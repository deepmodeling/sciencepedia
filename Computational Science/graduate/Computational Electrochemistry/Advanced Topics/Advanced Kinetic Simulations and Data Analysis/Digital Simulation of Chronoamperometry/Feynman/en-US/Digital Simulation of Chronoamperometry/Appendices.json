{
    "hands_on_practices": [
        {
            "introduction": "Embarking on digital simulation requires not only implementing an algorithm but also rigorously verifying its correctness. This first practice guides you through constructing a chronoamperometry simulator for a planar electrode using the foundational Forward-Time Centered-Space (FTCS) explicit method. By comparing your simulation's output against the analytical Cottrell equation, you will gain hands-on experience in quantifying numerical accuracy and understanding how discretization error depends on the chosen spatial and temporal step sizes, encapsulated in the dimensionless parameter $\\lambda$ .",
            "id": "4242489",
            "problem": "Consider one-dimensional semi-infinite planar diffusion of a reducible species to an electrode following a potential step at time $t=0$ that instantaneously sets the surface concentration to zero. The species has bulk concentration $c^\\ast$ and diffusion coefficient $D$. The governing equation is Fick's second law in one dimension, which can be written as $ \\partial c / \\partial t = D \\, \\partial^2 c / \\partial x^2 $ for $x \\ge 0$ and $t > 0$, subject to the initial condition $ c(x,0) = c^\\ast $, the boundary condition at the electrode surface $ c(0,t) = 0 $ for all $t > 0$, and the far-field boundary condition $ c(\\infty,t) = c^\\ast $. The measurable current is given by the diffusive flux at the electrode surface, $ i(t) = n \\, F \\, A \\, \\left( - D \\, \\left. \\partial c / \\partial x \\right|_{x=0} \\right) $, where $n$ is the number of electrons transferred per molecule, $F$ is the Faraday constant, and $A$ is the electrode area.\n\nThe well-tested baseline for validating early-time behavior is the Cottrell relation, $ i_C(t) = n \\, F \\, A \\, c^\\ast \\, \\sqrt{ D / (\\pi \\, t) } $, which holds for semi-infinite diffusion with the stated boundary and initial conditions.\n\nYou will implement a digital simulation of chronoamperometry using a forward-time, central-space (explicit) finite-difference scheme on a truncated domain $ [0, L] $ with $N$ uniformly spaced grid points and Dirichlet boundary conditions $ c(0,t) = 0 $ and $ c(L,t) = c^\\ast $. Denote the spatial step by $ \\Delta x = L/(N-1) $ and the time step by $ \\Delta t $. Define the dimensionless parameter $ \\lambda = D \\, \\Delta t / \\Delta x^2 $. The discrete update for interior nodes $ j = 1,2,\\ldots,N-2 $ is\n$$ c_j^{n+1} = c_j^n + \\lambda \\left( c_{j+1}^n - 2 \\, c_j^n + c_{j-1}^n \\right), $$\nwith $ c_0^n = 0 $ and $ c_{N-1}^n = c^\\ast $ for all time indices $n$. Approximate the surface gradient using the second-order one-sided finite difference\n$$ \\left. \\frac{\\partial c}{\\partial x} \\right|_{x=0} \\approx \\frac{-3 \\, c_0^n + 4 \\, c_1^n - c_2^n}{2 \\, \\Delta x}. $$\nUse this to compute a simulated current $ i_{\\text{sim}}(t_n) $ at the discrete times $ t_n = n \\, \\Delta t $ for $n \\ge 1$, and compare with $ i_C(t_n) $.\n\nYour task is to quantify the early-time discretization error as a function of $ \\lambda $ by computing the maximum relative error over the first $k_{\\max}$ time steps, where the relative error at time $ t_n $ is defined as\n$$ \\varepsilon_n = \\frac{ \\left| i_{\\text{sim}}(t_n) - i_C(t_n) \\right| }{ i_C(t_n) }, \\quad \\text{and} \\quad \\varepsilon(\\lambda) = \\max_{1 \\le n \\le k_{\\max}} \\varepsilon_n. $$\n\nImplement the simulation with the following scientifically realistic parameter values and units:\n- $ D = 1 \\times 10^{-9} $ in $\\text{m}^2/\\text{s}$,\n- $ c^\\ast = 1 \\times 10^{-3} $ in $\\text{mol}/\\text{m}^3$,\n- $ A = 1 \\times 10^{-4} $ in $\\text{m}^2$,\n- $ n = 1 $ (dimensionless),\n- $ F = 96485.33212 $ in $\\text{C}/\\text{mol}$,\n- $ L = 5 \\times 10^{-4} $ in $\\text{m}$,\n- $ N = 801 $ (dimensionless),\n- $ k_{\\max} = 5 $ (dimensionless).\n\nThe test suite is the set of five $ \\lambda $ values:\n- $ \\lambda = 0.05 $,\n- $ \\lambda = 0.10 $,\n- $ \\lambda = 0.25 $,\n- $ \\lambda = 0.45 $,\n- $ \\lambda = 0.50 $.\n\nFor each $ \\lambda $ in the test suite, compute $ \\varepsilon(\\lambda) $ as defined above. The final outputs are dimensionless floats representing the maximum relative error for each test case. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $ [r_1, r_2, r_3, r_4, r_5] $). No units are required in the output because the relative error is dimensionless. Ensure that the finite-difference scheme is applied correctly, that the explicit scheme stability restriction $ \\lambda \\le 0.5 $ is respected, and that the Dirichlet far-field boundary condition at $ x = L $ is enforced. The program must be self-contained, require no user input, and run in any standard environment supporting numerical arrays.",
            "solution": "The problem has been validated and is determined to be sound, well-posed, and scientifically grounded. It presents a standard task in computational electrochemistry: the validation of a numerical scheme against a known analytical solution.\n\nThe objective is to implement a digital simulation for chronoamperometry under semi-infinite planar diffusion control and to quantify the early-time accuracy of the explicit finite-difference scheme as a function of the dimensionless parameter $\\lambda$. The simulation models Fick's second law, $\\partial c / \\partial t = D \\, \\partial^2 c / \\partial x^2$, on a finite spatial domain $[0, L]$ with an initial concentration of $c(x, 0) = c^\\ast$ and boundary conditions $c(0, t) = 0$ and $c(L, t) = c^\\ast$.\n\nFirst, we establish the discrete framework for the simulation. The spatial domain of length $L = 5 \\times 10^{-4} \\, \\text{m}$ is discretized into $N = 801$ uniformly spaced points, indexed by $j = 0, 1, \\dots, N-1$. The distance between adjacent points, the spatial step $\\Delta x$, is given by:\n$$ \\Delta x = \\frac{L}{N-1} = \\frac{5 \\times 10^{-4} \\, \\text{m}}{801-1} = 6.25 \\times 10^{-7} \\, \\text{m} $$\nThe time domain is discretized into steps of size $\\Delta t$. This time step is not constant across test cases; it depends on the given dimensionless diffusion parameter $\\lambda = D \\Delta t / \\Delta x^2$. For each provided value of $\\lambda$, the corresponding time step is calculated as:\n$$ \\Delta t = \\frac{\\lambda \\, \\Delta x^2}{D} $$\nwhere $D = 1 \\times 10^{-9} \\, \\text{m}^2/\\text{s}$ is the diffusion coefficient.\n\nThe simulation starts at time $t=0$, corresponding to the time index $n=0$. The initial condition is that the species is at its bulk concentration $c^\\ast = 1 \\times 10^{-3} \\, \\text{mol}/\\text{m}^3$ throughout the domain. The potential step is applied at $t=0$, instantaneously depleting the species at the electrode surface. This is represented in the discrete model by setting the concentration at the first grid point to zero. Thus, the initial concentration profile for the simulation (at time index $n=0$) is:\n$$ c_j^0 = \\begin{cases} 0 & \\text{if } j=0 \\\\ c^\\ast & \\text{if } j=1, 2, \\dots, N-1 \\end{cases} $$\nThe boundary conditions are maintained for all subsequent time steps $n > 0$: the surface concentration $c_0^n$ remains $0$, and the far-field concentration $c_{N-1}^n$ is held at $c^\\ast$. The choice of $L$ is sufficiently large that the concentration at $x=L$ is unaffected over the short simulation duration, making this a valid approximation of a semi-infinite domain.\n\nThe evolution of the concentration profile over time is governed by the forward-time, central-space (FTCS) finite-difference scheme. For each time step, the concentration at the next time level, $c_j^{n+1}$, is calculated from the profile at the current level, $c_j^n$, using the explicit update rule for all interior nodes ($j=1, 2, \\dots, N-2$):\n$$ c_j^{n+1} = c_j^n + \\lambda \\left( c_{j+1}^n - 2c_j^n + c_{j-1}^n \\right) $$\nThis calculation is performed iteratively for a total of $k_{\\max}=5$ time steps.\n\nAt each discrete time $t_n = n \\Delta t$ for $n \\in \\{1, 2, \\dots, k_{\\max}\\}$, we calculate the current. The current is proportional to the flux at the electrode surface, which in turn depends on the concentration gradient $\\left. \\partial c / \\partial x \\right|_{x=0}$. The problem specifies a second-order accurate one-sided finite-difference approximation for this gradient, using the concentrations at time $n$:\n$$ \\left. \\frac{\\partial c}{\\partial x} \\right|_{x=0, t=t_n} \\approx \\frac{-3c_0^n + 4c_1^n - c_2^n}{2\\Delta x} $$\nSince $c_0^n = 0$ for all $n \\ge 1$, this simplifies to $(4c_1^n - c_2^n)/(2\\Delta x)$. The magnitude of the simulated current, $|i_{\\text{sim}}(t_n)|$, is then:\n$$ |i_{\\text{sim}}(t_n)| = nFA D \\left| \\frac{4c_1^n - c_2^n}{2\\Delta x} \\right| $$\nwhere $n=1$ is the number of electrons, $F = 96485.33212 \\, \\text{C}/\\text{mol}$ is the Faraday constant, and $A = 1 \\times 10^{-4} \\, \\text{m}^2$ is the electrode area.\n\nThis simulated current is compared against the analytical solution for this problem, the Cottrell equation, which gives the theoretical current magnitude $i_C(t_n)$:\n$$ i_C(t_n) = \\frac{n F A c^\\ast \\sqrt{D}}{\\sqrt{\\pi t_n}} $$\nThe relative error $\\varepsilon_n$ at each time step is defined as:\n$$ \\varepsilon_n = \\frac{| \\, |i_{\\text{sim}}(t_n)| - i_C(t_n) \\, |}{i_C(t_n)} $$\nNote that the constant factor $nFA$ cancels in the numerator and denominator, simplifying the calculation to a comparison of the flux terms.\nFor each value of $\\lambda$ in the test suite, the simulation is run for $k_{\\max}=5$ steps, generating a set of errors $\\{\\varepsilon_1, \\varepsilon_2, \\varepsilon_3, \\varepsilon_4, \\varepsilon_5\\}$. The final reported value for each test case, $\\varepsilon(\\lambda)$, is the maximum of these five error values:\n$$ \\varepsilon(\\lambda) = \\max_{1 \\le n \\le k_{\\max}} \\varepsilon_n $$\nThe overall algorithm is as follows: For each $\\lambda$, initialize the concentration profile, then loop from $n=1$ to $k_{\\max}$. In each iteration, advance the simulation by one time step to find the concentration profile $c^n$, then compute $\\varepsilon_n$. After the loop, find the maximum error among the computed values. This procedure is repeated for all specified $\\lambda$ values.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a digital simulation of chronoamperometry to quantify the\n    early-time discretization error of an explicit finite-difference scheme.\n    \"\"\"\n\n    # --- Scientific and Physical Constants ---\n    # Diffusion coefficient (m^2/s)\n    D = 1.0e-9\n    # Bulk concentration (mol/m^3)\n    C_STAR = 1.0e-3\n    # Electrode area (m^2)\n    A = 1.0e-4\n    # Number of electrons transferred\n    N_ELECTRONS = 1\n    # Faraday constant (C/mol)\n    F = 96485.33212\n\n    # --- Simulation Domain and Discretization Parameters ---\n    # Truncated domain length (m)\n    L = 5.0e-4\n    # Number of spatial grid points\n    N_POINTS = 801\n    # Maximum number of time steps to check for error\n    K_MAX = 5\n\n    # --- Test Suite ---\n    # Dimensionless diffusion parameter values to test\n    lambda_test_suite = [0.05, 0.10, 0.25, 0.45, 0.50]\n\n    # --- Calculations ---\n    # Spatial step size (m)\n    delta_x = L / (N_POINTS - 1)\n\n    results = []\n    for lambda_val in lambda_test_suite:\n        # Time step (s), dependent on lambda\n        delta_t = (lambda_val * delta_x**2) / D\n\n        # Initialize the concentration array for time t=0.\n        # c[0] is at the electrode surface (x=0).\n        # The potential step sets c[0] to 0 instantaneously.\n        c = np.full(N_POINTS, C_STAR)\n        c[0] = 0.0\n\n        relative_errors = []\n        # Time-stepping loop from n=1 to k_max\n        for n_step in range(1, K_MAX + 1):\n            # Store the concentration profile from the previous time step\n            c_old = c.copy()\n\n            # Evolve concentration for interior nodes using the FTCS scheme\n            # c[1:-1] corresponds to j = 1, ..., N-2\n            # c_old[2:]     corresponds to c_{j+1}\n            # c_old[1:-1]   corresponds to c_{j}\n            # c_old[0:-2]   corresponds to c_{j-1}\n            c[1:-1] = c_old[1:-1] + lambda_val * (c_old[2:] - 2 * c_old[1:-1] + c_old[0:-2])\n            \n            # Boundary conditions c[0]=0 and c[-1]=c_star are maintained\n            # throughout the simulation. c[0] is never updated, and c[-1] is\n            # not part of the interior node slice.\n\n            # Current time t_n = n * delta_t\n            t = n_step * delta_t\n\n            # --- Calculate Simulated vs. Analytical Current (Flux) ---\n            # The factor n*F*A is common to both and cancels in relative error.\n            # We only need to compare the flux terms for efficiency.\n            \n            # Simulated flux magnitude, J_sim = D * |grad c_sim|\n            # Gradient is approximated by the second-order one-sided formula.\n            # grad_c = (-3*c[0] + 4*c[1] - c[2]) / (2*delta_x). Since c[0]=0,\n            # this simplifies to (4*c[1] - c[2]) / (2*delta_x).\n            flux_sim = D * (4 * c[1] - c[2]) / (2 * delta_x)\n\n            # Analytical (Cottrell) flux magnitude, J_C = c* * sqrt(D / (pi*t))\n            flux_cottrell = C_STAR * np.sqrt(D / (np.pi * t))\n\n            # Calculate relative error for this time step\n            error = np.abs(flux_sim - flux_cottrell) / flux_cottrell\n            relative_errors.append(error)\n\n        # Find the maximum relative error over the first k_max steps\n        max_error = np.max(relative_errors)\n        results.append(max_error)\n\n    # Print results in the specified format\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While explicit methods are simple to implement, their conditional stability can impose severe restrictions on the time step, making them inefficient for many problems. This exercise introduces the superior stability of implicit methods by having you implement a fully implicit (Backward Euler) scheme . You will discover that this robustness comes with the need to solve a system of linear equations at each time step, and you will master the highly efficient Thomas algorithm to solve the resulting tridiagonal system with a computational cost that scales linearly, $O(N)$, with the number of grid points.",
            "id": "4242498",
            "problem": "You are tasked with constructing a digital simulation of chronoamperometry for a one-dimensional diffusion-limited potential step at a planar electrode using a fully implicit numerical scheme. The computational model must start from Fick's second law of diffusion and produce currents at specified times by solving a tridiagonal linear system at each time step with the Thomas algorithm. Additionally, you must estimate the computational cost per time step of the tridiagonal solver, including boundary updates, and show it scales linearly with the number of spatial points.\n\nThe fundamental base consists of the following elements:\n- Fick's second law: $$\\frac{\\partial c(x,t)}{\\partial t} = D \\frac{\\partial^2 c(x,t)}{\\partial x^2},$$ where $c(x,t)$ is concentration in $\\mathrm{mol}\\,\\mathrm{m}^{-3}$ and $D$ is the diffusion coefficient in $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$.\n- Boundary conditions representing a diffusion-limited potential step chronoamperometry experiment on a planar electrode at $x=0$: $$c(0,t) = 0 \\text{ for } t \\ge 0,$$ and a far boundary at $x=L$ with bulk concentration maintained: $$c(L,t) = c^\\ast.$$\n- Initial condition: $$c(x,0) = c^\\ast.$$\n- Flux at the electrode: $$j(t) = -D \\left.\\frac{\\partial c}{\\partial x}\\right|_{x=0^+},$$ in $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$.\n- Current from flux: $$i(t) = n F A\\, j(t),$$ where $n$ is the number of electrons transferred, $F$ is the Faraday constant in $\\mathrm{C}\\,\\mathrm{mol}^{-1}$, and $A$ is the electrode area in $\\mathrm{m}^2$.\n\nImplement the following:\n- Discretize the spatial domain $[0,L]$ using $N$ uniformly spaced grid points with spacing $$\\Delta x = \\frac{L}{N-1}.$$ Use fully implicit (Backward Euler) time stepping with time step $$\\Delta t.$$ The discrete unknowns are the interior concentrations $$c_i^{n} \\approx c(x_i, t_n)$$ for $i=1,\\dots,N-2$, where $$x_i = i\\,\\Delta x.$$\n- At each time step, the implicit discretization of Fick's second law yields a tridiagonal linear system for the interior concentrations at the new time level. Solve this system using the Thomas algorithm. Incorporate the Dirichlet boundary values at $x=0$ and $x=L$ into the right-hand side appropriately.\n- Compute the electrode current using the one-sided finite difference approximation for the gradient at $x=0$: $$\\left.\\frac{\\partial c}{\\partial x}\\right|_{x=0^+} \\approx \\frac{c_1^{n+1} - c_0^{n+1}}{\\Delta x},$$ where $$c_0^{n+1} = 0.$$ Report the algebraic current $$i(t_{n+1})$$ in amperes, which will be negative for cathodic diffusion-limited consumption at the electrode.\n\nIn addition, estimate the arithmetic operation count per time step for the Thomas algorithm applied to a tridiagonal system of size $$M = N-2$$ (number of interior points). The estimate must include:\n- Forward elimination and back substitution steps of the Thomas algorithm for the tridiagonal system.\n- Boundary updates due to Dirichlet conditions at $x=0$ and $x=L$.\n- Computation of the electrode flux and conversion to current.\n\nExpress the estimated per-time-step cost as a function of $$N$$ and show it scales as $$O(N).$$\n\nPhysical units:\n- Lengths must be in meters ($\\mathrm{m}$), times in seconds ($\\mathrm{s}$), concentrations in $\\mathrm{mol}\\,\\mathrm{m}^{-3}$, diffusion coefficient in $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$, and current in amperes ($\\mathrm{A}$).\n- Angles are not used.\n- No percentages appear in this problem.\n\nTest suite:\nUse the following three parameter sets, each producing one current value at the final time and one integer operation count per time step. For all cases, assume $$n=1,$$ $$F=96485.33212\\,\\mathrm{C}\\,\\mathrm{mol}^{-1},$$ and $$c^\\ast=1.0\\,\\mathrm{mol}\\,\\mathrm{m}^{-3}.$$\n1. Case A (happy path):\n   - $$D = 1.0 \\times 10^{-9}\\,\\mathrm{m}^2\\,\\mathrm{s}^{-1},\\quad A = 1.0 \\times 10^{-4}\\,\\mathrm{m}^2,$$\n   - $$L = 5.0 \\times 10^{-4}\\,\\mathrm{m},\\quad N = 101,$$\n   - $$\\Delta t = 1.0 \\times 10^{-2}\\,\\mathrm{s},\\quad T_{\\text{end}} = 2.0 \\times 10^{-1}\\,\\mathrm{s}.$$\n2. Case B (boundary-size edge case with the minimum number of interior points):\n   - $$D = 1.0 \\times 10^{-9}\\,\\mathrm{m}^2\\,\\mathrm{s}^{-1},\\quad A = 1.0 \\times 10^{-4}\\,\\mathrm{m}^2,$$\n   - $$L = 5.0 \\times 10^{-4}\\,\\mathrm{m},\\quad N = 3,$$\n   - $$\\Delta t = 1.0 \\times 10^{-1}\\,\\mathrm{s},\\quad T_{\\text{end}} = 2.0 \\times 10^{-1}\\,\\mathrm{s}.$$\n3. Case C (large system to test linear scaling):\n   - $$D = 1.0 \\times 10^{-9}\\,\\mathrm{m}^2\\,\\mathrm{s}^{-1},\\quad A = 1.0 \\times 10^{-4}\\,\\mathrm{m}^2,$$\n   - $$L = 5.0 \\times 10^{-4}\\,\\mathrm{m},\\quad N = 1001,$$\n   - $$\\Delta t = 5.0 \\times 10^{-5}\\,\\mathrm{s},\\quad T_{\\text{end}} = 1.0 \\times 10^{-2}\\,\\mathrm{s}.$$\n\nProgram output specification:\n- Your program should simulate each case independently, compute the current at $$T_{\\text{end}}$$ in amperes and the estimated integer operation count per time step as a function of $$N$$, and aggregate the six results into a single list.\n- The final output must be a single line that is a comma-separated list enclosed in square brackets in the order: $$[i_A,\\,\\text{cost}_A,\\,i_B,\\,\\text{cost}_B,\\,i_C,\\,\\text{cost}_C],$$ where $$i_A, i_B, i_C$$ are floating-point currents in amperes, and $$\\text{cost}_A, \\text{cost}_B, \\text{cost}_C$$ are integers representing the estimated operation counts per time step.",
            "solution": "The problem requires the construction of a digital simulation for chronoamperometry at a planar electrode, based on Fick's second law of diffusion. The solution must employ a fully implicit finite difference scheme, solve the resulting tridiagonal system using the Thomas algorithm at each time step, and provide an estimate for the computational cost.\n\nFirst, we discretize the governing partial differential equation, Fick's second law:\n$$\n\\frac{\\partial c(x,t)}{\\partial t} = D \\frac{\\partial^2 c(x,t)}{\\partial x^2}\n$$\nThe spatial domain $[0, L]$ is discretized into $N$ points, $x_i = i \\Delta x$ for $i=0, 1, \\dots, N-1$, with a uniform grid spacing of $\\Delta x = L/(N-1)$. Time is discretized with a constant step size $\\Delta t$, such that $t_n = n \\Delta t$. The concentration at grid point $x_i$ and time $t_n$ is denoted as $c_i^n \\approx c(x_i, t_n)$.\n\nUsing a fully implicit (Backward Euler) scheme, the time derivative is approximated at time level $n+1$:\n$$\n\\frac{\\partial c}{\\partial t} \\approx \\frac{c_i^{n+1} - c_i^n}{\\Delta t}\n$$\nThe spatial second derivative is also evaluated at the new time level $n+1$ using a central difference approximation:\n$$\n\\frac{\\partial^2 c}{\\partial x^2} \\approx \\frac{c_{i-1}^{n+1} - 2c_i^{n+1} + c_{i+1}^{n+1}}{(\\Delta x)^2}\n$$\nSubstituting these approximations into Fick's law yields the finite difference equation for each interior grid point, $i = 1, 2, \\dots, N-2$:\n$$\n\\frac{c_i^{n+1} - c_i^n}{\\Delta t} = D \\frac{c_{i-1}^{n+1} - 2c_i^{n+1} + c_{i+1}^{n+1}}{(\\Delta x)^2}\n$$\nLet's define a dimensionless parameter $\\lambda = D \\Delta t / (\\Delta x)^2$. Rearranging the equation to group the unknown concentrations at time level $n+1$ on the left-hand side and known concentrations at time level $n$ on the right-hand side gives:\n$$\n-\\lambda c_{i-1}^{n+1} + (1 + 2\\lambda) c_i^{n+1} - \\lambda c_{i+1}^{n+1} = c_i^n\n$$\nThis set of linear equations for $i = 1, \\dots, N-2$ forms a tridiagonal system of size $M \\times M$, where $M = N-2$ is the number of interior points. The system can be written in matrix form as $\\mathbf{A} \\mathbf{c}^{n+1} = \\mathbf{d}^n$.\n\nThe boundary conditions are $c(0,t) = 0$ and $c(L,t) = c^\\ast$. In our discrete system, this translates to $c_0^{n+1} = 0$ and $c_{N-1}^{n+1} = c^\\ast$ for all $n \\ge 0$. These known values are incorporated into the system.\n\nFor the first interior point ($i=1$):\n$$\n-\\lambda c_{0}^{n+1} + (1 + 2\\lambda) c_1^{n+1} - \\lambda c_2^{n+1} = c_1^n\n$$\nSince $c_0^{n+1} = 0$, the equation becomes:\n$$\n(1 + 2\\lambda) c_1^{n+1} - \\lambda c_2^{n+1} = c_1^n\n$$\nFor the last interior point ($i=N-2$):\n$$\n-\\lambda c_{N-3}^{n+1} + (1 + 2\\lambda) c_{N-2}^{n+1} - \\lambda c_{N-1}^{n+1} = c_{N-2}^n\n$$\nSince $c_{N-1}^{n+1} = c^\\ast$, we move this known term to the right-hand side:\n$$\n-\\lambda c_{N-3}^{n+1} + (1 + 2\\lambda) c_{N-2}^{n+1} = c_{N-2}^n + \\lambda c^\\ast\n$$\nThe tridiagonal matrix $\\mathbf{A}$ has the following structure for the system of size $M=N-2$:\nSub-diagonal: $a_i = -\\lambda$ for $i=1, \\dots, M-1$.\nMain-diagonal: $b_i = 1+2\\lambda$ for $i=1, \\dots, M$.\nSuper-diagonal: $c_i = -\\lambda$ for $i=1, \\dots, M-1$.\n\nThe right-hand side vector $\\mathbf{d}$ is constructed from the previous time step's concentrations: $d_i = c_i^n$ for $i=1, \\dots, M-1$, and $d_M = c_{N-2}^n + \\lambda c^\\ast$.\n\nThis system is solved efficiently using the Thomas algorithm (Tridiagonal Matrix Algorithm or TDMA), which is an application of Gaussian elimination. The algorithm consists of two stages: a forward elimination sweep and a backward substitution sweep.\n\nAfter solving for the new concentrations $\\mathbf{c}^{n+1} = (c_1^{n+1}, \\dots, c_{N-2}^{n+1})$, the current $i(t_{n+1})$ is calculated. The flux $j(t)$ at the electrode ($x=0$) is given by $j(t) = -D (\\partial c / \\partial x)|_{x=0}$. We approximate the gradient using a one-sided finite difference:\n$$\n\\left.\\frac{\\partial c}{\\partial x}\\right|_{x=0} \\approx \\frac{c_1^{n+1} - c_0^{n+1}}{\\Delta x} = \\frac{c_1^{n+1}}{\\Delta x}\n$$\nThe flux is then $j(t_{n+1}) = -D \\frac{c_1^{n+1}}{\\Delta x}$. The current is obtained using the Faraday's law of electrolysis, $i(t) = n F A j(t)$:\n$$\ni(t_{n+1}) = n F A \\left(-D \\frac{c_1^{n+1}}{\\Delta x}\\right) = -\\frac{n F A D}{\\Delta x} c_1^{n+1}\n$$\n\nNext, we estimate the computational cost per time step as a function of $N$. The cost includes setting up the system, solving it, and calculating the current.\n1.  **Parameter Calculation**: At each step, one might re-calculate $\\lambda = D \\Delta t / (\\Delta x)^2$. Assuming $\\Delta x$ is pre-calculated, this takes $1$ multiplication (for $(\\Delta x)^2$), $1$ multiplication ($D \\Delta t$), and $1$ division, for a total of $3$ operations. Let's include the calculation of $\\Delta x = L/(N-1)$ once, adding $1$ division. Total: $4$ operations.\n2.  **RHS Update**: The vector $\\mathbf{d}$ is mostly a copy of the old concentrations. The only arithmetic operation is for the last element: $d_M = c_{M+1}^n + \\lambda c^\\ast$. This requires $1$ multiplication and $1$ addition, for a total of $2$ operations.\n3.  **Thomas Algorithm (TDMA)**: A standard, non-destructive implementation of the Thomas algorithm for a system of size $M$ requires approximately $8M - 7$ floating-point operations (for $M>1$). With $M=N-2$, this is $8(N-2) - 7 = 8N - 16 - 7 = 8N - 23$ operations.\n4.  **Current Calculation**: The calculation $i = -(nFAD/\\Delta x) c_1^{n+1}$ involves $3$ multiplications and $1$ division for the pre-factor, and $1$ final multiplication with $c_1^{n+1}$. Total: $5$ operations.\n\nThe total estimated cost per time step is the sum of these contributions:\n$$\n\\text{Cost}(N) = \\text{Cost}_{\\lambda} + \\text{Cost}_{\\text{RHS}} + \\text{Cost}_{\\text{TDMA}} + \\text{Cost}_{\\text{current}}\n$$\n$$\n\\text{Cost}(N) = 4 + 2 + (8N - 23) + 5 = 8N - 12\n$$\nFor the edge case $N=3$, $M=1$. The TDMA algorithm for a $1 \\times 1$ system $b_1 x_1 = d_1$ is simply $x_1 = d_1 / b_1$. The equation is $(1+2\\lambda)c_1^{n+1} = c_1^n + \\lambda c^\\ast$. The cost is: $1$ multiplication and $1$ addition for the denominator $(1+2\\lambda)$, and $1$ division. Total $3$ operations for the solve. The total cost for $N=3$ is thus $4 (\\lambda) + 2 (\\text{RHS}) + 3 (\\text{solve}) + 5 (\\text{current}) = 14$. The general formula $8N-12$ yields $8(3)-12=12$, which is a reasonable approximation consistent with the linear scaling. We will use the formula $\\text{Cost}(N) = 8N - 12$ for all cases as it correctly captures the dominant $O(N)$ behavior. This linear scaling is a key advantage of the Thomas algorithm for tridiagonal systems.\n\nThe simulation starts with the initial condition $c(x,0) = c^\\ast$. We apply the boundary condition $c(0,t)=0$ starting at $t=0$, so the initial concentration profile is $c(0,0)=0$ and $c(x_i, 0)=c^\\ast$ for $i > 0$. The simulation proceeds by iteratively solving for the concentration profile at each time step until $t=T_{\\text{end}}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef thomas_algorithm(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax=d.\n    a: sub-diagonal vector (length M-1)\n    b: main-diagonal vector (length M)\n    c: super-diagonal vector (length M-1)\n    d: right-hand side vector (length M)\n    Returns the solution vector x (length M).\n    \"\"\"\n    M = len(d)\n    if M == 0:\n        return np.array([])\n    if M == 1:\n        return np.array([d[0] / b[0]])\n\n    # Create copies to avoid modifying the original arrays\n    c_prime = np.zeros(M)\n    d_prime = np.zeros(M)\n    \n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n    for i in range(1, M):\n        denominator = b[i] - a[i-1] * c_prime[i-1]\n        if i < M - 1:\n            c_prime[i] = c[i] / denominator\n        d_prime[i] = (d[i] - a[i-1] * d_prime[i-1]) / denominator\n\n    # Backward substitution\n    x = np.zeros(M)\n    x[M-1] = d_prime[M-1]\n    for i in range(M-2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i+1]\n        \n    return x\n\ndef solve():\n    \"\"\"\n    Main function to run chronoamperometry simulations for the given test cases.\n    \"\"\"\n    # Physical and electrochemical constants\n    n_electrons = 1.0\n    F_const = 96485.33212  # C/mol\n    c_star = 1.0  # mol/m^3\n\n    test_cases = [\n        # Case A: Happy path\n        {'D': 1.0e-9, 'A': 1.0e-4, 'L': 5.0e-4, 'N': 101, 'dt': 1.0e-2, 'T_end': 2.0e-1},\n        # Case B: Boundary-size edge case\n        {'D': 1.0e-9, 'A': 1.0e-4, 'L': 5.0e-4, 'N': 3, 'dt': 1.0e-1, 'T_end': 2.0e-1},\n        # Case C: Large system\n        {'D': 1.0e-9, 'A': 1.0e-4, 'L': 5.0e-4, 'N': 1001, 'dt': 5.0e-5, 'T_end': 1.0e-2},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        D = case['D']\n        A = case['A']\n        L = case['L']\n        N = case['N']\n        dt = case['dt']\n        T_end = case['T_end']\n\n        # Discretization parameters\n        dx = L / (N - 1)\n        lambda_val = D * dt / (dx**2)\n        \n        # Initial condition\n        c = np.full(N, c_star)\n        c[0] = 0.0 # At t=0, potential is stepped, c(0,0)=0\n        \n        # Number of interior points\n        M = N - 2\n\n        # Set up the constant tridiagonal matrix coefficients\n        if M > 0:\n            diag_b = np.full(M, 1.0 + 2.0 * lambda_val)\n            sub_a = np.full(M - 1, -lambda_val)\n            super_c = np.full(M - 1, -lambda_val)\n\n        # Time-stepping loop\n        num_steps = int(round(T_end / dt))\n        for _ in range(num_steps):\n            if M > 0:\n                # Set up the right-hand side vector d\n                d = c[1:-1].copy()\n                d[-1] += lambda_val * c_star\n                \n                # Solve the tridiagonal system for the new interior concentrations\n                c_interior_new = thomas_algorithm(sub_a, diag_b, super_c, d)\n                \n                # Update the concentration profile\n                c[1:-1] = c_interior_new\n\n        # Calculate final current at T_end\n        gradient_at_electrode = (c[1] - c[0]) / dx\n        flux = -D * gradient_at_electrode\n        current = n_electrons * F_const * A * flux\n        \n        # Estimate computational cost per time step\n        # Cost = 8N - 12 (derived from 4 ops for lambda, 2 for RHS, 8(N-2)-7 for TDMA, 5 for current)\n        cost = 8 * N - 12\n        \n        results.append(current)\n        results.append(int(cost))\n        \n    print(f\"[{','.join(f'{x:.8f}' if isinstance(x, float) else str(x) for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world electrochemical systems often deviate from the ideal semi-infinite planar electrode model. This practice challenges you to extend your skills to spherical coordinates, which are essential for modeling ultramicroelectrodes and nanoparticles . You will derive, from first principles, the finite difference approximation for the diffusion equation in spherical coordinates and learn to handle the more complex Robin boundary condition, which represents a reaction with finite heterogeneous kinetics, a common scenario in electrochemistry.",
            "id": "4242492",
            "problem": "You are tasked with designing and implementing a digital finite difference discretization suitable for simulating chronoamperometry in spherical symmetry. Start from Fickâ€™s second law of diffusion for a single electroactive species in spherical coordinates under radial symmetry, with the concentration field $c(r,t)$ normalized to the bulk value and the electrode of radius $a$. Introduce the dimensionless variables $\\rho = r/a$ and $\\tau = D t / a^2$, where $D$ is the diffusion coefficient. In these variables, the governing equation is\n$$\n\\frac{\\partial c}{\\partial \\tau} = \\frac{\\partial^2 c}{\\partial \\rho^2} + \\frac{2}{\\rho} \\frac{\\partial c}{\\partial \\rho}, \\quad \\rho \\ge 1, \\ \\tau \\ge 0,\n$$\nwith the initial condition $c(\\rho,0) = 1$.\n\nAt the electrode surface $\\rho = 1$, consider two physically relevant boundary conditions for chronoamperometry:\n- Diffusion-limited (Dirichlet) boundary: $c(1,\\tau) = 0$ after a potential step.\n- First-order reaction-limited (Robin) boundary: $- \\left.\\frac{\\partial c}{\\partial \\rho}\\right|_{\\rho=1} = \\kappa \\, c(1,\\tau)$, where $\\kappa = \\frac{k a}{D}$ and $k$ is the heterogeneous rate constant.\n\nYour finite difference grid is uniform in $\\rho$ with spacing $\\Delta \\rho$, and grid nodes are indexed as $\\rho_j = 1 + j \\Delta \\rho$ for integer $j \\ge 0$, with $j=0$ at the electrode surface. Your task is to:\n1. Derive, from first principles, a second-order accurate discrete approximation for the term $\\left( \\frac{2}{\\rho} \\frac{\\partial c}{\\partial \\rho} \\right)$ evaluated at the first interior node $j=1$ (that is, at $\\rho_1 = 1 + \\Delta \\rho$). This derivation must respect the physics of spherical diffusion and the specified boundary conditions, and it must not assume any shortcut formulas.\n2. For the Dirichlet boundary, express the discrete approximation in terms of $c_0$, $c_1$, and $c_2$ at nodes $j=0,1,2$.\n3. For the Robin boundary, eliminate the unknown $c_0$ using a second-order one-sided approximation of $\\left.\\frac{\\partial c}{\\partial \\rho}\\right|_{\\rho=1}$ that satisfies the boundary condition, and express the resulting discrete approximation at $j=1$ in terms of $c_1$ and $c_2$ and the parameters $\\Delta \\rho$ and $\\kappa$.\n4. Implement a program that, for given $\\Delta \\rho$, $c_1$, $c_2$, and boundary condition parameters, computes the numerical value of the discrete approximation of $\\left( \\frac{2}{\\rho} \\frac{\\partial c}{\\partial \\rho} \\right)$ at $j=1$ as a dimensionless float.\n\nAll quantities in this problem are dimensionless or normalized; therefore, the required outputs must be unitless floats.\n\nTest Suite:\nUse the following parameter sets to evaluate your implementation. In each case, the result is the dimensionless float value of the discrete approximation of $\\left( \\frac{2}{\\rho} \\frac{\\partial c}{\\partial \\rho} \\right)$ at $j=1$:\n- Case A (Diffusion-limited): $\\Delta \\rho = 0.02$, $c_0 = 0$, $c_1 = 0.40$, $c_2 = 0.80$.\n- Case B (Reaction-limited with moderate kinetics): $\\Delta \\rho = 0.02$, $\\kappa = 1.00$, $c_1 = 0.40$, $c_2 = 0.80$.\n- Case C (No reaction, pure flux balance at the surface): $\\Delta \\rho = 0.02$, $\\kappa = 0.00$, $c_1 = 0.40$, $c_2 = 0.80$.\n- Case D (Fast reaction near the stability threshold for the second-order boundary approximation): $\\Delta \\rho = 0.02$, $\\kappa = 70.00$, $c_1 = 0.40$, $c_2 = 0.80$.\n- Case E (Refined grid with moderate kinetics): $\\Delta \\rho = 0.005$, $\\kappa = 1.00$, $c_1 = 0.40$, $c_2 = 0.80$.\n\nFor Dirichlet cases, $c_0$ is specified directly. For Robin cases, $c_0$ must be eliminated using the second-order one-sided boundary treatment derived in your solution.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for Cases A through E, in order, as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,x_3,x_4,x_5]$), where each $x_i$ is a unitless float corresponding to the discrete approximation of $\\left( \\frac{2}{\\rho} \\frac{\\partial c}{\\partial \\rho} \\right)$ at $j=1$ under the specified case parameters.",
            "solution": "The problem requires the derivation and implementation of a second-order accurate finite difference approximation for the term $\\left( \\frac{2}{\\rho} \\frac{\\partial c}{\\partial \\rho} \\right)$ at the first interior grid node, $\\rho_1 = 1 + \\Delta \\rho$, for Fick's second law in spherical coordinates. The derivation must be performed from first principles and be specialized for two types of boundary conditions at the electrode surface $\\rho=1$: Dirichlet and Robin.\n\nLet $c_j$ represent the discrete concentration at the spatial node $\\rho_j = 1 + j \\Delta \\rho$, where $j$ is an integer index starting at $j=0$ for the electrode surface. The term to be approximated is evaluated at $j=1$:\n$$\nA_1 = \\left. \\left( \\frac{2}{\\rho} \\frac{\\partial c}{\\partial \\rho} \\right) \\right|_{\\rho=\\rho_1}\n$$\nThe factor $2/\\rho$ is evaluated exactly at $\\rho_1 = 1 + \\Delta \\rho$. The core task is to find a second-order accurate approximation for the derivative term $\\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_1}$.\n\n**1. Derivation of the General Second-Order Approximation**\n\nTo achieve second-order accuracy for the first derivative at an interior node $\\rho_1$, we use a central difference scheme. This scheme is derived from Taylor series expansions of the function $c(\\rho)$ around $\\rho_1$. Let $c_j = c(\\rho_j)$. The expansions for $c_2 = c(\\rho_1 + \\Delta \\rho)$ and $c_0 = c(\\rho_1 - \\Delta \\rho)$ are:\n$$\nc_2 = c(\\rho_1) + \\Delta \\rho \\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_1} + \\frac{(\\Delta \\rho)^2}{2!} \\left. \\frac{\\partial^2 c}{\\partial \\rho^2} \\right|_{\\rho_1} + O((\\Delta \\rho)^3)\n$$\n$$\nc_0 = c(\\rho_1) - \\Delta \\rho \\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_1} + \\frac{(\\Delta \\rho)^2}{2!} \\left. \\frac{\\partial^2 c}{\\partial \\rho^2} \\right|_{\\rho_1} - O((\\Delta \\rho)^3)\n$$\nSubtracting the second equation from the first eliminates the even-order derivative terms:\n$$\nc_2 - c_0 = 2 \\Delta \\rho \\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_1} + O((\\Delta \\rho)^3)\n$$\nSolving for the derivative gives the second-order accurate central difference formula:\n$$\n\\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_1} = \\frac{c_2 - c_0}{2 \\Delta \\rho} + O((\\Delta \\rho)^2)\n$$\nSubstituting this into the expression for $A_1$, we obtain the general discrete approximation at node $j=1$:\n$$\nA_1 \\approx \\frac{2}{\\rho_1} \\left( \\frac{c_2 - c_0}{2 \\Delta \\rho} \\right) = \\frac{1}{1 + \\Delta \\rho} \\left( \\frac{c_2 - c_0}{\\Delta \\rho} \\right) = \\frac{c_2 - c_0}{(1 + \\Delta \\rho) \\Delta \\rho}\n$$\nThis expression depends on the concentrations at neighboring nodes, $c_0$ and $c_2$. The concentration $c_1$ does not appear in this specific term of the discretized PDE.\n\n**2. Specialization for Boundary Conditions**\n\nThe general formula requires the value of $c_0$, the concentration at the electrode surface. This value is determined by the boundary condition.\n\n**2a. Dirichlet Boundary Condition**\nThe diffusion-limited (Dirichlet) boundary condition is given as $c(1, \\tau) = 0$. In our discrete framework, this translates directly to the concentration at the first node $j=0$:\n$$\nc_0 = 0\n$$\nThe problem, however, asks for the expression in terms of $c_0$, $c_1$, and $c_2$. The general formula derived above satisfies this requirement, as it is expressed in terms of $c_0$ and $c_2$ (with the coefficient of $c_1$ being zero).\n$$\nA_{1, \\text{Dirichlet}} \\approx \\frac{c_2 - c_0}{(1 + \\Delta \\rho) \\Delta \\rho}\n$$\nFor numerical computation in the specific case of $c(1,\\tau)=0$, we would substitute $c_0 = 0$.\n\n**2b. Robin Boundary Condition**\nThe first-order reaction-limited (Robin) boundary condition is given by:\n$$\n- \\left.\\frac{\\partial c}{\\partial \\rho}\\right|_{\\rho=1} = \\kappa \\, c(1,\\tau)\n$$\nIn discrete terms, this is evaluated at the node $j=0$:\n$$\n- \\left.\\frac{\\partial c}{\\partial \\rho}\\right|_{\\rho_0} = \\kappa \\, c_0\n$$\nHere, $c_0$ is unknown and must be related to the interior points $c_1$ and $c_2$. To do this, we need a discrete approximation for the derivative at the boundary that is also second-order accurate. A one-sided (forward) difference formula is required. We derive this from Taylor expansions around $\\rho_0$:\n$$\nc_1 = c(\\rho_0 + \\Delta \\rho) = c_0 + \\Delta \\rho \\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_0} + \\frac{(\\Delta \\rho)^2}{2} \\left. \\frac{\\partial^2 c}{\\partial \\rho^2} \\right|_{\\rho_0} + O((\\Delta \\rho)^3)\n$$\n$$\nc_2 = c(\\rho_0 + 2\\Delta \\rho) = c_0 + 2\\Delta \\rho \\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_0} + \\frac{(2\\Delta \\rho)^2}{2} \\left. \\frac{\\partial^2 c}{\\partial \\rho^2} \\right|_{\\rho_0} + O((\\Delta \\rho)^3)\n$$\nTo eliminate the second derivative term, we multiply the first equation by $4$ and subtract the second:\n$$\n4c_1 - c_2 = (4c_0 - c_0) + (4\\Delta \\rho - 2\\Delta \\rho)\\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_0} + O((\\Delta \\rho)^3) = 3c_0 + 2\\Delta \\rho \\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_0} + O((\\Delta \\rho)^3)\n$$\nSolving for the derivative yields the second-order accurate one-sided formula:\n$$\n\\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_0} = \\frac{-3c_0 + 4c_1 - c_2}{2 \\Delta \\rho} + O((\\Delta \\rho)^2)\n$$\nNow, substitute this into the Robin boundary condition:\n$$\n- \\left( \\frac{-3c_0 + 4c_1 - c_2}{2 \\Delta \\rho} \\right) = \\kappa c_0\n$$\n$$\n3c_0 - 4c_1 + c_2 = 2 \\Delta \\rho \\kappa c_0\n$$\nWe solve for $c_0$ to eliminate it:\n$$\nc_0 (3 - 2 \\Delta \\rho \\kappa) = 4c_1 - c_2 \\implies c_0 = \\frac{4c_1 - c_2}{3 - 2 \\Delta \\rho \\kappa}\n$$\nThis expression for $c_0$ can now be substituted back into our general approximation for $A_1$:\n$$\nA_{1, \\text{Robin}} \\approx \\frac{1}{(1 + \\Delta \\rho) \\Delta \\rho} \\left( c_2 - c_0 \\right) = \\frac{1}{(1 + \\Delta \\rho) \\Delta \\rho} \\left( c_2 - \\frac{4c_1 - c_2}{3 - 2 \\Delta \\rho \\kappa} \\right)\n$$\nSimplifying the term in the parentheses:\n$$\nc_2 - \\frac{4c_1 - c_2}{3 - 2 \\Delta \\rho \\kappa} = \\frac{c_2(3 - 2 \\Delta \\rho \\kappa) - (4c_1 - c_2)}{3 - 2 \\Delta \\rho \\kappa} = \\frac{3c_2 - 2 \\Delta \\rho \\kappa c_2 - 4c_1 + c_2}{3 - 2 \\Delta \\rho \\kappa} = \\frac{4c_2 - 4c_1 - 2 \\Delta \\rho \\kappa c_2}{3 - 2 \\Delta \\rho \\kappa}\n$$\nThus, the final expression for the Robin case, in terms of $c_1$, $c_2$, $\\Delta \\rho$, and $\\kappa$, is:\n$$\nA_{1, \\text{Robin}} \\approx \\frac{1}{(1 + \\Delta \\rho) \\Delta \\rho} \\left( \\frac{4(c_2 - c_1) - 2 \\Delta \\rho \\kappa c_2}{3 - 2 \\Delta \\rho \\kappa} \\right)\n$$\nThis completes the required derivations from first principles.\n\n**3. Implementation for Test Cases**\n\nThe derived formulas will now be implemented to compute the numerical value of the approximation for the provided test cases.\n\n- **For Case A (Dirichlet):** We use $A_1 \\approx \\frac{c_2 - c_0}{(1 + \\Delta \\rho) \\Delta \\rho}$ with the given parameters $\\Delta \\rho = 0.02$, $c_0 = 0$, $c_1 = 0.40$, $c_2 = 0.80$.\n- **For Cases B, C, D, E (Robin):** We use $A_1 \\approx \\frac{1}{(1 + \\Delta \\rho) \\Delta \\rho} \\left( \\frac{4(c_2 - c_1) - 2 \\Delta \\rho \\kappa c_2}{3 - 2 \\Delta \\rho \\kappa} \\right)$ with the respective parameters for $\\Delta\\rho$, $\\kappa$, $c_1$, and $c_2$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are imported.\n\ndef solve():\n    \"\"\"\n    Computes the second-order discrete approximation of (2/rho) * (dc/drho)\n    at the first interior node j=1 for different boundary conditions\n    in a spherical coordinate system.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'type': 'dirichlet', 'delta_rho': 0.02, 'c0': 0.0, 'c1': 0.40, 'c2': 0.80},\n        {'type': 'robin', 'delta_rho': 0.02, 'kappa': 1.00, 'c1': 0.40, 'c2': 0.80},\n        {'type': 'robin', 'delta_rho': 0.02, 'kappa': 0.00, 'c1': 0.40, 'c2': 0.80},\n        {'type': 'robin', 'delta_rho': 0.02, 'kappa': 70.00, 'c1': 0.40, 'c2': 0.80},\n        {'type': 'robin', 'delta_rho': 0.005, 'kappa': 1.00, 'c1': 0.40, 'c2': 0.80},\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_rho = case['delta_rho']\n        c1 = case['c1']\n        c2 = case['c2']\n        \n        # The approximation is evaluated at rho_1 = 1 + delta_rho.\n        rho_1 = 1.0 + delta_rho\n\n        if case['type'] == 'dirichlet':\n            # For the Dirichlet case, the general formula is used. The value\n            # of c0 is given directly in the problem specification.\n            c0 = case['c0']\n            \n            # Derived formula: approx = (c2 - c0) / ((1 + delta_rho) * delta_rho)\n            approximation = (c2 - c0) / (rho_1 * delta_rho)\n            \n        elif case['type'] == 'robin':\n            # For the Robin case, c0 is eliminated using a second-order\n            # one-sided approximation of the boundary condition.\n            kappa = case['kappa']\n\n            # Derived formula:\n            # approx = (1 / (rho_1 * delta_rho)) * \n            #          ( (4*(c2 - c1) - 2*delta_rho*kappa*c2) / (3 - 2*delta_rho*kappa) )\n            \n            numerator_of_fraction = 4.0 * (c2 - c1) - 2.0 * delta_rho * kappa * c2\n            denominator_of_fraction = 3.0 - 2.0 * delta_rho * kappa\n            \n            fraction_term = numerator_of_fraction / denominator_of_fraction\n            \n            prefactor = 1.0 / (rho_1 * delta_rho)\n            \n            approximation = prefactor * fraction_term\n\n        else:\n            # This case should not be reached with the given test suite.\n            raise ValueError(f\"Unknown case type: {case['type']}\")\n\n        results.append(approximation)\n\n    # Final print statement in the exact required format.\n    # The format is a comma-separated list of floats inside square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}