{
    "hands_on_practices": [
        {
            "introduction": "计时安培法的模拟之旅始于最直接的方法：显式前向时间中心空间（FTCS）法。本练习将指导您为平面电极建立模拟，并且最重要的是，对照精确的科特雷尔（Cottrell）解析解来验证您的数值结果。通过这个练习 ，您将获得误差分析的第一手经验，并了解无量纲参数 $\\lambda$ 如何决定模拟的准确性。",
            "id": "4242489",
            "problem": "考虑一个可还原物种在一维半无限平面上向电极的扩散，在时间 $t=0$ 时施加一个电位阶跃，使电极表面浓度瞬时变为零。该物种的体相浓度为 $c^\\ast$，扩散系数为 $D$。控制方程为一维菲克第二定律，可写作 $ \\partial c / \\partial t = D \\, \\partial^2 c / \\partial x^2 $，其中 $x \\ge 0$ 且 $t > 0$。该方程受以下条件约束：初始条件 $ c(x,0) = c^\\ast $，电极表面边界条件 $ c(0,t) = 0 $（对于所有 $t > 0$），以及远场边界条件 $ c(\\infty,t) = c^\\ast $。可测量的电流由电极表面的扩散通量给出，即 $ i(t) = n \\, F \\, A \\, \\left( - D \\, \\left. \\partial c / \\partial x \\right|_{x=0} \\right) $，其中 $n$ 是每个分子转移的电子数，$F$ 是法拉第常数，$A$ 是电极面积。\n\n用于验证早期行为的、经过充分检验的基准是 Cottrell 关系式，$ i_C(t) = n \\, F \\, A \\, c^\\ast \\, \\sqrt{ D / (\\pi \\, t) } $。该关系式在所述边界条件和初始条件下对半无限扩散成立。\n\n您将使用前向时间、中心空间（显式）有限差分格式，在一个具有 $N$ 个均匀间隔网格点的截断域 $ [0, L] $ 上，实现计时电流法的数字模拟，并采用狄利克雷边界条件 $ c(0,t) = 0 $ 和 $ c(L,t) = c^\\ast $。将空间步长记为 $ \\Delta x = L/(N-1) $，时间步长记为 $ \\Delta t $。定义无量纲参数 $ \\lambda = D \\, \\Delta t / \\Delta x^2 $。对于内部节点 $ j = 1,2,\\ldots,N-2 $ 的离散更新公式为\n$$ c_j^{n+1} = c_j^n + \\lambda \\left( c_{j+1}^n - 2 \\, c_j^n + c_{j-1}^n \\right), $$\n其中对于所有时间索引 $n$，有 $ c_0^n = 0 $ 和 $ c_{N-1}^n = c^\\ast $。使用二阶单边有限差分近似表面梯度\n$$ \\left. \\frac{\\partial c}{\\partial x} \\right|_{x=0} \\approx \\frac{-3 \\, c_0^n + 4 \\, c_1^n - c_2^n}{2 \\, \\Delta x}. $$\n利用此公式计算在离散时间 $ t_n = n \\, \\Delta t $（$n \\ge 1$）时的模拟电流 $ i_{\\text{sim}}(t_n) $，并与 $ i_C(t_n) $ 进行比较。\n\n您的任务是通过计算前 $k_{\\max}$ 个时间步长的最大相对误差来量化作为 $ \\lambda $ 函数的早期离散化误差。其中，时间 $ t_n $ 的相对误差定义为\n$$ \\varepsilon_n = \\frac{ \\left| i_{\\text{sim}}(t_n) - i_C(t_n) \\right| }{ i_C(t_n) }, \\quad \\text{且} \\quad \\varepsilon(\\lambda) = \\max_{1 \\le n \\le k_{\\max}} \\varepsilon_n. $$\n\n使用以下科学上符合实际的参数值和单位来实现模拟：\n- $ D = 1 \\times 10^{-9} $，单位 $\\text{m}^2/\\text{s}$，\n- $ c^\\ast = 1 \\times 10^{-3} $，单位 $\\text{mol}/\\text{m}^3$，\n- $ A = 1 \\times 10^{-4} $，单位 $\\text{m}^2$，\n- $ n = 1 $（无量纲），\n- $ F = 96485.33212 $，单位 $\\text{C}/\\text{mol}$，\n- $ L = 5 \\times 10^{-4} $，单位 $\\text{m}$，\n- $ N = 801 $（无量纲），\n- $ k_{\\max} = 5 $（无量纲）。\n\n测试集是以下五个 $ \\lambda $ 值：\n- $ \\lambda = 0.05 $,\n- $ \\lambda = 0.10 $,\n- $ \\lambda = 0.25 $,\n- $ \\lambda = 0.45 $,\n- $ \\lambda = 0.50 $.\n\n对于测试集中的每个 $ \\lambda $，计算如上定义的 $ \\varepsilon(\\lambda) $。最终输出是代表每个测试用例最大相对误差的无量纲浮点数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$ [r_1, r_2, r_3, r_4, r_5] $）。由于相对误差是无量纲的，因此输出中不需要单位。请确保有限差分格式被正确应用，显式格式的稳定性限制 $ \\lambda \\le 0.5 $ 得到遵守，并且在 $ x = L $ 处的狄利克雷远场边界条件被强制执行。程序必须是自包含的，不需要用户输入，并且能在任何支持数值数组的标准环境中运行。",
            "solution": "该问题已经过验证，被确定为是合理、适定且有科学依据的。它提出了计算电化学中的一个标准任务：针对一个已知的解析解来验证一个数值格式。\n\n其目标是实现一个在半无限平面扩散控制下的计时电流法数字模拟，并量化显式有限差分格式作为无量纲参数 $\\lambda$ 的函数的早期精度。该模拟在有限空间域 $[0, L]$ 上对菲克第二定律 $\\partial c / \\partial t = D \\, \\partial^2 c / \\partial x^2$ 进行建模，初始浓度为 $c(x, 0) = c^\\ast$，边界条件为 $c(0, t) = 0$ 和 $c(L, t) = c^\\ast$。\n\n首先，我们为模拟建立离散框架。长度为 $L = 5 \\times 10^{-4} \\, \\text{m}$ 的空间域被离散为 $N = 801$ 个均匀间隔的点，索引为 $j = 0, 1, \\dots, N-1$。相邻点之间的距离，即空间步长 $\\Delta x$，由下式给出：\n$$ \\Delta x = \\frac{L}{N-1} = \\frac{5 \\times 10^{-4} \\, \\text{m}}{801-1} = 6.25 \\times 10^{-7} \\, \\text{m} $$\n时间域被离散为大小为 $\\Delta t$ 的步长。这个时间步长在不同测试用例中不是恒定的；它取决于给定的无量纲扩散参数 $\\lambda = D \\Delta t / \\Delta x^2$。对于每个给定的 $\\lambda$ 值，相应的时间步长计算如下：\n$$ \\Delta t = \\frac{\\lambda \\, \\Delta x^2}{D} $$\n其中 $D = 1 \\times 10^{-9} \\, \\text{m}^2/\\text{s}$ 是扩散系数。\n\n模拟从时间 $t=0$ 开始，对应于时间索引 $n=0$。初始条件是物种在整个域中都处于其体相浓度 $c^\\ast = 1 \\times 10^{-3} \\, \\text{mol}/\\text{m}^3$。在 $t=0$ 时施加电位阶跃，瞬时耗尽电极表面的物种。在离散模型中，这通过将第一个网格点的浓度设置为零来表示。因此，模拟的初始浓度分布（在时间索引 $n=0$ 时）为：\n$$ c_j^0 = \\begin{cases} 0  \\text{若 } j=0 \\\\ c^\\ast  \\text{若 } j=1, 2, \\dots, N-1 \\end{cases} $$\n对于所有后续的时间步 $n > 0$，边界条件都保持不变：表面浓度 $c_0^n$ 保持为 $0$，远场浓度 $c_{N-1}^n$ 保持为 $c^\\ast$。$L$ 的选择足够大，使得在短暂的模拟时长内，$x=L$ 处的浓度不受影响，这使其成为对半无限域的有效近似。\n\n浓度分布随时间的演化由前向时间、中心空间（FTCS）有限差分格式控制。对于每个时间步，下一时间层级的浓度 $c_j^{n+1}$ 是根据当前层级的分布 $c_j^n$，使用对所有内部节点（$j=1, 2, \\dots, N-2$）的显式更新规则计算得出的：\n$$ c_j^{n+1} = c_j^n + \\lambda \\left( c_{j+1}^n - 2c_j^n + c_{j-1}^n \\right) $$\n这个计算会迭代执行总共 $k_{\\max}=5$ 个时间步。\n\n在每个离散时间 $t_n = n \\Delta t$（$n \\in \\{1, 2, \\dots, k_{\\max}\\}$），我们计算电流。电流与电极表面的通量成正比，而通量又取决于浓度梯度 $\\left. \\partial c / \\partial x \\right|_{x=0}$。该问题指定了使用时间 $n$ 的浓度来计算此梯度的二阶精度单边有限差分近似：\n$$ \\left. \\frac{\\partial c}{\\partial x} \\right|_{x=0, t=t_n} \\approx \\frac{-3c_0^n + 4c_1^n - c_2^n}{2\\Delta x} $$\n由于对于所有 $n \\ge 1$ 都有 $c_0^n = 0$，这简化为 $(4c_1^n - c_2^n)/(2\\Delta x)$。模拟电流的大小 $|i_{\\text{sim}}(t_n)|$ 于是为：\n$$ |i_{\\text{sim}}(t_n)| = nFA D \\left| \\frac{4c_1^n - c_2^n}{2\\Delta x} \\right| $$\n其中 $n=1$ 是电子数，$F = 96485.33212 \\, \\text{C}/\\text{mol}$ 是法拉第常数，$A = 1 \\times 10^{-4} \\, \\text{m}^2$ 是电极面积。\n\n将这个模拟电流与该问题的解析解——Cottrell 方程进行比较，后者给出了理论电流大小 $i_C(t_n)$：\n$$ i_C(t_n) = \\frac{n F A c^\\ast \\sqrt{D}}{\\sqrt{\\pi t_n}} $$\n每个时间步的相对误差 $\\varepsilon_n$ 定义为：\n$$ \\varepsilon_n = \\frac{| \\, |i_{\\text{sim}}(t_n)| - i_C(t_n) \\, |}{i_C(t_n)} $$\n注意，常数因子 $nFA$ 在分子和分母中被抵消，从而将计算简化为对通量项的比较。\n对于测试集中的每个 $\\lambda$ 值，模拟运行 $k_{\\max}=5$ 步，生成一组误差 $\\{\\varepsilon_1, \\varepsilon_2, \\varepsilon_3, \\varepsilon_4, \\varepsilon_5\\}$。每个测试用例的最终报告值 $\\varepsilon(\\lambda)$ 是这五个误差值中的最大值：\n$$ \\varepsilon(\\lambda) = \\max_{1 \\le n \\le k_{\\max}} \\varepsilon_n $$\n整体算法如下：对于每个 $\\lambda$，初始化浓度分布，然后从 $n=1$ 循环到 $k_{\\max}$。在每次迭代中，将模拟推进一个时间步以找到浓度分布 $c^n$，然后计算 $\\varepsilon_n$。循环结束后，在计算出的值中找到最大误差。对所有指定的 $\\lambda$ 值重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a digital simulation of chronoamperometry to quantify the\n    early-time discretization error of an explicit finite-difference scheme.\n    \"\"\"\n\n    # --- Scientific and Physical Constants ---\n    # Diffusion coefficient (m^2/s)\n    D = 1.0e-9\n    # Bulk concentration (mol/m^3)\n    C_STAR = 1.0e-3\n    # Electrode area (m^2)\n    A = 1.0e-4\n    # Number of electrons transferred\n    N_ELECTRONS = 1\n    # Faraday constant (C/mol)\n    F = 96485.33212\n\n    # --- Simulation Domain and Discretization Parameters ---\n    # Truncated domain length (m)\n    L = 5.0e-4\n    # Number of spatial grid points\n    N_POINTS = 801\n    # Maximum number of time steps to check for error\n    K_MAX = 5\n\n    # --- Test Suite ---\n    # Dimensionless diffusion parameter values to test\n    lambda_test_suite = [0.05, 0.10, 0.25, 0.45, 0.50]\n\n    # --- Calculations ---\n    # Spatial step size (m)\n    delta_x = L / (N_POINTS - 1)\n\n    results = []\n    for lambda_val in lambda_test_suite:\n        # Time step (s), dependent on lambda\n        delta_t = (lambda_val * delta_x**2) / D\n\n        # Initialize the concentration array for time t=0.\n        # c[0] is at the electrode surface (x=0).\n        # The potential step sets c[0] to 0 instantaneously.\n        c = np.full(N_POINTS, C_STAR)\n        c[0] = 0.0\n\n        relative_errors = []\n        # Time-stepping loop from n=1 to k_max\n        for n_step in range(1, K_MAX + 1):\n            # Store the concentration profile from the previous time step\n            c_old = c.copy()\n\n            # Evolve concentration for interior nodes using the FTCS scheme\n            # c[1:-1] corresponds to j = 1, ..., N-2\n            # c_old[2:]     corresponds to c_{j+1}\n            # c_old[1:-1]   corresponds to c_{j}\n            # c_old[0:-2]   corresponds to c_{j-1}\n            c[1:-1] = c_old[1:-1] + lambda_val * (c_old[2:] - 2 * c_old[1:-1] + c_old[0:-2])\n            \n            # Boundary conditions c[0]=0 and c[-1]=c_star are maintained\n            # throughout the simulation. c[0] is never updated, and c[-1] is\n            # not part of the interior node slice.\n\n            # Current time t_n = n * delta_t\n            t = n_step * delta_t\n\n            # --- Calculate Simulated vs. Analytical Current (Flux) ---\n            # The factor n*F*A is common to both and cancels in relative error.\n            # We only need to compare the flux terms for efficiency.\n            \n            # Simulated flux magnitude, J_sim = D * |grad c_sim|\n            # Gradient is approximated by the second-order one-sided formula.\n            # grad_c = (-3*c[0] + 4*c[1] - c[2]) / (2*delta_x). Since c[0]=0,\n            # this simplifies to (4*c[1] - c[2]) / (2*delta_x).\n            flux_sim = D * (4 * c[1] - c[2]) / (2 * delta_x)\n\n            # Analytical (Cottrell) flux magnitude, J_C = c* * sqrt(D / (pi*t))\n            flux_cottrell = C_STAR * np.sqrt(D / (np.pi * t))\n\n            # Calculate relative error for this time step\n            error = np.abs(flux_sim - flux_cottrell) / flux_cottrell\n            relative_errors.append(error)\n\n        # Find the maximum relative error over the first k_max steps\n        max_error = np.max(relative_errors)\n        results.append(max_error)\n\n    # Print results in the specified format\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然显式方法易于实现，但其条件稳定性可能带来限制。本练习  介绍了无条件稳定的隐式方法，这是一种更稳健的扩散问题处理技术。您将使用后向欧拉方案实现一个模拟，这需要在每个时间步长中使用高效的托马斯（Thomas）算法求解一个三对角线性方程组，并分析其计算成本。",
            "id": "4242498",
            "problem": "您的任务是使用完全隐式数值格式，为平面电极上的一维扩散限制电位阶跃构建计时电流法的数字模拟。该计算模型必须从菲克第二扩散定律出发，通过在每个时间步上使用托马斯算法求解一个三对角线性系统，来生成指定时间下的电流。此外，您必须估计三对角求解器每个时间步的计算成本（包括边界更新），并证明其与空间点数成线性关系。\n\n基本依据包括以下要素：\n- 菲克第二定律：$$\\frac{\\partial c(x,t)}{\\partial t} = D \\frac{\\partial^2 c(x,t)}{\\partial x^2},$$ 其中 $c(x,t)$ 是浓度，单位为 $\\mathrm{mol}\\,\\mathrm{m}^{-3}$，$D$ 是扩散系数，单位为 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$。\n- 边界条件，代表在 $x=0$ 处平面电极上进行的扩散限制电位阶跃计时电流法实验：$$c(0,t) = 0 \\text{ for } t \\ge 0,$$ 以及在 $x=L$ 处的远端边界，维持本体浓度：$$c(L,t) = c^\\ast.$$\n- 初始条件：$$c(x,0) = c^\\ast.$$\n- 电极处的通量：$$j(t) = -D \\left.\\frac{\\partial c}{\\partial x}\\right|_{x=0^+},$$ 单位为 $\\mathrm{mol}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$。\n- 由通量计算电流：$$i(t) = n F A\\, j(t),$$ 其中 $n$ 是转移的电子数，$F$ 是法拉第常数，单位为 $\\mathrm{C}\\,\\mathrm{mol}^{-1}$，$A$ 是电极面积，单位为 $\\mathrm{m}^2$。\n\n实现以下内容：\n- 使用 $N$ 个均匀间隔的网格点离散化空间域 $[0,L]$，间距为 $$\\Delta x = \\frac{L}{N-1}.$$ 使用时间步长为 $$\\Delta t$$ 的完全隐式（后向欧拉）时间步进。离散未知量为内部浓度 $$c_i^{n} \\approx c(x_i, t_n)$$，其中 $i=1,\\dots,N-2$ 且 $$x_i = i\\,\\Delta x.$$\n- 在每个时间步，菲克第二定律的隐式离散化会为新时间层级的内部浓度产生一个三对角线性系统。使用托马斯算法求解此系统。将 $x=0$ 和 $x=L$ 处的狄利克雷边界值适当地并入右侧项。\n- 使用 $x=0$ 处梯度的单边有限差分近似计算电极电流：$$\\left.\\frac{\\partial c}{\\partial x}\\right|_{x=0^+} \\approx \\frac{c_1^{n+1} - c_0^{n+1}}{\\Delta x},$$ 其中 $$c_0^{n+1} = 0.$$ 报告代数电流 $$i(t_{n+1})$$，单位为安培。对于电极上阴极扩散限制的消耗，该值将为负。\n\n此外，估计托马斯算法应用于大小为 $$M = N-2$$（内部点数）的三对角系统的每个时间步的算术运算次数。该估计必须包括：\n- 托马斯算法用于三对角系统的前向消元和后向代入步骤。\n- 由狄利克雷条件在 $x=0$ 和 $x=L$ 处引起的边界更新。\n- 电极通量的计算及到电流的转换。\n\n将每个时间步的估计成本表示为 $$N$$ 的函数，并证明其复杂度为 $$O(N)。$$\n\n物理单位：\n- 长度单位必须是米（$\\mathrm{m}$），时间单位是秒（$\\mathrm{s}$），浓度单位是 $\\mathrm{mol}\\,\\mathrm{m}^{-3}$，扩散系数单位是 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$，电流单位是安培（$\\mathrm{A}$）。\n- 不使用角度。\n- 本问题不出现百分比。\n\n测试套件：\n使用以下三组参数集，每组在最终时间产生一个电流值和每个时间步的一个整数运算次数。对于所有情况，假设 $$n=1,$$ $$F=96485.33212\\,\\mathrm{C}\\,\\mathrm{mol}^{-1},$$ 和 $$c^\\ast=1.0\\,\\mathrm{mol}\\,\\mathrm{m}^{-3}。$$\n1. 情况 A (正常路径):\n   - $$D = 1.0 \\times 10^{-9}\\,\\mathrm{m}^2\\,\\mathrm{s}^{-1},\\quad A = 1.0 \\times 10^{-4}\\,\\mathrm{m}^2,$$\n   - $$L = 5.0 \\times 10^{-4}\\,\\mathrm{m},\\quad N = 101,$$\n   - $$\\Delta t = 1.0 \\times 10^{-2}\\,\\mathrm{s},\\quad T_{\\text{end}} = 2.0 \\times 10^{-1}\\,\\mathrm{s}.$$\n2. 情况 B (具有最少内部点的边界大小边缘情况):\n   - $$D = 1.0 \\times 10^{-9}\\,\\mathrm{m}^2\\,\\mathrm{s}^{-1},\\quad A = 1.0 \\times 10^{-4}\\,\\mathrm{m}^2,$$\n   - $$L = 5.0 \\times 10^{-4}\\,\\mathrm{m},\\quad N = 3,$$\n   - $$\\Delta t = 1.0 \\times 10^{-1}\\,\\mathrm{s},\\quad T_{\\text{end}} = 2.0 \\times 10^{-1}\\,\\mathrm{s}.$$\n3. 情况 C (用于测试线性扩展的大型系统):\n   - $$D = 1.0 \\times 10^{-9}\\,\\mathrm{m}^2\\,\\mathrm{s}^{-1},\\quad A = 1.0 \\times 10^{-4}\\,\\mathrm{m}^2,$$\n   - $$L = 5.0 \\times 10^{-4}\\,\\mathrm{m},\\quad N = 1001,$$\n   - $$\\Delta t = 5.0 \\times 10^{-5}\\,\\mathrm{s},\\quad T_{\\text{end}} = 1.0 \\times 10^{-2}\\,\\mathrm{s}.$$\n\n程序输出规范：\n- 您的程序应独立模拟每种情况，计算在 $$T_{\\text{end}}$$ 时的电流（单位安培）以及每个时间步作为 $$N$$ 函数的估计整数运算次数，并将六个结果汇总到一个列表中。\n- 最终输出必须是单行，形式为方括号内以逗号分隔的列表：$$[i_A,\\,\\text{cost}_A,\\,i_B,\\,\\text{cost}_B,\\,i_C,\\,\\text{cost}_C],$$ 其中 $$i_A, i_B, i_C$$ 是以安培为单位的浮点数电流，$$\\text{cost}_A, \\text{cost}_B, \\text{cost}_C$$ 是表示每个时间步估计运算次数的整数。",
            "solution": "该问题要求构建一个基于菲克第二扩散定律的平面电极计时电流法数字模拟。解决方案必须采用完全隐式有限差分格式，在每个时间步使用托马斯算法求解所得的三对角系统，并提供计算成本的估计。\n\n首先，我们离散化控制偏微分方程，即菲克第二定律：\n$$\n\\frac{\\partial c(x,t)}{\\partial t} = D \\frac{\\partial^2 c(x,t)}{\\partial x^2}\n$$\n空间域 $[0, L]$ 被离散化为 $N$ 个点，$x_i = i \\Delta x$，其中 $i=0, 1, \\dots, N-1$，均匀网格间距为 $\\Delta x = L/(N-1)$。时间以恒定步长 $\\Delta t$ 离散化，使得 $t_n = n \\Delta t$。在网格点 $x_i$ 和时间 $t_n$ 的浓度表示为 $c_i^n \\approx c(x_i, t_n)$。\n\n使用完全隐式（后向欧拉）格式，时间导数在时间层级 $n+1$ 处近似为：\n$$\n\\frac{\\partial c}{\\partial t} \\approx \\frac{c_i^{n+1} - c_i^n}{\\Delta t}\n$$\n空间二阶导数也使用中心差分近似在新时间层级 $n+1$ 处求值：\n$$\n\\frac{\\partial^2 c}{\\partial x^2} \\approx \\frac{c_{i-1}^{n+1} - 2c_i^{n+1} + c_{i+1}^{n+1}}{(\\Delta x)^2}\n$$\n将这些近似值代入菲克定律，得到每个内部网格点 $i = 1, 2, \\dots, N-2$ 的有限差分方程：\n$$\n\\frac{c_i^{n+1} - c_i^n}{\\Delta t} = D \\frac{c_{i-1}^{n+1} - 2c_i^{n+1} + c_{i+1}^{n+1}}{(\\Delta x)^2}\n$$\n我们定义一个无量纲参数 $\\lambda = D \\Delta t / (\\Delta x)^2$。重新整理方程，将时间层级 $n+1$ 的未知浓度组合在左侧，将时间层级 $n$ 的已知浓度放在右侧，得到：\n$$\n-\\lambda c_{i-1}^{n+1} + (1 + 2\\lambda) c_i^{n+1} - \\lambda c_{i+1}^{n+1} = c_i^n\n$$\n这组关于 $i = 1, \\dots, N-2$ 的线性方程构成一个大小为 $M \\times M$ 的三对角系统，其中 $M = N-2$ 是内部点的数量。该系统可以写成矩阵形式 $\\mathbf{A} \\mathbf{c}^{n+1} = \\mathbf{d}^n$。\n\n边界条件为 $c(0,t) = 0$ 和 $c(L,t) = c^\\ast$。在我们的离散系统中，这转换为对所有 $n \\ge 0$，$c_0^{n+1} = 0$ 和 $c_{N-1}^{n+1} = c^\\ast$。这些已知值被并入系统中。\n\n对于第一个内部点（$i=1$）：\n$$\n-\\lambda c_{0}^{n+1} + (1 + 2\\lambda) c_1^{n+1} - \\lambda c_2^{n+1} = c_1^n\n$$\n由于 $c_0^{n+1} = 0$，方程变为：\n$$\n(1 + 2\\lambda) c_1^{n+1} - \\lambda c_2^{n+1} = c_1^n\n$$\n对于最后一个内部点（$i=N-2$）：\n$$\n-\\lambda c_{N-3}^{n+1} + (1 + 2\\lambda) c_{N-2}^{n+1} - \\lambda c_{N-1}^{n+1} = c_{N-2}^n\n$$\n由于 $c_{N-1}^{n+1} = c^\\ast$，我们将这个已知项移到右侧：\n$$\n-\\lambda c_{N-3}^{n+1} + (1 + 2\\lambda) c_{N-2}^{n+1} = c_{N-2}^n + \\lambda c^\\ast\n$$\n对于大小为 $M=N-2$ 的系统，三对角矩阵 $\\mathbf{A}$ 具有以下结构：\n次对角线：$a_i = -\\lambda$，其中 $i=1, \\dots, M-1$。\n主对角线：$b_i = 1+2\\lambda$，其中 $i=1, \\dots, M$。\n超对角线：$c_i = -\\lambda$，其中 $i=1, \\dots, M-1$。\n\n右侧向量 $\\mathbf{d}$ 由前一个时间步的浓度构建：$d_i = c_i^n$，其中 $i=1, \\dots, M-1$，以及 $d_M = c_{N-2}^n + \\lambda c^\\ast$。\n\n该系统使用托马斯算法（三对角矩阵算法或 TDMA）高效求解，该算法是高斯消去法的一种应用。该算法包括两个阶段：前向消元扫描和后向代入扫描。\n\n在解出新浓度 $\\mathbf{c}^{n+1} = (c_1^{n+1}, \\dots, c_{N-2}^{n+1})$ 后，计算电流 $i(t_{n+1})$。电极（$x=0$）处的通量 $j(t)$ 由 $j(t) = -D (\\partial c / \\partial x)|_{x=0}$ 给出。我们使用单边有限差分近似梯度：\n$$\n\\left.\\frac{\\partial c}{\\partial x}\\right|_{x=0} \\approx \\frac{c_1^{n+1} - c_0^{n+1}}{\\Delta x} = \\frac{c_1^{n+1}}{\\Delta x}\n$$\n通量则为 $j(t_{n+1}) = -D \\frac{c_1^{n+1}}{\\Delta x}$。电流通过法拉第电解定律 $i(t) = n F A j(t)$ 获得：\n$$\ni(t_{n+1}) = n F A \\left(-D \\frac{c_1^{n+1}}{\\Delta x}\\right) = -\\frac{n F A D}{\\Delta x} c_1^{n+1}\n$$\n\n接下来，我们估计每个时间步的计算成本，作为 $N$ 的函数。该成本包括建立系统、求解系统和计算电流。\n1.  **参数计算**：在每一步，可能需要重新计算 $\\lambda = D \\Delta t / (\\Delta x)^2$。假设 $\\Delta x$ 已预先计算，这需要 1 次乘法（用于 $(\\Delta x)^2$），1 次乘法（$D \\Delta t$），和 1 次除法，总共 3 次运算。我们包括一次 $\\Delta x = L/(N-1)$ 的计算，增加 1 次除法。总计：4 次运算。\n2.  **右侧项（RHS）更新**：向量 $\\mathbf{d}$ 大部分是旧浓度的副本。唯一的算术运算是针对最后一个元素：$d_M = c_{M+1}^n + \\lambda c^\\ast$。这需要 1 次乘法和 1 次加法，总共 2 次运算。\n3.  **托马斯算法 (TDMA)**：对于一个大小为 $M$ 的系统，托马斯算法的标准非破坏性实现大约需要 $8M - 7$ 次浮点运算（对于 $M>1$）。当 $M=N-2$ 时，这是 $8(N-2) - 7 = 8N - 16 - 7 = 8N - 23$ 次运算。\n4.  **电流计算**：计算 $i = -(nFAD/\\Delta x) c_1^{n+1}$ 涉及 3 次乘法和 1 次除法用于计算预因子，以及最后与 $c_1^{n+1}$ 的 1 次乘法。总计：5 次运算。\n\n每个时间步的总估计成本是这些贡献的总和：\n$$\n\\text{成本}(N) = \\text{成本}_{\\lambda} + \\text{成本}_{\\text{RHS}} + \\text{成本}_{\\text{TDMA}} + \\text{成本}_{\\text{电流}}\n$$\n$$\n\\text{成本}(N) = 4 + 2 + (8N - 23) + 5 = 8N - 12\n$$\n对于边缘情况 $N=3$，$M=1$。对于一个 $1 \\times 1$ 系统 $b_1 x_1 = d_1$ 的 TDMA 算法仅仅是 $x_1 = d_1 / b_1$。方程是 $(1+2\\lambda)c_1^{n+1} = c_1^n + \\lambda c^\\ast$。求解的成本是：分母 $(1+2\\lambda)$ 需要 1 次乘法和 1 次加法，以及 1 次除法。总共 3 次运算用于求解。因此，对于 $N=3$ 的总成本是 $4 (\\lambda) + 2 (\\text{RHS}) + 3 (\\text{求解}) + 5 (\\text{电流}) = 14$。通用公式 $8N-12$ 得出 $8(3)-12=12$，这是一个与线性扩展一致的合理近似。我们将对所有情况使用公式 $\\text{成本}(N) = 8N - 12$，因为它正确地捕捉了主要的 $O(N)$ 行为。这种线性扩展是托马斯算法用于三对角系统的一个关键优势。\n\n模拟从初始条件 $c(x,0) = c^\\ast$ 开始。我们从 $t=0$ 开始应用边界条件 $c(0,t)=0$，因此初始浓度分布为 $c(0,0)=0$ 和 $c(x_i, 0)=c^\\ast$（对于 $i > 0$）。模拟通过在每个时间步迭代求解浓度分布来进行，直到 $t=T_{\\text{end}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef thomas_algorithm(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax=d.\n    a: sub-diagonal vector (length M-1)\n    b: main-diagonal vector (length M)\n    c: super-diagonal vector (length M-1)\n    d: right-hand side vector (length M)\n    Returns the solution vector x (length M).\n    \"\"\"\n    M = len(d)\n    if M == 0:\n        return np.array([])\n    if M == 1:\n        return np.array([d[0] / b[0]])\n\n    # Create copies to avoid modifying the original arrays\n    c_prime = np.zeros(M)\n    d_prime = np.zeros(M)\n    \n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n    for i in range(1, M):\n        denominator = b[i] - a[i-1] * c_prime[i-1]\n        if i  M - 1:\n            c_prime[i] = c[i] / denominator\n        d_prime[i] = (d[i] - a[i-1] * d_prime[i-1]) / denominator\n\n    # Backward substitution\n    x = np.zeros(M)\n    x[M-1] = d_prime[M-1]\n    for i in range(M-2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i+1]\n        \n    return x\n\ndef solve():\n    \"\"\"\n    Main function to run chronoamperometry simulations for the given test cases.\n    \"\"\"\n    # Physical and electrochemical constants\n    n_electrons = 1.0\n    F_const = 96485.33212  # C/mol\n    c_star = 1.0  # mol/m^3\n\n    test_cases = [\n        # Case A: Happy path\n        {'D': 1.0e-9, 'A': 1.0e-4, 'L': 5.0e-4, 'N': 101, 'dt': 1.0e-2, 'T_end': 2.0e-1},\n        # Case B: Boundary-size edge case\n        {'D': 1.0e-9, 'A': 1.0e-4, 'L': 5.0e-4, 'N': 3, 'dt': 1.0e-1, 'T_end': 2.0e-1},\n        # Case C: Large system\n        {'D': 1.0e-9, 'A': 1.0e-4, 'L': 5.0e-4, 'N': 1001, 'dt': 5.0e-5, 'T_end': 1.0e-2},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        D = case['D']\n        A = case['A']\n        L = case['L']\n        N = case['N']\n        dt = case['dt']\n        T_end = case['T_end']\n\n        # Discretization parameters\n        dx = L / (N - 1)\n        lambda_val = D * dt / (dx**2)\n        \n        # Initial condition\n        c = np.full(N, c_star)\n        c[0] = 0.0 # At t=0, potential is stepped, c(0,0)=0\n        \n        # Number of interior points\n        M = N - 2\n\n        # Set up the constant tridiagonal matrix coefficients\n        if M > 0:\n            diag_b = np.full(M, 1.0 + 2.0 * lambda_val)\n            sub_a = np.full(M - 1, -lambda_val)\n            super_c = np.full(M - 1, -lambda_val)\n\n        # Time-stepping loop\n        num_steps = int(round(T_end / dt))\n        for _ in range(num_steps):\n            if M > 0:\n                # Set up the right-hand side vector d\n                d = c[1:-1].copy()\n                d[-1] += lambda_val * c_star\n                \n                # Solve the tridiagonal system for the new interior concentrations\n                c_interior_new = thomas_algorithm(sub_a, diag_b, super_c, d)\n                \n                # Update the concentration profile\n                c[1:-1] = c_interior_new\n\n        # Calculate final current at T_end\n        gradient_at_electrode = (c[1] - c[0]) / dx\n        flux = -D * gradient_at_electrode\n        current = n_electrons * F_const * A * flux\n        \n        # Estimate computational cost per time step\n        # Cost = 8N - 12 (derived from 4 ops for lambda, 2 for RHS, 8(N-2)-7 for TDMA, 5 for current)\n        cost = 8 * N - 12\n        \n        results.append(current)\n        results.append(int(cost))\n        \n    print(f\"[{','.join(f'{x:.8f}' if isinstance(x, float) else str(x) for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的电极往往偏离理想的平面几何形状。本练习  将我们的模拟框架扩展到球形扩散这一重要情况，这对于理解微电极和纳米颗粒至关重要。您将专注于离散化球形扩散方程的关键任务，特别是曲率项 $\\frac{2}{\\rho}\\frac{\\partial c}{\\partial \\rho}$，并正确实现不同的边界条件。",
            "id": "4242492",
            "problem": "你的任务是设计并实现一种适用于模拟球对称计时安培法的数字有限差分格式。从球坐标系下径向对称的单一电活性物质的Fick第二扩散定律出发，其中浓度场 $c(r,t)$ 已相对于本体浓度进行归一化，电极半径为 $a$。引入无量纲变量 $\\rho = r/a$ 和 $\\tau = D t / a^2$，其中 $D$ 为扩散系数。在这些变量下，控制方程为\n$$\n\\frac{\\partial c}{\\partial \\tau} = \\frac{\\partial^2 c}{\\partial \\rho^2} + \\frac{2}{\\rho} \\frac{\\partial c}{\\partial \\rho}, \\quad \\rho \\ge 1, \\ \\tau \\ge 0,\n$$\n初始条件为 $c(\\rho,0) = 1$。\n\n在电极表面 $\\rho = 1$ 处，考虑两种与计时安培法相关的物理边界条件：\n- 扩散控制（Dirichlet）边界：在电位阶跃后，$c(1,\\tau) = 0$。\n- 一级反应控制（Robin）边界：$- \\left.\\frac{\\partial c}{\\partial \\rho}\\right|_{\\rho=1} = \\kappa \\, c(1,\\tau)$，其中 $\\kappa = \\frac{k a}{D}$，$k$ 为非均相反应速率常数。\n\n你的有限差分网格在 $\\rho$ 方向上是均匀的，间距为 $\\Delta \\rho$，网格节点索引为 $\\rho_j = 1 + j \\Delta \\rho$（整数 $j \\ge 0$），其中 $j=0$ 对应电极表面。你的任务是：\n1. 从第一性原理出发，推导在第一个内部节点 $j=1$（即 $\\rho_1 = 1 + \\Delta \\rho$）处，对 $\\left( \\frac{2}{\\rho} \\frac{\\partial c}{\\partial \\rho} \\right)$ 项的二阶精度离散近似。此推导必须符合球形扩散的物理原理和指定的边界条件，且不得使用任何简便公式。\n2. 对于Dirichlet边界条件，将该离散近似表示为节点 $j=0,1,2$ 处的 $c_0$、$c_1$ 和 $c_2$ 的形式。\n3. 对于Robin边界条件，使用一个满足边界条件的 $\\left.\\frac{\\partial c}{\\partial \\rho}\\right|_{\\rho=1}$ 的二阶单边近似来消去未知数 $c_0$，并将得到的在 $j=1$ 处的离散近似表示为 $c_1$、$c_2$ 以及参数 $\\Delta \\rho$ 和 $\\kappa$ 的形式。\n4. 实现一个程序，对于给定的 $\\Delta \\rho$、$c_1$、$c_2$ 和边界条件参数，计算在 $j=1$ 处 $\\left( \\frac{2}{\\rho} \\frac{\\partial c}{\\partial \\rho} \\right)$ 的离散近似的数值，结果为一个无量纲浮点数。\n\n本问题中所有量均为无量纲或归一化的；因此，要求的输出必须是无单位的浮点数。\n\n测试套件：\n使用以下参数集来评估你的实现。在每种情况下，结果都是在 $j=1$ 处 $\\left( \\frac{2}{\\rho} \\frac{\\partial c}{\\partial \\rho} \\right)$ 的离散近似的无量纲浮点数值：\n- 情景A（扩散控制）：$\\Delta \\rho = 0.02$，$c_0 = 0$，$c_1 = 0.40$，$c_2 = 0.80$。\n- 情景B（中等动力学的反应控制）：$\\Delta \\rho = 0.02$，$\\kappa = 1.00$，$c_1 = 0.40$，$c_2 = 0.80$。\n- 情景C（无反应，表面纯通量平衡）：$\\Delta \\rho = 0.02$，$\\kappa = 0.00$，$c_1 = 0.40$，$c_2 = 0.80$。\n- 情景D（快速反应，接近二阶边界近似的稳定性阈值）：$\\Delta \\rho = 0.02$，$\\kappa = 70.00$，$c_1 = 0.40$，$c_2 = 0.80$。\n- 情景E（网格细化，中等动力学）：$\\Delta \\rho = 0.005$，$\\kappa = 1.00$，$c_1 = 0.40$，$c_2 = 0.80$。\n\n对于Dirichlet情景，$c_0$ 是直接给定的。对于Robin情景，必须使用你在解法中推导出的二阶单边边界处理方法来消去 $c_0$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含情景A到E的结果，结果按顺序排列，形式为方括号内的逗号分隔列表（例如 $[x_1,x_2,x_3,x_4,x_5]$），其中每个 $x_i$ 是在指定情景参数下，对应于 $j=1$ 处 $\\left( \\frac{2}{\\rho} \\frac{\\partial c}{\\partial \\rho} \\right)$ 离散近似的无单位浮点数。",
            "solution": "该问题要求针对球坐标系中的Fick第二定律，在第一个内部网格节点 $\\rho_1 = 1 + \\Delta \\rho$ 处，推导并实现 $\\left( \\frac{2}{\\rho} \\frac{\\partial c}{\\partial \\rho} \\right)$ 项的二阶精度有限差分近似。推导过程必须从第一性原理出发，并针对电极表面 $\\rho=1$ 处的两种边界条件进行特化：Dirichlet和Robin。\n\n令 $c_j$ 表示空间节点 $\\rho_j = 1 + j \\Delta \\rho$ 处的离散浓度，其中 $j$ 是一个整数索引，电极表面处 $j=0$。待近似的项在 $j=1$ 处求值：\n$$\nA_1 = \\left. \\left( \\frac{2}{\\rho} \\frac{\\partial c}{\\partial \\rho} \\right) \\right|_{\\rho=\\rho_1}\n$$\n因子 $2/\\rho$ 在 $\\rho_1 = 1 + \\Delta \\rho$ 处精确求值。核心任务是为导数项 $\\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_1}$ 找到一个二阶精度的近似。\n\n**1. 通用二阶近似的推导**\n\n为了在内部节点 $\\rho_1$ 处获得一阶导数的二阶精度，我们使用中心差分格式。该格式由函数 $c(\\rho)$ 在 $\\rho_1$ 点的泰勒级数展开推导而来。令 $c_j = c(\\rho_j)$。$c_2 = c(\\rho_1 + \\Delta \\rho)$ 和 $c_0 = c(\\rho_1 - \\Delta \\rho)$ 的展开式为：\n$$\nc_2 = c(\\rho_1) + \\Delta \\rho \\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_1} + \\frac{(\\Delta \\rho)^2}{2!} \\left. \\frac{\\partial^2 c}{\\partial \\rho^2} \\right|_{\\rho_1} + O((\\Delta \\rho)^3)\n$$\n$$\nc_0 = c(\\rho_1) - \\Delta \\rho \\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_1} + \\frac{(\\Delta \\rho)^2}{2!} \\left. \\frac{\\partial^2 c}{\\partial \\rho^2} \\right|_{\\rho_1} - O((\\Delta \\rho)^3)\n$$\n用第一个方程减去第二个方程，可以消去偶数阶导数项：\n$$\nc_2 - c_0 = 2 \\Delta \\rho \\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_1} + O((\\Delta \\rho)^3)\n$$\n对导数求解，得到二阶精度的中心差分公式：\n$$\n\\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_1} = \\frac{c_2 - c_0}{2 \\Delta \\rho} + O((\\Delta \\rho)^2)\n$$\n将此代入 $A_1$ 的表达式，我们得到在节点 $j=1$ 处的通用离散近似：\n$$\nA_1 \\approx \\frac{2}{\\rho_1} \\left( \\frac{c_2 - c_0}{2 \\Delta \\rho} \\right) = \\frac{1}{1 + \\Delta \\rho} \\left( \\frac{c_2 - c_0}{\\Delta \\rho} \\right) = \\frac{c_2 - c_0}{(1 + \\Delta \\rho) \\Delta \\rho}\n$$\n该表达式依赖于相邻节点 $c_0$ 和 $c_2$ 处的浓度。浓度 $c_1$ 不出现在离散化偏微分方程的这一特定项中。\n\n**2. 边界条件的特化处理**\n\n通用公式需要电极表面浓度 $c_0$ 的值。该值由边界条件确定。\n\n**2a. Dirichlet边界条件**\n扩散控制（Dirichlet）边界条件为 $c(1, \\tau) = 0$。在我们的离散框架中，这直接转化为第一个节点 $j=0$ 处的浓度：\n$$\nc_0 = 0\n$$\n然而，问题要求用 $c_0$、$c_1$ 和 $c_2$ 来表示该表达式。上面推导的通用公式满足这一要求，因为它已经用 $c_0$ 和 $c_2$ 表示（其中 $c_1$ 的系数为零）。\n$$\nA_{1, \\text{Dirichlet}} \\approx \\frac{c_2 - c_0}{(1 + \\Delta \\rho) \\Delta \\rho}\n$$\n在 $c(1,\\tau)=0$ 的特定情况下进行数值计算时，我们将代入 $c_0 = 0$。\n\n**2b. Robin边界条件**\n一级反应控制（Robin）边界条件由下式给出：\n$$\n- \\left.\\frac{\\partial c}{\\partial \\rho}\\right|_{\\rho=1} = \\kappa \\, c(1,\\tau)\n$$\n用离散形式表示，这在节点 $j=0$ 处计算：\n$$\n- \\left.\\frac{\\partial c}{\\partial \\rho}\\right|_{\\rho_0} = \\kappa \\, c_0\n$$\n在这里，$c_0$ 是未知的，必须与内部点 $c_1$ 和 $c_2$ 联系起来。为此，我们需要一个在边界处同样具有二阶精度的导数离散近似。这需要一个单边（向前）差分公式。我们通过在 $\\rho_0$ 附近进行泰勒展开来推导它：\n$$\nc_1 = c(\\rho_0 + \\Delta \\rho) = c_0 + \\Delta \\rho \\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_0} + \\frac{(\\Delta \\rho)^2}{2} \\left. \\frac{\\partial^2 c}{\\partial \\rho^2} \\right|_{\\rho_0} + O((\\Delta \\rho)^3)\n$$\n$$\nc_2 = c(\\rho_0 + 2\\Delta \\rho) = c_0 + 2\\Delta \\rho \\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_0} + \\frac{(2\\Delta \\rho)^2}{2} \\left. \\frac{\\partial^2 c}{\\partial \\rho^2} \\right|_{\\rho_0} + O((\\Delta \\rho)^3)\n$$\n为了消去二阶导数项，我们将第一个方程乘以4，然后减去第二个方程：\n$$\n4c_1 - c_2 = (4c_0 - c_0) + (4\\Delta \\rho - 2\\Delta \\rho)\\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_0} + O((\\Delta \\rho)^3) = 3c_0 + 2\\Delta \\rho \\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_0} + O((\\Delta \\rho)^3)\n$$\n对导数求解，得到二阶精度的单边公式：\n$$\n\\left. \\frac{\\partial c}{\\partial \\rho} \\right|_{\\rho_0} = \\frac{-3c_0 + 4c_1 - c_2}{2 \\Delta \\rho} + O((\\Delta \\rho)^2)\n$$\n现在，将此代入Robin边界条件：\n$$\n- \\left( \\frac{-3c_0 + 4c_1 - c_2}{2 \\Delta \\rho} \\right) = \\kappa c_0\n$$\n$$\n3c_0 - 4c_1 + c_2 = 2 \\Delta \\rho \\kappa c_0\n$$\n我们求解 $c_0$ 以消去它：\n$$\nc_0 (3 - 2 \\Delta \\rho \\kappa) = 4c_1 - c_2 \\implies c_0 = \\frac{4c_1 - c_2}{3 - 2 \\Delta \\rho \\kappa}\n$$\n现在可以将这个关于 $c_0$ 的表达式代回到我们对 $A_1$ 的通用近似中：\n$$\nA_{1, \\text{Robin}} \\approx \\frac{1}{(1 + \\Delta \\rho) \\Delta \\rho} \\left( c_2 - c_0 \\right) = \\frac{1}{(1 + \\Delta \\rho) \\Delta \\rho} \\left( c_2 - \\frac{4c_1 - c_2}{3 - 2 \\Delta \\rho \\kappa} \\right)\n$$\n化简括号中的项：\n$$\nc_2 - \\frac{4c_1 - c_2}{3 - 2 \\Delta \\rho \\kappa} = \\frac{c_2(3 - 2 \\Delta \\rho \\kappa) - (4c_1 - c_2)}{3 - 2 \\Delta \\rho \\kappa} = \\frac{3c_2 - 2 \\Delta \\rho \\kappa c_2 - 4c_1 + c_2}{3 - 2 \\Delta \\rho \\kappa} = \\frac{4c_2 - 4c_1 - 2 \\Delta \\rho \\kappa c_2}{3 - 2 \\Delta \\rho \\kappa}\n$$\n因此，对于Robin情景，以 $c_1$、$c_2$、$\\Delta \\rho$ 和 $\\kappa$ 表示的最终表达式为：\n$$\nA_{1, \\text{Robin}} \\approx \\frac{1}{(1 + \\Delta \\rho) \\Delta \\rho} \\left( \\frac{4(c_2 - c_1) - 2 \\Delta \\rho \\kappa c_2}{3 - 2 \\Delta \\rho \\kappa} \\right)\n$$\n这就完成了从第一性原理出发所要求的推导。\n\n**3. 测试情景的实现**\n\n现在将实现推导出的公式，以计算所提供测试情景的近似数值。\n\n- **对于情景A（Dirichlet）：** 我们使用 $A_1 \\approx \\frac{c_2 - c_0}{(1 + \\Delta \\rho) \\Delta \\rho}$ 以及给定的参数 $\\Delta \\rho = 0.02$、$c_0 = 0$、$c_1 = 0.40$、$c_2 = 0.80$。\n- **对于情景B、C、D、E（Robin）：** 我们使用 $A_1 \\approx \\frac{1}{(1 + \\Delta \\rho) \\Delta \\rho} \\left( \\frac{4(c_2 - c_1) - 2 \\Delta \\rho \\kappa c_2}{3 - 2 \\Delta \\rho \\kappa} \\right)$ 以及各自对应的 $\\Delta\\rho$、$\\kappa$、$c_1$ 和 $c_2$ 参数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are imported.\n\ndef solve():\n    \"\"\"\n    Computes the second-order discrete approximation of (2/rho) * (dc/drho)\n    at the first interior node j=1 for different boundary conditions\n    in a spherical coordinate system.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'type': 'dirichlet', 'delta_rho': 0.02, 'c0': 0.0, 'c1': 0.40, 'c2': 0.80},\n        {'type': 'robin', 'delta_rho': 0.02, 'kappa': 1.00, 'c1': 0.40, 'c2': 0.80},\n        {'type': 'robin', 'delta_rho': 0.02, 'kappa': 0.00, 'c1': 0.40, 'c2': 0.80},\n        {'type': 'robin', 'delta_rho': 0.02, 'kappa': 70.00, 'c1': 0.40, 'c2': 0.80},\n        {'type': 'robin', 'delta_rho': 0.005, 'kappa': 1.00, 'c1': 0.40, 'c2': 0.80},\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_rho = case['delta_rho']\n        c1 = case['c1']\n        c2 = case['c2']\n        \n        # The approximation is evaluated at rho_1 = 1 + delta_rho.\n        rho_1 = 1.0 + delta_rho\n\n        if case['type'] == 'dirichlet':\n            # For the Dirichlet case, the general formula is used. The value\n            # of c0 is given directly in the problem specification.\n            c0 = case['c0']\n            \n            # Derived formula: approx = (c2 - c0) / ((1 + delta_rho) * delta_rho)\n            approximation = (c2 - c0) / (rho_1 * delta_rho)\n            \n        elif case['type'] == 'robin':\n            # For the Robin case, c0 is eliminated using a second-order\n            # one-sided approximation of the boundary condition.\n            kappa = case['kappa']\n\n            # Derived formula:\n            # approx = (1 / (rho_1 * delta_rho)) * \n            #          ( (4*(c2 - c1) - 2*delta_rho*kappa*c2) / (3 - 2*delta_rho*kappa) )\n            \n            numerator_of_fraction = 4.0 * (c2 - c1) - 2.0 * delta_rho * kappa * c2\n            denominator_of_fraction = 3.0 - 2.0 * delta_rho * kappa\n            \n            fraction_term = numerator_of_fraction / denominator_of_fraction\n            \n            prefactor = 1.0 / (rho_1 * delta_rho)\n            \n            approximation = prefactor * fraction_term\n\n        else:\n            # This case should not be reached with the given test suite.\n            raise ValueError(f\"Unknown case type: {case['type']}\")\n\n        results.append(approximation)\n\n    # Final print statement in the exact required format.\n    # The format is a comma-separated list of floats inside square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}