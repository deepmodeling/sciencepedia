{
    "hands_on_practices": [
        {
            "introduction": "在粗粒化建模中，一个关键的初始步骤是模型参数化，这通常通过拟合实验数据来完成。本练习将演示如何使用贝叶斯推断方法，根据随温度变化的电导率测量数据来校准模型。这种方法不仅能提供激活能 $E_a$ 等参数的最佳估计值，还能量化这些参数的不确定性以及模型本身的系统偏差，这对于评估模型的可靠性至关重要。",
            "id": "4238696",
            "problem": "考虑一个用于掺杂有双（三氟甲磺酰）亚胺锂（LiTFSI）的聚环氧乙烷（PEO）中离子电导率的粗粒化（CG）模型。其科学前提是在中高温度下，聚合物电解质中的电荷传输主要由热激活跳跃主导。从过渡态理论和离子电导率（定义为电荷密度乘以迁移率）出发，并在一个将结构效应和多体效应吸收到一个有效的、与温度无关的指前因子中的粗粒化映射下，推导一个电导率自然对数与逆温度成线性关系的统计模型，该模型带有一个加性的、零均值的高斯偏差。然后，对参数和噪声方差使用共轭正态-逆伽马模型进行贝叶斯校准。\n\n定义和假设：\n- 令 $T$ 表示绝对温度（单位：开尔文），$\\sigma$ 表示离子电导率（单位：西门子/米，S/m）。\n- 在激活传输下，迁移率由活化能 $E_a$ 决定，并且在粗粒化意义上可以与一个不依赖于温度的指前因子结合，从而得到一个 $\\ln \\sigma$ 相对于 $1/T$ 呈线性的模型。\n- 模型与测量值之间的偏差被视为一个独立的、同分布的高斯随机变量，其方差为 $s^2$（由于模型处于对数空间，因此为无量纲）。\n- 玻尔兹曼常数，单位为电子伏特/开尔文，为 $k_B = 8.617333262145 \\times 10^{-5}$ eV/K。\n\n待推导并在解题中使用的统计公式：\n- 观测值：对于 $i = 1,\\dots,N$，定义 $y_i = \\ln \\sigma_i$ 和 $x_i = 1/T_i$。\n- 对数空间中的线性模型，带有加性高斯偏差：$y_i = a + b x_i + \\epsilon_i$，其中 $\\epsilon_i \\sim \\mathcal{N}(0, s^2)$。\n- 物理释义：$a = \\ln \\sigma_0$，其中 $\\sigma_0$ 为一个有效的指前因子（单位：S/m），以及 $b = -E_a/k_B$（单位：K$^{-1}$）。\n- 贝叶斯先验（共轭正态-逆伽马）：$\\theta \\mid s^2 \\sim \\mathcal{N}(m_0, s^2 S_0)$，其中 $\\theta = \\begin{bmatrix} a \\\\ b \\end{bmatrix}$，以及 $s^2 \\sim \\mathrm{InvGamma}(\\alpha_0, \\beta_0)$，逆伽马密度正比于 $(s^2)^{-\\alpha_0 - 1} \\exp(-\\beta_0 / s^2)$。\n\n您的任务：\n1. 从物理基础（激活传输和玻尔兹曼统计）出发，推导对数电导率与 $1/T$ 的线性表示，并将回归系数与物理参数 $E_a$ 和 $\\sigma_0$ 关联起来。\n2. 使用上述共轭贝叶斯线性回归模型，推导后验参数 $(m_n, S_n, \\alpha_n, \\beta_n)$，用 $(m_0, S_0, \\alpha_0, \\beta_0)$ 和数据 $(X, y)$ 表示，其中 $X$ 是一个 $N \\times 2$ 的设计矩阵，第一列全为1，第二列为 $x_i = 1/T_i$，而 $y$ 是一个 $N \\times 1$ 的向量，其元素为 $y_i = \\ln \\sigma_i$。\n3. 实现一个程序，对每个提供的测试用例计算：\n   - $E_a$ 的后验均值，单位为电子伏特 (eV)。\n   - $\\sigma_0$ 的后验均值，单位为西门子/米 (S/m)。\n   - 偏差方差 $s^2$（无量纲）的后验均值，作为模型偏差的定量度量。\n4. 最终输出必须是单行文本，包含所有测试用例的聚合结果，格式为用方括号括起来的逗号分隔列表，每个数值四舍五入到六位小数。\n\n参数先验（请精确使用这些值）：\n- 先验均值 $m_0 = \\begin{bmatrix} \\ln(1000) \\\\ -3000 \\end{bmatrix}$。\n- 先验协方差 $S_0 = \\begin{bmatrix} 10.0  0.0 \\\\ 0.0  1.0 \\times 10^7 \\end{bmatrix}$。\n- 逆伽马先验超参数 $\\alpha_0 = 2.0$ 和 $\\beta_0 = 0.05$。\n\n测试套件：\n- 案例 1（正常路径，中等活化能）：\n  - 温度 $T$（开尔文）：$[300, 320, 340, 360, 380]$。\n  - 电导率 $\\sigma$（S/m）：$[0.0068, 0.0130, 0.0245, 0.0540, 0.1050]$。\n- 案例 2（边界情况，温度依赖性几乎平坦）：\n  - 温度 $T$（开尔文）：$[300, 320, 340, 360, 380]$。\n  - 电导率 $\\sigma$（S/m）：$[0.0480, 0.0530, 0.0610, 0.0680, 0.0740]$。\n- 案例 3（边缘情况，高偏差/噪声）：\n  - 温度 $T$（开尔文）：$[300, 320, 340, 360, 380]$。\n  - 电导率 $\\sigma$（S/m）：$[0.0100, 0.0080, 0.0300, 0.0400, 0.1200]$。\n\n所需输出及单位：\n- 对每个案例，计算三个量：$E_a$ 的后验均值（eV），$\\sigma_0$ 的后验均值（S/m），以及 $s^2$ 的后验均值（无量纲）。\n- 将所有九个结果聚合到单行中，格式严格为：$[r_1,r_2,\\dots,r_9]$，其中每个 $r_j$ 是一个四舍五入到六位小数的浮点数。\n\n您的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[0.123456,2.345678,0.001234, \\dots]$）。不允许有其他输出。",
            "solution": "用户提供的问题是一个应用于物理化学模型的贝叶斯统计推断的有效练习。它要求从第一性原理推导模型，应用标准的贝叶斯回归公式，并实现这些公式以计算物理参数的后验估计。该问题具有科学依据，定义明确，并提供了所有必要信息。\n\n解决方案按要求分为三部分呈现：（1）从物理原理推导线性模型，（2）陈述贝叶斯后验参数更新方程，以及（3）推导目标量的计算公式。\n\n### 1. 从物理原理推导线性模型\n\n离子电导率 $\\sigma$ 由关系式 $\\sigma = \\sum_j n_j |z_j| e \\mu_j$ 定义，其中 $n_j$ 是电荷载流子种类 $j$ 的数密度，$z_j e$ 是其电荷，$\\mu_j$ 是其迁移率。在这个针对单一主要电荷载流子（例如 Li$^+$）的粗粒化模型中，我们可以将其简化为 $\\sigma = n q \\mu$，其中 $n$ 是移动电荷载流子的有效密度，$q$ 是基本电荷，$\\mu$ 是有效迁移率。\n\n问题陈述，电荷传输是一个热激活过程，这可以通过过渡态理论或更简单的阿伦尼乌斯型关系很好地描述。因此，迁移率 $\\mu$ 对温度 $T$ 的依赖关系为：\n$$\n\\mu(T) = \\mu_{ref} \\exp\\left(-\\frac{E_a}{k_B T}\\right)\n$$\n其中 $E_a$ 是离子跳跃的活化能，$k_B$ 是玻尔兹曼常数，$\\mu_{ref}$ 是一个与尝试频率和熵因子相关的指前因子。\n\n将这个迁移率表达式代入电导率方程得到：\n$$\n\\sigma(T) = (n q \\mu_{ref}) \\exp\\left(-\\frac{E_a}{k_B T}\\right)\n$$\n在粗粒化模型中，$(n q \\mu_{ref})$ 项汇集了复杂的多体和结构效应。假定在所考虑的温度范围内，它实际上与温度无关。我们将这整个项定义为有效的指前因子 $\\sigma_0$：\n$$\n\\sigma_0 \\equiv n q \\mu_{ref}\n$$\n于是，电导率模型变为：\n$$\n\\sigma(T) = \\sigma_0 \\exp\\left(-\\frac{E_a}{k_B T}\\right)\n$$\n为了获得线性关系，我们对等式两边取自然对数：\n$$\n\\ln(\\sigma(T)) = \\ln\\left(\\sigma_0 \\exp\\left(-\\frac{E_a}{k_B T}\\right)\\right)\n$$\n利用对数的性质 $\\ln(xy) = \\ln(x) + \\ln(y)$ 和 $\\ln(\\exp(z))=z$，我们得到：\n$$\n\\ln(\\sigma(T)) = \\ln(\\sigma_0) - \\frac{E_a}{k_B} \\frac{1}{T}\n$$\n这个方程是直线形式 $y = a + bx$。通过为每个数据点 $i$ 定义 $y_i = \\ln \\sigma_i$ 和 $x_i = 1/T_i$，我们得到了指定的线性模型：\n$$\ny_i = a + b x_i\n$$\n回归系数 $a$ 和 $b$ 与物理参数直接相关：\n- 截距，$a = \\ln \\sigma_0$。\n- 斜率，$b = -\\frac{E_a}{k_B}$。\n\n这完成了线性模型的推导及其系数的物理解释。\n\n### 2. 贝叶斯后验参数推导\n\n该问题指定了一个使用共轭正态-逆伽马（NIG）先验的贝叶斯线性回归框架。模型由 $y = X\\theta + \\epsilon$ 给出，其中 $\\epsilon \\sim \\mathcal{N}(0, s^2 I_N)$，$\\theta = [a, b]^T$。先验为 $p(\\theta, s^2) = p(\\theta | s^2) p(s^2)$，其中 $\\theta | s^2 \\sim \\mathcal{N}(m_0, s^2 S_0)$ 且 $s^2 \\sim \\mathrm{InvGamma}(\\alpha_0, \\beta_0)$。\n\n由于共轭性质，后验分布 $p(\\theta, s^2 | y, X)$ 也是一个正态-逆伽马分布，$p(\\theta, s^2 | y, X) \\sim \\mathrm{NIG}(m_n, S_n, \\alpha_n, \\beta_n)$。更新后的（后验）超参数 $(m_n, S_n, \\alpha_n, \\beta_n)$ 是通过将似然函数与先验分布相乘并识别所得分布的形式来推导的。这些更新方程的标准结果是：\n\n- $\\theta|s^2$ 的后验精度矩阵是先验精度与数据精度之和：$S_n^{-1} = S_0^{-1} + X^T X$。协方差矩阵是其逆：\n  $$ S_n = (S_0^{-1} + X^T X)^{-1} $$\n- $\\theta|s^2$ 的后验均值是先验均值和数据推导均值的精度加权平均：\n  $$ m_n = S_n (S_0^{-1} m_0 + X^T y) $$\n- $s^2$ 的后验形状参数通过新观测数量 $N$ 的一半进行更新：\n  $$ \\alpha_n = \\alpha_0 + \\frac{N}{2} $$\n- $s^2$ 的后验尺度参数通过先验、数据以及一个解释 $\\theta$ 均值变化的项的平方误差和进行更新：\n  $$ \\beta_n = \\beta_0 + \\frac{1}{2}(m_0^T S_0^{-1} m_0 + y^T y - m_n^T S_n^{-1} m_n) $$\n  注意，此表达式中的 $S_n^{-1}$ 是已经计算出的后验精度矩阵 $S_0^{-1} + X^T X$。\n\n### 3. 后验均值量的计算\n\n在后验分布由 $(m_n, S_n, \\alpha_n, \\beta_n)$ 完全指定后，我们可以计算物理参数的后验期望。\n\n**活化能 $E_a$ 的后验均值**：\n从关系式 $b = -E_a/k_B$ 可得 $E_a = -k_B b$。$E_a$ 的后验均值通过对 $b$ 的后验分布取期望得到：\n$$\nE[E_a | y, X] = E[-k_B b | y, X] = -k_B E[b | y, X]\n$$\n$\\theta$ 的边际后验分布 $p(\\theta|y, X)$ 是一个均值为 $m_n$ 的多元学生t分布。因此，$E[b | y, X]$ 是后验均值向量 $m_n$ 的第二个元素，记为 $m_{n,b}$。\n$$\nE[E_a | y, X] = -k_B \\cdot m_{n,b}\n$$\n\n**指前因子 $\\sigma_0$ 的后验均值**：\n从关系式 $a = \\ln \\sigma_0$ 可得 $\\sigma_0 = \\exp(a)$。$\\sigma_0$ 的后验均值是 $E[\\exp(a) | y, X]$。由于 $a$ 的边际后验分布是一个（非标准的）学生t分布，这个期望没有简单的封闭形式。一个标准且实用的近似是使用函数在参数后验均值处的值，这等效于一阶泰勒展开（或假设 $a$ 的后验分布高度集中在其均值附近）：\n$$\nE[\\sigma_0 | y, X] \\approx \\exp(E[a | y, X])\n$$\n后验均值 $E[a | y, X]$ 是 $m_n$ 的第一个元素，记为 $m_{n,a}$。\n$$\nE[\\sigma_0 | y, X] \\approx \\exp(m_{n,a})\n$$\n这是我们将要计算的量。\n\n**偏差方差 $s^2$ 的后验均值**：\n方差的边际后验分布 $p(s^2|y, X)$ 是一个参数为 $\\alpha_n$ 和 $\\beta_n$ 的逆伽马分布。\n$$\ns^2 | y, X \\sim \\mathrm{InvGamma}(\\alpha_n, \\beta_n)\n$$\n一个 $\\mathrm{InvGamma}(\\alpha, \\beta)$ 随机变量的均值为 $E[s^2] = \\frac{\\beta}{\\alpha - 1}$，前提是 $\\alpha > 1$。在我们的案例中，后验参数为 $\\alpha_n = \\alpha_0 + N/2 = 2.0 + 5/2 = 4.5$，满足该条件。\n因此，偏差方差的后验均值为：\n$$\nE[s^2 | y, X] = \\frac{\\beta_n}{\\alpha_n - 1}\n$$\n\n这些方程为解决该问题提供了完整的分析框架。实施将涉及将这些公式应用于测试套件中提供的数据集。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Bayesian calibration problem for the given test cases.\n    \"\"\"\n\n    # Physical Constants and Prior Hyperparameters\n    KB = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    # Prior for theta = [a, b]^T | s^2 ~ N(m0, s^2 * S0)\n    m0 = np.array([np.log(1000.0), -3000.0])\n    S0 = np.array([[10.0, 0.0], [0.0, 1.0e7]])\n\n    # Prior for s^2 ~ InvGamma(alpha0, beta0)\n    alpha0 = 2.0\n    beta0 = 0.05\n\n    test_cases = [\n        # Case 1 (happy path, moderate activation)\n        {\n            \"T\": np.array([300, 320, 340, 360, 380]),\n            \"sigma\": np.array([0.0068, 0.0130, 0.0245, 0.0540, 0.1050]),\n        },\n        # Case 2 (boundary, nearly flat temperature dependence)\n        {\n            \"T\": np.array([300, 320, 340, 360, 380]),\n            \"sigma\": np.array([0.0480, 0.0530, 0.0610, 0.0680, 0.0740]),\n        },\n        # Case 3 (edge, high discrepancy/noise)\n        {\n            \"T\": np.array([300, 320, 340, 360, 380]),\n            \"sigma\": np.array([0.0100, 0.0080, 0.0300, 0.0400, 0.1200]),\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        T_data = case[\"T\"]\n        sigma_data = case[\"sigma\"]\n\n        # 1. Transform data and construct design matrix\n        y = np.log(sigma_data)\n        x = 1.0 / T_data\n        N = len(y)\n        X = np.vstack([np.ones(N), x]).T\n\n        # 2. Compute posterior hyperparameters for the Normal-Inverse-Gamma distribution\n\n        # Pre-compute matrix inverses and products\n        S0_inv = np.linalg.inv(S0)\n        XT_X = X.T @ X\n        XT_y = X.T @ y\n\n        # Posterior for theta | s^2 ~ N(mn, s^2 * Sn)\n        Sn_inv = S0_inv + XT_X\n        Sn = np.linalg.inv(Sn_inv)\n        mn = Sn @ (S0_inv @ m0 + XT_y)\n\n        # Posterior for s^2 ~ InvGamma(alphan, betan)\n        alphan = alpha0 + N / 2.0\n        \n        # Calculation for betan:\n        # betan = beta0 + 0.5 * (m0^T @ S0_inv @ m0 + y^T @ y - mn^T @ Sn_inv @ mn)\n        term1 = m0.T @ S0_inv @ m0\n        term2 = y.T @ y\n        term3 = mn.T @ Sn_inv @ mn\n        betan = beta0 + 0.5 * (term1 + term2 - term3)\n\n        # 3. Calculate posterior means of the physical quantities\n\n        # Posterior mean of E_a (in eV)\n        # E[E_a] = -kB * E[b] = -kB * mn[1]\n        post_mean_Ea = -KB * mn[1]\n\n        # Posterior mean of sigma_0 (in S/m)\n        # E[sigma_0] approx exp(E[a]) = exp(mn[0])\n        post_mean_sigma0 = np.exp(mn[0])\n\n        # Posterior mean of s^2 (dimensionless)\n        # E[s^2] = betan / (alphan - 1)\n        post_mean_s2 = betan / (alphan - 1.0)\n        \n        all_results.extend([post_mean_Ea, post_mean_sigma0, post_mean_s2])\n\n    # Format the final output string\n    formatted_results = [f\"{r:.6f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个参数化的模型必须经过严格的验证才能投入使用。一个常见的误区是仅仅检验模型能否再现径向分布函数（$g(r)$）等简单的对关联。本练习旨在揭示这种方法的局限性，指导您计算更高阶的三体角向关联，以检验模型是否能捕捉到离子液体和聚合物电解质中至关重要的局部结构基元，例如离子笼。",
            "id": "4238726",
            "problem": "考虑一个由阳离子和阴离子组成的二元离子体系，该体系被限制在一个边长为 $L$ 的立方周期性盒子中，其中阳离子数量为 $N_{\\mathrm{C}}$，阴离子数量为 $N_{\\mathrm{A}}$。设 $\\mathbf{r}_i^{\\mathrm{C}} \\in \\mathbb{R}^3$ 表示阳离子位置，$\\mathbf{r}_j^{\\mathrm{A}} \\in \\mathbb{R}^3$ 表示阴离子位置。距离是使用最小镜像约定在周期性边界条件下计算的。目标是定义并计算阳离子-阴离子-阴离子三联体的三体角分布函数，并评估那些能够再现阳离子-阴离子径向分布函数的粗粒化模型是否也能捕捉到指示离子笼存在的角关联。\n\n从均匀系统中阳离子-阴离子径向分布函数 $g_{\\mathrm{CA}}(r)$ 的基本定义开始，\n$$\ng_{\\mathrm{CA}}(r) = \\frac{1}{\\rho_{\\mathrm{A}}} \\frac{1}{4\\pi r^2} \\frac{1}{N_{\\mathrm{C}}} \\left\\langle \\sum_{i=1}^{N_{\\mathrm{C}}} \\sum_{j=1}^{N_{\\mathrm{A}}} \\delta\\!\\left(r - \\left\\|\\mathbf{r}_i^{\\mathrm{C}} - \\mathbf{r}_j^{\\mathrm{A}}\\right\\|_{\\mathrm{MI}}\\right) \\right\\rangle,\n$$\n其中 $\\rho_{\\mathrm{A}} = N_{\\mathrm{A}}/V$ 是阴离子数密度，$V=L^3$ 是体积，$\\|\\cdot\\|_{\\mathrm{MI}}$ 表示周期性盒子中的最小镜像范数。\n\n对于一个阴离子-阳离子-阴离子三联体 $(j,i,k)$，定义一个以阳离子为中心的三体角 $\\theta$ 为向量 $\\mathbf{r}_{ij} = \\mathbf{r}_j^{\\mathrm{A}} - \\mathbf{r}_i^{\\mathrm{C}}$ 和 $\\mathbf{r}_{ik} = \\mathbf{r}_k^{\\mathrm{A}} - \\mathbf{r}_i^{\\mathrm{C}}$ 经过最小镜像映射约化后的夹角：\n$$\n\\theta_{jik} = \\arccos\\!\\left( \\frac{\\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ik}}{\\|\\mathbf{r}_{ij}\\|\\, \\|\\mathbf{r}_{ik}\\|} \\right), \\quad \\theta_{jik} \\in [0,\\pi].\n$$\n从每个阳离子周围第一配位壳层中的无序阴离子对 $(j,k)$ 形成的所有此类角度集合中，通过在 $[0,\\pi]$ 范围内进行直方图统计并归一化，构建角度概率密度 $p(\\theta)$，使得 $\\int_0^\\pi p(\\theta)\\, d\\theta = 1$。为消除在球面上均匀采样产生的几何偏差，定义几何校正角分布函数\n$$\nA(\\theta) = \\frac{p(\\theta)}{\\frac{1}{2}\\sin\\theta} \\Bigg/ \\left( \\int_0^\\pi \\frac{p(\\vartheta)}{\\frac{1}{2}\\sin\\vartheta}\\, d\\vartheta \\right),\n$$\n这样，如果阴离子方向在阳离子周围均匀分布，则 $A(\\theta)$ 在 $\\theta \\in [0,\\pi]$ 上近似为常数。离子笼对应于在 $A(\\theta)$ 中产生显著峰值的角关联。\n\n第一配位壳层是通过 $g_{\\mathrm{CA}}(r)$ 的第一个峰值 $r_{\\mathrm{peak}}$ 之后的第一个极小值 $r_{\\min}$ 来操作性地确定的，壳层内的阴离子满足 $\\|\\mathbf{r}_{ij}\\| \\le r_{\\min}$。\n\n你必须实现一个算法，该算法：\n1.  根据位置使用周期性最小镜像计算 $g_{\\mathrm{CA}}(r)$，并通过定位一个轻微平滑处理的 $g_{\\mathrm{CA}}(r)$ 的第一个局部极大值和随后的第一个局部极小值来估计 $r_{\\mathrm{peak}}$ 和 $r_{\\min}$。\n2.  从所有阳离子-阴离子-阴离子三联体中计算几何校正角分布 $A(\\theta)$，其中两个阴离子都位于阳离子的 $r_{\\min}$ 范围之内。角度必须以弧度为单位。\n3.  通过两个度量标准比较一个粗粒化模型 (CG) 和一个原子级参考 (AT)：\n    -   一个径向度量，定义为两条归一化的 $g_{\\mathrm{CA}}(r)$ 曲线在直方图区间中心上的平方 $L^2$ 范数，\n        $$\n        \\Delta_r = \\left\\| g_{\\mathrm{CA}}^{\\mathrm{CG}} - g_{\\mathrm{CA}}^{\\mathrm{AT}} \\right\\|_2,\n        $$\n        如果 $\\Delta_r \\le \\varepsilon_r$，则声明径向匹配满足。\n    -   一个角度度量，定义为两个几何校正分布在角度区间中心上的平方 $L^2$ 范数，\n        $$\n        \\Delta_\\theta = \\left\\| A^{\\mathrm{CG}} - A^{\\mathrm{AT}} \\right\\|_2,\n        $$\n        如果 $\\Delta_\\theta \\le \\varepsilon_\\theta$，则声明角度匹配满足。\n4.  对于每个测试用例，当且仅当径向和角度匹配都满足，并且统计量充足（量化为要求 AT 和 CG 数据集中的角度数均不少于 $M_{\\min}$）时，返回一个布尔值 `true`；否则返回 `false`。\n\n角度必须以弧度处理。距离必须以纳米计算。最终结果是布尔值，因此输出中不需要进行物理单位转换。\n\n测试套件。使用以下四个测试用例，每个用例由一个参数元组指定，用于指导合成系统的生成和比较：\n-   用例 1 (理想路径)：$(L, N_{\\mathrm{C}}, N_{\\mathrm{A}}, r_0, \\sigma_r, \\text{seed}) = (4.0\\,\\mathrm{nm}, 32, 256, 0.45\\,\\mathrm{nm}, 0.02\\,\\mathrm{nm}, 123)$。通过在盒子中均匀放置 $N_{\\mathrm{C}}$ 个阳离子来构建 AT，并为每个阳离子在距离 $r_0$ 处、方向为 $\\{\\pm \\hat{x}, \\pm \\hat{y}, \\pm \\hat{z}\\}$ 的位置放置 $8$ 个阴离子，并带有标准差为 $\\sigma_r$ 的独立高斯径向噪声；将其余阴离子均匀分布在盒子中以代表体相环境。通过复制 AT 阳离子位置并生成具有相同径向距离和方向但通过小的随机位移对半径和方向均施加了标准差为 $0.01\\,\\mathrm{nm}$ 的额外小高斯噪声的阴离子来构建 CG。预期结果为 true。\n-   用例 2 (角度不匹配)：$(L, N_{\\mathrm{C}}, N_{\\mathrm{A}}, r_0, \\sigma_r, \\text{seed}) = (4.0\\,\\mathrm{nm}, 32, 256, 0.45\\,\\mathrm{nm}, 0.02\\,\\mathrm{nm}, 456)$。如用例 1 构建 AT。通过保留每个阳离子周围相同的径向距离集，但在单位球面上分配随机独立的均匀方向来构建 CG。预期结果为 false。\n-   用例 3 (径向不匹配)：$(L, N_{\\mathrm{C}}, N_{\\mathrm{A}}, r_0, \\sigma_r, \\text{seed}) = (4.0\\,\\mathrm{nm}, 32, 256, 0.45\\,\\mathrm{nm}, 0.02\\,\\mathrm{nm}, 789)$。如用例 1 构建 AT。通过将第一壳层中所有阴离子-阳离子的目标径向距离乘以因子 $1.25$，同时保持方向与 AT 中相同来构建 CG。预期结果为 false。\n-   用例 4 (统计不足边界)：$(L, N_{\\mathrm{C}}, N_{\\mathrm{A}}, r_0, \\sigma_r, \\text{seed}) = (4.0\\,\\mathrm{nm}, 12, 24, 0.45\\,\\mathrm{nm}, 0.02\\,\\mathrm{nm}, 13579)$。通过放置 $N_{\\mathrm{C}}$ 个阳离子，并为一部分阳离子仅在其附近距离 $r_0$ 内放置一个阴离子来构建 AT；将其余阴离子均匀分布在远离阳离子的地方，使得许多阳离子的第一壳层内少于两个阴离子。构建 CG 以保留相同的径向分布但具有随机方向。由于角度不足，预期结果为 false。\n\n算法和数值细节：\n-   使用边长为 $L$ 的最小镜像约定来计算 $\\|\\cdot\\|_{\\mathrm{MI}}$。\n-   在 $0$ 和 $L/2$ 之间使用 $n_r=200$ 个径向区间，在 $0$ 和 $\\pi$ 之间使用 $n_\\theta=60$ 个角度区间。\n-   在进行峰值和极小值检测之前，通过一个宽度为 $w=5$ 区间的短移动平均窗口平滑 $g_{\\mathrm{CA}}(r)$。\n-   使用容差 $\\varepsilon_r = 0.08$，$\\varepsilon_\\theta = 0.12$，以及最小角度数 $M_{\\min} = 50$。\n-   如果在 $g_{\\mathrm{CA}}(r)$ 的第一个峰值后没有找到清晰的第一个极小值，则将截断值 $r_{\\min}$ 设置为峰值后的径向区间中心加上 $0.1\\,\\mathrm{nm}$ 的边距，上限为 $L/2$。\n\n你的程序应该根据上述指令，从提供的种子确定性地生成合成数据，执行所描述的分析，并产生一行输出，其中包含所有四个用例的布尔结果，形式为方括号括起来的逗号分隔列表（例如，“[True,False,False,False]”）。",
            "solution": "用户提供的问题是有效的。这是一个在计算统计力学中定义明确的任务，植根于分子模拟数据分析的标准原则。它要求实现算法来计算径向和角分布函数，以比较离子体系的粗粒化模型和原子级模型。该问题是自洽的、科学上合理的，并且在算法上是明确的。\n\n该解决方案围绕一系列受物理启发的计算步骤构建，旨在从粒子构型中提取结构信息，并基于该信息比较不同模型。分析的核心涉及量化离子间的径向和角关联。\n\n### 原理一：系统表示与周期性边界条件\n\n该系统是在一个边长为 $L$ 的立方盒子中，$N_{\\mathrm{C}}$ 个阳离子和 $N_{\\mathrm{A}}$ 个阴离子的集合。为了模拟类体相环境并最小化表面效应，采用了周期性边界条件（PBC）。这意味着盒子在所有三个空间维度上无限复制。在计算两个粒子之间的距离或向量时，我们使用最小镜像约定（MIC）。两个粒子之间的位移向量 $\\mathbf{v}$ 通过以下方式映射到其最短的周期性镜像 $\\mathbf{v}_{\\mathrm{MI}}$：\n$$\n\\mathbf{v}_{\\mathrm{MI}} = \\mathbf{v} - L \\cdot \\mathrm{round}(\\mathbf{v} / L)\n$$\n距离就是这个最小镜像向量的欧几里得范数 $\\|\\mathbf{v}_{\\mathrm{MI}}\\|$。所有空间计算都必须严格遵守这一约定。\n\n### 原理二：径向和角关联函数\n\n为了表征离子液体的结构，我们采用两种类型的关联函数：\n\n1.  **阳离子-阴离子径向分布函数, $g_{\\mathrm{CA}}(r)$**：该函数描述了在给定阳离子一定距离 $r$ 处找到一个阴离子的概率，相对于完全随机（理想气体）分布的概率。提供的定义是：\n    $$\n    g_{\\mathrm{CA}}(r) = \\frac{V}{N_{\\mathrm{C}} N_{\\mathrm{A}}} \\left\\langle \\sum_{i=1}^{N_{\\mathrm{C}}} \\sum_{j=1}^{N_{\\mathrm{A}}} \\frac{\\delta(r - \\|\\mathbf{r}_i^{\\mathrm{C}} - \\mathbf{r}_j^{\\mathrm{A}}\\|_{\\mathrm{MI}})}{4\\pi r^2} \\right\\rangle\n    $$\n    其中 $V=L^3$ 是体积。在离散实现中，我们计算阳离子-阴离子距离的直方图。对于每个中心为 $r_k$、宽度为 $\\Delta r$ 的区间 $k$，其值计算如下：\n    $$\n    g_{\\mathrm{CA}}(r_k) = \\frac{\\text{counts}(r_k)}{N_{\\mathrm{C}}} \\frac{V}{N_{\\mathrm{A}}} \\frac{1}{4\\pi r_k^2 \\Delta r}\n    $$\n    $g_{\\mathrm{CA}}(r)$ 中的峰表示优选的堆积距离，形成配位壳层。第一个峰之后的第一个极小值 $r_{\\min}$ 是第一配位壳层的一个标准的、操作上定义的边界。\n\n2.  **几何校正角分布, $A(\\theta)$**：虽然 $g_{\\mathrm{CA}}(r)$ 捕捉了径向有序性，但它无法反映阴离子在阳离子周围的三维排列。函数 $A(\\theta)$ 旨在探测这种局部几何结构。它测量由阴离子-阳离子-阴离子三联体形成的角 $\\theta_{jik}$ 的概率分布，其中阴离子 $j$ 和 $k$ 都在阳离子 $i$ 的第一配位壳层内（即距离 $\\le r_{\\min}$）。\n\n    为了消除在球面上大角度比小角度有更多形成方式这种平凡的几何偏差，原始的角度概率密度 $p(\\theta)$ 被除以 $\\frac{1}{2}\\sin\\theta$。然后将得到的函数归一化，使其在 $[0, \\pi]$ 上的积分为单位一，从而得到 $A(\\theta)$。\n    $$\n    A(\\theta) = \\frac{p(\\theta)/\\left(\\frac{1}{2}\\sin\\theta\\right)}{\\int_0^\\pi \\left[ p(\\vartheta)/\\left(\\frac{1}{2}\\sin\\vartheta\\right) \\right] d\\vartheta}\n    $$\n    对于一个没有角度偏好的系统（阴离子在阳离子周围的球面上均匀分布），$p(\\theta)$ 与 $\\sin\\theta$ 成正比，使得 $A(\\theta)$ 成为一个常数。$A(\\theta)$ 中的峰揭示了特定的、优选的局部几何构型，例如四面体或八面体“笼”。\n\n### 原理三：算法实现与模型比较\n\n对于每个测试用例，算法按以下步骤进行，每个用例提供一个参考的“原子级”（AT）模型和一个待测试的“粗粒化”（CG）模型。\n\n1.  **数据生成**：使用为每个测试用例提供的种子和参数，确定性地生成 AT 和 CG 模型的合成粒子构型。此步骤模拟了分子动力学模拟的输出。\n\n2.  **结构分析**：处理 AT 和 CG 的构型，以计算它们各自的 $g_{\\mathrm{CA}}(r)$ 和 $A(\\theta)$ 分布。\n    *   通过将所有最小镜像的阳离子-阴离子距离统计到 $n_r=200$ 个区间中并应用归一化公式来计算 $g_{\\mathrm{CA}}(r)$。\n    *   为了稳健地找到配位壳层截断值 $r_{\\min}$，使用宽度为 $w=5$ 的移动平均滤波器对计算出的 $g_{\\mathrm{CA}}(r)$ 进行平滑处理。在平滑后的数据中定位第一个显著峰和随后的第一个极小值。\n    *   计算在 $r_{\\min}$ 截断值内的阴离子-阳离子-阴离子三联体的所有角度。统计角度总数。如果此计数低于阈值 $M_{\\min}=50$，则认为统计量不足。\n    *   如果统计量充足，则将角度统计到 $n_\\theta=60$ 个区间中形成 $p(\\theta)$，然后用它来计算归一化的、几何校正的分布 $A(\\theta)$。\n\n3.  **定量比较**：使用基于 $L^2$ 范数的两个度量标准来评估 CG 模型与 AT 参考模型的一致性，$L^2$ 范数量化了分布之间的积分差异：\n    *   **径向度量 $\\Delta_r$**：径向结构中的差异为 $\\Delta_r = \\| g_{\\mathrm{CA}}^{\\mathrm{CG}} - g_{\\mathrm{CA}}^{\\mathrm{AT}} \\|_2$。如果 $\\Delta_r \\le \\varepsilon_r = 0.08$，则宣布匹配。\n    *   **角度度量 $\\Delta_\\theta$**：角度结构中的差异为 $\\Delta_\\theta = \\| A^{\\mathrm{CG}} - A^{\\mathrm{AT}} \\|_2$。如果 $\\Delta_\\theta \\le \\varepsilon_\\theta = 0.12$，则宣布匹配。\n\n4.  **最终判定**：一个测试用例被宣布为成功（评估为 `True`）当且仅当同时满足三个条件：AT 和 CG 模型的角度数都充足（$\\ge M_{\\min}$），径向匹配满足（$\\Delta_r \\le \\varepsilon_r$），并且角度匹配满足（$\\Delta_\\theta \\le \\varepsilon_\\theta$）。否则，它失败（`False`）。这种严格、多方面的比较确保了一个成功的 CG 模型不仅能再现成对距离，还能再现定义局部离子环境的关键高阶角关联。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for comparing coarse-grained vs. atomistic models.\n    \"\"\"\n    \n    # Define problem parameters\n    N_R_BINS = 200\n    N_THETA_BINS = 60\n    SMOOTH_W = 5\n    EPSILON_R = 0.08\n    EPSILON_theta = 0.12\n    M_MIN = 50\n\n    # Define test cases\n    test_cases = [\n        # (L, Nc, Na, r0, sigma_r, seed, case_type)\n        (4.0, 32, 256, 0.45, 0.02, 123, 'happy_path'),\n        (4.0, 32, 256, 0.45, 0.02, 456, 'angular_mismatch'),\n        (4.0, 32, 256, 0.45, 0.02, 789, 'radial_mismatch'),\n        (4.0, 12, 24, 0.45, 0.02, 13579, 'insufficient_stats'),\n    ]\n\n    results = []\n    for L, Nc, Na, r0, sigma_r, seed, case_type in test_cases:\n        \n        at_pos_c, at_pos_a, cg_pos_c, cg_pos_a = generate_configurations(\n            L, Nc, Na, r0, sigma_r, seed, case_type\n        )\n\n        g_at, A_at, n_angles_at, _, _ = analyze_system(\n            at_pos_c, at_pos_a, L, N_R_BINS, N_THETA_BINS, SMOOTH_W\n        )\n        \n        g_cg, A_cg, n_angles_cg, _, _ = analyze_system(\n            cg_pos_c, cg_pos_a, L, N_R_BINS, N_THETA_BINS, SMOOTH_W\n        )\n\n        stats_ok = (n_angles_at >= M_MIN) and (n_angles_cg >= M_MIN)\n\n        if not stats_ok:\n            results.append(False)\n            continue\n            \n        delta_r = np.linalg.norm(g_cg - g_at)\n        delta_theta = np.linalg.norm(A_cg - A_at)\n\n        radial_ok = delta_r <= EPSILON_R\n        angular_ok = delta_theta <= EPSILON_theta\n        \n        results.append(radial_ok and angular_ok)\n\n    print(f\"[{','.join(map(str, [r.item() for r in results]))}]\")\n\n\ndef mic_vector(v, L):\n    \"\"\"Computes minimal image vector(s) in a cubic box of length L.\"\"\"\n    return v - L * np.round(v / L)\n\ndef generate_configurations(L, Nc, Na, r0, sigma_r, seed, case_type):\n    \"\"\"Generates AT and CG configurations based on the test case type.\"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # Generate AT configuration\n    at_pos_c = rng.uniform(0, L, size=(Nc, 3))\n    at_pos_a = np.zeros((Na, 3))\n    \n    if case_type in ['happy_path', 'angular_mismatch', 'radial_mismatch']:\n        anions_per_cation = Na // Nc\n        directions = np.array([[1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1]])\n        idx = 0\n        for i in range(Nc):\n            # Place anions around cations\n            for j in range(anions_per_cation):\n                if j < 6: # Octahedral placement first\n                    direction = directions[j]\n                else: # Add more in random directions if Na/Nc > 6\n                    u = rng.normal(size=3)\n                    direction = u / np.linalg.norm(u)\n\n                radius = rng.normal(r0, sigma_r)\n                at_pos_a[idx] = at_pos_c[i] + radius * direction\n                idx += 1\n        # Distribute remaining anions uniformly if Na is not a multiple of Nc\n        for k in range(idx, Na):\n            at_pos_a[k] = rng.uniform(0, L, size=3)\n\n    elif case_type == 'insufficient_stats':\n        anions_placed = 0\n        for i in range(Nc):\n            # Place one anion near each cation\n            if anions_placed < Na:\n                u = rng.normal(size=3)\n                direction = u / np.linalg.norm(u)\n                radius = rng.normal(r0, sigma_r)\n                at_pos_a[anions_placed] = at_pos_c[i] + radius * direction\n                anions_placed += 1\n        # Place remaining anions uniformly\n        for i in range(anions_placed, Na):\n            at_pos_a[i] = rng.uniform(0, L, size=3)\n\n    at_pos_a = np.mod(at_pos_a, L)\n\n    # Generate CG configuration\n    cg_pos_c = np.copy(at_pos_c)\n    cg_pos_a = np.zeros((Na, 3))\n\n    if case_type == 'happy_path':\n        noise = rng.normal(0, 0.01, size=at_pos_a.shape)\n        cg_pos_a = at_pos_a + noise\n\n    elif case_type == 'angular_mismatch':\n        idx = 0\n        anions_per_cation = Na // Nc\n        for i in range(Nc):\n            cation_pos = at_pos_c[i]\n            for _ in range(anions_per_cation):\n                # Preserve radial distance, randomize direction\n                disp_at = mic_vector(at_pos_a[idx] - cation_pos, L)\n                dist_at = np.linalg.norm(disp_at)\n                u_rand = rng.normal(size=3)\n                dir_rand = u_rand / np.linalg.norm(u_rand)\n                cg_pos_a[idx] = cation_pos + dist_at * dir_rand\n                idx += 1\n        for k in range(idx, Na):\n             cg_pos_a[k] = rng.uniform(0, L, size=3)\n\n\n    elif case_type == 'radial_mismatch':\n        idx = 0\n        anions_per_cation = Na // Nc\n        for i in range(Nc):\n            cation_pos = at_pos_c[i]\n            for _ in range(anions_per_cation):\n                # Scale radial distance\n                disp_at = mic_vector(at_pos_a[idx] - cation_pos, L)\n                cg_pos_a[idx] = cation_pos + 1.25 * disp_at\n                idx += 1\n        for k in range(idx, Na):\n             cg_pos_a[k] = at_pos_a[k]\n\n    elif case_type == 'insufficient_stats':\n        # Preserve radial dist, randomize direction, as in angular mismatch\n        anions_placed = 0\n        for i in range(Nc):\n            if anions_placed < Na:\n                disp_at = mic_vector(at_pos_a[anions_placed] - cg_pos_c[i], L)\n                dist_at = np.linalg.norm(disp_at)\n                u_rand = rng.normal(size=3)\n                dir_rand = u_rand / np.linalg.norm(u_rand)\n                cg_pos_a[anions_placed] = cg_pos_c[i] + dist_at * dir_rand\n                anions_placed += 1\n        for i in range(anions_placed, Na):\n            cg_pos_a[i] = at_pos_a[i]\n\n    cg_pos_a = np.mod(cg_pos_a, L)\n    \n    return at_pos_c, at_pos_a, cg_pos_c, cg_pos_a\n\ndef analyze_system(cat_pos, an_pos, L, n_r, n_theta, w):\n    \"\"\"Computes g(r), A(theta), and number of angles for a given system.\"\"\"\n    Nc, Na = len(cat_pos), len(an_pos)\n    V = L**3\n    rho_A = Na / V\n\n    # --- 1. Compute g(r) ---\n    r_max = L / 2\n    dr = r_max / n_r\n    r_bins = np.linspace(0, r_max, n_r + 1)\n    r_centers = (r_bins[:-1] + r_bins[1:]) / 2\n    counts = np.zeros(n_r, dtype=int)\n\n    for i in range(Nc):\n        disps = an_pos - cat_pos[i]\n        disps_mic = mic_vector(disps, L)\n        dists = np.linalg.norm(disps_mic, axis=1)\n        \n        valid_dists = dists[dists < r_max]\n        bin_indices = (valid_dists / dr).astype(int)\n        np.add.at(counts, bin_indices, 1)\n\n    shell_volumes = 4 * np.pi * r_centers**2 * dr\n    # Avoid division by zero at r=0\n    g_ca = np.zeros_like(shell_volumes)\n    non_zero_vols = shell_volumes > 1e-9\n    g_ca[non_zero_vols] = (counts[non_zero_vols] / Nc) / (rho_A * shell_volumes[non_zero_vols])\n\n    # --- 2. Find r_min ---\n    g_smooth = np.convolve(g_ca, np.ones(w)/w, mode='same')\n    peaks, _ = find_peaks(g_smooth)\n    if not len(peaks): # No peak found\n        first_peak_idx = np.argmax(g_smooth)\n    else:\n        first_peak_idx = peaks[0]\n\n    minima, _ = find_peaks(-g_smooth[first_peak_idx:])\n    if not len(minima):\n        r_peak_center = r_centers[first_peak_idx]\n        r_min = min(r_peak_center + 0.1, r_max)\n    else:\n        first_min_idx = minima[0] + first_peak_idx\n        r_min = r_centers[first_min_idx]\n\n    # --- 3. Compute A(theta) ---\n    theta_max = np.pi\n    dtheta = theta_max / n_theta\n    theta_bins = np.linspace(0, theta_max, n_theta + 1)\n    theta_centers = (theta_bins[:-1] + theta_bins[1:]) / 2\n    \n    angles = []\n    for i in range(Nc):\n        disps = an_pos - cat_pos[i]\n        disps_mic = mic_vector(disps, L)\n        dists = np.linalg.norm(disps_mic, axis=1)\n        \n        neighbor_indices = np.where(dists <= r_min)[0]\n        if len(neighbor_indices) < 2:\n            continue\n            \n        neighbor_vectors = disps_mic[neighbor_indices]\n        num_neighbors = len(neighbor_indices)\n        \n        for j1 in range(num_neighbors):\n            for j2 in range(j1 + 1, num_neighbors):\n                v1 = neighbor_vectors[j1]\n                v2 = neighbor_vectors[j2]\n                \n                cos_theta = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\n                cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                angle = np.arccos(cos_theta)\n                angles.append(angle)\n\n    n_angles = len(angles)\n    if n_angles == 0:\n        return g_ca, np.zeros(n_theta), 0, r_centers, theta_centers\n\n    p_counts, _ = np.histogram(angles, bins=theta_bins)\n    p_theta = p_counts / (n_angles * dtheta)\n\n    sin_factor = 0.5 * np.sin(theta_centers)\n    \n    A_theta_raw = np.zeros_like(p_theta)\n    non_zero_sin = sin_factor > 1e-9\n    A_theta_raw[non_zero_sin] = p_theta[non_zero_sin] / sin_factor[non_zero_sin]\n\n    norm_const = np.sum(A_theta_raw) * dtheta\n    A_theta = A_theta_raw / norm_const if norm_const > 1e-9 else np.zeros_like(A_theta_raw)\n    \n    return g_ca, A_theta, n_angles, r_centers, theta_centers\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "许多粗粒化模型的最终目标是预测宏观性质。本练习提供了一个极具代表性的范例，展示如何利用 Kirkwood-Buff 理论，从微观结构信息（由径向分布函数给出）出发，计算出关键的宏观热力学性质——平均离子活度系数 $\\gamma_{\\pm}$。掌握这项技能对于理解溶液行为和设计新型电解质至关重要。",
            "id": "4238706",
            "problem": "给你一个聚环氧乙烷 (PEO)-锂 (Li) 聚合物电解质的粗粒度模型，其中每种化学物种由单一类型的位点表示：溶剂 PEO 链段 $(i=1)$、锂阳离子 $(i=2)$ 和阴离子 $(i=3)$。结构信息通过解析径向分布函数 (RDFs) $g_{ij}(r;c)$ 提供，该函数依赖于分离距离 $r$ 和以摩尔/升 (M) 为单位的体盐浓度 $c$。使用 Kirkwood–Buff 理论，计算作为盐浓度函数的平均离子活度系数 $\\gamma_{\\pm}(c)$，并针对一组指定的测试浓度进行计算。根据聚合物电解质的预期实验行为验证计算出的趋势，即在低浓度下由于有利的溶剂化而下降，随后在较高浓度下由于离子配对和溶剂化减弱而上升。\n\n使用的基本原理：\n- 巨正则系综中溶液的统计力学。\n- 径向分布函数 $g_{ij}(r)$ 及其总相关函数 $h_{ij}(r) = g_{ij}(r) - 1$ 的定义。\n- Kirkwood–Buff 积分：\n$$\nG_{ij}(c) = 4\\pi \\int_{0}^{\\infty} \\left[g_{ij}(r;c) - 1\\right] r^2 \\, dr,\n$$\n其单位为体积。\n- 涨落-响应关系 (巨正则系综)：浓度涨落矩阵\n$$\nC_{ij}(\\boldsymbol{\\rho}, c) = \\rho_i \\delta_{ij} + \\rho_i \\rho_j G_{ij}(c),\n$$\n以及化学势对密度的导数\n$$\n\\frac{\\partial \\mu_i}{\\partial \\rho_j} = k_{\\mathrm{B}} T \\left[C^{-1}(\\boldsymbol{\\rho}, c)\\right]_{ij},\n$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度，$\\boldsymbol{\\rho} = (\\rho_1,\\rho_2,\\rho_3)$ 是数密度。对于理想混合物（无相关性），$G_{ij}=0$ 且 $C_{ij}^{\\mathrm{id}} = \\rho_i \\delta_{ij}$，因此 $\\left[C^{\\mathrm{id}}\\right]^{-1}_{ij} = \\delta_{ij}/\\rho_i$，所以超额导数为\n$$\n\\left(\\frac{\\partial \\mu_i}{\\partial \\rho_j}\\right)^{\\mathrm{ex}} = k_{\\mathrm{B}} T \\left\\{\\left[C^{-1}\\right]_{ij} - \\frac{\\delta_{ij}}{\\rho_i}\\right\\}。\n$$\n通过沿密度空间中从零盐浓度到目标密度的路径对这些超额导数进行积分，可以得到超额化学势 $\\mu_i^{\\mathrm{ex}}(\\boldsymbol{\\rho})$，进而得到活度系数。\n\n定义、参数和单位：\n- 距离 $r$ 单位为纳米 (nm)，数密度 $\\rho_i$ 单位为 nm$^{-3}$，温度 $T = 298\\,\\mathrm{K}$，玻尔兹曼常数 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\,\\mathrm{J/K}$。\n- 阿伏伽德罗常数 $N_{\\mathrm{A}} = 6.02214076\\times 10^{23}\\,\\mathrm{mol}^{-1}$。\n- 从摩尔浓度到数密度的转换：$\\rho = c\\,N_{\\mathrm{A}}/10^{24}$ nm$^{-3}$，因为 $1\\,\\mathrm{L} = 10^{24}\\,\\mathrm{nm}^3$。数值上，$\\rho \\approx 0.602214076 \\, c$ nm$^{-3}$。\n- 在所有测试案例中，溶剂（PEO 链段）的数密度固定为 $\\rho_1 = 10.0$ nm$^{-3}$。\n- 电中性意味着 $\\rho_2 = \\rho_3 = \\rho_{\\mathrm{salt}} = 0.602214076 \\, c$ nm$^{-3}$。\n- 下面提供了 RDFs $g_{ij}(r;c)$，它们是科学上合理的粗粒度形式，能够产生收敛的 Kirkwood–Buff 积分并捕捉溶剂化和离子配对的趋势：\n\n对于 $i=j$（同类物种）：\n- PEO–PEO $(i=j=1)$：\n$$\ng_{11}(r) = 1 + S_{11}\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{11}}\\right), \\quad S_{11} = 0.10,\\ \\lambda_{11} = 0.80 \\ \\mathrm{nm}。\n$$\n- Li–Li $(i=j=2)$ 和 阴离子–阴离子 $(i=j=3)$：\n$$\ng_{22}(r;c) = 1 - H_{22}(c)\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{22}}\\right), \\quad H_{22}(c) = \\frac{0.60}{1 + 0.30\\,c},\\ \\lambda_{22} = 0.25 \\ \\mathrm{nm},\n$$\n$$\ng_{33}(r;c) = 1 - H_{33}(c)\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{33}}\\right), \\quad H_{33}(c) = \\frac{0.50}{1 + 0.30\\,c},\\ \\lambda_{33} = 0.25 \\ \\mathrm{nm}。\n$$\n\n对于 $i\\neq j$（交叉相关）：\n- Li–PEO $(i=2,j=1)$：\n$$\ng_{12}(r;c) = 1 + A_{12}(c)\\,\\exp\\!\\left(-\\frac{(r-r_{0,12})^2}{2\\sigma_{12}^2}\\right) - D_{12}\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{d,12}}\\right),\n$$\n其中 $A_{12}(c) = \\dfrac{4.0}{1 + 1.5\\,c}$，$r_{0,12} = 0.35\\,\\mathrm{nm}$，$\\sigma_{12} = 0.06\\,\\mathrm{nm}$，$D_{12} = 0.30$，$\\lambda_{d,12} = 0.50\\,\\mathrm{nm}$。\n- 阴离子–PEO $(i=3,j=1)$：\n$$\ng_{13}(r;c) = 1 + A_{13}(c)\\,\\exp\\!\\left(-\\frac{(r-r_{0,13})^2}{2\\sigma_{13}^2}\\right) - D_{13}\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{d,13}}\\right),\n$$\n其中 $A_{13}(c) = \\dfrac{2.0}{1 + 1.0\\,c}$，$r_{0,13} = 0.40\\,\\mathrm{nm}$，$\\sigma_{13} = 0.08\\,\\mathrm{nm}$，$D_{13} = 0.20$，$\\lambda_{d,13} = 0.60\\,\\mathrm{nm}$。\n- Li–阴离子 $(i=2,j=3)$：\n$$\ng_{23}(r;c) = 1 + P_{23}(c)\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{23}}\\right), \\quad P_{23}(c) = 0.20 + 0.50\\,c,\\ \\lambda_{23} = 0.20 \\ \\mathrm{nm}。\n$$\n对称性意味着 $g_{ij} = g_{ji}$，因此 $G_{ij} = G_{ji}$。\n\n计算 $\\gamma_{\\pm}(c)$ 的算法任务：\n1. 对于给定的 $c$，构建一个径向网格 $r \\in [0, R_{\\max}]$，其中 $R_{\\max} = 5.0\\,\\mathrm{nm}$，并使用足够小的均匀网格间距 $\\Delta r$ 以确保数值精度。\n2. 在网格上评估每个 $g_{ij}(r;c)$，并使用数值稳定的求积方法（如梯形法则）计算 $G_{ij}(c) = 4\\pi \\int_0^{R_{\\max}} [g_{ij}(r;c) - 1]\\,r^2\\,dr$。\n3. 使用上述规则将 $c$ 转换为数密度 $(\\rho_1,\\rho_2,\\rho_3)$，其中 $\\rho_1$ 固定，$\\rho_2=\\rho_3=0.602214076\\,c$ nm$^{-3}$。\n4. 构建矩阵 $C_{ij}(\\boldsymbol{\\rho},c) = \\rho_i \\delta_{ij} + \\rho_i \\rho_j G_{ij}(c)$。\n5. 计算 $M_{ij}(\\boldsymbol{\\rho},c) = k_{\\mathrm{B}} T\\,\\left[C^{-1}(\\boldsymbol{\\rho},c)\\right]_{ij}$ 和超额导数矩阵 $M^{\\mathrm{ex}}_{ij} = M_{ij} - k_{\\mathrm{B}} T\\,\\delta_{ij}/\\rho_i$。\n6. 沿电中性路径进行积分，其中 $\\rho_1$ 恒定，$\\rho_2 = \\rho_3 = \\rho_{\\mathrm{salt}}$ 从 0 增加到其目标值。使用离散化 $\\rho_{\\mathrm{salt}}^{(0)} \\approx 10^{-8}\\,\\mathrm{nm}^{-3}$ 以避免除以零，计算 $i=2,3$ 的情况：\n$$\n\\mu_i^{\\mathrm{ex}} = \\int_{\\rho_{\\mathrm{salt}}=0}^{\\rho_{\\mathrm{salt}}^{\\mathrm{target}}} \\left[M^{\\mathrm{ex}}_{i2}(\\boldsymbol{\\rho},c) + M^{\\mathrm{ex}}_{i3}(\\boldsymbol{\\rho},c)\\right] d\\rho_{\\mathrm{salt}}。\n$$\n7. 计算平均离子活度系数\n$$\n\\gamma_{\\pm}(c) = \\exp\\!\\left(\\frac{\\mu_2^{\\mathrm{ex}} + \\mu_3^{\\mathrm{ex}}}{2 k_{\\mathrm{B}} T}\\right),\n$$\n该系数是无量纲的。\n\n测试套件和验证：\n- 使用以下盐浓度 $c$（单位：摩尔/升 (M)）：$c \\in \\{0.01,\\ 0.10,\\ 0.50,\\ 1.00\\}$。\n- 对于每个 $c$，计算 $\\gamma_{\\pm}(c)$ 并四舍五入到四位小数。\n- 与实验趋势的验证：聚合物电解质通常表现出 $\\gamma_{\\pm}$ 在极低浓度下由于有利的溶剂化而从接近 1 的值下降，然后在较高浓度下由于显著的离子配对和减弱的溶剂化而增加。定义布尔标志 $\\mathrm{trend\\_ok}$，当且仅当序列同时满足 $\\gamma_{\\pm}(0.01) > \\gamma_{\\pm}(0.10)$ 和 $\\gamma_{\\pm}(1.00) > \\gamma_{\\pm}(0.50)$，并且列表的最小值出现在 $c=0.10$ 或 $c=0.50$ 时，该标志为真。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表。该列表必须按顺序包含四个四舍五入的活度系数，后跟布尔验证标志。例如：\"[0.9876,0.9543,1.1032,1.2541,True]\"。",
            "solution": "用户希望使用 Kirkwood–Buff 理论，为一个聚合物电解质的粗粒度模型计算平均离子活度系数 $\\gamma_{\\pm}(c)$。该问题被认为是有效的，因为它在科学上基于统计力学，提法恰当，包含了所有必要的定义和参数，并且表述客观。所提供的径向分布函数 $g_{ij}(r;c)$ 的解析形式是合理的，并允许进行完整的数值求解。\n\n解决方案通过执行问题陈述中详述的多步算法来进行。\n\n首先，我们定义所有物理常数和模型参数。\n-   玻尔兹曼常数：$k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$\n-   温度：$T = 298\\,\\mathrm{K}$\n-   阿伏伽德罗常数：$N_{\\mathrm{A}} = 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1}$\n-   从摩尔浓度 (M) 到数密度 (nm$^{-3}$) 的转换：$\\rho = c \\cdot (N_{\\mathrm{A}} / 10^{24})$，因为 $1\\,\\mathrm{L} = 10^{3}\\,\\mathrm{cm}^3 = 10^{24}\\,\\mathrm{nm}^3$。设此转换因子为 $k_c = N_{\\mathrm{A}}/10^{24} \\approx 0.602214\\,\\mathrm{nm}^{-3}\\,\\mathrm{M}^{-1}$。\n-   PEO 链段（物种1）的数密度：$\\rho_1 = 10.0\\,\\mathrm{nm}^{-3}$。\n-   阳离子（物种2）和阴离子（物种3）的数密度：$\\rho_2 = \\rho_3 = \\rho_{\\mathrm{salt}} = k_c \\cdot c$。\n\n计算的核心涉及 Kirkwood–Buff 积分 (KBIs)，$G_{ij}(c)$，定义为：\n$$\nG_{ij}(c) = 4\\pi \\int_{0}^{\\infty} h_{ij}(r;c) r^2 \\, dr\n$$\n其中 $h_{ij}(r;c) = g_{ij}(r;c) - 1$ 是总相关函数。问题为所有 $g_{ij}(r;c)$ 提供了依赖于盐浓度 $c$ 的解析表达式。这些积分使用梯形法则在从 $r=0$ 到 $R_{\\max} = 5.0\\,\\mathrm{nm}$ 的精细径向网格上进行数值计算。使用此截断是合理的，因为所有相关函数在此距离处均已指数衰减至可忽略不计的值。\n\n利用 KBIs，我们构建浓度涨落矩阵 $C_{ij}$，这是一个针对我们三组分系统的 $3 \\times 3$ 矩阵：\n$$\nC_{ij}(\\boldsymbol{\\rho}, c) = \\rho_i \\delta_{ij} + \\rho_i \\rho_j G_{ij}(c)\n$$\n其中 $\\boldsymbol{\\rho} = (\\rho_1, \\rho_2, \\rho_3)$ 是数密度向量。\n\n化学势对数密度的导数与该矩阵的逆矩阵相关：$\\partial \\mu_i / \\partial \\rho_j = k_{\\mathrm{B}} T [C^{-1}]_{ij}$。此导数的超额部分，解释了非理想相互作用，由下式给出：\n$$\n\\left(\\frac{\\partial \\mu_i}{\\partial \\rho_j}\\right)^{\\mathrm{ex}} = M^{\\mathrm{ex}}_{ij} = k_{\\mathrm{B}} T \\left( [C^{-1}]_{ij} - \\frac{\\delta_{ij}}{\\rho_i} \\right)\n$$\n离子物种（$i=2,3$）的超额化学势 $\\mu_i^{\\mathrm{ex}}$ 是通过沿指定的热力学路径对这些导数进行积分得到的。该路径是在恒定的溶剂密度 $\\rho_1$ 下，盐密度 $\\rho_2$ 和 $\\rho_3$ 从 0 一起增加到其最终值，即 $\\rho_2 = \\rho_3 = \\rho_{\\mathrm{salt}}$。超额化学势的微分为 $d\\mu_i^{\\mathrm{ex}} = \\sum_j (\\partial\\mu_i^{\\mathrm{ex}}/\\partial\\rho_j) d\\rho_j$。沿着我们的路径，$d\\rho_1=0$ 且 $d\\rho_2 = d\\rho_3 = d\\rho_{\\mathrm{salt}}$。这导出了积分式：\n$$\n\\mu_i^{\\mathrm{ex}}(\\rho_{\\mathrm{salt}}^{\\mathrm{target}}) = \\int_{0}^{\\rho_{\\mathrm{salt}}^{\\mathrm{target}}} \\left[ M^{\\mathrm{ex}}_{i2}(\\rho_{\\mathrm{salt}}) + M^{\\mathrm{ex}}_{i3}(\\rho_{\\mathrm{salt}}) \\right] d\\rho_{\\mathrm{salt}}\n$$\n该积分也使用梯形法则在 $\\rho_{\\mathrm{salt}}$ 值的网格上进行数值计算。积分下限设置为一个小的正数（$\\approx 10^{-8}\\,\\mathrm{nm}^{-3}$），以避免在 $\\rho_{\\mathrm{salt}}=0$ 时 $1/\\rho_i$ 项引起的数值问题。\n\n最后，平均离子活度系数 $\\gamma_{\\pm}(c)$ 从阳离子和阴离子的超额化学势计算得出：\n$$\n\\gamma_{\\pm}(c) = \\exp\\left(\\frac{\\mu_2^{\\mathrm{ex}} + \\mu_3^{\\mathrm{ex}}}{2 k_{\\mathrm{B}} T}\\right)\n$$\n\n对每个目标浓度 $c \\in \\{0.01, 0.10, 0.50, 1.00\\}$ 重复此整个过程。然后，将得到的 $\\gamma_{\\pm}$ 值序列与预期的实验趋势进行验证：初始下降后上升，最小值出现在中间浓度。基于此验证设置一个布尔标志 $\\mathrm{trend\\_ok}$。最终输出是一个列表，包含四个计算出的 $\\gamma_{\\pm}$ 值（四舍五入到四位小数）和布尔标志。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the mean ionic activity coefficient for a polymer electrolyte model\n    using Kirkwood-Buff theory and validates the concentration trend.\n    \"\"\"\n    # Physical and model constants\n    K_B = 1.380649e-23  # J/K\n    T = 298.0  # K\n    N_A = 6.02214076e23  # mol^-1\n    C_TO_RHO = N_A / 1e24  # (mol/L) to (nm^-3) conversion factor\n    RHO1 = 10.0  # nm^-3, fixed solvent density\n\n    # Parameters for RDFs\n    params = {\n        'g11': {'S11': 0.10, 'lambda11': 0.80},\n        'g22': {'H22_num': 0.60, 'H22_den': 0.30, 'lambda22': 0.25},\n        'g33': {'H33_num': 0.50, 'H33_den': 0.30, 'lambda33': 0.25},\n        'g12': {'A12_num': 4.0, 'A12_den': 1.5, 'r0_12': 0.35, 'sigma12': 0.06, 'D12': 0.30, 'lambda_d12': 0.50},\n        'g13': {'A13_num': 2.0, 'A13_den': 1.0, 'r0_13': 0.40, 'sigma13': 0.08, 'D13': 0.20, 'lambda_d13': 0.60},\n        'g23': {'P23_base': 0.20, 'P23_c': 0.50, 'lambda23': 0.20}\n    }\n\n    # Numerical integration settings\n    R_MAX = 5.0\n    N_R = 10001\n    r_grid = np.linspace(0, R_MAX, N_R)\n\n    def get_G_matrix(c, r):\n        \"\"\"Calculates the 3x3 matrix of Kirkwood-Buff integrals G_ij for a given concentration c.\"\"\"\n        # Calculate h_ij(r) = g_ij(r) - 1\n        p = params\n        h = np.zeros((3, 3, len(r)))\n\n        h[0, 0, :] = p['g11']['S11'] * np.exp(-r / p['g11']['lambda11'])\n        \n        H22_c = p['g22']['H22_num'] / (1 + p['g22']['H22_den'] * c)\n        h[1, 1, :] = -H22_c * np.exp(-r / p['g22']['lambda22'])\n\n        H33_c = p['g33']['H33_num'] / (1 + p['g33']['H33_den'] * c)\n        h[2, 2, :] = -H33_c * np.exp(-r / p['g33']['lambda33'])\n\n        A12_c = p['g12']['A12_num'] / (1 + p['g12']['A12_den'] * c)\n        h[0, 1, :] = (A12_c * np.exp(-(r - p['g12']['r0_12'])**2 / (2 * p['g12']['sigma12']**2))\n                    - p['g12']['D12'] * np.exp(-r / p['g12']['lambda_d12']))\n        \n        A13_c = p['g13']['A13_num'] / (1 + p['g13']['A13_den'] * c)\n        h[0, 2, :] = (A13_c * np.exp(-(r - p['g13']['r0_13'])**2 / (2 * p['g13']['sigma13']**2))\n                    - p['g13']['D13'] * np.exp(-r / p['g13']['lambda_d13']))\n\n        P23_c = p['g23']['P23_base'] + p['g23']['P23_c'] * c\n        h[1, 2, :] = P23_c * np.exp(-r / p['g23']['lambda23'])\n\n        # Create integrands and compute G_ij\n        G = np.zeros((3, 3))\n        r_sq = r**2\n        integrand_factor = 4 * np.pi\n        for i in range(3):\n            for j in range(i, 3):\n                integrand = integrand_factor * h[i, j, :] * r_sq\n                G[i, j] = np.trapz(integrand, r)\n                if i != j:\n                    G[j, i] = G[i, j]\n        return G\n\n    def get_mu_ex_integrand(rho_salt):\n        \"\"\"Calculates the integrand for the excess chemical potential integral.\"\"\"\n        c = rho_salt / C_TO_RHO\n        G = get_G_matrix(c, r_grid)\n        rhos = np.array([RHO1, rho_salt, rho_salt])\n\n        # Construct the fluctuation matrix C\n        C = np.diag(rhos) + np.outer(rhos, rhos) * G\n\n        # Invert C and calculate M_ex matrix\n        C_inv = np.linalg.inv(C)\n        M_ex = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                delta_ij = 1.0 if i == j else 0.0\n                M_ex[i, j] = K_B * T * (C_inv[i, j] - delta_ij / rhos[i])\n\n        # Integrand for mu_2^ex and mu_3^ex\n        integrand_mu2 = M_ex[1, 1] + M_ex[1, 2]\n        integrand_mu3 = M_ex[2, 1] + M_ex[2, 2]\n        return integrand_mu2, integrand_mu3\n\n    # Main calculation loop for each test concentration\n    test_cs = [0.01, 0.10, 0.50, 1.00]\n    gamma_results = []\n\n    for c_target in test_cs:\n        rho_target = c_target * C_TO_RHO\n        rho_min = 1e-8\n        N_rho = 1001\n        rho_grid = np.linspace(rho_min, rho_target, N_rho)\n        \n        vec_integrand_mu2 = np.zeros(N_rho)\n        vec_integrand_mu3 = np.zeros(N_rho)\n\n        for i, rho_s in enumerate(rho_grid):\n            ig2, ig3 = get_mu_ex_integrand(rho_s)\n            vec_integrand_mu2[i] = ig2\n            vec_integrand_mu3[i] = ig3\n        \n        mu2_ex = np.trapz(vec_integrand_mu2, rho_grid)\n        mu3_ex = np.trapz(vec_integrand_mu3, rho_grid)\n        \n        gamma_pm = np.exp((mu2_ex + mu3_ex) / (2 * K_B * T))\n        gamma_results.append(round(gamma_pm, 4))\n\n    # Trend validation\n    g = np.array(gamma_results)\n    min_idx = np.argmin(g)\n    trend_ok = (g[0] > g[1]) and (g[3] > g[2]) and (min_idx in [1, 2])\n\n    # Format final output\n    output_str = f\"[{','.join(map(str, gamma_results))},{str(trend_ok).capitalize()}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}