{
    "hands_on_practices": [
        {
            "introduction": "建立任何粗粒化模型的第一步通常是将其与已知的实验数据进行拟合，以确定其核心参数。本练习将介绍一种强大的贝叶斯推断方法，用于校准离子电导率模型。通过此练习，您不仅能学习如何获得最佳拟合参数，还能量化这些参数的不确定性以及模型本身的内在偏差，这对于严谨的科学建模至关重要 。",
            "id": "4238696",
            "problem": "考虑一个掺杂有双（三氟甲磺酰）亚胺锂（LiTFSI）的聚环氧乙烷（PEO）中离子电导率的粗粒化（CG）模型。其科学前提是，在中高温度下，聚合物电解质中的电荷传输主要由热激活跳跃主导。从过渡态理论和离子电导率（定义为电荷密度乘以迁移率）出发，在一个将结构和多体效应吸收到一个有效的、与温度无关的指前因子中的粗粒化映射下，推导出一个关于电导率自然对数的、与逆温度成线性关系的统计模型，该模型包含一个附加的、零均值的高斯偏差。然后，使用共轭正态-逆伽马模型对参数和噪声方差进行贝叶斯校准。\n\n定义和假设：\n- 令 $T$ 表示绝对温度（单位：开尔文），$\\sigma$ 表示离子电导率（单位：西门子/米，S/m）。\n- 在激活输运模型下，迁移率由活化能 $E_a$ 决定，并且在粗粒化意义上可以与一个不依赖于温度的指前因子结合，从而得到一个 $\\ln \\sigma$ 对 $1/T$ 呈线性的模型。\n- 模型与测量值之间的偏差被视为一个独立的、同分布的高斯随机变量，其方差为 $s^2$（由于模型在对数空间中，因此为无量纲）。\n- 玻尔兹曼常数（单位：电子伏特/开尔文）为 $k_B = 8.617333262145 \\times 10^{-5}$ eV/K。\n\n待推导并在解题中使用的统计公式：\n- 观测值：对于 $i = 1,\\dots,N$，定义 $y_i = \\ln \\sigma_i$ 和 $x_i = 1/T_i$。\n- 对数空间中的线性模型，带有加性高斯偏差：$y_i = a + b x_i + \\epsilon_i$，其中 $\\epsilon_i \\sim \\mathcal{N}(0, s^2)$。\n- 物理解释：$a = \\ln \\sigma_0$，其中 $\\sigma_0$ 为有效指前因子（单位：S/m）；$b = -E_a/k_B$（单位：K$^{-1}$）。\n- 贝叶斯先验（共轭正态-逆伽马）：对于 $\\theta = \\begin{bmatrix} a \\\\ b \\end{bmatrix}$，有 $\\theta \\mid s^2 \\sim \\mathcal{N}(m_0, s^2 S_0)$，且 $s^2 \\sim \\mathrm{InvGamma}(\\alpha_0, \\beta_0)$，其中逆伽马密度正比于 $(s^2)^{-\\alpha_0 - 1} \\exp(-\\beta_0 / s^2)$。\n\n你的任务：\n1. 从物理基础（激活输运和玻尔兹曼统计）出发，推导电导率对数与 $1/T$ 的线性关系表达式，并将回归系数与物理参数 $E_a$ 和 $\\sigma_0$ 关联起来。\n2. 使用上述共轭贝叶斯线性回归模型，根据先验参数 $(m_0, S_0, \\alpha_0, \\beta_0)$ 和数据 $(X, y)$ 推导后验参数 $(m_n, S_n, \\alpha_n, \\beta_n)$。其中，$X$ 是一个 $N \\times 2$ 的设计矩阵，第一列全为1，第二列为 $x_i = 1/T_i$；$y$ 是一个 $N \\times 1$ 的向量，其元素为 $y_i = \\ln \\sigma_i$。\n3. 实现一个程序，为每个给定的测试用例计算：\n   - $E_a$ 的后验均值（单位：电子伏特，eV）。\n   - $\\sigma_0$ 的后验均值（单位：西门子/米，S/m）。\n   - 偏差方差 $s^2$ 的后验均值（无量纲），作为模型偏差的定量度量。\n4. 最终输出必须为单行文本，包含所有测试用例的聚合结果，格式为方括号内由逗号分隔的列表，每个数值四舍五入到六位小数。\n\n参数先验（请精确使用以下数值）：\n- 先验均值 $m_0 = \\begin{bmatrix} \\ln(1000) \\\\ -3000 \\end{bmatrix}$。\n- 先验协方差 $S_0 = \\begin{bmatrix} 10.0  0.0 \\\\ 0.0  1.0 \\times 10^7 \\end{bmatrix}$。\n- 逆伽马先验超参数 $\\alpha_0 = 2.0$ 和 $\\beta_0 = 0.05$。\n\n测试集：\n- 用例1（理想情况，中等活化能）：\n  - 温度 $T$（开尔文）：$[300, 320, 340, 360, 380]$。\n  - 电导率 $\\sigma$（S/m）：$[0.0068, 0.0130, 0.0245, 0.0540, 0.1050]$。\n- 用例2（边界情况，几乎平坦的温度依赖性）：\n  - 温度 $T$（开尔文）：$[300, 320, 340, 360, 380]$。\n  - 电导率 $\\sigma$（S/m）：$[0.0480, 0.0530, 0.0610, 0.0680, 0.0740]$。\n- 用例3（边缘情况，高偏差/噪声）：\n  - 温度 $T$（开尔文）：$[300, 320, 340, 360, 380]$。\n  - 电导率 $\\sigma$（S/m）：$[0.0100, 0.0080, 0.0300, 0.0400, 0.1200]$。\n\n要求的输出和单位：\n- 对每个用例，计算三个量：$E_a$ 的后验均值（eV），$\\sigma_0$ 的后验均值（S/m），以及 $s^2$ 的后验均值（无量纲）。\n- 将所有九个结果聚合到单行中，格式为：$[r_1,r_2,\\dots,r_9]$，其中每个 $r_j$ 是一个四舍五入到六位小数的浮点数。\n\n你的程序应生成单行输出，包含方括号括起来的逗号分隔列表形式的结果（例如，$[0.123456,2.345678,0.001234, \\dots]$）。不允许任何其他输出。",
            "solution": "用户提供的问题是一个将贝叶斯统计推断应用于物理化学模型的有效练习。它要求从第一性原理推导模型，应用标准的贝叶斯回归公式，并实现这些公式以计算物理参数的后验估计。该问题具有科学依据，定义明确，并提供了所有必要的信息。\n\n解答按要求分为三个部分呈现：(1) 从物理原理推导线性模型，(2) 陈述贝叶斯后验参数更新方程，以及 (3) 推导目标量的计算公式。\n\n### 1. 从物理原理推导线性模型\n\n离子电导率 $\\sigma$ 由关系式 $\\sigma = \\sum_j n_j |z_j| e \\mu_j$ 定义，其中 $n_j$ 是载流子种类 $j$ 的数密度，$z_j e$ 是其电荷，$\\mu_j$ 是其迁移率。在这个针对单一主导载流子（例如 Li$^+$）的粗粒化模型中，我们可以将其简化为 $\\sigma = n q \\mu$，其中 $n$ 是移动载流子的有效密度，$q$ 是基本电荷，$\\mu$ 是有效迁移率。\n\n问题陈述，电荷传输是一个热激活过程，这可以用过渡态理论或更简单的阿伦尼乌斯型关系很好地描述。因此，迁移率 $\\mu$ 与温度 $T$ 的关系为：\n$$\n\\mu(T) = \\mu_{ref} \\exp\\left(-\\frac{E_a}{k_B T}\\right)\n$$\n其中 $E_a$ 是离子跳跃的活化能，$k_B$ 是玻尔兹曼常数，$\\mu_{ref}$ 是一个与尝试频率和熵因子相关的指前因子。\n\n将这个迁移率表达式代入电导率方程，得到：\n$$\n\\sigma(T) = (n q \\mu_{ref}) \\exp\\left(-\\frac{E_a}{k_B T}\\right)\n$$\n在粗粒化模型中，$(n q \\mu_{ref})$ 项汇集了复杂的多体和结构效应。假定在所考虑的温度范围内，它实际上与温度无关。我们将这整个项定义为有效指前因子 $\\sigma_0$：\n$$\n\\sigma_0 \\equiv n q \\mu_{ref}\n$$\n于是，电导率模型变为：\n$$\n\\sigma(T) = \\sigma_0 \\exp\\left(-\\frac{E_a}{k_B T}\\right)\n$$\n为了获得线性关系，我们对两边取自然对数：\n$$\n\\ln(\\sigma(T)) = \\ln\\left(\\sigma_0 \\exp\\left(-\\frac{E_a}{k_B T}\\right)\\right)\n$$\n利用对数的性质 $\\ln(xy) = \\ln(x) + \\ln(y)$ 和 $\\ln(\\exp(z))=z$，我们得到：\n$$\n\\ln(\\sigma(T)) = \\ln(\\sigma_0) - \\frac{E_a}{k_B} \\frac{1}{T}\n$$\n该方程具有直线 $y = a + bx$ 的形式。通过为每个数据点 $i$ 定义 $y_i = \\ln \\sigma_i$ 和 $x_i = 1/T_i$，我们得到了指定的线性模型：\n$$\ny_i = a + b x_i\n$$\n回归系数 $a$ 和 $b$ 与物理参数直接相关：\n- 截距，$a = \\ln \\sigma_0$。\n- 斜率，$b = -\\frac{E_a}{k_B}$。\n\n这便完成了线性模型的推导及其系数的物理解释。\n\n### 2. 贝叶斯后验参数推导\n\n问题指定了一个具有共轭正态-逆伽马（NIG）先验的贝叶斯线性回归框架。模型由 $y = X\\theta + \\epsilon$ 给出，其中 $\\epsilon \\sim \\mathcal{N}(0, s^2 I_N)$，$\\theta = [a, b]^T$。先验为 $p(\\theta, s^2) = p(\\theta | s^2) p(s^2)$，其中 $\\theta | s^2 \\sim \\mathcal{N}(m_0, s^2 S_0)$ 且 $s^2 \\sim \\mathrm{InvGamma}(\\alpha_0, \\beta_0)$。\n\n由于共轭性质，后验分布 $p(\\theta, s^2 | y, X)$ 也是一个正态-逆伽马分布，$p(\\theta, s^2 | y, X) \\sim \\mathrm{NIG}(m_n, S_n, \\alpha_n, \\beta_n)$。更新后的（后验）超参数 $(m_n, S_n, \\alpha_n, \\beta_n)$ 是通过将似然函数与先验分布相乘并识别结果分布的形式来推导的。这些更新方程的标准结果是：\n\n- $\\theta|s^2$ 的后验精度矩阵是先验精度与数据精度之和：$S_n^{-1} = S_0^{-1} + X^T X$。协方差矩阵是其逆：\n  $$ S_n = (S_0^{-1} + X^T X)^{-1} $$\n- $\\theta|s^2$ 的后验均值是先验均值和数据推导均值的精度加权平均：\n  $$ m_n = S_n (S_0^{-1} m_0 + X^T y) $$\n- $s^2$ 的后验形状参数通过新观测数量 $N$ 的一半进行更新：\n  $$ \\alpha_n = \\alpha_0 + \\frac{N}{2} $$\n- $s^2$ 的后验尺度参数通过先验、数据的平方误差之和以及一个解释 $\\theta$ 均值变化的项来更新：\n  $$ \\beta_n = \\beta_0 + \\frac{1}{2}(m_0^T S_0^{-1} m_0 + y^T y - m_n^T S_n^{-1} m_n) $$\n  注意，此表达式中的 $S_n^{-1}$ 是已经计算出的后验精度矩阵 $S_0^{-1} + X^T X$。\n\n### 3. 后验均值量的计算\n\n在后验分布完全由 $(m_n, S_n, \\alpha_n, \\beta_n)$ 指定后，我们可以计算物理参数的后验期望。\n\n**活化能 $E_a$ 的后验均值**：\n从关系式 $b = -E_a/k_B$，我们有 $E_a = -k_B b$。$E_a$ 的后验均值是通过对 $b$ 的后验分布取期望得到的：\n$$\nE[E_a | y, X] = E[-k_B b | y, X] = -k_B E[b | y, X]\n$$\n$\\theta$ 的边际后验分布 $p(\\theta|y, X)$ 是一个均值为 $m_n$ 的多元学生t分布。因此，$E[b | y, X]$ 是后验均值向量 $m_n$ 的第二个元素，记为 $m_{n,b}$。\n$$\nE[E_a | y, X] = -k_B \\cdot m_{n,b}\n$$\n\n**指前因子 $\\sigma_0$ 的后验均值**：\n从关系式 $a = \\ln \\sigma_0$，我们有 $\\sigma_0 = \\exp(a)$。$\\sigma_0$ 的后验均值为 $E[\\exp(a) | y, X]$。由于 $a$ 的边际后验是一个（非标准的）学生t分布，这个期望没有简单的封闭形式。一个标准且实用的近似是使用函数在参数后验均值处的值，这等效于一阶泰勒展开（或假设 $a$ 的后验高度集中在其均值附近）：\n$$\nE[\\sigma_0 | y, X] \\approx \\exp(E[a | y, X])\n$$\n后验均值 $E[a | y, X]$ 是 $m_n$ 的第一个元素，记为 $m_{n,a}$。\n$$\nE[\\sigma_0 | y, X] \\approx \\exp(m_{n,a})\n$$\n我们将计算此量。\n\n**偏差方差 $s^2$ 的后验均值**：\n方差的边际后验分布 $p(s^2|y, X)$ 是一个参数为 $\\alpha_n$ 和 $\\beta_n$ 的逆伽马分布。\n$$\ns^2 | y, X \\sim \\mathrm{InvGamma}(\\alpha_n, \\beta_n)\n$$\n一个 $\\mathrm{InvGamma}(\\alpha, \\beta)$ 随机变量的均值是 $E[s^2] = \\frac{\\beta}{\\alpha - 1}$，前提是 $\\alpha > 1$。在我们的例子中，后验参数为 $\\alpha_n = \\alpha_0 + N/2 = 2.0 + 5/2 = 4.5$，满足该条件。\n因此，偏差方差的后验均值为：\n$$\nE[s^2 | y, X] = \\frac{\\beta_n}{\\alpha_n - 1}\n$$\n\n这些方程提供了解决问题所需的完整分析框架。实施将涉及将这些公式应用于测试集中提供的数据集。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Bayesian calibration problem for the given test cases.\n    \"\"\"\n\n    # Physical Constants and Prior Hyperparameters\n    KB = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    # Prior for theta = [a, b]^T | s^2 ~ N(m0, s^2 * S0)\n    m0 = np.array([np.log(1000.0), -3000.0])\n    S0 = np.array([[10.0, 0.0], [0.0, 1.0e7]])\n\n    # Prior for s^2 ~ InvGamma(alpha0, beta0)\n    alpha0 = 2.0\n    beta0 = 0.05\n\n    test_cases = [\n        # Case 1 (happy path, moderate activation)\n        {\n            \"T\": np.array([300, 320, 340, 360, 380]),\n            \"sigma\": np.array([0.0068, 0.0130, 0.0245, 0.0540, 0.1050]),\n        },\n        # Case 2 (boundary, nearly flat temperature dependence)\n        {\n            \"T\": np.array([300, 320, 340, 360, 380]),\n            \"sigma\": np.array([0.0480, 0.0530, 0.0610, 0.0680, 0.0740]),\n        },\n        # Case 3 (edge, high discrepancy/noise)\n        {\n            \"T\": np.array([300, 320, 340, 360, 380]),\n            \"sigma\": np.array([0.0100, 0.0080, 0.0300, 0.0400, 0.1200]),\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        T_data = case[\"T\"]\n        sigma_data = case[\"sigma\"]\n\n        # 1. Transform data and construct design matrix\n        y = np.log(sigma_data)\n        x = 1.0 / T_data\n        N = len(y)\n        X = np.vstack([np.ones(N), x]).T\n\n        # 2. Compute posterior hyperparameters for the Normal-Inverse-Gamma distribution\n\n        # Pre-compute matrix inverses and products\n        S0_inv = np.linalg.inv(S0)\n        XT_X = X.T @ X\n        XT_y = X.T @ y\n\n        # Posterior for theta | s^2 ~ N(mn, s^2 * Sn)\n        Sn_inv = S0_inv + XT_X\n        Sn = np.linalg.inv(Sn_inv)\n        mn = Sn @ (S0_inv @ m0 + XT_y)\n\n        # Posterior for s^2 ~ InvGamma(alphan, betan)\n        alphan = alpha0 + N / 2.0\n        \n        # Calculation for betan:\n        # betan = beta0 + 0.5 * (m0^T @ S0_inv @ m0 + y^T @ y - mn^T @ Sn_inv @ mn)\n        term1 = m0.T @ S0_inv @ m0\n        term2 = y.T @ y\n        term3 = mn.T @ Sn_inv @ mn\n        betan = beta0 + 0.5 * (term1 + term2 - term3)\n\n        # 3. Calculate posterior means of the physical quantities\n\n        # Posterior mean of E_a (in eV)\n        # E[E_a] = -kB * E[b] = -kB * mn[1]\n        post_mean_Ea = -KB * mn[1]\n\n        # Posterior mean of sigma_0 (in S/m)\n        # E[sigma_0] approx exp(E[a]) = exp(mn[0])\n        post_mean_sigma0 = np.exp(mn[0])\n\n        # Posterior mean of s^2 (dimensionless)\n        # E[s^2] = betan / (alphan - 1)\n        post_mean_s2 = betan / (alphan - 1.0)\n        \n        all_results.extend([post_mean_Ea, post_mean_sigma0, post_mean_s2])\n\n    # Format the final output string\n    formatted_results = [f\"{r:.6f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个优秀的模型不仅要能重现其拟合的实验数据，更重要的是，它必须捕捉到底层的物理结构。本练习将超越简单的对相关函数（$g(r)$），引导您探索三体角分布，这是一个评估粗粒化模型能否准确再现离子笼等复杂局部结构的关键工具。这是对模型物理真实性的一个至关重要的考验 。",
            "id": "4238726",
            "problem": "考虑一个由阳离子和阴离子组成的二元离子体系，该体系被限制在边长为 $L$ 的立方周期性盒子中，其中阳离子数量为 $N_{\\mathrm{C}}$，阴离子数量为 $N_{\\mathrm{A}}$。令 $\\mathbf{r}_i^{\\mathrm{C}} \\in \\mathbb{R}^3$ 表示阳离子位置，$\\mathbf{r}_j^{\\mathrm{A}} \\in \\mathbb{R}^3$ 表示阴离子位置。距离在周期性边界条件下使用最小镜像约定进行计算。目标是为阳离子-阴离子-阴离子三元组定义并计算一个三体角分布函数，并评估那些能够复现阳离子-阴离子径向分布函数的粗粒化模型是否也能捕捉到指示离子笼存在的角相关性。\n\n从均匀体系中阳离子-阴离子径向分布函数 $g_{\\mathrm{CA}}(r)$ 的基本定义出发，\n$$\ng_{\\mathrm{CA}}(r) = \\frac{1}{\\rho_{\\mathrm{A}}} \\frac{1}{4\\pi r^2} \\frac{1}{N_{\\mathrm{C}}} \\left\\langle \\sum_{i=1}^{N_{\\mathrm{C}}} \\sum_{j=1}^{N_{\\mathrm{A}}} \\delta\\!\\left(r - \\left\\|\\mathbf{r}_i^{\\mathrm{C}} - \\mathbf{r}_j^{\\mathrm{A}}\\right\\|_{\\mathrm{MI}}\\right) \\right\\rangle,\n$$\n其中 $\\rho_{\\mathrm{A}} = N_{\\mathrm{A}}/V$ 是阴离子数密度，$V=L^3$ 是体积，$\\|\\cdot\\|_{\\mathrm{MI}}$ 表示周期性盒子中的最小镜像范数。\n\n为阴离子-阳离子-阴离子三元组 $(j,i,k)$ 定义一个以阳离子为中心的三体角 $\\theta$，其为经过最小镜像映射约化后的矢量 $\\mathbf{r}_{ij} = \\mathbf{r}_j^{\\mathrm{A}} - \\mathbf{r}_i^{\\mathrm{C}}$ 和 $\\mathbf{r}_{ik} = \\mathbf{r}_k^{\\mathrm{A}} - \\mathbf{r}_i^{\\mathrm{C}}$ 之间的夹角：\n$$\n\\theta_{jik} = \\arccos\\!\\left( \\frac{\\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ik}}{\\|\\mathbf{r}_{ij}\\|\\, \\|\\mathbf{r}_{ik}\\|} \\right), \\quad \\theta_{jik} \\in [0,\\pi].\n$$\n从每个阳离子周围第一配位壳层中所有无序阴离子对 $(j,k)$ 形成的这类角度集合中，通过对 $[0,\\pi]$ 范围内的角度进行直方图统计，构建角概率密度 $p(\\theta)$，并将其归一化以满足 $\\int_0^\\pi p(\\theta)\\, d\\theta = 1$。为了消除在球面上均匀采样时产生的几何偏差，定义几何校正角分布函数\n$$\nA(\\theta) = \\frac{p(\\theta)}{\\frac{1}{2}\\sin\\theta} \\Bigg/ \\left( \\int_0^\\pi \\frac{p(\\vartheta)}{\\frac{1}{2}\\sin\\vartheta}\\, d\\vartheta \\right),\n$$\n这样，如果阴离子方向在阳离子周围是均匀分布的，那么 $A(\\theta)$ 在 $\\theta \\in [0,\\pi]$ 上将近似为常数。离子笼对应于在 $A(\\theta)$ 中产生明显峰值的角相关性。\n\n第一配位壳层在操作上由 $g_{\\mathrm{CA}}(r)$ 的第一个峰 $r_{\\mathrm{peak}}$ 之后的第一个极小值 $r_{\\min}$ 来确定，壳层内的阴离子满足 $\\|\\mathbf{r}_{ij}\\| \\le r_{\\min}$。\n\n您必须实现一个算法，该算法能够：\n1. 使用周期性最小镜像从位置数据计算 $g_{\\mathrm{CA}}(r)$，并通过定位轻度平滑后的 $g_{\\mathrm{CA}}(r)$ 的第一个局部极大值和随后的第一个局部极小值来估计 $r_{\\mathrm{peak}}$ 和 $r_{\\min}$。\n2. 基于所有两个阴离子都位于阳离子 $r_{\\min}$ 范围内的阳离子-阴离子-阴离子三元组，计算几何校正角分布 $A(\\theta)$。角度必须以弧度为单位。\n3. 通过两个度量标准，将粗粒化模型 (CG) 与原子级参考模型 (AT) 进行比较：\n   - 一个定义为两条归一化 $g_{\\mathrm{CA}}(r)$ 曲线在直方图箱中心上的 $L^2$ 范数的径向度量，\n     $$\n     \\Delta_r = \\left\\| g_{\\mathrm{CA}}^{\\mathrm{CG}} - g_{\\mathrm{CA}}^{\\mathrm{AT}} \\right\\|_2,\n     $$\n     如果 $\\Delta_r \\le \\varepsilon_r$，则声明径向匹配满足条件。\n   - 一个定义为两个几何校正分布在角直方图箱中心上的 $L^2$ 范数的角向度量，\n     $$\n     \\Delta_\\theta = \\left\\| A^{\\mathrm{CG}} - A^{\\mathrm{AT}} \\right\\|_2,\n     $$\n     如果 $\\Delta_\\theta \\le \\varepsilon_\\theta$，则声明角向匹配满足条件。\n4. 为每个测试用例返回一个布尔值：当且仅当径向和角向匹配都满足，并且 AT 和 CG 数据集中都有足够的统计量（量化为至少需要 $M_{\\min}$ 个角度）时，返回 true；否则返回 false。\n\n角度必须以弧度处理。距离必须以纳米计算。输出中不需要进行物理单位转换，因为最终结果是布尔值。\n\n测试套件。使用以下四个测试用例，每个用例由一组指导合成系统生成和比较的参数元组指定：\n- 用例 1 (happy path): $(L, N_{\\mathrm{C}}, N_{\\mathrm{A}}, r_0, \\sigma_r, \\text{seed}) = (4.0\\,\\mathrm{nm}, 32, 256, 0.45\\,\\mathrm{nm}, 0.02\\,\\mathrm{nm}, 123)$。通过在盒子中均匀放置 $N_{\\mathrm{C}}$ 个阳离子来构建 AT，并为每个阳离子在距离 $r_0$ 处、沿 $\\{\\pm \\hat{x}, \\pm \\hat{y}, \\pm \\hat{z}\\}$ 方向放置 8 个阴离子，其径向带有标准差为 $\\sigma_r$ 的独立高斯噪声；将其余阴离子均匀分布在盒子中以代表体环境。通过复制 AT 阳离子位置并生成具有相同径向距离和方向但通过小的随机位移对半径和方向施加了标准差为 $0.01\\,\\mathrm{nm}$ 的额外高斯噪声的阴离子来构建 CG。预期结果为 true。\n- 用例 2 (angular mismatch): $(L, N_{\\mathrm{C}}, N_{\\mathrm{A}}, r_0, \\sigma_r, \\text{seed}) = (4.0\\,\\mathrm{nm}, 32, 256, 0.45\\,\\mathrm{nm}, 0.02\\,\\mathrm{nm}, 456)$。按用例 1 的方式构建 AT。构建 CG 时，保持每个阳离子周围的径向距离集合不变，但在单位球面上均匀分配随机的独立方向。预期结果为 false。\n- 用例 3 (radial mismatch): $(L, N_{\\mathrm{C}}, N_{\\mathrm{A}}, r_0, \\sigma_r, \\text{seed}) = (4.0\\,\\mathrm{nm}, 32, 256, 0.45\\,\\mathrm{nm}, 0.02\\,\\mathrm{nm}, 789)$。按用例 1 的方式构建 AT。构建 CG 时，将第一壳层中所有的阴离子-阳离子目标径向距离乘以因子 1.25，同时保持方向与 AT 中相同。预期结果为 false。\n- 用例 4 (insufficient statistics boundary): $(L, N_{\\mathrm{C}}, N_{\\mathrm{A}}, r_0, \\sigma_r, \\text{seed}) = (4.0\\,\\mathrm{nm}, 12, 24, 0.45\\,\\mathrm{nm}, 0.02\\,\\mathrm{nm}, 13579)$。通过放置 $N_{\\mathrm{C}}$ 个阳离子来构建 AT，并为一部分阳离子在距离 $r_0$ 内只放置一个邻近的阴离子；将其他阴离子均匀分布在远离阳离子的位置，因此许多阳离子的第一壳层内少于两个阴离子。构建 CG 以保持相同的径向分布但方向随机。预期因角度不足结果为 false。\n\n算法和数值细节：\n- 使用边长为 $L$ 的盒子的最小镜像约定来计算 $\\|\\cdot\\|_{\\mathrm{MI}}$。\n- 在 $0$ 和 $L/2$ 之间使用 $n_r=200$ 个径向箱，在 $0$ 和 $\\pi$ 之间使用 $n_\\theta=60$ 个角向箱。\n- 在进行峰值和极小值检测之前，通过宽度为 $w=5$ 个箱的短移动平均窗口平滑 $g_{\\mathrm{CA}}(r)$。\n- 使用容差 $\\varepsilon_r = 0.08$，$\\varepsilon_\\theta = 0.12$，以及最小角度数 $M_{\\min} = 50$。\n- 如果在 $g_{\\mathrm{CA}}(r)$ 的第一个峰之后没有找到明确的第一个极小值，则将截断值 $r_{\\min}$ 设置为峰值后的第一个径向箱中心加上 $0.1\\,\\mathrm{nm}$ 的裕量，且上限为 $L/2$。\n\n您的程序应根据上述说明，从提供的种子确定性地实现合成数据生成，执行所述分析，并生成单行输出，其中包含所有四个用例的布尔结果，形式为方括号括起来的逗号分隔列表（例如，“[True,False,False,False]”）。",
            "solution": "用户提供的问题是有效的。这是计算统计力学中一个明确定义的任务，其基础是分子模拟数据分析的标准原理。它要求实现算法来计算径向和角分布函数，以比较离子体系的粗粒化模型和原子级模型。该问题是自包含的、科学上合理的，并且在算法上是明确的。\n\n解决方案围绕一系列受物理原理驱动的计算步骤构建，旨在从粒子构型中提取结构信息，并基于该信息比较不同的模型。分析的核心在于量化离子间的径向和角相关性。\n\n### 原理1：系统表示与周期性边界条件\n\n该系统是边长为 $L$ 的立方盒子中 $N_{\\mathrm{C}}$ 个阳离子和 $N_{\\mathrm{A}}$ 个阴离子的集合。为模拟体相环境并最小化表面效应，采用了周期性边界条件 (PBC)。这意味着盒子在所有三个空间维度上无限复制。在计算两个粒子之间的距离或矢量时，我们使用最小镜像约定 (MIC)。两个粒子间的位移矢量 $\\mathbf{v}$ 通过以下方式映射到其最短周期性镜像 $\\mathbf{v}_{\\mathrm{MI}}$：\n$$\n\\mathbf{v}_{\\mathrm{MI}} = \\mathbf{v} - L \\cdot \\mathrm{round}(\\mathbf{v} / L)\n$$\n距离则是这个最小镜像矢量的欧几里得范数，即 $\\|\\mathbf{v}_{\\mathrm{MI}}\\|$。所有空间计算都必须严格遵守此约定。\n\n### 原理2：径向与角相关函数\n\n为了表征离子液体的结构，我们采用两种类型的相关函数：\n\n1.  **阳离子-阴离子径向分布函数, $g_{\\mathrm{CA}}(r)$**：此函数描述了在给定阳离子周围距离 $r$ 处找到一个阴离子的概率，相对于完全随机（理想气体）分布的概率。其定义为：\n    $$\n    g_{\\mathrm{CA}}(r) = \\frac{V}{N_{\\mathrm{C}} N_{\\mathrm{A}}} \\left\\langle \\sum_{i=1}^{N_{\\mathrm{C}}} \\sum_{j=1}^{N_{\\mathrm{A}}} \\frac{\\delta(r - \\|\\mathbf{r}_i^{\\mathrm{C}} - \\mathbf{r}_j^{\\mathrm{A}}\\|_{\\mathrm{MI}})}{4\\pi r^2} \\right\\rangle\n    $$\n    其中 $V=L^3$ 是体积。在离散实现中，我们计算阳离子-阴离子距离的直方图。对于中心为 $r_k$、宽度为 $\\Delta r$ 的每个箱 $k$，其值计算如下：\n    $$\n    g_{\\mathrm{CA}}(r_k) = \\frac{\\text{counts}(r_k)}{N_{\\mathrm{C}}} \\frac{V}{N_{\\mathrm{A}}} \\frac{1}{4\\pi r_k^2 \\Delta r}\n    $$\n    $g_{\\mathrm{CA}}(r)$ 中的峰表示优选的堆积距离，形成配位壳层。第一个峰之后的第一个极小值 $r_{\\min}$ 是第一配位壳层的一个标准的、操作上定义的边界。\n\n2.  **几何校正角分布, $A(\\theta)$**：尽管 $g_{\\mathrm{CA}}(r)$ 捕捉了径向有序性，但它无法反映阴离子在阳离子周围的三维排列。$A(\\theta)$ 函数旨在探测这种局部几何结构。它测量由阴离子-阳离子-阴离子三元组形成的角度 $\\theta_{jik}$ 的概率分布，其中阴离子 $j$ 和 $k$ 都位于阳离子 $i$ 的第一配位壳层内（即距离 $\\le r_{\\min}$）。\n\n    为了消除在球面上形成大角度的方式比小角度更多这种微不足道的几何偏差，原始角概率密度 $p(\\theta)$ 被除以 $\\frac{1}{2}\\sin\\theta$。然后将所得函数归一化，使其在 $[0, \\pi]$ 上的积分为1，从而得到 $A(\\theta)$。\n    $$\n    A(\\theta) = \\frac{p(\\theta)/\\left(\\frac{1}{2}\\sin\\theta\\right)}{\\int_0^\\pi \\left[ p(\\vartheta)/\\left(\\frac{1}{2}\\sin\\vartheta\\right) \\right] d\\vartheta}\n    $$\n    对于没有角偏好的系统（即阴离子在阳离子周围的球面上均匀分布），$p(\\theta)$ 与 $\\sin\\theta$ 成正比，这使得 $A(\\theta)$ 成为一个常数。$A(\\theta)$ 中的峰揭示了特定的、优选的局部几何结构，例如四面体或八面体“笼”。\n\n### 原理3：算法实现与模型比较\n\n对于每个测试用例，算法按以下步骤进行，每个用例提供一个参考的“原子级”(AT) 模型和一个待测试的“粗粒化”(CG) 模型。\n\n1.  **数据生成**：使用为每个测试用例提供的种子和参数，确定性地生成 AT 和 CG 模型的合成粒子构型。此步骤模拟了分子动力学模拟的输出。\n\n2.  **结构分析**：处理 AT 和 CG 构型，以计算它们各自的 $g_{\\mathrm{CA}}(r)$ 和 $A(\\theta)$ 分布。\n    *   通过将所有最小镜像的阳离子-阴离子距离统计到 $n_r=200$ 个箱中并应用归一化公式来计算 $g_{\\mathrm{CA}}(r)$。\n    *   为稳健地找到配位壳层截断值 $r_{\\min}$，使用宽度为 $w=5$ 的移动平均滤波器对计算出的 $g_{\\mathrm{CA}}(r)$ 进行平滑处理。在平滑后的数据中定位第一个显著的峰和随后的第一个极小值。\n    *   计算 $r_{\\min}$ 截断内所有三元组的阴离子-阳离子-阴离子角度。统计总角度数。如果此计数低于阈值 $M_{\\min}=50$，则认为统计量不足。\n    *   如果统计量充足，则将角度统计到 $n_\\theta=60$ 个箱中以形成 $p(\\theta)$，然后用它来计算归一化的、几何校正的分布 $A(\\theta)$。\n\n3.  **定量比较**：使用基于 $L^2$ 范数的两个度量来评估 CG 模型对 AT 参考模型的保真度，该范数测量分布之间的积分差异：\n    *   **径向度量 $\\Delta_r$**：径向结构中的差异为 $\\Delta_r = \\| g_{\\mathrm{CA}}^{\\mathrm{CG}} - g_{\\mathrm{CA}}^{\\mathrm{AT}} \\|_2$。如果 $\\Delta_r \\le \\varepsilon_r = 0.08$，则声明匹配。\n    *   **角向度量 $\\Delta_\\theta$**：角向结构中的差异为 $\\Delta_\\theta = \\| A^{\\mathrm{CG}} - A^{\\mathrm{AT}} \\|_2$。如果 $\\Delta_\\theta \\le \\varepsilon_\\theta = 0.12$，则声明匹配。\n\n4.  **最终裁定**：当且仅当同时满足三个条件时，测试用例才被宣告成功（评估为 `True`）：AT 和 CG 模型的角度数量都足够（$\\ge M_{\\min}$），径向匹配满足（$\\Delta_r \\le \\varepsilon_r$），并且角向匹配也满足（$\\Delta_\\theta \\le \\varepsilon_\\theta$）。否则，它失败（`False`）。这种严格、多方面的比较确保了成功的 CG 模型不仅能复现成对距离，还能复现定义局部离子环境的关键高阶角相关性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for comparing coarse-grained vs. atomistic models.\n    \"\"\"\n    \n    # Define problem parameters\n    N_R_BINS = 200\n    N_THETA_BINS = 60\n    SMOOTH_W = 5\n    EPSILON_R = 0.08\n    EPSILON_theta = 0.12\n    M_MIN = 50\n\n    # Define test cases\n    test_cases = [\n        # (L, Nc, Na, r0, sigma_r, seed, case_type)\n        (4.0, 32, 256, 0.45, 0.02, 123, 'happy_path'),\n        (4.0, 32, 256, 0.45, 0.02, 456, 'angular_mismatch'),\n        (4.0, 32, 256, 0.45, 0.02, 789, 'radial_mismatch'),\n        (4.0, 12, 24, 0.45, 0.02, 13579, 'insufficient_stats'),\n    ]\n\n    results = []\n    for L, Nc, Na, r0, sigma_r, seed, case_type in test_cases:\n        \n        at_pos_c, at_pos_a, cg_pos_c, cg_pos_a = generate_configurations(\n            L, Nc, Na, r0, sigma_r, seed, case_type\n        )\n\n        g_at, A_at, n_angles_at, _, _ = analyze_system(\n            at_pos_c, at_pos_a, L, N_R_BINS, N_THETA_BINS, SMOOTH_W\n        )\n        \n        g_cg, A_cg, n_angles_cg, _, _ = analyze_system(\n            cg_pos_c, cg_pos_a, L, N_R_BINS, N_THETA_BINS, SMOOTH_W\n        )\n\n        stats_ok = (n_angles_at >= M_MIN) and (n_angles_cg >= M_MIN)\n\n        if not stats_ok:\n            results.append(False)\n            continue\n            \n        delta_r = np.linalg.norm(g_cg - g_at)\n        delta_theta = np.linalg.norm(A_cg - A_at)\n\n        radial_ok = delta_r <= EPSILON_R\n        angular_ok = delta_theta <= EPSILON_theta\n        \n        results.append(radial_ok and angular_ok)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef mic_vector(v, L):\n    \"\"\"Computes minimal image vector(s) in a cubic box of length L.\"\"\"\n    return v - L * np.round(v / L)\n\ndef generate_configurations(L, Nc, Na, r0, sigma_r, seed, case_type):\n    \"\"\"Generates AT and CG configurations based on the test case type.\"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # Generate AT configuration\n    at_pos_c = rng.uniform(0, L, size=(Nc, 3))\n    at_pos_a = np.zeros((Na, 3))\n    \n    if case_type in ['happy_path', 'angular_mismatch', 'radial_mismatch']:\n        anions_per_cation = Na // Nc\n        directions = np.array([[1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1]])\n        idx = 0\n        for i in range(Nc):\n            # Place anions around cations\n            for j in range(anions_per_cation):\n                if j < 6: # Octahedral placement first\n                    direction = directions[j]\n                else: # Add more in random directions if Na/Nc > 6\n                    u = rng.normal(size=3)\n                    direction = u / np.linalg.norm(u)\n\n                radius = rng.normal(r0, sigma_r)\n                at_pos_a[idx] = at_pos_c[i] + radius * direction\n                idx += 1\n        # Distribute remaining anions uniformly if Na is not a multiple of Nc\n        for k in range(idx, Na):\n            at_pos_a[k] = rng.uniform(0, L, size=3)\n\n    elif case_type == 'insufficient_stats':\n        anions_placed = 0\n        for i in range(Nc):\n            # Place one anion near each cation\n            if anions_placed < Na:\n                u = rng.normal(size=3)\n                direction = u / np.linalg.norm(u)\n                radius = rng.normal(r0, sigma_r)\n                at_pos_a[anions_placed] = at_pos_c[i] + radius * direction\n                anions_placed += 1\n        # Place remaining anions uniformly\n        for i in range(anions_placed, Na):\n            at_pos_a[i] = rng.uniform(0, L, size=3)\n\n    at_pos_a = np.mod(at_pos_a, L)\n\n    # Generate CG configuration\n    cg_pos_c = np.copy(at_pos_c)\n    cg_pos_a = np.zeros((Na, 3))\n\n    if case_type == 'happy_path':\n        noise = rng.normal(0, 0.01, size=at_pos_a.shape)\n        cg_pos_a = at_pos_a + noise\n\n    elif case_type == 'angular_mismatch':\n        idx = 0\n        anions_per_cation = Na // Nc\n        for i in range(Nc):\n            cation_pos = at_pos_c[i]\n            for _ in range(anions_per_cation):\n                # Preserve radial distance, randomize direction\n                disp_at = mic_vector(at_pos_a[idx] - cation_pos, L)\n                dist_at = np.linalg.norm(disp_at)\n                u_rand = rng.normal(size=3)\n                dir_rand = u_rand / np.linalg.norm(u_rand)\n                cg_pos_a[idx] = cation_pos + dist_at * dir_rand\n                idx += 1\n        for k in range(idx, Na):\n             cg_pos_a[k] = rng.uniform(0, L, size=3)\n\n\n    elif case_type == 'radial_mismatch':\n        idx = 0\n        anions_per_cation = Na // Nc\n        for i in range(Nc):\n            cation_pos = at_pos_c[i]\n            for _ in range(anions_per_cation):\n                # Scale radial distance\n                disp_at = mic_vector(at_pos_a[idx] - cation_pos, L)\n                cg_pos_a[idx] = cation_pos + 1.25 * disp_at\n                idx += 1\n        for k in range(idx, Na):\n             cg_pos_a[k] = at_pos_a[k]\n\n    elif case_type == 'insufficient_stats':\n        # Preserve radial dist, randomize direction, as in angular mismatch\n        anions_placed = 0\n        for i in range(Nc):\n            if anions_placed < Na:\n                disp_at = mic_vector(at_pos_a[anions_placed] - cg_pos_c[i], L)\n                dist_at = np.linalg.norm(disp_at)\n                u_rand = rng.normal(size=3)\n                dir_rand = u_rand / np.linalg.norm(u_rand)\n                cg_pos_a[anions_placed] = cg_pos_c[i] + dist_at * dir_rand\n                anions_placed += 1\n        for i in range(anions_placed, Na):\n            cg_pos_a[i] = at_pos_a[i]\n\n    cg_pos_a = np.mod(cg_pos_a, L)\n    \n    return at_pos_c, at_pos_a, cg_pos_c, cg_pos_a\n\ndef analyze_system(cat_pos, an_pos, L, n_r, n_theta, w):\n    \"\"\"Computes g(r), A(theta), and number of angles for a given system.\"\"\"\n    Nc, Na = len(cat_pos), len(an_pos)\n    V = L**3\n    rho_A = Na / V\n\n    # --- 1. Compute g(r) ---\n    r_max = L / 2\n    dr = r_max / n_r\n    r_bins = np.linspace(0, r_max, n_r + 1)\n    r_centers = (r_bins[:-1] + r_bins[1:]) / 2\n    counts = np.zeros(n_r, dtype=int)\n\n    for i in range(Nc):\n        disps = an_pos - cat_pos[i]\n        disps_mic = mic_vector(disps, L)\n        dists = np.linalg.norm(disps_mic, axis=1)\n        \n        valid_dists = dists[dists < r_max]\n        bin_indices = (valid_dists / dr).astype(int)\n        np.add.at(counts, bin_indices, 1)\n\n    shell_volumes = 4 * np.pi * r_centers**2 * dr\n    # Avoid division by zero at r=0\n    g_ca = np.zeros_like(shell_volumes)\n    non_zero_vols = shell_volumes > 1e-9\n    g_ca[non_zero_vols] = (counts[non_zero_vols] / Nc) / (rho_A * shell_volumes[non_zero_vols])\n\n    # --- 2. Find r_min ---\n    g_smooth = np.convolve(g_ca, np.ones(w)/w, mode='same')\n    peaks, _ = find_peaks(g_smooth)\n    if not len(peaks): # No peak found\n        first_peak_idx = np.argmax(g_smooth)\n    else:\n        first_peak_idx = peaks[0]\n\n    minima, _ = find_peaks(-g_smooth[first_peak_idx:])\n    if not len(minima):\n        r_peak_center = r_centers[first_peak_idx]\n        r_min = min(r_peak_center + 0.1, r_max)\n    else:\n        first_min_idx = minima[0] + first_peak_idx\n        r_min = r_centers[first_min_idx]\n\n    # --- 3. Compute A(theta) ---\n    theta_max = np.pi\n    dtheta = theta_max / n_theta\n    theta_bins = np.linspace(0, theta_max, n_theta + 1)\n    theta_centers = (theta_bins[:-1] + theta_bins[1:]) / 2\n    \n    angles = []\n    for i in range(Nc):\n        disps = an_pos - cat_pos[i]\n        disps_mic = mic_vector(disps, L)\n        dists = np.linalg.norm(disps_mic, axis=1)\n        \n        neighbor_indices = np.where(dists <= r_min)[0]\n        if len(neighbor_indices) < 2:\n            continue\n            \n        neighbor_vectors = disps_mic[neighbor_indices]\n        num_neighbors = len(neighbor_indices)\n        \n        for j1 in range(num_neighbors):\n            for j2 in range(j1 + 1, num_neighbors):\n                v1 = neighbor_vectors[j1]\n                v2 = neighbor_vectors[j2]\n                \n                cos_theta = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))\n                cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                angle = np.arccos(cos_theta)\n                angles.append(angle)\n\n    n_angles = len(angles)\n    if n_angles == 0:\n        return g_ca, np.zeros(n_theta), 0, r_centers, theta_centers\n\n    p_counts, _ = np.histogram(angles, bins=theta_bins)\n    p_theta = p_counts / (n_angles * dtheta)\n\n    sin_factor = 0.5 * np.sin(theta_centers)\n    \n    A_theta_raw = np.zeros_like(p_theta)\n    non_zero_sin = sin_factor > 1e-9\n    A_theta_raw[non_zero_sin] = p_theta[non_zero_sin] / sin_factor[non_zero_sin]\n\n    norm_const = np.sum(A_theta_raw) * dtheta\n    A_theta = A_theta_raw / norm_const if norm_const > 1e-9 else np.zeros_like(A_theta_raw)\n    \n    return g_ca, A_theta, n_angles, r_centers, theta_centers\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "一个成功的预测模型的最终目标是计算那些难以或无法通过实验直接测量的性质。作为收尾练习，我们将演示如何利用一个经过验证的结构模型，通过优美的 Kirkwood–Buff 理论框架，计算一个关键的热力学性质——平均离子活度系数。这个过程将微观的结构细节与宏观的溶液热力学联系起来，充分展现了粗粒化建模的强大威力 。",
            "id": "4238706",
            "problem": "给定一个聚环氧乙烷 (PEO)-锂 (Li) 聚合物电解质的粗粒度模型，其中每种化学物质由单一类型的位点表示：溶剂 PEO 链段 $(i=1)$、锂阳离子 $(i=2)$ 和阴离子 $(i=3)$。结构信息通过解析径向分布函数 (RDF) $g_{ij}(r;c)$ 提供，该函数依赖于分离距离 $r$ 和以摩尔/升 (M) 为单位的本体盐浓度 $c$。使用 Kirkwood–Buff 理论，计算平均离子活度系数 $\\gamma_{\\pm}(c)$ 作为盐浓度的函数，并针对一组指定的测试浓度进行计算。根据聚合物电解质预期的实验行为验证计算出的趋势，即在低浓度下由于有利的溶剂化而减小，随后在较高浓度下由于离子对和溶剂化减弱而增加。\n\n使用的基本原理：\n- 巨正则系综中的溶液统计力学。\n- 径向分布函数 $g_{ij}(r)$ 及其总相关函数 $h_{ij}(r) = g_{ij}(r) - 1$ 的定义。\n- Kirkwood–Buff 积分：\n$$\nG_{ij}(c) = 4\\pi \\int_{0}^{\\infty} \\left[g_{ij}(r;c) - 1\\right] r^2 \\, dr,\n$$\n其单位为体积。\n- 涨落-响应关系（巨正则系综）：浓度涨落矩阵\n$$\nC_{ij}(\\boldsymbol{\\rho}, c) = \\rho_i \\delta_{ij} + \\rho_i \\rho_j G_{ij}(c),\n$$\n以及化学势对密度的导数\n$$\n\\frac{\\partial \\mu_i}{\\partial \\rho_j} = k_{\\mathrm{B}} T \\left[C^{-1}(\\boldsymbol{\\rho}, c)\\right]_{ij},\n$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度，$\\boldsymbol{\\rho} = (\\rho_1,\\rho_2,\\rho_3)$ 是数密度。对于理想混合物（无相关性），$G_{ij}=0$ 且 $C_{ij}^{\\mathrm{id}} = \\rho_i \\delta_{ij}$，因此 $\\left[C^{\\mathrm{id}}\\right]^{-1}_{ij} = \\delta_{ij}/\\rho_i$，所以超额导数为\n$$\n\\left(\\frac{\\partial \\mu_i}{\\partial \\rho_j}\\right)^{\\mathrm{ex}} = k_{\\mathrm{B}} T \\left\\{\\left[C^{-1}\\right]_{ij} - \\frac{\\delta_{ij}}{\\rho_i}\\right\\}.\n$$\n通过在密度空间中沿一条从零盐浓度到目标密度的路径对这些超额导数进行积分，可以获得超额化学势 $\\mu_i^{\\mathrm{ex}}(\\boldsymbol{\\rho})$，进而得到活度系数。\n\n定义、参数和单位：\n- 距离 $r$ 单位为纳米 (nm)，数密度 $\\rho_i$ 单位为 nm$^{-3}$，温度 $T = 298\\,\\mathrm{K}$，玻尔兹曼常数 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\,\\mathrm{J/K}$。\n- 阿伏伽德罗常数 $N_{\\mathrm{A}} = 6.02214076\\times 10^{23}\\,\\mathrm{mol}^{-1}$。\n- 从摩尔浓度到数密度的转换：$\\rho = c\\,N_{\\mathrm{A}}/10^{24}$ nm$^{-3}$，因为 $1\\,\\mathrm{L} = 10^{24}\\,\\mathrm{nm}^3$。数值上，$\\rho \\approx 0.602214076 \\, c$ nm$^{-3}$。\n- 在所有测试案例中，溶剂（PEO 链段）的数密度固定为 $\\rho_1 = 10.0$ nm$^{-3}$。\n- 电中性意味着 $\\rho_2 = \\rho_3 = \\rho_{\\mathrm{salt}} = 0.602214076 \\, c$ nm$^{-3}$。\n- 下面提供了 RDF $g_{ij}(r;c)$，它们是科学上合理的粗粒度形式，能产生收敛的 Kirkwood–Buff 积分并捕捉溶剂化和离子对趋势：\n\n对于 $i=j$（同类物质）：\n- PEO–PEO $(i=j=1)$:\n$$\ng_{11}(r) = 1 + S_{11}\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{11}}\\right), \\quad S_{11} = 0.10,\\ \\lambda_{11} = 0.80 \\ \\mathrm{nm}.\n$$\n- Li–Li $(i=j=2)$ 和阴离子–阴离子 $(i=j=3)$:\n$$\ng_{22}(r;c) = 1 - H_{22}(c)\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{22}}\\right), \\quad H_{22}(c) = \\frac{0.60}{1 + 0.30\\,c},\\ \\lambda_{22} = 0.25 \\ \\mathrm{nm},\n$$\n$$\ng_{33}(r;c) = 1 - H_{33}(c)\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{33}}\\right), \\quad H_{33}(c) = \\frac{0.50}{1 + 0.30\\,c},\\ \\lambda_{33} = 0.25 \\ \\mathrm{nm}.\n$$\n\n对于 $i\\neq j$（交叉相关）：\n- Li–PEO $(i=2,j=1)$:\n$$\ng_{12}(r;c) = 1 + A_{12}(c)\\,\\exp\\!\\left(-\\frac{(r-r_{0,12})^2}{2\\sigma_{12}^2}\\right) - D_{12}\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{d,12}}\\right),\n$$\n其中 $A_{12}(c) = \\dfrac{4.0}{1 + 1.5\\,c}$，$r_{0,12} = 0.35\\,\\mathrm{nm}$，$\\sigma_{12} = 0.06\\,\\mathrm{nm}$，$D_{12} = 0.30$，$\\lambda_{d,12} = 0.50\\,\\mathrm{nm}$。\n- 阴离子–PEO $(i=3,j=1)$:\n$$\ng_{13}(r;c) = 1 + A_{13}(c)\\,\\exp\\!\\left(-\\frac{(r-r_{0,13})^2}{2\\sigma_{13}^2}\\right) - D_{13}\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{d,13}}\\right),\n$$\n其中 $A_{13}(c) = \\dfrac{2.0}{1 + 1.0\\,c}$，$r_{0,13} = 0.40\\,\\mathrm{nm}$，$\\sigma_{13} = 0.08\\,\\mathrm{nm}$，$D_{13} = 0.20$，$\\lambda_{d,13} = 0.60\\,\\mathrm{nm}$。\n- Li–阴离子 $(i=2,j=3)$:\n$$\ng_{23}(r;c) = 1 + P_{23}(c)\\,\\exp\\!\\left(-\\frac{r}{\\lambda_{23}}\\right), \\quad P_{23}(c) = 0.20 + 0.50\\,c,\\ \\lambda_{23} = 0.20 \\ \\mathrm{nm}.\n$$\n对称性意味着 $g_{ij} = g_{ji}$，因此 $G_{ij} = G_{ji}$。\n\n计算 $\\gamma_{\\pm}(c)$ 的算法任务：\n1. 对于给定的 $c$，构建一个径向网格 $r \\in [0, R_{\\max}]$，其中 $R_{\\max} = 5.0\\,\\mathrm{nm}$，并采用足够小的均匀网格间距 $\\Delta r$ 以确保数值精度。\n2. 在网格上评估每个 $g_{ij}(r;c)$，并使用数值稳定的求积方法（如梯形法则）计算 $G_{ij}(c) = 4\\pi \\int_0^{R_{\\max}} [g_{ij}(r;c) - 1]\\,r^2\\,dr$。\n3. 使用上述规则将 $c$ 转换为数密度 $(\\rho_1,\\rho_2,\\rho_3)$，其中 $\\rho_1$ 固定，$\\rho_2=\\rho_3=0.602214076\\,c$ nm$^{-3}$。\n4. 构建矩阵 $C_{ij}(\\boldsymbol{\\rho},c) = \\rho_i \\delta_{ij} + \\rho_i \\rho_j G_{ij}(c)$。\n5. 计算 $M_{ij}(\\boldsymbol{\\rho},c) = k_{\\mathrm{B}} T\\,\\left[C^{-1}(\\boldsymbol{\\rho},c)\\right]_{ij}$ 和超额导数矩阵 $M^{\\mathrm{ex}}_{ij} = M_{ij} - k_{\\mathrm{B}} T\\,\\delta_{ij}/\\rho_i$。\n6. 沿着电中性路径积分，其中 $\\rho_1$ 恒定，$\\rho_2 = \\rho_3 = \\rho_{\\mathrm{salt}}$ 从 $0$ 增加到其目标值。使用一个离散化值 $\\rho_{\\mathrm{salt}}^{(0)} \\approx 10^{-8}\\,\\mathrm{nm}^{-3}$ 以避免除以零，对 $i=2,3$ 计算：\n$$\n\\mu_i^{\\mathrm{ex}} = \\int_{\\rho_{\\mathrm{salt}}=0}^{\\rho_{\\mathrm{salt}}^{\\mathrm{target}}} \\left[M^{\\mathrm{ex}}_{i2}(\\boldsymbol{\\rho},c) + M^{\\mathrm{ex}}_{i3}(\\boldsymbol{\\rho},c)\\right] d\\rho_{\\mathrm{salt}}.\n$$\n7. 计算平均离子活度系数\n$$\n\\gamma_{\\pm}(c) = \\exp\\!\\left(\\frac{\\mu_2^{\\mathrm{ex}} + \\mu_3^{\\mathrm{ex}}}{2 k_{\\mathrm{B}} T}\\right),\n$$\n其为无量纲。\n\n测试套件和验证：\n- 使用以下盐浓度 $c$（单位为摩尔/升，M）：$c \\in \\{0.01,\\ 0.10,\\ 0.50,\\ 1.00\\}$。\n- 对每个 $c$，计算 $\\gamma_{\\pm}(c)$ 并四舍五入到四位小数。\n- 对照实验趋势进行验证：聚合物电解质通常表现出 $\\gamma_{\\pm}$ 在极低浓度时由于有利的溶剂化而从接近 1 的值下降，然后在较高浓度时由于显著的离子对和减弱的溶剂化而增加。定义布尔标志 $\\mathrm{trend\\_ok}$，当且仅当序列同时满足 $\\gamma_{\\pm}(0.01) > \\gamma_{\\pm}(0.10)$ 和 $\\gamma_{\\pm}(1.00) > \\gamma_{\\pm}(0.50)$，并且列表中的最小值出现在 $c=0.10$ 或 $c=0.50$ 时，该标志为真。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含四个四舍五入的活度系数，后跟布尔验证标志。例如：\"[0.9876,0.9543,1.1032,1.2541,True]\"。",
            "solution": "用户希望使用 Kirkwood–Buff 理论，为一个聚合物电解质的粗粒度模型计算平均离子活度系数 $\\gamma_{\\pm}(c)$。该问题被认为是有效的，因为它具有坚实的统计力学科学基础，定义和参数齐全，问题陈述明确，并且表述客观。所提供的径向分布函数 $g_{ij}(r;c)$ 的解析形式是合理的，并允许进行完整的数值求解。\n\n解决方案通过执行问题陈述中详述的多步算法来进行。\n\n首先，我们定义所有物理常数和模型参数。\n- 玻尔兹曼常数：$k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$\n- 温度：$T = 298\\,\\mathrm{K}$\n- 阿伏伽德罗数：$N_{\\mathrm{A}} = 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1}$\n- 从摩尔浓度 (M) 到数密度 (nm$^{-3}$) 的转换：$\\rho = c \\cdot (N_{\\mathrm{A}} / 10^{24})$，因为 $1\\,\\mathrm{L} = 10^{3}\\,\\mathrm{cm}^3 = 10^{24}\\,\\mathrm{nm}^3$。设此转换因子为 $k_c = N_{\\mathrm{A}}/10^{24} \\approx 0.602214\\,\\mathrm{nm}^{-3}\\,\\mathrm{M}^{-1}$。\n- PEO 链段（物种 1）的数密度：$\\rho_1 = 10.0\\,\\mathrm{nm}^{-3}$。\n- 阳离子（物种 2）和阴离子（物种 3）的数密度：$\\rho_2 = \\rho_3 = \\rho_{\\mathrm{salt}} = k_c \\cdot c$。\n\n计算的核心涉及 Kirkwood–Buff 积分 (KBI) $G_{ij}(c)$，其定义为：\n$$\nG_{ij}(c) = 4\\pi \\int_{0}^{\\infty} h_{ij}(r;c) r^2 \\, dr\n$$\n其中 $h_{ij}(r;c) = g_{ij}(r;c) - 1$ 是总相关函数。问题提供了所有 $g_{ij}(r;c)$ 的解析表达式，这些表达式依赖于盐浓度 $c$。这些积分是在一个从 $r=0$ 到 $R_{\\max} = 5.0\\,\\mathrm{nm}$ 的精细径向网格上，使用梯形法则进行数值计算的。这个截断距离是合理的，因为所有相关函数在此距离处都已指数衰减至可忽略的值。\n\n利用 KBI，我们构建浓度涨落矩阵 $C_{ij}$，这是一个针对我们三组分系统的 $3 \\times 3$ 矩阵：\n$$\nC_{ij}(\\boldsymbol{\\rho}, c) = \\rho_i \\delta_{ij} + \\rho_i \\rho_j G_{ij}(c)\n$$\n其中 $\\boldsymbol{\\rho} = (\\rho_1, \\rho_2, \\rho_3)$ 是数密度向量。\n\n化学势对数密度的导数与该矩阵的逆相关：$\\partial \\mu_i / \\partial \\rho_j = k_{\\mathrm{B}} T [C^{-1}]_{ij}$。该导数的超额部分，用于解释非理想相互作用，由下式给出：\n$$\n\\left(\\frac{\\partial \\mu_i}{\\partial \\rho_j}\\right)^{\\mathrm{ex}} = M^{\\mathrm{ex}}_{ij} = k_{\\mathrm{B}} T \\left( [C^{-1}]_{ij} - \\frac{\\delta_{ij}}{\\rho_i} \\right)\n$$\n离子物种 ($i=2,3$) 的超额化学势 $\\mu_i^{\\mathrm{ex}}$ 是通过沿指定的热力学路径对这些导数进行积分得到的。该路径是在溶剂密度 $\\rho_1$ 恒定的情况下，盐密度 $\\rho_2$ 和 $\\rho_3$ 从 $0$ 一同增加到它们的最终值，即 $\\rho_2 = \\rho_3 = \\rho_{\\mathrm{salt}}$。超额化学势的微分为 $d\\mu_i^{\\mathrm{ex}} = \\sum_j (\\partial\\mu_i^{\\mathrm{ex}}/\\partial\\rho_j) d\\rho_j$。沿着我们的路径，$d\\rho_1=0$ 且 $d\\rho_2 = d\\rho_3 = d\\rho_{\\mathrm{salt}}$。这导出了以下积分：\n$$\n\\mu_i^{\\mathrm{ex}}(\\rho_{\\mathrm{salt}}^{\\mathrm{target}}) = \\int_{0}^{\\rho_{\\mathrm{salt}}^{\\mathrm{target}}} \\left[ M^{\\mathrm{ex}}_{i2}(\\rho_{\\mathrm{salt}}) + M^{\\mathrm{ex}}_{i3}(\\rho_{\\mathrm{salt}}) \\right] d\\rho_{\\mathrm{salt}}\n$$\n该积分也是在一个 $\\rho_{\\mathrm{salt}}$ 值的网格上使用梯形法则进行数值计算的。积分下限被设置为一个很小的正数（$\\approx 10^{-8}\\,\\mathrm{nm}^{-3}$），以避免在 $\\rho_{\\mathrm{salt}}=0$ 时 $1/\\rho_i$ 项引起的数值问题。\n\n最后，平均离子活度系数 $\\gamma_{\\pm}(c)$ 根据阳离子和阴离子的超额化学势计算得出：\n$$\n\\gamma_{\\pm}(c) = \\exp\\left(\\frac{\\mu_2^{\\mathrm{ex}} + \\mu_3^{\\mathrm{ex}}}{2 k_{\\mathrm{B}} T}\\right)\n$$\n\n对每个目标浓度 $c \\in \\{0.01, 0.10, 0.50, 1.00\\}$ 重复整个过程。然后将得到的 $\\gamma_{\\pm}$ 值序列与预期的实验趋势进行验证：初始下降，然后上升，最小值出现在中间浓度。根据此验证设置一个布尔标志 $\\mathrm{trend\\_ok}$。最终输出是一个列表，包含四个计算出的 $\\gamma_{\\pm}$ 值（四舍五入到四位小数）和该布尔标志。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the mean ionic activity coefficient for a polymer electrolyte model\n    using Kirkwood-Buff theory and validates the concentration trend.\n    \"\"\"\n    # Physical and model constants\n    K_B = 1.380649e-23  # J/K\n    T = 298.0  # K\n    N_A = 6.02214076e23  # mol^-1\n    C_TO_RHO = N_A / 1e24  # (mol/L) to (nm^-3) conversion factor\n    RHO1 = 10.0  # nm^-3, fixed solvent density\n\n    # Parameters for RDFs\n    params = {\n        'g11': {'S11': 0.10, 'lambda11': 0.80},\n        'g22': {'H22_num': 0.60, 'H22_den': 0.30, 'lambda22': 0.25},\n        'g33': {'H33_num': 0.50, 'H33_den': 0.30, 'lambda33': 0.25},\n        'g12': {'A12_num': 4.0, 'A12_den': 1.5, 'r0_12': 0.35, 'sigma12': 0.06, 'D12': 0.30, 'lambda_d12': 0.50},\n        'g13': {'A13_num': 2.0, 'A13_den': 1.0, 'r0_13': 0.40, 'sigma13': 0.08, 'D13': 0.20, 'lambda_d13': 0.60},\n        'g23': {'P23_base': 0.20, 'P23_c': 0.50, 'lambda23': 0.20}\n    }\n\n    # Numerical integration settings\n    R_MAX = 5.0\n    N_R = 10001\n    r_grid = np.linspace(0, R_MAX, N_R)\n\n    def get_G_matrix(c, r):\n        \"\"\"Calculates the 3x3 matrix of Kirkwood-Buff integrals G_ij for a given concentration c.\"\"\"\n        # Calculate h_ij(r) = g_ij(r) - 1\n        p = params\n        h = np.zeros((3, 3, len(r)))\n\n        h[0, 0, :] = p['g11']['S11'] * np.exp(-r / p['g11']['lambda11'])\n        \n        H22_c = p['g22']['H22_num'] / (1 + p['g22']['H22_den'] * c)\n        h[1, 1, :] = -H22_c * np.exp(-r / p['g22']['lambda22'])\n\n        H33_c = p['g33']['H33_num'] / (1 + p['g33']['H33_den'] * c)\n        h[2, 2, :] = -H33_c * np.exp(-r / p['g33']['lambda33'])\n\n        A12_c = p['g12']['A12_num'] / (1 + p['g12']['A12_den'] * c)\n        h[0, 1, :] = (A12_c * np.exp(-(r - p['g12']['r0_12'])**2 / (2 * p['g12']['sigma12']**2))\n                    - p['g12']['D12'] * np.exp(-r / p['g12']['lambda_d12']))\n        \n        A13_c = p['g13']['A13_num'] / (1 + p['g13']['A13_den'] * c)\n        h[0, 2, :] = (A13_c * np.exp(-(r - p['g13']['r0_13'])**2 / (2 * p['g13']['sigma13']**2))\n                    - p['g13']['D13'] * np.exp(-r / p['g13']['lambda_d13']))\n\n        P23_c = p['g23']['P23_base'] + p['g23']['P23_c'] * c\n        h[1, 2, :] = P23_c * np.exp(-r / p['g23']['lambda23'])\n\n        # Create integrands and compute G_ij\n        G = np.zeros((3, 3))\n        r_sq = r**2\n        integrand_factor = 4 * np.pi\n        for i in range(3):\n            for j in range(i, 3):\n                integrand = integrand_factor * h[i, j, :] * r_sq\n                G[i, j] = np.trapz(integrand, r)\n                if i != j:\n                    G[j, i] = G[i, j]\n        return G\n\n    def get_mu_ex_integrand(rho_salt):\n        \"\"\"Calculates the integrand for the excess chemical potential integral.\"\"\"\n        c = rho_salt / C_TO_RHO\n        G = get_G_matrix(c, r_grid)\n        rhos = np.array([RHO1, rho_salt, rho_salt])\n\n        # Construct the fluctuation matrix C\n        C = np.diag(rhos) + np.outer(rhos, rhos) * G\n\n        # Invert C and calculate M_ex matrix\n        C_inv = np.linalg.inv(C)\n        M_ex = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                delta_ij = 1.0 if i == j else 0.0\n                M_ex[i, j] = K_B * T * (C_inv[i, j] - delta_ij / rhos[i])\n\n        # Integrand for mu_2^ex and mu_3^ex\n        integrand_mu2 = M_ex[1, 1] + M_ex[1, 2]\n        integrand_mu3 = M_ex[2, 1] + M_ex[2, 2]\n        return integrand_mu2, integrand_mu3\n\n    # Main calculation loop for each test concentration\n    test_cs = [0.01, 0.10, 0.50, 1.00]\n    gamma_results = []\n\n    for c_target in test_cs:\n        rho_target = c_target * C_TO_RHO\n        rho_min = 1e-8\n        N_rho = 1001\n        rho_grid = np.linspace(rho_min, rho_target, N_rho)\n        \n        vec_integrand_mu2 = np.zeros(N_rho)\n        vec_integrand_mu3 = np.zeros(N_rho)\n\n        for i, rho_s in enumerate(rho_grid):\n            ig2, ig3 = get_mu_ex_integrand(rho_s)\n            vec_integrand_mu2[i] = ig2\n            vec_integrand_mu3[i] = ig3\n        \n        mu2_ex = np.trapz(vec_integrand_mu2, rho_grid)\n        mu3_ex = np.trapz(vec_integrand_mu3, rho_grid)\n        \n        gamma_pm = np.exp((mu2_ex + mu3_ex) / (2 * K_B * T))\n        gamma_results.append(round(gamma_pm, 4))\n\n    # Trend validation\n    g = np.array(gamma_results)\n    min_idx = np.argmin(g)\n    trend_ok = (g[0] > g[1]) and (g[3] > g[2]) and (min_idx in [1, 2])\n\n    # Format final output\n    output_str = f\"[{','.join(map(str, gamma_results))},{trend_ok}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}