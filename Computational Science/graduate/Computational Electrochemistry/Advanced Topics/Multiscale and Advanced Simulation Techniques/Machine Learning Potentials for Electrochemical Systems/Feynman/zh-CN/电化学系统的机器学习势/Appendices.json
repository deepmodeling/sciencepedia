{
    "hands_on_practices": [
        {
            "introduction": "一个稳健的原子间势函数的基础在于其对物理学基本对称性的遵循。本练习将引导你构建一个E(3)等变的消息传递层，这是许多前沿机器学习势函数的核心。通过构建并数值验证不可约张量特征的旋转等变性，你将对如何将物理对称性直接嵌入到神经网络架构中获得深刻的实践理解。",
            "id": "4250488",
            "problem": "你的任务是在计算电化学的框架内，为离子液体构建并验证一个三维欧几里得群 (E(3)) 等变的消息传递架构。目标是实现一个算法流程，展示不可约张量特征在空间旋转下的传播。三维欧几里得群 (E(3)) 由作用于三维空间的旋转和平移组成。旋转等变性定义为：通过旋转矩阵 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 旋转输入构型，等同于通过 $\\mathbf{R}$ 的一个一致性表示来旋转输出特征；而平移不变性则通过使用相对位置向量构建操作来强制实现。你必须在一个图上构建一个消息传递方案，其中节点对应离子，边对应由距离截断决定的相邻关系。\n\n你的架构必须使用不可约特征类型，这些特征在旋转下的变换遵循以下规则：\n- 标量 (球谐阶数 $l=0$)：特征 $s_i$ 在旋转 $\\mathbf{R}$ 下满足 $s_i' = s_i$。\n- 矢量 (球谐阶数 $l=1$)：特征 $\\mathbf{v}_i$ 在旋转 $\\mathbf{R}$ 下满足 $\\mathbf{v}_i' = \\mathbf{R}\\mathbf{v}_i$。\n- 对称无迹二阶张量 (球谐阶数 $l=2$)：特征 $\\mathbf{T}_i$ 在旋转 $\\mathbf{R}$ 下满足 $\\mathbf{T}_i' = \\mathbf{R}\\mathbf{T}_i\\mathbf{R}^{\\top}$。\n\n从以下概念基础出发：\n- 欧几里得群通过旋转 $\\mathbf{R}$ 和平移 $\\mathbf{a}$ 对位置 $\\mathbf{r}_i$ 的作用产生旋转后的位置 $\\mathbf{r}_i' = \\mathbf{R}\\mathbf{r}_i + \\mathbf{a}$。通过仅使用相对位置 $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$ 和单位方向向量 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij}/\\|\\mathbf{r}_{ij}\\|$ 来强制实现平移不变性。\n- 旋转等变性要求任何由 $\\hat{\\mathbf{r}}_{ij}$ 和 $\\|\\mathbf{r}_{ij}\\|$ 的各向同性（径向）函数构建的操作在 $\\mathbf{R}$ 旋转下都有一致的变换。$\\|\\mathbf{r}_{ij}\\|$ 的各向同性函数是旋转不变的标量。\n- 二阶张量 $\\mathbf{M}$ 的对称无迹投影定义为 $\\mathrm{STT}(\\mathbf{M}) = \\tfrac{1}{2}(\\mathbf{M} + \\mathbf{M}^{\\top}) - \\tfrac{\\mathrm{tr}(\\mathbf{M})}{3}\\mathbf{I}$，其中 $\\mathbf{I}$ 是单位矩阵。\n\n实现一个单一的消息传递层，该层能够：\n- 使用对邻居的求和来初始化节点特征 $s_i$（标量）、$\\mathbf{v}_i$（矢量）和 $\\mathbf{T}_i$（对称无迹张量），求和项是 $\\|\\mathbf{r}_{ij}\\|$ 的各向同性径向函数与由 $\\hat{\\mathbf{r}}_{ij}$ 和离子电荷 $q_j$ 构造的适当几何协变体的乘积。\n- 通过仅使用从 $\\hat{\\mathbf{r}}_{ij}$、$s_j$、$\\mathbf{v}_j$ 和 $\\mathbf{T}_j$ 派生出的旋转一致的缩并和投影，聚合来自邻居 $j$ 的消息，以更新特征 $s_i$、$\\mathbf{v}_i$ 和 $\\mathbf{T}_i$。更新必须保持 E(3) 等变性：在全局旋转 $\\mathbf{R}$ 的作用下，更新后的特征必须与上述的 $s_i'$、$\\mathbf{v}_i'$ 和 $\\mathbf{T}_i'$ 的变换方式完全一致。\n- 在更新中使用各向同性标量权重（常数），以避免引入任何优选方向，从而确保旋转对称性。\n\n通过为每个测试用例执行以下验证，来数值上展示旋转等变性：\n- 计算原始位置和电荷构型的更新后特征。\n- 对所有位置应用旋转 $\\mathbf{R}$，重新计算更新后的特征，并另外通过每种不可约类型（$l=0$, $l=1$, $l=2$）的适当表示来旋转最初计算出的更新后特征。\n- 报告重新计算的特征与旋转后的特征之间在所有节点上的最大差异：对于标量是绝对差，对于矢量是差的欧几里得范数，对于张量是差的弗罗贝尼乌斯范数。差异必须表示为无量纲浮点数。\n\n物理和数值约定：\n- 位置以纳米 (nm) 为单位。\n- 旋转角度必须以弧度为单位解释。\n- 所有距离都以纳米计算，径向函数必须仅依赖于以纳米为单位测量的 $\\|\\mathbf{r}_{ij}\\|$。\n- 最终输出是表示数值残差的无量纲浮点数；输出中不应包含物理单位。\n\n测试套件：\n使用以下参数集作为输入构型。对于每个用例，程序必须应用由旋转轴和角度指定的单次旋转，并按所述计算残差。\n\n用例 1 (一般离子液体簇，正常路径):\n- 位置 (nm): $[\\,[0.0,\\,0.0,\\,0.0],\\,[0.4,\\,0.1,\\,-0.2],\\,[-0.3,\\,0.5,\\,0.2],\\,[0.2,\\,-0.4,\\,0.3],\\,[-0.5,\\,-0.1,\\,-0.4],\\,[0.1,\\,0.6,\\,-0.3]\\,]$\n- 电荷 (基本电荷单位): $[\\,1.0,\\,-1.0,\\,1.0,\\,-1.0,\\,1.0,\\,-1.0\\,]$\n- 截断半径 (nm): $0.8$\n- 旋转轴: $[\\,0.3,\\,0.7,\\,0.6\\,]$\n- 旋转角 (弧度): $0.6$\n\n用例 2 (共线邻居，结构简并):\n- 位置 (nm): $[\\,[\\,-0.5,\\,0.0,\\,0.0],\\,[\\,0.0,\\,0.0,\\,0.0],\\,[\\,0.5,\\,0.0,\\,0.0]\\,]$\n- 电荷 (基本电荷单位): $[\\,1.0,\\,-1.0,\\,1.0\\,]$\n- 截断半径 (nm): $1.0$\n- 旋转轴: $[\\,0.0,\\,0.0,\\,1.0\\,]$\n- 旋转角 (弧度): $\\pi/3$\n\n用例 3 (因截断半径过小而无邻居，边界情况):\n- 位置 (nm): $[\\,[0.0,\\,0.0,\\,0.0],\\,[0.4,\\,0.1,\\,-0.2],\\,[-0.3,\\,0.5,\\,0.2],\\,[0.2,\\,-0.4,\\,0.3],\\,[-0.5,\\,-0.1,\\,-0.4],\\,[0.1,\\,0.6,\\,-0.3]\\,]$\n- 电荷 (基本电荷单位): $[\\,1.0,\\,-1.0,\\,1.0,\\,-1.0,\\,1.0,\\,-1.0\\,]$\n- 截断半径 (nm): $0.05$\n- 旋转轴: $[\\,0.2,\\,-0.4,\\,0.9\\,]$\n- 旋转角 (弧度): $1.2$\n\n用例 4 (零旋转角，边界条件):\n- 位置 (nm): $[\\,[0.2,\\,0.2,\\,0.2],\\,[\\,-0.2,\\,-0.2,\\,-0.2],\\,[\\,0.3,\\,-0.1,\\,0.4]\\,]$\n- 电荷 (基本电荷单位): $[\\,1.0,\\,-1.0,\\,1.0\\,]$\n- 截断半径 (nm): $0.5$\n- 旋转轴: $[\\,1.0,\\,0.0,\\,0.0\\,]$\n- 旋转角 (弧度): $0.0$\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个三元素浮点数列表，对应于 $[\\,\\text{scalar\\_error},\\,\\text{vector\\_error},\\,\\text{tensor\\_error}\\,]$。例如：$[[e_{s,1},e_{v,1},e_{T,1}],[e_{s,2},e_{v,2},e_{T,2}],[e_{s,3},e_{v,3},e_{T,3}],[e_{s,4},e_{v,4},e_{T,4}]]$。",
            "solution": "该问题是有效的。它在科学上基于 E(3) 等变深度学习的原理，特别是关于构建遵循欧几里得对称性的消息传递层。这个问题是适定的，提供了所有必要的数据和定义，以获得唯一且可验证的解。语言客观、正式。\n\n问题的核心是为一个离子图实现一个单一的消息传递层，并数值上验证其旋转等变性。图的节点是离子，由其位置 $\\mathbf{r}_i$ 和电荷 $q_i$ 表征。边由距离截断 $r_{\\text{cut}}$ 定义。每个节点 $i$ 上的特征是旋转群 $\\mathrm{SO}(3)$ 的一个不可约表示，由一个标量 $s_i$（$l=0$ 型）、一个矢量 $\\mathbf{v}_i$（$l=1$ 型）和一个对称无迹二阶张量 $\\mathbf{T}_i$（$l=2$ 型）组成。\n\n在旋转 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 下，这些特征必须变换如下：\n- $s_i' = s_i$\n- $\\mathbf{v}_i' = \\mathbf{R}\\mathbf{v}_i$\n- $\\mathbf{T}_i' = \\mathbf{R}\\mathbf{T}_i\\mathbf{R}^{\\top}$\n\n通过从相对位置向量 $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$ 构建所有操作，可以保证平移不变性。通过确保所有结合几何信息（源自 $\\mathbf{r}_{ij}$）和节点特征的操作在群论意义上都是有效的张量积，可以实现旋转等变性。\n\n该过程涉及两个主要阶段：特征初始化和特征更新。\n\n**步骤 1：特征初始化**\n\n首先，通过对每个离子 $i$ 的邻居 $j$（其中 $\\|\\mathbf{r}_{ij}\\| < r_{\\text{cut}}$）的贡献求和，计算初始特征（$s_i^{(0)}, \\mathbf{v}_i^{(0)}, \\mathbf{T}_i^{(0)}$）。这些初始特征是根据可用的最基本的等变体构建的：标量电荷 $q_j$ 和矢量化的单位方向向量 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / \\|\\mathbf{r}_{ij}\\|$。\n\n- **标量初始化 ($l=0$)：** 标量可以通过对其他标量求和形成。我们使用邻居的电荷 $q_j$。\n$$s_i^{(0)} = \\sum_{j \\in \\mathcal{N}(i)} q_j$$\n由于 $q_j$ 是标量，$s_i^{(0)}$ 也是一个标量，并且变换正确（即，是不变的）。\n\n- **矢量初始化 ($l=1$)：** 矢量可以通过将一个标量 ($q_j$) 与一个矢量 ($\\hat{\\mathbf{r}}_{ij}$) 相乘来形成。\n$$\\mathbf{v}_i^{(0)} = \\sum_{j \\in \\mathcal{N}(i)} q_j \\hat{\\mathbf{r}}_{ij}$$\n在旋转下，$\\hat{\\mathbf{r}}_{ij} \\rightarrow \\mathbf{R}\\hat{\\mathbf{r}}_{ij}$，因此 $\\mathbf{v}_i^{(0)} \\rightarrow \\mathbf{R}\\mathbf{v}_i^{(0)}$，这是矢量的正确变换。\n\n- **张量初始化 ($l=2$)：** 对称无迹二阶张量可以通过单位向量与自身的外积 $\\hat{\\mathbf{r}}_{ij} \\hat{\\mathbf{r}}_{ij}^{\\top}$，再进行投影来构建。$\\hat{\\mathbf{r}}_{ij} \\hat{\\mathbf{r}}_{ij}^{\\top}$ 的对称无迹部分是 $\\hat{\\mathbf{r}}_{ij} \\hat{\\mathbf{r}}_{ij}^{\\top} - \\frac{1}{3}\\mathbf{I}$，因为 $\\mathrm{tr}(\\hat{\\mathbf{r}}_{ij} \\hat{\\mathbf{r}}_{ij}^{\\top}) = \\|\\hat{\\mathbf{r}}_{ij}\\|^2 = 1$。\n$$\\mathbf{T}_i^{(0)} = \\sum_{j \\in \\mathcal{N}(i)} q_j \\left( \\hat{\\mathbf{r}}_{ij} \\hat{\\mathbf{r}}_{ij}^{\\top} - \\frac{1}{3}\\mathbf{I} \\right)$$\n这种构造方式能正确地作为 $l=2$ 型张量进行变换。\n\n**步骤 2：特征更新**\n\n接下来，我们定义一个消息传递更新规则，以根据相邻节点的初始特征计算下一层的特征（$s_i^{(1)}, \\mathbf{v}_i^{(1)}, \\mathbf{T}_i^{(1)}$）。每种特征类型的更新必须是若干项之和，这些项都根据该特征的类型进行变换。这是通过在来自邻居节点 $j$ 的特征与从 $\\hat{\\mathbf{r}}_{ij}$ 导出的几何量之间形成有效的缩并（张量积）来实现的。为简单和演示起见，我们为每次更新选择一个或两个代表性的相互作用项。\n\n- **标量更新 ($l=0 \\leftarrow (l=0 \\otimes l=0) \\oplus (l=1 \\otimes l=1)$):** 标量可以由邻居的标量 $s_j^{(0)}$（一个平凡积）或由两个矢量 $\\mathbf{v}_j^{(0)}$ 和 $\\hat{\\mathbf{r}}_{ij}$ 的点积形成。\n$$s_i^{(1)} = \\sum_{j \\in \\mathcal{N}(i)} \\left( s_j^{(0)} + \\mathbf{v}_j^{(0)} \\cdot \\hat{\\mathbf{r}}_{ij} \\right)$$\n\n- **矢量更新 ($l=1 \\leftarrow (l=0 \\otimes l=1) \\oplus (l=1 \\otimes l=0) \\oplus (l=2 \\otimes l=1)$):** 矢量可以通过将标量乘以矢量（例如，$s_j^{(0)}\\hat{\\mathbf{r}}_{ij}$）、将矢量乘以标量（例如，$\\mathbf{v}_j^{(0)}$）或将张量与矢量进行缩并（例如，$\\mathbf{T}_j^{(0)}\\hat{\\mathbf{r}}_{ij}$）来形成。\n$$\\mathbf{v}_i^{(1)} = \\sum_{j \\in \\mathcal{N}(i)} \\left( s_j^{(0)}\\hat{\\mathbf{r}}_{ij} + \\mathbf{v}_j^{(0)} + \\mathbf{T}_j^{(0)}\\hat{\\mathbf{r}}_{ij} \\right)$$\n\n- **张量更新 ($l=2 \\leftarrow (l=0 \\otimes l=2) \\oplus (l=1 \\otimes l=1)$):** $l=2$ 型张量可以通过将标量乘以张量（例如，$s_j^{(0)}(\\hat{\\mathbf{r}}_{ij}\\hat{\\mathbf{r}}_{ij}^\\top - \\frac{1}{3}\\mathbf{I})$）或从两个矢量的外积的对称无迹部分形成。\n$$\\mathbf{T}_i^{(1)} = \\sum_{j \\in \\mathcal{N}(i)} \\left( s_j^{(0)}\\left(\\hat{\\mathbf{r}}_{ij}\\hat{\\mathbf{r}}_{ij}^\\top - \\frac{1}{3}\\mathbf{I}\\right) + \\mathrm{STT}\\left(\\mathbf{v}_j^{(0)}\\hat{\\mathbf{r}}_{ij}^\\top + \\hat{\\mathbf{r}}_{ij}(\\mathbf{v}_j^{(0)})^\\top\\right) \\right)$$\n其中 $\\mathrm{STT}(\\mathbf{M}) = \\frac{1}{2}(\\mathbf{M} + \\mathbf{M}^{\\top}) - \\frac{\\mathrm{tr}(\\mathbf{M})}{3}\\mathbf{I}$ 是对称无迹投影算子。\n\n**步骤 3：数值验证**\n\n为验证等变性，我们执行以下程序：\n1.  计算原始离子位置的更新后特征 $\\{s_i^{(1)}, \\mathbf{v}_i^{(1)}, \\mathbf{T}_i^{(1)}\\}_{\\text{orig}}$。\n2.  根据给定的轴和角度构造旋转矩阵 $\\mathbf{R}$。\n3.  将旋转应用于原始位置：$\\mathbf{r}_i' = \\mathbf{R}\\mathbf{r}_i$。\n4.  使用这些新位置重新计算更新后的特征 $\\{s_i^{(1)}, \\mathbf{v}_i^{(1)}, \\mathbf{T}_i^{(1)}\\}_{\\text{recomputed}}$。\n5.  另外，使用定义的变换规则变换原始结果：\n    - $s_{i, \\text{transformed}}^{(1)} = s_{i, \\text{orig}}^{(1)}$\n    - $\\mathbf{v}_{i, \\text{transformed}}^{(1)} = \\mathbf{R} \\mathbf{v}_{i, \\text{orig}}^{(1)}$\n    - $\\mathbf{T}_{i, \\text{transformed}}^{(1)} = \\mathbf{R} \\mathbf{T}_{i, \\text{orig}}^{(1)} \\mathbf{R}^{\\top}$\n6.  E(3) 等变性属性要求重新计算的特征必须等于变换后的特征，即 $\\{h\\}_{\\text{recomputed}} = \\{h\\}_{\\text{transformed}}$。由于浮点运算，我们通过计算每种特征类型在所有离子上的最大差异来检查这一点。误差计算方式为：标量使用绝对差，矢量使用差的欧几里得范数，张量使用差的弗罗贝尼乌斯范数。\n\n提供的 Python 代码实现了这整个流程。`rotation_matrix_from_axis_angle` 函数使用罗德里格斯公式生成旋转矩阵 $\\mathbf{R}$。`equivariant_pipeline` 函数封装了特征初始化和更新步骤。主函数 `solve` 遍历测试用例，执行数值验证，并按规定格式化所得的误差值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotation_matrix_from_axis_angle(axis: np.ndarray, angle: float) -> np.ndarray:\n    \"\"\"\n    Computes a 3x3 rotation matrix from a rotation axis and angle using Rodrigues' formula.\n    \"\"\"\n    axis = np.asarray(axis)\n    if np.isclose(angle, 0.0):\n        return np.eye(3)\n    \n    # Normalize the rotation axis\n    norm = np.linalg.norm(axis)\n    if np.isclose(norm, 0.0):\n        # A zero axis with non-zero angle is ill-defined; return identity.\n        return np.eye(3)\n    axis = axis / norm\n    \n    # Skew-symmetric cross-product matrix\n    K = np.array([[0, -axis[2], axis[1]],\n                  [axis[2], 0, -axis[0]],\n                  [-axis[1], axis[0], 0]])\n    \n    I = np.eye(3)\n    # Rodrigues' rotation formula\n    R = I + np.sin(angle) * K + (1 - np.cos(angle)) * (K @ K)\n    \n    return R\n\ndef stt_projection(M: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the Symmetric Traceless Tensor (STT) projection of a 3x3 matrix.\n    STT(M) = 1/2(M + M^T) - tr(M)/3 * I\n    \"\"\"\n    return 0.5 * (M + M.T) - (np.trace(M) / 3.0) * np.eye(3)\n\ndef equivariant_pipeline(positions: np.ndarray, charges: np.ndarray, cutoff: float) -> tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Executes one layer of the E(3)-equivariant message passing architecture.\n    \"\"\"\n    num_atoms = positions.shape[0]\n    I = np.eye(3)\n    epsilon = 1e-9 # For numerical stability when normalizing vectors\n\n    # Step 1: Find neighbors for each atom\n    adj = []\n    for i in range(num_atoms):\n        neighbors = []\n        for j in range(num_atoms):\n            if i == j:\n                continue\n            dist = np.linalg.norm(positions[i] - positions[j])\n            if dist  cutoff:\n                neighbors.append(j)\n        adj.append(neighbors)\n\n    # Step 2: Initialize features (h_0)\n    s_0 = np.zeros(num_atoms)\n    v_0 = np.zeros((num_atoms, 3))\n    T_0 = np.zeros((num_atoms, 3, 3))\n\n    for i in range(num_atoms):\n        if not adj[i]: continue\n        for j in adj[i]:\n            r_ij = positions[j] - positions[i]\n            dist_ij = np.linalg.norm(r_ij)\n            hat_r_ij = r_ij / (dist_ij + epsilon)\n            \n            s_0[i] += charges[j]\n            v_0[i] += charges[j] * hat_r_ij\n            outer_prod = np.outer(hat_r_ij, hat_r_ij)\n            T_0[i] += charges[j] * (outer_prod - (1.0 / 3.0) * I)\n\n    # Step 3: Update features (h_1) by message passing\n    s_1 = np.zeros(num_atoms)\n    v_1 = np.zeros((num_atoms, 3))\n    T_1 = np.zeros((num_atoms, 3, 3))\n\n    for i in range(num_atoms):\n        if not adj[i]: continue\n        for j in adj[i]:\n            r_ij = positions[j] - positions[i]\n            dist_ij = np.linalg.norm(r_ij)\n            hat_r_ij = r_ij / (dist_ij + epsilon)\n\n            # Scalar update\n            s_1[i] += s_0[j] + np.dot(v_0[j], hat_r_ij)\n\n            # Vector update\n            v_1[i] += s_0[j] * hat_r_ij + v_0[j] + T_0[j] @ hat_r_ij\n\n            # Tensor update\n            term1_T = s_0[j] * (np.outer(hat_r_ij, hat_r_ij) - (1.0 / 3.0) * I)\n            \n            v_outer_r = np.outer(v_0[j], hat_r_ij)\n            M_vj_rij = v_outer_r + v_outer_r.T\n            term2_T = stt_projection(M_vj_rij) # Simplified from STT(v_j*r_ij_T + r_ij*v_j_T)\n            \n            T_1[i] += term1_T + term2_T\n\n    return s_1, v_1, T_1\n\ndef format_nested_list(data: list) - str:\n    \"\"\"\n    Recursively formats a nested list into a string without spaces after commas.\n    \"\"\"\n    if isinstance(data, list):\n        return f\"[{','.join(format_nested_list(item) for item in data)}]\"\n    else:\n        return f\"{item:.15e}\" if isinstance(item, float) else str(item)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify equivariance.\n    \"\"\"\n    test_cases = [\n        {\n            \"positions\": [[0.0, 0.0, 0.0], [0.4, 0.1, -0.2], [-0.3, 0.5, 0.2], [0.2, -0.4, 0.3], [-0.5, -0.1, -0.4], [0.1, 0.6, -0.3]],\n            \"charges\": [1.0, -1.0, 1.0, -1.0, 1.0, -1.0],\n            \"cutoff\": 0.8,\n            \"rot_axis\": [0.3, 0.7, 0.6],\n            \"rot_angle\": 0.6\n        },\n        {\n            \"positions\": [[-0.5, 0.0, 0.0], [0.0, 0.0, 0.0], [0.5, 0.0, 0.0]],\n            \"charges\": [1.0, -1.0, 1.0],\n            \"cutoff\": 1.0,\n            \"rot_axis\": [0.0, 0.0, 1.0],\n            \"rot_angle\": np.pi / 3\n        },\n        {\n            \"positions\": [[0.0, 0.0, 0.0], [0.4, 0.1, -0.2], [-0.3, 0.5, 0.2], [0.2, -0.4, 0.3], [-0.5, -0.1, -0.4], [0.1, 0.6, -0.3]],\n            \"charges\": [1.0, -1.0, 1.0, -1.0, 1.0, -1.0],\n            \"cutoff\": 0.05,\n            \"rot_axis\": [0.2, -0.4, 0.9],\n            \"rot_angle\": 1.2\n        },\n        {\n            \"positions\": [[0.2, 0.2, 0.2], [-0.2, -0.2, -0.2], [0.3, -0.1, 0.4]],\n            \"charges\": [1.0, -1.0, 1.0],\n            \"cutoff\": 0.5,\n            \"rot_axis\": [1.0, 0.0, 0.0],\n            \"rot_angle\": 0.0\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        positions_orig = np.array(case[\"positions\"], dtype=float)\n        charges = np.array(case[\"charges\"], dtype=float)\n        cutoff = float(case[\"cutoff\"])\n        rot_axis = np.array(case[\"rot_axis\"], dtype=float)\n        rot_angle = float(case[\"rot_angle\"])\n\n        # 1. Compute updated features for the original configuration\n        s_orig, v_orig, T_orig = equivariant_pipeline(positions_orig, charges, cutoff)\n\n        # 2. Build rotation matrix and rotate positions\n        R = rotation_matrix_from_axis_angle(rot_axis, rot_angle)\n        positions_rot = (R @ positions_orig.T).T\n\n        # 3. Compute updated features for the rotated configuration\n        s_recomputed, v_recomputed, T_recomputed = equivariant_pipeline(positions_rot, charges, cutoff)\n\n        # 4. Transform the original results using the rotation matrix\n        s_transformed = s_orig\n        v_transformed = (R @ v_orig.T).T\n        T_transformed = np.zeros_like(T_orig)\n        for i in range(T_orig.shape[0]):\n            T_transformed[i] = R @ T_orig[i] @ R.T\n\n        # 5. Calculate maximum discrepancy (error)\n        num_atoms = positions_orig.shape[0]\n        if num_atoms == 0:\n            scalar_error, vector_error, tensor_error = 0.0, 0.0, 0.0\n        else:\n            scalar_error = np.max(np.abs(s_recomputed - s_transformed)) if s_orig.size > 0 else 0.0\n            vector_error = np.max(np.linalg.norm(v_recomputed - v_transformed, axis=1)) if v_orig.size > 0 else 0.0\n            tensor_error = np.max(np.linalg.norm(T_recomputed - T_transformed, axis=(1, 2))) if T_orig.size > 0 else 0.0\n\n        all_results.append([scalar_error, vector_error, tensor_error])\n    \n    # Custom formatter to match the output format specification precisely\n    def format_results(results_list):\n        outer_parts = []\n        for inner_list in results_list:\n            inner_parts = [f\"{x:.6e}\" for x in inner_list]\n            outer_parts.append(f\"[{','.join(inner_parts)}]\")\n        return f\"[{','.join(outer_parts)}]\"\n\n    print(format_results(all_results))\n\nsolve()\n```"
        },
        {
            "introduction": "除了几何对称性，力场还必须遵守能量守恒定律，这意味着力必须可以从一个标量势中导出。本实践探讨了一种强制实现这一性质的强大技术：在训练损失函数中加入一个惩罚旋度的正则化项。你将分析训练动态，观察这种基于物理原理的正则化如何系统地消除学习到的力场中的非保守分量，从而确保一个明确定义的势能面。",
            "id": "4250465",
            "problem": "考虑一个用于平衡态电化学系统的二维力场模型，该模型在机器学习原子间势（MLIP）中使用，其中预测的力与坐标呈线性关系。设该模型由矩阵参数 $\\mathbf{W} \\in \\mathbb{R}^{2 \\times 2}$ 定义，对于 $\\mathbf{x} \\in \\mathbb{R}^2$，预测的力为 $\\hat{\\mathbf{F}}(\\mathbf{x}) = \\mathbf{W}\\mathbf{x}$。假设基准真相力是保守的，源于一个二阶可微的标量势 $U(\\mathbf{x})$，因此 $\\mathbf{F}(\\mathbf{x}) = -\\nabla U(\\mathbf{x})$。在此设定下，保守场意味着在单连通域上的旋度为零。\n\n训练目标函数结合了力匹配项和旋度惩罚正则化项。设在独立同分布样本 $\\{\\mathbf{x}_n, \\mathbf{F}_n\\}_{n=1}^N$ 上的力匹配损失为\n$$\n\\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) = \\frac{1}{N}\\sum_{n=1}^{N} \\left\\| \\mathbf{W}\\mathbf{x}_n - \\mathbf{F}_n \\right\\|_2^2.\n$$\n设旋度惩罚为二维中标量旋度的均方值。对于线性模型，标量旋度在空间上是恒定的，等于\n$$\n\\omega = \\frac{\\partial \\hat{F}_y}{\\partial x} - \\frac{\\partial \\hat{F}_x}{\\partial y} = W_{21} - W_{12}.\n$$\n将正则化项定义为\n$$\n\\mathcal{R}_{\\mathrm{curl}}(\\mathbf{W}) = \\omega^2 = \\left(W_{21} - W_{12}\\right)^2.\n$$\n总损失为\n$$\n\\mathcal{L}(\\mathbf{W}) = \\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) + \\lambda \\,\\mathcal{R}_{\\mathrm{curl}}(\\mathbf{W}),\n$$\n其中正则化权重 $\\lambda \\ge 0$。\n\n你需要从第一性原理出发，证明旋度惩罚如何强制保守性，并计算在学习率为 $\\eta  0$ 的梯度下降法下，它对训练动态的影响。假设：\n- 输入的样本协方差是各向同性的，即 $\\boldsymbol{\\Sigma} = \\mathbb{E}[\\mathbf{x}\\mathbf{x}^\\top] = \\sigma^2 \\mathbf{I}_2$，其中 $\\sigma^2  0$。\n- 基准真相力是保守的，对应一个对称矩阵 $\\mathbf{W}_{\\star}$，即 $\\mathbf{F}(\\mathbf{x}) = \\mathbf{W}_{\\star}\\mathbf{x}$ 且 $\\mathbf{W}_{\\star}^\\top = \\mathbf{W}_{\\star}$。\n\n引入 $\\mathbf{W}$ 的对称和反对称分量：\n$$\n\\mathbf{C} = \\frac{1}{2}\\left(\\mathbf{W} + \\mathbf{W}^\\top\\right), \\quad \\mathbf{S} = \\frac{1}{2}\\left(\\mathbf{W} - \\mathbf{W}^\\top\\right).\n$$\n注意，旋度仅依赖于 $\\mathbf{S}$。推导单次训练步骤下 $\\mathbf{S}$ 的梯度下降更新，并证明在各向同性协方差假设下，反对称部分被乘以一个标量收缩因子\n$$\n\\phi_{\\lambda} = 1 - 2\\eta\\left(\\sigma^2 + 2\\lambda\\right)\n$$\n每个步骤，而没有正则化项时，它被乘以\n$$\n\\phi_{0} = 1 - 2\\eta \\sigma^2.\n$$\n设 $a_0$ 表示反对称分量的初始振幅（例如，在基 $\\{\\mathbf{e}_1,\\mathbf{e}_2\\}$ 中的非对角元素 $S_{12}$）。经过 $K$ 步后，振幅按 $|a_K| = |a_0|\\,|\\phi|^K$ 缩放。\n\n你的任务是实现一个程序，给定一个由参数集 $(\\eta, \\sigma^2, \\lambda, a_0, K)$ 组成的小型测试套件，为每个测试用例计算比率\n$$\nr = \\frac{|\\phi_{\\lambda}|^K}{|\\phi_0|^K},\n$$\n该比率量化了有旋度惩罚与没有旋度惩罚时反对称分量的相对衰减（或增长）。该比率是无单位的。\n\n使用以下测试套件，其设计旨在覆盖一般情况、边界情况、因固定学习率导致收缩变慢的边缘情况以及临界阻尼情况：\n- 测试 1：$(\\eta, \\sigma^2, \\lambda, a_0, K) = (0.05, 1.0, 0.5, 1.0, 10)$。\n- 测试 2：$(\\eta, \\sigma^2, \\lambda, a_0, K) = (0.05, 1.0, 0.0, 1.0, 10)$。\n- 测试 3：$(\\eta, \\sigma^2, \\lambda, a_0, K) = (0.45, 1.0, 0.2, 1.0, 10)$。\n- 测试 4：$(\\eta, \\sigma^2, \\lambda, a_0, K) = (0.4, 0.5, 0.375, 1.0, 1)$。\n\n你的程序必须：\n- 完全按照上述定义为每个测试用例计算 $r$。\n- 生成单行输出，其中包含按测试顺序排列的结果，格式为方括号内用逗号分隔的列表，无空格，例如 $[r_1,r_2,r_3,r_4]$。",
            "solution": "问题陈述经评估有效。它在科学上基于计算物理和机器学习的原理，问题设定良好，目标明确，且内部一致。\n\n任务是推导线性力场模型中权重矩阵 $\\mathbf{W}$ 的反对称分量的梯度下降动态，然后计算一个量化基于旋度的正则化项效果的比率。\n\n首先，我们建立理论框架。总损失函数由下式给出：\n$$\n\\mathcal{L}(\\mathbf{W}) = \\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) + \\lambda \\,\\mathcal{R}_{\\mathrm{curl}}(\\mathbf{W})\n$$\n其中 $\\mathcal{L}_{\\mathrm{FM}}$ 是力匹配损失，$\\mathcal{R}_{\\mathrm{curl}}$ 是旋度正则化项。在大样本极限 ($N \\to \\infty$) 下，我们可以将 $\\mathcal{L}_{\\mathrm{FM}}$ 中的求和替换为对数据分布的期望：\n$$\n\\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) = \\mathbb{E}_{\\mathbf{x}} \\left[ \\left\\| \\mathbf{W}\\mathbf{x} - \\mathbf{F}(\\mathbf{x}) \\right\\|_2^2 \\right]\n$$\n鉴于基准真相力为 $\\mathbf{F}(\\mathbf{x}) = \\mathbf{W}_{\\star}\\mathbf{x}$，上式变为：\n$$\n\\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) = \\mathbb{E}_{\\mathbf{x}} \\left[ \\left\\| (\\mathbf{W} - \\mathbf{W}_{\\star})\\mathbf{x} \\right\\|_2^2 \\right]\n$$\n设 $\\Delta\\mathbf{W} = \\mathbf{W} - \\mathbf{W}_{\\star}$。期望可以写为：\n$$\n\\mathbb{E}_{\\mathbf{x}} \\left[ \\mathbf{x}^\\top (\\Delta\\mathbf{W})^\\top (\\Delta\\mathbf{W}) \\mathbf{x} \\right]\n$$\n使用性质 $\\mathbb{E}[\\mathbf{z}^\\top \\mathbf{A} \\mathbf{z}] = \\text{Tr}(\\mathbf{A} \\mathbb{E}[\\mathbf{z}\\mathbf{z}^\\top])$，我们有：\n$$\n\\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) = \\text{Tr}\\left( (\\Delta\\mathbf{W})^\\top (\\Delta\\mathbf{W}) \\mathbb{E}[\\mathbf{x}\\mathbf{x}^\\top] \\right)\n$$\n使用各向同性输入协方差的假设，$\\mathbb{E}[\\mathbf{x}\\mathbf{x}^\\top] = \\sigma^2 \\mathbf{I}_2$：\n$$\n\\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) = \\text{Tr}\\left( (\\Delta\\mathbf{W})^\\top (\\Delta\\mathbf{W}) \\sigma^2 \\mathbf{I}_2 \\right) = \\sigma^2 \\text{Tr}\\left( (\\Delta\\mathbf{W})^\\top \\Delta\\mathbf{W} \\right) = \\sigma^2 \\|\\mathbf{W} - \\mathbf{W}_{\\star}\\|_F^2\n$$\n其中 $\\|\\cdot\\|_F$ 表示 Frobenius 范数。\n\n接下来，我们将权重矩阵 $\\mathbf{W}$ 和误差 $\\Delta\\mathbf{W}$ 分解为对称和反对称分量。设 $\\mathbf{W} = \\mathbf{C} + \\mathbf{S}$ 和 $\\mathbf{W}_{\\star} = \\mathbf{C}_{\\star}$，其中 $\\mathbf{C} = \\frac{1}{2}(\\mathbf{W} + \\mathbf{W}^\\top)$ 和 $\\mathbf{C}_{\\star} = \\mathbf{W}_{\\star}$ 是对称的，而 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{W} - \\mathbf{W}^\\top)$ 是反对称的。真实的权重矩阵 $\\mathbf{W}_{\\star}$ 是对称的，因此其反对称部分为零。误差为 $\\Delta\\mathbf{W} = (\\mathbf{C} - \\mathbf{C}_{\\star}) + \\mathbf{S}$。\n一个矩阵的 Frobenius 范数是其元素平方和的平方根。对于一个对称矩阵和一个反对称矩阵之和的矩阵，其 Frobenius 范数的平方由于正交性而解耦：\n$$\n\\|\\Delta\\mathbf{W}\\|_F^2 = \\|\\mathbf{C} - \\mathbf{C}_{\\star}\\|_F^2 + \\|\\mathbf{S}\\|_F^2\n$$\n因此，力匹配损失为：\n$$\n\\mathcal{L}_{\\mathrm{FM}}(\\mathbf{W}) = \\sigma^2 \\left( \\|\\mathbf{C} - \\mathbf{C}_{\\star}\\|_F^2 + \\|\\mathbf{S}\\|_F^2 \\right)\n$$\n旋度正则化项为 $\\mathcal{R}_{\\mathrm{curl}}(\\mathbf{W}) = (W_{21} - W_{12})^2$。反对称部分 $\\mathbf{S}$ 的分量为 $S_{11}=S_{22}=0$, $S_{21} = \\frac{1}{2}(W_{21}-W_{12})$, 以及 $S_{12} = \\frac{1}{2}(W_{12}-W_{21}) = -S_{21}$。\n正则化项可以用 $\\mathbf{S}$ 的分量表示：\n$$\n\\mathcal{R}_{\\mathrm{curl}}(\\mathbf{W}) = (2 S_{21})^2 = 4S_{21}^2 = 2 (S_{21}^2 + S_{12}^2) = 2 \\|\\mathbf{S}\\|_F^2\n$$\n因此，总损失函数在对称和反对称分量上是解耦的：\n$$\n\\mathcal{L}(\\mathbf{W}) = \\sigma^2 \\|\\mathbf{C} - \\mathbf{C}_{\\star}\\|_F^2 + \\sigma^2 \\|\\mathbf{S}\\|_F^2 + \\lambda (2 \\|\\mathbf{S}\\|_F^2)\n$$\n$$\n\\mathcal{L}(\\mathbf{W}) = \\sigma^2 \\|\\mathbf{C} - \\mathbf{C}_{\\star}\\|_F^2 + (\\sigma^2 + 2\\lambda) \\|\\mathbf{S}\\|_F^2\n$$\n梯度下降更新需要损失函数关于矩阵 $\\mathbf{W}$ 的梯度。一般的求导法则是 $\\nabla_{\\mathbf{X}} \\|\\mathbf{X}-\\mathbf{A}\\|_F^2 = 2(\\mathbf{X}-\\mathbf{A})$ 和 $\\nabla_{\\mathbf{X}} \\|\\mathbf{S}_{\\mathbf{X}}\\|_F^2 = 2\\mathbf{S}_{\\mathbf{X}}$，其中 $\\mathbf{S}_{\\mathbf{X}}$ 是 $\\mathbf{X}$ 的反对称部分。应用这些法则：\n$$\n\\nabla_{\\mathbf{W}} \\mathcal{L}(\\mathbf{W}) = \\nabla_{\\mathbf{W}} \\left( \\sigma^2 \\|\\mathbf{W} - \\mathbf{W}_{\\star}\\|_F^2 \\right) + \\nabla_{\\mathbf{W}} \\left( 2\\lambda \\|\\mathbf{S}\\|_F^2 \\right)\n$$\n第一项得到 $2\\sigma^2(\\mathbf{W} - \\mathbf{W}_{\\star})$。正则化项的梯度是 $\\nabla_{\\mathbf{W}}(2\\lambda \\|\\mathbf{S}\\|_F^2) = 4\\lambda \\mathbf{S}$。将它们结合起来：\n$$\n\\nabla_{\\mathbf{W}} \\mathcal{L}(\\mathbf{W}) = 2\\sigma^2 (\\mathbf{W} - \\mathbf{W}_{\\star}) + 4\\lambda \\mathbf{S}\n$$\n代入 $\\mathbf{W} = \\mathbf{C} + \\mathbf{S}$ 和 $\\mathbf{W}_{\\star} = \\mathbf{C}_{\\star}$：\n$$\n\\nabla_{\\mathbf{W}} \\mathcal{L}(\\mathbf{W}) = 2\\sigma^2 ((\\mathbf{C} - \\mathbf{C}_{\\star}) + \\mathbf{S}) + 4\\lambda \\mathbf{S} = 2\\sigma^2 (\\mathbf{C} - \\mathbf{C}_{\\star}) + (2\\sigma^2 + 4\\lambda) \\mathbf{S}\n$$\n在第 $k$ 步，$\\mathbf{W}$ 的梯度下降更新规则是 $\\mathbf{W}_{k+1} = \\mathbf{W}_k - \\eta \\nabla_{\\mathbf{W}} \\mathcal{L}(\\mathbf{W}_k)$。反对称分量 $\\mathbf{S}$ 的更新是 $\\mathbf{W}$ 更新的反对称部分：\n$$\n\\mathbf{S}_{k+1} = \\text{antisymm}(\\mathbf{W}_{k+1}) = \\mathbf{S}_k - \\eta \\, \\text{antisymm}\\left( \\nabla_{\\mathbf{W}} \\mathcal{L}(\\mathbf{W}_k) \\right)\n$$\n梯度的对称部分是 $2\\sigma^2 (\\mathbf{C}_k - \\mathbf{C}_{\\star})$，其反对称部分是 $(2\\sigma^2 + 4\\lambda) \\mathbf{S}_k$。因此，$\\mathbf{S}$ 的更新是：\n$$\n\\mathbf{S}_{k+1} = \\mathbf{S}_k - \\eta (2\\sigma^2 + 4\\lambda) \\mathbf{S}_k = (1 - 2\\eta(\\sigma^2 + 2\\lambda)) \\mathbf{S}_k\n$$\n这表明反对称分量 $\\mathbf{S}$ 在每一步都被乘以一个标量收缩因子 $\\phi_{\\lambda} = 1 - 2\\eta(\\sigma^2 + 2\\lambda)$。在没有正则化项 ($\\lambda=0$) 的情况下，该因子为 $\\phi_0 = 1 - 2\\eta\\sigma^2$。只要学习率 $\\eta$ 选择得当以确保 $|\\phi_{\\lambda}|  1$，正则化项就会加快非保守分量 $\\mathbf{S}$ 向零衰减的速率。\n\n量化 $K$ 步后相对衰减的比率 $r$ 是：\n$$\nr = \\frac{|\\phi_{\\lambda}|^K}{|\\phi_0|^K} = \\left( \\frac{|\\phi_{\\lambda}|}{|\\phi_0|} \\right)^K\n$$\n为提供的测试用例计算此比率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative decay ratio of the antisymmetric component of a \n    weight matrix in a linear MLIP model, with and without a curl penalty.\n    \"\"\"\n    \n    # Test suite of parameters: (eta, sigma^2, lambda, a_0, K)\n    # a_0 is not needed for the calculation of the ratio r.\n    test_cases = [\n        # Test 1: General case\n        (0.05, 1.0, 0.5, 1.0, 10),\n        # Test 2: Boundary case (lambda = 0)\n        (0.05, 1.0, 0.0, 1.0, 10),\n        # Test 3: Edge case (slower contraction)\n        (0.45, 1.0, 0.2, 1.0, 10),\n        # Test 4: Critically damped case\n        (0.4, 0.5, 0.375, 1.0, 1),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        eta, sigma_sq, lam, a0, K = case\n        \n        # Contraction factor with the curl regularizer\n        # phi_lambda = 1 - 2*eta*(sigma^2 + 2*lambda)\n        phi_lambda = 1 - 2 * eta * (sigma_sq + 2 * lam)\n        \n        # Contraction factor without the regularizer (lambda = 0)\n        # phi_0 = 1 - 2*eta*sigma^2\n        phi_0 = 1 - 2 * eta * sigma_sq\n        \n        # The ratio r quantifies the relative decay (or growth) of the \n        # antisymmetric component after K steps.\n        # r = (|phi_lambda|^K) / (|phi_0|^K)\n        # Handle the case where phi_0 is zero to avoid division by zero.\n        # This case is not present in the test suite but is good practice.\n        if abs(phi_0) == 0:\n            # If phi_0 is 0, the unregularized component vanishes in one step.\n            # If phi_lambda is also 0, the ratio is indeterminate, but 1.0 is a\n            # reasonable interpretation (both vanish instantly).\n            # If phi_lambda is not 0, the regularized component does not vanish,\n            # so the relative decay is infinite. For the scope of this problem,\n            # we assume phi_0 is non-zero.\n            if abs(phi_lambda) == 0:\n                r = 1.0\n            else:\n                r = float('inf')\n        else:\n            r = (abs(phi_lambda)**K) / (abs(phi_0)**K)\n            \n        results.append(r)\n\n    # Format the final output as a comma-separated list in brackets,\n    # with no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "计算电化学中的一个关键挑战是精确模拟能量如何随电极电势变化。这最后一个练习将检验你的知识，让你评估和比较不同模型在处理电势依赖的吸附能时的表现。通过对纯机器学习势和更复杂的QM/ML混合模型进行误差分析，你将学会如何定量评估模型捕捉电化学界面上关键静电效应（如电荷转移和极化）的能力。",
            "id": "4250456",
            "problem": "考虑一个在恒定电极电势下建模的、与电化学界面相互作用的吸附质。吸附能由基本热力学差值定义为$$E_{\\mathrm{ads}}(U) = E_{\\mathrm{tot}}^{\\mathrm{slab+ads}}(U) - E_{\\mathrm{tot}}^{\\mathrm{slab}}(U) - \\mu_{\\mathrm{adsorbate}}(U),$$ 其中 $U$ 是电极电势，$E_{\\mathrm{tot}}^{\\mathrm{slab+ads}}(U)$ 是带有吸附质的平板的总能量，$E_{\\mathrm{tot}}^{\\mathrm{slab}}(U)$ 是洁净平板的总能量，$\\mu_{\\mathrm{adsorbate}}(U)$ 是吸附质的化学势，所有能量单位均为电子伏特 (eV)。在恒定电势条件下，界面能对电场的响应在主导阶上可以由一个线性项和一个二次极化项表示，从而给出一个参考吸附能模型$$E_{\\mathrm{ref}}(U) = E_0 + \\alpha U + \\gamma U^2,$$ 其中 $E_0$ 是在 $U=0$ 时的基准吸附能 (单位 eV)，$\\alpha$ (单位 eV/V) 集合了与电荷转移和偶极矩变化相关的有效线性耦合，而 $\\gamma$ (单位 eV/V$^2$) 代表了来自界面环境的电容性或非线性极化贡献。\n\n一个忽略显式静电耦合的纯机器学习 (ML) 界面势预测$$E_{\\mathrm{ML}}(U) = E_0 + b_{\\mathrm{ML}},$$ 其中 $b_{\\mathrm{ML}}$ 是一个系统性偏差 (单位 eV)。一个量子力学/机器学习 (QM/ML) 嵌入模型，此处定义为量子力学/机器学习 (QM/ML) 嵌入，它将化学活性位点的量子力学区域与机器学习环境相结合，并捕捉了一部分的静电响应，$$E_{\\mathrm{QM/ML}}(U) = E_0 + b_{\\mathrm{QM/ML}} + s\\,\\alpha\\,U + t\\,\\gamma\\,U^2,$$ 其中 $b_{\\mathrm{QM/ML}}$ 是一个较小的系统性偏差 (单位 eV)，$s \\in [0,1]$ 是恢复的线性响应的比例，而 $t \\in [0,1]$ 是恢复的二次极化的比例。\n\n对于一组电极电势 $\\{U_i\\}_{i=1}^N$，定义预测误差为$$\\varepsilon_{\\mathrm{ML},i} = E_{\\mathrm{ML}}(U_i) - E_{\\mathrm{ref}}(U_i), \\quad \\varepsilon_{\\mathrm{QM/ML},i} = E_{\\mathrm{QM/ML}}(U_i) - E_{\\mathrm{ref}}(U_i).$$ 一个模型的偏差 (平均误差) 为$$\\mathrm{Bias} = \\frac{1}{N}\\sum_{i=1}^N \\varepsilon_i,$$ 均方根误差 (RMSE) 为$$\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\varepsilon_i^2},$$ 以及误差相对于电势的最小二乘斜率，该斜率量化了与电势相关的系统性差异，其表达式为$$m = \\frac{\\sum_{i=1}^N \\left(U_i - \\bar{U}\\right)\\left(\\varepsilon_i - \\bar{\\varepsilon}\\right)}{\\sum_{i=1}^N \\left(U_i - \\bar{U}\\right)^2},$$ 其中 $\\bar{U} = \\frac{1}{N}\\sum_{i=1}^N U_i$ 且 $\\bar{\\varepsilon} = \\frac{1}{N}\\sum_{i=1}^N \\varepsilon_i$。斜率 $m$ 的单位是 eV/V。\n\n请实现一个程序，对于下述的每个测试用例，在指定的电势网格上构建 $E_{\\mathrm{ref}}(U)$、$E_{\\mathrm{ML}}(U)$ 和 $E_{\\mathrm{QM/ML}}(U)$，计算 ML 和 QM/ML 模型的误差指标 $\\mathrm{RMSE}$、$\\mathrm{Bias}$ 和 $m$，并输出结果。\n\n所有能量单位必须是 eV，电势 $U$ 的单位是伏特 (V)，斜率的单位是 eV/V。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，该列表由按顺序连接每个测试用例的以下序列构成$$[\\mathrm{RMSE}_{\\mathrm{ML}}, \\mathrm{RMSE}_{\\mathrm{QM/ML}}, \\mathrm{Bias}_{\\mathrm{ML}}, \\mathrm{Bias}_{\\mathrm{QM/ML}}, m_{\\mathrm{ML}}, m_{\\mathrm{QM/ML}}],$$ 其中每个浮点数四舍五入到 $6$ 位小数。\n\n使用以下测试套件：\n\n- 测试用例 $1$ (具有中等线性和二次响应的一般情况)：$E_0 = -0.60$ eV, $\\alpha = 0.30$ eV/V, $\\gamma = 0.10$ eV/V$^2$, $b_{\\mathrm{ML}} = 0.04$ eV, $b_{\\mathrm{QM/ML}} = 0.01$ eV, $s = 0.80$, $t = 0.50$, 电势 $U \\in \\{-0.40, -0.20, 0.00, 0.20, 0.40\\}$ V。\n- 测试用例 $2$ (在零电荷电势附近，线性响应可忽略)：$E_0 = -0.30$ eV, $\\alpha = 0.00$ eV/V, $\\gamma = 0.02$ eV/V$^2$, $b_{\\mathrm{ML}} = 0.03$ eV, $b_{\\mathrm{QM/ML}} = 0.015$ eV, $s = 0.80$, $t = 0.50$, 电势 $U \\in \\{-0.20, 0.00, 0.20\\}$ V。\n- 测试用例 $3$ (具有强线性和二次响应的高场情况)：$E_0 = -0.85$ eV, $\\alpha = 0.50$ eV/V, $\\gamma = 0.20$ eV/V$^2$, $b_{\\mathrm{ML}} = 0.05$ eV, $b_{\\mathrm{QM/ML}} = 0.02$ eV, $s = 0.70$, $t = 0.30$, 电势 $U \\in \\{-0.60, -0.30, 0.00, 0.30, 0.60\\}$ V。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,\\dots,x_M]$）的结果，该列表是按上文指定的确切顺序连接所有测试用例的结果而成的。每个数值必须四舍五入到 $6$ 位小数。",
            "solution": "该问题要求针对一个已定义的参考模型，计算两种不同的电化学界面吸附能计算模型——纯机器学习 (ML) 模型和混合量子力学/机器学习 (QM/ML) 模型——的若干误差指标。解决方案涉及对给定的一组参数和电极电势，系统地、逐步地应用所提供的数学公式。\n\n首先，我们为每个模型在特定电势 $U_i$ 下建立预测误差 $\\varepsilon_i$ 的解析表达式。误差定义为模型预测值与参考能量 $E_{\\mathrm{ref}}(U_i)$ 之间的差值。\n\n吸附能的参考模型由电极电势 $U$ 的二次函数给出：\n$$E_{\\mathrm{ref}}(U) = E_0 + \\alpha U + \\gamma U^2$$\n其中 $E_0$ 是零电势下的能量，$\\alpha$ 是线性耦合系数，$\\gamma$ 是二次极化系数。\n\n纯 ML 模型提供了一个与电势无关的预测：\n$$E_{\\mathrm{ML}}(U) = E_0 + b_{\\mathrm{ML}}$$\n其中 $b_{\\mathrm{ML}}$ 是一个系统性偏差。因此，ML 模型在电势 $U_i$ 下的预测误差 $\\varepsilon_{\\mathrm{ML},i}$ 为：\n$$\\varepsilon_{\\mathrm{ML},i} = E_{\\mathrm{ML}}(U_i) - E_{\\mathrm{ref}}(U_i) = (E_0 + b_{\\mathrm{ML}}) - (E_0 + \\alpha U_i + \\gamma U_i^2)$$\n简化此表达式，我们发现基准能量 $E_0$ 被消掉了：\n$$\\varepsilon_{\\mathrm{ML},i} = b_{\\mathrm{ML}} - \\alpha U_i - \\gamma U_i^2$$\n\nQM/ML 嵌入模型包含了对静电响应的部分描述：\n$$E_{\\mathrm{QM/ML}}(U) = E_0 + b_{\\mathrm{QM/ML}} + s\\,\\alpha\\,U + t\\,\\gamma\\,U^2$$\n其中 $b_{\\mathrm{QM/ML}}$ 是 QM/ML 的偏差，$s$ 和 $t$ 分别是恢复的线性响应和二次响应的比例。QM/ML 模型的预测误差 $\\varepsilon_{\\mathrm{QM/ML},i}$ 为：\n$$\\varepsilon_{\\mathrm{QM/ML},i} = E_{\\mathrm{QM/ML}}(U_i) - E_{\\mathrm{ref}}(U_i) = (E_0 + b_{\\mathrm{QM/ML}} + s\\alpha U_i + t\\gamma U_i^2) - (E_0 + \\alpha U_i + \\gamma U_i^2)$$\n$E_0$ 再次被消掉。通过组合各项，我们得到：\n$$\\varepsilon_{\\mathrm{QM/ML},i} = b_{\\mathrm{QM/ML}} - (1-s)\\alpha U_i - (1-t)\\gamma U_i^2$$\n\n有了在每个电势 $U_i$ 下误差的这些解析形式，我们就可以继续计算所需的统计指标：偏差 (Bias)、均方根误差 (RMSE) 和误差相对于电势的斜率 ($m$)。对于每个测试用例，我们都有一组包含 $N$ 个离散电势的集合 $\\{U_i\\}_{i=1}^N$。我们首先计算相应的误差向量 $\\boldsymbol{\\varepsilon}_{\\mathrm{ML}} = \\{\\varepsilon_{\\mathrm{ML},i}\\}_{i=1}^N$ 和 $\\boldsymbol{\\varepsilon}_{\\mathrm{QM/ML}} = \\{\\varepsilon_{\\mathrm{QM/ML},i}\\}_{i=1}^N$。\n\n然后按如下方式计算这些指标：\n1.  **偏差 (Bias)**：这是平均误差 $\\bar{\\varepsilon}$。对于一个通用的误差向量 $\\boldsymbol{\\varepsilon}$，它的计算公式为：\n    $$\\mathrm{Bias} = \\bar{\\varepsilon} = \\frac{1}{N}\\sum_{i=1}^N \\varepsilon_i$$\n\n2.  **均方根误差 (RMSE)**：该指标量化了误差的大小。它是误差平方的平均值的平方根：\n    $$\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\varepsilon_i^2}$$\n\n3.  **误差与电势的斜率 ($m$)**：该指标衡量误差中与电势相关的系统性趋势。它被计算为 $\\varepsilon_i$ 对 $U_i$ 作图的最佳拟合线的斜率：\n    $$m = \\frac{\\sum_{i=1}^N \\left(U_i - \\bar{U}\\right)\\left(\\varepsilon_i - \\bar{\\varepsilon}\\right)}{\\sum_{i=1}^N \\left(U_i - \\bar{U}\\right)^2}$$\n    其中 $\\bar{U}$ 是电势的平均值，$\\bar{U} = \\frac{1}{N}\\sum_{i=1}^N U_i$，而 $\\bar{\\varepsilon}$ 是误差的平均值（即偏差）。这个计算等价于求 $U$ 和 $\\varepsilon$ 的协方差除以 $U$ 的方差。\n\n每个测试用例的算法流程如下：\n1.  将电势集合 $\\{U_i\\}$ 定义为一个数值数组。\n2.  使用测试用例的参数（$\\alpha, \\gamma, b_{\\mathrm{ML}}, b_{\\mathrm{QM/ML}}, s, t$），利用推导出的简化表达式计算误差数组 $\\boldsymbol{\\varepsilon}_{\\mathrm{ML}}$ 和 $\\boldsymbol{\\varepsilon}_{\\mathrm{QM/ML}}$。\n3.  对每个模型（ML 和 QM/ML），使用其误差数组和电势数组来计算三个指标：$\\mathrm{RMSE}$、$\\mathrm{Bias}$ 和 $m$。\n4.  按照指定顺序存储六个计算值：$[\\mathrm{RMSE}_{\\mathrm{ML}}, \\mathrm{RMSE}_{\\mathrm{QM/ML}}, \\mathrm{Bias}_{\\mathrm{ML}}, \\mathrm{Bias}_{\\mathrm{QM/ML}}, m_{\\mathrm{ML}}, m_{\\mathrm{QM/ML}}]$。\n\n对所有测试用例重复此过程，并将得到的指标列表连接起来形成最终输出，每个值都格式化为六位小数。该实现使用 `numpy` 库进行高效的基于数组的计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates error metrics for ML and QM/ML models of adsorption energy\n    at an electrochemical interface for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1: general case\n        {\n            'params': {'alpha': 0.30, 'gamma': 0.10, 'b_ml': 0.04, 'b_qmml': 0.01, 's': 0.80, 't': 0.50},\n            'potentials': [-0.40, -0.20, 0.00, 0.20, 0.40]\n        },\n        # Test Case 2: near potential of zero charge\n        {\n            'params': {'alpha': 0.00, 'gamma': 0.02, 'b_ml': 0.03, 'b_qmml': 0.015, 's': 0.80, 't': 0.50},\n            'potentials': [-0.20, 0.00, 0.20]\n        },\n        # Test Case 3: high-field case\n        {\n            'params': {'alpha': 0.50, 'gamma': 0.20, 'b_ml': 0.05, 'b_qmml': 0.02, 's': 0.70, 't': 0.30},\n            'potentials': [-0.60, -0.30, 0.00, 0.30, 0.60]\n        },\n    ]\n\n    def calculate_metrics(potentials_arr, errors_arr):\n        \"\"\"\n        Computes RMSE, Bias, and slope m for a given set of errors and potentials.\n        \n        Args:\n            potentials_arr (np.ndarray): Array of electrode potentials U.\n            errors_arr (np.ndarray): Array of prediction errors.\n            \n        Returns:\n            tuple: A tuple containing (RMSE, Bias, m).\n        \"\"\"\n        # Bias (mean error)\n        bias = np.mean(errors_arr)\n        \n        # Root-Mean-Square Error\n        rmse = np.sqrt(np.mean(errors_arr**2))\n        \n        # Least-squares slope of error vs. potential\n        u_mean = np.mean(potentials_arr)\n        denominator = np.sum((potentials_arr - u_mean)**2)\n        \n        # Handle the case where all potentials are the same to avoid division by zero\n        if np.isclose(denominator, 0):\n            slope_m = 0.0\n        else:\n            # Note: err_mean is the same as bias\n            err_mean = np.mean(errors_arr)\n            numerator = np.sum((potentials_arr - u_mean) * (errors_arr - err_mean))\n            slope_m = numerator / denominator\n            \n        return rmse, bias, slope_m\n\n    all_results = []\n    for case in test_cases:\n        params = case['params']\n        U = np.array(case['potentials'])\n        \n        alpha, gamma = params['alpha'], params['gamma']\n        b_ml, b_qmml = params['b_ml'], params['b_qmml']\n        s, t = params['s'], params['t']\n\n        # Calculate error vectors for ML and QM/ML models\n        # eps_ml = b_ml - alpha*U - gamma*U^2\n        errors_ml = b_ml - alpha * U - gamma * U**2\n        \n        # eps_qmml = b_qmml - (1-s)*alpha*U - (1-t)*gamma*U^2\n        errors_qmml = b_qmml - (1 - s) * alpha * U - (1 - t) * gamma * U**2\n        \n        # Calculate metrics for the ML model\n        rmse_ml, bias_ml, m_ml = calculate_metrics(U, errors_ml)\n        \n        # Calculate metrics for the QM/ML model\n        rmse_qmml, bias_qmml, m_qmml = calculate_metrics(U, errors_qmml)\n        \n        # Extend the final list with results for the current case in the specified order\n        all_results.extend([rmse_ml, rmse_qmml, bias_ml, bias_qmml, m_ml, m_qmml])\n\n    # Format the final output string as a comma-separated list\n    # with each number rounded to 6 decimal places.\n    formatted_results = [f\"{x:.6f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}