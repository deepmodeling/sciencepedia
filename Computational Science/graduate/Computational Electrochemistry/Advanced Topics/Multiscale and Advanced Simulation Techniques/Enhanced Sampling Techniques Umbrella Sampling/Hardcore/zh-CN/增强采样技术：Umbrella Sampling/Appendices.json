{
    "hands_on_practices": [
        {
            "introduction": "在我们深入研究用于估算平均力势（PMF）的计算方法之前，通过一个解析模型来理解其物理本质是至关重要的。本练习将引导您使用经典的静电学，为一个靠近金属电极的可极化离子推导其PMF的解析表达式。通过这个过程，您将加深对构成PMF的各种物理相互作用（如电荷-电极相互作用和诱导偶极效应）的理解。",
            "id": "4244606",
            "problem": "一个电荷为 $q$、各向同性极化率为 $\\alpha$ 的离子，位于连续介质溶剂中的 $(0,0,z)$ 位置（$z>0$）。该溶剂的相对介电常数为 $\\epsilon_{r}$（因此介电常数为 $\\epsilon=\\epsilon_{0}\\epsilon_{r}$，其中 $\\epsilon_{0}$ 是真空介电常数）。一个理想导电的平面金属电极与 $z=0$ 平面重合，并保持在零电势。忽略有限离子尺寸、离子屏蔽、特异性吸附以及任何非静电相互作用。在线性响应范围内处理离子的极化率，并假设极化效应足够弱，以至于可以忽略 $\\alpha$ 的一阶以上项。\n\n使用带有导体边界条件的静电学方法，推导由于电极的存在，将离子准静态地从无穷远处移动到位置 $z$ 所需的可逆功（稳定能）。包括两个物理上不同的贡献：(i) 电荷与导体感应电场之间的相互作用，以及 (ii) 在由导体响应产生的局部电场中，与离子极化率相关的感应能。定义参考点，使得在 $z\\to\\infty$ 时稳定能为零。\n\n在计算电化学中，平均力势 (PMF) 定义为 $W(z)=-\\frac{1}{\\beta}\\ln P(z)+C$，其中 $P(z)$ 是坐标 $z$ 的无偏概率密度，$\\beta = \\frac{1}{k_{B}T}$（$k_{B}$ 为玻尔兹曼常数，$T$ 为温度），$C$ 是一个加性常数。在伞形采样中，添加谐波偏置 $V_{\\text{u}}(z)=\\frac{1}{2}k\\,(z-z_{0})^{2}$ 以增强对 $z$ 的采样，并通过适当的重加权方法恢复无偏 PMF。在所述假设下，沿 $z$ 方向的无偏 PMF 的静电贡献等于上面推导的稳定能，两者相差一个加性常数。\n\n提供 PMF 的总静电贡献 $W_{\\text{elec}}(z)$ 的闭式解析表达式，该表达式是 $z$, $q$, $\\alpha$, $\\epsilon_{0}$ 和 $\\epsilon_{r}$ 的函数。能量以焦耳为单位表示。最终答案必须是单个解析表达式。",
            "solution": "问题陈述被认为是有效的，因为它在经典静电学中有科学依据，是适定且客观的。它提出了一个可以使用已建立的物理原理解决的标准但非平凡的问题。\n\n平均力势 (PMF) 的总静电贡献，记为 $W_{\\text{elec}}(z)$，等效于将离子从无穷远处 ($z \\to \\infty$) 移动到距离电极有限距离 $z$ 处所需的可逆功。这个功是两个贡献的总和，如问题中所述：(i) 离子的电荷 $q$ 与电极的相互作用，以及 (ii) 离子的极化率 $\\alpha$ 在电极产生的电场中的感应能。参考能量在 $z \\to \\infty$ 处设为零。\n\n在导电平面附近的电介质中的电荷问题，可以使用镜像法来解决。离子电荷为 $q$，位于介电常数为 $\\epsilon = \\epsilon_{0}\\epsilon_{r}$ 的介质中的 $(0,0,z)$ 处。位于 $z=0$ 的导体保持零电势 ($V=0$)。通过在 $(0,0,-z)$ 位置放置一个镜像电荷 $q' = -q$，可以满足边界条件 $V(x,y,0)=0$。因此，$z>0$ 区域的静电场和电势是位于 $(0,0,z)$ 的真实电荷 $q$ 与位于 $(0,0,-z)$ 的镜像电荷 $q'=-q$ 所产生场的叠加。\n\n(i) 来自电荷-电极相互作用的贡献，$W_q(z)$：\n这个能量是外力所做的功，用于将电荷 $q$ 从 $z'=\\infty$ 移动到 $z'=z$，以抵抗导体对其施加的静电力。这个力等效于镜像电荷 $q'=-q$ 施加的力。位于 $z$ 的真实电荷与位于 $-z$ 的镜像电荷之间的距离是 $2z$。由镜像电荷在真实电荷位置产生的电场为：\n$$ \\vec{E}_{\\text{image}}(z) = \\frac{q'}{4\\pi\\epsilon (2z)^2} \\hat{z} = \\frac{-q}{16\\pi\\epsilon_{0}\\epsilon_{r} z^2} \\hat{z} $$\n电荷 $q$ 因该电场而受到的力为：\n$$ \\vec{F}_{q}(z) = q \\vec{E}_{\\text{image}}(z) = -\\frac{q^2}{16\\pi\\epsilon_{0}\\epsilon_{r} z^2} \\hat{z} $$\n这是一个将离子拉向电极的吸引力。准静态移动离子所需的外力为 $\\vec{F}_{\\text{ext}} = -\\vec{F}_{q}(z)$。所做的可逆功，即稳定能，是这个外力从无穷远到 $z$ 的积分：\n$$ W_q(z) = \\int_{\\infty}^{z} \\vec{F}_{\\text{ext}}(z') \\cdot d\\vec{l} = \\int_{\\infty}^{z} \\left( - \\vec{F}_{q}(z') \\right) \\cdot (\\hat{z} dz') $$\n$$ W_q(z) = \\int_{\\infty}^{z} \\frac{q^2}{16\\pi\\epsilon_{0}\\epsilon_{r} (z')^2} dz' = \\left[ -\\frac{q^2}{16\\pi\\epsilon_{0}\\epsilon_{r} z'} \\right]_{\\infty}^{z} $$\n$$ W_q(z) = -\\frac{q^2}{16\\pi\\epsilon_{0}\\epsilon_{r} z} - \\left( -\\frac{q^2}{16\\pi\\epsilon_{0}\\epsilon_{r} (\\infty)} \\right) = -\\frac{q^2}{16\\pi\\epsilon_{0}\\epsilon_{r} z} $$\n这个结果也可以等效地理解为系统的相互作用能。对于 $z>0$ 的区域，储存在电场中的总能量是真实-镜像电荷对相互作用能的一半，这也给出了相同的结果。\n\n(ii) 来自离子极化率的贡献，$W_{\\alpha}(z)$：\n离子具有各向同性极化率 $\\alpha$。在外部电场 $\\vec{E}_{\\text{loc}}$ 中，它获得一个感应偶极矩 $\\vec{p} = \\alpha \\vec{E}_{\\text{loc}}$。问题指明这是在线性响应范围内。该感应偶极子在电场中的能量由 $U_{\\text{ind}} = -\\frac{1}{2}\\alpha |\\vec{E}_{\\text{loc}}|^2$ 给出。\n离子位置处的局部电场 $\\vec{E}_{\\text{loc}}$ 是由所有其他源产生的场，在本例中即为导体上感应电荷所产生的场。根据镜像法，这恰好是前面计算过的、由镜像电荷产生的场 $\\vec{E}_{\\text{image}}(z)$。问题陈述中要求忽略 $\\alpha$ 的一阶以上项，这意味着我们不应考虑由感应偶极子自身的镜像所产生的场。因此，我们使用单极电荷 $q$ 的镜像所产生的场：\n$$ \\vec{E}_{\\text{loc}}(z) = \\vec{E}_{\\text{image}}(z) = -\\frac{q}{16\\pi\\epsilon_{0}\\epsilon_{r} z^2} \\hat{z} $$\n这个局部电场的模的平方为：\n$$ |\\vec{E}_{\\text{loc}}(z)|^2 = \\left( \\frac{q}{16\\pi\\epsilon_{0}\\epsilon_{r} z^2} \\right)^2 = \\frac{q^2}{256\\pi^2\\epsilon_{0}^2\\epsilon_{r}^2 z^4} $$\n那么，由感应引起的稳定能为：\n$$ W_{\\alpha}(z) = U_{\\text{ind}} = -\\frac{1}{2}\\alpha |\\vec{E}_{\\text{loc}}(z)|^2 = -\\frac{1}{2}\\alpha \\left( \\frac{q^2}{256\\pi^2\\epsilon_{0}^2\\epsilon_{r}^2 z^4} \\right) $$\n$$ W_{\\alpha}(z) = -\\frac{\\alpha q^2}{512\\pi^2\\epsilon_{0}^2\\epsilon_{r}^2 z^4} $$\n这一项表示由于离子在电极对离子电荷响应所产生的电场中发生极化而导致的能量降低。\n\nPMF 的总静电贡献 $W_{\\text{elec}}(z)$ 是这两个能量贡献的总和：\n$$ W_{\\text{elec}}(z) = W_q(z) + W_{\\alpha}(z) $$\n$$ W_{\\text{elec}}(z) = -\\frac{q^2}{16\\pi\\epsilon_{0}\\epsilon_{r} z} - \\frac{\\alpha q^2}{512\\pi^2\\epsilon_{0}^2\\epsilon_{r}^2 z^4} $$\n该表达式表示在电介质中，一个可极化离子距离接地导电电极 $z$ 处时的总稳定能，其参考态为无穷远分离状态。",
            "answer": "$$\n\\boxed{- \\frac{q^2}{16 \\pi \\epsilon_0 \\epsilon_r z} - \\frac{\\alpha q^2}{512 \\pi^2 \\epsilon_0^2 \\epsilon_r^2 z^4}}\n$$"
        },
        {
            "introduction": "伞形采样模拟的效率和准确性在很大程度上取决于采样窗口的布局。本练习是一个高级的计算任务，要求您设计并实现一个算法，根据一个初步的PMF来生成一个优化的、非均匀的窗口分布方案。掌握这种方法能确保在整个反应坐标上获得均匀的采样精度，从而最大限度地提高计算资源的利用效率。",
            "id": "4244627",
            "problem": "给定一个描述计算电化学中界面电子转移的一维反应坐标 $\\xi \\in [0,1]$。在一个均匀网格上，已有一个初步的平均力势 (PMF)，提供了以千焦每摩尔为单位的 $F(\\xi)$。目标是设计一个非均匀的伞形采样窗口方案，通过适当地选择窗口中心位置 $\\{\\xi_i\\}$ 和谐波力常数 $\\{k_i\\}$，在每个窗口采样时间固定且相等的情况下，使整个 $\\xi$ 上的期望统计误差均衡化。\n\n推导您的方法时，请仅使用以下基本原理和定义：\n\n- 平衡统计力学：沿反应坐标的无偏概率密度满足 $P(\\xi) \\propto \\exp\\left(-\\beta F(\\xi)\\right)$，其中 $\\beta = 1/(k_\\mathrm{B} T)$，$k_\\mathrm{B}$ 是 Boltzmann 常数，$T$ 是绝对温度。\n- 伞形采样对窗口 $i$ 使用的偏置势为 $U_i(\\xi) = \\frac{1}{2} k_i (\\xi - \\xi_i)^2$。\n- 窗口 $i$ 的有偏稳态分布与 $\\exp\\left(-\\beta \\left[F(\\xi) + U_i(\\xi)\\right]\\right)$ 成正比。\n- 自由能估计中的局部统计误差与每个 $\\xi$ 附近所有窗口共同贡献的局部有效采样密度成反比，假设每个窗口的采样时长相等，并且使用加权直方图分析方法 (WHAM) 或多态 Bennett 接受率 (MBAR) 进行相同的后处理。您必须根据这些事实，在不使用任何预先指定的快捷公式的情况下，构建一个有原则的准则来平衡 $\\xi$ 上的期望误差。\n\n设计一个算法，对于给定的初步 PMF $F(\\xi)$ 和一个指定的目标均方根采样宽度 $\\sigma$（在 $\\xi$ 的坐标单位下是无量纲的），计算：\n\n1. 一组在 $[0,1]$ 上的窗口中心 $\\{\\xi_i\\}_{i=1}^M$，其非均匀分布旨在使 $\\xi$ 上的期望统计误差均衡化。\n2. 一组谐波力常数 $\\{k_i\\}_{i=1}^M$，单位为千焦每摩尔每反应坐标平方，其选择方式应使得每个中心附近的局域涨落宽度与 PMF 的曲率结合后，约等于目标值。\n\n为进行评估，在 $\\xi$ 值的网格上定义聚合偏置采样密度 $S(\\xi) = \\sum_{i=1}^M \\exp\\left(-\\beta \\left[F(\\xi) + \\frac{1}{2}k_i(\\xi - \\xi_i)^2\\right]\\right)$。使用该网格，计算 $S(\\xi)$ 在整个定义域上的变异系数，即标准差除以平均值。较小的变异系数表示期望统计误差更加均衡。\n\n常数和单位：\n- 使用 $T = 298$ 开尔文和 $k_\\mathrm{B} = 0.008314462618$ 千焦每摩尔每开尔文，因此 $k_\\mathrm{B}T$ 的单位是千焦每摩尔，$\\beta$ 的单位是千焦每摩尔的倒数。\n- PMF 值 $F(\\xi)$ 的单位是千焦每摩尔，力常数 $k_i$ 必须以千焦每摩尔每反应坐标平方为单位给出。坐标 $\\xi$ 是无量纲的。\n\n假设在 $[0,1]$ 上有一个包含 $N$ 个点的均匀网格，其间距为 $\\Delta \\xi = 1/(N-1)$，并使用离散的 $F(\\xi)$ 值通过有限差分估计 PMF 曲率 $F''(\\xi)$，以指导 $k_i$ 的选择。您的方法在边界处必须具有鲁棒性。\n\n测试套件：\n- 案例1（“陡峭不对称双势阱”）：设 $N = 1001$，$M = 24$，$\\sigma = 0.05$。定义\n$$\nF_1(\\xi) = 12 \\exp\\left(-\\left(\\frac{\\xi - 0.5}{0.18}\\right)^2\\right) - 20 \\exp\\left(-\\left(\\frac{\\xi - 0.2}{0.06}\\right)^2\\right) - 30 \\exp\\left(-\\left(\\frac{\\xi - 0.8}{0.03}\\right)^2\\right).\n$$\n- 案例2（“窄边界势阱和远端势垒”）：设 $N = 1001$，$M = 30$，$\\sigma = 0.04$。定义\n$$\nF_2(\\xi) = 8 \\exp\\left(-\\left(\\frac{\\xi - 0.85}{0.08}\\right)^2\\right) - 35 \\exp\\left(-\\left(\\frac{\\xi - 0.05}{0.02}\\right)^2\\right) + 3 \\xi.\n$$\n- 案例3（“近乎平坦，带单个势垒和缓和势阱”）：设 $N = 1001$，$M = 16$，$\\sigma = 0.07$。定义\n$$\nF_3(\\xi) = 2 + 6 \\exp\\left(-\\left(\\frac{\\xi - 0.6}{0.15}\\right)^2\\right) - 8 \\exp\\left(-\\left(\\frac{\\xi - 0.3}{0.10}\\right)^2\\right).\n$$\n\n算法要求：\n- 在网格上使用中心有限差分（如适用）和在边界处使用单边有限差分来估计 $F''(\\xi)$。\n- 基于上述基本原理，提出一种有原则的方法，在无偏概率低的区域放置更多窗口中心，在无偏概率高的区域放置较少窗口中心，并选择 $k_i$ 使 $\\xi_i$ 附近的有效曲率产生的局域涨落宽度接近目标 $\\sigma$。\n- 通过构造确保 $k_i$ 为非负值，并对 $F''(\\xi)$ 中的大的正或负曲率具有鲁棒性。\n\n您的程序必须为每个测试案例计算方案 $(\\{\\xi_i\\},\\{k_i\\})$，在网格上评估 $S(\\xi)$，并输出 $S(\\xi)$ 的变异系数作为一个浮点数。最终输出必须是一行文本，包含三个测试案例的三个变异系数，格式为方括号内以逗号分隔的列表，如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$。\n\n输出的数字是无量纲的，并且必须以纯十进制浮点数形式打印。不应打印任何其他文本。",
            "solution": "该问题要求为一维反应坐标 $\\xi \\in [0,1]$ 设计一个最优的伞形采样窗口方案，该方案包括窗口中心 $\\{\\xi_i\\}$ 和谐波力常数 $\\{k_i\\}$。目标是使坐标上的期望统计误差均衡化，这等同于实现一个最大程度上均匀的聚合采样密度 $S(\\xi)$。推导过程从统计力学的第一性原理出发。\n\n首先，我们确定必要的物理常数和网格。热能为 $k_\\mathrm{B} T$，其中 $T = 298 \\, \\text{K}$，$k_\\mathrm{B} = 0.008314462618 \\, \\text{kJ} \\cdot \\text{mol}^{-1} \\cdot \\text{K}^{-1}$。逆温度为 $\\beta = 1/(k_\\mathrm{B} T)$。反应坐标 $\\xi$ 在一个包含 $N$ 个点的均匀网格上离散化，即 $\\{\\xi_j\\}_{j=0}^{N-1}$，间距为 $\\Delta\\xi = 1/(N-1)$。\n\n解决方案主要分为两个部分：确定力常数 $\\{k_i\\}$，然后确定窗口中心位置 $\\{\\xi_i\\}$。\n\n**1. 谐波力常数 $\\{k_i\\}$ 的确定**\n\n目标是选择每个力常数 $k_i$，使得系统在窗口 $i$ 内的局域涨落宽度与目标宽度 $\\sigma$ 相匹配。对于以 $\\xi_i$ 为中心、力常数为 $k_i$ 的窗口 $i$，其偏置势由下式给出：\n$$\nF_i^\\text{biased}(\\xi) = F(\\xi) + U_i(\\xi) = F(\\xi) + \\frac{1}{2} k_i (\\xi - \\xi_i)^2\n$$\n该窗口模拟内的概率分布为 $P_i(\\xi) \\propto \\exp(-\\beta F_i^\\text{biased}(\\xi))$。为了分析中心 $\\xi_i$ 周围的局域涨落，我们对无偏平均力势 (PMF) $F(\\xi)$ 在 $\\xi_i$ 附近进行泰勒展开：\n$$\nF(\\xi) \\approx F(\\xi_i) + F'(\\xi_i)(\\xi - \\xi_i) + \\frac{1}{2} F''(\\xi_i)(\\xi - \\xi_i)^2\n$$\n将此式代入偏置势表达式，得到 $\\xi_i$ 附近的有效势：\n$$\nF_i^\\text{biased}(\\xi) \\approx F(\\xi_i) + F'(\\xi_i)(\\xi - \\xi_i) + \\frac{1}{2} \\left( F''(\\xi_i) + k_i \\right) (\\xi - \\xi_i)^2\n$$\n这描述了一个有效力常数为 $k_i^\\text{eff} = F''(\\xi_i) + k_i$ 的谐波势。相应的概率分布近似为高斯分布，$P_i(\\xi) \\propto \\exp\\left(-\\frac{\\beta k_i^\\text{eff}}{2}(\\xi - \\xi_i)^2\\right)$。此高斯分布的方差为 $\\sigma_i^2 = 1/(\\beta k_i^\\text{eff})$。\n\n我们给定一个目标均方根采样宽度 $\\sigma$。通过将局域宽度 $\\sigma_i$ 与此目标 $\\sigma$ 等同，我们得到一个关于有效力常数的条件：\n$$\n\\sigma^2 = \\frac{1}{\\beta (F''(\\xi_i) + k_i)}\n$$\n解出我们期望的伞形力常数 $k_i$：\n$$\nk_i = \\frac{1}{\\beta \\sigma^2} - F''(\\xi_i)\n$$\n这里，$F''(\\xi_i)$ 是无偏 PMF 在窗口中心 $\\xi_i$ 处的局域曲率。项 $1/(\\beta \\sigma^2)$ 代表偏置势的目标总曲率。为确保偏置势是约束性的，力常数 $k_i$ 必须为非负值。这引出了选择 $k_i$ 的鲁棒性规则：\n$$\nk_i = \\max\\left(0, \\frac{1}{\\beta \\sigma^2} - F''(\\xi_i)\\right)\n$$\n该规则意味着，如果 PMF 的自然曲率 $F''(\\xi_i)$ 已经足够大使涨落宽度小于或等于 $\\sigma$，则不需要额外的偏置力 ($k_i = 0$)。否则，选择 $k_i$ 来增强自然曲率以达到目标。曲率 $F''(\\xi)$ 在离散网格上使用有限差分进行估计。我们对内部点使用二阶中心差分，对边界点使用指定的二阶单边公式，以保持整个定义域的准确性。\n\n**2. 窗口中心位置 $\\{\\xi_i\\}$ 的确定**\n\n主要目标是使聚合采样密度 $S(\\xi)$ 在定义域 $\\xi \\in [0,1]$ 上尽可能均匀。密度 $S(\\xi)$ 是所有 $M$ 个窗口贡献的总和：\n$$\nS(\\xi) = \\sum_{i=1}^M \\exp\\left(-\\beta \\left[F(\\xi) + \\frac{1}{2}k_i(\\xi - \\xi_i)^2\\right]\\right) = e^{-\\beta F(\\xi)} \\sum_{i=1}^M e^{-\\frac{\\beta k_i}{2}(\\xi - \\xi_i)^2}\n$$\n目标是使 $S(\\xi) \\approx C$，其中 $C$ 是一个常数。这意味着：\n$$\n\\sum_{i=1}^M e^{-\\frac{\\beta k_i}{2}(\\xi - \\xi_i)^2} \\approx C \\cdot e^{\\beta F(\\xi)}\n$$\n如果窗口数量 $M$ 足够大，我们可以用一个连续的窗口密度 $\\rho(\\xi')$ 上的积分来近似该和，其中 $\\xi'$ 是窗口中心坐标。在无穷小区间 $d\\xi'$ 内的窗口数量为 $\\rho(\\xi') d\\xi'$。该和变为：\n$$\n\\int_0^1 \\rho(\\xi') e^{-\\frac{\\beta k(\\xi')}{2}(\\xi - \\xi')^2} d\\xi' \\approx C \\cdot e^{\\beta F(\\xi)}\n$$\n其中 $k(\\xi')$ 是位于 $\\xi'$ 处的窗口的力常数。高斯项 $e^{-\\frac{\\beta k(\\xi')}{2}(\\xi - \\xi')^2}$ 在 $\\xi' \\approx \\xi$ 处急剧达到峰值。因此，该积分局部地探测了密度 $\\rho(\\xi')$。积分在 $\\xi$ 处的值近似与 $\\rho(\\xi)$ 成正比。这引出了关键的洞察：为了使左侧与 $e^{\\beta F(\\xi)}$ 成正比，窗口密度 $\\rho(\\xi)$ 必须选择为与 PMF 的 Boltzmann 因子成正比。\n$$\n\\rho(\\xi) \\propto e^{\\beta F(\\xi)}\n$$\n这一原则确保了在自由能高的区域（无偏概率低的区域）放置更多的窗口，以补偿系统自然回避这些区域的倾向。\n\n为了对离散数量的窗口 $M$ 算法化地实现这一原则，我们使用累积分布函数 (CDF) 方法。我们在网格上定义一个权重函数 $\\omega(\\xi) = e^{\\beta F(\\xi)}$。\n1. 计算此权重函数的累积积分：$W(\\xi) = \\int_0^\\xi \\omega(x) dx$。这在离散网格值 $\\omega(\\xi_j)$ 上使用梯形法则进行数值计算。\n2. 总积分为 $W_\\text{total} = W(1)$。我们将区间 $[0, W_\\text{total}]$ 分成 $M$ 个相等的子区间。在这些子区间的中点选择目标累积权重：$W_{\\text{target},i} = \\frac{i - 0.5}{M} W_\\text{total}$，其中 $i = 1, \\dots, M$。\n3. 然后通过对累积函数求逆来找到窗口中心 $\\{\\xi_i\\}$：$\\xi_i = W^{-1}(W_{\\text{target},i})$。这可以通过线性插值高效完成，即找到与目标累积权重相对应的 $\\xi$ 值。\n\n**算法总结：**\n1.  **初始化：** 定义常数 $T$、$k_\\mathrm{B}$，并计算 $\\beta$。在 $[0,1]$ 上建立包含 $N$ 个点 $\\{\\xi_j\\}$ 的网格。对于给定的测试案例，在此网格上评估 PMF $F(\\xi)$ 以获得 $\\{F_j\\}$。\n2.  **PMF 曲率：** 使用二阶有限差分公式（内部点用中心差分，边界点用指定的单边差分）在网格上计算二阶导数 $F''(\\xi)$，得到 $\\{F''_j\\}$。\n3.  **窗口中心 $\\{\\xi_i\\}$：**\n    a. 在网格上计算权重函数：$\\omega_j = \\exp(\\beta F_j)$。\n    b. 数值计算累积积分 $W_j = \\int_0^{\\xi_j} \\omega(x) dx$。\n    c. 在累积积分的范围内生成 $M$ 个等间距的目标值 $\\{W_{\\text{target},i}\\}$。\n    d. 使用线性插值找到与 $\\{W_{\\text{target},i}\\}$ 相对应的 $\\xi$ 坐标，从而确定 $M$ 个窗口中心 $\\{\\xi_i\\}$。\n4.  **力常数 $\\{k_i\\}$：**\n    a. 对于每个窗口中心 $\\xi_i$，通过插值网格值 $\\{F''_j\\}$ 来找到局域 PMF 曲率 $F''(\\xi_i)$。\n    b. 计算相应的力常数 $k_i = \\max(0, 1/(\\beta\\sigma^2) - F''(\\xi_i))$。\n5.  **评估：**\n    a. 使用确定的方案 $(\\{\\xi_i\\}, \\{k_i\\})$，在每个网格点 $\\xi_j$ 上计算聚合采样密度 $S(\\xi_j)$。\n    b. 计算所得数组 $\\{S_j\\}$ 的平均值和标准差。\n    c. 最终结果是变异系数，$\\text{CV} = \\text{std}(S) / \\text{mean}(S)$。\n\n这个有原则的两阶段过程确保了窗口的位置及其各自的约束力都被系统地选择，以平坦化整体采样剖面，从而优化伞形采样模拟的效率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the final results.\n    \"\"\"\n    \n    # Define physical constants\n    T = 298.0  # Kelvin\n    KB = 0.008314462618  # kJ/mol/K\n    BETA = 1.0 / (KB * T)\n\n    # Define test case PMF functions\n    def F1(xi):\n        return (12.0 * np.exp(-((xi - 0.5) / 0.18)**2) -\n                20.0 * np.exp(-((xi - 0.2) / 0.06)**2) -\n                30.0 * np.exp(-((xi - 0.8) / 0.03)**2))\n\n    def F2(xi):\n        return (8.0 * np.exp(-((xi - 0.85) / 0.08)**2) -\n                35.0 * np.exp(-((xi - 0.05) / 0.02)**2) +\n                3.0 * xi)\n\n    def F3(xi):\n        return (2.0 + 6.0 * np.exp(-((xi - 0.6) / 0.15)**2) -\n                8.0 * np.exp(-((xi - 0.3) / 0.10)**2))\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"F_func\": F1, \"N\": 1001, \"M\": 24, \"sigma\": 0.05},\n        {\"F_func\": F2, \"N\": 1001, \"M\": 30, \"sigma\": 0.04},\n        {\"F_func\": F3, \"N\": 1001, \"M\": 16, \"sigma\": 0.07},\n    ]\n\n    results = []\n    for case in test_cases:\n        cv = compute_schedule_and_cv(\n            case[\"F_func\"], case[\"N\"], case[\"M\"], case[\"sigma\"], BETA\n        )\n        results.append(cv)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_f_double_prime(F, dx):\n    \"\"\"\n    Computes the second derivative of a function F on a grid using\n    second-order finite differences.\n    \"\"\"\n    N = len(F)\n    F_pp = np.zeros_like(F)\n    dx2 = dx * dx\n\n    # Interior points: central difference\n    F_pp[1:-1] = (F[2:] - 2*F[1:-1] + F[:-2]) / dx2\n\n    # Boundary points: one-sided differences\n    if N >= 4:\n        # Left boundary (forward difference)\n        F_pp[0] = (2*F[0] - 5*F[1] + 4*F[2] - F[3]) / dx2\n        # Right boundary (backward difference)\n        F_pp[-1] = (2*F[-1] - 5*F[-2] + 4*F[-3] - F[-4]) / dx2\n    elif N >= 3: # Fallback for smaller N\n        F_pp[0] = (F[2] - 2*F[1] + F[0]) / dx2\n        F_pp[-1] = (F[-1] - 2*F[-2] + F[-3]) / dx2\n    # For N3, boundaries are same as interior, which is empty. Handled.\n    \n    return F_pp\n\ndef compute_schedule_and_cv(F_func, N, M, sigma, beta):\n    \"\"\"\n    Computes the umbrella sampling schedule and the coefficient of variation\n    of the aggregate sampling density for a given case.\n    \"\"\"\n    # 1. Grid and PMF\n    xi_grid = np.linspace(0.0, 1.0, N)\n    delta_xi = 1.0 / (N - 1)\n    F_grid = F_func(xi_grid)\n\n    # 2. PMF Curvature\n    F_double_prime_grid = compute_f_double_prime(F_grid, delta_xi)\n\n    # 3. Place Window Centers {xi_i}\n    weights = np.exp(beta * F_grid)\n    cum_weights = cumulative_trapezoid(weights, x=xi_grid, initial=0.0)\n    \n    total_weight = cum_weights[-1]\n    target_weights = (np.arange(1, M + 1) - 0.5) / M * total_weight\n    \n    xi_centers = np.interp(target_weights, cum_weights, xi_grid)\n\n    # 4. Calculate Force Constants {k_i}\n    F_double_prime_at_centers = np.interp(xi_centers, xi_grid, F_double_prime_grid)\n    \n    target_curvature = 1.0 / (beta * sigma**2)\n    k_constants = target_curvature - F_double_prime_at_centers\n    k_constants = np.maximum(0.0, k_constants)\n\n    # 5. Evaluate Performance Metric\n    S_grid = np.zeros(N)\n    for i in range(M):\n        U_i = 0.5 * k_constants[i] * (xi_grid - xi_centers[i])**2\n        S_grid += np.exp(-beta * (F_grid + U_i))\n\n    mean_S = np.mean(S_grid)\n    std_S = np.std(S_grid)\n    \n    if mean_S == 0:\n        return 0.0 # Or handle as an error, but for this problem should not happen\n        \n    cv = std_S / mean_S\n    return cv\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "在完成伞形采样模拟并通过加权直方图分析方法（WHAM）等方法进行分析后，我们得到的是沿着反应坐标的平均力（PMF的导数），而这些数据通常带有统计噪声。本练习聚焦于从这些含噪的力数据中稳健地重建PMF的关键步骤，您将通过实现Tikhonov正则化方法来学习如何通过积分得到一个平滑且物理上合理的PMF，从而有效控制噪声的传播。这个过程代表了从原始模拟输出到最终科学结论的完整流程中的一个关键环节。",
            "id": "4244617",
            "problem": "您的任务是设计并实现一个数值正则化方案，以便在计算电化学背景下，从沿反应坐标的含噪声平均力数据中重建平均力势。在伞形采样中，平均力势是沿着选定的反应坐标定义的，而从偏置窗口中估计出的平均力则用于通过数值积分来恢复平均力势。本任务分离了此恢复过程中的数值方面，并明确关注通过正则化来控制噪声传播。您必须生成一个单一、自包含的 Python 脚本，以执行下述任务，并按指定格式打印所需的最终输出。\n\n推导的基本依据：使用平均力势 $F(\\xi)$ 作为反应坐标 $\\xi$ 的函数的定义，以及导数 $dF/d\\xi$（平均力）与势 $F(\\xi)$ 之间的关系。所提供的数据是 $dF/d\\xi$ 的含噪声估计值，目标是通过正则化积分获得 $F(\\xi)$ 的稳定估计，该积分能够控制统计误差的传播。引入通过惩罚曲率（二阶导数）来控制平滑度的概念。从以下经过充分检验的事实出发：在均匀网格上进行离散化可以产生一阶和二阶导数的一致有限差分近似，并且 Tikhonov 型正则化通过在数据保真度与平滑度之间进行权衡来稳定逆问题。不要依赖快捷公式或预先推导的矩阵正规方程：从离散导数和平滑度的基本定义出发，推导您的离散算子构建和优化问题。\n\n为反应坐标 $\\xi$ 在区间 $\\xi \\in [0,L]$ 上建立一个一维均匀网格，其中 $L = 1.0$ 纳米 (nm)。令 $N$ 表示网格点数，网格间距为 $h = L/(N-1)$。将底层的“真实”平均力势 $F_{\\mathrm{true}}(\\xi)$ 定义为\n$$\nF_{\\mathrm{true}}(\\xi) = A \\sin\\left(\\frac{2\\pi \\xi}{L}\\right) + B \\xi^2,\n$$\n其中 $A = 5.0$ 千焦/摩尔 (kJ/mol)，$B = 2.0$ 千焦/摩尔/平方纳米 (kJ/mol/nm$^2$)。相应的“真实”平均力（导数）为\n$$\n\\frac{dF_{\\mathrm{true}}}{d\\xi}(\\xi) = A \\frac{2\\pi}{L} \\cos\\left(\\frac{2\\pi \\xi}{L}\\right) + 2B \\xi,\n$$\n单位为千焦/摩尔/纳米 (kJ/mol/nm)。\n\n通过向真实导数值添加独立的高斯噪声来生成网格点 $\\xi_i$ 上的合成含噪声平均力数据 $g_i$：\n$$\ng_i = \\left.\\frac{dF_{\\mathrm{true}}}{d\\xi}\\right|_{\\xi=\\xi_i} + \\varepsilon_i,\n$$\n其中 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$，$\\sigma$ 是指定的标准差，单位为千焦/摩尔/纳米 (kJ/mol/nm)。使用固定的伪随机生成器种子以确保可复现性。\n\n在网格上构建离散线性算子：\n- 一个一阶导数算子 $D$，作用于函数 $f$ 的网格值，以产生 $df/d\\xi$ 的近似值，使用标准有限差分。对于内部点 $i$ ($1 \\le i \\le N-2$)，使用中心差分近似\n$$\n\\left(D f\\right)_i = \\frac{f_{i+1} - f_{i-1}}{2h}.\n$$\n对于边界点，使用单边差分：\n$$\n\\left(D f\\right)_0 = \\frac{f_{1} - f_{0}}{h}, \\quad \\left(D f\\right)_{N-1} = \\frac{f_{N-1} - f_{N-2}}{h}.\n$$\n- 一个二阶导数算子 $L$，通过离散二阶差分来近似内部点的曲率\n$$\n\\left(L f\\right)_i = \\frac{f_{i+1} - 2 f_i + f_{i-1}}{h^2} \\quad \\text{对于 } 1 \\le i \\le N-2,\n$$\n并且 $\\left(L f\\right)_0 = 0$, $\\left(L f\\right)_{N-1} = 0$，以避免在边界处施加曲率惩罚。\n\n通过 Tikhonov 正则化设计正则化积分：通过最小化一个由离散算子和含噪声数据构建的二次目标函数来找到 $f$（$F(\\xi)$ 的估计值），\n$$\nJ(f) = \\left\\| D f - g \\right\\|_2^2 + \\alpha \\left\\| L f \\right\\|_2^2,\n$$\n其中 $g$ 是含噪声的导数样本向量，$\\alpha  0$ 是控制平滑度的正则化参数。因为从导数进行积分会留下一个任意的加性常数，所以施加锚定条件\n$$\nf(\\xi_0) = 0,\n$$\n以固定左边界的势能参考点。在优化中将此锚定实现为硬等式约束。\n\n您的程序必须：\n1. 构建网格以及真实势 $F_{\\mathrm{true}}(\\xi)$ 和其导数 $dF_{\\mathrm{true}}/d\\xi$。\n2. 使用指定的 $\\sigma$ 和种子生成含噪声的平均力数据 $g$。\n3. 构建离散算子 $D$ 和 $L$。\n4. 求解约束正则化最小二乘问题，以产生在 $f(\\xi_0)=0$ 约束下最小化 $J(f)$ 的 $f$。使用诸如 Karush–Kuhn–Tucker (KKT) 条件之类的原则性方法来精确执行等式约束。\n5. 计算恢复的 $f$ 与 $F_{\\mathrm{true}}$ 之间的均方根误差 (RMSE)，定义为\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(f_i - F_{\\mathrm{true}}(\\xi_i)\\right)^2},\n$$\n单位为千焦/摩尔 (kJ/mol)。\n\n明确的单位要求：所有势能 $F(\\xi)$ 必须以千焦/摩尔 (kJ/mol) 为单位处理，反应坐标 $\\xi$ 以纳米 (nm) 为单位，导数 $dF/d\\xi$ 以千焦/摩尔/纳米 (kJ/mol/nm) 为单位。您的程序的最终数值输出是无单位的数字，但必须可解释为以千焦/摩尔 (kJ/mol) 为单位的 RMSE 值。不使用角度。不使用百分比。\n\n测试套件：您的程序必须评估以下测试用例的 RMSE，每个用例由一个元组 $(N,\\sigma,\\alpha,\\text{seed})$ 定义：\n- 用例 1：$(101, 0.5, 10^{-2}, 0)$，代表具有中等噪声和中等正则化的“理想路径”。\n- 用例 2：$(101, 0.05, 10^{-6}, 1)$，代表具有几乎无正则化积分的低噪声场景。\n- 用例 3：$(101, 2.0, 10^{-1}, 2)$，代表具有更强正则化的高噪声场景。\n- 用例 4：$(21, 1.0, 5 \\times 10^{-2}, 3)$，代表具有中等噪声和正则化的粗糙网格。\n\n最终输出格式：您的程序应生成一行输出，其中包含四个测试用例的 RMSE 结果，以方括号括起来的逗号分隔列表形式，按上述顺序列出。例如，输出必须是以下形式：\n$$\n[\\mathrm{rmse}_1,\\mathrm{rmse}_2,\\mathrm{rmse}_3,\\mathrm{rmse}_4],\n$$\n其中每个 $\\mathrm{rmse}_i$ 是一个对应于用例 $i$ 的 RMSE 的十进制数，单位为千焦/摩尔 (kJ/mol)。",
            "solution": "该问题是有效的。它提出了一个在计算化学中应用的、适定的、有科学依据的数值分析任务。所有常数、函数形式和所需的数值方法都已明确指定，并且问题是自包含的。\n\n问题的核心是从一组关于其对反应坐标 $\\xi$ 的导数的含噪声测量值中重建平均力势 (PMF)，记为 $F(\\xi)$。给定的数据 $g$ 是真实平均力 $dF_{\\mathrm{true}}/d\\xi$ 的离散样本，被高斯噪声污染。任务是通过对含噪声数据 $g$ 进行数值积分，找到真实势 $F_{\\mathrm{true}}$ 的一个稳定估计 $f$。一个简单的数值积分（例如，梯形法则）会累积并放大 $g$ 中的噪声，导致对 $f$ 的估计很差。因此，采用正则化方法来确保解是平滑的，这对于势能面来说是一个物理上合理的假设。\n\n指定的方法是 Tikhonov 正则化。我们寻求一个离散函数 $f$（表示为在网格点 $\\xi_i$ 上的值 $f_i$ 的向量），该函数最小化以下目标泛函：\n$$\nJ(f) = \\left\\| D f - g \\right\\|_2^2 + \\alpha \\left\\| L f \\right\\|_2^2\n$$\n在这里，$f$ 是在一个包含 $N$ 个点的均匀网格上的未知势值向量 $[f_0, f_1, \\dots, f_{N-1}]^T$。向量 $g = [g_0, g_1, \\dots, g_{N-1}]^T$ 包含含噪声的平均力数据。算子 $D$ 是一阶导数 $d/d\\xi$ 的离散近似，而 $L$ 是二阶导数（曲率）$d^2/d\\xi^2$ 的离散近似。第一项 $\\|Df - g\\|_2^2$ 是一个数据保真度项，它强制我们的解 $f$ 的导数应与观测数据 $g$ 匹配。第二项 $\\|Lf\\|_2^2$ 是一个正则化（或惩罚）项，它惩罚具有高曲率的解，从而促进平滑性。正则化参数 $\\alpha  0$ 是一个标量，用于控制拟合数据与解的平滑度之间的权衡。\n\n由于微分和积分的定义可相差一个加性常数，因此所述问题是不适定的。为了获得唯一解，我们必须固定势在某一点的值。问题指定了一个锚定条件 $f(\\xi_0) = 0$，这在我们的离散解向量上转化为硬约束 $f_0 = 0$。\n\n我们使用 $N$ 个点将反应坐标 $\\xi$ 在区间 $[0, L]$ 上离散化，均匀间距为 $h = L/(N-1)$。网格点为 $\\xi_i = i \\cdot h$，其中 $i = 0, 1, \\dots, N-1$。离散算子 $D$ 和 $L$ 根据提供的有限差分公式构建为 $N \\times N$ 矩阵。\n\n一阶导数算子 $D$ 的构造如下：\n- 对于第一个点（索引 $i=0$），前向差分：$(Df)_0 = (f_1 - f_0)/h$。这对应于矩阵 $D$ 的第一行具有 $D_{0,0} = -1/h$, $D_{0,1} = 1/h$。\n- 对于内部点 ($1 \\le i \\le N-2$)，中心差分：$(Df)_i = (f_{i+1} - f_{i-1})/(2h)$。这意味着 $D$ 的第 $i$ 行具有 $D_{i, i-1} = -1/(2h)$ 和 $D_{i, i+1} = 1/(2h)$。\n- 对于最后一个点（索引 $i=N-1$），后向差分：$(Df)_{N-1} = (f_{N-1} - f_{N-2})/h$。$D$ 的最后一行具有 $D_{N-1, N-2} = -1/h$, $D_{N-1, N-1} = 1/h$。\n\n二阶导数算子 $L$ 的构造如下：\n- 对于内部点 ($1 \\le i \\le N-2$)：$(Lf)_i = (f_{i+1} - 2f_i + f_{i-1})/h^2$。$L$ 的第 $i$ 行具有 $L_{i, i-1} = 1/h^2$, $L_{i, i} = -2/h^2$ 和 $L_{i, i+1} = 1/h^2$。\n- 对于边界点 ($i=0$ 和 $i=N-1$)，曲率设为零：$(Lf)_0=0$ 和 $(Lf)_{N-1}=0$。矩阵 $L$ 的第一行和最后一行完全为零。\n\n问题是在线性约束 $f_0=0$ 的条件下，最小化二次目标函数 $J(f)$。这是一个约束最小二乘问题。一种解决此问题的原则性方法，正如对 KKT 条件的引用所建议的，是精确地执行该约束。最直接的方法是通过变量消除。我们要求解的向量是 $f = [f_0, f_1, \\dots, f_{N-1}]^T$。给定约束 $f_0=0$，唯一的未知数位于大小为 $N-1$ 的子向量 $f' = [f_1, \\dots, f_{N-1}]^T$ 中。\n\n我们可以用未知向量 $f'$ 来表示完整向量 $f$：$f_0=0$ 和 $f_i = f'_{i-1}$ 对于 $i=1, \\dots, N-1$。这种关系允许我们重写目标函数中的项。令 $D_{:, 1:}$ 为去掉第一列的矩阵 $D$（一个 $N \\times (N-1)$ 的矩阵），$L_{:, 1:}$ 也类似。那么 $Df = D_{:, 1:} f'$ 和 $Lf = L_{:, 1:} f'$。\n未知向量 $f'$ 的目标函数变为：\n$$\nJ(f') = \\left\\| D_{:, 1:} f' - g \\right\\|_2^2 + \\alpha \\left\\| L_{:, 1:} f' \\right\\|_2^2\n$$\n这现在是一个无约束线性最小二乘问题。为了找到最小值，我们将 $J(f')$ 关于 $f'$ 的梯度设为零。展开范数平方项：\n$$\nJ(f') = (D_{:, 1:}f' - g)^T(D_{:, 1:}f' - g) + \\alpha (L_{:, 1:}f')^T(L_{:, 1:}f')\n$$\n$$\nJ(f') = f'^T D_{:, 1:}^T D_{:, 1:} f' - 2g^T D_{:, 1:} f' + g^T g + \\alpha f'^T L_{:, 1:}^T L_{:, 1:} f'\n$$\n关于 $f'$ 的梯度是：\n$$\n\\nabla_{f'} J(f') = 2 D_{:, 1:}^T D_{:, 1:} f' - 2 D_{:, 1:}^T g + 2 \\alpha L_{:, 1:}^T L_{:, 1:} f'\n$$\n将梯度设为零，得到 $f'$ 的正规方程：\n$$\n(D_{:, 1:}^T D_{:, 1:} + \\alpha L_{:, 1:}^T L_{:, 1:}) f' = D_{:, 1:}^T g\n$$\n这是一个形式为 $A x = b$ 的标准线性系统，其中 $A = D_{:, 1:}^T D_{:, 1:} + \\alpha L_{:, 1:}^T L_{:, 1:}$，$x = f'$，以及 $b = D_{:, 1:}^T g$。矩阵 $A$ 是一个 $(N-1) \\times (N-1)$ 的对称正定矩阵，保证了 $f'$ 的唯一解。\n\n算法流程如下：\n1. 对于每个测试用例 $(N, \\sigma, \\alpha, \\text{seed})$，设置网格 $\\xi$ 和常数 $L, A, B$。\n2. 在网格上计算真实势 $F_{\\mathrm{true}}$ 及其导数 $dF_{\\mathrm{true}}/d\\xi$。\n3. 通过向 $dF_{\\mathrm{true}}/d\\xi$ 添加标准差为 $\\sigma$ 的高斯噪声，生成含噪声数据向量 $g$，并使用指定的随机种子以保证可复现性。\n4. 根据有限差分方案构造 $N \\times N$ 矩阵 $D$ 和 $L$。\n5. 如上所述，构建简化的 $(N-1) \\times (N-1)$ 线性系统 $A f' = b$。\n6. 求解该系统以得到未知向量 $f'$。\n7. 通过在 $f'$ 前面加上 $f_0=0$ 来重构完整的解向量 $f$。\n8. 参考势 $F_{\\mathrm{true}}(\\xi)$ 的定义使得 $F_{\\mathrm{true}}(0)=0$，这与我们的锚定条件相匹配。因此，我们可以直接计算恢复的势 $f$ 和真实势 $F_{\\mathrm{true}}$ 之间的均方根误差 (RMSE)：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(f_i - F_{\\mathrm{true}}(\\xi_i)\\right)^2}\n$$\n此过程提供了一种稳健且有原则的平均力势重建方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(N, sigma, alpha, seed):\n    \"\"\"\n    Solves a single instance of the PMF reconstruction problem.\n    \n    Args:\n        N (int): Number of grid points.\n        sigma (float): Standard deviation of the Gaussian noise.\n        alpha (float): Tikhonov regularization parameter.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        float: The root-mean-square error (RMSE) of the reconstruction.\n    \"\"\"\n    # 1. Construct the grid and the true potential and its derivative.\n    L_val = 1.0  # nm\n    A_val = 5.0  # kJ/mol\n    B_val = 2.0  # kJ/mol/nm^2\n\n    xi = np.linspace(0, L_val, N)\n    h = L_val / (N - 1)\n\n    F_true = A_val * np.sin(2 * np.pi * xi / L_val) + B_val * xi**2\n    dF_true_dxi = (A_val * (2 * np.pi / L_val) * np.cos(2 * np.pi * xi / L_val) + \n                   2 * B_val * xi)\n\n    # 2. Generate noisy mean force data.\n    rng = np.random.default_rng(seed)\n    noise = rng.normal(loc=0.0, scale=sigma, size=N)\n    g = dF_true_dxi + noise\n\n    # 3. Build the discrete operators D and L.\n    D = np.zeros((N, N))\n    # Forward difference at the start\n    D[0, 0] = -1.0 / h\n    D[0, 1] = 1.0 / h\n    # Central differences for interior\n    for i in range(1, N - 1):\n        D[i, i-1] = -1.0 / (2.0 * h)\n        D[i, i+1] = 1.0 / (2.0 * h)\n    # Backward difference at the end\n    D[N-1, N-2] = -1.0 / h\n    D[N-1, N-1] = 1.0 / h\n    \n    L_op = np.zeros((N, N))\n    # Standard 3-point stencil for second derivative for interior\n    for i in range(1, N - 1):\n        L_op[i, i-1] = 1.0 / h**2\n        L_op[i, i]   = -2.0 / h**2\n        L_op[i, i+1] = 1.0 / h**2\n    # Boundary curvature penalty is zero as specified.\n\n    # 4. Solve the constrained regularized least-squares problem.\n    # We enforce f[0] = 0 by solving for f_rest = f[1:].\n    # This transforms the problem to an unconstrained system for f_rest.\n    \n    # Take sub-matrices corresponding to f_rest\n    D_tilde = D[:, 1:]  # Shape (N, N-1)\n    L_tilde = L_op[:, 1:] # Shape (N, N-1)\n\n    # Form the normal equations for the unconstrained system: A * f_rest = b\n    # A has shape (N-1, N-1), b has shape (N-1,)\n    A_mat = D_tilde.T @ D_tilde + alpha * (L_tilde.T @ L_tilde)\n    b_vec = D_tilde.T @ g\n\n    # Solve the linear system\n    f_rest = np.linalg.solve(A_mat, b_vec)\n\n    # Reconstruct the full potential vector f, with f[0]=0\n    f = np.concatenate(([0.0], f_rest))\n\n    # 5. Compute the root-mean-square error (RMSE).\n    # The true potential is already anchored at F_true(0)=0.\n    rmse = np.sqrt(np.mean((f - F_true)**2))\n    \n    return rmse\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, sigma, alpha, seed)\n        (101, 0.5, 1e-2, 0),\n        (101, 0.05, 1e-6, 1),\n        (101, 2.0, 1e-1, 2),\n        (21, 1.0, 5e-2, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, sigma, alpha, seed = case\n        result = solve_case(N, sigma, alpha, seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}