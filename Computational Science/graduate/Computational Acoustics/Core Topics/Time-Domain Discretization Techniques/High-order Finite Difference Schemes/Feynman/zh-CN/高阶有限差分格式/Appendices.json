{
    "hands_on_practices": [
        {
            "introduction": "手动推导高阶差分格式的系数是一项繁琐且容易出错的任务。一种更强大、更可靠的方法是通过求解其背后的线性系统来将此过程自动化。这项实践  将指导您创建一个通用函数，用于为任意偶数阶 $2p$ 的中心差分格式生成系数，从而将一个理论推导任务转变为一个实用的计算工具。",
            "id": "2401266",
            "problem": "给定一个间距为 $h \\in \\mathbb{R}^{+}$ 的均匀网格和一组由整数 $k \\in \\mathbb{Z}$ 索引的网格点。对于一个固定的整数 $p \\in \\mathbb{N}$ 且 $p \\geq 1$，考虑一个宽度为 $2p+1$ 的中心差分格式模板，它由围绕一个点 $x_{0} \\in \\mathbb{R}$ 的偏移量为 $k \\in \\{-p,-p+1,\\dots,-1,0,1,\\dots,p-1,p\\}$ 的点组成。目标是使用函数值 $f(x_{0} + k h)$ 的线性组合来近似一个足够光滑的函数 $f:\\mathbb{R}\\to\\mathbb{R}$ 的一阶导数 $f^{\\prime}(x_{0})$。\n\n定义一个实系数向量 $\\{w_{k}\\}_{k=-p}^{p}$，使得中心有限差分近似\n$$\nD_{h}^{(p)}f(x_{0}) \\equiv \\frac{1}{h}\\sum_{k=-p}^{p} w_{k}\\, f(x_{0}+k h)\n$$\n当 $h \\to 0^{+}$ 时，其截断误差为 $\\mathcal{O}(h^{2p})$ 阶。在给定的 $2p+1$ 个对称点上所有可能的模板中，假设采用最小中心模板，并要求系数由以下精确性条件唯一确定：\n$$\n\\sum_{k=-p}^{p} w_{k}\\, k^{r} = \\delta_{r,1} \\quad \\text{对于所有整数 } r \\in \\{0,1,2,\\dots,2p\\}，\n$$\n其中 $\\delta_{r,1}$ 是克罗内克δ函数，当 $r=1$ 时等于 $1$，否则等于 $0$。这些条件强制要求，当 $D_{h}^{(p)}$ 应用于任何次数至多为 $2p$ 的多项式时，在考虑因子 $1/h$ 后，它能精确地再现 $x_{0}$ 处的一阶导数。\n\n任务：编写一个完整的、可运行的程序，该程序定义一个函数，对于给定的整数输入 $p \\geq 1$，返回满足上述方程组的系数列表 $[w_{-p}, w_{-p+1}, \\dots, w_{-1}, w_{0}, w_{1}, \\dots, w_{p-1}, w_{p}]$。您的程序必须为以下参数测试套件生成并输出系数：\n- $p \\in \\{1,2,3,4,5\\}$。\n\n输出中的所有数值必须表示为十进制浮点数，并四舍五入到小数点后恰好 $16$ 位。本问题不涉及物理单位。\n\n最终输出格式：您的程序应生成一行输出，其中包含作为逗号分隔列表的系数列表，不含嵌入的空格。具体来说，如果测试用例的结果是列表 $L_{1}, L_{2}, \\dots, L_{n}$，那么输出必须是如下形式的单行：\n$$\n[ L_{1},L_{2},\\dots,L_{n} ]\n$$\n其中每个 $L_{j}$ 都写成一个由方括号括起来的逗号分隔的十进制浮点数列表，四舍五入到小数点后恰好 $16$ 位，并且不含任何空格。例如，包含两个列表的输出可能如下所示：\n$$\n[[a_{1},a_{2},a_{3}],[b_{1},b_{2},b_{3},b_{4},b_{5}]].\n$$",
            "solution": "该问题陈述已经过严格的验证过程。\n\n**步骤1：提取已知条件**\n- 网格：均匀网格，间距为 $h \\in \\mathbb{R}^{+}$。\n- 模板：中心差分格式模板，宽度为 $2p+1$，其中 $p \\in \\mathbb{N}, p \\geq 1$，点由 $k \\in \\{-p, -p+1, \\dots, p\\}$ 索引。\n- 近似式：$D_{h}^{(p)}f(x_{0}) \\equiv \\frac{1}{h}\\sum_{k=-p}^{p} w_{k}\\, f(x_{0}+k h)$ 用于一阶导数 $f^{\\prime}(x_{0})$。\n- 精度：截断误差为 $\\mathcal{O}(h^{2p})$ 阶。\n- 系数：待求的实数向量 $\\{w_{k}\\}_{k=-p}^{p}$。\n- 条件：系数由以下线性方程组确定：\n$$\n\\sum_{k=-p}^{p} w_{k}\\, k^{r} = \\delta_{r,1} \\quad \\text{对于所有整数 } r \\in \\{0, 1, 2, \\dots, 2p\\}。\n$$\n- 任务：计算当 $p \\in \\{1, 2, 3, 4, 5\\}$ 时的系数 $w_k$。\n\n**步骤2：已知条件的验证**\n该问题在数值分析领域，特别是在推导有限差分公式的待定系数法方面，定义明确。所提供的条件直接源于匹配有限差分算子的泰勒级数展开中的系数，要求它对所有次数最高为 $2p$ 的多项式都能精确地再现一阶导数。\n\n该问题是求解一个包含 $2p+1$ 个线性方程的方程组，以求出 $2p+1$ 个未知系数 $\\{w_{k}\\}_{k=-p}^{p}$。该系统可以写成矩阵形式 $A \\mathbf{w} = \\mathbf{b}$。\n设未知数向量为 $\\mathbf{w} = [w_{-p}, w_{-p+1}, \\dots, w_{p}]^T$。\n右端向量为 $\\mathbf{b} = [0, 1, 0, \\dots, 0]^T$，其中唯一的非零元素对应于 $r=1$ 的条件。\n系统矩阵 $A$ 是一个 $(2p+1) \\times (2p+1)$ 的矩阵，其元素由 $A_{i,j} = (j-p)^i$ 给出，其中行索引 $i \\in \\{0, 1, \\dots, 2p\\}$，列索引 $j \\in \\{0, 1, \\dots, 2p\\}$。请注意，列索引 $j$ 对应于模板点 $k=j-p$。必须谨慎计算 $k^r$ 在 $k=0$ 处的值；具体来说，在此上下文中定义 $0^0$ 为 $1$，这与其在多项式基底中的作用一致，而当 $r>0$ 时 $0^r = 0$。\n得到的矩阵 $A$ 是一个关于不同节点 $\\{-p, -p+1, \\dots, p\\}$ 的范德蒙矩阵。由不同节点构造的范德蒙矩阵总是非奇异的。因此，其逆矩阵 $A^{-1}$ 存在且唯一。方程组 $A \\mathbf{w} = \\mathbf{b}$ 因此有唯一解 $\\mathbf{w} = A^{-1}\\mathbf{b}$。\n\n**步骤3：结论与行动**\n该问题具有科学依据，是适定的、客观的，并包含了所有必要信息。它被判定为**有效**。我们继续进行求解。\n\n求解过程需要为每个指定的 $p$ 值解决上述线性系统。\n\n设 $N = 2p+1$。我们必须求解大小为 $N$ 的向量 $\\mathbf{w} = [w_{-p}, \\dots, w_p]^T$。方程组为：\n$$\n\\begin{pmatrix}\n(-p)^0 & (-p+1)^0 & \\cdots & p^0 \\\\\n(-p)^1 & (-p+1)^1 & \\cdots & p^1 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n(-p)^{2p} & (-p+1)^{2p} & \\cdots & p^{2p}\n\\end{pmatrix}\n\\begin{pmatrix}\nw_{-p} \\\\\nw_{-p+1} \\\\\n\\vdots \\\\\nw_p\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n1 \\\\\n0 \\\\\n\\vdots \\\\\n0\n\\end{pmatrix}\n$$\n这个线性系统可以使用标准的数值线性代数库高效地求解。对于每个指定的整数 $p$，算法如下：\n1.  设置系统维度 $N = 2p+1$。\n2.  定义模板节点集合 $K = \\{k \\in \\mathbb{Z} \\mid -p \\le k \\le p \\}$。\n3.  构造 $N \\times N$ 的范德蒙矩阵 $A$，其元素为 $A_{r, k+p} = k^r$，其中 $r \\in \\{0, \\dots, 2p\\}$ 且 $k \\in K$。必须遵守 $0^0=1$ 的约定。\n4.  构造 $N$ 维右端向量 $\\mathbf{b}$，其中 $b_r = \\delta_{r,1}$，对于 $r \\in \\{0, \\dots, 2p\\}$。\n5.  求解线性系统 $A \\mathbf{w} = \\mathbf{b}$ 以得到系数向量 $\\mathbf{w}$。\n6.  所得向量 $\\mathbf{w}$ 的分量即为所需的系数 $[w_{-p}, w_{-p+1}, \\dots, w_p]$。\n\n此过程是确定性的，对于任何给定的 $p \\geq 1$，都将产生唯一的系数集。所提供的程序实现了这一确切逻辑。例如，对于 $p=1$，系统为：\n$$\n\\begin{pmatrix}\n1 & 1 & 1 \\\\\n-1 & 0 & 1 \\\\\n1 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\nw_{-1} \\\\\nw_{0} \\\\\nw_{1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n1 \\\\\n0\n\\end{pmatrix}\n$$\n该矩阵的行列式为 $2$，表明它是可逆的。解被正确地找到为 $\\mathbf{w} = [-0.5, 0, 0.5]^T$，这是标准二阶中心差分公式的系数。同样的原理也适用于更高的 $p$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the coefficients for centered finite difference approximations\n    of the first derivative for a given set of stencil widths.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 3, 4, 5]\n\n    results = []\n    for p in test_cases:\n        # The parameter 'p' defines a stencil of width 2p+1.\n        # The number of coefficients and equations is N = 2p+1.\n        N = 2 * p + 1\n        \n        # The stencil points k range from -p to p.\n        k_values = np.arange(-p, p + 1, dtype=float)\n        \n        # The powers r range from 0 to 2p.\n        r_values = np.arange(N, dtype=float).reshape(-1, 1)\n\n        # Construct the Vandermonde-like matrix A.\n        # A[r, j] = k_values[j]**r.\n        # numpy.power correctly handles 0**0 = 1.\n        A = np.power(k_values, r_values)\n        \n        # Construct the right-hand side vector b, where b_r = delta_{r,1}.\n        b = np.zeros(N)\n        b[1] = 1.0\n        \n        # Solve the linear system A*w = b for the coefficients w.\n        w = np.linalg.solve(A, b)\n        \n        results.append(w.tolist())\n\n    # Format the output as specified in the problem statement.\n    list_of_strings = []\n    for res_list in results:\n        # Format each coefficient to exactly 16 decimal places.\n        formatted_list = [f\"{x:.16f}\" for x in res_list]\n        list_of_strings.append(f\"[{','.join(formatted_list)}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(list_of_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "高阶格式的快速收敛性是以待求导函数足够光滑为前提的。当这个假设被违背时会发生什么？这项练习  通过将一个四阶格式应用于一个带有尖点的函数，来探索这一关键问题。这个实践测试揭示了数值方法在不连续点附近发生的“降阶”现象，并强调了理解数值方法局限性的重要性。",
            "id": "3227834",
            "problem": "您需要研究高阶有限差分近似在应用于具有不可微点的函数时的行为。基础出发点是足够光滑的函数在某点周围的泰勒级数展开。从以下定义开始：对于一个在点 $x$ 附近至少五次连续可微的函数 $f$，其值 $f(x \\pm h)$ 和 $f(x \\pm 2h)$ 允许在 $x$ 点进行泰勒级数展开。利用这些展开式，推导一个中心有限差分近似，该近似使用 $x - 2h$、$x - h$、$x + h$ 和 $x + 2h$ 处的值来近似 $f'(x)$，对于足够光滑的函数，其截断误差与 $h^4$ 成正比。\n\n推导出高阶方案后，请实现它并测试其在函数 $f(x) = |x - 0.5|$ 在区间 $[0,1]$ 上的性能。使用一个包含 $n$ 个点的均匀网格，因此网格间距为 $h = \\frac{1}{n - 1}$，网格点为 $x_i = i h$，其中 $i = 0, 1, \\dots, n - 1$。$f$ 的精确导数由 $f'(x) = -1$（对于 $x  0.5$）和 $f'(x) = +1$（对于 $x  0.5$）给出，在 $x = 0.5$ 处未定义。为确保科学真实性，将点 $x = 0.5$ 排除在任何误差度量之外，因为 $f'(0.5)$ 未定义。\n\n仅在内部点 $x_i$（其中 $i = 2, 3, \\dots, n - 3$）上定义导数近似，以确保四点中心模板能完全包含在区间内。将每个内部模板分类为“平滑区域”或“跨角点”，如下所示：\n- 以 $x_i$ 为中心的模板是“平滑区域”模板，如果 $x_{i-2}$ 和 $x_{i+2}$ 都严格位于 $0.5$ 的同一侧，即 $x_{i+2} \\le 0.5$ 或 $x_{i-2} \\ge 0.5$。\n- 以 $x_i$ 为中心的模板是“跨角点”模板，如果它跨越了角点，即 $x_{i-2}  0.5  x_{i+2}$。\n\n对于所提供的测试套件中的每个 $n$ 值，计算以下三个误差度量，表示为实数（浮点数）：\n- $E_{\\text{all}}$：在所有内部点 $x_i$ 上的最大绝对误差，不包括任何 $x_i = 0.5$ 的点。\n- $E_{\\text{smooth}}$：仅限于具有“平滑区域”模板的内部点上的最大绝对误差。\n- $E_{\\text{cross}}$：仅限于具有“跨角点”模板的内部点上的最大绝对误差。如果对于给定的 $n$，没有模板是跨角点的，则定义 $E_{\\text{cross}} = 0$。\n\n使用以下网格大小测试套件：\n- $n = 11$（粗网格，其中 $0.5$ 是一个网格点），\n- $n = 12$（粗网格，其中 $0.5$ 不是一个网格点），\n- $n = 101$（细网格，其中 $0.5$ 是一个网格点），\n- $n = 102$（细网格，其中 $0.5$ 不是一个网格点）。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例产生一个列表 $[E_{\\text{all}}, E_{\\text{smooth}}, E_{\\text{cross}}]$，整体输出是这些列表的列表，顺序与测试套件相同。例如，要求的输出格式为 $[[E_{\\text{all}}^{(11)}, E_{\\text{smooth}}^{(11)}, E_{\\text{cross}}^{(11)}],[E_{\\text{all}}^{(12)}, E_{\\text{smooth}}^{(12)}, E_{\\text{cross}}^{(12)}],[E_{\\text{all}}^{(101)}, E_{\\text{smooth}}^{(101)}, E_{\\text{cross}}^{(101)}],[E_{\\text{all}}^{(102)}, E_{\\text{smooth}}^{(102)}, E_{\\text{cross}}^{(102)}]]$。\n\n所有答案都是没有物理单位的纯数字，并且不涉及角度单位。",
            "solution": "用户提供的问题已经过验证，并被确定为一个有效的、适定的数值分析问题。它具有科学依据、自成体系且客观。理论推导和计算实现所需的所有信息都已提供。\n\n### 四阶中心差分公式的推导\n\n目标是使用五个点 $x-2h$、$x-h$、$x$、$x+h$ 和 $x+2h$ 推导一阶导数 $f'(x)$ 的有限差分近似。期望的近似应具有以下形式：\n$$\nf'(x) \\approx A f(x-2h) + B f(x-h) + C f(x) + D f(x+h) + E f(x+2h)\n$$\n为了达到高阶精度，我们利用足够光滑的函数 $f(x)$ 在点 $x$ 周围的泰勒级数展开。$f(x \\pm h)$ 和 $f(x \\pm 2h)$ 的展开式为：\n$$\nf(x+h) = f(x) + hf'(x) + \\frac{h^2}{2}f''(x) + \\frac{h^3}{6}f'''(x) + \\frac{h^4}{24}f^{(4)}(x) + \\frac{h^5}{120}f^{(5)}(x) + O(h^6)\n$$\n$$\nf(x-h) = f(x) - hf'(x) + \\frac{h^2}{2}f''(x) - \\frac{h^3}{6}f'''(x) + \\frac{h^4}{24}f^{(4)}(x) - \\frac{h^5}{120}f^{(5)}(x) + O(h^6)\n$$\n$$\nf(x+2h) = f(x) + 2hf'(x) + \\frac{4h^2}{2}f''(x) + \\frac{8h^3}{6}f'''(x) + \\frac{16h^4}{24}f^{(4)}(x) + \\frac{32h^5}{120}f^{(5)}(x) + O(h^6)\n$$\n$$\nf(x-2h) = f(x) - 2hf'(x) + \\frac{4h^2}{2}f''(x) - \\frac{8h^3}{6}f'''(x) + \\frac{16h^4}{24}f^{(4)}(x) - \\frac{32h^5}{120}f^{(5)}(x) + O(h^6)\n$$\n我们寻求 $f'(x)$ 的近似，它是一个关于位移 $h$ 的奇函数。因此，我们构造一个线性组合来分离奇数阶导数项。由于模板的中心性，我们期望该公式是反对称的，即 $C=0$，$B = -D$ 和 $A = -E$。该近似仅使用点 $x \\pm h$ 和 $x \\pm 2h$，而不使用点 $x$ 本身。这种中心差分的通用形式为：\n$$\nf'(x) \\approx \\frac{c_1(f(x+h) - f(x-h)) + c_2(f(x+2h) - f(x-2h))}{h}\n$$\n让我们从泰勒级数中计算这些差值：\n$$\nf(x+h) - f(x-h) = 2hf'(x) + \\frac{2h^3}{6}f'''(x) + \\frac{2h^5}{120}f^{(5)}(x) + O(h^7)\n$$\n$$\nf(x+2h) - f(x-2h) = 4hf'(x) + \\frac{16h^3}{6}f'''(x) + \\frac{64h^5}{120}f^{(5)}(x) + O(h^7)\n$$\n让我们将这些差值除以 $2h$ 后命名它们：\n$$\nD_1 = \\frac{f(x+h) - f(x-h)}{2h} = f'(x) + \\frac{h^2}{6}f'''(x) + \\frac{h^4}{120}f^{(5)}(x) + O(h^6)\n$$\n$$\nD_2 = \\frac{f(x+2h) - f(x-2h)}{4h} = f'(x) + \\frac{4h^2}{6}f'''(x) + \\frac{16h^4}{120}f^{(5)}(x) + O(h^6)\n$$\n$D_1$ 是二阶中心差分，$D_2$ 也是一个二阶中心差分，但步长为 $2h$。为了消去与 $h^2 f'''(x)$ 成正比的主误差项，我们可以构造 $D_1$ 和 $D_2$ 的线性组合。我们寻求系数 $\\alpha$ 和 $\\beta$，使得 $\\alpha D_1 + \\beta D_2$ 中的 $h^2$ 项被消去，同时 $\\alpha + \\beta = 1$ 以保留 $f'(x)$ 项。\n$$\n\\alpha \\left(\\frac{h^2}{6}\\right) + \\beta \\left(\\frac{4h^2}{6}\\right) = 0 \\implies \\alpha + 4\\beta = 0\n$$\n我们求解方程组：\n$$\n\\begin{cases} \\alpha + \\beta = 1 \\\\ \\alpha + 4\\beta = 0 \\end{cases}\n$$\n从第二个方程中减去第一个方程得到 $3\\beta = -1$，所以 $\\beta = -1/3$。然后 $\\alpha = 1 - \\beta = 1 - (-1/3) = 4/3$。\n改进后的近似是：\n$$\nf'(x) \\approx \\frac{4}{3}D_1 - \\frac{1}{3}D_2\n$$\n代入 $D_1$ 和 $D_2$ 的表达式：\n$$\nf'(x) \\approx \\frac{4}{3} \\frac{f(x+h) - f(x-h)}{2h} - \\frac{1}{3} \\frac{f(x+2h) - f(x-2h)}{4h}\n$$\n为了简化，我们找到一个公分母，即 $12h$：\n$$\nf'(x) \\approx \\frac{8(f(x+h) - f(x-h)) - (f(x+2h) - f(x-2h))}{12h}\n$$\n重新整理各项，得到最终公式：\n$$\nf'(x) \\approx \\frac{-f(x+2h) + 8f(x+h) - 8f(x-h) + f(x-2h)}{12h}\n$$\n截断误差可以通过将系数 $\\alpha = 4/3$ 和 $\\beta = -1/3$ 应用于 $D_1$ 和 $D_2$ 的 $h^4$ 项来找到：\n$$\n\\text{Error Term} = \\left(\\frac{4}{3}\\right) \\frac{h^4}{120}f^{(5)}(x) - \\left(\\frac{1}{3}\\right) \\frac{16h^4}{120}f^{(5)}(x) = \\frac{h^4}{120} \\left(\\frac{4}{3} - \\frac{16}{3}\\right) f^{(5)}(x) = \\frac{h^4}{120} \\left(\\frac{-12}{3}\\right) f^{(5)}(x) = \\frac{-4h^4}{120}f^{(5)}(x) = -\\frac{h^4}{30}f^{(5)}(x)\n$$\n该符号与近似误差的符号相反，因此截断误差为 $f'(x) - f'_{\\text{approx}} = \\frac{h^4}{30}f^{(5)}(x) + O(h^6)$。精度阶为 $O(h^4)$，符合要求。\n\n### 实现与分析\n\n所推导的公式被实现用于计算函数 $f(x) = |x - 0.5|$ 在 $[0,1]$ 上的导数。对于测试套件中的每个网格大小 $n$，执行以下步骤：\n1. 构建一个有 $n$ 个点的均匀网格，其中 $h = 1/(n-1)$，$x_i = ih$ (对于 $i=0, \\dots, n-1$)。\n2. 计算所有网格点上的函数值 $f(x_i)$ 及其精确导数 $f'(x_i) = \\text{sign}(x_i - 0.5)$。注意，在 $x_i = 0.5$ 处，精确导数未定义。\n3. 使用推导的公式计算所有内部点 $x_i$（其中 $i \\in [2, n-3]$）处的近似导数。\n4. 对于每个这样的点 $x_i$，如果 $x_i \\neq 0.5$，则计算近似导数与精确导数之间的绝对误差。\n5. 将以 $x_i$ 为中心的模板分类为“平滑区域”（如果 $x_{i+2} \\le 0.5$ 或 $x_{i-2} \\ge 0.5$）或“跨角点”（如果 $x_{i-2}  0.5  x_{i+2}$）。\n6. 收集三组误差：来自所有有效模板的误差、来自平滑区域模板的误差，以及来自跨角点模板的误差。\n7. 对每组误差计算最大绝对误差（$E_{\\text{all}}$, $E_{\\text{smooth}}$, $E_{\\text{cross}}$）。如果某一组为空，则其最大误差定义为 $0$。\n\n对测试套件 $\\{11, 12, 101, 102\\}$ 中的每个 $n$ 重复此过程。函数 $f(x)$ 是分段线性的，因此在任何不包含角点 $x=0.5$ 的区域内，其五阶导数均为零。因此，对于“平滑区域”模板， $O(h^4)$ 误差项消失，预计近似值在浮点精度范围内是精确的。对于“跨角点”模板，光滑性假设被违反，导致一个大的 $O(1)$ 误差，该误差不会随着 $h \\to 0$ 而减小。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and tests a high-order finite difference scheme on a function with a corner.\n    \"\"\"\n    # The problem specifies a test suite of grid sizes n.\n    test_cases = [11, 12, 101, 102]\n    \n    all_results = []\n\n    for n in test_cases:\n        # 1. Set up grid, function, and exact derivative\n        h = 1.0 / (n - 1)\n        x = np.linspace(0.0, 1.0, n)\n        \n        # Function f(x) = |x - 0.5|\n        f_x = np.abs(x - 0.5)\n        \n        # Exact derivative f'(x) = sign(x - 0.5)\n        # f'(x) = -1 for x  0.5, +1 for x > 0.5, undefined at x = 0.5\n        f_prime_exact = np.sign(x - 0.5)\n        \n        # Lists to store errors for different stencil types\n        errors_all = []\n        errors_smooth = []\n        errors_cross = []\n        \n        # 2. Loop over interior points where the 5-point stencil is valid\n        # The stencil at i uses points from i-2 to i+2.\n        # It's centered at x_i and defined for i from 2 to n-3.\n        # Python's range(start, stop) goes up to stop-1.\n        for i in range(2, n-2):\n            # Check edge case if i+2 is out of bounds due to loop definition\n            if i + 2 >= n:\n                continue\n\n            # The point where the derivative is being approximated\n            x_i = x[i]\n            \n            # Exclude the point x = 0.5 from any error metric, as f'(0.5) is undefined.\n            if np.isclose(x_i, 0.5):\n                continue\n                \n            # 3. Apply the fourth-order central difference formula\n            # f'(x) ≈ (-f(x+2h) + 8f(x+h) - 8f(x-h) + f(x-2h)) / (12h)\n            f_prime_approx = (\n                -f_x[i+2] + 8 * f_x[i+1] - 8 * f_x[i-1] + f_x[i-2]\n            ) / (12.0 * h)\n            \n            # 4. Calculate error\n            error = np.abs(f_prime_approx - f_prime_exact[i])\n            errors_all.append(error)\n            \n            # 5. Classify the stencil and categorize the error\n            x_stencil_min = x[i-2]\n            x_stencil_max = x[i+2]\n            \n            # Smooth-region stencil: entirely on one side of 0.5\n            if x_stencil_max = 0.5 or x_stencil_min >= 0.5:\n                errors_smooth.append(error)\n            # Corner-crossing stencil: straddles 0.5\n            elif x_stencil_min  0.5 and x_stencil_max > 0.5:\n                errors_cross.append(error)\n            # The classification is exhaustive for this problem's setup.\n\n        # 6. Compute the required error metrics (maximums)\n        # If a list is empty, the max error is 0.\n        E_all = max(errors_all) if errors_all else 0.0\n        E_smooth = max(errors_smooth) if errors_smooth else 0.0\n        E_cross = max(errors_cross) if errors_cross else 0.0\n        \n        all_results.append([E_all, E_smooth, E_cross])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists of floats.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在实际应用中，空间导数的计算往往是求解瞬态偏微分方程的一部分。这项实践  将高阶空间离散格式与整个模拟的稳定性联系起来。通过分析扩散方程离散化矩阵的特征值，我们可以确定显式时间积分格式所允许的最大稳定时间步长 $\\Delta t_{\\max}$，这是任何瞬态模拟中的一个关键考量因素。",
            "id": "2401265",
            "problem": "考虑在一维空间域 $[0,L)$ 上具有周期性边界条件的一维线性扩散方程，其空间离散化系统由下式给出：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\mathbf{u}(t) = A\\,\\mathbf{u}(t),\n$$\n其中 $A = \\kappa D^{(2)}$ 且 $D^{(2)}\\in\\mathbb{R}^{N\\times N}$ 是二阶导数算子 $\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}$ 在一个包含 $N$ 个点、网格间距为 $h=L/N$ 的均匀网格上的四阶精度、中心、周期性有限差分近似的矩阵表示。网格点位于 $x_j = jh$，$j=0,1,\\dots,N-1$，并且周期性边界条件将 $x_0$ 与 $x_N$ 等同。显式前向欧拉时间离散化定义为\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^{n} + \\Delta t \\, A\\, \\mathbf{u}^{n}.\n$$\n将最大稳定时间步长 $\\Delta t_{\\max}$ 定义为所有满足以下条件的 $\\Delta t  0$ 的上确界：对于 $A$ 的每个特征值 $\\lambda$，其放大因子满足 $\\left|1+\\Delta t\\,\\lambda\\right|\\le 1$。\n\n你的任务是：\n- 构建 $D^{(2)}$，作为在上述均匀周期网格上近似 $\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}$ 的四阶精度、中心、周期性有限差分矩阵。\n- 计算 $A=\\kappa D^{(2)}$ 的所有特征值。\n- 使用 $A$ 的特征值和上述定义，确定显式前向欧拉方法的 $\\Delta t_{\\max}$。\n\n测试套件和要求输出：\n使用以下参数集 $(L,N,\\kappa)$，每个集合定义一个独立的测试用例：\n- 测试用例 1：$(L,N,\\kappa)=\\left(1,\\,64,\\,1\\right)$。\n- 测试用例 2：$(L,N,\\kappa)=\\left(2,\\,32,\\,\\frac{1}{2}\\right)$。\n- 测试用例 3：$(L,N,\\kappa)=\\left(1,\\,5,\\,1\\right)$。\n- 测试用例 4：$(L,N,\\kappa)=\\left(\\pi,\\,100,\\,2\\right)$，其中 $\\pi$ 是圆周率。\n\n对于每个测试用例，计算 $\\Delta t_{\\max}$ 并将其表示为精确到小数点后 $10$ 位的不带单位的小数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含按上述顺序列出的四个测试用例的结果，格式为方括号内以逗号分隔的列表，例如 $\\left[\\Delta t_{\\max}^{(1)},\\Delta t_{\\max}^{(2)},\\Delta t_{\\max}^{(3)},\\Delta t_{\\max}^{(4)}\\right]$，每个条目都精确到小数点后 $10$ 位，并以标准十进制表示法打印。",
            "solution": "对问题陈述进行验证。\n\n逐字提取给定条件：\n- 常微分方程组为 $\\frac{\\mathrm{d}}{\\mathrm{d}t}\\mathbf{u}(t) = A\\,\\mathbf{u}(t)$。\n- 矩阵 $A$ 定义为 $A = \\kappa D^{(2)}$。\n- $D^{(2)}$ 是 $\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}$ 的四阶精度、中心、周期性有限差分近似的矩阵表示。\n- 域为 $[0,L)$，具有周期性边界条件。\n- 网格是均匀的，有 $N$ 个点 $x_j = jh$，$j=0,1,\\dots,N-1$。\n- 网格间距为 $h=L/N$。\n- 时间离散化是显式前向欧拉方法：$\\mathbf{u}^{n+1} = \\mathbf{u}^{n} + \\Delta t \\, A\\, \\mathbf{u}^{n}$。\n- 最大稳定时间步长定义为 $\\Delta t_{\\max} = \\sup\\{\\Delta t  0 \\mid |1+\\Delta t\\,\\lambda|\\le 1 \\text{ 对 } A \\text{ 的所有特征值 } \\lambda \\text{ 成立}\\}$。\n- 测试用例 $(L,N,\\kappa)$:\n  - 用例 1: $(1,\\,64,\\,1)$\n  - 用例 2: $(2,\\,32,\\,1/2)$\n  - 用例 3: $(1,\\,5,\\,1)$\n  - 用例 4: $(\\pi,\\,100,\\,2)$\n\n根据指定标准对问题进行验证。\n- **科学依据**：该问题基于数值分析和计算物理的核心原理，特别是使用有限差分法求解偏微分方程以及时间积分格式的稳定性分析。所有概念都是标准且公认的。\n- **适定性**：问题定义明确。它要求基于一套完整的参数和定义，计算一个特定的、可计算的量 $\\Delta t_{\\max}$。每个测试用例都存在唯一解。\n- **客观性**：问题以精确的数学语言陈述，没有任何主观性或模糊性。\n\n结论是该问题**有效**。将提供解答。\n\n解答过程分为四个阶段：\n1.  构建四阶有限差分算子矩阵 $D^{(2)}$。\n2.  确定系统矩阵 $A = \\kappa D^{(2)}$ 的特征值。\n3.  对前向欧拉方法进行稳定性分析，以推导 $\\Delta t_{\\max}$ 的表达式。\n4.  将推导出的公式应用于指定的测试用例。\n\n在网格点 $x_j$ 处，二阶导数 $\\frac{\\mathrm{d}^2 u}{\\mathrm{d} x^2}$ 的一个四阶精度中心有限差分近似由以下五点格式给出：\n$$\n\\frac{\\mathrm{d}^2 u}{\\mathrm{d} x^2}\\bigg|_{x_j} \\approx \\frac{1}{h^2} \\left( -\\frac{1}{12}u_{j-2} + \\frac{4}{3}u_{j-1} - \\frac{5}{2}u_j + \\frac{4}{3}u_{j+1} - \\frac{1}{12}u_{j+2} \\right)\n$$\n其中 $u_j = u(x_j)$，$h$ 是均匀网格间距。对于一个有 $N$ 个点的周期域，下标按模 $N$ 解释。这种结构产生一个循环矩阵 $D^{(2)} \\in \\mathbb{R}^{N\\times N}$。循环矩阵由其第一行定义。矩阵 $h^2 D^{(2)}$ 的第一行是 $(c_0, c_1, c_2, 0, \\dots, 0, c_2, c_1)$，其中系数为 $c_0 = -5/2$，$c_1 = 4/3$ 和 $c_2 = -1/12$。\n\n一个第一行为 $(r_0, r_1, \\dots, r_{N-1})$ 的 $N \\times N$ 循环矩阵的特征值由公式 $\\nu_k = \\sum_{j=0}^{N-1} r_j e^{-i 2\\pi kj/N}$ 给出，$k=0, 1, \\dots, N-1$。对于我们的矩阵 $h^2 D^{(2)}$，第一行中的非零元素位于下标 $j=0, 1, 2, N-2, N-1$ 处。其特征值记为 $\\mu_k$，为：\n$$\n\\mu_k = c_0 + c_1 e^{-i\\theta_k} + c_2 e^{-i2\\theta_k} + c_2 e^{-i(N-2)\\theta_k/N \\cdot N/ (2\\pi)} ...\n$$\n这应该是：\n$\\nu_k = \\sum_{j=0}^{N-1} r_j \\omega^{kj}$ 其中 $\\omega_k=e^{2\\pi i/N}$。$h^2 D^{(2)}$ 的第一行是 $(c_0, c_1, c_2, 0, \\dots, 0, c_2, c_1)$。\n$$\n\\mu_k = c_0 e^{i 2\\pi k(0)/N} + c_1 e^{i 2\\pi k(1)/N} + c_2 e^{i 2\\pi k(2)/N} + \\dots + c_2 e^{i 2\\pi k(N-2)/N} + c_1 e^{i 2\\pi k(N-1)/N}\n$$\n使用 $e^{i 2\\pi k(N-j)/N} = e^{i 2\\pi k} e^{-i 2\\pi kj/N} = e^{-i 2\\pi kj/N}$ 并令 $\\theta_k = 2\\pi k/N$，我们得到：\n$$\n\\mu_k = c_0 + c_1(e^{i\\theta_k} + e^{-i\\theta_k}) + c_2(e^{i2\\theta_k} + e^{-i2\\theta_k}) = c_0 + 2c_1\\cos(\\theta_k) + 2c_2\\cos(2\\theta_k)\n$$\n代入系数 $c_0 = -5/2$, $c_1 = 4/3$, $c_2 = -1/12$ 并使用恒等式 $\\cos(2\\theta) = 2\\cos^2(\\theta) - 1$：\n$$\n\\mu_k = -\\frac{5}{2} + \\frac{8}{3}\\cos(\\theta_k) - \\frac{1}{6}\\cos(2\\theta_k) = -\\frac{5}{2} + \\frac{8}{3}\\cos(\\theta_k) - \\frac{1}{6}(2\\cos^2(\\theta_k) - 1) = -\\frac{1}{3}\\cos^2(\\theta_k) + \\frac{8}{3}\\cos(\\theta_k) - \\frac{7}{3}\n$$\n$D^{(2)}$ 的特征值为 $\\lambda_{D^{(2)},k} = \\mu_k / h^2$，$A = \\kappa D^{(2)}$ 的特征值为 $\\lambda_k = \\kappa \\mu_k / h^2$。所有的 $\\lambda_k$ 都是实数且非正的，这符合扩散算子的要求。\n\n前向欧拉格式的稳定性要求对所有特征值 $\\lambda_k$ 都有 $|1 + \\Delta t \\lambda_k| \\le 1$。由于 $\\lambda_k \\in \\mathbb{R}$ 且 $\\lambda_k \\le 0$，此条件等价于 $-1 \\le 1 + \\Delta t \\lambda_k \\le 1$。对于 $\\Delta t  0$，右侧不等式恒成立。左侧不等式给出 $\\Delta t \\lambda_k \\ge -2$，这意味着 $\\Delta t \\le -2/\\lambda_k$（由于 $\\lambda_k  0$，不等号反向）。为了对所有 $k$ 满足此条件，我们必须有：\n$$\n\\Delta t \\le \\min_{k, \\lambda_k \\ne 0} \\left( \\frac{-2}{\\lambda_k} \\right) = \\frac{-2}{\\max_{k, \\lambda_k \\ne 0} |\\lambda_k|} = \\frac{-2}{\\lambda_{\\min}}\n$$\n其中 $\\lambda_{\\min}$ 是 $A$ 的最小（最负）的特征值。因此，$\\Delta t_{\\max} = -2 / \\lambda_{\\min}$。\n\n最小特征值 $\\lambda_{\\min}$ 对应于 $\\mu_k$ 的最小值。令 $c = \\cos(\\theta_k)$。函数 $f(c) = -\\frac{1}{3}c^2 + \\frac{8}{3}c - \\frac{7}{3}$ 的顶点在 $c = -(\\frac{8}{3}) / (2(-\\frac{1}{3})) = 4$，这在 $c \\in [-1, 1]$ 范围之外。在区间 $[-1, 1]$ 上，$f(c)$ 是单调递增的。因此，当 $\\cos(\\theta_k)$ 最小时，$\\mu_k$ 达到最小值。$k$ 的范围是 $0, 1, \\dots, N-1$。$\\cos(2\\pi k/N)$ 的最小值出现在 $k_{\\text{ext}} = \\lfloor N/2 \\rfloor$。\n因此，$h^2 D^{(2)}$ 的最负特征值是：\n$$\n\\mu_{\\min} = \\mu_{k_{\\text{ext}}} = \\frac{1}{3}\\left( -\\cos^2(\\theta_{\\text{ext}}) + 8\\cos(\\theta_{\\text{ext}}) - 7 \\right), \\quad \\text{where} \\quad \\theta_{\\text{ext}} = \\frac{2\\pi \\lfloor N/2 \\rfloor}{N}\n$$\n$A$ 的最小特征值是 $\\lambda_{\\min} = \\kappa \\mu_{\\min} / h^2$。最大稳定时间步长是：\n$$\n\\Delta t_{\\max} = \\frac{-2}{\\lambda_{\\min}} = \\frac{-2h^2}{\\kappa \\mu_{\\min}} = \\frac{-6h^2}{\\kappa \\left( -\\cos^2(\\theta_{\\text{ext}}) + 8\\cos(\\theta_{\\text{ext}}) - 7 \\right)}\n$$\n对于偶数 $N$ 会出现一个特殊情况。此时，$k_{\\text{ext}} = N/2$，因此 $\\theta_{\\text{ext}} = \\pi$ 且 $\\cos(\\theta_{\\text{ext}}) = -1$。括号中的项变为 $-(-1)^2 + 8(-1) - 7 = -1 - 8 - 7 = -16$。\n对于偶数 $N$，公式简化为：\n$$\n\\Delta t_{\\max} = \\frac{-6h^2}{\\kappa(-16)} = \\frac{3h^2}{8\\kappa} = \\frac{3(L/N)^2}{8\\kappa} = \\frac{3L^2}{8\\kappa N^2}\n$$\n\n每个测试用例的计算如下：\n\n- **测试用例 1**：$(L,N,\\kappa)=(1,64,1)$。$N=64$ 是偶数。\n  $\\Delta t_{\\max} = \\frac{3(1)^2}{8(1)(64)^2} = \\frac{3}{32768} = 0.000091552734375$。\n  四舍五入到小数点后 10 位：$0.0000915527$。\n\n- **测试用例 2**：$(L,N,\\kappa)=(2,32,1/2)$。$N=32$ 是偶数。\n  $\\Delta t_{\\max} = \\frac{3(2)^2}{8(1/2)(32)^2} = \\frac{12}{4(1024)} = \\frac{3}{1024} = 0.0029296875$。\n  四舍五入到小数点后 10 位：$0.0029296875$。\n\n- **测试用例 3**：$(L,N,\\kappa)=(1,5,1)$。$N=5$ 是奇数。\n  $h = 1/5$。$k_{\\text{ext}} = \\lfloor 5/2 \\rfloor = 2$。\n  $\\theta_{\\text{ext}} = 2\\pi(2)/5 = 4\\pi/5$。\n  令 $c = \\cos(4\\pi/5)$。$\\mu_{\\min} = \\frac{1}{3}(-c^2 + 8c - 7)$。\n  $\\Delta t_{\\max} = \\frac{-2(1/5)^2}{(1) \\cdot \\mu_{\\min}} = \\frac{-2/25}{\\mu_{\\min}} = \\frac{-6}{25(-c^2 + 8c - 7)}$。\n  数值上，$c \\approx -0.8090169944$，$\\mu_{\\min} \\approx -4.708881224$。\n  $\\Delta t_{\\max} \\approx \\frac{-0.08}{-4.708881224} \\approx 0.016989437820$。\n  四舍五入到小数点后 10 位：$0.0169894378$。\n\n- **测试用例 4**：$(L,N,\\kappa)=(\\pi,100,2)$。$N=100$ 是偶数。\n  $\\Delta t_{\\max} = \\frac{3(\\pi)^2}{8(2)(100)^2} = \\frac{3\\pi^2}{160000}$。\n  使用 $\\pi \\approx 3.141592653589793$，$\\Delta t_{\\max} \\approx \\frac{3(9.8696044011)}{160000} \\approx 0.000185055146$。\n  四舍五入到小数点后 10 位：$0.0001850551$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the largest stable time step for the forward Euler method\n    applied to the 1D diffusion equation with a fourth-order finite difference\n    spatial discretization on a periodic domain.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 64, 1.0),\n        (2.0, 32, 0.5),\n        (1.0, 5, 1.0),\n        (np.pi, 100, 2.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, kappa = case\n        h = L / N\n\n        # The stability limit depends on whether N is even or odd.\n        if N % 2 == 0:\n            # For even N, the Nyquist mode k=N/2 exists, and cos(2*pi*k/N) = -1.\n            # This leads to a simplified formula for dt_max.\n            # dt_max = (3 * h**2) / (8 * kappa)\n            dt_max = (3 * L**2) / (8 * kappa * N**2)\n        else:\n            # For odd N, the most negative eigenvalue corresponds to k = floor(N/2).\n            # We must use the general formula.\n            k_ext = np.floor(N / 2)\n            theta_ext = 2 * np.pi * k_ext / N\n            cos_theta = np.cos(theta_ext)\n            \n            # The minimum eigenvalue of the scaled (h^2 * D^(2)) operator.\n            # This is derived from the symbol of the FD scheme.\n            mu_min = (1/3) * (-cos_theta**2 + 8 * cos_theta - 7)\n            \n            # The minimum eigenvalue of the system matrix A = kappa * D^(2).\n            lambda_min = kappa * mu_min / h**2\n            \n            # The stability limit is dt_max = -2 / lambda_min.\n            dt_max = -2.0 / lambda_min\n\n        results.append(f\"{dt_max:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}