{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any computational study is the translation of discrete equations into a functional algorithm. This first practice challenges you to construct the core engine of a 3D acoustic solver from the ground up. By focusing on the explicit array indexing for the leapfrog update on a staggered grid, you will tackle the crucial details of managing data structures, navigating ghost layers for boundary conditions, and ensuring the spatial and temporal staggering is correctly implemented. This exercise builds the fundamental programming skills necessary for developing robust finite-difference time-domain codes.",
            "id": "4138270",
            "problem": "You are asked to construct and implement a three-dimensional staggered-grid explicit time-marching scheme for linear acoustics using a leapfrog update with ghost layers that enforce physically consistent boundary conditions. Start from a fundamental base and derive the discrete updates and explicit array index ranges. Then implement the derived indexing in a complete, runnable program that performs a single pair of updates on a small set of prescribed test cases, and outputs quantifiable results as specified.\n\nFundamental base for linear acoustics:\n- The linearized momentum equation: $$\\frac{\\partial \\mathbf{u}}{\\partial t} = -\\frac{1}{\\rho}\\nabla p,$$ where $p$ is acoustic pressure, $\\mathbf{u} = (u_x,u_y,u_z)$ is acoustic particle velocity, and $\\rho$ is mass density.\n- The linearized continuity equation: $$\\frac{\\partial p}{\\partial t} = -K \\nabla\\cdot \\mathbf{u},$$ where $K$ is bulk modulus and $\\nabla\\cdot \\mathbf{u}$ is the divergence of velocity.\n\nStaggered-grid arrangement:\n- Pressure $p$ is stored at cell centers indexed by $(i,j,k)$.\n- Velocities are stored on faces:\n  - $u_x$ on faces normal to $x$ at indices $(i+\\tfrac{1}{2},j,k)$,\n  - $u_y$ on faces normal to $y$ at indices $(i,j+\\tfrac{1}{2},k)$,\n  - $u_z$ on faces normal to $z$ at indices $(i,j,k+\\tfrac{1}{2})$.\n- Uniform spacings $dx$, $dy$, $dz$ along $x$, $y$, $z$.\n\nTime staggering:\n- Pressure $p$ is evaluated at integer times $t^n$.\n- Velocity components are evaluated at half-integer times $t^{n\\pm 1/2}$.\n- The leapfrog updates are to be implemented as:\n  1. Update $\\mathbf{u}^{n+1/2}$ from $p^n$.\n  2. Update $p^{n+1}$ from $\\mathbf{u}^{n+1/2}$.\n\nGhost layers and boundary handling:\n- Use one ghost layer on every array dimension surrounding the interior domain for pressure and velocities. The ghost layers on $p$ must enforce homogeneous Neumann boundary conditions (zero normal derivative), i.e., copy interior values into ghost cells along each boundary so that the discrete normal gradient at boundaries is zero.\n- The ghost layers for velocity arrays should be allocated to support indexing and divergence operations; the normal velocity at physical boundaries must remain zero after the velocity update as a consequence of the Neumann boundary on pressure.\n\nDiscretization requirements:\n- Derive from the fundamental base the second-order centered, uniform-grid finite difference approximations for the gradient and divergence consistent with the staggered layout and time staggering. Carefully write the explicit index ranges for each velocity component and for pressure so that updates use only valid interior and ghost values.\n- Denote interior pressure indices as $i \\in \\{1,\\dots,N_x\\}$, $j \\in \\{1,\\dots,N_y\\}$, $k \\in \\{1,\\dots,N_z\\}$ for an interior grid of $N_x \\times N_y \\times N_z$ cells. Pressure arrays must include ghost layers at indices $i=0$ and $i=N_x+1$, $j=0$ and $j=N_y+1$, $k=0$ and $k=N_z+1$ to enforce the Neumann conditions.\n- Denote velocity face-index ranges consistent with the staggered positions and ghost layers so that differences align with pressure indices for divergence.\n\nProgram requirements:\n- Implement functions that:\n  1. Construct arrays for $p$, $u_x$, $u_y$, $u_z$ with ghost layers.\n  2. Initialize $p^n$ with a single-cell delta of amplitude $1$ at the interior center cell, and initialize $\\mathbf{u}^{n-1/2}$ to zero everywhere.\n  3. Fill pressure ghost layers to enforce homogeneous Neumann boundary conditions by copying adjacent interior cell values to the ghost cells.\n  4. Update $\\mathbf{u}^{n+1/2}$ from $p^n$ using the explicit staggered centered differences.\n  5. Update $p^{n+1}$ from $\\mathbf{u}^{n+1/2}$ using the explicit divergence centered differences.\n- Use $dt$ chosen for numerical stability as $$dt = \\frac{1}{2}\\frac{\\min(dx,dy,dz)}{c},\\quad c=\\sqrt{\\frac{K}{\\rho}},$$ where $c$ is the speed of sound. This value is to be computed per test case.\n- Ensure all array updates use explicit indexing that honors ghost layers and does not access out-of-range indices.\n\nTest suite:\nFor each test case, construct arrays, perform one velocity update and one pressure update, and then compute the following three quantities:\n\n1. The maximum absolute boundary-normal velocity magnitude after the velocity update (in meters per second). This is the maximum over all physical boundary faces of $|u_x|$ at $i=0$ and $i=N_x$, $|u_y|$ at $j=0$ and $j=N_y$, and $|u_z|$ at $k=0$ and $k=N_z$.\n2. The integer count of interior face locations used in the pressure divergence where the magnitude of the updated velocity exceeds a tolerance of $10^{-14}$.\n3. The sum of the interior pressure values after the pressure update (in Pascals).\n\nTest cases to implement:\n- Case A: $N_x=1$, $N_y=1$, $N_z=1$, $dx=0.1$, $dy=0.1$, $dz=0.1$, $\\rho=1.2$, $K=1.4\\times 10^5$.\n- Case B: $N_x=3$, $N_y=2$, $N_z=1$, $dx=0.05$, $dy=0.1$, $dz=0.2$, $\\rho=1.2$, $K=1.01\\times 10^5$.\n- Case C: $N_x=4$, $N_y=3$, $N_z=2$, $dx=0.02$, $dy=0.03$, $dz=0.04$, $\\rho=1.2$, $K=1.5\\times 10^5$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For the three test cases, aggregate the nine values in the order: boundary-normal velocity magnitude (in m/s), nonzero interior velocity count (integer), interior pressure sum (in Pa) for Case A, then the same triple for Case B, then Case C. For example: \"[vA,countA,sumA,vB,countB,sumB,vC,countC,sumC]\". All angles, if any, must be in radians, but no angles are used here. Ensure the units for velocities are meters per second and the units for pressure sums are Pascals. The counts are integers without units.",
            "solution": "The problem requires the derivation and implementation of a three-dimensional staggered-grid finite-difference time-domain (FDTD) scheme for the linearized acoustic equations. The solution will first be derived from fundamental principles, followed by an implementation that numerically solves the specified test cases.\n\n### 1. Problem Validation\nThe provided problem statement is a well-posed, scientifically grounded task in computational acoustics.\n- **Givens**:\n    - Momentum Equation: $\\frac{\\partial \\mathbf{u}}{\\partial t} = -\\frac{1}{\\rho}\\nabla p$\n    - Continuity Equation: $\\frac{\\partial p}{\\partial t} = -K \\nabla\\cdot \\mathbf{u}$\n    - Variables: acoustic pressure $p$, particle velocity $\\mathbf{u}=(u_x, u_y, u_z)$, mass density $\\rho$, bulk modulus $K$.\n    - Grid: Staggered, with $p$ at cell centers $(i,j,k)$, $u_x$ at $(i+\\tfrac{1}{2},j,k)$, $u_y$ at $(i,j+\\tfrac{1}{2},k)$, $u_z$ at $(i,j,k+\\tfrac{1}{2})$. Grid spacings are $dx, dy, dz$.\n    - Time Stepping: Leapfrog scheme, with $p$ at integer times $t^n$ and $\\mathbf{u}$ at half-integer times $t^{n \\pm 1/2}$.\n    - Boundary Conditions: Homogeneous Neumann for pressure $p$ ($\\frac{\\partial p}{\\partial n}=0$) enforced using one ghost layer.\n    - Domain: Interior grid of $N_x \\times N_y \\times N_z$ cells, with pressure indices $i \\in \\{1,\\dots,N_x\\}$, $j \\in \\{1,\\dots,N_y\\}$, $k \\in \\{1,\\dots,N_z\\}$.\n    - Initial Conditions: $p^n$ has a single-cell delta of amplitude $1$ at the interior center; $\\mathbf{u}^{n-1/2} = \\mathbf{0}$.\n    - Time Step: $dt = \\frac{1}{2}\\frac{\\min(dx,dy,dz)}{c}$, with $c=\\sqrt{K/\\rho}$.\n    - Test Cases and Output Requirements are specified.\n\n- **Validation**: The problem is valid. It is based on the fundamental equations of linear acoustics and employs a standard, stable numerical method (staggered-grid FDTD). The setup is self-contained, with all necessary parameters and conditions provided. It does not violate any scientific principles and is objective and formalizable.\n\n### 2. Derivation of the Discrete Scheme\n\n#### 2.1. Time Discretization (Leapfrog)\nThe leapfrog scheme involves evaluating pressure and velocity at staggered time steps. The time derivatives are approximated by second-order centered finite differences:\n\n- For the velocity update from $t^{n-1/2}$ to $t^{n+1/2}$, centered at $t^n$:\n$$ \\frac{\\mathbf{u}^{n+1/2} - \\mathbf{u}^{n-1/2}}{\\Delta t} = -\\frac{1}{\\rho} (\\nabla p)^n $$\n- For the pressure update from $t^n$ to $t^{n+1}$, centered at $t^{n+1/2}$:\n$$ \\frac{p^{n+1} - p^n}{\\Delta t} = -K (\\nabla \\cdot \\mathbf{u})^{n+1/2} $$\n\nThese lead to the following update rules:\n$$ \\mathbf{u}^{n+1/2} = \\mathbf{u}^{n-1/2} - \\frac{\\Delta t}{\\rho} (\\nabla p)^n $$\n$$ p^{n+1} = p^n - K \\Delta t (\\nabla \\cdot \\mathbf{u})^{n+1/2} $$\n\n#### 2.2. Spatial Discretization (Staggered Grid)\nThe spatial derivatives (gradient $\\nabla$ and divergence $\\nabla \\cdot$) are also approximated by second-order centered finite differences, evaluated at the appropriate staggered locations.\n\n- **Velocity Update (Gradient of Pressure)**: The gradient of pressure, $\\nabla p$, is needed at the locations of the velocity components.\n    - For $u_x$ at $(i+\\tfrac{1}{2},j,k)$, the partial derivative $\\frac{\\partial p}{\\partial x}$ is approximated using pressure values at adjacent cell centers $(i,j,k)$ and $(i+1,j,k)$:\n    $$ \\left. \\frac{\\partial p}{\\partial x} \\right|_{(i+1/2,j,k)} \\approx \\frac{p(i+1,j,k) - p(i,j,k)}{dx} $$\n    The update for the $x$-component of velocity is:\n    $$ u_x^{n+1/2}(i+\\tfrac{1}{2},j,k) = u_x^{n-1/2}(i+\\tfrac{1}{2},j,k) - \\frac{\\Delta t}{\\rho \\, dx} \\left( p^n(i+1,j,k) - p^n(i,j,k) \\right) $$\n    By analogy, the updates for $u_y$ and $u_z$ are:\n    $$ u_y^{n+1/2}(i,j+\\tfrac{1}{2},k) = u_y^{n-1/2}(i,j+\\tfrac{1}{2},k) - \\frac{\\Delta t}{\\rho \\, dy} \\left( p^n(i,j+1,k) - p^n(i,j,k) \\right) $$\n    $$ u_z^{n+1/2}(i,j,k+\\tfrac{1}{2}) = u_z^{n-1/2}(i,j,k+\\tfrac{1}{2}) - \\frac{\\Delta t}{\\rho \\, dz} \\left( p^n(i,j,k+1) - p^n(i,j,k) \\right) $$\n\n- **Pressure Update (Divergence of Velocity)**: The divergence of velocity, $\\nabla \\cdot \\mathbf{u}$, is needed at the pressure locations (cell centers, $(i,j,k)$).\n    $$ \\nabla \\cdot \\mathbf{u} = \\frac{\\partial u_x}{\\partial x} + \\frac{\\partial u_y}{\\partial y} + \\frac{\\partial u_z}{\\partial z} $$\n    Each term is approximated by a centered difference:\n    $$ \\left. \\frac{\\partial u_x}{\\partial x} \\right|_{(i,j,k)} \\approx \\frac{u_x(i+\\tfrac{1}{2},j,k) - u_x(i-\\tfrac{1}{2},j,k)}{dx} $$\n    $$ \\left. \\frac{\\partial u_y}{\\partial y} \\right|_{(i,j,k)} \\approx \\frac{u_y(i,j+\\tfrac{1}{2},k) - u_y(i,j-\\tfrac{1}{2},k)}{dy} $$\n    $$ \\left. \\frac{\\partial u_z}{\\partial z} \\right|_{(i,j,k)} \\approx \\frac{u_z(i,j,k+\\tfrac{1}{2}) - u_z(i,j,k-\\tfrac{1}{2})}{dz} $$\n    The pressure update is thus:\n    $$ p^{n+1}(i,j,k) = p^n(i,j,k) - K \\Delta t \\left( \\frac{u_x^{n+1/2}(i+\\tfrac{1}{2},j,k) - u_x^{n+1/2}(i-\\tfrac{1}{2},j,k)}{dx} + \\dots \\right) $$\n\n#### 2.3. Array Indexing and Ghost Layers\nWe use NumPy arrays and map the grid indices to array indices. A single ghost layer is added to each dimension.\n- `p` array: size $(N_x+2, N_y+2, N_z+2)$. Interior indices are `1..Nx`, `1..Ny`, `1..Nz`. Ghost layers are at index `0` and `N_x+1` (and similarly for `y` and `z`). `p[i,j,k]` stores $p(i,j,k)$.\n- `ux` array: size $(N_x+1, N_y+2, N_z+2)$. `ux[i,j,k]` stores $u_x(i+\\tfrac{1}{2},j,k)$. `i` runs from `0` to $N_x$.\n- `uy` array: size $(N_x+2, N_y+1, N_z+2)$. `uy[i,j,k]` stores $u_y(i,j+\\tfrac{1}{2},k)$. `j` runs from `0` to $N_y$.\n- `uz` array: size $(N_x+2, N_y+2, N_z+1)$. `uz[i,j,k]` stores $u_z(i,j,k+\\tfrac{1}{2})$. `k` runs from `0` to $N_z$.\n\nWith this indexing, the updates can be expressed in vectorized form:\n- **Velocity Update**:\n  - `ux_np12 = ux_nm12 - (dt/rho) * (p_n[1:,:,:] - p_n[:-1,:,:]) / dx`\n  - `uy_np12 = uy_nm12 - (dt/rho) * (p_n[:,1:,:] - p_n[:,:-1,:]) / dy`\n  - `uz_np12 = uz_nm12 - (dt/rho) * (p_n[:,:,1:] - p_n[:,:,:-1]) / dz`\n- **Pressure Update** (for interior points `1..N_x`, `1..N_y`, `1..N_z`):\n  - `div_u_x = (ux_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - ux_np12[0:Nx, 1:Ny+1, 1:Nz+1]) / dx`\n  - `div_u_y = (uy_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - uy_np12[1:Nx+1, 0:Ny, 1:Nz+1]) / dy`\n  - `div_u_z = (uz_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - uz_np12[1:Nx+1, 1:Ny+1, 0:Nz]) / dz`\n  - `p_np1[1:Nx+1, 1:Ny+1, 1:Nz+1] = p_n[1:Nx+1, 1:Ny+1, 1:Nz+1] - K*dt*(div_u_x + div_u_y + div_u_z)`\n\n#### 2.4. Boundary Conditions and Analysis of Expected Results\n- **Homogeneous Neumann BC**: $\\frac{\\partial p}{\\partial n}=0$ is enforced by copying values from the first interior layer to the adjacent ghost layer. For example, `p[0,:,:] = p[1,:,:]` and `p[Nx+1,:,:] = p[Nx,:,:]`.\n- **Maximum Boundary-Normal Velocity**: The normal velocity at a physical boundary is determined by the pressure gradient across that boundary. For the boundary at $i=1/2$, the update for $u_x(1/2,j,k)$ (i.e., `ux[0,j,k]`) depends on $p(1,j,k) - p(0,j,k)$. The Neumann BC forces $p(0,j,k) = p(1,j,k)$, making the discrete gradient zero. Since the initial velocity is zero, the normal velocities at all physical boundaries must remain zero. Thus, this value is expected to be $0.0$.\n- **Count of Non-Zero Velocities**: The initial pressure $p^n$ is a single point delta function. The velocity update `u^{n+1/2}` will be non-zero only where the gradient of $p^n$ is non-zero. This occurs only on the faces immediately adjacent to the cell with the pressure pulse. For a central pulse not adjacent to a boundary, this yields $6$ non-zero velocity components ($2$ for each dimension). If the pulse is next to a boundary, the Neumann BC will nullify the gradient in that direction, reducing the count.\n    - Case A ($1 \\times 1 \\times 1$): The single cell is adjacent to boundaries in all directions. The count is $0$.\n    - Case B ($3 \\times 2 \\times 1$): Center is $(2,2,1)$. It is interior in $x$, but on the boundary of the interior domain in $y$ and $z$. The count is $2$ ($x$) + $1$ ($y$) + $0$ ($z$) = $3$.\n    - Case C ($4 \\times 3 \\times 2$): Center is $(3,2,2)$. It is interior in $x$ and $y$, but on the boundary in $z$. The count is $2$ ($x$) + $2$ ($y$) + $1$ ($z$) = $5$.\n- **Sum of Interior Pressure**: The FDTD scheme on a staggered grid with these boundary conditions conserves a discrete analogue of total acoustic mass, $\\int p \\, dV$. The sum of the divergence terms over the entire interior volume telescopes to a sum of normal velocities at the boundary. Since these are zero, the total change in the sum of pressure values is zero. Therefore, the sum of interior pressure after the update should equal the initial sum, which is $1.0$.\n\nThese theoretical predictions serve as a robust verification for the correctness of the implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(Nx, Ny, Nz, dx, dy, dz, rho, K):\n    \"\"\"\n    Performs one full leapfrog update cycle for the 3D acoustic equations.\n    \"\"\"\n    # 1. Calculate derived parameters\n    c = np.sqrt(K / rho)\n    dt = 0.5 * min(dx, dy, dz) / c\n\n    # 2. Initialize arrays with ghost layers\n    p_shape = (Nx + 2, Ny + 2, Nz + 2)\n    ux_shape = (Nx + 1, Ny + 2, Nz + 2)\n    uy_shape = (Nx + 2, Ny + 1, Nz + 2)\n    uz_shape = (Nx + 2, Ny + 2, Nz + 1)\n\n    p_n = np.zeros(p_shape)\n    ux_nm12 = np.zeros(ux_shape)\n    uy_nm12 = np.zeros(uy_shape)\n    uz_nm12 = np.zeros(uz_shape)\n    \n    # Set initial pressure a delta function at the interior center\n    ic = Nx // 2 + 1\n    jc = Ny // 2 + 1\n    kc = Nz // 2 + 1\n    p_n[ic, jc, kc] = 1.0\n\n    # 3. Apply homogeneous Neumann boundary conditions on pressure\n    def apply_p_boundary_conditions(p):\n        p[0, :, :] = p[1, :, :]\n        p[Nx + 1, :, :] = p[Nx, :, :]\n        p[:, 0, :] = p[:, 1, :]\n        p[:, Ny + 1, :] = p[:, Ny, :]\n        p[:, :, 0] = p[:, :, 1]\n        p[:, :, Nz + 1] = p[:, :, Nz]\n        return p\n\n    p_n = apply_p_boundary_conditions(p_n)\n\n    # 4. Update velocity components to time n+1/2\n    ux_np12 = ux_nm12 - (dt / rho) * (p_n[1:, :, :] - p_n[:-1, :, :]) / dx\n    uy_np12 = uy_nm12 - (dt / rho) * (p_n[:, 1:, :] - p_n[:, :-1, :]) / dy\n    uz_np12 = uz_nm12 - (dt / rho) * (p_n[:, :, 1:] - p_n[:, :, :-1]) / dz\n\n    # 5. Update pressure to time n+1\n    p_np1 = np.copy(p_n)\n    \n    # Divergence terms are calculated over the volume that affects interior pressure cells\n    # The slices are constructed to produce a result of shape (Nx, Ny, Nz)\n    div_ux = (ux_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - ux_np12[0:Nx, 1:Ny+1, 1:Nz+1]) / dx\n    div_uy = (uy_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - uy_np12[1:Nx+1, 0:Ny, 1:Nz+1]) / dy\n    div_uz = (uz_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - uz_np12[1:Nx+1, 1:Ny+1, 0:Nz]) / dz\n\n    divergence = div_ux + div_uy + div_uz\n    \n    # Update only the interior pressure cells\n    p_np1[1:Nx+1, 1:Ny+1, 1:Nz+1] -= K * dt * divergence\n\n    # 6. Compute required output quantities\n    \n    # 6.1. Max absolute boundary-normal velocity\n    # Normal velocities are on faces at i=0, Nx; j=0, Ny; k=0, Nz\n    max_vx_boundary = np.max(np.abs(np.concatenate([ux_np12[0, :, :].ravel(), ux_np12[Nx, :, :].ravel()])))\n    max_vy_boundary = np.max(np.abs(np.concatenate([uy_np12[:, 0, :].ravel(), uy_np12[:, Ny, :].ravel()])))\n    max_vz_boundary = np.max(np.abs(np.concatenate([uz_np12[:, :, 0].ravel(), uz_np12[:, :, Nz].ravel()])))\n    \n    max_boundary_v = max(max_vx_boundary, max_vy_boundary, max_vz_boundary)\n\n    # 6.2. Count of interior face velocities exceeding tolerance\n    tol = 1e-14\n    \n    # Interior faces are those used in the divergence calculation for interior pressure points\n    # ux faces: i in [0,Nx], j in [1,Ny], k in [1,Nz]\n    # uy faces: i in [1,Nx], j in [0,Ny], k in [1,Nz]\n    # uz faces: i in [1,Nx], j in [1,Ny], k in [0,Nz]\n    \n    # Slicing corresponds to array indices. uy_np12[1:Nx+1, 0:Ny+1, 1:Nz+1] means\n    # indices i from 1 to Nx, j from 0 to Ny, k from 1 to Nz.\n    count_ux = np.sum(np.abs(ux_np12[0:Nx+1, 1:Ny+1, 1:Nz+1]) > tol)\n    count_uy = np.sum(np.abs(uy_np12[1:Nx+1, 0:Ny+1, 1:Nz+1]) > tol)\n    count_uz = np.sum(np.abs(uz_np12[1:Nx+1, 1:Ny+1, 0:Nz+1]) > tol)\n    \n    nonzero_v_count = int(count_ux + count_uy + count_uz)\n\n    # 6.3. Sum of interior pressure values after update\n    interior_p_sum = np.sum(p_np1[1:Nx+1, 1:Ny+1, 1:Nz+1])\n\n    return max_boundary_v, nonzero_v_count, interior_p_sum\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite and prints the final result.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'Nx': 1, 'Ny': 1, 'Nz': 1, 'dx': 0.1, 'dy': 0.1, 'dz': 0.1, 'rho': 1.2, 'K': 1.4e5},\n        # Case B\n        {'Nx': 3, 'Ny': 2, 'Nz': 1, 'dx': 0.05, 'dy': 0.1, 'dz': 0.2, 'rho': 1.2, 'K': 1.01e5},\n        # Case C\n        {'Nx': 4, 'Ny': 3, 'Nz': 2, 'dx': 0.02, 'dy': 0.03, 'dz': 0.04, 'rho': 1.2, 'K': 1.5e5},\n    ]\n\n    results = []\n    for case in test_cases:\n        v_bound, v_count, p_sum = run_simulation(**case)\n        results.extend([v_bound, v_count, p_sum])\n\n    # Format the final output string exactly as required.\n    # The output values are formatted to avoid excessive precision.\n    formatted_results = []\n    for i, res in enumerate(results):\n        if (i % 3) == 0:  # Boundary velocity\n            formatted_results.append(f\"{res:.1g}\")\n        elif (i % 3) == 1:  # Count\n            formatted_results.append(str(res))\n        else:  # Pressure sum\n            formatted_results.append(f\"{res:.1f}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After building a numerical solver, the next critical step is to verify its correctness. This practice introduces a powerful verification technique by simulating a known physical phenomenon: the resonant modes of a rectangular cavity. You will initialize a standing wave within a 2D domain and compare the dominant frequency of the time-evolved field, extracted via Fourier analysis, to the known analytical eigenfrequency. This process allows you to validate not only the core update scheme but also your implementation of different boundary conditions, such as rigid (Neumann) and pressure-release (Dirichlet) walls.",
            "id": "4138364",
            "problem": "Consider the linearized first-order acoustic equations in two spatial dimensions for small perturbations about a quiescent fluid state, given by the system\n$$\n\\frac{\\partial p}{\\partial t} = -K \\left( \\frac{\\partial v_x}{\\partial x} + \\frac{\\partial v_y}{\\partial y} \\right), \\quad\n\\rho_0 \\frac{\\partial v_x}{\\partial t} = -\\frac{\\partial p}{\\partial x}, \\quad\n\\rho_0 \\frac{\\partial v_y}{\\partial t} = -\\frac{\\partial p}{\\partial y},\n$$\nwhere $p$ is acoustic pressure, $v_x$ and $v_y$ are the components of acoustic particle velocity, $K$ is bulk modulus, and $\\rho_0$ is equilibrium density. Assume a rectangular cavity of dimensions $L_x$ by $L_y$ with walls that are either rigid or pressure-release. A rigid wall enforces $v_n=0$, i.e., zero normal velocity at the boundary, which corresponds to a homogeneous Neumann condition on $p$. A pressure-release wall enforces $p=0$ (Dirichlet condition). For a rectangular cavity, the continuous eigenfrequencies are\n$$\nf_{m,n} = \\frac{c}{2} \\sqrt{\\left(\\frac{m}{L_x}\\right)^2 + \\left(\\frac{n}{L_y}\\right)^2},\n$$\nwith $c$ the sound speed. For pressure-release walls, $m,n \\in \\mathbb{N}$, and for rigid walls, $m,n \\in \\mathbb{N}_0$ with the trivial case $m=n=0$ excluded.\n\nYou must implement an explicit two-dimensional staggered-grid scheme (pressure at cell centers and velocity components at cell faces) for this system. The discrete update must be derived from the above equations using finite differences consistent with the staggered arrangement:\n- Pressure $p[i,j]$ at cell centers located at positions $x_i = (i+\\tfrac{1}{2})\\Delta x$, $y_j = (j+\\tfrac{1}{2})\\Delta y$, for $i=0,\\dots,N_x-1$, $j=0,\\dots,N_y-1$.\n- Velocity $v_x[i,j]$ on vertical faces at $x = i \\Delta x$, $y = (j+\\tfrac{1}{2})\\Delta y$, for $i=0,\\dots,N_x$, $j=0,\\dots,N_y-1$.\n- Velocity $v_y[i,j]$ on horizontal faces at $x = (i+\\tfrac{1}{2})\\Delta x$, $y = j \\Delta y$, for $i=0,\\dots,N_x-1$, $j=0,\\dots,N_y$.\n\nUse a leapfrog-in-time approach where velocity is advanced from time $t^n$ to $t^{n+1/2}$ using pressure gradients, and pressure is advanced from $t^n$ to $t^{n+1}$ using the divergence of velocity at $t^{n+1/2}$. Boundary conditions must be enforced as follows:\n- For rigid walls, set the normal velocity components to zero on the domain boundary (i.e., $v_x[0,\\cdot]=0$, $v_x[N_x,\\cdot]=0$, $v_y[\\cdot,0]=0$, $v_y[\\cdot,N_y]=0$), and use symmetric ghost pressure values to produce zero-normal pressure gradients in the velocity update (i.e., $p_{\\text{ghost,left}}=p[0,\\cdot]$, $p_{\\text{ghost,right}}=p[N_x-1,\\cdot]$, $p_{\\text{ghost,bottom}}=p[\\cdot,0]$, $p_{\\text{ghost,top}}=p[\\cdot,N_y-1]$).\n- For pressure-release walls, enforce $p=0$ at the wall via antisymmetric ghost pressure values (i.e., $p_{\\text{ghost,left}}=-p[0,\\cdot]$, $p_{\\text{ghost,right}}=-p[N_x-1,\\cdot]$, $p_{\\text{ghost,bottom}}=-p[\\cdot,0]$, $p_{\\text{ghost,top}}=-p[\\cdot,N_y-1]$), and let velocity evolve freely.\n\nInitialize a standing wave by setting the initial pressure field to the appropriate continuous mode shape with unit amplitude and zero initial velocities:\n- For rigid walls (Neumann boundary condition), use $p(x,y,0) = \\cos\\left(\\frac{m \\pi x}{L_x}\\right)\\cos\\left(\\frac{n \\pi y}{L_y}\\right)$.\n- For pressure-release walls (Dirichlet boundary condition), use $p(x,y,0) = \\sin\\left(\\frac{m \\pi x}{L_x}\\right)\\sin\\left(\\frac{n \\pi y}{L_y}\\right)$.\n\nChoose the time step $\\Delta t$ from the Courant-Friedrichs-Lewy safety condition for the staggered scheme,\n$$\n\\Delta t = \\frac{\\text{CFL}}{c \\sqrt{\\left(\\frac{1}{\\Delta x}\\right)^2 + \\left(\\frac{1}{\\Delta y}\\right)^2}},\n$$\nwith $\\text{CFL} \\in (0,1)$. Simulate for a finite duration $T$ sufficient to resolve the dominant frequency of the standing wave. Extract the dominant discrete frequency $f_{\\text{FD}}$ from the pressure time history at a non-nodal interior point using a Discrete Fourier Transform and compute the relative error\n$$\n\\delta = \\frac{|f_{\\text{FD}} - f_{m,n}|}{f_{m,n}},\n$$\nwhich must be reported as a dimensionless decimal (not using a percent symbol).\n\nImplement the above in a complete program and run the following test suite. Use consistent physical and numerical units: $L_x$ and $L_y$ in meters, $c$ in meters per second, $\\rho_0$ in kilograms per cubic meter, $\\Delta t$ in seconds, and $f$ in Hertz. The final outputs must be the relative errors $\\delta$ for each case, rounded to six decimal places.\n\nTest Suite:\n- Case $1$ (happy path, rigid walls): $L_x=1.2$ $\\mathrm{m}$, $L_y=0.8$ $\\mathrm{m}$, $N_x=64$, $N_y=48$, $m=1$, $n=0$, $c=343$ $\\mathrm{m/s}$, $\\rho_0=1.21$ $\\mathrm{kg/m^3}$, $\\text{CFL}=0.95$, $T=0.25$ $\\mathrm{s}$.\n- Case $2$ (happy path, pressure-release walls): $L_x=1.2$ $\\mathrm{m}$, $L_y=0.8$ $\\mathrm{m}$, $N_x=64$, $N_y=48$, $m=1$, $n=1$, $c=343$ $\\mathrm{m/s}$, $\\rho_0=1.21$ $\\mathrm{kg/m^3}$, $\\text{CFL}=0.95$, $T=0.25$ $\\mathrm{s}$.\n- Case $3$ (edge case: one zero index mode and near-CFL limit, rigid walls): $L_x=1.0$ $\\mathrm{m}$, $L_y=1.5$ $\\mathrm{m}$, $N_x=60$, $N_y=50$, $m=0$, $n=2$, $c=343$ $\\mathrm{m/s}$, $\\rho_0=1.21$ $\\mathrm{kg/m^3}$, $\\text{CFL}=0.99$, $T=0.30$ $\\mathrm{s}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3]$) where $r_k$ are the three relative errors for the above cases, rounded to six decimal places.",
            "solution": "The user wants to solve the 2D linearized acoustic equations on a staggered grid using a finite-difference time-domain (FDTD) scheme and validate the numerical results against analytical eigenfrequencies. I have validated the problem statement and found it to be scientifically sound, well-posed, and complete. I will now provide the full solution.\n\n### **1. Governing Equations and Discretization**\n\nThe problem concerns the linearized first-order acoustic equations in two spatial dimensions:\n$$\n\\frac{\\partial p}{\\partial t} = -K \\left( \\frac{\\partial v_x}{\\partial x} + \\frac{\\partial v_y}{\\partial y} \\right)\n$$\n$$\n\\rho_0 \\frac{\\partial v_x}{\\partial t} = -\\frac{\\partial p}{\\partial x}\n$$\n$$\n\\rho_0 \\frac{\\partial v_y}{\\partial t} = -\\frac{\\partial p}{\\partial y}\n$$\nHere, $p$ is the acoustic pressure, $\\vec{v} = (v_x, v_y)$ is the particle velocity, $K$ is the bulk modulus, and $\\rho_0$ is the equilibrium density of the fluid. The sound speed is given by $c = \\sqrt{K/\\rho_0}$.\n\nWe employ a staggered-grid finite-difference scheme. The pressure $p$ is defined at cell centers, while the velocity components $v_x$ and $v_y$ are defined on the cell faces normal to their respective directions. Let the domain of size $L_x \\times L_y$ be discretized into $N_x \\times N_y$ cells, with spatial step sizes $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$. The discrete fields are denoted as:\n- $p_{i,j}^n \\approx p((i+\\frac{1}{2})\\Delta x, (j+\\frac{1}{2})\\Delta y, n\\Delta t)$\n- $v_{x, i,j}^{n+1/2} \\approx v_x(i\\Delta x, (j+\\frac{1}{2})\\Delta y, (n+\\frac{1}{2})\\Delta t)$\n- $v_{y, i,j}^{n+1/2} \\approx v_y((i+\\frac{1}{2})\\Delta x, j\\Delta y, (n+\\frac{1}{2})\\Delta t)$\n\nThe indices run $i=0, \\dots, N_x-1$ and $j=0, \\dots, N_y-1$ for pressure $p$. For velocities, the indices extend to the domain boundaries: $i=0, \\dots, N_x$ for $v_x$, and $j=0, \\dots, N_y$ for $v_y$.\n\nA leapfrog time-stepping scheme is used, where pressure is evaluated at integer time steps $n\\Delta t$ and velocities at half-integer time steps $(n+\\frac{1}{2})\\Delta t$. The partial derivatives are approximated using second-order central differences, which are naturally staggered in both space and time:\n\nThe velocity update equations are derived from the momentum equations:\n$$\nv_{x, i,j}^{n+1/2} = v_{x, i,j}^{n-1/2} - \\frac{\\Delta t}{\\rho_0 \\Delta x} (p_{i,j}^n - p_{i-1,j}^n)\n$$\n$$\nv_{y, i,j}^{n+1/2} = v_{y, i,j}^{n-1/2} - \\frac{\\Delta t}{\\rho_0 \\Delta y} (p_{i,j}^n - p_{i,j-1}^n)\n$$\n\nThe pressure update equation is derived from the continuity equation:\n$$\np_{i,j}^{n+1} = p_{i,j}^n - K \\Delta t \\left( \\frac{v_{x, i+1,j}^{n+1/2} - v_{x, i,j}^{n+1/2}}{\\Delta x} + \\frac{v_{y, i,j+1}^{n+1/2} - v_{y, i,j}^{n+1/2}}{\\Delta y} \\right)\n$$\nThese equations form the core of the FDTD simulation loop.\n\n### **2. Initial and Boundary Conditions**\n\n**Initial Conditions**: The simulation is initialized with a standing wave pattern for pressure, corresponding to a specific mode $(m, n)$, and zero initial velocity. For the leapfrog scheme, we set $p^0$ according to the specified functions and assume the velocities at time $t=-\\Delta t/2$ are zero.\n- For rigid walls (Neumann BCs): $p(x,y,0) = \\cos\\left(\\frac{m \\pi x}{L_x}\\right)\\cos\\left(\\frac{n \\pi y}{L_y}\\right)$. The discrete pressure field $p_{i,j}^0$ is initialized by evaluating this function at the pressure grid coordinates $(x_i, y_j) = ((i+0.5)\\Delta x, (j+0.5)\\Delta y)$.\n- For pressure-release walls (Dirichlet BCs): $p(x,y,0) = \\sin\\left(\\frac{m \\pi x}{L_x}\\right)\\sin\\left(\\frac{n \\pi y}{L_y}\\right)$.\n\n**Boundary Conditions**:\n- **Rigid Walls**: This condition imposes zero normal velocity ($v_n=0$) at the boundaries, which corresponds to a homogeneous Neumann condition on pressure ($\\partial p/\\partial n = 0$). In the discrete scheme, this is enforced by explicitly setting the normal velocity components on the boundary grid points to zero at every time step:\n$v_{x,0,j} = 0$, $v_{x,N_x,j} = 0$, $v_{y,i,0} = 0$, and $v_{y,i,N_y} = 0$. This method correctly models a zero pressure gradient at the wall within the FDTD framework.\n\n- **Pressure-Release Walls**: This condition imposes zero pressure ($p=0$) at the boundaries. This is a Dirichlet condition. We implement it using anti-symmetric ghost pressure values just outside the domain. For example, to update the velocity $v_{x,0,j}$ at the left boundary ($x=0$), the required pressure gradient involves a ghost pressure value $p_{-1,j}$. We set this ghost value to $p_{-1,j} = -p_{0,j}$. This effectively models the $p=0$ condition to second-order accuracy. The velocity update at the four boundaries becomes:\n$$\nv_{x, 0,j}^{n+1/2} = v_{x, 0,j}^{n-1/2} - \\frac{\\Delta t}{\\rho_0 \\Delta x} (p_{0,j}^n - (-p_{0,j}^n)) = v_{x, 0,j}^{n-1/2} - \\frac{2\\Delta t}{\\rho_0 \\Delta x} p_{0,j}^n\n$$\n$$\nv_{x, N_x,j}^{n+1/2} = v_{x, N_x,j}^{n-1/2} - \\frac{\\Delta t}{\\rho_0 \\Delta x} ((-p_{N_x-1,j}^n) - p_{N_x-1,j}^n) = v_{x, N_x,j}^{n-1/2} + \\frac{2\\Delta t}{\\rho_0 \\Delta x} p_{N_x-1,j}^n\n$$\nAnalogous updates apply to $v_{y,i,0}$ and $v_{y,i,N_y}$.\n\n### **3. Stability, Frequency Analysis, and Error Calculation**\n\n**Stability**: The explicit FDTD scheme is conditionally stable. The time step $\\Delta t$ must satisfy the Courant-Friedrichs-Lewy (CFL) condition. For the 2D staggered grid, this is:\n$$\n\\Delta t \\le \\frac{1}{c \\sqrt{\\left(\\frac{1}{\\Delta x}\\right)^2 + \\left(\\frac{1}{\\Delta y}\\right)^2}}\n$$\nWe use a safety factor $\\text{CFL}  1$ to set the time step:\n$$\n\\Delta t = \\frac{\\text{CFL}}{c \\sqrt{\\left(\\frac{1}{\\Delta x}\\right)^2 + \\left(\\frac{1}{\\Delta y}\\right)^2}}\n$$\n\n**Frequency Analysis**: The simulation is run for a total time $T$. The pressure at a fixed, non-nodal interior point is recorded at each time step, forming a discrete time signal. A Discrete Fourier Transform (DFT) is then applied to this signal using a Fast Fourier Transform (FFT) algorithm. The frequency corresponding to the largest-magnitude component (excluding the DC component) is identified as the dominant discrete frequency, $f_{\\text{FD}}$.\n\n**Error Calculation**: The numerical dispersion of the grid causes the numerical frequency $f_{\\text{FD}}$ to deviate from the analytical eigenfrequency $f_{m,n}$ for the continuous system. We quantify this deviation using the relative error $\\delta$:\n$$\n\\delta = \\frac{|f_{\\text{FD}} - f_{m,n}|}{f_{m,n}}\n$$\nwhere the analytical frequency is given by\n$$\nf_{m,n} = \\frac{c}{2} \\sqrt{\\left(\\frac{m}{L_x}\\right)^2 + \\left(\\frac{n}{L_y}\\right)^2}\n$$\nThe value of $\\delta$ serves as a measure of the accuracy of the FDTD simulation for the given discretization.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: (happy path, rigid walls)\n        {'Lx': 1.2, 'Ly': 0.8, 'Nx': 64, 'Ny': 48, 'm': 1, 'n': 0, 'c': 343.0,\n         'rho0': 1.21, 'CFL': 0.95, 'T': 0.25, 'bc_type': 'rigid'},\n        # Case 2: (happy path, pressure-release walls)\n        {'Lx': 1.2, 'Ly': 0.8, 'Nx': 64, 'Ny': 48, 'm': 1, 'n': 1, 'c': 343.0,\n         'rho0': 1.21, 'CFL': 0.95, 'T': 0.25, 'bc_type': 'pressure-release'},\n        # Case 3: (edge case: one zero index mode and near-CFL limit, rigid walls)\n        {'Lx': 1.0, 'Ly': 1.5, 'Nx': 60, 'Ny': 50, 'm': 0, 'n': 2, 'c': 343.0,\n         'rho0': 1.21, 'CFL': 0.99, 'T': 0.30, 'bc_type': 'rigid'}\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_fdtd_simulation(**case)\n        results.append(f\"{error:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_fdtd_simulation(Lx, Ly, Nx, Ny, m, n, c, rho0, CFL, T, bc_type):\n    \"\"\"\n    Performs a 2D acoustic FDTD simulation for a single test case.\n    \"\"\"\n    # 1. Grid and Simulation Parameters\n    dx = Lx / Nx\n    dy = Ly / Ny\n    K = c**2 * rho0  # Bulk modulus\n\n    # Stability condition (CFL)\n    dt = CFL / (c * np.sqrt(1/dx**2 + 1/dy**2))\n    n_steps = int(T / dt)\n\n    # 2. Field Initialization\n    p = np.zeros((Nx, Ny))\n    vx = np.zeros((Nx + 1, Ny))\n    vy = np.zeros((Nx, Ny + 1))\n    \n    # Pressure grid coordinates (cell centers)\n    p_x_coords = (np.arange(Nx) + 0.5) * dx\n    p_y_coords = (np.arange(Ny) + 0.5) * dy\n    xx, yy = np.meshgrid(p_x_coords, p_y_coords, indexing='ij')\n\n    # Initial pressure field\n    if bc_type == 'rigid':\n        p = np.cos(m * np.pi * xx / Lx) * np.cos(n * np.pi * yy / Ly)\n    elif bc_type == 'pressure-release':\n        # For pressure-release, m and n must be >= 1. The problem ensures this.\n        p = np.sin(m * np.pi * xx / Lx) * np.sin(n * np.pi * yy / Ly)\n\n    # 3. Main FDTD Loop\n    pressure_history = np.zeros(n_steps)\n    probe_x, probe_y = Nx // 3, Ny // 3 # A non-nodal point for all cases\n    \n    # Update coefficients\n    C_vx = dt / (rho0 * dx)\n    C_vy = dt / (rho0 * dy)\n    C_px = K * dt / dx\n    C_py = K * dt / dy\n\n    for t_step in range(n_steps):\n        # --- (1) Update Velocity Fields (from n-1/2 to n+1/2) ---\n        # Interior points\n        vx[1:Nx, :] -= C_vx * (p[1:Nx, :] - p[0:Nx-1, :])\n        vy[:, 1:Ny] -= C_vy * (p[:, 1:Ny] - p[:, 0:Ny-1])\n        \n        # --- (2) Apply Velocity Boundary Conditions ---\n        if bc_type == 'rigid':\n            vx[0, :] = 0.0\n            vx[Nx, :] = 0.0\n            vy[:, 0] = 0.0\n            vy[:, Ny] = 0.0\n        elif bc_type == 'pressure-release':\n            # Use anti-symmetric ghost cells for p to update boundary velocities\n            vx[0, :] -= 2.0 * C_vx * p[0, :]\n            vx[Nx, :] += 2.0 * C_vx * p[Nx-1, :]\n            vy[:, 0] -= 2.0 * C_vy * p[:, 0]\n            vy[:, Ny] += 2.0 * C_vy * p[:, Ny-1]\n\n        # --- (3) Update Pressure Field (from n to n+1) ---\n        p[:, :] -= C_px * (vx[1:Nx+1, :] - vx[0:Nx, :])\n        p[:, :] -= C_py * (vy[:, 1:Ny+1] - vy[:, 0:Ny])\n\n        # --- (4) Store pressure at probe location ---\n        pressure_history[t_step] = p[probe_x, probe_y]\n\n    # 4. Frequency Analysis\n    # Analytical frequency\n    # For rigid BCs, m,n=0,0 is excluded. For p-release, m,n>=1.\n    if (m == 0 and n == 0):\n        f_mn = 0.0\n    else:\n        f_mn = (c / 2.0) * np.sqrt((m / Lx)**2 + (n / Ly)**2)\n\n    # Numerical frequency from FFT\n    fft_result = np.fft.fft(pressure_history)\n    fft_freqs = np.fft.fftfreq(n_steps, d=dt)\n    \n    # Find peak frequency in the positive spectrum\n    positive_freq_mask = fft_freqs > 0\n    if not np.any(positive_freq_mask):\n        return np.nan # Avoid error if no positive frequencies (e.g., T is too short)\n        \n    peak_idx = np.argmax(np.abs(fft_result[positive_freq_mask]))\n    f_fd = fft_freqs[positive_freq_mask][peak_idx]\n\n    # 5. Calculate Relative Error\n    if f_mn == 0:\n        # Avoid division by zero if analytical frequency is zero.\n        # This case should not be hit with the provided test suite.\n        return np.abs(f_fd)\n    \n    relative_error = np.abs(f_fd - f_mn) / f_mn\n    \n    return relative_error\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "A hallmark of a reliable numerical method is its predictable convergence towards the true solution as the grid is refined. This final practice moves from case-specific verification to the formal validation of the scheme's accuracy. You will define and implement discrete versions of function norms, such as the $\\mathsf{L}^2$ and energy norms, to quantitatively measure the error of the staggered-grid difference operators. By performing a convergence rate study, you will confirm that the scheme achieves its theoretical second-order accuracy, a cornerstone of rigorous numerical analysis.",
            "id": "4138382",
            "problem": "Consider the one-dimensional linear acoustics in first-order form on a periodic domain with length $L$, written as the coupled system\n$$\n\\partial_t p(x,t) + \\kappa \\,\\partial_x u(x,t) = 0,\\qquad\n\\partial_t u(x,t) + \\frac{1}{\\rho}\\,\\partial_x p(x,t) = 0,\n$$\nwhere $p$ is the acoustic pressure, $u$ is the particle velocity, $\\rho$ is the density, and $\\kappa$ is the bulk modulus, all strictly positive constants. The spatial domain is $\\Omega = [0,L]$ with periodic boundary conditions. We seek to define discrete norms and seminorms on a uniform staggered grid and to compute observed convergence rates for staggered finite-difference approximations of spatial derivatives under grid refinement.\n\nDefine a uniform staggered grid with $N$ cells on $\\Omega$ with mesh spacing $h = L/N$, cell centers at $x_i = (i+\\tfrac{1}{2})h$ for $i \\in \\{0,1,\\dots,N-1\\}$, and cell faces at $x_{i+\\tfrac{1}{2}} = ih$ for $i \\in \\{0,1,\\dots,N-1\\}$; identify indices modulo $N$ to enforce periodicity. Let discrete scalar fields defined at centers be denoted by $\\{v_i\\}_{i=0}^{N-1}$ and at faces by $\\{w_{i+\\tfrac{1}{2}}\\}_{i=0}^{N-1}$.\n\n1. Define the discrete inner products and $\\mathsf{L}^2$ norms at cell centers and faces by\n$$\n\\langle v, \\tilde v\\rangle_{h,c} = \\sum_{i=0}^{N-1} h\\, v_i \\tilde v_i,\\quad \\|v\\|_{h,c} = \\sqrt{\\langle v, v\\rangle_{h,c}},\\qquad\n\\langle w, \\tilde w\\rangle_{h,f} = \\sum_{i=0}^{N-1} h\\, w_{i+\\tfrac{1}{2}} \\tilde w_{i+\\tfrac{1}{2}},\\quad \\|w\\|_{h,f} = \\sqrt{\\langle w, w\\rangle_{h,f}}.\n$$\n\n2. Define the staggered forward and backward difference operators with periodic wrapping,\n$$\n(D^+ v)_{i+\\tfrac{1}{2}} = \\frac{v_i - v_{i-1}}{h},\\qquad (D^- w)_i = \\frac{w_{i+1+\\tfrac{1}{2}} - w_{i+\\tfrac{1}{2}}}{h},\n$$\nfor $i \\in \\{0,1,\\dots,N-1\\}$, where indices are modulo $N$. These approximate $\\partial_x v$ at faces and $\\partial_x w$ at centers, respectively.\n\n3. Define $\\mathsf{H}^1$-like seminorms on the staggered grid by\n$$\n|v|_{h,c,1} = \\|D^+ v\\|_{h,f},\\qquad |w|_{h,f,1} = \\|D^- w\\|_{h,c}.\n$$\n\n4. Define the discrete energy-based norm for an acoustic state $(p,u)$ sampled on the staggered grid (with $p$ at centers and $u$ at faces) by\n$$\n\\|(p,u)\\|_{E,h} = \\sqrt{ \\frac{1}{2} \\sum_{i=0}^{N-1} h\\left( \\frac{1}{\\kappa} p_i^2 + \\rho\\, u_{i+\\tfrac{1}{2}}^2 \\right)}.\n$$\nThis is a discrete analogue of the continuous acoustic energy norm. No physical units are required for the outputs requested below, since the reported quantities are dimensionless convergence rates.\n\nLet $L = 2\\pi$. For smooth test functions $\\phi$ and $u$ that are $2\\pi$-periodic, define pointwise samples at centers and faces by $v_i = \\phi(x_i)$, $w_{i+\\tfrac{1}{2}} = u(x_{i+\\tfrac{1}{2}})$, and denote exact spatial derivatives by $\\partial_x \\phi$ and $\\partial_x u$. For an operator approximation error $e_h$ measured in a chosen discrete norm $\\|\\cdot\\|_h$, define the observed refinement-based convergence rate between mesh sizes $h$ and $h/2$ as\n$$\nr = \\frac{\\log\\left(\\|e_h\\|_h / \\|e_{h/2}\\|_{h/2}\\right)}{\\log(2)}.\n$$\n\nYour program must implement these definitions and compute observed convergence rates for the following test suite. For each test, use three successively refined grids with $N_0$, $2N_0$, and $4N_0$ cells, respectively. For each test, report the single observed rate computed between the two finest levels, namely $r_{(2N_0\\to 4N_0)}$.\n\n- Test $1$ (energy-weighted error of staggered gradient): Let $\\rho = 1.3$, $\\kappa = 2.6$, and $\\phi(x) = \\exp(\\sin x)$. For each grid, compute $D^+\\phi$ at faces from center samples and the exact $\\partial_x \\phi$ at faces. Form the pair $(p,u)$ with $p \\equiv 0$ at centers and $u$ equal to the facewise error $D^+\\phi - \\partial_x \\phi$. Compute the energy-based norm $\\|(p,u)\\|_{E,h}$ and the observed rate $r_{(2N_0\\to 4N_0)}$ with $N_0 = 32$.\n\n- Test $2$ (centered $\\mathsf{L}^2$ error of staggered divergence): Let $u(x) = \\exp(\\cos x)$. For each grid, sample $u$ at faces, compute $D^- u$ at centers, evaluate the exact $\\partial_x u$ at centers, compute the centered $\\mathsf{L}^2$ norm $\\|D^- u - \\partial_x u\\|_{h,c}$, and report the observed rate $r_{(2N_0\\to 4N_0)}$ with $N_0 = 32$.\n\n- Test $3$ (facewise $\\mathsf{L}^2$ error for higher wavenumber gradient): Let $\\phi(x) = \\sin(10 x)$. For each grid, compute $D^+\\phi$ at faces from center samples and compare to the exact $\\partial_x \\phi$ at faces using the facewise $\\mathsf{L}^2$ norm $\\|\\cdot\\|_{h,f}$, and report the observed rate $r_{(2N_0\\to 4N_0)}$ with $N_0 = 64$.\n\n- Test $4$ (centered $\\mathsf{L}^2$ error for higher wavenumber divergence): Let $u(x) = \\sin(11 x)$. For each grid, compute $D^- u$ at centers from face samples and compare to the exact $\\partial_x u$ at centers using the centered $\\mathsf{L}^2$ norm $\\|\\cdot\\|_{h,c}$, and report the observed rate $r_{(2N_0\\to 4N_0)}$ with $N_0 = 64$.\n\nAll functions are real-valued and smooth on $[0,2\\pi]$, and angles are in radians. No physical units are required for the output since the reported rates are dimensionless real numbers.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\text{Test 1 rate}, \\text{Test 2 rate}, \\text{Test 3 rate}, \\text{Test 4 rate}]$. The outputs must be floating-point numbers. Example format: $[r_1,r_2,r_3,r_4]$.",
            "solution": "We begin with the continuous first-order acoustic equations. The total acoustic energy of a state $(p,u)$ on a periodic domain $\\Omega=[0,L]$ is\n$$\n\\mathcal{E}(t) = \\frac{1}{2}\\int_0^L \\left(\\frac{1}{\\kappa}p(x,t)^2 + \\rho\\, u(x,t)^2\\right)\\,dx,\n$$\nwhich is conserved in time for smooth solutions with periodic boundary conditions. This continuous energy suggests a natural inner product and norm in which to measure errors of discretized acoustic states.\n\nOn a uniform staggered grid with $N$ cells, $h=L/N$, we place the pressure $p$ at cell centers $x_i=(i+\\tfrac{1}{2})h$ and the velocity $u$ at cell faces $x_{i+\\tfrac{1}{2}}=ih$. The discrete inner products\n$$\n\\langle v, \\tilde v\\rangle_{h,c} = \\sum_{i=0}^{N-1} h\\, v_i \\tilde v_i,\\qquad\n\\langle w, \\tilde w\\rangle_{h,f} = \\sum_{i=0}^{N-1} h\\, w_{i+\\tfrac{1}{2}} \\tilde w_{i+\\tfrac{1}{2}}\n$$\nare consistent Riemann-sum approximations of the continuous $\\mathsf{L}^2$ inner product for functions represented at centers and faces, respectively. The associated discrete $\\mathsf{L}^2$ norms $\\|v\\|_{h,c}$ and $\\|w\\|_{h,f}$ follow by taking the square root of the inner product with itself.\n\nThe staggered finite-difference operators $D^+$ and $D^-$ are defined by\n$$\n(D^+ v)_{i+\\tfrac{1}{2}} = \\frac{v_i - v_{i-1}}{h},\\qquad (D^- w)_i = \\frac{w_{i+1+\\tfrac{1}{2}} - w_{i+\\tfrac{1}{2}}}{h},\n$$\nwith periodic wrap of indices. These approximate the spatial derivative at staggered locations. A Taylor expansion shows second-order accuracy. For instance, for a smooth function $\\phi$, expand about $x_{i+\\tfrac{1}{2}}$:\n$$\n\\phi(x_i) = \\phi(x_{i+\\tfrac{1}{2}}) - \\frac{h}{2}\\phi'(x_{i+\\tfrac{1}{2}}) + \\frac{h^2}{8}\\phi''(x_{i+\\tfrac{1}{2}}) - \\frac{h^3}{48}\\phi^{(3)}(x_{i+\\tfrac{1}{2}}) + \\mathcal{O}(h^4),\n$$\n$$\n\\phi(x_{i-1}) = \\phi(x_{i+\\tfrac{1}{2}}) - \\frac{3h}{2}\\phi'(x_{i+\\tfrac{1}{2}}) + \\frac{9h^2}{8}\\phi''(x_{i+\\tfrac{1}{2}}) - \\frac{27h^3}{48}\\phi^{(3)}(x_{i+\\tfrac{1}{2}}) + \\mathcal{O}(h^4).\n$$\nSubtracting and dividing by $h$ yields\n$$\n(D^+\\phi)_{i+\\tfrac{1}{2}} = \\phi'(x_{i+\\tfrac{1}{2}}) + \\frac{h^2}{24}\\phi^{(3)}(x_{i+\\tfrac{1}{2}}) + \\mathcal{O}(h^4),\n$$\nwhich shows a truncation error of order $\\mathcal{O}(h^2)$. A similar expansion shows that $(D^- u)_i$ approximates $\\partial_x u(x_i)$ with $\\mathcal{O}(h^2)$ error. These imply that the discrete $\\mathsf{L}^2$ norm of the error for sufficiently smooth functions decreases as $\\mathcal{O}(h^2)$, hence the observed convergence rates under uniform refinement should approach $2$.\n\nFor discrete Sobolev-type measurement, define $\\mathsf{H}^1$-like seminorms $|v|_{h,c,1} = \\|D^+ v\\|_{h,f}$ for center fields and $|w|_{h,f,1} = \\|D^- w\\|_{h,c}$ for face fields. These are discrete analogues of the continuous $\\mathsf{H}^1$ seminorm $|f|_{H^1}=\\|\\partial_x f\\|_{L^2}$, respecting the staggered positioning of derivatives.\n\nThe energy-based discrete norm for a state $(p,u)$ is\n$$\n\\|(p,u)\\|_{E,h} = \\sqrt{\\frac{1}{2}\\sum_{i=0}^{N-1} h\\left(\\frac{1}{\\kappa}p_i^2 + \\rho\\, u_{i+\\tfrac{1}{2}}^2\\right)}.\n$$\nThis mirrors the continuous energy. It can also be used to measure the error of a pair $(e_p,e_u)$; for example, taking $e_p\\equiv 0$ and $e_u=D^+\\phi - \\partial_x\\phi$ yields\n$$\n\\|(e_p,e_u)\\|_{E,h} = \\sqrt{\\frac{\\rho}{2}}\\;\\|D^+\\phi - \\partial_x\\phi\\|_{h,f},\n$$\nso the energy-based error converges at the same rate as the facewise $\\mathsf{L}^2$ error of $D^+\\phi$.\n\nTo compute observed convergence rates, consider a sequence of grids with $N_0$, $2N_0$, and $4N_0$ cells. For each grid, assemble the staggered locations $x_i$ and $x_{i+\\tfrac{1}{2}}$, sample the exact function and its exact derivative, apply the discrete operator ($D^+$ or $D^-$), and compute the discrete norm of the error. Denote by $\\|e_{h}\\|$ the error norm on the grid with spacing $h$. Define the rate between the finer levels as\n$$\nr_{(2N_0\\to 4N_0)} = \\frac{\\log\\left(\\|e_{h/2}\\| / \\|e_{h/4}\\|\\right)}{\\log(2)}.\n$$\nFor smooth periodic functions, this observed rate should be close to $2$, reflecting the second-order consistency of $D^+$ and $D^-$.\n\nWe now specify the tests:\n\n- Test $1$: Choose $\\rho=1.3$, $\\kappa=2.6$, $\\phi(x)=\\exp(\\sin x)$, $N_0=32$, $L=2\\pi$. For each $N\\in\\{N_0,2N_0,4N_0\\}$, compute center samples $v_i=\\phi(x_i)$, facewise $D^+v$, the exact derivative $\\partial_x\\phi(x)=\\cos(x)\\exp(\\sin x)$ at faces, the facewise error $e_u=D^+v-\\partial_x\\phi$, the energy norm with $p\\equiv 0$, and then form $r_{(2N_0\\to 4N_0)}$.\n\n- Test $2$: Choose $u(x)=\\exp(\\cos x)$, $N_0=32$, $L=2\\pi$. For each $N$, compute face samples $w_{i+\\tfrac{1}{2}}=u(x_{i+\\tfrac{1}{2}})$, the centerwise $D^-w$, the exact derivative $\\partial_x u(x)=-\\sin(x)\\exp(\\cos x)$ at centers, compute $\\|D^-w-\\partial_x u\\|_{h,c}$, and then $r_{(2N_0\\to 4N_0)}$.\n\n- Test $3$: Choose $\\phi(x)=\\sin(10x)$, $N_0=64$, $L=2\\pi$. For each $N$, compute $D^+\\phi$ at faces from center samples, the exact derivative $\\partial_x\\phi(x)=10\\cos(10x)$ at faces, compute the facewise $\\mathsf{L}^2$ error, and then $r_{(2N_0\\to 4N_0)}$.\n\n- Test $4$: Choose $u(x)=\\sin(11x)$, $N_0=64$, $L=2\\pi$. For each $N$, compute $D^-u$ at centers from face samples, the exact derivative $\\partial_x u(x)=11\\cos(11x)$ at centers, compute the centered $\\mathsf{L}^2$ error, and then $r_{(2N_0\\to 4N_0)}$.\n\nAlgorithmically, for each test and refinement level:\n\n- Construct $x_i=(i+\\tfrac{1}{2})h$ and $x_{i+\\tfrac{1}{2}}=ih$ for $i\\in\\{0,\\dots,N-1\\}$ with $h=L/N$.\n\n- Evaluate the relevant exact function and its derivative at the required locations.\n\n- Apply $D^+$ or $D^-$ using periodic wrap of indices.\n\n- Compute the discrete $\\mathsf{L}^2$ norm or energy norm of the error, as appropriate.\n\n- Accumulate errors at $N_0$, $2N_0$, and $4N_0$; compute $r_{(2N_0\\to 4N_0)}$ using the formula above.\n\nFinally, output the four rates as a single line in the specified format. The expected rates are close to $2$ for all tests, subject to small deviations due to pre-asymptotic effects and the particular oscillatory content of the test functions.",
            "answer": "```python\nimport numpy as np\n\ndef make_grid(N, L):\n    h = L / N\n    x_centers = (np.arange(N) + 0.5) * h\n    x_faces = np.arange(N) * h\n    return h, x_centers, x_faces\n\ndef D_plus_center_to_face(phi_center, h):\n    # (D^+ v)_{i+1/2} = (v_i - v_{i-1})/h with periodic wrap\n    return (phi_center - np.roll(phi_center, 1)) / h\n\ndef D_minus_face_to_center(u_face, h):\n    # (D^- w)_i = (w_{i+1+1/2} - w_{i+1/2})/h with periodic wrap\n    return (np.roll(u_face, -1) - u_face) / h\n\ndef L2_norm_center(arr_center, h):\n    return np.sqrt(h * np.sum(arr_center**2))\n\ndef L2_norm_face(arr_face, h):\n    return np.sqrt(h * np.sum(arr_face**2))\n\ndef energy_norm(p_center, u_face, h, rho, kappa):\n    return np.sqrt(0.5 * h * (np.sum((1.0/kappa) * p_center**2) + np.sum(rho * u_face**2)))\n\n# Test functions and derivatives\ndef phi_exp_sin(x):\n    return np.exp(np.sin(x))\n\ndef dphi_exp_sin(x):\n    return np.cos(x) * np.exp(np.sin(x))\n\ndef phi_sin_k(x, k):\n    return np.sin(k * x)\n\ndef dphi_sin_k(x, k):\n    return k * np.cos(k * x)\n\ndef u_exp_cos(x):\n    return np.exp(np.cos(x))\n\ndef du_exp_cos(x):\n    return -np.sin(x) * np.exp(np.cos(x))\n\ndef u_sin_k(x, k):\n    return np.sin(k * x)\n\ndef du_sin_k(x, k):\n    return k * np.cos(k * x)\n\ndef rate_from_errors(e_h, e_h2):\n    return np.log(e_h / e_h2) / np.log(2.0)\n\ndef observed_rate_grad_energy(phi_func, dphi_func, L, N0, rho, kappa):\n    Ns = [N0, 2*N0, 4*N0]\n    errs = []\n    for N in Ns:\n        h, xc, xf = make_grid(N, L)\n        phi_c = phi_func(xc)\n        dphi_exact_f = dphi_func(xf)\n        dplus_phi = D_plus_center_to_face(phi_c, h)\n        e_face = dplus_phi - dphi_exact_f\n        # Energy norm with p=0 and u = error\n        p_zero = np.zeros_like(phi_c)\n        en = energy_norm(p_zero, e_face, h, rho, kappa)\n        errs.append(en)\n    # Use the rate between the two finest levels\n    r = rate_from_errors(errs[1], errs[2])\n    return r\n\ndef observed_rate_div_L2(u_func, du_func, L, N0):\n    Ns = [N0, 2*N0, 4*N0]\n    errs = []\n    for N in Ns:\n        h, xc, xf = make_grid(N, L)\n        u_f = u_func(xf)\n        du_exact_c = du_func(xc)\n        dminus_u = D_minus_face_to_center(u_f, h)\n        e_center = dminus_u - du_exact_c\n        l2 = L2_norm_center(e_center, h)\n        errs.append(l2)\n    r = rate_from_errors(errs[1], errs[2])\n    return r\n\ndef observed_rate_grad_L2(phi_func, dphi_func, L, N0):\n    Ns = [N0, 2*N0, 4*N0]\n    errs = []\n    for N in Ns:\n        h, xc, xf = make_grid(N, L)\n        phi_c = phi_func(xc)\n        dphi_exact_f = dphi_func(xf)\n        dplus_phi = D_plus_center_to_face(phi_c, h)\n        e_face = dplus_phi - dphi_exact_f\n        l2 = L2_norm_face(e_face, h)\n        errs.append(l2)\n    r = rate_from_errors(errs[1], errs[2])\n    return r\n\ndef solve():\n    L = 2.0 * np.pi\n\n    test_cases = [\n        # Test 1: gradient energy norm with phi = exp(sin x), rho=1.3, kappa=2.6, N0=32\n        (\"grad_energy_exp_sin\", 32, 1.3, 2.6),\n        # Test 2: divergence L2 with u = exp(cos x), N0=32\n        (\"div_l2_exp_cos\", 32, None, None),\n        # Test 3: gradient L2 with phi = sin(10x), N0=64\n        (\"grad_l2_sin10\", 64, None, None),\n        # Test 4: divergence L2 with u = sin(11x), N0=64\n        (\"div_l2_sin11\", 64, None, None),\n    ]\n\n    results = []\n    for case in test_cases:\n        name, N0, rho, kappa = case\n        if name == \"grad_energy_exp_sin\":\n            r = observed_rate_grad_energy(phi_exp_sin, dphi_exp_sin, L, N0, rho, kappa)\n            results.append(r)\n        elif name == \"div_l2_exp_cos\":\n            r = observed_rate_div_L2(u_exp_cos, du_exp_cos, L, N0)\n            results.append(r)\n        elif name == \"grad_l2_sin10\":\n            r = observed_rate_grad_L2(lambda x: phi_sin_k(x, 10.0),\n                                      lambda x: dphi_sin_k(x, 10.0), L, N0)\n            results.append(r)\n        elif name == \"div_l2_sin11\":\n            r = observed_rate_div_L2(lambda x: u_sin_k(x, 11.0),\n                                     lambda x: du_sin_k(x, 11.0), L, N0)\n            results.append(r)\n        else:\n            results.append(float('nan'))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}