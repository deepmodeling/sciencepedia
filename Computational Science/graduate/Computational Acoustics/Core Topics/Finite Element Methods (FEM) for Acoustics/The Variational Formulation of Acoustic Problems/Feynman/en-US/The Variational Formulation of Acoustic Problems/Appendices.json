{
    "hands_on_practices": [
        {
            "introduction": "The Finite Element Method (FEM) bridges the gap between the continuous world of partial differential equations and the discrete world of linear algebra. The cornerstone of this process is the assembly of system matrices from individual element-level contributions. This exercise provides fundamental practice in this translation by tasking you with deriving the complete element matrix for the Helmholtz equation on a single triangular element, including contributions from both the domain and an impedance boundary condition. ",
            "id": "4145890",
            "problem": "Consider a time-harmonic acoustic pressure field $p$ in a homogeneous medium with constant mass density and sound speed, modeled in a two-dimensional domain by the scalar Helmholtz equation with wave number $k>0$. Let the strong form be given by $-\\Delta p - k^{2} p = 0$ in an open set $\\Omega \\subset \\mathbb{R}^{2}$, together with a real-valued impedance (Robin) boundary condition $\\partial_{n} p + \\alpha p = 0$ on part of the boundary $\\Gamma_{R} \\subset \\partial \\Omega$, where $\\alpha>0$ is a given constant and $\\partial_{n}$ denotes the outward normal derivative. Assume the remaining boundary is Neumann with zero flux. Using the Finite Element Method (FEM) with linear Lagrange basis functions on a single triangular element $K$, let $K$ have vertices at $(x_{1},y_{1})=(0,0)$, $(x_{2},y_{2})=(1,0)$, and $(x_{3},y_{3})=(0,2)$. Assume the edge from node $1$ to node $2$ lies on $\\Gamma_{R}$, and the other edges are interior edges.\n\nStarting from the strong form, derive the variational (weak) formulation on $K$ and specify the linear Lagrange shape functions $\\phi_{1}, \\phi_{2}, \\phi_{3}$ associated with the three vertices of $K$. Then, for this element, compute the element-level bilinear form entries\n$$\na_{ij}^{(K)} \\;=\\; \\int_{K} \\nabla \\phi_{i} \\cdot \\nabla \\phi_{j} \\, dx \\;-\\; k^{2} \\int_{K} \\phi_{i}\\,\\phi_{j}\\, dx \\;+\\; \\int_{\\partial K \\cap \\Gamma_{R}} \\alpha\\, \\phi_{i}\\,\\phi_{j}\\, ds\n$$\nfor all $i,j \\in \\{1,2,3\\}$.\n\nExpress the final answer as a single row matrix in the order $\\left(a_{11}^{(K)},\\,a_{12}^{(K)},\\,a_{13}^{(K)},\\,a_{21}^{(K)},\\,a_{22}^{(K)},\\,a_{23}^{(K)},\\,a_{31}^{(K)},\\,a_{32}^{(K)},\\,a_{33}^{(K)}\\right)$, using exact arithmetic and leaving $k$ and $\\alpha$ as symbolic parameters. No rounding is required, and no units need to be specified.",
            "solution": "The governing equation for time-harmonic acoustics in a homogeneous medium is the scalar Helmholtz equation. Starting from the conservation of mass and momentum for small-amplitude disturbances and applying the time-harmonic ansatz $p(\\mathbf{x},t)=\\Re\\{P(\\mathbf{x})\\exp(-\\mathrm{i}\\omega t)\\}$ with angular frequency $\\omega$, one obtains for the spatial amplitude $P$ the boundary value problem $-\\Delta P - k^{2} P = 0$, where $k=\\omega/c$ is the wave number. Imposing a real impedance (Robin) boundary condition $\\partial_{n} P + \\alpha P = 0$ on $\\Gamma_{R}$ and homogeneous Neumann condition elsewhere, the variational (weak) formulation on a subdomain $K \\subset \\Omega$ is obtained by multiplying the strong form by a test function $v$ and integrating by parts:\n$$\n\\int_{K} (-\\Delta p)\\, v \\, dx - k^{2} \\int_{K} p\\, v \\, dx = 0.\n$$\nUsing the identity\n$$\n\\int_{K} (-\\Delta p)\\, v \\, dx = \\int_{K} \\nabla p \\cdot \\nabla v \\, dx - \\int_{\\partial K} \\partial_{n} p \\, v \\, ds,\n$$\nand imposing the boundary conditions, the natural boundary contribution on the Robin edge is\n$$\n-\\int_{\\partial K \\cap \\Gamma_{R}} \\partial_{n} p \\, v \\, ds = \\int_{\\partial K \\cap \\Gamma_{R}} \\alpha \\, p \\, v \\, ds,\n$$\nwhile Neumann boundary with zero flux adds nothing to the bilinear form. Therefore, the element-level bilinear form is\n$$\na^{(K)}(p,v) \\;=\\; \\int_{K} \\nabla p \\cdot \\nabla v \\, dx \\;-\\; k^{2} \\int_{K} p\\, v \\, dx \\;+\\; \\int_{\\partial K \\cap \\Gamma_{R}} \\alpha\\, p\\, v\\, ds.\n$$\nIn the Finite Element Method (FEM) using linear Lagrange basis functions on the triangle $K$ with vertices $(0,0)$, $(1,0)$, $(0,2)$, the standard nodal shape functions $\\{\\phi_{i}\\}_{i=1}^{3}$ are the barycentric coordinates. Using the area-coordinate representation,\n$$\n\\phi_{i}(x,y) \\;=\\; \\frac{a_{i} + b_{i} x + c_{i} y}{2A},\n$$\nwhere $A$ is the area of $K$, and for each vertex $i$, $(a_{i},b_{i},c_{i})$ are computed from the other two vertices $(x_{j},y_{j})$ and $(x_{k},y_{k})$ as\n$$\na_{i} = x_{j} y_{k} - x_{k} y_{j}, \\quad b_{i} = y_{j} - y_{k}, \\quad c_{i} = x_{k} - x_{j}.\n$$\nFor our triangle, the area is\n$$\nA \\;=\\; \\frac{1}{2} \\, |(x_{2}-x_{1})(y_{3}-y_{1}) - (x_{3}-x_{1})(y_{2}-y_{1})| \\;=\\; \\frac{1}{2}\\,(1\\cdot 2 - 0\\cdot 0) \\;=\\; 1.\n$$\nCompute $(a_{i},b_{i},c_{i})$:\n- For $i=1$ with $(j,k)=(2,3)$,\n$$\na_{1} = x_{2} y_{3} - x_{3} y_{2} = 1\\cdot 2 - 0\\cdot 0 = 2,\\quad b_{1} = y_{2} - y_{3} = 0 - 2 = -2,\\quad c_{1} = x_{3} - x_{2} = 0 - 1 = -1,\n$$\nso\n$$\n\\phi_{1}(x,y) = \\frac{2 - 2x - y}{2} = 1 - x - \\frac{y}{2}.\n$$\n- For $i=2$ with $(j,k)=(3,1)$,\n$$\na_{2} = x_{3} y_{1} - x_{1} y_{3} = 0\\cdot 0 - 0\\cdot 2 = 0,\\quad b_{2} = y_{3} - y_{1} = 2 - 0 = 2,\\quad c_{2} = x_{1} - x_{3} = 0 - 0 = 0,\n$$\nso\n$$\n\\phi_{2}(x,y) = \\frac{0 + 2x + 0\\cdot y}{2} = x.\n$$\n- For $i=3$ with $(j,k)=(1,2)$,\n$$\na_{3} = x_{1} y_{2} - x_{2} y_{1} = 0\\cdot 0 - 1\\cdot 0 = 0,\\quad b_{3} = y_{1} - y_{2} = 0 - 0 = 0,\\quad c_{3} = x_{2} - x_{1} = 1 - 0 = 1,\n$$\nso\n$$\n\\phi_{3}(x,y) = \\frac{0 + 0\\cdot x + 1\\cdot y}{2} = \\frac{y}{2}.\n$$\nThe gradients are constant on $K$:\n$$\n\\nabla \\phi_{i} = \\frac{1}{2A}\\,(b_{i},\\,c_{i}) = \\frac{1}{2}\\,(b_{i},\\,c_{i}),\n$$\ngiving\n$$\n\\nabla \\phi_{1} = \\left(-1,\\,-\\frac{1}{2}\\right),\\quad \\nabla \\phi_{2} = (1,\\,0),\\quad \\nabla \\phi_{3} = \\left(0,\\,\\frac{1}{2}\\right).\n$$\nBecause these are constant, the stiffness-like contribution\n$$\n\\int_{K} \\nabla \\phi_{i} \\cdot \\nabla \\phi_{j}\\, dx = A\\, \\nabla \\phi_{i} \\cdot \\nabla \\phi_{j} = \\nabla \\phi_{i} \\cdot \\nabla \\phi_{j},\n$$\nwith $A=1$. Compute all dot products:\n$$\n\\nabla \\phi_{1} \\cdot \\nabla \\phi_{1} = 1 + \\frac{1}{4} = \\frac{5}{4},\\quad \\nabla \\phi_{1} \\cdot \\nabla \\phi_{2} = -1,\\quad \\nabla \\phi_{1} \\cdot \\nabla \\phi_{3} = -\\frac{1}{4},\n$$\n$$\n\\nabla \\phi_{2} \\cdot \\nabla \\phi_{2} = 1,\\quad \\nabla \\phi_{2} \\cdot \\nabla \\phi_{3} = 0,\\quad \\nabla \\phi_{3} \\cdot \\nabla \\phi_{3} = \\frac{1}{4}.\n$$\nNext, the consistent $P_{1}$ mass-like contribution on a triangle with area $A=1$ is\n$$\n\\int_{K} \\phi_{i}\\,\\phi_{j}\\, dx =\n\\begin{cases}\n\\frac{1}{6}, & \\text{if } i=j, \\\\\n\\frac{1}{12}, & \\text{if } i\\neq j,\n\\end{cases}\n$$\nwhich can be verified either by direct integration or by standard formulas for linear triangular elements. Therefore, the internal bilinear entries are\n$$\n\\left[\\int_{K} \\nabla \\phi_{i} \\cdot \\nabla \\phi_{j}\\, dx\\right] - k^{2}\\left[\\int_{K} \\phi_{i}\\,\\phi_{j}\\, dx\\right]\n=\n\\begin{cases}\n\\frac{5}{4} - \\frac{k^{2}}{6}, & (i,j)=(1,1), \\\\\n-1 - \\frac{k^{2}}{12}, & (i,j)=(1,2)\\text{ or }(2,1), \\\\\n-\\frac{1}{4} - \\frac{k^{2}}{12}, & (i,j)=(1,3)\\text{ or }(3,1), \\\\\n1 - \\frac{k^{2}}{6}, & (i,j)=(2,2), \\\\\n0 - \\frac{k^{2}}{12} = -\\frac{k^{2}}{12}, & (i,j)=(2,3)\\text{ or }(3,2), \\\\\n\\frac{1}{4} - \\frac{k^{2}}{6}, & (i,j)=(3,3).\n\\end{cases}\n$$\nNow include the Robin boundary integral on $\\partial K \\cap \\Gamma_{R}$, which is the edge from node $1$ to node $2$. Parameterize this edge by $x \\in [0,1]$ with $y=0$ and $ds=dx$. The restricted shape functions are $\\phi_{1}(x,0) = 1 - x$, $\\phi_{2}(x,0) = x$, and $\\phi_{3}(x,0) = 0$. The boundary contributions are\n$$\n\\int_{\\partial K \\cap \\Gamma_{R}} \\alpha\\, \\phi_{1}\\,\\phi_{1}\\, ds = \\alpha \\int_{0}^{1} (1-x)^{2}\\, dx = \\alpha \\cdot \\frac{1}{3} = \\frac{\\alpha}{3},\n$$\n$$\n\\int_{\\partial K \\cap \\Gamma_{R}} \\alpha\\, \\phi_{2}\\,\\phi_{2}\\, ds = \\alpha \\int_{0}^{1} x^{2}\\, dx = \\alpha \\cdot \\frac{1}{3} = \\frac{\\alpha}{3},\n$$\n$$\n\\int_{\\partial K \\cap \\Gamma_{R}} \\alpha\\, \\phi_{1}\\,\\phi_{2}\\, ds = \\alpha \\int_{0}^{1} x(1-x)\\, dx = \\alpha \\cdot \\frac{1}{6} = \\frac{\\alpha}{6},\n$$\nand all terms involving $\\phi_{3}$ vanish on that edge. Summing internal and boundary contributions yields the complete element bilinear entries:\n$$\na_{11}^{(K)} = \\frac{5}{4} - \\frac{k^{2}}{6} + \\frac{\\alpha}{3},\\quad\na_{12}^{(K)} = -1 - \\frac{k^{2}}{12} + \\frac{\\alpha}{6},\\quad\na_{13}^{(K)} = -\\frac{1}{4} - \\frac{k^{2}}{12},\n$$\n$$\na_{21}^{(K)} = -1 - \\frac{k^{2}}{12} + \\frac{\\alpha}{6},\\quad\na_{22}^{(K)} = 1 - \\frac{k^{2}}{6} + \\frac{\\alpha}{3},\\quad\na_{23}^{(K)} = -\\frac{k^{2}}{12},\n$$\n$$\na_{31}^{(K)} = -\\frac{1}{4} - \\frac{k^{2}}{12},\\quad\na_{32}^{(K)} = -\\frac{k^{2}}{12},\\quad\na_{33}^{(K)} = \\frac{1}{4} - \\frac{k^{2}}{6}.\n$$\nThese are symmetric in $i$ and $j$ as expected. The requested ordering for the final row matrix is $\\left(a_{11}^{(K)},\\,a_{12}^{(K)},\\,a_{13}^{(K)},\\,a_{21}^{(K)},\\,a_{22}^{(K)},\\,a_{23}^{(K)},\\,a_{31}^{(K)},\\,a_{32}^{(K)},\\,a_{33}^{(K)}\\right)$.",
            "answer": "$$\\boxed{\\begin{pmatrix}\n\\frac{5}{4} - \\frac{k^{2}}{6} + \\frac{\\alpha}{3} & -1 - \\frac{k^{2}}{12} + \\frac{\\alpha}{6} & -\\frac{1}{4} - \\frac{k^{2}}{12} & -1 - \\frac{k^{2}}{12} + \\frac{\\alpha}{6} & 1 - \\frac{k^{2}}{6} + \\frac{\\alpha}{3} & -\\frac{k^{2}}{12} & -\\frac{1}{4} - \\frac{k^{2}}{12} & -\\frac{k^{2}}{12} & \\frac{1}{4} - \\frac{k^{2}}{6}\n\\end{pmatrix}}$$"
        },
        {
            "introduction": "A numerical solver is only as valuable as our confidence in its results, making verification against known solutions a critical skill in computational science. This practice guides you through the complete workflow of building and verifying a simple FEM solver for an acoustic resonance problem in a circular cavity. By leveraging symmetry to simplify the problem and comparing your numerical eigenvalues and eigenfunctions to the analytical Bessel function solutions, you will gain hands-on experience with error analysis and convergence concepts. ",
            "id": "4145864",
            "problem": "Consider the time-harmonic acoustic pressure field in a two-dimensional circular cavity of radius $R$, modeled as the solution of the interior eigenvalue problem for the Laplacian under a homogeneous Dirichlet boundary condition on the boundary. Let the spatial domain be the disk $D = \\{ (x,y) \\in \\mathbb{R}^2 \\mid x^2 + y^2 < R^2 \\}$ and the boundary $\\partial D = \\{ (x,y) \\in \\mathbb{R}^2 \\mid x^2 + y^2 = R^2 \\}$. The governing strong form is: find nontrivial $u$ and $\\lambda \\in \\mathbb{R}$ such that\n$$\n- \\Delta u = \\lambda\\, u \\quad \\text{in } D, \\qquad u = 0 \\quad \\text{on } \\partial D.\n$$\nStarting from this strong form, derive the variational (weak) formulation: find $u \\in V$ and $\\lambda \\in \\mathbb{R}$ such that\n$$\na(u,v) = \\lambda\\, m(u,v) \\quad \\text{for all } v \\in V,\n$$\nwhere $V$ is the appropriate function space. Clearly identify $V$, the bilinear form $a(\\cdot,\\cdot)$, and the bilinear form $m(\\cdot,\\cdot)$ in terms of fundamental quantities. Explain how symmetry and separation of variables justify restricting attention to the axisymmetric subspace and then derive the corresponding one-dimensional radial weak formulation on the interval $[0,R]$ with weight determined by the polar-coordinate Jacobian.\n\nImplement a Galerkin approximation using the Finite Element Method (FEM), with continuous, piecewise-linear basis functions on a uniform partition of the radial interval $[0,R]$ into $N$ elements. Enforce the Dirichlet boundary condition at $r=R$ as an essential boundary condition. Assemble the discrete stiffness matrix $\\mathbf{K}$ and mass matrix $\\mathbf{M}$ corresponding to the radial weak form with the correct weight. Formulate and solve the matrix generalized eigenvalue problem\n$$\n\\mathbf{K}\\,\\mathbf{u} = \\lambda_h\\, \\mathbf{M}\\,\\mathbf{u},\n$$\nto compute the first $p$ axisymmetric discrete eigenpairs $(\\lambda_h^{(j)}, \\mathbf{u}^{(j)})$.\n\nThe analytical axisymmetric eigenpairs are given by the Bessel functions of the first kind of order zero, with eigenfunctions $u^{(j)}_{\\text{exact}}(r) = J_0(k_j r)$ and wavenumbers $k_j$ determined by the zeros of $J_0$ at $r=R$, i.e., $J_0(k_j R) = 0$, and eigenvalues $\\lambda^{(j)}_{\\text{exact}} = k_j^2$. Describe precisely how to compute two error metrics against these analytical solutions:\n- The relative eigenvalue error defined by\n$$\nE_{\\lambda}^{(j)} = \\frac{\\left| \\lambda_h^{(j)} - \\lambda_{\\text{exact}}^{(j)} \\right|}{\\lambda_{\\text{exact}}^{(j)}}.\n$$\n- The relative eigenfunction error in the weighted $L^2$-norm induced by the mass bilinear form, with optimal scaling of the analytical function to best fit the discrete eigenvector. Specifically, if $\\mathbf{e}^{(j)}$ denotes the analytical eigenfunction sampled at the finite element nodes (excluding the Dirichlet node at $r=R$), define\n$$\n\\alpha^{(j)} = \\frac{\\mathbf{e}^{(j)T}\\mathbf{M}\\,\\mathbf{u}^{(j)}}{\\mathbf{e}^{(j)T}\\mathbf{M}\\,\\mathbf{e}^{(j)}}, \\qquad\nE_{u}^{(j)} = \\frac{ \\left\\| \\mathbf{u}^{(j)} - \\alpha^{(j)} \\mathbf{e}^{(j)} \\right\\|_{\\mathbf{M}} }{ \\left\\| \\mathbf{e}^{(j)} \\right\\|_{\\mathbf{M}} },\n$$\nwhere $\\left\\| \\mathbf{w} \\right\\|_{\\mathbf{M}} = \\sqrt{\\mathbf{w}^T \\mathbf{M} \\mathbf{w}}$.\n\nYour task is to write a complete, runnable program that:\n1. Assembles the one-dimensional radial FEM stiffness and mass matrices for the axisymmetric weak formulation on $[0,R]$ with homogeneous Dirichlet boundary at $r=R$.\n2. Solves for the first $p$ discrete eigenpairs.\n3. Computes the analytical axisymmetric eigenvalues and eigenfunctions using zeros of $J_0$.\n4. Computes $E_{\\lambda}^{(j)}$ and $E_{u}^{(j)}$ for each $j=1,\\dots,p$.\n5. Aggregates the results for the provided test suite and prints them as a single line.\n\nUse the following test suite of parameter values, covering typical, coarse, and changed-radius cases:\n- Test case 1 (general case): $R = 1.0$, $N = 128$, $p = 3$.\n- Test case 2 (coarse discretization edge case): $R = 1.0$, $N = 12$, $p = 2$.\n- Test case 3 (changed radius): $R = 0.75$, $N = 96$, $p = 3$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no whitespace. Each test case result must itself be a list of per-mode pairs, where each pair is of the form $[E_{\\lambda}^{(j)},E_{u}^{(j)}]$ for $j=1,\\dots,p$. For example, a possible output structure is\n$$\n\\big[ \\big[ [E_{\\lambda}^{(1)},E_{u}^{(1)}], [E_{\\lambda}^{(2)},E_{u}^{(2)}], \\dots \\big], \\big[ [\\cdot,\\cdot], \\dots \\big], \\big[ [\\cdot,\\cdot], \\dots \\big] \\big],\n$$\nprinted as a single line with no spaces. All numerical values should be floats in plain or scientific notation. No physical units are required since the problem is non-dimensionalized; angles are not involved; percentages must not be used.",
            "solution": "The problem presented is a complete and well-posed exercise in computational acoustics, specifically addressing the finite element analysis of an interior axisymmetric eigenvalue problem. It is scientifically sound, mathematically rigorous, and contains all necessary information for a unique solution. We shall proceed by first deriving the required mathematical formulations and then implementing the numerical solution as specified.\n\n### Part 1: Derivation of the Variational (Weak) Formulation\n\nThe strong form of the problem is to find an eigenfunction $u$ and an eigenvalue $\\lambda \\in \\mathbb{R}$ such that:\n$$\n\\begin{cases}\n- \\Delta u = \\lambda u & \\text{ in } D \\\\\nu = 0 & \\text{ on } \\partial D\n\\end{cases}\n$$\nwhere $D$ is the disk of radius $R$.\n\nTo derive the weak formulation, we multiply the governing partial differential equation by a test function $v$. The test function must belong to a function space that respects the homogeneous Dirichlet boundary condition. The appropriate space is the Sobolev space $V = H_0^1(D)$, which consists of functions that are square-integrable, have square-integrable first derivatives, and are zero on the boundary $\\partial D$.\n\nMultiplying by $v \\in V$ and integrating over the domain $D$ gives:\n$$\n- \\int_D (\\Delta u) v \\, dA = \\lambda \\int_D u v \\, dA\n$$\nWe apply Green's first identity (multidimensional integration by parts) to the left-hand side:\n$$\n\\int_D (\\nabla u \\cdot \\nabla v) \\, dA - \\int_{\\partial D} v (\\nabla u \\cdot \\mathbf{n}) \\, dS = \\lambda \\int_D u v \\, dA\n$$\nwhere $\\mathbf{n}$ is the outward unit normal to the boundary $\\partial D$. The boundary integral $\\int_{\\partial D} v (\\nabla u \\cdot \\mathbf{n}) \\, dS$ vanishes because the test function $v$ is zero on $\\partial D$ by definition of the space $V=H_0^1(D)$.\n\nThis leads to the variational (weak) formulation: find $u \\in V$ and $\\lambda \\in \\mathbb{R}$ such that for all $v \\in V$:\n$$\n\\int_D (\\nabla u \\cdot \\nabla v) \\, dA = \\lambda \\int_D u v \\, dA\n$$\nThis equation is of the form $a(u,v) = \\lambda m(u,v)$, where:\n- The function space is $V = H_0^1(D)$.\n- The stiffness bilinear form is $a(u,v) = \\int_D (\\nabla u \\cdot \\nabla v) \\, dA$.\n- The mass bilinear form is $m(u,v) = \\int_D u v \\, dA$.\nBoth $a(\\cdot,\\cdot)$ and $m(\\cdot,\\cdot)$ are symmetric and positive definite (on the specified space), which ensures that the eigenvalues $\\lambda$ are real and positive.\n\n### Part 2: Reduction to the Axisymmetric 1D Formulation\n\nThe circular geometry of the domain allows for solutions that are axisymmetric, i.e., independent of the angular coordinate $\\theta$. In polar coordinates $(r, \\theta)$, such a function is of the form $u(r, \\theta) = u(r)$. The Laplacian operator in polar coordinates is $\\Delta = \\frac{1}{r}\\frac{\\partial}{\\partial r}(r \\frac{\\partial}{\\partial r}) + \\frac{1}{r^2}\\frac{\\partial^2}{\\partial \\theta^2}$. For axisymmetric functions, the angular derivative vanishes, so $\\Delta u = \\frac{1}{r}\\frac{d}{dr}(r \\frac{du}{dr})$.\n\nThe strong form reduces to an ordinary differential equation on the interval $[0, R]$:\n$$\n-\\frac{1}{r}\\frac{d}{dr}\\left(r \\frac{du}{dr}\\right) = \\lambda u(r), \\quad u(R)=0, \\quad u'(0)=0\n$$\nThe condition $u'(0)=0$ is a natural boundary condition required for smoothness at the origin.\n\nTo derive the corresponding 1D weak formulation, we express the 2D bilinear forms in polar coordinates. The area element is $dA = r\\,dr\\,d\\theta$. The gradient of an axisymmetric function $u(r)$ is $\\nabla u = (u'(r), 0)$. Thus, for two axisymmetric functions $u(r)$ and $v(r)$, their dot product is $\\nabla u \\cdot \\nabla v = u'(r)v'(r)$.\n\nSubstituting these into the 2D weak form:\n$$\na(u,v) = \\int_0^{2\\pi} \\int_0^R (u'v') r\\,dr\\,d\\theta = 2\\pi \\int_0^R u'(r)v'(r) r\\,dr\n$$\n$$\nm(u,v) = \\int_0^{2\\pi} \\int_0^R (uv) r\\,dr\\,d\\theta = 2\\pi \\int_0^R u(r)v(r) r\\,dr\n$$\nThe constant factor of $2\\pi$ appears on both sides of $a(u,v) = \\lambda m(u,v)$ and can be cancelled. This yields the one-dimensional radial weak formulation: find $u \\in V_r$ such that for all $v \\in V_r$:\n$$\n\\int_0^R u'v' r\\,dr = \\lambda \\int_0^R uv r\\,dr\n$$\nHere, the function space is $V_r = \\{ v \\in H^1((0,R)) \\mid v(R)=0 \\}$, and the radial weight $r$ in the integrals arises from the Jacobian of the transformation from Cartesian to polar coordinates.\n\n### Part 3: Finite Element Method (FEM) Discretization\n\nWe discretize the 1D radial weak form using the Galerkin method with continuous, piecewise-linear basis functions. We partition the interval $[0,R]$ into $N$ elements of equal size $h=R/N$ with nodes $r_i = ih$ for $i=0,\\dots,N$. The solution is approximated as a linear combination $u_h(r) = \\sum_{j=0}^{N-1} u_j \\phi_j(r)$, where $\\phi_j(r)$ are the standard linear \"hat\" basis functions and $u_j$ are the nodal values. The homogeneous Dirichlet condition $u(R)=0$ is enforced as an essential boundary condition by setting $u_N=0$ and excluding the basis function $\\phi_N(r)$ from the trial space. This results in $N$ unknown degrees of freedom, $u_0, \\dots, u_{N-1}$.\n\nThe Galerkin procedure leads to the matrix generalized eigenvalue problem $\\mathbf{K}\\mathbf{u} = \\lambda_h \\mathbf{M}\\mathbf{u}$, where the entries of the stiffness matrix $\\mathbf{K}$ and mass matrix $\\mathbf{M}$ are given by:\n$$\nK_{ij} = \\int_0^R \\phi_j' \\phi_i' r\\,dr, \\quad M_{ij} = \\int_0^R \\phi_j \\phi_i r\\,dr \\quad \\text{for } i,j \\in \\{0, \\dots, N-1\\}\n$$\nThese global matrices are assembled from local (element) matrix contributions. For a generic element $e_k = [r_k, r_{k+1}]$, the local stiffness matrix $(\\mathbf{K}^e_k)$ and mass matrix $(\\mathbf{M}^e_k)$ are calculated by integrating over this element.\n\nThe local stiffness matrix is:\n$$\n\\mathbf{K}^e_k = \\frac{r_k+r_{k+1}}{2h}\n\\begin{pmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{pmatrix}\n$$\nThe local mass matrix, using exact integration for the linear basis functions and the linearly varying weight $r$, is:\n$$\n\\mathbf{M}^e_k = \\frac{h}{12}\n\\begin{pmatrix}\n3r_k+r_{k+1} & r_k+r_{k+1} \\\\\nr_k+r_{k+1} & r_k+3r_{k+1}\n\\end{pmatrix}\n$$\nThese $2 \\times 2$ element matrices are then assembled into the global $N \\times N$ matrices $\\mathbf{K}$ and $\\mathbf{M}$.\n\n### Part 4: Error Metrics\n\nThe analytical solution involves Bessel functions of the first kind of order zero, $J_0$. The eigenfunctions are $u^{(j)}_{\\text{exact}}(r) = J_0(k_j r)$, where the wavenumbers $k_j$ are determined by the roots of $J_0(k_j R) = 0$. If $z_j$ is the $j$-th positive root of $J_0(z)=0$, then $k_j = z_j/R$. The corresponding exact eigenvalues are $\\lambda^{(j)}_{\\text{exact}} = k_j^2 = (z_j/R)^2$.\n\nThe error metrics are computed as follows:\n1.  **Relative Eigenvalue Error**: For the $j$-th mode, this is a straightforward comparison between the numerically computed eigenvalue $\\lambda_h^{(j)}$ and the analytical one $\\lambda_{\\text{exact}}^{(j)}$:\n    $$\n    E_{\\lambda}^{(j)} = \\frac{\\left| \\lambda_h^{(j)} - \\lambda_{\\text{exact}}^{(j)} \\right|}{\\lambda_{\\text{exact}}^{(j)}}\n    $$\n2.  **Relative Eigenfunction Error**: This measures the difference in shape between the discrete eigenvector $\\mathbf{u}^{(j)}$ and the sampled analytical eigenfunction $\\mathbf{e}^{(j)}$, where $\\mathbf{e}^{(j)}_i = J_0(k_j r_i)$. To account for arbitrary scaling of the computed eigenvector, the analytical vector is first scaled by an optimal factor $\\alpha^{(j)}$ that minimizes the error in the norm induced by the mass matrix $\\mathbf{M}$.\n    The scaling factor $\\alpha^{(j)}$ is the projection of $\\mathbf{u}^{(j)}$ onto $\\mathbf{e}^{(j)}$ in the $\\mathbf{M}$-inner product:\n    $$\n    \\alpha^{(j)} = \\frac{\\langle \\mathbf{e}^{(j)}, \\mathbf{u}^{(j)} \\rangle_{\\mathbf{M}}}{\\langle \\mathbf{e}^{(j)}, \\mathbf{e}^{(j)} \\rangle_{\\mathbf{M}}} = \\frac{\\mathbf{e}^{(j)T}\\mathbf{M}\\,\\mathbf{u}^{(j)}}{\\mathbf{e}^{(j)T}\\mathbf{M}\\,\\mathbf{e}^{(j)}}\n    $$\n    The error is then the ratio of the $\\mathbf{M}$-norm of the residual to the $\\mathbf{M}$-norm of the scaled analytical vector:\n    $$\n    E_{u}^{(j)} = \\frac{ \\left\\| \\mathbf{u}^{(j)} - \\alpha^{(j)} \\mathbf{e}^{(j)} \\right\\|_{\\mathbf{M}} }{ \\left\\| \\mathbf{e}^{(j)} \\right\\|_{\\mathbf{M}} } = \\sqrt{\\frac{ (\\mathbf{u}^{(j)} - \\alpha^{(j)} \\mathbf{e}^{(j)})^T \\mathbf{M} (\\mathbf{u}^{(j)} - \\alpha^{(j)} \\mathbf{e}^{(j)}) }{ \\mathbf{e}^{(j)T} \\mathbf{M} \\mathbf{e}^{(j)} }}\n    $$\nThe following program implements this entire procedure.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\nfrom scipy.special import jn_zeros, j0\nimport json\n\ndef compute_errors(R, N, p):\n    \"\"\"\n    Assembles FEM matrices, solves the eigenvalue problem, and computes errors.\n\n    Args:\n        R (float): Radius of the circular cavity.\n        N (int): Number of elements for the radial discretization.\n        p (int): Number of eigenmodes to compute.\n\n    Returns:\n        list: A list of pairs [E_lambda, E_u] for each of the p modes.\n    \"\"\"\n    \n    # 1. Discretization and Matrix Assembly\n    h = R / N\n    nodes = np.linspace(0, R, N + 1)\n    \n    # The system size is N x N for the N unknown nodal values (u_0 to u_{N-1})\n    K = np.zeros((N, N))\n    M = np.zeros((N, N))\n    \n    # Loop over elements to assemble global matrices\n    for k in range(N):\n        r_k = nodes[k]\n        r_k_plus_1 = nodes[k+1]\n        \n        # Element stiffness matrix\n        ke_factor = (r_k + r_k_plus_1) / (2.0 * h)\n        Ke = ke_factor * np.array([[1.0, -1.0], [-1.0, 1.0]])\n        \n        # Element mass matrix (exact integration)\n        Me = (h / 12.0) * np.array([\n            [3.0 * r_k + r_k_plus_1, r_k + r_k_plus_1],\n            [r_k + r_k_plus_1, r_k + 3.0 * r_k_plus_1]\n        ])\n        \n        # Assemble into global matrices\n        # The last node (N) has a value of 0, so we only need to consider\n        # contributions up to node N-1.\n        if k < N - 1:\n            K[k:k+2, k:k+2] += Ke\n            M[k:k+2, k:k+2] += Me\n        else: # Last element connects node N-1 to N\n            K[k, k] += Ke[0, 0]\n            M[k, k] += Me[0, 0]\n\n    # 2. Solve the Generalized Eigenvalue Problem\n    # We want the p smallest eigenvalues, which eigh provides by default.\n    eigenvalues, eigenvectors = eigh(K, M)\n    \n    lambda_h = eigenvalues[:p]\n    u_h_vecs = eigenvectors[:, :p]\n    \n    # 3. Compute Analytical Solutions\n    zeros_j0 = jn_zeros(0, p)\n    k_exact = zeros_j0 / R\n    lambda_exact = k_exact**2\n\n    # 4. Compute Error Metrics\n    results_for_case = []\n    r_coords = nodes[:N] # Coordinates for the N unknown DoFs\n\n    for j in range(p):\n        # Relative eigenvalue error\n        E_lambda = np.abs(lambda_h[j] - lambda_exact[j]) / lambda_exact[j]\n        \n        # Relative eigenfunction error\n        u_h = u_h_vecs[:, j]\n        \n        # Sample analytical eigenfunction at nodes\n        e_j = j0(k_exact[j] * r_coords)\n        \n        # Compute optimal scaling factor alpha\n        alpha_num = e_j.T @ M @ u_h\n        alpha_den = e_j.T @ M @ e_j\n        \n        if alpha_den == 0:\n            # This case is highly unlikely with a valid basis\n            E_u = float('inf')\n        else:\n            alpha = alpha_num / alpha_den\n            \n            # Compute M-norms for the error formula\n            numerator_vec = u_h - alpha * e_j\n            num_norm_sq = numerator_vec.T @ M @ numerator_vec\n            den_norm_sq = alpha_den # same as e_j.T @ M @ e_j\n            \n            E_u = np.sqrt(num_norm_sq / den_norm_sq)\n\n        results_for_case.append([E_lambda, E_u])\n        \n    return results_for_case\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 128, 3), # Test case 1\n        (1.0, 12, 2),  # Test case 2\n        (0.75, 96, 3)  # Test case 3\n    ]\n\n    all_results = []\n    for R, N, p in test_cases:\n        case_results = compute_errors(R, N, p)\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Use json.dumps with custom separators to create a compact string representation.\n    output_str = json.dumps(all_results, separators=(',', ':'))\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "For most real-world problems, analytical solutions for verification are not available, so we must rely on the numerical solution itself to estimate its own error. This practice introduces the powerful concept of a posteriori error estimation, a cornerstone of adaptive mesh refinement and solution verification. You will implement a residual-based error estimator for a Discontinuous Galerkin (DG) discretization of the Helmholtz equation, learning how to quantify error by measuring local residuals and inter-element jumps in the discrete solution. ",
            "id": "4145888",
            "problem": "Consider the one-dimensional acoustic Helmholtz problem on a bounded interval domain $\\Omega = (0,L)$ for a harmonic acoustic pressure field $p(x)$ in a homogeneous medium. In the frequency domain, a standard model for linear acoustics reduces to the scalar Helmholtz equation in appropriate nondimensional units,\n$$\n- \\frac{d^2 p}{dx^2} - k^2 p = f \\quad \\text{in } \\Omega,\n$$\nwhere $k > 0$ is the wavenumber and $f(x)$ is a source term. Impose Dirichlet boundary conditions $p(0) = p_D$ and $p(L) = p_D$ for a prescribed boundary value $p_D$.\n\nStarting from the strong form, introduce the standard variational (weak) formulation on the Sobolev space $H^1(\\Omega)$: find $p \\in H^1(\\Omega)$ satisfying the Dirichlet boundary conditions such that, for all test functions $v \\in H^1_0(\\Omega)$,\n$$\n\\int_{\\Omega} \\frac{dp}{dx} \\frac{dv}{dx} \\, dx - k^2 \\int_{\\Omega} p v \\, dx = \\int_{\\Omega} f v \\, dx.\n$$\nTo discretize this problem using Discontinuous Galerkin (DG), specifically the Symmetric Interior Penalty Galerkin method, consider a mesh $\\mathcal{T}_h$ of $\\Omega$ into $N$ nonoverlapping elements $K_e = (x_e, x_{e+1})$ with sizes $h_e = x_{e+1} - x_e$ (uniform in the test suite below), and allow the discrete solution $p_h$ to be piecewise linear on each element with possible discontinuities at inter-element faces.\n\nA residual-based a posteriori error estimator for DG combines element-wise residuals and face jump contributions. In one spatial dimension, for piecewise linear $p_h$ and piecewise constant $f$, the elementwise strong residual reduces to $R_e(x) = f_e + k^2 p_h(x)$ because the second derivative vanishes within each element. The estimator aggregates:\n- Element residual norms, scaled by $h_e^2$,\n- Interior face flux jumps and solution jumps (penalized), scaled by $h_e$ and $h_e^{-1}$ respectively,\n- Boundary face terms reflecting weak imposition of Dirichlet boundary conditions.\n\nLet $p_e^L = p_h(x_e)$ and $p_e^R = p_h(x_{e+1})$ be the left and right endpoint values in element $e$, and let $s_e = (p_e^R - p_e^L)/h_e$ be the element slope. With $p_h(x) = p_e^L + s_e (x - x_e)$ on $K_e$ and a piecewise constant source $f_e$, define $a_e = f_e + k^2 p_e^L$ and $b_e = k^2 s_e$. The element residual $L^2$-norm squared integral is\n$$\n\\int_{K_e} R_e(x)^2 \\, dx = \\int_{0}^{h_e} \\left( a_e + b_e \\xi \\right)^2 \\, d\\xi = a_e^2 h_e + a_e b_e h_e^2 + \\frac{b_e^2 h_e^3}{3}.\n$$\nLet the estimator weight for element residuals be $C_{\\text{res}} > 0$ and for jumps be $C_{\\text{jump}} > 0$, and set the penalty parameter $C_{\\text{pen}} = \\gamma > 0$ consistent with the interior penalty method. For each interior face $i$ at location $x_i$ shared by elements $e$ (left) and $e+1$ (right), define the solution jump and flux jump\n$$\n[p_h]_i = p_e^R - p_{e+1}^L, \\quad [\\partial_n p_h]_i = - s_e + s_{e+1},\n$$\nwith a face length scale $h_i = \\min(h_e, h_{e+1})$. The interior face indicator is\n$$\n\\eta_i^2 = C_{\\text{jump}} \\, h_i \\, \\left( [\\partial_n p_h]_i \\right)^2 + C_{\\text{pen}} \\, h_i^{-1} \\, \\left( [p_h]_i \\right)^2.\n$$\nFor Dirichlet boundary conditions, the boundary face indicators at $x=0$ (left) and $x=L$ (right) are\n$$\n\\eta_{\\text{bnd},0}^2 = C_{\\text{bnd}} \\, h_1^{-1} \\, (p_0^L - p_D)^2 + C_{\\text{flux}} \\, h_1 \\, \\left( -s_0 \\right)^2,\n$$\n$$\n\\eta_{\\text{bnd},L}^2 = C_{\\text{bnd}} \\, h_N^{-1} \\, (p_{N-1}^R - p_D)^2 + C_{\\text{flux}} \\, h_N \\, \\left( +s_{N-1} \\right)^2,\n$$\nwhere $C_{\\text{bnd}}$ and $C_{\\text{flux}}$ are positive weight parameters (for this problem, set $C_{\\text{bnd}} = \\gamma$ and $C_{\\text{flux}} = 1$), and $s_0$ and $s_{N-1}$ are the slopes of the first and last elements, respectively. The global estimator is\n$$\n\\eta = \\left( \\sum_{e=0}^{N-1} C_{\\text{res}} \\, h_e^2 \\int_{K_e} R_e(x)^2 \\, dx \\; + \\sum_{i=1}^{N-1} \\eta_i^2 \\; + \\eta_{\\text{bnd},0}^2 + \\eta_{\\text{bnd},L}^2 \\right)^{1/2}.\n$$\n\nYour task is to implement a complete, runnable program that:\n- Constructs a uniform mesh and evaluates the above residual-based Discontinuous Galerkin (DG) a posteriori error estimator $\\eta$ for three specified test cases.\n- Uses the constants $C_{\\text{res}} = 1$, $C_{\\text{jump}} = 1$, $C_{\\text{pen}} = \\gamma$, $C_{\\text{bnd}} = \\gamma$, and $C_{\\text{flux}} = 1$.\n- Assumes piecewise linear $p_h$ described by the per-element endpoints $\\{(p_e^L, p_e^R)\\}_{e=0}^{N-1}$, piecewise constant $f_e$ per element, uniform element size $h = L/N$, and Dirichlet boundary data $p_D$.\n\nImplement the computation exactly as defined by the equations above.\n\nTest suite (each case is a tuple of $(L, N, k, \\gamma, p_D, \\{(p_e^L, p_e^R)\\}_{e}, \\{f_e\\}_e)$):\n1. Case A (happy path, interior face jumps present, zero source):\n   - $L = 1.0$, $N = 4$, $k = \\pi$, $\\gamma = 10.0$, $p_D = 0.0$.\n   - For $e = 0,1,2,3$ with $h = L/N$, set $x_e = e h$, $x_{e+1} = (e+1) h$, $p_e^L = \\sin(k x_e)$, $p_e^R = \\sin(k x_{e+1}) + \\delta_e$ with $\\delta_e = 0.01 \\cdot (-1)^e$.\n   - $f_e = 0.0$ for all elements.\n2. Case B (boundary-dominated, zero interior residual, nonzero Dirichlet mismatch):\n   - $L = 1.0$, $N = 3$, $k = 2.0$, $\\gamma = 5.0$, $p_D = 0.0$.\n   - Let $c = 0.5$, set $p_e^L = c$ and $p_e^R = c$ for all elements.\n   - Set $f_e = - k^2 c$ for all elements (so that $f_e + k^2 p_h(x) = 0$ in each element).\n3. Case C (single element, both boundary faces active, nonzero source):\n   - $L = 2.0$, $N = 1$, $k = 1.5$, $\\gamma = 20.0$, $p_D = 0.0$.\n   - Set $p_0^L = 1.0$, $p_0^R = -1.0$, and $f_0 = 0.1$.\n\nYour program should produce a single line of output containing the three estimator values $\\eta$ for Cases A, B, and C as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC]\"). Each result must be a floating-point number. No units are required; report pure numerical values in the specified format.",
            "solution": "The problem statement has been critically validated and is deemed valid. It is scientifically grounded in the fields of computational acoustics and numerical analysis, specifically concerning the Discontinuous Galerkin (DG) method and a posteriori error estimation for the Helmholtz equation. The problem is well-posed, providing all necessary definitions, constants, and data to compute a unique numerical result for each specified test case. The language is objective and the mathematical formalism is unambiguous, despite a minor notational inconsistency in element size indexing ($h_1, h_N$) that is rendered moot by the explicit constraint of a uniform mesh for all test cases. The task is to implement a precisely defined mathematical formula, which is a standard exercise in scientific computing.\n\nThe solution requires the implementation of the a posteriori error estimator $\\eta$ for a DG discretization of the one-dimensional Helmholtz equation. The global estimator $\\eta$ is defined as the square root of the sum of three distinct contributions: element residuals, interior face jumps, and boundary face terms.\n\n$$\n\\eta = \\left( \\sum_{e=0}^{N-1} \\eta_{\\text{res},e}^2 \\; + \\sum_{i=1}^{N-1} \\eta_i^2 \\; + \\eta_{\\text{bnd},0}^2 + \\eta_{\\text{bnd},L}^2 \\right)^{1/2}\n$$\n\nThe calculation is implemented in a modular fashion. A main function prepares the specific parameters for each test case, and a general-purpose function computes $\\eta$ based on these parameters.\n\n**1. Element Residual Contribution**\n\nFor each element $K_e = (x_e, x_{e+1})$ in the mesh, where $e \\in \\{0, 1, \\dots, N-1\\}$, the contribution to the estimator is $\\eta_{\\text{res},e}^2 = C_{\\text{res}} \\, h_e^2 \\int_{K_e} R_e(x)^2 \\, dx$. The element size $h_e = x_{e+1} - x_e$ is uniform across all elements, so $h_e = h = L/N$. The element residual is $R_e(x) = f_e + k^2 p_h(x)$, where $f_e$ is a constant source term and the solution $p_h(x)$ is linear, given by $p_h(x) = p_e^L + s_e (x - x_e)$ with slope $s_e = (p_e^R - p_e^L)/h$.\n\nThe squared $L^2$-norm of the residual on element $K_e$ is given by the exact integral:\n$$\n\\int_{K_e} R_e(x)^2 \\, dx = a_e^2 h + a_e b_e h^2 + \\frac{b_e^2 h^3}{3}\n$$\nwhere $a_e = f_e + k^2 p_e^L$ and $b_e = k^2 s_e$. The implementation computes the slope $s_e$ and coefficients $a_e$, $b_e$ for each element, evaluates this integral, scales it by $C_{\\text{res}} h^2$ (with $C_{\\text{res}} = 1$), and adds it to a running total for $\\eta^2$.\n\n**2. Interior Face Jump Contribution**\n\nFor each interior face $i \\in \\{1, \\dots, N-1\\}$, located at $x_i$ between element $i-1$ and element $i$, a penalty term $\\eta_i^2$ is added. This term accounts for discontinuities in the solution $p_h$ and its derivative. It is defined as:\n$$\n\\eta_i^2 = C_{\\text{jump}} \\, h_i \\, \\left( [\\partial_n p_h]_i \\right)^2 + C_{\\text{pen}} \\, h_i^{-1} \\, \\left( [p_h]_i \\right)^2\n$$\nThe constants are given as $C_{\\text{jump}} = 1$ and $C_{\\text{pen}} = \\gamma$. The face length scale $h_i$ is $h$ for our uniform mesh. The solution jump $[p_h]_i$ and the flux jump $[\\partial_n p_h]_i$ are given by:\n$$\n[p_h]_i = p_{i-1}^R - p_i^L\n$$\n$$\n[\\partial_n p_h]_i = - s_{i-1} + s_i\n$$\nThe implementation iterates through the $N-1$ interior faces, calculates these jumps using the pre-computed slopes and given endpoint values, evaluates $\\eta_i^2$, and adds it to the total for $\\eta^2$. For the case $N=1$, there are no interior faces, and this sum is correctly skipped.\n\n**3. Boundary Face Contribution**\n\nThe enforcement of Dirichlet boundary conditions $p(0)=p_D$ and $p(L)=p_D$ contributes two terms to the estimator.\n\nAt the left boundary $x=0$, the term is:\n$$\n\\eta_{\\text{bnd},0}^2 = C_{\\text{bnd}} \\, h^{-1} \\, (p_0^L - p_D)^2 + C_{\\text{flux}} \\, h \\, \\left( -s_0 \\right)^2\n$$\nAt the right boundary $x=L$, the term is:\n$$\n\\eta_{\\text{bnd},L}^2 = C_{\\text{bnd}} \\, h^{-1} \\, (p_{N-1}^R - p_D)^2 + C_{\\text{flux}} \\, h \\, \\left( +s_{N-1} \\right)^2\n$$\nThe constants are $C_{\\text{bnd}} = \\gamma$ and $C_{\\text{flux}} = 1$. The element size $h$ is used in place of the ambiguously indexed $h_1$ and $h_N$ from the problem description, justified by the uniform mesh constraint. The implementation calculates these two terms using the data from the first ($e=0$) and last ($e=N-1$) elements and adds them to $\\eta^2$.\n\nFinally, the total estimator value $\\eta$ is computed as the square root of the accumulated sum of all squared contributions. This procedure is applied to each of the three test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_eta(L, N, k, gamma, p_D, p_list, f_list):\n    \"\"\"\n    Computes the residual-based a posteriori error estimator for a 1D DG method.\n\n    Args:\n        L (float): Domain length.\n        N (int): Number of elements.\n        k (float): Wavenumber.\n        gamma (float): Penalty parameter, also used for C_pen and C_bnd.\n        p_D (float): Dirichlet boundary value.\n        p_list (list of tuples): List of (p_e^L, p_e^R) values for each element.\n        f_list (list of floats): List of source term values f_e for each element.\n\n    Returns:\n        float: The computed error estimator eta.\n    \"\"\"\n    h = L / N\n\n    C_res = 1.0\n    C_jump = 1.0\n    C_pen = gamma\n    C_bnd = gamma\n    C_flux = 1.0\n\n    eta_squared = 0.0\n    \n    slopes = []\n    \n    # Step 1: Sum of Element Residual contributions\n    for e in range(N):\n        p_e_L, p_e_R = p_list[e]\n        f_e = f_list[e]\n        \n        s_e = (p_e_R - p_e_L) / h if h > 0 else 0.0\n        slopes.append(s_e)\n        \n        a_e = f_e + k**2 * p_e_L\n        b_e = k**2 * s_e\n        \n        res_norm_sq = a_e**2 * h + a_e * b_e * h**2 + (b_e**2 * h**3) / 3\n        \n        eta_squared += C_res * h**2 * res_norm_sq\n        \n    # Step 2: Sum of Interior Face Jump contributions\n    # Loop over interior faces i=1, ..., N-1\n    # Face i is between element i-1 and i\n    for i in range(1, N):\n        p_left_R = p_list[i-1][1]\n        p_right_L = p_list[i][0]\n        s_left = slopes[i-1]\n        s_right = slopes[i]\n        \n        h_i = h # Uniform mesh\n        \n        jump_p = p_left_R - p_right_L\n        jump_flux = -s_left + s_right\n        \n        eta_i_sq = C_jump * h_i * jump_flux**2 + C_pen * (h_i**-1) * jump_p**2\n        eta_squared += eta_i_sq\n\n    # Step 3: Boundary Face contributions\n    if N > 0:\n        # Left boundary at x=0\n        p_0_L = p_list[0][0]\n        s_0 = slopes[0]\n        h_bnd_0 = h\n        eta_bnd_0_sq = C_bnd * (h_bnd_0**-1) * (p_0_L - p_D)**2 + C_flux * h_bnd_0 * (-s_0)**2\n        eta_squared += eta_bnd_0_sq\n        \n        # Right boundary at x=L\n        p_N_minus_1_R = p_list[N-1][1]\n        s_N_minus_1 = slopes[N-1]\n        h_bnd_L = h\n        eta_bnd_L_sq = C_bnd * (h_bnd_L**-1) * (p_N_minus_1_R - p_D)**2 + C_flux * h_bnd_L * (s_N_minus_1)**2\n        eta_squared += eta_bnd_L_sq\n        \n    return np.sqrt(eta_squared)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is processed to generate p_list and f_list before being passed\n    # to the calculator function.\n    \n    # Case A\n    L_A, N_A, k_A, gamma_A, p_D_A = 1.0, 4, np.pi, 10.0, 0.0\n    h_A = L_A / N_A\n    p_list_A = []\n    for e in range(N_A):\n        x_e = e * h_A\n        x_e_plus_1 = (e + 1) * h_A\n        delta_e = 0.01 * ((-1)**e)\n        p_e_L = np.sin(k_A * x_e)\n        p_e_R = np.sin(k_A * x_e_plus_1) + delta_e\n        p_list_A.append((p_e_L, p_e_R))\n    f_list_A = [0.0] * N_A\n    case_A = (L_A, N_A, k_A, gamma_A, p_D_A, p_list_A, f_list_A)\n\n    # Case B\n    L_B, N_B, k_B, gamma_B, p_D_B = 1.0, 3, 2.0, 5.0, 0.0\n    c_B = 0.5\n    p_list_B = [(c_B, c_B)] * N_B\n    f_list_B = [-k_B**2 * c_B] * N_B\n    case_B = (L_B, N_B, k_B, gamma_B, p_D_B, p_list_B, f_list_B)\n\n    # Case C\n    L_C, N_C, k_C, gamma_C, p_D_C = 2.0, 1, 1.5, 20.0, 0.0\n    p_list_C = [(1.0, -1.0)]\n    f_list_C = [0.1]\n    case_C = (L_C, N_C, k_C, gamma_C, p_D_C, p_list_C, f_list_C)\n\n    test_cases = [case_A, case_B, case_C]\n    \n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        eta = calculate_eta(*case)\n        results.append(eta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}