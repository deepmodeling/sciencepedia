{
    "hands_on_practices": [
        {
            "introduction": "理论的生命力在于实践。将声学问题的变分形式转化为可计算的离散系统，是有限元方法（FEM）的核心步骤。本练习将指导您完成这一基本过程，即针对一个典型的二维亥姆霍兹问题，手动推导单个三角形单元上的局部矩阵项。通过这个练习，您将深入理解亥姆霍兹算子和罗宾（Robin）边界条件是如何在单元层面被离散化为刚度矩阵、质量矩阵和边界贡献项的，这是构建任何有限元求解器的基础。",
            "id": "4145890",
            "problem": "考虑一个均匀介质中的时谐声压场 $p$，该介质具有恒定的质量密度和声速，在二维域中通过波数为 $k>0$ 的标量 Helmholtz 方程进行建模。设其强形式为 $-\\Delta p - k^{2} p = 0$（在开集 $\\Omega \\subset \\mathbb{R}^{2}$ 中），并附带在部分边界 $\\Gamma_{R} \\subset \\partial \\Omega$ 上的实值阻抗（Robin）边界条件 $\\partial_{n} p + \\alpha p = 0$，其中 $\\alpha>0$ 是一个给定常数，$\\partial_{n}$ 表示外法向导数。假设其余边界为零通量的 Neumann 边界。使用有限元法（FEM），在单个三角形单元 $K$ 上采用线性 Lagrange 基函数，设 $K$ 的顶点为 $(x_{1},y_{1})=(0,0)$、$(x_{2},y_{2})=(1,0)$ 和 $(x_{3},y_{3})=(0,2)$。假设从节点 1 到节点 2 的边位于 $\\Gamma_{R}$ 上，而其他边是内部边。\n\n从强形式出发，推导在 $K$ 上的变分（弱）形式，并指明与 $K$ 的三个顶点相关联的线性 Lagrange 形函数 $\\phi_{1}, \\phi_{2}, \\phi_{3}$。然后，对该单元计算单元级双线性形式的各项\n$$\na_{ij}^{(K)} \\;=\\; \\int_{K} \\nabla \\phi_{i} \\cdot \\nabla \\phi_{j} \\, dx \\;-\\; k^{2} \\int_{K} \\phi_{i}\\,\\phi_{j}\\, dx \\;+\\; \\int_{\\partial K \\cap \\Gamma_{R}} \\alpha\\, \\phi_{i}\\,\\phi_{j}\\, ds\n$$\n对所有 $i,j \\in \\{1,2,3\\}$。\n\n将最终答案表示为顺序为 $\\left(a_{11}^{(K)},\\,a_{12}^{(K)},\\,a_{13}^{(K)},\\,a_{21}^{(K)},\\,a_{22}^{(K)},\\,a_{23}^{(K)},\\,a_{31}^{(K)},\\,a_{32}^{(K)},\\,a_{33}^{(K)}\\right)$ 的单行矩阵，使用精确计算，并将 $k$ 和 $\\alpha$ 保留为符号参数。无需四舍五入，也无需指定单位。",
            "solution": "均匀介质中时谐声学的控制方程是标量 Helmholtz 方程。从小振幅扰动的质量和动量守恒出发，并应用角频率为 $\\omega$ 的时谐设想 $p(\\mathbf{x},t)=\\Re\\{P(\\mathbf{x})\\exp(-\\mathrm{i}\\omega t)\\}$，可以得到空间振幅 $P$ 的边值问题 $-\\Delta P - k^{2} P = 0$，其中 $k=\\omega/c$ 是波数。在 $\\Gamma_{R}$ 上施加实值阻抗（Robin）边界条件 $\\partial_{n} P + \\alpha P = 0$ 并在其他地方施加齐次 Neumann 条件，通过将强形式乘以一个测试函数 $v$ 并进行分部积分，可以得到子域 $K \\subset \\Omega$ 上的变分（弱）形式：\n$$\n\\int_{K} (-\\Delta p)\\, v \\, dx - k^{2} \\int_{K} p\\, v \\, dx = 0.\n$$\n使用恒等式\n$$\n\\int_{K} (-\\Delta p)\\, v \\, dx = \\int_{K} \\nabla p \\cdot \\nabla v \\, dx - \\int_{\\partial K} \\partial_{n} p \\, v \\, ds,\n$$\n并施加边界条件，Robin 边上的自然边界贡献为\n$$\n-\\int_{\\partial K \\cap \\Gamma_{R}} \\partial_{n} p \\, v \\, ds = \\int_{\\partial K \\cap \\Gamma_{R}} \\alpha \\, p \\, v \\, ds,\n$$\n而零通量的 Neumann 边界对双线性形式没有贡献。因此，单元级双线性形式为\n$$\na^{(K)}(p,v) \\;=\\; \\int_{K} \\nabla p \\cdot \\nabla v \\, dx \\;-\\; k^{2} \\int_{K} p\\, v \\, dx \\;+\\; \\int_{\\partial K \\cap \\Gamma_{R}} \\alpha\\, p\\, v\\, ds.\n$$\n在有限元法（FEM）中，对于顶点为 $(0,0)$、$(1,0)$、$(0,2)$ 的三角形 $K$ 使用线性 Lagrange 基函数，其标准节点形函数 $\\{\\phi_{i}\\}_{i=1}^{3}$ 是重心坐标。使用面积坐标表示，\n$$\n\\phi_{i}(x,y) \\;=\\; \\frac{a_{i} + b_{i} x + c_{i} y}{2A},\n$$\n其中 $A$ 是 $K$ 的面积，对于每个顶点 $i$，$(a_{i},b_{i},c_{i})$ 由另外两个顶点 $(x_{j},y_{j})$ 和 $(x_{k},y_{k})$ 计算得出：\n$$\na_{i} = x_{j} y_{k} - x_{k} y_{j}, \\quad b_{i} = y_{j} - y_{k}, \\quad c_{i} = x_{k} - x_{j}.\n$$\n对于我们的三角形，面积为\n$$\nA \\;=\\; \\frac{1}{2} \\, |(x_{2}-x_{1})(y_{3}-y_{1}) - (x_{3}-x_{1})(y_{2}-y_{1})| \\;=\\; \\frac{1}{2}\\,(1\\cdot 2 - 0\\cdot 0) \\;=\\; 1.\n$$\n计算 $(a_{i},b_{i},c_{i})$：\n- 对于 $i=1$，$(j,k)=(2,3)$，\n$$\na_{1} = x_{2} y_{3} - x_{3} y_{2} = 1\\cdot 2 - 0\\cdot 0 = 2,\\quad b_{1} = y_{2} - y_{3} = 0 - 2 = -2,\\quad c_{1} = x_{3} - x_{2} = 0 - 1 = -1,\n$$\n所以\n$$\n\\phi_{1}(x,y) = \\frac{2 - 2x - y}{2} = 1 - x - \\frac{y}{2}.\n$$\n- 对于 $i=2$，$(j,k)=(3,1)$，\n$$\na_{2} = x_{3} y_{1} - x_{1} y_{3} = 0\\cdot 0 - 0\\cdot 2 = 0,\\quad b_{2} = y_{3} - y_{1} = 2 - 0 = 2,\\quad c_{2} = x_{1} - x_{3} = 0 - 0 = 0,\n$$\n所以\n$$\n\\phi_{2}(x,y) = \\frac{0 + 2x + 0\\cdot y}{2} = x.\n$$\n- 对于 $i=3$，$(j,k)=(1,2)$，\n$$\na_{3} = x_{1} y_{2} - x_{2} y_{1} = 0\\cdot 0 - 1\\cdot 0 = 0,\\quad b_{3} = y_{1} - y_{2} = 0 - 0 = 0,\\quad c_{3} = x_{2} - x_{1} = 1 - 0 = 1,\n$$\n所以\n$$\n\\phi_{3}(x,y) = \\frac{0 + 0\\cdot x + 1\\cdot y}{2} = \\frac{y}{2}.\n$$\n梯度在 $K$ 上是常数：\n$$\n\\nabla \\phi_{i} = \\frac{1}{2A}\\,(b_{i},\\,c_{i}) = \\frac{1}{2}\\,(b_{i},\\,c_{i}),\n$$\n得到\n$$\n\\nabla \\phi_{1} = \\left(-1,\\,-\\frac{1}{2}\\right),\\quad \\nabla \\phi_{2} = (1,\\,0),\\quad \\nabla \\phi_{3} = \\left(0,\\,\\frac{1}{2}\\right).\n$$\n因为这些是常数，所以类刚度贡献为\n$$\n\\int_{K} \\nabla \\phi_{i} \\cdot \\nabla \\phi_{j}\\, dx = A\\, \\nabla \\phi_{i} \\cdot \\nabla \\phi_{j} = \\nabla \\phi_{i} \\cdot \\nabla \\phi_{j},\n$$\n其中 $A=1$。计算所有点积：\n$$\n\\nabla \\phi_{1} \\cdot \\nabla \\phi_{1} = 1 + \\frac{1}{4} = \\frac{5}{4},\\quad \\nabla \\phi_{1} \\cdot \\nabla \\phi_{2} = -1,\\quad \\nabla \\phi_{1} \\cdot \\nabla \\phi_{3} = -\\frac{1}{4},\n$$\n$$\n\\nabla \\phi_{2} \\cdot \\nabla \\phi_{2} = 1,\\quad \\nabla \\phi_{2} \\cdot \\nabla \\phi_{3} = 0,\\quad \\nabla \\phi_{3} \\cdot \\nabla \\phi_{3} = \\frac{1}{4}.\n$$\n接下来，在面积为 $A=1$ 的三角形上的协调 $P_{1}$ 类质量贡献为\n$$\n\\int_{K} \\phi_{i}\\,\\phi_{j}\\, dx =\n\\begin{cases}\n\\frac{1}{6},  \\text{if } i=j \\\\\n\\frac{1}{12},  \\text{if } i \\neq j\n\\end{cases}\n$$\n这可以通过直接积分或使用线性三角形单元的标准公式来验证。因此，内部双线性项为\n$$\n\\left[\\int_{K} \\nabla \\phi_{i} \\cdot \\nabla \\phi_{j}\\, dx\\right] - k^{2}\\left[\\int_{K} \\phi_{i}\\,\\phi_{j}\\, dx\\right]\n=\n\\begin{cases}\n\\frac{5}{4} - \\frac{k^{2}}{6},  (i,j)=(1,1) \\\\\n-1 - \\frac{k^{2}}{12},  (i,j)=(1,2)\\text{ or }(2,1) \\\\\n-\\frac{1}{4} - \\frac{k^{2}}{12},  (i,j)=(1,3)\\text{ or }(3,1) \\\\\n1 - \\frac{k^{2}}{6},  (i,j)=(2,2) \\\\\n-\\frac{k^{2}}{12},  (i,j)=(2,3)\\text{ or }(3,2) \\\\\n\\frac{1}{4} - \\frac{k^{2}}{6},  (i,j)=(3,3)\n\\end{cases}\n$$\n现在考虑在 $\\partial K \\cap \\Gamma_{R}$ 上的 Robin 边界积分，即从节点 1 到节点 2 的边。将该边参数化为 $x \\in [0,1]$，其中 $y=0$ 且 $ds=dx$。受限形函数为 $\\phi_{1}(x,0) = 1 - x$、$\\phi_{2}(x,0) = x$ 和 $\\phi_{3}(x,0) = 0$。边界贡献为\n$$\n\\int_{\\partial K \\cap \\Gamma_{R}} \\alpha\\, \\phi_{1}\\,\\phi_{1}\\, ds = \\alpha \\int_{0}^{1} (1-x)^{2}\\, dx = \\alpha \\cdot \\frac{1}{3} = \\frac{\\alpha}{3},\n$$\n$$\n\\int_{\\partial K \\cap \\Gamma_{R}} \\alpha\\, \\phi_{2}\\,\\phi_{2}\\, ds = \\alpha \\int_{0}^{1} x^{2}\\, dx = \\alpha \\cdot \\frac{1}{3} = \\frac{\\alpha}{3},\n$$\n$$\n\\int_{\\partial K \\cap \\Gamma_{R}} \\alpha\\, \\phi_{1}\\,\\phi_{2}\\, ds = \\alpha \\int_{0}^{1} x(1-x)\\, dx = \\alpha \\cdot \\frac{1}{6} = \\frac{\\alpha}{6},\n$$\n且所有涉及 $\\phi_{3}$ 的项在该边上都为零。将内部和边界贡献相加，得到完整的单元双线性项：\n$$\na_{11}^{(K)} = \\frac{5}{4} - \\frac{k^{2}}{6} + \\frac{\\alpha}{3},\\quad\na_{12}^{(K)} = -1 - \\frac{k^{2}}{12} + \\frac{\\alpha}{6},\\quad\na_{13}^{(K)} = -\\frac{1}{4} - \\frac{k^{2}}{12},\n$$\n$$\na_{21}^{(K)} = -1 - \\frac{k^{2}}{12} + \\frac{\\alpha}{6},\\quad\na_{22}^{(K)} = 1 - \\frac{k^{2}}{6} + \\frac{\\alpha}{3},\\quad\na_{23}^{(K)} = -\\frac{k^{2}}{12},\n$$\n$$\na_{31}^{(K)} = -\\frac{1}{4} - \\frac{k^{2}}{12},\\quad\na_{32}^{(K)} = -\\frac{k^{2}}{12},\\quad\na_{33}^{(K)} = \\frac{1}{4} - \\frac{k^{2}}{6}.\n$$\n如预期，这些项关于 $i$ 和 $j$ 是对称的。最终行矩阵所要求的顺序是 $\\left(a_{11}^{(K)},\\,a_{12}^{(K)},\\,a_{13}^{(K)},\\,a_{21}^{(K)},\\,a_{22}^{(K)},\\,a_{23}^{(K)},\\,a_{31}^{(K)},\\,a_{32}^{(K)},\\,a_{33}^{(K)}\\right)$。",
            "answer": "$$\\boxed{\\begin{pmatrix}\n\\frac{5}{4} - \\frac{k^{2}}{6} + \\frac{\\alpha}{3}  -1 - \\frac{k^{2}}{12} + \\frac{\\alpha}{6}  -\\frac{1}{4} - \\frac{k^{2}}{12} \\\\ -1 - \\frac{k^{2}}{12} + \\frac{\\alpha}{6}  1 - \\frac{k^{2}}{6} + \\frac{\\alpha}{3}  -\\frac{k^{2}}{12} \\\\ -\\frac{1}{4} - \\frac{k^{2}}{12}  -\\frac{k^{2}}{12}  \\frac{1}{4} - \\frac{k^{2}}{6}\n\\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了如何构建单个单元的矩阵之后，下一步自然是将这些“积木”组装成一个完整的全局系统并进行求解。本练习将引导您构建一个完整的、虽简化但功能齐全的有限元求解器，用于解决一个经典的声学基准问题——圆形腔体的本征模态。这个实践不仅展示了如何通过轴对称简化将二维问题降维处理，更重要的是，它强调了科学计算中至关重要的工作流程：通过与贝塞尔函数给出的解析解进行比对，来验证数值模型的正确性，这是确保计算结果可靠性的基石。",
            "id": "4145864",
            "problem": "考虑半径为 $R$ 的二维圆形腔体中的时谐声压场，该声压场被建模为拉普拉斯算子在边界上施加齐次狄利克雷边界条件下的内部特征值问题的解。设空间域为圆盘 $D = \\{ (x,y) \\in \\mathbb{R}^2 \\mid x^2 + y^2  R^2 \\}$，边界为 $\\partial D = \\{ (x,y) \\in \\mathbb{R}^2 \\mid x^2 + y^2 = R^2 \\}$。其控制强形式为：求非平凡解 $u$ 和 $\\lambda \\in \\mathbb{R}$，使得\n$$\n- \\Delta u = \\lambda\\, u \\quad \\text{in } D, \\qquad u = 0 \\quad \\text{on } \\partial D.\n$$\n从该强形式出发，推导其变分（弱）形式：求 $u \\in V$ 和 $\\lambda \\in \\mathbb{R}$，使得\n$$\na(u,v) = \\lambda\\, m(u,v) \\quad \\text{for all } v \\in V,\n$$\n其中 $V$ 是合适的函数空间。请明确指出函数空间 $V$、双线性形式 $a(\\cdot,\\cdot)$ 以及双线性形式 $m(\\cdot,\\cdot)$ 的基本量表示。解释对称性和变量分离法如何证明将注意力限制在轴对称子空间是合理的，然后推导在区间 $[0,R]$ 上相应的一维径向弱形式，其权重由极坐标雅可比行列式确定。\n\n使用有限元法（FEM）实现伽辽金近似，在径向区间 $[0,R]$ 的均匀剖分（$N$ 个单元）上使用连续分片线性基函数。将 $r=R$ 处的狄利克雷边界条件作为本质边界条件强制施加。组装与带正确权重的径向弱形式相对应的离散刚度矩阵 $\\mathbf{K}$ 和质量矩阵 $\\mathbf{M}$。建立并求解矩阵广义特征值问题\n$$\n\\mathbf{K}\\,\\mathbf{u} = \\lambda_h\\, \\mathbf{M}\\,\\mathbf{u},\n$$\n以计算前 $p$ 个轴对称离散特征对 $(\\lambda_h^{(j)}, \\mathbf{u}^{(j)})$。\n\n解析的轴对称特征对由零阶第一类贝塞尔函数给出，其特征函数为 $u^{(j)}_{\\text{exact}}(r) = J_0(k_j r)$，波数 $k_j$ 由 $J_0$ 在 $r=R$ 处的零点确定，即 $J_0(k_j R) = 0$，特征值为 $\\lambda^{(j)}_{\\text{exact}} = k_j^2$。请精确描述如何计算与这些解析解相比较的两种误差度量：\n- 相对特征值误差，定义为\n$$\nE_{\\lambda}^{(j)} = \\frac{\\left| \\lambda_h^{(j)} - \\lambda_{\\text{exact}}^{(j)} \\right|}{\\lambda_{\\text{exact}}^{(j)}}.\n$$\n- 由质量双线性形式导出的加权 $L^2$ 范数下的相对特征函数误差，其中解析函数经过最优缩放以最佳拟合离散特征向量。具体而言，若 $\\mathbf{e}^{(j)}$ 表示在有限元节点（不包括 $r=R$ 处的狄利克雷节点）处采样的解析特征函数，定义\n$$\n\\alpha^{(j)} = \\frac{\\mathbf{e}^{(j)T}\\mathbf{M}\\,\\mathbf{u}^{(j)}}{\\mathbf{e}^{(j)T}\\mathbf{M}\\,\\mathbf{e}^{(j)}}, \\qquad\nE_{u}^{(j)} = \\frac{ \\left\\| \\mathbf{u}^{(j)} - \\alpha^{(j)} \\mathbf{e}^{(j)} \\right\\|_{\\mathbf{M}} }{ \\left\\| \\mathbf{e}^{(j)} \\right\\|_{\\mathbf{M}} },\n$$\n其中 $\\left\\| \\mathbf{w} \\right\\|_{\\mathbf{M}} = \\sqrt{\\mathbf{w}^T \\mathbf{M} \\mathbf{w}}$。\n\n你的任务是编写一个完整、可运行的程序，该程序：\n1. 为 $[0,R]$ 上的轴对称弱形式组装一维径向有限元刚度矩阵和质量矩阵，并在 $r=R$ 处施加齐次狄利克雷边界条件。\n2. 求解前 $p$ 个离散特征对。\n3. 使用 $J_0$ 的零点计算解析的轴对称特征值和特征函数。\n4. 对每个 $j=1,\\dots,p$ 计算 $E_{\\lambda}^{(j)}$ 和 $E_{u}^{(j)}$。\n5. 汇总所提供的测试套件的结果，并将其作为单行打印。\n\n使用以下测试套件的参数值，涵盖一般情况、粗糙离散化情况和半径改变的情况：\n- 测试用例1（一般情况）：$R = 1.0$, $N = 128$, $p = 3$。\n- 测试用例2（粗糙离散化边界情况）：$R = 1.0$, $N = 12$, $p = 2$。\n- 测试用例3（半径改变情况）：$R = 0.75$, $N = 96$, $p = 3$。\n\n最终输出格式：你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，无空格。每个测试用例的结果本身必须是一个模式对的列表，其中每个模式对的形式为 $[E_{\\lambda}^{(j)},E_{u}^{(j)}]$，$j=1,\\dots,p$。例如，一个可能的输出结构是\n$$\n\\big[ \\big[ [E_{\\lambda}^{(1)},E_{u}^{(1)}], [E_{\\lambda}^{(2)},E_{u}^{(2)}], \\dots \\big], \\big[ [\\cdot,\\cdot], \\dots \\big], \\big[ [\\cdot,\\cdot], \\dots \\big] \\big],\n$$\n打印为单行，无空格。所有数值应为普通或科学记数法表示的浮点数。由于问题是无量纲化的，不需要物理单位；不涉及角度；不得使用百分比。",
            "solution": "所提出的问题是计算声学中一个完整且适定的练习，具体涉及内部轴对称特征值问题的有限元分析。它在科学上是合理的，在数学上是严谨的，并包含了唯一解所需的所有信息。我们将首先推导所需的数学公式，然后按照规定实现数值解。\n\n### 第1部分：变分（弱）形式的推导\n\n问题的强形式是找到一个特征函数 $u$ 和一个特征值 $\\lambda \\in \\mathbb{R}$，使得：\n$$\n\\begin{cases}\n- \\Delta u = \\lambda u  \\text{ in } D \\\\\nu = 0  \\text{ on } \\partial D\n\\end{cases}\n$$\n其中 $D$ 是半径为 $R$ 的圆盘。\n\n为了推导弱形式，我们将控制偏微分方程乘以一个测试函数 $v$。该测试函数必须属于一个满足齐次狄利克雷边界条件的函数空间。合适的空间是索博列夫空间 $V = H_0^1(D)$，它由平方可积、一阶导数平方可积且在边界 $\\partial D$ 上为零的函数组成。\n\n乘以 $v \\in V$ 并在域 $D$ 上积分，得到：\n$$\n- \\int_D (\\Delta u) v \\, dA = \\lambda \\int_D u v \\, dA\n$$\n我们对左侧应用 Green 第一恒等式（多维分部积分）：\n$$\n\\int_D (\\nabla u \\cdot \\nabla v) \\, dA - \\int_{\\partial D} v (\\nabla u \\cdot \\mathbf{n}) \\, dS = \\lambda \\int_D u v \\, dA\n$$\n其中 $\\mathbf{n}$ 是边界 $\\partial D$ 的外单位法向量。边界积分 $\\int_{\\partial D} v (\\nabla u \\cdot \\mathbf{n}) \\, dS$ 为零，因为根据空间 $V=H_0^1(D)$ 的定义，测试函数 $v$ 在 $\\partial D$ 上为零。\n\n这导出了变分（弱）形式：求 $u \\in V$ 和 $\\lambda \\in \\mathbb{R}$，使得对于所有 $v \\in V$：\n$$\n\\int_D (\\nabla u \\cdot \\nabla v) \\, dA = \\lambda \\int_D u v \\, dA\n$$\n该方程形如 $a(u,v) = \\lambda m(u,v)$，其中：\n- 函数空间为 $V = H_0^1(D)$。\n- 刚度双线性形式为 $a(u,v) = \\int_D (\\nabla u \\cdot \\nabla v) \\, dA$。\n- 质量双线性形式为 $m(u,v) = \\int_D u v \\, dA$。\n$a(\\cdot,\\cdot)$ 和 $m(\\cdot,\\cdot)$ 都是对称且（在指定空间上）正定的，这确保了特征值 $\\lambda$ 是实数且为正。\n\n### 第2部分：简化为轴对称一维形式\n\n域的圆形几何结构允许存在轴对称解，即与角坐标 $\\theta$ 无关的解。在极坐标 $(r, \\theta)$ 中，这样的函数形式为 $u(r, \\theta) = u(r)$。极坐标中的拉普拉斯算子是 $\\Delta = \\frac{1}{r}\\frac{\\partial}{\\partial r}(r \\frac{\\partial}{\\partial r}) + \\frac{1}{r^2}\\frac{\\partial^2}{\\partial \\theta^2}$。对于轴对称函数，角向导数消失，因此 $\\Delta u = \\frac{1}{r}\\frac{d}{dr}(r \\frac{du}{dr})$。\n\n强形式简化为在区间 $[0, R]$ 上的常微分方程：\n$$\n-\\frac{1}{r}\\frac{d}{dr}\\left(r \\frac{du}{dr}\\right) = \\lambda u(r), \\quad u(R)=0, \\quad u'(0)=0\n$$\n条件 $u'(0)=0$ 是为保证在原点处的光滑性所必需的自然边界条件。\n\n为了推导相应的一维弱形式，我们在极坐标中表示二维双线性形式。面积元为 $dA = r\\,dr\\,d\\theta$。轴对称函数 $u(r)$ 的梯度为 $\\nabla u = (u'(r), 0)$。因此，对于两个轴对称函数 $u(r)$ 和 $v(r)$，它们的点积为 $\\nabla u \\cdot \\nabla v = u'(r)v'(r)$。\n\n将这些代入二维弱形式：\n$$\na(u,v) = \\int_0^{2\\pi} \\int_0^R (u'v') r\\,dr\\,d\\theta = 2\\pi \\int_0^R u'(r)v'(r) r\\,dr\n$$\n$$\nm(u,v) = \\int_0^{2\\pi} \\int_0^R (uv) r\\,dr\\,d\\theta = 2\\pi \\int_0^R u(r)v(r) r\\,dr\n$$\n常数因子 $2\\pi$ 出现在 $a(u,v) = \\lambda m(u,v)$ 的两边，可以消去。这得到一维径向弱形式：求 $u \\in V_r$，使得对于所有 $v \\in V_r$：\n$$\n\\int_0^R u'v' r\\,dr = \\lambda \\int_0^R uv r\\,dr\n$$\n在这里，函数空间是 $V_r = \\{ v \\in H^1((0,R)) \\mid v(R)=0 \\}$，积分中的径向权重 $r$ 源于从笛卡尔坐标到极坐标变换的雅可比行列式。\n\n### 第3部分：有限元法（FEM）离散化\n\n我们使用伽辽金法和连续分片线性基函数对一维径向弱形式进行离散化。我们将区间 $[0,R]$ 剖分为 $N$ 个大小相等的单元，单元尺寸为 $h=R/N$，节点为 $r_i = ih$，$i=0,\\dots,N$。解被近似为线性组合 $u_h(r) = \\sum_{j=0}^{N-1} u_j \\phi_j(r)$，其中 $\\phi_j(r)$ 是标准的线性“帽”基函数，$u_j$ 是节点值。齐次狄利克雷条件 $u(R)=0$ 通过设置 $u_N=0$ 并从试探空间中排除基函数 $\\phi_N(r)$ 作为本质边界条件强制执行。这导致了 $N$ 个未知的自由度，$u_0, \\dots, u_{N-1}$。\n\n伽辽金过程导出矩阵广义特征值问题 $\\mathbf{K}\\mathbf{u} = \\lambda_h \\mathbf{M}\\mathbf{u}$，其中刚度矩阵 $\\mathbf{K}$ 和质量矩阵 $\\mathbf{M}$ 的项由下式给出：\n$$\nK_{ij} = \\int_0^R \\phi_j' \\phi_i' r\\,dr, \\quad M_{ij} = \\int_0^R \\phi_j \\phi_i r\\,dr \\quad \\text{for } i,j \\in \\{0, \\dots, N-1\\}\n$$\n这些全局矩阵由局部（单元）矩阵贡献组装而成。对于一个通用单元 $e_k = [r_k, r_{k+1}]$，通过在该单元上积分来计算局部刚度矩阵 $(\\mathbf{K}^e_k)$ 和质量矩阵 $(\\mathbf{M}^e_k)$。\n\n局部刚度矩阵为：\n$$\n\\mathbf{K}^e_k = \\frac{r_k+r_{k+1}}{2h}\n\\begin{pmatrix}\n1  -1 \\\\\n-1  1\n\\end{pmatrix}\n$$\n局部质量矩阵，使用精确积分处理线性基函数和线性变化的权重 $r$：\n$$\n\\mathbf{M}^e_k = \\frac{h}{12}\n\\begin{pmatrix}\n3r_k+r_{k+1}  r_k+r_{k+1} \\\\\nr_k+r_{k+1}  r_k+3r_{k+1}\n\\end{pmatrix}\n$$\n然后，这些 $2 \\times 2$ 的单元矩阵被组装成全局的 $N \\times N$ 矩阵 $\\mathbf{K}$ 和 $\\mathbf{M}$。\n\n### 第4部分：误差度量\n\n解析解涉及零阶第一类贝塞尔函数 $J_0$。特征函数为 $u^{(j)}_{\\text{exact}}(r) = J_0(k_j r)$，其中波数 $k_j$ 由 $J_0(k_j R) = 0$ 的根确定。如果 $z_j$ 是 $J_0(z)=0$ 的第 $j$ 个正根，那么 $k_j = z_j/R$。相应的精确特征值为 $\\lambda^{(j)}_{\\text{exact}} = k_j^2 = (z_j/R)^2$。\n\n误差度量计算如下：\n1.  **相对特征值误差**：对于第 $j$ 个模式，这是数值计算的特征值 $\\lambda_h^{(j)}$ 与解析特征值 $\\lambda_{\\text{exact}}^{(j)}$ 之间的直接比较：\n    $$\n    E_{\\lambda}^{(j)} = \\frac{\\left| \\lambda_h^{(j)} - \\lambda_{\\text{exact}}^{(j)} \\right|}{\\lambda_{\\text{exact}}^{(j)}}\n    $$\n2.  **相对特征函数误差**：该度量衡量离散特征向量 $\\mathbf{u}^{(j)}$ 与采样的解析特征函数 $\\mathbf{e}^{(j)}$ 之间的形状差异，其中 $\\mathbf{e}^{(j)}_i = J_0(k_j r_i)$。为了考虑计算出的特征向量的任意缩放，解析向量首先按一个最优因子 $\\alpha^{(j)}$ 进行缩放，该因子使质量矩阵 $\\mathbf{M}$ 导出的范数下的误差最小化。\n    缩放因子 $\\alpha^{(j)}$ 是 $\\mathbf{u}^{(j)}$ 在 $\\mathbf{M}$-内积意义下到 $\\mathbf{e}^{(j)}$ 上的投影：\n    $$\n    \\alpha^{(j)} = \\frac{\\langle \\mathbf{e}^{(j)}, \\mathbf{u}^{(j)} \\rangle_{\\mathbf{M}}}{\\langle \\mathbf{e}^{(j)}, \\mathbf{e}^{(j)} \\rangle_{\\mathbf{M}}} = \\frac{\\mathbf{e}^{(j)T}\\mathbf{M}\\,\\mathbf{u}^{(j)}}{\\mathbf{e}^{(j)T}\\mathbf{M}\\,\\mathbf{e}^{(j)}}\n    $$\n    然后，误差是残差的 $\\mathbf{M}$-范数与缩放后解析向量的 $\\mathbf{M}$-范数之比：\n    $$\n    E_{u}^{(j)} = \\frac{ \\left\\| \\mathbf{u}^{(j)} - \\alpha^{(j)} \\mathbf{e}^{(j)} \\right\\|_{\\mathbf{M}} }{ \\left\\| \\mathbf{e}^{(j)} \\right\\|_{\\mathbf{M}} } = \\sqrt{\\frac{ (\\mathbf{u}^{(j)} - \\alpha^{(j)} \\mathbf{e}^{(j)})^T \\mathbf{M} (\\mathbf{u}^{(j)} - \\alpha^{(j)} \\mathbf{e}^{(j)}) }{ \\mathbf{e}^{(j)T} \\mathbf{M} \\mathbf{e}^{(j)} }}\n    $$\n以下程序实现了这整个过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\nfrom scipy.special import jn_zeros, j0\nimport json\n\ndef compute_errors(R, N, p):\n    \"\"\"\n    Assembles FEM matrices, solves the eigenvalue problem, and computes errors.\n\n    Args:\n        R (float): Radius of the circular cavity.\n        N (int): Number of elements for the radial discretization.\n        p (int): Number of eigenmodes to compute.\n\n    Returns:\n        list: A list of pairs [E_lambda, E_u] for each of the p modes.\n    \"\"\"\n    \n    # 1. Discretization and Matrix Assembly\n    h = R / N\n    nodes = np.linspace(0, R, N + 1)\n    \n    # The system size is N x N for the N unknown nodal values (u_0 to u_{N-1})\n    K = np.zeros((N, N))\n    M = np.zeros((N, N))\n    \n    # Loop over elements to assemble global matrices\n    for k in range(N):\n        r_k = nodes[k]\n        r_k_plus_1 = nodes[k+1]\n        \n        # Element stiffness matrix\n        ke_factor = (r_k + r_k_plus_1) / (2.0 * h)\n        Ke = ke_factor * np.array([[1.0, -1.0], [-1.0, 1.0]])\n        \n        # Element mass matrix (exact integration)\n        Me = (h / 12.0) * np.array([\n            [3.0 * r_k + r_k_plus_1, r_k + r_k_plus_1],\n            [r_k + r_k_plus_1, r_k + 3.0 * r_k_plus_1]\n        ])\n        \n        # Assemble into global matrices\n        # The last node (N) has a value of 0, so we only need to consider\n        # contributions up to node N-1.\n        if k  N - 1:\n            K[k:k+2, k:k+2] += Ke\n            M[k:k+2, k:k+2] += Me\n        else: # Last element connects node N-1 to N\n            K[k, k] += Ke[0, 0]\n            M[k, k] += Me[0, 0]\n\n    # 2. Solve the Generalized Eigenvalue Problem\n    # We want the p smallest eigenvalues, which eigh provides by default.\n    eigenvalues, eigenvectors = eigh(K, M)\n    \n    lambda_h = eigenvalues[:p]\n    u_h_vecs = eigenvectors[:, :p]\n    \n    # 3. Compute Analytical Solutions\n    zeros_j0 = jn_zeros(0, p)\n    k_exact = zeros_j0 / R\n    lambda_exact = k_exact**2\n\n    # 4. Compute Error Metrics\n    results_for_case = []\n    r_coords = nodes[:N] # Coordinates for the N unknown DoFs\n\n    for j in range(p):\n        # Relative eigenvalue error\n        E_lambda = np.abs(lambda_h[j] - lambda_exact[j]) / lambda_exact[j]\n        \n        # Relative eigenfunction error\n        u_h = u_h_vecs[:, j]\n        \n        # Sample analytical eigenfunction at nodes\n        e_j = j0(k_exact[j] * r_coords)\n        \n        # Compute optimal scaling factor alpha\n        alpha_num = e_j.T @ M @ u_h\n        alpha_den = e_j.T @ M @ e_j\n        \n        if alpha_den == 0:\n            # This case is highly unlikely with a valid basis\n            E_u = float('inf')\n        else:\n            alpha = alpha_num / alpha_den\n            \n            # Compute M-norms for the error formula\n            numerator_vec = u_h - alpha * e_j\n            num_norm_sq = numerator_vec.T @ M @ numerator_vec\n            den_norm_sq = alpha_den # same as e_j.T @ M @ e_j\n            \n            E_u = np.sqrt(num_norm_sq / den_norm_sq)\n\n        results_for_case.append([E_lambda, E_u])\n        \n    return results_for_case\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 128, 3), # Test case 1\n        (1.0, 12, 2),  # Test case 2\n        (0.75, 96, 3)  # Test case 3\n    ]\n\n    all_results = []\n    for R, N, p in test_cases:\n        case_results = compute_errors(R, N, p)\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Use json.dumps with custom separators to create a compact string representation.\n    output_str = json.dumps(all_results, separators=(',', ':'))\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "数值解本质上是一种近似。在获得计算结果后，一个关键问题是：“这个近似的质量如何？”本节的最后一个练习将介绍一种高级技术来回答这个问题。我们将超越传统的有限元方法，探索更为灵活和强大的非连续伽辽金（Discontinuous Galerkin, DG）方法。通过这个实践，您将学习如何实现一种基于残差的后验误差估计器，它利用已求得的数值解自身来评估误差大小。这不仅能衡量解的精度，更为自适应网格加密等高级技术提供了理论依据，是提升计算效率和精度的关键所在。",
            "id": "4145888",
            "problem": "考虑均匀介质中谐波声压场 $p(x)$ 在有界区间域 $\\Omega = (0,L)$ 上的一维声学 Helmholtz 问题。在频域中，线性声学的标准模型在适当的无量纲单位下可简化为标量 Helmholtz 方程，\n$$\n- \\frac{d^2 p}{dx^2} - k^2 p = f \\quad \\text{in } \\Omega,\n$$\n其中 $k  0$ 是波数，$f(x)$ 是源项。施加 Dirichlet 边界条件 $p(0) = p_D$ 和 $p(L) = p_D$，其中 $p_D$ 是指定的边界值。\n\n从强形式出发，在 Sobolev 空间 $H^1(\\Omega)$ 上引入标准的变分（弱）形式：求满足 Dirichlet 边界条件的 $p \\in H^1(\\Omega)$，使得对于所有测试函数 $v \\in H^1_0(\\Omega)$，\n$$\n\\int_{\\Omega} \\frac{dp}{dx} \\frac{dv}{dx} \\, dx - k^2 \\int_{\\Omega} p v \\, dx = \\int_{\\Omega} f v \\, dx.\n$$\n为使用间断 Galerkin (DG) 方法（特别是对称内部罚 Galerkin 方法）对此问题进行离散化，考虑将 $\\Omega$ 剖分为一个由 $N$ 个不重叠单元 $K_e = (x_e, x_{e+1})$ 组成的网格 $\\mathcal{T}_h$，单元尺寸为 $h_e = x_{e+1} - x_e$（在下文的测试套件中是均匀的）。允许离散解 $p_h$ 在每个单元上是分片线性的，并在单元间界面处可能存在间断。\n\nDG 方法的基于残差的后验误差估计子结合了单元残差和界面跳跃的贡献。在一维空间中，对于分片线性的 $p_h$ 和分片常数的 $f$，由于每个单元内的二阶导数为零，单元强残差简化为 $R_e(x) = f_e + k^2 p_h(x)$。该估计子聚合了以下几项：\n- 单元残差范数，按 $h_e^2$ 缩放，\n- 内部界面通量跳跃和解的跳跃（被惩罚），分别按 $h_e$ 和 $h_e^{-1}$ 缩放，\n- 反映 Dirichlet 边界条件弱施加的边界界面项。\n\n令 $p_e^L = p_h(x_e)$ 和 $p_e^R = p_h(x_{e+1})$ 为单元 $e$ 中的左右端点值，令 $s_e = (p_e^R - p_e^L)/h_e$ 为单元斜率。当 $p_h(x) = p_e^L + s_e (x - x_e)$ 在 $K_e$ 上且源项 $f_e$ 为分片常数时，定义 $a_e = f_e + k^2 p_e^L$ 和 $b_e = k^2 s_e$。单元残差 $L^2$ 范数平方的积分为\n$$\n\\int_{K_e} R_e(x)^2 \\, dx = \\int_{0}^{h_e} \\left( a_e + b_e \\xi \\right)^2 \\, d\\xi = a_e^2 h_e + a_e b_e h_e^2 + \\frac{b_e^2 h_e^3}{3}.\n$$\n设单元残差的估计子权重为 $C_{\\text{res}}  0$，跳跃项的权重为 $C_{\\text{jump}}  0$，并设置与内部罚方法一致的惩罚参数 $C_{\\text{pen}} = \\gamma  0$。对于位于 $x_i$ 处、由单元 $e$（左）和 $e+1$（右）共享的每个内部界面 $i$，定义解的跳跃和通量跳跃\n$$\n[p_h]_i = p_e^R - p_{e+1}^L, \\quad [\\partial_n p_h]_i = - s_e + s_{e+1},\n$$\n其中界面长度尺度为 $h_i = \\min(h_e, h_{e+1})$。内部界面指示子为\n$$\n\\eta_i^2 = C_{\\text{jump}} \\, h_i \\, \\left( [\\partial_n p_h]_i \\right)^2 + C_{\\text{pen}} \\, h_i^{-1} \\, \\left( [p_h]_i \\right)^2.\n$$\n对于 Dirichlet 边界条件，位于 $x=0$（左）和 $x=L$（右）的边界界面指示子为\n$$\n\\eta_{\\text{bnd},0}^2 = C_{\\text{bnd}} \\, h_1^{-1} \\, (p_0^L - p_D)^2 + C_{\\text{flux}} \\, h_1 \\, \\left( -s_0 \\right)^2,\n$$\n$$\n\\eta_{\\text{bnd},L}^2 = C_{\\text{bnd}} \\, h_N^{-1} \\, (p_{N-1}^R - p_D)^2 + C_{\\text{flux}} \\, h_N \\, \\left( +s_{N-1} \\right)^2,\n$$\n其中 $C_{\\text{bnd}}$ 和 $C_{\\text{flux}}$ 是正权重参数（对于本问题，设 $C_{\\text{bnd}} = \\gamma$ 和 $C_{\\text{flux}} = 1$），$s_0$ 和 $s_{N-1}$ 分别是第一个和最后一个单元的斜率。全局估计子为\n$$\n\\eta = \\left( \\sum_{e=0}^{N-1} C_{\\text{res}} \\, h_e^2 \\int_{K_e} R_e(x)^2 \\, dx \\; + \\sum_{i=1}^{N-1} \\eta_i^2 \\; + \\eta_{\\text{bnd},0}^2 + \\eta_{\\text{bnd},L}^2 \\right)^{1/2}.\n$$\n\n你的任务是实现一个完整的、可运行的程序，该程序：\n- 构建一个均匀网格，并为三个指定的测试用例计算上述基于残差的间断 Galerkin (DG) 后验误差估计子 $\\eta$。\n- 使用常数 $C_{\\text{res}} = 1$、$C_{\\text{jump}} = 1$、$C_{\\text{pen}} = \\gamma$、$C_{\\text{bnd}} = \\gamma$ 和 $C_{\\text{flux}} = 1$。\n- 假设分片线性的 $p_h$ 由每个单元的端点 $\\{(p_e^L, p_e^R)\\}_{e=0}^{N-1}$ 描述，每个单元的 $f_e$ 为分片常数，单元尺寸均匀为 $h = L/N$，以及 Dirichlet 边界数据为 $p_D$。\n\n请完全按照上述方程定义的方式实现计算。\n\n测试套件（每个用例是一个元组 $(L, N, k, \\gamma, p_D, \\{(p_e^L, p_e^R)\\}_{e}, \\{f_e\\}_e)$）：\n1. 用例 A（正常路径，存在内部界面跳跃，零源项）：\n   - $L = 1.0$, $N = 4$, $k = \\pi$, $\\gamma = 10.0$, $p_D = 0.0$.\n   - 对于 $e = 0,1,2,3$，其中 $h = L/N$，设置 $x_e = e h$，$x_{e+1} = (e+1) h$，$p_e^L = \\sin(k x_e)$，$p_e^R = \\sin(k x_{e+1}) + \\delta_e$，其中 $\\delta_e = 0.01 \\cdot (-1)^e$。\n   - 所有单元的 $f_e = 0.0$。\n2. 用例 B（边界主导，零内部残差，非零 Dirichlet 不匹配）：\n   - $L = 1.0$, $N = 3$, $k = 2.0$, $\\gamma = 5.0$, $p_D = 0.0$.\n   - 令 $c = 0.5$，对所有单元设置 $p_e^L = c$ 和 $p_e^R = c$。\n   - 对所有单元设置 $f_e = - k^2 c$（因此每个单元内 $f_e + k^2 p_h(x) = 0$）。\n3. 用例 C（单个单元，两个边界界面均激活，非零源项）：\n   - $L = 2.0$, $N = 1$, $k = 1.5$, $\\gamma = 20.0$, $p_D = 0.0$.\n   - 设置 $p_0^L = 1.0$，$p_0^R = -1.0$ 和 $f_0 = 0.1$。\n\n你的程序应生成单行输出，其中包含用例 A、B 和 C 的三个估计子值 $\\eta$，形式为用方括号括起来的逗号分隔列表（例如，“[resultA,resultB,resultC]”）。每个结果必须是浮点数。无需单位；以指定格式报告纯数值。",
            "solution": "问题陈述已经过严格验证，并被认为是有效的。它在计算声学和数值分析领域具有科学依据，特别是关于间断 Galerkin (DG) 方法和 Helmholtz 方程的后验误差估计。该问题是适定的，提供了为每个指定测试用例计算唯一数值结果所需的所有必要定义、常数和数据。语言是客观的，数学形式是清晰无歧义的，尽管在单元尺寸索引（$h_1, h_N$）上存在微小的记法不一致，但由于所有测试用例都明确约束为均匀网格，这一点变得无关紧要。任务是实现一个精确定义的数学公式，这是科学计算中的一个标准练习。\n\n解决方案要求实现一维 Helmholtz 方程的 DG 离散化的后验误差估计子 $\\eta$。全局估计子 $\\eta$ 定义为三个不同贡献项之和的平方根：单元残差、内部界面跳跃和边界界面项。\n\n$$\n\\eta = \\left( \\sum_{e=0}^{N-1} \\eta_{\\text{res},e}^2 \\; + \\sum_{i=1}^{N-1} \\eta_i^2 \\; + \\eta_{\\text{bnd},0}^2 + \\eta_{\\text{bnd},L}^2 \\right)^{1/2}\n$$\n\n计算以模块化的方式实现。一个主函数为每个测试用例准备特定参数，一个通用函数根据这些参数计算 $\\eta$。\n\n**1. 单元残差贡献**\n\n对于网格中的每个单元 $K_e = (x_e, x_{e+1})$，其中 $e \\in \\{0, 1, \\dots, N-1\\}$，对估计子的贡献为 $\\eta_{\\text{res},e}^2 = C_{\\text{res}} \\, h_e^2 \\int_{K_e} R_e(x)^2 \\, dx$。单元尺寸 $h_e = x_{e+1} - x_e$ 在所有单元上是均匀的，因此 $h_e = h = L/N$。单元残差为 $R_e(x) = f_e + k^2 p_h(x)$，其中 $f_e$ 是一个常数源项，解 $p_h(x)$ 是线性的，由 $p_h(x) = p_e^L + s_e (x - x_e)$ 给出，斜率为 $s_e = (p_e^R - p_e^L)/h$。\n\n单元 $K_e$ 上残差的 $L^2$ 范数平方由精确积分给出：\n$$\n\\int_{K_e} R_e(x)^2 \\, dx = a_e^2 h + a_e b_e h^2 + \\frac{b_e^2 h^3}{3}\n$$\n其中 $a_e = f_e + k^2 p_e^L$ 且 $b_e = k^2 s_e$。实现过程为每个单元计算斜率 $s_e$ 和系数 $a_e$、$b_e$，计算该积分，将其按 $C_{\\text{res}} h^2$（其中 $C_{\\text{res}} = 1$）进行缩放，并将其加到 $\\eta^2$ 的累加总和中。\n\n**2. 内部界面跳跃贡献**\n\n对于每个位于单元 $i-1$ 和单元 $i$ 之间的 $x_i$ 处的内部界面 $i \\in \\{1, \\dots, N-1\\}$，会添加一个惩罚项 $\\eta_i^2$。该项用于解释解 $p_h$ 及其导数的间断性。其定义为：\n$$\n\\eta_i^2 = C_{\\text{jump}} \\, h_i \\, \\left( [\\partial_n p_h]_i \\right)^2 + C_{\\text{pen}} \\, h_i^{-1} \\, \\left( [p_h]_i \\right)^2\n$$\n给定常数 $C_{\\text{jump}} = 1$ 和 $C_{\\text{pen}} = \\gamma$。对于我们的均匀网格，界面长度尺度 $h_i$ 为 $h$。解的跳跃 $[p_h]_i$ 和通量跳跃 $[\\partial_n p_h]_i$ 由以下公式给出：\n$$\n[p_h]_i = p_{i-1}^R - p_i^L\n$$\n$$\n[\\partial_n p_h]_i = - s_{i-1} + s_i\n$$\n实现过程遍历 $N-1$ 个内部界面，使用预先计算的斜率和给定的端点值计算这些跳跃，计算 $\\eta_i^2$，并将其加到 $\\eta^2$ 的总和中。对于 $N=1$ 的情况，没有内部界面，此求和被正确跳过。\n\n**3. 边界界面贡献**\n\nDirichlet 边界条件 $p(0)=p_D$ 和 $p(L)=p_D$ 的施加为估计子贡献了两项。\n\n在左边界 $x=0$ 处，该项为：\n$$\n\\eta_{\\text{bnd},0}^2 = C_{\\text{bnd}} \\, h^{-1} \\, (p_0^L - p_D)^2 + C_{\\text{flux}} \\, h \\, \\left( -s_0 \\right)^2\n$$\n在右边界 $x=L$ 处，该项为：\n$$\n\\eta_{\\text{bnd},L}^2 = C_{\\text{bnd}} \\, h^{-1} \\, (p_{N-1}^R - p_D)^2 + C_{\\text{flux}} \\, h \\, \\left( +s_{N-1} \\right)^2\n$$\n常数为 $C_{\\text{bnd}} = \\gamma$ 和 $C_{\\text{flux}} = 1$。这里使用单元尺寸 $h$ 代替问题描述中索引不明确的 $h_1$ 和 $h_N$，这是由均匀网格的约束所证明是合理的。实现过程使用第一个（$e=0$）和最后一个（$e=N-1$）单元的数据计算这两项，并将它们加到 $\\eta^2$ 中。\n\n最后，总估计子值 $\\eta$ 计算为所有平方贡献项的累加和的平方根。该过程应用于所提供的三个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_eta(L, N, k, gamma, p_D, p_list, f_list):\n    \"\"\"\n    Computes the residual-based a posteriori error estimator for a 1D DG method.\n\n    Args:\n        L (float): Domain length.\n        N (int): Number of elements.\n        k (float): Wavenumber.\n        gamma (float): Penalty parameter, also used for C_pen and C_bnd.\n        p_D (float): Dirichlet boundary value.\n        p_list (list of tuples): List of (p_e^L, p_e^R) values for each element.\n        f_list (list of floats): List of source term values f_e for each element.\n\n    Returns:\n        float: The computed error estimator eta.\n    \"\"\"\n    h = L / N\n\n    C_res = 1.0\n    C_jump = 1.0\n    C_pen = gamma\n    C_bnd = gamma\n    C_flux = 1.0\n\n    eta_squared = 0.0\n    \n    slopes = []\n    \n    # Step 1: Sum of Element Residual contributions\n    for e in range(N):\n        p_e_L, p_e_R = p_list[e]\n        f_e = f_list[e]\n        \n        s_e = (p_e_R - p_e_L) / h if h > 0 else 0.0\n        slopes.append(s_e)\n        \n        a_e = f_e + k**2 * p_e_L\n        b_e = k**2 * s_e\n        \n        res_norm_sq = a_e**2 * h + a_e * b_e * h**2 + (b_e**2 * h**3) / 3\n        \n        eta_squared += C_res * h**2 * res_norm_sq\n        \n    # Step 2: Sum of Interior Face Jump contributions\n    # Loop over interior faces i=1, ..., N-1\n    # Face i is between element i-1 and i\n    for i in range(1, N):\n        p_left_R = p_list[i-1][1]\n        p_right_L = p_list[i][0]\n        s_left = slopes[i-1]\n        s_right = slopes[i]\n        \n        h_i = h # Uniform mesh\n        \n        jump_p = p_left_R - p_right_L\n        jump_flux = -s_left + s_right\n        \n        eta_i_sq = C_jump * h_i * jump_flux**2 + C_pen * (h_i**-1) * jump_p**2\n        eta_squared += eta_i_sq\n\n    # Step 3: Boundary Face contributions\n    if N > 0:\n        # Left boundary at x=0\n        p_0_L = p_list[0][0]\n        s_0 = slopes[0]\n        h_bnd_0 = h\n        eta_bnd_0_sq = C_bnd * (h_bnd_0**-1) * (p_0_L - p_D)**2 + C_flux * h_bnd_0 * (-s_0)**2\n        eta_squared += eta_bnd_0_sq\n        \n        # Right boundary at x=L\n        p_N_minus_1_R = p_list[N-1][1]\n        s_N_minus_1 = slopes[N-1]\n        h_bnd_L = h\n        eta_bnd_L_sq = C_bnd * (h_bnd_L**-1) * (p_N_minus_1_R - p_D)**2 + C_flux * h_bnd_L * (s_N_minus_1)**2\n        eta_squared += eta_bnd_L_sq\n        \n    return np.sqrt(eta_squared)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is processed to generate p_list and f_list before being passed\n    # to the calculator function.\n    \n    # Case A\n    L_A, N_A, k_A, gamma_A, p_D_A = 1.0, 4, np.pi, 10.0, 0.0\n    h_A = L_A / N_A\n    p_list_A = []\n    for e in range(N_A):\n        x_e = e * h_A\n        x_e_plus_1 = (e + 1) * h_A\n        delta_e = 0.01 * ((-1)**e)\n        p_e_L = np.sin(k_A * x_e)\n        p_e_R = np.sin(k_A * x_e_plus_1) + delta_e\n        p_list_A.append((p_e_L, p_e_R))\n    f_list_A = [0.0] * N_A\n    case_A = (L_A, N_A, k_A, gamma_A, p_D_A, p_list_A, f_list_A)\n\n    # Case B\n    L_B, N_B, k_B, gamma_B, p_D_B = 1.0, 3, 2.0, 5.0, 0.0\n    c_B = 0.5\n    p_list_B = [(c_B, c_B)] * N_B\n    f_list_B = [-k_B**2 * c_B] * N_B\n    case_B = (L_B, N_B, k_B, gamma_B, p_D_B, p_list_B, f_list_B)\n\n    # Case C\n    L_C, N_C, k_C, gamma_C, p_D_C = 2.0, 1, 1.5, 20.0, 0.0\n    p_list_C = [(1.0, -1.0)]\n    f_list_C = [0.1]\n    case_C = (L_C, N_C, k_C, gamma_C, p_D_C, p_list_C, f_list_C)\n\n    test_cases = [case_A, case_B, case_C]\n    \n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        eta = calculate_eta(*case)\n        results.append(eta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}