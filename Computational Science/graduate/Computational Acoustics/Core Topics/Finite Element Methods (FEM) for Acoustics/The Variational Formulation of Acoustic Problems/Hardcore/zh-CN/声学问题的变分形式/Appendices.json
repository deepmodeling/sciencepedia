{
    "hands_on_practices": [
        {
            "introduction": "有限元方法的核心是根据局部“单元”矩阵组装成全局方程组。本练习  为亥姆霍兹方程提供了将连续弱形式转化为离散矩阵项的基础性动手实践。通过在一个标准的三角形单元上手动推导和计算刚度、质量以及罗宾边界项，你将对这一转化过程建立起具体而深刻的理解。",
            "id": "4145890",
            "problem": "考虑一个时谐声压场 $p$，它存在于一个具有恒定质量密度和声速的均匀介质中，并通过波数为 $k0$ 的标量 Helmholtz 方程在一个二维域中建模。设其强形式在开集 $\\Omega \\subset \\mathbb{R}^{2}$ 中由 $-\\Delta p - k^{2} p = 0$ 给出，并附带一个在部分边界 $\\Gamma_{R} \\subset \\partial \\Omega$ 上的实值阻抗（Robin）边界条件 $\\partial_{n} p + \\alpha p = 0$，其中 $\\alpha0$ 是一个给定常数，$\\partial_{n}$ 表示外法向导数。假设其余边界为零通量的 Neumann 边界。使用有限元法（FEM），在单个三角形单元 $K$ 上采用线性 Lagrange 基函数。设单元 $K$ 的顶点位于 $(x_{1},y_{1})=(0,0)$、$(x_{2},y_{2})=(1,0)$ 和 $(x_{3},y_{3})=(0,2)$。假设从节点 $1$ 到节点 $2$ 的边位于 $\\Gamma_{R}$ 上，而其他边为内部边。\n\n从强形式出发，推导 $K$ 上的变分（弱）形式，并指定与 $K$ 的三个顶点相关联的线性 Lagrange 形函数 $\\phi_{1}, \\phi_{2}, \\phi_{3}$。然后，对此单元计算所有 $i,j \\in \\{1,2,3\\}$ 的单元级双线性形式项\n$$\na_{ij}^{(K)} \\;=\\; \\int_{K} \\nabla \\phi_{i} \\cdot \\nabla \\phi_{j} \\, dx \\;-\\; k^{2} \\int_{K} \\phi_{i}\\,\\phi_{j}\\, dx \\;+\\; \\int_{\\partial K \\cap \\Gamma_{R}} \\alpha\\, \\phi_{i}\\,\\phi_{j}\\, ds\n$$\n\n使用精确计算，并将 $k$ 和 $\\alpha$ 作为符号参数，将最终答案表示为 $\\left(a_{11}^{(K)},\\,a_{12}^{(K)},\\,a_{13}^{(K)},\\,a_{21}^{(K)},\\,a_{22}^{(K)},\\,a_{23}^{(K)},\\,a_{31}^{(K)},\\,a_{32}^{(K)},\\,a_{33}^{(K)}\\right)$ 顺序的单个行矩阵。无需四舍五入，也无需指定单位。",
            "solution": "均匀介质中时谐声学的控制方程是标量 Helmholtz 方程。从小振幅扰动的质量和动量守恒出发，并应用角频率为 $\\omega$ 的时谐假设 $p(\\mathbf{x},t)=\\Re\\{P(\\mathbf{x})\\exp(-\\mathrm{i}\\omega t)\\}$，可得到空间振幅 $P$ 的边值问题 $-\\Delta P - k^{2} P = 0$，其中 $k=\\omega/c$ 是波数。在 $\\Gamma_{R}$ 上施加实阻抗（Robin）边界条件 $\\partial_{n} P + \\alpha P = 0$ 并在其他地方施加齐次 Neumann 条件，通过将强形式乘以一个检验函数 $v$ 并进行分部积分，可以得到子域 $K \\subset \\Omega$ 上的变分（弱）形式：\n$$\n\\int_{K} (-\\Delta p)\\, v \\, dx - k^{2} \\int_{K} p\\, v \\, dx = 0.\n$$\n使用恒等式\n$$\n\\int_{K} (-\\Delta p)\\, v \\, dx = \\int_{K} \\nabla p \\cdot \\nabla v \\, dx - \\int_{\\partial K} \\partial_{n} p \\, v \\, ds,\n$$\n并施加边界条件，Robin 边上的自然边界贡献为\n$$\n-\\int_{\\partial K \\cap \\Gamma_{R}} \\partial_{n} p \\, v \\, ds = \\int_{\\partial K \\cap \\Gamma_{R}} \\alpha \\, p \\, v \\, ds,\n$$\n而零通量的 Neumann 边界对双线性形式没有贡献。因此，单元级双线性形式为\n$$\na^{(K)}(p,v) \\;=\\; \\int_{K} \\nabla p \\cdot \\nabla v \\, dx \\;-\\; k^{2} \\int_{K} p\\, v \\, dx \\;+\\; \\int_{\\partial K \\cap \\Gamma_{R}} \\alpha\\, p\\, v\\, ds.\n$$\n在有限元法（FEM）中，对顶点为 $(0,0)$、$(1,0)$、$(0,2)$ 的三角形 $K$ 使用线性 Lagrange 基函数，其标准节点形函数 $\\{\\phi_{i}\\}_{i=1}^{3}$ 是重心坐标。使用面积坐标表示法，\n$$\n\\phi_{i}(x,y) \\;=\\; \\frac{a_{i} + b_{i} x + c_{i} y}{2A},\n$$\n其中 $A$ 是 $K$ 的面积，对于每个顶点 $i$，$(a_{i},b_{i},c_{i})$ 由另外两个顶点 $(x_{j},y_{j})$ 和 $(x_{k},y_{k})$ 计算得出，公式如下：\n$$\na_{i} = x_{j} y_{k} - x_{k} y_{j}, \\quad b_{i} = y_{j} - y_{k}, \\quad c_{i} = x_{k} - x_{j}.\n$$\n对于我们的三角形，面积为\n$$\nA \\;=\\; \\frac{1}{2} \\, |(x_{2}-x_{1})(y_{3}-y_{1}) - (x_{3}-x_{1})(y_{2}-y_{1})| \\;=\\; \\frac{1}{2}\\,(1\\cdot 2 - 0\\cdot 0) \\;=\\; 1.\n$$\n计算 $(a_{i},b_{i},c_{i})$：\n- 对于 $i=1$，且 $(j,k)=(2,3)$，\n$$\na_{1} = x_{2} y_{3} - x_{3} y_{2} = 1\\cdot 2 - 0\\cdot 0 = 2,\\quad b_{1} = y_{2} - y_{3} = 0 - 2 = -2,\\quad c_{1} = x_{3} - x_{2} = 0 - 1 = -1,\n$$\n所以\n$$\n\\phi_{1}(x,y) = \\frac{2 - 2x - y}{2} = 1 - x - \\frac{y}{2}.\n$$\n- 对于 $i=2$，且 $(j,k)=(3,1)$，\n$$\na_{2} = x_{3} y_{1} - x_{1} y_{3} = 0\\cdot 0 - 0\\cdot 2 = 0,\\quad b_{2} = y_{3} - y_{1} = 2 - 0 = 2,\\quad c_{2} = x_{1} - x_{3} = 0 - 0 = 0,\n$$\n所以\n$$\n\\phi_{2}(x,y) = \\frac{0 + 2x + 0\\cdot y}{2} = x.\n$$\n- 对于 $i=3$，且 $(j,k)=(1,2)$，\n$$\na_{3} = x_{1} y_{2} - x_{2} y_{1} = 0\\cdot 0 - 1\\cdot 0 = 0,\\quad b_{3} = y_{1} - y_{2} = 0 - 0 = 0,\\quad c_{3} = x_{2} - x_{1} = 1 - 0 = 1,\n$$\n所以\n$$\n\\phi_{3}(x,y) = \\frac{0 + 0\\cdot x + 1\\cdot y}{2} = \\frac{y}{2}.\n$$\n梯度在 $K$ 上是常数：\n$$\n\\nabla \\phi_{i} = \\frac{1}{2A}\\,(b_{i},\\,c_{i}) = \\frac{1}{2}\\,(b_{i},\\,c_{i}),\n$$\n得到\n$$\n\\nabla \\phi_{1} = \\left(-1,\\,-\\frac{1}{2}\\right),\\quad \\nabla \\phi_{2} = (1,\\,0),\\quad \\nabla \\phi_{3} = \\left(0,\\,\\frac{1}{2}\\right).\n$$\n因为这些梯度是常数，所以类刚度贡献为\n$$\n\\int_{K} \\nabla \\phi_{i} \\cdot \\nabla \\phi_{j}\\, dx = A\\, \\nabla \\phi_{i} \\cdot \\nabla \\phi_{j} = \\nabla \\phi_{i} \\cdot \\nabla \\phi_{j},\n$$\n其中 $A=1$。计算所有点积：\n$$\n\\nabla \\phi_{1} \\cdot \\nabla \\phi_{1} = 1 + \\frac{1}{4} = \\frac{5}{4},\\quad \\nabla \\phi_{1} \\cdot \\nabla \\phi_{2} = -1,\\quad \\nabla \\phi_{1} \\cdot \\nabla \\phi_{3} = -\\frac{1}{4},\n$$\n$$\n\\nabla \\phi_{2} \\cdot \\nabla \\phi_{2} = 1,\\quad \\nabla \\phi_{2} \\cdot \\nabla \\phi_{3} = 0,\\quad \\nabla \\phi_{3} \\cdot \\nabla \\phi_{3} = \\frac{1}{4}.\n$$\n接下来，在面积为 $A=1$ 的三角形上，一致 $P_{1}$ 类质量贡献为\n$$\n\\int_{K} \\phi_{i}\\,\\phi_{j}\\, dx = A \\times \\frac{1 + \\delta_{ij}}{12} = \\begin{cases} \\frac{1}{6},  i=j, \\\\ \\frac{1}{12},  i\\neq j, \\end{cases}\n$$\n这可以通过直接积分或使用线性三角形单元的标准公式来验证。因此，内部双线性项为\n$$\n\\left[\\int_{K} \\nabla \\phi_{i} \\cdot \\nabla \\phi_{j}\\, dx\\right] - k^{2}\\left[\\int_{K} \\phi_{i}\\,\\phi_{j}\\, dx\\right]\n=\n\\begin{cases}\n\\frac{5}{4} - \\frac{k^{2}}{6},  (i,j)=(1,1), \\\\\n-1 - \\frac{k^{2}}{12},  (i,j)=(1,2)\\text{ 或 }(2,1), \\\\\n-\\frac{1}{4} - \\frac{k^{2}}{12},  (i,j)=(1,3)\\text{ 或 }(3,1), \\\\\n1 - \\frac{k^{2}}{6},  (i,j)=(2,2), \\\\\n0 - \\frac{k^{2}}{12} = -\\frac{k^{2}}{12},  (i,j)=(2,3)\\text{ 或 }(3,2), \\\\\n\\frac{1}{4} - \\frac{k^{2}}{6},  (i,j)=(3,3).\n\\end{cases}\n$$\n现在计入 $\\partial K \\cap \\Gamma_{R}$ 上的 Robin 边界积分，即从节点 $1$ 到节点 $2$ 的边。将该边参数化为 $x \\in [0,1]$，其中 $y=0$ 且 $ds=dx$。限制在该边上的形函数为 $\\phi_{1}(x,0) = 1 - x$、$\\phi_{2}(x,0) = x$ 和 $\\phi_{3}(x,0) = 0$。边界贡献为\n$$\n\\int_{\\partial K \\cap \\Gamma_{R}} \\alpha\\, \\phi_{1}\\,\\phi_{1}\\, ds = \\alpha \\int_{0}^{1} (1-x)^{2}\\, dx = \\alpha \\cdot \\frac{1}{3} = \\frac{\\alpha}{3},\n$$\n$$\n\\int_{\\partial K \\cap \\Gamma_{R}} \\alpha\\, \\phi_{2}\\,\\phi_{2}\\, ds = \\alpha \\int_{0}^{1} x^{2}\\, dx = \\alpha \\cdot \\frac{1}{3} = \\frac{\\alpha}{3},\n$$\n$$\n\\int_{\\partial K \\cap \\Gamma_{R}} \\alpha\\, \\phi_{1}\\,\\phi_{2}\\, ds = \\alpha \\int_{0}^{1} x(1-x)\\, dx = \\alpha \\cdot \\frac{1}{6} = \\frac{\\alpha}{6},\n$$\n且所有涉及 $\\phi_{3}$ 的项在该边上都为零。将内部贡献和边界贡献相加，得到完整的单元双线性项：\n$$\na_{11}^{(K)} = \\frac{5}{4} - \\frac{k^{2}}{6} + \\frac{\\alpha}{3},\\quad\na_{12}^{(K)} = -1 - \\frac{k^{2}}{12} + \\frac{\\alpha}{6},\\quad\na_{13}^{(K)} = -\\frac{1}{4} - \\frac{k^{2}}{12},\n$$\n$$\na_{21}^{(K)} = -1 - \\frac{k^{2}}{12} + \\frac{\\alpha}{6},\\quad\na_{22}^{(K)} = 1 - \\frac{k^{2}}{6} + \\frac{\\alpha}{3},\\quad\na_{23}^{(K)} = -\\frac{k^{2}}{12},\n$$\n$$\na_{31}^{(K)} = -\\frac{1}{4} - \\frac{k^{2}}{12},\\quad\na_{32}^{(K)} = -\\frac{k^{2}}{12},\\quad\na_{33}^{(K)} = \\frac{1}{4} - \\frac{k^{2}}{6}.\n$$\n如预期的那样，这些项关于 $i$ 和 $j$ 是对称的。最终行矩阵所要求的顺序是 $\\left(a_{11}^{(K)},\\,a_{12}^{(K)},\\,a_{13}^{(K)},\\,a_{21}^{(K)},\\,a_{22}^{(K)},\\,a_{23}^{(K)},\\,a_{31}^{(K)},\\,a_{32}^{(K)},\\,a_{33}^{(K)}\\right)$。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{5}{4} - \\frac{k^{2}}{6} + \\frac{\\alpha}{3}  -1 - \\frac{k^{2}}{12} + \\frac{\\alpha}{6}  -\\frac{1}{4} - \\frac{k^{2}}{12}  -1 - \\frac{k^{2}}{12} + \\frac{\\alpha}{6}  1 - \\frac{k^{2}}{6} + \\frac{\\alpha}{3}  -\\frac{k^{2}}{12}  -\\frac{1}{4} - \\frac{k^{2}}{12}  -\\frac{k^{2}}{12}  \\frac{1}{4} - \\frac{k^{2}}{6} \\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了单元矩阵的计算之后，我们将视野从单个单元的计算扩展到一个完整的计算工作流程。本练习  将指导你完成一个经典的基准问题——圆形声腔的本征模态分析。你将推导出一维径向弱形式，通过编程实现有限元离散化，求解矩阵特征值问题，并通过与贝塞尔函数构成的解析解进行对比来验证数值结果的准确性，这是科学计算中验证代码和量化精度的关键环节。",
            "id": "4145864",
            "problem": "考虑一个半径为 $R$ 的二维圆形腔体中的时间谐波声压场，该场被建模为拉普拉斯算子在边界上施加齐次狄利克雷边界条件下的内部特征值问题的解。设空间域为圆盘 $D = \\{ (x,y) \\in \\mathbb{R}^2 \\mid x^2 + y^2  R^2 \\}$，其边界为 $\\partial D = \\{ (x,y) \\in \\mathbb{R}^2 \\mid x^2 + y^2 = R^2 \\}$。控制方程的强形式为：寻找非平凡解 $u$ 和 $\\lambda \\in \\mathbb{R}$，使得\n$$\n- \\Delta u = \\lambda\\, u \\quad \\text{in } D, \\qquad u = 0 \\quad \\text{on } \\partial D.\n$$\n从这个强形式出发，推导出变分（弱）形式：寻找 $u \\in V$ 和 $\\lambda \\in \\mathbb{R}$，使得\n$$\na(u,v) = \\lambda\\, m(u,v) \\quad \\text{for all } v \\in V,\n$$\n其中 $V$ 是合适的函数空间。请明确指出 $V$、双线性形式 $a(\\cdot,\\cdot)$ 以及双线性形式 $m(\\cdot,\\cdot)$ 的基本量表示。解释对称性和变量分离如何证明将注意力限制在轴对称子空间是合理的，然后推导出在区间 $[0,R]$ 上相应的一维径向弱形式，其权重由极坐标雅可比行列式确定。\n\n使用有限元法（FEM）实现一个伽辽金近似，在径向区间 $[0,R]$ 的一个含 $N$ 个单元的均匀划分上，使用连续的分段线性基函数。将在 $r=R$ 处的狄利克雷边界条件作为本质边界条件强制施加。组装与带正确权重的径向弱形式相对应的离散刚度矩阵 $\\mathbf{K}$ 和质量矩阵 $\\mathbf{M}$。构建并求解矩阵广义特征值问题\n$$\n\\mathbf{K}\\,\\mathbf{u} = \\lambda_h\\, \\mathbf{M}\\,\\mathbf{u},\n$$\n以计算前 $p$ 个轴对称离散特征对 $(\\lambda_h^{(j)}, \\mathbf{u}^{(j)})$。\n\n解析的轴对称特征对由零阶第一类贝塞尔函数给出，其特征函数为 $u^{(j)}_{\\text{exact}}(r) = J_0(k_j r)$，波数 $k_j$ 由 $J_0$ 在 $r=R$ 处的零点确定，即 $J_0(k_j R) = 0$，对应的特征值为 $\\lambda^{(j)}_{\\text{exact}} = k_j^2$。请精确描述如何计算与这些解析解相比的两种误差度量：\n- 相对特征值误差，定义为\n$$\nE_{\\lambda}^{(j)} = \\frac{\\left| \\lambda_h^{(j)} - \\lambda_{\\text{exact}}^{(j)} \\right|}{\\lambda_{\\text{exact}}^{(j)}}.\n$$\n- 在由质量双线性形式导出的加权 $L^2$-范数下的相对特征函数误差，其中解析函数经过最优缩放以最佳拟合离散特征向量。具体来说，如果 $\\mathbf{e}^{(j)}$ 表示在有限元节点（不包括 $r=R$ 处的狄利克雷节点）上采样的解析特征函数，定义\n$$\n\\alpha^{(j)} = \\frac{\\mathbf{e}^{(j)T}\\mathbf{M}\\,\\mathbf{u}^{(j)}}{\\mathbf{e}^{(j)T}\\mathbf{M}\\,\\mathbf{e}^{(j)}}, \\qquad\nE_{u}^{(j)} = \\frac{ \\left\\| \\mathbf{u}^{(j)} - \\alpha^{(j)} \\mathbf{e}^{(j)} \\right\\|_{\\mathbf{M}} }{ \\left\\| \\mathbf{e}^{(j)} \\right\\|_{\\mathbf{M}} },\n$$\n其中 $\\left\\| \\mathbf{w} \\right\\|_{\\mathbf{M}} = \\sqrt{\\mathbf{w}^T \\mathbf{M} \\mathbf{w}}$。\n\n您的任务是编写一个完整的、可运行的程序，该程序：\n1. 组装用于在 $[0,R]$ 上、在 $r=R$ 处具有齐次狄利克雷边界的轴对称弱形式的一维径向FEM刚度矩阵和质量矩阵。\n2. 求解前 $p$ 个离散特征对。\n3. 使用 $J_0$ 的零点计算解析的轴对称特征值和特征函数。\n4. 对每个 $j=1,\\dots,p$ 计算 $E_{\\lambda}^{(j)}$ 和 $E_{u}^{(j)}$。\n5. 汇总所提供测试套件的结果，并将其作为单行打印。\n\n使用以下参数值的测试套件，涵盖典型、粗糙和更改半径的情况：\n- 测试用例 1 (一般情况): $R = 1.0$, $N = 128$, $p = 3$。\n- 测试用例 2 (粗糙离散化边界情况): $R = 1.0$, $N = 12$, $p = 2$。\n- 测试用例 3 (更改半径): $R = 0.75$, $N = 96$, $p = 3$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，且无空格。每个测试用例的结果本身必须是一个包含每个模态对的列表，其中每个对的形式为 $[E_{\\lambda}^{(j)},E_{u}^{(j)}]$，对于 $j=1,\\dots,p$。例如，一个可能的输出结构是\n$$\n\\big[ \\big[ [E_{\\lambda}^{(1)},E_{u}^{(1)}], [E_{\\lambda}^{(2)},E_{u}^{(2)}], \\dots \\big], \\big[ [\\cdot,\\cdot], \\dots \\big], \\big[ [\\cdot,\\cdot], \\dots \\big] \\big],\n$$\n以单行形式打印，不含空格。所有数值应为普通或科学记数法表示的浮点数。由于问题已无量纲化，不需要物理单位；不涉及角度；不得使用百分比。",
            "solution": "所提出的问题是一个完整且适定的计算声学练习，具体涉及内部轴对称特征值问题的有限元分析。它在科学上是合理的，在数学上是严谨的，并包含了唯一解所需的所有信息。我们将首先推导所需的数学公式，然后按照规定实现数值解。\n\n### 第1部分：变分（弱）形式的推导\n\n问题的强形式是找到一个特征函数 $u$ 和一个特征值 $\\lambda \\in \\mathbb{R}$，使得：\n$$\n\\begin{cases}\n- \\Delta u = \\lambda u  \\text{ in } D \\\\\nu = 0  \\text{ on } \\partial D\n\\end{cases}\n$$\n其中 $D$ 是半径为 $R$ 的圆盘。\n\n为了推导弱形式，我们将控制偏微分方程乘以一个测试函数 $v$。该测试函数必须属于一个满足齐次狄利克雷边界条件的函数空间。合适的空间是索伯列夫空间 $V = H_0^1(D)$，它包含平方可积、具有平方可积一阶导数且在边界 $\\partial D$ 上为零的函数。\n\n乘以 $v \\in V$ 并在域 $D$ 上积分，得到：\n$$\n- \\int_D (\\Delta u) v \\, dA = \\lambda \\int_D u v \\, dA\n$$\n我们对左侧应用格林第一恒等式（多维分部积分）：\n$$\n\\int_D (\\nabla u \\cdot \\nabla v) \\, dA - \\int_{\\partial D} v (\\nabla u \\cdot \\mathbf{n}) \\, dS = \\lambda \\int_D u v \\, dA\n$$\n其中 $\\mathbf{n}$ 是边界 $\\partial D$ 的外单位法向量。边界积分 $\\int_{\\partial D} v (\\nabla u \\cdot \\mathbf{n}) \\, dS$ 为零，因为根据空间 $V=H_0^1(D)$ 的定义，测试函数 $v$ 在 $\\partial D$ 上为零。\n\n这导出了变分（弱）形式：找到 $u \\in V$ 和 $\\lambda \\in \\mathbb{R}$，使得对于所有 $v \\in V$：\n$$\n\\int_D (\\nabla u \\cdot \\nabla v) \\, dA = \\lambda \\int_D u v \\, dA\n$$\n该方程形如 $a(u,v) = \\lambda m(u,v)$，其中：\n- 函数空间为 $V = H_0^1(D)$。\n- 刚度双线性形式为 $a(u,v) = \\int_D (\\nabla u \\cdot \\nabla v) \\, dA$。\n- 质量双线性形式为 $m(u,v) = \\int_D u v \\, dA$。\n$a(\\cdot,\\cdot)$ 和 $m(\\cdot,\\cdot)$ 都是对称且（在指定空间上）正定的，这确保了特征值 $\\lambda$ 是实数且为正。\n\n### 第2部分：简化为轴对称一维形式\n\n域的圆形几何结构允许存在轴对称解，即与角坐标 $\\theta$ 无关的解。在极坐标 $(r, \\theta)$ 中，这样的函数形式为 $u(r, \\theta) = u(r)$。极坐标下的拉普拉斯算子是 $\\Delta = \\frac{1}{r}\\frac{\\partial}{\\partial r}(r \\frac{\\partial}{\\partial r}) + \\frac{1}{r^2}\\frac{\\partial^2}{\\partial \\theta^2}$。对于轴对称函数，角向导数消失，因此 $\\Delta u = \\frac{1}{r}\\frac{d}{dr}(r \\frac{du}{dr})$。\n\n强形式简化为在区间 $[0, R]$ 上的常微分方程：\n$$\n-\\frac{1}{r}\\frac{d}{dr}\\left(r \\frac{du}{dr}\\right) = \\lambda u(r), \\quad u(R)=0, \\quad u'(0)=0\n$$\n条件 $u'(0)=0$ 是为保证在原点处光滑性所必需的自然边界条件。\n\n为了推导相应的一维弱形式，我们在极坐标中表示二维双线性形式。面积元为 $dA = r\\,dr\\,d\\theta$。轴对称函数 $u(r)$ 的梯度为 $\\nabla u = (u'(r), 0)$。因此，对于两个轴对称函数 $u(r)$ 和 $v(r)$，它们的点积为 $\\nabla u \\cdot \\nabla v = u'(r)v'(r)$。\n\n将这些代入二维弱形式：\n$$\na(u,v) = \\int_0^{2\\pi} \\int_0^R (u'v') r\\,dr\\,d\\theta = 2\\pi \\int_0^R u'(r)v'(r) r\\,dr\n$$\n$$\nm(u,v) = \\int_0^{2\\pi} \\int_0^R (uv) r\\,dr\\,d\\theta = 2\\pi \\int_0^R u(r)v(r) r\\,dr\n$$\n常数因子 $2\\pi$ 出现在 $a(u,v) = \\lambda m(u,v)$ 的两边，可以消去。这得到一维径向弱形式：找到 $u \\in V_r$，使得对于所有 $v \\in V_r$：\n$$\n\\int_0^R u'v' r\\,dr = \\lambda \\int_0^R uv r\\,dr\n$$\n这里，函数空间是 $V_r = \\{ v \\in H^1((0,R)) \\mid v(R)=0 \\}$，积分中的径向权重 $r$ 源于从笛卡尔坐标到极坐标转换的雅可比行列式。\n\n### 第3部分：有限元法（FEM）离散化\n\n我们使用伽辽金方法和连续的分段线性基函数来离散化一维径向弱形式。我们将区间 $[0,R]$ 划分成 $N$ 个大小相等的单元 $h=R/N$，节点为 $r_i = ih$，其中 $i=0,\\dots,N$。解被近似为线性组合 $u_h(r) = \\sum_{j=0}^{N-1} u_j \\phi_j(r)$，其中 $\\phi_j(r)$ 是标准的线性“帽状”基函数，而 $u_j$ 是节点值。通过设置 $u_N=0$ 并从试探空间中排除基函数 $\\phi_N(r)$ 来强制施加齐次狄利克雷条件 $u(R)=0$ 作为本质边界条件。这导致 $N$ 个未知自由度，$u_0, \\dots, u_{N-1}$。\n\n伽辽金过程导致矩阵广义特征值问题 $\\mathbf{K}\\mathbf{u} = \\lambda_h \\mathbf{M}\\mathbf{u}$，其中刚度矩阵 $\\mathbf{K}$ 和质量矩阵 $\\mathbf{M}$ 的元素由下式给出：\n$$\nK_{ij} = \\int_0^R \\phi_j' \\phi_i' r\\,dr, \\quad M_{ij} = \\int_0^R \\phi_j \\phi_i r\\,dr \\quad \\text{for } i,j \\in \\{0, \\dots, N-1\\}\n$$\n这些全局矩阵由局部（单元）矩阵贡献组装而成。对于一个通用单元 $e_k = [r_k, r_{k+1}]$，局部刚度矩阵 $(\\mathbf{K}^e_k)$ 和质量矩阵 $(\\mathbf{M}^e_k)$ 是通过在该单元上积分计算的。\n\n局部刚度矩阵为：\n$$\n\\mathbf{K}^e_k = \\frac{r_k+r_{k+1}}{2h}\n\\begin{pmatrix}\n1  -1 \\\\\n-1  1\n\\end{pmatrix}\n$$\n局部质量矩阵，使用对线性基函数和线性变化的权重 $r$ 的精确积分，为：\n$$\n\\mathbf{M}^e_k = \\frac{h}{12}\n\\begin{pmatrix}\n3r_k+r_{k+1}  r_k+r_{k+1} \\\\\nr_k+r_{k+1}  r_k+3r_{k+1}\n\\end{pmatrix}\n$$\n这些 $2 \\times 2$ 的单元矩阵随后被组装成全局 $N \\times N$ 矩阵 $\\mathbf{K}$ 和 $\\mathbf{M}$。\n\n### 第4部分：误差度量\n\n解析解涉及零阶第一类贝塞尔函数 $J_0$。特征函数为 $u^{(j)}_{\\text{exact}}(r) = J_0(k_j r)$，其中波数 $k_j$ 由 $J_0(k_j R) = 0$ 的根确定。如果 $z_j$ 是 $J_0(z)=0$ 的第 $j$ 个正根，则 $k_j = z_j/R$。相应的精确特征值为 $\\lambda^{(j)}_{\\text{exact}} = k_j^2 = (z_j/R)^2$。\n\n误差度量计算如下：\n1.  **相对特征值误差**：对于第 $j$ 个模态，这是数值计算的特征值 $\\lambda_h^{(j)}$ 与解析特征值 $\\lambda_{\\text{exact}}^{(j)}$ 之间的直接比较：\n    $$\n    E_{\\lambda}^{(j)} = \\frac{\\left| \\lambda_h^{(j)} - \\lambda_{\\text{exact}}^{(j)} \\right|}{\\lambda_{\\text{exact}}^{(j)}}\n    $$\n2.  **相对特征函数误差**：这度量了离散特征向量 $\\mathbf{u}^{(j)}$ 与采样的解析特征函数 $\\mathbf{e}^{(j)}$ 之间的形状差异，其中 $\\mathbf{e}^{(j)}_i = J_0(k_j r_i)$。为了考虑计算出的特征向量的任意缩放，首先将解析向量按一个最优因子 $\\alpha^{(j)}$ 进行缩放，该因子最小化了由质量矩阵 $\\mathbf{M}$ 导出的范数下的误差。\n    缩放因子 $\\alpha^{(j)}$ 是 $\\mathbf{u}^{(j)}$ 在 $\\mathbf{M}$-内积下到 $\\mathbf{e}^{(j)}$ 上的投影：\n    $$\n    \\alpha^{(j)} = \\frac{\\langle \\mathbf{e}^{(j)}, \\mathbf{u}^{(j)} \\rangle_{\\mathbf{M}}}{\\langle \\mathbf{e}^{(j)}, \\mathbf{e}^{(j)} \\rangle_{\\mathbf{M}}} = \\frac{\\mathbf{e}^{(j)T}\\mathbf{M}\\,\\mathbf{u}^{(j)}}{\\mathbf{e}^{(j)T}\\mathbf{M}\\,\\mathbf{e}^{(j)}}\n    $$\n    误差则是残差的 $\\mathbf{M}$-范数与缩放后解析向量的 $\\mathbf{M}$-范数之比：\n    $$\n    E_{u}^{(j)} = \\frac{ \\left\\| \\mathbf{u}^{(j)} - \\alpha^{(j)} \\mathbf{e}^{(j)} \\right\\|_{\\mathbf{M}} }{ \\left\\| \\mathbf{e}^{(j)} \\right\\|_{\\mathbf{M}} } = \\sqrt{\\frac{ (\\mathbf{u}^{(j)} - \\alpha^{(j)} \\mathbf{e}^{(j)})^T \\mathbf{M} (\\mathbf{u}^{(j)} - \\alpha^{(j)} \\mathbf{e}^{(j)}) }{ \\mathbf{e}^{(j)T} \\mathbf{M} \\mathbf{e}^{(j)} }}\n    $$\n以下程序实现了这整个过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\nfrom scipy.special import jn_zeros, j0\nimport json\n\ndef compute_errors(R, N, p):\n    \"\"\"\n    Assembles FEM matrices, solves the eigenvalue problem, and computes errors.\n\n    Args:\n        R (float): Radius of the circular cavity.\n        N (int): Number of elements for the radial discretization.\n        p (int): Number of eigenmodes to compute.\n\n    Returns:\n        list: A list of pairs [E_lambda, E_u] for each of the p modes.\n    \"\"\"\n    \n    # 1. Discretization and Matrix Assembly\n    h = R / N\n    nodes = np.linspace(0, R, N + 1)\n    \n    # The system size is N x N for the N unknown nodal values (u_0 to u_{N-1})\n    K = np.zeros((N, N))\n    M = np.zeros((N, N))\n    \n    # Loop over elements to assemble global matrices\n    for k in range(N):\n        r_k = nodes[k]\n        r_k_plus_1 = nodes[k+1]\n        \n        # Element stiffness matrix\n        ke_factor = (r_k + r_k_plus_1) / (2.0 * h)\n        Ke = ke_factor * np.array([[1.0, -1.0], [-1.0, 1.0]])\n        \n        # Element mass matrix (exact integration)\n        Me = (h / 12.0) * np.array([\n            [3.0 * r_k + r_k_plus_1, r_k + r_k_plus_1],\n            [r_k + r_k_plus_1, r_k + 3.0 * r_k_plus_1]\n        ])\n        \n        # Assemble into global matrices\n        # The last node (N) has a value of 0, so we only need to consider\n        # contributions up to node N-1.\n        if k  N - 1:\n            K[k:k+2, k:k+2] += Ke\n            M[k:k+2, k:k+2] += Me\n        else: # Last element connects node N-1 to N\n            K[k, k] += Ke[0, 0]\n            M[k, k] += Me[0, 0]\n\n    # 2. Solve the Generalized Eigenvalue Problem\n    # We want the p smallest eigenvalues, which eigh provides by default.\n    eigenvalues, eigenvectors = eigh(K, M)\n    \n    lambda_h = eigenvalues[:p]\n    u_h_vecs = eigenvectors[:, :p]\n    \n    # 3. Compute Analytical Solutions\n    zeros_j0 = jn_zeros(0, p)\n    k_exact = zeros_j0 / R\n    lambda_exact = k_exact**2\n\n    # 4. Compute Error Metrics\n    results_for_case = []\n    r_coords = nodes[:N] # Coordinates for the N unknown DoFs\n\n    for j in range(p):\n        # Relative eigenvalue error\n        E_lambda = np.abs(lambda_h[j] - lambda_exact[j]) / lambda_exact[j]\n        \n        # Relative eigenfunction error\n        u_h = u_h_vecs[:, j]\n        \n        # Sample analytical eigenfunction at nodes\n        e_j = j0(k_exact[j] * r_coords)\n        \n        # Compute optimal scaling factor alpha\n        alpha_num = e_j.T @ M @ u_h\n        alpha_den = e_j.T @ M @ e_j\n        \n        if alpha_den == 0:\n            # This case is highly unlikely with a valid basis\n            E_u = float('inf')\n        else:\n            alpha = alpha_num / alpha_den\n            \n            # Compute M-norms for the error formula\n            numerator_vec = u_h - alpha * e_j\n            num_norm_sq = numerator_vec.T @ M @ numerator_vec\n            den_norm_sq = alpha_den # same as e_j.T @ M @ e_j\n            \n            E_u = np.sqrt(num_norm_sq / den_norm_sq)\n\n        results_for_case.append([E_lambda, E_u])\n        \n    return results_for_case\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 128, 3), # Test case 1\n        (1.0, 12, 2),  # Test case 2\n        (0.75, 96, 3)  # Test case 3\n    ]\n\n    all_results = []\n    for R, N, p in test_cases:\n        case_results = compute_errors(R, N, p)\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Use json.dumps with custom separators to create a compact string representation.\n    output_str = json.dumps(all_results, separators=(',', ':'))\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "本部分将介绍一种在现代计算方法中应用广泛的先进技术。这项高级练习  聚焦于不连续伽辽金（DG）方法的后验误差估计，该方法能够评估已得数值解的质量，并为自适应网格加密提供指导。你将通过编程实现一个基于残差的误差估计器，从而获得关于单元内部残差和跨单元通量跳跃等DG方法核心概念的实践经验。",
            "id": "4145888",
            "problem": "考虑在一个有界区间域 $\\Omega = (0,L)$ 上的均匀介质中的一维声学 Helmholtz 问题，其谐波声压场为 $p(x)$。在频域中，线性声学的标准模型在适当的无量纲单位下可简化为标量 Helmholtz 方程，\n$$\n- \\frac{d^2 p}{dx^2} - k^2 p = f \\quad \\text{in } \\Omega,\n$$\n其中 $k  0$ 是波数，$f(x)$ 是源项。对给定的边界值 $p_D$，施加 Dirichlet 边界条件 $p(0) = p_D$ 和 $p(L) = p_D$。\n\n从强形式出发，在 Sobolev 空间 $H^1(\\Omega)$ 上引入标准的变分（弱）形式：求满足 Dirichlet 边界条件的 $p \\in H^1(\\Omega)$，使得对于所有检验函数 $v \\in H^1_0(\\Omega)$，\n$$\n\\int_{\\Omega} \\frac{dp}{dx} \\frac{dv}{dx} \\, dx - k^2 \\int_{\\Omega} p v \\, dx = \\int_{\\Omega} f v \\, dx.\n$$\n为使用间断 Galerkin (DG) 方法（特别是对称内部罚分 Galerkin 方法）离散此问题，考虑将 $\\Omega$ 剖分为一个包含 $N$ 个不重叠单元 $K_e = (x_e, x_{e+1})$ 的网格 $\\mathcal{T}_h$，单元尺寸为 $h_e = x_{e+1} - x_e$（在下文的测试套件中是均匀的），并允许离散解 $p_h$ 在每个单元上是分段线性的，在单元间的面上可能存在不连续性。\n\n用于 DG 的基于残差的后验误差估计器结合了单元残差和面跳跃贡献。在一维空间中，对于分段线性的 $p_h$ 和分段常数的 $f$，由于二阶导数在每个单元内部消失，单元强残差简化为 $R_e(x) = f_e + k^2 p_h(x)$。该估计器汇总了：\n- 单元残差范数，按 $h_e^2$ 缩放，\n- 内部面通量跳跃和解跳跃（受罚），分别按 $h_e$ 和 $h_e^{-1}$ 缩放，\n- 反映 Dirichlet 边界条件弱施加的边界面项。\n\n令 $p_e^L = p_h(x_e)$ 和 $p_e^R = p_h(x_{e+1})$ 为单元 $e$ 中的左右端点值，并令 $s_e = (p_e^R - p_e^L)/h_e$ 为单元斜率。在 $K_e$ 上，当 $p_h(x) = p_e^L + s_e (x - x_e)$ 且源项 $f_e$ 为分段常数时，定义 $a_e = f_e + k^2 p_e^L$ 和 $b_e = k^2 s_e$。单元残差的 $L^2$ 范数平方积分为\n$$\n\\int_{K_e} R_e(x)^2 \\, dx = \\int_{0}^{h_e} \\left( a_e + b_e \\xi \\right)^2 \\, d\\xi = a_e^2 h_e + a_e b_e h_e^2 + \\frac{b_e^2 h_e^3}{3}.\n$$\n设单元残差的估计器权重为 $C_{\\text{res}}  0$，跳跃项的权重为 $C_{\\text{jump}}  0$，并设置与内部罚分法一致的罚参数 $C_{\\text{pen}} = \\gamma  0$。对于位于 $x_i$ 处、由单元 $i-1$ 和 $i$ 共享的每个内部面 $i=1,\\dots,N-1$，定义解跳跃和通量跳跃\n$$\n[p_h]_i = p_{i-1}^R - p_i^L, \\quad [\\partial_n p_h]_i = - s_{i-1} + s_i,\n$$\n面长度尺度为 $h_i = \\min(h_{i-1}, h_i)$。内部面指示器为\n$$\n\\eta_i^2 = C_{\\text{jump}} \\, h_i \\, \\left( [\\partial_n p_h]_i \\right)^2 + C_{\\text{pen}} \\, h_i^{-1} \\, \\left( [p_h]_i \\right)^2.\n$$\n对于 Dirichlet 边界条件，位于 $x=0$（左）和 $x=L$（右）的边界面指示器为\n$$\n\\eta_{\\text{bnd},0}^2 = C_{\\text{bnd}} \\, h_0^{-1} \\, (p_0^L - p_D)^2 + C_{\\text{flux}} \\, h_0 \\, \\left( -s_0 \\right)^2,\n$$\n$$\n\\eta_{\\text{bnd},L}^2 = C_{\\text{bnd}} \\, h_{N-1}^{-1} \\, (p_{N-1}^R - p_D)^2 + C_{\\text{flux}} \\, h_{N-1} \\, \\left( +s_{N-1} \\right)^2,\n$$\n其中 $C_{\\text{bnd}}$ 和 $C_{\\text{flux}}$ 是正常数权重参数（对于此问题，设 $C_{\\text{bnd}} = \\gamma$ 和 $C_{\\text{flux}} = 1$），$s_0$ 和 $s_{N-1}$ 分别是第一个和最后一个单元的斜率。全局估计器为\n$$\n\\eta = \\left( \\sum_{e=0}^{N-1} C_{\\text{res}} \\, h_e^2 \\int_{K_e} R_e(x)^2 \\, dx \\; + \\sum_{i=1}^{N-1} \\eta_i^2 \\; + \\eta_{\\text{bnd},0}^2 + \\eta_{\\text{bnd},L}^2 \\right)^{1/2}.\n$$\n\n您的任务是实现一个完整、可运行的程序，该程序：\n- 构建一个均匀网格，并为三个指定的测试用例评估上述基于残差的间断 Galerkin (DG) 后验误差估计器 $\\eta$。\n- 使用常数 $C_{\\text{res}} = 1$、$C_{\\text{jump}} = 1$、$C_{\\text{pen}} = \\gamma$、$C_{\\text{bnd}} = \\gamma$ 和 $C_{\\text{flux}} = 1$。\n- 假设分段线性的 $p_h$ 由每个单元的端点 $\\{(p_e^L, p_e^R)\\}_{e=0}^{N-1}$ 描述，每个单元的 $f_e$ 为分段常数，单元尺寸均匀为 $h = L/N$，以及 Dirichlet 边界数据为 $p_D$。\n\n完全按照上述方程定义的方式实现计算。\n\n测试套件（每个用例是一个元组 $(L, N, k, \\gamma, p_D, \\{(p_e^L, p_e^R)\\}_{e}, \\{f_e\\}_e)$）：\n1. 用例 A (理想路径，存在内部面跳跃，源项为零)：\n   - $L = 1.0$，$N = 4$，$k = \\pi$，$\\gamma = 10.0$，$p_D = 0.0$。\n   - 对于 $e = 0,1,2,3$，当 $h = L/N$ 时，设置 $x_e = e h$，$x_{e+1} = (e+1) h$，$p_e^L = \\sin(k x_e)$，$p_e^R = \\sin(k x_{e+1}) + \\delta_e$，其中 $\\delta_e = 0.01 \\cdot (-1)^e$。\n   - 所有单元的 $f_e = 0.0$。\n2. 用例 B (边界主导，内部残差为零，Dirichlet 不匹配非零)：\n   - $L = 1.0$，$N = 3$，$k = 2.0$，$\\gamma = 5.0$，$p_D = 0.0$。\n   - 令 $c = 0.5$，对所有单元设置 $p_e^L = c$ 和 $p_e^R = c$。\n   - 对所有单元设置 $f_e = - k^2 c$（因此在每个单元中 $f_e + k^2 p_h(x) = 0$）。\n3. 用例 C (单个单元，两个边界面均激活，源项非零)：\n   - $L = 2.0$，$N = 1$，$k = 1.5$，$\\gamma = 20.0$，$p_D = 0.0$。\n   - 设置 $p_0^L = 1.0$，$p_0^R = -1.0$，以及 $f_0 = 0.1$。\n\n您的程序应生成一行输出，其中包含用例 A、B 和 C 的三个估计器值 $\\eta$，格式为方括号内以逗号分隔的列表（例如，“[resultA,resultB,resultC]”）。每个结果必须是浮点数。无需单位；以指定格式报告纯数值。",
            "solution": "问题陈述已经过严格验证，并被认为是有效的。它在计算声学和数值分析领域有科学依据，特别是关于间断 Galerkin (DG) 方法和 Helmholtz 方程的后验误差估计。该问题是适定的，提供了为每个指定的测试用例计算唯一数值结果所需的所有必要定义、常数和数据。语言客观，数学形式明确。任务是实现一个精确定义的数学公式，这是科学计算中的一个标准练习。\n\n该解决方案要求为一维 Helmholtz 方程的 DG 离散化实现后验误差估计器 $\\eta$。全局估计器 $\\eta$ 定义为三个不同贡献之和的平方根：单元残差、内部面跳跃和边界面项。\n\n$$\n\\eta = \\left( \\sum_{e=0}^{N-1} \\eta_{\\text{res},e}^2 \\; + \\sum_{i=1}^{N-1} \\eta_i^2 \\; + \\eta_{\\text{bnd},0}^2 + \\eta_{\\text{bnd},L}^2 \\right)^{1/2}\n$$\n\n计算以模块化的方式实现。一个主函数为每个测试用例准备特定的参数，一个通用函数根据这些参数计算 $\\eta$。\n\n**1. 单元残差贡献**\n\n对于网格中的每个单元 $K_e = (x_e, x_{e+1})$，其中 $e \\in \\{0, 1, \\dots, N-1\\}$，对估计器的贡献为 $\\eta_{\\text{res},e}^2 = C_{\\text{res}} \\, h_e^2 \\int_{K_e} R_e(x)^2 \\, dx$。单元尺寸 $h_e = x_{e+1} - x_e$ 在所有单元中是均匀的，因此 $h_e = h = L/N$。单元残差为 $R_e(x) = f_e + k^2 p_h(x)$，其中 $f_e$ 是一个常数源项，解 $p_h(x)$ 是线性的，由 $p_h(x) = p_e^L + s_e (x - x_e)$ 给出，斜率为 $s_e = (p_e^R - p_e^L)/h$。\n\n单元 $K_e$ 上残差的 $L^2$ 范数的平方由以下精确积分给出：\n$$\n\\int_{K_e} R_e(x)^2 \\, dx = a_e^2 h + a_e b_e h^2 + \\frac{b_e^2 h^3}{3}\n$$\n其中 $a_e = f_e + k^2 p_e^L$ 和 $b_e = k^2 s_e$。该实现为每个单元计算斜率 $s_e$ 和系数 $a_e$、$b_e$，计算此积分，将其乘以 $C_{\\text{res}} h^2$（其中 $C_{\\text{res}} = 1$），并将其加到 $\\eta^2$ 的运行总和中。\n\n**2. 内部面跳跃贡献**\n\n对于位于单元 $i-1$ 和单元 $i$ 之间、$x_i$ 处的每个内部面 $i \\in \\{1, \\dots, N-1\\}$，会增加一个罚项 $\\eta_i^2$。此项解释了求解 $p_h$ 及其导数中的不连续性。其定义为：\n$$\n\\eta_i^2 = C_{\\text{jump}} \\, h_i \\, \\left( [\\partial_n p_h]_i \\right)^2 + C_{\\text{pen}} \\, h_i^{-1} \\, \\left( [p_h]_i \\right)^2\n$$\n常数给定为 $C_{\\text{jump}} = 1$ 和 $C_{\\text{pen}} = \\gamma$。对于我们的均匀网格，面长度尺度 $h_i$ 为 $h$。解跳跃 $[p_h]_i$ 和通量跳跃 $[\\partial_n p_h]_i$ 由以下公式给出：\n$$\n[p_h]_i = p_{i-1}^R - p_i^L\n$$\n$$\n[\\partial_n p_h]_i = - s_{i-1} + s_i\n$$\n该实现遍历 $N-1$ 个内部面，使用预先计算的斜率和给定的端点值计算这些跳跃，评估 $\\eta_i^2$，并将其加到 $\\eta^2$ 的总和中。对于 $N=1$ 的情况，没有内部面，此求和被正确跳过。\n\n**3. 边界面贡献**\n\n施加 Dirichlet 边界条件 $p(0)=p_D$ 和 $p(L)=p_D$ 会对估计器贡献两项。\n\n在左边界 $x=0$ 处，该项为：\n$$\n\\eta_{\\text{bnd},0}^2 = C_{\\text{bnd}} \\, h_0^{-1} \\, (p_0^L - p_D)^2 + C_{\\text{flux}} \\, h_0 \\, \\left( -s_0 \\right)^2\n$$\n在右边界 $x=L$ 处，该项为：\n$$\n\\eta_{\\text{bnd},L}^2 = C_{\\text{bnd}} \\, h_{N-1}^{-1} \\, (p_{N-1}^R - p_D)^2 + C_{\\text{flux}} \\, h_{N-1} \\, \\left( +s_{N-1} \\right)^2\n$$\n常数为 $C_{\\text{bnd}} = \\gamma$ 和 $C_{\\text{flux}} = 1$。该实现使用第一个（$e=0$）和最后一个（$e=N-1$）单元的数据计算这两项，并将它们加到 $\\eta^2$ 中。\n\n最后，总估计器值 $\\eta$ 计算为所有平方贡献累加和的平方根。此过程应用于所提供的三个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_eta(L, N, k, gamma, p_D, p_list, f_list):\n    \"\"\"\n    Computes the residual-based a posteriori error estimator for a 1D DG method.\n\n    Args:\n        L (float): Domain length.\n        N (int): Number of elements.\n        k (float): Wavenumber.\n        gamma (float): Penalty parameter, also used for C_pen and C_bnd.\n        p_D (float): Dirichlet boundary value.\n        p_list (list of tuples): List of (p_e^L, p_e^R) values for each element.\n        f_list (list of floats): List of source term values f_e for each element.\n\n    Returns:\n        float: The computed error estimator eta.\n    \"\"\"\n    h = L / N\n\n    C_res = 1.0\n    C_jump = 1.0\n    C_pen = gamma\n    C_bnd = gamma\n    C_flux = 1.0\n\n    eta_squared = 0.0\n    \n    slopes = []\n    \n    # Step 1: Sum of Element Residual contributions\n    for e in range(N):\n        p_e_L, p_e_R = p_list[e]\n        f_e = f_list[e]\n        \n        s_e = (p_e_R - p_e_L) / h if h > 0 else 0.0\n        slopes.append(s_e)\n        \n        a_e = f_e + k**2 * p_e_L\n        b_e = k**2 * s_e\n        \n        res_norm_sq = a_e**2 * h + a_e * b_e * h**2 + (b_e**2 * h**3) / 3\n        \n        eta_squared += C_res * h**2 * res_norm_sq\n        \n    # Step 2: Sum of Interior Face Jump contributions\n    # Loop over interior faces i=1, ..., N-1\n    # Face i is between element i-1 and i\n    for i in range(1, N):\n        p_left_R = p_list[i-1][1]\n        p_right_L = p_list[i][0]\n        s_left = slopes[i-1]\n        s_right = slopes[i]\n        \n        h_i = h # Uniform mesh\n        \n        jump_p = p_left_R - p_right_L\n        jump_flux = -s_left + s_right\n        \n        eta_i_sq = C_jump * h_i * jump_flux**2 + C_pen * (h_i**-1) * jump_p**2\n        eta_squared += eta_i_sq\n\n    # Step 3: Boundary Face contributions\n    if N > 0:\n        # Left boundary at x=0\n        p_0_L = p_list[0][0]\n        s_0 = slopes[0]\n        h_bnd_0 = h\n        eta_bnd_0_sq = C_bnd * (h_bnd_0**-1) * (p_0_L - p_D)**2 + C_flux * h_bnd_0 * (-s_0)**2\n        eta_squared += eta_bnd_0_sq\n        \n        # Right boundary at x=L\n        p_N_minus_1_R = p_list[N-1][1]\n        s_N_minus_1 = slopes[N-1]\n        h_bnd_L = h\n        eta_bnd_L_sq = C_bnd * (h_bnd_L**-1) * (p_N_minus_1_R - p_D)**2 + C_flux * h_bnd_L * (s_N_minus_1)**2\n        eta_squared += eta_bnd_L_sq\n        \n    return np.sqrt(eta_squared)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is processed to generate p_list and f_list before being passed\n    # to the calculator function.\n    \n    # Case A\n    L_A, N_A, k_A, gamma_A, p_D_A = 1.0, 4, np.pi, 10.0, 0.0\n    h_A = L_A / N_A\n    p_list_A = []\n    for e in range(N_A):\n        x_e = e * h_A\n        x_e_plus_1 = (e + 1) * h_A\n        delta_e = 0.01 * ((-1)**e)\n        p_e_L = np.sin(k_A * x_e)\n        p_e_R = np.sin(k_A * x_e_plus_1) + delta_e\n        p_list_A.append((p_e_L, p_e_R))\n    f_list_A = [0.0] * N_A\n    case_A = (L_A, N_A, k_A, gamma_A, p_D_A, p_list_A, f_list_A)\n\n    # Case B\n    L_B, N_B, k_B, gamma_B, p_D_B = 1.0, 3, 2.0, 5.0, 0.0\n    c_B = 0.5\n    p_list_B = [(c_B, c_B)] * N_B\n    f_list_B = [-k_B**2 * c_B] * N_B\n    case_B = (L_B, N_B, k_B, gamma_B, p_D_B, p_list_B, f_list_B)\n\n    # Case C\n    L_C, N_C, k_C, gamma_C, p_D_C = 2.0, 1, 1.5, 20.0, 0.0\n    p_list_C = [(1.0, -1.0)]\n    f_list_C = [0.1]\n    case_C = (L_C, N_C, k_C, gamma_C, p_D_C, p_list_C, f_list_C)\n\n    test_cases = [case_A, case_B, case_C]\n    \n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        eta = calculate_eta(*case)\n        results.append(eta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}