{
    "hands_on_practices": [
        {
            "introduction": "本章的第一个实践练习将引导你完成一个基础但至关重要的任务：从零开始构建有限元系统矩阵。我们将以一个二维稳态热扩散问题为例，其控制方程（拉普拉斯方程）在数学上等同于声学中的势流问题，因此其装配过程具有普遍性。通过手动计算一个简单三角形网格的局部刚度矩阵，并将其装配到全局系统中，你将深入理解从弱形式到最终代数方程的完整力学过程 。",
            "id": "4020951",
            "problem": "考虑在一个预混火焰旁的薄惰性内衬段中的稳态热扩散，该过程在无量纲单位正方形域 $\\Omega = [0,1] \\times [0,1]$上建模。其各向同性导热系数 $k$ 在空间上是恒定的，且体积热源为零。控制方程为稳态能量守恒方程，即在 $\\Omega$ 中 $-\\nabla \\cdot \\left( k \\nabla T \\right) = 0$，并在外边界上施加狄利克雷（Dirichlet）边界条件。使用有限元（FE）方法，在三角形上采用分段线性拉格朗日（Lagrange）基函数来离散化弱形式。\n\n计算网格在四个角点处有节点，并在中心有一个内部节点：节点 $1$位于$(0,0)$，节点 $2$位于$(1,0)$，节点 $3$位于$(1,1)$，节点 $4$位于$(0,1)$，以及节点 $5$位于$(0.5,0.5)$。通过将中心节点连接到每条边，将网格三角化为四个三角形：三角形 $(1,2,5)$、$(2,3,5)$、$(3,4,5)$ 和 $(4,1,5)$。边界节点温度被指定为狄利克雷约束：$T_{1} = 723.4 \\, \\text{K}$，$T_{2} = 921.7 \\, \\text{K}$，$T_{3} = 801.3 \\, \\text{K}$，以及 $T_{4} = 649.8 \\, \\text{K}$。导热系数为 $k = 1$。\n\n任务：\n- 定义任意三角形上的局部分段线性拉格朗日基函数（用其重心坐标表示），并用笛卡尔坐标表示其梯度。\n- 从扩散方程的弱形式出发，使用这些基函数为任意三角形构建局部单元刚度矩阵。\n- 对于顶点为 $(0,0)$、$(1,0)$ 和 $(0.5,0.5)$ 的三角形 $(1,2,5)$，计算基函数的梯度及其局部刚度矩阵的所有条目。通过对称性解释这对其他三个三角形意味着什么。\n- 为内部节点 $5$ 组装全局刚度矩阵行，并强加（通过消元法）狄利克雷边界条件，以获得关于未知内部温度 $T_{5}$ 的标量线性方程。\n- 使用给定的边界值求解此标量方程，得到 $T_{5}$。\n\n将最终答案表示为 $T_{5}$ 的值（单位为开尔文）。将您的答案四舍五入到五位有效数字。在最终数值答案中不要包含单位。",
            "solution": "用户希望我使用有限元法（FEM）解决方形域上的稳态热扩散问题。\n\n### 第1步：提取已知条件\n- **控制方程：** 稳态热扩散方程 $-\\nabla \\cdot (k \\nabla T) = 0$ 于 $\\Omega$ 中。\n- **域：** $\\Omega = [0,1] \\times [0,1]$。\n- **导热系数：** $k=1$（恒定且各向同性）。\n- **源项：** $0$。\n- **离散化方法：** 有限元法，在三角形上采用分段线性拉格朗日（Lagrange）基函数。\n- **网格节点：**\n  - 节点 $1$：$(0,0)$\n  - 节点 $2$：$(1,0)$\n  - 节点 $3$：$(1,1)$\n  - 节点 $4$：$(0,1)$\n  - 节点 $5$：$(0.5,0.5)$\n- **网格单元（三角形）：**\n  - $\\Omega_1$: $(1,2,5)$\n  - $\\Omega_2$: $(2,3,5)$\n  - $\\Omega_3$: $(3,4,5)$\n  - $\\Omega_4$: $(4,1,5)$\n- **边界条件（狄利克雷）：**\n  - $T_1 = 723.4$\n  - $T_2 = 921.7$\n  - $T_3 = 801.3$\n  - $T_4 = 649.8$\n\n### 第2步：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题描述了稳态热传导，由恒定导热系数下的拉普拉斯方程控制。这是热传递和物理学中的一个基本且公认的原理。该设置在科学上是合理的。\n2.  **适定性：** 该问题是一个标准的椭圆边值问题（在封闭域上带有狄利克雷边界条件的拉普拉斯方程）。众所周知，此类问题是适定的，存在唯一且稳定的解。使用有限元法（FEM）进行离散化也是一个标准且有效的程序。\n3.  **客观性：** 该问题使用精确的数学语言和数值数据进行表述。没有主观或模棱两可的陈述。\n4.  **完整性和一致性：** 该问题提供了继续进行所需的所有信息：控制方程、域、网格几何形状、边界条件和材料属性。数据是自洽的。\n5.  **相关性：** 固体衬套中的热扩散问题与计算燃烧学直接相关，在计算燃烧学中，热气体和固体部件之间的共轭传热是需要建模的关键现象。\n\n### 第3步：结论和行动\n该问题有效。将提供完整的解决方案。\n\n### 求解推导\n控制方程是无热源的稳态热扩散方程，对于恒定导热系数 $k$，该方程简化为拉普拉斯方程：\n$$ -k \\nabla^2 T = 0 $$\n弱形式是通过乘以一个测试函数 $v$ 并在域 $\\Omega$ 上积分得到的。使用分部积分法（格林第一恒等式），我们得到：\n$$ \\int_{\\Omega} k (\\nabla v) \\cdot (\\nabla T) \\,d\\Omega - \\int_{\\partial\\Omega} v (k \\nabla T \\cdot \\mathbf{n}) \\,dS = 0 $$\n对于有限元法，我们将温度场 $T(x,y)$ 近似为基函数 $N_j(x,y)$ 的线性组合：\n$$ T_h(x,y) = \\sum_{j=1}^{5} T_j N_j(x,y) $$\n其中 $T_j$ 是未知的节点温度。使用伽辽金（Galerkin）方法，我们选择测试函数 $v$ 为基函数 $N_i(x,y)$。强加狄利克雷边界条件时，对于与内部节点相关的测试函数，边界积分的贡献为零。得到的线性方程组为 $K \\mathbf{T} = \\mathbf{F}$，其中全局刚度矩阵 $K$ 的条目由单元刚度矩阵 $K^e$ 组装而成：\n$$ K_{ij} = \\sum_{e} K_{ij}^e = \\sum_{e} \\int_{\\Omega_e} k (\\nabla N_i) \\cdot (\\nabla N_j) \\,d\\Omega $$\n向量 $\\mathbf{F}$ 包含源项和自然边界条件的贡献，在本问题中这些都为零。\n\n**任务1：基函数及其梯度**\n对于顶点为 $(x_1, y_1)$、$(x_2, y_2)$ 和 $(x_3, y_3)$ 的三角形单元，分段线性拉格朗日基函数 $N_i(x,y)$ 与重心坐标 $\\lambda_i(x,y)$ 相同。基函数 $N_i$ 在节点 $i$ 处等于 $1$，在其他两个节点处等于 $0$。该函数可以写成 $N_i(x,y) = a_i + b_i x + c_i y$。基函数的梯度在单元内是一个常数向量：\n$$ \\nabla N_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} b_i \\\\ c_i \\end{pmatrix} $$\n系数由以下公式给出：\n$$ b_1 = \\frac{y_2 - y_3}{2 A_e}, \\quad c_1 = \\frac{x_3 - x_2}{2 A_e} $$\n$$ b_2 = \\frac{y_3 - y_1}{2 A_e}, \\quad c_2 = \\frac{x_1 - x_3}{2 A_e} $$\n$$ b_3 = \\frac{y_1 - y_2}{2 A_e}, \\quad c_3 = \\frac{x_2 - x_1}{2 A_e} $$\n其中 $A_e$ 是三角形的面积。\n\n**任务2：局部单元刚度矩阵**\n由于基函数梯度和导热系数 $k$ 在线性三角形单元上是常数，单元刚度矩阵的积分简化为：\n$$ K_{ij}^e = \\int_{\\Omega_e} k (\\nabla N_i) \\cdot (\\nabla N_j) \\,d\\Omega = k ((\\nabla N_i) \\cdot (\\nabla N_j)) \\int_{\\Omega_e} \\,d\\Omega = k A_e (\\nabla N_i \\cdot \\nabla N_j) $$\n$$ K_{ij}^e = k A_e (b_i b_j + c_i c_j) $$\n\n**任务3：对三角形(1,2,5)进行计算**\n设单元 $\\Omega_1$ 为全局节点为 $(1,2,5)$ 的三角形。我们分别将局部节点索引 $1,2,3$ 分配给全局节点 $1,2,5$。顶点坐标为：$(x_1,y_1) = (0,0)$、$(x_2,y_2) = (1,0)$ 和 $(x_3,y_3) = (0.5,0.5)$。\n面积 $A_e$ 计算如下：\n$$ 2 A_e = \\det \\begin{pmatrix} x_1  y_1  1 \\\\ x_2  y_2  1 \\\\ x_3  y_3  1 \\end{pmatrix} = \\det \\begin{pmatrix} 0  0  1 \\\\ 1  0  1 \\\\ 0.5  0.5  1 \\end{pmatrix} = 1(1 \\cdot 0.5 - 0 \\cdot 0.5) = 0.5 $$\n因此，$A_e = 0.25$。\n与局部节点相关联的基函数的梯度为：\n- 对于局部节点 $1$（全局节点 $1$）：\n  $b_1 = \\frac{0 - 0.5}{0.5} = -1$, $c_1 = \\frac{0.5 - 1}{0.5} = -1$.\n  $\\nabla N_1 = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix}$.\n- 对于局部节点 $2$（全局节点 $2$）：\n  $b_2 = \\frac{0.5 - 0}{0.5} = 1$, $c_2 = \\frac{0 - 0.5}{0.5} = -1$.\n  $\\nabla N_2 = \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}$.\n- 对于局部节点 $3$（全局节点 $5$）：\n  $b_3 = \\frac{0 - 0}{0.5} = 0$, $c_3 = \\frac{1 - 0}{0.5} = 2$.\n  $\\nabla N_5 = \\begin{pmatrix} 0 \\\\ 2 \\end{pmatrix}$.\n\n当 $k=1$ 且 $A_e=0.25$ 时，局部刚度矩阵 $K^{(1,2,5)}$ 的条目为：\n$K_{11}^e = (1)(0.25)((-1)^2 + (-1)^2) = 0.25 \\times 2 = 0.5$\n$K_{12}^e = (1)(0.25)((-1)(1) + (-1)(-1)) = 0.25 \\times 0 = 0$\n$K_{15}^e = (1)(0.25)((-1)(0) + (-1)(2)) = 0.25 \\times (-2) = -0.5$\n$K_{22}^e = (1)(0.25)(1^2 + (-1)^2) = 0.25 \\times 2 = 0.5$\n$K_{25}^e = (1)(0.25)((1)(0) + (-1)(2)) = 0.25 \\times (-2) = -0.5$\n$K_{55}^e = (1)(0.25)(0^2 + 2^2) = 0.25 \\times 4 = 1.0$\n单元 $(1,2,5)$ 的局部刚度矩阵（按全局节点编号索引）为：\n$$ K^{(1,2,5)} = \\begin{pmatrix} 0.5  0  -0.5 \\\\ 0  0.5  -0.5 \\\\ -0.5  -0.5  1.0 \\end{pmatrix}_{\\text{rows/cols for nodes } 1,2,5} $$\n另外三个三角形 $(2,3,5)$、$(3,4,5)$ 和 $(4,1,5)$ 通过围绕域中心的旋转和反射与三角形 $(1,2,5)$ 全等。由于局部刚度矩阵的公式仅取决于三角形的几何形状（这对所有四个三角形都相同），因此它们各自局部刚度矩阵中条目的数值将是相同的，前提是使用一致的局部节点编号方案（例如，将中心节点映射到局部节点 $3$，将两个边界节点映射到局部节点 $1$ 和 $2$）。\n\n**任务4：全局刚度矩阵组装和边界条件施加**\n我们需要找到未知温度 $T_5$ 的方程。这对应于全局系统 $K \\mathbf{T} = \\mathbf{F}$ 的第五行。由于没有源项，初始方程为：\n$$ K_{51}T_1 + K_{52}T_2 + K_{53}T_3 + K_{54}T_4 + K_{55}T_5 = 0 $$\n系数 $K_{5j}$ 是通过对所有包含节点 $5$ 的单元的贡献求和来组装的。节点 $5$ 是所有四个单元的一部分。\n- $K_{55}$：对角项从每个单元刚度矩阵的 $(5,5)$ 条目中获得贡献。在我们的局部表示法中，这对应于局部矩阵的 $(3,3)$ 条目。\n  $K_{55} = K_{55}^{(1,2,5)} + K_{55}^{(2,3,5)} + K_{55}^{(3,4,5)} + K_{55}^{(4,1,5)} = 1.0 + 1.0 + 1.0 + 1.0 = 4.0$。\n- $K_{51}$：该非对角项从同时包含节点 $1$ 和 $5$ 的单元获得贡献。这些是单元 $(1,2,5)$ 和 $(4,1,5)$。从 $K^{(1,2,5)}$ 贡献为 $K_{15}^e = -0.5$。由于对称性，从 $K^{(4,1,5)}$ 的贡献也是 $-0.5$。\n  $K_{51} = -0.5 + (-0.5) = -1.0$。\n- $K_{52}$：该项从单元 $(1,2,5)$ 和 $(2,3,5)$ 获得贡献。从 $K^{(1,2,5)}$ 贡献为 $K_{25}^e = -0.5$。从 $K^{(2,3,5)}$ 的贡献也是 $-0.5$。\n  $K_{52} = -0.5 + (-0.5) = -1.0$。\n- 根据网格的对称性，其余的非对角项也为 $-1.0$：\n  $K_{53} = -1.0$\n  $K_{54} = -1.0$\n\n节点 $5$ 的组装方程为：\n$$ -1.0 T_1 - 1.0 T_2 - 1.0 T_3 - 1.0 T_4 + 4.0 T_5 = 0 $$\n施加狄利克雷边界条件意味着将已知的 $T_1, T_2, T_3, T_4$ 值代入此方程。这是一个关于单个未知数 $T_5$ 的单一线性方程。\n\n**任务5：求解 $T_5$**\n重新整理方程以求解 $T_5$：\n$$ 4.0 T_5 = T_1 + T_2 + T_3 + T_4 $$\n$$ T_5 = \\frac{T_1 + T_2 + T_3 + T_4}{4} $$\n这一结果表明，对于这个特定的对称网格，中心的有限元解是角点温度的算术平均值，这与离散最大值原理一致，并模仿了调和函数的均值性质。\n代入给定的边界温度值：\n$$ T_5 = \\frac{723.4 + 921.7 + 801.3 + 649.8}{4} $$\n$$ T_5 = \\frac{3096.2}{4} $$\n$$ T_5 = 774.05 $$\n问题要求答案保留五位有效数字。计算值 $774.05$ 已经有五位有效数字。",
            "answer": "$$\\boxed{774.05}$$"
        },
        {
            "introduction": "掌握了正确的装配流程后，理解刚度矩阵中每个元素的物理意义至关重要。此实践练习通过一个思想实验，要求你实现一个“有缺陷”的装配程序，该程序在每个单元中均忽略了节点间的耦合项（即非对角线项）。通过对比正确解与缺陷解的差异，你将直观地认识到非对角线元素在捕捉问题物理特性（即节点间的相互作用）方面为何不可或缺 。",
            "id": "3206662",
            "problem": "考虑在区间 $[0,1]$ 上的标量场 $u(x)$ 的一维边值问题，该问题由微分方程 $-u''(x) = f(x)$ 和齐次狄利克雷边界条件 $u(0) = 0$ 及 $u(1) = 0$ 定义。使用有限元法（FEM, Finite Element Method），在线性形函数的 $N$ 个单元的均匀网格上，组装全局刚度矩阵和载荷向量。求解得到的线性系统，以获得 $u(x)$ 的节点值。\n\n您必须实现两个组装例程：\n- 一个正确的组装例程，根据标准的伽辽金公式，将每个单元的所有贡献添加到全局刚度矩阵和载荷向量中。\n- 一个有缺陷的组装例程，对于每个单元，该例程始终忽略添加与局部节点对 $(0,1)$ 相关的耦合项，即单元两个局部节点之间的非对角贡献。所有其他贡献（包括对角项和载荷向量项）均正常组装。\n\n针对每个指定的测试用例，求解正确组装的系统和有缺陷组装的系统，并计算两个节点解（包括边界节点）之间差值的最大范数。节点向量 $v$ 的最大范数定义为 $\\max_i |v_i|$。\n\n实现数值积分以获得单元载荷向量。在参考单元上使用两点高斯积分法则，并将其映射到物理单元。当三角函数出现在 $f(x)$ 中时，角度必须以弧度为单位进行解释。\n\n最终输出必须为单行，其中包含一个用方括号括起来的逗号分隔列表，列表内容为所有给定测试用例的最大范数差值，顺序与下文所列顺序一致。\n\n测试套件：\n- 用例 $1$：$N=4$，$f(x) = 1$。\n- 用例 $2$：$N=8$，$f(x) = \\sin(\\pi x)$。\n- 用例 $3$：$N=1$，$f(x) = 1$。\n- 用例 $4$：$N=20$，$f(x) = e^{x}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个浮点数，表示用例 $i$ 的正确解与有缺陷解之间的最大范数差值。",
            "solution": "该问题要求使用有限元法（FEM）求解一个一维边值问题（BVP），并与一个有缺陷组装的系统进行比较。该BVP由定义域 $x \\in [0, 1]$ 上的微分方程 $-u''(x) = f(x)$ 和齐次狄利克雷边界条件 $u(0)=0$ 及 $u(1)=0$ 给出。\n\n求解过程包括以下步骤：\n1.  推导BVP的弱形式。\n2.  对定义域进行离散化，并使用线性形函数逼近解。\n3.  计算单元刚度矩阵和单元载荷向量。\n4.  使用正确和有缺陷两种程序组装全局刚度矩阵和载荷向量。\n5.  应用边界条件并求解得到的线性系统。\n6.  计算两个解之间差值的最大范数。\n\n### 第1步：弱形式\n为了推导弱形式，我们将微分方程乘以一个来自合适空间（这里是索伯列夫空间 $H_0^1(0,1)$，即在边界处为零的函数组成的空间）的测试函数 $v(x)$，并在定义域 $[0,1]$ 上积分：\n$$ -\\int_0^1 u''(x) v(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx $$\n对左侧应用分部积分得到：\n$$ \\left[-u'(x)v(x)\\right]_0^1 + \\int_0^1 u'(x) v'(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx $$\n由于测试函数 $v(x)$ 必须满足齐次边界条件，$v(0)=0$ 和 $v(1)=0$，边界项 $[-u'(x)v(x)]_0^1$ 为零。因此弱形式为：求 $u \\in H_0^1(0,1)$，使得对于所有 $v \\in H_0^1(0,1)$：\n$$ \\int_0^1 u'(x) v'(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx $$\n这可以表示为 $a(u,v) = L(v)$，其中 $a(u,v) = \\int_0^1 u'(x) v'(x) \\,dx$ 是一个双线性形式，$L(v) = \\int_0^1 f(x) v(x) \\,dx$ 是一个线性泛函。\n\n### 第2步：离散化与有限元法公式\n将定义域 $[0,1]$ 离散化为 $N$ 个长度为 $h=1/N$ 的均匀单元。这会创建 $N+1$ 个节点，位置在 $x_i = i \\cdot h$，$i=0, 1, \\dots, N$。未知函数 $u(x)$ 被近似为分段线性基函数 $\\phi_j(x)$（通常称为“帽函数”）的线性组合：\n$$ u_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x) $$\n其中 $U_j$ 是解的未知节点值，$U_j \\approx u(x_j)$。基函数 $\\phi_j(x)$ 在节点 $x_j$ 处为 $1$，在所有其他节点处为 $0$。伽辽金法使用与基函数相同的函数作为测试函数，即 $v(x) = \\phi_i(x)$。将这些代入弱形式，得到一个线性方程组 $K U = F$，其中：\n-   $K_{ij} = a(\\phi_j, \\phi_i) = \\int_0^1 \\phi_j'(x) \\phi_i'(x) \\,dx$ 是全局刚度矩阵 $K$ 的项。\n-   $F_i = L(\\phi_i) = \\int_0^1 f(x) \\phi_i(x) \\,dx$ 是全局载荷向量 $F$ 的项。\n-   $U$ 是节点值 $U_j$ 的向量。\n\n### 第3步：单元级计算\n计算以逐个单元为基础进行，然后组装成全局系统。对于一个跨越 $[x_k, x_{k+1}]$ 的单元 $e$，我们使用两个局部线性形函数 $N_0(x)$ 和 $N_1(x)$。它们在单元上的导数是常数：$N_0'(x) = -1/h$ 和 $N_1'(x) = 1/h$。\n\n$2 \\times 2$ 的单元刚度矩阵 $k^e$ 的项为 $k^e_{ij} = \\int_{x_k}^{x_{k+1}} N_i'(x) N_j'(x) \\,dx$。计算结果为：\n$$ k^e = \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} $$\n单元载荷向量 $f^e$ 的项为 $f^e_i = \\int_{x_k}^{x_{k+1}} f(x) N_i(x) \\,dx$。该积分使用数值积分计算。我们将积分变换到参考单元 $[-1,1]$ 上：\n$$ f^e_i = \\int_{-1}^1 f(x(\\xi)) N_i(\\xi) J \\,d\\xi $$\n其中 $\\xi$ 是参考单元上的坐标，$J=h/2$ 是变换 $x(\\xi) = x_k + \\frac{h}{2}(\\xi+1)$ 的雅可比行列式，$N_i(\\xi)$ 是参考单元上的线性形函数（$N_0(\\xi) = (1-\\xi)/2$, $N_1(\\xi) = (1+\\xi)/2$）。\n使用点为 $\\xi_{g} = \\pm 1/\\sqrt{3}$ 且权重为 $w_{g} = 1$ 的两点高斯积分法则，该积分近似为：\n$$ f^e_i \\approx \\frac{h}{2} \\sum_{q=1}^2 w_q f(x(\\xi_q)) N_i(\\xi_q) $$\n\n### 第4步：全局系统组装\n全局矩阵 $K$（大小为 $(N+1) \\times (N+1)$）和向量 $F$（大小为 $N+1$）初始化为零。对于连接全局节点 $i$ 和 $i+1$ 的每个单元 $e$：\n-   **正确组装**：$2 \\times 2$ 的矩阵 $k^e$ 被添加到全局矩阵 $K_c$ 的相应块中。具体来说，$K_c[i,i] += k^e_{00}$，$K_c[i,i+1] += k^e_{01}$，$K_c[i+1,i] += k^e_{10}$，以及 $K_c[i+1,i+1] += k^e_{11}$。这将产生一个对称的三对角矩阵。\n-   **有缺陷的组装**：根据问题描述，忽略 $k^e$ 的非对角项（$k^e_{01}$ 和 $k^e_{10}$）。只添加对角项：$K_d[i,i] += k^e_{00}$ 和 $K_d[i+1,i+1] += k^e_{11}$。这将产生一个对角全局刚度矩阵 $K_d$。\n-   **载荷向量组装**：在两种情况下，单元载荷向量 $f^e$ 都被正常组装。$F[i] += f^e_0$ 和 $F[i+1] += f^e_1$。\n\n### 第5步：应用边界条件与求解\n边界条件 $u(0)=0$ 和 $u(1)=0$ 意味着节点值 $U_0$ 和 $U_N$ 已知且等于 $0$。因此，我们可以求解 $N-1$ 个未知的内部节点值 $U_1, \\dots, U_{N-1}$。这通过提取与内部节点对应的子系统来完成。设 $\\hat{K}$ 为 $K$ 的对应于行和列 $1$ 到 $N-1$ 的 $(N-1) \\times (N-1)$ 子矩阵，$\\hat{F}$ 为 $F$ 的对应于条目 $1$ 到 $N-1$ 的子向量。我们求解简化的系统：\n$$ \\hat{K}_c \\hat{U}_c = \\hat{F} \\quad \\text{和} \\quad \\hat{K}_d \\hat{U}_d = \\hat{F} $$\n向量 $\\hat{U}_c$ 和 $\\hat{U}_d$ 包含内部节点的解。\n\n### 第6步：比较\n完整的解向量 $u_c$ 和 $u_d$ 是通过在内部解 $\\hat{U}_c$ 和 $\\hat{U}_d$ 的前面和后面附加零边界值来构造的。最终的度量标准是差值向量的最大范数：\n$$ \\text{diff} = \\max_i |(u_c)_i - (u_d)_i| $$\n对于 $N=1$ 的特殊情况，没有内部节点。解完全由边界条件 $u(0)=0$ 和 $u(1)=0$ 决定。因此，$u_c$ 和 $u_d$ 都是向量 $[0, 0]$，它们的差值为 $0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that sets up test cases and prints the final result.\n    \"\"\"\n\n    def solve_case(N, f_func):\n        \"\"\"\n        Solves the BVP for a given number of elements N and source function f.\n        Returns the max norm of the difference between the correct and defective solutions.\n        \"\"\"\n        # For N=1, there are no interior nodes. The solution is fixed by boundary\n        # conditions u(0)=0, u(1)=0. Both correct and defective solutions are [0,0],\n        # so the difference is 0. This also handles invalid N  2.\n        if N  2:\n            return 0.0\n\n        h = 1.0 / N\n        num_nodes = N + 1\n        \n        # Initialize global matrices and vectors for all N+1 nodes\n        K_correct = np.zeros((num_nodes, num_nodes))\n        K_defective = np.zeros((num_nodes, num_nodes))\n        F_global = np.zeros(num_nodes)\n        \n        # Element stiffness matrix is constant for all uniform elements\n        k_elem = (1.0 / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n        # Gaussian quadrature setup for the reference element [-1, 1]\n        xi_g = np.array([-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)])\n        w_g = np.array([1.0, 1.0])  # Weights are both 1 for 2-point rule\n        \n        # Shape functions N0(xi), N1(xi) evaluated at quadrature points\n        N0_vals = 0.5 * (1.0 - xi_g)\n        N1_vals = 0.5 * (1.0 + xi_g)\n\n        # Assembly loop over N elements\n        for e in range(N):\n            # Global node indices for element e\n            node_i, node_j = e, e + 1\n            \n            # --- Correct Stiffness Assembly ---\n            K_correct[node_i, node_i] += k_elem[0, 0]\n            K_correct[node_i, node_j] += k_elem[0, 1]\n            K_correct[node_j, node_i] += k_elem[1, 0]\n            K_correct[node_j, node_j] += k_elem[1, 1]\n            \n            # --- Defective Stiffness Assembly ---\n            K_defective[node_i, node_i] += k_elem[0, 0]\n            K_defective[node_j, node_j] += k_elem[1, 1]  # Omitting off-diagonals\n            \n            # --- Load Vector Assembly ---\n            x_left = e * h\n            # Map quadrature points from reference to physical element\n            x_q_physical = x_left + 0.5 * h * (1.0 + xi_g)\n            \n            # Evaluate f(x) at physical quadrature points\n            f_at_q = f_func(x_q_physical)\n            \n            # Jacobian of the transformation x(xi) is h/2\n            J = h / 2.0\n            \n            # Compute element load vector components using quadrature\n            # integral(f*N_i)dx ~ sum( f(x(xi_k))*N_i(xi_k) * J * w_k )\n            f_elem_0 = J * np.sum(f_at_q * N0_vals * w_g)\n            f_elem_1 = J * np.sum(f_at_q * N1_vals * w_g)\n            \n            F_global[node_i] += f_elem_0\n            F_global[node_j] += f_elem_1\n\n        # Apply boundary conditions by reducing the system to interior nodes (1 to N-1)\n        interior_slice = slice(1, N)\n        K_c_reduced = K_correct[interior_slice, interior_slice]\n        K_d_reduced = K_defective[interior_slice, interior_slice]\n        F_reduced = F_global[interior_slice]\n        \n        # Solve the linear systems for interior nodal values\n        u_hat_correct = np.linalg.solve(K_c_reduced, F_reduced)\n        u_hat_defective = np.linalg.solve(K_d_reduced, F_reduced)\n        \n        # The full solution vectors include the zero boundary conditions\n        u_correct = np.zeros(num_nodes)\n        u_defective = np.zeros(num_nodes)\n        u_correct[interior_slice] = u_hat_correct\n        u_defective[interior_slice] = u_hat_defective\n        \n        # Compute the maximum norm of the difference vector\n        max_norm_diff = np.max(np.abs(u_correct - u_defective))\n        \n        return max_norm_diff\n\n    # Define test cases from the problem statement.\n    # Lambdas are defined to be compatible with numpy array inputs.\n    test_cases = [\n        (4, lambda x: np.full_like(x, 1.0)),\n        (8, lambda x: np.sin(np.pi * x)),\n        (1, lambda x: np.full_like(x, 1.0)),\n        (20, lambda x: np.exp(x))\n    ]\n\n    results = []\n    for N, f in test_cases:\n        results.append(solve_case(N, f))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本章的最后一个实践将你的技能从手动计算提升到可验证的自动化代码实现，并直接应用于核心的声学问题。我们将处理一维亥姆霍兹方程（1D Helmholtz equation），它是频率域计算声学的基石。更重要的是，本练习引入了“制造解方法”(Method of Manufactured Solutions) 这一专业级代码验证技术，通过它你可以系统地测试并确保你的有限元程序和全局矩阵装配的正确性 。",
            "id": "4117066",
            "problem": "考虑区间 $x \\in (0,L)$ 上的一维频域声学模型，未知声压 $p(x)$ 由微分方程 $p''(x) + k^2 p(x) = s(x)$ 和边界条件 $p(0) = p_D$ 及 $p'(L) + \\alpha p(L) = g$ 控制。所有量均为无量纲。目标是验证使用一阶（线性）单元的伽辽金有限元法中全局系统矩阵组装的正确性。\n\n从控制微分方程和边界条件出发，通过将方程与任意试函数 $v(x)$ 相乘并进行分部积分，导出弱形式。通过对单元刚度矩阵和质量矩阵的贡献求和，并引入 $x=L$ 处的罗宾边界项，来组装全局系统矩阵。在全局系统中使用消元法施加狄利克雷条件 $p(0) = p_D$。求解得到的线性系统，以获得节点基下的离散解 $p_h(x)$。\n\n您的程序必须实现以下内容：\n\n- 在 $(0,L)$ 上使用包含 $N$ 个单元的均匀网格，节点为 $x_i = i h$，$i = 0,1,\\dots,N$，其中 $h = L/N$。\n- 在每个单元上使用一阶（线性）基函数，并使用两点高斯求积法则来计算由源项 $s(x)$ 产生的单元载荷向量。\n- 组装与弱形式对应的全局系统矩阵，该矩阵结合了刚度项、由 $k^2$ 引起的负质量项贡献以及 $x=L$ 处的罗宾边界贡献。将由 $g$ 引起的边界载荷添加到全局右端项。\n- 在 $x=0$ 处通过对全局矩阵和右端项进行消元来施加狄利克雷边界条件（即，一致地修改第一行和第一列，以强加 $p(0) = p_D$）。\n- 求解全局线性系统以获得节点值，并计算指定的验证量。\n\n为确保可测试性和覆盖率，请使用精确解方法（Method of Manufactured Solutions）：定义一个光滑的精确压力$p_{\\mathrm{exact}}(x)$，并设置源项$s(x) = p_{\\mathrm{exact}}''(x) + k^2 p_{\\mathrm{exact}}(x)$和罗宾数据$g = p_{\\mathrm{exact}}'(L) + \\alpha p_{\\mathrm{exact}}(L)$；设置狄利克雷值$p_D = p_{\\mathrm{exact}}(0)$。这确保了精确解满足微分方程和边界条件。\n\n实现以下三个测试用例：\n\n- 测试用例 1（一般情况）：$L = 1$, $N = 16$, $k = 4$, $\\alpha = 1.3$, $p_{\\mathrm{exact}}(x) = \\sin(2 x) + 0.3 x$。计算误差的 $L^2$ 范数 $||p_h - p_{\\mathrm{exact}}||_{L^2(0,L)}$，结果为浮点数。\n- 测试用例 2（阻抗边界对称性检查）：$L = 1$, $N = 20$, $k = 8$, $\\alpha = 2\\mathrm{i}$（纯虚数），$p_{\\mathrm{exact}}(x) = \\sin(1.5 x) + 0.1 x^2$。组装全局矩阵 $A$。如果 $||A - A^T||_F  10^{-12}$ 且 $||A - A^H||_F > 10^{-8}$，则返回布尔值 true，其中 $A^T$ 表示转置，$A^H$ 表示共轭转置，$||\\cdot||_F$ 是弗罗贝尼乌斯范数。\n- 测试用例 3（粗网格下的边界边缘情况）：$L = 1$, $N = 2$, $k = 1$, $\\alpha = 0$, $p_{\\mathrm{exact}}(x) = x (1 - x) + 0.05 \\sin(3 x)$。求解后，计算残差的欧几里得范数 $||A u - b||_2$，结果为浮点数，其中 $u$ 是节点值的向量，$A$ 是施加狄利克雷条件后组装的矩阵，$b$ 是右端向量。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序如下：测试用例 1 的 $L^2$ 误差（浮点数），测试用例 2 的对称性和厄米属性布尔值（布尔值），以及测试用例 3 的残差范数（浮点数）。例如，输出格式必须严格为“[result1,result2,result3]”。",
            "solution": "该问题是有效的，因为它提出了一个计算声学中适定的、有科学依据的问题，具体来说是一维亥姆霍兹方程的有限元解。所有必要的参数、方程和验证过程都已提供，该任务是偏微分方程数值方法中的一个标准练习。\n\n### 弱形式的推导\n\n一维频域声学模型的控制强形式由微分方程\n$$ p''(x) + k^2 p(x) = s(x) \\quad \\text{for } x \\in (0, L) $$\n以及在 $x=0$ 处的狄利克雷边界条件和在 $x=L$ 处的罗宾边界条件：\n$$ p(0) = p_D $$\n$$ p'(L) + \\alpha p(L) = g $$\n此处，$p(x)$ 是未知声压，$k$ 是波数，$s(x)$ 是源项，$\\alpha$ 和 $g$ 定义了罗宾边界条件。\n\n为推导弱形式，我们将微分方程与属于适当函数空间的任意试函数 $v(x)$ 相乘，并在域 $(0, L)$ 上积分。试函数必须满足任何本质（狄利克雷）边界条件的齐次形式，因此我们要求 $v(0)=0$。\n$$ \\int_0^L \\left( p''(x) + k^2 p(x) \\right) v(x) \\, dx = \\int_0^L s(x) v(x) \\, dx $$\n我们对二阶导数项应用分部积分：\n$$ \\int_0^L p''(x) v(x) \\, dx = \\left[ p'(x) v(x) \\right]_0^L - \\int_0^L p'(x) v'(x) \\, dx $$\n边界项为 $\\left[ p'(x) v(x) \\right]_0^L = p'(L)v(L) - p'(0)v(0)$。由于我们选择的 $v(x)$ 满足 $v(0)=0$，该项简化为 $p'(L)v(L)$。将其代回积分方程中，得到：\n$$ - \\int_0^L p'(x) v'(x) \\, dx + p'(L)v(L) + \\int_0^L k^2 p(x) v(x) \\, dx = \\int_0^L s(x) v(x) \\, dx $$\n接下来，我们通过代入 $p'(L) = g - \\alpha p(L)$ 来引入罗宾边界条件：\n$$ - \\int_0^L p'(x) v'(x) \\, dx + \\left( g - \\alpha p(L) \\right) v(L) + \\int_0^L k^2 p(x) v(x) \\, dx = \\int_0^L s(x) v(x) \\, dx $$\n重新排列各项，将所有涉及未知量 $p(x)$ 的表达式组合在左侧（LHS），将已知量组合在右侧（RHS），我们得到最终的弱形式：求压力 $p(x)$，使得 $p(0)=p_D$，且对于所有容许的试函数 $v(x)$ 均满足：\n$$ \\int_0^L p'(x) v'(x) \\, dx - k^2 \\int_0^L p(x) v(x) \\, dx + \\alpha p(L) v(L) = \\int_0^L s(x) v(x) \\, dx + g v(L) $$\n该方程的形式为 $a(p,v) = L(v)$，其中 $a(p,v)$ 是一个双线性形式，$L(v)$ 是一个线性泛函。\n\n### 有限元离散化\n\n我们将域 $(0, L)$ 离散化为 $N$ 个长度为 $h = L/N$ 的均匀单元。节点位于 $x_i = ih$，$i=0, 1, \\dots, N$。我们使用一阶（线性）基函数 $\\phi_j(x)$ 的线性组合来近似压力 $p(x)$：\n$$ p_h(x) = \\sum_{j=0}^N u_j \\phi_j(x) $$\n其中 $u_j = p_h(x_j)$ 是压力的未知节点值，$\\phi_j(x)$ 是“帽函数”，它在节点 $x_j$ 处为 1，在所有其他节点处为 0。\n\n在伽辽金方法中，我们使用基函数作为试函数，即 $v(x) = \\phi_i(x)$，$i=1, \\dots, N$。$i=0$ 对应的方程为狄利克雷条件保留。将 $p_h(x)$ 的展开式和 $v(x)=\\phi_i(x)$ 代入弱形式，得到一个线性方程组 $A \\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_0, u_1, \\dots, u_N]^T$。\n\n全局系统矩阵 $A$ 和右端向量 $\\mathbf{b}$ 的项由下式给出：\n$$ A_{ij} = \\int_0^L \\phi_i'(x) \\phi_j'(x) \\, dx - k^2 \\int_0^L \\phi_i(x) \\phi_j(x) \\, dx + \\alpha \\phi_i(L) \\phi_j(L) $$\n$$ b_i = \\int_0^L s(x) \\phi_i(x) \\, dx + g \\phi_i(L) $$\n\n这些全局矩阵是通过对每个单元的贡献求和来组装的。对于一个长度为 $h$ 的通用单元，其单元刚度矩阵 $K^e$ 和质量矩阵 $M^e$ 为：\n$$ K^e = \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}, \\quad M^e = \\frac{h}{6} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} $$\n单元矩阵为 $A^e = K^e - k^2 M^e$。\n\n罗宾边界项 $\\alpha p(L)v(L)$ 仅在 $p(L)$ 和 $v(L)$ 均不为零时有贡献。在我们的离散化中，这发生在 $\\phi_i = \\phi_N$ 和 $\\phi_j = \\phi_N$ 的时候。因此，值 $\\alpha$ 被加到全局矩阵的 $A_{N,N}$ 项上。类似地，项 $g v(L)$ 仅对第 $N$ 个方程有贡献，将 $g$ 加到 $b_N$ 上。\n\n对右端项的源项贡献 $\\int s(x) \\phi_i(x) dx$，通过使用两点高斯求积法则逐单元计算。\n\n### 边界条件施加\n\n狄利克雷条件 $p(0) = p_D$ 是通过修改完全组装好的关于 $\\mathbf{u}$ 的线性系统来施加的。该条件转化为 $u_0 = p_D$。我们使用消元法：\n1. 第一个方程（第 0 行）被替换为 $1 \\cdot u_0 = p_D$。这通过设置 $A_{00}=1$、对 $j0$ 设置 $A_{0j}=0$ 以及设置 $b_0=p_D$ 来实现。\n2. 已知值 $u_0$ 的影响从其他方程中减去。对于每一行 $i  0$，项 $A_{i0} u_0$ 被移到右端项：$b_i \\leftarrow b_i - A_{i0} p_D$。然后将矩阵的第一列（对于 $i0$）清零：$A_{i0}=0$。\n\n完成这些修改后，求解得到的系统以获得节点值 $\\mathbf{u}$。\n\n### 验证量\n\n- **误差的 $L^2$ 范数**：$||p_h - p_{\\mathrm{exact}}||_{L^2} = (\\int_0^L |p_h(x) - p_{\\mathrm{exact}}(x)|^2 dx)^{1/2}$。该积分通过对每个单元的贡献求和进行数值计算，使用足够精确的求积法则（例如，4 点高斯求积）进行评估。\n- **矩阵属性**：施加狄利克雷条件前的矩阵 $A$ 是 $A = K - k^2 M + B_\\alpha$，其中 $K$ 和 $M$ 是全局刚度矩阵和质量矩阵，$B_\\alpha$ 是一个在 $(N,N)$ 位置元素为 $\\alpha$ 的矩阵。由于 $K$ 和 $M$ 是实对称的，因此 $A$ 是对称的（$A=A^T$）。其共轭转置是 $A^H = K - \\bar{k}^2 M + \\bar{B}_\\alpha$。对于测试用例 2，$k$ 是实数，$\\alpha=2i$ 是纯虚数。因此 $A-A^H = B_\\alpha - \\bar{B}_\\alpha$，这是一个在 $(N,N)$ 位置元素为 $\\alpha - \\bar{\\alpha} = 4i$、其他位置为零的矩阵。弗罗贝尼乌斯范数 $||A-A^T||_F$ 应为零（在机器精度内），而 $||A-A^H||_F = \\sqrt{|4i|^2} = 4$，大于 $10^{-8}$。\n- **残差范数**：$||A_{\\text{mod}} \\mathbf{u} - \\mathbf{b}_{\\text{mod}}||_2$。这用于衡量线性求解器的精度。对于直接求解器，该值应接近机器精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and report results for all test cases.\n    \"\"\"\n    # Define manufactured solutions and their derivatives for each test case.\n    # Test Case 1\n    p_exact_1 = lambda x: np.sin(2 * x) + 0.3 * x\n    dp_exact_1 = lambda x: 2 * np.cos(2 * x) + 0.3\n    d2p_exact_1 = lambda x: -4 * np.sin(2 * x)\n\n    # Test Case 2\n    p_exact_2 = lambda x: np.sin(1.5 * x) + 0.1 * x**2\n    dp_exact_2 = lambda x: 1.5 * np.cos(1.5 * x) + 0.2 * x\n    d2p_exact_2 = lambda x: -1.5**2 * np.sin(1.5 * x) + 0.2\n\n    # Test Case 3\n    p_exact_3 = lambda x: x * (1 - x) + 0.05 * np.sin(3 * x)\n    dp_exact_3 = lambda x: 1 - 2 * x + 0.15 * np.cos(3 * x)\n    d2p_exact_3 = lambda x: -2 - 0.45 * np.sin(3 * x)\n\n    test_cases = [\n        {\n            \"id\": 1,\n            \"L\": 1.0, \"N\": 16, \"k\": 4.0, \"alpha\": 1.3,\n            \"p_exact\": p_exact_1, \"dp_exact\": dp_exact_1, \"d2p_exact\": d2p_exact_1\n        },\n        {\n            \"id\": 2,\n            \"L\": 1.0, \"N\": 20, \"k\": 8.0, \"alpha\": 2j,\n            \"p_exact\": p_exact_2, \"dp_exact\": dp_exact_2, \"d2p_exact\": d2p_exact_2\n        },\n        {\n            \"id\": 3,\n            \"L\": 1.0, \"N\": 2, \"k\": 1.0, \"alpha\": 0.0,\n            \"p_exact\": p_exact_3, \"dp_exact\": dp_exact_3, \"d2p_exact\": d2p_exact_3\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_fem_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a boolean is 'True' or 'False' which needs to be lowercased.\n    # str(True) -> 'True', str(True).lower() -> 'true'\n    print(f\"[{','.join(str(r).lower() if isinstance(r, bool) else str(r) for r in results)}]\")\n\ndef run_fem_case(case_params):\n    \"\"\"\n    Solves the 1D Helmholtz problem for a single test case.\n    \"\"\"\n    L = case_params[\"L\"]\n    N = case_params[\"N\"]\n    k = case_params[\"k\"]\n    alpha = case_params[\"alpha\"]\n    p_exact = case_params[\"p_exact\"]\n    dp_exact = case_params[\"dp_exact\"]\n    d2p_exact = case_params[\"d2p_exact\"]\n    case_id = case_params[\"id\"]\n\n    h = L / N\n    nodes = np.linspace(0, L, N + 1)\n    \n    # Define source and boundary data from manufactured solution\n    s = lambda x: d2p_exact(x) + k**2 * p_exact(x)\n    p_D = p_exact(0)\n    g = dp_exact(L) + alpha * p_exact(L)\n\n    # Determine data type for matrices (complex if k or alpha are complex)\n    dtype = np.complex128 if isinstance(k, complex) or isinstance(alpha, complex) else np.float64\n\n    # Assembly of global matrix A and vector b\n    A = np.zeros((N + 1, N + 1), dtype=dtype)\n    b = np.zeros(N + 1, dtype=dtype)\n\n    # Element matrices\n    K_e = (1/h) * np.array([[1, -1], [-1, 1]])\n    M_e = (h/6) * np.array([[2, 1], [1, 2]])\n    A_e = K_e - k**2 * M_e\n\n    # 2-point Gaussian quadrature for source term\n    gauss_pts_f = np.array([0.5 - 0.5/np.sqrt(3), 0.5 + 0.5/np.sqrt(3)])\n    gauss_wts_f = np.array([0.5, 0.5])\n    \n    for i in range(N):\n        # Global indices for the two nodes of element i\n        idx = np.array([i, i+1])\n        \n        # Assemble element matrix into global matrix\n        A[np.ix_(idx, idx)] += A_e\n\n        # Assemble element force vector using Gaussian quadrature\n        f_e = np.zeros(2, dtype=dtype)\n        for q_pt, q_wt in zip(gauss_pts_f, gauss_wts_f):\n            x_q = nodes[i] + h * q_pt\n            # Linear basis functions on reference element [0,1]\n            N_vals = np.array([1 - q_pt, q_pt])\n            f_e += q_wt * s(x_q) * N_vals\n        b[idx] += h * f_e\n\n    # Apply Robin boundary condition\n    A[N, N] += alpha\n    b[N] += g\n\n    # --- Test Case 2: Check matrix properties before Dirichlet BCs ---\n    if case_id == 2:\n        A_unmodified = A.copy()\n        norm_sym = np.linalg.norm(A_unmodified - A_unmodified.T, 'fro')\n        norm_her = np.linalg.norm(A_unmodified - A_unmodified.conj().T, 'fro')\n        return (norm_sym  1e-12) and (norm_her > 1e-8)\n        \n    # Apply Dirichlet BC (elimination method)\n    # Modify RHS first, before zeroing out the column\n    if N > 0: \n        b[1:] -= A[1:, 0] * p_D\n    \n    # Modify matrix\n    A[0, :] = 0\n    A[:, 0] = 0\n    A[0, 0] = 1\n    b[0] = p_D\n\n    # Solve linear system\n    u = np.linalg.solve(A, b)\n\n    # --- Test Case 1: Compute L2 error norm ---\n    if case_id == 1:\n        # L2 error calculation using 4-point Gaussian quadrature for accuracy\n        gauss_pts_e, gauss_wts_e = np.polynomial.legendre.leggauss(4)\n        # Map points and weights from [-1, 1] to [0, 1]\n        gauss_pts_e = 0.5 * (gauss_pts_e + 1)\n        gauss_wts_e = 0.5 * gauss_wts_e\n        \n        l2_error_sq = 0.0\n        for i in range(N):\n            elem_error_sq = 0.0\n            for q_pt, q_wt in zip(gauss_pts_e, gauss_wts_e):\n                x_q = nodes[i] + h * q_pt\n                p_h_val = u[i] * (1 - q_pt) + u[i+1] * q_pt\n                error_val = p_h_val - p_exact(x_q)\n                elem_error_sq += q_wt * np.abs(error_val)**2\n            l2_error_sq += h * elem_error_sq\n        return np.sqrt(l2_error_sq)\n\n    # --- Test Case 3: Compute residual norm ---\n    if case_id == 3:\n        residual = A @ u - b\n        return np.linalg.norm(residual, 2)\n\n    return None # Should not be reached\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}