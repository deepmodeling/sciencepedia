{
    "hands_on_practices": [
        {
            "introduction": "The first step in developing confidence in any numerical simulation tool is verification: ensuring the code correctly solves the mathematical equations it is intended to. This practice introduces the cornerstone of FEM verification, the convergence rate study, using a one-dimensional acoustic cavity problem. By implementing a simple FEM solver and comparing its error against a known analytical solution across several mesh refinements, you will gain hands-on experience with the entire FEM workflow and learn how to confirm that your implementation achieves the theoretically predicted accuracy .",
            "id": "4141617",
            "problem": "Consider the one-dimensional time-harmonic acoustic cavity on the domain $\\Omega = (0,1)$ with homogeneous Dirichlet boundary conditions $p(0) = 0$ and $p(1) = 0$. In the frequency domain under the assumptions of linear, inviscid acoustics, the pressure field $p(x)$ satisfies the Helmholtz equation\n$$\n- \\frac{d^2 p}{dx^2} - k^2 p = f(x) \\quad \\text{in } \\Omega,\n$$\nwhere $k$ is the wavenumber and $f(x)$ is a given source term. The weak form reads: find $p \\in H_0^1(0,1)$ such that\n$$\n\\int_0^1 \\frac{dp}{dx} \\frac{dv}{dx} \\, dx - k^2 \\int_0^1 p v \\, dx = \\int_0^1 f v \\, dx \\quad \\text{for all } v \\in H_0^1(0,1).\n$$\nDiscretize this weak problem using the Finite Element Method (FEM) with continuous, piecewise linear basis functions on a uniform mesh of $N$ elements of size $h = 1/N$. Assemble the discrete system matrix $A = K - k^2 M$, where $K$ is the standard stiffness matrix with entries $K_{ij} = \\int_0^1 \\frac{d\\phi_i}{dx}\\frac{d\\phi_j}{dx}\\,dx$ and $M$ is the standard mass matrix with entries $M_{ij} = \\int_0^1 \\phi_i \\phi_j \\, dx$. Use homogeneous Dirichlet boundary conditions by restricting the system to the interior degrees of freedom.\n\nTo obtain a known exact solution, consider $p_{\\text{exact}}(x) = \\sin(\\pi x)$. Choose the forcing term as $f(x) = (\\pi^2 - k^2)\\sin(\\pi x)$ so that $p_{\\text{exact}}$ satisfies the differential equation and boundary conditions for any wavenumber $k$.\n\nDefine the $L^2$-norm of the error and the $H^1$-seminorm of the error, respectively, as\n$$\n\\| p - p_h \\|_{L^2(0,1)} = \\left( \\int_0^1 \\left( p_{\\text{exact}}(x) - p_h(x) \\right)^2 \\, dx \\right)^{1/2}, \\quad\n| p - p_h |_{H^1(0,1)} = \\left( \\int_0^1 \\left( \\frac{d p_{\\text{exact}}}{dx}(x) - \\frac{d p_h}{dx}(x) \\right)^2 \\, dx \\right)^{1/2}.\n$$\nHere $p_h$ denotes the FEM solution and $\\frac{d p_h}{dx}$ denotes its piecewise constant derivative on each element. The theoretical prediction for piecewise linear elements is that, for sufficiently smooth $p_{\\text{exact}}$, the $L^2$-error scales like $h^2$ and the $H^1$-seminorm error scales like $h$.\n\nCompute the errors for multiple mesh resolutions, estimate the observed convergence rates via a least-squares fit of $\\log(\\text{error})$ versus $\\log(h)$, and assess whether the observed rates match the theoretical predictions. A match is defined as follows: the $L^2$ rate must be at least $1.8$ and the $H^1$ rate must be at least $0.9$.\n\nImplement a complete, runnable program that performs the above steps for the following test suite of parameter values, where each test case consists of a wavenumber $k$ and a list of mesh resolutions $N$:\n- Test case $1$: $k = \\frac{\\pi}{2}$, $N \\in [20,40,80,160]$.\n- Test case $2$: $k = 2.7 \\pi$, $N \\in [60,120,240,480]$.\n- Test case $3$: $k = 3.1 \\pi$, $N \\in [30,60,120,240]$.\n- Test case $4$ (edge case): $k = 4.5 \\pi$, $N \\in [8,16,32,64]$.\n\nYour program should:\n- Assemble the FEM system $A p_h = b$, where $b$ is the load vector obtained by integrating $f(x)$ against the basis functions using sufficiently accurate numerical quadrature.\n- Solve for $p_h$ for each $N$.\n- Compute $\\| p - p_h \\|_{L^2(0,1)}$ and $| p - p_h |_{H^1(0,1)}$ using accurate numerical quadrature.\n- Estimate the convergence rates across the provided $N$ values using least-squares regression on the pairs $(\\log(h), \\log(\\text{error}))$.\n- Return, for each test case, a boolean indicating whether both the $L^2$ and $H^1$ rates meet the thresholds above.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[{\\text{result}_1},{\\text{result}_2},{\\text{result}_3},{\\text{result}_4}]$, where each ${\\text{result}_i}$ is a boolean corresponding to test case $i$.",
            "solution": "The problem requires the implementation of a one-dimensional Finite Element Method (FEM) to solve the Helmholtz equation and a subsequent convergence study to verify theoretical error estimates. The problem is well-posed and scientifically sound, providing a clear path for verification of a numerical method.\n\nThe governing equation is the one-dimensional Helmholtz equation on the domain $\\Omega = (0,1)$:\n$$\n- \\frac{d^2 p}{dx^2} - k^2 p = f(x)\n$$\nwith homogeneous Dirichlet boundary conditions $p(0)=0$ and $p(1)=0$. The wavenumber is denoted by $k$, and $f(x)$ is a given source term.\n\nThe first step in the FEM is to derive the weak formulation. We multiply the equation by a test function $v \\in H_0^1(0,1)$ (a space of functions that are zero at the boundaries and have square-integrable first derivatives) and integrate over the domain $\\Omega$:\n$$\n- \\int_0^1 \\frac{d^2 p}{dx^2} v \\, dx - k^2 \\int_0^1 p v \\, dx = \\int_0^1 f v \\, dx\n$$\nApplying integration by parts to the first term and using the fact that $v(0)=v(1)=0$, we obtain the weak form: Find $p \\in H_0^1(0,1)$ such that\n$$\n\\int_0^1 \\frac{dp}{dx} \\frac{dv}{dx} \\, dx - k^2 \\int_0^1 p v \\, dx = \\int_0^1 f v \\, dx \\quad \\forall v \\in H_0^1(0,1).\n$$\nThis can be written in abstract form as $a(p,v) = L(v)$, where $a(\\cdot, \\cdot)$ is a bilinear form and $L(\\cdot)$ is a linear functional.\n\nNext, we discretize the domain $\\Omega$ into a uniform mesh of $N$ elements, each of length $h = 1/N$. The nodes are located at $x_i = i h$ for $i=0, 1, \\ldots, N$. We seek an approximate solution $p_h(x)$ in a finite-dimensional subspace. For this problem, we use continuous, piecewise linear basis functions, often called \"hat\" functions. The FEM solution is expressed as a linear combination of these basis functions:\n$$\np_h(x) = \\sum_{j=1}^{N-1} p_j \\phi_j(x)\n$$\nwhere $\\phi_j(x)$ is the hat function which is $1$ at node $x_j$ and $0$ at all other nodes, and linearly interpolates between them. The sum is over the $N-1$ interior nodes, as the boundary conditions $p_h(0) = p_h(1) = 0$ are enforced by excluding the basis functions $\\phi_0$ and $\\phi_N$. The coefficients $p_j$ are the unknown nodal values of the pressure field.\n\nSubstituting $p_h$ into the weak form and choosing the test functions $v$ to be the basis functions $\\phi_i$ themselves (the Galerkin method), we obtain a system of linear equations:\n$$\n\\sum_{j=1}^{N-1} p_j \\left( \\int_0^1 \\frac{d\\phi_j}{dx}\\frac{d\\phi_i}{dx}\\,dx - k^2 \\int_0^1 \\phi_j \\phi_i \\,dx \\right) = \\int_0^1 f \\phi_i \\,dx \\quad \\text{for } i=1, \\ldots, N-1.\n$$\nThis is the algebraic system $A \\mathbf{p} = \\mathbf{b}$, where $\\mathbf{p} = [p_1, \\ldots, p_{N-1}]^T$ is the vector of unknown nodal values. The system matrix $A$ and load vector $\\mathbf{b}$ have entries:\n$$\nA_{ij} = K_{ij} - k^2 M_{ij}, \\quad b_i = \\int_0^1 f(x) \\phi_i(x) \\, dx\n$$\nwhere $K_{ij} = \\int_0^1 \\frac{d\\phi_i}{dx}\\frac{d\\phi_j}{dx}\\,dx$ are entries of the stiffness matrix $K$, and $M_{ij} = \\int_0^1 \\phi_i \\phi_j \\,dx$ are entries of the mass matrix $M$.\n\nFor a uniform mesh with linear hat functions, the elemental stiffness and mass matrices for an element of length $h$ are:\n$$\nK^e = \\frac{1}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}, \\quad M^e = \\frac{h}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}\n$$\nAssembling these for the $N-1$ interior degrees of freedom results in symmetric tridiagonal global matrices $K$ and $M$. For $i,j \\in \\{1,...,N-1\\}$:\n- $K_{i,i} = 2/h$, $K_{i, i\\pm 1} = -1/h$\n- $M_{i,i} = 2h/3$, $M_{i, i\\pm 1} = h/6$\n\nThe problem uses the method of manufactured solutions to provide a known exact solution $p_{\\text{exact}}(x) = \\sin(\\pi x)$ by defining the source term as $f(x) = (\\pi^2 - k^2)\\sin(\\pi x)$. The integrals for the load vector $\\mathbf{b}$ and for the error norms involve transcendental functions and must be computed using numerical quadrature, such as the Gauss-Legendre quadrature, with a sufficient number of points to ensure the quadrature error is negligible.\n\nOnce the system $A \\mathbf{p} = \\mathbf{b}$ is assembled and solved for $\\mathbf{p}$, the FEM solution $p_h(x)$ is known. The error is then calculated using the $L^2$-norm and $H^1$-seminorm. These integrals are also computed numerically by summing the contributions from each element, using Gaussian quadrature. On each element $[x_{e-1}, x_e]$, the derivative of the FEM solution is constant: $\\frac{dp_h}{dx} = (p_e - p_{e-1})/h$.\n\nThe final step is to analyze the convergence rate. For a sequence of mesh refinements (decreasing $h$), the error $E$ is expected to scale as $E \\approx C h^\\alpha$, where $\\alpha$ is the rate of convergence. Taking the logarithm gives a linear relationship: $\\log(E) \\approx \\log(C) + \\alpha \\log(h)$. The rate $\\alpha$ can be estimated as the slope of a line fitted to the data points $(\\log(h), \\log(E))$ using a linear least-squares regression. The theoretical rates for linear elements are $\\alpha=2$ for the $L^2$-error and $\\alpha=1$ for the $H^1$-seminorm error. The problem sets practical thresholds of $\\alpha_{L^2} \\ge 1.8$ and $\\alpha_{H^1} \\ge 0.9$ to account for pre-asymptotic effects and numerical precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef assemble_matrices_sparse(N):\n    \"\"\"\n    Assembles the global sparse stiffness (K) and mass (M) matrices for a 1D uniform\n    mesh with N elements, restricted to N-1 interior degrees of freedom.\n    \"\"\"\n    h = 1.0 / N\n    dof = N - 1\n    \n    # Stiffness matrix K\n    k_diag = np.full(dof, 2.0 / h)\n    k_offdiag = np.full(dof - 1, -1.0 / h)\n    K = sparse.diags([k_offdiag, k_diag, k_offdiag], [-1, 0, 1], shape=(dof, dof), format='csr')\n\n    # Mass matrix M\n    m_diag = np.full(dof, 2.0 * h / 3.0)\n    m_offdiag = np.full(dof - 1, h / 6.0)\n    M = sparse.diags([m_offdiag, m_diag, m_offdiag], [-1, 0, 1], shape=(dof, dof), format='csr')\n\n    return K, M\n\ndef assemble_load_vector(k, N, quad_points, quad_weights):\n    \"\"\"\n    Assembles the load vector b for N elements using Gauss-Legendre quadrature.\n    b_j = integral(f(x) * phi_j(x) dx)\n    \"\"\"\n    h = 1.0 / N\n    dof = N - 1\n    b = np.zeros(dof)\n    nodes = np.linspace(0, 1, N + 1)\n    \n    f = lambda x: (np.pi**2 - k**2) * np.sin(np.pi * x)\n    \n    for j in range(1, N):\n        # Integral over element [x_{j-1}, x_j]\n        integral1 = 0.0\n        for i in range(len(quad_points)):\n            xi = quad_points[i]\n            w = quad_weights[i]\n            x_val = (nodes[j-1] + nodes[j]) / 2.0 + h / 2.0 * xi\n            phi_j_val = (x_val - nodes[j-1]) / h\n            integral1 += f(x_val) * phi_j_val * w\n        \n        # Integral over element [x_j, x_{j+1}]\n        integral2 = 0.0\n        for i in range(len(quad_points)):\n            xi = quad_points[i]\n            w = quad_weights[i]\n            x_val = (nodes[j] + nodes[j+1]) / 2.0 + h / 2.0 * xi\n            phi_j_val = (nodes[j+1] - x_val) / h\n            integral2 += f(x_val) * phi_j_val * w\n            \n        b[j-1] = integral1 * (h / 2.0) + integral2 * (h / 2.0)\n        \n    return b\n\ndef calculate_errors(p_h_full, k, N, quad_points, quad_weights):\n    \"\"\"\n    Calculates L2 and H1-seminorm errors using Gauss-Legendre quadrature.\n    p_h_full is the vector of nodal solutions including boundary values.\n    \"\"\"\n    h = 1.0 / N\n    nodes = np.linspace(0, 1, N + 1)\n    \n    p_exact = lambda x: np.sin(np.pi * x)\n    dp_exact = lambda x: np.pi * np.cos(np.pi * x)\n\n    l2_error_sq = 0.0\n    h1_error_sq = 0.0\n    \n    for e in range(N):\n        p_node_left = p_h_full[e]\n        p_node_right = p_h_full[e+1]\n        \n        dp_h = (p_node_right - p_node_left) / h\n        \n        elem_l2_sq = 0.0\n        elem_h1_sq = 0.0\n        \n        for i in range(len(quad_points)):\n            xi = quad_points[i]\n            w = quad_weights[i]\n            x_val = (nodes[e] + nodes[e+1]) / 2.0 + h / 2.0 * xi\n            \n            p_h_val = p_node_left * (1.0 - xi) / 2.0 + p_node_right * (1.0 + xi) / 2.0\n            \n            l2_integrand = (p_exact(x_val) - p_h_val)**2\n            elem_l2_sq += l2_integrand * w\n\n            h1_integrand = (dp_exact(x_val) - dp_h)**2\n            elem_h1_sq += h1_integrand * w\n\n        l2_error_sq += elem_l2_sq * (h / 2.0)\n        h1_error_sq += elem_h1_sq * (h / 2.0)\n        \n    return np.sqrt(l2_error_sq), np.sqrt(h1_error_sq)\n\ndef estimate_rate(h_vals, error_vals):\n    \"\"\"\n    Estimates convergence rate by a least-squares fit on log(error) vs log(h).\n    \"\"\"\n    log_h = np.log(h_vals)\n    log_err = np.log(error_vals)\n    rate, _ = np.polyfit(log_h, log_err, 1)\n    return rate\n\ndef run_single_case(k, N_list):\n    \"\"\"\n    Runs the full simulation for a single test case (k, N_list) and checks convergence.\n    \"\"\"\n    h_vals = []\n    l2_errors = []\n    h1_errors = []\n    \n    # Use 5-point Gauss-Legendre quadrature. This is sufficiently accurate.\n    quad_points, quad_weights = np.polynomial.legendre.leggauss(5)\n\n    for N in N_list:\n        h = 1.0 / N\n        h_vals.append(h)\n        \n        K, M = assemble_matrices_sparse(N)\n        A = K - k**2 * M\n        \n        b = assemble_load_vector(k, N, quad_points, quad_weights)\n        \n        p_h_interior = spsolve(A, b)\n        \n        p_h_full = np.concatenate(([0.0], p_h_interior, [0.0]))\n        \n        l2_err, h1_err = calculate_errors(p_h_full, k, N, quad_points, quad_weights)\n        l2_errors.append(l2_err)\n        h1_errors.append(h1_err)\n\n    l2_rate = estimate_rate(h_vals, l2_errors)\n    h1_rate = estimate_rate(h_vals, h1_errors)\n    \n    return l2_rate >= 1.8 and h1_rate >= 0.9\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the convergence study for each, and prints results.\n    \"\"\"\n    test_cases = [\n        (np.pi / 2, [20, 40, 80, 160]),\n        (2.7 * np.pi, [60, 120, 240, 480]),\n        (3.1 * np.pi, [30, 60, 120, 240]),\n        (4.5 * np.pi, [8, 16, 32, 64])\n    ]\n\n    results = []\n    for case in test_cases:\n        k, N_list = case\n        result = run_single_case(k, N_list)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the fundamentals of 1D implementation, this practice advances to a more physically relevant two-dimensional problem: the modal analysis of an acoustic cavity. You will compute the resonant frequencies (eigenfrequencies) of a rectangular room with rigid walls, a classic problem in room acoustics. This exercise involves formulating the acoustic wave equation as a generalized eigenvalue problem within the FEM framework, assembling stiffness and mass matrices on a 2D triangular mesh, and validating your numerical results against the well-known analytical solution for this geometry .",
            "id": "4141646",
            "problem": "Consider a two-dimensional rectangular acoustic cavity with rigid walls whose domain is $\\Omega = (0,L_x)\\times(0,L_y)$. Assume a homogeneous, lossless fluid characterized by constant mass density $\\rho$ and speed of sound $c$, with small perturbations so that linear acoustics applies. Starting from the fundamental linearized balance laws and constitutive relation for a compressible fluid, the acoustic pressure $p(x,y,t)$ obeys the scalar wave equation and, for time-harmonic fields $p(x,y,t) = \\text{Re}\\{\\phi(x,y)\\,e^{-i\\omega t}\\}$ with angular frequency $\\omega$, the spatial field $\\phi(x,y)$ satisfies the Helmholtz equation with rigid-wall boundary condition on $\\partial\\Omega$. The rigid walls impose a vanishing normal particle velocity, which corresponds to homogeneous Neumann boundary condition on acoustic pressure. Formulate the frequency-domain weak problem on $\\Omega$ and discretize it using the finite element method (FEM) with conforming piecewise-linear (affine) shape functions on a triangulation of the rectangular domain obtained by splitting each rectangular cell of a structured grid into two triangles. Assemble the global symmetric stiffness and mass matrices and solve the resulting generalized eigenvalue problem to approximate the lowest non-zero eigenfrequencies of the cavity.\n\nFor validation, derive the analytical modal frequencies for a rectangular cavity with rigid walls. The analytical wavenumbers are given by combinations that satisfy the Neumann boundary condition, and yield analytical eigenfrequencies that depend on $(m,n) \\in \\mathbb{N}_0^2$ with the trivial uniform-pressure mode excluded.\n\nYour task is to:\n- Derive the appropriate weak formulation from the base physical laws and boundary conditions specified.\n- Implement a conforming linear-triangle FEM that assembles the global stiffness and mass matrices on a structured triangulation of $\\Omega$, and solves the generalized symmetric eigenvalue problem to obtain the first $N$ non-zero eigenfrequencies.\n- Compute the corresponding first $N$ analytical rigid-wall modal frequencies for the same cavity, and compare the FEM results to the analytical ones by reporting the maximum relative error across the first $N$ non-zero modes.\n\nUse the following test suite of parameter sets, where each parameter set is a tuple $(L_x,L_y,c,N_x,N_y,N)$:\n- Test case $1$: $(L_x,L_y,c,N_x,N_y,N) = (\\,1.2\\,\\text{m},\\,0.8\\,\\text{m},\\,343\\,\\text{m/s},\\,30,\\,20,\\,5\\,)$.\n- Test case $2$: $(L_x,L_y,c,N_x,N_y,N) = (\\,1.0\\,\\text{m},\\,1.0\\,\\text{m},\\,343\\,\\text{m/s},\\,10,\\,10,\\,5\\,)$.\n- Test case $3$: $(L_x,L_y,c,N_x,N_y,N) = (\\,2.0\\,\\text{m},\\,0.5\\,\\text{m},\\,343\\,\\text{m/s},\\,40,\\,10,\\,6\\,)$.\n- Test case $4$: $(L_x,L_y,c,N_x,N_y,N) = (\\,1.0\\,\\text{m},\\,1.0\\,\\text{m},\\,343\\,\\text{m/s},\\,40,\\,40,\\,6\\,)$.\n\nIn each case, $L_x$ and $L_y$ are lengths in meters, $c$ is the speed of sound in meters per second, $(N_x,N_y)$ specifies the number of subdivisions along the $x$- and $y$-directions used to generate the structured grid (which produces $(N_x+1)\\times(N_y+1)$ nodes), and $N$ is the number of non-zero modes to be compared. You must assume rigid-wall (Neumann) boundary conditions on all sides.\n\nPhysical units:\n- Express all eigenfrequencies in hertz (Hz).\n- Compute relative errors as decimal values (unitless) using the formula $|f_{\\text{FEM}}-f_{\\text{analytical}}|/f_{\\text{analytical}}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to one test case and is the maximum relative error across the first $N$ non-zero modes for that case, rounded to six decimal places (e.g., $[0.012345,0.001234,0.000567,0.045678]$).",
            "solution": "The problem posed is to determine the acoustic eigenfrequencies of a two-dimensional rectangular cavity with rigid walls using the finite element method (FEM) and to validate the numerical results against an analytical solution. The problem is scientifically grounded, well-posed, and provides all necessary information for a complete solution. We proceed with the derivation and implementation.\n\nThe physical system is governed by the scalar wave equation for acoustic pressure $p$. For time-harmonic solutions of the form $p(x,y,t) = \\text{Re}\\{\\phi(x,y)e^{-i\\omega t}\\}$, the spatial pressure distribution $\\phi(x,y)$ within the domain $\\Omega = (0,L_x)\\times(0,L_y)$ satisfies the Helmholtz equation:\n$$ \\nabla^2 \\phi + k^2 \\phi = 0 $$\nwhere $k = \\omega/c$ is the wavenumber, $\\omega$ is the angular frequency, and $c$ is the constant speed of sound. The rigid walls impose a homogeneous Neumann boundary condition, as the normal component of particle velocity is zero, which translates to a zero normal gradient of the pressure field:\n$$ \\frac{\\partial \\phi}{\\partial n} = \\nabla \\phi \\cdot \\mathbf{n} = 0 \\quad \\text{on } \\partial\\Omega $$\nThis constitutes an eigenvalue problem for the squared wavenumber $k^2$.\n\nTo formulate the weak problem, we employ the method of weighted residuals. Multiplying the Helmholtz equation by an arbitrary test function $v$ from the Sobolev space $H^1(\\Omega)$ and integrating over the domain $\\Omega$ yields:\n$$ \\int_{\\Omega} v(\\nabla^2 \\phi + k^2 \\phi) \\, d\\Omega = 0 $$\nApplying Green's first identity to the Laplacian term, we obtain:\n$$ \\int_{\\Omega} (-\\nabla v \\cdot \\nabla \\phi + v k^2 \\phi) \\, d\\Omega + \\oint_{\\partial\\Omega} v \\frac{\\partial \\phi}{\\partial n} \\, dS = 0 $$\nThe boundary integral $\\oint_{\\partial\\Omega} v \\frac{\\partial \\phi}{\\partial n} \\, dS$ vanishes due to the homogeneous Neumann boundary condition. This is a natural boundary condition within this variational framework. The resulting weak formulation is to find $\\phi \\in H^1(\\Omega)$ and $k^2 \\in \\mathbb{R}$ such that for all $v \\in H^1(\\Omega)$:\n$$ \\int_{\\Omega} \\nabla v \\cdot \\nabla \\phi \\, d\\Omega = k^2 \\int_{\\Omega} v \\phi \\, d\\Omega $$\n\nFor the finite element discretization, we partition the domain $\\Omega$ into a mesh of triangular elements. The solution $\\phi$ is approximated within a finite-dimensional subspace $V_h \\subset H^1(\\Omega)$ as a linear combination of nodal basis functions (or shape functions) $N_j(x,y)$:\n$$ \\phi_h(x,y) = \\sum_{j=1}^{N_{nodes}} \\phi_j N_j(x,y) $$\nwhere $\\phi_j$ are the unknown coefficients, representing the value of the pressure field at node $j$, and $N_{nodes}$ is the total number of nodes in the mesh. We use conforming piecewise-linear basis functions, where $N_j$ is equal to $1$ at node $j$ and $0$ at all other nodes. Substituting this approximation for both the solution $\\phi$ and the test function $v$ (using the Galerkin method, where the test functions are the basis functions themselves, $v = N_i$), we obtain a system of linear equations:\n$$ \\sum_{j=1}^{N_{nodes}} \\left( \\int_{\\Omega} \\nabla N_i \\cdot \\nabla N_j \\, d\\Omega \\right) \\phi_j = k^2 \\sum_{j=1}^{N_{nodes}} \\left( \\int_{\\Omega} N_i N_j \\, d\\Omega \\right) \\phi_j \\quad \\text{for } i = 1, \\dots, N_{nodes} $$\nThis can be written in matrix form as a generalized eigenvalue problem:\n$$ \\mathbf{K} \\mathbf{\\Phi} = k^2 \\mathbf{M} \\mathbf{\\Phi} $$\nHere, $\\mathbf{\\Phi}$ is the vector of nodal unknowns, $\\lambda = k^2$ is the eigenvalue, and $\\mathbf{K}$ and $\\mathbf{M}$ are the global stiffness and mass matrices, respectively. Their entries are given by:\n$$ K_{ij} = \\int_{\\Omega} \\nabla N_i \\cdot \\nabla N_j \\, d\\Omega \\quad \\text{and} \\quad M_{ij} = \\int_{\\Omega} N_i N_j \\, d\\Omega $$\nThese global matrices are assembled by summing contributions from each element. For a linear triangular element $e$ with area $A_e$ and nodes $(x_1, y_1), (x_2, y_2), (x_3, y_3)$, the local $3 \\times 3$ element stiffness matrix $\\mathbf{K}^e$ and mass matrix $\\mathbf{M}^e$ are computed. The gradients of linear shape functions are constant over the element. The entry $(i,j)$ of the element stiffness matrix is $K_{ij}^e = (\\nabla N_i \\cdot \\nabla N_j) A_e = (b_i b_j + c_i c_j) A_e$, where the gradient coefficients are $b_k = (y_{k+1}-y_{k+2})/(2A_e)$ and $c_k = (x_{k+2}-x_{k+1})/(2A_e)$ (with cyclic index permutation). The element mass matrix for a linear triangle is given by the standard formula:\n$$ \\mathbf{M}^e = \\frac{A_e}{12} \\begin{pmatrix} 2 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{pmatrix} $$\nThe solved eigenvalues $\\lambda_i = k_i^2$ correspond to the squared wavenumbers. The first eigenvalue, $\\lambda_0$, is zero (or numerically close to zero), corresponding to the trivial constant-pressure mode $(k=0)$. We are interested in the non-zero eigenfrequencies, which are calculated from the subsequent eigenvalues $\\lambda_i > 0$ using the relation $f_i = \\omega_i/(2\\pi) = c k_i/(2\\pi) = c\\sqrt{\\lambda_i}/(2\\pi)$.\n\nFor validation, we derive the analytical solution. The Helmholtz equation with homogeneous Neumann boundary conditions on the rectangle $\\Omega = (0,L_x)\\times(0,L_y)$ is separable. The eigenfunctions are of the form $\\phi_{mn}(x,y) = \\cos(\\frac{m\\pi x}{L_x})\\cos(\\frac{n\\pi y}{L_y})$ for non-negative integer mode indices $m$ and $n$. The corresponding wavenumbers $k_{mn}$ must satisfy:\n$$ k_{mn}^2 = \\left(\\frac{m\\pi}{L_x}\\right)^2 + \\left(\\frac{n\\pi}{L_y}\\right)^2 $$\nThe analytical eigenfrequencies in Hertz are therefore:\n$$ f_{mn} = \\frac{c k_{mn}}{2\\pi} = \\frac{c}{2} \\sqrt{\\left(\\frac{m}{L_x}\\right)^2 + \\left(\\frac{n}{L_y}\\right)^2} $$\nThe trivial mode corresponds to $(m,n)=(0,0)$, which yields $f_{00}=0$. The first $N$ non-zero modes are found by computing $f_{mn}$ for various pairs $(m,n)$ and sorting the results in ascending order, taking care to account for degenerate modes where different pairs $(m,n)$ yield the same frequency. The comparison between the $i$-th FEM frequency $f_{i, \\text{FEM}}$ and the $i$-th analytical frequency $f_{i, \\text{analytical}}$ is performed using the relative error, and the maximum error over the first $N$ non-zero modes is reported.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import eigsh\n\ndef compute_max_error(Lx, Ly, c, Nx, Ny, N):\n    \"\"\"\n    Computes the maximum relative error for acoustic eigenfrequencies in a 2D cavity.\n\n    This function performs the following steps:\n    1. Generates a structured triangular mesh for the rectangular domain.\n    2. Assembles the global stiffness (K) and mass (M) matrices using linear finite elements.\n    3. Solves the generalized eigenvalue problem K*phi = lambda*M*phi for the lowest eigenmodes.\n    4. Calculates the first N non-zero FEM eigenfrequencies.\n    5. Calculates the first N non-zero analytical eigenfrequencies.\n    6. Computes the maximum relative error between the FEM and analytical results.\n    \"\"\"\n    # 1. Mesh Generation\n    num_nodes = (Nx + 1) * (Ny + 1)\n    dx = Lx / Nx\n    dy = Ly / Ny\n    \n    nodes = np.zeros((num_nodes, 2))\n    node_map = np.zeros((Nx + 1, Ny + 1), dtype=int)\n    idx = 0\n    for iy in range(Ny + 1):\n        for ix in range(Nx + 1):\n            nodes[idx, 0] = ix * dx\n            nodes[idx, 1] = iy * dy\n            node_map[ix, iy] = idx\n            idx += 1\n\n    elements = []\n    for iy in range(Ny):\n        for ix in range(Nx):\n            n1 = node_map[ix, iy]      # Bottom-left\n            n2 = node_map[ix + 1, iy]  # Bottom-right\n            n3 = node_map[ix + 1, iy + 1] # Top-right\n            n4 = node_map[ix, iy + 1]   # Top-left\n            # Split rectangle into two triangles along the n1-n3 diagonal\n            elements.append((n1, n2, n3))\n            elements.append((n1, n3, n4))\n\n    # 2. FEM Assembly\n    K = lil_matrix((num_nodes, num_nodes))\n    M = lil_matrix((num_nodes, num_nodes))\n    \n    M_const = np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n    \n    for el_nodes in elements:\n        p1_idx, p2_idx, p3_idx = el_nodes\n        p1, p2, p3 = nodes[p1_idx], nodes[p2_idx], nodes[p3_idx]\n        \n        # Element area and shape function gradients\n        area = 0.5 * np.abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n        \n        b = np.array([p2[1]-p3[1], p3[1]-p1[1], p1[1]-p2[1]]) / (2 * area)\n        c_grad = np.array([p3[0]-p2[0], p1[0]-p3[0], p2[0]-p1[0]]) / (2 * area)\n        \n        # Element stiffness matrix\n        Ke = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                Ke[i, j] = (b[i] * b[j] + c_grad[i] * c_grad[j]) * area\n        \n        # Element mass matrix\n        Me = (area / 12.0) * M_const\n        \n        # Assembly (add element matrices to global matrices)\n        ix_ = np.ix_(el_nodes, el_nodes)\n        K[ix_] += Ke\n        M[ix_] += Me\n\n    # 3. Eigenvalue Solver\n    # Convert to CSR format for efficient computation\n    K_csr = K.tocsr()\n    M_csr = M.tocsr()\n\n    # Solve the generalized eigenvalue problem. Request N+1 smallest magnitude eigenvalues.\n    # The smallest should be the zero-frequency mode.\n    # Using sigma=-0.1 targets eigenvalues close to zero, which is more robust.\n    try:\n        eigenvalues, _ = eigsh(K_csr, k=N + 1, M=M_csr, sigma=-0.1, which='LM')\n    except Exception:\n        # Fallback to smallest magnitude if sigma method fails\n        eigenvalues, _ = eigsh(K_csr, k=N + 1, M=M_csr, which='SM')\n        \n    # 4. Post-processing FEM results\n    # Eigenvalues from eigsh with sigma are not guaranteed to be sorted.\n    eigenvalues = np.sort(eigenvalues)\n    # The first eigenvalue corresponds to the k=0 mode and should be close to 0. We discard it.\n    fem_lambdas = eigenvalues[1 : N + 1]\n    fem_freqs = (c / (2 * np.pi)) * np.sqrt(np.maximum(0, fem_lambdas))\n\n    # 5. Analytical Frequencies\n    analytical_freqs_list = []\n    # A generous search space for (m,n) pairs to ensure we find the first N modes\n    m_max = int(N * (Lx/Ly if Ly > 0 else 1)) + 5\n    n_max = int(N * (Ly/Lx if Lx > 0 else 1)) + 5\n    for m in range(m_max + 1):\n        for n in range(n_max + 1):\n            if m == 0 and n == 0:\n                continue\n            freq = (c / 2.0) * np.sqrt((m / Lx)**2 + (n / Ly)**2)\n            analytical_freqs_list.append(freq)\n    \n    # Sort frequencies to find the lowest N non-zero modes\n    analytical_freqs_list.sort()\n    analytical_freqs = np.array(analytical_freqs_list[:N])\n\n    # 6. Error Calculation\n    if len(fem_freqs) != N or len(analytical_freqs) != N:\n        raise ValueError(\"Could not find the required number of modes.\")\n        \n    relative_errors = np.abs(fem_freqs - analytical_freqs) / analytical_freqs\n    max_relative_error = np.max(relative_errors)\n    \n    return max_relative_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (1.2, 0.8, 343, 30, 20, 5),\n        (1.0, 1.0, 343, 10, 10, 5),\n        (2.0, 0.5, 343, 40, 10, 6),\n        (1.0, 1.0, 343, 40, 40, 6),\n    ]\n\n    results = []\n    for params in test_cases:\n        Lx, Ly, c, Nx, Ny, N = params\n        error = compute_max_error(Lx, Ly, c, Nx, Ny, N)\n        results.append(f\"{error:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A critical detail in any finite element implementation is the numerical evaluation of the integrals that form the element stiffness and mass matrices. This process is typically performed using numerical quadrature, such as Gauss rules. This practice shifts focus from coding to the underlying theory, asking you to determine the minimal quadrature order required for exact integration as a function of the element's polynomial degree $p$. Understanding this relationship is essential for writing accurate and efficient FEM solvers, particularly when moving beyond simple linear elements to higher-order approximations .",
            "id": "4141612",
            "problem": "Consider the frequency-domain weak formulation of linear acoustics for pressure $p(\\boldsymbol{x})$ on a bounded domain $\\Omega \\subset \\mathbb{R}^{3}$ with homogeneous Neumann boundary conditions and constant material properties: mass density $\\rho$ and bulk modulus $\\kappa$. The bilinear forms are\n$$a(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, \\mathrm{d}\\Omega,$$\n$$m(u,v) = \\int_{\\Omega} u\\, v \\, \\mathrm{d}\\Omega,$$\nand the associated element-level matrices in the Finite Element Method (FEM) for acoustics over a tetrahedral element $\\Omega_{e}$ with polynomial basis functions of degree $p$ are\n$$K_{e}[i,j] = \\int_{\\Omega_{e}} \\nabla N_{i} \\cdot \\nabla N_{j} \\, \\mathrm{d}\\Omega,$$\n$$M_{e}[i,j] = \\int_{\\Omega_{e}} N_{i}\\, N_{j} \\, \\mathrm{d}\\Omega,$$\nwhere $N_{i}$ and $N_{j}$ are scalar shape functions spanning the local approximation space of degree $p$ on $\\Omega_{e}$. Assume straight-sided tetrahedral elements with an affine isoparametric mapping from the reference tetrahedron $\\hat{\\Omega}$ to $\\Omega_{e}$, so that the Jacobian matrix is constant on $\\Omega_{e}$.\n\nA symmetric Gauss rule on tetrahedra of order $r$ is defined as a cubature formula that exactly integrates all polynomials of total degree up to $r$ over $\\Omega_{e}$. Determine, as a function of the polynomial degree $p$, the minimal quadrature order $r$ needed to exactly integrate the integrands of $K_{e}$ and $M_{e}$ on $\\Omega_{e}$ using symmetric Gauss rules. Express your final answer as a pair giving the minimal orders for $K_{e}$ and $M_{e}$, respectively. No numerical rounding is required.",
            "solution": "The starting point is the weak formulation of linear acoustics and the standard element matrices in the Finite Element Method (FEM). For a tetrahedral element $\\Omega_{e}$ with polynomial basis functions of degree $p$, the element mass and stiffness matrices are defined by\n$$K_{e}[i,j] = \\int_{\\Omega_{e}} \\nabla N_{i} \\cdot \\nabla N_{j} \\, \\mathrm{d}\\Omega,$$\n$$M_{e}[i,j] = \\int_{\\Omega_{e}} N_{i}\\, N_{j} \\, \\mathrm{d}\\Omega.$$\n\nWe assume straight-sided tetrahedra with an affine map $F : \\hat{\\Omega} \\to \\Omega_{e}$, where $\\hat{\\Omega}$ is the reference tetrahedron, and the physical coordinates $\\boldsymbol{x}$ are given by $\\boldsymbol{x} = F(\\boldsymbol{\\xi}) = \\boldsymbol{A}\\boldsymbol{\\xi} + \\boldsymbol{b}$ for a constant matrix $\\boldsymbol{A} \\in \\mathbb{R}^{3 \\times 3}$ and vector $\\boldsymbol{b} \\in \\mathbb{R}^{3}$. Under this assumption:\n- The Jacobian matrix $\\boldsymbol{J} = \\nabla_{\\boldsymbol{\\xi}} F$ is constant on $\\hat{\\Omega}$.\n- The determinant $\\det(\\boldsymbol{J})$ is constant on $\\hat{\\Omega}$.\n- The mapping of gradients follows $\\nabla_{\\boldsymbol{x}} N = \\boldsymbol{J}^{-T} \\nabla_{\\boldsymbol{\\xi}} \\hat{N}$, where $\\hat{N}$ is the shape function on $\\hat{\\Omega}$.\n\nWe also use that the polynomial degree of shape functions is preserved under affine mappings: if $\\hat{N}_{i}$ is of degree $p$ in $\\boldsymbol{\\xi}$, then $N_{i}$ is of degree $p$ in $\\boldsymbol{x}$, because affine transformations do not increase polynomial degree.\n\nThe symmetric Gauss rules on tetrahedra of order $r$ exactly integrate any polynomial of total degree up to $r$. Therefore, to determine the minimal order $r$ needed, we must determine the maximal total polynomial degree of the integrands appearing in $K_{e}$ and $M_{e}$ when expressed in the coordinates where the quadrature is applied (here, in $\\boldsymbol{x}$ or equivalently in $\\boldsymbol{\\xi}$ with constant Jacobian factors).\n\nWe now analyze the polynomial degree of each integrand.\n\n1. Mass matrix integrand:\nThe integrand for $M_{e}[i,j]$ is $N_{i} N_{j}$. Each $N_{i}$ is a polynomial of degree $p$. The product of two polynomials of degree $p$ has degree $2p$. Because the Jacobian determinant is constant (affine mapping), the degree is not changed by the change of variables. Hence, the integrand to be integrated over $\\Omega_{e}$ is a polynomial of total degree\n$$d_{M} = 2p.$$\nTo exactly integrate this with a symmetric Gauss rule, the quadrature order must be at least $r \\geq d_{M} = 2p$.\n\n2. Stiffness matrix integrand:\nThe integrand for $K_{e}[i,j]$ is $\\nabla N_{i} \\cdot \\nabla N_{j}$. Each $N_{i}$ has degree $p$, so each gradient $\\nabla N_{i}$ has degree $p-1$ (differentiation reduces degree by one). The dot product of two polynomials of degree $p-1$ results in a polynomial of degree $2(p-1)$. Under the affine mapping, the gradient transformation involves the constant matrix $\\boldsymbol{J}^{-T}$, and the integrand also includes the constant factor $\\det(\\boldsymbol{J})$ when expressed on the reference element, but these constant factors do not alter the polynomial degree. Therefore, the total polynomial degree of the stiffness integrand is\n$$d_{K} = 2(p-1).$$\nTo exactly integrate this with a symmetric Gauss rule, the quadrature order must be at least $r \\geq d_{K} = 2(p-1)$.\n\nBecause a symmetric Gauss rule of order $r$ exactly integrates all polynomials up to degree $r$ and we seek minimal orders, the minimal quadrature orders required are\n$$r_{K} = 2(p-1), \\quad r_{M} = 2p.$$\n\nWe emphasize that these results rely on the affine element mapping. If the mapping were non-affine (e.g., curved isoparametric elements of degree $p$), the Jacobian and metric terms would be non-constant and the integrands would generally not be polynomials, making exact integration by polynomial-exact Gauss rules impossible in general. Under the stated affine assumption, however, the conclusions above hold.\n\nThus, the minimal symmetric Gauss rule orders for exact integration are $2(p-1)$ for the stiffness matrix and $2p$ for the mass matrix.",
            "answer": "$$\\boxed{\\begin{pmatrix} 2(p-1) & 2p \\end{pmatrix}}$$"
        }
    ]
}