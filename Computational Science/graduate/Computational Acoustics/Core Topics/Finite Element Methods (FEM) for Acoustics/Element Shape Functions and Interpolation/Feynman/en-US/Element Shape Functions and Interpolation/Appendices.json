{
    "hands_on_practices": [
        {
            "introduction": "The accuracy of the Finite Element Method begins with its most fundamental operation: approximating a function within a single element. To trust complex simulations, we must first understand and quantify this local approximation error. This practice provides a direct, analytical exercise where you will construct a linear interpolant for a simple sinusoidal wave and calculate the resulting error at the element's midpoint . This lays the essential groundwork for understanding the sources of inaccuracy in FEM.",
            "id": "4121795",
            "problem": "In harmonic computational acoustics, the one-dimensional acoustic pressure field under time-harmonic excitation satisfies the Helmholtz equation $\\frac{d^{2}p}{dx^{2}}+k^{2}p=0$, where $k$ is the acoustic wavenumber and $p(x)$ is the complex amplitude of pressure. Over a single interval element $\\Omega_{e}=[0,h]$ with node locations at $x=0$ and $x=h$, the Finite Element Method (FEM) represents the field by interpolation using element shape functions that satisfy the Kronecker delta property at the nodes. For a linear element, the standard shape functions are $N_{1}(x)=1-\\frac{x}{h}$ and $N_{2}(x)=\\frac{x}{h}$. Let the exact field within $\\Omega_{e}$ be the function $p(x)=\\sin(kx)$, where the amplitude is dimensionless. Define the nodal interpolation operator $I_{h}$ that maps $p(x)$ to its linear interpolant $I_{h}[p](x)$ constructed from the nodal values at $x=0$ and $x=h$.\n\nStarting from the definitions above and the properties of the shape functions, derive $I_{h}[\\sin(kx)](x)$ on $[0,h]$ and then derive the pointwise interpolation error $e(x)=I_{h}[\\sin(kx)](x)-\\sin(kx)$ evaluated at the midpoint $x=\\frac{h}{2}$. Express your final answer as a single closed-form analytic expression in terms of $k$ and $h$. No numerical evaluation is required, and no rounding is needed.",
            "solution": "The one-dimensional acoustic pressure field under time-harmonic excitation obeys the Helmholtz equation $\\frac{d^{2}p}{dx^{2}}+k^{2}p=0$. A particular solution consistent with many boundary conditions on a segment is $p(x)=\\sin(kx)$, where $k$ is the acoustic wavenumber. In the Finite Element Method (FEM), the field on an element $\\Omega_{e}=[0,h]$ is approximated by an interpolation operator $I_{h}$ that uses shape functions to match nodal values. For a linear two-node element, the shape functions are $N_{1}(x)=1-\\frac{x}{h}$ and $N_{2}(x)=\\frac{x}{h}$, and they satisfy $N_{1}(0)=1$, $N_{2}(0)=0$, $N_{1}(h)=0$, $N_{2}(h)=1$, with the Kronecker delta property $N_{i}(x_{j})=\\delta_{ij}$.\n\nThe interpolation operator $I_{h}$ applied to a function $p(x)$ constructs the interpolant as\n$$\nI_{h}[p](x)=p(0)N_{1}(x)+p(h)N_{2}(x),\n$$\nby definition of nodal interpolation on the element.\n\nWe first compute the nodal values of $p(x)=\\sin(kx)$:\n$$\np(0)=\\sin(k\\cdot 0)=\\sin(0)=0,\\qquad p(h)=\\sin(kh).\n$$\nSubstituting these into the interpolation formula gives\n$$\nI_{h}[\\sin(kx)](x)=\\sin(0)\\,N_{1}(x)+\\sin(kh)\\,N_{2}(x)=0\\cdot\\left(1-\\frac{x}{h}\\right)+\\sin(kh)\\left(\\frac{x}{h}\\right)=\\frac{x}{h}\\,\\sin(kh).\n$$\n\nNext, we define the pointwise interpolation error\n$$\ne(x)=I_{h}[\\sin(kx)](x)-\\sin(kx)=\\frac{x}{h}\\,\\sin(kh)-\\sin(kx).\n$$\nWe are asked to evaluate this error at the midpoint $x=\\frac{h}{2}$. Substituting $x=\\frac{h}{2}$,\n$$\ne\\!\\left(\\frac{h}{2}\\right)=\\frac{\\frac{h}{2}}{h}\\,\\sin(kh)-\\sin\\!\\left(k\\frac{h}{2}\\right)=\\frac{1}{2}\\sin(kh)-\\sin\\!\\left(\\frac{kh}{2}\\right).\n$$\nThis is a closed-form analytic expression in terms of $k$ and $h$.\n\nFor additional insight, one can rewrite the error using trigonometric identities. Using $\\sin(kh)=2\\sin\\!\\left(\\frac{kh}{2}\\right)\\cos\\!\\left(\\frac{kh}{2}\\right)$, we find\n$$\ne\\!\\left(\\frac{h}{2}\\right)=\\sin\\!\\left(\\frac{kh}{2}\\right)\\cos\\!\\left(\\frac{kh}{2}\\right)-\\sin\\!\\left(\\frac{kh}{2}\\right)=\\sin\\!\\left(\\frac{kh}{2}\\right)\\left(\\cos\\!\\left(\\frac{kh}{2}\\right)-1\\right),\n$$\nand using $1-\\cos\\theta=2\\sin^{2}\\!\\left(\\frac{\\theta}{2}\\right)$, equivalently\n$$\ne\\!\\left(\\frac{h}{2}\\right)=-2\\,\\sin\\!\\left(\\frac{kh}{2}\\right)\\,\\sin^{2}\\!\\left(\\frac{kh}{4}\\right).\n$$\nEither form is exact. The requested final answer can be provided as $\\frac{1}{2}\\sin(kh)-\\sin\\!\\left(\\frac{kh}{2}\\right)$, which directly follows from the interpolation definition and evaluation at the midpoint.",
            "answer": "$$\\boxed{\\frac{1}{2}\\sin(kh)-\\sin\\!\\left(\\frac{kh}{2}\\right)}$$"
        },
        {
            "introduction": "Local interpolation errors do not exist in isolation; they accumulate and interact to affect the global solution, especially in wave propagation problems. One of the most significant consequences is 'numerical dispersion,' where the simulated wave travels at a different speed than the true physical wave, causing phase errors that pollute the solution. This exercise guides you through the derivation of the discrete dispersion relation for the Helmholtz equation, revealing precisely how the element size $h$ and the physical wavenumber $k$ dictate the accuracy of the simulation .",
            "id": "4121806",
            "problem": "Consider time-harmonic, lossless, one-dimensional acoustics in an unbounded medium with constant mass density and bulk modulus such that the acoustic pressure field $p(x)$ satisfies the scalar Helmholtz equation $p''(x) + k^{2} p(x) = 0$ on the infinite line, where $k$ is the exact wavenumber. Using the standard continuous Galerkin Finite Element Method (FEM) with a uniform partition of the line into nodes $\\{x_{j}\\}_{j \\in \\mathbb{Z}}$ with spacing $h > 0$ and linear Lagrange shape functions on each element $[x_{j}, x_{j+1}]$, carry out the following:\n\n- Start from the weak form of the Helmholtz equation and the definition of the linear shape functions on the reference element $[-1,1]$, namely $N_{1}(\\xi) = \\frac{1 - \\xi}{2}$ and $N_{2}(\\xi) = \\frac{1 + \\xi}{2}$, together with the affine mapping $x(\\xi) = \\frac{x_{j+1} + x_{j}}{2} + \\frac{h}{2} \\xi$. Construct the element-level stiffness and mass matrices by integrating exactly over the reference element and mapping to physical coordinates.\n\n- Assemble the global semi-discrete system on the uniform mesh and analyze discrete plane-wave solutions of the form $p_{j} = \\exp(i j \\theta)$, where $\\theta$ is a real phase increment. Define the numerical wavenumber $k_{h}$ by $\\theta = k_{h} h$.\n\n- From first principles, derive the discrete dispersion relation linking $k_{h}$, $k$, and $h$, and solve it explicitly to obtain a closed-form expression for $k_{h}$ as a function of $k$ and $h$.\n\nYour final answer must be a single closed-form analytic expression for $k_{h}$ in terms of $k$ and $h$. Report $k_{h}$ in inverse meters. No intermediate equations are permitted in the final answer. If you choose to present any series expansions in your derivation, they must be properly justified from the discrete relation, but the final reported answer must remain in exact closed form. No rounding is required.",
            "solution": "The derivation begins with the weak form of the Helmholtz equation. We multiply $p'' + k^2 p = 0$ by a test function $v(x)$ and integrate over the domain. Using integration by parts on the second derivative term, the weak form is: Find $p \\in H^1$ such that for all $v \\in H^1$,\n$$ \\int (k^2 p v - p' v') \\, dx = 0 $$\n(Boundary terms vanish on an infinite domain). We discretize this using the Galerkin method, where the solution $p(x)$ and test function $v(x)$ are approximated from the same space of piecewise linear functions. The problem reduces to finding element-level matrices and assembling them.\n\n**1. Element Matrices**\nOn a single element of length $h$, the element stiffness matrix $\\mathbf{K}^e$ and mass matrix $\\mathbf{M}^e$ have entries:\n$$ K^e_{ab} = \\int_{0}^{h} N'_a(x) N'_b(x) \\, dx, \\quad M^e_{ab} = \\int_{0}^{h} N_a(x) N_b(x) \\, dx $$\nFor a linear element, the shape functions are $N_1(x) = 1 - x/h$ and $N_2(x) = x/h$. Their derivatives are constant: $N'_1(x) = -1/h$ and $N'_2(x) = 1/h$.\nThe integrals are straightforward:\n$$ K^e_{11} = \\int_0^h (-\\frac{1}{h})(-\\frac{1}{h}) dx = \\frac{1}{h^2} \\int_0^h dx = \\frac{1}{h} $$\n$$ K^e_{12} = \\int_0^h (-\\frac{1}{h})(\\frac{1}{h}) dx = -\\frac{1}{h^2} \\int_0^h dx = -\\frac{1}{h} $$\nBy symmetry, $K^e_{21} = -1/h$ and $K^e_{22} = 1/h$.\n$$ M^e_{11} = \\int_0^h (1 - \\frac{x}{h})^2 dx = h \\int_0^1 (1-u)^2 du = h [-\\frac{(1-u)^3}{3}]_0^1 = \\frac{h}{3} $$\n$$ M^e_{12} = \\int_0^h (1 - \\frac{x}{h})(\\frac{x}{h}) dx = h \\int_0^1 (u-u^2) du = h [\\frac{u^2}{2} - \\frac{u^3}{3}]_0^1 = \\frac{h}{6} $$\nBy symmetry, $M^e_{21} = h/6$ and $M^e_{22} = h/3$.\nThus, the element matrices are:\n$$ \\mathbf{K}^e = \\frac{1}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}, \\quad \\mathbf{M}^e = \\frac{h}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix} $$\n\n**2. Assembly and System Equation**\nFor an interior node $j$ on a uniform mesh, the assembled global equation is formed by contributions from elements $[x_{j-1}, x_j]$ and $[x_j, x_{j+1}]$. The row equation for node $j$ is:\n$$ (K^e_{22} + K^e_{11}) p_j + K^e_{21} p_{j-1} + K^e_{12} p_{j+1} - k^2 \\left( (M^e_{22} + M^e_{11}) p_j + M^e_{21} p_{j-1} + M^e_{12} p_{j+1} \\right) = 0 $$\nSubstituting the matrix values:\n$$ \\left(\\frac{1}{h} + \\frac{1}{h}\\right) p_j - \\frac{1}{h} p_{j-1} - \\frac{1}{h} p_{j+1} - k^2 \\left( \\left(\\frac{h}{3} + \\frac{h}{3}\\right) p_j + \\frac{h}{6} p_{j-1} + \\frac{h}{6} p_{j+1} \\right) = 0 $$\nThis simplifies to:\n$$ \\frac{1}{h} (2p_j - p_{j-1} - p_{j+1}) - k^2 \\frac{h}{6} (4p_j + p_{j-1} + p_{j+1}) = 0 $$\n\n**3. Discrete Dispersion Relation**\nWe seek a discrete plane-wave solution of the form $p_j = \\exp(i j \\theta)$, where $\\theta = k_h h$ is the numerical phase shift across one element. Thus, $p_{j-1} = p_j e^{-i\\theta}$ and $p_{j+1} = p_j e^{i\\theta}$. Substituting into the system equation and dividing by $p_j$:\n$$ \\frac{1}{h} (2 - e^{-i\\theta} - e^{i\\theta}) - k^2 \\frac{h}{6} (4 + e^{-i\\theta} + e^{i\\theta}) = 0 $$\nUsing the identity $2\\cos\\theta = e^{i\\theta} + e^{-i\\theta}$:\n$$ \\frac{1}{h} (2 - 2\\cos\\theta) - k^2 \\frac{h}{6} (4 + 2\\cos\\theta) = 0 $$\nMultiplying by $h$ and rearranging gives the discrete dispersion relation:\n$$ 2(1 - \\cos\\theta) = k^2 \\frac{h^2}{3} (2 + \\cos\\theta) $$\nWe now solve for $\\cos\\theta$:\n$$ 6(1 - \\cos\\theta) = (kh)^2 (2 + \\cos\\theta) $$\n$$ 6 - 6\\cos\\theta = 2(kh)^2 + (kh)^2 \\cos\\theta $$\n$$ 6 - 2(kh)^2 = \\cos\\theta (6 + (kh)^2) $$\n$$ \\cos\\theta = \\frac{6 - 2(kh)^2}{6 + (kh)^2} $$\n\n**4. Final Expression for $k_h$**\nSubstitute $\\theta = k_h h$ and solve for the numerical wavenumber $k_h$:\n$$ \\cos(k_h h) = \\frac{6 - 2k^2h^2}{6 + k^2h^2} $$\n$$ k_h h = \\arccos\\left(\\frac{6 - 2k^2h^2}{6 + k^2h^2}\\right) $$\n$$ k_h = \\frac{1}{h} \\arccos\\left(\\frac{6 - 2k^2h^2}{6 + k^2h^2}\\right) $$\nThis expression relates the numerical wavenumber $k_h$ to the true wavenumber $k$ and the element size $h$.",
            "answer": "$$\n\\boxed{\\frac{1}{h} \\arccos\\left( \\frac{6 - 2k^{2}h^{2}}{6 + k^{2}h^{2}} \\right)}\n$$"
        },
        {
            "introduction": "A powerful technique to improve accuracy and reduce dispersion is to use higher-degree polynomials for shape functions. This path, however, requires careful consideration of numerical stability, as a poor choice of interpolation nodes can lead to large, non-physical oscillations. This computational practice explores this critical issue by having you calculate the Lebesgue constant, a key measure of interpolation stability, for two different nodal distributions . You will see firsthand why node placement, such as using Gauss-Lobatto-Legendre points, is essential for robust high-order methods.",
            "id": "4121811",
            "problem": "Consider the interpolation of a one-dimensional acoustic pressure field on the reference finite element domain $[-1,1]$ using Lagrange polynomial shape functions of degree $p$, which are constructed from $p+1$ distinct nodal locations. In computational acoustics within the Finite Element Method (FEM), stable interpolation is critical for oscillatory fields arising from solutions to the Helmholtz equation, where high wavenumbers may lead to rapid spatial oscillations. Let the interpolation operator be defined by the Lagrange shape functions $\\ell_j(x)$ associated with nodal locations $\\{x_j\\}_{j=0}^{p}$, so that a function $f(x)$ is interpolated as $I[f](x) = \\sum_{j=0}^{p} f(x_j) \\,\\ell_j(x)$, with $\\ell_j(x_i) = \\delta_{ij}$ for all $i,j$. The Lebesgue constant $\\Lambda_{p}$ of the nodal set is defined by $\\Lambda_{p} = \\max_{x \\in [-1,1]} \\sum_{j=0}^{p} \\left| \\ell_j(x) \\right|$. The Lebesgue constant quantifies the worst-case amplification of nodal data during interpolation in the uniform norm and serves as a measure of interpolation stability. Two nodal distributions are considered: equispaced nodes and Gauss–Lobatto–Legendre (GLL) nodes. Equispaced nodes are the $p+1$ points $x_j = -1 + 2j/p$ for $j=0,\\dots,p$. Gauss–Lobatto–Legendre (GLL) nodes are defined as the union of the endpoints $x=-1$ and $x=1$ and the $p-1$ interior zeros of the derivative of the Legendre polynomial of degree $p$.\n\nStarting from the Lagrange interpolation definition and the shape function properties, implement a numerically stable algorithm to compute the Lebesgue constant $\\Lambda_{p}$ for both equispaced and Gauss–Lobatto–Legendre (GLL) nodes. Additionally, for the oscillatory acoustic field $f(x) = \\sin(k x)$, with the angle $k$ specified in radians, compute the empirical interpolation amplification $A_{p}(k) = \\max_{x \\in [-1,1]} \\left| I[f](x) \\right|$ on a uniform evaluation grid. Use a uniform evaluation grid of $20001$ points in $[-1,1]$ (including the endpoints), and use barycentric Lagrange interpolation to evaluate the shape functions and the interpolant stably. Your program must compute the Lebesgue constant by discretizing the supremum over the evaluation grid and similarly compute the empirical amplification of $f(x)=\\sin(kx)$.\n\nTest suite and output specification:\n- Use the following test cases, where angles are in radians and all outputs are dimensionless:\n    1. Case A: $p=8$, Gauss–Lobatto–Legendre nodes, $k=50$.\n    2. Case B: $p=8$, equispaced nodes, $k=50$.\n    3. Case C (boundary case): $p=1$, equispaced nodes, $k=50$.\n    4. Case D (edge case: higher oscillation): $p=8$, Gauss–Lobatto–Legendre nodes, $k=200$.\n    5. Case E (edge case: higher oscillation): $p=8$, equispaced nodes, $k=200$.\n- For each case, compute and return two quantities: the Lebesgue constant $\\Lambda_p$ and the empirical amplification $A_p(k)$. Express each numeric result as a float rounded to six decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n$[\\Lambda_{8}^{\\mathrm{GLL}}, A_{8}^{\\mathrm{GLL}}(50), \\Lambda_{8}^{\\mathrm{EQ}}, A_{8}^{\\mathrm{EQ}}(50), \\Lambda_{1}^{\\mathrm{EQ}}, A_{1}^{\\mathrm{EQ}}(50), \\Lambda_{8}^{\\mathrm{GLL}}, A_{8}^{\\mathrm{GLL}}(200), \\Lambda_{8}^{\\mathrm{EQ}}, A_{8}^{\\mathrm{EQ}}(200)]$,\nwhere $\\mathrm{GLL}$ denotes Gauss–Lobatto–Legendre nodes and $\\mathrm{EQ}$ denotes equispaced nodes. For example, the output should look like $[x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9,x_{10}]$, where each $x_i$ is a float rounded to six decimal places.",
            "solution": "The problem requires the computation of two key metrics for one-dimensional polynomial interpolation on the reference interval $[-1, 1]$: the Lebesgue constant $\\Lambda_p$ and the empirical interpolation amplification $A_p(k)$ for a specific oscillatory function. These metrics are to be calculated for two different sets of interpolation nodes: equispaced nodes and Gauss-Lobatto-Legendre (GLL) nodes. The purpose is to analyze and compare the numerical stability of these two nodal distributions, a critical aspect in computational methods like the Finite Element Method (FEM), particularly for problems in acoustics involving high-wavenumber solutions to the Helmholtz equation.\n\nThe core of the problem lies in Lagrange interpolation. Given a set of $p+1$ distinct nodes $\\{x_j\\}_{j=0}^p$ in $[-1, 1]$, any continuous function $f(x)$ can be approximated by a unique polynomial of degree at most $p$, denoted $I[f](x)$, which interpolates $f(x)$ at these nodes, i.e., $I[f](x_j) = f(x_j)$. This interpolant can be expressed using Lagrange basis polynomials $\\ell_j(x)$ as:\n$$\nI[f](x) = \\sum_{j=0}^{p} f(x_j) \\ell_j(x), \\quad \\text{where} \\quad \\ell_j(x_i) = \\delta_{ij} = \\begin{cases} 1 & i = j \\\\ 0 & i \\neq j \\end{cases}\n$$\nThe stability of this interpolation process is quantified by the Lebesgue constant $\\Lambda_p$, defined as the maximum value of the Lebesgue function $\\lambda_p(x) = \\sum_{j=0}^{p} |\\ell_j(x)|$ over the interval:\n$$\n\\Lambda_p = \\max_{x \\in [-1, 1]} \\lambda_p(x) = \\max_{x \\in [-1, 1]} \\sum_{j=0}^{p} |\\ell_j(x)|\n$$\nThe Lebesgue constant provides an upper bound on the amplification of errors in the function values $f(x_j)$. A small $\\Lambda_p$ indicates a stable interpolation scheme.\n\nThe second metric, the empirical interpolation amplification $A_p(k)$, measures the maximum magnitude of the interpolant for a specific function $f(x) = \\sin(kx)$, where $k$ is a wavenumber. It is defined as:\n$$\nA_p(k) = \\max_{x \\in [-1, 1]} |I[\\sin(kx)](x)|\n$$\nThis metric provides a practical measure of how well the interpolation scheme handles a representative oscillatory function.\n\nTo compute these quantities reliably, direct evaluation of the classic formula for Lagrange polynomials, $\\ell_j(x) = \\prod_{i \\neq j} \\frac{x-x_i}{x_j-x_i}$, is numerically unstable, especially for high degrees $p$. A superior method is barycentric Lagrange interpolation. The second barycentric form expresses the interpolating polynomial as:\n$$\nI[f](x) = \\frac{\\sum_{j=0}^{p} \\frac{w_j}{x-x_j} f(x_j)}{\\sum_{j=0}^{p} \\frac{w_j}{x-x_j}}\n$$\nwhere $w_j$ are the barycentric weights, defined as $w_j = \\left( \\prod_{i \\neq j} (x_j - x_i) \\right)^{-1}$. These weights depend only on the nodal distribution and can be pre-computed. This formula is numerically stable and efficient. From this, expressions for the shape functions $\\ell_j(x)$ and the Lebesgue function $\\lambda_p(x)$ can be derived:\n$$\n\\ell_j(x) = \\frac{w_j/(x-x_j)}{\\sum_{k=0}^{p} w_k/(x-x_k)} \\quad \\implies \\quad \\lambda_p(x) = \\sum_{j=0}^{p} |\\ell_j(x)| = \\frac{\\sum_{j=0}^{p} |w_j/(x-x_j)|}{|\\sum_{k=0}^{p} w_k/(x-x_k)|}\n$$\nThese formulae are valid for $x$ not equal to any node $x_j$. If $x=x_j$, then $I[f](x_j) = f(x_j)$ and $\\lambda_p(x_j) = 1$.\n\nThe problem specifies two nodal distributions:\n1.  **Equispaced nodes**: The $p+1$ points are given by the formula $x_j = -1 + \\frac{2j}{p}$ for $j=0, 1, \\dots, p$. These nodes are known to lead to poor stability, with $\\Lambda_p$ growing exponentially with $p$.\n2.  **Gauss-Lobatto-Legendre (GLL) nodes**: These consist of the endpoints $x=-1$ and $x=1$, and the $p-1$ interior roots of the derivative of the Legendre polynomial of degree $p$, $P'_p(x)$. The roots of $P'_p(x)$ are identical to the roots of the Jacobi polynomial $P_{p-1}^{(1,1)}(x)$. These nodes cluster near the endpoints and yield excellent stability, with $\\Lambda_p$ growing only logarithmically with $p$.\n\nThe algorithm to solve the problem is as follows:\n1.  For each test case defined by $(p, \\text{node type}, k)$:\n2.  **Generate Nodes**:\n    *   For equispaced nodes, apply the formula $x_j = -1 + 2j/p$.\n    *   For GLL nodes with degree $p > 1$, compute the $p-1$ roots of the Jacobi polynomial $P_{p-1}^{(1,1)}(x)$ using a numerical library function (e.g., `scipy.special.roots_jacobi`). Combine these interior roots with the endpoints $\\{-1, 1\\}$ to form the full set of $p+1$ nodes. For $p=1$, the GLL nodes are simply $\\{-1, 1\\}$.\n3.  **Compute Barycentric Weights**: Calculate the weight $w_j$ for each node $x_j$ using the formula $w_j = (\\prod_{i \\neq j} (x_j - x_i))^{-1}$.\n4.  **Define Evaluation Grid**: Create a fine, uniform grid of $N=20001$ points, denoted $\\{x_{eval}\\}$, spanning the interval $[-1, 1]$.\n5.  **Evaluate at Nodes**: Compute the values of the function $f(x) = \\sin(kx)$ at the $p+1$ nodes: $f_j = \\sin(kx_j)$.\n6.  **Evaluate on Grid**: For each point $x$ in the evaluation grid $\\{x_{eval}\\}$:\n    *   If $x$ is numerically close to a node $x_j$, the interpolated value is $f_j$ and the Lebesgue function value is $1$.\n    *   Otherwise, use the barycentric formulae to compute $I[f](x)$ and $\\lambda_p(x)$.\n7.  **Determine Maximums**: Approximate $\\Lambda_p$ and $A_p(k)$ by finding the maximum of the computed values of $\\lambda_p(x)$ and $|I[f](x)|$ over the evaluation grid, respectively.\n8.  **Format Output**: Store the computed $\\Lambda_p$ and $A_p(k)$ for each test case, and format the final results as a single comma-separated list rounded to six decimal places.\n\nThis procedure will be implemented for all specified test cases to produce the required output, demonstrating the marked difference in interpolation stability between equispaced and GLL nodes.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem.\n    It computes Lebesgue constants and empirical amplifications for several test cases\n    and prints the results in the specified format.\n    \"\"\"\n\n    def compute_interpolation_metrics(p: int, node_type: str, k: float):\n        \"\"\"\n        Computes the Lebesgue constant and empirical amplification for a given\n        polynomial degree, node type, and wavenumber.\n\n        Args:\n            p (int): The degree of the Lagrange polynomial.\n            node_type (str): Type of nodes, 'equispaced' or 'gll'.\n            k (float): The wavenumber for the function sin(kx).\n\n        Returns:\n            tuple: A tuple containing the Lebesgue constant and the empirical amplification,\n                   both as floats.\n        \"\"\"\n        N_eval = 20001\n        x_eval = np.linspace(-1.0, 1.0, N_eval)\n\n        # Step 1: Generate interpolation nodes\n        if node_type == 'equispaced':\n            x_nodes = np.linspace(-1.0, 1.0, p + 1)\n        elif node_type == 'gll':\n            if p == 0:\n                x_nodes = np.array([0.0])\n            elif p == 1:\n                # For p=1, GLL nodes are the endpoints, same as equispaced\n                x_nodes = np.array([-1.0, 1.0])\n            else:\n                # Interior nodes are roots of P'_p(x), which are roots of Jacobi P_{p-1}^{(1,1)}(x)\n                # scipy.special.roots_jacobi requires n > 0.\n                interior_nodes, _ = special.roots_jacobi(p - 1, 1, 1)\n                x_nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n                x_nodes.sort() # Ensure nodes are ordered\n        else:\n            raise ValueError(f\"Unknown node type: {node_type}\")\n\n        # Step 2: Compute barycentric weights\n        weights = np.ones(p + 1)\n        for j in range(p + 1):\n            # General formula for barycentric weights\n            other_nodes = np.delete(x_nodes, j)\n            weights[j] = 1.0 / np.prod(x_nodes[j] - other_nodes)\n\n        # Step 3: Evaluate function f(x) = sin(k*x) at nodes\n        f_nodes = np.sin(k * x_nodes)\n\n        # Step 4: Evaluate interpolant and Lebesgue function on the fine grid\n        lebesgue_func_vals = np.zeros(N_eval)\n        interp_vals = np.zeros(N_eval)\n\n        for i, x in enumerate(x_eval):\n            # Check if evaluation point x is very close to a node\n            is_node_mask = np.isclose(x, x_nodes)\n            if np.any(is_node_mask):\n                node_idx = np.where(is_node_mask)[0][0]\n                interp_vals[i] = f_nodes[node_idx]\n                lebesgue_func_vals[i] = 1.0\n            else:\n                # Use barycentric formulas for evaluation\n                terms = weights / (x - x_nodes)\n                sum_terms = np.sum(terms)\n                \n                # Interpolated value\n                interp_vals[i] = np.sum(terms * f_nodes) / sum_terms\n                \n                # Lebesgue function value\n                lebesgue_func_vals[i] = np.sum(np.abs(terms)) / np.abs(sum_terms)\n\n        # Step 5: Compute maximums to approximate the constants\n        lebesgue_constant = np.max(lebesgue_func_vals)\n        amplification = np.max(np.abs(interp_vals))\n\n        return lebesgue_constant, amplification\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'p': 8, 'node_type': 'gll', 'k': 50},       # Case A\n        {'p': 8, 'node_type': 'equispaced', 'k': 50}, # Case B\n        {'p': 1, 'node_type': 'equispaced', 'k': 50}, # Case C\n        {'p': 8, 'node_type': 'gll', 'k': 200},      # Case D\n        {'p': 8, 'node_type': 'equispaced', 'k': 200},# Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_p, a_p_k = compute_interpolation_metrics(case['p'], case['node_type'], case['k'])\n        results.append(lambda_p)\n        results.append(a_p_k)\n\n    # Final print statement in the exact required format.\n    formatted_results = [format(r, '.6f') for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}