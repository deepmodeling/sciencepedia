{
    "hands_on_practices": [
        {
            "introduction": "在扭曲或弯曲的网格上求解偏微分方程（如亥姆霍兹方程）时，一个核心挑战是如何将在物理坐标系下的微分算子（例如梯度 $\\nabla p$ 和拉普拉斯算子 $\\nabla^2 p$）用参考单元坐标系下的导数来表示。本练习将从第一性原理出发，指导你推导梯度（一阶导数）和Hessian矩阵（二阶导数）的变换法则。掌握这些变换是有限元方法中实现高阶算子的关键一步 。",
            "id": "4127693",
            "problem": "考虑一个在等参坐标 $\\boldsymbol{\\xi} = (\\xi,\\eta)$下的参考正方形上定义的标量声压场，通过一个光滑的双射等参变换映射到物理坐标 $\\mathbf{x} = (x,y)$。计算任务是将标量场的高阶导数从参考域转换到物理域，这在计算声学的有限元法（FEM）中，是评估亥姆霍兹算子等二阶算子所必需的。\n\n从第一性原理出发：多元链式法则、坐标变换的雅可比矩阵定义以及二阶导数的双线性形式解释。不要假设任何预先推导出的用于变换梯度或海森矩阵的快捷公式。您的推导必须从这些基础出发，构建可在物理坐标下表示梯度和海森矩阵的可实现公式，并用参考导数和几何映射来表示。所有三角函数参数均以弧度为单位。\n\n等参域中的参考场定义：\n$$\n\\hat{p}(\\xi,\\eta) = \\sin(k\\,\\xi)\\,\\cos(k\\,\\eta) + \\xi^3 - \\xi\\,\\eta^2,\n$$\n其中 $k = \\pi$。\n\n从 $(\\xi,\\eta)$ 到 $(x,y)$ 的等参映射：\n$$\nx(\\xi,\\eta) = \\xi + a\\,\\xi\\,\\eta, \\quad y(\\xi,\\eta) = \\eta + b\\,\\xi^2,\n$$\n其中常数 $a$ 和 $b$ 的选择应确保映射是光滑且局部可逆的。\n\n任务：\n- 根据多元链式法则和雅可比矩阵的定义，推导物理梯度 $\\nabla_{\\mathbf{x}} p$ 的表达式，用参考梯度 $\\nabla_{\\boldsymbol{\\xi}} \\hat{p}$ 和映射的雅可比矩阵表示。\n- 从第一性原理出发，推导物理海森矩阵 $\\nabla^2_{\\mathbf{x}} p$ 的表达式，用参考海森矩阵 $\\nabla^2_{\\boldsymbol{\\xi}} \\hat{p}$、雅可比矩阵以及映射的二阶导数表示，包括逆变换的二阶导数所做的贡献。您的推导必须明确说明，关于物理坐标的逆映射的二阶导数是如何通过对恒等式 $\\boldsymbol{\\xi}(\\mathbf{x}(\\boldsymbol{\\xi})) = \\boldsymbol{\\xi}$ 求导得出的。\n\n实现一个程序，对每个测试用例计算：\n- 物理梯度的欧几里得范数，即 $\\|\\nabla_{\\mathbf{x}} p\\|_2$。\n- 物理海森矩阵的迹，即 $\\mathrm{tr}(\\nabla^2_{\\mathbf{x}} p)$，也就是笛卡尔坐标系下的拉普拉斯算子。\n\n使用以下参数值 $(a,b,\\xi,\\eta)$ 的测试套件：\n- 测试用例 $1$：$a = 0.2$, $b = 0.1$, $\\xi = 0.3$, $\\eta = -0.2$。\n- 测试用例 $2$：$a = 0.0$, $b = 0.0$, $\\xi = 0.5$, $\\eta = 0.5$。\n- 测试用例 $3$：$a = -0.3$, $b = 0.0$, $\\xi = -0.8$, $\\eta = 0.9$。\n- 测试用例 $4$：$a = 0.0$, $b = 0.4$, $\\xi = 0.7$, $\\eta = -1.0$。\n- 测试用例 $5$：$a = 0.9$, $b = 0.0$, $\\xi = 0.2$, $\\eta = -1.0$。\n\n覆盖性设计：\n- 测试用例 $1$ 是一个通用的曲线映射，其交叉项和二次项均被激活。\n- 测试用例 $2$ 简化为恒等映射，为参考导数提供直接的一致性检验。\n- 测试用例 $3$ 在参考正方形边界附近，使用负 $a$ 值来分离交叉项效应。\n- 测试用例 $4$ 使用 $b > 0$ 来分离 $\\xi$ 方向上的二次拉伸效应。\n- 测试用例 $5$ 探索近退化的雅可比条件（$1 + a\\,\\eta$ 值很小但为正）。\n\n最终输出格式规范：\n您的程序应生成单行输出，包含所有测试用例的结果，形式为逗号分隔的对列表，其中每一对的格式为 $[\\text{gnorm},\\text{laplacian}]$，整个列表用方括号括起来，例如 $[[r_1^1,r_1^2],[r_2^1,r_2^2],\\ldots]$。条目 $\\text{gnorm}$ 和 $\\text{laplacian}$ 必须是浮点数。不应打印任何额外文本。",
            "solution": "该问题是有效的。这是一个适定的计算数学问题，具体涉及坐标变换下的微分算子变换，是有限元法（FEM）中的一个基本概念。该问题具有科学依据、自成体系且客观。所有必要的函数和参数都已提供，以获得唯一解。\n\n解决方案需要推导标量场 $p$ 从参考域 $\\boldsymbol{\\xi}=(\\xi, \\eta)$ 到物理域 $\\mathbf{x}=(x, y)$ 的梯度和海森矩阵的变换规则。物理场 $p(\\mathbf{x})$ 通过复合函数 $p(\\mathbf{x}) = \\hat{p}(\\boldsymbol{\\xi}(\\mathbf{x}))$ 与参考场 $\\hat{p}(\\boldsymbol{\\xi})$ 相关联，其中 $\\mathbf{x}(\\boldsymbol{\\xi})$ 是给定的等参映射。\n\n令正向映射为 $\\mathbf{x}(\\boldsymbol{\\xi})$，逆向映射为 $\\boldsymbol{\\xi}(\\mathbf{x})$。正向映射及其逆映射的雅可比矩阵表示为：\n$$\nJ = \\frac{\\partial \\mathbf{x}}{\\partial \\boldsymbol{\\xi}} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}, \\quad J^{-1} = \\frac{\\partial \\boldsymbol{\\xi}}{\\partial \\mathbf{x}} = \\begin{pmatrix} \\frac{\\partial \\xi}{\\partial x}  \\frac{\\partial \\xi}{\\partial y} \\\\ \\frac{\\partial \\eta}{\\partial x}  \\frac{\\partial \\eta}{\\partial y} \\end{pmatrix}\n$$\n\n**第1部分：梯度变换**\n\n物理场 $p$ 相对于坐标 $\\mathbf{x}$ 的梯度可使用多元链式法则求得。物理梯度 $\\nabla_{\\mathbf{x}} p$ 的分量为：\n$$\n\\frac{\\partial p}{\\partial x} = \\frac{\\partial \\hat{p}}{\\partial \\xi} \\frac{\\partial \\xi}{\\partial x} + \\frac{\\partial \\hat{p}}{\\partial \\eta} \\frac{\\partial \\eta}{\\partial x}\n$$\n$$\n\\frac{\\partial p}{\\partial y} = \\frac{\\partial \\hat{p}}{\\partial \\xi} \\frac{\\partial \\xi}{\\partial y} + \\frac{\\partial \\hat{p}}{\\partial \\eta} \\frac{\\partial \\eta}{\\partial y}\n$$\n用矩阵表示法，此关系可表示为：\n$$\n\\nabla_{\\mathbf{x}} p = \\begin{pmatrix} \\frac{\\partial p}{\\partial x} \\\\ \\frac{\\partial p}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} \\frac{\\partial \\xi}{\\partial x}  \\frac{\\partial \\eta}{\\partial x} \\\\ \\frac{\\partial \\xi}{\\partial y}  \\frac{\\partial \\eta}{\\partial y} \\end{pmatrix} \\begin{pmatrix} \\frac{\\partial \\hat{p}}{\\partial \\xi} \\\\ \\frac{\\partial \\hat{p}}{\\partial \\eta} \\end{pmatrix}\n$$\n识别出该矩阵是逆映射雅可比矩阵的转置 $(J^{-1})^T$，而该向量是参考梯度 $\\nabla_{\\boldsymbol{\\xi}} \\hat{p}$，我们得到梯度的变换规则：\n$$\n\\nabla_{\\mathbf{x}} p = (J^{-1})^T \\nabla_{\\boldsymbol{\\xi}} \\hat{p}\n$$\n此公式允许从参考梯度和正向映射雅可比矩阵的逆来计算物理梯度。欧几里得范数则为 $\\|\\nabla_{\\mathbf{x}} p\\|_2 = \\sqrt{ (\\frac{\\partial p}{\\partial x})^2 + (\\frac{\\partial p}{\\partial y})^2 }$。\n\n**第2部分：海森矩阵变换**\n\n物理场的海森矩阵 $\\nabla^2_{\\mathbf{x}} p$ 包含二阶偏导数。我们通过将物理梯度的分量对物理坐标求导来推导其分量。令 $i, j \\in \\{x, y\\}$ 为物理坐标的索引，$\\alpha, \\beta \\in \\{\\xi, \\eta\\}$ 为参考坐标的索引。\n从一阶导数的表达式出发，$\\frac{\\partial p}{\\partial x_i} = \\sum_{\\alpha} \\frac{\\partial \\hat{p}}{\\partial \\xi_\\alpha} \\frac{\\partial \\xi_\\alpha}{\\partial x_i}$，我们使用乘法法则和链式法则对 $x_j$ 求导：\n$$\n\\frac{\\partial^2 p}{\\partial x_j \\partial x_i} = \\sum_{\\alpha} \\left[ \\left( \\frac{\\partial}{\\partial x_j} \\frac{\\partial \\hat{p}}{\\partial \\xi_\\alpha} \\right) \\frac{\\partial \\xi_\\alpha}{\\partial x_i} + \\frac{\\partial \\hat{p}}{\\partial \\xi_\\alpha} \\frac{\\partial^2 \\xi_\\alpha}{\\partial x_j \\partial x_i} \\right]\n$$\n括号内的第一项再次通过链式法则展开：\n$$\n\\frac{\\partial}{\\partial x_j} \\frac{\\partial \\hat{p}}{\\partial \\xi_\\alpha} = \\sum_{\\beta} \\frac{\\partial^2 \\hat{p}}{\\partial \\xi_\\beta \\partial \\xi_\\alpha} \\frac{\\partial \\xi_\\beta}{\\partial x_j}\n$$\n将其代回，我们得到物理海森矩阵分量的完整表达式：\n$$\n\\frac{\\partial^2 p}{\\partial x_j \\partial x_i} = \\sum_{\\alpha, \\beta} \\frac{\\partial^2 \\hat{p}}{\\partial \\xi_\\beta \\partial \\xi_\\alpha} \\frac{\\partial \\xi_\\beta}{\\partial x_j} \\frac{\\partial \\xi_\\alpha}{\\partial x_i} + \\sum_{\\alpha} \\frac{\\partial \\hat{p}}{\\partial \\xi_\\alpha} \\frac{\\partial^2 \\xi_\\alpha}{\\partial x_j \\partial x_i}\n$$\n用矩阵形式表示，这变为：\n$$\n\\nabla^2_{\\mathbf{x}} p = (J^{-1})^T (\\nabla^2_{\\boldsymbol{\\xi}} \\hat{p}) J^{-1} + \\sum_{\\alpha=1}^{2} (\\nabla_{\\boldsymbol{\\xi}} \\hat{p})_\\alpha (\\nabla^2_{\\mathbf{x}} \\xi_\\alpha)\n$$\n这里，$\\nabla^2_{\\boldsymbol{\\xi}} \\hat{p}$ 是参考场的海森矩阵，$\\nabla^2_{\\mathbf{x}} \\xi_\\alpha$ 是逆坐标映射 $\\boldsymbol{\\xi}(\\mathbf{x})$ 第 $\\alpha$ 个分量的海森矩阵。\n\n项 $\\nabla^2_{\\mathbf{x}} \\xi_\\alpha$ 难以直接计算。根据问题的指示，我们通过对恒等式 $\\boldsymbol{\\xi}(\\mathbf{x}(\\boldsymbol{\\xi})) = \\boldsymbol{\\xi}$ 求导来推导它们。将 $\\sum_i \\frac{\\partial \\xi_\\alpha}{\\partial x_i} \\frac{\\partial x_i}{\\partial \\xi_\\beta} = \\delta_{\\alpha\\beta}$ 对参考坐标 $\\xi_\\gamma$ 求导，得到：\n$$\n\\sum_i \\left[ \\left( \\sum_k \\frac{\\partial^2 \\xi_\\alpha}{\\partial x_k \\partial x_i} \\frac{\\partial x_k}{\\partial \\xi_\\gamma} \\right) \\frac{\\partial x_i}{\\partial \\xi_\\beta} + \\frac{\\partial \\xi_\\alpha}{\\partial x_i} \\frac{\\partial^2 x_i}{\\partial \\xi_\\gamma \\partial \\xi_\\beta} \\right] = 0\n$$\n这个方程将逆映射的未知海森矩阵（$\\nabla^2_{\\mathbf{x}} \\xi_\\alpha$）与正向映射的已知海森矩阵（$\\nabla^2_{\\boldsymbol{\\xi}} x_i$）联系起来。在矩阵表示法中，这个复杂的表达式等价于：\n$$\nJ^T (\\nabla^2_{\\mathbf{x}} \\xi_\\alpha) J + \\sum_{i=1}^{2} (J^{-1})_{\\alpha i} (\\nabla^2_{\\boldsymbol{\\xi}} x_i) = \\mathbf{0}\n$$\n求解逆映射分量 $\\xi_\\alpha$ 的海森矩阵：\n$$\n\\nabla^2_{\\mathbf{x}} \\xi_\\alpha = - (J^T)^{-1} \\left( \\sum_{i=1}^{2} (J^{-1})_{\\alpha i} (\\nabla^2_{\\boldsymbol{\\xi}} x_i) \\right) J^{-1}\n$$\n将此结果代回物理海森矩阵 $\\nabla^2_{\\mathbf{x}} p$ 的表达式，提供了最终的可实现公式。然后通过取该结果矩阵的迹来求得拉普拉斯算子：$\\mathrm{tr}(\\nabla^2_{\\mathbf{x}} p)$。\n\n**分步实施计划：**\n\n1.  对于每个测试用例 `(a, b, xi, eta)`：\n2.  定义常数 $k = \\pi$。\n3.  计算 $\\hat{p}$ 的一阶导数：$\\hat{p}_\\xi, \\hat{p}_\\eta$。构建参考梯度向量 $\\nabla_{\\boldsymbol{\\xi}} \\hat{p}$。\n4.  计算 $\\hat{p}$ 的二阶导数：$\\hat{p}_{\\xi\\xi}, \\hat{p}_{\\eta\\eta}, \\hat{p}_{\\xi\\eta}$。构建参考海森矩阵 $\\nabla^2_{\\boldsymbol{\\xi}} \\hat{p}$。\n5.  计算映射 $x(\\xi,\\eta), y(\\xi,\\eta)$ 的一阶导数：$x_\\xi, x_\\eta, y_\\xi, y_\\eta$。构建雅可比矩阵 $J$。\n6.  计算映射的二阶导数：$x_{\\xi\\xi}, x_{\\xi\\eta}, x_{\\eta\\eta}$ 和 $y_{\\xi\\xi}, y_{\\xi\\eta}, y_{\\eta\\eta}$。构建海森矩阵 $\\nabla^2_{\\boldsymbol{\\xi}} x$ 和 $\\nabla^2_{\\boldsymbol{\\xi}} y$。\n7.  计算逆雅可比矩阵 $J^{-1}$。\n8.  计算物理梯度：$\\nabla_{\\mathbf{x}} p = (J^{-1})^T \\nabla_{\\boldsymbol{\\xi}} \\hat{p}$。\n9.  计算物理梯度的欧几里得范数 $\\|\\nabla_{\\mathbf{x}} p\\|_2$。\n10. 使用推导出的公式计算逆坐标映射的海森矩阵 $\\nabla^2_{\\mathbf{x}} \\xi$ 和 $\\nabla^2_{\\mathbf{x}} \\eta$。\n11. 组装完整的物理海森矩阵 $\\nabla^2_{\\mathbf{x}} p$。\n12. 计算物理海森矩阵的迹以求得拉普拉斯算子 $\\mathrm{tr}(\\nabla^2_{\\mathbf{x}} p)$。\n\n**针对特定问题的导数：**\n-   场：$\\hat{p}(\\xi,\\eta) = \\sin(k\\xi)\\cos(k\\eta) + \\xi^3 - \\xi\\eta^2$\n    -   $\\hat{p}_\\xi = k\\cos(k\\xi)\\cos(k\\eta) + 3\\xi^2 - \\eta^2$\n    -   $\\hat{p}_\\eta = -k\\sin(k\\xi)\\sin(k\\eta) - 2\\xi\\eta$\n    -   $\\hat{p}_{\\xi\\xi} = -k^2\\sin(k\\xi)\\cos(k\\eta) + 6\\xi$\n    -   $\\hat{p}_{\\eta\\eta} = -k^2\\sin(k\\xi)\\cos(k\\eta) - 2\\xi$\n    -   $\\hat{p}_{\\xi\\eta} = -k^2\\cos(k\\xi)\\sin(k\\eta) - 2\\eta$\n-   映射：$x(\\xi,\\eta) = \\xi + a\\xi\\eta$, $y(\\xi,\\eta) = \\eta + b\\xi^2$\n    -   $J = \\begin{pmatrix} 1 + a\\eta  a\\xi \\\\ 2b\\xi  1 \\end{pmatrix}$\n    -   $\\nabla^2_{\\boldsymbol{\\xi}} x = \\begin{pmatrix} 0  a \\\\ a  0 \\end{pmatrix}$\n    -   $\\nabla^2_{\\boldsymbol{\\xi}} y = \\begin{pmatrix} 2b  0 \\\\ 0  0 \\end{pmatrix}$\n\n将这些表达式代入上面推导的通用公式，以获得每个测试用例的数值结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the isoparametric transformation problem for a given set of test cases.\n    It computes the Euclidean norm of the physical gradient and the trace of the\n    physical Hessian (Laplacian) for a scalar field.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.2, 0.1, 0.3, -0.2),   # Test case 1\n        (0.0, 0.0, 0.5, 0.5),    # Test case 2\n        (-0.3, 0.0, -0.8, 0.9),  # Test case 3\n        (0.0, 0.4, 0.7, -1.0),   # Test case 4\n        (0.9, 0.0, 0.2, -1.0),   # Test case 5\n    ]\n\n    results = []\n    k = np.pi\n\n    for a, b, xi, eta in test_cases:\n        # 1. Compute derivatives of the scalar field p(xi, eta)\n        sin_kxi = np.sin(k * xi)\n        cos_kxi = np.cos(k * xi)\n        sin_keta = np.sin(k * eta)\n        cos_keta = np.cos(k * eta)\n\n        p_xi = k * cos_kxi * cos_keta + 3 * xi**2 - eta**2\n        p_eta = -k * sin_kxi * sin_keta - 2 * xi * eta\n        ref_grad = np.array([p_xi, p_eta])\n\n        p_xixi = -k**2 * sin_kxi * cos_keta + 6 * xi\n        p_etaeta = -k**2 * sin_kxi * cos_keta - 2 * xi\n        p_xieta = -k**2 * cos_kxi * sin_keta - 2 * eta\n        ref_hess = np.array([[p_xixi, p_xieta], [p_xieta, p_etaeta]])\n\n        # 2. Compute derivatives of the mapping x(xi, eta), y(xi, eta)\n        # Jacobian of the forward map\n        J = np.array([\n            [1 + a * eta, a * xi],\n            [2 * b * xi, 1.0]\n        ])\n\n        # Hessians of the forward map components\n        H_x = np.array([[0.0, a], [a, 0.0]])\n        H_y = np.array([[2.0 * b, 0.0], [0.0, 0.0]])\n\n        # 3. Perform the coordinate transformation\n        try:\n            J_inv = np.linalg.inv(J)\n        except np.linalg.LinAlgError:\n            # Handle singular Jacobian, though test cases are designed to avoid this\n            results.append([float('nan'), float('nan')])\n            continue\n\n        # 4. Compute physical gradient and its norm\n        phys_grad = J_inv.T @ ref_grad\n        grad_norm = np.linalg.norm(phys_grad)\n        \n        # 5. Compute physical Hessian and its trace (Laplacian)\n        \n        # This is (J^T)^{-1}, which is equivalent to (J^{-1})^T\n        J_T_inv = J_inv.T\n\n        # Compute Hessians of inverse map components: H_xi and H_eta\n        # H_xi = - (J^T)^-1 * (J_inv[0,0]*H_x + J_inv[0,1]*H_y) * J^-1\n        H_xi = -J_T_inv @ (J_inv[0, 0] * H_x + J_inv[0, 1] * H_y) @ J_inv\n        \n        # H_eta = - (J^T)^-1 * (J_inv[1,0]*H_x + J_inv[1,1]*H_y) * J^-1\n        H_eta = -J_T_inv @ (J_inv[1, 0] * H_x + J_inv[1, 1] * H_y) @ J_inv\n\n        # Assemble the full physical Hessian using the derived formula:\n        # H_p = (J^-1)^T * H_p_ref * J^-1 + p_xi * H_xi + p_eta * H_eta\n        phys_hess = J_inv.T @ ref_hess @ J_inv + ref_grad[0] * H_xi + ref_grad[1] * H_eta\n        \n        laplacian = np.trace(phys_hess)\n\n        results.append([grad_norm, laplacian])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, so str(results) produces the correct output string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "并非所有从参考单元到物理单元的映射都是等效的。高度倾斜或扭曲的单元会降低数值解的精度，并导致最终线性系统的条件数恶化。本练习通过计算各向异性比率 $\\mathcal{A}$ 和谱条件数 $\\kappa_2(\\mathbf{G})$ 这两个关键指标，来量化评估映射的质量，并探索单元的倾斜角度如何直接影响这些重要的度量 。",
            "id": "4127665",
            "problem": "考虑一个二维线性声学介质，其密度 $\\rho$（单位为 $\\mathrm{kg/m^3}$）和体积模量 $B$（单位为 $\\mathrm{Pa}$）均为常数。时域声压 $p(x,y,t)$ 满足声波方程\n$$\n\\frac{1}{B}\\,\\frac{\\partial^2 p}{\\partial t^2} - \\nabla \\cdot \\left( \\frac{1}{\\rho}\\,\\nabla p \\right) = 0,\n$$\n其中 $\\nabla$ 表示关于物理坐标 $(x,y)$ 的空间梯度算子。对于角频率为 $\\omega$（单位为 $\\mathrm{rad/s}$）的时谐场，压力可以写作 $p(x,y,t) = \\Re\\{ \\hat{p}(x,y)\\,e^{\\mathrm{i}\\,\\omega t} \\}$，其中 $\\hat{p}(x,y)$ 是复振幅，这导出了亥姆霍兹形式\n$$\n-\\nabla \\cdot \\left( \\frac{1}{\\rho}\\,\\nabla \\hat{p} \\right) - \\frac{\\omega^2}{B}\\,\\hat{p} = 0.\n$$\n\n在计算声学中，有限元法 (FEM) 采用从参考单元 $\\Omega_{\\xi} = \\{(\\xi,\\eta)\\,|\\,\\xi \\in [-1,1],\\,\\eta \\in [-1,1]\\}$ 到物理单元 $\\Omega_{x} \\subset \\mathbb{R}^2$ 的等参映射。对于一个四节点双线性四边形 (Q4) 单元，该映射定义为\n$$\n\\mathbf{x}(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,\\mathbf{x}_i,\n$$\n其中形函数为\n$$\nN_1(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_3(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1+\\eta),\n$$\n且节点坐标 $\\mathbf{x}_i = (x_i,y_i)$ 定义了物理单元。该映射的雅可比矩阵为\n$$\n\\mathbf{J}(\\xi,\\eta) = \n\\begin{bmatrix}\n\\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\\n\\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta}\n\\end{bmatrix},\n$$\n度量张量定义为\n$$\n\\mathbf{G}(\\xi,\\eta) = \\mathbf{J}(\\xi,\\eta)^{\\top}\\,\\mathbf{J}(\\xi,\\eta),\n$$\n其逆为 $\\mathbf{G}^{-1}(\\xi,\\eta)$。在此映射下，空间梯度变换为\n$$\n\\nabla_{x,y} = \\mathbf{J}^{-\\top}\\,\\nabla_{\\xi,\\eta},\n$$\n且亥姆霍兹算子的弱形式通过 $\\mathbf{G}^{-1}$ 反映了耦合。扭斜映射（非正交的 $\\mathbf{J}$）会在 $\\mathbf{G}^{-1}$ 中引入非对角线元素，从而耦合了 $\\xi$ 和 $\\eta$ 方向。一个有用的对此耦合的定量度量是各向异性比\n$$\n\\mathcal{A} = \\frac{\\left|g^{\\xi\\eta}\\right|}{\\sqrt{g^{\\xi\\xi}\\,g^{\\eta\\eta}}},\n$$\n其中 $g^{\\alpha\\beta}$ 是 $\\mathbf{G}^{-1}$ 的元素；$\\mathcal{A} = 0$ 表示正交性，而较大的值表示更强的扭斜引起的耦合。另一个重要的几何指标是 $\\mathbf{G}$ 在 2-范数下的谱条件数，\n$$\n\\kappa_2(\\mathbf{G}) = \\frac{\\lambda_{\\max}(\\mathbf{G})}{\\lambda_{\\min}(\\mathbf{G})},\n$$\n其中 $\\lambda_{\\max}$ 和 $\\lambda_{\\min}$ 分别是最大和最小特征值。此条件数反映了纵横比和扭斜对映射的综合影响。\n\n您将实现并分析一族仿射等参映射，这些映射将参考正方形映射到物理空间中的一个扭斜的平行四边形。该平行四边形由两个边向量定义\n$$\n\\mathbf{v}_1 = (L,\\,0),\\quad \\mathbf{v}_2 = (H\\,\\tan \\gamma,\\,H),\n$$\n其底边长为 $L$（单位为 $\\mathrm{m}$），高为 $H$（单位为 $\\mathrm{m}$），扭斜角为 $\\gamma$（单位为度）。物理 Q4 单元的节点坐标为\n$$\n\\mathbf{x}_1 = (0,\\,0),\\quad\n\\mathbf{x}_2 = (L,\\,0),\\quad\n\\mathbf{x}_3 = (L + H\\,\\tan \\gamma,\\,H),\\quad\n\\mathbf{x}_4 = (H\\,\\tan \\gamma,\\,H).\n$$\n对于此平行四边形，映射是仿射的，并且雅可比矩阵 $\\mathbf{J}$ 和度量张量 $\\mathbf{G}$ 在 $\\Omega_{\\xi}$ 上是恒定的。\n\n任务：\n1. 对于每个测试用例，从 $(L,H,\\gamma)$ 构建节点坐标 $\\mathbf{x}_i$，使用单元中心 $(\\xi,\\eta) = (0,0)$ 处的等参导数计算恒定的雅可比矩阵 $\\mathbf{J}$，求值 $\\mathbf{G} = \\mathbf{J}^{\\top}\\mathbf{J}$，并计算其逆 $\\mathbf{G}^{-1}$。\n2. 从 $\\mathbf{G}^{-1}$ 计算各向异性比 $\\mathcal{A} = \\left|g^{\\xi\\eta}\\right|/\\sqrt{g^{\\xi\\xi} g^{\\eta\\eta}}$。\n3. 从 $\\mathbf{G}$ 计算谱条件数 $\\kappa_2(\\mathbf{G})$，即其最大特征值与最小特征值之比。\n4. 对于每个测试用例，将数对 $[\\mathcal{A},\\,\\kappa_2(\\mathbf{G})]$ 报告为无量纲浮点数。\n\n角度单位要求：\n- 所有角度 $\\gamma$ 均以度为单位指定。在计算 $\\tan \\gamma$ 时，请使用度作为 $\\gamma$ 的单位。\n\n物理单位要求：\n- 使用米 ($\\mathrm{m}$)作为 $L$ 和 $H$ 的单位。报告的量 $\\mathcal{A}$ 和 $\\kappa_2(\\mathbf{G})$ 是无量纲的，应作为普通十进制浮点数报告。\n\n测试套件：\n- 在所有用例中，使用 $(L,H) = (1.0,\\,1.0)$（单位为 $\\mathrm{m}$），以及以下以度为单位的扭斜角 $\\gamma$：\n  - 用例 1：$\\gamma = -30$。\n  - 用例 2：$\\gamma = 0$。\n  - 用例 3：$\\gamma = 30$。\n  - 用例 4：$\\gamma = 60$。\n  - 用例 5：$\\gamma = 85$。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含结果，格式为用方括号括起来的逗号分隔列表，其中每个条目本身都是一个双元素列表 $[\\mathcal{A},\\,\\kappa_2(\\mathbf{G})]$，对应于一个测试用例，并按上述顺序列出。例如，格式必须类似于 $[[a_1,k_1],[a_2,k_2],\\dots]$，不含任何附加文本。",
            "solution": "该问题被认为是有效的，因为它以有限元法 (FEM) 为科学基础，是适定的，并提供了一套完整且一致的给定条件。任务是为一族扭斜的平行四边形单元计算等参映射的两个几何质量度量。我们将逐步推导所需的量。\n\n物理坐标 $\\mathbf{x} = (x, y)$ 通过等参映射 $\\mathbf{x}(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,\\mathbf{x}_i$ 与参考坐标 $(\\xi, \\eta)$ 相关联。该平行四边形的节点坐标 $\\mathbf{x}_i$ 如下：\n$\\mathbf{x}_1 = (0, 0)$，$\\mathbf{x}_2 = (L, 0)$，$\\mathbf{x}_3 = (L + H \\tan \\gamma, H)$，以及 $\\mathbf{x}_4 = (H \\tan \\gamma, H)$。\n\n**1. 雅可比矩阵推导**\n\n雅可比矩阵 $\\mathbf{J}$ 的分量为 $J_{kl} = \\partial x_k / \\partial \\xi_l$。对于二维映射，其形式为：\n$$\n\\mathbf{J} = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}\n$$\n导数计算方式为 $\\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} x_i$，其他分量依此类推。问题陈述，对于此仿射映射，$\\mathbf{J}$ 是恒定的，并可在单元中心 $(\\xi, \\eta) = (0, 0)$ 处求值。在该点，形函数的导数为：\n$\\partial N_1/\\partial \\xi = -1/4$, $\\partial N_2/\\partial \\xi = 1/4$, $\\partial N_3/\\partial \\xi = 1/4$, $\\partial N_4/\\partial \\xi = -1/4$.\n$\\partial N_1/\\partial \\eta = -1/4$, $\\partial N_2/\\partial \\eta = -1/4$, $\\partial N_3/\\partial \\eta = 1/4$, $\\partial N_4/\\partial \\eta = 1/4$.\n\n使用这些导数，雅可比矩阵的分量为：\n$J_{11} = \\frac{\\partial x}{\\partial \\xi} = \\frac{1}{4}(-x_1 + x_2 + x_3 - x_4) = \\frac{1}{4}(-0 + L + (L + H \\tan\\gamma) - H \\tan\\gamma) = \\frac{2L}{4} = \\frac{L}{2}$\n$J_{12} = \\frac{\\partial x}{\\partial \\eta} = \\frac{1}{4}(-x_1 - x_2 + x_3 + x_4) = \\frac{1}{4}(-0 - L + (L + H \\tan\\gamma) + H \\tan\\gamma) = \\frac{2H \\tan\\gamma}{4} = \\frac{H \\tan\\gamma}{2}$\n$J_{21} = \\frac{\\partial y}{\\partial \\xi} = \\frac{1}{4}(-y_1 + y_2 + y_3 - y_4) = \\frac{1}{4}(-0 + 0 + H - H) = 0$\n$J_{22} = \\frac{\\partial y}{\\partial \\eta} = \\frac{1}{4}(-y_1 - y_2 + y_3 + y_4) = \\frac{1}{4}(-0 - 0 + H + H) = \\frac{2H}{4} = \\frac{H}{2}$\n\n恒定的雅可比矩阵为：\n$$\n\\mathbf{J} = \\begin{bmatrix} L/2  (H \\tan \\gamma)/2 \\\\ 0  H/2 \\end{bmatrix}\n$$\n\n**2. 度量张量及其逆**\n\n度量张量为 $\\mathbf{G} = \\mathbf{J}^{\\top}\\mathbf{J}$。\n$$\n\\mathbf{G} = \\begin{bmatrix} L/2  0 \\\\ (H \\tan \\gamma)/2  H/2 \\end{bmatrix} \\begin{bmatrix} L/2  (H \\tan \\gamma)/2 \\\\ 0  H/2 \\end{bmatrix} = \\frac{1}{4} \\begin{bmatrix} L^2  LH \\tan \\gamma \\\\ LH \\tan \\gamma  H^2 \\tan^2 \\gamma + H^2 \\end{bmatrix}\n$$\n使用恒等式 $1+\\tan^2\\gamma = \\sec^2\\gamma$，我们得到：\n$$\n\\mathbf{G} = \\frac{1}{4} \\begin{bmatrix} L^2  LH \\tan \\gamma \\\\ LH \\tan \\gamma  H^2 \\sec^2 \\gamma \\end{bmatrix}\n$$\n逆度量张量 $\\mathbf{G}^{-1}$ 可以通过 $\\mathbf{G}^{-1} = (\\mathbf{J}^{-1})(\\mathbf{J}^{-1})^{\\top}$ 求得。首先，我们求 $\\mathbf{J}^{-1}$：\n$\\det(\\mathbf{J}) = (L/2)(H/2) = LH/4$。\n$$\n\\mathbf{J}^{-1} = \\frac{1}{LH/4} \\begin{bmatrix} H/2  -(H \\tan \\gamma)/2 \\\\ 0  L/2 \\end{bmatrix} = \\begin{bmatrix} 2/L  -2 \\tan \\gamma/L \\\\ 0  2/H \\end{bmatrix}\n$$\n那么，$\\mathbf{G}^{-1}$ 为：\n$$\n\\mathbf{G}^{-1} = \\begin{bmatrix} 2/L  -2 \\tan \\gamma/L \\\\ 0  2/H \\end{bmatrix} \\begin{bmatrix} 2/L  0 \\\\ -2 \\tan \\gamma/L  2/H \\end{bmatrix} = \\begin{bmatrix} \\frac{4}{L^2}(1+\\tan^2\\gamma)  -\\frac{4 \\tan \\gamma}{LH} \\\\ -\\frac{4 \\tan \\gamma}{LH}  \\frac{4}{H^2} \\end{bmatrix}\n$$\n这给出了 $\\mathbf{G}^{-1}$ 的分量，记为 $g^{\\alpha\\beta}$：\n$g^{\\xi\\xi} = \\frac{4}{L^2\\cos^2\\gamma}$, $g^{\\xi\\eta} = -\\frac{4\\tan\\gamma}{LH}$, $g^{\\eta\\eta} = \\frac{4}{H^2}$。\n\n**3. 各向异性比 $\\mathcal{A}$**\n\n各向异性比定义为 $\\mathcal{A} = \\frac{|g^{\\xi\\eta}|}{\\sqrt{g^{\\xi\\xi} g^{\\eta\\eta}}}$。代入各分量：\n$$\n\\mathcal{A} = \\frac{\\left|-\\frac{4\\tan\\gamma}{LH}\\right|}{\\sqrt{\\frac{4}{L^2\\cos^2\\gamma} \\cdot \\frac{4}{H^2}}} = \\frac{\\frac{4|\\tan\\gamma|}{LH}}{\\frac{4}{LH|\\cos\\gamma|}} = |\\tan\\gamma||\\cos\\gamma| = \\left|\\frac{\\sin\\gamma}{\\cos\\gamma}\\right||\\cos\\gamma| = |\\sin\\gamma|\n$$\n这个非常简洁的结果表明，各向异性比就是扭斜角正弦的绝对值。\n\n**4. 谱条件数 $\\kappa_2(\\mathbf{G})$**\n\n谱条件数为 $\\kappa_2(\\mathbf{G}) = \\lambda_{\\max}(\\mathbf{G})/\\lambda_{\\min}(\\mathbf{G})$。$\\mathbf{G}$ 的特征值 $\\lambda$ 是特征方程 $\\det(\\mathbf{G} - \\lambda\\mathbf{I}) = 0$ 的根。对于测试用例，$L=1$ 且 $H=1$，因此度量张量简化为：\n$$\n\\mathbf{G} = \\frac{1}{4} \\begin{bmatrix} 1  \\tan\\gamma \\\\ \\tan\\gamma  \\sec^2\\gamma \\end{bmatrix}\n$$\n令 $t = \\tan\\gamma$ 并求 $4\\mathbf{G}$ 的特征值。特征方程为 $\\det(4\\mathbf{G} - \\lambda'\\mathbf{I})=0$：\n$$\n(1-\\lambda')(1+t^2-\\lambda') - t^2 = 0 \\implies \\lambda'^2 - (2+t^2)\\lambda' + 1 = 0\n$$\n其根为 $\\lambda' = \\frac{(2+t^2) \\pm \\sqrt{(2+t^2)^2-4}}{2} = \\frac{(2+t^2) \\pm \\sqrt{t^4+4t^2}}{2} = \\frac{1}{2}\\left(2+t^2 \\pm |t|\\sqrt{t^2+4}\\right)$。\n$\\mathbf{G}$ 的特征值为 $\\lambda = \\lambda'/4$。条件数是特征值之比，与缩放因子 $1/4$ 无关：\n$$\n\\kappa_2(\\mathbf{G}) = \\frac{\\lambda'_{\\max}}{\\lambda'_{\\min}} = \\frac{2+t^2 + |t|\\sqrt{t^2+4}}{2+t^2 - |t|\\sqrt{t^2+4}}\n$$\n为了提高数值稳定性，特别是对于大的 $|t|$，我们可以将分母有理化：\n$$\n\\kappa_2(\\mathbf{G}) = \\frac{\\left(2+t^2 + |t|\\sqrt{t^2+4}\\right)^2}{\\left(2+t^2\\right)^2 - t^2(t^2+4)} = \\frac{\\left(2+t^2 + |t|\\sqrt{t^2+4}\\right)^2}{4}\n$$\n这给出了条件数的最终数值稳健公式，其中 $t=\\tan\\gamma$：\n$$\n\\kappa_2(\\mathbf{G}) = \\frac{1}{4}\\left(2+\\tan^2\\gamma + |\\tan\\gamma|\\sqrt{\\tan^2\\gamma+4}\\right)^2\n$$\n现在将实现这些推导出的 $\\mathcal{A}$ 和 $\\kappa_2(\\mathbf{G})$ 的公式来解决测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the anisotropy ratio and spectral condition\n    number for a skewed parallelogram element in FEM.\n    \"\"\"\n    # The problem specifies five test cases based on the skew angle gamma.\n    # The base length L and height H are fixed at 1.0 m.\n    test_gammas_deg = [-30.0, 0.0, 30.0, 60.0, 85.0]\n    \n    results = []\n\n    for gamma_deg in test_gammas_deg:\n        # Convert the skew angle from degrees to radians for use in trigonometric functions.\n        gamma_rad = np.deg2rad(gamma_deg)\n\n        # 1. Compute the Anisotropy Ratio (A)\n        # The derivation shows that A = |sin(gamma)|.\n        anisotropy_ratio = np.abs(np.sin(gamma_rad))\n\n        # 2. Compute the Spectral Condition Number (kappa_2(G))\n        # The condition number is derived from the eigenvalues of the metric tensor G.\n        # For L=H=1, it is a function of t = tan(gamma). A numerically stable\n        # formula is used to avoid issues with subtractive cancellation.\n        # kappa_2(G) = (1/4) * ( (2 + t^2) + |t|*sqrt(t^2 + 4) )^2\n        t = np.tan(gamma_rad)\n        \n        # For gamma = 0, the element is a square, and t=0. The metric tensor G\n        # is a multiple of the identity matrix, so its eigenvalues are equal,\n        # and the condition number is exactly 1.\n        if np.isclose(t, 0.0):\n            condition_number = 1.0\n        else:\n            term1 = 2.0 + t**2\n            term2 = np.abs(t) * np.sqrt(t**2 + 4.0)\n            condition_number = 0.25 * (term1 + term2)**2\n            \n        results.append([anisotropy_ratio, condition_number])\n\n    # Format the final output string according to the specification: [[a_1,k_1],[a_2,k_2],...].\n    # A high precision of 12 decimal places is used for the floating-point numbers\n    # to ensure accuracy and reproducibility.\n    result_strings = []\n    for a, k in results:\n        result_strings.append(f\"[{a:.12f},{k:.12f}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    # Print the single-line result to standard output.\n    print(final_output)\n\nsolve()\n\n```"
        },
        {
            "introduction": "在有限元方法中，组装刚度矩阵和质量矩阵等系统矩阵的最后一步，是在物理单元的定义域上对包含形函数及其导数的表达式进行积分。本练习将模拟这一核心过程，要求你通过坐标变换，在参考单元上计算这些积分，这一变换依赖于雅可比行列式。你将从零开始实现一个嵌套的自适应求积算法，以处理复杂被积函数和扭曲几何形状下的数值积分问题，这是开发实用有限元代码的一项关键技能 。",
            "id": "4127671",
            "problem": "考虑计算声学中的一个二维四边形有限元，其物理坐标 $(x,y)$（单位：米）通过等参双线性映射从参考正方形 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ 获得。该映射使用与四个参考顶点 $(-1,-1)$、$(1,-1)$、$(1,1)$、$(-1,1)$（按 $i=1,2,3,4$ 排序）相关联的标准双线性形函数 $N_i(\\xi,\\eta)$。节点以物理坐标 $(x_i,y_i)$（单位：米）给出。形函数为\n$$\nN_1(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_3(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1+\\eta).\n$$\n物理坐标为\n$$\nx(\\xi,\\eta)=\\sum_{i=1}^4 N_i(\\xi,\\eta)\\,x_i,\\qquad\ny(\\xi,\\eta)=\\sum_{i=1}^4 N_i(\\xi,\\eta)\\,y_i.\n$$\n设该映射的雅可比矩阵为\n$$\n\\mathbf{J}(\\xi,\\eta)=\n\\begin{bmatrix}\n\\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta}\\\\[4pt]\n\\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta}\n\\end{bmatrix},\n$$\n并将其行列式记为 $\\det\\mathbf{J}(\\xi,\\eta)$。\n\n在计算声学中，对曲边单元的积分经常出现在弱形式和边界积分法中。您需要通过变量替换 $(x,y)=(x(\\xi,\\eta),y(\\xi,\\eta))$ 将面积分\n$$\nI=\\iint_{\\Omega} g(x,y)\\,\\mathrm{d}A,\n$$\n变换到参考域上进行计算，变换后得到\n$$\nI=\\int_{-1}^{1}\\int_{-1}^{1} g\\!\\big(x(\\xi,\\eta),y(\\xi,\\eta)\\big)\\,\\big|\\det\\mathbf{J}(\\xi,\\eta)\\big|\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta.\n$$\n您必须从基本原理出发，设计并实现一个自适应求积算法，以在指定的绝对容差内计算变换后的积分。使用嵌套的自适应辛普森法则：在 $\\eta$ 方向上应用一维自适应辛普森积分，将内层积分计算为 $\\xi$ 的函数，然后在外层 $\\xi$ 方向上应用自适应辛普森积分来计算外层积分。误差控制必须是绝对的，并使用标准的辛普森差分误差估计器。您的实现必须是自包含的，不得依赖任何外部积分工具。\n\n定义以下两个被积函数 $g(x,y)$，它们模拟了声学中具有代表性的场量：\n- 对于波数为 $k$（单位：弧度/米）的驻波场：\n$$\ng_{\\text{wave}}(x,y)=\\cos(k\\,x)\\,\\cos(k\\,y).\n$$\n- 对于以 $(x_0,y_0)$ 为中心、宽度参数为 $\\sigma$（单位：米）的局部高斯特征：\n$$\ng_{\\text{gauss}}(x,y)=\\exp\\!\\left(-\\frac{(x-x_0)^2+(y-y_0)^2}{\\sigma^2}\\right).\n$$\n\n从变量替换定理和等参映射的定义出发，推导所需的雅可比矩阵并实现自适应积分算法。积分值必须以平方米为单位，并以小数点后十位的十进制浮点数形式打印。\n\n测试套件规范（角度单位为弧度，所有坐标单位为米）：\n- 情况1（一般斜四边形单元，波场）：节点 $\\big[(0.0,0.0),(2.0,0.5),(2.0,1.5),(0.0,1.0)\\big]$，波数 $k=5.0$，绝对容差 $10^{-8}$。\n- 情况2（近似退化的窄单元，高频场）：节点 $\\big[(0.0,0.0),(0.001,0.0),(0.001,1.0),(0.0,1.0)\\big]$，波数 $k=20.0$，绝对容差 $10^{-8}$。\n- 情况3（扭曲单元，局部高斯）：节点 $\\big[(0.5,0.0),(1.5,0.0),(1.7,1.2),(0.4,1.0)\\big]$，参数 $(x_0,y_0,\\sigma)=(1.0,0.5,0.15)$，绝对容差 $10^{-8}$。\n\n您的程序必须计算这些情况下三个积分 $I$ 的值（以指定单位），并将其打印为单行：一个用方括号括起来的逗号分隔列表。例如，输出格式必须与\n$$\n[\\text{result1},\\text{result2},\\text{result3}]\n$$\n完全一样，其中每个 $\\text{result}$ 都以小数点后十位的十进制浮点数形式打印，且不含任何附加文本。",
            "solution": "该问题要求计算一个一般四边形域上的二维积分。这是计算方法（如有限元法 FEM）中的一个标准流程，特别是在计算声学等领域，这些领域需要在复杂几何形状上对物理现象进行建模。解决方案涉及将积分从具有坐标 $(x, y)$ 的物理域 $\\Omega$ 变换到一个由 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$ 定义的标准参考域（一个正方形）。此变换通过等参映射实现，该映射使用同一组基函数（在此情况下为双线性形函数）来定义单元的几何形状和单元内解场的近似。\n\n需要计算的积分为\n$$\nI = \\iint_{\\Omega} g(x,y)\\,\\mathrm{d}A\n$$\n利用多重积分的变量替换定理，该积分可变换为参考正方形上的积分：\n$$\nI = \\int_{-1}^{1}\\int_{-1}^{1} g\\big(x(\\xi,\\eta), y(\\xi,\\eta)\\big)\\,\\big|\\det\\mathbf{J}(\\xi,\\eta)\\big|\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n$$\n其中 $\\mathbf{J}(\\xi,\\eta)$ 是坐标变换的雅可比矩阵，其行列式 $\\det\\mathbf{J}(\\xi,\\eta)$ 表示物理域与参考域之间的微分面积缩放因子。\n\n我们的第一步是系统地推导雅可比矩阵的分量。\n\n### 等参映射与雅可比矩阵推导\n物理坐标 $(x,y)$ 通过四个节点坐标 $(x_i, y_i)$ 和相应的双线性形函数 $N_i(\\xi, \\eta)$ 从参考坐标 $(\\xi,\\eta)$ 映射而来：\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) x_i \\quad \\text{和} \\quad y(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) y_i\n$$\n节点 $i=1,2,3,4$（分别位于角点 $(-1,-1)$、$(1,-1)$、$(1,1)$、$(-1,1)$）的形函数为：\n$$\nN_1(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1-\\eta) \\\\\nN_2(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1-\\eta) \\\\\nN_3(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1+\\eta) \\\\\nN_4(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1+\\eta)\n$$\n雅可比矩阵 $\\mathbf{J}$ 定义为：\n$$\n\\mathbf{J}(\\xi,\\eta) = \\begin{bmatrix}\n\\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\\n\\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta}\n\\end{bmatrix}\n$$\n为求得 $\\mathbf{J}$ 的元素，我们必须对形函数关于 $\\xi$ 和 $\\eta$ 求偏导。\n\n关于 $\\xi$ 的偏导数：\n$$\n\\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta), \\quad\n\\frac{\\partial N_2}{\\partial \\xi} = \\frac{1}{4}(1-\\eta), \\quad\n\\frac{\\partial N_3}{\\partial \\xi} = \\frac{1}{4}(1+\\eta), \\quad\n\\frac{\\partial N_4}{\\partial \\xi} = -\\frac{1}{4}(1+\\eta)\n$$\n关于 $\\eta$ 的偏导数：\n$$\n\\frac{\\partial N_1}{\\partial \\eta} = -\\frac{1}{4}(1-\\xi), \\quad\n\\frac{\\partial N_2}{\\partial \\eta} = -\\frac{1}{4}(1+\\xi), \\quad\n\\frac{\\partial N_3}{\\partial \\eta} = \\frac{1}{4}(1+\\xi), \\quad\n\\frac{\\partial N_4}{\\partial \\eta} = \\frac{1}{4}(1-\\xi)\n$$\n物理坐标的导数则通过链式法则求得：\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial \\xi} x_i = \\frac{1}{4} \\left[ (x_2-x_1)(1-\\eta) + (x_3-x_4)(1+\\eta) \\right] \\\\\n\\frac{\\partial y}{\\partial \\xi} = \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial \\xi} y_i = \\frac{1}{4} \\left[ (y_2-y_1)(1-\\eta) + (y_3-y_4)(1+\\eta) \\right] \\\\\n\\frac{\\partial x}{\\partial \\eta} = \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial \\eta} x_i = \\frac{1}{4} \\left[ (x_4-x_1)(1-\\xi) + (x_3-x_2)(1+\\xi) \\right] \\\\\n\\frac{\\partial y}{\\partial \\eta} = \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial \\eta} y_i = \\frac{1}{4} \\left[ (y_4-y_1)(1-\\xi) + (y_3-y_2)(1+\\xi) \\right]\n$$\n雅可比行列式 $\\det\\mathbf{J} = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta} - \\frac{\\partial x}{\\partial \\eta}\\frac{\\partial y}{\\partial \\xi}$ 因此是 $\\xi$ 和 $\\eta$ 的一个双线性多项式。对于一个有效的（非反转的）单元映射，该行列式在整个域内必须为正。\n\n### 自适应数值求积\n变换后的积分是一个嵌套的一维积分，我们将使用嵌套的自适应辛普森法则对其进行计算。对于一维积分 $\\int_a^b f(z) dz$，辛普森法则提供了一个近似值：\n$$\nS(a,b) = \\frac{b-a}{6} \\left[f(a) + 4f\\left(\\frac{a+b}{2}\\right) + f(b)\\right]\n$$\n自适应方案通过递归地细分积分区间来提高精度。我们将区间 $[a,b]$ 上的近似值 $S_1 = S(a,b)$ 与通过对两个半区间 $[a,c]$ 和 $[c,b]$（其中 $c=(a+b)/2$）上的近似值求和得到的更精确的值进行比较。设这个更精确的和为 $S_2 = S(a,c) + S(c,b)$。更精确的和 $S_2$ 的误差估计为：\n$$\nE \\approx \\frac{1}{15} |S_2 - S_1|\n$$\n递归算法的流程如下：对于给定的区间和绝对容差 $\\epsilon$，我们计算 $S_1$ 和 $S_2$。如果 $|S_2 - S_1|  15\\epsilon$，则表示满足容差要求，我们返回 $S_2$。否则，我们对子区间 $[a,c]$ 和 $[c,b]$ 递归应用该算法，每个子区间的容差为 $\\epsilon/2$。\n\n对于二维积分，我们以嵌套的方式应用此过程：\n$$\nI = \\int_{-1}^{1} \\left( \\int_{-1}^{1} F(\\xi, \\eta) \\,\\mathrm{d}\\eta \\right) \\mathrm{d}\\xi, \\quad \\text{其中 } F(\\xi, \\eta) = g\\big(x(\\xi,\\eta), y(\\xi,\\eta)\\big)\\,\\big|\\det\\mathbf{J}(\\xi,\\eta)\\big|\n$$\n外层积分是关于 $\\xi$ 的。其被积函数是关于 $\\eta$ 的内层积分。设 $G(\\xi) = \\int_{-1}^{1} F(\\xi, \\eta) \\,\\mathrm{d}\\eta$。外层积分为 $I = \\int_{-1}^1 G(\\xi)\\,\\mathrm{d}\\xi$。\n\n为了计算外层自适应求积所需的任意给定 $\\xi$ 对应的 $G(\\xi)$ 值，我们必须调用一维自适应求积例程来计算关于 $\\eta$ 的积分。为确保计算 $G(\\xi)$ 的误差不会破坏外层积分的误差控制，内层积分的容差必须保守地选择。一个稳健的策略是，为内层积分使用一个远小于当前外层积分步骤容差的容差。在我们的实现中，我们会将内层容差设置为主容差 $\\epsilon$ 的一小部分（例如 $1/100$），以确保函数 $G(\\xi)$ 以高精度计算。\n\n### 算法总结\n计算一个积分的完整算法如下：\n1.  通过四个节点坐标 $(x_i, y_i)$ 定义单元几何形状。\n2.  定义被积函数 $g(x,y)$ 及其参数。\n3.  创建一个函数 `full_integrand(xi, eta)`，该函数执行以下操作：\n    a. 给定 $(\\xi, \\eta)$，使用双线性形函数和节点坐标计算物理坐标 $(x,y)$。\n    b. 计算雅可比矩阵 $\\mathbf{J}(\\xi, \\eta)$ 的四个分量。\n    c. 计算行列式 $\\det \\mathbf{J}(\\xi, \\eta)$。\n    d. 计算特定问题的函数 $g(x,y)$ 的值。\n    e. 返回乘积 $g(x,y) \\times |\\det\\mathbf{J}(\\xi, \\eta)|$。\n4.  创建一个函数 `inner_integral_fn(xi)`，该函数使用一维自适应辛普森法则和一个严格的容差（例如 $\\epsilon_{\\text{total}}/100$）计算 `full_integrand(xi, eta)` 关于 $\\eta$ 从 $-1$ 到 $1$ 的积分。\n5.  使用一维自适应辛普森法则和指定的绝对容差 $\\epsilon_{\\text{total}}$ 计算 `inner_integral_fn(xi)` 关于 $\\xi$ 从 $-1$ 到 $1$ 的外层积分。\n6.  返回最终结果。\n\n此过程将应用于指定的三个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the specified test cases for 2D numerical integration\n    over a quadrilateral element.\n    \"\"\"\n\n    def _adaptive_simpson_recursive(f, a, b, tol, fa, fc, fb):\n        \"\"\"Recursive helper for adaptive Simpson's rule.\"\"\"\n        c = (a + b) / 2.0\n        h = b - a\n        S1 = h * (fa + 4 * fc + fb) / 6.0\n        \n        d = (a + c) / 2.0\n        e = (c + b) / 2.0\n        # The passed function `f` might be computationally expensive, so we evaluate\n        # it only when necessary.\n        fd = f(d)\n        fe = f(e)\n\n        # Simpson's rule on subintervals\n        S_left = (h / 2.0) * (fa + 4 * fd + fc) / 6.0\n        S_right = (h / 2.0) * (fc + 4 * fe + fb) / 6.0\n        S2 = S_left + S_right\n\n        # Error estimation based on the difference between the coarse and fine estimates.\n        # The error of S2 is approximately (S2 - S1) / 15. The condition\n        # abs(S2 - S1) / 15  tol is equivalent to abs(S2 - S1)  15 * tol.\n        if abs(S2 - S1)  15.0 * tol:\n            # S2 is the more accurate result.\n            return S2\n        \n        # If tolerance is not met, recurse on subintervals with halved tolerance.\n        return (_adaptive_simpson_recursive(f, a, c, tol / 2.0, fa, fd, fc) +\n                _adaptive_simpson_recursive(f, c, b, tol / 2.0, fc, fe, fb))\n\n    def adaptive_simpson_1d(f, a, b, tol):\n        \"\"\"\n        Calculates the definite integral of a function f from a to b using\n        adaptive Simpson's rule.\n        \n        This function serves as a wrapper for the recursive implementation,\n        handling the initial function evaluations.\n        \"\"\"\n        c = (a + b) / 2.0\n        fa = f(a)\n        fb = f(b)\n        fc = f(c)\n        return _adaptive_simpson_recursive(f, a, b, tol, fa, fc, fb)\n\n    def compute_integral_for_case(case_data):\n        \"\"\"\n        Computes the 2D integral for a single test case.\n        \"\"\"\n        nodes, g_type, params, tol = case_data\n        nodes = np.array(nodes)\n        \n        # Unpack node coordinates for clarity in formulas\n        x_nodes, y_nodes = nodes[:, 0], nodes[:, 1]\n        x1, x2, x3, x4 = x_nodes\n        y1, y2, y3, y4 = y_nodes\n\n        def get_geom_properties(xi, eta):\n            \"\"\"\n            Computes physical coordinates (x, y) and Jacobian determinant\n            for given reference coordinates (xi, eta).\n            \"\"\"\n            # Shape functions\n            N = np.array([\n                0.25 * (1 - xi) * (1 - eta),  # N1\n                0.25 * (1 + xi) * (1 - eta),  # N2\n                0.25 * (1 + xi) * (1 + eta),  # N3\n                0.25 * (1 - xi) * (1 + eta),  # N4\n            ])\n\n            # Coordinate mapping\n            x = np.dot(N, x_nodes)\n            y = np.dot(N, y_nodes)\n\n            # Derivatives of shape functions\n            # dN/d(xi)\n            dN_dxi = 0.25 * np.array([\n                -(1 - eta), (1 - eta), (1 + eta), -(1 + eta)\n            ])\n            # dN/d(eta)\n            dN_deta = 0.25 * np.array([\n                -(1 - xi), -(1 + xi), (1 + xi), (1 - xi)\n            ])\n\n            # Jacobian matrix components\n            dx_dxi = np.dot(dN_dxi, x_nodes)\n            dy_dxi = np.dot(dN_dxi, y_nodes)\n            dx_deta = np.dot(dN_deta, x_nodes)\n            dy_deta = np.dot(dN_deta, y_nodes)\n\n            # Jacobian determinant\n            jac_det = dx_dxi * dy_deta - dx_deta * dy_dxi\n            \n            return x, y, jac_det\n\n        # Define the specific integrand function g(x, y)\n        if g_type == 'wave':\n            k = params['k']\n            g = lambda x, y: np.cos(k * x) * np.cos(k * y)\n        elif g_type == 'gauss':\n            x0, y0, sigma = params['x0'], params['y0'], params['sigma']\n            sigma_sq = sigma**2\n            g = lambda x, y: np.exp(-((x-x0)**2 + (y-y0)**2) / sigma_sq)\n        else:\n            raise ValueError(\"Unknown integrand type\")\n\n        def full_integrand(xi, eta):\n            \"\"\"The complete function F(xi, eta) to be integrated.\"\"\"\n            x, y, jac_det = get_geom_properties(xi, eta)\n            return g(x, y) * abs(jac_det)\n\n        # For the nested quadrature, the inner integral must be evaluated with\n        # high precision to not pollute the error control of the outer integral.\n        # A tolerance of tol/100 is a conservative and robust choice.\n        inner_tol = tol / 100.0\n\n        def inner_integral_fn(xi):\n            \"\"\"\n            Represents the inner integral as a function of the outer variable xi.\n            G(xi) = integral from -1 to 1 of F(xi, eta) d(eta).\n            \"\"\"\n            eta_integrand = lambda eta: full_integrand(xi, eta)\n            return adaptive_simpson_1d(eta_integrand, -1.0, 1.0, inner_tol)\n\n        # Perform the outer integration\n        result = adaptive_simpson_1d(inner_integral_fn, -1.0, 1.0, tol)\n        return result\n\n    # Test suite specification\n    test_cases = [\n        (\n            [(0.0, 0.0), (2.0, 0.5), (2.0, 1.5), (0.0, 1.0)],\n            'wave', {'k': 5.0}, 1e-8\n        ),\n        (\n            [(0.0, 0.0), (0.001, 0.0), (0.001, 1.0), (0.0, 1.0)],\n            'wave', {'k': 20.0}, 1e-8\n        ),\n        (\n            [(0.5, 0.0), (1.5, 0.0), (1.7, 1.2), (0.4, 1.0)],\n            'gauss', {'x0': 1.0, 'y0': 0.5, 'sigma': 0.15}, 1e-8\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        integral_value = compute_integral_for_case(case)\n        results.append(f\"{integral_value:.10f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}