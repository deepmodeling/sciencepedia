{
    "hands_on_practices": [
        {
            "introduction": "任何边界积分方法的核心都是其积分核，即格林函数。在构建数值求解器之前，我们必须理解这些核的解析性质，特别是当源点和观测点相互靠近时的奇异行为。本练习将重点推导二维亥姆霍兹格林函数的对数奇异性，这是任何二维边界元方法代码的基础分析。",
            "id": "4119646",
            "problem": "考虑在无界、均匀的二维介质中的时谐声传播。对于波数 $k>0$ 的 Helmholtz 算子，其自由空间格林函数（也称为基本解）是分布 $G(\\mathbf{x},\\mathbf{y})$，它在 $\\mathbb{R}^{2}$ 中满足偏微分方程 (PDE) $(\\Delta_{\\mathbf{x}}+k^{2})\\,G(\\mathbf{x},\\mathbf{y})=-\\delta(\\mathbf{x}-\\mathbf{y})$ 以及外行 Sommerfeld 辐射条件。在直接和间接边界积分方程 (BIE) 的公式中，$G(\\mathbf{x},\\mathbf{y})$ 作为单层势和双层势的核函数出现。令 $r=|\\mathbf{x}-\\mathbf{y}|$。\n\na) 用零阶第一类 Hankel 函数显式地表示 $G(\\mathbf{x},\\mathbf{y})$。\n\nb) 仅使用经过充分检验的 Bessel 函数和 Hankel 函数的小宗量展开式，推导当 $r\\to 0^{+}$ 时 $G(\\mathbf{x},\\mathbf{y})$ 的领头阶渐近式，以揭示其对数奇异性。定义有限部分常数\n$$\nC(k)\\equiv \\lim_{r\\to 0^{+}}\\left[G(\\mathbf{x},\\mathbf{y})+\\frac{1}{2\\pi}\\ln r\\right],\n$$\n并以闭式形式计算 $C(k)$，其中 $\\gamma$ 表示 Euler–Mascheroni 常数。请以单个解析表达式的形式给出 $C(k)$ 的最终答案。",
            "solution": "该问题要求分析在 $\\mathbb{R}^{2}$ 中二维 Helmholtz 方程 $(\\Delta_{\\mathbf{x}}+k^{2})\\,G(\\mathbf{x},\\mathbf{y})=-\\delta(\\mathbf{x}-\\mathbf{y})$ 的自由空间格林函数。该函数，也称为基本解，必须满足 Sommerfeld 辐射条件，以确保波在无穷远处是纯粹外行的。令 $r=|\\mathbf{x}-\\mathbf{y}|$ 为源点 $\\mathbf{y}$ 和观测点 $\\mathbf{x}$ 之间的距离。\n\na) 满足外行辐射条件的二维 Helmholtz 方程的基本解在偏微分方程和波传播理论中是公认的。它由零阶第一类 Hankel 函数给出，记为 $H_0^{(1)}$。其具体形式为：\n$$\nG(\\mathbf{x},\\mathbf{y}) = \\frac{i}{4} H_0^{(1)}(kr)\n$$\n常数前置因子 $\\frac{i}{4}$ 是一个归一化常数，确保该函数满足定义的偏微分方程 $(\\Delta + k^2)G = -\\delta$。为验证此常数，可以在以 $\\mathbf{y}$ 为中心、半径为 $\\epsilon$ 的小圆盘 $B_{\\epsilon}$ 上对 PDE 进行积分，并取极限 $\\epsilon \\to 0$。根据散度定理，我们有：\n$$\n\\int_{B_{\\epsilon}} (\\Delta_{\\mathbf{x}}+k^{2})\\,G(\\mathbf{x},\\mathbf{y}) \\, d\\mathbf{x} = \\int_{\\partial B_{\\epsilon}} \\nabla_{\\mathbf{x}} G \\cdot \\mathbf{n} \\, dS + k^2 \\int_{B_{\\epsilon}} G \\, d\\mathbf{x}\n$$\n其中 $\\mathbf{n}$ 是边界 $\\partial B_{\\epsilon}$ 的外单位法向量。该积分必须等于 $-\\int_{B_{\\epsilon}} \\delta(\\mathbf{x}-\\mathbf{y}) \\, d\\mathbf{x} = -1$。使用已知的 Hankel 函数的小宗量渐近式，可以证明当 $\\epsilon \\to 0$ 时，右侧第一项趋近于 $-1$，第二项消失，这证实了前置因子 $\\frac{i}{4}$ 的选择。\n\nb) 为确定有限部分常数 $C(k)$，我们必须首先找出当 $r \\to 0^{+}$ 时 $G(\\mathbf{x},\\mathbf{y})$ 的领头阶渐近式。这需要用到构成 Hankel 函数的 Bessel 函数的小宗量展开式。Hankel 函数 $H_0^{(1)}(z)$ 定义为 $H_0^{(1)}(z) = J_0(z) + iY_0(z)$，其中 $J_0(z)$ 是零阶第一类 Bessel 函数，$Y_0(z)$ 是零阶第二类 Bessel 函数。\n\n对于小宗量 $z \\to 0$，其标准渐近展开式为：\n$$\nJ_0(z) = 1 - \\frac{z^2}{4} + O(z^4)\n$$\n$$\nY_0(z) = \\frac{2}{\\pi} \\left[ \\left(\\ln\\left(\\frac{z}{2}\\right) + \\gamma \\right) J_0(z) + \\frac{z^2}{4} - \\dots \\right]\n$$\n其中 $\\gamma \\approx 0.5772$ 是 Euler–Mascheroni 常数。\n\n对于 $z \\to 0$ 时的领头阶行为，我们可以近似 $J_0(z) \\approx 1$。因此，$Y_0(z)$ 的展开式简化为：\n$$\nY_0(z) = \\frac{2}{\\pi} \\left( \\ln\\left(\\frac{z}{2}\\right) + \\gamma \\right) + O(z^2 \\ln z)\n$$\n综合这些结果，$H_0^{(1)}(z)$ 的小宗量展开式为：\n$$\nH_0^{(1)}(z) = J_0(z) + iY_0(z) = 1 + i \\frac{2}{\\pi} \\left( \\ln\\left(\\frac{z}{2}\\right) + \\gamma \\right) + O(z^2 \\ln z)\n$$\n现在，我们将 $z=kr$ 代入此展开式，以找出 $G(\\mathbf{x},\\mathbf{y})$ 在 $r$ 较小时的行为：\n$$\nG(\\mathbf{x},\\mathbf{y}) = \\frac{i}{4} H_0^{(1)}(kr) = \\frac{i}{4} \\left[ 1 + i \\frac{2}{\\pi} \\left( \\ln\\left(\\frac{kr}{2}\\right) + \\gamma \\right) + O((kr)^2 \\ln(kr)) \\right]\n$$\n分配因子 $\\frac{i}{4}$：\n$$\nG(\\mathbf{x},\\mathbf{y}) = \\frac{i}{4} + \\frac{i^2}{4} \\frac{2}{\\pi} \\left( \\ln\\left(\\frac{kr}{2}\\right) + \\gamma \\right) + O(r^2 \\ln r)\n$$\n由于 $i^2 = -1$：\n$$\nG(\\mathbf{x},\\mathbf{y}) = \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln\\left(\\frac{kr}{2}\\right) + \\gamma \\right) + O(r^2 \\ln r)\n$$\n我们可以使用对数的性质 $\\ln(a/b) = \\ln(a) - \\ln(b)$ 和 $\\ln(ab) = \\ln(a) + \\ln(b)$ 来分离出与 $r$ 相关的项：\n$$\nG(\\mathbf{x},\\mathbf{y}) = \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln(r) + \\ln(k) - \\ln(2) + \\gamma \\right) + O(r^2 \\ln r)\n$$\n$$\nG(\\mathbf{x},\\mathbf{y}) = -\\frac{1}{2\\pi} \\ln r + \\left[ \\frac{i}{4} - \\frac{1}{2\\pi} (\\ln(k) - \\ln(2) + \\gamma) \\right] + O(r^2 \\ln r)\n$$\n此表达式显式地揭示了当 $r \\to 0^{+}$ 时格林函数的对数奇异性。领头阶渐近行为是 $G(\\mathbf{x},\\mathbf{y}) \\sim -\\frac{1}{2\\pi}\\ln r$。\n\n有限部分常数 $C(k)$ 由以下极限定义：\n$$\nC(k) \\equiv \\lim_{r\\to 0^{+}}\\left[G(\\mathbf{x},\\mathbf{y})+\\frac{1}{2\\pi}\\ln r\\right]\n$$\n将我们得到的 $G(\\mathbf{x},\\mathbf{y})$ 的渐近表达式代入此定义中：\n$$\nC(k) = \\lim_{r\\to 0^{+}}\\left[ \\left(-\\frac{1}{2\\pi} \\ln r + \\frac{i}{4} - \\frac{1}{2\\pi} (\\ln(k) - \\ln(2) + \\gamma) + O(r^2 \\ln r) \\right) + \\frac{1}{2\\pi}\\ln r \\right]\n$$\n对数奇异性项被消去：\n$$\nC(k) = \\lim_{r\\to 0^{+}}\\left[ \\frac{i}{4} - \\frac{1}{2\\pi} (\\ln(k) - \\ln(2) + \\gamma) + O(r^2 \\ln r) \\right]\n$$\n当 $r \\to 0^{+}$ 时，$O(r^2 \\ln r)$ 项消失。因此，极限为：\n$$\nC(k) = \\frac{i}{4} - \\frac{1}{2\\pi} (\\ln(k) - \\ln(2) + \\gamma)\n$$\n该表达式可以通过合并对数项来重写：\n$$\nC(k) = \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln\\left(\\frac{k}{2}\\right) + \\gamma \\right)\n$$\n这就是有限部分常数 $C(k)$ 的闭式表达式。",
            "answer": "$$\n\\boxed{\\frac{i}{4} - \\frac{1}{2\\pi}\\left(\\ln\\left(\\frac{k}{2}\\right) + \\gamma\\right)}\n$$"
        },
        {
            "introduction": "从解析上理解奇异性是一回事，而精确地对其进行积分则是另一回事。本练习从纯分析转向数值实践，旨在解决计算球体上单层算子“自影响”项的经典问题。通过首先推导精确的解析值，然后实现几种数值积分方案，您将亲身体验三维弱奇异积分带来的挑战及其解决方案。",
            "id": "4119598",
            "problem": "考虑由标量亥姆霍兹方程及其边界积分公式所描述的三维声散射问题。在求解外问题的直接边界积分方程（BIE）和间接边界积分方程（BIE）方法中，单层边界积分算子源于将声压场表示为一个基本解与边界上某个未知密度的表面卷积。在声波数为零的静态极限下，该问题简化为拉普拉斯情况。三维拉普拉斯基本解由 $G(\\mathbf{x},\\mathbf{y}) = \\frac{1}{4\\pi\\lVert \\mathbf{x}-\\mathbf{y}\\rVert}$ 给出，其中 $\\mathbf{x}$ 是场点，$\\mathbf{y}$ 是边界上的源点。对于边界元上的常数基函数，单层矩阵的对角自作用项对应一个弱奇异曲面积分，其中场点位于同一曲面单元上。\n\n你的任务是，对于单位球面上的一个配置点 $\\mathbf{x}_0$，从第一性原理推导拉普拉斯情况（$k=0$）下单层算子在单位球面上的对角自作用项的解析值。从整个单位球面 $S^2$ 上的常数基的积分定义出发，该自作用项可以写为\n$$\nI = \\int_{S^2} G(\\mathbf{x}_0,\\mathbf{y}) \\,\\mathrm{d}S_{\\mathbf{y}} = \\frac{1}{4\\pi}\\int_{S^2} \\frac{1}{\\lVert \\mathbf{x}_0-\\mathbf{y}\\rVert} \\,\\mathrm{d}S_{\\mathbf{y}}.\n$$\n利用单位球面上的几何关系，设极轴通过 $\\mathbf{x}_0$，用 $\\theta \\in [0,\\pi]$ 表示极角，用 $\\phi \\in [0,2\\pi]$ 表示方位角（角度以弧度为单位）。证明该积分是良定的，并对其进行解析计算。\n\n然后，实现一个程序，对同一积分进行数值近似，并针对你推导出的解析值，对三种奇异性感知的求积策略进行基准测试：\n\n- 策略 A（普通球面求积）：计算\n$$\nI_{\\mathrm{num}} = \\frac{1}{4\\pi}\\int_{0}^{2\\pi}\\int_{0}^{\\pi} \\frac{\\sin\\theta}{2\\sin\\big(\\frac{\\theta}{2}\\big)}\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi,\n$$\n使用 $\\theta$ 上的 Gauss–Legendre 求积和 $\\phi$ 上的均匀梯形法则。实现因子 $\\frac{\\sin\\theta}{2\\sin(\\theta/2)}$ 在 $\\theta=0$ 附近的一个数值稳定的计算方法。\n\n- 策略 B（近场解析分离）：在一个小的极角截断值 $\\theta_c \\in (0,\\pi)$ 处将积分分割为\n$$\nI = \\frac{1}{4\\pi}\\int_{0}^{2\\pi}\\int_{0}^{\\theta_c} \\frac{\\sin\\theta}{2\\sin\\big(\\frac{\\theta}{2}\\big)}\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi + \\frac{1}{4\\pi}\\int_{0}^{2\\pi}\\int_{\\theta_c}^{\\pi} \\frac{\\sin\\theta}{2\\sin\\big(\\frac{\\theta}{2}\\big)}\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi,\n$$\n解析计算近场部分，并使用 $\\theta$ 上的 Gauss–Legendre 求积和 $\\phi$ 上的均匀梯形法则数值计算远场部分。\n\n- 策略 C（二次 Duffy 型映射）：通过二次变量代换 $\\theta = u^2$（其中 $u \\in [0,\\sqrt{\\pi}]$）将分辨率集中在弱奇异点附近，使得\n$$\nI_{\\mathrm{num}} = \\frac{1}{4\\pi}\\int_{0}^{2\\pi}\\int_{0}^{\\sqrt{\\pi}} \\frac{\\sin(u^2)}{2\\sin\\big(\\frac{u^2}{2}\\big)}\\cdot 2u \\,\\mathrm{d}u\\,\\mathrm{d}\\phi,\n$$\n并使用 $u$ 上的 Gauss–Legendre 求积和 $\\phi$ 上的均匀梯形法则进行计算。\n\n所有角度必须以弧度处理。你的程序必须计算每个数值近似值与你推导的解析值之间的绝对误差。\n\n设计一个测试套件，覆盖不同的求积分辨率和近场截断值：\n- 对于策略 A：$(N_\\theta,N_\\phi) \\in \\{(4,8),(16,32),(64,128)\\}$。\n- 对于策略 B：$(N_\\theta,N_\\phi,\\theta_c) \\in \\{(16,32,0.1),(16,32,0.5),(16,32,1.0)\\}$。\n- 对于策略 C：$(N_u,N_\\phi) \\in \\{(16,32),(64,128)\\}$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果按上述测试套件指定的顺序排列，并表示为浮点数。例如，最后一行必须是以下格式：\n$$\n[\\text{error}_{A1},\\text{error}_{A2},\\text{error}_{A3},\\text{error}_{B1},\\text{error}_{B2},\\text{error}_{B3},\\text{error}_{C1},\\text{error}_{C2}].\n$$",
            "solution": "三维时谐波的声散射问题由亥姆霍兹方程描述。在边界积分方程（BIE）公式中，直接和间接方法都使用基本解和边界上的未知密度的曲面积分来表示解。拉普拉斯极限下的单层算子是核心：对于拉普拉斯方程，其基本解为 $G(\\mathbf{x},\\mathbf{y}) = \\frac{1}{4\\pi\\lVert \\mathbf{x}-\\mathbf{y}\\rVert}$，当观测点位于边界元上时，它会产生一个弱奇异的被积函数。\n\n我们考虑在整个单位球面 $S^2$ 上具有常数基，并且在球面上有一个配置点 $\\mathbf{x}_0$ 的情况。拉普拉斯情况下单层矩阵的对角自作用项为\n$$\nI = \\frac{1}{4\\pi}\\int_{S^2} \\frac{1}{\\lVert \\mathbf{x}_0 - \\mathbf{y}\\rVert}\\,\\mathrm{d}S_{\\mathbf{y}}.\n$$\n为进行解析计算，我们选择一个球坐标系，其中心使得极轴通过 $\\mathbf{x}_0$。设 $\\theta$ 为极角，$\\phi$ 为方位角，其中 $\\theta \\in [0,\\pi]$ 且 $\\phi \\in [0,2\\pi]$（角度以弧度为单位）。对于单位球面上的点，$\\mathbf{x}_0$ 和 $\\mathbf{y}$ 之间的欧几里得距离仅通过关系式\n$$\n\\lVert \\mathbf{x}_0 - \\mathbf{y} \\rVert = \\sqrt{2-2\\cos\\theta} = 2\\sin\\left(\\frac{\\theta}{2}\\right).\n$$\n取决于极角 $\\theta$。单位球面上的曲面元为\n$$\n\\mathrm{d}S = \\sin\\theta \\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi.\n$$\n因此，积分变为\n$$\nI = \\frac{1}{4\\pi}\\int_{0}^{2\\pi}\\int_{0}^{\\pi} \\frac{\\sin\\theta}{2\\sin\\left(\\frac{\\theta}{2}\\right)}\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi.\n$$\n注意，在 $\\theta = 0$ 处的表观奇异性是可积的，因为曲面元中的因子 $\\sin\\theta$ 消除了核函数中 $1/\\sin(\\theta/2)$ 的行为。使用恒等式 $\\sin\\theta = 2\\sin(\\theta/2)\\cos(\\theta/2)$，被积函数简化为\n$$\n\\frac{\\sin\\theta}{2\\sin\\left(\\frac{\\theta}{2}\\right)} = \\cos\\left(\\frac{\\theta}{2}\\right),\n$$\n该函数在 $[0,\\pi]$ 上是光滑的。因此，\n$$\nI = \\frac{1}{4\\pi}\\int_{0}^{2\\pi}\\int_{0}^{\\pi} \\cos\\left(\\frac{\\theta}{2}\\right)\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi = \\frac{1}{4\\pi}\\cdot 2\\pi \\cdot \\int_{0}^{\\pi} \\cos\\left(\\frac{\\theta}{2}\\right)\\,\\mathrm{d}\\theta.\n$$\n计算内层积分：\n$$\n\\int_{0}^{\\pi} \\cos\\left(\\frac{\\theta}{2}\\right)\\,\\mathrm{d}\\theta = 2\\left[\\sin\\left(\\frac{\\theta}{2}\\right)\\right]_{0}^{\\pi} = 2.\n$$\n因此，\n$$\nI = \\frac{1}{4\\pi}\\cdot 2\\pi \\cdot 2 = 1.\n$$\n这个解析值与经典的势论结果一致：半径为 $a$ 的均匀带电球壳在其表面上一点的牛顿势为 $\\int_{S^2} \\frac{1}{\\lVert \\mathbf{x}_0 - \\mathbf{y}\\rVert}\\,\\mathrm{d}S_{\\mathbf{y}} = 4\\pi a$，当 $a=1$ 且考虑因子 $\\frac{1}{4\\pi}$ 时，得到 $I=1$。\n\n用于数值基准测试的算法设计如下：\n\n- 对于策略 A，我们使用具有 $N_\\theta$ 个节点的 Gauss–Legendre 求积来近似 $[0,\\pi]$ 上的 $\\theta$ 积分，并使用具有 $N_\\phi$ 个点的均匀梯形法则来处理 $[0,2\\pi]$ 上的 $\\phi$ 积分。被积函数计算为 $\\frac{\\sin\\theta}{2\\sin(\\theta/2)}$，当 $\\sin(\\theta/2)$ 低于一个很小的阈值时，为了避免除以一个极小的数，会用数值稳定的方式替换为 $\\cos(\\theta/2)$。\n\n- 对于策略 B，我们在截断值 $\\theta_c$ 处分割积分。近场部分进行解析计算：\n$$\nI_{\\mathrm{near}} = \\frac{1}{4\\pi}\\int_{0}^{2\\pi}\\int_{0}^{\\theta_c} \\cos\\left(\\frac{\\theta}{2}\\right)\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi = \\frac{1}{4\\pi}\\cdot 2\\pi \\cdot 2\\sin\\left(\\frac{\\theta_c}{2}\\right) = \\sin\\left(\\frac{\\theta_c}{2}\\right).\n$$\n远场部分在 $[\\theta_c,\\pi]$ 上通过对 $\\theta$ 使用 Gauss–Legendre 求积和对 $\\phi$ 使用梯形法则进行数值计算。总的近似值为 $I_{\\mathrm{near}} + I_{\\mathrm{far}}$。\n\n- 对于策略 C，我们应用二次变量代换 $\\theta = u^2$，其中 $u \\in [0,\\sqrt{\\pi}]$。雅可比给出 $\\mathrm{d}\\theta = 2u\\,\\mathrm{d}u$。被积函数变为 $\\frac{\\sin(u^2)}{2\\sin(u^2/2)}\\cdot 2u$，当分母很小时，通过切换到 $\\cos(u^2/2)\\cdot 2u$ 在 $u=0$ 附近进行稳定计算。我们使用具有 $N_u$ 个节点的 Gauss–Legendre 求积处理 $[0,\\sqrt{\\pi}]$ 上的积分，并对 $\\phi$ 使用梯形法则。\n\n对于每个测试用例，程序计算数值估计值 $I_{\\mathrm{num}}$ 和绝对误差 $\\lvert I_{\\mathrm{num}} - 1\\rvert$，其中 $1$ 是上面推导出的解析值。结果以单行形式生成，作为一个用方括号括起来的逗号分隔列表，其顺序与测试套件相匹配。该设计测试了分辨率效应（通过 $N_\\theta$、$N_\\phi$、$N_u$）、弱奇异性的处理以及不同 $\\theta_c$ 下近场分离的影响。\n\n所有角度必须以弧度处理，输出值为无量纲的浮点数。不需要物理单位，因为单位球面和拉普拉斯核的归一化因子 $\\frac{1}{4\\pi}$ 使得目标量成为无量纲。",
            "answer": "```python\nimport numpy as np\n\ndef gauss_legendre_interval(n, a, b):\n    # Nodes and weights on [a,b] from Legendre polynomial on [-1,1]\n    xi, wi = np.polynomial.legendre.leggauss(n)\n    # Affine map\n    x = 0.5*(b - a)*xi + 0.5*(b + a)\n    w = 0.5*(b - a)*wi\n    return x, w\n\ndef stable_sin_over_2sin_half(theta, eps=1e-14):\n    # Evaluate sin(theta)/(2*sin(theta/2)) stably near theta=0\n    half = 0.5 * theta\n    denom = np.sin(half)\n    # Where denom is small, use cos(theta/2)\n    out = np.empty_like(theta, dtype=np.float64)\n    mask = np.abs(denom) > eps\n    # For the safe region (mask), perform division\n    out[mask] = np.sin(theta[mask]) / (2.0 * denom[mask])\n    # For the unsafe region (~mask), use stable form\n    out[~mask] = np.cos(half[~mask])\n    return out\n\ndef strategy_plain(N_theta, N_phi):\n    # Integrate over theta in [0, pi] and phi in [0, 2pi]\n    theta, w_theta = gauss_legendre_interval(N_theta, 0.0, np.pi)\n    # Uniform trapezoidal rule for phi\n    phi_w = (2.0 * np.pi) / N_phi\n    # Integrand does not depend on phi; phi integration gives exactly 2*pi by trapezoid on constant function\n    f_theta = stable_sin_over_2sin_half(theta)\n    integral_theta = np.sum(w_theta * f_theta)\n    I_num = (1.0 / (4.0 * np.pi)) * (N_phi * phi_w) * integral_theta\n    return I_num\n\ndef strategy_near_analytic(N_theta, N_phi, theta_c):\n    # Near-field analytic part\n    I_near = np.sin(0.5 * theta_c)\n    # Far-field numerical part over theta in [theta_c, pi]\n    theta, w_theta = gauss_legendre_interval(N_theta, theta_c, np.pi)\n    phi_w = (2.0 * np.pi) / N_phi\n    f_theta = stable_sin_over_2sin_half(theta)\n    integral_theta = np.sum(w_theta * f_theta)\n    I_far = (1.0 / (4.0 * np.pi)) * (N_phi * phi_w) * integral_theta\n    return I_near + I_far\n\ndef strategy_u2(N_u, N_phi):\n    # Quadratic mapping theta = u^2, u in [0, sqrt(pi)]\n    u, w_u = gauss_legendre_interval(N_u, 0.0, np.sqrt(np.pi))\n    theta = u**2\n    # Integrand with Jacobian: sin(theta)/(2*sin(theta/2))*2u\n    core = stable_sin_over_2sin_half(theta)\n    f_u = core * (2.0 * u)\n    integral_u = np.sum(w_u * f_u)\n    phi_w = (2.0 * np.pi) / N_phi\n    I_num = (1.0 / (4.0 * np.pi)) * (N_phi * phi_w) * integral_u\n    return I_num\n\ndef solve():\n    # Analytic value from derivation\n    I_analytic = 1.0\n\n    # Define the test cases (ordered as specified)\n    test_cases = [\n        ('plain', 4, 8),\n        ('plain', 16, 32),\n        ('plain', 64, 128),\n        ('near_analytic', 16, 32, 0.1),\n        ('near_analytic', 16, 32, 0.5),\n        ('near_analytic', 16, 32, 1.0),\n        ('u2', 16, 32),\n        ('u2', 64, 128),\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[0] == 'plain':\n            _, N_theta, N_phi = case\n            I_num = strategy_plain(N_theta, N_phi)\n        elif case[0] == 'near_analytic':\n            _, N_theta, N_phi, theta_c = case\n            I_num = strategy_near_analytic(N_theta, N_phi, theta_c)\n        elif case[0] == 'u2':\n            _, N_u, N_phi = case\n            I_num = strategy_u2(N_u, N_phi)\n        else:\n            I_num = np.nan\n        error = abs(I_num - I_analytic)\n        results.append(error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "双层势是边界元方法的另一块基石，它引出的第二类积分方程通常比第一类积分方程具有更好的条件数。该算子的一个关键特征是当在边界上求值时表现出的“跳跃”，这导致离散系统中出现一个单位算子项。本编程练习提供了一个实现双层算子的实践指南，通过搭配点法在数值上验证著名的Plemelj-Sokhotski跳跃条件。",
            "id": "4119643",
            "problem": "考虑由亥姆霍兹方程控制的时谐波计算声学问题。设声压场由 $u(\\mathbf{x})$ 表示，它在二维空间中满足齐次亥姆霍兹偏微分方程，\n$$\n(\\nabla^2 + k^2) u(\\mathbf{x}) = 0,\n$$\n其中 $k > 0$ 是波数。二维亥姆霍兹方程的自由空间格林函数 $G(\\mathbf{x}, \\mathbf{y})$ 定义为\n$$\nG(\\mathbf{x}, \\mathbf{y}) = \\frac{\\mathrm{i}}{4} H_0^{(1)}\\left(k \\lvert \\mathbf{x} - \\mathbf{y} \\rvert \\right),\n$$\n其中 $H_0^{(1)}$ 是零阶第一类汉克尔函数，$\\mathrm{i}$ 是虚数单位。密度为 $\\varphi$ 且支集在光滑闭合边界 $\\Gamma$ 上的双层势 $\\mathcal{D}[\\varphi](\\mathbf{x})$ 由下式给出\n$$\n\\mathcal{D}[\\varphi](\\mathbf{x}) = \\int_{\\Gamma} \\frac{\\partial G(\\mathbf{x}, \\mathbf{y})}{\\partial n_{\\mathbf{y}}} \\, \\varphi(\\mathbf{y}) \\, \\mathrm{d}\\Gamma(\\mathbf{y}),\n$$\n其中 $\\partial/\\partial n_{\\mathbf{y}}$ 表示在边界 $\\Gamma$ 上沿单位法向量 $\\mathbf{n}_{\\mathbf{y}}$ 方向关于源点 $\\mathbf{y}$ 的法向导数。\n\n已知双层势的边值极限会表现出跳跃间断，这由 Plemelj-Sokhotski 公式描述。当从区域外部（法向朝外）趋近边界 $\\Gamma$ 时，双层势的极限满足\n$$\n\\lim_{\\mathbf{x} \\to \\Gamma^{+}} \\mathcal{D}[\\varphi](\\mathbf{x}) = \\frac{1}{2} \\varphi(\\mathbf{x}) + \\operatorname{P.V.} \\int_{\\Gamma} \\frac{\\partial G(\\mathbf{x}, \\mathbf{y})}{\\partial n_{\\mathbf{y}}} \\, \\varphi(\\mathbf{y}) \\, \\mathrm{d}\\Gamma(\\mathbf{y}),\n$$\n而当从内部趋近时，\n$$\n\\lim_{\\mathbf{x} \\to \\Gamma^{-}} \\mathcal{D}[\\varphi](\\mathbf{x}) = -\\frac{1}{2} \\varphi(\\mathbf{x}) + \\operatorname{P.V.} \\int_{\\Gamma} \\frac{\\partial G(\\mathbf{x}, \\mathbf{y})}{\\partial n_{\\mathbf{y}}} \\, \\varphi(\\mathbf{y}) \\, \\mathrm{d}\\Gamma(\\mathbf{y}),\n$$\n其中 $\\operatorname{P.V.}$ 表示柯西主值积分。这个带有 $\\pm \\frac{1}{2}$ 跳跃的边值极限在直接和间接边界积分方程格式中都至关重要：在直接格式中，将边界条件施加在 $u(\\mathbf{x})$ 于 $\\Gamma$ 上的物理迹上，并使用位势理论得到一个包含 $\\frac{1}{2}$ 单位项的第二类边界积分方程；在间接格式中，用一个带有未知密度的位势拟设来表示场，并再次施加边界条件，从而产生相同的跳跃结构。\n\n您的任务是在一条光滑闭合曲线上实现一个配置法，通过在每个配置点显式地计算主值积分并加上单位项，来数值上实现带有 $\\frac{1}{2}$ 跳跃的边值极限。使用半径为 $a = 1$ 的单位圆 $\\Gamma = \\{\\mathbf{y}(\\theta) = (a \\cos \\theta, a \\sin \\theta) : \\theta \\in [0, 2\\pi)\\}$，其向外单位法向量为 $\\mathbf{n}_{\\mathbf{y}}(\\theta) = (\\cos \\theta, \\sin \\theta)$。用角度 $\\theta$（以弧度为单位）来参数化边界。弧长元为 $\\mathrm{d}\\Gamma(\\mathbf{y}) = a \\, \\mathrm{d}\\theta$。\n\n对于配置点 $\\theta_i = 2\\pi i / N$（其中 $i = 0, 1, \\dots, N-1$），定义一个离散算子矩阵 $\\mathbf{A} \\in \\mathbb{C}^{N \\times N}$ 来近似\n$$\n\\left( s \\, \\mathbf{I} + \\mathcal{K} \\right) \\varphi(\\theta_i) \\approx s \\, \\varphi(\\theta_i) + \\sum_{j \\neq i} w \\, K(\\theta_i, \\theta_j) \\, \\varphi(\\theta_j),\n$$\n其中 $s \\in \\{+1/2, -1/2\\}$ 表示外部或内部边界极限，$\\mathbf{I}$ 是单位矩阵， $w = \\frac{2\\pi a}{N}$ 是梯形法则的权重，以及\n$$\nK(\\theta_i, \\theta_j) = \\frac{\\partial G(\\mathbf{x}(\\theta_i), \\mathbf{y}(\\theta_j))}{\\partial n_{\\mathbf{y}}} = \\frac{\\mathrm{i} k}{4} H_1^{(1)}\\left(k r_{ij}\\right) \\frac{(\\mathbf{x}(\\theta_i) - \\mathbf{y}(\\theta_j)) \\cdot \\mathbf{n}_{\\mathbf{y}}(\\theta_j)}{r_{ij}},\n$$\n其中 $r_{ij} = \\lvert \\mathbf{x}(\\theta_i) - \\mathbf{y}(\\theta_j) \\rvert$，而 $H_1^{(1)}$ 是一阶第一类汉克尔函数。通过在求和中省略 $j = i$ 项，并在对角线元素上加上单位项 $s$ 来实现主值积分，即设置 $A_{ii} = s$ 和 $A_{ij} = w \\, K(\\theta_i, \\theta_j)$（当 $i \\neq j$ 时）。\n\n为了使问题在不预设解析本征结构的情况下可进行数值测试，请使用一个人为构造的密度函数 $\\varphi(\\theta)$，并通过过采样求积来计算右端项 $g(\\theta_i)$。该过采样求积以更高分辨率近似主值积分，以模拟“连续”积分。具体来说，对于每个配置点 $\\theta_i$，定义一个过采样网格 $\\theta'_m = 2\\pi (m + 1/2)/M$（其中 $m = 0, 1, \\dots, M-1$）以避免点重合，设置 $w' = 2\\pi a / M$，并近似计算\n$$\ng(\\theta_i) \\approx s \\, \\varphi(\\theta_i) + \\sum_{m=0}^{M-1} w' \\, K(\\theta_i, \\theta'_m) \\, \\varphi(\\theta'_m),\n$$\n其中 $K(\\theta_i, \\theta'_m)$ 使用 $\\mathbf{y}(\\theta'_m)$ 和 $\\mathbf{n}_{\\mathbf{y}}(\\theta'_m)$ 类似地进行计算。\n\n人为构造的密度函数为\n$$\n\\varphi(\\theta) = e^{\\mathrm{i} 3 \\theta} + \\frac{1}{2} e^{-\\mathrm{i} 2 \\theta}.\n$$\n\n您的程序必须：\n- 使用上述配置法，为给定参数 $(k, N, s, a)$ 构建矩阵 $\\mathbf{A}$。\n- 使用具有 $(M = \\alpha N)$ 个点和 $\\theta$ 中半步移位的过采样主值积分来计算 $g(\\theta_i)$。\n- 求解离散线性系统 $\\mathbf{A} \\, \\hat{\\varphi} = \\mathbf{g}$，以恢复人为构造的 $\\varphi(\\theta_i)$ 的近似解 $\\hat{\\varphi}$。\n- 报告相对加权 $\\ell^2$ 误差\n$$\nE = \\frac{\\left( \\sum_{i=0}^{N-1} \\lvert \\hat{\\varphi}_i - \\varphi(\\theta_i) \\rvert^2 \\, w \\right)^{1/2}}{\\left( \\sum_{i=0}^{N-1} \\lvert \\varphi(\\theta_i) \\rvert^2 \\, w \\right)^{1/2}}.\n$$\n\n角度单位必须是弧度。输出不需要物理单位。\n\n为以下参数集测试套件 $(k, N, s, a, \\alpha)$ 实现此过程：\n1. $(k = 2.0, N = 128, s = +\\frac{1}{2}, a = 1.0, \\alpha = 4)$。\n2. $(k = 2.0, N = 64, s = -\\frac{1}{2}, a = 1.0, \\alpha = 4)$。\n3. $(k = 0.1, N = 128, s = +\\frac{1}{2}, a = 1.0, \\alpha = 8)$。\n4. $(k = 20.0, N = 256, s = +\\frac{1}{2}, a = 1.0, \\alpha = 8)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如“[result1,result2,result3,result4]”。每个结果必须是一个浮点数，表示相应测试用例的相对误差 $E$。请使用指定的波数，并确保整个过程中角度变量 $\\theta$ 均以弧度为单位。",
            "solution": "用户提供的问题已经过分析，并被认为是有效的。该问题基于计算声学和边界元法的原理，具有科学依据，是适定的，并为数值验证任务提供了一套完整、无歧义的指令。该问题要求在圆形域上实施一种配置边界元法来求解亥姆霍兹方程，特别是为了验证双层势跳跃条件的数值表示。\n\n求解过程首先离散化边界积分算子，然后使用人为构造解法构建右端项向量，接着求解得到的线性系统，最后计算数值解的误差。\n\n### 1. 基于原理的数值格式设计\n\n问题的核心在于对边界积分方程的数值近似，该方程源于使用位势理论表示声场 $u(\\mathbf{x})$。对于边界 $\\Gamma$ 上的密度函数 $\\varphi$，双层势算子 $\\mathcal{D}[\\varphi]$ 的边值极限得到算子 $s\\mathbf{I} + \\mathcal{K}$，其中 $\\mathcal{K}$ 是柯西主值积分部分，而 $s\\mathbf{I}$ 是跳跃项，其中 $s = \\pm 1/2$ 取决于极限的方向（外部/内部）。我们将构建此算子的离散版本并进行测试。\n\n#### 1.1. 边界离散化与求积\n\n边界 $\\Gamma$ 是一个半径为 $a$ 的圆，通过角度 $\\theta \\in [0, 2\\pi)$ 参数化为 $\\mathbf{y}(\\theta) = (a \\cos \\theta, a \\sin \\theta)$。我们使用一组均匀分布的配置点将此边界离散为 $N$ 个段。配置点 $\\mathbf{x}_i$ 对应于角度 $\\theta_i = 2\\pi i / N$（其中 $i = 0, 1, \\dots, N-1$）。\n\n积分算子 $\\mathcal{K}$ 包含一个对 $\\Gamma$ 的积分。我们使用梯形法则来近似该积分。以源点 $\\mathbf{y}_j$ 为中心的每个段的贡献由该段的弧长加权，弧长近似为 $w = 2\\pi a / N$。\n\n#### 1.2. 边界积分算子的离散化\n\n我们构建一个 $N \\times N$ 的复矩阵 $\\mathbf{A}$，它表示算子 $s\\mathbf{I} + \\mathcal{K}$ 的离散形式。\n\n对于 $i \\neq j$，非对角元素 $A_{ij}$ 近似积分算子 $\\mathcal{K}$ 的作用。这是通过配置法实现的，即我们计算每对配置点 $\\mathbf{x}_i$ 和源点 $\\mathbf{y}_j$ 之间的积分核。\n$$\nA_{ij} = w \\, K(\\theta_i, \\theta_j) \\quad \\text{for } i \\neq j\n$$\n这里，$K(\\theta_i, \\theta_j)$ 是双层势算子的核函数：\n$$\nK(\\theta_i, \\theta_j) = \\frac{\\partial G(\\mathbf{x}_i, \\mathbf{y}_j)}{\\partial n_{\\mathbf{y}_j}} = \\frac{\\mathrm{i} k}{4} H_1^{(1)}\\left(k r_{ij}\\right) \\frac{(\\mathbf{x}_i - \\mathbf{y}_j) \\cdot \\mathbf{n}_{\\mathbf{y}_j}}{r_{ij}}\n$$\n其中 $\\mathbf{x}_i = \\mathbf{y}(\\theta_i)$，$\\mathbf{y}_j = \\mathbf{y}(\\theta_j)$，$r_{ij} = \\lvert \\mathbf{x}_i - \\mathbf{y}_j \\rvert$，$\\mathbf{n}_{\\mathbf{y}_j}$ 是点 $\\mathbf{y}_j$ 处的向外单位法向量，对于圆来说即为 $\\mathbf{y}_j/a$。汉克尔函数 $H_1^{(1)}$ 是一阶第一类汉克尔函数。\n\n对角元素 $A_{ii}$ 直接包含了来自 Plemelj-Sokhotski 公式的跳跃项 $s$。主值积分的计算格式涉及移除在 $\\mathbf{y}=\\mathbf{x}$ 处的奇点。在这个简单的配置法中，这是通过在求和中省略奇异项 $j=i$ 来实现的，并且来自单位算子 $\\mathbf{I}$ 的跳跃项被加到对角线上。\n$$\nA_{ii} = s\n$$\n这个组装规则生成了近似于 $s\\mathbf{I} + \\mathcal{K}$ 的离散矩阵算子 $\\mathbf{A}$。\n\n#### 1.3. 人为构造解法\n\n为验证我们的离散算子 $\\mathbf{A}$ 的正确性，我们使用人为构造解法。我们构造一个光滑密度函数 $\\varphi(\\theta)$，并能计算出算子 $(s\\mathbf{I} + \\mathcal{K})\\varphi$ 作用于其上的“真实”结果。这个真实结果将作为我们线性系统中的右端项向量 $\\mathbf{g}$。\n\n人为构造的密度函数为 $\\varphi(\\theta) = e^{\\mathrm{i} 3 \\theta} + \\frac{1}{2} e^{-\\mathrm{i} 2 \\theta}$。\n\n向量 $\\mathbf{g}$ 是通过高精度地近似连续积分来构建的。对于每个配置点 $\\theta_i$，我们计算 $g_i$ 如下：\n$$\ng_i = s \\, \\varphi(\\theta_i) + \\operatorname{P.V.} \\int_{\\Gamma} \\frac{\\partial G(\\mathbf{x}_i, \\mathbf{y})}{\\partial n_{\\mathbf{y}}} \\, \\varphi(\\mathbf{y}) \\, \\mathrm{d}\\Gamma(\\mathbf{y})\n$$\n该积分使用一个更精细的、具有 $M = \\alpha N$ 个点的过采样求积法则进行计算。为避免在此参考计算中出现任何奇点，过采样网格点被移动了半个步长：$\\theta'_m = 2\\pi (m + 1/2)/M$（其中 $m=0, 1, \\dots, M-1$）。相应的求积权重为 $w' = 2\\pi a / M$。然后，向量 $\\mathbf{g}$ 的第 $i$ 个分量计算如下：\n$$\ng_i \\approx s \\, \\varphi(\\theta_i) + \\sum_{m=0}^{M-1} w' \\, K(\\theta_i, \\theta'_m) \\, \\varphi(\\theta'_m)\n$$\n\n#### 1.4. 系统求解与误差计算\n\n在构建了矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{g}$ 后，我们求解线性系统 $\\mathbf{A} \\hat{\\mathbf{\\varphi}} = \\mathbf{g}$ 以得到向量 $\\hat{\\mathbf{\\varphi}}$。向量 $\\hat{\\mathbf{\\varphi}}$ 包含了在配置点上对精确密度值 $\\varphi(\\theta_i)$ 的数值近似 $\\hat{\\varphi}_i$。\n\n最后，我们通过计算相对加权 $\\ell^2$ 误差 $E$ 来量化数值解的精度：\n$$\nE = \\frac{\\left( \\sum_{i=0}^{N-1} \\lvert \\hat{\\varphi}_i - \\varphi(\\theta_i) \\rvert^2 \\, w \\right)^{1/2}}{\\left( \\sum_{i=0}^{N-1} \\lvert \\varphi(\\theta_i) \\rvert^2 \\, w \\right)^{1/2}}\n$$\n由于梯形权重 $w$ 对于均匀网格是恒定的，它在分子和分母中可以消去。误差度量简化为误差向量的标准相对欧几里得范数：\n$$\nE = \\frac{\\|\\hat{\\mathbf{\\varphi}} - \\mathbf{\\varphi}_{\\text{exact}}\\|_2}{\\|\\mathbf{\\varphi}_{\\text{exact}}\\|_2}\n$$\n其中 $(\\mathbf{\\varphi}_{\\text{exact}})_i = \\varphi(\\theta_i)$。一个小的误差 $E$ 表明离散算子 $\\mathbf{A}$ 正确地表示了连续算子 $s\\mathbf{I} + \\mathcal{K}$。对每个指定的测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import hankel1\n\ndef solve():\n    \"\"\"\n    Main function to run the boundary element method verification for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # (k, N, s, a, alpha)\n        (2.0, 128, +0.5, 1.0, 4),\n        (2.0, 64,  -0.5, 1.0, 4),\n        (0.1, 128, +0.5, 1.0, 8),\n        (20.0, 256, +0.5, 1.0, 8),\n    ]\n\n    results = []\n    for params in test_cases:\n        error = compute_bem_error(*params)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_bem_error(k, N, s, a, alpha):\n    \"\"\"\n    Computes the relative error for a single BEM test case.\n\n    Args:\n        k (float): Wavenumber.\n        N (int): Number of collocation points.\n        s (float): Jump term (+0.5 for exterior, -0.5 for interior).\n        a (float): Radius of the circular boundary.\n        alpha (int): Oversampling factor for RHS calculation.\n\n    Returns:\n        float: The relative weighted l2 error.\n    \"\"\"\n    # 1. Discretization and manufactured solution\n    theta = 2 * np.pi * np.arange(N) / N\n    w = 2 * np.pi * a / N\n    \n    # Manufactured density evaluated at collocation points\n    phi_exact_at_theta = np.exp(1j * 3 * theta) + 0.5 * np.exp(-1j * 2 * theta)\n    x_pts = a * np.stack((np.cos(theta), np.sin(theta)), axis=1)\n\n    # 2. Assemble matrix A\n    # Use broadcasting for vectorized computation of all pairs (i, j)\n    # xi_b: (N, 1, 2), yj_b: (1, N, 2)\n    xi_b = x_pts[:, np.newaxis, :]\n    yj_b = x_pts[np.newaxis, :, :]\n    \n    # Vector from source yj to target xi, shape: (N, N, 2)\n    diff_vec = xi_b - yj_b\n    \n    # Distance matrix r_ij, shape: (N, N)\n    r_ij = np.linalg.norm(diff_vec, axis=2)\n    \n    # Normal vectors n_y at yj, shape: (1, N, 2)\n    ny_j_b = yj_b / a\n    \n    # Dot product (xi - yj) . n_yj, shape: (N, N)\n    dot_prod = np.sum(diff_vec * ny_j_b, axis=2)\n    \n    # Kernel K(theta_i, theta_j) for i != j\n    # Suppress warnings for division by zero on the diagonal (r_ij=0)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        kernel_val = (1j * k / 4) * hankel1(1, k * r_ij) * (dot_prod / r_ij)\n    \n    # Construct matrix A\n    A = w * kernel_val\n    np.fill_diagonal(A, s) # A_ii = s\n\n    # 3. Assemble RHS vector g using oversampling (vectorized)\n    M = alpha * N\n    theta_prime = 2 * np.pi * (np.arange(M) + 0.5) / M\n    w_prime = 2 * np.pi * a / M\n\n    # Oversampled source points y' and normals n'\n    y_prime_pts = a * np.stack((np.cos(theta_prime), np.sin(theta_prime)), axis=1)\n    n_prime_pts = y_prime_pts / a\n\n    # Manufactured density at oversampled points\n    phi_prime = np.exp(1j * 3 * theta_prime) + 0.5 * np.exp(-1j * 2 * theta_prime)\n\n    # Vectorize computation over all (i, m) pairs\n    # xi_g_b: (N, 1, 2), y_prime_b: (1, M, 2)\n    y_prime_b = y_prime_pts[np.newaxis, :, :]\n    n_prime_b = n_prime_pts[np.newaxis, :, :]\n    \n    # Vector from source y' to target x, shape: (N, M, 2)\n    diff_vec_g = xi_b - y_prime_b\n    # Distances r_im, shape: (N, M)\n    r_im = np.linalg.norm(diff_vec_g, axis=2)\n    # Dot product, shape: (N, M)\n    dot_prod_g = np.sum(diff_vec_g * n_prime_b, axis=2)\n    \n    # Kernel matrix K(theta_i, theta'_m), shape: (N, M)\n    kernel_g_mat = (1j * k / 4) * hankel1(1, k * r_im) * (dot_prod_g / r_im)\n    \n    # Integral part by summing over m for each i, shape: (N,)\n    integral_part = np.sum(w_prime * kernel_g_mat * phi_prime, axis=1)\n    \n    # Assemble g\n    g = s * phi_exact_at_theta + integral_part\n        \n    # 4. Solve the linear system\n    phi_hat = np.linalg.solve(A, g)\n    \n    # 5. Compute the relative l2 error\n    # The weight w cancels in the relative error formula.\n    error_num = np.linalg.norm(phi_hat - phi_exact_at_theta)\n    error_den = np.linalg.norm(phi_exact_at_theta)\n    \n    if error_den == 0:\n        return 0.0 if error_num == 0 else np.inf\n        \n    return error_num / error_den\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}