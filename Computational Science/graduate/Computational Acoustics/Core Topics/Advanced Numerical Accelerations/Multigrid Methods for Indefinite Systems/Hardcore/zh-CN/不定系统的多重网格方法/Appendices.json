{
    "hands_on_practices": [
        {
            "introduction": "局部傅里叶分析 (Local Fourier Analysis, LFA) 是预测多重网格方法性能的核心理论工具。本练习将通过 LFA 揭示为何标准光滑器（如加权雅可比法）对于不定亥姆霍兹方程无效。通过推导和计算，你将亲眼看到在特定波数下，光滑因子的数值将大于1，这直接证明了误差放大而非衰减。",
            "id": "4130263",
            "problem": "考虑自由空间中的一维时谐线性声学问题，其频域压力满足亥姆霍兹方程：$-\\frac{\\mathrm{d}^{2}u}{\\mathrm{d}x^{2}} - k^{2} u = f$，该方程由线性状态下的质量和动量守恒导出。其中，$u$是声压幅值，$k$是波数，$f$是源项。使用二阶中心差分对二阶导数进行离散化，将算子离散在间距为$h$的无限均匀网格上。将得到的离散算子记为$A_{h}$，作用于网格函数$\\{u_{i}\\}_{i \\in \\mathbb{Z}}$。假设双网格方法使用一次预平滑和一次后平滑步骤，光滑器为加权雅可比法，权重为$\\omega = \\frac{2}{3}$，以及理想的粗网格校正，该校正能精确消除细网格角度$|\\theta| \\leq \\frac{\\pi}{2}$的傅里叶模式所张成的子空间中的低频误差分量。在局部傅里叶分析（LFA）框架下（局部傅里叶分析（LFA）使用平面波误差模式和算子符号来预测多重网格的性能），最坏情况下的双网格收敛因子定义为单步加权雅可比平滑符号的模平方在高频集$\\frac{\\pi}{2} \\leq \\theta \\leq \\pi$上的上确界。\n\n从以下基础出发：\n- 二阶导数的二阶中心有限差分近似。\n- 亥姆霍兹算子及其在无限均匀网格上的离散符号的定义。\n- 从对角分裂$A_{h} = D - (L + U)$和光滑器$S = I - \\omega D^{-1} A_{h}$推导出的加权雅可比光滑形式。\n\n推导离散亥姆霍兹符号$a(\\theta)$、对角符号$d$和加权雅可比平滑符号$s(\\theta)$，用无量纲参数$q = k h$表示。然后，使用上述理想化的双网格LFA假设，将最坏情况下的双网格收敛因子表示为$\\sup_{\\theta \\in [\\pi/2,\\pi]} |s(\\theta)|^{2}$。对于指定的参数$q = 1.6$和$\\omega = \\frac{2}{3}$，精确计算该上确界。\n\n你的最终答案必须是单一的最坏情况双网格收敛因子，表示为一个精确的有理数。不需要四舍五入，也不需要单位。",
            "solution": "在进行求解之前，对问题进行验证。\n\n### 第一步：提取已知条件\n-   **控制方程**：一维时谐线性声学压力$u$满足亥姆霍兹方程：$-\\frac{\\mathrm{d}^{2}u}{\\mathrm{d}x^{2}} - k^{2} u = f$。\n-   **离散化**：使用二阶中心差分对二阶导数进行离散化，将算子离散在间距为$h$的无限均匀网格上。\n-   **离散算子**：离散算子记为$A_h$。\n-   **双网格方法**：该方法采用一次预平滑和一次后平滑步骤。\n-   **光滑器**：光滑器为加权雅可比法，权重为$\\omega = \\frac{2}{3}$。\n-   **光滑器**：光滑器定义为$S = I - \\omega D^{-1} A_{h}$，从分裂$A_h = D - (L+U)$导出。\n-   **粗网格校正**：校正被假定为理想的，能精确消除傅里叶模式中细网格角度$|\\theta| \\leq \\frac{\\pi}{2}$的误差分量。\n-   **分析框架**：使用局部傅里叶分析（LFA）。\n-   **待计算量**：最坏情况下的双网格收敛因子定义为$\\sup_{\\theta \\in [\\pi/2,\\pi]} |s(\\theta)|^{2}$，其中$s(\\theta)$是单步加权雅可比平滑符号。\n-   **参数**：无量纲参数为$q = kh$，其指定值为$q=1.6$。\n\n### 第二步：使用提取的已知条件进行验证\n-   **科学基础**：该问题基于亥姆霍兹方程（波物理学的基石），并采用了标准的数值方法（有限差分、多重网格、加权雅可比法）和分析工具（局部傅里叶分析）。整个框架在科学上和数学上都是合理的。\n-   **适定性**：该问题是适定的。它要求基于一套完整的初始数据、参数和定义来计算一个特定的、明确定义的量（最坏情况下的平滑因子）。\n-   **客观性**：该问题以精确、客观和形式化的数学语言陈述，没有任何主观性或模糊性。\n-   **完整性与一致性**：该问题提供了所有必要的信息：微分方程、离散化方案、多重网格组件（光滑器、权重、理想校正）、分析方法（LFA）以及所有需要的数值参数（$\\omega$、$q$）。不存在矛盾。\n\n### 第三步：结论与行动\n该问题是有效的。将提供一个完整、有理有据的解答。\n\n### 求解推导\n求解过程首先推导离散亥姆霍兹算子的符号，然后是加权雅可比光滑器的符号，最后在指定的频率范围内计算其模平方的上确界。\n\n一维亥姆霍兹算子由$A = -\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2} - k^2$给出。\n在间距为$h$的均匀网格上，对二阶导数使用二阶中心有限差分，离散算子$A_h$在网格点$i$处作用于网格函数$\\{u_i\\}_{i \\in \\mathbb{Z}}$的结果是：\n$$ (A_h u)_i = -\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} - k^2 u_i $$\n我们可以将其重写为应用于点$i$的模板：\n$$ (A_h u)_i = \\frac{1}{h^2} \\left( -u_{i+1} + (2 - k^2 h^2)u_i - u_{i-1} \\right) $$\n\n为了进行局部傅里叶分析（LFA），我们分析算子$A_h$对傅里叶模式$u_j = \\exp(ij\\theta)$的作用，其中$\\theta \\in [-\\pi, \\pi]$是傅里叶角。算子$A_h$的符号$a(\\theta)$由关系式$(A_h \\exp(ij\\theta))_j = a(\\theta) \\exp(ij\\theta)$定义。\n$$ a(\\theta) = \\frac{1}{h^2} \\left( -e^{i\\theta} + (2 - k^2 h^2) - e^{-i\\theta} \\right) $$\n使用欧拉公式$e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$，符号变为：\n$$ a(\\theta) = \\frac{1}{h^2} \\left( 2 - 2\\cos(\\theta) - k^2 h^2 \\right) $$\n使用半角恒等式$1 - \\cos(\\theta) = 2\\sin^2(\\frac{\\theta}{2})$和给定的无量纲参数$q=kh$：\n$$ a(\\theta) = \\frac{1}{h^2} \\left( 4\\sin^2\\left(\\frac{\\theta}{2}\\right) - q^2 \\right) $$\n这是离散亥姆霍兹算子$A_h$的符号。\n\n加权雅可比法基于分裂$A_h = D - (L+U)$，其中$D$是$A_h$的对角部分。从模板可知，对角算子$D$由$(Du)_i = \\frac{1}{h^2}(2 - q^2)u_i$给出。$D$的符号，记为$d$，是常系数：\n$$ d = \\frac{1}{h^2}(2 - q^2) $$\n\n加权雅可比光滑器为$S = I - \\omega D^{-1} A_h$。其符号$s(\\theta)$由下式给出：\n$$ s(\\theta) = 1 - \\omega \\frac{a(\\theta)}{d} $$\n代入$a(\\theta)$和$d$的表达式：\n$$ s(\\theta) = 1 - \\omega \\frac{\\frac{1}{h^2} \\left( 4\\sin^2\\left(\\frac{\\theta}{2}\\right) - q^2 \\right)}{\\frac{1}{h^2}(2 - q^2)} = 1 - \\omega \\frac{4\\sin^2\\left(\\frac{\\theta}{2}\\right) - q^2}{2 - q^2} $$\n这是平滑符号的一般表达式。\n\n给定具体参数$\\omega = \\frac{2}{3}$和$q = 1.6$。我们将使用精确的有理数运算。\n$q = 1.6 = \\frac{16}{10} = \\frac{8}{5}$。\n$q^2 = \\left(\\frac{8}{5}\\right)^2 = \\frac{64}{25}$。\n分数中的分母是$2 - q^2 = 2 - \\frac{64}{25} = \\frac{50 - 64}{25} = -\\frac{14}{25}$。\n将这些值代入$s(\\theta)$的表达式中：\n$$ s(\\theta) = 1 - \\frac{2}{3} \\frac{4\\sin^2\\left(\\frac{\\theta}{2}\\right) - \\frac{64}{25}}{-\\frac{14}{25}} $$\n$$ s(\\theta) = 1 + \\left(\\frac{2}{3}\\right) \\left(\\frac{25}{14}\\right) \\left(4\\sin^2\\left(\\frac{\\theta}{2}\\right) - \\frac{64}{25}\\right) $$\n$$ s(\\theta) = 1 + \\frac{25}{21} \\left(4\\sin^2\\left(\\frac{\\theta}{2}\\right) - \\frac{64}{25}\\right) $$\n$$ s(\\theta) = 1 + \\frac{100}{21}\\sin^2\\left(\\frac{\\theta}{2}\\right) - \\frac{25}{21}\\frac{64}{25} $$\n$$ s(\\theta) = 1 + \\frac{100}{21}\\sin^2\\left(\\frac{\\theta}{2}\\right) - \\frac{64}{21} $$\n$$ s(\\theta) = \\frac{21 - 64}{21} + \\frac{100}{21}\\sin^2\\left(\\frac{\\theta}{2}\\right) = \\frac{1}{21}\\left(100\\sin^2\\left(\\frac{\\theta}{2}\\right) - 43\\right) $$\n\n题目要求计算最坏情况下的双网格收敛因子，其定义为$|s(\\theta)|^2$在高频范围$\\theta \\in [\\frac{\\pi}{2}, \\pi]$上的上确界。\n令$x = \\sin^2(\\frac{\\theta}{2})$。当$\\theta$在区间$[\\frac{\\pi}{2}, \\pi]$内变化时，其参数$\\frac{\\theta}{2}$在$[\\frac{\\pi}{4}, \\frac{\\pi}{2}]$内变化。\n在此区间上，$\\sin(\\frac{\\theta}{2})$是一个单调递增函数。\n最小值为$\\sin(\\frac{\\pi}{4}) = \\frac{\\sqrt{2}}{2}$，最大值为$\\sin(\\frac{\\pi}{2}) = 1$。\n因此，变量$x = \\sin^2(\\frac{\\theta}{2})$在区间$[(\\frac{\\sqrt{2}}{2})^2, 1^2] = [\\frac{2}{4}, 1] = [\\frac{1}{2}, 1]$内变化。\n\n我们需要找到$|f(x)|^2$在$x \\in [\\frac{1}{2}, 1]$上的上确界，其中$f(x) = \\frac{1}{21}(100x - 43)$。\n函数$f(x)$是关于$x$的线性函数，斜率为正（$m = \\frac{100}{21}$）。因此，它在其定义域上是单调递增的。$f(x)$在区间$[\\frac{1}{2}, 1]$上的极值必定出现在端点处。\n在$x = \\frac{1}{2}$处（对应于$\\theta = \\frac{\\pi}{2}$）：\n$$ f\\left(\\frac{1}{2}\\right) = \\frac{1}{21}\\left(100 \\cdot \\frac{1}{2} - 43\\right) = \\frac{1}{21}(50 - 43) = \\frac{7}{21} = \\frac{1}{3} $$\n在$x = 1$处（对应于$\\theta = \\pi$）：\n$$ f(1) = \\frac{1}{21}(100 \\cdot 1 - 43) = \\frac{57}{21} = \\frac{19 \\times 3}{7 \\times 3} = \\frac{19}{7} $$\n由于$f(x)$在区间$x \\in [\\frac{1}{2}, 1]$上从$\\frac{1}{3}$单调递增到$\\frac{19}{7}$，因此该函数始终为正。所以，$|f(x)| = f(x)$。\n$|f(x)|$在该区间上的最大值在$x=1$处取得，为$\\frac{19}{7}$。\n所求量是$|s(\\theta)|^2 = |f(x)|^2$的上确界，即$|f(x)|$最大值的平方。\n$$ \\sup_{\\theta \\in [\\pi/2, \\pi]} |s(\\theta)|^2 = \\left(\\frac{19}{7}\\right)^2 = \\frac{19^2}{7^2} = \\frac{361}{49} $$\n最坏情况下的双网格收敛因子是$\\frac{361}{49}$。",
            "answer": "$$\\boxed{\\frac{361}{49}}$$"
        },
        {
            "introduction": "在上一个练习中，我们运用了基于无限周期域假设的理想化 LFA 模型。本练习旨在连接理论与实践，探讨有限计算域和特定边界条件（如狄利克雷边界）带来的影响。你将通过计算理论预测值、数值实验测量值以及一个考虑了边界影响的“修正”预测值，来深入理解理想模型与实际计算之间的差异。",
            "id": "4130317",
            "problem": "考虑由齐次亥姆霍兹算子控制的一维时间谐波声学问题。在有限区间上的连续形式中，控制方程为 $$-\\frac{d^2 u}{dx^2} - k^2 u = f,$$ 其中 $u$ 是声场，$k$ 是波数（单位为 $\\mathrm{rad/m}$），$f$ 是源项。在长度为 $L$ 的域上，对具有 $n$ 个内部点的均匀网格，采用标准的二阶中心差分格式，并施加齐次狄利克雷边界条件（边界值为零），得到作用于网格值向量的离散算子。设网格间距为 $$h = \\frac{L}{n+1}.$$ 通过三对角模板定义缩放的离散亥姆霍兹算子矩阵 $$A \\in \\mathbb{R}^{n \\times n}$$：$$A_{j,j} = 2 - (k h)^2,\\quad A_{j,j-1} = -1,\\quad A_{j,j+1} = -1$$ 其中 $j \\in \\{1,\\dots,n\\}$，并约定超出范围的项被丢弃，这与齐次狄利克雷边界条件一致。这种缩放形式吸收了因子 $h^{-2}$，从而使三对角线上的元素变为无量纲。\n\n在多重网格方法中，使用诸如阻尼雅可比之类的松弛格式作为光滑器。阻尼雅可比迭代通过以下方式更新当前近似解：$$x \\leftarrow x + \\omega D^{-1}(b - A x),$$ 其中 $$D = \\operatorname{diag}(A)$$ 且 $\\omega \\in (0,2)$ 是阻尼参数。相应的误差传播算子为 $$E = I - \\omega D^{-1} A.$$ 局部傅里叶分析 (LFA) 通过分析无限周期网格上的符号来预测光滑性能。对于上述三对角模板，算子的 LFA 符号为 $$a(\\theta) = \\left(2 - (k h)^2\\right) - 2 \\cos(\\theta),$$ 阻尼雅可比的误差传播符号为 $$e(\\theta) = 1 - \\omega \\frac{a(\\theta)}{2 - (k h)^2} = 1 - \\omega + \\omega \\frac{2 \\cos(\\theta)}{2 - (k h)^2},$$ 其中 $\\theta$ 的单位是弧度。单步松弛的 LFA 光滑因子预测值为 $$\\rho_{\\mathrm{LFA}} = \\max_{\\theta \\in [0,\\pi]} \\left| e(\\theta) \\right|.$$\n\n在具有齐次狄利克雷边界条件和 $n$ 个内部点的有限网格上，离散算子 $$A$$ 可在离散正弦模基下对角化。容许波数为 $$\\theta_m = \\frac{\\pi m}{n+1}, \\quad m \\in \\{1,2,\\dots,n\\},$$ 阻尼雅可比对应的精确模态放大率为 $$e_{\\mathrm{sine}}(\\theta_m) = 1 - \\omega \\frac{\\left(2 - (k h)^2\\right) - 2 \\cos(\\theta_m)}{2 - (k h)^2}.$$ 有限网格上的测量光滑因子是 $$E$$ 的谱半径，等价地 $$\\rho_{\\mathrm{meas}} = \\max_{m \\in \\{1,\\dots,n\\}} \\left| e_{\\mathrm{sine}}(\\theta_m) \\right|.$$ LFA 的边界感知调和方法通过将连续周期谱替换为离散集合 $$\\{\\theta_m\\}_{m=1}^n$$ 来得到 $$\\rho_{\\mathrm{rec}} = \\max_{m \\in \\{1,\\dots,n\\}} \\left| e_{\\mathrm{sine}}(\\theta_m) \\right|,$$ 对于这种托普利茨-狄利克雷情况，该值在数值精度范围内与 $$\\rho_{\\mathrm{meas}}$$ 相匹配。\n\n任务：编写一个完整的、可运行的程序，针对下面指定的测试套件，计算并报告每种情况下的以下量：\n- LFA 光滑因子预测值 $$\\rho_{\\mathrm{LFA}}$$，计算方式为 $$\\max_{\\theta \\in [0,\\pi]} \\left| e(\\theta) \\right|$$，其中 $\\theta$ 的单位是弧度。\n- 有限网格上的测量光滑因子 $$\\rho_{\\mathrm{meas}}$$，计算方式为在 $n$ 点狄利克雷网格上 $$E = I - \\omega D^{-1} A$$ 的谱半径。\n- 边界感知的调和预测值 $$\\rho_{\\mathrm{rec}}$$，计算方式为 $$\\max_{m=1,\\dots,n} \\left| e_{\\mathrm{sine}}(\\theta_m) \\right|.$$\n\n所有输出均为无量纲。角度必须以弧度处理。您的数值程序必须通过在 $$[0,\\pi]$$ 上对足够密集的 $\\theta$ 值集合进行采样来评估 $$\\rho_{\\mathrm{LFA}}$$，并且必须通过对 $$E$$ 进行特征值分析来计算 $$\\rho_{\\mathrm{meas}}$$。所有结果均四舍五入至 $6$ 位小数。\n\n测试套件：\n- 情况 $1$ (一般“常规路径”)：$$n = 64,\\; L = 1\\,\\mathrm{m},\\; k = 40\\,\\mathrm{rad/m},\\; \\omega = 0.6.$$\n- 情况 $2$ (近不定性对角减弱)：$$n = 64,\\; L = 1\\,\\mathrm{m},\\; k = 91\\,\\mathrm{rad/m},\\; \\omega = 0.6.$$\n- 情况 $3$ (小网格非周期性加剧)：$$n = 15,\\; L = 1\\,\\mathrm{m},\\; k = 40\\,\\mathrm{rad/m},\\; \\omega = 0.6.$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $$[\\rho_{\\mathrm{LFA}}^{(1)}, \\rho_{\\mathrm{meas}}^{(1)}, \\rho_{\\mathrm{rec}}^{(1)}, \\rho_{\\mathrm{LFA}}^{(2)}, \\rho_{\\mathrm{meas}}^{(2)}, \\rho_{\\mathrm{rec}}^{(2)}, \\rho_{\\mathrm{LFA}}^{(3)}, \\rho_{\\mathrm{meas}}^{(3)}, \\rho_{\\mathrm{rec}}^{(3)}],$$ 其中上标 $({i})$ 表示情况 $i$。每个条目都必须是四舍五入到 $6$ 位小数的浮点数。",
            "solution": "该问题是有效的，因为它具有科学依据、提法恰当且目标明确。它提出了一个偏微分方程数值分析中的标准任务，具体涉及多重网格光滑器在亥姆霍兹方程上的性能。所有定义、参数和目标都陈述得清晰正确。\n\n目标是计算一维亥姆霍兹方程的阻尼雅可比松弛离散化的三个相关但不同的光滑因子，该方程为\n$$-\\frac{d^2 u}{dx^2} - k^2 u = f$$\n定义在长度为 $L$ 的域上，并带有齐次狄利克雷边界条件。该离散化使用 $n$ 个内部点，网格间距为 $h = \\frac{L}{n+1}$。得到的线性系统涉及一个缩放的无量纲矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其模板为 $[-1, 2-(kh)^2, -1]$。阻尼雅可比误差传播算子是 $E = I - \\omega D^{-1} A$，其中 $D = \\operatorname{diag}(A)$，$\\omega$ 是阻尼参数。\n\n我们将为每个测试用例计算以下内容：\n1.  局部傅里叶分析 (LFA) 光滑因子，$\\rho_{\\mathrm{LFA}}$。\n2.  有限网格上的测量光滑因子，$\\rho_{\\mathrm{meas}}$。\n3.  边界感知的调和 LFA 预测值，$\\rho_{\\mathrm{rec}}$。\n\n对于给定的参数集 $\\{n, L, k, \\omega\\}$，我们首先定义必要的派生常数。\n网格间距为 $h = \\frac{L}{n+1}$。\n矩阵 $A$ 的对角元素为 $A_{j,j} = d = 2 - (k h)^2$。非对角元素为 $A_{j,j\\pm1} = -1$。\n因此，对角矩阵 $D$ 为 $d \\cdot I$，其中 $I$ 是单位矩阵。\n\n**1. LFA 光滑因子 $\\rho_{\\mathrm{LFA}}$ 的计算**\n\nLFA 放大因子，即误差传播算子 $E$ 的符号，由下式给出\n$$e(\\theta) = 1 - \\omega \\frac{a(\\theta)}{2 - (k h)^2} = 1 - \\omega + \\omega \\frac{2 \\cos(\\theta)}{2 - (k h)^2}$$\n其中 $\\theta \\in [0, \\pi]$ 是傅里叶模的波数。\nLFA 光滑因子是该符号在所有相关频率上的最大模值：\n$$\\rho_{\\mathrm{LFA}} = \\max_{\\theta \\in [0,\\pi]} \\left| e(\\theta) \\right|$$\n函数 $e(\\theta)$ 是关于 $\\cos(\\theta)$ 的线性函数。当 $\\theta$ 在紧区间 $[0, \\pi]$ 上变化时，$\\cos(\\theta)$ 在 $[-1, 1]$ 上变化。线性函数在闭区间上的绝对值的最大值必然出现在端点之一。因此，我们只需要在 $\\theta=0$（此时 $\\cos(\\theta)=1$）和 $\\theta=\\pi$（此时 $\\cos(\\theta)=-1$）处评估 $e(\\theta)$。\n$$e(0) = 1 - \\omega + \\frac{2 \\omega}{2 - (k h)^2}$$\n$$e(\\pi) = 1 - \\omega - \\frac{2 \\omega}{2 - (k h)^2}$$\n$$\\rho_{\\mathrm{LFA}} = \\max\\left( \\left| e(0) \\right|, \\left| e(\\pi) \\right| \\right)$$\n这种解析方法是精确的，并且比在密集的 $\\theta$ 值集合上进行数值搜索更有效。\n\n**2. 测量光滑因子 $\\rho_{\\mathrm{meas}}$ 的计算**\n\n有限网格上的测量光滑因子是误差传播矩阵 $E = I - \\omega D^{-1} A$ 的谱半径。\n$$\\rho_{\\mathrm{meas}} = \\rho(E) = \\max_j |\\lambda_j(E)|$$\n其中 $\\lambda_j(E)$ 是 $E$ 的特征值。为计算该值，我们首先构建 $n \\times n$ 矩阵 $A$：\n$$A = \\begin{pmatrix} d  -1    \\\\ -1  d  -1   \\\\  \\ddots  \\ddots  \\ddots  \\\\   -1  d  -1 \\\\    -1  d \\end{pmatrix}, \\quad d = 2-(kh)^2$$\n然后我们构建 $E = I - \\frac{\\omega}{d} A$ 并数值计算其特征值。其绝对值的最大值即为 $\\rho_{\\mathrm{meas}}$。\n\n**3. 调和预测值 $\\rho_{\\mathrm{rec}}$ 的计算**\n\n调和预测通过使用有限网格上齐次狄利克雷边界条件所容许的离散波数集来调整 LFA。这些波数是：\n$$\\theta_m = \\frac{\\pi m}{n+1}, \\quad m \\in \\{1, 2, \\dots, n\\}$$\n对每个离散模态的预测放大率为：\n$$e_{\\mathrm{sine}}(\\theta_m) = 1 - \\omega \\frac{(2 - (k h)^2) - 2 \\cos(\\theta_m)}{2 - (k h)^2} = 1 - \\omega + \\omega \\frac{2 \\cos(\\theta_m)}{2 - (k h)^2}$$\n调和光滑因子是这些放大因子在所有容许模态上的最大值：\n$$\\rho_{\\mathrm{rec}} = \\max_{m \\in \\{1,\\dots,n\\}} \\left| e_{\\mathrm{sine}}(\\theta_m) \\right|$$\n正如问题正确指出的，对于这个特定情况（均匀网格上的狄利克雷边界条件的一维拉普拉斯算子），一个众所周知的结果是 $E$ 的特征值恰好是 $e_{\\mathrm{sine}}(\\theta_m)$ 的值。因此，$\\rho_{\\mathrm{rec}}$ 的计算在解析上等同于 $E$ 的特征值计算，我们预期 $\\rho_{\\mathrm{meas}} = \\rho_{\\mathrm{rec}}$ 在数值精度范围内成立。我们的计算将通过两种不同的方法来验证这一点：对 $\\rho_{\\mathrm{meas}}$ 进行直接的特征值计算，以及对 $\\rho_{\\mathrm{rec}}$ 使用解析公式进行求值。\n\n我们现在将此过程应用于每个测试用例。\n\n**情况 1：$n = 64, L = 1\\,\\mathrm{m}, k = 40\\,\\mathrm{rad/m}, \\omega = 0.6$**\n- $h = 1/(64+1) = 1/65\\,\\mathrm{m}$\n- $(kh)^2 = (40/65)^2 = (8/13)^2 = 64/169 \\approx 0.3787$\n- $d = 2 - 64/169 = 274/169 \\approx 1.6213$\n- $e(0) = 1 - 0.6 + 0.6 \\frac{2}{274/169} = 0.4 + 1.2 \\frac{169}{274} \\approx 1.140146$\n- $e(\\pi) = 0.4 - 1.2 \\frac{169}{274} \\approx -0.340146$\n- $\\rho_{\\mathrm{LFA}} = \\max(|1.140146|, |-0.340146|) = 1.140146$\n- $\\rho_{\\mathrm{meas}}$ 和 $\\rho_{\\mathrm{rec}}$ 将进行数值计算；我们预期它们会略小于 $\\rho_{\\mathrm{LFA}}$，因为离散网格未采样 $\\theta=0$。\n\n**情况 2：$n = 64, L = 1\\,\\mathrm{m}, k = 91\\,\\mathrm{rad/m}, \\omega = 0.6$**\n- $h = 1/65\\,\\mathrm{m}$\n- $(kh)^2 = (91/65)^2 = (1.4)^2 = 1.96$\n- $d = 2 - 1.96 = 0.04$ (算子接近奇异)\n- $e(0) = 1 - 0.6 + \\frac{2 \\times 0.6}{0.04} = 0.4 + 30 = 30.4$\n- $e(\\pi) = 0.4 - 30 = -29.6$\n- $\\rho_{\\mathrm{LFA}} = \\max(|30.4|, |-29.6|) = 30.4$\n\n**情况 3：$n = 15, L = 1\\,\\mathrm{m}, k = 40\\,\\mathrm{rad/m}, \\omega = 0.6$**\n- $h = 1/(15+1) = 1/16\\,\\mathrm{m}$\n- $(kh)^2 = (40/16)^2 = (2.5)^2 = 6.25$\n- $d = 2 - 6.25 = -4.25$ (算子是不定的)\n- $e(0) = 1 - 0.6 + \\frac{2 \\times 0.6}{-4.25} = 0.4 - \\frac{1.2}{4.25} \\approx 0.117647$\n- $e(\\pi) = 0.4 + \\frac{1.2}{4.25} \\approx 0.682353$\n- $\\rho_{\\mathrm{LFA}} = \\max(|0.117647|, |0.682353|) = 0.682353$\n\n数值实现将执行这些计算，并为每种情况确认 $\\rho_{\\mathrm{meas}}$ 和 $\\rho_{\\mathrm{rec}}$ 的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and reports smoothing factors for a discretized 1D Helmholtz\n    operator using damped Jacobi relaxation for three test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, L, k, omega)\n        (64, 1.0, 40.0, 0.6), # Case 1\n        (64, 1.0, 91.0, 0.6), # Case 2\n        (15, 1.0, 40.0, 0.6), # Case 3\n    ]\n\n    results = []\n    for n, L, k, omega in test_cases:\n        # Calculate derived parameters\n        h = L / (n + 1)\n        kh2 = (k * h)**2\n        diag_val = 2.0 - kh2\n\n        # 1. Calculate the LFA smoothing factor (rho_LFA)\n        # The LFA amplification factor e(theta) is linear in cos(theta).\n        # Its maximum magnitude on theta in [0, pi] must occur at the\n        # endpoints theta=0 or theta=pi.\n        # e(theta) = 1 - omega + omega * 2*cos(theta) / diag_val\n        \n        # This check is for robustness, though not strictly needed for the given test cases.\n        if diag_val == 0:\n            # If diag_val is zero, the Jacobi iteration is undefined.\n            # LFA symbol would be infinite.\n            rho_lfa = np.inf\n        else:\n            e_0 = 1.0 - omega + omega * 2.0 * np.cos(0) / diag_val\n            e_pi = 1.0 - omega + omega * 2.0 * np.cos(np.pi) / diag_val\n            rho_lfa = max(abs(e_0), abs(e_pi))\n        \n        # 2. Calculate the measured smoothing factor (rho_meas)\n        # This is the spectral radius of the error propagation matrix E = I - omega * D^-1 * A.\n        \n        # Construct the matrix A\n        A = np.diag(np.full(n, diag_val)) + \\\n            np.diag(np.full(n - 1, -1.0), k=1) + \\\n            np.diag(np.full(n - 1, -1.0), k=-1)\n        \n        # Construct the error propagation matrix E\n        if diag_val == 0:\n            # If diag_val is zero, D is singular.\n            # The spectral radius is considered infinite.\n            rho_meas = np.inf\n        else:\n            E = np.identity(n) - (omega / diag_val) * A\n            \n            # Compute the spectral radius of E\n            eigenvalues_E = np.linalg.eigvals(E)\n            rho_meas = np.max(np.abs(eigenvalues_E))\n\n        # 3. Calculate the boundary-aware reconciled prediction (rho_rec)\n        # This uses the discrete wavenumbers for the finite grid.\n        m = np.arange(1, n + 1)\n        thetas_m = (np.pi * m) / (n + 1)\n        \n        if diag_val == 0:\n            rho_rec = np.inf\n        else:\n            # e_sine(theta_m) = 1 - omega * (diag_val - 2*cos(theta_m)) / diag_val\n            # Simplified: e_sine(theta_m) = 1 - omega + omega * 2*cos(theta_m) / diag_val\n            e_sine_values = 1.0 - omega + (omega * 2.0 * np.cos(thetas_m)) / diag_val\n            rho_rec = np.max(np.abs(e_sine_values))\n\n        results.extend([rho_lfa, rho_meas, rho_rec])\n\n    # Final print statement in the exact required format.\n    # The map applies the rounding and formatting to each result.\n    formatted_results = map(lambda x: f\"{x:.6f}\", results)\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在分析了简单光滑器的失效原因并理解了理论与实践的差异后，我们转向构建一个有效的解决方案。本练习介绍了一种处理不定系统的强大技术——多项式光滑器。你将学习如何设计一个切比雪夫多项式光滑器，使其专门针对亥姆霍兹算子谱的特定环形区域进行优化，从而掌握在简单方法失效时工程化一个保证收敛的数值组件的关键技能。",
            "id": "4130235",
            "problem": "考虑时谐线性声学，其中声压场满足由声波方程推导出的亥姆霍兹方程。从声波方程 $\\,\\partial_t^2 p - c^2 \\Delta p = s\\,$ 出发，并假设形式为 $\\,p(\\mathbf{x},t) = \\Re\\{u(\\mathbf{x}) e^{-i \\omega t}\\}\\,$ 的时谐场，控制方程简化为亥姆霍兹方程 $\\,(-\\Delta - k^2) u = f\\,$，其中 $\\,k = \\omega/c\\,$ 是波数，$\\,\\Delta\\,$ 是拉普拉斯算子，$\\,f\\,$ 是源项。在使用合适的边界条件（例如，吸收层）在网格上进行离散化之后，得到的解 $\\,\\mathbf{u}\\,$ 的线性系统为 $\\,A \\mathbf{u} = \\mathbf{f}\\,$，其中 $\\,A \\in \\mathbb{C}^{N \\times N}\\,$ 是不定的，并且可能是非正规的。在计算声学的许多实际配置中，$\\,A\\,$ 的谱可以很好地由复平面上的一个环域 $\\,\\mathcal{A} = \\{\\lambda \\in \\mathbb{C} : r_{\\min} \\le |\\lambda| \\le r_{\\max}\\}\\,$ 来近似，其中 $\\,r_{\\min}  0\\,$ 且 $\\,r_{\\max}  r_{\\min}\\,$。\n\n为了为此类不定系统构建一个鲁棒的多重网格光滑器，可以作用于正规方程 $\\,H = A^* A\\,$，在假设 $\\,A\\,$ 在相关子空间上是满秩的情况下，该方程是厄米半正定的。如果 $\\,A\\,$ 的谱位于环域 $\\,\\mathcal{A}\\,$ 内，那么 $\\,H\\,$ 的谱位于实数区间 $\\,[\\alpha,\\beta]\\,$ 内，其中 $\\,\\alpha = r_{\\min}^2\\,$ 且 $\\,\\beta = r_{\\max}^2\\,$。然后可以设计一个多项式光滑器 $\\,p_n(H)\\,$，其中 $\\,p_n\\,$ 是一个 $n$ 阶多项式，其选择旨在减少与特征值 $\\,\\mu \\in [\\alpha,\\beta]\\,$ 相关的误差分量。\n\n您的任务是构造一个复值切比雪夫多项式光滑器 $\\,p_n(H)\\,$，它在谱区间 $\\,\\mu \\in [\\alpha,\\beta]\\,$ 上提供保证的衰减。具体来说，您必须：\n\n1. 从第一类切比雪夫多项式 $\\,T_n(x)\\,$ 的经过充分检验的性质（该多项式在区间 $\\,[-1,1]\\,$ 上最小化最大偏差）以及从 $\\,A\\,$ 的环状谱模型产生的 $\\,H\\,$ 到实数区间 $\\,[\\alpha,\\beta]\\,$ 的谱映射出发。仅使用这些基本依据，推导一个关于标量变量 $\\,\\mu\\,$ 的多项式 $\\,p_n(\\mu)\\,$，使得在归一化条件 $\\,p_n(0) = 1\\,$ 的约束下，$\\,\\max_{\\mu \\in [\\alpha,\\beta]} |p_n(\\mu)|\\,$ 被最小化。将 $\\,p_n(\\mu)\\,$ 显式地表示为 $\\,\\mu\\,$ 的幂的多项式，即 $\\,p_n(\\mu) = \\sum_{j=0}^{n} c_j \\mu^j\\,$，并阐明为强制 $\\,p_n(0) = 1\\,$ 所需的归一化。\n\n2. 基于切比雪夫多项式的极小化极大性质和合适的仿射映射（该映射将谱区间 $\\,\\mu \\in [\\alpha,\\beta]\\,$ 变换到 $\\,x \\in [-1,1]\\,$），推导出一个保证目标衰减因子 $\\,\\delta \\in (0,1)\\,$（即 $\\,\\max_{\\mu \\in [\\alpha,\\beta]} |p_n(\\mu)| \\le \\delta\\,$）的最小阶数 $\\,n\\,$ 的显式判据。您的推导必须基于第一性原理以及关于参数 $\\,x > 1\\,$ 时 $\\,T_n(x)\\,$ 的经过充分检验的事实。\n\n3. 实现一个完整的、可运行的程序，该程序：\n   - 对下面的每个测试用例，计算保证目标衰减 $\\,\\delta\\,$ 的最小多项式阶数 $\\,n\\,$。\n   - 构造 $\\,p_n(\\mu)\\,$（表示为 $\\,\\mu\\,$ 的幂）的归一化多项式系数 $\\,\\{c_j\\}_{j=0}^n\\,$。\n   - 将所有测试用例的结果作为单行返回，格式严格遵循由方括号括起来的逗号分隔列表，其中每个测试用例的结果形式为 $\\, [n,[c_0,c_1,\\dots,c_n]]\\,$。\n\n您必须使用 $\\,\\mu\\,$ 的幂次展开和从 $\\,\\mu$ 到切比雪夫参数的仿射映射来实现多项式构造，并且必须通过适当的归一化来强制 $\\,p_n(0) = 1\\,$。\n\n测试套件：\n- 案例 1 (正常路径)：$\\,r_{\\min} = 10.0\\,$, $\\,r_{\\max} = 40.0\\,$, $\\,\\delta = 0.1\\,$.\n- 案例 2 (窄环域)：$\\,r_{\\min} = 20.0\\,$, $\\,r_{\\max} = 21.0\\,$, $\\,\\delta = 10^{-3}\\,$.\n- 案例 3 (宽环域)：$\\,r_{\\min} = 5.0\\,$, $\\,r_{\\max} = 100.0\\,$, $\\,\\delta = 0.2\\,$.\n- 案例 4 (靠近原点但不包括零)：$\\,r_{\\min} = 0.5\\,$, $\\,r_{\\max} = 2.0\\,$, $\\,\\delta = 10^{-2}\\,$.\n- 案例 5 (严格衰减)：$\\,r_{\\min} = 15.0\\,$, $\\,r_{\\max} = 25.0\\,$, $\\,\\delta = 10^{-4}\\,$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，形式为 $\\, [n,[c_0,c_1,\\dots,c_n]]\\,$。例如：\n$\\,[[n_1,[c_{0,1},\\dots,c_{n_1,1}]],[n_2,[c_{0,2},\\dots,c_{n_2,2}]],\\dots]\\,$。\n所有数字必须以标准十进制表示法表示。本问题不要求物理单位或角度，所有数值输出必须是不带百分号的实数。",
            "solution": "该问题要求为离散化时谐声波方程产生的不定线性系统设计一个多项式光滑器。该光滑器基于切比雪夫多项式，并针对矩阵 $\\,A\\,$ 的谱位于复平面上的环域 $\\,\\mathcal{A} = \\{\\lambda \\in \\mathbb{C} : r_{\\min} \\le |\\lambda| \\le r_{\\max}\\}\\,$ 的系统进行了优化。该光滑器作用于正规方程矩阵 $\\,H = A^* A\\,$，其谱包含在实数区间 $\\,[\\alpha, \\beta]\\,$ 内，其中 $\\,\\alpha = r_{\\min}^2\\,$ 且 $\\,\\beta = r_{\\max}^2\\,$。\n\n我们的任务是推导并实现一个 $n$ 阶多项式 $\\,p_n(\\mu)\\,$，它满足归一化条件 $\\,p_n(0) = 1\\,$，并最小化在谱区间 $\\,[\\alpha, \\beta]\\,$ 上的最大绝对值。这是一个经典的极小化极大逼近问题。解决方案基于第一类切比雪夫多项式 $\\,T_n(x)\\,$ 的性质。\n\n### 第 1 部分：最优多项式的推导\n\n目标是找到一个 $n$ 阶多项式 $\\,p_n(\\mu)\\,$，它在约束条件 $\\,p_n(0) = 1\\,$ 下最小化 $\\,\\max_{\\mu \\in [\\alpha, \\beta]} |p_n(\\mu)|\\,$。\n\n已知切比雪夫多项式 $\\,T_n(x)\\,$ 是一个相关极小化极大问题的唯一解：在所有 $n$ 阶首一多项式中，$\\,2^{1-n} T_n(x)\\,$ 在区间 $\\,[-1, 1]\\,$ 上具有最小的最大绝对值。一个更普遍的性质是，对于 $\\,[-1, 1]\\,$ 之外的任意点 $\\,x_0\\,$，多项式 $\\,q_n(x) = T_n(x) / T_n(x_0)\\,$ 在所有满足 $\\,q_n(x_0) = 1\\,$ 的 $n$ 阶多项式 $\\,q_n\\,$ 中，最小化了 $\\,\\max_{x \\in [-1, 1]} |q_n(x)|\\,$。\n\n为了利用这一性质，我们首先应用一个仿射变换，将谱区间 $\\,[\\alpha, \\beta]\\,$ 映射到标准的切比雪夫区间 $\\,[-1, 1]\\,$：\n$$x(\\mu) = m\\mu + b$$\n我们要求 $\\,x(\\alpha) = -1\\,$ 和 $\\,x(\\beta) = 1\\,$。解这个线性方程组：\n$$\n\\begin{cases}\n-1 = m\\alpha + b \\\\\n1 = m\\beta + b\n\\end{cases}\n$$\n得到映射参数：\n$$m = \\frac{2}{\\beta - \\alpha} \\quad \\text{和} \\quad b = -\\frac{\\beta + \\alpha}{\\beta - \\alpha}$$\n归一化约束施加在 $\\,\\mu = 0\\,$ 处。我们将此点映射到 $\\,x\\,$ 坐标：\n$$x_0 = x(0) = b = -\\frac{\\beta + \\alpha}{\\beta - \\alpha}$$\n由于问题陈述 $\\,r_{\\min}  0\\,$，我们有 $\\,\\alpha = r_{\\min}^2  0\\,$。因此，$\\,\\beta  \\alpha  0\\,$，这意味着 $\\,\\beta + \\alpha  \\beta - \\alpha  0\\,$。所以，$\\,x_0  -1\\,$，归一化点位于区间 $\\,[-1, 1]\\,$ 之外。\n\n在变换后的坐标中，最优多项式为 $\\,q_n(x) = T_n(x) / T_n(x_0)\\,$。用原始变量 $\\,\\mu\\,$ 表示，解为：\n$$p_n(\\mu) = \\frac{T_n(x(\\mu))}{T_n(x_0)} = \\frac{T_n\\left(\\frac{2\\mu - (\\alpha + \\beta)}{\\beta - \\alpha}\\right)}{T_n\\left(-\\frac{\\beta + \\alpha}{\\beta - \\alpha}\\right)}$$\n该多项式满足 $\\,p_n(0) = T_n(x(0))/T_n(x_0) = 1\\,$。因此，多项式 $\\,p_n(\\mu) = \\sum_{j=0}^n c_j \\mu^j\\,$ 的常数项是 $\\,c_0 = 1\\,$。\n\n### 第 2 部分：目标衰减的最小阶数\n\n我们需要找到保证衰减因子为 $\\,\\delta \\in (0, 1)\\,$ 的最小阶数 $\\,n\\,$。这意味着我们需要：\n$$\\max_{\\mu \\in [\\alpha, \\beta]} |p_n(\\mu)| \\le \\delta$$\n对于 $\\,\\mu \\in [\\alpha, \\beta]\\,$，变量 $\\,x(\\mu)\\,$ 在 $\\,[-1, 1]\\,$ 内。在此区间内，$\\,T_n(x)\\,$ 的最大绝对值为 $\\,1\\,$。因此，$\\,|p_n(\\mu)|\\,$ 在 $\\,[\\alpha, \\beta]\\,$ 上的最大值为：\n$$\\max_{\\mu \\in [\\alpha, \\beta]} |p_n(\\mu)| = \\frac{\\max_{x \\in [-1, 1]} |T_n(x)|}{|T_n(x_0)|} = \\frac{1}{|T_n(x_0)|}$$\n条件变为 $\\,1 / |T_n(x_0)| \\le \\delta\\,$, 或 $\\,|T_n(x_0)| \\ge 1/\\delta\\,$。\n\n令 $\\,\\kappa = -x_0 = \\frac{\\beta + \\alpha}{\\beta - \\alpha}\\,$。由于 $\\,\\kappa > 1\\,$，我们对 $\\,x > 1\\,$ 使用恒等式 $\\,T_n(x) = \\cosh(n \\operatorname{arccosh}(x))\\,$。此外，$\\,T_n(-x) = (-1)^n T_n(x)\\,$，所以 $\\,|T_n(x_0)| = |T_n(-\\kappa)| = T_n(\\kappa)\\,$。不等式为：\n$$T_n(\\kappa) \\ge 1/\\delta$$\n代入 $\\,T_n(\\kappa)\\,$ 的恒等式：\n$$\\cosh(n \\operatorname{arccosh}(\\kappa)) \\ge 1/\\delta$$\n由于 $\\,\\operatorname{arccosh}(y)\\,$ 对于 $\\,y \\ge 1\\,$ 是一个增函数，我们可以将其应用于不等式两边（注意 $\\,1/\\delta > 1\\,$）：\n$$n \\operatorname{arccosh}(\\kappa) \\ge \\operatorname{arccosh}(1/\\delta)$$\n这就得出了阶数 $\\,n\\,$ 的判据：\n$$n \\ge \\frac{\\operatorname{arccosh}(1/\\delta)}{\\operatorname{arccosh}(\\kappa)}$$\n由于阶数必须是整数，所需的最小阶数为：\n$$n = \\left\\lceil \\frac{\\operatorname{arccosh}(1/\\delta)}{\\operatorname{arccosh}(\\kappa)} \\right\\rceil \\quad \\text{其中} \\quad \\kappa = \\frac{r_{\\max}^2 + r_{\\min}^2}{r_{\\max}^2 - r_{\\min}^2}$$\n\n### 第 3 部分：多项式系数的构造\n\n为了找到 $\\,p_n(\\mu) = \\sum_{j=0}^{n} c_j \\mu^j\\,$ 的系数 $\\,\\{c_j\\}\\,$，我们首先构造未归一化的多项式 $\\,P_n(\\mu) = T_n(m\\mu + b)\\,$ 的系数，其中 $\\,m = \\frac{2}{\\beta-\\alpha}\\,$ 且 $\\,b = -\\kappa\\,$。我们使用切比雪夫多项式的三项递推关系：\n$$T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x), \\quad \\text{其中 } T_0(x)=1, T_1(x)=x$$\n代入 $\\,x = m\\mu+b\\,$，我们得到多项式 $\\,P_k(\\mu) = T_k(m\\mu+b)\\,$ 的一个递推关系：\n$$P_{k+1}(\\mu) = 2(m\\mu+b)P_k(\\mu) - P_{k-1}(\\mu)$$\n这个关系可以转化为多项式系数的递推关系。设 $\\,P_k(\\mu) = \\sum_{j=0}^{k} d_j^{(k)} \\mu^j\\,$。$\\,P_{k+1}(\\mu)\\,$ 的系数 $\\,\\{d_j^{(k+1)}\\}\\,$ 可以从 $\\,P_k(\\mu)\\,$ 和 $\\,P_{k-1}(\\mu)\\,$ 的系数计算得出。具体来说，我们从 $\\,P_0(\\mu) = 1\\,$（系数：$\\,[1]\\,$）和 $\\,P_1(\\mu) = m\\mu+b\\,$（系数：$\\,[b, m]\\,$）的系数向量开始，迭代计算直到 $\\,P_n(\\mu)\\,$ 的系数向量。\n\n最终的系数 $\\,\\{c_j\\}\\,$ 是通过将 $\\,P_n(\\mu)\\,$ 的系数除以归一化常数 $\\,C_n = T_n(b)\\,$ 的值得到的：\n$$c_j = \\frac{d_j^{(n)}}{T_n(b)}$$\n常数 $\\,T_n(b)\\,$ 可以通过使用递推关系的标量版本高效计算：$\\,T_{k+1}(b) = 2b T_k(b) - T_{k-1}(b)\\,$。由于 $\\,d_0^{(n)} = P_n(0) = T_n(b)\\,$, 最终多项式的常数项为 $\\,c_0 = d_0^{(n)}/T_n(b) = 1\\,$，这符合归一化条件的要求。\n实现将算法化地遵循这一过程。",
            "answer": "```python\nimport numpy as np\n\ndef format_num(x):\n    \"\"\"Formats a number into a standard decimal string, trimming trailing zeros.\"\"\"\n    if x == 0.0:\n        return '0.0'\n    s = \"{:.16f}\".format(x)\n    s = s.rstrip('0')\n    if s.endswith('.'):\n        s = s[:-1]\n    if s == '-0':\n        s = '0'\n    return s\n\ndef compute_chebyshev_smoother(r_min, r_max, delta):\n    \"\"\"\n    Computes the minimal degree and coefficients of the Chebyshev polynomial smoother.\n\n    Args:\n        r_min (float): The minimum radius of the spectral annulus.\n        r_max (float): The maximum radius of the spectral annulus.\n        delta (float): The target attenuation factor.\n\n    Returns:\n        tuple: A tuple containing:\n            - n (int): The minimal polynomial degree.\n            - coeffs (list): The list of polynomial coefficients [c_0, c_1, ..., c_n].\n    \"\"\"\n    alpha = r_min**2\n    beta = r_max**2\n\n    # Handle the case where the annulus is degenerate\n    if np.isclose(alpha, beta):\n        return 0, [1.0]\n\n    # Calculate kappa for the mapped interval\n    kappa = (beta + alpha) / (beta - alpha)\n\n    # Calculate the minimal degree n\n    # n = arccosh(1/delta) / arccosh(kappa)\n    # Use the identity arccosh(x) = log(x + sqrt(x^2 - 1))\n    n_float = np.arccosh(1.0 / delta) / np.arccosh(kappa)\n    n = int(np.ceil(n_float))\n\n    if n == 0:\n        return 0, [1.0]\n\n    # Parameters for the affine map x(mu) = m*mu + b\n    m = 2.0 / (beta - alpha)\n    b = -kappa\n\n    # Calculate the normalization constant C_n = T_n(b) using the recurrence\n    T_km1 = 1.0  # T_0(b)\n    T_k = b      # T_1(b)\n    for _ in range(1, n):\n        T_kp1 = 2.0 * b * T_k - T_km1\n        T_km1 = T_k\n        T_k = T_kp1\n    C_n = T_k\n\n    # Compute coefficients of the unnormalized polynomial P_n(mu) = T_n(m*mu + b)\n    # using a recurrence on the coefficient vectors.\n    P_km1_coeffs = np.array([1.0])                   # Coeffs for P_0\n    if n == 1:\n        P_n_coeffs = np.array([b, m])\n    else:\n        P_k_coeffs = np.array([b, m])                # Coeffs for P_1\n        for k in range(1, n):\n            # Recurrence: P_{k+1} = 2*(m*mu+b)*P_k - P_{k-1}\n            # Term 1: 2*b*P_k\n            term1 = 2.0 * b * P_k_coeffs\n            # Term 2: 2*m*mu*P_k (multiplication by mu is a right shift of coeffs)\n            term2 = 2.0 * m * P_k_coeffs\n\n            # Combine terms to get P_{k+1}\n            P_kp1_coeffs = np.zeros(k + 2)\n            P_kp1_coeffs[:k + 1] += term1\n            P_kp1_coeffs[1:] += term2\n            P_kp1_coeffs[:k] -= P_km1_coeffs\n\n            P_km1_coeffs = P_k_coeffs\n            P_k_coeffs = P_kp1_coeffs\n        P_n_coeffs = P_k_coeffs\n\n    # Normalize coefficients to get the final polynomial p_n(mu)\n    coeffs = P_n_coeffs / C_n\n\n    return n, coeffs.tolist()\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    test_cases = [\n        (10.0, 40.0, 0.1),\n        (20.0, 21.0, 1e-3),\n        (5.0, 100.0, 0.2),\n        (0.5, 2.0, 1e-2),\n        (15.0, 25.0, 1e-4),\n    ]\n\n    results = []\n    for r_min, r_max, delta in test_cases:\n        n, coeffs = compute_chebyshev_smoother(r_min, r_max, delta)\n        \n        # Format the coefficients to strings\n        coeffs_str = '[' + ','.join(map(format_num, coeffs)) + ']'\n        \n        # Format the result for this case\n        case_result_str = f\"[{n},{coeffs_str}]\"\n        results.append(case_result_str)\n\n    # Final print statement must be a single line with the exact format\n    final_output = '[' + ','.join(results) + ']'\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}