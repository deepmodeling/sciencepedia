{
    "hands_on_practices": [
        {
            "introduction": "在深入研究分层矩阵和自适应交叉近似（ACA）的复杂细节之前，首先建立一个关于“为什么需要它们”的直观认识至关重要。当声学等领域的边界积分方程被离散化时，会产生巨大的稠密矩阵，其存储和计算成本可能高得惊人。本练习将通过具体的计算，量化比较传统稠密矩阵方法与分层矩阵方法在内存占用和计算成本上的差异，从而揭示后者的巨大优势。",
            "id": "4115706",
            "problem": "三维时谐声学亥姆霍兹方程的边界积分离散化产生一个包含 $N=10^{5}$ 个边界未知数的稠密线性系统。所得的系统矩阵是复值的，单个矩阵元素以双精度复数格式存储，占用 $16$ 字节。考虑两种组装与存储策略：\n\n1. 稠密组装与存储：\n   - 通过计算所有源-目标对的格林函数核来完全组装矩阵。以成对相互作用模型产生$\\mathcal{O}(N^{2})$次核函数计算为基本依据。\n   - 存储量包括所有 $N^{2}$ 个矩阵元素。\n\n2. 采用自适应交叉近似（ACA）的分层矩阵：\n   - 该区域被分层划分为一个深度为$L=\\lceil \\log_{2} N \\rceil$的平衡二叉聚类树。\n   - 远场容许块通过自适应交叉近似（ACA）使用秩为 $r=30$ 的低秩分解进行压缩。在一个 $m \\times n$ 矩阵块的秩 $r$ 分解中，存储 $U \\in \\mathbb{C}^{m \\times r}$ 和 $V \\in \\mathbb{C}^{n \\times r}$，需要 $r(m+n)$ 个复数。\n   - 使用平衡二叉空间划分的一个经过充分验证的性质，即在某个容许性条件下，固定层级 $\\ell$ 上所有远场块的 $(m+n)$ 之和以 $2N$ 为界。因此，对所有 $L$ 个层级求和，存储所有远场低秩因子所需的复数总数以$2 r N \\log_{2} N$为界。假设在 $N=10^{5}$ 和 $r=30$ 的情况下，与此项相比，近场贡献可以忽略不计。\n   - 假设 ACA 组装成本与存储的低秩自由度数量成正比，因此远场块的核函数计算总数也与$2 r N \\log_{2} N$成正比。使用单位比例常数来获得一个具体的计数值。\n\n任务：\n- 从这些依据和假设出发，推导出以下各项的显式公式：\n  - 稠密存储量（以字节为单位）和稠密组装成本（以核函数计算次数为单位）。\n  - 分层存储量（以字节为单位）和分层组装成本（以核函数计算次数为单位）。\n- 然后，定义压缩因子\n  $$S \\equiv \\frac{\\text{稠密存储量 (字节)}}{\\text{分层存储量 (字节)}}$$\n  对于 $N=10^{5}$ 和 $r=30$，计算 $S$ 的值。\n- 为了便于理解，您也可以使用十进制单位吉字节（$1\\,\\mathrm{GB} = 10^{9}$ 字节）来表示中间的内存预算。但是，您最终报告的值必须是压缩因子 $S$ 这个纯数。\n\n将您关于 $S$ 的最终答案四舍五入至四位有效数字。最终报告的数字不应包含任何单位。",
            "solution": "问题陈述经评估有效。它在科学上基于计算声学中使用的边界元法和分层矩阵近似（特别是自适应交叉近似，ACA）的既定原理。问题是适定的，提供了所有必要的数据、明确的假设和清晰的定义，确保可以推导出唯一且有意义的解。其参数和背景对于一个大规模科学计算问题是现实的。\n\n我们着手进行推导和求解。\n\n边界未知数的数量为 $N=10^{5}$。单个矩阵元素以双精度复数形式存储，占用 $16$ 字节。\n\n首先，我们分析稠密组装与存储策略。\n系统矩阵的大小为 $N \\times N$。元素总数为 $N^2$。\n稠密矩阵所需的存储量，记为 $D_{\\text{存储}}$，是元素总数乘以每个元素的存储量：\n$$D_{\\text{存储}} = N^2 \\times 16 \\text{ 字节}$$\n组装成本，定义为核函数计算的次数，基于成对相互作用模型，其成本记为 $D_{\\text{成本}}$，为：\n$$D_{\\text{成本}} = N^2 \\text{ 次核函数计算}$$\n\n接下来，我们分析采用自适应交叉近似（ACA）的分层矩阵策略。\n低秩近似的秩给定为 $r=30$。\n问题陈述指出，存储所有远场低秩因子所需的复数总数以 $2 r N \\log_{2} N$ 为界，并且假设近场的贡献可以忽略不计。\n因此，分层矩阵的存储量，记为 $H_{\\text{存储}}$，由该数量乘以每个复数的存储量给出：\n$$H_{\\text{存储}} = (2 r N \\log_{2} N) \\times 16 \\text{ 字节}$$\n远场块的组装成本，记为 $H_{\\text{成本}}$，假设与存储量成正比且比例常数为单位1，并且再次忽略近场成本。\n$$H_{\\text{成本}} = 2 r N \\log_{2} N \\text{ 次核函数计算}$$\n\n现在，我们针对给定参数 $N=10^5$ 和 $r=30$ 计算这些量和压缩因子 $S$。\n\n对于稠密策略：\n$D_{\\text{存储}} = (10^5)^2 \\times 16 = 10^{10} \\times 16 = 1.6 \\times 10^{11}$ 字节。使用换算 $1\\,\\mathrm{GB} = 10^9$ 字节，这相当于 $160\\,\\mathrm{GB}$。\n$D_{\\text{成本}} = (10^5)^2 = 10^{10}$ 次核函数计算。\n\n对于分层策略，我们首先计算 $\\log_{2} N$ 的值：\n$$\\log_{2} N = \\log_{2}(10^5) = 5 \\log_{2}(10)$$\n使用换底公式，$\\log_{2}(10) = \\frac{\\ln(10)}{\\ln(2)}$。\n数值上，$\\log_{2}(10^5) \\approx 5 \\times \\frac{2.302585}{0.693147} \\approx 16.60964$。\n现在我们可以计算存储量和成本：\n$H_{\\text{存储}} = (2 \\times 30 \\times 10^5 \\times \\log_{2}(10^5)) \\times 16 \\approx (60 \\times 10^5 \\times 16.60964) \\times 16 \\approx 9.965784 \\times 10^7 \\times 16 \\approx 1.5945 \\times 10^9$ 字节。这大约是 $1.595\\,\\mathrm{GB}$。\n$H_{\\text{成本}} = 2 \\times 30 \\times 10^5 \\times \\log_{2}(10^5) \\approx 60 \\times 10^5 \\times 16.60964 \\approx 9.966 \\times 10^7$ 次核函数计算。\n\n压缩因子 $S$ 定义为稠密存储量与分层存储量之比：\n$$S \\equiv \\frac{D_{\\text{存储}}}{H_{\\text{存储}}}$$\n代入推导出的公式：\n$$S = \\frac{N^2 \\times 16}{(2 r N \\log_{2} N) \\times 16} = \\frac{N^2}{2 r N \\log_{2} N} = \\frac{N}{2 r \\log_{2} N}$$\n这个公式表明，压缩因子随问题规模 $N$ 线性提高，并与秩 $r$ 和 $N$ 的对数成反比。\n\n我们现在为给定值计算 $S$：\n$$S = \\frac{10^5}{2 \\times 30 \\times \\log_{2}(10^5)} = \\frac{10^5}{60 \\times \\log_{2}(10^5)}$$\n使用先前计算出的 $\\log_{2}(10^5)$ 的值：\n$$S \\approx \\frac{100000}{60 \\times 16.60964} \\approx \\frac{100000}{996.5784} \\approx 100.3433$$\n将结果四舍五入到四位有效数字，得到 $100.3$。\n这意味着对于此问题规模，与稠密矩阵方法相比，分层矩阵方法将存储需求减少了约 $100.3$ 倍。",
            "answer": "$$\\boxed{100.3}$$"
        },
        {
            "introduction": "了解了分层矩阵的巨大效率优势后，我们自然会问：这种效率是如何实现的？其核心在于将矩阵巧妙地划分为“近场”（不可压缩）和“远场”（可压缩）的子块。本练习将指导您亲手实现执行此划分的几何准则，即“可纳性条件”（admissibility condition）。",
            "id": "4115730",
            "problem": "给定一个计算声学背景，其中由时谐声学亥姆霍兹问题产生的稠密边界积分方程矩阵，在层次矩阵的框架内使用自适应交叉近似（ACA）进行压缩。该物理模型由亥姆霍兹方程控制，边界积分公式导致由自由空间格林函数填充的矩阵。层次矩阵结构要求将块进行几何可容许性分类，分为近场（不压缩）和远场（适用于低秩表示）。您的任务是实现一个由用户选择的分离参数参数化的几何远场可容许性测试，并计算在用给定数量的嵌板离散化的球体上，可容许块的比例。\n\n从以下基本基础开始：\n- 时谐声学场由亥姆霍兹方程$ \\nabla^2 p(\\boldsymbol{x}) + k^2 p(\\boldsymbol{x}) = 0 $控制，其中波数为 $ k $。\n- 当源簇和目标簇在空间中相对于其尺寸充分分离时，亥姆霍兹方程的自由空间格林函数 $ G(\\boldsymbol{x},\\boldsymbol{y}) $ 是 $ \\boldsymbol{x} $ 和 $ \\boldsymbol{y} $ 的光滑函数，这种光滑性是远场相互作用中低秩近似的基础。\n- 层次矩阵将索引集划分为由几何包围盒表示的簇。簇对之间的块使用一个几何准则被分类为远场或近场，该准则与“如果两个簇的尺寸相对于它们的分离距离较小，则它们是远场”的原则相一致。\n\n实现以下内容：\n1. 使用 $ N $ 个嵌板离散化半径为 $ R = 1 $ 的单位球体，由球体表面上的 $ N $ 个准均匀点 $ \\{\\boldsymbol{x}_i\\}_{i=1}^N $ 表示。使用一种经过良好测试的确定性方法，该方法能在球体上产生近乎均匀的覆盖（例如，斐波那契晶格），以定义满足 $ \\|\\boldsymbol{x}_i\\|_2 = R $ 的嵌板位置 $ \\boldsymbol{x}_i \\in \\mathbb{R}^3 $。最终结果中不需要物理单位，因为输出是一个无量纲的比例。\n2. 在点集上构建一个二元空间簇树，方法是沿着其轴对齐包围盒的最长轴递归地分裂簇，直到每个叶簇最多包含 $ m $ 个嵌板，其中 $ m $ 是一个固定的整数且 $ m \\geq 2 $。每个簇都与其在 $ \\mathbb{R}^3 $ 中的轴对齐包围盒相关联，该包围盒由最小和最大角向量 $ \\boldsymbol{b}^{\\min} \\in \\mathbb{R}^3 $ 和 $ \\boldsymbol{b}^{\\max} \\in \\mathbb{R}^3 $ 定义。簇的大小使用从包围盒派生的一致几何度量来量化，两个簇之间的分离使用它们轴对齐包围盒之间的欧几里得距离来量化。\n3. 在同一簇树上为行和列构建一个块-簇树（由于边界对于源和目标是相同的，因此是同一集合）。从由根簇与自身组成的对开始，递归地生成块，如下所示：如果一对簇满足一个几何条件，该条件形式化了尺寸相对于分离距离较小的原则，则声明此块为远场并且不再进一步细分；否则，如果两个簇都是叶簇，则声明此块为近场；如果不可容许且至少有一个簇不是叶簇，则细分具有较大几何尺寸的一侧（如果两者都非叶簇）或非叶簇的一侧，并在子对上递归，直到满足前述条件之一。递归过程必须将完整的相互作用矩阵索引划分为一个不相交的块集合。\n4. 使用一个选定的分离参数 $ \\eta > 0 $，实现一个与上述原则一致的、数学上合理的远场可容许性测试。使用每个簇的轴对齐包围盒来定义其几何尺寸，并使用两个轴对齐包围盒之间的欧几里得最小距离来定义分离。该测试必须由 $ \\eta $ 参数化，以便增加 $ \\eta $ 会使分类更加宽松。\n5. 计算块-簇树的可容许块比例，定义为远场块的数量除以划分中的总块数。\n\n您的程序必须：\n- 使用 $ R = 1 $ 和一个固定的叶大小 $ m = 16 $ 个嵌板/叶簇。\n- 对于每个测试用例，构建簇树和块-簇树，并计算可容许块的比例，结果为一个在 $ [0,1] $ 区间内的实数，四舍五入到六位小数。\n- 生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果。\n\n测试套件：\n- 情况1：$ N = 64 $， $ \\eta = 0.5 $。\n- 情况2：$ N = 64 $， $ \\eta = 1.0 $。\n- 情况3：$ N = 64 $， $ \\eta = 2.0 $。\n- 情况4：$ N = 8 $， $ \\eta = 0.5 $。\n- 情况5：$ N = 256 $， $ \\eta = 0.5 $。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$ [r_1,r_2,r_3,r_4,r_5] $），其中每个 $ r_i $ 是对应测试用例的可容许块比例，四舍五入到六位小数。",
            "solution": "该问题是有效的。它是一个定义明确的计算任务，其基础是用于加速边界元方法的层次矩阵的既定原则。参数和目标清晰、一致且科学合理。\n\n目标是计算在层次矩阵划分中，对于由球面上点离散化的边界，可容许（远场）块的比例。这个比例是层次矩阵算法的一个关键性能指标，因为它代表了可以被压缩的矩阵块的比例，从而降低计算复杂度。该过程涉及计算科学中的几个标准步骤：几何离散化、层次化数据结构和基于几何可容许性准则的递归划分。\n\n解决方案通过以下步骤序列构建：\n1. 在球体上生成准均匀分布的点，以表示离散化的边界。\n2. 构建一个空间簇树，以层次化地组织这些点。\n3. 定义并实现一个几何可容许性准则，将簇对分类为近场或远场。\n4. 构建一个将矩阵划分为近场和远场块的块-簇树，并计算最终的可容许块比例。\n\n**步骤1：球体离散化**\n\n第一步是生成一组 $N$ 个点 $\\{\\boldsymbol{x}_i\\}_{i=1}^N$，这些点代表半径为 $R=1$ 的单位球体表面上的嵌板位置。为使结果具有确定性和代表性，这些点必须以准均匀的方式分布。斐波那契晶格为此提供了一种有效的方法。第 $i$ 个点（其中 $i \\in \\{0, 1, \\dots, N-1\\}$）的坐标使用球坐标 $(\\rho, \\theta, \\phi)$ 生成，其中 $\\rho$ 是径向距离，$\\theta$ 是方位角，$\\phi$ 是极角。对于单位球体，$\\rho=1$。角度由以下公式给出：\n$$ \\phi_i = \\arccos\\left(1 - \\frac{2(i+0.5)}{N}\\right) $$\n$$ \\theta_i = \\frac{2\\pi i}{\\Phi} $$\n其中 $\\Phi = \\frac{1+\\sqrt{5}}{2}$ 是黄金比例。然后通过标准变换获得笛卡尔坐标 $\\boldsymbol{x}_i = (x_i, y_i, z_i)$：\n$$ x_i = R \\sin(\\phi_i) \\cos(\\theta_i) $$\n$$ y_i = R \\sin(\\phi_i) \\sin(\\theta_i) $$\n$$ z_i = R \\cos(\\phi_i) $$\n给定 $R=1$，这些点位于单位球体上，满足 $\\|\\boldsymbol{x}_i\\|_2 = 1$。这 $N$ 个点构成了我们问题的索引集。\n\n**步骤2：簇树构建**\n\n簇树是一种对点集进行空间组织的层次化数据结构。它是递归构建的。树中的每个节点，称为一个簇 $\\tau$，代表点索引的一个子集 $I_\\tau \\subseteq \\{0, 1, \\dots, N-1\\}$，并与一个轴对齐包围盒（AABB）$\\mathcal{B}_\\tau$ 相关联，该包围盒包围了所有点 $\\{\\boldsymbol{x}_i\\}_{i \\in I_\\tau}$。\n\n树的构建过程如下：\n-   根簇包含所有 $N$ 个点索引。\n-   一个递归函数应用于根簇。对于一个给定的簇 $\\tau$：\n    1.  如果簇中的点数 $|I_\\tau|$ 小于或等于叶大小参数 $m$（给定为 $m=16$），则该簇被声明为叶簇，并且此分支的递归终止。\n    2.  否则，该簇被分裂为两个子簇。分裂是沿着簇的 AABB $\\mathcal{B}_\\tau$ 的最长维度进行的。点根据它们在此维度上坐标的中位数被划分为两组。这确保了平衡的空间划分。\n    3.  从这两组点创建两个新的子簇，并对每个子簇调用递归函数。\n\n这个过程产生一个二叉树，其中每个叶簇最多包含 $m$ 个点。\n\n**步骤3：几何可容许性准则**\n\n层次矩阵方法的核心是可容许性准则，它决定两个簇 $\\tau$ 和 $\\sigma$ 之间的相互作用是否可以被近似。这基于格林函数对于充分分离的域是光滑的这一原理。一个标准的几何条件通过比较簇的大小与它们的分离距离来形式化这一原理。\n\n对于两个簇 $\\tau$ 和 $\\sigma$，我们定义：\n-   **包围盒 $\\mathcal{B}$**：一个簇 $\\tau$ 的 AABB 由其最小和最大角向量 $\\boldsymbol{b}_\\tau^{\\min}$ 和 $\\boldsymbol{b}_\\tau^{\\max}$ 定义。\n-   **直径 $\\text{diam}(\\mathcal{B}_\\tau)$**：簇的大小由其 AABB 的直径量化，计算为包围盒对角线的欧几里得范数：$\\text{diam}(\\mathcal{B}_\\tau) = \\|\\boldsymbol{b}_\\tau^{\\max} - \\boldsymbol{b}_\\tau^{\\min}\\|_2$。\n-   **距离 $\\text{dist}(\\mathcal{B}_\\tau, \\mathcal{B}_\\sigma)$**：两个簇之间的分离是它们 AABB 之间的最小欧几里得距离。计算公式为 $\\text{dist}(\\mathcal{B}_\\tau, \\mathcal{B}_\\sigma) = \\left( \\sum_{j=1}^3 \\max(0, b_{\\tau,j}^{\\min} - b_{\\sigma,j}^{\\max}, b_{\\sigma,j}^{\\min} - b_{\\tau,j}^{\\max})^2 \\right)^{1/2}$。\n\n对于给定的分离参数 $\\eta > 0$，如果以下条件成立，则对应于簇对 $(\\tau, \\sigma)$ 的块被声明为**可容许的**（远场）：\n$$ \\max(\\text{diam}(\\mathcal{B}_\\tau), \\text{diam}(\\mathcal{B}_\\sigma)) \\le \\eta \\cdot \\text{dist}(\\mathcal{B}_\\tau, \\mathcal{B}_\\sigma) $$\n如果包围盒接触或重叠，$\\text{dist}(\\mathcal{B}_\\tau, \\mathcal{B}_\\sigma) = 0$，该条件不满足（除非簇是直径为零的单点）。增加 $\\eta$ 会放宽此条件，允许在相同距离下将更大的簇视为“远场”，从而使可容许性更宽松。\n\n**步骤4：块-簇树和比例计算**\n\n块-簇树表示将整个矩阵乘积空间 $I \\times I$ 划分为不相交的块 $(\\tau, \\sigma)$。我们不需要显式地存储这棵树；我们可以递归地遍历它来计算可容许（远场）和不可容许（近场）的叶块数量。\n\n计数是通过一个递归算法执行的，该算法使用栈进行迭代，以避免深度递归问题：\n1.  用初始块 `(root, root)` 初始化一个栈，其中 `root` 是簇树的根。初始化计数器 $N_{\\text{far}} = 0$ 和 $N_{\\text{near}} = 0$。\n2.  当栈不为空时，弹出一个块 $(\\tau, \\sigma)$。\n3.  使用步骤3中的准则检查该块是否可容许。\n    -   如果是，则增加 $N_{\\text{far}}$，并且不再细分此块。\n    -   如果不是，则继续下一步。\n4.  检查 $\\tau$ 和 $\\sigma$ 是否都是叶簇。\n    -   如果是，则此块是一个不可压缩的近场块。增加 $N_{\\text{near}}$。\n    -   如果不是，则至少有一个簇不是叶簇，该块必须被细分。\n5.  为了细分，选择直径较大的簇进行分裂。如果一个簇是叶簇，则必须分裂另一个（非叶）簇。\n    -   如果选择 $\\tau$ 进行分裂，则将其子对 $(\\tau_1, \\sigma)$ 和 $(\\tau_2, \\sigma)$ 推入栈中。\n    -   如果选择 $\\sigma$ 进行分裂，则将 $(\\tau, \\sigma_1)$ 和 $(\\tau, \\sigma_2)$ 推入栈中。\n6.  重复此过程直到栈为空。\n\n最后，可容许块的比例计算如下：\n$$ \\mathcal{F} = \\frac{N_{\\text{far}}}{N_{\\text{far}} + N_{\\text{near}}} $$\n对于问题陈述中指定的每个测试用例，计算此值，并将结果四舍五入到六位小数。在 $N=8$ 且 $m=16$ 的特殊情况下，簇树只有一个根节点（它也是一个叶节点）。块 `(root, root)` 是不可容许的，且无法细分，导致 $N_{\\text{near}}=1$ 和 $N_{\\text{far}}=0$，得出比例为 $0.0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the fraction of admissible blocks in a hierarchical matrix partition\n    for a sphere discretization.\n    \"\"\"\n\n    class Cluster:\n        \"\"\"Represents a cluster of points and its bounding box.\"\"\"\n        def __init__(self, indices, all_points):\n            self.indices = np.array(indices, dtype=int)\n            if self.indices.size > 0:\n                self.points = all_points[self.indices]\n                self.bbox_min = np.min(self.points, axis=0)\n                self.bbox_max = np.max(self.points, axis=0)\n                self.diameter = np.linalg.norm(self.bbox_max - self.bbox_min)\n            else:\n                self.points = np.empty((0, 3))\n                # Define a non-interfering default for empty clusters\n                self.bbox_min = np.full(3, np.inf)\n                self.bbox_max = np.full(3, -np.inf)\n                self.diameter = 0.0\n            self.children = None\n\n    def generate_sphere_points(N, R):\n        \"\"\"Generates N quasi-uniform points on a sphere of radius R using a Fibonacci lattice.\"\"\"\n        if N == 0:\n            return np.empty((0, 3))\n        \n        indices = np.arange(0, N, dtype=float) + 0.5\n        \n        phi = np.arccos(1 - 2 * indices / N)\n        golden_ratio = (1 + 5**0.5) / 2\n        theta = 2 * np.pi * indices / golden_ratio\n        \n        x = R * np.cos(theta) * np.sin(phi)\n        y = R * np.sin(theta) * np.sin(phi)\n        z = R * np.cos(phi)\n        \n        return np.stack([x, y, z], axis=1)\n\n    def build_cluster_tree(cluster, m, all_points):\n        \"\"\"Recursively builds a spatial cluster tree.\"\"\"\n        if len(cluster.indices) <= m:\n            return  # This cluster is a leaf\n\n        # Find the longest dimension of the bounding box to split along\n        dims = cluster.bbox_max - cluster.bbox_min\n        split_dim = np.argmax(dims)\n        \n        # Partition points based on the median coordinate\n        coords = cluster.points[:, split_dim]\n        median = np.median(coords)\n        \n        left_indices = cluster.indices[coords < median]\n        right_indices = cluster.indices[coords >= median]\n\n        # Handle degenerate cases where one child would be empty\n        if len(left_indices) == 0 or len(right_indices) == 0:\n            mid_idx = len(cluster.indices) // 2\n            left_indices = cluster.indices[:mid_idx]\n            right_indices = cluster.indices[mid_idx:]\n\n        cluster.children = [\n            Cluster(left_indices, all_points),\n            Cluster(right_indices, all_points)\n        ]\n        \n        for child in cluster.children:\n            build_cluster_tree(child, m, all_points)\n\n    def is_admissible(c_tau, c_sigma, eta):\n        \"\"\"Checks if the block (c_tau, c_sigma) is admissible.\"\"\"\n        dist_sq = 0.0\n        for i in range(3):\n            d = max(0.0, c_tau.bbox_min[i] - c_sigma.bbox_max[i], c_sigma.bbox_min[i] - c_tau.bbox_max[i])\n            dist_sq += d * d\n        \n        if dist_sq == 0:\n            return False  # Bounding boxes overlap or touch\n        \n        dist = np.sqrt(dist_sq)\n        max_diam = max(c_tau.diameter, c_sigma.diameter)\n        \n        return max_diam <= eta * dist\n\n    def count_blocks(root, eta):\n        \"\"\"Counts far-field and near-field blocks in the block-cluster tree.\"\"\"\n        far_count = 0\n        near_count = 0\n        \n        if root is None:\n            return 0, 0\n        \n        stack = [(root, root)]\n        \n        while stack:\n            c_tau, c_sigma = stack.pop()\n            \n            if is_admissible(c_tau, c_sigma, eta):\n                far_count += 1\n                continue\n            \n            # If not admissible, check if we must stop subdividing\n            if c_tau.children is None and c_sigma.children is None:\n                near_count += 1\n                continue\n                \n            # If we can subdivide, determine which cluster to split\n            split_tau = (c_tau.children is not None) and \\\n                        ((c_sigma.children is None) or (c_tau.diameter >= c_sigma.diameter))\n\n            if split_tau:\n                for child_tau in c_tau.children:\n                    stack.append((child_tau, c_sigma))\n            else:  # split_sigma\n                for child_sigma in c_sigma.children:\n                    stack.append((c_tau, child_sigma))\n\n        return far_count, near_count\n\n    R = 1.0\n    m = 16\n    \n    test_cases = [\n        (64, 0.5),\n        (64, 1.0),\n        (64, 2.0),\n        (8, 0.5),\n        (256, 0.5),\n    ]\n\n    results = []\n    for N, eta in test_cases:\n        points = generate_sphere_points(N, R)\n        \n        if N > 0:\n            root = Cluster(range(N), points)\n            build_cluster_tree(root, m, points)\n            far_blocks, near_blocks = count_blocks(root, eta)\n            total_blocks = far_blocks + near_blocks\n        \n            if total_blocks > 0:\n                fraction = far_blocks / total_blocks\n            else:\n                fraction = 0.0\n        else:\n            fraction = 0.0\n\n        results.append(round(fraction, 6))\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们已经知道远场块是可压缩的，但它们究竟能被压缩到什么程度？这个问题的答案在于它们的“数值秩”（numerical rank）。本练习旨在探索决定数值秩的关键因素，将抽象的数学概念与问题的物理本质联系起来。通过将基于物理原理的启发式公式与通过奇异值分解（SVD）得到的精确数值秩进行比较，您将深入理解为何以及何时可以实现高效的低秩近似。",
            "id": "4115752",
            "problem": "考虑由波数为 $k$ 的亥姆霍兹方程控制的三维时谐声场。自由空间格林函数由 $G(\\mathbf{x},\\mathbf{y}) = \\dfrac{e^{\\mathrm{i} k \\|\\mathbf{x} - \\mathbf{y}\\|}}{4 \\pi \\|\\mathbf{x} - \\mathbf{y}\\|}$ 给出。在层次矩阵方法中，对应于两个充分分离的簇之间相互作用的块允许低秩可分近似，并且自适应交叉近似 (Adaptive Cross Approximation, ACA) 可以恢复这种低秩结构。我们关注两个边长为 $a$ 的轴对齐立方体 $X$ 和 $Y$，其中心沿 $x$ 轴相距为 $d$；因此，最近的面间距为 $d-a$。这两个立方体被均匀离散化为笛卡尔张量网格，以形成稠密相互作用矩阵 $A \\in \\mathbb{C}^{n \\times n}$，其中 $A_{ij} = G(\\mathbf{x}_i,\\mathbf{y}_j)$，而 $\\{\\mathbf{x}_i\\}$ 和 $\\{\\mathbf{y}_j\\}$ 分别是 $X$ 和 $Y$ 中的网格点。\n\n从亥姆霍兹格林函数可分展开的加法定理以及层次矩阵的经典可容许性概念（充分分离的簇产生收敛的简并展开）出发，使用以下启发式方法来估计数值秩：\n- 令 $L$ 为同时满足分离尾部控制和振荡内容解析这两个约束的最小整数：\n  1. 分离尾部控制：选择 $L$ 使得 $L \\ge \\left\\lceil \\dfrac{\\ln(1/\\varepsilon)}{\\ln(d/a)} \\right\\rceil$，\n  2. 振荡内容解析：选择 $L$ 使得 $L \\ge \\left\\lceil k a \\right\\rceil$。\n- 球谐函数中最高阶为 $L$ 的可分展开包含 $(L+1)^2$ 个角模式；使用 $R_{\\text{heur}} = (L+1)^2$ 作为秩的估计值。\n\n此处 $\\varepsilon$ 表示在弗罗贝尼乌斯范数下期望的相对误差容限。为了数值验证此启发式方法，将每个立方体在每个空间维度上用 $N$ 个等距点进行离散化，每个立方体总共有 $n = N^3$ 个点。构建相互作用矩阵 $A$ 并计算通过截断奇异值分解 (SVD) 得到的最小整数秩 $R_{\\text{svd}}$，使得截断近似 $A_R$ 的相对弗罗贝尼乌斯误差满足\n$$\n\\frac{\\|A - A_R\\|_F}{\\|A\\|_F} \\le \\varepsilon,\n$$\n其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。使用面间距 $d-a$ 并将立方体中心放置在 $\\mathbf{c}_X = \\left(-\\dfrac{d}{2},\\,0,\\,0\\right)$ 和 $\\mathbf{c}_Y = \\left(\\dfrac{d}{2},\\,0,\\,0\\right)$。每个立方体相对于其中心占据 $[-a/2, a/2]^3$ 的空间。\n\n你的程序必须为以下测试套件实现启发式秩估计和基于 SVD 测量的最小秩，所有测试均在每个维度使用 $N=5$ 个点并使用上述格林函数：\n- 测试用例 1（正常情况）：$ka = 2$, $d/a = 6$, $\\varepsilon = 10^{-6}$。\n- 测试用例 2（更高频率）：$ka = 10$, $d/a = 6$, $\\varepsilon = 10^{-6}$。\n- 测试用例 3（接近可容许性边界）：$ka = 2$, $d/a = 1.2$, $\\varepsilon = 10^{-6}$。\n- 测试用例 4（低频）：$ka = 0.5$, $d/a = 6$, $\\varepsilon = 10^{-6}$。\n\n对于所有测试用例，设置 $a = 1$（单位：米），因此 $k = ka / a = ka$ 的单位是米$^{-1}$，而 $d = (d/a) \\cdot a$ 的单位是米。输出 $R_{\\text{heur}}$ 和 $R_{\\text{svd}}$ 是无单位的整数。\n\n你的程序应生成单行输出，其中包含一个逗号分隔的列表，列表括在方括号中。列表中的每个元素都是一个测试用例的结果对 `[R_heur,R_svd]`，顺序与上文所列一致。例如，输出格式必须完全是\n`[[R_heur_1,R_svd_1],[R_heur_2,R_svd_2],[R_heur_3,R_svd_3],[R_heur_4,R_svd_4]]`",
            "solution": "该问题要求对边界元矩阵特定块的启发式估计秩与数值计算秩进行比较。该矩阵源于与三维亥姆霍兹方程相关的积分算子的离散化。分析分为两部分：启发式秩 $R_{\\text{heur}}$ 的推导与计算，以及基于 SVD 的秩 $R_{\\text{svd}}$ 的数值计算。\n\n首先，我们讨论启发式秩估计 $R_{\\text{heur}}$。该估计的基础在于波传播的物理学，特别是使用可分展开（如球谐函数的加法定理）来表示自由空间格林函数 $G(\\mathbf{x},\\mathbf{y}) = \\frac{e^{\\mathrm{i} k \\|\\mathbf{x} - \\mathbf{y}\\|}}{4 \\pi \\|\\mathbf{x} - \\mathbf{y}\\|}$。对于两个充分分离的点簇 $X$ 和 $Y$，其相互作用块 $A$（其中 $A_{ij} = G(\\mathbf{x}_i, \\mathbf{y}_j)$）可以由一个低秩矩阵近似。此近似的秩取决于展开的阶数 $L$。问题提供了两个物理约束来确定一个充分的阶数 $L$。\n\n1.  **分离尾部控制**：此约束源于积分算子奇异值的衰减，而奇异值的衰减与簇之间的分离程度有关。对于特征尺寸为 $a$、相距为 $d$ 的簇，多极展开误差以比率 $a/d$ 呈几何级数衰减。为达到期望的相对精度 $\\varepsilon$，阶数 $L$ 必须足够大，以充分抑制展开中被截断的“尾部”。这给出了第一个条件：\n    $$L \\ge L_{\\text{sep}} = \\left\\lceil \\frac{\\ln(1/\\varepsilon)}{\\ln(d/a)} \\right\\rceil$$\n    对于充分分离的簇（$d/a \\gg 1$）和低频情况，此条件起主导作用。\n\n2.  **振荡内容解析**：此约束与应用于波场角分量的奈奎斯特-香农采样定理有关。为了在一个大小为 $a$ 的区域上准确表示波数为 $k$ 的波，基函数的数量必须与无量纲量 $ka$ 成正比。更高的频率（更大的 $k$）或更大的域（更大的 $a$）会引入更多必须被解析的振荡。在球谐函数的背景下，这引出了第二个条件：\n    $$L \\ge L_{\\text{osc}} = \\left\\lceil k a \\right\\rceil$$\n    在高频情况下，此条件变得主导，此时核函数的振荡性质是限制可压缩性的主要因素。\n\n所需的总展开阶数 $L$ 必须同时满足这两个约束，因此 $L = \\max(L_{\\text{sep}}, L_{\\text{osc}})$。一个阶数为 $L$ 的球谐函数展开包含 $(L+1)^2$ 个基函数。这个数量为数值秩提供了一个直接的启发式估计：\n$$R_{\\text{heur}} = (L+1)^2$$\n\n其次，我们计算数值秩 $R_{\\text{svd}}$ 作为基准。这包括以下步骤：\n1.  **离散化**：对两个立方体域 $X$ 和 $Y$ 进行离散化。每个立方体边长为 $a=1$，包含 $n=N^3$ 个点，其中每个维度上有 $N=5$ 个等距点。立方体的中心分别设为 $\\mathbf{c}_X = (-d/2, 0, 0)$ 和 $\\mathbf{c}_Y = (d/2, 0, 0)$。\n2.  **矩阵组装**：构建稠密的 $n \\times n$ 相互作用矩阵 $A$，其元素为 $A_{ij} = G(\\mathbf{x}_i, \\mathbf{y}_j)$，适用于所有点 $\\mathbf{x}_i \\in X$ 和 $\\mathbf{y}_j \\in Y$。\n3.  **奇异值分解 (SVD)**：计算矩阵 $A$ 的 SVD，得到奇异值 $\\sigma_0 \\ge \\sigma_1 \\ge \\dots \\ge \\sigma_{n-1} \\ge 0$。SVD 在弗罗贝尼乌斯范数下提供了最优的低秩近似。通过保留前 $R$ 个奇异值和奇异向量，可以构成一个秩为 $R$ 的近似 $A_R$。\n4.  **秩的确定**：秩为 $R$ 的近似误差由 $\\|A - A_R\\|_F = \\sqrt{\\sum_{i=R}^{n-1} \\sigma_i^2}$ 给出。相对弗罗贝尼乌斯误差是此误差与矩阵总范数 $\\|A\\|_F = \\sqrt{\\sum_{i=0}^{n-1} \\sigma_i^2}$ 的比值。我们寻找最小的整数秩 $R_{\\text{svd}}$，使得此相对误差不大于指定的容限 $\\varepsilon$：\n    $$\\frac{\\sqrt{\\sum_{i=R_{\\text{svd}}}^{n-1} \\sigma_i^2}}{\\sqrt{\\sum_{i=0}^{n-1} \\sigma_i^2}} \\le \\varepsilon$$\n    这等价于找到最小的 $R$，使得 $(\\sum_{i=R}^{n-1} \\sigma_i^2) \\le \\varepsilon^2 (\\sum_{i=0}^{n-1} \\sigma_i^2)$。这个值 $R$ 是通过从 $R=0$ 到 $n$ 遍历可能的秩，并选择第一个满足条件的秩来确定的。\n\n该程序为四个测试用例中的每一个都实现了这两个过程，从而提供了基于物理的启发式方法与精确数值秩之间的比较。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_R_heur(ka, da_ratio, epsilon):\n    \"\"\"\n    Calculates the heuristic rank estimate based on physical constraints.\n\n    Args:\n        ka (float): Dimensionless wavenumber.\n        da_ratio (float): Ratio of center-to-center distance to cube side length.\n        epsilon (float): Desired relative error tolerance.\n\n    Returns:\n        int: The heuristic rank estimate R_heur.\n    \"\"\"\n    # Separation-tail control constraint\n    # Note: np.log(da_ratio) is safe since all test cases have da_ratio > 1\n    L_sep = np.ceil(np.log(1.0 / epsilon) / np.log(da_ratio))\n    \n    # Oscillatory-content resolution constraint\n    L_osc = np.ceil(ka)\n    \n    # L is the maximum of the two constraints\n    L = int(np.max([L_sep, L_osc]))\n    \n    # Heuristic rank based on spherical harmonics expansion of order L\n    R_heur = (L + 1)**2\n    return R_heur\n\ndef calculate_R_svd(ka, da_ratio, epsilon, N, a):\n    \"\"\"\n    Constructs the interaction matrix and computes the SVD-based minimal rank.\n\n    Args:\n        ka (float): Dimensionless wavenumber.\n        da_ratio (float): Ratio of center-to-center distance to cube side length.\n        epsilon (float): Desired relative error tolerance.\n        N (int): Number of equispaced points per dimension.\n        a (float): Side length of the cubes.\n\n    Returns:\n        int: The SVD-based minimal rank R_svd.\n    \"\"\"\n    # Derived physical parameters\n    k = ka / a\n    d = da_ratio * a\n    n = N**3\n    \n    # 1. Generate grid points for a cube centered at the origin\n    coords_1d = np.linspace(-a / 2.0, a / 2.0, N)\n    # Use 'ij' indexing for consistency, then reshape to a list of (x,y,z) points\n    grid_rel = np.array(np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')).T.reshape(-1, 3)\n\n    # 2. Translate grid points to absolute positions for cubes X and Y\n    center_X = np.array([-d / 2.0, 0.0, 0.0])\n    center_Y = np.array([d / 2.0, 0.0, 0.0])\n    \n    points_X = grid_rel + center_X\n    points_Y = grid_rel + center_Y\n\n    # 3. Construct the interaction matrix A using broadcasting for efficiency\n    # points_X shape: (n, 3) -> (n, 1, 3)\n    # points_Y shape: (n, 3) -> (1, n, 3)\n    # diff shape: (n, n, 3)\n    diff = points_X[:, np.newaxis, :] - points_Y[np.newaxis, :, :]\n    \n    # dists shape: (n, n)\n    dists = np.linalg.norm(diff, axis=2)\n    \n    # Calculate Green's function for all pairs (Helmholtz kernel)\n    # Note: dists are never zero since cubes are separated in all test cases\n    A = np.exp(1j * k * dists) / (4.0 * np.pi * dists)\n    \n    # 4. Compute singular values (we only need the values, not the vectors)\n    s = np.linalg.svd(A, compute_uv=False)\n    \n    # 5. Find the minimal rank R_svd that satisfies the error tolerance\n    s_sq = s**2\n    total_norm_sq = np.sum(s_sq)\n    \n    # If the matrix is numerically zero, its rank is 0.\n    if total_norm_sq == 0:\n        return 0\n\n    target_error_sq = epsilon**2 * total_norm_sq\n    \n    # Loop through possible ranks R from 0 to n to find the smallest one\n    # that satisfies the error condition.\n    R_svd = n # Default to full rank if no smaller rank suffices\n    for R in range(n):\n        # Error for a rank-R approximation is the sum of squares of trailing singular values\n        error_sq = np.sum(s_sq[R:])\n        \n        if error_sq <= target_error_sq:\n            R_svd = R\n            break\n            \n    return R_svd\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define test cases as (ka, d/a, epsilon)\n    test_cases = [\n        (2.0, 6.0, 1e-6),   # Test case 1\n        (10.0, 6.0, 1e-6),  # Test case 2\n        (2.0, 1.2, 1e-6),   # Test case 3\n        (0.5, 6.0, 1e-6),   # Test case 4\n    ]\n\n    # Global parameters from the problem statement\n    N = 5\n    a = 1.0\n\n    final_result_strings = []\n    for ka, da_ratio, epsilon in test_cases:\n        R_heur = calculate_R_heur(ka, da_ratio, epsilon)\n        R_svd = calculate_R_svd(ka, da_ratio, epsilon, N, a)\n        # Format each pair as [R_heur,R_svd] without spaces\n        final_result_strings.append(f\"[{R_heur},{R_svd}]\")\n\n    # Combine all results into the final required format\n    print(f\"[{','.join(final_result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}