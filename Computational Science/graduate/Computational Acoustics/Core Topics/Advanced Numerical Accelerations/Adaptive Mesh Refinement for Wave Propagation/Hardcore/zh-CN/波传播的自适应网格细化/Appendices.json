{
    "hands_on_practices": [
        {
            "introduction": "波传播的数值模拟本质上是一种近似。一个关键挑战是，离散网格会扭曲波的传播方式，这种现象被称为数值色散。本练习将引导你推导数值相速度误差的精确解析表达式，揭示其如何依赖于网格间距和波数 。理解这种关系是智能设计能准确捕捉波物理特性的网格的第一步。",
            "id": "4116240",
            "problem": "考虑在声速 $c$ 恒定的均匀介质中，小振幅声扰动的一维传播，该过程由无穷域上的线性波动方程 $u_{tt} = c^{2} u_{xx}$ 建模。假设空间网格是均匀的，间距为 $h$，时间步长是均匀的，为 $\\Delta t$。在自适应网格加密（AMR）层级的每个网格上，假设在空间和时间上都使用相同的显式二阶中心差分格式，并采用时间子循环来维持所有加密层级上库朗数 $\\lambda = c \\Delta t / h$ 恒定。\n\n从线性波动方程出发，用时间上的二阶中心差分近似 $u_{tt}$，用空间上的二阶中心差分近似 $u_{xx}$，以获得全离散更新。通过代入平面波拟设 $u_{j}^{n} = \\Re\\{\\exp(i(k j h - \\omega n \\Delta t))\\}$（其中 $k$ 是物理波数，$\\omega$ 是角频率）进行 von Neumann 稳定性和色散分析，推导出连接无量纲时间频率 $\\Omega = \\omega \\Delta t$、无量纲空间波数 $\\theta = k h$ 和库朗数 $\\lambda$ 的离散色散关系。\n\n使用该离散色散关系，定义数值相速度 $v_{p,\\text{num}} = \\omega / k$ 和真实相速度 $v_{p,\\text{true}} = c$，并将归一化数值相速度误差 $E(k,h,\\Delta t) = v_{p,\\text{num}}/c - 1$ 确定为 $k$、$h$、$\\Delta t$ 和 $c$ 的精确解析函数。将最终答案表示为单个闭式表达式。无需四舍五入，该量是无量纲的；报告时无需单位。",
            "solution": "该问题要求推导一维线性波动方程标准有限差分离散的归一化数值相速度误差。\n\n控制小振幅声扰动传播的偏微分方程（PDE）是线性波动方程：\n$$\nu_{tt} = c^{2} u_{xx}\n$$\n其中 $u(x, t)$ 是扰动，$c$ 是恒定的声速，下标表示偏微分。\n\n我们在空间步长为 $h$、时间步长为 $\\Delta t$ 的均匀网格上对此方程进行离散化。令 $u_j^n$ 表示 $u(jh, n\\Delta t)$ 的数值近似。时间和空间导数的二阶中心有限差分近似为：\n$$\nu_{tt} \\approx \\frac{u_j^{n+1} - 2u_j^n + u_j^{n-1}}{(\\Delta t)^2}\n$$\n$$\nu_{xx} \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{h^2}\n$$\n将这些近似值代入波动方程，得到全离散格式：\n$$\n\\frac{u_j^{n+1} - 2u_j^n + u_j^{n-1}}{(\\Delta t)^2} = c^2 \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{h^2}\n$$\n这是一个显式格式。我们可以重新整理它来求解 $u_j^{n+1}$：\n$$\nu_j^{n+1} = 2u_j^n - u_j^{n-1} + \\left(\\frac{c \\Delta t}{h}\\right)^2 (u_{j+1}^n - 2u_j^n + u_{j-1}^n)\n$$\n引入库朗数 $\\lambda = \\frac{c \\Delta t}{h}$，方程简化为：\n$$\nu_j^{n+1} = 2u_j^n - u_j^{n-1} + \\lambda^2 (u_{j+1}^n - 2u_j^n + u_{j-1}^n)\n$$\n为了进行 von Neumann 稳定性和色散分析，我们将单个傅里叶模（一个平面波拟设）代入离散方程。由于方程是线性的且系数为实数，我们可以使用复数形式 $u_j^n = \\exp(i(kjh - \\omega n\\Delta t))$，其中 $k$ 是波数，$\\omega$ 是角频率。如问题陈述中所指定，得到的色散关系对于解的实部 $\\Re\\{\\exp(i(kjh - \\omega n\\Delta t))\\}$ 是有效的。\n\n离散方程中的各项变为：\n$u_j^{n\\pm 1} = \\exp(\\mp i\\omega\\Delta t) u_j^n$\n$u_{j\\pm 1}^n = \\exp(\\pm ikh) u_j^n$\n\n将这些代入格式中：\n$$\n\\exp(-i\\omega\\Delta t)u_j^n = 2u_j^n - \\exp(i\\omega\\Delta t)u_j^n + \\lambda^2 (\\exp(ikh)u_j^n - 2u_j^n + \\exp(-ikh)u_j^n)\n$$\n除以公因子 $u_j^n$（非零）并重新整理得到：\n$$\n\\exp(-i\\omega\\Delta t) + \\exp(i\\omega\\Delta t) - 2 = \\lambda^2 (\\exp(ikh) + \\exp(-ikh) - 2)\n$$\n使用欧拉恒等式 $2\\cos(x) = \\exp(ix) + \\exp(-ix)$，我们可以将其写为：\n$$\n2\\cos(\\omega\\Delta t) - 2 = \\lambda^2 (2\\cos(kh) - 2)\n$$\n提出因子 $-2$ 并使用半角三角恒等式 $1 - \\cos(x) = 2\\sin^2(x/2)$，我们得到：\n$$\n-2(1 - \\cos(\\omega\\Delta t)) = -2\\lambda^2(1 - \\cos(kh))\n$$\n$$\n2\\sin^2\\left(\\frac{\\omega\\Delta t}{2}\\right) = 2\\lambda^2\\sin^2\\left(\\frac{kh}{2}\\right)\n$$\n$$\n\\sin^2\\left(\\frac{\\omega\\Delta t}{2}\\right) = \\lambda^2\\sin^2\\left(\\frac{kh}{2}\\right)\n$$\n取平方根并考虑正向传播波的主支，得到离散色散关系：\n$$\n\\sin\\left(\\frac{\\omega\\Delta t}{2}\\right) = \\lambda \\sin\\left(\\frac{kh}{2}\\right)\n$$\n该关系将数值频率 $\\omega$ 与波数 $k$联系起来。由此，我们可以解出 $\\omega$：\n$$\n\\frac{\\omega\\Delta t}{2} = \\arcsin\\left(\\lambda \\sin\\left(\\frac{kh}{2}\\right)\\right)\n$$\n$$\n\\omega = \\frac{2}{\\Delta t} \\arcsin\\left(\\lambda \\sin\\left(\\frac{kh}{2}\\right)\\right)\n$$\n数值相速度定义为 $v_{p,\\text{num}} = \\omega/k$。代入 $\\omega$ 的表达式：\n$$\nv_{p,\\text{num}} = \\frac{2}{k\\Delta t} \\arcsin\\left(\\lambda \\sin\\left(\\frac{kh}{2}\\right)\\right)\n$$\n问题要求归一化数值相速度误差 $E = \\frac{v_{p,\\text{num}}}{c} - 1$。真实相速度为 $v_{p,\\text{true}} = c$。\n$$\nE = \\frac{v_{p,\\text{num}}}{c} - 1 = \\frac{1}{c} \\left[ \\frac{2}{k\\Delta t} \\arcsin\\left(\\lambda \\sin\\left(\\frac{kh}{2}\\right)\\right) \\right] - 1\n$$\n最后，我们代入 $\\lambda = \\frac{c \\Delta t}{h}$，用基本参数 $k$、$h$、$\\Delta t$ 和 $c$ 来表示误差：\n$$\nE = \\frac{2}{ck\\Delta t} \\arcsin\\left(\\frac{c\\Delta t}{h} \\sin\\left(\\frac{kh}{2}\\right)\\right) - 1\n$$\n这就是归一化数值相速度误差的最终闭式表达式。",
            "answer": "$$\\boxed{\\frac{2}{c k \\Delta t} \\arcsin\\left(\\frac{c \\Delta t}{h} \\sin\\left(\\frac{kh}{2}\\right)\\right) - 1}$$"
        },
        {
            "introduction": "在明确了*为什么*需要网格细化之后，实践中的问题就变成了*在哪里*进行细化。本练习将挑战你从第一性原理出发，设计并实现一个静态自适应网格细化策略 。你将基于两个关键指标来制定细化准则：解析局部波长以防止色散，以及在解曲率高的区域限制插值误差。这项实践将让你直接体验如何根据解的特征创建智能网格。",
            "id": "4116078",
            "problem": "给定一个声速随空间变化的一维声学介质，要求您为声压的时谐快照计算一个自适应网格加密配置。其目标是捕捉由短波长和剧烈振幅变化引起的关键小尺度效应，同时避免在其他区域过度加密。程序必须基于第一性原理为每个测试用例计算加密分布，并以指定的输出格式生成汇总摘要。\n\n物理模型是具有可变声速的一维空间线性声波方程，\n$$\n\\frac{\\partial^2 p}{\\partial t^2}(x,t) = c(x)^2 \\frac{\\partial^2 p}{\\partial x^2}(x,t),\n$$\n其中 $p(x,t)$ 是声压，$c(x)$ 是声速。考虑一个频率为 $f$（单位为 $\\mathrm{Hz}$）的时谐激励，并定义角频率 $\\omega = 2\\pi f$。对于一个缓慢变化的介质，局部空间波数为 $k(x) \\approx \\omega / c(x)$，局部波长为 $\\lambda(x) = c(x) / f$。\n\n我们考虑在 $t=0$ 时刻，空间分布如下的快照\n$$\np(x) = g(x) \\cos(\\phi(x)),\n$$\n其中\n$$\ng(x) = \\exp\\!\\left( -\\frac{(x-x_0)^2}{2\\sigma^2} \\right),\n\\quad\n\\phi(x) = \\omega s(x),\n\\quad\ns(x) = \\int_0^x \\frac{1}{c(\\xi)} \\,\\mathrm{d}\\xi,\n$$\n其中 $x \\in [0,L]$，$L$ 的单位是 $\\mathrm{m}$，中心 $x_0$ 的单位是 $\\mathrm{m}$，包络宽度参数 $\\sigma$ 的单位是 $\\mathrm{m}$。介质是分段常数的：\n$$\nc(x) =\n\\begin{cases}\nc_1,  & 0 \\le x \\le x_s,\\\\\nc_2,  & x_s < x \\le L,\n\\end{cases}\n$$\n其中 $c_1$ 和 $c_2$ 的单位是 $\\mathrm{m/s}$，界面位置 $x_s$ 的单位是 $\\mathrm{m}$。因此，\n$$\ns(x) =\n\\begin{cases}\n\\frac{x}{c_1},  & 0 \\le x \\le x_s,\\\\\n\\frac{x_s}{c_1} + \\frac{x-x_s}{c_2},  & x_s < x \\le L.\n\\end{cases}\n$$\n\n您必须从 $[0,L]$ 上的一个包含 $N_0$ 个单元的均匀基础网格（基础单元尺寸 $h_0 = L / N_0$）开始，构建一个静态自适应网格加密配置。每个中心为 $x_i$ 的基础单元 $i$ 可以通过二分法加密成 $2^{L_i}$ 个叶单元，其中 $L_i \\in \\{0,1,2,\\dots\\}$ 是局部加密等级。加密等级 $L_i$ 由满足以下两个约束条件的最小等级确定，使得加密后的单元尺寸 $h_i = h_0 / 2^{L_i}$ 成立：\n\n1. 波长分辨率约束，确保每个局域波长内至少有 $M_{\\min}$ 个点：\n$$\nh_i \\le \\frac{\\lambda(x_i)}{M_{\\min}} = \\frac{c(x_i)}{f\\, M_{\\min}}.\n$$\n\n2. 基于插值误差的约束。对于一个尺寸为 $h$ 的单元上的二阶连续可微函数，其泰勒余项的界为一个常数乘以 $h^2$ 再乘以二阶导数的上确界。使用线性插值误差的经典界，\n$$\nE_{\\text{lin}} \\le \\frac{h^2}{8} \\sup_{\\text{cell}} \\left| \\frac{\\mathrm{d}^2 p}{\\mathrm{d}x^2} \\right|,\n$$\n强制要求\n$$\n\\frac{h_i^2}{8} \\left| p''(x_i) \\right| \\le \\tau,\n$$\n其中 $\\tau$ 是用户指定的振幅误差容限（无量纲），这得到了由曲率驱动的约束\n$$\nh_i \\le \\sqrt{\\frac{8 \\tau}{\\left| p''(x_i) \\right| + \\varepsilon}},\n$$\n其中有一个小的正则化项 $\\varepsilon > 0$ 以避免除以零。\n\n为避免在声场可忽略的区域过度加密，应用一个振幅保护：如果局部振幅满足 $|p(x_i)| < A_{\\min}$（无量纲），则无论上述约束如何，都设置 $L_i = 0$。此保护措施可防止在场值太小而没有意义的区域进行加密。\n\n就本问题而言，在远离界面 $x_s$ 的地方，使用乘法法则处理 $p''(x)$，并设 $\\phi''(x)=0$ 几乎处处成立（因为 $c(x)$ 是分段常数）。使用 $g'(x) = -\\frac{x-x_0}{\\sigma^2} g(x)$ 和 $g''(x) = \\left( \\frac{(x-x_0)^2}{\\sigma^4} - \\frac{1}{\\sigma^2} \\right) g(x)$，并记 $a(x) = \\cos(\\phi(x))$ 和 $b(x) = \\sin(\\phi(x))$，可以得到\n$$\np''(x) = g''(x)\\, a(x) \\;-\\; 2 g'(x)\\, \\phi'(x)\\, b(x) \\;-\\; g(x)\\, \\left( \\phi'(x) \\right)^2 a(x),\n$$\n其中 $\\phi'(x) = \\omega / c(x)$ 且对于 $x \\ne x_s$ 有 $\\phi''(x)=0$。\n\n为每个测试用例定义以下汇总输出：\n- 叶单元总数，\n$$\nN_{\\text{leaf}} = \\sum_{i=0}^{N_0-1} 2^{L_i},\n$$\n- 使用的最大加密等级，\n$$\nL_{\\max} = \\max_i L_i,\n$$\n- 不使用振幅保护时的假设过度加密比率，计算方法为：如果不应用振幅保护，在 $|p(x_i)| < A_{\\min}$ 的区域中将被加密的叶单元数占总叶单元数的比例，\n$$\nR_{\\text{waste}} = \\frac{\\sum_{i: |p(x_i)| < A_{\\min}} 2^{\\widetilde{L}_i}}{\\sum_{i=0}^{N_0-1} 2^{\\widetilde{L}_i}},\n$$\n其中 $\\widetilde{L}_i$ 是通过相同约束但不考虑振幅保护所获得的加密等级。\n\n所有物理量必须使用以下单位：\n- 域长度 $L$ 单位为 $\\mathrm{m}$。\n- 声速 $c_1$ 和 $c_2$ 单位为 $\\mathrm{m/s}$。\n- 频率 $f$ 单位为 $\\mathrm{Hz}$。\n- 振幅容限 $\\tau$ 是无量纲的。\n- 振幅保护阈值 $A_{\\min}$ 是无量纲的。\n- 包络宽度参数 $\\sigma$ 和位置 $x$、$x_0$、$x_s$ 单位为 $\\mathrm{m}$。\n\n角度使用弧度。不应使用百分号；比率必须表示为小数。\n\n所有测试用例均使用以下固定的域和基础网格：\n- 域 $[0,L]$，其中 $L = 1$。\n- 基础单元数量 $N_0 = 64$，因此 $h_0 = L / N_0$。\n- 声速值 $c_1 = 1500$, $c_2 = 1800$，界面位于 $x_s = 0.6$。\n\n您的程序必须为下面指定的四个测试用例计算自适应加密配置。对于每个用例，使用给定的参数和上述规则计算 $N_{\\text{leaf}}$、$L_{\\max}$ 和 $R_{\\text{waste}}$。\n\n测试套件（每个元组为 $(f, \\sigma, M_{\\min}, A_{\\min}, \\tau, x_0)$）：\n1. $(8000, 0.03, 12, 0.05, 0.005, 0.30)$\n2. $(20000, 0.02, 16, 0.01, 0.003, 0.40)$\n3. $(1500, 0.08, 10, 0.05, 0.008, 0.25)$\n4. $(12000, 0.025, 14, 0.02, 0.004, 0.58)$\n\n最终输出格式必须是包含四个结果列表的单行，每个测试用例一个结果，其中每个结果本身是按 $[N_{\\text{leaf}}, L_{\\max}, R_{\\text{waste}}]$ 顺序排列的列表。例如，输出必须如下所示\n$$\n[ [N_1, L_{\\max,1}, R_1], [N_2, L_{\\max,2}, R_2], [N_3, L_{\\max,3}, R_3], [N_4, L_{\\max,4}, R_4] ].\n$$",
            "solution": "该问题要求为一维声波传播场景设计一个静态自适应网格加密（AMR）配置。目标是为一个域上的一组基础单元确定局部加密等级，其依据的准则要能确保对局域波长和解的高曲率区域都有足够的解析度，同时避免在波振幅可忽略的区域进行不必要的加密。\n\n物理模型是在声速 $c(x)$ 随空间变化的介质中的线性声波方程：\n$$\n\\frac{\\partial^2 p}{\\partial t^2}(x,t) = c(x)^2 \\frac{\\partial^2 p}{\\partial x^2}(x,t)\n$$\n我们分析在 $t=0$ 时刻压力场 $p(x)$ 的时谐快照，其表达式为：\n$$\np(x) = g(x) \\cos(\\phi(x))\n$$\n其中 $g(x)$ 是一个高斯包络，$\\phi(x)$ 是空间相位。各分量定义如下：\n- 包络：$g(x) = \\exp\\!\\left( -\\frac{(x-x_0)^2}{2\\sigma^2} \\right)$\n- 相位：$\\phi(x) = \\omega s(x) = 2\\pi f s(x)$，其中 $s(x)$ 是从原点开始的声学传播时间。\n\n域为 $x \\in [0, L]$，其中 $L=1 \\, \\mathrm{m}$。声速 $c(x)$ 是分段常数：\n$$\nc(x) =\n\\begin{cases}\nc_1 = 1500 \\, \\mathrm{m/s},  & 0 \\le x \\le x_s = 0.6 \\, \\mathrm{m} \\\\\nc_2 = 1800 \\, \\mathrm{m/s},  & 0.6 \\, \\mathrm{m} < x \\le 1 \\, \\mathrm{m}\n\\end{cases}\n$$\n这导出了传播时间函数：\n$$\ns(x) = \\int_0^x \\frac{1}{c(\\xi)} \\,\\mathrm{d}\\xi =\n\\begin{cases}\n\\frac{x}{c_1},  & 0 \\le x \\le x_s \\\\\n\\frac{x_s}{c_1} + \\frac{x-x_s}{c_2},  & x_s < x \\le L\n\\end{cases}\n$$\n计算域 $[0, L]$ 最初被离散化为一个包含 $N_0 = 64$ 个单元的均匀基础网格。基础单元尺寸为 $h_0 = L / N_0 = 1/64 \\, \\mathrm{m}$。加密准则在每个基础单元 $i$ 的中心进行评估，该中心位于 $x_i = (i + 0.5)h_0$，其中 $i = 0, 1, \\dots, N_0-1$。\n\n对于每个基础单元 $i$，我们确定一个加密等级 $L_i \\in \\{0, 1, 2, \\dots\\}$，这对应于将该单元细分为 $2^{L_i}$ 个尺寸为 $h_i = h_0 / 2^{L_i}$ 的更小的叶单元。等级 $L_i$ 是满足一系列条件的最小非负整数。该过程首先确定不带振幅保护时所需的等级，记为 $\\widetilde{L}_i$，然后应用保护措施得到最终等级 $L_i$。\n\n首先，我们基于两个物理和数值约束，计算单元 $i$ 所需的单元尺寸 $h_{i, \\text{req}}$：\n\n1.  **波长分辨率约束**：为了精确表示波的振荡特性，局部单元尺寸 $h_i$ 必须是局域波长 $\\lambda(x_i) = c(x_i)/f$ 的一小部分。该约束确保每个波长至少有 $M_{\\min}$ 个网格点：\n    $$\n    h_i \\le h_{i, \\text{wave}} = \\frac{\\lambda(x_i)}{M_{\\min}} = \\frac{c(x_i)}{f M_{\\min}}\n    $$\n\n2.  **插值误差约束**：为了限制在单元内近似解（例如，使用线性基函数）所产生的误差，必须在曲率高的区域控制单元尺寸。该约束基于泰勒级数余项，它将误差与解的二阶导数 $p''(x_i)$ 联系起来。\n    $$\n    h_i \\le h_{i, \\text{curv}} = \\sqrt{\\frac{8 \\tau}{|p''(x_i)| + \\varepsilon}}\n    $$\n    这里，$\\tau$ 是一个指定的容限，$\\varepsilon$ 是一个小的正常数（例如 $\\varepsilon=10^{-12}$），用于在曲率为空时防止除以零。对于 $x \\neq x_s$，二阶导数 $p''(x)$ 使用乘法法则计算：\n    $$\n    p''(x) = g''(x) \\cos(\\phi(x)) - 2g'(x)\\phi'(x) \\sin(\\phi(x)) - g(x) (\\phi'(x))^2 \\cos(\\phi(x))\n    $$\n    其中 $\\phi'(x) = \\omega/c(x)$，$g'(x) = -\\frac{x-x_0}{\\sigma^2}g(x)$，以及 $g''(x) = \\left(\\frac{(x-x_0)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right)g(x)$。\n\n这两个约束中最严格的一个决定了单元 $i$ 所需的单元尺寸：\n$$\nh_{i, \\text{req}} = \\min(h_{i, \\text{wave}}, h_{i, \\text{curv}})\n$$\n由此，加密等级 $\\widetilde{L}_i$（不带振幅保护）是使 $h_0 / 2^{\\widetilde{L}_i} \\le h_{i, \\text{req}}$ 成立的最小整数。其计算方式如下：\n$$\n\\widetilde{L}_i = \\max\\left(0, \\left\\lceil \\log_2\\left(\\frac{h_0}{h_{i, \\text{req}}}\\right)\\right\\rceil\\right)\n$$\n其中上取整函数 $\\lceil \\cdot \\rceil$ 确保不等式得到满足，而 max 函数确保等级为非负。\n\n接下来，应用**振幅保护**。此规则可防止在解的振幅可忽略的区域进行加密，从而节省计算资源。\n$$\n\\text{如果 } |p(x_i)| < A_{\\min}, \\text{ 则 } L_i = 0. \\text{ 否则, } L_i = \\widetilde{L}_i.\n$$\n这个两步过程为每个基础单元生成最终的加密等级 $L_i$。\n\n最后，对于每个测试用例，我们从所有等级的集合 $\\{L_i\\}$ 和 $\\{\\widetilde{L}_i\\}$ 中计算三个汇总指标：\n-   **叶单元总数 ($N_{\\text{leaf}}$)**：最终自适应网格中的单元总数。\n    $$\n    N_{\\text{leaf}} = \\sum_{i=0}^{N_0-1} 2^{L_i}\n    $$\n-   **最大加密等级 ($L_{\\max}$)**：在域中任何地方使用的最深加密等级。\n    $$\n    L_{\\max} = \\max_{i} L_i\n    $$\n-   **过度加密比率 ($R_{\\text{waste}}$)**：在（未使用保护的）网格中，位于振幅低于阈值 $A_{\\min}$ 区域的单元占总单元的比例。该指标量化了由振幅保护带来的效率增益。\n    $$\n    R_{\\text{waste}} = \\frac{\\sum_{i: |p(x_i)| < A_{\\min}} 2^{\\widetilde{L}_i}}{\\sum_{j=0}^{N_0-1} 2^{\\widetilde{L}_j}}\n    $$\n\n计算流程包括遍历四个测试用例，设置相应参数，为所有 $N_0=64$ 个基础单元评估上述量，然后计算最终的汇总指标。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes adaptive mesh refinement configurations for a 1D acoustic wave problem.\n    \"\"\"\n    \n    # Fixed domain and base mesh parameters\n    L = 1.0  # Domain length in m\n    N0 = 64  # Number of base cells\n    h0 = L / N0  # Base cell size in m\n    c1 = 1500.0  # Sound speed in first medium in m/s\n    c2 = 1800.0  # Sound speed in second medium in m/s\n    xs = 0.6  # Interface location in m\n    epsilon = 1e-12  # Regularization for curvature constraint\n\n    # Base cell centers\n    x = (np.arange(N0) + 0.5) * h0\n\n    # Test suite: (f, sigma, M_min, A_min, tau, x0)\n    test_cases = [\n        (8000.0, 0.03, 12, 0.05, 0.005, 0.30),\n        (20000.0, 0.02, 16, 0.01, 0.003, 0.40),\n        (1500.0, 0.08, 10, 0.05, 0.008, 0.25),\n        (12000.0, 0.025, 14, 0.02, 0.004, 0.58),\n    ]\n\n    results = []\n    \n    # Vectorized helper functions based on the problem description\n    def get_c(x_vals):\n        return np.where(x_vals <= xs, c1, c2)\n\n    def get_s(x_vals):\n        return np.where(x_vals <= xs, x_vals / c1, xs / c1 + (x_vals - xs) / c2)\n\n    for case in test_cases:\n        f, sigma, M_min, A_min, tau, x0 = case\n        \n        omega = 2.0 * np.pi * f\n        \n        # Calculate physical quantities at all cell centers\n        c_vals = get_c(x)\n        s_vals = get_s(x)\n                \n        # Wave profile\n        phi_vals = omega * s_vals\n        g_vals = np.exp(-((x - x0)**2) / (2.0 * sigma**2))\n        p_vals = g_vals * np.cos(phi_vals)\n        \n        # Second derivative p''(x)\n        g_prime_vals = -((x - x0) / sigma**2) * g_vals\n        g_prime_prime_vals = (((x - x0)**2 / sigma**4) - (1.0 / sigma**2)) * g_vals\n        phi_prime_vals = omega / c_vals\n        \n        cos_phi = np.cos(phi_vals)\n        sin_phi = np.sin(phi_vals)\n        \n        p_prime_prime_vals = (g_prime_prime_vals * cos_phi \n                              - 2.0 * g_prime_vals * phi_prime_vals * sin_phi \n                              - g_vals * phi_prime_vals**2 * cos_phi)\n\n        # 1. Wavelength resolution constraint\n        lambda_vals = c_vals / f\n        h_wave = lambda_vals / M_min\n        \n        # 2. Interpolation error (curvature) constraint\n        h_curv = np.sqrt(8.0 * tau / (np.abs(p_prime_prime_vals) + epsilon))\n        \n        # Required cell size (most restrictive)\n        h_req = np.minimum(h_wave, h_curv)\n        \n        # Refinement level without amplitude guard\n        # Use np.maximum with 1.0 to avoid log2 of numbers < 1 giving negative results\n        ratio = h0 / h_req\n        tilde_L = np.ceil(np.log2(np.maximum(1.0, ratio))).astype(int)\n\n        # Apply amplitude guard\n        L = np.where(np.abs(p_vals) < A_min, 0, tilde_L)\n        \n        # Calculate aggregate metrics\n        N_leaf = int(np.sum(2**L))\n        L_max = int(np.max(L) if L.size > 0 else 0)\n        \n        # Calculate waste ratio\n        tilde_leaf_cells = 2**tilde_L\n        total_tilde_cells = np.sum(tilde_leaf_cells)\n        \n        waste_mask = np.abs(p_vals) < A_min\n        wasted_cells = np.sum(tilde_leaf_cells[waste_mask])\n        \n        R_waste = wasted_cells / total_tilde_cells if total_tilde_cells > 0 else 0.0\n\n        results.append([N_leaf, L_max, round(R_waste, 8)])\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "任何数值技术的最终考验是其在具有挑战性的、物理相关的问题上的表现。在最后的这个实践中，你将应用AMR来模拟波穿过聚焦透镜的传播，该场景的特点是波相位存在剧烈的空间振荡 。通过同时实现自适应和均匀网格的积分器，并将其结果与精确的解析解进行比较，你将能够定量地衡量AMR所带来的显著精度提升。本练习凸显了自适应方法在计算声学中的实用威力。",
            "id": "4116221",
            "problem": "您需要设计并实现一个完整的、可运行的程序，用于评估自适应网格加密（AMR）在积分由标量声波传播中薄聚焦透镜产生的快速振荡相位时，对数值精度的影响。该场景在横向坐标上是严格一维的，并基于标量时谐声学框架。所有长度单位必须是米，波长单位也是米。所要求的数值输出是无量纲的。\n\n从标量声波方程及其时谐简化形式开始。使用以下基本基础：标量波动方程 $\\nabla^2 p - \\dfrac{1}{c^2}\\dfrac{\\partial^2 p}{\\partial t^2} = 0$，时谐假设（ansatz）$p(\\mathbf{r},t) = \\Re\\{U(\\mathbf{r}) e^{-i \\omega t}\\}$ 导出亥姆霍兹方程 $\\nabla^2 U + k^2 n^2 U = 0$（其中 $k = \\dfrac{2\\pi}{\\lambda}$），以及从孔径传播到距离为 $z$ 的光轴（声轴）上的观察点的菲涅耳（傍轴）衍射近似。将焦距为 $f$ 的薄二次聚焦透镜建模为对入射平面波施加一个空间变化的相位。在傍轴近似下，透镜后距离 $z$ 处、通过半宽为 $a$ 的一维孔径传播的轴上场，可以简化为在孔径上的一个二次相位指数形式的单一振荡积分。仅从这些基础出发，推导出相位函数 $\\phi(y)$ 以及表征局部相位曲率作为 $\\lambda$、$z$ 和 $f$ 的函数的相应曲率参数，不得使用快捷公式。\n\n将轴上场的参考解定义为此二次相位积分在有限孔径上的精确值，该值可通过围线积分方法或标准复高斯积分，用复误差函数解析地表达出来。您必须使用数值上可靠的特殊函数求值来实现此精确参考解。\n\n设计两种数值积分策略来计算同一个孔径积分：\n- 在具有指定区间数 $N$ 的均匀网格上使用复化梯形法则。\n- 一种自适应网格加密（AMR）策略，其中局部单元尺寸 $h$ 由从相位函数 $\\phi(y)$ 推导出的相位控制准则确定。具体来说，对于宽度为 $h = y_1 - y_0$ 的单元 $[y_0,y_1]$，强制施加同步边界条件，控制单元上的最大相位梯度贡献和相位曲率贡献均不大于用户指定的相位容差 $\\varphi_{\\mathrm{tol}}$（单位为弧度）。使用相位的一阶和二阶导数 $\\phi'(y)$ 和 $\\phi''(y)$，设计一个形式为“如果基于梯度的界或基于曲率的界被违反，则进行加密”的充分加密测试。AMR 算法必须递归地二分任何未通过此测试的区间，直到满足边界条件为止。在自适应网格上的最终数值积分必须使用复化梯形法则。\n\n为了在相当的计算成本下对精度进行公平比较，请选择均匀复化梯形法则的区间数 $N$ 与您的 AMR 算法对相同参数集生成的自适应区间数完全相等。\n\n实现以下参数集的测试套件，每个参数集由 $(\\lambda, f, a, z)$ 描述，单位均为米：\n- 情况 A（中等相位曲率）：$(\\lambda, f, a, z) = (0.008, 1.0, 0.05, 0.8)$。\n- 情况 B（近焦点，最小振荡）：$(\\lambda, f, a, z) = (0.008, 1.0, 0.05, 1.0)$。\n- 情况 C（高相位曲率）：$(\\lambda, f, a, z) = (0.008, 1.0, 0.10, 0.2)$。\n\n对于每种情况，计算：\n- 精确的复孔径积分值（参考解），从第一性原理推导。\n- 均匀网格复化梯形积分，其中 $N$ 等于自适应区间的数量。\n- 您的 AMR 策略在固定的相位容差 $\\varphi_{\\mathrm{tol}}$ 下生成的自适应网格复化梯形积分。\n\n测量两种数值策略相对于参考解的复值积分绝对误差。然后，将 AMR 的精度增益量化为每种情况下均匀网格误差与自适应网格误差之比。如果任一误差在数值上为零，请以数值稳健的方式处理该比率，避免产生无穷大或 NaN。\n\n您的程序必须：\n- 使用 $\\varphi_{\\mathrm{tol}} = 0.3$ 弧度。\n- 将所有长度和波长单位视为米。输出为无量纲的误差比率。\n- 生成单行输出，包含一个含三个浮点数的列表，分别为情况 A、B、C 的精度增益比，按此顺序排列，格式化为 Python 列表字面量，例如 $[r_A,r_B,r_C]$。\n\n您的推导和实现必须是科学上现实且自洽的。程序必须是完全自包含的，并且不需要用户输入。最终输出必须是浮点数。",
            "solution": "该问题要求设计并实现一个数值实验，以评估自 adaptive 网格加密（AMR）策略与均匀网格相比，在对一个高度振荡函数进行积分时的有效性。该函数出现在标量声波通过薄聚焦透镜传播的背景下。下文将遵循数学物理的严格原则，详细介绍其推导、数值方法和比较。\n\n### 1. 场积分的推导\n\n分析始于压力扰动 $p$ 的标量声波方程：\n$$ \\nabla^2 p - \\frac{1}{c^2}\\frac{\\partial^2 p}{\\partial t^2} = 0 $$\n假设一个形式为 $p(\\mathbf{r}, t) = \\Re\\{U(\\mathbf{r}) e^{-i \\omega t}\\}$ 的时谐解，其中 $U(\\mathbf{r})$ 是复压力振幅，$\\omega$ 是角频率，且 $i = \\sqrt{-1}$，波动方程简化为亥姆霍兹方程：\n$$ \\nabla^2 U + k^2 n^2 U = 0 $$\n这里，$k = 2\\pi/\\lambda = \\omega/c$ 是在真空（或声速为 $c$ 的参考介质）中的波数，$\\lambda$ 是波长，$n$ 是折射率。对于在均匀介质中的传播，我们设 $n=1$。\n\n我们考虑一个初始平面波前，在 $z=0$ 平面沿 $y$ 方向通过一个半宽为 $a$ 的一维孔径的传播。在傍轴近似下，距离为 $z$ 的光轴上一个观察点的场由菲涅耳衍射积分描述。对于一维孔径，$(0, z)$ 处的场由下式给出：\n$$ U(0, z) \\propto \\int_{-a}^{a} U(y, 0^+) e^{i k \\frac{y^2}{2z}} dy $$\n其中 $U(y, 0^+)$ 是在 $z=0$ 处紧随孔径之后的复场。\n\n一个位于 $z=0$、焦距为 $f$ 的薄二次聚焦透镜对入射波施加一个相位变换。对于单位振幅的入射平面波 $U_{inc}(y) = 1$，紧随透镜之后的场为：\n$$ U(y, 0^+) = U_{inc}(y) \\cdot T_{lens}(y) = 1 \\cdot e^{-i k \\frac{y^2}{2f}} $$\n指数中的负号对应一个会聚透镜，它施加一个二次相位延迟，使离轴相位提前，从而将光线汇聚到焦点。\n\n将此场代入菲涅耳积分，我们得到轴上复振幅的表达式，除去一个比例常数外为：\n$$ I = \\int_{-a}^{a} e^{-i k \\frac{y^2}{2f}} e^{i k \\frac{y^2}{2z}} dy = \\int_{-a}^{a} e^{i \\frac{k}{2} \\left(\\frac{1}{z} - \\frac{1}{f}\\right) y^2} dy $$\n该积分由一个二次相位函数 $\\phi(y)$ 定义。我们可以将积分项写为 $e^{i\\phi(y)}$，其中：\n$$ \\phi(y) = \\alpha y^2 $$\n参数 $\\alpha$ 代表有效二次相位曲率，定义为：\n$$ \\alpha = \\frac{k}{2} \\left(\\frac{1}{z} - \\frac{1}{f}\\right) = \\frac{\\pi}{\\lambda} \\left(\\frac{1}{z} - \\frac{1}{f}\\right) $$\n因此，问题简化为计算复值积分 $I = \\int_{-a}^{a} e^{i \\alpha y^2} dy$。\n\n### 2. 解析参考解\n\n积分 $I = \\int_{-a}^{a} e^{i \\alpha y^2} dy$ 是菲涅耳积分的一种形式，可以使用复误差函数 $\\mathrm{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2} dt$ 解析求解。\n\n对于 $\\alpha \\neq 0$ 的情况，我们进行变量替换。令 $s = y\\sqrt{-i\\alpha}$，则 $y = s/\\sqrt{-i\\alpha}$ 且 $dy = ds/\\sqrt{-i\\alpha}$。积分限变为 $\\pm a\\sqrt{-i\\alpha}$。\n$$ I = \\int_{-a\\sqrt{-i\\alpha}}^{a\\sqrt{-i\\alpha}} e^{-s^2} \\frac{ds}{\\sqrt{-i\\alpha}} = \\frac{1}{\\sqrt{-i\\alpha}} \\left[ \\int_{-a\\sqrt{-i\\alpha}}^{0} e^{-s^2} ds + \\int_{0}^{a\\sqrt{-i\\alpha}} e^{-s^2} ds \\right] $$\n利用性质 $\\int_{-z}^0 = -\\int_0^{-z}$ 和误差函数的定义，上式可简化为：\n$$ I = \\frac{1}{\\sqrt{-i\\alpha}} \\frac{\\sqrt{\\pi}}{2} \\left[ \\mathrm{erf}(a\\sqrt{-i\\alpha}) - \\mathrm{erf}(-a\\sqrt{-i\\alpha}) \\right] $$\n由于 $\\mathrm{erf}(-z) = -\\mathrm{erf}(z)$，精确解为：\n$$ I_{exact} = \\sqrt{\\frac{\\pi}{-i\\alpha}} \\mathrm{erf}(a\\sqrt{-i\\alpha}) \\quad (\\text{对于 } \\alpha \\neq 0) $$\n必须使用复数平方根的主支。\n\n对于 $\\alpha = 0$ 的特殊情况（发生在焦平面 $z=f$ 处），被积函数变为 1：\n$$ I_{exact} = \\int_{-a}^{a} e^{0} dy = 2a \\quad (\\text{对于 } \\alpha = 0) $$\n这种情况对应于焦平面处的夫琅禾费衍射极限，此时轴上场简单地与孔径面积（或一维情况下的宽度）成正比。\n\n### 3. 数值积分策略\n\n#### 复化梯形法则\n对于由一组点 $\\{y_j\\}_{j=0}^M$ 定义的网格，积分通过对每个子区间 $[y_j, y_{j+1}]$ 上的梯形面积求和来近似：\n$$ I_{trapz} = \\sum_{j=0}^{M-1} \\frac{f(y_j) + f(y_{j+1})}{2} (y_{j+1} - y_j) $$\n其中 $f(y) = e^{i\\alpha y^2}$。对于在 $[-a, a]$ 上有 $N$ 个区间的均匀网格，步长是常数 $h = 2a/N$，点为 $y_j = -a + jh$。\n\n#### 自适应网格加密 (AMR)\nAMR 策略调整局部单元尺寸 $h$ 以维持指定的精度水平。加密决策基于相位函数 $\\phi(y) = \\alpha y^2$ 的局部行为。其导数为 $\\phi'(y) = 2\\alpha y$ 和 $\\phi''(y) = 2\\alpha$。一个区间 $[y_0, y_1]$（宽度 $h=y_1-y_0$）被递归地二分，直到它满足基于相位容差 $\\varphi_{\\mathrm{tol}}$ 的两个条件。\n\n1.  **基于梯度的准则**：此条件确保区间上的总相位变化有界，这对于准确解析振荡是必需的。区间上的相位变化为 $|\\phi(y_1) - \\phi(y_0)|$。根据中值定理，这等于 $|\\phi'(\\xi)|h$，其中 $\\xi \\in (y_0, y_1)$。为确保此值小于 $\\varphi_{\\mathrm{tol}}$，我们使用区间内最大梯度施加一个更严格的条件：\n    $$ h \\cdot \\max_{y \\in [y_0, y_1]} |\\phi'(y)| \\le \\varphi_{\\mathrm{tol}} $$\n    由于 $\\phi'(y)$ 是单调的，最大值出现在模最大的端点处。条件是：$h \\cdot |2\\alpha| \\cdot \\max(|y_0|, |y_1|) \\le \\varphi_{\\mathrm{tol}}$。\n\n2.  **基于曲率的准则**：此条件确保区间上的相位函数能被一条直线很好地近似。二次相位与其端点连接弦的最大偏差发生在中点，大约为 $\\frac{h^2}{8}|\\phi''(y_c)|$，其中 $y_c$ 是区间中心。我们对此偏差进行限定：\n    $$ \\frac{h^2}{8} |\\phi''(y)| \\le \\varphi_{\\mathrm{tol}} $$\n    由于 $\\phi''(y) = 2\\alpha$ 是常数，这简化为：$\\frac{|\\alpha|h^2}{4} \\le \\varphi_{\\mathrm{tol}}$。\n\n如果这两个条件中的任何一个被违反，区间就会被二分。算法从整个区间 $[-a, a]$ 开始，持续进行直到所有生成的子区间都满足这两个准则。最终的积分是在得到的非均匀网格上使用复化梯形法则计算的。\n\n### 4. 比较与实现\nAMR 方法的精度与具有等效函数求值次数的均匀网格方法进行比较。这是通过将均匀网格的区间数 $N_{uniform}$ 设置为等于 AMR 算法对给定参数集生成的总区间数 $N_{adaptive}$ 来实现的。\n\n精度增益由绝对误差之比量化：\n$$ R = \\frac{|\\text{Error}_{uniform}|}{|\\text{Error}_{adaptive}|} = \\frac{|I_{uniform} - I_{exact}|}{|I_{adaptive} - I_{exact}|} $$\n对自适应误差在数值上为零的情况进行了特殊处理，以避免除以零，同时正确反映性能增益。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the adaptive mesh refinement problem for acoustic wave propagation.\n    \"\"\"\n    \n    # Test cases defined as (lambda, f, a, z), all in meters.\n    test_cases = [\n        (0.008, 1.0, 0.05, 0.8),  # Case A: Moderate curvature\n        (0.008, 1.0, 0.05, 1.0),  # Case B: Near focus (zero curvature)\n        (0.008, 1.0, 0.10, 0.2),  # Case C: High curvature\n    ]\n    \n    # Phase tolerance for the AMR algorithm, in radians.\n    phi_tol = 0.3\n    \n    results = []\n\n    for lmbda, f, a, z in test_cases:\n        # 1. Calculate physical and integral parameters\n        k = 2 * np.pi / lmbda\n        \n        # Avoid division by zero if z is exactly 0\n        if np.abs(z) < 1e-15:\n            alpha = -np.inf # or handle as an error\n        else:\n            alpha = (np.pi / lmbda) * (1 / z - 1 / f)\n\n        # Integrand function\n        def integrand(y_vals, alpha_val):\n            if np.abs(alpha_val) < 1e-15:\n                return np.ones_like(y_vals, dtype=complex)\n            return np.exp(1j * alpha_val * y_vals**2)\n\n        # 2. Calculate the exact reference solution\n        if np.abs(alpha) < 1e-15:\n            # Special case for z = f, where alpha = 0.\n            I_exact = 2.0 * a\n        else:\n            # Use the complex error function for the general case.\n            # The argument to sqrt must be complex to use the principal branch correctly.\n            arg = a * np.sqrt(-1j * alpha)\n            I_exact = np.sqrt(np.pi / (-1j * alpha)) * erf(arg)\n        \n        # 3. Generate the adaptive mesh\n        final_intervals = []\n        if np.abs(alpha) < 1e-15:\n            # If alpha is zero, the integrand is constant, no refinement needed.\n            final_intervals.append((-a, a))\n        else:\n            work_queue = deque([(-a, a)])\n            mag_2_alpha = np.abs(2 * alpha)\n            mag_alpha_div_4 = np.abs(alpha) / 4.0\n\n            while work_queue:\n                y0, y1 = work_queue.popleft()\n                h = y1 - y0\n                \n                # Gradient-based refinement criterion\n                grad_term = h * mag_2_alpha * max(np.abs(y0), np.abs(y1))\n                # Curvature-based refinement criterion\n                curv_term = mag_alpha_div_4 * h**2\n\n                if grad_term > phi_tol or curv_term > phi_tol:\n                    # If either criterion fails, bisect the interval\n                    ym = (y0 + y1) / 2.0\n                    work_queue.append((y0, ym))\n                    work_queue.append((ym, y1))\n                else:\n                    # Interval is small enough, add to final list\n                    final_intervals.append((y0, y1))\n        \n        # Sort intervals to create a contiguous mesh (deque may alter order slightly)\n        final_intervals.sort()\n        adaptive_points = np.array([interval[0] for interval in final_intervals] + [final_intervals[-1][1]])\n        num_adaptive_intervals = len(final_intervals)\n\n        # 4. Compute integral on the adaptive mesh using composite trapezoidal rule\n        y_vals_adaptive = integrand(adaptive_points, alpha)\n        I_adaptive = 0.5 * np.sum((y_vals_adaptive[:-1] + y_vals_adaptive[1:]) * (adaptive_points[1:] - adaptive_points[:-1]))\n        \n        # 5. Compute integral on a uniform mesh with the same number of intervals\n        num_uniform_intervals = num_adaptive_intervals\n        uniform_points = np.linspace(-a, a, num_uniform_intervals + 1)\n        y_vals_uniform = integrand(uniform_points, alpha)\n        h_uniform = 2 * a / num_uniform_intervals\n        I_uniform = h_uniform * (0.5 * (y_vals_uniform[0] + y_vals_uniform[-1]) + np.sum(y_vals_uniform[1:-1]))\n        \n        # 6. Calculate errors and the accuracy gain ratio\n        err_adaptive = np.abs(I_adaptive - I_exact)\n        err_uniform = np.abs(I_uniform - I_exact)\n        \n        # Robustly handle the ratio calculation\n        if err_adaptive < 1e-15:\n            # If adaptive error is numerically zero:\n            # If uniform error is also zero, the methods are equally good, ratio is 1.\n            # If uniform error is non-zero, AMR is infinitely better; return a large number.\n            ratio = 1.0 if err_uniform < 1e-15 else 1e15\n        else:\n            ratio = err_uniform / err_adaptive\n            \n        results.append(ratio)\n\n    # Format the output as a list of floats\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}