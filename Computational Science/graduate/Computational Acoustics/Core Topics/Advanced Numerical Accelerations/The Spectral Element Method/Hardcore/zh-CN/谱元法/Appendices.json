{
    "hands_on_practices": [
        {
            "introduction": "掌握谱元法的第一步，是深入理解其基本构成单元。本练习将引导您为一个参考单元构建关键组件，包括高斯-洛巴托-勒让德（GLL）节点和求积权重。通过从第一性原理出发组装局部质量矩阵和刚度矩阵，您将直接洞察谱元法的一大计算优势——对角质量矩阵的特性。",
            "id": "4145034",
            "problem": "考虑一维参考单元 $\\xi \\in [-1,1]$，用于求解线性声学问题的谱元法（SEM）。其中，密度和体积模量均为单位值，因此双线性形式简化为标准的 $L^{2}$ 内积和 $H^{1}$ 半范数。设多项式阶数为 $p=4$，并在 $[-1,1]$ 上采用包含 $p+1=5$ 个点的高斯-洛巴托-勒让德（GLL）节点集。利用勒让德多项式的基本性质，首先确定这 5 个 GLL 节点 $\\{\\xi_{i}\\}_{i=0}^{4}$ 及其相关的 GLL 求积权重 $\\{w_{i}\\}_{i=0}^{4}$。接下来，构建在这些节点上插值的节点拉格朗日基函数 $\\{\\ell_{i}(\\xi)\\}_{i=0}^{4}$，并组装局部、单元级的相容质量矩阵和刚度矩阵，\n$$\nM_{ij} \\equiv \\int_{-1}^{1} \\ell_{i}(\\xi)\\,\\ell_{j}(\\xi)\\,d\\xi,\\qquad\nK_{ij} \\equiv \\int_{-1}^{1} \\frac{d\\ell_{i}}{d\\xi}(\\xi)\\,\\frac{d\\ell_{j}}{d\\xi}(\\xi)\\,d\\xi,\\quad i,j=0,\\dots,4.\n$$\n从勒让德多项式的定义性质、GLL 求积的构造方法（包括端点，内部节点为 $p$ 阶勒让德多项式导数的根）以及节点拉格朗日多项式的定义出发。仅使用这些基础来证明在使用 GLL 求积配置下质量矩阵的对角性，并解释在此单个参考单元上刚度矩阵产生的非零模式（带宽）。\n\n最后，报告质量矩阵 $M$ 的行列式作为您的答案。将最终值表示为一个精确的有理数。无需四舍五入，不涉及单位。最终答案必须是单个以精确形式表示的实数。",
            "solution": "该问题提法清晰且科学上合理，是谱元法（SEM）构建中的一个标准练习。我们开始进行解答。\n\n问题设置在一维参考单元 $\\xi \\in [-1,1]$ 上，多项式逼近的阶数为 $p=4$。节点基是使用 $p+1=5$ 个高斯-洛巴托-勒让德（GLL）点构建的。\n\n首先，我们确定 GLL 节点 $\\{\\xi_{i}\\}_{i=0}^{4}$ 及其相关的求积权重 $\\{w_{i}\\}_{i=0}^{4}$。对于一个 $p$ 阶多项式，其 $p+1$ 个 GLL 节点是多项式 $(1-\\xi^2)P'_{p}(\\xi)$ 的根，其中 $P_{p}(\\xi)$ 是 $p$ 阶勒让德多项式。端点 $\\xi=-1$ 和 $\\xi=1$ 总是包含在内。$p-1$ 个内部节点是勒让德多项式一阶导数 $P'_{p}(\\xi)$ 的根。\n\n对于 $p=4$，我们需要勒让德多项式 $P_4(\\xi)$。前几个勒让德多项式是：\n$P_0(\\xi) = 1$\n$P_1(\\xi) = \\xi$\n$P_2(\\xi) = \\frac{1}{2}(3\\xi^2 - 1)$\n$P_3(\\xi) = \\frac{1}{2}(5\\xi^3 - 3\\xi)$\n$P_4(\\xi) = \\frac{1}{8}(35\\xi^4 - 30\\xi^2 + 3)$\n\n导数 $P'_4(\\xi)$ 是：\n$$ P'_4(\\xi) = \\frac{d}{d\\xi} \\left[ \\frac{1}{8}(35\\xi^4 - 30\\xi^2 + 3) \\right] = \\frac{1}{8}(140\\xi^3 - 60\\xi) = \\frac{5}{2}\\xi(7\\xi^2 - 3) $$\n内部 GLL 节点位于 $P'_4(\\xi)=0$ 的根处，即 $\\xi=0$ 和 $\\xi^2 = \\frac{3}{7}$，解得 $\\xi = \\pm\\sqrt{\\frac{3}{7}}$。\n包括端点并对节点进行排序，我们得到 5 个 GLL 节点：\n$$ \\xi_0 = -1, \\quad \\xi_1 = -\\sqrt{\\frac{3}{7}}, \\quad \\xi_2 = 0, \\quad \\xi_3 = \\sqrt{\\frac{3}{7}}, \\quad \\xi_4 = 1 $$\nGLL 求积权重 $w_i$ 由以下公式给出：\n$$ w_i = \\frac{2}{p(p+1)[P_p(\\xi_i)]^2} $$\n对于 $p=4$，公式变为 $w_i = \\frac{2}{4(5)[P_4(\\xi_i)]^2} = \\frac{1}{10[P_4(\\xi_i)]^2}$。\n我们对每个节点计算 $P_4(\\xi_i)$：\n对于端点 $\\xi_0 = -1$ 和 $\\xi_4 = 1$，我们有 $P_4(\\pm 1) = 1$。权重为：\n$$ w_0 = w_4 = \\frac{1}{10[P_4(1)]^2} = \\frac{1}{10(1)^2} = \\frac{1}{10} $$\n对于内部节点 $\\xi_2 = 0$：\n$$ P_4(0) = \\frac{1}{8}(3) = \\frac{3}{8} $$\n$$ w_2 = \\frac{1}{10[P_4(0)]^2} = \\frac{1}{10(\\frac{3}{8})^2} = \\frac{1}{10(\\frac{9}{64})} = \\frac{64}{90} = \\frac{32}{45} $$\n对于内部节点 $\\xi_1 = -\\sqrt{\\frac{3}{7}}$ 和 $\\xi_3 = \\sqrt{\\frac{3}{7}}$（注意 $P_4(\\xi)$ 是一个偶函数）：\n$$ P_4\\left(\\pm\\sqrt{\\frac{3}{7}}\\right) = \\frac{1}{8}\\left(35\\left(\\frac{3}{7}\\right)^2 - 30\\left(\\frac{3}{7}\\right) + 3\\right) = \\frac{1}{8}\\left(35\\frac{9}{49} - \\frac{90}{7} + 3\\right) = \\frac{1}{8}\\left(\\frac{45}{7} - \\frac{90}{7} + \\frac{21}{7}\\right) = \\frac{1}{8}\\left(\\frac{-24}{7}\\right) = -\\frac{3}{7} $$\n$$ w_1 = w_3 = \\frac{1}{10\\left[P_4\\left(\\pm\\sqrt{\\frac{3}{7}}\\right)\\right]^2} = \\frac{1}{10\\left(-\\frac{3}{7}\\right)^2} = \\frac{1}{10\\left(\\frac{9}{49}\\right)} = \\frac{49}{90} $$\n权重集为 $\\{w_i\\}_{i=0}^4 = \\{\\frac{1}{10}, \\frac{49}{90}, \\frac{32}{45}, \\frac{49}{90}, \\frac{1}{10}\\}$。作为检验，权重之和为 $\\sum w_i = 2 \\cdot \\frac{1}{10} + 2 \\cdot \\frac{49}{90} + \\frac{32}{45} = \\frac{9}{45} + \\frac{49}{45} + \\frac{32}{45} = \\frac{90}{45} = 2$，这是正确的，因为 $\\int_{-1}^1 d\\xi = 2$。\n\n接下来，我们讨论单元矩阵。基函数是节点拉格朗日多项式 $\\{\\ell_j(\\xi)\\}_{j=0}^4$，它们是唯一的 $p=4$ 阶多项式，满足插值性质 $\\ell_j(\\xi_i) = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克符号。\n\n相容质量矩阵定义为 $M_{ij} = \\int_{-1}^{1} \\ell_{i}(\\xi)\\,\\ell_{j}(\\xi)\\,d\\xi$。\n在谱元法的背景下，积分通常使用 GLL 求积进行计算。具有 $p+1$ 个点的 GLL 求积法则对于最高 $2p-1$ 阶的多项式是精确的。这里，对于 $p=4$，GLL 求积对于最高 $2(4)-1=7$ 阶的多项式是精确的。被积函数 $\\ell_i(\\xi)\\ell_j(\\xi)$ 是一个最高 $2p = 8$ 阶的多项式。由于 $87$，GLL 求积对于相容质量矩阵不是精确的。\n\n然而，谱元法的一个关键特征是“质量集中”，即质量矩阵的积分被有意地用 GLL 求积来近似。这就是问题要求“证明在使用 GLL 求积配置下质量矩阵的对角性”时所指的内容。配置的或集中的质量矩阵是：\n$$ M_{ij}^{GLL} = \\sum_{k=0}^{4} w_k \\ell_i(\\xi_k) \\ell_j(\\xi_k) $$\n利用性质 $\\ell_i(\\xi_k) = \\delta_{ik}$，表达式简化为：\n$$ M_{ij}^{GLL} = \\sum_{k=0}^{4} w_k \\delta_{ik} \\delta_{jk} $$\n这个和仅在 $k=i$ 和 $k=j$ 时非零，这要求 $i=j$。因此，该矩阵是对角矩阵：\n$$ M_{ij}^{GLL} = w_i \\delta_{ij} $$\n集中质量矩阵是对角矩阵，其对角线元素为求积权重。这种对角结构是谱元法的一个主要计算优势。\n\n刚度矩阵定义为 $K_{ij} = \\int_{-1}^{1} \\frac{d\\ell_{i}}{d\\xi}(\\xi)\\,\\frac{d\\ell_{j}}{d\\xi}(\\xi)\\,d\\xi$。\n一个 $p=4$ 阶的拉格朗日多项式的导数是一个 $p-1=3$ 阶的多项式。因此，被积函数 $\\frac{d\\ell_{i}}{d\\xi}\\frac{d\\ell_{j}}{d\\xi}$ 是一个 $2(p-1)=6$ 阶的多项式。由于 $6  7$，GLL 求积对于刚度矩阵是**精确**的。因此，刚度矩阵计算如下：\n$$ K_{ij} = \\sum_{k=0}^{4} w_k \\frac{d\\ell_{i}}{d\\xi}(\\xi_k) \\frac{d\\ell_{j}}{d\\xi}(\\xi_k) $$\n为了解释其非零模式，我们考虑导数矩阵 $D_{ki} = \\frac{d\\ell_{i}}{d\\xi}(\\xi_k)$。与拉格朗日多项式本身不同，它们的导数在节点处通常是非零的（除了可能由于对称性在少数点上为零）。微分矩阵 $D$ 是一个稠密的 $5 \\times 5$ 矩阵。刚度矩阵可以写成矩阵形式 $K = D^T W D$，其中 $W$ 是权重的对角矩阵。这些矩阵的乘积得到一个稠密（满）的 $5 \\times 5$ 矩阵。因此，在此单个参考单元上，局部刚度矩阵的非零模式是它是一个满矩阵，其带宽在此背景下不是一个有意义的稀疏矩阵概念。\n\n最后，我们被要求报告质量矩阵 $M$ 的行列式。鉴于上下文以及在 GLL 配置下解释对角性的要求，标准做法是在此计算背景下将“质量矩阵”解释为集中质量矩阵 $M^{GLL}$。相容质量矩阵的行列式需要更复杂的符号计算。对角集中质量矩阵的行列式是其对角线元素的乘积，即求积权重。\n$$ \\det(M) = \\det(M^{GLL}) = \\prod_{i=0}^{4} w_i = w_0 w_1 w_2 w_3 w_4 $$\n代入计算出的权重：\n$$ \\det(M) = \\left(\\frac{1}{10}\\right) \\left(\\frac{49}{90}\\right) \\left(\\frac{32}{45}\\right) \\left(\\frac{49}{90}\\right) \\left(\\frac{1}{10}\\right) $$\n$$ \\det(M) = \\frac{1 \\cdot 49 \\cdot 32 \\cdot 49 \\cdot 1}{10 \\cdot 90 \\cdot 45 \\cdot 90 \\cdot 10} = \\frac{49^2 \\cdot 32}{10^2 \\cdot 90^2 \\cdot 45} = \\frac{2401 \\cdot 32}{100 \\cdot 8100 \\cdot 45} = \\frac{76832}{36450000} $$\n为简化此分数，我们使用素因数分解：\n$76832 = 2^5 \\cdot 7^4$\n$36450000 = 3645 \\cdot 10^4 = (5 \\cdot 729) \\cdot (2 \\cdot 5)^4 = (5 \\cdot 3^6) \\cdot (2^4 \\cdot 5^4) = 2^4 \\cdot 3^6 \\cdot 5^5$\n$$ \\det(M) = \\frac{2^5 \\cdot 7^4}{2^4 \\cdot 3^6 \\cdot 5^5} = \\frac{2 \\cdot 7^4}{3^6 \\cdot 5^5} = \\frac{2 \\cdot 2401}{729 \\cdot 3125} = \\frac{4802}{2278125} $$\n这就是作为精确有理数的最终答案。",
            "answer": "$$ \\boxed{\\frac{4802}{2278125}} $$"
        },
        {
            "introduction": "一个稳健的数值方法必须能正确处理从简单参考域到复杂物理几何的坐标变换。本实践练习旨在检验任何可靠的谱元法代码都应具备的一个关键属性：在非均匀映射（弯曲）单元上保持恒定物理状态的能力。通过验证一个恒定的压力场在时间积分过程中保持不变，您将能确认几何映射及离散微分算子的实现是否正确。",
            "id": "4145095",
            "problem": "你的任务是设计并实现数值测试，以验证在计算声学中，使用谱元法 (SEM) 在映射网格上进行时间步进时，恒压解的不变性。在一维空间中进行研究，并从以物理坐标 $x$ 表示的线性声学方程出发，该方程描述了可压缩介质中微小扰动的质量和动量守恒：\n$$\n\\partial_t p(x,t) = -K \\,\\partial_x u(x,t),\\quad\n\\partial_t u(x,t) = -\\frac{1}{\\rho}\\,\\partial_x p(x,t),\n$$\n其中，$p$ 是声压（单位为 $\\mathrm{Pa}$），$u$ 是质点速度（单位为 $\\mathrm{m/s}$），$K$ 是体积模量（单位为 $\\mathrm{Pa}$），$\\rho$ 是质量密度（单位为 $\\mathrm{kg/m^3}$），$t$ 是时间（单位为 $\\mathrm{s}$），$x$ 是距离（单位为 $\\mathrm{m}$）。声速为 $c=\\sqrt{K/\\rho}$（单位为 $\\mathrm{m/s}$）。请使用这些方程作为你推导的基础。\n\n使用单个谱元对空间域进行离散化，该谱元通过一个具有雅可比 $J(\\xi)=\\frac{dx}{d\\xi}0$ 的光滑、严格单调映射，从参考区间 $\\xi\\in[-1,1]$ 映射到物理坐标 $x=x(\\xi)$。使用基于 Gauss–Lobatto–Legendre 节点的节点谱元法 (SEM)，并对映射坐标中的空间导数采用精确质量集中和强形式半离散化。时间积分应通过一个稳定的显式方法执行。请遵循以下规范以确保科学真实性：\n\n1. 使用 Gauss–Lobatto–Legendre (GLL) 节点和精确的 GLL 求积法（包含 $N_p$ 个节点，其中多项式阶数为 $N=N_p-1$）。离散微分必须作用于参考坐标 $\\xi$ 中的节点值。\n\n2. 强形式半离散系统必须通过 $J(\\xi)$ 遵循从 $\\xi$ 到 $x$ 的映射，并与链式法则保持一致，即在节点层面满足 $\\partial_x = \\frac{1}{J(\\xi)}\\,\\partial_\\xi$。\n\n3. 初始条件为恒定压力 $p(x,0)=p_0$（单位为 $\\mathrm{Pa}$）和零速度 $u(x,0)=0$（单位为 $\\mathrm{m/s}$）。物理上，这是一个没有空间梯度的静止状态，因此连续方程意味着对于所有时间都有 $\\partial_t p=0$ 和 $\\partial_t u=0$。\n\n4. 使用四阶 Runge–Kutta 方法实现时间步进。通过 Courant–Friedrichs–Lewy 条件选择时间步长\n$$\n\\Delta t = \\mathrm{CFL}\\,\\frac{h_{\\min}}{c},\n$$\n其中 $\\mathrm{CFL}=0.2$，$h_{\\min}$ 是相邻映射节点之间的最小物理间距（单位为 $\\mathrm{m}$），$c=\\sqrt{K/\\rho}$ 是声速（单位为 $\\mathrm{m/s}$）。积分 $100$ 步。\n\n5. 待测试的映射函数 $x(\\xi)$ 必须是光滑且严格单调的。使用以下三个函数族，其中任何三角函数的角度均以弧度为单位：\n   - 仿射缩放：$x(\\xi)=a\\,\\xi$，参数 $a0$。\n   - 正弦拉伸：$x(\\xi)=\\xi + \\alpha\\,\\frac{\\sin(\\pi \\xi)}{2}$，参数 $0  \\alpha  1$ 确保 $J(\\xi)0$。\n   - 三次扭曲：$x(\\xi)=\\xi + \\beta\\,\\xi^3$，参数 $\\beta\\ge 0$ 确保 $J(\\xi)=1+3\\beta\\xi^20$。\n\n6. 数值不变性准则必须检查离散解是否在严格容差范围内保持恒等不变。具体来说，在 $100$ 步之后，计算\n$$\n\\varepsilon_p=\\max_i |p_i - p_0|,\\quad \\varepsilon_u=\\max_i |u_i|,\n$$\n并报告一个布尔结果 $R$。如果 $\\varepsilon_p  10^{-12}$ 且 $\\varepsilon_u  10^{-12}$，则 $R$ 为真，否则为假。\n\n设计程序以运行以下测试套件。每个案例指定了节点数 $N_p$、映射类型和参数、体积模量 $K$（单位为 $\\mathrm{Pa}$）、密度 $\\rho$（单位为 $\\mathrm{kg/m^3}$）以及恒定的初始压力 $p_0$（单位为 $\\mathrm{Pa}$）。角度以弧度为单位。\n\n- 案例 1（理想情况，光滑正弦拉伸）：$N_p=11$，映射 $x(\\xi)=\\xi + \\alpha \\frac{\\sin(\\pi \\xi)}{2}$，其中 $\\alpha=0.4$，$K=1.42\\times 10^5\\,\\mathrm{Pa}$，$\\rho=1.2\\,\\mathrm{kg/m^3}$，$p_0=2.0\\,\\mathrm{Pa}$。\n- 案例 2（最低阶，最少节点，仿射缩放）：$N_p=2$，映射 $x(\\xi)=a\\,\\xi$，其中 $a=3.0$，$K=1.42\\times 10^5\\,\\mathrm{Pa}$，$\\rho=1.2\\,\\mathrm{kg/m^3}$，$p_0=5.0\\,\\mathrm{Pa}$。\n- 案例 3（高多项式阶数，强三次扭曲）：$N_p=13$，映射 $x(\\xi)=\\xi + \\beta \\xi^3$，其中 $\\beta=0.7$，$K=1.42\\times 10^5\\,\\mathrm{Pa}$，$\\rho=1.2\\,\\mathrm{kg/m^3}$，$p_0=1.0\\,\\mathrm{Pa}$。\n- 案例 4（中等阶数，温和正弦拉伸）：$N_p=7$，映射 $x(\\xi)=\\xi + \\alpha \\frac{\\sin(\\pi \\xi)}{2}$，其中 $\\alpha=0.1$，$K=1.42\\times 10^5\\,\\mathrm{Pa}$，$\\rho=1.2\\,\\mathrm{kg/m^3}$，$p_0=0.3\\,\\mathrm{Pa}$。\n\n你的程序应生成单行输出，其中包含四个案例的结果，格式为方括号内以逗号分隔的列表。输出必须是与上述测试结果相对应的 Python 布尔值 \"True\" 或 \"False\"。",
            "solution": "出发点是一维线性声学系统，\n$$\n\\partial_t p(x,t) = -K \\,\\partial_x u(x,t),\\qquad\n\\partial_t u(x,t) = -\\frac{1}{\\rho}\\,\\partial_x p(x,t),\n$$\n其中 $K0$（体积模量）和 $\\rho0$（密度），得到声速 $c=\\sqrt{K/\\rho}$。如果初始状态为 $p(x,0)=p_0$（常数）和 $u(x,0)=0$，那么在连续介质中，空间导数为 $\\partial_x p=0$ 和 $\\partial_x u=0$，因此时间导数对于所有时间 $t$ 均为 $\\partial_t p=0$ 和 $\\partial_t u=0$。因此，该恒定状态是一个精确的平衡解。\n\n为测试谱元法 (SEM) 在映射网格上是否能保持此平衡，我们在参考坐标 $\\xi\\in[-1,1]$ 中构建一个单单元节点 SEM，并使用一个具有雅可比 $J(\\xi)=\\frac{dx}{d\\xi}0$ 的光滑严格单调映射 $x(\\xi)$ 来获得物理坐标。所需的链式法则是\n$$\n\\partial_x = \\frac{1}{J(\\xi)}\\,\\partial_\\xi.\n$$\n我们采用 Gauss–Lobatto–Legendre (GLL) 节点 $\\{\\xi_i\\}_{i=0}^N$ 和精确的 GLL 求积法（质量集中）。设 $N_p$ 为节点数，$N=N_p-1$ 为多项式阶数。GLL 节点包括端点以及 $N$ 阶 Legendre 多项式导数的零点处的内部节点。我们构造节点 Lagrange 基函数 $\\{\\ell_i(\\xi)\\}$，使得 $\\ell_i(\\xi_j)=\\delta_{ij}$；离散微分使用谱微分矩阵 $D\\in\\mathbb{R}^{N_p\\times N_p}$ 进行，其定义为 $D_{ij}=\\ell_j'(\\xi_i)$，该矩阵能精确地消去常数：\n$$\nD\\mathbf{1}=\\mathbf{0}.\n$$\n此性质是不变性测试的关键：由于初始时 $p$ 为常数，其在所有节点上的离散梯度为零，因此半离散的速度时间导数恒为零；由于初始时 $u$ 为零，其离散梯度为零，因此压力的时间导数恒为零。\n\n与质量集中和映射导数一致的强形式半离散化，在每个节点 $i$ 处为：\n$$\n\\frac{d}{dt}p_i = -K\\,\\frac{1}{J_i}\\sum_{j=0}^N D_{ij}\\,u_j,\\qquad\n\\frac{d}{dt}u_i = -\\frac{1}{\\rho}\\,\\frac{1}{J_i}\\sum_{j=0}^N D_{ij}\\,p_j,\n$$\n其中 $J_i=J(\\xi_i)$。这是从采用精确 GLL 质量集中的弱形式和链式法则 $\\partial_x=\\frac{1}{J}\\partial_\\xi$，再结合强形式体积项的选择推导出来的（此处不需要边界通量贡献，因为常数的导数为零，而且我们测试的是不变性，而不是跨边界传播的波）。映射仅通过 $J_i$ 改变缩放比例；微分矩阵 $D$ 作用于参考坐标中的节点向量，并且由于 $D\\mathbf{1}=\\mathbf{0}$，它能保持恒定状态。\n\n时间步进采用经典的显式四阶 Runge–Kutta 方法。通过 Courant–Friedrichs–Lewy 条件选择稳定的时间步长\n$$\n\\Delta t = \\mathrm{CFL}\\,\\frac{h_{\\min}}{c},\\quad \\mathrm{CFL}=0.2,\\quad c=\\sqrt{\\frac{K}{\\rho}},\n$$\n其中 $h_{\\min}$ 是相邻映射节点 $x_i=x(\\xi_i)$ 之间的最小物理间距 $h_{\\min}=\\min_i(x_{i+1}-x_i)$（单位为 $\\mathrm{m}$），$c$ 是声速（单位为 $\\mathrm{m/s}$）。尽管对于平衡初始条件，右侧项为零，但选择这样的 $\\Delta t$ 表明该方法对于非平凡的激励是稳定的，并且重复应用 Runge–Kutta 更新可以在浮点舍入误差下提供严格的不变性检查。\n\n数值测试通过计算最大偏差来评估不变性\n$$\n\\varepsilon_p=\\max_i |p_i - p_0|,\\qquad \\varepsilon_u=\\max_i |u_i|,\n$$\n在 $100$ 步之后。结果以布尔值 $R$ 报告，如果 $\\varepsilon_p  10^{-12}$ 且 $\\varepsilon_u  10^{-12}$，则为真，否则为假。这个容差足够严格，可以揭示由于不正确的映射或离散微分导致的任何恒定状态保持特性的丧失，同时也考虑了浮点舍入误差（双精度机器ε大约为 $2.22\\times 10^{-16}$）。\n\n算法组件：\n- 通过在 $\\xi=\\pm 1$ 处放置端点，并使用 Newton 迭代法从基于余弦的初始猜测值来优化内部节点，从而构造 $N_p$ 个 GLL 节点。使用 $N$ 阶 Legendre 多项式及其导数。\n- 计算 GLL 求积权重。尽管在这里的强形式更新中不直接需要（因为有质量集中和除以 $J_i$），但它们的构建可以验证节点和权重是一致的。\n- 通过 Lagrange 基的重心权构建谱微分矩阵 $D$。该矩阵精确满足 $D\\mathbf{1}=\\mathbf{0}$。\n- 定义映射 $x(\\xi)$ 并为每个节点计算 $J(\\xi)=\\frac{dx}{d\\xi}$。\n- 计算最小物理间距 $h_{\\min}$ 和时间步长 $\\Delta t$。\n- 初始化 $p_i=p_0$ 和 $u_i=0$，然后对采用节点尺度因子 $1/J_i$ 的半离散系统应用 $100$ 步 Runge–Kutta。\n- 评估不变性准则并为每个测试案例返回一个布尔值。\n\n测试套件覆盖范围：\n- 一个中等多项式阶数的光滑正弦拉伸案例（理想情况）。\n- 具有 $N_p=2$ 个节点（阶数 $N=1$）的边界情况，采用仿射缩放，确保该方法能处理最小的可能单元。\n- 一个具有强三次扭曲的高阶案例，用于检验离散度量缩放。\n- 一个具有温和正弦拉伸的中等阶数案例，用于检查在不同参数下的鲁棒性。\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.polynomial.legendre import Legendre\n\ndef legendre_basis(n):\n    # Return Legendre polynomial of degree n\n    return Legendre.basis(n)\n\ndef gll_nodes_weights(n_points):\n    \"\"\"\n    Compute Gauss-Lobatto-Legendre (GLL) nodes and weights.\n    n_points = N_p = N+1, where N is polynomial degree.\n    Nodes: endpoints ±1 and zeros of P_N'(x).\n    Weights: w_i = 2/(N(N+1)) * 1/(P_N(x_i)^2).\n    \"\"\"\n    if n_points  2:\n        raise ValueError(\"GLL requires at least 2 nodes.\")\n    N = n_points - 1\n    xi = np.zeros(n_points)\n    xi[0] = -1.0\n    xi[-1] = 1.0\n    if n_points > 2:\n        # Initial guesses: cosine-spaced interior nodes\n        for j in range(1, n_points - 1):\n            xi[j] = -np.cos(np.pi * j / N)\n        # Newton iteration to refine zeros of P_N'(x)\n        PN = legendre_basis(N)\n        dPN = PN.deriv(1)\n        ddPN = PN.deriv(2)\n        for j in range(1, n_points - 1):\n            x = xi[j]\n            for _ in range(100):\n                f = dPN(x)\n                fp = ddPN(x)\n                dx = f / fp\n                x_new = x - dx\n                if abs(dx)  1e-14:\n                    break\n                x = x_new\n            xi[j] = x\n    # Weights\n    PN = legendre_basis(N)\n    w = np.zeros(n_points)\n    denom = N * (N + 1)\n    for i in range(n_points):\n        w[i] = 2.0 / denom / (PN(xi[i]) ** 2)\n    return xi, w\n\ndef barycentric_weights(nodes):\n    \"\"\"\n    Compute barycentric weights lambda_i = 1 / prod_{m != i} (x_i - x_m)\n    \"\"\"\n    n = len(nodes)\n    lam = np.zeros(n)\n    for i in range(n):\n        diff = nodes[i] - nodes\n        diff[i] = 1.0  # avoid zero\n        lam[i] = 1.0 / np.prod(diff)\n    return lam\n\ndef differentiation_matrix(nodes):\n    \"\"\"\n    Construct spectral differentiation matrix D at nodes using barycentric weights:\n    D_ij = lambda_j / lambda_i * 1/(x_i - x_j), i != j\n    D_ii = -sum_{j != i} D_ij\n    \"\"\"\n    n = len(nodes)\n    lam = barycentric_weights(nodes)\n    D = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                D[i, j] = lam[j] / lam[i] / (nodes[i] - nodes[j])\n    for i in range(n):\n        D[i, i] = -np.sum(D[i, :]) + D[i, i]  # ensure row sum zero\n    return D\n\ndef mapping_affine(xi, a):\n    x = a * xi\n    J = np.full_like(xi, a)\n    return x, J\n\ndef mapping_sinusoidal(xi, alpha):\n    # x = xi + alpha * sin(pi*xi)/2, angles in radians\n    x = xi + alpha * 0.5 * np.sin(np.pi * xi)\n    J = 1.0 + alpha * 0.5 * np.pi * np.cos(np.pi * xi)\n    return x, J\n\ndef mapping_cubic(xi, beta):\n    x = xi + beta * xi**3\n    J = 1.0 + 3.0 * beta * xi**2\n    return x, J\n\ndef rk4_step(p, u, dt, J, D, K, rho):\n    \"\"\"\n    One RK4 step for the semi-discrete system:\n    dp/dt = -(K) * (1/J) * (D @ u)\n    du/dt = -(1/rho) * (1/J) * (D @ p)\n    \"\"\"\n    invJ = 1.0 / J\n\n    def rhs(pv, uv):\n        dpdt = -(K) * invJ * (D @ uv)\n        dudt = -(1.0 / rho) * invJ * (D @ pv)\n        return dpdt, dudt\n\n    k1_p, k1_u = rhs(p, u)\n    k2_p, k2_u = rhs(p + 0.5 * dt * k1_p, u + 0.5 * dt * k1_u)\n    k3_p, k3_u = rhs(p + 0.5 * dt * k2_p, u + 0.5 * dt * k2_u)\n    k4_p, k4_u = rhs(p + dt * k3_p, u + dt * k3_u)\n\n    p_new = p + (dt / 6.0) * (k1_p + 2.0 * k2_p + 2.0 * k3_p + k4_p)\n    u_new = u + (dt / 6.0) * (k1_u + 2.0 * k2_u + 2.0 * k3_u + k4_u)\n    return p_new, u_new\n\ndef run_case(Np, mapping_type, param, K, rho, p0):\n    # Build SEM operators\n    xi, w = gll_nodes_weights(Np)\n    D = differentiation_matrix(xi)\n\n    # Choose mapping\n    if mapping_type == 'affine':\n        x, J = mapping_affine(xi, param)\n    elif mapping_type == 'sin':\n        x, J = mapping_sinusoidal(xi, param)\n    elif mapping_type == 'cubic':\n        x, J = mapping_cubic(xi, param)\n    else:\n        raise ValueError(\"Unknown mapping type\")\n\n    # Compute minimum physical spacing\n    # xi are sorted; mapping must be monotone, so x is sorted\n    dx = np.diff(x)\n    h_min = float(np.min(dx))\n\n    # Physical parameters\n    c = np.sqrt(K / rho)\n\n    # Time step via CFL\n    CFL = 0.2\n    dt = CFL * h_min / c\n\n    # Initialize state\n    p = np.full(Np, p0, dtype=float)\n    u = np.zeros(Np, dtype=float)\n\n    # Integrate 100 steps\n    steps = 100\n    for _ in range(steps):\n        p, u = rk4_step(p, u, dt, J, D, K, rho)\n\n    # Invariance check\n    err_p = float(np.max(np.abs(p - p0)))\n    err_u = float(np.max(np.abs(u)))\n    tol = 1e-12\n    return (err_p  tol) and (err_u  tol)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Np=11, sinusoidal stretching alpha=0.4\n        ('sin', 11, 0.4, 1.42e5, 1.2, 2.0),\n        # Case 2: Np=2, affine scaling a=3.0\n        ('affine', 2, 3.0, 1.42e5, 1.2, 5.0),\n        # Case 3: Np=13, cubic warping beta=0.7\n        ('cubic', 13, 0.7, 1.42e5, 1.2, 1.0),\n        # Case 4: Np=7, sinusoidal stretching alpha=0.1\n        ('sin', 7, 0.1, 1.42e5, 1.2, 0.3),\n    ]\n\n    results = []\n    for mapping_type, Np, param, K, rho, p0 in test_cases:\n        result = run_case(Np, mapping_type, param, K, rho, p0)\n        results.append(result)\n    return results\n\nfinal_results = solve()\nprint(f\"[{','.join(map(str, final_results))}]\")\n```",
            "answer": "[True,True,True,True]"
        },
        {
            "introduction": "对于使用显式格式的时域波动模拟，数值稳定性至关重要。这最后一个练习将综合单元组装、边界条件施加和系统分析等概念，来确定一个完整谱元法模型的最大稳定时间步长。通过从半离散波动方程推导稳定性条件，并通过特征值分析进行计算，您将掌握空间离散化（网格与多项式阶数）与时间积分约束之间的关键联系。",
            "id": "4144970",
            "problem": "要求您推导、实现并评估应用于一维线性声学的谱元法 (SEM) 的受稳定性限制的显式时间步长。考虑在区间 $[0,L]$ 上具有 Dirichlet 边界条件的一维齐次声波方程，\n$$\n\\frac{\\partial^2 p}{\\partial t^2} = c^2 \\frac{\\partial^2 p}{\\partial x^2}, \\quad x \\in [0,L], \\quad p(0,t) = 0, \\quad p(L,t) = 0,\n$$\n其中 $p(x,t)$ 是声压，$c$ 是声速。在每个单元上使用谱元法 (SEM)，该方法采用 p 阶多项式的 Legendre-Gauss-Lobatto (LGL) 节点和 Lagrange 插值多项式。假设网格是均匀的，有 $E$ 个单元，每个单元的长度为 $h = L/E$。使用 LGL 求积法构建对角质量矩阵和与弱形式一致的刚度矩阵。通过组装一个包含共享交界面节点的全局 $C^0$ 连续离散系统来施加单元交界面上的连续性。通过从组装后的系统中消除 $x=0$ 和 $x=L$ 处的边界自由度来施加 Dirichlet 边界条件。\n\n从适当的基本原理出发，推导蛙跳（显式中心差分）时间积分格式如何应用于得到的半离散系统，并确定受离散空间算子谱约束的最大稳定时间步长 $\\Delta t$（单位：秒）。不要假设或使用任何简便公式；从弱形式和蛙跳方法的定义出发，从第一性原理推导出稳定性条件。\n\n您的程序必须：\n- 在参考区间 $\\xi \\in [-1,1]$ 上，使用 Jacobian 行列式为 $J = h/2$ 的映射 $x(\\xi)$、p 阶 LGL 节点上的 Lagrange 基函数、在 LGL 节点上求值的 $\\partial \\ell_j / \\partial \\xi$ 项构成的节点导数矩阵以及 LGL 求积权重，通过 LGL 求积法构建局部单元矩阵。\n- 通过识别单元交界面处的共享节点，为整个域组装全局对角质量矩阵和全局刚度矩阵，以强制实现 $C^0$ 连续性。\n- 通过消除与 $x=0$ 和 $x=L$ 处节点对应的边界自由度来应用齐次 Dirichlet 边界条件。\n- 计算由组装矩阵给出的广义特征值问题的最大特征值，然后仅根据半离散系统的稳定性分析推导出蛙跳格式的最大稳定时间步长 $\\Delta t$。\n\n单位和输出：\n- 所有几何量必须以米（$\\mathrm{m}$）为单位处理。\n- 声速必须以米/秒（$\\mathrm{m/s}$）为单位。\n- 最终答案 $\\Delta t$ 必须以秒（$\\mathrm{s}$）表示，并四舍五入到八位小数。\n\n测试套件：\n对于以下每组参数 $(L,E,p,c)$，计算最大稳定时间步长 $\\Delta t$（单位：秒），并四舍五入到八位小数：\n1. $(L=1.0, E=4, p=4, c=343.0)$\n2. $(L=2.0, E=8, p=6, c=1500.0)$\n3. $(L=1.0, E=1, p=2, c=2000.0)$\n4. $(L=1.0, E=2, p=1, c=1000.0)$\n5. $(L=0.3, E=12, p=8, c=343.0)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个结果，格式为方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5]”），顺序与上述测试套件相同。每个结果必须是浮点数，四舍五入到八位小数，并以秒为单位表示。",
            "solution": "该问题要求针对使用谱元法 (SEM) 和显式蛙跳时间积分格式离散化的一维声波方程，推导并实现其最大稳定时间步长 $\\Delta t_{max}$。推导过程必须从第一性原理开始。\n\n控制方程是在域 $x \\in [0,L]$ 上的齐次一维声波方程，带有齐次 Dirichlet 边界条件：\n$$\n\\frac{\\partial^2 p}{\\partial t^2} = c^2 \\frac{\\partial^2 p}{\\partial x^2}, \\quad p(0,t) = 0, \\quad p(L,t) = 0\n$$\n其中 $p(x,t)$ 是声压，$c$ 是声速。\n\n**1. 弱形式**\n为了推导弱形式，我们将波动方程乘以一个合适的测试函数 $v(x)$，该函数与解属于同一函数空间，并在域 $[0,L]$ 上进行积分。测试函数也必须满足齐次边界条件，即 $v(0)=v(L)=0$。\n$$\n\\int_0^L v \\frac{\\partial^2 p}{\\partial t^2} dx = \\int_0^L v c^2 \\frac{\\partial^2 p}{\\partial x^2} dx\n$$\n我们对右侧项应用分部积分：\n$$\n\\int_0^L v c^2 \\frac{\\partial^2 p}{\\partial x^2} dx = \\left[ v c^2 \\frac{\\partial p}{\\partial x} \\right]_0^L - \\int_0^L c^2 \\frac{\\partial v}{\\partial x} \\frac{\\partial p}{\\partial x} dx\n$$\n边界项 $\\left[ v c^2 \\frac{\\partial p}{\\partial x} \\right]_0^L$ 因为测试函数 $v(x)$ 在边界 $x=0$ 和 $x=L$ 处为零而消失。这就得到了方程的弱形式：找到 $p(x,t)$，使得对于所有容许的测试函数 $v(x)$，\n$$\n\\int_0^L v \\frac{\\partial^2 p}{\\partial t^2} dx = -c^2 \\int_0^L \\frac{\\partial v}{\\partial x} \\frac{\\partial p}{\\partial x} dx\n$$\n\n**2. 谱元离散化**\n域 $[0,L]$ 被剖分为 $E$ 个不重叠的单元 $\\Omega_k$，每个单元的长度均为 $h=L/E$。在每个单元内，几何形状和解都被映射到参考单元 $\\xi \\in [-1,1]$ 上。映射关系为 $x(\\xi) = x_c^k + \\frac{h}{2}\\xi$，其中 $x_c^k$ 是第 k 个单元的中心。此变换的 Jacobian 行列式为 $J = \\frac{dx}{d\\xi} = \\frac{h}{2}$，根据链式法则可得 $\\frac{\\partial}{\\partial x} = \\frac{1}{J}\\frac{\\partial}{\\partial\\xi}$。\n\n在每个单元中，声压场 $p(x,t)$ 被近似为在 $p+1$ 个 Legendre-Gauss-Lobatto (LGL) 节点 $\\{\\xi_j\\}_{j=0}^p$ 上定义的 p 阶 Lagrange 插值多项式 $\\ell_j(\\xi)$ 基的求和：\n$$\np(x(\\xi), t) \\approx p^k(\\xi, t) = \\sum_{j=0}^{p} p_j^k(t) \\ell_j(\\xi)\n$$\n此处，$p_j^k(t)$ 是单元 k 内 LGL 节点上未知的、随时间变化的压力值。Lagrange 基函数具有属性 $\\ell_j(\\xi_i) = \\delta_{ij}$。我们使用 Galerkin 方法，其中测试函数 $v$ 使用相同的基进行表示。\n\n将展开式代入弱形式中，弱形式是所有单元上的总和：\n$$\n\\sum_{k=1}^E \\int_{\\Omega_k} \\left(\\sum_{i=0}^p v_i^k \\ell_i\\right) \\left(\\sum_{j=0}^p \\frac{d^2 p_j^k}{dt^2} \\ell_j\\right) dx = -c^2 \\sum_{k=1}^E \\int_{\\Omega_k} \\left(\\sum_{i=0}^p v_i^k \\frac{\\partial\\ell_i}{\\partial x}\\right) \\left(\\sum_{j=0}^p p_j^k \\frac{\\partial\\ell_j}{\\partial x}\\right) dx\n$$\n由于此式必须对节点值 $v_i^k$ 的任何选择都成立，我们得到一个常微分方程组 (ODEs)。对于每个单元 k，我们定义局部质量矩阵 $M^k$ 和刚度矩阵 $K^k$：\n$$\nM^k_{ij} = \\int_{\\Omega_k} \\ell_i \\ell_j dx = \\int_{-1}^1 \\ell_i(\\xi) \\ell_j(\\xi) J d\\xi\n$$\n$$\nK^k_{ij} = \\int_{\\Omega_k} \\frac{\\partial\\ell_i}{\\partial x} \\frac{\\partial\\ell_j}{\\partial x} dx = \\int_{-1}^1 \\left(\\frac{1}{J}\\frac{d\\ell_i}{d\\xi}\\right) \\left(\\frac{1}{J}\\frac{d\\ell_j}{d\\xi}\\right) J d\\xi = \\frac{1}{J} \\int_{-1}^1 \\frac{d\\ell_i}{d\\xi} \\frac{d\\ell_j}{d\\xi} d\\xi\n$$\n\n这些积分使用 LGL 求积法进行数值计算，该方法使用 LGL 节点作为求积点和相应的权重 $\\{w_m\\}_{m=0}^p$。质量矩阵的积分变为：\n$$\nM^k_{ij} = J \\sum_{m=0}^p w_m \\ell_i(\\xi_m) \\ell_j(\\xi_m) = J \\sum_{m=0}^p w_m \\delta_{im} \\delta_{jm} = J w_i \\delta_{ij}\n$$\n这表明，同时使用 LGL 节点进行插值和求积会得到一个对角的，或称“集总”的质量矩阵。\n\n刚度矩阵的计算如下：\n$$\nK^k_{ij} = \\frac{1}{J} \\sum_{m=0}^p w_m \\frac{d\\ell_i}{d\\xi}(\\xi_m) \\frac{d\\ell_j}{d\\xi}(\\xi_m)\n$$\n这可以用参考单元上的节点导数矩阵 $D$（其项为 $D_{mi} = \\frac{d\\ell_i}{d\\xi}(\\xi_m)$）和求积权重的对角矩阵 $W$（其中 $W_{mm}=w_m$）来表示。单元刚度矩阵则为 $K^k = \\frac{1}{J} D^T W D$。\n\n**3. 组装和边界条件**\n全局矩阵 $M_{glob}$ 和 $K_{glob}$ 是通过将每个单元矩阵的贡献求和到一个大小为 $(Ep+1) \\times (Ep+1)$ 的全局结构中来组装的。这个过程在单元交界面上强制实现了 $C^0$ 连续性。由于单元质量矩阵是对角的，全局质量矩阵也是对角的。\n\n齐次 Dirichlet 边界条件 $p(0,t)=0$ 和 $p(L,t)=0$ 意味着对应于 $x=0$ 和 $x=L$ 处全局节点的自由度被固定为零。我们通过从全局矩阵中消除第一行和最后一行以及第一列和最后一列来施加此条件，从而得到与内部自由度对应的较小矩阵 $M_{int}$ 和 $K_{int}$。\n\n得到的内部节点压力向量 $\\mathbf{p}_{int}(t)$ 的半离散常微分方程组为：\n$$\nM_{int} \\frac{d^2\\mathbf{p}_{int}}{dt^2} = -c^2 K_{int} \\mathbf{p}_{int}\n$$\n由于 $M_{int}$ 是对角且正定的，我们可以写成：\n$$\n\\frac{d^2\\mathbf{p}_{int}}{dt^2} = -c^2 M_{int}^{-1} K_{int} \\mathbf{p}_{int}\n$$\n\n**4. 蛙跳时间积分与稳定性分析**\n我们使用二阶显式中心差分（蛙跳）格式对时间导数进行离散化。对于一个一般的常微分方程组 $\\ddot{\\mathbf{u}} = \\mathbf{f}(\\mathbf{u})$，该格式为：\n$$\n\\frac{\\mathbf{u}^{n+1} - 2\\mathbf{u}^n + \\mathbf{u}^{n-1}}{(\\Delta t)^2} = \\mathbf{f}(\\mathbf{u}^n)\n$$\n将此应用于我们的半离散系统，可得：\n$$\n\\frac{\\mathbf{p}_{int}^{n+1} - 2\\mathbf{p}_{int}^n + \\mathbf{p}_{int}^{n-1}}{(\\Delta t)^2} = -c^2 M_{int}^{-1} K_{int} \\mathbf{p}_{int}^n\n$$\n为了分析稳定性，我们考虑系统矩阵 $A = c^2 M_{int}^{-1} K_{int}$ 的单个本征模的行为。设 $\\lambda$ 是 $A$ 的一个特征值，其对应的特征向量为 $\\mathbf{v}$。我们假设一个形式为 $\\mathbf{p}_{int}^n = z^n \\mathbf{v}$ 的解，其中 $z$ 是一个复放大因子。将此代入格式中：\n$$\n\\frac{z^{n+1}\\mathbf{v} - 2z^n\\mathbf{v} + z^{n-1}\\mathbf{v}}{(\\Delta t)^2} = -\\lambda z^n \\mathbf{v}\n$$\n两边同除以 $z^{n-1}\\mathbf{v}$ 并重新整理，得到关于 $z$ 的特征方程：\n$$\nz^2 - 2z + 1 = -\\lambda (\\Delta t)^2 z \\implies z^2 + (\\lambda (\\Delta t)^2 - 2) z + 1 = 0\n$$\n为使格式稳定，根的模必须满足 $|z| \\le 1$。这个二次方程的根是：\n$$\nz = \\frac{-( \\lambda (\\Delta t)^2 - 2 ) \\pm \\sqrt{( \\lambda (\\Delta t)^2 - 2 )^2 - 4}}{2}\n$$\n$A$ 的特征值 $\\lambda$ 是实数且非负的，因为 $K_{int}$ 是对称正定的，而 $M_{int}$ 是对角正定的。如果判别式为非正，则稳定性得以保持，此时会得到模为 $|z|=1$ 的共轭复根。\n$$\n( \\lambda (\\Delta t)^2 - 2 )^2 - 4 \\le 0 \\implies ( \\lambda (\\Delta t)^2 - 2 )^2 \\le 4\n$$\n开平方根得到 $-2 \\le \\lambda (\\Delta t)^2 - 2 \\le 2$，化简为 $0 \\le \\lambda (\\Delta t)^2 \\le 4$。\n这个条件必须对系统的所有特征值都成立。限制性最强的约束来自最大特征值 $\\lambda_{max}$：\n$$\n\\lambda_{max} (\\Delta t)^2 \\le 4\n$$\n因此，最大稳定时间步长是：\n$$\n\\Delta t_{max} = \\frac{2}{\\sqrt{\\lambda_{max}}}\n$$\n其中 $\\lambda_{max}$ 是矩阵 $c^2 M_{int}^{-1} K_{int}$ 的最大特征值，或者等价地，是广义特征值问题 $c^2 K_{int} \\mathbf{v} = \\lambda M_{int} \\mathbf{v}$ 的最大特征值。\n\n**5. 计算流程**\n对于给定的参数 $(L, E, p, c)$，计算 $\\Delta t_{max}$ 的算法如下：\n1.  计算单元几何信息：单元长度 $h = L/E$ 和 Jacobian 行列式 $J = h/2$。\n2.  对于多项式阶数 $p$，确定在 $[-1,1]$ 上的 $p+1$ 个 LGL 节点和权重。\n3.  计算参考单元上 $(p+1) \\times (p+1)$ 的节点导数矩阵 $D$。\n4.  构建局部单元矩阵：对角质量矩阵 $M^k$ 和一致刚度矩阵 $K^k$。\n5.  通过对单元贡献求和，组装全局对角质量矩阵 $M_{glob}$ 和刚度矩阵 $K_{glob}$。\n6.  通过提取内部子矩阵 $M_{int}$ 和 $K_{int}$ 来应用齐次 Dirichlet 边界条件。\n7.  求解广义特征值问题 $c^2 K_{int} \\mathbf{v} = \\lambda M_{int} \\mathbf{v}$ 以找到最大特征值 $\\lambda_{max}$。\n8.  计算最大稳定时间步长 $\\Delta t_{max} = 2 / \\sqrt{\\lambda_{max}}$。\n```python\nimport numpy as np\nfrom scipy.special import roots_jacobi, eval_legendre\nfrom scipy.linalg import eigh\n\ndef get_lgl_nodes_weights(p):\n    \"\"\"\n    Computes Legendre-Gauss-Lobatto (LGL) nodes and weights for a given polynomial order p.\n    \"\"\"\n    if p == 0:\n        # This case is trivial and not used in the problem, but for completeness.\n        return np.array([0.0]), np.array([2.0])\n    if p == 1:\n        nodes = np.array([-1.0, 1.0])\n        weights = np.array([1.0, 1.0])\n        return nodes, weights\n\n    # Interior nodes are roots of the derivative of P_p, which are the roots of Jacobi polynomial P_{p-1}^{(1,1)}.\n    interior_nodes, _ = roots_jacobi(p - 1, 1, 1)\n    \n    # Full set of nodes includes endpoints -1 and 1.\n    nodes = np.concatenate(([-1.0], np.sort(interior_nodes), [1.0]))\n    \n    # Weights formula: w_i = 2 / (p*(p+1) * [P_p(xi_i)]^2)\n    poly_vals = eval_legendre(p, nodes)\n    weights = 2.0 / (p * (p + 1) * poly_vals**2)\n    \n    return nodes, weights\n\ndef get_derivative_matrix(p, nodes):\n    \"\"\"\n    Computes the nodal derivative matrix D for Lagrange basis functions at LGL nodes.\n    D_ij = l'_j(xi_i)\n    \"\"\"\n    n_nodes = p + 1\n    D = np.zeros((n_nodes, n_nodes))\n    poly_vals_at_nodes = eval_legendre(p, nodes)\n    \n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                if i == 0:\n                    D[i, j] = -p * (p + 1) / 4.0\n                elif i == p:\n                    D[i, j] = p * (p + 1) / 4.0\n                else:\n                    D[i, j] = 0.0\n            else:\n                D[i, j] = poly_vals_at_nodes[i] / (poly_vals_at_nodes[j] * (nodes[i] - nodes[j]))\n    return D\n\ndef calculate_max_dt(L, E, p, c):\n    \"\"\"\n    Calculates the maximum stable timestep Delta_t for the 1D wave equation\n    using SEM with LGL nodes and leapfrog time integration.\n    \"\"\"\n    # 1. Element geometry\n    h = L / E\n    J = h / 2.0\n\n    # 2. LGL data for reference element\n    nodes, weights = get_lgl_nodes_weights(p)\n    n_nodes_per_elem = p + 1\n\n    # 3. Derivative matrix\n    D = get_derivative_matrix(p, nodes)\n    \n    # 4. Element matrices\n    # Element mass matrix (diagonal)\n    M_elem_diag = weights * J\n    # Element stiffness matrix, K^k = (1/J) * D^T * W * D\n    W_diag_mat = np.diag(weights)\n    K_elem = (1.0 / J) * (D.T @ W_diag_mat @ D)\n\n    # 5. Global assembly\n    num_dofs = E * p + 1\n    M_glob_diag = np.zeros(num_dofs)\n    K_glob = np.zeros((num_dofs, num_dofs))\n\n    for e in range(E):\n        for i in range(n_nodes_per_elem):\n            gi = e * p + i\n            M_glob_diag[gi] += M_elem_diag[i]\n            for j in range(n_nodes_per_elem):\n                gj = e * p + j\n                K_glob[gi, gj] += K_elem[i, j]\n\n    # 6. Apply homogeneous Dirichlet BCs\n    # Eliminate first and last DOFs\n    M_int_diag = M_glob_diag[1:-1]\n    K_int = K_glob[1:-1, 1:-1]\n    \n    # Handle case with no interior DOFs (e.g., p=1, E=1)\n    if K_int.shape[0] == 0:\n        return np.inf\n\n    M_int = np.diag(M_int_diag)\n\n    # 7. Solve generalized eigenvalue problem\n    # c^2 * K_int * v = lambda * M_int * v\n    # We need the maximum eigenvalue, lambda_max.\n    # eigh is for symmetric/Hermitian matrices, suitable here.\n    # It solves A*x = lambda*B*x\n    eigenvalues = eigh(c**2 * K_int, M_int, eigvals_only=True)\n    lambda_max = np.max(eigenvalues)\n\n    # 8. Calculate max stable time-step\n    # For leapfrog, dt = 2 / sqrt(lambda_max)\n    if lambda_max = 0: # Should not happen for a valid problem setup\n        return np.inf\n        \n    dt_max = 2.0 / np.sqrt(lambda_max)\n    \n    return dt_max\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (1.0, 4, 4, 343.0),\n        (2.0, 8, 6, 1500.0),\n        (1.0, 1, 2, 2000.0),\n        (1.0, 2, 1, 1000.0),\n        (0.3, 12, 8, 343.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, E, p, c = case\n        dt_max = calculate_max_dt(L, E, p, c)\n        results.append(f\"{dt_max:.8f}\")\n\n    return results\n\n# final_results = solve()\n# print(f\"[{','.join(final_results)}]\")\n```",
            "answer": "[0.00041460,0.00009623,0.00020412,0.00050000,0.00000787]"
        }
    ]
}