{
    "hands_on_practices": [
        {
            "introduction": "The first step in mastering any numerical method is to learn how to apply it correctly and understand its performance on representative problems. This exercise provides a practical introduction to using the Gauss-Legendre quadrature rule, a cornerstone of numerical integration over the interval $[-1, 1]$. By applying a pre-defined rule to various functions, you will directly observe its remarkable accuracy for smooth functions, verify its degree of exactness for polynomials, and explore its limitations when faced with highly oscillatory integrands relevant to wave phenomena .",
            "id": "4133056",
            "problem": "Consider the task of approximating definite integrals on the interval $[-1,1]$ using Gaussian quadrature, which is a family of formulas that integrate polynomials exactly up to a certain degree by evaluating the integrand at carefully chosen nodes with associated weights. In computational acoustics, such integrals arise in angular averaging, radiation integrals, and plane-wave expansions where variables often represent direction cosines mapped to $[-1,1]$. The Gauss–Legendre rule is the Gaussian quadrature specialized to the unit weight function $w(x)=1$ on $[-1,1]$. Starting from the foundational facts that Legendre polynomials are orthogonal on $[-1,1]$ under the unit weight and that a Gaussian quadrature with $n$ nodes can be constructed to be exact for all polynomials of degree up to $2n-1$, design and implement an algorithm that uses Gauss–Legendre nodes and weights to approximate integrals of smooth functions on $[-1,1]$.\n\nYour program must implement a Gauss–Legendre rule for a given number of nodes $n$, apply it to evaluate the integral approximation\n$$\n\\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{i=1}^{n} w_i\\,f(x_i),\n$$\nwhere $(x_i,w_i)$ are the Gauss–Legendre nodes and weights for the chosen $n$. For each test case, compute the absolute error by comparing the quadrature value to the analytic value of the integral.\n\nYou must use the following test suite, which exercises correctness, exactness at the polynomial degree boundary, symmetry of the interval, and behavior on oscillatory integrands relevant to acoustical problems:\n\n- Case A (happy path): $n=6$, $f(x)=e^x$. The analytic value is $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$. Output both the quadrature approximation and the absolute error.\n- Case B (degree boundary and symmetry): $n=6$, $f(x)=x^{11}$. This is an odd polynomial on a symmetric interval. The analytic value is $\\int_{-1}^{1} x^{11}\\,dx = 0$. Output only the absolute error.\n- Case C (beyond exactness degree): $n=6$, $f(x)=x^{12}$. The analytic value is $\\int_{-1}^{1} x^{12}\\,dx = \\frac{2}{13}$. Output only the absolute error.\n- Case D (boundary condition on $n$): $n=1$, $f(x)=e^x$. The analytic value is $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$. Output only the absolute error.\n- Case E (oscillatory acoustics-inspired test): $n=6$, $f(x)=\\cos(50 x)$. Angles must be treated in radians. The analytic value is $\\int_{-1}^{1} \\cos(50x)\\,dx = \\frac{2\\sin(50)}{50}$. Output only the absolute error.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order and data types:\n$$\n[\\text{A\\_approx},\\ \\text{A\\_err},\\ \\text{B\\_err},\\ \\text{C\\_err},\\ \\text{D\\_err},\\ \\text{E\\_err}],\n$$\nwhere each entry is a floating-point number. There are no physical units involved, and angles must be treated in radians for the cosine function in Case E.",
            "solution": "The problem is valid. It is scientifically grounded in the established mathematical theory of numerical integration, specifically Gauss-Legendre quadrature. It is well-posed, providing all necessary information, functions, and parameters to compute unique numerical results. The problem is objective and uses standard, unambiguous terminology. We may therefore proceed with the solution.\n\nThe core task is to approximate the definite integral of a function $f(x)$ over the symmetric interval $[-1, 1]$ using the Gauss-Legendre quadrature rule. This method belongs to the family of Gaussian quadratures, which are designed to yield the highest possible degree of precision for a given number of function evaluations. The general form of an $n$-point Gaussian quadrature is:\n$$\n\\int_{a}^{b} w(x) f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\nHere, $w(x)$ is a non-negative weight function, $[a, b]$ is the interval of integration, the $x_i$ are the $n$ quadrature nodes (or points), and the $w_i$ are the corresponding $n$ quadrature weights.\n\nFor the specific case of Gauss-Legendre quadrature, the interval is $[-1, 1]$ and the weight function is unity, i.e., $w(x) = 1$. The formula simplifies to:\n$$\n\\int_{-1}^{1} f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\nThe remarkable property of this method stems from the specific choice of nodes and weights. The $n$ nodes, $x_i$, are chosen to be the roots of the $n$-th degree Legendre polynomial, $P_n(x)$. The Legendre polynomials form a sequence of orthogonal polynomials on the interval $[-1, 1]$ with respect to the weight function $w(x)=1$. With this choice of nodes, the weights $w_i$ can be determined such that the quadrature formula is exact for all polynomials of degree up to and including $2n-1$. This degree of precision is twice that of other common rules, like the Newton-Cotes formulas (e.g., Trapezoidal, Simpson's), which are exact only for polynomials of degree up to $n-1$ or $n$ for an $n$-point rule.\n\nThe algorithm to solve the problem for each test case is as follows:\n1.  For a given number of nodes, $n$, obtain the set of Gauss-Legendre nodes $\\{x_i\\}_{i=1}^n$ and weights $\\{w_i\\}_{i=1}^n$. These are pre-computed values and can be retrieved using standard numerical libraries, such as `scipy.special.roots_legendre` as permitted.\n2.  Define the integrand function, $f(x)$, as specified in the test case.\n3.  Evaluate the function $f(x)$ at each node $x_i$ to get the values $f(x_i)$.\n4.  Calculate the quadrature approximation of the integral by computing the weighted sum: $I_{approx} = \\sum_{i=1}^{n} w_i f(x_i)$.\n5.  Calculate the absolute error, $E_{abs} = |I_{approx} - I_{analytic}|$, where $I_{analytic}$ is the provided exact value of the integral.\n\nWe will now apply this algorithm to each of the specified test cases.\n\n- **Case A**: $n=6$, $f(x)=e^x$. The analytic value is $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$. Since $f(x)=e^x$ is a transcendental function, not a polynomial, the Gauss-Legendre rule will not be exact. However, as $e^x$ is smooth and well-approximated by its Taylor series on $[-1, 1]$, a $6$-point rule is expected to provide high accuracy.\n\n- **Case B**: $n=6$, $f(x)=x^{11}$. The analytic value is $\\int_{-1}^{1} x^{11}\\,dx = 0$. The integrand is a polynomial of degree $11$. For $n=6$, the Gauss-Legendre rule is exact for all polynomials of degree up to $2n-1 = 2(6)-1 = 11$. Therefore, the quadrature must yield the exact result. The calculated approximation should be $0$, and the absolute error is expected to be numerically zero (i.e., at the level of machine precision).\n\n- **Case C**: $n=6$, $f(x)=x^{12}$. The analytic value is $\\int_{-1}^{1} x^{12}\\,dx = \\frac{2}{13}$. The integrand is a polynomial of degree $12$. This degree is greater than the degree of exactness, $2n-1=11$. Consequently, the quadrature rule is no longer exact for this function, and we anticipate a non-zero, albeit small, approximation error.\n\n- **Case D**: $n=1$, $f(x)=e^x$. The analytic value is $e - e^{-1}$. For $n=1$, the degree of exactness is $2(1)-1=1$. The single node is the root of $P_1(x)=x$, which is $x_1=0$. The weight is $w_1 = \\int_{-1}^{1} 1 \\,dx = 2$. The approximation is simply $I_{approx} = w_1 f(x_1) = 2 \\cdot f(0) = 2 \\cdot e^0 = 2$. We expect a much larger error than in Case A, which used a more accurate $6$-point rule.\n\n- **Case E**: $n=6$, $f(x)=\\cos(50x)$. The analytic value is $\\int_{-1}^{1} \\cos(50x)\\,dx = \\frac{2\\sin(50)}{50}$. This integrand is highly oscillatory over the interval $[-1, 1]$. Gaussian quadrature's efficiency relies on the function being well-approximated by a low-degree polynomial. A function like $\\cos(50x)$ requires a very high-degree polynomial for a good approximation, so a $6$-point rule is insufficient to capture its behavior. We expect a large approximation error, illustrating a limitation of low-order quadrature for such functions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Implements Gauss-Legendre quadrature to approximate definite integrals\n    and calculates the absolute error for a suite of test cases.\n    \"\"\"\n\n    results = []\n\n    # Case A: n=6, f(x) = e^x\n    n_A = 6\n    f_A = np.exp\n    analytic_A = np.exp(1) - np.exp(-1)\n    nodes_A, weights_A = roots_legendre(n_A)\n    approx_A = np.sum(weights_A * f_A(nodes_A))\n    err_A = np.abs(approx_A - analytic_A)\n    results.extend([approx_A, err_A])\n\n    # Case B: n=6, f(x) = x^11 (degree is 2n-1, should be exact)\n    n_B = 6\n    f_B = lambda x: x**11\n    analytic_B = 0.0\n    nodes_B, weights_B = roots_legendre(n_B)\n    approx_B = np.sum(weights_B * f_B(nodes_B))\n    err_B = np.abs(approx_B - analytic_B)\n    results.append(err_B)\n\n    # Case C: n=6, f(x) = x^12 (degree is 2n, should not be exact)\n    n_C = 6\n    f_C = lambda x: x**12\n    analytic_C = 2.0 / 13.0\n    nodes_C, weights_C = roots_legendre(n_C)\n    approx_C = np.sum(weights_C * f_C(nodes_C))\n    err_C = np.abs(approx_C - analytic_C)\n    results.append(err_C)\n\n    # Case D: n=1, f(x) = e^x\n    n_D = 1\n    f_D = np.exp\n    analytic_D = np.exp(1) - np.exp(-1)\n    nodes_D, weights_D = roots_legendre(n_D)\n    approx_D = np.sum(weights_D * f_D(nodes_D))\n    err_D = np.abs(approx_D - analytic_D)\n    results.append(err_D)\n\n    # Case E: n=6, f(x) = cos(50x) (oscillatory function)\n    n_E = 6\n    f_E = lambda x: np.cos(50 * x)\n    analytic_E = 2.0 * np.sin(50) / 50.0\n    nodes_E, weights_E = roots_legendre(n_E)\n    approx_E = np.sum(weights_E * f_E(nodes_E))\n    err_E = np.abs(approx_E - analytic_E)\n    results.append(err_E)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While using pre-computed quadrature rules is convenient, a deeper understanding comes from building them from first principles. This practice guides you through the elegant Golub-Welsch algorithm, which reveals the profound connection between Gaussian quadrature and the spectral theory of symmetric matrices . By constructing a 3-point Gauss-Legendre rule yourself, you will transform the abstract theory of orthogonal polynomials into a tangible and powerful computational tool.",
            "id": "4132998",
            "problem": "Consider the role of orthogonal polynomial-based Gaussian quadrature in computational acoustics, where axisymmetric boundary-integral formulations of the Helmholtz equation naturally involve expansions in Legendre polynomials over the interval $[-1,1]$. Starting from the core definitions of orthogonality of Legendre polynomials with respect to the unit weight on $[-1,1]$ and their three-term recurrence, construct the $3$-point Gauss–Legendre quadrature on $[-1,1]$ without using any pre-tabulated nodes or weights. Your derivation should be grounded in the existence of a symmetric tridiagonal Jacobi matrix associated with orthogonal polynomials and the spectral theorem for real symmetric matrices, but you must not assume or quote closed-form nodes or weights. Numerically compute the nodes and weights, and then use them to verify exactness properties.\n\nYou must implement a complete runnable program that:\n- Constructs the $3$-point Gauss–Legendre quadrature for the unit weight on $[-1,1]$ using a numerically stable procedure based on the symmetric tridiagonal Jacobi matrix associated with Legendre polynomials (do not use pre-tabulated quadrature rules).\n- Uses the computed nodes and weights to evaluate the quadrature of the following functions over $[-1,1]$:\n  1. $f_1(x) = x^5$.\n  2. $f_2(x) = x^6$.\n  3. $f_3(x) = P_5(x)$, where $P_5$ is the Legendre polynomial of degree $5$.\n- Checks the following properties:\n  1. Symmetry of the nodes: $x_1 \\approx -x_3$ and $x_2 \\approx 0$ within a tolerance of $10^{-12}$.\n  2. Conservation of the total weight: $\\sum_{i=1}^3 w_i \\approx 2$ within machine precision.\n\nTest Suite and Answer Specification:\n- Test case $1$ (exactness for odd polynomial up to degree $2n-1$): Compute the quadrature approximation of $\\int_{-1}^{1} x^5 \\, dx$ and report it as a float.\n- Test case $2$ (non-exactness beyond degree $2n-1$): Compute the absolute error of the quadrature approximation to $\\int_{-1}^{1} x^6 \\, dx$, where the exact integral is $\\frac{2}{7}$, and report it as a float.\n- Test case $3$ (weight sum check): Compute $\\sum_{i=1}^3 w_i$ and report it as a float.\n- Test case $4$ (node symmetry check): Report a boolean indicating whether $|x_1 + x_3| \\le 10^{-12}$ and $|x_2| \\le 10^{-12}$.\n- Test case $5$ (axisymmetric acoustics relevance): Compute the quadrature approximation of $\\int_{-1}^{1} P_5(x) \\, dx$ and report it as a float.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order: $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$, where each result is respectively the float for the integral of $x^5$, the float absolute error for $x^6$, the float sum of weights, the boolean for node symmetry, and the float for the integral of $P_5(x)$. No physical units or angle units are involved; all quantities are dimensionless real numbers. The boolean must be reported in the programming language’s canonical boolean representation.",
            "solution": "The problem statement is a valid computational exercise in numerical analysis, specifically concerning the construction of Gaussian quadrature rules from first principles. It is scientifically grounded in the theory of orthogonal polynomials and their connection to eigenvalue problems, well-posed with a unique and computable solution, and expressed in objective, formal language. The problem is self-contained and free of contradictions. I will now proceed with the solution.\n\nThe core principle of Gaussian quadrature is to select a set of $n$ points (nodes) $x_i$ and corresponding weights $w_i$ to approximate an integral with a weighted sum, such that the approximation is exact for all polynomials up to the highest possible degree, which is $2n-1$. For an integral over the interval $[-1, 1]$ with a weight function $W(x)$, the quadrature rule is:\n$$\n\\int_{-1}^{1} W(x) f(x) \\, dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\nFor Gauss-Legendre quadrature, the weight function is $W(x) = 1$.\n\nThe construction of the nodes and weights is deeply connected to the properties of orthogonal polynomials. A sequence of polynomials $\\{p_k(x)\\}_{k=0}^\\infty$ is orthogonal with respect to the weight function $W(x)$ on $[a, b]$ if their inner product is zero for different degrees:\n$$\n\\langle p_m, p_n \\rangle = \\int_{a}^{b} W(x) p_m(x) p_n(x) \\, dx = C_n \\delta_{mn}\n$$\nwhere $C_n$ is a normalization constant and $\\delta_{mn}$ is the Kronecker delta. For Legendre polynomials $P_n(x)$ on $[-1, 1]$ with $W(x)=1$, this relation is $\\int_{-1}^{1} P_m(x) P_n(x) \\, dx = \\frac{2}{2n+1} \\delta_{mn}$. The nodes $x_i$ of an $n$-point Gauss-Legendre quadrature rule are the roots of the Legendre polynomial $P_n(x)$.\n\nA powerful and numerically stable method for finding the nodes and weights, known as the Golub-Welsch algorithm, avoids finding polynomial roots directly. It leverages the three-term recurrence relation that all orthogonal polynomials satisfy. For monic orthogonal polynomials $\\pi_k(x)$ (where the leading coefficient is $1$), this recurrence can be written as:\n$$\n\\pi_{k+1}(x) = (x - \\alpha_k) \\pi_k(x) - \\beta_k \\pi_{k-1}(x)\n$$\nwith initial conditions $\\pi_0(x) = 1$ and $\\pi_{-1}(x) = 0$. The coefficients $\\alpha_k$ and $\\beta_k$ are determined by the specific family of orthogonal polynomials.\n\nThis recurrence leads to the construction of a symmetric tridiagonal matrix, the Jacobi matrix $J_n$, of size $n \\times n$:\n$$\nJ_n = \\begin{pmatrix}\n\\alpha_0 & \\sqrt{\\beta_1} & 0 & \\dots & 0 \\\\\n\\sqrt{\\beta_1} & \\alpha_1 & \\sqrt{\\beta_2} & \\dots & 0 \\\\\n0 & \\sqrt{\\beta_2} & \\alpha_2 & \\ddots & \\vdots \\\\\n\\vdots & & \\ddots & \\ddots & \\sqrt{\\beta_{n-1}} \\\\\n0 & \\dots & \\dots & \\sqrt{\\beta_{n-1}} & \\alpha_{n-1}\n\\end{pmatrix}\n$$\nThe key insight is that the eigenvalues of this matrix $J_n$ are precisely the quadrature nodes $x_i$. This is a consequence of the spectral theorem for real symmetric matrices. Furthermore, the quadrature weights $w_i$ can be computed from the eigenvectors of $J_n$. If $v_i$ is the normalized eigenvector corresponding to the eigenvalue $x_i$, and $v_{i,1}$ is its first component, the weight $w_i$ is given by:\n$$\nw_i = \\mu_0 (v_{i,1})^2\n$$\nwhere $\\mu_0 = \\int_{-1}^{1} W(x) \\, dx$ is the zeroth moment of the weight function.\n\nFor the Gauss-Legendre quadrature on $[-1, 1]$ ($W(x)=1$), the recurrence coefficients for the monic Legendre polynomials are:\n$$\n\\alpha_k = 0 \\quad \\text{for } k \\ge 0\n$$\n$$\n\\beta_k = \\frac{k^2}{4k^2 - 1} \\quad \\text{for } k \\ge 1\n$$\nThe zeroth moment is $\\mu_0 = \\int_{-1}^{1} 1 \\, dx = 2$.\n\nTo construct the $3$-point rule ($n=3$), we need the coefficients $\\alpha_0, \\alpha_1, \\alpha_2$ and $\\beta_1, \\beta_2$.\n- $\\alpha_0 = 0, \\alpha_1 = 0, \\alpha_2 = 0$.\n- $\\beta_1 = \\frac{1^2}{4(1)^2 - 1} = \\frac{1}{3}$.\n- $\\beta_2 = \\frac{2^2}{4(2)^2 - 1} = \\frac{4}{15}$.\n\nThe $3 \\times 3$ Jacobi matrix $J_3$ is therefore:\n$$\nJ_3 = \\begin{pmatrix}\n0 & \\sqrt{1/3} & 0 \\\\\n\\sqrt{1/3} & 0 & \\sqrt{4/15} \\\\\n0 & \\sqrt{4/15} & 0\n\\end{pmatrix}\n$$\nThe computational procedure is as follows:\n1.  Construct the matrix $J_3$.\n2.  Solve the eigenvalue problem $J_3 v_i = x_i v_i$ to find the eigenvalues $x_i$ (nodes) and the corresponding normalized eigenvectors $v_i$. A numerically stable algorithm for symmetric matrices, such as the one implemented in `numpy.linalg.eigh`, should be used.\n3.  Calculate the weights using the formula $w_i = 2 (v_{i,1})^2$, where $v_{i,1}$ is the first component of the $i$-th eigenvector.\n4.  With the computed nodes $\\{x_i\\}$ and weights $\\{w_i\\}$, apply the quadrature rule $\\sum_{i=1}^3 w_i f(x_i)$ to the specified functions and perform the required checks. An $n=3$ rule is exact for polynomials of degree up to $2n-1 = 5$.\n\nThe functions to be integrated are $f_1(x) = x^5$, $f_2(x) = x^6$, and $f_3(x) = P_5(x)$, where $P_5(x) = \\frac{1}{8}(63x^5 - 70x^3 + 15x)$.\n- For $f_1(x)=x^5$, the degree is $5$. The quadrature rule must be exact. The exact integral is $\\int_{-1}^{1} x^5 \\, dx = 0$.\n- For $f_2(x)=x^6$, the degree is $6$, exceeding the exactness limit. The quadrature will not be exact. The exact integral is $\\int_{-1}^{1} x^6 \\, dx = \\frac{2}{7}$.\n- For $f_3(x)=P_5(x)$, the degree is $5$. The quadrature rule must be exact. By orthogonality, $\\int_{-1}^{1} P_5(x) \\, dx = \\int_{-1}^{1} P_5(x) P_0(x) \\, dx = 0$.\n\nThe following implementation carries out these steps to produce the requested results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and verifies the 3-point Gauss-Legendre quadrature rule\n    using the Jacobi matrix eigenvalue method.\n    \"\"\"\n\n    # 1. Construct the 3-point Gauss-Legendre quadrature rule\n    n = 3\n    \n    # Recurrence coefficients for monic Legendre polynomials\n    # alpha_k = 0 for all k\n    # beta_k = k^2 / (4*k^2 - 1) for k >= 1\n    alphas = np.zeros(n)\n    betas = np.array([k**2 / (4 * k**2 - 1) for k in range(n + 1)]) # range includes 0\n    \n    # Construct the symmetric tridiagonal Jacobi matrix J_n\n    J = np.zeros((n, n))\n    J += np.diag(alphas)\n    J += np.diag(np.sqrt(betas[1:n]), k=1)\n    J += np.diag(np.sqrt(betas[1:n]), k=-1)\n    \n    # 2. Solve the eigenvalue problem to get nodes and weights\n    # Eigenvalues are the quadrature nodes.\n    # eigh returns eigenvalues in ascending order.\n    eigenvalues, eigenvectors = np.linalg.eigh(J)\n    nodes = eigenvalues\n    \n    # Weights are derived from the first component of the normalized eigenvectors.\n    # mu_0 is the integral of the weight function w(x)=1 over [-1, 1], which is 2.\n    mu_0 = 2.0\n    weights = mu_0 * eigenvectors[0, :]**2\n    \n    results = []\n\n    # 3. Perform the test calculations as specified in the problem\n    \n    # Test case 1: Compute quadrature of integral(x^5) dx from -1 to 1.\n    # The 3-point rule is exact for polynomials of degree up to 2*3-1=5.\n    # The exact integral is 0.\n    f1 = lambda x: x**5\n    integrand_1 = f1(nodes)\n    quad_result_1 = np.sum(weights * integrand_1)\n    results.append(quad_result_1)\n    \n    # Test case 2: Compute absolute error of quadrature for integral(x^6) dx.\n    # The rule is not exact for degree 6. The exact integral is 2/7.\n    exact_integral_2 = 2.0 / 7.0\n    f2 = lambda x: x**6\n    integrand_2 = f2(nodes)\n    quad_result_2 = np.sum(weights * integrand_2)\n    abs_error_2 = np.abs(quad_result_2 - exact_integral_2)\n    results.append(abs_error_2)\n    \n    # Test case 3: Compute the sum of the weights.\n    # Should equal mu_0 = 2.\n    sum_of_weights = np.sum(weights)\n    results.append(sum_of_weights)\n    \n    # Test case 4: Check for node symmetry.\n    # Nodes are x_1, x_2, x_3, sorted ascending.\n    # We check if x_1 = -x_3 and x_2 = 0 within a tolerance.\n    tol = 1e-12\n    symmetry_check = (np.abs(nodes[0] + nodes[2]) = tol) and \\\n                     (np.abs(nodes[1]) = tol)\n    results.append(symmetry_check)\n    \n    # Test case 5: Compute quadrature of integral(P_5(x)) dx from -1 to 1.\n    # P_5(x) = (1/8)*(63*x^5 - 70*x^3 + 15*x). Degree is 5, so quadrature is exact.\n    # The exact integral is 0 by orthogonality with P_0(x)=1.\n    def p5(x):\n        return (1/8.0) * (63 * x**5 - 70 * x**3 + 15 * x)\n    integrand_5 = p5(nodes)\n    quad_result_5 = np.sum(weights * integrand_5)\n    results.append(quad_result_5)\n\n    # Convert boolean to its canonical string representation and format output\n    str_results = []\n    for r in results:\n        if isinstance(r, bool):\n            str_results.append(str(r))\n        else:\n            str_results.append(f\"{r:.15g}\")\n            \n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "In computational acoustics, integrands are often highly oscillatory, posing a significant challenge for general-purpose quadrature methods. This exercise investigates the performance of Gauss-Legendre quadrature for such integrals and compares it to a specialized Filon-type method designed for this very purpose . This comparative analysis is crucial for developing the practical skill of selecting the most efficient and accurate numerical algorithm for a given physical problem, particularly as wave frequency increases.",
            "id": "4133001",
            "problem": "Consider the canonical oscillatory integral from computational acoustics for a one-dimensional, constant-amplitude plane wave over a symmetric aperture, defined by the real-valued integral\n$$\nI(k) = \\int_{-1}^{1} \\cos(k x)\\,dx,\n$$\nwhere $k$ is a nonnegative angular wavenumber and all angles are measured in radians. In numerical propagation and radiation models, accuracy depends on the ability of a quadrature rule to resolve oscillations as $k$ increases. You will investigate the error as a function of the number of nodes or subintervals and compare a Gaussian quadrature (Gauss–Legendre rule) to a Filon-type rule tailored to oscillatory integrals.\n\nStarting from foundational principles of calculus and orthogonal polynomials—specifically, the Fundamental Theorem of Calculus, properties of trigonometric functions, and the exactness of Gauss–Legendre quadrature for polynomials up to degree $2n-1$—derive and implement the following:\n\n1. A Gauss–Legendre quadrature approximation to $I(k)$ with $n$ nodes over $[-1,1]$.\n2. A Filon-type composite rule over $[-1,1]$ that approximates the oscillatory factor by integrating it exactly on each subinterval while treating the amplitude as piecewise constant (equal to the midpoint amplitude). For this problem, the physical amplitude is exactly constant and equal to $1$, and angles are in radians.\n\nCompute, for each prescribed $k$, the absolute error $E_{\\mathrm{GL}}(k,n)$ of the Gauss–Legendre approximation and the absolute error $E_{\\mathrm{F}}(k,m)$ of the Filon-type approximation, where $n$ is the number of Gauss–Legendre nodes and $m$ is the number of uniform subintervals in the Filon-type composite rule. Use only mathematically valid operations; do not assume any shortcut formulas beyond the foundational principles.\n\nYour program must:\n- For each $k$ in the test suite, evaluate $E_{\\mathrm{GL}}(k,n)$ for $n \\in \\{\\,1,2,4,8,16,32,64,128\\,\\}$ and $E_{\\mathrm{F}}(k,m)$ for $m \\in \\{\\,1,2,4,8,16,32,64,128\\,\\}$.\n- Use an absolute error tolerance of $10^{-12}$ to determine the smallest $n$ (denoted $n^\\star_{\\mathrm{GL}}(k)$) such that $E_{\\mathrm{GL}}(k,n) \\le 10^{-12}$, and similarly the smallest $m$ (denoted $m^\\star_{\\mathrm{F}}(k)$) such that $E_{\\mathrm{F}}(k,m) \\le 10^{-12}$. If no value in the specified sets satisfies the tolerance, report $-1$ for that quantity.\n- Report, for each $k$, the maximum absolute error across the tested $n$ for Gauss–Legendre, $\\max_{n} E_{\\mathrm{GL}}(k,n)$, and the maximum absolute error across the tested $m$ for Filon-type, $\\max_{m} E_{\\mathrm{F}}(k,m)$.\n\nTest suite (angles in radians):\n- $k = 0$,\n- $k = \\pi$,\n- $k = 50$,\n- $k = 200$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain one entry per $k$ in the test suite, in the same order as listed above.\n- For each $k$, output the list $[\\,n^\\star_{\\mathrm{GL}}(k),\\,m^\\star_{\\mathrm{F}}(k),\\,\\max_{n} E_{\\mathrm{GL}}(k,n),\\,\\max_{m} E_{\\mathrm{F}}(k,m)\\,]$.\n- All numerical values must be reported as plain decimals (floats) or integers. No units are required because all quantities are dimensionless and angles are in radians.\n- Example of the required output structure (with placeholders): $[[\\,n_1,m_1,e_{1,\\max}^{\\mathrm{GL}},e_{1,\\max}^{\\mathrm{F}}\\,],[\\,n_2,m_2,e_{2,\\max}^{\\mathrm{GL}},e_{2,\\max}^{\\mathrm{F}}\\,],\\dots]$.\n\nYour implementation must be a complete, runnable program, and must not require any external input.",
            "solution": "The problem requires a comparative analysis of two numerical quadrature methods—Gauss–Legendre and a zeroth-order Filon-type rule—for the canonical oscillatory integral $I(k) = \\int_{-1}^{1} \\cos(k x)\\,dx$. The analysis involves implementing both methods, calculating their absolute error against the exact analytical solution for various wavenumbers $k$, and determining the computational effort (number of nodes or subintervals) required to achieve a specified accuracy.\n\n### 1. Analytical Solution\n\nThe first step is to find the exact value of the integral, which serves as the ground truth for error calculations. We use the Fundamental Theorem of Calculus.\n\nFor a non-zero angular wavenumber $k > 0$:\n$$\nI(k) = \\int_{-1}^{1} \\cos(k x)\\,dx = \\left[ \\frac{\\sin(k x)}{k} \\right]_{-1}^{1} = \\frac{\\sin(k \\cdot 1)}{k} - \\frac{\\sin(k \\cdot (-1))}{k}\n$$\nUsing the property that $\\sin(-x) = -\\sin(x)$, this simplifies to:\n$$\nI(k) = \\frac{\\sin(k) - (-\\sin(k))}{k} = \\frac{2\\sin(k)}{k}\n$$\n\nFor the special case where the wavenumber $k=0$:\n$$\nI(0) = \\int_{-1}^{1} \\cos(0 \\cdot x)\\,dx = \\int_{-1}^{1} 1\\,dx = [x]_{-1}^{1} = 1 - (-1) = 2\n$$\nIt is worth noting that the solution for $k>0$ is continuous at $k=0$, as $\\lim_{k \\to 0} \\frac{2\\sin(k)}{k} = 2$, which matches $I(0)$.\n\n### 2. Method 1: Gauss–Legendre Quadrature\n\nGauss–Legendre quadrature is a powerful method for approximating integrals over the interval $[-1, 1]$. Its general form is:\n$$\n\\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\nHere, $n$ is the number of nodes. The nodes $x_i$ are the roots of the $n$-th degree Legendre polynomial, $P_n(x)$, and the weights $w_i$ are derived from the theory of orthogonal polynomials. A key property of this rule is that it is exact for any polynomial of degree up to $2n-1$.\n\nFor our specific integral, the integrand is $f(x) = \\cos(kx)$. The Gauss–Legendre approximation, $I_{\\mathrm{GL}}(k,n)$, is:\n$$\nI_{\\mathrm{GL}}(k,n) = \\sum_{i=1}^{n} w_i \\cos(k x_i)\n$$\nFor $k=0$, the integrand is $f(x) = \\cos(0) = 1$, which is a polynomial of degree $0$. The $n=1$ Gauss-Legendre rule is exact for polynomials of degree up to $2(1)-1=1$, so it will integrate $f(x)=1$ exactly. For $n \\ge 1$, the approximation will be exact.\n\nFor $k > 0$, $\\cos(kx)$ is not a polynomial. The accuracy of the approximation depends on how well the integrand can be represented by a polynomial of degree $2n-1$. As $k$ increases, the function oscillates more rapidly, requiring a higher-degree polynomial (and thus a larger $n$) to achieve a given accuracy. The absolute error is calculated as $E_{\\mathrm{GL}}(k,n) = |I(k) - I_{\\mathrm{GL}}(k,n)|$.\n\nThe nodes and weights will be computed numerically using routines from the `scipy` library, which is standard practice.\n\n### 3. Method 2: Filon-type Composite Rule\n\nFilon-type methods are specifically designed for oscillatory integrals of the form $\\int_{a}^{b} g(x) \\Omega(kx) dx$, where $g(x)$ is a slowly varying amplitude and $\\Omega(kx)$ is a rapidly oscillating function (e.g., $\\cos(kx)$ or $\\sin(kx)$). The core idea is to approximate $g(x)$ by a simpler function (like a low-degree polynomial) on subintervals and then integrate the resulting product $p(x)\\Omega(kx)$ exactly.\n\nThe problem specifies a zeroth-order composite rule:\n1. Divide the interval $[-1, 1]$ into $m$ uniform subintervals, $[x_j, x_{j+1}]$, each of length $h = \\frac{2}{m}$, where $x_j = -1 + jh$.\n2. On each subinterval, approximate the amplitude function $g(x)$—which in our case is $g(x)=1$—by a constant equal to its value at the subinterval's midpoint.\n3. Integrate the resulting approximation exactly over each subinterval.\n\nFor the integral $I(k) = \\int_{-1}^{1} 1 \\cdot \\cos(kx) dx$, the amplitude is $g(x) = 1$. Approximating this constant function by its midpoint value results in the constant $1$ itself. Therefore, on each subinterval $[x_j, x_{j+1}]$, the approximation to the integral is:\n$$\n\\int_{x_j}^{x_{j+1}} (\\text{midpoint value of } g(x)) \\cdot \\cos(kx)\\,dx = \\int_{x_j}^{x_{j+1}} 1 \\cdot \\cos(kx)\\,dx\n$$\nThe Filon-type approximation $I_{\\mathrm{F}}(k,m)$ is the sum of these integrals over all $m$ subintervals:\n$$\nI_{\\mathrm{F}}(k,m) = \\sum_{j=0}^{m-1} \\int_{x_j}^{x_{j+1}} \\cos(kx)\\,dx\n$$\nBy the additivity property of definite integrals, this sum telescopes to the original integral over the full domain:\n$$\nI_{\\mathrm{F}}(k,m) = \\int_{x_0}^{x_m} \\cos(kx)\\,dx = \\int_{-1}^{1} \\cos(kx)\\,dx = I(k)\n$$\nThis demonstrates a crucial result: for this specific problem where the amplitude function is exactly constant, the prescribed Filon-type rule is **analytically exact** for any number of subintervals $m \\ge 1$ and for all values of $k$. Consequently, the absolute error $E_{\\mathrm{F}}(k,m) = |I(k) - I_{\\mathrm{F}}(k,m)|$ will be zero, or a very small number limited only by floating-point precision. This means that for any $k$, the smallest number of subintervals to reach the tolerance is $m^\\star_{\\mathrm{F}}(k) = 1$, and the maximum error across all tested $m$ will be approximately $0$.\n\n### 4. Computational Procedure\n\nThe program will execute the following steps for each $k$ in the test suite $\\{0, \\pi, 50, 200\\}$:\n\n1.  **Compute Exact Value**: Calculate $I(k)$ using the analytical formulas derived above, with special handling for $k=0$.\n2.  **Evaluate Gauss–Legendre Error**:\n    *   Initialize $n^\\star_{\\mathrm{GL}} = -1$ and $\\max_{n} E_{\\mathrm{GL}} = 0$.\n    *   Iterate through $n \\in \\{1, 2, 4, 8, 16, 32, 64, 128\\}$.\n    *   For each $n$, fetch the Gauss-Legendre nodes $x_i$ and weights $w_i$.\n    *   Compute the approximation $I_{\\mathrm{GL}}(k,n) = \\sum_{i=1}^{n} w_i \\cos(k x_i)$.\n    *   Calculate the absolute error $E_{\\mathrm{GL}}(k,n) = |I(k) - I_{\\mathrm{GL}}(k,n)|$.\n    *   Update $\\max_{n} E_{\\mathrm{GL}}$ with the current error if it is larger.\n    *   If $E_{\\mathrm{GL}}(k,n) \\le 10^{-12}$ and $n^\\star_{\\mathrm{GL}}$ has not yet been set, assign $n^\\star_{\\mathrm{GL}} = n$.\n3.  **Evaluate Filon-type Error**:\n    *   Based on our analytical finding, $I_{\\mathrm{F}}(k,m)$ is identical to $I(k)$.\n    *   Therefore, $m^\\star_{\\mathrm{F}}(k) = 1$ (the first value in the set of $m$).\n    *   The error $E_{\\mathrm{F}}(k,m)$ is effectively $0$ for all $m$. The maximum error $\\max_{m} E_{\\mathrm{F}}$ is also $0$.\n4.  **Collate and Report**: Store the computed tuple $[n^\\star_{\\mathrm{GL}}, m^\\star_{\\mathrm{F}}, \\max_{n} E_{\\mathrm{GL}}, \\max_{m} E_{\\mathrm{F}}]$ for the current $k$ and proceed to the next value in the test suite. Finally, format the collected results as a single line of text.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes and compares the error of Gauss-Legendre and Filon-type\n    quadrature for a canonical oscillatory integral from computational acoustics.\n    \"\"\"\n    \n    # Define the problem parameters\n    test_suite_k = [0.0, np.pi, 50.0, 200.0]\n    n_values = [1, 2, 4, 8, 16, 32, 64, 128]\n    m_values = [1, 2, 4, 8, 16, 32, 64, 128]\n    tolerance = 1e-12\n\n    def exact_integral(k):\n        \"\"\"Computes the exact value of the integral I(k) = int_{-1}^{1} cos(kx) dx.\"\"\"\n        if k == 0.0:\n            return 2.0\n        else:\n            return 2.0 * np.sin(k) / k\n\n    def gauss_legendre_approx(k, n):\n        \"\"\"Computes the Gauss-Legendre quadrature approximation for I(k) with n nodes.\"\"\"\n        nodes, weights = roots_legendre(n)\n        integrand_values = np.cos(k * nodes)\n        return np.sum(weights * integrand_values)\n\n    def filon_type_approx(k, m):\n        \"\"\"\n        Computes the Filon-type quadrature approximation.\n        As derived in the solution, for f(x)=1, this method is analytically exact\n        for any m >= 1, and thus returns the exact integral value.\n        \"\"\"\n        return exact_integral(k)\n\n    all_results = []\n    for k in test_suite_k:\n        # Calculate the exact value for the current k\n        i_exact = exact_integral(k)\n\n        # --- Gauss-Legendre Analysis ---\n        n_star_gl = -1\n        max_err_gl = 0.0\n        for n in n_values:\n            i_gl = gauss_legendre_approx(k, n)\n            err_gl = np.abs(i_exact - i_gl)\n            \n            if err_gl > max_err_gl:\n                max_err_gl = err_gl\n            \n            if err_gl = tolerance and n_star_gl == -1:\n                n_star_gl = n\n\n        # --- Filon-type Analysis ---\n        m_star_f = -1\n        max_err_f = 0.0\n        for m in m_values:\n            # As derived, the Filon-type approximation for a constant amplitude of 1\n            # is identical to the exact integral. The error is thus 0 up to machine precision.\n            i_f = filon_type_approx(k, m)\n            err_f = np.abs(i_exact - i_f)\n\n            if err_f > max_err_f:\n                max_err_f = err_f\n\n            if err_f = tolerance and m_star_f == -1:\n                m_star_f = m\n        \n        # In the specific case for Filon method, m_star_f will always be the first\n        # element, 1, and max_err_f will be ~0 due to exactness.\n        # This explicit check handles the case where m_values might not start at 1.\n        if m_star_f == -1 and m_values:\n             # Fallback if no m met the tolerance, which shouldn't happen here.\n             pass\n\n        # Collect results for this k\n        all_results.append([n_star_gl, m_star_f, max_err_gl, max_err_f])\n\n    # Format the final output string exactly as required\n    # e.g., [[1, 1, 0.0, 0.0], [8, 1, 0.5103, 0.0], ...]\n    result_str = \"[\" + \",\".join([f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\" for res in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}