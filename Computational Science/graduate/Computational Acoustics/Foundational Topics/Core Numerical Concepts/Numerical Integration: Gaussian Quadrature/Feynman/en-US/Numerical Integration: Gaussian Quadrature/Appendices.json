{
    "hands_on_practices": [
        {
            "introduction": "The first step in mastering any numerical technique is to develop an intuition for its behavior in practice. This exercise provides a hands-on exploration of the Gauss-Legendre quadrature rule, a cornerstone of numerical integration. By applying a standard implementation to a variety of functions, you will directly observe its remarkable accuracy for smooth functions, verify its theoretical exactness for polynomials up to degree $2n-1$, and probe its limitations when faced with highly oscillatory integrands—a common challenge in computational acoustics .",
            "id": "4133056",
            "problem": "Consider the task of approximating definite integrals on the interval $[-1,1]$ using Gaussian quadrature, which is a family of formulas that integrate polynomials exactly up to a certain degree by evaluating the integrand at carefully chosen nodes with associated weights. In computational acoustics, such integrals arise in angular averaging, radiation integrals, and plane-wave expansions where variables often represent direction cosines mapped to $[-1,1]$. The Gauss–Legendre rule is the Gaussian quadrature specialized to the unit weight function $w(x)=1$ on $[-1,1]$. Starting from the foundational facts that Legendre polynomials are orthogonal on $[-1,1]$ under the unit weight and that a Gaussian quadrature with $n$ nodes can be constructed to be exact for all polynomials of degree up to $2n-1$, design and implement an algorithm that uses Gauss–Legendre nodes and weights to approximate integrals of smooth functions on $[-1,1]$.\n\nYour program must implement a Gauss–Legendre rule for a given number of nodes $n$, apply it to evaluate the integral approximation\n$$\n\\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{i=1}^{n} w_i\\,f(x_i),\n$$\nwhere $(x_i,w_i)$ are the Gauss–Legendre nodes and weights for the chosen $n$. For each test case, compute the absolute error by comparing the quadrature value to the analytic value of the integral.\n\nYou must use the following test suite, which exercises correctness, exactness at the polynomial degree boundary, symmetry of the interval, and behavior on oscillatory integrands relevant to acoustical problems:\n\n- Case A (happy path): $n=6$, $f(x)=e^x$. The analytic value is $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$. Output both the quadrature approximation and the absolute error.\n- Case B (degree boundary and symmetry): $n=6$, $f(x)=x^{11}$. This is an odd polynomial on a symmetric interval. The analytic value is $\\int_{-1}^{1} x^{11}\\,dx = 0$. Output only the absolute error.\n- Case C (beyond exactness degree): $n=6$, $f(x)=x^{12}$. The analytic value is $\\int_{-1}^{1} x^{12}\\,dx = \\frac{2}{13}$. Output only the absolute error.\n- Case D (boundary condition on $n$): $n=1$, $f(x)=e^x$. The analytic value is $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$. Output only the absolute error.\n- Case E (oscillatory acoustics-inspired test): $n=6$, $f(x)=\\cos(50 x)$. Angles must be treated in radians. The analytic value is $\\int_{-1}^{1} \\cos(50x)\\,dx = \\frac{2\\sin(50)}{50}$. Output only the absolute error.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order and data types:\n$$\n[\\text{A\\_approx},\\ \\text{A\\_err},\\ \\text{B\\_err},\\ \\text{C\\_err},\\ \\text{D\\_err},\\ \\text{E\\_err}],\n$$\nwhere each entry is a floating-point number. There are no physical units involved, and angles must be treated in radians for the cosine function in Case E.",
            "solution": "The problem is valid. It is scientifically grounded in the established mathematical theory of numerical integration, specifically Gauss-Legendre quadrature. It is well-posed, providing all necessary information, functions, and parameters to compute unique numerical results. The problem is objective and uses standard, unambiguous terminology. We may therefore proceed with the solution.\n\nThe core task is to approximate the definite integral of a function $f(x)$ over the symmetric interval $[-1, 1]$ using the Gauss-Legendre quadrature rule. This method belongs to the family of Gaussian quadratures, which are designed to yield the highest possible degree of precision for a given number of function evaluations. The general form of an $n$-point Gaussian quadrature is:\n$$\n\\int_{a}^{b} w(x) f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\nHere, $w(x)$ is a non-negative weight function, $[a, b]$ is the interval of integration, the $x_i$ are the $n$ quadrature nodes (or points), and the $w_i$ are the corresponding $n$ quadrature weights.\n\nFor the specific case of Gauss-Legendre quadrature, the interval is $[-1, 1]$ and the weight function is unity, i.e., $w(x) = 1$. The formula simplifies to:\n$$\n\\int_{-1}^{1} f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\nThe remarkable property of this method stems from the specific choice of nodes and weights. The $n$ nodes, $x_i$, are chosen to be the roots of the $n$-th degree Legendre polynomial, $P_n(x)$. The Legendre polynomials form a sequence of orthogonal polynomials on the interval $[-1, 1]$ with respect to the weight function $w(x)=1$. With this choice of nodes, the weights $w_i$ can be determined such that the quadrature formula is exact for all polynomials of degree up to and including $2n-1$. This degree of precision is twice that of other common rules, like the Newton-Cotes formulas (e.g., Trapezoidal, Simpson's), which are exact only for polynomials of degree up to $n-1$ or $n$ for an $n$-point rule.\n\nThe algorithm to solve the problem for each test case is as follows:\n1.  For a given number of nodes, $n$, obtain the set of Gauss-Legendre nodes $\\{x_i\\}_{i=1}^n$ and weights $\\{w_i\\}_{i=1}^n$. These are pre-computed values and can be retrieved using standard numerical libraries, such as `scipy.special.roots_legendre` as permitted.\n2.  Define the integrand function, $f(x)$, as specified in the test case.\n3.  Evaluate the function $f(x)$ at each node $x_i$ to get the values $f(x_i)$.\n4.  Calculate the quadrature approximation of the integral by computing the weighted sum: $I_{approx} = \\sum_{i=1}^{n} w_i f(x_i)$.\n5.  Calculate the absolute error, $E_{abs} = |I_{approx} - I_{analytic}|$, where $I_{analytic}$ is the provided exact value of the integral.\n\nWe will now apply this algorithm to each of the specified test cases.\n\n- **Case A**: $n=6$, $f(x)=e^x$. The analytic value is $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$. Since $f(x)=e^x$ is a transcendental function, not a polynomial, the Gauss-Legendre rule will not be exact. However, as $e^x$ is smooth and well-approximated by its Taylor series on $[-1, 1]$, a $6$-point rule is expected to provide high accuracy.\n\n- **Case B**: $n=6$, $f(x)=x^{11}$. The analytic value is $\\int_{-1}^{1} x^{11}\\,dx = 0$. The integrand is a polynomial of degree $11$. For $n=6$, the Gauss-Legendre rule is exact for all polynomials of degree up to $2n-1 = 2(6)-1 = 11$. Therefore, the quadrature must yield the exact result. The calculated approximation should be $0$, and the absolute error is expected to be numerically zero (i.e., at the level of machine precision).\n\n- **Case C**: $n=6$, $f(x)=x^{12}$. The analytic value is $\\int_{-1}^{1} x^{12}\\,dx = \\frac{2}{13}$. The integrand is a polynomial of degree $12$. This degree is greater than the degree of exactness, $2n-1=11$. Consequently, the quadrature rule is no longer exact for this function, and we anticipate a non-zero, albeit small, approximation error.\n\n- **Case D**: $n=1$, $f(x)=e^x$. The analytic value is $e - e^{-1}$. For $n=1$, the degree of exactness is $2(1)-1=1$. The single node is the root of $P_1(x)=x$, which is $x_1=0$. The weight is $w_1 = \\int_{-1}^{1} 1 \\,dx = 2$. The approximation is simply $I_{approx} = w_1 f(x_1) = 2 \\cdot f(0) = 2 \\cdot e^0 = 2$. We expect a much larger error than in Case A, which used a more accurate $6$-point rule.\n\n- **Case E**: $n=6$, $f(x)=\\cos(50x)$. The analytic value is $\\int_{-1}^{1} \\cos(50x)\\,dx = \\frac{2\\sin(50)}{50}$. This integrand is highly oscillatory over the interval $[-1, 1]$. Gaussian quadrature's efficiency relies on the function being well-approximated by a low-degree polynomial. A function like $\\cos(50x)$ requires a very high-degree polynomial for a good approximation, so a $6$-point rule is insufficient to capture its behavior. We expect a large approximation error, illustrating a limitation of low-order quadrature for such functions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Implements Gauss-Legendre quadrature to approximate definite integrals\n    and calculates the absolute error for a suite of test cases.\n    \"\"\"\n\n    results = []\n\n    # Case A: n=6, f(x) = e^x\n    n_A = 6\n    f_A = np.exp\n    analytic_A = np.exp(1) - np.exp(-1)\n    nodes_A, weights_A = roots_legendre(n_A)\n    approx_A = np.sum(weights_A * f_A(nodes_A))\n    err_A = np.abs(approx_A - analytic_A)\n    results.extend([approx_A, err_A])\n\n    # Case B: n=6, f(x) = x^11 (degree is 2n-1, should be exact)\n    n_B = 6\n    f_B = lambda x: x**11\n    analytic_B = 0.0\n    nodes_B, weights_B = roots_legendre(n_B)\n    approx_B = np.sum(weights_B * f_B(nodes_B))\n    err_B = np.abs(approx_B - analytic_B)\n    results.append(err_B)\n\n    # Case C: n=6, f(x) = x^12 (degree is 2n, should not be exact)\n    n_C = 6\n    f_C = lambda x: x**12\n    analytic_C = 2.0 / 13.0\n    nodes_C, weights_C = roots_legendre(n_C)\n    approx_C = np.sum(weights_C * f_C(nodes_C))\n    err_C = np.abs(approx_C - analytic_C)\n    results.append(err_C)\n\n    # Case D: n=1, f(x) = e^x\n    n_D = 1\n    f_D = np.exp\n    analytic_D = np.exp(1) - np.exp(-1)\n    nodes_D, weights_D = roots_legendre(n_D)\n    approx_D = np.sum(weights_D * f_D(nodes_D))\n    err_D = np.abs(approx_D - analytic_D)\n    results.append(err_D)\n\n    # Case E: n=6, f(x) = cos(50x) (oscillatory function)\n    n_E = 6\n    f_E = lambda x: np.cos(50 * x)\n    analytic_E = 2.0 * np.sin(50) / 50.0\n    nodes_E, weights_E = roots_legendre(n_E)\n    approx_E = np.sum(weights_E * f_E(nodes_E))\n    err_E = np.abs(approx_E - analytic_E)\n    results.append(err_E)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having applied a pre-built quadrature rule, we now move from being a user to a developer by constructing the rule from first principles. This practice demystifies the origin of the \"magic\" nodes and weights by guiding you through the implementation of the celebrated Golub-Welsch algorithm, which connects Gaussian quadrature to the eigenvalue problem of a specific Jacobi matrix. Completing this exercise  will deepen your understanding of the profound link between orthogonal polynomials and numerical integration, and the rigorous validation steps will reinforce best practices in scientific computing.",
            "id": "4133076",
            "problem": "In computational acoustics, accurate numerical evaluation of integrals over angular or directional variables is essential for high-frequency wave modeling and boundary integral formulations. A central tool is Gaussian quadrature with Legendre weight, which approximates integrals on the interval $[-1,1]$ by a weighted sum at specially chosen nodes. This problem asks you to derive, implement, and validate a construction of Legendre–Gauss nodes and weights using the Golub–Welsch algorithm, starting from fundamental orthogonality and three-term recurrence properties of Legendre polynomials. You must not use any precomputed nodes or weights, nor specialized functions that directly return them.\n\nYour tasks are:\n\n1) Construct the $n \\times n$ symmetric tridiagonal Jacobi matrix associated with the Legendre weight $w(x) = 1$ on $[-1,1]$, using only the three-term recurrence for orthonormal polynomials as the fundamental basis. Obtain the Legendre–Gauss nodes by solving the eigenvalue problem for this Jacobi matrix, and obtain the weights from the first components of the corresponding normalized eigenvectors. Use $n = 10$.\n\n2) Derive an analytic expression for the Legendre–Gauss weights based on orthogonality of Legendre polynomials and properties of the derivative of the Legendre polynomial of degree $n$, and use it to compute a second set of weights at the nodes from part 1. Do not use any formula directly in the problem statement; implement your derivation in code.\n\n3) Validate the correctness and accuracy of your implementation by computing and reporting the following quantities:\n   - The maximum relative difference between the weights computed by the Golub–Welsch eigenvector formula and the analytic expression derived from Legendre polynomial properties. Report a single floating-point number.\n   - The absolute error in the sum of the weights compared to the exact integral of the weight function over $[-1,1]$, which is $2$. Report a single floating-point number.\n   - The maximum absolute quadrature error when integrating monomials $x^k$ for all integers $k$ from $0$ to $2n-1$ inclusive, comparing the quadrature sum to the exact integral $\\int_{-1}^{1} x^k \\, dx$, which equals $0$ for odd $k$ and $2/(k+1)$ for even $k$. Report a single floating-point number.\n\n4) To connect to a canonical oscillatory integral in acoustics, consider the integral\n$$\nI(\\alpha) = \\int_{-1}^{1} e^{i \\alpha x} \\, dx = \\frac{2 \\sin(\\alpha)}{\\alpha} \\quad \\text{for } \\alpha \\neq 0, \\quad I(0) = 2,\n$$\nwith $\\alpha$ in radians. Using the nodes and weights from part 1 with $n=10$, approximate $I(\\alpha)$ for a set of parameters $\\alpha \\in \\{0, 0.1, 1, 10, 50\\}$ (all in radians), and report a list of the absolute errors $|I_{\\text{quad}}(\\alpha) - I(\\alpha)|$ for these $\\alpha$ values, in the order given.\n\nImportant implementation and output requirements:\n\n- Use only the three-term recurrence structure for Legendre polynomials to build the Jacobi matrix and the eigenvalue problem to obtain nodes and weights. The problem forbids any use of shortcut routines that directly return Gaussian nodes or weights.\n- Angles must be interpreted in radians.\n- All outputs must be dimensionless real numbers.\n- Test suite: use $n=10$ and $\\alpha \\in \\{0, 0.1, 1, 10, 50\\}$.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be of the form\n$\n[\\text{max\\_relative\\_weight\\_difference}, \\text{weight\\_sum\\_error}, \\text{max\\_moment\\_error}, [e_{\\alpha=0}, e_{\\alpha=0.1}, e_{\\alpha=1}, e_{\\alpha=10}, e_{\\alpha=50}]]\n$\nwhere each element is a floating-point number. For example, an output could look like\n$\n[1e-15,0.0,2.22e-16,[0.0,1e-15,1e-12,1e-6,1e-4]].\n$ \nYour program must print exactly one line in this format and must not read any input.",
            "solution": "The problem requires the construction, implementation, and validation of the Legendre–Gauss quadrature rule for $n=10$ points using the Golub–Welsch algorithm. This algorithm establishes a profound connection between Gaussian quadrature and the spectral theory of symmetric tridiagonal matrices, known as Jacobi matrices. We will proceed by first constructing the Jacobi matrix from the three-term recurrence of orthonormal Legendre polynomials. Then, we will solve the corresponding eigenvalue problem to find the quadrature nodes and weights. These results will be validated against an analytic formula for the weights and by testing the quadrature's exactness for polynomials. Finally, we will apply the quadrature rule to a representative oscillatory integral found in acoustics.\n\n**Step 1: Construction of the Jacobi Matrix (Golub–Welsch Algorithm)**\n\nGaussian quadrature approximates an integral of the form $\\int_a^b f(x) w(x) \\, dx$ by a weighted sum $\\sum_{j=1}^{n} w_j f(x_j)$. The nodes $\\{x_j\\}$ and weights $\\{w_j\\}$ are chosen to make this approximation exact for all polynomials of degree up to $2n-1$. For a family of polynomials $\\{\\phi_k(x)\\}$ that are orthonormal with respect to the weight function $w(x)$ on $[a, b]$, they satisfy a three-term recurrence relation:\n$$\nx \\phi_k(x) = \\beta_k \\phi_{k-1}(x) + \\alpha_k \\phi_k(x) + \\beta_{k+1} \\phi_{k+1}(x)\n$$\nThese coefficients, $\\alpha_k$ and $\\beta_k$, form an $n \\times n$ symmetric tridiagonal matrix, the Jacobi matrix $J_n$:\n$$\nJ_n = \\begin{pmatrix}\n\\alpha_0 & \\beta_1 & 0 & \\cdots & 0 \\\\\n\\beta_1 & \\alpha_1 & \\beta_2 & \\ddots & \\vdots \\\\\n0 & \\beta_2 & \\alpha_2 & \\ddots & 0 \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & \\beta_{n-1} \\\\\n0 & \\cdots & 0 & \\beta_{n-1} & \\alpha_{n-1}\n\\end{pmatrix}\n$$\nThe Golub–Welsch algorithm states that the $n$ quadrature nodes $\\{x_j\\}$ are the eigenvalues of this matrix $J_n$. The corresponding weights $\\{w_j\\}$ are derived from the first components of the normalized eigenvectors. Specifically, if $v_j$ is the normalized eigenvector for the eigenvalue $x_j$, then the weight is $w_j = \\mu_0 (v_{j,0})^2$, where $v_{j,0}$ is the first component of $v_j$ and $\\mu_0 = \\int_a^b w(x) \\, dx$.\n\nFor this problem, we use the Legendre weight function $w(x) = 1$ on the interval $[-1, 1]$.\nThe integral of the weight function is $\\mu_0 = \\int_{-1}^1 1 \\, dx = 2$.\nThe standard Legendre polynomials, $P_k(x)$, are orthogonal but not orthonormal. The orthonormal polynomials are $\\phi_k(x) = \\sqrt{\\frac{2k+1}{2}} P_k(x)$.\nThe recurrence coefficients are given by $\\alpha_k = \\int_{-1}^1 x (\\phi_k(x))^2 \\, dx$ and $\\beta_k = \\int_{-1}^1 x \\phi_k(x) \\phi_{k-1}(x) \\, dx$.\nDue to the symmetry of the interval $[-1, 1]$ and the weight function $w(x)=1$, the integrand for $\\alpha_k$ is odd, so $\\alpha_k = 0$ for all $k$.\nThe off-diagonal terms $\\beta_k$ can be derived from the standard recurrence for $P_k(x)$:\n$$\n(k+1)P_{k+1}(x) = (2k+1)xP_k(x) - kP_{k-1}(x)\n$$\nRearranging for $x P_k(x)$ and substituting the relation for $\\phi_k(x)$, we find the recurrence for the orthonormal polynomials, which yields the coefficient:\n$$\n\\beta_k = \\frac{k}{\\sqrt{(2k-1)(2k+1)}} = \\frac{k}{\\sqrt{4k^2 - 1}} \\quad \\text{for } k=1, \\dots, n-1\n$$\nFor $n=10$, we construct a $10 \\times 10$ matrix $J_{10}$ with zeros on the diagonal and the values of $\\beta_k$ for $k=1, \\dots, 9$ on the super- and sub-diagonals. Solving the eigenvalue problem $J_{10} V = V \\Lambda$, where $\\Lambda$ is the diagonal matrix of eigenvalues (nodes) and $V$ is the matrix of eigenvectors, provides the nodes and weights.\n\n**Step 2: Analytic Formula for Weights**\n\nFor validation, we compute the weights using an alternative method. The weights for Legendre-Gauss quadrature are given by the formula:\n$$\nw_j = \\frac{2}{(1 - x_j^2) [P_n'(x_j)]^2}\n$$\nwhere $P_n'(x_j)$ is the derivative of the $n$-th degree Legendre polynomial evaluated at the node $x_j$. To implement this, we require an expression for $P_n'(x_j)$. Legendre polynomials satisfy the differential relation:\n$$\n(1 - x^2)P_n'(x) = nP_{n-1}(x) - nxP_n(x)\n$$\nAt the nodes $x_j$, which are the roots of $P_n(x)$, we have $P_n(x_j) = 0$. The relation simplifies to:\n$$\n(1 - x_j^2)P_n'(x_j) = nP_{n-1}(x_j)\n$$\nSubstituting this into the weight formula yields a more stable expression that avoids direct computation of the derivative and potential division by zero if $1 - x_j^2$ is small:\n$$\nw_j = \\frac{2(1 - x_j^2)}{n^2 [P_{n-1}(x_j)]^2}\n$$\nTo use this formula, we first find the nodes $x_j$ via the Golub-Welsch method, and then evaluate $P_{n-1}(x)$ at these nodes. The polynomial $P_{n-1}(x_j)$ is computed using its standard three-term recurrence relation, implemented from first principles.\n\n**Step 3: Validation Protocol**\n\nWe perform three quantitative checks to validate our implementation:\n1.  **Maximum Relative Weight Difference**: We compute the weights using both the Golub-Welsch method ($w_j^{\\text{GW}}$) and the analytic formula ($w_j^{\\text{analytic}}$). The maximum relative difference, $\\max_j \\left| \\frac{w_j^{\\text{GW}} - w_j^{\\text{analytic}}}{w_j^{\\text{analytic}}} \\right|$, is calculated. This should be on the order of machine precision.\n2.  **Weight Sum Error**: The sum of the weights must equal the integral of the weight function, $\\sum_{j=1}^n w_j = \\int_{-1}^1 1 \\, dx = 2$. We report the absolute error $|\\sum_{j=1}^n w_j - 2|$.\n3.  **Maximum Moment Error**: An $n$-point Gaussian quadrature rule is exact for all polynomials up to degree $2n-1$. We test this by integrating the monomials $x^k$ for $k=0, 1, \\dots, 2n-1$. The exact integral is $I_k = \\int_{-1}^1 x^k \\, dx$, which is $2/(k+1)$ for even $k$ and $0$ for odd $k$. We compute the maximum absolute error $| \\sum_{j=1}^n w_j x_j^k - I_k |$ over this range of $k$.\n\n**Step 4: Application to an Oscillatory Integral**\n\nWe apply the developed $n=10$ quadrature rule to approximate the oscillatory integral:\n$$\nI(\\alpha) = \\int_{-1}^{1} e^{i \\alpha x} \\, dx\n$$\nThe exact solution is $I(\\alpha) = \\frac{2\\sin(\\alpha)}{\\alpha}$ for $\\alpha \\neq 0$ and $I(0) = 2$. The numerical approximation is given by $I_{\\text{quad}}(\\alpha) = \\sum_{j=1}^{10} w_j e^{i \\alpha x_j}$. We compute the absolute error $|I_{\\text{quad}}(\\alpha) - I(\\alpha)|$ for $\\alpha \\in \\{0, 0.1, 1, 10, 50\\}$. This test demonstrates the performance of the quadrature for a non-polynomial, oscillatory function characteristic of wave phenomena in acoustics. As the frequency parameter $\\alpha$ increases, the integrand oscillates more rapidly, and the approximation error is expected to grow for a fixed number of quadrature points.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef legendre_poly_eval(k, x):\n    \"\"\"\n    Evaluates the Legendre polynomial P_k(x) at point(s) x using the\n    three-term recurrence relation.\n    \"\"\"\n    x = np.asarray(x)\n    if k == 0:\n        return np.ones_like(x)\n    if k == 1:\n        return x\n    \n    p_k_minus_2 = np.ones_like(x)\n    p_k_minus_1 = x\n    for i in range(2, k + 1):\n        p_k = ((2 * i - 1) * x * p_k_minus_1 - (i - 1) * p_k_minus_2) / i\n        p_k_minus_2 = p_k_minus_1\n        p_k_minus_1 = p_k\n    return p_k_minus_1\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates Legendre-Gauss quadrature.\n    \"\"\"\n    n = 10\n    alpha_values = [0.0, 0.1, 1.0, 10.0, 50.0]\n\n    # --- Part 1: Golub-Welsch Algorithm ---\n    # Construct the n x n symmetric tridiagonal Jacobi matrix.\n    # Diagonal elements (alpha_k) are 0.\n    # Off-diagonal elements (beta_k) are k / sqrt(4k^2 - 1).\n    J = np.zeros((n, n))\n    for k in range(1, n):\n        beta_k = k / np.sqrt(4 * k**2 - 1)\n        J[k, k-1] = beta_k\n        J[k-1, k] = beta_k\n        \n    # Solve the eigenvalue problem for the Jacobi matrix.\n    # Eigenvalues are the nodes, eigenvectors are used for weights.\n    # np.linalg.eigh is used for symmetric matrices and returns sorted eigenvalues.\n    nodes, eigenvectors = np.linalg.eigh(J)\n    \n    # Calculate weights from the first component of the normalized eigenvectors.\n    # w_j = mu_0 * (v_{j,0})^2, where mu_0 = integral of w(x)=1 from -1 to 1, which is 2.\n    # eigenvectors are stored as columns. eigenvectors[0,:] gives the first row.\n    weights_gw = 2.0 * (eigenvectors[0, :])**2\n    \n    # The nodes from eigh are already sorted, and weights correspond to them.\n    # No extra sorting is needed.\n\n    # --- Part 2: Analytic Weight Formula ---\n    # Compute weights for validation using the formula:\n    # w_j = 2*(1-x_j^2) / (n^2 * [P_{n-1}(x_j)]^2)\n    p_n_minus_1_at_nodes = legendre_poly_eval(n - 1, nodes)\n    weights_analytic = (2.0 * (1 - nodes**2)) / (n**2 * p_n_minus_1_at_nodes**2)\n    \n    # --- Part 3: Validation ---\n    # 3a: Maximum relative difference between Golub-Welsch and analytic weights.\n    # The denominator is non-zero for Legendre-Gauss weights.\n    rel_diffs = np.abs(weights_gw - weights_analytic) / np.abs(weights_analytic)\n    max_relative_weight_difference = np.max(rel_diffs)\n    \n    # 3b: Absolute error in the sum of weights (should sum to 2).\n    # Using the Golub-Welsch weights for all subsequent calculations as per problem statement.\n    weight_sum_error = np.abs(np.sum(weights_gw) - 2.0)\n    \n    # 3c: Maximum absolute quadrature error for monomials x^k up to degree 2n-1.\n    # The quadrature should be exact, so error should be near machine precision.\n    max_moment_error = 0.0\n    for k in range(2 * n):\n        # Exact integral of x^k from -1 to 1\n        exact_integral = 2.0 / (k + 1) if k % 2 == 0 else 0.0\n        \n        # Quadrature approximation\n        quadrature_sum = np.sum(weights_gw * (nodes**k))\n        \n        error = np.abs(quadrature_sum - exact_integral)\n        if error > max_moment_error:\n            max_moment_error = error\n\n    # --- Part 4: Application to Oscillatory Integral ---\n    # Approximate I(alpha) = integral from -1 to 1 of exp(i*alpha*x) dx.\n    acoustic_errors = []\n    for alpha in alpha_values:\n        # Exact integral: 2*sin(alpha)/alpha for alpha!=0, 2 for alpha=0.\n        if alpha == 0.0:\n            exact_val = 2.0\n        else:\n            exact_val = 2.0 * np.sin(alpha) / alpha\n            \n        # Quadrature approximation. np.exp handles complex numbers.\n        quad_val = np.sum(weights_gw * np.exp(1j * alpha * nodes))\n        \n        # Absolute error |I_quad - I_exact|\n        error = np.abs(quad_val - exact_val)\n        acoustic_errors.append(error)\n        \n    # --- Final Output Formatting ---\n    # The problem requires a specific format: [num, num, num, [num, num, ...]]\n    # This involves manually formatting the inner list.\n    acoustic_errors_str = f\"[{','.join(map(str, acoustic_errors))}]\"\n    \n    results = [\n        max_relative_weight_difference,\n        weight_sum_error,\n        max_moment_error,\n        acoustic_errors_str\n    ]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "We conclude with an advanced application that addresses a central problem in computational wave physics: the efficient evaluation of oscillatory integrals. This exercise sets up a direct comparison between the general-purpose Gauss-Legendre quadrature and a specialized Filon-type method designed explicitly for oscillatory integrands. By analyzing the performance and convergence of both methods as the oscillation frequency increases, you will gain critical insight into the trade-offs between general and specialized numerical tools, a key consideration for developing efficient and accurate acoustic models .",
            "id": "4133001",
            "problem": "Consider the canonical oscillatory integral from computational acoustics for a one-dimensional, constant-amplitude plane wave over a symmetric aperture, defined by the real-valued integral\n$$\nI(k) = \\int_{-1}^{1} \\cos(k x)\\,dx,\n$$\nwhere $k$ is a nonnegative angular wavenumber and all angles are measured in radians. In numerical propagation and radiation models, accuracy depends on the ability of a quadrature rule to resolve oscillations as $k$ increases. You will investigate the error as a function of the number of nodes or subintervals and compare a Gaussian quadrature (Gauss–Legendre rule) to a Filon-type rule tailored to oscillatory integrals.\n\nStarting from foundational principles of calculus and orthogonal polynomials—specifically, the Fundamental Theorem of Calculus, properties of trigonometric functions, and the exactness of Gauss–Legendre quadrature for polynomials up to degree $2n-1$—derive and implement the following:\n\n1. A Gauss–Legendre quadrature approximation to $I(k)$ with $n$ nodes over $[-1,1]$.\n2. A Filon-type composite rule over $[-1,1]$ that approximates the oscillatory factor by integrating it exactly on each subinterval while treating the amplitude as piecewise constant (equal to the midpoint amplitude). For this problem, the physical amplitude is exactly constant and equal to $1$, and angles are in radians.\n\nCompute, for each prescribed $k$, the absolute error $E_{\\mathrm{GL}}(k,n)$ of the Gauss–Legendre approximation and the absolute error $E_{\\mathrm{F}}(k,m)$ of the Filon-type approximation, where $n$ is the number of Gauss–Legendre nodes and $m$ is the number of uniform subintervals in the Filon-type composite rule. Use only mathematically valid operations; do not assume any shortcut formulas beyond the foundational principles.\n\nYour program must:\n- For each $k$ in the test suite, evaluate $E_{\\mathrm{GL}}(k,n)$ for $n \\in \\{1,2,4,8,16,32,64,128\\}$ and $E_{\\mathrm{F}}(k,m)$ for $m \\in \\{1,2,4,8,16,32,64,128\\}$.\n- Use an absolute error tolerance of $10^{-12}$ to determine the smallest $n$ (denoted $n^\\star_{\\mathrm{GL}}(k)$) such that $E_{\\mathrm{GL}}(k,n) \\le 10^{-12}$, and similarly the smallest $m$ (denoted $m^\\star_{\\mathrm{F}}(k)$) such that $E_{\\mathrm{F}}(k,m) \\le 10^{-12}$. If no value in the specified sets satisfies the tolerance, report $-1$ for that quantity.\n- Report, for each $k$, the maximum absolute error across the tested $n$ for Gauss–Legendre, $\\max_{n} E_{\\mathrm{GL}}(k,n)$, and the maximum absolute error across the tested $m$ for Filon-type, $\\max_{m} E_{\\mathrm{F}}(k,m)$.\n\nTest suite (angles in radians):\n- $k = 0$,\n- $k = \\pi$,\n- $k = 50$,\n- $k = 200$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain one entry per $k$ in the test suite, in the same order as listed above.\n- For each $k$, output the list $[n^\\star_{\\mathrm{GL}}(k), m^\\star_{\\mathrm{F}}(k), \\max_{n} E_{\\mathrm{GL}}(k,n), \\max_{m} E_{\\mathrm{F}}(k,m)]$.\n- All numerical values must be reported as plain decimals (floats) or integers. No units are required because all quantities are dimensionless and angles are in radians.\n- Example of the required output structure (with placeholders): $[[n_1,m_1,e_{1,\\max}^{\\mathrm{GL}},e_{1,\\max}^{\\mathrm{F}}],[n_2,m_2,e_{2,\\max}^{\\mathrm{GL}},e_{2,\\max}^{\\mathrm{F}}],\\dots]$.\n\nYour implementation must be a complete, runnable program, and must not require any external input.",
            "solution": "The problem requires a comparative analysis of two numerical quadrature methods—Gauss–Legendre and a zeroth-order Filon-type rule—for the canonical oscillatory integral $I(k) = \\int_{-1}^{1} \\cos(k x)\\,dx$. The analysis involves implementing both methods, calculating their absolute error against the exact analytical solution for various wavenumbers $k$, and determining the computational effort (number of nodes or subintervals) required to achieve a specified accuracy.\n\n### 1. Analytical Solution\n\nThe first step is to find the exact value of the integral, which serves as the ground truth for error calculations. We use the Fundamental Theorem of Calculus.\n\nFor a non-zero angular wavenumber $k > 0$:\n$$\nI(k) = \\int_{-1}^{1} \\cos(k x)\\,dx = \\left[ \\frac{\\sin(k x)}{k} \\right]_{-1}^{1} = \\frac{\\sin(k \\cdot 1)}{k} - \\frac{\\sin(k \\cdot (-1))}{k}\n$$\nUsing the property that $\\sin(-x) = -\\sin(x)$, this simplifies to:\n$$\nI(k) = \\frac{\\sin(k) - (-\\sin(k))}{k} = \\frac{2\\sin(k)}{k}\n$$\n\nFor the special case where the wavenumber $k=0$:\n$$\nI(0) = \\int_{-1}^{1} \\cos(0 \\cdot x)\\,dx = \\int_{-1}^{1} 1\\,dx = [x]_{-1}^{1} = 1 - (-1) = 2\n$$\nIt is worth noting that the solution for $k>0$ is continuous at $k=0$, as $\\lim_{k \\to 0} \\frac{2\\sin(k)}{k} = 2$, which matches $I(0)$.\n\n### 2. Method 1: Gauss–Legendre Quadrature\n\nGauss–Legendre quadrature is a powerful method for approximating integrals over the interval $[-1, 1]$. Its general form is:\n$$\n\\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\nHere, $n$ is the number of nodes. The nodes $x_i$ are the roots of the $n$-th degree Legendre polynomial, $P_n(x)$, and the weights $w_i$ are derived from the theory of orthogonal polynomials. A key property of this rule is that it is exact for any polynomial of degree up to $2n-1$.\n\nFor our specific integral, the integrand is $f(x) = \\cos(kx)$. The Gauss–Legendre approximation, $I_{\\mathrm{GL}}(k,n)$, is:\n$$\nI_{\\mathrm{GL}}(k,n) = \\sum_{i=1}^{n} w_i \\cos(k x_i)\n$$\nFor $k=0$, the integrand is $f(x) = \\cos(0) = 1$, which is a polynomial of degree $0$. The $n=1$ Gauss-Legendre rule is exact for polynomials of degree up to $2(1)-1=1$, so it will integrate $f(x)=1$ exactly. For $n \\ge 1$, the approximation will be exact.\n\nFor $k > 0$, $\\cos(kx)$ is not a polynomial. The accuracy of the approximation depends on how well the integrand can be represented by a polynomial of degree $2n-1$. As $k$ increases, the function oscillates more rapidly, requiring a higher-degree polynomial (and thus a larger $n$) to achieve a given accuracy. The absolute error is calculated as $E_{\\mathrm{GL}}(k,n) = |I(k) - I_{\\mathrm{GL}}(k,n)|$.\n\nThe nodes and weights will be computed numerically using routines from the `scipy` library, which is standard practice.\n\n### 3. Method 2: Filon-type Composite Rule\n\nFilon-type methods are specifically designed for oscillatory integrals of the form $\\int_{a}^{b} g(x) \\Omega(kx) dx$, where $g(x)$ is a slowly varying amplitude and $\\Omega(kx)$ is a rapidly oscillating function (e.g., $\\cos(kx)$ or $\\sin(kx)$). The core idea is to approximate $g(x)$ by a simpler function (like a low-degree polynomial) on subintervals and then integrate the resulting product $p(x)\\Omega(kx)$ exactly.\n\nThe problem specifies a zeroth-order composite rule:\n1. Divide the interval $[-1, 1]$ into $m$ uniform subintervals, $[x_j, x_{j+1}]$, each of length $h = \\frac{2}{m}$, where $x_j = -1 + jh$.\n2. On each subinterval, approximate the amplitude function $g(x)$—which in our case is $g(x)=1$—by a constant equal to its value at the subinterval's midpoint.\n3. Integrate the resulting approximation exactly over each subinterval.\n\nFor the integral $I(k) = \\int_{-1}^{1} 1 \\cdot \\cos(kx) dx$, the amplitude is $g(x) = 1$. Approximating this constant function by its midpoint value results in the constant $1$ itself. Therefore, on each subinterval $[x_j, x_{j+1}]$, the approximation to the integral is:\n$$\n\\int_{x_j}^{x_{j+1}} (\\text{midpoint value of } g(x)) \\cdot \\cos(kx)\\,dx = \\int_{x_j}^{x_{j+1}} 1 \\cdot \\cos(kx)\\,dx\n$$\nThe Filon-type approximation $I_{\\mathrm{F}}(k,m)$ is the sum of these integrals over all $m$ subintervals:\n$$\nI_{\\mathrm{F}}(k,m) = \\sum_{j=0}^{m-1} \\int_{x_j}^{x_{j+1}} \\cos(kx)\\,dx\n$$\nBy the additivity property of definite integrals, this sum telescopes to the original integral over the full domain:\n$$\nI_{\\mathrm{F}}(k,m) = \\int_{x_0}^{x_m} \\cos(kx)\\,dx = \\int_{-1}^{1} \\cos(kx)\\,dx = I(k)\n$$\nThis demonstrates a crucial result: for this specific problem where the amplitude function is exactly constant, the prescribed Filon-type rule is **analytically exact** for any number of subintervals $m \\ge 1$ and for all values of $k$. Consequently, the absolute error $E_{\\mathrm{F}}(k,m) = |I(k) - I_{\\mathrm{F}}(k,m)|$ will be zero, or a very small number limited only by floating-point precision. This means that for any $k$, the smallest number of subintervals to reach the tolerance is $m^\\star_{\\mathrm{F}}(k) = 1$, and the maximum error across all tested $m$ will be approximately $0$.\n\n### 4. Computational Procedure\n\nThe program will execute the following steps for each $k$ in the test suite $\\{0, \\pi, 50, 200\\}$:\n\n1.  **Compute Exact Value**: Calculate $I(k)$ using the analytical formulas derived above, with special handling for $k=0$.\n2.  **Evaluate Gauss–Legendre Error**:\n    *   Initialize $n^\\star_{\\mathrm{GL}} = -1$ and $\\max_{n} E_{\\mathrm{GL}} = 0$.\n    *   Iterate through $n \\in \\{1, 2, 4, 8, 16, 32, 64, 128\\}$.\n    *   For each $n$, fetch the Gauss-Legendre nodes $x_i$ and weights $w_i$.\n    *   Compute the approximation $I_{\\mathrm{GL}}(k,n) = \\sum_{i=1}^{n} w_i \\cos(k x_i)$.\n    *   Calculate the absolute error $E_{\\mathrm{GL}}(k,n) = |I(k) - I_{\\mathrm{GL}}(k,n)|$.\n    *   Update $\\max_{n} E_{\\mathrm{GL}}$ with the current error if it is larger.\n    *   If $E_{\\mathrm{GL}}(k,n) \\le 10^{-12}$ and $n^\\star_{\\mathrm{GL}}$ has not yet been set, assign $n^\\star_{\\mathrm{GL}} = n$.\n3.  **Evaluate Filon-type Error**:\n    *   Based on our analytical finding, $I_{\\mathrm{F}}(k,m)$ is identical to $I(k)$.\n    *   Therefore, $m^\\star_{\\mathrm{F}}(k) = 1$ (the first value in the set of $m$).\n    *   The error $E_{\\mathrm{F}}(k,m)$ is effectively $0$ for all $m$. The maximum error $\\max_{m} E_{\\mathrm{F}}$ is also $0$.\n4.  **Collate and Report**: Store the computed tuple $[n^\\star_{\\mathrm{GL}}, m^\\star_{\\mathrm{F}}, \\max_{n} E_{\\mathrm{GL}}, \\max_{m} E_{\\mathrm{F}}]$ for the current $k$ and proceed to the next value in the test suite. Finally, format the collected results as a single line of text.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes and compares the error of Gauss-Legendre and Filon-type\n    quadrature for a canonical oscillatory integral from computational acoustics.\n    \"\"\"\n    \n    # Define the problem parameters\n    test_suite_k = [0.0, np.pi, 50.0, 200.0]\n    n_values = [1, 2, 4, 8, 16, 32, 64, 128]\n    m_values = [1, 2, 4, 8, 16, 32, 64, 128]\n    tolerance = 1e-12\n\n    def exact_integral(k):\n        \"\"\"Computes the exact value of the integral I(k) = int_{-1}^{1} cos(kx) dx.\"\"\"\n        if k == 0.0:\n            return 2.0\n        else:\n            return 2.0 * np.sin(k) / k\n\n    def gauss_legendre_approx(k, n):\n        \"\"\"Computes the Gauss-Legendre quadrature approximation for I(k) with n nodes.\"\"\"\n        nodes, weights = roots_legendre(n)\n        integrand_values = np.cos(k * nodes)\n        return np.sum(weights * integrand_values)\n\n    def filon_type_approx(k, m):\n        \"\"\"\n        Computes the Filon-type quadrature approximation.\n        As derived in the solution, for f(x)=1, this method is analytically exact\n        for any m >= 1, and thus returns the exact integral value.\n        \"\"\"\n        return exact_integral(k)\n\n    all_results = []\n    for k in test_suite_k:\n        # Calculate the exact value for the current k\n        i_exact = exact_integral(k)\n\n        # --- Gauss-Legendre Analysis ---\n        n_star_gl = -1\n        max_err_gl = 0.0\n        for n in n_values:\n            i_gl = gauss_legendre_approx(k, n)\n            err_gl = np.abs(i_exact - i_gl)\n            \n            if err_gl > max_err_gl:\n                max_err_gl = err_gl\n            \n            if err_gl = tolerance and n_star_gl == -1:\n                n_star_gl = n\n\n        # --- Filon-type Analysis ---\n        m_star_f = -1\n        max_err_f = 0.0\n        for m in m_values:\n            # As derived, the Filon-type approximation for a constant amplitude of 1\n            # is identical to the exact integral. The error is thus 0 up to machine precision.\n            i_f = filon_type_approx(k, m)\n            err_f = np.abs(i_exact - i_f)\n\n            if err_f > max_err_f:\n                max_err_f = err_f\n\n            if err_f = tolerance and m_star_f == -1:\n                m_star_f = m\n        \n        # In the specific case for Filon method, m_star_f will always be the first\n        # element, 1, and max_err_f will be ~0 due to exactness.\n        # This explicit check handles the case where m_values might not start at 1.\n        if m_star_f == -1 and m_values:\n             # Fallback if no m met the tolerance, which shouldn't happen here.\n             pass\n\n        # Collect results for this k\n        all_results.append([n_star_gl, m_star_f, max_err_gl, max_err_f])\n\n    # Format the final output string exactly as required\n    # e.g., [[1, 1, 0.0, 0.0], [8, 1, 0.5103, 0.0], ...]\n    result_str = \"[\" + \",\".join([f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\" for res in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}