{
    "hands_on_practices": [
        {
            "introduction": "在数值分析中，我们经常使用一个简单的标量检验方程 $y' = \\lambda y$ 来研究时间积分格式的稳定性。这个看似简单的方程抓住了许多复杂系统中线性化后动态行为的本质。通过对这个模型应用前向欧拉法这一最基础的显式格式，我们可以推导出其稳定性的严格约束条件，从而深刻理解为何显式方法在处理“刚性”问题时会面临严重的时间步长限制。",
            "id": "4024140",
            "problem": "在一个代表计算燃烧学中单步衰变过程的均匀、等温、充分混合的反应系统中，标量状态变量 $y(t)$（例如，自由基物质质量分数的一个小扰动）的时间演化在局部由线性常微分方程（ODE）$y'(t) = \\lambda\\, y(t)$ 控制，其中 $\\lambda \\in \\mathbb{R}$ 且 $\\lambda  0$ 代表一个具有特征衰减时间尺度的化学汇。考虑使用显式前向欧拉（FE）方法对该常微分方程进行时间推进。从应用于线性测试方程的单步方法的绝对稳定性定义出发，并根据显式前向欧拉法产生的离散更新，推导当 $\\lambda$ 为实数且为负时，保证扰动幅度不增长的时间步长 $\\Delta t$ 的条件。然后，对于 $\\lambda = -10^{6}~\\mathrm{s}^{-1}$ 的特定情况，计算满足所推导的稳定性条件的最大 $\\Delta t$。最终答案以秒为单位表示，并四舍五入到 $3$ 位有效数字。最终答案必须是一个实数。",
            "solution": "在尝试解答之前，对问题进行验证。\n\n### 第 1 步：提取已知条件\n- 控制性常微分方程（ODE）为 $y'(t) = \\lambda\\, y(t)$。\n- 参数 $\\lambda$ 是一个实数，且 $\\lambda  0$。\n- 数值积分方案是显式前向欧拉（FE）方法。\n- 稳定性的条件是扰动幅度不增长，这意味着 $|y_{n+1}| \\leq |y_n|$。\n- 给定一个特定情况 $\\lambda = -10^{6}~\\mathrm{s}^{-1}$。\n- 任务是推导时间步长 $\\Delta t$ 的稳定性条件，然后计算给定 $\\lambda$ 下的最大 $\\Delta t$，并四舍五入到 $3$ 位有效数字。\n\n### 第 2 步：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题基于标准的线性测试方程 $y' = \\lambda y$，这是常微分方程数值方法稳定性分析的基石。显式前向欧拉法是一种基本的数值方案。A-稳定性（或在本例中，其在实数轴上的一个子集）的概念是数值分析领域的核心，特别是对于计算燃烧学中遇到的刚性方程。该问题在科学上是合理的。\n2.  **适定性：** 该问题是适定的。它要求对稳定性界限进行标准推导并进行后续计算。推导过程会得出一个唯一的不等式，计算会得出一个唯一的、明确定义的数值答案。\n3.  **客观性：** 该问题使用数学和计算科学中精确、客观和标准的术语进行陈述。\n4.  **完整性和一致性：** 该问题提供了所有必要信息：控制方程、数值方法、参数 $\\lambda$ 的约束条件以及稳定性准则。没有矛盾之处。\n5.  **合理性：** $\\lambda = -10^{6}~\\mathrm{s}^{-1}$ 的值代表了 $10^{-6}~\\mathrm{s}$ 或 $1~\\mu\\mathrm{s}$ 的特征时间尺度，这对于燃烧过程中的快速化学反应（例如，自由基动力学）在物理上是现实的。\n\n### 第 3 步：结论与行动\n该问题被认为是**有效的**，因为它具有科学依据、适定且完整。将提供完整的解答。\n\n### 解答推导\n该问题涉及由线性常微分方程控制的标量 $y(t)$ 的时间演化：\n$$\ny'(t) = \\frac{dy}{dt} = \\lambda y(t)\n$$\n其中 $\\lambda$ 是一个实数负常数（$\\lambda  0$）。我们希望使用显式前向欧拉（FE）方法对该方程进行数值求解。\n\n设 $y_n$ 是解 $y(t)$ 在离散时间 $t_n = n \\Delta t$ 处的数值近似，其中 $\\Delta t$ 是时间步长。FE 方法使用前向有限差分来近似导数 $y'(t_n)$：\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} \\approx y'(t_n)\n$$\n将此代入在 $t_n$ 处取值的控制性常微分方程，我们得到：\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = \\lambda y_n\n$$\n重新整理该方程以求解 $y_{n+1}$，得到前向欧拉方法的离散更新规则：\n$$\ny_{n+1} = y_n + \\Delta t (\\lambda y_n)\n$$\n$$\ny_{n+1} = (1 + \\lambda \\Delta t) y_n\n$$\n该方程将下一个时间步的解 $y_{n+1}$ 与当前时间步的解 $y_n$ 联系起来。项 $G = 1 + \\lambda \\Delta t$ 被称为放大因子，因为它决定了解的幅度如何从一步到下一步被放大（或衰减）。\n\n问题要求扰动幅度不增长。这转化为绝对稳定性条件，即数值解的幅度不能随时间增加。对于单步法，这意味着：\n$$\n|y_{n+1}| \\le |y_n|\n$$\n将更新规则代入此不等式，我们有：\n$$\n|(1 + \\lambda \\Delta t) y_n| \\le |y_n|\n$$\n假设 $y_n \\neq 0$，我们可以除以 $|y_n|$ 以获得关于放大因子 $G$ 的条件：\n$$\n|G| \\le 1 \\quad \\implies \\quad |1 + \\lambda \\Delta t| \\le 1\n$$\n这个绝对值不等式等价于以下一对不等式：\n$$\n-1 \\le 1 + \\lambda \\Delta t \\le 1\n$$\n为了找到关于 $\\Delta t$ 的条件，我们首先从不等式的所有部分减去 $1$：\n$$\n-2 \\le \\lambda \\Delta t \\le 0\n$$\n给定 $\\lambda  0$。时间步长 $\\Delta t$ 必须为正，所以 $\\Delta t > 0$。因此，乘积 $\\lambda \\Delta t$ 总是负的。这意味着不等式的右侧，即 $\\lambda \\Delta t \\le 0$，是自动满足的。\n\n因此，该方法的稳定性仅受不等式左侧的约束：\n$$\n-2 \\le \\lambda \\Delta t\n$$\n为了分离出 $\\Delta t$，我们除以 $\\lambda$。由于 $\\lambda$ 是负数，此操作会反转不等号的方向：\n$$\n\\frac{-2}{\\lambda} \\ge \\Delta t\n$$\n这可以更常规地写成：\n$$\n\\Delta t \\le -\\frac{2}{\\lambda}\n$$\n这就是对于应用于给定常微分方程（其中 $\\lambda$ 为实数且为负）的前向欧拉方法，保证稳定性的时间步长 $\\Delta t$ 的推导条件。\n\n现在，我们将此结果应用于 $\\lambda = -10^{6}~\\mathrm{s}^{-1}$ 的特定情况。满足稳定性条件的最大时间步长 $\\Delta t_{\\text{max}}$ 由等式给出：\n$$\n\\Delta t_{\\text{max}} = -\\frac{2}{\\lambda}\n$$\n代入给定的 $\\lambda$ 值：\n$$\n\\Delta t_{\\text{max}} = -\\frac{2}{-10^{6}~\\mathrm{s}^{-1}} = \\frac{2}{10^{6}}~\\mathrm{s} = 2 \\times 10^{-6}~\\mathrm{s}\n$$\n问题要求答案四舍五入到 $3$ 位有效数字。用科学记数法表示，即为 $2.00 \\times 10^{-6}$。",
            "answer": "$$\\boxed{2.00 \\times 10^{-6}}$$"
        },
        {
            "introduction": "对于计算声学等波动问题，数值解的精度与稳定性同等重要，甚至更为关键。即使像 Crank-Nicolson 这样的隐式格式具有无条件稳定性的优良特性，如果时间步长取得过大，也会导致严重的相位误差，即数值色散，从而无法准确模拟波的传播。 这项练习将指导你量化这种相位误差，并推导出为了保证波形不失真，每个波周期所需的最少时间步数，这是从理论走向工程实践的关键一步。",
            "id": "4122879",
            "problem": "考虑一维均匀介质中的线性声波方程，\n$$\n\\frac{\\partial^{2} p}{\\partial t^{2}} = c^{2} \\frac{\\partial^{2} p}{\\partial x^{2}},\n$$\n其中 $p$ 是声压，$c$ 是声速。在波数为 $k \\in \\mathbb{R}$ 的空间傅里叶变换下，每个傅里叶模式独立演化，并满足一个具有纯虚谱的线性常微分方程。等价地，对于任意固定的 $k$，复模态振幅 $y(t)$ 满足一阶线性常微分方程\n$$\n\\frac{d y}{d t} = i \\, \\omega \\, y, \\quad \\omega = c\\,|k|.\n$$\n你需要使用时间步长均匀（$\\Delta t > 0$）的 Crank-Nicolson（梯形）隐式时间积分器来对该模式进行时间推进。虽然该格式对此类线性问题是无条件稳定的，但要准确捕捉波的传播，需要足够的时间分辨率。\n\n仅从给定的控制方程和作为常微分方程时间离散化的 Crank-Nicolson 方法的定义出发，推导允许的相对相速度误差与无量纲时间步长之间的前导阶小参数渐近关系。然后，在允许的相对相速度误差很小（$\\delta \\ll 1$）的渐近区域内，确定每个物理周期所需的最小时间步数 $N_{\\min}(\\delta)$，以确保角频率为 $\\omega$ 的模式的相对相速度误差的绝对值不超过 $\\delta$。\n\n将最终答案表示为仅含 $\\delta$ 的单个闭式解析表达式。最终答案中不包含任何单位。如果引入了任何辅助量，请将其消去，以使最终表达式仅依赖于 $\\delta$。无需进行数值四舍五入。",
            "solution": "问题陈述经过严格验证，确认有效。它具有科学依据，是适定的、客观的，并包含足够的信息来推导出唯一且有意义的解。这是波现象数值分析中的一个标准问题。\n\n该问题要求分析当 Crank-Nicolson 时间积分格式应用于控制声波方程单个傅里叶模式演化的简谐振子方程时所产生的数值相位误差。\n\n复模态振幅 $y(t)$ 的控制常微分方程如下：\n$$\n\\frac{d y}{d t} = i \\, \\omega \\, y\n$$\n其中 $i = \\sqrt{-1}$ 是虚数单位，$\\omega$ 是该模式的实值角频率。\n\nCrank-Nicolson 方法，也称为梯形法则，用于在时间上离散化此方程。设 $y_n$ 是 $y(n \\Delta t)$ 的数值近似，其中 $\\Delta t$ 是均匀的时间步长。该格式定义为：\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = \\frac{1}{2} \\left( (i \\omega y_n) + (i \\omega y_{n+1}) \\right)\n$$\n这是一个关于 $y_{n+1}$ 的隐式格式。我们重新整理各项来求解 $y_{n+1}$：\n$$\ny_{n+1} - \\frac{i \\omega \\Delta t}{2} y_{n+1} = y_n + \\frac{i \\omega \\Delta t}{2} y_n\n$$\n$$\ny_{n+1} \\left( 1 - \\frac{i \\omega \\Delta t}{2} \\right) = y_n \\left( 1 + \\frac{i \\omega \\Delta t}{2} \\right)\n$$\n更新规则可以写成 $y_{n+1} = G_{num} y_n$，其中 $G_{num}$ 是数值放大因子：\n$$\nG_{num} = \\frac{1 + \\frac{i \\omega \\Delta t}{2}}{1 - \\frac{i \\omega \\Delta t}{2}}\n$$\n控制常微分方程的精确解在一个时间步长内的演化为 $y(t_{n+1}) = y(t_n) \\exp(i \\omega \\Delta t)$。因此，精确放大因子为 $G_{exact} = \\exp(i \\omega \\Delta t)$。\n\n数值格式引入了一个数值频率 $\\omega_{num}$，使得数值解根据有效放大因子 $G_{num} = \\exp(i \\omega_{num} \\Delta t)$ 演化。数值放大因子的相位是单个时间步长内的数值相位变化，即 $\\phi_{num} = \\omega_{num} \\Delta t$。精确放大因子的相位是 $\\phi_{exact} = \\omega \\Delta t$。\n\n数值放大因子 $G_{num}$ 是一个形式为 $(a+ib)/(a-ib)$ 的复数，其中 $a=1$，$b=\\omega \\Delta t / 2$。其模为 $|G_{num}| = 1$，这证实了该格式是纯色散的，不引入数值耗散或放大。$G_{num}$ 的相位 $\\phi_{num}$ 由下式给出：\n$$\n\\phi_{num} = \\arg\\left(1 + \\frac{i \\omega \\Delta t}{2}\\right) - \\arg\\left(1 - \\frac{i \\omega \\Delta t}{2}\\right)\n$$\n利用关系式 $\\arg(x+iy) = \\arctan(y/x)$ 以及 $\\arctan(-z) = -\\arctan(z)$，我们得到：\n$$\n\\phi_{num} = \\arctan\\left(\\frac{\\omega \\Delta t}{2}\\right) - \\left(-\\arctan\\left(\\frac{\\omega \\Delta t}{2}\\right)\\right) = 2 \\arctan\\left(\\frac{\\omega \\Delta t}{2}\\right)\n$$\n相对相速度误差（我们记为 $\\delta_{pv}$）定义为频率的相对误差：\n$$\n\\delta_{pv} = \\frac{\\omega_{num} - \\omega}{\\omega} = \\frac{\\omega_{num} \\Delta t - \\omega \\Delta t}{\\omega \\Delta t} = \\frac{\\phi_{num} - \\phi_{exact}}{\\phi_{exact}}\n$$\n代入相位的表达式，我们得到：\n$$\n\\delta_{pv} = \\frac{2 \\arctan\\left(\\frac{\\omega \\Delta t}{2}\\right) - \\omega \\Delta t}{\\omega \\Delta t} = \\frac{2 \\arctan\\left(\\frac{\\omega \\Delta t}{2}\\right)}{\\omega \\Delta t} - 1\n$$\n问题要求找到小误差下的前导阶渐近关系，这对应于一个小的无量纲时间步长 $\\omega \\Delta t \\ll 1$。令 $x = \\frac{\\omega \\Delta t}{2}$。条件 $\\omega \\Delta t \\ll 1$ 意味着 $x \\ll 1$。我们使用 $\\arctan(x)$ 在 $x=0$ 附近的泰勒级数展开：\n$$\n\\arctan(x) = x - \\frac{x^3}{3} + O(x^5)\n$$\n将此代入 $\\delta_{pv}$ 的表达式中：\n$$\n\\delta_{pv} = \\frac{2 \\left( x - \\frac{x^3}{3} + O(x^5) \\right)}{2x} - 1 = \\left( 1 - \\frac{x^2}{3} + O(x^4) \\right) - 1 = -\\frac{x^2}{3} + O(x^4)\n$$\n代回 $x = \\frac{\\omega \\Delta t}{2}$：\n$$\n\\delta_{pv} \\approx -\\frac{1}{3} \\left(\\frac{\\omega \\Delta t}{2}\\right)^2 = -\\frac{(\\omega \\Delta t)^2}{12}\n$$\n这就是相对相速度误差与无量纲时间步长 $\\omega \\Delta t$ 之间的前导阶渐近关系。负号表示数值相速度小于物理相速度（相位滞后）。\n\n问题规定，相对相速度误差的绝对值不得超过一个小的允许误差 $\\delta \\ll 1$。因此，我们需要 $|\\delta_{pv}| \\le \\delta$。使用渐近关系：\n$$\n\\frac{(\\omega \\Delta t)^2}{12} \\le \\delta\n$$\n这个不等式可以解出无量纲时间步长 $\\omega \\Delta t$：\n$$\n(\\omega \\Delta t)^2 \\le 12 \\delta \\implies \\omega \\Delta t \\le \\sqrt{12 \\delta} = 2 \\sqrt{3 \\delta}\n$$\n此条件为给定的模式 $\\omega$ 设置了允许的时间步长 $\\Delta t$ 的上限，以满足误差容限 $\\delta$。为了找到每个周期内的最小时间步数，我们必须使用最大允许时间步长 $\\Delta t_{max}$。\n$$\n\\Delta t_{max} = \\frac{2 \\sqrt{3 \\delta}}{\\omega}\n$$\n波模式的物理周期是 $T = \\frac{2\\pi}{\\omega}$。每个周期的步数由 $N = \\frac{T}{\\Delta t}$ 给出。最小时间步数 $N_{min}$ 对应于最大时间步长 $\\Delta t_{max}$：\n$$\nN_{min}(\\delta) = \\frac{T}{\\Delta t_{max}} = \\frac{2\\pi / \\omega}{2 \\sqrt{3 \\delta} / \\omega}\n$$\n因子 $\\omega$ 消去，我们得到仅含 $\\delta$ 的 $N_{min}$ 的最终表达式：\n$$\nN_{min}(\\delta) = \\frac{2\\pi}{2 \\sqrt{3 \\delta}} = \\frac{\\pi}{\\sqrt{3 \\delta}}\n$$\n该表达式给出了在 $\\delta$ 很小的渐近极限下，为确保相对相速度误差的绝对值不大于 $\\delta$ 所需的每个周期的最小时间步数。",
            "answer": "$$\\boxed{\\frac{\\pi}{\\sqrt{3 \\delta}}}$$"
        },
        {
            "introduction": "理论分析为我们提供了关于数值格式收敛阶和稳定性的深刻见解，但计算科学的最终检验标准在于实践。这项综合性练习旨在将理论付诸实践，要求你亲手编写代码，实现包括显式和隐式在内的多种时间积分格式。 通过运行数值实验并对误差数据进行拟合，你将能够从经验上验证这些格式的理论收敛阶，这不仅能加深你对理论的理解，也是验证代码正确性和培养计算问题解决能力的基本功。",
            "id": "4122854",
            "problem": "考虑一维空间中的线性声学，在小扰动下，其受质量和动量守恒定律支配，从而导出二阶波动方程。对于均匀介质中波数为 $k$、声速为 $c$（单位：$\\mathrm{m/s}$）的单个傅里叶模式，其位移幅值 $u(t)$ 满足常微分方程 $u''(t) + \\omega^2 u(t) = 0$，其中 $\\omega = c k$ 是角频率（单位：$\\mathrm{rad/s}$）。这是因为空间傅里叶模式 $e^{\\mathrm{i} k x}$ 是空间部分的解，剩下的时间部分是一个角频率为 $\\omega = c k$ 的振荡器。设初始条件为 $u(0) = u_0$ 和 $u'(0) = v_0$，其中 $u_0$ 和 $v_0$ 为无量纲幅值。精确解在所有时间上都是良态且光滑的，您应将 $u(t)$ 视为无量纲量，时间 $t$ 的单位为 $\\mathrm{s}$。\n\n您的任务是通过重复地将时间步长 $\\Delta t$ 减半，来评估应用于此单模声学振荡器的多种时间积分格式的时间离散化误差收敛率。请使用一种能避免空间离散化从而分离出时间误差的公式。从振荡器方程 $u''(t) + \\omega^2 u(t) = 0$ 或其等价的一阶系统 $y'(t) = A y(t)$（其中 $y(t) = [u(t), v(t)]^\\top$，$A = \\begin{bmatrix} 0  1 \\\\ -\\omega^2  0 \\end{bmatrix}$ 且 $v(t) = u'(t)$）出发，根据第一性原理推导您的时间步进公式。\n\n实现以下时间积分格式：\n- 针对二阶方程 $u''(t) + \\omega^2 u(t) = 0$ 的显式二阶中心差分格式。\n- 针对一阶系统 $y'(t) = A y(t)$ 的隐式后向欧拉格式。\n- 针对一阶系统 $y'(t) = A y(t)$ 的隐式 Crank–Nicolson（隐式中点）格式。\n\n对于每种格式，通过将数值解与基于给定 $\\omega$、$u_0$ 和 $v_0$ 的精确解进行比较，计算在最终时刻 $T$ 时 $u$ 的绝对误差。为了评估观测到的时间精度阶 $p$，对一系列减半的时间步长 $\\Delta t_i = \\Delta t_0 / 2^i$（$i = 0, 1, \\dots, L-1$）及其对应的误差 $e(\\Delta t_i)$，进行 $\\log e(\\Delta t)$ 对 $\\log \\Delta t$ 的最小二乘拟合，并报告其斜率 $p$。\n\n科学和数值细节：\n- $c$ 的单位为 $\\mathrm{m/s}$，$k$ 的单位为 $\\mathrm{rad/m}$，$\\omega$ 的单位为 $\\mathrm{rad/s}$，$t$ 的单位为 $\\mathrm{s}$，$\\Delta t$ 的单位为 $\\mathrm{s}$。幅值变量 $u$ 和 $v$ 是无量纲的。\n- 对于给定的整数 $N_0$，选择 $T = N_0 \\Delta t_0$，这样对于每个减半层级 $i$，最终时刻都能精确地保持为 $T = (N_0 \\cdot 2^i) \\Delta t_i$。这确保了在不同减半层级之间最终时刻的一致性。\n- 对于显式中心差分格式，请确保初始半步或等效的启动程序是根据底层振荡器一致地构建的，以达到预期的二阶时间精度。\n\n您的程序必须实现以上要求，并为以下测试套件生成观测到的精度阶 $p$。每个测试用例是一个参数元组 $(\\text{scheme}, c, f, u_0, v_0, \\Delta t_0 \\text{ rule}, N_0, L)$，其中 $\\text{scheme} \\in \\{\\text{SV}, \\text{BE}, \\text{CN}\\}$ 分别表示显式中心差分（Störmer–Verlet）格式 $\\text{SV}$、后向欧拉格式 $\\text{BE}$ 和 Crank–Nicolson 格式 $\\text{CN}$。角频率为 $\\omega = 2 \\pi f$（单位：$\\mathrm{rad/s}$），波数为 $k = \\omega / c$（单位：$\\mathrm{rad/m}$）。$\\Delta t_0 \\text{ rule}$ 指定了如何根据 $\\omega$ 来设置 $\\Delta t_0$。\n\n测试套件：\n- 用例1：$(\\text{SV}, c = 343, f = 2000, u_0 = 1, v_0 = 0, \\Delta t_0 = 1 / \\omega, N_0 = 80, L = 5)$。\n- 用例2：$(\\text{BE}, c = 343, f = 2000, u_0 = 1, v_0 = 0, \\Delta t_0 = 1 / \\omega, N_0 = 80, L = 5)$。\n- 用例3：$(\\text{CN}, c = 343, f = 2000, u_0 = 1, v_0 = 0, \\Delta t_0 = 1 / \\omega, N_0 = 80, L = 5)$。\n- 用例4：$(\\text{SV}, c = 343, f = 2000, u_0 = 1, v_0 = 0, \\Delta t_0 = 1.9 / \\omega, N_0 = 80, L = 5)$，用于探测中心差分格式的显式稳定性边界附近，其稳定性条件为 $\\Delta t \\omega  2$。\n- 用例5：$(\\text{CN}, c = 343, f = 8000, u_0 = 1, v_0 = 0, \\Delta t_0 = 1 / \\omega, N_0 = 80, L = 5)$。\n\n您的程序应使用在 $L$ 个层级上对 $\\log e(\\Delta t)$ 与 $\\log \\Delta t$ 进行的最小二乘拟合，来计算每个用例的观测阶数 $p$，然后生成一行输出，其中包含用方括号括起来并以逗号分隔的结果列表（例如，$[\\text{result1},\\text{result2},\\text{result3}]$）。每个结果必须是对应于指定用例的估计阶数的浮点数（十进制形式），不带单位。",
            "solution": "该问题要求评估三种不同的时间积分格式应用于单模声学振荡器方程时的时间收敛率。该分析包括实现这些格式，针对一系列逐渐减小的时间步长 $\\Delta t$，计算在固定最终时刻 $T$ 的数值解与精确解之间的误差，并通过对误差的对数与时间步长的对数进行最小二乘拟合来确定观测到的精度阶 $p$。\n\n首先，我们建立控制常微分方程 (ODE) 的精确解析解，它将作为误差计算的基准。二阶 ODE 由下式给出：\n$$u''(t) + \\omega^2 u(t) = 0$$\n初始条件为 $u(0) = u_0$ 和 $u'(0) = v_0$。其通解形式为 $u(t) = C_1 \\cos(\\omega t) + C_2 \\sin(\\omega t)$。应用初始条件：\n$u(0) = C_1 = u_0$\n$u'(t) = -\\omega C_1 \\sin(\\omega t) + \\omega C_2 \\cos(\\omega t) \\implies u'(0) = \\omega C_2 = v_0 \\implies C_2 = v_0/\\omega$。\n因此，位移 $u(t)$ 和速度 $v(t) = u'(t)$ 的精确解为：\n$$u(t) = u_0 \\cos(\\omega t) + \\frac{v_0}{\\omega} \\sin(\\omega t)$$\n$$v(t) = -u_0 \\omega \\sin(\\omega t) + v_0 \\cos(\\omega t)$$\n这些公式将用于计算最终时刻 $T$ 的数值解的误差。\n\n接下来，我们推导数值格式。时间被离散化为 $t_n = n \\Delta t$，其中 $u^n \\approx u(t_n)$。\n\n**1. 显式二阶中心差分 (Störmer–Verlet) 格式 (SV)**\n该格式直接离散化二阶 ODE $u'' = -\\omega^2 u$。二阶导数 $u''(t_n)$ 使用二阶中心差分进行近似：\n$$\\frac{u^{n+1} - 2u^n + u^{n-1}}{(\\Delta t)^2} = -\\omega^2 u^n + O((\\Delta t)^2)$$\n重新整理以求解 $u^{n+1}$，得到显式时间步进公式：\n$$u^{n+1} = (2 - (\\omega \\Delta t)^2)u^n - u^{n-1}$$\n这是一个两步法，需要两个初始值 $u^0$ 和 $u^1$ 来启动迭代。\n$u^0 = u(0) = u_0$。\n为了使格式达到全局二阶精度，$u^1$ 必须以至少二阶的精度进行计算。我们使用在 $t=0$ 处的泰勒展开：\n$$u(\\Delta t) = u(0) + \\Delta t u'(0) + \\frac{(\\Delta t)^2}{2} u''(0) + O((\\Delta t)^3)$$\n代入初始条件以及从 ODE 中得到的 $u''(0) = -\\omega^2 u(0) = -\\omega^2 u_0$：\n$$u^1 = u_0 + v_0 \\Delta t - \\frac{(\\omega \\Delta t)^2}{2} u_0$$\n这种启动程序确保了整个方法能达到其理论上的二阶精度。该格式是条件稳定的，要求 $|\\omega \\Delta t| \\le 2$。\n\n**2. 隐式后向欧拉格式 (BE)**\n该格式应用于等价的一阶系统 $y'(t) = Ay(t)$，其中 $y(t) = [u(t), v(t)]^\\top$，矩阵 $A$ 为：\n$$A = \\begin{bmatrix} 0  1 \\\\ -\\omega^2  0 \\end{bmatrix}$$\n后向欧拉方法由以下公式定义：\n$$y^{n+1} = y^n + \\Delta t A y^{n+1}$$\n这是一个隐式格式，需要我们求解 $y^{n+1}$：\n$$(I - \\Delta t A) y^{n+1} = y^n \\implies y^{n+1} = (I - \\Delta t A)^{-1} y^n$$\n其中 $I$ 是 $2 \\times 2$ 的单位矩阵。我们计算矩阵 $(I - \\Delta t A)$ 的逆：\n$$I - \\Delta t A = \\begin{bmatrix} 1  -\\Delta t \\\\ \\omega^2 \\Delta t  1 \\end{bmatrix}$$\n其逆为：\n$$(I - \\Delta t A)^{-1} = \\frac{1}{1 + (\\omega \\Delta t)^2} \\begin{bmatrix} 1  \\Delta t \\\\ -\\omega^2 \\Delta t  1 \\end{bmatrix}$$\n状态向量 $y^n = [u^n, v^n]^\\top$ 用 $y^0 = [u_0, v_0]^\\top$ 初始化，并进行迭代更新。后向欧拉格式是无条件稳定的，但只有一阶精度，即 $p=1$。\n\n**3. 隐式 Crank–Nicolson 格式 (CN)**\nCrank-Nicolson 格式也是一种用于一阶系统的隐式方法，其定义如下：\n$$y^{n+1} = y^n + \\frac{\\Delta t}{2} (A y^n + A y^{n+1})$$\n它在时间中点 $t_{n+1/2}$ 处近似导数。求解 $y^{n+1}$：\n$$(I - \\frac{\\Delta t}{2} A) y^{n+1} = (I + \\frac{\\Delta t}{2} A) y^n \\implies y^{n+1} = \\left(I - \\frac{\\Delta t}{2} A\\right)^{-1} \\left(I + \\frac{\\Delta t}{2} A\\right) y^n$$\n放大矩阵 $G = (I - \\frac{\\Delta t}{2} A)^{-1} (I + \\frac{\\Delta t}{2} A)$ 为：\n$$G = \\frac{1}{1 + \\frac{(\\omega \\Delta t)^2}{4}} \\begin{bmatrix} 1 - \\frac{(\\omega \\Delta t)^2}{4}  \\Delta t \\\\ -\\omega^2 \\Delta t  1 - \\frac{(\\omega \\Delta t)^2}{4} \\end{bmatrix}$$\n更新规则为 $y^{n+1} = G y^n$。该格式是无条件稳定的，且具有二阶精度 ($p=2$)。\n\n**收敛率分析**\n对于每个测试用例，我们计算一系列 $L$ 个时间步长（$\\Delta t_i = \\Delta t_0 / 2^i$，$i=0, 1, \\dots, L-1$）下的数值解及其误差。步数被调整为 $N_i = N_0 \\cdot 2^i$，以保持最终时刻 $T = N_i \\Delta t_i = N_0 \\Delta t_0$ 恒定。在时刻 $T$ 的绝对误差为 $e(\\Delta t_i) = |u_{\\text{numerical}}(T) - u_{\\text{exact}}(T)|$。理论收敛关系为 $e(\\Delta t) \\approx C (\\Delta t)^p$，其中 $p$ 是精度阶。取对数可得：\n$$\\log(e) \\approx \\log(C) + p \\log(\\Delta t)$$\n这是 $\\log(e)$ 和 $\\log(\\Delta t)$ 之间的线性关系，斜率为 $p$。我们通过对数据点 $(\\log(\\Delta t_i), \\log(e_i))$（$i=0, \\dots, L-1$）进行线性最小二乘拟合来计算该斜率。所得的斜率即为该格式在指定测试条件下的观测精度阶。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_order(case_params):\n    \"\"\"\n    Calculates the observed order of accuracy for a given numerical scheme and parameters.\n    \n    Args:\n        case_params (tuple): A tuple containing the test case parameters:\n            (scheme, c, f, u0, v0, dt0_rule_val, N0, L).\n\n    Returns:\n        float: The observed order of accuracy 'p'.\n    \"\"\"\n    scheme, c, f, u0, v0, dt0_rule_val, N0, L = case_params\n\n    omega = 2.0 * np.pi * f\n    dt0 = dt0_rule_val / omega\n    T = N0 * dt0\n\n    log_dts = []\n    log_errors = []\n\n    # Calculate exact solution at time T for error comparison\n    if omega == 0:\n        u_exact = u0 + v0 * T\n    else:\n        u_exact = u0 * np.cos(omega * T) + (v0 / omega) * np.sin(omega * T)\n\n    # Loop over refinement levels\n    for i in range(L):\n        dt_i = dt0 / (2**i)\n        N_i = int(N0 * (2**i))\n\n        u_numerical = 0.0\n        if scheme == 'SV':\n            # Störmer-Verlet (Central Difference)\n            u_prev = u0\n            # Second-order accurate starting step\n            u_curr = u0 + v0 * dt_i - 0.5 * (omega**2) * u0 * (dt_i**2)\n            \n            if N_i == 0:\n                 u_numerical = u0\n            elif N_i == 1:\n                u_numerical = u_curr\n            else:\n                for _ in range(N_i - 1):\n                    u_next = (2.0 - (omega * dt_i)**2) * u_curr - u_prev\n                    u_prev = u_curr\n                    u_curr = u_next\n                u_numerical = u_curr\n\n        elif scheme == 'BE':\n            # Backward Euler\n            y = np.array([u0, v0], dtype=np.float64)\n            omega2 = omega**2\n            denom = 1.0 + (omega * dt_i)**2\n            update_matrix = np.array([\n                [1.0, dt_i],\n                [-omega2 * dt_i, 1.0]\n            ], dtype=np.float64) / denom\n            \n            for _ in range(N_i):\n                y = update_matrix @ y\n            u_numerical = y[0]\n\n        elif scheme == 'CN':\n            # Crank-Nicolson\n            y = np.array([u0, v0], dtype=np.float64)\n            omega2 = omega**2\n            term = (omega * dt_i)**2 / 4.0\n            denom = 1.0 + term\n            \n            m11_m22 = (1.0 - term) / denom\n            m12 = dt_i / denom\n            m21 = -omega2 * dt_i / denom\n            \n            update_matrix = np.array([\n                [m11_m22, m12],\n                [m21, m11_m22]\n            ], dtype=np.float64)\n            \n            for _ in range(N_i):\n                y = update_matrix @ y\n            u_numerical = y[0]\n\n        error = np.abs(u_numerical - u_exact)\n        \n        # Avoid log(0) issues for very small errors.\n        if error > np.finfo(float).tiny:\n            log_dts.append(np.log(dt_i))\n            log_errors.append(np.log(error))\n\n    # Perform linear regression if there are enough points for a fit.\n    if len(log_dts) > 1:\n        p, _ = np.polyfit(log_dts, log_errors, 1)\n        return p\n    else:\n        return np.nan # Return NaN if fit is not possible.\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (scheme, c, f, u0, v0, dt0_rule_val, N0, L)\n        ('SV', 343.0, 2000.0, 1.0, 0.0, 1.0, 80, 5),\n        ('BE', 343.0, 2000.0, 1.0, 0.0, 1.0, 80, 5),\n        ('CN', 343.0, 2000.0, 1.0, 0.0, 1.0, 80, 5),\n        ('SV', 343.0, 2000.0, 1.0, 0.0, 1.9, 80, 5),\n        ('CN', 343.0, 8000.0, 1.0, 0.0, 1.0, 80, 5),\n    ]\n\n    results = []\n    for case in test_cases:\n        order = calculate_order(case)\n        results.append(order)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}