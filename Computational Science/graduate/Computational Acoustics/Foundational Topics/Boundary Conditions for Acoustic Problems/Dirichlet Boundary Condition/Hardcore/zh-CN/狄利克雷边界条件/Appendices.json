{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的计算模拟之前，我们必须掌握声学中狄利克雷边界条件所代表的基本物理原理。这项练习将从第一性原理出发，推导声波在压力释放（声软）边界上的反射系数，这是声学中狄利克雷条件的经典体现。通过完成此推导，您将揭示此边界条件如何导致入射压力波发生完美的相位反转，从而巩固对此核心概念的理解。",
            "id": "4120025",
            "problem": "考虑一个均匀、无粘性、可压缩的流体，占据半空间 $z>0$，其密度 $\\rho$ 和声速 $c$ 为常数。一个角频率为 $\\omega$ 的时谐平面声波从流体内部入射到位于 $z=0$ 的平面边界上。该边界是压力释放（声软）边界，因此声压满足狄利克雷边界条件 $p(x,z=0,t)=0$ 对所有 $x$ 和 $t$ 成立。设入射波矢量与从流体指向边界的单位法向量之间的夹角为 $\\theta \\in (0,\\pi/2)$，并假设在 $x$-$z$ 平面内为二维相关性。\n\n从线性声学方程组和状态方程出发，推导在时谐拟设下复压幅 $p(x,z)$ 所满足的标量亥姆霍兹偏微分方程 (PDE)。然后，仅使用边界条件、介质的均匀性和边界的平移不变性，从第一性原理出发，证明波矢量平行于边界的分量在反射时保持不变。最后，确定由 $z=0$ 处的 $p_r = R_p\\,p_i$ 定义的复压反射系数 $R_p$，其中 $p_i$ 和 $p_r$ 分别是入射和反射复压场。\n\n你的最终答案应为 $R_p$ 的单个闭式表达式（无量纲）。不需要进行数值取整。如果需要，所有角度都应以弧度为单位。",
            "solution": "该问题要求进行三个与平面声波从压力释放边界反射相关的独立推导。我们将从线性声学的基本原理出发，依次解决每个部分。\n\n在平衡密度为 $\\rho_0$、压力为 $p_0$ 的均匀、无粘性、可压缩流体中，声学的控制方程是线性化的欧拉方程（动量守恒）和连续性方程（质量守恒）。对于压力 $p$、密度 $\\rho'$ 和流体速度 $\\mathbf{u}$ 的小扰动，这些方程为：\n$$\n\\rho_0 \\frac{\\partial \\mathbf{u}}{\\partial t} = -\\nabla p \\quad \\text{(动量方程)}\n$$\n$$\n\\frac{\\partial \\rho'}{\\partial t} + \\rho_0 \\nabla \\cdot \\mathbf{u} = 0 \\quad \\text{(连续性方程)}\n$$\n该方程组由线性化状态方程封闭，它关联了等熵过程中的压力和密度扰动：\n$$\np = c^2 \\rho'\n$$\n其中 $c = \\sqrt{(\\partial p/\\partial \\rho)_S}$ 是声速，在这个均匀介质中为常数。\n\n**第一部分：亥姆霍兹方程的推导**\n\n我们的目标是将这三个方程组合成一个关于声压 $p$ 的单一偏微分方程 (PDE)。\n\n首先，我们对动量方程取散度：\n$$\n\\nabla \\cdot \\left( \\rho_0 \\frac{\\partial \\mathbf{u}}{\\partial t} \\right) = -\\nabla \\cdot (\\nabla p)\n$$\n由于 $\\rho_0$ 是常数，且空间和时间导数可交换，我们得到：\n$$\n\\rho_0 \\frac{\\partial}{\\partial t} (\\nabla \\cdot \\mathbf{u}) = -\\nabla^2 p\n$$\n接下来，我们对连续性方程取时间导数：\n$$\n\\frac{\\partial}{\\partial t} \\left( \\frac{\\partial \\rho'}{\\partial t} + \\rho_0 \\nabla \\cdot \\mathbf{u} \\right) = 0\n$$\n$$\n\\frac{\\partial^2 \\rho'}{\\partial t^2} + \\rho_0 \\frac{\\partial}{\\partial t} (\\nabla \\cdot \\mathbf{u}) = 0\n$$\n现在，将状态方程中的 $\\rho' = p/c^2$ 代入此结果：\n$$\n\\frac{1}{c^2} \\frac{\\partial^2 p}{\\partial t^2} + \\rho_0 \\frac{\\partial}{\\partial t} (\\nabla \\cdot \\mathbf{u}) = 0\n$$\n我们可以从动量方程的散度中分离出项 $\\rho_0 \\frac{\\partial}{\\partial t} (\\nabla \\cdot \\mathbf{u})$，得到 $\\rho_0 \\frac{\\partial}{\\partial t}(\\nabla \\cdot \\mathbf{u}) = -\\nabla^2 p$。将此式代入前一个方程，得到：\n$$\n\\frac{1}{c^2} \\frac{\\partial^2 p}{\\partial t^2} - \\nabla^2 p = 0\n$$\n这就是压力场 $p(x,z,t)$ 的齐次声波方程。\n\n问题指定了角频率为 $\\omega$ 的时谐波。因此，我们对压力采用时谐拟设，将总压力场表示为一个复量的实部。根据物理学和工程学中的标准惯例，我们将完整的含时压力写为 $p_{total}(x,z,t) = p(x,z)e^{-i\\omega t}$，其中 $p(x,z)$ 是复压幅。将此代入波动方程：\n$$\n\\nabla^2 (p(x,z)e^{-i\\omega t}) - \\frac{1}{c^2} \\frac{\\partial^2}{\\partial t^2} (p(x,z)e^{-i\\omega t}) = 0\n$$\n由于 $p(x,z)$ 不依赖于时间 $t$，我们可以对 $t$ 进行微分：$\\frac{\\partial}{\\partial t} (e^{-i\\omega t}) = -i\\omega e^{-i\\omega t}$ 和 $\\frac{\\partial^2}{\\partial t^2} (e^{-i\\omega t}) = (-i\\omega)^2 e^{-i\\omega t} = -\\omega^2 e^{-i\\omega t}$。方程变为：\n$$\ne^{-i\\omega t} \\nabla^2 p(x,z) - \\frac{1}{c^2} p(x,z) (-\\omega^2 e^{-i\\omega t}) = 0\n$$\n我们可以提出非零项 $e^{-i\\omega t}$：\n$$\n\\nabla^2 p(x,z) + \\frac{\\omega^2}{c^2} p(x,z) = 0\n$$\n定义波数为 $k = \\omega/c$，我们得到复压幅的标量亥姆霍兹偏微分方程：\n$$\n\\nabla^2 p(x,z) + k^2 p(x,z) = 0\n$$\n\n**第二部分：切向波矢量分量的守恒**\n\n流体中的总压力场 $p(x,z)$ 是入射波 $p_i(x,z)$ 和反射波 $p_r(x,z)$ 的叠加：\n$$\np(x,z) = p_i(x,z) + p_r(x,z)\n$$\n作为满足亥姆霍兹方程的平面波，入射场和反射场具有以下一般形式：\n$$\np_i(x,z) = P_i e^{i(k_{ix}x + k_{iz}z)}\n$$\n$$\np_r(x,z) = P_r e^{i(k_{rx}x + k_{rz}z)}\n$$\n其中 $P_i$ 和 $P_r$ 是复振幅，$\\mathbf{k}_i = (k_{ix}, k_{iz})$ 和 $\\mathbf{k}_r = (k_{rx}, k_{rz})$ 分别是入射和反射波矢量。介质的均匀性要求两列波以相同的速度 $c$ 传播，因此它们的波数模长必须相同：$|\\mathbf{k}_i| = |\\mathbf{k}_r| = k = \\omega/c$。\n\n边界条件是在 $z=0$ 处为压力释放面，这意味着在任何时刻，边界上所有点的总声压均为零。用复振幅表示，即：\n$$\np(x,z=0) = 0 \\quad \\text{对所有 } x\n$$\n将入射波和反射波的表达式代入边界条件：\n$$\np_i(x,0) + p_r(x,0) = 0\n$$\n$$\nP_i e^{i(k_{ix}x + k_{iz} \\cdot 0)} + P_r e^{i(k_{rx}x + k_{rz} \\cdot 0)} = 0\n$$\n$$\nP_i e^{ik_{ix}x} + P_r e^{ik_{rx}x} = 0\n$$\n这个方程必须对边界上所有的 $x$ 值都成立。这是边界平移不变性的关键推论。函数族 $\\{e^{i\\lambda x} | \\lambda \\in \\mathbb{R}\\}$ 构成一组线性无关的基函数。要使两个此类函数的线性组合对所有 $x$ 都为零，必须满足以下两个条件之一：\n1. 系数均为零（$P_i=0$ 和 $P_r=0$），这对应于没有波的平凡情况。\n2. 指数相同（$k_{ix} = k_{rx}$），且系数之和为零（$P_i + P_r = 0$）。\n\n假设存在非平凡的入射波（$P_i \\neq 0$），则第二个条件必须成立。因此，我们必须有：\n$$\nk_{ix} = k_{rx}\n$$\n这从第一性原理（均匀性、平移不变性和边界条件）证明了平行于边界的波矢量分量在反射时是守恒的。这是反射的斯涅尔定律的基础。\n\n**第三部分：压力反射系数的确定**\n\n复压反射系数 $R_p$ 由在边界 $z=0$ 处求值的关系式 $p_r = R_p p_i$ 定义。\n$$\nR_p = \\frac{p_r(x,z=0)}{p_i(x,z=0)}\n$$\n使用 $z=0$ 处的平面波表达式：\n$$\nR_p = \\frac{P_r e^{ik_{rx}x}}{P_i e^{ik_{ix}x}}\n$$\n根据第二部分的结果，我们知道 $k_{ix} = k_{rx}$。$R_p$ 的表达式简化为复振幅之比：\n$$\nR_p = \\frac{P_r}{P_i}\n$$\n同样根据第二部分，边界条件要求 $P_i + P_r = 0$，这意味着 $P_r = -P_i$。将此代入 $R_p$ 的表达式中：\n$$\nR_p = \\frac{-P_i}{P_i} = -1\n$$\n因此，平面波入射到压力释放边界上的复压反射系数为 $-1$。这表明在边界处，反射压力波与入射波振幅相同，但相位完全相反（$\\pi$ 弧度的相移），从而确保它们的和恒为零。这个结果与入射角 $\\theta$ 无关。",
            "answer": "$$\n\\boxed{-1}\n$$"
        },
        {
            "introduction": "从纯粹的理论分析转向数值近似的实际挑战。理论上的边界可以是完美光滑的，但在计算中，离散网格常常会引入几何上的近似。本练习将使用有限差分法（Finite Difference Method, FDM）在笛卡尔网格上模拟一个弯曲的狄利克雷边界，让您亲身体验这种“阶梯”近似所带来的误差。通过这个实践，您将学会如何量化由此产生的数值误差，并基于其缩放行为，推导出实用的网格加密标准。",
            "id": "4120000",
            "problem": "考虑由标量亥姆霍兹方程控制的时间谐波声压，该声压在二维空间中位于一个压力释放（声软）边界内，这意味着压力在边界上满足等于零的狄利克雷条件。一个标准的简化公式使用狄利克雷拉普拉斯特征问题来表征模态波数。具体来说，对于一个具有光滑边界的有界域，第一模态由算子 $-\\Delta$ 在边界上满足狄利克雷边界条件 $p=0$ 的最小特征对给出，满足\n$$\n-\\Delta p = \\lambda p, \\quad p|_{\\partial \\Omega}=0.\n$$\n当边界是弯曲的（例如，一个圆形）但在笛卡尔网格上进行离散化时，边界会使用阶梯状掩模进行近似。即使内部的有限差分算子名义上是二阶的，这种几何近似也会在计算出的特征值和场中引入误差。您的任务是量化一个圆盘的第一狄利克雷特征值的阶梯误差，并基于第一性原理缩放提出一个网格细化准则。\n\n从基本定律和核心定义出发，按如下方式构建计算过程：\n- 物理域是一个以原点为中心、半径为 $R$（单位为米）的圆盘，在 $r=R$ 处满足狄利克雷边界条件 $p=0$。\n- 圆盘的连续第一狄利克雷特征值由下式给出\n$$\n\\lambda_{\\text{anal}} = \\frac{j_{0,1}^2}{R^2},\n$$\n其中 $j_{0,1}$ 是零阶第一类贝塞尔函数的第一个正零点。\n- 在间距为 $h$（单位为米）的均匀笛卡尔网格上近似该圆盘。坐标为 $(x,y)$ 且满足 $x^2+y^2  R^2$ 的网格点被定义为内部点。",
            "solution": "该问题被评估为有效，因为它在科学上基于计算声学和数值分析的原理，问题定义良好、客观，并包含完整解答所需的所有必要信息。\n\n本任务旨在分析当使用有限差分法计算狄利克雷拉普拉斯算子的第一特征值时，由圆形边界的阶梯近似所引入的数值误差。我们将构建计算流程，实施该流程以分析特定的测试用例，并基于观测到的误差缩放规律推导出一个实用的网格细化准则。\n\n**1. 连续特征问题**\n\n物理问题涉及二维域 $\\Omega$ 内的时间谐波声压 $p$。该压力场由标量亥姆霍兹方程控制。对于模态分析，这简化为负拉普拉斯算子 $-\\Delta$ 的特征值问题。域 $\\Omega$ 是一个以原点为中心的半径为 $R$ 的圆盘。边界条件是压力释放或声软类型，对应于边界 $\\partial\\Omega$ 上的齐次狄利克雷条件 $p=0$。因此，该问题可表述为：\n$$\n-\\Delta p = \\lambda p \\quad \\text{in } \\Omega, \\qquad p|_{\\partial\\Omega} = 0.\n$$\n该问题的解是特征对 $(\\lambda_k, p_k)$，其中 $\\lambda_k$ 是特征值（与模态波数相关），$p_k$是对应的特征函数（模态）。\n\n对于半径为 $R$ 的圆盘，特征函数在极坐标中是可分离的。第一模态，即基频模态，是径向对称的。最小特征值 $\\lambda_{\\text{anal}}$ 的解析表达式是已知的，由下式给出：\n$$\n\\lambda_{\\text{anal}} = \\left(\\frac{j_{0,1}}{R}\\right)^2,\n$$\n其中 $j_{0,1}$ 是零阶第一类贝塞尔函数 $J_0(x)$ 的第一个正根。其值约为 $j_{0,1} \\approx 2.4048255577$。$\\lambda$ 的单位是长度的平方的倒数，这里是 $\\text{m}^{-2}$。\n\n**2. 离散近似**\n\n为了数值求解该问题，我们采用有限差分法。连续域被一个均匀笛卡尔网格上的离散点集所取代，网格间距为 $h$。我们定义一个覆盖方形域 $[-R, R] \\times [-R, R]$ 的计算网格。如果网格点 $(x_i, y_j)$ 位于圆盘内部，即 $x_i^2 + y_j^2  R^2$，则它被视为*内部*点。所有其他点都被视为边界的一部分，其上的压力固定为 $p=0$。\n\n负拉普拉斯算子 $-\\Delta$ 在每个内部网格点 $(i, j)$ 处使用标准的五点模板进行近似：\n$$\n(-\\Delta_h p)_{i,j} = \\frac{4p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1}}{h^2}.\n$$\n在每个内部点上应用此近似会得到一个线性方程组。设 $N_{\\text{int}}$ 是内部网格点的总数。我们可以将这些点上的压力 $p$ 值表示为一个大小为 $N_{\\text{int}}$ 的向量 $\\mathbf{p}$。离散特征问题于是可以写成矩阵形式：\n$$\nA \\mathbf{p} = \\lambda \\mathbf{p}.\n$$\n此处，$A$ 是一个表示离散算子 $-\\Delta_h$ 的 $N_{\\text{int}} \\times N_{\\text{int}}$ 稀疏矩阵。$A$ 的元素构造如下：\n- 对每个内部点，将其二维网格坐标 $(i,j)$ 映射到一个唯一的一维索引 $k \\in \\{0, 1, \\dots, N_{\\text{int}}-1\\}$。\n- 对应于点 $k$ 的对角线元素是 $A_{k,k} = 4/h^2$。\n- 对于点 $k$ 的每个同样是内部点（索引为 $k'$）的邻居，设置一个非对角线元素：$A_{k,k'} = -1/h^2$。\n- 如果一个邻居位于边界上或边界外，根据狄利克雷条件，其压力值为 $0$。这个贡献被自然地包含在模板求和中，因此对于这些边界相互作用，不需要特定的矩阵项。\n\n最终得到的矩阵 $A$ 是实对称正定矩阵。该矩阵的最小特征值（我们记作 $\\lambda_{\\text{num}}$）是 $\\lambda_{\\text{anal}}$ 的数值近似。它可以使用稀疏对称特征求解器高效计算。\n\n**3. 误差分析与缩放定律**\n\n离散化会引入误差。在此公式中，误差的主要来源是对圆盘光滑弯曲边界的“阶梯”近似。虽然五点模板在域内部是二阶精度 ($O(h^2)$)，但边界处的几何误差仅为一阶 ($O(h)$)。这种低阶误差主导了总误差。\n\n我们将计算出的特征值的相对误差 $\\varepsilon$ 量化为：\n$$\n\\varepsilon = \\left|\\frac{\\lambda_{\\text{num}}-\\lambda_{\\text{anal}}}{\\lambda_{\\text{anal}}}\\right|.\n$$\n基于域微扰理论，主阶误差预计与网格间距相对于域大小的比例呈线性缩放关系：\n$$\n\\varepsilon \\approx C \\frac{h}{R},\n$$\n其中 $C$ 是一个无量纲常数，它取决于几何形状和具体的边界实现方式，但对于小的 $h/R$ 值，它近似独立于 $h$ 和 $R$。\n\n**4. 网格细化准则**\n\n目标是确定一个合适的网格间距 $h$，以达到期望的误差容限 $\\varepsilon_{\\text{tol}}$。首先，我们通过经验方法估计常数 $C$。通过对几种 $R$ 和 $h$ 的组合（即提供的测试用例）进行模拟，我们为每个用例计算比率 $\\varepsilon / (h/R)$。通过取这些值的中位数，可以得到对 $C$ 的一个鲁棒估计。\n\n一旦 $C$ 已知，我们就可以反转缩放定律，为给定的容限 $\\varepsilon_{\\text{tol}}$ 确定最大允许网格间距 $h_{\\max}$：\n$$\n\\varepsilon_{\\text{tol}} \\approx C \\frac{h_{\\max}}{R} \\implies h_{\\max} \\approx \\frac{\\varepsilon_{\\text{tol}} R}{C}.\n$$\n如果一个间距为 $h$ 的给定网格满足准則 $h \\le h_{\\max}$，则认为它足够精细。\n\n实现的程序将执行以下步骤：\n1. 对于每个测试用例 $(R, h, \\varepsilon_{\\text{tol}})$，构建矩阵 $A$ 并计算 $\\lambda_{\\text{num}}$。\n2. 计算相应的相对误差 $\\varepsilon$。\n3. 处理完所有用例后，将所有计算出的 $\\varepsilon / (h/R)$ 比率的中位数作为缩放常数 $C$ 的估计值。\n4. 对于每个测试用例，使用估计出的 $C$以及该用例特定的 $\\varepsilon_{\\text{tol}}$ 和 $R$ 来计算推荐的 $h_{\\max}$。\n5. 为每个用例报告计算出的三元组 $[\\varepsilon, h_{\\max}, (h \\le h_{\\max})]$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import jn_zeros\nfrom scipy.sparse import coo_matrix\nfrom scipy.sparse.linalg import eigsh\n\ndef solve():\n    \"\"\"\n    Computes staircasing error for the Dirichlet-Laplacian eigenvalue on a disk,\n    estimates the error scaling constant, and proposes a mesh refinement criterion.\n    \"\"\"\n    # The first positive zero of the Bessel function of the first kind of order zero, J0(x).\n    j01 = jn_zeros(0, 1)[0]\n    \n    # Test cases: (R, h, eps_tol)\n    # R: radius in meters\n    # h: grid spacing in meters\n    # eps_tol: target relative error tolerance (dimensionless)\n    test_cases = [\n        (1.0, 0.05, 0.02),\n        (1.0, 0.2, 0.05),\n        (0.5, 0.025, 0.01),\n        (1.0, 0.0125, 0.005),\n    ]\n\n    # --- Pass 1: Compute numerical errors for all test cases ---\n    computed_data = []\n    ratios_for_C = []\n\n    for R, h, eps_tol in test_cases:\n        # 1. Grid and Mask Generation\n        # Create a centered Cartesian grid that encloses the disk.\n        # The number of points from center to edge is determined by floor(R/h).\n        lim = int(np.floor(R / h))\n        coords = np.arange(-lim, lim + 1) * h\n        grid_dim = len(coords)\n        xx, yy = np.meshgrid(coords, coords)\n        \n        # Create a boolean mask for grid points inside the disk.\n        mask = (xx**2 + yy**2)  R**2\n        \n        n_interior = np.sum(mask)\n        \n        # Map 2D grid indices of interior points to 1D linear indices.\n        idx_map = -np.ones((grid_dim, grid_dim), dtype=int)\n        idx_map[mask] = np.arange(n_interior)\n\n        # 2. Matrix Assembly using Coordinate (COO) format for efficiency\n        row_ind, col_ind, data = [], [], []\n        \n        # Iterate over all grid points to build the discrete operator matrix.\n        for i in range(grid_dim):\n            for j in range(grid_dim):\n                if mask[i, j]:\n                    k = idx_map[i, j]\n                    \n                    # Diagonal element from the 5-point stencil (4 * p_ij)\n                    row_ind.append(k)\n                    col_ind.append(k)\n                    data.append(4.0)\n\n                    # Off-diagonal elements for neighbors (-1 * p_neighbor)\n                    # For neighbors outside the mask, the pressure is 0 (Dirichlet BC),\n                    # so they don't contribute to the matrix for interior points.\n                    for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                        if 0 = ni  grid_dim and 0 = nj  grid_dim and mask[ni, nj]:\n                            k_neighbor = idx_map[ni, nj]\n                            row_ind.append(k)\n                            col_ind.append(k_neighbor)\n                            data.append(-1.0)\n        \n        # Scale matrix entries by 1/h^2.\n        mat_data = np.array(data) / (h**2)\n        \n        # Create the sparse matrix and convert to CSR format for fast arithmetic.\n        A = coo_matrix((mat_data, (row_ind, col_ind)), shape=(n_interior, n_interior)).tocsr()\n        \n        # 3. Eigenvalue Computation\n        # Use a sparse symmetric eigensolver to find the smallest magnitude eigenvalue.\n        eigenvalues, _ = eigsh(A, k=1, which='SM')\n        lambda_num = eigenvalues[0]\n        \n        # 4. Error Calculation\n        lambda_anal = (j01 / R)**2\n        epsilon = np.abs(lambda_num - lambda_anal) / lambda_anal\n        \n        # Store results for the second pass.\n        computed_data.append({'R': R, 'h': h, 'eps_tol': eps_tol, 'epsilon': epsilon})\n        ratios_for_C.append(epsilon / (h / R))\n\n    # --- Pass 2: Estimate C, compute h_max, and check criterion ---\n    \n    # Estimate the scaling constant C as the median of the observed ratios.\n    C = np.median(ratios_for_C)\n    \n    final_results = []\n    for data_point in computed_data:\n        R = data_point['R']\n        h = data_point['h']\n        eps_tol = data_point['eps_tol']\n        epsilon = data_point['epsilon']\n        \n        # Calculate the recommended maximum mesh spacing h_max based on the fitted C.\n        h_max = (eps_tol * R) / C\n        \n        # Check if the given mesh spacing h meets the refinement criterion.\n        meets_criterion = h = h_max\n        \n        final_results.append([epsilon, h_max, meets_criterion])\n\n    # --- Format and Print Output ---\n    def format_case_result(res):\n        eps_val, hmax_val, meets_val = res\n        # Format booleans as lowercase 'true'/'false' for consistent output.\n        meets_str = str(meets_val).lower()\n        return f\"[{eps_val},{hmax_val},{meets_str}]\"\n\n    output_str = f\"[{','.join([format_case_result(res) for res in final_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在我们理解了基于网格的几何误差之后，现在我们来探索有限元法（Finite Element Method, FEM）——一种在处理复杂几何和边界条件时更为强大和灵活的工具。这个动手实践将深入探讨两个高级的有限元概念。您将研究如何使用高阶单元通过减少数值频散来显著提高解的精度，同时还将实现罚函数法，这是一种无需修改矩阵结构便能“弱”施加狄利克雷条件的通用技术。",
            "id": "4120047",
            "problem": "考虑频域中域 $[0,L]$ 上的一维声压场。在线性声学假设下，压力 $p(x)$ 满足从质量和动量守恒推导出的标量亥姆霍兹方程，\n$$\\frac{d^2 p}{dx^2} + k^2 p = -s(x),$$\n其中 $k$ 是声波数，$s(x)$ 是一个源项。$x=0$ 处的压力释放（声软）边界通过狄利克雷边界条件 $p(0)=0$ 建模，而 $x=L$ 处的刚性终端通过诺伊曼边界条件 $\\frac{dp}{dx}(L)=0$ 建模。\n\n对应于亥姆霍兹算子和拉普拉斯特征问题的弱形式将被用作基本基础。对于一个测试函数 $v(x)$，拉普拉斯特征问题的弱形式为\n$$\\int_0^L \\frac{dp'}{dx}\\frac{dv'}{dx}\\,dx = \\lambda \\int_0^L p\\,v\\,dx,$$\n其中 $p(0)=0$ 且 $\\frac{dp}{dx}(L)=0$，并且 $\\lambda = k^2$。对于强制泊松问题（用于通过罚函数法评估边界实施情况），\n$$-\\frac{d^2 u}{dx^2} = s(x),$$\n其中 $u(0)=0$（压力释放狄利克雷条件）且 $\\frac{du}{dx}(L)=0$（刚性诺伊曼条件），其弱形式为\n$$\\int_0^L \\frac{du'}{dx}\\frac{dv'}{dx}\\,dx = \\int_0^L s\\,v\\,dx.$$\n在狄利克雷条件的罚函数实施中，通过边界项 $\\alpha\\,u(0)\\,v(0)$ 来增强弱形式的双线性项，其中 $\\alpha0$ 是罚系数。在一维节点拉格朗日有限元空间中，这简化为在与 $x=0$ 处边界节点相关联的自由度上进行一次对角线加法。\n\n您必须在 $[0,L]$ 上的 $N_e$ 个单元的均匀网格上，使用多项式次数为 $r$ 的拉格朗日单元实现一个有限元方法。使用以下标准事实来推导算法：\n- 拉普拉斯算子的双线性形式产生全局刚度矩阵 $K$，该矩阵由单元贡献 $K_e = \\int \\frac{d\\phi_i}{dx}\\frac{d\\phi_j}{dx}\\,dx$ 组装而成，其中 $\\phi_i$ 是定义在每个单元上的拉格朗日形函数。\n- 质量矩阵 $M$ 为 $M_e = \\int \\phi_i \\phi_j\\,dx$。\n- 拉普拉斯算子的广义特征值问题是 $K u = \\lambda M u$，受制于在 $x=0$ 处强施加的狄利克雷边界条件（通过消除该自由度）。\n- 对于采用罚函数法实施的强制泊松问题，求解 $(K + \\alpha B) u = f$，其中 $B$ 编码了边界项 $u(0)v(0)$，$f$ 是载荷向量 $f_i = \\int s \\phi_i\\,dx$。\n- 将 $x=L$ 处的诺伊曼边界条件作为弱形式中的自然边界条件使用（无需显式修改）。\n\n定义以下定量度量：\n1. 罚函数法下狄利克雷边界实施的准确性：计算边界失配比\n$$\\rho = \\frac{|u_h(0)|}{\\|u_h\\|_{L^2(0,L)}},\\quad \\|u_h\\|_{L^2(0,L)} = \\sqrt{u_h^\\top M u_h},$$\n其中 $u_h$ 是对采用罚函数法实施狄利克雷边界条件的强制泊松问题计算出的有限元解。\n2. 基模的色散误差：计算相对特征值误差\n$$\\epsilon = \\frac{|\\lambda_h - \\lambda_{\\text{exact}}|}{\\lambda_{\\text{exact}}},\\quad \\lambda_{\\text{exact}} = \\left(\\frac{\\pi}{2L}\\right)^2,$$\n对于在 $x=0$ 处为狄利克雷条件、在 $x=L$ 处为诺伊曼条件的拉普拉斯算子广义特征值问题的最小特征值。\n\n实现要求：\n- 通过求解参考单元 $[-1,1]$ 上等距节点的范德蒙德系统，在每个单元上构建次数为 $r$ 的拉格朗日基函数，并使用足够阶数的高斯-勒让德求积法来精确积分至多项式次数 $2r$。\n- 使用从参考单元到物理单元的映射来组装全局刚度矩阵和质量矩阵。\n- 对于用于评估边界实施的强制泊松问题，设置源项 $s(x) = \\exp\\!\\left(-\\left(\\frac{x - 0.7 L}{0.1 L}\\right)^2\\right)$，此项为无量纲，并添加罚函数项，其系数为 $\\alpha = \\sigma / h$，其中 $h = L/N_e$ 是单元长度，$\\sigma$ 是无量纲的罚函数强度。\n- 对于特征值问题，通过消除 $x=0$ 处的边界自由度来强施加狄利克雷边界条件。\n\n单位与常数：\n- 使用 $L = 1$ 米。所有计算出的 $\\rho$ 和 $\\epsilon$ 量均为无量纲，因此最终答案中无需单位转换。\n\n测试套件：\n计算以下六个案例，以评估高阶拉格朗日单元对狄利克雷边界实施准确性和色散误差的影响。\n- 案例A（边界实施，理想情况）：$(r=1, N_e=32, \\sigma=10^3)$ 计算 $\\rho$。\n- 案例B（边界实施，高阶）：$(r=3, N_e=32, \\sigma=10^3)$ 计算 $\\rho$。\n- 案例C（边界实施，弱罚函数边界情况）：$(r=2, N_e=32, \\sigma=50)$ 计算 $\\rho$。\n- 案例D（色散误差，低阶）：$(r=1, N_e=10)$ 计算最小特征值的 $\\epsilon$。\n- 案例E（色散误差，中阶）：$(r=2, N_e=10)$ 计算最小特征值的 $\\epsilon$。\n- 案例F（色散误差，高阶）：$(r=3, N_e=10)$ 计算最小特征值的 $\\epsilon$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按以下顺序排列的结果，格式为方括号内的逗号分隔列表：\n$[\\rho_{A}, \\rho_{B}, \\rho_{C}, \\epsilon_{D}, \\epsilon_{E}, \\epsilon_{F}]$。\n\n运行时不提供任何输入；所有参数必须包含在程序中。程序必须能够在任何符合指定执行环境的现代 Python 环境中直接运行。",
            "solution": "用户提供的问题经评估为**有效**。这是一个在计算声学领域内提法恰当、有科学依据的问题陈述，为一个一维有限元分析指定了完整的方程组、边界条件、参数和评估指标。\n\n### 1. 理论框架\n该问题旨在求解域 $\\Omega = [0, L]$ 上的一维标量亥姆霍兹方程的数值解，方程如下\n$$ \\frac{d^2 p}{dx^2} + k^2 p = -s(x) $$\n其中 $p(x)$ 是声压，$k$ 是波数，$s(x)$ 是源项。$x=0$ 处的边界条件为压力释放（声软）狄利克雷条件 $p(0)=0$，$x=L$ 处的边界条件为刚性诺伊曼条件 $\\frac{dp}{dx}(L)=0$。\n\n有限元方法（FEM）基于控制偏微分方程的弱（变分）形式。为推导弱形式，我们将方程乘以一个来自合适函数空间的测试函数 $v(x)$，并在域 $\\Omega$ 上积分。\n\n对于相关的拉普拉斯特征值问题 $-\\frac{d^2 p}{dx^2} = \\lambda p$，其弱形式可通过分部积分得到：\n$$ -\\int_0^L \\frac{d^2 p}{dx^2} v \\,dx = \\lambda \\int_0^L p v \\,dx $$\n$$ \\left[ -\\frac{dp}{dx} v \\right]_0^L + \\int_0^L \\frac{dp}{dx} \\frac{dv}{dx} \\,dx = \\lambda \\int_0^L p v \\,dx $$\n测试函数 $v$ 选自满足齐次本质边界条件的函数空间，因此 $v(0)=0$。诺伊曼条件 $\\frac{dp}{dx}(L)=0$ 使得 $x=L$ 处的边界项消失。由于 $v(0)=0$，$x=0$ 处的边界项也消失。这导出了问题中提供的弱形式：找到 $p$，使得对于所有有效的 $v$ 都满足，\n$$ \\int_0^L \\frac{dp}{dx} \\frac{dv}{dx} \\,dx = \\lambda \\int_0^L p v \\,dx $$\n其中 $\\lambda = k^2$。\n\n类似地，对于受相同边界条件约束的强制泊松问题 $-\\frac{d^2 u}{dx^2} = s(x)$，其弱形式为：找到 $u$，使得对于所有有效的 $v$ 都满足，\n$$ \\int_0^L \\frac{du}{dx} \\frac{dv}{dx} \\,dx = \\int_0^L s v \\,dx $$\n在这两种情况下，$x=L$ 处的诺伊曼条件都是自然边界条件，由弱形式自动满足。\n\n### 2. 有限元离散化\n域 $[0, L]$ 被离散化为 $N_e$ 个长度均匀为 $h = L/N_e$ 的单元。在每个单元内，解由多项式次数为 $r$ 的拉格朗日基函数的线性组合来近似。近似解 $u_h(x)$ 写为：\n$$ u_h(x) = \\sum_{j=1}^{N_{dof}} u_j \\phi_j(x) $$\n其中 $u_j$ 是未知的节点值（自由度），$\\phi_j(x)$ 是全局基函数。它们是通过将在参考单元（通常为 $\\xi \\in [-1, 1]$）上定义的局部拉格朗日多项式拼接起来而构造的。对于一个次数为 $r$ 的多项式，参考单元上有 $r+1$ 个节点。我们使用等距节点 $\\xi_i = -1 + 2i/r$，$i=0, 1, \\dots, r$。第 $j$ 个拉格朗日基多项式 $L_j(\\xi)$ 具有属性 $L_j(\\xi_k) = \\delta_{jk}$，其中 $\\delta_{jk}$ 是克罗内克δ。\n\n将解（$p_h$ 或 $u_h$）和测试函数（$v_h$）的有限元近似代入弱形式，将积分方程转换为线性代数方程组。这就得到了特征值问题的矩阵形式 $K u = \\lambda M u$ 和泊松问题的矩阵形式 $K u = f$。\n\n### 3. 矩阵组装\n全局刚度矩阵 $K$、质量矩阵 $M$ 和载荷向量 $f$ 是通过对每个单元的贡献求和来组装的。对于跨越 $[x_e, x_{e+1}]$ 的单个单元 $e$，从物理坐标 $x$ 到参考坐标 $\\xi$ 的变量变换为 $x(\\xi) = x_e + \\frac{h}{2}(1+\\xi)$。此变换的雅可比行列式为 $J = \\frac{dx}{d\\xi} = \\frac{h}{2}$。导数变换为 $\\frac{d}{dx} = \\frac{1}{J}\\frac{d}{d\\xi}$。\n\n单元矩阵和向量使用数值求积法计算。使用 $n_p = r+1$ 个点的高斯-勒让德求积法，它可以精确积分最高次数为 $2(r+1)-1 = 2r+1$ 的多项式，满足了对 $2r$ 次多项式的要求。\n- **单元刚度矩阵 $K_e$**：\n  $$ (K_e)_{ij} = \\int_{x_e}^{x_{e+1}} \\frac{d\\phi_i}{dx}\\frac{d\\phi_j}{dx}\\,dx = \\int_{-1}^1 \\left(\\frac{1}{J}\\frac{d\\phi_i}{d\\xi}\\right) \\left(\\frac{1}{J}\\frac{d\\phi_j}{d\\xi}\\right) J\\,d\\xi = \\frac{1}{J} \\sum_{k=1}^{n_p} w_k \\frac{d\\phi_i}{d\\xi}(\\xi_k) \\frac{d\\phi_j}{d\\xi}(\\xi_k) $$\n- **单元质量矩阵 $M_e$**：\n  $$ (M_e)_{ij} = \\int_{x_e}^{x_{e+1}} \\phi_i \\phi_j \\,dx = \\int_{-1}^1 \\phi_i(\\xi) \\phi_j(\\xi) J\\,d\\xi = J \\sum_{k=1}^{n_p} w_k \\phi_i(\\xi_k) \\phi_j(\\xi_k) $$\n- **单元载荷向量 $f_e$**：\n  $$ (f_e)_i = \\int_{x_e}^{x_e+1} s(x)\\phi_i(x)\\,dx = \\int_{-1}^1 s(x(\\xi))\\phi_i(\\xi) J\\,d\\xi = J \\sum_{k=1}^{n_p} w_k s(x(\\xi_k)) \\phi_i(\\xi_k) $$\n在这里，$w_k$ 和 $\\xi_k$ 是高斯-勒让德权重和点。这些单元级别的贡献随后被映射到它们对应的全局自由度上，并相加以形成全局系统。总自由度数为 $N_{dof} = N_e \\times r + 1$。\n\n### 4. 边界条件实施与求解\n\n**特征值问题（色散误差 $\\epsilon$）：**\n狄利克雷条件 $p(0)=0$ 被强施加。由于第一个自由度 $u_0$ 对应于 $x=0$ 处的解，因此通过从全局矩阵 $K$ 和 $M$ 中移除第一行和第一列来施加此条件。得到的广义特征值问题是：\n$$ K_{\\text{mod}} u_{\\text{mod}} = \\lambda M_{\\text{mod}} u_{\\text{mod}} $$\n该系统使用广义特征求解器（如 `scipy.linalg.eigh`）进行求解。得到的最小特征值 $\\lambda_h$ 是连续问题的基频特征值的数值近似。在 $[0, L]$ 上混合边界条件下的精确特征值为 $\\lambda_{\\text{exact}} = (\\frac{\\pi}{2L})^2$。然后相对误差 $\\epsilon$ 计算如下：\n$$ \\epsilon = \\frac{|\\lambda_h - \\lambda_{\\text{exact}}|}{\\lambda_{\\text{exact}}} $$\n\n**泊松问题（边界实施 $\\rho$）：**\n狄利克雷条件 $u(0)=0$ 使用罚函数法弱施加。这涉及用项 $\\alpha u(0) v(0)$ 来增强双线性形式 $\\int \\frac{du}{dx}\\frac{dv}{dx}dx$，其中 $\\alpha = \\sigma/h$ 是一个大的罚参数。在矩阵系统中，这对应于将 $\\alpha$ 加到与 $x=0$ 处自由度相关的刚度矩阵的对角线元素上。修改后的系统为：\n$$ (K + \\alpha B) u = f $$\n其中 $B$ 是一个只有一个非零项 $B_{00}=1$ 的矩阵。求解此线性系统得到系数向量 $u_h$ 后，计算边界失配比 $\\rho$。边界处的解值为 $u_h(0) = u_0$。$L^2$-范数为 $\\|u_h\\|_{L^2} = \\sqrt{u_h^\\top M u_h}$。该比值为：\n$$ \\rho = \\frac{|u_h(0)|}{\\|u_h\\|_{L^2(0,L)}} = \\frac{|u_0|}{\\sqrt{u_h^\\top M u_h}} $$\n该度量量化了相对于解的整体大小，狄利克雷条件被满足的程度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef get_lagrange_basis(r):\n    \"\"\"\n    Generates Lagrange basis polynomials and their derivatives of degree r\n    on the reference element [-1, 1] with equidistant nodes.\n    \n    This function uses Lagrange's formula for polynomial construction, which can be\n    more stable than inverting a Vandermonde matrix.\n    \n    Returns:\n        tuple: A list of np.poly1d objects for the basis functions and a list of\n               np.poly1d objects for their derivatives.\n    \"\"\"\n    nodes_ref = np.linspace(-1, 1, r + 1)\n    \n    basis_polys = []\n    for j in range(r + 1):\n        # Numerator is a polynomial that is zero at all nodes except nodes_ref[j]\n        num_poly = np.poly1d([1.0])\n        for k in range(r + 1):\n            if k == j:\n                continue\n            num_poly *= np.poly1d([1.0, -nodes_ref[k]])\n        \n        # Denominator is a normalizing constant\n        den_val = num_poly(nodes_ref[j])\n            \n        basis_polys.append(num_poly / den_val)\n        \n    basis_derivs = [np.polyder(p) for p in basis_polys]\n    \n    return basis_polys, basis_derivs\n\ndef assemble_matrices(r, Ne, L, basis_polys, basis_derivs):\n    \"\"\"\n    Assembles global stiffness (K) and mass (M) matrices for a 1D problem\n    on [0, L] with Ne elements of polynomial degree r.\n    \"\"\"\n    h = L / Ne\n    n_dof = r * Ne + 1\n    \n    K = np.zeros((n_dof, n_dof))\n    M = np.zeros((n_dof, n_dof))\n    \n    # Gauss-Legendre quadrature: n_gauss points integrates polynomials up to degree 2*n_gauss - 1.\n    # To integrate K (degree 2r-2) and M (degree 2r), we need 2*n_gauss - 1 >= 2r,\n    # so n_gauss >= (2r+1)/2. Choosing n_gauss = r + 1 is sufficient.\n    n_gauss = r + 1\n    gauss_pts, gauss_wts = np.polynomial.legendre.leggauss(n_gauss)\n    \n    # Evaluate basis functions and derivatives at Gauss points on reference element\n    phi_vals = np.array([p(gauss_pts) for p in basis_polys])\n    dphi_dxi_vals = np.array([d(gauss_pts) for d in basis_derivs])\n    \n    # Calculate local (element) matrices on the reference element [-1, 1]\n    # Ke_ref_ij = integral(dphi_i/dxi * dphi_j/dxi dxi)\n    # Me_ref_ij = integral(phi_i * phi_j dxi)\n    Ke_ref = np.einsum('ik,jk,k->ij', dphi_dxi_vals, dphi_dxi_vals, gauss_wts)\n    Me_ref = np.einsum('ik,jk,k->ij', phi_vals, phi_vals, gauss_wts)\n    \n    # Jacobian of transformation: x(xi) = x_e + h/2 * (1 + xi) -> J = dx/dxi = h/2\n    J = h / 2.0\n    \n    # Scale reference matrices to physical element size\n    # Ke = (1/J) * Ke_ref, Me = J * Me_ref\n    Ke_elem = (1.0 / J) * Ke_ref\n    Me_elem = J * Me_ref\n    \n    # Assemble global matrices by looping over elements\n    for e in range(Ne):\n        # Global indices for DOFs in element e\n        indices = np.arange(e * r, e * r + r + 1)\n        ix = np.ix_(indices, indices)\n        K[ix] += Ke_elem\n        M[ix] += Me_elem\n        \n    return K, M\n\ndef compute_rho(r, Ne, sigma, L):\n    \"\"\"Computes the boundary mismatch ratio rho for the forced Poisson problem.\"\"\"\n    h = L / Ne\n    alpha = sigma / h\n    n_dof = r * Ne + 1\n    \n    basis_polys, basis_derivs = get_lagrange_basis(r)\n    K, M = assemble_matrices(r, Ne, L, basis_polys, basis_derivs)\n    \n    # Assemble load vector f\n    f = np.zeros(n_dof)\n    J = h / 2.0\n    \n    # Use quadrature order consistent with mass matrix for source term integration\n    n_gauss = r + 1\n    gauss_pts, gauss_wts = np.polynomial.legendre.leggauss(n_gauss)\n    phi_vals_at_gauss = np.array([p(gauss_pts) for p in basis_polys])\n\n    def source_func(x_phys):\n        return np.exp(-((x_phys - 0.7 * L) / (0.1 * L))**2)\n\n    for e in range(Ne):\n        x_e_start = e * h\n        x_phys_at_gauss = x_e_start + J * (1.0 + gauss_pts)\n        s_vals = source_func(x_phys_at_gauss)\n        \n        # fe_i = integral_e s(x) * phi_i(x) dx = J * integral(s(x(xi)) * phi_i(xi) dxi)\n        fe = J * np.einsum('ik,k,k->i', phi_vals_at_gauss, s_vals, gauss_wts)\n        \n        indices = np.arange(e * r, e * r + r + 1)\n        f[indices] += fe\n        \n    A = K.copy()\n    A[0, 0] += alpha\n    \n    u_h = linalg.solve(A, f)\n    \n    u_h_at_0 = u_h[0]\n    norm_L2_sq = u_h.T @ M @ u_h\n    \n    if norm_L2_sq = 0:\n        return 0.0\n    \n    rho_val = np.abs(u_h_at_0) / np.sqrt(norm_L2_sq)\n    return rho_val\n\ndef compute_epsilon(r, Ne, L):\n    \"\"\"Computes the relative eigenvalue error epsilon for the fundamental mode.\"\"\"\n    basis_polys, basis_derivs = get_lagrange_basis(r)\n    K, M = assemble_matrices(r, Ne, L, basis_polys, basis_derivs)\n    \n    # Apply strong Dirichlet BC at x=0 by removing the first row and column\n    K_mod = K[1:, 1:]\n    M_mod = M[1:, 1:]\n    \n    # Solve the generalized eigenvalue problem. Use eigh for symmetric matrices.\n    eigenvalues = linalg.eigh(K_mod, M_mod, eigvals_only=True)\n    lambda_h = eigenvalues[0] # eigh returns sorted eigenvalues\n    \n    lambda_exact = (np.pi / (2 * L))**2\n    \n    epsilon_val = np.abs(lambda_h - lambda_exact) / lambda_exact\n    return epsilon_val\n\ndef solve():\n    \"\"\"Main solver function to run all test cases.\"\"\"\n    L = 1.0\n\n    test_cases = [\n        # type, r, Ne, sigma (for rho) or None (for epsilon)\n        ('rho', 1, 32, 1000.0),  # Case A\n        ('rho', 3, 32, 1000.0),  # Case B\n        ('rho', 2, 32, 50.0),    # Case C\n        ('epsilon', 1, 10, None),# Case D\n        ('epsilon', 2, 10, None),# Case E\n        ('epsilon', 3, 10, None),# Case F\n    ]\n\n    results = []\n    for case_type, r, Ne, sigma in test_cases:\n        if case_type == 'rho':\n            result = compute_rho(r=r, Ne=Ne, sigma=sigma, L=L)\n        elif case_type == 'epsilon':\n            result = compute_epsilon(r=r, Ne=Ne, L=L)\n        else:\n            raise ValueError(f\"Unknown case type: {case_type}\")\n        results.append(result)\n\n    print(f\"[{','.join(f'{res:.6e}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}