{
    "hands_on_practices": [
        {
            "introduction": "本实践探讨了最简单的声源——单极子源的基本特性。通过分析声源附近的能量密度，我们可以区分出传播到远场的能量（我们听到的声音）和仅在近场局部存储和交换的能量。理解这种无功能量和有功能量之间的区别，对于声学理论和换能器设计等实际应用都至关重要。该练习为球面波在其源点附近的行为提供了一个具体的解析模型。",
            "id": "4134631",
            "problem": "考虑一个位于无界、均匀、无粘、无损耗流体原点的时谐声单极子源，该流体的恒定平衡质量密度为 $\\rho_0$，声速为 $c$。该源以角频率 $\\omega$ 注入流体，复体积速度振幅为 $Q_0$，时间依赖关系为 $\\exp(-i\\omega t)$。假设产生的场是球对称且向外传播的。\n\n从线性化动量方程（欧拉方程）和线性化连续性方程，以及联系压强扰动 $p$ 和密度扰动 $\\rho'$ 的线性状态方程 $p=c^2\\rho'$ 出发，推导控制声压 $p(\\mathbf{x})$ 的非齐次亥姆霍兹方程，该方程应包含适用于给定单极子的点源项。使用三维自由空间格林函数求解复压强振幅 $p(r)$，然后使用线性化动量方程获得径向质点速度振幅 $u_r(r)$。\n\n对于小振幅时谐场，时间平均势（压缩）能密度 $\\langle w_p(r)\\rangle$ 和动能密度 $\\langle w_k(r)\\rangle$ 定义为\n$$\n\\langle w_p(r)\\rangle = \\frac{|p(r)|^2}{4\\,\\rho_0 c^2}, \n\\qquad\n\\langle w_k(r)\\rangle = \\frac{\\rho_0\\,|u_r(r)|^2}{4}.\n$$\n将抗性声能密度定义为\n$$\nw_{\\mathrm{re}}(r) = \\langle w_p(r)\\rangle - \\langle w_k(r)\\rangle.\n$$\n将 $w_{\\mathrm{re}}(r)$ 显式地计算为一个由 $r$、$\\rho_0$、$Q_0$ 和基本常数构成的闭合形式函数，并根据源近场中存储的振荡能量解释其物理意义。用焦耳每立方米 (J/m$^3$) 表示你对 $w_{\\mathrm{re}}(r)$ 的最终答案。没有给出数值；请提供精确的解析表达式。无需四舍五入。",
            "solution": "该问题要求推导和计算时谐单极子源的抗性声能密度。这是基础声学中的一个有效问题。\n\n该过程包括三个主要部分：\n1.  推导控制声压 $p$ 的非齐次亥姆霍兹方程。\n2.  求解复压强振幅 $p(r)$ 和径向质点速度振幅 $u_r(r)$。\n3.  计算时间平均能量密度和抗性能量密度 $w_{\\mathrm{re}}(r)$。\n\n**第一部分：非齐次亥姆霍兹方程的推导**\n\n我们从无粘、无损耗流体的线性化流体动力学方程开始，假设时间依赖关系为 $\\exp(-i\\omega t)$。这意味着时间导数算子可以被替换为乘以 $-i\\omega$。\n\n线性化动量方程（欧拉方程）为：\n$$\n\\rho_0 \\frac{\\partial \\mathbf{u}}{\\partial t} = -\\nabla p\n$$\n对于具有复振幅 $\\mathbf{u}(\\mathbf{x})$ 和 $p(\\mathbf{x})$ 的时谐场，该方程变为：\n$$\n-i\\omega \\rho_0 \\mathbf{u} = -\\nabla p \\implies \\mathbf{u} = \\frac{1}{i\\omega \\rho_0} \\nabla p\n\\quad (1)\n$$\n其中 $\\rho_0$ 是平衡流体密度，$\\mathbf{u}$ 是质点速度矢量， $p$ 是声压扰动。\n\n线性化连续性方程，包括一个在原点以体积速度 $Q(t) = Q_0 \\exp(-i\\omega t)$ 注入流体的单极子源，其形式为：\n$$\n\\frac{\\partial \\rho'}{\\partial t} + \\rho_0 \\nabla \\cdot \\mathbf{u} = \\rho_0 Q(t) \\delta(\\mathbf{x})\n$$\n其中 $\\rho'$ 是密度扰动，$\\delta(\\mathbf{x})$ 是三维狄拉克δ函数。对于时谐场，该方程变为：\n$$\n-i\\omega \\rho' + \\rho_0 \\nabla \\cdot \\mathbf{u} = \\rho_0 Q_0 \\delta(\\mathbf{x})\n\\quad (2)\n$$\n\n线性状态方程联系了压强和密度扰动：\n$$\np = c^2 \\rho' \\implies \\rho' = \\frac{p}{c^2}\n\\quad (3)\n$$\n其中 $c$ 是声速。\n\n我们可以结合这三个方程来找到一个关于压强 $p$ 的单一方程。首先，将方程(3)代入方程(2)：\n$$\n-i\\omega \\frac{p}{c^2} + \\rho_0 \\nabla \\cdot \\mathbf{u} = \\rho_0 Q_0 \\delta(\\mathbf{x})\n$$\n接下来，将方程(1)中 $\\mathbf{u}$ 的表达式代入这个修改后的连续性方程：\n$$\n-i\\omega \\frac{p}{c^2} + \\rho_0 \\nabla \\cdot \\left(\\frac{1}{i\\omega \\rho_0} \\nabla p\\right) = \\rho_0 Q_0 \\delta(\\mathbf{x})\n$$\n常数项 $\\rho_0$ 和 $1/(i\\omega)$ 可以移到散度算子之外：\n$$\n-i\\omega \\frac{p}{c^2} + \\frac{1}{i\\omega} \\nabla^2 p = \\rho_0 Q_0 \\delta(\\mathbf{x})\n$$\n将整个方程乘以 $i\\omega$ 得到：\n$$\n(-i\\omega)^2 \\frac{p}{c^2} + \\nabla^2 p = i\\omega \\rho_0 Q_0 \\delta(\\mathbf{x})\n$$\n$$\n-\\omega^2 \\frac{p}{c^2} + \\nabla^2 p = i\\omega \\rho_0 Q_0 \\delta(\\mathbf{x})\n$$\n引入波数 $k = \\omega/c$，我们得到声压的非齐次亥姆霍兹方程：\n$$\n\\nabla^2 p + k^2 p = i\\omega \\rho_0 Q_0 \\delta(\\mathbf{x})\n\\quad (4)\n$$\n\n**第二部分：压强和质点速度的求解**\n\n方程(4)的解可以使用亥姆霍兹算子的自由空间格林函数找到。格林函数 $G(\\mathbf{x}|\\mathbf{x}')$ 是满足索末菲辐射条件（代表向外传播的波）的方程 $(\\nabla^2 + k^2)G = -\\delta(\\mathbf{x}-\\mathbf{x}')$ 的解。在三维空间中，它是：\n$$\nG(\\mathbf{x}|\\mathbf{x}') = \\frac{\\exp(ik|\\mathbf{x}-\\mathbf{x}'|)}{4\\pi|\\mathbf{x}-\\mathbf{x}'|}\n$$\n形如 $(\\nabla^2 + k^2)\\psi = -F(\\mathbf{x})$ 的方程的解由卷积 $\\psi(\\mathbf{x}) = \\int G(\\mathbf{x}|\\mathbf{x}') F(\\mathbf{x}') dV'$ 给出。\n在我们的例子中，源项是 $F(\\mathbf{x}) = -i\\omega \\rho_0 Q_0 \\delta(\\mathbf{x})$。源位于原点（$\\mathbf{x}' = 0$），我们有：\n$$\np(\\mathbf{x}) = \\int \\frac{\\exp(ik|\\mathbf{x}-\\mathbf{x}'|)}{4\\pi|\\mathbf{x}-\\mathbf{x}'|} \\left( -i\\omega \\rho_0 Q_0 \\delta(\\mathbf{x}') \\right) dV'\n$$\n利用δ函数计算该积分得到：\n$$\np(\\mathbf{x}) = -i\\omega \\rho_0 Q_0 \\frac{\\exp(ik|\\mathbf{x}|)}{4\\pi|\\mathbf{x}|}\n$$\n对于球对称场，我们使用径向坐标 $r=|\\mathbf{x}|$。复压强振幅为：\n$$\np(r) = -\\frac{i\\omega \\rho_0 Q_0}{4\\pi r} \\exp(ikr)\n\\quad (5)\n$$\n接下来，我们使用方程(1)求径向质点速度 $u_r(r)$。对于球对称场，$\\nabla p = \\frac{\\partial p}{\\partial r} \\hat{\\mathbf{r}}$，所以 $u_r(r) = \\frac{1}{i\\omega \\rho_0} \\frac{\\partial p}{\\partial r}$。\n$$\n\\frac{\\partial p}{\\partial r} = -\\frac{i\\omega \\rho_0 Q_0}{4\\pi} \\frac{\\partial}{\\partial r}\\left(\\frac{\\exp(ikr)}{r}\\right) = -\\frac{i\\omega \\rho_0 Q_0}{4\\pi} \\left( \\frac{ik\\exp(ikr)}{r} - \\frac{\\exp(ikr)}{r^2} \\right)\n$$\n$$\n\\frac{\\partial p}{\\partial r} = -\\frac{i\\omega \\rho_0 Q_0}{4\\pi r} \\exp(ikr) \\left(ik - \\frac{1}{r}\\right) = p(r) \\left(ik-\\frac{1}{r}\\right)\n$$\n将此代入 $u_r(r)$ 的表达式中：\n$$\nu_r(r) = \\frac{p(r)}{i\\omega \\rho_0} \\left(ik - \\frac{1}{r}\\right) = \\frac{p(r)}{\\rho_0 c} \\left(1 - \\frac{1}{ikr}\\right) = \\frac{p(r)}{\\rho_0 c} \\left(1 + \\frac{i}{kr}\\right)\n$$\n代入方程(5)中 $p(r)$ 的表达式，得到一个更明确的 $u_r(r)$ 形式：\n$$\nu_r(r) = \\left(-\\frac{i\\omega \\rho_0 Q_0}{4\\pi r} \\exp(ikr)\\right) \\frac{1}{i\\omega \\rho_0} \\left(ik - \\frac{1}{r}\\right) = -\\frac{Q_0}{4\\pi r} \\exp(ikr) \\left(ik - \\frac{1}{r}\\right)\n$$\n$$\nu_r(r) = \\frac{Q_0}{4\\pi r^2} \\exp(ikr)(1 - ikr)\n\\quad (6)\n$$\n\n**第三部分：抗性能量密度的计算**\n\n时间平均势能密度由 $\\langle w_p(r)\\rangle = \\frac{|p(r)|^2}{4\\rho_0 c^2}$ 给出。我们首先求 $|p(r)|^2$：\n$$\n|p(r)|^2 = \\left|-\\frac{i\\omega \\rho_0 Q_0}{4\\pi r} \\exp(ikr)\\right|^2 = \\frac{\\omega^2 \\rho_0^2 |Q_0|^2}{16\\pi^2 r^2} |-i|^2 |\\exp(ikr)|^2 = \\frac{\\omega^2 \\rho_0^2 |Q_0|^2}{16\\pi^2 r^2}\n$$\n因此，势能密度为：\n$$\n\\langle w_p(r) \\rangle = \\frac{1}{4\\rho_0 c^2} \\frac{\\omega^2 \\rho_0^2 |Q_0|^2}{16\\pi^2 r^2} = \\frac{\\omega^2 \\rho_0 |Q_0|^2}{64\\pi^2 c^2 r^2} = \\frac{k^2 \\rho_0 |Q_0|^2}{64\\pi^2 r^2}\n\\quad (7)\n$$\n时间平均动能密度由 $\\langle w_k(r)\\rangle = \\frac{\\rho_0 |u_r(r)|^2}{4}$ 给出。我们首先求 $|u_r(r)|^2$：\n$$\n|u_r(r)|^2 = \\left|\\frac{Q_0}{4\\pi r^2} \\exp(ikr)(1 - ikr)\\right|^2 = \\frac{|Q_0|^2}{16\\pi^2 r^4} |\\exp(ikr)|^2 |1 - ikr|^2\n$$\n因为 $|1 - ikr|^2 = 1^2 + (-kr)^2 = 1 + k^2r^2$，我们有：\n$$\n|u_r(r)|^2 = \\frac{|Q_0|^2 (1 + k^2r^2)}{16\\pi^2 r^4}\n$$\n动能密度为：\n$$\n\\langle w_k(r) \\rangle = \\frac{\\rho_0}{4} \\frac{|Q_0|^2 (1 + k^2r^2)}{16\\pi^2 r^4} = \\frac{\\rho_0 |Q_0|^2 (1 + k^2r^2)}{64\\pi^2 r^4}\n\\quad (8)\n$$\n抗性声能密度定义为 $w_{\\mathrm{re}}(r) = \\langle w_p(r)\\rangle - \\langle w_k(r)\\rangle$。代入方程(7)和(8)：\n$$\nw_{\\mathrm{re}}(r) = \\frac{k^2 \\rho_0 |Q_0|^2}{64\\pi^2 r^2} - \\frac{\\rho_0 |Q_0|^2 (1 + k^2r^2)}{64\\pi^2 r^4}\n$$\n为了合并这些项，我们使用公分母 $64\\pi^2 r^4$：\n$$\nw_{\\mathrm{re}}(r) = \\frac{\\rho_0 |Q_0|^2}{64\\pi^2 r^4} \\left[ (k^2r^2) - (1 + k^2r^2) \\right]\n$$\n$$\nw_{\\mathrm{re}}(r) = \\frac{\\rho_0 |Q_0|^2}{64\\pi^2 r^4} [k^2r^2 - 1 - k^2r^2] = \\frac{\\rho_0 |Q_0|^2}{64\\pi^2 r^4} (-1)\n$$\n抗性能量密度的最终表达式为：\n$$\nw_{\\mathrm{re}}(r) = -\\frac{\\rho_0 |Q_0|^2}{64\\pi^2 r^4}\n$$\n\n**物理意义：**\n抗性能量密度 $w_{\\mathrm{re}}(r)$ 代表声能场中局部的、非传播的分量。它量化了时间平均势能密度和动能密度之间的不平衡。\n- 在远场（$kr \\gg 1$）中，我们有 $\\langle w_p \\rangle \\approx \\langle w_k \\rangle$，所以 $w_{\\mathrm{re}}(r) \\to 0$。这表示一个传播波，其中能量在势能和动能形式之间均等分配，能量向外流动而不会被局部储存。\n- 在近场（$kr \\ll 1$）中，动能密度 $\\langle w_k \\rangle \\propto 1/r^4$ 远大于势能密度 $\\langle w_p \\rangle \\propto k^2/r^2$。因此，$w_{\\mathrm{re}}(r) = \\langle w_p \\rangle - \\langle w_k \\rangle \\approx -\\langle w_k \\rangle$。抗性能量很大且为负值，表明动能占主导地位。\n这个巨大的动能对应于紧邻脉动源的流体质量的“晃动”运动。这种运动不能有效地产生传播所需的压缩和稀疏。相反，它代表了在周期的某一部分储存在流体惯性中、在另一部分返回到声源的能量，非常类似于交流电路中电感器磁场中储存的能量。这个以储存的动能为主的区域被称为抗性近场。",
            "answer": "$$\n\\boxed{-\\frac{\\rho_0 |Q_0|^2}{64\\pi^2 r^4}}\n$$"
        },
        {
            "introduction": "从连续的解析模型转向离散的计算世界，会不可避免地引入误差。本实践旨在解决其中最重要的一种：有限差分时域 (FDTD) 模拟中的数值色散。您将推导出离散网格如何导致平面波的传播速度依赖于其频率和相对于网格轴线的方向，这种现象在真实物理世界中并不存在。量化这种相位误差是评估数值波模拟准确性的基本技能。",
            "id": "4134634",
            "problem": "考虑均匀介质中的二维线性声波方程，\n$$\\frac{\\partial^2 p}{\\partial t^2} = c^2 \\left( \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} \\right),$$\n其中 $p$ 是声压场，$c$ 是声速。在空间步长为 $\\Delta x$ 和 $\\Delta y$、时间步长为 $\\Delta t$ 的均匀笛卡尔网格上，使用标准的二阶中心有限差分在空间和时间上近似二阶导数。这得到了显式的二阶有限差分格式\n$$\\frac{p_{i,j}^{n+1} - 2 p_{i,j}^{n} + p_{i,j}^{n-1}}{\\Delta t^2} = c^2 \\left( \\frac{p_{i+1,j}^{n} - 2 p_{i,j}^{n} + p_{i-1,j}^{n}}{\\Delta x^2} + \\frac{p_{i,j+1}^{n} - 2 p_{i,j}^{n} + p_{i,j-1}^{n}}{\\Delta y^2} \\right),$$\n其中 $i$ 和 $j$ 是空间网格的索引，$n$ 是时间的索引。从线性声波方程及其上述离散近似出发，通过代入以下形式的离散平面波来进行平面波分析\n$$p_{i,j}^{n} = A \\exp\\left( \\mathrm{i} \\left( k_x i \\Delta x + k_y j \\Delta y - \\omega n \\Delta t \\right) \\right),$$\n其中 $A$ 是一个常数振幅，$k_x$ 和 $k_y$ 是波数矢量 $\\mathbf{k}$ 的笛卡尔分量，其大小为 $|\\mathbf{k}| = k$，而 $\\omega$ 是角频率。推导此格式的离散色散关系 $\\omega(\\mathbf{k})$。使用角频率的主支，使得 $0 \\le \\omega \\Delta t \\le \\pi$。\n\n使用推导出的 $\\omega(\\mathbf{k})$，定义数值相速度 $c_{\\mathrm{num}} = \\omega / k$。通过计算相对误差来量化与角度相关的相速度误差\n$$\\varepsilon = \\frac{c_{\\mathrm{num}}}{c} - 1,$$\n以小数形式表示（例如，5% 的误差必须报告为 0.05）。角度必须以弧度表示。所有物理量必须使用国际标准（SI）单位处理：米（$\\mathrm{m}$）、秒（$\\mathrm{s}$）和弧度（$\\mathrm{rad}$）。\n\n您的程序必须实现推导出的离散色散关系，并为以下每个测试用例评估 $\\varepsilon$。对于指定了 Courant 数的情况，对于各向同性网格（$\\Delta x = \\Delta y$），使用关系式 $\\Delta t = S \\Delta x / c$，对于各向异性网格，使用 $\\Delta t = S_x \\Delta x / c$（这意味着有效的 $S_y = c \\Delta t / \\Delta y$）。确保这些选择隐式地遵守了稳定性条件。\n\n测试套件参数集（每个用例指定 $(c, \\Delta x, \\Delta y, \\Delta t, k, \\theta)$，其中 $\\theta$ 是从 $x$ 轴测量的传播角度）：\n- 用例 1：$c = 343\\,\\mathrm{m/s}$，$\\Delta x = 0.01\\,\\mathrm{m}$，$\\Delta y = 0.01\\,\\mathrm{m}$，$S = 0.7$，因此 $\\Delta t = S \\Delta x / c$，$k = 200\\,\\mathrm{rad/m}$，$\\theta = 0$。\n- 用例 2：$c = 343\\,\\mathrm{m/s}$，$\\Delta x = 0.01\\,\\mathrm{m}$，$\\Delta y = 0.01\\,\\mathrm{m}$，$S = 0.7$，因此 $\\Delta t = S \\Delta x / c$，$k = 200\\,\\mathrm{rad/m}$，$\\theta = \\pi/4$。\n- 用例 3：$c = 343\\,\\mathrm{m/s}$，$\\Delta x = 0.01\\,\\mathrm{m}$，$\\Delta y = 0.01\\,\\mathrm{m}$，$S = 0.7$，因此 $\\Delta t = S \\Delta x / c$，$k = 10\\,\\mathrm{rad/m}$，$\\theta = \\pi/8$。\n- 用例 4：$c = 343\\,\\mathrm{m/s}$，$\\Delta x = 0.01\\,\\mathrm{m}$，$\\Delta y = 0.01\\,\\mathrm{m}$，$S = 0.7$，因此 $\\Delta t = S \\Delta x / c$，$k = 0.95 \\pi / \\Delta x\\,\\mathrm{rad/m}$，$\\theta = \\pi/4$。\n- 用例 5：$c = 343\\,\\mathrm{m/s}$，$\\Delta x = 0.01\\,\\mathrm{m}$，$\\Delta y = 0.015\\,\\mathrm{m}$，$S_x = 0.6$，因此 $\\Delta t = S_x \\Delta x / c$，且 $S_y = c \\Delta t / \\Delta y$，$k = 180\\,\\mathrm{rad/m}$，$\\theta = \\pi/3$。\n- 用例 6：$c = 1500\\,\\mathrm{m/s}$，$\\Delta x = 0.02\\,\\mathrm{m}$，$\\Delta y = 0.02\\,\\mathrm{m}$，$S = 0.6$，因此 $\\Delta t = S \\Delta x / c$，$k = 80\\,\\mathrm{rad/m}$，$\\theta = \\pi/6$。\n\n您的程序应生成单行输出，其中包含这六个用例的相对相速度误差 $\\varepsilon$，形式为用方括号括起来的逗号分隔列表（例如，$[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4,\\varepsilon_5,\\varepsilon_6]$）。这些值必须是无量纲的小数（无百分号），并按上面列出的顺序排列。",
            "solution": "目标是为二维线性声波方程的二阶有限差分格式推导离散色散关系，并使用该关系来量化给定参数集的数值相速度误差。\n\n起点是均匀、无损耗介质中的二维线性声波方程：\n$$ \\frac{\\partial^2 p}{\\partial t^2} = c^2 \\left( \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} \\right) $$\n其中 $p(x,y,t)$ 是声压，$c$ 是恒定的声速。该方程在空间步长为 $\\Delta x$ 和 $\\Delta y$、时间步长为 $\\Delta t$ 的均匀笛卡尔网格上进行离散化。在网格点 $(i\\Delta x, j\\Delta y)$ 和时间 $n\\Delta t$ 处的压力表示为 $p_{i,j}^{n}$。对所有二阶导数使用二阶中心有限差分，我们得到显式时域有限差分（FDTD）格式：\n$$ \\frac{p_{i,j}^{n+1} - 2 p_{i,j}^{n} + p_{i,j}^{n-1}}{\\Delta t^2} = c^2 \\left( \\frac{p_{i+1,j}^{n} - 2 p_{i,j}^{n} + p_{i-1,j}^{n}}{\\Delta x^2} + \\frac{p_{i,j+1}^{n} - 2 p_{i,j}^{n} + p_{i,j-1}^{n}}{\\Delta y^2} \\right) $$\n\n为了进行平面波分析（也称为 von Neumann 分析），我们代入以下形式的离散平面波解，或称 ansatz：\n$$ p_{i,j}^{n} = A \\exp\\left( \\mathrm{i} \\left( k_x i \\Delta x + k_y j \\Delta y - \\omega n \\Delta t \\right) \\right) $$\n到数值格式中。这里，$A$ 是一个常数振幅，$k_x$ 和 $k_y$ 是波数矢量 $\\mathbf{k}$ 的笛卡尔分量，$\\omega$ 是角频率，$\\mathrm{i}$ 是虚数单位。\n\n代入 ansatz 需要计算在移位的网格点 $(i\\pm 1, j, n)$、$(i, j\\pm 1, n)$ 和 $(i, j, n\\pm 1)$ 处的压力：\n\\begin{itemize}\n    \\item $p_{i,j}^{n\\pm 1} = p_{i,j}^{n} \\exp(\\mp \\mathrm{i} \\omega \\Delta t)$\n    \\item $p_{i\\pm 1,j}^{n} = p_{i,j}^{n} \\exp(\\pm \\mathrm{i} k_x \\Delta x)$\n    \\item $p_{i,j\\pm 1}^{n} = p_{i,j}^{n} \\exp(\\pm \\mathrm{i} k_y \\Delta y)$\n\\end{itemize}\n将这些代入 FDTD 格式，并除以公共的非零因子 $p_{i,j}^{n}$：\n$$ \\frac{\\exp(-\\mathrm{i} \\omega \\Delta t) - 2 + \\exp(\\mathrm{i} \\omega \\Delta t)}{\\Delta t^2} = c^2 \\left( \\frac{\\exp(\\mathrm{i} k_x \\Delta x) - 2 + \\exp(-\\mathrm{i} k_x \\Delta x)}{\\Delta x^2} + \\frac{\\exp(\\mathrm{i} k_y \\Delta y) - 2 + \\exp(-\\mathrm{i} k_y \\Delta y)}{\\Delta y^2} \\right) $$\n使用欧拉公式 $\\exp(\\mathrm{i}\\phi) + \\exp(-\\mathrm{i}\\phi) = 2 \\cos(\\phi)$，方程简化为：\n$$ \\frac{2 \\cos(\\omega \\Delta t) - 2}{\\Delta t^2} = c^2 \\left( \\frac{2 \\cos(k_x \\Delta x) - 2}{\\Delta x^2} + \\frac{2 \\cos(k_y \\Delta y) - 2}{\\Delta y^2} \\right) $$\n接下来，我们使用半角恒等式 $1 - \\cos(\\phi) = 2 \\sin^2(\\phi/2)$：\n$$ \\frac{-4 \\sin^2(\\omega \\Delta t / 2)}{\\Delta t^2} = c^2 \\left( \\frac{-4 \\sin^2(k_x \\Delta x / 2)}{\\Delta x^2} + \\frac{-4 \\sin^2(k_y \\Delta y / 2)}{\\Delta y^2} \\right) $$\n消去公因子 $-4$ 得到：\n$$ \\frac{\\sin^2(\\omega \\Delta t / 2)}{\\Delta t^2} = c^2 \\left( \\frac{\\sin^2(k_x \\Delta x / 2)}{\\Delta x^2} + \\frac{\\sin^2(k_y \\Delta y / 2)}{\\Delta y^2} \\right) $$\n为了求解 $\\omega$，我们首先分离出 $\\sin(\\omega \\Delta t / 2)$。问题指定使用 $\\omega$ 的主支，使得 $0 \\le \\omega \\Delta t \\le \\pi$。这意味着 $0 \\le \\omega \\Delta t / 2 \\le \\pi/2$，在此区间 $\\sin(\\omega \\Delta t / 2)$ 是非负的。取正平方根：\n$$ \\sin(\\omega \\Delta t / 2) = c \\Delta t \\sqrt{ \\frac{\\sin^2(k_x \\Delta x / 2)}{\\Delta x^2} + \\frac{\\sin^2(k_y \\Delta y / 2)}{\\Delta y^2} } $$\n应用反正弦函数并求解 $\\omega$ 得到离散色散关系：\n$$ \\omega(\\mathbf{k}) = \\frac{2}{\\Delta t} \\arcsin\\left( c \\Delta t \\sqrt{ \\frac{\\sin^2(k_x \\Delta x / 2)}{\\Delta x^2} + \\frac{\\sin^2(k_y \\Delta y / 2)}{\\Delta y^2} } \\right) $$\n这个方程将数值角频率 $\\omega$ 与波数分量 $k_x$ 和 $k_y$ 联系起来，它不同于连续色散关系 $\\omega = c k = c \\sqrt{k_x^2 + k_y^2}$。这种差异是数值色散的来源。\n\n数值相速度 $c_{\\mathrm{num}}$ 定义为 $\\omega/k$，其中 $k = |\\mathbf{k}| = \\sqrt{k_x^2 + k_y^2}$。然后相对相速度误差 $\\varepsilon$ 计算如下：\n$$ \\varepsilon = \\frac{c_{\\mathrm{num}}}{c} - 1 = \\frac{\\omega(\\mathbf{k})}{c k} - 1 $$\n代入 $\\omega(\\mathbf{k})$ 的表达式：\n$$ \\varepsilon = \\frac{1}{c k} \\left[ \\frac{2}{\\Delta t} \\arcsin\\left( c \\Delta t \\sqrt{ \\frac{\\sin^2(k_x \\Delta x / 2)}{\\Delta x^2} + \\frac{\\sin^2(k_y \\Delta y / 2)}{\\Delta y^2} } \\right) \\right] - 1 $$\n波数分量通过 $k_x = k \\cos(\\theta)$ 和 $k_y = k \\sin(\\theta)$ 与传播角 $\\theta$（从 $x$ 轴测量）和大小 $k$ 相关。\n\n对于实现，每个测试用例执行以下步骤：\n1.  获取参数：$c, \\Delta x, \\Delta y, k, \\theta$ 和 Courant 数（$S$ 或 $S_x$）。\n2.  使用提供的 Courant 数定义计算时间步长 $\\Delta t$。对于各向同性网格（$\\Delta x = \\Delta y$），$\\Delta t = S \\Delta x / c$。对于各向异性情况，$\\Delta t = S_x \\Delta x / c$。\n3.  计算波数分量 $k_x = k \\cos(\\theta)$ 和 $k_y = k \\sin(\\theta)$。\n4.  计算反正弦函数的参数：$A = c \\Delta t \\sqrt{ \\frac{\\sin^2(k_x \\Delta x / 2)}{\\Delta x^2} + \\frac{\\sin^2(k_y \\Delta y / 2)}{\\Delta y^2} }$。\n5.  计算数值角频率 $\\omega = (2/\\Delta t) \\arcsin(A)$。\n6.  计算数值相速度 $c_{\\mathrm{num}} = \\omega / k$。\n7.  计算相对误差 $\\varepsilon = c_{\\mathrm{num}}/c - 1$。\n该格式的稳定性由 Courant-Friedrichs-Lewy (CFL) 条件保证，该条件要求对于所有可能的波数，反正弦函数的参数必须小于或等于 1。这导致条件 $c \\Delta t \\sqrt{1/\\Delta x^2 + 1/\\Delta y^2} \\le 1$。测试用例中的 Courant 数被选择以满足此条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required.\n\ndef solve():\n    \"\"\"\n    Derives the discrete dispersion relation for the 2D FDTD acoustic wave scheme\n    and calculates the relative phase speed error for several test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (c, dx, dy, S_or_Sx, k, theta).\n    # For isotropic grids, the fourth element is the Courant number S.\n    # For anisotropic grids, it is Sx.\n    test_cases = [\n        (343.0, 0.01, 0.01, 0.7, 200.0, 0.0),\n        (343.0, 0.01, 0.01, 0.7, 200.0, np.pi/4),\n        (343.0, 0.01, 0.01, 0.7, 10.0, np.pi/8),\n        (343.0, 0.01, 0.01, 0.7, 0.95 * np.pi / 0.01, np.pi/4),\n        (343.0, 0.01, 0.015, 0.6, 180.0, np.pi/3),\n        (1500.0, 0.02, 0.02, 0.6, 80.0, np.pi/6),\n    ]\n\n    results = []\n    \n    # Differentiate case 5 as it has an anisotropic grid definition\n    # for the Courant number.\n    anisotropic_case_index = 4 # Case 5 is index 4\n\n    for i, case in enumerate(test_cases):\n        c, dx, dy, s_param, k, theta = case\n        \n        # Calculate time step dt based on Courant number definition\n        if i == anisotropic_case_index:\n            # Case 5: S_x is given\n            Sx = s_param\n            dt = Sx * dx / c\n        else:\n            # All other cases: S is given for isotropic grid\n            S = s_param\n            dt = S * dx / c\n\n        # Calculate wavenumber components\n        kx = k * np.cos(theta)\n        ky = k * np.sin(theta)\n\n        # Calculate terms inside the square root of the dispersion relation\n        term_x_arg = kx * dx / 2.0\n        term_y_arg = ky * dy / 2.0\n        \n        # Handle the case where dx or dy is zero, although not in test cases\n        if dx == 0:\n            term_x = (kx / 2.0)**2\n        else:\n            term_x = (np.sin(term_x_arg) / dx)**2\n\n        if dy == 0:\n            term_y = (ky / 2.0)**2\n        else:\n            term_y = (np.sin(term_y_arg) / dy)**2\n\n        # Argument for the arcsin function\n        # The stability condition ensures this is = 1.0\n        arcsin_arg = c * dt * np.sqrt(term_x + term_y)\n\n        # Calculate numerical angular frequency omega\n        omega_num = (2.0 / dt) * np.arcsin(arcsin_arg)\n\n        # Calculate numerical phase speed\n        # Handle k=0 case to avoid division by zero, although not in tests\n        if k == 0:\n            c_num = c # In the limit k->0, dispersion error is zero\n        else:\n            c_num = omega_num / k\n\n        # Calculate relative phase speed error\n        epsilon = c_num / c - 1.0\n        results.append(epsilon)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "某些物理问题最自然的描述方式是使用包含奇点的坐标系，例如圆柱坐标系中的轴线。本实践提出了一个高级计算挑战：为圆柱波开发一种高阶有限元方法 (FEM)，该方法即便在 $r=0$ 处存在奇点，也能保持准确和稳定。通过巧妙的变量替换，您将把奇异的控制方程转化为一个正则方程，这项强大的技术对于在各种几何结构中稳健地模拟波动现象至关重要。",
            "id": "4134647",
            "problem": "考虑在均匀无损介质中的时间谐波声传播。从声波方程出发，并假设解是可分离的，方位分解后的二维圆柱时间谐波场可以简化为一个整数阶 $n$ 方位模态的径向边值问题。令 $k$ 表示无量纲波数，令 $r \\in [0,R]$ 表示径向坐标（所有量均为无量纲）。对于整数 $n$，轴上精确的正则径向解在 $r=0$ 附近的行为類似 $r^n$，且与第一类贝塞尔函数 $J_n(kr)$ 成正比。\n\n您的任务是：\n1. 使用一个基于原理的推导，该推导从声波方程和可分离方位谐波的定义出发，得出一个适用于圆柱坐标系下整数方位阶 $n \\geq 0$ 的弱形式，该弱形式可用于高阶有限元离散化，并能以保持模态在轴附近 $r^n$ 行为正则性的方式处理轴 $r=0$。\n2. 在一个自包含程序中实现所推导的弱形式，该程序为变换后的未知量在区间 $[0,R]$ 上构建一个一维、高阶、$C^0$ 有限元系统。每个单元使用次数为 $p$ 的多项式，并采用包含 $N_e$ 个均匀单元的协调网格。您的程序必须：\n   - 采用能确保单元交界面上协调性的基。\n   - 使用足够精确的高斯积分法，为所选的 $p$ 积分所有单元矩阵。\n   - 在 $r=R$ 处施加与方位阶 $n$ 的精确模态一致的狄利克雷边界条件。\n   - 求解后，根据变换后的未知量重构物理径向场。\n3. 通过计算数值解 $R_h(r)$ 与精确贝塞尔解 $J_n(kr)$ 之间的相对加权 $L^2$ 误差来验证离散化，使用反映声能密度的圆柱权重。具体来说，计算\n   $$\\varepsilon = \\left( \\frac{\\int_0^R r \\left(R_h(r) - J_n(kr)\\right)^2 \\, dr}{\\int_0^R r \\left(J_n(kr)\\right)^2 \\, dr} \\right)^{1/2}.$$\n4. 将所有量视为无量纲。程序输出中不使用角度，因此不需要角度单位。\n\n推导约束：\n- 从声波方程和时间谐波解的可分离性开始；不要从直接跳到目标弱形式的快捷公式开始。\n- 通过展示弱形式如何保持 $r^n$ 的正则性来证明轴处理方法的合理性。\n\n实现细节：\n- 每个单元使用次数为 $p$ 的高阶有限元基，并将端点包含在节点集中，以便在 $r=R$ 处施加狄利克雷边界条件。\n- 使用足够阶数的高斯积分，以在映射到物理坐标后精确积分最高达 $2p$ 次的多项式。\n- 求解变换后的未知量后，重构 $R_h(r)$，并使用带有圆柱权重 $r$ 的高斯积分评估相对误差 $\\varepsilon$。\n\n测试套件：\n在以下参数集 $(n,k,R,p,N_e)$ 上评估您的实现：\n- 情况1（理想路径，基模）：$(0, 20.0, 1.0, 6, 12)$。\n- 情况2（轴正则性压力测试，较高方位阶）：$(2, 15.0, 0.75, 5, 10)$。\n- 情况3（小域，中等波数）：$(1, 5.0, 0.2, 6, 4)$。\n- 情况4（高频，较高方位阶）：$(3, 35.0, 1.0, 8, 20)$。\n- 情况5（近准静态，小半径）：$(0, 0.5, 0.05, 4, 3)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[result1,result2,result3]\"）。每个结果必须是相应测试用例的相对加权 $L^2$ 誤差 $\\varepsilon$，表示为浮点数。",
            "solution": "用户要求对求解时间谐波圆柱声波的高阶有限元方法进行完整的、基于原理的推导和实现，并特别关注如何处理轴 $r=0$ 处的坐标奇点。\n\n### 第1部分：弱形式的推导\n\n推导始于均匀无損介质中声压场 $P(\\mathbf{x}, t)$ 的标量声波方程：\n$$ \\nabla^2 P(\\mathbf{x}, t) - \\frac{1}{c^2} \\frac{\\partial^2 P(\\mathbf{x}, t)}{\\partial t^2} = 0 $$\n其中 $c$ 是恒定的声速。我们假设形式为 $P(\\mathbf{x}, t) = p(\\mathbf{x}) e^{-i\\omega t}$ 的时间谐波解，其中 $\\omega$ 是角频率。将其代入波动方程，得到空间分量 $p(\\mathbf{x})$ 的亥姆霍兹方程：\n$$ \\nabla^2 p(\\mathbf{x}) + k^2 p(\\mathbf{x}) = 0 $$\n其中 $k = \\omega/c$ 是波数。\n\n在二维圆柱坐标 $(r, \\theta)$ 中，拉普拉斯算子为 $\\nabla^2 = \\frac{1}{r}\\frac{\\partial}{\\partial r}\\left(r\\frac{\\partial}{\\partial r}\\right) + \\frac{1}{r^2}\\frac{\\partial^2}{\\partial \\theta^2}$。亥姆霍兹方程变为：\n$$ \\frac{1}{r}\\frac{\\partial}{\\partial r}\\left(r\\frac{\\partial p}{\\partial r}\\right) + \\frac{1}{r^2}\\frac{\\partial^2 p}{\\partial \\theta^2} + k^2 p = 0 $$\n我们寻求形式为 $p(r, \\theta) = R(r)\\Theta(\\theta)$ 的可分离解。将其代入方程并重新整理各项，可以实现变量分离：\n$$ \\frac{1}{R(r)}\\frac{1}{r}\\frac{d}{dr}\\left(r\\frac{dR}{dr}\\right) + k^2 + \\frac{1}{r^2}\\frac{1}{\\Theta(\\theta)}\\frac{d^2\\Theta}{d\\theta^2} = 0 $$\n$$ \\frac{r}{R(r)}\\frac{d}{dr}\\left(r\\frac{dR}{dr}\\right) + k^2r^2 = -\\frac{1}{\\Theta(\\theta)}\\frac{d^2\\Theta}{d\\theta^2} $$\n由于左侧仅依赖于 $r$，右侧仅依赖于 $\\theta$，两者必须等于一个常数，我们将其记为 $n^2$。这产生了两个常微分方程（ODE）。方位角方程为：\n$$ \\frac{d^2\\Theta}{d\\theta^2} + n^2\\Theta = 0 $$\n为使解在角度上是单值的（即 $\\Theta(\\theta) = \\Theta(\\theta+2\\pi)$），$n$ 必须是整数。解的形式为 $e^{\\pm in\\theta}$。\n径向方程为：\n$$ \\frac{d}{dr}\\left(r\\frac{dR}{dr}\\right) + \\left(k^2r - \\frac{n^2}{r}\\right)R = 0 $$\n这是贝塞尔微分方程。为使物理解在轴 $r=0$ 处是正则的（有限的），我们必须选择第一类贝塞尔函数，$R(r) = J_n(kr)$。对于整数 $n \\ge 0$，$J_n(z)$ 在 $z=0$ 附近的渐近行为是 $J_n(z) \\sim \\frac{1}{n!}(\\frac{z}{2})^n$。因此，$R(r)$ 在轴附近的行为类似 $r^n$。\n\n为推导此径向ODE的弱形式，通常的做法是乘以一个测试函数 $v(r)$ 并在定义域 $[0, R]$ 上积分。\n$$ \\int_0^R \\left( -\\frac{d}{dr}\\left(r\\frac{dR}{dr}\\right)v + \\frac{n^2}{r}Rv \\right) dr = \\int_0^R k^2 r R v \\, dr $$\n对第一项进行分部积分会带来一个挑战。虽然 $r=0$ 处的边界项消失了，但对于 $n>0$ 的情况，积分 $\\int_0^R \\frac{n^2}{r}Rv \\, dr$ 是有问题的。如果对 $R$ 和 $v$ 使用标准的多项式基函数（它们在 $r=0$ 处非零），则被积函数的行为类似 $1/r$，这是不可积的。\n\n为解决这个奇点并保持解的已知正则性，我们引入变量替换。令 $R(r) = r^n U(r)$。由于已知 $R(r)$ 的行为类似 $r^n$，新的未知变量 $U(r)$ 在 $r=0$ 处必须是正则的（$U(0)$ 是一个有限常数）。让我们将此变换代入径向ODE。\n首先，我们求 $R(r)$ 的导数：\n$R' = nr^{n-1}U + r^n U'$\n$rR' = nr^n U + r^{n+1} U'$\n那么，ODE的第一项变为：\n$$\n\\frac{d}{dr}(rR') = \\frac{d}{dr}(nr^n U + r^{n+1} U') = n^2r^{n-1}U + nr^nU' + (n+1)r^nU' + r^{n+1}U'' = r^{n-1}n^2U + (2n+1)r^nU' + r^{n+1}U''\n$$\n将此代入径向ODE：\n$$ (r^{n-1}n^2U + (2n+1)r^nU' + r^{n+1}U'') + (k^2r - \\frac{n^2}{r})(r^nU) = 0 $$\n$$ r^{n-1}n^2U + (2n+1)r^nU' + r^{n+1}U'' + k^2r^{n+1}U - n^2r^{n-1}U = 0 $$\n奇异项 $n^2r^{n-1}U$ 被抵消，剩下：\n$$ r^{n+1}U'' + (2n+1)r^nU' + k^2r^{n+1}U = 0 $$\n除以 $r^n$（对于 $r>0$）得到：\n$$ rU'' + (2n+1)U' + k^2rU = 0 $$\n这个ODE可以通过乘以积分因子 $r^{2n}$ 写成更方便的自伴形式：\n$$ r^{2n+1}U'' + (2n+1)r^{2n}U' + k^2r^{2n+1}U = 0 $$\n$$ \\frac{d}{dr}\\left( r^{2n+1} U' \\right) + k^2 r^{2n+1} U = 0 $$\n这是变换后问题的强形式。对于 $n \\ge 0$，所有系数现在在 $r=0$ 处都是正则的。由于 $U(r)$ 在 $r=0$ 处是正则的，并且是 $r$ 的偶函数（从 $J_n(kr)/r^n$ 的级数展开可知），其导数 $U'(0) = 0$。这是一个自然边界条件，弱形式会自动满足它。\n\n现在，我们推导 $U(r)$ 的弱形式。我们将自伴形式乘以一个测试函数 $v(r)$ 并在定义域 $[0, R]$ 上积分：\n$$ \\int_0^R \\frac{d}{dr}\\left( r^{2n+1} U' \\right) v \\, dr + \\int_0^R k^2 r^{2n+1} U v \\, dr = 0 $$\n对第一项应用分部积分：\n$$ \\left[ r^{2n+1} U' v \\right]_0^R - \\int_0^R r^{2n+1} U' v' \\, dr + \\int_0^R k^2 r^{2n+1} U v \\, dr = 0 $$\n$r=0$ 处的边界项因为 $2n+1 \\ge 1$ 而消失。在 $r=R$ 处，我们将施加一个狄利克雷边界条件，因此我们选择测试函数 $v$ 使得 $v(R)=0$，这使得在 $R$ 处的边界项消失。最终的弱形式是：在适当的函数空间中找到 $U$，使得对于所有容许的测试函数 $v$：\n$$ \\int_0^R r^{2n+1} U' v' \\, dr - \\int_0^R k^2 r^{2n+1} U v \\, dr = 0 $$\n这个方程定义了有限元系统。我们将 $U(r)$ 离散化为 $U_h(r) = \\sum_j U_j \\phi_j(r)$，其中 $\\phi_j$ 是 $C^0$ 多项式基函数，$U_j$ 是节点值。测试函数 $v$ 从基函数 $\\phi_i$ 中选取。这导出了线性系统：\n$$ (A - k^2 M) \\mathbf{U} = \\mathbf{0} $$\n其中刚度矩阵 $A$ 和质量矩阵 $M$ 的元素为：\n$$ A_{ij} = \\int_0^R r^{2n+1} \\phi_j'(r) \\phi_i'(r) \\, dr $$\n$$ M_{ij} = \\int_0^R r^{2n+1} \\phi_j(r) \\phi_i(r) \\, dr $$\n然后修改此系统以包含狄利克雷边界条件 $R(R) = J_n(kR)$，这可以转换为 $U(R) = J_n(kR)/R^n$。\n\n### 第2部分和第3部分：实现与验证\n\n实现遵循推导出的弱形式。在区间 $[0,R]$ 上创建一个包含 $N_e$ 个均匀单元的网格。在每个单元上，我们使用次数为 $p$ 的拉格朗日多项式节点基。\n\n单元刚度矩阵和质量矩阵的积分是使用高斯积分计算的。选择一个有 $p+1$ 个点的法则，这对于包含最高 $2p$ 次多项式并乘以权重 $r(\\xi)^{2n+1}$ 的被积函数是足够精确的。\n\n在组装全局矩阵 $A$ 和 $M$ 之后，形成系统 $(A-k^2M)\\mathbf{U}=\\mathbf{f}$。通过修改系统矩阵的最后一行和最后一列并创建相应的右端向量 $\\mathbf{f}$ 来处理 $r=R$ 处的狄利克雷条件。求解简化后的系统以得到 $U_h$ 的未知节点值。\n\n物理场 $R_h(r)$ 的数值解是通过关系式 $R_h(r) = r^n U_h(r)$ 从变换变量 $U_h(r)$ 的解中重构出来的。\n\n最后，计算相对加权 $L^2$ 误差 $\\varepsilon$。这需要计算两个积分：\n分子：$\\int_0^R r (R_h(r) - J_n(kr))^2 \\, dr$\n分母：$\\int_0^R r (J_n(kr))^2 \\, dr$\n这些积分通过对每个单元的贡献求和来进行数值计算，使用高阶高斯积分法则（含 $2p$ 个点）以确保误差计算本身的准确性。这两个积分之比的平方根即为最终误差 $\\varepsilon$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import jv, roots_legendre\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the problem-solving process.\n    It defines test cases and computes the relative error for each.\n    \"\"\"\n\n    def lagrange_basis(nodes, x):\n        \"\"\"\n        Evaluates 1D Lagrange basis polynomials and their derivatives defined on a set of nodes.\n\n        Args:\n            nodes (np.ndarray): 1D array of node coordinates for the basis.\n            x (np.ndarray): The point(s) at which to evaluate the basis.\n\n        Returns:\n            tuple[np.ndarray, np.ndarray]: A tuple of two arrays:\n                - values: shape (num_nodes, num_x_pts), L_i(x_j)\n                - derivatives: shape (num_nodes, num_x_pts), L'_i(x_j)\n        \"\"\"\n        num_nodes = len(nodes)\n        x = np.atleast_1d(x)\n        \n        values = np.zeros((num_nodes, len(x)))\n        derivatives = np.zeros((num_nodes, len(x)))\n        \n        for i in range(num_nodes):\n            # Denominator for L_i\n            den = np.prod([nodes[i] - nodes[j] for j in range(num_nodes) if i != j])\n            \n            # Numerator for L_i(x)\n            num = np.prod([x - nodes[j] for j in range(num_nodes) if i != j], axis=0)\n            values[i, :] = num / den\n            \n            # Derivative L'_i(x) = sum_{k!=i} ( prod_{j!=i,k} (x-x_j) ) / den\n            temp_sum = np.zeros_like(x, dtype=float)\n            for k in range(num_nodes):\n                if k == i:\n                    continue\n                \n                prod = np.prod([x - nodes[j] for j in range(num_nodes) if j != i and j != k], axis=0)\n                temp_sum += prod\n            \n            derivatives[i, :] = temp_sum / den\n            \n        return values, derivatives\n\n    def compute_fem_error(n, k, R, p, Ne):\n        \"\"\"\n        Computes the relative weighted L2 error for a given set of parameters.\n        \"\"\"\n        # 1. Setup and Discretization\n        h = R / Ne\n        num_dofs = Ne * p + 1\n        \n        # Reference element nodes (equispaced)\n        ref_nodes = np.linspace(-1, 1, p + 1)\n        \n        # Quadrature rules\n        # For assembly: p+1 points, exact for polynomials of degree 2p+1\n        q_nodes_asm, q_weights_asm = roots_legendre(p + 1)\n        # For error calculation: 2p points, higher accuracy\n        q_nodes_err, q_weights_err = roots_legendre(2 * p)\n\n        # Reference element basis functions evaluated at quadrature points\n        psi_asm, dpsi_asm = lagrange_basis(ref_nodes, q_nodes_asm)\n        psi_err, _ = lagrange_basis(ref_nodes, q_nodes_err) # Derivatives not needed for error value\n\n        # 2. Assembly of Global Matrices\n        A = np.zeros((num_dofs, num_dofs))\n        M = np.zeros((num_dofs, num_dofs))\n        \n        for e in range(Ne):\n            r_e_start = e * h\n            \n            # Element matrices\n            A_e = np.zeros((p + 1, p + 1))\n            M_e = np.zeros((p + 1, p + 1))\n\n            # Jacobian of transformation from reference to physical element\n            J = h / 2.0\n            \n            for q_idx, xi_q in enumerate(q_nodes_asm):\n                w_q = q_weights_asm[q_idx]\n                r_q = r_e_start + J * (1 + xi_q)\n\n                for i in range(p + 1):\n                    for j in range(p + 1):\n                        dpsi_i_dr = dpsi_asm[i, q_idx] / J\n                        dpsi_j_dr = dpsi_asm[j, q_idx] / J\n                        \n                        weight_r = r_q**(2 * n + 1)\n                        \n                        A_e[i, j] += weight_r * dpsi_i_dr * dpsi_j_dr * w_q * J\n                        M_e[i, j] += weight_r * psi_asm[i, q_idx] * psi_asm[j, q_idx] * w_q * J\n            \n            # Assemble element matrices into global matrices\n            for i in range(p + 1):\n                gi = e * p + i\n                for j in range(p + 1):\n                    gj = e * p + j\n                    A[gi, gj] += A_e[i, j]\n                    M[gi, gj] += M_e[i, j]\n\n        # 3. Solve the Linear System with Dirichlet BC\n        S = A - k**2 * M\n        \n        # BC value for the transformed variable U at r=R\n        U_bc = jv(n, k * R) / (R**n if R > 0 else 1.0)\n        \n        # Modify system for Dirichlet BC\n        S_reduced = S[:-1, :-1]\n        rhs = -S[:-1, -1] * U_bc\n        \n        # Solve for unknown DOFs\n        U_unknowns = np.linalg.solve(S_reduced, rhs)\n        \n        # Combine known and computed DOFs\n        U_sol = np.append(U_unknowns, U_bc)\n\n        # 4. Error Calculation\n        error_num_integral = 0.0\n        error_den_integral = 0.0\n        \n        for e in range(Ne):\n            r_e_start = e * h\n            J = h / 2.0\n            local_dof_indices = np.arange(e * p, e * p + p + 1)\n            U_local = U_sol[local_dof_indices]\n\n            for q_idx, xi_q in enumerate(q_nodes_err):\n                w_q = q_weights_err[q_idx]\n                r_q = r_e_start + J * (1 + xi_q)\n                \n                # Evaluate numerical solution U_h at quadrature point\n                U_h_at_rq = np.dot(U_local, psi_err[:, q_idx])\n                \n                # Reconstruct physical solution R_h\n                R_h_at_rq = (r_q**n) * U_h_at_rq\n                \n                # Exact solution R\n                R_exact_at_rq = jv(n, k * r_q)\n                \n                # Accumulate weighted integrals\n                error_num_integral += r_q * (R_h_at_rq - R_exact_at_rq)**2 * w_q * J\n                error_den_integral += r_q * (R_exact_at_rq)**2 * w_q * J\n        \n        if error_den_integral == 0.0:\n            return 0.0 if error_num_integral == 0.0 else np.inf\n\n        relative_error = np.sqrt(error_num_integral / error_den_integral)\n        return relative_error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 20.0, 1.0, 6, 12),\n        (2, 15.0, 0.75, 5, 10),\n        (1, 5.0, 0.2, 6, 4),\n        (3, 35.0, 1.0, 8, 20),\n        (0, 0.5, 0.05, 4, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, k, R, p, Ne = case\n        result = compute_fem_error(n, k, R, p, Ne)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}