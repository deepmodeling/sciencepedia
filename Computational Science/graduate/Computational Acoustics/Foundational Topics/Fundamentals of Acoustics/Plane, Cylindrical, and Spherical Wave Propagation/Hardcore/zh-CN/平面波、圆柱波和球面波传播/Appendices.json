{
    "hands_on_practices": [
        {
            "introduction": "当我们使用有限差分 (FDTD) 等数值方法模拟波的传播时，我们将连续的时空替换为离散的网格。这种离散化会引入误差，导致波的相速度依赖于其频率和相对于网格的传播方向，这种现象被称为数值色散。本练习  提供了对二维波动方程中数值色散的动手分析，让您能够推导出离散色散关系并量化相位误差，这是任何计算科学家都应具备的关键技能。",
            "id": "4134634",
            "problem": "考虑均匀介质中的二维线性声波方程，\n$$\\frac{\\partial^2 p}{\\partial t^2} = c^2 \\left( \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} \\right),$$\n其中$p$是声压场，$c$是声速。在空间步长为$\\Delta x$和$\\Delta y$、时间步长为$\\Delta t$的均匀笛卡尔网格上，使用标准的二阶中心有限差分在空间和时间上近似二阶导数。这可以得到显式二阶有限差分格式\n$$\\frac{p_{i,j}^{n+1} - 2 p_{i,j}^{n} + p_{i,j}^{n-1}}{\\Delta t^2} = c^2 \\left( \\frac{p_{i+1,j}^{n} - 2 p_{i,j}^{n} + p_{i-1,j}^{n}}{\\Delta x^2} + \\frac{p_{i,j+1}^{n} - 2 p_{i,j}^{n} + p_{i,j-1}^{n}}{\\Delta y^2} \\right),$$\n其中$i$和$j$是空间网格的索引，$n$是时间的索引。从上述线性声波方程及其离散近似出发，通过代入以下形式的离散平面波来进行平面波分析\n$$p_{i,j}^{n} = A \\exp\\left( \\mathrm{i} \\left( k_x i \\Delta x + k_y j \\Delta y - \\omega n \\Delta t \\right) \\right),$$\n其中$A$是恒定振幅，$k_x$和$k_y$是波数矢量$\\mathbf{k}$（其大小为$|\\mathbf{k}| = k$）的笛卡尔分量，$\\omega$是角频率。推导该格式的离散色散关系$\\omega(\\mathbf{k})$。角频率使用主支，以满足$0 \\le \\omega \\Delta t \\le \\pi$。\n\n使用推导出的$\\omega(\\mathbf{k})$，定义数值相速度$c_{\\mathrm{num}} = \\omega / k$。通过计算相对误差来量化与角度相关的相速度误差\n$$\\varepsilon = \\frac{c_{\\mathrm{num}}}{c} - 1,$$\n以小数形式表示（例如，5% 的误差必须报告为 0.05）。角度必须以弧度表示。所有物理量必须使用国际标准 (SI) 单位处理：米 ($\\mathrm{m}$)、秒 ($\\mathrm{s}$) 和弧度 ($\\mathrm{rad}$)。\n\n您的程序必须实现推导出的离散色散关系，并为以下每个测试用例计算$\\varepsilon$。对于指定了库朗数的用例，对于各向同性网格（$\\Delta x = \\Delta y$），使用关系式$\\Delta t = S \\Delta x / c$，对于各向异性网格，使用$\\Delta t = S_x \\Delta x / c$（这意味着有效的$S_y = c \\Delta t / \\Delta y$）。确保这些选择隐式地满足了稳定性条件。\n\n测试用例参数集（每个用例指定$(c, \\Delta x, \\Delta y, \\Delta t, k, \\theta)$，其中$\\theta$是从 x 轴测量的传播角度）：\n- 用例 1：$c = 343\\,\\mathrm{m/s}$，$\\Delta x = 0.01\\,\\mathrm{m}$，$\\Delta y = 0.01\\,\\mathrm{m}$，$S = 0.7$ 因此 $\\Delta t = S \\Delta x / c$，$k = 200\\,\\mathrm{rad/m}$，$\\theta = 0$。\n- 用例 2：$c = 343\\,\\mathrm{m/s}$，$\\Delta x = 0.01\\,\\mathrm{m}$，$\\Delta y = 0.01\\,\\mathrm{m}$，$S = 0.7$ 因此 $\\Delta t = S \\Delta x / c$，$k = 200\\,\\mathrm{rad/m}$，$\\theta = \\pi/4$。\n- 用例 3：$c = 343\\,\\mathrm{m/s}$，$\\Delta x = 0.01\\,\\mathrm{m}$，$\\Delta y = 0.01\\,\\mathrm{m}$，$S = 0.7$ 因此 $\\Delta t = S \\Delta x / c$，$k = 10\\,\\mathrm{rad/m}$，$\\theta = \\pi/8$。\n- 用例 4：$c = 343\\,\\mathrm{m/s}$，$\\Delta x = 0.01\\,\\mathrm{m}$，$\\Delta y = 0.01\\,\\mathrm{m}$，$S = 0.7$ 因此 $\\Delta t = S \\Delta x / c$，$k = 0.95 \\pi / \\Delta x\\,\\mathrm{rad/m}$，$\\theta = \\pi/4$。\n- 用例 5：$c = 343\\,\\mathrm{m/s}$，$\\Delta x = 0.01\\,\\mathrm{m}$，$\\Delta y = 0.015\\,\\mathrm{m}$，$S_x = 0.6$ 因此 $\\Delta t = S_x \\Delta x / c$ 且 $S_y = c \\Delta t / \\Delta y$，$k = 180\\,\\mathrm{rad/m}$，$\\theta = \\pi/3$。\n- 用例 6：$c = 1500\\,\\mathrm{m/s}$，$\\Delta x = 0.02\\,\\mathrm{m}$，$\\Delta y = 0.02\\,\\mathrm{m}$，$S = 0.6$ 因此 $\\Delta t = S \\Delta x / c$，$k = 80\\,\\mathrm{rad/m}$，$\\theta = \\pi/6$。\n\n您的程序应生成单行输出，其中包含这六个用例的相对相速度误差$\\varepsilon$，形式为用方括号括起来的逗号分隔列表（例如，$[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4,\\varepsilon_5,\\varepsilon_6]$）。这些值必须是无量纲小数（无百分号），并按上述顺序列出。",
            "solution": "目标是为二维线性声波方程的二阶有限差分格式推导离散色散关系，并利用该关系对给定的一组参数量化数值相速度误差。\n\n出发点是均匀无损介质中的二维线性声波方程：\n$$ \\frac{\\partial^2 p}{\\partial t^2} = c^2 \\left( \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} \\right) $$\n其中$p(x,y,t)$是声压，$c$是恒定的声速。该方程在空间步长为$\\Delta x$和$\\Delta y$、时间步长为$\\Delta t$的均匀笛卡尔网格上进行离散化。在网格点$(i\\Delta x, j\\Delta y)$和时间$n\\Delta t$处的压力表示为$p_{i,j}^{n}$。对所有二阶导数使用二阶中心有限差分，我们得到显式时域有限差分 (FDTD) 格式：\n$$ \\frac{p_{i,j}^{n+1} - 2 p_{i,j}^{n} + p_{i,j}^{n-1}}{\\Delta t^2} = c^2 \\left( \\frac{p_{i+1,j}^{n} - 2 p_{i,j}^{n} + p_{i-1,j}^{n}}{\\Delta x^2} + \\frac{p_{i,j+1}^{n} - 2 p_{i,j}^{n} + p_{i,j-1}^{n}}{\\Delta y^2} \\right) $$\n\n为了进行平面波分析（也称为 von Neumann 分析），我们代入一个形式如下的离散平面波解，或称试探解 (ansatz)：\n$$ p_{i,j}^{n} = A \\exp\\left( \\mathrm{i} \\left( k_x i \\Delta x + k_y j \\Delta y - \\omega n \\Delta t \\right) \\right) $$\n这里，$A$是恒定振幅，$k_x$和$k_y$是波数矢量$\\mathbf{k}$的笛卡尔分量，$\\omega$是角频率，$\\mathrm{i}$是虚数单位。\n\n代入试探解需要计算在移位的网格点$(i\\pm 1, j, n)$、$(i, j\\pm 1, n)$和$(i, j, n\\pm 1)$处的压力：\n\\begin{itemize}\n    \\item $p_{i,j}^{n\\pm 1} = p_{i,j}^{n} \\exp(\\mp \\mathrm{i} \\omega \\Delta t)$\n    \\item $p_{i\\pm 1,j}^{n} = p_{i,j}^{n} \\exp(\\pm \\mathrm{i} k_x \\Delta x)$\n    \\item $p_{i,j\\pm 1}^{n} = p_{i,j}^{n} \\exp(\\pm \\mathrm{i} k_y \\Delta y)$\n\\end{itemize}\n将这些代入 FDTD 格式中，并除以公共非零因子$p_{i,j}^{n}$：\n$$ \\frac{\\exp(-\\mathrm{i} \\omega \\Delta t) - 2 + \\exp(\\mathrm{i} \\omega \\Delta t)}{\\Delta t^2} = c^2 \\left( \\frac{\\exp(\\mathrm{i} k_x \\Delta x) - 2 + \\exp(-\\mathrm{i} k_x \\Delta x)}{\\Delta x^2} + \\frac{\\exp(\\mathrm{i} k_y \\Delta y) - 2 + \\exp(-\\mathrm{i} k_y \\Delta y)}{\\Delta y^2} \\right) $$\n使用欧拉公式$\\exp(\\mathrm{i}\\phi) + \\exp(-\\mathrm{i}\\phi) = 2 \\cos(\\phi)$，方程简化为：\n$$ \\frac{2 \\cos(\\omega \\Delta t) - 2}{\\Delta t^2} = c^2 \\left( \\frac{2 \\cos(k_x \\Delta x) - 2}{\\Delta x^2} + \\frac{2 \\cos(k_y \\Delta y) - 2}{\\Delta y^2} \\right) $$\n接下来，我们使用半角恒等式$1 - \\cos(\\phi) = 2 \\sin^2(\\phi/2)$：\n$$ \\frac{-4 \\sin^2(\\omega \\Delta t / 2)}{\\Delta t^2} = c^2 \\left( \\frac{-4 \\sin^2(k_x \\Delta x / 2)}{\\Delta x^2} + \\frac{-4 \\sin^2(k_y \\Delta y / 2)}{\\Delta y^2} \\right) $$\n消去公因子$-4$后得到：\n$$ \\frac{\\sin^2(\\omega \\Delta t / 2)}{\\Delta t^2} = c^2 \\left( \\frac{\\sin^2(k_x \\Delta x / 2)}{\\Delta x^2} + \\frac{\\sin^2(k_y \\Delta y / 2)}{\\Delta y^2} \\right) $$\n为了解出$\\omega$，我们首先分离出$\\sin(\\omega \\Delta t / 2)$。问题指定对$\\omega$使用主支，以满足$0 \\le \\omega \\Delta t \\le \\pi$。这意味着$0 \\le \\omega \\Delta t / 2 \\le \\pi/2$，在此区间内$\\sin(\\omega \\Delta t / 2)$是非负的。取正平方根：\n$$ \\sin(\\omega \\Delta t / 2) = c \\Delta t \\sqrt{ \\frac{\\sin^2(k_x \\Delta x / 2)}{\\Delta x^2} + \\frac{\\sin^2(k_y \\Delta y / 2)}{\\Delta y^2} } $$\n应用反正弦函数并求解$\\omega$可得到离散色散关系：\n$$ \\omega(\\mathbf{k}) = \\frac{2}{\\Delta t} \\arcsin\\left( c \\Delta t \\sqrt{ \\frac{\\sin^2(k_x \\Delta x / 2)}{\\Delta x^2} + \\frac{\\sin^2(k_y \\Delta y / 2)}{\\Delta y^2} } \\right) $$\n该方程将数值角频率$\\omega$与波数分量$k_x$和$k_y$联系起来，它不同于连续色散关系$\\omega = c k = c \\sqrt{k_x^2 + k_y^2}$。这种差异是数值色散的来源。\n\n数值相速度$c_{\\mathrm{num}}$定义为$\\omega/k$，其中$k = |\\mathbf{k}| = \\sqrt{k_x^2 + k_y^2}$。相对相速度误差$\\varepsilon$则计算为：\n$$ \\varepsilon = \\frac{c_{\\mathrm{num}}}{c} - 1 = \\frac{\\omega(\\mathbf{k})}{c k} - 1 $$\n代入$\\omega(\\mathbf{k})$的表达式：\n$$ \\varepsilon = \\frac{1}{c k} \\left[ \\frac{2}{\\Delta t} \\arcsin\\left( c \\Delta t \\sqrt{ \\frac{\\sin^2(k_x \\Delta x / 2)}{\\Delta x^2} + \\frac{\\sin^2(k_y \\Delta y / 2)}{\\Delta y^2} } \\right) \\right] - 1 $$\n波数分量通过$k_x = k \\cos(\\theta)$和$k_y = k \\sin(\\theta)$与传播角$\\theta$（从 x 轴测量）和大小$k$相关。\n\n在实现时，对每个测试用例执行以下步骤：\n1. 获取参数：$c, \\Delta x, \\Delta y, k, \\theta$以及库朗数（$S$或$S_x$）。\n2. 使用提供的库朗数定义计算时间步长$\\Delta t$。对于各向同性网格（$\\Delta x = \\Delta y$），$\\Delta t = S \\Delta x / c$。对于各向异性情况，$\\Delta t = S_x \\Delta x / c$。\n3. 计算波数分量$k_x = k \\cos(\\theta)$和$k_y = k \\sin(\\theta)$。\n4. 计算反正弦函数的参数：$A = c \\Delta t \\sqrt{ \\frac{\\sin^2(k_x \\Delta x / 2)}{\\Delta x^2} + \\frac{\\sin^2(k_y \\Delta y / 2)}{\\Delta y^2} }$。\n5. 计算数值角频率$\\omega = (2/\\Delta t) \\arcsin(A)$。\n6. 计算数值相速度$c_{\\mathrm{num}} = \\omega / k$。\n7. 计算相对误差$\\varepsilon = c_{\\mathrm{num}}/c - 1$。\n该格式的稳定性由 Courant-Friedrichs-Lewy (CFL) 条件保证，该条件要求反正弦函数的参数对所有可能的波数都小于或等于$1$。这导致条件$c \\Delta t \\sqrt{1/\\Delta x^2 + 1/\\Delta y^2} \\le 1$。测试用例中的库朗数被选择来满足此条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required.\n\ndef solve():\n    \"\"\"\n    Derives the discrete dispersion relation for the 2D FDTD acoustic wave scheme\n    and calculates the relative phase speed error for several test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (c, dx, dy, S_or_Sx, k, theta).\n    # For isotropic grids, the fourth element is the Courant number S.\n    # For anisotropic grids, it is Sx.\n    test_cases = [\n        (343.0, 0.01, 0.01, 0.7, 200.0, 0.0),\n        (343.0, 0.01, 0.01, 0.7, 200.0, np.pi/4),\n        (343.0, 0.01, 0.01, 0.7, 10.0, np.pi/8),\n        (343.0, 0.01, 0.01, 0.7, 0.95 * np.pi / 0.01, np.pi/4),\n        (343.0, 0.01, 0.015, 0.6, 180.0, np.pi/3),\n        (1500.0, 0.02, 0.02, 0.6, 80.0, np.pi/6),\n    ]\n\n    results = []\n    \n    # Differentiate case 5 as it has an anisotropic grid definition\n    # for the Courant number.\n    anisotropic_case_index = 4 # Case 5 is index 4\n\n    for i, case in enumerate(test_cases):\n        c, dx, dy, s_param, k, theta = case\n        \n        # Calculate time step dt based on Courant number definition\n        if i == anisotropic_case_index:\n            # Case 5: S_x is given\n            Sx = s_param\n            dt = Sx * dx / c\n        else:\n            # All other cases: S is given for isotropic grid\n            S = s_param\n            dt = S * dx / c\n\n        # Calculate wavenumber components\n        kx = k * np.cos(theta)\n        ky = k * np.sin(theta)\n\n        # Calculate terms inside the square root of the dispersion relation\n        term_x_arg = kx * dx / 2.0\n        term_y_arg = ky * dy / 2.0\n        \n        # Handle the case where dx or dy is zero, although not in test cases\n        if dx == 0:\n            term_x = (kx / 2.0)**2\n        else:\n            term_x = (np.sin(term_x_arg) / dx)**2\n\n        if dy == 0:\n            term_y = (ky / 2.0)**2\n        else:\n            term_y = (np.sin(term_y_arg) / dy)**2\n\n        # Argument for the arcsin function\n        # The stability condition ensures this is = 1.0\n        arcsin_arg = c * dt * np.sqrt(term_x + term_y)\n\n        # Calculate numerical angular frequency omega\n        omega_num = (2.0 / dt) * np.arcsin(arcsin_arg)\n\n        # Calculate numerical phase speed\n        # Handle k=0 case to avoid division by zero, although not in tests\n        if k == 0:\n            c_num = c # In the limit k-0, dispersion error is zero\n        else:\n            c_num = omega_num / k\n\n        # Calculate relative phase speed error\n        epsilon = c_num / c - 1.0\n        results.append(epsilon)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个简单的单极子声源产生向外传播的球面波，这是声学中的一个基本构成单元。声源附近的声场能量并非纯粹向外传播；其中有相当一部分以“无功”能量的形式储存在声场中并与声源进行交换，这源于近场中声压和质点速度之间的相位不匹配。通过推导声压和速度场并计算无功能量密度 ，您将对球面波的近场和远场区别获得更深刻的物理理解。",
            "id": "4134631",
            "problem": "考虑一个位于无界、均匀、无粘性、无损耗流体中的时谐声单极子源，该源位于原点。流体的恒定平衡质量密度为$\\rho_0$，声速为$c$。该源以角频率$\\omega$注入流体，复体积速度振幅为$Q_0$，时间依赖关系为$\\exp(-i\\omega t)$。假设产生的场是球对称且向外传播的。\n\n从线性化的动量方程（欧拉方程）和线性化的连续性方程，以及通过$p=c^2\\rho'$关联压力扰动$p$和密度扰动$\\rho'$的线性状态方程出发，推导声压$p(\\mathbf{x})$的控制非齐次亥姆霍兹方程，并为给定的单极子源写出适当的点源项。使用三维自由空间格林函数求解复压振幅$p(r)$，然后使用线性化动量方程得到径向质点速度振幅$u_r(r)$。\n\n对于小振幅时谐场，时间平均势（压缩）能密度$\\langle w_p(r)\\rangle$和动能密度$\\langle w_k(r)\\rangle$定义为\n$$\n\\langle w_p(r)\\rangle = \\frac{|p(r)|^2}{4\\,\\rho_0 c^2}, \n\\qquad\n\\langle w_k(r)\\rangle = \\frac{\\rho_0\\,|u_r(r)|^2}{4}.\n$$\n将无功能声能密度定义为\n$$\nw_{\\mathrm{re}}(r) = \\langle w_p(r)\\rangle - \\langle w_k(r)\\rangle.\n$$\n将$w_{\\mathrm{re}}(r)$明确地表示为$r$、$\\rho_0$、$Q_0$和基本常数的闭合形式函数，并解释其在源近场中存储的振荡能量方面的物理意义。将$w_{\\mathrm{re}}(r)$的最终答案以焦耳/立方米（J/m$^3$）表示。未给出数值；请提供精确的解析表达式。不需要四舍五入。",
            "solution": "该问题要求推导和计算时谐单极子源的无功能声能密度。这是基础声学中的一个有效问题。\n\n该过程包括三个主要部分：\n1.  声压$p$的控制非齐次亥姆霍兹方程的推导。\n2.  复压振幅$p(r)$和径向质点速度振幅$u_r(r)$的求解。\n3.  时间平均能量密度和无功能声能密度$w_{\\mathrm{re}}(r)$的计算。\n\n**第一部分：非齐次亥姆霍兹方程的推导**\n\n我们从无粘性、无损耗流体的线性化流体动力学方程开始，假设时间依赖关系为$\\exp(-i\\omega t)$形式。这意味着时间导数算子可以被替换为乘以$-i\\omega$。\n\n线性化动量方程（欧拉方程）为：\n$$\n\\rho_0 \\frac{\\partial \\mathbf{u}}{\\partial t} = -\\nabla p\n$$\n对于具有复振幅$\\mathbf{u}(\\mathbf{x})$和$p(\\mathbf{x})$的时谐场，该方程变为：\n$$\n-i\\omega \\rho_0 \\mathbf{u} = -\\nabla p \\implies \\mathbf{u} = \\frac{1}{i\\omega \\rho_0} \\nabla p\n\\quad (1)\n$$\n其中$\\rho_0$是平衡流体密度，$\\mathbf{u}$是质点速度矢量，$p$是声压扰动。\n\n线性化连续性方程，包括一个位于原点、以体积速度$Q(t) = Q_0 \\exp(-i\\omega t)$注入流体的单极子源，为：\n$$\n\\frac{\\partial \\rho'}{\\partial t} + \\rho_0 \\nabla \\cdot \\mathbf{u} = \\rho_0 Q(t) \\delta(\\mathbf{x})\n$$\n其中$\\rho'$是密度扰动，$\\delta(\\mathbf{x})$是三维狄拉克δ函数。对于时谐场，该方程变为：\n$$\n-i\\omega \\rho' + \\rho_0 \\nabla \\cdot \\mathbf{u} = \\rho_0 Q_0 \\delta(\\mathbf{x})\n\\quad (2)\n$$\n\n线性状态方程关联了压力和密度扰动：\n$$\np = c^2 \\rho' \\implies \\rho' = \\frac{p}{c^2}\n\\quad (3)\n$$\n其中$c$是声速。\n\n我们可以组合这三个方程来找到一个关于压力$p$的单一方程。首先，将方程(3)代入方程(2)：\n$$\n-i\\omega \\frac{p}{c^2} + \\rho_0 \\nabla \\cdot \\mathbf{u} = \\rho_0 Q_0 \\delta(\\mathbf{x})\n$$\n接下来，将方程(1)中$\\mathbf{u}$的表达式代入这个修改后的连续性方程：\n$$\n-i\\omega \\frac{p}{c^2} + \\rho_0 \\nabla \\cdot \\left(\\frac{1}{i\\omega \\rho_0} \\nabla p\\right) = \\rho_0 Q_0 \\delta(\\mathbf{x})\n$$\n常数项$\\rho_0$和$1/(i\\omega)$可以移到散度算子外面：\n$$\n-i\\omega \\frac{p}{c^2} + \\frac{1}{i\\omega} \\nabla^2 p = \\rho_0 Q_0 \\delta(\\mathbf{x})\n$$\n整个方程乘以$i\\omega$得到：\n$$\n(-i\\omega)^2 \\frac{p}{c^2} + \\nabla^2 p = i\\omega \\rho_0 Q_0 \\delta(\\mathbf{x})\n$$\n$$\n-\\omega^2 \\frac{p}{c^2} + \\nabla^2 p = i\\omega \\rho_0 Q_0 \\delta(\\mathbf{x})\n$$\n引入波数$k = \\omega/c$，我们得到声压的非齐次亥姆霍兹方程：\n$$\n\\nabla^2 p + k^2 p = i\\omega \\rho_0 Q_0 \\delta(\\mathbf{x})\n\\quad (4)\n$$\n\n**第二部分：压力和质点速度的求解**\n\n方程(4)的解可以使用亥姆霍兹算子的自由空间格林函数找到。格林函数$G(\\mathbf{x}|\\mathbf{x}')$是满足索末菲辐射条件（代表向外传播的波）的方程$(\\nabla^2 + k^2)G = -\\delta(\\mathbf{x}-\\mathbf{x}')$的解。对于三维空间，它是：\n$$\nG(\\mathbf{x}|\\mathbf{x}') = \\frac{\\exp(ik|\\mathbf{x}-\\mathbf{x}'|)}{4\\pi|\\mathbf{x}-\\mathbf{x}'|}\n$$\n形如$(\\nabla^2 + k^2)\\psi = -F(\\mathbf{x})$的方程的解由卷积$\\psi(\\mathbf{x}) = \\int G(\\mathbf{x}|\\mathbf{x}') F(\\mathbf{x}') dV'$给出。\n在我们的情况中，源项是$F(\\mathbf{x}) = -i\\omega \\rho_0 Q_0 \\delta(\\mathbf{x})$。源在原点（$\\mathbf{x}' = 0$），我们有：\n$$\np(\\mathbf{x}) = \\int \\frac{\\exp(ik|\\mathbf{x}-\\mathbf{x}'|)}{4\\pi|\\mathbf{x}-\\mathbf{x}'|} \\left( -i\\omega \\rho_0 Q_0 \\delta(\\mathbf{x}') \\right) dV'\n$$\n用δ函数计算积分得到：\n$$\np(\\mathbf{x}) = -i\\omega \\rho_0 Q_0 \\frac{\\exp(ik|\\mathbf{x}|)}{4\\pi|\\mathbf{x}|}\n$$\n对于球对称场，我们使用径向坐标$r=|\\mathbf{x}|$。复压振幅为：\n$$\np(r) = -\\frac{i\\omega \\rho_0 Q_0}{4\\pi r} \\exp(ikr)\n\\quad (5)\n$$\n接下来，我们使用方程(1)求径向质点速度$u_r(r)$。对于球对称场，$\\nabla p = \\frac{\\partial p}{\\partial r} \\hat{\\mathbf{r}}$，所以$u_r(r) = \\frac{1}{i\\omega \\rho_0} \\frac{\\partial p}{\\partial r}$。\n$$\n\\frac{\\partial p}{\\partial r} = -\\frac{i\\omega \\rho_0 Q_0}{4\\pi} \\frac{\\partial}{\\partial r}\\left(\\frac{\\exp(ikr)}{r}\\right) = -\\frac{i\\omega \\rho_0 Q_0}{4\\pi} \\left( \\frac{ik\\exp(ikr)}{r} - \\frac{\\exp(ikr)}{r^2} \\right)\n$$\n$$\n\\frac{\\partial p}{\\partial r} = -\\frac{i\\omega \\rho_0 Q_0}{4\\pi r} \\exp(ikr) \\left(ik - \\frac{1}{r}\\right) = p(r) \\left(ik-\\frac{1}{r}\\right)\n$$\n将此代入$u_r(r)$的表达式中：\n$$\nu_r(r) = \\frac{p(r)}{i\\omega \\rho_0} \\left(ik - \\frac{1}{r}\\right) = \\frac{p(r)}{\\rho_0 c} \\left(1 - \\frac{1}{ikr}\\right) = \\frac{p(r)}{\\rho_0 c} \\left(1 + \\frac{i}{kr}\\right)\n$$\n将方程(5)中$p(r)$的表达式代入，得到$u_r(r)$更明确的形式：\n$$\nu_r(r) = \\left(-\\frac{i\\omega \\rho_0 Q_0}{4\\pi r} \\exp(ikr)\\right) \\frac{1}{i\\omega \\rho_0} \\left(ik - \\frac{1}{r}\\right) = -\\frac{Q_0}{4\\pi r} \\exp(ikr) \\left(ik - \\frac{1}{r}\\right)\n$$\n$$\nu_r(r) = \\frac{Q_0}{4\\pi r^2} \\exp(ikr)(1 - ikr)\n\\quad (6)\n$$\n\n**第三部分：无功能声能密度的计算**\n\n时间平均势能密度由$\\langle w_p(r)\\rangle = \\frac{|p(r)|^2}{4\\rho_0 c^2}$给出。我们首先求$|p(r)|^2$：\n$$\n|p(r)|^2 = \\left|-\\frac{i\\omega \\rho_0 Q_0}{4\\pi r} \\exp(ikr)\\right|^2 = \\frac{\\omega^2 \\rho_0^2 |Q_0|^2}{16\\pi^2 r^2} |-i|^2 |\\exp(ikr)|^2 = \\frac{\\omega^2 \\rho_0^2 |Q_0|^2}{16\\pi^2 r^2}\n$$\n因此，势能密度为：\n$$\n\\langle w_p(r) \\rangle = \\frac{1}{4\\rho_0 c^2} \\frac{\\omega^2 \\rho_0^2 |Q_0|^2}{16\\pi^2 r^2} = \\frac{\\omega^2 \\rho_0 |Q_0|^2}{64\\pi^2 c^2 r^2} = \\frac{k^2 \\rho_0 |Q_0|^2}{64\\pi^2 r^2}\n\\quad (7)\n$$\n时间平均动能密度由$\\langle w_k(r)\\rangle = \\frac{\\rho_0 |u_r(r)|^2}{4}$给出。我们首先求$|u_r(r)|^2$：\n$$\n|u_r(r)|^2 = \\left|\\frac{Q_0}{4\\pi r^2} \\exp(ikr)(1 - ikr)\\right|^2 = \\frac{|Q_0|^2}{16\\pi^2 r^4} |\\exp(ikr)|^2 |1 - ikr|^2\n$$\n由于$|1 - ikr|^2 = 1^2 + (-kr)^2 = 1 + k^2r^2$，我们有：\n$$\n|u_r(r)|^2 = \\frac{|Q_0|^2 (1 + k^2r^2)}{16\\pi^2 r^4}\n$$\n动能密度为：\n$$\n\\langle w_k(r) \\rangle = \\frac{\\rho_0}{4} \\frac{|Q_0|^2 (1 + k^2r^2)}{16\\pi^2 r^4} = \\frac{\\rho_0 |Q_0|^2 (1 + k^2r^2)}{64\\pi^2 r^4}\n\\quad (8)\n$$\n无功能声能密度定义为$w_{\\mathrm{re}}(r) = \\langle w_p(r)\\rangle - \\langle w_k(r)\\rangle$。代入方程(7)和(8)：\n$$\nw_{\\mathrm{re}}(r) = \\frac{k^2 \\rho_0 |Q_0|^2}{64\\pi^2 r^2} - \\frac{\\rho_0 |Q_0|^2 (1 + k^2r^2)}{64\\pi^2 r^4}\n$$\n为了合并这些项，我们使用公分母$64\\pi^2 r^4$：\n$$\nw_{\\mathrm{re}}(r) = \\frac{\\rho_0 |Q_0|^2}{64\\pi^2 r^4} \\left[ (k^2r^2) - (1 + k^2r^2) \\right]\n$$\n$$\nw_{\\mathrm{re}}(r) = \\frac{\\rho_0 |Q_0|^2}{64\\pi^2 r^4} [k^2r^2 - 1 - k^2r^2] = \\frac{\\rho_0 |Q_0|^2}{64\\pi^2 r^4} (-1)\n$$\n无功能声能密度的最终表达式为：\n$$\nw_{\\mathrm{re}}(r) = -\\frac{\\rho_0 |Q_0|^2}{64\\pi^2 r^4}\n$$\n\n**物理意义：**\n无功能声能密度$w_{\\mathrm{re}}(r)$代表声能场的局部、非传播分量。它量化了时间平均势能密度和动能密度之间的不平衡。\n- 在远场（$kr \\gg 1$）中，我们有$\\langle w_p \\rangle \\approx \\langle w_k \\rangle$，因此$w_{\\mathrm{re}}(r) \\to 0$。这表示一个传播波，其中能量在势能和动能形式之间平均分配，能量向外流动而不在局部存储。\n- 在近场（$kr \\ll 1$）中，动能密度$\\langle w_k \\rangle \\propto 1/r^4$主导了势能密度$\\langle w_p \\rangle \\propto k^2/r^2$。因此，$w_{\\mathrm{re}}(r) = \\langle w_p \\rangle - \\langle w_k \\rangle \\approx -\\langle w_k \\rangle$。无功能声能为大的负值，表明动能占主导地位。\n这种巨大的动能对应于紧邻脉动源周围的流体质量的“晃动”运动。这种运动不能有效地产生传播所需的压缩和稀疏。相反，它代表了在一个周期的一部分时间内存储在流体惯性中的能量，并在另一部分时间内返回到源，很像交流电路中电感器磁场中存储的能量。这个存储动能占主导的区域被称为无功近场。",
            "answer": "$$\n\\boxed{-\\frac{\\rho_0 |Q_0|^2}{64\\pi^2 r^4}}\n$$"
        },
        {
            "introduction": "在圆柱坐标系中模拟波对于具有轴对称性的问题至关重要，但这会在坐标轴（$r=0$）处引入一个数学奇点。由于这个奇点，朴素的有限元离散化可能会失败，因此需要通过变量替换将问题转化为能够被精确求解的正则形式。这个高级实践  将指导您推导并实现一种高阶有限元方法，该方法能正确处理轴心奇点，这是模拟圆柱波现象的一项关键技术。",
            "id": "4134647",
            "problem": "考虑在均匀、无损介质中的时谐声波传播。从声波方程出发，并假设解是可分离的，方位分解后的二维圆柱坐标系下的时谐场可简化为一个关于整数阶方位角模式$n$的径向边值问题。令$k$表示无量纲波数，令$r \\in [0,R]$表示径向坐标（所有量均为无量纲）。对于整数$n$，在轴线处精确的正则径向解在$r=0$附近的行为类似于$r^n$，且与第一类贝塞尔函数$J_n(kr)$成正比。\n\n您的任务是：\n1. 采用基于第一性原理的推导，从声波方程和可分离方位谐波的定义出发，推导出一个适用于圆柱坐标系下整数方位阶$n \\geq 0$的高阶有限元离散化的弱形式，该弱形式处理轴线$r=0$的方式能够保持在轴线附近行为类似于$r^n$的模式的正则性。\n2. 在一个独立的程序中实现所推导的弱形式，该程序在区间$[0,R]$上为变换后的未知量组装一个一维、高阶、$C^0$连续的有限元系统。每个单元使用次数为$p$的多项式，并采用包含$N_e$个均匀单元的协调网格。您的程序必须：\n   - 采用能确保单元间界面处协调性的基函数。\n   - 对于选定的$p$，使用足够精确的高斯求积来积分所有单元矩阵。\n   - 在$r=R$处施加与精确的$n$阶方位角模式一致的狄利克雷边界条件。\n   - 求解后，从变换后的未知量重构物理径向场。\n3. 通过计算数值解$R_h(r)$与精确贝塞尔解$J_n(kr)$之间的相对加权$L^2$误差来验证离散化，使用反映声能密度的圆柱权重。具体而言，计算\n   $$\\varepsilon = \\left( \\frac{\\int_0^R r \\left(R_h(r) - J_n(kr)\\right)^2 \\, dr}{\\int_0^R r \\left(J_n(kr)\\right)^2 \\, dr} \\right)^{1/2}.$$\n4. 将所有量视为无量纲。程序输出中不使用角度，因此不需要角度单位。\n\n推导约束：\n- 从声波方程和时谐解的可分离性出发；不要从直接跳到目标弱形式的简化公式开始。\n- 通过展示弱形式如何保持$r^n$的正则性来证明轴线处理的合理性。\n\n实现细节：\n- 每个单元使用次数为$p$的高阶有限元基函数，并在节点集中包含端点，以便在$r=R$处施加狄利克雷边界条件。\n- 使用足够阶数的高斯求积，以便在映射到物理坐标后，能精确积分最高为$2p$次的多项式。\n- 求解变换后的未知量后，重构$R_h(r)$并使用圆柱权重$r$的高斯求积来计算相对误差$\\varepsilon$。\n\n测试套件：\n在以下参数集$(n,k,R,p,N_e)$上评估您的实现：\n- 情况1（理想路径，基模）：$(0, 20.0, 1.0, 6, 12)$。\n- 情况2（轴线正则性压力测试，高阶方位角模式）：$(2, 15.0, 0.75, 5, 10)$。\n- 情况3（小域，中等波数）：$(1, 5.0, 0.2, 6, 4)$。\n- 情况4（高频，高阶方位角模式）：$(3, 35.0, 1.0, 8, 20)$。\n- 情况5（近准静态，小半径）：$(0, 0.5, 0.05, 4, 3)$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起（例如，“[result1,result2,result3]”）。每个结果必须是对应测试用例的相对加权$L^2$误差$\\varepsilon$，表示为浮点数。",
            "solution": "用户要求一个完整的、基于第一性原理的推导和高阶有限元方法的实现，用于求解时谐圆柱声波问题，并特别关注如何处理轴线$r=0$处的坐标奇异性。\n\n### 第1部分：弱形式的推导\n\n推导始于均匀、无损介质中声压场$P(\\mathbf{x}, t)$的标量声波方程：\n$$ \\nabla^2 P(\\mathbf{x}, t) - \\frac{1}{c^2} \\frac{\\partial^2 P(\\mathbf{x}, t)}{\\partial t^2} = 0 $$\n其中$c$是恒定的声速。我们假设形式为$P(\\mathbf{x}, t) = p(\\mathbf{x}) e^{-i\\omega t}$的时谐解，其中$\\omega$是角频率。将此代入波动方程，得到空间分量$p(\\mathbf{x})$的亥姆霍兹方程：\n$$ \\nabla^2 p(\\mathbf{x}) + k^2 p(\\mathbf{x}) = 0 $$\n其中$k = \\omega/c$是波数。\n\n在二维圆柱坐标$(r, \\theta)$中，拉普拉斯算子为$\\nabla^2 = \\frac{1}{r}\\frac{\\partial}{\\partial r}\\left(r\\frac{\\partial}{\\partial r}\\right) + \\frac{1}{r^2}\\frac{\\partial^2}{\\partial \\theta^2}$。亥姆霍兹方程变为：\n$$ \\frac{1}{r}\\frac{\\partial}{\\partial r}\\left(r\\frac{\\partial p}{\\partial r}\\right) + \\frac{1}{r^2}\\frac{\\partial^2 p}{\\partial \\theta^2} + k^2 p = 0 $$\n我们寻求形式为$p(r, \\theta) = R(r)\\Theta(\\theta)$的可分离解。将其代入方程并重新整理各项，可实现变量分离：\n$$ \\frac{1}{R(r)}\\frac{1}{r}\\frac{d}{dr}\\left(r\\frac{dR}{dr}\\right) + k^2 + \\frac{1}{r^2}\\frac{1}{\\Theta(\\theta)}\\frac{d^2\\Theta}{d\\theta^2} = 0 $$\n$$ \\frac{r}{R(r)}\\frac{d}{dr}\\left(r\\frac{dR}{dr}\\right) + k^2r^2 = -\\frac{1}{\\Theta(\\theta)}\\frac{d^2\\Theta}{d\\theta^2} $$\n由于左侧仅依赖于$r$而右侧仅依赖于$\\theta$，两者都必须等于一个常数，我们将其记为$n^2$。这产生了两个常微分方程（ODE）。方位角方程为：\n$$ \\frac{d^2\\Theta}{d\\theta^2} + n^2\\Theta = 0 $$\n为使解在角度上是单值的（即$\\Theta(\\theta) = \\Theta(\\theta+2\\pi)$），$n$必须是整数。解的形式为$e^{\\pm in\\theta}$。\n径向方程为：\n$$ \\frac{d}{dr}\\left(r\\frac{dR}{dr}\\right) + \\left(k^2r - \\frac{n^2}{r}\\right)R = 0 $$\n这是贝塞尔微分方程。为了使物理上的解在轴线$r=0$处是正则的（有限的），我们必须选择第一类贝塞尔函数，$R(r) = J_n(kr)$。对于整数$n \\ge 0$，$J_n(z)$在$z=0$附近的渐近行为是$J_n(z) \\sim \\frac{1}{n!}(\\frac{z}{2})^n$。因此，$R(r)$在轴线附近的行为类似于$r^n$。\n\n为推导此径向ODE的弱形式，通常会乘以一个检验函数$v(r)$并在定义域$[0, R]$上积分。\n$$ \\int_0^R \\left( -\\frac{d}{dr}\\left(r\\frac{dR}{dr}\\right)v + \\frac{n^2}{r}Rv \\right) dr = \\int_0^R k^2 r R v \\, dr $$\n对第一项进行分部积分会带来一个挑战。虽然$r=0$处的边界项消失了，但积分$\\int_0^R \\frac{n^2}{r}Rv \\, dr$在$n0$时是有问题的。如果对$R$和$v$使用标准的多项式基函数（它们在$r=0$处非零），被积函数的行为将类似于$1/r$，这是不可积的。\n\n为了解决这个奇异性并保持解的已知正则性，我们引入变量代换。令$R(r) = r^n U(r)$。由于已知$R(r)$的行为类似于$r^n$，新的未知变量$U(r)$在$r=0$处必须是正则的（$U(0)$是一个有限常数）。我们将此变换代入径向ODE。\n首先，我们求$R(r)$的导数：\n$R' = nr^{n-1}U + r^n U'$\n$rR' = nr^n U + r^{n+1} U'$\n然后，ODE的第一项变为：\n$\\frac{d}{dr}(rR') = \\frac{d}{dr}(nr^n U + r^{n+1} U') = n^2r^{n-1}U + nr^nU' + (n+1)r^nU' + r^{n+1}U'' = r^{n-1}n^2U + (2n+1)r^nU' + r^{n+1}U''$。\n将此代入径向ODE：\n$$ (r^{n-1}n^2U + (2n+1)r^nU' + r^{n+1}U'') + (k^2r - \\frac{n^2}{r})(r^nU) = 0 $$\n$$ r^{n-1}n^2U + (2n+1)r^nU' + r^{n+1}U'' + k^2r^{n+1}U - n^2r^{n-1}U = 0 $$\n奇异项$n^2r^{n-1}U$被消去，剩下：\n$$ r^{n+1}U'' + (2n+1)r^nU' + k^2r^{n+1}U = 0 $$\n除以$r^n$（对于$r0$）得到：\n$$ rU'' + (2n+1)U' + k^2rU = 0 $$\n这个ODE可以通过乘以积分因子$r^{2n}$写成一个更方便的自伴随形式：\n$$ r^{2n+1}U'' + (2n+1)r^{2n}U' + k^2r^{2n+1}U = 0 $$\n$$ \\frac{d}{dr}\\left( r^{2n+1} U' \\right) + k^2 r^{2n+1} U = 0 $$\n这是变换后问题的强形式。对于$n \\ge 0$，所有系数现在在$r=0$处都是正则的。由于$U(r)$在$r=0$处是正则的，并且是$r$的偶函数（从$J_n(kr)/r^n$的级数展开可知），其导数$U'(0) = 0$。这是一个自然边界条件，将被弱形式自动满足。\n\n现在，我们推导$U(r)$的弱形式。我们将自伴随形式乘以一个检验函数$v(r)$并在定义域$[0, R]$上积分：\n$$ \\int_0^R \\frac{d}{dr}\\left( r^{2n+1} U' \\right) v \\, dr + \\int_0^R k^2 r^{2n+1} U v \\, dr = 0 $$\n对第一项应用分部积分：\n$$ \\left[ r^{2n+1} U' v \\right]_0^R - \\int_0^R r^{2n+1} U' v' \\, dr + \\int_0^R k^2 r^{2n+1} U v \\, dr = 0 $$\n$r=0$处的边界项因为$2n+1 \\ge 1$而消失。在$r=R$处，我们将施加狄利克雷边界条件，因此我们选择检验函数$v$使得$v(R)=0$，这使得在$R$处的边界项也消失。最终的弱形式为：在适当的函数空间中找到$U$，使得对于所有容许的检验函数$v$：\n$$ \\int_0^R r^{2n+1} U' v' \\, dr - \\int_0^R k^2 r^{2n+1} U v \\, dr = 0 $$\n这个方程定义了有限元系统。我们将$U(r)$离散化为$U_h(r) = \\sum_j U_j \\phi_j(r)$，其中$\\phi_j$是$C^0$连续的多项式基函数，$U_j$是节点值。检验函数$v$从基函数$\\phi_i$中选取。这导出了线性系统：\n$$ (A - k^2 M) \\mathbf{U} = \\mathbf{0} $$\n其中刚度矩阵$A$和质量矩阵$M$的元素为：\n$$ A_{ij} = \\int_0^R r^{2n+1} \\phi_j'(r) \\phi_i'(r) \\, dr $$\n$$ M_{ij} = \\int_0^R r^{2n+1} \\phi_j(r) \\phi_i(r) \\, dr $$\n然后修改此系统以包含狄利克雷边界条件$R(R) = J_n(kR)$，这等价于$U(R) = J_n(kR)/R^n$。\n\n### 第2和3部分：实现与验证\n\n实现遵循推导出的弱形式。在区间$[0,R]$上创建一个包含$N_e$个均匀单元的网格。在每个单元上，我们使用次数为$p$的拉格朗日多项式的节点基。单元刚度矩阵和质量矩阵的积分使用高斯求积计算。选择具有$p+1$个点的求积规则，这对于包含最高为$2p$次多项式并乘以权重$r(\\xi)^{2n+1}$的被积函数，其精度是足够的。\n\n组装完全局矩阵$A$和$M$后，构建系统$(A-k^2M)\\mathbf{U}=\\mathbf{f}$。通过修改系统矩阵的最后一行和最后一列，并创建相应的右侧向量$\\mathbf{f}$来处理$r=R$处的狄利克雷条件。求解简化后的系统以获得$U_h$的未知节点值。\n\n物理场的数值解$R_h(r)$是通过关系式$R_h(r) = r^n U_h(r)$从变换后变量的解$U_h(r)$重构得到的。\n\n最后，计算相对加权$L^2$误差$\\varepsilon$。这需要计算两个积分：\n分子：$\\int_0^R r (R_h(r) - J_n(kr))^2 \\, dr$\n分母：$\\int_0^R r (J_n(kr))^2 \\, dr$\n这些积分是通过对每个单元的贡献求和来数值计算的，使用高阶高斯求积法则（含$2p$个点）以确保误差计算本身的准确性。这两个积分之比的平方根即为最终误差$\\varepsilon$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import jv, roots_legendre\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the problem-solving process.\n    It defines test cases and computes the relative error for each.\n    \"\"\"\n\n    def lagrange_basis(nodes, x):\n        \"\"\"\n        Evaluates 1D Lagrange basis polynomials and their derivatives defined on a set of nodes.\n\n        Args:\n            nodes (np.ndarray): 1D array of node coordinates for the basis.\n            x (np.ndarray): The point(s) at which to evaluate the basis.\n\n        Returns:\n            tuple[np.ndarray, np.ndarray]: A tuple of two arrays:\n                - values: shape (num_nodes, num_x_pts), L_i(x_j)\n                - derivatives: shape (num_nodes, num_x_pts), L'_i(x_j)\n        \"\"\"\n        num_nodes = len(nodes)\n        x = np.atleast_1d(x)\n        \n        values = np.zeros((num_nodes, len(x)))\n        derivatives = np.zeros((num_nodes, len(x)))\n        \n        for i in range(num_nodes):\n            # Denominator for L_i\n            den = np.prod([nodes[i] - nodes[j] for j in range(num_nodes) if i != j])\n            \n            # Numerator for L_i(x)\n            num = np.prod([x - nodes[j] for j in range(num_nodes) if i != j], axis=0)\n            values[i, :] = num / den\n            \n            # Derivative L'_i(x) = sum_{k!=i} ( prod_{j!=i,k} (x-x_j) ) / den\n            temp_sum = np.zeros_like(x, dtype=float)\n            for k in range(num_nodes):\n                if k == i:\n                    continue\n                \n                prod = np.prod([x - nodes[j] for j in range(num_nodes) if j != i and j != k], axis=0)\n                temp_sum += prod\n            \n            derivatives[i, :] = temp_sum / den\n            \n        return values, derivatives\n\n    def compute_fem_error(n, k, R, p, Ne):\n        \"\"\"\n        Computes the relative weighted L2 error for a given set of parameters.\n        \"\"\"\n        # 1. Setup and Discretization\n        h = R / Ne\n        num_dofs = Ne * p + 1\n        \n        # Reference element nodes (equispaced)\n        ref_nodes = np.linspace(-1, 1, p + 1)\n        \n        # Quadrature rules\n        # For assembly: p+1 points, exact for polynomials of degree 2p+1\n        q_nodes_asm, q_weights_asm = roots_legendre(p + 1)\n        # For error calculation: 2p points, higher accuracy\n        q_nodes_err, q_weights_err = roots_legendre(2 * p)\n\n        # Reference element basis functions evaluated at quadrature points\n        psi_asm, dpsi_asm = lagrange_basis(ref_nodes, q_nodes_asm)\n        psi_err, _ = lagrange_basis(ref_nodes, q_nodes_err) # Derivatives not needed for error value\n\n        # 2. Assembly of Global Matrices\n        A = np.zeros((num_dofs, num_dofs))\n        M = np.zeros((num_dofs, num_dofs))\n        \n        for e in range(Ne):\n            r_e_start = e * h\n            \n            # Element matrices\n            A_e = np.zeros((p + 1, p + 1))\n            M_e = np.zeros((p + 1, p + 1))\n\n            # Jacobian of transformation from reference to physical element\n            J = h / 2.0\n            \n            for q_idx, xi_q in enumerate(q_nodes_asm):\n                w_q = q_weights_asm[q_idx]\n                r_q = r_e_start + J * (1 + xi_q)\n\n                for i in range(p + 1):\n                    for j in range(p + 1):\n                        dpsi_i_dr = dpsi_asm[i, q_idx] / J\n                        dpsi_j_dr = dpsi_asm[j, q_idx] / J\n                        \n                        weight_r = r_q**(2 * n + 1)\n                        \n                        A_e[i, j] += weight_r * dpsi_i_dr * dpsi_j_dr * w_q * J\n                        M_e[i, j] += weight_r * psi_asm[i, q_idx] * psi_asm[j, q_idx] * w_q * J\n            \n            # Assemble element matrices into global matrices\n            for i in range(p + 1):\n                gi = e * p + i\n                for j in range(p + 1):\n                    gj = e * p + j\n                    A[gi, gj] += A_e[i, j]\n                    M[gi, gj] += M_e[i, j]\n\n        # 3. Solve the Linear System with Dirichlet BC\n        S = A - k**2 * M\n        \n        # BC value for the transformed variable U at r=R\n        U_bc = jv(n, k * R) / (R**n if R > 0 else 1.0)\n        \n        # Modify system for Dirichlet BC\n        S_reduced = S[:-1, :-1]\n        rhs = -S[:-1, -1] * U_bc\n        \n        # Solve for unknown DOFs\n        U_unknowns = np.linalg.solve(S_reduced, rhs)\n        \n        # Combine known and computed DOFs\n        U_sol = np.append(U_unknowns, U_bc)\n\n        # 4. Error Calculation\n        error_num_integral = 0.0\n        error_den_integral = 0.0\n        \n        for e in range(Ne):\n            r_e_start = e * h\n            J = h / 2.0\n            local_dof_indices = np.arange(e * p, e * p + p + 1)\n            U_local = U_sol[local_dof_indices]\n\n            for q_idx, xi_q in enumerate(q_nodes_err):\n                w_q = q_weights_err[q_idx]\n                r_q = r_e_start + J * (1 + xi_q)\n                \n                # Evaluate numerical solution U_h at quadrature point\n                U_h_at_rq = np.dot(U_local, psi_err[:, q_idx])\n                \n                # Reconstruct physical solution R_h\n                R_h_at_rq = (r_q**n) * U_h_at_rq\n                \n                # Exact solution R\n                R_exact_at_rq = jv(n, k * r_q)\n                \n                # Accumulate weighted integrals\n                error_num_integral += r_q * (R_h_at_rq - R_exact_at_rq)**2 * w_q * J\n                error_den_integral += r_q * (R_exact_at_rq)**2 * w_q * J\n        \n        if error_den_integral == 0.0:\n            return 0.0 if error_num_integral == 0.0 else np.inf\n\n        relative_error = np.sqrt(error_num_integral / error_den_integral)\n        return relative_error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 20.0, 1.0, 6, 12),\n        (2, 15.0, 0.75, 5, 10),\n        (1, 5.0, 0.2, 6, 4),\n        (3, 35.0, 1.0, 8, 20),\n        (0, 0.5, 0.05, 4, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, k, R, p, Ne = case\n        result = compute_fem_error(n, k, R, p, Ne)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}