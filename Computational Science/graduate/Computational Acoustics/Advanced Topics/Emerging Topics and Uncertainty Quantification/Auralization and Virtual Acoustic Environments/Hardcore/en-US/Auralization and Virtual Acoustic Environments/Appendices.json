{
    "hands_on_practices": [
        {
            "introduction": "At the heart of many physically-based auralization systems lies a numerical wave solver. This first practice delves into the fundamental properties of the Finite-Difference Time-Domain (FDTD) method, a cornerstone of computational acoustics. By deriving the discrete dispersion relation, you will gain critical insight into the sources of numerical error and the trade-offs between accuracy, grid resolution, and computational cost, a crucial skill for validating any wave-based simulation .",
            "id": "4117107",
            "problem": "In room acoustic auralization for virtual acoustic environments, wave-based propagation models are used to synthesize physically plausible impulse responses. Consider the linear acoustic wave equation in a homogeneous, lossless medium,\n$$\n\\frac{\\partial^{2} u(\\mathbf{x},t)}{\\partial t^{2}} = c^{2} \\nabla^{2} u(\\mathbf{x},t),\n$$\ndiscretized by a standard second-order explicit scheme on a uniform Cartesian grid with spacing $\\Delta x$ in all three spatial directions and a time step $\\Delta t$. The Courant number is defined as $C = c \\Delta t / \\Delta x$. Assume a three-dimensional ($3$D) computational domain sufficiently large to neglect boundary effects. Use the method of Finite-Difference Time-Domain (FDTD), that is, centered differences in time and the standard $7$-point discrete Laplacian in space on a collocated grid.\n\nAssume a discrete plane-wave solution of the form\n$$\nu^{n}_{i,j,k} = U \\exp\\!\\left( \\mathrm{i} \\big( k_{x} i \\Delta x + k_{y} j \\Delta x + k_{z} k \\Delta x - \\omega n \\Delta t \\big) \\right),\n$$\nwhere $U \\in \\mathbb{C}$ is a constant amplitude, $(i,j,k) \\in \\mathbb{Z}^{3}$ indexes grid points, $n \\in \\mathbb{Z}$ indexes time steps, $\\mathbf{k}=(k_{x},k_{y},k_{z})$ is the continuous wavevector, and $\\omega$ is the angular frequency. Let $\\kappa_{x} = k_{x} \\Delta x$, $\\kappa_{y} = k_{y} \\Delta x$, and $\\kappa_{z} = k_{z} \\Delta x$ denote the dimensionless wavenumber components.\n\nStarting from the continuous wave equation and the described finite-difference approximations as the only allowed base, derive the discrete dispersion relation linking $\\omega$ and $(k_{x},k_{y},k_{z})$. From this, define the phase velocity $v_{p} = \\omega / k$ with $k = \\sqrt{k_{x}^{2} + k_{y}^{2} + k_{z}^{2}}$, and derive the relative phase velocity error\n$$\n\\varepsilon = \\frac{v_{p}}{c} - 1\n$$\nas a closed-form analytic expression in terms of the Courant number $C$ and the dimensionless wavenumber components $(\\kappa_{x}, \\kappa_{y}, \\kappa_{z})$. Express your final answer for $\\varepsilon$ in exact analytic form with no numerical evaluation. No rounding is required. State your final expression in terms of $C$, $\\kappa_{x}$, $\\kappa_{y}$, and $\\kappa_{z}$ only.",
            "solution": "The problem statement is subjected to validation.\n\n### Step 1: Extract Givens\n-   Continuous wave equation: $\\frac{\\partial^{2} u(\\mathbf{x},t)}{\\partial t^{2}} = c^{2} \\nabla^{2} u(\\mathbf{x},t)$.\n-   Medium characteristics: Homogeneous, lossless.\n-   Discretization scheme: Standard second-order explicit finite-difference scheme.\n-   Grid: Uniform Cartesian grid, spacing $\\Delta x$ in three spatial dimensions ($3$D).\n-   Time step: $\\Delta t$.\n-   Courant number: $C = c \\Delta t / \\Delta x$.\n-   Computational Domain: Sufficiently large to neglect boundary effects.\n-   Numerical Method: Finite-Difference Time-Domain (FDTD) with centered differences in time and the standard $7$-point discrete Laplacian in space on a collocated grid.\n-   Assumed discrete solution form: $u^{n}_{i,j,k} = U \\exp\\!\\left( \\mathrm{i} \\big( k_{x} i \\Delta x + k_{y} j \\Delta x + k_{z} k \\Delta x - \\omega n \\Delta t \\big) \\right)$.\n-   Variable definitions: $U \\in \\mathbb{C}$ is a constant amplitude, $(i,j,k) \\in \\mathbb{Z}^{3}$ are spatial grid indices, $n \\in \\mathbb{Z}$ is the time step index, $\\mathbf{k}=(k_{x},k_{y},k_{z})$ is the continuous wavevector, and $\\omega$ is the angular frequency.\n-   Dimensionless wavenumbers: $\\kappa_{x} = k_{x} \\Delta x$, $\\kappa_{y} = k_{y} \\Delta x$, and $\\kappa_{z} = k_{z} \\Delta x$.\n-   Phase velocity definition: $v_{p} = \\omega / k$, with $k = \\sqrt{k_{x}^{2} + k_{y}^{2} + k_{z}^{2}}$.\n-   Relative phase velocity error definition: $\\varepsilon = \\frac{v_{p}}{c} - 1$.\n-   Objective: Derive a closed-form analytic expression for $\\varepsilon$ in terms of $C$, $\\kappa_{x}$, $\\kappa_{y}$, and $\\kappa_{z}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, rooted in the fundamental analysis of numerical methods for partial differential equations, specifically the wave equation, which is a cornerstone of computational acoustics. It is well-posed, providing all necessary definitions and constraints to derive a unique analytical solution. The language is objective and precise. The setup is complete and internally consistent. The scenario described is a standard procedure for analyzing the numerical dispersion of FDTD schemes, which is a realistic and essential task in scientific computing. The problem is non-trivial, requiring a multi-step derivation involving careful algebraic manipulation.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be derived as requested.\n\nThe derivation proceeds by first discretizing the continuous wave equation using the specified finite-difference approximations, and then substituting the given plane-wave ansatz to find the discrete dispersion relation.\n\nThe continuous wave equation in three dimensions is:\n$$\n\\frac{\\partial^{2} u}{\\partial t^{2}} = c^{2} \\left( \\frac{\\partial^{2} u}{\\partial x^{2}} + \\frac{\\partial^{2} u}{\\partial y^{2}} + \\frac{\\partial^{2} u}{\\partial z^{2}} \\right)\n$$\nLet a grid point be denoted by $(i\\Delta x, j\\Delta x, k\\Delta x)$ and a time step by $n\\Delta t$. The value of the field $u$ at this point in spacetime is $u^{n}_{i,j,k}$.\n\nThe second-order centered difference approximation for the time derivative is:\n$$\n\\frac{\\partial^{2} u}{\\partial t^{2}} \\approx \\frac{u^{n+1}_{i,j,k} - 2u^{n}_{i,j,k} + u^{n-1}_{i,j,k}}{(\\Delta t)^{2}}\n$$\nThe standard $7$-point stencil for the spatial Laplacian on a collocated grid is:\n$$\n\\nabla^{2} u \\approx \\frac{u^{n}_{i+1,j,k} + u^{n}_{i-1,j,k} - 2u^{n}_{i,j,k}}{(\\Delta x)^{2}} + \\frac{u^{n}_{i,j+1,k} + u^{n}_{i,j-1,k} - 2u^{n}_{i,j,k}}{(\\Delta x)^{2}} + \\frac{u^{n}_{i,j,k+1} + u^{n}_{i,j,k-1} - 2u^{n}_{i,j,k}}{(\\Delta x)^{2}}\n$$\nCombining these approximations gives the FDTD scheme for the wave equation:\n$$\n\\frac{u^{n+1}_{i,j,k} - 2u^{n}_{i,j,k} + u^{n-1}_{i,j,k}}{(\\Delta t)^{2}} = \\frac{c^{2}}{(\\Delta x)^{2}} \\left( u^{n}_{i+1,j,k} + u^{n}_{i-1,j,k} + u^{n}_{i,j+1,k} + u^{n}_{i,j-1,k} + u^{n}_{i,j,k+1} + u^{n}_{i,j,k-1} - 6u^{n}_{i,j,k} \\right)\n$$\nNow, substitute the discrete plane-wave solution $u^{n}_{i,j,k} = U \\exp\\left( \\mathrm{i} (i\\kappa_{x} + j\\kappa_{y} + k\\kappa_{z} - n\\omega\\Delta t) \\right)$ into the FDTD equation. Note that $\\kappa_{d} = k_{d}\\Delta x$ for $d \\in \\{x,y,z\\}$.\nThe common factor $U \\exp\\left( \\mathrm{i} (i\\kappa_{x} + j\\kappa_{y} + k\\kappa_{z} - n\\omega\\Delta t) \\right)$ will be present in every term and can be canceled. We are left with phase factors corresponding to the shifts in indices.\n\nFor the left-hand side (LHS):\n$$\n\\frac{1}{(\\Delta t)^{2}} \\left( \\exp(-\\mathrm{i}\\omega\\Delta t) - 2 + \\exp(\\mathrm{i}\\omega\\Delta t) \\right) = \\frac{2}{(\\Delta t)^{2}} (\\cos(\\omega\\Delta t) - 1)\n$$\nUsing the half-angle identity $1 - \\cos(\\theta) = 2\\sin^{2}(\\theta/2)$, the LHS becomes:\n$$\n-\\frac{4}{(\\Delta t)^{2}} \\sin^{2}\\left(\\frac{\\omega\\Delta t}{2}\\right)\n$$\nFor the right-hand side (RHS):\n$$\n\\frac{c^{2}}{(\\Delta x)^{2}} \\left( (\\exp(\\mathrm{i}\\kappa_{x}) + \\exp(-\\mathrm{i}\\kappa_{x})) + (\\exp(\\mathrm{i}\\kappa_{y}) + \\exp(-\\mathrm{i}\\kappa_{y})) + (\\exp(\\mathrm{i}\\kappa_{z}) + \\exp(-\\mathrm{i}\\kappa_{z})) - 6 \\right)\n$$\nThis simplifies using Euler's identity $2\\cos\\theta = e^{i\\theta} + e^{-i\\theta}$:\n$$\n\\frac{c^{2}}{(\\Delta x)^{2}} \\left( 2\\cos(\\kappa_{x}) + 2\\cos(\\kappa_{y}) + 2\\cos(\\kappa_{z}) - 6 \\right) = \\frac{2c^{2}}{(\\Delta x)^{2}} \\left( \\cos(\\kappa_{x}) - 1 + \\cos(\\kappa_{y}) - 1 + \\cos(\\kappa_{z}) - 1 \\right)\n$$\nApplying the same half-angle identity, the RHS becomes:\n$$\n-\\frac{4c^{2}}{(\\Delta x)^{2}} \\left( \\sin^{2}\\left(\\frac{\\kappa_{x}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{y}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{z}}{2}\\right) \\right)\n$$\nEquating the simplified LHS and RHS:\n$$\n-\\frac{4}{(\\Delta t)^{2}} \\sin^{2}\\left(\\frac{\\omega\\Delta t}{2}\\right) = -\\frac{4c^{2}}{(\\Delta x)^{2}} \\left( \\sin^{2}\\left(\\frac{\\kappa_{x}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{y}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{z}}{2}\\right) \\right)\n$$\nCanceling the factor of $-4$ and rearranging gives the discrete dispersion relation:\n$$\n\\sin^{2}\\left(\\frac{\\omega\\Delta t}{2}\\right) = \\left(\\frac{c\\Delta t}{\\Delta x}\\right)^{2} \\left[ \\sin^{2}\\left(\\frac{\\kappa_{x}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{y}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{z}}{2}\\right) \\right]\n$$\nUsing the Courant number $C = c\\Delta t/\\Delta x$:\n$$\n\\sin^{2}\\left(\\frac{\\omega\\Delta t}{2}\\right) = C^{2} \\left[ \\sin^{2}\\left(\\frac{\\kappa_{x}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{y}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{z}}{2}\\right) \\right]\n$$\nTo find $\\omega$, we take the square root (assuming positive frequency) and then the arcsin:\n$$\n\\sin\\left(\\frac{\\omega\\Delta t}{2}\\right) = C \\sqrt{\\sin^{2}\\left(\\frac{\\kappa_{x}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{y}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{z}}{2}\\right)}\n$$\n$$\n\\omega = \\frac{2}{\\Delta t} \\arcsin\\left( C \\sqrt{\\sin^{2}\\left(\\frac{\\kappa_{x}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{y}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{z}}{2}\\right)} \\right)\n$$\nThe numerical phase velocity is $v_{p} = \\omega/k$. The relative phase velocity error is $\\varepsilon = v_{p}/c - 1 = \\omega/(ck) - 1$.\nWe need to express this in terms of $C$ and $\\kappa_{d}$. We have $k = \\sqrt{k_{x}^{2}+k_{y}^{2}+k_{z}^{2}}$. Since $\\kappa_{d}=k_{d}\\Delta x$, we can write $k_{d}=\\kappa_{d}/\\Delta x$. Thus,\n$$\nk = \\sqrt{\\left(\\frac{\\kappa_{x}}{\\Delta x}\\right)^{2} + \\left(\\frac{\\kappa_{y}}{\\Delta x}\\right)^{2} + \\left(\\frac{\\kappa_{z}}{\\Delta x}\\right)^{2}} = \\frac{1}{\\Delta x}\\sqrt{\\kappa_{x}^{2}+\\kappa_{y}^{2}+\\kappa_{z}^{2}}\n$$\nNow substitute $\\omega$ and $k$ into the expression for $\\varepsilon$:\n$$\n\\varepsilon = \\frac{1}{ck} \\left( \\frac{2}{\\Delta t} \\arcsin\\left( C \\sqrt{\\sum_{d}\\sin^{2}\\left(\\frac{\\kappa_{d}}{2}\\right)} \\right) \\right) - 1\n$$\nLet's analyze the term $1/(ck)$:\n$$\n\\frac{1}{ck} = \\frac{1}{c \\frac{1}{\\Delta x}\\sqrt{\\kappa_{x}^{2}+\\kappa_{y}^{2}+\\kappa_{z}^{2}}} = \\frac{\\Delta x}{c \\sqrt{\\kappa_{x}^{2}+\\kappa_{y}^{2}+\\kappa_{z}^{2}}}\n$$\nThe complete pre-factor is $\\frac{1}{ck\\Delta t}$:\n$$\n\\frac{1}{ck\\Delta t} = \\frac{\\Delta x}{c \\Delta t \\sqrt{\\kappa_{x}^{2}+\\kappa_{y}^{2}+\\kappa_{z}^{2}}}\n$$\nUsing the Courant number $C = c\\Delta t/\\Delta x$, we can write $c\\Delta t = C\\Delta x$.\n$$\n\\frac{1}{ck\\Delta t} = \\frac{\\Delta x}{C\\Delta x \\sqrt{\\kappa_{x}^{2}+\\kappa_{y}^{2}+\\kappa_{z}^{2}}} = \\frac{1}{C\\sqrt{\\kappa_{x}^{2}+\\kappa_{y}^{2}+\\kappa_{z}^{2}}}\n$$\nSubstituting this back into the expression for $\\varepsilon$:\n$$\n\\varepsilon = \\frac{2}{C\\sqrt{\\kappa_{x}^{2}+\\kappa_{y}^{2}+\\kappa_{z}^{2}}} \\arcsin\\left( C \\sqrt{\\sin^{2}\\left(\\frac{\\kappa_{x}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{y}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{z}}{2}\\right)} \\right) - 1\n$$\nThis is the final closed-form expression for the relative phase velocity error in terms of the specified variables.",
            "answer": "$$\n\\boxed{\\frac{2}{C \\sqrt{\\kappa_{x}^{2} + \\kappa_{y}^{2} + \\kappa_{z}^{2}}} \\arcsin\\left( C \\sqrt{ \\sin^{2}\\left(\\frac{\\kappa_{x}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{y}}{2}\\right) + \\sin^{2}\\left(\\frac{\\kappa_{z}}{2}\\right) } \\right) - 1}\n$$"
        },
        {
            "introduction": "Once a simulation environment is established, we need efficient methods to compute the acoustic field. This practice introduces importance sampling, a powerful Monte Carlo technique used to dramatically accelerate rendering by focusing computational effort on the most acoustically significant paths . You will derive an optimal sampling strategy from first principles and implement it, providing a direct experience with variance reduction techniques that are vital for real-time ray-based and path-based auralization.",
            "id": "4117140",
            "problem": "You are tasked with designing an importance sampling strategy for ray directions on the unit sphere for binaural auralization in virtual acoustic environments. The goal is to minimize the variance of Monte Carlo estimators of binaural energy metrics by shaping the sampling distribution according to both the source directivity and the listenerâ€™s directional sensitivity (as approximated by a Head-Related Transfer Function (HRTF)). Work in the free-field without reflections so that the binaural energy depends only on the direction.\n\nStart from the following fundamental base: Monte Carlo estimation for an integral over the unit sphere. Let $\\Omega$ denote the unit sphere in $\\mathbb{R}^3$ and let $d\\Omega$ denote the surface measure. Given a nonnegative integrand $f(\\boldsymbol{\\omega})$ and a probability density function $p(\\boldsymbol{\\omega})$ defined on $\\Omega$ with respect to $d\\Omega$, the Monte Carlo estimator for the integral $I=\\int_{\\Omega} f(\\boldsymbol{\\omega})\\,d\\Omega$ using $N$ independent samples $\\boldsymbol{\\omega}_i \\sim p$ is $\\hat{I}=\\frac{1}{N}\\sum_{i=1}^{N}\\frac{f(\\boldsymbol{\\omega}_i)}{p(\\boldsymbol{\\omega}_i)}$. Its variance is $\\mathrm{Var}[\\hat{I}]=\\frac{1}{N}\\left(\\int_{\\Omega}\\frac{f(\\boldsymbol{\\omega})^2}{p(\\boldsymbol{\\omega})}\\,d\\Omega - I^2\\right)$.\n\nDefine the binaural integrands for the left and right ears by\n$$\nf_L(\\boldsymbol{\\omega}) = D_s(\\boldsymbol{\\omega})\\,S_L(\\boldsymbol{\\omega}),\\quad\nf_R(\\boldsymbol{\\omega}) = D_s(\\boldsymbol{\\omega})\\,S_R(\\boldsymbol{\\omega}),\n$$\nwhere $D_s(\\boldsymbol{\\omega})$ is the source directivity and $S_L(\\boldsymbol{\\omega})$, $S_R(\\boldsymbol{\\omega})$ are directional sensitivity functions for the left and right ear respectively. Use a parametric, unit-vector-based axis model for directionality:\n$$\nP(\\boldsymbol{\\omega};\\boldsymbol{a},n) = \\max\\left(0,\\ \\boldsymbol{a}\\cdot\\boldsymbol{\\omega}\\right)^n,\n$$\nwhere $\\boldsymbol{a}$ is a unit vector giving the axis of maximum response, $n$ is a nonnegative exponent controlling lobe sharpness, and $\\boldsymbol{a}\\cdot\\boldsymbol{\\omega}$ is the cosine of the angle between the axis and the direction. In this model, set $D_s(\\boldsymbol{\\omega})=P(\\boldsymbol{\\omega};\\boldsymbol{a}_s,m)$ with source axis $\\boldsymbol{a}_s$ and exponent $m$, and $S_L(\\boldsymbol{\\omega})=P(\\boldsymbol{\\omega};\\boldsymbol{a}_L,n_L)$, $S_R(\\boldsymbol{\\omega})=P(\\boldsymbol{\\omega};\\boldsymbol{a}_R,n_R)$ with ear axes $\\boldsymbol{a}_L$, $\\boldsymbol{a}_R$ and exponents $n_L$, $n_R$.\n\nAngles must be handled in radians. Parameterize $\\boldsymbol{\\omega}$ by spherical coordinates $(\\theta,\\phi)$ with $\\theta\\in[0,\\pi]$ the polar angle measured from the $+z$ axis and $\\phi\\in[0,2\\pi)$ the azimuth. The Cartesian unit direction corresponding to $(\\theta,\\phi)$ is\n$$\n\\boldsymbol{\\omega}(\\theta,\\phi) = \\left(\\sin\\theta\\cos\\phi,\\ \\sin\\theta\\sin\\phi,\\ \\cos\\theta\\right),\n$$\nand the differential surface element is $d\\Omega = \\sin\\theta\\,d\\theta\\,d\\phi$.\n\nYou must derive, from the variance expression and first principles of importance sampling, a sampling density $p^\\star(\\boldsymbol{\\omega})$ that minimizes a weighted sum of variances for the left and right ear estimators. Specifically, for positive weights $w_L$ and $w_R$, minimize\n$$\n\\Psi(p) = w_L\\left(\\int_{\\Omega}\\frac{f_L(\\boldsymbol{\\omega})^2}{p(\\boldsymbol{\\omega})}\\,d\\Omega - I_L^2\\right) + w_R\\left(\\int_{\\Omega}\\frac{f_R(\\boldsymbol{\\omega})^2}{p(\\boldsymbol{\\omega})}\\,d\\Omega - I_R^2\\right),\n$$\nsubject to the constraint $\\int_{\\Omega} p(\\boldsymbol{\\omega})\\,d\\Omega = 1$, where $I_L=\\int_{\\Omega} f_L(\\boldsymbol{\\omega})\\,d\\Omega$ and $I_R=\\int_{\\Omega} f_R(\\boldsymbol{\\omega})\\,d\\Omega$.\n\nThen, implement a numerical integration on a spherical grid to evaluate, for a set of test cases, the weighted sum-of-variances under:\n- Uniform sampling $p_u(\\boldsymbol{\\omega}) = \\frac{1}{4\\pi}$,\n- The optimal combined sampling $p^\\star(\\boldsymbol{\\omega})$ you derived.\n\nFor numerical stability, treat the quotient $\\frac{f_k(\\boldsymbol{\\omega})^2}{p(\\boldsymbol{\\omega})}$ as $0$ wherever both the numerator and denominator are $0$. Angles are in radians and all quantities are dimensionless for this free-field directional model.\n\nTest Suite:\nUse the following three test cases to assess the variance reduction achieved by $p^\\star$ relative to $p_u$. In all cases, set $w_L=w_R=\\frac{1}{2}$, $\\boldsymbol{a}_L=(0,1,0)$ (left ear axis along $+y$), $\\boldsymbol{a}_R=(0,-1,0)$ (right ear axis along $-y$).\n- Case A (boundary, isotropic source): $m=0$, $n_L=2$, $n_R=2$, $\\boldsymbol{a}_s=(1,0,0)$.\n- Case B (happy path, aligned directional source): $m=8$, $n_L=4$, $n_R=4$, $\\boldsymbol{a}_s=(0,1,0)$.\n- Case C (edge, extremely narrow ear lobes): $m=4$, $n_L=16$, $n_R=16$, $\\boldsymbol{a}_s=(1,0,0)$.\n\nRequired final outputs:\nFor each case, compute the ratio $r=\\frac{\\Psi(p^\\star)}{\\Psi(p_u)}$, where lower values indicate variance reduction. Your program should produce a single line of output containing the three ratios for Cases A, B, and C as a comma-separated list enclosed in square brackets (e.g., $[r_A,r_B,r_C]$). All angles must be in radians. The outputs must be floating-point numbers.",
            "solution": "The user has provided a well-posed problem in computational acoustics that is scientifically grounded and mathematically tractable. It requires the derivation of an optimal importance sampling density and its numerical evaluation against a baseline. The problem statement is complete, consistent, and adheres to the principles of mathematics and physics. Therefore, I will proceed with a full solution.\n\nThe objective is to derive an importance sampling probability density function (PDF) $p(\\boldsymbol{\\omega})$ on the unit sphere $\\Omega$ that minimizes a weighted sum of variances for Monte Carlo estimators of left-ear and right-ear energy integrals, $I_L = \\int_{\\Omega} f_L(\\boldsymbol{\\omega})d\\Omega$ and $I_R = \\int_{\\Omega} f_R(\\boldsymbol{\\omega})d\\Omega$.\n\nThe total quantity to minimize, which is proportional to the weighted sum of variances, is given by:\n$$\n\\Psi(p) = w_L\\left(\\int_{\\Omega}\\frac{f_L(\\boldsymbol{\\omega})^2}{p(\\boldsymbol{\\omega})}\\,d\\Omega - I_L^2\\right) + w_R\\left(\\int_{\\Omega}\\frac{f_R(\\boldsymbol{\\omega})^2}{p(\\boldsymbol{\\omega})}\\,d\\Omega - I_R^2\\right)\n$$\nThis minimization is subject to the constraint that $p(\\boldsymbol{\\omega})$ must be a valid PDF, i.e., $p(\\boldsymbol{\\omega}) \\ge 0$ for all $\\boldsymbol{\\omega} \\in \\Omega$ and $\\int_{\\Omega} p(\\boldsymbol{\\omega})\\,d\\Omega = 1$.\n\nThe terms $-w_L I_L^2$ and $-w_R I_R^2$ are constant with respect to the choice of $p(\\boldsymbol{\\omega})$. Thus, minimizing $\\Psi(p)$ is equivalent to minimizing the functional $J(p)$:\n$$\nJ(p) = \\int_{\\Omega} \\frac{w_L f_L(\\boldsymbol{\\omega})^2 + w_R f_R(\\boldsymbol{\\omega})^2}{p(\\boldsymbol{\\omega})} \\,d\\Omega\n$$\nFor notational simplicity, let us define a combined function $g(\\boldsymbol{\\omega}) = w_L f_L(\\boldsymbol{\\omega})^2 + w_R f_R(\\boldsymbol{\\omega})^2$. The problem reduces to minimizing $J(p) = \\int_{\\Omega} \\frac{g(\\boldsymbol{\\omega})}{p(\\boldsymbol{\\omega})} \\,d\\Omega$ subject to $\\int_{\\Omega} p(\\boldsymbol{\\omega})\\,d\\Omega = 1$.\n\nWe solve this isoperimetric problem using the method of Lagrange multipliers. The Lagrangian functional $\\mathcal{L}$ is:\n$$\n\\mathcal{L}(p, \\lambda) = J(p) - \\lambda \\left(\\int_{\\Omega} p(\\boldsymbol{\\omega})\\,d\\Omega - 1\\right) = \\int_{\\Omega} \\left( \\frac{g(\\boldsymbol{\\omega})}{p(\\boldsymbol{\\omega})} - \\lambda p(\\boldsymbol{\\omega}) \\right) \\,d\\Omega + \\lambda\n$$\nTo find the optimal function $p^\\star(\\boldsymbol{\\omega})$ that minimizes $\\mathcal{L}$, we compute the functional derivative with respect to $p$ and set it to zero:\n$$\n\\frac{\\delta \\mathcal{L}}{\\delta p(\\boldsymbol{\\omega}')} = -\\frac{g(\\boldsymbol{\\omega}')}{p^\\star(\\boldsymbol{\\omega}')^2} - \\lambda = 0\n$$\nSolving for $p^\\star(\\boldsymbol{\\omega}')$, we find:\n$$\np^\\star(\\boldsymbol{\\omega}')^2 = -\\frac{g(\\boldsymbol{\\omega}')}{\\lambda}\n$$\nSince $g(\\boldsymbol{\\omega}) \\ge 0$ and $p^\\star(\\boldsymbol{\\omega}) \\ge 0$, the Lagrange multiplier $\\lambda$ must be negative. Let $\\lambda = -C^2$ for some positive constant $C$. This gives:\n$$\np^\\star(\\boldsymbol{\\omega}) = \\frac{\\sqrt{g(\\boldsymbol{\\omega})}}{C}\n$$\nThe constant $C$ is determined by the normalization constraint $\\int_{\\Omega} p^\\star(\\boldsymbol{\\omega})\\,d\\Omega = 1$:\n$$\n\\int_{\\Omega} \\frac{\\sqrt{g(\\boldsymbol{\\omega})}}{C} \\,d\\Omega = 1 \\quad \\implies \\quad C = \\int_{\\Omega} \\sqrt{g(\\boldsymbol{\\omega})} \\,d\\Omega\n$$\nTherefore, the optimal probability density function, denoted $p^\\star(\\boldsymbol{\\omega})$, is:\n$$\np^\\star(\\boldsymbol{\\omega}) = \\frac{\\sqrt{g(\\boldsymbol{\\omega})}}{\\int_{\\Omega} \\sqrt{g(\\boldsymbol{\\omega}')} \\,d\\Omega'} = \\frac{\\sqrt{w_L f_L(\\boldsymbol{\\omega})^2 + w_R f_R(\\boldsymbol{\\omega})^2}}{\\int_{\\Omega} \\sqrt{w_L f_L(\\boldsymbol{\\omega}')^2 + w_R f_R(\\boldsymbol{\\omega}')^2} \\,d\\Omega'}\n$$\nNext, we formulate the expressions for $\\Psi(p)$ under uniform sampling $p_u(\\boldsymbol{\\omega})$ and optimal sampling $p^\\star(\\boldsymbol{\\omega})$ to evaluate the performance improvement. The quantity to evaluate is the ratio $r = \\frac{\\Psi(p^\\star)}{\\Psi(p_u)}$.\n\nLet $I_{const}^2 = w_L I_L^2 + w_R I_R^2$. The variance functional is $\\Psi(p) = \\int_{\\Omega} \\frac{g(\\boldsymbol{\\omega})}{p(\\boldsymbol{\\omega})}d\\Omega - I_{const}^2$.\n\nFor uniform sampling, $p_u(\\boldsymbol{\\omega}) = \\frac{1}{4\\pi}$. The integral term becomes:\n$$\nV(p_u) = \\int_{\\Omega} \\frac{g(\\boldsymbol{\\omega})}{1/(4\\pi)} \\,d\\Omega = 4\\pi \\int_{\\Omega} g(\\boldsymbol{\\omega}) \\,d\\Omega\n$$\nSo, $\\Psi(p_u) = 4\\pi \\int_{\\Omega} g(\\boldsymbol{\\omega}) \\,d\\Omega - I_{const}^2$.\n\nFor the optimal sampler $p^\\star(\\boldsymbol{\\omega}) = \\frac{\\sqrt{g(\\boldsymbol{\\omega})}}{C}$, the integral term is:\n$$\nV(p^\\star) = \\int_{\\Omega} \\frac{g(\\boldsymbol{\\omega})}{\\sqrt{g(\\boldsymbol{\\omega})}/C} \\,d\\Omega = C \\int_{\\Omega} \\sqrt{g(\\boldsymbol{\\omega})} \\,d\\Omega\n$$\nSubstituting $C = \\int_{\\Omega} \\sqrt{g(\\boldsymbol{\\omega})} \\,d\\Omega$, we get:\n$$\nV(p^\\star) = \\left( \\int_{\\Omega} \\sqrt{g(\\boldsymbol{\\omega})} \\,d\\Omega \\right)^2\n$$\nSo, $\\Psi(p^\\star) = \\left( \\int_{\\Omega} \\sqrt{g(\\boldsymbol{\\omega})} \\,d\\Omega \\right)^2 - I_{const}^2$.\n\nThe ratio to compute is thus:\n$$\nr = \\frac{\\Psi(p^\\star)}{\\Psi(p_u)} = \\frac{\\left( \\int_{\\Omega} \\sqrt{g(\\boldsymbol{\\omega})} \\,d\\Omega \\right)^2 - (w_L I_L^2 + w_R I_R^2)}{4\\pi \\int_{\\Omega} g(\\boldsymbol{\\omega}) \\,d\\Omega - (w_L I_L^2 + w_R I_R^2)}\n$$\nTo compute this ratio for the given test cases, we must perform numerical integration over the sphere $\\Omega$. Using spherical coordinates $\\boldsymbol{\\omega}(\\theta,\\phi) = \\left(\\sin\\theta\\cos\\phi,\\ \\sin\\theta\\sin\\phi,\\ \\cos\\theta\\right)$ with $d\\Omega = \\sin\\theta\\,d\\theta\\,d\\phi$, any integral $\\int_\\Omega F(\\boldsymbol{\\omega})d\\Omega$ becomes $\\int_0^{2\\pi} \\int_0^\\pi F(\\boldsymbol{\\omega}(\\theta,\\phi)) \\sin\\theta\\, d\\theta d\\phi$.\n\nWe need to compute four integrals for each test case:\n$1$. $I_L = \\iint f_L(\\theta,\\phi) \\sin\\theta\\,d\\theta d\\phi$\n$2$. $I_R = \\iint f_R(\\theta,\\phi) \\sin\\theta\\,d\\theta d\\phi$\n$3$. $I_g = \\iint g(\\theta,\\phi) \\sin\\theta\\,d\\theta d\\phi$\n$4$. $I_{\\sqrt{g}} = \\iint \\sqrt{g(\\theta,\\phi)} \\sin\\theta\\,d\\theta d\\phi$\n\nThe functions $f_L$ and $f_R$ are defined using the parametric model $P(\\boldsymbol{\\omega};\\boldsymbol{a},n) = \\max\\left(0,\\ \\boldsymbol{a}\\cdot\\boldsymbol{\\omega}\\right)^n$:\n$f_L(\\boldsymbol{\\omega}) = P(\\boldsymbol{\\omega};\\boldsymbol{a}_s,m) \\cdot P(\\boldsymbol{\\omega};\\boldsymbol{a}_L,n_L)$\n$f_R(\\boldsymbol{\\omega}) = P(\\boldsymbol{\\omega};\\boldsymbol{a}_s,m) \\cdot P(\\boldsymbol{\\omega};\\boldsymbol{a}_R,n_R)$\nThe corresponding functions of $\\theta$ and $\\phi$ are then constructed and integrated numerically. The following implementation uses `scipy.integrate.dblquad` for this purpose.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import dblquad\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding and evaluating an optimal importance sampling\n    strategy for binaural auralization.\n    \"\"\"\n\n    test_cases = [\n        {'name': 'Case A', 'params': {'m': 0, 'n_L': 2, 'n_R': 2, 'a_s': (1.0, 0.0, 0.0)}},\n        {'name': 'Case B', 'params': {'m': 8, 'n_L': 4, 'n_R': 4, 'a_s': (0.0, 1.0, 0.0)}},\n        {'name': 'Case C', 'params': {'m': 4, 'n_L': 16, 'n_R': 16, 'a_s': (1.0, 0.0, 0.0)}},\n    ]\n\n    # Shared parameters for all test cases\n    W_L = 0.5\n    W_R = 0.5\n    A_L = np.array([0.0, 1.0, 0.0])\n    A_R = np.array([0.0, -1.0, 0.0])\n\n    def calculate_variance_ratio(m, n_L, n_R, a_s):\n        \"\"\"\n        Calculates the ratio of weighted variance sums Psi(p*)/Psi(pu) for a given set of parameters.\n        The function defines all necessary integrands and performs numerical integration.\n        \"\"\"\n        a_s_vec = np.array(a_s)\n\n        def omega_cartesian(theta, phi):\n            \"\"\"Converts spherical coordinates (theta, phi) to a Cartesian unit vector.\"\"\"\n            sin_theta = np.sin(theta)\n            return np.array([\n                sin_theta * np.cos(phi),\n                sin_theta * np.sin(phi),\n                np.cos(theta)\n            ])\n\n        def P_func(theta, phi, a, n):\n            \"\"\"Computes P(omega; a, n) = max(0, a.omega)^n.\"\"\"\n            omega = omega_cartesian(theta, phi)\n            dot_product = np.dot(a, omega)\n            # The convention np.power(0.0, 0.0) = 1.0 is used, which is appropriate\n            # for the isotropic source case (m=0).\n            return np.power(np.maximum(0.0, dot_product), n)\n\n        def f_L(theta, phi):\n            \"\"\"Defines the left-ear integrand f_L(omega).\"\"\"\n            D_s = P_func(theta, phi, a_s_vec, m)\n            S_L = P_func(theta, phi, A_L, n_L)\n            return D_s * S_L\n\n        def f_R(theta, phi):\n            \"\"\"Defines the right-ear integrand f_R(omega).\"\"\"\n            D_s = P_func(theta, phi, a_s_vec, m)\n            S_R = P_func(theta, phi, A_R, n_R)\n            return D_s * S_R\n        \n        def g_func(theta, phi):\n            \"\"\"Defines g(omega) = w_L*f_L(omega)^2 + w_R*f_R(omega)^2.\"\"\"\n            val_fL = f_L(theta, phi)\n            val_fR = f_R(theta, phi)\n            return W_L * val_fL**2 + W_R * val_fR**2\n\n        # Define the full integrands for scipy.integrate.dblquad, including the surface element sin(theta).\n        # dblquad expects the function signature func(y, x), where y is the inner integral variable.\n        # We use theta as the inner variable (y) and phi as the outer variable (x).\n        integrand_fL = lambda theta, phi: f_L(theta, phi) * np.sin(theta)\n        integrand_fR = lambda theta, phi: f_R(theta, phi) * np.sin(theta)\n        integrand_g = lambda theta, phi: g_func(theta, phi) * np.sin(theta)\n        integrand_sqrt_g = lambda theta, phi: np.sqrt(g_func(theta, phi)) * np.sin(theta)\n        \n        # Integration bounds for the unit sphere: phi in [0, 2pi], theta in [0, pi]\n        phi_min, phi_max = 0, 2 * np.pi\n        theta_min, theta_max = 0, np.pi\n\n        # Perform the four required numerical integrations\n        I_L, _ = dblquad(integrand_fL, phi_min, phi_max, theta_min, theta_max)\n        I_R, _ = dblquad(integrand_fR, phi_min, phi_max, theta_min, theta_max)\n        I_g, _ = dblquad(integrand_g, phi_min, phi_max, theta_min, theta_max)\n        I_sqrt_g, _ = dblquad(integrand_sqrt_g, phi_min, phi_max, theta_min, theta_max)\n\n        # Calculate the constant term I_const^2 = w_L*I_L^2 + w_R*I_R^2\n        I_const_sq = W_L * I_L**2 + W_R * I_R**2\n\n        # Calculate Psi(p_u) for uniform sampling\n        V_p_u = 4 * np.pi * I_g\n        Psi_p_u = V_p_u - I_const_sq\n        \n        # Calculate Psi(p*) for optimal sampling\n        V_p_star = I_sqrt_g**2\n        Psi_p_star = V_p_star - I_const_sq\n\n        # The variance must be non-negative. Small negative values due to numerical\n        # error are clamped to zero.\n        if Psi_p_u < 0: Psi_p_u = 0.0\n        \n        # Avoid division by zero. If variance under uniform sampling is zero,\n        # no improvement is possible, so the ratio is 1.\n        if Psi_p_u == 0.0:\n            return 1.0\n\n        ratio = Psi_p_star / Psi_p_u\n        return ratio\n\n    results = []\n    for case in test_cases:\n        params = case['params']\n        ratio = calculate_variance_ratio(params['m'], params['n_L'], params['n_R'], params['a_s'])\n        results.append(ratio)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The final stage of auralization is the faithful reproduction of the simulated sound field for a listener. This exercise focuses on Vector Base Amplitude Panning (VBAP), a widely used technique for positioning virtual sources within a loudspeaker array . By implementing the VBAP algorithm and evaluating its robustness to listener movement, you will tackle the practical challenges of creating stable and convincing virtual acoustic experiences.",
            "id": "4117127",
            "problem": "You are to implement a program that computes loudspeaker weights for Vector Base Amplitude Panning (VBAP) and evaluates robustness to listener head movements and off-axis positions in a two-dimensional loudspeaker setup. The program must follow the principles of free-field acoustic superposition and geometric reasoning.\n\nThe physical and mathematical base is as follows:\n- Use linear superposition of acoustic pressure in the far field and assume ideal monopole loudspeakers whose pressure amplitude magnitude scales inversely with distance, that is $|p| \\propto 1/r$.\n- Model loudspeaker directions by unit vectors in the plane.\n- Compute VBAP gains for a target direction by selecting a base of two adjacent loudspeakers whose nonnegative linear combination reproduces the target direction vector.\n- Normalize gains to constant power, that is the Euclidean norm of the gain vector equals $1$.\n- Predict perceived direction under steady-state using an energy-vector approximation derived from time-averaged active intensity considerations, by weighting directions with squared amplitudes.\n\nAll angles must be treated and reported in radians. All distances must be in meters. All gains and power ratios are dimensionless.\n\nDefinitions to be used:\n- A loudspeaker at angular position $\\theta$ on a circle of radius $R$ centered at the nominal listening position has Cartesian coordinates $\\mathbf{s} = R[\\cos(\\theta), \\sin(\\theta)]^{\\mathsf{T}}$. Its unit direction vector from the nominal listening position is $\\mathbf{l} = [\\cos(\\theta), \\sin(\\theta)]^{\\mathsf{T}}$.\n- The target source direction unit vector is $\\mathbf{t} = [\\cos(\\theta_{\\text{t}}), \\sin(\\theta_{\\text{t}})]^{\\mathsf{T}}$.\n- Vector Base Amplitude Panning (VBAP) in the plane approximates a desired direction by a nonnegative linear combination of two adjacent loudspeaker unit vectors $\\mathbf{l}_i$ and $\\mathbf{l}_j$ so that $\\mathbf{t} = g_i \\mathbf{l}_i + g_j \\mathbf{l}_j$ with $g_i \\ge 0$, $g_j \\ge 0$. Normalize the gains to constant power so that $\\sqrt{g_i^2 + g_j^2} = 1$.\n- Listener head yaw is modeled as a rotation by angle $\\phi$ about the plane origin. Angles are positive for counterclockwise rotation.\n- A listener off-axis position is $\\mathbf{p} = [x, 0]^{\\mathsf{T}}$ in meters, displacing the listener along the horizontal axis.\n- For evaluation at head yaw $\\phi$ and listener position $\\mathbf{p}$, the unit direction from the listener to loudspeaker $k$ expressed in the listener-head coordinate frame is $\\mathbf{u}_k(\\phi,x) = \\frac{\\mathbf{R}(-\\phi)(\\mathbf{s}_k - \\mathbf{p})}{\\|\\mathbf{s}_k - \\mathbf{p}\\|}$ where $\\mathbf{R}(\\alpha)$ is the $2 \\times 2$ rotation matrix by angle $\\alpha$.\n- The distance from the listener to loudspeaker $k$ is $r_k(x) = \\|\\mathbf{s}_k - \\mathbf{p}\\|$. Assuming coherent, in-phase driving and far-field monopoles, the amplitude from loudspeaker $k$ is proportional to $a_k = g_k / r_k(x)$.\n- The energy vector predictor for perceived direction under steady-state is $\\mathbf{E}(\\phi,x) = \\sum_k a_k^2 \\mathbf{u}_k(\\phi,x)$. The predicted perceived azimuth is the argument of $\\mathbf{E}(\\phi,x)$, computed as $\\operatorname{atan2}(E_y,E_x)$.\n- The target direction in the head coordinate frame at yaw $\\phi$ is $\\mathbf{t}_{\\text{head}}(\\phi) = \\mathbf{R}(-\\phi)\\mathbf{t}$, with azimuth $\\theta_{\\text{head}}(\\phi) = \\operatorname{atan2}(t_{\\text{head},y}, t_{\\text{head},x})$.\n- The angular error at yaw $\\phi$ is the principal value of the difference between the predicted and target azimuths, wrapped to $[-\\pi,\\pi]$ and measured as an absolute value.\n- The instantaneous mean-squared pressure proxy is $P(\\phi,x) = \\sum_k a_k^2$. The reference center value at zero offset and zero yaw is $P_0 = 1/R^2$ due to constant-power normalization and equal distances at the center.\n\nYou must perform the following tasks:\n1. Given a circular loudspeaker layout and a target direction, compute the VBAP gains for exactly two loudspeakers and identify which loudspeaker pair is used. Use adjacent loudspeakers ordered by angle, wrap-around included. Select the pair whose nonnegative linear combination reproduces the target unit vector. Normalize the gains to constant power.\n2. For a specified set of head yaw angles $\\phi$ evenly spaced over a closed interval $[\\phi_{\\min}, \\phi_{\\max}]$ and a specified listener lateral offset $x$, evaluate robustness by computing:\n   - The worst-case absolute angular error in radians over the yaw sample set.\n   - The root-mean-square deviation of $P(\\phi,x)/P_0$ from $1$ over the yaw sample set, where $P_0$ is defined above. This quantity is dimensionless.\n3. All angles must be in radians. Distances are in meters. Gains and all energy quantities are dimensionless. The final numerical outputs must be rounded to $6$ decimal places.\n\nYour program must implement the above and run the following test suite. For each test case below, the loudspeaker angles are given in degrees but must be interpreted in radians internally; the target direction is also given in degrees and must be interpreted in radians internally; the head yaw range is given in radians; the number of samples is an integer specifying the number of evenly spaced samples including the endpoints.\n\nCommon parameters for all test cases:\n- Circle radius $R = 2.0$ meters.\n\nTest cases:\n- Case A:\n  - Loudspeaker angles (degrees): $[-60, -20, 20, 60]$.\n  - Target direction (degrees): $10$.\n  - Listener lateral offset $x$ (meters): $0.0$.\n  - Yaw range $[\\phi_{\\min}, \\phi_{\\max}]$ (radians): $[-0.34906585, 0.34906585]$.\n  - Number of yaw samples: $9$.\n- Case B:\n  - Loudspeaker angles (degrees): $[-60, -20, 20, 60]$.\n  - Target direction (degrees): $60$.\n  - Listener lateral offset $x$ (meters): $0.2$.\n  - Yaw range $[\\phi_{\\min}, \\phi_{\\max}]$ (radians): $[-0.34906585, 0.34906585]$.\n  - Number of yaw samples: $13$.\n- Case C:\n  - Loudspeaker angles (degrees): $[-90, -30, 30, 90]$.\n  - Target direction (degrees): $0$.\n  - Listener lateral offset $x$ (meters): $-0.3$.\n  - Yaw range $[\\phi_{\\min}, \\phi_{\\max}]$ (radians): $[-0.52359878, 0.52359878]$.\n  - Number of yaw samples: $11$.\n\nRequired program output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- Each test case result must be a list in the form $[i_1, i_2, g_1, g_2, e_{\\max}, d_{\\text{rms}}]$, where $i_1$ and $i_2$ are the $0$-based indices of the chosen loudspeakers in the order they appear in the input list, $g_1$ and $g_2$ are the corresponding VBAP gains after constant-power normalization, $e_{\\max}$ is the worst-case absolute angular error in radians, and $d_{\\text{rms}}$ is the root-mean-square deviation of $P(\\phi,x)/P_0$ from $1$ (dimensionless). All floating-point values must be rounded to $6$ decimal places.\n- The final printed line must therefore look like $[[i_1,i_2,g_1,g_2,e_{\\max},d_{\\text{rms}}],[...],[...]]$ without any additional text.\n\nYour task is to implement this computation precisely as specified and produce the single-line output in the required format. All angles must be in radians, and distances in meters. Gains and energy quantities are dimensionless. Round all floating-point results to $6$ decimal places in the printed output.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of computational acoustics, mathematically well-posed, and provides a complete and consistent set of definitions and parameters. The task is to implement a computational model for Vector Base Amplitude Panning (VBAP) and to analyze its robustness to listener displacement and head rotation. The solution proceeds in two main stages: first, the calculation of loudspeaker gains for a target direction, and second, the evaluation of perceptual and physical robustness metrics across a range of listening conditions.\n\nThe algorithmic and mathematical design is as follows:\n\n**1. VBAP Gain Calculation**\n\nThe first task is to determine the appropriate gains for a pair of adjacent loudspeakers to create a phantom source at a specified target direction. The loudspeakers are arranged on a circle of radius $R$ centered at the nominal listening position (the origin).\n\n-   **Representations**: A loudspeaker at angle $\\theta_k$ has a corresponding unit direction vector $\\mathbf{l}_k = [\\cos(\\theta_k), \\sin(\\theta_k)]^{\\mathsf{T}}$. Similarly, the target direction $\\theta_t$ is represented by a unit vector $\\mathbf{t} = [\\cos(\\theta_t), \\sin(\\theta_t)]^{\\mathsf{T}}$. All angles provided in degrees are first converted to radians.\n\n-   **Loudspeaker Pair Selection**: VBAP creates the phantom source using a pair of adjacent loudspeakers. The correct pair, with 0-based indices $i$ and $j$, is the one whose direction vectors $\\mathbf{l}_i$ and $\\mathbf{l}_j$ span the target vector $\\mathbf{t}$. Mathematically, this means that $\\mathbf{t}$ can be expressed as a linear combination of $\\mathbf{l}_i$ and $\\mathbf{l}_j$ with non-negative coefficients. We seek unnormalized gains $g'_i$ and $g'_j$ that satisfy the vector equation:\n    $$\n    \\mathbf{t} = g'_i \\mathbf{l}_i + g'_j \\mathbf{l}_j\n    $$\n    This can be written as a $2 \\times 2$ linear system:\n    $$\n    \\begin{pmatrix} l_{ix} & l_{jx} \\\\ l_{iy} & l_{jy} \\end{pmatrix} \\begin{pmatrix} g'_i \\\\ g'_j \\end{pmatrix} = \\begin{pmatrix} t_x \\\\ t_y \\end{pmatrix}\n    $$\n    where $\\mathbf{l}_k = [l_{kx}, l_{ky}]^{\\mathsf{T}}$ and $\\mathbf{t} = [t_x, t_y]^{\\mathsf{T}}$. The algorithm iterates through all adjacent pairs of loudspeakers $(k, (k+1) \\pmod N)$, where $N$ is the total number of loudspeakers, solving this system for each pair. The first pair that yields a solution with both $g'_i \\ge 0$ and $g'_j \\ge 0$ is selected. This method is robust and correctly handles cases where the target direction coincides with a loudspeaker direction.\n\n-   **Gain Normalization**: The problem specifies a constant-power normalization scheme. The unnormalized gains $g'_i$ and $g'_j$ are scaled such that the Euclidean norm of the final gain vector is unity. The normalized gains $g_i$ and $g_j$ are thus computed as:\n    $$\n    g_i = \\frac{g'_i}{\\sqrt{(g'_i)^2 + (g'_j)^2}}, \\quad g_j = \\frac{g'_j}{\\sqrt{(g'_i)^2 + (g'_j)^2}}\n    $$\n    This ensures that $g_i^2 + g_j^2 = 1$. These gains, $g_i$ and $g_j$, along with the indices $i$ and $j$ of the chosen loudspeakers, form the first part of the result. For all other loudspeakers, the gain is $0$.\n\n**2. Robustness Evaluation**\n\nThe second task is to evaluate the stability of the sound field with respect to listener head yaw and lateral displacement. The analysis is performed over a set of $N_\\phi$ evenly spaced head yaw angles $\\phi$ in a given range $[\\phi_{\\min}, \\phi_{\\max}]$ for a fixed lateral offset $\\mathbf{p} = [x, 0]^{\\mathsf{T}}$.\n\n-   **Physical Model**: At a displaced position $\\mathbf{p}$, the distance from the listener to loudspeaker $k$ (at position $\\mathbf{s}_k = R \\mathbf{l}_k$) is $r_k(x) = \\|\\mathbf{s}_k - \\mathbf{p}\\|$. Assuming ideal monopole sources, the acoustic pressure amplitude from loudspeaker $k$ is inversely proportional to this distance, given by $a_k = g_k / r_k(x)$, where $g_k$ is the normalized gain.\n\n-   **Energy Vector and Perceived Direction**: The perceived direction is predicted using the energy vector model. The direction vector from the listener to loudspeaker $k$, expressed in the listener's head coordinate frame (rotated by $\\phi$), is $\\mathbf{u}_k(\\phi,x) = \\frac{\\mathbf{R}(-\\phi)(\\mathbf{s}_k - \\mathbf{p})}{\\|\\mathbf{s}_k - \\mathbf{p}\\|}$, where $\\mathbf{R}(-\\phi)$ is the 2D rotation matrix for an angle of $-\\phi$. The total energy vector $\\mathbf{E}$ is the sum of the squared amplitudes weighting these direction vectors:\n    $$\n    \\mathbf{E}(\\phi,x) = \\sum_k a_k^2 \\mathbf{u}_k(\\phi,x)\n    $$\n    The sum is taken over the two active loudspeakers. The predicted perceived azimuth in the head frame is the angle of this vector, $\\theta_{pred} = \\operatorname{atan2}(E_y, E_x)$.\n\n-   **Angular Error**: The target direction in the head frame is $\\mathbf{t}_{\\text{head}}(\\phi) = \\mathbf{R}(-\\phi)\\mathbf{t}$, with azimuth $\\theta_{target} = \\operatorname{atan2}(t_{\\text{head},y}, t_{\\text{head},x})$. The angular error for a given yaw $\\phi$ is the absolute difference between the predicted and target azimuths, wrapped to the interval $[-\\pi, \\pi]$. Let $\\Delta\\theta = \\theta_{pred} - \\theta_{target}$. The wrapped error is $\\mathrm{wrap}(\\Delta\\theta)$. The worst-case absolute angular error, $e_{\\max}$, is the maximum of $|\\mathrm{wrap}(\\Delta\\theta)|$ over all sampled yaw angles.\n\n-   **Pressure Fluctuation**: The constancy of sound pressure level is evaluated using a mean-squared pressure proxy, $P(\\phi,x) = \\sum_k a_k^2$. The reference pressure at the center with zero yaw is $P_0 = (1/R)^2$, derived from $\\sum (g_k/R)^2 = (\\sum g_k^2)/R^2 = 1/R^2$. The robustness metric $d_{\\text{rms}}$ is the root-mean-square deviation of the pressure ratio $P(\\phi,x)/P_0$ from $1$, computed across all sampled yaw angles:\n    $$\n    d_{\\text{rms}} = \\sqrt{\\frac{1}{N_\\phi} \\sum_{k=1}^{N_\\phi} \\left( \\frac{P(\\phi_k, x)}{P_0} - 1 \\right)^2}\n    $$\n\nThese calculations are performed for each test case to yield the final set of six values: $[i_1, i_2, g_1, g_2, e_{\\max}, d_{\\text{rms}}]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the VBAP simulation for all test cases and print the results.\n    \"\"\"\n\n    def format_results(results_list):\n        \"\"\"\n        Formats the final list of results into the required string format\n        with floating point numbers rounded to 6 decimal places.\n        \"\"\"\n        formatted_cases = []\n        for case_result in results_list:\n            i1, i2, g1, g2, e_max, d_rms = case_result\n            # i1, i2 are integers, the rest are floats.\n            formatted_case = f\"[{i1},{i2},{g1:.6f},{g2:.6f},{e_max:.6f},{d_rms:.6f}]\"\n            formatted_cases.append(formatted_case)\n        return f\"[{','.join(formatted_cases)}]\"\n\n    def compute_vbap_metrics(ls_angles_deg, target_angle_deg, x, yaw_range_rad, yaw_samples):\n        \"\"\"\n        Computes VBAP gains and robustness metrics for a single test case.\n        \"\"\"\n        # Common parameter\n        R = 2.0\n\n        # Convert input angles from degrees to radians\n        ls_angles_rad = np.deg2rad(ls_angles_deg)\n        target_angle_rad = np.deg2rad(target_angle_deg)\n\n        # Define loudspeaker and target direction vectors (unit vectors)\n        num_ls = len(ls_angles_rad)\n        ls_vectors = np.array([[np.cos(a), np.sin(a)] for a in ls_angles_rad])\n        target_vector = np.array([np.cos(target_angle_rad), np.sin(target_angle_rad)])\n\n        # Step 1: Find the active loudspeaker pair and calculate VBAP gains\n        i1, i2 = -1, -1\n        g_unnormalized = None\n        \n        # Iterate through adjacent loudspeaker pairs\n        for i in range(num_ls):\n            j = (i + 1) % num_ls\n            l_i = ls_vectors[i]\n            l_j = ls_vectors[j]\n            \n            # Form the matrix L = [l_i, l_j]\n            L_matrix = np.array([l_i, l_j]).T\n            \n            # The matrix is non-singular if speakers are not collinear\n            if abs(np.linalg.det(L_matrix)) < 1e-9:\n                continue\n\n            # Solve the system t = g'_i * l_i + g'_j * l_j for unnormalized gains g'\n            try:\n                g_prime = np.linalg.solve(L_matrix, target_vector)\n                \n                # The correct pair is the one yielding non-negative gains\n                if np.all(g_prime >= -1e-9):\n                    i1, i2 = i, j\n                    g_unnormalized = g_prime\n                    break\n            except np.linalg.LinAlgError:\n                continue\n        \n        if i1 == -1:\n             raise ValueError(\"Could not find a valid loudspeaker pair.\")\n\n        # Normalize gains for constant power: sqrt(g1^2 + g2^2) = 1\n        norm_g = np.linalg.norm(g_unnormalized)\n        g_normalized = g_unnormalized / norm_g if norm_g > 1e-9 else np.array([0.0, 0.0])\n        g1, g2 = g_normalized[0], g_normalized[1]\n\n        # Step 2: Evaluate robustness over a range of head yaws and a listener offset\n        yaw_angles = np.linspace(yaw_range_rad[0], yaw_range_rad[1], yaw_samples)\n        listener_pos = np.array([x, 0.0])\n        ls_positions = R * ls_vectors\n        P0 = 1.0 / R**2\n        \n        active_indices = [i1, i2]\n        active_gains = [g1, g2]\n\n        angular_errors = []\n        pressure_devs_sq = []\n\n        for phi in yaw_angles:\n            # Rotation matrix for head yaw\n            rot_matrix = np.array([[np.cos(-phi), -np.sin(-phi)],\n                                   [np.sin(-phi), np.cos(-phi)]])\n\n            E_vector = np.zeros(2)\n            P_sum = 0.0\n\n            # Sum contributions from the two active loudspeakers\n            for idx, gain in zip(active_indices, active_gains):\n                s_k = ls_positions[idx]\n                d_k = s_k - listener_pos  # Vector from listener to speaker\n                r_k = np.linalg.norm(d_k) # Distance to speaker\n                \n                if r_k < 1e-9: continue\n\n                # Amplitude scales as 1/r\n                a_k = gain / r_k\n                # Direction vector in head coordinate frame\n                u_k = (rot_matrix @ d_k) / r_k\n\n                E_vector += (a_k**2) * u_k\n                P_sum += a_k**2\n            \n            # Predicted perceived azimuth in head frame\n            theta_pred = np.arctan2(E_vector[1], E_vector[0])\n\n            # Target azimuth in head frame\n            target_head_frame = rot_matrix @ target_vector\n            theta_target_head = np.arctan2(target_head_frame[1], target_head_frame[0])\n            \n            # Angular error, wrapped to [-pi, pi]\n            error = theta_pred - theta_target_head\n            wrapped_error = (error + np.pi) % (2 * np.pi) - np.pi\n            angular_errors.append(np.abs(wrapped_error))\n\n            # Squared deviation of the pressure proxy ratio from 1\n            pressure_ratio = P_sum / P0\n            pressure_devs_sq.append((pressure_ratio - 1)**2)\n\n        e_max = np.max(angular_errors)\n        d_rms = np.sqrt(np.mean(pressure_devs_sq))\n\n        return [i1, i2, g1, g2, e_max, d_rms]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {'ls_angles_deg': [-60, -20, 20, 60], 'target_angle_deg': 10, 'x': 0.0,\n         'yaw_range_rad': [-0.34906585, 0.34906585], 'yaw_samples': 9},\n        # Case B\n        {'ls_angles_deg': [-60, -20, 20, 60], 'target_angle_deg': 60, 'x': 0.2,\n         'yaw_range_rad': [-0.34906585, 0.34906585], 'yaw_samples': 13},\n        # Case C\n        {'ls_angles_deg': [-90, -30, 30, 90], 'target_angle_deg': 0, 'x': -0.3,\n         'yaw_range_rad': [-0.52359878, 0.52359878], 'yaw_samples': 11},\n    ]\n\n    # Run all test cases and collect results\n    results = []\n    for case_params in test_cases:\n        result = compute_vbap_metrics(**case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(format_results(results))\n\nsolve()\n```"
        }
    ]
}