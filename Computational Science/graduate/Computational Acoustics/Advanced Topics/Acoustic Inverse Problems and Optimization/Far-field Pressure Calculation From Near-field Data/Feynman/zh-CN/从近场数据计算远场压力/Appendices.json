{
    "hands_on_practices": [
        {
            "introduction": "在计算声学中，通过傅里叶变换，近场数据与远场方向图之间存在着深刻的联系。然而，实际测量总是在有限的孔径上进行，这相当于对声场施加了一个窗函数，从而导致频谱泄漏，影响远场预测的准确性。本练习  将通过数值实验，直观地展示如何利用不同的平滑窗函数来控制这种泄漏，并量化分析在主瓣宽度与旁瓣抑制之间的基本权衡，这是任何基于傅里叶声学的近场-远场变换技术的核心实践。",
            "id": "4123377",
            "problem": "考虑一个在声速为 $c$、密度为 $\\rho$ 的均匀无损介质中的时谐声场，其时间依赖关系 $e^{j\\omega t}$ 已被省略。声压 $p(x,y,z)$ 满足由线性化波动方程推导出的亥姆霍兹方程。在测量平面 $z=0$ 上，设近场声压在一个尺寸为 $L_x \\times L_y$ 的有限矩形测量孔径上采样，并被离散化到具有 $N_x \\times N_y$ 个点、间距为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$ 的均匀网格上。声波数为 $k = \\omega/c = 2\\pi f/c$，其中 $f$ 是频率。将 $p(x,y,0)$ 的二维空间傅里叶变换定义为 $P(k_x,k_y)$，其中 $k_x$ 和 $k_y$ 是空间角频率（单位为 $\\mathrm{rad/m}$）。假设一个频率 $f$ 给定的单色场。\n\n从基本定律和定义（线性化声波方程、亥姆霍兹方程和角谱表示法）出发，推导并实现一个计算程序，该程序能够：\n- 根据在 $L_x \\times L_y$ 上测量的离散化近场数据 $p(x,y,0)$ 计算 $P(k_x,k_y)$。\n- 展示将 $p(x,y,0)$ 乘以一个平滑锥削（窗函数）$w(x,y)$ 如何减少 $P(k_x,k_y)$ 中的频谱泄漏，并改变沿 $k_x$ 轴（当 $k_y=0$ 时）的远场模式。\n- 量化远场中主瓣展宽与旁瓣抑制之间的权衡。\n\n假设一个由尺寸为 $A_x \\times A_y$、以原点为中心的均匀矩形活塞组成的合成近场：当 $|x|\\le A_x/2$ 且 $|y|\\le A_y/2$ 时，$p(x,y,0)=1$，否则 $p(x,y,0)=0$。应用由沿 $x$ 和 $y$ 方向的一维锥削构成的可分离单位振幅窗函数 $w(x,y)=w_x(x)w_y(y)$。\n\n定义以下定量指标：\n1. 角谱中的频谱泄漏分数 $L$ 定义为\n$$\nL = \\frac{\\displaystyle \\iint_{\\mathcal{D}_\\text{prop}\\setminus\\mathcal{R}_\\text{ML}} |P(k_x,k_y)|^2 \\,\\mathrm{d}k_x\\,\\mathrm{d}k_y}{\\displaystyle \\iint_{\\mathcal{D}_\\text{prop}} |P(k_x,k_y)|^2 \\,\\mathrm{d}k_x\\,\\mathrm{d}k_y},\n$$\n其中 $\\mathcal{D}_\\text{prop}=\\{(k_x,k_y): |k_x|\\le k, |k_y|\\le k\\}$ 是传播分量集合，$\\mathcal{R}_\\text{ML}=\\{(k_x,k_y): |k_x|\\le k_{x,\\text{ROI}}, |k_y|\\le k_{y,\\text{ROI}}\\}$ 是代表主瓣区域的矩形区域，其边界为 $k_{x,\\text{ROI}}=2\\pi/A_x$ 和 $k_{y,\\text{ROI}}=2\\pi/A_y$。将 $L$ 表示为小数。\n2. 沿 $k_x$ 轴在 $k_y=0$ 处的远场主瓣半峰全宽 (FWHM)，定义为一维切片 $|P(k_x,0)|$ 的幅度等于其峰值的 $\\sqrt{0.5}$ 倍的两点之间的宽度。将此宽度以 $\\mathrm{rad/m}$ 为单位表示。\n3. 沿 $k_x$ 轴在 $k_y=0$ 处的峰值旁瓣电平比 $S$，定义为在传播区域 $|k_x|\\le k$ 内，对于 $|k_x|>k_{x,\\text{ROI}}$ 的 $|P(k_x,0)|$ 的最大值，并由主瓣峰值归一化。将 $S$ 表示为小数。\n\n您的任务是实现一个完整的程序，该程序能够：\n- 在指定的网格上构建近场 $p(x,y,0)$ 并应用每个窗函数 $w(x,y)$。\n- 使用采样间距 $\\Delta x$ 和 $\\Delta y$，通过离散二维傅里叶变换计算 $P(k_x,k_y)$。\n- 对每种窗函数情况，评估如上定义的 $L$、FWHM 和 $S$。\n\n使用以下物理和数值参数（所有数值均以标准国际单位制给出）：\n- 声速 $c = 343\\,\\mathrm{m/s}$，频率 $f = 40000\\,\\mathrm{Hz}$，因此 $k = 2\\pi f / c$。\n- 测量孔径尺寸 $L_x = 0.3\\,\\mathrm{m}$ 和 $L_y = 0.3\\,\\mathrm{m}$。\n- 网格尺寸 $N_x = 512$ 和 $N_y = 512$。\n- 矩形活塞尺寸 $A_x = 0.1\\,\\mathrm{m}$ 和 $A_y = 0.08\\,\\mathrm{m}$。\n\n待评估的窗函数：\n- 情况1：矩形窗（无锥削）。\n- 情况2：汉宁窗。\n- 情况3：图基窗，参数 $\\alpha = 0.25$（无量纲）。\n- 情况4：布莱克曼窗。\n\n不使用角度单位；空间谱量必须以 $\\mathrm{rad/m}$ 表示。比率必须以小数表示。\n\n测试套件：\n为上述四种情况评估这些指标。程序的最终输出必须是单行，包含一个列表的列表，每个子列表对应一种情况，并按顺序 $[L,\\text{FWHM},S]$ 包含三个结果。格式必须严格为\n$$\n\\text{[}[L_1,\\text{FWHM}_1,S_1],[L_2,\\text{FWHM}_2,S_2],[L_3,\\text{FWHM}_3,S_3],[L_4,\\text{FWHM}_4,S_4]\\text{]}\n$$\n数值采用纯十进制表示，FWHM 单位为 $\\mathrm{rad/m}$。",
            "solution": "该问题要求分析从一个加窗的、有限孔径测量的近场声压分布中推导出的远场声学特性。此分析基于线性声学、傅里叶光学和数字信号处理的原理。\n\n在均匀无损介质中，时谐声波的传播由亥姆霍兹方程控制，该方程是线性化声波方程的频域表示：\n$$ \\nabla^2 p(\\mathbf{r}) + k^2 p(\\mathbf{r}) = 0 $$\n其中 $p(\\mathbf{r})$ 是位置 $\\mathbf{r}=(x,y,z)$ 处的复声压，$k = \\omega/c = 2\\pi f/c$ 是声波数，$\\omega$ 是角频率，$c$ 是声速，时间依赖关系 $e^{j\\omega t}$ 已被省略。\n\n一个求解此方程的有效方法是角谱表示法。该方法将任意平面 $z$ 上的声压场表示为具有不同传播方向的平面波的叠加。场 $p(x,y,z)$ 可写为其角谱 $P(k_x, k_y)$ 的逆傅里叶变换：\n$$ p(x,y,z) = \\frac{1}{(2\\pi)^2} \\iint_{-\\infty}^{\\infty} P(k_x,k_y) e^{j(k_x x + k_y y + k_z z)} \\,\\mathrm{d}k_x\\,\\mathrm{d}k_y $$\n在此，$P(k_x,k_y)$ 是平面 $z=0$ 上声压分布的二维空间傅里叶变换：\n$$ P(k_x,k_y) = \\iint_{-\\infty}^{\\infty} p(x,y,0) e^{-j(k_x x + k_y y)} \\,\\mathrm{d}x\\,\\mathrm{d}y $$\n分量 $k_z$ 由色散关系 $k_x^2 + k_y^2 + k_z^2 = k^2$ 决定，即 $k_z = \\sqrt{k^2 - k_x^2 - k_y^2}$。当 $k_z$ 为实数时（即当 $k_x^2 + k_y^2 \\le k^2$ 时），平面波从源平面传播出去。当 $k_z$ 为虚数时，波是倏逝波，并随 $z$ 指数衰减。传播分量的角谱 $P(k_x, k_y)$ 与远场辐射图样成正比。\n\n在实践中，近场声压 $p(x,y,0)$ 在一个尺寸为 $L_x \\times L_y$ 的有限孔径上、一个具有 $N_x \\times N_y$ 个点、间距为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$ 的离散网格上进行采样。因此，连续傅里叶变换由离散傅里叶变换 (DFT) 近似，通常使用快速傅里叶变换 (FFT) 算法计算。连续角谱与二维 DFT 结果之间的关系是：\n$$ P(k_x, k_y) \\approx \\Delta x \\Delta y \\cdot \\text{DFT}\\{p(n\\Delta x, m\\Delta y, 0)\\} $$\n其中离散空间频率 $(k_x, k_y)$ 对应于 DFT 矩阵的索引。\n\n将场截断至有限孔径相当于将真实近场乘以一个矩形窗函数。在频域中，这对应于将真实角谱与一个二维 sinc 函数进行卷积，从而引入频谱泄漏——即主瓣的能量“泄漏”到旁瓣中，掩盖了较弱的特征并扭曲了频谱。为减弱此效应，可将测量数据乘以一个在孔径边界处向零渐变的平滑窗函数 $w(x,y)$。这个过程称为变迹或加窗，它以展宽主瓣为代价，减小了所得频谱中旁瓣的幅度。这种在旁瓣抑制和主瓣宽度（分辨率）之间的权衡是频谱分析的一个基本方面。\n\n计算过程如下：\n1.  **网格与参数定义**：我们定义所提供的物理和数值参数。空间坐标 $(x,y)$ 在孔径 $L_x \\times L_y$ 上离散化。相应的空间频率坐标 $(k_x, k_y)$ 由采样属性通过 $k_x[u] = \\frac{2\\pi u}{N_x \\Delta x}$ 和 $k_y[v] = \\frac{2\\pi v}{N_y \\Delta y}$ 确定，其中 $u$ 和 $v$ 是频率指数。\n2.  **近场与窗函数合成**：在网格上构建均匀活塞源的合成近场。对于每种情况，生成一个可分离的二维窗函数 $w(x,y) = w_x(x)w_y(y)$，并与近场数据进行逐元素相乘以产生加窗后的场 $p_w(x,y,0)$。\n3.  **角谱计算**：计算 $p_w(x,y,0)$ 的二维 FFT，并适当地乘以 $\\Delta x \\Delta y$ 以近似 $P(k_x, k_y)$。\n4.  **指标评估**：对于每个得到的角谱，计算三个指定的指标。\n    *   **频谱泄漏分数 ($L$)**：此指标量化了位于定义的主瓣区域之外的传播功率部分。通过对指定区域 $\\mathcal{D}_\\text{prop}$ 和 $\\mathcal{R}_\\text{ML}$ 内离散网格点上 $P(k_x, k_y)$ 的幅度平方求和来近似积分。问题将 $\\mathcal{D}_\\text{prop}$ 定义为一个方形区域，这是对物理圆形区域 $k_x^2 + k_y^2 \\le k^2$ 的简化，但在计算中遵循此定义。\n    *   **远场 FWHM**：确定沿 $k_x$ 轴（在 $k_y=0$ 处）主瓣的半峰全宽。这需要找到一维频谱切片 $|P(k_x, 0)|$ 的峰值，然后找到幅度为 $\\text{peak}/\\sqrt{2}$ 处波瓣的宽度。由于目标值可能不落在离散的频率点上，因此使用线性插值来准确定位半功率点。\n    *   **峰值旁瓣比 ($S$)**：使用相同的一维频谱切片，在旁瓣区域（定义为 $|k_x| > k_{x,\\text{ROI}}$ 且在传播域 $|k_x| \\le k$ 内）找到最大幅度，并用主瓣峰值幅度进行归一化。\n\n此过程可以定量比较不同窗函数对远场辐射特性的影响，阐明了有限孔径数据傅里叶分析中频谱分辨率和动态范围之间的基本权衡。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal.windows import tukey\n\ndef solve():\n    \"\"\"\n    Computes and analyzes the angular spectrum of a windowed acoustic near-field.\n    \"\"\"\n    # Physical and Numerical Parameters\n    c = 343.0  # Speed of sound in m/s\n    f = 40000.0  # Frequency in Hz\n    Lx = 0.3  # Aperture size in x in m\n    Ly = 0.3  # Aperture size in y in m\n    Nx = 512  # Number of grid points in x\n    Ny = 512  # Number of grid points in y\n    Ax = 0.1  # Piston size in x in m\n    Ay = 0.08  # Piston size in y in m\n\n    # Derived Parameters\n    k = 2 * np.pi * f / c  # Wavenumber in rad/m\n    dx = Lx / Nx  # Grid spacing in x in m\n    dy = Ly / Ny  # Grid spacing in y in m\n    kx_roi = 2 * np.pi / Ax  # Main-lobe region boundary in kx\n    ky_roi = 2 * np.pi / Ay  # Main-lobe region boundary in ky\n\n    # Create spatial grids\n    x = np.linspace(-Lx / 2, Lx / 2 - dx, Nx)\n    y = np.linspace(-Ly / 2, Ly / 2 - dy, Ny)\n    xx, yy = np.meshgrid(x, y)\n\n    # Create spatial frequency grids\n    kx_vals = 2 * np.pi * np.fft.fftshift(np.fft.fftfreq(Nx, d=dx))\n    ky_vals = 2 * np.pi * np.fft.fftshift(np.fft.fftfreq(Ny, d=dy))\n    kx_grid, ky_grid = np.meshgrid(kx_vals, ky_vals)\n    \n    # Create the near-field pressure for the piston source\n    p_near_field = np.zeros((Ny, Nx))\n    p_near_field[(np.abs(yy) = Ay / 2)  (np.abs(xx) = Ax / 2)] = 1.0\n\n    window_cases = {\n        'rect': (np.ones(Nx), np.ones(Ny)),\n        'hann': (np.hanning(Nx), np.hanning(Ny)),\n        'tukey': (tukey(Nx, alpha=0.25), tukey(Ny, alpha=0.25)),\n        'blackman': (np.blackman(Nx), np.blackman(Ny))\n    }\n    \n    results = []\n\n    for name, (wx, wy) in window_cases.items():\n        # --- Window Application ---\n        w = np.outer(wy, wx)\n        p_windowed = p_near_field * w\n\n        # --- Angular Spectrum Calculation (FFT) ---\n        P_w_unscaled = np.fft.fftshift(np.fft.fft2(p_windowed))\n        P_w = P_w_unscaled * dx * dy\n        \n        # --- Metric 1: Spectral Leakage Fraction (L) ---\n        power_spectrum = np.abs(P_w)**2\n        \n        mask_prop = (np.abs(kx_grid) = k)  (np.abs(ky_grid) = k)\n        mask_ml = (np.abs(kx_grid) = kx_roi)  (np.abs(ky_grid) = ky_roi)\n        mask_leakage = mask_prop  ~mask_ml\n        \n        total_prop_power = np.sum(power_spectrum[mask_prop])\n        leakage_power = np.sum(power_spectrum[mask_leakage])\n        \n        L = leakage_power / total_prop_power if total_prop_power > 0 else 0.0\n\n        # --- Metrics 2  3: FWHM and Side-lobe Ratio (S) ---\n        p_kx_slice = P_w[Ny // 2, :]\n        mag_slice = np.abs(p_kx_slice)\n        \n        peak_mag = np.max(mag_slice)\n        peak_idx = np.argmax(mag_slice)\n        \n        # Metric 2: FWHM\n        target_mag = peak_mag / np.sqrt(2.0)\n        \n        # Interpolate to find k_right\n        idx_right_search_range = np.arange(peak_idx, Nx)\n        mag_right = mag_slice[idx_right_search_range]\n        kx_right = kx_vals[idx_right_search_range]\n        k_right_interp = np.interp(target_mag, mag_right[::-1], kx_right[::-1])\n        \n        # Interpolate to find k_left\n        idx_left_search_range = np.arange(0, peak_idx + 1)\n        mag_left = mag_slice[idx_left_search_range]\n        kx_left = kx_vals[idx_left_search_range]\n        k_left_interp = np.interp(target_mag, mag_left, kx_left)\n\n        FWHM = k_right_interp - k_left_interp\n\n        # Metric 3: Peak Side-lobe Ratio (S)\n        mask_sidelobe = (np.abs(kx_vals) > kx_roi)  (np.abs(kx_vals) = k)\n        \n        if np.any(mask_sidelobe):\n            peak_sidelobe_mag = np.max(mag_slice[mask_sidelobe])\n            S = peak_sidelobe_mag / peak_mag if peak_mag > 0 else 0.0\n        else:\n            S = 0.0\n            \n        results.append([L, FWHM, S])\n\n    # Format the final output string\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        output_str += f\"[{res[0]},{res[1]},{res[2]}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "对于具有复杂三维辐射特性的声源，我们需要在包围声源的闭合曲面（如球面）上进行测量，以完整地捕捉其声学特征。声场可以被分解为一系列正交的球谐函数模态，通过将测量的近场数据投影到这个基上，我们可以确定每个出射波的系数。这项实践  旨在实现这种功能强大的近场-远场变换（NFFT）技术，让您亲手验证如何从球形近场数据中准确提取完整的远场方向图，这是声源特性表征的关键一步。",
            "id": "4131134",
            "problem": "要求您设计并实现一个数值实验，以验证计算声学中的远场提取，方法是在一个封闭球面上测量声压 $p$，并将数值提取的远场与在 $r \\to \\infty$ 极限下的解析渐近行为 $p(\\mathbf{x}) \\sim \\dfrac{e^{i k r}}{r} f(\\hat{\\mathbf{x}})$ 进行比较，其中 $\\hat{\\mathbf{x}}$ 是单位观测方向。\n\n从一个基本基础开始：在紧凑源之外的区域，外部声场 $p$ 满足齐次 Helmholtz 方程 $\\nabla^2 p + k^2 p = 0$，并遵循 Sommerfeld 辐射条件。在任何一个以原点为中心、包围源区域的半径为 $r$ 的球面上，解可以展开为球谐函数级数。角向依赖性可以用球谐函数表示，径向依赖性可以用球贝塞尔函数和球汉克尔函数表示。利用这些事实和球谐函数的正交性，推导出一个算法，用于从球形测量表面上的近场测量值 $p$ 中提取远场振幅 $f(\\hat{\\mathbf{x}})$。\n\n在这个数值实验中，“测量”的近场数据由单个出射球谐波模式合成，因此精确的远场是已知的。对于选定的非负整数阶数 $l$ 和整数序数 $m$（满足 $-l \\le m \\le l$），定义外部场为\n$$\np(r,\\theta,\\phi) = A\\, h_l^{(1)}(k r)\\, Y_l^m(\\theta,\\phi),\n$$\n其中 $A$ 是复振幅，$h_l^{(1)}$ 是第一类球汉克尔函数，$Y_l^m$ 是具有 Condon-Shortley 相位的标准正交球谐函数，$r$ 是半径，$\\theta$ 是极角，$\\phi$ 是方位角。角度必须以弧度处理。\n\n您的任务：\n- 从所描述的基本基础出发，推导一个数学上合理的程序，该程序：\n  1. 使用半径为 $r_0$ 的球面上的 $p$ 的表面样本，通过在单位球上使用正交关系进行投影来计算与 $(l,m)$ 球谐函数相关的模态系数，并使用数值积分实现。\n  2. 使用 $h_l^{(1)}(k r)$ 的大 $r$ 渐近行为，来获得单位球上一般方向 $\\hat{\\mathbf{x}}$ 的 $f(\\hat{\\mathbf{x}})$。\n- 使用数值稳定的球面数值积分法来实现该程序，该方法应考虑曲面元 $d\\Omega = \\sin\\theta\\, d\\theta\\, d\\phi$ 中的权重因子 $\\sin\\theta$。在 $\\mu = \\cos\\theta$ 上使用 Gauss-Legendre 数值积分，在 $\\phi$ 上使用均匀梯形法则。\n- 通过计算在一组单位球上的观测方向上，数值提取的远场振幅与解析远场振幅之间的相对误差来验证远场提取。使用以下误差度量：\n$$\n\\varepsilon = \\frac{\\left\\| f_{\\mathrm{num}}(\\hat{\\mathbf{x}}_j) - f_{\\mathrm{ana}}(\\hat{\\mathbf{x}}_j) \\right\\|_{2}}{\\left\\| f_{\\mathrm{ana}}(\\hat{\\mathbf{x}}_j) \\right\\|_{2}},\n$$\n其中离散 $\\ell^2$ 范数是在所有观测方向 $\\hat{\\mathbf{x}}_j$ 上聚合的，$f_{\\mathrm{num}}$ 和 $f_{\\mathrm{ana}}$ 分别是数值提取和解析的远场振幅。\n- 所有角度必须使用弧度。由于 $A$ 是无量纲的，误差 $\\varepsilon$ 也是无量纲的，因此不需要进行物理单位转换。\n\n测试套件：\n为以下参数集计算误差 $\\varepsilon$，每个参数集表示为一个元组 $(k, r_0, l, m, A)$，其中 $k$ 是波数（单位为 $\\mathrm{rad}/\\mathrm{m}$），$r_0$ 是测量球面半径（单位为 $\\mathrm{m}$），$l$ 和 $m$ 指定球谐波模式，$A$ 是复振幅：\n- 情况 1：$(k, r_0, l, m, A) = (10.0, 0.75, 0, 0, 1.0)$。\n- 情况 2：$(k, r_0, l, m, A) = (20.0, 1.10, 1, 0, 0.7)$。\n- 情况 3：$(k, r_0, l, m, A) = (35.0, 1.30, 5, 3, 1.2)$。\n\n观测方向：\n使用一组由 $\\theta_j \\in \\{\\pi/8, 3\\pi/8, 5\\pi/8\\}$ 和 $\\phi_j \\in \\{ 2\\pi n / 10 \\mid n = 0,1,\\dots,9 \\}$ 定义的方向 $(\\theta_j,\\phi_j)$，构成 $30$ 个方向。角度必须以弧度为单位。\n\n需遵守的实现细节：\n- 球谐函数必须在 $\\int_{0}^{2\\pi}\\int_{0}^{\\pi} Y_l^m(\\theta,\\phi)\\, Y_{l'}^{m'}(\\theta,\\phi)^{*}\\, \\sin\\theta\\, d\\theta\\, d\\phi = \\delta_{l l'} \\delta_{m m'}$ 的意义上是标准正交的。\n- 使用足够精细的数值积分来数值逼近曲面积分。推荐的配置是在 $\\mu = \\cos\\theta$ 上使用 $N_\\theta = 64$ 个 Gauss-Legendre 节点，在 $\\phi$ 上使用 $N_\\phi = 128$ 个均匀间隔的节点。\n- 所有角度均以弧度表示。\n- 最终程序不得读取任何输入。它必须计算三个测试用例的误差，并生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。例如：$[e_1,e_2,e_3]$，其中每个 $e_i$ 是一个浮点数。\n\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[e_1,e_2,e_3]$）。",
            "solution": "该问题要求设计并实现一个数值实验，以验证计算声学中的远场提取程序。该过程涉及合成近场压力分布，使用它通过数值积分计算模态系数，重建远场振幅，并将其与已知的解析解进行比较以计算误差。\n\n### 远场提取程序的数学推导\n\n在一个紧凑源区域外部，满足 Helmholtz 方程 $\\nabla^2 p + k^2 p = 0$ 和 Sommerfeld 辐射条件的声压场 $p(\\mathbf{x})$，可以表示为一系列出射球面波。在球坐标 $(r, \\theta, \\phi)$ 中，该展开式为：\n$$\np(r, \\theta, \\phi) = \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{l} a_{lm} h_l^{(1)}(k r) Y_l^m(\\theta, \\phi)\n$$\n其中 $a_{lm}$ 是复模态系数，$h_l^{(1)}$ 是第一类球汉克尔函数（表示出射波），$Y_l^m$ 是标准正交球谐函数。\n\n远场行为由 $r \\to \\infty$ 时的渐近关系 $p(\\mathbf{x}) \\sim \\frac{e^{ikr}}{r} f(\\hat{\\mathbf{x}})$ 定义。为了找到远场振幅 $f(\\hat{\\mathbf{x}})$，我们使用球汉克尔函数的大宗量渐近形式：\n$$\nh_l^{(1)}(z) \\sim \\frac{1}{z} e^{i(z - (l+1)\\pi/2)} = \\frac{(-i)^{l+1}}{z} e^{iz} \\quad \\text{for } z \\to \\infty\n$$\n将 $z=kr$ 代入压力展开式中：\n$$\np(r, \\theta, \\phi) \\sim \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{l} a_{lm} \\left( \\frac{(-i)^{l+1}}{kr} e^{ikr} \\right) Y_l^m(\\theta, \\phi) = \\frac{e^{ikr}}{r} \\left( \\frac{1}{k} \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{l} a_{lm} (-i)^{l+1} Y_l^m(\\theta, \\phi) \\right)\n$$\n通过将其与 $f(\\hat{\\mathbf{x}})$ 的定义进行比较，我们确定远场振幅为：\n$$\nf(\\hat{\\mathbf{x}}) = f(\\theta, \\phi) = \\frac{1}{k} \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{l} a_{lm} (-i)^{l+1} Y_l^m(\\theta, \\phi)\n$$\n核心任务是从近场数据中确定系数 $a_{lm}$。给定在半径为 $r_0$ 的测量球面上的压力 $p(r_0, \\theta, \\phi)$，我们可以利用球谐函数的标准正交性，$\\int_{S^2} Y_l^m(\\theta, \\phi) (Y_{l'}^{m'}(\\theta, \\phi))^* d\\Omega = \\delta_{ll'} \\delta_{mm'}$，其中 $d\\Omega = \\sin\\theta d\\theta d\\phi$。\n\n将 $r=r_0$ 处的压力展开式乘以 $(Y_l^m)^*$ 并在单位球上积分，得到：\n$$\n\\int_{S^2} p(r_0, \\theta, \\phi) (Y_l^m(\\theta, \\phi))^* d\\Omega = \\sum_{l'=0}^{\\infty} \\sum_{m'=-l'}^{l'} a_{l'm'} h_{l'}^{(1)}(kr_0) \\int_{S^2} Y_{l'}^{m'}(\\theta, \\phi) (Y_l^m(\\theta, \\phi))^* d\\Omega\n$$\n由于正交性，总和中除 $(l', m')=(l, m)$ 之外的所有项都消失，从而得到：\n$$\n\\int_{S^2} p(r_0, \\theta, \\phi) (Y_l^m(\\theta, \\phi))^* d\\Omega = a_{lm} h_l^{(1)}(kr_0)\n$$\n因此，可以使用以下公式提取模态系数 $a_{lm}$：\n$$\na_{lm} = \\frac{1}{h_l^{(1)}(kr_0)} \\int_0^{2\\pi} \\int_0^\\pi p(r_0, \\theta, \\phi) (Y_l^m(\\theta, \\phi))^* \\sin\\theta d\\theta d\\phi\n$$\n\n### 数值实现\n\n问题提供了一个由单一模式 $(l,m)$ 组成的合成场：\n$$\np(r, \\theta, \\phi) = A h_l^{(1)}(kr) Y_l^m(\\theta, \\phi)\n$$\n对于这个场，解析系数就是 $a_{lm} = A$，所有其他系数都为零。因此，解析远场振幅为：\n$$\nf_{\\mathrm{ana}}(\\theta, \\phi) = \\frac{A}{k} (-i)^{l+1} Y_l^m(\\theta, \\phi)\n$$\n\n数值程序如下：\n1.  **合成数据**：在球面数值积分网格上评估 $p(r_0, \\theta, \\phi)$。\n2.  **数值积分**：使用数值积分法来近似 $a_{lm}$ 的积分。球面上的积分通过变量替换为 $\\mu = \\cos\\theta$ 来处理，因此 $\\sin\\theta d\\theta d\\phi$ 变为 $d\\mu d\\phi$。我们对 $\\mu$ 的积分（从 $-1$ 到 $1$）使用 Gauss-Legendre 数值积分，对 $\\phi$ 的积分（从 $0$ 到 $2\\pi$）使用梯形法则。对于 $\\theta$ 中的 $N_\\theta$ 个点和 $\\phi$ 中的 $N_\\phi$ 个点，函数 $G(\\theta, \\phi)$ 的积分近似为：\n    $$\n    \\int_{S^2} G(\\theta, \\phi) d\\Omega \\approx \\sum_{i=1}^{N_\\theta} w_i \\left( \\frac{2\\pi}{N_\\phi} \\sum_{j=0}^{N_\\phi-1} G(\\theta_i, \\phi_j) \\right)\n    $$\n    其中 $(\\mu_i, w_i)$ 是 Gauss-Legendre 节点和权重，$\\theta_i = \\arccos(\\mu_i)$，并且 $\\phi_j = 2\\pi j / N_\\phi$。\n3.  **计算系数**：使用 $a_{lm}$ 的公式和数值计算的积分值来计算数值系数 $a_{lm, \\text{num}}$。\n4.  **构建数值远场**：数值提取的远场为 $f_{\\mathrm{num}}(\\theta, \\phi) = \\frac{a_{lm, \\text{num}}}{k} (-i)^{l+1} Y_l^m(\\theta, \\phi)$。\n5.  **计算误差**：计算相对误差 $\\varepsilon$。由于问题的单模特性，误差度量简化为：\n    $$\n    \\varepsilon = \\frac{\\left\\| f_{\\mathrm{num}} - f_{\\mathrm{ana}} \\right\\|_{2}}{\\left\\| f_{\\mathrm{ana}} \\right\\|_{2}} = \\frac{\\left\\| \\frac{(a_{lm, \\text{num}} - A)}{k}(-i)^{l+1} Y_l^m \\right\\|_{2}}{\\left\\| \\frac{A}{k}(-i)^{l+1} Y_l^m \\right\\|_{2}}\n    $$\n    涉及 $Y_l^m$, $k$, 和 $(-i)^{l+1}$ 的项在范数中被消去，将误差简化为提取系数的相对误差：\n    $$\n    \\varepsilon = \\frac{|a_{lm, \\text{num}} - A|}{|A|}\n    $$\n    这种简化表明，在这个特定问题中，计算误差不需要观测方向集，因为误差与观测方向无关，仅由用于提取系数的数值积分的精度决定。验证的核心在于单个数值积分。\n\n实现将直接遵循这个推导出的程序：在数值积分网格上合成场，将其投影回已知模式以获得 $a_{lm, \\text{num}}$，然后计算与已知系数 $A$ 的相对误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import sph_harm, spherical_jn, spherical_yn\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Solves the computational acoustics problem for the given test cases.\n    \"\"\"\n    \n    def h_l_1(l_val, x):\n        \"\"\"\n        Computes the spherical Hankel function of the first kind h_l^(1)(x).\n        Args:\n            l_val: int, the order of the function.\n            x: float or array-like, the argument(s).\n        Returns:\n            Complex value(s) of the Hankel function.\n        \"\"\"\n        # scipy functions for spherical Bessel functions j_n(x) and y_n(x)\n        return spherical_jn(l_val, x) + 1j * spherical_yn(l_val, x)\n\n    def calculate_error(k, r0, l_mode, m_mode, A_amp):\n        \"\"\"\n        Calculates the relative error for a single test case.\n        Args:\n            k: Wavenumber.\n            r0: Measurement sphere radius.\n            l_mode: Degree of the spherical harmonic.\n            m_mode: Order of the spherical harmonic.\n            A_amp: Complex amplitude of the mode.\n        Returns:\n            The relative error epsilon.\n        \"\"\"\n        N_theta = 64\n        N_phi = 128\n\n        # 1. Setup quadrature grid\n        # Gauss-Legendre quadrature for theta integration (via mu=cos(theta))\n        mu_nodes, weights = leggauss(N_theta)  # mu is in [-1, 1]\n        theta_nodes = np.arccos(mu_nodes)     # theta is in [pi, 0]\n\n        # Uniform trapezoidal rule for phi integration\n        phi_nodes = np.linspace(0, 2 * np.pi, N_phi, endpoint=False)\n        \n        # Create a meshgrid for vectorized calculations.\n        # 'ij' indexing ensures theta corresponds to the first axis.\n        theta_grid, phi_grid = np.meshgrid(theta_nodes, phi_nodes, indexing='ij')\n        \n        # 2. Synthesize \"measured\" field p(r0, theta, phi) on the quadrature grid.\n        # Note: scipy.special.sph_harm expects arguments (m, l, phi, theta).\n        ylm_values = sph_harm(m_mode, l_mode, phi_grid, theta_grid)\n        \n        # Calculate the Hankel function value (it's a scalar constant for the grid)\n        h_val = h_l_1(l_mode, k * r0)\n        \n        p_values = A_amp * h_val * ylm_values\n\n        # 3. Compute the modal coefficient via numerical projection.\n        # The integrand for the projection is p * conj(Y_l^m).\n        integrand = p_values * np.conj(ylm_values)\n        \n        # Perform quadrature: Sum_i(w_i * Sum_j(integrand_ij * d_phi) )\n        # where d_phi = 2*pi/N_phi.\n        # NumPy broadcasting is used for efficiency: weights is (N_theta,), integrand is (N_theta, N_phi).\n        # weights[:, np.newaxis] has shape (N_theta, 1), which broadcasts over the phi dimension.\n        integral_val = (2 * np.pi / N_phi) * np.sum(weights[:, np.newaxis] * integrand)\n        \n        # 4. Extract the numerical coefficient from the integral.\n        a_lm_num = integral_val / h_val\n\n        # 5. Calculate the relative error.\n        # As derived, this simplifies to the relative error of the coefficient.\n        error = np.abs(a_lm_num - A_amp) / np.abs(A_amp)\n        \n        return error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, r0, l, m, A)\n        (10.0, 0.75, 0, 0, 1.0),\n        (20.0, 1.10, 1, 0, 0.7),\n        (35.0, 1.30, 5, 3, 1.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        k_val, r0_val, l_val, m_val, A_val = case\n        err = calculate_error(k_val, r0_val, l_val, m_val, A_val)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    # Using high precision floating point format for clear results.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论模型是理想的，但真实的测量数据总是伴随着误差，例如传感器阵列的幅度和相位校准误差。这些看似微小的随机误差会在远场重建过程中传播并累积，最终影响预测结果的可靠性。通过本练习 ，我们将从统计学的角度出发，推导并量化这些近场测量误差对远场方向图的影响，并学习如何制定误差预算和容差，以确保最终的声学预测达到预期的精度要求。",
            "id": "4123308",
            "problem": "给定一条由$N$个声学传感器组成的一维测量线，这些传感器沿$x$轴分布在一个声速为$c$的均匀、无损介质中。传感器记录了单一角频率$\\omega=2\\pi f$（其中$f$是频率，单位为赫兹）下的复声压。需要从近场传感器数据重构出观测角$\\theta$（单位为弧度）处的远场声压模式。目标是评估传感器相位噪声和幅度校准误差对重构远场模式的影响，并推导出在指定的关注角域内，将相对均方根误差保持在预定阈值以下所需的容差。\n\n从以下基本原理出发：\n- 均匀介质中的声压$p(\\mathbf{r})$满足亥姆霍兹方程$\\nabla^2 p + k^2 p = 0$，其中$k=\\omega/c$是波数。\n- 在Fraunhofer近似下，远场中的场可以表示为声压在某个平面上的傅里叶型投影。对于一个位于$y=0$沿$x$轴的一维孔径，角度$\\theta$处的远场声压正比于$p(x,0)$乘以一个取决于$\\theta$的相位因子的积分，对于采样数据，这简化为一个离散和。\n\n假设传感器$n$在位置$x_n$处测得的无误差近场声压为$p_n$，角度$\\theta$处的远场通过间距为$\\Delta x$的离散和重构：\n$$\nS(\\theta) = \\sum_{n=1}^{N} w_n(\\theta)\\, p_n,\n$$\n其中$w_n(\\theta)$是一个已知的单位幅度的复权重，包含了依赖于$k$、$x_n$和$\\theta$的传播相位因子。设测量的近场声压包含每个传感器的小幅度和相位误差：\n$$\n\\tilde{p}_n = p_n \\left(1 + a_n\\right) e^{i \\phi_n},\n$$\n其中$a_n$是均值为零、独立的幅度校准误差（无量纲分数），标准差为$\\sigma_a$；$\\phi_n$是均值为零、独立的相位误差（单位为弧度），标准差为$\\sigma_\\phi$。假设$a_n$和$\\phi_n$在各传感器间独立且相互独立。\n\n将带有误差的重构远场定义为\n$$\n\\tilde{S}(\\theta) = \\sum_{n=1}^{N} w_n(\\theta)\\, \\tilde{p}_n.\n$$\n设角度$\\theta$处的相对均方误差为\n$$\n\\varepsilon^2(\\theta) = \\frac{\\mathbb{E}\\left[\\,\\left|\\tilde{S}(\\theta) - S(\\theta)\\right|^2\\,\\right]}{\\left|S(\\theta)\\right|^2}.\n$$\n\n您的任务是：\n1. 从第一性原理出发，使用对小$\\phi_n$的一阶线性化，推导出$\\varepsilon^2(\\theta)$关于$\\sigma_a$、$\\sigma_\\phi$、$p_n$、$w_n(\\theta)$和$S(\\theta)$的表达式。\n2. 基于您的表达式，推导$(\\sigma_a, \\sigma_\\phi)$的容差，以使$\\varepsilon(\\theta)$在一个关注角域内的最大值受一个预设阈值$\\varepsilon_{\\mathrm{th}}$的限制。该关注区域定义为参考远场幅度$\\left|S(\\theta)\\right|$至少为其峰值的$g_{\\min}$倍的角度集合，即$\\left|S(\\theta)\\right| \\ge g_{\\min}\\,\\max_{\\theta} \\left|S(\\theta)\\right|$。\n3. 实现一个程序，该程序：\n   - 构造一个合成的近场$p_n$，作为入射到传感器线上的两个平面波的相干叠加：\n     $$\n     p_n = e^{i k \\sin(\\theta_0) x_n} + \\beta\\, e^{i k \\sin(\\theta_1) x_n},\n     $$\n     其中$\\theta_0$和$\\theta_1$是入射角（单位为弧度），$\\beta$是一个实数幅度缩放因子。\n   - 使用权重为$w_n(\\theta) = \\Delta x\\, e^{-i k x_n \\sin(\\theta)}$的离散Fraunhofer型求和，在一个角度网格$\\theta \\in [-\\pi/3,\\pi/3]$（单位为弧度）上计算$S(\\theta)$。\n   - 计算定义的$\\Gamma(\\theta)$：\n     $$\n     \\Gamma(\\theta) = \\frac{\\sum_{n=1}^{N} \\left|w_n(\\theta) p_n\\right|^2}{\\left|S(\\theta)\\right|^2},\n     $$\n     并用它来获得$(\\sigma_a, \\sigma_\\phi)$的容差，以保证$\\max_{\\theta \\in \\mathcal{R}} \\varepsilon(\\theta) \\le \\varepsilon_{\\mathrm{th}}$，其中$\\mathcal{R}$是关注区域。\n   - 通过一个指定的分配参数$\\alpha \\in [0,1]$在幅度和相位之间分配组合容差预算，使得\n     $$\n     \\sigma_a = \\alpha\\, \\frac{\\varepsilon_{\\mathrm{th}}}{\\sqrt{\\max_{\\theta \\in \\mathcal{R}} \\Gamma(\\theta)}},\\quad\n     \\sigma_{\\phi} = \\sqrt{1 - \\alpha^2}\\, \\frac{\\varepsilon_{\\mathrm{th}}}{\\sqrt{\\max_{\\theta \\in \\mathcal{R}} \\Gamma(\\theta)}}.\n     $$\n4. 程序必须生成包含每个给定测试用例的容差$(\\sigma_a, \\sigma_\\phi)$的最终输出，连接成一个单一的浮点数列表。\n\n使用以下参数值的测试套件：\n- 测试用例1（理想情况）：\n  - $N=64$，$L=0.512$米（均匀间距），$f=6000$赫兹，$c=343$米/秒，$\\theta_0 = 0$弧度，$\\theta_1 = 0.34906585$弧度，$\\beta=0.6$，$\\varepsilon_{\\mathrm{th}}=0.05$，$g_{\\min}=0.2$，$\\alpha=0.7$。\n- 测试用例2（近混叠，较高频率）：\n  - $N=32$，$L=0.256$米（均匀间距），$f=12000$赫兹，$c=343$米/秒，$\\theta_0 = 0.26179939$弧度，$\\theta_1 = -0.34906585$弧度，$\\beta=0.4$，$\\varepsilon_{\\mathrm{th}}=0.1$，$g_{\\min}=0.1$，$\\alpha=0.5$。\n- 测试用例3（窄孔径，宽波束）：\n  - $N=128$，$L=0.128$米（均匀间距），$f=4000$赫兹，$c=343$米/秒，$\\theta_0 = 0$弧度，$\\theta_1 = 0.52359878$弧度，$\\beta=0.3$，$\\varepsilon_{\\mathrm{th}}=0.02$，$g_{\\min}=0.3$，$\\alpha=0.8$。\n\n重要实现细节：\n- 传感器位置$x_n$在$[-L/2, L/2]$上均匀分布，间距为$\\Delta x = L/(N-1)$。\n- 在$[-\\pi/3,\\pi/3]$弧度范围内的一个包含$181$个样本的均匀间隔网格上计算角度。\n- 幅度误差$\\sigma_a$必须以无量纲分数报告。相位误差$\\sigma_\\phi$必须以弧度报告。\n- 所有角度必须以弧度处理和报告。\n- 您的程序应生成一行输出，包含一个用方括号括起来的逗号分隔列表形式的结果。列表顺序必须是$[\\sigma_{a,1},\\sigma_{\\phi,1},\\sigma_{a,2},\\sigma_{\\phi,2},\\sigma_{a,3},\\sigma_{\\phi,3}]$，每个条目都是一个浮点数。",
            "solution": "### 步骤1：误差表达式推导\n\n首先，推导相对均方误差$\\varepsilon^2(\\theta)$的表达式。重构远场中的误差$\\Delta S(\\theta)$是含误差的重构$\\tilde{S}(\\theta)$与理想重构$S(\\theta)$之差：\n$$\n\\Delta S(\\theta) = \\tilde{S}(\\theta) - S(\\theta) = \\sum_{n=1}^{N} w_n(\\theta) (\\tilde{p}_n - p_n)\n$$\n带噪声的声压测量$\\tilde{p}_n$由$\\tilde{p}_n = p_n (1 + a_n) e^{i \\phi_n}$给出。对于小的相位误差$\\phi_n$，使用一阶泰勒展开$e^{i \\phi_n} \\approx 1 + i \\phi_n$。代入并忽略二阶小项$a_n \\phi_n$后，得到：\n$$\n\\tilde{p}_n - p_n \\approx p_n (a_n + i \\phi_n)\n$$\n因此，远场误差为：\n$$\n\\Delta S(\\theta) \\approx \\sum_{n=1}^{N} w_n(\\theta) p_n (a_n + i \\phi_n)\n$$\n我们计算此误差的幅值平方的期望值，$\\mathbb{E}[|\\Delta S(\\theta)|^2]$：\n$$\n\\mathbb{E}[|\\Delta S(\\theta)|^2] = \\mathbb{E}\\left[ \\left(\\sum_{n=1}^{N} w_n p_n (a_n + i \\phi_n)\\right) \\left(\\sum_{m=1}^{N} w_m^* p_m^* (a_m - i \\phi_m)\\right) \\right]\n$$\n$$\n= \\sum_{n=1}^{N} \\sum_{m=1}^{N} w_n p_n w_m^* p_m^* \\, \\mathbb{E}[(a_n + i \\phi_n)(a_m - i \\phi_m)]\n$$\n由于误差是均值为零、相互独立且在各传感器间独立的，$\\mathbb{E}[a_n a_m] = \\sigma_a^2 \\delta_{nm}$，$\\mathbb{E}[\\phi_n \\phi_m] = \\sigma_\\phi^2 \\delta_{nm}$，且交叉项的期望为零。因此，\n$$\n\\mathbb{E}[(a_n + i \\phi_n)(a_m - i \\phi_m)] = (\\sigma_a^2 + \\sigma_\\phi^2) \\delta_{nm}\n$$\n双重求和简化为单重求和：\n$$\n\\mathbb{E}[|\\Delta S(\\theta)|^2] = (\\sigma_a^2 + \\sigma_\\phi^2) \\sum_{n=1}^{N} |w_n(\\theta) p_n|^2\n$$\n最后，相对均方误差的表达式为：\n$$\n\\varepsilon^2(\\theta) = (\\sigma_a^2 + \\sigma_\\phi^2) \\frac{\\sum_{n=1}^{N} |w_n(\\theta) p_n|^2}{|S(\\theta)|^2}\n$$\n\n### 步骤2：误差容差推导\n\n容差条件是$\\max_{\\theta \\in \\mathcal{R}} \\varepsilon(\\theta) \\le \\varepsilon_{\\mathrm{th}}$，其中$\\mathcal{R}$是关注区域。这等价于$\\max_{\\theta \\in \\mathcal{R}} \\varepsilon^2(\\theta) \\le \\varepsilon_{\\mathrm{th}}^2$。\n使用$\\Gamma(\\theta)$的定义，$\\Gamma(\\theta) = \\frac{\\sum_{n=1}^{N} |w_n(\\theta) p_n|^2}{|S(\\theta)|^2}$，我们有：\n$$\n\\varepsilon^2(\\theta) = (\\sigma_a^2 + \\sigma_\\phi^2) \\Gamma(\\theta)\n$$\n容差条件变为：\n$$\n(\\sigma_a^2 + \\sigma_\\phi^2) \\max_{\\theta \\in \\mathcal{R}} \\Gamma(\\theta) \\le \\varepsilon_{\\mathrm{th}}^2\n$$\n这建立了一个误差预算。最大允许误差由等式给出：\n$$\n\\sigma_a^2 + \\sigma_\\phi^2 = \\frac{\\varepsilon_{\\mathrm{th}}^2}{\\max_{\\theta \\in \\mathcal{R}} \\Gamma(\\theta)}\n$$\n使用分配参数$\\alpha$，我们得到指定的容差公式：\n$$\n\\sigma_a = \\alpha\\, \\frac{\\varepsilon_{\\mathrm{th}}}{\\sqrt{\\max_{\\theta \\in \\mathcal{R}} \\Gamma(\\theta)}},\\quad\n\\sigma_{\\phi} = \\sqrt{1 - \\alpha^2}\\, \\frac{\\varepsilon_{\\mathrm{th}}}{\\sqrt{\\max_{\\theta \\in \\mathcal{R}} \\Gamma(\\theta)}}\n$$\n\n### 步骤3：算法实现\n\n对每个测试用例，算法如下：\n1.  **参数初始化**：计算波数$k$，传感器位置$x_n$，以及角度网格$\\theta_j$。\n2.  **近场计算**：计算每个传感器处的复声压$p_n$。\n3.  **远场计算**：对每个角度$\\theta_j$计算理想远场模式$S(\\theta_j)$。\n4.  **$\\Gamma(\\theta)$计算**：计算分子$\\sum |w_n p_n|^2$（与$\\theta$无关），然后对每个$\\theta_j$除以$|S(\\theta_j)|^2$得到$\\Gamma(\\theta_j)$。\n5.  **确定关注区域$\\mathcal{R}$**：找到$|S(\\theta)|$的最大值$S_{\\max}$，然后确定满足$|S(\\theta_j)| \\ge g_{\\min} S_{\\max}$的角度索引。\n6.  **寻找$\\Gamma_{\\max, \\mathcal{R}}$**：在$\\mathcal{R}$对应的$\\Gamma(\\theta_j)$值中找到最大值。\n7.  **计算容差**：使用步骤2中的公式计算$\\sigma_a$和$\\sigma_\\phi$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 64, \"L\": 0.512, \"f\": 6000, \"c\": 343, \n            \"theta0\": 0, \"theta1\": 0.34906585, \"beta\": 0.6,\n            \"eps_th\": 0.05, \"g_min\": 0.2, \"alpha\": 0.7\n        },\n        {\n            \"N\": 32, \"L\": 0.256, \"f\": 12000, \"c\": 343,\n            \"theta0\": 0.26179939, \"theta1\": -0.34906585, \"beta\": 0.4,\n            \"eps_th\": 0.1, \"g_min\": 0.1, \"alpha\": 0.5\n        },\n        {\n            \"N\": 128, \"L\": 0.128, \"f\": 4000, \"c\": 343,\n            \"theta0\": 0, \"theta1\": 0.52359878, \"beta\": 0.3,\n            \"eps_th\": 0.02, \"g_min\": 0.3, \"alpha\": 0.8\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        sigma_a, sigma_phi = calculate_tolerances(**params)\n        results.extend([sigma_a, sigma_phi])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_tolerances(N, L, f, c, theta0, theta1, beta, eps_th, g_min, alpha):\n    \"\"\"\n    Calculates the amplitude and phase error tolerances for a single test case.\n\n    Args:\n        N (int): Number of sensors.\n        L (float): Length of the sensor line in meters.\n        f (float): Frequency in Hertz.\n        c (float): Speed of sound in meters per second.\n        theta0 (float): Incidence angle of the first plane wave in radians.\n        theta1 (float): Incidence angle of the second plane wave in radians.\n        beta (float): Amplitude scaling factor for the second plane wave.\n        eps_th (float): Relative RMS error threshold.\n        g_min (float): Fraction of peak magnitude for region of interest.\n        alpha (float): Tolerance allocation parameter.\n\n    Returns:\n        tuple[float, float]: A tuple containing the calculated tolerances \n                             (sigma_a, sigma_phi).\n    \"\"\"\n\n    # Step 1: Initialize Parameters\n    # Wavenumber\n    k = 2 * np.pi * f / c\n    \n    # Sensor positions\n    # If N=1, spacing is undefined. Problem assumes N > 1.\n    if N > 1:\n        delta_x = L / (N - 1)\n        x_n = np.linspace(-L / 2, L / 2, N)\n    else: # Edge case for N=1\n        delta_x = 0\n        x_n = np.array([0.0])\n\n    # Angle grid\n    num_angles = 181\n    theta_grid = np.linspace(-np.pi / 3, np.pi / 3, num_angles)\n\n    # Step 2: Compute Near-Field Pressure\n    p_n = np.exp(1j * k * np.sin(theta0) * x_n) + \\\n          beta * np.exp(1j * k * np.sin(theta1) * x_n)\n\n    # Step 3: Compute Ideal Far-Field Pattern S(theta)\n    # S(theta_j) = sum_n { delta_x * exp(-1j*k*x_n*sin(theta_j)) * p_n }\n    # This can be computed efficiently using matrix operations.\n    sin_theta = np.sin(theta_grid)\n    # Outer product of x_n and sin_theta gives the exponent matrix\n    exp_matrix = np.exp(-1j * k * np.outer(x_n, sin_theta))\n    # S(theta) is the dot product of p_n with columns of the weight matrix\n    S_theta = delta_x * (p_n @ exp_matrix)\n\n    # Step 4: Compute Gamma(theta)\n    # Numerator of Gamma: sum_n |w_n(theta) * p_n|^2\n    # Since |w_n(theta)| = delta_x, this is (delta_x^2) * sum_n |p_n|^2\n    numerator_gamma = (delta_x**2) * np.sum(np.abs(p_n)**2)\n    \n    # Denominator of Gamma: |S(theta)|^2\n    # Add a small epsilon to avoid division by zero at pattern nulls\n    # These nulls will be excluded by the region of interest definition anyway.\n    S_theta_mag_sq = np.abs(S_theta)**2\n    # Protect against division by zero in case of an all-zero pattern\n    S_theta_mag_sq[S_theta_mag_sq  1e-30] = 1e-30\n    Gamma_theta = numerator_gamma / S_theta_mag_sq\n\n    # Step 5: Identify Region of Interest (ROI)\n    S_theta_mag = np.abs(S_theta)\n    S_max = np.max(S_theta_mag)\n    \n    # If the pattern is zero everywhere, the ROI is empty. Handle this case.\n    if S_max  1e-15:\n      # This case implies Gamma is infinite, making tolerances zero.\n      return 0.0, 0.0\n      \n    S_min_roi = g_min * S_max\n    \n    # Create a boolean mask for the angles in the ROI\n    roi_mask = S_theta_mag >= S_min_roi\n    \n    # If the ROI is empty (e.g., g_min > 1), we cannot proceed.\n    # The max of an empty set is undefined. We assume this won't happen \n    # with valid problem parameters.\n    if not np.any(roi_mask):\n        # This implies all signal is below g_min*S_max.\n        # This can happen if g_min is large. In this scenario, there's no\n        # region to enforce the tolerance. We could interpret this as\n        # requiring infinite precision (zero tolerance).\n        return 0.0, 0.0\n\n    # Step 6: Find Maximum of Gamma(theta) in ROI\n    Gamma_in_roi = Gamma_theta[roi_mask]\n    max_Gamma_in_roi = np.max(Gamma_in_roi)\n\n    # Step 7: Calculate Tolerances\n    # Common factor for both tolerances\n    common_factor = eps_th / np.sqrt(max_Gamma_in_roi)\n    \n    sigma_a = alpha * common_factor\n    sigma_phi = np.sqrt(1 - alpha**2) * common_factor\n    \n    return sigma_a, sigma_phi\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}