{
    "hands_on_practices": [
        {
            "introduction": "在我们模拟或构建时间反转系统之前，我们必须能正确地捕捉波场。这个练习通过将奈奎斯特-香农采样定理应用于声波的时空维度，为我们奠定了必要的理论基础。理解这些约束是避免混叠、确保波场的任何数字表示都忠实于物理现实的第一步。",
            "id": "4147332",
            "problem": "一个线性时间反转镜由$N$个相同的全向声学换能器组成，这些换能器沿$x$轴放置在$x_m = m d$（$m = 0,1,\\dots,N-1$）的位置上，具有均匀间距$d$和孔径长度$(N-1)d$。介质是均匀的，声速为$c_0$，在感兴趣的频带内色散可忽略不计。一个位于阵列前方半空间的紧凑声源发射一个带限信号，其声场可以很好地近似为传播平面波的叠加，其角频率支持为$|\\omega| \\le \\omega_{\\max}$，到达角（从阵列法线测量）受限于$|\\theta| \\le \\theta_{\\max}$，其中$\\theta_{\\max} \\in (0,\\pi/2]$。每个换能器记录局部声压$p(x_m,t)$，记录的信号被低通滤波到频带$|\\omega| \\le \\omega_{\\max}$，以采样周期$\\Delta t$在时间上进行采样，然后时间反转，并由同一阵列重新发射，以在声源位置重新聚焦。\n\n假设时间反转过程在其他方面是理想的（在连续极限下是完美的时间反转，且换能器自噪声可忽略不计），并且重新聚焦不需要倏逝波分量（即$|k_x|>k$的分量）。使用第一性原理，推导为避免记录场发生混叠（这会破坏重新聚焦）所需的时间和空间上的最小采样约束。您的推导必须从波动方程和平面波解的叠加开始，确定沿阵列的切向波数内容，并在时间和空间上应用采样定理，以获得关于$\\omega_{\\max}$、$c_0$、$d$和$\\theta_{\\max}$的严格奈奎斯特不等式。然后选择正确陈述这些严格约束的选项。\n\n选项：\n\nA. 时间采样必须满足$\\Delta t \\le \\pi/\\omega_{\\max}$。空间采样必须满足$d \\le \\pi/k_x^{\\max}$，其中$k_x^{\\max} = k_{\\max}\\,|\\sin\\theta_{\\max}|$且$k_{\\max} = \\omega_{\\max}/c_0$。对于$\\theta_{\\max} = \\pi/2$的情况，这简化为$d \\le \\pi/k_{\\max}$，即$d \\le \\lambda_{\\min}/2$，其中$\\lambda_{\\min} = 2\\pi/k_{\\max}$。\n\nB. 时间采样必须满足$\\Delta t \\le 2\\pi/\\omega_{\\max}$。空间采样必须满足$d \\le \\pi/k_{\\max}$，且与$\\theta_{\\max}$无关。\n\nC. 时间采样必须满足$\\Delta t \\le \\pi/\\omega_{\\max}$。空间采样必须满足$d \\le \\lambda_{\\min}$，即$d \\le 2\\pi/k_{\\max}$。\n\nD. 时间采样必须满足$\\Delta t \\le 1/\\omega_{\\max}$。空间采样必须满足$d \\le \\pi/\\big(2 k_{\\max}|\\sin\\theta_{\\max}|\\big)$。\n\nE. 时间采样必须满足$\\Delta t \\ge \\pi/\\omega_{\\max}$。空间采样必须满足$d \\ge \\pi/k_{\\max}$。",
            "solution": "该问题要求推导时间反转声学实验的最小采样约束。这需要在时间域和空间域都应用奈奎斯特-香农采样定理。\n\n首先，评估问题陈述的有效性。\n\n**步骤1：提取已知条件**\n- **阵列：** 一个由$N$个相同的全向换能器组成的线性时间反转镜。\n- **阵列几何：** 换能器沿$x$轴位于$x_m = m d$（$m = 0,1,\\dots,N-1$）处。间距$d$是均匀的。孔径长度为$(N-1)d$。\n- **介质：** 均匀，声速为$c_0$，色散可忽略。\n- **声场：** 传播平面波的叠加。\n- **时间带宽：** 角频率支持为$|\\omega| \\le \\omega_{\\max}$。\n- **空间带宽：** 到达角$\\theta$（从阵列法线测量）受限于$|\\theta| \\le \\theta_{\\max}$，其中$\\theta_{\\max} \\in (0,\\pi/2]$。\n- **信号处理：** 记录的压力$p(x_m,t)$被低通滤波到$|\\omega| \\le \\omega_{\\max}$，然后以周期$\\Delta t$进行采样。\n- **假设：** 时间反转过程是理想的。重新聚焦不需要倏逝波分量（即$|k_x|>k$，其中$k=\\omega/c_0$）。\n- **目标：** 推导$\\Delta t$和$d$的最小采样约束（严格的奈奎斯特不等式）以避免混叠。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题基于波传播（波动方程）、傅里叶分析和奈奎斯特-香农采样定理等基本原理。所描述的装置是阵列信号处理和计算声学中的一个标准（尽管是理想化的）模型。\n- **适定性：** 问题是适定的。它提供了确定信号在时间和空间上的带宽所需的所有必要参数（$\\omega_{\\max}$, $c_0$, $\\theta_{\\max}$）。要求“最小采样约束”或“严格的奈奎斯特不等式”是一个明确的目标，即找到最大允许的采样间隔。\n- **客观性：** 问题使用精确、客观的科学语言陈述。没有主观或模糊的术语。\n\n问题陈述没有违反任何无效标准。这是一个物理学和工程学中的标准、正式的问题。\n\n**步骤3：结论与行动**\n问题陈述是有效的。下面是解的完整推导过程。\n\n**采样约束的推导**\n\n推导分为两部分：首先是时间域，其次是空间域。两者都依赖于奈奎斯特-香农采样定理，该定理指出，要完美重构一个带限信号，采样率必须至少是信号中最高频率分量的两倍。\n\n**1. 时间采样约束 ($\\Delta t$)**\n\n问题明确指出，记录的信号是带限的，其角频率支持为$|\\omega| \\le \\omega_{\\max}$。这意味着信号不包含幅度大于$\\omega_{\\max}$（单位：弧度/秒）的频率分量。\n\n信号中的最高周期性频率为 $f_{\\max} = \\frac{\\omega_{\\max}}{2\\pi}$。\n\n根据奈奎斯特-香农采样定理，采样频率$f_s$必须满足：\n$$f_s \\ge 2 f_{\\max}$$\n代入$f_s = 1/\\Delta t$和$f_{\\max} = \\omega_{\\max}/(2\\pi)$：\n$$\\frac{1}{\\Delta t} \\ge 2 \\left( \\frac{\\omega_{\\max}}{2\\pi} \\right) = \\frac{\\omega_{\\max}}{\\pi}$$\n为了找到采样周期$\\Delta t$的最严格约束，我们求解$\\Delta t$：\n$$\\Delta t \\le \\frac{\\pi}{\\omega_{\\max}}$$\n这是为避免时间混叠而对时间采样周期的最小约束。\n\n**2. 空间采样约束 ($d$)**\n\n声场是平面波的叠加。一个角频率为$\\omega$、到达角为$\\theta$的单一平面波分量在二维中（阵列在$x$轴上，声源在$y>0$的半空间中）可以写为：\n$$p(x, y, t) = A \\exp(i(k_x x + k_y y - \\omega t))$$\n其中$\\mathbf{k} = (k_x, k_y)$是波矢量。波矢量的大小为$k = |\\mathbf{k}| = \\sqrt{k_x^2 + k_y^2} = \\omega/c_0$。角度$\\theta$是从阵列法线（$y$轴）测量的，所以波矢量的分量是：\n$$k_x = k \\sin\\theta$$\n$$k_y = k \\cos\\theta$$\n换能器位于$x$轴上（在$y=0$处）。阵列采样的场为$p(x_m, 0, t)$。沿阵列的场的空间变化由相位项$\\exp(i k_x x)$决定。量$k_x$是沿阵列轴的切向波数或空间频率。\n\n要在空间上应用采样定理，我们必须找到沿阵列的信号的空间带宽。这由$|k_x|$的最大可能值决定。\n$$|k_x| = |k \\sin\\theta| = \\left| \\frac{\\omega}{c_0} \\sin\\theta \\right|$$\n$|k_x|$的最大值，记为$k_x^{\\max}$，发生在$|\\omega|$和$|\\sin\\theta|$都最大化时。\n- $|\\omega|$的最大值给定为$\\omega_{\\max}$。\n- 到达角受限于$|\\theta| \\le \\theta_{\\max}$。由于$\\theta_{\\max} \\in (0, \\pi/2]$，在此范围内$|\\sin\\theta|$的最大值为$\\sin\\theta_{\\max}$。\n\n因此，最大切向波数为：\n$$k_x^{\\max} = \\frac{\\omega_{\\max}}{c_0} \\sin\\theta_{\\max}$$\n我们定义$k_{\\max} = \\omega_{\\max}/c_0$为最大波数，对应于最高时间频率。可能的角度范围$|\\theta| \\le \\theta_{\\max}$意味着$\\theta \\in [-\\theta_{\\max}, \\theta_{\\max}]$。切向波数的最大幅值确实是在$\\theta = \\pm \\theta_{\\max}$时取到，所以$|k_x| \\le \\frac{\\omega_{\\max}}{c_0}|\\sin(\\pm \\theta_{\\max})| = k_{\\max} \\sin\\theta_{\\max}$，因为$\\sin\\theta_{\\max} > 0$。问题中使用$|\\sin\\theta_{\\max}|$的措辞是等效的。\n$$k_x^{\\max} = k_{\\max} |\\sin\\theta_{\\max}|$$\n因此，沿阵列的信号在空间角频率$k_x$方面是带限的，区间为$[-k_x^{\\max}, k_x^{\\max}]$。\n\n应用空间版本的奈奎斯特-香农采样定理，空间采样间隔$d$必须满足：\n$$d \\le \\frac{\\pi}{k_x^{\\max}}$$\n代入$k_x^{\\max}$的表达式：\n$$d \\le \\frac{\\pi}{k_{\\max} |\\sin\\theta_{\\max}|}$$\n这是为避免空间混叠而对空间采样间隔（换能器间距）的最小约束。\n\n**组合约束：**\n- 时间：$\\Delta t \\le \\frac{\\pi}{\\omega_{\\max}}$\n- 空间：$d \\le \\frac{\\pi}{k_{\\max} |\\sin\\theta_{\\max}|}$，其中$k_{\\max} = \\omega_{\\max}/c_0$。\n\n**选项评估**\n\n**A. 时间采样必须满足$\\Delta t \\le \\pi/\\omega_{\\max}$。空间采样必须满足$d \\le \\pi/k_x^{\\max}$，其中$k_x^{\\max} = k_{\\max}\\,|\\sin\\theta_{\\max}|$且$k_{\\max} = \\omega_{\\max}/c_0$。对于$\\theta_{\\max} = \\pi/2$的情况，这简化为$d \\le \\pi/k_{\\max}$，即$d \\le \\lambda_{\\min}/2$，其中$\\lambda_{\\min} = 2\\pi/k_{\\max}$。**\n- 时间约束$\\Delta t \\le \\pi/\\omega_{\\max}$与我们的推导完全匹配。\n- 空间约束$d \\le \\pi/k_x^{\\max}$及$k_x^{\\max} = k_{\\max}\\,|\\sin\\theta_{\\max}|$也与我们的推导完全匹配。\n- 对于$\\theta_{\\max} = \\pi/2$的特殊情况，$|\\sin(\\pi/2)| = 1$，所以空间约束变为$d \\le \\pi/k_{\\max}$。最小波长为$\\lambda_{\\min} = 2\\pi c_0 / \\omega_{\\max} = 2\\pi/k_{\\max}$。将其代入约束条件，得到$d \\le \\pi/(2\\pi/\\lambda_{\\min}) = \\lambda_{\\min}/2$。这个简化也是正确的，代表了著名的半波长间距准则。\n**结论：正确。**\n\n**B. 时间采样必须满足$\\Delta t \\le 2\\pi/\\omega_{\\max}$。空间采样必须满足$d \\le \\pi/k_{\\max}$，且与$\\theta_{\\max}$无关。**\n- 时间约束$\\Delta t \\le 2\\pi/\\omega_{\\max}$错了2倍。这对应于以$\\omega_{\\max}/(2\\pi)$的速率采样，这等于最高频率，而不是其两倍。\n- 空间约束$d \\le \\pi/k_{\\max}$仅在$\\theta_{\\max} = \\pi/2$的特定情况下正确。它并非与$\\theta_{\\max}$无关；对于$\\theta_{\\max}  \\pi/2$，约束条件不那么严格。\n**结论：错误。**\n\n**C. 时间采样必须满足$\\Delta t \\le \\pi/\\omega_{\\max}$。空间采样必须满足$d \\le \\lambda_{\\min}$，即$d \\le 2\\pi/k_{\\max}$。**\n- 时间约束是正确的。\n- 空间约束$d \\le 2\\pi/k_{\\max}$等效于$d \\le \\lambda_{\\min}$。这是错误的。最严格的要求（对于$\\theta_{\\max}=\\pi/2$）是$d \\le \\lambda_{\\min}/2$。$d=\\lambda_{\\min}$的间距会导致严重的混叠。\n**结论：错误。**\n\n**D. 时间采样必须满足$\\Delta t \\le 1/\\omega_{\\max}$。空间采样必须满足$d \\le \\pi/\\big(2 k_{\\max}|\\sin\\theta_{\\max}|\\big)$。**\n- 时间约束$\\Delta t \\le 1/\\omega_{\\max}$是错误的。它缺少一个因子$\\pi$。\n- 空间约束$d \\le \\pi/(2 k_{\\max}|\\sin\\theta_{\\max}|)$过于严格了2倍。虽然以这样的密度采样可以避免混叠，但这并非问题所要求的“最小”或“最严格”的约束。\n**结论：错误。**\n\n**E. 时间采样必须满足$\\Delta t \\ge \\pi/\\omega_{\\max}$。空间采样必须满足$d \\ge \\pi/k_{\\max}$。**\n- 两个不等式都反了。这些约束将允许任意大的采样间隔，从而导致混叠。\n**结论：错误。**\n\n只有选项A基于第一性原理，为时间和空间采样提供了正确推导出的严格约束。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "计算模型需要有限的域，这使得人工吸收边界成为必需，以防止虚假反射。本练习将深入探讨如何实现一个时域有限差分（FDTD）模拟，并探索完美匹配层（PMLs）——一种标准的吸收技术——是如何内在地破坏时间反转不变性的。你将量化这种效应，并获得声学领域基石模拟方法的实践经验。",
            "id": "4147319",
            "problem": "您必须实现一个带有完美匹配层 (PML) 的二维时域有限差分模拟，用于研究线性声波方程中的时间反转声学。从无损线性声波方程 $p_{tt} = c^2 \\nabla^2 p$ 开始，其中 $p(\\mathbf{x},t)$ 是声压，$c$ 是声速，$\\nabla^2$ 是拉普拉斯算子。为模拟 PML，使用一个空间变化的阻尼系数 $\\sigma(\\mathbf{x}) \\ge 0$，并考虑阻尼波模型 $p_{tt} + \\sigma(\\mathbf{x}) p_t = c^2 \\nabla^2 p + s(\\mathbf{x},t)$，其中 $s(\\mathbf{x},t)$ 是一个外部源项。在无损介质中，时间反转聚焦是精确的；然而，任何耗散，包括 PML 的吸收，都会破坏时间反转不变性，并降低重聚焦效果。目标是量化 PML 吸收对边界附近重聚焦准确性的影响。\n\n使用以下要求：\n\n- 在间距为 $\\Delta x = \\Delta y$ 的均匀方形网格上，使用空间和时间上的二阶中心有限差分对 $p_{tt} + \\sigma(\\mathbf{x}) p_t = c^2 \\nabla^2 p + s(\\mathbf{x},t)$ 进行离散化。令更新满足无损部分的 Courant–Friedrichs–Lewy 稳定性条件，并一致地引入阻尼项。离散更新必须从连续方程推导得出，不能使用任何临时的简化公式。\n\n- 将完美匹配层 (PML) 实现为一个非负阻尼场 $\\sigma(\\mathbf{x})$，该场在内部区域为零，并在厚度为 $d_{\\text{pml}}$ 个单元的边界层内向区域边界平滑增加。使用一个阶数为 $m$ 的多项式斜坡和一个最大阻尼 $\\sigma_{\\max}$。您的 $\\sigma(\\mathbf{x})$ 应由 $x$ 和 $y$ 方向的分量相加构成，以便角落处有更强的阻尼。\n\n- 除了域内的 PML 外，在外部网格边缘使用零梯度 (Neumann) 边界条件，这样到达最外层边缘的波在被 PML 衰减后，反射被降至最低。\n\n- 正向模拟必须从边界附近的单个源注入一个限带脉冲，并在位于 PML 内边缘的“时间反转镜”传感器环上记录压力。反向模拟必须从该传感器环重新发射时间反转后的记录信号。\n\n- 源波形：使用中心频率为 $f_0$ 的 Ricker 子波，其公式为 $w(t) = \\left(1 - 2 \\pi^2 f_0^2 (t-t_c)^2\\right) \\exp\\left(-\\pi^2 f_0^2 (t-t_c)^2\\right)$，其中 $t_c$ 的选择应使脉冲完全位于模拟时间区间内。源振幅必须为 1 帕斯卡，因此压力单位为帕斯卡 (Pa)。\n\n- 时间反转过程：在所有传感器环位置记录正向压力的时间序列，然后通过在相同位置注入时间反转后的记录信号来运行反向模拟，时间步数相同。\n\n- 聚焦度量：在反向运行完成后，计算原始源位置在最后时刻的焦斑峰值振幅 $A$，单位为帕斯卡 (Pa)。这个 $A$ 是需要报告的标量值。\n\n要使用的数值参数和单位：\n\n- 网格尺寸：$N_x = N_y = 64$ 个单元，间距 $\\Delta x = \\Delta y = 0.01$ 米。\n- 声速：$c = 343$ 米/秒。\n- 时间步长：选择 $\\Delta t = 1.5 \\times 10^{-5}$ 秒。\n- 时间步数：$N_t = 1600$。\n- PML 厚度：$d_{\\text{pml}} = 8$ 个单元。\n- PML 多项式阶数：$m = 3$，最大阻尼 $\\sigma_{\\max} = 800$ /秒。\n- 源频率：$f_0 = 1000$ 赫兹。\n- 传感器环：各边上索引等于 PML 内边缘的所有网格点，即 $i = d_{\\text{pml}}$，$i = N_x - d_{\\text{pml}} - 1$，$j = d_{\\text{pml}}$ 或 $j = N_y - d_{\\text{pml}} - 1$。\n\n强制执行的离散化细节：\n\n- 对空间上的拉普拉斯算子使用二阶中心差分近似，对时间上的 $p_{tt}$ 使用二阶中心差分近似，并对 $p_t$ 使用一个能导出两步显式格式的相容的一阶近似。离散更新必须反映阻尼项对 $p_t$ 的依赖性。\n\n- 通过边缘值复制的方式对拉普拉斯算子应用零梯度边界处理，以避免 PML 之外的人为反射。\n\n测试套件：\n\n对于正向模拟，将源放置在水平索引 $i_s = \\lfloor N_x/2 \\rfloor$ 和垂直索引 $j_s = d_{\\text{pml}} + d$ 处，其中 $d$ 是从 PML 内边缘到内部区域的单元格数。使用以下六个测试用例：\n\n1. $d = 3$ 个单元，反向运行，PML 启用（使用与正向运行相同的 $\\sigma(\\mathbf{x})$）。\n2. $d = 10$ 个单元，反向运行，PML 启用。\n3. $d = 20$ 个单元，反向运行，PML 启用。\n4. $d = 3$ 个单元，反向运行，PML 禁用（在反向运行中设置 $\\sigma(\\mathbf{x}) = 0$）。\n5. $d = 10$ 个单元，反向运行，PML 禁用。\n6. $d = 20$ 个单元，反向运行，PML 禁用。\n\n对于每个测试用例，计算反向运行的最后一个时间步时，源位置处的焦斑峰值振幅 $A$（单位：帕斯卡）。您的程序应产生单行输出，其中包含按上述顺序列出的六个结果，格式为用方括号括起来的逗号分隔列表（例如，“[A1,A2,A3,A4,A5,A6]”）。所有振幅必须以帕斯卡 (Pa) 为单位，表示为浮点数。",
            "solution": "该问题要求实现一个二维（$2$D）时域有限差分（FDTD）模拟，以研究吸收边界层对声学时间反转的影响。该模拟基于线性声波方程，并通过增加一个模拟完美匹配层（PML）的阻尼项进行了修改。\n\n声压 $p(\\mathbf{x}, t)$ 的控制偏微分方程（PDE）如下：\n$$\n\\frac{\\partial^2 p}{\\partial t^2} + \\sigma(\\mathbf{x}) \\frac{\\partial p}{\\partial t} = c^2 \\nabla^2 p + s(\\mathbf{x}, t)\n$$\n此处，$c$ 是恒定的声速，$\\sigma(\\mathbf{x})$ 是一个空间相关的阻尼系数，仅在 PML 区域内非零，$s(\\mathbf{x}, t)$ 是一个外部源项。模拟将在一个均匀的笛卡尔网格上进行，空间步长为 $\\Delta x = \\Delta y$，时间步长为 $\\Delta t$。\n\n为了数值求解该方程，我们使用二阶中心有限差分对其进行离散化。令 $p_{i,j}^n$ 表示在网格点 $(i\\Delta x, j\\Delta y)$ 和时间 $n\\Delta t$ 处的压力。各偏导数近似如下：\n- 二阶时间导数：$\\frac{\\partial^2 p}{\\partial t^2} \\approx \\frac{p_{i,j}^{n+1} - 2p_{i,j}^n + p_{i,j}^{n-1}}{\\Delta t^2}$\n- 一阶时间导数：$\\frac{\\partial p}{\\partial t} \\approx \\frac{p_{i,j}^{n+1} - p_{i,j}^{n-1}}{2\\Delta t}$ (这是一个可导出所需的两步显式格式的二阶近似)。\n- 拉普拉斯算子：$\\nabla^2 p \\approx \\frac{p_{i+1,j}^n - 2p_{i,j}^n + p_{i-1,j}^n}{\\Delta x^2} + \\frac{p_{i,j+1}^n - 2p_{i,j}^n + p_{i,j-1}^n}{\\Delta y^2}$\n\n将这些近似代入 PDE，并分离出未来时间步的项 $p_{i,j}^{n+1}$，即可得到显式更新方程。在网格点 $(i,j)$ 和时间步 $n$ 的离散化 PDE 为：\n$$\n\\frac{p_{i,j}^{n+1} - 2p_{i,j}^n + p_{i,j}^{n-1}}{\\Delta t^2} + \\sigma_{i,j} \\frac{p_{i,j}^{n+1} - p_{i,j}^{n-1}}{2\\Delta t} = c^2 \\nabla^2_h p_{i,j}^n + s_{i,j}^n\n$$\n其中 $\\nabla^2_h$ 表示离散拉普拉斯算子。我们将包含 $p_{i,j}^{n+1}$ 和 $p_{i,j}^{n-1}$ 的项分组：\n$$\np_{i,j}^{n+1} \\left( \\frac{1}{\\Delta t^2} + \\frac{\\sigma_{i,j}}{2\\Delta t} \\right) = \\frac{2p_{i,j}^n}{\\Delta t^2} - p_{i,j}^{n-1} \\left( \\frac{1}{\\Delta t^2} - \\frac{\\sigma_{i,j}}{2\\Delta t} \\right) + c^2 \\nabla^2_h p_{i,j}^n + s_{i,j}^n\n$$\n两边乘以 $\\Delta t^2$ 并重新整理以求解 $p_{i,j}^{n+1}$，得到最终的 FDTD 更新法则：\n$$\np_{i,j}^{n+1} = \\frac{1}{1 + \\frac{\\sigma_{i,j}\\Delta t}{2}} \\left[ 2p_{i,j}^n - p_{i,j}^{n-1}\\left(1 - \\frac{\\sigma_{i,j}\\Delta t}{2}\\right) + c^2 \\Delta t^2 \\nabla^2_h p_{i,j}^n + \\Delta t^2 s_{i,j}^n \\right]\n$$\n这是一个三层（或两步）时间步进格式，因为它需要时间 $n$ 和 $n-1$ 的压力场来计算时间 $n+1$ 的场。模拟从静止开始，因此初始条件为 $p_{i,j}^0 = 0$ 和 $p_{i,j}^{-1} = 0$（这等价于 $\\partial p/\\partial t|_{t=0} = 0$）。\n\n这种显式格式的稳定性由 Courant–Friedrichs–Lewy (CFL) 条件决定。对于二维无损波动方程，该条件为 $c \\Delta t \\sqrt{1/\\Delta x^2 + 1/\\Delta y^2} \\le 1$。给定 $\\Delta x = \\Delta y$，该条件简化为 $\\frac{c \\Delta t \\sqrt{2}}{\\Delta x} \\le 1$。使用所提供的参数：$c=343\\,\\text{m/s}$，$\\Delta t=1.5 \\times 10^{-5}\\,\\text{s}$，以及 $\\Delta x=0.01\\,\\text{m}$，CFL 数约为 $\\frac{343 \\times 1.5 \\times 10^{-5} \\times \\sqrt{2}}{0.01} \\approx 0.728$，该值小于 1，满足稳定性判据。\n\nPML 是通过阻尼场 $\\sigma(\\mathbf{x})$ 实现的。该场在计算域内部为零，并在厚度为 $d_{\\text{pml}} = 8$ 个单元的边界层内增加。其剖面遵循一个阶数为 $m=3$ 的多项式斜坡。对于给定的坐标方向（例如 $x$），从内部区域进入 PML 距离为 $k$ 个单元处的阻尼 $\\sigma_x$ 由 $\\sigma_x(k) = \\sigma_{\\max} (k/d_{\\text{pml}})^m$ 给出，其中 $k$ 的范围是从 1 到 $d_{\\text{pml}}$。在点 $(i,j)$ 的总阻尼是两个方向贡献的总和：$\\sigma_{i,j} = \\sigma_x(i) + \\sigma_y(j)$。这种相加构造使得区域角落的阻尼更强。通过将第一内层的压力值复制到一层虚拟单元中，在最外层网格边缘应用零梯度 Neumann 边界条件，这可以通过填充（padding）高效处理。\n\n时间反转过程涉及两次模拟：\n$1$. 正向模拟：一个源在指定位置 $(i_s, j_s)$ 注入一个 Ricker 子波 $w(t) = (1 - 2 \\pi^2 f_0^2 (t-t_c)^2) \\exp(-\\pi^2 f_0^2 (t-t_c)^2)$。计算 $N_t=1600$ 个时间步的压力演化。在此过程中，在由 PML 内边缘定义的传感器环位置上记录压力时间序列。\n$2$. 反向模拟：再次运行模拟 $N_t$ 个时间步。介质被重置为静止状态。先前记录的信号被时间反转，并在其各自的传感器位置作为源注入。对于在正向模拟中从 $t=0$ 到 $T=(N_t-1)\\Delta t$ 记录的信号 $p_{\\text{rec}}(t)$，反向模拟中注入的源是 $s(t) = p_{\\text{rec}}(T-t)$。在理想的无损介质中，这个过程应使波沿其原始路径反向传播，并在最后时刻在原始源位置重新聚焦。模拟在两种条件下进行：一次是 PML 阻尼激活（$\\sigma  0$），另一次是禁用（$\\sigma = 0$）。\n\n每个测试用例要报告的最终指标是在反向模拟的最后一个时间步时，原始源位置 $(i_s, j_s)$ 处的压力振幅 $A$。该值量化了时间反转聚焦的质量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the time-reversal acoustic simulations for all test cases.\n    \"\"\"\n    \n    # --- Numerical parameters and constants ---\n    NX = 64          # Grid size in x\n    NY = 64          # Grid size in y\n    DX = 0.01        # Grid spacing in x (m)\n    DY = 0.01        # Grid spacing in y (m)\n    C0 = 343.0       # Speed of sound (m/s)\n    DT = 1.5e-5      # Time step (s)\n    NT = 1600        # Number of time steps\n    D_PML = 8        # PML thickness (cells)\n    PML_M = 3        # PML polynomial order\n    SIGMA_MAX = 800.0# Maximum damping in PML (s^-1)\n    F0 = 1000.0      # Source center frequency (Hz)\n    SRC_AMP = 1.0    # Source amplitude (Pa)\n\n    def create_pml_sigma():\n        \"\"\"Constructs the spatially varying PML damping field sigma.\"\"\"\n        sigma = np.zeros((NX, NY))\n        sigma_x = np.zeros((NX, NY))\n        sigma_y = np.zeros((NX, NY))\n\n        # Ramp profile for each side\n        # Left PML region\n        for i in range(D_PML):\n            dist = D_PML - i\n            sigma_x[i, :] = SIGMA_MAX * (dist / D_PML)**PML_M\n        # Right PML region\n        for i in range(NX - D_PML, NX):\n            dist = i - (NX - D_PML - 1)\n            sigma_x[i, :] = SIGMA_MAX * (dist / D_PML)**PML_M\n        # Top PML region\n        for j in range(D_PML):\n            dist = D_PML - j\n            sigma_y[:, j] = SIGMA_MAX * (dist / D_PML)**PML_M\n        # Bottom PML region\n        for j in range(NY - D_PML, NY):\n            dist = j - (NY - D_PML - 1)\n            sigma_y[:, j] = SIGMA_MAX * (dist / D_PML)**PML_M\n        \n        # Combine contributions additively\n        sigma = sigma_x + sigma_y\n        return sigma\n\n    def ricker_wavelet(t, t_c, f0):\n        \"\"\"Generates a Ricker wavelet.\"\"\"\n        arg = (np.pi * f0 * (t - t_c))**2\n        return (1.0 - 2.0 * arg) * np.exp(-arg)\n\n    def get_sensor_indices():\n        \"\"\"Returns a list of (i, j) tuples for the sensor ring locations.\"\"\"\n        indices = []\n        i_min, i_max = D_PML, NX - D_PML - 1\n        j_min, j_max = D_PML, NY - D_PML - 1\n\n        # Top and bottom rows of the inner domain\n        for i in range(i_min, i_max + 1):\n            indices.append((i, j_min))\n            indices.append((i, j_max))\n\n        # Left and right columns (excluding corners already added)\n        for j in range(j_min + 1, j_max):\n            indices.append((i_min, j))\n            indices.append((i_max, j))\n        return indices\n\n    def run_fdtd_simulation(sigma, nt, src_is=None, src_js=None, \n                              source_time_series=None, \n                              recordings_to_inject=None, \n                              sensor_indices=None):\n        \"\"\"Core FDTD simulation loop for one run (forward or backward).\"\"\"\n        p_curr = np.zeros((NX, NY), dtype=np.float64)\n        p_prev = np.zeros((NX, NY), dtype=np.float64)\n        \n        # Precompute coefficients for the update equation\n        coeff1 = 1.0 / (1.0 + sigma * DT / 2.0)\n        coeff2 = 1.0 - sigma * DT / 2.0\n        c_courant_sq = (C0 * DT / DX)**2\n\n        recorded_signals = None\n        if sensor_indices is not None and recordings_to_inject is None:\n            recorded_signals = np.zeros((len(sensor_indices), nt), dtype=np.float64)\n        \n        for n in range(nt):\n            # Apply Neumann BC via padding with edge values\n            p_padded = np.pad(p_curr, 1, mode='edge')\n            \n            # Compute discrete Laplacian (without 1/dx^2 factor)\n            lap_p = (p_padded[2:, 1:-1] + p_padded[:-2, 1:-1] + \n                     p_padded[1:-1, 2:] + p_padded[1:-1, :-2] - \n                     4.0 * p_curr)\n            \n            # Create source grid for this timestep\n            source_grid = np.zeros((NX, NY), dtype=np.float64)\n            if source_time_series is not None and src_is is not None:\n                source_grid[src_is, src_js] = source_time_series[n]\n                \n            if recordings_to_inject is not None and sensor_indices is not None:\n                # Inject time-reversed signals\n                time_reversed_step = nt - 1 - n\n                for k, (i, j) in enumerate(sensor_indices):\n                    source_grid[i, j] += recordings_to_inject[k, time_reversed_step]\n\n            # FDTD update equation\n            term_lap = c_courant_sq * lap_p\n            term_source = DT**2 * source_grid\n            \n            p_next = coeff1 * (2.0 * p_curr - coeff2 * p_prev + term_lap + term_source)\n            \n            p_prev, p_curr = p_curr, p_next\n            \n            # Record signals if in forward run\n            if recorded_signals is not None:\n                for k, (i, j) in enumerate(sensor_indices):\n                    recorded_signals[k, n] = p_curr[i, j]\n                    \n        return p_curr, recorded_signals\n\n    def solve_case(d, backward_pml_active):\n        \"\"\"Runs one full test case (forward and backward simulation).\"\"\"\n        # --- 1. Setup ---\n        isrc = NX // 2\n        jsrc = D_PML + d\n        \n        pml_sigma = create_pml_sigma()\n        sensor_indices = get_sensor_indices()\n        \n        # Generate source Ricker wavelet\n        t_c = 4.0 / F0  # Pulse center time\n        time_pts = np.arange(NT) * DT\n        source_waveform = SRC_AMP * ricker_wavelet(time_pts, t_c, F0)\n        \n        # --- 2. Forward run with PML ---\n        _, recorded_signals = run_fdtd_simulation(pml_sigma, NT, \n                                                  src_is=isrc, src_js=jsrc, \n                                                  source_time_series=source_waveform,\n                                                  sensor_indices=sensor_indices)\n        \n        # --- 3. Backward run ---\n        backward_sigma = pml_sigma if backward_pml_active else np.zeros((NX, NY))\n        \n        final_pressure_field, _ = run_fdtd_simulation(backward_sigma, NT,\n                                                      recordings_to_inject=recorded_signals,\n                                                      sensor_indices=sensor_indices)\n                                                      \n        # --- 4. Get result metric ---\n        focal_amplitude = final_pressure_field[isrc, jsrc]\n        return focal_amplitude\n\n    # --- Main test suite execution ---\n    test_cases = [\n        # d, backward_pml_active\n        (3, True),   # Case 1\n        (10, True),  # Case 2\n        (20, True),  # Case 3\n        (3, False),  # Case 4\n        (10, False), # Case 5\n        (20, False)  # Case 6\n    ]\n    \n    results = []\n    for d, pml_active in test_cases:\n        result = solve_case(d, pml_active)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多真实世界的环境，如海洋，更适合被描述为性质随距离变化的波导。本练习介绍了一种强大的抛物方程（PE）方法，通过分裂步傅里叶算法求解，以模拟这种情况。你将发现，对于非平稳介质，真正的时间反转需要使用伴随算子——一个比简单的时间反演对称性更普遍的概念，并证明为什么朴素的后向传播会失败。",
            "id": "4147353",
            "problem": "您需要形式化并模拟在二维距离-深度声波导中的窄角传播和时间反转聚焦，该波导具有随距离变化的声速，并使用抛物方程近似。从无损介质中的标量线性声波方程出发，推导出一个用于描述单色场随距离推进的自洽抛物方程。然后，在存在距离依赖性的情况下，将时间反转反向传播算子指定为前向算子的伴随算子。通过分步傅里叶解实现一个数值演示，展示在时间反转中考虑非平稳（随距离变化）传播对于实现正确聚焦的必要性。\n\n基本出发点是无损介质中压力 $p(\\mathbf{x},t)$ 的标量声波方程，声速为 $c(\\mathbf{x})$，\n$$\n\\nabla^2 p(\\mathbf{x},t) - \\frac{1}{c^2(\\mathbf{x})}\\frac{\\partial^2 p(\\mathbf{x},t)}{\\partial t^2} = 0,\n$$\n及其通过 $p(\\mathbf{x},t) = \\Re\\{\\hat{p}(\\mathbf{x}) e^{-i \\omega t}\\}$ 简化为单色场的亥姆霍兹方程，\n$$\n\\nabla^2 \\hat{p}(\\mathbf{x}) + k^2(\\mathbf{x}) \\hat{p}(\\mathbf{x}) = 0,\n$$\n其中 $k(\\mathbf{x}) = \\omega / c(\\mathbf{x})$。考虑在距离-深度坐标 $(r,z)$ 中的二维传播，围绕一个恒定的参考声速 $c_0$ 引入参考波数 $k_0 = \\omega/c_0$，并为由 $\\hat{p}(r,z) = \\psi(r,z) e^{i k_0 r}$ 定义的复包络 $\\psi(r,z)$ 推导一个窄角抛物方程。在前向传播、小角度和弱非均匀性条件下，证明 $\\psi(r,z)$ 的演化可以用以下形式的一阶距离步进方程来近似：\n$$\n\\frac{\\partial \\psi}{\\partial r} = \\frac{i}{2 k_0} \\frac{\\partial^2 \\psi}{\\partial z^2} + \\frac{i k_0}{2} V(r,z) \\psi,\n$$\n其中 $V(r,z)$ 是一个由 $c(r,z)$ 和 $c_0$ 构建的无量纲折射势。\n\n接下来，从互易性和线性算子伴随的第一性原理出发，论证对于距离依赖介质，正确的时间反转反向传播算子必须是前向算子的伴随算子，且其依赖于 $r$ 的系数需以相反顺序遍历。解释为什么用平稳（距离无关）近似替换距离依赖性（例如，对于所有 $r$，将 $V(r,z)$ 固定为 $V(R,z)$，其中 $R$ 是终端距离）通常会降低时间反转的聚焦效果。\n\n您的程序必须通过在 $r$ 方向上使用分步傅里叶步进法，在二维域中数值模拟前向传播和两种类型的时间反转反向传播：\n- 前向算子使用从随距离变化的声速 $c(r,z)$ 推导出的折射势 $V(r,z)$，将 $\\psi(r,z)$ 从 $r=0$ 推进到 $r=R$。\n- 正确的时间反转反向传播使用负的距离步长，将 $\\psi_{\\text{TR}}(r,z)$ 从 $r=R$ 推进到 $r=0$，并使用相同的、在 $r$ 方向上反向遍历的距离依赖势 $V(r,z)$。\n- 平稳近似反向传播使用对所有 $r$ 都固定的 $V(R,z)$，将 $\\psi_{\\text{TR,stat}}(r,z)$ 从 $r=R$ 推进到 $r=0$。\n\n声速剖面定义为\n$$\nc(r,z) = c_0 \\left[1 + a_z \\left(\\frac{z}{H} - \\frac{1}{2}\\right) + b_r \\left(\\frac{r}{R}\\right)\\right],\n$$\n其中 $c_0$、$a_z$ 为常数，$b_r$ 为测试参数。使用深度范围 $H$ 和终端距离 $R$。使用角频率为 $\\omega = 2\\pi f$ 的单色载波，其中 $f$ 为频率。折射势定义为\n$$\nV(r,z) = \\left(\\frac{c_0}{c(r,z)}\\right)^2 - 1,\n$$\n它是无量纲的。在 $r=0$ 处的初始包络是一个单位振幅的高斯函数，中心位于源深度 $z_s$，标准差为 $\\sigma$，即\n$$\n\\psi(0,z) = \\exp\\left(-\\frac{(z-z_s)^2}{2 \\sigma^2}\\right).\n$$\n\n在具有周期性边界条件的均匀深度网格上，实现 $z$ 方向的分步傅里叶方案。在每个距离步长 $\\Delta r$ 中，施加一个半步折射相位，通过 $z$ 方向的傅里叶变换施加一个全步衍射相位，然后再施加另一个半步折射相位。对于衍射算子，使用谱乘子\n$$\n\\exp\\left(-i \\frac{\\Delta r}{2 k_0} k_z^2\\right),\n$$\n其中 $k_z$ 是根据深度间距构建的离散网格上的垂直波数。折射半步将场乘以 $\\exp\\left(i \\frac{k_0 \\Delta r}{2} V(r,z)\\right)$。\n\n在执行时间反转时，用前向场 $\\psi(R,z)$ 的复共轭在 $r=R$ 处初始化反向传播，并以负的 $\\Delta r$ 步进：\n- 对于正确的时间反转，使用沿反向距离评估的、依赖于 $r$ 的 $V(r,z)$。\n- 对于平稳近似，对所有 $r$ 使用 $V(R,z)$。\n\n对于正确和稳态两种反向传播，通过在 $r=0$ 处、原始源深度 $z=z_s$ 的恢复包络幅度来衡量聚焦质量。报告改进因子\n$$\n\\Gamma = \\frac{\\left|\\psi_{\\text{TR}}(0,z_s)\\right|}{\\left|\\psi_{\\text{TR,stat}}(0,z_s)\\right|},\n$$\n该因子是无量纲的。\n\n使用以下物理上合理的常数和单位：\n- 参考声速 $c_0 = 1500$ m/s。\n- 频率 $f = 250$ Hz（因此角频率单位为弧度/秒）。所有角度单位为弧度。\n- 深度范围 $H = 2000$ m。\n- 深度网格点数 $N_z = 1024$。\n- 终端距离 $R = 20000$ m。\n- 距离步长 $\\Delta r = 50$ m。\n- 源深度位置 $z_s = H/2$ (米)。\n- 初始高斯标准差 $\\sigma = 30$ m。\n- 深度梯度分数 $a_z = -0.003$ (无量纲)。\n- 距离梯度分数 $b_r$ 根据测试用例变化 (无量纲)。\n\n测试套件：\n- 情况 1 (距离上均匀): $b_r = 0.0$。\n- 情况 2 (弱距离依赖): $b_r = 1.0 \\times 10^{-4}$。\n- 情况 3 (较强距离依赖): $b_r = 2.0 \\times 10^{-4}$。\n\n对于每个测试用例，计算并返回改进因子 $\\Gamma$（浮点数）。您的程序应生成单行输出，其中包含三个结果，以逗号分隔并用方括号括起来，例如，“[result1,result2,result3]”。报告的三个值是无量纲浮点数，应以 Python 生成的完整双精度打印，无需额外四舍五入或单位注释。",
            "solution": "该问题经评估有效。它在科学上基于波传播和计算声学的原理，具有一套完整的物理和数值参数，问题设定良好，并且表述客观。它提出了一个非平凡的数值实验，以演示时间反转物理学中的一个关键概念。\n\n第一步是从二维亥姆霍兹方程推导窄角抛物方程（PE）。出发点是描述在具有随距离和深度变化的波数 $k(r,z) = \\omega/c(r,z)$ 的介质中单色压力场 $\\hat{p}(r,z)$ 的亥姆霍兹方程：\n$$\n\\frac{\\partial^2 \\hat{p}}{\\partial r^2} + \\frac{\\partial^2 \\hat{p}}{\\partial z^2} + k^2(r,z) \\hat{p} = 0\n$$\n我们假设场主要沿正 $r$ 方向传播。这提示我们可以分解出一个快速变化的载波相位，该相位对应于参考波数 $k_0 = \\omega/c_0$，其中 $c_0$ 是一个恒定的参考声速。我们定义一个缓变复包络 $\\psi(r,z)$，使得：\n$$\n\\hat{p}(r,z) = \\psi(r,z) e^{i k_0 r}\n$$\n$\\hat{p}$ 相对于 $r$ 的导数是：\n$$\n\\frac{\\partial \\hat{p}}{\\partial r} = \\left(\\frac{\\partial \\psi}{\\partial r} + i k_0 \\psi\\right) e^{i k_0 r}\n$$\n$$\n\\frac{\\partial^2 \\hat{p}}{\\partial r^2} = \\left(\\frac{\\partial^2 \\psi}{\\partial r^2} + 2 i k_0 \\frac{\\partial \\psi}{\\partial r} - k_0^2 \\psi\\right) e^{i k_0 r}\n$$\n将此式与 $\\frac{\\partial^2 \\hat{p}}{\\partial z^2} = \\frac{\\partial^2 \\psi}{\\partial z^2} e^{i k_0 r}$ 代入亥姆霍兹方程，并消去公因子 $e^{i k_0 r}$，得到：\n$$\n\\frac{\\partial^2 \\psi}{\\partial r^2} + 2 i k_0 \\frac{\\partial \\psi}{\\partial r} - k_0^2 \\psi + \\frac{\\partial^2 \\psi}{\\partial z^2} + k^2(r,z) \\psi = 0\n$$\n抛物近似的核心是*缓变包络近似*（SVEA）。该近似假设包络 $\\psi$ 在距离 $r$ 上的变化远慢于载波相位，数学上表示为 $\\left|\\frac{\\partial^2 \\psi}{\\partial r^2}\\right| \\ll \\left|2 k_0 \\frac{\\partial \\psi}{\\partial r}\\right|$。这对于大部分能量集中在 $r$ 轴附近的窄角传播是有效的。舍去 $\\frac{\\partial^2 \\psi}{\\partial r^2}$ 项，我们得到：\n$$\n2 i k_0 \\frac{\\partial \\psi}{\\partial r} + \\frac{\\partial^2 \\psi}{\\partial z^2} + (k^2(r,z) - k_0^2) \\psi \\approx 0\n$$\n求解距离导数 $\\frac{\\partial \\psi}{\\partial r}$：\n$$\n\\frac{\\partial \\psi}{\\partial r} \\approx \\frac{i}{2 k_0} \\frac{\\partial^2 \\psi}{\\partial z^2} + \\frac{i}{2 k_0} (k^2(r,z) - k_0^2) \\psi\n$$\n项 $(k^2(r,z) - k_0^2)$ 代表了与参考介质的偏差。我们可以用声速 $c(r,z)$ 和参考声速 $c_0$ 来表示它：\n$$\nk^2(r,z) - k_0^2 = \\frac{\\omega^2}{c^2(r,z)} - \\frac{\\omega^2}{c_0^2} = k_0^2 \\left[ \\left(\\frac{c_0}{c(r,z)}\\right)^2 - 1 \\right]\n$$\n通过定义无量纲折射势 $V(r,z) = \\left(\\frac{c_0}{c(r,z)}\\right)^2 - 1$，方程变为：\n$$\n\\frac{\\partial \\psi}{\\partial r} = \\frac{i}{2 k_0} \\frac{\\partial^2 \\psi}{\\partial z^2} + \\frac{i k_0}{2} V(r,z) \\psi\n$$\n这就是所求的抛物方程，它是一个关于距离 $r$ 的一阶微分方程，可以从 $r=0$ 处的初始条件向前步进求解。\n\n我们可以将这个演化过程抽象地写为 $\\frac{\\partial \\psi}{\\partial r} = i(\\mathcal{D} + \\mathcal{V}(r))\\psi$，其中 $\\mathcal{D} = \\frac{1}{2k_0}\\frac{\\partial^2}{\\partial z^2}$ 是自伴随的衍射算子，$\\mathcal{V}(r) = \\frac{k_0}{2}V(r,z)$ 是用于折射的、随距离变化的自伴随乘法算子。将场从 $r=0$ 映射到 $r=R$ 的前向传播算子 $\\mathcal{G}(R,0)$ 是演化算子的路径排序指数。时间反转旨在从在 $r=R$ 处测量的场重构原始源场。这包括对场 $\\psi(R,z)$ 取共轭并进行反向传播。如果反向传播算子是前向传播算子的伴随算子，即 $\\mathcal{G}_{\\text{TR}}(0,R) = \\mathcal{G}^\\dagger(R,0)$，则可以实现完美聚焦。算子 $\\mathcal{A}$ 的伴随算子由内积关系 $\\langle \\mathcal{A} u, v \\rangle = \\langle u, \\mathcal{A}^\\dagger v \\rangle$ 定义。对于演化算子 $i(\\mathcal{D} + \\mathcal{V}(r))$，它是反埃尔米特算子，其伴随算子是 $-i(\\mathcal{D} + \\mathcal{V}(r))$。完整前向传播算子 $\\mathcal{G}(R,0)$ 的伴随算子涉及以相反的距离 $r$ 顺序应用这些伴随演化算子。因此，正确的时间反转反向传播必须使用相同的随距离变化的势 $V(r,z)$，但是在从 $R$ 回到 $0$ 的距离范围内进行评估。\n\n如果在反向传播期间将介质近似为平稳的（例如，对所有 $r$ 使用 $V(R,z)$），则反向传播算子将不再是真实前向传播算子的伴随算子。这种算子失配，$\\mathcal{G}_{\\text{TR,stat}} \\neq \\mathcal{G}^\\dagger$，会导致在源位置处波前的重构不完美，从而降低聚焦效果。这种退化的严重程度随着距离依赖性的大小而增加，此处由参数 $b_r$ 量化。\n\n数值解是使用分步傅里叶（SSF）方法实现的。对于从 $r_j$到 $r_{j+1}$ 的单个距离步长 $\\Delta r$，场使用对称的斯特朗分裂法推进：\n$$\n\\psi(r_{j+1}, z) \\approx e^{i\\frac{k_0 \\Delta r}{4} V(r_{j+1}, z)} \\mathcal{F}^{-1} \\left\\{ e^{-i \\frac{\\Delta r}{2 k_0} k_z^2} \\mathcal{F} \\left\\{ e^{i\\frac{k_0 \\Delta r}{4} V(r_j,z)} \\psi(r_j, z) \\right\\} \\right\\}\n$$\n这等效于规定的半步折射、全步衍射和另一个半步折射的序列。在实践中，我们将其实现为：\n1. 在 $r_j$ 处的半步折射： $\\psi \\leftarrow \\psi \\cdot \\exp\\left(i \\frac{k_0 \\Delta r}{2} V(r_j,z)\\right)$\n2. 全步衍射： $\\psi \\leftarrow \\mathcal{F}^{-1}\\left\\{ \\exp\\left(-i \\frac{\\Delta r}{2 k_0} k_z^2\\right) \\mathcal{F}\\{\\psi\\} \\right\\}$\n3. 在 $r_{j+1}$ 处的半步折射： $\\psi \\leftarrow \\psi \\cdot \\exp\\left(i \\frac{k_0 \\Delta r}{2} V(r_{j+1},z)\\right)$\n\n对于反向传播，我们用 $\\psi^*(R,z)$ 进行初始化，并使用负的距离步长 $-\\Delta r$ 进行步进。这会改变每个算子指数中的符号，从而正确地实现伴随运算。\n1. 正确的时间反转（TR）：在从 $r_j$ 到 $r_{j-1}$ 的反向循环中使用 $V(r_j, z)$ 和 $V(r_{j-1}, z)$。\n2. 平稳时间反转（TR）：在所有折射步骤中使用 $V(R,z)$。\n\n改进因子 $\\Gamma$ 直接比较了正确时间反转与平稳近似的峰值焦斑振幅，从而量化了考虑距离依赖性的必要性。当 $b_r=0$ 时，介质与距离无关，因此两种时间反转方法相同，得出 $\\Gamma=1$。当 $b_r0$ 时，我们预期 $\\Gamma1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Simulates acoustic propagation and time reversal in a range-dependent waveguide\n    using the parabolic equation and split-step Fourier method.\n    \"\"\"\n    \n    # Define physical and numerical constants\n    c0 = 1500.0        # Reference sound speed (m/s)\n    f = 250.0          # Frequency (Hz)\n    H = 2000.0         # Depth extent (m)\n    Nz = 1024          # Number of depth grid points\n    R = 20000.0        # Terminal range (m)\n    dr = 50.0          # Range step (m)\n    zs = H / 2.0       # Source depth (m)\n    sigma = 30.0       # Initial Gaussian standard deviation (m)\n    az = -0.003        # Depth-gradient fraction (dimensionless)\n\n    # Test cases for the range-gradient fraction\n    test_cases = [\n        0.0,             # Case 1: Homogeneous in range\n        1.0e-4,          # Case 2: Weak range dependence\n        2.0e-4           # Case 3: Stronger range dependence\n    ]\n\n    results = []\n\n    # Derived parameters\n    omega = 2.0 * np.pi * f\n    k0 = omega / c0\n    dz = H / Nz\n    z_grid = np.arange(Nz) * dz\n    zs_idx = int(np.round(zs / dz)) % Nz\n    Nr = int(R / dr)\n    r_grid = np.arange(Nr + 1) * dr\n    kz_grid = 2.0 * np.pi * fftfreq(Nz, d=dz)\n\n    # Pre-calculate diffraction operators for forward and backward propagation\n    diff_op_fwd = np.exp(-1j * dr / (2.0 * k0) * kz_grid**2)\n    diff_op_bwd = np.exp(1j * dr / (2.0 * k0) * kz_grid**2)\n\n    for br in test_cases:\n        # --- Define sound speed and refraction potential ---\n        def c(r, z, br_val):\n            return c0 * (1.0 + az * (z / H - 0.5) + br_val * (r / R))\n\n        def V(r, z, br_val):\n            return (c0 / c(r, z, br_val))**2 - 1.0\n\n        # --- Forward Propagation ---\n        # Initial field at r=0\n        psi = np.exp(-(z_grid - zs)**2 / (2.0 * sigma**2)).astype(np.complex128)\n        \n        # Store potentials at each range step to avoid re-calculation\n        V_matrix = np.array([V(r_val, z_grid, br) for r_val in r_grid])\n\n        # SSF loop for forward propagation\n        for j in range(Nr):\n            # First half refraction step\n            psi *= np.exp(0.5j * k0 * dr * V_matrix[j])\n            # Full diffraction step in spectral domain\n            psi_k = fft(psi)\n            psi_k *= diff_op_fwd\n            psi = ifft(psi_k)\n            # Second half refraction step\n            psi *= np.exp(0.5j * k0 * dr * V_matrix[j+1])\n        \n        psi_R = psi  # Field at terminal range R\n\n        # --- Time Reversal: Correct (Adjoint) Back-propagation ---\n        psi_tr = np.conj(psi_R)\n        \n        # SSF loop for back-propagation\n        for j in range(Nr, 0, -1):\n            # First half refraction step\n            psi_tr *= np.exp(-0.5j * k0 * dr * V_matrix[j])\n            # Full diffraction step (adjoint)\n            psi_tr_k = fft(psi_tr)\n            psi_tr_k *= diff_op_bwd\n            psi_tr = ifft(psi_tr_k)\n            # Second half refraction step\n            psi_tr *= np.exp(-0.5j * k0 * dr * V_matrix[j-1])\n        \n        psi_tr_0 = psi_tr # Recovered field at r=0\n\n        # --- Time Reversal: Stationary Approximation Back-propagation ---\n        psi_tr_stat = np.conj(psi_R)\n        V_stat = V_matrix[-1] # Potential at r=R\n        ref_op_stat_half = np.exp(-0.5j * k0 * dr * V_stat)\n        \n        # SSF loop for back-propagation with stationary potential\n        for _ in range(Nr):\n            # First half refraction step (using V(R,z))\n            psi_tr_stat *= ref_op_stat_half\n            # Full diffraction step\n            psi_tr_stat_k = fft(psi_tr_stat)\n            psi_tr_stat_k *= diff_op_bwd\n            psi_tr_stat = ifft(psi_tr_stat_k)\n            # Second half refraction step (using V(R,z))\n            psi_tr_stat *= ref_op_stat_half\n\n        psi_tr_stat_0 = psi_tr_stat # Recovered field at r=0\n\n        # --- Calculate Improvement Factor Gamma ---\n        mag_tr = np.abs(psi_tr_0[zs_idx])\n        mag_tr_stat = np.abs(psi_tr_stat_0[zs_idx])\n\n        # Handle potential division by zero, though unlikely in this problem\n        if mag_tr_stat == 0:\n            # If stationary fails completely, improvement is conceptually infinite\n            # Capping at a large number or setting to 1.0 if both are zero.\n            gamma = 1.0 if mag_tr == 0 else np.finfo(np.float64).max\n        else:\n            gamma = mag_tr / mag_tr_stat\n        \n        results.append(gamma)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}