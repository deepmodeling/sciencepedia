{
    "hands_on_practices": [
        {
            "introduction": "在拓扑声学中，一个核心任务是计算拓扑不变量，例如陈数（Chern number），它能够对能带的拓扑性质进行分类。Fukui-Hatsugai-Suzuki（FHS）方法提供了一种在离散布里渊区上直接计算陈数的强大而数值稳定的途径。这项实践将引导你应用FHS方法，通过计算一个二维声学超材料模型中的陈数，深入理解贝里曲率（Berry curvature）的离散化及其与拓扑相变的关系 。",
            "id": "4147729",
            "problem": "考虑一个二维周期性声学超材料，在低频下通过一个耦合模式有效布洛赫算符进行建模，该算符在每个晶胞中具有两个杂化压力模式。根据空间周期性和布洛赫定理，小振幅压力场可以由布洛赫波解表示，这些解由第一布里渊区上的布洛赫波矢 $k = (k_x,k_y)$ 标记。第一布里渊区被取为方形区域 $k_x,k_y \\in [-\\pi,\\pi]$，角度单位为弧度。模式耦合被选择为对称性允许且非互易的，从而产生一个有效的 $2 \\times 2$ 厄米布洛赫算符\n$$\nH(k) = \\sin(k_x)\\,\\sigma_x + \\sin(k_y)\\,\\sigma_y + \\left(m + \\cos(k_x) + \\cos(k_y)\\right)\\,\\sigma_z,\n$$\n其中 $m$ 是一个无量纲偏置参数，可通过旋转谐振器或施加稳恒声流来调节，而 $\\sigma_x,\\sigma_y,\\sigma_z$ 是泡利矩阵。对于每个 $k$，本征值问题 $H(k)\\,u_b(k) = \\omega_b(k)\\,u_b(k)$ 定义了由能带标记的归一化本征模式 $u_b(k)$。\n\n孤立能带 $b$ 的第一陈数是一个整数，由贝里曲率在布里渊区上的积分给出。该陈数源于在k空间中，本征模式 $u_b(k)$ 绕无穷小回路进行平行输运时累积的几何相位。从贝里联络和贝里曲率的定义出发，并利用数值计算在有限网格上操作这一事实，基于布里渊区均匀网格上的规范不变链路变量，为下能带 $b=0$（具有较小本征值的能带）构建陈数的离散近似。\n\n通过将布里渊区离散化为一个由k点构成的均匀 $N \\times N$ 网格来实现该方法，其中 $k_x$ 和 $k_y$ 在 $[-\\pi,\\pi]$ 内均匀采样。在网格上使用周期性边界条件，以便边界处的相邻点可以回绕。\n\n通过计算本征矢量绕每个基本格框输运一周所累积的相位，来计算每个基本格框上的离散贝里通量，然后对所有格框求和以估计下能带的陈数。为保证数值稳定性，确保每个 $k$ 点的本征矢量都已归一化，并使用规范不变的方法比较相邻的本征矢量。角度必须以弧度处理。\n\n除了计算陈数，还需估计两个数值误差度量：\n\n- 有限网格离散化误差估计：计算在基础网格尺寸 $N$ 和加密网格尺寸 $2N$ 上获得的陈数之间的绝对差，两者均使用相同的 $m$ 和上述相同的方法。将此差异报告为一个非负实数。\n\n- 模式正交性稳定度量：对于基础网格尺寸 $N$，计算下能带在整个网格上相邻重叠的幅度与单位1的平均偏差。具体来说，在网格上的每个 $k$ 点，计算重叠幅度 $s_x(k) = \\left|\\langle u_0(k)|u_0(k+\\Delta_x)\\rangle\\right|$ 和 $s_y(k) = \\left|\\langle u_0(k)|u_0(k+\\Delta_y)\\rangle\\right|$，其中 $\\Delta_x$ 和 $\\Delta_y$ 表示在 $k_x$ 和 $k_y$ 方向上带有周期性回绕的单个网格步长位移。然后将正交性稳定度量定义为所有 $k$ 点上 $\\left(1 - s_x(k)\\right)$ 和 $\\left(1 - s_y(k)\\right)$ 的算术平均值；将此平均值报告为一个在 $[0,1]$ 区间内的实数。较大的值表示由于粗糙采样或近简并而导致的更强的局部规范涨落。\n\n你的程序必须为以下测试套件中的每个测试用例输出一个包含三个条目的列表 $[C, E_{\\mathrm{mesh}}, E_{\\mathrm{ortho}}]$，其中 $C$ 是在基础网格 $N$ 上计算的下能带陈数（报告为一个未经四舍五入的实数），$E_{\\mathrm{mesh}}$ 是如上定义的有限网格离散化误差估计，而 $E_{\\mathrm{ortho}}$ 是如上定义的模式正交性稳定度量。该测试套件包含以下参数集 $(m,N)$：\n\n- 测试用例 1：$(m,N) = (-1.0,\\,21)$。\n- 测试用例 2：$(m,N) = (0.0,\\,21)$，一个能隙闭合的边界情况。\n- 测试用例 3：$(m,N) = (1.0,\\,21)$。\n- 测试用例 4：$(m,N) = (3.0,\\,21)$。\n- 测试用例 5：$(m,N) = (-1.0,\\,9)$，一个用于强调正交性稳定性的粗糙网格。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的列表组成的列表，例如 $[[r_{11},r_{12},r_{13}],[r_{21},r_{22},r_{23}],\\ldots]$，其中每个 $r_{ij}$ 都是一个实数。角度必须以弧度为单位，并且由于所有量都是无量纲的，因此不需要物理单位。代码必须是自包含的，并且无需任何输入即可运行。",
            "solution": "该问题要求计算一个二维拓扑声学超材料下能带的第一陈数，以及两个数值误差度量。该解决方案需要一种基于布里渊区晶格离散化的数值方法。\n\n该系统由一个 $2 \\times 2$ 的厄米布洛赫算符（或哈密顿量）描述，它是布洛赫波矢 $k = (k_x, k_y)$ 的函数：\n$$\nH(k) = d_x(k)\\,\\sigma_x + d_y(k)\\,\\sigma_y + d_z(k)\\,\\sigma_z\n$$\n其中 $\\sigma_x, \\sigma_y, \\sigma_z$ 是泡利矩阵：\n$$\n\\sigma_x = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}, \\quad \\sigma_y = \\begin{pmatrix} 0  -i \\\\ i  0 \\end{pmatrix}, \\quad \\sigma_z = \\begin{pmatrix} 1  0 \\\\ 0  -1 \\end{pmatrix}\n$$\n矢量 $\\vec{d}(k)$ 的分量由 $d_x(k) = \\sin(k_x)$、$d_y(k) = \\sin(k_y)$ 和 $d_z(k) = m + \\cos(k_x) + \\cos(k_y)$ 给出。参数 $m$ 用于调控系统穿过不同的拓扑相。此哈密顿量的本征值为 $\\omega(k) = \\pm|\\vec{d}(k)|$，定义了两个能带。问题集中于下能带，其对应于本征值 $\\omega_0(k) = -|\\vec{d}(k)|$。\n\n第一陈数 $C$ 是一个表征能带结构的拓扑不变量。它被定义为贝里曲率 $\\mathcal{F}(k)$ 在第一布里渊区 (BZ) 上的积分：\n$$\nC = \\frac{1}{2\\pi} \\int_{\\mathrm{BZ}} \\mathcal{F}(k) \\, dk_x dk_y\n$$\n贝里曲率源于本征态的几何结构。对于有限网格上的数值计算，由于底层贝里联络的规范依赖性，直接对该积分进行离散化是繁琐的。一个更稳健的方法，正如问题所建议的，是基于由 Fukui、Hatsugai 和 Suzuki 提出的格点规范理论表述。\n\n数值计算步骤如下：\n\n1.  **布里渊区的离散化**：将布里渊区 BZ（$k_x, k_y \\in [-\\pi, \\pi]$）离散化为一个均匀的 $N \\times N$ 网格。为遵循 BZ 的周期性，网格点选为 $k_{i_x, i_y} = (k_x^{(i_x)}, k_y^{(i_y)})$，其中对于 $i_{x,y} \\in \\{0, 1, \\dots, N-1\\}$，$k_{x,y}^{(i)} = -\\pi + i \\frac{2\\pi}{N}$。\n\n2.  **本征矢量计算**：在每个网格点 $k$，构建哈密顿矩阵 $H(k)$ 并将其对角化，以找到其本征值和本征矢量。我们关心的是与最低本征值 $\\omega_0(k)$ 对应的归一化本征矢量 $u_0(k)$。对网格上所有 $N^2$ 个点都执行此操作。\n\n3.  **链路变量**：我们定义连接格点上相邻本征矢量的链路变量。这些复数表示平行输运的规范不变部分：\n    $$\n    U_x(k) = \\langle u_0(k) | u_0(k + \\Delta_x) \\rangle\n    $$\n    $$\n    U_y(k) = \\langle u_0(k) | u_0(k + \\Delta_y) \\rangle\n    $$\n    其中 $\\Delta_x$ 和 $\\Delta_y$ 分别是 $k_x$ 和 $k_y$ 方向上的晶格矢量。内积为 $\\langle a | b \\rangle = a^\\dagger b$。\n\n4.  **格框贝里通量**：通过一个始于点 $k$ 的基本格框的局域贝里通量，是通过计算该格框威尔逊环的辐角得出的。这个环绕格框的四个链路变量的乘积是一个规范不变量：\n    $$\n    W(k) = U_x(k) \\, U_y(k+\\Delta_x) \\, U_x(k+\\Delta_y)^* \\, U_y(k)^*\n    $$\n    局域通量则为 $\\mathcal{F}_{\\text{lat}}(k) = \\arg(W(k))$。复对数的分支必须选择在 $(-\\pi, \\pi]$ 内，这可以由 `atan2` 函数（或 `numpy.angle`）自然处理。\n\n5.  **陈数求和**：总陈数是布里渊区中所有 $N^2$ 个格框上的局域通量之和，再用 $2\\pi$ 归一化：\n    $$\n    C = \\frac{1}{2\\pi} \\sum_{k \\in \\text{grid}} \\mathcal{F}_{\\text{lat}}(k)\n    $$\n    对于一个有能隙的系统和足够精细的网格，这个和会收敛到一个整数。\n\n除了在尺寸为 $N$ 的基础网格上计算陈数 $C$ 外，还计算了两个误差度量：\n\n-   **有限网格离散化误差 ($E_{\\mathrm{mesh}}$)**：此度量用于估计计算相对于网格尺寸的收敛性。它通过计算在基础网格（$N \\times N$）和加密网格（$2N \\times 2N$）上计算出的陈数之间的绝对差得出：\n    $$\n    E_{\\mathrm{mesh}} = |C_N - C_{2N}|\n    $$\n\n-   **模式正交性稳定度量 ($E_{\\mathrm{ortho}}$)**：此度量量化了整个布里渊区上本征矢量场的“平滑度”。由于在相邻点 $k$ 和 $k'$ 的归一化本征矢量应几乎相同（仅相差一个小的旋转），它们内积的幅度 $|\\langle u_0(k) | u_0(k') \\rangle|$ 应接近于 $1$。与 $1$ 的显著偏离表明本征矢量发生了快速变化，这通常发生在能带简并（能隙闭合点）附近或网格过于粗糙的情况下。该度量定义为在基础 $N \\times N$ 网格上所有链路上与单位1的平均偏差：\n    $$\n    E_{\\mathrm{ortho}} = \\frac{1}{2N^2} \\sum_{k \\in \\text{grid}} \\left[ \\left(1 - |\\langle u_0(k)|u_0(k+\\Delta_x)\\rangle|\\right) + \\left(1 - |\\langle u_0(k)|u_0(k+\\Delta_y)\\rangle|\\right) \\right]\n    $$\n\n实现利用 `numpy` 进行高效的矢量化计算。k空间网格使用 `meshgrid` 生成。哈密顿量被构建为一个形状为 $(N, N, 2, 2)$ 的数组。`numpy.linalg.eigh` 用于同时对角化所有 $N^2$ 个矩阵。通过使用 `numpy.roll` 移动数组来访问相邻网格点，从而高效地处理周期性边界条件。这种矢量化的方法避免了缓慢的 Python 循环，非常适合此类问题。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_properties(m, N_grid):\n    \"\"\"\n    Computes the Chern number and orthogonality metrics for a given m and grid size N.\n\n    Args:\n        m (float): The bias parameter in the Hamiltonian.\n        N_grid (int): The number of points along one dimension of the BZ grid.\n\n    Returns:\n        tuple: A tuple containing:\n            - chern_number (float): The computed Chern number for the lower band.\n            - s_x (np.ndarray): Array of overlap magnitudes in the x-direction.\n            - s_y (np.ndarray): Array of overlap magnitudes in the y-direction.\n    \"\"\"\n    # Create the k-space grid. np.linspace with endpoint=False is standard for\n    # periodic Fourier-space calculations.\n    k_vals = np.linspace(-np.pi, np.pi, N_grid, endpoint=False)\n    kx, ky = np.meshgrid(k_vals, k_vals, indexing='ij')\n\n    # Construct the Hamiltonian H(k) = d(k) . sigma over the entire grid.\n    # The shape will be (N_grid, N_grid, 2, 2).\n    H = np.zeros((N_grid, N_grid, 2, 2), dtype=complex)\n    \n    # Components of the d-vector\n    d_x = np.sin(kx)\n    d_y = np.sin(ky)\n    d_z = m + np.cos(kx) + np.cos(ky)\n\n    # Populate the Hamiltonian matrices using Pauli matrix definitions\n    H[..., 0, 0] = d_z\n    H[..., 1, 1] = -d_z\n    H[..., 0, 1] = d_x - 1j * d_y\n    H[..., 1, 0] = d_x + 1j * d_y\n\n    # Diagonalize the Hamiltonian at each k-point.\n    # np.linalg.eigh is for Hermitian matrices and returns sorted eigenvalues\n    # and corresponding normalized eigenvectors.\n    # evals shape: (N_grid, N_grid, 2)\n    # evecs shape: (N_grid, N_grid, 2, 2)\n    evals, evecs = np.linalg.eigh(H)\n\n    # Extract the eigenvectors for the lower band (corresponding to the first eigenvalue).\n    # u0 shape: (N_grid, N_grid, 2)\n    u0 = evecs[..., 0]\n\n    # Compute link variables (overlaps) using periodic boundary conditions via np.roll.\n    # The inner product is"
        },
        {
            "introduction": "除了直接积分贝里曲率，威尔逊环（Wilson loop）是另一种揭示能带拓扑的有力工具。通过计算威尔逊环的本征值谱，我们可以追踪瓦尼尔中心（Wannier center）在动量空间中的演化，其缠绕数直接对应于陈数。这个练习将让你通过实现威尔逊环的计算，从几何相位和瓦尼尔荷流动的角度来理解拓扑不变量，为你提供一个与FHS方法互补的深刻见解 。",
            "id": "4147659",
            "problem": "考虑一个二维周期性声学超材料，其模型为一个具有线性、无损、小振幅动力学特性的晶格。周期性介质中的线性化声波方程产生了一个厄米算符的布洛赫本征问题，该算符在晶体动量空间中是周期性的。在计算声学中，一个等效厄米布洛赫算符 $H(\\mathbf{k})$ 作用于布洛赫模式 $u_n(\\mathbf{k})$，并产生能带频率（或在等效描述中的能量）。对于由一组能带标签 $\\mathcal{S}$ 索引的固定能带子空间，沿 $k_x$ 方向的非阿贝尔贝里联络定义为\n$$\n\\mathcal{A}_x^{mn}(\\mathbf{k}) = i \\langle u_m(\\mathbf{k}) \\mid \\partial_{k_x} u_n(\\mathbf{k}) \\rangle,\\quad m,n \\in \\mathcal{S}.\n$$\n在固定 $k_y$ 时，沿 $k_x$ 的威尔逊环是路径排序指数\n$$\nW(k_y) = \\mathcal{P} \\exp\\left(i \\int_{0}^{2\\pi} \\mathcal{A}_x(\\mathbf{k}) \\, dk_x \\right),\n$$\n其本征值可以写成 $e^{i \\theta_a(k_y)}$，其中相位 $ \\theta_a(k_y)$ 是瓦尼尔中心角。当 $k_y$ 从 $0$ 遍历到 $2\\pi$ 时，这些相位之和的净缠绕是非平庸拓扑的一个标志；具体而言，整数\n$$\n\\nu = \\frac{1}{2\\pi} \\left[ \\sum_a \\theta_a(2\\pi) - \\sum_a \\theta_a(0) \\right],\n$$\n在 $k_y$ 上选择连续分支进行计算，该整数表示了能带子空间的拓扑特性。\n\n你的任务是为一个指定的能带子空间实现一个完整的、数值稳定的威尔逊环计算，并识别瓦尼尔中心流中的整数缠绕。你必须使用离散的布里渊区采样和一种数值上稳健的规范不变构造方法。\n\n使用以下 $H(\\mathbf{k})$ 的等效模型来定义测试套件。所有角度必须以弧度处理，所有量均为无量纲。\n\n1. 具有破缺的等效时间反演对称性的双能带 Qi–Wu–Zhang 模型：\n$$\nH_{\\mathrm{QWZ}}(\\mathbf{k};m) = \\sin(k_x)\\,\\sigma_x + \\sin(k_y)\\,\\sigma_y + \\left(m + \\cos(k_x) + \\cos(k_y)\\right)\\,\\sigma_z,\n$$\n其中 $\\sigma_x,\\sigma_y,\\sigma_z$ 是泡利矩阵，$m$ 是一个实数参数。在此等效描述中，能量较低的能带被视为维度为 $1$ 的“占据”能带子空间。\n\n2. 由两个独立的 Qi–Wu–Zhang 块组成的块对角四能带模型：\n$$\nH_{\\mathrm{BLOCK}}(\\mathbf{k};m_1,m_2) = H_{\\mathrm{QWZ}}(\\mathbf{k};m_1) \\oplus H_{\\mathrm{QWZ}}(\\mathbf{k};m_2),\n$$\n其中“占据”能带子空间的维度为 $2$，由该 $4\\times 4$ 厄米算符的两个最低能量能带组成。\n\n对于每个固定的 $k_y$，使用 $k_x$ 和 $k_y$ 的离散采样，实现沿 $k_x \\in [0,2\\pi)$ 的威尔逊环 $W(k_y)$，在所选占据子空间内相邻 $k_x$ 点之间构造一个数值幺正的连接，并计算行列式相位\n$$\n\\phi(k_y) = \\arg\\left(\\det W(k_y)\\right).\n$$\n然后计算整数缠绕数\n$$\n\\nu = \\mathrm{round}\\left(\\frac{\\phi(2\\pi) - \\phi(0)}{2\\pi}\\right),\n$$\n在将 $\\phi(k_y)$ 展开为 $k_y$ 的连续函数后。报告每个测试用例的该整数。\n\n测试套件规范（所有角度均为弧度，所有量均为无量纲）：\n\n- 测试用例 1：模型 $H_{\\mathrm{QWZ}}$，参数 $m = 0.5$，离散化 $N_{k_x} = 201$, $N_{k_y} = 181$，占据子空间维度 $1$。\n- 测试用例 2：模型 $H_{\\mathrm{QWZ}}$，参数 $m = 3.0$，离散化 $N_{k_x} = 201$, $N_{k_y} = 181$，占据子空间维度 $1$。\n- 测试用例 3：模型 $H_{\\mathrm{QWZ}}$，参数 $m = -0.5$，离散化 $N_{k_x} = 201$, $N_{k_y} = 181$，占据子空间维度 $1$。\n- 测试用例 4：模型 $H_{\\mathrm{BLOCK}}$，参数 $m_1 = 0.5$, $m_2 = -0.5$，离散化 $N_{k_x} = 181$, $N_{k_y} = 151$，占据子空间维度 $2$。\n- 测试用例 5：模型 $H_{\\mathrm{QWZ}}$，参数 $m = 0.5$，粗糙离散化 $N_{k_x} = 31$, $N_{k_y} = 31$，占据子空间维度 $1$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“$[result_1,result_2,\\dots]$”），其中每个 $result_j$ 是按上述顺序列出的相应测试用例计算出的整数缠绕数 $\\nu$。输出是无单位的，所有内部计算必须使用弧度作为角度单位。",
            "solution": "该问题是有效的，因为它在拓扑声学领域提出了一个定义明确、有科学依据的计算任务。所给出的模型、参数和目标都足够精确，能够得出一个唯一且可验证的解。其基础物理，基于周期性介质的布洛赫理论描述以及拓扑能带理论中的贝里联络和威尔逊环等概念，是可靠的。所提供的 Qi–Wu–Zhang (QWZ) 模型是一个展现非平庸拓扑相（陈绝缘体）的系统的典型例子，其拓扑不变量是公认的。\n\n任务是计算整数缠绕数 $\\nu$，它对应于指定占据能带子空间的陈数。这通过沿一个晶体学方向（例如 $k_x$）计算威尔逊环，并观察其性质如何随横向晶体动量 $k_y$ 变化来实现。\n\n沿动量空间中闭合路径的威尔逊环是一个矩阵，它捕捉了布洛赫态累积的几何相位。对于在固定 $k_y$ 下沿 $k_x$ 方向从 $k_x=0$到 $k_x=2\\pi$ 的路径，威尔逊环算符由下式给出\n$$\nW(k_y) = \\mathcal{P} \\exp\\left(i \\int_{0}^{2\\pi} \\mathcal{A}_x(\\mathbf{k}) \\, dk_x \\right),\n$$\n其中 $\\mathcal{P}$ 表示路径排序，$\\mathcal{A}_x$ 是所选能带子空间的非阿贝尔贝里联络矩阵。其分量为 $\\mathcal{A}_x^{mn}(\\mathbf{k}) = i \\langle u_m(\\mathbf{k}) \\mid \\partial_{k_x} u_n(\\mathbf{k}) \\rangle$，其中 $\\{|u_n(\\mathbf{k})\\rangle\\}$ 是维度为 $D$ 的占据子空间的布洛赫态标准正交基。\n\n由于数值对角化程序返回的本征向量相位存在规范自由度，直接数值计算 $\\partial_{k_x} u_n(\\mathbf{k})$ 是不明智的。一种数值稳定且规范不变的方法涉及将积分路径离散化。布里渊区在离散点上进行采样。$k_x$ 路径被离散化为 $N_{k_x}$ 个点，$k_{x,j} = j(2\\pi/N_{k_x})$，$j = 0, 1, \\dots, N_{k_x}-1$。积分随后被近似为“连接矩阵” $F_j$ 的乘积，这些矩阵连接了相邻动量点上占据态的基：\n$$\n(F_j)_{mn} = \\langle u_m(\\mathbf{k}_j) \\mid u_n(\\mathbf{k}_{j+1}) \\rangle,\n$$\n其中 $\\mathbf{k}_j = (k_{x,j}, k_y)$。以矩阵形式表示，$F_j = U_j^\\dagger U_{j+1}$，其中 $U_j$ 是一个 $N \\times D$ 矩阵，其列是在 $\\mathbf{k}_j$ 处的 $D$ 个占据布洛赫本征向量。路径排序的乘积变为矩阵乘积，其中较大 $k_x$ 的算符出现在左侧：\n$$\nW(k_y) \\approx F_{N_{k_x}-1} F_{N_{k_x}-2} \\cdots F_0.\n$$\n布里渊区的周期性意味着 $k_x=2\\pi$ 处的态等价于 $k_x=0$ 处的态，因此最终的连接矩阵是 $F_{N_{k_x}-1} = U_{N_{k_x}-1}^\\dagger U_0$。\n\n幺正矩阵 $W(k_y)$ 的本征值形式为 $e^{i\\theta_a(k_y)}$，其中相位 $\\theta_a(k_y)$ 是瓦尼尔中心的位置。这些相位之和与威尔逊环的行列式有关：\n$$\n\\sum_a \\theta_a(k_y) = \\arg\\left(\\det W(k_y)\\right) \\pmod{2\\pi}.\n$$\n令 $\\phi(k_y) = \\arg(\\det W(k_y))$。当 $k_y$ 从 $0$ 变化到 $2\\pi$ 时，中心 $\\theta_a(k_y)$ 可能会“流动”，其和的净变化（在被正确地展开为 $k_y$ 的连续函数后）揭示了拓扑缠绕数：\n$$\n\\nu = \\frac{1}{2\\pi} \\left[ \\phi_{\\text{unwrapped}}(2\\pi) - \\phi_{\\text{unwrapped}}(0) \\right].\n$$\n由于 $\\nu$ 必须是整数，通过对结果进行四舍五入可以使计算更加稳健。\n\n算法流程如下：\n1.  将 $k_y$ 路径离散化为从 $k_y=0$ 到 $k_y=2\\pi$（含端点）的 $N_{k_y}$ 个点。\n2.  对于此网格中的每个 $k_y$：\n    a. 将 $k_x$ 路径离散化为从 $k_x=0$ 到 $k_x=2\\pi$（不含端点）的 $N_{k_x}$ 个点。\n    b. 对于每个点 $(k_{x,j}, k_y)$，构造指定的哈密顿矩阵 $H(k_{x,j}, k_y)$。\n    c. 使用厄米本征求解器（例如 `numpy.linalg.eigh`）对 $H$ 进行数值对角化。\n    d. 从排序后的本征值中，识别出对应于 $D$ 个最低能量能带的 $D$ 个本征向量。这些向量构成了矩阵 $U_j$ 的列。\n    e. 计算连接矩阵 $F_j = U_j^\\dagger U_{j+1}$（$j=0, \\dots, N_{k_x}-1$），通过 $U_{N_{k_x}} = U_0$ 强制执行周期性。\n    f. 计算威尔逊环矩阵 $W(k_y) = F_{N_{k_x}-1} \\cdots F_0$。\n    g. 计算其行列式的相位 $\\phi(k_y) = \\arg(\\det W(k_y))$。\n3.  将相位 $\\{\\phi(k_y)\\}$ 收集到一个数组中。\n4.  对此数组应用相位展开算法（例如 `numpy.unwrap`）以获得 $\\phi_{\\text{unwrapped}}(k_y)$。\n5.  计算缠绕数 $\\nu = \\text{round}\\left( (\\phi_{\\text{unwrapped}}[-1] - \\phi_{\\text{unwrapped}}[0]) / (2\\pi) \\right)$。\n\n此过程应用于每个测试用例，使用指定的哈密顿模型 $H_{\\mathrm{QWZ}}(\\mathbf{k};m)$ 和 $H_{\\mathrm{BLOCK}}(\\mathbf{k};m_1,m_2)$ 及其相应参数。前者是一个 $2 \\times 2$ 模型，而后者是一个 $4 \\times 4$ 的块对角模型。占据子空间维度 $D$（$1$ 或 $2$）的选择遵循指定要求。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import block_diag\n\n# Define Pauli matrices as global constants\nSIGMA_X = np.array([[0, 1], [1, 0]], dtype=np.complex128)\nSIGMA_Y = np.array([[0, -1j], [1j, 0]], dtype=np.complex128)\nSIGMA_Z = np.array([[1, 0], [0, -1]], dtype=np.complex128)\n\ndef get_hamiltonian(kx, ky, model, params):\n    \"\"\"\n    Constructs the Hamiltonian matrix for a given model and parameters.\n    \"\"\"\n    if model == 'QWZ':\n        m = params['m']\n        h = (np.sin(kx) * SIGMA_X +\n             np.sin(ky) * SIGMA_Y +\n             (m + np.cos(kx) + np.cos(ky)) * SIGMA_Z)\n        return h\n    elif model == 'BLOCK':\n        m1, m2 = params['m1'], params['m2']\n        h1 = (np.sin(kx) * SIGMA_X +\n              np.sin(ky) * SIGMA_Y +\n              (m1 + np.cos(kx) + np.cos(ky)) * SIGMA_Z)\n        h2 = (np.sin(kx) * SIGMA_X +\n              np.sin(ky) * SIGMA_Y +\n              (m2 + np.cos(kx) + np.cos(ky)) * SIGMA_Z)\n        return block_diag(h1, h2)\n    else:\n        raise ValueError(f\"Unknown model: {model}\")\n\ndef calculate_phi_at_ky(ky, model, params, Nkx, D):\n    \"\"\"\n    Calculates the phase of the determinant of the Wilson loop for a fixed ky.\n    \"\"\"\n    kx_grid = np.linspace(0, 2 * np.pi, Nkx, endpoint=False)\n    \n    # Store matrices of occupied eigenvectors for each kx\n    U_list = []\n    for kx in kx_grid:\n        H = get_hamiltonian(kx, ky, model, params)\n        # eigh returns sorted eigenvalues and corresponding eigenvectors\n        # for Hermitian matrices.\n        evals, evecs = np.linalg.eigh(H)\n        # The first D columns correspond to the D lowest eigenvalues.\n        U = evecs[:, :D]\n        U_list.append(U)\n\n    # Calculate the Wilson loop by multiplying link matrices\n    # W = F_{N-1} * ... * F_0\n    W = np.identity(D, dtype=np.complex128)\n    for j in range(Nkx):\n        U_j = U_list[j]\n        # Use periodic boundary condition for the last link\n        U_j_plus_1 = U_list[(j + 1) % Nkx]\n        \n        # Link matrix F_j = U_j^dagger * U_{j+1}\n        F_j = U_j.T.conj() @ U_j_plus_1\n        \n        # Multiply from the left to get correct path ordering\n        W = F_j @ W\n\n    # The phase of the determinant of the Wilson loop\n    return np.angle(np.linalg.det(W))\n\ndef compute_winding_number(model, params, Nkx, Nky, D):\n    \"\"\"\n    Computes the winding number nu for a given set of parameters.\n    \"\"\"\n    # The ky path must include both 0 and 2*pi to get phi(0) and phi(2*pi)\n    ky_grid = np.linspace(0, 2 * np.pi, Nky, endpoint=True)\n    \n    phi_values = []\n    for ky in ky_grid:\n        phi = calculate_phi_at_ky(ky, model, params, Nkx, D)\n        phi_values.append(phi)\n        \n    # Unwrap the phase to handle jumps larger than pi\n    phi_unwrapped = np.unwrap(phi_values)\n    \n    # Total phase change over the ky path [0, 2*pi]\n    delta_phi = phi_unwrapped[-1] - phi_unwrapped[0]\n    \n    # The winding number is the integer number of 2*pi windings\n    winding_number = round(delta_phi / (2 * np.pi))\n    \n    return int(winding_number)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {'model': 'QWZ',   'params': {'m': 0.5}, 'Nkx': 201, 'Nky': 181, 'D': 1},\n        {'model': 'QWZ',   'params': {'m': 3.0}, 'Nkx': 201, 'Nky': 181, 'D': 1},\n        {'model': 'QWZ',   'params': {'m': -0.5}, 'Nkx': 201, 'Nky': 181, 'D': 1},\n        {'model': 'BLOCK', 'params': {'m1': 0.5, 'm2': -0.5}, 'Nkx': 181, 'Nky': 151, 'D': 2},\n        {'model': 'QWZ',   'params': {'m': 0.5}, 'Nkx': 31, 'Nky': 31, 'D': 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        nu = compute_winding_number(\n            model=case['model'],\n            params=case['params'],\n            Nkx=case['Nkx'],\n            Nky=case['Nky'],\n            D=case['D']\n        )\n        results.append(nu)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}