{
    "hands_on_practices": [
        {
            "introduction": "Before we compute reflections with ray-based methods, it is crucial to understand the wave-like nature of sound that dominates at low frequencies. The interaction of sound waves with room boundaries creates standing wave patterns known as acoustic modes, which define a room's characteristic resonant frequencies. This foundational exercise  guides you through the process of deriving these modes from first principles, connecting the physical constraint of a rigid wall to the mathematical quantization of sound fields in an enclosure.",
            "id": "4135947",
            "problem": "A three-dimensional rectangular room occupies the domain $0 \\leq x \\leq L_{x}$, $0 \\leq y \\leq L_{y}$, and $0 \\leq z \\leq L_{z}$. The room is filled with a homogeneous, lossless, stationary fluid of density $\\rho_{0}$ and sound speed $c$, and all six walls are perfectly rigid. Consider time-harmonic acoustic motion with angular frequency $\\omega$, so that the acoustic pressure can be written as $p(\\mathbf{x},\\omega) \\exp(-\\mathrm{i}\\,\\omega t)$ where $p(\\mathbf{x},\\omega)$ is the complex amplitude. Assume a trial pressure amplitude\n$$\np(x,y,z,\\omega) = A \\cos(k_{x} x)\\cos(k_{y} y)\\cos(k_{z} z),\n$$\nwhere $A$ is a complex constant and $k_{x}$, $k_{y}$, $k_{z}$ are separation constants to be determined.\n\nStarting from the linearized equations of acoustics, and using only standard physical laws, do the following:\n\n1. Derive the appropriate rigid-wall boundary condition for the pressure field on each wall in terms of the normal derivative $\\partial p/\\partial n$, where $\\partial p/\\partial n = \\hat{\\mathbf{n}}\\cdot\\nabla p$ and $\\hat{\\mathbf{n}}$ is the outward unit normal to the wall.\n\n2. Compute the outward normal derivative $\\partial p/\\partial n$ of the given trial field at each of the six walls: $x=0$, $x=L_{x}$, $y=0$, $y=L_{y}$, $z=0$, and $z=L_{z}$.\n\n3. Impose the boundary condition derived in part 1 on each wall and demand that it holds for all points on that wall. From this, determine the constraints on $k_{x}$, $k_{y}$, and $k_{z}$.\n\nExpress your final results for the wavenumbers $k_{x}$, $k_{y}$, and $k_{z}$ in reciprocal meters $\\text{m}^{-1}$. Provide the final answer as a single row matrix containing the three expressions for $(k_{x},k_{y},k_{z})$ in terms of the room dimensions and integer mode indices. No numerical rounding is required.",
            "solution": "The problem requires the determination of the allowed wavenumbers for acoustic modes in a rectangular room with rigid walls, based on a given trial solution for the pressure field. The solution will proceed in three steps as specified in the problem statement.\n\nFirst, I will derive the boundary condition imposed by a perfectly rigid wall on the acoustic pressure field. The fundamental relationship between acoustic pressure $p$ and fluid particle velocity $\\mathbf{u}$ is given by the linearized Euler's equation of motion. For a homogeneous, stationary fluid of density $\\rho_{0}$, this is:\n$$\n\\rho_{0} \\frac{\\partial \\mathbf{u}(\\mathbf{x}, t)}{\\partial t} = -\\nabla p(\\mathbf{x}, t)\n$$\nThe problem specifies time-harmonic motion, where the pressure is $p(\\mathbf{x},\\omega) \\exp(-\\mathrm{i}\\,\\omega t)$ and the particle velocity is $\\mathbf{u}(\\mathbf{x},\\omega) \\exp(-\\mathrm{i}\\,\\omega t)$. Substituting these forms into Euler's equation gives:\n$$\n\\rho_{0} \\frac{\\partial}{\\partial t} \\left[ \\mathbf{u}(\\mathbf{x},\\omega) \\exp(-\\mathrm{i}\\,\\omega t) \\right] = -\\nabla \\left[ p(\\mathbf{x},\\omega) \\exp(-\\mathrm{i}\\,\\omega t) \\right]\n$$\nEvaluating the time derivative and gradient, we get:\n$$\n\\rho_{0} (-\\mathrm{i}\\,\\omega) \\mathbf{u}(\\mathbf{x},\\omega) \\exp(-\\mathrm{i}\\,\\omega t) = -[\\nabla p(\\mathbf{x},\\omega)] \\exp(-\\mathrm{i}\\,\\omega t)\n$$\nCanceling the common time-dependent factor $\\exp(-\\mathrm{i}\\,\\omega t)$ and rearranging for the complex velocity amplitude $\\mathbf{u}(\\mathbf{x},\\omega)$ yields:\n$$\n\\mathbf{u}(\\mathbf{x},\\omega) = \\frac{\\nabla p(\\mathbf{x},\\omega)}{\\mathrm{i}\\,\\omega \\rho_{0}}\n$$\nA perfectly rigid wall is impenetrable. This physical constraint means that the component of the fluid particle velocity normal to the wall must be zero at the wall's surface. If $\\hat{\\mathbf{n}}$ is the outward unit normal vector to a wall surface, this condition is expressed as:\n$$\n\\mathbf{u}(\\mathbf{x},\\omega) \\cdot \\hat{\\mathbf{n}} = 0 \\quad \\text{for } \\mathbf{x} \\text{ on the wall}\n$$\nSubstituting the expression for $\\mathbf{u}(\\mathbf{x},\\omega)$ gives the boundary condition in terms of the pressure amplitude:\n$$\n\\frac{\\nabla p(\\mathbf{x},\\omega) \\cdot \\hat{\\mathbf{n}}}{\\mathrm{i}\\,\\omega \\rho_{0}} = 0\n$$\nFor a non-trivial acoustic field, the angular frequency $\\omega$ is non-zero, and the fluid density $\\rho_{0}$ is also non-zero. Therefore, the condition simplifies to:\n$$\n\\nabla p(\\mathbf{x},\\omega) \\cdot \\hat{\\mathbf{n}} = 0\n$$\nBy definition, the normal derivative is $\\partial p/\\partial n = \\nabla p \\cdot \\hat{\\mathbf{n}}$. Thus, the boundary condition for the acoustic pressure amplitude $p$ at a perfectly rigid wall is:\n$$\n\\frac{\\partial p}{\\partial n} = 0\n$$\nThis is a homogeneous Neumann boundary condition.\n\nSecond, we compute the outward normal derivative $\\partial p/\\partial n$ for the given trial pressure field at each of the six walls. The trial field is:\n$$\np(x,y,z,\\omega) = A \\cos(k_{x} x)\\cos(k_{y} y)\\cos(k_{z} z)\n$$\nThe gradient of this field, $\\nabla p$, is:\n$$\n\\nabla p = \\frac{\\partial p}{\\partial x}\\hat{\\mathbf{i}} + \\frac{\\partial p}{\\partial y}\\hat{\\mathbf{j}} + \\frac{\\partial p}{\\partial z}\\hat{\\mathbf{k}}\n$$\nwhere\n$$\n\\frac{\\partial p}{\\partial x} = -A k_{x} \\sin(k_{x} x)\\cos(k_{y} y)\\cos(k_{z} z)\n$$\n$$\n\\frac{\\partial p}{\\partial y} = -A k_{y} \\cos(k_{x} x)\\sin(k_{y} y)\\cos(k_{z} z)\n$$\n$$\n\\frac{\\partial p}{\\partial z} = -A k_{z} \\cos(k_{x} x)\\cos(k_{y} y)\\sin(k_{z} z)\n$$\nNow we evaluate $\\partial p/\\partial n = \\hat{\\mathbf{n}}\\cdot\\nabla p$ at each wall.\n1.  Wall at $x=0$: The outward normal is $\\hat{\\mathbf{n}} = -\\hat{\\mathbf{i}}$.\n    $\\frac{\\partial p}{\\partial n} = (-\\hat{\\mathbf{i}}) \\cdot \\nabla p = -\\frac{\\partial p}{\\partial x} \\bigg|_{x=0} = -(-A k_{x} \\sin(0)\\cos(k_{y} y)\\cos(k_{z} z)) = 0$.\n2.  Wall at $x=L_{x}$: The outward normal is $\\hat{\\mathbf{n}} = +\\hat{\\mathbf{i}}$.\n    $\\frac{\\partial p}{\\partial n} = (+\\hat{\\mathbf{i}}) \\cdot \\nabla p = +\\frac{\\partial p}{\\partial x} \\bigg|_{x=L_{x}} = -A k_{x} \\sin(k_{x} L_{x})\\cos(k_{y} y)\\cos(k_{z} z)$.\n3.  Wall at $y=0$: The outward normal is $\\hat{\\mathbf{n}} = -\\hat{\\mathbf{j}}$.\n    $\\frac{\\partial p}{\\partial n} = (-\\hat{\\mathbf{j}}) \\cdot \\nabla p = -\\frac{\\partial p}{\\partial y} \\bigg|_{y=0} = -(-A k_{y} \\cos(k_{x} x)\\sin(0)\\cos(k_{z} z)) = 0$.\n4.  Wall at $y=L_{y}$: The outward normal is $\\hat{\\mathbf{n}} = +\\hat{\\mathbf{j}}$.\n    $\\frac{\\partial p}{\\partial n} = (+\\hat{\\mathbf{j}}) \\cdot \\nabla p = +\\frac{\\partial p}{\\partial y} \\bigg|_{y=L_{y}} = -A k_{y} \\cos(k_{x} x)\\sin(k_{y} L_{y})\\cos(k_{z} z)$.\n5.  Wall at $z=0$: The outward normal is $\\hat{\\mathbf{n}} = -\\hat{\\mathbf{k}}$.\n    $\\frac{\\partial p}{\\partial n} = (-\\hat{\\mathbf{k}}) \\cdot \\nabla p = -\\frac{\\partial p}{\\partial z} \\bigg|_{z=0} = -(-A k_{z} \\cos(k_{x} x)\\cos(k_{y} y)\\sin(0)) = 0$.\n6.  Wall at $z=L_{z}$: The outward normal is $\\hat{\\mathbf{n}} = +\\hat{\\mathbf{k}}$.\n    $\\frac{\\partial p}{\\partial n} = (+\\hat{\\mathbf{k}}) \\cdot \\nabla p = +\\frac{\\partial p}{\\partial z} \\bigg|_{z=L_{z}} = -A k_{z} \\cos(k_{x} x)\\cos(k_{y} y)\\sin(k_{z} L_{z})$.\nThe trial solution automatically satisfies the boundary condition at the walls $x=0$, $y=0$, and $z=0$.\n\nThird, we impose the boundary condition $\\partial p/\\partial n = 0$ on the remaining three walls ($x=L_x$, $y=L_y$, $z=L_z$). For a non-trivial solution ($A \\neq 0$), this requires specific constraints on the wavenumbers $k_{x}$, $k_{y}$, and $k_{z}$.\n\n1.  At $x=L_{x}$: We require $-A k_{x} \\sin(k_{x} L_{x})\\cos(k_{y} y)\\cos(k_{z} z) = 0$ for all $y \\in [0, L_{y}]$ and $z \\in [0, L_{z}]$. For a non-trivial spatial mode, this can only be satisfied if the sine term is zero. The case $k_x=0$ is a valid solution corresponding to the mode index $n_x=0$. If $k_x \\neq 0$, we must have:\n    $$\n    \\sin(k_{x} L_{x}) = 0\n    $$\n    This implies that the argument of the sine function must be an integer multiple of $\\pi$.\n    $$\n    k_{x} L_{x} = n_{x} \\pi, \\quad \\text{for } n_{x} \\in \\mathbb{Z}\n    $$\n    This yields $k_{x} = \\frac{n_{x} \\pi}{L_{x}}$. Since $\\cos(-u) = \\cos(u)$, negative integers for $n_{x}$ do not produce new unique spatial functions, so we restrict $n_{x}$ to non-negative integers: $n_{x} = 0, 1, 2, \\dots$.\n\n2.  At $y=L_{y}$: Similar reasoning requires $-A k_{y} \\cos(k_{x} x)\\sin(k_{y} L_{y})\\cos(k_{z} z) = 0$ for all $x \\in [0, L_{x}]$ and $z \\in [0, L_{z}]$. This leads to:\n    $$\n    \\sin(k_{y} L_{y}) = 0 \\quad \\text{or} \\quad k_y=0\n    $$\n    $$\n    k_{y} L_{y} = n_{y} \\pi \\implies k_{y} = \\frac{n_{y} \\pi}{L_{y}}, \\quad \\text{for } n_{y} = 0, 1, 2, \\dots\n    $$\n\n3.  At $z=L_{z}$: The condition $-A k_{z} \\cos(k_{x} x)\\cos(k_{y} y)\\sin(k_{z} L_{z}) = 0$ must hold for all $x \\in [0, L_{x}]$ and $y \\in [0, L_{y}]$, which implies:\n    $$\n    \\sin(k_{z} L_{z}) = 0 \\quad \\text{or} \\quad k_z=0\n    $$\n    $$\n    k_{z} L_{z} = n_{z} \\pi \\implies k_{z} = \\frac{n_{z} \\pi}{L_{z}}, \\quad \\text{for } n_{z} = 0, 1, 2, \\dots\n    $$\n\nThe set of integers $(n_{x}, n_{y}, n_{z})$ specifies an acoustic mode of the rectangular room. The case $(0,0,0)$ corresponds to a spatially uniform pressure, which is a valid solution representing a static pressure offset. The wavenumbers are thus quantized.\n\nThe final expressions for the wavenumbers are:\n$$\nk_{x} = \\frac{n_{x} \\pi}{L_{x}}\n$$\n$$\nk_{y} = \\frac{n_{y} \\pi}{L_{y}}\n$$\n$$\nk_{z} = \\frac{n_{z} \\pi}{L_{z}}\n$$\nwhere $n_x$, $n_y$, and $n_z$ are non-negative integer mode indices. The units are correct, as $L_x, L_y, L_z$ are in meters, making the wavenumbers in reciprocal meters ($\\text{m}^{-1}$).",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{n_{x} \\pi}{L_{x}} & \\frac{n_{y} \\pi}{L_{y}} & \\frac{n_{z} \\pi}{L_{z}} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "While wave-based models are ideal for low frequencies, they become computationally expensive for higher frequencies, where geometric acoustics offers an efficient alternative. The Image Source Method (ISM) is a cornerstone of this approach, elegantly modeling specular reflections by replacing them with virtual sound sources. This hands-on coding exercise  challenges you to implement the core of the ISM algorithm, calculating the timings and amplitudes of reflections in a rectangular room.",
            "id": "4135936",
            "problem": "You are given a three-dimensional rectangular room characterized by its dimensions $(L_x,L_y,L_z)$, a source position $\\mathbf{r}_s=(x_s,y_s,z_s)$, a receiver position $\\mathbf{r}=(x_r,y_r,z_r)$, the speed of sound $c$ in meters per second, and a maximum path length $D_{\\max}$ in meters. Assume perfectly rigid walls, meaning the Acoustic Boundary Condition (ABC) on all walls is the Neumann boundary condition that the normal derivative of the acoustic pressure vanishes. Under this assumption, the Image Source Method (ISM) models specular reflections by replacing each reflection with a virtual source (an image source) located at positions generated by reflections in each axis.\n\nFrom the three-dimensional wave equation and the corresponding free-space Green’s function, the impulse response contribution of a single point source in an unbounded medium is supported on the sphere defined by $t=d/c$, where $d$ is the Euclidean distance to the source, and its geometric spreading amplitude scales as $1/(4\\pi d)$. For rigid walls, the pressure reflection coefficient is one in magnitude, so the geometric attenuation of a reflected path equals that of the corresponding image source with no additional magnitude scaling from the reflections.\n\nLet the image source positions be indexed by integers $(m,n,p)\\in\\mathbb{Z}^3$, with each coordinate given by\n$$\nx_{m} = 2 m L_x + (-1)^m x_s,\\quad\ny_{n} = 2 n L_y + (-1)^n y_s,\\quad\nz_{p} = 2 p L_z + (-1)^p z_s,\n$$\nso that $\\mathbf{r}_{mnp} = (x_m,y_n,z_p)$. For each image source, define the path length\n$$\nd_{mnp} = \\left\\|\\mathbf{r}-\\mathbf{r}_{mnp}\\right\\|_2,\n$$\nthe delay\n$$\n\\tau_{mnp} = \\frac{d_{mnp}}{c},\n$$\nand the geometric attenuation\n$$\nA_{mnp} = \\frac{1}{4\\pi d_{mnp}}.\n$$\nYour task is to enumerate all image sources with $d_{mnp}\\leq D_{\\max}$, compute $\\tau_{mnp}$ in seconds and $A_{mnp}$ in $\\mathrm{m}^{-1}$, and output the results sorted by ascending $\\tau_{mnp}$.\n\nYour program must implement the enumeration efficiently by bounding the integer indices $(m,n,p)$ using the requirement that $|x_m-x_r|\\leq D_{\\max}$, $|y_n-y_r|\\leq D_{\\max}$, and $|z_p-z_r|\\leq D_{\\max}$. The enumeration must be exact; do not approximate or truncate within these bounds. Always include the direct path corresponding to $(m,n,p)=(0,0,0)$ when it satisfies $d_{000}\\leq D_{\\max}$.\n\nAll physical quantities must be handled in International System of Units (SI), specifically:\n- Distances in meters.\n- Speed of sound in meters per second.\n- Delays in seconds.\n- Geometric attenuation in inverse meters, $\\mathrm{m}^{-1}$.\n\nYour program must produce a single line of output containing the results from all test cases, formatted as a string representation of a list of lists. Each inner list corresponds to one test case and contains the computed `[delay, attenuation]` pairs, rounded to six decimal places and sorted by ascending delay. For example: `[[[...], [...]], [[...]], [], [[...]]]`\n\nRound all delays $\\tau_{mnp}$ and attenuations $A_{mnp}$ to six decimal places in the final output.\n\nUse the speed of sound $c=343.0$ meters per second unless specified otherwise in the test case.\n\nTest Suite (each tuple is $(L_x,L_y,L_z,\\;x_s,y_s,z_s,\\;x_r,y_r,z_r,\\;D_{\\max},\\;c)$):\n1. Happy path: $(7.0,6.0,3.0,\\;1.2,2.0,1.0,\\;5.1,4.5,1.4,\\;12.0,\\;343.0)$.\n2. Boundary equality on direct path: $(10.0,8.0,3.0,\\;2.0,3.0,1.5,\\;8.0,3.0,1.5,\\;6.0,\\;343.0)$.\n3. Receiver and source near a wall: $(4.0,3.0,2.5,\\;0.2,1.0,0.6,\\;0.3,2.1,1.2,\\;3.0,\\;343.0)$.\n4. No images within range (empty result expected): $(6.0,5.0,3.0,\\;0.5,0.5,0.5,\\;5.5,4.5,2.5,\\;1.0,\\;343.0)$.",
            "solution": "The user has provided a computational acoustics problem requiring the implementation of the Image Source Method (ISM) for a rectangular room. The solution must enumerate all acoustic paths from a source to a receiver, including direct and reflected paths, that do not exceed a maximum path length.\n\n### Step 1: Problem Validation\n\nThe problem is subjected to a rigorous validation process before a solution is attempted.\n\n#### Step 1.1: Extract Givens\n\nThe following information is provided in the problem statement:\n- **Room Dimensions**: A three-dimensional rectangular room with dimensions $(L_x, L_y, L_z)$.\n- **Source Position**: $\\mathbf{r}_s = (x_s, y_s, z_s)$.\n- **Receiver Position**: $\\mathbf{r} = (x_r, y_r, z_r)$.\n- **Speed of Sound**: $c$, in meters per second.\n- **Maximum Path Length**: $D_{\\max}$, in meters.\n- **Boundary Conditions**: Perfectly rigid walls (Neumann boundary condition), implying a pressure reflection coefficient of $1$.\n- **Image Source Position Formulae**: For an integer index vector $(m, n, p) \\in \\mathbb{Z}^3$, the coordinates of the image source $\\mathbf{r}_{mnp} = (x_m, y_n, z_p)$ are given by:\n  $$x_{m} = 2 m L_x + (-1)^m x_s$$\n  $$y_{n} = 2 n L_y + (-1)^n y_s$$\n  $$z_{p} = 2 p L_z + (-1)^p z_s$$\n- **Path Length Calculation**: The Euclidean distance from an image source to the receiver is $d_{mnp} = \\left\\|\\mathbf{r}-\\mathbf{r}_{mnp}\\right\\|_2$.\n- **Delay Calculation**: The propagation delay is $\\tau_{mnp} = d_{mnp} / c$.\n- **Attenuation Calculation**: The geometric attenuation is $A_{mnp} = \\frac{1}{4\\pi d_{mnp}}$.\n- **Primary Constraint**: Only image sources for which $d_{mnp} \\leq D_{\\max}$ are to be considered.\n- **Enumeration Bounding**: The search for valid integer indices $(m,n,p)$ can be bounded by the necessary conditions $|x_m - x_r| \\leq D_{\\max}$, $|y_n - y_r| \\leq D_{\\max}$, and $|z_p - z_r| \\leq D_{\\max}$.\n- **Output Requirements**: For each test case, produce a list of pairs $[\\tau_{mnp}, A_{mnp}]$, sorted by ascending $\\tau_{mnp}$, with values rounded to six decimal places. The final output aggregates results from all test cases into a single list.\n- **Default Constant**: The speed of sound is $c = 343.0 \\, \\mathrm{m/s}$ unless specified otherwise.\n- **Test Suite**: A set of four test cases is provided to validate the implementation.\n\n#### Step 1.2: Validate Using Extracted Givens\n\nThe problem is assessed based on the predefined criteria:\n\n- **Scientifically Grounded**: The Image Source Method is a fundamental and widely used technique in room acoustics for modeling specular reflections in rectangular geometries. The provided equations for image source positions, path length, delay, and attenuation are standard and correct for the idealized case of perfectly rigid walls. The underlying physical principles (wave propagation, geometric spreading) are sound.\n- **Well-Posed**: The problem is well-defined. For a given set of input parameters, the process of enumerating image sources, applying a filter ($d_{mnp} \\leq D_{\\max}$), and computing the associated physical quantities is deterministic. The provided bounding strategy ensures that the search space is finite, guaranteeing that a unique and computable solution exists.\n- **Objective**: The problem is formulated using precise mathematical expressions and objective physical quantities. It is free from ambiguity, subjectivity, or opinion-based statements.\n\nThe problem does not exhibit any of the listed invalidity flaws. It is scientifically sound, formalizable, complete, and poses a non-trivial but solvable computational task.\n\n#### Step 1.3: Verdict and Action\n\nThe problem statement is **valid**. A solution will be developed and implemented.\n\n### Step 2: Solution Design\n\nThe core of the problem is to devise an algorithm that efficiently enumerates all image sources satisfying the path length constraint.\n\n#### Algorithmic Principles\n\nThe Image Source Method models reflections by creating virtual copies of the sound source, mirrored across the room's boundaries. For a rectangular room, this process generates an infinite lattice of image sources. The task is to find all such sources from which the path length to the receiver does not exceed $D_{\\max}$.\n\nA brute-force search over all integers $(m,n,p) \\in \\mathbb{Z}^3$ is computationally infeasible. A more efficient approach, as suggested by the problem, is to establish finite bounds on the indices $m$, $n$, and $p$.\n\n#### Bounding the Search Space\n\nThe primary constraint is $d_{mnp}^2 = (x_m - x_r)^2 + (y_n - y_r)^2 + (z_p - z_r)^2 \\leq D_{\\max}^2$. This implies that each squared term must also be less than or equal to $D_{\\max}^2$. For the x-coordinate, this gives the necessary (but not sufficient) condition:\n$$|x_m - x_r| \\leq D_{\\max}$$\nSubstituting the definition of $x_m$:\n$$|2 m L_x + (-1)^m x_s - x_r| \\leq D_{\\max}$$\nTo find a simple, conservative integer range for $m$, we can use the triangle inequality, $|a+b| \\ge |a|-|b|$:\n$$|2 m L_x + ((-1)^m x_s - x_r)| \\ge |2 m L_x| - |(-1)^m x_s - x_r|$$\nTherefore, the condition requires:\n$$|2 m L_x| - |(-1)^m x_s - x_r| \\leq D_{\\max}$$\n$$|2m|L_x \\leq D_{\\max} + |(-1)^m x_s - x_r|$$\nSince $0 \\leq x_s \\leq L_x$ and $0 \\leq x_r \\leq L_x$, the term $|(-1)^m x_s - x_r|$ is bounded. For instance, $|(-1)^m x_s - x_r| \\leq |x_s| + |x_r| \\le L_x + L_x = 2L_x$. Using this rough bound:\n$$|2m|L_x \\leq D_{\\max} + 2L_x$$\n$$|m| \\leq \\frac{D_{\\max}}{2L_x} + 1$$\nThis yields a symmetric and conservative range for the index $m$: $m \\in [-\\lfloor \\frac{D_{\\max}}{2L_x} + 1 \\rfloor, \\lfloor \\frac{D_{\\max}}{2L_x} + 1 \\rfloor]$. This range guarantees that no valid image source is missed. Analogous bounds are derived for indices $n$ and $p$:\n- $m_{lim} = \\lfloor D_{\\max} / (2L_x) + 1 \\rfloor$\n- $n_{lim} = \\lfloor D_{\\max} / (2L_y) + 1 \\rfloor$\n- $p_{lim} = \\lfloor D_{\\max} / (2L_z) + 1 \\rfloor$\n\nThe algorithm will iterate through all integer triplets $(m,n,p)$ within the Cartesian product of the ranges $[-m_{lim}, m_{lim}]$, $[-n_{lim}, n_{lim}]$, and $[-p_{lim}, p_{lim}]$.\n\n#### Algorithm Outline\n\n1.  For each test case, parse the input parameters: $(L_x, L_y, L_z)$, $\\mathbf{r}_s=(x_s, y_s, z_s)$, $\\mathbf{r}=(x_r, y_r, z_r)$, $D_{\\max}$, and $c$.\n\n2.  Calculate the integer index limits $m_{lim}$, $n_{lim}$, and $p_{lim}$ as described above.\n\n3.  Initialize an empty list, `image_contributions`, to store the valid $[\\tau, A]$ pairs.\n\n4.  Execute three nested loops for $m \\in [-m_{lim}, m_{lim}]$, $n \\in [-n_{lim}, n_{lim}]$, and $p \\in [-p_{lim}, p_{lim}]$.\n\n5.  Inside the innermost loop, for each index triplet $(m,n,p)$:\n    a. Compute the image source position $\\mathbf{r}_{mnp}=(x_m, y_n, z_p)$ using the given formulae.\n    b. Calculate the distance vector $\\mathbf{d} = \\mathbf{r} - \\mathbf{r}_{mnp}$.\n    c. Compute the scalar path length $d_{mnp} = \\|\\mathbf{d}\\|_2$.\n    d. If $d_{mnp} \\leq D_{\\max}$:\n        i. Check that $d_{mnp} > 0$ to prevent division by zero. The problem setup makes $d_{mnp}=0$ extremely unlikely, but it is a necessary check for robustness.\n        ii. Calculate the delay: $\\tau_{mnp} = d_{mnp} / c$.\n        iii. Calculate the attenuation: $A_{mnp} = 1 / (4 \\pi d_{mnp})$.\n        iv. Append the pair $[\\tau_{mnp}, A_{mnp}]$ to the `image_contributions` list.\n\n6.  After the loops complete, sort the `image_contributions` list in ascending order based on the first element of each pair (the delay, $\\tau$).\n\n7.  Create a new list by iterating through the sorted `image_contributions`, rounding each $\\tau$ and $A$ value to six decimal places as required.\n\n8.  Store the resulting list of rounded pairs. This list represents the solution for one test case.\n\n9.  After processing all test cases, aggregate the results into a final list and format it into the specified string representation for the final output.\n\nThis systematic procedure ensures all constraints of the problem are met, providing an exact enumeration within the derived bounds, and producing the output in the specified sorted and formatted manner.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Image Source Method (ISM) to find all acoustic paths within a maximum length\n    for a rectangular room with rigid walls.\n    \"\"\"\n\n    # Test Suite provided in the problem statement.\n    # Format: (Lx, Ly, Lz, xs, ys, zs, xr, yr, zr, D_max, c)\n    test_cases = [\n        (7.0, 6.0, 3.0, 1.2, 2.0, 1.0, 5.1, 4.5, 1.4, 12.0, 343.0),\n        (10.0, 8.0, 3.0, 2.0, 3.0, 1.5, 8.0, 3.0, 1.5, 6.0, 343.0),\n        (4.0, 3.0, 2.5, 0.2, 1.0, 0.6, 0.3, 2.1, 1.2, 3.0, 343.0),\n        (6.0, 5.0, 3.0, 0.5, 0.5, 0.5, 5.5, 4.5, 2.5, 1.0, 343.0),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        Lx, Ly, Lz, xs, ys, zs, xr, yr, zr, D_max, c = case\n        \n        r_s = np.array([xs, ys, zs])\n        r_r = np.array([xr, yr, zr])\n        L = np.array([Lx, Ly, Lz])\n\n        # Calculate conservative bounds for the integer indices m, n, p.\n        # This is based on |m| <= D_max / (2*L) + 1.\n        m_lim = int(np.floor(D_max / (2 * Lx) + 1))\n        n_lim = int(np.floor(D_max / (2 * Ly) + 1))\n        p_lim = int(np.floor(D_max / (2 * Lz) + 1))\n\n        image_contributions = []\n\n        for m_idx in range(-m_lim, m_lim + 1):\n            for n_idx in range(-n_lim, n_lim + 1):\n                for p_idx in range(-p_lim, p_lim + 1):\n                    # Compute the position of the image source r_mnp\n                    \n                    # x_m = 2*m*Lx + (-1)^m * xs\n                    x_m = 2 * m_idx * Lx + ((-1)**m_idx) * xs\n                    # y_n = 2*n*Ly + (-1)^n * ys\n                    y_n = 2 * n_idx * Ly + ((-1)**n_idx) * ys\n                    # z_p = 2*p*Lz + (-1)^p * zs\n                    z_p = 2 * p_idx * Lz + ((-1)**p_idx) * zs\n\n                    r_mnp = np.array([x_m, y_n, z_p])\n                    \n                    # Calculate distance d_mnp = ||r_r - r_mnp||\n                    d_mnp = np.linalg.norm(r_r - r_mnp)\n\n                    # Check if the path length is within the maximum allowed distance\n                    if d_mnp <= D_max:\n                        # Ensure distance is non-zero to avoid division by zero\n                        if d_mnp > 1e-9: # Using a small epsilon for floating point safety\n                            # Calculate delay tau = d/c\n                            tau_mnp = d_mnp / c\n                            # Calculate geometric attenuation A = 1/(4*pi*d)\n                            A_mnp = 1.0 / (4.0 * np.pi * d_mnp)\n                            image_contributions.append([tau_mnp, A_mnp])\n        \n        # Sort contributions by ascending delay (tau)\n        image_contributions.sort(key=lambda x: x[0])\n        \n        # Round the results to 6 decimal places\n        rounded_results = [[round(tau, 6), round(A, 6)] for tau, A in image_contributions]\n        \n        all_results.append(rounded_results)\n\n    # Format the final output string to match the problem specification\n    # [[...],[...],...] without spaces.\n    results_str = str(all_results).replace(\" \", \"\")\n    print(results_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Acoustic models, whether wave-based or geometric, often produce results in continuous time, such as the precise arrival times of reflections from the Image Source Method. To use these models in a digital simulation or for auralization, we must convert them into a discrete-time signal, a process that presents a significant challenge: arrival times rarely align perfectly with the digital sampling grid. This practice  tackles this crucial implementation detail head-on, asking you to implement a fractional delay filter using Lagrange interpolation and quantify its performance, a key skill for any high-fidelity acoustic simulation.",
            "id": "4135901",
            "problem": "Given a rectangular room scenario modeled by the image source method, the continuous-time acoustic impulse response at a receiver due to a set of arrivals is a sum of delayed Dirac impulses. Let the sample rate be $f_s$ (in $\\mathrm{Hz}$) and the arrival times be the set $\\{t_n\\}_{n=1}^N$ (in $\\mathrm{s}$). Assume unit amplitude for all arrivals so that the continuous-time impulse response is $h_\\mathrm{c}(t) = \\sum_{n=1}^N \\delta(t - t_n)$. When discretized, the desired discrete-time impulse response is a sequence $h[k]$ constructed to approximate the delayed impulses at non-integer sample indices. Use order-$M$ polynomial Lagrange interpolation to realize fractional sample delays: for each delay $t_n$, with $d_n = f_s t_n$ measured in samples, write $d_n = p_n + \\mu_n$ where $p_n \\in \\mathbb{Z}$ is the integer part and $\\mu_n \\in [0,1)$ is the fractional part. The order-$M$ interpolation produces a finite impulse response supported on $M+1$ consecutive samples that approximates the fractional delay $\\mu_n$ around the integer index $p_n$.\n\nStarting from the linear wave equation and its Green’s function solution for room acoustics, justify the discrete-time representation as a sum of delayed impulses and derive how order-$M$ Lagrange interpolation approximates a fractional delay. Then, define the frequency response of the discretized impulse response $H_\\mathrm{approx}(f) = \\sum_{k=0}^{L-1} h[k] e^{-j 2 \\pi f k / f_s}$ and the ideal continuous-time frequency response $H_\\mathrm{ideal}(f) = \\sum_{n=1}^N e^{-j 2 \\pi f t_n}$. The approximation error as a function of interpolation order and frequency is\n$$\nE_M(f) = \\left| \\, \\left|H_\\mathrm{approx}(f)\\right| - \\left|H_\\mathrm{ideal}(f)\\right| \\, \\right|.\n$$\nHere, all angles are measured in radians. You must compute $h[k]$ using order-$M$ Lagrange interpolation, evaluate $H_\\mathrm{approx}(f)$ and $H_\\mathrm{ideal}(f)$ on specified frequency grids, and report the maximum magnitude error over each grid.\n\nImplement a complete, runnable program that:\n- Constructs $h[k]$ for the provided $f_s$, $\\{t_n\\}$, and interpolation order $M$.\n- Evaluates $H_\\mathrm{approx}(f)$ and $H_\\mathrm{ideal}(f)$ at each frequency in the test suite.\n- Computes, for each test case, the scalar metric $\\max_{f \\in \\mathcal{F}} E_M(f)$, where $\\mathcal{F}$ is the provided frequency set of the test case.\n- Produces a single line of output containing the results as a comma-separated list enclosed in square brackets.\n\nAll physical units must be respected: use $f_s$ in $\\mathrm{Hz}$, delays $t_n$ in $\\mathrm{s}$, and frequencies $f$ in $\\mathrm{Hz}$. Angles must be in radians. The final outputs are dimensionless real numbers.\n\nTest Suite:\n- Case $1$ (general case): $f_s = 48000$, $\\{t_n\\} = \\{0.007123, 0.012345\\}$, $M = 3$, frequency set $\\mathcal{F} = \\{0, 1000, 5000, 10000, 15000, 20000\\}$.\n- Case $2$ (boundary: nearest-neighbor interpolation): $f_s = 48000$, $\\{t_n\\} = \\{0.0034\\}$, $M = 0$, frequency set $\\mathcal{F} = \\{0, 5000, 10000, 20000, 23000\\}$.\n- Case $3$ (edge: high order and near-integer fractional delays): $f_s = 44100$, $\\{t_n\\} = \\{(100.999)/f_s, (257.1)/f_s\\}$, $M = 10$, frequency set $\\mathcal{F} = \\{0, 1000, 5000, 10000, 15000, 20000\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3]$), where $r_i$ is $\\max_{f \\in \\mathcal{F}} E_M(f)$ for Case $i$, expressed as a decimal number.",
            "solution": "The problem requires the formulation and implementation of a procedure to quantify the error introduced by discretizing a continuous-time acoustic impulse response using polynomial-based fractional delay filtering. The impulse response is modeled as a sum of delayed Dirac impulses, a representation justified by the image source method in room acoustics.\n\n### Part 1: From the Wave Equation to a Sum of Delayed Impulses\n\nThe propagation of sound in a fluid medium like air is governed by the linear acoustic wave equation. For the acoustic pressure field $p(\\mathbf{r}, t)$ at position $\\mathbf{r}$ and time $t$, this equation is:\n$$\n\\nabla^2 p(\\mathbf{r}, t) - \\frac{1}{c^2} \\frac{\\partial^2 p(\\mathbf{r}, t)}{\\partial t^2} = -S(\\mathbf{r}, t)\n$$\nwhere $c$ is the speed of sound and $S(\\mathbf{r}, t)$ is a source term. For an idealized point source at $\\mathbf{r}_s$ emitting an impulse at time $t=0$, the source term is $S(\\mathbf{r}, t) = \\delta(\\mathbf{r} - \\mathbf{r}_s) \\delta(t)$.\n\nThe solution to this equation in an unbounded, free-field medium is the Green's function, which represents a spherically expanding wave:\n$$\ng(\\mathbf{r}, t | \\mathbf{r}_s, 0) = \\frac{1}{4\\pi ||\\mathbf{r} - \\mathbf{r}_s||} \\delta\\left(t - \\frac{||\\mathbf{r} - \\mathbf{r}_s||}{c}\\right)\n$$\nThis solution is a Dirac impulse, delayed by the travel time $t_d = ||\\mathbf{r} - \\mathbf{r}_s||/c$, with its amplitude attenuated by the spherical spreading factor $1/(4\\pi ||\\mathbf{r} - \\mathbf{r}_s||)$.\n\nIn a reverberant environment, such as a rectangular room with acoustically hard (perfectly reflecting) walls, the sound field at a receiver location $\\mathbf{r}_r$ is the superposition of the direct sound from the source and a series of reflections from the walls. The image source method provides an elegant way to solve for this field. The boundary conditions imposed by the walls are satisfied by constructing a lattice of \"image\" sources, which are reflections of the physical source across the room boundaries.\n\nEach image source, indexed by $n$, acts as a source in free space, contributing a delayed and attenuated impulse to the pressure at the receiver. The total acoustic impulse response at the receiver, $h_c(t)$, is the sum of these contributions:\n$$\nh_c(t) = \\sum_{n=0}^{\\infty} A_n \\delta(t - t_n)\n$$\nHere, $t_n$ is the propagation time from the $n$-th image source to the receiver, and $A_n$ is the corresponding attenuation factor, which accounts for spherical spreading and the reflection coefficients of the walls.\n\nThe problem statement simplifies this model by assuming there is a finite number $N$ of significant arrivals and that all arrivals have unit amplitude ($A_n=1$ for all $n$). This leads directly to the given continuous-time impulse response model:\n$$\nh_c(t) = \\sum_{n=1}^N \\delta(t - t_n)\n$$\nThis justifies the representation of the room impulse response as a sum of delayed Dirac impulses.\n\n### Part 2: Discretization via Lagrange Interpolation\n\nTo process the continuous-time signal $h_c(t)$ with digital systems, it must be sampled at a rate $f_s$, with sampling period $T_s = 1/f_s$. A naive sampling procedure, $h[k] = h_c(k T_s)$, would miss any impulse whose arrival time $t_n$ is not an integer multiple of $T_s$.\n\nThe total delay in samples for an arrival at time $t_n$ is $d_n = t_n / T_s = f_s t_n$. In general, $d_n$ is a non-integer value. We can decompose it into an integer part $p_n = \\lfloor d_n \\rfloor$ and a fractional part $\\mu_n = d_n - p_n$, where $\\mu_n \\in [0, 1)$. The task of correctly representing this non-integer delay in the discrete-time domain is known as fractional delay filtering.\n\nThe ideal fractional delay filter has a non-causal, infinite-length impulse response (a shifted sinc function), making it impractical. Therefore, a finite-length impulse response (FIR) approximation is required. Lagrange interpolation provides a method to construct such an FIR filter.\n\nAn order-$M$ Lagrange interpolator constructs a unique polynomial of degree at most $M$ that passes through $M+1$ given points. To design an FIR filter that approximates a fractional delay $\\mu_n$, we can use the Lagrange basis polynomials. For a causal filter of length $M+1$ that interpolates over the integer sample indices $\\{0, 1, \\dots, M\\}$, the filter coefficient at index $\\ell \\in \\{0, 1, \\dots, M\\}$ is given by:\n$$\nh_{\\mu_n, M}[\\ell] = \\prod_{i=0, i \\neq \\ell}^{M} \\frac{\\mu_n - i}{\\ell - i}\n$$\nThese coefficients, $h_{\\mu_n, M}[\\ell]$, form the FIR filter that approximates the fractional delay part $\\mu_n$. The integer delay part $p_n$ is implemented by shifting the position of this FIR filter along the time axis.\n\n### Part 3: Algorithm for Impulse Response Construction\n\nThe complete discrete-time impulse response $h[k]$ is constructed by superimposing the individual FIR filters for each arrival.\n\n1.  **Determine Impulse Response Length**: The latest arrival time $t_{\\max} = \\max_n\\{t_n\\}$ determines the required length of the discrete impulse response array. The maximum sample delay is $d_{\\max} = f_s t_{\\max}$. The filter for this arrival will have its last non-zero coefficient at index $\\lfloor d_{\\max} \\rfloor + M$. Thus, the total length required is $L = \\lfloor d_{\\max} \\rfloor + M + 1$. An array $h[k]$ of length $L$ is initialized to all zeros.\n\n2.  **Superimpose Arrival Filters**: For each arrival time $t_n$ in the set $\\{t_n\\}_{n=1}^N$:\n    a. Calculate the total delay in samples: $d_n = f_s t_n$.\n    b. Decompose the delay into its integer and fractional parts: $p_n = \\lfloor d_n \\rfloor$ and $\\mu_n = d_n - p_n$.\n    c. For each index $\\ell$ from $0$ to $M$:\n        i.  Calculate the Lagrange interpolation coefficient: $c_\\ell = \\prod_{i=0, i \\neq \\ell}^{M} (\\mu_n - i) / (\\ell - i)$.\n        ii. Add this coefficient to the total impulse response at the appropriate sample index: $h[p_n + \\ell] \\leftarrow h[p_n + \\ell] + c_\\ell$.\n\nThe resulting array $h[k]$ is the discretized representation of the room impulse response $h_c(t)$.\n\n### Part 4: Frequency-Domain Error Calculation\n\nTo evaluate the quality of the approximation, we compare the magnitude of the frequency response of the discrete-time filter, $H_\\mathrm{approx}(f)$, with that of the ideal continuous-time response, $H_\\mathrm{ideal}(f)$.\n\n1.  **Approximate Frequency Response**: For a given frequency $f$, $H_\\mathrm{approx}(f)$ is computed via the Discrete-Time Fourier Transform (DTFT) of $h[k]$:\n    $$\n    H_\\mathrm{approx}(f) = \\sum_{k=0}^{L-1} h[k] e^{-j 2 \\pi f k / f_s}\n    $$\n    where $j = \\sqrt{-1}$.\n\n2.  **Ideal Frequency Response**: The Fourier transform of the ideal continuous-time response $h_c(t) = \\sum_{n=1}^N \\delta(t - t_n)$ is:\n    $$\n    H_\\mathrm{ideal}(f) = \\mathcal{F}\\{h_c(t)\\} = \\sum_{n=1}^N e^{-j 2 \\pi f t_n}\n    $$\n\n3.  **Error Metric**: The error at a given frequency $f$ is defined as the absolute difference between the magnitude responses:\n    $$\n    E_M(f) = \\left| \\, \\left|H_\\mathrm{approx}(f)\\right| - \\left|H_\\mathrm{ideal}(f)\\right| \\, \\right|\n    $$\nThe final metric for each test case is the maximum value of this error over the specified set of frequencies $\\mathcal{F}$:\n$$\n\\max_{f \\in \\mathcal{F}} E_M(f)\n$$\n\nThis procedure provides a quantitative measure of how well the Lagrange-based fractional delay filter of order $M$ preserves the magnitude spectrum of the ideal signal.",
            "answer": "```python\nimport numpy as np\n\ndef lagrange_coeffs(mu, M):\n    \"\"\"\n    Computes the coefficients of an order-M Lagrange interpolation FIR filter\n    for a fractional delay mu.\n    \"\"\"\n    if M == 0:\n        # Nearest neighbor interpolation\n        # The filter is just a delta at the nearest integer sample.\n        # This implementation places it at the floor index, which is causal.\n        return np.array([1.0])\n    \n    ell = np.arange(M + 1)\n    coeffs = np.zeros(M + 1)\n    \n    for l_idx, l_val in enumerate(ell):\n        numerator = 1.0\n        denominator = 1.0\n        for i_val in ell:\n            if i_val != l_val:\n                numerator *= mu - i_val\n                denominator *= l_val - i_val\n        coeffs[l_idx] = numerator / denominator\n        \n    return coeffs\n\ndef calculate_max_error(fs, t_n_list, M, F_list):\n    \"\"\"\n    Calculates the maximum approximation error over a set of frequencies.\n    \"\"\"\n    if not t_n_list:\n        return 0.0\n\n    # Step 1: Construct the discrete-time impulse response h[k]\n    t_n_array = np.array(t_n_list)\n    d_max = fs * np.max(t_n_array)\n    p_max = int(np.floor(d_max))\n    L = p_max + M + 1\n    h = np.zeros(L, dtype=np.float64)\n\n    for t_n in t_n_array:\n        d_n = fs * t_n\n        p_n = int(np.floor(d_n))\n        mu_n = d_n - p_n\n        \n        coeffs = lagrange_coeffs(mu_n, M)\n        \n        start_idx = p_n\n        end_idx = p_n + M + 1\n        if end_idx <= L:\n            h[start_idx:end_idx] += coeffs\n\n    # Step 2: Calculate error for each frequency in F_list\n    max_error = 0.0\n    k_vec = np.arange(L)\n    \n    for f in F_list:\n        # Calculate approximate frequency response\n        exp_vec_approx = np.exp(-1j * 2 * np.pi * f * k_vec / fs)\n        H_approx = np.sum(h * exp_vec_approx)\n\n        # Calculate ideal frequency response\n        exp_vec_ideal = np.exp(-1j * 2 * np.pi * f * t_n_array)\n        H_ideal = np.sum(exp_vec_ideal)\n        \n        # Calculate error\n        error = np.abs(np.abs(H_approx) - np.abs(H_ideal))\n        if error > max_error:\n            max_error = error\n            \n    return max_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"fs\": 48000,\n            \"t_n\": [0.007123, 0.012345],\n            \"M\": 3,\n            \"F\": [0, 1000, 5000, 10000, 15000, 20000],\n        },\n        {\n            \"fs\": 48000,\n            \"t_n\": [0.0034],\n            \"M\": 0,\n            \"F\": [0, 5000, 10000, 20000, 23000],\n        },\n        {\n            \"fs\": 44100,\n            \"t_n\": [100.999 / 44100, 257.1 / 44100],\n            \"M\": 10,\n            \"F\": [0, 1000, 5000, 10000, 15000, 20000],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        fs = case[\"fs\"]\n        t_n_list = case[\"t_n\"]\n        M = case[\"M\"]\n        F_list = case[\"F\"]\n        \n        max_err = calculate_max_error(fs, t_n_list, M, F_list)\n        results.append(f\"{max_err:.10f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}