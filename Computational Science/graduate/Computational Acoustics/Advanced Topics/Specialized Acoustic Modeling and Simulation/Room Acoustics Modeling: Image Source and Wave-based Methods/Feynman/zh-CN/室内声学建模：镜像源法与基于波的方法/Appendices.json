{
    "hands_on_practices": [
        {
            "introduction": "本次练习是计算房间声学领域的一项基础实践。我们将为一个简单的矩形房间实现经典的镜像声源法（Image Source Method, ISM），该方法是许多几何声学模型的基石。通过这项练习 ，你将巩固对镜面反射建模方式的理解，并学会如何计算延迟和几何衰减等基本声学参数。",
            "id": "4135936",
            "problem": "给定一个三维矩形房间，其尺寸为 $(L_x,L_y,L_z)$，一个声源位置 $\\mathbf{r}_s=(x_s,y_s,z_s)$，一个接收器位置 $\\mathbf{r}=(x_r,y_r,z_r)$，声速 $c$（单位为米/秒），以及最大路径长度 $D_{\\max}$（单位为米）。假设墙壁是完美刚性的，这意味着所有墙壁上的声学边界条件（Acoustic Boundary Condition, ABC）是 Neumann 边界条件，即声压的法向导数为零。在此假设下，镜像声源法（Image Source Method, ISM）通过将每次反射替换为一个虚拟声源（即镜像声源）来模拟镜面反射，这些虚拟声源的位置是通过在各个轴上的反射生成的。\n\n根据三维波动方程和相应的自由空间 Green 函数，无界介质中单个点声源的脉冲响应贡献分布在由 $t=d/c$ 定义的球面上，其中 $d$ 是到声源的欧几里得距离，其几何扩散振幅按 $1/(4\\pi d)$ 的比例缩放。对于刚性墙壁，声压反射系数的模为1，因此反射路径的几何衰减等于相应镜像声源的几何衰减，没有因反射而产生的额外幅度缩放。\n\n设镜像声源位置由整数 $(m,n,p)\\in\\mathbb{Z}^3$ 索引，每个坐标由以下公式给出\n$$\n\\begin{aligned}\nx_{m} &= 2 m L_x + (-1)^m x_s, \\\\\ny_{n} &= 2 n L_y + (-1)^n y_s, \\\\\nz_{p} &= 2 p L_z + (-1)^p z_s,\n\\end{aligned}\n$$\n使得 $\\mathbf{r}_{mnp} = (x_m,y_n,z_p)$。对于每个镜像声源，定义路径长度\n$$\nd_{mnp} = \\left\\|\\mathbf{r}-\\mathbf{r}_{mnp}\\right\\|_2,\n$$\n延迟\n$$\n\\tau_{mnp} = \\frac{d_{mnp}}{c},\n$$\n以及几何衰减\n$$\nA_{mnp} = \\frac{1}{4\\pi d_{mnp}}.\n$$\n你的任务是枚举所有满足 $d_{mnp}\\leq D_{\\max}$ 的镜像声源，计算 $\\tau_{mnp}$（单位为秒）和 $A_{mnp}$（单位为 $\\mathrm{m}^{-1}$），并按 $\\tau_{mnp}$ 升序排列输出结果。\n\n你的程序必须通过使用 $|x_m-x_r|\\leq D_{\\max}$、$|y_n-y_r|\\leq D_{\\max}$ 和 $|z_p-z_r|\\leq D_{\\max}$ 的要求来限制整数索引 $(m,n,p)$ 的范围，从而高效地实现枚举。枚举必须是精确的；在这些边界内不要进行近似或截断。当直达路径满足 $d_{000}\\leq D_{\\max}$ 时，必须始终包含对应的 $(m,n,p)=(0,0,0)$。\n\n所有物理量必须使用国际单位制（SI）处理，具体如下：\n- 距离单位为米。\n- 声速单位为米/秒。\n- 延迟单位为秒。\n- 几何衰减单位为反米，$\\mathrm{m}^{-1}$。\n\n在最终输出中，将所有延迟 $\\tau_{mnp}$ 和衰减 $A_{mnp}$ 四舍五入到六位小数。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个 $[\\tau_{mnp},A_{mnp}]$ 对的列表，同样用方括号括起来，并按 $\\tau_{mnp}$ 升序排序。因此，最终的输出格式为：\n$$\n[\\,[\\,[\\tau_1,A_1],\\ldots],\\;[\\,[\\tau_1,A_1],\\ldots],\\;\\ldots\\,]\n$$\n其中最外层的列表汇集了所有给定测试用例的结果。\n\n除非测试用例中另有规定，否则使用声速 $c=343.0$ 米/秒。\n\n测试套件（每个元组为 $(L_x,L_y,L_z,\\;x_s,y_s,z_s,\\;x_r,y_r,z_r,\\;D_{\\max},\\;c)$）：\n1. 正常路径：$(7.0,6.0,3.0,\\;1.2,2.0,1.0,\\;5.1,4.5,1.4,\\;12.0,\\;343.0)$。\n2. 直达路径上的边界等式：$(10.0,8.0,3.0,\\;2.0,3.0,1.5,\\;8.0,3.0,1.5,\\;6.0,\\;343.0)$。\n3. 接收器和声源靠近墙壁：$(4.0,3.0,2.5,\\;0.2,1.0,0.6,\\;0.3,2.1,1.2,\\;3.0,\\;343.0)$。\n4. 范围内无镜像（预期结果为空）：$(6.0,5.0,3.0,\\;0.5,0.5,0.5,\\;5.5,4.5,2.5,\\;1.0,\\;343.0)$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如， \"[[...],[...],[...],[...]]\"）。每个内部列表对应一个测试用例，并包含四舍五入到六位小数并按 $\\tau_{mnp}$ 升序排序的 $[\\tau_{mnp},A_{mnp}]$ 对。",
            "solution": "用户提供了一个计算声学问题，要求为一个矩形房间实现镜像声源法（ISM）。解决方案必须枚举从声源到接收器的所有声学路径（包括直达路径和反射路径），这些路径的长度不超过最大路径长度。\n\n### 步骤 1：问题验证\n\n在尝试解决问题之前，需对其进行严格的验证过程。\n\n#### 步骤 1.1：提取给定信息\n\n问题陈述中提供了以下信息：\n- **房间尺寸**：一个三维矩形房间，其尺寸为 $(L_x, L_y, L_z)$。\n- **声源位置**：$\\mathbf{r}_s = (x_s, y_s, z_s)$。\n- **接收器位置**：$\\mathbf{r} = (x_r, y_r, z_r)$。\n- **声速**：$c$，单位为米/秒。\n- **最大路径长度**：$D_{\\max}$，单位为米。\n- **边界条件**：完美刚性墙壁（Neumann 边界条件），意味着声压反射系数为 $1$。\n- **镜像声源位置公式**：对于整数索引向量 $(m, n, p) \\in \\mathbb{Z}^3$，镜像声源 $\\mathbf{r}_{mnp} = (x_m, y_n, z_p)$ 的坐标由以下公式给出：\n  $$x_{m} = 2 m L_x + (-1)^m x_s$$\n  $$y_{n} = 2 n L_y + (-1)^n y_s$$\n  $$z_{p} = 2 p L_z + (-1)^p z_s$$\n- **路径长度计算**：从镜像声源到接收器的欧几里得距离为 $d_{mnp} = \\left\\|\\mathbf{r}-\\mathbf{r}_{mnp}\\right\\|_2$。\n- **延迟计算**：传播延迟为 $\\tau_{mnp} = d_{mnp} / c$。\n- **衰减计算**：几何衰减为 $A_{mnp} = \\frac{1}{4\\pi d_{mnp}}$。\n- **主要约束**：只考虑满足 $d_{mnp} \\leq D_{\\max}$ 的镜像声源。\n- **枚举范围界定**：有效整数索引 $(m,n,p)$ 的搜索可以通过必要条件 $|x_m - x_r| \\leq D_{\\max}$、$|y_n - y_r| \\leq D_{\\max}$ 和 $|z_p - z_r| \\leq D_{\\max}$ 来界定范围。\n- **输出要求**：对于每个测试用例，生成一个 $[\\tau_{mnp}, A_{mnp}]$ 对的列表，按 $\\tau_{mnp}$ 升序排序，数值四舍五入到六位小数。最终输出将所有测试用例的结果聚合到一个列表中。\n- **默认常数**：除非另有说明，声速为 $c = 343.0 \\, \\mathrm{m/s}$。\n- **测试套件**：提供了一组四个测试用例以验证实现。\n\n#### 步骤 1.2：使用提取的给定信息进行验证\n\n根据预定义标准对问题进行评估：\n\n- **科学依据**：镜像声源法是室内声学中用于模拟矩形几何体内镜面反射的一种基础且广泛应用的技术。所提供的镜像声源位置、路径长度、延迟和衰减的方程对于完美刚性墙壁的理想化情况是标准且正确的。其基础物理原理（波的传播、几何扩散）是可靠的。\n- **适定性**：该问题是适定的。对于给定的输入参数集，枚举镜像声源、应用过滤器（$d_{mnp} \\leq D_{\\max}$）以及计算相关物理量的过程是确定性的。所提供的范围界定策略确保了搜索空间是有限的，从而保证存在唯一且可计算的解。\n- **客观性**：该问题使用精确的数学表达式和客观的物理量来表述。它没有歧义、主观性或基于观点的陈述。\n\n该问题没有表现出任何列出的无效性缺陷。它在科学上是可靠的，可形式化的，完整的，并且提出了一个非平凡但可解的计算任务。\n\n#### 步骤 1.3：结论与行动\n\n问题陈述是 **有效的**。将开发并实现一个解决方案。\n\n### 步骤 2：解决方案设计\n\n问题的核心是设计一种算法，以高效地枚举所有满足路径长度约束的镜像声源。\n\n#### 算法原理\n\n镜像声源法通过创建声源的虚拟副本（在房间边界上镜像）来模拟反射。对于矩形房间，此过程会生成一个无限的镜像声源晶格。任务是找到所有这些声源，其到接收器的路径长度不超过 $D_{\\max}$。\n\n对所有整数 $(m,n,p) \\in \\mathbb{Z}^3$ 进行暴力搜索在计算上是不可行的。正如问题所建议的，一种更高效的方法是为索引 $m$、$n$ 和 $p$ 建立有限的边界。\n\n#### 界定搜索空间\n\n主要约束是 $d_{mnp}^2 = (x_m - x_r)^2 + (y_n - y_r)^2 + (z_p - z_r)^2 \\leq D_{\\max}^2$。这意味着每个平方项也必须小于或等于 $D_{\\max}^2$。对于 x 坐标，这给出了必要（但不充分）条件：\n$$|x_m - x_r| \\leq D_{\\max}$$\n代入 $x_m$ 的定义：\n$$|2 m L_x + (-1)^m x_s - x_r| \\leq D_{\\max}$$\n为了找到一个简单、保守的 $m$ 的整数范围，我们可以使用三角不等式 $|a+b| \\ge |a|-|b|$：\n$$|2 m L_x + ((-1)^m x_s - x_r)| \\ge |2 m L_x| - |(-1)^m x_s - x_r|$$\n因此，该条件要求：\n$$|2 m L_x| - |(-1)^m x_s - x_r| \\leq D_{\\max}$$\n$$|2m|L_x \\leq D_{\\max} + |(-1)^m x_s - x_r|$$\n由于 $0 \\leq x_s \\leq L_x$ 且 $0 \\leq x_r \\leq L_x$，项 $|(-1)^m x_s - x_r|$ 是有界的。例如， $|(-1)^m x_s - x_r| \\leq |x_s| + |x_r| \\le L_x + L_x = 2L_x$。使用这个粗略的界限：\n$$|2m|L_x \\leq D_{\\max} + 2L_x$$\n$$|m| \\leq \\frac{D_{\\max}}{2L_x} + 1$$\n这为索引 $m$ 产生了一个对称且保守的范围：$m \\in [-\\lfloor \\frac{D_{\\max}}{2L_x} + 1 \\rfloor, \\lfloor \\frac{D_{\\max}}{2L_x} + 1 \\rfloor]$。这个范围保证了不会漏掉任何有效的镜像声源。索引 $n$ 和 $p$ 的类似边界也可以推导出：\n- $m_{lim} = \\lfloor D_{\\max} / (2L_x) + 1 \\rfloor$\n- $n_{lim} = \\lfloor D_{\\max} / (2L_y) + 1 \\rfloor$\n- $p_{lim} = \\lfloor D_{\\max} / (2L_z) + 1 \\rfloor$\n\n该算法将遍历范围 $[-m_{lim}, m_{lim}]$、$[-n_{lim}, n_{lim}]$ 和 $[-p_{lim}, p_{lim}]$ 的笛卡尔积内的所有整数三元组 $(m,n,p)$。\n\n#### 算法大纲\n\n1.  对于每个测试用例，解析输入参数：$(L_x, L_y, L_z)$、$\\mathbf{r}_s=(x_s, y_s, z_s)$、$\\mathbf{r}=(x_r, y_r, z_r)$、$D_{\\max}$ 和 $c$。\n\n2.  如上所述，计算整数索引限制 $m_{lim}$、$n_{lim}$ 和 $p_{lim}$。\n\n3.  初始化一个空列表 `image_contributions`，用于存储有效的 $[\\tau, A]$ 对。\n\n4.  为 $m \\in [-m_{lim}, m_{lim}]$、$n \\in [-n_{lim}, n_{lim}]$ 和 $p \\in [-p_{lim}, p_{lim}]$ 执行三个嵌套循环。\n\n5.  在最内层循环中，对于每个索引三元组 $(m,n,p)$：\n    a. 使用给定公式计算镜像声源位置 $\\mathbf{r}_{mnp}=(x_m, y_n, z_p)$。\n    b. 计算距离向量 $\\mathbf{d} = \\mathbf{r} - \\mathbf{r}_{mnp}$。\n    c. 计算标量路径长度 $d_{mnp} = \\|\\mathbf{d}\\|_2$。\n    d. 如果 $d_{mnp} \\leq D_{\\max}$：\n        i. 检查 $d_{mnp} > 0$ 以防止除零错误。问题的设置使得 $d_{mnp}=0$ 的情况极不可能发生，但为了稳健性，这是一个必要的检查。\n        ii. 计算延迟：$\\tau_{mnp} = d_{mnp} / c$。\n        iii. 计算衰减：$A_{mnp} = 1 / (4 \\pi d_{mnp})$。\n        iv. 将对 $[\\tau_{mnp}, A_{mnp}]$ 追加到 `image_contributions` 列表中。\n\n6.  循环完成后，根据每对的第一个元素（延迟 $\\tau$）对 `image_contributions` 列表进行升序排序。\n\n7.  通过遍历排序后的 `image_contributions` 创建一个新列表，按要求将每个 $\\tau$ 和 $A$ 值四舍五入到六位小数。\n\n8.  存储生成的四舍五入后的对的列表。此列表代表一个测试用例的解。\n\n9.  处理完所有测试用例后，将结果聚合到一个最终列表中，并将其格式化为指定的字符串表示形式以供最终输出。\n\n这个系统化的过程确保了问题的所有约束都得到满足，在推导出的边界内提供了精确的枚举，并以指定的排序和格式化方式生成输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Image Source Method (ISM) to find all acoustic paths within a maximum length\n    for a rectangular room with rigid walls.\n    \"\"\"\n\n    # Test Suite provided in the problem statement.\n    # Format: (Lx, Ly, Lz, xs, ys, zs, xr, yr, zr, D_max, c)\n    test_cases = [\n        (7.0, 6.0, 3.0, 1.2, 2.0, 1.0, 5.1, 4.5, 1.4, 12.0, 343.0),\n        (10.0, 8.0, 3.0, 2.0, 3.0, 1.5, 8.0, 3.0, 1.5, 6.0, 343.0),\n        (4.0, 3.0, 2.5, 0.2, 1.0, 0.6, 0.3, 2.1, 1.2, 3.0, 343.0),\n        (6.0, 5.0, 3.0, 0.5, 0.5, 0.5, 5.5, 4.5, 2.5, 1.0, 343.0),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        Lx, Ly, Lz, xs, ys, zs, xr, yr, zr, D_max, c = case\n        \n        r_s = np.array([xs, ys, zs])\n        r_r = np.array([xr, yr, zr])\n        L = np.array([Lx, Ly, Lz])\n\n        # Calculate conservative bounds for the integer indices m, n, p.\n        # This is based on |m| = D_max / (2*L) + 1.\n        m_lim = int(np.floor(D_max / (2 * Lx) + 1))\n        n_lim = int(np.floor(D_max / (2 * Ly) + 1))\n        p_lim = int(np.floor(D_max / (2 * Lz) + 1))\n\n        image_contributions = []\n\n        for m_idx in range(-m_lim, m_lim + 1):\n            for n_idx in range(-n_lim, n_lim + 1):\n                for p_idx in range(-p_lim, p_lim + 1):\n                    # Compute the position of the image source r_mnp\n                    \n                    # x_m = 2*m*Lx + (-1)^m * xs\n                    x_m = 2 * m_idx * Lx + ((-1)**m_idx) * xs\n                    # y_n = 2*n*Ly + (-1)^n * ys\n                    y_n = 2 * n_idx * Ly + ((-1)**n_idx) * ys\n                    # z_p = 2*p*Lz + (-1)^p * zs\n                    z_p = 2 * p_idx * Lz + ((-1)**p_idx) * zs\n\n                    r_mnp = np.array([x_m, y_n, z_p])\n                    \n                    # Calculate distance d_mnp = ||r_r - r_mnp||\n                    d_mnp = np.linalg.norm(r_r - r_mnp)\n\n                    # Check if the path length is within the maximum allowed distance\n                    if d_mnp = D_max:\n                        # Ensure distance is non-zero to avoid division by zero\n                        if d_mnp > 1e-9: # Using a small epsilon for floating point safety\n                            # Calculate delay tau = d/c\n                            tau_mnp = d_mnp / c\n                            # Calculate geometric attenuation A = 1/(4*pi*d)\n                            A_mnp = 1.0 / (4.0 * np.pi * d_mnp)\n                            image_contributions.append([tau_mnp, A_mnp])\n        \n        # Sort contributions by ascending delay (tau)\n        image_contributions.sort(key=lambda x: x[0])\n        \n        # Round the results to 6 decimal places\n        rounded_results = [[round(tau, 6), round(A, 6)] for tau, A in image_contributions]\n        \n        all_results.append(rounded_results)\n\n    # Format the final output string to match the problem specification\n    # [[...],[...],...] without spaces.\n    results_str = str(all_results).replace(\" \", \"\")\n    print(results_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握基础镜像声源法之后，本次练习将挑战更为真实、非矩形的复杂空间建模。你将需要开发一个算法来验证一般多面体房间中的一阶反射，这要求实现关键的几何测试，包括确定镜面反射点和检测声路遮挡 。这项练习对于理解简单模型的局限性以及掌握高级仿真所需的计算几何技术至关重要。",
            "id": "4135900",
            "problem": "给定一个由有限个平面多边形定义的多面体房间，每个多边形由有序顶点和一个向外的单位法向量指定。一个位于位置 $\\mathbf{s} \\in \\mathbb{R}^3$ 的点声源和一个位于位置 $\\mathbf{r} \\in \\mathbb{R}^3$ 的接收器都在房间内部。在几何声学的高频极限下，一阶镜像声源对应于房间多边形的镜面反射。对于多边形 $i$，一个候选的一阶镜像声源是通过将 $\\mathbf{s}$ 跨越多边形 $i$ 的支撑平面进行镜像得到的。从 $\\mathbf{r}$ 到该镜像声源的射线的镜面反射点，是线段 $\\mathbf{r} \\rightarrow \\mathbf{s}'_i$ 与多边形 $i$ 所在平面的交点。一个有效的一阶镜像声源必须满足两个条件：(i) 交点位于多边形 $i$ 的有限边界之内；(ii) 路径的两个线段 $\\mathbf{s} \\rightarrow \\mathbf{p}_i$ 和 $\\mathbf{r} \\rightarrow \\mathbf{p}_i$ 不被任何其他多边形遮挡（即，它们不与任何其他多边形的内部相交）。\n\n从与计算声学一致的基本原理出发，使用线性声学波动方程以及源自Fermat原理（平稳路径长度）的镜面反射条件，构建一个算法来确定哪些一阶镜像声源是有效的。对于每个多边形，计算其反射的镜像声源，找到镜面交点，测试该点是否位于多边形边界内，并检查是否存在被所有其他多边形遮挡的情况。对于恰好落在多边形边缘或顶点上的交点，视为相应多边形的有效反射。使用一个小的正数值容差 $\\varepsilon$ 来鲁棒地处理浮点数比较。\n\n定义和几何图元：\n\n- 多边形 $i$ 由其平面上按逆时针顺序排列的顶点列表 $\\{\\mathbf{v}_{i,0}, \\mathbf{v}_{i,1}, \\dots, \\mathbf{v}_{i,m_i-1}\\}$ 和一个单位法向量 $\\mathbf{n}_i$ 定义。其支撑平面是集合 $\\{\\mathbf{x} \\in \\mathbb{R}^3 : \\mathbf{n}_i \\cdot (\\mathbf{x} - \\mathbf{v}_{i,0}) = 0\\}$。\n- $\\mathbf{s}$ 关于多边形 $i$ 平面的反射为 $\\mathbf{s}'_i = \\mathbf{s} - 2\\,(\\mathbf{n}_i \\cdot (\\mathbf{s} - \\mathbf{v}_{i,0}))\\,\\mathbf{n}_i$。\n- 镜面交点 $\\mathbf{p}_i$ 是通过将直线 $\\mathbf{\\ell}(t) = \\mathbf{r} + t(\\mathbf{s}'_i - \\mathbf{r})$ 与平面 $\\mathbf{n}_i \\cdot (\\mathbf{x} - \\mathbf{v}_{i,0}) = 0$ 相交计算得到的。如果 $t$ 不在区间 $[0,1]$ 内，则交点位于线段之外，反射无效。\n- 必须在多边形的局部坐标系中执行点在多边形内测试。在平面上构建一个标准正交基 $\\{\\mathbf{u}_i, \\mathbf{w}_i\\}$，其中 $\\mathbf{u}_i$ 与一条边的方向对齐，$\\mathbf{w}_i = \\mathbf{n}_i \\times \\mathbf{u}_i$，然后通过 $x_u = (\\mathbf{x} - \\mathbf{v}_{i,0}) \\cdot \\mathbf{u}_i$ 和 $x_w = (\\mathbf{x} - \\mathbf{v}_{i,0}) \\cdot \\mathbf{w}_i$ 将点 $\\mathbf{x}$ 投影到 $(x_u, x_w)$ 坐标。对投影后的顶点和投影后的交点执行二维点在多边形内测试。\n- 遮挡测试必须检查线段 $\\mathbf{s} \\rightarrow \\mathbf{p}_i$ 和 $\\mathbf{r} \\rightarrow \\mathbf{p}_i$ 的内部是否与任何其他多边形 $j \\neq i$ 的内部相交。对于每个线段和多边形 $j$，求线段与多边形 $j$ 的平面的交点。如果交点参数严格位于线段内部，并且交点位于多边形 $j$ 的内部（在二维局部坐标系中），则路径被遮挡，多边形 $i$ 的镜像声源无效。\n\n您的程序必须实现此算法并将其应用于以下测试套件。所有坐标的单位均为米。答案不需要单位，因为输出是索引。\n\n测试套件：\n\n- 测试用例1（轴对齐矩形房间，无障碍物）：\n  - 房间墙壁（多边形ID 0到5）：\n    - ID 0：地板，顶点 $\\{(0,0,0),(10,0,0),(10,8,0),(0,8,0)\\}$，法向量 $(0,0,-1)$。\n    - ID 1：天花板，顶点 $\\{(0,0,3),(10,0,3),(10,8,3),(0,8,3)\\}$，法向量 $(0,0,1)$。\n    - ID 2：墙壁 $x=0$，顶点 $\\{(0,0,0),(0,8,0),(0,8,3),(0,0,3)\\}$，法向量 $(-1,0,0)$。\n    - ID 3：墙壁 $x=10$，顶点 $\\{(10,0,0),(10,8,0),(10,8,3),(10,0,3)\\}$，法向量 $(1,0,0)$。\n    - ID 4：墙壁 $y=0$，顶点 $\\{(0,0,0),(10,0,0),(10,0,3),(0,0,3)\\}$，法向量 $(0,-1,0)$。\n    - ID 5：墙壁 $y=8$，顶点 $\\{(0,8,0),(10,8,0),(10,8,3),(0,8,3)\\}$，法向量 $(0,1,0)$。\n  - 声源 $\\mathbf{s}=(3,2,1)$。\n  - 接收器 $\\mathbf{r}=(7,6,1.5)$。\n  - 预期行为：内部路径线段除了在反射点处与反射墙相交外，不应与其他墙壁相交。\n\n- 测试用例2（同一房间，带有一个垂直矩形柱状障碍物）：\n  - 房间墙壁如测试用例1所示（ID 0到5）。\n  - 柱面（ID 6到9），高为3，底座为水平面上的矩形，x 范围为 $[4.5,5.5]$，y 范围为 $[3.5,4.5]$：\n    - ID 6：柱面 $x=4.5$，顶点 $\\{(4.5,3.5,0),(4.5,4.5,0),(4.5,4.5,3),(4.5,3.5,3)\\}$，法向量 $(-1,0,0)$。\n    - ID 7：柱面 $x=5.5$，顶点 $\\{(5.5,3.5,0),(5.5,4.5,0),(5.5,4.5,3),(5.5,3.5,3)\\}$，法向量 $(1,0,0)$。\n    - ID 8：柱面 $y=3.5$，顶点 $\\{(4.5,3.5,0),(5.5,3.5,0),(5.5,3.5,3),(4.5,3.5,3)\\}$，法向量 $(0,-1,0)$。\n    - ID 9：柱面 $y=4.5$，顶点 $\\{(4.5,4.5,0),(5.5,4.5,0),(5.5,4.5,3),(4.5,4.5,3)\\}$，法向量 $(0,1,0)$。\n  - 声源 $\\mathbf{s}=(2,2,1)$。\n  - 接收器 $\\mathbf{r}=(8,6,1)$。\n  - 预期行为：某些反射路径可能会被柱面遮挡。\n\n- 测试用例3（同一房间内靠近边缘的位置）：\n  - 房间墙壁如测试用例1所示（ID 0到5）。\n  - 声源 $\\mathbf{s}=(0.2,0.4,0.5)$。\n  - 接收器 $\\mathbf{r}=(9.6,7.7,2.8)$。\n  - 预期行为：反射点可能非常靠近边缘；数值容差必须将边缘上的点视为有效，并避免错误的遮挡判断。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，其本身是有效的一阶镜像声源的多边形 ID 列表，且不含空格。例如：`[[0,1],[2,3,4],[5]]`（此示例仅为说明；您的程序必须输出针对给定测试套件的计算结果）。",
            "solution": "问题陈述提出了计算声学领域中一个明确定义的任务，特别是在几何声学建模的范畴内。它要求实现镜像声源法，以确定多面体房间中一阶镜面反射的有效性。该问题的有效性在此得到确认，因为它具有科学依据，内容自洽，且算法上是明确的。它基于高频极限下波传播的既定原理，其中声路径可近似为射线，反射遵循镜面反射定律，这是Fermat平稳时间原理的直接推论。\n\n解决方案将通过系统地实现所述的几何测试来构建。算法的核心在于遍历房间的每个平面多边形，将其视为一个潜在的反射面，并应用一系列验证标准。\n\n**1. 理论基础：镜像声源法**\n\n介质中声音的传播由声波方程控制。在频域中，对于正弦声源，这简化为亥姆霍兹方程：\n$$\n\\nabla^2 \\hat{p}(\\mathbf{x}) + k^2 \\hat{p}(\\mathbf{x}) = -S(\\mathbf{x})\n$$\n其中 $\\hat{p}(\\mathbf{x})$ 是位置 $\\mathbf{x}$ 处的复声压幅值，$k = \\omega/c$ 是波数，$\\omega$ 是角频率，$c$ 是声速，$S(\\mathbf{x})$ 代表声源分布。\n\n对于具有平面理想反射边界的房间，镜像声源法是该方程的一个优雅解法。在高频极限（$k \\rightarrow \\infty$）下，声音的波动性可以近似为几何射线。平面上的镜面反射在几何上等效于从一个“虚”声源或“镜像”声源到接收器的直线路径。这个镜像声源是原始声源相对于反射平面的镜像。这种构造满足了理想刚性表面上法向速度为零的边界条件，并确保路径长度（从而传播时间）是平稳的（Fermat原理），这也是镜面反射的条件。路径 $\\mathbf{s} \\rightarrow \\mathbf{p}_i \\rightarrow \\mathbf{r}$ 的长度与直线路径 $\\mathbf{s}'_i \\rightarrow \\mathbf{p}_i \\rightarrow \\mathbf{r}$ 的长度相同，当这三点共线时，该长度最小。\n\n**2. 验证一阶镜像声源的算法步骤**\n\n对于给定的声源 $\\mathbf{s}$、接收器 $\\mathbf{r}$ 和一组平面多边形 $\\{\\text{Poly}_0, \\text{Poly}_1, \\dots, \\text{Poly}_N\\}$，我们将每个多边形 $\\text{Poly}_i$ 作为反射面进行测试。\n\n**步骤 2.1：镜像声源的计算**\n\n设多边形 $\\text{Poly}_i$ 由其平面上的一点 $\\mathbf{v}_{i,0}$ 和一个向外的单位法向量 $\\mathbf{n}_i$ 定义。从声源 $\\mathbf{s}$到该平面的有向垂直距离为 $d = \\mathbf{n}_i \\cdot (\\mathbf{s} - \\mathbf{v}_{i,0})$。通过将 $\\mathbf{s}$ 对该平面进行镜像，可以找到镜像声源 $\\mathbf{s}'_i$：\n$$\n\\mathbf{s}'_i = \\mathbf{s} - 2 d \\, \\mathbf{n}_i = \\mathbf{s} - 2 (\\mathbf{n}_i \\cdot (\\mathbf{s} - \\mathbf{v}_{i,0})) \\mathbf{n}_i\n$$\n\n**步骤 2.2：镜面反射点的计算**\n\n镜面反射点 $\\mathbf{p}_i$ 是连接接收器 $\\mathbf{r}$ 和镜像声源 $\\mathbf{s}'_i$ 的线段与 $\\text{Poly}_i$ 平面的交点。\n线上的一点由 $\\mathbf{\\ell}(t) = \\mathbf{r} + t(\\mathbf{s}'_i - \\mathbf{r})$ 给出，其中 $t \\in \\mathbb{R}$。平面上的一点 $\\mathbf{x}$ 满足 $\\mathbf{n}_i \\cdot (\\mathbf{x} - \\mathbf{v}_{i,0}) = 0$。将 $\\mathbf{\\ell}(t)$ 代入 $\\mathbf{x}$：\n$$\n\\mathbf{n}_i \\cdot (\\mathbf{r} + t(\\mathbf{s}'_i - \\mathbf{r}) - \\mathbf{v}_{i,0}) = 0\n$$\n求解参数 $t$：\n$$\nt = \\frac{\\mathbf{n}_i \\cdot (\\mathbf{v}_{i,0} - \\mathbf{r})}{\\mathbf{n}_i \\cdot (\\mathbf{s}'_i - \\mathbf{r})}\n$$\n如果分母接近于零（在容差 $\\varepsilon$ 内），则直线与平面平行，不存在唯一交点，反射无效。为使反射在物理上合理（即在 $\\mathbf{r}$ 和 $\\mathbf{s}'_i$ 之间的路径上），必须有 $t \\in [0, 1]$。我们使用一个容差：$t \\in [-\\varepsilon, 1+\\varepsilon]$。如果满足此条件，则交点为：\n$$\n\\mathbf{p}_i = \\mathbf{r} + t(\\mathbf{s}'_i - \\mathbf{r})\n$$\n\n**步骤 2.3：点在多边形内测试**\n\n只有当 $\\mathbf{p}_i$ 位于多边形 $\\text{Poly}_i$ 的有限边界内时，反射才有效。为测试这一点，我们将三维几何投影到二维平面上。我们为多边形平面构建一个标准正交基 $\\{\\mathbf{u}_i, \\mathbf{w}_i\\}$：\n1.  令 $\\mathbf{u}_i = \\frac{\\mathbf{v}_{i,1} - \\mathbf{v}_{i,0}}{\\|\\mathbf{v}_{i,1} - \\mathbf{v}_{i,0}\\|}$ 为沿第一条边的单位向量。\n2.  令 $\\mathbf{w}_i = \\mathbf{n}_i \\times \\mathbf{u}_i$，它同时正交于 $\\mathbf{n}_i$ 和 $\\mathbf{u}_i$。\n\n三维空间中的任何点 $\\mathbf{x}$ 都可以投影到这个二维坐标系（原点在 $\\mathbf{v}_{i,0}$）中，表示为 $(x_u, x_w)$：\n$$\nx_u = (\\mathbf{x} - \\mathbf{v}_{i,0}) \\cdot \\mathbf{u}_i, \\quad x_w = (\\mathbf{x} - \\mathbf{v}_{i,0}) \\cdot \\mathbf{w}_i\n$$\n我们将多边形的所有顶点 $\\mathbf{v}_{i,k}$ 和点 $\\mathbf{p}_i$ 投影到这个二维系统中。确定投影点是否在投影多边形内的一种鲁棒方法是环绕数算法。它计算每个多边形边在测试点所对的角度之和。\n$$\nW = \\sum_{k=0}^{m_i - 1} \\text{angle}(\\vec{P V_{k}}, \\vec{P V_{k+1}})\n$$\n其中 $P$ 是投影的测试点，$V_k$ 是投影的顶点。如果 $|W| \\approx 2\\pi$，则点在内部。如果 $W \\approx 0$，则点在外部。如果 $|W| \\approx \\pi$，则点在边上。根据问题要求，边上或顶点上的点被视为有效，因此我们测试 $|W|  \\pi - \\varepsilon$。\n\n**步骤 2.4：遮挡测试**\n\n一个有效的反射路径不能被阻挡。构成路径的两个线段 $\\mathbf{s} \\rightarrow \\mathbf{p}_i$ 和 $\\mathbf{p}_i \\rightarrow \\mathbf{r}$，必须检查是否与所有其他多边形 $\\text{Poly}_j$（其中 $j \\neq i$）的*内部*相交。\n\n对于每个线段（例如，从 $\\mathbf{a}$ 到 $\\mathbf{b}$）和每个潜在的遮挡多边形 $\\text{Poly}_j$：\n1.  计算包含该线段的直线与 $\\text{Poly}_j$ 平面的交点。该直线为 $\\mathbf{\\ell}(t) = \\mathbf{a} + t(\\mathbf{b} - \\mathbf{a})$。交点参数为：\n    $$\n    t_{int} = \\frac{\\mathbf{n}_j \\cdot (\\mathbf{v}_{j,0} - \\mathbf{a})}{\\mathbf{n}_j \\cdot (\\mathbf{b} - \\mathbf{a})}\n    $$\n2.  只有当交点严格位于线段的*内部*时，才会发生遮挡。这要求 $t_{int} \\in (\\varepsilon, 1-\\varepsilon)$。容差 $\\varepsilon$ 对于避免在端点处发生错误的遮挡判断至关重要，尤其是在位于 $\\text{Poly}_i$ 平面上的 $\\mathbf{p}_i$点。\n3.  如果 $t_{int}$ 在此范围内，计算交点 $\\mathbf{x}_{int} = \\mathbf{a} + t_{int}(\\mathbf{b} - \\mathbf{a})$。\n4.  对 $\\mathbf{x}_{int}$ 进行相对于多边形 $\\text{Poly}_j$ 的点在多边形内测试。要构成遮挡，交点必须在多边形的*内部*。因此，环绕数必须接近 $2\\pi$，即 $|W|  2\\pi - \\varepsilon$。\n5.  如果对于任一线段和任一多边形 $j \\neq i$，条件(2)和(4)都满足，则来自 $\\text{Poly}_i$ 的反射路径被遮挡，该镜像声源无效。算法可以停止对 $\\text{Poly}_i$ 的遮挡检查，并继续处理下一个潜在的反射面。\n\n如果一个多边形 $i$ 通过了所有这些测试（有效的交点参数 $t$，点 $\\mathbf{p}_i$ 在多边形 $i$ 内部，且无遮挡），则其索引被添加到有效的一阶镜像声源列表中。对环境中的所有多边形和每个测试用例重复此整个过程。",
            "answer": "```python\nimport numpy as np\n\n# Global numerical tolerance for floating-point comparisons\nEPSILON = 1e-9\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the validation algorithm.\n    \"\"\"\n    \n    # Test Case 1: Simple rectangular room\n    walls_case1 = [\n        # ID 0: floor\n        {'id': 0, 'vertices': np.array([[0,0,0],[10,0,0],[10,8,0],[0,8,0]], dtype=float), 'normal': np.array([0,0,-1], dtype=float)},\n        # ID 1: ceiling\n        {'id': 1, 'vertices': np.array([[0,0,3],[0,8,3],[10,8,3],[10,0,3]], dtype=float), 'normal': np.array([0,0,1], dtype=float)},\n        # ID 2: wall x=0\n        {'id': 2, 'vertices': np.array([[0,0,0],[0,8,0],[0,8,3],[0,0,3]], dtype=float), 'normal': np.array([-1,0,0], dtype=float)},\n        # ID 3: wall x=10\n        {'id': 3, 'vertices': np.array([[10,0,0],[10,0,3],[10,8,3],[10,8,0]], dtype=float), 'normal': np.array([1,0,0], dtype=float)},\n        # ID 4: wall y=0\n        {'id': 4, 'vertices': np.array([[0,0,0],[0,0,3],[10,0,3],[10,0,0]], dtype=float), 'normal': np.array([0,-1,0], dtype=float)},\n        # ID 5: wall y=8\n        {'id': 5, 'vertices': np.array([[0,8,0],[10,8,0],[10,8,3],[0,8,3]], dtype=float), 'normal': np.array([0,1,0], dtype=float)},\n    ]\n    s1 = np.array([3, 2, 1], dtype=float)\n    r1 = np.array([7, 6, 1.5], dtype=float)\n\n    # Test Case 2: Room with pillar\n    pillar_faces = [\n        # ID 6: pillar face x=4.5\n        {'id': 6, 'vertices': np.array([[4.5,3.5,0],[4.5,4.5,0],[4.5,4.5,3],[4.5,3.5,3]], dtype=float), 'normal': np.array([-1,0,0], dtype=float)},\n        # ID 7: pillar face x=5.5\n        {'id': 7, 'vertices': np.array([[5.5,3.5,0],[5.5,3.5,3],[5.5,4.5,3],[5.5,4.5,0]], dtype=float), 'normal': np.array([1,0,0], dtype=float)},\n        # ID 8: pillar face y=3.5\n        {'id': 8, 'vertices': np.array([[4.5,3.5,0],[4.5,3.5,3],[5.5,3.5,3],[5.5,3.5,0]], dtype=float), 'normal': np.array([0,-1,0], dtype=float)},\n        # ID 9: pillar face y=4.5\n        {'id': 9, 'vertices': np.array([[4.5,4.5,0],[5.5,4.5,0],[5.5,4.5,3],[4.5,4.5,3]], dtype=float), 'normal': np.array([0,1,0], dtype=float)},\n    ]\n    walls_case2 = walls_case1 + pillar_faces\n    s2 = np.array([2, 2, 1], dtype=float)\n    r2 = np.array([8, 6, 1], dtype=float)\n    \n    # Test Case 3: Near-edge positions\n    walls_case3 = walls_case1\n    s3 = np.array([0.2, 0.4, 0.5], dtype=float)\n    r3 = np.array([9.6, 7.7, 2.8], dtype=float)\n\n    test_cases = [\n        (walls_case1, s1, r1),\n        (walls_case2, s2, r2),\n        (walls_case3, s3, r3)\n    ]\n\n    all_results = []\n    for polygons, s, r in test_cases:\n        valid_ids = find_valid_image_sources(polygons, s, r)\n        all_results.append(f\"[{','.join(map(str, sorted(valid_ids)))}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\ndef find_valid_image_sources(polygons, s, r):\n    \"\"\"\n    For a given room geometry, source, and receiver, find all valid first-order image sources.\n    \"\"\"\n    valid_ids = []\n    for i, poly_i in enumerate(polygons):\n        # 1. Calculate image source\n        v0_i = poly_i['vertices'][0]\n        n_i = poly_i['normal']\n        dist_s_plane = np.dot(s - v0_i, n_i)\n        s_prime = s - 2 * dist_s_plane * n_i\n\n        # 2. Calculate specular reflection point\n        line_dir = s_prime - r\n        denom = np.dot(n_i, line_dir)\n        if abs(denom)  EPSILON:\n            continue  # Line is parallel to the plane\n\n        t = np.dot(v0_i - r, n_i) / denom\n        if not (-EPSILON = t = 1 + EPSILON):\n            continue # Intersection is outside the r -> s' segment\n\n        p_i = r + t * line_dir\n\n        # 3. Point-in-polygon test for the reflection point\n        if not is_point_in_polygon(p_i, poly_i, on_boundary_ok=True):\n            continue\n            \n        # 4. Occlusion test\n        is_occluded = False\n        path_segments = [(s, p_i), (r, p_i)]\n        for seg_start, seg_end in path_segments:\n            for j, poly_j in enumerate(polygons):\n                if i == j:\n                    continue  # A segment cannot be occluded by its own reflecting polygon\n                \n                if check_segment_occlusion(seg_start, seg_end, poly_j):\n                    is_occluded = True\n                    break\n            if is_occluded:\n                break\n        \n        if not is_occluded:\n            valid_ids.append(poly_i['id'])\n            \n    return valid_ids\n\ndef is_point_in_polygon(point, polygon, on_boundary_ok=False):\n    \"\"\"\n    Checks if a 3D point is inside a 3D polygon using the winding number algorithm.\n    The point must lie on the polygon's plane.\n    \"\"\"\n    vertices = polygon['vertices']\n    normal = polygon['normal']\n    \n    # Create local 2D coordinate system on the polygon's plane\n    u_vec = vertices[1] - vertices[0]\n    u_vec /= np.linalg.norm(u_vec)\n    w_vec = np.cross(normal, u_vec)\n\n    # Project polygon vertices to 2D\n    verts_2d = []\n    for v in vertices:\n        v_proj = v - vertices[0]\n        verts_2d.append(np.array([np.dot(v_proj, u_vec), np.dot(v_proj, w_vec)]))\n\n    # Project point to 2D\n    p_proj = point - vertices[0]\n    p_2d = np.array([np.dot(p_proj, u_vec), np.dot(p_proj, w_vec)])\n\n    # Winding number algorithm\n    total_angle = 0.0\n    num_verts = len(verts_2d)\n    for i in range(num_verts):\n        v1 = verts_2d[i] - p_2d\n        v2 = verts_2d[(i + 1) % num_verts] - p_2d\n        \n        dot_product = np.dot(v1, v2)\n        cross_product_mag = v1[0] * v2[1] - v1[1] * v2[0] # Determinant for 2D cross product\n        \n        angle = np.arctan2(cross_product_mag, dot_product)\n        total_angle += angle\n\n    # Check if inside based on total angle\n    if on_boundary_ok:\n        # Point is inside or on the boundary if angle is |pi| or |2pi|\n        return abs(abs(total_angle) - np.pi)  EPSILON or abs(abs(total_angle) - 2 * np.pi)  EPSILON\n    else:\n        # Point is strictly inside if angle is |2pi|\n        return abs(abs(total_angle) - 2 * np.pi)  EPSILON\n\ndef check_segment_occlusion(seg_start, seg_end, occluder_poly):\n    \"\"\"\n    Checks if a line segment is occluded by a polygon.\n    \"\"\"\n    seg_dir = seg_end - seg_start\n    seg_len_sq = np.dot(seg_dir, seg_dir)\n    if seg_len_sq  EPSILON**2:\n        return False # Zero-length segment cannot be occluded\n\n    v0_j = occluder_poly['vertices'][0]\n    n_j = occluder_poly['normal']\n    \n    denom = np.dot(n_j, seg_dir)\n    if abs(denom)  EPSILON:\n        return False # Segment is parallel to occluder plane\n\n    t_int = np.dot(n_j, v0_j - seg_start) / denom\n\n    # Check if intersection is strictly within the segment's interior\n    if t_int = EPSILON or t_int >= 1 - EPSILON:\n        return False\n\n    intersection_point = seg_start + t_int * seg_dir\n    \n    # Check if intersection point is strictly inside the occluder polygon\n    if is_point_in_polygon(intersection_point, occluder_poly, on_boundary_ok=False):\n        return True\n        \n    return False\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在使用镜像声源法等方法确定了反射声的到达时间后，下一个关键步骤是将其渲染成用于数字音频处理的离散时间脉冲响应。本次练习将指导你实现拉格朗日插值，以精确地表示分数延迟——当声音到达时间点落在两个采样点之间时便会产生这种延迟 。掌握这项技术是将几何模型的输出转化为高保真声学仿真的基础。",
            "id": "4135901",
            "problem": "给定一个通过镜像声源法建模的矩形房间场景，接收器处由一组到达声波产生的连续时间声学脉冲响应是一系列延迟狄拉克脉冲之和。设采样率为 $f_s$ (单位 $\\mathrm{Hz}$)，到达时间集合为 $\\{t_n\\}_{n=1}^N$ (单位 $\\mathrm{s}$)。假设所有到达声波的振幅均为单位1，因此连续时间脉冲响应为 $h_\\mathrm{c}(t) = \\sum_{n=1}^N \\delta(t - t_n)$。离散化后，期望的离散时间脉冲响应是一个序列 $h[k]$，其构造旨在近似非整数采样点索引上的延迟脉冲。使用M阶多项式拉格朗日插值来实现分数采样延迟：对于每个延迟 $t_n$，以采样点为单位的延迟为 $d_n = f_s t_n$，可写作 $d_n = p_n + \\mu_n$，其中 $p_n \\in \\mathbb{Z}$ 是整数部分，$\\mu_n \\in [0,1)$ 是分数部分。M阶插值会产生一个在 $M+1$ 个连续采样点上支撑的有限脉冲响应，该响应在整数索引 $p_n$ 附近近似分数延迟 $\\mu_n$。\n\n从线性波动方程及其在室内声学中的格林函数解出发，论证为何离散时间表示为延迟脉冲之和是合理的，并推导M阶拉格朗日插值如何近似分数延迟。然后，定义离散化脉冲响应的频率响应 $H_\\mathrm{approx}(f) = \\sum_{k=0}^{L-1} h[k] e^{-j 2 \\pi f k / f_s}$ 和理想连续时间频率响应 $H_\\mathrm{ideal}(f) = \\sum_{n=1}^N e^{-j 2 \\pi f t_n}$。近似误差作为插值阶数和频率的函数为\n$$\nE_M(f) = \\left| \\, \\left|H_\\mathrm{approx}(f)\\right| - \\left|H_\\mathrm{ideal}(f)\\right| \\, \\right|.\n$$\n此处，所有角度均以弧度为单位。您必须使用M阶拉格朗日插值计算 $h[k]$，在指定的频率网格上评估 $H_\\mathrm{approx}(f)$ 和 $H_\\mathrm{ideal}(f)$，并报告每个网格上的最大幅度误差。\n\n实现一个完整、可运行的程序，该程序能够：\n- 针对给定的 $f_s$、$\\{t_n\\}$ 和插值阶数 $M$ 构建 $h[k]$。\n- 对测试套件中的每个频率计算 $H_\\mathrm{approx}(f)$ 和 $H_\\mathrm{ideal}(f)$。\n- 对每个测试用例，计算标量指标 $\\max_{f \\in \\mathcal{F}} E_M(f)$，其中 $\\mathcal{F}$ 是该测试用例给定的频率集合。\n- 生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n\n所有物理单位必须遵守：使用 $f_s$ (单位 $\\mathrm{Hz}$)、延迟 $t_n$ (单位 $\\mathrm{s}$) 和频率 $f$ (单位 $\\mathrm{Hz}$)。角度必须以弧度为单位。最终输出为无量纲实数。\n\n测试套件：\n- 用例1（一般情况）：$f_s = 48000$，$\\{t_n\\} = \\{0.007123, 0.012345\\}$，$M = 3$，频率集合 $\\mathcal{F} = \\{0, 1000, 5000, 10000, 15000, 20000\\}$。\n- 用例2（边界情况：最近邻插值）：$f_s = 48000$，$\\{t_n\\} = \\{0.0034\\}$，$M = 0$，频率集合 $\\mathcal{F} = \\{0, 5000, 10000, 20000, 23000\\}$。\n- 用例3（边缘情况：高阶且接近整数的分数延迟）：$f_s = 44100$，$\\{t_n\\} = \\{(100.999)/f_s, (257.1)/f_s\\}$，$M = 10$，频率集合 $\\mathcal{F} = \\{0, 1000, 5000, 10000, 15000, 20000\\}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[r_1,r_2,r_3]$），其中 $r_i$ 是用例 $i$ 的 $\\max_{f \\in \\mathcal{F}} E_M(f)$，表示为十进制数。",
            "solution": "该问题要求制定并实现一个程序，以量化使用基于多项式的分数延迟滤波对连续时间声学脉冲响应进行离散化时引入的误差。脉冲响应被建模为延迟狄拉克脉冲之和，这一表示方法在室内声学中通过镜像声源法得到了验证。\n\n### 第一部分：从波动方程到延迟脉冲之和\n\n声音在空气等流体介质中的传播由线性声学波动方程控制。对于位置 $\\mathbf{r}$ 和时间 $t$ 处的声压场 $p(\\mathbf{r}, t)$，该方程为：\n$$\n\\nabla^2 p(\\mathbf{r}, t) - \\frac{1}{c^2} \\frac{\\partial^2 p(\\mathbf{r}, t)}{\\partial t^2} = -S(\\mathbf{r}, t)\n$$\n其中 $c$ 是声速，$S(\\mathbf{r}, t)$ 是源项。对于一个在 $t=0$ 时刻于 $\\mathbf{r}_s$ 处发射脉冲的理想点声源，源项为 $S(\\mathbf{r}, t) = \\delta(\\mathbf{r} - \\mathbf{r}_s) \\delta(t)$。\n\n在无界自由场介质中，此方程的解是格林函数，它表示一个球形扩展波：\n$$\ng(\\mathbf{r}, t | \\mathbf{r}_s, 0) = \\frac{1}{4\\pi ||\\mathbf{r} - \\mathbf{r}_s||} \\delta\\left(t - \\frac{||\\mathbf{r} - \\mathbf{r}_s||}{c}\\right)\n$$\n该解是一个狄拉克脉冲，其延迟时间为传播时间 $t_d = ||\\mathbf{r} - \\mathbf{r}_s||/c$，其振幅因球形扩散因子 $1/(4\\pi ||\\mathbf{r} - \\mathbf{r}_s||)$ 而衰减。\n\n在混响环境中，例如具有声学刚性（完美反射）墙壁的矩形房间，接收器位置 $\\mathbf{r}_r$ 处的声场是来自声源的直达声和一系列来自墙壁的反射声的叠加。镜像声源法为求解该声场提供了一种简洁的方法。通过构建一个由“镜像”声源组成的晶格来满足墙壁施加的边界条件，这些镜像声源是物理声源穿过房间边界的反射。\n\n每个由 $n$ 索引的镜像声源都像自由空间中的一个声源一样，为接收器处的压力贡献一个延迟和衰减的脉冲。接收器处的总声学脉冲响应 $h_c(t)$ 是这些贡献的总和：\n$$\nh_c(t) = \\sum_{n=0}^{\\infty} A_n \\delta(t - t_n)\n$$\n在这里，$t_n$ 是从第 $n$ 个镜像声源到接收器的传播时间，$A_n$ 是相应的衰减因子，它考虑了球形扩散和墙壁的反射系数。\n\n问题陈述通过假设存在有限数量 $N$ 的重要到达声波，并且所有到达声波的振幅均为单位1（对所有 $n$，$A_n=1$）来简化此模型。这直接导出了给定的连续时间脉冲响应模型：\n$$\nh_c(t) = \\sum_{n=1}^N \\delta(t - t_n)\n$$\n这证明了将房间脉冲响应表示为延迟狄拉克脉冲之和的合理性。\n\n### 第二部分：通过拉格朗日插值进行离散化\n\n为了用数字系统处理连续时间信号 $h_c(t)$，必须以采样率 $f_s$（采样周期 $T_s = 1/f_s$）对其进行采样。一种简单的采样过程，$h[k] = h_c(k T_s)$，会漏掉任何到达时间 $t_n$ 不是 $T_s$ 整数倍的脉冲。\n\n以采样点为单位，一个到达时间为 $t_n$ 的声波的总延迟是 $d_n = t_n / T_s = f_s t_n$。通常，$d_n$ 是一个非整数值。我们可以将其分解为一个整数部分 $p_n = \\lfloor d_n \\rfloor$ 和一个分数部分 $\\mu_n = d_n - p_n$，其中 $\\mu_n \\in [0, 1)$。在离散时间域中正确表示这种非整数延迟的任务被称为分数延迟滤波。\n\n理想的分数延迟滤波器具有非因果、无限长度的脉冲响应（一个移位的sinc函数），这使其不切实际。因此，需要一种有限长度脉冲响应（FIR）的近似方法。拉格朗日插值为构建此类FIR滤波器提供了一种方法。\n\n一个M阶拉格朗日插值器构建一个唯一的、次数最多为 $M$ 的多项式，该多项式穿过 $M+1$ 个给定点。为了设计一个近似分数延迟 $\\mu_n$ 的FIR滤波器，我们可以使用拉格朗日基多项式。对于一个在整数采样索引 $\\{0, 1, \\dots, M\\}$ 上进行插值的、长度为 $M+1$ 的因果滤波器，其在索引 $\\ell \\in \\{0, 1, \\dots, M\\}$ 处的滤波器系数由下式给出：\n$$\nh_{\\mu_n, M}[\\ell] = \\prod_{i=0, i \\neq \\ell}^{M} \\frac{\\mu_n - i}{\\ell - i}\n$$\n这些系数 $h_{\\mu_n, M}[\\ell]$ 构成了近似分数延迟部分 $\\mu_n$ 的FIR滤波器。整数延迟部分 $p_n$ 是通过沿时间轴移动此FIR滤波器的位置来实现的。\n\n### 第三部分：脉冲响应构建算法\n\n完整的离散时间脉冲响应 $h[k]$ 是通过叠加每个到达声波的独立FIR滤波器来构建的。\n\n1.  **确定脉冲响应长度**：最晚的到达时间 $t_{\\max} = \\max_n\\{t_n\\}$ 决定了离散脉冲响应数组所需的长度。最大采样延迟为 $d_{\\max} = f_s t_{\\max}$。该到达声波的滤波器最后一个非零系数将位于索引 $\\lfloor d_{\\max} \\rfloor + M$ 处。因此，所需的总长度为 $L = \\lfloor d_{\\max} \\rfloor + M + 1$。将一个长度为 $L$ 的数组 $h[k]$ 初始化为全零。\n\n2.  **叠加到达滤波器**：对于集合 $\\{t_n\\}_{n=1}^N$ 中的每个到达时间 $t_n$：\n    a. 计算以采样点为单位的总延迟：$d_n = f_s t_n$。\n    b. 将延迟分解为其整数部分和分数部分：$p_n = \\lfloor d_n \\rfloor$ 和 $\\mu_n = d_n - p_n$。\n    c. 对于从 $0$ 到 $M$ 的每个索引 $\\ell$：\n        i.  计算拉格朗日插值系数：$c_\\ell = \\prod_{i=0, i \\neq \\ell}^{M} (\\mu_n - i) / (\\ell - i)$。\n        ii. 将此系数加到总脉冲响应中相应的采样点索引处：$h[p_n + \\ell] \\leftarrow h[p_n + \\ell] + c_\\ell$。\n\n最终得到的数组 $h[k]$ 即为房间脉冲响应 $h_c(t)$ 的离散化表示。\n\n### 第四部分：频域误差计算\n\n为了评估近似的质量，我们将离散时间滤波器的频率响应幅度 $H_\\mathrm{approx}(f)$ 与理想连续时间响应的频率响应幅度 $H_\\mathrm{ideal}(f)$ 进行比较。\n\n1.  **近似频率响应**：对于给定的频率 $f$，$H_\\mathrm{approx}(f)$ 通过 $h[k]$ 的离散时间傅里叶变换（DTFT）计算：\n    $$\n    H_\\mathrm{approx}(f) = \\sum_{k=0}^{L-1} h[k] e^{-j 2 \\pi f k / f_s}\n    $$\n    其中 $j = \\sqrt{-1}$。\n\n2.  **理想频率响应**：理想连续时间响应 $h_c(t) = \\sum_{n=1}^N \\delta(t - t_n)$ 的傅里叶变换为：\n    $$\n    H_\\mathrm{ideal}(f) = \\mathcal{F}\\{h_c(t)\\} = \\sum_{n=1}^N e^{-j 2 \\pi f t_n}\n    $$\n\n3.  **误差度量**：在给定频率 $f$ 处的误差定义为幅度响应之间的绝对差：\n    $$\n    E_M(f) = \\left| \\, \\left|H_\\mathrm{approx}(f)\\right| - \\left|H_\\mathrm{ideal}(f)\\right| \\, \\right|\n    $$\n每个测试用例的最终度量是在指定频率集合 $\\mathcal{F}$ 上该误差的最大值：\n$$\n\\max_{f \\in \\mathcal{F}} E_M(f)\n$$\n\n此过程提供了一个定量度量，衡量M阶基于拉格朗日的的分数延迟滤波器在多大程度上保持了理想信号的幅度谱。",
            "answer": "```python\nimport numpy as np\n\ndef lagrange_coeffs(mu, M):\n    \"\"\"\n    Computes the coefficients of an order-M Lagrange interpolation FIR filter\n    for a fractional delay mu.\n    \"\"\"\n    if M == 0:\n        return np.array([1.0])\n    \n    ell = np.arange(M + 1)\n    coeffs = np.zeros(M + 1)\n    \n    for l_idx, l_val in enumerate(ell):\n        numerator = 1.0\n        denominator = 1.0\n        for i_val in ell:\n            if i_val != l_val:\n                numerator *= mu - i_val\n                denominator *= l_val - i_val\n        coeffs[l_idx] = numerator / denominator\n        \n    return coeffs\n\ndef calculate_max_error(fs, t_n_list, M, F_list):\n    \"\"\"\n    Calculates the maximum approximation error over a set of frequencies.\n    \"\"\"\n    if not t_n_list:\n        return 0.0\n\n    # Step 1: Construct the discrete-time impulse response h[k]\n    t_n_array = np.array(t_n_list)\n    d_max = fs * np.max(t_n_array)\n    p_max = int(np.floor(d_max))\n    L = p_max + M + 1\n    h = np.zeros(L, dtype=np.float64)\n\n    for t_n in t_n_array:\n        d_n = fs * t_n\n        p_n = int(np.floor(d_n))\n        mu_n = d_n - p_n\n        \n        coeffs = lagrange_coeffs(mu_n, M)\n        \n        start_idx = p_n\n        end_idx = p_n + M + 1\n        if end_idx = L:\n            h[start_idx:end_idx] += coeffs\n\n    # Step 2: Calculate error for each frequency in F_list\n    max_error = 0.0\n    k_vec = np.arange(L)\n    \n    for f in F_list:\n        # Calculate approximate frequency response\n        exp_vec_approx = np.exp(-1j * 2 * np.pi * f * k_vec / fs)\n        H_approx = np.sum(h * exp_vec_approx)\n\n        # Calculate ideal frequency response\n        exp_vec_ideal = np.exp(-1j * 2 * np.pi * f * t_n_array)\n        H_ideal = np.sum(exp_vec_ideal)\n        \n        # Calculate error\n        error = np.abs(np.abs(H_approx) - np.abs(H_ideal))\n        if error > max_error:\n            max_error = error\n            \n    return max_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"fs\": 48000,\n            \"t_n\": [0.007123, 0.012345],\n            \"M\": 3,\n            \"F\": [0, 1000, 5000, 10000, 15000, 20000],\n        },\n        {\n            \"fs\": 48000,\n            \"t_n\": [0.0034],\n            \"M\": 0,\n            \"F\": [0, 5000, 10000, 20000, 23000],\n        },\n        {\n            \"fs\": 44100,\n            \"t_n\": [100.999 / 44100, 257.1 / 44100],\n            \"M\": 10,\n            \"F\": [0, 1000, 5000, 10000, 15000, 20000],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        fs = case[\"fs\"]\n        t_n_list = case[\"t_n\"]\n        M = case[\"M\"]\n        F_list = case[\"F\"]\n        \n        max_err = calculate_max_error(fs, t_n_list, M, F_list)\n        results.append(f\"{max_err:.10f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}