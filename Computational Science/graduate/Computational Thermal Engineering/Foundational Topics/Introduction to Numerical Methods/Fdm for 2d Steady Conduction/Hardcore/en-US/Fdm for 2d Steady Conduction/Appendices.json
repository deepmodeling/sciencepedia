{
    "hands_on_practices": [
        {
            "introduction": "Before tackling complex engineering problems, it is crucial to verify that your numerical solver is implemented correctly. This practice introduces the Method of Manufactured Solutions (MMS), a powerful technique for code verification. You will implement a standard five-point stencil for the 2D Poisson equation and use a prescribed smooth solution to generate a source term, allowing you to precisely measure your code's error and confirm its theoretical second-order accuracy .",
            "id": "3952953",
            "problem": "Consider two-dimensional steady heat conduction in a homogeneous medium with constant thermal conductivity $k$ on the unit square domain $[0,1] \\times [0,1]$. The governing balance of energy for steady heat conduction with volumetric heat generation is the divergence form $-\\nabla \\cdot (k \\nabla T) = q$, where $T$ is temperature and $q$ is volumetric heat generation. Assume nondimensional variables and $k = 1$. Let the exact temperature field be $T(x,y) = \\sin(\\pi x)\\sin(\\pi y)$, with angles in radians. Using this exact solution, generate the corresponding source term $q(x,y)$ via the relation $-\\nabla^2 T = q$, and impose Dirichlet boundary conditions consistent with the exact solution on the entire boundary of the domain. The boundaries of the unit square are at $x=0$, $x=1$, $y=0$, and $y=1$.\n\nDerive, from first principles, a second-order accurate Finite Difference Method (FDM) discretization of the governing equation on a uniform Cartesian grid with equal spacing in both directions. Use a five-point stencil on interior grid points and enforce Dirichlet boundary conditions on the grid boundary. Construct the discrete linear system corresponding to the negative Laplacian operator acting on $T$ equated to the discrete $q$. Assemble the right-hand side by evaluating $q$ at the interior grid points. Solve the resulting linear system for $T$ on the interior grid points.\n\nDefine the spatial step size as $h = 1/(n+1)$, where $n$ is the number of interior grid points in each coordinate direction. Let the interior grid points be at $x_i = ih$ and $y_j = jh$ for $i,j \\in \\{1,2,\\ldots,n\\}$. Compute the discrete error by comparing the numerical solution to the exact solution at the interior grid points. Use the discrete $L_2$ norm defined as $\\left(\\sum_{i=1}^n \\sum_{j=1}^n \\left|e_{ij}\\right|^2 h^2\\right)^{1/2}$ and the discrete $L_\\infty$ norm defined as $\\max_{i,j} \\left|e_{ij}\\right|$, where $e_{ij}$ is the error at $(x_i,y_j)$.\n\nDemonstrate second-order convergence by computing the observed order $p$ between successive uniform grids using $p = \\frac{\\log(E_\\text{coarse}/E_\\text{fine})}{\\log(h_\\text{coarse}/h_\\text{fine})}$, where $E$ is either the $L_2$ error or the $L_\\infty$ error and $h$ is the grid spacing corresponding to the number of interior points.\n\nYour program must implement the above, solve the discrete systems, and report the observed orders for a set of test pairs of grid resolutions. All quantities are nondimensional.\n\nTest Suite:\n- Use interior grid sizes $n \\in \\{4,8,16,32,64\\}$ and evaluate observed orders between the successive pairs $(4,8)$, $(8,16)$, $(16,32)$, and $(32,64)$.\n- For each pair, compute the observed order for both the $L_2$ norm and the $L_\\infty$ norm.\n- This suite covers a coarse-grid boundary case ($n=4$), intermediate grids, and a relatively fine grid ($n=64$) to test asymptotic behavior.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the observed orders as a comma-separated list enclosed in square brackets, in the exact order: $[p_{L_2}(4,8), p_{L_2}(8,16), p_{L_2}(16,32), p_{L_2}(32,64), p_{L_\\infty}(4,8), p_{L_\\infty}(8,16), p_{L_\\infty}(16,32), p_{L_\\infty}(32,64)]$.\n- Each entry must be a floating-point number.",
            "solution": "The problem is subjected to validation and is determined to be valid. It is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution.\n\n### 1. Problem Formulation\n\nThe problem concerns two-dimensional steady-state heat conduction in a unit square domain, $\\Omega = [0,1] \\times [0,1]$. The governing equation is the Poisson equation, which arises from the energy balance equation $-\\nabla \\cdot (k \\nabla T) = q$ by assuming constant thermal conductivity $k=1$. The equation is:\n$$-\\nabla^2 T(x,y) = q(x,y) \\quad \\text{for } (x,y) \\in \\Omega$$\nwhere $T$ is the temperature field and $q$ is the volumetric heat generation rate.\n\nThe Method of Manufactured Solutions (MMS) is employed to verify the numerical scheme. An exact solution is prescribed:\n$$T_{exact}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$$\nThe corresponding source term $q(x,y)$ is derived by substituting $T_{exact}$ into the governing equation. The partial derivatives are:\n$$ \\frac{\\partial T_{exact}}{\\partial x} = \\pi \\cos(\\pi x)\\sin(\\pi y) \\implies \\frac{\\partial^2 T_{exact}}{\\partial x^2} = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y) $$\n$$ \\frac{\\partial T_{exact}}{\\partial y} = \\pi \\sin(\\pi x)\\cos(\\pi y) \\implies \\frac{\\partial^2 T_{exact}}{\\partial y^2} = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y) $$\nThe Laplacian of $T_{exact}$ is:\n$$ \\nabla^2 T_{exact} = \\frac{\\partial^2 T_{exact}}{\\partial x^2} + \\frac{\\partial^2 T_{exact}}{\\partial y^2} = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y) $$\nTherefore, the source term must be:\n$$ q(x,y) = -\\nabla^2 T_{exact} = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y) $$\nDirichlet boundary conditions are imposed on all four boundaries of the unit square ($\\partial\\Omega$) and are taken from the exact solution.\n$$ T(x,y) = T_{exact}(x,y) \\quad \\text{for } (x,y) \\in \\partial\\Omega $$\nOn the boundaries $x=0$, $x=1$, $y=0$, and $y=1$, the exact solution evaluates to zero:\n$$ T(0,y) = \\sin(0)\\sin(\\pi y) = 0 $$\n$$ T(1,y) = \\sin(\\pi)\\sin(\\pi y) = 0 $$\n$$ T(x,0) = \\sin(\\pi x)\\sin(0) = 0 $$\n$$ T(x,1) = \\sin(\\pi x)\\sin(\\pi) = 0 $$\nThus, we have homogeneous Dirichlet boundary conditions on the entire boundary.\n\n### 2. Finite Difference Discretization\n\nThe domain is discretized using a uniform Cartesian grid with $n$ interior points in each direction. The grid spacing is $h = 1/(n+1)$. The grid points are $(x_i, y_j)$, where $x_i = ih$ and $y_j = jh$ for $i,j \\in \\{0, 1, \\dots, n+1\\}$. The interior points correspond to indices $i,j \\in \\{1, 2, \\dots, n\\}$. Let $T_{i,j}$ be the numerical approximation of $T(x_i, y_j)$.\n\nThe second partial derivatives are approximated using second-order central difference formulas. These are derived from Taylor series expansions around $(x_i, y_j)$:\n$$ T(x_i \\pm h, y_j) = T(x_i, y_j) \\pm h \\frac{\\partial T}{\\partial x} + \\frac{h^2}{2} \\frac{\\partial^2 T}{\\partial x^2} \\pm \\frac{h^3}{6} \\frac{\\partial^3 T}{\\partial x^3} + \\mathcal{O}(h^4) $$\nAdding the expansions for $+h$ and $-h$ yields:\n$$ T(x_i+h, y_j) + T(x_i-h, y_j) = 2T(x_i, y_j) + h^2 \\frac{\\partial^2 T}{\\partial x^2} + \\mathcal{O}(h^4) $$\nRearranging for the second derivative gives the second-order accurate approximation:\n$$ \\left.\\frac{\\partial^2 T}{\\partial x^2}\\right|_{(x_i,y_j)} = \\frac{T_{i-1,j} - 2T_{i,j} + T_{i+1,j}}{h^2} + \\mathcal{O}(h^2) $$\nSimilarly for the $y$-direction:\n$$ \\left.\\frac{\\partial^2 T}{\\partial y^2}\\right|_{(x_i,y_j)} = \\frac{T_{i,j-1} - 2T_{i,j} + T_{i,j+1}}{h^2} + \\mathcal{O}(h^2) $$\nSubstituting these approximations into the governing equation $-\\nabla^2 T = q$ at an interior grid point $(x_i, y_j)$ yields the discrete equation:\n$$ -\\left( \\frac{T_{i-1,j} - 2T_{i,j} + T_{i+1,j}}{h^2} + \\frac{T_{i,j-1} - 2T_{i,j} + T_{i,j+1}}{h^2} \\right) = q_{i,j} $$\nwhere $q_{i,j} = q(x_i, y_j)$. Rearranging gives the five-point stencil equation:\n$$ 4T_{i,j} - T_{i-1,j} - T_{i+1,j} - T_{i,j-1} - T_{i,j+1} = h^2 q_{i,j} $$\nThis equation is valid for all interior points, i.e., for $i,j \\in \\{1, 2, \\dots, n\\}$.\n\n### 3. Linear System of Equations\n\nThe $n^2$ discrete equations for the $n^2$ unknown interior temperatures $\\{T_{i,j}\\}$ form a linear system of equations, $A\\vec{T} = \\vec{b}$. The unknowns are ordered into a single vector $\\vec{T}$ of length $N=n^2$. We use a row-major mapping, where the index $k$ for the grid point $(i,j)$ is $k = (j-1)n + (i-1)$ for $k \\in \\{0, 1, \\dots, N-1\\}$.\n\nThe matrix $A$ is an $N \\times N$ sparse matrix. Each row $k$ corresponds to the discrete equation at point $(i,j)$. The equation $4T_{i,j} - T_{i-1,j} - T_{i+1,j} - T_{i,j-1} - T_{i,j+1} = h^2 q_{i,j}$ leads to the following matrix entries for row $k$:\n- $A_{k,k} = 4$\n- $A_{k, k-1} = -1$ (for neighbor $(i-1,j)$, if $i>1$)\n- $A_{k, k+1} = -1$ (for neighbor $(i+1,j)$, if $i<n$)\n- $A_{k, k-n} = -1$ (for neighbor $(i,j-1)$, if $j>1$)\n- $A_{k, k+n} = -1$ (for neighbor $(i,j+1)$, if $j<n$)\n\nIf a neighbor is on the boundary (e.g., $i-1=0$), its temperature $T_{0,j}$ is known from the Dirichlet boundary condition. In this problem, all boundary values are zero, so these terms simply vanish and do not contribute to the right-hand side vector $\\vec{b}$.\nThe right-hand side vector $\\vec{b}$ has components $b_k = h^2 q_{i,j} = h^2 (2\\pi^2 \\sin(\\pi x_i) \\sin(\\pi y_j))$.\nThe resulting matrix $A$ is a symmetric positive-definite block tridiagonal matrix. This system can be solved efficiently for the vector of numerical temperatures $\\vec{T}_{num}$.\n\n### 4. Error Analysis and Convergence Order\n\nAfter solving the system, the numerical solution vector $\\vec{T}_{num}$ is reshaped into an $n \\times n$ grid. The error at each interior grid point is calculated as the difference between the numerical and exact solutions:\n$$ e_{ij} = T_{ij}^\\text{numerical} - T_{exact}(x_i, y_j) $$\nTwo discrete error norms are computed:\n- The discrete $L_\\infty$ norm (maximum error):\n$$ E_\\infty = \\max_{1 \\le i,j \\le n} |e_{ij}| $$\n- The discrete $L_2$ norm:\n$$ E_2 = \\left( \\sum_{i=1}^n \\sum_{j=1}^n |e_{ij}|^2 h^2 \\right)^{1/2} $$\nThe order of convergence, $p$, is computed to verify that the numerical scheme is second-order accurate ($p \\approx 2$). Given the errors $E_\\text{coarse}$ and $E_\\text{fine}$ on two successive grids with grid spacings $h_\\text{coarse}$ and $h_\\text{fine}$, the observed order is:\n$$ p = \\frac{\\log(E_\\text{coarse} / E_\\text{fine})}{\\log(h_\\text{coarse} / h_\\text{fine})} $$\nThe computational procedure involves solving the system for a sequence of refined grids ($n=4, 8, 16, 32, 64$) and computing $p$ for each successive pair of grids for both error norms.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\nimport math\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to solve the 2D Poisson problem and compute convergence orders.\n    \"\"\"\n\n    def solve_poisson(n: int) -> tuple[float, float, float]:\n        \"\"\"\n        Solves the 2D Poisson equation on a unit square for a given grid size.\n\n        Args:\n            n: The number of interior grid points in each direction.\n\n        Returns:\n            A tuple containing:\n            - h (float): The grid spacing.\n            - l2_error (float): The discrete L2 norm of the error.\n            - linf_error (float): The discrete L_infinity norm of the error.\n        \"\"\"\n        # 1. Define grid parameters\n        h = 1.0 / (n + 1)\n        N = n * n  # Total number of interior points (unknowns)\n\n        # 2. Create grid coordinates for interior points\n        # Grid points are at x_i = i*h, y_j = j*h for i,j in {1,...,n}\n        grid_pts = np.arange(1, n + 1) * h\n        # Use 'ij' indexing so that X[j, i] = x_i and Y[j, i] = y_j\n        X, Y = np.meshgrid(grid_pts, grid_pts, indexing='ij')\n\n        # 3. Assemble the right-hand side (RHS) vector `b`\n        # q(x,y) = 2 * pi^2 * sin(pi*x) * sin(pi*y)\n        # b = h^2 * q, flattened in row-major order\n        q_grid = 2 * (np.pi**2) * np.sin(np.pi * X) * np.sin(np.pi * Y)\n        b = (h**2) * q_grid.flatten()\n\n        # 4. Assemble the sparse matrix A for the negative Laplacian\n        # The equation is 4*T_ij - T_i-1,j - T_i+1,j - T_i,j-1 - T_i,j+1 = b_ij\n        # This structure results in a matrix with 5 non-zero diagonals.\n        \n        main_diag = np.full(N, 4.0)\n        \n        # Off-diagonal for x-neighbors (k -> k+/-1)\n        # Need to zero out entries that cross row boundaries\n        off_diag_1 = np.full(N - 1, -1.0)\n        off_diag_1[n-1::n] = 0.0\n        \n        # Off-diagonal for y-neighbors (k -> k+/-n)\n        off_diag_n = np.full(N - n, -1.0)\n        \n        diagonals = [main_diag, off_diag_1, off_diag_1, off_diag_n, off_diag_n]\n        offsets = [0, 1, -1, n, -n]\n        \n        A = diags(diagonals, offsets, shape=(N, N), format='csr')\n\n        # 5. Solve the linear system A * T_vec = b\n        T_vec_num = spsolve(A, b)\n\n        # 6. Compute the error\n        # Reshape the numerical solution to the 2D grid\n        T_grid_num = T_vec_num.reshape((n, n))\n        \n        # Get the exact solution at the interior grid points\n        T_grid_exact = np.sin(np.pi * X) * np.sin(np.pi * Y)\n        \n        # Compute the error grid\n        error_grid = T_grid_num - T_grid_exact\n\n        # 7. Calculate error norms\n        # L-infinity norm\n        linf_error = np.abs(error_grid).max()\n        \n        # L2 norm: sqrt(sum(|e_ij|^2 * h^2)) = h * sqrt(sum(|e_ij|^2))\n        # np.linalg.norm(error_grid) computes the Frobenius norm, which is sqrt(sum(|e_ij|^2))\n        l2_error = h * np.linalg.norm(error_grid)\n        \n        return h, l2_error, linf_error\n\n    # Test suite parameters\n    n_values = [4, 8, 16, 32, 64]\n    errors = {}\n\n    # Calculate errors for each grid size\n    for n in n_values:\n        h, l2_err, linf_err = solve_poisson(n)\n        errors[n] = {'h': h, 'l2': l2_err, 'linf': linf_err}\n\n    # Compute observed convergence orders\n    p_l2_list = []\n    p_linf_list = []\n    \n    for i in range(len(n_values) - 1):\n        n_coarse = n_values[i]\n        n_fine = n_values[i+1]\n        \n        # Get errors and grid spacings\n        e_coarse_l2 = errors[n_coarse]['l2']\n        e_fine_l2 = errors[n_fine]['l2']\n        \n        e_coarse_linf = errors[n_coarse]['linf']\n        e_fine_linf = errors[n_fine]['linf']\n        \n        h_coarse = errors[n_coarse]['h']\n        h_fine = errors[n_fine]['h']\n\n        # Calculate observed order p = log(E_c/E_f) / log(h_c/h_f)\n        p_l2 = math.log(e_coarse_l2 / e_fine_l2) / math.log(h_coarse / h_fine)\n        p_linf = math.log(e_coarse_linf / e_fine_linf) / math.log(h_coarse / h_fine)\n        \n        p_l2_list.append(p_l2)\n        p_linf_list.append(p_linf)\n\n    # Combine results into the final list in the specified order\n    final_results = p_l2_list + p_linf_list\n\n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world scenarios rarely have simple temperature-specified boundaries everywhere; often, heat flux (a Neumann condition) is specified instead. This exercise extends our solver to handle mixed Dirichlet-Neumann boundary conditions, a critical capability for practical simulations. You will derive and implement second-order accurate one-sided stencils for the flux conditions and validate your implementation using a polynomial manufactured solution, which reveals an important property of finite difference approximations .",
            "id": "3952893",
            "problem": "Consider two-dimensional steady heat conduction with a constant, isotropic thermal conductivity $k$ in a rectangular domain $\\Omega = [0,1] \\times [0,1]$. Let the volumetric source be represented by $S(x,y)$, and the temperature field by $T(x,y)$. The governing equation is derived from conservation of energy together with Fourier’s law of conduction, namely\n$$\n- \\nabla \\cdot \\left( k \\nabla T \\right) = S(x,y),\n$$\nwith $k$ constant and equal to $k = 1$ (dimensionless units), so the equation reduces to\n$$\n- \\Delta T = S(x,y).\n$$\nYou are to validate mixed boundary treatments in the finite difference method by using a manufactured exact polynomial solution. Define the exact temperature field\n$$\nT_{\\mathrm{exact}}(x,y) = 1 + x - 2y + \\tfrac{1}{2} x^2 + xy + y^2,\n$$\nand construct the source term $S(x,y)$ by substituting $T_{\\mathrm{exact}}(x,y)$ into the governing equation as required by the differential operator. The boundary conditions are mixed Dirichlet–Neumann on the four sides of $\\Omega$:\n- On the left edge $x = 0$ and the bottom edge $y = 0$, impose Dirichlet temperature:\n$$\nT(x=0,y) = T_{\\mathrm{exact}}(0,y), \\quad T(x,y=0) = T_{\\mathrm{exact}}(x,0).\n$$\n- On the right edge $x = 1$, impose the outward normal derivative (Neumann) corresponding to the exact field:\n$$\n\\frac{\\partial T}{\\partial n}\\bigg|_{x=1} = \\frac{\\partial T}{\\partial x}\\bigg|_{x=1} = \\frac{\\partial T_{\\mathrm{exact}}}{\\partial x}(1,y).\n$$\n- On the top edge $y = 1$, impose the outward normal derivative (Neumann) corresponding to the exact field:\n$$\n\\frac{\\partial T}{\\partial n}\\bigg|_{y=1} = \\frac{\\partial T}{\\partial y}\\bigg|_{y=1} = \\frac{\\partial T_{\\mathrm{exact}}}{\\partial y}(x,1).\n$$\nAll quantities are dimensionless, and the dependent variable $T$ is to be reported in dimensionless units.\n\nDiscretize the domain $\\Omega$ by a uniform grid with $N_x$ nodes in the $x$-direction and $N_y$ nodes in the $y$-direction, with uniform spacings $h_x = 1/(N_x-1)$ and $h_y = 1/(N_y-1)$. Derive a finite difference method based on the following principles, starting from the fundamental laws and definitions:\n- Use the discrete form arising from the governing equation and Taylor-series-based central differences to approximate the Laplacian at interior nodes, achieving second-order accuracy in $h_x$ and $h_y$.\n- Enforce the Dirichlet boundary conditions by directly setting the temperature equal to the exact boundary value at the corresponding grid nodes.\n- Enforce Neumann boundary conditions using outward-normal, one-sided finite difference approximations that are second-order accurate with respect to the grid spacing, derived from Taylor expansions. At the corner where the right and top boundaries meet, apply a single Neumann equation (choose one orientation to avoid overconstraining that node).\n\nConstruct a linear system whose unknowns are the temperatures at all grid nodes, including the boundary nodes. Solve this linear system to obtain the numerical approximation $T_{\\mathrm{num}}(x_i,y_j)$ on the grid. Compute the error $E_{i,j} = T_{\\mathrm{num}}(x_i,y_j) - T_{\\mathrm{exact}}(x_i,y_j)$ and report the following error norms separately over the interior and over the boundary sets of nodes:\n- The interior set consists of all nodes with $1 \\le i \\le N_x - 2$ and $1 \\le j \\le N_y - 2$.\n- The boundary set consists of all nodes with $i \\in \\{0, N_x - 1\\}$ or $j \\in \\{0, N_y - 1\\}$.\n\nFor each set, compute:\n- The discrete root-mean-square (RMS) error,\n$$\n\\mathrm{RMS} = \\sqrt{\\frac{1}{M}\\sum_{(i,j) \\in \\mathcal{S}} E_{i,j}^2 },\n$$\nwhere $\\mathcal{S}$ is the chosen set (interior or boundary) and $M$ is the cardinality of that set.\n- The discrete maximum (infinity) norm error,\n$$\n\\|E\\|_{\\infty} = \\max_{(i,j) \\in \\mathcal{S}} |E_{i,j}|.\n$$\n\nImplement the algorithm as a complete, runnable program that constructs the linear system, solves for $T_{\\mathrm{num}}$, and computes the requested norms for each of the test cases listed below. All calculations are dimensionless. No angles or percentages are involved.\n\nTest suite:\n- Case A (happy path): $N_x = 21$, $N_y = 21$.\n- Case B (moderate rectangular grid): $N_x = 5$, $N_y = 7$.\n- Case C (minimal grid supporting second-order one-sided Neumann stencils): $N_x = 3$, $N_y = 3$.\n- Case D (stretched grid): $N_x = 33$, $N_y = 9$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist of four floats in the order\n$$\n\\left[\\mathrm{RMS\\_interior},\\ \\mathrm{L\\infty\\_interior},\\ \\mathrm{RMS\\_boundary},\\ \\mathrm{L\\infty\\_boundary}\\right].\n$$\nThus, the final output must be of the form\n$$\n\\left[\\left[r_1,\\ell_1,b_1,B_1\\right],\\left[r_2,\\ell_2,b_2,B_2\\right],\\left[r_3,\\ell_3,b_3,B_3\\right],\\left[r_4,\\ell_4,b_4,B_4\\right]\\right],\n$$\nwhere each $r_i$, $\\ell_i$, $b_i$, and $B_i$ is a float. The line must contain this single bracketed list and nothing else.",
            "solution": "The user has provided a well-posed problem in computational heat transfer. I will first validate the problem statement, then proceed with a full derivation and solution.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n\n-   **Governing Equation:** $- \\nabla \\cdot ( k \\nabla T ) = S(x,y)$ for two-dimensional steady-state heat conduction.\n-   **Domain:** A unit square, $\\Omega = [0,1] \\times [0,1]$.\n-   **Thermal Conductivity:** $k = 1$ (constant, isotropic, dimensionless).\n-   **Simplified Governing Equation:** $- \\Delta T = S(x,y)$, which is the Poisson equation.\n-   **Manufactured Exact Solution:** $T_{\\mathrm{exact}}(x,y) = 1 + x - 2y + \\frac{1}{2} x^2 + xy + y^2$.\n-   **Source Term:** $S(x,y)$ is to be derived from $T_{\\mathrm{exact}}(x,y)$.\n-   **Boundary Conditions (BCs):**\n    -   Dirichlet on the left edge ($x=0$): $T(0,y) = T_{\\mathrm{exact}}(0,y)$.\n    -   Dirichlet on the bottom edge ($y=0$): $T(x,0) = T_{\\mathrm{exact}}(x,0)$.\n    -   Neumann on the right edge ($x=1$): $\\frac{\\partial T}{\\partial n}\\big|_{x=1} = \\frac{\\partial T}{\\partial x}\\big|_{x=1} = \\frac{\\partial T_{\\mathrm{exact}}}{\\partial x}(1,y)$.\n    -   Neumann on the top edge ($y=1$): $\\frac{\\partial T}{\\partial n}\\big|_{y=1} = \\frac{\\partial T}{\\partial y}\\big|_{y=1} = \\frac{\\partial T_{\\mathrm{exact}}}{\\partial y}(x,1)$.\n-   **Discretization:** Uniform grid with $N_x \\times N_y$ nodes. Spacings are $h_x = 1/(N_x-1)$ and $h_y = 1/(N_y-1)$.\n-   **Numerical Method:**\n    -   Interior nodes: Second-order central differences for the Laplacian.\n    -   Dirichlet nodes: Direct value assignment.\n    -   Neumann nodes: Second-order one-sided differences.\n    -   Corner node $(1,1)$: A single Neumann equation is to be applied.\n-   **System of Equations:** A linear system for all nodal temperatures.\n-   **Error Analysis:** Compute RMS and $L_\\infty$ norms of the error $E_{i,j} = T_{\\mathrm{num}}(x_i,y_j) - T_{\\mathrm{exact}}(x_i,y_j)$ separately for interior and boundary nodes.\n-   **Test Cases:** (A) $N_x=21, N_y=21$; (B) $N_x=5, N_y=7$; (C) $N_x=3, N_y=3$; (D) $N_x=33, N_y=9$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is assessed against the validation criteria.\n\n-   **Scientifically Grounded:** The problem is based on the fundamental principles of heat conduction, governed by the Poisson equation. The method of manufactured solutions is a standard, rigorous technique for the verification of numerical codes. The problem is scientifically and mathematically sound.\n-   **Well-Posed:** The elliptic partial differential equation on a closed domain with a combination of Dirichlet and Neumann boundary conditions (a mixed boundary value problem) is well-posed, guaranteeing a unique and stable solution. The numerical scheme is standard and leads to a solvable linear system.\n-   **Objective:** The problem is stated with precise mathematical definitions and objective language.\n-   **Completeness and Consistency:** The problem is self-contained. All necessary information to construct and solve the problem is provided. The instruction to use a single Neumann equation at the mixed-Neumann corner $(1,1)$ correctly avoids over-constraining the system. The minimum grid size for Case C is consistent with the requirements of the second-order one-sided stencil.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is a well-defined, standard verification problem in computational engineering. I will proceed to derive and implement the solution.\n\n### **Principle-Based Solution**\n\n**1. Formulation of the problem**\n\nFirst, we must derive the source term $S(x,y)$ and the functions for the boundary conditions from the given exact solution $T_{\\mathrm{exact}}(x,y) = 1 + x - 2y + \\frac{1}{2} x^2 + xy + y^2$.\n\nThe first partial derivatives are:\n$$\n\\frac{\\partial T_{\\mathrm{exact}}}{\\partial x} = 1 + x + y\n$$\n$$\n\\frac{\\partial T_{\\mathrm{exact}}}{\\partial y} = -2 + x + 2y\n$$\nThe second partial derivatives are:\n$$\n\\frac{\\partial^2 T_{\\mathrm{exact}}}{\\partial x^2} = 1\n$$\n$$\n\\frac{\\partial^2 T_{\\mathrm{exact}}}{\\partial y^2} = 2\n$$\nThe Laplacian is $\\Delta T_{\\mathrm{exact}} = \\frac{\\partial^2 T_{\\mathrm{exact}}}{\\partial x^2} + \\frac{\\partial^2 T_{\\mathrm{exact}}}{\\partial y^2} = 1 + 2 = 3$.\nFrom the governing equation, $-\\Delta T = S(x,y)$, the source term is $S(x,y) = -\\Delta T_{\\mathrm{exact}} = -3$. This is a constant source.\n\nThe boundary conditions are:\n-   **Left ($x=0$):** $T(0,y) = T_{\\mathrm{exact}}(0,y) = 1 - 2y + y^2 = (1-y)^2$.\n-   **Bottom ($y=0$):** $T(x,0) = T_{\\mathrm{exact}}(x,0) = 1 + x + \\frac{1}{2}x^2$.\n-   **Right ($x=1$):** $\\frac{\\partial T}{\\partial x}(1,y) = \\frac{\\partial T_{\\mathrm{exact}}}{\\partial x}(1,y) = 1 + 1 + y = 2+y$. Let's call this $g_R(y)$.\n-   **Top ($y=1$):** $\\frac{\\partial T}{\\partial y}(x,1) = \\frac{\\partial T_{\\mathrm{exact}}}{\\partial y}(x,1) = -2 + x + 2(1) = x$. Let's call this $g_T(x)$.\n\n**2. Discretization and Linear System Construction**\n\nThe domain is discretized into a grid of $N_x \\times N_y$ nodes. The temperature at each node $(x_i, y_j) = (i h_x, j h_y)$ is denoted $T_{i,j}$. The $N_x N_y$ unknown nodal temperatures are arranged into a single vector $\\mathbf{T}$ of length $N = N_x N_y$. We use a row-major mapping, where the 2D grid index $(i,j)$ (with $i \\in [0, N_x-1], j \\in [0, N_y-1]$) maps to the 1D vector index $k = i + j N_x$. The problem is to find $\\mathbf{T}$ by solving the linear system $A\\mathbf{T} = \\mathbf{b}$. We construct the matrix $A$ and vector $\\mathbf{b}$ by writing one equation for each node.\n\n-   **Interior Nodes ($1 \\le i \\le N_x-2, 1 \\le j \\le N_y-2$):**\n    The equation $-\\Delta T = S$ is discretized using second-order central differences for the Laplacian:\n    $$\n    -\\left( \\frac{T_{i+1,j} - 2T_{i,j} + T_{i-1,j}}{h_x^2} + \\frac{T_{i,j+1} - 2T_{i,j} + T_{i,j-1}}{h_y^2} \\right) = S(x_i, y_j) = -3\n    $$\n    Rearranging gives the stencil for the matrix row corresponding to node $(i,j)$:\n    $$\n    \\left(\\frac{2}{h_x^2} + \\frac{2}{h_y^2}\\right)T_{i,j} - \\frac{1}{h_x^2}T_{i-1,j} - \\frac{1}{h_x^2}T_{i+1,j} - \\frac{1}{h_y^2}T_{i,j-1} - \\frac{1}{h_y^2}T_{i,j+1} = -3\n    $$\n\n-   **Dirichlet Boundary Nodes:**\n    -   **Left ($i=0, \\forall j$):** The equation is simply $T_{0,j} = T_{\\mathrm{exact}}(0, y_j) = (1-y_j)^2$. In the linear system, this corresponds to a row with a $1$ on the diagonal and the value $(1-y_j)^2$ in the $\\mathbf{b}$ vector.\n    -   **Bottom ($j=0, i > 0$):** Similarly, $T_{i,0} = T_{\\mathrm{exact}}(x_i, 0) = 1 + x_i + \\frac{1}{2}x_i^2$. The Dirichlet condition on the left boundary takes precedence at the corner $(0,0)$.\n\n-   **Neumann Boundary Nodes:** We use second-order accurate one-sided (backward) finite difference formulas.\n    -   **Right ($i=N_x-1, 0 < j < N_y-1$):** The condition is $\\frac{\\partial T}{\\partial x} = g_R(y_j)$. The stencil is:\n        $$\n        \\frac{3T_{N_x-1,j} - 4T_{N_x-2,j} + T_{N_x-3,j}}{2 h_x} = 2+y_j\n        $$\n    -   **Top ($j=N_y-1, 0 < i < N_x-1$):** The condition is $\\frac{\\partial T}{\\partial y} = g_T(x_i)$. The stencil is:\n        $$\n        \\frac{3T_{i,N_y-1} - 4T_{i,N_y-2} + T_{i,N_y-3}}{2 h_y} = x_i\n        $$\n\n-   **Corner Nodes:**\n    -   Corners with at least one Dirichlet boundary ($(0,0), (1,0), (0,1)$) have their temperature directly set by the Dirichlet condition.\n    -   **Corner $(1,1)$ (or $(N_x-1, N_y-1)$ in indices):** This node has two Neumann conditions. As instructed, we apply only one to avoid over-constraining the system. We will consistently use the stencil for the top boundary, extended to include the corner $i=N_x-1$:\n        $$\n        \\frac{3T_{N_x-1,N_y-1} - 4T_{N_x-1,N_y-2} + T_{N_x-1,N_y-3}}{2 h_y} = x_{N_x-1} = 1\n        $$\n        This choice is arbitrary but sufficient.\n\n**3. Solution and Error Analysis**\n\nAn important observation for this problem is that the exact solution $T_{\\mathrm{exact}}$ is a quadratic polynomial. The finite difference stencils chosen (second-order central for the Laplacian, second-order one-sided for the first derivative) are known to be exact for polynomials of degree up to 3 and 2, respectively. Specifically, the truncation error for these stencils involves third or fourth derivatives of the function, which are zero for a quadratic polynomial. Consequently, the discrete equations are satisfied exactly by the values of $T_{\\mathrm{exact}}$ at the grid nodes.\n\nTherefore, the vector of exact temperatures $\\mathbf{T}_{\\mathrm{exact}}$ is a solution to the linear system $A\\mathbf{T} = \\mathbf{b}$. Since the system is well-posed and has a unique solution, the numerical solution $\\mathbf{T}_{\\mathrm{num}}$ obtained by solving the system must be identical to $\\mathbf{T}_{\\mathrm{exact}}$, up to the limits of floating-point precision. The expected error, $E_{i,j} = T_{\\mathrm{num}}(x_i,y_j) - T_{\\mathrm{exact}}(x_i,y_j)$, should be on the order of machine epsilon (approximately $10^{-15}$). All error norms (RMS and $L_{\\infty}$), for both interior and boundary nodes, are expected to be very close to zero.\n\nThe error metrics are computed over two sets of nodes:\n-   **Interior set $\\mathcal{S}_{\\mathrm{int}}$:** Nodes $(i,j)$ where $1 \\le i \\le N_x-2$ and $1 \\le j \\le N_y-2$.\n-   **Boundary set $\\mathcal{S}_{\\mathrm{bound}}$:** All other nodes.\n\nFor each set $\\mathcal{S}$ with cardinality $M$:\n-   The Root-Mean-Square (RMS) error: $\\mathrm{RMS} = \\sqrt{\\frac{1}{M}\\sum_{(i,j) \\in \\mathcal{S}} E_{i,j}^2 }$.\n-   The maximum ($L_\\infty$) norm error: $\\|E\\|_{\\infty} = \\max_{(i,j) \\in \\mathcal{S}} |E_{i,j}|$.\n\nThe following implementation builds and solves the linear system for each test case and computes these four error metrics.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (21, 21),  # Case A\n        (5, 7),    # Case B\n        (3, 3),    # Case C\n        (33, 9),   # Case D\n    ]\n\n    all_results = []\n    for nx, ny in test_cases:\n        result = compute_for_case(nx, ny)\n        all_results.append(list(result))\n\n    # Format the output as a single string: [[r1,l1,b1,B1], [r2,l2,b2,B2], ...]\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef compute_for_case(Nx, Ny):\n    \"\"\"\n    Solves the 2D Poisson problem for a given grid size (Nx, Ny)\n    and computes the error norms.\n    \"\"\"\n    hx = 1.0 / (Nx - 1) if Nx > 1 else 0.0\n    hy = 1.0 / (Ny - 1) if Ny > 1 else 0.0\n    N_nodes = Nx * Ny\n\n    A = np.zeros((N_nodes, N_nodes))\n    b = np.zeros(N_nodes)\n\n    x_coords = np.linspace(0.0, 1.0, Nx)\n    y_coords = np.linspace(0.0, 1.0, Ny)\n\n    # Helper functions for exact solution and BCs\n    def t_exact(x, y):\n        return 1.0 + x - 2.0*y + 0.5*x**2 + x*y + y**2\n\n    # Assemble the matrix A and vector b\n    for j in range(Ny):\n        for i in range(Nx):\n            k = i + j * Nx  # Row-major 1D index\n\n            is_left = (i == 0)\n            is_right = (i == Nx - 1)\n            is_bottom = (j == 0)\n            is_top = (j == Ny - 1)\n\n            # Dirichlet BCs (highest priority)\n            if is_left:\n                A[k, k] = 1.0\n                b[k] = (1.0 - y_coords[j])**2\n            elif is_bottom:\n                A[k, k] = 1.0\n                b[k] = 1.0 + x_coords[i] + 0.5 * x_coords[i]**2\n            \n            # Neumann BCs\n            elif is_top: # Top BC takes precedence at the (Nx-1, Ny-1) corner\n                # 2nd-order backward difference for dy\n                k1 = i + (j-1)*Nx\n                k2 = i + (j-2)*Nx\n                A[k, k]   = 3.0 / (2.0 * hy)\n                A[k, k1]  = -4.0 / (2.0 * hy)\n                A[k, k2]  = 1.0 / (2.0 * hy)\n                b[k] = x_coords[i]   # dT/dy(x,1) = x\n            elif is_right:\n                # 2nd-order backward difference for dx\n                k1 = (i-1) + j*Nx\n                k2 = (i-2) + j*Nx\n                A[k, k]   = 3.0 / (2.0 * hx)\n                A[k, k1]  = -4.0 / (2.0 * hx)\n                A[k, k2]  = 1.0 / (2.0 * hx)\n                b[k] = 2.0 + y_coords[j] # dT/dx(1,y) = 2+y\n\n            # Interior nodes\n            else:\n                # -Laplacian(T) = -3\n                k_up = i + (j + 1) * Nx\n                k_down = i + (j - 1) * Nx\n                k_right = (i + 1) + j * Nx\n                k_left = (i - 1) + j * Nx\n                \n                A[k, k] = 2.0/hx**2 + 2.0/hy**2\n                A[k, k_right] = -1.0/hx**2\n                A[k, k_left]  = -1.0/hx**2\n                A[k, k_up]    = -1.0/hy**2\n                A[k, k_down]  = -1.0/hy**2\n                b[k] = -3.0\n\n    # Solve the linear system\n    T_vec = np.linalg.solve(A, b)\n    T_num = T_vec.reshape((Ny, Nx))\n\n    # Calculate exact solution on the grid\n    X, Y = np.meshgrid(x_coords, y_coords)\n    T_ex = t_exact(X, Y)\n\n    # Calculate the error\n    E = T_num - T_ex\n\n    # Calculate error norms for interior and boundary nodes\n    # Interior nodes (1 <= i <= Nx-2, 1 <= j <= Ny-2)\n    if Nx > 2 and Ny > 2:\n        E_interior = E[1:-1, 1:-1]\n        rms_interior = np.sqrt(np.mean(E_interior**2))\n        linf_interior = np.max(np.abs(E_interior))\n    else: # No interior nodes\n        rms_interior = 0.0\n        linf_interior = 0.0\n\n    # Boundary nodes\n    mask_boundary = np.ones_like(E, dtype=bool)\n    if Nx > 2 and Ny > 2:\n        mask_boundary[1:-1, 1:-1] = False\n    \n    E_boundary = E[mask_boundary]\n    \n    if E_boundary.size > 0:\n        rms_boundary = np.sqrt(np.mean(E_boundary**2))\n        linf_boundary = np.max(np.abs(E_boundary))\n    else: # Should not happen for given cases\n        rms_boundary = 0.0\n        linf_boundary = 0.0\n\n    return rms_interior, linf_interior, rms_boundary, linf_boundary\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "Discretizing a partial differential equation results in a large system of linear equations, and solving it efficiently is paramount, especially for fine grids. This practice moves beyond basic direct solvers to the implementation of the red-black Gauss-Seidel method, an iterative technique optimized for parallelism. You will learn how the checkerboard coloring of the grid decouples dependencies, allowing for faster computation, and explore the convergence properties of this powerful solver in the context of the underlying physics .",
            "id": "3952957",
            "problem": "Consider the two-dimensional steady heat conduction problem for a homogeneous material with constant thermal conductivity, modeled by the Poisson equation derived from conservation of energy and Fourier’s law. Let the temperature field be $T(x,y)$ over a rectangular domain $\\Omega = [0,L_x] \\times [0,L_y]$. With volumetric source density per conductivity defined by $f(x,y)$, the governing equation is\n$$\n\\nabla^2 T(x,y) = - f(x,y),\n$$\nsubject to Dirichlet boundary conditions $T(x,y) = g(x,y)$ on $\\partial \\Omega$. Angles in all trigonometric functions must be interpreted in radians. Temperature must be expressed in the unit Kelvin. Your task is to discretize this problem using the Finite Difference Method (FDM) on a uniform Cartesian grid and to solve the resulting linear system using a red-black Gauss–Seidel iterative method. You must additionally explain, starting from first principles, why the red-black coloring enhances parallelism and why the method retains convergence properties.\n\nStarting point requirements:\n- Begin from conservation of energy (steady state) and Fourier’s law for heat conduction to motivate the governing equation and its properties (such as symmetry and positive definiteness for the discrete system under Dirichlet boundary conditions).\n- Derive the central approximation of the Laplacian operator using Taylor expansions on a uniform grid with spacings $h_x$ and $h_y$ in the $x$ and $y$ directions, respectively, ensuring scientific consistency from first principles and well-tested formulas.\n- Develop the red-black Gauss–Seidel iteration by identifying the bipartite structure of the finite difference stencil graph on the grid and establishing the independence of nodes in the same color set during a sweep, and justify convergence in terms of matrix splitting for symmetric positive definite systems.\n\nImplementation requirements:\n- The program must assemble the discrete Poisson operator with five-point stencil on a uniform grid, impose Dirichlet boundary values, and iterate using red-black Gauss–Seidel until a stopping criterion based on the discrete residual norm is met or a maximum number of iterations is reached.\n- The discrete residual at interior nodes $(i,j)$ must be evaluated as\n$$\nr_{i,j} = \\frac{T_{i-1,j} - 2 T_{i,j} + T_{i+1,j}}{h_x^2} + \\frac{T_{i,j-1} - 2 T_{i,j} + T_{i,j+1}}{h_y^2} + f_{i,j},\n$$\nand the stopping criterion must be $\\max_{i,j} |r_{i,j}| < \\varepsilon$, where $\\varepsilon$ is a prescribed tolerance.\n\nTest suite:\nImplement and solve the following three test cases. In all cases, return the maximum absolute temperature error (in Kelvin) over all grid points compared to the exact solution. Use the specified tolerances and iteration limits.\n\n- Test case $1$ (happy path, square domain with manufactured solution):\n  - Domain parameters: $L_x = 1$, $L_y = 1$.\n  - Grid resolution: $N_x = 65$, $N_y = 65$ (total nodes per direction, including boundaries).\n  - Exact solution: $T(x,y) = \\sin(\\pi x)\\sin(\\pi y)$.\n  - Source term: $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$, so that $\\nabla^2 T = -f$ holds.\n  - Boundary data: $T(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ on $\\partial \\Omega$.\n  - Tolerance: $\\varepsilon = 10^{-8}$.\n  - Maximum iterations: $N_{\\text{max}} = 5000$.\n  - Output: maximum absolute error in Kelvin as a float.\n\n- Test case $2$ (boundary condition edge case, trivial solution):\n  - Domain parameters: $L_x = 1$, $L_y = 1$.\n  - Grid resolution: $N_x = 4$, $N_y = 4$.\n  - Exact solution: $T(x,y) = 0$.\n  - Source term: $f(x,y) = 0$.\n  - Boundary data: $T(x,y) = 0$ on $\\partial \\Omega$.\n  - Tolerance: $\\varepsilon = 10^{-12}$.\n  - Maximum iterations: $N_{\\text{max}} = 5000$.\n  - Output: maximum absolute error in Kelvin as a float.\n\n- Test case $3$ (rectangular domain with anisotropic grid spacings):\n  - Domain parameters: $L_x = 2$, $L_y = 1$.\n  - Grid resolution: $N_x = 63$, $N_y = 17$.\n  - Exact solution: $T(x,y) = \\sin\\!\\big(\\frac{\\pi x}{L_x}\\big)\\sin\\!\\big(\\frac{\\pi y}{L_y}\\big)$.\n  - Source term: $f(x,y) = \\Big(\\frac{\\pi^2}{L_x^2} + \\frac{\\pi^2}{L_y^2}\\Big) \\sin\\!\\big(\\frac{\\pi x}{L_x}\\big)\\sin\\!\\big(\\frac{\\pi y}{L_y}\\big)$, so that $\\nabla^2 T = -f$ holds.\n  - Boundary data: $T(x,y) = \\sin\\!\\big(\\frac{\\pi x}{L_x}\\big)\\sin\\!\\big(\\frac{\\pi y}{L_y}\\big)$ on $\\partial \\Omega$.\n  - Tolerance: $\\varepsilon = 10^{-8}$.\n  - Maximum iterations: $N_{\\text{max}} = 5000$.\n  - Output: maximum absolute error in Kelvin as a float.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3]$), where $r_1$, $r_2$, and $r_3$ are the maximum absolute temperature errors (in Kelvin) for Test cases $1$, $2$, and $3$, respectively. No additional text should be printed.",
            "solution": "The physical basis for the problem is the principle of conservation of energy applied to heat transfer. In a steady state, with no change in internal energy over time, the net rate of heat conducted into any control volume must balance the rate of heat generated within that volume. This balance is expressed mathematically as:\n$$\n-\\oint_{\\partial V} \\vec{q} \\cdot d\\vec{A} + \\int_V \\dot{q} \\, dV = 0\n$$\nHere, $\\vec{q}$ represents the heat flux vector in units of Watts per square meter ($W/m^2$), $\\dot{q}$ is the volumetric heat generation rate ($W/m^3$), $V$ is the control volume, and $\\partial V$ is its boundary surface. Applying the divergence theorem, we transform the surface integral into a volume integral, yielding $\\int_V (-\\nabla \\cdot \\vec{q} + \\dot{q}) \\, dV = 0$. Since this must hold for any arbitrary volume $V$, the integrand itself must be zero, leading to the differential form of the energy balance: $\\nabla \\cdot \\vec{q} = \\dot{q}$.\n\nThe relationship between heat flux and temperature is given by Fourier's Law of heat conduction, $\\vec{q} = -k \\nabla T$, where $k$ is the thermal conductivity of the material and $T$ is the temperature field. For a homogeneous material with constant thermal conductivity, substituting Fourier's Law into the energy balance gives $\\nabla \\cdot (-k \\nabla T) = \\dot{q}$, which simplifies to $-k \\nabla^2 T = \\dot{q}$. The Laplacian operator is $\\nabla^2 = \\nabla \\cdot \\nabla$. By defining a source term per unit conductivity, $f(x,y) = \\dot{q}/k$, we arrive at the governing Poisson equation for two-dimensional steady-state heat conduction:\n$$\n\\nabla^2 T(x,y) = - f(x,y)\n$$\nThis equation is to be solved over the rectangular domain $\\Omega = [0,L_x] \\times [0,L_y]$ subject to specified Dirichlet boundary conditions.\n\nTo solve this partial differential equation numerically, we employ the Finite Difference Method (FDM). We discretize the continuous domain $\\Omega$ into a uniform Cartesian grid of points $(x_i, y_j)$, where $x_i = i h_x$ for $i \\in \\{0, 1, \\dots, N_x-1\\}$ and $y_j = j h_y$ for $j \\in \\{0, 1, \\dots, N_y-1\\}$. The grid spacings are $h_x = L_x / (N_x - 1)$ and $h_y = L_y / (N_y - 1)$. The temperature at a grid point is denoted $T_{i,j} \\approx T(x_i, y_j)$. The partial derivatives in the Laplacian are approximated using central differences derived from Taylor series expansions. For the second partial derivative with respect to $x$ at $(x_i, y_j)$:\n$$\nT(x_i \\pm h_x, y_j) = T(x_i, y_j) \\pm h_x \\frac{\\partial T}{\\partial x} \\bigg|_{(i,j)} + \\frac{h_x^2}{2} \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{(i,j)} \\pm \\frac{h_x^3}{6} \\frac{\\partial^3 T}{\\partial x^3} \\bigg|_{(i,j)} + \\mathcal{O}(h_x^4)\n$$\nAdding the expansions for $+h_x$ and $-h_x$ cancels the odd-order derivative terms, leading to:\n$$\nT_{i+1,j} + T_{i-1,j} = 2T_{i,j} + h_x^2 \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{(i,j)} + \\mathcal{O}(h_x^4)\n$$\nRearranging gives the second-order accurate central difference approximation:\n$$\n\\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{(i,j)} \\approx \\frac{T_{i+1,j} - 2T_{i,j} + T_{i-1,j}}{h_x^2}\n$$\nA similar expression is found for the $y$-derivative. Substituting these into the Poisson equation yields the discrete equation at each interior node $(i,j)$:\n$$\n\\frac{T_{i+1,j} - 2T_{i,j} + T_{i-1,j}}{h_x^2} + \\frac{T_{i,j+1} - 2T_{i,j} + T_{i,j-1}}{h_y^2} + f_{i,j} = 0\n$$\nThis five-point stencil relates the temperature at a node to its four nearest neighbors. This forms a large, sparse system of linear equations, $A\\mathbf{T} = \\mathbf{b}$, for the unknown interior temperatures.\n\nThe red-black Gauss-Seidel method is an iterative technique for solving this linear system. It exploits the structure of the five-point stencil. The grid nodes are partitioned into two sets, \"red\" and \"black\", like a checkerboard: a node $(i,j)$ is red if $i+j$ is even, and black if $i+j$ is odd. The update formula for $T_{i,j}$, derived by isolating $T_{i,j}$ in the discrete equation, is:\n$$\nT_{i,j} = \\frac{1}{2(1/h_x^2 + 1/h_y^2)} \\left( \\frac{T_{i+1,j} + T_{i-1,j}}{h_x^2} + \\frac{T_{i,j+1} + T_{i,j-1}}{h_y^2} + f_{i,j} \\right)\n$$\nCrucially, the update for any node depends only on its four nearest neighbors, which are all of the opposite color. This bipartite structure means all red nodes can be updated simultaneously using only values from black nodes, and vice versa. This property is the basis for parallelism: a red-black Gauss-Seidel iteration proceeds in two stages. First, a \"red sweep\" updates all red nodes in parallel. Second, a \"black sweep\" updates all black nodes in parallel using the newly computed values at the red nodes.\n\nThe convergence of this iterative method is guaranteed because the matrix $A$ of the linear system is symmetric and positive definite (SPD) for Dirichlet boundary conditions. The symmetry of $A$ is a direct consequence of the symmetric nature of the central difference stencil. Positive definiteness can be demonstrated by showing that the quadratic form $\\mathbf{x}^T A \\mathbf{x}$ corresponds to the discrete Dirichlet energy, a sum of squared differences, which is positive for any non-trivial temperature field $\\mathbf{x}$ with zero on the boundaries. The Gauss-Seidel method, and any reordering of it like red-black, is proven to converge for any SPD matrix. The iteration continues until the discrete residual, $r_{i,j}$, is acceptably small. The residual measures how well the current solution $T^{(k)}$ satisfies the discrete equation:\n$$\nr_{i,j}^{(k)} = \\frac{T_{i-1,j}^{(k)} - 2 T_{i,j}^{(k)} + T_{i+1,j}^{(k)}}{h_x^2} + \\frac{T_{i,j-1}^{(k)} - 2 T_{i,j}^{(k)} + T_{i,j+1}^{(k)}}{h_y^2} + f_{i,j}\n$$\nThe stopping criterion is $\\max_{i,j} |r_{i,j}^{(k)}| < \\varepsilon$ for a given tolerance $\\varepsilon$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_poisson_solver(Lx, Ly, Nx, Ny, T_exact_func, f_func, epsilon, N_max):\n    \"\"\"\n    Solves the 2D Poisson equation using a red-black Gauss-Seidel iterative method.\n\n    Args:\n        Lx (float): Domain length in x-direction.\n        Ly (float): Domain length in y-direction.\n        Nx (int): Number of grid points in x-direction.\n        Ny (int): Number of grid points in y-direction.\n        T_exact_func (callable): Function T(X, Y) for the exact solution.\n        f_func (callable): Function f(X, Y) for the source term.\n        epsilon (float): Convergence tolerance for the residual.\n        N_max (int): Maximum number of iterations.\n\n    Returns:\n        float: Maximum absolute error between the numerical and exact solutions.\n    \"\"\"\n    # 1. Grid setup\n    x = np.linspace(0.0, Lx, Nx)\n    y = np.linspace(0.0, Ly, Ny)\n    hx = Lx / (Nx - 1)\n    hy = Ly / (Ny - 1)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Initialization\n    T_exact = T_exact_func(X, Y)\n    f = f_func(X, Y)\n    \n    # Initialize temperature field, with 0s for interior and BCs on boundary\n    T = np.zeros_like(T_exact)\n    T[0,  :] = T_exact[0,  :]\n    T[-1, :] = T_exact[-1, :]\n    T[:,  0] = T_exact[:,  0]\n    T[:, -1] = T_exact[:, -1]\n\n    # Pre-calculate constants for the update formula\n    inv_hx2 = 1.0 / (hx * hx)\n    inv_hy2 = 1.0 / (hy * hy)\n    denom = 2.0 * (inv_hx2 + inv_hy2)\n\n    # 3. Create red-black masks for the interior of the grid\n    # Indices for the interior grid slice [1:-1, 1:-1]\n    idx, idy = np.indices((Nx - 2, Ny - 2)) \n    # Red nodes: i+j is even. Note that indices are relative to the whole grid, \n    # so we use their original indices (idx+1, idy+1).\n    red_mask_interior = ((idx + 1) + (idy + 1)) % 2 == 0\n    black_mask_interior = np.logical_not(red_mask_interior)\n    \n    # 4. Iteration loop\n    for _ in range(N_max):\n        # --- Red Sweep ---\n        # Calculate update term for all interior points based on current T\n        T_update_term = ( (T[2:, 1:-1] + T[:-2, 1:-1]) * inv_hx2 + \\\n                          (T[1:-1, 2:] + T[1:-1, :-2]) * inv_hy2 + \\\n                          f[1:-1, 1:-1] ) / denom\n        # Apply update only to red points\n        T[1:-1, 1:-1][red_mask_interior] = T_update_term[red_mask_interior]\n\n        # --- Black Sweep ---\n        # Recalculate update term now that red points are updated\n        T_update_term = ( (T[2:, 1:-1] + T[:-2, 1:-1]) * inv_hx2 + \\\n                          (T[1:-1, 2:] + T[1:-1, :-2]) * inv_hy2 + \\\n                          f[1:-1, 1:-1] ) / denom\n        # Apply update only to black points\n        T[1:-1, 1:-1][black_mask_interior] = T_update_term[black_mask_interior]\n        \n        # 5. Check for convergence\n        if _ % 5 == 0: # Check residual every 5 iterations to save computation\n            residual = (T[2:, 1:-1] - 2*T[1:-1, 1:-1] + T[:-2, 1:-1]) * inv_hx2 + \\\n                       (T[1:-1, 2:] - 2*T[1:-1, 1:-1] + T[1:-1, :-2]) * inv_hy2 + \\\n                       f[1:-1, 1:-1]\n            max_residual = np.max(np.abs(residual))\n            if max_residual < epsilon:\n                break\n    \n    # 6. Calculate final error\n    max_abs_error = np.max(np.abs(T - T_exact))\n    return max_abs_error\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the results.\n    \"\"\"\n    pi = np.pi\n    test_cases = [\n        # Test case 1\n        {\n            \"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 65, \"Ny\": 65,\n            \"T_exact_func\": lambda X, Y: np.sin(pi * X) * np.sin(pi * Y),\n            \"f_func\": lambda X, Y: 2 * pi**2 * np.sin(pi * X) * np.sin(pi * Y),\n            \"epsilon\": 1e-8, \"N_max\": 5000,\n        },\n        # Test case 2\n        {\n            \"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 4, \"Ny\": 4,\n            \"T_exact_func\": lambda X, Y: 0.0 * X * Y, # Ensure correct shape\n            \"f_func\": lambda X, Y: 0.0 * X * Y,\n            \"epsilon\": 1e-12, \"N_max\": 5000,\n        },\n        # Test case 3\n        {\n            \"Lx\": 2.0, \"Ly\": 1.0, \"Nx\": 63, \"Ny\": 17,\n            \"T_exact_func\": lambda X, Y: np.sin(pi * X / 2.0) * np.sin(pi * Y / 1.0),\n            \"f_func\": lambda X, Y: ( (pi/2.0)**2 + (pi/1.0)**2 ) * np.sin(pi * X / 2.0) * np.sin(pi * Y / 1.0),\n            \"epsilon\": 1e-8, \"N_max\": 5000,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_poisson_solver(\n            case[\"Lx\"], case[\"Ly\"], case[\"Nx\"], case[\"Ny\"],\n            case[\"T_exact_func\"], case[\"f_func\"],\n            case[\"epsilon\"], case[\"N_max\"]\n        )\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}