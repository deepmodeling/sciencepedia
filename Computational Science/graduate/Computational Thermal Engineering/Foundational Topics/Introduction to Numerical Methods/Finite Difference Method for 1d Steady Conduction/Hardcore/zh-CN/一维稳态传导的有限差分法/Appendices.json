{
    "hands_on_practices": [
        {
            "introduction": "我们从一个基础但极具启发性的练习开始。对于某些简化的物理问题，数值方法不仅能提供近似解，还能得到精确解。通过解决一个具有已知线性温度分布的一维稳态导热问题，我们将亲手验证标准的中心差分格式在这种理想情况下的精确性，从而为更复杂的分析建立坚实的理论基础和信心。",
            "id": "3954436",
            "problem": "一根长度为 $L$ 的均匀一维杆，其导热系数 $k$ 为常数，处于稳态热传导状态，无内部体积生热。其左端 $x=0$ 处保持在指定温度 $T(0)=T_{0}$，右端 $x=L$ 处保持在指定温度 $T(L)=T_{L}$。从能量守恒原理和 Fourier 热传导定律出发，推导温度场 $T(x)$ 的连续控制方程，并确定精确的温度分布 $T(x)$。\n\n使用有限差分法 (FDM)，将区域离散为 $N$ 个相等的子区间，产生 $N+1$ 个网格点 $x_{i}=i\\,\\Delta x$（$i=0,1,\\dots,N$），其间距均匀为 $\\Delta x=L/N$。为内部节点建立离散的稳态热传导方程，并在端点处施加边界条件。求解所得的线性系统，以获得节点温度 $\\{T_{i}\\}_{i=0}^{N}$。\n\n通过将节点温度 $\\{T_{i}\\}$ 与在网格点 $\\{x_{i}\\}$ 处求值的精确连续解 $T(x)$ 进行比较，来验证离散格式。将最大范数误差定义为\n$$\nE_{\\infty}(\\Delta x)=\\max_{0\\leq i\\leq N}\\left|T_{i}-T(x_{i})\\right|.\n$$\n推导 $E_{\\infty}(\\Delta x)$ 作为 $\\Delta x$ 函数的闭式表达式。将 $E_{\\infty}(\\Delta x)$ 以开尔文 (K) 为单位表示。最终答案必须是仅依赖于 $\\Delta x$ 的单一解析表达式。",
            "solution": "该问题要求推导和比较一根具有指定边界温度且无内部生热的均匀杆中的一维稳态热传导的连续解和离散解。最终目标是找到两种解之间最大误差的闭式表达式。\n\n首先，我们推导连续控制方程及其精确解。对于无生热的一维稳态系统，能量守恒原理指出热流率 $q_x$ 沿杆是恒定的。这表示为：\n$$\n\\frac{dq_x}{dx} = 0\n$$\nFourier 热传导定律将热流率与温度梯度联系起来：\n$$\nq_x = -kA\\frac{dT}{dx}\n$$\n其中 $k$ 是导热系数，$A$ 是横截面积，两者均假定为常数。将 Fourier 定律代入能量守恒方程得到：\n$$\n\\frac{d}{dx}\\left(-kA\\frac{dT}{dx}\\right) = 0\n$$\n由于 $k$ 和 $A$ 是常数，我们可以将其简化为温度场 $T(x)$ 的控制常微分方程：\n$$\n\\frac{d^2T}{dx^2} = 0\n$$\n为了找到精确的温度分布 $T(x)$，我们将此方程对 $x$ 积分两次：\n$$\n\\frac{dT}{dx} = C_1\n$$\n$$\nT(x) = C_1 x + C_2\n$$\n其中 $C_1$ 和 $C_2$ 是由边界条件决定的积分常数。\n给定的边界条件是：\n1. 在 $x=0$ 处，$T(0) = T_0$。\n2. 在 $x=L$ 处，$T(L) = T_L$。\n\n应用第一个边界条件：\n$$\nT(0) = C_1(0) + C_2 = T_0 \\implies C_2 = T_0\n$$\n应用第二个边界条件：\n$$\nT(L) = C_1 L + T_0 = T_L \\implies C_1 = \\frac{T_L - T_0}{L}\n$$\n将常数代回通解，我们得到精确的连续温度分布：\n$$\nT(x) = \\left(\\frac{T_L - T_0}{L}\\right)x + T_0\n$$\n\n接下来，我们使用有限差分法 (FDM) 来建立和求解该问题。长度为 $L$ 的区域被离散为 $N$ 个宽度为 $\\Delta x = L/N$ 的相等子区间。这会产生 $N+1$ 个网格点 $x_i = i\\Delta x$ ($i = 0, 1, \\dots, N$)。每个网格点 $x_i$ 处的温度记为 $T_i$。\n\n控制方程 $\\frac{d^2T}{dx^2} = 0$ 在每个内部节点 $x_i$ (对于 $i=1, 2, \\dots, N-1$) 处使用二阶精度的中心差分格式对二阶导数进行离散：\n$$\n\\left.\\frac{d^2T}{dx^2}\\right|_{x_i} \\approx \\frac{T_{i+1} - 2T_i + T_{i-1}}{\\Delta x^2}\n$$\n将此代入控制方程，得到每个内部节点的离散方程：\n$$\n\\frac{T_{i+1} - 2T_i + T_{i-1}}{\\Delta x^2} = 0\n$$\n这简化为关于节点温度的线性代数方程：\n$$\nT_{i+1} - 2T_i + T_{i-1} = 0 \\quad \\text{for } i = 1, 2, \\dots, N-1\n$$\n这组 $N-1$ 个方程由边界条件补充，边界条件直接应用于端点：\n$$\nT_0 = T(0) = T_0\n$$\n$$\nT_N = T(L) = T_L\n$$\n离散方程可以重排为 $T_i - T_{i-1} = T_{i+1} - T_i$，这表明任意两个相邻节点之间的温差是恒定的。这意味着节点温度构成一个等差数列。我们可以将 $T_i$ 的通解写为：\n$$\nT_i = T_0 + i \\cdot C\n$$\n其中 $C$ 是公差。为了求出 $C$，我们使用 $i=N$ 处的边界条件：\n$$\nT_N = T_0 + N \\cdot C = T_L\n$$\n解出 $C$：\n$$\nC = \\frac{T_L - T_0}{N}\n$$\n将此代回，得到节点温度的解：\n$$\nT_i = T_0 + i \\left(\\frac{T_L - T_0}{N}\\right) \\quad \\text{for } i = 0, 1, \\dots, N\n$$\n\n最后，我们通过将节点温度 $\\{T_i\\}$ 与在网格点 $\\{x_i\\}$ 处求值的精确连续解 $T(x)$ 进行比较，来验证离散格式。在网格点 $x_i = i \\Delta x = i (L/N)$ 处的精确解是：\n$$\nT(x_i) = \\left(\\frac{T_L - T_0}{L}\\right)x_i + T_0 = \\left(\\frac{T_L - T_0}{L}\\right)\\left(i \\frac{L}{N}\\right) + T_0 = i\\left(\\frac{T_L - T_0}{N}\\right) + T_0\n$$\n将此与离散解 $T_i$ 进行比较：\n$$\nT(x_i) = T_0 + i\\left(\\frac{T_L - T_0}{N}\\right)\n$$\n$$\nT_i = T_0 + i \\left(\\frac{T_L - T_0}{N}\\right)\n$$\n我们观察到，数值解 $T_i$ 的表达式与在网格点 $x_i$ 处求值的精确解的表达式完全相同。因此，每个节点处的误差 $e_i = T_i - T(x_i)$ 是：\n$$\ne_i = \\left(T_0 + i \\left(\\frac{T_L - T_0}{N}\\right)\\right) - \\left(T_0 + i \\left(\\frac{T_L - T_0}{N}\\right)\\right) = 0\n$$\n这对所有节点 $i=0, 1, \\dots, N$ 都成立。\n\n最大范数误差定义为 $E_{\\infty}(\\Delta x)=\\max_{0\\leq i\\leq N}\\left|T_{i}-T(x_{i})\\right|$。由于每个节点的误差都为零，最大误差也为零：\n$$\nE_{\\infty}(\\Delta x) = \\max_{0\\leq i\\leq N}|0| = 0\n$$\n出现这个结果是因为二阶导数的中心差分格式是基于泰勒级数展开的。该格式的截断误差与函数的四阶导数 $T^{(4)}(x)$ 成正比。对于给定的问题，精确解是一个线性函数，$T(x) = C_1 x + C_2$。所有二阶及以上的导数都恒为零。具体来说，$T^{(4)}(x) = 0$。因此，有限差分近似的局部截断误差恰好为零，并且 FDM 解在节点处与精确解完全一致。\n\n因此，$E_{\\infty}(\\Delta x)$ 的闭式表达式为 $0$。这个值是一个常数，它平凡地满足了仅依赖于 $\\Delta x$ 的要求。误差的单位是开尔文 (K)，所以结果是 $0$ K。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "在验证了基础概念后，我们将着手构建一个功能更全面的通用求解器。该练习要求我们处理更接近实际工程问题的复杂性，例如变化的材料属性和不同类型的热边界。通过实现一个能够应对可变热导率以及狄利克雷（Dirichlet）、诺伊曼（Neumann）和罗宾（Robin）边界条件的程序，并应用高效的托马斯算法（TDMA）求解，你将掌握开发稳健数值模拟工具的核心技能。",
            "id": "3954359",
            "problem": "考虑沿长度为 $L$ 的杆的一维稳态热传导，其空间坐标为 $x \\in [0,L]$。根据能量守恒和傅里叶热传导定律推导出的控制方程为\n$$\n\\frac{d}{dx}\\Big(k(x)\\frac{dT}{dx}\\Big) + q'''(x) = 0,\n$$\n其中 $T(x)$ 是温度，$k(x)$ 是热导率，$q'''(x)$ 是体积生热率。假设使用一个具有 $N$ 个等距区间的均匀网格，节点索引为 $i=0,1,\\dots,N$，间距为 $\\Delta x = L/N$。使用有限差分法 (FDM) 推导一个三对角线性系统 $a_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i$（对于 $i=0,1,\\dots,N$），该系统在内部节点上强制执行控制方程，并在端点上强制执行边界条件。对于变化的 $k(x)$，使用由调和平均值定义的一致的界面值 $k_{i+1/2}$\n$$\nk_{i+\\frac{1}{2}} = \\frac{2}{\\frac{1}{k_i} + \\frac{1}{k_{i+1}}}, \\quad \\text{其中 } k_i \\equiv k(x_i).\n$$\n对于内部节点 $i=1,\\dots,N-1$，使用保守的两点通量近似来离散化通量散度：\n$$\n-\\,\\frac{k_{i-\\frac{1}{2}}}{\\Delta x}\\,T_{i-1} + \\frac{k_{i-\\frac{1}{2}} + k_{i+\\frac{1}{2}}}{\\Delta x}\\,T_i - \\frac{k_{i+\\frac{1}{2}}}{\\Delta x}\\,T_{i+1} = -\\,q'''_i\\,\\Delta x,\n$$\n其中 $q'''_i \\equiv q'''(x_i)$。对于边界条件，在 $i=0$（左侧）和 $i=N$（右侧）处强制执行以下线性关系：\n- 狄利克雷（给定温度）：$T_0 = T_\\text{L}$ 或 $T_N = T_\\text{R}$。\n- 诺伊曼（给定外向热通量 $q''$）：$-\\,k\\,\\frac{dT}{dx}\\big|_{\\text{face}} = q''$，采用在 $\\Delta x/2$ 上的单侧面梯度近似，得到\n$$\n\\text{左侧:}\\quad \\bigg(\\frac{2k_{1/2}}{\\Delta x}\\bigg)T_0 \\;-\\;\\bigg(\\frac{2k_{1/2}}{\\Delta x}\\bigg)T_1 \\;=\\; q''_\\text{L}, \\qquad\n\\text{右侧:}\\quad -\\bigg(\\frac{2k_{N-\\frac{1}{2}}}{\\Delta x}\\bigg)T_{N-1} \\;+\\;\\bigg(\\frac{2k_{N-\\frac{1}{2}}}{\\Delta x}\\bigg)T_N \\;=\\; -\\,q''_\\text{R}.\n$$\n- 罗宾（与环境温度 $T_\\infty$ 和传热系数 $h$ 的对流边界）：$-\\,k\\,\\frac{dT}{dx}\\big|_{\\text{face}} = h\\,(T_\\text{s} - T_\\infty)$，使用相同的面梯度近似，得到\n$$\n\\text{左侧:}\\quad \\bigg(\\frac{2k_{1/2}}{\\Delta x} + h_\\text{L}\\bigg)T_0 \\;-\\;\\bigg(\\frac{2k_{1/2}}{\\Delta x}\\bigg)T_1 \\;=\\; h_\\text{L}\\,T_{\\infty,\\text{L}},\n$$\n$$\n\\text{右侧:}\\quad -\\bigg(\\frac{2k_{N-\\frac{1}{2}}}{\\Delta x}\\bigg)T_{N-1} \\;+\\;\\bigg(\\frac{2k_{N-\\frac{1}{2}}}{\\Delta x} + h_\\text{R}\\bigg)T_N \\;=\\; h_\\text{R}\\,T_{\\infty,\\text{R}}.\n$$\n您必须实现托马斯算法（三对角矩阵算法，TDMA）来求解所得的三对角系统。从第一性原理出发，明确推导前向消元和回代公式，并解释其正确性。然后，编写一个完整的程序，为每个测试用例构建三对角系统，并使用推导出的 TDMA 公式进行求解。\n\n必须遵守物理单位：使用米 ($\\text{m}$)、开尔文 ($\\text{K}$)、瓦特每米开尔文 ($\\text{W}/(\\text{m}\\cdot\\text{K})$)、瓦特每立方米 ($\\text{W}/\\text{m}^3$) 和瓦特每平方米开尔文 ($\\text{W}/(\\text{m}^2\\cdot\\text{K})$)。\n\n测试套件：\n- 案例 $1$ (恒定热导率, 狄利克雷-狄利克雷, 无生热):\n  - $L = 1\\,\\text{m}$， $N = 10$， $k(x) \\equiv 10\\,\\text{W}/(\\text{m}\\cdot\\text{K})$， $q'''(x) \\equiv 0\\,\\text{W}/\\text{m}^3$， $T(0) = 300\\,\\text{K}$， $T(L) = 350\\,\\text{K}$。\n  - 输出：节点温度列表 $[T_0,\\dots,T_{10}]$，单位为 $\\text{K}$。\n- 案例 $2$ (分段热导率, 诺伊曼-狄利克雷, 无生热):\n  - $L = 1\\,\\text{m}$， $N = 8$，当 $x  L/2$ 时 $k(x) = 100\\,\\text{W}/(\\text{m}\\cdot\\text{K})$，当 $x \\ge L/2$ 时 $k(x) = 200\\,\\text{W}/(\\text{m}\\cdot\\text{K})$， $q'''(x) \\equiv 0\\,\\text{W}/\\text{m}^3$，左边界绝热 ($q''_\\text{L} = 0\\,\\text{W}/\\text{m}^2$)，右边界 $T(L) = 400\\,\\text{K}$。\n  - 输出：节点温度列表 $[T_0,\\dots,T_8]$，单位为 $\\text{K}$。\n- 案例 $3$ (恒定热导率, 狄利克雷-狄利克雷, 均匀生热):\n  - $L = 0.02\\,\\text{m}$， $N = 20$， $k(x) \\equiv 200\\,\\text{W}/(\\text{m}\\cdot\\text{K})$， $q'''(x) \\equiv 1.0\\times 10^5\\,\\text{W}/\\text{m}^3$， $T(0) = 300\\,\\text{K}$， $T(L) = 300\\,\\text{K}$。\n  - 输出：节点温度列表 $[T_0,\\dots,T_{20}]$，单位为 $\\text{K}$。\n- 案例 $4$ (恒定热导率, 罗宾-罗宾, 无生热):\n  - $L = 0.5\\,\\text{m}$， $N = 10$， $k(x) \\equiv 30\\,\\text{W}/(\\text{m}\\cdot\\text{K})$， $q'''(x) \\equiv 0\\,\\text{W}/\\text{m}^3$，左边界: $h_\\text{L} = 100\\,\\text{W}/(\\text{m}^2\\cdot\\text{K})$， $T_{\\infty,\\text{L}} = 290\\,\\text{K}$，右边界: $h_\\text{R} = 50\\,\\text{W}/(\\text{m}^2\\cdot\\text{K})$， $T_{\\infty,\\text{R}} = 310\\,\\text{K}$。\n  - 输出：节点温度列表 $[T_0,\\dots,T_{10}]$，单位为 $\\text{K}$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，本身也是一个节点温度列表（单位为 $\\text{K}$），并四舍五入到 $6$ 位小数。例如：\n$$\n[\\text{case1\\_list},\\text{case2\\_list},\\text{case3\\_list},\\text{case4\\_list}]\n$$\n输出字符串中不含空格。",
            "solution": "用户提供了一个定义明确的计算热传导问题。所有必要的控制方程、离散化方案、边界条件和测试参数都已指定。该问题在科学上是合理的、自洽的，并且在算法上是可解的。因此，该问题是有效的。\n\n### 1. 有限差分公式\n\n问题是求解具有可变热导率 $k(x)$ 和体积生热率 $q'''(x)$ 的一维稳态热传导方程：\n$$\n\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right) + q'''(x) = 0\n$$\n区域 $x \\in [0, L]$ 被离散化为一个具有 $N$ 个区间的均匀网格，从而产生 $N+1$ 个节点，索引为 $i=0, 1, \\dots, N$。网格间距为 $\\Delta x = L/N$，节点位置为 $x_i = i \\Delta x$。我们寻求节点温度 $T_i \\approx T(x_i)$。\n\n通过对每个内部节点 $x_i$ 中心处长度为 $\\Delta x$ 的控制体（CV）积分控制方程，可以推导出一个保守的有限差分格式。该控制体从 $x_{i-1/2}$ 延伸到 $x_{i+1/2}$。\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( \\frac{d}{dx}\\left(k\\frac{dT}{dx}\\right) + q''' \\right) dx = 0\n$$\n对第一项应用微积分基本定理，并近似源项的积分，得到：\n$$\n\\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i+1/2}} - \\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i-1/2}} + q'''_i \\Delta x = 0\n$$\n控制体表面的热通量使用中心差分进行近似：\n$$\n\\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i+1/2}} \\approx k_{i+1/2} \\frac{T_{i+1} - T_i}{\\Delta x}\n$$\n$$\n\\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i-1/2}} \\approx k_{i-1/2} \\frac{T_i - T_{i-1}}{\\Delta x}\n$$\n界面热导率 $k_{i \\pm 1/2}$ 使用调和平均值计算，以正确处理材料属性的突变并确保热通量的连续性：\n$$\nk_{i-1/2} = \\frac{2}{\\frac{1}{k_{i-1}} + \\frac{1}{k_i}}, \\quad k_{i+1/2} = \\frac{2}{\\frac{1}{k_i} + \\frac{1}{k_{i+1}}}\n$$\n将通量近似代入积分能量平衡方程中，得到：\n$$\nk_{i+1/2} \\frac{T_{i+1} - T_i}{\\Delta x} - k_{i-1/2} \\frac{T_i - T_{i-1}}{\\Delta x} + q'''_i \\Delta x = 0\n$$\n乘以 $-\\Delta x$ 并重新整理各项，得到问题陈述中给出的内部节点 $i \\in [1, N-1]$ 的线性方程：\n$$\n\\left(-\\frac{k_{i-1/2}}{\\Delta x}\\right) T_{i-1} + \\left(\\frac{k_{i-1/2} + k_{i+1/2}}{\\Delta x}\\right) T_i + \\left(-\\frac{k_{i+1/2}}{\\Delta x}\\right) T_{i+1} = -q'''_i \\Delta x\n$$\n该方程符合通用三对角形式 $a_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i$。\n\n### 2. 组装三对角系统\n\n用于求解 $N+1$ 个未知温度 $T_0, \\dots, T_N$ 的 $N+1$ 个线性方程的完整系统是通过在每个节点应用适当的方程形成的。\n\n**内部节点 ($i = 1, \\dots, N-1$):**\n- $a_i = -k_{i-1/2} / \\Delta x$\n- $b_i = (k_{i-1/2} + k_{i+1/2}) / \\Delta x$\n- $c_i = -k_{i+1/2} / \\Delta x$\n- $d_i = -q'''_i \\Delta x$\n\n**边界节点 ($i=0$ 和 $i=N$):**\n系统的第一行 ($i=0$) 和最后一行 ($i=N$) 由边界条件确定。\n\n**左边界 ($i=0$):**\n1.  **狄利克雷:** $T_0 = T_L$。方程为 $1 \\cdot T_0 + 0 \\cdot T_1 = T_L$。\n    - $b_0 = 1$, $c_0 = 0$, $d_0 = T_L$。($a_0$ 未使用)。\n2.  **诺伊曼:** $-\\,k\\,\\frac{dT}{dx}\\big|_{\\text{face}} = q''_\\text{L}$。给定的离散化是 $\\left(\\frac{2k_{1/2}}{\\Delta x}\\right)T_0 - \\left(\\frac{2k_{1/2}}{\\Delta x}\\right)T_1 = q''_\\text{L}$。\n    - $b_0 = 2k_{1/2} / \\Delta x$, $c_0 = -2k_{1/2} / \\Delta x$, $d_0 = q''_\\text{L}$。\n3.  **罗宾:** 给定的离散化是 $\\left(\\frac{2k_{1/2}}{\\Delta x} + h_\\text{L}\\right)T_0 - \\left(\\frac{2k_{1/2}}{\\Delta x}\\right)T_1 = h_\\text{L}T_{\\infty,\\text{L}}$。\n    - $b_0 = 2k_{1/2}/\\Delta x + h_\\text{L}$, $c_0 = -2k_{1/2}/\\Delta x$, $d_0 = h_\\text{L}T_{\\infty,\\text{L}}$。\n\n**右边界 ($i=N$):**\n1.  **狄利克雷:** $T_N = T_R$。方程为 $1 \\cdot T_N = T_R$。\n    - $a_N = 0$, $b_N = 1$, $d_N = T_R$。($c_N$ 未使用)。\n2.  **诺伊曼:** $-\\,k\\,\\frac{dT}{dx}\\big|_{\\text{face}} = q''_\\text{R}$。给定的离散化是 $-\\left(\\frac{2k_{N-1/2}}{\\Delta x}\\right)T_{N-1} + \\left(\\frac{2k_{N-1/2}}{\\Delta x}\\right)T_N = -q''_\\text{R}$。\n    - $a_N = -2k_{N-1/2}/\\Delta x$, $b_N = 2k_{N-1/2}/\\Delta x$, $d_N = -q''_\\text{R}$。\n3.  **罗宾:** 给定的离散化是 $-\\left(\\frac{2k_{N-1/2}}{\\Delta x}\\right)T_{N-1} + \\left(\\frac{2k_{N-1/2}}{\\Delta x} + h_\\text{R}\\right)T_N = h_\\text{R}T_{\\infty,\\text{R}}$。\n    - $a_N = -2k_{N-1/2}/\\Delta x$, $b_N = 2k_{N-1/2}/\\Delta x + h_\\text{R}$, $d_N = h_\\text{R}T_{\\infty,\\text{R}}$。\n\n这些系数构成了一个大小为 $(N+1) \\times (N+1)$ 的三对角线性方程组，可以高效地求解。\n\n### 3. 托马斯算法 (TDMA) 的推导\n\n托马斯算法，或称三对角矩阵算法 (TDMA)，是高斯消元法针对三对角系统的一种特殊形式。它以 $O(N)$ 的操作求解该系统，这比通用的 $O(N^3)$ 矩阵求逆要高效得多。该推导包括一个前向消元过程和一个回代过程。\n\n考虑方程组，对于 $i = 0, \\dots, N$:\n$$\na_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i\n$$\n根据定义，$a_0 = 0$ 且 $c_N = 0$。\n\n**前向消元过程：**\n此过程的目标是将系统转换为上双对角形式。我们通过消除次对角线元素 $a_i$ 来实现这一点。\n\n第一个方程 ($i=0$) 是 $b_0 T_0 + c_0 T_1 = d_0$。我们可以用 $T_1$ 表示 $T_0$：\n$$\nT_0 = -\\frac{c_0}{b_0} T_1 + \\frac{d_0}{b_0}\n$$\n第二个方程 ($i=1$) 是 $a_1 T_0 + b_1 T_1 + c_1 T_2 = d_1$。代入 $T_0$ 的表达式：\n$$\na_1 \\left(-\\frac{c_0}{b_0} T_1 + \\frac{d_0}{b_0}\\right) + b_1 T_1 + c_1 T_2 = d_1\n$$\n重新整理各项：\n$$\n\\left(b_1 - \\frac{a_1 c_0}{b_0}\\right) T_1 + c_1 T_2 = d_1 - \\frac{a_1 d_0}{b_0}\n$$\n这个过程可以推广。我们执行行变换，将每个方程转换为 $T_i + c'_i T_{i+1} = d'_i$ 的形式。\n我们定义修正系数 $c'_i$ 和 $d'_i$。\n\n对于 $i=0$:\n$$\nc'_0 = \\frac{c_0}{b_0}, \\quad d'_0 = \\frac{d_0}{b_0}\n$$\n对于 $i  0$，我们有原始方程 $a_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i$ 和先前为行 $i-1$ 修正的方程：$T_{i-1} = -c'_{i-1} T_i + d'_{i-1}$。将 $T_{i-1}$ 的表达式代入行 $i$ 的原始方程中：\n$$\na_i (-c'_{i-1} T_i + d'_{i-1}) + b_i T_i + c_i T_{i+1} = d_i\n$$\n按 $T_i$ 和 $T_{i+1}$ 分组各项：\n$$\n(b_i - a_i c'_{i-1}) T_i + c_i T_{i+1} = d_i - a_i d'_{i-1}\n$$\n除以 $T_i$ 的新系数以将其分离，得到修正系数的递推关系：\n$$\nc'_i = \\frac{c_i}{b_i - a_i c'_{i-1}}, \\quad d'_i = \\frac{d_i - a_i d'_{i-1}}{b_i - a_i c'_{i-1}}\n$$\n这些递推关系应用于 $i = 1, \\dots, N$。注意，对于 $i=N$, $c_N=0$，所以 $c'_N=0$。\n\n前向消元扫描过程如下：\n1.  计算 $c'_0 = c_0/b_0$ 和 $d'_0 = d_0/b_0$。\n2.  对于 $i = 1, \\dots, N$，使用递推关系计算 $c'_i$ 和 $d'_i$。\n\n**回代过程：**\n在前向过程之后，系统已转换为上双对角形式：\n$$\nT_i + c'_i T_{i+1} = d'_i \\quad \\text{for } i=0, \\dots, N-1\n$$\n$$\nT_N = d'_N \\quad (\\text{因为 } c'_N = 0)\n$$\n最后一个温度 $T_N$ 直接可知：\n$$\nT_N = d'_N\n$$\n其余的温度可以通过从 $i=N-1$ 向下到 $0$ 的回代求得：\n$$\nT_i = d'_i - c'_i T_{i+1}\n$$\n回代扫描过程如下：\n1.  设置 $T_N = d'_N$。\n2.  对于 $i = N-1, N-2, \\dots, 0$，计算 $T_i = d'_i - c'_i T_{i+1}$。\n\n这个两步过程完成了求解。对于对角占优矩阵，该算法是数值稳定的，这是所考虑的物理系统满足的一个条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tdma(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal linear system Ax=d using the Thomas algorithm (TDMA).\n\n    Args:\n        a (np.ndarray): The sub-diagonal (indices 1 to n-1). a[0] is ignored.\n        b (np.ndarray): The main diagonal (indices 0 to n-1).\n        c (np.ndarray): The super-diagonal (indices 0 to n-2). c[n-1] is ignored.\n        d (np.ndarray): The right-hand side vector.\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = len(d)\n    c_prime = np.zeros(n)\n    d_prime = np.zeros(n)\n    x = np.zeros(n)\n\n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n\n    for i in range(1, n):\n        denom = b[i] - a[i] * c_prime[i-1]\n        c_prime[i] = c[i] / denom\n        d_prime[i] = (d[i] - a[i] * d_prime[i-1]) / denom\n\n    # Backward substitution\n    x[n-1] = d_prime[n-1]\n    for i in range(n-2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i+1]\n\n    return x\n\ndef solve_heat_conduction(L, N, k_func, q_func, bc_left, bc_right):\n    \"\"\"\n    Constructs and solves the 1D steady heat conduction problem using FDM.\n    \"\"\"\n    # 1. Setup grid and properties\n    x_nodes = np.linspace(0, L, N + 1)\n    dx = L / N\n    \n    k_vals = np.array([k_func(x) for x in x_nodes])\n    q_vals = np.array([q_func(x) for x in q_nodes])\n\n    # 2. Compute interface conductivities\n    k_interface = np.zeros(N)\n    for i in range(N):\n        # Harmonic mean for k_{i+1/2}\n        if k_vals[i] == 0 or k_vals[i+1] == 0:\n            k_interface[i] = 0 # Or handle as insulated\n        else:\n            k_interface[i] = 2.0 / (1.0/k_vals[i] + 1.0/k_vals[i+1])\n\n    # 3. Initialize tridiagonal system coefficients\n    num_nodes = N + 1\n    a = np.zeros(num_nodes) # sub-diagonal\n    b = np.zeros(num_nodes) # main-diagonal\n    c = np.zeros(num_nodes) # super-diagonal\n    d = np.zeros(num_nodes) # RHS vector\n\n    # 4. Fill coefficients for interior nodes (i = 1 to N-1)\n    for i in range(1, N):\n        a[i] = -k_interface[i-1] / dx\n        b[i] = (k_interface[i-1] + k_interface[i]) / dx\n        c[i] = -k_interface[i] / dx\n        d[i] = -q_vals[i] * dx\n\n    # 5. Fill coefficients for boundary nodes (i=0 and i=N)\n    # Left boundary (i=0)\n    bc_type_L, bc_val_L = bc_left[0], bc_left[1:]\n    if bc_type_L == 'dirichlet':\n        b[0] = 1.0\n        c[0] = 0.0\n        d[0] = bc_val_L[0]\n    elif bc_type_L == 'neumann':\n        q_L = bc_val_L[0]\n        b[0] = 2 * k_interface[0] / dx\n        c[0] = -2 * k_interface[0] / dx\n        d[0] = q_L\n    elif bc_type_L == 'robin':\n        h_L, T_inf_L = bc_val_L\n        b[0] = 2 * k_interface[0] / dx + h_L\n        c[0] = -2 * k_interface[0] / dx\n        d[0] = h_L * T_inf_L\n\n    # Right boundary (i=N)\n    bc_type_R, bc_val_R = bc_right[0], bc_right[1:]\n    if bc_type_R == 'dirichlet':\n        a[N] = 0.0\n        b[N] = 1.0\n        d[N] = bc_val_R[0]\n    elif bc_type_R == 'neumann':\n        q_R = bc_val_R[0]\n        a[N] = -2 * k_interface[N-1] / dx\n        b[N] = 2 * k_interface[N-1] / dx\n        d[N] = -q_R\n    elif bc_type_R == 'robin':\n        h_R, T_inf_R = bc_val_R\n        a[N] = -2 * k_interface[N-1] / dx\n        b[N] = 2 * k_interface[N-1] / dx + h_R\n        d[N] = h_R * T_inf_R\n\n    # 6. Solve the system\n    T = solve_tdma(a, b, c, d)\n    return T\n\n\ndef solve():\n    test_cases = [\n        # Case 1\n        {\n            \"L\": 1.0, \"N\": 10, \"k_func\": lambda x: 10.0, \"q_func\": lambda x: 0.0,\n            \"bc_left\": ('dirichlet', 300.0), \"bc_right\": ('dirichlet', 350.0)\n        },\n        # Case 2\n        {\n            \"L\": 1.0, \"N\": 8, \"k_func\": lambda x: 100.0 if x  0.5 else 200.0, \"q_func\": lambda x: 0.0,\n            \"bc_left\": ('neumann', 0.0), \"bc_right\": ('dirichlet', 400.0)\n        },\n        # Case 3\n        {\n            \"L\": 0.02, \"N\": 20, \"k_func\": lambda x: 200.0, \"q_func\": lambda x: 1.0e5,\n            \"bc_left\": ('dirichlet', 300.0), \"bc_right\": ('dirichlet', 300.0)\n        },\n        # Case 4\n        {\n            \"L\": 0.5, \"N\": 10, \"k_func\": lambda x: 30.0, \"q_func\": lambda x: 0.0,\n            \"bc_left\": ('robin', 100.0, 290.0), \"bc_right\": ('robin', 50.0, 310.0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        T = solve_heat_conduction(\n            case[\"L\"], case[\"N\"], case[\"k_func\"], case[\"q_func\"],\n            case[\"bc_left\"], case[\"bc_right\"]\n        )\n        results.append(T)\n\n    # Format the final output string exactly as required\n    result_strings = []\n    for T in results:\n        # Format each temperature list to a string '[T0,T1,...]'\n        # with numbers rounded to 6 decimal places.\n        temp_list_str = f\"[{','.join([f'{temp:.6f}' for temp in T])}]\"\n        result_strings.append(temp_list_str)\n\n    # Join the individual case strings into the final format '[[...],[...]]'\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "编写代码只是第一步，确保其正确性同样至关重要。在本练习中，我们将学习一种严谨的代码验证技术——“制造解法”（Method of Manufactured Solutions）。你将通过求解一个具有已知非平凡解析解的问题，并进行网格加密分析，来定量地计算数值格式的“收敛阶”，从而验证你的程序是否达到了预期的二阶精度。这是从“能运行”到“可信赖”的关键一步。",
            "id": "3954376",
            "problem": "考虑在一维空间区间 $[0,1]$（单位为米）上的稳态热传导，其热导率为 $k(x)$，体积生热率为 $s(x)$（单位为瓦/立方米）。其控制方程由傅里叶热传导定律和稳态能量守恒结合得出，即以下微分方程\n$$\n-\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right) = s(x),\n$$\n其边界条件在 $x=0$ 和 $x=1$ 处给定。您将需要在一个包含 $N$ 个节点（包括边界）的均匀网格上实现一个二阶精度的有限差分法 (FDM)，其中 $h = \\frac{1}{N-1}$，以数值方式逼近温度场 $T(x)$（单位为开尔文）。使用守恒型内部离散格式\n$$\n-\\frac{1}{h^2}\\left(k_{i+\\frac{1}{2}}\\left(T_{i+1}-T_i\\right) - k_{i-\\frac{1}{2}}\\left(T_i - T_{i-1}\\right)\\right) = s(x_i),\n$$\n对于内部节点 $i=1,\\dots,N-2$，其中界面热导率 $k_{i\\pm\\frac{1}{2}}$ 必须通过调和平均值来近似\n$$\nk_{i+\\frac{1}{2}} = \\left(\\frac{1}{2}\\left(\\frac{1}{k_i} + \\frac{1}{k_{i+1}}\\right)\\right)^{-1} = \\frac{2 k_i k_{i+1}}{k_i + k_{i+1}},\n$$\n$k_{i-\\frac{1}{2}}$ 的计算也类似。对于狄利克雷边界条件，在边界节点上强制施加精确温度。对于在 $x=1$ 处的零热通量和恒定热导率的诺伊曼边界条件，使用以下二阶精度公式来施加边界导数\n$$\n\\frac{3 T_{N-1} - 4 T_{N-2} + T_{N-3}}{2h} = 0.\n$$\n您将使用构造解（manufactured solution）进行网格加密分析，从而使得解析解是已知的。对于每个测试用例，定义精确解 $T_{\\text{exact}}(x)$（单位为开尔文）、热导率 $k(x)$、根据控制方程派生出的源项 $s(x)$（单位为瓦/立方米）以及相应的边界条件。计算三个连续的 $N$ 值所对应的数值解，并评估离散 $L^2$ 误差范数\n$$\nE_N = \\sqrt{h \\sum_{i=0}^{N-1} \\left(T_i^{\\text{num}} - T_{\\text{exact}}(x_i)\\right)^2},\n$$\n其中 $x_i = i h$，$T_i^{\\text{num}}$ 是在节点 $i$ 计算得到的数值温度，$T_{\\text{exact}}(x_i)$ 是在该节点上的精确温度。根据两个最密的网格，计算观测精度阶\n$$\np_{\\text{obs}} = \\frac{\\ln\\left(E_{N_2}/E_{N_3}\\right)}{\\ln\\left(h_{N_2}/h_{N_3}\\right)},\n$$\n其中 $h_N = \\frac{1}{N-1}$，$(N_1,N_2,N_3)$ 是该测试用例的连续网格尺寸。将 $p_{\\text{obs}}$ 作为无量纲浮点数报告。\n\n测试套件：\n- 测试用例 1（狄利克雷-狄利克雷，恒定热导率）：\n  - 区域：$x \\in [0,1]$ 米。\n  - 热导率：$k(x) = 1$ 瓦/米-开尔文。\n  - 精确解：$T_{\\text{exact}}(x) = \\sin(\\pi x)$ 开尔文。\n  - 源项：$s(x) = -\\frac{d}{dx}\\left(k(x)\\frac{dT_{\\text{exact}}}{dx}\\right) = \\pi^2 \\sin(\\pi x)$ 瓦/立方米。\n  - 边界条件：$T(0) = 0$ 开尔文, $T(1) = 0$ 开尔文。\n  - 网格尺寸：$(N_1,N_2,N_3) = (21, 41, 81)$。\n\n- 测试用例 2（狄利克雷-狄利克雷，平滑变化的热导率）：\n  - 区域：$x \\in [0,1]$ 米。\n  - 热导率：$k(x) = 1 + x$ 瓦/米-开尔文。\n  - 精确解：$T_{\\text{exact}}(x) = \\sin(\\pi x)$ 开尔文。\n  - 源项：$s(x) = -\\frac{d}{dx}\\left(k(x)\\frac{dT_{\\text{exact}}}{dx}\\right) = (1+x)\\pi^2 \\sin(\\pi x) - \\pi \\cos(\\pi x)$ 瓦/立方米。\n  - 边界条件：$T(0) = 0$ 开尔文, $T(1) = 0$ 开尔文。\n  - 网格尺寸：$(N_1,N_2,N_3) = (17, 33, 65)$。\n\n- 测试用例 3（狄利克雷-诺伊曼，右边界为零通量的恒定热导率）：\n  - 区域：$x \\in [0,1]$ 米。\n  - 热导率：$k(x) = 1$ 瓦/米-开尔文。\n  - 精确解：$T_{\\text{exact}}(x) = \\sin\\left(\\frac{\\pi}{2} x\\right)$ 开尔文。\n  - 源项：$s(x) = -\\frac{d}{dx}\\left(k(x)\\frac{dT_{\\text{exact}}}{dx}\\right) = \\left(\\frac{\\pi}{2}\\right)^2 \\sin\\left(\\frac{\\pi}{2} x\\right)$ 瓦/立方米。\n  - 边界条件：$T(0) = 0$ 开尔文，以及在 $x=1$ 处的零通量 $k \\frac{dT}{dx}(1) = 0$。\n  - 网格尺寸：$(N_1,N_2,N_3) = (19, 37, 73)$。\n\n您的程序必须：\n- 实现所述的 FDM，为每个 $N$ 组装并求解得到的线性系统。\n- 在每个测试用例中为每个 $N$ 计算 $E_N$，然后根据两个最密的网格计算 $p_{\\text{obs}}$。\n- 生成单行输出，其中包含按测试用例顺序排列的三个 $p_{\\text{obs}}$ 值，形式为用方括号括起来的逗号分隔列表。例如：“[p1,p2,p3]”。\n所有 $p_{\\text{obs}}$ 的输出均为无量纲浮点数。",
            "solution": "该问题要求实现一个二阶精度的有限差分法 (FDM) 来求解区间 $x \\in [0, 1]$ 上的一维稳态热传导方程。控制方程为\n$$\n-\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right) = s(x),\n$$\n其中 $T(x)$ 是温度，$k(x)$ 是热导率，$s(x)$ 是体积生热率。目标是使用构造解法 (Method of Manufactured Solutions) 进行网格加密研究，以验证数值格式的二阶精度。\n\n首先，将空间域 $[0, 1]$ 离散化为一个包含 $N$ 个节点的均匀网格。节点坐标由 $x_i = i h$ 给出，其中 $i = 0, 1, \\dots, N-1$，$h = 1/(N-1)$ 是恒定的网格间距。这些节点上的温度 $T(x_i)$ 记为 $T_i$。\n\n对于内部节点 $i = 1, \\dots, N-2$，我们应用所提供的守恒型有限差分离散格式。该格式是通过将控制方程在以每个节点为中心、从 $x_i - h/2$ 到 $x_i + h/2$ 的控制体积上积分得出的。这导出了离散方程：\n$$\n-\\frac{1}{h} \\left( \\left. k \\frac{dT}{dx} \\right|_{i+\\frac{1}{2}} - \\left. k \\frac{dT}{dx} \\right|_{i-\\frac{1}{2}} \\right) = s(x_i).\n$$\n控制体表面上的通量 $\\left. k \\frac{dT}{dx} \\right|_{i\\pm\\frac{1}{2}}$ 使用中心差分进行近似，例如 $\\left. k \\frac{dT}{dx} \\right|_{i+\\frac{1}{2}} \\approx k_{i+\\frac{1}{2}} \\frac{T_{i+1}-T_i}{h}$。这得到了指定的公式：\n$$\n-\\frac{1}{h^2}\\left(k_{i+\\frac{1}{2}}\\left(T_{i+1}-T_i\\right) - k_{i-\\frac{1}{2}}\\left(T_i - T_{i-1}\\right)\\right) = s(x_i).\n$$\n界面热导率 $k_{i\\pm\\frac{1}{2}}$ 使用相邻节点热导率的调和平均值计算：\n$$\nk_{i+\\frac{1}{2}} = \\frac{2 k(x_i) k(x_{i+1})}{k(x_i) + k(x_{i+1})} \\quad \\text{和} \\quad k_{i-\\frac{1}{2}} = \\frac{2 k(x_{i-1}) k(x_i)}{k(x_{i-1}) + k(x_i)}.\n$$\n调和平均值对于确保通量守恒特别有效，尤其是在热导率急剧变化时。\n\n重新排列内部节点方程，按未知温度 $T_{i-1}$、$T_i$ 和 $T_{i+1}$ 对各项进行分组，可为每个内部节点 $i$ 得到一个线性代数方程：\n$$\n\\left(-\\frac{k_{i-\\frac{1}{2}}}{h^2}\\right) T_{i-1} + \\left(\\frac{k_{i-\\frac{1}{2}} + k_{i+\\frac{1}{2}}}{h^2}\\right) T_i + \\left(-\\frac{k_{i+\\frac{1}{2}}}{h^2}\\right) T_{i+1} = s(x_i).\n$$\n这 $N-2$ 个方程与节点 $i=0$ 和 $i=N-1$ 处边界条件的两个方程相结合，构成了一个包含 $N$ 个未知数的 $N$ 个线性方程组，可以写成矩阵形式 $A\\mathbf{T} = \\mathbf{b}$。这里，$\\mathbf{T} = [T_0, T_1, \\dots, T_{N-1}]^T$ 是未知节点温度的向量，$A$ 是一个 $N \\times N$ 的系数矩阵，$\\mathbf{b}$ 是一个 $N \\times 1$ 的源向量。\n\n边界条件决定了系统的第一行（$i=0$）和最后一行（$i=N-1$）。\n对于狄利克雷边界条件，如 $T(0) = T_0^{\\text{exact}}$，相应的方程就是 $1 \\cdot T_0 = T_0^{\\text{exact}}$。这将矩阵 $A$ 的第一行设置为 $[1, 0, \\dots, 0]$，并将 $\\mathbf{b}$ 的第一个元素设置为 $T_0^{\\text{exact}}$。对于 $x=1$ 处的狄利克雷条件，最后一行的处理方式类似。\n\n对于 $x=1$ 处的零热通量诺伊曼边界条件 $k(1)\\frac{dT}{dx}(1) = 0$，需要对导数进行离散近似。问题指定了一个二阶精度的单边差分公式：\n$$\n\\frac{3 T_{N-1} - 4 T_{N-2} + T_{N-3}}{2h} = 0.\n$$\n这直接给出了系统的最后一个方程：$T_{N-3} - 4T_{N-2} + 3T_{N-1} = 0$。对于这个方程，矩阵 $A$ 的最后一行将在第 $N-3$、$N-2$ 和 $N-1$ 列有非零项，其值分别为 $1$、$-4$ 和 $3$。$\\mathbf{b}$ 中对应的元素为 $0$。\n\n一旦对于给定的测试用例和网格尺寸 $N$，矩阵 $A$ 和向量 $\\mathbf{b}$ 被完全组装，就可以求解该线性系统以获得数值解向量 $\\mathbf{T}^{\\text{num}}$。\n\n为了验证实现，我们使用所提供的构造解。对于每个 $N$，将数值解 $\\mathbf{T}^{\\text{num}}$ 与在网格点上评估的精确解 $\\mathbf{T}^{\\text{exact}}$ 进行比较。误差使用离散 $L^2$ 范数进行量化：\n$$\nE_N = \\sqrt{h \\sum_{i=0}^{N-1} \\left(T_i^{\\text{num}} - T_{\\text{exact}}(x_i)\\right)^2}.\n$$\n然后，使用来自两个最密网格 $N_2$ 和 $N_3$ 的误差来计算观测精度阶 $p_{\\text{obs}}$：\n$$\np_{\\text{obs}} = \\frac{\\ln\\left(E_{N_2}/E_{N_3}\\right)}{\\ln\\left(h_{N_2}/h_{N_3}\\right)}.\n$$\n对于一个二阶精度的格式，我们期望随着网格的加密，$p_{\\text{obs}} \\approx 2$。程序将对所有三个测试用例执行此过程，并报告计算出的 $p_{\\text{obs}}$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_bvp(N, k_func, s_func, bc_left_tuple, bc_right_tuple):\n    \"\"\"\n    Solves the 1D steady conduction BVP using a finite difference method.\n\n    Args:\n        N (int): Number of grid nodes.\n        k_func (callable): Function k(x) for thermal conductivity.\n        s_func (callable): Function s(x) for the source term.\n        bc_left_tuple (tuple): Tuple of (type, value) for the left BC.\n        bc_right_tuple (tuple): Tuple of (type, value) for the right BC.\n\n    Returns:\n        np.array: The numerical solution for temperature T at the grid nodes.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    x = np.linspace(0.0, 1.0, N)\n\n    k_vals = k_func(x)\n    s_vals = s_func(x)\n\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # Interior nodes (i=1, ..., N-2)\n    for i in range(1, N - 1):\n        k_im1 = k_vals[i - 1]\n        k_i = k_vals[i]\n        k_ip1 = k_vals[i + 1]\n\n        # Harmonic mean for interface conductivity\n        k_imhalf = (2.0 * k_im1 * k_i) / (k_im1 + k_i)\n        k_iphalf = (2.0 * k_i * k_ip1) / (k_i + k_ip1)\n\n        A[i, i - 1] = -k_imhalf / (h * h)\n        A[i, i] = (k_imhalf + k_iphalf) / (h * h)\n        A[i, i + 1] = -k_iphalf / (h * h)\n        b[i] = s_vals[i]\n\n    # Boundary conditions\n    # Left BC at x=0 (node i=0)\n    bc_left_type, bc_left_val = bc_left_tuple\n    if bc_left_type == 'dirichlet':\n        A[0, 0] = 1.0\n        b[0] = bc_left_val\n    \n    # Right BC at x=1 (node i=N-1)\n    bc_right_type, bc_right_val = bc_right_tuple\n    if bc_right_type == 'dirichlet':\n        A[N - 1, N - 1] = 1.0\n        b[N - 1] = bc_right_val\n    elif bc_right_type == 'neumann':\n        # Zero-flux Neumann BC: 3*T_{N-1} - 4*T_{N-2} + T_{N-3} = 0\n        if bc_right_val == 0.0:\n            A[N - 1, N - 3] = 1.0\n            A[N - 1, N - 2] = -4.0\n            A[N - 1, N - 1] = 3.0\n            b[N - 1] = 0.0\n\n    # Solve the linear system\n    T_num = np.linalg.solve(A, b)\n    return T_num\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1: DD, constant k\",\n            \"k_func\": lambda x: np.full_like(x, 1.0),\n            \"T_exact_func\": lambda x: np.sin(np.pi * x),\n            \"s_func\": lambda x: np.pi**2 * np.sin(np.pi * x),\n            \"bc_left\": ('dirichlet', 0.0),\n            \"bc_right\": ('dirichlet', 0.0),\n            \"meshes\": (21, 41, 81)\n        },\n        {\n            \"name\": \"Case 2: DD, variable k\",\n            \"k_func\": lambda x: 1.0 + x,\n            \"T_exact_func\": lambda x: np.sin(np.pi * x),\n            \"s_func\": lambda x: (1.0 + x) * np.pi**2 * np.sin(np.pi * x) - np.pi * np.cos(np.pi * x),\n            \"bc_left\": ('dirichlet', 0.0),\n            \"bc_right\": ('dirichlet', 0.0),\n            \"meshes\": (17, 33, 65)\n        },\n        {\n            \"name\": \"Case 3: DN, constant k\",\n            \"k_func\": lambda x: np.full_like(x, 1.0),\n            \"T_exact_func\": lambda x: np.sin(np.pi / 2.0 * x),\n            \"s_func\": lambda x: (np.pi / 2.0)**2 * np.sin(np.pi / 2.0 * x),\n            \"bc_left\": ('dirichlet', 0.0),\n            \"bc_right\": ('neumann', 0.0),\n            \"meshes\": (19, 37, 73)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        errors = []\n        h_vals = []\n        for N in case[\"meshes\"]:\n            h = 1.0 / (N - 1)\n            x = np.linspace(0.0, 1.0, N)\n            \n            # Solve for numerical temperature\n            T_num = solve_bvp(N, case[\"k_func\"], case[\"s_func\"], case[\"bc_left\"], case[\"bc_right\"])\n            \n            # Get exact temperature\n            T_exact = case[\"T_exact_func\"](x)\n            \n            # Calculate L2 error\n            error = np.sqrt(h * np.sum((T_num - T_exact)**2))\n            errors.append(error)\n            h_vals.append(h)\n            \n        # Unpack errors and grid spacings\n        E_N2, E_N3 = errors[1], errors[2]\n        h_N2, h_N3 = h_vals[1], h_vals[2]\n\n        # Compute observed order of accuracy\n        p_obs = np.log(E_N2 / E_N3) / np.log(h_N2 / h_N3)\n        results.append(p_obs)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}