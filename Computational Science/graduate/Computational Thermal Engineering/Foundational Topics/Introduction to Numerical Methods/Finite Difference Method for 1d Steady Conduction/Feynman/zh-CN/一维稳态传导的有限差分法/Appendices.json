{
    "hands_on_practices": [
        {
            "introduction": "第一个实践练习  将引导您从零开始构建一个完整的有限差分求解器。您将对一维稳态热传导方程进行离散化，处理各种边界条件（狄利克雷、诺伊曼和罗宾），并实现高效的托马斯算法（TDMA）来求解所得的三对角系统。这种动手实践是计算工程师的基石技能，它将巩固您对物理定律如何转化为可解数值模型的理解。",
            "id": "3954359",
            "problem": "考虑一根长度为 $L$ 的杆中的一维稳态热传导，其空间坐标为 $x \\in [0,L]$。根据能量守恒和傅里叶热传导定律推导出的控制方程为\n$$\n\\frac{d}{dx}\\Big(k(x)\\frac{dT}{dx}\\Big) + q'''(x) = 0,\n$$\n其中 $T(x)$ 是温度，$k(x)$ 是热导率，$q'''(x)$ 是体积生热率。假设一个具有 $N$ 个等间距区间的均匀网格，节点索引为 $i=0,1,\\dots,N$，间距为 $\\Delta x = L/N$。使用有限差分法 (FDM) 推导一个三对角线性系统 $a_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i$（其中 $i=0,1,\\dots,N$），该系统在内部节点强制执行控制方程，并在端点强制执行边界条件。对于变化的 $k(x)$，使用由调和平均值定义的一致界面值 $k_{i+1/2}$\n$$\nk_{i+\\frac{1}{2}} = \\frac{2}{\\frac{1}{k_i} + \\frac{1}{k_{i+1}}}, \\quad \\text{其中 } k_i \\equiv k(x_i).\n$$\n对于内部节点 $i=1,\\dots,N-1$，使用保守的两点通量近似来离散化通量散度：\n$$\n-\\,\\frac{k_{i-\\frac{1}{2}}}{\\Delta x}\\,T_{i-1} + \\frac{k_{i-\\frac{1}{2}} + k_{i+\\frac{1}{2}}}{\\Delta x}\\,T_i - \\frac{k_{i+\\frac{1}{2}}}{\\Delta x}\\,T_{i+1} = -\\,q'''_i\\,\\Delta x,\n$$\n其中 $q'''_i \\equiv q'''(x_i)$。对于边界条件，在 $i=0$ (左) 和 $i=N$ (右) 处强制执行以下线性关系：\n- 狄利克雷 (给定温度)：$T_0 = T_\\text{L}$ 或 $T_N = T_\\text{R}$。\n- 诺伊曼 (给定外向热通量 $q''$)：$-\\,k\\,\\frac{dT}{dx}\\big|_{\\text{face}} = q''$，在 $\\Delta x/2$ 上使用单侧面梯度近似，得到\n$$\n\\text{左:}\\quad \\bigg(\\frac{2k_{1/2}}{\\Delta x}\\bigg)T_0 \\;-\\;\\bigg(\\frac{2k_{1/2}}{\\Delta x}\\bigg)T_1 \\;=\\; q''_\\text{L}, \\qquad\n\\text{右:}\\quad -\\bigg(\\frac{2k_{N-\\frac{1}{2}}}{\\Delta x}\\bigg)T_{N-1} \\;+\\;\\bigg(\\frac{2k_{N-\\frac{1}{2}}}{\\Delta x}\\bigg)T_N \\;=\\; -\\,q''_\\text{R}.\n$$\n- 罗宾 (与环境温度 $T_\\infty$ 和传热系数 $h$ 的对流边界)：$-\\,k\\,\\frac{dT}{dx}\\big|_{\\text{face}} = h\\,(T_\\text{s} - T_\\infty)$，使用相同的面梯度近似，得到\n$$\n\\text{左:}\\quad \\bigg(\\frac{2k_{1/2}}{\\Delta x} + h_\\text{L}\\bigg)T_0 \\;-\\;\\bigg(\\frac{2k_{1/2}}{\\Delta x}\\bigg)T_1 \\;=\\; h_\\text{L}\\,T_{\\infty,\\text{L}},\n$$\n$$\n\\text{右:}\\quad -\\bigg(\\frac{2k_{N-\\frac{1}{2}}}{\\Delta x}\\bigg)T_{N-1} \\;+\\;\\bigg(\\frac{2k_{N-\\frac{1}{2}}}{\\Delta x} + h_\\text{R}\\bigg)T_N \\;=\\; h_\\text{R}\\,T_{\\infty,\\text{R}}.\n$$\n你必须实现托马斯算法（三对角矩阵算法，TDMA）来求解所得的三对角系统。从第一性原理出发，明确推导前向消元和回代公式，并解释其正确性。然后，编写一个完整的程序，为每个测试用例构建三对角系统，并使用推导出的 TDMA 公式进行求解。\n\n必须遵守物理单位：使用米 ($\\text{m}$)、开尔文 ($\\text{K}$)、瓦特每米开尔文 ($\\text{W}/(\\text{m}\\cdot\\text{K})$)、瓦特每立方米 ($\\text{W}/\\text{m}^3$) 和瓦特每平方米开尔文 ($\\text{W}/(\\text{m}^2\\cdot\\text{K})$)。\n\n测试套件：\n- 用例 $1$ (恒定热导率, 狄利克雷-狄利克雷, 无生热)：\n  - $L = 1\\,\\text{m}$，$N = 10$，$k(x) \\equiv 10\\,\\text{W}/(\\text{m}\\cdot\\text{K})$，$q'''(x) \\equiv 0\\,\\text{W}/\\text{m}^3$，$T(0) = 300\\,\\text{K}$，$T(L) = 350\\,\\text{K}$。\n  - 输出：节点温度列表 $[T_0,\\dots,T_{10}]$，单位为 $\\text{K}$。\n- 用例 $2$ (分段热导率, 诺伊曼-狄利克雷, 无生热)：\n  - $L = 1\\,\\text{m}$，$N = 8$，当 $x  L/2$ 时 $k(x) = 100\\,\\text{W}/(\\text{m}\\cdot\\text{K})$，当 $x \\ge L/2$ 时 $k(x) = 200\\,\\text{W}/(\\text{m}\\cdot\\text{K})$，$q'''(x) \\equiv 0\\,\\text{W}/\\text{m}^3$，左边界绝热 ($q''_\\text{L} = 0\\,\\text{W}/\\text{m}^2$)，右边界 $T(L) = 400\\,\\text{K}$。\n  - 输出：节点温度列表 $[T_0,\\dots,T_8]$，单位为 $\\text{K}$。\n- 用例 $3$ (恒定热导率, 狄利克雷-狄利克雷, 均匀生热)：\n  - $L = 0.02\\,\\text{m}$，$N = 20$，$k(x) \\equiv 200\\,\\text{W}/(\\text{m}\\cdot\\text{K})$，$q'''(x) \\equiv 1.0\\times 10^5\\,\\text{W}/\\text{m}^3$，$T(0) = 300\\,\\text{K}$，$T(L) = 300\\,\\text{K}$。\n  - 输出：节点温度列表 $[T_0,\\dots,T_{20}]$，单位为 $\\text{K}$。\n- 用例 $4$ (恒定热导率, 罗宾-罗宾, 无生热)：\n  - $L = 0.5\\,\\text{m}$，$N = 10$，$k(x) \\equiv 30\\,\\text{W}/(\\text{m}\\cdot\\text{K})$，$q'''(x) \\equiv 0\\,\\text{W}/\\text{m}^3$，左边界：$h_\\text{L} = 100\\,\\text{W}/(\\text{m}^2\\cdot\\text{K})$，$T_{\\infty,\\text{L}} = 290\\,\\text{K}$，右边界：$h_\\text{R} = 50\\,\\text{W}/(\\text{m}^2\\cdot\\text{K})$，$T_{\\infty,\\text{R}} = 310\\,\\text{K}$。\n  - 输出：节点温度列表 $[T_0,\\dots,T_{10}]$，单位为 $\\text{K}$。\n\n你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是一个节点温度列表（单位为 $\\text{K}$），四舍五入到 $6$ 位小数。例如：\n$$\n[\\text{case1\\_list},\\text{case2\\_list},\\text{case3\\_list},\\text{case4\\_list}]\n$$\n输出字符串中不含空格。",
            "solution": "用户提供了一个定义明確的计算热传导问题。所有必要的控制方程、离散化方案、边界条件和测试参数都已指定。该问题在科学上是合理的、自洽的，并且可以通过算法求解。因此，该问题是有效的。\n\n### 1. 有限差分公式\n\n问题是求解具有可变热导率 $k(x)$ 和体积生热率 $q'''(x)$ 的一维稳态热传导方程：\n$$\n\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right) + q'''(x) = 0\n$$\n域 $x \\in [0, L]$ 被离散化为一个具有 $N$ 个区间的均匀网格，从而产生 $N+1$ 个节点，索引为 $i=0, 1, \\dots, N$。网格间距为 $\\Delta x = L/N$，节点位置为 $x_i = i \\Delta x$。我们寻求节点温度 $T_i \\approx T(x_i)$。\n\n通过在以每个内部节点 $x_i$ 为中心的长度为 $\\Delta x$ 的控制体 (CV) 上对控制方程进行积分，可以推导出保守的有限差分格式。该 CV 从 $x_{i-1/2}$ 延伸到 $x_{i+1/2}$。\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( \\frac{d}{dx}\\left(k\\frac{dT}{dx}\\right) + q''' \\right) dx = 0\n$$\n对第一项应用微积分基本定理，并近似源项的积分，得到：\n$$\n\\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i+1/2}} - \\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i-1/2}} + q'''_i \\Delta x = 0\n$$\nCV 面上的热通量通过中心差分进行近似：\n$$\n\\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i+1/2}} \\approx k_{i+1/2} \\frac{T_{i+1} - T_i}{\\Delta x}\n$$\n$$\n\\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i-1/2}} \\approx k_{i-1/2} \\frac{T_i - T_{i-1}}{\\Delta x}\n$$\n界面热导率 $k_{i \\pm 1/2}$ 使用调和平均值计算，以正确处理材料属性的突变并确保热通量的连续性：\n$$\nk_{i-1/2} = \\frac{2}{\\frac{1}{k_{i-1}} + \\frac{1}{k_i}}, \\quad k_{i+1/2} = \\frac{2}{\\frac{1}{k_i} + \\frac{1}{k_{i+1}}}\n$$\n将通量近似值代入积分后的能量平衡方程中，得到：\n$$\nk_{i+1/2} \\frac{T_{i+1} - T_i}{\\Delta x} - k_{i-1/2} \\frac{T_i - T_{i-1}}{\\Delta x} + q'''_i \\Delta x = 0\n$$\n乘以 $-\\Delta x$ 并重新整理各项，得到问题陈述中提供的内部节点 $i \\in [1, N-1]$ 的线性方程：\n$$\n\\left(-\\frac{k_{i-1/2}}{\\Delta x}\\right) T_{i-1} + \\left(\\frac{k_{i-1/2} + k_{i+1/2}}{\\Delta x}\\right) T_i + \\left(-\\frac{k_{i+1/2}}{\\Delta x}\\right) T_{i+1} = -q'''_i \\Delta x\n$$\n该方程符合通用三对角形式 $a_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i$。\n\n### 2. 组装三对角系统\n\n用于求解 $N+1$ 个未知温度 $T_0, \\dots, T_N$ 的完整的 $N+1$ 个线性方程组是通过在每个节点应用适当的方程形成的。\n\n**内部节点 ($i = 1, \\dots, N-1$):**\n- $a_i = -k_{i-1/2} / \\Delta x$\n- $b_i = (k_{i-1/2} + k_{i+1/2}) / \\Delta x$\n- $c_i = -k_{i+1/2} / \\Delta x$\n- $d_i = -q'''_i \\Delta x$\n\n**边界节点 ($i=0$ 和 $i=N$):**\n系统的第一行 ($i=0$) 和最后一行 ($i=N$) 由边界条件确定。\n\n**左边界 ($i=0$):**\n1.  **狄利克雷:** $T_0 = T_L$。方程为 $1 \\cdot T_0 + 0 \\cdot T_1 = T_L$。\n    - $b_0 = 1$, $c_0 = 0$, $d_0 = T_L$。($a_0$ 未使用)。\n2.  **诺伊曼:** $-\\,k\\,\\frac{dT}{dx}\\big|_{\\text{face}} = q''_\\text{L}$。提供的离散化为 $\\left(\\frac{2k_{1/2}}{\\Delta x}\\right)T_0 - \\left(\\frac{2k_{1/2}}{\\Delta x}\\right)T_1 = q''_\\text{L}$。\n    - $b_0 = 2k_{1/2} / \\Delta x$, $c_0 = -2k_{1/2} / \\Delta x$, $d_0 = q''_\\text{L}$。\n3.  **罗宾:** 提供的离散化为 $\\left(\\frac{2k_{1/2}}{\\Delta x} + h_\\text{L}\\right)T_0 - \\left(\\frac{2k_{1/2}}{\\Delta x}\\right)T_1 = h_\\text{L}T_{\\infty,\\text{L}}$。\n    - $b_0 = 2k_{1/2}/\\Delta x + h_\\text{L}$, $c_0 = -2k_{1/2}/\\Delta x$, $d_0 = h_\\text{L}T_{\\infty,\\text{L}}$。\n\n**右边界 ($i=N$):**\n1.  **狄利克雷:** $T_N = T_R$。方程为 $1 \\cdot T_N = T_R$。\n    - $a_N = 0$, $b_N = 1$, $d_N = T_R$。($c_N$ 未使用)。\n2.  **诺伊曼:** $-\\,k\\,\\frac{dT}{dx}\\big|_{\\text{face}} = q''_\\text{R}$。提供的离散化为 $-\\left(\\frac{2k_{N-1/2}}{\\Delta x}\\right)T_{N-1} + \\left(\\frac{2k_{N-1/2}}{\\Delta x}\\right)T_N = -q''_\\text{R}$。\n    - $a_N = -2k_{N-1/2}/\\Delta x$, $b_N = 2k_{N-1/2}/\\Delta x$, $d_N = -q''_\\text{R}$。\n3.  **罗宾:** 提供的离散化为 $-\\left(\\frac{2k_{N-1/2}}{\\Delta x}\\right)T_{N-1} + \\left(\\frac{2k_{N-1/2}}{\\Delta x} + h_\\text{R}\\right)T_N = h_\\text{R}T_{\\infty,\\text{R}}$。\n    - $a_N = -2k_{N-1/2}/\\Delta x$, $b_N = 2k_{N-1/2}/\\Delta x + h_\\text{R}$, $d_N = h_\\text{R}T_{\\infty,\\text{R}}$。\n\n这些系数构成一个大小为 $(N+1) \\times (N+1)$ 的三对角线性方程组，可以高效求解。\n\n### 3. 托马斯算法 (TDMA) 的推导\n\n托马斯算法，或称三对角矩阵算法 (TDMA)，是高斯消元法针对三对角系统的一种特殊形式。它以 $O(N)$ 的操作次数求解系统，远比通用的 $O(N^3)$ 矩阵求逆高效。推导过程包括一个前向消元过程和一个回代过程。\n\n考虑方程组 $i = 0, \\dots, N$:\n$$\na_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i\n$$\n根据定义，$a_0 = 0$ 且 $c_N = 0$。\n\n**前向消元过程:**\n此过程的目标是将系统转换为上双对角形式。我们通过消去次对角线元素 $a_i$ 来实现这一点。\n\n第一个方程 ($i=0$) 是 $b_0 T_0 + c_0 T_1 = d_0$。我们可以用 $T_1$ 表示 $T_0$：\n$$\nT_0 = -\\frac{c_0}{b_0} T_1 + \\frac{d_0}{b_0}\n$$\n第二个方程 ($i=1$) 是 $a_1 T_0 + b_1 T_1 + c_1 T_2 = d_1$。代入 $T_0$ 的表达式：\n$$\na_1 \\left(-\\frac{c_0}{b_0} T_1 + \\frac{d_0}{b_0}\\right) + b_1 T_1 + c_1 T_2 = d_1\n$$\n重新整理各项：\n$$\n\\left(b_1 - \\frac{a_1 c_0}{b_0}\\right) T_1 + c_1 T_2 = d_1 - \\frac{a_1 d_0}{b_0}\n$$\n这个过程可以推广。我们执行行操作，将每个方程转换为 $T_i + c'_i T_{i+1} = d'_i$ 的形式。\n让我们定义修改后的系数 $c'_i$ 和 $d'_i$。\n\n对于 $i=0$:\n$$\nc'_0 = \\frac{c_0}{b_0}, \\quad d'_0 = \\frac{d_0}{b_0}\n$$\n对于 $i  0$，我们有原始方程 $a_i T_{i-1} + b_i T_i + c_i T_{i+1} = d_i$ 和之前为第 $i-1$ 行修改的方程：$T_{i-1} = -c'_{i-1} T_i + d'_{i-1}$。将 $T_{i-1}$ 的表达式代入第 $i$ 行的原始方程中：\n$$\na_i (-c'_{i-1} T_i + d'_{i-1}) + b_i T_i + c_i T_{i+1} = d_i\n$$\n按 $T_i$ 和 $T_{i+1}$ 分组：\n$$\n(b_i - a_i c'_{i-1}) T_i + c_i T_{i+1} = d_i - a_i d'_{i-1}\n$$\n除以 $T_i$ 的新系数以将其分离出来，得到修改后系数的递推关系：\n$$\nc'_i = \\frac{c_i}{b_i - a_i c'_{i-1}}, \\quad d'_i = \\frac{d_i - a_i d'_{i-1}}{b_i - a_i c'_{i-1}}\n$$\n这些递推关系适用于 $i = 1, \\dots, N$。注意对于 $i=N$，$c_N=0$，所以 $c'_N=0$。\n\n前向消元扫描过程如下：\n1.  计算 $c'_0 = c_0/b_0$ 和 $d'_0 = d_0/b_0$。\n2.  对于 $i = 1, \\dots, N$，使用递推关系计算 $c'_i$ 和 $d'_i$。\n\n**回代过程:**\n在前向过程之后，系统已转换为上双对角形式：\n$$\nT_i + c'_i T_{i+1} = d'_i \\quad \\text{for } i=0, \\dots, N-1\n$$\n$$\nT_N = d'_N \\quad (\\text{因为 } c'_N = 0)\n$$\n最后一个温度 $T_N$ 是直接已知的：\n$$\nT_N = d'_N\n$$\n剩下的温度可以通过从 $i=N-1$ 向下到 $0$ 进行回代来找到：\n$$\nT_i = d'_i - c'_i T_{i+1}\n$$\n回代扫描过程如下：\n1.  设置 $T_N = d'_N$。\n2.  对于 $i = N-1, N-2, \\dots, 0$，计算 $T_i = d'_i - c'_i T_{i+1}$。\n\n这个两步过程完成了求解。对于对角占优矩阵，该算法是数值稳定的，我们所考虑的物理系统满足这一条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tdma(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal linear system Ax=d using the Thomas algorithm (TDMA).\n\n    Args:\n        a (np.ndarray): The sub-diagonal (indices 1 to n-1). a[0] is ignored.\n        b (np.ndarray): The main diagonal (indices 0 to n-1).\n        c (np.ndarray): The super-diagonal (indices 0 to n-2). c[n-1] is ignored.\n        d (np.ndarray): The right-hand side vector.\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = len(d)\n    c_prime = np.zeros(n)\n    d_prime = np.zeros(n)\n    x = np.zeros(n)\n\n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n\n    for i in range(1, n):\n        denom = b[i] - a[i] * c_prime[i-1]\n        c_prime[i] = c[i] / denom\n        d_prime[i] = (d[i] - a[i] * d_prime[i-1]) / denom\n\n    # Backward substitution\n    x[n-1] = d_prime[n-1]\n    for i in range(n-2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i+1]\n\n    return x\n\ndef solve_heat_conduction(L, N, k_func, q_func, bc_left, bc_right):\n    \"\"\"\n    Constructs and solves the 1D steady heat conduction problem using FDM.\n    \"\"\"\n    # 1. Setup grid and properties\n    x_nodes = np.linspace(0, L, N + 1)\n    dx = L / N\n    \n    k_vals = np.array([k_func(x) for x in x_nodes])\n    q_vals = np.array([q_func(x) for x in x_nodes])\n\n    # 2. Compute interface conductivities\n    k_interface = np.zeros(N)\n    for i in range(N):\n        # Harmonic mean for k_{i+1/2}\n        if k_vals[i] == 0 or k_vals[i+1] == 0:\n            k_interface[i] = 0 # Or handle as insulated\n        else:\n            k_interface[i] = 2.0 / (1.0/k_vals[i] + 1.0/k_vals[i+1])\n\n    # 3. Initialize tridiagonal system coefficients\n    num_nodes = N + 1\n    a = np.zeros(num_nodes) # sub-diagonal\n    b = np.zeros(num_nodes) # main-diagonal\n    c = np.zeros(num_nodes) # super-diagonal\n    d = np.zeros(num_nodes) # RHS vector\n\n    # 4. Fill coefficients for interior nodes (i = 1 to N-1)\n    for i in range(1, N):\n        a[i] = -k_interface[i-1] / dx\n        b[i] = (k_interface[i-1] + k_interface[i]) / dx\n        c[i] = -k_interface[i] / dx\n        d[i] = -q_vals[i] * dx\n\n    # 5. Fill coefficients for boundary nodes (i=0 and i=N)\n    # Left boundary (i=0)\n    bc_type_L, bc_val_L = bc_left[0], bc_left[1:]\n    if bc_type_L == 'dirichlet':\n        b[0] = 1.0\n        c[0] = 0.0\n        d[0] = bc_val_L[0]\n    elif bc_type_L == 'neumann':\n        q_L = bc_val_L[0]\n        b[0] = 2 * k_interface[0] / dx\n        c[0] = -2 * k_interface[0] / dx\n        d[0] = q_L\n    elif bc_type_L == 'robin':\n        h_L, T_inf_L = bc_val_L\n        b[0] = 2 * k_interface[0] / dx + h_L\n        c[0] = -2 * k_interface[0] / dx\n        d[0] = h_L * T_inf_L\n\n    # Right boundary (i=N)\n    bc_type_R, bc_val_R = bc_right[0], bc_right[1:]\n    if bc_type_R == 'dirichlet':\n        a[N] = 0.0\n        b[N] = 1.0\n        d[N] = bc_val_R[0]\n    elif bc_type_R == 'neumann':\n        q_R = bc_val_R[0]\n        a[N] = -2 * k_interface[N-1] / dx\n        b[N] = 2 * k_interface[N-1] / dx\n        d[N] = -q_R\n    elif bc_type_R == 'robin':\n        h_R, T_inf_R = bc_val_R\n        a[N] = -2 * k_interface[N-1] / dx\n        b[N] = 2 * k_interface[N-1] / dx + h_R\n        d[N] = h_R * T_inf_R\n\n    # 6. Solve the system\n    T = solve_tdma(a, b, c, d)\n    return T\n\n\ndef solve():\n    test_cases = [\n        # Case 1\n        {\n            \"L\": 1.0, \"N\": 10, \"k_func\": lambda x: 10.0, \"q_func\": lambda x: 0.0,\n            \"bc_left\": ('dirichlet', 300.0), \"bc_right\": ('dirichlet', 350.0)\n        },\n        # Case 2\n        {\n            \"L\": 1.0, \"N\": 8, \"k_func\": lambda x: 100.0 if x  0.5 else 200.0, \"q_func\": lambda x: 0.0,\n            \"bc_left\": ('neumann', 0.0), \"bc_right\": ('dirichlet', 400.0)\n        },\n        # Case 3\n        {\n            \"L\": 0.02, \"N\": 20, \"k_func\": lambda x: 200.0, \"q_func\": lambda x: 1.0e5,\n            \"bc_left\": ('dirichlet', 300.0), \"bc_right\": ('dirichlet', 300.0)\n        },\n        # Case 4\n        {\n            \"L\": 0.5, \"N\": 10, \"k_func\": lambda x: 30.0, \"q_func\": lambda x: 0.0,\n            \"bc_left\": ('robin', 100.0, 290.0), \"bc_right\": ('robin', 50.0, 310.0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        T = solve_heat_conduction(\n            case[\"L\"], case[\"N\"], case[\"k_func\"], case[\"q_func\"],\n            case[\"bc_left\"], case[\"bc_right\"]\n        )\n        results.append(T)\n\n    # Format the final output string exactly as required\n    result_strings = []\n    for T in results:\n        # Format each temperature list to a string '[T0,T1,...]'\n        # with numbers rounded to 6 decimal places.\n        temp_list_str = f\"[{','.join([f'{temp:.6f}' for temp in T])}]\"\n        result_strings.append(temp_list_str)\n\n    # Join the individual case strings into the final format '[[...],[...]]'\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "构建求解器后，下一个关键步骤是验证其正确性并量化其精度。本实践问题  介绍了“人造解法”（Method of Manufactured Solutions），这是一种强有力的代码验证技术。通过设计一个具有已知精确解的问题，您将执行网格加密研究，以数值方式计算求解器的收敛阶，从而验证您的实现是否符合理论预期。",
            "id": "3954376",
            "problem": "考虑在一维空间区间 $[0,1]$（单位为米）上的稳态热传导，其热导率为 $k(x)$，体积生热率为 $s(x)$（单位为瓦特每立方米）。控制方程由傅里叶热传导定律和稳态能量守恒结合得出，其微分方程为\n$$\n-\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right) = s(x),\n$$\n边界条件在 $x=0$ 和 $x=1$ 处指定。您将实现一个二阶精度的有限差分法 (FDM)，该方法作用于一个包含 $N$ 个节点（包括边界）的均匀网格，网格间距 $h = \\frac{1}{N-1}$，以数值方式近似温度场 $T(x)$（单位为开尔文）。使用守恒的内部离散格式\n$$\n-\\frac{1}{h^2}\\left(k_{i+\\frac{1}{2}}\\left(T_{i+1}-T_i\\right) - k_{i-\\frac{1}{2}}\\left(T_i - T_{i-1}\\right)\\right) = s(x_i),\n$$\n用于内部节点 $i=1,\\dots,N-2$，其中界面热导率 $k_{i\\pm\\frac{1}{2}}$ 必须通过调和平均值来近似\n$$\nk_{i+\\frac{1}{2}} = \\left(\\frac{1}{2}\\left(\\frac{1}{k_i} + \\frac{1}{k_{i+1}}\\right)\\right)^{-1} = \\frac{2 k_i k_{i+1}}{k_i + k_{i+1}},\n$$\n$k_{i-\\frac{1}{2}}$ 的计算也类似。对于狄利克雷边界条件，在边界节点上强制施加精确温度。对于在 $x=1$ 处具有零热通量和恒定热导率的诺伊曼边界条件，使用二阶精度公式强制施加边界导数\n$$\n\\frac{3 T_{N-1} - 4 T_{N-2} + T_{N-3}}{2h} = 0.\n$$\n您将使用构造解进行网格加密分析，以便解析解是已知的。对于每个测试用例，定义精确解 $T_{\\text{exact}}(x)$（单位为开尔文）、热导率 $k(x)$、从控制方程导出的源项 $s(x)$（单位为瓦特每立方米）以及适当的边界条件。对三个连续的 $N$ 值计算数值解，并评估离散 $L^2$ 误差范数\n$$\nE_N = \\sqrt{h \\sum_{i=0}^{N-1} \\left(T_i^{\\text{num}} - T_{\\text{exact}}(x_i)\\right)^2},\n$$\n其中 $x_i = i h$，$T_i^{\\text{num}}$ 是节点 $i$ 处计算出的数值温度，$T_{\\text{exact}}(x_i)$ 是该节点处的精确温度。根据两个最精细的网格，计算观测到的精度阶\n$$\np_{\\text{obs}} = \\frac{\\ln\\left(E_{N_2}/E_{N_3}\\right)}{\\ln\\left(h_{N_2}/h_{N_3}\\right)},\n$$\n其中 $h_N = \\frac{1}{N-1}$，$(N_1,N_2,N_3)$ 是测试用例的连续网格尺寸。将 $p_{\\text{obs}}$ 报告为无量纲浮点数。\n\n测试套件：\n- 测试用例 1 (Dirichlet–Dirichlet，恒定热导率):\n  - 域: $x \\in [0,1]$ 米。\n  - 热导率: $k(x) = 1$ 瓦特每米开尔文。\n  - 精确解: $T_{\\text{exact}}(x) = \\sin(\\pi x)$ 开尔文。\n  - 源项: $s(x) = -\\frac{d}{dx}\\left(k(x)\\frac{dT_{\\text{exact}}}{dx}\\right) = \\pi^2 \\sin(\\pi x)$ 瓦特每立方米。\n  - 边界条件: $T(0) = 0$ 开尔文, $T(1) = 0$ 开尔文。\n  - 网格尺寸: $(N_1,N_2,N_3) = (21, 41, 81)$。\n\n- 测试用例 2 (Dirichlet–Dirichlet，平滑变化的热导率):\n  - 域: $x \\in [0,1]$ 米。\n  - 热导率: $k(x) = 1 + x$ 瓦特每米开尔文。\n  - 精确解: $T_{\\text{exact}}(x) = \\sin(\\pi x)$ 开尔文。\n  - 源项: $s(x) = -\\frac{d}{dx}\\left(k(x)\\frac{dT_{\\text{exact}}}{dx}\\right) = (1+x)\\pi^2 \\sin(\\pi x) - \\pi \\cos(\\pi x)$ 瓦特每立方米。\n  - 边界条件: $T(0) = 0$ 开尔文, $T(1) = 0$ 开尔文。\n  - 网格尺寸: $(N_1,N_2,N_3) = (17, 33, 65)$。\n\n- 测试用例 3 (Dirichlet–Neumann，恒定热导率，右边界零通量):\n  - 域: $x \\in [0,1]$ 米。\n  - 热导率: $k(x) = 1$ 瓦特每米开尔文。\n  - 精确解: $T_{\\text{exact}}(x) = \\sin\\left(\\frac{\\pi}{2} x\\right)$ 开尔文。\n  - 源项: $s(x) = -\\frac{d}{dx}\\left(k(x)\\frac{dT_{\\text{exact}}}{dx}\\right) = \\left(\\frac{\\pi}{2}\\right)^2 \\sin\\left(\\frac{\\pi}{2} x\\right)$ 瓦特每立方米。\n  - 边界条件: $T(0) = 0$ 开尔文，以及在 $x=1$ 处零通量 $k \\frac{dT}{dx}(1) = 0$。\n  - 网格尺寸: $(N_1,N_2,N_3) = (19, 37, 73)$。\n\n您的程序必须：\n- 实现所述的 FDM，为每个 $N$ 组装并求解得到的线性系统。\n- 在每个测试用例中为每个 $N$ 计算 $E_{N}$，然后从两个最精细的网格计算 $p_{\\text{obs}}$。\n- 生成单行输出，其中包含三个 $p_{\\text{obs}}$ 值，按测试用例的顺序排列，形式为方括号括起来的逗号分隔列表。例如：“[p1,p2,p3]”。\n所有 $p_{\\text{obs}}$ 的输出均为无量纲浮点数。",
            "solution": "该问题要求实现一种二阶精度的有限差分法 (FDM)，以求解在区间 $x \\in [0, 1]$ 上的一维稳态热传导方程。控制方程为\n$$\n-\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right) = s(x),\n$$\n其中 $T(x)$ 是温度，$k(x)$ 是热导率，$s(x)$ 是体积生热率。目标是使用构造解法进行网格加密研究，以验证数值格式的二阶精度。\n\n首先，将空间域 $[0, 1]$ 离散为包含 $N$ 个节点的均匀网格。节点坐标由 $x_i = i h$ 给出，其中 $i = 0, 1, \\dots, N-1$，$h = 1/(N-1)$ 是恒定的网格间距。这些节点上的温度 $T(x_i)$ 记为 $T_i$。\n\n对于内部节点 $i = 1, \\dots, N-2$，我们应用所提供的守恒有限差分离散格式。该格式是通过将控制方程在以每个节点为中心、从 $x_i - h/2$ 到 $x_i + h/2$ 的控制体积上积分得到的。这导出了离散方程：\n$$\n-\\frac{1}{h} \\left( \\left. k \\frac{dT}{dx} \\right|_{i+\\frac{1}{2}} - \\left. k \\frac{dT}{dx} \\right|_{i-\\frac{1}{2}} \\right) = s(x_i).\n$$\n控制体表面上的通量 $\\left. k \\frac{dT}{dx} \\right|_{i\\pm\\frac{1}{2}}$ 使用中心差分进行近似，例如 $\\left. k \\frac{dT}{dx} \\right|_{i+\\frac{1}{2}} \\approx k_{i+\\frac{1}{2}} \\frac{T_{i+1}-T_i}{h}$。这得到了指定的公式：\n$$\n-\\frac{1}{h^2}\\left(k_{i+\\frac{1}{2}}\\left(T_{i+1}-T_i\\right) - k_{i-\\frac{1}{2}}\\left(T_i - T_{i-1}\\right)\\right) = s(x_i).\n$$\n界面热导率 $k_{i\\pm\\frac{1}{2}}$ 是使用相邻节点热导率的调和平均值计算的：\n$$\nk_{i+\\frac{1}{2}} = \\frac{2 k(x_i) k(x_{i+1})}{k(x_i) + k(x_{i+1})} \\quad \\text{和} \\quad k_{i-\\frac{1}{2}} = \\frac{2 k(x_{i-1}) k(x_i)}{k(x_{i-1}) + k(x_i)}.\n$$\n调和平均值在确保通量守恒方面特别有效，尤其是在热导率急剧变化时。\n\n对内部节点方程进行重排，按未知温度 $T_{i-1}$、$T_i$ 和 $T_{i+1}$ 分组，可为每个内部节点 $i$ 得到一个线性代数方程：\n$$\n\\left(-\\frac{k_{i-\\frac{1}{2}}}{h^2}\\right) T_{i-1} + \\left(\\frac{k_{i-\\frac{1}{2}} + k_{i+\\frac{1}{2}}}{h^2}\\right) T_i + \\left(-\\frac{k_{i+\\frac{1}{2}}}{h^2}\\right) T_{i+1} = s(x_i).\n$$\n这 $N-2$ 个方程，与节点 $i=0$ 和 $i=N-1$ 处的两个边界条件方程相结合，构成了一个包含 $N$ 个未知数的 $N$ 个线性方程组，可以写成矩阵形式 $A\\mathbf{T} = \\mathbf{b}$。这里，$\\mathbf{T} = [T_0, T_1, \\dots, T_{N-1}]^T$ 是未知节点温度的向量，$A$ 是一个 $N \\times N$ 的系数矩阵，$\\mathbf{b}$ 是一个 $N \\times 1$ 的源向量。\n\n边界条件决定了系统的第一行 ($i=0$) 和最后一行 ($i=N-1$)。\n对于狄利克雷边界条件，例如 $T(0) = T_0^{\\text{exact}}$，对应的方程就是 $1 \\cdot T_0 = T_0^{\\text{exact}}$。这将矩阵 $A$ 的第一行设置为 $[1, 0, \\dots, 0]$，并将 $\\mathbf{b}$ 的第一个元素设置为 $T_0^{\\text{exact}}$。对于最后一行，$x=1$ 处的狄利克雷条件也做类似处理。\n\n对于 $x=1$ 处的零通量诺伊曼边界条件 $k(1)\\frac{dT}{dx}(1) = 0$，需要对导数进行离散近似。问题指定了一个二阶精度的单边公式：\n$$\n\\frac{3 T_{N-1} - 4 T_{N-2} + T_{N-3}}{2h} = 0.\n$$\n这直接给出了系统的最后一个方程：$T_{N-3} - 4T_{N-2} + 3T_{N-1} = 0$。对于这个方程，矩阵 $A$ 的最后一行将在第 $N-3$、$N-2$ 和 $N-1$ 列有非零项，值分别为 $1$、$-4$ 和 $3$。$\\mathbf{b}$ 中对应的元素为 $0$。\n\n一旦针对给定的测试用例和网格尺寸 $N$ 完全组装好矩阵 $A$ 和向量 $\\mathbf{b}$，就可以求解该线性系统以得到数值解向量 $\\mathbf{T}^{\\text{num}}$。\n\n为验证实现，我们使用提供的构造解。对于每个 $N$，将数值解 $\\mathbf{T}^{\\text{num}}$ 与在网格点上求值的精确解 $\\mathbf{T}^{\\text{exact}}$ 进行比较。误差使用离散 $L^2$ 范数进行量化：\n$$\nE_N = \\sqrt{h \\sum_{i=0}^{N-1} \\left(T_i^{\\text{num}} - T_{\\text{exact}}(x_i)\\right)^2}.\n$$\n然后，使用来自两个最精细网格 $N_2$ 和 $N_3$ 的误差计算观测到的精度阶 $p_{\\text{obs}}$：\n$$\np_{\\text{obs}} = \\frac{\\ln\\left(E_{N_2}/E_{N_3}\\right)}{\\ln\\left(h_{N_2}/h_{N_3}\\right)}.\n$$\n对于二阶精度的格式，我们期望随着网格加密，$p_{\\text{obs}} \\approx 2$。程序将对所有三个测试用例执行此过程，并报告计算出的 $p_{\\text{obs}}$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_bvp(N, k_func, s_func, bc_left_tuple, bc_right_tuple):\n    \"\"\"\n    Solves the 1D steady conduction BVP using a finite difference method.\n\n    Args:\n        N (int): Number of grid nodes.\n        k_func (callable): Function k(x) for thermal conductivity.\n        s_func (callable): Function s(x) for the source term.\n        bc_left_tuple (tuple): Tuple of (type, value) for the left BC.\n        bc_right_tuple (tuple): Tuple of (type, value) for the right BC.\n\n    Returns:\n        np.array: The numerical solution for temperature T at the grid nodes.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    x = np.linspace(0.0, 1.0, N)\n\n    k_vals = k_func(x)\n    s_vals = s_func(x)\n\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # Interior nodes (i=1, ..., N-2)\n    for i in range(1, N - 1):\n        k_im1 = k_vals[i - 1]\n        k_i = k_vals[i]\n        k_ip1 = k_vals[i + 1]\n\n        # Harmonic mean for interface conductivity\n        k_imhalf = (2.0 * k_im1 * k_i) / (k_im1 + k_i)\n        k_iphalf = (2.0 * k_i * k_ip1) / (k_i + k_ip1)\n\n        A[i, i - 1] = -k_imhalf / (h * h)\n        A[i, i] = (k_imhalf + k_iphalf) / (h * h)\n        A[i, i + 1] = -k_iphalf / (h * h)\n        b[i] = s_vals[i]\n\n    # Boundary conditions\n    # Left BC at x=0 (node i=0)\n    bc_left_type, bc_left_val = bc_left_tuple\n    if bc_left_type == 'dirichlet':\n        A[0, 0] = 1.0\n        b[0] = bc_left_val\n    \n    # Right BC at x=1 (node i=N-1)\n    bc_right_type, bc_right_val = bc_right_tuple\n    if bc_right_type == 'dirichlet':\n        A[N - 1, N - 1] = 1.0\n        b[N - 1] = bc_right_val\n    elif bc_right_type == 'neumann':\n        # Zero-flux Neumann BC: 3*T_{N-1} - 4*T_{N-2} + T_{N-3} = 0\n        if bc_right_val == 0.0:\n            A[N - 1, N - 3] = 1.0\n            A[N - 1, N - 2] = -4.0\n            A[N - 1, N - 1] = 3.0\n            b[N - 1] = 0.0\n\n    # Solve the linear system\n    T_num = np.linalg.solve(A, b)\n    return T_num\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1: DD, constant k\",\n            \"k_func\": lambda x: np.full_like(x, 1.0),\n            \"T_exact_func\": lambda x: np.sin(np.pi * x),\n            \"s_func\": lambda x: np.pi**2 * np.sin(np.pi * x),\n            \"bc_left\": ('dirichlet', 0.0),\n            \"bc_right\": ('dirichlet', 0.0),\n            \"meshes\": (21, 41, 81)\n        },\n        {\n            \"name\": \"Case 2: DD, variable k\",\n            \"k_func\": lambda x: 1.0 + x,\n            \"T_exact_func\": lambda x: np.sin(np.pi * x),\n            \"s_func\": lambda x: (1.0 + x) * np.pi**2 * np.sin(np.pi * x) - np.pi * np.cos(np.pi * x),\n            \"bc_left\": ('dirichlet', 0.0),\n            \"bc_right\": ('dirichlet', 0.0),\n            \"meshes\": (17, 33, 65)\n        },\n        {\n            \"name\": \"Case 3: DN, constant k\",\n            \"k_func\": lambda x: np.full_like(x, 1.0),\n            \"T_exact_func\": lambda x: np.sin(np.pi / 2.0 * x),\n            \"s_func\": lambda x: (np.pi / 2.0)**2 * np.sin(np.pi / 2.0 * x),\n            \"bc_left\": ('dirichlet', 0.0),\n            \"bc_right\": ('neumann', 0.0),\n            \"meshes\": (19, 37, 73)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        errors = []\n        h_vals = []\n        for N in case[\"meshes\"]:\n            h = 1.0 / (N - 1)\n            x = np.linspace(0.0, 1.0, N)\n            \n            # Solve for numerical temperature\n            T_num = solve_bvp(N, case[\"k_func\"], case[\"s_func\"], case[\"bc_left\"], case[\"bc_right\"])\n            \n            # Get exact temperature\n            T_exact = case[\"T_exact_func\"](x)\n            \n            # Calculate L2 error\n            error = np.sqrt(h * np.sum((T_num - T_exact)**2))\n            errors.append(error)\n            h_vals.append(h)\n            \n        # Unpack errors and grid spacings\n        E_N2, E_N3 = errors[1], errors[2]\n        h_N2, h_N3 = h_vals[1], h_vals[2]\n\n        # Compute observed order of accuracy\n        p_obs = np.log(E_N2 / E_N3) / np.log(h_N2 / h_N3)\n        results.append(p_obs)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的练习  将挑战您将技能应用于一个更复杂、更实际的场景：带有热接触电阻的复合板中的热传导。您将基于热阻类比法，实现一个单元中心有限差分格式，这是一种对多材料系统建模的直观而强大的方法。通过将您的数值结果与解析解进行验证，您将增强对异质材料和界面进行建模的信心，这是高等热分析中的一项常见任务。",
            "id": "3954435",
            "problem": "考虑一个双层平面板中的一维稳态热传导问题，每层的热导率恒定，且在界面处存在热接触电阻。其控制物理基础是能量守恒和傅里叶热传导定律。在稳态下，热通量在空间上是恒定的，每个均匀层内的温度场是线性的。由于热接触电阻的存在，界面处会出现与热通量成正比的有限温度跳跃。两端的边界为给定的温度（狄利克雷类型）。目标是验证一种有限差分格式，该格式使用基于电阻的表面电导来处理界面，并与精确的解析解进行对比。\n\n您必须推导并实现一种离散化方法，该方法通过在控制体积上对一维稳态热传导方程进行积分，并利用热阻表示表面热通量而得到。假设横截面积为单位面积。使用以下基本原理：\n- 固定控制体积的能量守恒：在稳态下，穿过控制体积表面的净传导热流为零。\n- 傅里叶热传导定律：热通量由 $q = -k \\,\\dfrac{dT}{dx}$ 给出，其中 $k$ 是热导率，$T$ 是温度，$x$ 是空间坐标。\n- 界面热接触电阻：界面上的温降为 $\\Delta T_{\\text{int}} = q\\,R_c$，其中 $R_c$ 是接触电阻。\n\n离散化要求：\n- 将厚度为 $L_1$ 的层 $1$ 划分为 $N_1$ 个宽度为 $\\Delta x_1 = L_1/N_1$ 的均匀控制体积。将厚度为 $L_2$ 的层 $2$ 划分为 $N_2$ 个宽度为 $\\Delta x_2 = L_2/N_2$ 的均匀控制体积。将节点未知量置于控制体积中心；界面与层 $1$ 的最后一个控制体积和层 $2$ 的第一个控制体积之间的面重合。\n- 对于电导率为 $k$ 的均匀层中的内部面，使用面电导 $G = \\dfrac{1}{\\left(\\dfrac{\\Delta x}{2}\\dfrac{1}{k} + \\dfrac{\\Delta x}{2}\\dfrac{1}{k}\\right)} = \\dfrac{k}{\\Delta x}$。\n- 对于具有狄利克雷温度 $T_{\\mathrm{b}}$ 的边界表面，使用半单元面电导 $G = \\dfrac{1}{\\left(\\dfrac{\\Delta x}{2}\\dfrac{1}{k}\\right)} = \\dfrac{2k}{\\Delta x}$，并将 $G\\,T_{\\mathrm{b}}$ 合并到相邻节点的离散平衡方程的源项中。\n- 对于电导率分别为 $k_1$ 和 $k_2$、半单元宽度分别为 $\\dfrac{\\Delta x_1}{2}$ 和 $\\dfrac{\\Delta x_2}{2}$ 以及接触电阻为 $R_c$（单位 $\\mathrm{m^2\\,K/W}$）的两层之间的界面，使用复合面电导 $$G_{\\mathrm{int}} = \\dfrac{1}{\\left(\\dfrac{\\Delta x_1}{2}\\dfrac{1}{k_1} + R_c + \\dfrac{\\Delta x_2}{2}\\dfrac{1}{k_2}\\right)}.$$ 为节点温度 $T_i$ 建立一个三对角线性系统，使得在每个内部节点处，流入和流出的传导通量之和为零，已知的边界温度通过源项引入。\n\n用于验证的解析解：\n- 设总厚度为 $L = L_1 + L_2$，左边界 $x=0$ 处的温度为 $T_0$，右边界 $x=L$ 处的温度为 $T_L$。\n- 恒定热通量为 $$q = \\dfrac{T_0 - T_L}{\\left(\\dfrac{L_1}{k_1} + R_c + \\dfrac{L_2}{k_2}\\right)}.$$\n- 精确的温度分布是分段线性的：\n  - 对于 $0 \\le x \\le L_1$：$$T(x) = T_0 - \\dfrac{q}{k_1}\\,x.$$\n  - 对于 $L_1 \\le x \\le L$：$$T(x) = T_L + \\dfrac{q}{k_2}\\,(L - x).$$\n- 在层 $1$ 中，节点位置为 $x_i = \\left(i + \\dfrac{1}{2}\\right)\\Delta x_1$，其中 $i = 0,1,\\dots,N_1-1$；在层 $2$ 中，节点位置为 $x_i = L_1 + \\left(j + \\dfrac{1}{2}\\right)\\Delta x_2$，其中 $j = 0,1,\\dots,N_2-1$。\n\n验证指标：\n- 对于每个测试用例，计算离散节点温度与在相同节点位置上计算的解析温度之间的最大绝对逐点误差。误差以开尔文（$\\mathrm{K}$）为单位表示，并四舍五入到 $6$ 位小数。\n\n测试套件：\n为以下参数集提供结果，所有量均使用相干单位：\n- 测试用例 $1$（一般情况）：$L_1 = 0.04\\,\\mathrm{m}$，$L_2 = 0.06\\,\\mathrm{m}$，$k_1 = 16\\,\\mathrm{W/(m\\,K)}$，$k_2 = 45\\,\\mathrm{W/(m\\,K)}$，$R_c = 5\\times 10^{-4}\\,\\mathrm{m^2\\,K/W}$，$T_0 = 400\\,\\mathrm{K}$，$T_L = 300\\,\\mathrm{K}$，$N_1 = 40$，$N_2 = 60$。\n- 测试用例 $2$（大接触电阻）：$L_1 = 0.02\\,\\mathrm{m}$，$L_2 = 0.02\\,\\mathrm{m}$，$k_1 = 200\\,\\mathrm{W/(m\\,K)}$，$k_2 = 200\\,\\mathrm{W/(m\\,K)}$，$R_c = 5\\times 10^{-2}\\,\\mathrm{m^2\\,K/W}$，$T_0 = 350\\,\\mathrm{K}$，$T_L = 300\\,\\mathrm{K}$，$N_1 = 20$，$N_2 = 20$。\n- 测试用例 $3$（零接触电阻）：$L_1 = 0.03\\,\\mathrm{m}$，$L_2 = 0.07\\,\\mathrm{m}$，$k_1 = 5\\,\\mathrm{W/(m\\,K)}$，$k_2 = 150\\,\\mathrm{W/(m\\,K)}$，$R_c = 0\\,\\mathrm{m^2\\,K/W}$，$T_0 = 500\\,\\mathrm{K}$，$T_L = 300\\,\\mathrm{K}$，$N_1 = 30$，$N_2 = 70$。\n- 测试用例 $4$（层间网格高度不均匀）：$L_1 = 0.1\\,\\mathrm{m}$，$L_2 = 0.9\\,\\mathrm{m}$，$k_1 = 40\\,\\mathrm{W/(m\\,K)}$，$k_2 = 40\\,\\mathrm{W/(m\\,K)}$，$R_c = 10^{-6}\\,\\mathrm{m^2\\,K/W}$，$T_0 = 310\\,\\mathrm{K}$，$T_L = 290\\,\\mathrm{K}$，$N_1 = 3$，$N_2 = 97$。\n- 测试用例 $5$（第一层非常薄）：$L_1 = 10^{-3}\\,\\mathrm{m}$，$L_2 = 9.9\\times 10^{-2}\\,\\mathrm{m}$，$k_1 = 10\\,\\mathrm{W/(m\\,K)}$，$k_2 = 10\\,\\mathrm{W/(m\\,K)}$，$R_c = 10^{-3}\\,\\mathrm{m^2\\,K/W}$，$T_0 = 1000\\,\\mathrm{K}$，$T_L = 900\\,\\mathrm{K}$，$N_1 = 1$，$N_2 = 99$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目是相应测试用例的最大绝对误差（单位：开尔文），四舍五入到 $6$ 位小数（例如，$\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$）。不应打印任何其他文本。",
            "solution": "问题陈述经评估有效。它具有科学依据，提法得当且客观。它提出了计算传热学中的一个标准问题——通过带接触电阻的复合板的一维稳态热传导。所提供的控制方程、离散化方案和解析解都是正确的，并且与热工和数值方法的既定原理相一致。测试用例定义明确，并为唯一解提供了所有必要的数据。\n\n求解过程首先基于指定的有限差分法（FDM）构建数值模型，然后实现所提供的解析解，最后计算每个测试用例中两者之间的最大绝对误差。\n\n**1. 有限差分法（FDM）公式**\n\n物理域由总厚度为 $L=L_1+L_2$ 的两层组成，被离散为 $N = N_1 + N_2$ 个连续的控制体积（CV）。节点温度 $T_i$ 定义在每个控制体积 $i$ 的中心。应用于每个控制体积的基本原理是能量守恒，对于没有热源的稳态传导，这简化为穿过控制体积各个面的传热速率之和为零。\n\n穿过两个节点 $i$ 和 $j$ 之间的一个面的热流率 $Q$ 使用热导 $G$ 建模为 $Q = G(T_i - T_j)$，其中面积假定为单位一。这类似于欧姆定律，温差为电势，热流为电流。对于未知节点温度 $T_i$（$i=0, \\dots, N-1$），整个方程组构成一个线性系统 $\\mathbf{A}\\mathbf{T} = \\mathbf{b}$，其中 $\\mathbf{T}$ 是节点温度向量。每个节点 $i$ 的方程的具体形式为：\n\n$$ G_{\\text{left}}(T_{\\text{left}} - T_i) + G_{\\text{right}}(T_{\\text{right}} - T_i) = 0 $$\n\n其中 $T_{\\text{left}}$ 和 $T_{\\text{right}}$ 是相邻节点（或边界）的温度，而 $G_{\\text{left}}$ 和 $G_{\\text{right}}$ 分别是到控制体积左、右面的热导。这可以重排为矩阵系统中的一行的形式：$G_{\\text{left}}T_{\\text{left}} - (G_{\\text{left}} + G_{\\text{right}})T_i + G_{\\text{right}}T_{\\text{right}} = 0$。\n\n热导根据热阻定义为 $G = 1/R_{th}$。问题指定了不同面类型的热导：\n\n- **内部面（在层1或层2内）：** 对于均匀材料中（电导率为 $k$，网格间距为 $\\Delta x$）两个节点之间的面，热阻是两个半单元热阻之和：$R_{th} = \\frac{\\Delta x/2}{k} + \\frac{\\Delta x/2}{k} = \\frac{\\Delta x}{k}$。热导为 $G = \\frac{k}{\\Delta x}$。\n\n- **边界表面（在 $x=0$ 或 $x=L$ 处）：** 对于狄利克雷边界上温度为 $T_{\\mathrm{b}}$ 的面，热阻为单个半单元的热阻：$R_{th} = \\frac{\\Delta x/2}{k}$。热导为 $G_{\\mathrm{b}} = \\frac{2k}{\\Delta x}$。已知的边界温度被并入源向量 $\\mathbf{b}$。对于节点 $0$，项 $G_{\\mathrm{b}}T_0$ 被移到等式右侧。对于最后一个节点 $N-1$，项 $G_{\\mathrm{b}}T_L$ 被移到等式右侧。\n\n- **界面（层1和层2之间）：** 在节点 $N_1-1$（层1）和节点 $N_1$（层2）之间的界面处，总热阻是三个串联热阻之和：层1中的半单元热阻、接触电阻 $R_c$ 和层2中的半单元热阻。因此，界面热导为：\n$$ G_{\\mathrm{int}} = \\frac{1}{\\frac{\\Delta x_1/2}{k_1} + R_c + \\frac{\\Delta x_2/2}{k_2}} $$\n\n为所有 $N$ 个节点组合这些方程，会得到一个对称、正定的三对角矩阵 $\\mathbf{A}$，可以高效地求解该矩阵以找到数值温度向量 $\\mathbf{T}_{\\text{numerical}}$。为此，我们使用专门的带状矩阵求解器。\n\n**2. 解析解**\n\n问题提供了用于验证的精确解析解。首先，通过将总温降除以总热阻来计算通过平板的恒定热通量 $q$：\n$$ q = \\frac{T_0 - T_L}{R_{\\text{total}}} = \\frac{T_0 - T_L}{\\left(\\frac{L_1}{k_1} + R_c + \\frac{L_2}{k_2}\\right)} $$\n温度分布 $T(x)$ 是分段线性的。对于每个节点位置 $x_i$，解析温度计算如下：\n- 对于层1中的节点（$0 \\le x_i \\le L_1$）：\n  $$ T(x_i) = T_0 - \\frac{q}{k_1}x_i $$\n- 对于层2中的节点（$L_1  x_i \\le L_1+L_2$）：\n  $$ T(x_i) = T_L + \\frac{q}{k_2}(L_1+L_2 - x_i) $$\n单元中心网格的节点位置 $x_i$ 为：\n- 对于 $i=0, \\dots, N_1-1$：$x_i = (i + 1/2)\\Delta x_1$，其中 $\\Delta x_1 = L_1/N_1$。\n- 对于 $i=N_1, \\dots, N-1$（令 $j=i-N_1$）：$x_i = L_1 + (j + 1/2)\\Delta x_2$，其中 $\\Delta x_2 = L_2/N_2$。\n这样就得到了解析温度向量 $\\mathbf{T}_{\\text{analytical}}$。\n\n**3. 验证指标**\n\n通过计算数值解和解析解之间的最大绝对逐点误差来进行验证：\n$$ \\text{Error} = \\max_i |T_{\\text{numerical},i} - T_{\\text{analytical},i}| $$\n一个关键的见解是，所指定的基于中心差分近似的FDM方案，对于解是一次多项式（线性函数）的问题是精确的。由于每层中的温度分布是线性的，因此内部节点的离散化误差为零。使用热阻类比对边界和界面条件的特殊处理也保持了这种精确性。因此，计算出的误差预计仅由于浮点表示的限制而非零，即在机器精度的数量级上。最终结果按要求四舍五入到 $6$ 位小数。\n\n以下代码为每个提供的测试用例实现了这个完整的过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D steady conduction problem for a two-layer slab\n    with contact resistance using FDM and validates against the\n    analytical solution for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general case)\n        {'L1': 0.04, 'L2': 0.06, 'k1': 16.0, 'k2': 45.0, 'Rc': 5e-4, \n         'T0': 400.0, 'TL': 300.0, 'N1': 40, 'N2': 60},\n        # Test case 2 (large contact resistance)\n        {'L1': 0.02, 'L2': 0.02, 'k1': 200.0, 'k2': 200.0, 'Rc': 5e-2, \n         'T0': 350.0, 'TL': 300.0, 'N1': 20, 'N2': 20},\n        # Test case 3 (zero contact resistance)\n        {'L1': 0.03, 'L2': 0.07, 'k1': 5.0, 'k2': 150.0, 'Rc': 0.0, \n         'T0': 500.0, 'TL': 300.0, 'N1': 30, 'N2': 70},\n        # Test case 4 (high grid nonuniformity)\n        {'L1': 0.1, 'L2': 0.9, 'k1': 40.0, 'k2': 40.0, 'Rc': 1e-6, \n         'T0': 310.0, 'TL': 290.0, 'N1': 3, 'N2': 97},\n        # Test case 5 (very thin first layer)\n        {'L1': 1e-3, 'L2': 9.9e-2, 'k1': 10.0, 'k2': 10.0, 'Rc': 1e-3, \n         'T0': 1000.0, 'TL': 900.0, 'N1': 1, 'N2': 99},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = calculate_max_error(**case)\n        results.append(f\"{error:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_max_error(L1, L2, k1, k2, Rc, T0, TL, N1, N2):\n    \"\"\"\n    Calculates the maximum absolute error between the FDM and analytical solutions.\n    \"\"\"\n    N = N1 + N2\n    dx1 = L1 / N1 if N1 > 0 else 0.0\n    dx2 = L2 / N2 if N2 > 0 else 0.0\n    \n    # --- 1. FDM Numerical Solution ---\n    # Assemble the tridiagonal system A*T = b.\n    # The matrix A is stored in the `ab` banded format for scipy.linalg.solve_banded.\n    # ab has 3 rows: super-diagonal (shifted), main-diagonal, sub-diagonal (shifted).\n    ab = np.zeros((3, N))\n    b = np.zeros(N)\n\n    # Pre-calculate interface conductance if both layers exist\n    G_int = 0.0\n    if N1 > 0 and N2 > 0:\n        R_int_thermal = (dx1 / 2.0 / k1) + Rc + (dx2 / 2.0 / k2)\n        G_int = 1.0 / R_int_thermal\n\n    # Build matrix row by row\n    for i in range(N):\n        # Determine properties of the current control volume (CV)\n        is_in_layer1 = (i  N1)\n        k_node = k1 if is_in_layer1 else k2\n        dx_node = dx1 if is_in_layer1 else dx2\n\n        # Left face of CV i\n        if i == 0:  # Left boundary face\n            G_left = 2.0 * k_node / dx_node\n            b[i] -= G_left * T0\n        elif i == N1: # Interface face (from layer 2 side)\n            G_left = G_int\n            ab[2, i-1] = G_left\n        else: # Interior face\n            G_left = k_node / dx_node\n            ab[2, i-1] = G_left\n\n        # Right face of CV i\n        if i == N - 1: # Right boundary face\n            G_right = 2.0 * k_node / dx_node\n            b[i] -= G_right * TL\n        elif i == N1 - 1: # Interface face (from layer 1 side)\n            G_right = G_int\n            ab[0, i+1] = G_right\n        else: # Interior face\n            G_right = k_node / dx_node\n            ab[0, i+1] = G_right\n        \n        # Main diagonal term\n        ab[1, i] = -(G_left + G_right)\n\n    # Solve the linear system for nodal temperatures\n    T_numerical = solve_banded((1, 1), ab, b)\n\n    # --- 2. Analytical Solution ---\n    L_total = L1 + L2\n    R_total = (L1 / k1 if k1 > 0 else 0) + Rc + (L2 / k2 if k2 > 0 else 0)\n    q = (T0 - TL) / R_total if R_total > 0 else 0.0\n\n    # Calculate nodal positions\n    x_nodes = np.zeros(N)\n    if N1 > 0:\n        x_nodes[:N1] = (np.arange(N1) + 0.5) * dx1\n    if N2 > 0:\n        x_nodes[N1:] = L1 + (np.arange(N2) + 0.5) * dx2\n\n    # Calculate analytical temperatures at nodal positions\n    T_analytical = np.zeros(N)\n    mask_layer1 = x_nodes = L1\n    mask_layer2 = ~mask_layer1\n\n    T_analytical[mask_layer1] = T0 - (q / k1) * x_nodes[mask_layer1]\n    T_analytical[mask_layer2] = TL + (q / k2) * (L_total - x_nodes[mask_layer2])\n\n    # --- 3. Validation ---\n    max_abs_error = np.max(np.abs(T_numerical - T_analytical))\n    \n    return max_abs_error\n\nsolve()\n```"
        }
    ]
}