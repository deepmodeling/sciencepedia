{
    "hands_on_practices": [
        {
            "introduction": "验证是数值模拟的基石。本练习将指导您针对一个具有精确解析解的经典一维热传导问题，实施并验证您的 Crank-Nicolson 求解器 。通过将数值结果与精确解进行比较，您将能定量地检验代码的正确性，并进行收敛性研究以确认该格式的二阶精度。",
            "id": "3990207",
            "problem": "考虑一个均匀平板中的一维瞬态热传导，该过程由热方程控制。其基本原理是能量守恒和傅里叶热传导定律，两者共同导出了热方程 $ \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} $，适用于 $ x \\in (0, L) $ 和 $ t  0 $，其中 $ T(x,t) $ 是温度场，$ \\alpha $ 是热扩散系数，$ L $ 是平板的长度。该平板服从均匀狄利克雷边界条件 $ T(0,t) = 0 $ 和 $ T(L,t) = 0 $，适用于所有 $ t \\ge 0 $。初始温度场为 $ T(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right) + \\frac{1}{2}\\sin\\left(\\frac{3\\pi x}{L}\\right) $。\n\n通过分离变量法，狄利克雷平板问题的精确解可以写成傅里叶正弦级数形式 $ T(x,t) = \\sum_{m=1}^{\\infty} A_m \\exp\\left(-\\alpha \\lambda_m^2 t\\right)\\sin\\left(\\lambda_m x\\right) $，其中 $ \\lambda_m = \\frac{m\\pi}{L} $，系数 $ A_m $ 由初始条件确定。对于给定的初始条件，仅有的非零系数是 $ A_1 = 1 $ 和 $ A_3 = \\frac{1}{2} $，精确解简化为 $ T_{\\mathrm{exact}}(x,t) = \\exp\\left(-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t\\right)\\sin\\left(\\frac{\\pi x}{L}\\right) + \\frac{1}{2}\\exp\\left(-\\alpha \\left(\\frac{3\\pi}{L}\\right)^2 t\\right)\\sin\\left(\\frac{3\\pi x}{L}\\right) $。\n\n您的任务是为该问题在均匀空间网格和恒定时间步长上推导并实现 Crank–Nicolson (CN) 格式，并使用精确解计算数值误差，将其表示为空间步长 $ \\Delta x $ 和时间步长 $ \\Delta t $ 的函数。具体要求如下：\n\n- 在均匀狄利克雷边界条件下，为区域 $ x \\in (0, L) $ 内的内部节点推导 CN 时间步进格式。在空间上使用标准的二阶中心差分，并对扩散项使用梯形时间积分。不要使用任何简便公式；从热方程出发，通过应用适当的有限差分近似和时间平均来构建离散方程。\n- 在一个程序中实现 CN 格式，该程序使用包含 $ N_x $ 个节点（包括边界）的均匀网格和恒定的时间步长 $ \\Delta t $，将解从 $ t = 0 $ 推进到 $ t = t_{\\mathrm{end}} $。假设 $ t_{\\mathrm{end}} $ 可以被 $ \\Delta t $ 整除。\n- 计算在 $ t = t_{\\mathrm{end}} $ 时，数值解与在相同网格节点上求值的精确解 $ T_{\\mathrm{exact}}(x,t_{\\mathrm{end}}) $ 之间的离散均方根误差，定义为 $ E = \\sqrt{\\frac{1}{N_x}\\sum_{i=0}^{N_x-1}\\left(T_i^{n_{\\mathrm{end}}} - T_{\\mathrm{exact}}(x_i, t_{\\mathrm{end}})\\right)^2} $。以开尔文（$ \\mathrm{K} $）为单位报告误差 $ E $。使用 $ x_i = i \\Delta x $，其中 $ \\Delta x = \\frac{L}{N_x - 1} $，$ n_{\\mathrm{end}} $ 是最终的时间索引。\n\n物理单位：\n- 空间量以米（$ \\mathrm{m} $）为单位报告，时间以秒（$ \\mathrm{s} $）为单位报告。\n- 热扩散系数 $ \\alpha $ 的单位必须是 $ \\mathrm{m}^2/\\mathrm{s} $。\n- 误差必须以开尔文（$ \\mathrm{K} $）为单位报告。\n\n实现程序以运行以下测试套件，探究不同 $ \\Delta x $ 和 $ \\Delta t $ 下的误差行为：\n\n- 测试 $ 1 $ (基准): $ L = 1.0 \\ \\mathrm{m} $, $ \\alpha = 1.0 \\times 10^{-4} \\ \\mathrm{m}^2/\\mathrm{s} $, $ t_{\\mathrm{end}} = 10.0 \\ \\mathrm{s} $, $ N_x = 51 $, $ \\Delta t = 0.10 \\ \\mathrm{s} $。\n- 测试 $ 2 $ (细化时间步长): $ L = 1.0 \\ \\mathrm{m} $, $ \\alpha = 1.0 \\times 10^{-4} \\ \\mathrm{m}^2/\\mathrm{s} $, $ t_{\\mathrm{end}} = 10.0 \\ \\mathrm{s} $, $ N_x = 51 $, $ \\Delta t = 0.025 \\ \\mathrm{s} $。\n- 测试 $ 3 $ (细化空间步长): $ L = 1.0 \\ \\mathrm{m} $, $ \\alpha = 1.0 \\times 10^{-4} \\ \\mathrm{m}^2/\\mathrm{s} $, $ t_{\\mathrm{end}} = 10.0 \\ \\mathrm{s} $, $ N_x = 201 $, $ \\Delta t = 0.10 \\ \\mathrm{s} $。\n- 测试 $ 4 $ (两者皆粗): $ L = 1.0 \\ \\mathrm{m} $, $ \\alpha = 1.0 \\times 10^{-4} \\ \\mathrm{m}^2/\\mathrm{s} $, $ t_{\\mathrm{end}} = 10.0 \\ \\mathrm{s} $, $ N_x = 21 $, $ \\Delta t = 1.25 \\ \\mathrm{s} $。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$ [E_1,E_2,E_3,E_4] $），其中每个 $ E_k $ 是测试 $ k $ 在 $ t = t_{\\mathrm{end}} $ 时在相应网格上计算出的均方根误差（单位为 $ \\mathrm{K} $）。",
            "solution": "根据指定标准，用户提供的问题被评估为有效。它在科学上基于传热学和数值分析的原理，信息充分且一致，问题设定良好，并且其表述是客观的。任务是为一维瞬态热传导问题推导并实现 Crank–Nicolson 格式，并根据提供的精确解计算数值误差。\n\n### Crank–Nicolson 格式的推导\n\n一维瞬态热传导的控制偏微分方程 (PDE) 是热方程：\n$$ \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} $$\n其中 $T(x,t)$ 是温度，$\\alpha$ 是热扩散系数，$x$ 是空间坐标，$t$ 是时间。定义域为 $x \\in (0, L)$ 和 $t  0$。\n\n该问题在均匀网格上进行离散化。设空间域被划分为 $N_x-1$ 个宽度为 $\\Delta x = \\frac{L}{N_x - 1}$ 的区间，网格点为 $x_i = i \\Delta x$，其中 $i = 0, 1, \\dots, N_x-1$。时间以步长 $\\Delta t$ 离散化，即 $t_n = n \\Delta t$。网格点 $i$ 在时间步 $n$ 的温度记为 $T_i^n \\approx T(x_i, t_n)$。\n\nCrank–Nicolson 方法使用中心在 $t_{n+1/2}$ 处的前向差分来近似时间导数，并通过对当前时间步 ($n$) 和下一时间步 ($n+1$) 的空间导数项的值进行平均来近似该项。这等效于对空间项的时间积分应用梯形法则。\n\n时间导数近似为：\n$$ \\frac{\\partial T}{\\partial t} \\bigg|_{i}^{n+1/2} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t} $$\n在时间中点 $t_{n+1/2}$ 处评估 PDE：\n$$ \\frac{\\partial T}{\\partial t} \\bigg|_{i}^{n+1/2} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{i}^{n+1/2} $$\nCrank-Nicolson 格式通过平均来近似右侧项：\n$$ \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{i}^{n+1/2} \\approx \\frac{1}{2} \\left( \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{i}^{n+1} + \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{i}^{n} \\right) $$\n将这些结合起来，得到半离散化方程：\n$$ \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left[ \\left(\\frac{\\partial^2 T}{\\partial x^2}\\right)_i^{n+1} + \\left(\\frac{\\partial^2 T}{\\partial x^2}\\right)_i^n \\right] $$\n接下来，使用标准的二阶中心差分格式来近似二阶空间导数：\n$$ \\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{i} \\approx \\frac{T_{i-1} - 2T_i + T_{i+1}}{(\\Delta x)^2} $$\n将此空间离散化代入时间步进方程，得到完全离散形式：\n$$ \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left( \\frac{T_{i-1}^{n+1} - 2T_i^{n+1} + T_{i+1}^{n+1}}{(\\Delta x)^2} + \\frac{T_{i-1}^{n} - 2T_i^{n} + T_{i+1}^{n}}{(\\Delta x)^2} \\right) $$\n为简化此表达式，我们引入无量纲扩散数（或网格傅里叶数）$r$：\n$$ r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2} $$\n整个方程乘以 $\\Delta t$ 并代入 $r$：\n$$ T_i^{n+1} - T_i^n = \\frac{r}{2} \\left( (T_{i-1}^{n+1} - 2T_i^{n+1} + T_{i+1}^{n+1}) + (T_{i-1}^{n} - 2T_i^{n} + T_{i+1}^{n}) \\right) $$\n下一步是重新整理方程，将新时间步 $n+1$ 的所有项（未知数）放在左侧 (LHS)，将当前时间步 $n$ 的所有项（已知数）放在右侧 (RHS)：\n$$ T_i^{n+1} - \\frac{r}{2}(T_{i-1}^{n+1} - 2T_i^{n+1} + T_{i+1}^{n+1}) = T_i^n + \\frac{r}{2}(T_{i-1}^{n} - 2T_i^{n} + T_{i+1}^{n}) $$\n简化两边，得到内部节点 $i$ 的有限差分方程的最终形式：\n$$ -\\frac{r}{2}T_{i-1}^{n+1} + (1+r)T_i^{n+1} - \\frac{r}{2}T_{i+1}^{n+1} = \\frac{r}{2}T_{i-1}^{n} + (1-r)T_i^{n} + \\frac{r}{2}T_{i+1}^{n} $$\n该方程对定义域内的内部节点有效，即 $i = 1, 2, \\dots, N_x-2$。\n\n问题指定了均匀狄利克雷边界条件：$T(0,t) = 0$ 和 $T(L,t) = 0$。在我们的离散框架中，这转化为对于所有时间步 $n$，$T_0^n = 0$ 和 $T_{N_x-1}^n = 0$。\n\n这个关于内部节点未知温度 $\\{T_i^{n+1}\\}_{i=1}^{N_x-2}$ 的线性方程组可以写成矩阵形式：\n$$ \\mathbf{A} \\mathbf{T}_{\\mathrm{int}}^{n+1} = \\mathbf{B} \\mathbf{T}_{\\mathrm{int}}^{n} $$\n其中 $\\mathbf{T}_{\\mathrm{int}}^n = [T_1^n, T_2^n, \\dots, T_{N_x-2}^n]^T$ 是内部温度向量。矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$ 是三对角的，维度为 $(N_x-2) \\times (N_x-2)$。\n\n左侧矩阵 $\\mathbf{A}$ 为：\n$$ \\mathbf{A} = \\begin{pmatrix}\n1+r  -r/2  0  \\dots \\\\\n-r/2  1+r  -r/2  \\dots \\\\\n0  \\ddots  \\ddots  \\ddots \\\\\n\\dots  -r/2  1+r  -r/2 \\\\\n\\dots  0  -r/2  1+r\n\\end{pmatrix} $$\n右侧矩阵 $\\mathbf{B}$ 为：\n$$ \\mathbf{B} = \\begin{pmatrix}\n1-r  r/2  0  \\dots \\\\\nr/2  1-r  r/2  \\dots \\\\\n0  \\ddots  \\ddots  \\ddots \\\\\n\\dots  r/2  1-r  r/2 \\\\\n\\dots  0  r/2  1-r\n\\end{pmatrix} $$\n注意，通用格式方程中涉及 $T_0$ 和 $T_{N_x-1}$ 的项由于边界条件为零而被吸收。例如，对于第一个内部节点 ($i=1$)，方程是 $(1+r)T_1^{n+1} - \\frac{r}{2}T_2^{n+1} = (1-r)T_1^n + \\frac{r}{2}T_2^n$。\n\n为了将解从时间 $t_n$ 推进到 $t_{n+1}$，我们执行以下步骤：\n1.  构造已知的右侧向量 $\\mathbf{b} = \\mathbf{B} \\mathbf{T}_{\\mathrm{int}}^{n}$。\n2.  求解线性系统 $\\mathbf{A} \\mathbf{T}_{\\mathrm{int}}^{n+1} = \\mathbf{b}$ 以得到未知向量 $\\mathbf{T}_{\\mathrm{int}}^{n+1}$。\n由于 $\\mathbf{A}$ 是一个对称、正定、三对角矩阵，这个系统可以使用例如 Thomas 算法或带状矩阵求解器非常高效地求解。\n\n初始条件 $T(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right) + \\frac{1}{2}\\sin\\left(\\frac{3\\pi x}{L}\\right)$ 用于设置 $n=0$ 时的温度向量 $\\mathbf{T}^0$。然后，数值解在时间上向前推进，直到 $t = t_{\\mathrm{end}}$。\n\n最后，在 $t=t_{\\mathrm{end}}$ 时，通过比较所有网格节点 $i = 0, \\dots, N_x-1$ 上的数值解 $T_i^{n_{\\mathrm{end}}}$ 和精确解 $T_{\\mathrm{exact}}(x_i, t_{\\mathrm{end}})$ 来计算离散均方根误差 $E$：\n$$ E = \\sqrt{\\frac{1}{N_x}\\sum_{i=0}^{N_x-1}\\left(T_i^{n_{\\mathrm{end}}} - T_{\\mathrm{exact}}(x_i, t_{\\mathrm{end}})\\right)^2} $$\n为此比较使用了指定的精确解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef exact_solution(x, t, L, alpha):\n    \"\"\"\n    Computes the exact analytical solution to the heat equation problem.\n    \"\"\"\n    term1 = np.exp(-alpha * (np.pi / L)**2 * t) * np.sin(np.pi * x / L)\n    term2 = 0.5 * np.exp(-alpha * (3 * np.pi / L)**2 * t) * np.sin(3 * np.pi * x / L)\n    return term1 + term2\n\ndef run_simulation(L, alpha, t_end, Nx, dt):\n    \"\"\"\n    Runs one simulation of the Crank-Nicolson scheme for the 1D heat equation.\n\n    Args:\n        L (float): Length of the slab in meters.\n        alpha (float): Thermal diffusivity in m^2/s.\n        t_end (float): Final simulation time in seconds.\n        Nx (int): Number of spatial grid points.\n        dt (float): Time step in seconds.\n\n    Returns:\n        float: The root-mean-square error at t_end.\n    \"\"\"\n    # 1. Setup spatial and temporal grid\n    dx = L / (Nx - 1)\n    x = np.linspace(0, L, Nx)\n    \n    # Ensure t_end is a multiple of dt\n    num_t_steps = int(round(t_end / dt))\n\n    # 2. Define the non-dimensional diffusion number\n    r = alpha * dt / dx**2\n\n    # 3. Set the initial condition T(x, 0)\n    T = exact_solution(x, 0, L, alpha)\n\n    # 4. Set up the tridiagonal system A * T_new = b for interior nodes\n    N_int = Nx - 2  # Number of interior nodes\n    \n    # The LHS matrix A is constant, so it can be constructed once.\n    # We use the banded format required by scipy.linalg.solve_banded.\n    # The matrix has 1 lower diagonal, 1 main diagonal, 1 upper diagonal.\n    # The format is a (3, N_int) array.\n    A_banded = np.zeros((3, N_int))\n    A_banded[0, 1:] = -r / 2.0      # Super-diagonal (u)\n    A_banded[1, :] = 1.0 + r         # Main diagonal (d)\n    A_banded[2, :-1] = -r / 2.0      # Sub-diagonal (l)\n\n    # 5. Perform the time-marching loop\n    T_int = T[1:-1].copy() # Get interior nodes for the first step\n\n    for _ in range(num_t_steps):\n        # Construct the RHS vector b = B * T_int\n        # This is done explicitly to avoid forming the matrix B\n        b = np.zeros(N_int)\n        \n        # General case for nodes not adjacent to boundaries\n        if N_int > 2:\n            b[1:-1] = (r / 2.0) * T_int[:-2] + (1.0 - r) * T_int[1:-1] + (r / 2.0) * T_int[2:]\n        \n        # First interior node (i=1), where T_0^n = 0\n        if N_int > 0:\n            b[0] = (1.0 - r) * T_int[0] + (r / 2.0) * T_int[1] if N_int > 1 else (1.0 - r) * T_int[0]\n        \n        # Last interior node (i=Nx-2), where T_{Nx-1}^n = 0\n        if N_int > 1:\n            b[-1] = (r / 2.0) * T_int[-2] + (1.0 - r) * T_int[-1]\n\n        # Solve the linear system A * T_int_new = b for T_int_new\n        T_int = solve_banded((1, 1), A_banded, b)\n\n    # 6. Reconstruct the full solution vector at t_end\n    T_numerical = np.zeros(Nx)\n    T_numerical[1:-1] = T_int\n    # Boundary nodes T_numerical[0] and T_numerical[-1] remain 0.\n\n    # 7. Calculate the exact solution at t_end\n    T_exact_final = exact_solution(x, t_end, L, alpha)\n\n    # 8. Compute the Root-Mean-Square (RMS) error\n    # The sum is over all Nx points, including boundaries.\n    error = np.sqrt(np.mean((T_numerical - T_exact_final)**2))\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, alpha, t_end, Nx, dt)\n        (1.0, 1.0e-4, 10.0, 51, 0.10),    # Test 1\n        (1.0, 1.0e-4, 10.0, 51, 0.025),   # Test 2\n        (1.0, 1.0e-4, 10.0, 201, 0.10),   # Test 3\n        (1.0, 1.0e-4, 10.0, 21, 1.25),    # Test 4\n    ]\n\n    results = []\n    for case in test_cases:\n        L, alpha, t_end, Nx, dt = case\n        # Calculate the error for the current test case.\n        error = run_simulation(L, alpha, t_end, Nx, dt)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在验证了求解器的基本正确性后，下一步是深入分析其数值特性。本练习通过一个数值实验来测量 Crank-Nicolson 格式的逐模态放大因子，从而将抽象的冯·诺依曼稳定性分析与具体的计算结果联系起来 。理解放大因子有助于我们预测该格式在处理包含不同尺度波动的复杂问题时的稳定性和数值耗散行为。",
            "id": "3990185",
            "problem": "考虑由能量守恒定律与傅里叶热传导定律耦合所支配的一维瞬态热传导。在具有恒定热扩散系数 $\\alpha$ 的均匀介质中，周期性域上的温度场 $u(x,t)$ 遵循抛物型偏微分方程 $\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}$ 进行演化。在一个长度为 $L$ 的域上，考虑一个包含 $N$ 个点的均匀网格，其空间步长为 $h = L/N$，时间步长为 $\\Delta t$。将 Crank–Nicolson (CN) 方法应用于标准的二阶中心差分空间离散化，并采用周期性边界条件。从时间层 $n$ 到 $n+1$ 的更新过程可以表示为一个左端项为循环矩阵的线性系统。离散傅里叶模 $e^{\\mathrm{i} q j}$（其中 $j$ 是网格索引，$q$ 是离散波数，单位为弧度/索引）是周期性边界条件下离散拉普拉斯算子的特征函数。\n\n您的任务是：\n- 从能量守恒和傅里叶定律出发，推导出一维热方程 $\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}$。\n- 构建作用于网格函数 $u_j$ 的均匀网格二阶中心差分离散拉普拉斯算子 $L$，其形式为 $L u_j = u_{j+1} - 2 u_j + u_{j-1}$，并采用周期性环绕索引。\n- 针对此半离散系统，推导 Crank–Nicolson (CN) 半隐式时间离散化方法，将更新写成 $(I - \\frac{\\alpha \\Delta t}{2 h^2} L) u^{n+1} = (I + \\frac{\\alpha \\Delta t}{2 h^2} L) u^n$ 的形式，其中 $I$ 是单位算子，$u^n$ 是时间层 $n$ 的网格值向量。\n- 对于单个离散傅里叶模 $u_j^n = \\hat{u}^n e^{\\mathrm{i} q j}$，使用 $L$ 的特征值，根据无量纲比率 $r = \\alpha \\Delta t / h^2$ 以及从离散拉普拉斯算子特征值中确定的与模态相关的量，得出一个 CN 时间步长的解析放大因子 $G(q)$。不要提供中间的简化公式；从第一性原理出发推导该放大因子。\n\n设计一个数值实验，通过以下步骤测量逐模放大情况：\n- 将 $u^0$ 初始化为单位振幅的单个复傅里叶模 $u_j^0 = e^{\\mathrm{i} q j}$，其中 $m$ 为指定的整数模态指数，$q = 2 \\pi m / N$。\n- 组装循环左端矩阵 $(I - \\frac{r}{2} L)$ 和右端向量 $(I + \\frac{r}{2} L) u^0$，并使用精确线性代数求解 $u^1$。\n- 通过离散傅里叶变换 (Discrete Fourier Transform (DFT)) 计算所选模态的测量放大比 $R_{\\mathrm{meas}} = \\hat{u}^1 / \\hat{u}^0$。\n\n对于以下每个测试用例，计算绝对误差 $E = |R_{\\mathrm{meas}} - G(q)|$（一个无量纲浮点数）：\n- 用例 1：$N = 64$, $L = 2 \\pi$, $\\alpha = 1.0$, $\\Delta t = 10^{-4}$, $m = 0$。\n- 用例 2：$N = 64$, $L = 2 \\pi$, $\\alpha = 1.0$, $\\Delta t = 10^{-2}$, $m = 16$。\n- 用例 3：$N = 64$, $L = 2 \\pi$, $\\alpha = 1.0$, $\\Delta t = 1$, $m = 32$。\n- 用例 4：$N = 33$, $L = 2 \\pi$, $\\alpha = 0.5$, $\\Delta t = 0.2$, $m = 11$。\n- 用例 5：$N = 128$, $L = 2 \\pi$, $\\alpha = 1.0$, $\\Delta t = 0.05$, $m = 5$。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表（例如，$[result1,result2,result3]$），列表中的每个条目是按上述顺序列出的对应测试用例的绝对误差 $E$。所有数值答案必须是无量纲浮点数，且无需物理单位。该数值实验必须验证解析推导出的放大因子，方法是证明测量得到的放大比在数值精度范围内与解析预测相匹配，并覆盖低频、中频和最高频的离散模态，以及大小不同的 $r$ 值，以探究 Crank–Nicolson 方法的稳定性和阻尼特性。",
            "solution": "该问题被验证为具有科学依据、适定且完整。我们开始求解，其中涉及若干理论推导，随后通过数值实现来验证理论结果。\n\n**一维热方程的推导**\n\n我们从能量守恒原理开始。对于一维介质，考虑从位置 $x_1$ 到 $x_2$ 的任意一段。该段内的总热能 $E_{\\text{total}}$ 是体能量密度 $e(x,t)$ 在该体积上的积分。假设横截面积 $A$ 均匀，则有 $E_{\\text{total}} = \\int_{x_1}^{x_2} e(x,t) A \\, dx$。该能量的变化率必须等于热量流入该段的净速率。设 $\\phi(x,t)$ 为热通量（单位面积单位时间内的能量）。流入该段的热流速率为 $A \\phi(x_1, t) - A \\phi(x_2, t)$。因此，能量守恒的积分形式为：\n$$\n\\frac{d}{dt} \\int_{x_1}^{x_2} e(x,t) A \\, dx = A \\phi(x_1, t) - A \\phi(x_2, t)\n$$\n两边同除以 $A$ 并对右侧使用微积分基本定理，我们得到：\n$$\n\\frac{d}{dt} \\int_{x_1}^{x_2} e(x,t) \\, dx = - \\int_{x_1}^{x_2} \\frac{\\partial \\phi}{\\partial x} \\, dx\n$$\n将左侧的时间导数移入积分内（根据莱布尼茨积分法则），得到：\n$$\n\\int_{x_1}^{x_2} \\frac{\\partial e}{\\partial t} \\, dx = - \\int_{x_1}^{x_2} \\frac{\\partial \\phi}{\\partial x} \\, dx\n$$\n由于该等式必须对任意区间 $[x_1, x_2]$ 成立，因此被积函数必须相等。这给出了能量守恒的微分形式：\n$$\n\\frac{\\partial e}{\\partial t} = - \\frac{\\partial \\phi}{\\partial x}\n$$\n热能量密度 $e$ 通过 $e(x,t) = \\rho c_p u(x,t)$ 与温度 $u(x,t)$ 相关，其中 $\\rho$ 是质量密度，$c_p$ 是比热容，两者均假定为常数。傅里叶热传导定律指出，热通量与负温度梯度成正比：$\\phi(x,t) = -k \\frac{\\partial u}{\\partial x}$，其中 $k$ 是热导率，也假定为常数。\n\n将这两个本构关系代入能量守恒方程：\n$$\n\\frac{\\partial}{\\partial t} (\\rho c_p u) = - \\frac{\\partial}{\\partial x} \\left(-k \\frac{\\partial u}{\\partial x}\\right)\n$$\n$$\n\\rho c_p \\frac{\\partial u}{\\partial t} = k \\frac{\\partial^2 u}{\\partial x^2}\n$$\n整理各项，我们得到一维热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{k}{\\rho c_p} \\frac{\\partial^2 u}{\\partial x^2}\n$$\n我们将热扩散系数定义为 $\\alpha = k / (\\rho c_p)$，它将材料属性合并为一个单一常数。最终的控制方程是：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\n\n**空间算子的离散化**\n\n热方程在包含 $N$ 个点 $x_j = j h$（$j = 0, 1, \\dots, N-1$）的均匀网格上进行离散化，其中 $h=L/N$ 是空间步长。网格点 $j$ 在时间 $t$ 的温度记为 $u_j(t)$。二阶空间导数 $\\partial^2 u/\\partial x^2$ 在网格点 $x_j$ 处使用二阶中心差分格式进行近似。这由 $u(x)$ 在 $x_j$ 附近的泰勒级数展开推导得出：\n$$\nu(x_j+h) = u(x_j) + h \\frac{\\partial u}{\\partial x}\\bigg|_{x_j} + \\frac{h^2}{2} \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j} + \\frac{h^3}{6} \\frac{\\partial^3 u}{\\partial x^3}\\bigg|_{x_j} + O(h^4)\n$$\n$$\nu(x_j-h) = u(x_j) - h \\frac{\\partial u}{\\partial x}\\bigg|_{x_j} + \\frac{h^2}{2} \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j} - \\frac{h^3}{6} \\frac{\\partial^3 u}{\\partial x^3}\\bigg|_{x_j} + O(h^4)\n$$\n将这两个展开式相加可以消去奇数阶导数项：\n$$\nu(x_j+h) + u(x_j-h) = 2 u(x_j) + h^2 \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j} + O(h^4)\n$$\n求解二阶导数，我们得到近似式：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j} \\approx \\frac{u(x_j+h) - 2u(x_j) + u(x_j-h)}{h^2} = \\frac{u_{j+1} - 2u_j + u_{j-1}}{h^2}\n$$\n问题陈述中定义了一个作用于网格函数 $u_j$ 的离散算子 $L$，其形式为 $L u_j = u_{j+1} - 2u_j + u_{j-1}$。这是离散拉普拉斯算子的一个未缩放的表示。周期性边界条件意味着索引按模 $N$ 进行计算，因此 $u_{N} = u_0$ 且 $u_{-1} = u_{N-1}$。因此，热方程的半离散形式为：\n$$\n\\frac{d u_j}{d t} = \\frac{\\alpha}{h^2} (L u)_j\n$$\n\n**Crank–Nicolson 格式的推导**\n\nCrank-Nicolson 方法是一种在时间上二阶精确的隐式时间步进格式。它通过在时间层 $n+1/2$ 附近使用中心差分公式离散化时间导数而推导得出：\n$$\n\\frac{u^{n+1}_j - u^{n}_j}{\\Delta t} \\approx \\frac{d u_j}{d t}\\bigg|_{t_{n+1/2}}\n$$\n其中 $u^n_j$ 是网格点 $j$ 在时间步 $n$ 的温度。半离散方程右侧的空间导数项也通过对时间层 $n$ 和 $n+1$ 的值取平均，在时间层 $n+1/2$ 处进行近似：\n$$\n\\frac{\\alpha}{h^2} (L u)_j \\bigg|_{t_{n+1/2}} \\approx \\frac{1}{2} \\left[ \\left(\\frac{\\alpha}{h^2} L u\\right)^{n}_j + \\left(\\frac{\\alpha}{h^2} L u\\right)^{n+1}_j \\right]\n$$\n令这两个近似式相等，得到全离散格式：\n$$\n\\frac{u^{n+1}_j - u^{n}_j}{\\Delta t} = \\frac{\\alpha}{2h^2} \\left[ (L u^n)_j + (L u^{n+1})_j \\right]\n$$\n乘以 $\\Delta t$ 并整理各项，将时间 $n$ 的已知值与时间 $n+1$ 的未知值分离开：\n$$\nu^{n+1}_j - \\frac{\\alpha \\Delta t}{2h^2} (L u^{n+1})_j = u^{n}_j + \\frac{\\alpha \\Delta t}{2h^2} (L u^n)_j\n$$\n我们定义无量纲参数 $r = \\alpha \\Delta t / h^2$。针对整个网格值向量 $u^n$ 的格式可以写成算子形式：\n$$\nu^{n+1} - \\frac{r}{2} L u^{n+1} = u^{n} + \\frac{r}{2} L u^{n}\n$$\n提出公因子 $u^{n+1}$ 和 $u^n$ 并使用单位算子 $I$：\n$$\n\\left(I - \\frac{r}{2}L\\right) u^{n+1} = \\left(I + \\frac{r}{2}L\\right) u^{n}\n$$\n这就是 Crank-Nicolson 更新规则的最终形式，它需要在每个时间步求解一个线性系统。\n\n**解析放大因子的推导**\n\n为分析该格式的稳定性和准确性，我们进行 von Neumann 稳定性分析。我们研究单个离散傅里叶模 $u_j^n = \\hat{u}^n e^{\\mathrm{i}qj}$ 在一个时间步内是如何被放大的。这里，$\\hat{u}^n$ 是时间步 $n$ 时模的复振幅，$j$ 是网格索引，$q$ 是离散波数。\n\n首先，我们求出离散拉普拉斯算子 $L$ 作用于此傅里叶模时的特征值：\n$$\n(L u^n)_j = u_{j+1}^n - 2u_j^n + u_{j-1}^n = \\hat{u}^n e^{\\mathrm{i}q(j+1)} - 2\\hat{u}^n e^{\\mathrm{i}qj} + \\hat{u}^n e^{\\mathrm{i}q(j-1)}\n$$\n提出公因子 $\\hat{u}^n e^{\\mathrm{i}qj}$：\n$$\n(L u^n)_j = \\hat{u}^n e^{\\mathrm{i}qj} (e^{\\mathrm{i}q} - 2 + e^{-\\mathrm{i}q})\n$$\n使用欧拉公式 $e^{\\mathrm{i}q} + e^{-\\mathrm{i}q} = 2\\cos(q)$。因此，括号中的表达式变为 $2\\cos(q) - 2$。所以，$L$ 对傅里叶模的作用相当于标量乘法：\n$$\n(L u^n)_j = (2\\cos(q) - 2) u_j^n\n$$\n对于波数为 $q$ 的模，算子 $L$ 的特征值为 $\\lambda_L(q) = 2(\\cos(q) - 1)$。\n\n现在，我们将傅里叶模拟设代入 Crank-Nicolson 格式中：\n$$\n\\left(I - \\frac{r}{2}L\\right) u^{n+1} = \\left(I + \\frac{r}{2}L\\right) u^{n}\n$$\n由于傅里叶模是 $L$ 的特征函数，它们也是任何 $L$ 的算子多项式（例如 $(I - \\frac{r}{2}L)$ 和 $(I + \\frac{r}{2}L)$）的特征函数。将这些算子应用于该模态，得到：\n$$\n\\left(1 - \\frac{r}{2}\\lambda_L(q)\\right) u^{n+1}_j = \\left(1 + \\frac{r}{2}\\lambda_L(q)\\right) u^{n}_j\n$$\n代入 $u_j^n = \\hat{u}^n e^{\\mathrm{i}qj}$ 和 $u_j^{n+1} = \\hat{u}^{n+1} e^{\\mathrm{i}qj}$：\n$$\n\\left(1 - \\frac{r}{2}\\lambda_L(q)\\right) \\hat{u}^{n+1} e^{\\mathrm{i}qj} = \\left(1 + \\frac{r}{2}\\lambda_L(q)\\right) \\hat{u}^{n} e^{\\mathrm{i}qj}\n$$\n放大因子定义为 $G(q) = \\hat{u}^{n+1} / \\hat{u}^{n}$。两边相除，我们得到：\n$$\nG(q) = \\frac{1 + \\frac{r}{2}\\lambda_L(q)}{1 - \\frac{r}{2}\\lambda_L(q)}\n$$\n代入与模态相关的特征值表达式 $\\lambda_L(q) = 2(\\cos(q) - 1)$：\n$$\nG(q) = \\frac{1 + \\frac{r}{2}(2(\\cos(q) - 1))}{1 - \\frac{r}{2}(2(\\cos(q) - 1))} = \\frac{1 + r(\\cos(q) - 1)}{1 - r(\\cos(q) - 1)}\n$$\n\n**数值实验设计**\n数值实验用于验证这一解析结果。对于每个测试用例，我们执行以下步骤：\n$1$. 我们将网格函数 $u^0$ 初始化为单位振幅的单个复傅里叶模 $u_j^0 = e^{\\mathrm{i} q j}$，其中对于给定的整数模态指数 $m$，$q = 2\\pi m / N$。\n$2$. 我们构建 Crank-Nicolson 算子的矩阵表示。算子 $L$ 是一个循环矩阵。线性系统 $A u^1 = b$ 的矩阵为 $A = I - \\frac{r}{2} L$，向量为 $b = (I + \\frac{r}{2} L) u^0$。\n$3$. 我们使用标准线性求解器求解线性系统 $A u^1 = b$，以得到下一时间步的状态向量 $u^1$。\n$4$. 我们计算测量得到的放大比 $R_{\\mathrm{meas}}$。由于初始状态是纯傅里叶模，经过一个线性时间步之后的状态 $u^1$，除了数值浮点误差外，应为同一模态乘以放大因子。信号 $v$ 中模态 $m$ 的振幅可以通过离散傅里叶变换 (DFT) 提取，即 $\\hat{v}[m] = \\text{DFT}(v)[m] / N$。放大比是振幅之比：$R_{\\mathrm{meas}} = \\hat{u}^1[m] / \\hat{u}^0[m]$。由于 $\\hat{u}^0[m] = 1$，这可以简化为 $R_{\\mathrm{meas}} = \\text{DFT}(u^1)[m] / N$。\n$5$. 最后，我们计算测量得到的放大因子与解析放大因子之间的绝对误差：$E = |R_{\\mathrm{meas}} - G(q)|$。此误差应接近机器精度，从而证实解析推导和数值实现的正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import circulant\n\ndef solve():\n    \"\"\"\n    Solves the problem by running a numerical experiment for each test case\n    to validate the analytical amplification factor of the Crank-Nicolson scheme.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, alpha, dt, m)\n        (64, 2 * np.pi, 1.0, 1e-4, 0),\n        (64, 2 * np.pi, 1.0, 1e-2, 16),\n        (64, 2 * np.pi, 1.0, 1.0, 32),\n        (33, 2 * np.pi, 0.5, 0.2, 11),\n        (128, 2 * np.pi, 1.0, 0.05, 5),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, alpha, dt, m = case\n\n        # Calculate derived parameters\n        h = L / N\n        r = alpha * dt / (h * h)\n        q = 2 * np.pi * m / N\n\n        # --- Analytical Amplification Factor G(q) ---\n        # G(q) = (1 + r * (cos(q) - 1)) / (1 - r * (cos(q) - 1))\n        cos_q = np.cos(q)\n        g_analytical = (1 + r * (cos_q - 1)) / (1 - r * (cos_q - 1))\n\n        # --- Numerical Experiment ---\n        \n        # 1. Initialize to a single complex Fourier mode with unit amplitude\n        j_indices = np.arange(N)\n        u0 = np.exp(1j * q * j_indices)\n\n        # 2. Assemble the circulant matrices for the CN scheme\n        # The discrete Laplacian L is a circulant matrix. We construct its first row.\n        # L u_j = u_{j+1} - 2*u_j + u_{j-1}\n        # First row of L matrix is [-2, 1, 0, ..., 0, 1]\n        l_first_row = np.zeros(N)\n        l_first_row[0] = -2.0\n        l_first_row[1] = 1.0\n        l_first_row[N - 1] = 1.0  # Periodic boundary condition\n        \n        L_matrix = circulant(l_first_row)\n        \n        # Identity matrix\n        I_matrix = np.identity(N)\n\n        # LHS matrix A = I - (r/2) * L\n        A_matrix = I_matrix - (r / 2.0) * L_matrix\n        \n        # RHS operator matrix B_op = I + (r/2) * L\n        B_op_matrix = I_matrix + (r / 2.0) * L_matrix\n\n        # Calculate RHS vector b = B_op * u^0\n        b_vector = B_op_matrix @ u0\n\n        # 3. Solve the linear system A * u^1 = b for u^1\n        u1 = np.linalg.solve(A_matrix, b_vector)\n\n        # 4. Compute the measured amplification ratio R_meas via DFT\n        # The amplitude of mode m in u1 is DFT(u1)[m] / N.\n        # Initial amplitude is 1. So, R_meas = (DFT(u1)[m] / N) / 1.\n        dft_u1 = np.fft.fft(u1)\n        r_measured = dft_u1[m] / N\n\n        # 5. Compute the absolute error E\n        error = np.abs(r_measured - g_analytical)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "实际工程问题通常涉及随时间变化的边界条件和内部热源，这为代码验证带来了挑战。本练习将介绍功能强大的“人造解方法”(Method of Manufactured Solutions, MMS)，它是在缺乏简单解析解时验证代码的通用技术 。您将学习如何将含时源项和边界条件正确地集成到 Crank-Nicolson 格式中，并确保其二阶时间精度不受影响。",
            "id": "3990262",
            "problem": "考虑一根长度为 $L$、具有恒定热扩散系数 $\\alpha$ 的均匀固态杆中的一维瞬态热传导。令 $x \\in [0,L]$ 且 $t \\ge 0$。根据能量守恒和傅里叶定律，控制方程可表示为包含体积源项的热方程：$$\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} + s(x,t)$$. 假设狄利克雷边界条件为 $T(0,t) = g_0(t)$ 和 $T(L,t) = g_L(t)$，初始条件为 $T(x,0) = T_0(x)$。温度 $T$ 以开尔文为单位，长度以米为单位，时间以秒为单位。角度（若有）必须以弧度为单位。\n\n为在克兰克-尼科尔森格式中测试随时间变化的边界条件和体积源项的时间中心实现，请使用制造解方法。定义精确解 $$u(x,t) = \\sin\\left(\\frac{\\pi x}{L}\\right)\\cos(\\omega t) + \\frac{x}{L} t e^{-\\beta t}$$. 根据控制方程和此 $u(x,t)$，确定相应的源项 $s(x,t)$、边界函数 $g_0(t)$ 和 $g_L(t)$ 以及初始条件 $T_0(x)$，使得 $u(x,t)$ 精确满足该问题。所有角度均以弧度为单位。\n\n从上述基本定律和定义出发，为内部节点推导一个克兰克-尼科尔森时间离散格式。该格式需通过在 $t^n$ 和 $t^{n+1}$ 处评估的时间中心贡献，正确地包含随时间变化的源项和边界条件。具体而言，该离散系统必须在内部使用空间二阶差分算子，并以与时间中心化一致的方式包含边界值的影响。不要使用预先推导的简化公式；相反，应通过对控制方程应用时间中点求积，并通过狄利克雷约束消除边界节点，从第一性原理推导离散格式。\n\n在一个完整的程序中实现你的推导，该程序：\n- 将空间域均匀离散为 $N_x$ 个区间，因此网格间距为 $\\Delta x = L/N_x$，内部未知数位于 $x_i = i\\Delta x$ 处，其中 $i=1,2,\\dots,N_x-1$。\n- 使用均匀的时间步长 $\\Delta t$，使得 $t_f/\\Delta t$ 为整数，并将解推进到最终时间 $t_f$。\n- 在 $t^n$ 和 $t^{n+1}$ 处评估体积源项 $s(x,t)$，并形成一个时间中心的贡献。\n- 在 $t^n$ 和 $t^{n+1}$ 处评估边界值 $g_0(t)$ 和 $g_L(t)$，并将其时间中心的影响整合到内部方程中。\n- 使用 $T_0(x)$进行初始化，并在每个时间步计算数值解 $T^{n}(x)$。\n\n对于下述每个测试用例，计算在最终时间 $t_f$ 的最大绝对误差，定义为 $$E_{\\infty} = \\max_{0 \\le i \\le N_x} \\left| T(x_i,t_f) - u(x_i,t_f) \\right|$$. 以浮点数形式报告每个 $E_{\\infty}$（单位：开尔文）。\n\n使用以下物理参数（所有测试共用）：\n- $L = 0.3$ $\\mathrm{m}$，\n- $\\alpha = 1.6 \\times 10^{-5}$ $\\mathrm{m}^2/\\mathrm{s}$，\n- $\\omega = 7.0$ $\\mathrm{rad}/\\mathrm{s}$，\n- $\\beta = 3.0$ $\\mathrm{s}^{-1}$，\n- $t_f = 0.2$ $\\mathrm{s}$。\n\n测试套件（每个用例指定 $(N_x,\\Delta t)$）：\n1. 正常路径： $(N_x,\\Delta t) = (50, 0.004)$。\n2. 粗分辨率边界情况： $(N_x,\\Delta t) = (12, 0.01)$。\n3. 高分辨率情况： $(N_x,\\Delta t) = (150, 0.001)$。\n\n您的程序应生成单行输出，其中包含三个结果，格式为方括号内由逗号分隔的列表（例如 $[E_1,E_2,E_3]$），其中 $E_1$、$E_2$ 和 $E_3$ 分别对应于用例1、2和3。每个条目必须是 $E_{\\infty}$ 的浮点数值（单位：开尔文）。",
            "solution": "首先，通过确定与所提供的制造解一致的源项、边界条件和初始条件来验证问题。随后，从第一性原理推导克兰克-尼科尔森数值格式，并将其表述为矩阵系统。\n\n### 1. 通过制造解方法构建问题\n\n带源项的一维瞬态热方程由下式给出：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} + s(x,t)\n$$\n我们给定一个制造解 $u(x,t)$，并假设其为问题的精确解。\n$$\nu(x,t) = \\sin\\left(\\frac{\\pi x}{L}\\right)\\cos(\\omega t) + \\frac{x}{L} t e^{-\\beta t}\n$$\n为使此函数成为精确解，我们必须推导满足控制方程和约束条件的源项 $s(x,t)$、初始条件 $T_0(x)$ 以及边界条件 $g_0(t)$ 和 $g_L(t)$。\n\n首先，我们计算 $u(x,t)$ 所需的偏导数。\n\n关于时间 $t$ 的偏导数为：\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial}{\\partial t} \\left[ \\sin\\left(\\frac{\\pi x}{L}\\right)\\cos(\\omega t) \\right] + \\frac{\\partial}{\\partial t} \\left[ \\frac{x}{L} t e^{-\\beta t} \\right] \\\\\n\\frac{\\partial u}{\\partial t} = -\\omega \\sin\\left(\\frac{\\pi x}{L}\\right)\\sin(\\omega t) + \\frac{x}{L} (1 \\cdot e^{-\\beta t} + t \\cdot (-\\beta e^{-\\beta t})) \\\\\n\\frac{\\partial u}{\\partial t} = -\\omega \\sin\\left(\\frac{\\pi x}{L}\\right)\\sin(\\omega t) + \\frac{x}{L} (1 - \\beta t) e^{-\\beta t}\n$$\n关于空间 $x$ 的二阶偏导数为：\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x}{L}\\right)\\cos(\\omega t) + \\frac{1}{L} t e^{-\\beta t} \\\\\n\\frac{\\partial^2 u}{\\partial x^2} = -\\left(\\frac{\\pi}{L}\\right)^2 \\sin\\left(\\frac{\\pi x}{L}\\right)\\cos(\\omega t)\n$$\n通过整理控制方程可得到源项 $s(x,t)$：$s(x,t) = \\frac{\\partial T}{\\partial t} - \\alpha \\frac{\\partial^2 T}{\\partial x^2}$。代入 $u(x,t)$ 的导数：\n$$\ns(x,t) = \\left[ -\\omega \\sin\\left(\\frac{\\pi x}{L}\\right)\\sin(\\omega t) + \\frac{x}{L} (1 - \\beta t) e^{-\\beta t} \\right] - \\alpha \\left[ -\\left(\\frac{\\pi}{L}\\right)^2 \\sin\\left(\\frac{\\pi x}{L}\\right)\\cos(\\omega t) \\right] \\\\\ns(x,t) = \\sin\\left(\\frac{\\pi x}{L}\\right) \\left[ \\alpha\\left(\\frac{\\pi}{L}\\right)^2\\cos(\\omega t) - \\omega\\sin(\\omega t) \\right] + \\frac{x}{L}(1 - \\beta t)e^{-\\beta t}\n$$\n通过计算 $u(x,t)$ 在 $t=0$ 时的值来获得初始条件 $T_0(x)$：\n$$\nT_0(x) = u(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right)\\cos(0) + \\frac{x}{L}(0)e^0 = \\sin\\left(\\frac{\\pi x}{L}\\right)\n$$\n通过计算 $u(x,t)$ 在 $x=0$ 和 $x=L$ 时的值来找到狄利克雷边界条件：\n$$\ng_0(t) = T(0,t) = u(0,t) = \\sin(0)\\cos(\\omega t) + \\frac{0}{L} t e^{-\\beta t} = 0 \\\\\ng_L(t) = T(L,t) = u(L,t) = \\sin(\\pi)\\cos(\\omega t) + \\frac{L}{L} t e^{-\\beta t} = t e^{-\\beta t}\n$$\n\n### 2. 克兰克-尼科尔森格式的推导\n克兰克-尼科尔森方法是通过在 $t^{n+1/2} = t^n + \\Delta t/2$ 处对控制方程进行时间中心化来推导的。时间导数用区间 $[t^n, t^{n+1}]$ 上的中心差分来近似，而空间导数和源项则用它们在 $t^n$ 和 $t^{n+1}$ 处值的平均值来近似。令 $T_i^n \\approx T(x_i, t^n)$。\n\n$$\n\\left. \\frac{\\partial T}{\\partial t} \\right|_{i}^{n+1/2} = \\frac{1}{2} \\left[ \\left(\\alpha \\frac{\\partial^2 T}{\\partial x^2} + s\\right)_i^n + \\left(\\alpha \\frac{\\partial^2 T}{\\partial x^2} + s\\right)_i^{n+1} \\right]\n$$\n对时间导数使用二阶中心差分，对空间二阶导数使用标准中心差分：\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left( \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2} + \\frac{T_{i+1}^{n+1} - 2T_i^{n+1} + T_{i-1}^{n+1}}{(\\Delta x)^2} \\right) + \\frac{1}{2}(s_i^n + s_i^{n+1})\n$$\n其中 $s_i^k = s(x_i, t^k)$。我们将时间层 $n+1$ 的项（未知数）归到左侧，将时间层 $n$ 的项（已知数）归到右侧。令 $r = \\frac{\\alpha \\Delta t}{2(\\Delta x)^2}$。两边乘以 $\\Delta t$ 并重新整理得到：\n$$\nT_i^{n+1} - r(T_{i+1}^{n+1} - 2T_i^{n+1} + T_{i-1}^{n+1}) = T_i^n + r(T_{i+1}^n - 2T_i^n + T_{i-1}^n) + \\frac{\\Delta t}{2}(s_i^n + s_i^{n+1})\n$$\n这可以简化为内部节点 $i=1, 2, \\dots, N_x-1$ 的计算格式：\n$$\n-r T_{i-1}^{n+1} + (1+2r) T_i^{n+1} - r T_{i+1}^{n+1} = r T_{i-1}^n + (1-2r) T_i^n + r T_{i+1}^n + \\frac{\\Delta t}{2}(s_i^n + s_i^{n+1})\n$$\n\n### 3. 矩阵系统公式化\n所有内部节点的方程组构成一个三对角线性方程组 $\\mathbf{A} \\mathbf{T}_{\\text{int}}^{n+1} = \\mathbf{d}^n$，其中 $\\mathbf{T}_{\\text{int}}^{n+1} = [T_1^{n+1}, T_2^{n+1}, \\dots, T_{N_x-1}^{n+1}]^T$ 是时间 $t^{n+1}$ 时未知内部温度的向量。\n\n矩阵 $\\mathbf{A}$ 是一个 $(N_x-1) \\times (N_x-1)$ 的对称三对角矩阵：\n$$\n\\mathbf{A} = \n\\begin{pmatrix}\n1+2r  -r  0  \\cdots  0 \\\\\n-r  1+2r  -r  \\cdots  0 \\\\\n0  -r  1+2r   \\vdots \\\\\n\\vdots   \\ddots   -r \\\\\n0  \\cdots   -r  1+2r\n\\end{pmatrix}\n$$\n右侧向量 $\\mathbf{d}^n$ 是通过考虑时间层 $n$ 的项并引入边界条件来构建的。对于 $k \\in \\{n, n+1\\}$，边界值 $T_0^k = g_0(t^k)$ 和 $T_{N_x}^k = g_L(t^k)$ 是已知的。\n\n对于第一个内部节点（$i=1$）：\n$$\n-r T_0^{n+1} + (1+2r) T_1^{n+1} - r T_2^{n+1} = r T_0^n + (1-2r) T_1^n + r T_2^n + \\frac{\\Delta t}{2}(s_1^n + s_1^{n+1})\n$$\n将已知的边界项 $-r T_0^{n+1}$ 移到右侧：\n$$\nd_1^n = (1-2r) T_1^n + r T_2^n + r(T_0^n + T_0^{n+1}) + \\frac{\\Delta t}{2}(s_1^n + s_1^{n+1})\n$$\n对于最后一个内部节点（$i=N_x-1$）：\n$$\n-r T_{N_x-2}^{n+1} + (1+2r) T_{N_x-1}^{n+1} - r T_{N_x}^{n+1} = r T_{N_x-2}^n + (1-2r) T_{N_x-1}^n + r T_{N_x}^n + \\frac{\\Delta t}{2}(s_{N_x-1}^n + s_{N_x-1}^{n+1})\n$$\n将已知的边界项 $-r T_{N_x}^{n+1}$ 移到右侧：\n$$\nd_{N_x-1}^n = r T_{N_x-2}^n + (1-2r) T_{N_x-1}^n + r(T_{N_x}^n + T_{N_x}^{n+1}) + \\frac{\\Delta t}{2}(s_{N_x-1}^n + s_{N_x-1}^{n+1})\n$$\n对于任何其他内部节点 $i \\in \\{2, \\dots, N_x-2\\}$：\n$$\nd_i^n = r T_{i-1}^n + (1-2r) T_i^n + r T_{i+1}^n + \\frac{\\Delta t}{2}(s_i^n + s_i^{n+1})\n$$\n在每个时间步，我们使用时间 $t^n$ 的解来组合右侧向量 $\\mathbf{d}^n$，并使用专门的算法（如 `scipy.linalg.solve_banded` 中可用的托马斯算法）高效地求解三对角系统 $\\mathbf{A} \\mathbf{T}_{\\text{int}}^{n+1} = \\mathbf{d}^n$。\n\n### 4. 算法步骤\n1.  设置物理和数值参数：$L, \\alpha, \\omega, \\beta, t_f, N_x, \\Delta t$。\n2.  定义精确解 $u(x,t)$、源项 $s(x,t)$、边界条件 $g_0(t), g_L(t)$ 和初始条件 $T_0(x)$ 的函数。\n3.  创建空间网格 $x_i = i \\Delta x$，其中 $i=0, \\dots, N_x$，$\\Delta x = L/N_x$。\n4.  使用初始条件初始化大小为 $N_x+1$ 的温度向量 $T$：$T_i = T_0(x_i)$。\n5.  以适用于求解器的带状格式构建常数三对角矩阵 $\\mathbf{A}$。\n6.  在从 $t=0$到 $t_f$ 的时间步长循环中进行迭代：\n    a. 确定当前时间 $t^n$ 和下一时间 $t^{n+1}$。\n    b. 使用 $T^n$ 的值以及在 $t^n$ 和 $t^{n+1}$ 处计算的源函数和边界函数，构建大小为 $N_x-1$ 的右侧(RHS)向量 $\\mathbf{d}^n$。\n    c. 求解线性系统 $\\mathbf{A} \\mathbf{T}_{\\text{int}}^{n+1} = \\mathbf{d}^n$ 以获得下一时间步的内部温度。\n    d. 用新解 $\\mathbf{T}_{\\text{int}}^{n+1}$ 更新主温度向量 $T$ 的内部节点。\n7.  在最后一个时间步之后，将数值解 $T$ 的边界点设置为它们在 $t_f$ 时的精确值：$T_0 = g_0(t_f)$ 和 $T_{N_x} = g_L(t_f)$。\n8.  计算所有网格点上的精确解 $u(x_i, t_f)$。\n9.  计算最大绝对误差 $E_{\\infty} = \\max_{0 \\le i \\le N_x} |T_i - u(x_i, t_f)|$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main solver function to run the test cases and print the results.\n    \"\"\"\n    # Shared physical parameters\n    L = 0.3  # m\n    alpha = 1.6e-5  # m^2/s\n    omega = 7.0  # rad/s\n    beta = 3.0  # s^-1\n    t_f = 0.2  # s\n\n    # Define the test cases\n    test_cases = [\n        (50, 0.004),   # Case 1: Happy path\n        (12, 0.01),    # Case 2: Coarse resolution\n        (150, 0.001),  # Case 3: Fine resolution\n    ]\n\n    # --- Manufactured Solution and Derived Functions ---\n    # All angles are in radians, as per numpy default.\n\n    def u_exact(x, t, L, omega, beta):\n        \"\"\"Exact manufactured solution u(x, t).\"\"\"\n        term1 = np.sin(np.pi * x / L) * np.cos(omega * t)\n        term2 = (x / L) * t * np.exp(-beta * t)\n        return term1 + term2\n\n    def s_source(x, t, L, alpha, omega, beta):\n        \"\"\"Derived volumetric source term s(x, t).\"\"\"\n        pi_L_sq = (np.pi / L)**2\n        term1_factor = alpha * pi_L_sq * np.cos(omega * t) - omega * np.sin(omega * t)\n        term1 = np.sin(np.pi * x / L) * term1_factor\n        term2 = (x / L) * (1 - beta * t) * np.exp(-beta * t)\n        return term1 + term2\n\n    def g0(t):\n        \"\"\"Boundary condition at x=0.\"\"\"\n        return 0.0\n\n    def gL(t, beta):\n        \"\"\"Boundary condition at x=L.\"\"\"\n        return t * np.exp(-beta * t)\n\n    def T0(x, L):\n        \"\"\"Initial condition T(x, 0).\"\"\"\n        return np.sin(np.pi * x / L)\n\n    def run_simulation(Nx, dt):\n        \"\"\"\n        Runs the Crank-Nicolson simulation for a single test case.\n\n        Args:\n            Nx (int): Number of spatial intervals.\n            dt (float): Time step size.\n\n        Returns:\n            float: The maximum absolute error E_infinity at the final time.\n        \"\"\"\n        # --- Discretization Setup ---\n        dx = L / Nx\n        x = np.linspace(0, L, Nx + 1)\n        num_steps = round(t_f / dt)\n        # Ensure final time is an exact multiple of dt\n        final_time = num_steps * dt\n\n        # Diffusion number for Crank-Nicolson\n        r = alpha * dt / (2.0 * dx**2)\n\n        # --- Matrix System Setup (A * T_n+1 = d_n) ---\n        num_interior_nodes = Nx - 1\n        \n        # Construct the banded matrix A for the LHS\n        A_banded = np.zeros((3, num_interior_nodes))\n        A_banded[0, 1:] = -r  # Super-diagonal\n        A_banded[1, :] = 1.0 + 2.0 * r  # Main diagonal\n        A_banded[2, :-1] = -r  # Sub-diagonal\n        \n        # --- Initialization ---\n        T = T0(x, L)\n        \n        # --- Time Marching Loop ---\n        for n in range(num_steps):\n            t_n = n * dt\n            t_n_plus_1 = (n + 1) * dt\n            \n            T_interior_n = T[1:Nx]\n            \n            # Construct the RHS vector d_n\n            d_n = np.zeros(num_interior_nodes)\n\n            # Contribution from B * T_n (interior nodes)\n            # This is equivalent to r*T_{i-1}^n + (1-2r)*T_i^n + r*T_{i+1}^n for i=2..Nx-2\n            d_n[1:-1] = r * T_interior_n[:-2] + (1.0 - 2.0 * r) * T_interior_n[1:-1] + r * T_interior_n[2:]\n            # First interior node (i=1)\n            d_n[0] = (1.0 - 2.0 * r) * T_interior_n[0] + r * T_interior_n[1]\n            # Last interior node (i=Nx-1)\n            d_n[-1] = r * T_interior_n[-2] + (1.0 - 2.0 * r) * T_interior_n[-1]\n            \n            # Add source term contribution\n            s_n = s_source(x[1:Nx], t_n, L, alpha, omega, beta)\n            s_n_plus_1 = s_source(x[1:Nx], t_n_plus_1, L, alpha, omega, beta)\n            d_n += (dt / 2.0) * (s_n + s_n_plus_1)\n\n            # Add boundary condition contribution\n            d_n[0] += r * (g0(t_n) + g0(t_n_plus_1))\n            d_n[-1] += r * (gL(t_n, beta) + gL(t_n_plus_1, beta))\n            \n            # Solve the linear system for T at t_n+1\n            T_interior_n_plus_1 = solve_banded((1, 1), A_banded, d_n)\n            \n            # Update the solution vector\n            T[1:Nx] = T_interior_n_plus_1\n\n        # --- Error Calculation at Final Time ---\n        # Update boundary values to t_f for correct error calculation\n        T[0] = g0(final_time)\n        T[Nx] = gL(final_time, beta)\n\n        T_exact_final = u_exact(x, final_time, L, omega, beta)\n        error = np.max(np.abs(T - T_exact_final))\n        \n        return error\n\n    results = []\n    for Nx, dt in test_cases:\n        error_inf = run_simulation(Nx, dt)\n        results.append(error_inf)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}