{
    "hands_on_practices": [
        {
            "introduction": "在有限体积法中，任何计算都始于对控制体几何的精确描述。对于由任意多边形构成的非正交网格，我们必须能够从其顶点坐标稳健地计算出关键的几何属性。本练习将指导你计算一个普通四边形面的质心和法向量，这是处理任何复杂网格所需的基础技能。",
            "id": "3999805",
            "problem": "考虑由傅里叶定律建模的稳态热传导，其中穿过一个面的扩散热通量密度与沿该面外法向单位向量投影的温度梯度成正比。在有限体积法 (FVM) 中，对于非正交网格，两个相邻控制体之间的主要扩散贡献是通过将形心到形心的向量投影到面单位法向量上构建的，这需要对通用多面体单元的面心和面法线有鲁棒的几何定义。\n\n一个四边形面分隔了两个相邻的单元，其形心分别为 $P$ 和 $N$。该面的顶点在三维空间中由位置向量 $\\boldsymbol{r}_1$、$\\boldsymbol{r}_2$、$\\boldsymbol{r}_3$ 和 $\\boldsymbol{r}_4$ 按逆时针顺序列出。顶点坐标和单元形心如下：\n- $\\boldsymbol{r}_1 = (\\,0.100,\\, 0.000,\\, 0.020\\,)$ 米,\n- $\\boldsymbol{r}_2 = (\\,0.180,\\, 0.040,\\, 0.030\\,)$ 米,\n- $\\boldsymbol{r}_3 = (\\,0.160,\\, 0.120,\\, 0.010\\,)$ 米,\n- $\\boldsymbol{r}_4 = (\\,0.080,\\, 0.080,\\, 0.000\\,)$ 米,\n- $\\boldsymbol{r}_P = (\\,0.120,\\, 0.050,\\, 0.010\\,)$ 米,\n- $\\boldsymbol{r}_N = (\\,0.140,\\, 0.090,\\, 0.020\\,)$ 米。\n\n从向量微积分和几何学的第一性原理出发，并且除了局部的三角形分解外不假设面的平面性，完成以下任务：\n- 将四边形分解为两个三角形 $(\\boldsymbol{r}_1,\\boldsymbol{r}_2,\\boldsymbol{r}_3)$ 和 $(\\boldsymbol{r}_1,\\boldsymbol{r}_3,\\boldsymbol{r}_4)$，并通过对三角形的形心进行面积加权平均来构建面心 $\\boldsymbol{r}_f$。\n- 通过对三角形面积向量求和来构建面面积向量，并通过将此面积向量归一化来定义单位面法向量 $\\boldsymbol{n}_f$。选择 $\\boldsymbol{n}_f$ 的方向，使得 $(\\boldsymbol{r}_N - \\boldsymbol{r}_P)\\cdot \\boldsymbol{n}_f \\ge 0$。\n- 使用这些几何构造，推导并计算正交距离 $d_{\\perp}$，其为 $(\\boldsymbol{r}_N - \\boldsymbol{r}_P)$ 在 $\\boldsymbol{n}_f$ 上的投影。\n\n只报告 $d_{\\perp}$ 的最终值。您的答案应以米为单位，并四舍五入到四位有效数字。",
            "solution": "用户提供的问题已经过验证，并被确定为计算几何领域中一个有效的、适定的问题，与计算热工学领域相关。所有必要数据均已提供，约束条件一致，且该问题基于公认的科学和数学原理。\n\n解题过程遵循问题陈述中概述的步骤。所有坐标均以米为单位。\n\n首先，我们定义四边形面顶点以及相邻单元形心 $P$ 和 $N$ 的给定位置向量：\n$\\boldsymbol{r}_1 = \\begin{pmatrix} 0.100 \\\\ 0.000 \\\\ 0.020 \\end{pmatrix}$, $\\boldsymbol{r}_2 = \\begin{pmatrix} 0.180 \\\\ 0.040 \\\\ 0.030 \\end{pmatrix}$, $\\boldsymbol{r}_3 = \\begin{pmatrix} 0.160 \\\\ 0.120 \\\\ 0.010 \\end{pmatrix}$, $\\boldsymbol{r}_4 = \\begin{pmatrix} 0.080 \\\\ 0.080 \\\\ 0.000 \\end{pmatrix}$\n$\\boldsymbol{r}_P = \\begin{pmatrix} 0.120 \\\\ 0.050 \\\\ 0.010 \\end{pmatrix}$, $\\boldsymbol{r}_N = \\begin{pmatrix} 0.140 \\\\ 0.090 \\\\ 0.020 \\end{pmatrix}$\n\n第一个任务是通过将四边形分解为两个三角形 $T_A = (\\boldsymbol{r}_1, \\boldsymbol{r}_2, \\boldsymbol{r}_3)$ 和 $T_B = (\\boldsymbol{r}_1, \\boldsymbol{r}_3, \\boldsymbol{r}_4)$ 来构建面心 $\\boldsymbol{r}_f$。\n\n对于三角形 $T_A$，我们计算其形心、面积向量和标量面积。\n形心 $\\boldsymbol{c}_A$ 是其顶点的算术平均值：\n$$ \\boldsymbol{c}_A = \\frac{1}{3}(\\boldsymbol{r}_1 + \\boldsymbol{r}_2 + \\boldsymbol{r}_3) = \\frac{1}{3}\\begin{pmatrix} 0.100+0.180+0.160 \\\\ 0.000+0.040+0.120 \\\\ 0.020+0.030+0.010 \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} 0.440 \\\\ 0.160 \\\\ 0.060 \\end{pmatrix} $$\n面积向量 $\\boldsymbol{A}_A$ 是通过两个边向量的叉积计算得出的：\n$$ \\boldsymbol{r}_2 - \\boldsymbol{r}_1 = \\begin{pmatrix} 0.080 \\\\ 0.040 \\\\ 0.010 \\end{pmatrix}, \\quad \\boldsymbol{r}_3 - \\boldsymbol{r}_1 = \\begin{pmatrix} 0.060 \\\\ 0.120 \\\\ -0.010 \\end{pmatrix} $$\n$$ \\boldsymbol{A}_A = \\frac{1}{2} [(\\boldsymbol{r}_2 - \\boldsymbol{r}_1) \\times (\\boldsymbol{r}_3 - \\boldsymbol{r}_1)] = \\frac{1}{2} \\begin{pmatrix} (0.040)(-0.010) - (0.010)(0.120) \\\\ (0.010)(0.060) - (0.080)(-0.010) \\\\ (0.080)(0.120) - (0.040)(0.060) \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} = \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} $$\n标量面积 $A_A$ 是 $\\boldsymbol{A}_A$ 的模：\n$$ A_A = |\\boldsymbol{A}_A| = \\sqrt{(-0.0008)^2 + (0.0007)^2 + (0.0036)^2} = \\sqrt{1.409 \\times 10^{-5}} \\approx 0.003753665 \\text{ 米}^2 $$\n\n对于三角形 $T_B$，我们进行类似的计算。\n形心 $\\boldsymbol{c}_B$ 为：\n$$ \\boldsymbol{c}_B = \\frac{1}{3}(\\boldsymbol{r}_1 + \\boldsymbol{r}_3 + \\boldsymbol{r}_4) = \\frac{1}{3}\\begin{pmatrix} 0.100+0.160+0.080 \\\\ 0.000+0.120+0.080 \\\\ 0.020+0.010+0.000 \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} 0.340 \\\\ 0.200 \\\\ 0.030 \\end{pmatrix} $$\n面积向量 $\\boldsymbol{A}_B$ 为：\n$$ \\boldsymbol{r}_3 - \\boldsymbol{r}_1 = \\begin{pmatrix} 0.060 \\\\ 0.120 \\\\ -0.010 \\end{pmatrix}, \\quad \\boldsymbol{r}_4 - \\boldsymbol{r}_1 = \\begin{pmatrix} -0.020 \\\\ 0.080 \\\\ -0.020 \\end{pmatrix} $$\n$$ \\boldsymbol{A}_B = \\frac{1}{2} [(\\boldsymbol{r}_3 - \\boldsymbol{r}_1) \\times (\\boldsymbol{r}_4 - \\boldsymbol{r}_1)] = \\frac{1}{2} \\begin{pmatrix} (0.120)(-0.020) - (-0.010)(0.080) \\\\ (-0.010)(-0.020) - (0.060)(-0.020) \\\\ (0.060)(0.080) - (0.120)(-0.020) \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} = \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} $$\n标量面积 $A_B$ 是 $\\boldsymbol{A}_B$ 的模：\n$$ A_B = |\\boldsymbol{A}_B| = \\sqrt{(-0.0008)^2 + (0.0007)^2 + (0.0036)^2} = \\sqrt{1.409 \\times 10^{-5}} \\approx 0.003753665 \\text{ 米}^2 $$\n面心 $\\boldsymbol{r}_f$ 是三角形形心的面积加权平均值：\n$$ \\boldsymbol{r}_f = \\frac{A_A \\boldsymbol{c}_A + A_B \\boldsymbol{c}_B}{A_A + A_B} $$\n由于 $A_A = A_B$，这简化为形心的算术平均值：\n$$ \\boldsymbol{r}_f = \\frac{1}{2}(\\boldsymbol{c}_A + \\boldsymbol{c}_B) = \\frac{1}{2} \\left[ \\frac{1}{3}\\begin{pmatrix} 0.440 \\\\ 0.160 \\\\ 0.060 \\end{pmatrix} + \\frac{1}{3}\\begin{pmatrix} 0.340 \\\\ 0.200 \\\\ 0.030 \\end{pmatrix} \\right] = \\frac{1}{6}\\begin{pmatrix} 0.780 \\\\ 0.360 \\\\ 0.090 \\end{pmatrix} = \\begin{pmatrix} 0.130 \\\\ 0.060 \\\\ 0.015 \\end{pmatrix} $$\n\n第二个任务是构建面面积向量和单位面法向量 $\\boldsymbol{n}_f$。\n总面面积向量 $\\boldsymbol{A}_f$ 是三角形面积向量的和：\n$$ \\boldsymbol{A}_f = \\boldsymbol{A}_A + \\boldsymbol{A}_B = \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} + \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} = \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} $$\n面面积向量的模为：\n$$ |\\boldsymbol{A}_f| = \\sqrt{(-0.0016)^2 + (0.0014)^2 + (0.0072)^2} = \\sqrt{2.56 \\times 10^{-6} + 1.96 \\times 10^{-6} + 51.84 \\times 10^{-6}} = \\sqrt{5.636 \\times 10^{-5}} $$\n$$ |\\boldsymbol{A}_f| \\approx 0.00750733 \\text{ 米}^2 $$\n原始单位法向量为 $\\boldsymbol{n}_{f, \\text{raw}} = \\frac{\\boldsymbol{A}_f}{|\\boldsymbol{A}_f|}$。\n我们必须确保其方向满足 $(\\boldsymbol{r}_N - \\boldsymbol{r}_P)\\cdot \\boldsymbol{n}_f \\ge 0$。首先，我们计算连接单元形心的向量：\n$$ \\boldsymbol{d} = \\boldsymbol{r}_N - \\boldsymbol{r}_P = \\begin{pmatrix} 0.140-0.120 \\\\ 0.090-0.050 \\\\ 0.020-0.010 \\end{pmatrix} = \\begin{pmatrix} 0.02 \\\\ 0.04 \\\\ 0.01 \\end{pmatrix} $$\n接下来，我们检查点积 $\\boldsymbol{d} \\cdot \\boldsymbol{A}_f$ 的符号：\n$$ \\boldsymbol{d} \\cdot \\boldsymbol{A}_f = (0.02)(-0.0016) + (0.04)(0.0014) + (0.01)(0.0072) = -0.000032 + 0.000056 + 0.000072 = 0.000096 $$\n由于该点积为正，$\\boldsymbol{A}_f$ 的方向已经符合要求。因此，最终的单位法向量 $\\boldsymbol{n}_f$ 为：\n$$ \\boldsymbol{n}_f = \\frac{\\boldsymbol{A}_f}{|\\boldsymbol{A}_f|} = \\frac{1}{\\sqrt{5.636 \\times 10^{-5}}} \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} $$\n\n第三个任务是计算正交距离 $d_{\\perp}$。这被定义为形心到形心的向量 $\\boldsymbol{d} = \\boldsymbol{r}_N - \\boldsymbol{r}_P$ 在单位面法向量 $\\boldsymbol{n}_f$ 上的投影。这个投影由点积给出：\n$$ d_{\\perp} = (\\boldsymbol{r}_N - \\boldsymbol{r}_P) \\cdot \\boldsymbol{n}_f = \\boldsymbol{d} \\cdot \\frac{\\boldsymbol{A}_f}{|\\boldsymbol{A}_f|} = \\frac{\\boldsymbol{d} \\cdot \\boldsymbol{A}_f}{|\\boldsymbol{A}_f|} $$\n使用先前计算的值：\n$$ d_{\\perp} = \\frac{0.000096}{\\sqrt{5.636 \\times 10^{-5}}} \\approx \\frac{0.000096}{0.00750733} \\approx 0.0127873 \\text{ 米} $$\n按要求将结果四舍五入到四位有效数字：\n$$ d_{\\perp} \\approx 0.01279 \\text{ 米} $$",
            "answer": "$$\\boxed{0.01279}$$"
        },
        {
            "introduction": "精确定义几何量之后，下一步是理解非正交性如何影响数值格式的精度。一个在正交网格上表现良好的简单格式，在倾斜网格上可能会产生不可忽略的误差。本练习将通过一个经典的二维热传导问题，让你亲手实现一个简单的两点通量近似格式，并量化其在斜网格上引入的离散误差，从而深刻理解为何必须为非正交网格开发专门的修正格式。",
            "id": "3999818",
            "problem": "考虑稳态、各向同性的热传导方程，其导热系数为常数，写作 $-\\nabla \\cdot (k \\nabla T) = q$，其中 $k$ 为正常数。在通用二维网格上进行有限体积法 (FVM) 离散时，根据散度定理，控制体上扩散通量的散度可以推导为其各个表面法向通量的总和。在非正交网格上，相邻单元的中心连接向量通常与面法线方向不一致，如果使用两点法来近似通量，会引入几何误差。本问题旨在量化此类误差，并将其与标准的偏斜度度量指标关联起来。\n\n通过对单位正方形参考网格应用仿射剪切变换，可以构建一系列偏斜网格。设参考坐标为 $(x,y) \\in [0,1] \\times [0,1]$，其上划分有 $N_x \\times N_y$ 个四边形单元的结构化网格。通过剪切映射定义物理坐标 $(x',y')$\n$$\n\\begin{pmatrix} x' \\\\ y' \\end{pmatrix}\n=\n\\begin{pmatrix} 1 & \\alpha \\\\ 0 & 1 \\end{pmatrix}\n\\begin{pmatrix} x \\\\ y \\end{pmatrix}\n=\n\\begin{pmatrix} x + \\alpha y \\\\ y \\end{pmatrix},\n$$\n其中 $\\alpha$ 是一个实值偏斜参数。对于任意 $\\alpha$，该映射都是线性的且保持面积不变。\n\n设基准温度场为如下的制造解\n$$\nT(x',y') = \\sin(\\pi x') \\sin(\\pi y'),\n$$\n并取 $k = 1$，因此精确的拉普拉斯算子为\n$$\n\\nabla^2 T(x',y') = -2 \\pi^2 \\sin(\\pi x') \\sin(\\pi y').\n$$\n对于每个内部单元，在其每个面上使用两点、中心到中心的格式，构建扩散通量散度的离散近似。对于单元 $P$ 与其相邻单元 $N$ 之间的面 $f$，定义中心连接向量 $\\boldsymbol{r}_f = \\boldsymbol{x}_N - \\boldsymbol{x}_P$、其模长 $|\\boldsymbol{r}_f|$ 以及单位向量 $\\hat{\\boldsymbol{r}}_f = \\boldsymbol{r}_f / |\\boldsymbol{r}_f|$。设面的边向量为 $\\boldsymbol{e}_f$，其模长为面长 $L_f = \\|\\boldsymbol{e}_f\\|$，并设 $\\hat{\\boldsymbol{n}}_f$ 为面的单位法向量，其方向的选取保证 $\\hat{\\boldsymbol{n}}_f \\cdot \\hat{\\boldsymbol{r}}_f \\ge 0$。则面矢量为 $\\boldsymbol{S}_f = L_f \\hat{\\boldsymbol{n}}_f$。穿过面 $f$ 的两点法向通量计算如下\n$$\n\\Phi_f^{\\text{TP}} = \\left( \\frac{T_N - T_P}{|\\boldsymbol{r}_f|} \\right) \\left( \\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right),\n$$\n单元 $P$ 中的离散散度为 $\\sum_{f \\in \\partial P} \\Phi_f^{\\text{TP}} / A_P$，其中 $A_P$ 是单元的物理面积。在边界面上，通过在面心计算 $T$ 值作为 $T_N$ 并将 $\\boldsymbol{r}_f$ 取为从单元中心到面心的向量，来施加狄利克雷(Dirichlet)数据。\n\n将每个单元的误差定义为\n$$\nE_P = \\frac{1}{A_P} \\sum_{f \\in \\partial P} \\Phi_f^{\\text{TP}} - \\nabla^2 T(\\boldsymbol{x}_P),\n$$\n并计算所有单元上的离散 $L_2$ 范数和离散 $L_{\\infty}$ 范数：\n$$\n\\|E\\|_{L_2} = \\sqrt{ \\sum_{P} A_P \\, E_P^2 }, \\qquad \\|E\\|_{L_{\\infty}} = \\max_{P} |E_P|.\n$$\n为表征非正交性，使用以下基于面的偏斜度度量指标。对于每个面 $f$，定义失准角\n$$\n\\theta_f = \\arccos\\!\\left( \\left| \\hat{\\boldsymbol{n}}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right| \\right),\n$$\n以弧度表示，以及非正交修正向量\n$$\n\\boldsymbol{s}_f = \\boldsymbol{S}_f - \\left( \\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right) \\hat{\\boldsymbol{r}}_f,\n$$\n其模长为 $\\|\\boldsymbol{s}_f\\| = L_f \\sin(\\theta_f)$。在整个网格（包括边界面）上，计算\n$$\n\\theta_{\\max} = \\max_f \\theta_f, \\qquad \\overline{\\|\\boldsymbol{s}\\|} = \\frac{1}{N_F} \\sum_{f} \\|\\boldsymbol{s}_f\\|,\n$$\n其中 $N_F$ 是总的面数。\n\n您的任务是实现一个程序，对于由不同 $(N_x,N_y,\\alpha)$ 三元组生成的一系列网格，计算误差 $E_P$ 的离散 $L_2$ 和 $L_{\\infty}$ 范数，以及偏斜度度量指标 $\\theta_{\\max}$ 和 $\\overline{\\|\\boldsymbol{s}\\|}$。然后，通过报告测试套件中 $\\|E\\|_{L_2}$ 值向量与 $\\theta_{\\max}$ 值向量之间，以及 $\\|E\\|_{L_2}$ 值向量与 $\\overline{\\|\\boldsymbol{s}\\|}$ 值向量之间的皮尔逊(Pearson)相关系数，将误差大小与偏斜度度量指标进行关联。\n\n角度量必须以弧度报告。在此设置中，所有其他量均为无量纲。\n\n实现程序以评估以下测试套件：\n- 案例 1: $(N_x,N_y,\\alpha) = (20,20,0.0)$。\n- 案例 2: $(N_x,N_y,\\alpha) = (20,20,0.2)$。\n- 案例 3: $(N_x,N_y,\\alpha) = (20,20,0.4)$。\n- 案例 4 (分辨率较粗的边缘案例): $(N_x,N_y,\\alpha) = (4,4,0.3)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个测试案例贡献一个包含四个浮点数的子列表 $[\\|E\\|_{L_2}, \\|E\\|_{L_{\\infty}}, \\theta_{\\max}, \\overline{\\|\\boldsymbol{s}\\|}]$，顺序如此。在这些子列表之后，附加两个额外的浮点数：四个案例中 $\\|E\\|_{L_2}$ 值列表与 $\\theta_{\\max}$ 值列表之间的皮尔逊(Pearson)相关系数，以及四个案例中 $\\|E\\|_{L_2}$ 值列表与 $\\overline{\\|\\boldsymbol{s}\\|}$ 值列表之间的皮尔逊(Pearson)相关系数。例如，输出格式为\n$$\n\\big[ [e_{2,1}, e_{\\infty,1}, \\theta_{\\max,1}, \\overline{\\|s\\|}_1], [e_{2,2}, e_{\\infty,2}, \\theta_{\\max,2}, \\overline{\\|s\\|}_2], [e_{2,3}, e_{\\infty,3}, \\theta_{\\max,3}, \\overline{\\|s\\|}_3], [e_{2,4}, e_{\\infty,4}, \\theta_{\\max,4}, \\overline{\\|s\\|}_4], \\rho_{e_2,\\theta}, \\rho_{e_2,\\overline{s}} \\big],\n$$\n其中每个 $e_{2,i}$ 是案例 $i$ 的 $\\|E\\|_{L_2}$，每个 $e_{\\infty,i}$ 是案例 $i$ 的 $\\|E\\|_{L_{\\infty}}$，而 $\\rho_{e_2,\\theta}$ 和 $\\rho_{e_2,\\overline{s}}$ 是对应的皮尔逊(Pearson)相关系数。程序必须生成网格，执行所有计算，并严格按照此格式打印单行输出，不得包含任何其他文本。",
            "solution": "该问题要求在有限体积法 (FVM) 框架内，针对非正交网格上的稳态热传导方程，对两点通量近似 (TPFA) 格式所产生的离散误差进行批判性分析。此分析将通过为一系列测试案例实现指定的数值格式，并将计算出的误差与标准的网格偏斜度度量指标进行关联来完成。\n\n控制偏微分方程是泊松(Poisson)方程，它源于具有恒定导热系数 $k$ 和热源 $q$ 的稳态各向同性热传导：\n$$\n-\\nabla \\cdot (k \\nabla T) = q\n$$\n对于本问题，给定 $k=1$，因此方程简化为 $-\\nabla^2 T = q$。FVM 的基础是将此方程在一个控制体 $V_P$（网格中的一个单元）上积分，并应用散度定理：\n$$\n\\int_{V_P} -\\nabla \\cdot (\\nabla T) \\, dV = \\int_{V_P} q \\, dV\n$$\n$$\n-\\oint_{\\partial V_P} \\nabla T \\cdot d\\boldsymbol{S} = \\int_{V_P} q \\, dV\n$$\n左侧项代表通过其边界 $\\partial V_P$流入控制体的净热通量。离散化此表达式，单元体积 $V_P$ 上的积分近似为 $q_P A_P$，其中 $q_P$ 是在单元中心 $\\boldsymbol{x}_P$ 处的热源值，$A_P$ 是单元面积（在二维情况下）。边界积分则通过构成 $\\partial V_P$ 的各个面 $f$ 上的通量之和来近似：\n$$\n\\sum_{f \\in \\partial V_P} \\text{Flux}_f^{\\text{in}} \\approx q_P A_P\n$$\n本问题的设置是为了分析一种特定、简单的通量近似方法。对于分隔单元 $P$ 与其相邻单元 $N$ 的面 $f$，温度梯度 $\\nabla T$ 是沿着连接单元中心的直线 $\\boldsymbol{r}_f = \\boldsymbol{x}_N - \\boldsymbol{x}_P$ 进行近似的。这导出了从相邻单元 $N$ 穿过面 $f$ 进入单元 $P$ 的热通量的两点近似法：\n$$\n\\Phi_f^{\\text{TP}} = \\left( \\frac{T_N - T_P}{|\\boldsymbol{r}_f|} \\right) \\left( \\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right)\n$$\n此处，$\\boldsymbol{S}_f$ 是面矢量（垂直于面，其大小等于面长），而 $\\hat{\\boldsymbol{r}}_f$ 是沿中心连接线的单位向量。众所周知，这种近似仅在网格正交时，即 $\\boldsymbol{r}_f$ 与 $\\boldsymbol{S}_f$ 平行时，才是准确的。在非正交网格上，由于 $\\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\neq |\\boldsymbol{S}_f|$，此公式会引入一个“偏斜误差”。\n\n为了量化此误差，我们使用制造解方法。我们指定一个光滑的温度场解析函数 $T(x',y') = \\sin(\\pi x') \\sin(\\pi y')$。然后，精确计算满足控制方程所需对应的源项 $q$：\n$$\nq = -\\nabla^2 T = -(-2\\pi^2 \\sin(\\pi x') \\sin(\\pi y')) = 2\\pi^2 T(x', y')\n$$\n从 FVM 平衡推导出的源项离散算子为 $(\\sum_{f} \\Phi_f^{\\text{TP}}) / A_P$。问题将每个单元的误差 $E_P$ 定义为离散算子的作用与解析拉普拉斯算子之间的差值，两者均使用制造解进行评估：\n$$\nE_P = \\frac{1}{A_P} \\sum_{f \\in \\partial P} \\Phi_f^{\\text{TP}} - \\nabla^2 T(\\boldsymbol{x}_P)\n$$\n这个误差 $E_P$ 代表了空间离散的截断误差。我们将使用离散 $L_2$ 和 $L_{\\infty}$ 范数在整个网格上全局量化此误差：\n$$\n\\|E\\|_{L_2} = \\sqrt{ \\sum_{P} A_P \\, E_P^2 }, \\qquad \\|E\\|_{L_{\\infty}} = \\max_{P} |E_P|\n$$\n几何非正交性由两个度量指标来表征。对于每个面 $f$，我们计算面法线与单元中心连接向量之间的失准角 $\\theta_f$：\n$$\n\\theta_f = \\arccos\\!\\left( \\left| \\hat{\\boldsymbol{n}}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right| \\right) = \\arccos\\!\\left( \\frac{|\\boldsymbol{S}_f \\cdot \\boldsymbol{r}_f|}{\\|\\boldsymbol{S}_f\\| \\|\\boldsymbol{r}_f\\|} \\right)\n$$\n以及非正交修正向量 $\\boldsymbol{s}_f$ 的模长，该向量是面矢量 $\\boldsymbol{S}_f$ 在与 $\\hat{\\boldsymbol{r}}_f$ 正交方向上的分量：\n$$\n\\|\\boldsymbol{s}_f\\| = \\|\\boldsymbol{S}_f\\| \\sin(\\theta_f)\n$$\n这些指标被聚合成全局网格偏斜度度量指标 $\\theta_{\\max}$（所有面上的最大角度）和 $\\overline{\\|\\boldsymbol{s}\\|}$（所有面上 $\\boldsymbol{s}_f$ 模长的平均值）。\n\n实现过程如下：\n1.  对于每个由 $(N_x, N_y, \\alpha)$ 定义的测试案例，生成一个结构化网格。首先，在参考域 $[0,1] \\times [0,1]$ 中创建一个 $(N_x+1) \\times (N_y+1)$ 个节点的均匀笛卡尔网格。然后，应用仿射剪切映射 $\\begin{pmatrix} x' \\\\ y' \\end{pmatrix} = \\begin{pmatrix} 1 & \\alpha \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix}$ 将节点坐标转换到物理域中。\n2.  计算所有单元和面的几何属性。单元中心 $\\boldsymbol{x}_P$ 计算为其四个顶点的形心。单元面积 $A_P$ 使用鞋带公式计算。对于每个面，确定其长度 $L_f$、中心和面矢量 $\\boldsymbol{S}_f$。\n3.  一个循环遍历网格中的每个单元 $P$。对于其四个面中的每一个，识别出相应的相邻单元 $N$。\n4.  对于每个面，如果是内部面，则相邻单元是邻近的单元。如果是边界面，则根据指定的狄利克雷(Dirichlet)边界条件处理方式，在面心处获取“相邻”数据。\n5.  计算向量 $\\boldsymbol{r}_f$ 和 $\\boldsymbol{S}_f$。通过算法强制规定 $\\boldsymbol{S}_f$ 的方向以确保 $\\boldsymbol{S}_f \\cdot \\boldsymbol{r}_f \\ge 0$。\n6.  计算通量贡献 $\\Phi_f^{\\text{TP}}$ 并将其加到单元 $P$ 的运行总和中。同时计算并存储基于面的偏斜度度量指标 $\\theta_f$ 和 $\\|\\boldsymbol{s}_f\\|$，避免对内部面进行重复计算。\n7.  处理完一个单元的所有面后，使用总通量和来计算单元误差 $E_P$。\n8.  一旦所有单元处理完毕，计算全局误差范数 $\\|E\\|_{L_2}$ 和 $\\|E\\|_{L_{\\infty}}$，以及全局偏斜度度量指标 $\\theta_{\\max}$ 和 $\\overline{\\|\\boldsymbol{s}\\|}$。\n9.  完成所有四个测试案例后，分别计算 $\\|E\\|_{L_2}$ 值向量与 $\\theta_{\\max}$ 值向量之间，以及 $\\|E\\|_{L_2}$ 值向量与 $\\overline{\\|\\boldsymbol{s}\\|}$ 值向量之间的皮尔逊(Pearson)相关系数。这量化了离散误差与网格非正交性之间的统计关系。\n\n此程序提供了问题陈述所要求的完整而严谨的评估。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        (20, 20, 0.0),\n        (20, 20, 0.2),\n        (20, 20, 0.4),\n        (4, 4, 0.3),\n    ]\n\n    case_results = []\n    e_l2_values = []\n    theta_max_values = []\n    s_bar_values = []\n\n    for Nx, Ny, alpha in test_cases:\n        e_l2, e_linf, theta_max, s_bar = compute_metrics(Nx, Ny, alpha)\n        case_results.append([e_l2, e_linf, theta_max, s_bar])\n        e_l2_values.append(e_l2)\n        theta_max_values.append(theta_max)\n        s_bar_values.append(s_bar)\n\n    # Compute correlation coefficients\n    rho_e2_theta = np.corrcoef(e_l2_values, theta_max_values)[0, 1]\n    rho_e2_s = np.corrcoef(e_l2_values, s_bar_values)[0, 1]\n\n    # Format the output string\n    result_str_parts = [f\"[{','.join(f'{val:.8e}' for val in res)}]\" for res in case_results]\n    full_result_str = f\"[{','.join(result_str_parts)},{rho_e2_theta:.8e},{rho_e2_s:.8e}]\"\n    \n    print(full_result_str)\n\ndef compute_metrics(Nx, Ny, alpha):\n    \"\"\"\n    Computes error and skewness metrics for a given mesh configuration.\n    \"\"\"\n    # Define manufactured solution and its Laplacian\n    T_func = lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y)\n    lap_T_func = lambda x, y: -2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    # 1. Generate mesh nodes in physical coordinates (x', y')\n    x_ref = np.linspace(0, 1, Nx + 1)\n    y_ref = np.linspace(0, 1, Ny + 1)\n    xx_ref, yy_ref = np.meshgrid(x_ref, y_ref, indexing='ij')\n\n    shear_map = np.array([[1, alpha], [0, 1]])\n    ref_coords = np.stack([xx_ref, yy_ref], axis=-1)\n    nodes = np.einsum('ij,klj->kli', shear_map, ref_coords)\n\n    # 2. Compute cell centers and areas\n    cell_centers = np.zeros((Nx, Ny, 2))\n    cell_areas = np.zeros((Nx, Ny))\n    for i in range(Nx):\n        for j in range(Ny):\n            v1 = nodes[i, j]\n            v2 = nodes[i + 1, j]\n            v3 = nodes[i + 1, j + 1]\n            v4 = nodes[i, j + 1]\n            cell_centers[i, j] = (v1 + v2 + v3 + v4) / 4.0\n            # Shoelace formula for area of a quadrilateral\n            area = 0.5 * abs(v1[0]*v2[1] - v1[1]*v2[0] + \n                             v2[0]*v3[1] - v2[1]*v3[0] + \n                             v3[0]*v4[1] - v3[1]*v4[0] + \n                             v4[0]*v1[1] - v4[1]*v1[0])\n            cell_areas[i, j] = area\n            \n    # 3. Main loop: Compute fluxes and skewness for each cell\n    cell_flux_sum = np.zeros((Nx, Ny))\n    face_thetas = []\n    face_s_mags = []\n    processed_faces = set()\n\n    for i in range(Nx):\n        for j in range(Ny):\n            P_center = cell_centers[i, j]\n            T_P = T_func(P_center[0], P_center[1])\n\n            # Neighbors: E, N, W, S\n            neighbors_info = [\n                ('E', i + 1, j, (i + 1, j), (i + 1, j + 1)), # N, P_face_node_idx1, P_face_node_idx2\n                ('N', i, j + 1, (i + 1, j + 1), (i, j + 1)),\n                ('W', i - 1, j, (i, j + 1), (i, j)),\n                ('S', i, j - 1, (i, j), (i + 1, j))\n            ]\n\n            for direction, ni, nj, v_idx1, v_idx2 in neighbors_info:\n                is_boundary = not (0 <= ni < Nx and 0 <= nj < Ny)\n                \n                v1 = nodes[v_idx1]\n                v2 = nodes[v_idx2]\n\n                # Face area vector S_f, oriented outwards from P\n                S_f = np.array([v2[1] - v1[1], -(v2[0] - v1[0])])\n                L_f = np.linalg.norm(S_f)\n\n                if is_boundary:\n                    face_center = (v1 + v2) / 2.0\n                    r_f = face_center - P_center\n                    T_N = T_func(face_center[0], face_center[1])\n                else:\n                    N_center = cell_centers[ni, nj]\n                    r_f = N_center - P_center\n                    T_N = T_func(N_center[0], N_center[1])\n\n                # Ensure S_f.r_f >= 0 as per problem spec\n                if np.dot(S_f, r_f) < 0:\n                    S_f = -S_f\n                \n                r_f_mag_sq = np.dot(r_f, r_f)\n                if r_f_mag_sq == 0:\n                    flux = 0\n                else:\n                    flux = (T_N - T_P) * np.dot(S_f, r_f) / r_f_mag_sq\n                \n                cell_flux_sum[i, j] += flux\n                \n                # Use a canonical representation of the face to avoid double counting\n                face_key = tuple(sorted((v_idx1, v_idx2)))\n                if face_key not in processed_faces:\n                    processed_faces.add(face_key)\n                    \n                    r_f_mag = np.sqrt(r_f_mag_sq)\n                    if L_f > 1e-12 and r_f_mag > 1e-12:\n                        cos_theta_abs = abs(np.dot(S_f, r_f)) / (L_f * r_f_mag)\n                        # Clamp due to potential floating point inaccuracies\n                        cos_theta_abs = min(1.0, max(-1.0, cos_theta_abs))\n                        theta_f = np.arccos(cos_theta_abs)\n                        s_mag = L_f * np.sin(theta_f)\n                        \n                        face_thetas.append(theta_f)\n                        face_s_mags.append(s_mag)\n\n    # 4. Compute error norms and aggregated skewness metrics\n    cell_errors = np.zeros((Nx, Ny))\n    for i in range(Nx):\n        for j in range(Ny):\n            P_center = cell_centers[i, j]\n            lap_T_P = lap_T_func(P_center[0], P_center[1])\n            discrete_lap = cell_flux_sum[i, j] / cell_areas[i, j]\n            cell_errors[i, j] = discrete_lap - lap_T_P\n            \n    e_l2 = np.sqrt(np.sum(cell_areas * cell_errors**2))\n    e_linf = np.max(np.abs(cell_errors))\n    \n    theta_max = np.max(face_thetas) if face_thetas else 0.0\n    s_bar = np.mean(face_s_mags) if face_s_mags else 0.0\n\n    return e_l2, e_linf, theta_max, s_bar\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "认识到非正交性会引入误差后，我们转向一个更高级的实际应用：在压力-速度耦合算法中处理这种效应。Rhie-Chow 插值是防止同位网格上出现压力棋盘格震荡的关键技术，但其标准形式在非正交网格上同样需要修正。本练习旨在通过量化忽略非正交修正项所带来的速度场误差，揭示该修正对于维持解的准确性和稳定性的重要作用。",
            "id": "3999812",
            "problem": "考虑一个二维、稳态、不可压缩的流场，其中用于计算质量通量的面法向速度是通过 Rhie–Chow 动量插值 (RCMI) 获得的。在非正交网格中，面法向压力梯度的正交近似使用沿连接单元中心的直线投影的中心到中心压力差，而完整的非正交修正则添加了投影到面法线上的压力梯度的切向分量。目标是通过与一个由已知解析压力场构建的参考解进行比较，来量化忽略非正交修正时计算出的面法向速度的误差，并报告由此引起的棋盘格振荡幅值。\n\n基本原理和几何设置：\n- 设压力是在一个映射网格上定义的光滑标量场 $p(x,y)$。由压力梯度引起的面法向速度分量，以无量纲形式表示为 $u_{n,f} = -\\nabla p \\cdot \\boldsymbol{n}_f$，其中 $\\boldsymbol{n}_f$ 是面 $f$ 的单位法向量。此选择对应于一种无量纲化，其中有效逆动量系数为单位1，因此所有量都是无量纲的。\n- 对于由两个相邻控制体共享的面 $f$，其控制体中心由大小为 $\\lvert \\boldsymbol{d} \\rvert$ 的向量 $\\boldsymbol{d}$ 分隔，定义单位向量 $\\hat{\\boldsymbol{d}} = \\boldsymbol{d} / \\lvert \\boldsymbol{d} \\rvert$。将面法向量分解为 $\\boldsymbol{n}_f = \\beta_f \\hat{\\boldsymbol{d}} + \\boldsymbol{t}_f$，其中 $\\beta_f = \\boldsymbol{n}_f \\cdot \\hat{\\boldsymbol{d}}$，$\\boldsymbol{t}_f$ 是 $\\boldsymbol{n}_f$ 在 $\\hat{\\boldsymbol{d}}$ 切线方向上的分量。面法向压力梯度的正交近似使用 $\\beta_f \\, \\Delta p / \\lvert \\boldsymbol{d} \\rvert$，其中 $\\Delta p$ 是跨面的压力差。非正交修正则加上 $\\boldsymbol{t}_f \\cdot (\\nabla p)_f$，其中 $(\\nabla p)_f$ 是在面中心处计算的压力梯度。\n- 通过从计算坐标 $(\\xi,\\eta) \\in [0,1]^2$到物理坐标 $(x,y)$的线性剪切映射来构建非正交网格：\n$$\nx(\\xi,\\eta) = \\xi + \\alpha \\eta,\\quad y(\\xi,\\eta) = \\eta,\n$$\n其中 $\\alpha$ 是剪切参数。单元中心位于 $\\xi_i = (i + 0.5) \\Delta \\xi$ 和 $\\eta_j = (j + 0.5) \\Delta \\eta$，其中 $\\Delta \\xi = 1/N_x$ 和 $\\Delta \\eta = 1/N_y$。内部垂直面位于 $\\xi_{f} = (i+1) \\Delta \\xi$ 和 $\\eta_{f} = \\eta_j$，而内部水平面位于 $\\xi_f = \\xi_i$ 和 $\\eta_f = (j+1) \\Delta \\eta$。\n- 对于垂直面，面切线为 $\\partial \\boldsymbol{r} / \\partial \\eta = (\\alpha,1)$，得出单位法向量\n$$\n\\boldsymbol{n}_v = \\frac{(1,-\\alpha)}{\\sqrt{1+\\alpha^2}},\\quad \\boldsymbol{d}_v = (\\Delta \\xi, 0),\\quad \\beta_v = \\boldsymbol{n}_v \\cdot \\hat{\\boldsymbol{d}}_v = \\frac{1}{\\sqrt{1+\\alpha^2}}.\n$$\n对于水平面，面切线为 $\\partial \\boldsymbol{r} / \\partial \\xi = (1,0)$，得出单位法向量\n$$\n\\boldsymbol{n}_h = (0,1),\\quad \\boldsymbol{d}_h = (\\alpha \\Delta \\eta, \\Delta \\eta),\\quad \\beta_h = \\boldsymbol{n}_h \\cdot \\hat{\\boldsymbol{d}}_h = \\frac{1}{\\sqrt{1+\\alpha^2}}.\n$$\n因此，垂直面和水平面共享相同的 $\\beta = 1/\\sqrt{1+\\alpha^2}$，而 $\\lvert \\boldsymbol{d}_v \\rvert = \\Delta \\xi$ 和 $\\lvert \\boldsymbol{d}_h \\rvert = \\Delta \\eta \\sqrt{1+\\alpha^2}$。\n\n参考与未修正的面法向梯度：\n- 参考（完全修正）：$g_{\\text{ref},f} = \\nabla p(x_f,y_f) \\cdot \\boldsymbol{n}_f$。\n- 未修正（仅正交）：$g_{\\text{orth},f} = \\beta_f \\, \\Delta p / \\lvert \\boldsymbol{d} \\rvert$。\n- 相应的无量纲面法向速度为 $u_{\\text{ref},f} = -g_{\\text{ref},f}$ 和 $u_{\\text{uncorr},f} = -g_{\\text{orth},f}$。\n\n误差和棋盘格振荡幅值定义：\n- 平均绝对误差 (MAE) 是在所有内部面（包括垂直和水平面）上 $\\lvert u_{\\text{uncorr},f} - u_{\\text{ref},f} \\rvert$ 的平均值。\n- 棋盘格振荡幅值是沿一维内部面序列定义的，其值为最高频率离散傅里叶分量（交替模式）的量级。对于沿一条线的一系列面速度误差 $\\{e_m\\}_{m=0}^{M-1}$，其幅值为\n$$\nA = \\left\\lvert \\frac{1}{M} \\sum_{m=0}^{M-1} e_m (-1)^m \\right\\rvert.\n$$\n计算沿中心行垂直面和中心列水平面的 $A$ 值，并报告两者中的最大值。\n\n测试套件和压力场：\n使用以下无量纲测试套件参数集和压力场 $p(x,y)$，及其解析梯度 $\\nabla p(x,y)$：\n- 案例 1：$N_x = 32$，$N_y = 32$，$\\alpha = 0.3$，$p_1(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$，$\\nabla p_1 = (2\\pi \\cos(2\\pi x)\\sin(2\\pi y),\\; 2\\pi \\sin(2\\pi x)\\cos(2\\pi y))$。\n- 案例 2：$N_x = 32$，$N_y = 32$，$\\alpha = 0.0$，$p_2(x,y) = x + 2y$，$\\nabla p_2 = (1,\\;2)$。\n- 案例 3：$N_x = 32$，$N_y = 32$，$\\alpha = 1.0$，$p_1(x,y)$ 如上。\n- 案例 4：$N_x = 8$，$N_y = 8$，$\\alpha = 0.5$，$p_3(x,y) = x^2 + y^2$，$\\nabla p_3 = (2x,\\;2y)$。\n- 案例 5：$N_x = 8$，$N_y = 8$，$\\alpha = 0.0$，$p_3(x,y)$ 如上。\n\n计算要求：\n- 对于每个案例，构建网格，计算所有内部面的 $u_{\\text{ref},f}$ 和 $u_{\\text{uncorr},f}$，然后计算定义的 MAE 和棋盘格振荡幅值 $A$。\n- 所有量均为无量纲；不需要物理单位。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的列表，包含五个双元素列表，每个内部列表为对应测试案例的 $[\\text{MAE},\\text{Amplitude}]$，不含空格，例如：\n[[mae1,amp1],[mae2,amp2],[mae3,amp3],[mae4,amp4],[mae5,amp5]]",
            "solution": "问题陈述已经过验证，被认为是合理的。它提出了一个在计算流体力学领域中定义明确、有科学依据的数值实验，特别是关于非正交网格上的有限体积法。所有必要的参数、定义和控制方程都已提供，不存在会妨碍唯一解的矛盾或模糊之处。该问题是一个标准练习，用于分析在忽略非正交修正时与压力梯度项相关的离散化误差。\n\n任务是计算二维非正交网格上面法向速度的平均绝对误差 (MAE) 和棋盘格振荡幅值。该误差源于使用简化的压力梯度正交近似，而非完整、几何上正确的公式。该分析针对涉及不同网格参数和解析压力场的几个测试案例进行。\n\n该方法的核心在于为计算网格的每个内部面 $f$ 计算两种版本的面法向速度 $u_f$。\n\n$1$. **网格与坐标系**：物理域 $(x,y)$ 是通过线性剪切映射从 $(\\xi,\\eta) \\in [0,1]^2$ 中的均匀计算网格生成的：\n$$\nx(\\xi,\\eta) = \\xi + \\alpha \\eta, \\quad y(\\xi,\\eta) = \\eta\n$$\n其中 $\\alpha$ 是剪切参数。单元中心位于计算单元的中心，面中心位于计算单元之间的边界上。对于一个 $N_x \\times N_y$ 单元的网格，计算单元的尺寸为 $\\Delta \\xi = 1/N_x$ 和 $\\Delta \\eta = 1/N_y$。\n\n$2$. **参考面法向速度 ($u_{\\text{ref},f}$)**：这是从精确的解析压力场 $p(x,y)$ 推导出的“真实”速度。它是通过将在物理面中心 $(x_f, y_f)$ 处计算的解析压力梯度 $\\nabla p$ 投影到面的单位法向量 $\\boldsymbol{n}_f$ 上来计算的。\n$$\nu_{\\text{ref},f} = -\\nabla p(x_f, y_f) \\cdot \\boldsymbol{n}_f\n$$\n垂直面 ($\\boldsymbol{n}_v$) 和水平面 ($\\boldsymbol{n}_h$) 的单位法向量分别给出为 $\\boldsymbol{n}_v = (1, -\\alpha)/\\sqrt{1+\\alpha^2}$ 和 $\\boldsymbol{n}_h = (0, 1)$。\n\n$3$. **未修正的面法向速度 ($u_{\\text{uncorr},f}$)**：此速度使用有限体积求解器中常见的正交近似计算。它仅使用共享面的两个单元之间的压力差 $\\Delta p$（沿连接其中心的线投影）来近似法向压力梯度。\n$$\nu_{\\text{uncorr},f} = -g_{\\text{orth},f} = -\\beta_f \\frac{\\Delta p}{|\\boldsymbol{d}|}\n$$\n这里，$\\Delta p$ 是相邻单元中心之间的压力差（例如，对于东面是 $p_E - p_P$），$|\\boldsymbol{d}|$ 是这些单元中心之间的距离，而 $\\beta_f = \\boldsymbol{n}_f \\cdot \\hat{\\boldsymbol{d}}$ 是面法向量 $\\boldsymbol{n}_f$ 与连接单元中心的单位向量 $\\hat{\\boldsymbol{d}}$ 之间夹角的余弦值。问题提供了必要的几何因子：对于两种类型的面，$\\beta_f = 1/\\sqrt{1+\\alpha^2}$；对于垂直面，$|\\boldsymbol{d}_v| = \\Delta \\xi$；对于水平面，$|\\boldsymbol{d}_h| = \\Delta \\eta \\sqrt{1+\\alpha^2}$。\n\n$4$. **误差量化**：\n   - **平均绝对误差 (MAE)**：单个面的误差为 $e_f = u_{\\text{uncorr},f} - u_{\\text{ref},f}$。MAE 是此误差绝对值 $|e_f|$ 在网格所有内部面（包括垂直和水平面）上的平均值。\n   $$\n   \\text{MAE} = \\frac{1}{N_{\\text{faces}}} \\sum_{f} |u_{\\text{uncorr},f} - u_{\\text{ref},f}|\n   $$\n   - **棋盘格振荡幅值 ($A$)**: 该度量标准量化了误差场中的高频、单元间振荡，这种现象被称为棋盘格振荡，而 Rhie-Chow 插值正是为了抑制这种现象而设计的。对于沿网格线的一系列面误差 $\\{e_m\\}_{m=0}^{M-1}$，其幅值是在奈奎斯特频率处归一化离散傅里叶分量的量级：\n   $$\n   A = \\left\\lvert \\frac{1}{M} \\sum_{m=0}^{M-1} e_m (-1)^m \\right\\rvert\n   $$\n   此幅值是为两个序列计算的：沿中心水平网格线的垂直面上的误差，以及沿中心垂直网格线的水平面上的误差。报告这两个幅值中的最大值。\n\n通过迭代每个测试案例来实现解决方案。对于每个案例，我们构建网格，遍历所有内部面，计算 $u_{\\text{ref},f}$ 和 $u_{\\text{uncorr},f}$，并存储产生的误差 $e_f$。最后，从收集到的误差中计算 MAE 和最大棋盘格振荡幅值 $A$。该过程是确定性的，并为每个定义的案例产生唯一的数值结果。网格为正交 ($\\alpha=0$) 且压力场为线性或二次的特殊情况可作为解析校验，因为正交近似误差应为零，从而验证了实现。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational thermal engineering problem for all specified test cases.\n    \"\"\"\n\n    def p1(x, y):\n        return np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)\n\n    def grad_p1(x, y):\n        val_x = 2 * np.pi * np.cos(2 * np.pi * x) * np.sin(2 * np.pi * y)\n        val_y = 2 * np.pi * np.sin(2 * np.pi * x) * np.cos(2 * np.pi * y)\n        return np.array([val_x, val_y])\n\n    def p2(x, y):\n        return x + 2 * y\n\n    def grad_p2(x, y):\n        return np.array([1.0, 2.0])\n\n    def p3(x, y):\n        return x**2 + y**2\n\n    def grad_p3(x, y):\n        return np.array([2 * x, 2 * y])\n\n    test_cases = [\n        {'Nx': 32, 'Ny': 32, 'alpha': 0.3, 'p_func': p1, 'grad_p_func': grad_p1},\n        {'Nx': 32, 'Ny': 32, 'alpha': 0.0, 'p_func': p2, 'grad_p_func': grad_p2},\n        {'Nx': 32, 'Ny': 32, 'alpha': 1.0, 'p_func': p1, 'grad_p_func': grad_p1},\n        {'Nx': 8, 'Ny': 8, 'alpha': 0.5, 'p_func': p3, 'grad_p_func': grad_p3},\n        {'Nx': 8, 'Ny': 8, 'alpha': 0.0, 'p_func': p3, 'grad_p_func': grad_p3},\n    ]\n\n    def compute_metrics_for_case(Nx, Ny, alpha, p_func, grad_p_func):\n        \"\"\"\n        Computes MAE and checkerboarding amplitude for a single case.\n        \"\"\"\n        delta_xi = 1.0 / Nx\n        delta_eta = 1.0 / Ny\n\n        def map_coords(xi, eta):\n            return xi + alpha * eta, eta\n\n        total_error_sum = 0.0\n        num_faces = 0\n\n        vert_errors_central_row = []\n        horiz_errors_central_col = []\n        \n        # Geometric factors\n        sqrt_1_alpha_sq = np.sqrt(1 + alpha**2)\n        beta = 1.0 / sqrt_1_alpha_sq\n        n_v = np.array([1.0, -alpha]) / sqrt_1_alpha_sq\n        n_h = np.array([0.0, 1.0])\n        d_v_mag = delta_xi\n        d_h_mag = delta_eta * sqrt_1_alpha_sq\n\n        central_row_j_idx = Ny // 2\n        central_col_i_idx = Nx // 2\n\n        # Loop over interior vertical faces\n        for j in range(Ny):\n            for i in range(Nx - 1):\n                eta_j_center = (j + 0.5) * delta_eta\n                xi_p_center = (i + 0.5) * delta_xi\n                xi_e_center = (i + 1.5) * delta_xi\n                xi_f = (i + 1.0) * delta_xi\n\n                x_p, y_p = map_coords(xi_p_center, eta_j_center)\n                x_e, y_e = map_coords(xi_e_center, eta_j_center)\n                x_f, y_f = map_coords(xi_f, eta_j_center)\n\n                delta_p = p_func(x_e, y_e) - p_func(x_p, y_p)\n                \n                g_orth = beta * delta_p / d_v_mag\n                g_ref = np.dot(grad_p_func(x_f, y_f), n_v)\n\n                error = g_ref - g_orth  # e_u = u_uncorr - u_ref = -g_orth - (-g_ref) = g_ref - g_orth\n                total_error_sum += np.abs(error)\n                num_faces += 1\n                \n                if j == central_row_j_idx:\n                    vert_errors_central_row.append(error)\n\n        # Loop over interior horizontal faces\n        for j in range(Ny - 1):\n            for i in range(Nx):\n                xi_i_center = (i + 0.5) * delta_xi\n                eta_p_center = (j + 0.5) * delta_eta\n                eta_n_center = (j + 1.5) * delta_eta\n                eta_f = (j + 1.0) * delta_eta\n\n                x_p, y_p = map_coords(xi_i_center, eta_p_center)\n                x_n, y_n = map_coords(xi_i_center, eta_n_center)\n                x_f, y_f = map_coords(xi_i_center, eta_f)\n\n                delta_p = p_func(x_n, y_n) - p_func(x_p, y_p)\n                \n                g_orth = beta * delta_p / d_h_mag\n                g_ref = np.dot(grad_p_func(x_f, y_f), n_h)\n\n                error = g_ref - g_orth\n                total_error_sum += np.abs(error)\n                num_faces += 1\n                \n                if i == central_col_i_idx:\n                    horiz_errors_central_col.append(error)\n\n        mae = total_error_sum / num_faces if num_faces > 0 else 0.0\n\n        # Calculate checkerboarding amplitude\n        e_v = np.array(vert_errors_central_row)\n        M_v = len(e_v)\n        amp_v = 0.0\n        if M_v > 0:\n            alternating_v = (-1.0)**np.arange(M_v)\n            amp_v = np.abs(np.sum(e_v * alternating_v) / M_v)\n\n        e_h = np.array(horiz_errors_central_col)\n        M_h = len(e_h)\n        amp_h = 0.0\n        if M_h > 0:\n            alternating_h = (-1.0)**np.arange(M_h)\n            amp_h = np.abs(np.sum(e_h * alternating_h) / M_h)\n            \n        amplitude = max(amp_v, amp_h)\n        \n        return [mae, amplitude]\n\n    results = []\n    for case in test_cases:\n        result = compute_metrics_for_case(**case)\n        results.append(result)\n    \n    # Format output to match the required specification '[[mae1,amp1],[mae2,amp2],...]'\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        }
    ]
}