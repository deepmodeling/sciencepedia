{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any robust finite volume solver on complex meshes lies in the accurate computation of geometric properties. This first exercise grounds your understanding by tasking you with calculating the essential geometric quantities for a single, non-planar quadrilateral face—the fundamental building block for general polyhedral grids. Mastering these vector calculus-based computations is the first step toward implementing accurate flux discretizations. ",
            "id": "3999805",
            "problem": "Consider steady heat conduction modeled by Fourier’s law, where the diffusive heat flux density across a face is proportional to the temperature gradient projected along the face’s outward unit normal. In the Finite Volume Method (FVM), on non-orthogonal grids, the primary diffusion contribution between two neighboring control volumes is built from the projection of the centroid-to-centroid vector onto the face unit normal, which requires robust geometric definitions of the face centroid and face normal for general polyhedral cells.\n\nA single quadrilateral face separates two neighboring cells with centroids $P$ and $N$. The face vertices are given in counterclockwise order by the position vectors $\\boldsymbol{r}_1$, $\\boldsymbol{r}_2$, $\\boldsymbol{r}_3$, and $\\boldsymbol{r}_4$ in three-dimensional space. The vertex coordinates and cell centroids are:\n- $\\boldsymbol{r}_1 = (\\,0.100,\\, 0.000,\\, 0.020\\,)$ m,\n- $\\boldsymbol{r}_2 = (\\,0.180,\\, 0.040,\\, 0.030\\,)$ m,\n- $\\boldsymbol{r}_3 = (\\,0.160,\\, 0.120,\\, 0.010\\,)$ m,\n- $\\boldsymbol{r}_4 = (\\,0.080,\\, 0.080,\\, 0.000\\,)$ m,\n- $\\boldsymbol{r}_P = (\\,0.120,\\, 0.050,\\, 0.010\\,)$ m,\n- $\\boldsymbol{r}_N = (\\,0.140,\\, 0.090,\\, 0.020\\,)$ m.\n\nStarting from first principles of vector calculus and geometry, and without assuming planarity beyond the local triangular decompositions, do the following:\n- Construct the face centroid $\\boldsymbol{r}_f$ by decomposing the quadrilateral into two triangles $(\\boldsymbol{r}_1,\\boldsymbol{r}_2,\\boldsymbol{r}_3)$ and $(\\boldsymbol{r}_1,\\boldsymbol{r}_3,\\boldsymbol{r}_4)$ and performing an area-weighted average of the triangle centroids.\n- Construct the face area vector by summing the triangle area vectors, and define the unit face normal $\\boldsymbol{n}_f$ by normalizing this area vector. Choose the orientation of $\\boldsymbol{n}_f$ such that $(\\boldsymbol{r}_N - \\boldsymbol{r}_P)\\cdot \\boldsymbol{n}_f \\ge 0$.\n- Using these geometric constructs, derive and compute the orthogonal distance $d_{\\perp}$ as the projection of $(\\boldsymbol{r}_N - \\boldsymbol{r}_P)$ onto $\\boldsymbol{n}_f$.\n\nReport only the final value of $d_{\\perp}$. Express your answer in meters and round to four significant figures.",
            "solution": "The user-provided problem has been validated and is determined to be a valid, well-posed problem in computational geometry, relevant to the field of computational thermal engineering. All necessary data are provided, the constraints are consistent, and the problem is grounded in established scientific and mathematical principles.\n\nThe solution proceeds by following the steps outlined in the problem statement. All coordinates are given in meters.\n\nFirst, we define the given position vectors for the vertices of the quadrilateral face and the centroids of the neighboring cells, $P$ and $N$:\n$\\boldsymbol{r}_1 = \\begin{pmatrix} 0.100 \\\\ 0.000 \\\\ 0.020 \\end{pmatrix}$, $\\boldsymbol{r}_2 = \\begin{pmatrix} 0.180 \\\\ 0.040 \\\\ 0.030 \\end{pmatrix}$, $\\boldsymbol{r}_3 = \\begin{pmatrix} 0.160 \\\\ 0.120 \\\\ 0.010 \\end{pmatrix}$, $\\boldsymbol{r}_4 = \\begin{pmatrix} 0.080 \\\\ 0.080 \\\\ 0.000 \\end{pmatrix}$\n$\\boldsymbol{r}_P = \\begin{pmatrix} 0.120 \\\\ 0.050 \\\\ 0.010 \\end{pmatrix}$, $\\boldsymbol{r}_N = \\begin{pmatrix} 0.140 \\\\ 0.090 \\\\ 0.020 \\end{pmatrix}$\n\nThe first task is to construct the face centroid $\\boldsymbol{r}_f$ by decomposing the quadrilateral into two triangles, $T_A = (\\boldsymbol{r}_1, \\boldsymbol{r}_2, \\boldsymbol{r}_3)$ and $T_B = (\\boldsymbol{r}_1, \\boldsymbol{r}_3, \\boldsymbol{r}_4)$.\n\nFor triangle $T_A$, we calculate its centroid, area vector, and scalar area.\nThe centroid $\\boldsymbol{c}_A$ is the arithmetic mean of its vertices:\n$$ \\boldsymbol{c}_A = \\frac{1}{3}(\\boldsymbol{r}_1 + \\boldsymbol{r}_2 + \\boldsymbol{r}_3) = \\frac{1}{3}\\begin{pmatrix} 0.100+0.180+0.160 \\\\ 0.000+0.040+0.120 \\\\ 0.020+0.030+0.010 \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} 0.440 \\\\ 0.160 \\\\ 0.060 \\end{pmatrix} $$\nThe area vector $\\boldsymbol{A}_A$ is calculated using the cross product of two edge vectors:\n$$ \\boldsymbol{r}_2 - \\boldsymbol{r}_1 = \\begin{pmatrix} 0.080 \\\\ 0.040 \\\\ 0.010 \\end{pmatrix}, \\quad \\boldsymbol{r}_3 - \\boldsymbol{r}_1 = \\begin{pmatrix} 0.060 \\\\ 0.120 \\\\ -0.010 \\end{pmatrix} $$\n$$ \\boldsymbol{A}_A = \\frac{1}{2} [(\\boldsymbol{r}_2 - \\boldsymbol{r}_1) \\times (\\boldsymbol{r}_3 - \\boldsymbol{r}_1)] = \\frac{1}{2} \\begin{pmatrix} (0.040)(-0.010) - (0.010)(0.120) \\\\ (0.010)(0.060) - (0.080)(-0.010) \\\\ (0.080)(0.120) - (0.040)(0.060) \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} = \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} $$\nThe scalar area $A_A$ is the magnitude of $\\boldsymbol{A}_A$:\n$$ A_A = |\\boldsymbol{A}_A| = \\sqrt{(-0.0008)^2 + (0.0007)^2 + (0.0036)^2} = \\sqrt{1.409 \\times 10^{-5}} \\approx 0.003753665 \\text{ m}^2 $$\n\nFor triangle $T_B$, we perform analogous calculations.\nThe centroid $\\boldsymbol{c}_B$ is:\n$$ \\boldsymbol{c}_B = \\frac{1}{3}(\\boldsymbol{r}_1 + \\boldsymbol{r}_3 + \\boldsymbol{r}_4) = \\frac{1}{3}\\begin{pmatrix} 0.100+0.160+0.080 \\\\ 0.000+0.120+0.080 \\\\ 0.020+0.010+0.000 \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} 0.340 \\\\ 0.200 \\\\ 0.030 \\end{pmatrix} $$\nThe area vector $\\boldsymbol{A}_B$ is:\n$$ \\boldsymbol{r}_3 - \\boldsymbol{r}_1 = \\begin{pmatrix} 0.060 \\\\ 0.120 \\\\ -0.010 \\end{pmatrix}, \\quad \\boldsymbol{r}_4 - \\boldsymbol{r}_1 = \\begin{pmatrix} -0.020 \\\\ 0.080 \\\\ -0.020 \\end{pmatrix} $$\n$$ \\boldsymbol{A}_B = \\frac{1}{2} [(\\boldsymbol{r}_3 - \\boldsymbol{r}_1) \\times (\\boldsymbol{r}_4 - \\boldsymbol{r}_1)] = \\frac{1}{2} \\begin{pmatrix} (0.120)(-0.020) - (-0.010)(0.080) \\\\ (-0.010)(-0.020) - (0.060)(-0.020) \\\\ (0.060)(0.080) - (0.120)(-0.020) \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} = \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} $$\nThe scalar area $A_B$ is the magnitude of $\\boldsymbol{A}_B$:\n$$ A_B = |\\boldsymbol{A}_B| = \\sqrt{(-0.0008)^2 + (0.0007)^2 + (0.0036)^2} = \\sqrt{1.409 \\times 10^{-5}} \\approx 0.003753665 \\text{ m}^2 $$\nThe face centroid $\\boldsymbol{r}_f$ is the area-weighted average of the triangle centroids:\n$$ \\boldsymbol{r}_f = \\frac{A_A \\boldsymbol{c}_A + A_B \\boldsymbol{c}_B}{A_A + A_B} $$\nSince $A_A = A_B$, this simplifies to the arithmetic mean of the centroids:\n$$ \\boldsymbol{r}_f = \\frac{1}{2}(\\boldsymbol{c}_A + \\boldsymbol{c}_B) = \\frac{1}{2} \\left[ \\frac{1}{3}\\begin{pmatrix} 0.440 \\\\ 0.160 \\\\ 0.060 \\end{pmatrix} + \\frac{1}{3}\\begin{pmatrix} 0.340 \\\\ 0.200 \\\\ 0.030 \\end{pmatrix} \\right] = \\frac{1}{6}\\begin{pmatrix} 0.780 \\\\ 0.360 \\\\ 0.090 \\end{pmatrix} = \\begin{pmatrix} 0.130 \\\\ 0.060 \\\\ 0.015 \\end{pmatrix} $$\n\nThe second task is to construct the face area vector and the unit face normal $\\boldsymbol{n}_f$.\nThe total face area vector $\\boldsymbol{A}_f$ is the sum of the triangle area vectors:\n$$ \\boldsymbol{A}_f = \\boldsymbol{A}_A + \\boldsymbol{A}_B = \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} + \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} = \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} $$\nThe magnitude of the face area vector is:\n$$ |\\boldsymbol{A}_f| = \\sqrt{(-0.0016)^2 + (0.0014)^2 + (0.0072)^2} = \\sqrt{2.56 \\times 10^{-6} + 1.96 \\times 10^{-6} + 51.84 \\times 10^{-6}} = \\sqrt{5.636 \\times 10^{-5}} $$\n$$ |\\boldsymbol{A}_f| \\approx 0.00750733 \\text{ m}^2 $$\nThe raw unit normal vector is $\\boldsymbol{n}_{f, \\text{raw}} = \\frac{\\boldsymbol{A}_f}{|\\boldsymbol{A}_f|}$.\nWe must ensure its orientation satisfies $(\\boldsymbol{r}_N - \\boldsymbol{r}_P)\\cdot \\boldsymbol{n}_f \\ge 0$. First, we compute the vector connecting the cell centroids:\n$$ \\boldsymbol{d} = \\boldsymbol{r}_N - \\boldsymbol{r}_P = \\begin{pmatrix} 0.140-0.120 \\\\ 0.090-0.050 \\\\ 0.020-0.010 \\end{pmatrix} = \\begin{pmatrix} 0.02 \\\\ 0.04 \\\\ 0.01 \\end{pmatrix} $$\nNext, we check the sign of the dot product $\\boldsymbol{d} \\cdot \\boldsymbol{A}_f$:\n$$ \\boldsymbol{d} \\cdot \\boldsymbol{A}_f = (0.02)(-0.0016) + (0.04)(0.0014) + (0.01)(0.0072) = -0.000032 + 0.000056 + 0.000072 = 0.000096 $$\nSince this dot product is positive, the direction of $\\boldsymbol{A}_f$ is already consistent with the requirement. Thus, the final unit normal vector $\\boldsymbol{n}_f$ is:\n$$ \\boldsymbol{n}_f = \\frac{\\boldsymbol{A}_f}{|\\boldsymbol{A}_f|} = \\frac{1}{\\sqrt{5.636 \\times 10^{-5}}} \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} $$\n\nThe third task is to compute the orthogonal distance $d_{\\perp}$. This is defined as the projection of the centroid-to-centroid vector $\\boldsymbol{d} = \\boldsymbol{r}_N - \\boldsymbol{r}_P$ onto the unit face normal $\\boldsymbol{n}_f$. This projection is given by the dot product:\n$$ d_{\\perp} = (\\boldsymbol{r}_N - \\boldsymbol{r}_P) \\cdot \\boldsymbol{n}_f = \\boldsymbol{d} \\cdot \\frac{\\boldsymbol{A}_f}{|\\boldsymbol{A}_f|} = \\frac{\\boldsymbol{d} \\cdot \\boldsymbol{A}_f}{|\\boldsymbol{A}_f|} $$\nUsing the values computed previously:\n$$ d_{\\perp} = \\frac{0.000096}{\\sqrt{5.636 \\times 10^{-5}}} \\approx \\frac{0.000096}{0.00750733} \\approx 0.0127873 \\text{ m} $$\nRounding the result to four significant figures as requested:\n$$ d_{\\perp} \\approx 0.01279 \\text{ m} $$",
            "answer": "$$\\boxed{0.01279}$$"
        },
        {
            "introduction": "With a firm grasp of face geometry, we now investigate the direct consequences of non-orthogonality on numerical accuracy. This practice guides you through a numerical experiment to quantify the error of a basic two-point flux approximation on a series of progressively skewed meshes. By correlating the observed error with standard mesh skewness metrics, you will develop a quantitative intuition for how grid quality directly impacts solution fidelity. ",
            "id": "3999818",
            "problem": "Consider the steady, isotropic heat conduction equation with constant thermal conductivity, written as $-\\nabla \\cdot (k \\nabla T) = q$, with $k$ a positive constant. In a Finite Volume Method (FVM) discretization on a general two-dimensional mesh, the divergence of the diffusive flux over a control volume can be derived from the divergence theorem as the sum of normal fluxes across its faces. On non-orthogonal grids, the center-to-center vector between neighboring cells is generally not aligned with the face normal, which induces geometric errors if one uses a two-point approximation for the flux. This problem is concerned with quantifying such errors and relating them to standard skewness metrics.\n\nA family of skew meshes is constructed by applying an affine shear to a unit-square reference grid. Let the reference coordinates be $(x,y) \\in [0,1] \\times [0,1]$, with a structured partition of $N_x \\times N_y$ quadrilateral cells. Define the physical coordinates $(x',y')$ by the shear map\n$$\n\\begin{pmatrix} x' \\\\ y' \\end{pmatrix}\n=\n\\begin{pmatrix} 1 & \\alpha \\\\ 0 & 1 \\end{pmatrix}\n\\begin{pmatrix} x \\\\ y \\end{pmatrix}\n=\n\\begin{pmatrix} x + \\alpha y \\\\ y \\end{pmatrix},\n$$\nwhere $\\alpha$ is a real-valued skew parameter. The mapping is linear and area-preserving for any $\\alpha$.\n\nLet the benchmark temperature field be the manufactured solution\n$$\nT(x',y') = \\sin(\\pi x') \\sin(\\pi y'),\n$$\nand take $k = 1$ so that the exact Laplacian is\n$$\n\\nabla^2 T(x',y') = -2 \\pi^2 \\sin(\\pi x') \\sin(\\pi y').\n$$\nFor each interior cell, form a discrete approximation to the divergence of the diffusive flux using a two-point, center-to-center scheme on each face. For a face $f$ between a cell $P$ and a neighbor $N$, define the center-to-center vector $\\boldsymbol{r}_f = \\boldsymbol{x}_N - \\boldsymbol{x}_P$, its magnitude $|\\boldsymbol{r}_f|$, and unit vector $\\hat{\\boldsymbol{r}}_f = \\boldsymbol{r}_f / |\\boldsymbol{r}_f|$. Let the face edge vector be $\\boldsymbol{e}_f$ whose magnitude is the face length $L_f = \\|\\boldsymbol{e}_f\\|$, and let $\\hat{\\boldsymbol{n}}_f$ be the unit normal to the face, oriented such that $\\hat{\\boldsymbol{n}}_f \\cdot \\hat{\\boldsymbol{r}}_f \\ge 0$. The face area vector is then $\\boldsymbol{S}_f = L_f \\hat{\\boldsymbol{n}}_f$. The two-point normal flux across face $f$ is computed as\n$$\n\\Phi_f^{\\text{TP}} = \\left( \\frac{T_N - T_P}{|\\boldsymbol{r}_f|} \\right) \\left( \\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right),\n$$\nand the discrete divergence in cell $P$ is $\\sum_{f \\in \\partial P} \\Phi_f^{\\text{TP}} / A_P$, where $A_P$ is the physical cell area. At boundary faces, impose Dirichlet data by setting $T_N = T$ evaluated at the face center and taking $\\boldsymbol{r}_f$ from the cell center to the face center.\n\nDefine the per-cell error as\n$$\nE_P = \\frac{1}{A_P} \\sum_{f \\in \\partial P} \\Phi_f^{\\text{TP}} - \\nabla^2 T(\\boldsymbol{x}_P),\n$$\nand compute the discrete $L_2$ norm and the discrete $L_{\\infty}$ norm over all cells:\n$$\n\\|E\\|_{L_2} = \\sqrt{ \\sum_{P} A_P \\, E_P^2 }, \\qquad \\|E\\|_{L_{\\infty}} = \\max_{P} |E_P|.\n$$\nTo characterize non-orthogonality, use the following face-based skewness metrics. For each face $f$, define the misalignment angle\n$$\n\\theta_f = \\arccos\\!\\left( \\left| \\hat{\\boldsymbol{n}}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right| \\right),\n$$\nexpressed in radians, and the non-orthogonal correction vector\n$$\n\\boldsymbol{s}_f = \\boldsymbol{S}_f - \\left( \\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right) \\hat{\\boldsymbol{r}}_f,\n$$\nwith magnitude $\\|\\boldsymbol{s}_f\\| = L_f \\sin(\\theta_f)$. Over the entire mesh (including boundary faces), compute\n$$\n\\theta_{\\max} = \\max_f \\theta_f, \\qquad \\overline{\\|\\boldsymbol{s}\\|} = \\frac{1}{N_F} \\sum_{f} \\|\\boldsymbol{s}_f\\|,\n$$\nwhere $N_F$ is the total number of faces.\n\nYour task is to implement a program that, for a sequence of meshes generated by different $(N_x,N_y,\\alpha)$ triplets, computes the discrete $L_2$ and $L_{\\infty}$ norms of the error $E_P$, along with the skewness metrics $\\theta_{\\max}$ and $\\overline{\\|\\boldsymbol{s}\\|}$, and then correlates the error magnitude with the skewness metrics by reporting the Pearson correlation coefficients across the test suite between the vector of $\\|E\\|_{L_2}$ values and the vectors of $\\theta_{\\max}$ and $\\overline{\\|\\boldsymbol{s}\\|}$, respectively.\n\nAngle quantities must be reported in radians. All other quantities are dimensionless in this setup.\n\nImplement the program to evaluate the following test suite:\n- Case $1$: $(N_x,N_y,\\alpha) = (20,20,0.0)$.\n- Case $2$: $(N_x,N_y,\\alpha) = (20,20,0.2)$.\n- Case $3$: $(N_x,N_y,\\alpha) = (20,20,0.4)$.\n- Case $4$ (edge case with coarse resolution): $(N_x,N_y,\\alpha) = (4,4,0.3)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a sub-list with four floats $[\\|E\\|_{L_2}, \\|E\\|_{L_{\\infty}}, \\theta_{\\max}, \\overline{\\|\\boldsymbol{s}\\|}]$ in that order. After these sub-lists, append two additional floats: the Pearson correlation coefficient between the list of $\\|E\\|_{L_2}$ values and the list of $\\theta_{\\max}$ values across the four cases, and the Pearson correlation coefficient between the list of $\\|E\\|_{L_2}$ values and the list of $\\overline{\\|\\boldsymbol{s}\\|}$ values across the four cases. For example, the output format is\n$$\n\\big[ [e_{2,1}, e_{\\infty,1}, \\theta_{\\max,1}, \\overline{\\|s\\|}_1], [e_{2,2}, e_{\\infty,2}, \\theta_{\\max,2}, \\overline{\\|s\\|}_2], [e_{2,3}, e_{\\infty,3}, \\theta_{\\max,3}, \\overline{\\|s\\|}_3], [e_{2,4}, e_{\\infty,4}, \\theta_{\\max,4}, \\overline{\\|s\\|}_4], \\rho_{e_2,\\theta}, \\rho_{e_2,\\overline{s}} \\big],\n$$\nwhere each $e_{2,i}$ is $\\|E\\|_{L_2}$ for case $i$, each $e_{\\infty,i}$ is $\\|E\\|_{L_{\\infty}}$ for case $i$, and $\\rho_{e_2,\\theta}$ and $\\rho_{e_2,\\overline{s}}$ are the corresponding Pearson correlation coefficients. The program must generate the mesh, perform all computations, and print the single-line output exactly in this format, without any other text.",
            "solution": "The problem requires a critical analysis of the discretization error incurred by a two-point flux approximation (TPFA) scheme within a Finite Volume Method (FVM) framework for the steady-state heat conduction equation on non-orthogonal grids. The analysis will be performed by implementing the specified numerical scheme for a series of test cases and correlating the computed error against standard grid skewness metrics.\n\nThe governing partial differential equation is the Poisson equation, arising from steady, isotropic heat conduction with constant thermal conductivity $k$ and a heat source $q$:\n$$\n-\\nabla \\cdot (k \\nabla T) = q\n$$\nFor this problem, we are given $k=1$, so the equation simplifies to $-\\nabla^2 T = q$. The FVM is based on integrating this equation over a control volume $V_P$ (a cell in the mesh) and applying the divergence theorem:\n$$\n\\int_{V_P} -\\nabla \\cdot (\\nabla T) \\, dV = \\int_{V_P} q \\, dV\n$$\n$$\n-\\oint_{\\partial V_P} \\nabla T \\cdot d\\boldsymbol{S} = \\int_{V_P} q \\, dV\n$$\nThe left-hand side represents the net heat flux into the control volume through its boundary $\\partial V_P$. Discretizing this expression, the integral over the cell volume $V_P$ is approximated as $q_P A_P$, where $q_P$ is the source evaluation at the cell center $\\boldsymbol{x}_P$ and $A_P$ is the cell area (in 2D). The boundary integral is approximated by a sum of fluxes over the faces $f$ that constitute $\\partial V_P$:\n$$\n\\sum_{f \\in \\partial V_P} \\text{Flux}_f^{\\text{in}} \\approx q_P A_P\n$$\nThe problem is set up to analyze a specific, simple approximation for the flux. For a face $f$ separating cell $P$ from a neighboring cell $N$, the temperature gradient $\\nabla T$ is approximated along the line connecting the cell centers, $\\boldsymbol{r}_f = \\boldsymbol{x}_N - \\boldsymbolx_P$. This leads to the two-point approximation for the heat flux entering cell $P$ from neighbor $N$ across face $f$:\n$$\n\\Phi_f^{\\text{TP}} = \\left( \\frac{T_N - T_P}{|\\boldsymbol{r}_f|} \\right) \\left( \\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right)\n$$\nHere, $\\boldsymbol{S}_f$ is the face area vector (normal to the face, with magnitude equal to face length), and $\\hat{\\boldsymbol{r}}_f$ is the unit vector along the center-to-center line. This approximation is known to be accurate only when the grid is orthogonal, i.e., when $\\boldsymbol{r}_f$ is parallel to $\\boldsymbol{S}_f$. On non-orthogonal grids, where $\\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\neq |\\boldsymbol{S}_f|$, this formulation introduces a \"skewness error.\"\n\nTo quantify this error, we use the method of manufactured solutions. A smooth analytical function for the temperature field, $T(x',y') = \\sin(\\pi x') \\sin(\\pi y')$, is prescribed. The corresponding source term $q$ required to satisfy the governing equation is then calculated exactly:\n$$\nq = -\\nabla^2 T = -(-2\\pi^2 \\sin(\\pi x') \\sin(\\pi y')) = 2\\pi^2 T(x', y')\n$$\nThe discrete operator for the source term, derived from the FVM balance, is $(\\sum_{f} \\Phi_f^{\\text{TP}}) / A_P$. The problem defines the per-cell error $E_P$ as the difference between the action of the discrete operator and the analytical Laplacian operator, both evaluated using the manufactured solution:\n$$\nE_P = \\frac{1}{A_P} \\sum_{f \\in \\partial P} \\Phi_f^{\\text{TP}} - \\nabla^2 T(\\boldsymbol{x}_P)\n$$\nThis error $E_P$ represents the truncation error of the spatial discretization. We will quantify this error globally over the mesh using the discrete $L_2$ and $L_{\\infty}$ norms:\n$$\n\\|E\\|_{L_2} = \\sqrt{ \\sum_{P} A_P \\, E_P^2 }, \\qquad \\|E\\|_{L_{\\infty}} = \\max_{P} |E_P|\n$$\nThe geometric non-orthogonality is characterized by two metrics. For each face $f$, we compute the misalignment angle $\\theta_f$ between the face normal and the cell-center connection vector:\n$$\n\\theta_f = \\arccos\\!\\left( \\left| \\hat{\\boldsymbol{n}}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right| \\right) = \\arccos\\!\\left( \\frac{|\\boldsymbol{S}_f \\cdot \\boldsymbol{r}_f|}{\\|\\boldsymbol{S}_f\\| \\|\\boldsymbol{r}_f\\|} \\right)\n$$\nAnd the magnitude of the non-orthogonal correction vector $\\boldsymbol{s}_f$, which is the component of the face area vector $\\boldsymbol{S}_f$ that is orthogonal to $\\hat{\\boldsymbol{r}}_f$:\n$$\n\\|\\boldsymbol{s}_f\\| = \\|\\boldsymbol{S}_f\\| \\sin(\\theta_f)\n$$\nThese are aggregated into global mesh skewness metrics $\\theta_{\\max}$ (the maximum angle over all faces) and $\\overline{\\|\\boldsymbol{s}\\|}$ (the average magnitude of $\\boldsymbol{s}_f$ over all faces).\n\nThe implementation proceeds as follows:\n1.  For each test case defined by $(N_x, N_y, \\alpha)$, a structured grid is generated. First, a uniform Cartesian grid of $(N_x+1) \\times (N_y+1)$ nodes is created in the reference domain $[0,1] \\times [0,1]$. Then, the affine shear map $\\begin{pmatrix} x' \\\\ y' \\end{pmatrix} = \\begin{pmatrix} 1  \\alpha \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix}$ is applied to transform the node coordinates into the physical domain.\n2.  Geometric properties for all cells and faces are computed. Cell centers $\\boldsymbol{x}_P$ are calculated as the centroid of their four vertices. Cell areas $A_P$ are calculated using the shoelace formula. For each face, its length $L_f$, center, and area vector $\\boldsymbol{S}_f$ are determined.\n3.  A loop iterates over each cell $P$ in the grid. For each of its four faces, the corresponding neighbor $N$ is identified.\n4.  For each face, if it is an interior face, the neighbor is an adjacent cell. If it is a boundary face, the \"neighbor\" data is taken at the face center, consistent with the specified Dirichlet boundary condition treatment.\n5.  The vectors $\\boldsymbol{r}_f$ and $\\boldsymbol{S}_f$ are computed. The orientation of $\\boldsymbol{S}_f$ is algorithmically enforced to ensure $\\boldsymbol{S}_f \\cdot \\boldsymbol{r}_f \\ge 0$.\n6.  The flux contribution $\\Phi_f^{\\text{TP}}$ is calculated and added to a running sum for cell $P$. The face-based skewness metrics $\\theta_f$ and $\\|\\boldsymbol{s}_f\\|$ are also computed and stored, avoiding duplicate calculations for interior faces.\n7.  After processing all faces of a cell, the total flux sum is used to compute the cell error $E_P$.\n8.  Once all cells are processed, the global error norms $\\|E\\|_{L_2}$ and $\\|E\\|_{L_{\\infty}}$, and the global skewness metrics $\\theta_{\\max}$ and $\\overline{\\|\\boldsymbol{s}\\|}$, are calculated.\n9.  After completing all four test cases, the Pearson correlation coefficient is computed between the vector of $\\|E\\|_{L_2}$ values and the vectors of $\\theta_{\\max}$ and $\\overline{\\|\\boldsymbol{s}\\|}$ values, respectively. This quantifies the statistical relationship between the discretization error and grid non-orthogonality.\n\nThis procedure provides a complete and rigorous evaluation as demanded by the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        (20, 20, 0.0),\n        (20, 20, 0.2),\n        (20, 20, 0.4),\n        (4, 4, 0.3),\n    ]\n\n    case_results = []\n    e_l2_values = []\n    theta_max_values = []\n    s_bar_values = []\n\n    for Nx, Ny, alpha in test_cases:\n        e_l2, e_linf, theta_max, s_bar = compute_metrics(Nx, Ny, alpha)\n        case_results.append([e_l2, e_linf, theta_max, s_bar])\n        e_l2_values.append(e_l2)\n        theta_max_values.append(theta_max)\n        s_bar_values.append(s_bar)\n\n    # Compute correlation coefficients\n    rho_e2_theta = np.corrcoef(e_l2_values, theta_max_values)[0, 1]\n    rho_e2_s = np.corrcoef(e_l2_values, s_bar_values)[0, 1]\n\n    # Format the output string\n    result_str_parts = [f\"[{','.join(f'{val:.8e}' for val in res)}]\" for res in case_results]\n    full_result_str = f\"[{','.join(result_str_parts)},{rho_e2_theta:.8e},{rho_e2_s:.8e}]\"\n    \n    print(full_result_str)\n\ndef compute_metrics(Nx, Ny, alpha):\n    \"\"\"\n    Computes error and skewness metrics for a given mesh configuration.\n    \"\"\"\n    # Define manufactured solution and its Laplacian\n    T_func = lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y)\n    lap_T_func = lambda x, y: -2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    # 1. Generate mesh nodes in physical coordinates (x', y')\n    x_ref = np.linspace(0, 1, Nx + 1)\n    y_ref = np.linspace(0, 1, Ny + 1)\n    xx_ref, yy_ref = np.meshgrid(x_ref, y_ref, indexing='ij')\n\n    shear_map = np.array([[1, alpha], [0, 1]])\n    ref_coords = np.stack([xx_ref, yy_ref], axis=-1)\n    nodes = np.einsum('ij,klj-kli', shear_map, ref_coords)\n\n    # 2. Compute cell centers and areas\n    cell_centers = np.zeros((Nx, Ny, 2))\n    cell_areas = np.zeros((Nx, Ny))\n    for i in range(Nx):\n        for j in range(Ny):\n            v1 = nodes[i, j]\n            v2 = nodes[i + 1, j]\n            v3 = nodes[i + 1, j + 1]\n            v4 = nodes[i, j + 1]\n            cell_centers[i, j] = (v1 + v2 + v3 + v4) / 4.0\n            # Shoelace formula for area of a quadrilateral\n            area = 0.5 * abs(v1[0]*v2[1] - v1[1]*v2[0] + \n                             v2[0]*v3[1] - v2[1]*v3[0] + \n                             v3[0]*v4[1] - v3[1]*v4[0] + \n                             v4[0]*v1[1] - v4[1]*v1[0])\n            cell_areas[i, j] = area\n            \n    # 3. Main loop: Compute fluxes and skewness for each cell\n    cell_flux_sum = np.zeros((Nx, Ny))\n    face_thetas = []\n    face_s_mags = []\n    processed_faces = set()\n\n    for i in range(Nx):\n        for j in range(Ny):\n            P_center = cell_centers[i, j]\n            T_P = T_func(P_center[0], P_center[1])\n\n            # Neighbors: E, N, W, S\n            neighbors_info = [\n                ('E', i + 1, j, (i + 1, j), (i + 1, j + 1)), # N, P_face_node_idx1, P_face_node_idx2\n                ('N', i, j + 1, (i + 1, j + 1), (i, j + 1)),\n                ('W', i - 1, j, (i, j + 1), (i, j)),\n                ('S', i, j - 1, (i, j), (i + 1, j))\n            ]\n\n            for direction, ni, nj, v_idx1, v_idx2 in neighbors_info:\n                is_boundary = not (0 = ni  Nx and 0 = nj  Ny)\n                \n                v1 = nodes[v_idx1]\n                v2 = nodes[v_idx2]\n\n                # Face area vector S_f, oriented outwards from P\n                S_f = np.array([v2[1] - v1[1], -(v2[0] - v1[0])])\n                L_f = np.linalg.norm(S_f)\n\n                if is_boundary:\n                    face_center = (v1 + v2) / 2.0\n                    r_f = face_center - P_center\n                    T_N = T_func(face_center[0], face_center[1])\n                else:\n                    N_center = cell_centers[ni, nj]\n                    r_f = N_center - P_center\n                    T_N = T_func(N_center[0], N_center[1])\n\n                # Ensure S_f.r_f = 0 as per problem spec\n                if np.dot(S_f, r_f)  0:\n                    S_f = -S_f\n                \n                r_f_mag_sq = np.dot(r_f, r_f)\n                if r_f_mag_sq == 0:\n                    flux = 0\n                else:\n                    flux = (T_N - T_P) * np.dot(S_f, r_f) / r_f_mag_sq\n                \n                cell_flux_sum[i, j] += flux\n                \n                # Use a canonical representation of the face to avoid double counting\n                face_key = tuple(sorted((v_idx1, v_idx2)))\n                if face_key not in processed_faces:\n                    processed_faces.add(face_key)\n                    \n                    r_f_mag = np.sqrt(r_f_mag_sq)\n                    if L_f  1e-12 and r_f_mag  1e-12:\n                        cos_theta_abs = abs(np.dot(S_f, r_f)) / (L_f * r_f_mag)\n                        # Clamp due to potential floating point inaccuracies\n                        cos_theta_abs = min(1.0, max(-1.0, cos_theta_abs))\n                        theta_f = np.arccos(cos_theta_abs)\n                        s_mag = L_f * np.sin(theta_f)\n                        \n                        face_thetas.append(theta_f)\n                        face_s_mags.append(s_mag)\n\n    # 4. Compute error norms and aggregated skewness metrics\n    cell_errors = np.zeros((Nx, Ny))\n    for i in range(Nx):\n        for j in range(Ny):\n            P_center = cell_centers[i, j]\n            lap_T_P = lap_T_func(P_center[0], P_center[1])\n            discrete_lap = cell_flux_sum[i, j] / cell_areas[i, j]\n            cell_errors[i, j] = discrete_lap - lap_T_P\n            \n    e_l2 = np.sqrt(np.sum(cell_areas * cell_errors**2))\n    e_linf = np.max(np.abs(cell_errors))\n    \n    theta_max = np.max(face_thetas) if face_thetas else 0.0\n    s_bar = np.mean(face_s_mags) if face_s_mags else 0.0\n\n    return e_l2, e_linf, theta_max, s_bar\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Non-orthogonality is not only a feature of internal grid lines but is also an unavoidable consequence of approximating curved boundaries with planar faces. This final exercise explores this critical aspect of computational modeling, comparing the error from a simple planar-face flux calculation against a more sophisticated, higher-order method. This practice demonstrates the importance of boundary treatment and introduces the concept of using geometric corrections to recover accuracy. ",
            "id": "3999810",
            "problem": "Consider steady-state heat conduction without sources in a two-dimensional domain with a smooth curved boundary. Let the temperature field be harmonic and given by $T(r,\\theta) = T_{\\infty} + A\\,r^{m}\\cos(m\\theta)$, where $A$ is a real constant with units $\\mathrm{K}/\\mathrm{m}^{m}$, $m$ is a positive integer, and $(r,\\theta)$ are polar coordinates. The boundary of interest is a circle of radius $R$ (in $\\mathrm{m}$). The outward unit normal at the true boundary is $\\mathbf{n}_{\\text{true}} = \\mathbf{e}_{r}$. Thermal conductivity $k$ is constant and isotropic, with units $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$. By Fourier’s law, the true wall-normal heat flux density is $q_{\\text{true}} = -k\\,\\nabla T \\cdot \\mathbf{n}_{\\text{true}}$ at the true boundary location $(r,\\theta)=(R,\\theta_{0})$. Angles are to be treated in radians.\n\nIn a non-orthogonal finite-volume representation of the curved boundary, suppose one replaces the true boundary locally by a planar face (a chord of the circle) of chord length $c$ (in $\\mathrm{m}$) centered at the polar angle $\\theta_{0}$. The face centroid is at the radial offset $r_{p} = R - \\delta$ where the sagitta (geometric offset) $\\delta$ depends on $R$ and $c$ by the circle-chord relation $\\delta = R - \\sqrt{R^{2} - (c/2)^{2}}$. Due to non-orthogonality and face warp, the planar face’s unit normal $\\mathbf{n}_{p}$ is rotated by a warp angle $\\alpha$ (in radians) relative to $\\mathbf{n}_{\\text{true}}$, within the local $(\\mathbf{e}_{r},\\mathbf{e}_{t})$ plane, so that $\\mathbf{n}_{p}$ is obtained by rotating $\\mathbf{e}_{r}$ toward $\\mathbf{e}_{t}$ by $\\alpha$.\n\nDefine two approximations for the wall-normal heat flux density:\n\n- Planar-face flux approximation $q_{\\text{planar}}$: Evaluate $\\nabla T$ at the planar face centroid $(r,\\theta)=(r_{p},\\theta_{0})$ and project onto the planar face normal $\\mathbf{n}_{p}$, then apply Fourier’s law $q_{\\text{planar}} = -k\\,\\nabla T(r_{p},\\theta_{0})\\cdot \\mathbf{n}_{p}$.\n\n- Higher-order geometric approximation $q_{\\text{high}}$: Use a Taylor correction along the true normal to approximate the true-boundary normal derivative from values at the planar centroid. Specifically, approximate $\\partial T/\\partial r$ at $(r,\\theta)=(R,\\theta_{0})$ by a first-order Taylor expansion in the normal direction starting from $(r_{p},\\theta_{0})$, i.e., $\\left.\\partial T/\\partial r\\right|_{r=R,\\theta=\\theta_{0}} \\approx \\left.\\partial T/\\partial r\\right|_{r=r_{p},\\theta=\\theta_{0}} + \\delta\\,\\left.\\partial^{2}T/\\partial r^{2}\\right|_{r=r_{p},\\theta=\\theta_{0}}$, and then set $q_{\\text{high}} = -k$ times this approximation. Use $\\mathbf{n}_{\\text{true}}$ for $q_{\\text{high}}$.\n\nTasks:\n\n- From the fundamental base consisting of Fourier’s law of heat conduction $q_{n} = -k\\,\\nabla T\\cdot \\mathbf{n}$, the polar-coordinate gradient identity for scalar fields, and the harmonicity of $T(r,\\theta) = A\\,r^{m}\\cos(m\\theta)$, derive explicit expressions for $q_{\\text{true}}$, $q_{\\text{planar}}$, and $q_{\\text{high}}$ in terms of $k$, $A$, $m$, $R$, $\\theta_{0}$, $c$, and $\\alpha$. The polar angle unit must be radians. Express heat flux density in $\\mathrm{W}/\\mathrm{m}^{2}$.\n\n- Define the absolute errors $e_{\\text{planar}} = |q_{\\text{planar}} - q_{\\text{true}}|$ and $e_{\\text{high}} = |q_{\\text{high}} - q_{\\text{true}}|$, and show how these errors depend on the face warp angle $\\alpha$ and the mesh resolution via the chord length $c$ through the sagitta $\\delta$.\n\n- Implement a program that computes $[e_{\\text{planar}}, e_{\\text{high}}]$ for each of the following test cases, and prints the results as a single line: a comma-separated list of pairs enclosed in square brackets, where each pair is itself a two-element list $[e_{\\text{planar}}, e_{\\text{high}}]$. All heat flux density errors must be reported in $\\mathrm{W}/\\mathrm{m}^{2}$ and rounded to $10$ decimal places. Use $T_{\\infty} = 0$ for all cases.\n\nTest suite (angles in radians, lengths in $\\mathrm{m}$, conductivity in $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$):\n\n- Case $1$ (general non-orthogonal, moderate resolution): $R = 1.0$, $k = 10.0$, $A = 1.0$, $m = 3$, $\\theta_{0} = 0.4$, $c = 0.2$, $\\alpha = 0.1$.\n\n- Case $2$ (refined resolution, same warp): $R = 1.0$, $k = 10.0$, $A = 1.0$, $m = 3$, $\\theta_{0} = 0.4$, $c = 0.05$, $\\alpha = 0.1$.\n\n- Case $3$ (no warp, same resolution as Case $1$): $R = 1.0$, $k = 10.0$, $A = 1.0$, $m = 3$, $\\theta_{0} = 0.4$, $c = 0.2$, $\\alpha = 0.0$.\n\n- Case $4$ (vanishing true normal flux, tangential-gradient sensitivity): $R = 1.0$, $k = 10.0$, $A = 1.0$, $m = 3$, $\\theta_{0} = \\pi/(2m)$, $c = 0.2$, $\\alpha = 0.1$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list of pairs enclosed in square brackets, for example, $[[e_{\\text{planar},1}, e_{\\text{high},1}],[e_{\\text{planar},2}, e_{\\text{high},2}],\\dots]$, with each value rounded to $10$ decimal places and in $\\mathrm{W}/\\mathrm{m}^{2}$.",
            "solution": "The problem statement has been critically validated and is deemed to be self-contained, scientifically grounded, and well-posed. It presents a standard exercise in the analysis of numerical errors for boundary condition implementation in computional fluid dynamics and heat transfer. We may therefore proceed with the derivation and solution.\n\nThe core of the problem is to derive expressions for the true and approximate wall-normal heat fluxes and analyze the resulting errors. This requires applying Fourier's law of heat conduction, $q = -k\\,\\nabla T \\cdot \\mathbf{n}$, using vector calculus in polar coordinates.\n\nThe specified temperature field is $T(r,\\theta) = T_{\\infty} + A\\,r^{m}\\cos(m\\theta)$. As all calculations involve gradients of $T$, the constant $T_{\\infty}$ can be set to $0$ without loss of generality, as specified for the test cases. Thus, we use $T(r,\\theta) = A\\,r^{m}\\cos(m\\theta)$.\n\nThe gradient of a scalar field $T$ in polar coordinates $(r, \\theta)$ is given by:\n$$ \\nabla T = \\frac{\\partial T}{\\partial r}\\mathbf{e}_{r} + \\frac{1}{r}\\frac{\\partial T}{\\partial \\theta}\\mathbf{e}_{t} $$\nwhere $\\mathbf{e}_{r}$ and $\\mathbf{e}_{t}$ are the unit vectors in the radial and tangential directions, respectively.\n\nFirst, we compute the necessary partial derivatives of the temperature field:\n$$ \\frac{\\partial T}{\\partial r} = \\frac{\\partial}{\\partial r} \\left( A\\,r^{m}\\cos(m\\theta) \\right) = Am\\,r^{m-1}\\cos(m\\theta) $$\n$$ \\frac{\\partial T}{\\partial \\theta} = \\frac{\\partial}{\\partial \\theta} \\left( A\\,r^{m}\\cos(m\\theta) \\right) = -Am\\,r^{m}\\sin(m\\theta) $$\nThe second-order radial derivative, required for the higher-order approximation, is:\n$$ \\frac{\\partial^{2}T}{\\partial r^{2}} = \\frac{\\partial}{\\partial r} \\left( Am\\,r^{m-1}\\cos(m\\theta) \\right) = Am(m-1)r^{m-2}\\cos(m\\theta) $$\n\nThe gradient vector is therefore:\n$$ \\nabla T(r,\\theta) = Am\\,r^{m-1}\\cos(m\\theta)\\,\\mathbf{e}_{r} - Am\\,r^{m-1}\\sin(m\\theta)\\,\\mathbf{e}_{t} $$\n\nWith these expressions, we can derive the three heat flux quantities.\n\n**1. True Wall-Normal Heat Flux, $q_{\\text{true}}$**\nThis is defined at the true boundary location $(r, \\theta) = (R, \\theta_{0})$ using the true outward normal $\\mathbf{n}_{\\text{true}} = \\mathbf{e}_{r}$.\n$$ q_{\\text{true}} = -k\\,\\nabla T(R, \\theta_{0}) \\cdot \\mathbf{n}_{\\text{true}} $$\n$$ q_{\\text{true}} = -k \\left( Am\\,R^{m-1}\\cos(m\\theta_0)\\,\\mathbf{e}_{r} - Am\\,R^{m-1}\\sin(m\\theta_0)\\,\\mathbf{e}_{t} \\right) \\cdot \\mathbf{e}_{r} $$\nSince $\\mathbf{e}_{r} \\cdot \\mathbf{e}_{r} = 1$ and $\\mathbf{e}_{t} \\cdot \\mathbf{e}_{r} = 0$, the expression simplifies to:\n$$ q_{\\text{true}} = -kAm\\,R^{m-1}\\cos(m\\theta_0) $$\n\n**2. Planar-Face Flux Approximation, $q_{\\text{planar}}$**\nThis approximation is evaluated at the planar face centroid $(r_p, \\theta_0)$, where $r_p = \\sqrt{R^2 - (c/2)^2}$. The flux is projected onto the planar face normal, $\\mathbf{n}_{p}$. The normal $\\mathbf{n}_{p}$ is rotated by the warp angle $\\alpha$ from $\\mathbf{e}_{r}$ towards $\\mathbf{e}_{t}$, so $\\mathbf{n}_{p} = \\cos(\\alpha)\\mathbf{e}_{r} + \\sin(\\alpha)\\mathbf{e}_{t}$.\n$$ q_{\\text{planar}} = -k\\,\\nabla T(r_{p}, \\theta_{0}) \\cdot \\mathbf{n}_{p} $$\n$$ q_{\\text{planar}} = -k \\left( Am\\,r_p^{m-1}\\cos(m\\theta_0)\\,\\mathbf{e}_{r} - Am\\,r_p^{m-1}\\sin(m\\theta_0)\\,\\mathbf{e}_{t} \\right) \\cdot \\left( \\cos(\\alpha)\\mathbf{e}_{r} + \\sin(\\alpha)\\mathbf{e}_{t} \\right) $$\nPerforming the dot product:\n$$ q_{\\text{planar}} = -k Am\\,r_p^{m-1} \\left( \\cos(m\\theta_0)\\cos(\\alpha) - \\sin(m\\theta_0)\\sin(\\alpha) \\right) $$\nUsing the trigonometric identity for the cosine of a sum of angles, $\\cos(x+y) = \\cos(x)\\cos(y) - \\sin(x)\\sin(y)$:\n$$ q_{\\text{planar}} = -kAm\\,r_p^{m-1}\\cos(m\\theta_0 + \\alpha) $$\nwhere $r_p = R - (R - \\sqrt{R^2 - (c/2)^2})$.\n\n**3. Higher-Order Geometric Approximation, $q_{\\text{high}}$**\nThis approximation uses a first-order Taylor series expansion to estimate the radial derivative at the true boundary $r=R$ from values at the face centroid $r=r_p$:\n$$ \\left.\\frac{\\partial T}{\\partial r}\\right|_{R, \\theta_0} \\approx \\left.\\frac{\\partial T}{\\partial r}\\right|_{r_p, \\theta_0} + \\delta\\,\\left.\\frac{\\partial^{2}T}{\\partial r^{2}}\\right|_{r_p, \\theta_0} $$\nThe flux is then $q_{\\text{high}} = -k$ times this approximate derivative.\nSubstituting our expressions for the derivatives evaluated at $(r_p, \\theta_0)$:\n$$ q_{\\text{high}} = -k \\left( Am\\,r_p^{m-1}\\cos(m\\theta_0) + \\delta \\cdot Am(m-1)r_p^{m-2}\\cos(m\\theta_0) \\right) $$\nFactoring out common terms:\n$$ q_{\\text{high}} = -kAm\\cos(m\\theta_0) \\left( r_p^{m-1} + \\delta(m-1)r_p^{m-2} \\right) $$\n\n**4. Error Analysis**\nThe absolute errors are $e_{\\text{planar}} = |q_{\\text{planar}} - q_{\\text{true}}|$ and $e_{\\text{high}} = |q_{\\text{high}} - q_{\\text{true}}|$.\n\nFor small chord length $c$, the sagitta $\\delta = R - \\sqrt{R^2 - c^2/4} \\approx R(1 - (1 - c^2/(8R^2))) = c^2/(8R)$, so $\\delta = O(c^2)$.\nThe error $e_{\\text{planar}}$ arises from two sources: the geometric displacement $\\delta$ and the non-orthogonality $\\alpha$.\nA Taylor expansion of $q_{\\text{planar}}$ for small $\\delta$ and $\\alpha$ shows that the error $e_{\\text{planar}}$ is, to leading order, a linear combination of terms proportional to $\\delta$ and $\\alpha$.\n$$ e_{\\text{planar}} \\approx |kAm| \\left| R^{m-1} \\left( \\alpha \\sin(m\\theta_0) + \\frac{(m-1)\\delta}{R} \\cos(m\\theta_0) \\right) \\right| + O(\\delta^2, \\alpha^2, \\alpha\\delta) $$\nThus, the error is first-order in the warp angle $\\alpha$ and second-order in the mesh size $c$ (since $\\delta \\propto c^2$).\n\nThe error $e_{\\text{high}}$ arises because the Taylor series used to approximate the derivative is truncated. The approximation for $\\left.\\frac{\\partial T}{\\partial r}\\right|_{R}$ is $f(R-\\delta) + \\delta f'(R-\\delta)$, where $f(r) = \\left.\\frac{\\partial T}{\\partial r}\\right|_{\\theta_0}$. The true value is $f(R)$. The Taylor series error is known to be $\\frac{\\delta^2}{2} f''(R-\\delta) + O(\\delta^3)$. This means the error in the derivative is $O(\\delta^2)$.\n$$ e_{\\text{high}} = |q_{\\text{high}} - q_{\\text{true}}| \\approx \\left| -k \\left( \\frac{\\delta^2}{2} \\left.\\frac{\\partial^3 T}{\\partial r^3}\\right|_{R, \\theta_0} \\right) \\right| $$\nSince $\\delta \\propto c^2$, the error $e_{\\text{high}}$ is proportional to $\\delta^2$, which means $e_{\\text{high}} = O(c^4)$. This approximation is fourth-order accurate in mesh size and is not directly affected by the warp angle $\\alpha$, as it explicitly computes an approximation for the derivative along the true normal direction.\n\nThe following program implements these derived formulas to compute the errors for the specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates and prints the errors for planar and higher-order heat flux\n    approximations at a curved boundary for a set of test cases.\n    \"\"\"\n    \n    # Test suite (angles in radians, lengths in m, conductivity in W/(m.K)):\n    test_cases = [\n        # Case 1 (general non-orthogonal, moderate resolution)\n        {'R': 1.0, 'k': 10.0, 'A': 1.0, 'm': 3, 'theta0': 0.4, 'c': 0.2, 'alpha': 0.1},\n        # Case 2 (refined resolution, same warp)\n        {'R': 1.0, 'k': 10.0, 'A': 1.0, 'm': 3, 'theta0': 0.4, 'c': 0.05, 'alpha': 0.1},\n        # Case 3 (no warp, same resolution as Case 1)\n        {'R': 1.0, 'k': 10.0, 'A': 1.0, 'm': 3, 'theta0': 0.4, 'c': 0.2, 'alpha': 0.0},\n        # Case 4 (vanishing true normal flux, tangential-gradient sensitivity)\n        {'R': 1.0, 'k': 10.0, 'A': 1.0, 'm': 3, 'theta0': np.pi / (2 * 3), 'c': 0.2, 'alpha': 0.1},\n    ]\n\n    results_str_list = []\n    \n    for case in test_cases:\n        R = case['R']\n        k = case['k']\n        A = case['A']\n        m = case['m']\n        theta0 = case['theta0']\n        c = case['c']\n        alpha = case['alpha']\n\n        # Ensure m is treated as an integer for powers and derivatives\n        m = int(m)\n\n        # 1. Calculate true wall-normal heat flux (q_true)\n        q_true = -k * A * m * (R**(m-1)) * np.cos(m * theta0)\n\n        # 2. Calculate planar-face flux approximation (q_planar)\n        # Geometric quantities for the planar face\n        delta = R - np.sqrt(R**2 - (c / 2)**2)\n        r_p = R - delta\n        \n        q_planar = -k * A * m * (r_p**(m-1)) * np.cos(m * theta0 + alpha)\n\n        # 3. Calculate higher-order geometric approximation (q_high)\n        # Handle the case where m=1, as the second derivative is zero\n        if m == 1:\n            d2T_dr2_rp = 0\n        else:\n            d2T_dr2_rp = A * m * (m - 1) * (r_p**(m - 2)) * np.cos(m * theta0)\n\n        dT_dr_rp = A * m * (r_p**(m-1)) * np.cos(m * theta0)\n        \n        approx_dT_dr = dT_dr_rp + delta * d2T_dr2_rp\n        q_high = -k * approx_dT_dr\n\n        # 4. Calculate absolute errors\n        e_planar = abs(q_planar - q_true)\n        e_high = abs(q_high - q_true)\n\n        # 5. Format results as specified: rounded to 10 decimal places\n        e_planar_rounded = round(e_planar, 10)\n        e_high_rounded = round(e_high, 10)\n        \n        # Format numbers to always show 10 decimal places\n        e_planar_str = f\"{e_planar_rounded:.10f}\"\n        e_high_str = f\"{e_high_rounded:.10f}\"\n        \n        results_str_list.append(f\"[{e_planar_str},{e_high_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```"
        }
    ]
}