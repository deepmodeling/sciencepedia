{
    "hands_on_practices": [
        {
            "introduction": "在非结构或非正交网格上应用有限体积法时，准确计算控制体面的几何属性是实现精确数值模拟的首要步骤。此练习将引导您运用基础矢量微积分，为一个非平面的四边形网格面计算其几何中心、法向量以及相邻单元中心的正交距离。通过这项实践，您将掌握在复杂几何形状上构建数值格式所必需的基本功，为后续更复杂的非正交修正打下坚实基础 。",
            "id": "3999805",
            "problem": "考虑由傅里叶定律(Fourier's law)建模的稳态热传导，其中穿过一个面的扩散热通量密度与沿该面外单位法线方向投影的温度梯度成正比。在有限体积法（FVM）中，对于非正交网格，两个相邻控制体之间的主要扩散贡献是由形心到形心向量在面单位法线上的投影构成的，这需要对通用多面体单元的面心和面法线有鲁棒的几何定义。\n\n一个四边形面分隔了两个相邻的单元，其形心分别为 $P$ 和 $N$。该面的顶点在三维空间中由位置向量 $\\boldsymbol{r}_1$、$\\boldsymbol{r}_2$、$\\boldsymbol{r}_3$ 和 $\\boldsymbol{r}_4$ 以逆时针顺序给出。顶点坐标和单元形心如下：\n- $\\boldsymbol{r}_1 = (\\,0.100,\\, 0.000,\\, 0.020\\,)$ m,\n- $\\boldsymbol{r}_2 = (\\,0.180,\\, 0.040,\\, 0.030\\,)$ m,\n- $\\boldsymbol{r}_3 = (\\,0.160,\\, 0.120,\\, 0.010\\,)$ m,\n- $\\boldsymbol{r}_4 = (\\,0.080,\\, 0.080,\\, 0.000\\,)$ m,\n- $\\boldsymbol{r}_P = (\\,0.120,\\, 0.050,\\, 0.010\\,)$ m,\n- $\\boldsymbol{r}_N = (\\,0.140,\\, 0.090,\\, 0.020\\,)$ m。\n\n从向量微积分和几何学的基本原理出发，并且除了局部的三角形分解外不假设面的平坦性，完成以下操作：\n- 通过将四边形分解为两个三角形 $(\\boldsymbol{r}_1,\\boldsymbol{r}_2,\\boldsymbol{r}_3)$ 和 $(\\boldsymbol{r}_1,\\boldsymbol{r}_3,\\boldsymbol{r}_4)$，并对三角形的形心进行面积加权平均，来构建面心 $\\boldsymbol{r}_f$。\n- 通过对三角形面积向量求和来构建面面积向量，并通过将此面积向量归一化来定义单位面法线 $\\boldsymbol{n}_f$。选择 $\\boldsymbol{n}_f$ 的方向，以使其满足 $(\\boldsymbol{r}_N - \\boldsymbol{r}_P)\\cdot \\boldsymbol{n}_f \\ge 0$。\n- 使用这些几何构造，推导并计算正交距离 $d_{\\perp}$，其为 $(\\boldsymbol{r}_N - \\boldsymbol{r}_P)$ 在 $\\boldsymbol{n}_f$ 上的投影。\n\n只报告 $d_{\\perp}$ 的最终值。答案以米为单位，并四舍五入到四位有效数字。",
            "solution": "用户提供的问题已经过验证，并被确定为计算几何领域中一个有效、适定的问题，与计算热工领域相关。所有必要的数据均已提供，约束条件一致，且问题基于既定的科学和数学原理。\n\n解题过程遵循问题陈述中概述的步骤。所有坐标均以米为单位。\n\n首先，我们定义四边形面顶点以及相邻单元 $P$ 和 $N$ 的形心的给定位置向量：\n$\\boldsymbol{r}_1 = \\begin{pmatrix} 0.100 \\\\ 0.000 \\\\ 0.020 \\end{pmatrix}$, $\\boldsymbol{r}_2 = \\begin{pmatrix} 0.180 \\\\ 0.040 \\\\ 0.030 \\end{pmatrix}$, $\\boldsymbol{r}_3 = \\begin{pmatrix} 0.160 \\\\ 0.120 \\\\ 0.010 \\end{pmatrix}$, $\\boldsymbol{r}_4 = \\begin{pmatrix} 0.080 \\\\ 0.080 \\\\ 0.000 \\end{pmatrix}$\n$\\boldsymbol{r}_P = \\begin{pmatrix} 0.120 \\\\ 0.050 \\\\ 0.010 \\end{pmatrix}$, $\\boldsymbol{r}_N = \\begin{pmatrix} 0.140 \\\\ 0.090 \\\\ 0.020 \\end{pmatrix}$\n\n第一个任务是通过将四边形分解为两个三角形 $T_A = (\\boldsymbol{r}_1, \\boldsymbol{r}_2, \\boldsymbol{r}_3)$ 和 $T_B = (\\boldsymbol{r}_1, \\boldsymbol{r}_3, \\boldsymbol{r}_4)$ 来构建面心 $\\boldsymbol{r}_f$。\n\n对于三角形 $T_A$，我们计算其形心、面积向量和标量面积。\n形心 $\\boldsymbol{c}_A$ 是其顶点的算术平均值：\n$$ \\boldsymbol{c}_A = \\frac{1}{3}(\\boldsymbol{r}_1 + \\boldsymbol{r}_2 + \\boldsymbol{r}_3) = \\frac{1}{3}\\begin{pmatrix} 0.100+0.180+0.160 \\\\ 0.000+0.040+0.120 \\\\ 0.020+0.030+0.010 \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} 0.440 \\\\ 0.160 \\\\ 0.060 \\end{pmatrix} $$\n面积向量 $\\boldsymbol{A}_A$ 是通过两个边向量的叉积计算得出的：\n$$ \\boldsymbol{r}_2 - \\boldsymbol{r}_1 = \\begin{pmatrix} 0.080 \\\\ 0.040 \\\\ 0.010 \\end{pmatrix}, \\quad \\boldsymbol{r}_3 - \\boldsymbol{r}_1 = \\begin{pmatrix} 0.060 \\\\ 0.120 \\\\ -0.010 \\end{pmatrix} $$\n$$ \\boldsymbol{A}_A = \\frac{1}{2} [(\\boldsymbol{r}_2 - \\boldsymbol{r}_1) \\times (\\boldsymbol{r}_3 - \\boldsymbol{r}_1)] = \\frac{1}{2} \\begin{pmatrix} (0.040)(-0.010) - (0.010)(0.120) \\\\ (0.010)(0.060) - (0.080)(-0.010) \\\\ (0.080)(0.120) - (0.040)(0.060) \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} = \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} $$\n标量面积 $A_A$ 是 $\\boldsymbol{A}_A$ 的模：\n$$ A_A = |\\boldsymbol{A}_A| = \\sqrt{(-0.0008)^2 + (0.0007)^2 + (0.0036)^2} = \\sqrt{1.409 \\times 10^{-5}} \\approx 0.003753665 \\text{ m}^2 $$\n\n对于三角形 $T_B$，我们进行类似的计算。\n形心 $\\boldsymbol{c}_B$ 为：\n$$ \\boldsymbol{c}_B = \\frac{1}{3}(\\boldsymbol{r}_1 + \\boldsymbol{r}_3 + \\boldsymbol{r}_4) = \\frac{1}{3}\\begin{pmatrix} 0.100+0.160+0.080 \\\\ 0.000+0.120+0.080 \\\\ 0.020+0.010+0.000 \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} 0.340 \\\\ 0.200 \\\\ 0.030 \\end{pmatrix} $$\n面积向量 $\\boldsymbol{A}_B$ 为：\n$$ \\boldsymbol{r}_3 - \\boldsymbol{r}_1 = \\begin{pmatrix} 0.060 \\\\ 0.120 \\\\ -0.010 \\end{pmatrix}, \\quad \\boldsymbol{r}_4 - \\boldsymbol{r}_1 = \\begin{pmatrix} -0.020 \\\\ 0.080 \\\\ -0.020 \\end{pmatrix} $$\n$$ \\boldsymbol{A}_B = \\frac{1}{2} [(\\boldsymbol{r}_3 - \\boldsymbol{r}_1) \\times (\\boldsymbol{r}_4 - \\boldsymbol{r}_1)] = \\frac{1}{2} \\begin{pmatrix} (0.120)(-0.020) - (-0.010)(0.080) \\\\ (-0.010)(-0.020) - (0.060)(-0.020) \\\\ (0.060)(0.080) - (0.120)(-0.020) \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} = \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} $$\n标量面积 $A_B$ 是 $\\boldsymbol{A}_B$ 的模：\n$$ A_B = |\\boldsymbol{A}_B| = \\sqrt{(-0.0008)^2 + (0.0007)^2 + (0.0036)^2} = \\sqrt{1.409 \\times 10^{-5}} \\approx 0.003753665 \\text{ m}^2 $$\n面心 $\\boldsymbol{r}_f$ 是三角形形心的面积加权平均值：\n$$ \\boldsymbol{r}_f = \\frac{A_A \\boldsymbol{c}_A + A_B \\boldsymbol{c}_B}{A_A + A_B} $$\n由于 $A_A = A_B$，这简化为形心的算术平均值：\n$$ \\boldsymbol{r}_f = \\frac{1}{2}(\\boldsymbol{c}_A + \\boldsymbol{c}_B) = \\frac{1}{2} \\left[ \\frac{1}{3}\\begin{pmatrix} 0.440 \\\\ 0.160 \\\\ 0.060 \\end{pmatrix} + \\frac{1}{3}\\begin{pmatrix} 0.340 \\\\ 0.200 \\\\ 0.030 \\end{pmatrix} \\right] = \\frac{1}{6}\\begin{pmatrix} 0.780 \\\\ 0.360 \\\\ 0.090 \\end{pmatrix} = \\begin{pmatrix} 0.130 \\\\ 0.060 \\\\ 0.015 \\end{pmatrix} $$\n\n第二个任务是构建面面积向量和单位面法线 $\\boldsymbol{n}_f$。\n总面面积向量 $\\boldsymbol{A}_f$ 是三角形面积向量之和：\n$$ \\boldsymbol{A}_f = \\boldsymbol{A}_A + \\boldsymbol{A}_B = \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} + \\begin{pmatrix} -0.0008 \\\\ 0.0007 \\\\ 0.0036 \\end{pmatrix} = \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} $$\n面面积向量的模为：\n$$ |\\boldsymbol{A}_f| = \\sqrt{(-0.0016)^2 + (0.0014)^2 + (0.0072)^2} = \\sqrt{2.56 \\times 10^{-6} + 1.96 \\times 10^{-6} + 51.84 \\times 10^{-6}} = \\sqrt{5.636 \\times 10^{-5}} $$\n$$ |\\boldsymbol{A}_f| \\approx 0.00750733 \\text{ m}^2 $$\n原始单位法向量为 $\\boldsymbol{n}_{f, \\text{raw}} = \\frac{\\boldsymbol{A}_f}{|\\boldsymbol{A}_f|}$。\n我们必须确保其方向满足 $(\\boldsymbol{r}_N - \\boldsymbol{r}_P)\\cdot \\boldsymbol{n}_f \\ge 0$。首先，我们计算连接单元形心的向量：\n$$ \\boldsymbol{d} = \\boldsymbol{r}_N - \\boldsymbol{r}_P = \\begin{pmatrix} 0.140-0.120 \\\\ 0.090-0.050 \\\\ 0.020-0.010 \\end{pmatrix} = \\begin{pmatrix} 0.02 \\\\ 0.04 \\\\ 0.01 \\end{pmatrix} $$\n接下来，我们检查点积 $\\boldsymbol{d} \\cdot \\boldsymbol{A}_f$ 的符号：\n$$ \\boldsymbol{d} \\cdot \\boldsymbol{A}_f = (0.02)(-0.0016) + (0.04)(0.0014) + (0.01)(0.0072) = -0.000032 + 0.000056 + 0.000072 = 0.000096 $$\n由于该点积为正，$\\boldsymbol{A}_f$ 的方向已经满足要求。因此，最终的单位法向量 $\\boldsymbol{n}_f$ 为：\n$$ \\boldsymbol{n}_f = \\frac{\\boldsymbol{A}_f}{|\\boldsymbol{A}_f|} = \\frac{1}{\\sqrt{5.636 \\times 10^{-5}}} \\begin{pmatrix} -0.0016 \\\\ 0.0014 \\\\ 0.0072 \\end{pmatrix} $$\n\n第三个任务是计算正交距离 $d_{\\perp}$。它被定义为形心到形心向量 $\\boldsymbol{d} = \\boldsymbol{r}_N - \\boldsymbol{r}_P$ 在单位面法线 $\\boldsymbol{n}_f$ 上的投影。该投影由点积给出：\n$$ d_{\\perp} = (\\boldsymbol{r}_N - \\boldsymbol{r}_P) \\cdot \\boldsymbol{n}_f = \\boldsymbol{d} \\cdot \\frac{\\boldsymbol{A}_f}{|\\boldsymbol{A}_f|} = \\frac{\\boldsymbol{d} \\cdot \\boldsymbol{A}_f}{|\\boldsymbol{A}_f|} $$\n使用前面计算出的值：\n$$ d_{\\perp} = \\frac{0.000096}{\\sqrt{5.636 \\times 10^{-5}}} \\approx \\frac{0.000096}{0.00750733} \\approx 0.0127873 \\text{ m} $$\n按要求将结果四舍五入到四位有效数字：\n$$ d_{\\perp} \\approx 0.01279 \\text{ m} $$",
            "answer": "$$\\boxed{0.01279}$$"
        },
        {
            "introduction": "在非正交网格上，最简单的两点通量近似（TPFA）方案会因几何失准而引入显著的离散误差。本练习采用“人造解方法”（Method of Manufactured Solutions），让您亲手实现一个数值实验，以量化这种误差并探究其与网格质量的关系。通过计算误差与网格偏斜度指标之间的相关性，您将深刻理解几何非正交性是如何直接影响并降低数值解的精度，从而体会到非正交修正的必要性 。",
            "id": "3999818",
            "problem": "考虑具有恒定热导率的稳态、各向同性热传导方程，写作 $-\\nabla \\cdot (k \\nabla T) = q$，其中 $k$ 为一个正常数。在通用二维网格上进行有限体积法 (FVM) 离散时，根据散度定理，一个控制体上扩散通量的散度可以推导为其各个面上的法向通量之和。在非正交网格上，相邻单元之间的中心到中心向量通常与面法线不对齐，如果使用两点近似来计算通量，这会引入几何误差。本问题旨在量化此类误差，并将其与标准的网格偏斜度度量联系起来。\n\n通过对一个单位正方形参考网格应用仿射剪切，可以构建一系列偏斜网格。设参考坐标为 $(x,y) \\in [0,1] \\times [0,1]$，其上有一个 $N_x \\times N_y$ 个四边形单元的结构化剖分。通过剪切映射定义物理坐标 $(x',y')$：\n$$\n\\begin{pmatrix} x' \\\\ y' \\end{pmatrix}\n=\n\\begin{pmatrix} 1  \\alpha \\\\ 0  1 \\end{pmatrix}\n\\begin{pmatrix} x \\\\ y \\end{pmatrix}\n=\n\\begin{pmatrix} x + \\alpha y \\\\ y \\end{pmatrix},\n$$\n其中 $\\alpha$ 是一个实值偏斜参数。对于任意 $\\alpha$，该映射都是线性的且保持面积。\n\n设基准温度场为以下人工解：\n$$\nT(x',y') = \\sin(\\pi x') \\sin(\\pi y'),\n$$\n并取 $k = 1$，则精确的拉普拉斯算子为：\n$$\n\\nabla^2 T(x',y') = -2 \\pi^2 \\sin(\\pi x') \\sin(\\pi y').\n$$\n对于每个内部单元，在其每个面上使用两点、中心到中心的格式，构建扩散通量散度的离散近似。对于单元 $P$ 与其相邻单元 $N$ 之间的一个面 $f$，定义中心到中心向量 $\\boldsymbol{r}_f = \\boldsymbol{x}_N - \\boldsymbol{x}_P$、其大小 $|\\boldsymbol{r}_f|$ 和单位向量 $\\hat{\\boldsymbol{r}}_f = \\boldsymbol{r}_f / |\\boldsymbol{r}_f|$。设面边向量为 $\\boldsymbol{e}_f$，其大小为面长度 $L_f = \\|\\boldsymbol{e}_f\\|$；设 $\\hat{\\boldsymbol{n}}_f$ 为面的单位法向量，其方向的选取使得 $\\hat{\\boldsymbol{n}}_f \\cdot \\hat{\\boldsymbol{r}}_f \\ge 0$。则面面积向量为 $\\boldsymbol{S}_f = L_f \\hat{\\boldsymbol{n}}_f$。穿过面 $f$ 的两点法向通量计算如下：\n$$\n\\Phi_f^{\\text{TP}} = \\left( \\frac{T_N - T_P}{|\\boldsymbol{r}_f|} \\right) \\left( \\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right),\n$$\n单元 $P$ 中的离散散度为 $\\sum_{f \\in \\partial P} \\Phi_f^{\\text{TP}} / A_P$，其中 $A_P$ 是物理单元面积。在边界面上，通过将 $T_N$ 设置为在面中心处求值的温度 $T$，并将 $\\boldsymbol{r}_f$ 取为从单元中心到面中心的向量来施加狄利克雷数据。\n\n定义每个单元的误差为：\n$$\nE_P = \\frac{1}{A_P} \\sum_{f \\in \\partial P} \\Phi_f^{\\text{TP}} - \\nabla^2 T(\\boldsymbol{x}_P),\n$$\n并计算所有单元上的离散 $L_2$ 范数和离散 $L_{\\infty}$ 范数：\n$$\n\\|E\\|_{L_2} = \\sqrt{ \\sum_{P} A_P \\, E_P^2 }, \\qquad \\|E\\|_{L_{\\infty}} = \\max_{P} |E_P|.\n$$\n为了表征非正交性，使用以下基于面的偏斜度度量。对于每个面 $f$，定义未对齐角：\n$$\n\\theta_f = \\arccos\\!\\left( \\left| \\hat{\\boldsymbol{n}}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right| \\right),\n$$\n以弧度表示，以及非正交修正向量：\n$$\n\\boldsymbol{s}_f = \\boldsymbol{S}_f - \\left( \\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right) \\hat{\\boldsymbol{r}}_f,\n$$\n其大小为 $\\|\\boldsymbol{s}_f\\| = L_f \\sin(\\theta_f)$。在整个网格（包括边界面）上，计算：\n$$\n\\theta_{\\max} = \\max_f \\theta_f, \\qquad \\overline{\\|\\boldsymbol{s}\\|} = \\frac{1}{N_F} \\sum_{f} \\|\\boldsymbol{s}_f\\|,\n$$\n其中 $N_F$ 是面的总数。\n\n您的任务是实现一个程序，对于由不同的 $(N_x,N_y,\\alpha)$ 三元组生成的一系列网格，计算误差 $E_P$ 的离散 $L_2$ 和 $L_{\\infty}$ 范数，以及偏斜度度量 $\\theta_{\\max}$ 和 $\\overline{\\|\\boldsymbol{s}\\|}$。然后，通过报告测试套件中 $\\|E\\|_{L_2}$ 值向量与 $\\theta_{\\max}$ 和 $\\overline{\\|\\boldsymbol{s}\\|}$ 值向量之间的皮尔逊相关系数，将误差大小与偏斜度度量进行关联。\n\n角度量必须以弧度报告。在此设置中，所有其他量均为无量纲。\n\n实现该程序以评估以下测试套件：\n- 案例 1：$(N_x,N_y,\\alpha) = (20,20,0.0)$。\n- 案例 2：$(N_x,N_y,\\alpha) = (20,20,0.2)$。\n- 案例 3：$(N_x,N_y,\\alpha) = (20,20,0.4)$。\n- 案例 4（分辨率较粗的边缘案例）：$(N_x,N_y,\\alpha) = (4,4,0.3)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试案例贡献一个包含四个浮点数 $[\\|E\\|_{L_2}, \\|E\\|_{L_{\\infty}}, \\theta_{\\max}, \\overline{\\|\\boldsymbol{s}\\|}]$ 的子列表，顺序如此。在这些子列表之后，追加两个额外的浮点数：四个案例中 $\\|E\\|_{L_2}$ 值列表与 $\\theta_{\\max}$ 值列表之间的皮尔逊相关系数，以及四个案例中 $\\|E\\|_{L_2}$ 值列表与 $\\overline{\\|\\boldsymbol{s}\\|}$ 值列表之间的皮尔逊相关系数。例如，输出格式为：\n$$\n\\big[ [e_{2,1}, e_{\\infty,1}, \\theta_{\\max,1}, \\overline{\\|s\\|}_1], [e_{2,2}, e_{\\infty,2}, \\theta_{\\max,2}, \\overline{\\|s\\|}_2], [e_{2,3}, e_{\\infty,3}, \\theta_{\\max,3}, \\overline{\\|s\\|}_3], [e_{2,4}, e_{\\infty,4}, \\theta_{\\max,4}, \\overline{\\|s\\|}_4], \\rho_{e_2,\\theta}, \\rho_{e_2,\\overline{s}} \\big],\n$$\n其中，每个 $e_{2,i}$ 是案例 $i$ 的 $\\|E\\|_{L_2}$，每个 $e_{\\infty,i}$ 是案例 $i$ 的 $\\|E\\|_{L_{\\infty}}$，而 $\\rho_{e_2,\\theta}$ 和 $\\rho_{e_2,\\overline{s}}$ 是相应的皮尔逊相关系数。程序必须生成网格，执行所有计算，并完全按照这种格式打印单行输出，不得包含任何其他文本。",
            "solution": "该问题要求在有限体积法 (FVM) 框架内，针对非正交网格上的稳态热传导方程，对两点通量近似 (TPFA) 格式所产生的离散误差进行深入分析。该分析将通过为一系列测试案例实现指定的数值格式，并将计算出的误差与标准网格偏斜度度量进行关联来完成。\n\n控制偏微分方程为泊松方程，它源于具有恒定热导率 $k$ 和热源 $q$ 的稳态、各向同性热传导：\n$$\n-\\nabla \\cdot (k \\nabla T) = q\n$$\n对于本问题，给定 $k=1$，因此方程简化为 $-\\nabla^2 T = q$。有限体积法基于将此方程在一个控制体 $V_P$（网格中的一个单元）上进行积分，并应用散度定理：\n$$\n\\int_{V_P} -\\nabla \\cdot (\\nabla T) \\, dV = \\int_{V_P} q \\, dV\n$$\n$$\n-\\oint_{\\partial V_P} \\nabla T \\cdot d\\boldsymbol{S} = \\int_{V_P} q \\, dV\n$$\n左手边表示通过其边界 $\\partial V_P$流入控制体的净热通量。将此表达式离散化，在单元体积 $V_P$ 上的积分近似为 $q_P A_P$，其中 $q_P$ 是在单元中心 $\\boldsymbol{x}_P$ 处求值的源项，$A_P$ 是单元面积（在二维情况下）。边界积分通过对构成 $\\partial V_P$ 的各个面 $f$ 上的通量求和来近似：\n$$\n\\sum_{f \\in \\partial V_P} \\text{Flux}_f^{\\text{in}} \\approx q_P A_P\n$$\n该问题的设置是为了分析一种特定、简单的通量近似方法。对于分隔单元 $P$ 与其相邻单元 $N$ 的一个面 $f$，温度梯度 $\\nabla T$ 沿着连接单元中心的直线 $\\boldsymbol{r}_f = \\boldsymbol{x}_N - \\boldsymbol{x}_P$ 进行近似。这得到了从相邻单元 $N$ 穿过面 $f$ 进入单元 $P$ 的热通量的两点近似：\n$$\n\\Phi_f^{\\text{TP}} = \\left( \\frac{T_N - T_P}{|\\boldsymbol{r}_f|} \\right) \\left( \\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right)\n$$\n此处，$\\boldsymbol{S}_f$ 是面面积向量（垂直于该面，大小等于面长度），$\\hat{\\boldsymbol{r}}_f$ 是沿中心到中心线的单位向量。众所周知，这种近似仅在网格正交时（即 $\\boldsymbol{r}_f$ 与 $\\boldsymbol{S}_f$ 平行时）才是精确的。在非正交网格上，当 $\\boldsymbol{S}_f \\cdot \\hat{\\boldsymbol{r}}_f \\neq |\\boldsymbol{S}_f|$ 时，该公式会引入“偏斜误差”。\n\n为量化此误差，我们使用人工解方法。指定一个光滑的温度场解析函数 $T(x',y') = \\sin(\\pi x') \\sin(\\pi y')$。然后，为满足控制方程所需的相应源项 $q$ 可以被精确计算：\n$$\nq = -\\nabla^2 T = -(-2\\pi^2 \\sin(\\pi x') \\sin(\\pi y')) = 2\\pi^2 T(x', y')\n$$\n从 FVM 平衡推导出的源项离散算子为 $(\\sum_{f} \\Phi_f^{\\text{TP}}) / A_P$。问题将每个单元的误差 $E_P$ 定义为离散算子的作用与解析拉普拉斯算子作用之间的差值，两者都使用人工解进行求值：\n$$\nE_P = \\frac{1}{A_P} \\sum_{f \\in \\partial P} \\Phi_f^{\\text{TP}} - \\nabla^2 T(\\boldsymbol{x}_P)\n$$\n此误差 $E_P$ 代表了空间离散化的截断误差。我们将使用离散 $L_2$ 和 $L_{\\infty}$ 范数在整个网格上全局量化此误差：\n$$\n\\|E\\|_{L_2} = \\sqrt{ \\sum_{P} A_P \\, E_P^2 }, \\qquad \\|E\\|_{L_{\\infty}} = \\max_{P} |E_P|\n$$\n几何非正交性由两个度量来表征。对于每个面 $f$，我们计算面法线与单元中心连接向量之间的未对齐角 $\\theta_f$：\n$$\n\\theta_f = \\arccos\\!\\left( \\left| \\hat{\\boldsymbol{n}}_f \\cdot \\hat{\\boldsymbol{r}}_f \\right| \\right) = \\arccos\\!\\left( \\frac{|\\boldsymbol{S}_f \\cdot \\boldsymbol{r}_f|}{\\|\\boldsymbol{S}_f\\| \\|\\boldsymbol{r}_f\\|} \\right)\n$$\n以及非正交修正向量 $\\boldsymbol{s}_f$ 的大小，它是面面积向量 $\\boldsymbol{S}_f$ 中与 $\\hat{\\boldsymbol{r}}_f$ 正交的分量：\n$$\n\\|\\boldsymbol{s}_f\\| = \\|\\boldsymbol{S}_f\\| \\sin(\\theta_f)\n$$\n这些被汇总为全局网格偏斜度度量 $\\theta_{\\max}$（所有面上的最大角度）和 $\\overline{\\|\\boldsymbol{s}\\|}$（所有面上 $\\boldsymbol{s}_f$ 的平均大小）。\n\n实现过程如下：\n1.  对于由 $(N_x, N_y, \\alpha)$ 定义的每个测试案例，生成一个结构化网格。首先，在参考域 $[0,1] \\times [0,1]$ 中创建一个 $(N_x+1) \\times (N_y+1)$ 个节点的均匀笛卡尔网格。然后，应用仿射剪切映射 $\\begin{pmatrix} x' \\\\ y' \\end{pmatrix} = \\begin{pmatrix} 1  \\alpha \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix}$ 将节点坐标变换到物理域。\n2.  计算所有单元和面的几何属性。单元中心 $\\boldsymbol{x}_P$ 按其四个顶点的质心计算。单元面积 $A_P$ 使用鞋带公式计算。对于每个面，确定其长度 $L_f$、中心和面积向量 $\\boldsymbol{S}_f$。\n3.  一个循环遍历网格中的每个单元 $P$。对于其四个面中的每一个，识别出相应的相邻单元 $N$。\n4.  对于每个面，如果它是内部面，则相邻者是一个相邻单元。如果它是边界面，则“相邻者”的数据取自面中心，这与指定的狄利克雷边界条件处理方法一致。\n5.  计算向量 $\\boldsymbol{r}_f$ 和 $\\boldsymbol{S}_f$。通过算法强制保证 $\\boldsymbol{S}_f$ 的方向，以确保 $\\boldsymbol{S}_f \\cdot \\boldsymbol{r}_f \\ge 0$。\n6.  计算通量贡献 $\\Phi_f^{\\text{TP}}$ 并将其加到单元 $P$ 的一个累加和中。同时计算并存储基于面的偏斜度度量 $\\theta_f$ 和 $\\|\\boldsymbol{s}_f\\|$，并避免对内部面进行重复计算。\n7.  处理完一个单元的所有面之后，使用总通量和来计算该单元的误差 $E_P$。\n8.  一旦所有单元都处理完毕，就计算全局误差范数 $\\|E\\|_{L_2}$ 和 $\\|E\\|_{L_{\\infty}}$，以及全局偏斜度度量 $\\theta_{\\max}$ 和 $\\overline{\\|\\boldsymbol{s}\\|}$。\n9.  完成所有四个测试案例后，分别计算 $\\|E\\|_{L_2}$ 值向量与 $\\theta_{\\max}$ 和 $\\overline{\\|\\boldsymbol{s}\\|}$ 值向量之间的皮尔逊相关系数。这量化了离散误差与网格非正交性之间的统计关系。\n\n该流程提供了问题陈述所要求的完整而严谨的评估。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        (20, 20, 0.0),\n        (20, 20, 0.2),\n        (20, 20, 0.4),\n        (4, 4, 0.3),\n    ]\n\n    case_results = []\n    e_l2_values = []\n    theta_max_values = []\n    s_bar_values = []\n\n    for Nx, Ny, alpha in test_cases:\n        e_l2, e_linf, theta_max, s_bar = compute_metrics(Nx, Ny, alpha)\n        case_results.append([e_l2, e_linf, theta_max, s_bar])\n        e_l2_values.append(e_l2)\n        theta_max_values.append(theta_max)\n        s_bar_values.append(s_bar)\n\n    # Compute correlation coefficients\n    rho_e2_theta = np.corrcoef(e_l2_values, theta_max_values)[0, 1]\n    rho_e2_s = np.corrcoef(e_l2_values, s_bar_values)[0, 1]\n\n    # Format the output string\n    result_str_parts = [f\"[{','.join(f'{val:.8e}' for val in res)}]\" for res in case_results]\n    full_result_str = f\"[{','.join(result_str_parts)},{rho_e2_theta:.8e},{rho_e2_s:.8e}]\"\n    \n    print(full_result_str)\n\ndef compute_metrics(Nx, Ny, alpha):\n    \"\"\"\n    Computes error and skewness metrics for a given mesh configuration.\n    \"\"\"\n    # Define manufactured solution and its Laplacian\n    T_func = lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y)\n    lap_T_func = lambda x, y: -2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    # 1. Generate mesh nodes in physical coordinates (x', y')\n    x_ref = np.linspace(0, 1, Nx + 1)\n    y_ref = np.linspace(0, 1, Ny + 1)\n    xx_ref, yy_ref = np.meshgrid(x_ref, y_ref, indexing='ij')\n\n    shear_map = np.array([[1, alpha], [0, 1]])\n    ref_coords = np.stack([xx_ref, yy_ref], axis=-1)\n    nodes = np.einsum('ij,klj->kli', shear_map, ref_coords)\n\n    # 2. Compute cell centers and areas\n    cell_centers = np.zeros((Nx, Ny, 2))\n    cell_areas = np.zeros((Nx, Ny))\n    for i in range(Nx):\n        for j in range(Ny):\n            v1 = nodes[i, j]\n            v2 = nodes[i + 1, j]\n            v3 = nodes[i + 1, j + 1]\n            v4 = nodes[i, j + 1]\n            cell_centers[i, j] = (v1 + v2 + v3 + v4) / 4.0\n            # Shoelace formula for area of a quadrilateral\n            area = 0.5 * abs(v1[0]*v2[1] - v1[1]*v2[0] + \n                             v2[0]*v3[1] - v2[1]*v3[0] + \n                             v3[0]*v4[1] - v3[1]*v4[0] + \n                             v4[0]*v1[1] - v4[1]*v1[0])\n            cell_areas[i, j] = area\n            \n    # 3. Main loop: Compute fluxes and skewness for each cell\n    cell_flux_sum = np.zeros((Nx, Ny))\n    face_thetas = []\n    face_s_mags = []\n    processed_faces = set()\n\n    for i in range(Nx):\n        for j in range(Ny):\n            P_center = cell_centers[i, j]\n            T_P = T_func(P_center[0], P_center[1])\n\n            # Neighbors: E, N, W, S\n            neighbors_info = [\n                ('E', i + 1, j, (i + 1, j), (i + 1, j + 1)), # N, P_face_node_idx1, P_face_node_idx2\n                ('N', i, j + 1, (i + 1, j + 1), (i, j + 1)),\n                ('W', i - 1, j, (i, j + 1), (i, j)),\n                ('S', i, j - 1, (i, j), (i + 1, j))\n            ]\n\n            for direction, ni, nj, v_idx1, v_idx2 in neighbors_info:\n                is_boundary = not (0 = ni  Nx and 0 = nj  Ny)\n                \n                v1 = nodes[v_idx1]\n                v2 = nodes[v_idx2]\n\n                # Face area vector S_f, oriented outwards from P\n                S_f = np.array([v2[1] - v1[1], -(v2[0] - v1[0])])\n                L_f = np.linalg.norm(S_f)\n\n                if is_boundary:\n                    face_center = (v1 + v2) / 2.0\n                    r_f = face_center - P_center\n                    T_N = T_func(face_center[0], face_center[1])\n                else:\n                    N_center = cell_centers[ni, nj]\n                    r_f = N_center - P_center\n                    T_N = T_func(N_center[0], N_center[1])\n\n                # Ensure S_f.r_f >= 0 as per problem spec\n                if np.dot(S_f, r_f)  0:\n                    S_f = -S_f\n                \n                r_f_mag_sq = np.dot(r_f, r_f)\n                if r_f_mag_sq == 0:\n                    flux = 0\n                else:\n                    r_f_hat = r_f / np.sqrt(r_f_mag_sq)\n                    flux = (T_N - T_P) / np.sqrt(r_f_mag_sq) * np.dot(S_f, r_f_hat)\n                \n                cell_flux_sum[i, j] += flux\n                \n                # Use a canonical representation of the face to avoid double counting\n                face_key = tuple(sorted((v_idx1, v_idx2)))\n                if face_key not in processed_faces:\n                    processed_faces.add(face_key)\n                    \n                    r_f_mag = np.sqrt(r_f_mag_sq)\n                    if L_f > 1e-12 and r_f_mag > 1e-12:\n                        cos_theta_abs = abs(np.dot(S_f, r_f)) / (L_f * r_f_mag)\n                        # Clamp due to potential floating point inaccuracies\n                        cos_theta_abs = min(1.0, max(0.0, cos_theta_abs))\n                        theta_f = np.arccos(cos_theta_abs)\n                        s_mag = L_f * np.sin(theta_f)\n                        \n                        face_thetas.append(theta_f)\n                        face_s_mags.append(s_mag)\n\n    # 4. Compute error norms and aggregated skewness metrics\n    cell_errors = np.zeros((Nx, Ny))\n    for i in range(Nx):\n        for j in range(Ny):\n            P_center = cell_centers[i, j]\n            lap_T_P = lap_T_func(P_center[0], P_center[1])\n            discrete_lap = cell_flux_sum[i, j] / cell_areas[i, j]\n            cell_errors[i, j] = discrete_lap - lap_T_P\n            \n    e_l2 = np.sqrt(np.sum(cell_areas * cell_errors**2))\n    e_linf = np.max(np.abs(cell_errors))\n    \n    theta_max = np.max(face_thetas) if face_thetas else 0.0\n    s_bar = np.mean(face_s_mags) if face_s_mags else 0.0\n\n    return e_l2, e_linf, theta_max, s_bar\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在求解不可压缩流动的压力基耦合算法中，Rhie-Chow插值是防止压力-速度解耦的关键技术，但在非正交网格上，该方法需要进行特殊处理。本练习旨在量化在Rhie-Chow动量插值中忽略非正交修正项所导致的误差，特别是其可能诱发的棋盘格压力场伪振荡。这项实践揭示了在复杂的耦合算法中正确处理非正交性的实际重要性，以确保数值解的稳定性和准确性 。",
            "id": "3999812",
            "problem": "考虑一个二维、定常、不可压缩的流场，其中用于质量通量评估的面法向速度是通过 Rhie–Chow 动量插值 (RCMI) 获得的。在非正交网格中，面法向压力梯度的正交近似使用沿连接单元中心的直线投影的中心到中心压力差，而完整的非正交修正则添加了投影到面法线上的压力梯度的切向分量。本题的目标是通过与根据已知解析压力场构建的参考解进行比较，来量化在忽略非正交修正时计算出的面法向速度的误差，并报告所引起的棋盘格振幅。\n\n基本原理和几何设置：\n- 设压力为一个在映射网格上定义的光滑标量场 $p(x,y)$。由压力梯度引起的面法向速度分量以无量纲形式表示为 $u_{n,f} = -\\nabla p \\cdot \\boldsymbol{n}_f$，其中 $\\boldsymbol{n}_f$ 是面 $f$ 的单位法向量。这种选择对应于一种无量纲化，其中有效的逆动量系数为单位1，因此所有量都是无量纲的。\n- 对于由两个相邻控制体共享的面 $f$，其中心由向量 $\\boldsymbol{d}$ 分隔，其大小为 $\\lvert \\boldsymbol{d} \\rvert$，定义单位向量 $\\hat{\\boldsymbol{d}} = \\boldsymbol{d} / \\lvert \\boldsymbol{d} \\rvert$。将面法向量分解为 $\\boldsymbol{n}_f = \\beta_f \\hat{\\boldsymbol{d}} + \\boldsymbol{t}_f$，其中 $\\beta_f = \\boldsymbol{n}_f \\cdot \\hat{\\boldsymbol{d}}$，$\\boldsymbol{t}_f$ 是 $\\boldsymbol{n}_f$ 在与 $\\hat{\\boldsymbol{d}}$ 相切方向上的分量。面法向压力梯度的正交近似使用 $\\beta_f \\, \\Delta p / \\lvert \\boldsymbol{d} \\rvert$，其中 $\\Delta p$ 是跨面的压力差。非正交修正添加了 $\\boldsymbol{t}_f \\cdot (\\nabla p)_f$，其中 $(\\nabla p)_f$ 是在面中心计算的压力梯度。\n- 通过从计算坐标 $(\\xi,\\eta) \\in [0,1]^2$ 到物理坐标 $(x,y)$ 的线性剪切映射构建一个非正交网格：\n$$\nx(\\xi,\\eta) = \\xi + \\alpha \\eta,\\quad y(\\xi,\\eta) = \\eta,\n$$\n其中 $\\alpha$ 是剪切参数。单元中心位于 $\\xi_i = (i + 0.5) \\Delta \\xi$ 和 $\\eta_j = (j + 0.5) \\Delta \\eta$，其中 $\\Delta \\xi = 1/N_x$ 和 $\\Delta \\eta = 1/N_y$。内部垂直面位于 $\\xi_{f} = (i+1) \\Delta \\xi$ 和 $\\eta_{f} = \\eta_j$，内部水平面位于 $\\xi_f = \\xi_i$ 和 $\\eta_f = (j+1) \\Delta \\eta$。\n- 对于垂直面，面切线为 $\\partial \\boldsymbol{r} / \\partial \\eta = (\\alpha,1)$，给出单位法向量\n$$\n\\boldsymbol{n}_v = \\frac{(1,-\\alpha)}{\\sqrt{1+\\alpha^2}},\\quad \\boldsymbol{d}_v = (\\Delta \\xi, 0),\\quad \\beta_v = \\boldsymbol{n}_v \\cdot \\hat{\\boldsymbol{d}}_v = \\frac{1}{\\sqrt{1+\\alpha^2}}.\n$$\n对于水平面，面切线为 $\\partial \\boldsymbol{r} / \\partial \\xi = (1,0)$，给出单位法向量\n$$\n\\boldsymbol{n}_h = (0,1),\\quad \\boldsymbol{d}_h = (\\alpha \\Delta \\eta, \\Delta \\eta),\\quad \\beta_h = \\boldsymbol{n}_h \\cdot \\hat{\\boldsymbol{d}}_h = \\frac{1}{\\sqrt{1+\\alpha^2}}.\n$$\n因此，垂直和水平面共享相同的 $\\beta = 1/\\sqrt{1+\\alpha^2}$，而 $\\lvert \\boldsymbol{d}_v \\rvert = \\Delta \\xi$ 且 $\\lvert \\boldsymbol{d}_h \\rvert = \\Delta \\eta \\sqrt{1+\\alpha^2}$。\n\n参考和未修正的面法向梯度：\n- 参考（完全修正）：$g_{\\text{ref},f} = \\nabla p(x_f,y_f) \\cdot \\boldsymbol{n}_f$。\n- 未修正（仅正交）：$g_{\\text{orth},f} = \\beta_f \\, \\Delta p / \\lvert \\boldsymbol{d} \\rvert$。\n- 相应的无量纲面法向速度为 $u_{\\text{ref},f} = -g_{\\text{ref},f}$ 和 $u_{\\text{uncorr},f} = -g_{\\text{orth},f}$。\n\n误差和棋盘格振幅定义：\n- 平均绝对误差 (MAE) 是在所有内部面（包括垂直和水平面）上 $\\lvert u_{\\text{uncorr},f} - u_{\\text{ref},f} \\rvert$ 的平均值。\n- 棋盘格振幅是沿内部面的一维序列定义的，作为最高频率离散傅里叶分量（交替模式）的大小。对于沿一条线的一系列面速度误差 $\\{e_m\\}_{m=0}^{M-1}$，振幅为\n$$\nA = \\left\\lvert \\frac{1}{M} \\sum_{m=0}^{M-1} e_m (-1)^m \\right\\rvert.\n$$\n计算沿中心行垂直面和中心列水平面的 $A$，并报告两者中的最大值。\n\n测试套件和压力场：\n使用以下无量纲测试套件参数集和压力场 $p(x,y)$ 及其解析梯度 $\\nabla p(x,y)$：\n- 案例1：$N_x = 32$, $N_y = 32$, $\\alpha = 0.3$, $p_1(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$, $\\nabla p_1 = (2\\pi \\cos(2\\pi x)\\sin(2\\pi y),\\; 2\\pi \\sin(2\\pi x)\\cos(2\\pi y))$。\n- 案例2：$N_x = 32$, $N_y = 32$, $\\alpha = 0.0$, $p_2(x,y) = x + 2y$, $\\nabla p_2 = (1,\\;2)$。\n- 案例3：$N_x = 32$, $N_y = 32$, $\\alpha = 1.0$, $p_1(x,y)$ 如上。\n- 案例4：$N_x = 8$, $N_y = 8$, $\\alpha = 0.5$, $p_3(x,y) = x^2 + y^2$, $\\nabla p_3 = (2x,\\;2y)$。\n- 案例5：$N_x = 8$, $N_y = 8$, $\\alpha = 0.0$, $p_3(x,y)$ 如上。\n\n所需计算：\n- 对于每个案例，构建网格，计算所有内部面的 $u_{\\text{ref},f}$ 和 $u_{\\text{uncorr},f}$，然后按定义计算 MAE 和棋盘格振幅 $A$。\n- 所有量均为无量纲；不需要物理单位。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个逗号分隔的列表，该列表由五个双元素列表组成，每个内部列表为对应测试用例的 $[\\text{MAE},\\text{振幅}]$，不含空格，例如：\n[[mae1,amp1],[mae2,amp2],[mae3,amp3],[mae4,amp4],[mae5,amp5]]",
            "solution": "问题陈述已经过验证，被认为是合理的。它提出了一个在计算流体动力学领域中定义明确、有科学依据的数值实验，特别是关于非正交网格上的有限体积法。所有必要的参数、定义和控制方程都已提供，不存在会妨碍唯一解的矛盾或歧义。该问题是分析在省略非正交修正时与压力梯度项相关的离散误差的标准练习。\n\n任务是计算在二维非正交网格上面法向速度的平均绝对误差 (MAE) 和棋盘格振幅。该误差源于使用简化的正交近似来计算压力梯度，而不是使用完整的、几何上正确的公式。此分析针对涉及不同网格参数和解析压力场的几个测试用例进行。\n\n该方法的核心涉及为计算网格的每个内部面 $f$ 计算两个版本的面法向速度 $u_f$。\n\n1. **网格和坐标系**：物理域 $(x,y)$ 是通过线性剪切映射从 $(\\xi,\\eta) \\in [0,1]^2$ 中的均匀计算网格生成的：\n$$\nx(\\xi,\\eta) = \\xi + \\alpha \\eta, \\quad y(\\xi,\\eta) = \\eta\n$$\n其中 $\\alpha$ 是剪切参数。单元中心位于计算单元的中心，面中心位于计算单元之间的边界上。对于一个 $N_x \\times N_y$ 单元的网格，计算单元的尺寸为 $\\Delta \\xi = 1/N_x$ 和 $\\Delta \\eta = 1/N_y$。\n\n2. **参考面法向速度 ($u_{\\text{ref},f}$)**：这是“真实”速度，源自精确的解析压力场 $p(x,y)$。它是通过将在物理面中心 $(x_f, y_f)$ 处计算的解析压力梯度 $\\nabla p$ 投影到面的单位法向量 $\\boldsymbol{n}_f$ 上来计算的。\n$$\nu_{\\text{ref},f} = -\\nabla p(x_f, y_f) \\cdot \\boldsymbol{n}_f\n$$\n垂直面 ($\\boldsymbol{n}_v$) 和水平面 ($\\boldsymbol{n}_h$) 的单位法向量分别给出为 $\\boldsymbol{n}_v = (1, -\\alpha)/\\sqrt{1+\\alpha^2}$ 和 $\\boldsymbol{n}_h = (0, 1)$。\n\n3. **未修正的面法向速度 ($u_{\\text{uncorr},f}$)**：此速度使用有限体积求解器中常见的正交近似计算。它仅使用共享面的两个单元之间的压力差 $\\Delta p$，沿连接其中心的直线进行投影，来近似法向压力梯度。\n$$\nu_{\\text{uncorr},f} = -g_{\\text{orth},f} = -\\beta_f \\frac{\\Delta p}{|\\boldsymbol{d}|}\n$$\n这里，$\\Delta p$ 是相邻单元中心之间的压力差（例如，对于东面是 $p_E - p_P$），$|\\boldsymbol{d}|$ 是这些单元中心之间的距离，$\\beta_f = \\boldsymbol{n}_f \\cdot \\hat{\\boldsymbol{d}}$ 是面法线 $\\boldsymbol{n}_f$ 与连接单元中心的单位向量 $\\hat{\\boldsymbol{d}}$ 之间夹角的余弦。问题提供了必要的几何因子：对于两种面类型，$\\beta_f = 1/\\sqrt{1+\\alpha^2}$，垂直面的 $|\\boldsymbol{d}_v| = \\Delta \\xi$，水平面的 $|\\boldsymbol{d}_h| = \\Delta \\eta \\sqrt{1+\\alpha^2}$。\n\n4. **误差量化**：\n   - **平均绝对误差 (MAE)**：单个面的误差为 $e_f = u_{\\text{uncorr},f} - u_{\\text{ref},f}$。MAE 是此误差的绝对值 $|e_f|$ 在网格所有内部面（包括垂直和水平面）上的平均值。\n   $$\n   \\text{MAE} = \\frac{1}{N_{\\text{faces}}} \\sum_{f} |u_{\\text{uncorr},f} - u_{\\text{ref},f}|\n   $$\n   - **棋盘格振幅 ($A$)**：此度量量化了误差场中的高频、单元到单元的振荡，这种现象被称为棋盘格，而 Rhie-Chow 插值正是为了抑制这种现象而设计的。对于沿网格线的一系列面误差 $\\{e_m\\}_{m=0}^{M-1}$，振幅是在奈奎斯特频率下归一化离散傅里叶分量的大小：\n   $$\n   A = \\left\\lvert \\frac{1}{M} \\sum_{m=0}^{M-1} e_m (-1)^m \\right\\rvert\n   $$\n   此振幅是为两个序列计算的：沿中心水平网格线的垂直面上的误差，以及沿中心垂直网格线的水平面上的误差。报告这两个振幅中的最大值。\n\n该解决方案通过遍历每个测试用例来实现。对于每个案例，我们构建网格，遍历所有内部面，计算 $u_{\\text{ref},f}$ 和 $u_{\\text{uncorr},f}$，并存储产生的误差 $e_f$。最后，从收集到的误差中计算出 MAE 和最大棋盘格振幅 $A$。该过程是确定性的，并为每个定义的案例产生唯一的数值结果。网格为正交 ($\\alpha=0$) 且压力场为线性或二次的特殊情况可作为解析校验，因为正交近似误差应为零，从而验证了实现的正确性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational thermal engineering problem for all specified test cases.\n    \"\"\"\n\n    def p1(x, y):\n        return np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)\n\n    def grad_p1(x, y):\n        val_x = 2 * np.pi * np.cos(2 * np.pi * x) * np.sin(2 * np.pi * y)\n        val_y = 2 * np.pi * np.sin(2 * np.pi * x) * np.cos(2 * np.pi * y)\n        return np.array([val_x, val_y])\n\n    def p2(x, y):\n        return x + 2 * y\n\n    def grad_p2(x, y):\n        return np.array([1.0, 2.0])\n\n    def p3(x, y):\n        return x**2 + y**2\n\n    def grad_p3(x, y):\n        return np.array([2 * x, 2 * y])\n\n    test_cases = [\n        {'Nx': 32, 'Ny': 32, 'alpha': 0.3, 'p_func': p1, 'grad_p_func': grad_p1},\n        {'Nx': 32, 'Ny': 32, 'alpha': 0.0, 'p_func': p2, 'grad_p_func': grad_p2},\n        {'Nx': 32, 'Ny': 32, 'alpha': 1.0, 'p_func': p1, 'grad_p_func': grad_p1},\n        {'Nx': 8, 'Ny': 8, 'alpha': 0.5, 'p_func': p3, 'grad_p_func': grad_p3},\n        {'Nx': 8, 'Ny': 8, 'alpha': 0.0, 'p_func': p3, 'grad_p_func': grad_p3},\n    ]\n\n    def compute_metrics_for_case(Nx, Ny, alpha, p_func, grad_p_func):\n        \"\"\"\n        Computes MAE and checkerboarding amplitude for a single case.\n        \"\"\"\n        delta_xi = 1.0 / Nx\n        delta_eta = 1.0 / Ny\n\n        def map_coords(xi, eta):\n            return xi + alpha * eta, eta\n\n        total_error_sum = 0.0\n        num_faces = 0\n\n        vert_errors_central_row = []\n        horiz_errors_central_col = []\n        \n        # Geometric factors\n        sqrt_1_alpha_sq = np.sqrt(1 + alpha**2)\n        beta = 1.0 / sqrt_1_alpha_sq\n        n_v = np.array([1.0, -alpha]) / sqrt_1_alpha_sq\n        n_h = np.array([0.0, 1.0])\n        d_v_mag = delta_xi\n        d_h_mag = delta_eta * sqrt_1_alpha_sq\n\n        central_row_j_idx = Ny // 2\n        central_col_i_idx = Nx // 2\n\n        # Loop over interior vertical faces\n        for j in range(Ny):\n            for i in range(Nx - 1):\n                eta_j_center = (j + 0.5) * delta_eta\n                xi_p_center = (i + 0.5) * delta_xi\n                xi_e_center = (i + 1.5) * delta_xi\n                xi_f = (i + 1.0) * delta_xi\n\n                x_p, y_p = map_coords(xi_p_center, eta_j_center)\n                x_e, y_e = map_coords(xi_e_center, eta_j_center)\n                x_f, y_f = map_coords(xi_f, eta_j_center)\n\n                delta_p = p_func(x_e, y_e) - p_func(x_p, y_p)\n                \n                g_orth = beta * delta_p / d_v_mag\n                g_ref = np.dot(grad_p_func(x_f, y_f), n_v)\n\n                error = g_ref - g_orth  # e_u = u_uncorr - u_ref = -g_orth - (-g_ref) = g_ref - g_orth\n                total_error_sum += np.abs(error)\n                num_faces += 1\n                \n                if j == central_row_j_idx:\n                    vert_errors_central_row.append(error)\n\n        # Loop over interior horizontal faces\n        for j in range(Ny - 1):\n            for i in range(Nx):\n                xi_i_center = (i + 0.5) * delta_xi\n                eta_p_center = (j + 0.5) * delta_eta\n                eta_n_center = (j + 1.5) * delta_eta\n                eta_f = (j + 1.0) * delta_eta\n\n                x_p, y_p = map_coords(xi_i_center, eta_p_center)\n                x_n, y_n = map_coords(xi_i_center, eta_n_center)\n                x_f, y_f = map_coords(xi_i_center, eta_f)\n\n                delta_p = p_func(x_n, y_n) - p_func(x_p, y_p)\n                \n                g_orth = beta * delta_p / d_h_mag\n                g_ref = np.dot(grad_p_func(x_f, y_f), n_h)\n\n                error = g_ref - g_orth\n                total_error_sum += np.abs(error)\n                num_faces += 1\n                \n                if i == central_col_i_idx:\n                    horiz_errors_central_col.append(error)\n\n        mae = total_error_sum / num_faces if num_faces > 0 else 0.0\n\n        # Calculate checkerboarding amplitude\n        e_v = np.array(vert_errors_central_row)\n        M_v = len(e_v)\n        amp_v = 0.0\n        if M_v > 0:\n            alternating_v = (-1.0)**np.arange(M_v)\n            amp_v = np.abs(np.sum(e_v * alternating_v) / M_v)\n\n        e_h = np.array(horiz_errors_central_col)\n        M_h = len(e_h)\n        amp_h = 0.0\n        if M_h > 0:\n            alternating_h = (-1.0)**np.arange(M_h)\n            amp_h = np.abs(np.sum(e_h * alternating_h) / M_h)\n            \n        amplitude = max(amp_v, amp_h)\n        \n        return [mae, amplitude]\n\n    results = []\n    for case in test_cases:\n        result = compute_metrics_for_case(**case)\n        results.append(result)\n    \n    # Format output to match the required specification '[[mae1,amp1],[mae2,amp2],...]'\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        }
    ]
}