{
    "hands_on_practices": [
        {
            "introduction": "在有限元方法中，雅可比行列式是确保从参考单元到物理单元的映射有效且符合物理规律的关键指标。正的雅可比行列式对于保持体积和方向至关重要，这是获得稳定且有意义的模拟结果的基础。本练习将从概念和计算两个层面探讨这一原理，加深您对单元有效性的理解。",
            "id": "3959412",
            "problem": "考虑三维瞬态热传导方程，其强形式写作 $\\rho c \\frac{\\partial T}{\\partial t} = \\nabla \\cdot (k \\nabla T) + q$，以及使用八节点三线性六面体单元对其进行的等参有限元离散化。在从参考立方体 $(\\xi,\\eta,\\zeta) \\in [-1,1]^{3}$ 到物理单元的标准等参映射中，物理坐标 $(x,y,z)$ 由附着于八个节点的八个三线性形函数 $N_{i}(\\xi,\\eta,\\zeta)$ 插值得到。在此映射下，弱形式中的单元级积分通过变量替换进行转换\n$$\n\\int_{\\Omega_{e}} f(\\boldsymbol{x}) \\,\\mathrm{d}\\Omega \\;=\\; \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} f\\big(\\boldsymbol{x}(\\xi,\\eta,\\zeta)\\big)\\,\\det\\big(\\boldsymbol{J}(\\xi,\\eta,\\zeta)\\big)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta,\n$$\n其中 $\\boldsymbol{J}(\\xi,\\eta,\\zeta)$ 是映射的雅可比矩阵，其列向量为 $\\partial \\boldsymbol{x}/\\partial \\xi$、$\\partial \\boldsymbol{x}/\\partial \\eta$ 和 $\\partial \\boldsymbol{x}/\\partial \\zeta$。$[-1,1]$ 上的高斯积分在各个高斯积分点处使用正权重。对于一个六面体单元，请解释为什么在各高斯积分点处 $\\det(\\boldsymbol{J})$ 的符号必须为正，以保持方向并对离散化热方程中的单元矩阵产生物理上有意义的贡献。然后，对于下面给定的特定扭曲平行六面体单元，计算在八个 $2\\times 2\\times 2$ 高斯积分点（其坐标为 $\\xi=\\pm 1/\\sqrt{3}$，$\\eta=\\pm 1/\\sqrt{3}$，$\\zeta=\\pm 1/\\sqrt{3}$）上的缩放雅可比的最小值，其中某一点的缩放雅可比定义为\n$$\nJ_{s}(\\xi,\\eta,\\zeta) \\;=\\; \\frac{\\det(\\boldsymbol{J}(\\xi,\\eta,\\zeta))}{\\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\xi}(\\xi,\\eta,\\zeta)\\right\\| \\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\eta}(\\xi,\\eta,\\zeta)\\right\\| \\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\zeta}(\\xi,\\eta,\\zeta)\\right\\|}.\n$$\n\n八个物理节点的坐标由一个基点 $\\boldsymbol{a} = (0.1,-0.05,0.02)$ 和三个边向量 $\\boldsymbol{v}_{1}=(2.0,0.2,0.0)$、$\\boldsymbol{v}_{2}=(0.0,1.6,0.1)$ 和 $\\boldsymbol{v}_{3}=(0.3,-0.1,0.9)$ 通过以下方式生成：\n$$\n\\boldsymbol{x}(\\xi_{i},\\eta_{i},\\zeta_{i}) \\;=\\; \\boldsymbol{a} \\;+\\; \\frac{\\xi_{i}}{2}\\,\\boldsymbol{v}_{1} \\;+\\; \\frac{\\eta_{i}}{2}\\,\\boldsymbol{v}_{2} \\;+\\; \\frac{\\zeta_{i}}{2}\\,\\boldsymbol{v}_{3},\n$$\n其中 $(\\xi_{i},\\eta_{i},\\zeta_{i})$ 是常规六面体节点排序中的八个角点参考坐标 $(\\pm 1,\\pm 1,\\pm 1)$。该单元在物理空间中是几何扭曲且非正交的，但仍然是参考立方体的仿射图像。\n\n请将最终答案表示为无量纲小数，并四舍五入到四位有效数字。",
            "solution": "该问题陈述有效。它以有限元法原理为科学基础，信息完备，问题适定，且语言客观。\n\n该问题包含两部分。第一部分是解释雅可比行列式为正的物理和数学必要性。第二部分是计算给定单元的特定网格质量度量。\n\n第一部分：雅可比行列式为正的重要性\n\n等参映射将物理单元 $\\Omega_e$ 上的积分转换为标准参考单元（一个由 $(\\xi, \\eta, \\zeta) \\in [-1,1]^3$ 定义的立方体）上的积分。积分中的变量替换规则如下：\n$$\n\\int_{\\Omega_{e}} f(\\boldsymbol{x}) \\,\\mathrm{d}\\Omega = \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} f\\big(\\boldsymbol{x}(\\xi,\\eta,\\zeta)\\big)\\,\\det\\big(\\boldsymbol{J}(\\xi,\\eta,\\zeta)\\big)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta\n$$\n此处，$\\det(\\boldsymbol{J})$ 是变换 $\\boldsymbol{x}(\\xi, \\eta, \\zeta)$ 的雅可比矩阵的行列式。它表示物理空间中的微分体积元 $\\mathrm{d}\\Omega$ 与参考空间中的微分体积元 $\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta$ 之间的局部比率。即 $\\mathrm{d}\\Omega = \\det(\\boldsymbol{J})\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta$。\n\n$\\det(\\boldsymbol{J})$ 在单元内所有位置，特别是在用于数值计算积分的高斯积分点处，必须为正，主要有三个原因：\n\n$1$. 物理体积：物理体积元 $\\mathrm{d}\\Omega$ 必须是一个正量。按照惯例，参考体积元 $\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta$ 是正的。因此，要使 $\\mathrm{d}\\Omega$ 为正，$\\det(\\boldsymbol{J})$ 必须严格为正。$\\det(\\boldsymbol{J}) = 0$ 意味着单元退化，体积为零；而 $\\det(\\boldsymbol{J})  0$ 则意味着单元“扭曲”或“内外翻转”，这是非物理的。\n\n$2$. 数学有效性：变量替换定理要求映射 $\\boldsymbol{x}(\\xi, \\eta, \\zeta)$ 是一个微分同胚，这意味着它必须是连续可微的，并且其逆映射也连续可微。一个必要条件是雅可比行列式在定义域内不变号且不为零。$\\det(\\boldsymbol{J})$ 为正可以确保该映射是一一对应且保持方向的，即参考空间中的右手坐标系映射到物理空间中仍为右手坐标系。\n\n$3$. 数值稳定性与矩阵的物理意义：单元矩阵，如质量矩阵 $\\boldsymbol{M}_e$ 和刚度矩阵 $\\boldsymbol{K}_e$，是通过高斯积分计算的，该方法将积分近似为一个和式：$\\sum_k w_k g(\\xi_k, \\eta_k, \\zeta_k)$，其中 $g$ 是包含 $\\det(\\boldsymbol{J})$ 的完整被积函数，而权重 $w_k$ 总是正的。例如，单元质量矩阵中的一个元素为 $M_{ij} = \\int_{\\Omega_e} \\rho c N_i N_j \\,\\mathrm{d}\\Omega$。当 $i=j$ 时，项 $\\rho c N_i N_j$ 是正的。如果 $\\det(\\boldsymbol{J})$ 在某个积分点为负，该点将对总和产生负贡献。这可能导致计算出的质量矩阵非正定，这在物理上是不正确的，因为它可能意味着，例如，一个正的动能可能与一个非物理状态相关联。一个非正定的质量或刚度矩阵会破坏整个方程组的解。\n\n第二部分：最小缩放雅可比的计算\n\n一个八节点等参单元的坐标映射由 $\\boldsymbol{x}(\\xi, \\eta, \\zeta) = \\sum_{i=1}^{8} N_{i}(\\xi,\\eta,\\zeta) \\boldsymbol{x}_{i}$ 给出，其中 $\\boldsymbol{x}_i$ 是节点坐标，$N_i$ 是三线性形函数 $N_i(\\xi,\\eta,\\zeta) = \\frac{1}{8}(1+\\xi_i\\xi)(1+\\eta_i\\eta)(1+\\zeta_i\\zeta)$。节点坐标由以下关系指定：\n$$\n\\boldsymbol{x}_{i} = \\boldsymbol{a} + \\frac{\\xi_{i}}{2}\\,\\boldsymbol{v}_{1} + \\frac{\\eta_{i}}{2}\\,\\boldsymbol{v}_{2} + \\frac{\\zeta_{i}}{2}\\,\\boldsymbol{v}_{3}\n$$\n其中 $(\\xi_i, \\eta_i, \\zeta_i)$ 是参考立方体中节点的坐标，即 $(\\pm 1, \\pm 1, \\pm 1)$。将此代入插值公式可得：\n$$\n\\boldsymbol{x}(\\xi, \\eta, \\zeta) = \\sum_{i=1}^{8} N_{i} \\left( \\boldsymbol{a} + \\frac{\\xi_{i}}{2}\\,\\boldsymbol{v}_{1} + \\frac{\\eta_{i}}{2}\\,\\boldsymbol{v}_{2} + \\frac{\\zeta_{i}}{2}\\,\\boldsymbol{v}_{3} \\right) = \\boldsymbol{a}\\sum_{i=1}^{8}N_i + \\frac{\\boldsymbol{v}_1}{2}\\sum_{i=1}^{8}\\xi_i N_i + \\frac{\\boldsymbol{v}_2}{2}\\sum_{i=1}^{8}\\eta_i N_i + \\frac{\\boldsymbol{v}_3}{2}\\sum_{i=1}^{8}\\zeta_i N_i\n$$\n利用三线性形函数的恒等式 $\\sum_i N_i = 1$、$\\sum_i \\xi_i N_i = \\xi$、$\\sum_i \\eta_i N_i = \\eta$ 和 $\\sum_i \\zeta_i N_i = \\zeta$，该映射可简化为仿射变换：\n$$\n\\boldsymbol{x}(\\xi, \\eta, \\zeta) = \\boldsymbol{a} + \\frac{\\xi}{2}\\,\\boldsymbol{v}_{1} + \\frac{\\eta}{2}\\,\\boldsymbol{v}_{2} + \\frac{\\zeta}{2}\\,\\boldsymbol{v}_{3}\n$$\n雅可比矩阵 $\\boldsymbol{J}$ 的列向量是 $\\boldsymbol{x}$ 关于 $\\xi$、$\\eta$ 和 $\\zeta$ 的偏导数：\n$$\n\\frac{\\partial \\boldsymbol{x}}{\\partial \\xi} = \\frac{1}{2}\\boldsymbol{v}_{1} = \\frac{1}{2}(2.0, 0.2, 0.0) = (1.0, 0.1, 0.0)\n$$\n$$\n\\frac{\\partial \\boldsymbol{x}}{\\partial \\eta} = \\frac{1}{2}\\boldsymbol{v}_{2} = \\frac{1}{2}(0.0, 1.6, 0.1) = (0.0, 0.8, 0.05)\n$$\n$$\n\\frac{\\partial \\boldsymbol{x}}{\\partial \\zeta} = \\frac{1}{2}\\boldsymbol{v}_{3} = \\frac{1}{2}(0.3, -0.1, 0.9) = (0.15, -0.05, 0.45)\n$$\n由于这些向量是常数，雅可比矩阵 $\\boldsymbol{J}$ 在整个单元内是恒定的。因此，$\\det(\\boldsymbol{J})$ 和缩放雅可比 $J_s$ 也是常数。最小值即为任意一点的值。\n$$\n\\boldsymbol{J} = \\begin{pmatrix} 1.0   0.0   0.15 \\\\ 0.1   0.8   -0.05 \\\\ 0.0   0.05   0.45 \\end{pmatrix}\n$$\n$\\boldsymbol{J}$ 的行列式为：\n$$\n\\det(\\boldsymbol{J}) = 1.0(0.8 \\cdot 0.45 - (-0.05) \\cdot 0.05) - 0.0(\\ldots) + 0.15(0.1 \\cdot 0.05 - 0.8 \\cdot 0.0)\n$$\n$$\n\\det(\\boldsymbol{J}) = 1.0(0.36 + 0.0025) + 0.15(0.005) = 0.3625 + 0.00075 = 0.36325\n$$\n接下来，我们计算 $\\boldsymbol{J}$ 的列向量的范数：\n$$\n\\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\xi}\\right\\| = \\left\\| \\frac{1}{2}\\boldsymbol{v}_{1} \\right\\| = \\frac{1}{2}\\sqrt{2.0^2 + 0.2^2 + 0.0^2} = \\frac{1}{2}\\sqrt{4.04}\n$$\n$$\n\\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\eta}\\right\\| = \\left\\| \\frac{1}{2}\\boldsymbol{v}_{2} \\right\\| = \\frac{1}{2}\\sqrt{0.0^2 + 1.6^2 + 0.1^2} = \\frac{1}{2}\\sqrt{2.57}\n$$\n$$\n\\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\zeta}\\right\\| = \\left\\| \\frac{1}{2}\\boldsymbol{v}_{3} \\right\\| = \\frac{1}{2}\\sqrt{0.3^2 + (-0.1)^2 + 0.9^2} = \\frac{1}{2}\\sqrt{0.09 + 0.01 + 0.81} = \\frac{1}{2}\\sqrt{0.91}\n$$\n缩放雅可比 $J_s$ 定义为：\n$$\nJ_{s} = \\frac{\\det(\\boldsymbol{J})}{\\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\xi}\\right\\| \\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\eta}\\right\\| \\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\zeta}\\right\\|}\n$$\n代入计算出的值：\n$$\nJ_s = \\frac{0.36325}{\\left(\\frac{1}{2}\\sqrt{4.04}\\right) \\left(\\frac{1}{2}\\sqrt{2.57}\\right) \\left(\\frac{1}{2}\\sqrt{0.91}\\right)} = \\frac{8 \\times 0.36325}{\\sqrt{4.04 \\times 2.57 \\times 0.91}}\n$$\n$$\nJ_s = \\frac{2.906}{\\sqrt{9.448348}} \\approx \\frac{2.906}{3.0738165} \\approx 0.945404\n$$\n由于对于此仿射单元，$J_s$ 是常数，因此它在所有八个高斯积分点的值都相同，这个值也就是最小值。四舍五入到四位有效数字，结果为 $0.9454$。",
            "answer": "$$\n\\boxed{0.9454}\n$$"
        },
        {
            "introduction": "虽然网格质量度量可以预示潜在问题，但理解网格质量如何直接影响求解精度也至关重要。我们在此引入“人造解方法”(Method of Manufactured Solutions, MMS)，这是一种强大的代码验证技术。本练习将演示如何设计一个受控实验，以系统地量化由特定网格缺陷（如非正交性）引入的数值误差。",
            "id": "3959445",
            "problem": "要求您构建一个制造解基准测试，以量化在使用有限体积法 (FVM) 进行稳态、常物性热传导计算时，网格非正交性对面法向热通量误差的影响。其控制物理为傅里叶热传导定律和散度定理。制造的温度场定义在一个二维域上，并在一个逻辑矩形网格的单元中心进行采样，该网格经过剪切以产生由一个参数表征的可控非正交性。任务是计算一种忽略非正交修正的两点式面法向热通量近似的相对均方根 (RMS) 误差，并将其表示为非正交性参数的函数。\n\n基本原理：\n- 傅里叶热传导定律：热通量矢量由 $\\mathbf{q} = -k \\nabla T$ 给出，其中 $k$ 为常数热导率，$T$ 为温度。\n- 散度定理（在其标准的FVM用法中）：通过面积矢量为 $\\mathbf{S}$ 的面的法向热通量为 $\\Phi = \\mathbf{q} \\cdot \\mathbf{S} = -\\nabla T \\cdot \\mathbf{S}$（当 $k=1$ 时）。面积矢量 $\\mathbf{S}$ 的大小等于面长度，方向等于控制体表面的外向单位法向量。\n\n几何与非正交网格：\n- 使用计算域 $(\\xi,\\eta) \\in [0,1]\\times[0,1]$，其上有一个均匀的逻辑矩形网格，包含 $N_x \\times N_y$ 个单元中心，中心坐标为 $(\\xi_i,\\eta_j) = \\big((i+\\tfrac{1}{2})/N_x,\\,(j+\\tfrac{1}{2})/N_y\\big)$，其中整数 $i \\in \\{0,\\dots,N_x-1\\}$ 和 $j \\in \\{0,\\dots,N_y-1\\}$。\n- 通过以下定义的线性剪切将计算域映射到物理坐标：\n$$\nx(\\xi,\\eta) = \\xi + \\tan(\\theta)\\,\\eta,\\quad y(\\xi,\\eta) = \\eta,\n$$\n其中 $\\theta$ 是非正交性参数（角度单位：弧度），$\\tan(\\theta)$ 控制剪切幅度。这种构造确保了计算坐标线之间的夹角与正交性的偏离程度受 $\\theta$ 控制。\n\n制造的温度场：\n- 定义无量纲温度场\n$$\nT(x,y) = \\sin\\!\\big(2\\pi x\\big)\\,\\sin\\!\\big(2\\pi y\\big).\n$$\n这给出了一个精确、已知的梯度\n$$\n\\nabla T(x,y) = \\left( 2\\pi\\cos\\!\\big(2\\pi x\\big)\\,\\sin\\!\\big(2\\pi y\\big),\\; 2\\pi\\sin\\!\\big(2\\pi x\\big)\\,\\cos\\!\\big(2\\pi y\\big) \\right),\n$$\n该梯度必须在物理空间的面中心处进行计算。\n\n待量化的离散误差：\n- 仅考虑内部面。对于由中心点为 $\\mathbf{x}_P$ 和 $\\mathbf{x}_N$ 的一对相邻控制体共享的每个内部面 $f$，定义：\n  - 中心到中心的矢量 $\\mathbf{d}_f = \\mathbf{x}_N - \\mathbf{x}_P$。\n  - 面面积矢量 $\\mathbf{S}_f$，其大小等于面长度，方向为主单元 $P$ 的外向法线方向；对于直面，$\\mathbf{S}_f$ 垂直于面切线，并通过映射计算得出。\n  - 精确的面法向热通量 $\\Phi_f^{\\text{exact}} = -\\nabla T(\\mathbf{x}_f)\\cdot \\mathbf{S}_f$，其中 $\\mathbf{x}_f$ 是通过映射相应的计算面中心得到的物理面中心点。\n  - 忽略非正交修正的两点通量近似，其定义为中心到中心方向导数在面面积矢量上的投影，由两个相邻单元中心的值 $T(\\mathbf{x}_P)$ 和 $T(\\mathbf{x}_N)$ 以及几何信息 $(\\mathbf{d}_f,\\mathbf{S}_f)$ 构建。使用 $k=1$ 和无量纲单位。\n- 汇总所有内部面上逐面的差异，以形成无量纲相对均方根误差：\n$$\n\\mathcal{E}_{\\text{rel}} = \\sqrt{\\frac{\\sum_f \\big(\\Phi_f^{\\text{tpf}} - \\Phi_f^{\\text{exact}}\\big)^2}{\\sum_f \\big(\\Phi_f^{\\text{exact}}\\big)^2}},\n$$\n其中 $\\Phi_f^{\\text{tpf}}$ 是面 $f$ 的两点通量近似值。\n\n角度单位与物理单位：\n- 角度 $\\theta$ 必须以弧度为单位。\n- 所有量均为无量纲；无需进行物理单位转换。\n\n测试套件：\n- 使用方形网格，$N_x=N_y=N$，以及以下 $(N,\\theta)$ 对：\n  - 案例1：$N=16$，$\\theta=0.0$。\n  - 案例2：$N=16$，$\\theta=0.2$。\n  - 案例3：$N=16$，$\\theta=0.5$。\n  - 案例4：$N=32$，$\\theta=0.5$。\n  - 案例5：$N=16$，$\\theta=0.7$。\n\n程序要求：\n- 按照规定实现几何结构和制造场。\n- 对于每个测试案例，使用两个方向上的所有内部面计算 $\\mathcal{E}_{\\text{rel}}$。\n- 您的程序应生成单行输出，其中包含结果。结果是一个用逗号分隔的浮点数列表，四舍五入到恰好8位小数，并用方括号括起来（例如，$\\big[$$0.01234567$$,$$0.00123456$$\\big]$）。其顺序必须与上面列出的案例1到5相匹配。",
            "solution": "问题陈述已经过严格验证，被认为是合理、适定且有科学依据的。它提出了计算传热学中的一个明确任务：量化在非正交网格上使用有限体积法（FVM）时，一种常见的简化所引入的误差。我们将给出完整的解法。\n\n问题的核心是计算相对均方根（RMS）误差 $\\mathcal{E}_{\\text{rel}}$，该误差用于比较在剪切计算网格的内部面上，精确的解析热通量与简化的数值近似值。该分析针对一个稳态热传导问题，该问题由傅里叶定律 $\\mathbf{q} = -k \\nabla T$ 控制，在一个具有已知（或“制造”）温度场的二维域上进行。对于此问题，热导率 $k$ 取为1，所有量均为无量纲。\n\n制造的温度场由下式给出\n$$\nT(x,y) = \\sin(2\\pi x) \\sin(2\\pi y)\n$$\n因此，该场的解析梯度为\n$$\n\\nabla T(x,y) = \\begin{pmatrix} 2\\pi\\cos(2\\pi x)\\sin(2\\pi y) \\\\ 2\\pi\\sin(2\\pi x)\\cos(2\\pi y) \\end{pmatrix}\n$$\n\n计算网格是在单位正方形 $(\\xi, \\eta) \\in [0,1] \\times [0,1]$ 上定义的 $N_x \\times N_y$ 个单元的逻辑矩形网格。一个线性剪切映射将这些计算坐标转换为物理坐标 $(x,y)$:\n$$\nx(\\xi,\\eta) = \\xi + \\tan(\\theta)\\eta\n$$\n$$\ny(\\xi,\\eta) = \\eta\n$$\n其中 $\\theta$ 是以弧度为单位的剪切角。此变换将常数 $\\eta$ 线映射到物理域中的水平线，而常数 $\\xi$ 线则映射到斜率为 $1/\\tan(\\theta)$ 的直线。因此，物理网格线之间的夹角为 $90^\\circ - \\theta$。\n\n我们的步骤如下：\n1.  基于参数 $N_x$、$N_y$ 和 $\\theta$ 定义网格几何形状。\n2.  遍历网格的所有内部面。\n3.  对每个面，计算精确热通量 $\\Phi_f^{\\text{exact}}$ 和近似的两点热通量 $\\Phi_f^{\\text{tpf}}$。\n4.  汇总平方差以计算最终的相对RMS误差 $\\mathcal{E}_{\\text{rel}}$。\n\n**1. 网格几何**\n\n索引为 $i \\in \\{0, \\dots, N_x-1\\}$ 和 $j \\in \\{0, \\dots, N_y-1\\}$ 的单元 $(i, j)$，其中心位于计算坐标 $(\\xi_c, \\eta_c)$ 处：\n$$\n\\xi_c = \\frac{i+0.5}{N_x}, \\quad \\eta_c = \\frac{j+0.5}{N_y}\n$$\n这些坐标通过剪切变换映射到物理坐标 $(x_c, y_c)$。\n\n一个内部面由两个相邻单元共享。我们考虑两族面：\n-   **$\\xi$-面：** 位于常数 $\\xi$ 处，分隔单元 $(i,j)$ 和 $(i+1,j)$ 的面。其计算中心位于 $(\\xi_f, \\eta_f) = (\\frac{i+1}{N_x}, \\frac{j+0.5}{N_y})$。\n-   **$\\eta$-面：** 位于常数 $\\eta$ 处，分隔单元 $(i,j)$ 和 $(i,j+1)$ 的面。其计算中心位于 $(\\xi_f, \\eta_f) = (\\frac{i+0.5}{N_x}, \\frac{j+1}{N_y})$。\n\n面面积矢量 $\\mathbf{S}_f$ 至关重要。其大小为面长度，方向为从指定的“主”单元 $P$ 指出的外向法线方向。对于线性映射，这些矢量对于每一族面都是恒定的。使用从映射雅可比矩阵派生的标准FVM定义，其中单元宽度为 $\\Delta\\xi = 1/N_x$ 和 $\\Delta\\eta = 1/N_y$：\n-   对于 $\\xi$-面（例如，单元的东面），面积矢量为 $\\mathbf{S}_{\\xi} = (\\Delta\\eta, -\\tan(\\theta)\\Delta\\eta)$。\n-   对于 $\\eta$-面（例如，单元的北面），面积矢量为 $\\mathbf{S}_{\\eta} = (0, \\Delta\\xi)$。\n\n**2. 单个面的通量计算**\n\n对于分隔主单元 $P$ 和相邻单元 $N$ 的每个内部面 $f$，我们执行以下计算。\n\n**精确通量 $\\Phi_f^{\\text{exact}}$：**\n通过面的精确热通量由面中心的热通量矢量 $\\mathbf{q}(\\mathbf{x}_f) = -\\nabla T(\\mathbf{x}_f)$ 与面面积矢量 $\\mathbf{S}_f$ 的点积给出。\n$$\n\\Phi_f^{\\text{exact}} = \\mathbf{q}(\\mathbf{x}_f) \\cdot \\mathbf{S}_f = - \\nabla T(\\mathbf{x}_f) \\cdot \\mathbf{S}_f\n$$\n此处，$\\mathbf{x}_f$ 是面中心的物理坐标，$\\nabla T(\\mathbf{x}_f)$ 是在该点计算的精确梯度。\n\n**近似两点通量 $\\Phi_f^{\\text{tpf}}$：**\n此通量近似仅使用两个相邻单元中心处的温度值 $T_P = T(\\mathbf{x}_P)$ 和 $T_N = T(\\mathbf{x}_N)$ 以及几何矢量 $\\mathbf{d}_f = \\mathbf{x}_N - \\mathbf{x}_P$ 和 $\\mathbf{S}_f$ 来构造。梯度沿着连接单元中心的直线进行近似：\n$$\n\\nabla T_f^{\\text{approx}} = \\frac{T_N - T_P}{|\\mathbf{d}_f|^2} \\mathbf{d}_f\n$$\n相应的近似热通量矢量为 $\\mathbf{q}_f^{\\text{tpf}} = - \\nabla T_f^{\\text{approx}}$。通过面的通量则为：\n$$\n\\Phi_f^{\\text{tpf}} = \\mathbf{q}_f^{\\text{tpf}} \\cdot \\mathbf{S}_f = - \\left( \\frac{T_N - T_P}{|\\mathbf{d}_f|^2} \\mathbf{d}_f \\right) \\cdot \\mathbf{S}_f = - (T_N - T_P) \\frac{\\mathbf{d}_f \\cdot \\mathbf{S}_f}{|\\mathbf{d}_f|^2}\n$$\n这个公式正确地捕捉了一个“忽略非正交修正”的简单FVM格式的本质。误差的产生是因为对于非正交网格 ($\\theta \\neq 0$)，单元中心连接矢量 $\\mathbf{d}_f$ 通常不与面法向矢量（包含在 $\\mathbf{S}_f$ 中）平行。\n\n**3. 汇总与误差计算**\n\n我们遍历所有内部面，对平方误差和精确通量的平方进行求和：\n-   平方误差之和: $\\sum_f_ \\text{err} = \\sum_{f} \\left(\\Phi_f^{\\text{tpf}} - \\Phi_f^{\\text{exact}}\\right)^2$\n-   精确通量平方之和: $\\sum_f_ \\text{exact} = \\sum_{f} \\left(\\Phi_f^{\\text{exact}}\\right)^2$\n\n求和范围包括所有内部的 $\\xi$-面 和 $\\eta$-面。最终的相对均方根误差为：\n$$\n\\mathcal{E}_{\\text{rel}} = \\sqrt{\\frac{\\sum_f_ \\text{err}}{\\sum_f_ \\text{exact}}}\n$$\n\n实现将包含一个以 $N$ 和 $\\theta$ 为输入的函数。在此函数内部，我们将遍历两个方向的面族的所有内部面索引，计算几何属性，为每个面评估两种通量，并累加计算 $\\mathcal{E}_{\\text{rel}}$ 所需的和。对问题陈述中提供的每个测试案例重复此过程。\n\n对于正交情况（$\\theta=0$），两个面族中的矢量 $\\mathbf{d}_f$ 都与 $\\mathbf{S}_f$ 平行。此时 $\\Phi_f^{\\text{tpf}}$ 中的主要误差是使用中心差分 $(T_N - T_P)/|\\mathbf{d}_f|$ 来近似导数 $\\partial T/\\partial n$ 所产生的截断误差。该误差是二阶的，即 O($\\Delta x^2$)，并且应该很小。对于非正交情况（$\\theta \\neq 0$），由 $\\mathbf{d}_f$ 和 $\\mathbf{S}_f$ 未对齐造成的几何误差会引入一个一阶误差 O($\\Delta x$)，该误差将占主导地位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_relative_rms_error(N, theta_rad):\n    \"\"\"\n    Computes the relative RMS error for a given grid size and non-orthogonality angle.\n\n    Args:\n        N (int): The number of cells in each direction (Nx=Ny=N).\n        theta_rad (float): The non-orthogonality angle in radians.\n\n    Returns:\n        float: The calculated relative RMS error.\n    \"\"\"\n    N_x, N_y = N, N\n    delta_xi = 1.0 / N_x\n    delta_eta = 1.0 / N_y\n    tan_theta = np.tan(theta_rad)\n\n    # --- Manufactured Solution Functions ---\n    def T_func(x, y):\n        return np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)\n\n    def grad_T_func(x, y):\n        grad_x = 2 * np.pi * np.cos(2 * np.pi * x) * np.sin(2 * np.pi * y)\n        grad_y = 2 * np.pi * np.sin(2 * np.pi * x) * np.cos(2 * np.pi * y)\n        return np.array([grad_x, grad_y])\n\n    def map_to_physical(xi, eta):\n        x = xi + tan_theta * eta\n        y = eta\n        return np.array([x, y])\n\n    sum_sq_error = 0.0\n    sum_sq_exact = 0.0\n\n    # --- Process interior xi-faces (vertical faces) ---\n    S_xi = np.array([delta_eta, -tan_theta * delta_eta])\n    for i in range(N_x - 1):\n        for j in range(N_y):\n            # Cell P (owner) and N (neighbor) computational centers\n            xi_P, eta_P = (i + 0.5) * delta_xi, (j + 0.5) * delta_eta\n            xi_N, eta_N = (i + 1.5) * delta_xi, (j + 0.5) * delta_eta\n            \n            # Face computational center\n            xi_f, eta_f = (i + 1.0) * delta_xi, (j + 0.5) * delta_eta\n\n            # Map to physical coordinates\n            x_P = map_to_physical(xi_P, eta_P)\n            x_N = map_to_physical(xi_N, eta_N)\n            x_f = map_to_physical(xi_f, eta_f)\n            \n            # Geometric vectors\n            d_f = x_N - x_P\n            \n            # Calculate fluxes\n            T_P = T_func(x_P[0], x_P[1])\n            T_N = T_func(x_N[0], x_N[1])\n            \n            d_f_dot_S_f = np.dot(d_f, S_xi)\n            d_f_dot_d_f = np.dot(d_f, d_f)\n            \n            # Note: k=1 is assumed\n            phi_tpf = -(T_N - T_P) * d_f_dot_S_f / d_f_dot_d_f\n            \n            grad_T_at_f = grad_T_func(x_f[0], x_f[1])\n            phi_exact = -np.dot(grad_T_at_f, S_xi)\n            \n            # Accumulate sums\n            sum_sq_error += (phi_tpf - phi_exact)**2\n            sum_sq_exact += phi_exact**2\n\n    # --- Process interior eta-faces (horizontal faces) ---\n    S_eta = np.array([0.0, delta_xi])\n    for i in range(N_x):\n        for j in range(N_y - 1):\n            # Cell P (owner) and N (neighbor) computational centers\n            xi_P, eta_P = (i + 0.5) * delta_xi, (j + 0.5) * delta_eta\n            xi_N, eta_N = (i + 0.5) * delta_xi, (j + 1.5) * delta_eta\n            \n            # Face computational center\n            xi_f, eta_f = (i + 0.5) * delta_xi, (j + 1.0) * delta_eta\n\n            # Map to physical coordinates\n            x_P = map_to_physical(xi_P, eta_P)\n            x_N = map_to_physical(xi_N, eta_N)\n            x_f = map_to_physical(xi_f, eta_f)\n            \n            # Geometric vectors\n            d_f = x_N - x_P\n\n            # Calculate fluxes\n            T_P = T_func(x_P[0], x_P[1])\n            T_N = T_func(x_N[0], x_N[1])\n\n            d_f_dot_S_f = np.dot(d_f, S_eta)\n            d_f_dot_d_f = np.dot(d_f, d_f)\n\n            phi_tpf = -(T_N - T_P) * d_f_dot_S_f / d_f_dot_d_f\n            \n            grad_T_at_f = grad_T_func(x_f[0], x_f[1])\n            phi_exact = -np.dot(grad_T_at_f, S_eta)\n            \n            # Accumulate sums\n            sum_sq_error += (phi_tpf - phi_exact)**2\n            sum_sq_exact += phi_exact**2\n\n    if sum_sq_exact == 0.0:\n        return 0.0 # Or handle as an error, but unlikely for this problem\n\n    return np.sqrt(sum_sq_error / sum_sq_exact)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        (16, 0.0),  # Case 1\n        (16, 0.2),  # Case 2\n        (16, 0.5),  # Case 3\n        (32, 0.5),  # Case 4\n        (16, 0.7),  # Case 5\n    ]\n\n    results = []\n    for N, theta_rad in test_cases:\n        error = calculate_relative_rms_error(N, theta_rad)\n        results.append(f\"{error:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在探讨了结构化和受控场景后，我们将转向在有限体积法中使用的真实非结构化网格的复杂性。本练习将介绍诸如正交效率和偏斜度等实用的基于面的度量标准。您将模拟网格优化中的一项常见任务：评估一个局部网格区域在节点移动前后的质量变化，并权衡其中涉及的利弊。",
            "id": "3959480",
            "problem": "您正在一个非结构化的二维网格上使用有限体积法 (FVM) 模拟扩散热通量。在面上精确评估扩散通量依赖于单元与单元之间的连接性与面法线之间的对齐，以及面相对于质心到质心连线的位置的几何保真度。考虑共享一个公共面的两个相邻控制体。设两个单元的质心在 $\\mathbb{R}^2$ 中为 $\\,\\mathbf{x}_P\\,$ 和 $\\,\\mathbf{x}_N\\,$，单位为米；面质心为 $\\,\\mathbf{x}_f\\,$，单位为米；单位面法线为 $\\,\\mathbf{n}_f\\,$（从单元 $\\,P\\,$ 指向单元 $\\,N\\,$）；面长度为 $\\,L_f\\,$，单位为米。定义连接向量 $\\,\\mathbf{d} = \\mathbf{x}_N - \\mathbf{x}_P\\,$. 扩散通量的离散化误差可以与两个广泛使用的网格质量度量相关联：\n\n1. 正交效率 $\\,\\eta_f\\,$：该指标量化了 $\\,\\mathbf{d}\\,$ 和 $\\,\\mathbf{n}_f\\,$ 之间的对齐程度，定义为归一化的面法线投影大小 $\\,\\eta_f = \\dfrac{\\left|\\mathbf{d}\\cdot\\mathbf{n}_f\\right|}{\\|\\mathbf{d}\\|}\\,$. 值越接近 $\\,1\\,$ 表示正交性越好。\n\n2. 面偏斜度 $\\,s_f\\,$：该指标量化了面质心与质心到质心连线和面平面交点之间的偏移量。设 $\\,\\mathbf{x}_{\\mathrm{int}}\\,$ 是参数线 $\\,\\mathbf{x}(t)=\\mathbf{x}_P+t\\,\\mathbf{d}\\,$ 与面平面 $\\,\\{\\mathbf{x}:\\mathbf{n}_f\\cdot(\\mathbf{x}-\\mathbf{x}_f)=0\\}\\,$ 的交点，该交点通过求解 $\\,\\mathbf{n}_f\\cdot(\\mathbf{x}_P+t\\,\\mathbf{d}-\\mathbf{x}_f)=0\\,$ 来找到 $\\,t\\,$. 然后定义 $\\,s_f=\\dfrac{\\|\\mathbf{x}_f-\\mathbf{x}_{\\mathrm{int}}\\|}{L_f}\\,$. 值越小表示偏斜度越低。为保证数值稳健性，当 $|\\mathbf{n}_f\\cdot\\mathbf{d}|  \\epsilon\\,$ 且 $\\,\\epsilon=10^{-5}\\,$ 时，将 $\\,s_f\\,$ 近似为 $\\,s_f\\approx\\dfrac{\\|\\mathbf{x}_f-\\mathbf{x}_P\\|}{L_f}\\,$.\n\n您执行一次局部节点重定位，这会改变 $\\,\\mathbf{x}_N\\,$ 并可能改变 $\\,\\mathbf{x}_f\\,$，产生新值 $\\,\\mathbf{x}_N^{\\mathrm{(after)}}\\,$ 和 $\\,\\mathbf{x}_f^{\\mathrm{(after)}}\\,$（对于给定的面，$\\,\\mathbf{n}_f\\,$ 和 $\\,L_f\\,$ 保持不变）。您需要计算 $\\,\\eta_f\\,$ 和 $\\,s_f\\,$ 的改善情况，定义为 $\\,\\Delta\\eta_f=\\eta_f^{\\mathrm{(after)}}-\\eta_f^{\\mathrm{(before)}}\\,$ 和 $\\,\\Delta s_f=s_f^{\\mathrm{(after)}}-s_f^{\\mathrm{(before)}}\\,$. 此外，还需评估与面邻域内单元尺寸均匀性之间的权衡。设重定位前后邻域单元的面积（单位为平方米）由列表 $\\,\\{A_i^{\\mathrm{(before)}}\\}\\,$ 和 $\\,\\{A_i^{\\mathrm{(after)}}\\}\\,$ 给出。通过变异系数 $\\,U = \\dfrac{\\sigma_A}{\\mu_A}\\,$ 来衡量均匀性，其中 $\\,\\mu_A\\,$ 是平均面积，$\\,\\sigma_A\\,$ 是总体标准差。如果 $\\,U^{\\mathrm{(after)}}  U^{\\mathrm{(before)}}\\,$，则认为均匀性得到了改善。",
            "solution": "问题陈述经评估为 **有效**。它在科学上基于计算传热学的有限体积法 (FVM) 原理，所提供的信息完备，定义和目标明确，是一个适定问题。指定的网格质量度量——正交效率和面偏斜度——是计算工程中用于评估计算网格质量及其对数值解精度的影响的标准度量。使用变异系数来衡量均匀性是一种标准的统计实践。该问题是自包含的，没有矛盾或含糊之处。\n\n解决方案按照要求从第一性原理出发，从所提供的几何和统计定义中推导出计算步骤。\n\n在有限体积法中，穿过控制体面的扩散通量是基础。对于标量属性 $\\phi$，其通量由 Fourier 定律（用于热量）或 Fick 定律（用于质量）控制，即 $\\mathbf{J} = -\\Gamma \\nabla\\phi$，其中 $\\Gamma$ 是扩散系数。穿过面 $f$ 的总通量为 $\\int_f \\mathbf{J} \\cdot \\mathbf{n}_f \\, dA$。在以单元为中心的 FVM 格式中，这使用两个相邻单元 $P$ 和 $N$ 质心处的值来近似。梯度沿着连接质心的直线进行近似，$\\nabla\\phi \\approx (\\phi_N - \\phi_P)/\\mathbf{d}$，其中 $\\mathbf{d} = \\mathbf{x}_N - \\mathbf{x}_P$。然后，垂直于面的通量分量与该梯度近似在面法线 $\\mathbf{n}_f$ 上的投影有关。当单元到单元的连接向量 $\\mathbf{d}$ 与面法线 $\\mathbf{n}_f$ 不对齐（非正交性）以及当面质心 $\\mathbf{x}_f$ 不位于连接 $\\mathbf{x}_P$ 和 $\\mathbf{x}_N$ 的线段上（偏斜）时，会产生离散化误差。度量 $\\eta_f$ 和 $s_f$ 就是为了量化这些几何缺陷而设计的。\n\n**1. 正交效率 ($\\eta_f$)**\n\n正交效率 $\\eta_f$ 衡量连接向量 $\\mathbf{d} = \\mathbf{x}_N - \\mathbf{x}_P$ 和面法线向量 $\\mathbf{n}_f$ 之间的对齐程度。它定义为：\n$$\n\\eta_f = \\frac{\\left|\\mathbf{d}\\cdot\\mathbf{n}_f\\right|}{\\|\\mathbf{d}\\|}\n$$\n这是向量 $\\mathbf{d}$ 和 $\\mathbf{n}_f$ 之间夹角 $\\theta$ 的余弦值的绝对值，因为 $\\mathbf{d}\\cdot\\mathbf{n}_f = \\|\\mathbf{d}\\| \\|\\mathbf{n}_f\\| \\cos\\theta$ 且 $\\|\\mathbf{n}_f\\|=1$。$\\eta_f=1$ 的值表示完美正交（$\\mathbf{d}$ 平行于 $\\mathbf{n}_f$），而 $\\eta_f=0$ 表示 $\\mathbf{d}$ 与面平面相切（最差情况）。计算需要：\n1.  计算向量 $\\mathbf{d} = (x_{N} - x_{P}, y_{N} - y_{P})$。\n2.  计算其模 $\\|\\mathbf{d}\\| = \\sqrt{(x_{N} - x_{P})^2 + (y_{N} - y_{P})^2}$。\n3.  计算点积 $\\mathbf{d}\\cdot\\mathbf{n}_f$。\n4.  评估 $\\eta_f$ 的公式。\n\n**2. 面偏斜度 ($s_f$)**\n\n面偏斜度 $s_f$ 量化了面质心 $\\mathbf{x}_f$ 相对于连接单元质心 $\\mathbf{x}_P$ 和 $\\mathbf{x}_N$ 的直线的位移。此推导遵循问题的定义。穿过 $\\mathbf{x}_P$ 和 $\\mathbf{x}_N$ 的直线参数化为 $\\mathbf{x}(t) = \\mathbf{x}_P + t\\,\\mathbf{d}$。面由一个平面（在二维中是一条线）表示，该平面由所有满足 $\\mathbf{n}_f\\cdot(\\mathbf{x}-\\mathbf{x}_f)=0$ 的点 $\\mathbf{x}$ 定义。通过将直线方程代入平面方程，可以找到交点 $\\mathbf{x}_{\\mathrm{int}}$：\n$$\n\\mathbf{n}_f \\cdot ((\\mathbf{x}_P + t\\,\\mathbf{d}) - \\mathbf{x}_f) = 0\n$$\n$$\n\\mathbf{n}_f \\cdot (\\mathbf{x}_P - \\mathbf{x}_f) + t\\,(\\mathbf{n}_f \\cdot \\mathbf{d}) = 0\n$$\n求解参数 $t$ 可得：\n$$\nt = \\frac{\\mathbf{n}_f \\cdot (\\mathbf{x}_f - \\mathbf{x}_P)}{\\mathbf{n}_f \\cdot \\mathbf{d}}\n$$\n该表达式在分母 $\\mathbf{n}_f \\cdot \\mathbf{d}$ 不为零时有效。分母很小表示直线几乎与面平面平行，这可能导致数值不稳定。问题指定了一个稳健性检查：如果 $|\\mathbf{d} \\cdot \\mathbf{n}_f|  \\epsilon$ 其中 $\\epsilon=10^{-5}$，则使用替代近似。\n\n计算过程如下：\n1.  计算 $\\mathbf{d} = \\mathbf{x}_N - \\mathbf{x}_P$ 和点积 $\\mathbf{d} \\cdot \\mathbf{n}_f$。\n2.  如果 $|\\mathbf{d} \\cdot \\mathbf{n}_f|  \\epsilon$:\n    $$\n    s_f = \\frac{\\|\\mathbf{x}_f - \\mathbf{x}_P\\|}{L_f}\n    $$\n3.  否则：\n    a. 使用推导出的公式计算 $t$。\n    b. 确定交点：$\\mathbf{x}_{\\mathrm{int}} = \\mathbf{x}_P + t\\,\\mathbf{d}$。\n    c. 计算偏斜度：\n    $$\n    s_f = \\frac{\\|\\mathbf{x}_f - \\mathbf{x}_{\\mathrm{int}}\\|}{L_f}\n    $$\n\n**3. 均匀性 ($U$)**\n\n邻域内单元尺寸的均匀性通过面积 $\\{A_i\\}$ 的变异系数 $U$ 来衡量。这是一个衡量相对变异性的标准统计量。它定义为总体标准差 $\\sigma_A$ 与平均值 $\\mu_A$ 的比值：\n$$\nU = \\frac{\\sigma_A}{\\mu_A}\n$$\n平均值计算为 $\\mu_A = \\frac{1}{N} \\sum_{i=1}^N A_i$，总体标准差计算为 $\\sigma_A = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N (A_i - \\mu_A)^2}$，其中 $N$ 是邻域中单元的数量。$U$ 值越小，表示单元尺寸的均匀性越高。如果 $U^{\\mathrm{(after)}}  U^{\\mathrm{before}}$，则认为均匀性得到改善。\n\n**每个测试用例的算法**\n\n对于每个测试用例，我们都给定了“之前”和“之后”的几何形状和面积分布状态。求解算法如下：\n1.  定义一个函数，该函数接受一组参数（$\\mathbf{x}_P, \\mathbf{x}_N, \\mathbf{x}_f, \\mathbf{n}_f, L_f, \\{A_i\\}$），并根据上述原理计算三个度量（$\\eta_f, s_f, U$）。\n2.  对“之前”的数据调用此函数，以获得 $\\eta_f^{\\mathrm{(before)}}$、$s_f^{\\mathrm{(before)}}$ 和 $U^{\\mathrm{(before)}}$。\n3.  对“之后”的数据调用此函数，以获得 $\\eta_f^{\\mathrm{(after)}}$、$s_f^{\\mathrm{(after)}}$ 和 $U^{\\mathrm{(after)}}$。\n4.  计算变化量：$\\Delta\\eta_f = \\eta_f^{\\mathrm{(after)}} - \\eta_f^{\\mathrm{(before)}}$ 和 $\\Delta s_f = s_f^{\\mathrm{(after)}} - s_f^{\\mathrm{(before)}}$。\n5.  确定均匀性改善的布尔标志：$\\text{uniformity\\_improved} = (U^{\\mathrm{(after)}}  U^{\\mathrm{(before)}})$。\n6.  组合结果 $[\\Delta\\eta_f, \\Delta s_f, \\text{uniformity\\_improved}]$，将浮点数四舍五入到六位小数，并将其添加到结果列表中。\n7.  处理完所有测试用例后，将结果列表格式化为最终输出指定的字符串格式。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the grid quality metrics problem for a given set of test cases.\n    \"\"\"\n\n    epsilon = 1e-5\n\n    test_cases = [\n        {\n            \"before\": {\n                \"x_P\": np.array([0., 0.]), \"x_N\": np.array([1., 0.1]),\n                \"x_f\": np.array([0.5, 0.0]), \"n_f\": np.array([1., 0.]),\n                \"L_f\": 1.0, \"areas\": [1.00, 1.10, 0.90, 1.05, 0.95]\n            },\n            \"after\": {\n                \"x_P\": np.array([0., 0.]), \"x_N\": np.array([1., 0.0]),\n                \"x_f\": np.array([0.5, 0.0]), \"n_f\": np.array([1., 0.]),\n                \"L_f\": 1.0, \"areas\": [1.02, 1.08, 0.92, 1.03, 0.95]\n            }\n        },\n        {\n            \"before\": {\n                \"x_P\": np.array([0., 0.]), \"x_N\": np.array([0., 1.]),\n                \"x_f\": np.array([0., 0.5]), \"n_f\": np.array([0., 1.]),\n                \"L_f\": 1.0, \"areas\": [1.00, 1.00, 1.00, 1.00, 1.00]\n            },\n            \"after\": {\n                \"x_P\": np.array([0., 0.]), \"x_N\": np.array([0., 1.05]),\n                \"x_f\": np.array([0., 0.5]), \"n_f\": np.array([0., 1.]),\n                \"L_f\": 1.0, \"areas\": [0.90, 1.10, 1.00, 1.00, 1.00]\n            }\n        },\n        {\n            \"before\": {\n                \"x_P\": np.array([0., 0.]), \"x_N\": np.array([1., 1e-6]),\n                \"x_f\": np.array([0.5, 0.02]), \"n_f\": np.array([0., 1.]),\n                \"L_f\": 1.0, \"areas\": [1.00, 0.80, 1.20, 1.10, 0.90]\n            },\n            \"after\": {\n                \"x_P\": np.array([0., 0.]), \"x_N\": np.array([1., 0.05]),\n                \"x_f\": np.array([0.5, 0.02]), \"n_f\": np.array([0., 1.]),\n                \"L_f\": 1.0, \"areas\": [1.20, 0.70, 1.30, 0.80, 1.00]\n            }\n        }\n    ]\n\n    def calculate_metrics(params):\n        \"\"\"\n        Calculates orthogonality, skewness, and uniformity for a single geometry configuration.\n        \"\"\"\n        x_P, x_N, x_f, n_f, L_f, areas = params.values()\n\n        # Connectivity vector\n        d_vec = x_N - x_P\n\n        # Orthogonality efficiency (eta_f)\n        d_norm = np.linalg.norm(d_vec)\n        if d_norm == 0:\n            eta_f = 0.0 # Degenerate case, though not in tests\n        else:\n            eta_f = np.abs(np.dot(d_vec, n_f)) / d_norm\n\n        # Face skewness (s_f)\n        n_dot_d = np.dot(n_f, d_vec)\n        if np.abs(n_dot_d)  epsilon:\n            # Robustness approximation\n            s_f = np.linalg.norm(x_f - x_P) / L_f\n        else:\n            # Full calculation\n            t = np.dot(n_f, x_f - x_P) / n_dot_d\n            x_int = x_P + t * d_vec\n            s_f = np.linalg.norm(x_f - x_int) / L_f\n\n        # Uniformity (U)\n        areas_np = np.array(areas)\n        mu_A = np.mean(areas_np)\n        if mu_A == 0:\n            U = 0.0 # Or undefined; assume 0 for uniform zero-area cells\n        else:\n            sigma_A = np.std(areas_np) # ddof=0 is default for population std dev\n            U = sigma_A / mu_A\n            \n        return eta_f, s_f, U\n\n    results = []\n    for case in test_cases:\n        eta_before, s_f_before, U_before = calculate_metrics(case[\"before\"])\n        eta_after, s_f_after, U_after = calculate_metrics(case[\"after\"])\n\n        delta_eta_f = eta_after - eta_before\n        delta_s_f = s_f_after - s_f_before\n        uniformity_improved = U_after  U_before\n\n        results.append([delta_eta_f, delta_s_f, uniformity_improved])\n\n    # Format the results into the required string format\n    str_results = []\n    for r in results:\n        # Format floats to 6 decimal places and convert bool to string 'True'/'False'\n        str_results.append(f\"[{r[0]:.6f},{r[1]:.6f},{r[2]}]\")\n\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        }
    ]
}