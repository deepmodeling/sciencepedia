{
    "hands_on_practices": [
        {
            "introduction": "Before we can assess the quality of a mesh, we must first ensure its mathematical validity. This practice explores the fundamental requirement of a positive Jacobian determinant for isoparametric elements, a condition that ensures a physical element has positive volume and maintains its orientation. By working through this problem , you will connect the abstract mathematics of the finite element mapping to its profound implications for the physical realism and numerical stability of the resulting simulation.",
            "id": "3959412",
            "problem": "Consider the transient heat conduction equation in three dimensions, written in strong form as $\\rho c \\frac{\\partial T}{\\partial t} = \\nabla \\cdot (k \\nabla T) + q$, and its isoparametric finite element discretization using eight-node trilinear hexahedral elements. In the standard isoparametric mapping from the reference cube $(\\xi,\\eta,\\zeta) \\in [-1,1]^{3}$ to a physical element, the physical coordinates $(x,y,z)$ are interpolated by trilinear shape functions $N_{i}(\\xi,\\eta,\\zeta)$ attached to the eight nodes. Under this mapping, the element-level integrals in the weak form are transformed by the change of variables\n$$\n\\int_{\\Omega_{e}} f(\\boldsymbol{x}) \\,\\mathrm{d}\\Omega \\;=\\; \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} f\\big(\\boldsymbol{x}(\\xi,\\eta,\\zeta)\\big)\\,\\det\\big(\\boldsymbol{J}(\\xi,\\eta,\\zeta)\\big)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta,\n$$\nwhere $\\boldsymbol{J}(\\xi,\\eta,\\zeta)$ is the Jacobian matrix of the mapping with columns $\\partial \\boldsymbol{x}/\\partial \\xi$, $\\partial \\boldsymbol{x}/\\partial \\eta$, and $\\partial \\boldsymbol{x}/\\partial \\zeta$. Gaussian quadrature on $[-1,1]$ uses positive weights at the Gaussian integration points. For a hexahedral element, explain why the sign of $\\det(\\boldsymbol{J})$ at the Gaussian integration points must be positive to preserve orientation and yield physically meaningful contributions to element matrices in the discretized heat equation. Then, for the specific distorted parallelepiped element below, compute the minimum value of the scaled Jacobian across the eight $2\\times 2\\times 2$ Gaussian integration points (with abscissae $\\xi=\\pm 1/\\sqrt{3}$, $\\eta=\\pm 1/\\sqrt{3}$, $\\zeta=\\pm 1/\\sqrt{3}$), where the scaled Jacobian at a point is defined as\n$$\nJ_{s}(\\xi,\\eta,\\zeta) \\;=\\; \\frac{\\det(\\boldsymbol{J}(\\xi,\\eta,\\zeta))}{\\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\xi}(\\xi,\\eta,\\zeta)\\right\\| \\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\eta}(\\xi,\\eta,\\zeta)\\right\\| \\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\zeta}(\\xi,\\eta,\\zeta)\\right\\|}.\n$$\n\nThe eight physical-node coordinates are generated from a base point $\\boldsymbol{a} = (0.1,-0.05,0.02)$ and three edge vectors $\\boldsymbol{v}_{1}=(2.0,0.2,0.0)$, $\\boldsymbol{v}_{2}=(0.0,1.6,0.1)$, and $\\boldsymbol{v}_{3}=(0.3,-0.1,0.9)$ by\n$$\n\\boldsymbol{x}(\\xi_{i},\\eta_{i},\\zeta_{i}) \\;=\\; \\boldsymbol{a} \\;+\\; \\frac{\\xi_{i}}{2}\\,\\boldsymbol{v}_{1} \\;+\\; \\frac{\\eta_{i}}{2}\\,\\boldsymbol{v}_{2} \\;+\\; \\frac{\\zeta_{i}}{2}\\,\\boldsymbol{v}_{3},\n$$\nwhere $(\\xi_{i},\\eta_{i},\\zeta_{i})$ are the eight corner reference coordinates $(\\pm 1,\\pm 1,\\pm 1)$ in the usual hexahedral node ordering. This element is geometrically distorted and non-orthogonal in physical space but remains an affine image of the reference cube.\n\nExpress your final answer as a dimensionless decimal and round to four significant figures.",
            "solution": "The problem statement is found to be valid. It is scientifically grounded in the principles of the finite element method, well-posed with all necessary information provided, and objective in its language.\n\nThe problem consists of two parts. The first is an explanation of the physical and mathematical necessity for the Jacobian determinant to be positive. The second is a calculation of a specific mesh quality metric for a given element.\n\nPart 1: The significance of a positive Jacobian determinant\n\nThe isoparametric mapping transforms integrals over a physical element $\\Omega_e$ to integrals over a standard reference element, a cube defined by $(\\xi, \\eta, \\zeta) \\in [-1,1]^3$. The rule for the change of variables in integration is:\n$$\n\\int_{\\Omega_{e}} f(\\boldsymbol{x}) \\,\\mathrm{d}\\Omega = \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} f\\big(\\boldsymbol{x}(\\xi,\\eta,\\zeta)\\big)\\,\\det\\big(\\boldsymbol{J}(\\xi,\\eta,\\zeta)\\big)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta\n$$\nHere, $\\det(\\boldsymbol{J})$ is the determinant of the Jacobian matrix of the transformation $\\boldsymbol{x}(\\xi, \\eta, \\zeta)$. It represents the local ratio of the differential volume element in physical space, $\\mathrm{d}\\Omega$, to the differential volume element in reference space, $\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta$. That is, $\\mathrm{d}\\Omega = \\det(\\boldsymbol{J})\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta$.\n\nThere are three primary reasons why $\\det(\\boldsymbol{J})$ must be positive everywhere within the element, and specifically at the Gaussian integration points used to numerically evaluate the integral:\n\n$1$. Physical Volume: A physical volume element, $\\mathrm{d}\\Omega$, must be a positive quantity. By convention, the reference volume element $\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,\\mathrm{d}\\zeta$ is positive. Therefore, for $\\mathrm{d}\\Omega$ to be positive, $\\det(\\boldsymbol{J})$ must be strictly positive. A value of $\\det(\\boldsymbol{J}) = 0$ implies a degenerate element with zero volume, while $\\det(\\boldsymbol{J})  0$ implies a \"tangled\" or \"inside-out\" element, which is non-physical.\n\n$2$. Mathematical Validity: The change of variables theorem requires the mapping $\\boldsymbol{x}(\\xi, \\eta, \\zeta)$ to be a diffeomorphism, which implies it must be continuously differentiable and have a continuously differentiable inverse. A necessary condition for this is that the Jacobian determinant does not change sign and is non-zero within the domain. A positive $\\det(\\boldsymbol{J})$ ensures the mapping is one-to-one and orientation-preserving, meaning a right-handed coordinate system in the reference space maps to a right-handed system in the physical space.\n\n$3$. Numerical Stability and Physical Meaning of Matrices: Element matrices, such as the mass matrix $\\boldsymbol{M}_e$ and stiffness matrix $\\boldsymbol{K}_e$, are computed via Gaussian quadrature, which approximates the integral as a sum: $\\sum_k w_k g(\\xi_k, \\eta_k, \\zeta_k)$, where $g$ is the full integrand including $\\det(\\boldsymbol{J})$ and the weights $w_k$ are always positive. For example, an entry in the element mass matrix is $M_{ij} = \\int_{\\Omega_e} \\rho c N_i N_j \\,\\mathrm{d}\\Omega$. The term $\\rho c N_i N_j$ is positive for $i=j$. If $\\det(\\boldsymbol{J})$ were negative at an integration point, that point would contribute negatively to the sum. This can lead to the computed mass matrix not being positive definite, which is physically incorrect as it implies, for example, that a positive kinetic energy could be associated with a non-physical state. A non-positive definite mass or stiffness matrix corrupts the entire solution of the system of equations.\n\nPart 2: Calculation of the minimum scaled Jacobian\n\nThe coordinate mapping for an eight-node isoparametric element is given by $\\boldsymbol{x}(\\xi, \\eta, \\zeta) = \\sum_{i=1}^{8} N_{i}(\\xi,\\eta,\\zeta) \\boldsymbol{x}_{i}$, where $\\boldsymbol{x}_i$ are the nodal coordinates and $N_i$ are the trilinear shape functions $N_i(\\xi,\\eta,\\zeta) = \\frac{1}{8}(1+\\xi_i\\xi)(1+\\eta_i\\eta)(1+\\zeta_i\\zeta)$. The nodal coordinates are specified by the relation:\n$$\n\\boldsymbol{x}_{i} = \\boldsymbol{a} + \\frac{\\xi_{i}}{2}\\,\\boldsymbol{v}_{1} + \\frac{\\eta_{i}}{2}\\,\\boldsymbol{v}_{2} + \\frac{\\zeta_{i}}{2}\\,\\boldsymbol{v}_{3}\n$$\nwhere $(\\xi_i, \\eta_i, \\zeta_i)$ are the coordinates of the nodes in the reference cube, i.e., $(\\pm 1, \\pm 1, \\pm 1)$. Substituting this into the interpolation formula yields:\n$$\n\\boldsymbol{x}(\\xi, \\eta, \\zeta) = \\sum_{i=1}^{8} N_{i} \\left( \\boldsymbol{a} + \\frac{\\xi_{i}}{2}\\,\\boldsymbol{v}_{1} + \\frac{\\eta_{i}}{2}\\,\\boldsymbol{v}_{2} + \\frac{\\zeta_{i}}{2}\\,\\boldsymbol{v}_{3} \\right) = \\boldsymbol{a}\\sum_{i=1}^{8}N_i + \\frac{\\boldsymbol{v}_1}{2}\\sum_{i=1}^{8}\\xi_i N_i + \\frac{\\boldsymbol{v}_2}{2}\\sum_{i=1}^{8}\\eta_i N_i + \\frac{\\boldsymbol{v}_3}{2}\\sum_{i=1}^{8}\\zeta_i N_i\n$$\nUsing the identities of trilinear shape functions, $\\sum_i N_i = 1$, $\\sum_i \\xi_i N_i = \\xi$, $\\sum_i \\eta_i N_i = \\eta$, and $\\sum_i \\zeta_i N_i = \\zeta$, the mapping simplifies to an affine transformation:\n$$\n\\boldsymbol{x}(\\xi, \\eta, \\zeta) = \\boldsymbol{a} + \\frac{\\xi}{2}\\,\\boldsymbol{v}_{1} + \\frac{\\eta}{2}\\,\\boldsymbol{v}_{2} + \\frac{\\zeta}{2}\\,\\boldsymbol{v}_{3}\n$$\nThe columns of the Jacobian matrix $\\boldsymbol{J}$ are the partial derivatives of $\\boldsymbol{x}$ with respect to $\\xi$, $\\eta$, and $\\zeta$:\n$$\n\\frac{\\partial \\boldsymbol{x}}{\\partial \\xi} = \\frac{1}{2}\\boldsymbol{v}_{1} = \\frac{1}{2}(2.0, 0.2, 0.0) = (1.0, 0.1, 0.0)\n$$\n$$\n\\frac{\\partial \\boldsymbol{x}}{\\partial \\eta} = \\frac{1}{2}\\boldsymbol{v}_{2} = \\frac{1}{2}(0.0, 1.6, 0.1) = (0.0, 0.8, 0.05)\n$$\n$$\n\\frac{\\partial \\boldsymbol{x}}{\\partial \\zeta} = \\frac{1}{2}\\boldsymbol{v}_{3} = \\frac{1}{2}(0.3, -0.1, 0.9) = (0.15, -0.05, 0.45)\n$$\nSince these vectors are constant, the Jacobian matrix $\\boldsymbol{J}$ is constant throughout the element. Consequently, $\\det(\\boldsymbol{J})$ and the scaled Jacobian $J_s$ are also constant. The minimum value is simply the value at any point.\n$$\n\\boldsymbol{J} = \\begin{pmatrix} 1.0  0.0  0.15 \\\\ 0.1  0.8  -0.05 \\\\ 0.0  0.05  0.45 \\end{pmatrix}\n$$\nThe determinant of $\\boldsymbol{J}$ is:\n$$\n\\det(\\boldsymbol{J}) = 1.0(0.8 \\cdot 0.45 - (-0.05) \\cdot 0.05) - 0.0(\\ldots) + 0.15(0.1 \\cdot 0.05 - 0.8 \\cdot 0.0)\n$$\n$$\n\\det(\\boldsymbol{J}) = 1.0(0.36 + 0.0025) + 0.15(0.005) = 0.3625 + 0.00075 = 0.36325\n$$\nNext, we compute the norms of the column vectors of $\\boldsymbol{J}$:\n$$\n\\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\xi}\\right\\| = \\left\\| \\frac{1}{2}\\boldsymbol{v}_{1} \\right\\| = \\frac{1}{2}\\sqrt{2.0^2 + 0.2^2 + 0.0^2} = \\frac{1}{2}\\sqrt{4.04}\n$$\n$$\n\\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\eta}\\right\\| = \\left\\| \\frac{1}{2}\\boldsymbol{v}_{2} \\right\\| = \\frac{1}{2}\\sqrt{0.0^2 + 1.6^2 + 0.1^2} = \\frac{1}{2}\\sqrt{2.57}\n$$\n$$\n\\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\zeta}\\right\\| = \\left\\| \\frac{1}{2}\\boldsymbol{v}_{3} \\right\\| = \\frac{1}{2}\\sqrt{0.3^2 + (-0.1)^2 + 0.9^2} = \\frac{1}{2}\\sqrt{0.09 + 0.01 + 0.81} = \\frac{1}{2}\\sqrt{0.91}\n$$\nThe scaled Jacobian $J_s$ is defined as:\n$$\nJ_{s} = \\frac{\\det(\\boldsymbol{J})}{\\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\xi}\\right\\| \\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\eta}\\right\\| \\left\\|\\frac{\\partial \\boldsymbol{x}}{\\partial \\zeta}\\right\\|}\n$$\nSubstituting the calculated values:\n$$\nJ_s = \\frac{0.36325}{\\left(\\frac{1}{2}\\sqrt{4.04}\\right) \\left(\\frac{1}{2}\\sqrt{2.57}\\right) \\left(\\frac{1}{2}\\sqrt{0.91}\\right)} = \\frac{8 \\times 0.36325}{\\sqrt{4.04 \\times 2.57 \\times 0.91}}\n$$\n$$\nJ_s = \\frac{2.906}{\\sqrt{9.448348}} \\approx \\frac{2.906}{3.0738165} \\approx 0.945404\n$$\nSince $J_s$ is constant for this affine element, its value is the same at all eight Gaussian integration points, and this value is therefore also the minimum. Rounding to four significant figures, the result is $0.9454$.",
            "answer": "$$\n\\boxed{0.9454}\n$$"
        },
        {
            "introduction": "Quantifying mesh quality often begins with measuring geometric properties, and one of the most important is orthogonality. This metric is especially critical in finite volume methods for accurately computing diffusive fluxes. This hands-on exercise  delves into the practical implementation of angle-based metrics, challenging you to compare the numerical robustness of `arccos` and `arctan2` formulations for calculating the angle between face-normal and cell-center-to-center vectors, a core skill for developing reliable CFD tools.",
            "id": "3959477",
            "problem": "You are tasked with implementing and validating angle-based grid quality metrics relevant to Computational Thermal Engineering, focusing on mesh orthogonality as used in the Finite Volume (FV) method for diffusion. Consider a face with unit face-normal vector $\\mathbf{n}$ and the vector connecting the centers of adjacent cells $\\mathbf{d}$. Mesh non-orthogonality can be quantified by the angle $\\theta$ between $\\mathbf{n}$ and $\\mathbf{d}$, and the non-orthogonality metric $\\varphi$ defined as $\\varphi = \\lvert \\theta - \\pi/2 \\rvert$. Angles must be expressed in radians.\n\nStarting from fundamental definitions:\n- The dot product $\\,\\mathbf{a} \\cdot \\mathbf{b} = \\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert \\cos \\theta\\,$ relates the angle $\\theta$ to the cosine of the angle.\n- In three dimensions, the magnitude of the cross product obeys $\\,\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert = \\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert \\sin \\theta\\,$, and in two dimensions, the scalar $\\,a_x b_y - a_y b_x\\,$ equals the $z$-component of the embedded three-dimensional cross product.\n\nYou must:\n1. Compute $\\theta$ using the dot-product formulation:\n   $$\\theta_{\\mathrm{dot}} = \\arccos\\!\\left(\\frac{\\mathbf{n} \\cdot \\mathbf{d}}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert}\\right),$$\n   using careful numerical handling that clamps the argument of $\\arccos$ to the interval $\\left[-1,1\\right]$.\n2. Compute $\\theta$ using the arctangent formulation:\n   $$\\theta_{\\arctan} = \\arctan2\\!\\left(\\frac{\\lVert \\mathbf{n} \\times \\mathbf{d} \\rVert}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert},\\,\\frac{\\mathbf{n} \\cdot \\mathbf{d}}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert}\\right),$$\n   where for two-dimensional vectors you must use $\\lvert n_x d_y - n_y d_x \\rvert$ as the magnitude of the embedded cross product in the numerator.\n3. Compute the non-orthogonality metric $\\varphi$ from both angles, i.e., $\\varphi_{\\mathrm{dot}} = \\lvert \\theta_{\\mathrm{dot}} - \\pi/2 \\rvert$ and $\\varphi_{\\arctan} = \\lvert \\theta_{\\arctan} - \\pi/2 \\rvert$.\n4. Validate robustness by checking agreement between the two formulations. For each test case, output a boolean indicating whether both angles agree within a specified tolerance and the computation is valid. Agreement is defined as $\\lvert \\theta_{\\mathrm{dot}} - \\theta_{\\arctan} \\rvert \\le \\varepsilon$ with $\\varepsilon = 10^{-12}$. Computations are invalid if $\\lVert \\mathbf{n} \\rVert = 0$ or $\\lVert \\mathbf{d} \\rVert = 0$.\n\nAngle unit specification: All angles must be computed in radians.\n\nTest Suite:\nUse the following set of pairs $(\\mathbf{n}, \\mathbf{d})$ that represent face normals and center-to-center vectors. Each vector is provided in either two or three dimensions. All components are dimensionless.\n\n- Case $1$: $\\mathbf{n} = (1,0,0)$, $\\mathbf{d} = (0,1,0)$.\n- Case $2$: $\\mathbf{n} = (1,0,0)$, $\\mathbf{d} = (10^{-12},1,0)$.\n- Case $3$: $\\mathbf{n} = (1,0,0)$, $\\mathbf{d} = (10^{3},0,0)$.\n- Case $4$: $\\mathbf{n} = (1,0,0)$, $\\mathbf{d} = (-2,0,0)$.\n- Case $5$: $\\mathbf{n} = (1,0,0)$, $\\mathbf{d} = (0,0,0)$.\n- Case $6$: $\\mathbf{n} = (1,10^{-14},0)$, $\\mathbf{d} = (1,-10^{-14},0)$.\n- Case $7$: $\\mathbf{n} = \\left(\\frac{\\sqrt{2}}{2}, \\frac{\\sqrt{2}}{2}\\right)$, $\\mathbf{d} = \\left(\\frac{\\sqrt{2}}{2}, -\\frac{\\sqrt{2}}{2}\\right)$.\n- Case $8$: $\\mathbf{n} = (1,2,3)$, $\\mathbf{d} = (4,5,6)$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3\\right]$). Each $\\mathrm{result}_i$ must be a boolean corresponding to Case $i$, indicating whether $\\theta_{\\mathrm{dot}}$ and $\\theta_{\\arctan}$ agree within $\\varepsilon$ and the computation is valid. The angle computations must be in radians internally.",
            "solution": "The problem requires the implementation and validation of two methods for calculating the angle $\\theta$ between two vectors, $\\mathbf{n}$ and $\\mathbf{d}$, which is a fundamental task in assessing mesh quality for computational methods like the Finite Volume (FV) method. The quality metric of interest is non-orthogonality, quantified by $\\varphi = \\lvert \\theta - \\pi/2 \\rvert$. We are asked to compute $\\theta$ using both a dot-product based `arccos` formulation and a more robust `arctan2` formulation, and then verify their agreement for a series of test cases.\n\nFirst, the problem statement is validated.\n**Step 1: Extract Givens**\n- Vectors: A face-normal vector $\\mathbf{n}$ and a cell-center connection vector $\\mathbf{d}$.\n- Angle: $\\theta$ is the angle between $\\mathbf{n}$ and $\\mathbf{d}$.\n- Non-orthogonality metric: $\\varphi = \\lvert \\theta - \\pi/2 \\rvert$.\n- Dot product definition: $\\mathbf{a} \\cdot \\mathbf{b} = \\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert \\cos \\theta$.\n- Cross product magnitude (3D): $\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert = \\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert \\sin \\theta$.\n- Cross product magnitude (2D): $\\lvert a_x b_y - a_y b_x \\rvert$.\n- Angle formula 1 (dot product): $\\theta_{\\mathrm{dot}} = \\arccos\\!\\left(\\frac{\\mathbf{n} \\cdot \\mathbf{d}}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert}\\right)$, with argument clamping to $[-1, 1]$.\n- Angle formula 2 (arctangent): $\\theta_{\\arctan} = \\arctan2\\!\\left(\\frac{\\lVert \\mathbf{n} \\times \\mathbf{d} \\rVert}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert},\\,\\frac{\\mathbf{n} \\cdot \\mathbf{d}}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert}\\right)$, using the 2D cross product magnitude for 2D vectors.\n- Validation criteria:\n    1. Computation is invalid if $\\lVert \\mathbf{n} \\rVert = 0$ or $\\lVert \\mathbf{d} \\rVert = 0$.\n    2. Agreement is defined as $\\lvert \\theta_{\\mathrm{dot}} - \\theta_{\\arctan} \\rvert \\le \\varepsilon$, with tolerance $\\varepsilon = 10^{-12}$.\n- Units: All angles are in radians.\n- Test Cases: Eight pairs of $(\\mathbf{n}, \\mathbf{d})$ vectors are provided.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective. It is based on fundamental principles of vector algebra and their standard application in computational engineering. The instructions are precise, the necessary data and formulas are provided, and the task is to implement a deterministic algorithm. The minor inconsistency between the description of $\\mathbf{n}$ as a \"unit vector\" and the test cases where it is not, is inconsequential because the provided formulas correctly normalize the vectors by their magnitudes, making them general.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be developed and implemented.\n\n**Principle-Based Design and Implementation**\n\nThe core of the task is to compute the angle $\\theta \\in [0, \\pi]$ between two vectors. The two prescribed methods offer a comparison of numerical stability.\n\n1.  **Dot Product (`arccos`) Method**:\n    The cosine of the angle $\\theta$ is derived from the dot product definition:\n    $$ \\cos\\theta = \\frac{\\mathbf{n} \\cdot \\mathbf{d}}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert} $$\n    The angle is then found by taking the inverse cosine: $\\theta_{\\mathrm{dot}} = \\arccos(\\cos\\theta)$. A critical numerical issue arises when $\\mathbf{n}$ and $\\mathbf{d}$ are nearly collinear (parallel or anti-parallel). In such cases, $\\cos\\theta$ is very close to $1$ or $-1$. Due to finite precision floating-point arithmetic, the calculated value can slightly exceed the valid domain $[-1, 1]$ of the $\\arccos$ function, leading to a domain error. The problem correctly mandates clamping the argument of $\\arccos$ to $[-1, 1]$ to prevent this.\n\n2.  **Arctangent (`arctan2`) Method**:\n    The `arctan2(y, x)` function computes the angle in radians between the positive x-axis and the point $(x, y)$. It is superior to $\\arctan(y/x)$ as it uses the signs of both arguments to determine the correct quadrant, yielding a result in $(-\\pi, \\pi]$. By providing it with arguments proportional to $\\sin\\theta$ and $\\cos\\theta$, we can robustly determine $\\theta$.\n    The required arguments are:\n    - $x \\propto \\cos\\theta = \\frac{\\mathbf{n} \\cdot \\mathbf{d}}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert}$\n    - $y \\propto \\sin\\theta = \\frac{\\lVert \\mathbf{n} \\times \\mathbf{d} \\rVert}{\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert}$\n    The magnitude of the cross product gives $\\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert \\sin\\theta$. Since $\\theta \\in [0, \\pi]$ (the range of `arccos`), $\\sin\\theta \\ge 0$, so we use the magnitude directly. For 2D vectors $\\mathbf{n} = (n_x, n_y)$ and $\\mathbf{d} = (d_x, d_y)$, the magnitude of the equivalent 3D cross product is $\\lvert n_x d_y - n_y d_x \\rvert$.\n    Thus, $\\theta_{\\arctan}$ is calculated as specified. This method is generally more stable than the `arccos` approach, especially for small angles.\n\n**Algorithmic Procedure**\nFor each test case $(\\mathbf{n}, \\mathbf{d})$:\n1.  Represent the vectors as numerical arrays.\n2.  Calculate the Euclidean norms (magnitudes) $\\lVert \\mathbf{n} \\rVert$ and $\\lVert \\mathbf{d} \\rVert$.\n3.  Check the invalidity condition: if either norm is zero, the result for the case is `False`.\n4.  If the norms are non-zero, proceed. Calculate the product of norms, $\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert$.\n5.  Calculate the dot product, $\\mathbf{n} \\cdot \\mathbf{d}$.\n6.  Compute $\\cos\\theta = (\\mathbf{n} \\cdot \\mathbf{d}) / (\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert)$.\n7.  Compute $\\theta_{\\mathrm{dot}}$ by taking the `arccos` of $\\cos\\theta$ after clamping it to the interval $[-1.0, 1.0]$.\n8.  Compute the magnitude of the cross product. This requires a check for the dimensionality of the vectors.\n    - If 3D, compute $\\lVert \\mathbf{n} \\times \\mathbf{d} \\rVert$.\n    - If 2D, compute $\\lvert n_x d_y - n_y d_x \\rvert$.\n9.  Compute the value proportional to $\\sin\\theta$: $\\lVert \\mathbf{n} \\times \\mathbf{d} \\rVert / (\\lVert \\mathbf{n} \\rVert \\lVert \\mathbf{d} \\rVert)$.\n10. Compute $\\theta_{\\arctan}$ using `arctan2` with the sine and cosine components as arguments.\n11. Compare the two angles: determine if $\\lvert \\theta_{\\mathrm{dot}} - \\theta_{\\arctan} \\rvert \\le 10^{-12}$. This boolean value is the result for the case.\n12. Collect the boolean results from all cases and format them into the required output string.\n\nThe logic is implemented in Python using the `numpy` library for its efficient and reliable vector operations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the grid quality metric validation problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Orthogonal vectors\n        ((1, 0, 0), (0, 1, 0)),\n        # Case 2: Nearly orthogonal vectors\n        ((1, 0, 0), (1e-12, 1, 0)),\n        # Case 3: Parallel vectors\n        ((1, 0, 0), (1e3, 0, 0)),\n        # Case 4: Anti-parallel vectors\n        ((1, 0, 0), (-2, 0, 0)),\n        # Case 5: Zero vector, invalid computation\n        ((1, 0, 0), (0, 0, 0)),\n        # Case 6: Nearly parallel vectors, testing precision\n        ((1, 1e-14, 0), (1, -1e-14, 0)),\n        # Case 7: 2D orthogonal vectors\n        ((np.sqrt(2)/2, np.sqrt(2)/2), (np.sqrt(2)/2, -np.sqrt(2)/2)),\n        # Case 8: General 3D vectors\n        ((1, 2, 3), (4, 5, 6)),\n    ]\n\n    def compute_angle_agreement(n_tuple, d_tuple):\n        \"\"\"\n        Computes the angle between two vectors using two methods and checks agreement.\n\n        Args:\n            n_tuple: A tuple representing vector n.\n            d_tuple: A tuple representing vector d.\n\n        Returns:\n            A boolean indicating if the computation is valid and the two angle\n            calculations agree within the tolerance.\n        \"\"\"\n        n = np.array(n_tuple, dtype=np.float64)\n        d = np.array(d_tuple, dtype=np.float64)\n\n        # Calculate norms and check for invalidity (zero vector)\n        norm_n = np.linalg.norm(n)\n        norm_d = np.linalg.norm(d)\n        \n        if norm_n == 0 or norm_d == 0:\n            return False\n\n        norm_prod = norm_n * norm_d\n        \n        # --- Dot-product (arccos) method ---\n        dot_nd = np.dot(n, d)\n        cos_theta = dot_nd / norm_prod\n        \n        # Clamp argument to arccos to handle potential floating point inaccuracies\n        cos_theta_clamped = np.clip(cos_theta, -1.0, 1.0)\n        theta_dot = np.arccos(cos_theta_clamped)\n\n        # --- Arctangent (arctan2) method ---\n        # Calculate magnitude of cross product based on dimension\n        if n.size == 3:\n            # 3D case\n            norm_cross_nd = np.linalg.norm(np.cross(n, d))\n        elif n.size == 2:\n            # 2D case as specified\n            norm_cross_nd = np.abs(n[0] * d[1] - n[1] * d[0])\n        else:\n            # Should not happen with given test cases\n            return False\n\n        sin_theta_component = norm_cross_nd / norm_prod\n        \n        # arctan2(y, x), where y ~ sin(theta) and x ~ cos(theta)\n        # This correctly computes the angle in [0, pi], matching arccos range\n        theta_arctan = np.arctan2(sin_theta_component, cos_theta)\n        \n        # --- Validation check ---\n        epsilon = 1e-12\n        agreement = np.abs(theta_dot - theta_arctan) = epsilon\n        \n        return agreement\n\n    results = []\n    for case in test_cases:\n        n_vec, d_vec = case\n        result = compute_angle_agreement(n_vec, d_vec)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate test of a mesh quality metric is its correlation with solution accuracy. This practice introduces the Method of Manufactured Solutions (MMS), a powerful and rigorous technique used in code verification to precisely quantify discretization errors. By constructing a problem with a known analytical solution , you will perform a numerical experiment to isolate and measure the error introduced by a controlled amount of mesh non-orthogonality, providing a clear demonstration of why high-quality meshes are essential for reliable simulations.",
            "id": "3959445",
            "problem": "You are asked to construct a manufactured-solution benchmark to quantify the effect of mesh non-orthogonality on face-normal heat flux errors in steady, constant-property conduction using the Finite Volume Method (FVM). The governing physics is Fourier’s law of heat conduction and the divergence theorem. The manufactured temperature field is defined on a two-dimensional domain and sampled at cell centers of a logically rectangular grid that is sheared to produce a controlled non-orthogonality characterized by a parameter. The task is to compute a relative root-mean-square (RMS) error for a two-point face-normal heat flux approximation that neglects non-orthogonal corrections, as a function of the non-orthogonality parameter.\n\nFundamental base:\n- Fourier’s law of heat conduction: the heat flux vector is given by $\\mathbf{q} = -k \\nabla T$, where $k$ is the constant thermal conductivity and $T$ is temperature.\n- Divergence theorem (in its standard FVM use): the face-normal heat flux through a face with area vector $\\mathbf{S}$ is $\\Phi = \\mathbf{q} \\cdot \\mathbf{S} = -\\nabla T \\cdot \\mathbf{S}$ for $k=1$. The area vector $\\mathbf{S}$ has magnitude equal to the face length and direction equal to the outward unit normal of the control volume face.\n\nGeometry and non-orthogonal mesh:\n- Use a computational domain $(\\xi,\\eta) \\in [0,1]\\times[0,1]$ with a uniform logically rectangular grid of $N_x \\times N_y$ cell centers at $(\\xi_i,\\eta_j) = \\big((i+\\tfrac{1}{2})/N_x,\\,(j+\\tfrac{1}{2})/N_y\\big)$ for integers $i \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$.\n- Map the computational domain to physical coordinates by a linear shear defined by\n$$\nx(\\xi,\\eta) = \\xi + \\tan(\\theta)\\,\\eta,\\quad y(\\xi,\\eta) = \\eta,\n$$\nwhere $\\theta$ is the non-orthogonality parameter (angle unit: radians), and $\\tan(\\theta)$ controls the shear magnitude. This construction ensures that the angle between the computational coordinate lines deviates from orthogonality by a controlled amount tied to $\\theta$.\n\nManufactured temperature field:\n- Define the dimensionless temperature field\n$$\nT(x,y) = \\sin\\!\\big(2\\pi x\\big)\\,\\sin\\!\\big(2\\pi y\\big).\n$$\nThis yields an exact, known gradient\n$$\n\\nabla T(x,y) = \\left( 2\\pi\\cos\\!\\big(2\\pi x\\big)\\,\\sin\\!\\big(2\\pi y\\big),\\; 2\\pi\\sin\\!\\big(2\\pi x\\big)\\,\\cos\\!\\big(2\\pi y\\big) \\right),\n$$\nwhich must be evaluated at face centers in physical space.\n\nDiscretization artifacts to be quantified:\n- Consider interior faces only. For each interior face $f$ shared by a pair of neighboring control volumes with centers $\\mathbf{x}_P$ and $\\mathbf{x}_N$, define:\n  - The center-to-center vector $\\mathbf{d}_f = \\mathbf{x}_N - \\mathbf{x}_P$.\n  - The face area vector $\\mathbf{S}_f$ of magnitude equal to the face length and orientation equal to the outward normal from the owner cell $P$; for straight faces, $\\mathbf{S}_f$ is perpendicular to the face tangent and is computed from the mapping.\n  - The exact face-normal heat flux $\\Phi_f^{\\text{exact}} = -\\nabla T(\\mathbf{x}_f)\\cdot \\mathbf{S}_f$, where $\\mathbf{x}_f$ is the physical face-center point obtained by mapping the appropriate computational face-center.\n  - The two-point flux approximation that neglects non-orthogonal corrections, defined as the projection of the center-to-center directional derivative onto the face area vector, built from the two adjacent cell-center values $T(\\mathbf{x}_P)$ and $T(\\mathbf{x}_N)$ and the geometry $(\\mathbf{d}_f,\\mathbf{S}_f)$. Use $k=1$ and dimensionless units.\n- Aggregate these facewise discrepancies to form a dimensionless relative RMS error over all interior faces,\n$$\n\\mathcal{E}_{\\text{rel}} = \\sqrt{\\frac{\\sum_f \\big(\\Phi_f^{\\text{tpf}} - \\Phi_f^{\\text{exact}}\\big)^2}{\\sum_f \\big(\\Phi_f^{\\text{exact}}\\big)^2}},\n$$\nwhere $\\Phi_f^{\\text{tpf}}$ is the two-point flux approximation for face $f$.\n\nAngle unit and physical units:\n- The angle $\\theta$ must be specified in radians.\n- All quantities are dimensionless; no physical unit conversion is required.\n\nTest suite:\n- Use square grids with $N_x=N_y=N$ and the following $(N,\\theta)$ pairs:\n  - Case $1$: $N=16$, $\\theta=0.0$.\n  - Case $2$: $N=16$, $\\theta=0.2$.\n  - Case $3$: $N=16$, $\\theta=0.5$.\n  - Case $4$: $N=32$, $\\theta=0.5$.\n  - Case $5$: $N=16$, $\\theta=0.7$.\n\nProgram requirements:\n- Implement the geometry and manufactured field as specified.\n- For each test case, compute $\\mathcal{E}_{\\text{rel}}$ using all interior faces of both face families.\n- Your program should produce a single line of output containing the results as a comma-separated list of floating-point numbers rounded to exactly $8$ decimal places, enclosed in square brackets (for example, $\\big[$$0.01234567$$,$$0.00123456$$\\big]$). The order must match Cases $1$ through $5$ as listed above.",
            "solution": "The problem statement has been critically validated and is deemed sound, well-posed, and scientifically grounded. It presents a clear task in computational heat transfer: to quantify the error introduced by a common simplification in the Finite Volume Method (FVM) on non-orthogonal meshes. We shall proceed with a full solution.\n\nThe core of the problem is to compute a relative root-mean-square (RMS) error, $\\mathcal{E}_{\\text{rel}}$, which compares an exact analytical heat flux with a simplified numerical approximation across the interior faces of a sheared computational grid. The analysis is performed for a steady-state heat conduction problem governed by Fourier's law, $\\mathbf{q} = -k \\nabla T$, on a two-dimensional domain with a known, or \"manufactured,\" temperature field. For this problem, the thermal conductivity $k$ is taken as $1$, and all quantities are dimensionless.\n\nThe manufactured temperature field is given by\n$$\nT(x,y) = \\sin(2\\pi x) \\sin(2\\pi y)\n$$\nThe analytical gradient of this field is therefore\n$$\n\\nabla T(x,y) = \\begin{pmatrix} 2\\pi\\cos(2\\pi x)\\sin(2\\pi y) \\\\ 2\\pi\\sin(2\\pi x)\\cos(2\\pi y) \\end{pmatrix}\n$$\n\nThe computational grid is a logically rectangular mesh of $N_x \\times N_y$ cells defined on the unit square $(\\xi, \\eta) \\in [0,1] \\times [0,1]$. A linear shear mapping transforms these computational coordinates to physical coordinates $(x,y)$:\n$$\nx(\\xi,\\eta) = \\xi + \\tan(\\theta)\\eta\n$$\n$$\ny(\\xi,\\eta) = \\eta\n$$\nwhere $\\theta$ is the shear angle in radians. This transformation maps lines of constant $\\eta$ to horizontal lines in the physical domain, while lines of constant $\\xi$ are mapped to lines with a slope of $1/\\tan(\\theta)$. The angle between the physical grid lines is thus $90^\\circ - \\theta$.\n\nOur procedure is as follows:\n1.  Define the grid geometry based on the parameters $N_x$, $N_y$, and $\\theta$.\n2.  Iterate through all interior faces of the grid.\n3.  For each face, calculate the exact heat flux, $\\Phi_f^{\\text{exact}}$, and the approximate two-point heat flux, $\\Phi_f^{\\text{tpf}}$.\n4.  Aggregate the squared differences to compute the final relative RMS error, $\\mathcal{E}_{\\text{rel}}$.\n\n**1. Grid Geometry**\n\nA cell $(i, j)$ with indices $i \\in \\{0, \\dots, N_x-1\\}$ and $j \\in \\{0, \\dots, N_y-1\\}$ has its center at computational coordinates $(\\xi_c, \\eta_c)$:\n$$\n\\xi_c = \\frac{i+0.5}{N_x}, \\quad \\eta_c = \\frac{j+0.5}{N_y}\n$$\nThese are mapped to physical coordinates $(x_c, y_c)$ using the shear transformation.\n\nAn interior face is shared between two adjacent cells. We consider two families of faces:\n-   **$\\xi$-faces:** Faces at constant $\\xi$, separating cells $(i,j)$ and $(i+1,j)$. Their computational centers are at $(\\xi_f, \\eta_f) = (\\frac{i+1}{N_x}, \\frac{j+0.5}{N_y})$.\n-   **$\\eta$-faces:** Faces at constant $\\eta$, separating cells $(i,j)$ and $(i,j+1)$. Their computational centers are at $(\\xi_f, \\eta_f) = (\\frac{i+0.5}{N_x}, \\frac{j+1}{N_y})$.\n\nThe face area vector, $\\mathbf{S}_f$, is critical. Its magnitude is the face length, and its direction is the outward normal from a designated \"owner\" cell $P$. For a linear mapping, these vectors are constant for each face family. Using standard FVM definitions derived from the mapping Jacobian, with cell widths $\\Delta\\xi = 1/N_x$ and $\\Delta\\eta = 1/N_y$:\n-   For a $\\xi$-face (e.g., the east face of a cell), the area vector is $\\mathbf{S}_{\\xi} = (\\Delta\\eta, -\\tan(\\theta)\\Delta\\eta)$.\n-   For an $\\eta$-face (e.g., the north face of a cell), the area vector is $\\mathbf{S}_{\\eta} = (0, \\Delta\\xi)$.\n\n**2. Flux Calculations for a Single Face**\n\nFor each interior face $f$ separating an owner cell $P$ and a neighbor cell $N$, we perform the following calculations.\n\n**Exact Flux $\\Phi_f^{\\text{exact}}$:**\nThe exact heat flux through the face is given by the dot product of the heat flux vector at the face center, $\\mathbf{q}(\\mathbf{x}_f) = -\\nabla T(\\mathbf{x}_f)$, and the face area vector $\\mathbf{S}_f$.\n$$\n\\Phi_f^{\\text{exact}} = \\mathbf{q}(\\mathbf{x}_f) \\cdot \\mathbf{S}_f = - \\nabla T(\\mathbf{x}_f) \\cdot \\mathbf{S}_f\n$$\nHere, $\\mathbf{x}_f$ is the physical coordinate of the face center, and $\\nabla T(\\mathbf{x}_f)$ is the exact gradient evaluated at that point.\n\n**Approximate Two-Point Flux $\\Phi_f^{\\text{tpf}}$:**\nThis flux approximation is constructed using only the temperature values at the centers of the two adjacent cells, $T_P = T(\\mathbf{x}_P)$ and $T_N = T(\\mathbf{x}_N)$, and the geometric vectors $\\mathbf{d}_f = \\mathbf{x}_N - \\mathbf{x}_P$ and $\\mathbf{S}_f$. The gradient is approximated along the line connecting the cell centers:\n$$\n\\nabla T_f^{\\text{approx}} = \\frac{T_N - T_P}{|\\mathbf{d}_f|^2} \\mathbf{d}_f\n$$\nThe corresponding approximate heat flux vector is $\\mathbf{q}_f^{\\text{tpf}} = - \\nabla T_f^{\\text{approx}}$. The flux through the face is then:\n$$\n\\Phi_f^{\\text{tpf}} = \\mathbf{q}_f^{\\text{tpf}} \\cdot \\mathbf{S}_f = - \\left( \\frac{T_N - T_P}{|\\mathbf{d}_f|^2} \\mathbf{d}_f \\right) \\cdot \\mathbf{S}_f = - (T_N - T_P) \\frac{\\mathbf{d}_f \\cdot \\mathbf{S}_f}{|\\mathbf{d}_f|^2}\n$$\nThis formulation correctly captures the essence of a simple FVM scheme that \"neglects non-orthogonal corrections.\" The error arises because the cell-center connection vector $\\mathbf{d}_f$ is not, in general, parallel to the face normal vector (embedded in $\\mathbf{S}_f$) for a non-orthogonal mesh ($\\theta \\neq 0$).\n\n**3. Aggregation and Error Calculation**\n\nWe iterate through all interior faces, summing the squared error and the squared exact flux:\n-   Sum of squared errors: $\\sum_f_ \\text{err} = \\sum_{f} \\left(\\Phi_f^{\\text{tpf}} - \\Phi_f^{\\text{exact}}\\right)^2$\n-   Sum of squared exact fluxes: $\\sum_f_ \\text{exact} = \\sum_{f} \\left(\\Phi_f^{\\text{exact}}\\right)^2$\n\nThe summations run over all interior $\\xi$-faces and $\\eta$-faces. The final relative RMS error is:\n$$\n\\mathcal{E}_{\\text{rel}} = \\sqrt{\\frac{\\sum_f_ \\text{err}}{\\sum_f_ \\text{exact}}}\n$$\n\nThe implementation will consist of a function that takes $N$ and $\\theta$ as input. Inside this function, we will loop over the interior face indices for both face families, compute the geometric properties, evaluate the two fluxes for each face, and accumulate the sums required for the $\\mathcal{E}_{\\text{rel}}$ calculation. This process is repeated for each test case provided in the problem statement.\n\nFor the orthogonal case ($\\theta=0$), the vector $\\mathbf{d}_f$ is parallel to $\\mathbf{S}_f$ for both face families. The dominant error in $\\Phi_f^{\\text{tpf}}$ is then the truncation error from approximating the derivative $\\partial T/\\partial n$ with a central difference $(T_N - T_P)/|\\mathbf{d}_f|$. This error is second-order, O($\\Delta x^2$), and should be small. For non-orthogonal cases ($\\theta \\neq 0$), the geometric error from the misalignment of $\\mathbf{d}_f$ and $\\mathbf{S}_f$ introduces a first-order error, O($\\Delta x$), which will dominate.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_relative_rms_error(N, theta_rad):\n    \"\"\"\n    Computes the relative RMS error for a given grid size and non-orthogonality angle.\n\n    Args:\n        N (int): The number of cells in each direction (Nx=Ny=N).\n        theta_rad (float): The non-orthogonality angle in radians.\n\n    Returns:\n        float: The calculated relative RMS error.\n    \"\"\"\n    N_x, N_y = N, N\n    delta_xi = 1.0 / N_x\n    delta_eta = 1.0 / N_y\n    tan_theta = np.tan(theta_rad)\n\n    # --- Manufactured Solution Functions ---\n    def T_func(x, y):\n        return np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)\n\n    def grad_T_func(x, y):\n        grad_x = 2 * np.pi * np.cos(2 * np.pi * x) * np.sin(2 * np.pi * y)\n        grad_y = 2 * np.pi * np.sin(2 * np.pi * x) * np.cos(2 * np.pi * y)\n        return np.array([grad_x, grad_y])\n\n    def map_to_physical(xi, eta):\n        x = xi + tan_theta * eta\n        y = eta\n        return np.array([x, y])\n\n    sum_sq_error = 0.0\n    sum_sq_exact = 0.0\n\n    # --- Process interior xi-faces (vertical faces) ---\n    S_xi = np.array([delta_eta, -tan_theta * delta_eta])\n    for i in range(N_x - 1):\n        for j in range(N_y):\n            # Cell P (owner) and N (neighbor) computational centers\n            xi_P, eta_P = (i + 0.5) * delta_xi, (j + 0.5) * delta_eta\n            xi_N, eta_N = (i + 1.5) * delta_xi, (j + 0.5) * delta_eta\n            \n            # Face computational center\n            xi_f, eta_f = (i + 1.0) * delta_xi, (j + 0.5) * delta_eta\n\n            # Map to physical coordinates\n            x_P = map_to_physical(xi_P, eta_P)\n            x_N = map_to_physical(xi_N, eta_N)\n            x_f = map_to_physical(xi_f, eta_f)\n            \n            # Geometric vectors\n            d_f = x_N - x_P\n            \n            # Calculate fluxes\n            T_P = T_func(x_P[0], x_P[1])\n            T_N = T_func(x_N[0], x_N[1])\n            \n            d_f_dot_S_f = np.dot(d_f, S_xi)\n            d_f_dot_d_f = np.dot(d_f, d_f)\n            \n            # Note: k=1 is assumed\n            phi_tpf = -(T_N - T_P) * d_f_dot_S_f / d_f_dot_d_f\n            \n            grad_T_at_f = grad_T_func(x_f[0], x_f[1])\n            phi_exact = -np.dot(grad_T_at_f, S_xi)\n            \n            # Accumulate sums\n            sum_sq_error += (phi_tpf - phi_exact)**2\n            sum_sq_exact += phi_exact**2\n\n    # --- Process interior eta-faces (horizontal faces) ---\n    S_eta = np.array([0.0, delta_xi])\n    for i in range(N_x):\n        for j in range(N_y - 1):\n            # Cell P (owner) and N (neighbor) computational centers\n            xi_P, eta_P = (i + 0.5) * delta_xi, (j + 0.5) * delta_eta\n            xi_N, eta_N = (i + 0.5) * delta_xi, (j + 1.5) * delta_eta\n            \n            # Face computational center\n            xi_f, eta_f = (i + 0.5) * delta_xi, (j + 1.0) * delta_eta\n\n            # Map to physical coordinates\n            x_P = map_to_physical(xi_P, eta_P)\n            x_N = map_to_physical(xi_N, eta_N)\n            x_f = map_to_physical(xi_f, eta_f)\n            \n            # Geometric vectors\n            d_f = x_N - x_P\n\n            # Calculate fluxes\n            T_P = T_func(x_P[0], x_P[1])\n            T_N = T_func(x_N[0], x_N[1])\n\n            d_f_dot_S_f = np.dot(d_f, S_eta)\n            d_f_dot_d_f = np.dot(d_f, d_f)\n\n            phi_tpf = -(T_N - T_P) * d_f_dot_S_f / d_f_dot_d_f\n            \n            grad_T_at_f = grad_T_func(x_f[0], x_f[1])\n            phi_exact = -np.dot(grad_T_at_f, S_eta)\n            \n            # Accumulate sums\n            sum_sq_error += (phi_tpf - phi_exact)**2\n            sum_sq_exact += phi_exact**2\n\n    if sum_sq_exact == 0.0:\n        return 0.0 # Or handle as an error, but unlikely for this problem\n\n    return np.sqrt(sum_sq_error / sum_sq_exact)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        (16, 0.0),  # Case 1\n        (16, 0.2),  # Case 2\n        (16, 0.5),  # Case 3\n        (32, 0.5),  # Case 4\n        (16, 0.7),  # Case 5\n    ]\n\n    results = []\n    for N, theta_rad in test_cases:\n        error = calculate_relative_rms_error(N, theta_rad)\n        results.append(f\"{error:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}