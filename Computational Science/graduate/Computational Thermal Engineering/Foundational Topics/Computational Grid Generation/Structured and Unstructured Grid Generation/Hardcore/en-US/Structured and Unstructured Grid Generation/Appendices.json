{
    "hands_on_practices": [
        {
            "introduction": "Before exploring sophisticated grid generation techniques, we must address the most fundamental requirement: grid validity. A computational grid is useless if it folds or tangles, and the key mathematical tool to diagnose this is the Jacobian determinant, $J$, of the mapping. This exercise  challenges you to analyze a common algebraic grid transformation, derive its Jacobian, and determine the precise parameter limits that ensure a valid, one-to-one mapping, providing a crucial foundation for robust grid generation.",
            "id": "3987900",
            "problem": "In computational thermal engineering, maintaining a one-to-one mapping between a computational domain and a physical domain is essential to avoid grid tangling in the numerical simulation of heat transfer. Consider a two-dimensional algebraic grid deformation used to control node clustering for a buoyancy-driven cavity flow. The deformation maps the computational square $(\\xi,\\eta)\\in [0,1]\\times[0,1]$ to the physical plane via\n$$\nx(\\xi,\\eta) = \\xi,\\qquad y(\\xi,\\eta) = \\eta + \\epsilon \\sin(\\pi \\xi)\\sin(\\pi \\eta),\n$$\nwhere $\\epsilon$ is a dimensionless control parameter.\n\nStarting from the definition of the Jacobian determinant of a mapping between planes and the condition for a bijective map in two dimensions, derive an explicit expression for the Jacobian determinant $J(\\xi,\\eta;\\epsilon)$ of this transformation. Use this to determine the tightest upper bound on $|\\epsilon|$ such that the mapping remains bijective throughout the entire computational square, ensuring no grid line crossings anywhere in $[0,1]\\times[0,1]$. Identify, in your reasoning, the locations in $(\\xi,\\eta)$ where the Jacobian approaches zero as $|\\epsilon|$ approaches its maximal allowable value, and explain why those locations are critical from the standpoint of grid tangling risk.\n\nReport, as your final answer, only the maximum allowable magnitude of $\\epsilon$ as a symbolic expression in terms of $\\pi$. Do not round. There are no physical units for $\\epsilon$; it is dimensionless.",
            "solution": "The problem requires the derivation of the condition under which a given two-dimensional mapping remains bijective, ensuring no grid tangling. This involves calculating the Jacobian determinant of the transformation and finding the constraint on the parameter $\\epsilon$ that prevents the determinant from becoming zero or changing sign within the specified domain.\n\nThe given transformation maps the computational coordinates $(\\xi, \\eta)$ from the unit square $[0,1]\\times[0,1]$ to the physical coordinates $(x,y)$ according to the functions:\n$$\nx(\\xi,\\eta) = \\xi\n$$\n$$\ny(\\xi,\\eta) = \\eta + \\epsilon \\sin(\\pi \\xi)\\sin(\\pi \\eta)\n$$\nA continuously differentiable mapping remains bijective (one-to-one) in a domain if its Jacobian determinant does not change sign and is never zero in the interior of the domain. The Jacobian determinant $J$ of the transformation from $(\\xi, \\eta)$ to $(x,y)$ is defined as:\n$$\nJ(\\xi,\\eta;\\epsilon) = \\det \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta} - \\frac{\\partial x}{\\partial \\eta}\\frac{\\partial y}{\\partial \\xi}\n$$\nFirst, we compute the necessary partial derivatives of the transformation functions:\n$$\n\\frac{\\partial x}{\\partial \\xi} = 1\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = 0\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left( \\eta + \\epsilon \\sin(\\pi \\xi)\\sin(\\pi \\eta) \\right) = \\epsilon \\pi \\cos(\\pi \\xi)\\sin(\\pi \\eta)\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left( \\eta + \\epsilon \\sin(\\pi \\xi)\\sin(\\pi \\eta) \\right) = 1 + \\epsilon \\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta)\n$$\nSubstituting these derivatives into the formula for the Jacobian determinant, we obtain the explicit expression for $J$:\n$$\nJ(\\xi,\\eta;\\epsilon) = (1) \\cdot (1 + \\epsilon \\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta)) - (0) \\cdot (\\epsilon \\pi \\cos(\\pi \\xi)\\sin(\\pi \\eta))\n$$\n$$\nJ(\\xi,\\eta;\\epsilon) = 1 + \\epsilon \\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta)\n$$\nFor the transformation to be valid and avoid grid tangling, the Jacobian determinant must remain strictly positive throughout the domain, i.e., $J(\\xi,\\eta;\\epsilon) > 0$ for all $(\\xi,\\eta) \\in [0,1]\\times[0,1]$. A value of $J=0$ signifies a singular transformation where grid lines collapse, and $J<0$ implies a local inversion of the coordinate system, both of which constitute grid tangling. Therefore, we must satisfy the inequality:\n$$\n1 + \\epsilon \\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta) > 0\n$$\nTo find the tightest bound on $|\\epsilon|$, we must find the minimum and maximum values of the term $A(\\xi,\\eta) = \\sin(\\pi \\xi)\\cos(\\pi \\eta)$ over the domain $(\\xi,\\eta) \\in [0,1]\\times[0,1]$.\nFor $\\xi \\in [0,1]$, the term $\\sin(\\pi \\xi)$ is always non-negative, ranging from $0$ to $1$. Its maximum value is $1$ at $\\xi = 1/2$.\nFor $\\eta \\in [0,1]$, the term $\\cos(\\pi \\eta)$ ranges from $1$ (at $\\eta=0$) to $-1$ (at $\\eta=1$).\n\nThe maximum value of $A(\\xi,\\eta)$ occurs when $\\sin(\\pi \\xi)$ is maximal and $\\cos(\\pi \\eta)$ is maximal:\n$$\n\\max(A) = \\max(\\sin(\\pi \\xi)) \\cdot \\max(\\cos(\\pi \\eta)) = (1) \\cdot (1) = 1\n$$\nThis occurs when $\\xi = 1/2$ and $\\eta = 0$, i.e., at the point $(1/2, 0)$.\n\nThe minimum value of $A(\\xi,\\eta)$ occurs when $\\sin(\\pi \\xi)$ is maximal and $\\cos(\\pi \\eta)$ is minimal:\n$$\n\\min(A) = \\max(\\sin(\\pi \\xi)) \\cdot \\min(\\cos(\\pi \\eta)) = (1) \\cdot (-1) = -1\n$$\nThis occurs when $\\xi = 1/2$ and $\\eta = 1$, i.e., at the point $(1/2, 1)$.\n\nNow we analyze the inequality $1 + \\epsilon \\pi A(\\xi,\\eta) > 0$ based on the sign of $\\epsilon$.\n\nCase 1: $\\epsilon > 0$.\nThe term $\\epsilon \\pi A(\\xi,\\eta)$ can be negative. The inequality must hold even for the most restrictive condition, which corresponds to the minimum value of $A(\\xi,\\eta) = -1$.\n$$\n1 + \\epsilon \\pi (-1) > 0 \\implies 1 - \\epsilon \\pi > 0 \\implies \\epsilon \\pi  1 \\implies \\epsilon  \\frac{1}{\\pi}\n$$\n\nCase 2: $\\epsilon  0$.\nThe term $\\epsilon \\pi A(\\xi,\\eta)$ can be positive. The inequality must hold even for the most restrictive condition, which corresponds to the maximum value of $A(\\xi,\\eta) = 1$. Let $\\epsilon = -|\\epsilon|$.\n$$\n1 + \\epsilon \\pi (1) > 0 \\implies 1 - |\\epsilon| \\pi > 0 \\implies |\\epsilon| \\pi  1 \\implies |\\epsilon|  \\frac{1}{\\pi}\n$$\n\nCombining both cases, the condition for the Jacobian to be strictly positive everywhere in the domain is $|\\epsilon|  1/\\pi$. The tightest upper bound on the magnitude of $\\epsilon$ is the value at which the Jacobian first reaches zero. This occurs when $|\\epsilon| = 1/\\pi$. Therefore, the maximum allowable magnitude for $\\epsilon$ is $1/\\pi$.\n\nThe locations $(\\xi,\\eta)$ where the Jacobian approaches zero as $|\\epsilon|$ approaches its maximal value, $1/\\pi$, are the points where the term $\\sin(\\pi \\xi)\\cos(\\pi \\eta)$ reaches its extremal values.\n- If $\\epsilon \\to 1/\\pi$, the Jacobian becomes zero when $1 + (1/\\pi)\\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta) = 0$, which simplifies to $\\sin(\\pi \\xi)\\cos(\\pi \\eta) = -1$. This occurs at $(\\xi, \\eta) = (1/2, 1)$.\n- If $\\epsilon \\to -1/\\pi$, the Jacobian becomes zero when $1 - (1/\\pi)\\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta) = 0$, which simplifies to $\\sin(\\pi \\xi)\\cos(\\pi \\eta) = 1$. This occurs at $(\\xi, \\eta) = (1/2, 0)$.\n\nThese locations are critical from the standpoint of grid tangling because they are the points where the local mapping first becomes singular. At these points, $J = \\frac{\\partial y}{\\partial \\eta} = 0$. This means that for a line of constant $\\xi$, the physical coordinate $y$ ceases to be a monotonic function of $\\eta$. A zero derivative marks the onset of folding, where two distinct points in the computational grid $(\\xi, \\eta_1)$ and $(\\xi, \\eta_2)$ could map to the same physical point $(x,y)$, destroying the one-to-one nature of the mapping and causing the grid to tangle.",
            "answer": "$$\\boxed{\\frac{1}{\\pi}}$$"
        },
        {
            "introduction": "With the concept of grid validity established, we now turn to the constructive process of generating structured grids for complex geometries. Transfinite Interpolation (TFI) is a powerful algebraic method that generates a smooth interior grid by blending information from the domain's boundaries. In this practice , you will derive a TFI mapping from first principles and then quantify the grid's orthogonality, directly connecting the properties of the boundary curves to the quality of the resulting mesh.",
            "id": "3987841",
            "problem": "Consider a two-dimensional parametric mapping from the unit square $[0,1] \\times [0,1]$ with parameters $(\\xi,\\eta)$ to a physical planar domain suitable for simulating steady heat conduction in a thin plate with slightly deformed boundaries. The mapping is constructed by Transfinite Interpolation (TFI), also known as the Coons patch, using four boundary curves that interpolate positions along the domain edges. Let the four boundary curves be defined as follows:\n- Bottom boundary at $\\eta = 0$: $D_{1}(\\xi) = \\big(\\xi,\\, d\\,\\xi(1-\\xi)\\big)$.\n- Top boundary at $\\eta = 1$: $D_{2}(\\xi) = \\big(\\xi,\\, 1 + a\\,\\xi(1-\\xi)\\big)$.\n- Left boundary at $\\xi = 0$: $C_{1}(\\eta) = \\big(b\\,\\eta(1-\\eta),\\, \\eta\\big)$.\n- Right boundary at $\\xi = 1$: $C_{2}(\\eta) = \\big(1 + c\\,\\eta(1-\\eta),\\, \\eta\\big)$.\n\nThese curves satisfy positional compatibility at the four corners, i.e., $D_{1}(0) = C_{1}(0)$, $D_{1}(1) = C_{2}(0)$, $D_{2}(0) = C_{1}(1)$, and $D_{2}(1) = C_{2}(1)$, but their tangent vectors at the corners are generally incompatible (non-orthogonal), which can introduce grid orthogonality error near the corners.\n\nStarting from first principles of parametric mappings and boundary interpolation, and without assuming any shortcut formulas for the interior construction, derive the TFI expressions for the interior mapping $\\mathbf{X}(\\xi,\\eta) = \\big(x(\\xi,\\eta),\\,y(\\xi,\\eta)\\big)$ that interpolate all four boundaries and recover the four corner points consistently. Then, taking the grid orthogonality measure to be the cosine of the angle between the parametric coordinate directions, defined by\n$$\nE(\\xi,\\eta) = \\frac{\\big|\\mathbf{X}_{\\xi}(\\xi,\\eta) \\cdot \\mathbf{X}_{\\eta}(\\xi,\\eta)\\big|}{\\|\\mathbf{X}_{\\xi}(\\xi,\\eta)\\|\\,\\|\\mathbf{X}_{\\eta}(\\xi,\\eta)\\|},\n$$\nquantify the orthogonality error introduced by corner tangent incompatibility at the lower-left corner $(\\xi,\\eta) = (0,0)$.\n\nUse the parameter values $a = 0.3$, $b = 0.2$, $c = -0.25$, and $d = 0.25$, and evaluate $E(0,0)$ as a single real number. Express your final answer as a dimensionless decimal and round your result to four significant figures.",
            "solution": "The problem requires the derivation of a Transfinite Interpolation (TFI) mapping and the subsequent calculation of a grid orthogonality measure at a specific corner. The solution proceeds by first principles, as stipulated.\n\nA two-dimensional parametric mapping $\\mathbf{X}(\\xi, \\eta) = (x(\\xi,\\eta), y(\\xi,\\eta))$ is constructed to map the unit square in the parametric domain, $(\\xi, \\eta) \\in [0, 1] \\times [0, 1]$, to a physical domain. The mapping must interpolate the four specified boundary curves: $D_1(\\xi)$ at $\\eta=0$, $D_2(\\xi)$ at $\\eta=1$, $C_1(\\eta)$ at $\\xi=0$, and $C_2(\\eta)$ at $\\xi=1$.\n\nTransfinite Interpolation, or the Coons patch, constructs the interior mapping $\\mathbf{X}(\\xi,\\eta)$ from a Boolean sum of projectors. We define two projectors, $P_\\xi$ and $P_\\eta$, which interpolate between pairs of curves. Using linear blending functions $L_0(\\zeta) = 1-\\zeta$ and $L_1(\\zeta) = \\zeta$, the projectors are:\n$$ P_{\\xi}[\\mathbf{X}](\\xi, \\eta) = (1-\\xi)\\mathbf{X}(0, \\eta) + \\xi\\mathbf{X}(1, \\eta) $$\n$$ P_{\\eta}[\\mathbf{X}](\\xi, \\eta) = (1-\\eta)\\mathbf{X}(\\xi, 0) + \\eta\\mathbf{X}(\\xi, 1) $$\nSubstituting the boundary conditions $\\mathbf{X}(0, \\eta) = C_1(\\eta)$, $\\mathbf{X}(1, \\eta) = C_2(\\eta)$, $\\mathbf{X}(\\xi, 0) = D_1(\\xi)$, and $\\mathbf{X}(\\xi, 1) = D_2(\\xi)$, we get:\n$$ P_{\\xi}(\\xi, \\eta) = (1-\\xi)C_1(\\eta) + \\xi C_2(\\eta) $$\n$$ P_{\\eta}(\\xi, \\eta) = (1-\\eta)D_1(\\xi) + \\eta D_2(\\xi) $$\nThe TFI mapping is the Boolean sum of these projectors, $\\mathbf{X} = P_\\xi \\oplus P_\\eta$, which is defined as:\n$$ \\mathbf{X}(\\xi, \\eta) = P_\\xi(\\xi, \\eta) + P_\\eta(\\xi, \\eta) - P_\\xi P_\\eta(\\xi, \\eta) $$\nThe product projector $P_\\xi P_\\eta$ is found by applying $P_\\xi$ to the result of $P_\\eta$:\n$$ P_\\xi P_\\eta(\\xi, \\eta) = P_\\xi \\big[ (1-\\eta)D_1(\\xi) + \\eta D_2(\\xi) \\big] = (1-\\xi)\\big[ (1-\\eta)D_1(0) + \\eta D_2(0) \\big] + \\xi\\big[ (1-\\eta)D_1(1) + \\eta D_2(1) \\big] $$\nThe problem states that the boundaries are positionally compatible at the corners, so we have:\n$\\mathbf{X}(0,0) = D_1(0) = C_1(0) = (0,0)$\n$\\mathbf{X}(1,0) = D_1(1) = C_2(0) = (1,0)$\n$\\mathbf{X}(0,1) = D_2(0) = C_1(1) = (0,1)$\n$\\mathbf{X}(1,1) = D_2(1) = C_2(1) = (1,1)$\nSubstituting these into the expression for $P_\\xi P_\\eta$ yields the bilinear interpolation of the four corner points:\n$$ P_\\xi P_\\eta(\\xi, \\eta) = (1-\\xi)(1-\\eta)\\mathbf{X}(0,0) + \\xi(1-\\eta)\\mathbf{X}(1,0) + (1-\\xi)\\eta\\mathbf{X}(0,1) + \\xi\\eta\\mathbf{X}(1,1) $$\nThe full TFI mapping is therefore:\n$$ \\mathbf{X}(\\xi, \\eta) = (1-\\xi)C_1(\\eta) + \\xi C_2(\\eta) + (1-\\eta)D_1(\\xi) + \\eta D_2(\\xi) - \\big[ (1-\\xi)(1-\\eta)\\mathbf{X}(0,0) + \\xi(1-\\eta)\\mathbf{X}(1,0) + (1-\\xi)\\eta\\mathbf{X}(0,1) + \\xi\\eta\\mathbf{X}(1,1) \\big] $$\nNow, we substitute the given boundary curve definitions into this formula. The mapping $\\mathbf{X}(\\xi,\\eta)$ has components $(x(\\xi,\\eta), y(\\xi,\\eta))$.\nFor the $x$-component:\n$x_{C1}(\\eta) = b\\eta(1-\\eta)$, $x_{C2}(\\eta) = 1+c\\eta(1-\\eta)$, $x_{D1}(\\xi) = \\xi$, $x_{D2}(\\xi) = \\xi$.\n$x_{00}=0$, $x_{10}=1$, $x_{01}=0$, $x_{11}=1$.\n$$ x(\\xi,\\eta) = (1-\\xi)b\\eta(1-\\eta) + \\xi(1+c\\eta(1-\\eta)) + (1-\\eta)\\xi + \\eta\\xi - \\big[ \\xi(1-\\eta) + \\xi\\eta \\big] $$\n$$ x(\\xi,\\eta) = (1-\\xi)b\\eta(1-\\eta) + \\xi + \\xi c\\eta(1-\\eta) + \\xi - \\xi = \\xi + (1-\\xi)b\\eta(1-\\eta) + \\xi c\\eta(1-\\eta) $$\nFor the $y$-component:\n$y_{C1}(\\eta) = \\eta$, $y_{C2}(\\eta) = \\eta$, $y_{D1}(\\xi) = d\\xi(1-\\xi)$, $y_{D2}(\\xi) = 1+a\\xi(1-\\xi)$.\n$y_{00}=0$, $y_{10}=0$, $y_{01}=1$, $y_{11}=1$.\n$$ y(\\xi,\\eta) = (1-\\xi)\\eta + \\xi\\eta + (1-\\eta)d\\xi(1-\\xi) + \\eta(1+a\\xi(1-\\xi)) - \\big[ (1-\\xi)\\eta + \\xi\\eta \\big] $$\n$$ y(\\xi,\\eta) = \\eta + (1-\\eta)d\\xi(1-\\xi) + \\eta + \\eta a\\xi(1-\\xi) - \\eta = \\eta + (1-\\eta)d\\xi(1-\\xi) + \\eta a\\xi(1-\\xi) $$\nNext, we compute the tangent vectors $\\mathbf{X}_{\\xi} = \\frac{\\partial \\mathbf{X}}{\\partial \\xi}$ and $\\mathbf{X}_{\\eta} = \\frac{\\partial \\mathbf{X}}{\\partial \\eta}$.\n$$ \\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\big[ \\xi + b\\eta(1-\\eta) - \\xi b\\eta(1-\\eta) + \\xi c\\eta(1-\\eta) \\big] = 1 - b\\eta(1-\\eta) + c\\eta(1-\\eta) = 1 + (c-b)\\eta(1-\\eta) $$\n$$ \\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\big[ \\eta + d(1-\\eta)(\\xi-\\xi^2) + a\\eta(\\xi-\\xi^2) \\big] = d(1-\\eta)(1-2\\xi) + a\\eta(1-2\\xi) = (d(1-\\eta)+a\\eta)(1-2\\xi) $$\n$$ \\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\big[ \\xi + b(1-\\xi)(\\eta-\\eta^2) + c\\xi(\\eta-\\eta^2) \\big] = b(1-\\xi)(1-2\\eta) + c\\xi(1-2\\eta) = (b(1-\\xi)+c\\xi)(1-2\\eta) $$\n$$ \\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\big[ \\eta + d\\xi(1-\\xi) - \\eta d\\xi(1-\\xi) + \\eta a\\xi(1-\\xi) \\big] = 1 - d\\xi(1-\\xi) + a\\xi(1-\\xi) = 1 + (a-d)\\xi(1-\\xi) $$\nThe tangent vectors are:\n$$ \\mathbf{X}_{\\xi}(\\xi,\\eta) = \\begin{pmatrix} 1 + (c-b)\\eta(1-\\eta) \\\\ (d(1-\\eta) + a\\eta)(1-2\\xi) \\end{pmatrix}, \\quad \\mathbf{X}_{\\eta}(\\xi,\\eta) = \\begin{pmatrix} (b(1-\\xi) + c\\xi)(1-2\\eta) \\\\ 1 + (a-d)\\xi(1-\\xi) \\end{pmatrix} $$\nWe evaluate these vectors at the lower-left corner $(\\xi,\\eta)=(0,0)$:\n$$ \\mathbf{X}_{\\xi}(0,0) = \\begin{pmatrix} 1 + (c-b)(0) \\\\ (d(1)+a(0))(1) \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ d \\end{pmatrix} $$\n$$ \\mathbf{X}_{\\eta}(0,0) = \\begin{pmatrix} (b(1)+c(0))(1) \\\\ 1+(a-d)(0) \\end{pmatrix} = \\begin{pmatrix} b \\\\ 1 \\end{pmatrix} $$\nThe orthogonality measure $E(\\xi,\\eta)$ is the cosine of the angle between these vectors. At $(0,0)$:\n$$ E(0,0) = \\frac{\\big|\\mathbf{X}_{\\xi}(0,0) \\cdot \\mathbf{X}_{\\eta}(0,0)\\big|}{\\|\\mathbf{X}_{\\xi}(0,0)\\|\\,\\|\\mathbf{X}_{\\eta}(0,0)\\|} $$\nWe compute the dot product and norms:\n$$ \\mathbf{X}_{\\xi}(0,0) \\cdot \\mathbf{X}_{\\eta}(0,0) = \\begin{pmatrix} 1 \\\\ d \\end{pmatrix} \\cdot \\begin{pmatrix} b \\\\ 1 \\end{pmatrix} = 1 \\cdot b + d \\cdot 1 = b+d $$\n$$ \\|\\mathbf{X}_{\\xi}(0,0)\\| = \\sqrt{1^2 + d^2} = \\sqrt{1+d^2} $$\n$$ \\|\\mathbf{X}_{\\eta}(0,0)\\| = \\sqrt{b^2 + 1^2} = \\sqrt{1+b^2} $$\nSubstituting these into the expression for $E(0,0)$:\n$$ E(0,0) = \\frac{|b+d|}{\\sqrt{1+d^2}\\sqrt{1+b^2}} $$\nNow, we substitute the given parameter values: $a=0.3$, $b=0.2$, $c=-0.25$, and $d=0.25$. Note that $a$ and $c$ are not required for this specific calculation.\n$$ b+d = 0.2 + 0.25 = 0.45 $$\n$$ 1+d^2 = 1 + (0.25)^2 = 1 + 0.0625 = 1.0625 $$\n$$ 1+b^2 = 1 + (0.2)^2 = 1 + 0.04 = 1.04 $$\n$$ E(0,0) = \\frac{|0.45|}{\\sqrt{1.0625}\\sqrt{1.04}} = \\frac{0.45}{\\sqrt{1.0625 \\times 1.04}} = \\frac{0.45}{\\sqrt{1.105}} $$\nCalculating the numerical value:\n$$ E(0,0) \\approx \\frac{0.45}{1.0511898} \\approx 0.4280709... $$\nRounding the result to four significant figures, we obtain $0.4281$.",
            "answer": "$$\n\\boxed{0.4281}\n$$"
        },
        {
            "introduction": "While structured grids are efficient, unstructured grids offer superior flexibility for highly complex geometries. However, this flexibility comes with the challenge of ensuring high-quality elements throughout the domain. This practical exercise  delves into this challenge by comparing two cornerstone triangulation algorithms: the optimality-driven Delaunay method and a constructive Advancing Front technique. By generating meshes and quantifying their quality using the critical minimum-angle metric, you will gain a tangible understanding of how different generation strategies impact the suitability of a mesh for accurate thermal simulations.",
            "id": "3987848",
            "problem": "You are to construct and compare two planar triangular meshes for curved boundaries and quantify differences in triangle quality using the minimum-angle metric. The context is computational thermal engineering, where mesh quality influences numerical accuracy and stability for heat transfer simulations. The two meshes are generated using Delaunay Triangulation (DT) and the Advancing Front Method (AFM), respectively. The metric to be compared is the minimum internal angle of each triangle, expressed in degrees.\n\nStarting from Euclidean geometry, the internal angles of a triangle are well-defined based on the lengths of its sides and the dot product of its edges. For a triangle with vertices at position vectors $\\mathbf{p}_0$, $\\mathbf{p}_1$, and $\\mathbf{p}_2$ in $\\mathbb{R}^2$, the internal angles at each vertex can be derived from the vector directions and their norms, thereby providing a fundamental basis to compute the minimum angle in each triangle.\n\nYou must generate identical node sets for both DT and AFM so that any difference in triangle quality arises purely from the connectivity strategy. For each test case, perform the following steps:\n\n1. Node set generation:\n   - Curved boundary definitions:\n     - Circle of radius $R$ using parametric form $\\mathbf{b}(\\theta) = (R\\cos\\theta, R\\sin\\theta)$.\n     - Ellipse with semi-axes $a$ and $b$ using $\\mathbf{e}(\\theta) = (a\\cos\\theta, b\\sin\\theta)$.\n   - Discretize the boundary with $N$ equally spaced points using $\\theta_j = 2\\pi j/N$ for $j=0,1,\\dots,N-1$.\n   - Generate $L-1$ concentric interior rings defined by scaled radii $r_\\ell = 1 - \\ell/L$ for $\\ell=1,2,\\dots,L-1$ (uniform radial grading), and parameterize the rings with the same $N$ angles $\\theta_j$. For the circle, points are $(R r_\\ell \\cos\\theta_j, R r_\\ell \\sin\\theta_j)$. For the ellipse, points are $(a r_\\ell \\cos\\theta_j, b r_\\ell \\sin\\theta_j)$.\n   - Include a single center node at $(0,0)$ to close the front.\n   - Use the same node set for DT and AFM.\n\n2. Mesh construction:\n   - DT mesh: Compute the Delaunay triangulation of the node set in $\\mathbb{R}^2$.\n   - AFM mesh: Construct triangles by connecting adjacent rings in a layered fashion. For ring index $\\ell$ and angle index $j$ (with $j$ taken modulo $N$), create two triangles per segment:\n     - $(\\ell,j)\\rightarrow(\\ell+1,j)\\rightarrow(\\ell+1,j+1)$,\n     - $(\\ell,j)\\rightarrow(\\ell+1,j+1)\\rightarrow(\\ell,j+1)$,\n     and finally triangulate the innermost ring to the center by fans $(L-1,j)\\rightarrow\\text{center}\\rightarrow(L-1,j+1)$.\n\n3. Triangle minimum-angle metric:\n   - For each triangle, compute all three internal angles using Euclidean vector operations and the inverse cosine function, and take the minimum angle in degrees. That is, for each triangle $T$, compute $\\alpha_{\\min}(T)$ in degrees.\n\n4. Quantification of differences:\n   - For each mesh, compute:\n     - The arithmetic mean of the minimum angles: $\\mu = \\frac{1}{M}\\sum_{k=1}^{M} \\alpha_{\\min}(T_k)$, where $M$ is the number of triangles.\n     - The worst-case minimum angle: $\\omega = \\min_{k=1,\\dots,M} \\alpha_{\\min}(T_k)$.\n   - Compute differences between DT and AFM for the same node set:\n     - $\\Delta\\mu = \\mu_{\\text{DT}} - \\mu_{\\text{AFM}}$,\n     - $\\Delta\\omega = \\omega_{\\text{DT}} - \\omega_{\\text{AFM}}$.\n   - All angles must be expressed in degrees.\n\nTest suite:\nProvide three scientifically sound test cases that exercise different aspects of the mesh generation and quality assessment.\n\n- Test case 1 (happy path, circle, moderate resolution): $R=1$, $N=64$, $L=8$.\n- Test case 2 (ellipse, anisotropy due to geometry): $a=1.5$, $b=1$, $N=64$, $L=8$.\n- Test case 3 (boundary condition, coarse resolution): $R=1$, $N=16$, $L=3$.\n\nYour program must implement the above specification, compute $\\Delta\\mu$ and $\\Delta\\omega$ for each test case, and output the results in a single line. The final output format must be a comma-separated list enclosed in square brackets containing the values ordered as $[\\Delta\\mu_1,\\Delta\\omega_1,\\Delta\\mu_2,\\Delta\\omega_2,\\Delta\\mu_3,\\Delta\\omega_3]$, where the subscript denotes the test case index ($1$ to $3$). All angle quantities must be in degrees, and the floats should be printed directly without rounding adjustments beyond the programming languageâ€™s default behavior.",
            "solution": "The posed problem is scientifically sound, mathematically well-defined, and computationally feasible. It addresses a fundamental task in computational physics and engineering: the generation and quality assessment of meshes for numerical simulations. The problem specifies two distinct and standard meshing strategies, Delaunay Triangulation (DT) and a structured Advancing Front Method (AFM), to be applied to an identical set of nodes. A rigorous comparison is then performed using a standard mesh quality metric, the minimum internal angle. All parameters, geometric definitions, and algorithms are specified with sufficient precision to permit a unique and verifiable solution. Thus, the problem is valid, and we proceed with a reasoned solution.\n\nThe core of the problem lies in comparing the geometric quality of two different triangulations of the same point set. The quality of a triangular mesh is paramount in numerical methods like the Finite Element Method (FEM) or Finite Volume Method (FVM), commonly used in computational thermal engineering. Poor quality triangles, particularly those with very small internal angles (so-called \"sliver\" or \"degenerate\" triangles), can lead to ill-conditioned numerical systems, reduced accuracy, and slower convergence of iterative solvers.\n\n**1. Node Set Generation**\n\nTo ensure a direct comparison of the triangulation connectivity, an identical set of nodes is generated for both the DT and AFM approaches for each test case. The nodes are distributed within a planar domain defined by a curved boundary. The generation process is as follows:\n\n- A set of $N$ angular positions is defined by $\\theta_j = \\frac{2\\pi j}{N}$ for $j=0, 1, \\dots, N-1$.\n- For a given geometry (circle or ellipse), the boundary is discretized using these angles. The boundary itself corresponds to a radial scaling factor of $1$.\n- $L-1$ concentric interior rings are generated. The rings are graded uniformly in the radial direction. The scaling factor for the $\\ell$-th ring (where $\\ell=1, \\dots, L-1$) is given by $r_\\ell = 1 - \\ell/L$. The outermost boundary can be considered ring $\\ell=0$ with $r_0=1$. This gives a total of $L$ rings.\n- For a circle of radius $R$, a point on ring $\\ell$ ($0 \\le \\ell  L$) at angle $\\theta_j$ is $\\mathbf{p}_{\\ell,j} = ((1 - \\ell/L)R\\cos\\theta_j, (1 - \\ell/L)R\\sin\\theta_j)$.\n- for an ellipse with semi-axes $a$ and $b$, a point is $\\mathbf{p}_{\\ell,j} = ((1 - \\ell/L)a\\cos\\theta_j, (1 - \\ell/L)b\\sin\\theta_j)$.\n- A single node is placed at the origin $(0,0)$ to serve as the center point, which is necessary for closing the mesh at the domain's interior.\n- The total number of nodes is $N \\times L + 1$.\n\n**2. Mesh Construction Methodologies**\n\nWith the node set defined, two distinct triangulation algorithms are applied.\n\n**2.1. Delaunay Triangulation (DT)**\nThe Delaunay triangulation is a canonical method in computational geometry. For a given set of points $P$ in a plane, a triangulation $\\text{DT}(P)$ is a Delaunay triangulation if no point in $P$ is inside the circumcircle of any triangle in $\\text{DT}(P)$. This \"empty circumcircle\" property has the desirable effect of maximizing the minimum angle of all triangles in the mesh, thereby avoiding skinny triangles whenever possible. It represents an optimal solution in terms of this particular quality metric. We will compute the DT using the `scipy.spatial.Delaunay` class, which implements an efficient algorithm (typically Quickhull) for this purpose.\n\n**2.2. Advancing Front Method (AFM)**\nThe specific procedure described in the problem is a structured, layer-by-layer triangulation, which can be seen as a simplified form of an advancing front method. The \"front\" in this case is the boundary of each concentric ring. The algorithm proceeds as follows:\n- For each layer between an outer ring $\\ell$ and an inner ring $\\ell+1$ (for $\\ell=0, \\dots, L-2$), the quadrilaterals formed by adjacent nodes $(\\mathbf{p}_{\\ell,j}, \\mathbf{p}_{\\ell,j+1}, \\mathbf{p}_{\\ell+1,j+1}, \\mathbf{p}_{\\ell+1,j})$ are each divided into two triangles. The problem specifies the division:\n  - Triangle 1: Connecting vertices $(\\ell, j)$, $(\\ell+1, j)$, and $(\\ell+1, j+1)$.\n  - Triangle 2: Connecting vertices $(\\ell, j)$, $(\\ell+1, j+1)$, and $(\\ell, j+1)$.\n  The index $j$ is treated modulo $N$ to handle the closed-loop nature of the rings.\n- After triangulating the $L-1$ layers, the innermost ring (ring $L-1$) is triangulated to the center point. This is done by creating a \"fan\" of triangles, where each triangle is formed by two adjacent nodes on the innermost ring and the center point: $(\\ell=L-1, j)$, center, and $(\\ell=L-1, j+1)$.\nThis structured approach creates a highly regular grid but its quality is constrained by the predefined connectivity, unlike the adaptive nature of DT.\n\n**3. Triangle Quality Assessment**\n\nTo quantify mesh quality, the minimum internal angle of each triangle is computed. For a triangle with vertices at position vectors $\\mathbf{p}_0$, $\\mathbf{p}_1$, and $\\mathbf{p}_2$, the angle $\\alpha_0$ at vertex $\\mathbf{p}_0$ is found using the dot product of the edge vectors originating from that vertex, $\\mathbf{v}_{01} = \\mathbf{p}_1 - \\mathbf{p}_0$ and $\\mathbf{v}_{02} = \\mathbf{p}_2 - \\mathbf{p}_0$. The angle is given by:\n$$ \\alpha_0 = \\arccos\\left(\\frac{\\mathbf{v}_{01} \\cdot \\mathbf{v}_{02}}{\\|\\mathbf{v}_{01}\\| \\|\\mathbf{v}_{02}\\|}\\right) $$\nThe other two angles, $\\alpha_1$ and $\\alpha_2$, are computed similarly. The quality metric for a single triangle $T_k$ is its minimum angle, $\\alpha_{\\min}(T_k) = \\min(\\alpha_0, \\alpha_1, \\alpha_2)$. The result from $\\arccos$ is in radians and must be converted to degrees by multiplying by $180/\\pi$.\n\n**4. Comparative Analysis**\n\nTo compare the overall quality of the DT and AFM meshes, we compute two aggregate statistics for each mesh:\n- The arithmetic mean of the minimum angles over all $M$ triangles in the mesh: $\\mu = \\frac{1}{M}\\sum_{k=1}^{M} \\alpha_{\\min}(T_k)$. This metric indicates the average triangle quality.\n- The global minimum angle across all triangles: $\\omega = \\min_{k=1,\\dots,M} \\alpha_{\\min}(T_k)$. This metric identifies the single worst triangle in the mesh, which is often a critical factor for numerical stability.\n\nThe final comparison is captured by the differences in these metrics between the two methods:\n- $\\Delta\\mu = \\mu_{\\text{DT}} - \\mu_{\\text{AFM}}$\n- $\\Delta\\omega = \\omega_{\\text{DT}} - \\omega_{\\text{AFM}}$\n\nPositive values for $\\Delta\\mu$ and $\\Delta\\omega$ indicate that the Delaunay triangulation produced a mesh with better average quality and a better worst-case triangle, respectively, which is generally expected due to its angle-optimizing property. The implementation will perform these calculations for the specified test cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy.spatial import Delaunay\n\ndef solve():\n    \"\"\"\n    Main function to run the mesh comparison for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Circle, moderate resolution\n        {'shape': 'circle', 'params': {'R': 1.0}, 'N': 64, 'L': 8},\n        # Case 2: Ellipse, anisotropy\n        {'shape': 'ellipse', 'params': {'a': 1.5, 'b': 1.0}, 'N': 64, 'L': 8},\n        # Case 3: Circle, coarse resolution\n        {'shape': 'circle', 'params': {'R': 1.0}, 'N': 16, 'L': 3},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Generate Node Set\n        points = generate_nodes(case['shape'], case['params'], case['N'], case['L'])\n\n        # Step 2: Build Meshes\n        dt_triangles = build_dt_mesh(points)\n        afm_triangles = build_afm_mesh(case['N'], case['L'])\n\n        # Step 3  4: Compute Quality Metrics and Differences\n        mu_dt, omega_dt = compute_mesh_quality(points, dt_triangles)\n        mu_afm, omega_afm = compute_mesh_quality(points, afm_triangles)\n\n        delta_mu = mu_dt - mu_afm\n        delta_omega = omega_dt - omega_afm\n\n        results.extend([delta_mu, delta_omega])\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef generate_nodes(shape, params, N, L):\n    \"\"\"\n    Generates the node set for a given geometry.\n    The nodes are ordered by ring, then by angle.\n    Ring 0 is the outermost boundary, ring L-1 is the innermost.\n    The last point is the center at (0,0).\n    \"\"\"\n    num_points = N * L + 1\n    points = np.zeros((num_points, 2))\n    thetas = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n    for l in range(L):\n        scale = 1.0 - l / L\n        if shape == 'circle':\n            R = params['R']\n            x_coords = R * scale * np.cos(thetas)\n            y_coords = R * scale * np.sin(thetas)\n        elif shape == 'ellipse':\n            a, b = params['a'], params['b']\n            x_coords = a * scale * np.cos(thetas)\n            y_coords = b * scale * np.sin(thetas)\n        \n        start_idx = l * N\n        end_idx = start_idx + N\n        points[start_idx:end_idx, 0] = x_coords\n        points[start_idx:end_idx, 1] = y_coords\n\n    # Center node is already (0,0) by np.zeros initialization\n    return points\n\n\ndef build_dt_mesh(points):\n    \"\"\"\n    Computes the Delaunay triangulation for a given set of points.\n    \"\"\"\n    delaunay_tri = Delaunay(points)\n    return delaunay_tri.simplices\n\n\ndef build_afm_mesh(N, L):\n    \"\"\"\n    Constructs the triangulation using the structured Advancing Front Method.\n    \"\"\"\n    triangles = []\n    \n    # Layered triangulation between concentric rings\n    for l in range(L - 1):\n        for j in range(N):\n            j_plus_1 = (j + 1) % N\n            \n            # Indices for the four nodes of the \"quad\"\n            idx_lj = l * N + j\n            idx_lj1 = l * N + j_plus_1\n            idx_l1j = (l + 1) * N + j\n            idx_l1j1 = (l + 1) * N + j_plus_1\n            \n            # Create two triangles from the quad\n            # Triangle 1: (l,j) - (l+1,j) - (l+1,j+1)\n            triangles.append([idx_lj, idx_l1j, idx_l1j1])\n            # Triangle 2: (l,j) - (l+1,j+1) - (l,j+1)\n            triangles.append([idx_lj, idx_l1j1, idx_lj1])\n\n    # Fan triangulation for the innermost ring to the center\n    center_idx = N * L\n    innermost_ring_l = L - 1\n    for j in range(N):\n        j_plus_1 = (j + 1) % N\n        idx_L1j = innermost_ring_l * N + j\n        idx_L1j1 = innermost_ring_l * N + j_plus_1\n        \n        # Triangle: (L-1,j) - center - (L-1,j+1)\n        triangles.append([idx_L1j, center_idx, idx_L1j1])\n        \n    return np.array(triangles)\n\n\ndef compute_min_angle_of_triangle(p0, p1, p2):\n    \"\"\"\n    Computes the minimum internal angle of a single triangle in degrees.\n    \"\"\"\n    # Create edge vectors\n    v01 = p1 - p0\n    v02 = p2 - p0\n    v12 = p2 - p1\n\n    # Compute dot products and norms\n    dot_p0 = np.dot(v01, v02)\n    dot_p1 = np.dot(-v01, v12)\n    dot_p2 = np.dot(-v02, -v12)\n\n    norm_v01 = np.linalg.norm(v01)\n    norm_v02 = np.linalg.norm(v02)\n    norm_v12 = np.linalg.norm(v12)\n\n    # Avoid division by zero for degenerate triangles (collinear points)\n    if norm_v01 == 0 or norm_v02 == 0 or norm_v12 == 0:\n        return 0.0\n\n    # Calculate cosines of angles, clipping to handle floating point inaccuracies\n    cos_a0 = np.clip(dot_p0 / (norm_v01 * norm_v02), -1.0, 1.0)\n    cos_a1 = np.clip(dot_p1 / (norm_v01 * norm_v12), -1.0, 1.0)\n    \n    # The third angle is derived from the first two\n    # a2 = 180 - a0 - a1, however, direct computation is more robust\n    cos_a2 = np.clip(dot_p2 / (norm_v02 * norm_v12), -1.0, 1.0)\n    \n    # Calculate angles in radians and then convert to degrees\n    a0 = np.arccos(cos_a0)\n    a1 = np.arccos(cos_a1)\n    a2 = np.arccos(cos_a2)\n\n    angles_deg = np.rad2deg([a0, a1, a2])\n    \n    return np.min(angles_deg)\n\n\ndef compute_mesh_quality(points, triangles):\n    \"\"\"\n    Computes the mean and minimum of the minimum angles for all triangles in a mesh.\n    \"\"\"\n    min_angles = [\n        compute_min_angle_of_triangle(points[tri[0]], points[tri[1]], points[tri[2]])\n        for tri in triangles\n    ]\n    \n    min_angles = np.array(min_angles)\n    mean_min_angle = np.mean(min_angles)\n    worst_case_angle = np.min(min_angles)\n    \n    return mean_min_angle, worst_case_angle\n\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}