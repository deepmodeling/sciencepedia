{
    "hands_on_practices": [
        {
            "introduction": "计算网格生成本质上是一种坐标变换。一个有效的网格要求这种变换是单值的，以防止网格线交叉或折叠，即所谓的“网格缠结”现象。映射的雅可比行列式为此提供了一个数学判据，在整个域中保持为正的雅可比行列式可以保证一个有效且保持方向的网格。本练习  将引导您推导出一个映射保持有效的解析条件，将一个纯数学概念与计算模拟中的关键实践要求联系起来。",
            "id": "3987900",
            "problem": "在计算热工学中，维持计算域与物理域之间的一一映射对于避免传热数值模拟中的网格缠结至关重要。考虑一个用于控制浮力驱动腔体流动的节点聚集的二维代数网格变形。该变形通过以下方式将计算正方形 $(\\xi,\\eta)\\in [0,1]\\times[0,1]$ 映射到物理平面：\n$$\nx(\\xi,\\eta) = \\xi,\\qquad y(\\xi,\\eta) = \\eta + \\epsilon \\sin(\\pi \\xi)\\sin(\\pi \\eta),\n$$\n其中 $\\epsilon$ 是一个无量纲控制参数。\n\n从平面间映射的雅可比行列式定义以及二维双射映射的条件出发，推导该变换的雅可比行列式 $J(\\xi,\\eta;\\epsilon)$ 的显式表达式。利用此表达式确定 $|\\epsilon|$ 的最紧上界，使得映射在整个计算正方形内保持双射，确保在 $[0,1]\\times[0,1]$ 内任何地方都不会发生网格线交叉。在你的推理中，指出当 $|\\epsilon|$ 接近其最大允许值时，雅可比行列式趋于零的 $(\\xi,\\eta)$ 位置，并从网格缠结风险的角度解释为什么这些位置是关键的。\n\n作为你的最终答案，仅报告 $\\epsilon$ 的最大允许量值，以包含 $\\pi$ 的符号表达式形式给出。不要四舍五入。$\\epsilon$ 没有物理单位，是无量纲的。",
            "solution": "问题要求推导给定二维映射保持双射（确保无网格缠结）的条件。这涉及到计算变换的雅可比行列式，并找到参数 $\\epsilon$ 的约束条件，以防止行列式在指定域内变为零或改变符号。\n\n给定的变换根据以下函数将计算坐标 $(\\xi, \\eta)$ 从单位正方形 $[0,1]\\times[0,1]$ 映射到物理坐标 $(x,y)$：\n$$\nx(\\xi,\\eta) = \\xi\n$$\n$$\ny(\\xi,\\eta) = \\eta + \\epsilon \\sin(\\pi \\xi)\\sin(\\pi \\eta)\n$$\n如果一个连续可微映射的雅可比行列式在域的内部不改变符号且从不为零，则该映射在该域内保持双射（一一对应）。从 $(\\xi, \\eta)$ 到 $(x,y)$ 的变换的雅可比行列式 $J$ 定义为：\n$$\nJ(\\xi,\\eta;\\epsilon) = \\det \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta} - \\frac{\\partial x}{\\partial \\eta}\\frac{\\partial y}{\\partial \\xi}\n$$\n首先，我们计算变换函数的必要偏导数：\n$$\n\\frac{\\partial x}{\\partial \\xi} = 1\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = 0\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left( \\eta + \\epsilon \\sin(\\pi \\xi)\\sin(\\pi \\eta) \\right) = \\epsilon \\pi \\cos(\\pi \\xi)\\sin(\\pi \\eta)\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left( \\eta + \\epsilon \\sin(\\pi \\xi)\\sin(\\pi \\eta) \\right) = 1 + \\epsilon \\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta)\n$$\n将这些导数代入雅可比行列式的公式中，我们得到 $J$ 的显式表达式：\n$$\nJ(\\xi,\\eta;\\epsilon) = (1) \\cdot (1 + \\epsilon \\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta)) - (0) \\cdot (\\epsilon \\pi \\cos(\\pi \\xi)\\sin(\\pi \\eta))\n$$\n$$\nJ(\\xi,\\eta;\\epsilon) = 1 + \\epsilon \\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta)\n$$\n为使变换有效并避免网格缠结，雅可比行列式必须在整个域内保持严格为正，即对于所有 $(\\xi,\\eta) \\in [0,1]\\times[0,1]$，$J(\\xi,\\eta;\\epsilon) > 0$。$J=0$ 的值表示奇异变换，此时网格线会塌陷；而 $J  0$ 则意味着坐标系的局部反转，这两种情况都构成网格缠结。因此，我们必须满足不等式：\n$$\n1 + \\epsilon \\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta) > 0\n$$\n为了找到 $|\\epsilon|$ 的最紧边界，我们必须求出项 $A(\\xi,\\eta) = \\sin(\\pi \\xi)\\cos(\\pi \\eta)$ 在域 $(\\xi,\\eta) \\in [0,1]\\times[0,1]$ 上的最小值和最大值。\n对于 $\\xi \\in [0,1]$，项 $\\sin(\\pi \\xi)$ 始终为非负，范围从 $0$ 到 $1$。其最大值为 $1$，在 $\\xi = 1/2$ 时取得。\n对于 $\\eta \\in [0,1]$，项 $\\cos(\\pi \\eta)$ 的范围从 $1$（在 $\\eta=0$ 时）到 $-1$（在 $\\eta=1$ 时）。\n\n$A(\\xi,\\eta)$ 的最大值出现在 $\\sin(\\pi \\xi)$ 和 $\\cos(\\pi \\eta)$ 同时取最大值时：\n$$\n\\max(A) = \\max(\\sin(\\pi \\xi)) \\cdot \\max(\\cos(\\pi \\eta)) = (1) \\cdot (1) = 1\n$$\n这发生在 $\\xi = 1/2$ 和 $\\eta = 0$ 时，即在点 $(1/2, 0)$。\n\n$A(\\xi,\\eta)$ 的最小值出现在 $\\sin(\\pi \\xi)$ 取最大值而 $\\cos(\\pi \\eta)$ 取最小值时：\n$$\n\\min(A) = \\max(\\sin(\\pi \\xi)) \\cdot \\min(\\cos(\\pi \\eta)) = (1) \\cdot (-1) = -1\n$$\n这发生在 $\\xi = 1/2$ 和 $\\eta = 1$ 时，即在点 $(1/2, 1)$。\n\n现在我们根据 $\\epsilon$ 的符号来分析不等式 $1 + \\epsilon \\pi A(\\xi,\\eta) > 0$。\n\n情况1：$\\epsilon > 0$。\n项 $\\epsilon \\pi A(\\xi,\\eta)$ 可以为负。不等式必须在最严格的条件下也成立，这对应于 $A(\\xi,\\eta)$ 的最小值 $-1$。\n$$\n1 + \\epsilon \\pi (-1) > 0 \\implies 1 - \\epsilon \\pi > 0 \\implies \\epsilon \\pi  1 \\implies \\epsilon  \\frac{1}{\\pi}\n$$\n\n情况2：$\\epsilon  0$。\n项 $\\epsilon \\pi A(\\xi,\\eta)$ 可以为正。不等式必须在最严格的条件下也成立，这对应于 $A(\\xi,\\eta)$ 的最大值 $1$。令 $\\epsilon = -|\\epsilon|$。\n$$\n1 + \\epsilon \\pi (1) > 0 \\implies 1 - |\\epsilon| \\pi > 0 \\implies |\\epsilon| \\pi  1 \\implies |\\epsilon|  \\frac{1}{\\pi}\n$$\n\n综合两种情况，雅可比行列式在域内处处严格为正的条件是 $|\\epsilon|  1/\\pi$。$\\epsilon$ 量值的最紧上界是使雅可比行列式首次达到零的值。这发生在 $|\\epsilon| = 1/\\pi$ 时。因此，$\\epsilon$ 的最大允许量值为 $1/\\pi$。\n\n当 $|\\epsilon|$ 趋近其最大值 $1/\\pi$ 时，雅可比行列式趋近于零的 $(\\xi,\\eta)$ 位置，是项 $\\sin(\\pi \\xi)\\cos(\\pi \\eta)$ 达到其极值的点。\n- 如果 $\\epsilon \\to 1/\\pi$，雅可比行列式在 $1 + (1/\\pi)\\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta) = 0$ 时变为零，这可以简化为 $\\sin(\\pi \\xi)\\cos(\\pi \\eta) = -1$。这发生在 $(\\xi, \\eta) = (1/2, 1)$。\n- 如果 $\\epsilon \\to -1/\\pi$，雅可比行列式在 $1 - (1/\\pi)\\pi \\sin(\\pi \\xi)\\cos(\\pi \\eta) = 0$ 时变为零，这可以简化为 $\\sin(\\pi \\xi)\\cos(\\pi \\eta) = 1$。这发生在 $(\\xi, \\eta) = (1/2, 0)$。\n\n从网格缠结的角度来看，这些位置是关键的，因为它们是局部映射首次变为奇异的点。在这些点上，$J = \\partial y / \\partial \\eta = 0$。这意味着对于一条 $\\xi$ 为常数的线，物理坐标 $y$ 不再是 $\\eta$ 的单调函数。零导数标志着折叠的开始，此时计算网格中的两个不同点 $(\\xi, \\eta_1)$ 和 $(\\xi, \\eta_2)$ 可能会映射到同一个物理点 $(x,y)$，从而破坏了映射的一一对应性并导致网格缠结。",
            "answer": "$$\\boxed{\\frac{1}{\\pi}}$$"
        },
        {
            "introduction": "在理解了基本约束之后，我们转向一种能贴合复杂几何形状的结构化网格生成实用方法。超限插值（Transfinite Interpolation, TFI），或称库恩斯曲面（Coons patch），是实现此目的的一种经典而强大的技术，它通过融合域边界曲线的信息来构建内部网格。在本练习  中，您将从第一性原理出发推导TFI映射，并量化一个关键的网格质量度量——边界处的正交性，从而揭示边界曲线的定义如何影响最终的网格质量。",
            "id": "3987841",
            "problem": "考虑一个二维参数映射，它将带有参数 $(\\xi,\\eta)$ 的单位正方形 $[0,1] \\times [0,1]$ 映射到一个物理平面域上，该域适用于模拟具有轻微变形边界的薄板中的稳态热传导。该映射是使用四条边界曲线通过超限插值（TFI）（也称为 Coons 曲面）构建的，这些曲线对域边缘上的位置进行插值。设四条边界曲线定义如下：\n- 位于 $\\eta = 0$ 的底边界：$D_{1}(\\xi) = \\big(\\xi,\\, d\\,\\xi(1-\\xi)\\big)$。\n- 位于 $\\eta = 1$ 的顶边界：$D_{2}(\\xi) = \\big(\\xi,\\, 1 + a\\,\\xi(1-\\xi)\\big)$。\n- 位于 $\\xi = 0$ 的左边界：$C_{1}(\\eta) = \\big(b\\,\\eta(1-\\eta),\\, \\eta\\big)$。\n- 位于 $\\xi = 1$ 的右边界：$C_{2}(\\eta) = \\big(1 + c\\,\\eta(1-\\eta),\\, \\eta\\big)$。\n\n这些曲线在四个角点处满足位置相容性，即 $D_{1}(0) = C_{1}(0)$、$D_{1}(1) = C_{2}(0)$、$D_{2}(0) = C_{1}(1)$ 和 $D_{2}(1) = C_{2}(1)$，但它们在角点处的切向量通常不相容（非正交），这可能在角点附近引入网格正交性误差。\n\n从参数映射和边界插值的第一性原理出发，并且不假设任何用于内部构造的简化公式，推导内部映射 $\\mathbf{X}(\\xi,\\eta) = \\big(x(\\xi,\\eta),\\,y(\\xi,\\eta)\\big)$ 的 TFI 表达式，该表达式插值所有四条边界并一致地恢复四个角点。然后，将网格正交性度量取为参数坐标方向之间夹角的余弦，其定义为\n$$\nE(\\xi,\\eta) = \\frac{\\big|\\mathbf{X}_{\\xi}(\\xi,\\eta) \\cdot \\mathbf{X}_{\\eta}(\\xi,\\eta)\\big|}{\\|\\mathbf{X}_{\\xi}(\\xi,\\eta)\\|\\,\\|\\mathbf{X}_{\\eta}(\\xi,\\eta)\\|},\n$$\n量化由左下角 $(\\xi,\\eta) = (0,0)$ 处的角点切线不相容性引入的正交性误差。\n\n使用参数值 $a = 0.3$、$b = 0.2$、$c = -0.25$ 和 $d = 0.25$，并将 $E(0,0)$ 计算为单个实数。将最终答案表示为无量纲小数，并四舍五入到四位有效数字。",
            "solution": "该问题要求推导超限插值（TFI）映射，并随后计算特定角点处的网格正交性度量。解题过程按规定从第一性原理出发。\n\n构建一个二维参数映射 $\\mathbf{X}(\\xi, \\eta) = (x(\\xi,\\eta), y(\\xi,\\eta))$，将参数域中的单位正方形 $(\\xi, \\eta) \\in [0, 1] \\times [0, 1]$ 映射到物理域。该映射必须插值四个指定的边界曲线：$\\eta=0$ 处的 $D_1(\\xi)$，$\\eta=1$ 处的 $D_2(\\xi)$，$\\xi=0$ 处的 $C_1(\\eta)$，以及 $\\xi=1$ 处的 $C_2(\\eta)$。\n\n超限插值（或 Coons 曲面）从投影算子的布尔和构建内部映射 $\\mathbf{X}(\\xi,\\eta)$。我们定义两个投影算子 $P_\\xi$ 和 $P_\\eta$，它们在曲线对之间进行插值。使用线性混合函数 $L_0(\\zeta) = 1-\\zeta$ 和 $L_1(\\zeta) = \\zeta$，投影算子为：\n$$ P_{\\xi}[\\mathbf{X}](\\xi, \\eta) = (1-\\xi)\\mathbf{X}(0, \\eta) + \\xi\\mathbf{X}(1, \\eta) $$\n$$ P_{\\eta}[\\mathbf{X}](\\xi, \\eta) = (1-\\eta)\\mathbf{X}(\\xi, 0) + \\eta\\mathbf{X}(\\xi, 1) $$\n代入边界条件 $\\mathbf{X}(0, \\eta) = C_1(\\eta)$、$\\mathbf{X}(1, \\eta) = C_2(\\eta)$、$\\mathbf{X}(\\xi, 0) = D_1(\\xi)$ 和 $\\mathbf{X}(\\xi, 1) = D_2(\\xi)$，我们得到：\n$$ P_{\\xi}(\\xi, \\eta) = (1-\\xi)C_1(\\eta) + \\xi C_2(\\eta) $$\n$$ P_{\\eta}(\\xi, \\eta) = (1-\\eta)D_1(\\xi) + \\eta D_2(\\xi) $$\nTFI 映射是这些投影算子的布尔和，$\\mathbf{X} = P_\\xi \\oplus P_\\eta$，其定义为：\n$$ \\mathbf{X}(\\xi, \\eta) = P_\\xi(\\xi, \\eta) + P_\\eta(\\xi, \\eta) - P_\\xi P_\\eta(\\xi, \\eta) $$\n积投影算子 $P_\\xi P_\\eta$ 是通过将 $P_\\xi$ 应用于 $P_\\eta$ 的结果得到的：\n$$ P_\\xi P_\\eta(\\xi, \\eta) = P_\\xi \\big[ (1-\\eta)D_1(\\xi) + \\eta D_2(\\xi) \\big] = (1-\\xi)\\big[ (1-\\eta)D_1(0) + \\eta D_2(0) \\big] + \\xi\\big[ (1-\\eta)D_1(1) + \\eta D_2(1) \\big] $$\n题目说明边界在角点处是位置相容的，因此我们有：\n$\\mathbf{X}(0,0) = D_1(0) = C_1(0) = (0,0)$\n$\\mathbf{X}(1,0) = D_1(1) = C_2(0) = (1,0)$\n$\\mathbf{X}(0,1) = D_2(0) = C_1(1) = (0,1)$\n$\\mathbf{X}(1,1) = D_2(1) = C_2(1) = (1,1)$\n将这些代入 $P_\\xi P_\\eta$ 的表达式，得到四个角点的双线性插值：\n$$ P_\\xi P_\\eta(\\xi, \\eta) = (1-\\xi)(1-\\eta)\\mathbf{X}(0,0) + \\xi(1-\\eta)\\mathbf{X}(1,0) + (1-\\xi)\\eta\\mathbf{X}(0,1) + \\xi\\eta\\mathbf{X}(1,1) $$\n因此，完整的 TFI 映射为：\n$$ \\mathbf{X}(\\xi, \\eta) = (1-\\xi)C_1(\\eta) + \\xi C_2(\\eta) + (1-\\eta)D_1(\\xi) + \\eta D_2(\\xi) - \\big[ (1-\\xi)(1-\\eta)\\mathbf{X}(0,0) + \\xi(1-\\eta)\\mathbf{X}(1,0) + (1-\\xi)\\eta\\mathbf{X}(0,1) + \\xi\\eta\\mathbf{X}(1,1) \\big] $$\n现在，我们将给定的边界曲线定义代入此公式。映射 $\\mathbf{X}(\\xi,\\eta)$ 具有分量 $(x(\\xi,\\eta), y(\\xi,\\eta))$。\n对于 $x$ 分量：\n$x_{C1}(\\eta) = b\\eta(1-\\eta)$，$x_{C2}(\\eta) = 1+c\\eta(1-\\eta)$，$x_{D1}(\\xi) = \\xi$，$x_{D2}(\\xi) = \\xi$。\n$x_{00}=0$，$x_{10}=1$，$x_{01}=0$，$x_{11}=1$。\n$$ x(\\xi,\\eta) = (1-\\xi)b\\eta(1-\\eta) + \\xi(1+c\\eta(1-\\eta)) + (1-\\eta)\\xi + \\eta\\xi - \\big[ \\xi(1-\\eta) + \\xi\\eta \\big] $$\n$$ x(\\xi,\\eta) = (1-\\xi)b\\eta(1-\\eta) + \\xi + \\xi c\\eta(1-\\eta) + \\xi - \\xi = \\xi + (1-\\xi)b\\eta(1-\\eta) + \\xi c\\eta(1-\\eta) $$\n对于 $y$ 分量：\n$y_{C1}(\\eta) = \\eta$，$y_{C2}(\\eta) = \\eta$，$y_{D1}(\\xi) = d\\xi(1-\\xi)$，$y_{D2}(\\xi) = 1+a\\xi(1-\\xi)$。\n$y_{00}=0$，$y_{10}=0$，$y_{01}=1$，$y_{11}=1$。\n$$ y(\\xi,\\eta) = (1-\\xi)\\eta + \\xi\\eta + (1-\\eta)d\\xi(1-\\xi) + \\eta(1+a\\xi(1-\\xi)) - \\big[ (1-\\xi)\\eta + \\xi\\eta \\big] $$\n$$ y(\\xi,\\eta) = \\eta + (1-\\eta)d\\xi(1-\\xi) + \\eta + \\eta a\\xi(1-\\xi) - \\eta = \\eta + (1-\\eta)d\\xi(1-\\xi) + \\eta a\\xi(1-\\xi) $$\n接下来，我们计算切向量 $\\mathbf{X}_{\\xi} = \\frac{\\partial \\mathbf{X}}{\\partial \\xi}$ 和 $\\mathbf{X}_{\\eta} = \\frac{\\partial \\mathbf{X}}{\\partial \\eta}$。\n$$ \\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\big[ \\xi + b\\eta(1-\\eta) - \\xi b\\eta(1-\\eta) + \\xi c\\eta(1-\\eta) \\big] = 1 - b\\eta(1-\\eta) + c\\eta(1-\\eta) = 1 + (c-b)\\eta(1-\\eta) $$\n$$ \\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\big[ \\eta + d(1-\\eta)(\\xi-\\xi^2) + a\\eta(\\xi-\\xi^2) \\big] = d(1-\\eta)(1-2\\xi) + a\\eta(1-2\\xi) = (d(1-\\eta)+a\\eta)(1-2\\xi) $$\n$$ \\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\big[ \\xi + b(1-\\xi)(\\eta-\\eta^2) + c\\xi(\\eta-\\eta^2) \\big] = b(1-\\xi)(1-2\\eta) + c\\xi(1-2\\eta) = (b(1-\\xi)+c\\xi)(1-2\\eta) $$\n$$ \\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\big[ \\eta + d\\xi(1-\\xi) - \\eta d\\xi(1-\\xi) + \\eta a\\xi(1-\\xi) \\big] = 1 - d\\xi(1-\\xi) + a\\xi(1-\\xi) = 1 + (a-d)\\xi(1-\\xi) $$\n切向量为：\n$$ \\mathbf{X}_{\\xi}(\\xi,\\eta) = \\begin{pmatrix} 1 + (c-b)\\eta(1-\\eta) \\\\ (d(1-\\eta) + a\\eta)(1-2\\xi) \\end{pmatrix}, \\quad \\mathbf{X}_{\\eta}(\\xi,\\eta) = \\begin{pmatrix} (b(1-\\xi) + c\\xi)(1-2\\eta) \\\\ 1 + (a-d)\\xi(1-\\xi) \\end{pmatrix} $$\n我们计算这些向量在左下角 $(\\xi,\\eta)=(0,0)$ 处的值：\n$$ \\mathbf{X}_{\\xi}(0,0) = \\begin{pmatrix} 1 + (c-b)(0) \\\\ (d(1)+a(0))(1) \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ d \\end{pmatrix} $$\n$$ \\mathbf{X}_{\\eta}(0,0) = \\begin{pmatrix} (b(1)+c(0))(1) \\\\ 1+(a-d)(0) \\end{pmatrix} = \\begin{pmatrix} b \\\\ 1 \\end{pmatrix} $$\n正交性度量 $E(\\xi,\\eta)$ 是这些向量之间夹角的余弦。在 $(0,0)$ 处：\n$$ E(0,0) = \\frac{\\big|\\mathbf{X}_{\\xi}(0,0) \\cdot \\mathbf{X}_{\\eta}(0,0)\\big|}{\\|\\mathbf{X}_{\\xi}(0,0)\\|\\,\\|\\mathbf{X}_{\\eta}(0,0)\\|} $$\n我们计算点积和范数：\n$$ \\mathbf{X}_{\\xi}(0,0) \\cdot \\mathbf{X}_{\\eta}(0,0) = \\begin{pmatrix} 1 \\\\ d \\end{pmatrix} \\cdot \\begin{pmatrix} b \\\\ 1 \\end{pmatrix} = 1 \\cdot b + d \\cdot 1 = b+d $$\n$$ \\|\\mathbf{X}_{\\xi}(0,0)\\| = \\sqrt{1^2 + d^2} = \\sqrt{1+d^2} $$\n$$ \\|\\mathbf{X}_{\\eta}(0,0)\\| = \\sqrt{b^2 + 1^2} = \\sqrt{1+b^2} $$\n将这些代入 $E(0,0)$ 的表达式：\n$$ E(0,0) = \\frac{|b+d|}{\\sqrt{1+d^2}\\sqrt{1+b^2}} $$\n现在，我们代入给定的参数值：$a=0.3$，$b=0.2$，$c=-0.25$ 和 $d=0.25$。注意，对于此特定计算，不需要 $a$ 和 $c$。\n$$ b+d = 0.2 + 0.25 = 0.45 $$\n$$ 1+d^2 = 1 + (0.25)^2 = 1 + 0.0625 = 1.0625 $$\n$$ 1+b^2 = 1 + (0.2)^2 = 1 + 0.04 = 1.04 $$\n$$ E(0,0) = \\frac{|0.45|}{\\sqrt{1.0625}\\sqrt{1.04}} = \\frac{0.45}{\\sqrt{1.0625 \\times 1.04}} = \\frac{0.45}{\\sqrt{1.105}} $$\n计算数值：\n$$ E(0,0) \\approx \\frac{0.45}{1.0511898} \\approx 0.4280709... $$\n将结果四舍五入到四位有效数字，我们得到 $0.4281$。",
            "answer": "$$\n\\boxed{0.4281}\n$$"
        },
        {
            "introduction": "虽然结构化网格效率高，但复杂的几何形状常常需要非结构化网格的灵活性。生成此类网格的两种主流范式是德劳内三角剖分（Delaunay Triangulation, DT）和推进前沿法（Advancing Front Method, AFM）。这些方法基于不同的几何准则生成三角形连接：DT通过优化外接圆属性来最大化最小角，而AFM则从边界开始逐层构建网格。在本编程练习  中，您将对这两种方法进行直接的量化比较，通过实现算法并使用最小角质量度量来评估它们的输出，从而理解它们各自的内在权衡。",
            "id": "3987848",
            "problem": "您需要构建并比较两种用于弯曲边界的平面三角形网格，并使用最小角度量来量化三角形质量的差异。其背景是计算热工程，在该领域，网格质量影响传热模拟的数值精度和稳定性。这两种网格分别使用 Delaunay 三角剖分 (DT) 和前沿推进法 (AFM) 生成。需要比较的度量是每个三角形的最小内角，以度为单位表示。\n\n从欧几里得几何出发，三角形的内角根据其边长和边向量的点积有明确的定义。对于一个在 $\\mathbb{R}^2$ 中顶点位置向量为 $\\mathbf{p}_0$、$\\mathbf{p}_1$ 和 $\\mathbf{p}_2$ 的三角形，每个顶点的内角可以从向量方向及其范数推导出来，从而为计算每个三角形的最小角提供了基本依据。\n\n您必须为 DT 和 AFM 生成相同的节点集，以便三角形质量的任何差异纯粹由连接策略引起。对于每个测试用例，请执行以下步骤：\n\n1. 节点集生成：\n   - 弯曲边界定义：\n     - 使用参数形式 $\\mathbf{b}(\\theta) = (R\\cos\\theta, R\\sin\\theta)$ 的半径为 $R$ 的圆。\n     - 使用 $\\mathbf{e}(\\theta) = (a\\cos\\theta, b\\sin\\theta)$ 的半轴为 $a$ 和 $b$ 的椭圆。\n   - 使用 $\\theta_j = 2\\pi j/N$（其中 $j=0,1,\\dots,N-1$）以 $N$ 个等间距点离散化边界。\n   - 生成由缩放半径 $r_\\ell = 1 - \\ell/L$（其中 $\\ell=1,2,\\dots,L-1$）定义的 $L-1$ 个同心内环（均匀径向分级），并用相同的 $N$ 个角度 $\\theta_j$ 参数化这些环。对于圆形，点为 $(R r_\\ell \\cos\\theta_j, R r_\\ell \\sin\\theta_j)$。对于椭圆，点为 $(a r_\\ell \\cos\\theta_j, b r_\\ell \\sin\\theta_j)$。\n   - 在 $(0,0)$ 处包含一个中心节点以闭合前沿。\n   - 对 DT 和 AFM 使用相同的节点集。\n\n2. 网格构建：\n   - DT 网格：计算 $\\mathbb{R}^2$ 中节点集的 Delaunay 三角剖分。\n   - AFM 网格：通过分层连接相邻环来构建三角形。对于环索引 $\\ell$ 和角度索引 $j$（其中 $j$ 对 $N$ 取模），每个分段创建两个三角形：\n     - $(\\ell,j)\\rightarrow(\\ell+1,j)\\rightarrow(\\ell+1,j+1)$,\n     - $(\\ell,j)\\rightarrow(\\ell+1,j+1)\\rightarrow(\\ell,j+1)$,\n     最后通过扇形 $(L-1,j)\\rightarrow\\text{中心}\\rightarrow(L-1,j+1)$ 将最内层的环三角剖分至中心点。\n\n3. 三角形最小角度量：\n   - 对于每个三角形，使用欧几里得向量运算和反余弦函数计算所有三个内角，并取最小角（以度为单位）。也就是说，对于每个三角形 $T$，计算 $\\alpha_{\\min}(T)$（以度为单位）。\n\n4. 差异量化：\n   - 对于每个网格，计算：\n     - 最小角的算术平均值：$\\mu = \\frac{1}{M}\\sum_{k=1}^{M} \\alpha_{\\min}(T_k)$，其中 $M$ 是三角形的数量。\n     - 最差情况下的最小角：$\\omega = \\min_{k=1,\\dots,M} \\alpha_{\\min}(T_k)$。\n   - 计算相同节点集下 DT 和 AFM 之间的差异：\n     - $\\Delta\\mu = \\mu_{\\text{DT}} - \\mu_{\\text{AFM}}$,\n     - $\\Delta\\omega = \\omega_{\\text{DT}} - \\omega_{\\text{AFM}}$。\n   - 所有角度必须以度表示。\n\n测试套件：\n提供三个科学上合理的测试用例，以检验网格生成和质量评估的不同方面。\n\n- 测试用例 1（理想情况，圆形，中等分辨率）：$R=1$，$N=64$，$L=8$。\n- 测试用例 2（椭圆，由几何形状引起的各向异性）：$a=1.5$，$b=1$，$N=64$，$L=8$。\n- 测试用例 3（边界条件，粗糙分辨率）：$R=1$，$N=16$，$L=3$。\n\n您的程序必须实现上述规范，为每个测试用例计算 $\\Delta\\mu$ 和 $\\Delta\\omega$，并在一行中输出结果。最终输出格式必须是一个包含在方括号中的逗号分隔列表，其中包含按 $[\\Delta\\mu_1,\\Delta\\omega_1,\\Delta\\mu_2,\\Delta\\omega_2,\\Delta\\mu_3,\\Delta\\omega_3]$ 顺序排列的值，下标表示测试用例索引（1 到 3）。所有角度量必须以度为单位，浮点数应直接打印，除了编程语言的默认行为外，不进行舍入调整。",
            "solution": "所提出的问题在科学上是合理的，在数学上是明确定义的，并且在计算上是可行的。它解决了计算物理与工程中的一个基本任务：为数值模拟生成网格并进行质量评估。该问题指定了两种截然不同且标准的网格划分策略，即 Delaunay 三角剖分 (DT) 和结构化的前沿推进法 (AFM)，并应用于同一组节点。然后使用标准的网格质量度量——最小内角，进行严格的比较。所有参数、几何定义和算法都以足够的精度进行了指定，从而可以得到唯一且可验证的解。因此，该问题是有效的，我们继续进行合理的求解。\n\n问题的核心在于比较同一点集的两种不同三角剖分的几何质量。在计算热工程中常用的数值方法，如有限元法 (FEM) 或有限体积法 (FVM) 中，三角形网格的质量至关重要。质量差的三角形，特别是那些内角非常小的三角形（即所谓的“狭长”或“退化”三角形），可能导致病态数值系统、精度降低以及迭代求解器收敛速度变慢。\n\n**1. 节点集生成**\n\n为确保对三角剖分连通性进行直接比较，对于每个测试用例，都为 DT 和 AFM 方法生成了一套相同的节点。这些节点分布在由弯曲边界定义的平面域内。生成过程如下：\n\n- 一组 $N$ 个角度位置由 $\\theta_j = \\frac{2\\pi j}{N}$ 定义，其中 $j=0, 1, \\dots, N-1$。\n- 对于给定的几何形状（圆形或椭圆），使用这些角度对边界进行离散化。边界本身对应于径向缩放因子为 1。\n- 生成 $L-1$ 个同心内环。这些环在径向方向上均匀分级。第 $\\ell$ 个环（其中 $\\ell=1, \\dots, L-1$）的缩放因子由 $r_\\ell = 1 - \\ell/L$ 给出。最外层边界可被视为第 $\\ell=0$ 个环，其 $r_0=1$。这样总共有 $L$ 个环。\n- 对于半径为 $R$ 的圆形，位于环 $\\ell$（$0 \\le \\ell  L$）上、角度为 $\\theta_j$ 的点是 $\\mathbf{p}_{\\ell,j} = ((1 - \\ell/L)R\\cos\\theta_j, (1 - \\ell/L)R\\sin\\theta_j)$。\n- 对于半轴为 $a$ 和 $b$ 的椭圆，一个点是 $\\mathbf{p}_{\\ell,j} = ((1 - \\ell/L)a\\cos\\theta_j, (1 - \\ell/L)b\\sin\\theta_j)$。\n- 在原点 $(0,0)$ 处放置一个节点作为中心点，这对于在区域内部闭合网格是必需的。\n- 节点总数为 $N \\times L + 1$。\n\n**2. 网格构建方法**\n\n定义节点集后，应用两种不同的三角剖分算法。\n\n**2.1. Delaunay 三角剖分 (DT)**\nDelaunay 三角剖分是计算几何中的一种经典方法。对于平面中的给定点集 $P$，如果 $\\text{DT}(P)$ 中任何三角形的外接圆内部不包含 $P$ 中的任何点，则该三角剖分 $\\text{DT}(P)$ 是一个 Delaunay 三角剖分。这种“空外接圆”性质具有理想的效果，即最大化网格中所有三角形的最小角，从而尽可能避免细长三角形。就这个特定的质量度量而言，它代表了一个最优解。我们将使用 `scipy.spatial.Delaunay` 类来计算 DT，该类为此实现了一个高效的算法（通常是 Quickhull）。\n\n**2.2. 前沿推进法 (AFM)**\n问题中描述的具体过程是一种结构化的、逐层的三角剖分，可以看作是前沿推进法的一种简化形式。在本例中，“前沿”是每个同心环的边界。算法过程如下：\n- 对于外环 $\\ell$ 和内环 $\\ell+1$ 之间的每一层（$\\ell=0, \\dots, L-2$），由相邻节点 $(\\mathbf{p}_{\\ell,j}, \\mathbf{p}_{\\ell,j+1}, \\mathbf{p}_{\\ell+1,j+1}, \\mathbf{p}_{\\ell+1,j})$ 形成的四边形各自被分成两个三角形。问题指定了划分方式：\n  - 三角形 1：连接顶点 $(\\ell, j)$、$(\\ell+1, j)$ 和 $(\\ell+1, j+1)$。\n  - 三角形 2：连接顶点 $(\\ell, j)$、$(\\ell+1, j+1)$ 和 $(\\ell, j+1)$。\n  索引 $j$ 对 $N$ 取模处理，以应对环的闭环特性。\n- 在对 $L-1$ 层进行三角剖分后，最内层的环（环 $L-1$）被三角剖分至中心点。这是通过创建一个“扇形”三角剖分来完成的，其中每个三角形由最内层环上的两个相邻节点和中心点形成：$(\\ell=L-1, j)$、中心点和 $(\\ell=L-1, j+1)$。\n这种结构化方法创建了一个高度规则的网格，但与 DT 的自适应特性不同，其质量受预定义连接性的约束。\n\n**3. 三角形质量评估**\n\n为了量化网格质量，计算每个三角形的最小内角。对于顶点位置向量为 $\\mathbf{p}_0$、$\\mathbf{p}_1$ 和 $\\mathbf{p}_2$ 的三角形，顶点 $\\mathbf{p}_0$ 处的角度 $\\alpha_0$ 是通过从该顶点出发的边向量 $\\mathbf{v}_{01} = \\mathbf{p}_1 - \\mathbf{p}_0$ 和 $\\mathbf{v}_{02} = \\mathbf{p}_2 - \\mathbf{p}_0$ 的点积来找到的。该角度由以下公式给出：\n$$ \\alpha_0 = \\arccos\\left(\\frac{\\mathbf{v}_{01} \\cdot \\mathbf{v}_{02}}{\\|\\mathbf{v}_{01}\\| \\|\\mathbf{v}_{02}\\|}\\right) $$\n另外两个角 $\\alpha_1$ 和 $\\alpha_2$ 的计算方法类似。单个三角形 $T_k$ 的质量度量是其最小角 $\\alpha_{\\min}(T_k) = \\min(\\alpha_0, \\alpha_1, \\alpha_2)$。$\\arccos$ 的结果是弧度，必须通过乘以 $180/\\pi$ 转换为度。\n\n**4. 对比分析**\n\n为了比较 DT 和 AFM 网格的整体质量，我们为每个网格计算两个聚合统计量：\n- 网格中所有 $M$ 个三角形的最小角的算术平均值：$\\mu = \\frac{1}{M}\\sum_{k=1}^{M} \\alpha_{\\min}(T_k)$。该度量表示平均三角形质量。\n- 所有三角形中的全局最小角：$\\omega = \\min_{k=1,\\dots,M} \\alpha_{\\min}(T_k)$。该度量识别出网格中质量最差的单个三角形，这通常是影响数值稳定性的一个关键因素。\n\n最终的比较通过这两种方法在这些度量上的差异来体现：\n- $\\Delta\\mu = \\mu_{\\text{DT}} - \\mu_{\\text{AFM}}$\n- $\\Delta\\omega = \\omega_{\\text{DT}} - \\omega_{\\text{AFM}}$\n\n$\\Delta\\mu$ 和 $\\Delta\\omega$ 的正值表明 Delaunay 三角剖分生成的网格分别具有更好的平均质量和更好的最差情况三角形，这通常是预期的，因为其具有角度优化的特性。该实现将对指定的测试用例执行这些计算。",
            "answer": "```python\nimport numpy as np\nfrom scipy.spatial import Delaunay\n\ndef solve():\n    \"\"\"\n    Main function to run the mesh comparison for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Circle, moderate resolution\n        {'shape': 'circle', 'params': {'R': 1.0}, 'N': 64, 'L': 8},\n        # Case 2: Ellipse, anisotropy\n        {'shape': 'ellipse', 'params': {'a': 1.5, 'b': 1.0}, 'N': 64, 'L': 8},\n        # Case 3: Circle, coarse resolution\n        {'shape': 'circle', 'params': {'R': 1.0}, 'N': 16, 'L': 3},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Generate Node Set\n        points = generate_nodes(case['shape'], case['params'], case['N'], case['L'])\n\n        # Step 2: Build Meshes\n        dt_triangles = build_dt_mesh(points)\n        afm_triangles = build_afm_mesh(case['N'], case['L'])\n\n        # Step 3  4: Compute Quality Metrics and Differences\n        mu_dt, omega_dt = compute_mesh_quality(points, dt_triangles)\n        mu_afm, omega_afm = compute_mesh_quality(points, afm_triangles)\n\n        delta_mu = mu_dt - mu_afm\n        delta_omega = omega_dt - omega_afm\n\n        results.extend([delta_mu, delta_omega])\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef generate_nodes(shape, params, N, L):\n    \"\"\"\n    Generates the node set for a given geometry.\n    The nodes are ordered by ring, then by angle.\n    Ring 0 is the outermost boundary, ring L-1 is the innermost.\n    The last point is the center at (0,0).\n    \"\"\"\n    num_points = N * L + 1\n    points = np.zeros((num_points, 2))\n    thetas = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n    for l in range(L):\n        scale = 1.0 - l / L\n        if shape == 'circle':\n            R = params['R']\n            x_coords = R * scale * np.cos(thetas)\n            y_coords = R * scale * np.sin(thetas)\n        elif shape == 'ellipse':\n            a, b = params['a'], params['b']\n            x_coords = a * scale * np.cos(thetas)\n            y_coords = b * scale * np.sin(thetas)\n        \n        start_idx = l * N\n        end_idx = start_idx + N\n        points[start_idx:end_idx, 0] = x_coords\n        points[start_idx:end_idx, 1] = y_coords\n\n    # Center node is already (0,0) by np.zeros initialization\n    return points\n\n\ndef build_dt_mesh(points):\n    \"\"\"\n    Computes the Delaunay triangulation for a given set of points.\n    \"\"\"\n    delaunay_tri = Delaunay(points)\n    return delaunay_tri.simplices\n\n\ndef build_afm_mesh(N, L):\n    \"\"\"\n    Constructs the triangulation using the structured Advancing Front Method.\n    \"\"\"\n    triangles = []\n    \n    # Layered triangulation between concentric rings\n    for l in range(L - 1):\n        for j in range(N):\n            j_plus_1 = (j + 1) % N\n            \n            # Indices for the four nodes of the \"quad\"\n            idx_lj = l * N + j\n            idx_lj1 = l * N + j_plus_1\n            idx_l1j = (l + 1) * N + j\n            idx_l1j1 = (l + 1) * N + j_plus_1\n            \n            # Create two triangles from the quad\n            # Triangle 1: (l,j) -> (l+1,j) -> (l+1,j+1)\n            triangles.append([idx_lj, idx_l1j, idx_l1j1])\n            # Triangle 2: (l,j) -> (l+1,j+1) -> (l,j+1)\n            triangles.append([idx_lj, idx_l1j1, idx_lj1])\n\n    # Fan triangulation for the innermost ring to the center\n    center_idx = N * L\n    innermost_ring_l = L - 1\n    for j in range(N):\n        j_plus_1 = (j + 1) % N\n        idx_L1j = innermost_ring_l * N + j\n        idx_L1j1 = innermost_ring_l * N + j_plus_1\n        \n        # Triangle: (L-1,j) -> center -> (L-1,j+1)\n        triangles.append([idx_L1j, center_idx, idx_L1j1])\n        \n    return np.array(triangles)\n\n\ndef compute_min_angle_of_triangle(p0, p1, p2):\n    \"\"\"\n    Computes the minimum internal angle of a single triangle in degrees.\n    \"\"\"\n    # Create edge vectors\n    v01 = p1 - p0\n    v02 = p2 - p0\n    v12 = p2 - p1\n\n    # Compute dot products and norms\n    dot_p0 = np.dot(v01, v02)\n    dot_p1 = np.dot(-v01, v12)\n    dot_p2 = np.dot(-v02, -v12)\n\n    norm_v01 = np.linalg.norm(v01)\n    norm_v02 = np.linalg.norm(v02)\n    norm_v12 = np.linalg.norm(v12)\n\n    # Avoid division by zero for degenerate triangles (collinear points)\n    if norm_v01 == 0 or norm_v02 == 0 or norm_v12 == 0:\n        return 0.0\n\n    # Calculate cosines of angles, clipping to handle floating point inaccuracies\n    cos_a0 = np.clip(dot_p0 / (norm_v01 * norm_v02), -1.0, 1.0)\n    cos_a1 = np.clip(dot_p1 / (norm_v01 * norm_v12), -1.0, 1.0)\n    \n    # The third angle is derived from the first two\n    # a2 = 180 - a0 - a1, however, direct computation is more robust\n    cos_a2 = np.clip(dot_p2 / (norm_v02 * norm_v12), -1.0, 1.0)\n    \n    # Calculate angles in radians and then convert to degrees\n    a0 = np.arccos(cos_a0)\n    a1 = np.arccos(cos_a1)\n    a2 = np.arccos(cos_a2)\n\n    angles_deg = np.rad2deg([a0, a1, a2])\n    \n    return np.min(angles_deg)\n\n\ndef compute_mesh_quality(points, triangles):\n    \"\"\"\n    Computes the mean and minimum of the minimum angles for all triangles in a mesh.\n    \"\"\"\n    min_angles = [\n        compute_min_angle_of_triangle(points[tri[0]], points[tri[1]], points[tri[2]])\n        for tri in triangles\n    ]\n    \n    min_angles = np.array(min_angles)\n    mean_min_angle = np.mean(min_angles)\n    worst_case_angle = np.min(min_angles)\n    \n    return mean_min_angle, worst_case_angle\n\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}