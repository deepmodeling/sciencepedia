{
    "hands_on_practices": [
        {
            "introduction": "The concept of thermal resistance is a cornerstone of simplified heat transfer analysis for linear systems. But how does this useful tool adapt when thermal conductivity, $k$, is no longer a constant but a function of temperature, $T$? This exercise will guide you through the analytical derivation of an *effective* thermal resistance for a common nonlinear scenario. Mastering this derivation provides a tangible understanding of how temperature-dependent properties alter the overall heat transfer characteristics of a medium. ",
            "id": "3976335",
            "problem": "A long slab of thickness $L$ and constant cross-sectional area $A$ conducts heat in one spatial dimension $x \\in [0,L]$ under steady conditions with no internal heat generation. The boundary temperatures are prescribed as $T(0)=T_{0}$ and $T(L)=T_{L}$, with $T_{0} \\neq T_{L}$. The thermal conductivity depends on temperature according to $k(T)=k_{0}\\left(1+\\beta T\\right)$, where $k_{0}>0$ and $\\beta$ are constants, and $k(T)>0$ for all temperatures between $T_{0}$ and $T_{L}$. Let the heat rate conducted through the slab be $Q$ and define the effective thermal resistance $R_{\\text{eff}}$ by $R_{\\text{eff}} \\equiv (T_{0}-T_{L})/Q$.\n\nStarting from the steady one-dimensional energy conservation and Fourier’s law of heat conduction, derive an explicit closed-form expression for $R_{\\text{eff}}$ in terms of $L$, $A$, $k_{0}$, $\\beta$, $T_{0}$, and $T_{L}$. Then, briefly interpret how $R_{\\text{eff}}$ varies with the parameter $\\beta$ under the constraint that $k(T)$ remains positive over the temperature range. Your final answer must be a single analytic expression for $R_{\\text{eff}}$; do not provide an inequality or an equation. No numerical evaluation is required.",
            "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- Geometry: A long slab of thickness $L$ and constant cross-sectional area $A$.\n- Spatial domain: One-dimensional, $x \\in [0,L]$.\n- Conditions: Steady state, no internal heat generation.\n- Boundary conditions: $T(0)=T_{0}$ and $T(L)=T_{L}$.\n- Constraint: $T_{0} \\neq T_{L}$.\n- Material property: Thermal conductivity $k(T)=k_{0}(1+\\beta T)$, where $k_{0}>0$ and $\\beta$ are constants.\n- Physical constraint: $k(T)>0$ for all temperatures between $T_{0}$ and $T_{L}$.\n- Definitions: Heat rate is $Q$; effective thermal resistance is $R_{\\text{eff}} \\equiv (T_{0}-T_{L})/Q$.\n- Task: Derive a closed-form expression for $R_{\\text{eff}}$ and interpret its variation with $\\beta$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is based on the fundamental principles of heat conduction, namely the energy conservation equation and Fourier's law. The use of a temperature-dependent thermal conductivity, specifically a linear model, is a standard and physically realistic extension of the simplest case. The problem is scientifically sound.\n- **Well-Posedness**: The problem is a one-dimensional, steady-state boundary value problem. A first-order ordinary differential equation will result from the physics, and the two prescribed temperature boundary conditions are sufficient to determine a unique solution for the temperature profile and thus for the heat rate $Q$. The problem is well-posed.\n- **Objectivity**: The language is precise, and the terms used are standard in the field of thermal engineering. The problem is objective.\n- **Completeness and Consistency**: The problem provides all necessary information (geometry, boundary conditions, material property law) and contains no internal contradictions. The constraint $k(T) > 0$ ensures the physical model remains valid.\n- **Other Flaws**: The problem does not exhibit any of the other invalidity flags such as being unrealistic, ill-structured, trivial, or unverifiable.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. A solution will be derived.\n\nThe governing equation for one-dimensional, steady-state heat conduction with no internal heat generation is derived from the principle of energy conservation:\n$$ \\frac{d}{dx} \\left( q_x \\right) = 0 $$\nwhere $q_x$ is the heat flux in the $x$-direction. This equation implies that $q_x$ is a constant throughout the slab. The total heat rate $Q$ through the slab of constant cross-sectional area $A$ is given by $Q = A q_x$. Therefore, $Q$ is also constant with respect to $x$.\n\nFourier's law of heat conduction relates the heat flux to the temperature gradient:\n$$ q_x = -k(T) \\frac{dT}{dx} $$\nSubstituting the constant heat rate $Q$, we have:\n$$ \\frac{Q}{A} = -k(T) \\frac{dT}{dx} $$\nWe are given that the thermal conductivity $k(T)$ is a linear function of temperature $T$:\n$$ k(T) = k_{0}(1+\\beta T) $$\nSubstituting this expression into the equation yields:\n$$ \\frac{Q}{A} = -k_{0}(1+\\beta T) \\frac{dT}{dx} $$\nThis is a first-order ordinary differential equation. We can solve it by separating variables. We rearrange the equation to group terms involving $T$ on one side and terms involving $x$ on the other:\n$$ \\frac{Q}{A} dx = -k_{0}(1+\\beta T) dT $$\nTo find the total heat rate $Q$ in terms of the boundary temperatures, we integrate this equation across the slab. The spatial variable $x$ is integrated from $0$ to $L$, while the temperature $T$ is integrated from the corresponding boundary temperature $T(0)=T_{0}$ to $T(L)=T_{L}$.\n$$ \\int_{0}^{L} \\frac{Q}{A} dx = \\int_{T_{0}}^{T_{L}} -k_{0}(1+\\beta T) dT $$\nSince $Q$, $A$, and $k_{0}$ are constants, we can take them out of the integrals:\n$$ \\frac{Q}{A} \\int_{0}^{L} dx = -k_{0} \\int_{T_{0}}^{T_{L}} (1+\\beta T) dT $$\nPerforming the integration on both sides:\n$$ \\frac{Q}{A} [x]_{0}^{L} = -k_{0} \\left[ T + \\frac{\\beta T^2}{2} \\right]_{T_{0}}^{T_{L}} $$\n$$ \\frac{Q L}{A} = -k_{0} \\left( \\left( T_{L} + \\frac{\\beta T_{L}^2}{2} \\right) - \\left( T_{0} + \\frac{\\beta T_{0}^2}{2} \\right) \\right) $$\nRearranging the terms inside the parenthesis:\n$$ \\frac{Q L}{A} = -k_{0} \\left( (T_{L} - T_{0}) + \\frac{\\beta}{2}(T_{L}^2 - T_{0}^2) \\right) $$\nWe use the algebraic identity $a^2 - b^2 = (a-b)(a+b)$ to factor the term $T_{L}^2 - T_{0}^2$:\n$$ \\frac{Q L}{A} = -k_{0} \\left( (T_{L} - T_{0}) + \\frac{\\beta}{2}(T_{L} - T_{0})(T_{L} + T_{0}) \\right) $$\nFactor out the common term $(T_{L} - T_{0})$:\n$$ \\frac{Q L}{A} = -k_{0} (T_{L} - T_{0}) \\left( 1 + \\frac{\\beta}{2}(T_{L} + T_{0}) \\right) $$\nMultiplying by $-1$ on both sides of the inner expression gives:\n$$ \\frac{Q L}{A} = k_{0} (T_{0} - T_{L}) \\left( 1 + \\frac{\\beta}{2}(T_{0} + T_{L}) \\right) $$\nThe problem defines the effective thermal resistance as $R_{\\text{eff}} \\equiv (T_{0}-T_{L})/Q$. We rearrange the above equation to find this ratio.\n$$ \\frac{T_{0}-T_{L}}{Q} = \\frac{L}{A k_{0} \\left( 1 + \\frac{\\beta}{2}(T_{0} + T_{L}) \\right)} $$\nTherefore, the expression for the effective thermal resistance is:\n$$ R_{\\text{eff}} = \\frac{L}{A k_{0} \\left( 1 + \\frac{\\beta}{2}(T_{0} + T_{L}) \\right)} $$\nThis expression can be interpreted by defining an average thermal conductivity, $k_{\\text{avg}}$, evaluated at the arithmetic mean of the boundary temperatures, $T_{\\text{avg}} = (T_{0}+T_{L})/2$.\n$$ k_{\\text{avg}} = k(T_{\\text{avg}}) = k_{0}(1 + \\beta T_{\\text{avg}}) = k_{0}\\left(1 + \\beta \\frac{T_{0}+T_{L}}{2}\\right) $$\nThen the effective resistance has a form analogous to the constant-property case:\n$$ R_{\\text{eff}} = \\frac{L}{A k_{\\text{avg}}} $$\nThe variation of $R_{\\text{eff}}$ with the parameter $\\beta$ can be analyzed from its expression. The resistance $R_{\\text{eff}}$ is inversely proportional to the term $1 + \\frac{\\beta}{2}(T_{0} + T_{L})$. Assuming temperatures are measured on an absolute scale (e.g., Kelvin), the sum $T_{0}+T_{L}$ is positive.\n- If $\\beta > 0$, the thermal conductivity increases with temperature. The denominator $1 + \\frac{\\beta}{2}(T_{0} + T_{L})$ is greater than $1$. This results in a lower effective resistance $R_{\\text{eff}}$ compared to the case where $\\beta=0$.\n- If $\\beta < 0$, the thermal conductivity decreases with temperature. The denominator is less than $1$ (but must be positive, as guaranteed by the problem constraint that $k(T)>0$ throughout the range). This results in a higher effective resistance $R_{\\text{eff}}$ compared to the case where $\\beta=0$.\nIn summary, $R_{\\text{eff}}$ is a monotonically decreasing function of $\\beta$.",
            "answer": "$$ \\boxed{\\frac{L}{A k_{0} \\left(1 + \\frac{\\beta}{2}(T_{0} + T_{L})\\right)}} $$"
        },
        {
            "introduction": "While analytical solutions are invaluable for building intuition, they are often limited to simplified geometries and material property models. Most practical nonlinear conduction problems demand numerical methods. This practice moves from analytical derivation to computational implementation, challenging you to build and apply a Newton-Raphson solver to find the surface temperature in a problem with a prescribed heat flux.  This hands-on exercise is fundamental for developing the skills to tackle the nonlinear boundary value problems that are prevalent in engineering.",
            "id": "3976312",
            "problem": "Consider one-dimensional, steady heat conduction in a homogeneous slab occupying the domain $0 \\le x \\le L$, with spatial coordinate $x$ measured in meters. The heat flux boundary condition at the surface $x=0$ is prescribed as a constant value $q''_0$ in watts per square meter. The back face at $x=L$ has a prescribed temperature $T_b$ in kelvin. The thermal conductivity $k(T)$ varies with temperature, and the slab is otherwise free of internal heat sources. Assume the slab remains in a temperature range where $k(T) > 0$ and the conduction model is valid. Use the sign convention of Fourier’s law $q''(x) = - k(T) \\, dT/dx$, where $q''(x)$ is the local heat flux.\n\nStarting from fundamental heat conduction principles, derive the governing relationship that the unknown surface temperature $T_s = T(x=0)$ must satisfy when $k(T)$ depends on temperature. Show that this relationship is a nonlinear algebraic equation for $T_s$, and design a Newton iteration to solve for $T_s$ given $q''_0$, $L$, $T_b$, and a specified functional form of $k(T)$.\n\nYour implementation must follow these computational requirements:\n- Define the scalar residual function in terms of $T_s$ that enforces the appropriate energy balance implied by steady, one-dimensional conduction with the above boundary conditions.\n- Derive the Newton update using the derivative of the residual with respect to $T_s$, expressed in terms of $k(T)$ evaluated at the current iterate.\n- Implement a robust algorithm that converges for the test cases provided, including safeguards appropriate for a nonlinear equation where $k(T)$ varies with $T$, and report the final $T_s$ for each case.\n\nPhysical units:\n- Report the surface temperature $T_s$ in kelvin.\n- All inputs must be interpreted in the following units: $q''_0$ in watts per square meter ($\\mathrm{W}/\\mathrm{m}^2$), $L$ in meters ($\\mathrm{m}$), $T$ in kelvin ($\\mathrm{K}$), and $k$ in watts per meter-kelvin ($\\mathrm{W}/\\mathrm{m}\\cdot\\mathrm{K}$).\n\nTest suite:\nUse the following five parameter sets. In all cases, $T_b$ is the temperature at $x=L$.\n\n1. Case A (linear conductivity):\n   - $k(T) = k_0 \\left[ 1 + \\alpha \\left( T - T_{\\mathrm{ref}} \\right) \\right]$\n   - $k_0 = 200 \\ \\mathrm{W}/\\mathrm{m}\\cdot\\mathrm{K}$, $\\alpha = 1\\times 10^{-3} \\ \\mathrm{K}^{-1}$, $T_{\\mathrm{ref}} = 300 \\ \\mathrm{K}$\n   - $L = 0.01 \\ \\mathrm{m}$, $q''_0 = 5\\times 10^{5} \\ \\mathrm{W}/\\mathrm{m}^2$, $T_b = 300 \\ \\mathrm{K}$\n\n2. Case B (exponential conductivity):\n   - $k(T) = k_0 \\exp\\left[ \\beta \\left( T - T_{\\mathrm{ref}} \\right) \\right]$\n   - $k_0 = 150 \\ \\mathrm{W}/\\mathrm{m}\\cdot\\mathrm{K}$, $\\beta = 5\\times 10^{-3} \\ \\mathrm{K}^{-1}$, $T_{\\mathrm{ref}} = 350 \\ \\mathrm{K}$\n   - $L = 0.02 \\ \\mathrm{m}$, $q''_0 = 1\\times 10^{6} \\ \\mathrm{W}/\\mathrm{m}^2$, $T_b = 350 \\ \\mathrm{K}$\n\n3. Case C (quadratic conductivity in temperature increment):\n   - $k(T) = k_0 \\left[ 1 + a_1 \\left( T - T_{\\mathrm{ref}} \\right) + a_2 \\left( T - T_{\\mathrm{ref}} \\right)^2 \\right]$\n   - $k_0 = 100 \\ \\mathrm{W}/\\mathrm{m}\\cdot\\mathrm{K}$, $a_1 = 2\\times 10^{-3} \\ \\mathrm{K}^{-1}$, $a_2 = 1\\times 10^{-6} \\ \\mathrm{K}^{-2}$, $T_{\\mathrm{ref}} = 300 \\ \\mathrm{K}$\n   - $L = 0.005 \\ \\mathrm{m}$, $q''_0 = -2\\times 10^{5} \\ \\mathrm{W}/\\mathrm{m}^2$, $T_b = 400 \\ \\mathrm{K}$\n\n4. Case D (piecewise-linear conductivity):\n   - $k(T) = \\begin{cases}\n     50 + 0.1 \\left( T - 300 \\right), & T \\le 600 \\\\\n     80 + 0.05 \\left( T - 600 \\right), & T > 600\n     \\end{cases}$\n   - $L = 0.03 \\ \\mathrm{m}$, $q''_0 = 3\\times 10^{5} \\ \\mathrm{W}/\\mathrm{m}^2$, $T_b = 450 \\ \\mathrm{K}$\n\n5. Case E (zero-flux check with exponential conductivity):\n   - $k(T) = k_0 \\exp\\left( \\beta T \\right)$\n   - $k_0 = 75 \\ \\mathrm{W}/\\mathrm{m}\\cdot\\mathrm{K}$, $\\beta = 2\\times 10^{-3} \\ \\mathrm{K}^{-1}$\n   - $L = 0.01 \\ \\mathrm{m}$, $q''_0 = 0 \\ \\mathrm{W}/\\mathrm{m}^2$, $T_b = 500 \\ \\mathrm{K}$\n\nAnswer specification:\n- Your program must compute the surface temperature $T_s$ for each of the five cases using a Newton iteration derived from first principles, and must include appropriate safeguards to ensure convergence for monotonic $k(T)$ with $k(T) > 0$.\n- Express each computed $T_s$ in kelvin, rounded to six decimal places.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be ordered as $\\left[T_s^{(A)}, T_s^{(B)}, T_s^{(C)}, T_s^{(D)}, T_s^{(E)}\\right]$ where the superscripts denote the case labels; for example, $\\left[325.123456,450.654321,390.000000,588.000000,500.000000\\right]$.",
            "solution": "This problem requires the derivation and implementation of a numerical method to solve for an unknown surface temperature in a nonlinear heat conduction problem. The solution proceeds in two parts: first, the derivation of the governing equation and the numerical algorithm, and second, the implementation of this algorithm to solve the given test cases.\n\n### Derivation of the Governing Equation and Numerical Method\n\n**1. Governing Physical Principle**\nFor one-dimensional, steady-state heat conduction with no internal heat generation, the energy conservation principle simplifies to:\n$$\n\\frac{d}{dx}\\left( q''(x) \\right) = 0\n$$\nwhere $q''(x)$ is the local heat flux. This implies that the heat flux is constant throughout the slab. Using the boundary condition at $x=0$, we have $q''(x) = q''(0) = q''_0$ for all $x \\in [0, L]$.\n\nFourier's law of heat conduction relates the heat flux to the temperature gradient:\n$$\nq''(x) = -k(T) \\frac{dT}{dx}\n$$\nSince $q''(x) = q''_0$, we obtain the governing ordinary differential equation:\n$$\nq''_0 = -k(T) \\frac{dT}{dx}\n$$\n\n**2. Integral Form of the Governing Equation**\nTo find the relationship between the temperatures at the boundaries, we separate variables and integrate across the slab from $x=0$ to $x=L$:\n$$\nq''_0 \\, dx = -k(T) \\, dT\n$$\n$$\n\\int_{x=0}^{x=L} q''_0 \\, dx = \\int_{T(0)}^{T(L)} -k(T) \\, dT\n$$\nSubstituting the boundary conditions $T(0) = T_s$ (the unknown surface temperature) and $T(L) = T_b$ (the known back face temperature), the integration yields:\n$$\nq''_0 [x]_0^L = - \\int_{T_s}^{T_b} k(T) \\, dT\n$$\n$$\nq''_0 L = \\int_{T_b}^{T_s} k(T) \\, dT\n$$\nThis is the fundamental integral relationship that the unknown surface temperature $T_s$ must satisfy.\n\n**3. Formulation of the Nonlinear Residual Equation**\nTo solve for $T_s$ using a root-finding algorithm, we define a residual function $R(T_s)$ whose root is the desired solution. We rearrange the integral equation into the form $R(T_s) = 0$:\n$$\nR(T_s) = \\int_{T_b}^{T_s} k(T) \\, dT - q''_0 L = 0\n$$\nThis is a nonlinear algebraic equation for $T_s$, as the integral's value depends on $T_s$ through the function $k(T)$.\n\n**4. Newton-Raphson Iteration Method**\nThe Newton-Raphson method is an iterative technique for finding the roots of a real-valued function. The update formula is:\n$$\nT_{s, n+1} = T_{s, n} - \\frac{R(T_{s, n})}{R'(T_{s, n})}\n$$\nwhere $T_{s, n}$ is the estimate of the root at iteration $n$, and $R'(T_s)$ is the derivative of the residual function with respect to $T_s$.\n\nWe find $R'(T_s)$ by differentiating the residual function:\n$$\nR'(T_s) = \\frac{d}{dT_s} \\left( \\int_{T_b}^{T_s} k(T) \\, dT - q''_0 L \\right)\n$$\nBy the Fundamental Theorem of Calculus, the derivative of the integral term is:\n$$\n\\frac{d}{dT_s} \\left( \\int_{T_b}^{T_s} k(T) \\, dT \\right) = k(T_s)\n$$\nThe term $q''_0 L$ is constant with respect to $T_s$, so its derivative is zero. Thus, the derivative of the residual is simply the thermal conductivity evaluated at the surface temperature $T_s$:\n$$\nR'(T_s) = k(T_s)\n$$\nSubstituting these expressions into the Newton-Raphson formula gives the specific update rule for this problem:\n$$\nT_{s, n+1} = T_{s, n} - \\frac{\\int_{T_b}^{T_{s, n}} k(T) \\, dT - q''_0 L}{k(T_{s, n})}\n$$\n\n**5. Implementation Strategy**\nThe solution is found by implementing this iterative scheme.\n- **Initial Guess**: A good initial guess $T_{s,0}$ can be obtained by assuming $k(T)$ is constant and equal to its value at the known boundary, $k(T_b)$. The integral relation then simplifies to $q''_0 L \\approx k(T_b)(T_s - T_b)$, yielding the initial guess: $T_{s,0} = T_b + \\frac{q''_0 L}{k(T_b)}$.\n- **Iteration**: The iteration proceeds until the absolute value of the residual $|R(T_s)|$ falls below a specified tolerance (e.g., $10^{-8}$), or a maximum number of iterations is reached.\n- **Integrals**: For each given functional form of $k(T)$, its definite integral is computed analytically to be used within the residual calculation for maximum accuracy and efficiency.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the surface temperature of a slab with temperature-dependent\n    thermal conductivity using a Newton-Raphson solver.\n    \"\"\"\n\n    def newton_solver(residual_func, derivative_func, T0, tol=1e-8, max_iter=50):\n        \"\"\"\n        A robust Newton-Raphson solver for a scalar nonlinear equation.\n        \"\"\"\n        Ts = float(T0)\n        for _ in range(max_iter):\n            res = residual_func(Ts)\n            if abs(res)  tol:\n                return Ts\n\n            deriv = derivative_func(Ts)\n            if abs(deriv)  1e-12:  # Safeguard against division by zero\n                # This should not be reached for k(T) > 0.\n                raise ValueError(\"Derivative is too small; Newton's method fails.\")\n            \n            # Standard Newton-Raphson step\n            step = -res / deriv\n            \n            # A simple step-size damper for robustness, although not strictly\n            # necessary for these monotonic problems.\n            max_step = 100.0 # Limit temperature change to 100K per step\n            if abs(step) > max_step:\n                step = np.sign(step) * max_step\n\n            Ts += step\n\n        # If loop finishes without convergence, raise an error.\n        raise RuntimeError(f\"Newton's method did not converge after {max_iter} iterations.\")\n\n    # --- Test Case Definitions ---\n    \n    # Case A: Linear conductivity\n    # k(T) = k0 * (1 + alpha * (T - T_ref))\n    params_A = {'k0': 200.0, 'alpha': 1e-3, 'T_ref': 300.0, \n                'L': 0.01, 'q0': 5e5, 'Tb': 300.0}\n    \n    def k_A(T, p):\n        return p['k0'] * (1.0 + p['alpha'] * (T - p['T_ref']))\n    \n    def integral_k_A(Ts, p):\n        # Antiderivative of k0*(1-alpha*T_ref) + k0*alpha*T is\n        # k0*(1-alpha*T_ref)*T + 0.5*k0*alpha*T^2\n        def primitive(T_val):\n            return p['k0'] * ((1.0 - p['alpha'] * p['T_ref']) * T_val + \\\n                              0.5 * p['alpha'] * T_val**2)\n        return primitive(Ts) - primitive(p['Tb'])\n\n    # Case B: Exponential conductivity\n    # k(T) = k0 * exp(beta * (T - T_ref))\n    params_B = {'k0': 150.0, 'beta': 5e-3, 'T_ref': 350.0,\n                'L': 0.02, 'q0': 1e6, 'Tb': 350.0}\n    \n    def k_B(T, p):\n        return p['k0'] * np.exp(p['beta'] * (T - p['T_ref']))\n    \n    def integral_k_B(Ts, p):\n        # Antiderivative of k0 * exp(beta*(T-T_ref)) is (k0/beta) * exp(beta*(T-T_ref))\n        def primitive(T_val):\n            return (p['k0'] / p['beta']) * np.exp(p['beta'] * (T_val - p['T_ref']))\n        return primitive(Ts) - primitive(p['Tb'])\n\n    # Case C: Quadratic conductivity\n    # k(T) = k0 * (1 + a1*(T-T_ref) + a2*(T-T_ref)^2)\n    params_C = {'k0': 100.0, 'a1': 2e-3, 'a2': 1e-6, 'T_ref': 300.0,\n                'L': 0.005, 'q0': -2e5, 'Tb': 400.0}\n\n    def k_C(T, p):\n        dT = T - p['T_ref']\n        return p['k0'] * (1.0 + p['a1'] * dT + p['a2'] * dT**2)\n\n    def integral_k_C(Ts, p):\n        # Antiderivative of k0*(1+a1*u+a2*u^2) where u=T-T_ref is\n        # k0*(u + a1/2*u^2 + a2/3*u^3)\n        def primitive(T_val):\n            dT = T_val - p['T_ref']\n            return p['k0'] * (dT + (p['a1'] / 2.0) * dT**2 + (p['a2'] / 3.0) * dT**3)\n        return primitive(Ts) - primitive(p['Tb'])\n\n    # Case D: Piecewise-linear conductivity\n    params_D = {'L': 0.03, 'q0': 3e5, 'Tb': 450.0, 'T_split': 600.0}\n\n    def k_D(T, p):\n        if T = p['T_split']:\n            return 50.0 + 0.1 * (T - 300.0) # 20 + 0.1*T\n        else:\n            return 80.0 + 0.05 * (T - 600.0) # 50 + 0.05*T\n\n    def integral_k_D(Ts, p):\n        T_split = p['T_split']\n\n        def primitive_1(T): return 20.0 * T + 0.05 * T**2\n        def primitive_2(T): return 50.0 * T + 0.025 * T**2\n        \n        # Integral from a common reference point (arbitrarily 0K) to T\n        def integral_from_ref(T):\n            if T = T_split:\n                return primitive_1(T)\n            else:\n                # Value at split + integral over the second part\n                val_at_split = primitive_1(T_split)\n                integral_part2 = primitive_2(T) - primitive_2(T_split)\n                return val_at_split + integral_part2\n        \n        return integral_from_ref(Ts) - integral_from_ref(p['Tb'])\n\n\n    # Case E: Zero-flux check\n    params_E = {'k0': 75.0, 'beta': 2e-3, 'L': 0.01, 'q0': 0.0, 'Tb': 500.0}\n\n    def k_E(T, p):\n        return p['k0'] * np.exp(p['beta'] * T)\n\n    def integral_k_E(Ts, p):\n        def primitive(T_val):\n            return (p['k0'] / p['beta']) * np.exp(p['beta'] * T_val)\n        return primitive(Ts) - primitive(p['Tb'])\n\n    test_cases = [\n        (params_A, k_A, integral_k_A),\n        (params_B, k_B, integral_k_B),\n        (params_C, k_C, integral_k_C),\n        (params_D, k_D, integral_k_D),\n        (params_E, k_E, integral_k_E),\n    ]\n\n    results = []\n    for params, k_func, integral_k_func in test_cases:\n        q0 = params['q0']\n        L = params['L']\n        Tb = params['Tb']\n        \n        # Define residual and its derivative for the solver\n        residual = lambda Ts: integral_k_func(Ts, params) - q0 * L\n        derivative = lambda Ts: k_func(Ts, params)\n        \n        # Calculate a physically-based initial guess\n        k_at_Tb = k_func(Tb, params)\n        if abs(k_at_Tb)  1e-12: # Avoid division by zero in guess\n            T0 = Tb \n        else:\n            # T_s approx T_b + (q0 * L) / k(T_b)\n            T0 = Tb + (q0 * L) / k_at_Tb\n\n        # In zero-flux case, initial guess is the exact solution\n        if q0 == 0.0:\n            T_final = Tb\n        else:\n            T_final = newton_solver(residual, derivative, T0)\n        \n        # Append result rounded to 6 decimal places\n        results.append(f\"{T_final:.6f}\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After developing a numerical solver for a nonlinear PDE, a critical question arises: how can we be certain the code is implemented correctly? The Method of Manufactured Solutions (MMS) is a rigorous and indispensable technique for code verification. This final exercise introduces you to this professional-grade practice by having you work backward: starting with a chosen \"manufactured\" solution, you will derive the corresponding source term that makes it an exact solution to the nonlinear governing equation.  This process creates a tailored benchmark problem, allowing for precise quantification of your code's accuracy.",
            "id": "3976326",
            "problem": "Consider steady-state two-dimensional heat conduction in a simply connected domain $\\Omega = (0,1)\\times(0,1)$ with temperature-dependent thermal conductivity. The governing strong form of the energy balance for a continuum with volumetric heat source is\n$$\n\\nabla \\cdot \\big(k(T)\\,\\nabla T\\big) + \\dot{q}(T) = 0 \\quad \\text{in } \\Omega,\n$$\nwith prescribed Dirichlet boundary condition $T = T^{\\star}(x,y)$ on $\\partial \\Omega$. You are asked to construct a manufactured solution within the framework of the Method of Manufactured Solutions (MMS), defined as the deliberate choice of an exact solution $T(x,y)$ and associated data such that the governing equation is satisfied identically. Proceed as follows:\n\n- Choose the manufactured exact temperature field\n$$\nT(x,y) = T_{c} + \\gamma\\,(x^{2} + y^{2}),\n$$\nwhere $T_{c}  0$ and $\\gamma  0$ are constants, and let the boundary condition be $T^{\\star}(x,y) = T(x,y)$ for $(x,y) \\in \\partial \\Omega$.\n\n- Impose a strictly positive, monotone conductivity of exponential form\n$$\nk(T) = k_{0}\\,\\exp(\\alpha\\,T),\n$$\nwith $k_{0}  0$ and $\\alpha$ a real parameter.\n\nStarting from the conservation law above and fundamental vector calculus identities applicable to $\\nabla \\cdot \\big(k(T)\\,\\nabla T\\big)$, derive a source function $\\dot{q}(T)$ expressed strictly as a function of $T$ (no explicit $x$ or $y$), such that the chosen $T(x,y)$ satisfies the governing equation exactly for the given $k(T)$. Your derivation must begin from the stated energy balance and proceed by first principles; do not invoke any specialized pre-derived formulas beyond standard differentiation rules.\n\nAdditionally, outline a verification plan appropriate for an advanced computational thermal engineering code that solves the nonlinear problem, including but not limited to: consistency of linearization for a Newton-type solver, discrete residual evaluation at the manufactured solution, and grid-convergence assessment of the numerical error norm toward the exact $T(x,y)$.\n\nProvide your final answer as the pair of closed-form expressions $\\big(k(T),\\,\\dot{q}(T)\\big)$, reported in the units $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$ for $k(T)$ and $\\mathrm{W}\\,\\mathrm{m}^{-3}$ for $\\dot{q}(T)$. No numerical evaluation is required; give exact symbolic expressions. Express the final pair in a single row matrix as specified in the final answer guidelines.",
            "solution": "This problem requires constructing a source term for a manufactured solution to the nonlinear heat conduction equation and outlining a code verification plan.\n\n### Derivation of the Source Function $\\dot{q}(T)$\nThe starting point is the governing equation for steady-state heat conduction:\n$$\n\\nabla \\cdot \\big(k(T)\\,\\nabla T\\big) + \\dot{q}(T) = 0\n$$\nFrom this, the source function $\\dot{q}(T)$ is isolated:\n$$\n\\dot{q}(T) = -\\nabla \\cdot \\big(k(T)\\,\\nabla T\\big)\n$$\nWe apply the product rule for the divergence of a scalar field $k(T)$ times a vector field $\\nabla T$, which is $\\nabla \\cdot (f\\mathbf{A}) = (\\nabla f) \\cdot \\mathbf{A} + f (\\nabla \\cdot \\mathbf{A})$:\n$$\n\\nabla \\cdot \\big(k(T)\\,\\nabla T\\big) = \\big(\\nabla k(T)\\big) \\cdot (\\nabla T) + k(T) \\big(\\nabla \\cdot (\\nabla T)\\big)\n$$\nThe divergence of the gradient is the Laplacian, $\\nabla \\cdot (\\nabla T) = \\nabla^2 T$. For the term $\\nabla k(T)$, we use the chain rule for the gradient: $\\nabla k(T) = \\frac{dk}{dT} \\nabla T$.\nSubstituting these identities back gives:\n$$\n\\nabla \\cdot \\big(k(T)\\,\\nabla T\\big) = \\left(\\frac{dk}{dT} \\nabla T\\right) \\cdot (\\nabla T) + k(T) \\nabla^2 T = \\frac{dk}{dT} |\\nabla T|^2 + k(T) \\nabla^2 T\n$$\nTherefore, the source function must be:\n$$\n\\dot{q}(T) = - \\left( \\frac{dk}{dT} |\\nabla T|^2 + k(T) \\nabla^2 T \\right)\n$$\nNext, we evaluate the required terms based on the given manufactured solution $T(x,y) = T_{c} + \\gamma\\,(x^{2} + y^{2})$ and conductivity $k(T) = k_{0}\\,\\exp(\\alpha\\,T)$.\n\nFirst, we compute the gradient and Laplacian of the temperature field $T(x,y)$:\nThe partial derivatives are:\n$$\n\\frac{\\partial T}{\\partial x} = 2\\gamma x \\quad \\text{and} \\quad \\frac{\\partial T}{\\partial y} = 2\\gamma y\n$$\nThe gradient vector is $\\nabla T = 2\\gamma x \\,\\mathbf{i} + 2\\gamma y \\,\\mathbf{j}$.\nThe squared magnitude of the gradient is:\n$$\n|\\nabla T|^2 = \\left(\\frac{\\partial T}{\\partial x}\\right)^2 + \\left(\\frac{\\partial T}{\\partial y}\\right)^2 = (2\\gamma x)^2 + (2\\gamma y)^2 = 4\\gamma^2 (x^2 + y^2)\n$$\nThe second partial derivatives are:\n$$\n\\frac{\\partial^2 T}{\\partial x^2} = 2\\gamma \\quad \\text{and} \\quad \\frac{\\partial^2 T}{\\partial y^2} = 2\\gamma\n$$\nThe Laplacian of the temperature field is:\n$$\n\\nabla^2 T = \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} = 2\\gamma + 2\\gamma = 4\\gamma\n$$\nSecond, we compute the derivative of the conductivity $k(T)$ with respect to temperature $T$:\n$$\n\\frac{dk}{dT} = \\frac{d}{dT} \\left( k_{0}\\,\\exp(\\alpha\\,T) \\right) = \\alpha\\,k_{0}\\,\\exp(\\alpha\\,T) = \\alpha\\,k(T)\n$$\nNow we substitute these components into the expression for $\\dot{q}(T)$:\n$$\n\\dot{q}(T) = - \\left( \\big(\\alpha\\,k(T)\\big) \\big(4\\gamma^2(x^2+y^2)\\big) + k(T) (4\\gamma) \\right)\n$$\nWe can factor out $4\\gamma$ and $k(T)$:\n$$\n\\dot{q}(T) = -4\\gamma\\,k(T) \\left( \\alpha\\gamma(x^2+y^2) + 1 \\right)\n$$\nThe problem requires $\\dot{q}(T)$ to be expressed strictly as a function of temperature $T$, without explicit dependence on the spatial coordinates $x$ and $y$. We use the definition of the manufactured solution to establish this relationship:\n$$\nT = T_{c} + \\gamma(x^2+y^2) \\implies \\gamma(x^2+y^2) = T - T_c\n$$\nSubstituting this into the expression for $\\dot{q}(T)$ eliminates the explicit spatial dependence:\n$$\n\\dot{q}(T) = -4\\gamma\\,k(T) \\left( \\alpha(T - T_c) + 1 \\right)\n$$\nFinally, we substitute the full expression for $k(T)$:\n$$\n\\dot{q}(T) = -4\\gamma\\,k_{0}\\,\\exp(\\alpha\\,T) \\big( \\alpha(T - T_{c}) + 1 \\big)\n$$\nThis is the required source function.\n\n### Verification Plan Outline\nFor an advanced computational thermal engineering code (e.g., a finite element method code), a verification plan using this manufactured solution would consist of the following steps:\n\n1.  **Implementation**:\n    -   Implement the derived source function $\\dot{q}(T) = -4\\gamma\\,k_{0}\\,\\exp(\\alpha\\,T) \\big( \\alpha(T - T_{c}) + 1 \\big)$ and the conductivity function $k(T) = k_0\\exp(\\alpha T)$ into the code's material property and source term routines.\n    -   Implement the Dirichlet boundary condition by evaluating $T^{\\star}(x,y) = T_{c} + \\gamma(x^2+y^2)$ at the boundary nodes.\n\n2.  **Consistency of Linearization (Jacobian Verification)**:\n    -   The nonlinear system of equations arising from the finite element discretization, $\\mathbf{R}(\\mathbf{T}) = \\mathbf{0}$, is solved using a Newton-Raphson method, which requires the Jacobian matrix $\\mathbf{J} = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{T}}$.\n    -   Derive the analytical form of the Jacobian contributions from the nonlinear terms $k(T)$ and $\\dot{q}(T)$. This involves the derivatives $\\frac{dk}{dT}$ and $\\frac{d\\dot{q}}{dT}$.\n    -   Use a finite difference method to approximate the Jacobian numerically, e.g., $J_{ij} \\approx \\frac{R_i(\\mathbf{T} + \\epsilon \\mathbf{e}_j) - R_i(\\mathbf{T})}{\\epsilon}$, where $\\mathbf{e}_j$ is a unit vector.\n    -   Compare the analytical and numerically-approximated Jacobians at an arbitrary state $\\mathbf{T}$. Agreement to a tolerance dependent on $\\epsilon$ verifies the correctness of the analytical Jacobian implementation, which is crucial for the Newton solver's quadratic convergence.\n\n3.  **Discrete Residual Evaluation**:\n    -   Evaluate the exact manufactured solution $T(x,y)$ at every node in the mesh to create an exact discrete solution vector $\\mathbf{T}_{exact}$.\n    -   Substitute $\\mathbf{T}_{exact}$ into the discrete residual assembly routine of the code to compute $\\mathbf{R}(\\mathbf{T}_{exact})$.\n    -   Due to discretization error, $\\mathbf{R}(\\mathbf{T}_{exact})$ will not be zero. The MMS is constructed to satisfy the PDE, not its discrete approximation. However, the norm $\\|\\mathbf{R}(\\mathbf{T}_{exact})\\|$ should converge to zero as the mesh size $h \\to 0$ at a predictable rate. This test confirms that the discrete operators and the source term are implemented consistently.\n\n4.  **Grid-Convergence Assessment**:\n    -   This is the definitive verification test.\n    -   Define a sequence of successively refined meshes over the domain $\\Omega = (0,1)\\times(0,1)$.\n    -   On each mesh, solve the full nonlinear problem to obtain a numerical solution $\\mathbf{T}_h$.\n    -   For each $\\mathbf{T}_h$, compute the error by comparing it to the known exact solution $T(x,y)$. The error is measured using a functional norm, typically the $L^2$ norm: $e_{L^2} = \\left( \\int_\\Omega (T_h - T)^2 d\\Omega \\right)^{1/2}$.\n    -   The theoretical order of convergence, $p$, relates the error to the mesh size $h$ by $e \\approx C h^p$. By computing the error on at least two meshes, $h_1$ and $h_2$, the observed order can be calculated as $p_{obs} = \\frac{\\ln(e_1/e_2)}{\\ln(h_1/h_2)}$.\n    -   Verify that $p_{obs}$ matches the theoretical order of convergence $p$ for the element type used in the discretization (e.g., for linear basis functions, $p \\approx 2$ is expected for the $L^2$ norm). This verifies that the code is free of bugs that would corrupt its designed accuracy.\n\nThe final expressions for $k(T)$ and $\\dot{q}(T)$ are provided below.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix} k_{0}\\,\\exp(\\alpha\\,T)  -4\\gamma\\,k_{0}\\,\\exp(\\alpha\\,T) \\big( \\alpha(T - T_{c}) + 1 \\big) \\end{pmatrix}\n}\n$$"
        }
    ]
}