{
    "hands_on_practices": [
        {
            "introduction": "在热传递分析中，材料属性（如导热系数）通常随温度变化，这使得控制方程变为非线性，难以求得解析解。本练习通过求解一个具有随温度线性变化的导热系数的一维稳态热传导问题，并将精确解与常用的线性化近似解进行比较，来探讨这种非线性性的影响。通过这项实践，您将深入理解线性化近似的适用范围和误差来源，这是工程分析中一项至关重要的判断能力。",
            "id": "3959775",
            "problem": "一块厚度为 $L$ 的平板处于稳定的一维热传导状态，无内部热源。其导热系数随温度线性变化，关系式为 $k(T) = k_0 \\left(1 + \\beta T \\right)$，其中 $k_0$ 和 $\\beta$ 为正常数。边界温度给定为 $T(0) = T_0$ 和 $T(L) = T_L$，且 $T_L > T_0$。仅从一维稳态能量守恒定律（$\\frac{d q_x}{dx} = 0$）和傅里叶热传导定律（$q_x = -k(T) \\frac{dT}{dx}$）出发，完成以下任务：\n\n1. 推导平板内的精确温度分布 $T_{\\text{exact}}(x)$，并用 $k_0$、$ \\beta$、$ T_0$、$ T_L$ 和 $L$ 表示恒定的热通量 $q_x$。\n2. 通过将导热系数“冻结”在参考温度（等于算术平均值 $T_{\\text{ref}} = \\frac{T_0 + T_L}{2}$）下，求解得到的恒定物性热传导问题，从而获得线性化的温度场 $T_{\\text{lin}}(x)$。\n3. 使用参数值 $k_0 = 50\\,\\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$、$\\beta = 1.0 \\times 10^{-3}\\,\\text{K}^{-1}$、$L = 0.10\\,\\text{m}$、$T_0 = 300\\,\\text{K}$ 和 $T_L = 500\\,\\text{K}$，计算精确温度场与线性化温度场之间的最大绝对逐点误差，\n$$\nE_{\\max} \\equiv \\max_{x \\in [0,L]} \\left| T_{\\text{exact}}(x) - T_{\\text{lin}}(x) \\right|.\n$$\n\n最终答案以开尔文（K）为单位表示。将答案四舍五入至四位有效数字。",
            "solution": "### 步骤 1：提取已知条件\n- 几何形状：厚度为 $L$ 的平板。\n- 过程：稳定的一维热传导，无内部热源。\n- 材料属性：导热系数 $k(T) = k_0 (1 + \\beta T)$，其中 $k_0 > 0$ 且 $\\beta > 0$。\n- 控制方程：$\\frac{d q_x}{dx} = 0$（稳态能量守恒）和 $q_x = -k(T) \\frac{dT}{dx}$（傅里叶定律）。\n- 边界条件：$T(0) = T_0$ 和 $T(L) = T_L$，且 $T_L > T_0$。\n- 任务 1：推导精确温度分布 $T_{\\text{exact}}(x)$ 和恒定热通量 $q_x$。\n- 任务 2：使用恒定导热系数 $k_{\\text{ref}} = k(T_{\\text{ref}})$（其中 $T_{\\text{ref}} = \\frac{T_0 + T_L}{2}$）推导线性化温度场 $T_{\\text{lin}}(x)$。\n- 任务 3：使用参数值 $k_0 = 50\\,\\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$、$\\beta = 1.0 \\times 10^{-3}\\,\\text{K}^{-1}$、$L = 0.10\\,\\text{m}$、$T_0 = 300\\,\\text{K}$ 和 $T_L = 500\\,\\text{K}$，计算最大绝对逐点误差 $E_{\\max} = \\max_{x \\in [0,L]} | T_{\\text{exact}}(x) - T_{\\text{lin}}(x) |$。最终答案需四舍五入至四位有效数字。\n\n### 步骤 2：验证问题\n该问题具有科学合理性、适定性、完整性和客观性。所有必要的数据均已提供，因此可以进行求解。\n\n### 解题推导\n\n**1. 精确温度分布和热通量**\n\n稳态能量守恒方程为 $\\frac{d q_x}{dx} = 0$，这意味着热通量 $q_x$ 在整个平板中是一个常数。代入傅里叶定律可得：\n$$\nq_x = -k(T) \\frac{dT}{dx} = -k_0 (1 + \\beta T) \\frac{dT}{dx}\n$$\n这是一个变量可分离的一阶常微分方程。我们写成 $q_x dx = -k_0 (1 + \\beta T) dT$ 并进行积分。为了求出常数 $q_x$，我们对整个平板进行积分：\n$$\n\\int_0^L q_x dx = -\\int_{T_0}^{T_L} k_0 (1 + \\beta T) dT\n$$\n$$\nq_x L = -k_0 \\left[ T + \\frac{\\beta}{2} T^2 \\right]_{T_0}^{T_L} = -k_0 \\left( (T_L - T_0) + \\frac{\\beta}{2} (T_L^2 - T_0^2) \\right)\n$$\n整理该表达式得到热通量：\n$$\nq_x = -\\frac{k_0}{L} (T_L - T_0) \\left( 1 + \\frac{\\beta}{2} (T_L + T_0) \\right)\n$$\n为了求得温度分布 $T_{\\text{exact}}(x)$，我们将方程从 $x=0$ 积分到任意位置 $x$：\n$$\n\\int_0^x q_x dx' = -\\int_{T_0}^{T(x)} k_0 (1 + \\beta T') dT'\n$$\n$$\nq_x x = -k_0 \\left( \\left( T(x) - T_0 \\right) + \\frac{\\beta}{2} \\left( T(x)^2 - T_0^2 \\right) \\right)\n$$\n通过对两个积分结果（$q_x L$ 和 $q_x x$）取比值来消去 $q_x$：\n$$\n\\frac{x}{L} = \\frac{\\left( T(x) - T_0 \\right) + \\frac{\\beta}{2} \\left( T(x)^2 - T_0^2 \\right)}{\\left( T_L - T_0 \\right) + \\frac{\\beta}{2} \\left( T_L^2 - T_0^2 \\right)}\n$$\n这给出了 $T(x)$ 的一个隐式表达式。通过对 $(1+\\beta T)$ 进行配方可以得到一个更简洁的显式解。注意到 $\\int (1+\\beta T) dT = \\frac{1}{2\\beta}(1+\\beta T)^2 + C$。因此：\n$$\nq_x L = -\\frac{k_0}{2\\beta} \\left[ (1+\\beta T_L)^2 - (1+\\beta T_0)^2 \\right]\n$$\n$$\nq_x x = -\\frac{k_0}{2\\beta} \\left[ (1+\\beta T(x))^2 - (1+\\beta T_0)^2 \\right]\n$$\n取比值：\n$$\n\\frac{x}{L} = \\frac{(1+\\beta T(x))^2 - (1+\\beta T_0)^2}{(1+\\beta T_L)^2 - (1+\\beta T_0)^2}\n$$\n求解 $(1+\\beta T(x))^2$:\n$$\n(1+\\beta T_{\\text{exact}}(x))^2 = (1+\\beta T_0)^2 + \\frac{x}{L}\\left[ (1+\\beta T_L)^2 - (1+\\beta T_0)^2 \\right]\n$$\n求解 $T_{\\text{exact}}(x)$ 并取正根：\n$$\nT_{\\text{exact}}(x) = \\frac{1}{\\beta} \\left( -1 + \\sqrt{(1+\\beta T_0)^2 + \\frac{x}{L}\\left[ (1+\\beta T_L)^2 - (1+\\beta T_0)^2 \\right]} \\right)\n$$\n\n**2. 线性化温度分布**\n\n对于这部分，导热系数保持为常数 $k_{\\text{ref}} = k(T_{\\text{ref}})$，其中 $T_{\\text{ref}} = \\frac{T_0 + T_L}{2}$。\n$$\nk_{\\text{ref}} = k_0 \\left( 1 + \\beta T_{\\text{ref}} \\right) = k_0 \\left( 1 + \\beta \\frac{T_0 + T_L}{2} \\right)\n$$\n控制方程变为 $\\frac{d^2T}{dx^2} = 0$。通解是 $T(x) = C_1 x + C_2$。应用边界条件可得：\n$$\nT_{\\text{lin}}(x) = T_0 + (T_L - T_0) \\frac{x}{L}\n$$\n\n**3. 最大绝对逐点误差**\n\n误差 $E(x) = T_{\\text{exact}}(x) - T_{\\text{lin}}(x)$。最大误差出现在 $\\frac{dE}{dx} = 0$ 的点 $x_m$ 处，即 $\\frac{d T_{\\text{exact}}}{dx}(x_m) = \\frac{d T_{\\text{lin}}}{dx}$。\n注意到，精确热通量 $q_x$ 和线性化热通量 $q_{\\text{lin}} = -k_{\\text{ref}} \\frac{T_L-T_0}{L}$ 相等。\n$$\nq_x = -\\frac{k_0}{L} (T_L - T_0) \\left( 1 + \\frac{\\beta}{2} (T_L + T_0) \\right) = -\\frac{k_0\\left(1+\\beta T_{\\text{ref}}\\right)}{L}(T_L-T_0) = -\\frac{k_{\\text{ref}}}{L}(T_L-T_0) = q_{\\text{lin}}\n$$\n最大误差的条件 $\\frac{d T_{\\text{exact}}}{dx} = \\frac{d T_{\\text{lin}}}{dx}$ 变为 $\\frac{-q_x}{k(T_{\\text{exact}}(x_m))} = \\frac{-q_{\\text{lin}}}{k_{\\text{ref}}}$。\n由于 $q_x=q_{\\text{lin}}$，这简化为 $k(T_{\\text{exact}}(x_m)) = k_{\\text{ref}}$，这意味着 $T_{\\text{exact}}(x_m) = T_{\\text{ref}}$。\n我们将 $T_{\\text{exact}}(x_m) = T_{\\text{ref}}$ 代入 $x/L$ 的表达式中来求 $x_m$。令 $a = 1+\\beta T_0$ 且 $b = 1+\\beta T_L$。则 $1+\\beta T_{\\text{ref}} = \\frac{a+b}{2}$。\n$$\n\\frac{x_m}{L} = \\frac{(1+\\beta T_{\\text{ref}})^2 - (1+\\beta T_0)^2}{(1+\\beta T_L)^2 - (1+\\beta T_0)^2} = \\frac{((a+b)/2)^2 - a^2}{b^2 - a^2}\n$$\n$$\n\\frac{x_m}{L} = \\frac{( (a+b)/2 - a ) ( (a+b)/2 + a )}{(b-a)(b+a)} = \\frac{ (b-a)/2 \\cdot (3a+b)/2 }{ (b-a)(b+a) } = \\frac{1}{4} \\frac{3a+b}{a+b}\n$$\n最大误差为 $E_{\\max} = |T_{\\text{exact}}(x_m) - T_{\\text{lin}}(x_m)| = |T_{\\text{ref}} - T_{\\text{lin}}(x_m)|$。\n$$\nE_{\\max} = \\left| \\frac{T_0+T_L}{2} - \\left(T_0 + (T_L - T_0)\\frac{x_m}{L}\\right) \\right| = |T_L - T_0| \\left| \\frac{1}{2} - \\frac{x_m}{L} \\right|\n$$\n$$\n\\frac{1}{2} - \\frac{x_m}{L} = \\frac{1}{2} - \\frac{1}{4}\\frac{3a+b}{a+b} = \\frac{2(a+b) - (3a+b)}{4(a+b)} = \\frac{b-a}{4(a+b)}\n$$\n$E_{\\max} = |T_L - T_0| \\left| \\frac{b-a}{4(a+b)} \\right| = (T_L - T_0) \\frac{\\beta(T_L - T_0)}{4(2 + \\beta(T_0 + T_L))}$\n$$\nE_{\\max} = \\frac{\\beta(T_L - T_0)^2}{4(2 + \\beta(T_0 + T_L))}\n$$\n现在，我们代入给定的数值：$\\beta = 1.0 \\times 10^{-3}\\,\\text{K}^{-1}$、$T_0 = 300\\,\\text{K}$、$T_L = 500\\,\\text{K}$。\n$T_L - T_0 = 200\\,\\text{K}$。\n$T_0 + T_L = 800\\,\\text{K}$。\n$$\nE_{\\max} = \\frac{(1.0 \\times 10^{-3}) (200)^2}{4(2 + (1.0 \\times 10^{-3})(800))} = \\frac{(1.0 \\times 10^{-3}) (40000)}{4(2 + 0.8)} = \\frac{40}{4(2.8)} = \\frac{10}{2.8} = \\frac{25}{7} \\approx 3.571428... \\,\\text{K}\n$$\n四舍五入到四位有效数字，最大绝对逐点误差为 $3.571\\,\\text{K}$。",
            "answer": "$$\n\\boxed{3.571}\n$$"
        },
        {
            "introduction": "认识到即使是简单的非线性问题也难以获得解析解后，我们转向构建一个更通用的数值工具。本练习将指导您从基本守恒定律出发，构建一个二维稳态热传导方程的有限体积法（FVM）求解器，特别关注如何通过谐波平均处理变化的导热系数以及如何精确地施加边界条件。这项实践是计算热工领域的一项核心技能，它将理论知识转化为解决复杂工程问题的实用代码。",
            "id": "3959812",
            "problem": "考虑二维空间中的稳态热传导算子，其定义为导热通量的散度，即 $\\nabla \\cdot (k \\nabla T)$，其中 $T$ 为温度，$k$ 为热导率。从局部能量守恒陈述和傅里叶热传导定律出发，推导一个在单位正方形域 $[0,1]\\times[0,1]$ 上的结构化笛卡尔网格的二阶精确有限体积法 (FVM) 离散格式，该格式采用单元中心未知量和面法向通量。推导必须从控制体上的积分守恒形式开始，并使用物理上一致的面通量定义。明确展示如何通过在内部界面上使用谐波平均来处理 $k$ 的空间变化，并解释如何处理狄利克雷边界条件以保持二阶空间精度。假设 $k$ 是一个足够光滑的位置函数，并且除非另有说明，仅依赖于 $x$ 坐标。\n\n您的程序必须实现所推导的离散格式，以求解偏微分方程\n$$\n\\nabla \\cdot \\left(k(x)\\nabla T(x,y)\\right) = f(x,y)\n$$\n在域 $x\\in[0,1]$, $y\\in[0,1]$ 上，并受制于在所有边界上规定的狄利克雷边界条件 $T(x,y) = T_{\\text{exact}}(x,y)$。使用人造解法，其中\n$$\nT_{\\text{exact}}(x,y) = \\sin(\\pi x)\\sin(\\pi y),\n$$\n并选择 $k(x) = k_0 + \\alpha x$，其中常数 $k_0 \\ge 0$ 和 $\\alpha \\ge 0$。从精确解 $T_{\\text{exact}}(x,y)$ 和选定的 $k(x)$ 推导出相应的源项 $f(x,y)$，并使用中点法则来近似计算每个控制体 $\\Omega_P$ 上的 $\\int_{\\Omega_P} f \\, dV$。网格应为均匀网格，在 $x$ 方向有 $N_x$ 个单元，在 $y$ 方向有 $N_y$ 个单元，单元宽度分别为 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$。在内部界面上实现 $k$ 的谐波平均以计算界面热导率用于通量计算，并通过消除虚拟单元值来处理狄利克雷边界界面，以获得二阶一致的界面系数和源项。组装得到的稀疏线性系统并求解单元中心温度。\n\n计算误差，定义为数值解 $T_h$ 与精确解 $T_{\\text{exact}}$ 之差的离散 $\\ell^2$ 范数，\n$$\n\\|e\\|_2 = \\left(\\sum_{P} (T_h(P) - T_{\\text{exact}}(P))^2 \\, \\Delta x \\, \\Delta y \\right)^{1/2},\n$$\n并以开尔文为单位报告。同时，对于一对网格 $(N_x,N_y)$ 和 $(2N_x,2N_y)$，使用以下公式计算观测到的精度阶 $p$：\n$$\np = \\frac{\\ln\\left(\\|e\\|_2^{\\text{coarse}}/\\|e\\|_2^{\\text{fine}}\\right)}{\\ln(2)},\n$$\n该值为无量纲，必须以小数形式报告。\n\n测试套件和要求输出：\n实现并运行以下四个测试用例：\n- 情况 $1$ (恒定热导率，一般精度)：$k_0 = 2$, $\\alpha = 0$, $N_x = 40$, $N_y = 40$。输出以开尔文为单位的离散 $\\ell^2$ 误差。\n- 情况 $2$ (线性变化热导率，一般精度)：$k_0 = 1$, $\\alpha = 1$, $N_x = 40$, $N_y = 40$。输出以开尔文为单位的离散 $\\ell^2$ 误差。\n- 情况 $3$ (线性变化热导率，粗网格边缘情况)：$k_0 = 1$, $\\alpha = 1$, $N_x = 8$, $N_y = 8$。输出以开尔文为单位的离散 $\\ell^2$ 误差。\n- 情况 $4$ (线性变化热导率，加密时的观测阶数)：$k_0 = 1$, $\\alpha = 1$, 粗网格 $N_x = 20$, $N_y = 20$, 细网格 $N_x = 40$, $N_y = 40$。输出观测阶数 $p$ 作为小数值。\n\n您的程序应生成单行输出，其中包含按上述情况顺序排列的结果，形式为逗号分隔的列表，并用方括号括起来，例如 $[e_1,e_2,e_3,p_4]$，其中 $e_i$ 是以开尔文为单位的误差，$p_4$ 是无量纲数。不应打印任何单位；将 $e_i$ 解释为开尔文，将 $p_4$ 解释为小数。如果涉及角度，必须使用弧度。如果涉及百分比，必须表示为小数。\n\n科学和算法要求：\n- 推导必须从能量守恒和傅里叶定律开始，而不是从预先推导出的离散公式开始。\n- 在均匀笛卡尔网格上通过中心差分实现二阶空间精度。\n- 在内部界面上使用 $k$ 的谐波平均。\n- 使用一致的狄利克雷边界处理和半单元距离以保持二阶精度。\n- 组装并求解得到的稀疏线性系统。\n- 确保情景在科学上是合理且自洽的。\n\n最终程序必须是完整且可运行的，使用指定的执行环境，无需外部输入，并产生确切要求的单行输出格式。",
            "solution": "该问题要求推导并实现一个二阶精确的有限体积法 (FVM)，用于求解在二维笛卡尔网格上具有空间变化热导率 $k(x)$ 的稳态热传导方程。推导必须源于能量守恒和傅里叶热传导定律的基本原理。\n\n带有源项 $f$ 的稳态热传导的控制偏微分方程 (PDE) 为：\n$$ \\nabla \\cdot \\left(k \\nabla T\\right) = f $$\n其中 $T$ 是温度，$k$ 是热导率，$f$ 是体积热源密度。\n\nFVM 从守恒定律的积分形式开始。将 PDE 在任意控制体 (CV) $\\Omega_P$ 上积分，得到：\n$$ \\int_{\\Omega_P} \\nabla \\cdot \\left(k \\nabla T\\right) \\, dV = \\int_{\\Omega_P} f \\, dV $$\n对左侧应用散度定理，将散度的体积积分转换为通量在控制体边界 $\\partial \\Omega_P$ 上的面积分：\n$$ \\oint_{\\partial \\Omega_P} (k \\nabla T) \\cdot \\mathbf{n} \\, dS = \\int_{\\Omega_P} f \\, dV $$\n这里，$\\mathbf{n}$ 是指向面元 $dS$ 外部的单位法向量。项 $-(k \\nabla T)$ 是傅里叶定律中的热通量矢量 $\\mathbf{q}$。因此，该方程表示穿过控制体边界的热通量与在其内部产生的热量之间的平衡。\n\n现在，我们在由矩形单元组成的结构化笛卡尔网格上离散化这个积分方程。考虑一个通用单元或控制体 $\\Omega_P$，中心位于点 $P(x_P, y_P)$，尺寸为 $\\Delta x \\times \\Delta y$，体积为 $V_P = \\Delta x \\Delta y$（假设单位深度）。边界 $\\partial \\Omega_P$ 由四个面组成：东 ($e$)、西 ($w$)、北 ($n$) 和南 ($s$)。积分平衡方程变为这四个面上的通量之和：\n$$ F_e - F_w + F_n - F_s = \\bar{f}_P V_P $$\n其中 $F_f$ 表示穿过面 $f$ 的总热率，$\\bar{f}_P$ 是控制体上的平均源项。总热率是面法向通量密度 $q_f$ 与面面积 $A_f$ 的乘积。对于我们的二维网格，面积为 $A_e = A_w = \\Delta y$ 和 $A_n = A_s = \\Delta x$。平衡方程为：\n$$ (q_e A_e - q_w A_w) + (q_n A_n - q_s A_s) = (q_e - q_w)\\Delta y + (q_n - q_s)\\Delta x = \\bar{f}_P \\Delta x \\Delta y $$\n问题指定使用中点法则来近似积分源项，因此 $\\bar{f}_P \\approx f(x_P, y_P)$。通量 $q_f$ 是在面中心处垂直于面的热通量矢量的分量。使用傅里叶定律，我们近似这些通量。例如，在东面：\n$$ q_e = (-k\\nabla T)_e \\cdot \\mathbf{i} \\approx -k_e \\left(\\frac{\\partial T}{\\partial x}\\right)_e $$\n其中 $k_e$ 是东面的热导率。为保持二阶精度，面上的梯度使用相邻单元中心之间的中心差分来近似。设 $P$ 表示当前单元的中心，$E, W, N, S$ 分别表示其东、西、北、南邻居的中心。梯度为：\n$$ \\left(\\frac{\\partial T}{\\partial x}\\right)_e \\approx \\frac{T_E - T_P}{\\Delta x}, \\quad \\left(\\frac{\\partial T}{\\partial y}\\right)_n \\approx \\frac{T_N - T_P}{\\Delta y} $$\n因此，穿过单元 $P$ 四个面的通量近似为：\n$$ q_e \\approx -k_e \\frac{T_E - T_P}{\\Delta x}, \\quad q_w \\approx -k_w \\frac{T_P - T_W}{\\Delta x} $$\n$$ q_n \\approx -k_n \\frac{T_N - T_P}{\\Delta y}, \\quad q_s \\approx -k_s \\frac{T_P - T_S}{\\Delta y} $$\n\n对于空间变化的电导率 $k(x)$，必须适当地评估面电导率 $k_f$。对于垂直于变化方向的面（东面和西面），单元中心电导率的简单算术平均将导致一阶精度。为确保二阶精度和物理一致性（通量和温度的连续性），使用谐波平均。这相当于将跨面的热传递建模为与面相邻的两个半单元对应的一系列热阻。\n对于单元 $P$ 和 $E$ 之间的内部东面：\n$$ k_e = \\frac{2 k(x_P) k(x_E)}{k(x_P) + k(x_E)} $$\n类似地，对于单元 $W$ 和 $P$ 之间的西面：\n$$ k_w = \\frac{2 k(x_W) k(x_P)}{k(x_W) + k(x_P)} $$\n对于北面和南面，它们与恒定的 $x$ 坐标对齐，电导率 $k(x)$ 沿每个面是恒定的。因此，不需要平均：\n$$ k_n = k_s = k(x_P) $$\n将这些通量近似值代入平衡方程，得到内部单元 $P$ 的离散方程：\n$$ -k_e \\frac{T_E - T_P}{\\Delta x} \\Delta y - \\left(-k_w \\frac{T_P - T_W}{\\Delta x}\\right) \\Delta y - k_n \\frac{T_N - T_P}{\\Delta y} \\Delta x - \\left(-k_s \\frac{T_P - T_S}{\\Delta y}\\right) \\Delta x = f(x_P, y_P) \\Delta x \\Delta y $$\n整理为标准的线性代数形式 $a_P T_P = a_E T_E + a_W T_W + a_N T_N + a_S T_S + b_P$：\n$$ \\left( k_e \\frac{\\Delta y}{\\Delta x} + k_w \\frac{\\Delta y}{\\Delta x} + k_n \\frac{\\Delta x}{\\Delta y} + k_s \\frac{\\Delta x}{\\Delta y} \\right) T_P = \\left( k_e \\frac{\\Delta y}{\\Delta x} \\right) T_E + \\left( k_w \\frac{\\Delta y}{\\Delta x} \\right) T_W + \\left( k_n \\frac{\\Delta x}{\\Delta y} \\right) T_N + \\left( k_s \\frac{\\Delta x}{\\Delta y} \\right) T_S + f_P \\Delta x \\Delta y $$\n这里，我们定义系数：$a_E = k_e \\frac{\\Delta y}{\\Delta x}$，$a_W = k_w \\frac{\\Delta y}{\\Delta x}$，$a_N = k_n \\frac{\\Delta x}{\\Delta y}$，$a_S = k_s \\frac{\\Delta x}{\\Delta y}$，以及中心系数 $a_P = a_E + a_W + a_N + a_S$。源项贡献为 $b_P = f(x_P, y_P) \\Delta x \\Delta y$。\n\n对于与狄利克雷边界相邻的单元，必须修改处理方式以保持二阶精度。考虑位于西边界（$x=0$）的单元 $P$。该单元的西面位于边界上，那里的温度 $T_b$ 是已知的。从单元中心 $P$ 到此边界的距离是 $\\Delta x/2$。西面上的梯度使用单元中心值和边界值来近似：\n$$ \\left(\\frac{\\partial T}{\\partial x}\\right)_w \\approx \\frac{T_P - T_{b,w}}{\\Delta x / 2} $$\n其中 $T_{b,w} = T_{\\text{exact}}(0, y_P)$。穿过西面的通量是 $q_w = -k_w (\\frac{T_P - T_{b,w}}{\\Delta x/2})$，其中 $k_w = k(0)$ 是边界上的热导率。平衡方程中的项是 $-q_w \\Delta y$。西面的系数变为 $a_W = k(0) \\frac{\\Delta y}{\\Delta x/2} = 2k(0)\\frac{\\Delta y}{\\Delta x}$。这修改了边界单元的线性方程：项 $a_W T_W$ 被替换为一个已知值，加到源项中。位于西边界的单元 $P$ 的最终方程是：\n$$ (a_E + a_W + a_N + a_S) T_P - a_E T_E - a_N T_N - a_S T_S = b_P + a_W T_{b,w} $$\n此过程类似地应用于所有其他边界（东、北、南），相应地调整边界面的系数和源项。这种使用半单元距离的“虚拟单元”消除方法确保了边界上的梯度近似是二阶的，从而保持了格式的整体精度。\n\n最后，我们使用人造解法来定义源项 $f(x,y)$。给定 $T_{\\text{exact}}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ 和 $k(x) = k_0 + \\alpha x$，我们计算 $f(x,y) = \\nabla \\cdot (k \\nabla T_{\\text{exact}})$。\n已知 $\\nabla T_{\\text{exact}} = \\langle \\pi\\cos(\\pi x)\\sin(\\pi y), \\pi\\sin(\\pi x)\\cos(\\pi y) \\rangle$，我们有：\n$$ f(x,y) = \\frac{\\partial}{\\partial x}\\left((k_0+\\alpha x)\\pi\\cos(\\pi x)\\sin(\\pi y)\\right) + \\frac{\\partial}{\\partial y}\\left((k_0+\\alpha x)\\pi\\sin(\\pi x)\\cos(\\pi y)\\right) $$\n$$ f(x,y) = \\pi\\sin(\\pi y)\\left[\\alpha\\cos(\\pi x) - (k_0+\\alpha x)\\pi\\sin(\\pi x)\\right] + (k_0+\\alpha x)\\pi\\sin(\\pi x)\\left[-\\pi\\sin(\\pi y)\\right] $$\n$$ f(x,y) = \\pi \\alpha \\cos(\\pi x)\\sin(\\pi y) - 2\\pi^2 (k_0 + \\alpha x) \\sin(\\pi x)\\sin(\\pi y) $$\n这个函数用于计算每个单元的源项 $b_P$。为所有 $N_x \\times N_y$ 个单元组装方程，会得到一个稀疏线性系统 $A\\mathbf{T} = \\mathbf{b}$，可以求解该系统以获得单元中心温度的向量 $\\mathbf{T}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve_pde(Nx, Ny, k0, alpha):\n    \"\"\"\n    Solves the 2D steady heat conduction equation using a cell-centered FVM.\n\n    Args:\n        Nx (int): Number of cells in the x-direction.\n        Ny (int): Number of cells in the y-direction.\n        k0 (float): Constant term in thermal conductivity k(x).\n        alpha (float): Linear coefficient in thermal conductivity k(x).\n\n    Returns:\n        float: The discrete l2-norm of the error.\n    \"\"\"\n    dx = 1.0 / Nx\n    dy = 1.0 / Ny\n    x_centers = (np.arange(Nx) + 0.5) * dx\n    y_centers = (np.arange(Ny) + 0.5) * dy\n    xx, yy = np.meshgrid(x_centers, y_centers, indexing='xy')\n\n    # Define analytical functions based on the method of manufactured solutions\n    k_func = lambda x: k0 + alpha * x\n    T_exact_func = lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y)\n    \n    def f_func(x, y):\n        pi = np.pi\n        term1 = pi * alpha * np.cos(pi * x) * np.sin(pi * y)\n        term2 = -2 * pi**2 * (k0 + alpha * x) * np.sin(pi * x) * np.sin(pi * y)\n        return term1 + term2\n\n    N_total = Nx * Ny\n    A = lil_matrix((N_total, N_total))\n    b = np.zeros(N_total)\n\n    # Assemble the sparse matrix A and the source vector b\n    for j in range(Ny):  # y-index\n        for i in range(Nx):  # x-index\n            p = i + j * Nx  # 1D index, mapping (i,j) -> p\n            \n            x_p, y_p = x_centers[i], y_centers[j]\n            \n            # Integrated source term (midpoint rule)\n            b[p] = f_func(x_p, y_p) * dx * dy\n            \n            a_P = 0.0  # Diagonal coefficient\n            \n            # West face\n            if i > 0:  # Interior face\n                x_w_center = x_centers[i-1]\n                k_p = k_func(x_p)\n                k_w_cell = k_func(x_w_center)\n                k_w_face = 2.0 * k_p * k_w_cell / (k_p + k_w_cell) # Harmonic mean\n                a_W = k_w_face * dy / dx\n                A[p, p - 1] = -a_W\n                a_P += a_W\n            else:  # Boundary face (x=0)\n                k_w_face = k_func(0.0)\n                a_W = k_w_face * dy / (dx / 2.0)\n                a_P += a_W\n                T_b = T_exact_func(0.0, y_p)\n                b[p] += a_W * T_b\n                \n            # East face\n            if i  Nx - 1:  # Interior face\n                x_e_center = x_centers[i+1]\n                k_p = k_func(x_p)\n                k_e_cell = k_func(x_e_center)\n                k_e_face = 2.0 * k_p * k_e_cell / (k_p + k_e_cell) # Harmonic mean\n                a_E = k_e_face * dy / dx\n                A[p, p + 1] = -a_E\n                a_P += a_E\n            else:  # Boundary face (x=1)\n                k_e_face = k_func(1.0)\n                a_E = k_e_face * dy / (dx / 2.0)\n                a_P += a_E\n                T_b = T_exact_func(1.0, y_p)\n                b[p] += a_E * T_b\n                \n            # South face\n            if j > 0:  # Interior face\n                k_s_face = k_func(x_p) # k is constant along y-normal face\n                a_S = k_s_face * dx / dy\n                A[p, p - Nx] = -a_S\n                a_P += a_S\n            else:  # Boundary face (y=0)\n                k_s_face = k_func(x_p)\n                a_S = k_s_face * dx / (dy / 2.0)\n                a_P += a_S\n                T_b = T_exact_func(x_p, 0.0)\n                b[p] += a_S * T_b\n\n            # North face\n            if j  Ny - 1:  # Interior face\n                k_n_face = k_func(x_p)\n                a_N = k_n_face * dx / dy\n                A[p, p + Nx] = -a_N\n                a_P += a_N\n            else:  # Boundary face (y=1)\n                k_n_face = k_func(x_p)\n                a_N = k_n_face * dx / (dy / 2.0)\n                a_P += a_N\n                T_b = T_exact_func(x_p, 1.0)\n                b[p] += a_N * T_b\n                \n            A[p, p] = a_P\n\n    # Solve the linear system\n    A_csr = A.tocsr()\n    T_numerical_flat = spsolve(A_csr, b)\n    T_numerical = T_numerical_flat.reshape((Ny, Nx))\n    \n    # Calculate discrete l2-norm of the error\n    T_exact_grid = T_exact_func(xx, yy)\n    error = np.sqrt(np.sum((T_numerical - T_exact_grid)**2 * dx * dy))\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        {'id': 1, 'k0': 2.0, 'alpha': 0.0, 'Nx': 40, 'Ny': 40, 'type': 'error'},\n        {'id': 2, 'k0': 1.0, 'alpha': 1.0, 'Nx': 40, 'Ny': 40, 'type': 'error'},\n        {'id': 3, 'k0': 1.0, 'alpha': 1.0, 'Nx': 8, 'Ny': 8, 'type': 'error'},\n        {'id': 4, 'k0': 1.0, 'alpha': 1.0, 'Nx_coarse': 20, 'Ny_coarse': 20, 'type': 'order'}\n    ]\n\n    results = []\n    \n    # Case 1\n    case1 = test_cases[0]\n    e1 = solve_pde(case1['Nx'], case1['Ny'], case1['k0'], case1['alpha'])\n    results.append(e1)\n    \n    # Case 2\n    case2 = test_cases[1]\n    e2 = solve_pde(case2['Nx'], case2['Ny'], case2['k0'], case2['alpha'])\n    results.append(e2)\n\n    # Case 3\n    case3 = test_cases[2]\n    e3 = solve_pde(case3['Nx'], case3['Ny'], case3['k0'], case3['alpha'])\n    results.append(e3)\n\n    # Case 4\n    case4 = test_cases[3]\n    e_coarse = solve_pde(case4['Nx_coarse'], case4['Ny_coarse'], case4['k0'], case4['alpha'])\n    e_fine = solve_pde(case4['Nx_coarse'] * 2, case4['Ny_coarse'] * 2, case4['k0'], case4['alpha'])\n    p4 = np.log(e_coarse / e_fine) / np.log(2.0)\n    results.append(p4)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在开发了如前一个练习中的复杂数值求解器之后，一个关键问题随之而来：“我的代码正确吗？”。本练习介绍了一种严格的验证技术——“人造解方法”（Method of Manufactured Solutions, MMS），用于检验数值求解器的正确性和精度阶。通过亲手设计一个解析解并推导相应的源项和边界条件，您可以对照一个具有已知精确解的问题来测试您的求解器，从而确保其实现的可靠性。",
            "id": "3959791",
            "problem": "考虑一个二维无量纲单位正方形域 $\\Omega = \\{(x,y)\\,|\\,0 \\le x \\le 1,\\,0 \\le y \\le 1\\}$ 和一个无量纲时间区间 $t \\ge 0$。对于一个具有空间变化的标量热导率的固体，其控制能量平衡方程为\n$$\n\\rho\\,c\\,\\frac{\\partial T}{\\partial t} = \\nabla \\cdot \\big(k(x,y)\\,\\nabla T(x,y,t)\\big) + \\dot{q}(x,y,t),\n$$\n其中 $\\rho$ 是无量纲密度，$c$ 是无量纲比热容，$T$ 是温度场，$k(x,y)$ 是无量纲热导率，而 $\\dot{q}(x,y,t)$ 是无量纲体积热源，必须选择它以使人工解精确满足该方程。单位外法向量为 $\\mathbf{n}$，边界条件为混合边界条件：\n- 左边界和下边界为 Dirichlet 条件：对于 $0 \\le y \\le 1$，$T(0,y,t)$ 是给定的；对于 $0 \\le x \\le 1$，$T(x,0,t)$ 是给定的。\n- 上边界为 Neumann 条件：对于 $0 \\le x \\le 1$，$-\\,\\mathbf{n}\\cdot\\big(k\\,\\nabla T\\big)\\big|_{y=1}$ 是给定的。\n- 右边界为 Robin 条件：对于 $0 \\le y \\le 1$，$-\\,\\mathbf{n}\\cdot\\big(k\\,\\nabla T\\big)\\big|_{x=1} = h\\big(T(1,y,t) - T_\\infty\\big)$，其中 $h$ 为常数传热系数，$T_\\infty$ 为常数环境温度。\n\n您的任务是设计一个人工解 $T(x,y,t)$ 和相应的 $\\dot{q}(x,y,t)$，用于验证此变热导率热方程的计算求解器，并实现一个程序，在指定点计算所得表达式的值。使用以下科学上合理且足够光滑的选择，这些选择经过精心设计，以确保 Robin 边界条件被精确满足，同时保持域内热导率的空间变化性：\n- 热导率：\n$$\nk(x,y) = 1 + \\varepsilon\\,\\sin(\\pi x)\\,\\cos(\\pi y),\n$$\n其中 $\\varepsilon$ 是一个无量纲振幅参数。\n- 人工解：\n$$\nT(x,y,t) = T_\\infty + B(y,t)\\,e^{-h x},\n$$\n其中\n$$\nB(y,t) = \\sin(\\pi y)\\,\\cos(\\omega t) + y^2\\,t,\n$$\n其中 $h$ 是无量纲传热系数，$\\omega$ 是无量纲角频率（单位为弧度/单位时间）。三角函数中的所有角度都必须以弧度为单位。\n\n根据能量守恒基本陈述和傅里叶热传导定律，必须选择源项，以使人工解精确满足控制方程：\n$$\n\\dot{q}(x,y,t) = \\rho\\,c\\,\\frac{\\partial T}{\\partial t} - \\nabla \\cdot \\big(k(x,y)\\,\\nabla T(x,y,t)\\big).\n$$\n在 $x=0$ 和 $y=0$ 上的 Dirichlet 数据由限制在这些边界上的人工解 $T$ 给出。在 $y=1$ 上的 Neumann 数据是在 $y=1$ 处计算的向外热通量 $-\\,\\mathbf{n}\\cdot(k\\nabla T)$。在 $x=1$ 上的 Robin 条件对于所选的 $T$ 和 $k$ 必须精确成立。\n\n实现一个程序，对下面的每个测试用例，按规定计算一个标量值：\n- 对于内部点，计算 $\\dot{q}(x,y,t)$。\n- 对于上边界，计算在 $y=1$ 处的 Neumann 通量 $-\\,\\mathbf{n}\\cdot(k\\nabla T)$。\n- 对于右边界，计算 Robin 条件的绝对残差，\n$$\nR_{\\text{Robin}}(y,t) = \\left|-\\,\\mathbf{n}\\cdot\\big(k\\,\\nabla T\\big)\\big|_{x=1} - h\\big(T(1,y,t) - T_\\infty\\big)\\right|.\n$$\n- 对于下边界，计算 Dirichlet 绝对残差，\n$$\nR_{\\text{Dirichlet}}(x,t) = \\left|T(x,0,t) - T_\\infty\\right|.\n$$\n\n所有量都是无量纲的，因此不需要物理单位。使用以下测试套件，该套件检验内部源项、两种类型的边界通量和边界恒等式，包括边界情况：\n- 案例 1 (内部“理想路径”)：参数 $(\\varepsilon, h, \\omega, \\rho, c, T_\\infty) = (0.3, 2.0, 1.4, 1.1, 0.9, 0.2)$，点 $(x,y,t) = (0.25, 0.75, 0.5)$，输出 $\\dot{q}(x,y,t)$ 为十进制浮点数。\n- 案例 2 (上边界 Neumann 通量)：与案例 1 参数相同，点 $(x,t) = (0.4, 0.5)$ 位于 $y=1$ 处，输出 $-\\,\\mathbf{n}\\cdot(k\\nabla T)$ 为十进制浮点数。\n- 案例 3 (右边界 Robin 恒等式)：与案例 1 参数相同，点 $(y,t) = (0.6, 0.75)$ 位于 $x=1$ 处，输出 $R_{\\text{Robin}}(y,t)$ 为十进制浮点数。\n- 案例 4 (下边界 Dirichlet 恒等式)：与案例 1 参数相同，点 $(x,t) = (0.7, 0.33)$ 位于 $y=0$ 处，输出 $R_{\\text{Dirichlet}}(x,t)$ 为十进制浮点数。\n- 案例 5 (具有恒定热导率和零时间的内部边界情况)：参数 $(\\varepsilon, h, \\omega, \\rho, c, T_\\infty) = (0.0, 1.5, 2.0, 1.0, 1.0, 0.1)$，点 $(x,y,t) = (0.5, 0.5, 0.0)$，输出 $\\dot{q}(x,y,t)$ 为十进制浮点数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$\\,[r_1,r_2,r_3,r_4,r_5]$\\,），其中 $r_i$ 是按上面列出的顺序为案例 $i$ 计算的标量。角度必须以弧度为单位。不应打印任何其他文本。",
            "solution": "问题陈述已经过仔细验证，并被确定为应用人工解法（Method of Manufactured Solutions）验证偏微分方程数值求解器的一项有效练习。该问题具有科学依据，对于指定的评估任务是适定的、客观的且内部一致的。\n\n任务是为具有可变热导率的无量纲热方程，根据给出的人工解，推导并计算源项 $\\dot{q}$、边界通量和边界条件残差的表达式。\n\n控制方程为：\n$$\n\\rho\\,c\\,\\frac{\\partial T}{\\partial t} = \\nabla \\cdot \\big(k(x,y)\\,\\nabla T(x,y,t)\\big) + \\dot{q}(x,y,t)\n$$\n为满足给定人工解 $T$ 的方程所需的源项 $\\dot{q}$，可通过整理方程得到：\n$$\n\\dot{q}(x,y,t) = \\rho\\,c\\,\\frac{\\partial T}{\\partial t} - \\nabla \\cdot \\big(k(x,y)\\,\\nabla T(x,y,t)\\big)\n$$\n使用向量微积分恒等式 $\\nabla \\cdot (\\phi \\mathbf{F}) = (\\nabla \\phi) \\cdot \\mathbf{F} + \\phi (\\nabla \\cdot \\mathbf{F})$，其中标量场为 $\\phi = k$，向量场为 $\\mathbf{F} = \\nabla T$，散度项可展开为：\n$$\n\\nabla \\cdot (k \\nabla T) = (\\nabla k) \\cdot (\\nabla T) + k (\\nabla \\cdot (\\nabla T)) = \\nabla k \\cdot \\nabla T + k \\nabla^2 T\n$$\n因此，源项表示为：\n$$\n\\dot{q}(x,y,t) = \\rho\\,c\\,\\frac{\\partial T}{\\partial t} - (\\nabla k \\cdot \\nabla T + k \\nabla^2 T)\n$$\n为了计算此表达式，我们必须计算给定的人工解 $T(x,y,t)$ 和热导率 $k(x,y)$ 的偏导数。\n\n给定的函数是：\n- 热导率：$k(x,y) = 1 + \\varepsilon\\,\\sin(\\pi x)\\,\\cos(\\pi y)$\n- 温度：$T(x,y,t) = T_\\infty + B(y,t)\\,e^{-h x}$，其中 $B(y,t) = \\sin(\\pi y)\\,\\cos(\\omega t) + y^2\\,t$\n\n我们接下来推导所需的导数。\n\n$B(y,t)$ 的导数：\n- $\\frac{\\partial B}{\\partial t} = -\\omega\\,\\sin(\\pi y)\\,\\sin(\\omega t) + y^2$\n- $\\frac{\\partial B}{\\partial y} = \\pi\\,\\cos(\\pi y)\\,\\cos(\\omega t) + 2yt$\n- $\\frac{\\partial^2 B}{\\partial y^2} = -\\pi^2\\,\\sin(\\pi y)\\,\\cos(\\omega t) + 2t$\n\n$T(x,y,t)$ 的导数：\n- 时间导数：$\\frac{\\partial T}{\\partial t} = \\frac{\\partial B}{\\partial t}\\,e^{-h x} = \\big(-\\omega\\,\\sin(\\pi y)\\,\\sin(\\omega t) + y^2\\big)\\,e^{-h x}$\n- 梯度 $\\nabla T$：\n  - $\\frac{\\partial T}{\\partial x} = -h\\,B(y,t)\\,e^{-h x}$\n  - $\\frac{\\partial T}{\\partial y} = \\frac{\\partial B}{\\partial y}\\,e^{-h x} = \\big(\\pi\\,\\cos(\\pi y)\\,\\cos(\\omega t) + 2yt\\big)\\,e^{-h x}$\n  - $\\nabla T = \\begin{pmatrix} -h\\,B\\,e^{-h x} \\\\ \\frac{\\partial B}{\\partial y}\\,e^{-h x} \\end{pmatrix}$\n- 拉普拉斯算子 $\\nabla^2 T$：\n  - $\\frac{\\partial^2 T}{\\partial x^2} = h^2\\,B(y,t)\\,e^{-h x}$\n  - $\\frac{\\partial^2 T}{\\partial y^2} = \\frac{\\partial^2 B}{\\partial y^2}\\,e^{-h x} = \\big(-\\pi^2\\,\\sin(\\pi y)\\,\\cos(\\omega t) + 2t\\big)\\,e^{-h x}$\n  - $\\nabla^2 T = \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} = \\Big(h^2\\,B + \\frac{\\partial^2 B}{\\partial y^2}\\Big)\\,e^{-h x}$\n\n$k(x,y)$ 的导数：\n- 梯度 $\\nabla k$：\n  - $\\frac{\\partial k}{\\partial x} = \\varepsilon\\,\\pi\\,\\cos(\\pi x)\\,\\cos(\\pi y)$\n  - $\\frac{\\partial k}{\\partial y} = -\\varepsilon\\,\\pi\\,\\sin(\\pi x)\\,\\sin(\\pi y)$\n  - $\\nabla k = \\begin{pmatrix} \\varepsilon\\,\\pi\\,\\cos(\\pi x)\\,\\cos(\\pi y) \\\\ -\\varepsilon\\,\\pi\\,\\sin(\\pi x)\\,\\sin(\\pi y) \\end{pmatrix}$\n\n在计算出所有分量导数后，我们可以组合计算 $\\dot{q}$ 和边界通量所需的各项。\n\n案例 1 和 5：内部源项 $\\dot{q}(x,y,t)$\n项 $\\nabla k \\cdot \\nabla T$ 为：\n$$\n\\nabla k \\cdot \\nabla T = \\frac{\\partial k}{\\partial x}\\frac{\\partial T}{\\partial x} + \\frac{\\partial k}{\\partial y}\\frac{\\partial T}{\\partial y} = \\big( (\\varepsilon\\,\\pi\\,\\cos(\\pi x)\\,\\cos(\\pi y))(-h B) + (-\\varepsilon\\,\\pi\\,\\sin(\\pi x)\\,\\sin(\\pi y))(\\frac{\\partial B}{\\partial y}) \\big) e^{-hx}\n$$\n通过将所有推导出的表达式代入 $\\dot{q} = \\rho\\,c\\,\\frac{\\partial T}{\\partial t} - (\\nabla k \\cdot \\nabla T + k \\nabla^2 T)$ 来计算源项 $\\dot{q}$。\n\n案例 2：上边界 ($y=1$) 的 Neumann 通量\n上边界的外法向量为 $\\mathbf{n} = (0, 1)$。给定的 Neumann 通量为 $-\\mathbf{n}\\cdot(k\\nabla T)$。\n$$\n\\text{通量} = -\\mathbf{n}\\cdot(k\\nabla T)\\big|_{y=1} = -(0,1) \\cdot \\begin{pmatrix} k \\frac{\\partial T}{\\partial x} \\\\ k \\frac{\\partial T}{\\partial y} \\end{pmatrix}_{y=1} = -k(x,1)\\,\\frac{\\partial T}{\\partial y}\\Big|_{y=1}\n$$\n在 $y=1$ 处：\n- $k(x,1) = 1 + \\varepsilon\\,\\sin(\\pi x)\\,\\cos(\\pi) = 1 - \\varepsilon\\,\\sin(\\pi x)$\n- $\\frac{\\partial B}{\\partial y}\\Big|_{y=1} = \\pi\\,\\cos(\\pi)\\,\\cos(\\omega t) + 2(1)t = -\\pi\\,\\cos(\\omega t) + 2t$\n- $\\frac{\\partial T}{\\partial y}\\Big|_{y=1} = \\big(-\\pi\\,\\cos(\\omega t) + 2t\\big)\\,e^{-h x}$\n最终的通量为：\n$$\n\\text{通量} = -\\big(1 - \\varepsilon\\,\\sin(\\pi x)\\big)\\big(-\\pi\\,\\cos(\\omega t) + 2t\\big)\\,e^{-h x}\n$$\n\n案例 3：右边界 ($x=1$) 的 Robin 残差\n外法向量为 $\\mathbf{n} = (1, 0)$。残差为：\n$$\nR_{\\text{Robin}} = \\left|-\\mathbf{n}\\cdot(k\\nabla T)\\big|_{x=1} - h\\big(T(1,y,t) - T_\\infty\\big)\\right| = \\left|-k(1,y)\\frac{\\partial T}{\\partial x}\\Big|_{x=1} - h\\big(T(1,y,t) - T_\\infty\\big)\\right|\n$$\n根据构造：\n- $k(1,y) = 1 + \\varepsilon\\,\\sin(\\pi)\\,\\cos(\\pi y) = 1$。\n- $\\frac{\\partial T}{\\partial x}\\big|_{x=1} = -h\\,B(y,t)\\,e^{-h}$。\n- 通量项为 $-k(1,y)\\frac{\\partial T}{\\partial x}\\big|_{x=1} = -(1)(-h\\,B\\,e^{-h}) = h\\,B\\,e^{-h}$。\n- 环境项为 $h(T(1,y,t) - T_\\infty) = h\\big( (T_\\infty + B\\,e^{-h}) - T_\\infty \\big) = h\\,B\\,e^{-h}$。\n这两项是相同的，因此它们的差为 $0$。残差 $R_{\\text{Robin}}$ 恒等于零。\n\n案例 4：下边界 ($y=0$) 的 Dirichlet 残差\n残差为：\n$$\nR_{\\text{Dirichlet}} = \\left|T(x,0,t) - T_\\infty\\right|\n$$\n在 $y=0$ 处：\n- $B(0,t) = \\sin(0)\\,\\cos(\\omega t) + (0)^2 t = 0$。\n- $T(x,0,t) = T_\\infty + B(0,t)\\,e^{-hx} = T_\\infty$。\n残差为 $|T_\\infty - T_\\infty| = 0$。残差 $R_{\\text{Dirichlet}}$ 恒等于零。\n\n这些推导出的数学表达式在以下程序中实现，用于计算指定测试用例的数值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes results for the specified test cases based on the Method of Manufactured Solutions.\n    \"\"\"\n    test_cases = [\n        # Case 1: interior \"happy path\"\n        {'case_id': 1, 'params': (0.3, 2.0, 1.4, 1.1, 0.9, 0.2), 'point': (0.25, 0.75, 0.5), 'type': 'q_source'},\n        # Case 2: top edge Neumann flux\n        {'case_id': 2, 'params': (0.3, 2.0, 1.4, 1.1, 0.9, 0.2), 'point': (0.4, 1.0, 0.5), 'type': 'neumann_flux_y1'},\n        # Case 3: right edge Robin identity\n        {'case_id': 3, 'params': (0.3, 2.0, 1.4, 1.1, 0.9, 0.2), 'point': (1.0, 0.6, 0.75), 'type': 'robin_residual_x1'},\n        # Case 4: bottom edge Dirichlet identity\n        {'case_id': 4, 'params': (0.3, 2.0, 1.4, 1.1, 0.9, 0.2), 'point': (0.7, 0.0, 0.33), 'type': 'dirichlet_residual_y0'},\n        # Case 5: interior edge case\n        {'case_id': 5, 'params': (0.0, 1.5, 2.0, 1.0, 1.0, 0.1), 'point': (0.5, 0.5, 0.0), 'type': 'q_source'},\n    ]\n\n    results = []\n    for case in test_cases:\n        params = case['params']\n        point = case['point']\n        calc_type = case['type']\n        \n        result = compute_quantity(params, point, calc_type)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_quantity(params_tuple, point_tuple, calc_type):\n    \"\"\"\n    Computes a specific quantity (source term, flux, or residual) for given parameters and a point.\n    \"\"\"\n    eps, h, omega, rho, c, T_inf = params_tuple\n    x, y, t = point_tuple\n\n    # Helper terms related to B(y,t) = sin(pi*y)*cos(omega*t) + y^2*t\n    sin_pi_y = np.sin(np.pi * y)\n    cos_pi_y = np.cos(np.pi * y)\n    sin_omega_t = np.sin(omega * t)\n    cos_omega_t = np.cos(omega * t)\n\n    B = sin_pi_y * cos_omega_t + y**2 * t\n    dB_dt = -omega * sin_pi_y * sin_omega_t + y**2\n    dB_dy = np.pi * cos_pi_y * cos_omega_t + 2 * y * t\n    d2B_dy2 = -np.pi**2 * sin_pi_y * cos_omega_t + 2 * t\n\n    # Helper terms related to T(x,y,t) = T_inf + B(y,t)*exp(-h*x)\n    exp_neg_hx = np.exp(-h * x)\n    \n    T = T_inf + B * exp_neg_hx\n    dT_dt = dB_dt * exp_neg_hx\n    dT_dx = -h * B * exp_neg_hx\n    dT_dy = dB_dy * exp_neg_hx\n\n    # Helper terms for k(x,y) = 1 + eps*sin(pi*x)*cos(pi*y)\n    k = 1.0 + eps * np.sin(np.pi * x) * cos_pi_y\n    dk_dx = eps * np.pi * np.cos(np.pi * x) * cos_pi_y\n    dk_dy = -eps * np.pi * np.sin(np.pi * x) * sin_pi_y\n    \n    if calc_type == 'q_source':\n        # Laplacian T term: d2T_dx2 + d2T_dy2\n        d2T_dx2 = h**2 * B * exp_neg_hx\n        d2T_dy2 = d2B_dy2 * exp_neg_hx\n        laplacian_T = d2T_dx2 + d2T_dy2\n        \n        # Divergence term: grad(k) . grad(T) + k * laplacian(T)\n        grad_k_dot_grad_T = dk_dx * dT_dx + dk_dy * dT_dy\n        div_k_grad_T = grad_k_dot_grad_T + k * laplacian_T\n        \n        q = rho * c * dT_dt - div_k_grad_T\n        return q\n\n    elif calc_type == 'neumann_flux_y1':\n        # On y=1, normal n is (0,1). Flux is -n.(k*grad(T)) = -k*dT/dy\n        # Re-evaluate terms at y=1, careful with sin(pi*1) = 0, cos(pi*1) = -1\n        y_b = 1.0\n        cos_pi_y_b = -1.0\n        \n        k_b = 1.0 + eps * np.sin(np.pi * x) * cos_pi_y_b # k at y=1\n        \n        dB_dy_b = np.pi * cos_pi_y_b * cos_omega_t + 2 * y_b * t\n        dT_dy_b = dB_dy_b * exp_neg_hx\n        \n        flux = -k_b * dT_dy_b\n        return flux\n\n    elif calc_type == 'robin_residual_x1':\n        # Residual is | -k*dT/dx - h*(T - T_inf) | at x=1\n        # Re-evaluate at x=1, where sin(pi*1)=0\n        x_b = 1.0\n        exp_neg_hx_b = np.exp(-h * x_b)\n\n        k_b = 1.0 # k at x=1\n        \n        T_b = T_inf + B * exp_neg_hx_b\n        dT_dx_b = -h * B * exp_neg_hx_b\n        \n        flux_term = -k_b * dT_dx_b\n        ambient_term = h * (T_b - T_inf)\n        \n        residual = np.abs(flux_term - ambient_term)\n        return residual\n        \n    elif calc_type == 'dirichlet_residual_y0':\n        # Residual is |T - T_inf| at y=0\n        # Re-evaluate at y=0, where sin(0)=0 and y^2=0\n        y_b = 0.0\n        \n        B_b = 0.0\n        T_b = T_inf + B_b * exp_neg_hx\n        \n        residual = np.abs(T_b - T_inf)\n        return residual\n        \n    else:\n        raise ValueError(f\"Unknown calculation type: {calc_type}\")\n\nsolve()\n```"
        }
    ]
}