{
    "hands_on_practices": [
        {
            "introduction": "This first practice is foundational, guiding you through the derivation of the discrete pressure correction equation from first principles. By applying the divergence theorem to a finite control volume, we will see how the continuous Poisson equation for pressure transforms into a set of algebraic equations that can be solved numerically . This exercise is crucial for understanding how the physical mandate of mass conservation is enforced at the discrete level within a computational grid.",
            "id": "3993952",
            "problem": "An isothermal, incompressible flow of a Newtonian fluid with constant density $\\rho$ is simulated in a one-dimensional channel of length $L$ and uniform cross-sectional area $A$, using a collocated finite volume method with $N$ equal control volumes. The energy equation is decoupled and not solved, and the flow is considered only along the $x$-direction. The fundamental base for the derivation is the conservation of mass for incompressible flow, $\\nabla \\cdot \\mathbf{u} = 0$, and the momentum balance from the incompressible Navier–Stokes equations with explicit treatment of convection and diffusion and implicit treatment of the pressure at the new time. A backward Euler time stepping scheme with time step $\\Delta t$ is used to advance the solution from time level $n$ to $n+1$.\n\nA fractional-step (projection) approach is applied: first, a predicted velocity field $\\mathbf{u}^{*}$ is obtained by solving the momentum equation without the pressure gradient at time level $n+1$; then a pressure correction $p'$ is introduced such that the corrected velocity $\\mathbf{u}^{n+1} = \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla p'$ satisfies the incompressible continuity equation at time level $n+1$. This yields a pressure correction equation of Poisson type. The domain is discretized into $N$ uniform control volumes of width $\\Delta x = L/N$, with pressures $p'$ stored at cell centers, face-centered gradients approximated by second-order central differences, and face velocities $u^{*}_{i\\pm 1/2}$ used to evaluate the discrete divergence.\n\nFor an interior control volume indexed by $i$, derive the discrete pressure correction equation in tridiagonal form,\n$$\na_{P} \\, p'_{i} = a_{E} \\, p'_{i+1} + a_{W} \\, p'_{i-1} + b_{i},\n$$\nwhere $a_{P}$, $a_{E}$, and $a_{W}$ are the linear system coefficients and $b_{i}$ is the contribution from the predicted velocity divergence. Using only the fundamental laws and the stated discretization assumptions, determine the symbolic expression for the diagonal coefficient $a_{P}$ for an interior cell in terms of the cross-sectional area $A$ and the uniform cell width $\\Delta x$. Express your final answer as a closed-form analytic expression. No rounding is required, and no units should be included in the final boxed answer.",
            "solution": "The derivation of the discrete pressure correction equation begins with the fundamental relations of the fractional-step (projection) method for incompressible flow. The corrected velocity field at the new time step, $\\mathbf{u}^{n+1}$, must satisfy the continuity equation for an incompressible fluid:\n$$\n\\nabla \\cdot \\mathbf{u}^{n+1} = 0\n$$\nThe corrected velocity is related to the predicted velocity, $\\mathbf{u}^{*}$, and the pressure correction, $p'$, by the formula provided:\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla p'\n$$\nwhere $\\Delta t$ is the time step and $\\rho$ is the constant fluid density.\n\nSubstituting the second equation into the first yields the continuous pressure correction equation:\n$$\n\\nabla \\cdot \\left( \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla p' \\right) = 0\n$$\nAs $\\Delta t$ and $\\rho$ are constants, the divergence operator can be distributed:\n$$\n\\nabla \\cdot \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla \\cdot (\\nabla p') = 0\n$$\nThis rearranges to the Poisson equation for the pressure correction $p'$:\n$$\n\\nabla^2 p' = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^{*}\n$$\nHere, $\\nabla^2$ is the Laplacian operator, which is $\\nabla \\cdot \\nabla$.\n\nTo discretize this equation using the finite volume method, we integrate it over a generic interior control volume $CV_i$. The control volume has a uniform width $\\Delta x$ and a constant cross-sectional area $A$, so its volume is $V_P = A \\Delta x$.\n$$\n\\int_{CV_i} \\nabla^2 p' \\, dV = \\int_{CV_i} \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^{*} \\, dV\n$$\nApplying the divergence theorem, which states $\\int_V (\\nabla \\cdot \\mathbf{F}) \\, dV = \\oint_S (\\mathbf{F} \\cdot \\mathbf{n}) \\, dS$, to both sides of the equation. For the one-dimensional case, the surface integral simplifies to a sum over the east ($e$) and west ($w$) faces of the control volume, located at $x_{i+1/2}$ and $x_{i-1/2}$ respectively. The area of each face is $A$.\n\nThe left-hand side (LHS) becomes:\n$$\n\\int_{CV_i} \\nabla \\cdot (\\nabla p') \\, dV = \\oint_{S_i} (\\nabla p' \\cdot \\mathbf{n}) \\, dS = \\left[ A \\left( \\frac{\\partial p'}{\\partial x} \\right) \\right]_{e} - \\left[ A \\left( \\frac{\\partial p'}{\\partial x} \\right) \\right]_{w}\n$$\nThe problem specifies that face-centered gradients are approximated by second-order central differences. The gradient at the east face ($e$) is approximated using the cell-center values $p'_{i+1}$ and $p'_{i}$, and the gradient at the west face ($w$) is approximated using $p'_{i}$ and $p'_{i-1}$:\n$$\n\\left( \\frac{\\partial p'}{\\partial x} \\right)_{e} \\approx \\frac{p'_{i+1} - p'_{i}}{\\Delta x}\n$$\n$$\n\\left( \\frac{\\partial p'}{\\partial x} \\right)_{w} \\approx \\frac{p'_{i} - p'_{i-1}}{\\Delta x}\n$$\nSubstituting these approximations into the LHS gives:\n$$\n\\text{LHS} = A \\left( \\frac{p'_{i+1} - p'_{i}}{\\Delta x} \\right) - A \\left( \\frac{p'_{i} - p'_{i-1}}{\\Delta x} \\right) = \\frac{A}{\\Delta x} (p'_{i+1} - 2p'_{i} + p'_{i-1})\n$$\nThe right-hand side (RHS) of the integrated equation is:\n$$\n\\text{RHS} = \\frac{\\rho}{\\Delta t} \\int_{CV_i} \\nabla \\cdot \\mathbf{u}^{*} \\, dV = \\frac{\\rho}{\\Delta t} \\oint_{S_i} (\\mathbf{u}^{*} \\cdot \\mathbf{n}) \\, dS = \\frac{\\rho}{\\Delta t} \\left( [A u^{*}]_{e} - [A u^{*}]_{w} \\right)\n$$\nwhere $u^{*}_{e}$ and $u^{*}_{w}$ are the face-centered predicted velocities (given as $u^{*}_{i+1/2}$ and $u^{*}_{i-1/2}$).\n\nEquating the LHS and RHS:\n$$\n\\frac{A}{\\Delta x} (p'_{i+1} - 2p'_{i} + p'_{i-1}) = \\frac{\\rho A}{\\Delta t} (u^{*}_{i+1/2} - u^{*}_{i-1/2})\n$$\nWe must now rearrange this equation into the target form specified in the problem:\n$$\na_{P} \\, p'_{i} = a_{E} \\, p'_{i+1} + a_{W} \\, p'_{i-1} + b_{i}\n$$\nFrom our derived equation, we isolate the term with $p'_{i}$:\n$$\n-\\frac{2A}{\\Delta x} p'_{i} = - \\frac{A}{\\Delta x} p'_{i+1} - \\frac{A}{\\Delta x} p'_{i-1} + \\frac{\\rho A}{\\Delta t} (u^{*}_{i+1/2} - u^{*}_{i-1/2})\n$$\nMultiplying the entire equation by $-1$ to make the coefficient of $p'_i$ positive:\n$$\n\\frac{2A}{\\Delta x} p'_{i} = \\frac{A}{\\Delta x} p'_{i+1} + \\frac{A}{\\Delta x} p'_{i-1} - \\frac{\\rho A}{\\Delta t} (u^{*}_{i+1/2} - u^{*}_{i-1/2})\n$$\nThis equation now matches the target form. The problem states that $b_{i}$ is the contribution from the predicted velocity divergence, and that the coefficients $a_P, a_E, a_W$ should be expressed in terms of $A$ and $\\Delta x$ only. This unique algebraic arrangement partitions the terms as follows:\n$$\na_{P} = \\frac{2A}{\\Delta x}\n$$\n$$\na_{E} = \\frac{A}{\\Delta x}\n$$\n$$\na_{W} = \\frac{A}{\\Delta x}\n$$\n$$\nb_{i} = - \\frac{\\rho A}{\\Delta t} (u^{*}_{i+1/2} - u^{*}_{i-1/2})\n$$\nThis form satisfies all conditions, notably that $a_P$, $a_E$, and $a_W$ depend only on the geometric parameters $A$ and $\\Delta x$, while the physical parameters $\\rho$ and the time step $\\Delta t$ are absorbed into the source term $b_i$.\n\nThe diagonal coefficient for an interior cell is therefore:\n$$\na_{P} = \\frac{2A}{\\Delta x}\n$$",
            "answer": "$$\n\\boxed{\\frac{2A}{\\Delta x}}\n$$"
        },
        {
            "introduction": "A key challenge in using collocated grids is the potential for pressure-velocity decoupling, leading to unphysical, high-frequency pressure oscillations known as 'checkerboarding'. This practice delves into the Rhie-Chow interpolation method, a widely used technique to suppress these oscillations, by analyzing its effect on different pressure modes . Through Fourier analysis, you will demonstrate how this numerical method selectively damps the problematic checkerboard mode, thereby ensuring a stable and physically realistic pressure field.",
            "id": "3993953",
            "problem": "Consider a one-dimensional, periodic, uniformly discretized domain of length $L$ with $N$ collocated control volumes of spacing $h = L/N$, constant density $\\rho$, and incompressible flow. A pressure-correction step is carried out within the Semi-Implicit Method for Pressure-Linked Equations (SIMPLE), and face-normal velocities are computed on a collocated grid using Rhie–Chow interpolation. The Rhie–Chow interpolation modifies the face-normal velocity at the face between cells $i$ and $i+1$ by adding a pressure-difference-based term that comes from the discretized momentum equation, while other non-pressure contributions are aggregated in an interpolated term. Denote the pressure at cell center $i$ by $p_i$ and model the pressure-induced contribution to the face-normal velocity at face $i+1/2$ as $u_{i+1/2}^{p} = -\\delta\\,(p_{i+1} - p_i)$, where $\\delta > 0$ is a constant determined by the diagonal dominance of the discretized momentum operator and grid metrics. Assume that all non-pressure contributions to the face-normal velocities either cancel from the divergence in the pressure-correction equation or do not affect the analysis of pressure-mode coupling.\n\nStarting from the conservation of mass and its discrete divergence form for incompressible flow, derive the linear operator $L$ acting on the pressure field that arises solely from the Rhie–Chow pressure-difference contribution to the face-normal velocities. On the uniform grid, perform a Fourier (normal-mode) analysis by considering a pressure mode of the form $p_i = \\hat{p}\\,\\exp(\\mathrm{i} k x_i)$ with $x_i = i h$ and wavenumber $k$. Determine the normalized Fourier symbol $\\sigma(k)$ such that $L p_i = \\left(\\frac{\\delta}{h}\\right)\\sigma(k)\\,p_i$.\n\nFinally, evaluate the normalized symbol for the checkerboard mode characterized by $k h = \\pi$. Express your final answer as a single real number. No rounding is required, and no physical units should be attached to the final value because the requested symbol is dimensionless by construction.",
            "solution": "The derivation begins with the principle of mass conservation for an incompressible flow. In one dimension, the differential form of the continuity equation is $\\frac{du}{dx} = 0$. For a collocated grid, we apply the finite volume method to a control volume centered at node $i$, which extends from face $i-\\frac{1}{2}$ to face $i+\\frac{1}{2}$. The discrete form of the continuity equation is obtained by integrating the divergence over the control volume and applying the divergence theorem, which results in:\n$$\n\\frac{u_{i+1/2} - u_{i-1/2}}{h} = 0\n$$\nwhere $u_{i+1/2}$ and $u_{i-1/2}$ are the velocities at the control volume faces and $h$ is the uniform grid spacing.\n\nThe problem states that we are to consider only the pressure-induced contribution to the face-normal velocity, which is given by the Rhie-Chow interpolation model:\n$$\nu_{i+1/2}^{p} = -\\delta\\,(p_{i+1} - p_i)\n$$\nwhere $p_i$ is the pressure at cell center $i$ and $\\delta > 0$ is a constant. The term $u_{i-1/2}^{p}$ is found by shifting the index $i$ to $i-1$:\n$$\nu_{i-1/2}^{p} = -\\delta\\,(p_i - p_{i-1})\n$$\nThe linear operator $L$ acting on the pressure field $p$ arises from substituting these pressure-dependent velocities into the discrete continuity equation. This operator forms the left-hand side of the pressure-correction Poisson equation. We define $L p_i$ as the discrete divergence of this velocity field:\n$$\nL p_i = \\frac{u_{i+1/2}^{p} - u_{i-1/2}^{p}}{h}\n$$\nSubstituting the expressions for the face velocities:\n$$\nL p_i = \\frac{1}{h} \\left[ (-\\delta\\,(p_{i+1} - p_i)) - (-\\delta\\,(p_i - p_{i-1})) \\right]\n$$\nFactoring out the constant $-\\frac{\\delta}{h}$:\n$$\nL p_i = -\\frac{\\delta}{h} \\left[ (p_{i+1} - p_i) - (p_i - p_{i-1}) \\right]\n$$\nSimplifying the expression inside the brackets gives the discrete Laplacian stencil:\n$$\nL p_i = -\\frac{\\delta}{h} (p_{i+1} - 2p_i + p_{i-1})\n$$\nThis is the derived linear operator $L$ acting on the pressure field.\n\nNext, we perform a Fourier (normal-mode) analysis by considering a pressure mode of the form $p_i = \\hat{p}\\,\\exp(\\mathrm{i} k x_i)$, where $x_i = i h$. To find the action of $L$ on this mode, we first express $p_{i+1}$ and $p_{i-1}$ in terms of $p_i$:\n$$\np_{i+1} = \\hat{p}\\,\\exp(\\mathrm{i} k x_{i+1}) = \\hat{p}\\,\\exp(\\mathrm{i} k (x_i + h)) = \\hat{p}\\,\\exp(\\mathrm{i} k x_i)\\,\\exp(\\mathrm{i} k h) = p_i\\,\\exp(\\mathrm{i} k h)\n$$\n$$\np_{i-1} = \\hat{p}\\,\\exp(\\mathrm{i} k x_{i-1}) = \\hat{p}\\,\\exp(\\mathrm{i} k (x_i - h)) = \\hat{p}\\,\\exp(\\mathrm{i} k x_i)\\,\\exp(-\\mathrm{i} k h) = p_i\\,\\exp(-\\mathrm{i} k h)\n$$\nSubstituting these into the expression for $L p_i$:\n$$\nL p_i = -\\frac{\\delta}{h} (p_i\\,\\exp(\\mathrm{i} k h) - 2p_i + p_i\\,\\exp(-\\mathrm{i} k h))\n$$\nFactoring out $p_i$:\n$$\nL p_i = -\\frac{\\delta}{h} p_i (\\exp(\\mathrm{i} k h) - 2 + \\exp(-\\mathrm{i} k h))\n$$\nUsing the Euler identity $\\cos(\\theta) = \\frac{\\exp(\\mathrm{i}\\theta) + \\exp(-\\mathrm{i}\\theta)}{2}$, we can write $\\exp(\\mathrm{i} k h) + \\exp(-\\mathrm{i} k h) = 2\\cos(k h)$. The expression in the parenthesis becomes:\n$$\n\\exp(\\mathrm{i} k h) - 2 + \\exp(-\\mathrm{i} k h) = 2\\cos(k h) - 2 = -2(1 - \\cos(k h))\n$$\nSubstituting this back into the equation for $L p_i$:\n$$\nL p_i = -\\frac{\\delta}{h} p_i [-2(1 - \\cos(k h))]\n$$\n$$\nL p_i = \\frac{2\\delta}{h} (1 - \\cos(k h)) p_i\n$$\nThe problem requires us to find the normalized Fourier symbol $\\sigma(k)$ defined by the relation $L p_i = \\left(\\frac{\\delta}{h}\\right)\\sigma(k)\\,p_i$. By comparing this definition with our derived result, we can identify $\\sigma(k)$:\n$$\n\\left(\\frac{\\delta}{h}\\right)\\sigma(k)\\,p_i = \\frac{2\\delta}{h} (1 - \\cos(k h)) p_i\n$$\nCanceling the common factor $\\left(\\frac{\\delta}{h}\\right)p_i$ from both sides, we obtain the expression for the normalized symbol:\n$$\n\\sigma(k) = 2(1 - \\cos(k h))\n$$\nFinally, we must evaluate this symbol for the checkerboard mode, which is characterized by the dimensionless wavenumber $k h = \\pi$. This mode corresponds to the highest frequency that can be resolved on the grid, with pressure values alternating in sign between adjacent cells, i.e., $p_i \\propto (-1)^i$. Substituting $k h = \\pi$ into the expression for $\\sigma(k)$:\n$$\n\\sigma(k)\\rvert_{kh=\\pi} = 2(1 - \\cos(\\pi))\n$$\nSince $\\cos(\\pi) = -1$, the evaluation is:\n$$\n\\sigma(k)\\rvert_{kh=\\pi} = 2(1 - (-1)) = 2(1 + 1) = 4\n$$\nThis result indicates that the discrete operator responds most strongly to the checkerboard mode, which is the desired behavior of the Rhie-Chow interpolation—to prevent such spurious pressure oscillations by creating a well-conditioned pressure-Poisson equation.",
            "answer": "$$ \\boxed{4} $$"
        },
        {
            "introduction": "The pressure correction equation ultimately yields a large, sparse linear system of the form $A x = b$ that must be solved efficiently. This final hands-on practice transitions from theory to computation, tasking you with implementing a Preconditioned Conjugate Gradient (PCG) solver to find the pressure correction vector . The focus is not just on the solution itself, but on the critical diagnostics—such as absolute and relative residuals—that are used to monitor the solver's convergence and ensure the accuracy of the final solution.",
            "id": "3993963",
            "problem": "Consider a steady, incompressible flow of a Newtonian fluid on a one-dimensional, collocated finite volume grid with uniform cell volumes. The discrete mass conservation for each control volume requires that the algebraic sum of mass fluxes across its faces be zero. Starting from the conservation of mass and Newton’s second law applied to a finite volume, and using a segregated solution strategy where the momentum equations are first solved to obtain a provisional velocity field, the pressure field must be corrected to enforce discrete continuity. This yields a linear, symmetric positive definite discrete system for the pressure correction variable that couples neighboring control volumes through the flux correction terms. The numerical task is to solve this linear system efficiently and to design diagnostics that quantify convergence based on residuals and their normalization.\n\nYour job is twofold:\n- From first principles, reason about the structure of the pressure correction equation arising from the requirement that the corrected mass fluxes satisfy the discrete continuity equation, and define appropriate residuals and convergence criteria for the iterative solution of the resulting symmetric positive definite linear system.\n- Implement a program that, for a given set of small symmetric positive definite systems representative of pressure correction equations on one-dimensional grids, solves for the correction variable using an iterative method with a simple preconditioner, while computing diagnostics for residuals and convergence. The program must output a single line aggregating the diagnostics for all provided test cases.\n\nUse the following definitions to guide the design of your diagnostics:\n- Let the linear system for the correction variable be written abstractly as $A x = b$, where $A \\in \\mathbb{R}^{n \\times n}$ is symmetric positive definite, $x \\in \\mathbb{R}^{n}$ is the unknown vector of pressure corrections, and $b \\in \\mathbb{R}^{n}$ encodes the discrete mass imbalance due to the provisional fluxes. Define the residual at iteration $k$ as $r^{(k)} = b - A x^{(k)}$.\n- Define the unnormalized residual norm as $R_{2}^{(k)} = \\lVert r^{(k)} \\rVert_{2}$ and the normalized residual as $N_{2}^{(k)} = \\dfrac{\\lVert r^{(k)} \\rVert_{2}}{\\max\\left(\\lVert b \\rVert_{2}, \\varepsilon\\right)}$, with $\\varepsilon = 10^{-30}$ to avoid division by zero.\n- Define the monotonicity ratio for $k \\geq 1$ as $q^{(k)} = \\dfrac{\\lVert r^{(k)} \\rVert_{2}}{\\lVert r^{(k-1)} \\rVert_{2}}$. Use a divergence detector that flags nonconvergence if $q^{(k)} > \\gamma$ for at least $\\kappa$ consecutive iterations, where $\\gamma > 1$ and $\\kappa \\in \\mathbb{N}$ are specified per test case.\n\nConvergence must be declared if and only if both $R_{2}^{(k)} \\leq \\tau_{\\text{abs}}$ and $N_{2}^{(k)} \\leq \\tau_{\\text{rel}}$ before hitting the maximum number of iterations. Otherwise, return nonconvergence.\n\nAlgorithmic requirement:\n- Use the Preconditioned Conjugate Gradient (PCG) method with a diagonal (Jacobi) preconditioner $M = \\operatorname{diag}(A)$ to solve each system. Initialize with a given $x^{(0)}$. At each iteration, update the solution, residual, search direction, and compute $R_{2}^{(k)}$, $N_{2}^{(k)}$, and $q^{(k)}$. Apply the divergence detector parameters $(\\gamma, \\kappa)$.\n\nTest suite:\nImplement your solver and diagnostics on the following three independent test cases. Each case is a linear system with $A$, $b$, and solver parameters. All numbers are dimensionless.\n\n- Test case $1$ (well-conditioned, “happy path”):\n  - $n = 5$,\n  - $$A = \\begin{bmatrix}\n  2 & -1 & 0 & 0 & 0\\\\\n  -1 & 2 & -1 & 0 & 0\\\\\n  0 & -1 & 2 & -1 & 0\\\\\n  0 & 0 & -1 & 2 & -1\\\\\n  0 & 0 & 0 & -1 & 2\n  \\end{bmatrix},\\quad\n  b = \\begin{bmatrix} 1\\\\ -2\\\\ 3\\\\ -2\\\\ 1 \\end{bmatrix},\\quad\n  x^{(0)} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}.$$\n  - Convergence parameters: $\\tau_{\\text{abs}} = 10^{-12}$, $\\tau_{\\text{rel}} = 10^{-12}$, $\\gamma = 1.20$, $\\kappa = 3$, $k_{\\max} = 200$.\n\n- Test case $2$ (nearly ill-conditioned tridiagonal, tests robustness):\n  - $n = 6$,\n  - $$A = \\begin{bmatrix}\n  2 & -0.999 & 0 & 0 & 0 & 0\\\\\n  -0.999 & 2 & -0.999 & 0 & 0 & 0\\\\\n  0 & -0.999 & 2 & -0.999 & 0 & 0\\\\\n  0 & 0 & -0.999 & 2 & -0.999 & 0\\\\\n  0 & 0 & 0 & -0.999 & 2 & -0.999\\\\\n  0 & 0 & 0 & 0 & -0.999 & 2\n  \\end{bmatrix},\\quad\n  b = \\begin{bmatrix} 1\\\\ -1\\\\ 1\\\\ -1\\\\ 1\\\\ -1 \\end{bmatrix},\\quad\n  x^{(0)} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}.$$\n  - Convergence parameters: $\\tau_{\\text{abs}} = 10^{-12}$, $\\tau_{\\text{rel}} = 10^{-12}$, $\\gamma = 1.05$, $\\kappa = 4$, $k_{\\max} = 400$.\n\n- Test case $3$ (zero right-hand side, tests immediate convergence and normalization):\n  - $n = 4$,\n  - $$A = \\begin{bmatrix}\n  2 & -1 & 0 & 0\\\\\n  -1 & 2 & -1 & 0\\\\\n  0 & -1 & 2 & -1\\\\\n  0 & 0 & -1 & 2\n  \\end{bmatrix},\\quad\n  b = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix},\\quad\n  x^{(0)} = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}.$$\n  - Convergence parameters: $\\tau_{\\text{abs}} = 10^{-16}$, $\\tau_{\\text{rel}} = 10^{-16}$, $\\gamma = 1.10$, $\\kappa = 2$, $k_{\\max} = 50$.\n\nProgram output specification:\n- For each test case, compute the boolean convergence flag, the number of iterations performed until termination, the final unnormalized residual norm $R_{2}^{(\\text{final})}$, and the final normalized residual $N_{2}^{(\\text{final})}$.\n- Your program should produce a single line of output containing the results as a comma-separated list of lists in the order of the test cases, where each inner list is of the form $[\\text{converged}, \\text{iterations}, R_{2}^{(\\text{final})}, N_{2}^{(\\text{final})}]$. For example, the output format must be exactly like $[[\\text{bool},\\text{int},\\text{float},\\text{float}],[\\text{bool},\\text{int},\\text{float},\\text{float}],[\\text{bool},\\text{int},\\text{float},\\text{float}]]$ with no extra whitespace or text.\n\nAngle units and physical units are not applicable here; all quantities are dimensionless. The systems provided are consistent with discrete pressure correction equations arising in collocated finite volume formulations used in the Semi-Implicit Method for Pressure-Linked Equations (SIMPLE), but you must base your diagnostics and solver solely on the abstract linear algebraic formulation given.",
            "solution": "In computational fluid dynamics, segregated solvers, such as the SIMPLE (Semi-Implicit Method for Pressure-Linked Equations) algorithm, are commonly used to solve the discretized, incompressible Navier-Stokes equations. This approach decouples the calculation of velocity and pressure, solving for them sequentially within an iterative loop.\n\nThe starting point is the set of discretized momentum and continuity equations. For a given control volume $P$, the momentum equation can be written abstractly as:\n$$a_P \\mathbf{u}_P = \\sum_{nb} a_{nb} \\mathbf{u}_{nb} - V_P (\\nabla p)_d + \\mathbf{b}_u$$\nwhere $\\mathbf{u}_P$ is the velocity vector at the center of cell $P$, the sum is over neighboring cells $nb$, the $a$ coefficients arise from the discretization of convection and diffusion terms, $V_P$ is the cell volume, $(\\nabla p)_d$ is a discrete form of the pressure gradient, and $\\mathbf{b}_u$ contains all other source terms. The continuity equation, or conservation of mass, for an incompressible flow is:\n$$\\sum_{f} (\\mathbf{u} \\cdot \\mathbf{n}) A_f = 0$$\nwhere the sum is over the faces $f$ of the control volume, $\\mathbf{u}$ is the velocity at the face, $\\mathbf{n}$ is the face-normal vector, and $A_f$ is the face area.\n\nThe segregated solution procedure is as follows:\n1.  A pressure field, $p^*$, is guessed or taken from a previous iteration.\n2.  The momentum equation is solved to find a provisional velocity field, $\\mathbf{u}^*$, that is not yet divergence-free (i.e., does not satisfy continuity):\n    $$a_P \\mathbf{u}_P^* = \\sum_{nb} a_{nb} \\mathbf{u}_{nb}^* - V_P (\\nabla p^*)_d + \\mathbf{b}_u$$\n3.  Since $\\mathbf{u}^*$ does not satisfy the discrete continuity equation, it produces a net mass flux, or imbalance, $\\dot{m}_P^*$, for each control volume $P$:\n    $$\\dot{m}_P^* = \\sum_{f} \\rho (\\mathbf{u}^* \\cdot \\mathbf{n}) A_f \\neq 0$$\n4.  Corrections for pressure, $p'$, and velocity, $\\mathbf{u}'$, are introduced such that the final fields, $p = p^* + p'$ and $\\mathbf{u} = \\mathbf{u}^* + \\mathbf{u}'$, satisfy the governing equations, most critically the continuity equation. By subtracting the momentum equation for $\\mathbf{u}^*$ from that for $\\mathbf{u}$, and introducing approximations common to SIMPLE-like methods, a simplified relationship between the velocity correction and the pressure correction gradient is obtained. For a collocated grid as specified, this relation can be abstracted to the face level as:\n    $$\\mathbf{u}'_f \\approx -d_f (\\nabla p')_d$$\n    where $d_f$ is a coefficient derived from the momentum equation coefficients.\n5.  This velocity correction is then used to enforce the continuity constraint on the final velocity field:\n    $$\\sum_{f} \\rho (\\mathbf{u}^* \\cdot \\mathbf{n}) A_f + \\sum_{f} \\rho (\\mathbf{u}' \\cdot \\mathbf{n}) A_f = 0$$\n    Substituting the expression for $\\mathbf{u}'_f$ and the definition of $\\dot{m}_P^*$:\n    $$\\sum_{f} \\rho (-d_f (\\nabla p')_d \\cdot \\mathbf{n}) A_f = -\\dot{m}_P^*$$\n    This equation relates the pressure corrections $p'$ in neighboring cells. For a $1\\text{D}$ grid with cells $i-1$, $i$, and $i+1$, this discretizes to a form like:\n    $$C_{i,i-1} p'_{i-1} + C_{i,i} p'_i + C_{i,i+1} p'_{i+1} = -\\dot{m}_i^*$$\n    Assembling these equations for all control volumes results in a linear system of equations, $A x = b$. Here, $x$ is the vector of unknown pressure corrections, $p'$, for each cell; $b$ is the vector of negative mass imbalances, $-\\dot{m}^*$; and $A$ is the matrix of coefficients. The structure of $A$ arises from the discrete Laplacian operator, making it sparse, symmetric, and (with at least one pressure value fixed as a boundary condition) positive definite. The matrices provided in the test cases are canonical examples of this structure for a $1\\text{D}$ domain.\n\n**Solver Diagnostics and Convergence Criteria**\n\nSolving the system $A x = b$ for the pressure correction $x$ is a central part of each outer iteration of the fluid flow solver. Since this must be done repeatedly, an efficient iterative method is required. Monitoring the convergence of this inner, linear-algebraic iteration is crucial.\n\nLet $x^{(k)}$ be the approximate solution for the pressure correction vector at iteration $k$.\n-   **Residual ($r^{(k)}$)**: The residual vector is defined as $r^{(k)} = b - A x^{(k)}$. It quantifies the error in the equation for each control volume. In this physical context, $b$ is the mass imbalance from the provisional velocity field, and $A x^{(k)}$ is the mass flux correction implied by the current pressure correction guess $x^{(k)}$. Therefore, $r^{(k)}$ represents the *remaining* mass imbalance in each control volume. The goal of the solver is to drive this residual to zero.\n-   **Unnormalized Residual Norm ($R_{2}^{(k)}$)**: The Euclidean or L$2$-norm of the residual, $R_{2}^{(k)} = \\lVert r^{(k)} \\rVert_{2}$, aggregates the individual cell imbalances into a single, global, scalar measure of how well discrete continuity is being satisfied. Convergence is declared only if this absolute measure falls below a specified tolerance, $R_{2}^{(k)} \\leq \\tau_{\\text{abs}}$.\n-   **Normalized Residual ($N_{2}^{(k)}$)**: The normalized residual, $N_{2}^{(k)} = \\dfrac{\\lVert r^{(k)} \\rVert_{2}}{\\max\\left(\\lVert b \\rVert_{2}, \\varepsilon\\right)}$, provides a relative measure of convergence. It indicates the reduction in the residual relative to its initial value, $\\lVert r^{(0)} \\rVert_{2} = \\lVert b \\rVert_{2}$ (assuming $x^{(0)}=0$). This is often a more robust criterion than the absolute residual, as it is independent of the problem's scale. The small parameter $\\varepsilon > 0$ prevents division by zero if the initial right-hand side $b$ is null. Convergence requires $N_{2}^{(k)} \\leq \\tau_{\\text{rel}}$.\n-   **Monotonicity Ratio ($q^{(k)}$)**: Defined for $k \\geq 1$ as $q^{(k)} = \\dfrac{\\lVert r^{(k)} \\rVert_{2}}{\\lVert r^{(k-1)} \\rVert_{2}}$, this ratio tracks the iteration-to-iteration convergence rate. For a well-behaved iterative method, $q^{(k)} < 1$. If $q^{(k)} > 1$, the residual is growing, indicating divergence. The divergence detector, which flags nonconvergence if $q^{(k)}>\\gamma$ (with $\\gamma > 1$) for $\\kappa$ consecutive iterations, provides a practical mechanism to terminate a failing or stalled solver.\n\n**Preconditioned Conjugate Gradient (PCG) Algorithm**\n\nThe Conjugate Gradient method is an optimal iterative algorithm for solving linear systems $A x = b$ where $A$ is symmetric positive definite. Its convergence rate depends on the condition number of $A$. Preconditioning is a technique to improve the condition number by solving a modified system, $M^{-1}Ax = M^{-1}b$, where $M$ is the preconditioner matrix. $M$ should be an easily invertible approximation of $A$.\n\nFor this problem, the specified preconditioner is the Jacobi preconditioner, which is simply the diagonal of $A$, i.e., $M = \\operatorname{diag}(A)$. For such a diagonal matrix, its inverse $M^{-1}$ is trivial to compute: $(M^{-1})_{ii} = 1/A_{ii}$.\n\nThe PCG algorithm to solve $A x = b$ starting from an initial guess $x^{(0)}$ is as follows:\n\n1.  Initialize iteration counter $k=0$.\n2.  Compute the initial residual: $r^{(0)} = b - A x^{(0)}$.\n3.  Apply the preconditioner: Solve $M z^{(0)} = r^{(0)}$. For the Jacobi preconditioner, this is $z^{(0)}_i = r^{(0)}_i / A_{ii}$ for each component $i$.\n4.  Set the initial search direction: $p^{(0)} = z^{(0)}$.\n5.  Compute $\\rho_0 = (r^{(0)})^T z^{(0)}$.\n6.  Begin the iteration loop for $k = 0, 1, 2, \\dots, k_{\\max}-1$:\n    a. Compute the matrix-vector product: $\\mathbf{q}^{(k)} = A p^{(k)}$.\n    b. Compute the step size: $\\alpha_k = \\rho_k / ((p^{(k)})^T \\mathbf{q}^{(k)})$.\n    c. Update the solution: $x^{(k+1)} = x^{(k)} + \\alpha_k p^{(k)}$.\n    d. Update the residual: $r^{(k+1)} = r^{(k)} - \\alpha_k \\mathbf{q}^{(k)}$. This is more numerically stable than $r^{(k+1)} = b - A x^{(k+1)}$.\n    e. Check for convergence using $r^{(k+1)}$ against $\\tau_{\\text{abs}}$ and $\\tau_{\\text{rel}}$. If converged, terminate successfully.\n    f. Check for divergence using the monotonicity ratio. If divergence is detected, terminate with failure.\n    g. Apply the preconditioner: Solve $M z^{(k+1)} = r^{(k+1)}$. For Jacobi, $z^{(k+1)}_i = r^{(k+1)}_i / A_{ii}$.\n    h. Compute $\\rho_{k+1} = (r^{(k+1)})^T z^{(k+1)}$.\n    i. Compute the improvement factor for the search direction: $\\beta_k = \\rho_{k+1} / \\rho_k$.\n    j. Update the search direction: $p^{(k+1)} = z^{(k+1)} + \\beta_k p^{(k)}$.\n    k. Update $\\rho_k \\leftarrow \\rho_{k+1}$ for the next iteration.\n7.  If the loop completes without convergence, terminate with failure.\n\nThis algorithm, combined with the previously defined diagnostics, provides a robust and efficient method for solving the pressure correction systems given in the test suite.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a set of linear systems representative of pressure correction equations\n    using the Preconditioned Conjugate Gradient (PCG) method with a Jacobi\n    preconditioner. It computes and returns convergence diagnostics.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"A\": np.array([\n                [2.0, -1.0, 0.0, 0.0, 0.0],\n                [-1.0, 2.0, -1.0, 0.0, 0.0],\n                [0.0, -1.0, 2.0, -1.0, 0.0],\n                [0.0, 0.0, -1.0, 2.0, -1.0],\n                [0.0, 0.0, 0.0, -1.0, 2.0]\n            ]),\n            \"b\": np.array([1.0, -2.0, 3.0, -2.0, 1.0]),\n            \"x0\": np.array([0.0, 0.0, 0.0, 0.0, 0.0]),\n            \"params\": {\"abs\": 1e-12, \"rel\": 1e-12, \"gamma\": 1.20, \"kappa\": 3, \"k_max\": 200}\n        },\n        {\n            \"A\": np.array([\n                [2.0, -0.999, 0.0, 0.0, 0.0, 0.0],\n                [-0.999, 2.0, -0.999, 0.0, 0.0, 0.0],\n                [0.0, -0.999, 2.0, -0.999, 0.0, 0.0],\n                [0.0, 0.0, -0.999, 2.0, -0.999, 0.0],\n                [0.0, 0.0, 0.0, -0.999, 2.0, -0.999],\n                [0.0, 0.0, 0.0, 0.0, -0.999, 2.0]\n            ]),\n            \"b\": np.array([1.0, -1.0, 1.0, -1.0, 1.0, -1.0]),\n            \"x0\": np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),\n            \"params\": {\"abs\": 1e-12, \"rel\": 1e-12, \"gamma\": 1.05, \"kappa\": 4, \"k_max\": 400}\n        },\n        {\n            \"A\": np.array([\n                [2.0, -1.0, 0.0, 0.0],\n                [-1.0, 2.0, -1.0, 0.0],\n                [0.0, -1.0, 2.0, -1.0],\n                [0.0, 0.0, -1.0, 2.0]\n            ]),\n            \"b\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"x0\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"params\": {\"abs\": 1e-16, \"rel\": 1e-16, \"gamma\": 1.10, \"kappa\": 2, \"k_max\": 50}\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        A = case[\"A\"]\n        b = case[\"b\"]\n        x = case[\"x0\"].copy()\n        params = case[\"params\"]\n        \n        tau_abs = params[\"abs\"]\n        tau_rel = params[\"rel\"]\n        gamma = params[\"gamma\"]\n        kappa = params[\"kappa\"]\n        k_max = params[\"k_max\"]\n        \n        # Preconditioner M is the diagonal of A\n        M_inv_diag = 1.0 / np.diag(A)\n\n        # Iteration k=0 setup\n        r = b - A @ x\n        r_norm_unnormalized = np.linalg.norm(r)\n        \n        b_norm = np.linalg.norm(b)\n        normalization_factor = max(b_norm, 1e-30)\n        r_norm_normalized = r_norm_unnormalized / normalization_factor\n\n        # Check for convergence at iteration 0\n        if r_norm_unnormalized = tau_abs and r_norm_normalized = tau_rel:\n            results.append([True, 0, r_norm_unnormalized, r_norm_normalized])\n            continue\n        \n        # PCG initialization\n        z = r * M_inv_diag\n        p = z.copy()\n        rho_old = r @ z\n        \n        divergence_counter = 0\n        prev_r_norm = r_norm_unnormalized\n        converged = False\n        \n        # Iteration loop\n        for k_iter in range(1, k_max + 1):\n            Ap = A @ p\n            alpha = rho_old / (p @ Ap)\n            \n            x += alpha * p\n            r -= alpha * Ap\n            \n            # --- Diagnostics ---\n            r_norm_unnormalized = np.linalg.norm(r)\n            r_norm_normalized = r_norm_unnormalized / normalization_factor\n            \n            # Divergence Check\n            monotonicity_ratio = r_norm_unnormalized / prev_r_norm if prev_r_norm > 0 else 0.0\n            if monotonicity_ratio > gamma:\n                divergence_counter += 1\n            else:\n                divergence_counter = 0\n            \n            if divergence_counter >= kappa:\n                converged = False\n                break\n                \n            prev_r_norm = r_norm_unnormalized\n            \n            # Convergence Check\n            if r_norm_unnormalized = tau_abs and r_norm_normalized = tau_rel:\n                converged = True\n                break\n\n            # --- PCG update ---\n            z = r * M_inv_diag\n            rho_new = r @ z\n            \n            # Failsafe for breakdown\n            if abs(rho_old)  1e-40:\n                converged = (r_norm_unnormalized = tau_abs and r_norm_normalized = tau_rel)\n                break\n\n            beta = rho_new / rho_old\n            p = z + beta * p\n            rho_old = rho_new\n        else: # This else belongs to the for loop, executes if loop finishes without break\n            converged = False\n            k_iter = k_max\n\n        results.append([converged, k_iter, r_norm_unnormalized, r_norm_normalized])\n\n    # Format the final output string exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}