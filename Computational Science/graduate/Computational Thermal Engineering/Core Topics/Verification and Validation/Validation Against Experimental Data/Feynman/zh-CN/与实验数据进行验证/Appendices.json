{
    "hands_on_practices": [
        {
            "introduction": "模型验证的第一步通常是使用实验数据来校准模型中的未知参数。然而，一个在训练数据上表现完美的模型，在新数据上可能表现不佳，这种现象被称为过拟合。本练习将指导您使用 K-折交叉验证这一强大的统计技术，来校准一个基于物理学的热传导模型，并获得对其预测性能的更可靠估计。通过这种方式，我们可以更准确地评估模型在面对未见数据时的泛化能力 。",
            "id": "4002175",
            "problem": "给定一个稳态一维热传导校准问题，其物理模型源于能量守恒和 Fourier 热传导定律。考虑一个厚度为 $L$ 的均匀平板，其两侧承受温差 $\\Delta T = T_{\\mathrm{hot}} - T_{\\mathrm{cold}}$。在内部热生成可忽略的稳态条件下，空间温度梯度近似均匀，可测量的表面法向热通量 $q''$ 服从一个线性本构关系，其中包含一个未知的有效热导率参数 $k_{\\mathrm{eff}}$。定义回归量 $x = \\Delta T / L$。与基本原理一致的单参数模型为 $q'' = k_{\\mathrm{eff}} \\, x$。在实验中，您观察到成对的 $(x_i, y_i)$，其中 $y_i$ 表示带有加性测量噪声的测量热通量。\n\n假设加性测量噪声为零均值的高斯噪声。在同方差情况下，噪声方差在所有样本中是恒定的；在异方差情况下，每个样本 $i$ 都有一个已知的标准差 $\\sigma_i$，且噪声方差为 $\\sigma_i^2$。在训练集上校准 $k_{\\mathrm{eff}}$ 时，对于同方差情况，应通过最小化训练集的残差平方和来进行；对于异方差情况，则通过最小化加权残差平方和来进行，其中权重与 $1/\\sigma_i^2$ 成正比。\n\n您的任务是实现 $K$ 折交叉验证，以使用上述物理-统计模型估计 $q''$ 的预期预测误差。通过将样本索引 $i$ 分配到折 $(i \\bmod K)$（其中 $i = 0, 1, \\dots, N-1$），将 $N$ 个样本划分为 $K$ 个折。对于每个折 $f \\in \\{0, 1, \\dots, K-1\\}$，仅使用折索引不等于 $f$ 的训练样本来拟合 $k_{\\mathrm{eff}}$，然后对折 $f$ 中的验证样本预测 $q''$，计算这些验证样本的预测误差平方，并汇总所有折的验证误差平方。此处的预期预测误差定义为这 $N$ 个样本的预测误差平方的均值，最终报告的分数是均方根误差 (RMSE)，其物理单位与 $q''$ 相同。最终的 RMSE 值以 $\\mathrm{W}/\\mathrm{m}^2$ 为单位表示，并四舍五入到三位小数。\n\n使用以下与所述物理原理一致的数据集。平板厚度为 $L = 0.01 \\ \\mathrm{m}$。测量的温差 $\\Delta T$ 以 $\\mathrm{K}$ 为单位，测量的热通量 $y_i$ 以 $\\mathrm{W}/\\mathrm{m}^2$ 为单位。共有 $N = 12$ 个数据点，按所示顺序索引。对于每个 $i$，计算 $x_i = \\Delta T_i / L$，单位为 $\\mathrm{K}/\\mathrm{m}$。\n\n- $\\Delta T$ 列表 (单位 $\\mathrm{K}$): $[5, 8, 10, 12, 15, 18, 20, 22, 25, 28, 30, 35]$。\n- $y$ 列表 (单位 $\\mathrm{W}/\\mathrm{m}^2$): $[90500, 143200, 181300, 214100, 271800, 322000, 359500, 397700, 451200, 503100, 542800, 627400]$。\n\n对于异方差加权（仅在指定时使用），使用以下每个样本的标准差，单位为 $\\mathrm{W}/\\mathrm{m}^2$：$\\sigma$ 列表 $[4000, 5000, 3500, 4500, 3000, 6000, 3200, 4800, 2800, 5200, 3000, 7000]$。\n\n按照定义实现 $K$ 折交叉验证程序（通过索引模 $K$ 进行折分配）。在每个训练集上通过最小化适当的训练目标来校准 $k_{\\mathrm{eff}}$（如果未提供 $\\sigma_i$，则为未加权的残差平方和；如果提供了 $\\sigma_i$，则为加权残差平方和，权重为 $1/\\sigma_i^2$）。在每个验证集上，计算未加权的预测误差平方 $(y_i - \\widehat{y}_i)^2$，并汇总所有折的结果以生成总体 RMSE。\n\n测试套件：\n- 情况 1 (正常路径)：$K = 4$，同方差（无权重）。\n- 情况 2 (边界：留一法交叉验证)：$K = 12$，同方差（无权重）。\n- 情况 3 (边界：最少折数)：$K = 2$，同方差（无权重）。\n- 情况 4 (重要边缘情况：异方差训练)：$K = 3$，使用提供的 $\\sigma_i$ 进行加权训练，但仍报告验证预测的未加权 RMSE。\n\n您的程序必须输出一行，其中包含四个 RMSE 值的列表，按上述情况的顺序排列，每个值以 $\\mathrm{W}/\\mathrm{m}^2$ 为单位，并四舍五入到三位小数。要求的最终输出格式为一行，包含一个用方括号括起来的逗号分隔列表，例如，`\"[r_1,r_2,r_3,r_4]\"`，其中每个 $r_j$ 是一个小数点后恰好有三位数字的浮点数，并且根据构造，单位默认为 $\\mathrm{W}/\\mathrm{m}^2$。",
            "solution": "用户提供了一个问题，要求实现 K 折交叉验证，以估计一个基于物理的一维热传导模型的预测误差。此任务将热工学原理与标准统计验证方法相结合。\n\n首先，我们将物理模型和统计模型形式化。问题陈述描述了通过厚度为 $L$ 的均匀平板的稳态一维热传导。其主导物理原理是 Fourier 定律，该定律指出热通量 $q''$ 与温度梯度的负值成正比。对于整个平板上的均匀热梯度，可表示为：\n$$\nq'' = k \\left( \\frac{\\Delta T}{L} \\right)\n$$\n其中 $k$ 是材料的热导率，$\\Delta T$ 是平板两侧的温差。该方程提供了一个线性模型。我们定义了一个回归变量 $x = \\Delta T / L$，即温度梯度的大小。该模型简化为一个通过原点的线性关系，其中单个参数 $k_{\\mathrm{eff}}$ 表示有效热导率：\n$$\nq'' = k_{\\mathrm{eff}} x\n$$\n实验数据集由 $N$ 对观测值 $(x_i, y_i)$ 组成，其中 $y_i$ 是对应于给定热梯度 $x_i$ 的测量热通量。统计模型假设测量的通量 $y_i$ 是真实通量加上一个加性的、零均值的高斯噪声项 $\\epsilon_i$：\n$$\ny_i = k_{\\mathrm{eff}} x_i + \\epsilon_i\n$$\n我们的目标是从训练数据集中估计 $k_{\\mathrm{eff}}$。采用最小二乘法来找到使基于残差平方和的目标函数最小化的值 $\\hat{k}_{\\mathrm{eff}}$。该函数的形式取决于关于噪声方差的假设。\n\n在**同方差情况**下，假定所有测量的噪声方差 $\\mathrm{Var}(\\epsilon_i) = \\sigma^2$ 都是恒定的。我们最小化普通残差平方和 (SSR)：\n$$\nS(k_{\\mathrm{eff}}) = \\sum_{i \\in \\text{train}} (y_i - k_{\\mathrm{eff}} x_i)^2\n$$\n为了找到最小值，我们将 $S$ 对 $k_{\\mathrm{eff}}$ 的导数设为零：\n$$\n\\frac{dS}{dk_{\\mathrm{eff}}} = \\sum_{i \\in \\text{train}} 2(y_i - k_{\\mathrm{eff}} x_i)(-x_i) = -2 \\left( \\sum_{i \\in \\text{train}} x_i y_i - k_{\\mathrm{eff}} \\sum_{i \\in \\text{train}} x_i^2 \\right) = 0\n$$\n求解 $k_{\\mathrm{eff}}$ 即可得到普通最小二乘 (OLS) 估计量：\n$$\n\\hat{k}_{\\mathrm{eff, OLS}} = \\frac{\\sum_{i \\in \\text{train}} x_i y_i}{\\sum_{i \\in \\text{train}} x_i^2}\n$$\n\n在**异方差情况**下，每个测量的噪声方差 $\\mathrm{Var}(\\epsilon_i) = \\sigma_i^2$ 是唯一的且已知的。为了考虑这一点，我们最小化加权残差平方和 (WSSR)，其中权重 $w_i=1/\\sigma_i^2$ 会给予噪声较大的数据点较小的影响。\n$$\nS_w(k_{\\mathrm{eff}}) = \\sum_{i \\in \\text{train}} w_i (y_i - k_{\\mathrm{eff}} x_i)^2 = \\sum_{i \\in \\text{train}} \\frac{1}{\\sigma_i^2} (y_i - k_{\\mathrm{eff}} x_i)^2\n$$\n对 $k_{\\mathrm{eff}}$ 求导并将结果设为零，得到加权最小二乘 (WLS) 估计量：\n$$\n\\hat{k}_{\\mathrm{eff, WLS}} = \\frac{\\sum_{i \\in \\text{train}} w_i x_i y_i}{\\sum_{i \\in \\text{train}} w_i x_i^2}\n$$\n\n有了这些估计量，我们就可以进行 $K$ 折交叉验证算法了。该技术提供了模型泛化误差的估计。$N=12$ 个样本的数据集被确定性地划分为 $K$ 个折，其中样本索引 $i$ 被分配到折 $j = i \\pmod{K}$。算法执行如下：\n1.  对于从 $0$ 到 $K-1$ 的每个折 $f$，将折 $f$ 中的样本指定为验证集，所有其他样本构成训练集。\n2.  仅使用训练集数据，按规定应用 OLS 或 WLS 公式来估计参数 $\\hat{k}_{\\mathrm{eff}}$。\n3.  使用拟合好的模型预测验证集中样本的结果：对于验证集中的每个 $j$，$\\hat{y}_j = \\hat{k}_{\\mathrm{eff}} x_j$。\n4.  为每个验证样本计算未加权的预测误差平方 $e_j^2 = (y_j - \\hat{y}_j)^2$。至关重要的是，在所有情况下，验证误差都是未加权的，因为目标是在绝对尺度上评估模型的预测准确性。\n5.  遍历所有 $K$ 个折后，已为整个数据集中的每个样本 $i$ 计算了预测误差平方 $e_i^2$。\n6.  最终的性能指标是均方根误差 (RMSE)。它通过首先计算所有 $N$ 个预测的均方误差 (MSE)，然后取其平方根来计算：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} e_i^2}\n$$\nRMSE 与被预测的量 ($y$) 具有相同的物理单位，在本问题中为 $\\mathrm{W}/\\mathrm{m}^2$。\n\n该实现将针对四个不同的测试用例执行此算法，这些用例的折数 $K$ 和训练方法（同方差与异方差）各不相同。对于每种情况，都会计算一个 RMSE 值并四舍五入到三位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements K-fold cross-validation for a 1D heat conduction model.\n    \"\"\"\n    # --- Data Preparation ---\n    # Define physical constants and dataset dimensions.\n    L = 0.01  # Slab thickness in meters\n    N = 12    # Number of samples\n\n    # Define the raw experimental data as NumPy arrays.\n    delta_T_arr = np.array([5, 8, 10, 12, 15, 18, 20, 22, 25, 28, 30, 35], dtype=float)  # in K\n    y_arr = np.array([90500, 143200, 181300, 214100, 271800, 322000, 359500, 397700, 451200, 503100, 542800, 627400], dtype=float)  # in W/m^2\n    sigma_arr = np.array([4000, 5000, 3500, 4500, 3000, 6000, 3200, 4800, 2800, 5200, 3000, 7000], dtype=float)  # in W/m^2\n\n    # Calculate the regressor x = delta_T / L\n    x_arr = delta_T_arr / L\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (K, is_heteroscedastic_training)\n    test_cases = [\n        (4, False),  # Case 1: K=4, homoscedastic\n        (12, False), # Case 2: K=12, homoscedastic (LOOCV)\n        (2, False),  # Case 3: K=2, homoscedastic\n        (3, True)    # Case 4: K=3, heteroscedastic training\n    ]\n\n    results = []\n\n    # --- K-Fold Cross-Validation Loop ---\n    # Iterate through each test case.\n    for K, is_heteroscedastic in test_cases:\n        # Array to store the squared error for each of the N samples.\n        squared_errors = np.zeros(N)\n\n        # Loop over each fold f, from 0 to K-1.\n        for f in range(K):\n            # 1. Partition data into training and validation sets based on index.\n            # The rule is: sample i is in fold (i mod K).\n            val_indices = [i for i in range(N) if i % K == f]\n            train_indices = [i for i in range(N) if i % K != f]\n\n            x_train = x_arr[train_indices]\n            y_train = y_arr[train_indices]\n            \n            x_val = x_arr[val_indices]\n            y_val = y_arr[val_indices]\n\n            # 2. Train model: estimate k_eff on the training set.\n            if not is_heteroscedastic:\n                # Homoscedastic case: Ordinary Least Squares (OLS)\n                # k_eff = sum(x_i * y_i) / sum(x_i^2)\n                numerator = np.sum(x_train * y_train)\n                denominator = np.sum(x_train**2)\n                k_eff = numerator / denominator\n            else:\n                # Heteroscedastic case: Weighted Least Squares (WLS)\n                # k_eff = sum(w_i * x_i * y_i) / sum(w_i * x_i^2) where w_i = 1/sigma_i^2\n                sigma_train = sigma_arr[train_indices]\n                weights = 1.0 / sigma_train**2\n                numerator = np.sum(weights * x_train * y_train)\n                denominator = np.sum(weights * x_train**2)\n                k_eff = numerator / denominator\n\n            # 3. Predict on the validation set.\n            y_pred = k_eff * x_val\n            \n            # 4. Compute unweighted squared errors and store them.\n            # The squared errors are stored in the original indices' positions.\n            squared_errors[val_indices] = (y_val - y_pred)**2\n\n        # 5. Calculate the final Root Mean Square Error (RMSE) for this K.\n        # The RMSE is the square root of the mean of all N squared errors.\n        mean_squared_error = np.mean(squared_errors)\n        root_mean_squared_error = np.sqrt(mean_squared_error)\n        \n        # Format the result to three decimal places and add to the list.\n        results.append(f\"{root_mean_squared_error:.3f}\")\n\n    # Final print statement in the exact required format: [r1,r2,r3,r4]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "用于验证的实验数据本身并非总是物理现实的完美再现。测量传感器，尤其是用于动态过程的传感器，其固有的响应时间会扭曲或延迟真实信号。本练习将引导您处理一个核心的数据预处理任务：通过反卷积技术，从一个一阶传感器记录的含噪输出信号中，重建出更接近真实的原始温度信号。掌握这项技能对于确保验证所用的实验数据尽可能准确地反映物理过程至关重要 。",
            "id": "4002173",
            "problem": "给定一个用于计算热工学中的温度传感器的测量模型。该传感器被建模为一个线性时不变系统，其传递函数为 $G(s)=\\frac{1}{1+\\tau s}$，其中 $\\tau$ 是传感器的时间常数。真实温度输入 $x(t)$ 和测量温度输出 $y(t)$ 通过一阶微分方程 $\\tau \\frac{dy}{dt} + y = x$ 相关联。测量信号用于验证计算预测，但由于传感器的动态特性，需要进行反卷积以获得近似 $x(t)$ 的校正温度信号。\n\n从线性时不变系统、卷积积分和一阶动力学模型的基本定义出发，推导一个能从 $y(t)$ 估计 $x(t)$ 且对测量噪声具有鲁棒性的、有理论依据的反卷积过程。您的推导应从微分方程 $\\tau \\frac{dy}{dt} + y = x$ 开始，并推导至适用于采样信号的离散时间公式。您必须在每个长度为 $\\Delta t$ 的采样区间内输入为零阶保持的假设下，证明离散时间模型的合理性，推导其递推形式和相应的离散时间频率响应 $G_d(e^{j\\Omega})$。然后，您必须使用最小范数（Tikhonov）准则，在频域中推导出一个稳定的正则化逆运算，并认识到朴素的逆运算会放大高频噪声。\n\n将您的反卷积算法实现为一个完整、可运行的程序，该程序：\n- 在采样间隔为 $\\Delta t$ 的离散时间网格上构建真实温度信号 $x[n]$。\n- 通过模拟在零阶保持假设下从连续时间模型推导出的离散时间动态特性来生成测量信号 $y[n]$：$y[n]$ 通过参数 $\\tau$ 和 $\\Delta t$ 依赖于 $y[n-1]$ 和 $x[n]$。\n- 向 $y[n]$ 添加具有指定标准差的加性高斯白噪声，以模拟实验条件。\n- 使用离散时间频率响应 $G_d(e^{j\\Omega})$ 执行正则化频域反卷积，以获得校正后的估计值 $\\hat{x}[n]$。\n- 在整个时间记录上计算 $\\hat{x}[n]$ 和 $x[n]$ 之间的平均绝对误差。\n\n必须明确遵守物理单位：时间以秒（$\\mathrm{s}$）为单位，温度以开尔文（$\\mathrm{K}$）为单位。平均绝对误差必须以开尔文（$\\mathrm{K}$）为单位，作为浮点数报告。算法中必须使用快速傅里叶变换（FFT）。\n\n测试套件和规格：\n实现以下四个覆盖典型、边界和边缘条件的测试用例。对于每个用例，使用指定的参数和信号定义。在所有用例中，设置 $y[0]=x[0]$ 以避免初始的人为瞬态。\n\n- 用例 1（典型路径）：\n  - 采样：$N=4096$ 个样本，$\\Delta t = 0.01\\,\\mathrm{s}$。\n  - 传感器：$\\tau = 1.0\\,\\mathrm{s}$。\n  - 真实信号：在 $t_s=10\\,\\mathrm{s}$ 时从 $300\\,\\mathrm{K}$ 阶跃到 $310\\,\\mathrm{K}$，即当 $t<10\\,\\mathrm{s}$ 时 $x(t)=300\\,\\mathrm{K}$，当 $t\\ge 10\\,\\mathrm{s}$ 时 $x(t)=310\\,\\mathrm{K}$。\n  - 噪声：加性高斯白噪声，标准差 $\\sigma=0.05\\,\\mathrm{K}$，随机种子为 $1$。\n  - 正则化参数：$\\lambda = 10^{-4}$。\n\n- 用例 2（边界：零噪声）：\n  - 采样：$N=4096$，$\\Delta t = 0.01\\,\\mathrm{s}$。\n  - 传感器：$\\tau = 0.5\\,\\mathrm{s}$。\n  - 真实信号：正弦波 $x(t)=300\\,\\mathrm{K} + 2\\,\\mathrm{K} \\sin\\left(2\\pi f t\\right)$，其中 $f=0.2\\,\\mathrm{Hz}$。\n  - 噪声：$\\sigma=0\\,\\mathrm{K}$，随机种子为 $2$（种子未使用，但为保持一致性而指定）。\n  - 正则化参数：$\\lambda = 10^{-8}$。\n\n- 用例 3（边缘：大时间常数）：\n  - 采样：$N=2000$，$\\Delta t = 0.05\\,\\mathrm{s}$。\n  - 传感器：$\\tau = 5.0\\,\\mathrm{s}$。\n  - 真实信号：在整个持续时间 $T=N\\Delta t=100\\,\\mathrm{s}$ 内从 $300\\,\\mathrm{K}$ 线性增加到 $305\\,\\mathrm{K}$ 的斜坡信号，即 $x(t) = 300\\,\\mathrm{K} + 0.05\\,\\mathrm{K/s}\\cdot t$。\n  - 噪声：$\\sigma=0.1\\,\\mathrm{K}$，随机种子为 $3$。\n  - 正则化参数：$\\lambda = 10^{-3}$。\n\n- 用例 4（边缘：高噪声和混合动态）：\n  - 采样：$N=3000$，$\\Delta t = 0.02\\,\\mathrm{s}$。\n  - 传感器：$\\tau = 2.0\\,\\mathrm{s}$。\n  - 真实信号：复合信号 $x(t)=300\\,\\mathrm{K} + 1\\,\\mathrm{K} \\sin\\left(2\\pi f t\\right) + \\Delta T\\cdot u(t-t_s)$，其中 $f=0.1\\,\\mathrm{Hz}$，$\\Delta T=5\\,\\mathrm{K}$，$t_s=20\\,\\mathrm{s}$，且 $u(\\cdot)$ 为单位阶跃函数。\n  - 噪声：$\\sigma=0.2\\,\\mathrm{K}$，随机种子为 $4$。\n  - 正则化参数：$\\lambda = 5\\times 10^{-3}$。\n\n数值实现要求：\n- 使用在零阶保持假设下推导的离散时间模型，其中 $a=\\exp(-\\Delta t/\\tau)$ 且递推关系为 $y[n]=a\\,y[n-1]+(1-a)\\,x[n]$。\n- 使用与递推模型相对应的离散时间频率响应 $G_d(e^{j\\Omega})$。推导并使用在与 FFT 一致的离散角频率网格 $\\Omega_k=\\frac{2\\pi k}{N}$ 上计算的 $G_d(e^{j\\Omega})$。\n- 在频域中实现从最小范数准则得出的正则化逆滤波器，并通过逆 FFT 计算时域中的 $\\hat{x}[n]$。\n- 为每个用例计算平均绝对误差 $\\mathrm{MAE} = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left|\\hat{x}[n]-x[n]\\right|$。以 $\\mathrm{K}$ 为单位表示 $\\mathrm{MAE}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的平均绝对误差，单位为开尔文，四舍五入到六位小数，形式为用方括号括起来的逗号分隔列表（例如，“[$\\text{mae}_1$,$\\text{mae}_2$,$\\text{mae}_3$,$\\text{mae}_4$]”）。打印出的数字本身必须是没有单位的普通浮点数，但它们代表开尔文值。",
            "solution": "该问题要求推导并实现一种正则化反卷积算法，用于从传感器带噪声的、经动态滤波的输出中估计真实的温度输入。传感器被建模为一阶线性时不变（LTI）系统。解决方案分三个阶段进行：首先，推导离散时间系统模型及其频率响应；其次，基于最小范数准则推导正则化逆滤波器；第三，实现完整的算法。\n\n### 1. 离散时间系统模型与频率响应\n\n传感器动态由以下一阶常微分方程描述：\n$$ \\tau \\frac{dy(t)}{dt} + y(t) = x(t) $$\n其中 $x(t)$ 是真实温度，$y(t)$ 是测量温度，$\\tau$ 是传感器的时间常数。这对应于连续时间传递函数 $G(s) = \\frac{1}{1+\\tau s}$。\n\n为了用数字计算机处理，信号以恒定间隔 $\\Delta t$ 进行采样，得到离散序列 $x[n] = x(n\\Delta t)$ 和 $y[n] = y(n\\Delta t)$。问题提供了一个特定的离散时间递推关系来对系统行为进行建模：\n$$ y[n] = a \\cdot y[n-1] + (1-a) \\cdot x[n] $$\n其中系数 $a$ 定义为 $a = \\exp(-\\Delta t/\\tau)$。该形式被指定为用于模拟传感器输出和反卷积过程的模型。\n\n为了在频域中执行反卷积，我们必须首先确定该系统的离散时间频率响应 $G_d(e^{j\\Omega})$。我们对递推关系应用离散时间傅里叶变换（DTFT）。设 $X(e^{j\\Omega})$ 和 $Y(e^{j\\Omega})$ 分别是 $x[n]$ 和 $y[n]$ 的 DTFT。利用 DTFT 的时移性质 $\\mathcal{F}\\{f[n-k]\\} = e^{-j\\Omega k} F(e^{j\\Omega})$，变换后的方程为：\n$$ Y(e^{j\\Omega}) = a e^{-j\\Omega} Y(e^{j\\Omega}) + (1-a) X(e^{j\\Omega}) $$\n离散时间传递函数 $G_d(e^{j\\Omega}) = Y(e^{j\\Omega})/X(e^{j\\Omega})$ 可以通过重新整理各项得到：\n$$ Y(e^{j\\Omega}) (1 - a e^{-j\\Omega}) = (1-a) X(e^{j\\Omega}) $$\n$$ G_d(e^{j\\Omega}) = \\frac{1-a}{1 - a e^{-j\\Omega}} $$\n这就是离散时间正向模型的频率响应。该系统的直流增益为 $G_d(e^{j0}) = \\frac{1-a}{1-a} = 1$，这与连续时间模型一致，在连续时间模型中，恒定输入 $x(t)=X_0$ 会产生稳态输出 $y(t)=X_0$。\n\n### 2. 正则化反卷积\n\n反卷积问题是一个逆问题：给定输出 $y[n]$，我们希望找到输入 $x[n]$。在频域中，这对应于从 $Y_k$ 中找到 $X_k$，其中索引 $k$ 表示离散傅里叶变换（DFT）的第 $k$ 个频率仓。一种朴素的逆运算是 $\\hat{X}_k = Y_k / G_{d,k}$，其中 $G_{d,k} = G_d(e^{j\\Omega_k})$ 且 $\\Omega_k = 2\\pi k/N$。\n\n然而，测量噪声使这成为一个严重的病态问题。测量到的信号是 $y_{noisy}[n] = y[n] + w[n]$，其中 $w[n]$ 是噪声。在频域中，$Y_{noisy,k} = G_{d,k} X_k + W_k$。$G_{d,k}$ 的幅值在高频处减小，因此在进行朴素逆运算时，噪声项 $W_k/G_{d,k}$ 会被大大放大，从而破坏解。\n\nTikhonov 正则化通过找到一个估计值 $\\hat{x}$ 来最小化一个结合了数据保真项和正则化项的成本函数，从而提供了一个鲁棒的解：\n$$ J(\\hat{x}) = \\sum_{n=0}^{N-1} |(g_d * \\hat{x})[n] - y_{noisy}[n]|^2 + \\lambda \\sum_{n=0}^{N-1} |\\hat{x}[n]|^2 $$\n这里，$g_d[n]$ 是系统的脉冲响应，* 表示卷积，$\\lambda > 0$ 是正则化参数，它惩罚具有大范数的解，从而有效抑制噪声。\n\n使用 Parseval 定理，我们可以在频域中表示该成本函数：\n$$ J(\\hat{X}) = \\sum_{k=0}^{N-1} |G_{d,k} \\hat{X}_k - Y_{noisy,k}|^2 + \\lambda \\sum_{k=0}^{N-1} |\\hat{X}_k|^2 $$\n对于每个频率分量 $k$，可以逐项最小化这个和：\n$$ J_k(\\hat{X}_k) = |G_{d,k} \\hat{X}_k - Y_{noisy,k}|^2 + \\lambda |\\hat{X}_k|^2 $$\n为了找到最小值，我们对 $\\hat{X}_k^*$ 求复导数并将其设为零：\n$$ \\frac{\\partial J_k}{\\partial \\hat{X}_k^*} = G_{d,k}^* (G_{d,k} \\hat{X}_k - Y_{noisy,k}) + \\lambda \\hat{X}_k = 0 $$\n求解最优估计 $\\hat{X}_k$：\n$$ (\\lvert G_{d,k} \\rvert^2 + \\lambda) \\hat{X}_k = G_{d,k}^* Y_{noisy,k} $$\n$$ \\hat{X}_k = \\left( \\frac{G_{d,k}^*}{\\lvert G_{d,k} \\rvert^2 + \\lambda} \\right) Y_{noisy,k} $$\n这个表达式定义了正则化逆滤波器。分母中的项 $\\lambda$ 防止了除以小数，从而稳定了逆运算。\n\n### 3. 算法流程\n\n获取校正后温度信号 $\\hat{x}[n]$ 并评估其准确性的完整流程如下：\n1.  **信号生成**：对于给定的测试用例，根据其解析定义和采样间隔 $\\Delta t$，生成长度为 $N$ 的离散真实温度信号 $x[n]$。\n2.  **正向模拟**：应用递推关系 $y[n] = a y[n-1] + (1-a) x[n]$ 模拟测量信号 $y[n]$，其中 $a = \\exp(-\\Delta t/\\tau)$ 且初始条件为 $y[0]=x[0]$。\n3.  **噪声添加**：通过添加一系列均值为 $0$、标准差为 $\\sigma$ 的独立同分布高斯随机数，创建带噪声的测量信号 $y_{noisy}[n]$。\n4.  **频域变换**：计算带噪信号的 DFT，$Y_{noisy} = \\text{FFT}(y_{noisy}[n])$。\n5.  **频率响应构建**：使用公式 $G_{d,k} = \\frac{1-a}{1 - a \\exp(-j\\Omega_k)}$，构建在 DFT 频率 $\\Omega_k = 2\\pi k/N$（其中 $k = 0, \\ldots, N-1$）上计算的离散时间频率响应向量 $G_d$。\n6.  **正则化逆运算**：应用正则化逆滤波器计算估计的真实信号的 DFT：$\\hat{X}_k = \\left( \\frac{G_{d,k}^*}{\\lvert G_{d,k} \\rvert^2 + \\lambda} \\right) Y_{noisy,k}$。\n7.  **时域重建**：应用逆 DFT 获得估计的时域信号：$\\hat{x}[n] = \\text{IFFT}(\\hat{X})$。结果取 IFFT 复数输出的实部。\n8.  **误差计算**：计算估计信号和真实信号之间的平均绝对误差（MAE）：$\\mathrm{MAE} = \\frac{1}{N}\\sum_{n=0}^{N-1} |\\hat{x}[n]-x[n]|$。\n\n对四个指定的测试用例均实施此流程，以评估正则化反卷积方法在不同条件下的性能。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_deconvolution_case(N, dt, tau, x_signal_func, sigma, seed, lambda_reg):\n    \"\"\"\n    Runs a single test case for the regularized deconvolution problem.\n\n    Args:\n        N (int): Number of samples.\n        dt (float): Sampling interval in seconds.\n        tau (float): Sensor time constant in seconds.\n        x_signal_func (callable): Function that takes a time array and returns the true signal x[n].\n        sigma (float): Standard deviation of the additive white Gaussian noise in Kelvin.\n        seed (int): Random seed for noise generation.\n        lambda_reg (float): Regularization parameter.\n\n    Returns:\n        float: The mean absolute error between the reconstructed signal and the true signal.\n    \"\"\"\n    # 1. Signal Generation\n    t = np.arange(N) * dt\n    x = x_signal_func(t, N, dt)\n\n    # 2. Forward Simulation\n    a = np.exp(-dt / tau)\n    y = np.zeros(N)\n    y[0] = x[0]  # Initial condition\n    for n in range(1, N):\n        y[n] = a * y[n-1] + (1 - a) * x[n]\n\n    # 3. Noise Addition\n    rng = np.random.default_rng(seed)\n    noise = rng.normal(0, sigma, N)\n    y_noisy = y + noise\n\n    # 4. Frequency Domain Transformation\n    Y_noisy_fft = np.fft.fft(y_noisy)\n\n    # 5. Frequency Response Construction\n    # Discrete angular frequencies Omega_k = 2*pi*k/N for k=0,...,N-1\n    # np.fft.fftfreq(N) gives k/N\n    Omega = 2 * np.pi * np.fft.fftfreq(N)\n    Gd = (1 - a) / (1 - a * np.exp(-1j * Omega))\n\n    # 6. Regularized Inversion\n    Gd_conj = np.conj(Gd)\n    Gd_mag_sq = np.abs(Gd)**2\n    regularized_inverse_filter = Gd_conj / (Gd_mag_sq + lambda_reg)\n    X_hat_fft = regularized_inverse_filter * Y_noisy_fft\n\n    # 7. Time Domain Reconstruction\n    x_hat = np.fft.ifft(X_hat_fft)\n    x_hat = np.real(x_hat)  # Result should be real, take real part to discard numerical error\n\n    # 8. Error Calculation\n    mae = np.mean(np.abs(x_hat - x))\n    return mae\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the deconvolution simulations.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"N\": 4096, \"dt\": 0.01, \"tau\": 1.0,\n            \"x_signal_func\": lambda t, N, dt: 300.0 + 10.0 * (t >= 10.0),\n            \"sigma\": 0.05, \"seed\": 1, \"lambda_reg\": 1e-4\n        },\n        # Case 2 (boundary: zero noise)\n        {\n            \"N\": 4096, \"dt\": 0.01, \"tau\": 0.5,\n            \"x_signal_func\": lambda t, N, dt: 300.0 + 2.0 * np.sin(2 * np.pi * 0.2 * t),\n            \"sigma\": 0.0, \"seed\": 2, \"lambda_reg\": 1e-8\n        },\n        # Case 3 (edge: large time constant)\n        {\n            \"N\": 2000, \"dt\": 0.05, \"tau\": 5.0,\n            \"x_signal_func\": lambda t, N, dt: 300.0 + 0.05 * t,\n            \"sigma\": 0.1, \"seed\": 3, \"lambda_reg\": 1e-3\n        },\n        # Case 4 (edge: high noise and mixed dynamics)\n        {\n            \"N\": 3000, \"dt\": 0.02, \"tau\": 2.0,\n            \"x_signal_func\": lambda t, N, dt: 300.0 + 1.0 * np.sin(2 * np.pi * 0.1 * t) + 5.0 * (t >= 20.0),\n            \"sigma\": 0.2, \"seed\": 4, \"lambda_reg\": 5e-3\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        mae = run_deconvolution_case(\n            case[\"N\"], case[\"dt\"], case[\"tau\"],\n            case[\"x_signal_func\"], case[\"sigma\"],\n            case[\"seed\"], case[\"lambda_reg\"]\n        )\n        results.append(round(mae, 6))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "验证的最终环节是将模型的预测结果与实验测量值进行比较。然而，由于模型的输入参数（如材料属性）和实验测量过程都存在不确定性，因此简单的数值比较是不够的。本练习将带您实践一种严谨的验证方法：通过推导和应用灵敏度系数，来量化模型输入参数的不确定性如何传播到最终的温度预测中。这将使我们能够构建预测值的置信区间，并据此做出关于模型与实验是否在统计上一致的科学判断 。",
            "id": "4002180",
            "problem": "考虑一个占据 $x \\ge 0$ 区域的均匀、各向同性的半无限固体中的一维瞬态热传导问题。其控制平衡是能量守恒定律与傅里叶热传导定律的结合，从而得到一个偏微分方程（PDE）：温度场 $T(x,t)$ 满足能量守恒、傅里叶定律以及相应的初始和边界条件。在 $x=0$ 的表面，在时间 $t=0$ 时温度发生瞬时阶跃变化，使得当 $t>0$ 时 $T(0,t)=T_s$，初始条件为对所有 $x \\ge 0$，$T(x,0)=T_i$。该材料的热导率为 $k$，密度为 $\\rho$，比热容为 $c_p$，热扩散率定义为 $\\alpha = \\frac{k}{\\rho c_p}$。预测的温度 $T(x,t)$ 取决于热属性 $k$、$\\rho$ 和 $c_p$。\n\n在计算热工验证中，我们旨在量化材料属性中的不确定性如何传播到指定点 $(x,t)$ 处预测温度 $T(x,t)$ 的不确定性，并评估其与实验测量值的一致性。您必须从第一性原理出发，推导 $T$ 相对于属性 $k$、$\\rho$ 和 $c_p$ 的灵敏度系数，然后使用它们来传播属性不确定性。假设不确定性很小，以致一阶线性化有效。\n\n需要执行的任务：\n- 从描述的边界和初始条件的半无限固体的控制能量守恒和傅里叶传导定律出发，推导 $T(x,t)$ 的表达式，然后通过 $\\alpha = \\frac{k}{\\rho c_p}$ 使用链式法则推导灵敏度系数 $\\frac{\\partial T}{\\partial k}$、$\\frac{\\partial T}{\\partial \\rho}$ 和 $\\frac{\\partial T}{\\partial c_p}$。\n- 设属性向量为 $\\mathbf{p} = [k,\\rho,c_p]^T$，其均值和协方差矩阵 $\\boldsymbol{\\Sigma}$ 编码了标准差和互协方差。在一阶线性化下，展示在给定的 $(x,t)$ 处 $T$ 的方差如何计算为 $J \\boldsymbol{\\Sigma} J^T$，其中 $J = \\left[\\frac{\\partial T}{\\partial k}, \\frac{\\partial T}{\\partial \\rho}, \\frac{\\partial T}{\\partial c_p}\\right]$。\n- 将总方差分解为来自单个属性及其成对协方差的贡献：来自对角项的 $V_k$、$V_\\rho$、$V_{c_p}$，以及来自非对角项的 $V_{k\\rho}$、$V_{kc_p}$、$V_{\\rho c_p}$，其中 $V_k = \\left(\\frac{\\partial T}{\\partial k}\\right)^2 \\sigma_k^2$，$V_\\rho = \\left(\\frac{\\partial T}{\\partial \\rho}\\right)^2 \\sigma_\\rho^2$，$V_{c_p} = \\left(\\frac{\\partial T}{\\partial c_p}\\right)^2 \\sigma_{c_p}^2$，对于 $i \\ne j$，$V_{ij} = 2 \\frac{\\partial T}{\\partial p_i} \\frac{\\partial T}{\\partial p_j} \\operatorname{Cov}(p_i,p_j)$。总方差为 $V_{\\text{tot}} = V_k + V_\\rho + V_{c_p} + V_{k\\rho} + V_{kc_p} + V_{\\rho c_p}$，总标准差为 $\\sigma_T = \\sqrt{V_{\\text{tot}}}$。\n- 为与实验数据进行验证，给定实验温度 $T_{\\text{exp}}$ 和实验标准差 $\\sigma_{\\text{exp}}$，根据 $2$ 倍标准差准则计算在 $(x,t)$ 处的模型预测是否与测量值统计上兼容，即判断是否满足 $\\left|T_{\\text{model}} - T_{\\text{exp}}\\right| \\le 2 \\sqrt{\\sigma_T^2 + \\sigma_{\\text{exp}}^2}$。\n\n使用以下测试套件（所有物理量必须按指定单位处理）：\n\n材料平均属性（所有情况相同）：$k = 16\\,\\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$，$\\rho = 8000\\,\\text{kg}\\,\\text{m}^{-3}$，$c_p = 500\\,\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$。\n\n情况1（理想情况，独立不确定性）：\n- 空间位置和时间：$x = 0.01\\,\\text{m}$，$t = 100\\,\\text{s}$。\n- 边界和初始温度：$T_s = 350\\,\\text{K}$，$T_i = 300\\,\\text{K}$。\n- 属性标准差：$\\sigma_k = 0.8\\,\\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$，$\\sigma_\\rho = 400\\,\\text{kg}\\,\\text{m}^{-3}$，$\\sigma_{c_p} = 25\\,\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$。\n- 协方差：$\\operatorname{Cov}(k,\\rho)=0$，$\\operatorname{Cov}(k,c_p)=0$，$\\operatorname{Cov}(\\rho,c_p)=0$。\n- 实验温度和不确定性：$T_{\\text{exp}} = 336.0\\,\\text{K}$，$\\sigma_{\\text{exp}} = 0.2\\,\\text{K}$。\n\n情况2（相关属性）：\n- 空间位置和时间：$x = 0.01\\,\\text{m}$，$t = 100\\,\\text{s}$。\n- 边界和初始温度：$T_s = 350\\,\\text{K}$，$T_i = 300\\,\\text{K}$。\n- 属性标准差：$\\sigma_k = 0.8\\,\\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$，$\\sigma_\\rho = 400\\,\\text{kg}\\,\\text{m}^{-3}$，$\\sigma_{c_p} = 25\\,\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$。\n- 由相关系数 $r_{ij}$ 构建的协方差：$r_{k\\rho} = -0.5$，$r_{kc_p} = 0.8$，$r_{\\rho c_p} = 0.3$。因此，$\\operatorname{Cov}(k,\\rho) = r_{k\\rho}\\,\\sigma_k \\sigma_\\rho$，$\\operatorname{Cov}(k,c_p) = r_{kc_p}\\,\\sigma_k \\sigma_{c_p}$，$\\operatorname{Cov}(\\rho,c_p) = r_{\\rho c_p}\\,\\sigma_\\rho \\sigma_{c_p}$。\n- 实验温度和不确定性：$T_{\\text{exp}} = 336.5\\,\\text{K}$，$\\sigma_{\\text{exp}} = 0.3\\,\\text{K}$。\n\n情况3（早期时间的边缘情况，独立不确定性）：\n- 空间位置和时间：$x = 0.01\\,\\text{m}$，$t = 1\\,\\text{s}$。\n- 边界和初始温度：$T_s = 350\\,\\text{K}$，$T_i = 300\\,\\text{K}$。\n- 属性标准差：$\\sigma_k = 0.8\\,\\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$，$\\sigma_\\rho = 400\\,\\text{kg}\\,\\text{m}^{-3}$，$\\sigma_{c_p} = 25\\,\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$。\n- 协方差：$\\operatorname{Cov}(k,\\rho)=0$，$\\operatorname{Cov}(k,c_p)=0$，$\\operatorname{Cov}(\\rho,c_p)=0$。\n- 实验温度和不确定性：$T_{\\text{exp}} = 300.5\\,\\text{K}$，$\\sigma_{\\text{exp}} = 0.2\\,\\text{K}$。\n\n单位和输出要求：\n- 所有输入和计算必须遵守规定的物理单位。\n- 以 $\\text{K}$ 为单位表示总标准差 $\\sigma_T$。\n- 以 $\\text{K}^2$ 为单位表示每个方差贡献 $V_k$、$V_\\rho$、$V_{c_p}$、$V_{k\\rho}$、$V_{kc_p}$、$V_{\\rho c_p}$。\n- 兼容性结果必须是布尔值。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例产生一个形如 $[\\sigma_T, V_k, V_\\rho, V_{c_p}, V_{k\\rho}, V_{kc_p}, V_{\\rho c_p}, \\text{compat}]$ 的列表。总体输出应该是这些按用例生成的列表的列表，例如：$[[\\dots],[\\dots],[\\dots]]$。",
            "solution": "该问题要求针对一维瞬态热传导问题，推导并应用一种不确定性传播方法。求解过程分三个阶段：首先，从基本原理推导解析温度场；其次，推导关于材料属性的灵敏度系数；第三，应用这些灵敏度系数来传播不确定性，并与实验数据进行验证检查。\n\n### 1. 温度场 $T(x,t)$ 的推导\n\n均匀介质中一维热传导的控制偏微分方程（PDE）是热方程：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} \\quad \\text{for } x > 0, t > 0\n$$\n其中 $T(x,t)$ 是温度，$x$ 是空间坐标，$t$ 是时间，$\\alpha = \\frac{k}{\\rho c_p}$ 是热扩散率。材料属性为热导率 $k$、密度 $\\rho$ 和比热容 $c_p$。\n\n该问题定义在半无限域 $x \\ge 0$上，具有以下初始和边界条件：\n- 初始条件 (IC): 对 $x \\ge 0$，$T(x, 0) = T_i$\n- 边界条件 (BC1): 对 $t > 0$，$T(0, t) = T_s$\n- 边界条件 (BC2): 对 $t > 0$，$T(x \\to \\infty, t) = T_i$\n\n为了简化问题，我们引入无量纲温度 $\\theta(x,t)$：\n$$\n\\theta(x,t) = \\frac{T(x,t) - T_i}{T_s - T_i}\n$$\n$\\theta$ 的偏微分方程和条件变为：\n$$\n\\frac{\\partial \\theta}{\\partial t} = \\alpha \\frac{\\partial^2 \\theta}{\\partial x^2}\n$$\n- 初始条件: $\\theta(x, 0) = 0$\n- 边界条件1: $\\theta(0, t) = 1$\n- 边界条件2: $\\theta(x \\to \\infty, t) = 0$\n\n这是一个自相似问题，可以使用相似性变换求解。我们引入一个结合了 $x$ 和 $t$ 的单一相似性变量 $\\eta$：\n$$\n\\eta = \\frac{x}{2\\sqrt{\\alpha t}}\n$$\n我们假设解 $\\theta(x,t)$ 仅是 $\\eta$ 的函数，即 $\\theta(x,t) = f(\\eta)$。使用链式法则，我们将 $\\theta$ 的偏微分方程转换为关于 $f(\\eta)$ 的常微分方程 (ODE)：\n$$\n\\frac{\\partial \\theta}{\\partial t} = \\frac{df}{d\\eta}\\frac{\\partial \\eta}{\\partial t} = f'(\\eta) \\left(-\\frac{x}{4\\sqrt{\\alpha} t^{3/2}}\\right) = -\\frac{\\eta}{2t} f'(\\eta)\n$$\n$$\n\\frac{\\partial \\theta}{\\partial x} = \\frac{df}{d\\eta}\\frac{\\partial \\eta}{\\partial x} = f'(\\eta) \\frac{1}{2\\sqrt{\\alpha t}} \\quad \\implies \\quad \\frac{\\partial^2 \\theta}{\\partial x^2} = f''(\\eta) \\left(\\frac{1}{2\\sqrt{\\alpha t}}\\right)^2 = \\frac{1}{4\\alpha t} f''(\\eta)\n$$\n将这些代入 $\\theta$ 的热方程中：\n$$\n-\\frac{\\eta}{2t} f'(\\eta) = \\alpha \\left(\\frac{1}{4\\alpha t} f''(\\eta)\\right) \\implies f''(\\eta) + 2\\eta f'(\\eta) = 0\n$$\n$f(\\eta)$ 的边界条件是：\n- $f(\\eta=0) = \\theta(0,t) = 1$\n- $f(\\eta \\to \\infty) = \\theta(x \\to \\infty, t) = 0$\n\n这个二阶常微分方程可以通过首先令 $g(\\eta) = f'(\\eta)$ 来求解，这会得到一阶常微分方程 $g'(\\eta) + 2\\eta g(\\eta) = 0$。这是一个可分离方程：$\\frac{dg}{g} = -2\\eta d\\eta$，积分得到 $\\ln(g) = -\\eta^2 + C_1$，或 $g(\\eta) = C_2 e^{-\\eta^2}$。\n然后，$f(\\eta) = \\int g(\\eta) d\\eta = C_2 \\int e^{-\\eta^2} d\\eta + C_3$。该积分与误差函数 $\\operatorname{erf}(\\eta) = \\frac{2}{\\sqrt{\\pi}}\\int_0^\\eta e^{-u^2}du$ 相关。因此，通解为 $f(\\eta) = A \\operatorname{erf}(\\eta) + B$。\n\n应用边界条件：\n- $f(0) = 1 \\implies A \\operatorname{erf}(0) + B = 1 \\implies B=1$\n- $f(\\infty) = 0 \\implies A \\operatorname{erf}(\\infty) + B = 0 \\implies A(1) + 1 = 0 \\implies A=-1$\n\n$f(\\eta)$ 的解是 $f(\\eta) = 1 - \\operatorname{erf}(\\eta) = \\operatorname{erfc}(\\eta)$，其中 $\\operatorname{erfc}$ 是互补误差函数。\n转换回原始变量：\n$$\n\\frac{T(x,t) - T_i}{T_s - T_i} = \\operatorname{erfc}\\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right)\n$$\n温度场的最终表达式为：\n$$\nT(x,t) = T_i + (T_s - T_i) \\operatorname{erfc}\\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right)\n$$\n\n### 2. 灵敏度系数的推导\n\n灵敏度系数 $\\frac{\\partial T}{\\partial p_j}$（其中 $p_j \\in \\{k, \\rho, c_p\\}$）量化了温度预测值随材料属性微小变化的改变程度。$T$ 对这些属性的依赖完全通过热扩散率 $\\alpha$ 体现。我们使用链式法则：\n$$\n\\frac{\\partial T}{\\partial p_j} = \\frac{\\partial T}{\\partial \\alpha} \\frac{\\partial \\alpha}{\\partial p_j}\n$$\n首先，我们求 $T$ 相对于 $\\alpha$ 的偏导数。令 $\\eta = \\frac{x}{2\\sqrt{\\alpha t}} = \\frac{x}{2\\sqrt{t}}\\alpha^{-1/2}$。\n$$\n\\frac{\\partial T}{\\partial \\alpha} = (T_s - T_i) \\frac{d}{d\\alpha} \\left[\\operatorname{erfc}(\\eta)\\right] = (T_s - T_i) \\frac{d(\\operatorname{erfc}(\\eta))}{d\\eta} \\frac{\\partial \\eta}{\\partial \\alpha}\n$$\n互补误差函数的导数是 $\\frac{d}{d\\eta}\\operatorname{erfc}(\\eta) = -\\frac{2}{\\sqrt{\\pi}}e^{-\\eta^2}$。$\\eta$ 相对于 $\\alpha$ 的导数是：\n$$\n\\frac{\\partial \\eta}{\\partial \\alpha} = \\frac{x}{2\\sqrt{t}} \\left(-\\frac{1}{2}\\alpha^{-3/2}\\right) = -\\frac{x}{4\\sqrt{t}\\alpha\\sqrt{\\alpha}} = -\\frac{1}{2\\alpha} \\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right) = -\\frac{\\eta}{2\\alpha}\n$$\n将这些结合起来得到：\n$$\n\\frac{\\partial T}{\\partial \\alpha} = (T_s - T_i) \\left(-\\frac{2}{\\sqrt{\\pi}}e^{-\\eta^2}\\right) \\left(-\\frac{\\eta}{2\\alpha}\\right) = (T_s - T_i) \\frac{\\eta}{\\alpha\\sqrt{\\pi}} e^{-\\eta^2}\n$$\n接下来，我们求 $\\alpha = \\frac{k}{\\rho c_p}$ 相对于每个属性的偏导数：\n$$\n\\frac{\\partial \\alpha}{\\partial k} = \\frac{1}{\\rho c_p} = \\frac{\\alpha}{k}\n$$\n$$\n\\frac{\\partial \\alpha}{\\partial \\rho} = -\\frac{k}{(\\rho c_p)^2} \\rho = -\\frac{k}{\\rho^2 c_p} = -\\frac{\\alpha}{\\rho}\n$$\n$$\n\\frac{\\partial \\alpha}{\\partial c_p} = -\\frac{k}{\\rho c_p^2} = -\\frac{\\alpha}{c_p}\n$$\n最后，我们组装灵敏度系数：\n$$\n\\frac{\\partial T}{\\partial k} = \\frac{\\partial T}{\\partial \\alpha} \\frac{\\partial \\alpha}{\\partial k} = \\left( (T_s - T_i) \\frac{\\eta}{\\alpha\\sqrt{\\pi}} e^{-\\eta^2} \\right) \\left(\\frac{\\alpha}{k}\\right) = (T_s - T_i) \\frac{\\eta}{k\\sqrt{\\pi}} e^{-\\eta^2}\n$$\n$$\n\\frac{\\partial T}{\\partial \\rho} = \\frac{\\partial T}{\\partial \\alpha} \\frac{\\partial \\alpha}{\\partial \\rho} = \\left( (T_s - T_i) \\frac{\\eta}{\\alpha\\sqrt{\\pi}} e^{-\\eta^2} \\right) \\left(-\\frac{\\alpha}{\\rho}\\right) = -(T_s - T_i) \\frac{\\eta}{\\rho\\sqrt{\\pi}} e^{-\\eta^2}\n$$\n$$\n\\frac{\\partial T}{\\partial c_p} = \\frac{\\partial T}{\\partial \\alpha} \\frac{\\partial \\alpha}{\\partial c_p} = \\left( (T_s - T_i) \\frac{\\eta}{\\alpha\\sqrt{\\pi}} e^{-\\eta^2} \\right) \\left(-\\frac{\\alpha}{c_p}\\right) = -(T_s - T_i) \\frac{\\eta}{c_p\\sqrt{\\pi}} e^{-\\eta^2}\n$$\n这些表达式将用于不确定性传播。\n\n### 3. 不确定性传播与验证\n\n给定属性向量 $\\mathbf{p} = [k, \\rho, c_p]^T$ 中的微小不确定性，由协方差矩阵 $\\boldsymbol{\\Sigma}$ 表征，预测温度 $T$ 的方差可以一阶近似为：\n$$\n\\sigma_T^2 = J \\boldsymbol{\\Sigma} J^T\n$$\n其中 $J = \\left[\\frac{\\partial T}{\\partial k}, \\frac{\\partial T}{\\partial \\rho}, \\frac{\\partial T}{\\partial c_p}\\right]$ 是雅可比矩阵（在此为行向量）。展开此矩阵乘积可得总方差：\n$$\n\\sigma_T^2 = \\sum_{i=1}^3 \\sum_{j=1}^3 J_i J_j \\boldsymbol{\\Sigma}_{ij} = \\left(\\frac{\\partial T}{\\partial k}\\right)^2 \\sigma_k^2 + \\left(\\frac{\\partial T}{\\partial \\rho}\\right)^2 \\sigma_\\rho^2 + \\left(\\frac{\\partial T}{\\partial c_p}\\right)^2 \\sigma_{c_p}^2 + 2\\frac{\\partial T}{\\partial k}\\frac{\\partial T}{\\partial \\rho}\\operatorname{Cov}(k,\\rho) + 2\\frac{\\partial T}{\\partial k}\\frac{\\partial T}{\\partial c_p}\\operatorname{Cov}(k,c_p) + 2\\frac{\\partial T}{\\partial \\rho}\\frac{\\partial T}{\\partial c_p}\\operatorname{Cov}(\\rho,c_p)\n$$\n这个总方差 $V_{\\text{tot}} = \\sigma_T^2$ 可以分解为来自单个属性方差及其成对协方差的贡献，正如问题陈述中所指定。\n\n为了进行验证，模型预测值 $T_{\\text{model}}$ 必须与实验测量值 $T_{\\text{exp}}$ 进行比较。差值 $D = T_{\\text{model}} - T_{\\text{exp}}$ 的方差是模型预测方差和实验测量方差之和（假设它们是独立的）：$\\sigma_D^2 = \\sigma_T^2 + \\sigma_{\\text{exp}}^2$。统计兼容性检验是检查均值之差是否落在某个置信区间内，这里指定为 $2$ 倍标准差：\n$$\n|T_{\\text{model}} - T_{\\text{exp}}| \\le 2\\sigma_D = 2 \\sqrt{\\sigma_T^2 + \\sigma_{\\text{exp}}^2}\n$$\n如果这个不等式成立，则认为模型与实验在统计上是兼容的。现在将以计算方式实现这整个过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Solves the transient heat conduction and uncertainty propagation problem for the given test cases.\n    \"\"\"\n\n    # Material mean properties (SI units)\n    k_mean = 16.0  # W/(m*K)\n    rho_mean = 8000.0  # kg/m^3\n    cp_mean = 500.0  # J/(kg*K)\n\n    test_cases = [\n        # Case 1: Independent uncertainties\n        {\n            \"x\": 0.01, \"t\": 100.0, \"Ts\": 350.0, \"Ti\": 300.0,\n            \"sigma_k\": 0.8, \"sigma_rho\": 400.0, \"sigma_cp\": 25.0,\n            \"cov_k_rho\": 0.0, \"cov_k_cp\": 0.0, \"cov_rho_cp\": 0.0,\n            \"T_exp\": 336.0, \"sigma_exp\": 0.2\n        },\n        # Case 2: Correlated properties\n        {\n            \"x\": 0.01, \"t\": 100.0, \"Ts\": 350.0, \"Ti\": 300.0,\n            \"sigma_k\": 0.8, \"sigma_rho\": 400.0, \"sigma_cp\": 25.0,\n            \"r_k_rho\": -0.5, \"r_k_cp\": 0.8, \"r_rho_cp\": 0.3,\n            \"T_exp\": 336.5, \"sigma_exp\": 0.3\n        },\n        # Case 3: Early-time edge case, independent uncertainties\n        {\n            \"x\": 0.01, \"t\": 1.0, \"Ts\": 350.0, \"Ti\": 300.0,\n            \"sigma_k\": 0.8, \"sigma_rho\": 400.0, \"sigma_cp\": 25.0,\n            \"cov_k_rho\": 0.0, \"cov_k_cp\": 0.0, \"cov_rho_cp\": 0.0,\n            \"T_exp\": 300.5, \"sigma_exp\": 0.2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        x, t = case[\"x\"], case[\"t\"]\n        Ts, Ti = case[\"Ts\"], case[\"Ti\"]\n        sigma_k, sigma_rho, sigma_cp = case[\"sigma_k\"], case[\"sigma_rho\"], case[\"sigma_cp\"]\n        T_exp, sigma_exp = case[\"T_exp\"], case[\"sigma_exp\"]\n\n        # Handle covariance calculations for Case 2\n        if \"r_k_rho\" in case:\n            r_k_rho, r_k_cp, r_rho_cp = case[\"r_k_rho\"], case[\"r_k_cp\"], case[\"r_rho_cp\"]\n            cov_k_rho = r_k_rho * sigma_k * sigma_rho\n            cov_k_cp = r_k_cp * sigma_k * sigma_cp\n            cov_rho_cp = r_rho_cp * sigma_rho * sigma_cp\n        else:\n            cov_k_rho, cov_k_cp, cov_rho_cp = case[\"cov_k_rho\"], case[\"cov_k_cp\"], case[\"cov_rho_cp\"]\n\n        # 1. Calculate model temperature T_model\n        alpha = k_mean / (rho_mean * cp_mean)\n        eta = x / (2 * np.sqrt(alpha * t))\n        T_model = Ti + (Ts - Ti) * erfc(eta)\n\n        # 2. Calculate sensitivity coefficients\n        common_factor = (Ts - Ti) * (eta / np.sqrt(np.pi)) * np.exp(-eta**2)\n        \n        # Handle eta=0 case to avoid division by zero in sensitivity formulas\n        # At eta=0 (x=0), sensitivities are zero because T is fixed by BC.\n        # For eta -> inf, sensitivities go to 0.\n        if np.isclose(eta, 0):\n            sens_k, sens_rho, sens_cp = 0.0, 0.0, 0.0\n        else:\n            sens_k = common_factor / k_mean\n            sens_rho = -common_factor / rho_mean\n            sens_cp = -common_factor / cp_mean\n        \n        # 3. Calculate variance contributions\n        V_k = sens_k**2 * sigma_k**2\n        V_rho = sens_rho**2 * sigma_rho**2\n        V_cp = sens_cp**2 * sigma_cp**2\n        \n        V_k_rho = 2 * sens_k * sens_rho * cov_k_rho\n        V_k_cp = 2 * sens_k * sens_cp * cov_k_cp\n        V_rho_cp = 2 * sens_rho * sens_cp * cov_rho_cp\n\n        # 4. Calculate total variance and standard deviation\n        V_tot = V_k + V_rho + V_cp + V_k_rho + V_k_cp + V_rho_cp\n        sigma_T = np.sqrt(V_tot)\n\n        # 5. Perform statistical compatibility check\n        total_variance_diff = sigma_T**2 + sigma_exp**2\n        is_compatible = abs(T_model - T_exp) = 2 * np.sqrt(total_variance_diff)\n\n        case_results = [sigma_T, V_k, V_rho, V_cp, V_k_rho, V_k_cp, V_rho_cp, is_compatible]\n        results.append(case_results)\n\n    # Format the entire output as a single string\n    # Convert each inner list to its string representation\n    # Then join these strings with commas\n    # Finally, wrap the result in square brackets\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}