{
    "hands_on_practices": [
        {
            "introduction": "理论知识只有通过实践才能真正内化。本章提供了一系列精心设计的动手实践，旨在引导你从基本计算过渡到高级算法设计，从而加深对非结构网格上梯度重构的理解。我们的第一个实践是应用Green-Gauss方法进行基础梯度计算。这个练习  不仅要求你动手执行有限体积法中的一项核心任务，还促使你思考不同界面值近似方案（这是关键的建模选择）如何影响最终结果，并直面网格歪斜度对计算精度的影响。",
            "id": "3958307",
            "problem": "考虑一个在计算热工学中，用于计算流体力学（CFD）的有限体积法（FVM）的二维控制体（单元）$P$。单元 $P$ 的体积为 $V_{P} = 1.0$，其边界 $\\partial V_{P}$ 由四个平面 $f \\in \\{E,N,W,S\\}$（东、北、西、南）组成。外向面矢量由 $\\boldsymbol{S}_{E} = (1.0,\\,0.0)$、$\\boldsymbol{S}_{N} = (0.0,\\,1.2)$、$\\boldsymbol{S}_{W} = (-1.0,\\,0.0)$ 和 $\\boldsymbol{S}_{S} = (0.0,\\,-1.2)$ 给出。单元中心位于 $\\boldsymbol{x}_{P} = (0.0,\\,0.0)$，面中心位于 $\\boldsymbol{x}_{f,E} = (0.6,\\,0.3)$、$\\boldsymbol{x}_{f,N} = (-0.1,\\,0.7)$、$\\boldsymbol{x}_{f,W} = (-0.5,\\,-0.2)$ 和 $\\boldsymbol{x}_{f,S} = (0.1,\\,-0.6)$。与面 $E$、$N$、$W$ 和 $S$ 相邻的单元中心分别为 $\\boldsymbol{x}_{N,E} = (1.0,\\,0.1)$、$\\boldsymbol{x}_{N,N} = (0.2,\\,1.1)$、$\\boldsymbol{x}_{N,W} = (-1.1,\\,-0.1)$ 和 $\\boldsymbol{x}_{N,S} = (0.0,\\,-1.0)$。\n\n温度场是光滑的，其解析式为\n$$\nT(x,y) \\;=\\; 300 \\;+\\; 5x \\;-\\; 3y \\;+\\; 2x^{2} \\;-\\; xy \\;+\\; y^{2}.\n$$\n\n从散度定理和基本定义出发，推导单元 $P$ 的离散 Green–Gauss 梯度重构公式，\n$$\n\\nabla T_{P} \\;\\approx\\; \\frac{1}{V_{P}} \\sum_{f \\in \\partial V_{P}} T_{f}\\,\\boldsymbol{S}_{f},\n$$\n并清晰说明面温度 $T_{f}$ 是如何近似的。然后：\n\n1. 使用等权重中心到中心插值，定义 $T_{f}^{\\text{lin}} = \\frac{1}{2}\\left(T_{P} + T_{N,f}\\right)$，其中 $T_{P} = T(\\boldsymbol{x}_{P})$ 且 $T_{N,f} = T(\\boldsymbol{x}_{N,f})$，并计算 Green–Gauss 近似值 $\\nabla T_{P}^{\\text{lin}}$。\n\n2. 使用精确面心值计算，定义 $T_{f}^{\\text{exact}} = T(\\boldsymbol{x}_{f})$，并计算 Green–Gauss 近似值 $\\nabla T_{P}^{\\text{exact}}$。\n\n3. 从 Taylor 级数的角度，定性讨论扭曲面（其中 $\\boldsymbol{x}_{f}$ 与连接 $\\boldsymbol{x}_{P}$ 和 $\\boldsymbol{x}_{N,f}$ 的直线不共线）对 $\\nabla T_{P}^{\\text{lin}}$ 相对于 $\\nabla T_{P}^{\\text{exact}}$ 和真实梯度的误差的影响。\n\n将两个梯度向量按 $\\nabla T_{P}^{\\text{lin}}$ 和 $\\nabla T_{P}^{\\text{exact}}$ 的顺序，以单行矩阵的形式报告。将每个分量四舍五入到四位有效数字。每个梯度分量的单位为 $\\mathrm{K/m}$。",
            "solution": "该问题要求在 Green-Gauss 重构框架内，使用两种不同的面温度近似方法计算控制体内的温度梯度，然后讨论结果。\n\n首先，我们推导梯度的离散 Green-Gauss 公式。推导从梯度定理开始，该定理是 Gauss 散度定理的一个推论。对于标量场 $T$ 和常数向量 $\\boldsymbol{c}$，将散度定理应用于向量场 $T\\boldsymbol{c}$ 可得：\n$$ \\int_{V} \\nabla \\cdot (T\\boldsymbol{c}) \\, dV = \\oint_{\\partial V} (T\\boldsymbol{c}) \\cdot d\\boldsymbol{S} $$\n使用乘积法则 $\\nabla \\cdot (\\phi \\boldsymbol{A}) = \\phi (\\nabla \\cdot \\boldsymbol{A}) + \\boldsymbol{A} \\cdot (\\nabla \\phi)$，并注意对于常数向量 $\\boldsymbol{c}$ 有 $\\nabla \\cdot \\boldsymbol{c} = 0$，我们得到 $\\nabla \\cdot (T\\boldsymbol{c}) = \\boldsymbol{c} \\cdot \\nabla T$。将此代入散度定理可得：\n$$ \\int_{V} \\boldsymbol{c} \\cdot \\nabla T \\, dV = \\oint_{\\partial V} T (\\boldsymbol{c} \\cdot d\\boldsymbol{S}) $$\n由于 $\\boldsymbol{c}$ 是一个任意常数向量，它可以从积分中提出：\n$$ \\boldsymbol{c} \\cdot \\int_{V} \\nabla T \\, dV = \\boldsymbol{c} \\cdot \\oint_{\\partial V} T \\, d\\boldsymbol{S} $$\n该等式对任何 $\\boldsymbol{c}$ 都成立，这意味着向量本身必须相等：\n$$ \\int_{V} \\nabla T \\, dV = \\oint_{\\partial V} T \\, d\\boldsymbol{S} $$\n为了将其应用于有限体积单元 $P$，我们引入近似。梯度 $\\nabla T$ 被假定在单元体积 $V_P$ 上是恒定的，并等于其在中心点的值 $\\nabla T_P$。体积积分因此近似为：\n$$ \\int_{V_P} \\nabla T \\, dV \\approx \\nabla T_P \\int_{V_P} dV = V_P \\nabla T_P $$\n在边界 $\\partial V_P$ 上的面积分被离散为对各个面 $f$ 的求和。在每个面上，温度被假定为恒定的，并等于一个具有代表性的面值 $T_f$。面积分近似为：\n$$ \\oint_{\\partial V_P} T \\, d\\boldsymbol{S} = \\sum_{f \\in \\partial V_P} \\int_{S_f} T \\, d\\boldsymbol{S} \\approx \\sum_{f \\in \\partial V_P} T_f \\int_{S_f} d\\boldsymbol{S} = \\sum_{f \\in \\partial V_P} T_f \\boldsymbol{S}_f $$\n其中 $\\boldsymbol{S}_f$ 是面 $f$ 的外向面积矢量。\n令近似的体积积分和面积分相等，得到 $V_P \\nabla T_P \\approx \\sum_{f} T_f \\boldsymbol{S}_f$，这就导出了所要求的公式：\n$$ \\nabla T_P \\approx \\frac{1}{V_P} \\sum_{f \\in \\partial V_P} T_f \\boldsymbol{S}_f $$\n这种重构的准确性取决于用于面温度 $T_f$ 的近似方法。\n\n给定的温度场是 $T(x,y) = 300 + 5x - 3y + 2x^2 - xy + y^2$。\n单元中心是 $\\boldsymbol{x}_P = (0.0, 0.0)$，所以中心点的温度是 $T_P = T(0.0, 0.0) = 300$。\n单元体积给定为 $V_P = 1.0$。\n\n### 1. 使用线性插值的梯度，$\\nabla T_P^{\\text{lin}}$\n\n该方法通过在共享面的两个单元中心之间进行线性插值来近似面温度：$T_f^{\\text{lin}} = \\frac{1}{2}(T_P + T_{N,f})$。我们首先计算相邻单元中心的温度。\n$T_{N,E} = T(1.0, 0.1) = 300 + 5(1.0) - 3(0.1) + 2(1.0)^2 - (1.0)(0.1) + (0.1)^2 = 306.61$\n$T_{N,N} = T(0.2, 1.1) = 300 + 5(0.2) - 3(1.1) + 2(0.2)^2 - (0.2)(1.1) + (1.1)^2 = 298.77$\n$T_{N,W} = T(-1.1, -0.1) = 300 + 5(-1.1) - 3(-0.1) + 2(-1.1)^2 - (-1.1)(-0.1) + (-0.1)^2 = 297.12$\n$T_{N,S} = T(0.0, -1.0) = 300 + 5(0.0) - 3(-1.0) + 2(0.0)^2 - (0.0)(-1.0) + (-1.0)^2 = 304.0$\n\n$T_P = 300$时，面温度为：\n$T_{f,E}^{\\text{lin}} = \\frac{1}{2}(300 + 306.61) = 303.305$\n$T_{f,N}^{\\text{lin}} = \\frac{1}{2}(300 + 298.77) = 299.385$\n$T_{f,W}^{\\text{lin}} = \\frac{1}{2}(300 + 297.12) = 298.56$\n$T_{f,S}^{\\text{lin}} = \\frac{1}{2}(300 + 304.0) = 302.0$\n\n现在，我们计算总和 $\\sum_f T_f^{\\text{lin}} \\boldsymbol{S}_f$：\n$\\sum T_f^{\\text{lin}} \\boldsymbol{S}_f = T_{f,E}^{\\text{lin}}\\boldsymbol{S}_E + T_{f,N}^{\\text{lin}}\\boldsymbol{S}_N + T_{f,W}^{\\text{lin}}\\boldsymbol{S}_W + T_{f,S}^{\\text{lin}}\\boldsymbol{S}_S$\n$= 303.305(1.0, 0.0) + 299.385(0.0, 1.2) + 298.56(-1.0, 0.0) + 302.0(0.0, -1.2)$\n$= (303.305 - 298.56, 1.2 \\times 299.385 - 1.2 \\times 302.0)$\n$= (4.745, 359.262 - 362.4)$\n$= (4.745, -3.138)$\n\n梯度为 $\\nabla T_P^{\\text{lin}} = \\frac{1}{V_P} (4.745, -3.138) = \\frac{1}{1.0} (4.745, -3.138) = (4.745, -3.138)$。\n\n### 2. 使用精确面心值计算的梯度，$\\nabla T_P^{\\text{exact}}$\n\n该方法使用面中心的精确温度，$T_f^{\\text{exact}} = T(\\boldsymbol{x}_f)$。\n$T_{f,E}^{\\text{exact}} = T(0.6, 0.3) = 300 + 5(0.6) - 3(0.3) + 2(0.6)^2 - (0.6)(0.3) + (0.3)^2 = 302.73$\n$T_{f,N}^{\\text{exact}} = T(-0.1, 0.7) = 300 + 5(-0.1) - 3(0.7) + 2(-0.1)^2 - (-0.1)(0.7) + (0.7)^2 = 297.98$\n$T_{f,W}^{\\text{exact}} = T(-0.5, -0.2) = 300 + 5(-0.5) - 3(-0.2) + 2(-0.5)^2 - (-0.5)(-0.2) + (-0.2)^2 = 298.54$\n$T_{f,S}^{\\text{exact}} = T(0.1, -0.6) = 300 + 5(0.1) - 3(-0.6) + 2(0.1)^2 - (0.1)(-0.6) + (-0.6)^2 = 302.74$\n\n现在，我们计算总和 $\\sum_f T_f^{\\text{exact}} \\boldsymbol{S}_f$：\n$\\sum T_f^{\\text{exact}} \\boldsymbol{S}_f = T_{f,E}^{\\text{exact}}\\boldsymbol{S}_E + T_{f,N}^{\\text{exact}}\\boldsymbol{S}_N + T_{f,W}^{\\text{exact}}\\boldsymbol{S}_W + T_{f,S}^{\\text{exact}}\\boldsymbol{S}_S$\n$= 302.73(1.0, 0.0) + 297.98(0.0, 1.2) + 298.54(-1.0, 0.0) + 302.74(0.0, -1.2)$\n$= (302.73 - 298.54, 1.2 \\times 297.98 - 1.2 \\times 302.74)$\n$= (4.19, 357.576 - 363.288)$\n$= (4.19, -5.712)$\n\n梯度为 $\\nabla T_P^{\\text{exact}} = \\frac{1}{V_P} (4.19, -5.712) = \\frac{1}{1.0} (4.19, -5.712) = (4.19, -5.712)$。\n\n### 3. 定性讨论\n\n为了评估这些近似的准确性，我们首先计算单元中心 $\\boldsymbol{x}_P=(0.0, 0.0)$ 处的真实梯度。\n温度场的梯度为 $\\nabla T = (\\frac{\\partial T}{\\partial x}, \\frac{\\partial T}{\\partial y}) = (5 + 4x - y, -3 - x + 2y)$。\n在 $\\boldsymbol{x}_P = (0.0, 0.0)$ 处，真实梯度为 $\\nabla T(\\boldsymbol{x}_P) = (5, -3)$。\n\n比较结果：\n真实梯度: $\\nabla T_{\\text{true}} = (5, -3)$\n线性插值: $\\nabla T_P^{\\text{lin}} = (4.745, -3.138)$\n精确面心值: $\\nabla T_P^{\\text{exact}} = (4.19, -5.712)$\n\n$\\nabla T_P^{\\text{lin}}$ 相对于 $\\nabla T_P^{\\text{exact}}$ 的误差受扭曲面的影响可以通过分析每种方法中的误差来源来理解。当连接相邻单元中心 $\\boldsymbol{x}_P$ 和 $\\boldsymbol{x}_{N,f}$ 的线段与面法向量不对齐，或者当该线与面的交点不与面中心 $\\boldsymbol{x}_f$ 重合时，该面被认为是扭曲的。在本问题中，这两种情况都存在。\n\n`lin`方法使用插值温度 $T_f^{\\text{lin}} = \\frac{1}{2}(T_P + T_{N,f})$。对于给定的非线性场，这不是面中心 $\\boldsymbol{x}_f$ 处温度的二阶近似，而是单元中心连线中点 $\\boldsymbol{x}_{m,f} = \\frac{1}{2}(\\boldsymbol{x}_P + \\boldsymbol{x}_{N,f})$ 处温度的二阶近似。在 Green-Gauss 求和中，将这个值应用于面中心位置会引入一个“扭曲误差”。这个误差近似为 $(\\boldsymbol{x}_{m,f} - \\boldsymbol{x}_f) \\cdot \\nabla T$，它是一个一阶误差项，污染了梯度计算，降低了格式的理论精度。\n\n`exact`方法通过使用 $T_f^{\\text{exact}} = T(\\boldsymbol{x}_f)$，似乎更优越，因为它在面积分近似所要求的正确位置上计算温度，从而避免了`lin`方法所犯的显式扭曲误差。然而，Green-Gauss 公式本身是一种近似，其精度对单元的几何形状敏感。对于一个完全正交的单元（例如，与坐标轴对齐的矩形），该公式对于线性温度场是精确的。对于给定的变形单元，该公式引入了显著的几何误差。这就是为什么 $\\nabla T_P^{\\text{exact}}$ 与真实梯度 $\\nabla T_{\\text{true}}$ 有很大偏差。几何上的不完美基本上导致该公式将真实梯度错误地“映射”到一个不准确的数值梯度上。\n\n在这个具体案例中，`lin`方法给出的结果偶然地更接近真实梯度。这是因为`lin`方法固有的误差（来自非线性场的插值误差和扭曲误差）恰好部分抵消了 Green-Gauss 公式在这个特定变形单元上的巨大几何误差。这个结果是偶然的，不具有普遍性。通常，在高质量网格（低扭曲度）上，`exact`方法会更准确。在高度扭曲的网格上，未经显式扭曲校正的`lin`方法是出了名的不准确，并且可能引入非物理的数值扩散。此处`exact`方法的糟糕表现凸显了基本 Green-Gauss 格式在低质量网格上的一个根本局限性。\n\n将计算出的梯度分量四舍五入到四位有效数字：\n$\\nabla T_P^{\\text{lin}} = (4.745, -3.138)$\n$\\nabla T_P^{\\text{exact}} = (4.190, -5.712)$\n\n两个梯度向量以单行矩阵的形式报告：$(\\nabla T_{P,x}^{\\text{lin}}, \\nabla T_{P,y}^{\\text{lin}}, \\nabla T_{P,x}^{\\text{exact}}, \\nabla T_{P,y}^{\\text{exact}})$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4.745  -3.138  4.190  -5.712\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在掌握了基本的手动计算后，下一步是进行编程实现并验证其正确性。一个可靠的数值方法必须遵循基本的物理和数学原理，例如在坐标系变换下的不变性。这个练习  不仅要求你实现加权最小二乘法，更重要的是，它挑战你设计一个数值测试来验证你的代码实现能够正确处理刚性变换（旋转和平移），这体现了梯度的协变性。这是开发可信赖的仿真代码所必需的一项关键技能。",
            "id": "3958335",
            "problem": "考虑一个用于计算热工学中有限体积法 (FVM) 的二维非结构化网格邻域。设在平面上定义一个标量温度场 $T(\\mathbf{x})$，其中 $\\mathbf{x} = (x,y)$ 的单位为米， $T$ 的单位为开尔文。梯度 $\\nabla T(\\mathbf{x})$ 的单位是开尔文/米。您需要实现一种加权最小二乘梯度重构方法，并设计一个测试来验证重构出的梯度在网格的刚性平移和旋转下能够协变变换。您的验证过程必须从第一性原理出发，即从梯度的定义和多变量微积分的链式法则开始推导，不得依赖任何快捷公式。\n\n平面上的刚体运动由一个平移向量 $\\mathbf{t} \\in \\mathbb{R}^2$ （单位为米）和一个旋转角度 $\\theta$ （单位为弧度）给出。旋转矩阵 $\\mathbf{R}(\\theta)$ 满足正交性并保持距离不变。在此运动下，网格点 $\\mathbf{x}$ 映射为 $\\mathbf{x}' = \\mathbf{R}(\\theta)\\mathbf{x} + \\mathbf{t}$。在网格运动下，物理不变量标量场为 $T'(\\mathbf{x}') = T(\\mathbf{R}(\\theta)^{\\top}(\\mathbf{x}' - \\mathbf{t}))$，这表示在 $\\mathbf{x}'$ 的原像处计算的原始场的值。\n\n您必须：\n- 在中心点 $\\mathbf{x}_0$ 处，使用其邻点 $\\{\\mathbf{x}_i\\}$ 以及温度值 $T(\\mathbf{x}_0)$ 和 $T(\\mathbf{x}_i)$，通过最小化带距离权重的残差平方和来估算 $\\mathbf{x}_0$ 处的 $\\nabla T$，从而实现加权最小二乘梯度重构。使用的权重 $w_i$ 与 $1/\\|\\mathbf{x}_i - \\mathbf{x}_0\\|^2$ 成正比。\n- 对网格应用刚体运动 $(\\mathbf{R}(\\theta), \\mathbf{t})$ 以获得 $\\mathbf{x}_0' = \\mathbf{R}(\\theta)\\mathbf{x}_0 + \\mathbf{t}$ 和 $\\mathbf{x}_i' = \\mathbf{R}(\\theta)\\mathbf{x}_i + \\mathbf{t}$，并如上所述定义 $T'(\\mathbf{x}')$。使用变换后的邻点和 $T'$ 在 $\\mathbf{x}_0'$ 处重构梯度。\n- 使用第一性原理（链式法则），确定原始梯度与变换后坐标系中的梯度之间为满足协变性而必须遵循的理论关系。严格地使用此关系，仅根据您原始重构的梯度和刚体运动参数来计算变换后的期望梯度，不进行任何启发式修正。\n- 计算变换后期望梯度与重构梯度之间的差异，即它们差值的欧几里得范数。以 $\\mathrm{K/m}$ 为单位表示该差异。\n\n实现该程序，并在以下测试集上进行评估。每种情况下的温度场都是线性的：$T(\\mathbf{x}) = \\alpha x + \\beta y + \\gamma$，其中 $\\alpha$ 和 $\\beta$ 的单位为 $\\mathrm{K/m}$，$\\gamma$ 的单位为 $\\mathrm{K}$。角度以弧度为单位指定；位置以米为单位指定。对于每个测试用例，请使用所提供的中心点和邻点坐标。\n\n测试用例 1（一般刚体运动，非退化邻域）：\n- 中心点 $\\mathbf{x}_0 = (0.3,-0.4)$。\n- 邻点 $\\{(1.1,-0.5),(0.0,-0.1),(0.8,0.7),(-0.6,-0.9),(0.4,-1.2),(1.5,0.2)\\}$。\n- 场系数：$\\alpha = 2.5$，$\\beta = -1.0$，$\\gamma = 350$。\n- 旋转角：$\\theta = 0.7$。\n- 平移：$\\mathbf{t} = (0.5,-1.0)$。\n\n测试用例 2（纯平移，非退化邻域）：\n- 中心点 $\\mathbf{x}_0 = (0.3,-0.4)$。\n- 邻点 $\\{(1.1,-0.5),(0.0,-0.1),(0.8,0.7),(-0.6,-0.9),(0.4,-1.2),(1.5,0.2)\\}$。\n- 场系数：$\\alpha = 2.5$，$\\beta = -1.0$，$\\gamma = 350$。\n- 旋转角：$\\theta = 0.0$。\n- 平移：$\\mathbf{t} = (-3.0,4.0)$。\n\n测试用例 3（纯旋转 $\\,\\pi\\,$，不同邻域）：\n- 中心点 $\\mathbf{x}_0 = (-0.2,0.1)$。\n- 邻点 $\\{(0.5,0.6),(-0.1,-0.8),(-0.7,0.3),(0.9,-0.4),(-0.5,1.0)\\}$。\n- 场系数：$\\alpha = 1.2$，$\\beta = 3.4$，$\\gamma = 280$。\n- 旋转角：$\\theta = \\pi$。\n- 平移：$\\mathbf{t} = (0.0,0.0)$。\n\n测试用例 4（带微小横向扰动的近共线邻域）：\n- 中心点 $\\mathbf{x}_0 = (0.0,0.0)$。\n- 邻点 $\\{(-1.0,0.001),(-0.5,-0.002),(0.3,0.0005),(0.8,-0.0015),(1.2,0.002)\\}$。\n- 场系数：$\\alpha = -0.8$，$\\beta = 0.6$，$\\gamma = 310$。\n- 旋转角：$\\theta = \\pi/2$。\n- 平移：$\\mathbf{t} = (0.2,-0.3)$。\n\n您的程序应生成单行输出，其中包含四个测试用例的差异值（以 $\\mathrm{K/m}$ 为单位），形式为方括号内以逗号分隔的列表，例如：$[d_1,d_2,d_3,d_4]$，其中每个 $d_i$ 是一个以 $\\mathrm{K/m}$ 为单位的浮点数。",
            "solution": "用户的请求是验证并解决一个关于在非结构化网格上使用加权最小二乘法重构的梯度的协变变换性质的问题。\n\n### 步骤 1：提取已知条件\n- **标量场**：一个温度场 $T(\\mathbf{x})$，其中 $\\mathbf{x} = (x,y)$。用于测试的场为 $T(\\mathbf{x}) = \\alpha x + \\beta y + \\gamma$。\n- **刚体运动**：一个坐标变换 $\\mathbf{x}' = \\mathbf{R}(\\theta)\\mathbf{x} + \\mathbf{t}$，其中 $\\mathbf{R}(\\theta)$ 是一个二维旋转矩阵（旋转角度为 $\\theta$），$\\mathbf{t}$ 是一个平移向量。\n- **变换后的场**：新坐标系中的标量场定义为 $T'(\\mathbf{x}') = T(\\mathbf{R}(\\theta)^{\\top}(\\mathbf{x}' - \\mathbf{t}))$。\n- **梯度重构方法**：在中心点 $\\mathbf{x}_0$ 使用其邻点 $\\{\\mathbf{x}_i\\}$ 进行加权最小二乘计算。\n- **权重**：邻点 $i$ 的权重为 $w_i \\propto 1/\\|\\mathbf{x}_i - \\mathbf{x}_0\\|^2$。我们将使用 $w_i = 1/\\|\\mathbf{x}_i - \\mathbf{x}_0\\|^2$。\n- **验证任务**：\n    1. 在原始网格中重构 $\\mathbf{x}_0$ 处的梯度 $\\nabla T$。\n    2. 在变换后的网格中重构 $\\mathbf{x}_0' = \\mathbf{R}(\\theta)\\mathbf{x}_0 + \\mathbf{t}$ 处的梯度 $\\nabla' T'$。\n    3. 使用链式法则确定原始梯度和变换后梯度之间的理论关系。\n    4. 使用此关系计算期望的变换后梯度。\n    5. 计算重构的变换后梯度与期望的变换后梯度之间的差异，定义为它们差值的欧几里得范数。\n- **测试用例**：提供了四个具体的测试用例，每个用例都包含：\n    - 中心点 $\\mathbf{x}_0$。\n    - 一组邻点 $\\{\\mathbf{x}_i\\}$。\n    - 温度场系数 $(\\alpha, \\beta, \\gamma)$。\n    - 旋转角 $\\theta$。\n    - 平移向量 $\\mathbf{t}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准评估该问题：\n- **科学依据**：该问题植根于矢量微积分（链式法则、梯度）、线性代数（矩阵运算、最小二乘法）以及计算物理和工程（有限体积法、梯度重构）中的基本原理和标准数值方法。所有概念都是成熟的。\n- **适定性**：问题定义清晰，信息充分。对于每个测试用例，都提供了所有必要数据（网格点、场参数、变换参数）。只要邻点不是完全共线，最小二乘问题就有唯一解，所有测试用例都满足这个条件（测试用例 4 是“近共线”但并非完全共线，这使其成为检验数值稳定性的良好测试）。\n- **客观性**：问题以精确、量化和无偏见的语言陈述。目标具体且可衡量。\n- 该问题未表现出任何无效性缺陷。它在科学上是合理的，可形式化的，完整的，现实的，并且结构良好。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。将提供一个完整的、有理有据的解决方案。\n\n### 基于原理的解决方案\n\n问题的核心是验证数值计算出的梯度在坐标系的刚体运动下能够正确地（协变地）变换。我们首先从第一性原理推导数值方法和理论变换定律。\n\n**1. 加权最小二乘梯度重构**\n我们希望在中心点 $\\mathbf{x}_0$ 找到梯度向量 $\\mathbf{g} = \\nabla T(\\mathbf{x}_0) = (g_x, g_y)^{\\top}$ 的一个估计值。基于一阶泰勒级数展开，邻点 $\\mathbf{x}_i$ 处的温度 $T_i$ 可以近似为：\n$$\nT(\\mathbf{x}_i) \\approx T(\\mathbf{x}_0) + \\nabla T(\\mathbf{x}_0) \\cdot (\\mathbf{x}_i - \\mathbf{x}_0)\n$$\n整理后，我们为每个邻点 $i$ 得到一个方程：\n$$\nT_i - T_0 \\approx g_x (x_i - x_0) + g_y (y_i - y_0)\n$$\n其中 $T_i = T(\\mathbf{x}_i)$ 且 $T_0 = T(\\mathbf{x}_0)$。令 $\\Delta T_i = T_i - T_0$ 和 $\\Delta \\mathbf{x}_i = \\mathbf{x}_i - \\mathbf{x}_0 = (\\Delta x_i, \\Delta y_i)^{\\top}$。所有 $N$ 个邻点的方程组构成了一个超定线性系统 $\\mathbf{A} \\mathbf{g} \\approx \\mathbf{b}$，其中：\n$$\n\\mathbf{A} = \\begin{pmatrix} \\Delta x_1  \\Delta y_1 \\\\ \\Delta x_2  \\Delta y_2 \\\\ \\vdots  \\vdots \\\\ \\Delta x_N  \\Delta y_N \\end{pmatrix}, \\quad\n\\mathbf{g} = \\begin{pmatrix} g_x \\\\ g_y \\end{pmatrix}, \\quad\n\\mathbf{b} = \\begin{pmatrix} \\Delta T_1 \\\\ \\Delta T_2 \\\\ \\vdots \\\\ \\Delta T_N \\end{pmatrix}\n$$\n加权最小二乘法旨在最小化加权残差的平方和：\n$$\nJ(\\mathbf{g}) = \\sum_{i=1}^{N} w_i \\left( (\\Delta x_i, \\Delta y_i) \\cdot \\mathbf{g} - \\Delta T_i \\right)^2 = (\\mathbf{A}\\mathbf{g} - \\mathbf{b})^{\\top} \\mathbf{W} (\\mathbf{A}\\mathbf{g} - \\mathbf{b})\n$$\n其中 $\\mathbf{W}$ 是一个对角权重矩阵，$W_{ii} = w_i = 1/\\|\\Delta \\mathbf{x}_i\\|^2$。通过将 $J$ 对 $\\mathbf{g}$ 的导数设为零，$\\frac{\\partial J}{\\partial \\mathbf{g}} = 0$，可以找到最小值，这会得到正规方程组：\n$$\n(\\mathbf{A}^{\\top}\\mathbf{W}\\mathbf{A})\\mathbf{g} = \\mathbf{A}^{\\top}\\mathbf{W}\\mathbf{b}\n$$\n梯度 $\\mathbf{g}$ 可通过求解这个 $2 \\times 2$ 线性系统得到。对于问题中给出的线性温度场 $T(\\mathbf{x}) = \\alpha x + \\beta y + \\gamma$，真实梯度是常数 $\\nabla T = (\\alpha, \\beta)^{\\top}$。近似式 $T(\\mathbf{x}_i) \\approx T(\\mathbf{x}_0) + \\nabla T \\cdot \\Delta \\mathbf{x}_i$ 变为等式，只要 $\\mathbf{A}^{\\top}\\mathbf{W}\\mathbf{A}$ 可逆（即邻点不共线），最小二乘法将恢复精确梯度。\n\n**2. 梯度矢量的协变变换**\n我们从第一性原理推导梯度的变换规则。刚体运动将点 $\\mathbf{x}$ 映射到 $\\mathbf{x}' = \\mathbf{R}\\mathbf{x} + \\mathbf{t}$。从变换后坐标回到原始坐标的逆映射为 $\\mathbf{x}(\\mathbf{x}') = \\mathbf{R}^{-1}(\\mathbf{x}' - \\mathbf{t})$。由于旋转矩阵 $\\mathbf{R}$ 是正交的，所以 $\\mathbf{R}^{-1} = \\mathbf{R}^{\\top}$，因此：\n$$\n\\mathbf{x}(\\mathbf{x}') = \\mathbf{R}^{\\top}(\\mathbf{x}' - \\mathbf{t})\n$$\n标量温度场是物理不变量，因此其在某一个物理点的值与描述该点的坐标系无关。因此，变换后的场定义为 $T'(\\mathbf{x}') = T(\\mathbf{x}(\\mathbf{x}'))$。\n\n我们求解 $T'$ 相对于新坐标 $\\mathbf{x}' = (x', y')$ 的梯度。我们使用多变量链式法则。梯度 $\\nabla' T' = (\\frac{\\partial T'}{\\partial x'}, \\frac{\\partial T'}{\\partial y'})^{\\top}$ 的分量为：\n$$\n\\frac{\\partial T'}{\\partial x'_k} = \\sum_{j=1}^{2} \\frac{\\partial T}{\\partial x_j} \\frac{\\partial x_j}{\\partial x'_k}\n$$\n这可以用矩阵形式表示。为此推导，我们将梯度向量视为行向量。那么 $(\\nabla' T')_{\\text{row}} = (\\nabla T)_{\\text{row}} \\mathbf{J}$，其中 $\\mathbf{J}$ 是逆映射 $\\mathbf{x}(\\mathbf{x'})$ 的雅可比矩阵：\n$$\n\\mathbf{J} = \\frac{\\partial \\mathbf{x}}{\\partial \\mathbf{x'}} = \\begin{pmatrix} \\frac{\\partial x}{\\partial x'}  \\frac{\\partial x}{\\partial y'} \\\\ \\frac{\\partial y}{\\partial x'}  \\frac{\\partial y}{\\partial y'} \\end{pmatrix}\n$$\n从映射 $\\mathbf{x}(\\mathbf{x}') = \\mathbf{R}^{\\top}\\mathbf{x}' - \\mathbf{R}^{\\top}\\mathbf{t}$ 可知，雅可比矩阵就是 $\\mathbf{x}'$ 的常数矩阵系数，即 $\\mathbf{R}^{\\top}$。\n$$\n\\mathbf{J} = \\mathbf{R}^{\\top}\n$$\n将此代入链式法则表达式得到 $(\\nabla' T')_{\\text{row}} = (\\nabla T)_{\\text{row}} \\mathbf{R}^{\\top}$。对两边进行转置以回到列向量形式：\n$$\n\\nabla' T' = (\\mathbf{R}^{\\top})^{\\top} (\\nabla T) = \\mathbf{R} (\\nabla T)\n$$\n这就是梯度向量（一阶协变张量）的理论变换定律。新坐标系中的梯度向量是通过将原始梯度向量用相同的旋转矩阵 $\\mathbf{R}$ 进行旋转得到的。平移 $\\mathbf{t}$ 不影响梯度。这就是变换后坐标系中的“期望”梯度。\n\n**3. 验证流程**\n验证算法如下：\n1.  **原始重构**：对于给定的测试用例，计算中心点和邻点的温度 $T_0$ 和 $T_i$。求解加权最小二乘系统 $(\\mathbf{A}^{\\top}\\mathbf{W}\\mathbf{A})\\mathbf{g}_{\\text{orig}} = \\mathbf{A}^{\\top}\\mathbf{W}\\mathbf{b}$ 以找到原始重构梯度 $\\mathbf{g}_{\\text{orig}}$。\n2.  **变换后重构**：\n    a. 对所有点应用刚体运动：$\\mathbf{x}'_0 = \\mathbf{R}\\mathbf{x}_0 + \\mathbf{t}$ 和 $\\mathbf{x}'_i = \\mathbf{R}\\mathbf{x}_i + \\mathbf{t}$。\n    b. 变换后点 $\\mathbf{x}'_i$ 的温度为 $T'(\\mathbf{x}'_i) = T(\\mathbf{x}_i)$。因此，对应点的温度值保持不变。\n    c. 为变换后的几何求解一个新的加权最小二乘系统 $(\\mathbf{A}'^{\\top}\\mathbf{W}'\\mathbf{A}')\\mathbf{g}'_{\\text{recon}} = \\mathbf{A}'^{\\top}\\mathbf{W}'\\mathbf{b}'$，以找到新坐标系中的重构梯度 $\\mathbf{g}'_{\\text{recon}}$。\n3.  **期望梯度**：使用导出的协变定律计算期望的变换后梯度：$\\mathbf{g}'_{\\text{exp}} = \\mathbf{R} \\mathbf{g}_{\\text{orig}}$。\n4.  **差异**：计算重构的变换后梯度与期望的变换后梯度之间差值的欧几里得范数：$d = \\| \\mathbf{g}'_{\\text{recon}} - \\mathbf{g}'_{\\text{exp}} \\|_2$。\n\n因为所选权重 $w_i = 1/\\|\\Delta\\mathbf{x}_i\\|^2$ 是基于距离的，而距离在刚体运动下是不变的（$w'_i = w_i$），所以该数值方案本身是完全协变的。如思考过程中所示，可以解析地证明 $\\mathbf{g}'_{\\text{recon}} = \\mathbf{R} \\mathbf{g}_{\\text{orig}}$。因此，计算出的差异 $d$ 应该为零，仅受浮点运算精度的限制。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gradient reconstruction covariance problem for all test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"x0\": np.array([0.3, -0.4]),\n            \"neighbors\": np.array([\n                [1.1, -0.5], [0.0, -0.1], [0.8, 0.7], \n                [-0.6, -0.9], [0.4, -1.2], [1.5, 0.2]\n            ]),\n            \"field_coeffs\": (2.5, -1.0, 350.0), # alpha, beta, gamma\n            \"theta\": 0.7,\n            \"t\": np.array([0.5, -1.0]),\n        },\n        {\n            \"x0\": np.array([0.3, -0.4]),\n            \"neighbors\": np.array([\n                [1.1, -0.5], [0.0, -0.1], [0.8, 0.7], \n                [-0.6, -0.9], [0.4, -1.2], [1.5, 0.2]\n            ]),\n            \"field_coeffs\": (2.5, -1.0, 350.0),\n            \"theta\": 0.0,\n            \"t\": np.array([-3.0, 4.0]),\n        },\n        {\n            \"x0\": np.array([-0.2, 0.1]),\n            \"neighbors\": np.array([\n                [0.5, 0.6], [-0.1, -0.8], [-0.7, 0.3], \n                [0.9, -0.4], [-0.5, 1.0]\n            ]),\n            \"field_coeffs\": (1.2, 3.4, 280.0),\n            \"theta\": np.pi,\n            \"t\": np.array([0.0, 0.0]),\n        },\n        {\n            \"x0\": np.array([0.0, 0.0]),\n            \"neighbors\": np.array([\n                [-1.0, 0.001], [-0.5, -0.002], [0.3, 0.0005], \n                [0.8, -0.0015], [1.2, 0.002]\n            ]),\n            \"field_coeffs\": (-0.8, 0.6, 310.0),\n            \"theta\": np.pi / 2,\n            \"t\": np.array([0.2, -0.3]),\n        }\n    ]\n\n    results = []\n\n    def reconstruct_gradient(center_point, neighbor_points, center_temp, neighbor_temps):\n        \"\"\"\n        Implements weighted least-squares gradient reconstruction.\n        \n        Args:\n            center_point (np.ndarray): 1D array of shape (2,) for the center point coords.\n            neighbor_points (np.ndarray): 2D array of shape (N, 2) for neighbor coords.\n            center_temp (float): Temperature at the center point.\n            neighbor_temps (np.ndarray): 1D array of shape (N,) for neighbor temperatures.\n            \n        Returns:\n            np.ndarray: The reconstructed gradient vector of shape (2,).\n        \"\"\"\n        delta_x = neighbor_points - center_point\n        delta_T = neighbor_temps - center_temp\n        \n        # Weights proportional to 1/distance^2\n        # Add a small epsilon to avoid division by zero if a neighbor is at the center\n        distances_sq = np.sum(delta_x**2, axis=1)\n        weights = 1.0 / (distances_sq + 1e-15)\n        \n        W = np.diag(weights)\n        A = delta_x\n        b = delta_T\n        \n        # Normal equations: (A^T W A) g = A^T W b\n        A_T_W_A = A.T @ W @ A\n        A_T_W_b = A.T @ W @ b\n        \n        gradient = np.linalg.solve(A_T_W_A, A_T_W_b)\n        return gradient\n\n    for case in test_cases:\n        x0 = case[\"x0\"]\n        neighbors = case[\"neighbors\"]\n        alpha, beta, gamma = case[\"field_coeffs\"]\n        theta = case[\"theta\"]\n        t = case[\"t\"]\n        \n        # Define the linear temperature field\n        temp_field = lambda p: alpha * p[..., 0] + beta * p[..., 1] + gamma\n\n        # --- 1. Original Gradient Reconstruction ---\n        T0 = temp_field(x0)\n        Ti = temp_field(neighbors)\n        grad_orig = reconstruct_gradient(x0, neighbors, T0, Ti)\n        \n        # --- 2. Transformed Gradient Reconstruction ---\n        # Rotation matrix\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, -s], [s, c]])\n        \n        # Apply rigid motion to mesh points\n        x0_prime = R @ x0 + t\n        neighbors_prime = (R @ neighbors.T).T + t\n        \n        # Per problem statement T'(x') = T(R^T(x'-t)), so T'(x_i') = T(x_i).\n        # Temperature values at corresponding points are identical.\n        T0_prime = T0\n        Ti_prime = Ti\n        \n        grad_prime_recon = reconstruct_gradient(x0_prime, neighbors_prime, T0_prime, Ti_prime)\n        \n        # --- 3. Expected Transformed Gradient ---\n        # Apply covariance transformation law: grad' = R * grad\n        grad_prime_expected = R @ grad_orig\n        \n        # --- 4. Compute Discrepancy ---\n        discrepancy = np.linalg.norm(grad_prime_recon - grad_prime_expected)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际的计算工程应用中，没有任何一种单一的梯度重构方法能在所有情况下都表现完美。因此，最后的这个综合性实践  旨在指导你构建一个先进且实用的混合算法。该算法能够根据局部网格质量（如边界邻近度、非正交性和数值条件数）在稳健的Green-Gauss方法和高精度的最小二乘方法之间进行动态切换。完成这个练习需要你综合运用对两种方法优缺点的深刻理解，其设计思想代表了当前最先进的计算工程软件中使用的技术。",
            "id": "3958323",
            "problem": "您的任务是在有限体积法 (FVM) 框架内，为二维非结构网格设计并实现一种动态梯度重构算法。该算法必须根据局部几何和数值质量，在两种重构方法之间切换：Green–Gauss (GG) 和加权最小二乘 (WLS)。目标是在给定单元的中心重构标量场（在此解释为温度）的梯度，并确保在边界附近和高度倾斜的区域具有鲁棒性。重构出的梯度必须与解析参考解进行比对评估，且算法的方法选择必须有明确、可量化的标准作为依据。\n\n从以下基本原理开始：\n- 高斯散度定理指出，对于一个足够光滑的标量场 $\\,\\phi(\\boldsymbol{x})\\,$，在面积为 $\\,A\\,$ 的多边形单元上，单元平均梯度满足\n$$\n\\int_{\\Omega} \\nabla \\phi \\, \\mathrm{d}\\Omega = \\int_{\\partial \\Omega} \\phi \\, \\boldsymbol{n} \\, \\mathrm{d}S,\n$$\n其中 $\\,\\boldsymbol{n}\\,$ 表示外向单位法向量，$\\,\\partial \\Omega\\,$ 是单元边界。\n- 围绕单元中心 $\\,\\boldsymbol{x}_P\\,$ 的线性场 $\\,\\phi(\\boldsymbol{x})\\approx \\phi_P + \\boldsymbol{g}\\cdot(\\boldsymbol{x}-\\boldsymbol{x}_P)\\,$ 的加权最小二乘 (WLS) 拟合，可以通过最小化以下函数获得\n$$\nJ(\\boldsymbol{g}) = \\sum_j w_j \\left[ \\phi_j - \\phi_P - \\boldsymbol{g}\\cdot(\\boldsymbol{x}_j-\\boldsymbol{x}_P) \\right]^2,\n$$\n其中权重为正 $\\,w_j>0\\,$，由此导出正规方程\n$$\n\\left( \\boldsymbol{A}^\\top \\boldsymbol{W}\\boldsymbol{A} \\right)\\boldsymbol{g} = \\boldsymbol{A}^\\top \\boldsymbol{W}\\boldsymbol{b},\n$$\n其中 $\\,\\boldsymbol{A}\\,$ 的行是 $\\,(\\boldsymbol{x}_j-\\boldsymbol{x}_P)^\\top\\,$，$\\,\\boldsymbol{b}\\,$ 的元素是 $\\,\\phi_j - \\phi_P\\,$，$\\,\\boldsymbol{W}\\,$ 是对角矩阵，其对角元为 $\\,w_j\\,$。\n\n基于以下标准，设计一个鲁棒的方法选择器：\n1. 边界邻近性：如果任何一个面是边界（狄利克雷条件），则优先选用 WLS，因为 Green–Gauss 方法在边界处可能会因有偏的面值而产生误差。\n2. 非正交性：将一个面上的非正交性定义为面法向量 $\\,\\boldsymbol{n}_f\\,$ 与某个特征向量 $\\,\\boldsymbol{d}_f\\,$ 之间的夹角（以度为单位）。对于内部面，该向量是中心到中心的向量；对于边界，则是单元中心到面中心的向量。该角度为\n$$\n\\theta_f = \\arccos\\left( \\frac{|\\boldsymbol{d}_f\\cdot \\boldsymbol{n}_f|}{\\|\\boldsymbol{d}_f\\|} \\right)\\times \\frac{180}{\\pi}.\n$$\n令 $\\,\\theta_{\\max}\\,$ 为所有面中的最大角度。如果 $\\,\\theta_{\\max} > \\Theta^\\star\\,$，则优先选用 WLS。使用 $\\,\\Theta^\\star = 60\\,$ 度。\n3. 数值条件：如果优先选择 WLS，则计算 $\\,\\boldsymbol{A}^\\top \\boldsymbol{W}\\boldsymbol{A}\\,$ 的条件数 $\\,\\kappa\\,$ 及其秩。如果 $\\,\\kappa>\\kappa_{\\max}\\,$ 或秩小于 $2$，则退回至 GG 方法。使用 $\\,\\kappa_{\\max}=10^6\\,$。\n\n实现以下内容：\n- Green–Gauss 梯度：对于一个面积为 $\\,A\\,$、边（面）长为 $\\,L_f\\,$、外向单位法向量为 $\\,\\boldsymbol{n}_f\\,$、中点为 $\\,\\boldsymbol{x}_f\\,$ 的多边形单元，梯度近似为\n$$\n\\nabla \\phi_P \\approx \\frac{1}{A} \\sum_{f} \\phi_f \\, \\boldsymbol{n}_f \\, L_f,\n$$\n其中 $\\,\\phi_f\\,$ 对于内部面等于相邻两个单元值的算术平均值，对于边界面则等于 $\\,\\boldsymbol{x}_f\\,$ 处的狄利克雷边界值。\n- 加权最小二乘梯度：仅使用内部邻居中心 $\\,\\boldsymbol{x}_j\\,$ 求解正规方程以得到 $\\,\\boldsymbol{g}\\,$，权重为 $\\,w_j = 1/\\|\\boldsymbol{x}_j-\\boldsymbol{x}_P\\|\\,$。如果根据上述标准，该系统是秩亏的或病态的，则退回至 GG 方法。\n\n解析温度场和单位：\n- 设解析温度场为\n$$\nT(x,y) = 300 + 10x + 5y + 0.5\\,x\\,y,\n$$\n其中 $\\,T\\,$ 的单位为开尔文 (K)，$\\,x,y\\,$ 的单位为米 (m)。精确梯度为\n$$\n\\nabla T(x,y) = \\left(10 + 0.5y,\\; 5 + 0.5x \\right) \\quad \\text{单位 K/m}.\n$$\n所有计算出的梯度误差必须以开尔文每米 (K/m) 报告。角度必须以度为单位处理。\n\n测试套件：\n对于每个测试用例，一个目标单元由其顶点（按逆时针顺序）和每个面的邻居元数据（是否为边界，如果是内部面，则提供邻居中心）定义。程序必须评估所选方法以及在单元中心的绝对梯度误差大小（欧几里得范数）。算法必须根据上述标准动态选择重构方法。\n\n- 测试用例 1（内部形状规整的正方形，无边界）：\n    - 顶点：$(1,1)$, $(2,1)$, $(2,2)$, $(1,2)$。\n    - 各面邻居（面 0 到 3 按顶点顺序）：内部邻居，中心分别在 $(1.5,0.5)$, $(2.5,1.5)$, $(1.5,2.5)$, $(0.5,1.5)$。\n- 测试用例 2（边界角落的正方形）：\n    - 顶点：$(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$。\n    - 各面邻居：面 0 为边界，面 1 为内部，邻居中心在 $(1.5,0.5)$，面 2 为内部，邻居中心在 $(0.5,1.5)$，面 3 为边界。\n- 测试用例 3（高度倾斜的四边形，仅有内部邻居）：\n    - 顶点：$(2.0,1.0)$, $(3.0,1.1)$, $(2.8,2.2)$, $(2.0,2.0)$。\n    - 各面邻居：内部邻居中心分别在 $(3.3,0.4)$, $(3.6,1.8)$, $(1.9,2.8)$, $(1.4,1.4)$。\n- 测试用例 4（边界单元，内部邻居不足以用于 WLS）：\n    - 顶点：$(3,0)$, $(4,0)$, $(4,1)$, $(3,1)$。\n    - 各面邻居：面 0, 1, 2 为边界，面 3 为内部，邻居中心在 $(2.5,0.5)$。\n\n选择阈值：\n- 非正交性阈值：$\\,\\Theta^\\star = 60\\,$ 度。\n- 最大可接受条件数：$\\,\\kappa_{\\max} = 10^6\\,$。\n\n输出规范：\n- 对每个测试用例，输出一个包含两个条目的列表：所选方法的代码和绝对梯度误差的大小。Green–Gauss (GG) 方法代码为 $\\,0\\,$，加权最小二乘 (WLS) 方法代码为 $\\,1\\,$。\n- 程序的最终输出必须是单行文本，包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表。每个结果必须是一个双元素列表，不含空格，形式为 $\\,\\left[\\text{method\\_code},\\text{error}\\right]\\,$。例如：\n$$\n[\\,[0,0.001234],[1,0.000567],\\ldots\\,]\n$$\n- 所有梯度误差必须以浮点数形式表示，单位为 $\\,\\text{K/m}\\,$。输出必须只包含数值（不含单位字符串），每个误差值四舍五入到六位小数。\n\n角度单位要求：\n- 所有用于非正交性评估的角度都必须以度为单位处理。\n\n您的程序必须实现这种动态选择算法，为指定的测试套件计算重构梯度，将其与精确的解析梯度进行比较，并生成所需的输出行。",
            "solution": "问题陈述经评估有效。它在科学上基于有限体积法 (FVM) 的原理，在数学上是适定的，并为一项计算工程任务提供了一套完整、明确的要求和数据。因此，可以构建一个解决方案。\n\n核心任务是为二维非结构网格实现一种动态梯度重构算法。该算法必须根据局部单元的几何形状和数值稳定性，在 Green-Gauss (GG) 和加权最小二乘 (WLS) 方法之间进行选择。解决方案分几个阶段进行：几何预处理、应用选择逻辑、使用所选方法计算梯度，以及将结果误差与精确的解析解进行评估。\n\n### 几何预处理\n对于由一组按逆时针顺序排列的顶点 $\\{\\boldsymbol{v}_0, \\boldsymbol{v}_1, \\ldots, \\boldsymbol{v}_{N-1}\\}$ 定义的每个多边形单元，几个几何属性是基础。\n\n单元的面积 $A$ 使用鞋带公式计算：\n$$ A = \\frac{1}{2} \\left| \\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i) \\right| $$\n其中 $\\boldsymbol{v}_i = (x_i, y_i)$，索引对 $N$ 取模。\n\n单元中心 $\\boldsymbol{x}_P = (C_x, C_y)$ 使用简单多边形的精确公式计算：\n$$ C_x = \\frac{1}{6A} \\sum_{i=0}^{N-1} (x_i + x_{i+1})(x_i y_{i+1} - x_{i+1} y_i) $$\n$$ C_y = \\frac{1}{6A} \\sum_{i=0}^{N-1} (y_i + y_{i+1})(x_i y_{i+1} - x_{i+1} y_i) $$\n\n连接顶点 $\\boldsymbol{v}_i$ 和 $\\boldsymbol{v}_{i+1}$ 的多边形每条边构成一个面 $f$。对每个面，我们计算：\n- 面长 $L_f = \\| \\boldsymbol{v}_{i+1} - \\boldsymbol{v}_i \\|$。\n- 面中点（中心）$\\boldsymbol{x}_f = \\frac{1}{2}(\\boldsymbol{v}_i + \\boldsymbol{v}_{i+1})$。\n- 外向单位法向量 $\\boldsymbol{n}_f$。对于顶点 $(x_i, y_i)$ 和 $(x_{i+1}, y_{i+1})$，未缩放的法向量为 $(y_{i+1}-y_i, -(x_{i+1}-x_i))$，然后将其归一化为单位长度。\n\n### 动态方法选择算法\n实现一个分层决策过程，为每个单元选择最合适的梯度重构方法。\n\n1.  **边界邻近性：** 第一个标准是是否存在边界面。如果单元的任何一个面是边界面，则优先选择 WLS 方法。这是因为 GG 方法依赖于面值，对于内部面，该值可以从相邻单元中心插值得到。在边界处，这是不可能的，直接使用边界值可能会引入偏差，尤其对于非正交网格。而 WLS 方法仅使用内部邻居构建，在这种情况下可以提供更鲁棒的梯度估计。\n\n2.  **非正交性：** 如果单元没有边界面，则通过每个面 $f$ 上的非正交性角 $\\theta_f$ 来评估其几何质量。这个角度衡量了连接单元中心的向量 $\\boldsymbol{d}_f$ 与面法向量 $\\boldsymbol{n}_f$ 之间的偏差。其定义为：\n    $$ \\theta_f = \\arccos\\left( \\frac{|\\boldsymbol{d}_f\\cdot \\boldsymbol{n}_f|}{\\|\\boldsymbol{d}_f\\|} \\right)\\times \\frac{180}{\\pi} $$\n    对于内部面，$\\boldsymbol{d}_f = \\boldsymbol{x}_N - \\boldsymbol{x}_P$，其中 $\\boldsymbol{x}_N$ 是邻居单元的中心。对于边界面，$\\boldsymbol{d}_f = \\boldsymbol{x}_f - \\boldsymbol{x}_P$。如果所有面上的最大非正交性 $\\theta_{\\max}$ 超过阈值 $\\Theta^\\star = 60^\\circ$，则认为网格高度倾斜，优先选择 WLS 以减轻 GG 方法在这种情况下可能产生的巨大误差。\n\n3.  **数值条件：** 如果根据上述标准优先选择 WLS，则对其数值稳定性进行最终检查。WLS 方法需要求解一个线性系统。一个适定的系统需要足够数量的线性无关约束。对于二维梯度，至少需要两个不共线的邻居中心。这通过以下方式进行正式检查：\n    - **秩：** 系统矩阵 $\\boldsymbol{M} = \\boldsymbol{A}^\\top \\boldsymbol{W}\\boldsymbol{A}$ 的秩必须为 $2$。如果内部邻居的数量少于 $2$，或者它们相对于单元中心 $\\boldsymbol{x}_P$ 是共线的，则秩将小于 $2$。\n    - **条件数：** 条件数 $\\kappa(\\boldsymbol{M})$ 衡量了解对输入扰动的敏感度。非常高的条件数表示系统是病态的。\n    如果秩小于 $2$ 或者 $\\kappa(\\boldsymbol{M})$ 超过阈值 $\\kappa_{\\max}=10^6$，则认为 WLS 方法不可靠。在这种情况下，算法必须退回至更鲁棒但可能精度较低的 GG 方法。\n\n如果两个主要标准（边界邻近性、非正交性）都没有指示优先选择 WLS，则默认使用 GG 方法。\n\n### 梯度重构方法\n标量场是解析温度函数 $\\phi(x,y) = T(x,y) = 300 + 10x + 5y + 0.5xy$。\n\n**Green-Gauss (GG) 梯度**\nGG 方法使用高斯散度定理的离散形式来近似单元平均梯度：\n$$ \\nabla \\phi_P \\approx \\frac{1}{A} \\sum_{f} \\phi_f \\boldsymbol{n}_f L_f $$\n面上标量场的值 $\\phi_f$ 近似为：\n- 对于内部面，它是两个相邻单元中心值的算术平均值：$\\phi_f = \\frac{1}{2} (\\phi_P + \\phi_N)$，其中 $\\phi_P = T(\\boldsymbol{x}_P)$ 且 $\\phi_N = T(\\boldsymbol{x}_N)$。\n- 对于边界面，它是面中点处的精确值：$\\phi_f = T(\\boldsymbol{x}_f)$。\n\n**加权最小二乘 (WLS) 梯度**\nWLS 方法寻找一个梯度向量 $\\boldsymbol{g} = (g_x, g_y)^\\top$，使得在内部邻居集合 $j$ 上的加权残差平方和最小化：\n$$ J(\\boldsymbol{g}) = \\sum_j w_j \\left[ (\\phi_j - \\phi_P) - \\boldsymbol{g} \\cdot (\\boldsymbol{x}_j - \\boldsymbol{x}_P) \\right]^2 $$\n权重选择为与单元中心到邻居中心的距离成反比，$w_j = 1/\\|\\boldsymbol{x}_j - \\boldsymbol{x}_P\\|$。这种最小化导出了正规方程：\n$$ \\left( \\boldsymbol{A}^\\top \\boldsymbol{W}\\boldsymbol{A} \\right)\\boldsymbol{g} = \\boldsymbol{A}^\\top \\boldsymbol{W}\\boldsymbol{b} $$\n这里，$\\boldsymbol{A}$ 是行向量为位移向量 $(\\boldsymbol{x}_j-\\boldsymbol{x}_P)^\\top$ 的矩阵，$\\boldsymbol{W}$ 是权重 $w_j$ 的对角矩阵，$\\boldsymbol{b}$ 是标量差值 $\\phi_j - \\phi_P$ 的向量。求解这个 $2 \\times 2$ 系统以得到梯度向量 $\\boldsymbol{g}$。\n\n### 误差评估\n对于每个测试用例，将重构的梯度 $\\boldsymbol{g}_{recon}$ 与在单元中心 $\\boldsymbol{x}_P$ 处计算的精确解析梯度进行比较：\n$$ \\nabla T(x_P, y_P) = (10 + 0.5y_P, 5 + 0.5x_P) $$\n绝对误差大小计算为差向量的欧几里得范数：\n$$ \\text{Error} = \\| \\boldsymbol{g}_{recon} - \\nabla T(\\boldsymbol{x}_P) \\| $$\n每个测试用例的最终输出包括一个方法代码（GG 为 $0$，WLS 为 $1$）和这个计算出的误差，四舍五入到六位小数。",
            "answer": "```python\nimport numpy as np\n\n# --- Problem Constants and Analytic Functions ---\n\nTHETA_STAR = 60.0  # degrees\nKAPPA_MAX = 1e6\n\ndef analytic_T(x, y):\n    \"\"\"Analytic temperature field T(x,y) in Kelvin.\"\"\"\n    return 300.0 + 10.0 * x + 5.0 * y + 0.5 * x * y\n\ndef analytic_grad_T(x, y):\n    \"\"\"Exact gradient of the temperature field in K/m.\"\"\"\n    return np.array([10.0 + 0.5 * y, 5.0 + 0.5 * x])\n\n# --- Geometric Utility Functions ---\n\ndef get_polygon_properties(vertices):\n    \"\"\"\n    Calculates the area and centroid of a simple polygon.\n    Assumes vertices are given in counter-clockwise order.\n    \"\"\"\n    verts_shifted = np.roll(vertices, -1, axis=0)\n    cross_prod_terms = vertices[:, 0] * verts_shifted[:, 1] - verts_shifted[:, 0] * vertices[:, 1]\n    \n    area = 0.5 * np.sum(cross_prod_terms)\n    \n    cx_terms = (vertices[:, 0] + verts_shifted[:, 0]) * cross_prod_terms\n    cy_terms = (vertices[:, 1] + verts_shifted[:, 1]) * cross_prod_terms\n    \n    centroid_x = (1.0 / (6.0 * area)) * np.sum(cx_terms)\n    centroid_y = (1.0 / (6.0 * area)) * np.sum(cy_terms)\n    \n    return area, np.array([centroid_x, centroid_y])\n\ndef get_face_properties(vertices):\n    \"\"\"\n    Calculates properties for each face of the polygon.\n    Returns a list of dictionaries, one for each face.\n    \"\"\"\n    num_verts = len(vertices)\n    faces = []\n    for i in range(num_verts):\n        p1 = vertices[i]\n        p2 = vertices[(i + 1) % num_verts]\n        \n        face_vec = p2 - p1\n        length = np.linalg.norm(face_vec)\n        midpoint = 0.5 * (p1 + p2)\n        \n        # Outward normal for CCW vertices\n        normal = np.array([face_vec[1], -face_vec[0]]) / length\n        faces.append({'length': length, 'midpoint': midpoint, 'normal': normal})\n    return faces\n\n# --- Gradient Reconstruction Methods ---\n\ndef calculate_gg_gradient(cell_centroid, cell_area, faces, neighbor_data):\n    \"\"\"Computes the gradient using the Green-Gauss method.\"\"\"\n    grad_sum = np.zeros(2)\n    phi_P = analytic_T(cell_centroid[0], cell_centroid[1])\n    \n    for i, face in enumerate(faces):\n        neighbor = neighbor_data[i]\n        if neighbor['type'] == 'internal':\n            phi_N = analytic_T(neighbor['centroid'][0], neighbor['centroid'][1])\n            phi_f = 0.5 * (phi_P + phi_N)\n        else: # boundary\n            phi_f = analytic_T(face['midpoint'][0], face['midpoint'][1])\n        \n        grad_sum += phi_f * face['normal'] * face['length']\n        \n    return grad_sum / cell_area\n\ndef solve():\n    \"\"\"Main solver function to process all test cases.\"\"\"\n    \n    # Test cases defined as (vertices, neighbor_metadata)\n    test_cases = [\n        # Case 1: Interior well-shaped square\n        (\n            np.array([[1, 1], [2, 1], [2, 2], [1, 2]], dtype=float),\n            [\n                {'type': 'internal', 'centroid': np.array([1.5, 0.5])},\n                {'type': 'internal', 'centroid': np.array([2.5, 1.5])},\n                {'type': 'internal', 'centroid': np.array([1.5, 2.5])},\n                {'type': 'internal', 'centroid': np.array([0.5, 1.5])},\n            ]\n        ),\n        # Case 2: Boundary corner square\n        (\n            np.array([[0, 0], [1, 0], [1, 1], [0, 1]], dtype=float),\n            [\n                {'type': 'boundary', 'centroid': None},\n                {'type': 'internal', 'centroid': np.array([1.5, 0.5])},\n                {'type': 'internal', 'centroid': np.array([0.5, 1.5])},\n                {'type': 'boundary', 'centroid': None},\n            ]\n        ),\n        # Case 3: Highly skewed quadrilateral, internal\n        (\n            np.array([[2.0, 1.0], [3.0, 1.1], [2.8, 2.2], [2.0, 2.0]], dtype=float),\n            [\n                {'type': 'internal', 'centroid': np.array([3.3, 0.4])},\n                {'type': 'internal', 'centroid': np.array([3.6, 1.8])},\n                {'type': 'internal', 'centroid': np.array([1.9, 2.8])},\n                {'type': 'internal', 'centroid': np.array([1.4, 1.4])},\n            ]\n        ),\n        # Case 4: Boundary cell with insufficient neighbors for WLS\n        (\n            np.array([[3, 0], [4, 0], [4, 1], [3, 1]], dtype=float),\n            [\n                {'type': 'boundary', 'centroid': None},\n                {'type': 'boundary', 'centroid': None},\n                {'type': 'boundary', 'centroid': None},\n                {'type': 'internal', 'centroid': np.array([2.5, 0.5])},\n            ]\n        )\n    ]\n    \n    results = []\n\n    for vertices, neighbor_data in test_cases:\n        # --- 1. Geometric Pre-processing ---\n        area, centroid = get_polygon_properties(vertices)\n        faces = get_face_properties(vertices)\n        phi_P = analytic_T(centroid[0], centroid[1])\n\n        # --- 2. Dynamic Method Selection ---\n        has_boundary = any(n['type'] == 'boundary' for n in neighbor_data)\n        prefer_wls = has_boundary\n        \n        if not prefer_wls:\n            max_theta = 0.0\n            for i, face in enumerate(faces):\n                neighbor = neighbor_data[i]\n                if neighbor['type'] == 'internal':\n                    d_f = neighbor['centroid'] - centroid\n                else: # Boundary\n                    d_f = face['midpoint'] - centroid\n                \n                cos_theta = np.abs(np.dot(d_f, face['normal'])) / np.linalg.norm(d_f)\n                # Clip to avoid domain errors with arccos\n                cos_theta = np.clip(cos_theta, 0.0, 1.0)\n                theta_deg = np.degrees(np.arccos(cos_theta))\n                if theta_deg > max_theta:\n                    max_theta = theta_deg\n            \n            if max_theta > THETA_STAR:\n                prefer_wls = True\n        \n        # --- 3. Gradient Calculation ---\n        grad = None\n        method_code = 0  # Default to GG (0)\n\n        if prefer_wls:\n            internal_neighbors = [n['centroid'] for n in neighbor_data if n['type'] == 'internal']\n            \n            if len(internal_neighbors)  2:\n                # Revert to GG, not enough neighbors for WLS\n                pass\n            else:\n                # Attempt WLS\n                num_neighbors = len(internal_neighbors)\n                A = np.zeros((num_neighbors, 2))\n                b = np.zeros(num_neighbors)\n                w = np.zeros(num_neighbors)\n\n                for i, neighbor_centroid in enumerate(internal_neighbors):\n                    delta_x = neighbor_centroid - centroid\n                    A[i, :] = delta_x\n                    dist = np.linalg.norm(delta_x)\n                    w[i] = 1.0 / dist if dist > 1e-9 else 1e9\n                    phi_N = analytic_T(neighbor_centroid[0], neighbor_centroid[1])\n                    b[i] = phi_N - phi_P\n                \n                W = np.diag(w)\n                M = A.T @ W @ A\n                \n                rank = np.linalg.matrix_rank(M)\n                if rank  2:\n                    # Revert to GG, rank deficient\n                    pass\n                else:\n                    cond = np.linalg.cond(M)\n                    if cond > KAPPA_MAX:\n                        # Revert to GG, ill-conditioned\n                        pass\n                    else:\n                        # WLS is valid\n                        rhs = A.T @ W @ b\n                        grad = np.linalg.solve(M, rhs)\n                        method_code = 1\n        \n        # Fallback to GG if WLS was not selected or failed\n        if grad is None:\n            grad = calculate_gg_gradient(centroid, area, faces, neighbor_data)\n            method_code = 0\n            \n        # --- 4. Error Evaluation ---\n        exact_grad = analytic_grad_T(centroid[0], centroid[1])\n        error = np.linalg.norm(grad - exact_grad)\n        \n        results.append(f\"[{method_code},{error:.6f}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}