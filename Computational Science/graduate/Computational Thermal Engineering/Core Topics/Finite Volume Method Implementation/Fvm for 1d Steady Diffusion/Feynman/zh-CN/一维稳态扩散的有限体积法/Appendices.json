{
    "hands_on_practices": [
        {
            "introduction": "本节的实践练习旨在训练有限体积法的一项核心技能：扩散项的离散化。我们将从抽象的控制方程出发，推导出其具体的代数形式。这项练习要求你从能量守恒基本原理和傅里叶定律出发，为一个横截面积随空间变化的一维翅片推导离散扩散导纳。掌握这一推导过程对于理解有限体积法如何处理空间变化的物性和复杂几何形状至关重要。",
            "id": "3956044",
            "problem": "考虑沿一个锥形翅片的一维稳态热传导，其横截面积随空间变化，由 $A(x) = A_0 \\left(1 + \\alpha x\\right)$ 描述，其中 $A_0 > 0$ 且 $\\alpha$ 为一常数，使得在整个翅片上 $1 + \\alpha x > 0$。热导率 $k$ 是恒定的。设一个非均匀单元中心网格由相邻节点位置 $x_W, x_P, x_E$ 定义，其控制体表面位于 $x_w = \\frac{x_W + x_P}{2}$ 和 $x_e = \\frac{x_P + x_E}{2}$。使用有限体积法 (FVM)，从局部能量守恒原理和 Fourier 热传导定律出发。在与节点 $x_P$ 相关联的控制体 $\\left[x_w, x_e\\right]$ 上，推导离散扩散传导系数 $D_w$ 和 $D_e$，它们在非均匀网格上的标准两点通量近似中分别乘以西侧和东侧相邻节点的温差。假设相邻单元中心之间的温度是线性重构的，并在控制体表面上计算横截面积。以 $k$、$A_0$、$\\alpha$、$x_W$、$x_P$ 和 $x_E$ 的闭合形式给出 $D_w$ 和 $D_e$ 的最终表达式。根据你的推导，简要解释 $A(x)$ 的变化如何影响表面上的局部扩散通量。\n\n将最终答案表示为包含 $D_w$ 和 $D_e$ 的行矩阵。无需四舍五入。",
            "solution": "该问题是有效的。这是一个计算传热学中的标准、适定问题，基于能量守恒和 Fourier 定律的基本原理，并为唯一的推导提供了所有必要信息。\n\n推导始于一维稳态热传导的局部能量守恒原理。对于中心节点 $P$ 周围由区域 $[x_w, x_e]$ 定义的控制体 (CV)，在没有热源或热汇的情况下，能量守恒方程的积分形式为：\n$$ \\int_{x_w}^{x_e} \\frac{d}{dx} \\left( Q_x \\right) dx = 0 $$\n其中 $Q_x$ 是 $x$ 方向的总热率。应用微积分基本定理，该方程简化为控制体表面的热率平衡：\n$$ Q_e - Q_w = 0 $$\n此处，$Q_w$ 和 $Q_e$ 分别是在西侧表面 ($x=x_w$) 和东侧表面 ($x=x_e$) 进入和离开控制体的热率。\n\n根据 Fourier 热传导定律，热率由 $Q_x = -k A(x) \\frac{dT}{dx}$ 给出，其中 $k$ 是热导率，$A(x)$ 是横截面积，$\\frac{dT}{dx}$ 是温度梯度。\n\n有限体积法 (FVM) 需要对控制体表面的热率进行近似。问题要求在相邻单元中心之间使用温度的线性重构，并在控制体表面上计算横截面积。\n\n让我们首先考虑位于 $x_w$ 的西侧表面。该表面位于节点 $W$ 和 $P$ 之间。该表面的温度梯度使用这些节点处的温度 $T_W$ 和 $T_P$ 及其位置 $x_W$ 和 $x_P$ 来近似：\n$$ \\left( \\frac{dT}{dx} \\right)_w \\approx \\frac{T_P - T_W}{x_P - x_W} $$\n西侧表面的横截面积 $A_w$ 在 $x = x_w$ 处计算：\n$$ A_w = A(x_w) $$\n热导率 $k$ 是恒定的。西侧表面的热率于是近似为：\n$$ Q_w = -k A_w \\left( \\frac{dT}{dx} \\right)_w \\approx -k A_w \\frac{T_P - T_W}{x_P - x_W} = \\frac{k A_w}{x_P - x_W} (T_W - T_P) $$\n问题定义了扩散传导系数 $D_w$，使得通量用温差 $(T_P - T_W)$ 来表示。我们可以将 $Q_w$ 的表达式重写为：\n$$ Q_w = \\frac{k A_w}{x_P - x_W} (T_P - T_W) $$\n等等，热通量必须从高温流向低温。如果 $T_W > T_P$，热量从 W 流向 P，所以 $Q_w$ 应该是正的。我的近似是 $-k A_w \\frac{T_P - T_W}{x_P-x_W}$。如果 $T_W > T_P$，$T_P-T_W$ 是负的，所以 $Q_w$ 是正的。这是正确的。标准的 FVM 形式表示从单元到其相邻单元的通量。让我们使用从西侧*进入*单元的通量，即 $Q_w$。两点通量近似通常写为 $D(T_{neighbor} - T_{cell})$。让我们遵循问题的措辞。它要求 $D_w$ 乘以“西侧相邻节点的温差”。这可能有些模棱两可。是 $(T_W - T_P)$ 还是 $(T_P - T_W)$？让我们假设离散化方程的标准形式为 $a_W(T_W - T_P)$，其中 $a_W$ 是系数。\n重新检查我的推导：$Q_w = -k A_w \\frac{T_P - T_W}{x_P - x_W} = \\frac{k A_w}{x_P - x_W} (T_W - T_P)$。这与 $Q_w = a_W(T_W-T_P)$ 的形式一致。\n然而，问题陈述的措辞，“在标准两点通量近似中推导分别乘以西侧和东侧相邻节点温差的离散扩散传导系数 $D_w$ 和 $D_e$”，最常与从单元中心 $P$ 的角度写的通量相关联，例如，$Q_w = D_w (T_P - T_W)$。如果热量流入，这将导致负通量。让我们使用这个约定，因为它在许多教科书中是标准的。\n$$ Q_w = -D_w(T_P - T_W) = D_w(T_W - T_P) \\implies D_w = \\frac{k A_w}{x_P - x_W} $$\n\n类似地，对于位于节点 $P$ 和 $E$ 之间的东侧表面 $x_e$，温度梯度为：\n$$ \\left( \\frac{dT}{dx} \\right)_e \\approx \\frac{T_E - T_P}{x_E - x_P} $$\n离开东侧表面的热率为：\n$$ Q_e = -k A_e \\left( \\frac{dT}{dx} \\right)_e \\approx -k A_e \\frac{T_E - T_P}{x_E - x_P} = \\frac{k A_e}{x_E - x_P} (T_P - T_E) $$\n这里，传导系数 $D_e$ 被定义为使得 $Q_e = D_e(T_P - T_E)$。将此与推导出的表达式进行比较，我们得到：\n$$ D_e = \\frac{k A_e}{x_E - x_P} $$\n现在，我们将表面位置和面积函数的给定表达式代入。\n表面位置由下式给出：\n$$ x_w = \\frac{x_W + x_P}{2} $$\n$$ x_e = \\frac{x_P + x_E}{2} $$\n横截面积函数为 $A(x) = A_0 (1 + \\alpha x)$。表面上的面积为：\n$$ A_w = A(x_w) = A_0 \\left(1 + \\alpha x_w\\right) = A_0 \\left(1 + \\alpha \\frac{x_W + x_P}{2}\\right) $$\n$$ A_e = A(x_e) = A_0 \\left(1 + \\alpha x_e\\right) = A_0 \\left(1 + \\alpha \\frac{x_P + x_E}{2}\\right) $$\n将这些代入传导系数 $D_w$ 和 $D_e$ 的表达式中：\n$$ D_w = \\frac{k A_w}{x_P - x_W} = \\frac{k A_0 \\left(1 + \\alpha \\frac{x_W + x_P}{2}\\right)}{x_P - x_W} $$\n$$ D_e = \\frac{k A_e}{x_E - x_P} = \\frac{k A_0 \\left(1 + \\alpha \\frac{x_P + x_E}{2}\\right)}{x_E - x_P} $$\n这些就是离散扩散传导系数的最终表达式。\n\n横截面积 $A(x)$ 的变化通过修改传导系数 $D_w$ 和 $D_e$ 来直接影响局部扩散通量。传导系数与各自表面上的面积 $A_w$ 和 $A_e$ 成正比。对于稳态下通过翅片的恒定热率（$Q_x = \\text{constant}$），Fourier 定律意味着 $A(x) \\frac{dT}{dx}$ 必须是恒定的（因为 $-k$ 是恒定的）。这意味着在面积 $A(x)$ 较大的地方，温度梯度的大小 $|\\frac{dT}{dx}|$ 必须较小，反之亦然。我们推导出的传导系数反映了这一点：$D_w$ 和 $D_e$ 与局部面积成正比。例如，如果翅片是发散的（$\\alpha > 0$），那么 $A_e > A_w$。在均匀网格上（$x_E - x_P = x_P - x_W$），这导致 $D_e > D_w$。能量平衡 $Q_e = Q_w$ 变为 $D_e(T_P - T_E) = D_w(T_W - T_P)$，对于 $D_e > D_w$ 的情况，这意味着 $(T_P - T_E)  (T_W - T_P)$，即单元东半部分的温降小于西半部分的温降，这与随着 $x$ 增加温度梯度减小的情况相符。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{k A_0 \\left(1 + \\alpha \\frac{x_W + x_P}{2}\\right)}{x_P - x_W}  \\frac{k A_0 \\left(1 + \\alpha \\frac{x_P + x_E}{2}\\right)}{x_E - x_P} \\end{pmatrix} } $$"
        },
        {
            "introduction": "在掌握了单个项的离散化之后，本练习将着眼于一个在实际模拟中常见且关键的挑战：如何模拟材料界面上物性的突变。通过一项编程实践，你将比较两种不同方法——算术平均与调和平均——在计算材料界面导热系数时的精度差异。这项研究不仅将从物理和数学上揭示为何调和平均法在处理扩散问题时更具优势，还将展示网格对齐对求解精度的深远影响。",
            "id": "3956059",
            "problem": "考虑具有恒定截面积的一维稳态热扩散问题。其控制守恒方程是傅里叶热传导定律和稳态能量平衡的结合，先应用于控制体，然后应用于整个区域。设空间域为 $[0, L]$，狄利克雷边界温度为 $T(0)=T_0$ 和 $T(L)=T_L$。热导率是分段常数，在 $x=x_i$ 处有一个单一的材料界面，其中对于 $0 \\le x  x_i$，$k=k_1$；对于 $x_i  x \\le L$，$k=k_2$。你将用 Python 编写一个程序，使用 $N$ 个控制体来求解这个问题。\n\n你的程序将通过四个测试用例进行评估，以量化三种数值情景的误差：（1）均匀网格上的算术平均，（2）均匀网格上的调和平均，以及（3）对齐的非均匀网格上的调和平均，其中界面与单元面重合。你必须比较这些方法在中等（$k_1/k_2 = 10$）和高（$k_1/k_2 = 1000$）导热系数对比度下，以及在界面位于不同位置（$x_i = 0.37L$ 和 $x_i = 0.41L$）时的性能。在所有测试用例中，使用 $N=40$ 个单元，边界温度为 $T_0 = 300\\,\\mathrm{K}$ 和 $T_L = 400\\,\\mathrm{K}$。最后，你的程序必须输出一个单行字符串，其中包含十二个由此产生的均方根（RMS）误差，格式为方括号括起来的逗号分隔列表。",
            "solution": "该问题被评估为具有科学依据、良态、客观且完整。它构成了计算传热学中的一个标准验证练习。我们继续进行求解。\n\n### 1. 解析基准解\n\n无热源的一维稳态热扩散方程由下式给出：\n$$\n\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right) = 0\n$$\n其中 $T$ 是温度，$x$ 是空间坐标，$k(x)$ 是热导率。将此方程对 $x$ 积分一次得到：\n$$\nk(x)\\frac{dT}{dx} = C_1\n$$\n其中 $C_1$ 是一个积分常数。项 $-k(x)\\frac{dT}{dx}$ 代表热通量 $q(x)$。因此，热通量 $q = -C_1$ 在整个区域 $[0, L]$ 内是恒定的。这是无源汇稳态能量守恒的直接结果。\n\n于是温度梯度为 $\\frac{dT}{dx} = -\\frac{q}{k(x)}$。我们可以在 $k(x)$ 为常数的两个材料区域上对这个表达式进行积分。\n\n对于第一个区域，$x \\in [0, x_i]$，其中热导率为 $k_1$：\n$$\n\\int_{T(0)}^{T(x)} dT' = \\int_{0}^{x} \\left(-\\frac{q}{k_1}\\right) dx'\n$$\n应用边界条件 $T(0) = T_0$，我们得到：\n$$\nT(x) - T_0 = -\\frac{q}{k_1}x \\implies T(x) = T_0 - \\frac{q}{k_1}x \\quad \\text{for } 0 \\le x \\le x_i\n$$\n\n对于第二个区域，$x \\in [x_i, L]$，其中热导率为 $k_2$：\n$$\n\\int_{T(x_i)}^{T(x)} dT' = \\int_{x_i}^{x} \\left(-\\frac{q}{k_2}\\right) dx'\n$$\n这得到：\n$$\nT(x) - T(x_i) = -\\frac{q}{k_2}(x - x_i) \\implies T(x) = T(x_i) - \\frac{q}{k_2}(x - x_i) \\quad \\text{for } x_i \\le x \\le L\n$$\n这里，$T(x_i)$ 是材料界面处的温度。物理原理要求温度在界面处是连续的，所以 $T(x_i)$ 是从第一个区域的解在 $x=x_i$ 处得到的值：\n$$\nT(x_i) = T_0 - \\frac{q}{k_1}x_i\n$$\n将此代入第二个区域的方程中，得到：\n$$\nT(x) = \\left(T_0 - \\frac{q}{k_1}x_i\\right) - \\frac{q}{k_2}(x - x_i)\n$$\n为了求出恒定的热通量 $q$，我们在 $x=L$ 处应用边界条件，其中 $T(L) = T_L$：\n$$\nT_L = T_0 - q\\left(\\frac{x_i}{k_1} + \\frac{L-x_i}{k_2}\\right)\n$$\n解出 $q$：\n$$\nq = \\frac{T_0 - T_L}{\\frac{x_i}{k_1} + \\frac{L-x_i}{k_2}}\n$$\n分母是复合板单位面积的总热阻。确定了 $q$ 之后，解析温度场就完全定义了。这个分段线性函数将作为评估数值解的精确基准。\n\n### 2. 有限体积法 (FVM) 离散\n\n我们将区域 $[0, L]$ 离散为 $N$ 个连续的控制体（单元）。对于一个中心节点为 $P$、由西侧面 $w$ 和东侧面 $e$ 界定的通用内部单元 $i$，我们在单元体积 $V_i = A \\Delta x_i$ 上对控制方程进行积分：\n$$\n\\int_{x_w}^{x_e} \\frac{d}{dx}\\left(k A \\frac{dT}{dx}\\right) dx = 0\n$$\n应用散度定理（或一维微积分基本定理），这变成单元面通量的平衡：\n$$\n\\left(k A \\frac{dT}{dx}\\right)_e - \\left(k A \\frac{dT}{dx}\\right)_w = 0\n$$\n令 $Q = -kA\\frac{dT}{dx}$ 为总热率。该方程表明，从西侧面进入的热率等于从东侧面离开的热率，即 $Q_w = Q_e$。\n\n使用两点通量近似，界面上的热率通过相邻单元中心的温度来近似。设单元 $i$ 由节点 $P$ 表示，其西侧邻居为 $W$，东侧邻居为 $E$。\n$$\nQ_e = -k_e A \\frac{T_E - T_P}{\\delta x_{PE}} \\quad \\text{和} \\quad Q_w = -k_w A \\frac{T_P - T_W}{\\delta x_{WP}}\n$$\n其中 $k_e$ 和 $k_w$ 分别是对应界面上的热导率，$\\delta x_{PE}$ 和 $\\delta x_{WP}$ 是相邻单元中心之间的距离。单元 $i$ 的守恒方程变为：\n$$\n-k_e A \\frac{T_E - T_P}{\\delta x_{PE}} - \\left(-k_w A \\frac{T_P - T_W}{\\delta x_{WP}}\\right) = 0\n$$\n由于面积 $A$ 是恒定且非零的，它可以被消去。将各项重新整理为标准的 FVM 代数形式 $a_P T_P = a_W T_W + a_E T_E$：\n$$\n\\left(\\frac{k_w}{\\delta x_{WP}} + \\frac{k_e}{\\delta x_{PE}}\\right) T_P = \\left(\\frac{k_w}{\\delta x_{WP}}\\right) T_W + \\left(\\frac{k_e}{\\delta x_{PE}}\\right) T_E\n$$\n系数为：\n$$\na_W = \\frac{k_w}{\\delta x_{WP}}, \\quad a_E = \\frac{k_e}{\\delta x_{PE}}, \\quad a_P = a_W + a_E\n$$\n\n#### 界面热导率平均\n界面热导率 $k_w$ 和 $k_e$ 是通过它们所分隔的单元的热导率插值得到的。设 $k_P$ 和 $k_E$ 是与界面 $e$ 相邻的两个单元的热导率。\n-   **算术平均**: $k_e = \\frac{k_P + k_E}{2}$\n-   **调和平均**: $k_e = \\frac{2k_P k_E}{k_P + k_E}$ 或 $\\frac{1}{k_e} = \\frac{1}{2}\\left(\\frac{1}{k_P} + \\frac{1}{k_E}\\right)$\n\n对于通过层状介质的一维扩散问题，调和平均在物理上更合适，因为它能正确地对串联热阻进行平均。\n\n#### 边界条件\n对于边界单元，其中一个相邻节点是边界。\n对于左边界（$x=0$）处的单元 $0$，西侧“邻居”是边界本身，具有给定的温度 $T_0$。西侧面（边界）的通量是在半单元距离 $\\Delta x_0/2$ 上计算的：\n$$\nQ_w = -k_0 A \\frac{T_0 - T_{BC,0}}{\\Delta x_0/2}\n$$\n其中 $k_0$ 是单元 $0$ 的热导率，$T_{BC,0}$ 是边界温度 $T_0$。单元 $0$ 的代数方程是：\n$$\n\\left(\\frac{2k_0 A}{\\Delta x_0} + a_E\\right) T_0 = a_E T_1 + \\frac{2k_0 A}{\\Delta x_0} T_{BC,0}\n$$\n类似地，对于右边界（$x=L$）处的单元 $N-1$，东侧“邻居”是温度为 $T_L$ 的边界。方程为：\n$$\n\\left(a_W + \\frac{2k_{N-1} A}{\\Delta x_{N-1}}\\right) T_{N-1} = a_W T_{N-2} + \\frac{2k_{N-1} A}{\\Delta x_{N-1}} T_{BC,L}\n$$\n\n这 $N$ 个单元的方程构成了一个三对角线性方程组 $M\\mathbf{T}=\\mathbf{b}$，可以求解得到单元中心温度向量 $\\mathbf{T}$。\n\n### 3. 网格生成与误差分析\n\n**均匀网格**：将区域 $[0, L]$ 划分为 $N$ 个等宽的单元，宽度为 $\\Delta x = L/N$。单元中心位于 $x_c(i) = (i+0.5)\\Delta x$，其中 $i=0, \\dots, N-1$。单元热导率 $k_i$ 根据其中心位置分配：如果 $x_c(i)  x_i$ 则 $k_i = k_1$，如果 $x_c(i) > x_i$ 则 $k_i = k_2$。如果材料界面 $x_i$ 与单元面不重合，这种方法会导致误差，因为数值格式实际上错误地放置了热导率的跳跃点。\n\n**对齐非均匀网格**：为了消除这个误差源，我们构建一个网格，保证一个单元面恰好位于 $x=x_i$。我们将 $N$ 个单元分为两组：$N_{left}$ 个单元用于区域 $[0, x_i]$，$N_{right}$ 个单元用于区域 $[x_i, L]$，使得 $N_{left} + N_{right} = N$。使用按比例分配的方法：$N_{left} = \\text{round}(N \\cdot x_i / L)$ 且 $N_{right} = N - N_{left}$。每个区域内的单元宽度是均匀的：$\\Delta x_{left} = x_i / N_{left}$ 和 $\\Delta x_{right} = (L-x_i) / N_{right}$。在这个网格上，单元 $N_{left}-1$ 和单元 $N_{left}$ 之间的界面位于 $x_i$。在此界面上应用调和平均来计算界面热导率，可以准确地模拟物理过程。\n\n**误差量化**：均方根 (RMS) 误差用于衡量数值解 $T_{num,i}$ 和解析解 $T_{ana,i}$ 在单元中心 $x_c(i)$ 处的差异：\n$$\nE_{RMS} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} (T_{num,i} - T_{ana,i})^2}\n$$\n\n整个过程涉及为每个测试案例求解三种情景下的 FVM 方程组：（1）均匀网格上的算术平均，（2）均匀网格上的调和平均，以及（3）对齐网格上的调和平均，并为每种情景计算 RMS 误差。",
            "answer": "```python\n# 完整的、可运行的 Python 3 代码如下。\n# 导入的模块必须符合指定的执行环境。\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    使用 FVM 求解多个测试案例的一维稳态热扩散问题。\n    为每个案例计算三种不同数值方法的 RMS 误差。\n    \"\"\"\n    test_cases = [\n        # 案例1：理想情况，中等对比度，内部未对齐\n        {'L': 1.0, 'T0': 300.0, 'TL': 400.0, 'k1': 1.0, 'k2': 10.0, 'xi': 0.37, 'N': 40, 'A': 1.0},\n        # 案例2：高对比度，内部未对齐\n        {'L': 1.0, 'T0': 300.0, 'TL': 400.0, 'k1': 0.1, 'k2': 100.0, 'xi': 0.41, 'N': 40, 'A': 1.0},\n        # 案例3：界面靠近边界\n        {'L': 1.0, 'T0': 300.0, 'TL': 400.0, 'k1': 1.0, 'k2': 10.0, 'xi': 0.02, 'N': 40, 'A': 1.0},\n        # 案例4：均匀网格上的对齐界面\n        {'L': 1.0, 'T0': 300.0, 'TL': 400.0, 'k1': 1.0, 'k2': 10.0, 'xi': 0.50, 'N': 40, 'A': 1.0},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L, T0, TL, k1, k2, xi, N = case['L'], case['T0'], case['TL'], case['k1'], case['k2'], case['xi'], case['N']\n\n        # 1. 解析解\n        R_th_total = (xi / k1) + ((L - xi) / k2)\n        q = (T0 - TL) / R_th_total\n        Ti = T0 - q * xi / k1\n\n        def T_analytical(x):\n            if x = xi:\n                return T0 - q * x / k1\n            else:\n                return Ti - q * (x - xi) / k2\n\n        # 2. FVM 求解器函数\n        def fvm_solver(x_centers, k_cells, T_start, T_end, kf_method):\n            n_cells = len(x_centers)\n            A_matrix = np.zeros((n_cells, n_cells))\n            b_vector = np.zeros(n_cells)\n            \n            # 单元宽度和节点间距\n            x_faces = np.zeros(n_cells + 1)\n            x_faces[1:-1] = 0.5 * (x_centers[:-1] + x_centers[1:])\n            x_faces[-1] = L\n            cell_widths = x_faces[1:] - x_faces[:-1]\n            \n            # 填充矩阵和向量\n            for i in range(n_cells):\n                # 西侧面\n                if i == 0:\n                    # 边界条件\n                    k_w = k_cells[i]\n                    dx_wp = x_centers[i] - 0.0\n                    a_W_term = k_w / dx_wp\n                    A_matrix[i, i] += a_W_term\n                    b_vector[i] += a_W_term * T_start\n                else:\n                    k_w_cell, k_p_cell = k_cells[i-1], k_cells[i]\n                    if kf_method == 'arithmetic':\n                        k_w = 0.5 * (k_w_cell + k_p_cell)\n                    else: # 调和\n                        k_w = 2.0 * k_w_cell * k_p_cell / (k_w_cell + k_p_cell) if (k_w_cell + k_p_cell)  0 else 0\n                    dx_wp = x_centers[i] - x_centers[i-1]\n                    a_W = k_w / dx_wp\n                    A_matrix[i, i] += a_W\n                    A_matrix[i, i-1] -= a_W\n\n                # 东侧面\n                if i == n_cells - 1:\n                    # 边界条件\n                    k_e = k_cells[i]\n                    dx_pe = L - x_centers[i]\n                    a_E_term = k_e / dx_pe\n                    A_matrix[i, i] += a_E_term\n                    b_vector[i] += a_E_term * T_end\n                else:\n                    k_p_cell, k_e_cell = k_cells[i], k_cells[i+1]\n                    if kf_method == 'arithmetic':\n                        k_e = 0.5 * (k_p_cell + k_e_cell)\n                    else: # 调和\n                        k_e = 2.0 * k_p_cell * k_e_cell / (k_p_cell + k_e_cell) if (k_p_cell + k_e_cell)  0 else 0\n                    dx_pe = x_centers[i+1] - x_centers[i]\n                    a_E = k_e / dx_pe\n                    A_matrix[i, i] += a_E\n                    A_matrix[i, i+1] -= a_E\n\n            # 这是一种与 a_p T_p 形式不同的实现，但二者等价。\n            # a_p T_p = a_w T_w + a_e T_e + S_u - a_p T_p - a_w T_w - a_e T_e = S_u\n            # 其矩阵形式为 Ax=b。\n            # 我们来检查一下我的公式。\n            # 我当前的公式对应于 d/dx(k*dT/dx)=0，它变为\n            # k_e * (T_e - T_p) / dx_pe - k_w * (T_p - T_w) / dx_wp = 0\n            # (k_e/dx_pe + k_w/dx_wp)T_p - (k_w/dx_wp)T_w - (k_e/dx_pe)T_e = 0\n            # 我的系数是： A[i,i] = a_p, A[i, i-1] = -a_w, A[i, i+1] = -a_e。\n            # 对于边界，它们被移到右侧项（RHS）。这看起来是正确的。\n            # 再次检查边界。\n            # 对于 i=0，k_e(T_e-T_p)/dx_pe - k_w(T_p-T_w)/dx_wp = 0，其中 T_w=T_start\n            # (k_e/dx_pe + k_w/dx_wp)T_p - (k_e/dx_pe)T_e = (k_w/dx_wp)T_start.\n            # 我的实现：a_p T_p - a_e T_e = b\n            # A[i,i] = a_p, A[i,i+1]=-a_e, b[i] = b。这似乎是正确的。\n\n            T_numerical = np.linalg.solve(A_matrix, b_vector)\n            return T_numerical\n\n        def rms_error(T_num, T_ana):\n            return np.sqrt(np.mean((T_num - T_ana)**2))\n\n        # 3. 均匀网格计算\n        dx_uniform = L / N\n        x_centers_uniform = (np.arange(N) + 0.5) * dx_uniform\n        k_cells_uniform = np.array([k1 if x  xi else k2 for x in x_centers_uniform])\n        T_ana_uniform = np.array([T_analytical(x) for x in x_centers_uniform])\n\n        T_arith_uniform = fvm_solver(x_centers_uniform, k_cells_uniform, T0, TL, 'arithmetic')\n        E_arith_uniform = rms_error(T_arith_uniform, T_ana_uniform)\n        \n        T_harm_uniform = fvm_solver(x_centers_uniform, k_cells_uniform, T0, TL, 'harmonic')\n        E_harm_uniform = rms_error(T_harm_uniform, T_ana_uniform)\n        \n        results.extend([E_arith_uniform, E_harm_uniform])\n\n        # 4. 对齐网格计算\n        N_left = int(round(N * xi / L)) if L  0 else 0\n        if xi == L: N_left = N\n        if xi == 0: N_left = 0\n        N_right = N - N_left\n\n        x_centers_aligned = np.zeros(N)\n        k_cells_aligned = np.zeros(N)\n\n        if N_left  0:\n            dx_left = xi / N_left\n            x_centers_aligned[:N_left] = (np.arange(N_left) + 0.5) * dx_left\n            k_cells_aligned[:N_left] = k1\n        \n        if N_right  0:\n            dx_right = (L - xi) / N_right\n            x_centers_aligned[N_left:] = xi + (np.arange(N_right) + 0.5) * dx_right\n            k_cells_aligned[N_left:] = k2\n\n        T_ana_aligned = np.array([T_analytical(x) for x in x_centers_aligned])\n        \n        T_harm_aligned = fvm_solver(x_centers_aligned, k_cells_aligned, T0, TL, 'harmonic')\n        E_harm_aligned = rms_error(T_harm_aligned, T_ana_aligned)\n        \n        results.append(E_harm_aligned)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本章的最后一个实践练习将我们的重点从模型构建转移到模型验证，这是确保任何数值模拟可靠性的关键一步。你将为一个具有已知解析解的问题编写一个FVM求解器，并执行一次精度阶数研究，这是计算流体动力学中的一个标准验证流程。这项练习将使你能够正式地验证你的代码是否以理论预期的收敛速率收敛，从而增强对程序实现的信心，并加深对截断误差的理解。",
            "id": "3956039",
            "problem": "考虑一根长度为 $L$ 的均质杆内的一维稳态热传导，其导热系数 $k$、横截面积 $A$ 恒定，且存在均匀的体积热生成率 $\\dot{q}'''$。对于带内热源的一维稳态扩散问题，其控制能量守恒定律是傅里叶定律在控制体上积分的散度形式，在连续介质极限下，该定律可简化为关于温度场的二阶常微分方程。未知场为定义在 $x \\in [0,L]$ 上的温度 $T(x)$。假设采用狄利克雷（Dirichlet）边界条件 $T(0) = T_0$ 和 $T(L) = T_L$。\n\n任务：\n- 从基本能量守恒定律和傅里叶定律出发，推导 $T(x)$ 的连续方程，并在上述狄利克雷边界条件下求出 $T(x)$ 的精确解。证明精确解是关于 $x$ 的二次函数，并由 $k$、$A$、$\\dot{q}'''$、$T_0$、$T_L$ 和 $L$ 唯一确定。温度单位必须为开尔文（$\\mathrm{K}$），导热系数单位为 $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$，横截面积单位为 $\\mathrm{m}^2$，体积热生成率单位为 $\\mathrm{W}/\\mathrm{m}^3$，长度单位为米（$\\mathrm{m}$）。\n- 在具有 $N$ 个控制体（大小为 $\\Delta x = L/N$）的均匀网格上，推导一种基于单元中心的有限体积法 (FVM) 离散格式。对面法向梯度使用两点中心差分近似，并使用半控制体距离处理狄利克雷边界。将每个控制体的离散方程写成典范 FVM 形式 $a_P T_P = a_W T_W + a_E T_E + S_u$，其中 $T_P$ 表示单元中心温度，$T_W$ 和 $T_E$ 分别表示其西侧和东侧相邻单元的温度，$S_u$ 是积分源项贡献。\n- 编写一个程序，用于组装并求解所得的关于单元中心温度 $T_P$ 的三对角线性系统。然后在相同的单元中心位置计算连续精确解，并计算误差范数。使用离散 $L^2$ (积分) 范数，其计算公式为 $\\sqrt{\\sum_{i=1}^N \\left(T_i^{\\text{disc}} - T(x_i)^{\\text{exact}}\\right)^2 \\Delta x}$，其中 $x_i$ 是单元中心坐标，$T_i^{\\text{disc}}$ 是这些中心的离散温度。\n- 通过计算观测阶数 $p$ 来验证二阶空间精度，计算公式为 $p = \\log_2\\left(E_h/E_{h/2}\\right)$，其中 $E_h$ 是网格间距为 $h=\\Delta x$ 时的误差范数，$E_{h/2}$ 是网格加密一倍后的误差范数。\n\n测试套件和要求的输出：\n- 使用以下三个测试用例来评估实现：\n  1. 用例 A（对称边界温度，非零热生成）：$L = 0.2\\,\\mathrm{m}$，$k = 15.0\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$，$A = 1.0\\times 10^{-3}\\,\\mathrm{m}^2$，$\\dot{q}''' = 2.0\\times 10^{5}\\,\\mathrm{W}/\\mathrm{m}^3$，$T_0 = 300.0\\,\\mathrm{K}$，$T_L = 300.0\\,\\mathrm{K}$，使用两套网格 $N=40$ 和 $N=80$。以浮点数形式输出观测阶数 $p$。\n  2. 用例 B（非对称边界温度，非零热生成）：$L = 0.1\\,\\mathrm{m}$，$k = 200.0\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$，$A = 5.0\\times 10^{-4}\\,\\mathrm{m}^2$，$\\dot{q}''' = 1.0\\times 10^{6}\\,\\mathrm{W}/\\mathrm{m}^3$，$T_0 = 300.0\\,\\mathrm{K}$，$T_L = 350.0\\,\\mathrm{K}$，使用两套网格 $N=20$ 和 $N=40$。以浮点数形式输出观测阶数 $p$。\n  3. 用例 C（边界情况，零热生成）：$L = 0.3\\,\\mathrm{m}$，$k = 50.0\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$，$A = 2.0\\times 10^{-4}\\,\\mathrm{m}^2$，$\\dot{q}''' = 0.0\\,\\mathrm{W}/\\mathrm{m}^3$，$T_0 = 300.0\\,\\mathrm{K}$，$T_L = 350.0\\,\\mathrm{K}$，使用两套网格 $N=10$ 和 $N=20$。由于精确解是线性的，中心差分 FVM 应该能将其重现到舍入误差范围内；如果两套网格的离散 $L^2$ 范数误差均低于 $1.0\\times 10^{-11}\\,\\mathrm{K}$，则输出布尔值 $True$，否则输出 $False$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序为用例 A、用例 B、用例 C（例如，$[p_A,p_B,\\text{boolean}_C]$）。数字 $p_A$ 和 $p_B$ 是无量纲的，必须打印为浮点数。用例 C 的布尔值必须打印为 $True$ 或 $False$。",
            "solution": "该问题被评估为有效。这是一个在计算传热学领域中定义明确、有科学依据的问题，内容自洽，没有歧义或矛盾。\n\n### 第 1 部分：连续控制方程和精确解\n\n控制该过程的基本原理是能量守恒。对于一维稳态系统，在长度为 $\\Delta x$、横截面积恒为 $A$ 的任意控制体上的能量平衡为：\n\n(能量传入速率) + (能量生成速率) = (能量传出速率)\n\n设 $q(x)$ 为正 $x$ 方向的热通量，单位为 $\\mathrm{W}/\\mathrm{m}^2$。传热速率（热流）为 $Q(x) = q(x) A$。能量平衡变为：\n$$Q(x) - Q(x+\\Delta x) + \\dot{q}''' (A \\Delta x) = 0$$\n其中 $\\dot{q}'''$ 是均匀的体积热生成率，单位为 $\\mathrm{W}/\\mathrm{m}^3$。两边同除以体积 $A \\Delta x$ 并取极限 $\\Delta x \\to 0$，可得到能量守恒方程的微分形式：\n$$-\\frac{d}{dx}q(x) + \\dot{q}''' = 0$$\n傅里叶（Fourier）热传导定律将热通量与温度梯度关联起来：\n$$q(x) = -k \\frac{dT}{dx}$$\n其中 $k$ 是导热系数，单位为 $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$，$T(x)$ 是温度场。将傅里叶定律代入守恒方程可得：\n$$-\\frac{d}{dx}\\left(-k \\frac{dT}{dx}\\right) + \\dot{q}''' = 0$$\n由于假设导热系数 $k$ 是常数，方程可简化为关于 $T(x)$ 的二阶常微分方程 (ODE)：\n$$\\frac{d^2T}{dx^2} = -\\frac{\\dot{q}'''}{k}$$\n为了求得精确解，我们将此常微分方程对 $x$ 积分两次：\n$$\\frac{dT}{dx} = -\\frac{\\dot{q}'''}{k}x + C_1$$\n$$T(x) = -\\frac{\\dot{q}'''}{2k}x^2 + C_1 x + C_2$$\n这表明精确解是 $x$ 的二次函数。积分常数 $C_1$ 和 $C_2$ 通过应用狄利克雷（Dirichlet）边界条件 $T(0) = T_0$ 和 $T(L) = T_L$ 来确定。\n\n在 $x=0$ 处：\n$$T(0) = T_0 = -\\frac{\\dot{q}'''}{2k}(0)^2 + C_1(0) + C_2 \\implies C_2 = T_0$$\n在 $x=L$ 处：\n$$T(L) = T_L = -\\frac{\\dot{q}'''}{2k}L^2 + C_1 L + T_0$$\n求解 $C_1$：\n$$C_1 L = T_L - T_0 + \\frac{\\dot{q}'''L^2}{2k} \\implies C_1 = \\frac{T_L - T_0}{L} + \\frac{\\dot{q}'''L}{2k}$$\n将 $C_1$ 和 $C_2$ 代回 $T(x)$ 的表达式，得到唯一的精确解：\n$$T(x) = -\\frac{\\dot{q}'''}{2k}x^2 + \\left(\\frac{T_L - T_0}{L} + \\frac{\\dot{q}'''L}{2k}\\right)x + T_0$$\n该解可以重排为线性分布（无源项的传导）和抛物线分布（边界温度为零的源项）的叠加：\n$$T(x)^{\\text{exact}} = T_0 + (T_L - T_0)\\frac{x}{L} + \\frac{\\dot{q}'''}{2k}(Lx - x^2)$$\n该解由参数 $k, \\dot{q}''', T_0, T_L,$ 和 $L$ 唯一确定。面积 $A$ 没有出现在温度的控制方程中，因为它被消去了，但在计算总热率时需要用到。\n\n### 第 2 部分：有限体积法 (FVM) 离散化\n\n我们将区域 $x \\in [0, L]$ 离散为 $N$ 个均匀的、以单元为中心的控制体 (CV)，每个控制体的宽度为 $\\Delta x = L/N$。第 $i$ 个控制体的中心用 $P$ (或 $i$)表示，其坐标为 $x_i = (i-0.5)\\Delta x$，其中 $i=1, 2, \\dots, N$。第 $i$ 个控制体的西侧和东侧面分别位于 $x_w = (i-1)\\Delta x$ 和 $x_e = i\\Delta x$。\n\n我们将原始守恒定律 $\\frac{d}{dx}(k \\frac{dT}{dx}) + \\dot{q}''' = 0$ 在第 $i$ 个控制体上积分：\n$$\\int_{x_w}^{x_e} \\left(\\frac{d}{dx}\\left(k \\frac{dT}{dx}\\right) + \\dot{q}'''\\right) A \\, dx = 0$$\n$$A \\int_{x_w}^{x_e} \\frac{d}{dx}\\left(k \\frac{dT}{dx}\\right) dx + A \\int_{x_w}^{x_e} \\dot{q}''' \\, dx = 0$$\n对第一项应用微积分基本定理，并计算常数源项的积分：\n$$A \\left[k \\frac{dT}{dx}\\right]_w^e + A \\dot{q}''' \\Delta x = 0$$\n$$A \\left(k \\frac{dT}{dx}\\right)_e - A \\left(k \\frac{dT}{dx}\\right)_w + A \\dot{q}''' \\Delta x = 0$$\n单元交界面上的梯度使用相邻单元中心温度的中心差分来近似。对于内部单元 $i$，其相邻单元为西侧的单元 $W$ ($i-1$) 和东侧的单元 $E$ ($i+1$)。\n$$\\left(\\frac{dT}{dx}\\right)_e \\approx \\frac{T_E - T_P}{\\Delta x} \\quad \\text{and} \\quad \\left(\\frac{dT}{dx}\\right)_w \\approx \\frac{T_P - T_W}{\\Delta x}$$\n将这些近似代入内部控制体（$i=2, \\dots, N-1$）的积分平衡方程：\n$$A k \\frac{T_E - T_P}{\\Delta x} - A k \\frac{T_P - T_W}{\\Delta x} + A \\dot{q}''' \\Delta x = 0$$\n重排为典范 FVM 形式 $a_P T_P = a_W T_W + a_E T_E + S_u$：\n$$\\left(\\frac{kA}{\\Delta x} + \\frac{kA}{\\Delta x}\\right) T_P = \\left(\\frac{kA}{\\Delta x}\\right) T_W + \\left(\\frac{kA}{\\Delta x}\\right) T_E + \\dot{q}''' A \\Delta x$$\n内部单元的系数为：$a_P = \\frac{2kA}{\\Delta x}$，$a_W = a_E = \\frac{kA}{\\Delta x}$，源项为 $S_u = \\dot{q}''' A \\Delta x$。\n\n对于边界单元，处理方式有所修改：\n**单元 1 (西边界):** 西侧面是位于 $x=0$ 处的物理边界，温度为 $T_0$。该界面上的梯度在半个单元距离 $\\Delta x/2$ 上进行近似：\n$$\\left(\\frac{dT}{dx}\\right)_w \\approx \\frac{T_P - T_0}{\\Delta x / 2} = \\frac{T_1 - T_0}{\\Delta x / 2}$$\n东侧面的梯度是标准的：$(\\frac{dT}{dx})_e \\approx \\frac{T_2 - T_1}{\\Delta x}$。代入平衡方程：\n$$A k \\frac{T_2 - T_1}{\\Delta x} - A k \\frac{T_1 - T_0}{\\Delta x/2} + A \\dot{q}''' \\Delta x = 0$$\n对 $T_P = T_1$ 进行重排：\n$$\\left(\\frac{kA}{\\Delta x} + \\frac{2kA}{\\Delta x}\\right) T_1 = \\left(\\frac{kA}{\\Delta x}\\right) T_2 + \\left(\\frac{2kA}{\\Delta x} T_0 + \\dot{q}''' A \\Delta x\\right)$$\n此处，$a_P = \\frac{3kA}{\\Delta x}$，$a_W = 0$，$a_E = \\frac{kA}{\\Delta x}$，以及 $S_u = \\frac{2kA}{\\Delta x} T_0 + \\dot{q}''' A \\Delta x$。\n\n**单元 N (东边界):** 东侧面是位于 $x=L$ 处的边界，温度为 $T_L$。其梯度近似为：\n$$\\left(\\frac{dT}{dx}\\right)_e \\approx \\frac{T_L - T_P}{\\Delta x / 2} = \\frac{T_L - T_N}{\\Delta x / 2}$$\n西侧面的梯度为 $(\\frac{dT}{dx})_w \\approx \\frac{T_N - T_{N-1}}{\\Delta x}$。代入平衡方程：\n$$A k \\frac{T_L - T_N}{\\Delta x/2} - A k \\frac{T_N - T_{N-1}}{\\Delta x} + A \\dot{q}''' \\Delta x = 0$$\n对 $T_P = T_N$ 进行重排：\n$$\\left(\\frac{2kA}{\\Delta x} + \\frac{kA}{\\Delta x}\\right) T_N = \\left(\\frac{kA}{\\Delta x}\\right) T_{N-1} + \\left(\\frac{2kA}{\\Delta x} T_L + \\dot{q}''' A \\Delta x\\right)$$\n此处，$a_P = \\frac{3kA}{\\Delta x}$，$a_W = \\frac{kA}{\\Delta x}$，$a_E = 0$，以及 $S_u = \\frac{2kA}{\\Delta x} T_L + \\dot{q}''' A \\Delta x$。\n\n### 第 3 部分：线性系统和精度验证\n\n这 $N$ 个线性代数方程构成一个三对角系统 $\\mathbf{M}\\mathbf{T} = \\mathbf{b}$，其中 $\\mathbf{T} = [T_1, T_2, \\dots, T_N]^T$。为了便于实现，将所有方程两边同除以 $kA/\\Delta x$：\n- **方程 1:** $3 T_1 - T_2 = \\frac{\\dot{q}''' (\\Delta x)^2}{k} + 2 T_0$\n- **方程 i=2..N-1:** $-T_{i-1} + 2 T_i - T_{i+1} = \\frac{\\dot{q}''' (\\Delta x)^2}{k}$\n- **方程 N:** $-T_{N-1} + 3 T_N = \\frac{\\dot{q}''' (\\Delta x)^2}{k} + 2 T_L$\n\n该系统通过数值方法求解，得到离散温度 $T_i^{\\text{disc}}$。在单元中心坐标 $x_i$ 处，使用离散 $L^2$ 范数与精确解进行比较来评估误差：\n$$E = \\sqrt{\\sum_{i=1}^N \\left(T_i^{\\text{disc}} - T(x_i)^{\\text{exact}}\\right)^2 \\Delta x}$$\n该中心差分格式的理论精度阶数为二阶，意味着误差 $E$ 与 $(\\Delta x)^2$ 成正比。我们通过在间距为 $h$ 和 $h/2$ 的两套网格上求解，并计算观测精度阶数 $p$ 来验证这一点：\n$$p = \\log_2\\left(\\frac{E_h}{E_{h/2}}\\right)$$\n对于二阶格式，我们期望 $p \\approx 2$。\n\n对于 $\\dot{q}'''=0$ 的用例 C，精确解是线性的。代数运算可以证实，线性解能精确满足 FVM 格式（包括边界处理），因此数值解应在机器浮点精度范围内与精确解相匹配。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, run test cases, and print the final output.\n    \"\"\"\n\n    def compute_error(L, k, A, q_gen, T0, TL, N):\n        \"\"\"\n        Solves the 1D steady diffusion problem using FVM and returns the L2 error norm.\n        \n        Args:\n            L (float): Length of the rod [m].\n            k (float): Thermal conductivity [W/(m.K)].\n            A (float): Cross-sectional area [m^2].\n            q_gen (float): Volumetric heat generation [W/m^3].\n            T0 (float): Temperature at x=0 [K].\n            TL (float): Temperature at x=L [K].\n            N (int): Number of control volumes.\n        \n        Returns:\n            float: The discrete L2 norm of the error.\n        \"\"\"\n        # 1. Grid setup\n        dx = L / N\n        x_centers = np.linspace(dx / 2, L - dx / 2, N)\n\n        # 2. Assemble the linear system M*T = b (simplified form)\n        M = np.zeros((N, N))\n        b = np.zeros(N)\n\n        # Fill main and off-diagonals\n        np.fill_diagonal(M, 2.0)\n        np.fill_diagonal(M[1:], -1.0)\n        np.fill_diagonal(M[:, 1:], -1.0)\n        \n        # Apply boundary condition modifications\n        M[0, 0] = 3.0\n        M[N - 1, N - 1] = 3.0\n\n        # Assemble the RHS vector b\n        source_term = (q_gen * dx**2) / k\n        b.fill(source_term)\n        b[0] += 2 * T0\n        b[N - 1] += 2 * TL\n\n        # 3. Solve the linear system\n        T_fvm = np.linalg.solve(M, b)\n\n        # 4. Calculate the exact solution at cell centers\n        # T_exact(x) = T0 + (TL - T0)*x/L + (q_gen/(2*k))*(L*x - x**2)\n        term1 = T0\n        term2 = (TL - T0) * x_centers / L\n        term3 = (q_gen / (2 * k)) * (L * x_centers - x_centers**2)\n        T_exact = term1 + term2 + term3\n        \n        # 5. Compute the discrete L2 error norm\n        error_norm = np.sqrt(np.sum((T_fvm - T_exact)**2) * dx)\n        \n        return error_norm\n\n    results = []\n\n    # Case A: Symmetric BCs, with generation\n    L_A, k_A, A_A, q_gen_A, T0_A, TL_A = 0.2, 15.0, 1.0e-3, 2.0e5, 300.0, 300.0\n    N1_A, N2_A = 40, 80\n    error_h_A = compute_error(L_A, k_A, A_A, q_gen_A, T0_A, TL_A, N1_A)\n    error_h2_A = compute_error(L_A, k_A, A_A, q_gen_A, T0_A, TL_A, N2_A)\n    # Avoid division by zero if error is zero\n    if error_h2_A  0:\n        p_A = np.log2(error_h_A / error_h2_A)\n    else:\n        p_A = np.inf # Or some other indicator of exactness\n    results.append(p_A)\n\n    # Case B: Asymmetric BCs, with generation\n    L_B, k_B, A_B, q_gen_B, T0_B, TL_B = 0.1, 200.0, 5.0e-4, 1.0e6, 300.0, 350.0\n    N1_B, N2_B = 20, 40\n    error_h_B = compute_error(L_B, k_B, A_B, q_gen_B, T0_B, TL_B, N1_B)\n    error_h2_B = compute_error(L_B, k_B, A_B, q_gen_B, T0_B, TL_B, N2_B)\n    if error_h2_B  0:\n        p_B = np.log2(error_h_B / error_h2_B)\n    else:\n        p_B = np.inf\n    results.append(p_B)\n\n    # Case C: Zero generation (linear solution)\n    L_C, k_C, A_C, q_gen_C, T0_C, TL_C = 0.3, 50.0, 2.0e-4, 0.0, 300.0, 350.0\n    N1_C, N2_C = 10, 20\n    error_1_C = compute_error(L_C, k_C, A_C, q_gen_C, T0_C, TL_C, N1_C)\n    error_2_C = compute_error(L_C, k_C, A_C, q_gen_C, T0_C, TL_C, N2_C)\n    threshold = 1.0e-11\n    result_C = (error_1_C  threshold) and (error_2_C  threshold)\n    results.append(result_C)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}