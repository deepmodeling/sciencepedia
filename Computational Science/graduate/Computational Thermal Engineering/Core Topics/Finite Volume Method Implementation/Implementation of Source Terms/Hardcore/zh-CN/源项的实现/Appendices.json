{
    "hands_on_practices": [
        {
            "introduction": "我们从一个基础但至关重要的实践开始：实现一个由外部场（电势）派生出的源项。本练习强调了使用“人造解法”（Method of Manufactured Solutions）进行代码验证的重要性。我们将实现一个焦耳热源项 $S_J$，并验证我们对线性势场 $\\phi$ 的数值梯度计算是否精确，从而从根本上确保源项实现的正确性，为处理更复杂的物理问题建立坚实的数值基础。",
            "id": "3962599",
            "problem": "要求您在均匀介质中的直流 (DC) 电传导问题中，实现并验证一个体积焦耳热源项的数值实现。验证的核心在于电势为线性的情况，这意味着电场是均匀的，因此整个域上的焦耳热源项也是均匀的。目标是从离散化的电势场计算源项，并将其与根据基本定律推导出的解析期望值进行比较。\n\n使用的基本原理：\n- 稳态传导的欧姆定律：电流密度由 $\\mathbf{J} = \\boldsymbol{\\sigma}\\,\\mathbf{E}$ 给出，其中 $\\boldsymbol{\\sigma}$ 是标量电导率或对称正定电导率张量，$\\mathbf{E}$ 是电场。\n- 电场是电势的负梯度：$\\mathbf{E} = -\\nabla \\phi$。\n- 体积焦耳热率（源项）为 $S_J = \\mathbf{J} \\cdot \\mathbf{E}$，单位为 $\\mathrm{W/m^3}$。\n\n场景：\n- 考虑一个位于 $\\mathbb{R}^d$ 中的矩形均匀域，该域具有均匀网格和单元中心变量。设电势为线性函数 $\\phi(\\mathbf{x}) = \\phi_0 + \\sum_{i=1}^d a_i x_i$，其中 $\\phi_0$ 和 $a_i$ 是常数。这将在整个域上产生一个均匀电场 $\\mathbf{E} = -(a_1, a_2, \\dots, a_d)$ 和一个均匀的焦耳热源 $S_J$。\n- 对于各向同性电导率（标量）$\\sigma$，$S_J$ 是一个常数，等于 $\\sigma \\sum_{i=1}^d a_i^2$。\n- 对于各向异性电导率（张量）$\\boldsymbol{\\sigma} \\in \\mathbb{R}^{d \\times d}$，且其对称正定，$S_J$ 是一个常数，等于 $\\mathbf{E}^\\mathsf{T} \\boldsymbol{\\sigma} \\mathbf{E} = \\mathbf{a}^\\mathsf{T} \\boldsymbol{\\sigma} \\mathbf{a}$，其中 $\\mathbf{a} = (a_1,\\dots,a_d)$。\n\n您的任务：\n- 实现一个程序，该程序能构建均匀网格，在单元中心计算线性电势，使用适用于单元中心数据的一致性有限差分格式计算数值梯度，计算电场和电流密度，并在每个单元上以 $\\mathbf{J} \\cdot \\mathbf{E}$ 的形式构成焦耳热源项。\n- 对每个测试用例，将计算出的场 $S_J(\\mathbf{x})$ 与解析的均匀值进行比较，并报告所有单元上的最大绝对偏差。以 $\\mathrm{W/m^3}$ 为单位表示最终偏差。\n\n数值细节：\n- 在域长度为 $(L_x, L_y, L_z)$ 的区域上使用单元中心网格，每个维度有 $N_x, N_y, N_z$ 个单元。\n- 在内部单元使用二阶中心差分，并在域边界使用一致的单侧差分，这样线性电势可以产生精确的离散梯度。\n\n单位：\n- 电导率 $\\sigma$ 和张量分量的单位是 $\\mathrm{S/m}$。\n- 电势 $\\phi$ 的单位是 $\\mathrm{V}$。\n- 电场 $\\mathbf{E}$ 的单位是 $\\mathrm{V/m}$。\n- 焦耳热源 $S_J$ 的单位是 $\\mathrm{W/m^3}$。\n- 以 $\\mathrm{W/m^3}$ 为单位，将偏差报告为浮点数。\n\n测试套件：\n实现以下 $5$ 个测试用例。对每个用例，数值计算 $S_J$ 并以 $\\mathrm{W/m^3}$ 为单位报告单个数字 $\\max_{\\text{cells}} |S_J^{\\text{num}} - S_J^{\\text{analytic}}|$。\n\n- 测试 1（一维，各向同性，典型分辨率）：\n  - 维度 $d = 1$。\n  - $N_x = 51$，$L_x = 0.7$ $\\mathrm{m}$。\n  - $\\phi_0 = 2.0$ $\\mathrm{V}$，$a_1 = 3.0$ $\\mathrm{V/m}$。\n  - $\\sigma = 10.0$ $\\mathrm{S/m}$。\n- 测试 2（二维，各向同性，混合梯度）：\n  - 维度 $d = 2$。\n  - $(N_x, N_y) = (64, 32)$，$(L_x, L_y) = (1.2, 0.8)$ $\\mathrm{m}$。\n  - $\\phi_0 = 0.0$ $\\mathrm{V}$，$(a_1, a_2) = (5.0, -4.0)$ $\\mathrm{V/m}$。\n  - $\\sigma = 2.0$ $\\mathrm{S/m}$。\n- 测试 3（二维，各向异性电导率张量）：\n  - 维度 $d = 2$。\n  - $(N_x, N_y) = (33, 65)$，$(L_x, L_y) = (0.5, 0.3)$ $\\mathrm{m}$。\n  - $\\phi_0 = 1.0$ $\\mathrm{V}$，$(a_1, a_2) = (2.0, -4.0)$ $\\mathrm{V/m}$。\n  - $\\boldsymbol{\\sigma} = \\begin{bmatrix} 5.0  1.0 \\\\ 1.0  3.0 \\end{bmatrix}$ $\\mathrm{S/m}$。\n- 测试 4（三维，各向同性，零场边界情况）：\n  - 维度 $d = 3$。\n  - $(N_x, N_y, N_z) = (7, 9, 11)$，$(L_x, L_y, L_z) = (0.1, 0.2, 0.3)$ $\\mathrm{m}$。\n  - $\\phi_0 = 10.0$ $\\mathrm{V}$，$(a_1, a_2, a_3) = (0.0, 0.0, 0.0)$ $\\mathrm{V/m}$。\n  - $\\sigma = 12.0$ $\\mathrm{S/m}$。\n- 测试 5（一维，各向同性，边界主导的粗网格）：\n  - 维度 $d = 1$。\n  - $N_x = 2$，$L_x = 1.0$ $\\mathrm{m}$。\n  - $\\phi_0 = -3.0$ $\\mathrm{V}$，$a_1 = 0.75$ $\\mathrm{V/m}$。\n  - $\\sigma = 7.0$ $\\mathrm{S/m}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表 (例如，\"[result1,result2,result3,result4,result5]\")。每个条目必须是相应测试用例的最大绝对偏差，以 $\\mathrm{W/m^3}$ 为单位，表示为浮点数。",
            "solution": "该问题要求在一个均匀介质中的直流电传导问题中，对体积焦耳热源项 $S_J$ 进行数值实现和验证。验证基于电势 $\\phi$ 是位置的线性函数的特定情况，这简化了解析计算，并为数值方案提供了一个清晰的基准。\n\n基础物理学由三个原理给出。首先，欧姆定律将电流密度矢量 $\\mathbf{J}$ 与电场矢量 $\\mathbf{E}$ 和电导率 $\\boldsymbol{\\sigma}$ 关联起来，即 $\\mathbf{J} = \\boldsymbol{\\sigma}\\,\\mathbf{E}$。对于各向同性材料，电导率 $\\boldsymbol{\\sigma}$ 可以是标量 $\\sigma$；对于各向异性材料，它可以是张量。其次，电场被定义为标量电势的负梯度，即 $\\mathbf{E} = -\\nabla \\phi$。第三，体积焦耳热率，在热能平衡中充当源项，由点积 $S_J = \\mathbf{J} \\cdot \\mathbf{E}$ 给出。将前两个关系式代入第三个，得到 $S_J = (-\\nabla\\phi)^\\mathsf{T} \\boldsymbol{\\sigma} (-\\nabla\\phi) = (\\nabla\\phi)^\\mathsf{T} \\boldsymbol{\\sigma} (\\nabla\\phi)$。\n\n问题指定了一个形式为 $\\phi(\\mathbf{x}) = \\phi_0 + \\sum_{i=1}^d a_i x_i$ 的线性电势场，其中 $\\mathbf{x}=(x_1, \\dots, x_d)$，且 $\\phi_0$ 和 $a_i$ 是常数。该电势的梯度是一个常数矢量 $\\nabla\\phi = (a_1, a_2, \\dots, a_d) = \\mathbf{a}$。因此，电场在整个域上是均匀的：$\\mathbf{E} = -\\mathbf{a}$。这种均匀性会传播到电流密度 $\\mathbf{J} = -\\boldsymbol{\\sigma}\\mathbf{a}$ 和焦耳热源项 $S_J$。因此，解析源项 $S_J^{\\text{analytic}}$ 是一个由 $S_J^{\\text{analytic}} = (-\\mathbf{a}) \\cdot (-\\boldsymbol{\\sigma}\\mathbf{a}) = \\mathbf{a}^\\mathsf{T} \\boldsymbol{\\sigma} \\mathbf{a}$ 给出的常数值。对于各向同性的情况，其中 $\\boldsymbol{\\sigma}$ 是标量 $\\sigma$ 乘以单位矩阵，这简化为 $S_J^{\\text{analytic}} = \\sigma (\\mathbf{a} \\cdot \\mathbf{a}) = \\sigma \\sum_{i=1}^d a_i^2$。\n\n数值任务是离散化域，在每个离散单元上计算源项 $S_J^{\\text{num}}$，并验证其与常数解析值 $S_J^{\\text{analytic}}$ 相匹配。验证的核心在于梯度 $\\nabla\\phi$ 的数值计算。问题强制要求使用对线性电势精确的有限差分格式。这是一个至关重要的要求。满足此属性的数值梯度算子在应用于离散电势场 $\\phi_{i,j,\\dots}$ 时，将产生一个离散电场 $\\mathbf{E}^{\\text{num}}$，该电场在整个网格上是均匀的，并且等于解析电场 $-\\mathbf{a}$（在机器精度范围内）。\n\n算法流程如下：\n$1$。对每个测试用例，定义域的维度 $(L_x, L_y, \\dots)$、单元数量 $(N_x, N_y, \\dots)$、电势系数 $(\\phi_0, a_1, a_2, \\dots)$ 以及电导率 $\\sigma$ 或 $\\boldsymbol{\\sigma}$。\n$2$。构建一个均匀的、以单元为中心的网格。对于每个维度 $k \\in \\{x, y, z\\}$，单元尺寸为 $\\Delta_k = L_k / N_k$，单元中心坐标为 $x_{k,i} = (i + 0.5)\\Delta_k$，其中 $i \\in \\{0, 1, \\dots, N_k-1\\}$。在多维情况下，使用这些坐标向量生成多维坐标数组。\n$3$。在每个单元中心计算线性电势 $\\phi(\\mathbf{x})$，创建一个包含电势值的多维数组 $\\boldsymbol{\\Phi}$。\n$4$。使用适当的公式计算解析源项 $S_J^{\\text{analytic}}$：对于各向同性的情况，使用 $\\sigma \\sum a_i^2$；对于各向异性的情况，使用 $\\mathbf{a}^\\mathsf{T} \\boldsymbol{\\sigma} \\mathbf{a}$。这将产生一个单一的标量值。\n$5$。计算电势场 $\\boldsymbol{\\Phi}$ 的数值梯度。我们采用一种在域内部为二阶精度、在边界为一阶精度的有限差分格式。所使用的中心和单侧模板对于线性函数都是精确的，满足了问题的要求。`numpy.gradient` 函数实现了这样一种格式，使其成为一个合适的工具。此步骤为梯度的每个分量（例如 $(\\nabla\\phi)_x$、$(\\nabla\\phi)_y$ 等）生成数组。\n$6$。根据梯度计算每个单元的电场矢量分量 $\\mathbf{E}^{\\text{num}} = -\\nabla^{\\text{num}} \\phi$。每个分量 $E_k^{\\text{num}}$ 都是一个多维数组。\n$7$。计算电流密度矢量分量 $\\mathbf{J}^{\\text{num}} = \\boldsymbol{\\sigma} \\mathbf{E}^{\\text{num}}$。在各向同性的情况下，这是一个简单的缩放：$J_k^{\\text{num}} = \\sigma E_k^{\\text{num}}$。在各向异性的情况下，它是在每个网格点上进行矩阵-矢量乘法：$J_i^{\\text{num}} = \\sum_j \\sigma_{ij} E_j^{\\text{num}}$。\n$8$。计算数值源项 $S_J^{\\text{num}} = \\mathbf{J}^{\\text{num}} \\cdot \\mathbf{E}^{\\text{num}} = \\sum_k J_k^{\\text{num}} E_k^{\\text{num}}$。这将得到一个多维数组，其中每个元素是相应单元中的源项值。\n$9$。最后的验证步骤是计算数值源项场与常数解析值之间的最大绝对偏差：$\\max | S_J^{\\text{num}} - S_J^{\\text{analytic}} |$。由于所选的数值梯度格式对于给定的线性电势是精确的，所有后续的数值计算也应该是精确的，与解析解的差异仅在于浮点舍入误差。因此，预期的偏差是一个非常接近 $0$ 的值。\n\n将此程序应用于所提供的 5 个测试用例，这些用例涵盖了一维、二维和三维，各向同性和各向异性电导率，非零场和零场，以及不同分辨率的网格，包括一个用于测试边界条件处理的 2 单元粗网格。然后报告每个用例的最大绝对偏差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_deviation(d, N, L, phi0, a, sigma):\n    \"\"\"\n    Calculates the maximum absolute deviation of the numerical Joule heating source term.\n\n    Args:\n        d (int): Number of spatial dimensions.\n        N (tuple): Number of cells in each dimension (Nx, Ny, ...).\n        L (tuple): Length of the domain in each dimension (Lx, Ly, ...).\n        phi0 (float): Constant offset for the potential function.\n        a (tuple): Coefficients of the linear terms in the potential function.\n        sigma (float or list of lists): Electrical conductivity (scalar for isotropic,\n                                        matrix for anisotropic).\n\n    Returns:\n        float: The maximum absolute deviation between the numerical and analytical\n               source terms over all cells.\n    \"\"\"\n    # 1. Create Grid\n    deltas = tuple(L[i] / N[i] for i in range(d))\n    \n    # Create 1D coordinate vectors for cell centers\n    coord_vectors = [np.linspace(0.5 * deltas[i], L[i] - 0.5 * deltas[i], N[i]) for i in range(d)]\n    \n    # Create multidimensional coordinate grids\n    if d > 1:\n        coord_grids = np.meshgrid(*coord_vectors, indexing='ij')\n    else:\n        coord_grids = coord_vectors\n\n    # 2. Evaluate Potential Field\n    phi = np.full(N, phi0, dtype=np.float64)\n    for i in range(d):\n        phi += a[i] * coord_grids[i]\n\n    # 3. Calculate Analytical Source Term\n    a_vec = np.array(a)\n    if np.isscalar(sigma):  # Isotropic case\n        S_J_analytic = sigma * np.dot(a_vec, a_vec)\n    else:  # Anisotropic case\n        sigma_mat = np.array(sigma)\n        S_J_analytic = a_vec.T @ sigma_mat @ a_vec\n\n    # 4. Calculate Numerical Gradient\n    # np.gradient uses 2nd-order central differences for interior and\n    # 1st-order one-sided differences for boundaries. Both are exact\n    # for a linear function, as required.\n    grad_phi = np.gradient(phi, *deltas)\n    \n    # np.gradient returns a single array for 1D, must be in a list for uniform handling\n    if d == 1:\n        grad_phi = [grad_phi]\n\n    # 5. Calculate Numerical Electric Field E = -grad(phi)\n    E_field = [-g for g in grad_phi]\n\n    # 6. Calculate Numerical Current Density J = sigma * E\n    if np.isscalar(sigma):  # Isotropic case\n        J_field = [sigma * e for e in E_field]\n    else:  # Anisotropic case: J_i = sum_j(sigma_ij * E_j)\n        J_field = []\n        sigma_mat = np.array(sigma)\n        for i in range(d):\n            J_comp = np.zeros(N, dtype=np.float64)\n            for j in range(d):\n                J_comp += sigma_mat[i, j] * E_field[j]\n            J_field.append(J_comp)\n\n    # 7. Calculate Numerical Source Term S_J = J . E\n    S_J_num = np.zeros(N, dtype=np.float64)\n    for i in range(d):\n        S_J_num += J_field[i] * E_field[i]\n\n    # 8. Compute Maximum Absolute Deviation\n    max_abs_dev = np.max(np.abs(S_J_num - S_J_analytic))\n    \n    return max_abs_dev\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test 1: 1D, isotropic, typical resolution\n        {'d': 1, 'N': (51,), 'L': (0.7,), 'phi0': 2.0, 'a': (3.0,), 'sigma': 10.0},\n        \n        # Test 2: 2D, isotropic, mixed gradients\n        {'d': 2, 'N': (64, 32), 'L': (1.2, 0.8), 'phi0': 0.0, 'a': (5.0, -4.0), 'sigma': 2.0},\n        \n        # Test 3: 2D, anisotropic\n        {'d': 2, 'N': (33, 65), 'L': (0.5, 0.3), 'phi0': 1.0, 'a': (2.0, -4.0), \n         'sigma': [[5.0, 1.0], [1.0, 3.0]]},\n         \n        # Test 4: 3D, isotropic, zero field edge case\n        {'d': 3, 'N': (7, 9, 11), 'L': (0.1, 0.2, 0.3), 'phi0': 10.0, 'a': (0.0, 0.0, 0.0), \n         'sigma': 12.0},\n\n        # Test 5: 1D, isotropic, boundary-dominated coarse grid\n        {'d': 1, 'N': (2,), 'L': (1.0,), 'phi0': -3.0, 'a': (0.75,), 'sigma': 7.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        deviation = calculate_deviation(case['d'], case['N'], case['L'], case['phi0'], case['a'], case['sigma'])\n        results.append(deviation)\n\n    # Format and print the final output as specified\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "接下来，我们将处理一个高度非线性且物理上更复杂的源项：化学反应放热。本练习将探索 Arrhenius 动力学模型的实现，这是燃烧和化学工程模拟的基石。更关键的是，我们还将推导并实现该源项的雅可比矩阵（$\\partial S_{\\text{chem}}/\\partial T$），这是将其耦合到能够处理化学反应典型刚性（stiffness）问题的隐式数值求解器中的关键一步。",
            "id": "3962610",
            "problem": "考虑热能方程中出现的均匀反应混合物的体积化学放热源项，该源项被建模为所有基元反应的总和。设物种数量为 $N_{\\mathrm{s}}$，反应数量为 $N_{\\mathrm{r}}$。对于每个反应指数 $r \\in \\{1,\\dots,N_{\\mathrm{r}}\\}$，反应进程率根据质量分数通过阿伦尼乌斯幂律建模为\n$$\n\\dot{\\omega}_r(T,\\mathbf{Y}) \\;=\\; A_r \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\prod_{k=1}^{N_{\\mathrm{s}}} Y_k^{\\nu_{kr}},\n$$\n其中 $T$ 是绝对温度（单位：开尔文），$\\mathbf{Y} = (Y_1,\\dots,Y_{N_{\\mathrm{s}}})$ 是物种质量分数，$A_r$ 是指前因子，$E_r$ 是活化能，$R$ 是普适气体常数，$\\nu_{kr}\\ge 0$ 是反应级数。体积化学热源建模为\n$$\nS_{\\mathrm{chem}}(T,\\mathbf{Y}) \\;=\\; - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\,\\dot{\\omega}_r(T,\\mathbf{Y}),\n$$\n其中 $\\Delta H_r$ 是反应的摩尔焓（产物减去反应物），在此约定下，对于放热反应 $\\Delta H_r  0$。假设模型中，$A_r$、$E_r$、$\\Delta H_r$ 和 $\\nu_{kr}$ 相对于 $T$ 和 $\\mathbf{Y}$ 是常数，并且在隐式求解器中为进行 Newton-Raphson 耦合而对 $T$ 求导时，$\\mathbf{Y}$ 保持不变。\n\n任务 1 (推导): 从能量守恒和上述定义出发，推导在 $\\mathbf{Y}$ 固定的情况下，温度导数 $\\partial S_{\\mathrm{chem}}/\\partial T$ 的闭式表达式，该表达式应直接用 $\\{A_r,E_r,\\Delta H_r,\\nu_{kr},R,T,\\mathbf{Y}\\}$ 表示。您的推导必须从 $S_{\\mathrm{chem}}$ 的定义和基本微积分法则开始，而不是从任何预先给出的简化公式开始。\n\n任务 2 (实现): 实现一个程序，对于给定的输入 $(T,\\mathbf{Y},\\{A_r\\},\\{E_r\\},\\{\\Delta H_r\\},\\{\\nu_{kr}\\})$，使用您推导的表达式计算 $S_{\\mathrm{chem}}(T,\\mathbf{Y})$ 和导数 $\\partial S_{\\mathrm{chem}}/\\partial T$。使用普适气体常数 $R = 8.31446261815324\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$ (该值为 $8.31446261815324$)。您可以假设每个质量分数 $Y_k \\ge 0$ 且 $\\sum_k Y_k = 1$。即使 $Y_k=0$，任何零级依赖项 $Y_k^{0}$ 也应视为等于 $1$。\n\n单位：体积源项 $S_{\\mathrm{chem}}$ 必须以 $\\mathrm{W}\\,\\mathrm{m}^{-3}$ 为单位报告，导数 $\\partial S_{\\mathrm{chem}}/\\partial T$ 必须以 $\\mathrm{W}\\,\\mathrm{m}^{-3}\\,\\mathrm{K}^{-1}$ 为单位报告。使用的输入应确保最终单位一致；特别是，将 $\\Delta H_r$ 解释为单位 $\\mathrm{J}\\,\\mathrm{mol}^{-1}$，将 $\\dot{\\omega}_r$ 解释为单位 $\\mathrm{mol}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$，这样 $S_{\\mathrm{chem}}$ 的单位就是 $\\mathrm{J}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}=\\mathrm{W}\\,\\mathrm{m}^{-3}$。\n\n测试套件：您的程序必须为以下五个测试案例计算 $S_{\\mathrm{chem}}$ 和 $\\partial S_{\\mathrm{chem}}/\\partial T$，每个案例由 $(T,\\mathbf{Y},\\{A_r\\},\\{E_r\\},\\{\\Delta H_r\\},\\{\\nu_{kr}\\})$ 指定。\n\n- 案例 1 (基准，混合分数级):\n  - $N_{\\mathrm{s}} = 3$, $N_{\\mathrm{r}} = 2$。\n  - $T = 1200\\,\\mathrm{K}$ (即 $1200$)。\n  - $\\mathbf{Y} = [0.70,\\,0.20,\\,0.10]$。\n  - $\\{A_r\\} = [2.0\\times 10^{7},\\,1.0\\times 10^{8}]$。\n  - $\\{E_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [8.0\\times 10^{4},\\,1.2\\times 10^{5}]$。\n  - $\\{\\Delta H_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [-2.0\\times 10^{5},\\,-5.0\\times 10^{5}]$。\n  - $\\{\\nu_{kr}\\}$ 为一个矩阵，行代表反应:\n    - $r=1$: $[1.0,\\,1.0,\\,0.0]$，\n    - $r=2$: $[0.5,\\,0.5,\\,0.0]$。\n\n- 案例 2 (物种耗尽边界情况；由于质量分数为零导致反应速率消失):\n  - $N_{\\mathrm{s}} = 3$, $N_{\\mathrm{r}} = 2$。\n  - $T = 1000\\,\\mathrm{K}$ (即 $1000$)。\n  - $\\mathbf{Y} = [1.0,\\,0.0,\\,0.0]$。\n  - $\\{A_r\\} = [1.0\\times 10^{7},\\,3.0\\times 10^{7}]$。\n  - $\\{E_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [5.0\\times 10^{4},\\,1.0\\times 10^{5}]$。\n  - $\\{\\Delta H_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [-1.0\\times 10^{5},\\,-2.0\\times 10^{5}]$。\n  - $\\{\\nu_{kr}\\}$:\n    - $r=1$: $[1.0,\\,1.0,\\,0.0]$，\n    - $r=2$: $[2.0,\\,1.0,\\,0.0]$。\n\n- 案例 3 (一个反应的活化能为零；该反应对导数的贡献消失):\n  - $N_{\\mathrm{s}} = 3$, $N_{\\mathrm{r}} = 2$。\n  - $T = 900\\,\\mathrm{K}$ (即 $900$)。\n  - $\\mathbf{Y} = [0.50,\\,0.30,\\,0.20]$。\n  - $\\{A_r\\} = [3.0\\times 10^{3},\\,2.5\\times 10^{7}]$。\n  - $\\{E_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [0.0,\\,6.0\\times 10^{4}]$。\n  - $\\{\\Delta H_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [-4.0\\times 10^{5},\\,-3.0\\times 10^{5}]$。\n  - $\\{\\nu_{kr}\\}$:\n    - $r=1$: $[1.0,\\,0.0,\\,0.0]$，\n    - $r=2$: $[1.0,\\,1.0,\\,0.0]$。\n\n- 案例 4 (低温下的零级反应；包含一个吸热反应):\n  - $N_{\\mathrm{s}} = 3$, $N_{\\mathrm{r}} = 3$。\n  - $T = 300\\,\\mathrm{K}$ (即 $300$)。\n  - $\\mathbf{Y} = [0.20,\\,0.60,\\,0.20]$。\n  - $\\{A_r\\} = [4.0\\times 10^{8},\\,5.0\\times 10^{9},\\,1.0\\times 10^{7}]$。\n  - $\\{E_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [7.5\\times 10^{4},\\,1.1\\times 10^{5},\\,2.0\\times 10^{4}]$。\n  - $\\{\\Delta H_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [-1.0\\times 10^{5},\\,+2.0\\times 10^{5},\\,-5.0\\times 10^{4}]$。\n  - $\\{\\nu_{kr}\\}$:\n    - $r=1$: $[0.5,\\,0.5,\\,0.0]$，\n    - $r=2$: $[1.0,\\,1.0,\\,1.0]$，\n    - $r=3$: $[0.0,\\,0.0,\\,0.0]$。\n\n- 案例 5 (单一反应，对所有物种均为零级；纯粹由温度控制):\n  - $N_{\\mathrm{s}} = 3$, $N_{\\mathrm{r}} = 1$。\n  - $T = 1500\\,\\mathrm{K}$ (即 $1500$)。\n  - $\\mathbf{Y} = [0.40,\\,0.40,\\,0.20]$。\n  - $\\{A_r\\} = [8.0\\times 10^{6}]$。\n  - $\\{E_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [9.0\\times 10^{4}]$。\n  - $\\{\\Delta H_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [-1.5\\times 10^{5}]$。\n  - $\\{\\nu_{kr}\\}$:\n    - $r=1$: $[0.0,\\,0.0,\\,0.0]$。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试案例，输出一个双元素列表 $[S_{\\mathrm{chem}},\\,\\partial S_{\\mathrm{chem}}/\\partial T]$，单位如前述，每个值四舍五入到 $6$ 位小数，并且行中不包含任何空格。例如，总体输出应类似于 $[[v_{11},v_{12}],[v_{21},v_{22}],\\dots]$，其中 $v_{ij}$ 是十进制数。不应打印任何其他文本。",
            "solution": "该问题是有效的，因为它在科学上基于化学动力学和热力学，问题定义明确、客观，并为获得唯一解提供了所有必要信息。我们有两个任务目标：首先，推导化学热源项的温度导数 $\\partial S_{\\mathrm{chem}}/\\partial T$ 的表达式；其次，实现一个程序，为一组给定的测试案例计算 $S_{\\mathrm{chem}}$ 及其导数。\n\n### 任务 1：$\\partial S_{\\mathrm{chem}} / \\partial T$ 的推导\n\n体积化学热源 $S_{\\mathrm{chem}}$ 定义为混合物中所有基元反应释放或吸收热量的总和：\n$$\nS_{\\mathrm{chem}}(T,\\mathbf{Y}) \\;=\\; - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\,\\dot{\\omega}_r(T,\\mathbf{Y})\n$$\n其中 $\\Delta H_r$ 是反应 $r$ 的摩尔焓（常数），$\\dot{\\omega}_r$ 是反应 $r$ 的进程率。\n\n为了求 $S_{\\mathrm{chem}}$ 关于温度 $T$ 的偏导数，我们必须对上述表达式求导，同时保持质量分数向量 $\\mathbf{Y}$ 不变，正如题目所规定的。有限和的导数是导数的和。由于 $\\Delta H_r$ 是常数，它们可以从微分算子中提出：\n$$\n\\frac{\\partial S_{\\mathrm{chem}}}{\\partial T} = \\frac{\\partial}{\\partial T} \\left( - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\,\\dot{\\omega}_r(T,\\mathbf{Y}) \\right) = - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\, \\frac{\\partial \\dot{\\omega}_r}{\\partial T}\n$$\n\n下一步是求反应进程率 $\\dot{\\omega}_r$ 关于 $T$ 的导数。该速率由阿伦尼乌斯幂律表达式给出：\n$$\n\\dot{\\omega}_r(T,\\mathbf{Y}) \\;=\\; A_r \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\prod_{k=1}^{N_{\\mathrm{s}}} Y_k^{\\nu_{kr}}\n$$\n在这里，$A_r$ (指前因子)、$E_r$ (活化能)、$R$ (普适气体常数) 和 $\\nu_{kr}$ (反应级数) 都是常数。对于关于 $T$ 的偏导数，质量分数 $Y_k$ 也被视作常数。因此，乘积项 $\\prod_{k=1}^{N_{\\mathrm{s}}} Y_k^{\\nu_{kr}}$ 相对于 $T$ 是一个常数。我们将此乘积定义为与浓度相关的因子 $C_r(\\mathbf{Y})$：\n$$\nC_r(\\mathbf{Y}) = \\prod_{k=1}^{N_{\\mathrm{s}}} Y_k^{\\nu_{kr}}\n$$\n这使我们能够为了对 $T$ 求导而更紧凑地写出 $\\dot{\\omega}_r$：\n$$\n\\dot{\\omega}_r(T, \\mathbf{Y}) = A_r \\, C_r(\\mathbf{Y}) \\, \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right)\n$$\n\n现在我们对 $\\dot{\\omega}_r$ 求关于 $T$ 的导数。项 $A_r$ 和 $C_r(\\mathbf{Y})$ 是常数因子。\n$$\n\\frac{\\partial \\dot{\\omega}_r}{\\partial T} = A_r \\, C_r(\\mathbf{Y}) \\, \\frac{\\partial}{\\partial T} \\left( \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\right)\n$$\n我们应用链式法则进行求导。设指数的参数为 $u(T) = -E_r / (RT) = -(E_r/R)T^{-1}$。$\\exp(u(T))$ 关于 $T$ 的导数是 $\\exp(u(T)) \\cdot (du/dT)$。首先，我们计算 $du/dT$：\n$$\n\\frac{du}{dT} = \\frac{d}{dT} \\left( -\\frac{E_r}{R} T^{-1} \\right) = -\\frac{E_r}{R} (-1) T^{-2} = \\frac{E_r}{R T^2}\n$$\n将此代入指数项的导数中：\n$$\n\\frac{\\partial}{\\partial T} \\left( \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\right) = \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\cdot \\left(\\frac{E_r}{R T^2}\\right)\n$$\n现在，将此结果代入 $\\partial \\dot{\\omega}_r / \\partial T$ 的表达式中：\n$$\n\\frac{\\partial \\dot{\\omega}_r}{\\partial T} = A_r \\, C_r(\\mathbf{Y}) \\, \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\cdot \\left(\\frac{E_r}{R T^2}\\right)\n$$\n我们认识到项组 $A_r \\, C_r(\\mathbf{Y}) \\, \\exp\\left(-E_r/(RT)\\right)$ 正是原始的反应速率 $\\dot{\\omega}_r(T, \\mathbf{Y})$。这使得导数可以有一个紧凑的表示形式：\n$$\n\\frac{\\partial \\dot{\\omega}_r}{\\partial T} = \\dot{\\omega}_r(T,\\mathbf{Y}) \\cdot \\frac{E_r}{R T^2}\n$$\n\n最后，我们将 $\\partial \\dot{\\omega}_r / \\partial T$ 的这个表达式代回我们关于 $\\partial S_{\\mathrm{chem}} / \\partial T$ 的方程中：\n$$\n\\frac{\\partial S_{\\mathrm{chem}}}{\\partial T} = - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\left( \\dot{\\omega}_r(T,\\mathbf{Y}) \\cdot \\frac{E_r}{R T^2} \\right)\n$$\n整理各项，我们得到导数的最终闭式表达式：\n$$\n\\frac{\\partial S_{\\mathrm{chem}}}{\\partial T} = - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\, \\frac{E_r}{R T^2} \\, \\dot{\\omega}_r(T,\\mathbf{Y})\n$$\n这个表达式也可以用单个源项贡献 $S_{\\mathrm{chem}, r} = -\\Delta H_r \\dot{\\omega}_r$ 来写成：\n$$\n\\frac{\\partial S_{\\mathrm{chem}}}{\\partial T} = \\sum_{r=1}^{N_{\\mathrm{r}}} S_{\\mathrm{chem}, r}(T,\\mathbf{Y}) \\cdot \\frac{E_r}{R T^2}\n$$\n推导至此完成。结果完全由所提供的参数和变量表示。\n\n### 任务 2：实现\n\n该实现将使用推导出的公式为每个测试案例计算 $S_{\\mathrm{chem}}$ 和 $\\partial S_{\\mathrm{chem}}/\\partial T$。实现的核心是一个函数，该函数接受单个场景的参数（$T, \\mathbf{Y}, \\{A_r\\}, \\{E_r\\}, \\{\\Delta H_r\\}, \\{\\nu_{kr}\\}$）。在此函数内部，我们遍历每个反应 $r=1, \\dots, N_r$。对于每个反应，我们首先计算 $\\dot{\\omega}_r$。然后使用该值计算反应 $r$ 对 $S_{\\mathrm{chem}}$ 及其导数 $\\partial S_{\\mathrm{chem}}/\\partial T$ 的贡献。将这些贡献相加以获得总值。为了效率和清晰性，计算使用 NumPy 进行了矢量化。一个特殊情况，即 $Y_k^0=1$ 即使 $Y_k=0$，正如问题中所指定的，由 Python 和 NumPy 的 `**` 运算符自然处理，该运算符将 `0.0**0.0` 计算为 `1.0`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It defines the test cases, computes the results, and prints them\n    in the specified format.\n    \"\"\"\n\n    # Define the universal gas constant R in J/(mol*K)\n    R = 8.31446261815324\n\n    test_cases = [\n        # Case 1: baseline, mixed fractional orders\n        {\n            \"T\": 1200.0,\n            \"Y\": [0.70, 0.20, 0.10],\n            \"A\": [2.0e7, 1.0e8],\n            \"E\": [8.0e4, 1.2e5],\n            \"delta_H\": [-2.0e5, -5.0e5],\n            \"nu\": [[1.0, 1.0, 0.0], [0.5, 0.5, 0.0]],\n        },\n        # Case 2: species-depletion edge case\n        {\n            \"T\": 1000.0,\n            \"Y\": [1.0, 0.0, 0.0],\n            \"A\": [1.0e7, 3.0e7],\n            \"E\": [5.0e4, 1.0e5],\n            \"delta_H\": [-1.0e5, -2.0e5],\n            \"nu\": [[1.0, 1.0, 0.0], [2.0, 1.0, 0.0]],\n        },\n        # Case 3: zero activation energy\n        {\n            \"T\": 900.0,\n            \"Y\": [0.50, 0.30, 0.20],\n            \"A\": [3.0e3, 2.5e7],\n            \"E\": [0.0, 6.0e4],\n            \"delta_H\": [-4.0e5, -3.0e5],\n            \"nu\": [[1.0, 0.0, 0.0], [1.0, 1.0, 0.0]],\n        },\n        # Case 4: low temperature with zero-order and endothermic reaction\n        {\n            \"T\": 300.0,\n            \"Y\": [0.20, 0.60, 0.20],\n            \"A\": [4.0e8, 5.0e9, 1.0e7],\n            \"E\": [7.5e4, 1.1e5, 2.0e4],\n            \"delta_H\": [-1.0e5, 2.0e5, -5.0e4],\n            \"nu\": [[0.5, 0.5, 0.0], [1.0, 1.0, 1.0], [0.0, 0.0, 0.0]],\n        },\n        # Case 5: single, purely temperature-controlled reaction\n        {\n            \"T\": 1500.0,\n            \"Y\": [0.40, 0.40, 0.20],\n            \"A\": [8.0e6],\n            \"E\": [9.0e4],\n            \"delta_H\": [-1.5e5],\n            \"nu\": [[0.0, 0.0, 0.0]],\n        },\n    ]\n\n    def compute_source_and_derivative(T, Y_list, A_list, E_list, delta_H_list, nu_matrix):\n        \"\"\"\n        Computes the chemical source term S_chem and its temperature derivative.\n        \n        Args:\n            T (float): Temperature in Kelvin.\n            Y_list (list): List of species mass fractions.\n            A_list (list): List of pre-exponential factors.\n            E_list (list): List of activation energies in J/mol.\n            delta_H_list (list): List of molar enthalpies of reaction in J/mol.\n            nu_matrix (list of lists): Matrix of reaction orders (Nr x Ns).\n\n        Returns:\n            tuple: A tuple containing (S_chem, dS_chem_dT).\n        \"\"\"\n        # Convert inputs to NumPy arrays for vectorized operations\n        Y = np.array(Y_list)\n        A = np.array(A_list)\n        E = np.array(E_list)\n        delta_H = np.array(delta_H_list)\n        nu = np.array(nu_matrix)\n\n        # Calculate concentration-dependent part of reaction rate, C_r = prod(Y_k^nu_kr)\n        # Broadcasting Y (shape=(Ns,)) onto nu (shape=(Nr, Ns)) results in an array\n        # of shape (Nr, Ns). We then take the product along axis=1 (species axis).\n        # This correctly handles Y_k=0 cases, including the 0^0=1 convention.\n        conc_prods = np.prod(Y**nu, axis=1)\n\n        # Calculate Arrhenius exponential term\n        exp_terms = np.exp(-E / (R * T))\n\n        # Calculate reaction progress rates, dot(omega)_r\n        omega_dots = A * exp_terms * conc_prods\n\n        # Calculate individual reaction contributions to the source term S_chem,r\n        s_chem_terms = -delta_H * omega_dots\n\n        # Sum contributions to get total S_chem\n        s_chem = np.sum(s_chem_terms)\n        \n        # Calculate the derivative using the derived formula:\n        # dS_chem/dT = sum_r S_chem,r * E_r / (R * T^2)\n        # Note: (E / (R * T**2)) term can be zero if E_r=0, which is handled correctly.\n        ds_chem_dt_terms = s_chem_terms * E / (R * T**2)\n\n        # Sum contributions to get total derivative\n        ds_chem_dt = np.sum(ds_chem_dt_terms)\n        \n        return s_chem, ds_chem_dt\n\n    results_list = []\n    for case in test_cases:\n        s_chem, ds_chem_dt = compute_source_and_derivative(\n            case[\"T\"], case[\"Y\"], case[\"A\"], case[\"E\"], case[\"delta_H\"], case[\"nu\"]\n        )\n        # Format each pair of results as requested\n        results_list.append(f\"[{s_chem:.6f},{ds_chem_dt:.6f}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们以一个涉及历史依赖性的瞬态问题作为总结：相变过程中的潜热释放。通过使用焓法（enthalpy method），本练习演示了如何对源项依赖于状态变量变化率的现象进行建模。我们的重点将是确保数值实现的守恒性，即在整个模拟时间内，源项所交换的总能量与物相净变化所需的物理能量完全相等。",
            "id": "3962644",
            "problem": "给定一个空间均匀的单一控制体积，其温度随时间变化，并可能在指定的糊状区（mushy interval）内发生相变。您的任务是实现一个数值上一致的相变源项，并通过对源项进行时间积分来验证控制体积级别的能量守恒。从能量守恒第一性原理和焓的定义出发，设计一个与这些原理一致的离散算法。在所关注的时间间隔内，该控制体积具有恒定的密度和热物理性质。假设没有宏观运动，并忽略跨越边界的空间热通量，因此潜热贡献是能量平衡中唯一需要考虑的内部源项。\n\n使用以下基本原理：\n- 控制体积的能量守恒：总热能的时间变化率等于净增加的体积功率。用比焓表示总热能，其中比焓由显热部分和潜热部分组成。您可以假设比焓由基准显热贡献和取决于液相分数的潜热贡献之和给出。\n- 液相分数是温度的函数，由固相线和液相线温度界定的糊状区内的分段线性关系定义。\n\n构建一个与焓的潜热部分的时间变化率一致的、离散的、时间精确的相变源项表示。实现以下步骤：\n1. 对于每个测试用例，给定一个时间网格 $\\{t^n\\}_{n=0}^{N}$（不一定是均匀间隔的）、一个温度历史 $\\{T^n\\}_{n=0}^{N}$、密度 $\\rho$、控制体积 $V$、熔化潜热 $L$、固相线温度 $T_s$ 和液相线温度 $T_l$。\n2. 使用分段定义将温度映射到液相分数\n   - $f(T) = 0$，如果 $T \\le T_s$，\n   - $f(T) = 1$，如果 $T \\ge T_l$，\n   - $f(T) = \\dfrac{T - T_s}{T_l - T_s}$，如果 $T_s  T  T_l$。\n3. 在每个时间步长上定义一个一致的离散相变源功率，该功率表示由于液相分数变化导致控制体积中潜能交换的速率。您的设计必须源于焓的潜热部分的时间导数，并且仅使用离散时间 $\\{t^n\\}$ 和液相分数 $\\{f^n\\}$ 上的可用信息。\n4. 计算此离散源在整个时间间隔上的时间积分，以获得交换的总潜热 $Q_{\\text{int}}$（单位：焦耳）。\n5. 独立计算 $Q_{\\text{mass}}$，即基于在该时间间隔内发生相变的净质量所预期的潜热（单位：焦耳）。\n6. 报告每个测试用例的绝对误差 $|Q_{\\text{int}} - Q_{\\text{mass}}|$（单位：焦耳）。\n\n单位和符号约定：\n- 使用国际单位制。温度单位为开尔文，时间单位为秒，密度单位为千克/立方米，体积单位为立方米，潜热单位为焦耳/千克，能量单位为焦耳。\n- 定义液相分数 $f$ 随熔化而增加。正的源功率对应于为完成熔化而输入的能量；负值对应于凝固时释放的能量。\n\n测试套件：\n实现您的程序以评估以下五个测试用例。在每个用例中，计算 $Q_{\\text{int}}$ 和 $Q_{\\text{mass}}$，并输出绝对误差（单位：焦耳）。\n\n- 案例 A（穿越整个糊状区的线性变化）：\n  - $\\rho = 7800$, $V = 1\\cdot 10^{-6}$, $L = 2.7\\cdot 10^{5}$, $T_s = 600$, $T_l = 660$.\n  - 时间：$t^n = n$，对于 $n = 0,\\dots,200$（因此 $t \\in [0,200]$）。\n  - 温度：$T^n$ 从 $t^0$ 时的 $580$ 线性变化到 $t^{200}$ 时的 $680$。\n\n- 案例 B（无熔化，始终低于固相线）：\n  - $\\rho = 7800$, $V = 1\\cdot 10^{-6}$, $L = 2.7\\cdot 10^{5}$, $T_s = 600$, $T_l = 660$.\n  - 时间：$t^n = n$，对于 $n = 0,\\dots,100$（因此 $t \\in [0,100]$）。\n  - 温度：对于所有 $n$，$T^n = 590$。\n\n- 案例 C（糊状区内的部分熔化）：\n  - $\\rho = 900$, $V = 2\\cdot 10^{-5}$, $L = 2.0\\cdot 10^{5}$, $T_s = 320$, $T_l = 330$.\n  - 时间：$t^n = n$，对于 $n = 0,\\dots,50$（因此 $t \\in [0,50]$）。\n  - 温度：$T^n$ 从 $t^0$ 时的 $323$ 线性变化到 $t^{50}$ 时的 $328$。\n\n- 案例 D（从液相线以上再冻结至固相线以下）：\n  - $\\rho = 7800$, $V = 1\\cdot 10^{-6}$, $L = 2.7\\cdot 10^{5}$, $T_s = 600$, $T_l = 660$.\n  - 时间：$t^n = n$，对于 $n = 0,\\dots,200$（因此 $t \\in [0,200]$）。\n  - 温度：$T^n$ 从 $t^0$ 时的 $700$ 线性变化到 $t^{200}$ 时的 $580$。\n\n- 案例 E（非均匀时间步长，穿越糊状区）：\n  - $\\rho = 2700$, $V = 5\\cdot 10^{-6}$, $L = 3.97\\cdot 10^{5}$, $T_s = 855$, $T_l = 933$.\n  - 时间：$t = [0,1,2,4,7,11,16]$。\n  - 温度：$T = [840,850,860,900,920,940,950]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含案例 A 到 E 的绝对误差（单位：焦耳），格式为方括号内以逗号分隔的列表（例如，“[xA,xB,xC,xD,xE]”）。每个条目必须是浮点数（单位：焦耳）。不要打印任何其他文本。输出中的数字以焦耳表示，不带任何单位标签；问题陈述已指定了单位。",
            "solution": "此问题被验证为具有科学依据、提法恰当、客观且完整。它基于能量守恒的基本原理，并利用标准的焓法来模拟相变，这是计算热工学的一个基石。所有需要的数据和定义均已提供，任务是实现一个指定的数值算法并验证其守恒性质。我们现在可以开始求解。\n\n推导和实现遵循热力学关于控制体积的第一性原理。\n\n**1. 控制原理与焓公式**\n\n基本原理是控制体积的能量守恒，即体积内总能量 $E$ 的时间变化率等于能量净增加率 $\\dot{Q}$。对于一个空间均匀、密度 $\\rho$ 恒定且边界上无空间通量的控制体积 $V$，这表示为：\n$$ \\frac{dE}{dt} = P_{source} $$\n其中 $P_{source}$ 是来自内部源的总功率（单位：瓦特）。\n\n总热能 $E$ 由 $E = m h = (\\rho V) h$ 给出，其中 $h$ 是比焓。比焓由显热部分（与温度变化相关）和潜热部分（与相变相关）组成：\n$$ h(T) = h_{sensible}(T) + h_{latent}(T) $$\n本问题关注由潜热交换产生的源项。比焓的潜热部分定义为：\n$$ h_{latent}(T) = L f(T) $$\n其中 $L$ 是比熔化潜热（单位：J/kg），$f(T)$ 是液相分数，一个从 0（完全固态）到 1（完全液态）变化的无量纲量。\n\n**2. 相变源项的推导**\n\n由相变引起的源功率 $P_{source}$ 是控制体积中总潜能的时间变化率：\n$$ P_{source}(t) = \\frac{d}{dt} \\left[ \\int_V \\rho h_{latent}(T) \\, dV \\right] $$\n在空间均匀性和性质恒定的假设下，这简化为：\n$$ P_{source}(t) = \\rho V \\frac{d(h_{latent})}{dt} = \\rho V L \\frac{df(T)}{dt} $$\n该方程定义了相变过程中产生或消耗的瞬时功率。\n\n**3. 源项及其时间积分的离散化**\n\n为了数值上实现这一点，我们考虑一组离散的时间点 $\\{t^0, t^1, \\dots, t^N\\}$ 及其对应的温度 $\\{T^0, T^1, \\dots, T^N\\}$。\n\n首先，我们使用提供的分段线性函数计算每个时间点 $t^n$ 的液相分数 $f^n = f(T^n)$：\n$$\nf(T) =\n\\begin{cases}\n0  \\text{如果 } T \\le T_s \\\\\n\\dfrac{T - T_s}{T_l - T_s}  \\text{如果 } T_s  T  T_l \\\\\n1  \\text{如果 } T \\ge T_l\n\\end{cases}\n$$\n其中 $T_s$ 和 $T_l$ 分别是固相线温度和液相线温度。\n\n接下来，我们在每个时间间隔 $[t^n, t^{n+1}]$ 上定义源功率的离散表示。使用一阶有限差分来近似时间导数 $df/dt$，该时间间隔内的平均源功率 $P_{source}^n$ 为：\n$$ P_{source}^n = \\rho V L \\frac{f^{n+1} - f^n}{t^{n+1} - t^n} $$\n该表达式表示在时间步长 $\\Delta t^n = t^{n+1} - t^n$ 内潜能交换的平均速率。\n\n问题要求通过在整个时间间隔 $[t^0, t^N]$ 上对此离散源功率进行积分来计算交换的总潜能 $Q_{int}$。离散积分是每个时间步长内交换能量的总和：\n$$ Q_{int} = \\sum_{n=0}^{N-1} (\\text{平均功率}_n) \\times (\\text{时间步长}_n) = \\sum_{n=0}^{N-1} P_{source}^n \\Delta t^n $$\n代入 $P_{source}^n$ 的表达式：\n$$ Q_{int} = \\sum_{n=0}^{N-1} \\left( \\rho V L \\frac{f^{n+1} - f^n}{t^{n+1} - t^n} \\right) (t^{n+1} - t^n) $$\n\n**4. 能量守恒的验证**\n\n$Q_{int}$ 的表达式呈现为一个伸缩求和。时间步长 $\\Delta t^n = (t^{n+1} - t^n)$ 在求和的每一项中都被解析地消掉了：\n$$ Q_{int} = \\rho V L \\sum_{n=0}^{N-1} (f^{n+1} - f^n) $$\n$$ Q_{int} = \\rho V L \\left[ (f^1 - f^0) + (f^2 - f^1) + \\dots + (f^N - f^{N-1}) \\right] $$\n中间项相互抵消，得到：\n$$ Q_{int} = \\rho V L (f^N - f^0) $$\n\n这个结果表明，所选择的离散源项公式是精确守恒的。通过数值积分计算出的总潜能仅取决于液相分数的初始状态（$f^0$）和最终状态（$f^N$），而与中间路径或时间步长的大小无关。\n\n为了验证这一点，我们根据相的净变化计算预期的能量交换 $Q_{mass}$。控制体积的总质量是 $m = \\rho V$。从固相变为液相的净质量是 $m \\cdot (f^N - f^0)$。相关的潜能是：\n$$ Q_{mass} = [m (f^N - f^0)] \\cdot L = \\rho V L (f^N - f^0) $$\n\n通过直接比较，我们看到 $Q_{int} = Q_{mass}$。因此，绝对误差 $|Q_{int} - Q_{mass}|$ 在解析上为零。实现将明确遵循求和过程，以遵守问题步骤。任何产生的非零误差都将完全归因于数字计算中固有的浮点运算不精确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the phase change source term problem for five test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: Ramp through full mushy interval\n        {\n            \"rho\": 7800.0, \"V\": 1.0e-6, \"L\": 2.7e5, \"Ts\": 600.0, \"Tl\": 660.0,\n            \"t\": np.arange(201, dtype=float),\n            \"T\": np.linspace(580.0, 680.0, 201)\n        },\n        # Case B: No melting, always below solidus\n        {\n            \"rho\": 7800.0, \"V\": 1.0e-6, \"L\": 2.7e5, \"Ts\": 600.0, \"Tl\": 660.0,\n            \"t\": np.arange(101, dtype=float),\n            \"T\": np.full(101, 590.0)\n        },\n        # Case C: Partial melting within mushy band\n        {\n            \"rho\": 900.0, \"V\": 2.0e-5, \"L\": 2.0e5, \"Ts\": 320.0, \"Tl\": 330.0,\n            \"t\": np.arange(51, dtype=float),\n            \"T\": np.linspace(323.0, 328.0, 51)\n        },\n        # Case D: Refreezing from above liquidus to below solidus\n        {\n            \"rho\": 7800.0, \"V\": 1.0e-6, \"L\": 2.7e5, \"Ts\": 600.0, \"Tl\": 660.0,\n            \"t\": np.arange(201, dtype=float),\n            \"T\": np.linspace(700.0, 580.0, 201)\n        },\n        # Case E: Nonuniform time steps, crossing the mushy interval\n        {\n            \"rho\": 2700.0, \"V\": 5.0e-6, \"L\": 3.97e5, \"Ts\": 855.0, \"Tl\": 933.0,\n            \"t\": np.array([0.0, 1.0, 2.0, 4.0, 7.0, 11.0, 16.0]),\n            \"T\": np.array([840.0, 850.0, 860.0, 900.0, 920.0, 940.0, 950.0])\n        }\n    ]\n\n    results = []\n    \n    def liquid_fraction(T_vals, T_s, T_l):\n        \"\"\"\n        Computes the liquid fraction based on temperature using a piecewise linear model.\n        Handles scalar or numpy array inputs for temperature.\n        \"\"\"\n        # Ensure robustness against T_l = T_s, although not present in test cases.\n        if T_l == T_s:\n            return np.where(T_vals > T_s, 1.0, 0.0)\n        \n        # Calculate liquid fraction in the mushy zone\n        f = (T_vals - T_s) / (T_l - T_s)\n        \n        # Clip the result to the range [0, 1] for temperatures outside the mushy zone\n        return np.clip(f, 0.0, 1.0)\n\n    for case in test_cases:\n        rho, V, L, Ts, Tl = case[\"rho\"], case[\"V\"], case[\"L\"], case[\"Ts\"], case[\"Tl\"]\n        t, T_hist = case[\"t\"], case[\"T\"]\n        \n        # Step 2: Map temperature to liquid fraction\n        f_vals = liquid_fraction(T_hist, Ts, Tl)\n        \n        # Step 3  4: Define discrete source power and compute its time integral Q_int\n        # Calculate changes in time and liquid fraction over each step\n        dt_vals = np.diff(t)\n        df_vals = np.diff(f_vals)\n        \n        # Create a mask to handle dt=0, although not expected in these test cases\n        mask = dt_vals != 0\n        P_source_vals = np.zeros_like(dt_vals)\n        \n        # Calculate discrete power P = rho*V*L*(df/dt) for each step\n        P_source_vals[mask] = rho * V * L * (df_vals[mask] / dt_vals[mask])\n        \n        # Integrate power over time: Q_int = sum(P_n * dt_n)\n        Q_int = np.sum(P_source_vals * dt_vals)\n        \n        # Step 5: Independently compute expected latent heat Q_mass\n        f_initial = f_vals[0]\n        f_final = f_vals[-1]\n        Q_mass = rho * V * L * (f_final - f_initial)\n        \n        # Step 6: Report the absolute error\n        error = np.abs(Q_int - Q_mass)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}