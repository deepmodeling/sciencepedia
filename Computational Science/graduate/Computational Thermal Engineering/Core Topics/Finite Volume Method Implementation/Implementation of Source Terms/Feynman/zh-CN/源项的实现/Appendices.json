{
    "hands_on_practices": [
        {
            "introduction": "在计算热工学中，确保数值实现准确无误是至关重要的第一步。本练习将指导您完成一个基础但关键的实践：焦耳热源项的代码验证。我们将从一个给定的电势场出发，通过数值方法计算焦耳热源 $S_J = \\mathbf{J} \\cdot \\mathbf{E}$，并将其与精确的解析解进行比较，这是一种被称为“制造解法”的验证技术。这个过程不仅能加深您对源项离散化的理解，还能培养严谨的软件验证思维。",
            "id": "3962599",
            "problem": "要求您在均匀介质中的直流（DC）传导问题中，实现并验证一个体积焦耳热源项的数值实现。验证的重点是电势为线性函数的案例，这意味着整个区域内电场是均匀的，因此焦耳热源项也是均匀的。目标是从离散化的电势场计算源项，并将其与根据基本定律推导出的解析期望值进行比较。\n\n使用的基本原理：\n- 稳态传导的欧姆定律：电流密度由 $\\mathbf{J} = \\boldsymbol{\\sigma}\\,\\mathbf{E}$ 给出，其中 $\\boldsymbol{\\sigma}$ 是标量电导率或对称正定电导率张量，$\\mathbf{E}$ 是电场。\n- 电场是电势的负梯度：$\\mathbf{E} = -\\nabla \\phi$。\n- 体积焦耳热率（源项）为 $S_J = \\mathbf{J} \\cdot \\mathbf{E}$，单位为 $\\mathrm{W/m^3}$。\n\n场景：\n- 考虑 $\\mathbb{R}^d$ 中的一个矩形均匀域，该域具有均匀网格和单元中心变量。设电势为线性函数 $\\phi(\\mathbf{x}) = \\phi_0 + \\sum_{i=1}^d a_i x_i$，其中 $\\phi_0$ 和 $a_i$ 是常数。这将在整个域内产生一个均匀电场 $\\mathbf{E} = -(a_1, a_2, \\dots, a_d)$ 和一个均匀的焦耳热源 $S_J$。\n- 对于各向同性电导率（标量）$\\sigma$，$S_J$ 是一个常数，等于 $\\sigma \\sum_{i=1}^d a_i^2$。\n- 对于各向异性电导率（张量）$\\boldsymbol{\\sigma} \\in \\mathbb{R}^{d \\times d}$，且为对称正定张量，$S_J$ 是一个常数，等于 $\\mathbf{E}^\\mathsf{T} \\boldsymbol{\\sigma} \\mathbf{E} = \\mathbf{a}^\\mathsf{T} \\boldsymbol{\\sigma} \\mathbf{a}$，其中 $\\mathbf{a} = (a_1,\\dots,a_d)$。\n\n您的任务：\n- 实现一个程序，该程序构建均匀网格，在单元中心计算线性电势，使用适合单元中心数据的相容有限差分格式计算数值梯度，计算电场和电流密度，并在每个单元中将焦耳热源项形式化为 $\\mathbf{J} \\cdot \\mathbf{E}$。\n- 对每个测试案例，将计算出的场 $S_J(\\mathbf{x})$ 与解析的均匀值进行比较，并报告所有单元上的最大绝对偏差。最终偏差以 $\\mathrm{W/m^3}$ 表示。\n\n数值细节：\n- 在域长度为 $(L_x, L_y, L_z)$ 上使用单元中心网格，每个维度的单元数为 $N_x, N_y, N_z$。\n- 在内部单元使用二阶中心差分，在域边界使用相容的单边差分，这样线性电势可以产生精确的离散梯度。\n\n单位：\n- 电导率 $\\sigma$ 和张量分量的单位是 $\\mathrm{S/m}$。\n- 电势 $\\phi$ 的单位是 $\\mathrm{V}$。\n- 电场 $\\mathbf{E}$ 的单位是 $\\mathrm{V/m}$。\n- 焦耳热源 $S_J$ 的单位是 $\\mathrm{W/m^3}$。\n- 偏差以 $\\mathrm{W/m^3}$ 为单位，并以浮点数形式报告。\n\n测试套件：\n实现以下 $5$ 个测试案例。对每个案例，数值计算 $S_J$ 并报告单个数字 $\\max_{\\text{cells}} |S_J^{\\text{num}} - S_J^{\\text{analytic}}|$，单位为 $\\mathrm{W/m^3}$。\n\n- 测试 $1$（一维，各向同性，典型分辨率）：\n  - 维度 $d = 1$。\n  - $N_x = 51$，$L_x = 0.7$ $\\mathrm{m}$。\n  - $\\phi_0 = 2.0$ $\\mathrm{V}$，$a_1 = 3.0$ $\\mathrm{V/m}$。\n  - $\\sigma = 10.0$ $\\mathrm{S/m}$。\n- 测试 $2$（二维，各向同性，混合梯度）：\n  - 维度 $d = 2$。\n  - $(N_x, N_y) = (64, 32)$，$(L_x, L_y) = (1.2, 0.8)$ $\\mathrm{m}$。\n  - $\\phi_0 = 0.0$ $\\mathrm{V}$，$(a_1, a_2) = (5.0, -4.0)$ $\\mathrm{V/m}$。\n  - $\\sigma = 2.0$ $\\mathrm{S/m}$。\n- 测试 $3$（二维，各向异性电导率张量）：\n  - 维度 $d = 2$。\n  - $(N_x, N_y) = (33, 65)$，$(L_x, L_y) = (0.5, 0.3)$ $\\mathrm{m}$。\n  - $\\phi_0 = 1.0$ $\\mathrm{V}$，$(a_1, a_2) = (2.0, -4.0)$ $\\mathrm{V/m}$。\n  - $\\boldsymbol{\\sigma} = \\begin{bmatrix} 5.0  1.0 \\\\ 1.0  3.0 \\end{bmatrix}$ $\\mathrm{S/m}$。\n- 测试 $4$（三维，各向同性，零场边界情况）：\n  - 维度 $d = 3$。\n  - $(N_x, N_y, N_z) = (7, 9, 11)$，$(L_x, L_y, L_z) = (0.1, 0.2, 0.3)$ $\\mathrm{m}$。\n  - $\\phi_0 = 10.0$ $\\mathrm{V}$，$(a_1, a_2, a_3) = (0.0, 0.0, 0.0)$ $\\mathrm{V/m}$。\n  - $\\sigma = 12.0$ $\\mathrm{S/m}$。\n- 测试 $5$（一维，各向同性，边界主导的粗网格）：\n  - 维度 $d = 1$。\n  - $N_x = 2$，$L_x = 1.0$ $\\mathrm{m}$。\n  - $\\phi_0 = -3.0$ $\\mathrm{V}$，$a_1 = 0.75$ $\\mathrm{V/m}$。\n  - $\\sigma = 7.0$ $\\mathrm{S/m}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[result1,result2,result3,result4,result5]\"）。每个条目必须是相应测试案例的最大绝对偏差，以 $\\mathrm{W/m^3}$ 为单位的浮点数表示。",
            "solution": "该问题要求在一个均匀介质中的直流传导问题中，对体积焦耳热源项 $S_J$ 进行数值实现和验证。验证基于一个特定案例，即电势 $\\phi$ 是位置的线性函数，这简化了解析计算，并为数值格式提供了一个清晰的基准。\n\n基础物理学由三个原理给出。首先，欧姆定律将电流密度矢量 $\\mathbf{J}$ 与电场矢量 $\\mathbf{E}$ 和电导率 $\\boldsymbol{\\sigma}$ 联系起来，即 $\\mathbf{J} = \\boldsymbol{\\sigma}\\,\\mathbf{E}$。对于各向同性材料，电导率 $\\boldsymbol{\\sigma}$ 可以是标量 $\\sigma$；对于各向异性材料，则为张量。其次，电场被定义为标量电势的负梯度，即 $\\mathbf{E} = -\\nabla \\phi$。第三，体积焦耳热率（在热能平衡中充当源项）由点积 $S_J = \\mathbf{J} \\cdot \\mathbf{E}$ 给出。将前两个关系式代入第三个，得到 $S_J = (-\\nabla\\phi)^\\mathsf{T} \\boldsymbol{\\sigma} (-\\nabla\\phi) = (\\nabla\\phi)^\\mathsf{T} \\boldsymbol{\\sigma} (\\nabla\\phi)$。\n\n问题指定了一个形式为 $\\phi(\\mathbf{x}) = \\phi_0 + \\sum_{i=1}^d a_i x_i$ 的线性电势场，其中 $\\mathbf{x}=(x_1, \\dots, x_d)$，$\\phi_0$ 和 $a_i$ 是常数。该电势的梯度是一个常数向量，$\\nabla\\phi = (a_1, a_2, \\dots, a_d) = \\mathbf{a}$。因此，整个域内的电场是均匀的：$\\mathbf{E} = -\\mathbf{a}$。这种均匀性会传递到电流密度 $\\mathbf{J} = -\\boldsymbol{\\sigma}\\mathbf{a}$ 和焦耳热源项 $S_J$。因此，解析源项 $S_J^{\\text{analytic}}$ 是一个常数值，由 $S_J^{\\text{analytic}} = (-\\mathbf{a}) \\cdot (-\\boldsymbol{\\sigma}\\mathbf{a}) = \\mathbf{a}^\\mathsf{T} \\boldsymbol{\\sigma} \\mathbf{a}$ 给出。对于各向同性情况，其中 $\\boldsymbol{\\sigma}$ 是标量 $\\sigma$ 乘以单位矩阵，这简化为 $S_J^{\\text{analytic}} = \\sigma (\\mathbf{a} \\cdot \\mathbf{a}) = \\sigma \\sum_{i=1}^d a_i^2$。\n\n数值任务是离散化域，在每个离散单元上计算源项 $S_J^{\\text{num}}$，并验证其是否与常数解析值 $S_J^{\\text{analytic}}$ 相匹配。验证的核心在于梯度的数值计算 $\\nabla\\phi$。问题要求使用对线性电势精确的有限差分格式。这是一个关键要求。一个满足此属性的数值梯度算子，当应用于离散电势场 $\\phi_{i,j,\\dots}$ 时，将产生一个离散电场 $\\mathbf{E}^{\\text{num}}$，该电场在整个网格上是均匀的，并且在机器精度范围内等于解析场 $-\\mathbf{a}$。\n\n算法流程如下：\n$1$。对于每个测试案例，定义域维度 $(L_x, L_y, \\dots)$、单元数 $(N_x, N_y, \\dots)$、电势系数 $(\\phi_0, a_1, a_2, \\dots)$ 和电导率 $\\sigma$ 或 $\\boldsymbol{\\sigma}$。\n$2$。构建一个均匀的、以单元为中心的网格。对于每个维度 $k \\in \\{x, y, z\\}$，单元尺寸为 $\\Delta_k = L_k / N_k$，单元中心坐标为 $x_{k,i} = (i + 0.5)\\Delta_k$，其中 $i \\in \\{0, 1, \\dots, N_k-1\\}$。在多维情况下，使用这些坐标向量生成多维坐标数组。\n$3$。在每个单元中心计算线性电势 $\\phi(\\mathbf{x})$，创建一个势值的多维数组 $\\boldsymbol{\\Phi}$。\n$4$。使用适当的公式计算解析源项 $S_J^{\\text{analytic}}$，对于各向同性情况使用 $\\sigma \\sum a_i^2$，对于各向异性情况使用 $\\mathbf{a}^\\mathsf{T} \\boldsymbol{\\sigma} \\mathbf{a}$。这将产生一个单一的标量值。\n$5$。计算电势场 $\\boldsymbol{\\Phi}$ 的数值梯度。我们采用一种在域内部为二阶精确、在边界为一阶精确的有限差分格式。所使用的中心和单边差分模板对于线性函数都是精确的，满足了问题的要求。`numpy.gradient` 函数实现了这样一种格式，使其成为一个合适的工具。此步骤为梯度的每个分量生成数组，例如 $(\\nabla\\phi)_x$, $(\\nabla\\phi)_y$ 等。\n$6$。根据梯度计算每个单元处电场矢量的分量，$\\mathbf{E}^{\\text{num}} = -\\nabla^{\\text{num}} \\phi$。每个分量 $E_k^{\\text{num}}$ 都是一个多维数组。\n$7$。计算电流密度矢量 $\\mathbf{J}^{\\text{num}} = \\boldsymbol{\\sigma} \\mathbf{E}^{\\text{num}}$ 的分量。在各向同性情况下，这是一个简单的缩放：$J_k^{\\text{num}} = \\sigma E_k^{\\text{num}}$。在各向异性情况下，这是在每个网格点上的矩阵-向量乘法：$J_i^{\\text{num}} = \\sum_j \\sigma_{ij} E_j^{\\text{num}}$。\n$8$。计算数值源项 $S_J^{\\text{num}} = \\mathbf{J}^{\\text{num}} \\cdot \\mathbf{E}^{\\text{num}} = \\sum_k J_k^{\\text{num}} E_k^{\\text{num}}$。这将产生一个多维数组，其中每个元素是相应单元中的源项值。\n$9$。最终的验证步骤是计算数值源项场与常数解析值之间的最大绝对偏差：$\\max | S_J^{\\text{num}} - S_J^{\\text{analytic}} |$。由于所选的数值梯度格式对于给定的线性电势是精确的，所有后续的数值计算也应该是精确的，仅因浮点舍入误差而与解析解有所不同。因此，预期的偏差是一个非常接近于 $0$ 的值。\n\n此过程应用于所提供的全部 $5$ 个测试案例，这些案例涵盖了一维、二维和三维，各向同性和各向异性电导率，非零场和零场，以及不同分辨率的网格，包括一个用于测试边界条件处理的粗糙 $2$ 单元网格。然后报告每种情况的最大绝对偏差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_deviation(d, N, L, phi0, a, sigma):\n    \"\"\"\n    Calculates the maximum absolute deviation of the numerical Joule heating source term.\n\n    Args:\n        d (int): Number of spatial dimensions.\n        N (tuple): Number of cells in each dimension (Nx, Ny, ...).\n        L (tuple): Length of the domain in each dimension (Lx, Ly, ...).\n        phi0 (float): Constant offset for the potential function.\n        a (tuple): Coefficients of the linear terms in the potential function.\n        sigma (float or list of lists): Electrical conductivity (scalar for isotropic,\n                                        matrix for anisotropic).\n\n    Returns:\n        float: The maximum absolute deviation between the numerical and analytical\n               source terms over all cells.\n    \"\"\"\n    # 1. Create Grid\n    deltas = tuple(L[i] / N[i] for i in range(d))\n    \n    # Create 1D coordinate vectors for cell centers\n    coord_vectors = [np.linspace(0.5 * deltas[i], L[i] - 0.5 * deltas[i], N[i]) for i in range(d)]\n    \n    # Create multidimensional coordinate grids\n    if d > 1:\n        coord_grids = np.meshgrid(*coord_vectors, indexing='ij')\n    else:\n        coord_grids = coord_vectors\n\n    # 2. Evaluate Potential Field\n    phi = np.full(N, phi0, dtype=np.float64)\n    for i in range(d):\n        phi += a[i] * coord_grids[i]\n\n    # 3. Calculate Analytical Source Term\n    a_vec = np.array(a)\n    if np.isscalar(sigma):  # Isotropic case\n        S_J_analytic = sigma * np.dot(a_vec, a_vec)\n    else:  # Anisotropic case\n        sigma_mat = np.array(sigma)\n        S_J_analytic = a_vec.T @ sigma_mat @ a_vec\n\n    # 4. Calculate Numerical Gradient\n    # np.gradient uses 2nd-order central differences for interior and\n    # 1st-order one-sided differences for boundaries. Both are exact\n    # for a linear function, as required.\n    grad_phi = np.gradient(phi, *deltas)\n    \n    # np.gradient returns a single array for 1D, must be in a list for uniform handling\n    if d == 1:\n        grad_phi = [grad_phi]\n\n    # 5. Calculate Numerical Electric Field E = -grad(phi)\n    E_field = [-g for g in grad_phi]\n\n    # 6. Calculate Numerical Current Density J = sigma * E\n    if np.isscalar(sigma):  # Isotropic case\n        J_field = [sigma * e for e in E_field]\n    else:  # Anisotropic case: J_i = sum_j(sigma_ij * E_j)\n        J_field = []\n        sigma_mat = np.array(sigma)\n        for i in range(d):\n            J_comp = np.zeros(N, dtype=np.float64)\n            for j in range(d):\n                J_comp += sigma_mat[i, j] * E_field[j]\n            J_field.append(J_comp)\n\n    # 7. Calculate Numerical Source Term S_J = J . E\n    S_J_num = np.zeros(N, dtype=np.float64)\n    for i in range(d):\n        S_J_num += J_field[i] * E_field[i]\n\n    # 8. Compute Maximum Absolute Deviation\n    max_abs_dev = np.max(np.abs(S_J_num - S_J_analytic))\n    \n    return max_abs_dev\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test 1: 1D, isotropic, typical resolution\n        {'d': 1, 'N': (51,), 'L': (0.7,), 'phi0': 2.0, 'a': (3.0,), 'sigma': 10.0},\n        \n        # Test 2: 2D, isotropic, mixed gradients\n        {'d': 2, 'N': (64, 32), 'L': (1.2, 0.8), 'phi0': 0.0, 'a': (5.0, -4.0), 'sigma': 2.0},\n        \n        # Test 3: 2D, anisotropic\n        {'d': 2, 'N': (33, 65), 'L': (0.5, 0.3), 'phi0': 1.0, 'a': (2.0, -4.0), \n         'sigma': [[5.0, 1.0], [1.0, 3.0]]},\n         \n        # Test 4: 3D, isotropic, zero field edge case\n        {'d': 3, 'N': (7, 9, 11), 'L': (0.1, 0.2, 0.3), 'phi0': 10.0, 'a': (0.0, 0.0, 0.0), \n         'sigma': 12.0},\n\n        # Test 5: 1D, isotropic, boundary-dominated coarse grid\n        {'d': 1, 'N': (2,), 'L': (1.0,), 'phi0': -3.0, 'a': (0.75,), 'sigma': 7.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        deviation = calculate_deviation(case['d'], case['N'], case['L'], case['phi0'], case['a'], case['sigma'])\n        results.append(deviation)\n\n    # Format and print the final output as specified\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本源项的实现后，我们转向更复杂的多物理场问题，例如燃烧和化学反应流。本练习聚焦于化学反应释放的热量，这是一个高度非线性的源项，其实现是许多高级模拟的核心。您将实践如何实现基于阿伦尼乌斯定律的反应速率，并推导和计算其对温度的偏导数 $\\frac{\\partial S_{\\text{chem}}}{\\partial T}$ 。这个导数（雅可比项）对于保证隐式求解器的稳定性和收敛性至关重要。",
            "id": "3962610",
            "problem": "考虑热能方程中出现的均匀反应混合物的体积化学放热源项，其模型为所有基元反应的总和。设物种数量为 $N_{\\mathrm{s}}$，反应数量为 $N_{\\mathrm{r}}$。对于每个反应指数 $r \\in \\{1,\\dots,N_{\\mathrm{r}}\\}$，反应进度速率由关于质量分数的阿伦尼乌斯幂律建模为\n$$\n\\dot{\\omega}_r(T,\\mathbf{Y}) \\;=\\; A_r \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\prod_{k=1}^{N_{\\mathrm{s}}} Y_k^{\\nu_{kr}},\n$$\n其中 $T$ 是绝对温度（单位：开尔文），$\\mathbf{Y} = (Y_1,\\dots,Y_{N_{\\mathrm{s}}})$ 是物种质量分数，$A_r$ 是指前因子，$E_r$ 是活化能，$R$ 是普适气体常数，$\\nu_{kr}\\ge 0$ 是反应级数。体积化学热源模型为\n$$\nS_{\\mathrm{chem}}(T,\\mathbf{Y}) \\;=\\; - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\,\\dot{\\omega}_r(T,\\mathbf{Y}),\n$$\n其中 $\\Delta H_r$ 是反应的摩尔焓（产物减去反应物），在此约定中，对于放热反应 $\\Delta H_r  0$。在模型中，假设 $A_r$、$E_r$、$\\Delta H_r$ 和 $\\nu_{kr}$ 是关于 $T$ 和 $\\mathbf{Y}$ 的常数，并且在为隐式求解器中的 Newton-Raphson 耦合对 $T$ 求导时，$\\mathbf{Y}$ 保持固定。\n\n任务 1 (推导)：从能量守恒和上述定义出发，推导在固定 $\\mathbf{Y}$ 条件下温度导数 $\\partial S_{\\mathrm{chem}}/\\partial T$ 的闭式表达式，该表达式应直接用 $\\{A_r,E_r,\\Delta H_r,\\nu_{kr},R,T,\\mathbf{Y}\\}$ 表示。您的推导必须从 $S_{\\mathrm{chem}}$ 的定义和基本微积分法则开始，而不是从任何预先给出的捷径公式开始。\n\n任务 2 (实现)：实现一个程序，对于给定的输入 $(T,\\mathbf{Y},\\{A_r\\},\\{E_r\\},\\{\\Delta H_r\\},\\{\\nu_{kr}\\})$，使用您推导的表达式计算 $S_{\\mathrm{chem}}(T,\\mathbf{Y})$ 和导数 $\\partial S_{\\mathrm{chem}}/\\partial T$。使用普适气体常数 $R = 8.31446261815324\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$ (该值为 $8.31446261815324$)。您可以假设每个质量分数 $Y_k \\ge 0$ 且 $\\sum_k Y_k = 1$。即使 $Y_k=0$，也应将任何零级依赖 $Y_k^{0}$ 视为等于 $1$。\n\n单位：体积源项 $S_{\\mathrm{chem}}$ 必须以 $\\mathrm{W}\\,\\mathrm{m}^{-3}$ 报告，导数 $\\partial S_{\\mathrm{chem}}/\\partial T$ 以 $\\mathrm{W}\\,\\mathrm{m}^{-3}\\,\\mathrm{K}^{-1}$ 报告。使用的输入应使结果单位一致；特别是，将 $\\Delta H_r$ 解释为 $\\mathrm{J}\\,\\mathrm{mol}^{-1}$，将 $\\dot{\\omega}_r$ 解释为 $\\mathrm{mol}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$，这样 $S_{\\mathrm{chem}}$ 的单位就是 $\\mathrm{J}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}=\\mathrm{W}\\,\\mathrm{m}^{-3}$。\n\n测试套件：您的程序必须为以下五个测试用例计算 $S_{\\mathrm{chem}}$ 和 $\\partial S_{\\mathrm{chem}}/\\partial T$，每个用例由 $(T,\\mathbf{Y},\\{A_r\\},\\{E_r\\},\\{\\Delta H_r\\},\\{\\nu_{kr}\\})$ 指定。\n\n- 用例 1 (基准，混合分数级)：\n  - $N_{\\mathrm{s}} = 3$, $N_{\\mathrm{r}} = 2$。\n  - $T = 1200\\,\\mathrm{K}$ (即 $1200$)。\n  - $\\mathbf{Y} = [0.70,\\,0.20,\\,0.10]$。\n  - $\\{A_r\\} = [2.0\\times 10^{7},\\,1.0\\times 10^{8}]$。\n  - $\\{E_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [8.0\\times 10^{4},\\,1.2\\times 10^{5}]$。\n  - $\\{\\Delta H_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [-2.0\\times 10^{5},\\,-5.0\\times 10^{5}]$。\n  - $\\{\\nu_{kr}\\}$ 为一个矩阵，行为反应：\n    - $r=1$: $[1.0,\\,1.0,\\,0.0]$，\n    - $r=2$: $[0.5,\\,0.5,\\,0.0]$。\n\n- 用例 2 (物种耗尽边缘情况；由于质量分数为零导致速率消失)：\n  - $N_{\\mathrm{s}} = 3$, $N_{\\mathrm{r}} = 2$。\n  - $T = 1000\\,\\mathrm{K}$ (即 $1000$)。\n  - $\\mathbf{Y} = [1.0,\\,0.0,\\,0.0]$。\n  - $\\{A_r\\} = [1.0\\times 10^{7},\\,3.0\\times 10^{7}]$。\n  - $\\{E_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [5.0\\times 10^{4},\\,1.0\\times 10^{5}]$。\n  - $\\{\\Delta H_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [-1.0\\times 10^{5},\\,-2.0\\times 10^{5}]$。\n  - $\\{\\nu_{kr}\\}$:\n    - $r=1$: $[1.0,\\,1.0,\\,0.0]$，\n    - $r=2$: $[2.0,\\,1.0,\\,0.0]$。\n\n- 用例 3 (一个反应的活化能为零；该反应的导数贡献消失)：\n  - $N_{\\mathrm{s}} = 3$, $N_{\\mathrm{r}} = 2$。\n  - $T = 900\\,\\mathrm{K}$ (即 $900$)。\n  - $\\mathbf{Y} = [0.50,\\,0.30,\\,0.20]$。\n  - $\\{A_r\\} = [3.0\\times 10^{3},\\,2.5\\times 10^{7}]$。\n  - $\\{E_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [0.0,\\,6.0\\times 10^{4}]$。\n  - $\\{\\Delta H_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [-4.0\\times 10^{5},\\,-3.0\\times 10^{5}]$。\n  - $\\{\\nu_{kr}\\}$:\n    - $r=1$: $[1.0,\\,0.0,\\,0.0]$，\n    - $r=2$: $[1.0,\\,1.0,\\,0.0]$。\n\n- 用例 4 (低温下的零级反应；包含一个吸热反应)：\n  - $N_{\\mathrm{s}} = 3$, $N_{\\mathrm{r}} = 3$。\n  - $T = 300\\,\\mathrm{K}$ (即 $300$)。\n  - $\\mathbf{Y} = [0.20,\\,0.60,\\,0.20]$。\n  - $\\{A_r\\} = [4.0\\times 10^{8},\\,5.0\\times 10^{9},\\,1.0\\times 10^{7}]$。\n  - $\\{E_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [7.5\\times 10^{4},\\,1.1\\times 10^{5},\\,2.0\\times 10^{4}]$。\n  - $\\{\\Delta H_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [-1.0\\times 10^{5},\\,+2.0\\times 10^{5},\\,-5.0\\times 10^{4}]$。\n  - $\\{\\nu_{kr}\\}$:\n    - $r=1$: $[0.5,\\,0.5,\\,0.0]$，\n    - $r=2$: $[1.0,\\,1.0,\\,1.0]$，\n    - $r=3$: $[0.0,\\,0.0,\\,0.0]$。\n\n- 用例 5 (单一反应，对所有物种均为零级；纯粹由温度控制)：\n  - $N_{\\mathrm{s}} = 3$, $N_{\\mathrm{r}} = 1$。\n  - $T = 1500\\,\\mathrm{K}$ (即 $1500$)。\n  - $\\mathbf{Y} = [0.40,\\,0.40,\\,0.20]$。\n  - $\\{A_r\\} = [8.0\\times 10^{6}]$。\n  - $\\{E_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [9.0\\times 10^{4}]$。\n  - $\\{\\Delta H_r\\}\\,(\\mathrm{J}\\,\\mathrm{mol}^{-1}) = [-1.5\\times 10^{5}]$。\n  - $\\{\\nu_{kr}\\}$:\n    - $r=1$: $[0.0,\\,0.0,\\,0.0]$。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。对于每个测试用例，输出一个双元素列表 $[S_{\\mathrm{chem}},\\,\\partial S_{\\mathrm{chem}}/\\partial T]$，单位如前所述，每个值四舍五入到 $6$ 位小数，并且行中不含任何空格。例如，总体输出应类似于 $[[v_{11},v_{12}],[v_{21},v_{22}],\\dots]$，其中 $v_{ij}$ 是十进制数。不应打印其他任何文本。",
            "solution": "该问题是有效的，因为它在化学动力学和热力学方面有科学依据，问题提出得当、客观，并为获得唯一解提供了所有必要信息。我们有两个任务目标：首先，推导化学热源项的温度导数表达式 $\\partial S_{\\mathrm{chem}}/\\partial T$；其次，实现一个程序，为一组给定的测试用例计算 $S_{\\mathrm{chem}}$ 及其导数。\n\n### 任务 1：$\\partial S_{\\mathrm{chem}} / \\partial T$ 的推导\n\n体积化学热源 $S_{\\mathrm{chem}}$ 定义为混合物中所有基元反应放出或吸收的热量总和：\n$$\nS_{\\mathrm{chem}}(T,\\mathbf{Y}) \\;=\\; - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\,\\dot{\\omega}_r(T,\\mathbf{Y})\n$$\n其中 $\\Delta H_r$ 是反应 $r$ 的摩尔焓（常数），$\\dot{\\omega}_r$ 是反应 $r$ 的进度速率。\n\n为了求 $S_{\\mathrm{chem}}$ 对温度 $T$ 的偏导数，我们必须对上述表达式求导，同时按要求保持质量分数向量 $\\mathbf{Y}$ 恒定。有限和的导数是导数的和。由于 $\\Delta H_r$ 是常数，它们可以从微分算子中提出：\n$$\n\\frac{\\partial S_{\\mathrm{chem}}}{\\partial T} = \\frac{\\partial}{\\partial T} \\left( - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\,\\dot{\\omega}_r(T,\\mathbf{Y}) \\right) = - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\, \\frac{\\partial \\dot{\\omega}_r}{\\partial T}\n$$\n\n下一步是求反应进度速率 $\\dot{\\omega}_r$ 对 $T$ 的导数。该速率由阿伦尼乌斯幂律表达式给出：\n$$\n\\dot{\\omega}_r(T,\\mathbf{Y}) \\;=\\; A_r \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\prod_{k=1}^{N_{\\mathrm{s}}} Y_k^{\\nu_{kr}}\n$$\n这里，$A_r$（指前因子）、$E_r$（活化能）、$R$（普适气体常数）和 $\\nu_{kr}$（反应级数）都是常数。对于对 $T$ 的偏导数，质量分数 $Y_k$ 也被视为常数。因此，乘积项 $\\prod_{k=1}^{N_{\\mathrm{s}}} Y_k^{\\nu_{kr}}$ 是一个关于 $T$ 的常数。让我们将此乘积定义为浓度依赖因子 $C_r(\\mathbf{Y})$：\n$$\nC_r(\\mathbf{Y}) = \\prod_{k=1}^{N_{\\mathrm{s}}} Y_k^{\\nu_{kr}}\n$$\n这使我们能够更紧凑地写出 $\\dot{\\omega}_r$，以便对 $T$ 进行微分：\n$$\n\\dot{\\omega}_r(T, \\mathbf{Y}) = A_r \\, C_r(\\mathbf{Y}) \\, \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right)\n$$\n\n现在我们对 $\\dot{\\omega}_r$ 关于 $T$ 求导。项 $A_r$ 和 $C_r(\\mathbf{Y})$ 是常数因子。\n$$\n\\frac{\\partial \\dot{\\omega}_r}{\\partial T} = A_r \\, C_r(\\mathbf{Y}) \\, \\frac{\\partial}{\\partial T} \\left( \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\right)\n$$\n我们应用链式法则求导。设指数的参数为 $u(T) = -E_r / (RT) = -(E_r/R)T^{-1}$。$\\exp(u(T))$ 对 $T$ 的导数是 $\\exp(u(T)) \\cdot (du/dT)$。首先，我们计算 $du/dT$：\n$$\n\\frac{du}{dT} = \\frac{d}{dT} \\left( -\\frac{E_r}{R} T^{-1} \\right) = -\\frac{E_r}{R} (-1) T^{-2} = \\frac{E_r}{R T^2}\n$$\n将此代入指数项的导数中：\n$$\n\\frac{\\partial}{\\partial T} \\left( \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\right) = \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\cdot \\left(\\frac{E_r}{R T^2}\\right)\n$$\n现在，将此结果代入 $\\partial \\dot{\\omega}_r / \\partial T$ 的表达式中：\n$$\n\\frac{\\partial \\dot{\\omega}_r}{\\partial T} = A_r \\, C_r(\\mathbf{Y}) \\, \\exp\\!\\left(-\\dfrac{E_r}{R\\,T}\\right) \\cdot \\left(\\frac{E_r}{R T^2}\\right)\n$$\n我们认识到项组 $A_r \\, C_r(\\mathbf{Y}) \\, \\exp\\left(-E_r/(RT)\\right)$ 就是原始的反应速率 $\\dot{\\omega}_r(T, \\mathbf{Y})$。这使得导数可以紧凑地表示：\n$$\n\\frac{\\partial \\dot{\\omega}_r}{\\partial T} = \\dot{\\omega}_r(T,\\mathbf{Y}) \\cdot \\frac{E_r}{R T^2}\n$$\n\n最后，我们将 $\\partial \\dot{\\omega}_r / \\partial T$ 的这个表达式代回到我们关于 $\\partial S_{\\mathrm{chem}} / \\partial T$ 的方程中：\n$$\n\\frac{\\partial S_{\\mathrm{chem}}}{\\partial T} = - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\left( \\dot{\\omega}_r(T,\\mathbf{Y}) \\cdot \\frac{E_r}{R T^2} \\right)\n$$\n整理各项，我们得到导数的最终闭式表达式：\n$$\n\\frac{\\partial S_{\\mathrm{chem}}}{\\partial T} = - \\sum_{r=1}^{N_{\\mathrm{r}}} \\Delta H_r \\, \\frac{E_r}{R T^2} \\, \\dot{\\omega}_r(T,\\mathbf{Y})\n$$\n这个表达式也可以用各个源项贡献 $S_{\\mathrm{chem}, r} = -\\Delta H_r \\dot{\\omega}_r$ 来写成：\n$$\n\\frac{\\partial S_{\\mathrm{chem}}}{\\partial T} = \\sum_{r=1}^{N_{\\mathrm{r}}} S_{\\mathrm{chem}, r}(T,\\mathbf{Y}) \\cdot \\frac{E_r}{R T^2}\n$$\n推导至此完成。结果完全用所提供的参数和变量表示。\n\n### 任务 2：实现\n\n实现部分将使用推导出的公式为每个测试用例计算 $S_{\\mathrm{chem}}$ 和 $\\partial S_{\\mathrm{chem}}/\\partial T$。实现的核心是一个函数，该函数接受单个场景的参数（$T, \\mathbf{Y}, \\{A_r\\}, \\{E_r\\}, \\{\\Delta H_r\\}, \\{\\nu_{kr}\\}$）。在此函数内部，我们遍历每个反应 $r=1, \\dots, N_r$。对于每个反应，我们首先计算 $\\dot{\\omega}_r$。然后使用此值计算反应 $r$ 对 $S_{\\mathrm{chem}}$ 及其导数 $\\partial S_{\\mathrm{chem}}/\\partial T$ 的贡献。将这些贡献相加以获得总值。为了效率和清晰度，使用 NumPy 对计算进行向量化。问题中指定的特殊情况，即即使 $Y_k=0$ 时 $Y_k^0=1$，Python 和 NumPy 的 `**` 运算符可以自然处理，该运算符将 `0.0**0.0` 计算为 `1.0`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It defines the test cases, computes the results, and prints them\n    in the specified format.\n    \"\"\"\n\n    # Define the universal gas constant R in J/(mol*K)\n    R = 8.31446261815324\n\n    test_cases = [\n        # Case 1: baseline, mixed fractional orders\n        {\n            \"T\": 1200.0,\n            \"Y\": [0.70, 0.20, 0.10],\n            \"A\": [2.0e7, 1.0e8],\n            \"E\": [8.0e4, 1.2e5],\n            \"delta_H\": [-2.0e5, -5.0e5],\n            \"nu\": [[1.0, 1.0, 0.0], [0.5, 0.5, 0.0]],\n        },\n        # Case 2: species-depletion edge case\n        {\n            \"T\": 1000.0,\n            \"Y\": [1.0, 0.0, 0.0],\n            \"A\": [1.0e7, 3.0e7],\n            \"E\": [5.0e4, 1.0e5],\n            \"delta_H\": [-1.0e5, -2.0e5],\n            \"nu\": [[1.0, 1.0, 0.0], [2.0, 1.0, 0.0]],\n        },\n        # Case 3: zero activation energy\n        {\n            \"T\": 900.0,\n            \"Y\": [0.50, 0.30, 0.20],\n            \"A\": [3.0e3, 2.5e7],\n            \"E\": [0.0, 6.0e4],\n            \"delta_H\": [-4.0e5, -3.0e5],\n            \"nu\": [[1.0, 0.0, 0.0], [1.0, 1.0, 0.0]],\n        },\n        # Case 4: low temperature with zero-order and endothermic reaction\n        {\n            \"T\": 300.0,\n            \"Y\": [0.20, 0.60, 0.20],\n            \"A\": [4.0e8, 5.0e9, 1.0e7],\n            \"E\": [7.5e4, 1.1e5, 2.0e4],\n            \"delta_H\": [-1.0e5, 2.0e5, -5.0e4],\n            \"nu\": [[0.5, 0.5, 0.0], [1.0, 1.0, 1.0], [0.0, 0.0, 0.0]],\n        },\n        # Case 5: single, purely temperature-controlled reaction\n        {\n            \"T\": 1500.0,\n            \"Y\": [0.40, 0.40, 0.20],\n            \"A\": [8.0e6],\n            \"E\": [9.0e4],\n            \"delta_H\": [-1.5e5],\n            \"nu\": [[0.0, 0.0, 0.0]],\n        },\n    ]\n\n    def compute_source_and_derivative(T, Y_list, A_list, E_list, delta_H_list, nu_matrix):\n        \"\"\"\n        Computes the chemical source term S_chem and its temperature derivative.\n        \n        Args:\n            T (float): Temperature in Kelvin.\n            Y_list (list): List of species mass fractions.\n            A_list (list): List of pre-exponential factors.\n            E_list (list): List of activation energies in J/mol.\n            delta_H_list (list): List of molar enthalpies of reaction in J/mol.\n            nu_matrix (list of lists): Matrix of reaction orders (Nr x Ns).\n\n        Returns:\n            tuple: A tuple containing (S_chem, dS_chem_dT).\n        \"\"\"\n        # Convert inputs to NumPy arrays for vectorized operations\n        Y = np.array(Y_list)\n        A = np.array(A_list)\n        E = np.array(E_list)\n        delta_H = np.array(delta_H_list)\n        nu = np.array(nu_matrix)\n\n        # Calculate concentration-dependent part of reaction rate, C_r = prod(Y_k^nu_kr)\n        # Broadcasting Y (shape=(Ns,)) onto nu (shape=(Nr, Ns)) results in an array\n        # of shape (Nr, Ns). We then take the product along axis=1 (species axis).\n        # This correctly handles Y_k=0 cases, including the 0^0=1 convention.\n        conc_prods = np.prod(Y**nu, axis=1)\n\n        # Calculate Arrhenius exponential term\n        exp_terms = np.exp(-E / (R * T))\n\n        # Calculate reaction progress rates, dot(omega)_r\n        omega_dots = A * exp_terms * conc_prods\n\n        # Calculate individual reaction contributions to the source term S_chem,r\n        s_chem_terms = -delta_H * omega_dots\n\n        # Sum contributions to get total S_chem\n        s_chem = np.sum(s_chem_terms)\n        \n        # Calculate the derivative using the derived formula:\n        # dS_chem/dT = sum_r S_chem,r * E_r / (R * T^2)\n        # Note: (E / (R * T**2)) term can be zero if E_r=0, which is handled correctly.\n        ds_chem_dt_terms = s_chem_terms * E / (R * T**2)\n\n        # Sum contributions to get total derivative\n        ds_chem_dt = np.sum(ds_chem_dt_terms)\n        \n        return s_chem, ds_chem_dt\n\n    results_list = []\n    for case in test_cases:\n        s_chem, ds_chem_dt = compute_source_and_derivative(\n            case[\"T\"], case[\"Y\"], case[\"A\"], case[\"E\"], case[\"delta_H\"], case[\"nu\"]\n        )\n        # Format each pair of results as requested\n        results_list.append(f\"[{s_chem:.6f},{ds_chem_dt:.6f}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了空间相关的源项，许多问题还涉及由系统状态随时间变化而产生的瞬态源项。本练习将探讨相变过程（如熔化和凝固）的建模，这是一个典型的例子。您将使用“焓法”来实现潜热源项，该源项与液相分数的时间变化率直接相关。本实践的核心是验证您的数值实现是否满足能量守恒，即源项在时间上积分得到的总能量与理论上因相变而吸收或释放的总潜热完全相等。",
            "id": "3962644",
            "problem": "给定一个空间上均匀的单一控制体，其温度随时间变化，并可能在预设的糊状区内发生相变。您的任务是实现一个数值上一致的相变源项，并通过对源项进行时间积分来验证控制体层面的能量守恒。从能量守恒的第一性原理和焓的定义出发，设计一个与这些原理一致的离散算法。在所研究的时间间隔内，该控制体具有恒定的密度和热物理性质。假设没有宏观运动，并忽略跨越边界的空间热通量，因此潜热贡献是能量平衡中唯一需要考虑的内源项。\n\n使用以下基本原理：\n- 控制体的能量守恒：总热能的时间变化率等于净增加的体积功率。用比焓表示总热能，其中比焓由显热部分和潜热部分组成。您可以假设比焓由基准显热贡献和依赖于液相分数的潜热贡献之和给出。\n- 液相分数是温度的函数，通过一个由固相线和液相线温度界定的糊状区内的分段线性关系来定义。\n\n构建一个与焓的潜热部分的时间变化率相一致的相变源项的离散、时间精确表示。实现以下步骤：\n1. 对于每个测试案例，给定一个时间网格 $\\{t^n\\}_{n=0}^{N}$（不一定是均匀间隔的）、一个温度历史 $\\{T^n\\}_{n=0}^{N}$、密度 $\\rho$、控制体体积 $V$、熔化潜热 $L$、固相线温度 $T_s$ 和液相线温度 $T_l$。\n2. 使用分段定义将温度映射到液相分数\n   - 若 $T \\le T_s$，则 $f(T) = 0$\n   - 若 $T \\ge T_l$，则 $f(T) = 1$\n   - 若 $T_s  T  T_l$，则 $f(T) = \\dfrac{T - T_s}{T_l - T_s}$\n3. 在每个时间步长上定义一个一致的离散相变源功率，该功率代表由于液相分数变化而在控制体中交换潜能的速率。您的设计必须遵循焓的潜热部分的时间导数，并且仅使用在离散时间 $\\{t^n\\}$ 和液相分数 $\\{f^n\\}$ 可用的信息。\n4. 计算此离散源在整个时间间隔上的时间积分，以获得总交换潜热 $Q_{\\text{int}}$（单位：焦耳）。\n5. 独立计算 $Q_{\\text{mass}}$，即基于在整个时间间隔内发生相变的净质量所预期的潜热（单位：焦耳）。\n6. 报告每个测试案例的绝对误差 $|Q_{\\text{int}} - Q_{\\text{mass}}|$（单位：焦耳）。\n\n单位和符号约定：\n- 使用国际单位制。温度单位为开尔文，时间单位为秒，密度单位为千克/立方米，体积单位为立方米，潜热单位为焦耳/千克，能量单位为焦耳。\n- 定义液相分数 $f$ 随熔化而增加。正的源功率对应于为完成熔化而输入的能量；负值对应于凝固时释放的能量。\n\n测试套件：\n实现您的程序以评估以下五个测试案例。在每个案例中，计算 $Q_{\\text{int}}$ 和 $Q_{\\text{mass}}$，并输出绝对误差（单位：焦耳）。\n\n- 案例 A（斜坡式地穿过整个糊状区）：\n  - $\\rho = 7800$, $V = 1\\cdot 10^{-6}$, $L = 2.7\\cdot 10^{5}$, $T_s = 600$, $T_l = 660$.\n  - 时间：$t^n = n$，其中 $n = 0,\\dots,200$（因此 $t \\in [0,200]$）。\n  - 温度：$T^n$ 从 $t^0$ 时的 $580$ 线性变化到 $t^{200}$ 时的 $680$。\n\n- 案例 B（无熔化，始终低于固相线）：\n  - $\\rho = 7800$, $V = 1\\cdot 10^{-6}$, $L = 2.7\\cdot 10^{5}$, $T_s = 600$, $T_l = 660$.\n  - 时间：$t^n = n$，其中 $n = 0,\\dots,100$（因此 $t \\in [0,100]$）。\n  - 温度：对于所有 $n$，$T^n = 590$。\n\n- 案例 C（在糊状区内的部分熔化）：\n  - $\\rho = 900$, $V = 2\\cdot 10^{-5}$, $L = 2.0\\cdot 10^{5}$, $T_s = 320$, $T_l = 330$.\n  - 时间：$t^n = n$，其中 $n = 0,\\dots,50$（因此 $t \\in [0,50]$）。\n  - 温度：$T^n$ 从 $t^0$ 时的 $323$ 线性变化到 $t^{50}$ 时的 $328$。\n\n- 案例 D（从液相线以上再冻结至固相线以下）：\n  - $\\rho = 7800$, $V = 1\\cdot 10^{-6}$, $L = 2.7\\cdot 10^{5}$, $T_s = 600$, $T_l = 660$.\n  - 时间：$t^n = n$，其中 $n = 0,\\dots,200$（因此 $t \\in [0,200]$）。\n  - 温度：$T^n$ 从 $t^0$ 时的 $700$ 线性变化到 $t^{200}$ 时的 $580$。\n\n- 案例 E（非均匀时间步长，穿过糊状区）：\n  - $\\rho = 2700$, $V = 5\\cdot 10^{-6}$, $L = 3.97\\cdot 10^{5}$, $T_s = 855$, $T_l = 933$.\n  - 时间：$t = [0,1,2,4,7,11,16]$。\n  - 温度：$T = [840,850,860,900,920,940,950]$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含案例 A 到 E 的绝对误差（单位为焦耳），格式为方括号内以逗号分隔的列表（例如，“[xA,xB,xC,xD,xE]”）。每个条目必须是浮点数（单位为焦耳）。不要打印任何额外的文本。在输出中以焦耳表示数值，不带任何单位标签；问题陈述已指定单位。",
            "solution": "此问题被验证为科学上合理、适定、客观和完整。它基于能量守恒的基本原理，并利用标准的焓法来模拟相变，这是计算热工学的基石。所有必需的数据和定义均已提供，任务是实现一个指定的数值算法并验证其守恒性质。我们现在可以开始求解。\n\n推导和实现遵循控制体热力学的第一性原理。\n\n**1. 控制原理与焓公式**\n\n基本原理是控制体的能量守恒，即体积内总能量 $E$ 的时间变化率等于能量增加的净速率 $\\dot{Q}$。对于一个空间均匀、密度 $\\rho$ 恒定且边界上无空间通量的控制体 $V$，这可以表示为：\n$$ \\frac{dE}{dt} = P_{source} $$\n其中 $P_{source}$ 是来自内源的总功率（单位：瓦特）。\n\n总热能 $E$ 由 $E = m h = (\\rho V) h$ 给出，其中 $h$ 是比焓。比焓由显热部分（与温度变化相关）和潜热部分（与相变相关）组成：\n$$ h(T) = h_{sensible}(T) + h_{latent}(T) $$\n该问题关注的是由潜热交换产生的源项。比焓的潜热部分定义为：\n$$ h_{latent}(T) = L f(T) $$\n其中 $L$ 是比熔化潜热（单位：J/kg），$f(T)$ 是液相分数，一个从 $0$（完全固态）到 $1$（完全液态）变化的无量纲量。\n\n**2. 相变源项的推导**\n\n由相变引起的源功率 $P_{source}$ 是控制体中总潜能的时间变化率：\n$$ P_{source}(t) = \\frac{d}{dt} \\left[ \\int_V \\rho h_{latent}(T) \\, dV \\right] $$\n考虑到空间均匀性和性质恒定的假设，上式简化为：\n$$ P_{source}(t) = \\rho V \\frac{d(h_{latent})}{dt} = \\rho V L \\frac{df(T)}{dt} $$\n该方程定义了在相变过程中产生或消耗的瞬时功率。\n\n**3. 源项的离散化及其时间积分**\n\n为了在数值上实现这一点，我们考虑一组离散的时间点 $\\{t^0, t^1, \\dots, t^N\\}$ 及其对应的温度 $\\{T^0, T^1, \\dots, T^N\\}$。\n\n首先，我们使用提供的分段线性函数在每个时间点 $t^n$ 计算液相分数 $f^n = f(T^n)$：\n$$\nf(T) =\n\\begin{cases}\n0  \\text{若 } T \\le T_s \\\\\n\\dfrac{T - T_s}{T_l - T_s}  \\text{若 } T_s  T  T_l \\\\\n1  \\text{若 } T \\ge T_l\n\\end{cases}\n$$\n其中 $T_s$ 和 $T_l$ 分别是固相线和液相线温度。\n\n接下来，我们在每个时间间隔 $[t^n, t^{n+1}]$ 上定义源功率的离散表示。使用一阶有限差分来近似时间导数 $df/dt$，该时间间隔内的平均源功率 $P_{source}^n$ 为：\n$$ P_{source}^n = \\rho V L \\frac{f^{n+1} - f^n}{t^{n+1} - t^n} $$\n此表达式表示在时间步长 $\\Delta t^n = t^{n+1} - t^n$ 内潜能交换的平均速率。\n\n问题要求通过在整个时间间隔 $[t^0, t^N]$ 上对此离散源功率进行积分来计算总交换潜热 $Q_{int}$。离散积分是每个时间步长中交换的能量的总和：\n$$ Q_{int} = \\sum_{n=0}^{N-1} (\\text{平均功率}_n) \\times (\\text{时间步长}_n) = \\sum_{n=0}^{N-1} P_{source}^n \\Delta t^n $$\n代入 $P_{source}^n$ 的表达式：\n$$ Q_{int} = \\sum_{n=0}^{N-1} \\left( \\rho V L \\frac{f^{n+1} - f^n}{t^{n+1} - t^n} \\right) (t^{n+1} - t^n) $$\n\n**4. 能量守恒的验证**\n\n$Q_{int}$ 的表达式揭示了一个伸缩求和。时间步长 $\\Delta t^n = (t^{n+1} - t^n)$ 在求和的每一项中解析上相互抵消：\n$$ Q_{int} = \\rho V L \\sum_{n=0}^{N-1} (f^{n+1} - f^n) $$\n$$ Q_{int} = \\rho V L \\left[ (f^1 - f^0) + (f^2 - f^1) + \\dots + (f^N - f^{N-1}) \\right] $$\n中间项相互抵消，得到：\n$$ Q_{int} = \\rho V L (f^N - f^0) $$\n\n这一结果表明，所选的离散源项公式是精确守恒的。通过数值积分计算出的总潜能仅取决于液相分数的初始状态（$f^0$）和最终状态（$f^N$），而与中间路径或时间步长的大小无关。\n\n为了验证这一点，我们根据相的净变化来计算预期的能量交换 $Q_{mass}$。控制体的总质量为 $m = \\rho V$。从固相变为液相的净质量为 $m \\cdot (f^N - f^0)$。相关的潜能为：\n$$ Q_{mass} = [m (f^N - f^0)] \\cdot L = \\rho V L (f^N - f^0) $$\n\n通过直接比较，我们看到 $Q_{int} = Q_{mass}$。因此，绝对误差 $|Q_{int} - Q_{mass}|$ 在解析上为零。实现将明确遵循求和过程以遵守问题步骤。任何产生的非零误差将完全归因于数字计算中固有的浮点数运算误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the phase change source term problem for five test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: Ramp through full mushy interval\n        {\n            \"rho\": 7800.0, \"V\": 1.0e-6, \"L\": 2.7e5, \"Ts\": 600.0, \"Tl\": 660.0,\n            \"t\": np.arange(201, dtype=float),\n            \"T\": np.linspace(580.0, 680.0, 201)\n        },\n        # Case B: No melting, always below solidus\n        {\n            \"rho\": 7800.0, \"V\": 1.0e-6, \"L\": 2.7e5, \"Ts\": 600.0, \"Tl\": 660.0,\n            \"t\": np.arange(101, dtype=float),\n            \"T\": np.full(101, 590.0)\n        },\n        # Case C: Partial melting within mushy band\n        {\n            \"rho\": 900.0, \"V\": 2.0e-5, \"L\": 2.0e5, \"Ts\": 320.0, \"Tl\": 330.0,\n            \"t\": np.arange(51, dtype=float),\n            \"T\": np.linspace(323.0, 328.0, 51)\n        },\n        # Case D: Refreezing from above liquidus to below solidus\n        {\n            \"rho\": 7800.0, \"V\": 1.0e-6, \"L\": 2.7e5, \"Ts\": 600.0, \"Tl\": 660.0,\n            \"t\": np.arange(201, dtype=float),\n            \"T\": np.linspace(700.0, 580.0, 201)\n        },\n        # Case E: Nonuniform time steps, crossing the mushy interval\n        {\n            \"rho\": 2700.0, \"V\": 5.0e-6, \"L\": 3.97e5, \"Ts\": 855.0, \"Tl\": 933.0,\n            \"t\": np.array([0.0, 1.0, 2.0, 4.0, 7.0, 11.0, 16.0]),\n            \"T\": np.array([840.0, 850.0, 860.0, 900.0, 920.0, 940.0, 950.0])\n        }\n    ]\n\n    results = []\n    \n    def liquid_fraction(T_vals, T_s, T_l):\n        \"\"\"\n        Computes the liquid fraction based on temperature using a piecewise linear model.\n        Handles scalar or numpy array inputs for temperature.\n        \"\"\"\n        # Ensure robustness against T_l = T_s, although not present in test cases.\n        if T_l == T_s:\n            return np.where(T_vals  T_s, 1.0, 0.0)\n        \n        # Calculate liquid fraction in the mushy zone\n        f = (T_vals - T_s) / (T_l - T_s)\n        \n        # Clip the result to the range [0, 1] for temperatures outside the mushy zone\n        return np.clip(f, 0.0, 1.0)\n\n    for case in test_cases:\n        rho, V, L, Ts, Tl = case[\"rho\"], case[\"V\"], case[\"L\"], case[\"Ts\"], case[\"Tl\"]\n        t, T_hist = case[\"t\"], case[\"T\"]\n        \n        # Step 2: Map temperature to liquid fraction\n        f_vals = liquid_fraction(T_hist, Ts, Tl)\n        \n        # Step 3  4: Define discrete source power and compute its time integral Q_int\n        # Calculate changes in time and liquid fraction over each step\n        dt_vals = np.diff(t)\n        df_vals = np.diff(f_vals)\n        \n        # Create a mask to handle dt=0, although not expected in these test cases\n        mask = dt_vals != 0\n        P_source_vals = np.zeros_like(dt_vals)\n        \n        # Calculate discrete power P = rho*V*L*(df/dt) for each step\n        P_source_vals[mask] = rho * V * L * (df_vals[mask] / dt_vals[mask])\n        \n        # Integrate power over time: Q_int = sum(P_n * dt_n)\n        Q_int = np.sum(P_source_vals * dt_vals)\n        \n        # Step 5: Independently compute expected latent heat Q_mass\n        f_initial = f_vals[0]\n        f_final = f_vals[-1]\n        Q_mass = rho * V * L * (f_final - f_initial)\n        \n        # Step 6: Report the absolute error\n        error = np.abs(Q_int - Q_mass)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}