{
    "hands_on_practices": [
        {
            "introduction": "在计算热工学中，显式时间积分格式因其实现简单而备受青睐。然而，这种便利性的代价是其稳定性受限于严格的条件，如果时间步长 $\\Delta t$ 相对于网格尺寸选择不当，数值解可能会出现非物理的振荡，甚至导致计算发散。本练习  旨在通过一个瞬态热扩散问题，实践如何确定最大允许的稳定时间步长，将前处理中的网格设计与求解器设置直接联系起来，这是防止数值不稳定、确保获得有效解的基本功。",
            "id": "3983557",
            "problem": "一个一维瞬态热扩散问题将使用显式前向欧拉时间积分和二阶中心空间差分进行模拟。物理域是一根长度为 $L = 0.36$ $\\mathrm{m}$ 的杆，其热扩散系数为常数 $\\alpha = 1.4 \\times 10^{-5}$ $\\mathrm{m^2/s}$。作为前处理的一部分，通过拉伸映射 $x_i = L \\left(\\frac{i}{N}\\right)^2$（其中 $i = 0, 1, \\dots, N$，$N = 12$）生成了一个非均匀网格。求解器对所有单元使用单一的全局统一时间步长 $\\Delta t$，并通过使用网格中的最小空间步长 $h$ 作为特征间距来约束 $\\Delta t$，从而保证稳定性。后处理将计算约束最强的单元处的无量纲傅里叶数，以验证其是否接近稳定性极限。\n\n从能量守恒和傅里叶定律导出的一维热方程出发，推导适用于所述显式格式的线性稳定性约束，然后计算该网格和材料属性所允许的最大稳定统一时间步长 $\\Delta t$。使用从给定映射中找到的最小相邻间距 $h$ 来设定约束。将最终数值答案四舍五入至四位有效数字，并以秒为单位表示。",
            "solution": "该问题是适定的且有科学依据。所有必要数据均已提供且一致。\n\n一维瞬态热扩散方程由下式给出：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\n其中 $T$ 是温度，$t$ 是时间，$x$ 是空间坐标，$\\alpha$ 是热扩散系数。\n\n该问题指定使用显式前向欧拉方法进行时间积分，并使用二阶中心差分进行空间离散来求解。设 $T_i^n$ 表示空间节点 $i$ 在时间步 $n$ 的温度。时间上的前向差分为：\n$$\n\\frac{\\partial T}{\\partial t} \\bigg|_i^n \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t}\n$$\n对于间距为 $h$ 的均匀网格，空间上的中心差分为：\n$$\n\\frac{\\partial^2 T}{\\partial x^2} \\bigg|_i^n \\approx \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{h^2}\n$$\n将这些代入热方程，得到前向时间中心空间（FTCS）离散格式：\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{h^2}\n$$\n为求未来温度 $T_i^{n+1}$ 进行整理，得到显式更新方程：\n$$\nT_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{h^2} (T_{i+1}^n - 2T_i^n + T_{i-1}^n)\n$$\n无量纲数组合 $Fo = \\frac{\\alpha \\Delta t}{h^2}$ 是网格傅里叶数。对此格式在均匀网格上进行的冯·诺依曼稳定性分析表明，当且仅当傅里叶数有界时，该格式是稳定的：\n$$\nFo \\le \\frac{1}{2} \\quad \\implies \\quad \\frac{\\alpha \\Delta t}{h^2} \\le \\frac{1}{2}\n$$\n这导致了对时间步长的稳定性约束：\n$$\n\\Delta t \\le \\frac{h^2}{2\\alpha}\n$$\n该问题指定了一个非均匀网格，其稳定性分析更为复杂。然而，问题明确指出，稳定性约束应基于网格中的最小空间步长 $h$。设该最小间距为 $h_{min}$。因此，最大稳定统一时间步长 $\\Delta t_{max}$ 的条件为：\n$$\n\\Delta t_{max} = \\frac{h_{min}^2}{2\\alpha}\n$$\n为求得 $h_{min}$，我们必须分析给定的网格生成映射：\n$$\nx_i = L \\left(\\frac{i}{N}\\right)^2 \\quad \\text{for } i = 0, 1, \\dots, N\n$$\n第 $i$ 个单元的间距 $h_i$ 定义为节点 $i$ 和节点 $i-1$ 之间的距离，即：\n$$\nh_i = x_i - x_{i-1} \\quad \\text{for } i = 1, \\dots, N\n$$\n代入映射函数：\n$$\nh_i = L \\left(\\frac{i}{N}\\right)^2 - L \\left(\\frac{i-1}{N}\\right)^2 = \\frac{L}{N^2} \\left[ i^2 - (i-1)^2 \\right]\n$$\n展开项 $(i-1)^2 = i^2 - 2i + 1$：\n$$\nh_i = \\frac{L}{N^2} [i^2 - (i^2 - 2i + 1)] = \\frac{L}{N^2} (2i - 1)\n$$\n为求得 $h_{min}$，我们观察到 $h_i$ 是关于索引 $i$ 的线性增函数。因此，最小间距出现在最小索引处，即 $i=1$：\n$$\nh_{min} = h_1 = \\frac{L}{N^2} (2(1) - 1) = \\frac{L}{N^2}\n$$\n现在我们代入给定的数值：$L = 0.36 \\, \\mathrm{m}$ 和 $N=12$。\n$$\nh_{min} = \\frac{0.36}{12^2} = \\frac{0.36}{144} = 0.0025 \\, \\mathrm{m}\n$$\n确定了最小间距后，我们现在可以使用给定的热扩散系数 $\\alpha = 1.4 \\times 10^{-5} \\, \\mathrm{m^2/s}$ 来计算最大稳定时间步长 $\\Delta t_{max}$。\n$$\n\\Delta t_{max} = \\frac{h_{min}^2}{2\\alpha} = \\frac{(0.0025)^2}{2 \\times (1.4 \\times 10^{-5})}\n$$\n$$\n\\Delta t_{max} = \\frac{6.25 \\times 10^{-6}}{2.8 \\times 10^{-5}} = \\frac{6.25}{28} \\approx 0.22321428... \\, \\mathrm{s}\n$$\n问题要求将最终答案四舍五入至四位有效数字。\n$$\n\\Delta t_{max} \\approx 0.2232 \\, \\mathrm{s}\n$$\n该值代表了求解器可以使用的最大统一时间步长，它基于网格中最小单元施加的保守约束，保证了整个域的数值稳定性。对于这个约束最强的单元，其傅里叶数将恰好处于 $0.5$ 的极限值。",
            "answer": "$$\n\\boxed{0.2232}\n$$"
        },
        {
            "introduction": "仿真计算得到结果后，我们必须回答一个关键问题：“这个结果的可信度有多高？”。后处理的一个核心任务就是量化因时空离散化而引入的数值误差。本练习  介绍了一种在计算流体力学和传热学中广泛应用的标准化方法——网格收敛性指数（Grid Convergence Index, GCI），用于通过一系列系统加密的网格上的仿真结果来估计离散不确定性。熟练运用GCI是建立仿真结果可信度、严谨报告研究成果的关键环节。",
            "id": "3983586",
            "problem": "使用计算流体力学（CFD）模拟了长度为 $L$、水力直径为 $D_{h}$ 的直通道内的受热层流。材料属性为常数，壁面边界条件施加了均匀热通量。后处理的目标是面积平均努塞尔数 $Nu$，其根据第一性原理定义为 $Nu = h D_{h} / k$，其中 $h$ 是对流传热系数，$k$ 是热导率。沿受热长度方向的空间离散是均匀的，并在预处理中构建了三个系统加密的网格，其沿流向的控制体积数分别为 $N_{3} = 64$、$N_{2} = 128$ 和 $N_{1} = 256$。因此，网格间距的尺度关系为 $h_{i} \\propto L / N_{i}$，加密比满足 $r_{21} = h_{2}/h_{1} = 2$ 和 $r_{32} = h_{3}/h_{2} = 2$。求解器采用二阶空间格式和全隐式时间推进法求解稳态；迭代误差可以忽略不计，因为所有网格的无量纲残差都已降至 $10^{-8}$ 以下。后处理得到三套网格上的面积平均努塞尔数如下：$Nu_{3} = 7.880$，$Nu_{2} = 7.974$ 和 $Nu_{1} = 8.017$。假设解处于网格收敛的渐近区域，且主阶离散误差的行为符合 $E(h) \\approx C h^{p}$，其中 $C$ 是一个常数，$p$ 是观测到的精度阶。使用安全系数为 $F_{s} = 1.25$ 的三网格方法计算网格收敛指数（GCI），构建最密网格上的 GCI，并解释围绕 $Nu_{1}$ 的相应不确定性带。仅报告基于最密网格的努塞尔数不确定性带的上限。以无量纲的努塞尔数形式表达您的最终答案，并将答案四舍五入到 $4$ 位有效数字。",
            "solution": "该问题要求计算在最密网格上计算的面积平均努塞尔数 $Nu$ 的不确定性带的上限。根据要求，将采用网格收敛指数（GCI）方法，这是一种用于估计计算模拟中离散误差的标准化程序。\n\n从三套系统加密的网格中给出的数据如下：\n-   密网格（1）：解 $\\phi_1 = Nu_1 = 8.017$。\n-   中等网格（2）：解 $\\phi_2 = Nu_2 = 7.974$。\n-   粗网格（3）：解 $\\phi_3 = Nu_3 = 7.880$。\n\n网格加密是均匀的，加密比为常数 $r = 2$。GCI 计算的安全系数指定为 $F_s = 1.25$。\n\nGCI 方法假设离散误差 $E$ 遵循关系式 $E(h) = \\phi(h) - \\phi_{exact} \\approx C h^p$，其中 $\\phi(h)$ 是特征间距为 $h$ 的网格上的解，$\\phi_{exact}$ 是精确解，$C$ 是一个常数，$p$ 是精度阶。对于具有恒定加密比 $r = h_2/h_1 = h_3/h_2$ 的三网格研究，可以计算出观测到的精度阶 $p$。\n\n首先，我们计算连续网格上解的差值：\n$$ \\epsilon_{21} = \\phi_2 - \\phi_1 = 7.974 - 8.017 = -0.043 $$\n$$ \\epsilon_{32} = \\phi_3 - \\phi_2 = 7.880 - 7.974 = -0.094 $$\n\n这些差值的比率 $R$ 用于求解 $p$：\n$$ R = \\frac{\\epsilon_{32}}{\\epsilon_{21}} = \\frac{\\phi_3 - \\phi_2}{\\phi_2 - \\phi_1} = \\frac{-0.094}{-0.043} = \\frac{94}{43} $$\n对于处于渐近区域的解，该比率约等于 $r^p$。因此，我们可以求解观测到的精度阶 $p$：\n$$ p = \\frac{\\ln(R)}{\\ln(r)} = \\frac{\\ln\\left(\\frac{94}{43}\\right)}{\\ln(2)} \\approx \\frac{\\ln(2.1860465)}{0.693147} \\approx \\frac{0.782071}{0.693147} \\approx 1.12828 $$\n\n密网格解的不确定度 $U$ 是通过将理查德森误差估计值乘以安全系数 $F_s$ 计算得出的。密网格解 $\\phi_1$ 的误差估计值由 $E_a^{12} = \\frac{\\phi_1 - \\phi_2}{r^p - 1}$ 给出。不确定度 $U$ 为：\n$$ U = F_s \\left| E_a^{12} \\right| = F_s \\left| \\frac{\\phi_1 - \\phi_2}{r^p - 1} \\right| $$\n我们可以将 $r^p = R$ 代入此表达式：\n$$ U = F_s \\frac{|\\phi_1 - \\phi_2|}{R - 1} $$\n代入数值：\n$$ U = 1.25 \\times \\frac{|8.017 - 7.974|}{\\frac{94}{43} - 1} = 1.25 \\times \\frac{0.043}{\\frac{94 - 43}{43}} = 1.25 \\times \\frac{0.043}{\\frac{51}{43}} $$\n$$ U = 1.25 \\times \\frac{0.043 \\times 43}{51} = 1.25 \\times \\frac{1.849}{51} \\approx 1.25 \\times 0.0362549 \\approx 0.0453186 $$\n\n问题要求的是围绕密网格努塞尔数 $Nu_1 = \\phi_1$ 的不确定性带的上限。该不确定性带定义为 $[\\phi_1 - U, \\phi_1 + U]$。因此，上限为 $\\phi_1 + U$。\n$$ \\text{上限} = \\phi_1 + U = 8.017 + 0.0453186 = 8.0623186 $$\n\n最后，问题要求将答案四舍五入到 $4$ 位有效数字。\n$$ \\text{上限} \\approx 8.062 $$\n该值代表了在安全系数为 $1.25$ 的情况下，精确努塞尔数预期所在的区间的上界。",
            "answer": "$$\\boxed{8.062}$$"
        },
        {
            "introduction": "在计算实践中，解决同一个问题往往存在多种数值策略，每种策略都在计算成本和求解精度之间有不同的权衡。这个综合性练习  引导您完成一个完整的仿真工作流，旨在比较显式方法（许多小的、廉价的时间步）与隐式方法（一个大的、昂贵的时间步）的优劣。通过定义和计算误差与成本的量化指标，您将学习如何基于数据在不同的求解器策略之间做出理性决策，这是实现高效、高质仿真的核心能力。",
            "id": "3983540",
            "problem": "您将实施一个计算实验，遵循预处理、求解器和后处理的标准模拟工作流程，以分析在齐次狄利克雷边界条件的瞬态一维热传导问题中，单个大隐式时间步长与多个小显式时间步长之间的权衡。其控制物理原理由能量守恒和傅里叶热传导定律定义，最终得到一维热方程。数学和物理基础如下。\n\n基本原理：\n- 均匀介质中的一维瞬态热传导由热方程建模\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2},\n$$\n其中 $0  x  L$, $t > 0$，$T$ 是温度，单位为 $\\mathrm{K}$，$\\alpha$ 是热扩散系数，单位为 $\\mathrm{m^2/s}$，$L$ 是长度，单位为 $\\mathrm{m}$。\n- 齐次狄利克雷边界条件：对于 $t \\ge 0$，$T(0,t) = 0$ 且 $T(L,t) = 0$。\n- 初始条件：$T(x,0) = T_0 \\sin\\left(\\frac{\\pi x}{L}\\right)$，其中 $T_0$ 是振幅，单位为 $\\mathrm{K}$。\n- 解析解：\n$$\nT_{\\text{exact}}(x,t) = T_0 \\sin\\left(\\frac{\\pi x}{L}\\right) \\exp\\left(-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t\\right).\n$$\n\n预处理：\n- 使用有限差分法（FDM）对空间进行离散化，设置 $N_x$ 个内部节点，均匀间距为 $\\Delta x = \\frac{L}{N_x+1}$，节点位置为 $x_i = i \\Delta x$，其中 $i = 1,2,\\dots,N_x$。由于齐次狄利克雷边界条件，位于 $x = 0$ 和 $x = L$ 的边界节点被排除在未知向量之外，但它们的值在离散算子中得到了考虑。\n- 使用 $T_i(0) = T_0 \\sin\\left(\\frac{\\pi x_i}{L}\\right)$ 初始化离散温度向量，其中 $i = 1,\\dots,N_x$。\n\n求解器：\n- 显式方法：时间上采用前向欧拉法，空间上对内部节点采用中心差分法，\n$$\nT_i^{n+1} = T_i^n + \\mathrm{Fo}_e\\left(T_{i+1}^n - 2 T_i^n + T_{i-1}^n\\right),\n$$\n其中 $\\mathrm{Fo}_e = \\frac{\\alpha \\Delta t_e}{\\Delta x^2}$，$\\Delta t_e$ 是显式时间步长，$n$ 表示时间层。边界条件意味着 $T_0^n = 0$ 且 $T_{N_x+1}^n = 0$。显式格式必须满足经典的稳定性条件 $\\mathrm{Fo}_e \\le \\frac{1}{2}$。\n- 隐式方法：时间上采用后向欧拉法，空间上采用中心差分法，采用大小为 $\\Delta t_i = T_{\\text{end}}$ 的单个大步长，\n$$\n\\left(\\mathbf{I} - \\mathrm{Fo}_i \\mathbf{L}\\right)\\mathbf{T}^{n+1} = \\mathbf{T}^{n},\n$$\n其中 $\\mathrm{Fo}_i = \\frac{\\alpha \\Delta t_i}{\\Delta x^2}$，$\\mathbf{I}$ 是单位矩阵，$\\mathbf{L}$ 是标准的三对角离散拉普拉斯算子，其模板系数为 $\\{-1,2,-1\\}$，应用于内部节点。该矩阵的主对角线元素为 $1 + 2\\mathrm{Fo}_i$，次对角线元素为 $-\\mathrm{Fo}_i$。使用托马斯算法（三对角高斯消元法）精确求解这个单隐式步长的线性系统。\n\n后处理：\n- 在最终时间 $t = T_{\\text{end}}$，使用给定公式计算内部网格点上的解析解 $\\mathbf{T}_{\\text{exact}}(T_{\\text{end}})$。\n- 定义向量 $\\mathbf{T}$ 在 $t = T_{\\text{end}}$ 时相对于解析解的归一化离散均方根误差为\n$$\ne = \\frac{1}{T_0}\\sqrt{\\frac{1}{N_x}\\sum_{i=1}^{N_x}\\left(T_i - T_{\\text{exact},i}\\right)^2},\n$$\n该误差是无量纲的。\n- 定义一个针对每个内部节点的无量纲计算成本模型如下。设 $c_e$ 为每个内部节点执行一个显式步长的成本系数，$c_i$ 为每个内部节点执行一个隐式步长的成本系数。则\n$$\nC_{\\text{exp}} = N_{\\text{steps}} \\, c_e, \\quad C_{\\text{imp}} = 1 \\cdot c_i,\n$$\n其中 $N_{\\text{steps}} = T_{\\text{end}}/\\Delta t_e$ 是显式步数，假定为整数。使用 $c_e = 6$ 和 $c_i = 10$ 来反映显式更新与一次三对角求解的典型每节点操作计数。\n- 定义一个用于决策的无量纲目标函数，以平衡误差和成本，\n$$\nJ = e + \\lambda C,\n$$\n其中 $\\lambda$ 是一个无量纲权重。在不同方法中，较低的 $J$ 值表示在该权重下更优选的方法。\n\n您的任务：\n- 实现完整的工作流程：预处理（网格和初始化）、求解器（显式多步和隐式单步）以及后处理（计算误差、成本和决策）。\n- 对于每个测试用例，计算：\n    1. 误差比 $r_e = \\frac{e_{\\text{exp}}}{e_{\\text{imp}}}$ (无量纲)。\n    2. 成本比 $r_c = \\frac{C_{\\text{exp}}}{C_{\\text{imp}}}$ (无量纲)。\n    3. 决策 $d$，定义为：如果 $J_{\\text{exp}}  J_{\\text{imp}}$，则 $d = 1$，否则 $d = 0$ (整数)。\n\n物理单位与一致性：\n- 使用国际单位制（SI units）：$L$ 单位为 $\\mathrm{m}$，$\\alpha$ 单位为 $\\mathrm{m^2/s}$，$T_{\\text{end}}$ 和 $\\Delta t_e$ 单位为 $\\mathrm{s}$，$T_0$ 单位为 $\\mathrm{K}$。输出 $r_e$、$r_c$ 和 $d$ 是无量纲或无单位的整数，因此最终输出不需要物理单位。\n\n测试套件：\n- 所有用例均使用 $T_0 = 1$。\n- 对于每个用例，确保 $\\mathrm{Fo}_e \\le \\frac{1}{2}$ 且 $T_{\\text{end}}/\\Delta t_e$ 为整数。\n\n提供以下四个测试用例：\n- 用例 1（中等扩散和细网格的常规路径）：\n    - $L = 0.1$, $\\alpha = 10^{-5}$, $N_x = 50$, $T_{\\text{end}} = 10.0$, $\\Delta t_e = 0.02$, $\\lambda = 0.1$。\n- 用例 2（小时间范围、粗网格、较慢的显式演化）：\n    - $L = 0.1$, $\\alpha = 10^{-4}$, $N_x = 20$, $T_{\\text{end}} = 1.0$, $\\Delta t_e = 0.001$, $\\lambda = 0.01$。\n- 用例 3（长域上接近稳定性极限的显式步长）：\n    - $L = 1.0$, $\\alpha = 5\\times 10^{-3}$, $N_x = 200$, $T_{\\text{end}} = 0.099$, $\\Delta t_e = 0.0012375$, $\\lambda = 1.0$。\n- 用例 4（极粗网格且显式步长接近稳定性极限的边缘情况）：\n    - $L = 0.05$, $\\alpha = 10^{-4}$, $N_x = 5$, $T_{\\text{end}} = 4.087584$, $\\Delta t_e = 0.340632$, $\\lambda = 0.5$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含每个测试用例的结果列表，每个列表包含三个条目 $[r_e, r_c, d]$。将所有四个测试用例的列表聚合到一个顶层列表中。确切的输出字符串必须是如下形式的单行：\n$$\n\\big[ [r_{e,1}, r_{c,1}, d_1], [r_{e,2}, r_{c,2}, d_2], [r_{e,3}, r_{c,3}, d_3], [r_{e,4}, r_{c,4}, d_4] \\big],\n$$\n数值以标准十进制表示法打印。",
            "solution": "用户提供的问题已经过严格验证，被确定为一个有效、适定且科学合理的计算热工学练习。所有参数、方程和条件都是完整、一致的，并且基于数值分析和传热学的既定原理。\n\n该问题要求对求解一维瞬态热方程的两种数值格式进行比较分析：多步显式前向欧拉法和单步隐式后向欧拉法。该比较基于数值精度（误差）和计算量（成本）之间的权衡，并通过一个无量纲的目标函数进行形式化。整个过程遵循标准的模拟工作流程：预处理、求解和后处理。\n\n该问题的控制性偏微分方程（PDE）是一维热方程：\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2}\n$$\n该方程描述了温度 $T$ 在一维空间域（长度为 $L$）上随时间 $t$ 的演变，其中 $\\alpha$ 是材料的热扩散系数。该系统受齐次狄利克雷边界条件 $T(0,t) = T(L,t) = 0$ 和初始正弦温度分布 $T(x,0) = T_0 \\sin\\left(\\frac{\\pi x}{L}\\right)$ 的约束。这个特定的初始条件对应于空间微分算子的第一特征模态，从而得出一个便于验证的解析解：\n$$\nT_{\\text{exact}}(x,t) = T_0 \\sin\\left(\\frac{\\pi x}{L}\\right) \\exp\\left(-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t\\right)\n$$\n\n任务的核心是对该问题进行离散化并进行数值求解。\n\n**1. 预处理：离散化**\n\n首先，将连续空间域 $x \\in [0, L]$ 离散化为网格。我们定义 $N_x$ 个内部节点，其均匀间距为 $\\Delta x = \\frac{L}{N_x+1}$。内部节点的空间坐标为 $x_i = i \\Delta x$，其中 $i=1, 2, \\dots, N_x$。这些节点上的温度表示为 $T_i(t)$。\n\n使用二阶中心差分近似空间二阶导数，我们得到一个常微分方程组（ODEs）：\n$$\n\\frac{d T_i(t)}{dt} = \\frac{\\alpha}{\\Delta x^2} (T_{i+1}(t) - 2T_i(t) + T_{i-1}(t))\n$$\n以矩阵形式表示为 $\\frac{d\\mathbf{T}}{dt} = \\frac{\\alpha}{\\Delta x^2}\\mathbf{A}\\mathbf{T}$，其中 $\\mathbf{T}$ 是内部节点温度向量，$\\mathbf{A}$ 是一个三对角矩阵，表示离散拉普拉斯算子，其模板为 $(1, -2, 1)$，并包含了零值边界条件。\n\n通过在网格点上采样连续函数来离散化初始条件：\n$$\nT_i(0) = T_0 \\sin\\left(\\frac{\\pi x_i}{L}\\right)\n$$\n\n**2. 求解器：时间积分**\n\n使用两种不同的方法将该常微分方程组从 $t=0$ 积分到 $t=T_{\\text{end}}$。\n\n**2.1. 显式方法：前向欧拉法**\n\n时间导数使用前向差分进行近似。该格式仅使用时间层 $n$ 的已知值来更新时间层 $n+1$ 的温度：\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t_e} = \\frac{\\alpha}{\\Delta x^2}(T_{i+1}^n - 2T_i^n + T_{i-1}^n)\n$$\n整理后得到显式更新规则：\n$$\nT_i^{n+1} = T_i^n + \\mathrm{Fo}_e (T_{i+1}^n - 2T_i^n + T_{i-1}^n)\n$$\n其中 $\\mathrm{Fo}_e = \\frac{\\alpha \\Delta t_e}{\\Delta x^2}$ 是显式的库朗-弗里德里希斯-列维（CFL）数或傅里叶数。此方法计算简单，但是条件稳定的，要求 $\\mathrm{Fo}_e \\le \\frac{1}{2}$ 以防止无界误差增长。模拟通过应用此更新规则进行 $N_{\\text{steps}} = T_{\\text{end}}/\\Delta t_e$ 步。\n\n**2.2. 隐式方法：后向欧拉法**\n\n时间导数同样用一阶差分近似，但空间项在未来的时间层 $n+1$ 上进行计算：\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t_i} = \\frac{\\alpha}{\\Delta x^2}(T_{i+1}^{n+1} - 2T_i^{n+1} + T_{i-1}^{n+1})\n$$\n此问题指定了一个大的时间步长，$\\Delta t_i = T_{\\text{end}}$。将所有未知量（$T^{n+1}$）移到等式左侧，为每个内部节点 $i$ 得到一个线性方程组：\n$$\n-\\mathrm{Fo}_i T_{i-1}^{n+1} + (1 + 2\\mathrm{Fo}_i) T_i^{n+1} - \\mathrm{Fo}_i T_{i+1}^{n+1} = T_i^n\n$$\n其中 $\\mathrm{Fo}_i = \\frac{\\alpha \\Delta t_i}{\\Delta x^2}$。以矩阵形式表示为 $(\\mathbf{I} - \\mathrm{Fo}_i \\mathbf{A})\\mathbf{T}^{n+1} = \\mathbf{T}^{n}$。得到的矩阵 $(\\mathbf{I} - \\mathrm{Fo}_i \\mathbf{A})$ 是三对角、对称且对角占优的，这使得可以使用托马斯算法（一种针对三对角系统的高斯消元法）进行高效且稳定的求解。此方法是无条件稳定的，允许非常大的时间步长，但代价是需要求解一个线性系统。\n\n**3. 后处理：分析与决策**\n\n从两种方法获得 $t=T_{\\text{end}}$ 时的数值解后，进行定量比较。\n\n首先，在每个内部节点上计算解析解 $T_{\\text{exact}}(x_i, T_{\\text{end}})$。\n\n每个数值解（$\\mathbf{T}_{\\text{exp}}$ 和 $\\mathbf{T}_{\\text{imp}}$）的精度通过归一化离散均方根误差来衡量：\n$$\ne = \\frac{1}{T_0}\\sqrt{\\frac{1}{N_x}\\sum_{i=1}^{N_x}\\left(T_i - T_{\\text{exact},i}\\right)^2}\n$$\n\n接下来，使用提供的无量纲模型估算计算成本：\n- 显式成本：$C_{\\text{exp}} = N_{\\text{steps}} \\cdot c_e = (T_{\\text{end}}/\\Delta t_e) \\cdot 6$\n- 隐式成本：$C_{\\text{imp}} = 1 \\cdot c_i = 10$\n\n最后，基于目标函数 $J = e + \\lambda C$ 做出决策，该函数使用权重因子 $\\lambda$ 来平衡误差 $e$ 和成本 $C$。对于给定的 $\\lambda$，具有较低 $J$ 值的方法被认为是更优的。如果 $J_{\\text{exp}}  J_{\\text{imp}}$，决策变量 $d$ 设为 $1$，否则设为 $0$。\n\n同时计算误差比 $r_e = e_{\\text{exp}} / e_{\\text{imp}}$ 和成本比 $r_c = C_{\\text{exp}} / C_{\\text{imp}}$，以进一步深入了解两种格式的相对性能。该实现将为每个指定的测试用例系统地执行整个工作流程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef thomas_algorithm(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax = d using the Thomas algorithm.\n    a: sub-diagonal (length N-1)\n    b: main diagonal (length N)\n    c: super-diagonal (length N-1)\n    d: right-hand side (length N)\n    Returns the solution vector x.\n    \"\"\"\n    n = len(d)\n    c_prime = np.zeros(n)\n    d_prime = np.zeros(n)\n    x = np.zeros(n)\n\n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n    for i in range(1, n):\n        denominator = b[i] - a[i-1] * c_prime[i-1]\n        if i  n - 1:\n            c_prime[i] = c[i] / denominator\n        d_prime[i] = (d[i] - a[i-1] * d_prime[i-1]) / denominator\n\n    # Backward substitution\n    x[n-1] = d_prime[n-1]\n    for i in range(n-2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i+1]\n        \n    return x\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: L, alpha, Nx, T_end, dt_e, lambda_val\n        (0.1, 1e-5, 50, 10.0, 0.02, 0.1),\n        # Case 2\n        (0.1, 1e-4, 20, 1.0, 0.001, 0.01),\n        # Case 3\n        (1.0, 5e-3, 200, 0.099, 0.0012375, 1.0),\n        # Case 4\n        (0.05, 1e-4, 5, 4.087584, 0.340632, 0.5),\n    ]\n\n    T0 = 1.0\n    c_e = 6.0\n    c_i = 10.0\n    \n    all_results = []\n\n    for L, alpha, Nx, T_end, dt_e, lambda_val in test_cases:\n        # ===== 1. PRE-PROCESSING =====\n        dx = L / (Nx + 1)\n        x_nodes = np.linspace(dx, L - dx, Nx)\n        \n        # Initial condition\n        T_initial = T0 * np.sin(np.pi * x_nodes / L)\n\n        # ===== 2. SOLVER: EXPLICIT METHOD =====\n        Fo_e = alpha * dt_e / dx**2\n        \n        # As per problem validation, Fo = 0.5 is met for all cases.\n        # As per problem validation, T_end / dt_e is an integer.\n        N_steps = int(round(T_end / dt_e))\n        \n        T_current_exp = np.copy(T_initial)\n        \n        for _ in range(N_steps):\n            T_new_exp = np.copy(T_current_exp)\n            \n            # Vectorized update for interior nodes\n            if Nx > 1:\n                T_new_exp[1:-1] = T_current_exp[1:-1] + Fo_e * (\n                    T_current_exp[2:] - 2 * T_current_exp[1:-1] + T_current_exp[0:-2])\n            \n            # Update for boundary-adjacent nodes (T=0 at boundaries)\n            T_new_exp[0] = T_current_exp[0] + Fo_e * (T_current_exp[1] - 2 * T_current_exp[0] + 0) if Nx > 0 else T_current_exp[0]\n            if Nx > 1:\n                T_new_exp[-1] = T_current_exp[-1] + Fo_e * (0 - 2 * T_current_exp[-1] + T_current_exp[-2])\n            \n            T_current_exp = T_new_exp\n            \n        T_final_exp = T_current_exp\n\n        # ===== 3. SOLVER: IMPLICIT METHOD =====\n        dt_i = T_end\n        Fo_i = alpha * dt_i / dx**2\n        \n        # Set up the tridiagonal system Ax = d\n        # A has diagonals: a, b, c\n        # b_j = 1 + 2*Fo_i\n        # a_j = c_j = -Fo_i\n        # d = T_initial\n        \n        b = np.full(Nx, 1.0 + 2.0 * Fo_i)\n        a = np.full(Nx - 1, -Fo_i)\n        c = np.full(Nx - 1, -Fo_i)\n        d = T_initial\n        \n        T_final_imp = thomas_algorithm(a, b, c, d)\n\n        # ===== 4. POST-PROCESSING =====\n        # Analytical solution\n        decay_term = np.exp(-alpha * (np.pi/L)**2 * T_end)\n        T_exact = T0 * np.sin(np.pi * x_nodes / L) * decay_term\n\n        # Errors\n        e_exp = (1/T0) * np.sqrt(np.mean((T_final_exp - T_exact)**2))\n        e_imp = (1/T0) * np.sqrt(np.mean((T_final_imp - T_exact)**2))\n\n        # Costs\n        C_exp = N_steps * c_e\n        C_imp = 1.0 * c_i\n        \n        # Ratios\n        r_e = e_exp / e_imp if e_imp != 0 else float('inf')\n        r_c = C_exp / C_imp\n\n        # Objective functions and decision\n        J_exp = e_exp + lambda_val * C_exp\n        J_imp = e_imp + lambda_val * C_imp\n        \n        decision = 1 if J_exp  J_imp else 0\n\n        all_results.append([r_e, r_c, decision])\n\n    # Final print statement in the exact required format.\n    print(str(all_results).replace(\"'\", \"\"))\n\nsolve()\n```"
        }
    ]
}