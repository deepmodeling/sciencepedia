{
    "hands_on_practices": [
        {
            "introduction": "在实施迭代求解器之前，理解如何从理论上预测其性能至关重要。本练习通过对一个典型的模型问题——一维热传导——进行分析，推导出雅可比方法的谱半径，从而对该方法的收敛性进行了基础性的探讨。这项实践旨在锻炼您的分析能力，并将物理问题的离散化与控制收敛性的抽象代数性质联系起来。",
            "id": "3986575",
            "problem": "一个具有恒定横截面的直翼片可以通过稳态一维热传导方程和齐次狄利克雷边界条件来建模，在无量纲化后，可以简化为以下边值问题\n$$\n- \\frac{d^{2} u}{dx^{2}} = f(x), \\quad x \\in (0,1), \\qquad u(0)=0,\\; u(1)=0.\n$$\n使用 $n$ 个等距内点 $x_{j} = j h$（$j=1,2,\\dots,n$，$h = \\frac{1}{n+1}$）对区间内部进行离散化。使用标准二阶中心差分法，得到线性系统 $A \\mathbf{u} = \\mathbf{b}$，其中 $A$ 是由带狄利克雷边界条件的离散负二阶导数产生的三对角矩阵。考虑将雅可比方法应用于此系统，使用标准分裂 $A = D - (L+U)$，雅可比迭代矩阵为 $B_{J} = I - D^{-1} A$。\n\n从离散算子和边界条件出发，通过构建一个合适的特征向量正交基，显式地推导出 $B_{J}$ 的特征对。然后，确定谱半径 $\\rho(B_{J})$ 作为 $n$ 的闭式函数。\n\n只需报告 $\\rho(B_{J})$ 的最终闭式解析表达式。不需要进行数值计算。",
            "solution": "该问题是有效的。这是一个数值分析中的标准、适定问题，涉及从边值问题的有限差分离散导出的迭代矩阵的谱性质。所有信息都是自洽且科学合理的。\n\n我们首先对给定的边值问题进行离散化：\n$$\n- \\frac{d^{2} u}{dx^{2}} = f(x), \\quad x \\in (0,1), \\qquad u(0)=0,\\; u(1)=0.\n$$\n将定义域 $(0,1)$ 分成 $n+1$ 个等宽的子区间，宽度为 $h = \\frac{1}{n+1}$。网格点为 $x_j = jh$，其中 $j=0, 1, \\dots, n+1$。函数 $u(x)$ 在内部网格点的值记为 $u_j = u(x_j)$，$j=1, 2, \\dots, n$。边界条件意味着 $u_0 = 0$ 和 $u_{n+1} = 0$。\n\n在内部点 $x_j$ 处的二阶导数使用二阶中心差分公式进行近似：\n$$\n\\frac{d^{2} u}{dx^{2}}\\Bigg|_{x=x_j} \\approx \\frac{u(x_{j+1}) - 2u(x_j) + u(x_{j-1})}{h^2} = \\frac{u_{j+1} - 2u_j + u_{j-1}}{h^2}.\n$$\n将此式代入每个内部点 $x_j$ 的微分方程中，得到一个包含 $n$ 个线性方程的方程组：\n$$\n- \\frac{u_{j+1} - 2u_j + u_{j-1}}{h^2} = f(x_j), \\quad j=1, 2, \\dots, n.\n$$\n整理各项，我们得到：\n$$\n\\frac{1}{h^2}(-u_{j-1} + 2u_j - u_{j+1}) = f_j,\n$$\n其中 $f_j = f(x_j)$。我们应用边界条件：对于 $j=1$，$u_0=0$；对于 $j=n$，$u_{n+1}=0$。该方程组可以写成矩阵形式 $A \\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_1, u_2, \\dots, u_n]^T$，$\\mathbf{b} = [f_1, f_2, \\dots, f_n]^T$，而 $A$ 是一个 $n \\times n$ 矩阵：\n$$\nA = \\frac{1}{h^2} \\begin{pmatrix}\n2  -1  0  \\cdots  0 \\\\\n-1  2  -1  \\ddots  \\vdots \\\\\n0  -1  \\ddots  \\ddots  0 \\\\\n\\vdots  \\ddots  \\ddots  2  -1 \\\\\n0  \\cdots  0  -1  2\n\\end{pmatrix}.\n$$\n对于雅可比方法，矩阵 $A$ 分裂为 $A = D - (L+U)$，其中 $D$ 是 $A$ 的对角部分，$-L$ 和 $-U$ 分别是 $A$ 的严格下三角和上三角部分。雅可比迭代矩阵由 $B_J = D^{-1}(L+U) = I - D^{-1}A$ 给出。\n\n从 $A$ 的结构来看，其对角部分是 $D = \\frac{2}{h^2}I$，其中 $I$ 是 $n \\times n$ 的单位矩阵。\n$D$ 的逆是 $D^{-1} = \\frac{h^2}{2}I$。\n将此代入 $B_J$ 的表达式中：\n$$\nB_J = I - \\left(\\frac{h^2}{2}I\\right) A = I - \\frac{h^2}{2} \\left[ \\frac{1}{h^2} \\begin{pmatrix}\n2  -1   \\cdots \\\\\n-1  2  -1  \\\\\n \\ddots  \\ddots  \\ddots \\\\\n  -1  2\n\\end{pmatrix} \\right] = I - \\frac{1}{2} \\begin{pmatrix}\n2  -1   \\cdots \\\\\n-1  2  -1  \\\\\n \\ddots  \\ddots  \\ddots \\\\\n  -1  2\n\\end{pmatrix}.\n$$\n这就得到了雅可比迭代矩阵：\n$$\nB_J = \\begin{pmatrix}\n1    \\\\\n  1   \\\\\n   \\ddots  \\\\\n    1\n\\end{pmatrix} - \\begin{pmatrix}\n1  -1/2   \\\\\n-1/2  1  -1/2  \\\\\n \\ddots  \\ddots  \\ddots \\\\\n  -1/2  1\n\\end{pmatrix} = \\begin{pmatrix}\n0  1/2  0  \\cdots  0 \\\\\n1/2  0  1/2  \\ddots  \\vdots \\\\\n0  1/2  \\ddots  \\ddots  0 \\\\\n\\vdots  \\ddots  \\ddots  0  1/2 \\\\\n0  \\cdots  0  1/2  0\n\\end{pmatrix}.\n$$\n为了求谱半径 $\\rho(B_J)$，我们需要求出 $B_J$ 的特征值。题目要求我们通过首先构建一个特征向量的正交基来完成。$B_J$ 的特征向量与 $A$ 的特征向量相同，因为 $B_J$ 是 $A$ 的一个线性多项式，而 $D$ 是单位矩阵的一个标量倍。\n\n让我们求出三对角矩阵 $T$ 的特征对，其中 $A = \\frac{1}{h^2}T$，$T$ 的对角元为 $2$，非对角元为 $-1$。设 $T$ 的一个特征向量为 $\\mathbf{v}$，对应的特征值为 $\\mu$。特征值问题 $T\\mathbf{v} = \\mu \\mathbf{v}$ 的第 $j$ 个分量是：\n$$\n-v_{j-1} + 2v_j - v_{j+1} = \\mu v_j,\n$$\n边界条件为 $v_0 = 0$ 和 $v_{n+1} = 0$。这是一个线性二阶差分方程。我们假设一个形式为 $v_j = \\sin(j\\theta)$ 的解，其中 $\\theta$ 是某个角度。边界条件 $v_0=0$ 自动满足。条件 $v_{n+1}=0$ 要求 $\\sin((n+1)\\theta) = 0$，这意味着 $(n+1)\\theta = k\\pi$，其中 $k$ 是某个整数。因此，我们有一个由 $k$ 索引的候选解族：\n$$\n\\theta_k = \\frac{k\\pi}{n+1}, \\quad k=1, 2, \\dots, n.\n$$\n对应的向量 $\\mathbf{v}^{(k)}$ 的分量为 $v_j^{(k)} = \\sin\\left(\\frac{jk\\pi}{n+1}\\right)$。这些向量构成了 $n$ 个线性无关的向量集合，并且它们构成了 $\\mathbb{R}^n$ 的一个正交基。\n\n让我们找出每个特征向量 $\\mathbf{v}^{(k)}$ 对应的特征值 $\\mu_k$。将 $v_j^{(k)}$ 代入差分方程：\n$$\n-\\sin\\left(\\frac{(j-1)k\\pi}{n+1}\\right) + 2\\sin\\left(\\frac{jk\\pi}{n+1}\\right) - \\sin\\left(\\frac{(j+1)k\\pi}{n+1}\\right) = \\mu_k \\sin\\left(\\frac{jk\\pi}{n+1}\\right).\n$$\n使用三角恒等式 $\\sin(a-b)+\\sin(a+b) = 2\\sin(a)\\cos(b)$，我们可以简化左侧：\n$$\n2\\sin\\left(\\frac{jk\\pi}{n+1}\\right) - \\left[ \\sin\\left(\\frac{(j-1)k\\pi}{n+1}\\right) + \\sin\\left(\\frac{(j+1)k\\pi}{n+1}\\right) \\right] = 2\\sin\\left(\\frac{jk\\pi}{n+1}\\right) - 2\\sin\\left(\\frac{jk\\pi}{n+1}\\right)\\cos\\left(\\frac{k\\pi}{n+1}\\right).\n$$\n提取公因式 $\\sin\\left(\\frac{jk\\pi}{n+1}\\right)$，我们得到：\n$$\n\\left(2 - 2\\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right) \\sin\\left(\\frac{jk\\pi}{n+1}\\right) = \\mu_k \\sin\\left(\\frac{jk\\pi}{n+1}\\right).\n$$\n因此，$T$ 的特征值为 $\\mu_k = 2 - 2\\cos\\left(\\frac{k\\pi}{n+1}\\right)$，其中 $k=1, \\dots, n$。\n\n矩阵 $A$、$T$ 和 $B_J$ 都共享相同的特征向量 $\\mathbf{v}^{(k)}$。设 $\\lambda_k(A)$ 为 $A$ 的特征值，$\\lambda_k(B_J)$ 为 $B_J$ 的特征值。\n$$\n\\lambda_k(A) = \\frac{1}{h^2}\\mu_k = \\frac{2}{h^2}\\left(1 - \\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right).\n$$\n$B_J$ 和 $A$ 的特征值之间的关系是 $\\lambda(B_J) = 1 - (\\frac{h^2}{2})\\lambda(A)$。因此，\n$$\n\\lambda_k(B_J) = 1 - \\frac{h^2}{2} \\lambda_k(A) = 1 - \\frac{h^2}{2} \\left[ \\frac{2}{h^2}\\left(1 - \\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right) \\right].\n$$\n$$\n\\lambda_k(B_J) = 1 - \\left(1 - \\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right) = \\cos\\left(\\frac{k\\pi}{n+1}\\right), \\quad k=1, 2, \\dots, n.\n$$\n$B_J$ 的特征对是 $\\left( \\cos\\left(\\frac{k\\pi}{n+1}\\right), \\mathbf{v}^{(k)} \\right)$，其中 $\\mathbf{v}^{(k)}$ 的第 $j$ 个分量是 $\\sin\\left(\\frac{jk\\pi}{n+1}\\right)$。\n\n$B_J$ 的谱半径是其特征值绝对值的最大值：\n$$\n\\rho(B_J) = \\max_{k \\in \\{1, \\dots, n\\}} |\\lambda_k(B_J)| = \\max_{k \\in \\{1, \\dots, n\\}} \\left| \\cos\\left(\\frac{k\\pi}{n+1}\\right) \\right|.\n$$\n余弦函数的自变量 $\\frac{k\\pi}{n+1}$ 的范围从 $\\frac{\\pi}{n+1}$ (当 $k=1$ 时) 到 $\\frac{n\\pi}{n+1}$ (当 $k=n$ 时)。这个范围包含在区间 $(0, \\pi)$ 内。函数 $|\\cos(x)|$ 在 $(0, \\pi)$ 上关于 $x=\\pi/2$ 对称，其最大值在任何闭区间 $[a, b] \\subset (0, \\pi)$ 的端点处取得，即在 $x=a$ 或 $x=b$ 处。\n在本例中，自变量的集合是离散的：$\\{\\frac{\\pi}{n+1}, \\frac{2\\pi}{n+1}, \\dots, \\frac{n\\pi}{n+1}\\}$。当 $\\theta$ 最接近 $0$ 或 $\\pi$ 时，$|\\cos(\\theta)|$ 的值最大。\n最接近 $0$ 和 $\\pi$ 的自变量是当 $k=1$ 和 $k=n$ 时：\n$$\n\\text{对于 } k=1: \\quad \\left| \\cos\\left(\\frac{\\pi}{n+1}\\right) \\right| = \\cos\\left(\\frac{\\pi}{n+1}\\right) \\quad (\\text{因为当 } n \\ge 1 \\text{ 时，} \\frac{\\pi}{n+1} \\in (0, \\pi/2)).\n$$\n$$\n\\text{对于 } k=n: \\quad \\left| \\cos\\left(\\frac{n\\pi}{n+1}\\right) \\right| = \\left| \\cos\\left(\\pi - \\frac{\\pi}{n+1}\\right) \\right| = \\left| -\\cos\\left(\\frac{\\pi}{n+1}\\right) \\right| = \\cos\\left(\\frac{\\pi}{n+1}\\right).\n$$\n对于 $k=2, \\dots, n-1$，$|\\cos(\\frac{k\\pi}{n+1})|$ 的值会更小，因为 $\\frac{k\\pi}{n+1}$ 会比端点离 $0$ 和 $\\pi$ 更远。\n因此，最大绝对值在 $k=1$ 和 $k=n$ 时取得。\n谱半径为：\n$$\n\\rho(B_J) = \\cos\\left(\\frac{\\pi}{n+1}\\right).\n$$",
            "answer": "$$\n\\boxed{\\cos\\left(\\frac{\\pi}{n+1}\\right)}\n$$"
        },
        {
            "introduction": "从理论转向实践，我们会发现像逐次超松弛（SOR）法这样强大的方法，其性能可能对实现细节出人意料地敏感。本练习将探讨未知数排序对SOR方法收敛性的关键影响，特别是对于在热流问题中常见的对流主导的非对称系统。通过编程和比较不同排序，您将直接观察到一个“糟糕”的排序如何导致方法失效，而一个“良好”的排序则能确保成功——这对任何计算工程师来说都是至关重要的一课。",
            "id": "3986584",
            "problem": "考虑恒定物性下的稳态一维对流-扩散能量平衡，通过在包含 $n$ 个节点的均匀网格上进行标准有限体积离散化，得到一个线性系统 $A \\mathbf{T} = \\mathbf{b}$，其系数矩阵 $A$ 为三对角矩阵。对于纯导热问题（无对流），$A$ 是对称正定的，例如对角线元素为 $2$，非对角线元素为 $-1$。对于采用迎风差分格式离散化的对流主导问题，$A$ 仍然是严格对角占优的，其非对角元素为非正值，并且通常是非对称的，其中上游耦合（一个非对角线）的量值可能远大于下游耦合（另一个非对角线）的量值。定常迭代法通过将 $A$ 分裂为 $A = D - L - U$ 来求解 $A \\mathbf{T} = \\mathbf{b}$，其中 $D$ 是对角部分，$L$ 是严格下三角部分，$U$ 是严格上三角部分（所有这些都根据给定的未知量排序来定义）。采用松弛参数 $\\omega$ 的逐次超松弛（SOR）方法的迭代公式为\n$$\n\\mathbf{T}^{(k+1)} = (D - \\omega L)^{-1} \\left( (1 - \\omega) D + \\omega U \\right) \\mathbf{T}^{(k)} + (D - \\omega L)^{-1} \\omega \\mathbf{b}.\n$$\n相关的齐次 SOR 迭代矩阵是\n$$\nG_{\\omega} = (D - \\omega L)^{-1} \\left( (1 - \\omega) D + \\omega U \\right).\n$$\n对于给定的排序和 $\\omega$，SOR 方法的收敛性由谱半径 $\\rho(G_{\\omega})$ 决定，即该方法收敛当且仅当 $\\rho(G_{\\omega})  1$。未知量的排序通过置换相似性改变了 $A$ 到 $D$、$L$ 和 $U$ 的分解：如果 $P$ 是表示重新排序的置换矩阵，则重排后的系统为 $\\tilde{A} = P A P^{\\mathsf{T}}$，分裂也相应改变。在非对称情况下，这会强烈影响 $\\rho(G_{\\omega})$，可能导致在不良排序下超松弛 SOR 方法发散。\n\n您的任务是通过计算在指定排序下的 $\\rho(G_{\\omega})$ 来量化 SOR 对排序的敏感性，并构建一个在不良排序下导致 $\\omega  1$ 时发散的反例。\n\n从离散能量平衡和代数分裂 $A = D - L - U$ 的基本原理出发，推导排序如何映射为 $A$ 的置换相似变换，进而得到一个修改后的 $G_{\\omega}$。实现一个程序，该程序：\n\n- 接受以下固定的内部数据作为矩阵、排序和松弛参数的测试套件。\n- 对于每个测试用例，根据指定的排序形成重排矩阵 $\\tilde{A} = P A P^{\\mathsf{T}}$，根据该排序构造 $D$、$L$ 和 $U$，构建 SOR 迭代矩阵 $G_{\\omega}$，计算 $\\rho(G_{\\omega})$，并返回一个布尔值，表示收敛（$\\rho(G_{\\omega})  1$）或发散（$\\rho(G_{\\omega}) \\ge 1$）。\n\n使用以下测试套件，其设计旨在涵盖不同方面，包括对称正定的“理想情况”、非对称的对流主导情况以及边界行为，并明确说明了参数：\n\n- 测试用例 1：对称正定传导问题，$n = 20$，三对角矩阵，对角线元素为 $2$，非对角线元素为 $-1$；自然排序；$\\omega = 1.8$。\n- 测试用例 2：与测试用例 1 相同，但采用反向排序；$\\omega = 1.8$。\n- 测试用例 3：对流主导的非对称系统，$n = 20$，三对角矩阵，对角线元素为 $4.0$，下次对角线元素为 $-0.05$，上次对角线元素为 $-3.9$；自然排序；$\\omega = 1.2$。\n- 测试用例 4：与测试用例 3 相同，但采用反向排序；$\\omega = 1.2$。\n- 测试用例 5：与测试用例 3 相同，但采用反向排序；$\\omega = 1.05$。\n- 测试用例 6：与测试用例 3 相同；自然排序；采用欠松弛，$\\omega = 0.9$。\n\n定义：\n\n- 自然排序是索引 $\\{1,2,\\dots,n\\}$ 上的单位置换 $P = I$。\n- 反向排序是将索引 $i$ 映射到 $n+1-i$ 的置换。\n\n您的程序应生成一行输出，其中包含六个测试用例的结果，格式为方括号括起来的逗号分隔列表（例如，“[true,true,false,...]”）。每个条目都必须是一个布尔值，表示相应测试用例的收敛（true）或发散（false），并按上述顺序列出。这些代数计算不需要物理单位。不涉及角度。不使用百分比；答案条目仅为布尔值。",
            "solution": "核心任务是确定逐次超松弛（SOR）迭代法对于几个源自计算热工问题的线性系统的收敛性。SOR 方法的收敛性由其相关迭代矩阵 $G_{\\omega}$ 的谱半径决定。该方法收敛当且仅当谱半径 $\\rho(G_{\\omega})$ 严格小于 $1$。\n\n该问题关注线性系统 $A \\mathbf{T} = \\mathbf{b}$ 中未知量的排序如何影响此收敛性，特别是对于由对流主导现象产生的非对称矩阵。$n$ 个未知量的一种排序由一个大小为 $n \\times n$ 的置换矩阵 $P$ 表示。应用此排序将原系统转换为一个等价系统：\n$$\n(P A P^{\\mathsf{T}}) (P \\mathbf{T}) = P \\mathbf{b}\n$$\n令 $\\tilde{A} = P A P^{\\mathsf{T}}$、$\\tilde{\\mathbf{T}} = P \\mathbf{T}$ 和 $\\tilde{\\mathbf{b}} = P \\mathbf{b}$。然后将 SOR 方法应用于重排后的系统 $\\tilde{A} \\tilde{\\mathbf{T}} = \\tilde{\\mathbf{b}}$。\n\nSOR 方法基于系数矩阵的分裂。对于重排矩阵 $\\tilde{A}$，其分裂为 $\\tilde{A} = \\tilde{D} - \\tilde{L} - \\tilde{U}$，其中：\n- $\\tilde{D}$ 是 $\\tilde{A}$ 的对角部分。\n- $-\\tilde{L}$ 是 $\\tilde{A}$ 的严格下三角部分。因此，$\\tilde{L}$ 是 $\\tilde{A}$ 严格下三角部分的负值。\n- $-\\tilde{U}$ 是 $\\tilde{A}$ 的严格上三角部分。因此，$\\tilde{U}$ 是 $\\tilde{A}$ 严格上三角部分的负值。\n\n重排后系统的 SOR 迭代公式由下式给出：\n$$\n\\tilde{\\mathbf{T}}^{(k+1)} = (\\tilde{D} - \\omega \\tilde{L})^{-1} \\left( (1 - \\omega) \\tilde{D} + \\omega \\tilde{U} \\right) \\tilde{\\mathbf{T}}^{(k)} + (\\tilde{D} - \\omega \\tilde{L})^{-1} \\omega \\tilde{\\mathbf{b}}\n$$\n其中 $\\omega$ 是松弛参数，$k$ 是迭代指数。此过程的收敛性取决于重排系统 SOR 迭代矩阵 $\\tilde{G}_{\\omega}$ 的谱半径，定义为：\n$$\n\\tilde{G}_{\\omega} = (\\tilde{D} - \\omega \\tilde{L})^{-1} \\left( (1 - \\omega) \\tilde{D} + \\omega \\tilde{U} \\right)\n$$\n收敛条件为 $\\rho(\\tilde{G}_{\\omega})  1$。\n\n为了评估每个测试用例的收敛性，我们遵循一个系统化的计算步骤：\n1. 按规定构造大小为 $n \\times n$ 的基矩阵 $A$。对于主对角线为 $d$、下次对角线为 $l$、上次对角线为 $u$ 的三对角矩阵，其元素为 $A_{ii} = d$、$A_{i, i-1} = l$ 和 $A_{i, i+1} = u$。\n2. 为指定的排序构造置换矩阵 $P$。\n    - 对于自然排序，$P$ 是单位矩阵 $I$。\n    - 对于反向排序，$P$ 是反对角矩阵，其元素为 $P_{i, n+1-i} = 1$（$i=1, \\dots, n$），所有其他元素为 $0$。\n3. 计算重排矩阵 $\\tilde{A} = P A P^{\\mathsf{T}}$。\n4. 分解 $\\tilde{A}$ 以获得矩阵 $\\tilde{D}$、$\\tilde{L}$ 和 $\\tilde{U}$。具体来说：\n    - $\\tilde{D}$ 是一个包含 $\\tilde{A}$ 对角元素的对角矩阵。\n    - $\\tilde{L}$ 是 $\\tilde{A}$ 严格下三角部分的负值。\n    - $\\tilde{U}$ 是 $\\tilde{A}$ 严格上三角部分的负值。\n5. 使用给定的 $\\omega$ 值组装 SOR 迭代矩阵 $\\tilde{G}_{\\omega}$。\n6. 计算 $\\tilde{G}_{\\omega}$ 的特征值 $\\lambda_i$。\n7. 计算谱半径 $\\rho(\\tilde{G}_{\\omega}) = \\max_i |\\lambda_i|$。\n8. 通过测试 $\\rho(\\tilde{G}_{\\omega})  1$ 来判断收敛性。结果是一个布尔值：`true` 表示收敛，`false` 表示发散。\n\n此过程应用于六个测试用例中的每一个。\n\n- 对于测试用例 1 和 2，矩阵 $A$ 是对称正定（SPD）的。对于此类矩阵，已知 SOR 方法对任何松弛参数 $\\omega \\in (0, 2)$ 都是收敛的。由于置换相似变换 $P A P^{\\mathsf{T}}$ 保持了 SPD 性质，因此对于自然排序和反向排序，当 $\\omega = 1.8$ 时，预期都会收敛。\n\n- 对于测试用例 3-6，矩阵 $A$ 是非对称且严格对角占优的，对应于采用迎风差分的对流主导问题。此类矩阵通常是 M-矩阵，对于 M-矩阵，如果 $\\omega \\in (0, 1]$，则保证 SOR 对任何排序都收敛。这预示了测试用例 6（其中 $\\omega = 0.9$）会收敛。对于超松弛（$\\omega > 1$），收敛性无法保证，并且对未知量的排序高度敏感。“自然”排序（$1, 2, \\dots, n$）构成了相对于强耦合方向（从高索引到低索引）的下游扫描，已知这对于 $\\omega > 1$ 的 SOR 是不稳定的。相反，“反向”排序（$n, n-1, \\dots, 1$）构成了上游扫描，与信息流方向一致，通常能实现稳定且快速的收敛。此推理表明测试用例 3（$\\omega = 1.2$，自然排序）会发散，而测试用例 4 和 5（$\\omega = 1.2$ 和 $\\omega=1.05$，反向排序）会收敛。\n\n最终的程序为每个测试用例实现了这一完整的验证过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the problem by evaluating SOR convergence for a suite of test cases.\n    \"\"\"\n\n    def construct_tridiagonal_matrix(n, diag_val, lower_val, upper_val):\n        \"\"\"Constructs a tridiagonal matrix of size n x n.\"\"\"\n        diag = np.full(n, diag_val)\n        lower = np.full(n - 1, lower_val)\n        upper = np.full(n - 1, upper_val)\n        return np.diag(diag) + np.diag(lower, k=-1) + np.diag(upper, k=1)\n\n    def check_sor_convergence(A, ordering, omega):\n        \"\"\"\n        Checks the convergence of the SOR method for a given matrix, ordering, and omega.\n\n        Args:\n            A (np.ndarray): The base coefficient matrix.\n            ordering (str): The ordering of unknowns, 'natural' or 'reverse'.\n            omega (float): The relaxation parameter.\n\n        Returns:\n            bool: True if the method converges, False otherwise.\n        \"\"\"\n        n = A.shape[0]\n\n        # 1. Construct the permutation matrix P\n        if ordering == 'natural':\n            P = np.identity(n)\n        elif ordering == 'reverse':\n            P = np.fliplr(np.identity(n))\n        else:\n            raise ValueError(\"Unknown ordering type\")\n\n        # 2. Compute the reordered matrix A_tilde\n        A_tilde = P @ A @ P.T\n\n        # 3. Decompose A_tilde into D, L, U\n        # Note the convention: A = D - L - U\n        D_tilde = np.diag(np.diag(A_tilde))\n        L_tilde = -np.tril(A_tilde, k=-1)\n        U_tilde = -np.triu(A_tilde, k=1)\n\n        # 4. Construct the SOR iteration matrix G_omega\n        # G_omega = inv(D - omega*L) * ((1-omega)*D + omega*U)\n        # Check if D - omega*L is invertible\n        inv_term = D_tilde - omega * L_tilde\n        try:\n            np.linalg.inv(inv_term)\n        except np.linalg.LinAlgError:\n            # If the matrix is singular, spectral radius is effectively infinite\n            return False\n\n        G_omega = np.linalg.inv(inv_term) @ ((1 - omega) * D_tilde + omega * U_tilde)\n\n        # 5. Compute the spectral radius\n        eigenvalues = np.linalg.eigvals(G_omega)\n        spectral_radius = np.max(np.abs(eigenvalues))\n\n        # 6. Check for convergence\n        return spectral_radius  1.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'n': 20, 'diag': 2.0, 'lower': -1.0, 'upper': -1.0, 'ordering': 'natural', 'omega': 1.8}, # Case 1\n        {'n': 20, 'diag': 2.0, 'lower': -1.0, 'upper': -1.0, 'ordering': 'reverse', 'omega': 1.8}, # Case 2\n        {'n': 20, 'diag': 4.0, 'lower': -0.05, 'upper': -3.9, 'ordering': 'natural', 'omega': 1.2}, # Case 3\n        {'n': 20, 'diag': 4.0, 'lower': -0.05, 'upper': -3.9, 'ordering': 'reverse', 'omega': 1.2}, # Case 4\n        {'n': 20, 'diag': 4.0, 'lower': -0.05, 'upper': -3.9, 'ordering': 'reverse', 'omega': 1.05},# Case 5\n        {'n': 20, 'diag': 4.0, 'lower': -0.05, 'upper': -3.9, 'ordering': 'natural', 'omega': 0.9}  # Case 6\n    ]\n\n    results = []\n    for case in test_cases:\n        # Construct the base matrix A\n        A = construct_tridiagonal_matrix(case['n'], case['diag'], case['lower'], case['upper'])\n        \n        # Check convergence and store the result\n        converges = check_sor_convergence(A, case['ordering'], case['omega'])\n        results.append(str(converges).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了单一方法的基础上，我们现在来解决一个更复杂、更具实践性的挑战：设计一个混合求解器。本练习将雅可比方法易于并行的特性与逐次超松弛（SOR）方法的快速收敛性相结合，并采用自适应准则在两者之间切换。您将实现一个策略，用于动态估计雅可比方法的收敛速率，并利用该估计值为SOR选择一个近乎最优的松弛参数，从而展示一种在实际计算代码中使用的强大技术。",
            "id": "3986541",
            "problem": "考虑一个方形域中的稳态热传导问题，其边界条件为齐次狄利克雷边界条件，由偏微分方程 $- \\nabla \\cdot ( \\mathbf{k} \\nabla T ) = f(x,y)$ 控制，其中 $\\mathbf{k} = \\mathrm{diag}(k_x,k_y)$ 是一个恒定的正定热导率张量，其分量 $k_x  0$ 和 $k_y  0$。使用具有 $n \\times n$ 个内部点、网格间距为 $h = 1/(n+1)$ 的均匀笛卡尔网格，并采用标准的二阶中心差分格式，内部点的有限差分方程可写作\n$$\n2(k_x + k_y) \\, T_{i,j} - k_x \\left( T_{i+1,j} + T_{i-1,j} \\right) - k_y \\left( T_{i,j+1} + T_{i,j-1} \\right) = h^2 f_{i,j},\n$$\n对于 $i,j \\in \\{1,2,\\dots,n\\}$，且边界上 $T=0$。\n\n您必须设计并实现一个混合定常迭代求解器，该求解器以 Jacobi 方法开始以利用其并行更新结构，然后在观察到的残差下降率稳定时切换到逐次超松弛 (Successive Over-Relaxation, SOR) 方法。第 $k$ 次迭代的残差逐点定义为\n$$\nr^{(k)}_{i,j} = 2(k_x + k_y) \\, T^{(k)}_{i,j} - k_x \\left( T^{(k)}_{i+1,j} + T^{(k)}_{i-1,j} \\right) - k_y \\left( T^{(k)}_{i,j+1} + T^{(k)}_{i,j-1} \\right) - h^2 f_{i,j},\n$$\n残差范数为 $||r^{(k)}||_2 = \\left( \\sum_{i=1}^n \\sum_{j=1}^n \\left(r^{(k)}_{i,j}\\right)^2 \\right)^{1/2}$。Jacobi 更新公式为\n$$\nT^{(k+1)}_{i,j} = \\frac{k_x \\left( T^{(k)}_{i+1,j} + T^{(k)}_{i-1,j} \\right) + k_y \\left( T^{(k)}_{i,j+1} + T^{(k)}_{i,j-1} \\right) + h^2 f_{i,j}}{2(k_x + k_y)},\n$$\n以及带有松弛因子 $\\omega \\in (0,2)$ 的逐次超松弛 (SOR) 更新公式为\n$$\nT^{(k+1)}_{i,j} = (1-\\omega) T^{(k)}_{i,j} + \\omega \\, \\frac{k_x \\left( T^{(k)}_{i+1,j} + T^{(k+1)}_{i-1,j} \\right) + k_y \\left( T^{(k)}_{i,j+1} + T^{(k+1)}_{i,j-1} \\right) + h^2 f_{i,j}}{2(k_x + k_y)},\n$$\n其中 Gauss–Seidel 顺序使用最新的相邻点值。\n\n切换准则：在 Jacobi 迭代期间，计算比率序列 $q_k = ||r^{(k)}||_2 / ||r^{(k-1)}||_2$。在经过最少 $N_{\\min}$ 次 Jacobi 迭代后，在一个长度为 $m$ 的滑动窗口上计算这些比率，如果窗口内的比率稳定且严格收缩，则切换到 SOR。稳定且严格收缩的解释是 $\\max(q_{k-m+1},\\dots,q_k) - \\min(q_{k-m+1},\\dots,q_k) \\le \\delta$ 且 $\\frac{1}{m}\\sum_{j=k-m+1}^k q_j  1$。在切换时，将窗口内比率的平均值作为 $\\hat{\\rho}_J$ 的估计值，并使用一个基于 $\\hat{\\rho}_J$ 的、有科学依据的函数来选择超松弛因子 $\\omega$。您必须确保 $\\omega \\in (0,2)$，并在您的解决方案中记录其理由。\n\n停止准则：使用相对残差范数阈值 $||r^{(k)}||_2 / ||r^{(0)}||_2 \\le \\tau$，从零初始猜测 $T^{(0)}_{i,j} = 0$ 开始。\n\n实现该混合求解器，并将其应用于以下三个测试用例。在每个用例中，区域为单位正方形，边界条件为 $T=0$，内部网格大小为 $n \\times n$。\n\n- 测试用例 A (通用、各向同性、常数源):\n  - $n = 50$\n  - $k_x = 1$, $k_y = 1$\n  - $f(x,y) = 1$\n  - 相对容差 $\\tau = 10^{-6}$\n  - 滑动窗口长度 $m = 20$\n  - 最小 Jacobi 迭代次数 $N_{\\min} = 40$\n  - 最大 Jacobi 迭代次数 $N_{\\max} = 100$\n  - 稳定带 $\\delta = 5 \\times 10^{-4}$\n\n- 测试用例 B (各向异性、平滑源):\n  - $n = 60$\n  - $k_x = 4$, $k_y = 1$\n  - $f(x,y) = \\sin(\\pi x)\\sin(\\pi y)$\n  - 相对容差 $\\tau = 5 \\times 10^{-7}$\n  - 滑动窗口长度 $m = 25$\n  - 最小 Jacobi 迭代次数 $N_{\\min} = 50$\n  - 最大 Jacobi 迭代次数 $N_{\\max} = 120$\n  - 稳定带 $\\delta = 8 \\times 10^{-4}$\n\n- 测试用例 C (小网格、高频棋盘源):\n  - $n = 8$\n  - $k_x = 1$, $k_y = 1$\n  - $f_{i,j} = (-1)^{i+j}$\n  - 相对容差 $\\tau = 10^{-6}$\n  - 滑动窗口长度 $m = 10$\n  - 最小 Jacobi 迭代次数 $N_{\\min} = 15$\n  - 最大 Jacobi 迭代次数 $N_{\\max} = 40$\n  - 稳定带 $\\delta = 10^{-3}$\n\n输出规格：对于每个测试用例，计算并返回一个包含三个量的列表：\n- 满足停止准则所需的总迭代次数（Jacobi 迭代次数加 SOR 迭代次数）（整数），\n- 是否切换到逐次超松弛 (SOR) 的指示符（若切换则为 $1$，否则为 $0$），\n- SOR 中使用的最终松弛因子 $\\omega$（浮点数，四舍五入到 $5$ 位小数；如果从未使用 SOR，则报告 $\\omega = 1.0$）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个测试用例的三元组都包含在各自的子括号中，例如 $[ [a_1,b_1,c_1], [a_2,b_2,c_2], [a_3,b_3,c_3] ]$，其中每个 $a_k$ 是一个整数，每个 $b_k$ 是 $\\{0,1\\}$ 中的一个整数，每个 $c_k$ 是一个四舍五入到 $5$ 位小数的浮点数。",
            "solution": "用户在偏微分方程数值方法领域提供了一个定义明确的计算问题。该问题科学上合理，内容自洽，算法上精确。因此，该问题被认定为有效，并将构建一个解决方案。\n\n### **1. 问题公式化**\n\n该问题涉及二维方形域中稳态热传导方程的数值解：\n$$\n- \\nabla \\cdot ( \\mathbf{k} \\nabla T ) = f(x,y)\n$$\n其中 $\\mathbf{k} = \\mathrm{diag}(k_x, k_y)$ 是一个对角热导率张量，其常数正分量为 $k_x$ 和 $k_y$，$T(x,y)$ 是温度场，$f(x,y)$ 是热源项。边界条件为齐次狄利克雷边界条件，即在正方形的所有边界上 $T=0$。\n\n在具有 $n \\times n$ 个内部点和网格间距 $h = 1/(n+1)$ 的均匀笛卡尔网格上，使用二阶中心差分格式对该方程进行离散化，得到一个线性代数方程组。对于每个内部网格点 $(i,j)$，其中 $i, j \\in \\{1, \\dots, n\\}$，方程为：\n$$\n2(k_x + k_y) T_{i,j} - k_x ( T_{i+1,j} + T_{i-1,j} ) - k_y ( T_{i,j+1} + T_{i,j-1} ) = h^2 f_{i,j}\n$$\n该系统可以写成矩阵形式 $A\\mathbf{T} = \\mathbf{b}$，其中 $\\mathbf{T}$ 是未知温度 $T_{i,j}$ 组成的向量。矩阵 $A$ 是一个大型稀疏矩阵，且当 $k_x, k_y  0$ 时，它是对称正定 (Symmetric Positive-Definite, SPD) 的。这个 SPD 属性至关重要，因为它保证了所提出的迭代方法的收敛性。\n\n### **2. 混合迭代求解器设计**\n\n任务是实现一个混合迭代求解器，它以 Jacobi 方法开始，并根据收敛行为自适应地切换到逐次超松弛 (SOR) 方法。\n\n#### **2.1. Jacobi 方法**\n\nJacobi 方法是一种迭代方案，其中新迭代值 $T^{(k+1)}$ 的每个分量仅使用前一个迭代值 $T^{(k)}$ 的分量来计算。点 $(i,j)$ 的更新规则是：\n$$\nT^{(k+1)}_{i,j} = \\frac{k_x ( T^{(k)}_{i+1,j} + T^{(k)}_{i-1,j} ) + k_y ( T^{(k)}_{i,j+1} + T^{(k)}_{i,j-1} ) + h^2 f_{i,j}}{2(k_x + k_y)}\n$$\nJacobi 方法的一个关键特性是，所有点 $(i,j)$ 的更新可以同时（并行）执行，因为在同一次迭代中它们彼此不依赖。这是通过在当前迭代的所有计算中使用前一次迭代的温度场的副本来实现的。\n\n#### **2.2. 逐次超松弛 (SOR) 方法**\n\nSOR 是 Gauss-Seidel 方法的一种增强。它通过取前一迭代值 $T^{(k)}_{i,j}$ 和由 Gauss-Seidel 步骤预测的值的加权平均来计算新的迭代值 $T^{(k+1)}_{i,j}$。按顺序（例如，按字典顺序）应用于网格点，其更新规则为：\n$$\nT^{(k+1)}_{i,j} = (1-\\omega) T^{(k)}_{i,j} + \\omega \\, \\frac{k_x (T^{(k)}_{i+1,j} + T^{(k+1)}_{i-1,j}) + k_y (T^{(k)}_{i,j+1} + T^{(k+1)}_{i,j-1}) + h^2 f_{i,j}}{2(k_x + k_y)}\n$$\n这里，$\\omega \\in (0, 2)$ 是松弛因子。在更新 $T_{i,j}$ 时，$T_{i-1,j}$ 和 $T_{i,j-1}$ 的值已经在第 $(k+1)$ 次迭代中更新为新值，而 $T_{i+1,j}$ 和 $T_{i,j+1}$ 仍为第 $k$ 次迭代的值。这种顺序数据依赖性使得标准形式的 SOR 本质上是不可并行的，但如果 $\\omega$ 选择得当，其收敛速度通常比 Jacobi 快。\n\n#### **2.3. 切换准则与 $\\omega$ 估计**\n\n求解器以 Jacobi 迭代开始。混合策略的核心是切换到 SOR 的准则。\n1.  **监控：** 在 Jacobi 阶段，我们在每次迭代 $k$ 时计算残差的 L2 范数 $||r^{(k)}||_2$。残差定义为 $r^{(k)} = A T^{(k)} - \\mathbf{b}$，其逐点分量为 $r^{(k)}_{i,j} = 2(k_x + k_y) T^{(k)}_{i,j} - k_x (T^{(k)}_{i+1,j} + T^{(k)}_{i-1,j}) - k_y (T^{(k)}_{i,j+1} + T^{(k)}_{i,j-1}) - h^2 f_{i,j}$。然后我们跟踪残差下降比率的序列 $q_k = ||r^{(k)}||_2 / ||r^{(k-1)}||_2$。\n2.  **条件：** 对于在 $N_{\\min}$ 和 $N_{\\max}$ 之间的迭代 $k$，我们检查一个包含最近 $m$ 个比率的滑动窗口。如果同时满足两个条件，则触发切换到 SOR：\n    -   窗口中的比率已稳定：$\\max(q_{k-m+1}, \\dots, q_k) - \\min(q_{k-m+1}, \\dots, q_k) \\le \\delta$。\n    -   求解器正在收敛：平均比率 $\\frac{1}{m}\\sum_{j=k-m+1}^k q_j  1$。\n3.  **Omega 估计：** 切换时，窗口内比率的平均值 $\\hat{\\rho}_J = \\text{mean}(q_{k-m+1}, \\dots, q_k)$ 用作 Jacobi 迭代矩阵谱半径的估计。这是合理的，因为对于收敛的线性迭代，其渐近收敛率由谱半径决定，而谱半径表现为连续误差（和残差）范数的比率。对于由这种离散化产生的矩阵类别，一个公认的理论结果将最优 SOR 松弛因子 $\\omega_{\\text{opt}}$ 与 Jacobi 谱半径 $\\rho_J$ 联系起来：\n    $$\n    \\omega_{\\text{opt}} = \\frac{2}{1 + \\sqrt{1 - \\rho_J^2}}\n    $$\n    我们在此公式中使用我们的估计值 $\\hat{\\rho}_J$ 来计算后续 SOR 迭代的 $\\omega$ 值。由于切换条件要求 $\\hat{\\rho}_J  1$，平方根的参数为正，计算出的 $\\omega$ 将在范围 $[1, 2)$ 内，满足收敛要求 $\\omega \\in (0, 2)$。如果求解器未切换到 SOR，则报告 $\\omega$ 为 $1.0$。\n\n### **3. 算法实现**\n\n总体算法如下：\n1.  **初始化：**\n    -   设置网格参数 $n$，$h$。构建用于温度 $T$ 和源项 $f$ 的 $(n+2) \\times (n+2)$ 数组。初始化 $T^{(0)} = 0$。\n    -   根据测试用例计算源项数组 $f$ 和右侧项数组 $\\mathbf{b} = h^2 f$。\n    -   计算初始残差范数 $||r^{(0)}||_2 = ||A T^{(0)} - \\mathbf{b}||_2 = ||-\\mathbf{b}||_2$。\n    -   确定停止容差：$||r^{(k)}||_2 \\le \\tau ||r^{(0)}||_2$。\n\n2.  **主迭代循环：**\n    -   循环继续直到满足停止准则。\n    -   初始化 `mode = 'jacobi'`, `switched = 0`, `iter_count = 0`。\n    -   在循环内部，如果 `mode == 'jacobi'`:\n        -   执行一次 Jacobi 更新，从 $T^{(k)}$ 得到 $T^{(k+1)}$。\n        -   增加 `iter_count`。\n        -   计算新的残差范数 $||r^{(k+1)}||_2$。\n        -   计算并存储比率 $q_{k+1} = ||r^{(k+1)}||_2 / ||r^{(k)}||_2$。\n        -   如果 $N_{\\min} \\le \\text{iter\\_count} \\le N_{\\max}$ 且有足够的比率可用，检查切换条件。如果满足，设置 `mode = 'sor'`, `switched = 1`，并计算 $\\omega$。\n    -   如果 `mode == 'sor'`:\n        -   通过遍历所有内部网格点来执行一次 SOR 更新。\n        -   增加 `iter_count`。\n        -   计算新的残差范数 $||r^{(k+1)}||_2$。\n\n3.  **终止：**\n    -   一旦 $||r^{(k)}||_2$ 降至目标值以下，循环终止。\n    -   为该测试用例记录总 `iter_count`、`switched` 标志（$1$ 或 $0$）和计算出的 `omega`（如果未发生切换则为 $1.0$）。\n\n为所提供的三个测试用例中的每一个都实现了此结构。",
            "answer": "```python\nimport numpy as np\n\ndef run_solver(n, kx, ky, f_type, tau, m, N_min, N_max, delta):\n    \"\"\"\n    Implements the hybrid Jacobi-SOR solver for a single test case.\n\n    Args:\n        n (int): Number of interior grid points along one dimension.\n        kx (float): Conductivity in the x-direction.\n        ky (float): Conductivity in the y-direction.\n        f_type (str): Type of source function ('constant', 'sinsin', 'checkerboard').\n        tau (float): Relative tolerance for stopping criterion.\n        m (int): Sliding window length for switching criterion.\n        N_min (int): Minimum number of Jacobi iterations before checking switch condition.\n        N_max (int): Maximum number of Jacobi iterations before checking switch condition.\n        delta (float): Stability band for ratios in switching criterion.\n\n    Returns:\n        tuple: (total_iterations, switched_flag, omega_value)\n    \"\"\"\n    h = 1.0 / (n + 1)\n\n    # Setup source term f and RHS b\n    f = np.zeros((n + 2, n + 2))\n    if f_type == 'constant':\n        f[1:-1, 1:-1] = 1.0\n    elif f_type == 'sinsin':\n        # Use 'ij' indexing to match loops used for i, j indices\n        x_coords = np.linspace(0, 1, n + 2)\n        y_coords = np.linspace(0, 1, n + 2)\n        X, Y = np.meshgrid(x_coords, y_coords, indexing='ij')\n        f = np.sin(np.pi * X) * np.sin(np.pi * Y)\n    elif f_type == 'checkerboard':\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                f[i, j] = (-1)**(i + j)\n    b = h**2 * f\n\n    def calculate_residual_norm(T_mat):\n        \"\"\"Computes the L2 norm of the residual r = AT - b.\"\"\"\n        res_mat = (2 * (kx + ky) * T_mat[1:-1, 1:-1] -\n                   kx * (T_mat[2:, 1:-1] + T_mat[:-2, 1:-1]) -\n                   ky * (T_mat[1:-1, 2:] + T_mat[1:-1, :-2]) -\n                   b[1:-1, 1:-1])\n        return np.linalg.norm(res_mat)\n\n    # Initialization\n    T = np.zeros((n + 2, n + 2))\n    \n    initial_res_norm = calculate_residual_norm(T)\n    if initial_res_norm == 0:\n        return 0, 0, 1.0\n        \n    stop_norm = tau * initial_res_norm\n    \n    iter_count = 0\n    switched = 0\n    omega = 1.0\n    mode = 'jacobi'\n    res_ratios = []\n    \n    current_res_norm = initial_res_norm\n    # Safety break to prevent infinite loops\n    max_total_iters = 50000 \n    \n    while current_res_norm > stop_norm and iter_count  max_total_iters:\n        T_old = np.copy(T)\n        previous_res_norm = current_res_norm\n\n        if mode == 'jacobi':\n            # Jacobi update\n            T[1:-1, 1:-1] = (kx * (T_old[2:, 1:-1] + T_old[:-2, 1:-1]) +\n                             ky * (T_old[1:-1, 2:] + T_old[1:-1, :-2]) +\n                             b[1:-1, 1:-1]) / (2 * (kx + ky))\n            \n            iter_count += 1\n            current_res_norm = calculate_residual_norm(T)\n            \n            if previous_res_norm > 1e-15:\n                res_ratios.append(current_res_norm / previous_res_norm)\n            \n            if N_min = iter_count = N_max and len(res_ratios) >= m:\n                window = res_ratios[-m:]\n                mean_q = np.mean(window)\n                \n                if (np.max(window) - np.min(window) = delta) and (mean_q  1.0):\n                    switched = 1\n                    mode = 'sor'\n                    rho_J_est = mean_q\n                    omega = 2 / (1 + np.sqrt(1 - rho_J_est**2))\n        \n        else: # mode == 'sor'\n            # SOR update\n            for i in range(1, n + 1):\n                for j in range(1, n + 1):\n                    # Uses newest T[i-1,j] and T[i,j-1] from this sweep\n                    gs_sum = kx * (T[i+1, j] + T[i-1, j]) + ky * (T[i, j+1] + T[i, j-1])\n                    gs_term = (gs_sum + b[i, j]) / (2 * (kx + ky))\n                    T[i, j] = (1 - omega) * T_old[i, j] + omega * gs_term\n            \n            iter_count += 1\n            current_res_norm = calculate_residual_norm(T)\n            \n    if switched == 0:\n        omega_val = 1.0\n    else:\n        omega_val = omega\n\n    return iter_count, switched, omega_val\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test Case A\n        {'n': 50, 'kx': 1, 'ky': 1, 'f_type': 'constant', 'tau': 1e-6,\n         'm': 20, 'N_min': 40, 'N_max': 100, 'delta': 5e-4},\n        # Test Case B\n        {'n': 60, 'kx': 4, 'ky': 1, 'f_type': 'sinsin', 'tau': 5e-7,\n         'm': 25, 'N_min': 50, 'N_max': 120, 'delta': 8e-4},\n        # Test Case C\n        {'n': 8, 'kx': 1, 'ky': 1, 'f_type': 'checkerboard', 'tau': 1e-6,\n         'm': 10, 'N_min': 15, 'N_max': 40, 'delta': 1e-3}\n    ]\n\n    results = []\n    for case in test_cases:\n        iters, switch_flag, omega_final = run_solver(**case)\n        results.append([iters, switch_flag, omega_final])\n\n    # Format the output string precisely as requested\n    formatted_results = []\n    for r in results:\n        # r[2] is float; format it to 5 decimal places\n        formatted_results.append(f\"[{r[0]},{r[1]},{r[2]:.5f}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}