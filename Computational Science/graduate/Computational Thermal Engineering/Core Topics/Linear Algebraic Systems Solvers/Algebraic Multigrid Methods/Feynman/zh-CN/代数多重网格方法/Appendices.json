{
    "hands_on_practices": [
        {
            "introduction": "代数多重网格（AMG）方法的核心在于其能高效处理不同频率的误差。本练习将通过一个基础的数值实验，直观地展示松弛法在衰减高频误差方面的有效性，以及它在处理低频（平滑）误差分量时的不足。你将亲手构建一个双网格循环，定量地比较它与单纯松弛法在处理平滑误差时的巨大性能差异，从而深刻理解多重网格方法的根本优势。",
            "id": "3936595",
            "problem": "一个具有恒定且可能各向异性的热导率的稳态热传导问题，由能量守恒基本定律决定。在没有内部热源的情况下，其连续介质模型由偏微分方程 $-\\nabla \\cdot (k \\nabla T) = 0$ 给出，其中 $k$ 是热导率张量，$T$ 是温度。对于具有齐次狄利克雷（Dirichlet）边界条件的正方形域，通过在均匀笛卡尔内部点网格上采用二阶有限差分格式进行离散化，会得到一个对称正定的线性系统 $A x = b$，其中 $A$ 编码了离散扩散算子，$x$ 代表节点温度，$b$ 是源向量。在计算热工学中，诸如加权雅可比（weighted Jacobi）法之类的松弛方法能够有效衰减误差的高频分量，但对低频分量影响甚微。代数多重网格（Algebraic Multigrid, AMG）方法通过构建粗糙表示来处理这些低频分量，而双网格法作为AMG的一个基本组成部分，将松弛与粗网格校正相结合，以减少低频误差。\n\n你的任务是构建一个独立的数值示例，使用代数伽辽金（Galerkin）粗化算子，来演示双网格法如何减少仅靠松弛无法消除的低频误差分量。你必须从第一性原理出发，实现以下算法组件：\n\n- 离散热算子构建：为具有齐次狄利克雷边界条件的均匀 $n \\times n$ 内部网格构建离散扩散算子 $A$。对可能各向异性的热导率（主值为 $k_x$ 和 $k_y$）使用五点差分格式，网格间距为 $h_x = h_y = 1/(n+1)$。离散算子必须是对称正定的。形式上，对于二维情况，这可以表示为沿 $x$ 和 $y$ 方向的一维二阶导数算子的克罗内克（Kronecker）和。\n\n- 松弛格式：在齐次误差方程上实现权重为 $\\omega$ 的加权雅可比松弛算子。如果 $D$ 表示 $A$ 的对角线，则一个松弛步根据由 $A$ 和 $D$ 决定的迭代矩阵来更新当前误差 $e$。使用此松弛格式进行指定次数的扫描。\n\n- 代数限制与延拓：构建一个从细网格到粗网格的标准全加权限制算子 $R$，以及一个从粗网格到细网格的线性插值延拓算子 $P$，使得伽辽金粗网格算子 $A_c$ 定义为 $A_c = R A P$。对二维情况使用张量积构造，并确保 $P$ 和 $R$ 在变分原理意义上是相容的。\n\n- 用于误差缩减的双网格V-循环：在误差上实现一个单独的双网格循环。应用 $\\nu_1$ 次预松弛扫描，计算残差 $r = A e$，将其限制到粗网格，在粗网格上精确求解 $A_c d_c = r_c$，将校正量 $d_f = P d_c$ 延拓回细网格，更新误差 $e \\leftarrow e - d_f$，并应用 $\\nu_2$ 次后松弛扫描。\n\n- 初始误差模式：在细网格上生成初始误差 $e_0$，可使用低频模式 $e_{ij} = \\sin(\\pi x_i) \\sin(\\pi y_j)$（其中 $x_i = i h$，$h = 1/(n+1)$，$i = 1, \\dots, n$），或使用映射到内部网格索引的高频棋盘格模式 $e_{ij} = (-1)^{i+j}$。\n\n对于每个测试用例，计算并报告两个量化指标：\n1. 仅松弛缩减因子，定义为在误差上进行指定次数的加权雅可比扫描后，$\\|e_{\\text{relax}}\\|_2 / \\|e_0\\|_2$ 的值。\n2. 双网格缩减因子，定义为在进行一次具有指定预松弛和后松弛扫描的双网格V-循环后，$\\|e_{\\text{TG}}\\|_2 / \\|e_0\\|_2$ 的值。\n\n设计并实现程序以处理以下测试套件，该套件涵盖了理想路径、最小平滑、各向异性和高频边缘行为：\n\n- 测试用例 1：$n = 32$，$k_x = 1.0$，$k_y = 1.0$，低频初始误差，松弛扫描 $s = 10$，松弛权重 $\\omega = 2/3$，双网格预扫描 $\\nu_1 = 3$，双网格后扫描 $\\nu_2 = 3$。\n- 测试用例 2：$n = 32$，$k_x = 1.0$，$k_y = 1.0$，低频初始误差，松弛扫描 $s = 1$，松弛权重 $\\omega = 2/3$，双网格预扫描 $\\nu_1 = 1$，双网格后扫描 $\\nu_2 = 1$。\n- 测试用例 3：$n = 32$，$k_x = 1.0$，$k_y = 0.1$，低频初始误差，松弛扫描 $s = 10$，松弛权重 $\\omega = 2/3$，双网格预扫描 $\\nu_1 = 3$，双网格后扫描 $\\nu_2 = 3$。\n- 测试用例 4：$n = 32$，$k_x = 1.0$，$k_y = 1.0$，高频初始误差，松弛扫描 $s = 10$，松弛权重 $\\omega = 2/3$，双网格预扫描 $\\nu_1 = 3$，双网格后扫描 $\\nu_2 = 3$。\n\n在离散设置中，所有计算都是无量纲的。你的程序必须输出一行结果，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表。每个结果都必须是一个包含两个浮点数的列表，形式为 $[\\text{relax\\_factor}, \\text{two\\_grid\\_factor}]$，每个因子都按上述规定计算。例如，最终输出的形式必须为 $[[a,b],[c,d],[e,f],[g,h]]$，其中 $a$, $b$, $c$, $d$, $e$, $f$, $g$, 和 $h$ 是浮点数。",
            "solution": "该问题要求通过数值方式，演示双网格多重网格法在减少离散化热传导问题的低频误差分量方面的有效性。这将与简单的基于松弛的求解器（加权雅可比法）的性能进行对比，后者已知在处理此类误差分量时效率低下。分析是在齐次误差方程 $A e = 0$ 上进行的，其中 $A$ 是离散算子，$e$ 是误差向量。\n\n我们将从第一性原理出发构建所有算法组件：离散算子 $A$、松弛格式、网格间传递算子（限制算子 $R$ 和延拓算子 $P$）、粗网格算子 $A_c$ 以及双网格循环。\n\n**1. 离散热算子 $A$**\n\n对于具有各向异性热导率 $k$ 且无热源的稳态热传导问题，其控制偏微分方程为 $-\\nabla \\cdot (k \\nabla T) = 0$。对于主导热传导方向与笛卡尔坐标轴对齐的二维域，该方程展开为：\n$$\n- \\frac{\\partial}{\\partial x} \\left( k_x \\frac{\\partial T}{\\partial x} \\right) - \\frac{\\partial}{\\partial y} \\left( k_y \\frac{\\partial T}{\\partial y} \\right) = 0\n$$\n我们在单位正方形上一个均匀的 $n \\times n$ 内部点网格上离散化此方程。网格间距为 $h_x = h_y = h = 1/(n+1)$。使用二阶中心有限差分格式，内部网格点 $(i,j)$ 处的方程变为：\n$$\n-k_x \\frac{T_{i+1,j} - 2T_{i,j} + T_{i-1,j}}{h^2} - k_y \\frac{T_{i,j+1} - 2T_{i,j} + T_{i,j-1}}{h^2} = 0\n$$\n整理各项，我们得到单个网格点的差分格式：\n$$\n\\frac{1}{h^2} \\left[ (2k_x + 2k_y)T_{i,j} - k_x T_{i+1,j} - k_x T_{i-1,j} - k_y T_{i,j+1} - k_y T_{i,j-1} \\right] = 0\n$$\n这定义了线性系统 $A x = b$。对于我们的齐次误差方程，即 $A e = 0$。矩阵 $A$ 的大小为 $n^2 \\times n^2$，通过为所有 $n^2$ 个点组装差分格式而构建，假设网格点采用字典序排列。通过将边界上的节点值设为零来引入齐次狄利克雷边界条件。\n\n矩阵 $A$ 可以优雅地表示为一维离散拉普拉斯算子的克罗内克和。设 $A_{1D}$ 为代表一维二阶导数的 $n \\times n$ 三对角矩阵，其副对角线、主对角线和超对角线上的值分别为 $-1, 2, -1$。设 $I_n$ 为 $n \\times n$ 单位矩阵。则完整的二维算子 $A$ 为：\n$$\nA = \\frac{k_x}{h^2} (I_n \\otimes A_{1D}) + \\frac{k_y}{h^2} (A_{1D} \\otimes I_n)\n$$\n其中 $\\otimes$ 表示克罗内克积。此构造产生一个对称正定矩阵 $A$。\n\n**2. 初始误差模式**\n\n为了测试该方法的效能，我们用特定的空间频率初始化误差向量 $e_0$：\n- **低频模式**：$e_{ij} = \\sin(\\pi x_i) \\sin(\\pi y_j)$，其中 $x_i = ih$ 且 $y_j = jh$。此模式是光滑的，并且对应于单位正方形上连续拉普拉斯算子的最低频率特征函数。松弛方法在抑制此类误差时是出了名的缓慢。\n- **高频模式**：$e_{ij} = (-1)^{i+j}$。这是一个高度振荡的棋盘格模式。松弛方法在抑制此类误差时非常有效。\n\n**3. 松弛格式：加权雅可比法**\n\n加权雅可比法是一种迭代平滑器。对于齐次方程 $A e = 0$，误差向量 $e$ 的更新规则源自 $Ax=b$ 的迭代式 $x^{(k+1)} = x^{(k)} + \\omega D^{-1}(b-Ax^{(k)})$。这导致了误差 $e^{(k)}$ 的更新：\n$$\ne^{(k+1)} = (I - \\omega D^{-1}A) e^{(k)}\n$$\n其中 $I$ 是单位矩阵，$D$ 是 $A$ 的对角线，$\\omega$ 是松弛权重。对于对称正定矩阵，保证收敛的典型 $\\omega$ 值为 $\\omega=2/3$。此平滑器将应用指定的扫描次数。\n\n**4. 网格间传递算子：限制与延拓**\n\n多重网格的一个关键组成部分是在细网格（大小为 $n \\times n$）和更粗的网格之间传递信息。对于此问题，我们使用大小为 $n_c \\times n_c$ 的粗网格，其中 $n_c = n/2$。\n- **延拓（插值）算子 $P$**：此算子将向量从粗网格映射到细网格。我们使用双线性插值。在一维中，一个粗网格值被注入到其对应的细网格节点上，并线性插值到粗网格节点之间的中点。二维延拓算子 $P$ 由一维延拓算子 $P_{1D}$ 与自身的克罗内克积形成：$P = P_{1D} \\otimes P_{1D}$。$P$ 是一个 $n^2 \\times n_c^2$ 的矩阵。\n- **限制算子 $R$**：此算子将向量从细网格映射到粗网格。我们使用全加权限制，其中一个粗网格值是其在细网格上九个最近邻居的加权平均。对于伽辽金粗化算子，限制和延拓算子必须是相容的。满足变分原理的标准选择是 $R = c P^T$，其中 $c$ 是某个标量。对于我们选择的 $P$ 和标准全加权，关系为 $R = \\frac{1}{4}P^T$。$R$ 是一个 $n_c^2 \\times n^2$ 的矩阵。\n\n**5. 粗网格算子与双网格循环**\n\n粗网格算子 $A_c$ 使用伽辽金原理构建：\n$$\nA_c = R A P\n$$\n这种构造确保粗算子继承了细算子的性质，如对称性和正定性，并正确地表示了细网格算子在低频分量上的作用。$A_c$ 是一个大小为 $n_c^2 \\times n_c^2$ 的小型稠密矩阵。\n\n针对误差向量 $e$ 的单个双网格V-循环过程如下：\n1.  **预松弛**：对当前误差 $e$ 应用 $\\nu_1$ 次加权雅可比平滑器扫描。令结果为 $e'$。\n    $e' \\leftarrow (I - \\omega D^{-1}A)^{\\nu_1} e$\n2.  **计算残差**：在细网格上计算残差。根据问题陈述，$r = A e'$。\n3.  **限制残差**：将残差传递到粗网格：$r_c = R r$。\n4.  **求解粗网格问题**：为粗网格校正量 $d_c$ 精确求解粗网格系统 $A_c d_c = r_c$。由于 $A_c$ 很小，这是可行的。\n5.  **延拓校正量**：将校正量插值回细网格：$d_f = P d_c$。\n6.  **校正误差**：更新细网格误差：$e'' = e' - d_f$。\n7.  **后松弛**：对 $e''$ 应用 $\\nu_2$ 次加权雅可比平滑器扫描，以平滑由插值引入的高频误差。最终误差为 $e_{TG} = (I - \\omega D^{-1}A)^{\\nu_2} e''$。\n\n**6. 量化评估**\n\n对于每个测试用例，我们计算两个指标来量化性能：\n1.  **仅松弛缩减因子**：$\\|e_{\\text{relax}}\\|_2 / \\|e_0\\|_2$，其中 $e_{\\text{relax}}$ 是经过 $s$ 次雅可比扫描后的误差。\n2.  **双网格缩减因子**：$\\|e_{\\text{TG}}\\|_2 / \\|e_0\\|_2$，其中 $e_{\\text{TG}}$ 是经过一次双网格V-循环后的误差。\n\n这些指标将说明，对于低频误差，双网格因子显著小于仅松弛因子，从而证实了粗网格校正的有效性。对于高频误差，预计两种方法都将是有效的。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron, lil_matrix, csc_matrix\n\ndef build_discrete_operator(n, k_x, k_y):\n    \"\"\"\n    Constructs the discrete diffusion operator A, inter-grid operators P and R,\n    and the coarse-grid operator Ac.\n    \"\"\"\n    h = 1.0 / (n + 1)\n    \n    # 1D discrete Laplacian\n    diag_vals = [-1.0, 2.0, -1.0]\n    offsets = [-1, 0, 1]\n    A_1d = diags(diag_vals, offsets, shape=(n, n), format='csc')\n    \n    I_n = identity(n, format='csc')\n    \n    # 2D discrete operator A using Kronecker sum\n    A = (k_x / h**2) * kron(I_n, A_1d) + (k_y / h**2) * kron(A_1d, I_n)\n    A = csc_matrix(A)\n    \n    # Diagonal of A for Jacobi smoother\n    D = A.diagonal()\n    \n    # Coarsening\n    n_c = n // 2\n    if n % 2 != 0:\n        raise ValueError(\"n must be even for this coarsening strategy.\")\n\n    # 1D Prolongation operator P_1d\n    P_1d = lil_matrix((n, n_c))\n    for j in range(n_c):\n        # Injection to fine node 2*j+1 from coarse node j\n        P_1d[2*j + 1, j] = 1.0\n        # Interpolation to fine node 2*j\n        if j > 0:\n            P_1d[2*j, j - 1] = 0.5\n        P_1d[2*j, j] = 0.5\n    P_1d = csc_matrix(P_1d)\n\n    # 2D Prolongation operator P\n    P = kron(P_1d, P_1d, format='csc')\n    \n    # 2D Restriction operator R (Galerkin compatibility)\n    R = 0.25 * P.T\n    R = csc_matrix(R)\n\n    # Galerkin Coarse-grid operator Ac\n    A_c_sparse = R @ A @ P\n    A_c = A_c_sparse.toarray()\n    \n    return A, D, P, R, A_c\n\ndef create_initial_error(n, error_type='low_frequency'):\n    \"\"\"\n    Generates the initial error vector, either low-frequency (smooth) or\n    high-frequency (oscillatory).\n    \"\"\"\n    h = 1.0 / (n + 1)\n    e_2d = np.zeros((n, n))\n    \n    if error_type == 'low_frequency':\n        for i in range(n):\n            for j in range(n):\n                x_i = (i + 1) * h\n                y_j = (j + 1) * h\n                e_2d[i, j] = np.sin(np.pi * x_i) * np.sin(np.pi * y_j)\n    elif error_type == 'high_frequency':\n        for i in range(n):\n            for j in range(n):\n                e_2d[i, j] = (-1.0)**(i + j)\n    else:\n        raise ValueError(\"Unknown error_type specified.\")\n        \n    return e_2d.flatten()\n\ndef weighted_jacobi(e, A, D, omega, sweeps):\n    \"\"\"Applies a specified number of weighted Jacobi sweeps.\"\"\"\n    e_new = e.copy()\n    for _ in range(sweeps):\n        residual = -(A @ e_new)\n        e_new += omega * residual / D\n    return e_new\n\ndef two_grid_v_cycle(e0, A, D, P, R, A_c, omega, nu1, nu2):\n    \"\"\"Performs a single two-grid V-cycle on the error vector.\"\"\"\n    # 1. Pre-relaxation\n    e_pre = weighted_jacobi(e0, A, D, omega, nu1)\n    \n    # 2. Compute residual\n    r = A @ e_pre\n    \n    # 3. Restrict residual\n    r_c = R @ r\n    \n    # 4. Solve coarse-grid problem\n    d_c = np.linalg.solve(A_c, r_c)\n    \n    # 5. Prolongate correction\n    d_f = P @ d_c\n    \n    # 6. Correct error\n    e_corrected = e_pre - d_f\n    \n    # 7. Post-relaxation\n    e_final = weighted_jacobi(e_corrected, A, D, omega, nu2)\n    \n    return e_final\n\ndef solve():\n    test_cases = [\n        # n, kx, ky, error_type, s, omega, nu1, nu2\n        (32, 1.0, 1.0, 'low_frequency', 10, 2/3, 3, 3),\n        (32, 1.0, 1.0, 'low_frequency', 1, 2/3, 1, 1),\n        (32, 1.0, 0.1, 'low_frequency', 10, 2/3, 3, 3),\n        (32, 1.0, 1.0, 'high_frequency', 10, 2/3, 3, 3),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        n, k_x, k_y, error_type, s, omega, nu1, nu2 = case\n\n        # 1. Setup operators\n        A, D, P, R, A_c = build_discrete_operator(n, k_x, k_y)\n\n        # 2. Create initial error\n        e0 = create_initial_error(n, error_type)\n        e0_norm = np.linalg.norm(e0)\n\n        if e0_norm == 0:\n            all_results.append([0.0, 0.0])\n            continue\n            \n        # 3. Calculate relaxation-only reduction factor\n        e_relax = weighted_jacobi(e0, A, D, omega, s)\n        relax_factor = np.linalg.norm(e_relax) / e0_norm\n\n        # 4. Calculate two-grid reduction factor\n        e_tg = two_grid_v_cycle(e0, A, D, P, R, A_c, omega, nu1, nu2)\n        tg_factor = np.linalg.norm(e_tg) / e0_norm\n        \n        all_results.append([relax_factor, tg_factor])\n\n    # 5. Format and print the final output\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在见证了双网格方法的有效性之后，一个自然的问题是：我们如何从理论上衡量一个粗网格的“好坏”？本练习引入了弱逼近性质（Weak Approximation Property, WAP），这是一个关键的理论工具，用于量化粗空间逼近那些难以被松弛法消除的低能量模态（即平滑误差）的能力。通过计算不同粗空间下的 WAP 常数，你将理解选择正确的粗化策略（特别是包含近零空间向量）对 AMG 收敛性至关重要的原因。",
            "id": "3936637",
            "problem": "考虑一维空间中的稳态热传导，其由微分算子 $-\\dfrac{\\mathrm{d}}{\\mathrm{d}x}\\left(k \\dfrac{\\mathrm{d}}{\\mathrm{d}x}\\right)$ 控制，其中热导率 $k$ 为常数。对于单位长度域上的齐次狄利克雷边界条件，在具有 $n$ 个内部点的均匀网格上进行有限差分法离散化，会得到一个对称正定刚度矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其元素由标准的二阶中心差分近似构造。在代数多重网格 (AMG) 方法中，由延拓算子 $P \\in \\mathbb{R}^{n \\times m}$ 定义的粗糙空间的有效性，可以通过弱逼近性质 (Weak Approximation Property, WAP) 来量化。将弱逼近性质常数 $C_{\\mathrm{WAP}}(P)$ 定义为\n$$\nC_{\\mathrm{WAP}}(P) = \\sup_{x \\in \\mathbb{R}^n \\setminus \\{0\\}} \\min_{y \\in \\mathbb{R}^m} \\frac{\\| x - P y \\|_2^2}{x^\\top A x}.\n$$\n在计算热工学中，$A$ 的近零空间向量（即能量 $x^\\top A x$ 相对于其 $\\ell_2$ 范数很小的向量）通常包含低阶多项式模式。特别地，常数模式和线性模式是在扩散主导区域中缓慢变化的温度场的物理相关原型。本任务的目的是通过为不同选择的粗糙空间计算 $C_{\\mathrm{WAP}}(P)$，来评估缺少一个关键的近零空间向量（特别是线性模式）对双网格收敛代理指标的影响。\n\n你的程序必须：\n1. 构造用于一维热传导问题的离散矩阵 $A$，该问题具有齐次狄利克雷边界条件，定义在单位长度域上，并使用 $n$ 个内部点。令 $h = 1/(n+1)$ 表示网格间距，标准的二阶有限差分法离散化得到的矩阵 $A$ 的对角线元素为 $2/h^2$，非对角线元素为 $-1/h^2$。\n2. 对于每个测试用例，按如下方式定义延拓算子 $P$：\n   - 空粗糙空间：$P$ 有 $m=0$ 列（无粗糙校正）。\n   - 仅含常数向量的粗糙空间：$P$ 有 $m=1$ 列，等于常数向量 $[1,1,\\dots,1]^\\top$。\n   - 常数加线性模式的粗糙空间：$P$ 有 $m=2$ 列，由常数向量和线性模式向量 $v$ 给出，其中 $v_i = i h$，对于 $i=1,2,\\dots,n$。\n   - 单位矩阵粗糙空间：$P$ 是 $n \\times n$ 的单位矩阵（粗糙空间等于精细空间）。\n3. 根据上述定义计算 $C_{\\mathrm{WAP}}(P)$。除了 $A$ 的对称性和正定性外，不要假设任何其他特殊结构。\n4. 将每个结果表示为浮点数，并四舍五入到8位小数。\n\n测试套件：\n- 用例1：$n=64$，$P$ 是仅含常数向量的粗糙空间。\n- 用例2：$n=64$，$P$ 是常数加线性模式的粗糙空间。\n- 用例3：$n=8$，$P$ 是空粗糙空间。\n- 用例4：$n=32$，$P$ 是仅含常数向量的粗糙空间。\n- 用例5：$n=32$，$P$ 是单位矩阵粗糙空间。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果应与上述测试用例的顺序相对应（例如，$[r_1,r_2,r_3,r_4,r_5]$）。由于所有量在构造上都是无量纲的，因此不需要物理单位。",
            "solution": "该问题是有效的，因为它在科学上基于偏微分方程数值方法的理论，在数学上是适定的，并且是使用客观和形式化的语言定义的。我们着手解决它。\n\n目标是为给定的刚度矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和延拓算子 $P \\in \\mathbb{R}^{n \\times m}$ 计算弱逼近性质 (WAP) 常数 $C_{\\mathrm{WAP}}(P)$。该常数是代数多重网格 (AMG) 理论中的一个关键指标，用于量化由 $P$ 的列向量所代表的粗糙空间在逼近精细网格向量方面的有效性。其定义由下式给出：\n$$\nC_{\\mathrm{WAP}}(P) = \\sup_{x \\in \\mathbb{R}^n \\setminus \\{0\\}} \\min_{y \\in \\mathbb{R}^m} \\frac{\\| x - P y \\|_2^2}{x^\\top A x}\n$$\n\n首先，我们简化分子。项 $\\min_{y \\in \\mathbb{R}^m} \\| x - P y \\|_2^2$ 表示从向量 $x$ 到 $P$ 的列空间（记作 $\\mathcal{R}(P)$）的平方欧几里得距离。当 $P y$ 是 $x$ 在 $\\mathcal{R}(P)$ 上的正交投影时，达到这个最小值。向量差 $x - Py$ 则是 $x$ 在 $\\mathcal{R}(P)$ 的正交补空间上的投影。令 $Q_{\\perp}$ 为到这个补空间的正交投影算子。最小值为 $\\|Q_{\\perp} x\\|_2^2$。由于 $Q_{\\perp}$ 是一个投影矩阵，所以它是对称的（$Q_{\\perp}^\\top = Q_{\\perp}$）和幂等的（$Q_{\\perp}^2 = Q_{\\perp}$）。因此，我们可以将分子写为 $x^\\top Q_{\\perp}^\\top Q_{\\perp} x = x^\\top Q_{\\perp} x$。\n\nWAP 常数的表达式变为：\n$$\nC_{\\mathrm{WAP}}(P) = \\sup_{x \\in \\mathbb{R}^n \\setminus \\{0\\}} \\frac{x^\\top Q_{\\perp} x}{x^\\top A x}\n$$\n这就是广义特征值问题 $Q_{\\perp} x = \\lambda A x$ 的最大特征值的定义。矩阵 $A$ 源于负拉普拉斯算子的离散化，是对称正定 (SPD) 的。矩阵 $Q_{\\perp}$ 是一个投影矩阵，因此它是对称半正定 (SPSD) 的。对于一个矩阵束 $(B, M)$，其中 $B$ 是 SPSD 且 $M$ 是 SPD，其广义特征值 $\\lambda$ 是实数且非负的。因此，$C_{\\mathrm{WAP}}(P)$ 是良定义的，并对应于此问题的最大特征值。\n\n为每个测试用例计算 $C_{\\mathrm{WAP}}(P)$ 的总体算法如下：\n\n1.  **构造刚度矩阵 $A$**：对于给定的内部点数 $n$，网格间距为 $h = 1/(n+1)$。问题指明，算子 $-\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}$ 的离散化（即，假设热导率 $k=1$）得到一个 $n \\times n$ 的矩阵 $A$，其对角线元素为 $A_{ii} = 2/h^2$，次对角线/超对角线元素为 $A_{i, i\\pm 1} = -1/h^2$。这是一个对称三对角矩阵。\n\n2.  **构造延拓算子 $P$**：矩阵 $P \\in \\mathbb{R}^{n \\times m}$ 根据每个用例的定义进行构造：\n    -   **空粗糙空间**：$m=0$。$P$ 是一个 $n \\times 0$ 矩阵。\n    -   **仅含常数向量的粗糙空间**：$m=1$。$P$ 是一个 $n \\times 1$ 矩阵，其单列是向量 $[1, 1, \\dots, 1]^\\top$。\n    -   **常数加线性模式的粗糙空间**：$m=2$。$P$ 是一个 $n \\times 2$ 矩阵，其列是常数向量和线性模式向量 $v$，其分量为 $v_i = i h$，对于 $i=1, \\dots, n$。\n    -   **单位矩阵粗糙空间**：$m=n$。$P$ 是 $n \\times n$ 的单位矩阵 $I$。\n\n3.  **构造投影算子 $Q_{\\perp}$**：\n    -   如果 $P$ 是单位矩阵 ($P=I$)，则任何向量 $x \\in \\mathbb{R}^n$ 都在 $\\mathcal{R}(P)$ 中。当 $y=x$ 时，分子 $\\min_y \\|x-Iy\\|_2^2$ 为零。因此，$C_{\\mathrm{WAP}}(I) = 0$。\n    -   如果 $P$ 是空的 ($m=0$)，其列空间只包含零向量。正交补空间是整个 $\\mathbb{R}^n$，所以 $Q_{\\perp} = I$。\n    -   对于 $m>0$ 的其他情况，$Q_{\\perp} = I - Q$，其中 $Q$ 是到 $\\mathcal{R}(P)$ 上的投影算子。一种数值稳定的计算 $Q$ 的方法是通过 QR 分解。如果 $P = QR$，其中 $Q \\in \\mathbb{R}^{n \\times m}$ 具有张成 $\\mathcal{R}(P)$ 的标准正交列，那么投影算子是 $QQ^\\top$。因此，$Q_{\\perp} = I - QQ^\\top$。\n\n4.  **求解广义特征值问题**：使用数值线性代数库，我们求解 $Q_{\\perp} x = \\lambda A x$ 的特征值。找到的最大特征值即为 $C_{\\mathrm{WAP}}(P)$ 的值。\n\n将此过程应用于问题陈述中指定的每个测试用例。结果表明，在粗糙空间中包含相关的近零空间向量（例如拉普拉斯算子的线性模式）对于获得较小的 $C_{\\mathrm{WAP}}(P)$ 值至关重要，而该值是 AMG 方法中良好双网格收敛性的一个代理指标。较小的 $C_{\\mathrm{WAP}}(P)$ 值表示更有效的粗糙网格校正。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# numpy version: 1.23.5\nfrom scipy import linalg\n# scipy version: 1.11.4\n\ndef compute_C_WAP(n: int, p_type: str) -> float:\n    \"\"\"\n    Computes the Weak Approximation Property constant C_WAP(P).\n\n    Args:\n        n: The number of interior grid points (size of the matrix A).\n        p_type: A string specifying the type of prolongation operator P.\n                One of 'empty', 'constant', 'const_linear', 'identity'.\n\n    Returns:\n        The computed C_WAP(P) value as a float.\n    \"\"\"\n    # Handle the trivial case where the coarse space is the same as the fine space.\n    # The approximation error is always zero.\n    if p_type == 'identity':\n        return 0.0\n\n    # 1. Construct the stiffness matrix A\n    h = 1.0 / (n + 1)\n    diag_val = 2.0 / h**2\n    offdiag_val = -1.0 / h**2\n    \n    A = np.diag(np.full(n, diag_val)) + \\\n        np.diag(np.full(n - 1, offdiag_val), k=1) + \\\n        np.diag(np.full(n - 1, offdiag_val), k=-1)\n\n    # 2. Construct the projector Q_perp\n    if p_type == 'empty':\n        # For an empty coarse space, the complement is the entire space.\n        Q_perp = np.eye(n)\n    else:\n        # Construct the prolongation operator P based on the type\n        if p_type == 'constant':\n            P = np.ones((n, 1))\n        elif p_type == 'const_linear':\n            const_vec = np.ones((n, 1))\n            linear_vec = h * np.arange(1, n + 1).reshape(-1, 1)\n            P = np.hstack((const_vec, linear_vec))\n        else:\n            raise ValueError(f\"Unknown p_type: {p_type}\")\n        \n        # Use QR decomposition for a numerically stable computation of the projector.\n        # Let P = QR. The projector onto the column space of P is QQ^T.\n        q, _ = np.linalg.qr(P)\n        Q_proj = q @ q.T\n        Q_perp = np.eye(n) - Q_proj\n        \n        # Ensure Q_perp is numerically symmetric for the eigensolver\n        Q_perp = (Q_perp + Q_perp.T) / 2.0\n\n    # 3. Solve the generalized eigenvalue problem Q_perp * x = lambda * A * x\n    # We need the largest eigenvalue. scipy.linalg.eigh is suitable for\n    # symmetric/Hermitian generalized eigenvalue problems.\n    # It returns eigenvalues in ascending order.\n    eigenvalues = linalg.eigh(Q_perp, A, eigvals_only=True)\n    c_wap = np.max(eigenvalues)\n\n    return c_wap\n\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (n, p_type_string)\n    test_cases = [\n        (64, 'constant'),        # Case 1\n        (64, 'const_linear'),    # Case 2\n        (8, 'empty'),            # Case 3\n        (32, 'constant'),        # Case 4\n        (32, 'identity'),        # Case 5\n    ]\n\n    results = []\n    for n, p_type in test_cases:\n        result = compute_C_WAP(n, p_type)\n        # Format the result to 8 decimal places as a string.\n        results.append(f\"{result:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}