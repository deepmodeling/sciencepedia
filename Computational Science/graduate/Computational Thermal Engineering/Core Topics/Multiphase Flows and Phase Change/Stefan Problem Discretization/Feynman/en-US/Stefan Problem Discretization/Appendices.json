{
    "hands_on_practices": [
        {
            "introduction": "To effectively discretize Stefan problems, one must first grasp the inherent numerical stiffness that arises from the coupling of heat diffusion and interface motion. This exercise simplifies the full partial differential equation to a governing ordinary differential equation for the interface position, providing a clear and focused setting to explore stability. By implementing and comparing explicit and implicit time-stepping schemes, you will gain firsthand insight into conditional stability and understand why implicit methods are often essential for robustly solving moving boundary problems .",
            "id": "3987441",
            "problem": "Consider the one-dimensional, one-phase Stefan problem for a melting front in a slab occupying the interval $0 \\le x \\le s(t)$, where $s(t)$ denotes the position (in meters) of the solid–liquid interface at time $t$ (in seconds). The solid is initially at uniform temperature, and its boundary at $x=0$ is suddenly held at a hot temperature $T_0$ (in kelvin) greater than the melting temperature $T_m$ (in kelvin). Assume quasi-steady heat conduction in the solid and negligible heat conduction in the liquid, so that the temperature field in the solid satisfies a linear profile governed by Fourier's law of heat conduction and energy conservation at the moving interface (the Stefan condition).\n\nFundamental laws and definitions:\n- Fourier's law relates heat flux to temperature gradient by $q = -k \\,\\partial T/\\partial x$, where $k$ is thermal conductivity (in watts per meter kelvin).\n- Conservation of energy at the moving interface (the Stefan condition) states that the rate of latent heat release or absorption equals the heat flux entering the interface, $\\rho L \\, \\dfrac{ds}{dt} = -k \\,\\left.\\dfrac{\\partial T}{\\partial x}\\right|_{x=s(t)^-}$, where $\\rho$ is density (in kilograms per cubic meter) and $L$ is latent heat of fusion (in joules per kilogram).\n\nUnder the quasi-steady assumption with boundary conditions $T(0,t) = T_0$ and $T(s(t),t) = T_m$, the temperature field is $T(x,t) = T_0 + \\dfrac{T_m - T_0}{s(t)}\\,x$. Inserting this into the Stefan condition yields an ordinary differential equation (ODE) for the interface:\n$$\n\\frac{ds}{dt} = \\frac{C}{s(t)}, \\quad C := \\frac{k\\,(T_0 - T_m)}{\\rho\\,L}.\n$$\nFor melting, $T_0 > T_m$ so $C > 0$; for solidification (cooling), $C < 0$ if $T_0 < T_m$.\n\nYour task is to design, analyze, and implement two time-discretization schemes for advancing the interface position:\n- An explicit update\n$$\ns^{n+1} = s^n + \\Delta t \\, V_n, \\quad V_n := \\frac{C}{s^n},\n$$\n- An implicit update\n$$\ns^{n+1} = s^n + \\Delta t \\, V_n^{n+1}, \\quad V_n^{n+1} := \\frac{C}{s^{n+1}},\n$$\nwhere $s^n$ approximates $s(t^n)$ at discrete time $t^n = n\\,\\Delta t$ and $\\Delta t$ is the time step (in seconds).\n\nStarting from the above fundamental laws and definitions, you must:\n1. Derive the ODE for $s(t)$ and its exact solution,\n$$\ns(t) = \\sqrt{s(0)^2 + 2\\,C\\,t}.\n$$\n2. Derive and compare the stability properties of the explicit and implicit updates by analyzing the explicit update mapping $g(s) := s + \\Delta t\\,C/s$ and the implicit update’s quadratic relation for $s^{n+1}$. Use a principle-based argument tied to monotonicity and the discrete energy $E(s) := s^2$ to justify your conclusions.\n3. Derive a time-step restriction for the explicit scheme that ensures monotonicity and controls discrete energy growth. Express the derived maximum allowable time step $\\Delta t_{\\max}$ in seconds.\n\nImplementation requirements:\n- Implement both updates to advance $s(t)$ from the initial value $s(0)=s_0$ to a final time $t_{\\mathrm{end}}$.\n- Use a variable number of time steps $N = \\lceil t_{\\mathrm{end}}/\\Delta t \\rceil$ and a last partial step if needed so that the total advancement equals $t_{\\mathrm{end}}$.\n- For each test case, compute:\n  - The explicit scheme’s final interface position $s_{\\mathrm{exp}}(t_{\\mathrm{end}})$ (in meters).\n  - The implicit scheme’s final interface position $s_{\\mathrm{imp}}(t_{\\mathrm{end}})$ (in meters).\n  - The exact solution $s_{\\mathrm{exact}}(t_{\\mathrm{end}})$ (in meters).\n  - The derived explicit stability boolean $\\mathrm{stable}_{\\mathrm{exp}}$ defined by the inequality $\\Delta t < \\Delta t_{\\max}$ with $\\Delta t_{\\max} := \\dfrac{s_0^2}{C}$ for $C>0$ and $\\Delta t_{\\max} := \\dfrac{s_0^2}{|C|}$ for $C<0$, expressed in seconds.\n  - The relative errors for the explicit and implicit schemes, respectively,\n  $$\n  e_{\\mathrm{exp}} := \\frac{\\left|s_{\\mathrm{exp}}(t_{\\mathrm{end}}) - s_{\\mathrm{exact}}(t_{\\mathrm{end}})\\right|}{s_{\\mathrm{exact}}(t_{\\mathrm{end}})}, \\quad\n  e_{\\mathrm{imp}} := \\frac{\\left|s_{\\mathrm{imp}}(t_{\\mathrm{end}}) - s_{\\mathrm{exact}}(t_{\\mathrm{end}})\\right|}{s_{\\mathrm{exact}}(t_{\\mathrm{end}})},\n  $$\n  which are dimensionless decimals.\n\nTest suite:\nUse the following physically plausible parameters, consistent with a metal such as aluminum:\n- Thermal conductivity $k = 200$ $\\mathrm{W/(m\\cdot K)}$,\n- Density $\\rho = 2700$ $\\mathrm{kg/m^3}$,\n- Latent heat $L = 397000$ $\\mathrm{J/kg}$,\n- Melting temperature $T_m = 933$ $\\mathrm{K}$,\n- Hot boundary temperature $T_0 = 1033$ $\\mathrm{K}$,\n- Interface initial position $s_0 = 1\\times 10^{-3}$ $\\mathrm{m}$,\n- Final time $t_{\\mathrm{end}} = 10$ $\\mathrm{s}$.\n\nWith these shared parameters, evaluate three distinct time-step scenarios:\n- Case A (happy path): $\\Delta t = 0.01$ $\\mathrm{s}$.\n- Case B (boundary): $\\Delta t = \\Delta t_{\\max}$ (computed from the derived restriction, in seconds).\n- Case C (edge): $\\Delta t = 0.5$ $\\mathrm{s}$.\n\nYour program should produce a single line of output containing the aggregated results for the three test cases as a comma-separated list enclosed in square brackets. For each case, output in the order\n$$\n\\left[\\Delta t_{\\max}\\;\\mathrm{(in\\;s)},\\;\\mathrm{stable}_{\\mathrm{exp}}\\;\\mathrm{(boolean)},\\;e_{\\mathrm{exp}}\\;\\mathrm{(decimal)},\\;e_{\\mathrm{imp}}\\;\\mathrm{(decimal)}\\right],\n$$\nconcatenated for all three cases on one line. For example, the final output format must be\n$$\n\\left[\\Delta t_{\\max}^{(A)},\\mathrm{stable}_{\\mathrm{exp}}^{(A)},e_{\\mathrm{exp}}^{(A)},e_{\\mathrm{imp}}^{(A)},\\Delta t_{\\max}^{(B)},\\mathrm{stable}_{\\mathrm{exp}}^{(B)},e_{\\mathrm{exp}}^{(B)},e_{\\mathrm{imp}}^{(B)},\\Delta t_{\\max}^{(C)},\\mathrm{stable}_{\\mathrm{exp}}^{(C)},e_{\\mathrm{exp}}^{(C)},e_{\\mathrm{imp}}^{(C)}\\right],\n$$\nwhere every numeric entry is a plain decimal and every boolean entry is in the programming language’s native boolean format. All $\\Delta t_{\\max}$ entries must be expressed in seconds.",
            "solution": "The problem is well-posed, scientifically grounded in the principles of heat transfer, and provides a complete and consistent set of data and definitions for a computational task. It is a standard problem in the numerical analysis of moving boundary problems. Therefore, the problem is valid.\n\nThe solution proceeds in three parts as requested: (1) derivation of the governing ordinary differential equation (ODE) and its exact solution, (2) derivation and comparison of the stability properties of the explicit and implicit numerical schemes, and (3) implementation of the schemes to compute the requested outputs.\n\n### 1. Derivation of the Exact Solution\n\nThe problem states that under a quasi-steady assumption, the temperature profile in the solid phase $0 \\le x \\le s(t)$ is linear. Given the boundary conditions $T(x=0, t) = T_0$ and $T(x=s(t), t) = T_m$, the temperature field $T(x,t)$ is given by linear interpolation:\n$$\nT(x,t) = T_0 + \\frac{T_m - T_0}{s(t)} x\n$$\nThe heat flux $q$ is related to the temperature gradient by Fourier's law: $q = -k \\frac{\\partial T}{\\partial x}$. The gradient is uniform in space:\n$$\n\\frac{\\partial T}{\\partial x} = \\frac{T_m - T_0}{s(t)}\n$$\nThe Stefan condition at the interface $x=s(t)$ represents conservation of energy. The rate of energy consumed by phase change per unit area must equal the heat flux entering the interface from the solid side.\n$$\n\\rho L \\frac{ds}{dt} = -k \\left. \\frac{\\partial T}{\\partial x} \\right|_{x=s(t)^-}\n$$\nwhere $\\rho$ is the density, $L$ is the latent heat of fusion, and $k$ is the thermal conductivity. The notation $x=s(t)^-$ indicates the limit approaching the interface from the solid side ($x < s(t)$).\n\nSubstituting the expression for the temperature gradient into the Stefan condition yields:\n$$\n\\rho L \\frac{ds}{dt} = -k \\left( \\frac{T_m - T_0}{s(t)} \\right) = \\frac{k (T_0 - T_m)}{s(t)}\n$$\nThis can be rearranged into an ordinary differential equation for the interface position $s(t)$:\n$$\n\\frac{ds}{dt} = \\frac{k(T_0 - T_m)}{\\rho L} \\frac{1}{s(t)}\n$$\nDefining the constant $C := \\frac{k(T_0 - T_m)}{\\rho L}$, the ODE is:\n$$\n\\frac{ds}{dt} = \\frac{C}{s(t)}\n$$\nThis is a separable first-order ODE. We can solve it by separating variables and integrating from the initial state $(s(0), 0)$ to a state $(s(t), t)$:\n$$\ns(t) \\frac{ds}{dt} = C \\implies \\int_{s(0)}^{s(t)} s' ds' = \\int_0^t C dt'\n$$\nPerforming the integration gives:\n$$\n\\left[ \\frac{1}{2} (s')^2 \\right]_{s(0)}^{s(t)} = [C t']_0^t\n$$\n$$\n\\frac{1}{2}s(t)^2 - \\frac{1}{2}s(0)^2 = C t\n$$\nRearranging for $s(t)^2$ and solving for $s(t)$ (taking the positive root since position must be positive):\n$$\ns(t)^2 = s(0)^2 + 2Ct\n$$\n$$\ns(t) = \\sqrt{s(0)^2 + 2Ct}\n$$\nThis is the exact solution for the interface position, given the initial position $s(0)$.\n\n### 2. Stability Analysis of Discretization Schemes\n\nWe analyze the explicit and implicit schemes for advancing the solution from time $t^n$ to $t^{n+1} = t^n + \\Delta t$.\n\n**Explicit Scheme:**\nThe explicit update is given by $s^{n+1} = s^n + \\Delta t \\frac{C}{s^n}$. This can be written as an iterative map $s^{n+1} = g(s^n)$ where $g(s) = s + \\frac{\\Delta t C}{s}$.\n\nFor a melting problem, $T_0 > T_m$, so $C > 0$. We expect $s(t)$ to be a monotonically increasing function of time. A physically consistent numerical scheme should reflect this. Let's analyze the monotonicity of the update map $g(s)$. The derivative is:\n$$\ng'(s) = \\frac{d}{ds} \\left( s + \\frac{\\Delta t C}{s} \\right) = 1 - \\frac{\\Delta t C}{s^2}\n$$\nFor $g(s)$ to be a monotonically increasing function, we require $g'(s) \\ge 0$. This condition prevents unphysical oscillations, where a larger current position $s^n$ would lead to a smaller next position $s^{n+1}$.\n$$\n1 - \\frac{\\Delta t C}{s^2} \\ge 0 \\implies 1 \\ge \\frac{\\Delta t C}{s^2} \\implies \\Delta t \\le \\frac{s^2}{C}\n$$\nSince $s(t)$ increases with time for $C>0$, the term $s^2/C$ also increases. The most restrictive constraint on $\\Delta t$ occurs at the smallest value of $s$, which is the initial position $s_0 = s(0)$. Therefore, to ensure monotonicity for all steps, we must impose the condition:\n$$\n\\Delta t \\le \\frac{s_0^2}{C}\n$$\nThis defines the maximum allowable time step, $\\Delta t_{\\max} := \\frac{s_0^2}{C}$. If $\\Delta t > \\Delta t_{\\max}$, the scheme can become oscillatory and is considered unstable in this sense.\n\nFrom an energy perspective, we examine the evolution of the discrete energy $E(s) := s^2$. For the explicit scheme:\n$$\nE(s^{n+1}) = (s^{n+1})^2 = \\left(s^n + \\frac{\\Delta t C}{s^n}\\right)^2 = (s^n)^2 + 2C\\Delta t + \\frac{(\\Delta t C)^2}{(s^n)^2}\n$$\nThe exact solution evolves as $s(t_{n+1})^2 = s(t_n)^2 + 2C\\Delta t$. The explicit scheme introduces an additional non-negative term $\\frac{(\\Delta t C)^2}{(s^n)^2}$, which is a form of numerical dissipation. This term causes a systematic over-estimation of the energy $s^2$, and consequently an over-estimation of the interface position $s(t)$.\n\n**Implicit Scheme:**\nThe implicit update is given by $s^{n+1} = s^n + \\Delta t \\frac{C}{s^{n+1}}$. This can be rearranged into a quadratic equation for $s^{n+1}$:\n$$\n(s^{n+1})^2 - s^n s^{n+1} - \\Delta t C = 0\n$$\nThe solution is given by the quadratic formula:\n$$\ns^{n+1} = \\frac{s^n \\pm \\sqrt{(s^n)^2 + 4\\Delta t C}}{2}\n$$\nSince $s^{n+1}$ must be positive, we must choose the `+` sign. For the melting case ($C>0$), the term under the square root, $(s^n)^2 + 4\\Delta t C$, is always positive. Thus, a unique, real, positive solution for $s^{n+1}$ is guaranteed for any $\\Delta t > 0$. This means the implicit scheme is unconditionally stable for melting problems; there is no upper limit on the time step $\\Delta t$ for stability.\n\nAnalyzing the discrete energy for the implicit scheme:\nA Taylor series expansion for small $\\Delta t$ shows that $(s^{n+1})^2 \\approx (s^n)^2 + 2C\\Delta t - \\frac{(\\Delta t C)^2}{(s^n)^2}$. The numerical error term is negative, leading to a systematic under-estimation of the energy $s^2$ and the interface position $s(t)$.\n\n**Comparison Summary:**\n- The **explicit scheme** is simple to implement but is only conditionally stable. It requires $\\Delta t \\le s_0^2/C$ to maintain monotonicity. It tends to overestimate the interface position.\n- The **implicit scheme** requires solving a quadratic equation at each step but is unconditionally stable for melting ($C>0$). It tends to underestimate the interface position. Its superior stability makes it more robust, especially for large time steps.\n\n### 3. Time-Step Restriction\n\nAs derived in the stability analysis, the requirement for the explicit update map $g(s)$ to be monotonic, $g'(s) \\ge 0$, leads to the condition $\\Delta t \\le s^2/C$. To ensure this condition holds for the entire simulation, it must hold at the most restrictive point, which is at $t=0$ where $s=s_0$. This yields the maximum allowable time step:\n$$\n\\Delta t_{\\max} = \\frac{s_0^2}{C} = \\frac{s_0^2 \\rho L}{k(T_0 - T_m)}\n$$\nThe problem defines stability by the strict inequality $\\Delta t < \\Delta t_{\\max}$.\n\nFor the case of solidification where $T_0 < T_m$ and $C < 0$, the stability condition for the explicit scheme would arise from the need to keep $s^{n+1}$ positive, leading to $\\Delta t < (s^n)^2/|C|$. Since $s$ decreases, this condition becomes more restrictive over time. The implicit scheme, in this case, has a condition for the existence of real roots, $\\Delta t \\le (s^n)^2/(4|C|)$, which is more stringent. However, the present problem is a melting problem, so we focus on the $C>0$ case.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D Stefan problem using explicit and implicit schemes and compares\n    them to the exact solution.\n    \"\"\"\n    # Physically plausible parameters for a metal like aluminum\n    k = 200.0  # Thermal conductivity, W/(m.K)\n    rho = 2700.0  # Density, kg/m^3\n    L = 397000.0  # Latent heat of fusion, J/kg\n    Tm = 933.0  # Melting temperature, K\n    T0 = 1033.0  # Hot boundary temperature, K\n    s0 = 1.0e-3  # Interface initial position, m\n    t_end = 10.0  # Final time, s\n\n    # Calculate the Stefan problem constant C\n    C = k * (T0 - Tm) / (rho * L)\n\n    # Calculate the maximum stable time step for the explicit scheme\n    # The problem defines dt_max for both C>0 and C<0. We use C because T0 > Tm.\n    dt_max = s0**2 / C\n\n    # Define the time steps for the three test cases\n    test_cases_dt = [\n        0.01,         # Case A: Happy path\n        dt_max,       # Case B: Boundary case\n        0.5           # Case C: Unstable/edge case\n    ]\n\n    results = []\n    \n    for dt in test_cases_dt:\n        # --- Explicit Scheme Simulation ---\n        s_exp = s0\n        current_t = 0.0\n        while current_t < t_end:\n            step_dt = min(dt, t_end - current_t)\n            if s_exp <= 0: # Check for non-physical state\n                s_exp = -1.0 # Sentinel for failure\n                break\n            s_exp += step_dt * C / s_exp\n            current_t += step_dt\n        s_exp_final = s_exp\n\n        # --- Implicit Scheme Simulation ---\n        s_imp = s0\n        current_t = 0.0\n        while current_t < t_end:\n            step_dt = min(dt, t_end - current_t)\n            # Solve the quadratic equation for s_imp at n+1:\n            # (s_n+1)^2 - s_n * s_n+1 - dt * C = 0\n            # We take the positive root.\n            discriminant = s_imp**2 + 4 * step_dt * C\n            if discriminant < 0:\n                s_imp = -1.0 # Sentinel for failure\n                break\n            s_imp = (s_imp + np.sqrt(discriminant)) / 2.0\n            current_t += step_dt\n        s_imp_final = s_imp\n\n        # --- Exact Solution ---\n        s_exact_final = np.sqrt(s0**2 + 2 * C * t_end)\n\n        # --- Stability and Error Calculation ---\n        # Stability is defined by the strict inequality dt < dt_max\n        stable_exp = dt < dt_max\n\n        # Relative errors\n        # Handle cases where simulations might have failed\n        if s_exp_final > 0:\n            e_exp = np.abs(s_exp_final - s_exact_final) / s_exact_final\n        else: # If simulation failed, error is considered infinite or large. Use a placeholder.\n            e_exp = np.inf\n\n        if s_imp_final > 0:\n            e_imp = np.abs(s_imp_final - s_exact_final) / s_exact_final\n        else:\n            e_imp = np.inf\n\n        results.extend([dt_max, stable_exp, e_exp, e_imp])\n\n    # Format the final output string as specified\n    # The map(str,...) will convert booleans to 'True'/'False'\n    # and floats to their string representation.\n    formatted_results = [f\"{x}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While front-tracking methods can be precise, many practical applications favor fixed-grid approaches for their robustness and ease of implementation. The enthalpy method is a powerful fixed-grid technique that recasts the Stefan problem in a conservative form, automatically handling the phase change without explicitly tracking the interface. This practice guides you through implementing a finite volume-based enthalpy solver, focusing on the method's key strength: ensuring discrete energy conservation, a critical property for the physical fidelity of any thermal simulation .",
            "id": "3987456",
            "problem": "Consider a one-dimensional slab of length $L_x$ with uniform cross-sectional area $A$, material density $\\rho$, specific heat capacity $c_p$, thermal conductivity $k$, and latent heat of fusion $L_h$. The temperature-dependent phase fraction $\\phi(T)$ is defined by a linear mushy-zone model, where the solidus temperature is $T_s$ and the liquidus temperature is $T_l$. The phase fraction satisfies $\\phi(T)=0$ for $T \\le T_s$, $\\phi(T)=1$ for $T \\ge T_l$, and varies linearly as $\\phi(T)=(T-T_s)/(T_l-T_s)$ for $T_s < T < T_l$. The volumetric enthalpy is defined as\n$$ H(T) = \\rho c_p T + \\rho L_h \\phi(T) $$\nThe heat flux is defined by Fourier’s law as\n$$ q = -k \\frac{\\partial T}{\\partial x} $$\n\nStarting from the conservation of energy, the enthalpy method models the evolution as\n$$ \\frac{\\partial H}{\\partial t} + \\frac{\\partial q}{\\partial x} = 0 $$\nDiscretize the slab using the Finite Volume Method (FVM) on $N$ uniform control volumes of width $\\Delta x = L_x/N$. Let $H_i^n$ denote the enthalpy in control volume $i$ at time level $n$, and define face-centered fluxes $q_{j}^n$ at faces $j=0,1,\\dots,N$ with $q_0^n$ prescribed at the left boundary (positive into the domain) and $q_N^n$ prescribed at the right boundary. The update of enthalpy in each control volume must be obtained from summing face fluxes consistent with local conservation over each control volume and time step $\\Delta t$. The temperature required to compute fluxes must be recovered from enthalpy by inverting the constitutive relation $H(T)$ piecewise across solid, mushy, and liquid regimes.\n\nYour task is to implement a program that:\n- Initializes the slab with a uniform temperature $T_0$ and computes the corresponding initial enthalpy $H_i^0$ for all $i$.\n- Advances the enthalpy field $H_i^n$ for a specified number of time steps using the described enthalpy method and FVM flux summation with an explicit temporal update that uses temperatures $T_i^n$ recovered from $H_i^n$ and central differences for interior face gradients.\n- At each time step $n \\to n+1$, computes the total latent heat consumed or released as $\\sum_i \\rho L_h \\left(\\phi_i^{n+1} - \\phi_i^n\\right) V_i$, where $V_i = A \\Delta x$, and records the sign convention that positive values represent latent heat consumption (melting) while negative values represent latent heat release (solidification).\n- Demonstrates discrete energy conservation by computing the global energy residual $R^n$ defined as the net external energy input during the time step minus the change in total enthalpy in the domain, i.e.,\n$$ R^n = \\left(q_0^n - q_N^n\\right) A \\Delta t - \\sum_i \\left(H_i^{n+1} - H_i^n\\right) V_i $$\nReport the maximum absolute residual over all simulated time steps.\n\nAll energies must be expressed in Joules ($J$). Temperatures must be expressed in degrees Celsius ($^\\circ\\text{C}$). There are no percentages in the output.\n\nUse the following test suite of parameter sets to exercise the implementation across melting, solidification, and no-phase-change regimes. In all cases use $A=1$, $L_x=0.1$, $N=64$, $\\Delta t = 1.0$, $k=0.6$, $\\rho=1000$, $c_p=4200$, $L_h=334000$, $T_s=-1$, $T_l=1$, and simulate $N_t=30$ time steps. Prescribe the right boundary flux $q_N^n=0$ for all cases.\n\n- Case $1$ (melting): $T_0=-2$, left boundary flux $q_0^n=50000$ for all $n$.\n- Case $2$ (solidification): $T_0=2$, left boundary flux $q_0^n=-50000$ for all $n$.\n- Case $3$ (no phase change): $T_0=-10$, left boundary flux $q_0^n=1000$ for all $n$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, output two floats in $J$: first, the maximum absolute energy residual over all time steps, and second, the total latent heat consumed (positive) or released (negative) summed over all time steps. The final output must therefore be of the form $\\left[ r_1, \\ell_1, r_2, \\ell_2, r_3, \\ell_3 \\right]$, where $r_i$ and $\\ell_i$ are the residual and latent totals for case $i$ in $J$.",
            "solution": "The user-provided problem statement has been meticulously validated and is determined to be sound, well-posed, and scientifically grounded. It outlines a classical one-dimensional transient heat conduction problem with phase change, commonly known as a Stefan problem, to be solved using the enthalpy method with a Finite Volume Method (FVM) discretization. All parameters, governing equations, and boundary conditions are provided, enabling a direct and unambiguous implementation.\n\nThe solution is developed by adhering to the principles of conservation of energy and the specified numerical scheme. The primary steps involve discretizing the governing equation, defining the numerical update algorithm, and detailing the physical constitutive relations.\n\n**1. Governing Equation and Constitutive Relations**\n\nThe fundamental principle is the conservation of energy, which for a one-dimensional system is stated as:\n$$\n\\frac{\\partial H}{\\partial t} + \\frac{\\partial q}{\\partial x} = 0\n$$\nwhere $H$ is the volumetric enthalpy in $\\mathrm{J}/\\mathrm{m}^3$, $q$ is the heat flux in $\\mathrm{W}/\\mathrm{m}^2$, $t$ is time, and $x$ is the spatial coordinate.\n\nThe problem specifies the constitutive relations that connect the primary variables of enthalpy $H$ and temperature $T$:\nThe volumetric enthalpy $H(T)$ is a function of temperature, incorporating both sensible heat and latent heat:\n$$\nH(T) = \\rho c_p T + \\rho L_h \\phi(T)\n$$\nHere, $\\rho$ is density, $c_p$ is specific heat capacity, and $L_h$ is the latent heat of fusion. The phase fraction $\\phi(T)$ depends on the solidus temperature $T_s$ and liquidus temperature $T_l$:\n$$\n\\phi(T) =\n\\begin{cases}\n    0 & \\text{if } T \\le T_s \\quad (\\text{Solid}) \\\\\n    \\frac{T-T_s}{T_l-T_s} & \\text{if } T_s < T < T_l \\quad (\\text{Mushy}) \\\\\n    1 & \\text{if } T \\ge T_l \\quad (\\text{Liquid})\n\\end{cases}\n$$\nThe heat flux $q$ is given by Fourier's law of conduction:\n$$\nq = -k \\frac{\\partial T}{\\partial x}\n$$\nwhere $k$ is the thermal conductivity.\n\n**2. Finite Volume Discretization and Explicit Update**\n\nThe domain of length $L_x$ is discretized into $N$ uniform control volumes (CVs), each of width $\\Delta x = L_x/N$ and volume $V_i = A \\Delta x$, where $A$ is the cross-sectional area. We index the CVs from $i=0, \\dots, N-1$. The faces of the CVs are indexed $j=0, \\dots, N$, where face $j=0$ is the left boundary, face $j=N$ is the right boundary, and an interior face $j=i+1$ separates CV $i$ and CV $i+1$.\n\nIntegrating the governing equation over control volume $i$ (from $x_i$ to $x_{i+1}$) and over a time step $\\Delta t$ (from $t^n$ to $t^{n+1}$) yields the integral conservation law:\n$$\n\\int_{x_i}^{x_{i+1}} \\left( H(t^{n+1}) - H(t^n) \\right) dx + \\int_{t^n}^{t^{n+1}} \\left( q(x_{i+1}) - q(x_i) \\right) dt = 0\n$$\nApproximating the spatial and temporal integrals with values at the cell center and the beginning of the time step (an explicit formulation), we obtain the discrete equation for the average enthalpy $H_i$ in CV $i$:\n$$\n(H_i^{n+1} - H_i^n)\\Delta x + (q_{i+1}^n - q_i^n)\\Delta t = 0\n$$\nwhere $q_i^n$ and $q_{i+1}^n$ represent the fluxes at the left and right faces of CV $i$ at time level $n$, respectively. Rearranging for the updated enthalpy $H_i^{n+1}$:\n$$\nH_i^{n+1} = H_i^n - \\frac{\\Delta t}{\\Delta x} (q_{i+1}^n - q_i^n)\n$$\nThe problem defines boundary fluxes $q_0^n$ (left) and $q_N^n$ (right). Interior face fluxes are computed using a central difference approximation for the temperature gradient between adjacent cell centers:\n$$\nq_{i+1}^n \\approx -k \\frac{T_{i+1}^n - T_i^n}{\\Delta x} \\quad \\text{for } i = 0, \\dots, N-2\n$$\n\n**3. Enthalpy-Temperature Inversion**\n\nAt each time step, the temperature field $T^n$ must be recovered from the enthalpy field $H^n$ to compute the fluxes. This requires inverting the $H(T)$ relationship. Let $H_s = \\rho c_p T_s$ and $H_l = \\rho c_p T_l + \\rho L_h$ be the enthalpies at the solidus and liquidus points. The inversion is piecewise:\n- If $H \\le H_s$ (solid): $\\phi=0$, so $H = \\rho c_p T \\implies T = H / (\\rho c_p)$.\n- If $H \\ge H_l$ (liquid): $\\phi=1$, so $H = \\rho c_p T + \\rho L_h \\implies T = (H - \\rho L_h) / (\\rho c_p)$.\n- If $H_s < H < H_l$ (mushy): The phase fraction $\\phi$ is linearly related to enthalpy, $\\phi = (H - H_s) / (H_l - H_s)$. The temperature is then recovered by inverting the phase fraction definition: $T = T_s + \\phi(T_l - T_s)$. This two-step process ($H \\to \\phi \\to T$) is numerically robust.\n\n**4. Numerical Algorithm and Conservation Check**\n\nThe simulation proceeds as follows:\n1.  **Initialization**: Given an initial uniform temperature $T_0$, compute the initial phase fraction $\\phi_i^0$ and enthalpy $H_i^0$ for all CVs $i=0, \\dots, N-1$.\n2.  **Time Marching**: For each time step $n$ from $0$ to $N_t-1$:\n    a.  Store the current enthalpy field $H_i^n$ and phase fraction field $\\phi_i^n$.\n    b.  **Recover Temperature**: Compute $T_i^n$ from $H_i^n$ for all $i$ using the inversion logic.\n    c.  **Compute Fluxes**: Calculate all face fluxes $q_j^n$ for $j=0, \\dots, N$. The boundary fluxes $q_0^n$ and $q_N^n$ are prescribed, while interior fluxes are calculated from the temperature field $T^n$.\n    d.  **Update Enthalpy**: Compute the new enthalpy field $H_i^{n+1}$ for all $i$ using the explicit FVM update formula.\n    e.  **Post-Process**:\n        i.  Recover the new phase fraction $\\phi_i^{n+1}$ from $H_i^{n+1}$.\n        ii. Calculate the latent heat generation/consumption for the step: $\\Delta L^n = \\sum_i \\rho L_h (\\phi_i^{n+1} - \\phi_i^n) V_i$.\n        iii. check discrete energy conservation by computing the residual: $R^n = (q_0^n - q_N^n) A \\Delta t - \\sum_i (H_i^{n+1} - H_i^n) V_i$. Due to the formulation, this residual is theoretically zero and any non-zero value arises from floating-point arithmetic precision errors. The maximum absolute value of $R^n$ over the simulation is recorded.\n3.  **Reporting**: After completing all time steps for a given test case, the maximum absolute residual and the total accumulated latent heat are reported. This process is repeated for all test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used.\n\ndef solve():\n    \"\"\"\n    Solves the 1D Stefan problem using the enthalpy method and FVM.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'T0': -2.0, 'q0': 50000.0},  # Case 1: melting\n        {'T0': 2.0, 'q0': -50000.0}, # Case 2: solidification\n        {'T0': -10.0, 'q0': 1000.0},   # Case 3: no phase change\n    ]\n\n    # Global parameters\n    A = 1.0         # Cross-sectional area (m^2)\n    Lx = 0.1        # Slab length (m)\n    N = 64          # Number of control volumes\n    dt = 1.0        # Time step (s)\n    k = 0.6         # Thermal conductivity (W/m-K)\n    rho = 1000.0    # Density (kg/m^3)\n    cp = 4200.0     # Specific heat capacity (J/kg-K)\n    Lh = 334000.0   # Latent heat of fusion (J/kg)\n    Ts = -1.0       # Solidus temperature (degC)\n    Tl = 1.0        # Liquidus temperature (degC)\n    Nt = 30         # Number of time steps\n    qN = 0.0        # Flux at right boundary (x=Lx)\n\n    # Derived parameters\n    dx = Lx / N\n    Vi = A * dx  # Volume of a control volume\n\n    # Enthalpy thresholds for phase change\n    H_s = rho * cp * Ts\n    H_l = rho * cp * Tl + rho * Lh\n    H_mushy_range = H_l - H_s\n\n    # Helper function for state recovery from enthalpy\n    def get_T_and_phi_from_H(H_arr):\n        T_arr = np.zeros_like(H_arr)\n        phi_arr = np.zeros_like(H_arr)\n\n        solid_mask = H_arr <= H_s\n        liquid_mask = H_arr >= H_l\n        mushy_mask = (~solid_mask) & (~liquid_mask)\n\n        # Solid phase\n        phi_arr[solid_mask] = 0.0\n        T_arr[solid_mask] = H_arr[solid_mask] / (rho * cp)\n\n        # Liquid phase\n        phi_arr[liquid_mask] = 1.0\n        T_arr[liquid_mask] = (H_arr[liquid_mask] - rho * Lh) / (rho * cp)\n\n        # Mushy phase\n        phi_arr[mushy_mask] = (H_arr[mushy_mask] - H_s) / H_mushy_range\n        T_arr[mushy_mask] = Ts + phi_arr[mushy_mask] * (Tl - Ts)\n        \n        return T_arr, phi_arr\n\n    # Helper function for initialization\n    def get_H_and_phi_from_T(T_arr):\n        phi_arr = np.zeros_like(T_arr)\n\n        liquid_mask = T_arr >= Tl\n        mushy_mask = (T_arr > Ts) & (T_arr < Tl)\n\n        phi_arr[liquid_mask] = 1.0\n        phi_arr[mushy_mask] = (T_arr[mushy_mask] - Ts) / (Tl - Ts)\n        \n        H_arr = rho * cp * T_arr + rho * Lh * phi_arr\n        \n        return H_arr, phi_arr\n    \n    results = []\n    \n    for case in test_cases:\n        T0 = case['T0']\n        q0 = case['q0']\n    \n        # Initialization for the current case\n        T = np.full(N, T0)\n        H, _ = get_H_and_phi_from_T(T)\n\n        total_latent_heat = 0.0\n        max_abs_residual = 0.0\n\n        # Main time-stepping loop\n        for n in range(Nt):\n            H_old = H.copy()\n            \n            # Recover temperature and phase fraction from current enthalpy\n            T, phi_old = get_T_and_phi_from_H(H_old)\n            \n            # Compute fluxes at faces\n            q_faces = np.zeros(N + 1)\n            q_faces[0] = q0\n            q_faces[N] = qN\n            # Interior faces (j=1 to N-1)\n            q_faces[1:-1] = -k * (T[1:] - T[:-1]) / dx\n            \n            # Update enthalpy for all control volumes\n            H += (dt / dx) * (q_faces[:-1] - q_faces[1:])\n            \n            # Recover new phase fraction to calculate latent heat change\n            _, phi_new = get_T_and_phi_from_H(H)\n\n            # Calculate latent heat change for this step\n            latent_heat_step = np.sum(rho * Lh * (phi_new - phi_old) * Vi)\n            total_latent_heat += latent_heat_step\n\n            # Calculate the energy residual for this step\n            # Total change in enthalpy in the domain\n            total_enthalpy_change = np.sum((H - H_old) * Vi)\n            # Net energy input from boundaries\n            net_boundary_input = (q_faces[0] - q_faces[-1]) * A * dt\n            \n            residual = net_boundary_input - total_enthalpy_change\n            if abs(residual) > max_abs_residual:\n                max_abs_residual = abs(residual)\n                \n        results.extend([max_abs_residual, total_latent_heat])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond one-dimensional models introduces significant geometric complexity, particularly for methods that track or capture a sharp, curved interface. Accurately computing the interface normal and local field gradients from discrete data is a critical sub-problem in methods like level-set or front-tracking. This advanced exercise focuses on this reconstruction challenge in two dimensions, using a least-squares approach to highlight the interplay between stencil geometry, numerical conditioning, and the accuracy of the computed interface velocity .",
            "id": "3987407",
            "problem": "You are given an interface between two phases described implicitly by a level-set field and a surrounding temperature field. The local normal velocity at the interface is governed by the Stefan condition, which arises from energy conservation and latent heat release/absorption during phase change. Your task is to compute the normal velocity at a single, curved interface point by reconstructing the normal vector and temperature gradient using a first-order least-squares procedure over a neighborhood stencil. You must also quantify the sensitivity of the reconstruction to the stencil selection via a matrix condition number, and report the aggregated results for a prescribed test suite.\n\nFundamental base and governing relation. Consider a one-phase Stefan formulation in which heat conduction occurs on one side of the interface and the far-field driving does not require solving for the other side. The energy balance at the moving interface is\n$$ \\rho L V_n = -k \\,\\frac{\\partial T}{\\partial n}, $$\nwhere $V_n$ is the normal velocity (positive in the outward normal direction), $\\rho$ is the mass density, $L$ is the latent heat, $k$ is the thermal conductivity, and $\\partial T/\\partial n$ is the temperature derivative along the outward unit normal. In this problem, you must compute $V_n$ by reconstructing the normal and the temperature gradient directly from discrete data.\n\nReconstruction method. Let the interface be represented by a level-set field $\\phi(x,y)$, where the interface is the zero isocontour of $\\phi$. At a chosen interface location $\\mathbf{x}_0=(x_0,y_0)$, define a local first-order Taylor model for a field $f\\in\\{\\phi,T\\}$,\n$$ f(\\mathbf{x}_0+\\Delta\\mathbf{x}) \\approx a_f + \\mathbf{g}_f \\cdot \\Delta\\mathbf{x}, $$\nwhere $\\Delta\\mathbf{x} = (\\Delta x, \\Delta y)$ are offsets from $\\mathbf{x}_0$, $a_f$ is the local intercept, and $\\mathbf{g}_f=\\nabla f(\\mathbf{x}_0)$ is the local gradient. Given a stencil of $N$ neighbor points $\\{\\mathbf{x}_i=\\mathbf{x}_0+\\Delta\\mathbf{x}_i\\}_{i=1}^N$, assemble the linear least-squares system for $f$,\n$$ \\begin{bmatrix}\n1 & \\Delta x_1 & \\Delta y_1 \\\\\n\\vdots & \\vdots & \\vdots \\\\\n1 & \\Delta x_N & \\Delta y_N\n\\end{bmatrix}\n\\begin{bmatrix}\na_f \\\\ g_{f,x} \\\\ g_{f,y}\n\\end{bmatrix}\n\\approx\n\\begin{bmatrix}\nf(\\mathbf{x}_1) \\\\ \\vdots \\\\ f(\\mathbf{x}_N)\n\\end{bmatrix}. $$\nSolve in the least-squares sense to obtain $\\mathbf{g}_f$. The outward unit normal is reconstructed from the level-set gradient as\n$$ \\mathbf{n} = \\frac{\\nabla \\phi(\\mathbf{x}_0)}{\\|\\nabla \\phi(\\mathbf{x}_0)\\|} = \\frac{\\mathbf{g}_\\phi}{\\|\\mathbf{g}_\\phi\\|}, $$\nand the directional derivative of temperature along the normal is\n$$ \\frac{\\partial T}{\\partial n} = \\mathbf{n} \\cdot \\nabla T(\\mathbf{x}_0) = \\mathbf{n}\\cdot \\mathbf{g}_T. $$\nThe normal velocity follows from the Stefan condition,\n$$ V_n = -\\frac{k}{\\rho L}\\,\\mathbf{n}\\cdot\\mathbf{g}_T. $$\nTo quantify sensitivity to stencil selection, compute the condition number of the geometry matrix\n$$ G = \\begin{bmatrix}\n\\Delta x_1 & \\Delta y_1\\\\\n\\vdots & \\vdots\\\\\n\\Delta x_N & \\Delta y_N\n\\end{bmatrix}, $$\ndefined by\n$$ \\kappa(G) = \\frac{\\sigma_{\\max}(G)}{\\sigma_{\\min}(G)}, $$\nwhere $\\sigma_{\\max}$ and $\\sigma_{\\min}$ denote the largest and smallest singular values of $G$. A larger $\\kappa(G)$ indicates a more ill-conditioned stencil, implying increased sensitivity of the least-squares gradient to data perturbations.\n\nInterface, fields, and physical parameters. The interface is the circle $\\phi(x,y) = x^2 + y^2 - R^2$, with radius $R=0.05\\,\\mathrm{m}$. The point of interest is located at the angle $\\theta=\\pi/6$ (angle unit: radians), so that\n$$ x_0 = R\\cos\\theta,\\quad y_0 = R\\sin\\theta. $$\nThe temperature field is linear with a constant gradient aligned with the local outward normal at $\\mathbf{x}_0$:\n$$ \\nabla T = g \\,\\mathbf{n}_0,\\quad \\mathbf{n}_0 = \\frac{(x_0,y_0)}{\\sqrt{x_0^2+y_0^2}} = (\\cos\\theta,\\sin\\theta), $$\nand $T(x,y) = g\\,\\mathbf{n}_0\\cdot(x,y)$ with $g=100\\,\\mathrm{K/m}$. The physical properties are $\\rho=920\\,\\mathrm{kg/m^3}$, $L=3.34\\times 10^5\\,\\mathrm{J/kg}$, and $k=2.2\\,\\mathrm{W/(m\\cdot K)}$. The exact normal derivative at $\\mathbf{x}_0$ for the analytic temperature $T$ is $g$ because $\\mathbf{n}_0\\cdot\\nabla T = g\\,\\mathbf{n}_0\\cdot\\mathbf{n}_0 = g$, and the exact Stefan velocity is $V_n^\\star = -k g / (\\rho L)$, which you should recover approximately with well-conditioned stencils.\n\nTest suite. For each test, construct neighbors relative to $\\mathbf{x}_0$ using offsets $(\\Delta x_i,\\Delta y_i)$ as given; neighbor coordinates are $\\mathbf{x}_i=\\mathbf{x}_0+(\\Delta x_i,\\Delta y_i)$. Evaluate $\\phi(\\mathbf{x}_i)$ and $T(\\mathbf{x}_i)$ per definitions above. In test B, add the prescribed temperature noise to $T(\\mathbf{x}_i)$ before reconstruction. Use the least-squares procedure to reconstruct $\\nabla\\phi$ and $\\nabla T$ at $\\mathbf{x}_0$, compute $\\mathbf{n}$, and then compute $V_n$ and $\\kappa(G)$.\n\n- Test A (symmetric 8-point stencil, no temperature noise): Let $h=0.004\\,\\mathrm{m}$ and use the offsets\n$$\n(\\pm h,0),\\quad (0,\\pm h),\\quad \\left(\\pm\\frac{h}{\\sqrt{2}},\\pm\\frac{h}{\\sqrt{2}}\\right),\\quad \\left(\\pm\\frac{h}{\\sqrt{2}},\\mp\\frac{h}{\\sqrt{2}}\\right).\n$$\nThis yields 8 distinct points.\n\n- Test B (same symmetric 8-point stencil with temperature noise): Use the same offsets as Test A. Add the following noise values in Kelvin to the corresponding temperature samples in the order listed: $[0.07,\\,-0.03,\\,0.10,\\,-0.05,\\,0.02,\\,-0.04,\\,0.00,\\,0.06]$.\n\n- Test C (biased 5-point stencil, more points on one side of $\\mathbf{x}_0$): Let $h=0.004\\,\\mathrm{m}$ and use offsets\n$$\n(h,\\tfrac{h}{6}),\\quad (\\tfrac{h}{2},\\tfrac{h}{4}),\\quad (-0.2h,0.8h),\\quad (-0.5h,0.6h),\\quad (0.2h,0.9h).\n$$\n\n- Test D (near-collinear 4-point stencil, ill-conditioned): Let $h=0.004\\,\\mathrm{m}$ and use offsets\n$$\n(h,0),\\quad (-h,0),\\quad (0.5h,0.001h),\\quad (-0.5h,0.001h).\n$$\n\nRequired outputs and units. For each test, compute $V_n$ in meters per second and the condition number $\\kappa(G)$ (dimensionless). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list of two floats $[V_n,\\kappa(G)]$ in that order. Physical units must be carried consistently, and the reported $V_n$ must be in $\\mathrm{m/s}$. For example, your final printed line should look like\n$$ [\\,[V_{n,A},\\kappa_A],\\,[V_{n,B},\\kappa_B],\\,[V_{n,C},\\kappa_C],\\,[V_{n,D},\\kappa_D]\\,]. $$\n\nDesign for coverage. Test A is a well-conditioned \"happy path\" case. Test B evaluates sensitivity to moderate temperature noise. Test C investigates geometric bias. Test D probes a severe near-collinearity edge case with large condition number. All parameters are scientifically plausible and self-consistent.",
            "solution": "The derivation starts from the principle of energy conservation at a moving phase-change interface. In a one-phase Stefan description, energy balance equates conductive heat flux into the interface to the latent energy required to advance the interface:\n$$ \\rho L V_n = -k\\,\\frac{\\partial T}{\\partial n}. $$\nThis follows from the First Law of Thermodynamics applied to an infinitesimal control volume straddling the interface, with latent heat $L$ absorbed or released as the interface advances a differential distance along its normal $\\mathbf{n}$. The minus sign arises from the convention that positive heat flux into the interface (in the outward normal direction) consumes energy to grow the new phase.\n\nTo compute the normal derivative $\\partial T/\\partial n$ numerically at a curved interface point $\\mathbf{x}_0$, we reconstruct both the interface normal and the local temperature gradient via a least-squares approximation using data in a neighborhood. Given discrete samples $f(\\mathbf{x}_i)$ of a smooth field $f$ at offsets $\\Delta\\mathbf{x}_i = \\mathbf{x}_i - \\mathbf{x}_0$, we adopt a first-order Taylor model\n$$ f(\\mathbf{x}_0+\\Delta\\mathbf{x}) \\approx a_f + \\mathbf{g}_f \\cdot \\Delta\\mathbf{x}, $$\nwith unknown intercept $a_f$ and gradient vector $\\mathbf{g}_f = (g_{f,x},g_{f,y})$. Stacking $N$ such relations yields an overdetermined linear system\n$$ A\\boldsymbol{\\theta}_f \\approx \\mathbf{f},\\quad\nA=\\begin{bmatrix}\n1 & \\Delta x_1 & \\Delta y_1 \\\\\n\\vdots & \\vdots & \\vdots \\\\\n1 & \\Delta x_N & \\Delta y_N\n\\end{bmatrix},\\quad\n\\boldsymbol{\\theta}_f=\\begin{bmatrix} a_f \\\\ g_{f,x} \\\\ g_{f,y}\\end{bmatrix},\\quad\n\\mathbf{f}=\\begin{bmatrix} f(\\mathbf{x}_1) \\\\ \\vdots \\\\ f(\\mathbf{x}_N)\\end{bmatrix}.\n$$\nThe least-squares solution minimizes the residual $||A\\boldsymbol{\\theta}_f - \\mathbf{f}||_2$, which is well known from linear algebra and numerical analysis. A robust approach is to obtain $\\boldsymbol{\\theta}_f$ via the Moore–Penrose pseudoinverse using singular value decomposition, or equivalently via a stable routine that solves the normal equations. In practice, the routine computes\n$$ \\boldsymbol{\\theta}_f = \\operatorname*{arg\\,min}_{\\boldsymbol{\\theta}} ||A\\boldsymbol{\\theta}-\\mathbf{f}||_2, $$\nand the gradient is extracted as $\\mathbf{g}_f = (g_{f,x},g_{f,y})$. This construction applies to both $f=\\phi$ and $f=T$.\n\nThe outward unit normal is obtained from the level-set gradient,\n$$ \\mathbf{n} = \\frac{\\nabla \\phi(\\mathbf{x}_0)}{\\|\\nabla \\phi(\\mathbf{x}_0)\\|} = \\frac{\\mathbf{g}_\\phi}{\\|\\mathbf{g}_\\phi\\|}, $$\nwhich is consistent with the implicit surface definition $\\phi(\\mathbf{x})=0$: the gradient points in the direction of steepest increase of $\\phi$ and is normal to the level set. The normal derivative of temperature is then\n$$ \\frac{\\partial T}{\\partial n} = \\mathbf{n} \\cdot \\nabla T(\\mathbf{x}_0) = \\mathbf{n} \\cdot \\mathbf{g}_T. $$\nSubstituting into the Stefan relation yields\n$$ V_n = -\\frac{k}{\\rho L}\\,\\mathbf{n}\\cdot\\mathbf{g}_T. $$\n\nSensitivity of the reconstruction to the stencil choice is captured by the condition number of the geometry matrix $G\\in\\mathbb{R}^{N\\times 2}$ composed of the offsets,\n$$ G = \\begin{bmatrix}\n\\Delta x_1 & \\Delta y_1\\\\\n\\vdots & \\vdots\\\\\n\\Delta x_N & \\Delta y_N\n\\end{bmatrix}. $$\nThe least-squares estimate of the gradient depends on $G$ through the regressor matrix. If $G$ is ill-conditioned, small perturbations (such as noise in $T$) can cause large changes in the estimated gradient. The condition number\n$$ \\kappa(G) = \\frac{\\sigma_{\\max}(G)}{\\sigma_{\\min}(G)} $$\nquantifies this susceptibility, where $\\sigma_{\\max},\\sigma_{\\min}$ are singular values of $G$. Geometrically, $\\kappa(G)$ increases when the stencil points lie close to a line (near-collinearity), or when angular coverage is poor, leading to insufficient excitation of one component of the gradient.\n\nImplementation details for the given test suite:\n1. Interface and temperature fields: The interface level set is $\\phi(x,y)=x^2+y^2-R^2$ with $R=0.05\\,\\mathrm{m}$. The point of interest is $\\mathbf{x}_0 = (x_0,y_0) = (R\\cos\\theta,R\\sin\\theta)$ with $\\theta=\\pi/6$, so $\\mathbf{n}_0=(\\cos\\theta,\\sin\\theta)$. The temperature is $T(x,y)=g\\,\\mathbf{n}_0\\cdot(x,y)$ with $g=100\\,\\mathrm{K/m}$, which ensures an exact gradient $\\nabla T=g\\,\\mathbf{n}_0$ and an exact normal derivative $\\partial T/\\partial n=g$ at $\\mathbf{x}_0$.\n2. Neighbor generation: For each test, form $\\mathbf{x}_i=\\mathbf{x}_0+(\\Delta x_i,\\Delta y_i)$ from the specified offsets. Evaluate $\\phi(\\mathbf{x}_i)$ and $T(\\mathbf{x}_i)$, and add the specified noise to $T(\\mathbf{x}_i)$ in Test B.\n3. Least-squares reconstruction: Assemble $A$ with columns $[1,\\Delta x,\\Delta y]$ and solve for $\\boldsymbol{\\theta}_\\phi$ and $\\boldsymbol{\\theta}_T$ to obtain $\\mathbf{g}_\\phi$ and $\\mathbf{g}_T$. Compute $\\mathbf{n}=\\mathbf{g}_\\phi/\\|\\mathbf{g}_\\phi\\|$.\n4. Normal velocity and sensitivity: Compute $\\partial T/\\partial n = \\mathbf{n}\\cdot\\mathbf{g}_T$ and $V_n=-(k/(\\rho L))\\,\\partial T/\\partial n$ with $\\rho=920\\,\\mathrm{kg/m^3}$, $L=3.34\\times 10^5\\,\\mathrm{J/kg}$, and $k=2.2\\,\\mathrm{W/(m\\cdot K)}$. Compute $\\kappa(G)$ from the singular values of $G$ constructed from the offsets.\n\nExpected qualitative behavior:\n- In Test A, the symmetric stencil has good angular coverage; $\\kappa(G)$ should be modest, and $V_n$ should closely match the analytical $V_n^\\star = -k g / (\\rho L)$.\n- In Test B, the same stencil but with temperature noise slightly perturbs $\\mathbf{g}_T$, producing a small deviation in $V_n$; $\\kappa(G)$ is unchanged because it depends only on geometry.\n- In Test C, the biased stencil reduces angular coverage, increasing $\\kappa(G)$ and biasing the reconstructed gradients, which may yield a more noticeable deviation in $V_n$.\n- In Test D, near-collinearity leads to a large $\\kappa(G)$, indicating severe ill-conditioning; the reconstructed normal and temperature gradient will be highly sensitive, and $V_n$ may deviate significantly from the analytical value.\n\nThe program directly implements the above steps, computes the outputs for all tests, and prints a single line containing a list of $[V_n,\\kappa(G)]$ pairs in the required format. The angle unit is radians, and $V_n$ is reported in $\\mathrm{m/s}$.",
            "answer": "```python\nimport numpy as np\n\ndef least_squares_gradient(offsets, values):\n    \"\"\"\n    Fit a first-order Taylor model f(x0 + dx, y0 + dy) ~= a + b*dx + c*dy\n    using least squares, and return the gradient (b, c).\n    \"\"\"\n    # Build A with columns [1, dx, dy]\n    dx = np.array([o[0] for o in offsets], dtype=float)\n    dy = np.array([o[1] for o in offsets], dtype=float)\n    A = np.column_stack((np.ones_like(dx), dx, dy))\n    b = np.array(values, dtype=float)\n    # Solve least squares\n    theta, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n    # Gradient components\n    grad = np.array([theta[1], theta[2]], dtype=float)\n    return grad\n\ndef condition_number_geometry(offsets):\n    \"\"\"\n    Compute condition number kappa(G) = sigma_max / sigma_min for G=[dx,dy].\n    \"\"\"\n    dx = np.array([o[0] for o in offsets], dtype=float)\n    dy = np.array([o[1] for o in offsets], dtype=float)\n    G = np.column_stack((dx, dy))\n    # SVD singular values\n    s = np.linalg.svd(G, compute_uv=False)\n    # Handle potential singularity: if smin == 0, set kappa to inf\n    smax = np.max(s)\n    smin = np.min(s)\n    if smin == 0.0:\n        return float('inf')\n    return float(smax / smin)\n\ndef compute_case(offsets, add_temp_noise=None):\n    \"\"\"\n    Given offsets relative to x0, compute V_n and kappa(G).\n    If add_temp_noise is provided, it should be a list of noise values (same length as offsets)\n    to be added to temperature samples.\n    \"\"\"\n    # Physical and geometric parameters\n    R = 0.05  # m\n    theta = np.pi / 6.0  # radians\n    x0 = R * np.cos(theta)\n    y0 = R * np.sin(theta)\n    n0 = np.array([np.cos(theta), np.sin(theta)])  # unit normal at x0 for the circle\n    g = 100.0  # K/m\n    rho = 920.0  # kg/m^3\n    L = 3.34e5   # J/kg\n    k = 2.2      # W/(m*K)\n\n    # Build neighbor coordinates\n    pts = [(x0 + dx, y0 + dy) for (dx, dy) in offsets]\n\n    # Evaluate phi and T\n    phi_vals = []\n    T_vals = []\n    for i, (x, y) in enumerate(pts):\n        phi = x**2 + y**2 - R**2\n        T = g * (n0[0] * x + n0[1] * y)\n        phi_vals.append(phi)\n        T_vals.append(T)\n\n    # Add temperature noise if specified\n    if add_temp_noise is not None:\n        T_vals = [T_vals[i] + float(add_temp_noise[i]) for i in range(len(T_vals))]\n\n    # Reconstruct gradients via least squares\n    grad_phi = least_squares_gradient(offsets, phi_vals)\n    grad_T = least_squares_gradient(offsets, T_vals)\n\n    # Compute reconstructed unit normal\n    norm_grad_phi = np.linalg.norm(grad_phi)\n    # Guard against zero norm (degenerate); if zero, set normal to n0 to avoid division by zero\n    if norm_grad_phi == 0.0:\n        n_rec = n0.copy()\n    else:\n        n_rec = grad_phi / norm_grad_phi\n\n    # Directional derivative of T along reconstructed normal\n    dT_dn = float(np.dot(n_rec, grad_T))\n\n    # Stefan velocity\n    Vn = -k * dT_dn / (rho * L)\n\n    # Condition number of geometry matrix\n    kappa = condition_number_geometry(offsets)\n\n    return Vn, kappa\n\ndef solve():\n    # Define h and base offsets for tests\n    h = 0.004  # m\n\n    # Test A: symmetric 8-point stencil, no noise\n    offsets_A = [\n        ( h, 0.0),\n        (-h, 0.0),\n        ( 0.0, h),\n        ( 0.0,-h),\n        ( h/np.sqrt(2.0),  h/np.sqrt(2.0)),\n        (-h/np.sqrt(2.0), -h/np.sqrt(2.0)),\n        ( h/np.sqrt(2.0), -h/np.sqrt(2.0)),\n        (-h/np.sqrt(2.0),  h/np.sqrt(2.0)),\n    ]\n\n    # Test B: same as A, add temperature noise per given order\n    noise_B = [0.07, -0.03, 0.10, -0.05, 0.02, -0.04, 0.00, 0.06]\n\n    # Test C: biased 5-point stencil\n    offsets_C = [\n        ( h,       h/6.0),\n        ( 0.5*h,   h/4.0),\n        (-0.2*h,   0.8*h),\n        (-0.5*h,   0.6*h),\n        ( 0.2*h,   0.9*h),\n    ]\n\n    # Test D: near-collinear 4-point stencil\n    offsets_D = [\n        ( h,       0.0),\n        (-h,       0.0),\n        ( 0.5*h,   0.001*h),\n        (-0.5*h,   0.001*h),\n    ]\n\n    # Compute results\n    results = []\n    Vn_A, kappa_A = compute_case(offsets_A, add_temp_noise=None)\n    results.append([Vn_A, kappa_A])\n\n    Vn_B, kappa_B = compute_case(offsets_A, add_temp_noise=noise_B)\n    results.append([Vn_B, kappa_B])\n\n    Vn_C, kappa_C = compute_case(offsets_C, add_temp_noise=None)\n    results.append([Vn_C, kappa_C])\n\n    Vn_D, kappa_D = compute_case(offsets_D, add_temp_noise=None)\n    results.append([Vn_D, kappa_D])\n\n    # Print single line in required format\n    # Ensure plain Python list formatting with floats\n    # Convert inner lists to strings and join\n    formatted = \"[\" + \",\".join(\n        [\"[\" + \",\".join(map(str, pair)) + \"]\" for pair in results]\n    ) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}