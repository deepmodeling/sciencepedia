{
    "hands_on_practices": [
        {
            "introduction": "在投入编程之前，对问题的物理特性进行初步分析是计算科学家的重要一步。本练习的核心是计算斯特凡数（Stefan number, $Ste$），这是一个关键的无量纲参数，它量化了显热与潜热的比率。通过这个练习，您将学会如何利用斯特凡数来预测系统的动态行为（例如，缓慢或快速熔化），并预见相应的数值挑战，从而为选择合适的离散化策略提供指导。",
            "id": "3987464",
            "problem": "一个占据 $x \\geq 0$ 的一维 (1D) 半无限相变平板，初始时处于相变温度 $T_{m}$。在时间 $t=0$ 时，$x=0$ 处的边界温度突然升高并保持在一个更高的温度 $T_{b}  T_{m}$，从而引发熔化，并在 $x = s(t)$ 处形成一个清晰的固液界面。假设采用单相 Stefan 公式，其中固相保持在 $T_{m}$，热传导仅发生在液相中，界面清晰，没有糊状区。液相的热导率为 $k$，密度为 $\\rho$，定压比热为 $c_{p}$，该材料的熔化潜热为 $L$。\n\n给定以下代表类石蜡相变材料的物理上合理的参数：\n- $k = 0.40\\ \\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$，\n- $\\rho = 900\\ \\mathrm{kg}\\,\\mathrm{m}^{-3}$，\n- $c_{p} = 2200\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$，\n- $L = 2.60 \\times 10^{5}\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}$，\n- $T_{m} = 327\\ \\mathrm{K}$，\n- $T_{b} = 342\\ \\mathrm{K}$，\n\n计算表征此熔化场景中显热与潜热之比的无量纲 Stefan 数。然后，基于第一性原理，讨论界面动力学的预期定性状态（例如，慢速或快速熔化），以及这对移动边界问题的计算求解器在离散化方面的影响，包括时间步进、网格分辨率和方法选择。将最终答案表示为一个四舍五入到三位有效数字的无量纲数。",
            "solution": "用户提供了一个在尝试求解前需要进行严格验证的问题。\n\n### 步骤1：提取已知条件\n- 域：一维 (1D) 半无限平板, $x \\geq 0$。\n- 初始条件 ($t=0$): 整个平板处于相变温度, 对于所有 $x \\geq 0$ 都有 $T(x,0) = T_{m}$。\n- 边界条件 ($x=0$): 对于 $t  0$, 边界保持在恒定温度 $T_{b}  T_{m}$，即 $T(0,t) = T_{b}$。\n- 界面：在位置 $x = s(t)$ 处存在一个清晰的固液界面。\n- 模型：单相 Stefan 问题，固相保持在 $T = T_{m}$，热传导仅发生在液相 ($0 \\leq x \\leq s(t)$) 中。\n- 液相性质：\n  - 热导率: $k = 0.40\\ \\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$\n  - 密度: $\\rho = 900\\ \\mathrm{kg}\\,\\mathrm{m}^{-3}$\n  - 比热: $c_{p} = 2200\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$\n- 材料性质：\n  - 熔化潜热: $L = 2.60 \\times 10^{5}\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}$\n- 温度：\n  - 熔化温度: $T_{m} = 327\\ \\mathrm{K}$\n  - 边界温度: $T_{b} = 342\\ \\mathrm{K}$\n\n### 步骤2：使用提取的已知条件进行验证\n根据所需标准对问题陈述进行验证。\n1.  **科学依据：** 该问题描述了一个经典的单相 Stefan 问题，这是瞬态相变传热中一个基础且成熟的模型。其物理原理是合理的。所提供的材料参数明确说明是代表类石蜡材料的，并且其数量级和单位在物理上是现实的。\n2.  **适定性：** 该问题是适定的。初始条件和边界条件足以确定液相温度场和移动界面位置的唯一解。任务是计算一个标准的无量纲数（Stefan 数）并基于成熟的计算传热学原理提供定性讨论。\n3.  **客观性：** 该问题使用清晰、客观和定量的语言进行陈述。\n4.  **完整性和一致性：** 计算 Stefan 数所需的所有数据都已提供。条件 $T_{b}  T_{m}$ 确保了熔化的发生，这与问题设置一致。没有矛盾之处。\n\n### 步骤3：结论与行动\n该问题被判定为**有效**。将提供解答。\n\n该问题需要两部分：计算 Stefan 数，以及定性讨论其对问题动力学和数值解的影响。\n\n**第1部分：计算 Stefan 数**\n\nStefan 数，记作 $Ste$，是一个无量纲参数，表示显热与潜热之比。对于熔化问题，它通常根据液相的性质来定义。特征显热是将单位质量的液体从熔化温度 $T_m$ 升高到边界温度 $T_b$ 所需的能量。潜热是在温度 $T_m$ 下熔化单位质量固体所需的能量。\n\nStefan 数的数学定义是：\n$$\nSte = \\frac{c_{p} (T_{b} - T_{m})}{L}\n$$\n其中：\n- $c_p$ 是液体的比热。\n- $L$ 是熔化潜热。\n- $T_b$ 是边界温度。\n- $T_m$ 是熔化温度。\n\n将给定值代入此定义：\n- $c_{p} = 2200\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$\n- $T_{b} = 342\\ \\mathrm{K}$\n- $T_{m} = 327\\ \\mathrm{K}$\n- $L = 2.60 \\times 10^{5}\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}$\n\n温差为 $\\Delta T = T_{b} - T_{m} = 342\\ \\mathrm{K} - 327\\ \\mathrm{K} = 15\\ \\mathrm{K}$。\n\n现在我们计算 Stefan 数：\n$$\nSte = \\frac{(2200\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}) \\times (15\\ \\mathrm{K})}{2.60 \\times 10^{5}\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}}\n$$\n$$\nSte = \\frac{33000}{260000} = \\frac{33}{260}\n$$\n计算数值：\n$$\nSte \\approx 0.126923...\n$$\n四舍五入到三位有效数字，Stefan 数为 $0.127$。\n\n**第2部分：界面动力学与计算影响的讨论**\n\n计算出的 Stefan 数为 $Ste \\approx 0.127$。该值远小于 1 ($Ste \\ll 1$)，这具有重要的物理和数值后果。\n\n**界面动力学的定性状态：**\n小的 Stefan 数表明熔化潜热 ($L$) 相对于液相的显热容 ($c_{p} (T_{b} - T_{m})$) 要大得多。这标志着一个**潜热主导**的过程。物理上，这意味着到达固液界面的大部分热通量被相变本身消耗，只有一小部分用于提高新形成液体的温度。\n这导致了一个**慢速熔化**状态。界面 $s(t)$ 移动缓慢，因为需要大量的能量来克服潜热障碍并熔化固体。在这种状态下，液相中的温度分布，$T(x,t)$ for $0 \\leq x \\leq s(t)$，趋于近乎线性。这是因为边界的缓慢移动允许温度场弛豫到一个准稳态。液相中的控制热方程为 $\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}$，其中 $\\alpha = k/(\\rho c_p)$ 是热扩散系数。对于缓慢的界面运动，瞬态项 $\\frac{\\partial T}{\\partial t}$ 与扩散项相比变得很小，温度分布接近稳态线性分布。\n\n**对计算求解器中离散化的影响：**\n\n小的 Stefan 数 ($Ste \\ll 1$) 将此问题归类为数值上的“刚性”问题，这指导了数值方法、时间步进和网格分辨率的选择。\n\n1.  **方法选择：**\n    - **界面追踪法：** 这些方法显式追踪界面位置 $s(t)$ 并在带有移动边界的液相域中求解热方程。对于像这样具有清晰界面的 1D 问题，界面追踪法非常精确。然而，对于更高维度或界面拓扑发生变化的问题，其实现变得复杂。\n    - **固定网格法：** 这些方法通常更鲁棒且更易于实现。最常见的是**焓法**。该问题使用焓作为主要变量重新表述，从而得到整个区域的单一控制方程。相变通过焓-温度关系 $H(T)$ 被隐式处理。清晰的界面通常被涂抹在一个或两个网格单元上。该方法具有强保守性和鲁棒性，使其成为工业代码的标准选择。另一种固定网格法是**有效热容法**，其中潜热被建模为 $T_m$ 附近比热的一个巨大峰值。这通常会导致严重的数值刚性问题，并需要非常小的时间步长来保证稳定性，使其不如焓法受欢迎。鉴于问题的刚性 ($Ste \\ll 1$)，焓法是一个绝佳的选择。\n\n2.  **时间步进 ($\\Delta t$)：**\n    - 问题由大的潜热项引起的刚性，强烈倾向于使用**隐式时间积分格式**（例如，后向欧拉法、Crank-Nicolson 法）。显式格式会受到非常严格的稳定性时间步长限制，尤其是在使用有效热容公式时。隐式方法是无条件稳定的，允许由精度而非稳定性决定的更大时间步长。\n    - 即使使用隐式格式，时间步长也必须足够小，以精确解析界面的运动。一个常见的经验法则是确保界面在每个时间步长内移动的距离小于一个网格单元宽度 ($\\Delta x$)，以避免相界面的非物理“跳跃”并在焓法中保持精度。\n    - 由于熔化缓慢（因为 $Ste$ 很小），界面速度较低，这与高 $Ste$ 问题相比，对时间步长的要求可能不那么苛刻，但最终的选择取决于所需的精度。\n\n3.  **网格分辨率 ($\\Delta x$)：**\n    - 界面处的 Stefan 条件，$k \\frac{\\partial T}{\\partial x}|_{x=s(t)^-} = \\rho L \\frac{ds}{dt}$，表明界面速度与前沿的温度梯度成正比。精确解析这个梯度至关重要。这需要在移动界面附近有精细的网格分辨率。\n    - 在固定网格法中，使用更精细的网格可以使界面位置和温度分布更准确。相界面的涂抹效应随着 $\\Delta x \\to 0$ 而减小。\n    - 由于大部分液相区域的温度分布近乎线性（$Ste \\ll 1$ 的结果），在远离界面的地方，较粗的网格可能就足够了。这使得该问题成为**自适应网格加密 (AMR)** 的理想候选者。通过 AMR，精细网格仅在界面附近使用并随之移动，而其他地方则使用较粗的网格。这种策略在最需要的地方提供高精度，而没有全局精细网格带来的高昂计算成本，使其成为解决 Stefan 问题的一种高效方法。",
            "answer": "$$\n\\boxed{0.127}\n$$"
        },
        {
            "introduction": "在进行了宏观概念分析之后，我们可以深入探讨时间积分稳定性的核心数值挑战。本练习采用一个简化的界面演化模型，旨在清晰地隔离并展示时间离散格式的特性。它通过对比显式与隐式格式，揭示了前者在求解源于斯特凡问题的刚性常微分方程时的条件稳定性，以及后者所具有的无条件稳定性。通过推导稳定性限制并亲手实现两种方案，您将对为何隐式方法对于稳健求解相变问题至关重要获得具体而深刻的理解。",
            "id": "3987441",
            "problem": "考虑一维单相 Stefan 问题，该问题研究一个占据区间 $0 \\le x \\le s(t)$ 的板中的熔化前沿，其中 $s(t)$ 表示在时间 $t$（单位：秒）时固液界面的位置（单位：米）。固体初始温度均匀，其在 $x=0$ 处的边界突然被置于一个高于熔化温度 $T_m$（单位：开尔文）的热温度 $T_0$（单位：开尔文）。假设固体中为准稳态热传导，且液体中的热传导可忽略不计，因此固体中的温度场满足一个由傅里叶热传导定律和移动界面处的能量守恒（Stefan 条件）控制的线性分布。\n\n基本定律和定义：\n- 傅里葉定律通过 $q = -k \\,\\partial T/\\partial x$ 将热通量与温度梯度关联起来，其中 $k$ 是热导率（单位：瓦/米·开尔文）。\n- 移动界面处的能量守恒（Stefan 条件）指出，潜热释放或吸收的速率等于进入界面的热通量，即 $\\rho L \\, \\dfrac{ds}{dt} = -k \\,\\left.\\dfrac{\\partial T}{\\partial x}\\right|_{x=s(t)^-}$，其中 $\\rho$ 是密度（单位：千克/立方米），$L$ 是熔化潜热（单位：焦耳/千克）。\n\n在准稳态假设下，边界条件为 $T(0,t) = T_0$ 和 $T(s(t),t) = T_m$，温度场为 $T(x,t) = T_0 + \\dfrac{T_m - T_0}{s(t)}\\,x$。将此代入 Stefan 条件，得到关于界面的常微分方程 (ODE)：\n$$\n\\frac{ds}{dt} = \\frac{C}{s(t)}, \\quad C := \\frac{k\\,(T_0 - T_m)}{\\rho\\,L}.\n$$\n对于熔化过程，$T_0  T_m$，因此 $C  0$；对于凝固（冷却）过程，若 $T_0  T_m$，则 $C  0$。\n\n您的任务是为推进界面位置设计、分析和实现两种时间离散化方案：\n- 显式更新\n$$\ns^{n+1} = s^n + \\Delta t \\, V_n, \\quad V_n := \\frac{C}{s^n},\n$$\n- 隐式更新\n$$\ns^{n+1} = s^n + \\Delta t \\, V_n^{n+1}, \\quad V_n^{n+1} := \\frac{C}{s^{n+1}},\n$$\n其中 $s^n$ 近似于离散时间 $t^n = n\\,\\Delta t$ 处的 $s(t^n)$，$\\Delta t$ 是时间步长（单位：秒）。\n\n从上述基本定律和定义出发，您必须：\n1. 推导 $s(t)$ 的常微分方程及其精确解，\n$$\ns(t) = \\sqrt{s(0)^2 + 2\\,C\\,t}.\n$$\n2. 通过分析显式更新映射 $g(s) := s + \\Delta t\\,C/s$ 和隐式更新的关于 $s^{n+1}$ 的二次关系，推导并比较显式和隐式更新的稳定性。使用与单调性和离散能量 $E(s) := s^2$ 相关的基于原理的论证来证明您的结论。\n3. 为显式方案推导一个时间步长限制，以确保单调性并控制离散能量的增长。将推导出的最大允许时间步长 $\\Delta t_{\\max}$ 以秒为单位表示。\n\n实现要求：\n- 实现两种更新方案，将 $s(t)$ 从初始值 $s(0)=s_0$ 推进到最终时间 $t_{\\mathrm{end}}$。\n- 使用可变数量的时间步数 $N = \\lceil t_{\\mathrm{end}}/\\Delta t \\rceil$，并在需要时使用最后一个部分步长，以使总推进时间等于 $t_{\\mathrm{end}}$。\n- 对于每个测试用例，计算：\n  - 显式方案的最终界面位置 $s_{\\mathrm{exp}}(t_{\\mathrm{end}})$（单位：米）。\n  - 隐式方案的最终界面位置 $s_{\\mathrm{imp}}(t_{\\mathrm{end}})$（单位：米）。\n  - 精确解 $s_{\\mathrm{exact}}(t_{\\mathrm{end}})$（单位：米）。\n  - 推导出的显式稳定性布尔值 $\\mathrm{stable}_{\\mathrm{exp}}$，由不等式 $\\Delta t  \\Delta t_{\\max}$ 定义，其中对于 $C0$ 有 $\\Delta t_{\\max} := \\dfrac{s_0^2}{C}$，对于 $C0$ 有 $\\Delta t_{\\max} := \\dfrac{s_0^2}{|C|}$，以秒为单位表示。\n  - 显式和隐式方案的相对误差，分别为\n  $$\n  e_{\\mathrm{exp}} := \\frac{\\left|s_{\\mathrm{exp}}(t_{\\mathrm{end}}) - s_{\\mathrm{exact}}(t_{\\mathrm{end}})\\right|}{s_{\\mathrm{exact}}(t_{\\mathrm{end}})}, \\quad\n  e_{\\mathrm{imp}} := \\frac{\\left|s_{\\mathrm{imp}}(t_{\\mathrm{end}}) - s_{\\mathrm{exact}}(t_{\\mathrm{end}})\\right|}{s_{\\mathrm{exact}}(t_{\\mathrm{end}})},\n  $$\n  它们是无量纲小数。\n\n测试套件：\n使用以下与铝等金属一致的物理上合理的参数：\n- 热导率 $k = 200$ $\\mathrm{W/(m\\cdot K)}$，\n- 密度 $\\rho = 2700$ $\\mathrm{kg/m^3}$，\n- 潜热 $L = 397000$ $\\mathrm{J/kg}$，\n- 熔化温度 $T_m = 933$ $\\mathrm{K}$，\n- 热边界温度 $T_0 = 1033$ $\\mathrm{K}$，\n- 界面初始位置 $s_0 = 1\\times 10^{-3}$ $\\mathrm{m}$，\n- 最终时间 $t_{\\mathrm{end}} = 10$ $\\mathrm{s}$。\n\n使用这些共享参数，评估三种不同的时间步长情景：\n- 情况 A（理想路径）：$\\Delta t = 0.01$ $\\mathrm{s}$。\n- 情况 B（边界）：$\\Delta t = \\Delta t_{\\max}$（根据推导的限制计算，单位：秒）。\n- 情况 C（边缘）：$\\Delta t = 0.5$ $\\mathrm{s}$。\n\n您的程序应生成一行输出，其中包含三个测试用例的聚合结果，格式为方括号括起来的逗号分隔列表。对于每种情况，按顺序输出\n$$\n\\left[\\Delta t_{\\max}\\;\\mathrm{(in\\;s)},\\;\\mathrm{stable}_{\\mathrm{exp}}\\;\\mathrm{(boolean)},\\;e_{\\mathrm{exp}}\\;\\mathrm{(decimal)},\\;e_{\\mathrm{imp}}\\;\\mathrm{(decimal)}\\right],\n$$\n将所有三种情况的结果连接在同一行上。例如，最终输出格式必须是\n$$\n\\left[\\Delta t_{\\max}^{(A)},\\mathrm{stable}_{\\mathrm{exp}}^{(A)},e_{\\mathrm{exp}}^{(A)},e_{\\mathrm{imp}}^{(A)},\\Delta t_{\\max}^{(B)},\\mathrm{stable}_{\\mathrm{exp}}^{(B)},e_{\\mathrm{exp}}^{(B)},e_{\\mathrm{imp}}^{(B)},\\Delta t_{\\max}^{(C)},\\mathrm{stable}_{\\mathrm{exp}}^{(C)},e_{\\mathrm{exp}}^{(C)},e_{\\mathrm{imp}}^{(C)}\\right],\n$$\n其中每个数字条目都是普通小数，每个布尔条目都是编程语言的原生布尔格式。所有 $\\Delta t_{\\max}$ 条目都必须以秒为单位表示。",
            "solution": "该问题提法明确，科学上基于传热原理，并为计算任务提供了一套完整且一致的数据和定义。这是移动边界问题数值分析中的一个标准问题。因此，该问题是有效的。\n\n按要求，解答过程分为三部分：(1) 推导控制常微分方程 (ODE) 及其精确解；(2) 推导并比较显式和隐式数值方案的稳定性；(3) 实现这些方案以计算所要求的输出。\n\n### 1. 精确解的推导\n\n问题指出，在准稳态假设下，固相 $0 \\le x \\le s(t)$ 中的温度分布是线性的。给定边界条件 $T(x=0, t) = T_0$ 和 $T(x=s(t), t) = T_m$，温度场 $T(x,t)$ 通过线性插值给出：\n$$\nT(x,t) = T_0 + \\frac{T_m - T_0}{s(t)} x\n$$\n热通量 $q$ 通过傅里叶定律与温度梯度相关：$q = -k \\frac{\\partial T}{\\partial x}$。梯度在空间上是均匀的：\n$$\n\\frac{\\partial T}{\\partial x} = \\frac{T_m - T_0}{s(t)}\n$$\n界面 $x=s(t)$ 处的 Stefan 条件表示能量守恒。单位面积上相变所消耗的能量速率必须等于从固相侧进入界面的热通量。\n$$\n\\rho L \\frac{ds}{dt} = -k \\left. \\frac{\\partial T}{\\partial x} \\right|_{x=s(t)^-}\n$$\n其中 $\\rho$ 是密度， $L$ 是熔化潜热， $k$ 是热导率。符号 $x=s(t)^-$ 表示从固相侧（$x  s(t)$）趋近于界面的极限。\n\n将温度梯度的表达式代入 Stefan 条件，得到：\n$$\n\\rho L \\frac{ds}{dt} = -k \\left( \\frac{T_m - T_0}{s(t)} \\right) = \\frac{k (T_0 - T_m)}{s(t)}\n$$\n这可以重新整理为关于界面位置 $s(t)$ 的常微分方程：\n$$\n\\frac{ds}{dt} = \\frac{k(T_0 - T_m)}{\\rho L} \\frac{1}{s(t)}\n$$\n定义常数 $C := \\frac{k(T_0 - T_m)}{\\rho L}$，则常微分方程为：\n$$\n\\frac{ds}{dt} = \\frac{C}{s(t)}\n$$\n这是一个可分离的一阶常微分方程。我们可以通过分离变量并从初始状态 $(s(0), 0)$ 积分到状态 $(s(t), t)$ 来求解它：\n$$\ns(t) \\frac{ds}{dt} = C \\implies \\int_{s(0)}^{s(t)} s' ds' = \\int_0^t C dt'\n$$\n进行积分得到：\n$$\n\\left[ \\frac{1}{2} (s')^2 \\right]_{s(0)}^{s(t)} = [C t']_0^t\n$$\n$$\n\\frac{1}{2}s(t)^2 - \\frac{1}{2}s(0)^2 = C t\n$$\n对 $s(t)^2$ 进行整理并求解 $s(t)$（由于位置必须为正，取正根）：\n$$\ns(t)^2 = s(0)^2 + 2Ct\n$$\n$$\ns(t) = \\sqrt{s(0)^2 + 2Ct}\n$$\n这是给定初始位置 $s(0)$ 时界面位置的精确解。\n\n### 2. 离散化方案的稳定性分析\n\n我们分析用于将解从时间 $t^n$ 推进到 $t^{n+1} = t^n + \\Delta t$ 的显式和隐式方案。\n\n**显式方案：**\n显式更新由 $s^{n+1} = s^n + \\Delta t \\frac{C}{s^n}$ 给出。这可以写成一个迭代映射 $s^{n+1} = g(s^n)$，其中 $g(s) = s + \\frac{\\Delta t C}{s}$。\n\n对于熔化问题，$T_0  T_m$，因此 $C  0$。我们期望 $s(t)$ 是时间的单调递增函数。一个物理上一致的数值方案应该反映这一点。我们来分析更新映射 $g(s)$ 的单调性。其导数为：\n$$\ng'(s) = \\frac{d}{ds} \\left( s + \\frac{\\Delta t C}{s} \\right) = 1 - \\frac{\\Delta t C}{s^2}\n$$\n为了使 $g(s)$ 成为一个单调递增函数，我们需要 $g'(s) \\ge 0$。这个条件可以防止非物理的振荡，即当前位置 $s^n$ 越大反而导致下一个位置 $s^{n+1}$ 越小的情况。\n$$\n1 - \\frac{\\Delta t C}{s^2} \\ge 0 \\implies 1 \\ge \\frac{\\Delta t C}{s^2} \\implies \\Delta t \\le \\frac{s^2}{C}\n$$\n由于当 $C0$ 时 $s(t)$ 随时间增加，项 $s^2/C$ 也随之增加。对 $\\Delta t$ 最严格的约束发生在 $s$ 的最小值处，即初始位置 $s_0 = s(0)$。因此，为确保所有步骤的单调性，我们必须施加条件：\n$$\n\\Delta t \\le \\frac{s_0^2}{C}\n$$\n这定义了最大允许时间步长，$\\Delta t_{\\max} := \\frac{s_0^2}{C}$。如果 $\\Delta t  \\Delta t_{\\max}$，该方案可能会变得振荡，并在此意义上被认为是不稳定的。\n\n从能量的角度来看，我们研究离散能量 $E(s) := s^2$ 的演化。对于显式方案：\n$$\nE(s^{n+1}) = (s^{n+1})^2 = \\left(s^n + \\frac{\\Delta t C}{s^n}\\right)^2 = (s^n)^2 + 2C\\Delta t + \\frac{(\\Delta t C)^2}{(s^n)^2}\n$$\n精确解的演化方式为 $s(t_{n+1})^2 = s(t_n)^2 + 2C\\Delta t$。显式方案引入了一个额外的非负项 $\\frac{(\\Delta t C)^2}{(s^n)^2}$，这是一种形式的数值误差。这个项导致了对能量 $s^2$ 的系统性高估，因此也高估了界面位置 $s(t)$。\n\n**隐式方案：**\n隐式更新由 $s^{n+1} = s^n + \\Delta t \\frac{C}{s^{n+1}}$ 给出。这可以重新整理为关于 $s^{n+1}$ 的二次方程：\n$$\n(s^{n+1})^2 - s^n s^{n+1} - \\Delta t C = 0\n$$\n其解由二次求根公式给出：\n$$\ns^{n+1} = \\frac{s^n \\pm \\sqrt{(s^n)^2 + 4\\Delta t C}}{2}\n$$\n由于 $s^{n+1}$ 必须为正，我们必须选择 `+` 号。对于熔化情况（$C0$），平方根下的项 $(s^n)^2 + 4\\Delta t C$ 总是正的。因此，对于任何 $\\Delta t  0$，都保证存在一个唯一的、实数的、正的 $s^{n+1}$ 解。这意味着隐式方案对于熔化问题是无条件稳定的；对于稳定性没有时间步长 $\\Delta t$ 的上限。\n\n分析隐式方案的离散能量：\n对小 $\\Delta t$ 进行泰勒级数展开表明 $(s^{n+1})^2 \\approx (s^n)^2 + 2C\\Delta t - \\frac{(\\Delta t C)^2}{(s^n)^2}$。数值误差项为负，导致对能量 $s^2$ 和界面位置 $s(t)$ 的系统性低估。\n\n**比较总结：**\n- **显式方案**实现简单，但只是有条件稳定的。它需要 $\\Delta t \\le s_0^2/C$ 来保持单调性。它倾向于高估界面位置。\n- **隐式方案**需要在每一步求解一个二次方程，但对于熔化过程（$C0$）是无条件稳定的。它倾向于低估界面位置。其优越的稳定性使其更加鲁棒，尤其是在时间步长较大时。\n\n### 3. 时间步长限制\n\n如在稳定性分析中推导的，要求显式更新映射 $g(s)$ 是单调的，$g'(s) \\ge 0$，这导致了条件 $\\Delta t \\le s^2/C$。为了确保这个条件在整个模拟过程中都成立，它必须在最严格的点成立，即在 $t=0$ 处，$s=s_0$。这得出了最大允许时间步长：\n$$\n\\Delta t_{\\max} = \\frac{s_0^2}{C} = \\frac{s_0^2 \\rho L}{k(T_0 - T_m)}\n$$\n问题通过严格不等式 $\\Delta t  \\Delta t_{\\max}$ 来定义稳定性。\n\n对于凝固情况，其中 $T_0  T_m$ 且 $C  0$，显式方案的稳定性条件将源于保持 $s^{n+1}$ 为正的需要，导致 $\\Delta t  (s^n)^2/|C|$。由于 $s$ 减小，这个条件随时间变得更加严格。在这种情况下，隐式方案有一个存在实根的条件，$\\Delta t \\le (s^n)^2/(4|C|)$，这个条件更为苛刻。然而，当前问题是一个熔化问题，因此我们关注 $C0$ 的情况。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D Stefan problem using explicit and implicit schemes and compares\n    them to the exact solution.\n    \"\"\"\n    # Physically plausible parameters for a metal like aluminum\n    k = 200.0  # Thermal conductivity, W/(m.K)\n    rho = 2700.0  # Density, kg/m^3\n    L = 397000.0  # Latent heat of fusion, J/kg\n    Tm = 933.0  # Melting temperature, K\n    T0 = 1033.0  # Hot boundary temperature, K\n    s0 = 1.0e-3  # Interface initial position, m\n    t_end = 10.0  # Final time, s\n\n    # Calculate the Stefan problem constant C\n    C = k * (T0 - Tm) / (rho * L)\n\n    # Calculate the maximum stable time step for the explicit scheme\n    # The problem defines dt_max for both C>0 and C0. We use C because T0 > Tm.\n    dt_max = s0**2 / C\n\n    # Define the time steps for the three test cases\n    test_cases_dt = [\n        0.01,         # Case A: Happy path\n        dt_max,       # Case B: Boundary case\n        0.5           # Case C: Unstable/edge case\n    ]\n\n    results = []\n    \n    for dt in test_cases_dt:\n        # --- Explicit Scheme Simulation ---\n        s_exp = s0\n        current_t = 0.0\n        while current_t  t_end:\n            step_dt = min(dt, t_end - current_t)\n            if s_exp = 0: # Check for non-physical state\n                s_exp = -1.0 # Sentinel for failure\n                break\n            s_exp += step_dt * C / s_exp\n            current_t += step_dt\n        s_exp_final = s_exp\n\n        # --- Implicit Scheme Simulation ---\n        s_imp = s0\n        current_t = 0.0\n        while current_t  t_end:\n            step_dt = min(dt, t_end - current_t)\n            # Solve the quadratic equation for s_imp at n+1:\n            # (s_n+1)^2 - s_n * s_n+1 - dt * C = 0\n            # We take the positive root.\n            discriminant = s_imp**2 + 4 * step_dt * C\n            if discriminant  0:\n                s_imp = -1.0 # Sentinel for failure\n                break\n            s_imp = (s_imp + np.sqrt(discriminant)) / 2.0\n            current_t += step_dt\n        s_imp_final = s_imp\n\n        # --- Exact Solution ---\n        s_exact_final = np.sqrt(s0**2 + 2 * C * t_end)\n\n        # --- Stability and Error Calculation ---\n        # Stability is defined by the strict inequality dt  dt_max\n        stable_exp = dt  dt_max\n\n        # Relative errors\n        # Handle cases where simulations might have failed\n        if s_exp_final > 0:\n            e_exp = np.abs(s_exp_final - s_exact_final) / s_exact_final\n        else: # If simulation failed, error is considered infinite or large. Use a placeholder.\n            e_exp = np.inf\n\n        if s_imp_final > 0:\n            e_imp = np.abs(s_imp_final - s_exact_final) / s_exact_final\n        else:\n            e_imp = np.inf\n\n        results.extend([dt_max, stable_exp, e_exp, e_imp])\n\n    # Format the final output string as specified\n    # The map(str,...) will convert booleans to 'True'/'False'\n    # and floats to their string representation.\n    formatted_results = [f\"{x}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "超越简化模型，本实践将引导您实现一种功能强大且广泛应用于求解完整斯特凡问题的方法——焓法。该方法以焓作为主要守恒变量，将潜热自然地包含在内，从而巧妙地规避了显式追踪移动界面的复杂性。本练习聚焦于在保证能量守恒的有限体积法（FVM）框架下实现焓法，强调从焓中恢复温度和相分数等状态变量的关键技术，并验证离散格式的能量守恒特性。",
            "id": "3987456",
            "problem": "考虑一个一维平板，其长度为 $L_x$，具有均匀的横截面积 $A$、材料密度 $\\rho$、比热容 $c_p$、热导率 $k$ 以及熔化潜热 $L_h$。随温度变化的相分数 $\\phi(T)$ 由线性糊状区模型定义，其中固相线温度为 $T_s$，液相线温度为 $T_l$。当 $T \\le T_s$ 时，相分数满足 $\\phi(T)=0$；当 $T \\ge T_l$ 时，满足 $\\phi(T)=1$；当 $T_s  T  T_l$ 时，相分数线性变化，为 $\\phi(T)=(T-T_s)/(T_l-T_s)$。体积焓定义为 $H(T) = \\rho c_p T + \\rho L_h \\phi(T)$。热通量由傅里叶定律定义为 $q = -k \\frac{\\partial T}{\\partial x}$。\n\n从能量守恒出发，焓法将演化过程建模为 $\\frac{\\partial H}{\\partial t} + \\frac{\\partial q}{\\partial x} = 0$。使用有限体积法（FVM）将平板离散为 $N$ 个宽度为 $\\Delta x = L_x/N$ 的均匀控制体积。设 $H_i^n$ 表示在时间层 $n$ 时控制体积 $i$ 中的焓，并定义在面 $j=0,1,\\dots,N$ 上的面心通量 $q_{j}^n$，其中左边界（流入域内为正）的通量 $q_0^n$ 和右边界的通量 $q_N^n$ 是给定的。每个控制体积中焓的更新必须通过对面通量求和得到，该求和需与每个控制体积和时间步长 $\\Delta t$ 上的局部守恒相一致。具体而言，更新公式为 $H_i^{n+1} = H_i^n + \\frac{\\Delta t}{\\Delta x}(q_i^n - q_{i+1}^n)$。计算通量所需的温度必须通过对本构关系 $H(T)$ 在固相、糊状区和液相区进行分段反演从焓中恢复。\n\n您的任务是实现一个程序，该程序能够：\n- 使用均匀温度 $T_0$ 初始化平板，并为所有 $i$ 计算相应的初始焓 $H_i^0$。\n- 使用所述的焓法和 FVM 通量求和方法，将焓场 $H_i^n$推进指定的步数。该方法采用显式时间更新，使用从 $H_i^n$ 恢复的温度 $T_i^n$ 和中心差分来计算内界面梯度。\n- 在每个时间步 $n \\to n+1$，计算消耗或释放的总潜热，其公式为 $\\sum_i \\rho L_h \\left(\\phi_i^{n+1} - \\phi_i^n\\right) V_i$，其中 $V_i = A \\Delta x$。并记录符号约定：正值表示潜热消耗（熔化），负值表示潜热释放（凝固）。\n- 通过计算全局能量残差 $R^n$ 来验证离semasiology能量守恒。该残差定义为一个时间步内的净外部能量输入减去域内总焓的变化，即 $R^n = \\left(q_0^n - q_N^n\\right) A \\Delta t - \\sum_i \\left(H_i^{n+1} - H_i^n\\right) V_i$。报告在所有模拟时间步中残差绝对值的最大值。\n\n所有能量必须以焦耳（$J$）表示。所有温度必须以摄氏度（$^\\circ\\mathrm{C}$）表示。不使用角度。输出中没有百分比。\n\n使用以下参数集测试套件，以检验实现在熔化、凝固和无相变三种情况下的性能。在所有情况下，使用 $A=1$、$L_x=0.1$、$N=64$、$\\Delta t = 1.0$、$k=0.6$、$\\rho=1000$、$c_p=4200$、$L_h=334000$、$T_s=-1^\\circ\\mathrm{C}$、$T_l=1^\\circ\\mathrm{C}$，并模拟 $N_t=30$ 个时间步。对于所有情况，规定右边界通量 $q_N^n=0$。\n\n- 情况 1（熔化）：$T_0=-2^\\circ\\mathrm{C}$，对于所有 $n$，左边界通量 $q_0^n=50000$。\n- 情况 2（凝固）：$T_0=2^\\circ\\mathrm{C}$，对于所有 $n$，左边界通量 $q_0^n=-50000$。\n- 情况 3（无相变）：$T_0=-10^\\circ\\mathrm{C}$，对于所有 $n$，左边界通量 $q_0^n=1000$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每种情况，输出两个单位为 $J$ 的浮点数：首先是所有时间步中能量残差绝对值的最大值，其次是所有时间步中消耗（正值）或释放（负值）的总潜热之和。因此，最终输出的形式必须为 $\\left[ r_1, \\ell_1, r_2, \\ell_2, r_3, \\ell_3 \\right]$，其中 $r_i$ 和 $\\ell_i$ 分别是情况 $i$ 的残差和总潜热，单位为 $J$。",
            "solution": "用户提供的问题陈述已经过仔细验证，被确定为是合理、适定且具有科学依据的。它概述了一个经典的一维瞬态相变热传导问题，通常称为斯特凡问题（Stefan problem），将使用焓法和有限体积法（FVM）离散化来求解。所有参数、控制方程和边界条件都已提供，从而可以进行直接且明确的实现。\n\n该解决方案是遵循能量守恒原理和指定的数值方案开发的。主要步骤包括离散化控制方程、定义数值更新算法以及详细说明物理本构关系。\n\n**1. 控制方程和本构关系**\n\n基本原理是能量守恒，对于一维系统，其表述为：\n$$\n\\frac{\\partial H}{\\partial t} + \\frac{\\partial q}{\\partial x} = 0\n$$\n其中 $H$ 是体积焓（单位为 $\\mathrm{J}/\\mathrm{m}^3$），$q$ 是热通量（单位为 $\\mathrm{W}/\\mathrm{m}^2$），$t$ 是时间，$x$ 是空间坐标。\n\n问题指定了连接焓 $H$ 和温度 $T$ 这两个主要变量的本构关系：\n体积焓 $H(T)$ 是温度的函数，同时包含显热和潜热：\n$$\nH(T) = \\rho c_p T + \\rho L_h \\phi(T)\n$$\n这里，$\\rho$ 是密度，$c_p$ 是比热容，$L_h$ 是熔化潜热。相分数 $\\phi(T)$ 取决于固相线温度 $T_s$ 和液相线温度 $T_l$：\n$$\n\\phi(T) =\n\\begin{cases}\n    0  \\text{若 } T \\le T_s \\quad (\\text{固相}) \\\\\n    \\frac{T-T_s}{T_l-T_s}  \\text{若 } T_s  T  T_l \\quad (\\text{糊状区}) \\\\\n    1  \\text{若 } T \\ge T_l \\quad (\\text{液相})\n\\end{cases}\n$$\n热通量 $q$ 由傅里叶传导定律给出：\n$$\nq = -k \\frac{\\partial T}{\\partial x}\n$$\n其中 $k$ 是热导率。\n\n**2. 有限体积离散化和显式更新**\n\n长度为 $L_x$ 的区域被离散为 $N$ 个均匀的控制体积（CV），每个控制体积的宽度为 $\\Delta x = L_x/N$，体积为 $V_i = A \\Delta x$，其中 $A$ 是横截面积。我们将控制体积的索引设为 $i=0, \\dots, N-1$。控制体积的面的索引为 $j=0, \\dots, N$，其中面 $j=0$ 是左边界，面 $j=N$ 是右边界，内界面 $j=i+1$ 分隔了控制体积 $i$ 和 $i+1$。\n\n将控制方程在控制体积 $i$（从 $x_i$ 到 $x_{i+1}$）上以及在时间步长 $\\Delta t$（从 $t^n$ 到 $t^{n+1}$）上积分，得到积分形式的守恒定律：\n$$\n\\int_{x_i}^{x_{i+1}} \\left( H(t^{n+1}) - H(t^n) \\right) dx + \\int_{t^n}^{t^{n+1}} \\left( q(x_{i+1}) - q(x_i) \\right) dt = 0\n$$\n使用单元中心和时间步开始时的值（一种显式格式）来近似空间和时间积分，我们得到控制体积 $i$ 中平均焓 $H_i$ 的离散方程：\n$$\n(H_i^{n+1} - H_i^n)\\Delta x + (q_{i+1}^n - q_i^n)\\Delta t = 0\n$$\n其中 $q_i^n$ 和 $q_{i+1}^n$ 分别表示在时间层 $n$ 时控制体积 $i$ 的左、右界面上的通量。重新整理以求解更新后的焓 $H_i^{n+1}$：\n$$\nH_i^{n+1} = H_i^n + \\frac{\\Delta t}{\\Delta x} (q_i^n - q_{i+1}^n)\n$$\n问题定义了边界通量 $q_0^n$（左）和 $q_N^n$（右）。内界面通量使用中心差分来近似相邻单元中心之间的温度梯度进行计算：\n$$\nq_{i+1}^n \\approx -k \\frac{T_{i+1}^n - T_i^n}{\\Delta x} \\quad \\text{对于 } i = 0, \\dots, N-2\n$$\n\n**3. 焓-温反演**\n\n在每个时间步，必须从焓场 $H^n$ 中恢复温度场 $T^n$ 以计算通量。这需要对 $H(T)$ 关系进行反演。设 $H_s = \\rho c_p T_s$ 和 $H_l = \\rho c_p T_l + \\rho L_h$ 分别为固相点和液相点的焓。反演是分段进行的：\n- 如果 $H \\le H_s$（固相）：$\\phi=0$，因此 $H = \\rho c_p T \\implies T = H / (\\rho c_p)$。\n- 如果 $H \\ge H_l$（液相）：$\\phi=1$，因此 $H = \\rho c_p T + \\rho L_h \\implies T = (H - \\rho L_h) / (\\rho c_p)$。\n- 如果 $H_s  H  H_l$（糊状区）：相分数 $\\phi$ 与焓呈线性关系，$\\phi = (H - H_s) / (H_l - H_s)$。然后通过反演相分数的定义来恢复温度：$T = T_s + \\phi(T_l - T_s)$。这个两步过程（$H \\to \\phi \\to T$）在数值上是稳健的。\n\n**4. 数值算法和守恒性检验**\n\n模拟过程如下：\n1.  **初始化**：给定初始均匀温度 $T_0$，为所有控制体积 $i=0, \\dots, N-1$ 计算初始相分数 $\\phi_i^0$ 和焓 $H_i^0$。\n2.  **时间推进**：对于从 $0$ 到 $N_t-1$ 的每个时间步 $n$：\n    a.  存储当前的焓场 $H_i^n$ 和相分数场 $\\phi_i^n$。\n    b.  **恢复温度**：使用反演逻辑，为所有 $i$ 从 $H_i^n$ 计算 $T_i^n$。\n    c.  **计算通量**：计算所有面 $j=0, \\dots, N$ 上的通量 $q_j^n$。边界通量 $q_0^n$ 和 $q_N^n$ 是给定的，而内界面通量则根据温度场 $T^n$ 计算得出。\n    d.  **更新焓**：使用显式 FVM 更新公式，为所有 $i$ 计算新的焓场 $H_i^{n+1}$。\n    e.  **后处理**：\n        i.  从 $H_i^{n+1}$ 恢复新的相分数 $\\phi_i^{n+1}$。\n        ii. 计算该时间步的潜热生成/消耗：$\\Delta L^n = \\sum_i \\rho L_h (\\phi_i^{n+1} - \\phi_i^n) V_i$。\n        iii. 通过计算残差来检验离散能量守恒：$R^n = (q_0^n - q_N^n) A \\Delta t - \\sum_i (H_i^{n+1} - H_i^n) V_i$。由于公式的构造，该残差理论上为零，任何非零值都源于浮点运算的精度误差。记录整个模拟过程中 $R^n$ 的最大绝对值。\n3.  **报告**：完成给定测试用例的所有时间步后，报告最大绝对残差和累计的总潜热。对所有测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used.\n\ndef solve():\n    \"\"\"\n    Solves the 1D Stefan problem using the enthalpy method and FVM.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'T0': -2.0, 'q0': 50000.0},  # Case 1: melting\n        {'T0': 2.0, 'q0': -50000.0}, # Case 2: solidification\n        {'T0': -10.0, 'q0': 1000.0},   # Case 3: no phase change\n    ]\n\n    # Global parameters\n    A = 1.0         # Cross-sectional area (m^2)\n    Lx = 0.1        # Slab length (m)\n    N = 64          # Number of control volumes\n    dt = 1.0        # Time step (s)\n    k = 0.6         # Thermal conductivity (W/m-K)\n    rho = 1000.0    # Density (kg/m^3)\n    cp = 4200.0     # Specific heat capacity (J/kg-K)\n    Lh = 334000.0   # Latent heat of fusion (J/kg)\n    Ts = -1.0       # Solidus temperature (degC)\n    Tl = 1.0        # Liquidus temperature (degC)\n    Nt = 30         # Number of time steps\n    qN = 0.0        # Flux at right boundary (x=Lx)\n\n    # Derived parameters\n    dx = Lx / N\n    Vi = A * dx  # Volume of a control volume\n\n    # Enthalpy thresholds for phase change\n    H_s = rho * cp * Ts\n    H_l = rho * cp * Tl + rho * Lh\n    H_mushy_range = H_l - H_s\n\n    # Helper function for state recovery from enthalpy\n    def get_T_and_phi_from_H(H_arr):\n        T_arr = np.zeros_like(H_arr)\n        phi_arr = np.zeros_like(H_arr)\n\n        solid_mask = H_arr = H_s\n        liquid_mask = H_arr >= H_l\n        mushy_mask = (~solid_mask)  (~liquid_mask)\n\n        # Solid phase\n        phi_arr[solid_mask] = 0.0\n        T_arr[solid_mask] = H_arr[solid_mask] / (rho * cp)\n\n        # Liquid phase\n        phi_arr[liquid_mask] = 1.0\n        T_arr[liquid_mask] = (H_arr[liquid_mask] - rho * Lh) / (rho * cp)\n\n        # Mushy phase\n        phi_arr[mushy_mask] = (H_arr[mushy_mask] - H_s) / H_mushy_range\n        T_arr[mushy_mask] = Ts + phi_arr[mushy_mask] * (Tl - Ts)\n        \n        return T_arr, phi_arr\n\n    # Helper function for initialization\n    def get_H_and_phi_from_T(T_arr):\n        phi_arr = np.zeros_like(T_arr)\n\n        liquid_mask = T_arr >= Tl\n        mushy_mask = (T_arr > Ts)  (T_arr  Tl)\n\n        phi_arr[liquid_mask] = 1.0\n        phi_arr[mushy_mask] = (T_arr[mushy_mask] - Ts) / (Tl - Ts)\n        \n        H_arr = rho * cp * T_arr + rho * Lh * phi_arr\n        \n        return H_arr, phi_arr\n    \n    results = []\n    \n    for case in test_cases:\n        T0 = case['T0']\n        q0 = case['q0']\n    \n        # Initialization for the current case\n        T = np.full(N, T0)\n        H, _ = get_H_and_phi_from_T(T)\n\n        total_latent_heat = 0.0\n        max_abs_residual = 0.0\n\n        # Main time-stepping loop\n        for n in range(Nt):\n            H_old = H.copy()\n            \n            # Recover temperature and phase fraction from current enthalpy\n            T, phi_old = get_T_and_phi_from_H(H_old)\n            \n            # Compute fluxes at faces\n            q_faces = np.zeros(N + 1)\n            q_faces[0] = q0\n            q_faces[N] = qN\n            # Interior faces (j=1 to N-1)\n            q_faces[1:-1] = -k * (T[1:] - T[:-1]) / dx\n            \n            # Update enthalpy for all control volumes\n            H += (dt / dx) * (q_faces[:-1] - q_faces[1:])\n            \n            # Recover new phase fraction to calculate latent heat change\n            _, phi_new = get_T_and_phi_from_H(H)\n\n            # Calculate latent heat change for this step\n            latent_heat_step = np.sum(rho * Lh * (phi_new - phi_old) * Vi)\n            total_latent_heat += latent_heat_step\n\n            # Calculate the energy residual for this step\n            # Total change in enthalpy in the domain\n            total_enthalpy_change = np.sum((H - H_old) * Vi)\n            # Net energy input from boundaries\n            net_boundary_input = (q_faces[0] - q_faces[-1]) * A * dt\n            \n            residual = net_boundary_input - total_enthalpy_change\n            if abs(residual) > max_abs_residual:\n                max_abs_residual = abs(residual)\n                \n        results.extend([max_abs_residual, total_latent_heat])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}