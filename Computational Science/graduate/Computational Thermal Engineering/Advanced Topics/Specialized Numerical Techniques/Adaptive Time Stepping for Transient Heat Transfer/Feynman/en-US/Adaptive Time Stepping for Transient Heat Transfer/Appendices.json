{
    "hands_on_practices": [
        {
            "introduction": "Ensuring the physical realism of a simulation is paramount, especially when dealing with sharp thermal gradients introduced by boundary conditions or sources. This practice focuses on a fundamental aspect of robustness: preserving the discrete maximum principle. You will implement an adaptive algorithm that actively prevents non-physical temperature oscillations by monitoring spatial monotonicity and rejecting time steps that would violate it, providing a hands-on understanding of how to enforce solution stability .",
            "id": "3934707",
            "problem": "You are asked to design and implement an algorithm for one-dimensional transient heat conduction with an adaptive time stepping rule that preserves the discrete maximum principle and spatial monotonicity under a sharp boundary temperature jump. The underlying model is the transient heat equation, which must be derived and implemented from first principles without reliance on any built-in solver. The objective is to construct a test case that intentionally stresses the maximum principle and to develop an adaptive time stepping strategy that prevents non-physical oscillations and overshoot.\n\nThe physical model is the one-dimensional transient heat equation for temperature $T(x,t)$,\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2},\n$$\nwhere $\\alpha$ is the thermal diffusivity. The domain is a rod of length $L$ in meters with spatial coordinate $x \\in [0,L]$, initial temperature $T(x,0) = T_0$ in Kelvin, and time $t$ in seconds. The boundary conditions are Dirichlet (fixed temperature). At the left end, the temperature has a sudden step at time $t=0$ from $T_0$ to $T_1$, while the right end remains fixed at $T_0$; that is, $T(0,t) = T_1$ for all $t \\ge 0$ and $T(L,t) = T_0$ for all $t \\ge 0$. The thermal diffusivity $\\alpha$ must be expressed in $\\mathrm{m^2/s}$, $L$ in $\\mathrm{m}$, $t$ in $\\mathrm{s}$, and $T$ in $\\mathrm{K}$.\n\nYou must discretize the spatial domain into $N$ uniformly spaced nodes, including boundaries, with spacing $\\Delta x = L/(N-1)$, and use a simple explicit forward Euler time stepping with a centered second-order finite difference for the Laplacian. You must design an adaptive rule for the time step $\\Delta t$ that prevents violations of the discrete maximum principle and preserves monotonicity of the discrete temperature profile in space (non-increasing from $x=0$ to $x=L$ given $T_1 \\ge T_0$). The adaptive rule must adjust $\\Delta t$ based on local conditions of the discretized operator to ensure nonnegative mixing weights in the explicit update and must reject any proposed step that causes either overshoot beyond the boundary values or spatial monotonicity violation; rejected steps must be retried with a smaller $\\Delta t$.\n\nYour program must implement the following requirements:\n\n- Start from the fundamental conservation of energy and Fourier law to justify the model and the discretization, and implement the explicit update in time.\n- Implement Dirichlet boundary conditions $T(0,t) = T_1$ and $T(L,t) = T_0$, with the initial condition $T(x,0) = T_0$.\n- Use an adaptive time stepping rule that:\n  - Proposes a candidate $\\Delta t$,\n  - Ensures nonnegative coefficients in the explicit update,\n  - Rejects and halves $\\Delta t$ when either the discrete maximum principle or spatial monotonicity would be violated,\n  - Increases $\\Delta t$ cautiously after successful steps, but never beyond the limit that preserves nonnegative update weights.\n- Track, for the entire simulation, the worst monotonicity violation amplitude defined as\n  $$\n  \\max\\left(0, -\\min_i \\left(T_i - T_{i+1}\\right)\\right),\n  $$\n  where $T_i$ is the discrete temperature at node index $i$, and record the maximum of this quantity over time. This quantity must be reported in Kelvin.\n\nYou must run the solver for a set of four test cases. For each test case, you are given parameters $(L, N, \\alpha, T_0, T_1, t_{\\mathrm{final}}, \\Delta t_{\\mathrm{init}})$, where $t_{\\mathrm{final}}$ is the final time in seconds and $\\Delta t_{\\mathrm{init}}$ is the initial proposed time step in seconds. The test suite is:\n\n- Case 1: $L=0.02 \\, \\mathrm{m}$, $N=21$, $\\alpha=1\\times 10^{-5} \\, \\mathrm{m^2/s}$, $T_0=300 \\, \\mathrm{K}$, $T_1=600 \\, \\mathrm{K}$, $t_{\\mathrm{final}}=0.5 \\, \\mathrm{s}$, $\\Delta t_{\\mathrm{init}}=0.2 \\, \\mathrm{s}$.\n- Case 2: $L=0.02 \\, \\mathrm{m}$, $N=5$, $\\alpha=1\\times 10^{-4} \\, \\mathrm{m^2/s}$, $T_0=300 \\, \\mathrm{K}$, $T_1=600 \\, \\mathrm{K}$, $t_{\\mathrm{final}}=0.1 \\, \\mathrm{s}$, $\\Delta t_{\\mathrm{init}}=0.05 \\, \\mathrm{s}$.\n- Case 3: $L=0.1 \\, \\mathrm{m}$, $N=51$, $\\alpha=1\\times 10^{-6} \\, \\mathrm{m^2/s}$, $T_0=300 \\, \\mathrm{K}$, $T_1=800 \\, \\mathrm{K}$, $t_{\\mathrm{final}}=10.0 \\, \\mathrm{s}$, $\\Delta t_{\\mathrm{init}}=5.0 \\, \\mathrm{s}$.\n- Case 4: $L=0.02 \\, \\mathrm{m}$, $N=3$, $\\alpha=1\\times 10^{-3} \\, \\mathrm{m^2/s}$, $T_0=300 \\, \\mathrm{K}$, $T_1=600 \\, \\mathrm{K}$, $t_{\\mathrm{final}}=0.01 \\, \\mathrm{s}$, $\\Delta t_{\\mathrm{init}}=0.1 \\, \\mathrm{s}$.\n\nYour program must output, for each case, the maximum spatial monotonicity violation amplitude in Kelvin observed during the simulation. The final output must be a single line containing a comma-separated list enclosed in square brackets, with each result rounded to six decimal places, for example, $[r_1,r_2,r_3,r_4]$, where each $r_i$ is a float in $\\mathrm{K}$.\n\nAll computations must be performed in the specified units. Angles are not involved. Percentages must not be used.\n\nYour implementation must be a complete, runnable program. It must not read any external input and must not produce any output other than the required single-line list.",
            "solution": "The problem requires the design and implementation of an adaptive time-stepping algorithm for the one-dimensional transient heat equation. The algorithm must preserve the discrete maximum principle and spatial monotonicity of the solution under a sharp jump in a Dirichlet boundary condition.\n\n### Principle-Based Derivation and Discretization\n\nThe physical process is governed by the one-dimensional transient heat equation:\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\nwhere $T(x,t)$ is the temperature in Kelvin at position $x \\in [0,L]$ and time $t \\ge 0$, and $\\alpha$ is the thermal diffusivity in $\\mathrm{m^2/s}$. This equation is derived by combining the principle of conservation of energy with Fourier's law of heat conduction. Conservation of energy for a one-dimensional control volume states that the rate of change of internal energy is equal to the net rate of heat flow into it, $\\rho c_p \\frac{\\partial T}{\\partial t} = -\\frac{\\partial q}{\\partial x}$, where $q$ is the heat flux, $\\rho$ is the density, and $c_p$ is the specific heat capacity. Fourier's law states that heat flux is proportional to the negative temperature gradient, $q = -k \\frac{\\partial T}{\\partial x}$, where $k$ is the thermal conductivity. Combining these yields the heat equation with $\\alpha = k/(\\rho c_p)$.\n\nTo solve this equation numerically, we discretize the spatial domain and time. The spatial domain $x \\in [0,L]$ is divided into $N$ uniformly spaced nodes, $x_i = i \\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/(N-1)$. The temperature at node $i$ and time step $n$ is denoted by $T_i^n$.\n\nThe second-order spatial derivative is approximated using a second-order centered finite difference scheme:\n$$\n\\frac{\\partial^2 T}{\\partial x^2}\\bigg|_{x_i, t^n} \\approx \\frac{T_{i-1}^n - 2T_i^n + T_{i+1}^n}{(\\Delta x)^2}\n$$\nThe time derivative is approximated using the explicit forward Euler method:\n$$\n\\frac{\\partial T}{\\partial t}\\bigg|_{x_i, t^n} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t}\n$$\nwhere $\\Delta t = t^{n+1} - t^n$ is the time step. Substituting these approximations into the heat equation gives the fully discretized explicit update rule for any interior node $i \\in \\{1, \\dots, N-2\\}$:\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\frac{T_{i-1}^n - 2T_i^n + T_{i+1}^n}{(\\Delta x)^2}\n$$\nRearranging for the temperature at the next time step, $T_i^{n+1}$, we get:\n$$\nT_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{(\\Delta x)^2} (T_{i-1}^n - 2T_i^n + T_{i+1}^n)\n$$\n\n### Stability and the Discrete Maximum Principle\n\nLet's define the dimensionless Fourier number, $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$. The update equation can be rewritten as:\n$$\nT_i^{n+1} = s T_{i-1}^n + (1 - 2s) T_i^n + s T_{i+1}^n\n$$\nThe Discrete Maximum Principle (DMP) states that the temperature at a point $(x_i, t^{n+1})$ cannot be greater than the maximum temperature in the domain at time $t^n$, nor less than the minimum. For this to hold, $T_i^{n+1}$ must be a convex combination of the temperatures at the previous time step, which requires all coefficients in the update equation to be non-negative. Since $\\alpha$, $\\Delta t$, and $(\\Delta x)^2$ are positive, $s \\ge 0$. The sole remaining condition is:\n$$\n1 - 2s \\ge 0 \\implies s \\le \\frac{1}{2}\n$$\nThis gives the conditional stability limit for the forward Euler scheme:\n$$\n\\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\le \\frac{1}{2} \\implies \\Delta t \\le \\frac{(\\Delta x)^2}{2\\alpha}\n$$\nWe denote this maximum allowable time step as $\\Delta t_{\\mathrm{max}}$. If $\\Delta t > \\Delta t_{\\mathrm{max}}$, the coefficient $(1-2s)$ becomes negative, allowing $T_i^{n+1}$ to fall outside the range defined by its neighbors, leading to non-physical oscillations (overshoot and undershoot). This violates both the DMP and spatial monotonicity.\n\n### Adaptive Time-Stepping Algorithm Design\n\nThe problem specifies initial conditions that are designed to violate the stability criterion if a large, fixed time step is chosen. The temperature profile starts uniform at $T_0$, but the boundary at $x=0$ is instantaneously raised to $T_1$. An adaptive algorithm is required to manage the time step $\\Delta t$ to ensure a physically correct solution at all times.\n\nThe algorithm proceeds as follows:\n1.  **Initialization**: Discretize the domain, setting $\\Delta x = L/(N-1)$. Initialize the temperature array $T$ to $T_0$. Apply the boundary conditions: $T_0 \\leftarrow T_1$ and $T_{N-1} \\leftarrow T_0$. Set the current time $t=0.0$ and initialize the trial time step $\\Delta t$ to $\\Delta t_{\\mathrm{init}}$. Calculate the stability limit $\\Delta t_{\\mathrm{max}} = (\\Delta x)^2 / (2\\alpha)$. Initialize a variable `max_violation` to $0.0$.\n\n2.  **Time Evolution Loop**: The simulation runs in a loop while $t < t_{\\mathrm{final}}$. In each iteration, a time step is attempted.\n\n3.  **Step Rejection Sub-Loop**: To ensure each step is valid, an inner loop is used:\n    a. A candidate time step $\\Delta t_{\\mathrm{cand}}$ is proposed. For the first step in the simulation, this is $\\Delta t_{\\mathrm{init}}$. For subsequent steps, it is based on the previously successful step. Care is taken not to step past $t_{\\mathrm{final}}$.\n    b. A candidate temperature profile for the next time step, $T_{\\mathrm{cand}}$, is computed using the explicit update rule with $\\Delta t_{\\mathrm{cand}}$.\n    c. The candidate profile $T_{\\mathrm{cand}}$ is validated against two criteria:\n        i. **Maximum Principle Violation**: Check if any temperature value falls outside the initial range $[T_0, T_1]$. This is checked by testing if $\\max(T_{\\mathrm{cand}}) > T_1$ or $\\min(T_{\\mathrm{cand}}) < T_0$. (Assuming $T_1 \\ge T_0$).\n        ii. **Spatial Monotonicity Violation**: For the given boundary conditions ($T_1 \\ge T_0$), the temperature profile must be non-increasing with $x$. A violation occurs if $T_i < T_{i+1}$ for any node index $i$.\n    d. **Decision**: If either validation check fails, the candidate step is rejected. $\\Delta t_{\\mathrm{cand}}$ is halved ($\\Delta t_{\\mathrm{cand}} \\leftarrow \\Delta t_{\\mathrm{cand}} / 2$), and the sub-loop repeats. This process guarantees that an acceptable, smaller time step will eventually be found.\n    e. If both checks pass, the step is accepted. The inner loop terminates.\n\n4.  **State Update**: Once a valid step $\\Delta t_{\\mathrm{cand}}$ is found, the simulation state is updated:\n    a. The current temperature profile is set to the accepted candidate profile: $T \\leftarrow T_{\\mathrm{cand}}$.\n    b. The simulation time is advanced: $t \\leftarrow t + \\Delta t_{\\mathrm{cand}}$.\n    c. The time step for the *next* iteration is proposed by cautiously increasing the current successful step, for instance, by a factor of $1.2$. However, this proposed step is strictly capped by $\\Delta t_{\\mathrm{max}}$ to proactively enforce stability. So, $\\Delta t_{\\mathrm{next}} \\leftarrow \\min(1.2 \\times \\Delta t_{\\mathrm{cand}}, \\Delta t_{\\mathrm{max}})$.\n\n5.  **Metric Tracking**: The problem asks to track the maximum monotonicity violation. Since the algorithm rejects any step that *would cause* a violation, the temperature profiles that are accepted will, by design, exhibit no monotonicity violation. The metric $\\max\\left(0, -\\min_i \\left(T_i - T_{i+1}\\right)\\right)$ is calculated on each accepted state. For a correctly implemented algorithm, this value should be zero (or a value on the order of machine precision, which for practical purposes is zero), as any profile with $T_i < T_{i+1}$ would have been rejected. The maximum value of this metric over the entire simulation is therefore expected to be zero, confirming the algorithm's correctness.\n\nThis adaptive strategy ensures that even with a challenging initial time step, the simulation automatically reduces the step size to resolve the sharp initial transient near the boundary and then increases it as the solution smooths out, providing an efficient and robust solution.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(L, N, alpha, T0, T1, t_final, dt_init):\n    \"\"\"\n    Solves the 1D transient heat equation with an adaptive time step\n    that enforces the discrete maximum principle and spatial monotonicity.\n\n    Args:\n        L (float): Length of the rod (m).\n        N (int): Number of spatial nodes.\n        alpha (float): Thermal diffusivity (m^2/s).\n        T0 (float): Initial temperature and right boundary temperature (K).\n        T1 (float): Left boundary temperature (K).\n        t_final (float): Final simulation time (s).\n        dt_init (float): Initial time step (s).\n\n    Returns:\n        float: The maximum spatial monotonicity violation amplitude observed.\n    \"\"\"\n    # 1. Discretization and Initialization\n    if N < 2:\n        return 0.0  # Not enough nodes for a meaningful simulation\n        \n    x = np.linspace(0, L, N)\n    dx = L / (N - 1)\n    \n    # Set initial temperature profile at t=0\n    T = np.full(N, T0, dtype=np.float64)\n    # Apply boundary condition at x=0 for t>=0\n    T[0] = T1\n    # Boundary at x=L is already at T0\n    \n    t = 0.0\n    dt_current_proposal = dt_init\n    \n    # 2. Stability Limit\n    # The explicit scheme is stable for s = alpha * dt / dx**2 <= 0.5\n    # The time step must not exceed this physical limit.\n    dt_max = (dx**2) / (2.0 * alpha)\n    \n    max_monotonicity_violation = 0.0\n    \n    # Assumption based on problem statement\n    temp_min, temp_max = min(T0, T1), max(T0, T1)\n    \n    # 3. Time Loop\n    while t < t_final:\n        # 4. Adaptive Time Stepping Logic (Rejection Loop)\n        dt_proposed = min(dt_current_proposal, t_final - t) # Do not step over t_final\n\n        while True:\n            # If the time step becomes excessively small, break to prevent infinite loops.\n            if dt_proposed < 1e-15:\n                break\n                \n            # Propose the next state T_next\n            T_next = np.copy(T)\n            \n            # Explicit forward Euler update for interior nodes\n            # Using vectorization for performance\n            s = alpha * dt_proposed / (dx**2)\n            T_next[1:-1] = T[1:-1] + s * (T[2:] - 2 * T[1:-1] + T[:-2])\n            \n            # Boundary conditions are fixed (Dirichlet)\n            T_next[0] = T1\n            T_next[-1] = T0\n            \n            # --- Validation Checks ---\n            # Check 1: Maximum Principle Violation (Overshoot/Undershoot)\n            # The temperature should stay within the initial boundary limits.\n            max_principle_violation = np.any(T_next[1:-1] > temp_max) or np.any(T_next[1:-1] < temp_min)\n            \n            # Check 2: Spatial Monotonicity Violation\n            # For T1 >= T0, temperature should be non-increasing from left to right.\n            # Violation occurs if T_i < T_{i+1} for any i.\n            diffs = T_next[:-1] - T_next[1:]\n            monotonicity_violation_check = np.any(diffs < 0)\n            \n            if max_principle_violation or monotonicity_violation_check:\n                # REJECT step: The proposed step is too large. Halve it and retry.\n                dt_proposed /= 2.0\n            else:\n                # ACCEPT step: The step is valid.\n                break # Exit the rejection loop\n        \n        # If dt became too small, we end the simulation for this case.\n        if dt_proposed < 1e-15:\n            break\n            \n        # 5. Update State\n        dt_accepted = dt_proposed\n        T = T_next\n        t += dt_accepted\n        \n        # 6. Track Metrics on the accepted state\n        # The problem requires tracking the violation metric. By design of the\n        # rejection algorithm, this value should be zero on all accepted states.\n        diffs = T[:-1] - T[1:]\n        if diffs.size > 0:\n            current_violation = max(0.0, -np.min(diffs))\n            if current_violation > max_monotonicity_violation:\n                max_monotonicity_violation = current_violation\n        \n        # 7. Propose dt for the *next* iteration\n        # Cautiously increase step size, but never beyond the theoretical max.\n        dt_current_proposal = min(dt_accepted * 1.2, dt_max)\n\n    return max_monotonicity_violation\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (L, N, alpha, T0, T1, t_final, dt_init)\n        (0.02, 21, 1e-5, 300.0, 600.0, 0.5, 0.2),\n        (0.02, 5, 1e-4, 300.0, 600.0, 0.1, 0.05),\n        (0.1, 51, 1e-6, 300.0, 800.0, 10.0, 5.0),\n        (0.02, 3, 1e-3, 300.0, 600.0, 0.01, 0.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        violation = run_simulation(*case)\n        results.append(f\"{violation:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n# Run the solver\nsolve()\n```"
        },
        {
            "introduction": "Beyond stability, a key goal of adaptive time-stepping is to achieve a desired level of accuracy efficiently. This exercise moves from robustness to precision by using an embedded Runge-Kutta method to estimate the local truncation error at each step. You will build a controller that adjusts the time step to meet a specified error tolerance and then verify the algorithm's theoretical convergence rates, linking practical implementation with fundamental numerical analysis .",
            "id": "3934689",
            "problem": "Consider a one-dimensional homogeneous rod of length $L$ with thermal diffusivity $\\alpha$ undergoing transient heat conduction with Dirichlet boundary conditions. The governing equation is the heat equation, expressed as the partial differential equation\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2},\n$$\nfor $x \\in [0,L]$ and $t \\ge 0$, with boundary conditions $T(0,t) = 0$ and $T(L,t) = 0$ for all $t$, and initial condition $T(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right)$. The exact solution for these conditions is\n$$\nT_{\\text{exact}}(x,t) = e^{-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t} \\sin\\left(\\frac{\\pi x}{L}\\right).\n$$\nSpatially discretize the domain using a uniform grid with $N$ nodes and spacing $\\Delta x = \\frac{L}{N-1}$, and approximate spatial derivatives with the second-order central difference. This produces a semi-discrete ordinary differential equation system for the interior nodes (excluding the Dirichlet boundaries):\n$$\n\\frac{d\\mathbf{y}(t)}{dt} = \\mathbf{f}(\\mathbf{y}(t)) = \\alpha \\frac{1}{\\Delta x^2} \\left( \\mathbf{P}\\mathbf{y}(t) \\right),\n$$\nwhere $\\mathbf{y}(t) \\in \\mathbb{R}^{N-2}$ is the vector of temperatures at the interior nodes, and $\\mathbf{P}$ is the discrete Laplacian operator with homogeneous Dirichlet conditions.\n\nConstruct a time integration algorithm over the interval $t \\in [0, t_f]$ using an explicit second-order method with an embedded first-order method to estimate the local truncation error per step. Use the Euclidean norm for the error over the temperature vector $\\mathbf{y}$, and treat the norm as having units of Kelvin. Design an adaptive time step controller that targets a specified per-step error tolerance $\\mathrm{tol}$, enforcing step acceptance only when the estimated local error norm is less than or equal to $\\mathrm{tol}$. Incorporate a minimum time step $\\Delta t_{\\min}$ and a maximum time step $\\Delta t_{\\max}$ that respects explicit stability for the heat equation. If at $\\Delta t_{\\min}$ the estimated local error remains above $\\mathrm{tol}$, accept the step to avoid deadlock, and continue with $\\Delta t_{\\min}$.\n\nFor each simulation, compute:\n- The number of accepted time steps $N_{\\text{steps}}$ taken to reach $t_f$.\n- The global Euclidean norm error at $t_f$, defined by\n$$\nE_{\\text{final}} = \\left\\| \\mathbf{y}(t_f) - \\mathbf{y}_{\\text{exact}}(t_f) \\right\\|_2,\n$$\nwhere $\\mathbf{y}_{\\text{exact}}(t_f)$ is obtained by evaluating $T_{\\text{exact}}(x_i,t_f)$ at the interior grid points.\n\nDesign a test where you verify convergence rates by halving tolerances and observing both the step counts and final errors. Specifically, run paired simulations with tolerance values $(\\mathrm{tol}_1, \\mathrm{tol}_2)$ where $\\mathrm{tol}_2 = \\frac{1}{2}\\mathrm{tol}_1$, and compare the ratios\n$$\nR_{\\text{steps}} = \\frac{N_{\\text{steps}}(\\mathrm{tol}_2)}{N_{\\text{steps}}(\\mathrm{tol}_1)}, \\quad\nR_{\\text{error}} = \\frac{E_{\\text{final}}(\\mathrm{tol}_2)}{E_{\\text{final}}(\\mathrm{tol}_1)}.\n$$\nFor a second-order method controlled by an embedded first-order error estimate, the expected behavior (in the regime where the controller determines the time step and does not saturate at either $\\Delta t_{\\min}$ or $\\Delta t_{\\max}$) is that $R_{\\text{steps}}$ should be approximately $\\sqrt{2}$ and $R_{\\text{error}}$ should be approximately $\\frac{1}{2}$.\n\nUse the following fixed physical and numerical parameters:\n- Rod length: $L = 1 \\, \\mathrm{m}$.\n- Number of spatial nodes: $N = 50$.\n- Final time: $t_f = 1.0 \\, \\mathrm{s}$.\n- Minimum time step: $\\Delta t_{\\min} = 10^{-3} \\, \\mathrm{s}$.\n- Maximum time step: $\\Delta t_{\\max}$ set to $0.9$ times the explicit stability limit, i.e.,\n$$\n\\Delta t_{\\max} = 0.9 \\cdot \\frac{\\Delta x^2}{2 \\alpha}.\n$$\n\nImplement the adaptive controller and run the following test suite of parameter pairs, where each test case is a pair $(\\alpha, \\mathrm{tol}_1, \\mathrm{tol}_2)$:\n1. $(\\alpha = 10^{-4} \\, \\mathrm{m^2/s}, \\mathrm{tol}_1 = 10^{-4} \\, \\mathrm{K}, \\mathrm{tol}_2 = 5 \\times 10^{-5} \\, \\mathrm{K})$ — general case where the controller operates away from bounds.\n2. $(\\alpha = 10^{-4} \\, \\mathrm{m^2/s}, \\mathrm{tol}_1 = 10^{-10} \\, \\mathrm{K}, \\mathrm{tol}_2 = 5 \\times 10^{-11} \\, \\mathrm{K})$ — edge case expected to saturate at $\\Delta t_{\\min}$.\n3. $(\\alpha = 10^{-3} \\, \\mathrm{m^2/s}, \\mathrm{tol}_1 = 10^{-4} \\, \\mathrm{K}, \\mathrm{tol}_2 = 5 \\times 10^{-5} \\, \\mathrm{K})$ — higher diffusivity to probe different stiffness and controller scaling.\n\nFor each test case, compute booleans indicating whether the observed ratios meet expectations within specified tolerances:\n- Report $b_{\\text{steps}}$ as $\\text{True}$ if $\\left|\\frac{R_{\\text{steps}} - \\sqrt{2}}{\\sqrt{2}}\\right| \\le 0.10$, otherwise $\\text{False}$.\n- Report $b_{\\text{error}}$ as $\\text{True}$ if $\\left|\\frac{R_{\\text{error}} - \\frac{1}{2}}{\\frac{1}{2}}\\right| \\le 0.20$, otherwise $\\text{False}$.\n\nYour program should produce a single line of output containing the six booleans, ordered by test case and metric as a comma-separated list enclosed in square brackets (e.g., \"[b1,b2,b3,b4,b5,b6]\"), where for each test case the first boolean corresponds to $b_{\\text{steps}}$ and the second to $b_{\\text{error}}$. All quantities involving time must be expressed in seconds, and all error norms must be considered in Kelvin. No angles are involved.",
            "solution": "The problem requires the construction and verification of an adaptive time-stepping algorithm for solving the one-dimensional transient heat equation. The solution is developed by following established principles of numerical analysis for partial differential equations (PDEs), specifically the method of lines combined with an embedded Runge-Kutta scheme for temporal integration.\n\n### 1. Semi-Discretization using the Method of Lines\n\nThe governing PDE is\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2}\n$$\nfor $x \\in [0, L]$ and $t \\ge 0$. The first step is to transform this single PDE into a system of coupled ordinary differential equations (ODEs) in time. This is achieved through the method of lines, where we discretize the spatial domain and approximate the spatial derivatives.\n\nA uniform grid is defined with $N$ nodes, such that the spatial coordinates are $x_i = i \\cdot \\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/(N-1)$. Let $T_i(t) = T(x_i, t)$ be the temperature at node $i$. The second spatial derivative at an interior node $x_i$ (where $i=1, \\dots, N-2$) is approximated using a second-order central difference stencil:\n$$\n\\frac{\\partial^2 T}{\\partial x^2}\\bigg|_{x=x_i} \\approx \\frac{T_{i-1}(t) - 2T_i(t) + T_{i+1}(t)}{\\Delta x^2}.\n$$\nSubstituting this into the heat equation for each interior node yields a system of $N-2$ ODEs:\n$$\n\\frac{d T_i(t)}{dt} = \\frac{\\alpha}{\\Delta x^2} \\left( T_{i-1}(t) - 2T_i(t) + T_{i+1}(t) \\right).\n$$\nThe boundary conditions are $T(0,t) = T_0(t) = 0$ and $T(L,t) = T_{N-1}(t) = 0$. These values are incorporated into the equations for the first and last interior nodes ($i=1$ and $i=N-2$).\n\nThis system can be written in matrix form as $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$, where $\\mathbf{y}(t) = [T_1(t), T_2(t), \\dots, T_{N-2}(t)]^T$ is the vector of temperatures at the interior nodes. The function $\\mathbf{f}(\\mathbf{y})$ represents the right-hand side, which is a linear operation $\\frac{\\alpha}{\\Delta x^2} \\mathbf{P} \\mathbf{y}$, where $\\mathbf{P}$ is the $(N-2) \\times (N-2)$ tridiagonal matrix representing the discrete Laplacian with homogeneous Dirichlet boundary conditions:\n$$\n\\mathbf{P} = \\begin{pmatrix}\n-2 & 1 & 0 & \\dots \\\\\n1 & -2 & 1 & \\dots \\\\\n0 & 1 & -2 & \\dots \\\\\n\\vdots & & \\ddots & & 1 \\\\\n\\dots & 0 & 1 & -2\n\\end{pmatrix}.\n$$\n\n### 2. Adaptive Time Integration with an Embedded Method\n\nTo solve the ODE system $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ from an initial state $\\mathbf{y}(0)$, we use an adaptive time-stepping method. This requires an integrator that can provide an estimate of the local truncation error at each step. An embedded Runge-Kutta method is ideal for this purpose. We select the Heun-Euler pair, which is of order $(2,1)$.\n\nAt each time step from $t_n$ to $t_{n+1} = t_n + \\Delta t$, we compute two approximations for the solution $\\mathbf{y}_{n+1}$:\n1.  **First-order (Forward Euler) solution, $\\hat{\\mathbf{y}}_{n+1}$**:\n    $$\n    \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n)\n    $$\n    $$\n    \\hat{\\mathbf{y}}_{n+1} = \\mathbf{y}_n + \\Delta t \\, \\mathbf{k}_1\n    $$\n2.  **Second-order (Heun's method) solution, $\\mathbf{y}_{n+1}$**:\n    $$\n    \\mathbf{k}_2 = \\mathbf{f}(\\hat{\\mathbf{y}}_{n+1}) = \\mathbf{f}(\\mathbf{y}_n + \\Delta t \\, \\mathbf{k}_1)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{2} (\\mathbf{k}_1 + \\mathbf{k}_2)\n    $$\n\nThe difference between these two solutions provides an estimate of the local truncation error of the lower-order method. We use this as a proxy for the error of the higher-order method. The error estimate vector is $\\mathbf{e}_{n+1} = \\mathbf{y}_{n+1} - \\hat{\\mathbf{y}}_{n+1}$, and its Euclidean norm, $E_{\\text{local}} = \\|\\mathbf{e}_{n+1}\\|_2$, is used for step-size control.\n\n### 3. Step-Size Control Algorithm\n\nThe core of the adaptive algorithm is the controller that adjusts the time step $\\Delta t$ to meet a prescribed local error tolerance, $\\mathrm{tol}$.\n\n- **Step Acceptance/Rejection**: After computing $E_{\\text{local}}$, the step is accepted if $E_{\\text{local}} \\le \\mathrm{tol}$. If the step is accepted, the time is advanced ($t_{n+1} = t_n + \\Delta t$) and the solution is updated ($\\mathbf{y}_{n+1}$ becomes the new $\\mathbf{y}_n$). If $E_{\\text{local}} > \\mathrm{tol}$, the step is rejected, time is not advanced, and the step is retried with a smaller $\\Delta t$.\n- **Step-Size Update**: The new time step, $\\Delta t_{\\text{new}}$, is calculated based on the error from the current attempt. For a method of order $p+1$ controlled by an embedded method of order $p$ (here, $p=1$), the optimal step size scales with the error as:\n$$\n\\Delta t_{\\text{new}} = S \\cdot \\Delta t_{\\text{current}} \\left( \\frac{\\mathrm{tol}}{E_{\\text{local}}} \\right)^{\\frac{1}{p+1}},\n$$\nwhere $S$ is a safety factor (typically $0.8$ - $0.9$) to prevent overly optimistic step-size increases. We choose $S=0.9$ and $p=1$, yielding:\n$$\n\\Delta t_{\\text{new}} = 0.9 \\cdot \\Delta t_{\\text{current}} \\sqrt{\\frac{\\mathrm{tol}}{E_{\\text{local}}}}.\n$$\nThis formula is used to compute the step size for the next attempt, whether the current one was accepted or rejected.\n- **Constraints**: The calculated $\\Delta t$ is clipped to lie within the range $[\\Delta t_{\\min}, \\Delta t_{\\max}]$. The minimum step size, $\\Delta t_{\\min}$, prevents the algorithm from taking excessively small steps, while the maximum, $\\Delta t_{\\max}$, is determined by the explicit stability limit of the heat equation: $\\Delta t_{\\text{stable}} = \\Delta x^2/(2\\alpha)$. We use $\\Delta t_{\\max} = 0.9 \\cdot \\Delta t_{\\text{stable}}$.\n- **Deadlock Avoidance**: The problem specifies that if the current step size is at or below $\\Delta t_{\\min}$ and the error still exceeds $\\mathrm{tol}$, the step must be accepted to prevent the simulation from stalling. This is implemented by modifying the acceptance condition to `if E_local <= tol or dt <= dt_min`.\n\n### 4. Verification of Convergence Rates\n\nThe effectiveness of the adaptive controller is verified by testing its convergence properties. The theory of adaptive integrators suggests that for a $p$-th order main method, the global error should be proportional to the tolerance, $E_{\\text{global}} \\propto \\mathrm{tol}$. Furthermore, the average step size $\\Delta t$ should be proportional to $\\mathrm{tol}^{1/(p+1)}$.\n\nFor our second-order method ($p=1$ controlling $p+1=2$), we expect:\n-   **Global Error**: $E_{\\text{final}} \\propto \\mathrm{tol}$. Halving the tolerance ($\\mathrm{tol}_2 = \\frac{1}{2}\\mathrm{tol}_1$) should halve the final error, so the ratio $R_{\\text{error}} = \\frac{E_{\\text{final}}(\\mathrm{tol}_2)}{E_{\\text{final}}(\\mathrm{tol}_1)}$ should be approximately $\\frac{1}{2}$.\n-   **Step Count**: The average time step $\\Delta t$ is proportional to $\\mathrm{tol}^{1/2}$. The number of steps $N_{\\text{steps}}$ to cover a fixed interval $[0, t_f]$ is inversely proportional to the average step size, so $N_{\\text{steps}} \\propto 1/\\Delta t \\propto \\mathrm{tol}^{-1/2}$. Halving the tolerance should therefore increase the step count by a factor of $(1/2)^{-1/2} = \\sqrt{2}$. The ratio $R_{\\text{steps}} = \\frac{N_{\\text{steps}}(\\mathrm{tol}_2)}{N_{\\text{steps}}(\\mathrm{tol}_1)}$ should be approximately $\\sqrt{2}$.\n\nThe implementation will simulate the system for pairs of tolerances $(\\mathrm{tol}_1, \\mathrm{tol}_2)$ and check if these theoretical ratios are met within the specified relative error bounds, confirming the correct behavior of the adaptive algorithm. Cases where the controller saturates at $\\Delta t_{\\min}$ or $\\Delta t_{\\max}$ are not expected to follow these scaling laws.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef run_simulation(alpha, tol, L, N, tf, dt_min):\n    \"\"\"\n    Solves the 1D heat equation with an adaptive step-size controller.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        tol (float): Per-step error tolerance.\n        L (float): Length of the rod.\n        N (int): Number of spatial nodes.\n        tf (float): Final time.\n        dt_min (float): Minimum allowed time step.\n\n    Returns:\n        tuple: (number of accepted steps, final global error).\n    \"\"\"\n    dx = L / (N - 1)\n    dt_max = 0.9 * (dx ** 2) / (2 * alpha)\n    \n    # Interior spatial grid\n    x_interior = np.linspace(dx, L - dx, N - 2)\n    \n    # Initial condition for interior nodes\n    y = np.sin(np.pi * x_interior / L)\n    \n    # Pre-calculate constant for RHS evaluation\n    C = alpha / (dx ** 2)\n    \n    def f(y_vec):\n        \"\"\"Computes the RHS of the ODE system dy/dt = f(y).\"\"\"\n        # Pad with zero Dirichlet boundary conditions\n        y_full = np.zeros(N)\n        y_full[1:-1] = y_vec\n        # Central difference approximation\n        dydt = C * (y_full[:-2] - 2 * y_full[1:-1] + y_full[2:])\n        return dydt\n\n    t = 0.0\n    dt = dt_min  # Start with a conservative step size\n    n_steps = 0\n    safety_factor = 0.9\n\n    while t < tf:\n        # Ensure the final step lands exactly on tf\n        if t + dt > tf:\n            dt = tf - t\n\n        # Heun-Euler embedded pair\n        k1 = f(y)\n        y_euler = y + dt * k1\n        k2 = f(y_euler)\n        y_heun = y + (dt / 2.0) * (k1 + k2)\n        \n        # Estimate local error\n        error_norm = np.linalg.norm(y_heun - y_euler)\n        # Avoid division by zero if error is nil\n        if error_norm < 1e-16:\n            error_norm = 1e-16\n\n        # Step acceptance condition\n        accept_step = (error_norm <= tol) or (dt <= dt_min)\n\n        if accept_step:\n            t += dt\n            y = y_heun\n            n_steps += 1\n        \n        # Calculate new step size for the next attempt (or next step)\n        # Based on the error of the current attempt, regardless of acceptance\n        dt_new = safety_factor * dt * (tol / error_norm)**0.5\n        \n        # Clip the new step size to the defined bounds\n        dt = min(dt_max, max(dt_min, dt_new))\n\n    # Compute final global error against the exact solution\n    y_exact_tf = np.exp(-alpha * (np.pi/L)**2 * tf) * np.sin(np.pi * x_interior / L)\n    E_final = np.linalg.norm(y - y_exact_tf)\n    \n    return n_steps, E_final\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n    # Fixed physical and numerical parameters\n    L = 1.0\n    N = 50\n    tf = 1.0\n    dt_min = 1.0e-3\n\n    # Test suite: (alpha, tol_1, tol_2)\n    test_cases = [\n        (1.0e-4, 1.0e-4, 5.0e-5),\n        (1.0e-4, 1.0e-10, 5.0e-11),\n        (1.0e-3, 1.0e-4, 5.0e-5),\n    ]\n\n    all_booleans = []\n\n    for alpha, tol1, tol2 in test_cases:\n        # Run simulation for the first tolerance\n        N_steps1, E_final1 = run_simulation(alpha, tol1, L, N, tf, dt_min)\n        \n        # Run simulation for the second tolerance\n        N_steps2, E_final2 = run_simulation(alpha, tol2, L, N, tf, dt_min)\n\n        # Compute ratios\n        # Avoid division by zero if a result is zero\n        R_steps = N_steps2 / N_steps1 if N_steps1 > 0 else float('inf')\n        R_error = E_final2 / E_final1 if E_final1 > 0 else float('inf')\n        \n        # Verify step count ratio against theoretical sqrt(2)\n        sqrt2 = math.sqrt(2)\n        b_steps = abs((R_steps - sqrt2) / sqrt2) <= 0.10\n        all_booleans.append(b_steps)\n\n        # Verify final error ratio against theoretical 0.5\n        b_error = abs((R_error - 0.5) / 0.5) <= 0.20\n        all_booleans.append(b_error)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, all_booleans))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Explicit methods, even when adaptive, can become inefficient for stiff problems that demand impractically small time steps to maintain stability. This advanced practice introduces a powerful strategy: adaptive scheme switching between a fast explicit method and a stable implicit method. You will design and implement a switching criterion based on the Fourier number, $Fo$, complete with a hysteresis mechanism to prevent numerical 'chattering' and optimize computational performance for a wide range of transient behaviors .",
            "id": "3934621",
            "problem": "You are asked to formalize, implement, and evaluate an adaptive integration mode switching criterion for a one-dimensional transient heat conduction problem, based on the Fourier number and a target tolerance, with hysteresis to prevent rapid oscillations between schemes. The purpose is to derive the criterion from first principles, then implement it in a program that performs a short simulation for several test cases and reports quantifiable results.\n\nBegin from the one-dimensional transient heat equation for a homogeneous material,\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2},\n$$\nwhere $T$ is temperature, $t$ is time, $x$ is the spatial coordinate, and $\\alpha$ is the thermal diffusivity defined by\n$$\n\\alpha = \\frac{k}{\\rho c_p}.\n$$\nHere, $k$ is thermal conductivity, $\\rho$ is mass density, and $c_p$ is specific heat capacity at constant pressure. Consider a slab of length $L$ with fixed (Dirichlet) boundary temperatures $T(0,t)=T_L$ and $T(L,t)=T_R$, and an interior discretized into $N$ uniformly spaced interior nodes with spacing $\\Delta x = \\frac{L}{N+1}$. Use second-order central differences in space and single-step time marching. The explicit Forward Euler (FE) method and implicit Backward Euler (BE) method are to be used as the two candidate integration schemes.\n\nDefine the Fourier number (Fo) for one time step of size $\\Delta t$ by\n$$\nFo = \\frac{\\alpha \\Delta t}{\\Delta x^2}.\n$$\nYou must develop a principled criterion that uses the computed $Fo$ and a target tolerance parameter to decide, at each time step, whether to use the explicit or implicit method, and include hysteresis in the criterion so that small fluctuations of $Fo$ around the tolerance do not cause immediate switching back and forth. The criterion must be derived from the stability and accuracy properties of the underlying discretization and the physics of diffusion, not from ad hoc rules.\n\nImplement the following computational setting:\n\n- The spatial discretization employs $N$ interior nodes, uniform spacing $\\Delta x$, with Dirichlet boundary temperatures $T_L$ and $T_R$. The initial interior temperature is uniform $T_0$.\n- The FE update for interior node $i$ is applied as a standard second-order central-difference explicit step on the discrete Laplacian using the computed $Fo$ and fixed boundary values.\n- The BE update is applied by solving the tridiagonal linear system that arises from the fully implicit backward Euler in time and second-order central difference in space, with known Dirichlet boundaries contributing to the right-hand side.\n- At each time step with a proposed $\\Delta t$, compute $Fo$, apply your switching criterion with hysteresis, choose the scheme, and advance the solution.\n\nDesign your hysteresis so that, once one scheme is selected, small excursions of $Fo$ inside a tolerance band around a target value do not trigger a switch. Your criterion must be concrete and algorithmically checkable, but you must derive it first from the foundational properties of the discrete heat equation and the amplification behavior of the numerical schemes before specifying and implementing it.\n\nPhysical units must be consistently used and reported. Material properties $k$ are in $\\mathrm{W/(m\\,K)}$, $\\rho$ in $\\mathrm{kg/m^3}$, $c_p$ in $\\mathrm{J/(kg\\,K)}$, $L$ in $\\mathrm{m}$, $\\Delta t$ in $\\mathrm{s}$, $T$ in $\\mathrm{K}$.\n\nYour program must process the following test suite of parameter sets. In each case, start in the explicit mode at the first time step, unless your criterion dictates switching immediately once $Fo$ is evaluated. For each case, perform one update per listed $\\Delta t$ value:\n\n- Test case 1 (happy path, explicit-safe regime):\n  - Material: $k = 45 \\, \\mathrm{W/(m\\,K)}$, $\\rho = 7850 \\, \\mathrm{kg/m^3}$, $c_p = 500 \\, \\mathrm{J/(kg\\,K)}$.\n  - Geometry: $L = 0.02 \\, \\mathrm{m}$, $N = 10$.\n  - Boundary temperatures: $T_L = 400 \\, \\mathrm{K}$, $T_R = 300 \\, \\mathrm{K}$.\n  - Initial interior temperature: $T_0 = 300 \\, \\mathrm{K}$.\n  - Time step sequence: $\\Delta t$ list $[0.002, 0.003, 0.004, 0.005] \\, \\mathrm{s}$.\n  - Target tolerance and hysteresis: target $ \\tau = 0.45$ (dimensionless), hysteresis half-width $h = 0.03$ (dimensionless).\n- Test case 2 (crossing into implicit-needed regime):\n  - Material: $k = 45 \\, \\mathrm{W/(m\\,K)}$, $\\rho = 7850 \\, \\mathrm{kg/m^3}$, $c_p = 500 \\, \\mathrm{J/(kg\\,K)}$.\n  - Geometry: $L = 0.02 \\, \\mathrm{m}$, $N = 10$.\n  - Boundary temperatures: $T_L = 400 \\, \\mathrm{K}$, $T_R = 300 \\, \\mathrm{K}$.\n  - Initial interior temperature: $T_0 = 300 \\, \\mathrm{K}$.\n  - Time step sequence: $\\Delta t$ list $[0.1, 0.3, 0.6] \\, \\mathrm{s}$.\n  - Target tolerance and hysteresis: target $ \\tau = 0.45$, hysteresis half-width $h = 0.03$.\n- Test case 3 (oscillatory $Fo$ around tolerance to test hysteresis):\n  - Material: $k = 45 \\, \\mathrm{W/(m\\,K)}$, $\\rho = 7850 \\, \\mathrm{kg/m^3}$, $c_p = 500 \\, \\mathrm{J/(kg\\,K)}$.\n  - Geometry: $L = 0.02 \\, \\mathrm{m}$, $N = 10$.\n  - Boundary temperatures: $T_L = 400 \\, \\mathrm{K}$, $T_R = 300 \\, \\mathrm{K}$.\n  - Initial interior temperature: $T_0 = 300 \\, \\mathrm{K}$.\n  - Time step sequence: $\\Delta t$ list $[0.06, 0.05, 0.08, 0.04, 0.07] \\, \\mathrm{s}$.\n  - Target tolerance and hysteresis: target $ \\tau = 0.20$, hysteresis half-width $h = 0.05$.\n- Test case 4 (mostly implicit due to large steps):\n  - Material: $k = 45 \\, \\mathrm{W/(m\\,K)}$, $\\rho = 7850 \\, \\mathrm{kg/m^3}$, $c_p = 500 \\, \\mathrm{J/(kg\\,K)}$.\n  - Geometry: $L = 0.02 \\, \\mathrm{m}$, $N = 10$.\n  - Boundary temperatures: $T_L = 400 \\, \\mathrm{K}$, $T_R = 300 \\, \\mathrm{K}$.\n  - Initial interior temperature: $T_0 = 300 \\, \\mathrm{K}$.\n  - Time step sequence: $\\Delta t$ list $[0.5, 0.4, 0.6, 0.7] \\, \\mathrm{s}$.\n  - Target tolerance and hysteresis: target $ \\tau = 0.10$, hysteresis half-width $h = 0.02$.\n\nFor each test case, your program must compute and return a list of three values:\n- The fraction of steps that used the explicit scheme, as a decimal rounded to four places.\n- The total number of scheme switches (an integer) encountered across the time step sequence.\n- The final spatially averaged temperature across all nodes including both boundaries (i.e., the arithmetic mean of $T_L$, all interior nodal temperatures, and $T_R$), in $\\mathrm{K}$, rounded to four places.\n\nYour program should produce a single line of output containing the results for the test cases as a comma-separated list enclosed in square brackets, where each element is the list described above for a test case. For example, the output must look like\n$$\n[\\,[a_1,b_1,c_1],\\,[a_2,b_2,c_2],\\,[a_3,b_3,c_3],\\,[a_4,b_4,c_4]\\,]\n$$\nwith the numerical values filled in by your computations. No other output should be printed.",
            "solution": "The problem requires the development and implementation of an adaptive scheme-switching criterion for solving the one-dimensional transient heat equation. The choice at each time step is between the explicit Forward Euler (FE) method and the implicit Backward Euler (BE) method. The criterion must be based on the dimensionless Fourier number, a target tolerance, and include a hysteresis mechanism.\n\nThe governing partial differential equation (PDE) is the one-dimensional heat equation:\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\nwhere $T(x,t)$ is the temperature, $\\alpha = k/(\\rho c_p)$ is the thermal diffusivity, $k$ is thermal conductivity, $\\rho$ is density, and $c_p$ is specific heat capacity. The spatial domain is $x \\in [0, L]$. We discretize this domain into $N$ interior nodes with a uniform spacing of $\\Delta x = L/(N+1)$. The spatial locations of the nodes are $x_i = i \\Delta x$ for $i=0, 1, \\dots, N+1$. The boundary conditions are fixed temperatures $T(0,t) = T_0 = T_L$ and $T(L,t) = T_{N+1} = T_R$. The temperature at an interior node $i$ at time step $n$ is denoted $T_i^n$.\n\nUsing a second-order central difference for the spatial derivative, the semi-discretized equation at an interior node $i$ is:\n$$\n\\frac{d T_i}{d t} = \\alpha \\frac{T_{i+1} - 2T_i + T_{i-1}}{\\Delta x^2}\n$$\n\nWe consider two time integration schemes:\n\n1.  **Forward Euler (FE) Method (Explicit)**: This scheme uses a forward difference for the time derivative, evaluating the spatial derivative at the current time step $n$.\n    $$\n    \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{\\Delta x^2}\n    $$\n    Rearranging gives the explicit update rule:\n    $$\n    T_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{\\Delta x^2} \\left( T_{i+1}^n - 2T_i^n + T_{i-1}^n \\right)\n    $$\n    Introducing the Fourier number $Fo = \\frac{\\alpha \\Delta t}{\\Delta x^2}$, the update becomes:\n    $$\n    T_i^{n+1} = T_i^n + Fo \\left( T_{i+1}^n - 2T_i^n + T_{i-1}^n \\right)\n    $$\n    This method is computationally inexpensive as it provides a direct formula for the new temperature $T_i^{n+1}$.\n\n2.  **Backward Euler (BE) Method (Implicit)**: This scheme uses a backward difference for the time derivative, evaluating the spatial derivative at the future time step $n+1$.\n    $$\n    \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\frac{T_{i+1}^{n+1} - 2T_i^{n+1} + T_{i-1}^{n+1}}{\\Delta x^2}\n    $$\n    Rearranging to group the unknown terms $T^{n+1}$ on the left-hand side yields a system of linear equations for the interior nodes $i=1, \\dots, N$:\n    $$\n    -Fo \\, T_{i-1}^{n+1} + (1 + 2Fo) T_i^{n+1} - Fo \\, T_{i+1}^{n+1} = T_i^n\n    $$\n    This method is computationally more expensive as it requires solving this linear system at each time step.\n\n**Derivation of the Switching Criterion**\n\nThe choice between FE and BE is dictated by their stability properties. To derive the stability condition for the FE method, we perform a Von Neumann stability analysis. We consider a single Fourier mode of the error, $E_i^n = G^n e^{\\mathrm{j} k_m x_i}$, where $G$ is the amplification factor per time step, $k_m$ is the wave number, and $\\mathrm{j}=\\sqrt{-1}$. For a stable scheme, the error must not grow, which requires $|G| \\le 1$. Substituting the error mode into the FE update equation yields:\n$$\nG^{n+1} e^{\\mathrm{j} k_m i \\Delta x} = G^n e^{\\mathrm{j} k_m i \\Delta x} + Fo \\left( G^n e^{\\mathrm{j} k_m (i+1) \\Delta x} - 2G^n e^{\\mathrm{j} k_m i \\Delta x} + G^n e^{\\mathrm{j} k_m (i-1) \\Delta x} \\right)\n$$\nDividing by $G^n e^{\\mathrm{j} k_m i \\Delta x}$ gives the amplification factor $G$:\n$$\nG = 1 + Fo \\left( e^{\\mathrm{j} k_m \\Delta x} - 2 + e^{-\\mathrm{j} k_m \\Delta x} \\right) = 1 + Fo \\left( 2 \\cos(k_m \\Delta x) - 2 \\right)\n$$\nUsing the identity $1 - \\cos(\\theta) = 2 \\sin^2(\\theta/2)$, we get:\n$$\nG = 1 - 4 Fo \\sin^2\\left(\\frac{k_m \\Delta x}{2}\\right)\n$$\nThe stability condition $|G| \\le 1$ implies $-1 \\le G \\le 1$. The upper bound $G \\le 1$ is always satisfied since $Fo > 0$. The lower bound $-1 \\le G$ gives:\n$$\n-1 \\le 1 - 4 Fo \\sin^2\\left(\\frac{k_m \\Delta x}{2}\\right) \\implies 4 Fo \\sin^2\\left(\\frac{k_m \\Delta x}{2}\\right) \\le 2 \\implies Fo \\le \\frac{1}{2 \\sin^2(k_m \\Delta x/2)}\n$$\nThis condition must hold for all possible wave numbers $k_m$. The most restrictive condition (the smallest upper bound on $Fo$) occurs when $\\sin^2(k_m \\Delta x/2)$ is maximum, which is $1$. This corresponds to the highest frequency (shortest wavelength) mode that the grid can resolve, $\\lambda = 2\\Delta x$, for which $k_m \\Delta x = \\pi$. Thus, the stability limit for the FE method is:\n$$\nFo \\le 0.5\n$$\nThe BE method is unconditionally stable for all $Fo > 0$. Its amplification factor is $G = (1 + 4 Fo \\sin^2(k_m \\Delta x/2))^{-1}$, which always satisfies $0 < G \\le 1$.\n\nThe primary motivation for switching is to maintain stability while minimizing computational cost. The FE method is preferred for its speed, but only when it is stable. The BE method provides stability for any time step size, at the cost of solving a linear system.\n\nA principled switching criterion can be established based on the stability limit $Fo = 0.5$. To ensure accuracy and avoid numerical oscillations that occur near the stability boundary, we choose a target threshold $\\tau < 0.5$. The FE method will be considered safe if $Fo$ is below this target.\n\nTo prevent rapid switching (\"chattering\") if $Fo$ fluctuates around $\\tau$, a hysteresis band is introduced. We define a hysteresis half-width $h$, creating a lower threshold $T_L = \\tau - h$ and an upper threshold $T_H = \\tau + h$. The switching logic is formalized as follows: let the current integration mode be $M$.\n\n- If $M$ is **Explicit (FE)**: Switch to **Implicit (BE)** only if the Fourier number exceeds the upper threshold: $Fo > T_H$.\n- If $M$ is **Implicit (BE)**: Switch back to **Explicit (FE)** only if the Fourier number drops below the lower threshold: $Fo < T_L$.\n- If $Fo$ is within the band $[T_L, T_H]$, the current mode is retained.\n\nThe initial mode is set to Explicit. For the first time step, the criterion is checked, and the mode is selected before the update is performed.\n\n**Implementation of Numerical Schemes**\n\n**Explicit Update:**\nThe temperature vector at the new time step, $\\mathbf{T}^{n+1}$, is calculated directly from the vector at the current step, $\\mathbf{T}^{n}$. For each interior node $i \\in \\{1, ..., N\\}$:\n$$\nT_i^{n+1} = T_i^n + Fo(T_{i+1}^n - 2T_i^n + T_{i-1}^n)\n$$\nBoundary values $T_0^n = T_L$ and $T_{N+1}^n = T_R$ are used for the $i=1$ and $i=N$ calculations, respectively.\n\n**Implicit Update:**\nThe BE scheme requires solving the tridiagonal linear system $\\mathbf{A} \\mathbf{T}^{n+1} = \\mathbf{b}$ for the vector of unknown interior temperatures $\\mathbf{T}^{n+1} = [T_1^{n+1}, \\dots, T_N^{n+1}]^T$. The $N \\times N$ matrix $\\mathbf{A}$ has the form:\n$$\n\\mathbf{A} = \n\\begin{pmatrix}\n1+2Fo & -Fo & 0 & \\dots & 0 \\\\\n-Fo & 1+2Fo & -Fo & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n0 & \\dots & -Fo & 1+2Fo & -Fo \\\\\n0 & \\dots & 0 & -Fo & 1+2Fo\n\\end{pmatrix}\n$$\nThe right-hand side vector $\\mathbf{b}$ is constructed from the temperatures at the previous time step, $\\mathbf{T}^n$, and incorporates the fixed boundary conditions:\n$$\n\\mathbf{b} = \n\\begin{pmatrix}\nT_1^n + Fo \\cdot T_L \\\\\nT_2^n \\\\\n\\vdots \\\\\nT_{N-1}^n \\\\\nT_N^n + Fo \\cdot T_R\n\\end{pmatrix}\n$$\nThis system can be solved efficiently using a tridiagonal matrix algorithm (TDMA) or a specialized banded system solver, such as `scipy.linalg.solve_banded`.\n\nThe procedure for each test case is to initialize the temperature field and the mode, then iterate through the sequence of time steps. In each step, $Fo$ is computed, the switching criterion is applied, the appropriate scheme is used to update the temperatures, and statistics (scheme choice, switches) are recorded. Finally, the required output metrics are calculated.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D transient heat equation using an adaptive scheme-switching\n    criterion between Forward Euler and Backward Euler methods.\n    \"\"\"\n    test_cases = [\n        {\n            \"material\": {\"k\": 45.0, \"rho\": 7850.0, \"cp\": 500.0},\n            \"geometry\": {\"L\": 0.02, \"N\": 10},\n            \"conditions\": {\"T_L\": 400.0, \"T_R\": 300.0, \"T_0\": 300.0},\n            \"time\": {\"dt_list\": [0.002, 0.003, 0.004, 0.005]},\n            \"control\": {\"tau\": 0.45, \"h\": 0.03},\n        },\n        {\n            \"material\": {\"k\": 45.0, \"rho\": 7850.0, \"cp\": 500.0},\n            \"geometry\": {\"L\": 0.02, \"N\": 10},\n            \"conditions\": {\"T_L\": 400.0, \"T_R\": 300.0, \"T_0\": 300.0},\n            \"time\": {\"dt_list\": [0.1, 0.3, 0.6]},\n            \"control\": {\"tau\": 0.45, \"h\": 0.03},\n        },\n        {\n            \"material\": {\"k\": 45.0, \"rho\": 7850.0, \"cp\": 500.0},\n            \"geometry\": {\"L\": 0.02, \"N\": 10},\n            \"conditions\": {\"T_L\": 400.0, \"T_R\": 300.0, \"T_0\": 300.0},\n            \"time\": {\"dt_list\": [0.06, 0.05, 0.08, 0.04, 0.07]},\n            \"control\": {\"tau\": 0.20, \"h\": 0.05},\n        },\n        {\n            \"material\": {\"k\": 45.0, \"rho\": 7850.0, \"cp\": 500.0},\n            \"geometry\": {\"L\": 0.02, \"N\": 10},\n            \"conditions\": {\"T_L\": 400.0, \"T_R\": 300.0, \"T_0\": 300.0},\n            \"time\": {\"dt_list\": [0.5, 0.4, 0.6, 0.7]},\n            \"control\": {\"tau\": 0.10, \"h\": 0.02},\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Unpack parameters\n        k = case[\"material\"][\"k\"]\n        rho = case[\"material\"][\"rho\"]\n        cp = case[\"material\"][\"cp\"]\n        L = case[\"geometry\"][\"L\"]\n        N = case[\"geometry\"][\"N\"]\n        T_L = case[\"conditions\"][\"T_L\"]\n        T_R = case[\"conditions\"][\"T_R\"]\n        T_0 = case[\"conditions\"][\"T_0\"]\n        dt_list = case[\"time\"][\"dt_list\"]\n        tau = case[\"control\"][\"tau\"]\n        h = case[\"control\"][\"h\"]\n\n        # Calculated parameters\n        alpha = k / (rho * cp)\n        dx = L / (N + 1)\n\n        # Initialize state variables\n        # T_interior stores temperatures of N internal nodes\n        T_interior = np.full(N, T_0, dtype=float)\n        \n        current_mode = 'EXPLICIT'\n        explicit_steps = 0\n        switches = 0\n        \n        T_low = tau - h\n        T_high = tau + h\n\n        for dt in dt_list:\n            Fo = alpha * dt / (dx**2)\n            \n            prev_mode = current_mode\n            if current_mode == 'EXPLICIT':\n                if Fo > T_high:\n                    current_mode = 'IMPLICIT'\n            elif current_mode == 'IMPLICIT':\n                if Fo < T_low:\n                    current_mode = 'EXPLICIT'\n\n            if current_mode != prev_mode:\n                switches += 1\n\n            # Extend temperature array with boundaries for easier calculation\n            T_full = np.concatenate(([T_L], T_interior, [T_R]))\n\n            if current_mode == 'EXPLICIT':\n                explicit_steps += 1\n                T_new_interior = np.zeros(N)\n                for i in range(N):\n                    # T_full indices are i, i+1, i+2 for nodes i-1, i, i+1\n                    T_new_interior[i] = T_full[i+1] + Fo * (T_full[i+2] - 2 * T_full[i+1] + T_full[i])\n                T_interior = T_new_interior\n            \n            else: # IMPLICIT\n                # Build the tridiagonal system Ax = b for interior nodes\n                # A is represented by its diagonals for solve_banded\n                # a_banded has shape (3, N) for a tridiagonal matrix\n                # Row 0: super-diagonal (shifted)\n                # Row 1: main diagonal\n                # Row 2: sub-diagonal\n                \n                a_banded = np.zeros((3, N))\n                a_banded[0, 1:] = -Fo  # Super-diagonal\n                a_banded[1, :] = 1 + 2 * Fo  # Main diagonal\n                a_banded[2, :-1] = -Fo  # Sub-diagonal\n\n                # Build the right-hand side vector b\n                b = T_interior.copy()\n                b[0] += Fo * T_L\n                b[-1] += Fo * T_R\n\n                # Solve the system\n                T_interior = solve_banded((1, 1), a_banded, b)\n\n        # Calculate final metrics for the case\n        total_steps = len(dt_list)\n        explicit_fraction = round(explicit_steps / total_steps, 4)\n        \n        final_T_full = np.concatenate(([T_L], T_interior, [T_R]))\n        final_avg_temp = round(np.mean(final_T_full), 4)\n\n        results.append([explicit_fraction, switches, final_avg_temp])\n    \n    # Format and print the final output\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}