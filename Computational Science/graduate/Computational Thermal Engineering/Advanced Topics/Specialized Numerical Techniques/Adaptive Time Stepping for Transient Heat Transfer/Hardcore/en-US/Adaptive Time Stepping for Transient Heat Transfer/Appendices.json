{
    "hands_on_practices": [
        {
            "introduction": "Before we can control the time step, we must first understand why it needs controlling. This practice delves into the heart of numerical stability for explicit methods, demonstrating how the maximum permissible time step is not an arbitrary choice but is dictated by the physical properties of the system and its spatial discretization . By performing a linear stability analysis, you will derive the theoretical 'speed limit' for a simulation and calculate it for a tangible finite element model.",
            "id": "3934582",
            "problem": "Consider one-dimensional transient heat conduction in a homogeneous rod, discretized by the Finite Element (FE) method with linear elements. The semi-discrete system has the canonical form $M \\, \\dot{T}(t) + K \\, T(t) = F(t)$, where $M$ is the symmetric positive definite (SPD) capacity (mass) matrix and $K$ is the SPD conductivity (stiffness) matrix. An explicit one-step method is applied to advance the temperature vector $T(t)$ in time.\n\nPart A (derivation): Starting from the semi-discrete heat equation and using a forward Euler explicit discretization for the homogeneous system ($F(t)=0$), perform a linear stability analysis by decomposing the dynamics along the eigenmodes of $M^{-1}K$. Derive the explicit time-step stability bound in terms of the largest eigenvalue of $M^{-1}K$.\n\nPart B (computation): Consider a rod of length $L=0.3\\,\\text{m}$ and uniform cross-sectional area $A=1.0\\times 10^{-4}\\,\\text{m}^{2}$, with thermal conductivity $k=200\\,\\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$, density $\\rho=7800\\,\\text{kg}\\,\\text{m}^{-3}$, and specific heat $c=500\\,\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$. The rod is held at zero temperature at both ends (Dirichlet boundary conditions $T(0,t)=0$ and $T(L,t)=0$). Discretize the domain with a uniform mesh of four nodes (nodes $1,2,3,4$) and three linear elements of equal length, and use the consistent element capacity and conductivity matrices\n$$\nM^{(e)}=\\frac{\\rho c A h}{6}\\begin{bmatrix}2  1 \\\\ 1  2\\end{bmatrix},\\qquad\nK^{(e)}=\\frac{k A}{h}\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix},\n$$\nwhere $h=L/3$. Assemble the global matrices, enforce the Dirichlet boundary conditions at nodes $1$ and $4$, and extract the reduced $2\\times 2$ system for the interior nodes $2$ and $3$. Compute the largest eigenvalue $\\lambda_{\\max}$ of $M^{-1}K$ for this reduced system, and then determine the largest stable time step $\\Delta t_{\\max}$ predicted by your stability bound from Part A.\n\nExpress your final $\\Delta t_{\\max}$ in seconds, and round your answer to four significant figures.",
            "solution": "The governing semi-discrete heat equation is\n$$\nM \\, \\dot{T}(t) + K \\, T(t) = F(t),\n$$\nwith $M$ and $K$ symmetric positive definite (SPD) matrices for standard thermophysical properties and well-posed boundary conditions. For linear stability analysis, we consider the homogeneous system $F(t)=0$, yielding\n$$\n\\dot{T}(t) = -M^{-1}K\\,T(t).\n$$\nWe apply the forward Euler explicit scheme to this linear system:\n$$\nT^{n+1} = T^{n} + \\Delta t \\,\\dot{T}^{n} = T^{n} - \\Delta t \\, M^{-1}K\\,T^{n} = \\left(I - \\Delta t \\, M^{-1}K\\right) T^{n}.\n$$\nLet $M^{-1}K$ admit an eigen-decomposition in terms of eigenpairs $\\{(\\lambda_{i},v_{i})\\}$, where $M^{-1}K\\,v_{i}=\\lambda_{i} v_{i}$ and, due to the SPD property of $K$ and $M$, all $\\lambda_{i}0$ and there exists a complete set of eigenvectors. Expanding $T^{n}$ in the eigenbasis, $T^{n}=\\sum_{i}\\alpha_{i}^{n} v_{i}$, the recurrence along each mode is\n$$\n\\alpha_{i}^{n+1} = \\left(1 - \\Delta t \\,\\lambda_{i}\\right)\\alpha_{i}^{n}.\n$$\nThe scalar amplification factor is $g_{i}(\\Delta t)=1 - \\Delta t \\,\\lambda_{i}$. Forward Euler is stable for the linear test equation when $|g_{i}(\\Delta t)|\\leq 1$ for all modes. Because $\\lambda_{i}0$, the condition $|1 - \\Delta t \\,\\lambda_{i}|\\leq 1$ reduces to\n$$\n-1 \\leq 1 - \\Delta t \\,\\lambda_{i} \\leq 1 \\quad \\Longrightarrow \\quad 0 \\leq \\Delta t \\,\\lambda_{i} \\leq 2.\n$$\nThus, stability for all modes requires\n$$\n\\Delta t \\leq \\frac{2}{\\lambda_{\\max}},\n$$\nwhere $\\lambda_{\\max}=\\max_{i}\\lambda_{i}$ is the spectral radius of $M^{-1}K$.\n\nWe now compute $\\lambda_{\\max}$ for the specified mesh and material data. The mesh has $4$ nodes and $3$ equal-length elements, so $h=L/3$. With $L=0.3$, we have $h=0.1$. The element matrices are\n$$\nM^{(e)}=\\frac{\\rho c A h}{6}\\begin{bmatrix}2  1 \\\\ 1  2\\end{bmatrix},\\qquad K^{(e)}=\\frac{k A}{h}\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}.\n$$\nNumerically,\n$$\n\\rho c = 7800\\times 500 = 3.9\\times 10^{6},\\quad A h = (1.0\\times 10^{-4})\\times 0.1 = 1.0\\times 10^{-5},\n$$\nso\n$$\n\\frac{\\rho c A h}{6} = \\frac{3.9\\times 10^{6}\\times 1.0\\times 10^{-5}}{6} = \\frac{39}{6} = 6.5,\n$$\nand\n$$\n\\frac{k A}{h} = \\frac{200\\times 1.0\\times 10^{-4}}{0.1} = 0.2.\n$$\nTherefore,\n$$\nM^{(e)}=\\begin{bmatrix}13  6.5 \\\\ 6.5  13\\end{bmatrix},\\qquad K^{(e)}=0.2\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}.\n$$\nAssembly over three elements $(1\\text{–}2)$, $(2\\text{–}3)$, $(3\\text{–}4)$ yields the $4\\times 4$ global matrices. Enforcing homogeneous Dirichlet boundary conditions at nodes $1$ and $4$ reduces to the interior degrees of freedom at nodes $2$ and $3$. The reduced $2\\times 2$ matrices are\n$$\nM=\\begin{bmatrix}26  6.5 \\\\ 6.5  26\\end{bmatrix},\\qquad K=\\begin{bmatrix}0.4  -0.2 \\\\ -0.2  0.4\\end{bmatrix}.\n$$\nWe seek the generalized eigenvalues $\\lambda$ solving\n$$\nK v = \\lambda M v.\n$$\nEquivalently, $\\lambda$ satisfies\n$$\n\\det\\!\\left(K - \\lambda M\\right)=0.\n$$\nCompute the determinant:\n\\begin{align*}\n\\det\\!\\left(K - \\lambda M\\right)\n= \\det\\!\\begin{bmatrix}0.4 - 26\\lambda  -0.2 - 6.5\\lambda \\\\ -0.2 - 6.5\\lambda  0.4 - 26\\lambda\\end{bmatrix} \\\\\n= (0.4 - 26\\lambda)^{2} - (-0.2 - 6.5\\lambda)^{2} \\\\\n= \\left[(0.4 - 26\\lambda) - (-0.2 - 6.5\\lambda)\\right]\\left[(0.4 - 26\\lambda) + (-0.2 - 6.5\\lambda)\\right] \\\\\n= \\left(0.6 - 19.5\\lambda\\right)\\left(0.2 - 32.5\\lambda\\right).\n\\end{align*}\nSetting this to zero gives the two eigenvalues:\n$$\n0.6 - 19.5\\lambda = 0 \\quad \\Longrightarrow \\quad \\lambda_{1} = \\frac{0.6}{19.5} = \\frac{2}{65},\n$$\n$$\n0.2 - 32.5\\lambda = 0 \\quad \\Longrightarrow \\quad \\lambda_{2} = \\frac{0.2}{32.5} = \\frac{2}{325}.\n$$\nThus,\n$$\n\\lambda_{\\max} = \\frac{2}{65}.\n$$\nFrom the stability bound derived above for forward Euler,\n$$\n\\Delta t_{\\max} = \\frac{2}{\\lambda_{\\max}} = \\frac{2}{(2/65)} = 65.\n$$\nTherefore, the largest stable explicit time step for this mesh and material set is $\\Delta t_{\\max}=65$ seconds. Rounding to four significant figures yields $65.00$.",
            "answer": "$$\\boxed{65.00}$$"
        },
        {
            "introduction": "Knowing the theoretical stability limit is essential, but a truly robust solver must enforce it dynamically. This hands-on coding exercise guides you in building an adaptive controller whose primary goal is to preserve a fundamental physical property: the maximum principle, which prevents non-physical temperature overshoots . You will implement a rejection-based algorithm that automatically adjusts the time step to maintain a physically plausible and monotonic solution, a critical skill for handling simulations with sharp gradients or shocks.",
            "id": "3934707",
            "problem": "You are asked to design and implement an algorithm for one-dimensional transient heat conduction with an adaptive time stepping rule that preserves the discrete maximum principle and spatial monotonicity under a sharp boundary temperature jump. The underlying model is the transient heat equation, which must be derived and implemented from first principles without reliance on any built-in solver. The objective is to construct a test case that intentionally stresses the maximum principle and to develop an adaptive time stepping strategy that prevents non-physical oscillations and overshoot.\n\nThe physical model is the one-dimensional transient heat equation for temperature $T(x,t)$,\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2},\n$$\nwhere $\\alpha$ is the thermal diffusivity. The domain is a rod of length $L$ in meters with spatial coordinate $x \\in [0,L]$, initial temperature $T(x,0) = T_0$ in Kelvin, and time $t$ in seconds. The boundary conditions are Dirichlet (fixed temperature). At the left end, the temperature has a sudden step at time $t=0$ from $T_0$ to $T_1$, while the right end remains fixed at $T_0$; that is, $T(0,t) = T_1$ for all $t \\ge 0$ and $T(L,t) = T_0$ for all $t \\ge 0$. The thermal diffusivity $\\alpha$ must be expressed in $\\mathrm{m^2/s}$, $L$ in $\\mathrm{m}$, $t$ in $\\mathrm{s}$, and $T$ in $\\mathrm{K}$.\n\nYou must discretize the spatial domain into $N$ uniformly spaced nodes, including boundaries, with spacing $\\Delta x = L/(N-1)$, and use a simple explicit forward Euler time stepping with a centered second-order finite difference for the Laplacian. You must design an adaptive rule for the time step $\\Delta t$ that prevents violations of the discrete maximum principle and preserves monotonicity of the discrete temperature profile in space (non-increasing from $x=0$ to $x=L$ given $T_1 \\ge T_0$). The adaptive rule must adjust $\\Delta t$ based on local conditions of the discretized operator to ensure nonnegative mixing weights in the explicit update and must reject any proposed step that causes either overshoot beyond the boundary values or spatial monotonicity violation; rejected steps must be retried with a smaller $\\Delta t$.\n\nYour program must implement the following requirements:\n\n- Start from the fundamental conservation of energy and Fourier law to justify the model and the discretization, and implement the explicit update in time.\n- Implement Dirichlet boundary conditions $T(0,t) = T_1$ and $T(L,t) = T_0$, with the initial condition $T(x,0) = T_0$.\n- Use an adaptive time stepping rule that:\n  - Proposes a candidate $\\Delta t$,\n  - Ensures nonnegative coefficients in the explicit update,\n  - Rejects and halves $\\Delta t$ when either the discrete maximum principle or spatial monotonicity would be violated,\n  - Increases $\\Delta t$ cautiously after successful steps, but never beyond the limit that preserves nonnegative update weights.\n- Track, for the entire simulation, the worst monotonicity violation amplitude defined as\n  $$\n  \\max\\left(0, -\\min_i \\left(T_i - T_{i+1}\\right)\\right),\n  $$\n  where $T_i$ is the discrete temperature at node index $i$, and record the maximum of this quantity over time. This quantity must be reported in Kelvin.\n\nYou must run the solver for a set of four test cases. For each test case, you are given parameters $(L, N, \\alpha, T_0, T_1, t_{\\mathrm{final}}, \\Delta t_{\\mathrm{init}})$, where $t_{\\mathrm{final}}$ is the final time in seconds and $\\Delta t_{\\mathrm{init}}$ is the initial proposed time step in seconds. The test suite is:\n\n- Case $1$: $L=0.02$ $\\mathrm{m}$, $N=21$, $\\alpha=1\\times 10^{-5}$ $\\mathrm{m^2/s}$, $T_0=300$ $\\mathrm{K}$, $T_1=600$ $\\mathrm{K}$, $t_{\\mathrm{final}}=0.5$ $\\mathrm{s}$, $\\Delta t_{\\mathrm{init}}=0.2$ $\\mathrm{s}$.\n- Case $2$: $L=0.02$ $\\mathrm{m}$, $N=5$, $\\alpha=1\\times 10^{-4}$ $\\mathrm{m^2/s}$, $T_0=300$ $\\mathrm{K}$, $T_1=600$ $\\mathrm{K}$, $t_{\\mathrm{final}}=0.1$ $\\mathrm{s}$, $\\Delta t_{\\mathrm{init}}=0.05$ $\\mathrm{s}$.\n- Case $3$: $L=0.1$ $\\mathrm{m}$, $N=51$, $\\alpha=1\\times 10^{-6}$ $\\mathrm{m^2/s}$, $T_0=300$ $\\mathrm{K}$, $T_1=800$ $\\mathrm{K}$, $t_{\\mathrm{final}}=10.0$ $\\mathrm{s}$, $\\Delta t_{\\mathrm{init}}=5.0$ $\\mathrm{s}$.\n- Case $4$: $L=0.02$ $\\mathrm{m}$, $N=3$, $\\alpha=1\\times 10^{-3}$ $\\mathrm{m^2/s}$, $T_0=300$ $\\mathrm{K}$, $T_1=600$ $\\mathrm{K}$, $t_{\\mathrm{final}}=0.01$ $\\mathrm{s}$, $\\Delta t_{\\mathrm{init}}=0.1$ $\\mathrm{s}$.\n\nYour program must output, for each case, the maximum spatial monotonicity violation amplitude in Kelvin observed during the simulation. The final output must be a single line containing a comma-separated list enclosed in square brackets, with each result rounded to six decimal places, for example, $[r_1,r_2,r_3,r_4]$, where each $r_i$ is a float in $\\mathrm{K}$.\n\nAll computations must be performed in the specified units. Angles are not involved. Percentages must not be used.\n\nYour implementation must be a complete, runnable program. It must not read any external input and must not produce any output other than the required single-line list.",
            "solution": "The problem requires the design and implementation of an adaptive time-stepping algorithm for the one-dimensional transient heat equation. The algorithm must preserve the discrete maximum principle and spatial monotonicity of the solution under a sharp jump in a Dirichlet boundary condition.\n\n### Principle-Based Derivation and Discretization\n\nThe physical process is governed by the one-dimensional transient heat equation:\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\nwhere $T(x,t)$ is the temperature in Kelvin at position $x \\in [0,L]$ and time $t \\ge 0$, and $\\alpha$ is the thermal diffusivity in $\\mathrm{m^2/s}$. This equation is derived by combining the principle of conservation of energy with Fourier's law of heat conduction. Conservation of energy for a one-dimensional control volume states that the rate of change of internal energy is equal to the net rate of heat flow into it, $\\rho c_p \\frac{\\partial T}{\\partial t} = -\\frac{\\partial q}{\\partial x}$, where $q$ is the heat flux, $\\rho$ is the density, and $c_p$ is the specific heat capacity. Fourier's law states that heat flux is proportional to the negative temperature gradient, $q = -k \\frac{\\partial T}{\\partial x}$, where $k$ is the thermal conductivity. Combining these yields the heat equation with $\\alpha = k/(\\rho c_p)$.\n\nTo solve this equation numerically, we discretize the spatial domain and time. The spatial domain $x \\in [0,L]$ is divided into $N$ uniformly spaced nodes, $x_i = i \\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/(N-1)$. The temperature at node $i$ and time step $n$ is denoted by $T_i^n$.\n\nThe second-order spatial derivative is approximated using a second-order centered finite difference scheme:\n$$\n\\frac{\\partial^2 T}{\\partial x^2}\\bigg|_{x_i, t^n} \\approx \\frac{T_{i-1}^n - 2T_i^n + T_{i+1}^n}{(\\Delta x)^2}\n$$\nThe time derivative is approximated using the explicit forward Euler method:\n$$\n\\frac{\\partial T}{\\partial t}\\bigg|_{x_i, t^n} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t}\n$$\nwhere $\\Delta t = t^{n+1} - t^n$ is the time step. Substituting these approximations into the heat equation gives the fully discretized explicit update rule for any interior node $i \\in \\{1, \\dots, N-2\\}$:\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\frac{T_{i-1}^n - 2T_i^n + T_{i+1}^n}{(\\Delta x)^2}\n$$\nRearranging for the temperature at the next time step, $T_i^{n+1}$, we get:\n$$\nT_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{(\\Delta x)^2} (T_{i-1}^n - 2T_i^n + T_{i+1}^n)\n$$\n\n### Stability and the Discrete Maximum Principle\n\nLet's define the dimensionless Fourier number, $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$. The update equation can be rewritten as:\n$$\nT_i^{n+1} = s T_{i-1}^n + (1 - 2s) T_i^n + s T_{i+1}^n\n$$\nThe Discrete Maximum Principle (DMP) states that the temperature at a point $(x_i, t^{n+1})$ cannot be greater than the maximum temperature in the domain at time $t^n$, nor less than the minimum. For this to hold, $T_i^{n+1}$ must be a convex combination of the temperatures at the previous time step, which requires all coefficients in the update equation to be non-negative. Since $\\alpha$, $\\Delta t$, and $(\\Delta x)^2$ are positive, $s \\ge 0$. The sole remaining condition is:\n$$\n1 - 2s \\ge 0 \\implies s \\le \\frac{1}{2}\n$$\nThis gives the conditional stability limit for the forward Euler scheme:\n$$\n\\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\le \\frac{1}{2} \\implies \\Delta t \\le \\frac{(\\Delta x)^2}{2\\alpha}\n$$\nWe denote this maximum allowable time step as $\\Delta t_{\\mathrm{max}}$. If $\\Delta t  \\Delta t_{\\mathrm{max}}$, the coefficient $(1-2s)$ becomes negative, allowing $T_i^{n+1}$ to fall outside the range defined by its neighbors, leading to non-physical oscillations (overshoot and undershoot). This violates both the DMP and spatial monotonicity.\n\n### Adaptive Time-Stepping Algorithm Design\n\nThe problem specifies initial conditions that are designed to violate the stability criterion if a large, fixed time step is chosen. The temperature profile starts uniform at $T_0$, but the boundary at $x=0$ is instantaneously raised to $T_1$. An adaptive algorithm is required to manage the time step $\\Delta t$ to ensure a physically correct solution at all times.\n\nThe algorithm proceeds as follows:\n1.  **Initialization**: Discretize the domain, setting $\\Delta x = L/(N-1)$. Initialize the temperature array $T$ to $T_0$. Apply the boundary conditions: $T_0 \\leftarrow T_1$ and $T_{N-1} \\leftarrow T_0$. Set the current time $t=0.0$ and initialize the trial time step $\\Delta t$ to $\\Delta t_{\\mathrm{init}}$. Calculate the stability limit $\\Delta t_{\\mathrm{max}} = (\\Delta x)^2 / (2\\alpha)$. Initialize a variable `max_violation` to $0.0$.\n\n2.  **Time Evolution Loop**: The simulation runs in a loop while $t  t_{\\mathrm{final}}$. In each iteration, a time step is attempted.\n\n3.  **Step Rejection Sub-Loop**: To ensure each step is valid, an inner loop is used:\n    a. A candidate time step $\\Delta t_{\\mathrm{cand}}$ is proposed. For the first step in the simulation, this is $\\Delta t_{\\mathrm{init}}$. For subsequent steps, it is based on the previously successful step. Care is taken not to step past $t_{\\mathrm{final}}$.\n    b. A candidate temperature profile for the next time step, $T_{\\mathrm{cand}}$, is computed using the explicit update rule with $\\Delta t_{\\mathrm{cand}}$.\n    c. The candidate profile $T_{\\mathrm{cand}}$ is validated against two criteria:\n        i. **Maximum Principle Violation**: Check if any temperature value falls outside the initial range $[T_0, T_1]$. This is checked by testing if $\\max(T_{\\mathrm{cand}})  T_1$ or $\\min(T_{\\mathrm{cand}})  T_0$. (Assuming $T_1 \\ge T_0$).\n        ii. **Spatial Monotonicity Violation**: For the given boundary conditions ($T_1 \\ge T_0$), the temperature profile must be non-increasing with $x$. A violation occurs if $T_i  T_{i+1}$ for any node index $i$.\n    d. **Decision**: If either validation check fails, the candidate step is rejected. $\\Delta t_{\\mathrm{cand}}$ is halved ($\\Delta t_{\\mathrm{cand}} \\leftarrow \\Delta t_{\\mathrm{cand}} / 2$), and the sub-loop repeats. This process guarantees that an acceptable, smaller time step will eventually be found.\n    e. If both checks pass, the step is accepted. The inner loop terminates.\n\n4.  **State Update**: Once a valid step $\\Delta t_{\\mathrm{cand}}$ is found, the simulation state is updated:\n    a. The current temperature profile is set to the accepted candidate profile: $T \\leftarrow T_{\\mathrm{cand}}$.\n    b. The simulation time is advanced: $t \\leftarrow t + \\Delta t_{\\mathrm{cand}}$.\n    c. The time step for the *next* iteration is proposed by cautiously increasing the current successful step, for instance, by a factor of $1.2$. However, this proposed step is strictly capped by $\\Delta t_{\\mathrm{max}}$ to proactively enforce stability. So, $\\Delta t_{\\mathrm{next}} \\leftarrow \\min(1.2 \\times \\Delta t_{\\mathrm{cand}}, \\Delta t_{\\mathrm{max}})$.\n\n5.  **Metric Tracking**: The problem asks to track the maximum monotonicity violation. Since the algorithm rejects any step that *would cause* a violation, the temperature profiles that are accepted will, by design, exhibit no monotonicity violation. The metric $\\max\\left(0, -\\min_i \\left(T_i - T_{i+1}\\right)\\right)$ is calculated on each accepted state. For a correctly implemented algorithm, this value should be zero (or a value on the order of machine precision, which for practical purposes is zero), as any profile with $T_i  T_{i+1}$ would have been rejected. The maximum value of this metric over the entire simulation is therefore expected to be zero, confirming the algorithm's correctness.\n\nThis adaptive strategy ensures that even with a challenging initial time step, the simulation automatically reduces the step size to resolve the sharp initial transient near the boundary and then increases it as the solution smooths out, providing an efficient and robust solution.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(L, N, alpha, T0, T1, t_final, dt_init):\n    \"\"\"\n    Solves the 1D transient heat equation with an adaptive time step\n    that enforces the discrete maximum principle and spatial monotonicity.\n\n    Args:\n        L (float): Length of the rod (m).\n        N (int): Number of spatial nodes.\n        alpha (float): Thermal diffusivity (m^2/s).\n        T0 (float): Initial temperature and right boundary temperature (K).\n        T1 (float): Left boundary temperature (K).\n        t_final (float): Final simulation time (s).\n        dt_init (float): Initial time step (s).\n\n    Returns:\n        float: The maximum spatial monotonicity violation amplitude observed.\n    \"\"\"\n    # 1. Discretization and Initialization\n    if N  2:\n        return 0.0  # Not enough nodes for a meaningful simulation\n        \n    x = np.linspace(0, L, N)\n    dx = L / (N - 1)\n    \n    # Set initial temperature profile at t=0\n    T = np.full(N, T0, dtype=np.float64)\n    # Apply boundary condition at x=0 for t=0\n    T[0] = T1\n    # Boundary at x=L is already at T0\n    \n    t = 0.0\n    dt_current_proposal = dt_init\n    \n    # 2. Stability Limit\n    # The explicit scheme is stable for s = alpha * dt / dx**2 = 0.5\n    # The time step must not exceed this physical limit.\n    dt_max = (dx**2) / (2.0 * alpha)\n    \n    max_monotonicity_violation = 0.0\n    \n    # Assumption based on problem statement\n    temp_min, temp_max = min(T0, T1), max(T0, T1)\n    \n    # 3. Time Loop\n    while t  t_final:\n        # 4. Adaptive Time Stepping Logic (Rejection Loop)\n        dt_proposed = min(dt_current_proposal, t_final - t) # Do not step over t_final\n\n        while True:\n            # If the time step becomes excessively small, break to prevent infinite loops.\n            if dt_proposed  1e-15:\n                break\n                \n            # Propose the next state T_next\n            T_next = np.copy(T)\n            \n            # Explicit forward Euler update for interior nodes\n            # Using vectorization for performance\n            s = alpha * dt_proposed / (dx**2)\n            T_next[1:-1] = T[1:-1] + s * (T[2:] - 2 * T[1:-1] + T[:-2])\n            \n            # Boundary conditions are fixed (Dirichlet)\n            T_next[0] = T1\n            T_next[-1] = T0\n            \n            # --- Validation Checks ---\n            # Check 1: Maximum Principle Violation (Overshoot/Undershoot)\n            # The temperature should stay within the initial boundary limits.\n            max_principle_violation = np.any(T_next[1:-1]  temp_max) or np.any(T_next[1:-1]  temp_min)\n            \n            # Check 2: Spatial Monotonicity Violation\n            # For T1 = T0, temperature should be non-increasing from left to right.\n            # Violation occurs if T_i  T_{i+1} for any i.\n            diffs = T_next[:-1] - T_next[1:]\n            monotonicity_violation_check = np.any(diffs  0)\n            \n            if max_principle_violation or monotonicity_violation_check:\n                # REJECT step: The proposed step is too large. Halve it and retry.\n                dt_proposed /= 2.0\n            else:\n                # ACCEPT step: The step is valid.\n                break # Exit the rejection loop\n        \n        # If dt became too small, we end the simulation for this case.\n        if dt_proposed  1e-15:\n            break\n            \n        # 5. Update State\n        dt_accepted = dt_proposed\n        T = T_next\n        t += dt_accepted\n        \n        # 6. Track Metrics on the accepted state\n        # The problem requires tracking the violation metric. By design of the\n        # rejection algorithm, this value should be zero on all accepted states.\n        diffs = T[:-1] - T[1:]\n        if diffs.size  0:\n            current_violation = max(0.0, -np.min(diffs))\n            if current_violation  max_monotonicity_violation:\n                max_monotonicity_violation = current_violation\n        \n        # 7. Propose dt for the *next* iteration\n        # Cautiously increase step size, but never beyond the theoretical max.\n        dt_current_proposal = min(dt_accepted * 1.2, dt_max)\n\n    return max_monotonicity_violation\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (L, N, alpha, T0, T1, t_final, dt_init)\n        (0.02, 21, 1e-5, 300.0, 600.0, 0.5, 0.2),\n        (0.02, 5, 1e-4, 300.0, 600.0, 0.1, 0.05),\n        (0.1, 51, 1e-6, 300.0, 800.0, 10.0, 5.0),\n        (0.02, 3, 1e-3, 300.0, 600.0, 0.01, 0.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        violation = run_simulation(*case)\n        results.append(f\"{violation:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n# Run the solver\nsolve()\n```"
        },
        {
            "introduction": "While maintaining stability is non-negotiable, the ultimate goal of many simulations is to achieve a solution with a prescribed level of accuracy. This advanced practice introduces you to error-based adaptive time stepping, the engine behind most modern scientific computing solvers . You will implement a controller that uses an embedded method to estimate the local error and adjusts the time step to meet a specific tolerance, effectively putting the solver on 'autopilot' to achieve a target precision.",
            "id": "3934689",
            "problem": "Consider a one-dimensional homogeneous rod of length $L$ with thermal diffusivity $\\alpha$ undergoing transient heat conduction with Dirichlet boundary conditions. The governing equation is the heat equation, expressed as the partial differential equation\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2},\n$$\nfor $x \\in [0,L]$ and $t \\ge 0$, with boundary conditions $T(0,t) = 0$ and $T(L,t) = 0$ for all $t$, and initial condition $T(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right)$. The exact solution for these conditions is\n$$\nT_{\\text{exact}}(x,t) = e^{-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t} \\sin\\left(\\frac{\\pi x}{L}\\right).\n$$\nSpatially discretize the domain using a uniform grid with $N$ nodes and spacing $\\Delta x = \\frac{L}{N-1}$, and approximate spatial derivatives with the second-order central difference. This produces a semi-discrete ordinary differential equation system for the interior nodes (excluding the Dirichlet boundaries):\n$$\n\\frac{d\\mathbf{y}(t)}{dt} = \\mathbf{f}(\\mathbf{y}(t)) = \\alpha \\frac{1}{\\Delta x^2} \\left( \\mathbf{P}\\mathbf{y}(t) \\right),\n$$\nwhere $\\mathbf{y}(t) \\in \\mathbb{R}^{N-2}$ is the vector of temperatures at the interior nodes, and $\\mathbf{P}$ is the discrete Laplacian operator with homogeneous Dirichlet conditions.\n\nConstruct a time integration algorithm over the interval $t \\in [0, t_f]$ using an explicit second-order method with an embedded first-order method to estimate the local truncation error per step. Use the Euclidean norm for the error over the temperature vector $\\mathbf{y}$, and treat the norm as having units of Kelvin. Design an adaptive time step controller that targets a specified per-step error tolerance $\\mathrm{tol}$, enforcing step acceptance only when the estimated local error norm is less than or equal to $\\mathrm{tol}$. Incorporate a minimum time step $\\Delta t_{\\min}$ and a maximum time step $\\Delta t_{\\max}$ that respects explicit stability for the heat equation. If at $\\Delta t_{\\min}$ the estimated local error remains above $\\mathrm{tol}$, accept the step to avoid deadlock, and continue with $\\Delta t_{\\min}$.\n\nFor each simulation, compute:\n- The number of accepted time steps $N_{\\text{steps}}$ taken to reach $t_f$.\n- The global Euclidean norm error at $t_f$, defined by\n$$\nE_{\\text{final}} = \\left\\| \\mathbf{y}(t_f) - \\mathbf{y}_{\\text{exact}}(t_f) \\right\\|_2,\n$$\nwhere $\\mathbf{y}_{\\text{exact}}(t_f)$ is obtained by evaluating $T_{\\text{exact}}(x_i,t_f)$ at the interior grid points.\n\nDesign a test where you verify convergence rates by halving tolerances and observing both the step counts and final errors. Specifically, run paired simulations with tolerance values $(\\mathrm{tol}_1, \\mathrm{tol}_2)$ where $\\mathrm{tol}_2 = \\frac{1}{2}\\mathrm{tol}_1$, and compare the ratios\n$$\nR_{\\text{steps}} = \\frac{N_{\\text{steps}}(\\mathrm{tol}_2)}{N_{\\text{steps}}(\\mathrm{tol}_1)}, \\quad\nR_{\\text{error}} = \\frac{E_{\\text{final}}(\\mathrm{tol}_2)}{E_{\\text{final}}(\\mathrm{tol}_1)}.\n$$\nFor a second-order method controlled by an embedded first-order error estimate, the expected behavior (in the regime where the controller determines the time step and does not saturate at either $\\Delta t_{\\min}$ or $\\Delta t_{\\max}$) is that $R_{\\text{steps}}$ should be approximately $\\sqrt{2}$ and $R_{\\text{error}}$ should be approximately $\\frac{1}{2}$.\n\nUse the following fixed physical and numerical parameters:\n- Rod length: $L = 1$ meter.\n- Number of spatial nodes: $N = 50$.\n- Final time: $t_f = 1.0$ seconds.\n- Minimum time step: $\\Delta t_{\\min} = 10^{-3}$ seconds.\n- Maximum time step: $\\Delta t_{\\max}$ set to $0.9$ times the explicit stability limit, i.e.,\n$$\n\\Delta t_{\\max} = 0.9 \\cdot \\frac{\\Delta x^2}{2 \\alpha}.\n$$\n\nImplement the adaptive controller and run the following test suite of parameter pairs, where each test case is a pair $(\\alpha, \\mathrm{tol}_1, \\mathrm{tol}_2)$:\n1. $(\\alpha = 10^{-4} \\,\\text{m}^2/\\text{s}, \\mathrm{tol}_1 = 10^{-4} \\,\\text{K}, \\mathrm{tol}_2 = 5 \\times 10^{-5} \\,\\text{K})$ — general case where the controller operates away from bounds.\n2. $(\\alpha = 10^{-4} \\,\\text{m}^2/\\text{s}, \\mathrm{tol}_1 = 10^{-10} \\,\\text{K}, \\mathrm{tol}_2 = 5 \\times 10^{-11} \\,\\text{K})$ — edge case expected to saturate at $\\Delta t_{\\min}$.\n3. $(\\alpha = 10^{-3} \\,\\text{m}^2/\\text{s}, \\mathrm{tol}_1 = 10^{-4} \\,\\text{K}, \\mathrm{tol}_2 = 5 \\times 10^{-5} \\,\\text{K})$ — higher diffusivity to probe different stiffness and controller scaling.\n\nFor each test case, compute booleans indicating whether the observed ratios meet expectations within specified tolerances:\n- Report $b_{\\text{steps}}$ as $\\text{True}$ if $\\left|\\frac{R_{\\text{steps}} - \\sqrt{2}}{\\sqrt{2}}\\right| \\le 0.10$, otherwise $\\text{False}$.\n- Report $b_{\\text{error}}$ as $\\text{True}$ if $\\left|\\frac{R_{\\text{error}} - \\frac{1}{2}}{\\frac{1}{2}}\\right| \\le 0.20$, otherwise $\\text{False}$.\n\nYour program should produce a single line of output containing the six booleans, ordered by test case and metric as a comma-separated list enclosed in square brackets (e.g., \"[b1,b2,b3,b4,b5,b6]\"), where for each test case the first boolean corresponds to $b_{\\text{steps}}$ and the second to $b_{\\text{error}}$. All quantities involving time must be expressed in seconds, and all error norms must be considered in Kelvin. No angles are involved.",
            "solution": "The problem requires the construction and verification of an adaptive time-stepping algorithm for solving the one-dimensional transient heat equation. The solution is developed by following established principles of numerical analysis for partial differential equations (PDEs), specifically the method of lines combined with an embedded Runge-Kutta scheme for temporal integration.\n\n### 1. Semi-Discretization using the Method of Lines\n\nThe governing PDE is\n$$\n\\frac{\\partial T(x,t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(x,t)}{\\partial x^2}\n$$\nfor $x \\in [0, L]$ and $t \\ge 0$. The first step is to transform this single PDE into a system of coupled ordinary differential equations (ODEs) in time. This is achieved through the method of lines, where we discretize the spatial domain and approximate the spatial derivatives.\n\nA uniform grid is defined with $N$ nodes, such that the spatial coordinates are $x_i = i \\cdot \\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/(N-1)$. Let $T_i(t) = T(x_i, t)$ be the temperature at node $i$. The second spatial derivative at an interior node $x_i$ (where $i=1, \\dots, N-2$) is approximated using a second-order central difference stencil:\n$$\n\\frac{\\partial^2 T}{\\partial x^2}\\bigg|_{x=x_i} \\approx \\frac{T_{i-1}(t) - 2T_i(t) + T_{i+1}(t)}{\\Delta x^2}.\n$$\nSubstituting this into the heat equation for each interior node yields a system of $N-2$ ODEs:\n$$\n\\frac{d T_i(t)}{dt} = \\frac{\\alpha}{\\Delta x^2} \\left( T_{i-1}(t) - 2T_i(t) + T_{i+1}(t) \\right).\n$$\nThe boundary conditions are $T(0,t) = T_0(t) = 0$ and $T(L,t) = T_{N-1}(t) = 0$. These values are incorporated into the equations for the first and last interior nodes ($i=1$ and $i=N-2$).\n\nThis system can be written in matrix form as $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$, where $\\mathbf{y}(t) = [T_1(t), T_2(t), \\dots, T_{N-2}(t)]^T$ is the vector of temperatures at the interior nodes. The function $\\mathbf{f}(\\mathbf{y})$ represents the right-hand side, which is a linear operation $\\frac{\\alpha}{\\Delta x^2} \\mathbf{P} \\mathbf{y}$, where $\\mathbf{P}$ is the $(N-2) \\times (N-2)$ tridiagonal matrix representing the discrete Laplacian with homogeneous Dirichlet boundary conditions:\n$$\n\\mathbf{P} = \\begin{pmatrix}\n-2  1  0  \\dots \\\\\n1  -2  1  \\dots \\\\\n0  1  -2  \\dots \\\\\n\\vdots   \\ddots   1 \\\\\n\\dots  0  1  -2\n\\end{pmatrix}.\n$$\n\n### 2. Adaptive Time Integration with an Embedded Method\n\nTo solve the ODE system $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ from an initial state $\\mathbf{y}(0)$, we use an adaptive time-stepping method. This requires an integrator that can provide an estimate of the local truncation error at each step. An embedded Runge-Kutta method is ideal for this purpose. We select the Heun-Euler pair, which is of order $(2,1)$.\n\nAt each time step from $t_n$ to $t_{n+1} = t_n + \\Delta t$, we compute two approximations for the solution $\\mathbf{y}_{n+1}$:\n1.  **First-order (Forward Euler) solution, $\\hat{\\mathbf{y}}_{n+1}$**:\n    $$\n    \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n)\n    $$\n    $$\n    \\hat{\\mathbf{y}}_{n+1} = \\mathbf{y}_n + \\Delta t \\, \\mathbf{k}_1\n    $$\n2.  **Second-order (Heun's method) solution, $\\mathbf{y}_{n+1}$**:\n    $$\n    \\mathbf{k}_2 = \\mathbf{f}(\\hat{\\mathbf{y}}_{n+1}) = \\mathbf{f}(\\mathbf{y}_n + \\Delta t \\, \\mathbf{k}_1)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{2} (\\mathbf{k}_1 + \\mathbf{k}_2)\n    $$\n\nThe difference between these two solutions provides an estimate of the local truncation error of the lower-order method. We use this as a proxy for the error of the higher-order method. The error estimate vector is $\\mathbf{e}_{n+1} = \\mathbf{y}_{n+1} - \\hat{\\mathbf{y}}_{n+1}$, and its Euclidean norm, $E_{\\text{local}} = \\|\\mathbf{e}_{n+1}\\|_2$, is used for step-size control.\n\n### 3. Step-Size Control Algorithm\n\nThe core of the adaptive algorithm is the controller that adjusts the time step $\\Delta t$ to meet a prescribed local error tolerance, $\\mathrm{tol}$.\n\n- **Step Acceptance/Rejection**: After computing $E_{\\text{local}}$, the step is accepted if $E_{\\text{local}} \\le \\mathrm{tol}$. If the step is accepted, the time is advanced ($t_{n+1} = t_n + \\Delta t$) and the solution is updated ($\\mathbf{y}_{n+1}$ becomes the new $\\mathbf{y}_n$). If $E_{\\text{local}}  \\mathrm{tol}$, the step is rejected, time is not advanced, and the step is retried with a smaller $\\Delta t$.\n- **Step-Size Update**: The new time step, $\\Delta t_{\\text{new}}$, is calculated based on the error from the current attempt. For a method of order $p+1$ controlled by an embedded method of order $p$ (here, $p=1$), the optimal step size scales with the error as:\n$$\n\\Delta t_{\\text{new}} = S \\cdot \\Delta t_{\\text{current}} \\left( \\frac{\\mathrm{tol}}{E_{\\text{local}}} \\right)^{\\frac{1}{p+1}},\n$$\nwhere $S$ is a safety factor (typically $0.8$ - $0.9$) to prevent overly optimistic step-size increases. We choose $S=0.9$ and $p=1$, yielding:\n$$\n\\Delta t_{\\text{new}} = 0.9 \\cdot \\Delta t_{\\text{current}} \\sqrt{\\frac{\\mathrm{tol}}{E_{\\text{local}}}}.\n$$\nThis formula is used to compute the step size for the next attempt, whether the current one was accepted or rejected.\n- **Constraints**: The calculated $\\Delta t$ is clipped to lie within the range $[\\Delta t_{\\min}, \\Delta t_{\\max}]$. The minimum step size, $\\Delta t_{\\min}$, prevents the algorithm from taking excessively small steps, while the maximum, $\\Delta t_{\\max}$, is determined by the explicit stability limit of the heat equation: $\\Delta t_{\\text{stable}} = \\Delta x^2/(2\\alpha)$. We use $\\Delta t_{\\max} = 0.9 \\cdot \\Delta t_{\\text{stable}}$.\n- **Deadlock Avoidance**: The problem specifies that if the current step size is at or below $\\Delta t_{\\min}$ and the error still exceeds $\\mathrm{tol}$, the step must be accepted to prevent the simulation from stalling. This is implemented by modifying the acceptance condition to `if E_local = tol or dt = dt_min`.\n\n### 4. Verification of Convergence Rates\n\nThe effectiveness of the adaptive controller is verified by testing its convergence properties. The theory of adaptive integrators suggests that for a $p$-th order main method, the global error should be proportional to the tolerance, $E_{\\text{global}} \\propto \\mathrm{tol}$. Furthermore, the average step size $\\Delta t$ should be proportional to $\\mathrm{tol}^{1/(p+1)}$.\n\nFor our second-order method ($p=1$ controlling $p+1=2$), we expect:\n-   **Global Error**: $E_{\\text{final}} \\propto \\mathrm{tol}$. Halving the tolerance ($\\mathrm{tol}_2 = \\frac{1}{2}\\mathrm{tol}_1$) should halve the final error, so the ratio $R_{\\text{error}} = \\frac{E_{\\text{final}}(\\mathrm{tol}_2)}{E_{\\text{final}}(\\mathrm{tol}_1)}$ should be approximately $\\frac{1}{2}$.\n-   **Step Count**: The average time step $\\Delta t$ is proportional to $\\mathrm{tol}^{1/2}$. The number of steps $N_{\\text{steps}}$ to cover a fixed interval $[0, t_f]$ is inversely proportional to the average step size, so $N_{\\text{steps}} \\propto 1/\\Delta t \\propto \\mathrm{tol}^{-1/2}$. Halving the tolerance should therefore increase the step count by a factor of $(1/2)^{-1/2} = \\sqrt{2}$. The ratio $R_{\\text{steps}} = \\frac{N_{\\text{steps}}(\\mathrm{tol}_2)}{N_{\\text{steps}}(\\mathrm{tol}_1)}$ should be approximately $\\sqrt{2}$.\n\nThe implementation will simulate the system for pairs of tolerances $(\\mathrm{tol}_1, \\mathrm{tol}_2)$ and check if these theoretical ratios are met within the specified relative error bounds, confirming the correct behavior of the adaptive algorithm. Cases where the controller saturates at $\\Delta t_{\\min}$ or $\\Delta t_{\\max}$ are not expected to follow these scaling laws.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef run_simulation(alpha, tol, L, N, tf, dt_min):\n    \"\"\"\n    Solves the 1D heat equation with an adaptive step-size controller.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        tol (float): Per-step error tolerance.\n        L (float): Length of the rod.\n        N (int): Number of spatial nodes.\n        tf (float): Final time.\n        dt_min (float): Minimum allowed time step.\n\n    Returns:\n        tuple: (number of accepted steps, final global error).\n    \"\"\"\n    dx = L / (N - 1)\n    dt_max = 0.9 * (dx ** 2) / (2 * alpha)\n    \n    # Interior spatial grid\n    x_interior = np.linspace(dx, L - dx, N - 2)\n    \n    # Initial condition for interior nodes\n    y = np.sin(np.pi * x_interior / L)\n    \n    # Pre-calculate constant for RHS evaluation\n    C = alpha / (dx ** 2)\n    \n    def f(y_vec):\n        \"\"\"Computes the RHS of the ODE system dy/dt = f(y).\"\"\"\n        # Pad with zero Dirichlet boundary conditions\n        y_full = np.zeros(N)\n        y_full[1:-1] = y_vec\n        # Central difference approximation\n        dydt = C * (y_full[:-2] - 2 * y_full[1:-1] + y_full[2:])\n        return dydt\n\n    t = 0.0\n    dt = dt_min  # Start with a conservative step size\n    n_steps = 0\n    safety_factor = 0.9\n\n    while t  tf:\n        # Ensure the final step lands exactly on tf\n        if t + dt  tf:\n            dt = tf - t\n\n        # Heun-Euler embedded pair\n        k1 = f(y)\n        y_euler = y + dt * k1\n        k2 = f(y_euler)\n        y_heun = y + (dt / 2.0) * (k1 + k2)\n        \n        # Estimate local error\n        error_norm = np.linalg.norm(y_heun - y_euler)\n        # Avoid division by zero if error is nil\n        if error_norm  1e-16:\n            error_norm = 1e-16\n\n        # Step acceptance condition\n        accept_step = (error_norm = tol) or (dt = dt_min)\n\n        if accept_step:\n            t += dt\n            y = y_heun\n            n_steps += 1\n        \n        # Calculate new step size for the next attempt (or next step)\n        # Based on the error of the current attempt, regardless of acceptance\n        dt_new = safety_factor * dt * (tol / error_norm)**0.5\n        \n        # Clip the new step size to the defined bounds\n        dt = min(dt_max, max(dt_min, dt_new))\n\n    # Compute final global error against the exact solution\n    y_exact_tf = np.exp(-alpha * (np.pi/L)**2 * tf) * np.sin(np.pi * x_interior / L)\n    E_final = np.linalg.norm(y - y_exact_tf)\n    \n    return n_steps, E_final\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n    # Fixed physical and numerical parameters\n    L = 1.0\n    N = 50\n    tf = 1.0\n    dt_min = 1.0e-3\n\n    # Test suite: (alpha, tol_1, tol_2)\n    test_cases = [\n        (1.0e-4, 1.0e-4, 5.0e-5),\n        (1.0e-4, 1.0e-10, 5.0e-11),\n        (1.0e-3, 1.0e-4, 5.0e-5),\n    ]\n\n    all_booleans = []\n\n    for alpha, tol1, tol2 in test_cases:\n        # Run simulation for the first tolerance\n        N_steps1, E_final1 = run_simulation(alpha, tol1, L, N, tf, dt_min)\n        \n        # Run simulation for the second tolerance\n        N_steps2, E_final2 = run_simulation(alpha, tol2, L, N, tf, dt_min)\n\n        # Compute ratios\n        # Avoid division by zero if a result is zero\n        R_steps = N_steps2 / N_steps1 if N_steps1  0 else float('inf')\n        R_error = E_final2 / E_final1 if E_final1  0 else float('inf')\n        \n        # Verify step count ratio against theoretical sqrt(2)\n        sqrt2 = math.sqrt(2)\n        b_steps = abs((R_steps - sqrt2) / sqrt2) = 0.10\n        all_booleans.append(b_steps)\n\n        # Verify final error ratio against theoretical 0.5\n        b_error = abs((R_error - 0.5) / 0.5) = 0.20\n        all_booleans.append(b_error)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, all_booleans))}]\")\n\nsolve()\n```"
        }
    ]
}