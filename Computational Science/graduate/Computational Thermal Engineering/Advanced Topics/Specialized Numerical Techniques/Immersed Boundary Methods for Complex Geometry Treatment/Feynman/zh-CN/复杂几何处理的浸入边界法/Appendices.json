{
    "hands_on_practices": [
        {
            "introduction": "在锐利界面浸入边界法中，一项核心任务是在非贴体网格上精确地施加边界条件。本练习采用“制造解方法”(Method of Manufactured Solutions, MMS)，通过一个一维热传导问题来验证两种不同的虚拟单元(ghost-cell)处理策略的精度。通过将数值误差与理论预期进行比较，您将能严格地确认您的离散格式是否达到了预期的精度阶数，这是计算代码开发中的一项基本技能。",
            "id": "3961938",
            "problem": "考虑一个用于稳态热传导中沉浸边界法 (IBM) 鬼点强制的一维验证问题。其基本依据是傅里叶定律和稳态热传导，这两者共同推出了拉普拉斯方程，即温度场的二阶空间导数与源项相平衡。在一维局部界面法向坐标下，这简化为温度的二阶导数。我们关注在狄利克雷边界条件下，使用鬼点强制方法在临近界面的流体节点处对二阶导数进行的离散近似。\n\n一个制造的光滑温度场被指定为法向坐标 $s$ 的函数，表示为\n$$\nT(s) = e^{s} + 0.3 \\sin(3 s),\n$$\n其精确的二阶导数为\n$$\nT''(s) = e^{s} - 2.7 \\sin(3 s).\n$$\n在 $s = 0$ 处有一个沉浸界面，其狄利克雷边界条件 $T(0)$ 由制造解给出。沿 $s$ 定义一个间距为 $\\Delta n$ 的均匀网格，临近界面的流体节点位于 $s = d$ 处，其中 $d = \\alpha \\Delta n$，而 $\\alpha \\in (0,1)$ 是从界面到流体节点沿网格间距的分数距离。鬼点位于固体内部，坐标为 $s = d - \\Delta n  0$。离界面更远的下一个流体节点位于 $s = d + \\Delta n > 0$。\n\n将要检验两种鬼点强制策略：\n\n- 线性鬼点强制：通过在鬼点和流体节点之间的线段上进行线性插值来确定鬼点值，使得在界面 $s = 0$ 处的插值等于狄利克雷边界值。此方法仅使用界面值和相邻流体值，并以与这两个节点之间的线性剖面一致的方式强制执行边界条件。\n\n- 二次鬼点强制：通过拟合一个穿过法线上三个点的二次多项式来确定鬼点值：位于 $s = -d$ 的镜像点 $I$，位于 $s = 0$ 的边界点 $B$，以及位于 $s = d$ 的流体点 $P$。然后，在鬼点位置 $s = d - \\Delta n$ 处评估该二次拟合，以与跨边界的二阶剖面一致的方式重构鬼点值。\n\n对于每种强制策略，位于 $s = d$ 的临近界面流体节点处二阶导数的离散近似由中心差分公式定义，该公式使用位于 $s = d - \\Delta n$ 的鬼点值和位于 $s = d + \\Delta n$ 的流体节点值：\n$$\nD_2 = \\frac{ T(d - \\Delta n)_{\\text{ghost}} - 2 T(d) + T(d + \\Delta n) }{ \\Delta n^2 }.\n$$\n在同一位置的精确二阶导数为 $T''(d)$，绝对误差为\n$$\nE(\\Delta n; \\alpha) = \\left| D_2 - T''(d) \\right|.\n$$\n\n您的任务是严格按照上述定义实现两种鬼点强制策略，计算一系列网格间距 $\\Delta n$ （对应于网格尺寸 $N \\in \\{32,64,128,256,512,1024\\}$，因此 $\\Delta n = 1/N$）下的误差 $E(\\Delta n; \\alpha)$，并通过对 $\\log(E)$ 与 $\\log(\\Delta n)$ 的关系进行最小二乘法线性拟合，取其斜率来估计每种强制策略的观测精度阶 $p$。线性策略的预期精度阶为 $p = 1$，二次策略的预期精度阶为 $p = 2$。\n\n设计一个测试套件，覆盖一系列界面位置，包括类边缘情况：\n\n- 对于使用线性鬼点强制的 $\\alpha \\in \\{0.05, 0.1, 0.5, 0.9, 0.95\\}$。\n- 对于使用二次鬼点强制的 $\\alpha \\in \\{0.05, 0.1, 0.5, 0.9, 0.95\\}$。\n\n对于每个测试用例，计算观测阶数 $p$，并返回一个布尔值，指示观测阶数是否在预期阶数（线性为 $p = 1$，二次为 $p = 2$）的 $\\pm 0.2$ 容差范围内。最终输出是没有物理单位的布尔值。\n\n您的程序应生成单行输出，其中包含按上述测试套件顺序列出的结果，格式为方括号内以逗号分隔的列表（例如，“[result1,result2,...]”），即：\n$$\n[\\text{linear } \\alpha = 0.05, \\text{linear } \\alpha = 0.1, \\text{linear } \\alpha = 0.5, \\text{linear } \\alpha = 0.9, \\text{linear } \\alpha = 0.95, \\text{quadratic } \\alpha = 0.05, \\text{quadratic } \\alpha = 0.1, \\text{quadratic } \\alpha = 0.5, \\text{quadratic } \\alpha = 0.9, \\text{quadratic } \\alpha = 0.95].\n$$",
            "solution": "该问题是有效的。这是一个适定的、有科学依据的计算热工学验证练习，没有任何指定的缺陷。任务是实现并分析应用于一维稳态热传导问题的沉浸边界法的两种不同鬼点强制策略。\n\n此分析的基础是一个制造的温度场解，由下式给出\n$$\nT(s) = e^{s} + 0.3 \\sin(3 s).\n$$\n相应的精确二阶导数，它在稳态热传导方程中代表了源项（不计常数因子），是\n$$\nT''(s) = e^{s} - 2.7 \\sin(3 s).\n$$\n一个带有狄利克雷条件 $T(0)$ 的沉浸边界位于 $s=0$。计算网格是均匀的，间距为 $\\Delta n$。临近界面的流体节点位于 $s=d$，其中 $d = \\alpha \\Delta n$，$\\alpha \\in (0,1)$。该节点处温度的二阶导数 $T''(d)$ 使用三点中心差分格式进行近似：\n$$\nD_2 = \\frac{ T_{ghost}(d - \\Delta n) - 2 T(d) + T(d + \\Delta n) }{ \\Delta n^2 }.\n$$\n这里，$T(d)$ 和 $T(d + \\Delta n)$ 是流体节点处的精确温度，$T_{ghost}(d - \\Delta n)$ 是鬼点 $(s = d - \\Delta n)$ 处的温度，其值必须被重构以强制执行边界条件。目标是通过分析绝对误差 $E(\\Delta n; \\alpha) = | D_2 - T''(d) |$ 作为 $\\Delta n$ 的函数，来确定两种重构方案的精度阶 $p$。\n\n### 线性鬼点强制\n\n此策略通过假设在位于 $s = d$ 的相邻流体节点和位于 $s = d - \\Delta n$ 的鬼点之间存在线性温度剖面来确定鬼点值。该线性剖面必须外插到边界位置 $s=0$ 时等于给定的边界值 $T(0)$。从几何上看，这意味着点 $(0, T(0))$ 必须与点 $(d, T(d))$ 和 $(d-\\Delta n, T_{ghost})$ 共线。该共线条件可表示为：\n$$\n\\frac{T(d) - T(0)}{d - 0} = \\frac{T_{ghost} - T(d)}{(d - \\Delta n) - d}\n$$\n将 $d = \\alpha \\Delta n$ 代入并化简：\n$$\n\\frac{T(d) - T(0)}{\\alpha \\Delta n} = \\frac{T_{ghost} - T(d)}{-\\Delta n}\n$$\n$$\n-(T(d) - T(0)) = \\alpha(T_{ghost} - T(d))\n$$\n求解 $T_{ghost}$，可得：\n$$\nT_{ghost} = T(d) - \\frac{T(d) - T(0)}{\\alpha} = T(d)\\left(1-\\frac{1}{\\alpha}\\right) + \\frac{T(0)}{\\alpha}\n$$\n此方法使用一阶精度的信息来强制执行边界条件，因此得到的二阶导数近似预计为一阶精度，即 $p=1$。\n\n### 二次鬼点强制\n\n这种高阶策略通过将二次多项式 $P(s) = as^2 + bs + c$ 拟合到三个特定点来重构鬼点值。选择这些点是为了提供跨边界温度场的二阶精度表示：\n1.  临近界面的流体点：$P(d, T(d))$。\n2.  边界点本身：$B(0, T(0))$。\n3.  一个相对于边界与流体点对称的“镜像”点：$I(-d, T(-d))$。\n\n多项式的系数通过求解以下方程组确定：\n$$\n\\begin{align*} T(d) = ad^2 + bd + c \\\\ T(0) = c \\\\ T(-d) = ad^2 - bd + c \\end{align*}\n$$\n从第二个方程，我们立即得到 $c = T(0)$。将第一个和第三个方程相加得到 $T(d) + T(-d) = 2ad^2 + 2c$，从而得出系数 $a$：\n$$\na = \\frac{T(d) + T(-d) - 2T(0)}{2d^2}.\n$$\n从第一个方程中减去第三个方程得到 $T(d) - T(-d) = 2bd$，从而得出系数 $b$：\n$$\nb = \\frac{T(d) - T(-d)}{2d}.\n$$\n然后，通过在鬼点位置 $s_{ghost} = d - \\Delta n$ 处评估该多项式，可以找到鬼点温度 $T_{ghost}$：\n$$\nT_{ghost} = P(d - \\Delta n) = a(d - \\Delta n)^2 + b(d - \\Delta n) + c.\n$$\n由于此重构使用二次多项式，因此得到的二阶导数近似预计为二阶精度，即 $p=2$。\n\n### 精度阶验证\n\n对于每种策略和每个指定的 $\\alpha$ 值，通过数值收敛性研究来确定精度阶 $p$。绝对误差 $E$ 是为一系列逐渐加密的网格间距 $\\Delta n = 1/N$ 计算的，其中 $N \\in \\{32, 64, 128, 256, 512, 1024\\}$。误差与网格间距之间的理论关系是 $E \\approx C (\\Delta n)^p$，其中 $C$ 是一个常数。取对数可得线性关系：\n$$\n\\log(E) \\approx \\log(C) + p \\log(\\Delta n).\n$$\n观测精度阶 $p$ 是通过使用线性最小二乘回归，对数据点 $(\\log(\\Delta n), \\log(E))$ 的最佳拟合线的斜率来计算的。如果计算出的阶数 $p$ 在理论预期阶数（线性为 $1$，二次为 $2$）的 $\\pm 0.2$ 容差范围内，则每个测试用例的验证成功。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies linear and quadratic ghost-cell enforcement\n    strategies for an immersed boundary method in 1D heat conduction.\n    \"\"\"\n\n    # Define the manufactured solution and its exact second derivative\n    def T(s: float) - float:\n        \"\"\"Manufactured temperature field T(s).\"\"\"\n        return np.exp(s) + 0.3 * np.sin(3 * s)\n\n    def T_double_prime(s: float) - float:\n        \"\"\"Exact second derivative T''(s).\"\"\"\n        return np.exp(s) - 2.7 * np.sin(3 * s)\n\n    # Test suite parameters as specified in the problem statement\n    test_cases = [\n        # (alpha, enforcement_type, expected_order)\n        (0.05, 'linear', 1.0),\n        (0.1,  'linear', 1.0),\n        (0.5,  'linear', 1.0),\n        (0.9,  'linear', 1.0),\n        (0.95, 'linear', 1.0),\n        (0.05, 'quadratic', 2.0),\n        (0.1,  'quadratic', 2.0),\n        (0.5,  'quadratic', 2.0),\n        (0.9,  'quadratic', 2.0),\n        (0.95, 'quadratic', 2.0),\n    ]\n\n    # Grid sizes for the convergence study\n    Ns = np.array([32, 64, 128, 256, 512, 1024])\n    delta_ns = 1.0 / Ns\n\n    results = []\n    tolerance = 0.2\n\n    for alpha, enforcement_type, p_expected in test_cases:\n        log_delta_ns = np.log(delta_ns)\n        log_errors = []\n\n        for dn in delta_ns:\n            # Distance from interface to adjacent fluid node\n            d = alpha * dn\n            \n            # Key spatial locations\n            s_adj = d             # Interface-adjacent fluid node\n            s_next = d + dn       # Next fluid node\n            s_bdy = 0.0           # Boundary location\n            s_ghost = d - dn      # Ghost node location\n\n            # Exact temperatures at required locations\n            T_adj = T(s_adj)\n            T_next = T(s_next)\n            T_bdy = T(s_bdy)\n\n            T_ghost = 0.0\n            if enforcement_type == 'linear':\n                # Linear enforcement derived from T(0) = (1-alpha)*T(d) + alpha*T_ghost\n                # which represents linear extrapolation.\n                # Solved for T_ghost: T_ghost = (T(0) - (1-alpha)*T(d)) / alpha\n                if abs(alpha) > 1e-14:\n                    T_ghost = (T_bdy - (1.0 - alpha) * T_adj) / alpha\n                else: # Fallback to avoid division by zero\n                    T_ghost = T_adj # A simple, though inaccurate, fallback\n            \n            elif enforcement_type == 'quadratic':\n                # Quadratic enforcement: Fit P(s) = as^2 + bs + c through\n                # points at s = -d, 0, d.\n                s_img = -d\n                T_img = T(s_img)\n                \n                # Coefficients of the quadratic polynomial P(s)\n                c_quad = T_bdy\n                if abs(d) > 1e-14: # Avoid division by zero\n                    a_quad = (T_adj + T_img - 2.0 * T_bdy) / (2.0 * d**2)\n                    b_quad = (T_adj - T_img) / (2.0 * d)\n                else: # Should not happen with given test cases\n                    # Fallback to Taylor series for a and b if d is tiny\n                    a_quad = 0.5 * T_double_prime(0.0) # T''(0)/2!\n                    b_quad = (np.exp(0.0) + 0.3 * 3.0 * np.cos(0.0)) # T'(0)\n                \n                # Evaluate the polynomial at the ghost node location\n                T_ghost = a_quad * s_ghost**2 + b_quad * s_ghost + c_quad\n            \n            # Approximate the second derivative using the central difference formula\n            D2 = (T_ghost - 2.0 * T_adj + T_next) / (dn**2)\n\n            # Exact second derivative at the adjacent node\n            T_pp_adj = T_double_prime(s_adj)\n\n            # Compute the absolute error\n            error = np.abs(D2 - T_pp_adj)\n            log_errors.append(np.log(error))\n\n        # Perform linear regression on log-log data to find the observed order\n        log_errors = np.array(log_errors)\n        p_observed, _ = np.polyfit(log_delta_ns, log_errors, 1)\n\n        # Verify if the observed order is within the specified tolerance\n        is_valid = np.abs(p_observed - p_expected) = tolerance\n        results.append(is_valid)\n\n    # Format the boolean results into the required string format\n    result_str = [str(res).lower() for res in results]\n    print(f\"[{','.join(result_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当浸入边界切割笛卡尔网格时，会产生体积远小于常规单元的“小单元”(small cells)，这在显式时间积分格式中会导致严苛的稳定性约束。本练习将探讨两种守恒的稳定性策略——通量重分配(flux redistribution)和单元合并(cell merging)——来解决这一难题。掌握这些策略对于开发稳健且高效的瞬态问题浸入边界求解器至关重要，您将通过实践评估它们在维持全局能量守恒方面的效果。",
            "id": "3961816",
            "problem": "考虑一个一维瞬态热传导问题，该问题发生于一个嵌入在较大笛卡尔网格内的流体子域中，并使用浸入边界法（IBM）进行处理。流体中的控制能量方程是热扩散方程，由能量守恒和傅里叶定律推导得出：$$\\frac{\\partial T}{\\partial t} = \\kappa \\frac{\\partial^2 T}{\\partial x^2},$$ 其中 $T$ 是温度，$\\kappa = \\frac{k}{\\rho c}$ 是热扩散率，$k$ 是热导率，$\\rho$ 是密度，$c$ 是比热容。设横截面积为 $A = 1\\,\\mathrm{m}^2$，因此体积热容为 $C_v = \\rho c$，单位为 $\\mathrm{J}/(\\mathrm{m}^3\\cdot\\mathrm{K})$，对于长度为 $l$ 的控制体积，其能量 $U$（单位为 $\\mathrm{J}$）为 $U = C_v \\, l \\, T$。\n\n在长度为 $L = 1\\,\\mathrm{m}$ 的区间上使用有限体积法进行离散化，该区间被划分为 $N$ 个均匀基础尺寸为 $\\Delta x = L/N$ 的名义单元。一个浸入边界切割第一个单元，使其流体长度为 $l_0 = \\alpha \\Delta x$（其中 $0  \\alpha \\le 1$），而其余单元的流体长度为 $l_i = \\Delta x$（$i \\ge 1$）。位于 $x=0$ 的左边界和位于 $x=L$ 的右边界均为绝热边界，施加零热通量条件。单元 $i$ 和单元 $i+1$ 之间的离散内界面位于单元中心的中间位置，从而得到有效的中心到中心距离 $$d_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(l_i + l_{i+1}\\right)。$$ 通过内界面 $i+\\frac{1}{2}$ 的离散扩散热通量由下式给出 $$F_{i+\\frac{1}{2}} = -k A \\frac{T_{i+1} - T_i}{d_{i+\\frac{1}{2}}},$$ 单元 $i$ 的半离散守恒更新方程为 $$\\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(C_v \\, l_i \\, T_i\\right) = F_{i-\\frac{1}{2}} - F_{i+\\frac{1}{2}},$$ 由于是绝热边界，$F_{-\\frac{1}{2}} = 0$ 且 $F_{N-\\frac{1}{2}} = 0$。\n\n$l_0 \\ll \\Delta x$ 的小切割单元会使显式时间步进不稳定。在浸入边界处理中，常用的两种稳定化策略是：修改小切割单元邻近界面的通量（通量重分布或裁剪），以及将小切割单元与相邻的较大单元合并（单元合并），同时保持全局守恒。您的任务是实现这两种策略，并评估它们对全局能量守恒的影响。\n\n从能量守恒和傅里叶定律出发，并使用上述有限体积框架：\n- 根据界面通量和单元体积，推导 $T_i$ 的一致性显式欧拉更新格式。\n- 实现策略 A（通量重分布/裁剪）：基于扩散的局部显式稳定性要求，使用一个稳定化因子修改小切割单元邻近的界面通量，该因子对称地应用于受影响界面的两侧，以保持逐界面守恒。\n- 实现策略 B（单元合并）：将前两个单元视为一个合并簇，总长度为 $l_0 + l_1$；抑制它们之间的内部通量；仅使用其外界面来驱动该簇的能量变化；并将该簇的能量变化按体积比例分配给其组成单元，以维持全局守恒。\n- 使用绝热边界条件，因此理论上流体子域中的总能量应随时间保持恒定。\n\n使用以下物理参数：$k = 1\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$，$C_v = 1000\\,\\mathrm{J}/(\\mathrm{m}^3\\cdot\\mathrm{K})$，$A = 1\\,\\mathrm{m}^2$。使用初始温度场 $$T(x) = \\sin(2\\pi x),$$ 在给定非均匀网格的单元中心进行采样。使用显式欧拉法以时间步长 $\\Delta t = 0.01\\,\\mathrm{s}$ 向前推进 $n = 100$ 步。对于每次模拟，计算运行结束时的全局绝对能量误差（单位为焦耳），其定义为 $$E_\\mathrm{err} = \\left| \\sum_{i=0}^{N-1} C_v l_i T_i^{(n)} - \\sum_{i=0}^{N-1} C_v l_i T_i^{(0)} \\right|.$$\n\n测试套件：\n- 测试 1（理想情况，无切割）：$N = 50$，$\\alpha = 1$，策略 = 无。由于绝热边界和守恒性，预期能量误差接近于零。\n- 测试 2（中等切割，通量重分布）：$N = 50$，$\\alpha = 0.05$，策略 = 通量重分布/裁剪。评估 $E_\\mathrm{err}$。\n- 测试 3（严重切割，单元合并）：$N = 50$，$\\alpha = 0.01$，策略 = 单元合并。评估 $E_\\mathrm{err}$。\n- 测试 4（极端切割，通量重分布）：$N = 50$，$\\alpha = 0.001$，策略 = 通量重分布/裁剪。评估 $E_\\mathrm{err}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4]”）。每个结果必须是一个浮点数，给出相应测试用例的绝对能量误差 $E_\\mathrm{err}$（单位为焦耳），使用上述参数值和所述策略计算。如果涉及角度，必须以弧度为单位。所有能量均以焦耳表示。本问题不要求百分比。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它提出了一个计算热工学中的适定问题，没有科学或逻辑上的矛盾，尽管它在总域长度方面存在轻微的模糊性（这在浸入边界法的文献中很常见），但这并不妨碍问题的可解性或核心目标。任务是实现并评估应用于瞬态热扩散问题的两种常见浸入边界法（IBM）稳定化策略，重点关注它们对全局能量守恒的影响。所有提供的数据和条件都足以且一致地推导出解决方案。\n\n一维热扩散的控制偏微分方程是：\n$$ \\frac{\\partial T}{\\partial t} = \\kappa \\frac{\\partial^2 T}{\\partial x^2} $$\n其中 $\\kappa = k / (\\rho c)$ 是热扩散率。该问题使用有限体积法进行公式化。对于长度为 $l_i$ 的控制体积（单元）$i$，能量守恒定律的半离散形式为：\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(C_v \\, l_i \\, T_i\\right) = F_{i-\\frac{1}{2}} - F_{i+\\frac{1}{2}} $$\n其中 $C_v = \\rho c$ 是体积热容，$T_i$ 是单元 $i$ 中的平均温度，$F_{i\\pm\\frac{1}{2}}$ 是穿过单元界面的热通量。由于 $C_v$ 和 $l_i$ 不随时间变化，我们可以写成：\n$$ C_v l_i \\frac{\\mathrm{d}T_i}{\\mathrm{d}t} = F_{i-\\frac{1}{2}} - F_{i+\\frac{1}{2}} $$\n应用显式欧拉时间积分方案，其中时间导数近似为 $\\frac{\\mathrm{d}T_i}{\\mathrm{d}t} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t}$，我们推导出新时间步 $n+1$ 时温度 $T_i$ 的更新规则：\n$$ \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\frac{1}{C_v l_i} \\left( F_{i-\\frac{1}{2}}^n - F_{i+\\frac{1}{2}}^n \\right) $$\n$$ T_i^{n+1} = T_i^n + \\frac{\\Delta t}{C_v l_i} \\left( F_{i-\\frac{1}{2}}^n - F_{i+\\frac{1}{2}}^n \\right) $$\n界面 $i+\\frac{1}{2}$ 上的热通量 $F_{i+\\frac{1}{2}}^n$ 基于傅里叶定律计算，使用时间层 $n$ 的温度：\n$$ F_{i+\\frac{1}{2}}^n = -k A \\frac{T_{i+1}^n - T_i^n}{d_{i+\\frac{1}{2}}} $$\n其中 $d_{i+\\frac{1}{2}} = \\frac{1}{2}(l_i + l_{i+1})$ 是单元 $i$ 和单元 $i+1$ 中心之间的距离。绝热边界条件意味着在区域两端通量为零：$F_{-\\frac{1}{2}} = 0$ 且 $F_{N-\\frac{1}{2}} = 0$。\n\n该数值方案的一个关键特征是其遵守全局能量守恒。区域中总能量 $E_\\mathrm{total} = \\sum_{i=0}^{N-1} C_v l_i T_i$ 的变化率为：\n$$ \\frac{\\mathrm{d}E_\\mathrm{total}}{\\mathrm{d}t} = \\sum_{i=0}^{N-1} C_v l_i \\frac{\\mathrm{d}T_i}{\\mathrm{d}t} = \\sum_{i=0}^{N-1} \\left( F_{i-\\frac{1}{2}} - F_{i+\\frac{1}{2}} \\right) $$\n这形成了一个伸缩和：$(F_{-\\frac{1}{2}} - F_{\\frac{1}{2}}) + (F_{\\frac{1}{2}} - F_{\\frac{3}{2}}) + \\dots + (F_{N-\\frac{3}{2}} - F_{N-\\frac{1}{2}}) = F_{-\\frac{1}{2}} - F_{N-\\frac{1}{2}}$。考虑到绝热边界，该和为 $0 - 0 = 0$。因此，理论上总能量应保持不变。\n\n显式格式的稳定性约束使得稳定化策略成为必需，对于小切割单元（单元 0）而言，该约束尤其严格。\n\n**策略 A：通量重分布/裁剪**\n显式欧拉方案的稳定性要求时间步长 $\\Delta t$ 满足每个单元的局部 Courant-Friedrichs-Lewy (CFL) 条件。对于邻近绝热边界的小切割单元 0，更新规则 $T_0^{n+1} = T_0^n - \\frac{\\Delta t}{C_v l_0} F_{0+\\frac{1}{2}}^n$ 导出一个稳定性极限。代入通量表达式可得：\n$$ T_0^{n+1} = T_0^n \\left( 1 - \\frac{\\Delta t \\cdot k A}{C_v l_0 d_{0+\\frac{1}{2}}} \\right) + \\dots $$\n为保证稳定性，$T_0^n$ 的系数必须为非负，这要求 $\\Delta t \\le \\frac{C_v l_0 d_{0+\\frac{1}{2}}}{k A}$。这个局部时间步长限制，我们称之为 $\\Delta t_{\\mathrm{loc},0}$，当 $l_0 \\to 0$ 时会变得非常小。\n为了使用一个固定的、较大的 $\\Delta t$，通量 $F_{0+\\frac{1}{2}}$ 通过一个稳定化因子 $s$ 进行缩放：\n$$ s = \\min\\left(1.0, \\frac{\\Delta t_{\\mathrm{loc},0}}{\\Delta t}\\right) = \\min\\left(1.0, \\frac{C_v l_0 d_{0+\\frac{1}{2}}}{k A \\Delta t}\\right) $$\n修正后的通量 $F'_{0+\\frac{1}{2}} = s \\cdot F_{0+\\frac{1}{2}}$ 用于单元 0 和单元 1 的更新方程。这保持了逐界面守恒（从单元 0 流出的通量等于流入单元 1 的通量），并因此保持了全局能量守恒，因为伸缩和的性质仍然完整。\n\n**策略 B：单元合并**\n此策略将小单元 0 与其相邻的单元 1 合并成一个单一的计算簇。\n1. 它们之间的内部通量设置为零：$F_{0+\\frac{1}{2}} = 0$。\n2. 合并簇的能量 $E_m = E_0 + E_1 = C_v l_0 T_0 + C_v l_1 T_1$ 根据其外部通量进行更新，这些通量是 $F_{-\\frac{1}{2}} = 0$（在边界处）和 $F_{1+\\frac{1}{2}}$（在与单元 2 的界面处）。该簇的能量变化率为 $\\frac{\\mathrm{d}E_m}{\\mathrm{d}t} = F_{-\\frac{1}{2}} - F_{1+\\frac{1}{2}} = -F_{1+\\frac{1}{2}}$。\n3. 在一个时间步长内，簇的总能量变化 $\\Delta E_m = -\\Delta t \\cdot F_{1+\\frac{1}{2}}^n$ 按体积（或长度，因为面积是恒定的）比例分配给单元 0 和 1：\n$$ \\Delta E_0 = \\Delta E_m \\frac{l_0}{l_0 + l_1}, \\quad \\Delta E_1 = \\Delta E_m \\frac{l_1}{l_0 + l_1} $$\n然后更新温度：\n$$ T_0^{n+1} = T_0^n + \\frac{\\Delta E_0}{C_v l_0} = T_0^n + \\frac{\\Delta E_m}{C_v (l_0 + l_1)} $$\n$$ T_1^{n+1} = T_1^n + \\frac{\\Delta E_1}{C_v l_1} = T_1^n + \\frac{\\Delta E_m}{C_v (l_0 + l_1)} $$\n这等同于对簇中的两个单元施加相同的温度增量。该方法本质上也是守恒的。系统的总能量变化是所有单元（或簇）变化的总和，由于内部通量的抵消，该总和再次通过伸缩求和变为零。\n\n两种策略都被设计为完全守恒。因此，计算出的绝对能量误差 $E_\\mathrm{err}$ 应该接近于零，仅受浮点运算精度的限制，这证明了这些方法在确保数值稳定性的同时保持全局守恒的有效性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D transient heat conduction problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        (50, 1.0, \"none\"),\n        (50, 0.05, \"flux_redistribution/clipping\"),\n        (50, 0.01, \"cell_merging\"),\n        (50, 0.001, \"flux_redistribution/clipping\"),\n    ]\n\n    results = []\n    for N, alpha, strategy in test_cases:\n        result = simulate_case(N, alpha, strategy)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef simulate_case(N, alpha, strategy):\n    \"\"\"\n    Runs a single simulation case and returns the absolute energy error.\n\n    Args:\n        N (int): Number of nominal cells.\n        alpha (float): Fraction of the first cell's length.\n        strategy (str): Stabilization strategy ('none', 'flux_redistribution/clipping', 'cell_merging').\n\n    Returns:\n        float: Absolute global energy error in joules.\n    \"\"\"\n    # Physical and numerical parameters\n    L = 1.0\n    k = 1.0\n    Cv = 1000.0\n    A = 1.0\n    dt = 0.01\n    n_steps = 100\n\n    # Grid setup\n    dx = L / N\n    l = np.full(N, dx, dtype=np.float64)\n    l[0] = alpha * dx\n\n    # Cell center positions\n    x_coords = np.zeros(N, dtype=np.float64)\n    x_coords[0] = l[0] / 2.0\n    cell_left_edge = l[0]\n    for i in range(1, N):\n        x_coords[i] = cell_left_edge + l[i] / 2.0\n        cell_left_edge += l[i]\n\n    # Distances between cell centers\n    d = np.zeros(N - 1, dtype=np.float64)\n    for i in range(N - 1):\n        d[i] = (l[i] + l[i + 1]) / 2.0\n\n    # Initial condition\n    T_current = np.sin(2 * np.pi * x_coords, dtype=np.float64)\n\n    # Calculate initial total energy\n    E_initial = np.sum(Cv * l * T_current)\n\n    # Time-stepping loop\n    for _ in range(n_steps):\n        T_new = np.copy(T_current)\n\n        # Calculate fluxes at all internal faces (F[i] corresponds to face i-1/2)\n        # F[0] is F[-1/2], F[1] is F[1/2], etc.\n        F = np.zeros(N + 1, dtype=np.float64)\n        for i in range(N - 1):\n            F[i + 1] = -k * A * (T_current[i + 1] - T_current[i]) / d[i]\n\n        # Apply stabilization strategy\n        if strategy == \"flux_redistribution/clipping\":\n            # stability limit for cell 0\n            if d.size > 0:\n                dt_loc_0 = (Cv * l[0] * d[0]) / (k * A)\n                s = min(1.0, dt_loc_0 / dt)\n                F[1] *= s\n            \n            # General update for all cells\n            # Cell 0 (left boundary, flux F[-1/2] = F[0] = 0)\n            net_flux_rate_0 = F[0] - F[1]\n            T_new[0] = T_current[0] + (dt / (Cv * l[0])) * net_flux_rate_0\n            # Internal cells\n            for i in range(1, N - 1):\n                net_flux_rate_i = F[i] - F[i + 1]\n                T_new[i] = T_current[i] + (dt / (Cv * l[i])) * net_flux_rate_i\n            # Cell N-1 (right boundary, flux F[N-1/2] = F[N] = 0)\n            if N > 1:\n                net_flux_rate_N_1 = F[N - 1] - F[N]\n                T_new[N-1] = T_current[N-1] + (dt / (Cv * l[N-1])) * net_flux_rate_N_1\n\n        elif strategy == \"cell_merging\":\n            # Suppress flux between cell 0 and 1\n            F[1] = 0.0\n            \n            # Energy change of the merged cluster (0, 1) due to external flux F[1+1/2] = F[2]\n            flux_out_of_cluster = F[2]\n            delta_E_m = dt * (F[0] - flux_out_of_cluster) # F[0]=0\n            \n            # Distribute temp change to cells 0 and 1\n            l_m = l[0] + l[1]\n            delta_T_cluster = delta_E_m / (Cv * l_m)\n            T_new[0] = T_current[0] + delta_T_cluster\n            T_new[1] = T_current[1] + delta_T_cluster\n            \n            # Update other cells normally\n            for i in range(2, N - 1):\n                net_flux_rate_i = F[i] - F[i + 1]\n                T_new[i] = T_current[i] + (dt / (Cv * l[i])) * net_flux_rate_i\n            # Update cell N-1\n            if N > 2:\n                net_flux_rate_N_1 = F[N-1] - F[N]\n                T_new[N-1] = T_current[N-1] + (dt / (Cv * l[N-1])) * net_flux_rate_N_1\n\n        else: # \"none\" strategy\n            # General update for all cells\n            # Cell 0 (left boundary, F[-1/2]=F[0]=0)\n            net_flux_rate_0 = F[0] - F[1]\n            T_new[0] = T_current[0] + (dt / (Cv * l[0])) * net_flux_rate_0\n            # Internal cells\n            for i in range(1, N - 1):\n                net_flux_rate_i = F[i] - F[i + 1]\n                T_new[i] = T_current[i] + (dt / (Cv * l[i])) * net_flux_rate_i\n            # Cell N-1 (right boundary, F[N-1/2]=F[N]=0)\n            if N > 1:\n                net_flux_rate_N_1 = F[N-1] - F[N]\n                T_new[N-1] = T_current[N-1] + (dt / (Cv * l[N-1])) * net_flux_rate_N_1\n            \n        T_current = T_new\n\n    # Final Energy\n    E_final = np.sum(Cv * l * T_current)\n    \n    # Absolute Energy Error\n    E_err = np.abs(E_final - E_initial)\n    \n    return E_err\n\nsolve()\n```"
        },
        {
            "introduction": "浸入边界法本质上在两个参考系中运行：用于固定网格的欧拉框架和用于边界的拉格朗日框架。本练习利用矢量分析中的一个基本定律——散度定理，来验证热量守恒。您将通过两种不同的方法计算通过浸入边界的总热通量：一种是在拉格朗日框架中直接进行表面积分，另一种是在欧拉框架中对封闭区域进行体积积分。通过协调这两种方法的结果，您将学习一种强大的数值方法验证技术，并加深对连续物理模型及离散近似之间相互作用的理解。",
            "id": "3961812",
            "problem": "本题要求您使用两种基于热传导第一性原理的互补公式，计算穿过嵌入均匀笛卡尔网格内的光滑浸入闭合曲线的总传导热量。该设定模拟了一个二维稳态传导过程，其中空间变化的温度场在欧拉网格上采样，而圆形的浸入边界则通过拉格朗日求积法处理。目标是量化并协调通过欧拉控制体方法和拉格朗日曲面积分方法得到的总热传递，并在两种描述之间使用一致的插值，这是浸入边界法 (IBM) 中的标准做法。\n\n基本原理：\n- 傅里叶热传导定律：热通量矢量为 $ \\mathbf{q} = -k \\nabla T $，其中 $ k $ 是热导率，$ T $ 是温度场。\n- 二维散度定理（高斯定理）：对于任意足够光滑的矢量场 $ \\mathbf{F} $ 和一个区域 $ \\Omega $，其边界为 $ \\partial \\Omega $，外向单位法向量为 $ \\mathbf{n} $，则有\n$$\n\\int_{\\partial \\Omega} \\mathbf{F} \\cdot \\mathbf{n} \\, \\mathrm{d}s = \\int_{\\Omega} \\nabla \\cdot \\mathbf{F} \\, \\mathrm{d}A.\n$$\n将其应用于 $ \\mathbf{F} = \\mathbf{q} = -k \\nabla T $，可得\n$$\n\\int_{\\partial \\Omega} \\mathbf{q} \\cdot \\mathbf{n} \\, \\mathrm{d}s = -\\int_{\\Omega} \\nabla \\cdot (k \\nabla T) \\, \\mathrm{d}A.\n$$\n\n浸入边界法 (IBM) 视角：\n- 浸入边界在拉格朗日框架中由参数曲线 $ \\mathbf{X}(\\theta) $ 表示，其中 $ \\theta $ 是曲线参数（以弧度为单位的角度）。\n- 欧拉网格存储标量场 $ T $ 及其离散梯度 $ \\nabla T $，这些值被插值到拉格朗日点上。这种插值是在 IBM 中用于耦合拉格朗日和欧拉描述的正则化狄拉克δ函数的一个实用替代方法。\n\n您必须实现穿过一个以 $ (c_x,c_y) $ 为中心、半径为 $ R $ 的圆 $ \\Gamma $ 的两种总热传递评估方法：\n1. 曲面积分的拉格朗日求积\n$$\nQ_{\\mathrm{Lag}} = \\int_{\\Gamma} \\mathbf{q} \\cdot \\mathbf{n} \\, \\mathrm{d}s, \\quad \\mathbf{q} = -k \\nabla T, \\quad \\mathbf{n} \\text{ 是 } \\Gamma \\text{ 上的外向单位法向量},\n$$\n在 $ N_s $ 个均匀分布于 $ [0,2\\pi) $（弧度）的角度上使用复合梯形法则进行近似。在每个拉格朗日点 $ \\mathbf{X}(\\theta) = (c_x + R \\cos\\theta, c_y + R \\sin\\theta) $ 处，通过对欧拉离散梯度进行双线性插值来获得 $ \\nabla T $。\n\n2. 使用散度定理在圆 $ \\Gamma $ 内部的圆盘 $ \\Omega $ 上计算欧拉控制体通量：\n$$\nQ_{\\mathrm{Eul}} = -\\int_{\\Omega} \\nabla \\cdot (k \\nabla T) \\, \\mathrm{d}A,\n$$\n通过对位于圆内的所有网格单元中心点，将 $ T $ 的离散拉普拉斯算子乘以 $ k $ 和单元面积 $ \\Delta x \\, \\Delta y $ 后求和来进行近似。\n\n需实现的离散化细节：\n- 使用一个均匀的笛卡尔网格，包含 $ N_x \\times N_y $ 个单元中心，覆盖 $ [0,1] \\times [0,1] $ 米的区域，其中 $ \\Delta x = 1/N_x $ 且 $ \\Delta y = 1/N_y $。单元中心的坐标为 $ x_i = (i + \\tfrac{1}{2}) \\Delta x $，$ y_j = (j + \\tfrac{1}{2}) \\Delta y $，其中 $ i=0,\\dots,N_x-1 $ 且 $ j=0,\\dots,N_y-1 $。\n- 在内部通过二阶有限差分计算离散梯度 $ \\partial T / \\partial x $ 和 $ \\partial T / \\partial y $：\n$$\n\\left.\\frac{\\partial T}{\\partial x}\\right|_{j,i} \\approx \\frac{T_{j,i+1} - T_{j,i-1}}{2\\Delta x}, \\quad\n\\left.\\frac{\\partial T}{\\partial y}\\right|_{j,i} \\approx \\frac{T_{j+1,i} - T_{j-1,i}}{2\\Delta y}.\n$$\n对于边界索引，使用二阶单边差分来填充值。\n- 在内部通过二阶中心差分计算离散拉普拉斯算子：\n$$\n(\\nabla^2 T)_{j,i} \\approx \\frac{T_{j,i+1} - 2T_{j,i} + T_{j,i-1}}{\\Delta x^2} + \\frac{T_{j+1,i} - 2T_{j,i} + T_{j-1,i}}{\\Delta y^2}.\n$$\n- 在点 $ (x,y) $ 处的双线性插值使用四个相邻的单元中心 $ (x_i,y_j), (x_{i+1},y_j), (x_i,y_{j+1}), (x_{i+1},y_{j+1}) $，权重由其在单元内的相对位置确定。\n\n温度场和单位：\n- 设 $ k $ 的单位为 $ \\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K}) $，位置单位为米，温度单位为开尔文。温度场的构造使得单位保持一致：\n  - 径向二次场：$ T(x,y) = T_0 + A\\left[(x-c_x)^2 + (y-c_y)^2\\right] $，其中 $ A $ 的单位为 $ \\mathrm{K}/\\mathrm{m}^2 $。\n  - 线性场：$ T(x,y) = T_0 + B(x-c_x) + C(y-c_y) $，其中 $ B, C $ 的单位为 $ \\mathrm{K}/\\mathrm{m} $。\n  - 各向异性二次场：$ T(x,y) = T_0 + A_x(x-c_x)^2 + A_y(y-c_y)^2 $，其中 $ A_x, A_y $ 的单位为 $ \\mathrm{K}/\\mathrm{m}^2 $。\n- 用于拉格朗日参数化的角度 $ \\theta $ 必须以弧度为单位。\n\n科学真实性与协调性：\n- 在连续介质极限下，两个通量 $ Q_{\\mathrm{Lag}} $ 和 $ Q_{\\mathrm{Eul}} $ 应当一致。差异源于浸入边界附近的离散化、插值以及单元的几何掩膜。您必须报告这两个通量及其绝对差 $ D = |Q_{\\mathrm{Lag}} - Q_{\\mathrm{Eul}}| $。\n\n测试套件：\n实现程序以评估以下四种情况。所有圆都严格位于域内，以最小化边界伪影。\n\n- 情况 1（理想情况，光滑且对称的场）：\n  - $ N_x = N_y = 128 $，$ k = 1.0 \\ \\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K}) $，$ (c_x,c_y) = (0.5,0.5) \\ \\mathrm{m} $，$ R = 0.20 \\ \\mathrm{m} $，$ N_s = 1024 $，\n  - $ T_0 = 300 \\ \\mathrm{K} $，$ A = 8 \\ \\mathrm{K}/\\mathrm{m}^2 $，\n  - 温度：径向二次场。\n\n- 情况 2（边缘情况，粗糙网格和小几何尺度）：\n  - $ N_x = N_y = 32 $，$ k = 1.0 \\ \\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K}) $，$ (c_x,c_y) = (0.5,0.5) \\ \\mathrm{m} $，$ R = 0.20 \\ \\mathrm{m} $，$ N_s = 256 $，\n  - $ T_0 = 300 \\ \\mathrm{K} $，$ A = 8 \\ \\mathrm{K}/\\mathrm{m}^2 $，\n  - 温度：径向二次场。\n\n- 情况 3（边界条件情况，预期净通量为零）：\n  - $ N_x = N_y = 64 $，$ k = 1.0 \\ \\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K}) $，$ (c_x,c_y) = (0.5,0.5) \\ \\mathrm{m} $，$ R = 0.30 \\ \\mathrm{m} $，$ N_s = 512 $，\n  - $ T_0 = 300 \\ \\mathrm{K} $，$ B = 10 \\ \\mathrm{K}/\\mathrm{m} $，$ C = -7 \\ \\mathrm{K}/\\mathrm{m} $，\n  - 温度：线性场。\n\n- 情况 4（各向异性二次场，非对称梯度）：\n  - $ N_x = N_y = 96 $，$ k = 1.0 \\ \\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K}) $，$ (c_x,c_y) = (0.5,0.5) \\ \\mathrm{m} $，$ R = 0.25 \\ \\mathrm{m} $，$ N_s = 512 $，\n  - $ T_0 = 300 \\ \\mathrm{K} $，$ A_x = 3 \\ \\mathrm{K}/\\mathrm{m}^2 $，$ A_y = 1 \\ \\mathrm{K}/\\mathrm{m}^2 $，\n  - 温度：各向异性二次场。\n\n要求输出：\n- 对每种情况，计算以瓦特为单位的 $ Q_{\\mathrm{Lag}} $ 和 $ Q_{\\mathrm{Eul}} $ 以及以瓦特为单位的绝对差 $ D $。\n- 所有值均以瓦特（$ \\mathrm{W} $）表示，并四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，顺序如下\n$$\n[Q_{\\mathrm{Lag}}^{(1)}, Q_{\\mathrm{Eul}}^{(1)}, D^{(1)}, Q_{\\mathrm{Lag}}^{(2)}, Q_{\\mathrm{Eul}}^{(2)}, D^{(2)}, Q_{\\mathrm{Lag}}^{(3)}, Q_{\\mathrm{Eul}}^{(3)}, D^{(3)}, Q_{\\mathrm{Lag}}^{(4)}, Q_{\\mathrm{Eul}}^{(4)}, D^{(4)}],\n$$\n其中上标 $ (\\cdot) $ 表示情况索引。",
            "solution": "该问题要求计算穿过浸入二维域中的封闭圆形边界的总传导热量。这将通过实现两种不同但物理上等效的公式来完成：一个是沿边界的拉格朗日曲面积分，另一个是覆盖边界所包围区域的欧拉体积分。在浸入边界法（IBM）的背景下，比较它们的结果是一种基本的验证技术。整个分析基于傅里叶热传导定律和散度定理。\n\n首先，我们建立数学和物理框架。热通量矢量 $\\mathbf{q}$ 由傅里叶定律给出：\n$$\n\\mathbf{q} = -k \\nabla T\n$$\n其中 $k$ 是热导率（假定为常数），$T$ 是温度场。穿过闭合曲线 $\\Gamma$ 的总热传递 $Q$ 是 $\\mathbf{q}$ 通过 $\\Gamma$ 的通量：\n$$\nQ = \\oint_{\\Gamma} \\mathbf{q} \\cdot \\mathbf{n} \\, \\mathrm{d}s\n$$\n其中 $\\mathbf{n}$ 是指向 $\\Gamma$ 的外向单位法向量，$\\mathrm{d}s$ 是微分弧长。通过对 $\\Gamma$ 所包围的区域 $\\Omega$ 应用散度定理，该曲面积分可以转换为一个体（在二维中为面积）积分：\n$$\nQ = \\int_{\\Omega} \\nabla \\cdot \\mathbf{q} \\, \\mathrm{d}A = -\\int_{\\Omega} \\nabla \\cdot (k \\nabla T) \\, \\mathrm{d}A = -k \\int_{\\Omega} \\nabla^2 T \\, \\mathrm{d}A\n$$\n$Q$ 的这两个表达式构成了两种计算方法的基础。\n\n问题在定义于域 $[0,1] \\times [0,1]$ 上的均匀笛卡尔网格上进行离散化。该网格由 $N_x \\times N_y$ 个单元组成，网格间距为 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$。单元中心的坐标由 $x_i = (i + 0.5)\\Delta x$（对于 $i \\in \\{0, 1, \\dots, N_x-1\\}$）和 $y_j = (j + 0.5)\\Delta y$（对于 $j \\in \\{0, 1, \\dots, N_y-1\\}$）给出。连续温度场 $T(x,y)$ 在这些单元中心进行求值，以产生离散场 $T_{j,i} = T(x_i, y_j)$。\n\n为了评估积分，我们需要梯度和拉普拉斯算子的离散近似。我们在网格上计算梯度分量 $\\partial T / \\partial x$ 和 $\\partial T / \\partial y$。对于内部节点，使用二阶中心差分：\n$$\n\\left.\\frac{\\partial T}{\\partial x}\\right|_{j,i} \\approx \\frac{T_{j,i+1} - T_{j,i-1}}{2\\Delta x}, \\quad \\left.\\frac{\\partial T}{\\partial y}\\right|_{j,i} \\approx \\frac{T_{j+1,i} - T_{j-1,i}}{2\\Delta y}\n$$\n对于域边界上的节点（例如 $i=0$ 或 $i=N_x-1$），采用二阶单边差分公式以在整个网格上保持精度。例如，在左边界（$i=0$）处：\n$$\n\\left.\\frac{\\partial T}{\\partial x}\\right|_{j,0} \\approx \\frac{-3T_{j,0} + 4T_{j,1} - T_{j,2}}{2\\Delta x}\n$$\n在右边界（$i=N_x-1$）处：\n$$\n\\left.\\frac{\\partial T}{\\partial x}\\right|_{j,N_x-1} \\approx \\frac{3T_{j,N_x-1} - 4T_{j,N_x-2} + T_{j,N_x-3}}{2\\Delta x}\n$$\n类似的公式适用于 $j=0$ 和 $j=N_y-1$ 边界处的 $y$ 方向梯度。\n\n欧拉体积分需要拉普拉斯算子 $\\nabla^2 T$。由于所有测试用例中的圆都严格位于域内，我们只需在内部网格点上评估拉普拉斯算子。标准的二阶中心差分格式就足够了：\n$$\n(\\nabla^2 T)_{j,i} \\approx \\frac{T_{j,i+1} - 2T_{j,i} + T_{j,i-1}}{\\Delta x^2} + \\frac{T_{j+1,i} - 2T_{j,i} + T_{j-1,i}}{\\Delta y^2}\n$$\n\n第一种方法是拉格朗日曲面积分（$Q_{\\mathrm{Lag}}$），它近似于曲面积分。半径为 $R$、中心为 $(c_x, c_y)$ 的圆形边界 $\\Gamma$ 在拉格朗日框架中通过 $\\mathbf{X}(\\theta) = (c_x + R\\cos\\theta, c_y + R\\sin\\theta)$ 进行参数化，其中 $\\theta \\in [0, 2\\pi)$。外向单位法向量为 $\\mathbf{n}(\\theta) = (\\cos\\theta, \\sin\\theta)$，弧长元为 $\\mathrm{d}s = R\\,\\mathrm{d}\\theta$。积分变为：\n$$\nQ_{\\mathrm{Lag}} = -k R \\int_0^{2\\pi} \\nabla T(\\mathbf{X}(\\theta)) \\cdot \\mathbf{n}(\\theta) \\, \\mathrm{d}\\theta\n$$\n该积分使用复合梯形法则在 $N_s$ 个均匀间隔的点上进行数值近似。设角步长为 $\\Delta\\theta = 2\\pi/N_s$，角度为 $\\theta_m = m\\Delta\\theta$（对于 $m \\in \\{0, \\dots, N_s-1\\}$），则求和为：\n$$\nQ_{\\mathrm{Lag}} \\approx -k R \\Delta\\theta \\sum_{m=0}^{N_s-1} \\left( \\nabla T(\\mathbf{X}(\\theta_m)) \\cdot \\mathbf{n}(\\theta_m) \\right)\n$$\n此过程中的一个关键步骤是耦合拉格朗日和欧拉框架。每个拉格朗日点 $\\mathbf{X}(\\theta_m)$ 处的梯度矢量 $\\nabla T$ 不是直接可用的。它必须从定义在欧拉网格上的离散梯度场 $\\partial T/\\partial x$ 和 $\\partial T/\\partial y$ 进行插值。为此，我们使用双线性插值。对于一个点 $(x,y)$，我们确定其周围的四个单元中心，并使用这些中心处梯度值的加权平均来找到 $(x,y)$ 处的插值梯度。\n\n第二种方法是欧拉体积分（$Q_{\\mathrm{Eul}}$），它近似于由散度定理导出的面积分：\n$$\nQ_{\\mathrm{Eul}} \\approx -k \\sum_{(x_i, y_j) \\in \\Omega} (\\nabla^2 T)_{j,i} \\, \\Delta x \\Delta y\n$$\n求和是在所有严格位于圆 $\\Gamma$ 内部的网格单元中心 $(x_i, y_j)$ 的集合上进行的。这由条件 $(x_i - c_x)^2 + (y_j - c_y)^2  R^2$ 确定。值 $(\\nabla^2 T)_{j,i}$ 是在每个内部单元中心计算的离散拉普拉斯算子。这种方法依赖于一种“掩膜”技术来表示几何形状，这是笛卡尔网格方法处理复杂域的一个共同特征。\n\n最后，计算绝对差 $D = |Q_{\\mathrm{Lag}} - Q_{\\mathrm{Eul}}|$。在连续介质极限下，$D$ 应为零。在离散设置中，$D > 0$ 反映了有限差分格式中的离散化误差、从欧拉框架到拉格朗日框架的插值误差，以及拉格朗日求积和欧拉单元掩膜中的几何近似误差（混叠）的综合影响。比较 $Q_{\\mathrm{Lag}}$、$Q_{\\mathrm{Eul}}$ 及其解析值（如果可用）为数值实现的严谨验证提供了依据。",
            "answer": "```python\nimport numpy as np\n\ndef compute_gradients(T, dx, dy):\n    \"\"\"\n    Computes the gradient of a 2D scalar field T using second-order finite differences.\n    \"\"\"\n    Ny, Nx = T.shape\n    Gx = np.zeros_like(T, dtype=float)\n    Gy = np.zeros_like(T, dtype=float)\n\n    # Gx: Central difference for interior\n    if Nx  2:\n        Gx[:, 1:-1] = (T[:, 2:] - T[:, :-2]) / (2 * dx)\n        # Gx: Second-order one-sided for boundaries\n        Gx[:, 0] = (-3 * T[:, 0] + 4 * T[:, 1] - T[:, 2]) / (2 * dx)\n        Gx[:, -1] = (3 * T[:, -1] - 4 * T[:, -2] + T[:, -3]) / (2 * dx)\n    elif Nx == 2: # Handle very small grids\n        Gx[:, 0] = (T[:, 1] - T[:, 0]) / dx\n        Gx[:, 1] = (T[:, 1] - T[:, 0]) / dx\n\n\n    # Gy: Central difference for interior\n    if Ny  2:\n        Gy[1:-1, :] = (T[2:, :] - T[:-2, :]) / (2 * dy)\n        # Gy: Second-order one-sided for boundaries\n        Gy[0, :] = (-3 * T[0, :] + 4 * T[1, :] - T[2, :]) / (2 * dy)\n        Gy[-1, :] = (3 * T[-1, :] - 4 * T[-2, :] + T[-3, :]) / (2 * dy)\n    elif Ny == 2:\n        Gy[0, :] = (T[1, :] - T[0, :]) / dy\n        Gy[1, :] = (T[1, :] - T[0, :]) / dy\n        \n    return Gx, Gy\n\ndef compute_laplacian(T, dx, dy):\n    \"\"\"\n    Computes the Laplacian of a 2D scalar field T using second-order central differences\n    for the interior grid points. Boundaries are left as zero.\n    \"\"\"\n    lap_T = np.zeros_like(T, dtype=float)\n    Ny, Nx = T.shape\n    if Nx  2 and Ny  2:\n        lap_T[1:-1, 1:-1] = (T[1:-1, 2:] - 2*T[1:-1, 1:-1] + T[1:-1, :-2]) / dx**2 + \\\n                            (T[2:, 1:-1] - 2*T[1:-1, 1:-1] + T[:-2, 1:-1]) / dy**2\n    return lap_T\n\ndef bilinear_interp(field, pt_x, pt_y, dx, dy):\n    \"\"\"\n    Performs bilinear interpolation of a field value at a point (pt_x, pt_y).\n    \"\"\"\n    Ny, Nx = field.shape\n    \n    i_float = pt_x / dx - 0.5\n    j_float = pt_y / dy - 0.5\n    \n    i_idx = int(i_float)\n    j_idx = int(j_float)\n    \n    # Clip to ensure indices are within bounds for the 4-point stencil\n    i_idx = np.clip(i_idx, 0, Nx - 2)\n    j_idx = np.clip(j_idx, 0, Ny - 2)\n    \n    t = i_float - i_idx\n    u = j_float - j_idx\n    \n    val = ((1 - t) * (1 - u) * field[j_idx, i_idx] +\n           t * (1 - u) * field[j_idx, i_idx + 1] +\n           (1 - t) * u * field[j_idx + 1, i_idx] +\n           t * u * field[j_idx + 1, i_idx + 1])\n    return val\n\ndef calculate_Q_lagrangian(Gx, Gy, dx, dy, k, cx, cy, R, Ns):\n    \"\"\"\n    Calculates total heat transfer using Lagrangian surface quadrature.\n    \"\"\"\n    d_theta = 2 * np.pi / Ns\n    thetas = np.arange(Ns) * d_theta\n    integrand_sum = 0.0\n\n    for theta in thetas:\n        x_L = cx + R * np.cos(theta)\n        y_L = cy + R * np.sin(theta)\n        nx = np.cos(theta)\n        ny = np.sin(theta)\n        \n        grad_Tx = bilinear_interp(Gx, x_L, y_L, dx, dy)\n        grad_Ty = bilinear_interp(Gy, x_L, y_L, dx, dy)\n        \n        gradT_dot_n = grad_Tx * nx + grad_Ty * ny\n        integrand_sum += gradT_dot_n\n        \n    Q_lag = -k * R * integrand_sum * d_theta\n    return Q_lag\n\ndef calculate_Q_eulerian(lap_T, xx, yy, dx, dy, k, cx, cy, R):\n    \"\"\"\n    Calculates total heat transfer using Eulerian volume integration.\n    \"\"\"\n    dA = dx * dy\n    mask = (xx - cx)**2 + (yy - cy)**2  R**2\n    \n    Q_eul = -k * np.sum(lap_T[mask]) * dA\n    return Q_eul\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, smooth and symmetric field)\n        {'Nx': 128, 'Ny': 128, 'k': 1.0, 'cx': 0.5, 'cy': 0.5, 'R': 0.20, 'Ns': 1024,\n         'T_type': 'radial_quad', 'T_params': {'T0': 300.0, 'A': 8.0}},\n        # Case 2 (edge case, coarse grid and small geometry scale)\n        {'Nx': 32, 'Ny': 32, 'k': 1.0, 'cx': 0.5, 'cy': 0.5, 'R': 0.20, 'Ns': 256,\n         'T_type': 'radial_quad', 'T_params': {'T0': 300.0, 'A': 8.0}},\n        # Case 3 (boundary condition case, zero net flux expectation)\n        {'Nx': 64, 'Ny': 64, 'k': 1.0, 'cx': 0.5, 'cy': 0.5, 'R': 0.30, 'Ns': 512,\n         'T_type': 'linear', 'T_params': {'T0': 300.0, 'B': 10.0, 'C': -7.0}},\n        # Case 4 (anisotropic quadratic field, non-symmetric gradients)\n        {'Nx': 96, 'Ny': 96, 'k': 1.0, 'cx': 0.5, 'cy': 0.5, 'R': 0.25, 'Ns': 512,\n         'T_type': 'anisotropic_quad', 'T_params': {'T0': 300.0, 'Ax': 3.0, 'Ay': 1.0}},\n    ]\n\n    results = []\n    for params in test_cases:\n        Nx, Ny, k, cx, cy, R, Ns = params['Nx'], params['Ny'], params['k'], params['cx'], params['cy'], params['R'], params['Ns']\n        \n        # 1. Setup Grid and Temperature Field\n        dx, dy = 1.0 / Nx, 1.0 / Ny\n        x_coords = (np.arange(Nx) + 0.5) * dx\n        y_coords = (np.arange(Ny) + 0.5) * dy\n        xx, yy = np.meshgrid(x_coords, y_coords)\n        \n        T_params = params['T_params']\n        if params['T_type'] == 'radial_quad':\n            T = T_params['T0'] + T_params['A'] * ((xx - cx)**2 + (yy - cy)**2)\n        elif params['T_type'] == 'linear':\n            T = T_params['T0'] + T_params['B'] * (xx - cx) + T_params['C'] * (yy - cy)\n        elif params['T_type'] == 'anisotropic_quad':\n            T = T_params['T0'] + T_params['Ax'] * (xx - cx)**2 + T_params['Ay'] * (yy - cy)**2\n\n        # 2. Compute Derivatives on Eulerian Grid\n        Gx, Gy = compute_gradients(T, dx, dy)\n        lap_T = compute_laplacian(T, dx, dy)\n\n        # 3. Calculate Lagrangian Flux\n        Q_lag = calculate_Q_lagrangian(Gx, Gy, dx, dy, k, cx, cy, R, Ns)\n        \n        # 4. Calculate Eulerian Flux\n        Q_eul = calculate_Q_eulerian(lap_T, xx, yy, dx, dy, k, cx, cy, R)\n        \n        # 5. Calculate Difference\n        D = abs(Q_lag - Q_eul)\n        \n        results.extend([Q_lag, Q_eul, D])\n\n    print(f\"[{','.join(f'{v:.6f}' for v in results)}]\")\n\nsolve()\n```"
        }
    ]
}