{
    "hands_on_practices": [
        {
            "introduction": "为了真正理解通量限制器如何防止数值振荡，我们必须首先在最基础的层面观察其作用。本练习提供了一个动手计算，您将把 van Albada 限制器应用于一个特定的温度分布。通过计算受限的界面值，您将直接观察到限制器如何修正解，并为保证单调性而引入数值耗散。",
            "id": "3955144",
            "problem": "考虑由被动标量的能量守恒定律 $\\frac{\\partial T}{\\partial t} + a \\frac{\\partial T}{\\partial x} = 0$ 控制的一维、常系数温度平流，其中平流速度 $a0$ 为正。在一个网格上使用均匀的、以单元为中心的有限体积离散化方法，该网格的节点为 $x_i$，单元平均值为 $T_i$，数值对流通量为 $F_{i+1/2} = a\\,T_{i+1/2}^{-}$，其中 $T_{i+1/2}^{-}$ 表示在 $x_{i+1/2}$ 处的左侧重构界面温度。在一个高分辨率、总变差递减 (TVD) 的守恒律单调上游中心格式 (MUSCL) 重构中，单元 $i$ 内的分段线性斜率受到一个应用于上游梯度的通量限制器 $\\phi(r)$ 的限制。van Albada 限制器的表达式为\n$$\n\\phi(r) = \\frac{r^{2} + r}{1 + r^{2}},\n$$\n对于 $a0$，无量纲梯度比定义为\n$$\nr = \\frac{T_{i} - T_{i-1}}{T_{i+1} - T_{i}}。\n$$\n给定网格序列 $(T_{i-1}, T_i, T_{i+1}) = (\\,300\\,\\text{K},\\,330\\,\\text{K},\\,365\\,\\text{K}\\,)$ 和 $a = 0.25\\,\\text{m}\\,\\text{s}^{-1}$，使用带有 van Albada 限制器的 TVD-MUSCL 方法重构在 $x_{i+1/2}$ 处的左侧界面温度 $T_{i+1/2}^{-}$。然后，通过比较 $F_{i+1/2}$ 的值，解释对流通量中增量数值扩散的符号和大小，该增量是相对于对应于 $\\phi(r)=1$ 的无限制上风线性重构而言的。\n\n将最终计算出的 $T_{i+1/2}^{-}$ 四舍五入到四位有效数字。以开尔文表示界面温度。",
            "solution": "问题要求使用总变差递减 (TVD) 的守恒律单调上游中心格式 (MUSCL) 方法重构一个界面温度，然后解释通量限制器引入的数值扩散。\n\n控制方程是温度 $T$ 的一维线性平流方程：\n$$\n\\frac{\\partial T}{\\partial t} + a \\frac{\\partial T}{\\partial x} = 0\n$$\n其中平流速度 $a$ 为正，表示流动方向从左到右。\n\n在有限体积框架中，单元 $i$ 的半离散形式为：\n$$\n\\frac{d T_i}{dt} = -\\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2})\n$$\n其中 $T_i$ 是单元平均温度，$F_{i\\pm1/2}$ 是单元界面处的数值通量。问题将通量指定为 $F_{i+1/2} = a\\,T_{i+1/2}^{-}$，其中 $T_{i+1/2}^{-}$ 是在界面 $x_{i+1/2}$ 左侧的重构温度。\n\n对于具有上风偏斜率的 MUSCL 格式（因为 $a0$），单元 $i$ 内温度的分段线性重构在其右侧面 $x_{i+1/2}$ 处的值由下式给出：\n$$\nT_{i+1/2}^{-} = T_i + \\frac{1}{2} \\sigma_i \\Delta x\n$$\n其中 $\\sigma_i$ 是单元 $i$ 中的受限斜率。问题指出限制器应用于上游梯度。对于 $a0$，单元 $i$ 的上游梯度基于单元 $i$ 和 $i-1$ 中的数据。无限制的上风偏斜率为 $\\sigma_{i, \\text{unlim}} = (T_i - T_{i-1}) / \\Delta x$。\n\n将通量限制器 $\\phi(r)$ 应用于此斜率，得到受限斜率：\n$$\n\\sigma_i = \\phi(r_i) \\frac{T_i - T_{i-1}}{\\Delta x}\n$$\n将此代入重构公式，得到左侧界面温度的表达式：\n$$\nT_{i+1/2}^{-} = T_i + \\frac{1}{2} \\left( \\phi(r_i) \\frac{T_i - T_{i-1}}{\\Delta x} \\right) \\Delta x = T_i + \\frac{1}{2} \\phi(r_i) (T_i - T_{i-1})\n$$\n问题提供了必要的数据：$T_{i-1} = 300\\,\\text{K}$，$T_i = 330\\,\\text{K}$，以及 $T_{i+1} = 365\\,\\text{K}$。\n\n首先，我们计算单元 $i$ 处的无量纲梯度比 $r$：\n$$\nr_i = \\frac{T_{i} - T_{i-1}}{T_{i+1} - T_{i}} = \\frac{330 - 300}{365 - 330} = \\frac{30}{35} = \\frac{6}{7}\n$$\n接下来，我们计算 $r = 6/7$ 时的 van Albada 通量限制器函数 $\\phi(r)$：\n$$\n\\phi(r) = \\frac{r^{2} + r}{1 + r^{2}} \\implies \\phi\\left(\\frac{6}{7}\\right) = \\frac{\\left(\\frac{6}{7}\\right)^{2} + \\frac{6}{7}}{1 + \\left(\\frac{6}{7}\\right)^{2}} = \\frac{\\frac{36}{49} + \\frac{42}{49}}{\\frac{49}{49} + \\frac{36}{49}} = \\frac{\\frac{78}{49}}{\\frac{85}{49}} = \\frac{78}{85}\n$$\n现在，我们可以计算重构的界面温度 $T_{i+1/2}^{-}$：\n$$\nT_{i+1/2}^{-} = T_i + \\frac{1}{2} \\phi(r_i) (T_i - T_{i-1}) = 330 + \\frac{1}{2} \\left(\\frac{78}{85}\\right) (330 - 300)\n$$\n$$\nT_{i+1/2}^{-} = 330 + \\frac{1}{2} \\left(\\frac{78}{85}\\right) (30) = 330 + \\frac{1170}{85} = 330 + \\frac{234}{17}\n$$\n该值的数值为：\n$$\nT_{i+1/2}^{-} \\approx 330 + 13.76470588... = 343.76470588...\\,\\text{K}\n$$\n按要求四舍五入到四位有效数字，得到：\n$$\nT_{i+1/2}^{-} \\approx 343.8\\,\\text{K}\n$$\n为了解释限制器的效果，我们将此结果与无限制的上风线性重构进行比较，后者对应于设置 $\\phi(r)=1$。这代表一个纯粹的二阶完全上风格式。\n$$\nT_{i+1/2, \\text{unlim}}^{-} = T_i + \\frac{1}{2} (1) (T_i - T_{i-1}) = 330 + \\frac{1}{2} (30) = 330 + 15 = 345\\,\\text{K}\n$$\n使用 $a = 0.25\\,\\text{m}\\,\\text{s}^{-1}$ 计算相应的数值通量：\n$$\nF_{i+1/2, \\text{limited}} = a \\cdot T_{i+1/2}^{-} = 0.25 \\times \\left(330 + \\frac{1170}{85}\\right) \\approx 0.25 \\times 343.7647 = 85.94117...\\,\\text{W}\\,\\text{m}^{-2}\\text{ （如果 T 是焓的代理）}\n$$\n$$\nF_{i+1/2, \\text{unlim}} = a \\cdot T_{i+1/2, \\text{unlim}}^{-} = 0.25 \\times 345 = 86.25\\,\\text{W}\\,\\text{m}^{-2}\n$$\n已知扩散性最强但无振荡的一阶上风格式会使用 $T_{i+1/2}^{-} = T_i = 330\\,\\text{K}$。其通量将是 $F_{i+1/2, \\text{1st}} = 0.25 \\times 330 = 82.5\\,\\text{W}\\,\\text{m}^{-2}$。\n\n限制器的值为 $\\phi(r_i) = 78/85 \\approx 0.9176$，小于 1。这导致重构温度 $T_{i+1/2}^{-} \\approx 343.8\\,\\text{K}$ 低于无限制的二阶值 $T_{i+1/2, \\text{unlim}}^{-} = 345\\,\\text{K}$，并更接近一阶值 $T_{i+1/2, \\text{1st}}^{-} = 330\\,\\text{K}$。\n\n这种向一阶上风结果的偏移是增加数值扩散的决定性特征。高阶格式会在陡峭梯度附近引入非物理振荡（过冲和下冲）。通量限制器的作用是增加刚好足够的数值扩散，以抑制这些振荡并强制单调性（TVD 属性），其代价是在平滑区域的精度略低于无限制格式。\n\n因此，由限制器引入的增量数值扩散的符号为正（即，增加了扩散）。这种效应的大小反映在重构温度和相应对流通量的减小上。通量从 $F_{i+1/2, \\text{unlim}} = 86.25$ 减少到 $F_{i+1/2, \\text{limited}} \\approx 85.94$。通量差 $\\Delta F = F_{i+1/2, \\text{unlim}} - F_{i+1/2, \\text{limited}}  0$ 代表了限制器应用的耗散修正。\n$$\n\\Delta F = a \\frac{1}{2} (1 - \\phi(r_i)) (T_i - T_{i-1}) = 0.25 \\times \\frac{1}{2} \\left(1 - \\frac{78}{85}\\right) (30) = 0.25 \\times 15 \\times \\frac{7}{85} = \\frac{21}{68} \\approx 0.3088\n$$\n这个正值证实了，相对于无限制的二阶重构，限制器的作用是增加格式的耗散。",
            "answer": "$$\n\\boxed{343.8}\n$$"
        },
        {
            "introduction": "从单个计算过渡到完整的模拟，下一步是构建并验证一个完整的高分辨率格式。在此实践中，您将使用 van Leer 通量限制器，实现一个求解平流方程的有限体积求解器。 通过对光滑正弦波进行网格加密研究，您将验证该格式在光滑区域的二阶精度，这是高分辨率方法的一个标志性特征。",
            "id": "3955097",
            "problem": "光滑标量场的一维线性平流由守恒律 $\\partial_t u + \\partial_x (a u) = 0$ 控制，其中 $a$ 为恒定的正平流速度。从该守恒律和在 $[0,1]$ 上包含 $N$ 个宽度为 $\\Delta x$ 的网格的均匀周期性网格上的守恒有限体积离散化定义出发，构建一个高分辨率显式更新方案。该方案使用带有 van Leer 通量限制器的通量限制迎风格式，并以 Courant–Friedrichs–Lewy (CFL) 数 $\\nu \\in (0,1]$ 来推进时间上的解。van Leer 限制器对斜率比 $r$ 定义为 $\\phi_{\\mathrm{VL}}(r) = \\dfrac{r + |r|}{1 + |r|}$。在数值通量中对 $a  0$ 使用标准的迎风选择，并精确地施加周期性边界条件。\n\n物理和数值设置如下：\n\n- 区域：$x \\in [0,1]$，单位为米。使用周期性边界条件。\n- 平流速度：$a = 1\\,\\mathrm{m/s}$。\n- 初始条件：$u(x,0) = \\sin(2\\pi x)$。\n- 最终时间：$T = 1\\,\\mathrm{s}$，因此在时间 $T$ 的精确解为 $u(x,T) = \\sin(2\\pi x)$。\n- 时间步长：选择 $\\Delta t$ 以满足 $\\nu = a \\Delta t / \\Delta x$。使用 $\\nu = 0.5$，这样对于下面定义的所有网格，$T/\\Delta t$ 都是一个整数。\n\n您必须：\n- 使用有限体积法以守恒形式离散化守恒律，对 $a  0$ 使用带有 van Leer 限制器的高分辨率迎风通量。限制器应通过由连续单边差分构建的斜率比 $r_i$ 应用，并用于修正界面 $x_{i+1/2}$ 处的通量。根据构造，该方法对于 $a  0$ 必须是 Godunov 意义下的总变差递减 (TVD) 方法。清晰地实现周期性以计算所有必需的单边差分和界面通量。\n- 使用选定的显式时间步长将解从 $t=0$ 推进到 $t=T$，使得 $T/\\Delta t$ 是一个整数。\n- 计算在 $t=T$ 时的离散 $L^2$ 误差，其定义为 $E_2 = \\left(\\sum_{i=1}^{N} (u_i^{\\mathrm{num}} - u_i^{\\mathrm{exact}})^2 \\, \\Delta x \\right)^{1/2}$，其中 $u_i^{\\mathrm{exact}} = \\sin(2\\pi x_i)$，$x_i$ 是网格 $i$ 的中心。\n- 进行网格加密研究，并通过 $p = \\dfrac{\\log(E_2^{(1)}/E_2^{(2)})}{\\log(\\Delta x^{(1)}/\\Delta x^{(2)})}$ 估计任意两个连续网格之间的观测精度阶 $p$。\n\n使用以下网格尺寸（网格数量 $N$）的测试套件：\n- 粗网格：$N = 50$。\n- 中等网格：$N = 100$。\n- 细网格：$N = 200$。\n- 极细网格：$N = 400$。\n\n数值和物理单位：距离必须以 $\\mathrm{m}$ 为单位，时间以 $\\mathrm{s}$ 为单位，速度以 $\\mathrm{m/s}$ 为单位。$L^2$ 误差和观测阶数 $p$ 是无量纲数。初始条件振幅和所有常数必须完全按照规定使用。\n\n您的程序必须：\n- 对于测试套件中的每个 $N$，计算在 $t=T$ 时的 $L^2$ 误差 $E_2$，结果为浮点数。\n- 计算三个观测阶数 $p_{50\\to 100}$、$p_{100\\to 200}$ 和 $p_{200\\to 400}$，结果为浮点数。\n- 返回一个最终的布尔值，指示在两个最精细的网格加密上是否通过条件 $p_{100\\to 200} \\ge 1.8$ 和 $p_{200\\to 400} \\ge 1.8$ 验证了二阶精度。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序包含以下条目：$[E_{50}, E_{100}, E_{200}, E_{400}, p_{50\\to 100}, p_{100\\to 200}, p_{200\\to 400}, \\text{verified}]$，其中每个 $E_N$ 和 $p$ 都是浮点数，$\\text{verified}$ 是一个布尔值。例如，输出可能看起来像 $[1.23e-04,3.08e-05,7.67e-06,1.91e-06,2.00,2.00,2.00,True]$。",
            "solution": "该问题要求构建并应用一个高分辨率、通量限制的有限体积格式来求解一维线性平流方程。我们将详细介绍该数值方法的推导、实现以及误差分析和精度阶验证的步骤。\n\n控制性偏微分方程 (PDE) 是守恒形式的线性平流方程：\n$$ \\partial_t u + \\partial_x (a u) = 0 $$\n其中 $u(x,t)$ 是一个标量场，$t$ 是时间，$x$ 是空间坐标，$a$ 是恒定的正平流速度，给定为 $a=1\\,\\mathrm{m/s}$。该问题设置在一维周期性区域 $x \\in [0,1]$ 上。\n\n我们在一系列包含 $N$ 个网格单元的均匀网格上采用有限体积法。区域 $[0,1]$ 被划分为宽度为 $\\Delta x = 1/N$ 的网格单元 $C_i = [x_{i-1/2}, x_{i+1/2}]$，其中 $i=0, 1, \\dots, N-1$。网格中心为 $x_i = (i+0.5)\\Delta x$。在网格单元 $C_i$ 上对 PDE 进行积分得到：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\partial_t u \\,dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} \\partial_x (au) \\,dx = 0 $$\n使用莱布尼茨法则和微积分基本定理，这变为：\n$$ \\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} u \\,dx + [au]_{x_{i+1/2}} - [au]_{x_{i-1/2}} = 0 $$\n我们定义网格平均量 $u_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx$。网格平均量的演化方程为：\n$$ \\frac{d u_i}{dt} + \\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2}) = 0 $$\n这里，$F_{i \\pm 1/2}$ 表示在网格界面 $x_{i \\pm 1/2}$ 处的数值通量，它逼近了在这些位置的物理通量 $au$。\n\n对于时间离散化，我们使用显式前向欧拉方法。全离散更新公式为：\n$$ \\frac{u_i^{n+1} - u_i^n}{\\Delta t} + \\frac{1}{\\Delta x} (F_{i+1/2}^n - F_{i-1/2}^n) = 0 $$\n$$ u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2}^n - F_{i-1/2}^n) $$\n其中 $u_i^n$ 是在时间 $t^n = n\\Delta t$ 时网格 $i$ 中网格平均量的近似值。项 $\\frac{\\Delta t}{\\Delta x}$ 与 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = \\frac{a \\Delta t}{\\Delta x}$ 相关。更新变为：\n$$ u_i^{n+1} = u_i^n - \\frac{\\nu}{a} (F_{i+1/2}^n - F_{i-1/2}^n) $$\n\n为了在保持稳定性（即总变差递减，TVD）的同时实现高分辨率，我们将数值通量 $F_{i+1/2}$ 构建为低分辨率（一阶）通量和有限的高分辨率（反扩散）修正的组合。由于平流速度 $a$ 为正，信息从左向右传播，因此我们使用迎风偏置格式。\n\n在界面 $x_{i+1/2}$ 处的一阶迎风通量为：\n$$ F_{i+1/2}^{\\text{1st}} = a u_i^n $$\n针对此问题的常见二阶格式是 Lax-Wendroff 格式，其通量（对于 $a0$）为：\n$$ F_{i+1/2}^{\\text{LW}} = a u_i^n + \\frac{a}{2}\\left(1 - \\frac{a\\Delta t}{\\Delta x}\\right)(u_{i+1}^n - u_i^n) = a u_i^n + \\frac{a(1-\\nu)}{2}(u_{i+1}^n - u_i^n) $$\nLax-Wendroff 通量与一阶迎风通量之差是反扩散通量项，它能提供更高的精度，但可能在陡峭梯度附近引入伪振荡。\n$$ \\Phi_{i+1/2}^{\\text{AD}} = F_{i+1/2}^{\\text{LW}} - F_{i+1/2}^{\\text{1st}} = \\frac{a(1-\\nu)}{2}(u_{i+1}^n - u_i^n) $$\n高分辨率通量限制格式是通过将此反扩散通量的一部分（经过限制）加到一阶通量上来构建的：\n$$ F_{i+1/2} = F_{i+1/2}^{\\text{1st}} + \\phi(r_{i+1/2}) \\Phi_{i+1/2}^{\\text{AD}} = a u_i^n + \\phi(r_{i+1/2}) \\frac{a(1-\\nu)}{2}(u_{i+1}^n - u_i^n) $$\n函数 $\\phi(r)$ 是通量限制器，它依赖于斜率比 $r$。对于 $a0$ 的迎风偏置格式，界面 $x_{i+1/2}$ 处通量的斜率比比较了迎风网格 ($i-1$) 中的梯度与局部网格 ($i$) 中的梯度。它被定义为连续网格间差分的比率：\n$$ r_{i+1/2} = \\frac{u_i^n - u_{i-1}^n}{u_{i+1}^n - u_i^n} $$\n这个比率衡量了解的局部光滑性。问题指定了 van Leer 通量限制器：\n$$ \\phi_{\\mathrm{VL}}(r) = \\frac{r + |r|}{1 + |r|} $$\n如果分母 $u_{i+1}^n - u_i^n$ 为零，$r_{i+1/2}$ 是未定义的。然而，在这种情况下，反扩散通量项 $\\Phi_{i+1/2}^{\\text{AD}}$ 也为零，因此无论限制器的值如何，修正项都为零。我们通过将修正项设置为零来处理这种情况。\n\n周期性边界条件意味着网格索引以 $N$ 为模进行处理。例如，网格 $i=0$ 的迎风邻居是网格 $i=N-1$，而网格 $i=N-1$ 的顺风邻居是网格 $i=0$。这可以通过数组滚动或模运算来高效实现。\n\n每个时间步长的总体算法是：\n1. 对于每个网格 $i=0, \\dots, N-1$，使用来自网格 $i-1$、$i$ 和 $i+1$ 的值，并进行周期性环绕，计算斜率比 $r_{i+1/2}$。\n2. 为每个界面计算 van Leer 限制器 $\\phi_{\\mathrm{VL}}(r_{i+1/2})$。\n3. 为每个界面 $i=0, \\dots, N-1$ 计算数值通量 $F_{i+1/2}$。\n4. 通过移动右界面通量数组，计算每个网格左界面的通量 $F_{i-1/2}$。\n5. 同时将所有网格平均值 $u_i^n$ 更新为 $u_i^{n+1}$。\n\n此过程重复 $N_t = T/\\Delta t$ 个时间步长以达到最终时间 $T=1\\,\\mathrm{s}$。给定 $a=1\\,\\mathrm{m/s}$、$\\nu=0.5$ 和 $\\Delta x = 1/N$，时间步长为 $\\Delta t = \\nu \\Delta x / a = 0.5/N$，步数为 $N_t = T/\\Delta t = 1/(0.5/N) = 2N$，这是一个整数。\n\n在最后一个时间步之后，我们计算离散 $L^2$ 误差：\n$$ E_2 = \\left(\\sum_{i=0}^{N-1} (u_i^{\\text{num}} - u_i^{\\text{exact}})^2 \\, \\Delta x \\right)^{1/2} $$\n其中 $u_i^{\\text{num}}$ 是在时间 $T$ 时网格 $i$ 中的数值解，而 $u_i^{\\text{exact}} = u(x_i, T)$。由于波速为 $a=1\\,\\mathrm{m/s}$ 且最终时间为 $T=1\\,\\mathrm{s}$，波恰好传播一个区域长度，由于周期性而返回其初始状态。因此，$u(x,T) = u(x-aT,0) = \\sin(2\\pi(x-1)) = \\sin(2\\pi x)$。\n\n最后，我们使用两个具有分辨率 $N_1$ 和 $N_2$（以及相应的网格尺寸 $\\Delta x_1, \\Delta x_2$ 和误差 $E_2^{(1)}, E_2^{(2)}$）的连续网格进行网格加密研究。观测到的精度阶 $p$ 估计为：\n$$ p = \\frac{\\log(E_2^{(1)}/E_2^{(2)})}{\\log(\\Delta x_1/\\Delta x_2)} $$\n在我们网格加倍的情况下，$\\Delta x_1/\\Delta x_2 = 2$，所以 $p = \\frac{\\log(E_2^{(1)}/E_2^{(2)})}{\\log(2)}$。我们期望该格式在光滑解上的精度阶 $p \\approx 2$，尽管在极值点附近限制器可能会略微降低这个值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using a flux-limited finite volume scheme\n    and performs a grid refinement study.\n    \"\"\"\n    \n    # --- Physical and Numerical Parameters ---\n    grid_sizes = [50, 100, 200, 400]\n    a = 1.0  # Advection speed in m/s\n    L = 1.0  # Domain length in m\n    T = 1.0  # Final time in s\n    nu = 0.5  # CFL number\n\n    l2_errors = []\n\n    for N in grid_sizes:\n        # --- Grid and Time Step Setup ---\n        dx = L / N\n        dt = nu * dx / a\n        num_steps = int(round(T / dt))\n\n        # --- Initial Condition ---\n        # Cell centers\n        x = (np.arange(N) + 0.5) * dx\n        u = np.sin(2 * np.pi * x)\n\n        # --- Time Integration Loop ---\n        for _ in range(num_steps):\n            # Enforce periodic boundary conditions by rolling the array\n            u_im1 = np.roll(u, 1)  # u_{i-1}\n            u_ip1 = np.roll(u, -1)  # u_{i+1}\n            \n            # --- Calculate Slope Ratio r ---\n            # r_{i+1/2} is computed using info from cells i-1, i, i+1\n            # and is associated with the flux F_{i+1/2}\n            \n            # Numerator of r\n            num_r = u - u_im1\n            # Denominator of r\n            den_r = u_ip1 - u\n            \n            # Handle division by zero for r\n            r = np.zeros_like(u)\n            nonzero_den_mask = (den_r != 0)\n            r[nonzero_den_mask] = num_r[nonzero_den_mask] / den_r[nonzero_den_mask]\n            \n            # --- Calculate van Leer Flux Limiter phi ---\n            # phi(r) = (r + |r|) / (1 + |r|)\n            phi = (r + np.abs(r)) / (1.0 + np.abs(r))\n\n            # --- Calculate High-Resolution Flux F_{i+1/2} ---\n            # F_{i+1/2} = a*u_i + phi_i * a*(1-nu)/2 * (u_{i+1} - u_i)\n            \n            # First-order upwind flux\n            flux_low = a * u\n            \n            # Anti-diffusive correction term\n            flux_correction = phi * (a * (1 - nu) / 2.0) * den_r\n            \n            # High-resolution flux at the right cell interface (i+1/2)\n            F_iph = flux_low + flux_correction\n            \n            # Flux at the left cell interface (i-1/2) by rolling\n            F_imh = np.roll(F_iph, 1)\n            \n            # --- Update Solution ---\n            # u^{n+1} = u^n - (dt/dx) * (F_{i+1/2} - F_{i-1/2})\n            u = u - (dt / dx) * (F_iph - F_imh)\n\n        # --- Error Calculation ---\n        # Exact solution at t=T is the same as the initial condition\n        u_exact = np.sin(2 * np.pi * x)\n        \n        # L2-norm of the error\n        error = np.sqrt(np.sum((u - u_exact)**2) * dx)\n        l2_errors.append(error)\n\n    # --- Order of Accuracy Calculation ---\n    orders = []\n    for i in range(len(grid_sizes) - 1):\n        # p = log(E1/E2) / log(dx1/dx2)\n        # dx1/dx2 = 2 for grid doubling\n        order = np.log(l2_errors[i] / l2_errors[i+1]) / np.log(2)\n        orders.append(order)\n\n    # --- Verification of Second-Order Accuracy ---\n    # Condition: p >= 1.8 on the two finest refinements\n    verified = (orders[1] >= 1.8) and (orders[2] >= 1.8)\n\n    # --- Final Output Formatting ---\n    results_list = l2_errors + orders + [verified]\n    # Example format: [1.23e-04,3.08e-05,7.67e-06,1.91e-06,2.00,2.00,2.00,True]\n    # We use a mix of general and scientific notation for floats to be clean\n    formatted_results = []\n    for item in results_list:\n        if isinstance(item, bool):\n            formatted_results.append(str(item))\n        else: # float\n            if abs(item)  1e-3 and item != 0:\n                 formatted_results.append(f\"{item:.6e}\")\n            else:\n                 formatted_results.append(f\"{item:.6f}\")\n    \n    print(f\"[{','.join(map(str, results_list))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个鲁棒的数值格式需要同时仔细考虑空间和时间离散化。这个高级实践将探讨强稳定性保持（SSP）时间积分方法的关键概念。 您将构建一个场景，其中一个经过空间限制的格式，在与像经典四阶龙格-库塔（RK4）这样的非 SSP 时间积分方法耦合时，仍然会产生非物理振荡，从而凸显出整体性格式设计的重要性。",
            "id": "3955164",
            "problem": "考虑一维线性温度平流，其由守恒律 $T_t + a T_x = 0$ 在周期性域 $x \\in [0,1]$ 上控制，其中 $T(x,t)$ 是温度（单位：开尔文），$t$ 是时间（单位：秒），$a$ 是一个恒定的平流速度（单位：米/秒）。使用有限体积公式，其中单元平均值 $T_i^n$ 表示在时间层 $n$ 时单元 $i$ 中 $T$ 的平均值。半离散更新由通量差定义，\n$$\n\\frac{d T_i}{dt} = - \\frac{F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}}{\\Delta x},\n$$\n其中 $F_{i+\\frac{1}{2}}$ 是单元 $i$ 和 $i+1$ 之间单元界面上的一个相容的数值通量，$\\Delta x$ 是均匀的网格间距（单位：米）。使用带有 minmod 限制器的守恒律单调上游中心格式（MUSCL）重构来构造二阶空间离散化，以计算界面状态。将 minmod 函数定义为\n$$\n\\operatorname{minmod}(p,q) = \\begin{cases}\n\\operatorname{sign}(p)\\min(|p|,|q|),  \\text{if } \\operatorname{sign}(p) = \\operatorname{sign}(q), \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n对于每个界面 $x_{i+\\frac{1}{2}}$，重构左右状态，\n$$\nT_{i+\\frac{1}{2}}^L = T_i + \\frac{1}{2}\\operatorname{minmod}\\left(T_i - T_{i-1}, T_{i+1} - T_i\\right), \\quad\nT_{i+\\frac{1}{2}}^R = T_{i+1} - \\frac{1}{2}\\operatorname{minmod}\\left(T_{i+1} - T_i, T_{i+2} - T_{i+1}\\right),\n$$\n使用周期性索引。使用 Rusanov（局部 Lax–Friedrichs）数值通量，\n$$\nF_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(a T_{i+\\frac{1}{2}}^L + a T_{i+\\frac{1}{2}}^R\\right) - \\frac{1}{2}|a|\\left(T_{i+\\frac{1}{2}}^R - T_{i+\\frac{1}{2}}^L\\right).\n$$\n使用经典的四阶龙格-库塔方法（RK4）（这是一种非强稳定性保持（non-SSP）的高阶积分器），或三阶强稳定性保持龙格-库塔方法（SSPRK3）（这是一种 SSP 方法）进行时间积分。将 Courant–Friedrichs–Lewy (CFL) 数定义为 $\\text{CFL} = \\frac{a \\Delta t}{\\Delta x}$，其中 $\\Delta t$ 是时间步长（单位：秒）。对于 SSPRK3 方法，使用 Shu–Osher 分步格式，其中从 $n$ 到 $n+1$ 的更新由三个凸组合的前向欧拉式分步给出。\n\n将时间层 $n$ 时离散温度的总变差（在序列的意义上）定义为\n$$\n\\operatorname{TV}(T^n) = \\sum_{i=0}^{N-1} \\left| T_{i+1}^n - T_i^n \\right|,\n$$\n使用周期性索引，使得 $T_N^n \\equiv T_0^n$。总变差递减（TVD）条件要求在适当的稳定性条件下 $\\operatorname{TV}(T^{n+1}) \\le \\operatorname{TV}(T^n)$。强稳定性保持（SSP）方法保证，如果一个前向欧拉步在给定的空间离散化下，在某个时间步长限制下是 TVD 的，那么 SSP 方法在相关的时间步长限制下也保持 TVD，因为它可以被写成前向欧拉步的凸组合。非 SSP 方法（如 RK4）不保证 TVD，因此即使空间格式是受限的，也可能产生振荡。\n\n您的任务是构建计算实验，以展示一个非 SSP 的 RK4 方法在存在 MUSCL 空间限制的情况下仍产生振荡的案例，并通过计算总变差相对于初始总变差的最大归一化增量来量化对 TVD 条件的违反程度。对于每个实验，运行固定数量的时间步并计算\n$$\n\\mathcal{V} = \\max_{0 \\le n \\le N_{\\text{steps}}} \\frac{\\max\\left(\\operatorname{TV}(T^n) - \\operatorname{TV}(T^0), 0\\right)}{\\operatorname{TV}(T^0)}.\n$$\n将 $\\mathcal{V}$ 报告为十进制数（无量纲）。如果 $\\mathcal{V} = 0$，则在运行期间未违反 TVD 条件；如果 $\\mathcal{V}  0$，则 TVD 条件被违反的程度即为报告的数值。\n\n使用以下物理参数和初始条件，确保科学真实性和单位一致性：\n- 平流速度 $a = 1 \\ \\text{m/s}$。\n- 域长度 $L = 1 \\ \\text{m}$，具有周期性边界条件。\n- 网格分辨率 $N$ 个单元；因此 $\\Delta x = L/N$ 米。\n- 时间步长 $\\Delta t = \\text{CFL} \\cdot \\Delta x / a$ 秒。\n\n使用以下具有不同积分器类型、网格分辨率、CFL 数和初始条件的测试套件。对于初始条件，定义：\n- 阶跃剖面（单调不连续）：$T(x,0) = 1 \\ \\text{K}$ 对于 $x \\in [0.3, 0.7)$，否则 $T(x,0) = 0 \\ \\text{K}$。\n- 平滑余弦剖面：$T(x,0) = \\frac{1}{2}\\left(1 + \\cos(2\\pi x)\\right) \\ \\text{K}$。\n\n对每个测试运行 $N_{\\text{steps}} = 20$ 个时间步并计算 $\\mathcal{V}$。\n\n测试套件：\n1. 非 SSP RK4, $\\text{CFL} = 0.95$, $N = 50$, 阶跃剖面。\n2. SSPRK3, $\\text{CFL} = 0.95$, $N = 50$, 阶跃剖面。\n3. 非 SSP RK4, $\\text{CFL} = 0.90$, $N = 200$, 阶跃剖面。\n4. 非 SSP RK4, $\\text{CFL} = 0.95$, $N = 50$, 平滑余弦剖面。\n\n您的程序应生成单行输出，其中包含四个测试用例的结果，形式为方括号括起来的逗号分隔的十进制数列表（例如，“[result1,result2,result3,result4]”）。每个数字必须是相应测试用例的 $\\mathcal{V}$ 值，四舍五入到六位小数。由于所有输出都是无量纲比率，因此不应打印任何物理单位。如果使用了角度，单位将是弧度，但此设置不需要角度单位。不得使用百分比；所有结果都表示为小数。",
            "solution": "该问题陈述是偏微分方程数值方法领域中一个定义明确的计算实验，特别关注热工学中的输运现象。它是科学的、自洽的且客观的。所有参数、方程和数值方法都是计算流体动力学领域的标准方法。因此，该问题是有效的，并且可以构建一个解。\n\n任务是研究一维线性平流方程 $T_t + a T_x = 0$ 的数值格式的总变差递减（TVD）特性。该格式结合了二阶 MUSCL 空间重构和两种不同的时间积分方法：非强稳定性保持（non-SSP）的经典四阶龙格-库塔（RK4）方法和三阶强稳定性保持龙格-库塔（SSPRK3）方法。目标是证明并量化非 SSP 积分器即使在空间离散化旨在防止振荡的情况下，仍会引入振荡并违反 TVD 特性。\n\n解是使用有限体积法计算的。域 $x \\in [0, 1]$ 被划分为 $N$ 个宽度为 $\\Delta x = L/N = 1/N$ 的均匀单元。状态变量是单元平均温度 $T_i^n$。单元平均值 $T_i$ 演化的半离散方程由下式给出\n$$\n\\frac{d T_i}{dt} = \\mathcal{L}(T)_i = - \\frac{F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}}{\\Delta x}\n$$\n其中 $\\mathcal{L}(T)_i$ 代表空间离散算子，$F_{i+\\frac{1}{2}}$ 是单元 $i$ 和单元 $i+1$ 之间界面上的数值通量。\n\n**1. 空间离散化**\n\n空间离散化涉及三个步骤：数据重构、通量计算和通量差分。\n\n**1.1. 带 Minmod 限制器的 MUSCL 重构**\n\n为了在空间上达到二阶精度，我们根据单元平均值重构每个单元内的温度分布。在每个单元界面 $x_{i+\\frac{1}{2}}$ 处，我们通过带斜率限制的线性重构来确定左状态 $T_{i+\\frac{1}{2}}^L$ 和右状态 $T_{i+\\frac{1}{2}}^R$。\n\n每个单元 $i$ 中的斜率，记为 $\\Delta_i$，受到限制以防止在陡峭梯度附近产生伪振荡。为此使用了 minmod 限制器。它比较后向差分 $T_i - T_{i-1}$ 和前向差分 $T_{i+1} - T_i$。受限斜率由 $\\sigma_i = \\operatorname{minmod}(T_i - T_{i-1}, T_{i+1} - T_i)$ 给出，其中 minmod 函数定义为\n$$\n\\operatorname{minmod}(p,q) = \\begin{cases}\n\\operatorname{sign}(p)\\min(|p|,|q|),  \\text{if } \\operatorname{sign}(p) = \\operatorname{sign}(q) \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n这个限制器确保重构值不会引入新的局部极值，这是 TVD 格式的一个关键特性。界面 $x_{i+\\frac{1}{2}}$ 处的重构状态则为：\n$$\nT_{i+\\frac{1}{2}}^L = T_i + \\frac{1}{2}\\sigma_i\n$$\n$$\nT_{i+\\frac{1}{2}}^R = T_{i+1} - \\frac{1}{2}\\sigma_{i+1}\n$$\n通过对域边界处的单元索引进行环绕处理来施加周期性边界条件。例如，对于单元 $i=0$，值 $T_{i-1}$ 取为 $T_{N-1}$。\n\n**1.2. Rusanov (局部 Lax-Friedrichs) 通量**\n\n有了每个界面上的左右状态，数值通量 $F_{i+\\frac{1}{2}}$ 就用 Rusanov 公式计算。这种通量是鲁棒的，并引入与局部波速成正比的数值耗散。\n$$\nF_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(a T_{i+\\frac{1}{2}}^L + a T_{i+\\frac{1}{2}}^R\\right) - \\frac{1}{2}|a|\\left(T_{i+\\frac{1}{2}}^R - T_{i+\\frac{1}{2}}^L\\right)\n$$\n由于平流速度给定为 $a=1 \\ \\text{m/s}  0$，这简化为迎风通量 $F_{i+\\frac{1}{2}} = a T_{i+\\frac{1}{2}}^L$。\n\n**2. 时间离散化**\n\n半离散系统 $\\frac{dT}{dt} = \\mathcal{L}(T)$ 是一个常微分方程组，使用龙格-库塔方法求解。\n\n**2.1. 三阶强稳定性保持龙格-库塔 (SSPRK3)**\n\nSSP 方法旨在保持前向欧拉法的稳定性（如 TVD 特性）。SSPRK3 方法通过三个阶段将解从时间 $n$推进到 $n+1$：\n$$\n\\begin{aligned}\nT^{(1)} = T^n + \\Delta t \\mathcal{L}(T^n) \\\\\nT^{(2)} = \\frac{3}{4}T^n + \\frac{1}{4}T^{(1)} + \\frac{1}{4}\\Delta t \\mathcal{L}(T^{(1)}) \\\\\nT^{n+1} = \\frac{1}{3}T^n + \\frac{2}{3}T^{(2)} + \\frac{2}{3}\\Delta t \\mathcal{L}(T^{(2)})\n\\end{aligned}\n$$\n如果空间算子 $\\mathcal{L}$ 与前向欧拉法耦合在某个 CFL 条件下是 TVD 的，则 SSPRK3 保证全离散格式在相关的 CFL 条件下也是 TVD 的。\n\n**2.2. 经典四阶龙格-库塔 (RK4)**\n\n经典的 RK4 方法以其高精度而闻名，但它不是一种 SSP 方法。这意味着即使空间格式在前向欧拉法下是 TVD 的，它也可能违反 TVD 特性。其分步为：\n$$\n\\begin{aligned}\nk_1 = \\mathcal{L}(T^n) \\\\\nk_2 = \\mathcal{L}(T^n + \\frac{\\Delta t}{2} k_1) \\\\\nk_3 = \\mathcal{L}(T^n + \\frac{\\Delta t}{2} k_2) \\\\\nk_4 = \\mathcal{L}(T^n + \\Delta t k_3) \\\\\nT^{n+1} = T^n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\n这些系数不满足 SSP 方法所需的凸组合性质。\n\n**3. TVD 违反的评估**\n\n为了量化性能，我们测量每个时间步 $n$ 处离散解的总变差（TV）：\n$$\n\\operatorname{TV}(T^n) = \\sum_{i=0}^{N-1} |T_{i+1}^n - T_i^n|\n$$\n其中由于周期性，$T_N^n \\equiv T_0^n$。如果对所有 $n$ 都有 $\\operatorname{TV}(T^{n+1}) \\le \\operatorname{TV}(T^n)$，则格式是 TVD 的。我们计算仿真过程中 TV 的最大归一化增量，由度量 $\\mathcal{V}$ 定义：\n$$\n\\mathcal{V} = \\max_{0 \\le n \\le N_{\\text{steps}}} \\frac{\\max\\left(\\operatorname{TV}(T^n) - \\operatorname{TV}(T^0), 0\\right)}{\\operatorname{TV}(T^0)}\n$$\n$\\mathcal{V} = 0$ 的值表示未观察到 TVD 违规，而 $\\mathcal{V}  0$ 则量化了违规的程度。\n\n**4. 实现与测试流程**\n\n对指定的四个测试用例中的每一个都进行仿真。流程如下：\n1.  定义具有 $N$ 个单元和单元中心 $x_i = (i+0.5)\\Delta x$ 的网格。\n2.  根据给定的剖面（阶跃或余弦），在单元中心采样，初始化温度数组 $T^0$。\n3.  计算恒定时间步长 $\\Delta t = \\text{CFL} \\cdot \\Delta x / a$。\n4.  计算初始总变差 $\\operatorname{TV}(T^0)$。\n5.  迭代 $N_{\\text{steps}} = 20$ 个时间步。在每一步中，使用指定的时间积分器（SSPRK3 或 RK4）更新解 $T^n \\to T^{n+1}$。\n6.  在每一步，计算并存储 $\\operatorname{TV}(T^n)$。\n7.  仿真结束后，从存储的总变差值历史记录中计算度量 $\\mathcal{V}$。\n\n此流程被系统地应用于所有测试用例，并报告所得的 $\\mathcal{V}$ 值。该实现使用向量化的 `NumPy` 操作以提高效率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation test suite and print results.\n    \"\"\"\n\n    def minmod(p, q):\n        \"\"\"\n        Vectorized minmod limiter function.\n        \"\"\"\n        sign_p = np.sign(p)\n        result = np.zeros_like(p)\n        # The condition sign(p) * sign(q) > 0 is a concise way to handle signs\n        # and avoids issues with np.sign(0) = 0.\n        idx = np.where(sign_p * np.sign(q) > 0)\n        result[idx] = sign_p[idx] * np.minimum(np.abs(p[idx]), np.abs(q[idx]))\n        return result\n\n    def compute_rhs(T, dx, a):\n        \"\"\"\n        Computes the right-hand side of the semi-discrete finite volume scheme.\n        This corresponds to the spatial operator L(T).\n        \"\"\"\n        # Periodic boundary conditions via np.roll\n        T_im1 = np.roll(T, 1)\n        T_ip1 = np.roll(T, -1)\n\n        # MUSCL reconstruction with minmod limiter\n        # Slope in each cell i is based on differences with neighbors\n        delta_backward = T - T_im1\n        delta_forward = T_ip1 - T\n        sigma = minmod(delta_backward, delta_forward)\n\n        # Reconstructed states at interface i+1/2\n        # T_L corresponds to T_{i+1/2}^L, T_R to T_{i+1/2}^R\n        T_L = T + 0.5 * sigma\n        T_R = T_ip1 - 0.5 * np.roll(sigma, -1)\n\n        # Rusanov (local Lax-Friedrichs) flux\n        # F_flux[i] corresponds to F_{i+1/2}\n        flux_avg = 0.5 * (a * T_L + a * T_R)\n        dissipation = 0.5 * np.abs(a) * (T_R - T_L)\n        F_flux = flux_avg - dissipation\n\n        # Flux difference for each cell i: F_{i+1/2} - F_{i-1/2}\n        rhs = -(F_flux - np.roll(F_flux, 1)) / dx\n        return rhs\n\n    def ssprk3_step(T, dt, dx, a):\n        \"\"\"\n        Performs one time step using the third-order SSP Runge-Kutta method.\n        \"\"\"\n        T1 = T + dt * compute_rhs(T, dx, a)\n        T2 = 0.75 * T + 0.25 * (T1 + dt * compute_rhs(T1, dx, a))\n        T_next = (1.0 / 3.0) * T + (2.0 / 3.0) * (T2 + dt * compute_rhs(T2, dx, a))\n        return T_next\n\n    def rk4_step(T, dt, dx, a):\n        \"\"\"\n        Performs one time step using the classical fourth-order Runge-Kutta method.\n        \"\"\"\n        k1 = compute_rhs(T, dx, a)\n        k2 = compute_rhs(T + 0.5 * dt * k1, dx, a)\n        k3 = compute_rhs(T + 0.5 * dt * k2, dx, a)\n        k4 = compute_rhs(T + dt * k3, dx, a)\n        T_next = T + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n        return T_next\n\n    def total_variation(T):\n        \"\"\"\n        Computes the total variation of a discrete solution with periodic boundaries.\n        \"\"\"\n        return np.sum(np.abs(T - np.roll(T, 1)))\n\n    def run_simulation(integrator, cfl, N, ic_profile, n_steps):\n        \"\"\"\n        Runs a single simulation case and computes the TVD violation metric V.\n        \"\"\"\n        # Physical and grid parameters\n        L = 1.0\n        a = 1.0\n        dx = L / N\n        dt = cfl * dx / a\n\n        x = (np.arange(N) + 0.5) * dx\n\n        # Initial conditions\n        if ic_profile == 'step':\n            T = np.where((x >= 0.3)  (x  0.7), 1.0, 0.0)\n        elif ic_profile == 'cosine':\n            T = 0.5 * (1.0 + np.cos(2.0 * np.pi * x))\n        else:\n            raise ValueError(\"Unknown initial condition profile.\")\n\n        # Determine the time stepping function\n        if integrator == 'RK4':\n            step_func = rk4_step\n        elif integrator == 'SSPRK3':\n            step_func = ssprk3_step\n        else:\n            raise ValueError(\"Unknown integrator.\")\n\n        # Compute initial total variation\n        tv0 = total_variation(T)\n        if tv0 == 0.0:\n            return 0.0 # No variation to increase\n\n        tv_history = [tv0]\n        \n        T_current = T.copy()\n        for _ in range(n_steps):\n            T_current = step_func(T_current, dt, dx, a)\n            tv_history.append(total_variation(T_current))\n\n        # Compute the metric V\n        tv_history = np.array(tv_history)\n        max_tv_increase = np.max(np.maximum(tv_history - tv0, 0))\n        \n        V = max_tv_increase / tv0\n        \n        return V\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'integrator': 'RK4', 'cfl': 0.95, 'N': 50, 'ic_profile': 'step', 'n_steps': 20},\n        {'integrator': 'SSPRK3', 'cfl': 0.95, 'N': 50, 'ic_profile': 'step', 'n_steps': 20},\n        {'integrator': 'RK4', 'cfl': 0.90, 'N': 200, 'ic_profile': 'step', 'n_steps': 20},\n        {'integrator': 'RK4', 'cfl': 0.95, 'N': 50, 'ic_profile': 'cosine', 'n_steps': 20},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}