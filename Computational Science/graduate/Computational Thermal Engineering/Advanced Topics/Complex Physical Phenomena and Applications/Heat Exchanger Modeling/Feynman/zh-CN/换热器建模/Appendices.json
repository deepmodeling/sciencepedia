{
    "hands_on_practices": [
        {
            "introduction": "在计算建模中，确保数值解随着网格加密而收敛于一个确定的、与网格无关的解，是验证模型正确性的基本步骤。本练习将引导你应用理查森外推法 (Richardson extrapolation)，这是一种强大的技术，它能够利用在一系列加密网格上得到的数值解来估计模型的收敛阶数和精确解。通过这项实践，你将掌握评估数值方案准确性的核心方法。",
            "id": "3960797",
            "problem": "一个长度为 $L$、湿周长为 $P$ 的一维并流双套管换热器在稳态下运行，两种流体和管壁的轴向热传导均可忽略不计。每股流体在其横截面上都充分混合，物性参数恒定，总传热系数 (OHTC) $U$ 沿长度方向是均匀的。热、冷流体的质量流量分别为 $m_h$ 和 $m_c$，恒定比热容分别为 $c_{p,h}$ 和 $c_{p,c}$。入口温度为 $T_{h,\\text{in}}$ 和 $T_{c,\\text{in}}$。利用热力学第一定律和牛顿冷却定律，对沿换熱器长度为 $dx$ 的微分控制体进行能量平衡分析，可以得到描述热、冷流体温度 $T_h(x)$ 和 $T_c(x)$（其中 $x \\in [0,L]$）的一维耦合常微分控制方程。本题要求在一个包含 $N$ 个控制体的均匀网格上，通过保守的有限体积离散化方法对这些场变量进行数值近似；为一系列逐次加密的网格计算出口温度 $T_{h,\\text{out}} = T_h(L)$ 和 $T_{c,\\text{out}} = T_c(L)$；并通过 Richardson 外推法进行网格收敛性研究，以估计观测到的精度阶。\n\n从基本定律和核心定义出发，推导一个针对均匀网格尺寸 $h = L/N$、在轴向坐标 $x$ 上协调的一阶精度隐式推进格式。编写程序实现该格式，程序需要：\n- 使用入口温度作为边界值，从 $x=0$ 推进到 $x=L$；\n- 针对加密比 $r = 2$ 的三个逐次加密网格，计算出口温度；\n- 应用 Richardson 外推法估计每个出口温度的观测精度阶。\n\n您必须使用以下参数值测试套件（每个测试用例使用三个网格，其 $N_1$, $N_2$, $N_3$ 满足 $N_2 = 2 N_1$ 和 $N_3 = 2 N_2$）：\n\n- 测试用例 A (热容率平衡，中等传热): $L=5$ m, $P=1$ m, $U=400$ W/m$^2$K, $m_h=1.5$ kg/s, $c_{p,h}=4180$ J/kgK, $m_c=1.5$ kg/s, $c_{p,c}=4180$ J/kgK, $T_{h,\\text{in}}=360$ K, $T_{c,\\text{in}}=300$ K, $(N_1,N_2,N_3)=(50,100,200)$.\n- 测试用例 B (热容率不平衡): $L=5$ m, $P=1$ m, $U=300$ W/m$^2$K, $m_h=3.0$ kg/s, $c_{p,h}=4180$ J/kgK, $m_c=1.0$ kg/s, $c_{p,c}=4180$ J/kgK, $T_{h,\\text{in}}=370$ K, $T_{c,\\text{in}}=295$ K, $(N_1,N_2,N_3)=(50,100,200)$.\n- 测试用例 C (较长换热器，弱传热): $L=10$ m, $P=1$ m, $U=80$ W/m$^2$K, $m_h=2.0$ kg/s, $c_{p,h}=4180$ J/kgK, $m_c=2.5$ kg/s, $c_{p,c}=4180$ J/kgK, $T_{h,\\text{in}}=350$ K, $T_{c,\\text{in}}=310$ K, $(N_1,N_2,N_3)=(50,100,200)$.\n- 测试用例 D (较短换热器，强传热): $L=2$ m, $P=0.8$ m, $U=1200$ W/m$^2$K, $m_h=0.8$ kg/s, $c_{p,h}=4180$ J/kgK, $m_c=0.8$ kg/s, $c_{p,c}=4180$ J/kgK, $T_{h,\\text{in}}=330$ K, $T_{c,\\text{in}}=290$ K, $(N_1,N_2,N_3)=(50,100,200)$.\n\n对于每个测试用例，计算 $N_1$, $N_2$ 和 $N_3$ 对应的出口温度，然后使用 Richardson 外推法估计热流体出口温度的观测精度阶 $p_h$ 和冷流体出口温度的观测精度阶 $p_c$。此外，还需基于最密的两个网格和估计的阶数，计算经 Richardson 外推得到的出口温度 $T_{h,\\infty}$ 和 $T_{c,\\infty}$（单位为开尔文）。如果 Richardson 估计不处于渐近区（例如，如果连续差值变号或消失），则对该分量的阶数和外推温度返回一个非数值 (non-number)。\n\n输出和单位要求：\n- 温度必须在内部计算，并在报告时以开尔文表示。\n- 观测到的阶数 $p_h$ 和 $p_c$ 是无量纲的。\n- 将每个观测到的阶数四舍五入到 $5$ 位小数，将每个外推的出口温度四舍五入到 $3$ 位小数。\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表形式的结果，每个测试用例一个列表，顺序为 A、B、C、D。每个内部列表必须为 $[p_h, p_c, T_{h,\\infty}, T_{c,\\infty}]$ 的形式。例如：$[[p_h^{(A)},p_c^{(A)},T_{h,\\infty}^{(A)},T_{c,\\infty}^{(A)}],[p_h^{(B)},p_c^{(B)},T_{h,\\infty}^{(B)},T_{c,\\infty}^{(B)}],\\dots]$。\n\n程序必须是完整且可运行的，并且不得要求任何用户输入。",
            "solution": "问题要求推導并实现一个一阶精度的隐式有限体积格式，用于模拟一维并流双套管换热器。该实现将用于在逐次加密的网格上计算多个测试用例的出口温度，然后使用 Richardson 外推法进行网格收敛性研究，以估计精度阶和外推得到的、与网格无关的出口温度。\n\n### 步骤 1：控制方程\n物理系统是一个在稳态下运行的并流换热器。我们将热力学第一定律（能量守恒）应用于沿换热器轴线、从位置 $x$到 $x+dx$、长度为 $dx$ 的微分控制体。\n\n两种流体之间通过微分面积 $dA = P dx$ 的传热率 $\\delta\\dot{Q}$ 由牛顿冷却定律给出：\n$$ \\delta\\dot{Q} = U (T_h(x) - T_c(x)) P dx $$\n其中 $U$ 是总传热系数，$P$ 是湿周長，$T_h(x)$ 和 $T_c(x)$ 分别是热流体和冷流体的局部温度。\n\n对于热流体，焓率的变化必须与传出流体的热量相平衡：\n$$ \\dot{m}_h c_{p,h} T_h(x) - \\dot{m}_h c_{p,h} T_h(x+dx) = \\delta\\dot{Q} $$\n$$ -\\dot{m}_h c_{p,h} (T_h(x+dx) - T_h(x)) = U P (T_h(x) - T_c(x)) dx $$\n将热流体的热容率定义为 $C_h = \\dot{m}_h c_{p,h}$，并取极限 $dx \\to 0$，我们得到第一个常微分控制方程 (ODE)：\n$$ \\frac{dT_h}{dx} = -\\frac{UP}{C_h} (T_h - T_c) $$\n\n对于冷流体，焓率的变化必须与传入流体的热量相平衡：\n$$ \\dot{m}_c c_{p,c} T_c(x+dx) - \\dot{m}_c c_{p,c} T_c(x) = \\delta\\dot{Q} $$\n将冷流体的热容率定义为 $C_c = \\dot{m}_c c_{p,c}$，并取极限 $dx \\to 0$，我们得到第二个常微分控制方程 (ODE)：\n$$ \\frac{dT_c}{dx} = \\frac{UP}{C_c} (T_h - T_c) $$\n\n这是一个空间上的初值问题，边界条件在入口 $x=0$ 处给出：\n$$ T_h(0) = T_{h,\\text{in}} \\quad \\text{and} \\quad T_c(0) = T_{c,\\text{in}} $$\n\n### 步骤 2：有限体积离散化与隐式格式\n我们将长度为 $L$ 的区域离散为 $N$ 个均匀的控制体 (CV)，每个控制体的长度为 $h = L/N$。节点位于位置 $x_i = i \\cdot h$，其中 $i = 0, 1, \\dots, N$。第 $i$ 个控制体的范围是从 $x_i$ 到 $x_{i+1}$。我们在这个控制体上对控制 ODE 进行积分。\n\n对于热流体：\n$$ \\int_{x_i}^{x_{i+1}} \\frac{dT_h}{dx} dx = \\int_{x_i}^{x_{i+1}} -\\frac{UP}{C_h} (T_h(x) - T_c(x)) dx $$\n$$ T_h(x_{i+1}) - T_h(x_i) = -\\frac{UP}{C_h} \\int_{x_i}^{x_{i+1}} (T_h(x) - T_c(x)) dx $$\n令 $T_{h,i}$ 表示温度 $T_h(x_i)$。方程变为：\n$$ T_{h,i+1} - T_{h,i} = -\\frac{UP}{C_h} \\int_{x_i}^{x_{i+1}} (T_h(x) - T_c(x)) dx $$\n\n类似地，对于冷流体：\n$$ T_{c,i+1} - T_{c,i} = \\frac{UP}{C_c} \\int_{x_i}^{x_{i+1}} (T_h(x) - T_c(x)) dx $$\n\n为了构建一个一阶精度的隐式格式，我们使用区间末端 $x_{i+1}$ 处的函数值来近似右侧的积分。这是一种后向欧拉法。\n$$ \\int_{x_i}^{x_{i+1}} f(x) dx \\approx f(x_{i+1}) \\cdot (x_{i+1} - x_i) = f_{i+1} \\cdot h $$\n将此应用于我们的积分方程：\n$$ T_{h,i+1} - T_{h,i} = -\\frac{UP h}{C_h} (T_{h,i+1} - T_{c,i+1}) $$\n$$ T_{c,i+1} - T_{c,i} = \\frac{UP h}{C_c} (T_{h,i+1} - T_{c,i+1}) $$\n\n这是关于节点 $i+1$ 处的未知温度 $T_{h,i+1}$ 和 $T_{c,i+1}$ 的两个耦合线性代数方程，用节点 $i$ 处的已知温度表示。我们定义无量纲参数 $k_h = \\frac{UP h}{C_h}$ 和 $k_c = \\frac{UP h}{C_c}$。\n$$ T_{h,i+1} - T_{h,i} = -k_h (T_{h,i+1} - T_{c,i+1}) $$\n$$ T_{c,i+1} - T_{c,i} = k_c (T_{h,i+1} - T_{c,i+1}) $$\n重新整理，将未知数置于左侧：\n$$ (1+k_h) T_{h,i+1} - k_h T_{c,i+1} = T_{h,i} $$\n$$ -k_c T_{h,i+1} + (1+k_c) T_{c,i+1} = T_{c,i} $$\n这是每个推进步的 $2 \\times 2$ 线性系统：\n$$ \\begin{pmatrix} 1+k_h  -k_h \\\\ -k_c  1+k_c \\end{pmatrix} \\begin{pmatrix} T_{h,i+1} \\\\ T_{c,i+1} \\end{pmatrix} = \\begin{pmatrix} T_{h,i} \\\\ T_{c,i} \\end{pmatrix} $$\n\n### 步骤 3：推进格式的推导\n为找到更新法则，我们求解这个 $2 \\times 2$ 系统。系数矩阵的行列式为 $D = (1+k_h)(1+k_c) - (-k_h)(-k_c) = 1 + k_h + k_c$。该矩阵的逆矩阵是：\n$$ \\frac{1}{1+k_h+k_c} \\begin{pmatrix} 1+k_c  k_h \\\\ k_c  1+k_h \\end{pmatrix} $$\n因此，节点 $i+1$ 处的温度解为：\n$$ \\begin{pmatrix} T_{h,i+1} \\\\ T_{c,i+1} \\end{pmatrix} = \\frac{1}{1+k_h+k_c} \\begin{pmatrix} 1+k_c  k_h \\\\ k_c  1+k_h \\end{pmatrix} \\begin{pmatrix} T_{h,i} \\\\ T_{c,i} \\end{pmatrix} $$\n这给出了推进格式的显式更新公式：\n$$ T_{h,i+1} = \\frac{(1+k_c)T_{h,i} + k_h T_{c,i}}{1+k_h+k_c} $$\n$$ T_{c,i+1} = \\frac{k_c T_{h,i} + (1+k_h) T_{c,i}}{1+k_h+k_c} $$\n从已知的入口温度 $T_{h,0} = T_{h,\\text{in}}$ 和 $T_{c,0} = T_{c,\\text{in}}$ 开始，我们应用此格式 $N$ 次，从 $x=0$ 推进到 $x=L$，从而得到出口温度 $T_{h,N}$ 和 $T_{c,N}$。\n\n### 步骤 4：通过 Richardson 外推法进行网格收敛性分析\n设 $f_h$ 为在网格间距为 $h$ 的情况下计算得到的某个关注量（例如出口温度）的通用数值解。假设其误差展开式形式为 $f_h = f_{exact} + A h^p + \\mathcal{O}(h^q)$，其中 $p$ 是精度阶，且 $q>p$。\n给定在步长分别为 $h_1, h_2=h_1/r, h_3=h_2/r$ 的网格上计算得到的三个解 $f_1, f_2, f_3$，其中加密比 $r=2$，则观测到的精度阶 $p$ 可以估计为：\n$$ p = \\frac{\\ln\\left(\\frac{f_2 - f_1}{f_3 - f_2}\\right)}{\\ln(r)} $$\n该估计仅在解处于渐近收敛区时有效，此时连续差值 $(f_2-f_1)$ 和 $(f_3-f_2)$ 符号相同且非零。如果收敛不是单调的，我们就无法可靠地估计 $p$。\n\n一旦估计出 $p$，就可以通过从两个最密网格的解（$f_2, f_3$）进行外推，得到对精确解 $f_{\\infty}$ 更准确的估计：\n$$ f_{\\infty} = f_3 + \\frac{f_3 - f_2}{r^p - 1} $$\n对每个测试用例，此过程分别应用于热侧出口温度 ($T_{h,\\text{out}}$) 和冷侧出口温度 ($T_{c,\\text{out}}$)。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve_heat_exchanger(L, P, U, mh, cph, mc, cpc, Th_in, Tc_in, N):\n    \"\"\"\n    Solves for the outlet temperatures of a co-current heat exchanger\n    using a first-order implicit finite volume method.\n\n    Args:\n        L (float): Length of the exchanger (m).\n        P (float): Wetted perimeter (m).\n        U (float): Overall heat transfer coefficient (W/m^2K).\n        mh (float): Mass flow rate of hot fluid (kg/s).\n        cph (float): Specific heat of hot fluid (J/kgK).\n        mc (float): Mass flow rate of cold fluid (kg/s).\n        cpc (float): Specific heat of cold fluid (J/kgK).\n        Th_in (float): Inlet temperature of hot fluid (K).\n        Tc_in (float): Inlet temperature of cold fluid (K).\n        N (int): Number of control volumes.\n\n    Returns:\n        tuple[float, float]: Outlet temperatures (Th_out, Tc_out) in Kelvin.\n    \"\"\"\n    h = L / N\n    Ch = mh * cph\n    Cc = mc * cpc\n\n    # Handle potential division by zero if C is zero\n    if Ch == 0 or Cc == 0:\n        return (Th_in, Tc_in) if Ch == 0 else (np.nan, np.nan), (Tc_in, Th_in) if Cc == 0 else (np.nan, np.nan)\n\n\n    kh = U * P * h / Ch\n    kc = U * P * h / Cc\n    \n    denominator = 1.0 + kh + kc\n\n    Th_current = Th_in\n    Tc_current = Tc_in\n\n    for _ in range(N):\n        Th_next = ((1.0 + kc) * Th_current + kh * Tc_current) / denominator\n        Tc_next = (kc * Th_current + (1.0 + kh) * Tc_current) / denominator\n        Th_current = Th_next\n        Tc_current = Tc_next\n        \n    return Th_current, Tc_current\n\ndef perform_richardson_extrapolation(f1, f2, f3, r):\n    \"\"\"\n    Performs Richardson extrapolation to find the observed order and extrapolated value.\n\n    Args:\n        f1, f2, f3 (float): Solutions on coarse, medium, and fine grids.\n        r (float): Refinement ratio.\n\n    Returns:\n        tuple[float, float]: Observed order p and extrapolated value f_inf.\n    \"\"\"\n    diff1 = f2 - f1\n    diff2 = f3 - f2\n\n    # Check for asymptotic regime\n    if diff1 * diff2 = 0:\n        return np.nan, np.nan\n\n    ratio = diff1 / diff2\n    \n    # Another check for validity\n    if ratio = 0:\n        return np.nan, np.nan\n\n    p = math.log(ratio) / math.log(r)\n    \n    if (r**p - 1.0) == 0:\n        return p, np.nan\n        \n    f_inf = f3 + diff2 / (r**p - 1.0)\n    \n    return p, f_inf\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print final results.\n    \"\"\"\n    test_cases = [\n        # Test case A\n        {'L': 5, 'P': 1, 'U': 400, 'mh': 1.5, 'cph': 4180, 'mc': 1.5, 'cpc': 4180, 'Th_in': 360, 'Tc_in': 300, 'N_tuple': (50, 100, 200)},\n        # Test case B\n        {'L': 5, 'P': 1, 'U': 300, 'mh': 3.0, 'cph': 4180, 'mc': 1.0, 'cpc': 4180, 'Th_in': 370, 'Tc_in': 295, 'N_tuple': (50, 100, 200)},\n        # Test case C\n        {'L': 10, 'P': 1, 'U': 80, 'mh': 2.0, 'cph': 4180, 'mc': 2.5, 'cpc': 4180, 'Th_in': 350, 'Tc_in': 310, 'N_tuple': (50, 100, 200)},\n        # Test case D\n        {'L': 2, 'P': 0.8, 'U': 1200, 'mh': 0.8, 'cph': 4180, 'mc': 0.8, 'cpc': 4180, 'Th_in': 330, 'Tc_in': 290, 'N_tuple': (50, 100, 200)},\n    ]\n    \n    r = 2.0  # Refinement ratio\n    final_results_str_list = []\n\n    for case in test_cases:\n        params = {k: v for k, v in case.items() if k != 'N_tuple'}\n        N1, N2, N3 = case['N_tuple']\n        \n        Th_out1, Tc_out1 = solve_heat_exchanger(**params, N=N1)\n        Th_out2, Tc_out2 = solve_heat_exchanger(**params, N=N2)\n        Th_out3, Tc_out3 = solve_heat_exchanger(**params, N=N3)\n        \n        p_h, Th_inf = perform_richardson_extrapolation(Th_out1, Th_out2, Th_out3, r)\n        p_c, Tc_inf = perform_richardson_extrapolation(Tc_out1, Tc_out2, Tc_out3, r)\n\n        ph_str = f\"{p_h:.5f}\" if not np.isnan(p_h) else \"nan\"\n        pc_str = f\"{p_c:.5f}\" if not np.isnan(p_c) else \"nan\"\n        Th_inf_str = f\"{Th_inf:.3f}\" if not np.isnan(Th_inf) else \"nan\"\n        Tc_inf_str = f\"{Tc_inf:.3f}\" if not np.isnan(Tc_inf) else \"nan\"\n        \n        case_str = f\"[{ph_str},{pc_str},{Th_inf_str},{Tc_inf_str}]\"\n        final_results_str_list.append(case_str)\n\n    print(f\"[{','.join(final_results_str_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "实际的换热器工况常常涉及显著的温度梯度，这会导致流体物性（如黏度）发生变化，从而影响换热性能。本练习将重点探讨如何量化温度依赖性黏度对传热系数的影响，并通过应用经典的 Sieder-Tate 修正，将这一重要的物理效应整合到模型中。这有助于你理解从理想化模型向更贴近现实的物理模型迈进的关键步骤。",
            "id": "3960822",
            "problem": "一台单程逆流管壳式换热器，通过壳程的饱和蒸汽冷凝，来加热在光滑圆管内流动的对温度敏感的液体。在管程侧，假设流动为充分发展的、稳态的、湍流的、单相、单组分的流动，且轴向热传导和粘性耗散可忽略不计。根据一个已收敛的换热器模型确定，在所关注的轴向位置，管内径为 $D=0.025$ m，管程质量流量为 $\\dot{m}=0.80$ kg s$^{-1}$，管程平均（主流）温度为 $T_{b}=330$ K，而内壁面温度为 $T_{w}=380$ K。该液体的密度为 $\\rho=870$ kg m$^{-3}$，比热容为 $c_{p}=2000$ J kg$^{-1}$ K$^{-1}$，导热系数为 $k=0.13$ W m$^{-1}$ K$^{-1}$，在这一温度范围内可视为常数。其动力粘度遵循 Andrade 关系式\n$$\n\\mu(T)=A\\,\\exp\\!\\left(\\frac{B}{T}\\right),\n$$\n其中 $A=3.68\\times 10^{-5}$ Pa s 且 $B=2670$ K。\n\n请仅从湍流内流的动量和能量守恒以及壁面层控制传热和动量传递的概念出发，解释为何主流与壁面之间的粘度变化会修正基于雷诺数 (Re) 和普朗特数 (Pr) 的关联式所预测的传热系数。对于在光滑管内被加热的液体湍流，论证一个依赖于比值 $\\mu_{b}/\\mu_{w}$（其中 $\\mu_{b}\\equiv \\mu(T_{b})$ 且 $\\mu_{w}\\equiv \\mu(T_{w})$）的乘法修正项的出现是合理的。然后，使用一个以乘法形式包含了这种壁面粘度修正的、被广泛接受的湍流管内传热关联式，计算无量纲比值\n$$\nR \\equiv \\frac{\\text{考虑粘度变化修正的Nu}}{\\text{假设在主流条件下粘度恒定的Nu}}.\n$$\n将您计算出的 $R$ 的最终答案表示为一个纯数（无单位），并四舍五入到四位有效数字。不要报告任何中间值；仅报告按要求四舍五入后的最终 $R$ 值。",
            "solution": "该问题具有科学依据、提法得当且客观，并给出了一套完整且一致的已知条件，因此被认为是有效的。\n\n问题要求分为两部分：首先，对传热关联式中的粘度修正因子进行理论论证；其次，根据给定条件计算该修正因子。\n\n**第一部分：理论论证**\n\n在湍流内流中，动量传递和传热的主要阻力都集中在紧邻壁面的一个非常薄的区域内，该区域被称为粘性底层。控制该层内输运过程的基本原理是动量守恒和能量守恒。\n\n在近壁区，流动几乎与壁面平行（坐标 $y$ 垂直于壁面），剪切应力 $\\tau$ 和热通量 $q''$ 近似为常数，且等于其壁面值 $\\tau_w$ 和 $q_w''$。在粘性底层内，分子输运机制占主导地位。因此，壁面剪切应力和壁面热通量可分别用牛顿粘性定律和傅里叶导热定律表示：\n$$\n\\tau_w = \\mu \\frac{\\partial u}{\\partial y} \\bigg|_{y \\to 0}\n$$\n$$\nq_w'' = -k \\frac{\\partial T}{\\partial y} \\bigg|_{y \\to 0}\n$$\n此处，$\\mu$ 是动力粘度，$k$ 是导热系数，两者都是依赖于温度的物性参数。\n\n由 Osborne Reynolds 首次提出，后经 Chilton 和 Colburn 等人完善的动量传递与传热之间的类比，建立了流体摩擦与对流之间的直接联系。广泛用于湍流的 Chilton-Colburn 类比，通过普朗特数 Pr 将摩擦系数 $C_f$ 与斯坦顿数 St 联系起来：\n$$\n\\frac{C_f}{2} = \\text{St} \\cdot \\text{Pr}^{2/3}\n$$\n斯坦顿数的定义为 $\\text{St} \\equiv \\frac{h}{\\rho U_m c_p}$，其中 $h$ 是传热系数，$\\rho$ 是密度，$U_m$ 是平均速度，$c_p$ 是比热容。努塞尔数 $\\text{Nu} \\equiv \\frac{hD}{k}$ 通过 $\\text{Nu} = \\text{St} \\cdot \\text{Re} \\cdot \\text{Pr}$ 与斯坦顿数相关联。这些关系表明，任何影响壁面剪切应力和摩擦系数的因素，也同样会影响传热系数和努塞尔数。\n\n该问题描述的是液体被加热的过程，其中壁面温度 $T_w$ ($380$ K) 高于主流体温度 $T_b$ ($330$ K)。对大多数液体而言，粘度是温度的强减函数。所给出的 Andrade 关系式 $\\mu(T)=A\\,\\exp(B/T)$（其中 $B  0$）证实了这一特性。因此，壁面处的流体粘度 $\\mu_w \\equiv \\mu(T_w)$ 显著低于流动主流中的粘度 $\\mu_b \\equiv \\mu(T_b)$。\n\n这种横跨温度边界层的粘度变化，与物性恒定的流动相比，会使速度分布发生扭曲。靠近热壁面的较低粘度意味着流体更具流动性，并且在给定的剪切应力下，速度梯度 $\\partial u / \\partial y$ 更大。这导致粘性底层变薄。由于粘性底层是热阻最高的区域，该层的变薄降低了总传热阻力。结果是，与物性恒定的情况相比，传热系数 $h$ 得到增强。\n\n标准的传热关联式，如 Dittus-Boelter 方程，其形式为 $\\text{Nu}_b = C \\cdot \\text{Re}_b^m \\cdot \\text{Pr}_b^p$，其中所有流体物性均在主流温度 $T_b$ 下取值。这些关联式是从小温差实验数据中推导出来的，并未考虑上述的物性变化效应。\n\n为了对此进行修正，引入了一个乘法因子。对液体而言，最重要的物性变化是粘度。无量纲比值 $\\mu_b / \\mu_w$ 量化了这种变化的程度。基于大量实验数据，Sieder 和 Tate 提出了形式为：\n$$\n\\text{Nu} = \\text{Nu}_b \\left(\\frac{\\mu_b}{\\mu_w}\\right)^n\n$$\n的修正，其中 $\\text{Nu}_b$ 是使用主流物性计算的努塞尔数。指数 $n$ 由经验确定；对于管内湍流，广泛接受的值是 $n=0.14$。\n\n这种形式在物理上是一致的。对于加热情况，$T_w  T_b \\implies \\mu_b  \\mu_w$，因此因子 $(\\mu_b/\\mu_w)^{0.14}$ 大于 1，正确地预测了传热的增强。对于冷却情况，$T_w  T_b \\implies \\mu_b  \\mu_w$，因此该因子小于 1，正确地预测了由于靠近冷壁面的流体层粘度更大、移动更慢而导致的传热减弱。\n\n**第二部分：计算**\n\n问题要求计算比值 $R$，其定义为：\n$$\nR \\equiv \\frac{\\text{考虑粘度变化修正的Nu}}{\\text{假设在主流条件下粘度恒定的Nu}}\n$$\n根据以上讨论，考虑粘度修正后的努塞尔数由 $\\text{Nu}_{\\text{corr}} = \\text{Nu}_{\\text{bulk}} (\\mu_b / \\mu_w)^n$ 给出，其中 $\\text{Nu}_{\\text{bulk}}$ 是假设物性恒定并在主流温度下计算的努塞尔数。比值 $R$ 的分母就是这个 $\\text{Nu}_{\\text{bulk}}$。\n\n因此，比值 $R$ 简化为修正因子本身：\n$$\nR = \\frac{\\text{Nu}_{\\text{bulk}} \\left(\\frac{\\mu_b}{\\mu_w}\\right)^n}{\\text{Nu}_{\\text{bulk}}} = \\left(\\frac{\\mu_b}{\\mu_w}\\right)^n\n$$\n对于在管内被加热的液体湍流，标准指数为 $n=0.14$。\n主流温度和壁面温度下的粘度使用给定的 Andrade 关系式 $\\mu(T) = A \\exp(B/T)$ 计算。\n\n主流温度 $T_b = 330$ K 下的粘度为：\n$$\n\\mu_b = \\mu(T_b) = A \\exp\\left(\\frac{B}{T_b}\\right)\n$$\n壁面温度 $T_w = 380$ K 下的粘度为：\n$$\n\\mu_w = \\mu(T_w) = A \\exp\\left(\\frac{B}{T_w}\\right)\n$$\n粘度之比为：\n$$\n\\frac{\\mu_b}{\\mu_w} = \\frac{A \\exp\\left(B/T_b\\right)}{A \\exp\\left(B/T_w\\right)} = \\exp\\left(\\frac{B}{T_b} - \\frac{B}{T_w}\\right) = \\exp\\left[B\\left(\\frac{1}{T_b} - \\frac{1}{T_w}\\right)\\right]\n$$\n现在，我们可以写出 $R$ 的表达式：\n$$\nR = \\left[ \\exp\\left[B\\left(\\frac{1}{T_b} - \\frac{1}{T_w}\\right)\\right] \\right]^{n} = \\exp\\left[n \\cdot B \\left(\\frac{1}{T_b} - \\frac{1}{T_w}\\right)\\right]\n$$\n代入给定值 $n=0.14$，$B=2670$ K，$T_b=330$ K 和 $T_w=380$ K：\n$$\nR = \\exp\\left[0.14 \\times 2670 \\left(\\frac{1}{330} - \\frac{1}{380}\\right)\\right]\n$$\n$$\nR = \\exp\\left[373.8 \\left(\\frac{380 - 330}{330 \\times 380}\\right)\\right]\n$$\n$$\nR = \\exp\\left[373.8 \\left(\\frac{50}{125400}\\right)\\right]\n$$\n$$\nR = \\exp\\left[\\frac{18690}{125400}\\right] \\approx \\exp(0.14904306)\n$$\n$$\nR \\approx 1.160713\n$$\n按要求将结果四舍五入到四位有效数字，得到 $R = 1.161$。\n该值大于 1，证实了由于液体被加热而导致的传热增强的预期。",
            "answer": "$$\n\\boxed{1.161}\n$$"
        },
        {
            "introduction": "一个计算模型在经过开发与验证后，必须通过与实验数据的对比来进行确认，以保证其预测的准确性。本练习将介绍一套用于模型确认的规范化统计框架，通过假设检验来量化模型的偏差 (bias) 和精度 (precision)。掌握这一方法对于将计算模型应用于实际工程决策至关重要，是模型开发流程中不可或缺的最后环节。",
            "id": "3960782",
            "problem": "您的任务是通过将计算模型预测的热负荷与受控测试程序的测量结果进行比较，来验证该计算模型。验证必须通过量化模型偏差和精密度，并对模型误差进行有统计学原理支持的假设检验来执行。场景框架如下。\n\n一个单程换热器在多个稳态运行下进行测试。对于每次运行，测得的热负荷（单位：瓦特）通过稳态流动的能量守恒定律获得，即 $Q = \\dot{m} c_p (T_{\\text{out}} - T_{\\text{in}})$，其中 $Q$ 是热负荷（瓦特），$\\dot{m}$ 是质量流量（千克/秒），$c_p$ 是比热容（焦耳/千克·开尔文），$T$ 表示温度（开尔文）。计算模型预测相同运行条件下的热负荷。模型误差按次定义为相对误差 $e_i = \\dfrac{Q_{\\text{pred},i} - Q_{\\text{meas},i}}{Q_{\\text{meas},i}}$，这是一个无量纲的分数。\n\n假设以下在性能验证中经过充分检验的事实和建模假设为标准：\n- 测量过程对于真实物理热负荷是无偏的，只存在可归因于仪器和可重复性的随机噪声，而计算模型会引入额外的系统误差和随机误差。\n- 每次运行的相对误差 $\\{e_i\\}$ 是独立同分布的，具有有限的均值 $\\mu$ 和方差 $\\sigma^2$。\n- 对于中等样本量，当用样本标准差进行标准化时，误差的样本均值近似服从学生t分布；在正态性假设下，经过缩放的样本方差服从卡方分布。\n\n接受度量和假设检验：\n- 偏差度量：样本均值 $\\bar{e} = \\dfrac{1}{n}\\sum_{i=1}^n e_i$。定义一个双单侧检验（TOST）等效带，其边界为 $[-b_{\\max}, +b_{\\max}]$，其中 $b_{\\max} \\gt 0$ 是可接受的最大偏差量级。假设为 $H_0^L: \\mu \\le -b_{\\max}$ 对 $H_A^L: \\mu \\gt -b_{\\max}$，以及 $H_0^U: \\mu \\ge +b_{\\max}$ 对 $H_A^U: \\mu \\lt +b_{\\max}$。单侧 $t$ 统计量为 $t_L = \\dfrac{\\bar{e} - (-b_{\\max})}{s/\\sqrt{n}}$ 和 $t_U = \\dfrac{\\bar{e} - (+b_{\\max})}{s/\\sqrt{n}}$，其中 $s = \\sqrt{\\dfrac{1}{n-1}\\sum_{i=1}^n (e_i - \\bar{e})^2}$ 是样本标准差，$n$ 是运行次数。自由度为 $df = n - 1$，显著性水平为 $\\alpha$，计算 $p_L = 1 - F_t(t_L; df)$ 和 $p_U = F_t(t_U; df)$，其中 $F_t(\\cdot; df)$ 是学生t分布的累积分布函数。如果 $p_L \\lt \\alpha$ 和 $p_U \\lt \\alpha$ 同时成立，则偏差等效性“通过”。为便于报告，定义等效性 $p$ 值为 $p_{\\text{bias}} = \\max(p_L, p_U)$。\n- 精密度度量：样本标准差 $s$。定义一个可接受的最大标准差 $s_{\\max} \\gt 0$。检验 $H_0^\\sigma: \\sigma^2 \\ge s_{\\max}^2$ 对 $H_A^\\sigma: \\sigma^2 \\lt s_{\\max}^2$，使用卡方统计量 $X = \\dfrac{(n-1)s^2}{s_{\\max}^2}$，自由度为 $df = n - 1$。计算 $p_{\\text{prec}} = F_{\\chi^2}(X; df)$，即自由度为 $df$ 的卡方分布的下尾累积分布函数。如果 $p_{\\text{prec}} \\lt \\alpha$，则精密度“通过”。\n\n模型接受准则：当且仅当偏差等效性检验和精密度检验都通过时，模型在该测试程序下被接受。\n\n实现一个程序，为每个测试案例计算：\n- 所有运行的相对误差 $e_i$（无量纲分数）。\n- 样本均值 $\\bar{e}$（无量纲分数）。\n- 样本标准差 $s$（无量纲分数）。\n- TOST $p$ 值 $p_{\\text{bias}} = \\max(p_L, p_U)$（无量纲分数）。\n- 精密度 $p$ 值 $p_{\\text{prec}}$（无量纲分数）。\n- 一个表示偏差等效性是否通过的布尔值。\n- 一个表示精密度是否通过的布尔值。\n- 一个表示模型总体是否被接受的布尔值。\n\n所有浮点数输出必须四舍五入到六位小数。相对误差、均值、标准差和 $p$ 值应表示为无量纲分数，不带百分号。\n\n测试套件（每个案例提供测得的热负荷（瓦特）和模型的乘性误差因子；每次运行的预测热负荷为 $Q_{\\text{pred},i} = Q_{\\text{meas},i}(1+f_i)$）：\n\n- 案例1（理想情况，低偏差和高精密度）：\n  - $Q_{\\text{meas}}$（瓦特）：$[9950,10050,9980,10020,10010,10040,10030,9990,10060,10025,10015,10035]$。\n  - 误差乘子 $f_i$（无量纲）：$[0.007,-0.003,0.004,0.006,-0.002,0.005,0.001,-0.004,0.003,0.002,0.0,0.004]$。\n  - $b_{\\max} = 0.02$, $s_{\\max} = 0.03$, $\\alpha = 0.05$。\n\n- 案例2（由于系统性过高预测，未通过偏差等效性检验）：\n  - $Q_{\\text{meas}}$（瓦特）：$[11950,12010,12020,11980,12050,12030,11990,12040,12000,11970]$。\n  - 误差乘子 $f_i$（无量纲）：$[0.043,0.046,0.045,0.047,0.044,0.045,0.046,0.043,0.045,0.047]$。\n  - $b_{\\max} = 0.02$, $s_{\\max} = 0.03$, $\\alpha = 0.05$。\n\n- 案例3（由于高离散度但均值接近零，未通过精密度检验）：\n  - $Q_{\\text{meas}}$（瓦特）：$[8010,7990,8020,7980,8005,7995,8015,8000]$。\n  - 误差乘子 $f_i$（无量纲）：$[-0.03,0.02,-0.05,0.04,-0.02,0.03,-0.04,0.05]$。\n  - $b_{\\max} = 0.02$, $s_{\\max} = 0.03$, $\\alpha = 0.05$。\n\n最终输出格式：\n您的程序应生成一行输出，包含一个方括号括起来的逗号分隔列表，其中每个元素对应一个测试案例，并且本身是按以下顺序排列的列表：\n$[\\bar{e}, s, p_{\\text{bias}}, p_{\\text{prec}}, \\text{bias\\_pass}, \\text{precision\\_pass}, \\text{accept}]$。\n所有浮点值必须四舍五入到六位小数。顶层输出不得包含空格。例如，结构应类似于 $[[\\dots],[\\dots],[\\dots]]$，并作为单行精确打印。单位：$\\bar{e}$ 和 $s$ 是无量纲分数；$Q_{\\text{meas}}$ 和 $Q_{\\text{pred}}$ 的单位是瓦特；$p_{\\text{bias}}$ 和 $p_{\\text{prec}}$ 是无量纲分数。",
            "solution": "问题陈述已经过评估，被确定为**有效**。它在科学上基于工程模型验证的标准统计程序，问题陈述清晰，提供了所有必要信息和明确无歧义的定义，并且没有矛盾或事实错误。任务是实现一个指定的统计验证协议，这是计算工程中一个合理且可形式化的问题。\n\n解决方案通过实现所定义的统计检验来推进。对于每个测试案例，分析包括以下步骤。\n\n首先，计算每次运行的相对误差 $\\{e_i\\}$。问题将第 $i$ 次运行的相对误差定义为 $e_i = \\dfrac{Q_{\\text{pred},i} - Q_{\\text{meas},i}}{Q_{\\text{meas},i}}$。问题还规定，预测的热负荷 $Q_{\\text{pred},i}$ 通过乘性误差因子 $f_i$ 与测得的热负荷 $Q_{\\text{meas},i}$ 相关，即 $Q_{\\text{pred},i} = Q_{\\text{meas},i}(1+f_i)$。将此定义代入误差公式可得：\n$$\ne_i = \\frac{Q_{\\text{meas},i}(1+f_i) - Q_{\\text{meas},i}}{Q_{\\text{meas},i}} = \\frac{Q_{\\text{meas},i} + Q_{\\text{meas},i}f_i - Q_{\\text{meas},i}}{Q_{\\text{meas},i}} = \\frac{Q_{\\text{meas},i}f_i}{Q_{\\text{meas},i}} = f_i\n$$\n因此，每个测试案例的相对误差集 $\\{e_i\\}$ 与所提供的误差乘子集 $\\{f_i\\}$ 相同。$Q_{\\text{meas}}$ 的值是上下文信息，在误差计算本身中并不直接需要。\n\n接下来，对于 $n$ 个相对误差的集合 $\\{e_i\\}_{i=1}^n$，我们计算两个关键的样本统计量：样本均值 $\\bar{e}$ 和样本标准差 $s$。它们的定义如下：\n$$\n\\bar{e} = \\frac{1}{n}\\sum_{i=1}^n e_i\n$$\n$$\ns = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^n (e_i - \\bar{e})^2}\n$$\n数量 $n-1$ 代表偏差和精密度检验的自由度 $df$。\n\n然后，通过两个独立的假设检验，在给定的显著性水平 $\\alpha$ 下进行模型验证。\n\n第一个检验处理由样本均值 $\\bar{e}$ 度量的模型偏差。我们执行双单侧检验（TOST）程序，以确定真实平均误差 $\\mu$ 是否在统计上等效于零，即它是否位于预定义的等效带 $[-b_{\\max}, +b_{\\max}]$ 内。这需要检验两个原假设：$H_0^L: \\mu \\le -b_{\\max}$ 和 $H_0^U: \\mu \\ge +b_{\\max}$。只有当两个原假设都被拒绝时，模型偏差才被认为是可接受的。相应的单侧 $t$ 统计量计算如下：\n$$\nt_L = \\frac{\\bar{e} - (-b_{\\max})}{s/\\sqrt{n}} = \\frac{\\bar{e} + b_{\\max}}{s/\\sqrt{n}}\n$$\n$$\nt_U = \\frac{\\bar{e} - (+b_{\\max})}{s/\\sqrt{n}}\n$$\n这些检验的 $p$ 值是使用自由度为 $df = n - 1$ 的学生t分布的累积分布函数（CDF）$F_t(\\cdot; df)$ 计算的。对于针对 $H_0^L$ 的上尾检验， $p$ 值为 $p_L = 1 - F_t(t_L; df)$。对于针对 $H_0^U$ 的下尾检验， $p$ 值为 $p_U = F_t(t_U; df)$。偏差等效性检验的总 $p$ 值是这两者中的最大值：$p_{\\text{bias}} = \\max(p_L, p_U)$。如果 $p_{\\text{bias}} \\lt \\alpha$，则偏差等效性检验“通过”。\n\n第二个检验处理由样本标准差 $s$ 度量的模型精密度。我们检验原假设，即误差的真实方差 $\\sigma^2$ 大于或等于最大可接受标准差的平方 $s_{\\max}^2$。假设为 $H_0^\\sigma: \\sigma^2 \\ge s_{\\max}^2$ 对备择假设 $H_A^\\sigma: \\sigma^2 \\lt s_{\\max}^2$。这是一个单侧下尾检验。检验统计量 $X$ 计算如下：\n$$\nX = \\frac{(n-1)s^2}{s_{\\max}^2}\n$$\n该统计量服从自由度为 $df = n - 1$ 的卡方分布。$p$ 值 $p_{\\text{prec}}$ 是观测到小于或等于计算出的 $X$ 的检验统计量的概率，这对应于卡方分布的下尾累积分布函数 $F_{\\chi^2}(\\cdot; df)$：\n$$\np_{\\text{prec}} = F_{\\chi^2}(X; df)\n$$\n如果 $p_{\\text{prec}} \\lt \\alpha$，则精密度检验“通过”，表明有足够证据证明模型的随机误差小于指定的最大值。\n\n最后，确定模型的总体接受情况。当且仅当偏差等效性检验和精密度检验都通过时，模型才被视为可接受。\n\n实现将为所提供的三个测试案例计算这些值。在中间计算过程中将保持完全精度，最终的浮点结果（$\\bar{e}$, $s$, $p_{\\text{bias}}$, $p_{\\text{prec}}$）将按要求四舍五入到六位小数进行输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import t, chi2\n\ndef solve():\n    \"\"\"\n    Main function to run the validation analysis for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"f_i\": [0.007, -0.003, 0.004, 0.006, -0.002, 0.005, 0.001, -0.004, 0.003, 0.002, 0.0, 0.004],\n            \"b_max\": 0.02,\n            \"s_max\": 0.03,\n            \"alpha\": 0.05\n        },\n        {\n            \"f_i\": [0.043, 0.046, 0.045, 0.047, 0.044, 0.045, 0.046, 0.043, 0.045, 0.047],\n            \"b_max\": 0.02,\n            \"s_max\": 0.03,\n            \"alpha\": 0.05\n        },\n        {\n            \"f_i\": [-0.03, 0.02, -0.05, 0.04, -0.02, 0.03, -0.04, 0.05],\n            \"b_max\": 0.02,\n            \"s_max\": 0.03,\n            \"alpha\": 0.05\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        f_i = case[\"f_i\"]\n        b_max = case[\"b_max\"]\n        s_max = case[\"s_max\"]\n        alpha = case[\"alpha\"]\n\n        # As derived, the relative errors e_i are the same as the error multipliers f_i.\n        errors = np.array(f_i)\n        \n        # Calculate sample statistics\n        n = len(errors)\n        df = n - 1\n        e_bar = np.mean(errors)\n        s = np.std(errors, ddof=1) # Sample standard deviation\n        \n        # -- Bias Equivalence Test (TOST) --\n        # Standard error of the mean\n        se = s / np.sqrt(n)\n        \n        # t-statistics for the two one-sided tests\n        t_L = (e_bar - (-b_max)) / se\n        t_U = (e_bar - b_max) / se\n        \n        # p-values for the two one-sided tests\n        p_L = t.sf(t_L, df)  # Survival function (1 - cdf) for H_A: mu  -b_max\n        p_U = t.cdf(t_U, df)  # CDF for H_A: mu  b_max\n        \n        # Equivalence p-value\n        p_bias = max(p_L, p_U)\n        \n        # Bias equivalence pass/fail\n        bias_pass = p_bias  alpha\n        \n        # -- Precision Test (Chi-Square) --\n        # Test statistic\n        chi_sq_stat = (df * s**2) / (s_max**2)\n        \n        # p-value for the precision test (lower-tail test)\n        p_prec = chi2.cdf(chi_sq_stat, df)\n        \n        # Precision pass/fail\n        precision_pass = p_prec  alpha\n        \n        # -- Overall Model Acceptance --\n        accept = bias_pass and precision_pass\n        \n        # Format results for output with rounding\n        case_results = [\n            round(e_bar, 6),\n            round(s, 6),\n            round(p_bias, 6),\n            round(p_prec, 6),\n            bias_pass,\n            precision_pass,\n            accept\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as required\n    inner_strings = []\n    for res in all_results:\n        # Convert all items in the list to string and join with a comma\n        res_str = [f\"{v:.6f}\" if isinstance(v, float) else str(v).lower() for v in res]\n        inner_str = f\"[{','.join(res_str)}]\"\n        inner_strings.append(inner_str)\n    \n    # Join the inner lists with a comma and enclose in brackets\n    # Note: The problem asks to print booleans as True/False, which Python's str() does.\n    # The example output shows lowercase, so we'll enforce that.\n    final_output = f\"[{','.join(inner_strings)}]\"\n    final_output = final_output.replace(\"True\", \"true\").replace(\"False\", \"false\")\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}