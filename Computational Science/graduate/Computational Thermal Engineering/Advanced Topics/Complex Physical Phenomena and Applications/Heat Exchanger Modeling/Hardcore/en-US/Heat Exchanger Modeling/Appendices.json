{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of developing any computational model is verification: ensuring the underlying equations are solved correctly. This first practice focuses on this fundamental step by challenging you to compare a numerical solution against an exact analytical result for a simplified parallel-flow heat exchanger . By implementing a basic numerical scheme and contrasting its output with the well-known Log Mean Temperature Difference (LMTD) solution, you will quantify discretization error and confirm the theoretical order of accuracy, a crucial first skill in computational validation.",
            "id": "3960802",
            "problem": "Consider a steady, one-dimensional, co-current (parallel-flow) double-pipe heat exchanger with constant thermal properties, negligible axial conduction in both fluids and the wall, and uniform overall heat transfer coefficient. The axial coordinate is denoted by $x$, with $x \\in [0,L]$. The hot fluid enters at $x=0$ with temperature $T_{h,\\mathrm{in}}$, and the cold fluid enters at $x=0$ with temperature $T_{c,\\mathrm{in}}$. Let the hot-fluid heat capacity rate be $C_h = \\dot{m}_h c_{p,h}$, and the cold-fluid heat capacity rate be $C_c = \\dot{m}_c c_{p,c}$. The perimeter available for heat transfer is $P$, the exchanger length is $L$, and the overall heat transfer coefficient is $U$. The per-unit-length heat transfer rate is $q'(x) = U P \\left[T_h(x) - T_c(x)\\right]$. The governing energy conservation with Newton’s law of cooling along $x$ leads to a coupled system of ordinary differential equations for $T_h(x)$ and $T_c(x)$ under the stated assumptions.\n\nYour task is to verify a numerical solution against an analytical solution based on the Log Mean Temperature Difference (LMTD) method for this special case with constant properties and no axial conduction. Specifically, you must:\n\n- Starting only from the conservation of energy and Newton’s law of cooling applied to a differential control volume, determine the analytical expressions needed to compute the outlet temperatures $T_{h,\\mathrm{out}}$ and $T_{c,\\mathrm{out}}$, and the total heat transfer rate $Q$, using the Log Mean Temperature Difference (LMTD) specialized to the present co-current configuration and assumptions.\n- Implement a first-order finite-volume (equivalently, explicit Euler in space) discretization of the coupled ordinary differential equations along $x$ to obtain a numerical approximation to $T_h(x)$ and $T_c(x)$ and thus $T_{h,\\mathrm{out}}$, $T_{c,\\mathrm{out}}$, and $Q$.\n- Quantify numerical error by comparing numerical results to analytical ones. Use two uniform grids in $x$ with $N_1$ and $N_2$ segments, compute the relative errors in total heat transfer $Q$ for both grids, and estimate the observed order of accuracy $p$ using the relation $p = \\dfrac{\\ln\\left(E_{N_1}/E_{N_2}\\right)}{\\ln\\left(N_2/N_1\\right)}$, where $E_{N}$ is the relative error in $Q$ using $N$ segments. Also report the relative errors in $T_{h,\\mathrm{out}}$ and $T_{c,\\mathrm{out}}$ using the finer grid $N_2$. Treat all errors as dimensionless fractions (not percentages).\n- Identify and quantify sources of numerical error based on your discretization (e.g., truncation error from the first-order scheme and floating-point round-off), and reflect this quantification through the computed error values and the observed order $p$.\n\nAll quantities are in the International System of Units (SI). The program must compute, for each test case specified below, a list of five floats in the order\n$[E_Q(N_1), E_Q(N_2), p, E_{T_{h,\\mathrm{out}}}(N_2), E_{T_{c,\\mathrm{out}}}(N_2)]$,\nwhere $E_Q(N)$ is the relative error in $Q$ using $N$ segments, and $E_{T_{h,\\mathrm{out}}}(N_2)$ and $E_{T_{c,\\mathrm{out}}}(N_2)$ are the relative errors in the outlet temperatures using the finer grid $N_2$. Aggregate the lists for all test cases into a single line of output containing a comma-separated list enclosed in square brackets, where each element is the per-test-case list described above.\n\nUse the following test suite of parameter values to exercise different regimes:\n\n- Test case $1$ (moderate transfer, water-to-water):\n  - $U = 600\\,\\mathrm{W\\,m^{-2}\\,K^{-1}}$, $P = 2.5\\,\\mathrm{m}$, $L = 12\\,\\mathrm{m}$,\n  - $\\dot{m}_h = 1.2\\,\\mathrm{kg\\,s^{-1}}$, $c_{p,h} = 4181\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$,\n  - $\\dot{m}_c = 1.8\\,\\mathrm{kg\\,s^{-1}}$, $c_{p,c} = 4181\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$,\n  - $T_{h,\\mathrm{in}} = 350\\,\\mathrm{K}$, $T_{c,\\mathrm{in}} = 300\\,\\mathrm{K}$.\n- Test case $2$ (weak transfer, small temperature driving force):\n  - $U = 100\\,\\mathrm{W\\,m^{-2}\\,K^{-1}}$, $P = 1.5\\,\\mathrm{m}$, $L = 5\\,\\mathrm{m}$,\n  - $\\dot{m}_h = 1.0\\,\\mathrm{kg\\,s^{-1}}$, $c_{p,h} = 4200\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$,\n  - $\\dot{m}_c = 1.0\\,\\mathrm{kg\\,s^{-1}}$, $c_{p,c} = 4180\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$,\n  - $T_{h,\\mathrm{in}} = 330\\,\\mathrm{K}$, $T_{c,\\mathrm{in}} = 325\\,\\mathrm{K}$.\n- Test case $3$ (strong transfer, near-equilibration):\n  - $U = 2000\\,\\mathrm{W\\,m^{-2}\\,K^{-1}}$, $P = 2.0\\,\\mathrm{m}$, $L = 25\\,\\mathrm{m}$,\n  - $\\dot{m}_h = 0.8\\,\\mathrm{kg\\,s^{-1}}$, $c_{p,h} = 4000\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$,\n  - $\\dot{m}_c = 0.8\\,\\mathrm{kg\\,s^{-1}}$, $c_{p,c} = 4000\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$,\n  - $T_{h,\\mathrm{in}} = 360\\,\\mathrm{K}$, $T_{c,\\mathrm{in}} = 300\\,\\mathrm{K}$.\n\nFor all test cases, use $N_1 = 200$ and $N_2 = 800$ segments for the numerical discretization.\n\nYour program should produce a single line of output containing the results for the three test cases as a comma-separated list of the per-test-case lists, enclosed in square brackets, for example,\n$[[a_1,b_1,c_1,d_1,e_1],[a_2,b_2,c_2,d_2,e_2],[a_3,b_3,c_3,d_3,e_3]]$,\nwhere each $a_i$, $b_i$, $c_i$, $d_i$, $e_i$ is a float as defined above.",
            "solution": "The problem statement is a well-posed and scientifically sound exercise in transport phenomena and numerical methods, specifically within the context of thermal engineering. It requests the comparison of an analytical solution with a numerical one for a co-current heat exchanger, and a subsequent error analysis. The problem is valid and a solution will be provided.\n\nThe analysis proceeds in four stages:\n1.  Derivation of the governing system of ordinary differential equations (ODEs) from first principles.\n2.  Derivation of the analytical solution for outlet temperatures and total heat transfer rate.\n3.  Formulation of the numerical solution scheme based on a first-order finite-volume (or explicit Euler) method.\n4.  Definition of the error metrics and the procedure for evaluating the numerical scheme's accuracy.\n\n**1. Governing Equations**\n\nConsider a differential control volume of length $dx$ along the heat exchanger. The conservation of energy for the hot and cold fluids in this control volume under steady-state conditions yields:\n\nFor the hot fluid, the rate of change of enthalpy is equal to the rate of heat transferred to the cold fluid:\n$$d\\dot{Q} = -\\dot{m}_h c_{p,h} dT_h = -C_h dT_h$$\nAccording to Newton's law of cooling, this heat transfer is also given by:\n$$d\\dot{Q} = U (P dx) [T_h(x) - T_c(x)]$$\nCombining these gives the first governing ODE:\n$$\\frac{dT_h}{dx} = -\\frac{UP}{C_h} [T_h(x) - T_c(x)]$$\n\nFor the cold fluid, the rate of change of enthalpy is equal to the rate of heat received from the hot fluid:\n$$d\\dot{Q} = \\dot{m}_c c_{p,c} dT_c = C_c dT_c$$\nThis yields the second governing ODE:\n$$\\frac{dT_c}{dx} = \\frac{UP}{C_c} [T_h(x) - T_c(x)]$$\n\nThe system is subject to initial conditions at the inlet, $x=0$, for the co-current configuration:\n$$T_h(0) = T_{h,\\mathrm{in}}$$\n$$T_c(0) = T_{c,\\mathrm{in}}$$\n\n**2. Analytical Solution**\n\nTo solve this coupled linear system, we define the temperature difference $\\Delta T(x) = T_h(x) - T_c(x)$. Differentiating $\\Delta T(x)$ with respect to $x$:\n$$\\frac{d(\\Delta T)}{dx} = \\frac{dT_h}{dx} - \\frac{dT_c}{dx} = -\\frac{UP}{C_h} [T_h(x) - T_c(x)] - \\frac{UP}{C_c} [T_h(x) - T_c(x)]$$\n$$\\frac{d(\\Delta T)}{dx} = -UP \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right) \\Delta T(x)$$\nThis is a separable first-order ODE for $\\Delta T(x)$. We can integrate it from the inlet ($x=0$) to the outlet ($x=L$):\n$$\\int_{\\Delta T_1}^{\\Delta T_2} \\frac{d(\\Delta T)}{\\Delta T} = -UP \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right) \\int_0^L dx$$\nwhere $\\Delta T_1 = \\Delta T(0) = T_{h,\\mathrm{in}} - T_{c,\\mathrm{in}}$ and $\\Delta T_2 = \\Delta T(L) = T_{h,\\mathrm{out}} - T_{c,\\mathrm{out}}$.\n\nThe integration yields:\n$$\\ln\\left(\\frac{\\Delta T_2}{\\Delta T_1}\\right) = -UPL \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right)$$\nThe total heat transfer rate, $Q$, can be expressed from an overall energy balance on each fluid stream:\n$$Q = C_h (T_{h,\\mathrm{in}} - T_{h,\\mathrm{out}})$$\n$$Q = C_c (T_{c,\\mathrm{out}} - T_{c,\\mathrm{in}})$$\nFrom these, we can write the outlet temperatures in terms of $Q$:\n$$T_{h,\\mathrm{out}} = T_{h,\\mathrm{in}} - \\frac{Q}{C_h}$$\n$$T_{c,\\mathrm{out}} = T_{c,\\mathrm{in}} + \\frac{Q}{C_c}$$\nSubstituting these into the expression for $\\Delta T_2$:\n$$\\Delta T_2 = \\left(T_{h,\\mathrm{in}} - \\frac{Q}{C_h}\\right) - \\left(T_{c,\\mathrm{in}} + \\frac{Q}{C_c}\\right) = (T_{h,\\mathrm{in}} - T_{c,\\mathrm{in}}) - Q \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right) = \\Delta T_1 - Q \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right)$$\nNow substitute this expression for $\\Delta T_2$ back into the logarithm:\n$$\\ln\\left(\\frac{\\Delta T_1 - Q \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right)}{\\Delta T_1}\\right) = -UPL \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right)$$\nSolving for $Q$ gives the analytical expression for the total heat transfer rate:\n$$1 - \\frac{Q}{\\Delta T_1} \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right) = \\exp\\left[-UPL \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right)\\right]$$\n$$Q_{\\mathrm{an}} = \\frac{T_{h,\\mathrm{in}} - T_{c,\\mathrm{in}}}{\\frac{1}{C_h} + \\frac{1}{C_c}} \\left(1 - \\exp\\left[-UPL \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right)\\right]\\right)$$\nWith $Q_{\\mathrm{an}}$ computed, the analytical outlet temperatures are found directly:\n$$T_{h,\\mathrm{out,an}} = T_{h,\\mathrm{in}} - \\frac{Q_{\\mathrm{an}}}{C_h}$$\n$$T_{c,\\mathrm{out,an}} = T_{c,\\mathrm{in}} + \\frac{Q_{\\mathrm{an}}}{C_c}$$\nThese are the exact analytical reference values for the given model.\n\n**3. Numerical Solution**\n\nThe domain $[0,L]$ is discretized into $N$ uniform segments of length $\\Delta x = L/N$. The temperature at discrete points $x_i = i \\Delta x$ for $i=0, 1, \\dots, N$ is denoted as $T_i$.\nApplying the first-order explicit Euler method to the governing ODEs:\n$$y_{i+1} = y_i + f(y_i) \\Delta x$$\nFor our system, this becomes:\n$$T_{h,i+1} = T_{h,i} - \\frac{UP}{C_h} (T_{h,i} - T_{c,i}) \\Delta x$$\n$$T_{c,i+1} = T_{c,i} + \\frac{UP}{C_c} (T_{h,i} - T_{c,i}) \\Delta x$$\nStarting with the initial conditions $T_{h,0} = T_{h,\\mathrm{in}}$ and $T_{c,0} = T_{c,\\mathrm{in}}$, we march along the exchanger from $i=0$ to $i=N-1$, calculating the temperatures at each node. The numerical outlet temperatures are the values at the final node, $i=N$:\n$$T_{h,\\mathrm{out,num}} = T_{h,N}$$\n$$T_{c,\\mathrm{out,num}} = T_{c,N}$$\nThe numerical total heat transfer rate, $Q_{\\mathrm{num}}$, is determined by the overall energy balance using the computed outlet temperature:\n$$Q_{\\mathrm{num}} = C_h (T_{h,\\mathrm{in}} - T_{h,\\mathrm{out,num}})$$\nThis method is equivalent to a first-order finite-volume scheme on a vertex-centered grid where fluxes are evaluated using upwind values (which are simply the cell-center values in this one-way advective system).\n\n**4. Error Analysis**\n\nTo quantify the accuracy of the numerical scheme, we compute the relative error for a quantity $X$ as:\n$$E_X = \\frac{|X_{\\mathrm{num}} - X_{\\mathrm{an}}|}{|X_{\\mathrm{an}}|}$$\nThe problem requires the calculation of the relative errors in the total heat transfer rate, $E_Q(N)$, for two grid resolutions, $N_1$ and $N_2$, as well as the relative errors in outlet temperatures, $E_{T_{h,\\mathrm{out}}}(N_2)$ and $E_{T_{c,\\mathrm{out}}}(N_2)$, for the finer grid.\n\nThe primary source of numerical error in this case is the truncation error inherent in the Euler method. Explicit Euler is a first-order method, meaning its local truncation error is of order $\\Delta x^2$, leading to a global error of order $\\Delta x$. Therefore, the error $E$ is expected to be proportional to $\\Delta x$, or inversely proportional to $N$:\n$$E \\approx C \\Delta x = C \\frac{L}{N}$$\nwhere $C$ is a constant. The observed order of accuracy, $p$, can be estimated from the errors computed on two different grids, $N_1$ and $N_2$:\n$$E_{N_1} \\approx C/N_1$$\n$$E_{N_2} \\approx C/N_2$$\nDividing these expressions gives $E_{N_1}/E_{N_2} \\approx N_2/N_1$. Taking the natural logarithm and rearranging yields the formula for $p$:\n$$p = \\frac{\\ln(E_{N_1}/E_{N_2})}{\\ln(N_2/N_1)}$$\nFor a first-order scheme, we expect $p \\approx 1$. Any significant deviation would suggest that either the asymptotic error regime has not been reached or other error sources, such as floating-point round-off, are becoming dominant (which is unlikely for the specified $N_1$, $N_2$ and standard double-precision arithmetic). The computation of $p$ thus serves to numerically verify the theoretical order of accuracy of the implemented scheme.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the heat exchanger problem for three test cases, comparing\n    analytical and numerical solutions and performing an error analysis.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (moderate transfer, water-to-water)\n        {\n            \"U\": 600.0, \"P\": 2.5, \"L\": 12.0,\n            \"mdot_h\": 1.2, \"cp_h\": 4181.0,\n            \"mdot_c\": 1.8, \"cp_c\": 4181.0,\n            \"Th_in\": 350.0, \"Tc_in\": 300.0\n        },\n        # Test case 2 (weak transfer, small temperature driving force)\n        {\n            \"U\": 100.0, \"P\": 1.5, \"L\": 5.0,\n            \"mdot_h\": 1.0, \"cp_h\": 4200.0,\n            \"mdot_c\": 1.0, \"cp_c\": 4180.0,\n            \"Th_in\": 330.0, \"Tc_in\": 325.0\n        },\n        # Test case 3 (strong transfer, near-equilibration)\n        {\n            \"U\": 2000.0, \"P\": 2.0, \"L\": 25.0,\n            \"mdot_h\": 0.8, \"cp_h\": 4000.0,\n            \"mdot_c\": 0.8, \"cp_c\": 4000.0,\n            \"Th_in\": 360.0, \"Tc_in\": 300.0\n        }\n    ]\n    \n    N1 = 200\n    N2 = 800\n\n    def solve_analytical(params):\n        \"\"\"Calculates the analytical solution.\"\"\"\n        C_h = params[\"mdot_h\"] * params[\"cp_h\"]\n        C_c = params[\"mdot_c\"] * params[\"cp_c\"]\n        Th_in = params[\"Th_in\"]\n        Tc_in = params[\"Tc_in\"]\n        U, P, L = params[\"U\"], params[\"P\"], params[\"L\"]\n\n        inv_Ch_plus_inv_Cc = (1.0 / C_h) + (1.0 / C_c)\n        exponent_term = -U * P * L * inv_Ch_plus_inv_Cc\n        \n        Q_an = (Th_in - Tc_in) / inv_Ch_plus_inv_Cc * (1.0 - np.exp(exponent_term))\n        \n        Th_out_an = Th_in - Q_an / C_h\n        Tc_out_an = Tc_in + Q_an / C_c\n        \n        return Q_an, Th_out_an, Tc_out_an\n\n    def solve_numerical(params, N):\n        \"\"\"Calculates the numerical solution using explicit Euler.\"\"\"\n        C_h = params[\"mdot_h\"] * params[\"cp_h\"]\n        C_c = params[\"mdot_c\"] * params[\"cp_c\"]\n        Th_in = params[\"Th_in\"]\n        Tc_in = params[\"Tc_in\"]\n        U, P, L = params[\"U\"], params[\"P\"], params[\"L\"]\n        \n        dx = L / N\n        \n        Th = Th_in\n        Tc = Tc_in\n        \n        # Coefficients for Euler update\n        K_h = U * P / C_h * dx\n        K_c = U * P / C_c * dx\n\n        for _ in range(N):\n            T_diff = Th - Tc\n            Th_new = Th - K_h * T_diff\n            Tc_new = Tc + K_c * T_diff\n            Th, Tc = Th_new, Tc_new\n            \n        Th_out_num = Th\n        Tc_out_num = Tc\n\n        # Calculate Q from the hot fluid energy balance\n        Q_num = C_h * (Th_in - Th_out_num)\n\n        return Q_num, Th_out_num, Tc_out_num\n\n    all_results = []\n    \n    for case in test_cases:\n        # Analytical solution\n        Q_an, Th_out_an, Tc_out_an = solve_analytical(case)\n\n        # Numerical solution for N1\n        Q_num_N1, _, _ = solve_numerical(case, N1)\n        \n        # Numerical solution for N2\n        Q_num_N2, Th_out_num_N2, Tc_out_num_N2 = solve_numerical(case, N2)\n\n        # Calculate relative errors\n        E_Q_N1 = np.abs(Q_num_N1 - Q_an) / np.abs(Q_an)\n        E_Q_N2 = np.abs(Q_num_N2 - Q_an) / np.abs(Q_an)\n        \n        # Handle cases where outlet temperatures might be exactly zero or analytical value is zero\n        # (unlikely here, but good practice)\n        E_Th_out_N2 = np.abs(Th_out_num_N2 - Th_out_an) / np.abs(Th_out_an) if Th_out_an != 0 else 0.0\n        E_Tc_out_N2 = np.abs(Tc_out_num_N2 - Tc_out_an) / np.abs(Tc_out_an) if Tc_out_an != 0 else 0.0\n\n        # Calculate observed order of accuracy p\n        # Check for non-positive errors before taking log\n        if E_Q_N1 <= 0 or E_Q_N2 <= 0:\n            p = np.nan # Not meaningful if errors are zero or negative\n        else:\n            p = np.log(E_Q_N1 / E_Q_N2) / np.log(N2 / N1)\n\n        result_list = [E_Q_N1, E_Q_N2, p, E_Th_out_N2, E_Tc_out_N2]\n        all_results.append(result_list)\n        \n    # Format the output string as a list of lists without spaces.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "While verification against analytical solutions is ideal, most practical engineering models are too complex for such benchmarks to exist. This exercise introduces the indispensable technique of a grid convergence study, using Richardson extrapolation to estimate the grid-independent solution and verify the numerical scheme's order of accuracy . This practice moves beyond simple verification to assess the quantitative reliability of a simulation, ensuring results are not an artifact of the chosen mesh resolution.",
            "id": "3960797",
            "problem": "A one-dimensional co-current double-pipe heat exchanger of length $L$ and wetted perimeter $P$ operates at steady state with negligible axial conduction in both fluids and the wall. Each stream is well-mixed across the cross section, properties are constant, and the overall heat transfer coefficient (OHTC) $U$ is uniform along the length. The hot and cold streams have mass flow rates $m_h$ and $m_c$ and constant specific heats $c_{p,h}$ and $c_{p,c}$. The inlet temperatures are $T_{h,\\text{in}}$ and $T_{c,\\text{in}}$. The energy balance for a differential control volume of length $dx$ along the exchanger, using the First Law of Thermodynamics and Newton’s law of cooling, provides the governing one-dimensional coupled ordinary differential equations for the hot and cold fluid temperatures $T_h(x)$ and $T_c(x)$, where $x \\in [0,L]$. The problem is to approximate these field variables numerically by a conservative finite-volume discretization over a uniform mesh of $N$ control volumes, compute the outlet temperatures $T_{h,\\text{out}} = T_h(L)$ and $T_{c,\\text{out}} = T_c(L)$ for successively refined meshes, and perform a grid convergence study to estimate the observed order of accuracy through Richardson extrapolation.\n\nStarting from fundamental laws and core definitions, derive a consistent first-order accurate implicit marching scheme in the axial coordinate $x$ for the uniform grid size $h = L/N$. Implement the scheme in a program that:\n- marches from $x=0$ to $x=L$ using the inlet temperatures as boundary values,\n- computes the outlet temperatures for three successively refined meshes with refinement ratio $r = 2$,\n- applies Richardson extrapolation to estimate the observed order of accuracy for each outlet temperature.\n\nYou must use the following test suite of parameter values (each test case uses three meshes with $N_1$, $N_2$, $N_3$ such that $N_2 = 2 N_1$ and $N_3 = 2 N_2$):\n\n- Test case A (balanced capacity rates, moderate transfer): $L=5$ m, $P=1$ m, $U=400$ W/m$^2$K, $m_h=1.5$ kg/s, $c_{p,h}=4180$ J/kgK, $m_c=1.5$ kg/s, $c_{p,c}=4180$ J/kgK, $T_{h,\\text{in}}=360$ K, $T_{c,\\text{in}}=300$ K, $(N_1,N_2,N_3)=(50,100,200)$.\n- Test case B (imbalanced capacity rates): $L=5$ m, $P=1$ m, $U=300$ W/m$^2$K, $m_h=3.0$ kg/s, $c_{p,h}=4180$ J/kgK, $m_c=1.0$ kg/s, $c_{p,c}=4180$ J/kgK, $T_{h,\\text{in}}=370$ K, $T_{c,\\text{in}}=295$ K, $(N_1,N_2,N_3)=(50,100,200)$.\n- Test case C (longer exchanger, weak transfer): $L=10$ m, $P=1$ m, $U=80$ W/m$^2$K, $m_h=2.0$ kg/s, $c_{p,h}=4180$ J/kgK, $m_c=2.5$ kg/s, $c_{p,c}=4180$ J/kgK, $T_{h,\\text{in}}=350$ K, $T_{c,\\text{in}}=310$ K, $(N_1,N_2,N_3)=(50,100,200)$.\n- Test case D (short exchanger, strong transfer): $L=2$ m, $P=0.8$ m, $U=1200$ W/m$^2$K, $m_h=0.8$ kg/s, $c_{p,h}=4180$ J/kgK, $m_c=0.8$ kg/s, $c_{p,c}=4180$ J/kgK, $T_{h,\\text{in}}=330$ K, $T_{c,\\text{in}}=290$ K, $(N_1,N_2,N_3)=(50,100,200)$.\n\nFor each test case, compute the outlet temperatures for $N_1$, $N_2$, and $N_3$ and then estimate the observed order of accuracy $p_h$ for the hot outlet temperature and $p_c$ for the cold outlet temperature using Richardson extrapolation. Additionally, compute the Richardson-extrapolated outlet temperatures $T_{h,\\infty}$ and $T_{c,\\infty}$ (in Kelvin) based on the two finest meshes and the estimated order. If the Richardson estimation is not in the asymptotic regime (for example, if the successive differences change sign or vanish), return a non-number for the order and extrapolated temperature in that component.\n\nOutput and unit requirements:\n- Temperatures must be computed internally and, when reported, expressed in Kelvin.\n- The observed orders $p_h$ and $p_c$ are dimensionless.\n- Round each observed order to $5$ decimal places and each extrapolated outlet temperature to $3$ decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, with one list per test case in the order A, B, C, D. Each inner list must be of the form $[p_h, p_c, T_{h,\\infty}, T_{c,\\infty}]$. For example, $[[p_h^{(A)},p_c^{(A)},T_{h,\\infty}^{(A)},T_{c,\\infty}^{(A)}],[p_h^{(B)},p_c^{(B)},T_{h,\\infty}^{(B)},T_{c,\\infty}^{(B)}],\\dots]$.\n\nThe program must be complete and runnable and must not require any user input.",
            "solution": "The problem requires the derivation and implementation of a first-order accurate implicit finite-volume scheme to model a one-dimensional co-current double-pipe heat exchanger. The implementation will be used to compute outlet temperatures for several test cases on successively refined meshes, followed by a grid convergence study using Richardson extrapolation to estimate the order of accuracy and the extrapolated, grid-independent outlet temperatures.\n\n### Step 1: Governing Equations\nThe physical system is a co-current heat exchanger operating at steady state. We apply the First Law of Thermodynamics (energy conservation) to a differential control volume of length $dx$ along the exchanger axis, from location $x$ to $x+dx$.\n\nThe heat transfer rate, $\\delta\\dot{Q}$, between the two fluids across the differential area $dA = P dx$ is given by Newton's law of cooling:\n$$ \\delta\\dot{Q} = U (T_h(x) - T_c(x)) P dx $$\nwhere $U$ is the overall heat transfer coefficient, $P$ is the wetted perimeter, and $T_h(x)$ and $T_c(x)$ are the local temperatures of the hot and cold fluids, respectively.\n\nFor the hot fluid, the change in enthalpy rate must balance the heat transferred out of the fluid:\n$$ \\dot{m}_h c_{p,h} T_h(x) - \\dot{m}_h c_{p,h} T_h(x+dx) = \\delta\\dot{Q} $$\n$$ -\\dot{m}_h c_{p,h} (T_h(x+dx) - T_h(x)) = U P (T_h(x) - T_c(x)) dx $$\nDefining the heat capacity rate of the hot fluid as $C_h = \\dot{m}_h c_{p,h}$ and taking the limit $dx \\to 0$, we get the first governing ordinary differential equation (ODE):\n$$ \\frac{dT_h}{dx} = -\\frac{UP}{C_h} (T_h - T_c) $$\n\nFor the cold fluid, the change in enthalpy rate must balance the heat transferred into the fluid:\n$$ \\dot{m}_c c_{p,c} T_c(x+dx) - \\dot{m}_c c_{p,c} T_c(x) = \\delta\\dot{Q} $$\nDefining the heat capacity rate of the cold fluid as $C_c = \\dot{m}_c c_{p,c}$ and taking the limit $dx \\to 0$, we obtain the second governing ODE:\n$$ \\frac{dT_c}{dx} = \\frac{UP}{C_c} (T_h - T_c) $$\n\nThe problem is an initial value problem in space, with the boundary conditions given at the inlet, $x=0$:\n$$ T_h(0) = T_{h,\\text{in}} \\quad \\text{and} \\quad T_c(0) = T_{c,\\text{in}} $$\n\n### Step 2: Finite-Volume Discretization and Implicit Scheme\nWe discretize the domain of length $L$ into $N$ uniform control volumes (CVs), each of length $h = L/N$. The nodes are located at positions $x_i = i \\cdot h$ for $i = 0, 1, \\dots, N$. The $i$-th CV spans from $x_i$ to $x_{i+1}$. We integrate the governing ODEs over this CV.\n\nFor the hot fluid:\n$$ \\int_{x_i}^{x_{i+1}} \\frac{dT_h}{dx} dx = \\int_{x_i}^{x_{i+1}} -\\frac{UP}{C_h} (T_h(x) - T_c(x)) dx $$\n$$ T_h(x_{i+1}) - T_h(x_i) = -\\frac{UP}{C_h} \\int_{x_i}^{x_{i+1}} (T_h(x) - T_c(x)) dx $$\nLet $T_{h,i}$ denote the temperature $T_h(x_i)$. The equation becomes:\n$$ T_{h,i+1} - T_{h,i} = -\\frac{UP}{C_h} \\int_{x_i}^{x_{i+1}} (T_h(x) - T_c(x)) dx $$\n\nSimilarly, for the cold fluid:\n$$ T_{c,i+1} - T_{c,i} = \\frac{UP}{C_c} \\int_{x_i}^{x_{i+1}} (T_h(x) - T_c(x)) dx $$\n\nTo formulate a first-order accurate implicit scheme, we approximate the integral on the right-hand side using the function value at the end of the interval, $x_{i+1}$. This is a backward Euler method.\n$$ \\int_{x_i}^{x_{i+1}} f(x) dx \\approx f(x_{i+1}) \\cdot (x_{i+1} - x_i) = f_{i+1} \\cdot h $$\nApplying this to our integrated equations:\n$$ T_{h,i+1} - T_{h,i} = -\\frac{UP h}{C_h} (T_{h,i+1} - T_{c,i+1}) $$\n$$ T_{c,i+1} - T_{c,i} = \\frac{UP h}{C_c} (T_{h,i+1} - T_{c,i+1}) $$\n\nThese are two coupled linear algebraic equations for the unknown temperatures at node $i+1$, $T_{h,i+1}$ and $T_{c,i+1}$, in terms of the known temperatures at node $i$. Let's define the dimensionless parameters $k_h = \\frac{UP h}{C_h}$ and $k_c = \\frac{UP h}{C_c}$.\n$$ T_{h,i+1} - T_{h,i} = -k_h (T_{h,i+1} - T_{c,i+1}) $$\n$$ T_{c,i+1} - T_{c,i} = k_c (T_{h,i+1} - T_{c,i+1}) $$\nRearranging to group the unknowns on the left-hand side:\n$$ (1+k_h) T_{h,i+1} - k_h T_{c,i+1} = T_{h,i} $$\n$$ -k_c T_{h,i+1} + (1+k_c) T_{c,i+1} = T_{c,i} $$\nThis is a $2 \\times 2$ linear system for each marching step:\n$$ \\begin{pmatrix} 1+k_h & -k_h \\\\ -k_c & 1+k_c \\end{pmatrix} \\begin{pmatrix} T_{h,i+1} \\\\ T_{c,i+1} \\end{pmatrix} = \\begin{pmatrix} T_{h,i} \\\\ T_{c,i} \\end{pmatrix} $$\n\n### Step 3: Derivation of the Marching Scheme\nTo find the update rule, we solve the $2 \\times 2$ system. The determinant of the coefficient matrix is $D = (1+k_h)(1+k_c) - (-k_h)(-k_c) = 1 + k_h + k_c$. The inverse of the matrix is:\n$$ \\frac{1}{1+k_h+k_c} \\begin{pmatrix} 1+k_c & k_h \\\\ k_c & 1+k_h \\end{pmatrix} $$\nThe solution for the temperatures at node $i+1$ is thus:\n$$ \\begin{pmatrix} T_{h,i+1} \\\\ T_{c,i+1} \\end{pmatrix} = \\frac{1}{1+k_h+k_c} \\begin{pmatrix} 1+k_c & k_h \\\\ k_c & 1+k_h \\end{pmatrix} \\begin{pmatrix} T_{h,i} \\\\ T_{c,i} \\end{pmatrix} $$\nThis gives the explicit update formulas for the marching scheme:\n$$ T_{h,i+1} = \\frac{(1+k_c)T_{h,i} + k_h T_{c,i}}{1+k_h+k_c} $$\n$$ T_{c,i+1} = \\frac{k_c T_{h,i} + (1+k_h) T_{c,i}}{1+k_h+k_c} $$\nStarting with the known inlet temperatures $T_{h,0} = T_{h,\\text{in}}$ and $T_{c,0} = T_{c,\\text{in}}$, we apply this scheme $N$ times to march from $x=0$ to $x=L$, obtaining the outlet temperatures $T_{h,N}$ and $T_{c,N}$.\n\n### Step 4: Grid Convergence Analysis via Richardson Extrapolation\nLet $f_h$ be a generic numerical solution for a quantity of interest (e.g., outlet temperature) computed with grid spacing $h$. The error expansion is assumed to be of the form $f_h = f_{exact} + A h^p + \\mathcal{O}(h^q)$ where $p$ is the order of accuracy and $q>p$.\nGiven three solutions $f_1, f_2, f_3$ computed on meshes with step sizes $h_1, h_2=h_1/r, h_3=h_2/r$, where $r=2$ is the refinement ratio, the observed order of accuracy $p$ can be estimated as:\n$$ p = \\frac{\\ln\\left(\\frac{f_2 - f_1}{f_3 - f_2}\\right)}{\\ln(r)} $$\nThis estimation is valid only when the solutions are in the asymptotic convergence regime, where successive differences $(f_2-f_1)$ and $(f_3-f_2)$ have the same sign and are non-zero. If the convergence is not monotonic, we cannot reliably estimate $p$.\n\nOnce $p$ is estimated, a more accurate estimate of the exact solution, $f_{\\infty}$, can be obtained by extrapolating from the two finest-grid solutions ($f_2, f_3$):\n$$ f_{\\infty} = f_3 + \\frac{f_3 - f_2}{r^p - 1} $$\nThis procedure is applied independently to the hot-side outlet temperature ($T_{h,\\text{out}}$) and cold-side outlet temperature ($T_{c,\\text{out}}$) for each test case.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve_heat_exchanger(L, P, U, mh, cph, mc, cpc, Th_in, Tc_in, N):\n    \"\"\"\n    Solves for the outlet temperatures of a co-current heat exchanger\n    using a first-order implicit finite volume method.\n\n    Args:\n        L (float): Length of the exchanger (m).\n        P (float): Wetted perimeter (m).\n        U (float): Overall heat transfer coefficient (W/m^2K).\n        mh (float): Mass flow rate of hot fluid (kg/s).\n        cph (float): Specific heat of hot fluid (J/kgK).\n        mc (float): Mass flow rate of cold fluid (kg/s).\n        cpc (float): Specific heat of cold fluid (J/kgK).\n        Th_in (float): Inlet temperature of hot fluid (K).\n        Tc_in (float): Inlet temperature of cold fluid (K).\n        N (int): Number of control volumes.\n\n    Returns:\n        tuple[float, float]: Outlet temperatures (Th_out, Tc_out) in Kelvin.\n    \"\"\"\n    h = L / N\n    Ch = mh * cph\n    Cc = mc * cpc\n\n    # Handle potential division by zero if C is zero\n    if Ch == 0 or Cc == 0:\n        return (Th_in, Tc_in) if Ch == 0 else (np.nan, np.nan), (Tc_in, Th_in) if Cc == 0 else (np.nan, np.nan)\n\n\n    kh = U * P * h / Ch\n    kc = U * P * h / Cc\n    \n    denominator = 1.0 + kh + kc\n\n    Th_current = Th_in\n    Tc_current = Tc_in\n\n    for _ in range(N):\n        Th_next = ((1.0 + kc) * Th_current + kh * Tc_current) / denominator\n        Tc_next = (kc * Th_current + (1.0 + kh) * Tc_current) / denominator\n        Th_current = Th_next\n        Tc_current = Tc_next\n        \n    return Th_current, Tc_current\n\ndef perform_richardson_extrapolation(f1, f2, f3, r):\n    \"\"\"\n    Performs Richardson extrapolation to find the observed order and extrapolated value.\n\n    Args:\n        f1, f2, f3 (float): Solutions on coarse, medium, and fine grids.\n        r (float): Refinement ratio.\n\n    Returns:\n        tuple[float, float]: Observed order p and extrapolated value f_inf.\n    \"\"\"\n    diff1 = f2 - f1\n    diff2 = f3 - f2\n\n    # Check for asymptotic regime\n    if diff1 * diff2 <= 0:\n        return np.nan, np.nan\n\n    ratio = diff1 / diff2\n    \n    # Another check for validity\n    if ratio <= 0:\n        return np.nan, np.nan\n\n    p = math.log(ratio) / math.log(r)\n    \n    if (r**p - 1.0) == 0:\n        return p, np.nan\n        \n    f_inf = f3 + diff2 / (r**p - 1.0)\n    \n    return p, f_inf\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print final results.\n    \"\"\"\n    test_cases = [\n        # Test case A\n        {'L': 5, 'P': 1, 'U': 400, 'mh': 1.5, 'cph': 4180, 'mc': 1.5, 'cpc': 4180, 'Th_in': 360, 'Tc_in': 300, 'N_tuple': (50, 100, 200)},\n        # Test case B\n        {'L': 5, 'P': 1, 'U': 300, 'mh': 3.0, 'cph': 4180, 'mc': 1.0, 'cpc': 4180, 'Th_in': 370, 'Tc_in': 295, 'N_tuple': (50, 100, 200)},\n        # Test case C\n        {'L': 10, 'P': 1, 'U': 80, 'mh': 2.0, 'cph': 4180, 'mc': 2.5, 'cpc': 4180, 'Th_in': 350, 'Tc_in': 310, 'N_tuple': (50, 100, 200)},\n        # Test case D\n        {'L': 2, 'P': 0.8, 'U': 1200, 'mh': 0.8, 'cph': 4180, 'mc': 0.8, 'cpc': 4180, 'Th_in': 330, 'Tc_in': 290, 'N_tuple': (50, 100, 200)},\n    ]\n    \n    r = 2.0  # Refinement ratio\n    final_results_str_list = []\n\n    for case in test_cases:\n        params = {k: v for k, v in case.items() if k != 'N_tuple'}\n        N1, N2, N3 = case['N_tuple']\n        \n        Th_out1, Tc_out1 = solve_heat_exchanger(**params, N=N1)\n        Th_out2, Tc_out2 = solve_heat_exchanger(**params, N=N2)\n        Th_out3, Tc_out3 = solve_heat_exchanger(**params, N=N3)\n        \n        p_h, Th_inf = perform_richardson_extrapolation(Th_out1, Th_out2, Th_out3, r)\n        p_c, Tc_inf = perform_richardson_extrapolation(Tc_out1, Tc_out2, Tc_out3, r)\n\n        ph_str = f\"{p_h:.5f}\" if not np.isnan(p_h) else \"nan\"\n        pc_str = f\"{p_c:.5f}\" if not np.isnan(p_c) else \"nan\"\n        Th_inf_str = f\"{Th_inf:.3f}\" if not np.isnan(Th_inf) else \"nan\"\n        Tc_inf_str = f\"{Tc_inf:.3f}\" if not np.isnan(Tc_inf) else \"nan\"\n        \n        case_str = f\"[{ph_str},{pc_str},{Th_inf_str},{Tc_inf_str}]\"\n        final_results_str_list.append(case_str)\n\n    print(f\"[{','.join(final_results_str_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A verified model is not necessarily a valid one; the final step is to assess how well the model's predictions match real-world physical behavior. This practice guides you through the formal process of model validation, using statistical methods to compare simulation outputs against experimental measurements . You will learn to apply standard industry tests for bias and precision, enabling you to make a statistically-grounded judgment on whether a computational model is acceptable for its intended purpose.",
            "id": "3960782",
            "problem": "You are tasked with validating a computational model of a heat exchanger by comparing its predicted heat duty against measurements from a controlled test procedure. The validation must be performed by quantifying model bias and precision and conducting statistically principled hypothesis tests on the model error. The scenario is framed as follows.\n\nA single-pass heat exchanger is tested across multiple steady-state runs. For each run, the measured heat duty (in watts) is obtained via the conservation of energy for steady flow, which states that $Q = \\dot{m} c_p (T_{\\text{out}} - T_{\\text{in}})$, where $Q$ is heat duty in watts, $\\dot{m}$ is mass flow rate in kilograms per second, $c_p$ is specific heat capacity in joules per kilogram-kelvin, and $T$ denotes temperature in kelvin. The computational model predicts the heat duty for the same runs. Model error is defined runwise as the relative error $e_i = \\dfrac{Q_{\\text{pred},i} - Q_{\\text{meas},i}}{Q_{\\text{meas},i}}$, which is a dimensionless fraction.\n\nAssume the following well-tested facts and modeling assumptions, standard in performance validation:\n- The measurement process is unbiased for the true physical heat duty, up to random noise attributable to instrumentation and repeatability, and the computational model contributes additional systematic and random error.\n- The runwise relative errors $\\{e_i\\}$ are independent and identically distributed with finite mean $\\mu$ and variance $\\sigma^2$.\n- For moderate sample sizes, the sample mean of errors is approximately Student's $t$-distributed when standardized by the sample standard deviation, and the scaled sample variance is chi-square distributed under the assumption of normality.\n\nAcceptance metrics and hypothesis tests:\n- Bias metric: the sample mean $\\bar{e} = \\dfrac{1}{n}\\sum_{i=1}^n e_i$. Define a two one-sided tests (TOST) equivalence band with bounds $[-b_{\\max}, +b_{\\max}]$, where $b_{\\max} > 0$ is the maximum acceptable magnitude of bias. The hypotheses are $H_0^L: \\mu \\le -b_{\\max}$ versus $H_A^L: \\mu > -b_{\\max}$, and $H_0^U: \\mu \\ge +b_{\\max}$ versus $H_A^U: \\mu < +b_{\\max}$. The one-sided $t$-statistics are $t_L = \\dfrac{\\bar{e} - (-b_{\\max})}{s/\\sqrt{n}}$ and $t_U = \\dfrac{\\bar{e} - (+b_{\\max})}{s/\\sqrt{n}}$, where $s = \\sqrt{\\dfrac{1}{n-1}\\sum_{i=1}^n (e_i - \\bar{e})^2}$ is the sample standard deviation and $n$ is the number of runs. With degrees of freedom $df = n - 1$ and significance level $\\alpha$, compute $p_L = 1 - F_t(t_L; df)$ and $p_U = F_t(t_U; df)$, where $F_t(\\cdot; df)$ is the cumulative distribution function of the Student's $t$ distribution. Bias equivalence “passes” if both $p_L < \\alpha$ and $p_U < \\alpha$. For reporting, define the equivalence $p$-value as $p_{\\text{bias}} = \\max(p_L, p_U)$.\n- Precision metric: the sample standard deviation $s$. Define a maximum acceptable standard deviation $s_{\\max} > 0$. Test $H_0^\\sigma: \\sigma^2 \\ge s_{\\max}^2$ versus $H_A^\\sigma: \\sigma^2 < s_{\\max}^2$ using the chi-square statistic $X = \\dfrac{(n-1)s^2}{s_{\\max}^2}$ with $df = n - 1$. Compute $p_{\\text{prec}} = F_{\\chi^2}(X; df)$, the lower-tail cumulative distribution function of the chi-square distribution with $df$ degrees of freedom. Precision “passes” if $p_{\\text{prec}} < \\alpha$.\n\nModel acceptance criterion: the model is accepted for the test procedure if and only if bias equivalence passes and precision passes.\n\nImplement a program that, for each test case, computes:\n- The relative errors $e_i$ for all runs (dimensionless fraction).\n- The sample mean $\\bar{e}$ (dimensionless fraction).\n- The sample standard deviation $s$ (dimensionless fraction).\n- The TOST $p$-value $p_{\\text{bias}} = \\max(p_L, p_U)$ (dimensionless fraction).\n- The precision $p$-value $p_{\\text{prec}}$ (dimensionless fraction).\n- A boolean for bias equivalence passing.\n- A boolean for precision passing.\n- A boolean for overall model acceptance.\n\nAll floating-point outputs must be rounded to six decimal places. Express relative errors, means, standard deviations, and $p$-values as dimensionless fractions, not with a percentage sign.\n\nTest suite (each case provides measured heat duties in watts and multiplicative error factors for the model; the predicted heat duty for each run is $Q_{\\text{pred},i} = Q_{\\text{meas},i}(1+f_i)$):\n\n- Case $1$ (happy path, low bias and high precision):\n  - $Q_{\\text{meas}}$ in watts: $[9950,10050,9980,10020,10010,10040,10030,9990,10060,10025,10015,10035]$.\n  - Error multipliers $f_i$ (dimensionless): $[0.007,-0.003,0.004,0.006,-0.002,0.005,0.001,-0.004,0.003,0.002,0.0,0.004]$.\n  - $b_{\\max} = 0.02$, $s_{\\max} = 0.03$, $\\alpha = 0.05$.\n\n- Case $2$ (fails bias equivalence due to systematic overprediction):\n  - $Q_{\\text{meas}}$ in watts: $[11950,12010,12020,11980,12050,12030,11990,12040,12000,11970]$.\n  - Error multipliers $f_i$ (dimensionless): $[0.043,0.046,0.045,0.047,0.044,0.045,0.046,0.043,0.045,0.047]$.\n  - $b_{\\max} = 0.02$, $s_{\\max} = 0.03$, $\\alpha = 0.05$.\n\n- Case $3$ (fails precision due to high dispersion with near-zero mean):\n  - $Q_{\\text{meas}}$ in watts: $[8010,7990,8020,7980,8005,7995,8015,8000]$.\n  - Error multipliers $f_i$ (dimensionless): $[-0.03,0.02,-0.05,0.04,-0.02,0.03,-0.04,0.05]$.\n  - $b_{\\max} = 0.02$, $s_{\\max} = 0.03$, $\\alpha = 0.05$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list in the following order:\n$[\\bar{e}, s, p_{\\text{bias}}, p_{\\text{prec}}, \\text{bias\\_pass}, \\text{precision\\_pass}, \\text{accept}]$.\nAll floating-point values must be rounded to six decimal places. The top-level output must contain no spaces. For example, the structure should resemble $[[\\dots],[\\dots],[\\dots]]$ and be printed exactly as a single line. Units: $\\bar{e}$ and $s$ are dimensionless fractions; $Q_{\\text{meas}}$ and $Q_{\\text{pred}}$ are in watts; $p_{\\text{bias}}$ and $p_{\\text{prec}}$ are dimensionless fractions.",
            "solution": "The problem statement has been evaluated and is determined to be **valid**. It is scientifically grounded in standard statistical procedures for engineering model validation, well-posed with all necessary information and clear, unambiguous definitions, and free of contradictions or factual errors. The task is to implement a specified statistical validation protocol, which is a legitimate and formalizable problem in computational engineering.\n\nThe solution proceeds by implementing the statistical tests as defined. For each test case, the analysis consists of the following steps.\n\nFirst, the runwise relative errors, $\\{e_i\\}$, are calculated. The problem defines the relative error for run $i$ as $e_i = \\dfrac{Q_{\\text{pred},i} - Q_{\\text{meas},i}}{Q_{\\text{meas},i}}$. It also provides that the predicted heat duty, $Q_{\\text{pred},i}$, is related to the measured heat duty, $Q_{\\text{meas},i}$, by the multiplicative error factor $f_i$ such that $Q_{\\text{pred},i} = Q_{\\text{meas},i}(1+f_i)$. Substituting this definition into the error formula yields:\n$$\ne_i = \\frac{Q_{\\text{meas},i}(1+f_i) - Q_{\\text{meas},i}}{Q_{\\text{meas},i}} = \\frac{Q_{\\text{meas},i} + Q_{\\text{meas},i}f_i - Q_{\\text{meas},i}}{Q_{\\text{meas},i}} = \\frac{Q_{\\text{meas},i}f_i}{Q_{\\text{meas},i}} = f_i\n$$\nThus, the set of relative errors $\\{e_i\\}$ for each test case is identical to the provided set of error multipliers $\\{f_i\\}$. The values of $Q_{\\text{meas}}$ are contextual and not directly needed for the error calculation itself.\n\nNext, for the set of $n$ relative errors $\\{e_i\\}_{i=1}^n$, we compute the two key sample statistics: the sample mean, $\\bar{e}$, and the sample standard deviation, $s$. These are defined as:\n$$\n\\bar{e} = \\frac{1}{n}\\sum_{i=1}^n e_i\n$$\n$$\ns = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^n (e_i - \\bar{e})^2}\n$$\nThe quantity $n-1$ represents the degrees of freedom, $df$, for both the bias and precision tests.\n\nThe model validation is then conducted via two separate hypothesis tests with a given significance level $\\alpha$.\n\nThe first test addresses the model bias, measured by the sample mean $\\bar{e}$. We perform a Two One-Sided Tests (TOST) procedure to determine if the true mean error, $\\mu$, is statistically equivalent to zero, meaning it lies within a predefined equivalence band $[-b_{\\max}, +b_{\\max}]$. This requires testing two null hypotheses: $H_0^L: \\mu \\le -b_{\\max}$ and $H_0^U: \\mu \\ge +b_{\\max}$. The model bias is considered acceptable only if both null hypotheses are rejected. The corresponding one-sided $t$-statistics are calculated as:\n$$\nt_L = \\frac{\\bar{e} - (-b_{\\max})}{s/\\sqrt{n}} = \\frac{\\bar{e} + b_{\\max}}{s/\\sqrt{n}}\n$$\n$$\nt_U = \\frac{\\bar{e} - (+b_{\\max})}{s/\\sqrt{n}}\n$$\nThe $p$-values for these tests are computed using the cumulative distribution function (CDF) of the Student's $t$-distribution, $F_t(\\cdot; df)$, with $df = n - 1$ degrees of freedom. For the upper-tailed test against $H_0^L$, the $p$-value is $p_L = 1 - F_t(t_L; df)$. For the lower-tailed test against $H_0^U$, the $p$-value is $p_U = F_t(t_U; df)$. The overall $p$-value for the bias equivalence test is the maximum of these two: $p_{\\text{bias}} = \\max(p_L, p_U)$. The bias equivalence test \"passes\" if $p_{\\text{bias}} < \\alpha$.\n\nThe second test addresses the model precision, measured by the sample standard deviation $s$. We test the null hypothesis that the true variance of the error, $\\sigma^2$, is greater than or equal to a maximum acceptable squared standard deviation, $s_{\\max}^2$. The hypotheses are $H_0^\\sigma: \\sigma^2 \\ge s_{\\max}^2$ versus the alternative $H_A^\\sigma: \\sigma^2 < s_{\\max}^2$. This is a one-sided, lower-tailed test. The test statistic, $X$, is calculated as:\n$$\nX = \\frac{(n-1)s^2}{s_{\\max}^2}\n$$\nThis statistic follows a chi-square distribution with $df = n - 1$ degrees of freedom. The $p$-value, $p_{\\text{prec}}$, is the probability of observing a test statistic less than or equal to the calculated $X$, which corresponds to the lower-tail CDF of the chi-square distribution, $F_{\\chi^2}(\\cdot; df)$:\n$$\np_{\\text{prec}} = F_{\\chi^2}(X; df)\n$$\nThe precision test \"passes\" if $p_{\\text{prec}} < \\alpha$, indicating sufficient evidence that the model's random error is smaller than the specified maximum.\n\nFinally, the overall model acceptance is determined. The model is deemed acceptable if and only if both the bias equivalence test and the precision test pass.\n\nThe implementation will compute these values for each of the three test cases provided. Full precision will be maintained during intermediate calculations, and the final floating-point results ($\\bar{e}$, $s$, $p_{\\text{bias}}$, $p_{\\text{prec}}$) will be rounded to six decimal places for output, as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import t, chi2\n\ndef solve():\n    \"\"\"\n    Main function to run the validation analysis for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"f_i\": [0.007, -0.003, 0.004, 0.006, -0.002, 0.005, 0.001, -0.004, 0.003, 0.002, 0.0, 0.004],\n            \"b_max\": 0.02,\n            \"s_max\": 0.03,\n            \"alpha\": 0.05\n        },\n        {\n            \"f_i\": [0.043, 0.046, 0.045, 0.047, 0.044, 0.045, 0.046, 0.043, 0.045, 0.047],\n            \"b_max\": 0.02,\n            \"s_max\": 0.03,\n            \"alpha\": 0.05\n        },\n        {\n            \"f_i\": [-0.03, 0.02, -0.05, 0.04, -0.02, 0.03, -0.04, 0.05],\n            \"b_max\": 0.02,\n            \"s_max\": 0.03,\n            \"alpha\": 0.05\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        f_i = case[\"f_i\"]\n        b_max = case[\"b_max\"]\n        s_max = case[\"s_max\"]\n        alpha = case[\"alpha\"]\n\n        # As derived, the relative errors e_i are the same as the error multipliers f_i.\n        errors = np.array(f_i)\n        \n        # Calculate sample statistics\n        n = len(errors)\n        df = n - 1\n        e_bar = np.mean(errors)\n        s = np.std(errors, ddof=1) # Sample standard deviation\n        \n        # -- Bias Equivalence Test (TOST) --\n        # Standard error of the mean\n        se = s / np.sqrt(n)\n        \n        # t-statistics for the two one-sided tests\n        t_L = (e_bar - (-b_max)) / se\n        t_U = (e_bar - b_max) / se\n        \n        # p-values for the two one-sided tests\n        p_L = t.sf(t_L, df)  # Survival function (1 - cdf) for H_A: mu > -b_max\n        p_U = t.cdf(t_U, df)  # CDF for H_A: mu < b_max\n        \n        # Equivalence p-value\n        p_bias = max(p_L, p_U)\n        \n        # Bias equivalence pass/fail\n        bias_pass = p_bias < alpha\n        \n        # -- Precision Test (Chi-Square) --\n        # Test statistic\n        chi_sq_stat = (df * s**2) / (s_max**2)\n        \n        # p-value for the precision test (lower-tail test)\n        p_prec = chi2.cdf(chi_sq_stat, df)\n        \n        # Precision pass/fail\n        precision_pass = p_prec < alpha\n        \n        # -- Overall Model Acceptance --\n        accept = bias_pass and precision_pass\n        \n        # Format results for output with rounding\n        case_results = [\n            round(e_bar, 6),\n            round(s, 6),\n            round(p_bias, 6),\n            round(p_prec, 6),\n            bias_pass,\n            precision_pass,\n            accept\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as required\n    inner_strings = []\n    for res in all_results:\n        # Convert all items in the list to string and join with a comma\n        inner_str = f\"[{','.join(map(str, res))}]\"\n        inner_strings.append(inner_str)\n    \n    # Join the inner lists with a comma and enclose in brackets\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}