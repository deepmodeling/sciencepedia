{
    "hands_on_practices": [
        {
            "introduction": "在开发任何计算模型时，验证是确保其准确性和可靠性的第一步。最严格的验证形式之一是将数值模拟结果与简化问题的已知解析解进行比较。本练习将指导您完成这一基本过程：您将为一个简单的并流换热器实现一个基础的一阶数值格式，并对照精确的对数平均温差（LMTD）法解析解，来量化其数值误差和精度阶数 。",
            "id": "3960802",
            "problem": "考虑一个稳态、一维、并流（平行流）的双套管换热器，其热物性恒定，两种流体及壁面的轴向导热可忽略不计，且总传热系数均匀。轴向坐标用 $x$ 表示，其中 $x \\in [0,L]$。热流体在 $x=0$ 处以温度 $T_{h,\\mathrm{in}}$ 进入，冷流体也在 $x=0$ 处以温度 $T_{c,\\mathrm{in}}$ 进入。设热流体的热容率为 $C_h = \\dot{m}_h c_{p,h}$，冷流体的热容率为 $C_c = \\dot{m}_c c_{p,c}$。传热周长为 $P$，换热器长度为 $L$，总传热系数为 $U$。单位长度传热速率为 $q'(x) = U P \\left[T_h(x) - T_c(x)\\right]$。在所述假设下，沿 $x$ 方向应用能量守恒和 Newton 冷却定律，可得到关于 $T_h(x)$ 和 $T_c(x)$ 的常微分方程耦合系统。\n\n您的任务是，针对此具有恒定物性且无轴向导热的特殊情况，基于对数平均温差（LMTD）法，将数值解与解析解进行验证对比。具体来说，您必须：\n\n- 仅从应用于微元控制体的能量守恒和 Newton 冷却定律出发，使用专门针对当前并流配置和假设的对数平均温差（LMTD）法，确定计算出口温度 $T_{h,\\mathrm{out}}$ 和 $T_{c,\\mathrm{out}}$ 以及总传热速率 $Q$ 所需的解析表达式。\n- 对沿 $x$ 方向的常微分方程耦合系统实施一阶有限体积（等效于空间上的显式欧拉）离散化，以获得 $T_h(x)$ 和 $T_c(x)$ 的数值近似解，从而得到 $T_{h,\\mathrm{out}}$、$T_{c,\\mathrm{out}}$ 和 $Q$。\n- 通过将数值结果与解析结果进行比较来量化数值误差。使用两个分别包含 $N_1$ 和 $N_2$ 个网格段的均匀网格，计算两种网格下总传热速率 $Q$ 的相对误差，并使用关系式 $p = \\dfrac{\\ln\\left(E_{N_1}/E_{N_2}\\right)}{\\ln\\left(N_2/N_1\\right)}$ 估算观测到的精度阶 $p$，其中 $E_{N}$ 是使用 $N$ 个网格段时 $Q$ 的相对误差。同时，报告使用更精细的网格 $N_2$ 时 $T_{h,\\mathrm{out}}$ 和 $T_{c,\\mathrm{out}}$ 的相对误差。所有误差均以无量纲小数（而非百分比）表示。\n- 根据您的离散化方法，识别并量化数值误差的来源（例如，一阶格式的截断误差和浮点舍入误差），并通过计算出的误差值和观测到的精度阶 $p$ 来反映此量化结果。\n\n所有物理量均采用国际单位制（SI）。程序必须为下面指定的每个测试用例计算一个包含五个浮点数的列表，顺序为\n$[E_Q(N_1), E_Q(N_2), p, E_{T_{h,\\mathrm{out}}}(N_2), E_{T_{c,\\mathrm{out}}}(N_2)]$，\n其中 $E_Q(N)$ 是使用 $N$ 个网格段时 $Q$ 的相对误差，$E_{T_{h,\\mathrm{out}}}(N_2)$ 和 $E_{T_{c,\\mathrm{out}}}(N_2)$ 是使用更精细的网格 $N_2$ 时出口温度的相对误差。将所有测试用例的列表汇总到单行输出中，该输出包含一个用方括号括起来的逗号分隔列表，其中每个元素是如上所述的单个测试用例列表。\n\n使用以下参数值的测试套件来检验不同的工况：\n\n- 测试用例 1 (中等传热, 水-水):\n  - $U = 600\\,\\mathrm{W\\,m^{-2}\\,K^{-1}}$, $P = 2.5\\,\\mathrm{m}$, $L = 12\\,\\mathrm{m}$,\n  - $\\dot{m}_h = 1.2\\,\\mathrm{kg\\,s^{-1}}$, $c_{p,h} = 4181\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$,\n  - $\\dot{m}_c = 1.8\\,\\mathrm{kg\\,s^{-1}}$, $c_{p,c} = 4181\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$,\n  - $T_{h,\\mathrm{in}} = 350\\,\\mathrm{K}$, $T_{c,\\mathrm{in}} = 300\\,\\mathrm{K}$。\n- 测试用例 2 (弱传热, 温差驱动力小):\n  - $U = 100\\,\\mathrm{W\\,m^{-2}\\,K^{-1}}$, $P = 1.5\\,\\mathrm{m}$, $L = 5\\,\\mathrm{m}$,\n  - $\\dot{m}_h = 1.0\\,\\mathrm{kg\\,s^{-1}}$, $c_{p,h} = 4200\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$,\n  - $\\dot{m}_c = 1.0\\,\\mathrm{kg\\,s^{-1}}$, $c_{p,c} = 4180\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$,\n  - $T_{h,\\mathrm{in}} = 330\\,\\mathrm{K}$, $T_{c,\\mathrm{in}} = 325\\,\\mathrm{K}$。\n- 测试用例 3 (强传热, 接近平衡):\n  - $U = 2000\\,\\mathrm{W\\,m^{-2}\\,K^{-1}}$, $P = 2.0\\,\\mathrm{m}$, $L = 25\\,\\mathrm{m}$,\n  - $\\dot{m}_h = 0.8\\,\\mathrm{kg\\,s^{-1}}$, $c_{p,h} = 4000\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$,\n  - $\\dot{m}_c = 0.8\\,\\mathrm{kg\\,s^{-1}}$, $c_{p,c} = 4000\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$,\n  - $T_{h,\\mathrm{in}} = 360\\,\\mathrm{K}$, $T_{c,\\mathrm{in}} = 300\\,\\mathrm{K}$。\n\n对于所有测试用例，数值离散化使用 $N_1 = 200$ 和 $N_2 = 800$ 个网格段。\n\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为一个由方括号括起的、逗号分隔的列表，该列表的每个元素是单个测试用例的列表，例如，\n$[[a_1,b_1,c_1,d_1,e_1],[a_2,b_2,c_2,d_2,e_2],[a_3,b_3,c_3,d_3,e_3]]$，\n其中每个 $a_i$、$b_i$、$c_i$、$d_i$、$e_i$ 是如上定义的浮点数。",
            "solution": "问题陈述是在输运现象和数值方法领域，特别是在热工学背景下，一个适定且科学上合理的练习。它要求对并流换热器的解析解和数值解进行比较，并进行后续的误差分析。该问题是有效的，将提供解答。\n\n分析过程分为四个阶段：\n1.  从第一性原理推导常微分方程（ODE）控制系统。\n2.  推导出口温度和总传热速率的解析解。\n3.  基于一阶有限体积（或显式欧拉）法构建数值求解格式。\n4.  定义误差度量标准和评估数值格式准确性的程序。\n\n**1. 控制方程**\n\n考虑沿换热器长度为 $dx$ 的一个微元控制体。在稳态条件下，该控制体内热流体和冷流体的能量守恒得出：\n\n对于热流体，焓变率等于传递给冷流体的热量速率：\n$$d\\dot{Q} = -\\dot{m}_h c_{p,h} dT_h = -C_h dT_h$$\n根据 Newton 冷却定律，该传热量也由下式给出：\n$$d\\dot{Q} = U (P dx) [T_h(x) - T_c(x)]$$\n结合以上两式，得到第一个控制常微分方程：\n$$\\frac{dT_h}{dx} = -\\frac{UP}{C_h} [T_h(x) - T_c(x)]$$\n\n对于冷流体，焓变率等于从热流体接收的热量速率：\n$$d\\dot{Q} = \\dot{m}_c c_{p,c} dT_c = C_c dT_c$$\n这就得到了第二个控制常微分方程：\n$$\\frac{dT_c}{dx} = \\frac{UP}{C_c} [T_h(x) - T_c(x)]$$\n\n对于并流配置，该系统在入口 $x=0$ 处满足以下初始条件：\n$$T_h(0) = T_{h,\\mathrm{in}}$$\n$$T_c(0) = T_{c,\\mathrm{in}}$$\n\n**2. 解析解**\n\n为求解该耦合线性系统，我们定义温差 $\\Delta T(x) = T_h(x) - T_c(x)$。将 $\\Delta T(x)$ 对 $x$ 求导：\n$$\\frac{d(\\Delta T)}{dx} = \\frac{dT_h}{dx} - \\frac{dT_c}{dx} = -\\frac{UP}{C_h} [T_h(x) - T_c(x)] - \\frac{UP}{C_c} [T_h(x) - T_c(x)]$$\n$$\\frac{d(\\Delta T)}{dx} = -UP \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right) \\Delta T(x)$$\n这是一个关于 $\\Delta T(x)$ 的可分离一阶常微分方程。我们可以将其从入口（$x=0$）积分到出口（$x=L$）：\n$$\\int_{\\Delta T_1}^{\\Delta T_2} \\frac{d(\\Delta T)}{\\Delta T} = -UP \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right) \\int_0^L dx$$\n其中 $\\Delta T_1 = \\Delta T(0) = T_{h,\\mathrm{in}} - T_{c,\\mathrm{in}}$ 且 $\\Delta T_2 = \\Delta T(L) = T_{h,\\mathrm{out}} - T_{c,\\mathrm{out}}$。\n\n积分得到：\n$$\\ln\\left(\\frac{\\Delta T_2}{\\Delta T_1}\\right) = -UPL \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right)$$\n总传热速率 $Q$ 可以通过对每股流体的总能量平衡来表示：\n$$Q = C_h (T_{h,\\mathrm{in}} - T_{h,\\mathrm{out}})$$\n$$Q = C_c (T_{c,\\mathrm{out}} - T_{c,\\mathrm{in}})$$\n由此，我们可以用 $Q$ 来表示出口温度：\n$$T_{h,\\mathrm{out}} = T_{h,\\mathrm{in}} - \\frac{Q}{C_h}$$\n$$T_{c,\\mathrm{out}} = T_{c,\\mathrm{in}} + \\frac{Q}{C_c}$$\n将这些代入 $\\Delta T_2$ 的表达式中：\n$$\\Delta T_2 = \\left(T_{h,\\mathrm{in}} - \\frac{Q}{C_h}\\right) - \\left(T_{c,\\mathrm{in}} + \\frac{Q}{C_c}\\right) = (T_{h,\\mathrm{in}} - T_{c,\\mathrm{in}}) - Q \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right) = \\Delta T_1 - Q \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right)$$\n现在将此 $\\Delta T_2$ 的表达式代回对数项中：\n$$\\ln\\left(\\frac{\\Delta T_1 - Q \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right)}{\\Delta T_1}\\right) = -UPL \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right)$$\n求解 $Q$ 可得总传熱速率的解析表达式：\n$$1 - \\frac{Q}{\\Delta T_1} \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right) = \\exp\\left[-UPL \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right)\\right]$$\n$$Q_{\\mathrm{an}} = \\frac{T_{h,\\mathrm{in}} - T_{c,\\mathrm{in}}}{\\frac{1}{C_h} + \\frac{1}{C_c}} \\left(1 - \\exp\\left[-UPL \\left( \\frac{1}{C_h} + \\frac{1}{C_c} \\right)\\right]\\right)$$\n计算出 $Q_{\\mathrm{an}}$ 后，可直接求得解析解的出口温度：\n$$T_{h,\\mathrm{out,an}} = T_{h,\\mathrm{in}} - \\frac{Q_{\\mathrm{an}}}{C_h}$$\n$$T_{c,\\mathrm{out,an}} = T_{c,\\mathrm{in}} + \\frac{Q_{\\mathrm{an}}}{C_c}$$\n这些是给定模型的精确解析参考值。\n\n**3. 数值解**\n\n将域 $[0,L]$ 离散化为 $N$ 个长度为 $\\Delta x = L/N$ 的均匀段。离散点 $x_i = i \\Delta x$（其中 $i=0, 1, \\dots, N$）处的温度表示为 $T_i$。\n将一阶显式欧拉法应用于控制常微分方程：\n$$y_{i+1} = y_i + f(y_i) \\Delta x$$\n对于我们的系统，这变为：\n$$T_{h,i+1} = T_{h,i} - \\frac{UP}{C_h} (T_{h,i} - T_{c,i}) \\Delta x$$\n$$T_{c,i+1} = T_{c,i} + \\frac{UP}{C_c} (T_{h,i} - T_{c,i}) \\Delta x$$\n从初始条件 $T_{h,0} = T_{h,\\mathrm{in}}$ 和 $T_{c,0} = T_{c,\\mathrm{in}}$ 开始，我们沿换热器从 $i=0$ 到 $i=N-1$ 进行计算，求解每个节点的温度。数值解的出口温度是最后一个节点 $i=N$ 处的值：\n$$T_{h,\\mathrm{out,num}} = T_{h,N}$$\n$$T_{c,\\mathrm{out,num}} = T_{c,N}$$\n数值解的总传热速率 $Q_{\\mathrm{num}}$ 是通过使用计算出的出口温度进行总能量平衡来确定的：\n$$Q_{\\mathrm{num}} = C_h (T_{h,\\mathrm{in}} - T_{h,\\mathrm{out,num}})$$\n此方法等效于在顶点中心网格上的一阶有限体积格式，其中通量使用迎风值（在此单向平流系统中即为单元中心值）进行评估。\n\n**4. 误差分析**\n\n为了量化数值格式的准确性，我们计算物理量 $X$ 的相对误差如下：\n$$E_X = \\frac{|X_{\\mathrm{num}} - X_{\\mathrm{an}}|}{|X_{\\mathrm{an}}|}$$\n问题要求计算两种网格分辨率 $N_1$ 和 $N_2$ 下总传热速率的相对误差 $E_Q(N)$，以及在更精细网格下出口温度的相对误差 $E_{T_{h,\\mathrm{out}}}(N_2)$ 和 $E_{T_{c,\\mathrm{out}}}(N_2)$。\n\n在本例中，数值误差的主要来源是欧拉法固有的截断误差。显式欧拉法是一种一阶方法，意味着其局部截断误差为 $\\Delta x^2$ 阶，导致全局误差为 $\\Delta x$ 阶。因此，误差 $E$ 预期与 $\\Delta x$ 成正比，或与 $N$ 成反比：\n$$E \\approx C \\Delta x = C \\frac{L}{N}$$\n其中 $C$ 是一个常数。观测到的精度阶 $p$ 可以根据在两个不同网格 $N_1$ 和 $N_2$ 上计算出的误差来估算：\n$$E_{N_1} \\approx C/N_1$$\n$$E_{N_2} \\approx C/N_2$$\n将这两个表达式相除得到 $E_{N_1}/E_{N_2} \\approx N_2/N_1$。取自然对数并重新整理，得到 $p$ 的计算公式：\n$$p = \\frac{\\ln(E_{N_1}/E_{N_2})}{\\ln(N_2/N_1)}$$\n对于一阶格式，我们期望 $p \\approx 1$。任何显著的偏差都表明，要么尚未达到渐近误差区，要么其他误差源（如浮点舍入误差）开始占主导地位（这对于指定的 $N_1$、$N_2$ 和标准双精度算术来说不太可能）。因此，$p$ 的计算用于从数值上验证所实现格式的理论精度阶。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the heat exchanger problem for three test cases, comparing\n    analytical and numerical solutions and performing an error analysis.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (moderate transfer, water-to-water)\n        {\n            \"U\": 600.0, \"P\": 2.5, \"L\": 12.0,\n            \"mdot_h\": 1.2, \"cp_h\": 4181.0,\n            \"mdot_c\": 1.8, \"cp_c\": 4181.0,\n            \"Th_in\": 350.0, \"Tc_in\": 300.0\n        },\n        # Test case 2 (weak transfer, small temperature driving force)\n        {\n            \"U\": 100.0, \"P\": 1.5, \"L\": 5.0,\n            \"mdot_h\": 1.0, \"cp_h\": 4200.0,\n            \"mdot_c\": 1.0, \"cp_c\": 4180.0,\n            \"Th_in\": 330.0, \"Tc_in\": 325.0\n        },\n        # Test case 3 (strong transfer, near-equilibration)\n        {\n            \"U\": 2000.0, \"P\": 2.0, \"L\": 25.0,\n            \"mdot_h\": 0.8, \"cp_h\": 4000.0,\n            \"mdot_c\": 0.8, \"cp_c\": 4000.0,\n            \"Th_in\": 360.0, \"Tc_in\": 300.0\n        }\n    ]\n    \n    N1 = 200\n    N2 = 800\n\n    def solve_analytical(params):\n        \"\"\"Calculates the analytical solution.\"\"\"\n        C_h = params[\"mdot_h\"] * params[\"cp_h\"]\n        C_c = params[\"mdot_c\"] * params[\"cp_c\"]\n        Th_in = params[\"Th_in\"]\n        Tc_in = params[\"Tc_in\"]\n        U, P, L = params[\"U\"], params[\"P\"], params[\"L\"]\n\n        inv_Ch_plus_inv_Cc = (1.0 / C_h) + (1.0 / C_c)\n        exponent_term = -U * P * L * inv_Ch_plus_inv_Cc\n        \n        Q_an = (Th_in - Tc_in) / inv_Ch_plus_inv_Cc * (1.0 - np.exp(exponent_term))\n        \n        Th_out_an = Th_in - Q_an / C_h\n        Tc_out_an = Tc_in + Q_an / C_c\n        \n        return Q_an, Th_out_an, Tc_out_an\n\n    def solve_numerical(params, N):\n        \"\"\"Calculates the numerical solution using explicit Euler.\"\"\"\n        C_h = params[\"mdot_h\"] * params[\"cp_h\"]\n        C_c = params[\"mdot_c\"] * params[\"cp_c\"]\n        Th_in = params[\"Th_in\"]\n        Tc_in = params[\"Tc_in\"]\n        U, P, L = params[\"U\"], params[\"P\"], params[\"L\"]\n        \n        dx = L / N\n        \n        Th = Th_in\n        Tc = Tc_in\n        \n        # Coefficients for Euler update\n        K_h = U * P / C_h * dx\n        K_c = U * P / C_c * dx\n\n        for _ in range(N):\n            T_diff = Th - Tc\n            Th_new = Th - K_h * T_diff\n            Tc_new = Tc + K_c * T_diff\n            Th, Tc = Th_new, Tc_new\n            \n        Th_out_num = Th\n        Tc_out_num = Tc\n\n        # Calculate Q from the hot fluid energy balance\n        Q_num = C_h * (Th_in - Th_out_num)\n\n        return Q_num, Th_out_num, Tc_out_num\n\n    all_results = []\n    \n    for case in test_cases:\n        # Analytical solution\n        Q_an, Th_out_an, Tc_out_an = solve_analytical(case)\n\n        # Numerical solution for N1\n        Q_num_N1, _, _ = solve_numerical(case, N1)\n        \n        # Numerical solution for N2\n        Q_num_N2, Th_out_num_N2, Tc_out_num_N2 = solve_numerical(case, N2)\n\n        # Calculate relative errors\n        E_Q_N1 = np.abs(Q_num_N1 - Q_an) / np.abs(Q_an) if Q_an != 0 else 0.0\n        E_Q_N2 = np.abs(Q_num_N2 - Q_an) / np.abs(Q_an) if Q_an != 0 else 0.0\n        \n        # Handle cases where outlet temperatures might be exactly zero or analytical value is zero\n        # (unlikely here, but good practice)\n        E_Th_out_N2 = np.abs(Th_out_num_N2 - Th_out_an) / np.abs(Th_out_an) if Th_out_an != 0 else 0.0\n        E_Tc_out_N2 = np.abs(Tc_out_num_N2 - Tc_out_an) / np.abs(Tc_out_an) if Tc_out_an != 0 else 0.0\n\n        # Calculate observed order of accuracy p\n        # Check for non-positive errors before taking log\n        if E_Q_N1 = 0 or E_Q_N2 = 0:\n            p = np.nan # Not meaningful if errors are zero or negative\n        else:\n            p = np.log(E_Q_N1 / E_Q_N2) / np.log(N2 / N1)\n\n        result_list = [E_Q_N1, E_Q_N2, p, E_Th_out_N2, E_Tc_out_N2]\n        all_results.append(result_list)\n        \n    # Format the output string as a list of lists without spaces.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "在实际工程问题中，精确的解析解往往难以获得，这使得网格收敛性分析成为一种不可或缺的验证工具。通过在系统性加密的网格上进行计算，我们可以评估数值解的离散误差，并验证我们代码的实现是否正确。本练习将引导您实现一个更稳健的隐式格式，并应用理查森外推法来估算数值解的收敛阶和网格无关解，这是计算流体动力学和传热学中的一项核心技能 。",
            "id": "3960797",
            "problem": "一个长度为 $L$、湿周长为 $P$ 的一维并流双套管换热器在稳态下运行，两种流体和管壁的轴向传导可忽略不计。每股流体在横截面上充分混合，物性是恒定的，总传热系数 (OHTC) $U$ 沿长度方向是均匀的。热流体和冷流体的质量流量分别为 $m_h$ 和 $m_c$，恒定比热容分别为 $c_{p,h}$ 和 $c_{p,c}$。入口温度为 $T_{h,\\text{in}}$ 和 $T_{c,\\text{in}}$。对沿换热器长度为 $dx$ 的微元控制体应用能量平衡（使用热力学第一定律和牛顿冷却定律），可得到关于热、冷流体温度 $T_h(x)$ 和 $T_c(x)$（其中 $x \\in [0,L]$）的一维耦合常微分控制方程。问题在于，通过在一个包含 $N$ 个控制体积的均匀网格上进行保守的有限体积离散化，来数值近似这些场变量，为逐次加密的网格计算出口温度 $T_{h,\\text{out}} = T_h(L)$ 和 $T_{c,\\text{out}} = T_c(L)$，并执行网格收敛性研究，通过 Richardson 外推法估计观测到的精度阶。\n\n从基本定律和核心定义出发，针对均匀网格尺寸 $h = L/N$，推导一个在轴向坐标 $x$ 上协调的一阶精度隐式推进格式。用一个程序实现该格式，该程序：\n- 以入口温度为边界值，从 $x=0$ 推进到 $x=L$，\n- 为三个逐次加密的网格（加密比 $r = 2$）计算出口温度，\n- 应用 Richardson 外推法估计每个出口温度的观测精度阶。\n\n您必须使用以下参数值测试套件（每个测试用例使用三个网格，其 $N_1$、$N_2$、$N_3$ 满足 $N_2 = 2 N_1$ 和 $N_3 = 2 N_2$）：\n\n- 测试用例 A (热容率平衡，中等传热): $L=5$ m, $P=1$ m, $U=400$ W/m$^2$K, $m_h=1.5$ kg/s, $c_{p,h}=4180$ J/kgK, $m_c=1.5$ kg/s, $c_{p,c}=4180$ J/kgK, $T_{h,\\text{in}}=360$ K, $T_{c,\\text{in}}=300$ K, $(N_1,N_2,N_3)=(50,100,200)$。\n- 测试用例 B (热容率不平衡): $L=5$ m, $P=1$ m, $U=300$ W/m$^2$K, $m_h=3.0$ kg/s, $c_{p,h}=4180$ J/kgK, $m_c=1.0$ kg/s, $c_{p,c}=4180$ J/kgK, $T_{h,\\text{in}}=370$ K, $T_{c,\\text{in}}=295$ K, $(N_1,N_2,N_3)=(50,100,200)$。\n- 测试用例 C (较长换热器，弱传热): $L=10$ m, $P=1$ m, $U=80$ W/m$^2$K, $m_h=2.0$ kg/s, $c_{p,h}=4180$ J/kgK, $m_c=2.5$ kg/s, $c_{p,c}=4180$ J/kgK, $T_{h,\\text{in}}=350$ K, $T_{c,\\text{in}}=310$ K, $(N_1,N_2,N_3)=(50,100,200)$。\n- 测试用例 D (较短换热器，强传热): $L=2$ m, $P=0.8$ m, $U=1200$ W/m$^2$K, $m_h=0.8$ kg/s, $c_{p,h}=4180$ J/kgK, $m_c=0.8$ kg/s, $c_{p,c}=4180$ J/kgK, $T_{h,\\text{in}}=330$ K, $T_{c,\\text{in}}=290$ K, $(N_1,N_2,N_3)=(50,100,200)$。\n\n对于每个测试用例，计算 $N_1$、$N_2$ 和 $N_3$ 的出口温度，然后使用 Richardson 外推法估计热流体出口温度的观测精度阶 $p_h$ 和冷流体出口温度的观测精度阶 $p_c$。此外，基于两个最细的网格和估计的阶数，计算 Richardson 外推的出口温度 $T_{h,\\infty}$ 和 $T_{c,\\infty}$ (单位为开尔文)。如果 Richardson 估计不处于渐近区域（例如，如果连续差分变号或消失），则对该分量的阶数和外推温度返回一个非数值 (non-number)。\n\n输出和单位要求：\n- 温度必须在内部计算，并在报告时以开尔文表示。\n- 观测阶数 $p_h$ 和 $p_c$ 是无量纲的。\n- 将每个观测阶数四舍五入到小数点后 $5$ 位，每个外推出口温度四舍五入到小数点后 $3$ 位。\n- 您的程序应生成单行输出，包含一个逗号分隔的列表的列表，每个测试用例一个列表，顺序为 A、B、C、D。每个内部列表的形式必须为 $[p_h, p_c, T_{h,\\infty}, T_{c,\\infty}]$。例如，$[[p_h^{(A)},p_c^{(A)},T_{h,\\infty}^{(A)},T_{c,\\infty}^{(A)}],[p_h^{(B)},p_c^{(B)},T_{h,\\infty}^{(B)},T_{c,\\infty}^{(B)}],\\dots]$。\n\n程序必须是完整且可运行的，并且不得需要任何用户输入。",
            "solution": "该问题要求推导并实现一个一阶精度的隐式有限体积格式，用于模拟一维并流双套管换热器。该实现将用于计算几个测试用例在逐次加密网格上的出口温度，然后使用 Richardson 外推法进行网格收敛性研究，以估计精度阶和外推得到的网格无关出口温度。\n\n### 第 1 步：控制方程\n物理系统是一个在稳态下运行的并流换热器。我们将热力学第一定律（能量守恒）应用于沿换热器轴线，从位置 $x$ 到 $x+dx$、长度为 $dx$ 的微元控制体。\n\n通过微元面积 $dA = P dx$ 在两种流体之间传递的热量率 $\\delta\\dot{Q}$ 由牛顿冷却定律给出：\n$$ \\delta\\dot{Q} = U (T_h(x) - T_c(x)) P dx $$\n其中 $U$ 是总传热系数，$P$ 是湿周长，$T_h(x)$ 和 $T_c(x)$ 分别是热流体和冷流体的局部温度。\n\n对于热流体，焓率的变化必须与从流体传出的热量相平衡：\n$$ \\dot{m}_h c_{p,h} T_h(x) - \\dot{m}_h c_{p,h} T_h(x+dx) = \\delta\\dot{Q} $$\n$$ -\\dot{m}_h c_{p,h} (T_h(x+dx) - T_h(x)) = U P (T_h(x) - T_c(x)) dx $$\n将热流体的热容率定义为 $C_h = \\dot{m}_h c_{p,h}$，并取极限 $dx \\to 0$，我们得到第一个常微分控制方程 (ODE)：\n$$ \\frac{dT_h}{dx} = -\\frac{UP}{C_h} (T_h - T_c) $$\n\n对于冷流体，焓率的变化必须与传入流体的热量相平衡：\n$$ \\dot{m}_c c_{p,c} T_c(x+dx) - \\dot{m}_c c_{p,c} T_c(x) = \\delta\\dot{Q} $$\n将冷流体的热容率定义为 $C_c = \\dot{m}_c c_{p,c}$，并取极限 $dx \\to 0$，我们得到第二个常微分控制方程：\n$$ \\frac{dT_c}{dx} = \\frac{UP}{C_c} (T_h - T_c) $$\n\n该问题是一个空间上的初值问题，边界条件在入口 $x=0$ 处给出：\n$$ T_h(0) = T_{h,\\text{in}} \\quad \\text{和} \\quad T_c(0) = T_{c,\\text{in}} $$\n\n### 第 2 步：有限体积离散化和隐式格式\n我们将长度为 $L$ 的域离散化为 $N$ 个均匀的控制体积 (CV)，每个控制体积的长度为 $h = L/N$。节点位于 $x_i = i \\cdot h$ 的位置，其中 $i = 0, 1, \\dots, N$。第 $i$ 个控制体积从 $x_i$ 延伸到 $x_{i+1}$。我们在此控制体积上对控制常微分方程进行积分。\n\n对于热流体：\n$$ \\int_{x_i}^{x_{i+1}} \\frac{dT_h}{dx} dx = \\int_{x_i}^{x_{i+1}} -\\frac{UP}{C_h} (T_h(x) - T_c(x)) dx $$\n$$ T_h(x_{i+1}) - T_h(x_i) = -\\frac{UP}{C_h} \\int_{x_i}^{x_{i+1}} (T_h(x) - T_c(x)) dx $$\n令 $T_{h,i}$ 表示温度 $T_h(x_i)$。方程变为：\n$$ T_{h,i+1} - T_{h,i} = -\\frac{UP}{C_h} \\int_{x_i}^{x_{i+1}} (T_h(x) - T_c(x)) dx $$\n\n类似地，对于冷流体：\n$$ T_{c,i+1} - T_{c,i} = \\frac{UP}{C_c} \\int_{x_i}^{x_{i+1}} (T_h(x) - T_c(x)) dx $$\n\n为了构建一个一阶精度的隐式格式，我们使用区间末端 $x_{i+1}$ 的函数值来近似右侧的积分。这是一种后向欧拉法。\n$$ \\int_{x_i}^{x_{i+1}} f(x) dx \\approx f(x_{i+1}) \\cdot (x_{i+1} - x_i) = f_{i+1} \\cdot h $$\n将此应用于我们的积分方程：\n$$ T_{h,i+1} - T_{h,i} = -\\frac{UP h}{C_h} (T_{h,i+1} - T_{c,i+1}) $$\n$$ T_{c,i+1} - T_{c,i} = \\frac{UP h}{C_c} (T_{h,i+1} - T_{c,i+1}) $$\n\n这是关于节点 $i+1$ 处的未知温度 $T_{h,i+1}$ 和 $T_{c,i+1}$（用节点 $i$ 处的已知温度表示）的两个耦合线性代数方程组。让我们定义无量纲参数 $k_h = \\frac{UP h}{C_h}$ 和 $k_c = \\frac{UP h}{C_c}$。\n$$ T_{h,i+1} - T_{h,i} = -k_h (T_{h,i+1} - T_{c,i+1}) $$\n$$ T_{c,i+1} - T_{c,i} = k_c (T_{h,i+1} - T_{c,i+1}) $$\n重新整理，将未知数置于左侧：\n$$ (1+k_h) T_{h,i+1} - k_h T_{c,i+1} = T_{h,i} $$\n$$ -k_c T_{h,i+1} + (1+k_c) T_{c,i+1} = T_{c,i} $$\n这是每个推进步骤的 $2 \\times 2$ 线性系统：\n$$ \\begin{pmatrix} 1+k_h  -k_h \\\\ -k_c  1+k_c \\end{pmatrix} \\begin{pmatrix} T_{h,i+1} \\\\ T_{c,i+1} \\end{pmatrix} = \\begin{pmatrix} T_{h,i} \\\\ T_{c,i} \\end{pmatrix} $$\n\n### 第 3 步：推进格式的推导\n为了找到更新规则，我们求解这个 $2 \\times 2$ 系统。系数矩阵的行列式是 $D = (1+k_h)(1+k_c) - (-k_h)(-k_c) = 1 + k_h + k_c$。矩阵的逆为：\n$$ \\frac{1}{1+k_h+k_c} \\begin{pmatrix} 1+k_c  k_h \\\\ k_c  1+k_h \\end{pmatrix} $$\n因此，节点 $i+1$ 处的温度解为：\n$$ \\begin{pmatrix} T_{h,i+1} \\\\ T_{c,i+1} \\end{pmatrix} = \\frac{1}{1+k_h+k_c} \\begin{pmatrix} 1+k_c  k_h \\\\ k_c  1+k_h \\end{pmatrix} \\begin{pmatrix} T_{h,i} \\\\ T_{c,i} \\end{pmatrix} $$\n这给出了推进格式的显式更新公式：\n$$ T_{h,i+1} = \\frac{(1+k_c)T_{h,i} + k_h T_{c,i}}{1+k_h+k_c} $$\n$$ T_{c,i+1} = \\frac{k_c T_{h,i} + (1+k_h) T_{c,i}}{1+k_h+k_c} $$\n从已知的入口温度 $T_{h,0} = T_{h,\\text{in}}$ 和 $T_{c,0} = T_{c,\\text{in}}$ 开始，我们应用此格式 $N$ 次，从 $x=0$ 推进到 $x=L$，从而得到出口温度 $T_{h,N}$ 和 $T_{c,N}$。\n\n### 第 4 步：通过 Richardson 外推法进行网格收敛性分析\n设 $f_h$ 为在网格间距 $h$ 下计算得到的某个待求量（例如出口温度）的通用数值解。误差展开式假定为 $f_h = f_{exact} + A h^p + \\mathcal{O}(h^q)$ 的形式，其中 $p$ 是精度阶，且 $qp$。\n给定在步长分别为 $h_1, h_2=h_1/r, h_3=h_2/r$ 的网格上计算得到的三个解 $f_1, f_2, f_3$，其中 $r=2$ 是加密比，观测到的精度阶 $p$ 可估计为：\n$$ p = \\frac{\\ln\\left(\\frac{f_2 - f_1}{f_3 - f_2}\\right)}{\\ln(r)} $$\n该估计仅在解处于渐近收敛区域时有效，此时连续差分 $(f_2-f_1)$ 和 $(f_3-f_2)$ 符号相同且非零。如果收敛不是单调的，我们无法可靠地估计 $p$。\n\n一旦估计出 $p$，就可以通过对两个最细网格的解（$f_2, f_3$）进行外推，得到精确解 $f_{\\infty}$ 的一个更准确的估计：\n$$ f_{\\infty} = f_3 + \\frac{f_3 - f_2}{r^p - 1} $$\n对每个测试用例，此过程独立地应用于热侧出口温度 ($T_{h,\\text{out}}$) 和冷侧出口温度 ($T_{c,\\text{out}}$)。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve_heat_exchanger(L, P, U, mh, cph, mc, cpc, Th_in, Tc_in, N):\n    \"\"\"\n    Solves for the outlet temperatures of a co-current heat exchanger\n    using a first-order implicit finite volume method.\n\n    Args:\n        L (float): Length of the exchanger (m).\n        P (float): Wetted perimeter (m).\n        U (float): Overall heat transfer coefficient (W/m^2K).\n        mh (float): Mass flow rate of hot fluid (kg/s).\n        cph (float): Specific heat of hot fluid (J/kgK).\n        mc (float): Mass flow rate of cold fluid (kg/s).\n        cpc (float): Specific heat of cold fluid (J/kgK).\n        Th_in (float): Inlet temperature of hot fluid (K).\n        Tc_in (float): Inlet temperature of cold fluid (K).\n        N (int): Number of control volumes.\n\n    Returns:\n        tuple[float, float]: Outlet temperatures (Th_out, Tc_out) in Kelvin.\n    \"\"\"\n    h = L / N\n    Ch = mh * cph\n    Cc = mc * cpc\n\n    # Handle potential division by zero if C is zero\n    if Ch == 0 or Cc == 0:\n        return (Th_in, Tc_in) if Ch == 0 else (np.nan, np.nan), (Tc_in, Th_in) if Cc == 0 else (np.nan, np.nan)\n\n\n    kh = U * P * h / Ch\n    kc = U * P * h / Cc\n    \n    denominator = 1.0 + kh + kc\n\n    Th_current = Th_in\n    Tc_current = Tc_in\n\n    for _ in range(N):\n        Th_next = ((1.0 + kc) * Th_current + kh * Tc_current) / denominator\n        Tc_next = (kc * Th_current + (1.0 + kh) * Tc_current) / denominator\n        Th_current = Th_next\n        Tc_current = Tc_next\n        \n    return Th_current, Tc_current\n\ndef perform_richardson_extrapolation(f1, f2, f3, r):\n    \"\"\"\n    Performs Richardson extrapolation to find the observed order and extrapolated value.\n\n    Args:\n        f1, f2, f3 (float): Solutions on coarse, medium, and fine grids.\n        r (float): Refinement ratio.\n\n    Returns:\n        tuple[float, float]: Observed order p and extrapolated value f_inf.\n    \"\"\"\n    diff1 = f2 - f1\n    diff2 = f3 - f2\n\n    # Check for asymptotic regime (convergence must be monotonic and non-zero)\n    if diff1 * diff2 = 0:\n        return np.nan, np.nan\n\n    ratio = diff1 / diff2\n    \n    p = math.log(ratio) / math.log(r)\n    \n    if (r**p - 1.0) == 0:\n        return p, np.nan\n        \n    f_inf = f3 + diff2 / (r**p - 1.0)\n    \n    return p, f_inf\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print final results.\n    \"\"\"\n    test_cases = [\n        # Test case A\n        {'L': 5, 'P': 1, 'U': 400, 'mh': 1.5, 'cph': 4180, 'mc': 1.5, 'cpc': 4180, 'Th_in': 360, 'Tc_in': 300, 'N_tuple': (50, 100, 200)},\n        # Test case B\n        {'L': 5, 'P': 1, 'U': 300, 'mh': 3.0, 'cph': 4180, 'mc': 1.0, 'cpc': 4180, 'Th_in': 370, 'Tc_in': 295, 'N_tuple': (50, 100, 200)},\n        # Test case C\n        {'L': 10, 'P': 1, 'U': 80, 'mh': 2.0, 'cph': 4180, 'mc': 2.5, 'cpc': 4180, 'Th_in': 350, 'Tc_in': 310, 'N_tuple': (50, 100, 200)},\n        # Test case D\n        {'L': 2, 'P': 0.8, 'U': 1200, 'mh': 0.8, 'cph': 4180, 'mc': 0.8, 'cpc': 4180, 'Th_in': 330, 'Tc_in': 290, 'N_tuple': (50, 100, 200)},\n    ]\n    \n    r = 2.0  # Refinement ratio\n    final_results_str_list = []\n\n    for case in test_cases:\n        params = {k: v for k, v in case.items() if k != 'N_tuple'}\n        N1, N2, N3 = case['N_tuple']\n        \n        Th_out1, Tc_out1 = solve_heat_exchanger(**params, N=N1)\n        Th_out2, Tc_out2 = solve_heat_exchanger(**params, N=N2)\n        Th_out3, Tc_out3 = solve_heat_exchanger(**params, N=N3)\n        \n        p_h, Th_inf = perform_richardson_extrapolation(Th_out1, Th_out2, Th_out3, r)\n        p_c, Tc_inf = perform_richardson_extrapolation(Tc_out1, Tc_out2, Tc_out3, r)\n\n        ph_str = f\"{p_h:.5f}\" if not np.isnan(p_h) else \"nan\"\n        pc_str = f\"{p_c:.5f}\" if not np.isnan(p_c) else \"nan\"\n        Th_inf_str = f\"{Th_inf:.3f}\" if not np.isnan(Th_inf) else \"nan\"\n        Tc_inf_str = f\"{Tc_inf:.3f}\" if not np.isnan(Tc_inf) else \"nan\"\n        \n        case_str = f\"[{ph_str},{pc_str},{Th_inf_str},{Tc_inf_str}]\"\n        final_results_str_list.append(case_str)\n\n    print(f\"[{','.join(final_results_str_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "计算模型通常包含必须通过实验数据来确定的未知参数，这个过程称为模型校准或参数辨识。然而，在进行实验之前，一个至关重要的问题是：模型本身的结构是否允许我们唯一地确定这些参数？这个高级练习将向您介绍结构可辨识性的关键概念，并教您如何使用基于灵敏度分析和奇异值分解（SVD）的计算方法来评估参数的可辨识性，从而将理论建模与实际的实验设计联系起来 。",
            "id": "3960765",
            "problem": "一维顺流管式换热器被建模为两个平推流流体，它们通过一个壁面进行热交换，该壁面的轴向导热和热容均可忽略不计。热流体温度 $T_h(x)$ 和冷流体温度 $T_c(x)$ 沿轴向坐标 $x \\in [0,L]$ 变化。热流体入口温度 $T_{h,\\mathrm{in}}$ 和冷流体入口温度 $T_{c,\\mathrm{in}}$ 施加在 $x=0$ 处。热、冷流体的质量流量分别为 $\\dot{m}_h$ 和 $\\dot{m}_c$（单位：$\\mathrm{kg/s}$）。比热容分别为 $c_{p,h}$ 和 $c_{p,c}$（单位：$\\mathrm{J/(kg\\cdot K)}$）。总传热系数乘以单位长度面积记为 $k$（单位：$\\mathrm{W/(m\\cdot K)}$）。为反映因持液或分布不均导致的有效热容率可能存在的不确定性，引入无量纲比例参数 $s_h$ 和 $s_c$ 分别乘以热、冷流体的热容率。\n\n从应用于长度为 $\\mathrm{d}x$ 的无穷小切片的能量守恒出发，忽略轴向导热和壁面热容，并假设物性恒定。推导控制方程，并建立一个计算程序，以评估在改变质量流量和入口温度的设计实验下，从稳态出口温度测量值对参数向量 $\\boldsymbol{\\theta} = [k, s_h, s_c]^\\top$ 的结构可辨识性。\n\n使用以下基本依据和事实：\n- 微分控制体的能量守恒意味着对流焓变与流体间的热传递相平衡，且热传递量与温差成正比。\n- 平推流意味着轴向平流占主导地位，局部横向传热由一个线性系数描述。\n\n待实现的模型规范：\n- 设 $L$ 为换热器长度（单位：$\\mathrm{m}$）。顺流的控制性一维稳态方程为：\n$$\\frac{\\mathrm{d}T_h}{\\mathrm{d}x} = - \\frac{k}{\\dot{m}_h\\, c_{p,h}\\, s_h}\\,\\big(T_h - T_c\\big), \\quad \\frac{\\mathrm{d}T_c}{\\mathrm{d}x} = + \\frac{k}{\\dot{m}_c\\, c_{p,c}\\, s_c}\\,\\big(T_h - T_c\\big),$$\n边界条件为 $T_h(0) = T_{h,\\mathrm{in}}$ 和 $T_c(0) = T_{c,\\mathrm{in}}$。\n- 每个实验的测量输出为出口温度 $T_{h,\\mathrm{out}} = T_h(L)$ 和 $T_{c,\\mathrm{out}} = T_c(L)$。\n\n结构可辨识性评估：\n- 对于一组 $E$ 个独立实验，定义堆叠输出向量 $\\mathbf{y}(\\boldsymbol{\\theta}) \\in \\mathbb{R}^{2E}$，该向量由 $e=1,\\dots,E$ 的 $[T_{h,\\mathrm{out}}^{(e)}, T_{c,\\mathrm{out}}^{(e)}]$ 串联而成。\n- 通过中心有限差分法，围绕名义参数向量 $\\boldsymbol{\\theta}_0$ 来近似雅可比矩阵 $\\mathbf{J}(\\boldsymbol{\\theta}) = \\frac{\\partial \\mathbf{y}}{\\partial \\boldsymbol{\\theta}} \\in \\mathbb{R}^{2E \\times 3}$。\n- 使用奇异值分解 (SVD) 计算 $\\mathbf{J}(\\boldsymbol{\\theta}_0)$ 的数值秩。如果数值秩等于 $3$（参数数量），则宣布 $\\boldsymbol{\\theta}$ 在该实验集下是结构可辨识的。使用一个与最大奇异值相关的相对阈值来确定不可忽略的奇异值。\n\n数值和物理规格：\n- 使用 $L = 10$（单位：$\\mathrm{m}$）、$c_{p,h} = 4180$（单位：$\\mathrm{J/(kg\\cdot K)}$）、$c_{p,c} = 4180$（单位：$\\mathrm{J/(kg\\cdot K)}$）。\n- 使用名义参数 $\\boldsymbol{\\theta}_0 = [k_0, s_{h0}, s_{c0}]^\\top$，其中 $k_0 = 500$（单位：$\\mathrm{W/(m\\cdot K)}$），$s_{h0} = 1$，以及 $s_{c0} = 1$。\n- 通过将 $x \\in [0,L]$ 离散化为 $N$ 个均匀段，并使用遵循控制方程的显式方法推进状态，来对模型解进行数值近似。选择足够大的 $N$ 以确保数值精度和稳定性。\n- 使用中心有限差分法，扰动为 $\\delta_k = 10^{-4}\\,k_0$、$\\delta_{s_h} = 10^{-4}\\,s_{h0}$、$\\delta_{s_c} = 10^{-4}\\,s_{c0}$。\n- 使用基于 SVD 的秩阈值 $\\tau = \\epsilon \\,\\sigma_{\\max}$，其中 $\\sigma_{\\max}$ 是最大奇异值，$\\epsilon = 10^{-8}$。\n\n设计以下实验集作为测试套件。所有温度必须以 $\\mathrm{K}$ 为单位，所有质量流量必须以 $\\mathrm{kg/s}$ 为单位：\n- 测试案例 1（最少信息）：一个实验，其条件为 $(\\dot{m}_h, \\dot{m}_c, T_{h,\\mathrm{in}}, T_{c,\\mathrm{in}}) = (1.0, 1.0, 360.0, 300.0)$。\n- 测试案例 2（精心设计的集合）：三个实验\n  - $(\\dot{m}_h, \\dot{m}_c, T_{h,\\mathrm{in}}, T_{c,\\mathrm{in}}) = (0.8, 1.2, 360.0, 290.0)$,\n  - $(\\dot{m}_h, \\dot{m}_c, T_{h,\\mathrm{in}}, T_{c,\\mathrm{in}}) = (1.5, 0.7, 380.0, 310.0)$,\n  - $(\\dot{m}_h, \\dot{m}_c, T_{h,\\mathrm{in}}, T_{c,\\mathrm{in}}) = (1.0, 1.0, 350.0, 300.0)$。\n- 测试案例 3（冗余实验）：两个相同的实验\n  - $(\\dot{m}_h, \\dot{m}_c, T_{h,\\mathrm{in}}, T_{c,\\mathrm{in}}) = (1.0, 1.0, 360.0, 300.0)$,\n  - $(\\dot{m}_h, \\dot{m}_c, T_{h,\\mathrm{in}}, T_{c,\\mathrm{in}}) = (1.0, 1.0, 360.0, 300.0)$。\n\n你的程序必须：\n- 实现分布式模型的数值求解器。\n- 为每个实验集构建 $\\mathbf{y}(\\boldsymbol{\\theta})$。\n- 通过有限差分法近似 $\\mathbf{J}(\\boldsymbol{\\theta}_0)$。\n- 通过 SVD 计算数值秩并与 $3$ 进行比较。\n- 生成最终输出，格式为单行，内容是用方括号括起来的逗号分隔的布尔值列表，这些值按顺序对应测试案例 1、2 和 3 的结构可辨识性，例如 $\\texttt{[False,True,False]}$。",
            "solution": "用户提供的问题经评估有效。它在科学上基于传热原理，作为一个计算任务，其提法是适定的，并且其表述是客观的。所需计算的所有必要数据和定义均已提供。\n\n### 1. 理论框架\n\n该问题要求对顺流换热器模型的结构可辨识性进行评估。结构可辨识性关注的是，在给定的实验设计下，是否能从完美的、无噪声的测量中唯一确定模型的未知参数。所选方法是基于模型输出对参数的雅可比矩阵的局部灵敏度分析。\n\n#### 1.1. 模型方程\n\n该系统由一组关于热流体温度 $T_h(x)$ 和冷流体温度 $T_c(x)$ 沿轴向位置 $x$ 的耦合常微分方程（ODE）描述：\n$$\n\\frac{\\mathrm{d}T_h}{\\mathrm{d}x} = - \\frac{k}{s_h \\dot{m}_h c_{p,h}}\\,(T_h(x) - T_c(x))\n$$\n$$\n\\frac{\\mathrm{d}T_c}{\\mathrm{d}x} = + \\frac{k}{s_c \\dot{m}_c c_{p,c}}\\,(T_h(x) - T_c(x))\n$$\n这些方程表示在平推流假设下，忽略轴向导热和壁面动态学时，每个流体在微分控制体上的能量平衡。初始条件在入口 $x=0$ 处给出：\n$$\nT_h(0) = T_{h,\\mathrm{in}}, \\quad T_c(0) = T_{c,\\mathrm{in}}\n$$\n待辨识的参数为 $\\boldsymbol{\\theta} = [k, s_h, s_c]^\\top$，其中 $k$ 是单位长度的总传热系数，$s_h, s_c$ 是针对热、冷流体热容率的无量纲比例因子。对于给定的实验，测量输出是在 $x=L$ 处的出口温度：$\\mathbf{y} = [T_h(L), T_c(L)]^\\top$。\n\n#### 1.2. 参数化分析\n在进行数值方法之前，对模型的解析性检查揭示了一个关键属性。我们定义两个新的参数组，$p_1 = k/s_h$ 和 $p_2 = k/s_c$。控制方程可以重写为这些参数组的形式：\n$$\n\\frac{\\mathrm{d}T_h}{\\mathrm{d}x} = - \\frac{p_1}{\\dot{m}_h c_{p,h}}\\,(T_h(x) - T_c(x))\n$$\n$$\n\\frac{\\mathrm{d}T_c}{\\mathrm{d}x} = + \\frac{p_2}{\\dot{m}_c c_{p,c}}\\,(T_h(x) - T_c(x))\n$$\n该系统的解，以及因此的出口温度，仅取决于 $p_1$ 和 $p_2$ 的值，而不独立地取决于 $k, s_h, s_c$。从测量值中，最多只能确定 $p_1$ 和 $p_2$。然而，无法从这两个值中唯一地恢复出三个原始参数。对于任何解 $(k, s_h, s_c)$，对于任意标量 $\\lambda  0$，经过缩放的集合 $(\\lambda k, \\lambda s_h, \\lambda s_c)$ 会产生相同的 $p_1$ 和 $p_2$ 值，因此也会产生相同的可观测输出。这构成了结构不可辨识性。参数向量 $\\boldsymbol{\\theta}_0 = [k_0, s_{h0}, s_{c0}]^\\top$ 位于雅可比矩阵的零空间中，即 $\\mathbf{J}(\\boldsymbol{\\theta}_0) \\boldsymbol{\\theta}_0 = \\mathbf{0}$。因此，雅可比矩阵必须是秩亏的，其秩最多为 $2$。因此，我们预计所有测试案例都将得出不可辨识的结论（即秩小于 $3$）。\n\n### 2. 计算过程\n\n该问题规定了评估可辨识性的特定数值程序，我们现在将对此进行详细说明。\n\n#### 2.1. 模型的数值解\n该常微分方程系统采用数值方法求解。空间域 $x \\in [0, L]$ 被离散化为 $N$ 个长度为 $\\Delta x = L/N$ 的均匀段。使用显式欧拉法将解从 $x=0$ 推进到 $x=L$。对于从 $0$ 到 $N-1$ 的步长 $i$：\n$$\nT_{h,i+1} = T_{h,i} - \\Delta x \\left( \\frac{k}{s_h \\dot{m}_h c_{p,h}} \\right) (T_{h,i} - T_{c,i})\n$$\n$$\nT_{c,i+1} = T_{c,i} + \\Delta x \\left( \\frac{k}{s_c \\dot{m}_c c_{p,c}} \\right) (T_{h,i} - T_{c,i})\n$$\n从 $T_{h,0} = T_{h,\\mathrm{in}}$ 和 $T_{c,0} = T_{c,\\mathrm{in}}$ 开始，我们迭代 $N$ 次以获得出口温度 $T_{h,\\mathrm{out}} \\approx T_{h,N}$ 和 $T_{c,\\mathrm{out}} \\approx T_{c,N}$。选择一个足够大的 $N$ 值（例如，$N=1000$）以确保数值精度。\n\n#### 2.2. 雅可比矩阵近似\n对于一组 $E$ 个实验，模型输出是一个堆叠向量 $\\mathbf{y}(\\boldsymbol{\\theta}) \\in \\mathbb{R}^{2E}$，它串联了每个实验的出口温度。雅可比矩阵 $\\mathbf{J}(\\boldsymbol{\\theta}) = \\partial \\mathbf{y} / \\partial \\boldsymbol{\\theta}$ 是一个 $2E \\times 3$ 的矩阵，表示输出对每个参数的灵敏度。我们使用中心有限差分法在名义参数向量 $\\boldsymbol{\\theta}_0 = [k_0, s_{h0}, s_{c0}]^\\top$ 处近似 $\\mathbf{J}$。雅可比矩阵的第 $j$ 列由下式给出：\n$$\n\\mathbf{J}_{:,j} \\approx \\frac{\\mathbf{y}(\\boldsymbol{\\theta}_0 + \\delta_j \\mathbf{e}_j) - \\mathbf{y}(\\boldsymbol{\\theta}_0 - \\delta_j \\mathbf{e}_j)}{2\\delta_j}\n$$\n其中 $\\mathbf{e}_j$ 是第 $j$ 个标准基向量，$\\delta_j$ 是第 $j$ 个参数的小扰动（$\\delta_k, \\delta_{s_h}, \\delta_{s_c}$）。对于每个实验集，这需要对完整的输出向量 $\\mathbf{y}$ 进行 $2 \\times 3 = 6$ 次评估。\n\n#### 2.3. 数值秩计算\n结构可辨识性由雅可比矩阵 $\\mathbf{J}(\\boldsymbol{\\theta}_0)$ 的数值秩确定。秩通过奇异值分解（SVD）计算。$\\mathbf{J}$ 的 SVD 分解产生其奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_3 \\ge 0$。数值秩被认为是不可忽略的奇异值的数量。如果一个奇异值 $\\sigma_i$ 大于一个相对于最大奇异值 $\\sigma_{\\max} = \\sigma_1$ 定义的阈值 $\\tau$，则认为该奇异值是显著的：\n$$\n\\tau = \\epsilon \\, \\sigma_{\\max}\n$$\n其中按规定 $\\epsilon = 10^{-8}$。如果数值秩等于参数数量（即 $3$），则宣布该模型对于给定的实验集是结构可辨识的。否则，它是不可辨识的。此程序将应用于所提供的三个测试案例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the heat exchanger identifiability problem.\n    It defines problem constants, test cases, and runs the analysis for each.\n    \"\"\"\n\n    # --- Problem Constants and Specifications ---\n    L = 10.0  # m\n    C_P_H = 4180.0  # J/(kg.K)\n    C_P_C = 4180.0  # J/(kg.K)\n    N_STEPS = 1000  # Number of spatial discretization steps\n\n    # Nominal parameters theta_0 = [k, s_h, s_c]\n    k0 = 500.0  # W/(m.K)\n    s_h0 = 1.0\n    s_c0 = 1.0\n    theta_0 = np.array([k0, s_h0, s_c0])\n\n    # Finite difference perturbations\n    delta_k = 1e-4 * k0\n    delta_s_h = 1e-4 * s_h0\n    delta_s_c = 1e-4 * s_c0\n    deltas = np.array([delta_k, delta_s_h, delta_s_c])\n\n    # SVD rank threshold\n    SVD_EPSILON = 1e-8\n\n    # --- Test Cases ---\n    # Each test case is a list of experiments.\n    # Each experiment is a tuple: (m_dot_h, m_dot_c, T_h_in, T_c_in)\n    test_cases = [\n        # Test Case 1: Minimal information (1 experiment)\n        [\n            (1.0, 1.0, 360.0, 300.0)\n        ],\n        # Test Case 2: \"Well-designed\" set (3 experiments)\n        [\n            (0.8, 1.2, 360.0, 290.0),\n            (1.5, 0.7, 380.0, 310.0),\n            (1.0, 1.0, 350.0, 300.0)\n        ],\n        # Test Case 3: Redundant experiments (2 identical experiments)\n        [\n            (1.0, 1.0, 360.0, 300.0),\n            (1.0, 1.0, 360.0, 300.0)\n        ]\n    ]\n\n    def numerical_solver(params, exp_conditions):\n        \"\"\"\n        Solves the ODE system for a single experiment using the explicit Euler method.\n        \n        Args:\n            params (np.array): Parameter vector [k, s_h, s_c].\n            exp_conditions (tuple): Experimental conditions (m_dot_h, m_dot_c, T_h_in, T_c_in).\n\n        Returns:\n            tuple: Outlet temperatures (T_h_out, T_c_out).\n        \"\"\"\n        k, s_h, s_c = params\n        m_dot_h, m_dot_c, T_h_in, T_c_in = exp_conditions\n        \n        delta_x = L / N_STEPS\n        \n        cap_rate_h = m_dot_h * C_P_H\n        cap_rate_c = m_dot_c * C_P_C\n        \n        # Guard against division by zero if capacity rates or scale factors are zero\n        if cap_rate_h * s_h == 0 or cap_rate_c * s_c == 0:\n            return T_h_in, T_c_in\n\n        alpha_h = k / (s_h * cap_rate_h)\n        alpha_c = k / (s_c * cap_rate_c)\n\n        T_h = T_h_in\n        T_c = T_c_in\n\n        for _ in range(N_STEPS):\n            T_diff = T_h - T_c\n            dT_h = -alpha_h * T_diff * delta_x\n            dT_c = +alpha_c * T_diff * delta_x\n            T_h += dT_h\n            T_c += dT_c\n            \n        return T_h, T_c\n\n    def get_output_vector(params, experiment_set):\n        \"\"\"\n        Computes the stacked output vector y(theta) for a set of experiments.\n        \n        Args:\n            params (np.array): Parameter vector [k, s_h, s_c].\n            experiment_set (list): A list of experiment condition tuples.\n\n        Returns:\n            np.array: The stacked vector of all outlet temperatures.\n        \"\"\"\n        y_vec = []\n        for exp in experiment_set:\n            T_h_out, T_c_out = numerical_solver(params, exp)\n            y_vec.extend([T_h_out, T_c_out])\n        return np.array(y_vec)\n\n    def check_identifiability(experiment_set):\n        \"\"\"\n        Performs the structural identifiability analysis for a given set of experiments.\n        \n        Args:\n            experiment_set (list): A list of experiment condition tuples.\n\n        Returns:\n            bool: True if structurally identifiable, False otherwise.\n        \"\"\"\n        num_experiments = len(experiment_set)\n        num_outputs = 2 * num_experiments\n        num_params = len(theta_0)\n\n        J = np.zeros((num_outputs, num_params))\n\n        for j in range(num_params):\n            # Perturb parameter j\n            theta_plus = theta_0.copy()\n            theta_plus[j] += deltas[j]\n            \n            theta_minus = theta_0.copy()\n            theta_minus[j] -= deltas[j]\n            \n            # Compute output vectors for perturbed parameters\n            y_plus = get_output_vector(theta_plus, experiment_set)\n            y_minus = get_output_vector(theta_minus, experiment_set)\n            \n            # Central finite difference for Jacobian column\n            J[:, j] = (y_plus - y_minus) / (2 * deltas[j])\n\n        # Compute numerical rank via SVD\n        if J.shape[0] == 0: # Handle empty experiment set\n            return False\n            \n        try:\n            singular_values = np.linalg.svd(J, compute_uv=False)\n        except np.linalg.LinAlgError:\n            # In case of non-convergence, which is unlikely here\n            return False\n\n        if not singular_values.any():\n            return False\n\n        sigma_max = singular_values[0]\n        rank_threshold = SVD_EPSILON * sigma_max\n\n        numerical_rank = np.sum(singular_values > rank_threshold)\n        \n        return numerical_rank == num_params\n\n    # Run the analysis for each test case\n    results = [check_identifiability(case) for case in test_cases]\n\n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}