{
    "hands_on_practices": [
        {
            "introduction": "在着手编写任何代码或训练任何模型之前，最有效的步骤往往是简化问题本身。这个实践练习将向您展示如何运用量纲分析，特别是白金汉 $\\Pi$ 定理，来减少输入变量的数量。通过这种方式，可以使代理模型更高效、更易于训练，并能更好地泛化。我们将探讨如何为受热通道流动问题确定一个最小且完备的无量纲参数集合，以捕捉系统的核心物理特性 。",
            "id": "3988750",
            "problem": "一种具有恒定热物理性质的不可压缩牛顿流体稳定地流经一个高度为 $H$、宽度为 $W$ 的平面通道，其中 $W \\gg H$。流体动力学是充分发展的，并且两个壁面在轴向方向 $x$ 上都受到均匀的热通量 $q''$。通道长度为 $L$，主流平均速度为 $U$，入口主流平均温度为 $T_{\\mathrm{in}}$。浮力和热辐射可忽略不计，粘性耗散也可忽略不计。需要训练一个基于机器学习 (ML) 的代理模型，用于从可测量的输入中预测出口处的平均壁面温度 $T_w(L)$。\n\n从量纲齐次性和 Buckingham $\\Pi$ 定理出发，解释为什么对输入进行无量纲化可以减少 $T_w(L)$ 代理模型中的参数冗余，并构建一个最小的、物理上完备的无量纲数组，该数组应作为代理模型的输入，同时构建一个与 $T_w(L)$ 相关的、经过适当缩放的无量纲目标。特别地，考虑代理模型的输入可能包括 $q''$, $H$, $L$, $U$, $\\rho$, $\\mu$, $k$, $c_p$ 和 $T_{\\mathrm{in}}$，而输出是 $T_w(L)$。令 $T_b(L)$ 表示由沿通道的能量平衡确定的 $x=L$ 处的主流平均温度。\n\n对于该受热通道问题，哪个选项正确地陈述了减少冗余的原因，并提供了一组最小、非冗余、物理上合适的 $\\Pi$ 数群？\n\nA. 无量纲化减少了参数冗余，因为控制物理过程仅依赖于相似性数群；独立的无量纲数群数量等于 $n-k$，其中 $n$ 是变量的数量，$k$ 是基本量纲的数量。代理模型的一个最小集合是无量纲目标\n$$\\Pi_w \\;=\\; \\frac{k\\left[T_w(L)-T_b(L)\\right]}{q''\\,H},$$\n以及输入数群\n$$\\mathrm{Re} \\;=\\; \\frac{\\rho\\,U\\,H}{\\mu},\\quad \\mathrm{Pr} \\;=\\; \\frac{\\mu\\,c_p}{k},\\quad \\frac{L}{H}.$$\n\nB. 除非移除一个变量，否则无量纲化会增加变量的数量；减少量始终为 $n-1$，与基本量纲的数量无关。一个合适的集合是无量纲目标\n$$\\Pi_w \\;=\\; \\frac{T_w(L)}{T_{\\mathrm{in}}},$$\n输入为\n$$\\mathrm{Pe} \\;=\\; \\frac{\\rho\\,c_p\\,U\\,H}{k},\\quad \\mathrm{Re} \\;=\\; \\frac{\\rho\\,U\\,H}{\\mu},\\quad \\mathrm{Pr} \\;=\\; \\frac{\\mu\\,c_p}{k},\\quad \\frac{W}{H}.$$\n\nC. 只有在包含浮力时，无量纲化才能减少变量；对于当前流动，正确的数群必须包括重力效应。一个合适的集合是无量纲目标\n$$\\Pi_w \\;=\\; \\frac{q''\\,H}{k\\,T_w(L)},$$\n输入为\n$$\\mathrm{Gr} \\;=\\; \\frac{g\\,\\beta\\left[T_w(L)-T_{\\mathrm{in}}\\right]\\,H^3}{\\nu^2},\\quad \\mathrm{Pr} \\;=\\; \\frac{\\mu\\,c_p}{k},\\quad \\frac{L}{W}.$$\n\nD. 无量纲化减少了冗余，因为物理过程仅依赖于比率；正确的目标是\n$$\\Pi_w \\;=\\; \\frac{k\\left[T_w(L)-T_{\\mathrm{in}}\\right]}{q''\\,H},$$\n输入是\n$$\\mathrm{Re} \\;=\\; \\frac{\\rho\\,U\\,H}{\\mu},\\quad \\mathrm{Pr} \\;=\\; \\frac{\\mu\\,c_p}{k},\\quad \\frac{L}{H}.$$\n在这里，无论轴向加热如何，$T_{\\mathrm{in}}$ 都是 $x=L$ 处壁面传热的合适参考温度。",
            "solution": "用户希望我验证并解决一个关于应用量纲分析来指导热流体系统代理模型开发的问题。\n\n### 问题验证\n\n**步骤1：提取给定条件**\n\n问题描述了一个通过平面通道的稳定、不可压缩的牛顿流体流动。\n- **几何形状**：高度 $H$，宽度 $W$，长度 $L$。\n- **几何条件**：$W \\gg H$。\n- **流动条件**：流体动力学充分发展。\n- **热边界条件**：两个壁面都有均匀热通量 $q''$。\n- **流体性质（恒定）**：密度 $\\rho$，动力粘度 $\\mu$，热导率 $k$，比热容 $c_p$。\n- **流动/入口参数**：主流平均速度 $U$，入口主流平均温度 $T_{\\mathrm{in}}$。\n- **忽略的效应**：浮力、热辐射、粘性耗散。\n- **待预测量**：出口处的平均壁面温度 $T_w(L)$。\n- **代理模型的输入变量**：$q''$, $H$, $L$, $U$, $\\rho$, $\\mu$, $k$, $c_p$ 和 $T_{\\mathrm{in}}$。\n- **辅助定义**：$T_b(L)$ 是 $x=L$ 处的主流平均温度。\n- **任务**：使用量纲分析（Buckingham $\\Pi$ 定理）来解释参数冗余的减少，并为代理模型构建一个最小的、物理上完备的无量纲数组。\n\n**步骤2：使用提取的给定条件进行验证**\n\n- **科学性**：该问题描述了一个经典的强制对流传热场景。其物理过程由纳维-斯托克斯方程和热能方程控制。这些假设（不可压缩、性质恒定、忽略浮力等）是简化此类问题的标准做法，并且在其适用范围内是科学合理的。使用量纲分析来降低此类问题的复杂性是流体力学和传热学的基石。\n- **适定性**：该问题是适定的。给定输入，流动和温度场是唯一确定的，从而得到唯一的 $T_w(L)$ 值。目标是找到变量之间的函数关系，这是量纲分析的标准任务。\n- **客观性**：语言精确且技术性强。所有量都在工程学中有标准定义，清晰客观。\n- **完备性**：该问题提供了进行完整量纲分析所需的所有变量和条件。条件 $W \\gg H$ 恰当地将几何形状简化为两个无限大平行平板，使其成为一个二维问题。流体动力学和热边界条件已明确指定。\n- **一致性**：给定条件内部一致，没有矛盾。\n\n**步骤3：结论与行动**\n\n问题陈述是有效的。这是一个计算热工领域的标准且适定的问题，适合应用量纲分析。我将继续进行求解。\n\n### 求解推导\n\n目标是建立输出量 $T_w(L)$ 与九个输入变量（$q'', H, L, U, \\rho, \\mu, k, c_p, T_{\\mathrm{in}}$）之间的函数关系。方法是使用 Buckingham $\\Pi$ 定理进行量纲分析。\n\n首先，我们必须理解其底层物理。在内部对流传热中，区分决定流体主流平均温度升高的全局能量平衡和关联壁面温度与局部主流平均温度的局部传热至关重要。\n\n1.  **全局能量平衡**：在长度 $L$ 上加入流体的总热量率为 $Q_{total} = q'' \\times (\\text{受热表面积})$。对于高度为 $H$、宽度为 $W$ 的平面通道，若上下壁面均受热，则受热周长为 $2W$。受热面积为 $2WL$。流体的焓增率为 $\\dot{m} c_p [T_b(L) - T_{\\mathrm{in}}]$，其中质量流率为 $\\dot{m} = \\rho U A = \\rho U (WH)$。\n    令二者相等：\n    $$ q'' (2WL) = \\rho U (WH) c_p [T_b(L) - T_{\\mathrm{in}}] $$\n    求解出口处的主流温度 $T_b(L)$：\n    $$ T_b(L) = T_{\\mathrm{in}} + \\frac{2 q'' L}{\\rho U H c_p} $$\n    该方程表明 $T_b(L)$ 可以直接从输入参数计算得出。这是一个确定性的物理定律，不是代理模型需要学习的东西。\n\n2.  **局部传热**：出口（$x=L$）处的局部对流物理由传热系数 $h(L)$ 的定义描述：\n    $$ q'' = h(L) [T_w(L) - T_b(L)] $$\n    我们真正需要建模的量是传热系数 $h(L)$ 或其无量纲形式，即努塞尔数 $Nu_L$。努塞尔数使用特征长度定义，对于平面通道，通常是高度 $H$。\n    $$ Nu_L = \\frac{h(L) H}{k} $$\n    通道内强制对流的努塞尔数是流动状态、流体性质和几何构型的函数。这些由以下参数描述：\n    - **雷诺数**，$\\mathrm{Re} = \\frac{\\rho U H}{\\mu}$，代表惯性力与粘性力的比值。\n    - **普朗特数**，$\\mathrm{Pr} = \\frac{\\mu c_p}{k}$，是动量扩散率与热扩散率的比值。\n    - **无量纲轴向长度**，$L/H$，说明了热边界层的发展（入口效应）。\n\n    因此，努塞尔数的函数关系为：\n    $$ Nu_L = f\\left(\\mathrm{Re}, \\mathrm{Pr}, \\frac{L}{H}\\right) $$\n    代理模型应该被训练来学习这个函数 $f$。\n\n3.  **为代理模型构建无量纲数组**：\n    代理模型的输出是 $T_w(L)$。我们需要构建一个与 $T_w(L)$ 相关且是无量纲输入数组的函数的无量纲目标变量。基于局部传热物理，最物理上合适的建模量是温差 $T_w(L) - T_b(L)$。\n    从 $h(L)$ 和 $Nu_L$ 的定义出发：\n    $$ T_w(L) - T_b(L) = \\frac{q''}{h(L)} = \\frac{q'' H}{k \\cdot Nu_L} $$\n    我们可以重新整理这个式子，形成一个无量纲温度数群，这将是我们代理模型的目标变量：\n    $$ \\Pi_w = \\frac{k [T_w(L) - T_b(L)]}{q'' H} = \\frac{1}{Nu_L} $$\n    所以，代理模型将要逼近的完整物理关系是：\n    $$ \\Pi_w = \\frac{1}{f\\left(\\mathrm{Re}, \\mathrm{Pr}, \\frac{L}{H}\\right)} = g\\left(\\mathrm{Re}, \\mathrm{Pr}, \\frac{L}{H}\\right) $$\n    这个公式是理想的。代理模型的输入是由原始变量构成的最小、完备的无量纲数组（$\\mathrm{Re}, \\mathrm{Pr}, L/H$）。目标变量 $\\Pi_w$ 隔离了局部对流的物理过程。代理模型的总变量数从8个有量纲输入（$q'', H, L, U, \\rho, \\mu, k, c_p$）减少到3个无量纲输入。输入空间维度的降低是无量纲化的主要好处，因为它极大地减少了训练一个鲁棒模型所需的数据量。其背后的原理是 Buckingham $\\Pi$ 定理，该定理指出，任何涉及 $n$ 个变量和 $k$ 个基本量纲的物理上有意义的方程都可以重写为一个包含 $n-k$ 个无量纲参数的方程。\n\n4.  **基于机器学习的程序总结**：\n    - 给定原始输入（$q'', H, L, U, \\rho, \\mu, k, c_p, T_{\\mathrm{in}}$），首先计算代理模型的无量纲输入：$\\mathrm{Re} = \\frac{\\rho U H}{\\mu}$，$\\mathrm{Pr} = \\frac{\\mu c_p}{k}$ 和 $L/H$。\n    - 代理模型接收这3个输入并预测无量纲输出 $\\Pi_{w,pred} = g(\\mathrm{Re}, \\mathrm{Pr}, L/H)$。\n    - 根据能量平衡计算出口主流温度：$T_b(L) = T_{\\mathrm{in}} + \\frac{2 q'' L}{\\rho U H c_p}$。\n    - 重构最终的 $T_w(L)$ 的有量纲预测值：\n        $$ T_{w,pred}(L) = T_b(L) + \\Pi_{w,pred} \\frac{q'' H}{k} $$\n\n### 逐项分析\n\n**A. 无量纲化减少了参数冗余，因为控制物理过程仅依赖于相似性数群；独立的无量纲数群数量等于 $n-k$，其中 $n$ 是变量的数量，$k$ 是基本量纲的数量。代理模型的一个最小集合是无量纲目标\n$$\\Pi_w \\;=\\; \\frac{k\\left[T_w(L)-T_b(L)\\right]}{q''\\,H},$$\n以及输入数群\n$$\\mathrm{Re} \\;=\\; \\frac{\\rho\\,U\\,H}{\\mu},\\quad \\mathrm{Pr} \\;=\\; \\frac{\\mu\\,c_p}{k},\\quad \\frac{L}{H}.$$**\n- **理由**：提供的解释是正确的。它准确地陈述了动态相似性要求匹配无量纲数群，并正确引用了 Buckingham $\\Pi$ 定理来计算这些数群的数量。\n- **无量纲数组**：所提出的数组集合与我们的推导完全匹配。输入（$\\mathrm{Re}, \\mathrm{Pr}, L/H$）构成了一个描述问题物理的最小完备集合。目标数群（$\\Pi_w = 1/Nu_L$）是物理上最合适的选择，因为它隔离了局部对流现象，这正是代理模型应该学习的。问题明确引入了 $T_b(L)$，暗示应该用它来构建最相关的温差。\n- **结论**：**正确**。\n\n**B. 除非移除一个变量，否则无量纲化会增加变量的数量；减少量始终为 $n-1$，与基本量纲的数量无关。一个合适的集合是无量纲目标\n$$\\Pi_w \\;=\\; \\frac{T_w(L)}{T_{\\mathrm{in}}},$$\n输入为\n$$\\mathrm{Pe} \\;=\\; \\frac{\\rho\\,c_p\\,U\\,H}{k},\\quad \\mathrm{Re} \\;=\\; \\frac{\\rho\\,U\\,H}{\\mu},\\quad \\mathrm{Pr} \\;=\\; \\frac{\\mu\\,c_p}{k},\\quad \\frac{W}{H}.$$**\n- **理由**：无量纲化*增加*变量数量的说法是错误的。减少量总是 $n-1$ 的说法也是错误的；它取决于基本量纲的数量 $k$，从而得到 $n-k$ 个数群。\n- **无量纲数组**：目标数群 $\\Pi_w = T_w(L)/T_{\\mathrm{in}}$ 的选择很差，因为对流物理依赖于温差，而这个比值对温度标尺的零点选择很敏感（例如，摄氏度与开尔文）。输入集合 $\\{\\mathrm{Pe}, \\mathrm{Re}, \\mathrm{Pr}\\}$ 是冗余的，因为 $\\mathrm{Pe} = \\mathrm{Re} \\cdot \\mathrm{Pr}$。一个最小集合应该只包括这三者中的两个。鉴于问题陈述 $W \\gg H$，数群 $W/H$ 是不相关的。\n- **结论**：**不正确**。\n\n**C. 只有在包含浮力时，无量纲化才能减少变量；对于当前流动，正确的数群必须包括重力效应。一个合适的集合是无量纲目标\n$$\\Pi_w \\;=\\; \\frac{q''\\,H}{k\\,T_w(L)},$$\n输入为\n$$\\mathrm{Gr} \\;=\\; \\frac{g\\,\\beta\\left[T_w(L)-T_{\\mathrm{in}}\\right]\\,H^3}{\\nu^2},\\quad \\mathrm{Pr} \\;=\\; \\frac{\\mu\\,c_p}{k},\\quad \\frac{L}{W}.$$**\n- **理由**：无量纲化只有在包含浮力时才有用的说法是错误的。该技术是普遍适用的。\n- **无量纲数组**：问题明确说明浮力可以忽略，所以包含格拉晓夫数（$\\mathrm{Gr}$）是错误的。目标数群 $\\Pi_w = \\frac{q'' H}{k T_w(L)}$ 的选择很差，因为它涉及绝对温度。几何比率 $L/W$ 不是此问题的相关长宽比；$L/H$ 才是。\n- **结论**：**不正确**。\n\n**D. 无量纲化减少了冗余，因为物理过程仅依赖于比率；正确的目标是\n$$\\Pi_w \\;=\\; \\frac{k\\left[T_w(L)-T_{\\mathrm{in}}\\right]}{q''\\,H},$$\n输入是\n$$\\mathrm{Re} \\;=\\; \\frac{\\rho\\,U\\,H}{\\mu},\\quad \\mathrm{Pr} \\;=\\; \\frac{\\mu\\,c_p}{k},\\quad \\frac{L}{H}.$$\n在这里，无论轴向加热如何，$T_{\\mathrm{in}}$ 都是 $x=L$ 处壁面传热的合适参考温度。**\n- **理由**：“仅依赖于比率”的解释与选项A中更严谨的陈述相比不够精确。\n- **无量纲数组**：输入集合是正确的。目标数群 $\\Pi_w = \\frac{k[T_w(L)-T_{\\mathrm{in}}]}{q'' H}$ 是一个有效的无量纲量。然而，“$T_{\\mathrm{in}}$ 是 $x=L$ 处壁面传热的合适参考温度”的说法在物理上是值得商榷的。$x=L$ 处的局部传热是由温差 $T_w(L) - T_b(L)$ 驱动的，而不是 $T_w(L) - T_{\\mathrm{in}}$。使用 $T_{\\mathrm{in}}$ 将局部对流物理与全局轴向加热效应混合在一起，使其成为一个不如使用 $T_b(L)$ 基础和“合适”的选择。选项A的选择在物理上更优，因为它隔离了对流模型所关注的量（$Nu_L$）。\n- **结论**：**不正确**。虽然提出的数组在数学上是有效的，但对目标数群的论证在物理上很薄弱，使其不如选项A中的集合合适。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "本练习将引导您完成构建一个经典代理模型的完整工作流程。我们将从一个一维翅片的物理模型出发，生成训练数据，接着实现一个径向基函数（RBF）插值器，并利用留一法交叉验证（LOOCV）来调整其关键的超参数 $\\varepsilon$。通过这个练习，您将获得使用一种强大且广泛应用的技术，将物理参数映射到系统响应（如峰值温度）的具体实践经验 。",
            "id": "3988771",
            "problem": "你的任务是使用径向基函数（RBF）构建一个代理模型，以近似一个直细翅片中从热导率 $k$ 和体积热生成率 $q$ 到峰值温度的映射。该翅片在其侧表面和尖端受到对流作用。该物理系统是一个长度为 $L$ 的一维翅片，具有恒定的横截面积 $A$ 和周长 $P$，由具有恒定热导率 $k$ 和均匀内部体积热生成率 $q$ 的均匀材料制成。周围流体的环境温度均匀为 $T_{\\infty}$，沿侧表面的对流换热系数为 $h$，尖端的对流换热系数为 $h_{t}$。位于 $x=0$ 位置的翅片基部保持在恒定温度 $T_{b}$。翅片的控制性一维稳态能量平衡可以从能量守恒和傅里叶热传导定律推导得出，从而得到关于温度场 $T(x)$ 的线性二阶微分方程，并在基部和尖端附有适当的边界条件。峰值温度定义为 $\\max_{x \\in [0,L]} T(x)$。\n\n使用以下常数和单位：\n- 翅片长度 $L$ 等于 $0.05$ 米。\n- 横截面积 $A$ 等于 $1\\times 10^{-4}$ 平方米。\n- 周长 $P$ 等于 $0.04$ 米。\n- 侧表面对流系数 $h$ 等于 $50$ 瓦特/平方米-开尔文。\n- 尖端对流系数 $h_{t}$ 等于 $50$ 瓦特/平方米-开尔文。\n- 基部温度 $T_{b}$ 等于 $350$ 开尔文。\n- 环境温度 $T_{\\infty}$ 等于 $300$ 开尔文。\n\n所有温度必须以开尔文表示。如果在数学操作中出现任何角度，必须以弧度表示。\n\n从第一性原理出发，程序必须：\n1. 实现一个函数，该函数通过求解稳态能量守恒所隐含的一维翅片边值问题，返回给定输入 $(k,q)$ 的峰值温度 $\\max_{x \\in [0,L]} T(x)$。该问题中包含沿周长和尖端的对流。该方法应仅使用上述基本定义和边界条件，从控制方程和边界条件进行算法推导，而不调用或假设任何预先提供的公式。\n2. 通过组合集合 $k \\in \\{20,60,120,200\\}$ 瓦特/米-开尔文 和 $q \\in \\{0,2.5\\times 10^{5},5.0\\times 10^{5},1.0\\times 10^{6}\\}$ 瓦特/立方米 中的所有配对，生成一个大小为 $N$ 等于 $16$ 的训练数据集。对于每个配对，使用第1项中的函数计算相应的峰值温度。\n3. 使用高斯核 $\\phi(r) = \\exp\\!\\big(-(\\varepsilon\\, r)^{2}\\big)$ 构建一个 RBF 代理模型，其中 $r$ 是 $(k,q)$ 空间中的欧几里得距离，$\\varepsilon$ 是正形状参数。在计算距离之前，通过减去从训练数据集中计算出的样本均值并除以样本标准差，对每个输入特征 $k$ 和 $q$ 进行标准化。通过求解 RBF 权重的线性系统来构建插值器，以使代理模型在训练点处与训练值完全匹配。\n4. 使用留一法交叉验证（LOOCV）从候选集 $\\{0.2,0.5,1.0,2.0,3.0,5.0,10.0\\}$ 中选择形状参数 $\\varepsilon$。对于每个候选 $\\varepsilon$，计算在 $N$ 等于 $16$ 个训练点上的均方 LOOCV 误差，并选择使该误差最小的 $\\varepsilon$。\n5. 使用所选的形状参数，在以下五个 $(k,q)$ 测试案例中评估代理模型：\n   - 案例 1：$k$ 等于 $120$， $q$ 等于 $5.0\\times 10^{5}$。\n   - 案例 2：$k$ 等于 $80$， $q$ 等于 $0$。\n   - 案例 3：$k$ 等于 $20$， $q$ 等于 $1.0\\times 10^{6}$。\n   - 案例 4：$k$ 等于 $200$， $q$ 等于 $1.0\\times 10^{6}$。\n   - 案例 5：$k$ 等于 $60$， $q$ 等于 $2.5\\times 10^{5}$。\n   报告这些案例的代理模型预测的峰值温度，单位为开尔文。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，具体为：$[\\varepsilon_{\\text{opt}},T_{1},T_{2},T_{3},T_{4},T_{5}]$，其中 $\\varepsilon_{\\text{opt}}$ 是所选的形状参数（无单位），$T_{i}$ 是上述测试案例按顺序排列的代理模型预测的峰值温度（单位为开尔文）。输出中的所有数值条目必须是浮点数。",
            "solution": "该问题要求构建和验证一个径向基函数（RBF）代理模型，用以预测一维翅片中的峰值温度。该过程包括几个步骤：推导翅片温度分布的解析解，使用该解析解生成训练数据集，使用留一法交叉验证（LOOCV）优化RBF形状参数，最后，对一组测试案例预测峰值温度。\n\n### 步骤 1：翅片温度的解析模型\n\n第一步是推导沿翅片的温度分布 $T(x)$。我们考虑在翅片上位置 $x$ 处一个长度为 $dx$ 的微分单元上的一维稳态能量平衡。该翅片具有恒定的横截面积 $A$、周长 $P$ 和热导率 $k$。它与温度为 $T_{\\infty}$ 的环境流体进行对流换热，换热系数为 $h$，并具有均匀的体积热生成率 $q$。\n\n能量平衡方程为：\n$$q_{cond, x} + q_{gen} = q_{cond, x+dx} + q_{conv}$$\n使用傅里叶热传导定律 $q_{cond} = -kA \\frac{dT}{dx}$，牛顿冷却定律进行对流换热 $q_{conv} = h(Pdx)(T-T_{\\infty})$，并考虑内部热生成 $q_{gen} = q(Adx)$，我们得到：\n$$-kA \\frac{dT}{dx}\\bigg|_x + qAdx = -kA \\frac{dT}{dx}\\bigg|_{x+dx} + hP(T(x)-T_{\\infty})dx$$\n使用泰勒级数展开在 $x+dx$ 处的项并简化，我们得到控制性二阶常微分方程（ODE）：\n$$k \\frac{d^2T}{dx^2} - \\frac{hP}{A}(T-T_{\\infty}) + q = 0$$\n为了简化，我们引入过余温度 $\\theta(x) = T(x) - T_{\\infty}$。ODE 变为：\n$$\\frac{d^2\\theta}{dx^2} - m^2\\theta = -S$$\n其中 $m = \\sqrt{\\frac{hP}{kA}}$ 是翅片参数，$S = \\frac{q}{k}$ 与源项有关。\n\n这是一个线性、非齐次、二阶常微分方程。通解是齐次解 $\\theta_h(x)$ 和一个特解 $\\theta_p(x)$ 的和。齐次方程 $\\theta'' - m^2\\theta=0$ 的解为 $\\theta_h(x) = C_1 \\cosh(mx) + C_2 \\sinh(mx)$。对于常数源项 $-S$，假设一个常数特解 $\\theta_p(x) = C$。代入 ODE 得到 $-m^2C = -S$，所以 $C = \\frac{S}{m^2} = \\frac{q/k}{hP/kA} = \\frac{qA}{hP}$。我们用 $\\theta_s = \\frac{qA}{hP}$ 表示该项。\n\n过余温度的通解为：\n$$\\theta(x) = C_1 \\cosh(mx) + C_2 \\sinh(mx) + \\theta_s$$\n常数 $C_1$ 和 $C_2$ 由边界条件确定。\n\n**边界条件：**\n1. 在翅片基部（$x=0$）：温度固定为 $T_b$。\n    $$T(0) = T_b \\implies \\theta(0) = T_b - T_{\\infty} \\equiv \\theta_b$$\n    应用此条件，我们得到 $\\theta_b = C_1 \\cosh(0) + C_2 \\sinh(0) + \\theta_s = C_1 + \\theta_s$。\n    因此，$C_1 = \\theta_b - \\theta_s$。\n\n2. 在翅片尖端（$x=L$）：发生对流，系数为 $h_t$。尖端的能量平衡要求传入尖端的传导热量等于从尖端表面散失的对流热量。\n    $$-kA\\frac{dT}{dx}\\bigg|_{x=L} = h_t A (T(L)-T_{\\infty})$$\n    用 $\\theta$ 表示，即 $-k\\frac{d\\theta}{dx}\\bigg|_{x=L} = h_t \\theta(L)$。\n    导数为 $\\frac{d\\theta}{dx} = mC_1 \\sinh(mx) + mC_2 \\cosh(mx)$。在 $x=L$ 处求值并代入边界条件，得到：\n    $$-k(mC_1 \\sinh(mL) + mC_2 \\cosh(mL)) = h_t(C_1 \\cosh(mL) + C_2 \\sinh(mL) + \\theta_s)$$\n    整理以求解 $C_2$：\n    $$C_2 (h_t \\sinh(mL) + km \\cosh(mL)) = -C_1(h_t \\cosh(mL) + km \\sinh(mL)) - h_t \\theta_s$$\n    $$C_2 = -\\frac{C_1(h_t \\cosh(mL) + km \\sinh(mL)) + h_t \\theta_s}{h_t \\sinh(mL) + km \\cosh(mL)}$$\n利用已知的参数 $(k, q)$，我们可以计算出 $m$、$\\theta_s$、$C_1$ 和 $C_2$，从而完全确定温度分布 $T(x) = T_{\\infty} + \\theta(x)$。\n\n### 步骤 2：峰值温度计算\n\n峰值温度为 $\\max_{x \\in [0,L]} T(x)$。最大值可能出现在边界（$x=0$ 或 $x=L$）或内部点 $x_c \\in (0,L)$，在该点 $\\frac{dT}{dx}(x_c) = \\frac{d\\theta}{dx}(x_c) = 0$。\n内部极值的条件是：\n$$mC_1 \\sinh(mx_c) + mC_2 \\cosh(mx_c) = 0 \\implies \\tanh(mx_c) = -\\frac{C_2}{C_1}$$\n当且仅当 $|-C_2/C_1|  1$ 时，存在 $x_c$ 的实数解。如果 $\\frac{d^2\\theta}{dx^2}(x_c)  0$，则该极值为最大值。可以证明，只有当 $C_1  0$ 时，此条件才成立。\n对于给定的问题参数，$C_1 = \\theta_b - \\theta_s = (T_b - T_{\\infty}) - \\frac{qA}{hP} = 50 - q(5 \\times 10^{-5})$。为了可能存在内部最大值（$C_1  0$），我们需要 $q > 1 \\times 10^6$ W/m$^3$。由于数据集中的最大 $q$ 值为 $1 \\times 10^6$ W/m$^3$（此时 $C_1=0$），而对于所有其他情况，$q  1 \\times 10^6$ W/m$^3$（此时 $C_1 > 0$），因此在任何指定场景下都不会出现内部最大值。\n因此，峰值温度必须出现在定义域的边界处。峰值温度由下式给出：\n$$T_{peak} = \\max(T(0), T(L)) = \\max(T_b, T(L))$$\n其中 $T(L) = T_{\\infty} + C_1 \\cosh(mL) + C_2 \\sinh(mL) + \\theta_s$。这提供了一个确定性函数，用于计算任何输入对 $(k, q)$ 的峰值温度。\n\n### 步骤 3：RBF 代理模型\n\n我们构建一个 RBF 代理模型来近似映射 $(k, q) \\mapsto T_{peak}$。\n\n**训练数据：** 通过取 $k \\in \\{20,60,120,200\\}$ 和 $q \\in \\{0,2.5\\times 10^{5},5.0\\times 10^{5},1.0\\times 10^{6}\\}$ 的所有组合，生成一个包含 $N=16$ 个点的训练集。对于每一对 $(k_i, q_i)$，使用解析模型计算相应的峰值温度 $y_i = T_{peak}(k_i, q_i)$。\n\n**特征标准化：** 输入特征 $(k, q)$ 被标准化为零均值和单位方差。从 16 个训练点计算样本均值 $(\\mu_k, \\mu_q)$ 和标准差 $(\\sigma_k, \\sigma_q)$。一个标准化的输入是 $\\mathbf{x}'_i = (k'_i, q'_i)$，其中 $k'_i = (k_i - \\mu_k)/\\sigma_k$ 和 $q'_i = (q_i - \\mu_q)/\\sigma_q$。\n\n**RBF 插值：** RBF 代理模型具有形式 $f(\\mathbf{x}') = \\sum_{j=1}^{N} w_j \\phi(\\|\\mathbf{x}' - \\mathbf{x}'_j\\|)$，其中 $\\mathbf{x}'_j$ 是标准化的训练输入，$w_j$ 是权重，$\\phi(r)$ 是高斯核 $\\phi(r) = \\exp(-(\\varepsilon r)^2)$。距离 $r$ 是标准化空间中的欧几里得距离。权重 $\\mathbf{w} = [w_1, \\dots, w_N]^T$ 通过求解线性系统 $\\mathbf{\\Phi}\\mathbf{w} = \\mathbf{y}$ 来找到，其中 $\\mathbf{y} = [y_1, \\dots, y_N]^T$ 是训练输出的向量，$\\mathbf{\\Phi}$ 是 $N \\times N$ 的插值矩阵，其元素为 $\\Phi_{ij} = \\phi(\\|\\mathbf{x}'_i - \\mathbf{x}'_j\\|)$。\n\n### 步骤 4：通过 LOOCV 进行形状参数优化\n\n形状参数 $\\varepsilon$ 从集合 $\\{0.2,0.5,1.0,2.0,3.0,5.0,10.0\\}$ 中通过最小化 LOOCV 的均方误差来选择。对于给定的 $\\varepsilon$，第 $i$ 个点的 LOOCV 预测误差可以高效计算，而无需重新训练模型 $N$ 次。该误差由下式给出：\n$$e_i = y_i - f_{(-i)}(\\mathbf{x}_i) = \\frac{w_i}{(\\mathbf{\\Phi}^{-1})_{ii}}$$\n其中 $f_{(-i)}$ 是在除点 $i$ 外的所有数据上训练的模型，$\\mathbf{w} = \\mathbf{\\Phi}^{-1}\\mathbf{y}$，$(\\mathbf{\\Phi}^{-1})_{ii}$ 是插值矩阵逆的第 $i$ 个对角元素。均方 LOOCV 误差为 $MSE_{LOOCV} = \\frac{1}{N}\\sum_{i=1}^N e_i^2$。我们为每个候选 $\\varepsilon$ 计算此值，并选择产生最小 $MSE_{LOOCV}$ 的那个。\n\n### 步骤 5：预测\n\n使用最优形状参数 $\\varepsilon_{opt}$，使用所有 $N=16$ 个训练点构建最终的 RBF 模型。确定最终的权重 $\\mathbf{w}_{final}$。为了预测新测试点 $(k_{test}, q_{test})$ 的峰值温度，首先使用训练集的 $\\mu_k, \\sigma_k, \\mu_q, \\sigma_q$ 对该点进行标准化，得到 $\\mathbf{x}'_{test}$。然后按如下方式计算预测值：\n$$T_{pred} = f(\\mathbf{x}'_{test}) = \\sum_{j=1}^{N} w_{final, j} \\exp\\left(-(\\varepsilon_{opt} \\|\\mathbf{x}'_{test} - \\mathbf{x}'_j\\|)^2\\right)$$\n此过程应用于五个指定的测试案例。对于同时也是训练点的测试案例，RBF 插值器将精确地再现由解析模型计算出的值，这是该方法的一个关键特性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and evaluates an RBF surrogate model for fin peak temperature.\n    \"\"\"\n    # Physical constants\n    L = 0.05       # Fin length (m)\n    A = 1.0e-4     # Cross-sectional area (m^2)\n    P = 0.04       # Perimeter (m)\n    h = 50.0       # Convection coefficient (W/m^2-K)\n    h_t = 50.0     # Tip convection coefficient (W/m^2-K)\n    T_b = 350.0    # Base temperature (K)\n    T_inf = 300.0  # Ambient temperature (K)\n    theta_b = T_b - T_inf\n\n    def get_peak_temperature(k, q):\n        \"\"\"\n        Calculates the peak temperature of the fin for given k and q.\n        \"\"\"\n        # Handle k=0 case to avoid division by zero\n        if k == 0:\n            return np.nan\n\n        # Calculate intermediate parameters\n        m_squared = (h * P) / (k * A)\n        m = np.sqrt(m_squared)\n        theta_s = (q * A) / (h * P)\n\n        # Determine integration constants C1 and C2\n        C1 = theta_b - theta_s\n\n        # Avoid issues with large mL by using np.exp\n        mL = m * L\n        cosh_mL = np.cosh(mL)\n        sinh_mL = np.sinh(mL)\n\n        # Numerator and denominator for C2 calculation\n        num_C2 = -C1 * (h_t * cosh_mL + k * m * sinh_mL) - h_t * theta_s\n        den_C2 = h_t * sinh_mL + k * m * cosh_mL\n        C2 = num_C2 / den_C2\n\n        # The analytical solution indicates that for the given q range,\n        # no interior maximum exists. The peak is at the boundary.\n        # So, we only need to check T(L).\n\n        # Temperature at the tip (x=L)\n        theta_L = C1 * cosh_mL + C2 * sinh_mL + theta_s\n        T_L = T_inf + theta_L\n\n        # Peak temperature is max of base and tip temperatures\n        return max(T_b, T_L)\n\n    # 1. Generate training dataset\n    k_vals = np.array([20.0, 60.0, 120.0, 200.0])\n    q_vals = np.array([0.0, 2.5e5, 5.0e5, 1.0e6])\n    N = len(k_vals) * len(q_vals)\n\n    X_train = np.array(np.meshgrid(k_vals, q_vals)).T.reshape(-1, 2)\n    y_train = np.array([get_peak_temperature(k, q) for k, q in X_train])\n\n    # 2. Standardize input features\n    mu = np.mean(X_train, axis=0)\n    sigma = np.std(X_train, axis=0)\n    X_train_std = (X_train - mu) / sigma\n\n    # 3. Select shape parameter epsilon via LOOCV\n    epsilons = [0.2, 0.5, 1.0, 2.0, 3.0, 5.0, 10.0]\n    best_eps = None\n    min_mse = float('inf')\n\n    # Distance matrix for standardized training points\n    dist_matrix = np.sqrt(((X_train_std[:, np.newaxis, :] - X_train_std[np.newaxis, :, :])**2).sum(axis=2))\n    \n    for eps in epsilons:\n        # Construct interpolation matrix Phi\n        Phi = np.exp(-(eps * dist_matrix)**2)\n\n        # Solve for weights and calculate LOOCV error\n        try:\n            # Using solve is more stable but inv is needed for the efficient LOOCV formula\n            inv_Phi = np.linalg.inv(Phi)\n            weights = inv_Phi @ y_train\n            loocv_errors = weights / np.diag(inv_Phi)\n            mse = np.mean(loocv_errors**2)\n\n            if mse  min_mse:\n                min_mse = mse\n                best_eps = eps\n        except np.linalg.LinAlgError:\n            # In case of singularity, skip this epsilon\n            continue\n    \n    eps_opt = best_eps\n\n    # 4. Build final RBF model with optimal epsilon\n    final_dist_matrix = np.sqrt(((X_train_std[:, np.newaxis, :] - X_train_std[np.newaxis, :, :])**2).sum(axis=2))\n    final_Phi = np.exp(-(eps_opt * final_dist_matrix)**2)\n    final_weights = np.linalg.solve(final_Phi, y_train)\n\n    # 5. Evaluate surrogate at test cases\n    test_cases = [\n        (120.0, 5.0e5),\n        (80.0, 0.0),\n        (20.0, 1.0e6),\n        (200.0, 1.0e6),\n        (60.0, 2.5e5),\n    ]\n    \n    test_predictions = []\n    for k_test, q_test in test_cases:\n        x_test = np.array([k_test, q_test])\n        x_test_std = (x_test - mu) / sigma\n        \n        # Calculate distances from test point to all training points\n        dists = np.sqrt(np.sum((X_train_std - x_test_std)**2, axis=1))\n        \n        # Calculate kernel values\n        kernel_vals = np.exp(-(eps_opt * dists)**2)\n        \n        # Make prediction\n        T_pred = np.sum(final_weights * kernel_vals)\n        test_predictions.append(T_pred)\n\n    # Format the final output\n    results = [eps_opt] + test_predictions\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在物理系统的机器学习应用中，一个核心挑战是确保模型的预测遵循基本的物理定律。最后的这个实践练习介绍了一种验证已训练代理模型物理一致性的方法：数值单调性检验。我们将通过实现中心差分法来计算模型输出对输入的梯度，并检验其符号是否符合物理预期。这是在“黑箱”模型中建立信任、确保其预测具有物理意义的关键一步 。",
            "id": "3988673",
            "problem": "给定一个预先训练好的代理函数，它将热物理参数的输入向量映射到预测的单位面积稳态导热通量。将该代理函数表示为 $\\hat{q}:\\mathbb{R}^6\\rightarrow\\mathbb{R}$，其输入向量为 $\\mathbf{x}=\\left(T_h,T_c,L_1,k_1,L_2,k_2\\right)$，其中 $T_h$ 是热侧温度（单位为 $\\mathrm{K}$），$T_c$ 是冷侧温度（单位为 $\\mathrm{K}$），$L_1$ 和 $L_2$ 是层厚度（单位为 $\\mathrm{m}$），$k_1$ 和 $k_2$ 是热导率（单位为 $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$）。基于傅里叶热传导定律和串联热阻的结构，物理上一致的单调性期望为：\n- $\\frac{\\partial \\hat{q}}{\\partial T_h}\\ge 0$，\n- $\\frac{\\partial \\hat{q}}{\\partial T_c}\\le 0$，\n- $\\frac{\\partial \\hat{q}}{\\partial L_1}\\le 0$，\n- $\\frac{\\partial \\hat{q}}{\\partial k_1}\\ge 0$,\n- $\\frac{\\partial \\hat{q}}{\\partial L_2}\\le 0$,\n- $\\frac{\\partial \\hat{q}}{\\partial k_2}\\ge 0$。\n\n您的任务是通过中心有限差分计算经验梯度，并对采样输入验证符号约束，从而为训练好的代理输出实现一个数值单调性测试。使用在 $\\mathbf{x}$ 处的第 $j$ 个偏导数的中心有限差分近似：\n$$\n\\frac{\\partial \\hat{q}}{\\partial x_j}(\\mathbf{x})\\approx \\frac{\\hat{q}\\!\\left(\\mathbf{x}+h_j\\mathbf{e}_j\\right)-\\hat{q}\\!\\left(\\mathbf{x}-h_j\\mathbf{e}_j\\right)}{2h_j},\n$$\n其中 $\\mathbf{e}_j$ 是第 $j$ 个坐标单位向量，$h_j0$ 是 $x_j$ 的扰动大小。根据 $h_j=\\max\\!\\left(\\epsilon_j, s\\,|x_j|\\right)$ 来选择 $h_j$，其中 $s$ 是一个无量纲步长分数，$\\epsilon_j$ 是一个变量特定的最小步长，用于限制舍入敏感性。使用以下最小步长：$\\epsilon_{T_h}=\\epsilon_{T_c}=10^{-6}\\,\\mathrm{K}$，$\\epsilon_{L_1}=\\epsilon_{L_2}=10^{-9}\\,\\mathrm{m}$，以及 $\\epsilon_{k_1}=\\epsilon_{k_2}=10^{-9}\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$。如果符号约束在绝对容差 $\\tau0$ 内成立，则认为其得到满足，即对于期望的非负导数，接受 $\\frac{\\partial \\hat{q}}{\\partial x_j}\\ge -\\tau$；对于期望的非正导数，接受 $\\frac{\\partial \\hat{q}}{\\partial x_j}\\le \\tau$。\n\n输入采样应在指定的物理上合理的范围内进行独立同分布 (i.i.d.) 的均匀采样。对于下面的每个测试用例，在其域内抽取 $N$ 个样本 $\\mathbf{x}^{(i)}$，计算经验梯度，并在每个样本处验证所有六个符号约束。当且仅当所有 $N$ 个样本的所有六个约束都得到满足时，测试用例才算通过。\n\n所有温度以 $\\mathrm{K}$ 为单位，长度以 $\\mathrm{m}$ 为单位，热导率以 $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$ 为单位，代理热通量以 $\\mathrm{W}\\,\\mathrm{m}^{-2}$ 为单位。此问题不涉及角度。最终的程序输出必须是一行，包含一个用方括号括起来的逗号分隔列表，每个测试用例对应一个布尔值，表示通过或失败，顺序如下所示，例如 $\\left[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True}\\right]$。\n\n使用以下测试套件，其设计旨在覆盖典型条件、边界区域和近简并情况：\n\n- 测试用例 $1$（典型建筑围护结构体系）：\n  - $N=200$, $s=10^{-4}$, $\\tau=10^{-9}$。\n  - 范围：$T_h\\in[310,350]\\,\\mathrm{K}$， $T_c\\in[280,300]\\,\\mathrm{K}$， $L_1\\in[0.01,0.05]\\,\\mathrm{m}$， $k_1\\in[0.2,0.8]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$， $L_2\\in[0.01,0.05]\\,\\mathrm{m}$， $k_2\\in[10,50]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$。\n  - 随机种子：$12345$。\n\n- 测试用例 $2$（接近极限的薄高导热层）：\n  - $N=200$, $s=10^{-6}$, $\\tau=10^{-9}$。\n  - 范围：$T_h\\in[330,360]\\,\\mathrm{K}$， $T_c\\in[290,300]\\,\\mathrm{K}$， $L_1\\in[10^{-4},10^{-3}]\\,\\mathrm{m}$， $k_1\\in[100,400]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$， $L_2\\in[10^{-4},10^{-3}]\\,\\mathrm{m}$， $k_2\\in[100,400]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$。\n  - 随机种子：$54321$。\n\n- 测试用例 $3$（驱动温差小的近等温边界）：\n  - $N=200$, $s=10^{-4}$, $\\tau=10^{-9}$。\n  - 范围：$T_h\\in[300.1,300.5]\\,\\mathrm{K}$， $T_c\\in[299.6,300.0]\\,\\mathrm{K}$， $L_1\\in[0.01,0.02]\\,\\mathrm{m}$， $k_1\\in[0.2,0.5]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$， $L_2\\in[0.01,0.02]\\,\\mathrm{m}$， $k_2\\in[5,10]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$。\n  - 随机种子：$11111$。\n\n- 测试用例 $4$（低导热率层主导总热阻）：\n  - $N=200$, $s=10^{-4}$, $\\tau=10^{-9}$。\n  - 范围：$T_h\\in[315,335]\\,\\mathrm{K}$， $T_c\\in[285,295]\\,\\mathrm{K}$， $L_1\\in[0.02,0.04]\\,\\mathrm{m}$， $k_1\\in[0.02,0.05]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$， $L_2\\in[0.01,0.03]\\,\\mathrm{m}$， $k_2\\in[0.5,1.5]\\,\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$。\n  - 随机种子：$22222$。\n\n您的程序必须为每个测试用例实现经验梯度计算和对采样输入的单调性验证，并按照上述描述，以 $\\left[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4\\right]$ 的精确单行格式生成最终的布尔结果。",
            "solution": "此问题是有效的。它在计算热工学领域，特别是在代理模型的验证与确认方面，提出了一个清晰、有科学依据且适定的任务。问题的核心是实现一个数值程序，以测试一个模拟稳态热通量的代理函数 $\\hat{q}$ 的物理单调性。\n\n尽管问题陈述中提到了一个“预先训练好的代理函数”$\\hat{q}$，但没有提供其显式形式，唯一合乎逻辑且可解的解释是为任何有效代理模型都必须近似的底层物理模型实现该测试。该问题涉及通过串联双层的一维稳态热传导。根据傅里叶定律推导出的单位面积热通量 $q$ 的解析解为：\n$$q(\\mathbf{x}) = \\frac{T_h - T_c}{\\frac{L_1}{k_1} + \\frac{L_2}{k_2}}$$\n其中输入向量为 $\\mathbf{x}=\\left(T_h,T_c,L_1,k_1,L_2,k_2\\right)$。单位面积的总热阻为 $R_{\\text{th}} = \\frac{L_1}{k_1} + \\frac{L_2}{k_2}$。因此，$q = (T_h - T_c) / R_{\\text{th}}$。我们将在测试的实现中使用这个解析表达式作为 $\\hat{q}$。\n\n首先，我们从解析上验证问题中指定的单调性约束对于此模型是物理正确的。物理参数 $L_1, k_1, L_2, k_2$ 均为正，且指定的采样范围确保了 $T_h  T_c$。\n\n1.  关于 $T_h$ 的导数：\n    $$\\frac{\\partial q}{\\partial T_h} = \\frac{1}{\\frac{L_1}{k_1} + \\frac{L_2}{k_2}} = \\frac{1}{R_{\\text{th}}}$$\n    由于 $R_{\\text{th}}  0$，我们有 $\\frac{\\partial q}{\\partial T_h}  0$，与期望 $\\frac{\\partial \\hat{q}}{\\partial T_h} \\ge 0$ 一致。\n\n2.  关于 $T_c$ 的导数：\n    $$\\frac{\\partial q}{\\partial T_c} = \\frac{-1}{\\frac{L_1}{k_1} + \\frac{L_2}{k_2}} = -\\frac{1}{R_{\\text{th}}}$$\n    这总是负的，与 $\\frac{\\partial \\hat{q}}{\\partial T_c} \\le 0$ 一致。\n\n3.  关于 $L_1$ 的导数：\n    $$\\frac{\\partial q}{\\partial L_1} = (T_h - T_c) \\cdot \\left( -1 \\cdot \\left(\\frac{L_1}{k_1} + \\frac{L_2}{k_2}\\right)^{-2} \\cdot \\frac{1}{k_1} \\right) = -\\frac{T_h - T_c}{k_1 R_{\\text{th}}^2}$$\n    由于 $T_h - T_c  0$ 且 $k_1  0$，我们有 $\\frac{\\partial q}{\\partial L_1}  0$，与 $\\frac{\\partial \\hat{q}}{\\partial L_1} \\le 0$ 一致。\n\n4.  关于 $k_1$ 的导数：\n    $$\\frac{\\partial q}{\\partial k_1} = (T_h - T_c) \\cdot \\left( -1 \\cdot \\left(\\frac{L_1}{k_1} + \\frac{L_2}{k_2}\\right)^{-2} \\cdot \\left(-\\frac{L_1}{k_1^2}\\right) \\right) = \\frac{(T_h - T_c) L_1}{k_1^2 R_{\\text{th}}^2}$$\n    由于 $T_h - T_c  0$ 且 $L_1  0$，我们有 $\\frac{\\partial q}{\\partial k_1}  0$，与 $\\frac{\\partial \\hat{q}}{\\partial k_1} \\ge 0$ 一致。\n\n5.  关于 $L_2$ 和 $k_2$ 的导数：根据对称性，$L_2$ 和 $k_2$ 的结果与 $L_1$ 和 $k_1$ 的结果类似。\n    $$\\frac{\\partial q}{\\partial L_2} = -\\frac{T_h - T_c}{k_2 R_{\\text{th}}^2}  0, \\quad \\text{与 } \\frac{\\partial \\hat{q}}{\\partial L_2} \\le 0 \\text{ 一致}$$\n    $$\\frac{\\partial q}{\\partial k_2} = \\frac{(T_h - T_c) L_2}{k_2^2 R_{\\text{th}}^2}  0, \\quad \\text{与 } \\frac{\\partial \\hat{q}}{\\partial k_2} \\ge 0 \\text{ 一致}$$\n所有指定的单调性约束都是正确的。\n\n该解决方案实现了以下算法：\n1.  一个主过程遍历问题描述中定义的 4 个测试用例。对每个用例，都会计算一个布尔结果。\n2.  对于给定的测试用例，用指定的值为随机数生成器设定种子，以确保可复现性。\n3.  一个循环运行 $N$ 次迭代。在每次迭代中，通过从其指定范围内独立均匀地抽取每个分量，来采样一个 6 维输入向量 $\\mathbf{x}^{(i)}$。\n4.  对于每个样本 $\\mathbf{x}^{(i)}$，算法遍历其 6 个分量，从 $j=0$ 到 $j=5$。\n5.  在每个内循环迭代中，偏导数 $\\frac{\\partial \\hat{q}}{\\partial x_j}$ 使用中心有限差分公式进行近似：\n    $$\\frac{\\partial \\hat{q}}{\\partial x_j}(\\mathbf{x}) \\approx \\frac{\\hat{q}(\\mathbf{x}+h_j\\mathbf{e}_j) - \\hat{q}(\\mathbf{x}-h_j\\mathbf{e}_j)}{2h_j}$$\n    扰动大小 $h_j$ 是根据规则 $h_j=\\max(\\epsilon_j, s |x_j|)$ 为每个变量 $x_j$ 确定的，使用特定于用例的步长分数 $s$ 和全局定义的最小步长 $\\epsilon_j$。\n6.  然后将计算出的数值梯度与其期望的符号进行核对。核对过程包含绝对容差 $\\tau$。设 $g_j$ 为变量 $x_j$ 计算出的梯度。\n    - 如果期望的导数是非负的（$\\ge 0$），则当 $g_j  -\\tau$ 时，约束被违反。\n    - 如果期望的导数是非正的（$\\le 0$），则当 $g_j > \\tau$ 时，约束被违反。\n7.  如果在任何样本点的任何变量上违反了约束，该测试用例将立即被标记为失败（`False`），并且算法会继续处理下一个测试用例。\n8.  如果所有 $N$ 个样本的所有 6 个约束都得到满足，则该测试用例被标记为通过（`True`）。\n9.  最后，所有测试用例的布尔结果列表将按规定格式化并打印到标准输出。\n\n由于解析函数是完全单调的，数值测试预计将在所有情况下通过，从而得到 `[True,True,True,True]` 的输出。任何偏差都将表明数值微分方法因精度或稳定性问题而失败的区域，而本测试正是为此设计的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a numerical monotonicity test for a surrogate model of heat flux.\n    The surrogate is represented by the ideal physical model for 1D steady-state\n    heat conduction through two layers.\n    \"\"\"\n    \n    def q_surrogate(x: np.ndarray) -> float:\n        \"\"\"\n        Calculates the heat flux based on the analytical model.\n        x = [T_h, T_c, L_1, k_1, L_2, k_2]\n        \"\"\"\n        Th, Tc, L1, k1, L2, k2 = x\n        # The problem's constraints on L_i and k_i ensure the denominator is positive.\n        if k1 = 0 or k2 = 0:\n            return np.nan\n        resistance = L1 / k1 + L2 / k2\n        if resistance = 0:\n            return np.nan\n        return (Th - Tc) / resistance\n\n    test_cases = [\n        # Test Case 1 (typical building envelope regime)\n        {\n            'N': 200, 's': 1e-4, 'tau': 1e-9, 'seed': 12345,\n            'ranges': [\n                (310.0, 350.0),  # T_h [K]\n                (280.0, 300.0),  # T_c [K]\n                (0.01, 0.05),    # L_1 [m]\n                (0.2, 0.8),      # k_1 [W/mK]\n                (0.01, 0.05),    # L_2 [m]\n                (10.0, 50.0)     # k_2 [W/mK]\n            ]\n        },\n        # Test Case 2 (thin, highly conductive layers near the limit)\n        {\n            'N': 200, 's': 1e-6, 'tau': 1e-9, 'seed': 54321,\n            'ranges': [\n                (330.0, 360.0),  # T_h [K]\n                (290.0, 300.0),  # T_c [K]\n                (1e-4, 1e-3),    # L_1 [m]\n                (100.0, 400.0),  # k_1 [W/mK]\n                (1e-4, 1e-3),    # L_2 [m]\n                (100.0, 400.0)   # k_2 [W/mK]\n            ]\n        },\n        # Test Case 3 (near-isothermal boundary with small driving temperature difference)\n        {\n            'N': 200, 's': 1e-4, 'tau': 1e-9, 'seed': 11111,\n            'ranges': [\n                (300.1, 300.5),  # T_h [K]\n                (299.6, 300.0),  # T_c [K]\n                (0.01, 0.02),    # L_1 [m]\n                (0.2, 0.5),      # k_1 [W/mK]\n                (0.01, 0.02),    # L_2 [m]\n                (5.0, 10.0)      # k_2 [W/mK]\n            ]\n        },\n        # Test Case 4 (low-conductivity layer dominating overall resistance)\n        {\n            'N': 200, 's': 1e-4, 'tau': 1e-9, 'seed': 22222,\n            'ranges': [\n                (315.0, 335.0),  # T_h [K]\n                (285.0, 295.0),  # T_c [K]\n                (0.02, 0.04),    # L_1 [m]\n                (0.02, 0.05),    # k_1 [W/mK]\n                (0.01, 0.03),    # L_2 [m]\n                (0.5, 1.5)       # k_2 [W/mK]\n            ]\n        }\n    ]\n\n    # Minimum step sizes for perturbation\n    epsilons = np.array([1e-6, 1e-6, 1e-9, 1e-9, 1e-9, 1e-9])\n    \n    # Expected signs of partial derivatives: 1 for >= 0, -1 for = 0\n    # Corresponding to [T_h, T_c, L_1, k_1, L_2, k_2]\n    expected_signs = np.array([1, -1, -1, 1, -1, 1])\n    \n    results = []\n\n    for case in test_cases:\n        case_passes = True\n        rng = np.random.default_rng(case['seed'])\n        \n        N, s, tau = case['N'], case['s'], case['tau']\n        ranges = case['ranges']\n        \n        for _ in range(N):\n            # Generate a random sample vector\n            x_sample = np.array([rng.uniform(low, high) for low, high in ranges])\n            \n            # Compute perturbations h for all variables\n            h_vector = np.maximum(epsilons, s * np.abs(x_sample))\n            \n            for j in range(len(x_sample)):\n                # Evaluate surrogate at x + h*e_j and x - h*e_j\n                x_plus = x_sample.copy()\n                x_plus[j] += h_vector[j]\n                \n                x_minus = x_sample.copy()\n                x_minus[j] -= h_vector[j]\n                \n                q_plus = q_surrogate(x_plus)\n                q_minus = q_surrogate(x_minus)\n                \n                # Compute centered finite difference\n                grad_j = (q_plus - q_minus) / (2 * h_vector[j])\n                \n                # Verify sign constraint against tolerance tau\n                is_violated = False\n                if expected_signs[j] > 0 and grad_j  -tau:\n                    is_violated = True\n                elif expected_signs[j]  0 and grad_j > tau:\n                    is_violated = True\n\n                if is_violated:\n                    case_passes = False\n                    break  # Exit j-loop (variables)\n            \n            if not case_passes:\n                break  # Exit i-loop (samples)\n        \n        results.append(case_passes)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}