{
    "hands_on_practices": [
        {
            "introduction": "在编写任何优化代码之前，理解问题的数学结构至关重要。卡罗需-库恩-塔克（Karush-Kuhn-Tucker, KKT）条件为我们定义了在约束条件下，“最优”设计应满足的必要条件，并为数值优化算法提供了理论目标。本练习  将从第一性原理出发，引导你为一个普适的热拓扑优化问题推导出这些基础条件。",
            "id": "3998279",
            "problem": "考虑一个在具有 Lipschitz 边界的有界开域 $\\Omega \\subset \\mathbb{R}^{d}$ 上的热拓扑优化问题，其中设计变量是材料密度场 $\\rho:\\Omega \\to [0,1]$。设目标泛函 $J(\\rho)$ 是通过对每个容许的 $\\rho$ 求解稳态热传导问题，然后评估一个可微性能泛函所得到的简化成本；假设 $J:L^{\\infty}(\\Omega)\\to\\mathbb{R}$ 是 Fréchet 可微的，其导数用变分灵敏度 $\\frac{\\delta J}{\\delta \\rho}(x)$ 表示。该设计受全局体积约束和边界约束的限制，\n$$\n\\int_{\\Omega} \\rho(x)\\, dx \\le V^{*}, \\quad 0 \\le \\rho(x) \\le 1 \\quad \\text{对于几乎每一个 } x \\in \\Omega.\n$$\n从该约束问题的拉格朗日函数出发，推导必要的 Karush–Kuhn–Tucker (KKT) 最优性条件，包括驻定性、原始可行性、对偶可行性和互补松弛性。使用以下结构的拉格朗日函数，其中乘子 $\\lambda \\in \\mathbb{R}$ 对应体积约束，$\\alpha(x),\\beta(x)$ 分别对应逐点下界和上界约束：\n$$\n\\mathcal{L}(\\rho,\\lambda,\\alpha,\\beta) = J(\\rho) + \\lambda\\!\\left(\\int_{\\Omega} \\rho(x)\\, dx - V^{*}\\right) + \\int_{\\Omega} \\alpha(x)\\,(-\\rho(x))\\, dx + \\int_{\\Omega} \\beta(x)\\,(\\rho(x)-1)\\, dx,\n$$\n其中 $\\alpha,\\beta \\in L^{2}(\\Omega)$ 代表分布式乘子。清晰地陈述乘子的符号条件，以及与激活和非激活约束相关的互补松弛关系。你的推导应从变分法和约束优化的第一性原理开始，包括变分法基本引理和不等式约束最优性框架。\n\n作为最终答案，请以包含 $\\frac{\\delta J}{\\delta \\rho}(x)$、$\\lambda$、$\\alpha(x)$ 和 $\\beta(x)$ 的单一解析表达式的形式，报告 KKT 系统的逐点驻定性条件，该条件在 $\\Omega$ 中几乎处处成立。不需要进行数值评估。最终答案中不要包含任何单位。",
            "solution": "寻找最优材料密度分布 $\\rho(x)$ 的问题是一个在无限维函数空间中的约束优化问题。最优解的必要条件由 Karush–Kuhn–Tucker (KKT) 条件给出，该条件将拉格朗日乘子法推广到处理不等式约束。我们将基于所提供的拉格朗日函数系统地推导这些条件。\n\n该优化问题可以表述为：\n最小化 $J(\\rho)$\n约束条件：\n$g_1(\\rho) = \\int_{\\Omega} \\rho(x)\\, dx - V^{*} \\le 0$\n$g_{2,x}(\\rho) = -\\rho(x) \\le 0 \\quad$ 对 a.e. $x \\in \\Omega$\n$g_{3,x}(\\rho) = \\rho(x) - 1 \\le 0 \\quad$ 对 a.e. $x \\in \\Omega$\n\n该问题的拉格朗日函数为：\n$$\n\\mathcal{L}(\\rho,\\lambda,\\alpha,\\beta) = J(\\rho) + \\lambda g_1(\\rho) + \\int_{\\Omega} \\alpha(x) g_{2,x}(\\rho) \\, dx + \\int_{\\Omega} \\beta(x) g_{3,x}(\\rho) \\, dx\n$$\n代入约束的具体形式，我们得到：\n$$\n\\mathcal{L}(\\rho,\\lambda,\\alpha,\\beta) = J(\\rho) + \\lambda\\left(\\int_{\\Omega} \\rho(x)\\, dx - V^{*}\\right) + \\int_{\\Omega} \\alpha(x)\\,(-\\rho(x))\\, dx + \\int_{\\Omega} \\beta(x)\\,(\\rho(x)-1)\\, dx\n$$\n这可以通过组合包含 $\\rho(x)$ 的项来重写：\n$$\n\\mathcal{L}(\\rho,\\lambda,\\alpha,\\beta) = J(\\rho) + \\int_{\\Omega} \\left[ \\lambda \\rho(x) - \\alpha(x) \\rho(x) + \\beta(x) \\rho(x) \\right]\\, dx - \\lambda V^{*} - \\int_{\\Omega} \\beta(x) \\, dx\n$$\n\nKKT 条件是在作为局部最小值的正则点必须满足的一组四个条件：驻定性、原始可行性、对偶可行性和互补松弛性。\n\n1.  **驻定性条件**\n驻定性条件要求拉格朗日函数相对于原始变量 $\\rho$ 的一阶变分（或 Gâteaux 导数）对于所有容许变分 $\\delta \\rho$ 都为零。设 $\\rho^*$ 是一个最优密度场。那么对于任何容许变分 $\\delta \\rho$，我们必须有：\n$$\n\\delta_{\\rho} \\mathcal{L}(\\rho^*, \\lambda, \\alpha, \\beta; \\delta\\rho) = \\left. \\frac{d}{d\\epsilon} \\mathcal{L}(\\rho^* + \\epsilon \\delta\\rho, \\dots) \\right|_{\\epsilon=0} = 0\n$$\n我们计算拉格朗日函数中每一项的变分：\n-   根据变分灵敏度 $\\frac{\\delta J}{\\delta \\rho}$ 的定义，目标泛函 $J(\\rho)$ 的变分为：\n    $$\n    \\delta_{\\rho} J(\\rho; \\delta\\rho) = \\int_{\\Omega} \\frac{\\delta J}{\\delta \\rho}(x) \\delta\\rho(x) \\, dx\n    $$\n-   约束项的变分计算如下。由于它们在 $\\rho$ 中是线性的，其变分是直接的：\n    $$\n    \\delta_{\\rho} \\left[ \\lambda\\left(\\int_{\\Omega} \\rho(x)\\, dx - V^{*}\\right) \\right] = \\lambda \\int_{\\Omega} \\delta\\rho(x) \\, dx\n    $$\n    $$\n    \\delta_{\\rho} \\left[ \\int_{\\Omega} \\alpha(x)\\,(-\\rho(x))\\, dx \\right] = -\\int_{\\Omega} \\alpha(x) \\delta\\rho(x) \\, dx\n    $$\n    $$\n    \\delta_{\\rho} \\left[ \\int_{\\Omega} \\beta(x)\\,(\\rho(x)-1)\\, dx \\right] = \\int_{\\Omega} \\beta(x) \\delta\\rho(x) \\, dx\n    $$\n结合这些结果，拉格朗日函数的一阶变分为：\n$$\n\\delta_{\\rho} \\mathcal{L} = \\int_{\\Omega} \\frac{\\delta J}{\\delta \\rho}(x) \\delta\\rho(x) \\, dx + \\lambda \\int_{\\Omega} \\delta\\rho(x) \\, dx - \\int_{\\Omega} \\alpha(x) \\delta\\rho(x) \\, dx + \\int_{\\Omega} \\beta(x) \\delta\\rho(x) \\, dx = 0\n$$\n提出任意变分 $\\delta\\rho(x)$：\n$$\n\\int_{\\Omega} \\left( \\frac{\\delta J}{\\delta \\rho}(x) + \\lambda - \\alpha(x) + \\beta(x) \\right) \\delta\\rho(x) \\, dx = 0\n$$\n根据变分法基本引理，如果这个积分恒等式对所有容许变分 $\\delta\\rho(x)$（例如，所有 $\\delta \\rho \\in L^2(\\Omega)$）都成立，那么括号中的项必须在 $\\Omega$ 中几乎处处为零。这就得到了逐点驻定性条件：\n$$\n\\frac{\\delta J}{\\delta \\rho}(x) + \\lambda - \\alpha(x) + \\beta(x) = 0 \\quad \\text{对 a.e. } x \\in \\Omega\n$$\n\n2.  **原始可行性**\n最优解 $\\rho(x)$ 必须满足原问题的约束：\n$$\n\\int_{\\Omega} \\rho(x)\\, dx - V^{*} \\le 0\n$$\n$$\n-\\rho(x) \\le 0 \\implies \\rho(x) \\ge 0 \\quad \\text{对 a.e. } x \\in \\Omega\n$$\n$$\n\\rho(x) - 1 \\le 0 \\implies \\rho(x) \\le 1 \\quad \\text{对 a.e. } x \\in \\Omega\n$$\n\n3.  **对偶可行性**\n对于一个具有 $g_i(\\rho) \\le 0$ 形式不等式约束的最小化问题，相应的拉格朗日乘子必须是非负的。\n-   对于体积约束 $\\int_{\\Omega} \\rho(x)\\, dx - V^{*} \\le 0$，乘子 $\\lambda$ 必须满足：\n    $$\n    \\lambda \\ge 0\n    $$\n-   对于逐点下界约束 $-\\rho(x) \\le 0$，乘子场 $\\alpha(x)$ 必须满足：\n    $$\n    \\alpha(x) \\ge 0 \\quad \\text{对 a.e. } x \\in \\Omega\n    $$\n-   对于逐点上界约束 $\\rho(x) - 1 \\le 0$，乘子场 $\\beta(x)$ 必须满足：\n    $$\n    \\beta(x) \\ge 0 \\quad \\text{对 a.e. } x \\in \\Omega\n    $$\n\n4.  **互补松弛性**\n这个条件表明，对于每个不等式约束，乘子与约束函数的乘积必须为零。这意味着一个乘子只有在相应的约束是激活的（即等式成立）时才能是严格正的。\n-   对于体积约束：\n    $$\n    \\lambda \\left( \\int_{\\Omega} \\rho(x)\\, dx - V^{*} \\right) = 0\n    $$\n-   对于逐点下界约束：\n    $$\n    \\alpha(x) (-\\rho(x)) = 0 \\implies \\alpha(x) \\rho(x) = 0 \\quad \\text{对 a.e. } x \\in \\Omega\n    $$\n    这意味着如果 $\\rho(x) > 0$（即下界非激活），那么 $\\alpha(x)$ 必须为 $0$。\n-   对于逐点上界约束：\n    $$\n    \\beta(x) (\\rho(x) - 1) = 0 \\quad \\text{对 a.e. } x \\in \\Omega\n    $$\n    这意味着如果 $\\rho(x)  1$（即上界非激活），那么 $\\beta(x)$ 必须为 $0$。\n\n这四组条件共同构成了给定拓扑优化问题的 KKT 最优性条件。问题特别要求的是逐点驻定性条件，我们已将其作为第一个结果推导出来。",
            "answer": "$$\n\\boxed{\\frac{\\delta J}{\\delta \\rho}(x) + \\lambda - \\alpha(x) + \\beta(x) = 0}\n$$"
        },
        {
            "introduction": "任何优化过程都依赖于一个能够准确模拟给定设计下物理行为的“正向求解器”。本练习  专注于为一个具有挑战性的共轭传热问题（包含非线性的辐射效应）构建一个有限体积求解器。其中的关键点在于通过全局能量平衡检查来验证求解器的物理一致性，这是任何高保真模拟中都不可或缺的一步。",
            "id": "3998265",
            "problem": "考虑一个用于稳态共轭传热热拓扑优化的二维矩形设计域。该域宽为 $L$ 米，高为 $H$ 米，具有均匀的平面外厚度 $t$ 米。其内部是一种非均匀固体，其有效热导率由固体各向同性材料惩罚模型（SIMP）控制：$k(\\rho) = k_{\\min} + \\rho^p (k_{\\max} - k_{\\min})$，其中 $\\rho \\in [0,1]$ 是单元级的设计密度，$p$ 是惩罚指数，$k_{\\min}$ 是类孔隙区域的残余热导率，$k_{\\max}$ 是类固体材料的热导率。\n\n控制性的稳态热方程是控制体的能量守恒陈述，在域 $\\Omega$ 内有体积生热 $q(\\mathbf{x})$：\n$$\n-\\nabla \\cdot \\left( k(\\rho) \\nabla T(\\mathbf{x}) \\right) = q(\\mathbf{x}) \\quad \\text{in } \\Omega,\n$$\n受限于不相交的边界部分 $\\Gamma_{\\text{sink}}$（等温热沉）、$\\Gamma_{\\text{conv}}$（与环境的对流交换）、$\\Gamma_{\\text{rad}}$（辐射交换）上的边界条件，其余边界为绝热。边界条件为：\n$$\nT = T_{\\text{sink}} \\quad \\text{on } \\Gamma_{\\text{sink}},\n$$\n$$\n- \\mathbf{n} \\cdot k(\\rho) \\nabla T = h \\left( T - T_{\\infty} \\right) \\quad \\text{on } \\Gamma_{\\text{conv}},\n$$\n$$\n- \\mathbf{n} \\cdot k(\\rho) \\nabla T = \\varepsilon \\sigma \\left( T^4 - T_{\\text{sur}}^4 \\right) \\quad \\text{on } \\Gamma_{\\text{rad}},\n$$\n其中 $\\mathbf{n}$ 是外向单位法向量，$h$ 是对流传热系数，$T_{\\infty}$ 是环境温度，$\\varepsilon$ 是表面发射率，$\\sigma$ 是斯特藩-玻尔兹曼常数。\n\n从热力学第一定律出发，应用散度定理，推导出全局能量平衡，即总输入热功率等于通过热沉的传导、对流移除和辐射移除的热量之和：\n$$\n\\underbrace{\\int_{\\Omega} q \\, d\\Omega}_{\\text{total input}} = \\underbrace{\\int_{\\Gamma_{\\text{sink}}} \\left( -\\mathbf{n} \\cdot k(\\rho) \\nabla T \\right) d\\Gamma}_{\\text{conduction to sink}} + \\underbrace{\\int_{\\Gamma_{\\text{conv}}} h (T - T_{\\infty}) \\, d\\Gamma}_{\\text{convective removal}} + \\underbrace{\\int_{\\Gamma_{\\text{rad}}} \\varepsilon \\sigma \\left( T^4 - T_{\\text{sur}}^4 \\right) d\\Gamma}_{\\text{radiative removal}}.\n$$\n将能量平衡残差定义为\n$$\nr = \\left| \\int_{\\Omega} q \\, d\\Omega - \\int_{\\Gamma_{\\text{sink}}} \\left( -\\mathbf{n} \\cdot k(\\rho) \\nabla T \\right) d\\Gamma - \\int_{\\Gamma_{\\text{conv}}} h (T - T_{\\infty}) \\, d\\Gamma - \\int_{\\Gamma_{\\text{rad}}} \\varepsilon \\sigma \\left( T^4 - T_{\\text{sur}}^4 \\right) d\\Gamma \\right|.\n$$\n在 $x$ 方向有 $N_x$ 个单元、$y$ 方向有 $N_y$ 个单元的均匀网格上，实施一个基于保守的格心有限体积离散化的数值方案。对面热导率使用谐波平均。通过到边界距离为 $d = \\Delta x/2$ 的半网格扩散热导来施加狄利克雷热沉边界条件。将对流和辐射边界条件作为线性罗宾型贡献施加到离散方程中。为了处理辐射的非线性，在每次迭代中对底部边界节点采用不动点线性化，使用有效辐射热导 $h_{\\text{rad}} = 4 \\varepsilon \\sigma T^3$ 和有效环境温度 $T_{\\text{eff}} = T - \\frac{\\varepsilon \\sigma (T^4 - T_{\\text{sur}}^4)}{h_{\\text{rad}}}$，以使线性化边界通量等于在当前迭代值下计算的非线性通量。迭代直至温度场收敛。\n\n对于数值实现，请明确遵守单位使用以下参数：\n- 域：$L = 0.10$ 米，$H = 0.10$ 米，厚度 $t = 0.010$ 米。$N_x = 10$，$N_y = 10$ 单元的均匀网格，因此 $\\Delta x = L/N_x$ 且 $\\Delta y = H/N_y$。\n- 材料模型：$k_{\\min} = 0.2$ 瓦/米·开尔文，$k_{\\max} = 200$ 瓦/米·开尔文，惩罚指数 $p = 3$。\n- 热沉：$\\Gamma_{\\text{sink}}$ 是整个左边界；$T_{\\text{sink}} = 300$ 开尔文。\n- 对流：$\\Gamma_{\\text{conv}}$ 是整个顶部和右侧边界；$T_{\\infty} = 300$ 开尔文。对流系数 $h$ 根据测试案例变化（见下文）。\n- 辐射：$\\Gamma_{\\text{rad}}$ 是整个底部边界；$\\varepsilon$ 根据测试案例变化（见下文）。周围温度 $T_{\\text{sur}} = 300$ 开尔文，$\\sigma = 5.670374419 \\times 10^{-8}$ 瓦/米²·开尔文⁴。\n- 内部生热：在中心的 $4 \\times 4$ 单元块中，$q(\\mathbf{x}) = Q = 1.0 \\times 10^7$ 瓦/立方米，其他地方 $q(\\mathbf{x}) = 0$。中心块的索引为 $i \\in \\{3,4,5,6\\}$，$j \\in \\{3,4,5,6\\}$，使用从零开始的索引，$i$ 沿 $x$ 轴，$j$ 沿 $y$ 轴。\n- 拓扑（设计密度场 $\\rho$）根据测试案例变化（见下文），并通过 SIMP 模型影响 $k(\\rho)$。\n\n程序要求：\n- 构建离散线性系统并求解温度场 $T_{i,j}$（单位：开尔文）。\n- 使用精确的辐射通量 $\\varepsilon \\sigma (T^4 - T_{\\text{sur}}^4)$ 对底部边界积分进行后处理，顶部和右侧边界使用对流通量 $h (T - T_{\\infty})$，左侧边界使用与半网格热导模型一致的扩散边界通量作为到热沉的传导通量，来评估能量平衡残差 $r$（单位：瓦）。\n- 使用不动点迭代将辐射纳入线性系统，直到连续迭代之间的最大温度变化小于 $10^{-8}$ 开尔文或达到最多 $50$ 次迭代。\n\n测试套件：\n提供三个测试案例，以不同的拓扑和边界参数组合来验证实现：\n1. 测试案例 A（基准非均匀传导，带对流和辐射）：\n   - 对所有单元，$\\rho_{i,j} = 1$，\n   - $h = 1000$ 瓦/米²·开尔文，\n   - $\\varepsilon = 0.8$。\n2. 测试案例 B（稀疏对角线传导路径，带对流和辐射）：\n   - 对所有单元，$\\rho_{i,j} = 0.05$，除了 $i = j$ 或 $i = j \\pm 1$（裁剪到有效索引）的单元，其中 $\\rho_{i,j} = 1$，\n   - $h = 1000$ 瓦/米²·开尔文，\n   - $\\varepsilon = 0.8$。\n3. 测试案例 C（纯传导至热沉，无对流或辐射）：\n   - 对所有单元，$\\rho_{i,j} = 1$，\n   - $h = 0$ 瓦/米²·开尔文，\n   - $\\varepsilon = 0$。\n\n最终输出规范：\n您的程序应生成一行输出，其中包含三个测试案例的能量平衡残差 $r$（单位：瓦），形式为用方括号括起来的逗号分隔列表，每个值四舍五入到六位有效数字（例如，$\\left[0.123456,0.000321,1.23457\\right]$）。这些值必须以瓦特为单位，并严格按照此格式打印。",
            "solution": "该问题提出了一个计算传热学的任务，要求推导全局能量平衡，设计并实现一个求解带非线性边界条件的稳态热方程的数值求解器，并在一组特定的测试案例上评估该求解器。该问题在科学上是合理的、适定的，并为完整解决提供了所有必要信息。\n\n### 第1部分：全局能量平衡的推导\n\n推导从域 $\\Omega$ 内具有内部热源 $q(\\mathbf{x})$ 的稳态热传导的控制性偏微分方程开始：\n$$\n-\\nabla \\cdot \\left( k(\\rho) \\nabla T(\\mathbf{x}) \\right) = q(\\mathbf{x})\n$$\n此方程是将热力学第一定律应用于无穷小控制体的陈述，其中热通量矢量 $\\mathbf{q}'' = -k(\\rho)\\nabla T$ 的散度与单位体积的局部生热率 $q$ 相平衡。\n\n为了获得整个域 $\\Omega$ 的全局能量平衡，我们将控制方程在域的体积上积分（对于厚度为 $t$ 的二维问题，这对应于在面积 $d\\Omega$ 上积分并乘以 $t$，但为简单起见，我们用 $d\\Omega$ 表示体积元 $dxdydz$）：\n$$\n\\int_{\\Omega} -\\nabla \\cdot \\left( k(\\rho) \\nabla T(\\mathbf{x}) \\right) d\\Omega = \\int_{\\Omega} q(\\mathbf{x}) d\\Omega\n$$\n右侧项 $\\int_{\\Omega} q \\, d\\Omega$ 代表域内产生的总功率。\n\n我们对左侧应用散度定理。该定理指出，对于一个连续可微的矢量场 $\\mathbf{F}$，其在体积 $\\Omega$ 上的散度积分等于该场通过包围该体积的闭合曲面 $\\partial\\Omega$ 的通量：$\\int_{\\Omega} (\\nabla \\cdot \\mathbf{F}) \\, d\\Omega = \\oint_{\\partial\\Omega} \\mathbf{n} \\cdot \\mathbf{F} \\, d\\Gamma$。在这里，我们的矢量场是热通量 $\\mathbf{q}'' = -k(\\rho)\\nabla T$。\n$$\n\\int_{\\Omega} \\nabla \\cdot \\left( -k(\\rho) \\nabla T \\right) d\\Omega = \\oint_{\\partial\\Omega} \\mathbf{n} \\cdot \\left( -k(\\rho) \\nabla T \\right) d\\Gamma\n$$\n因此，积分后的控制方程变为：\n$$\n\\int_{\\Omega} q(\\mathbf{x}) \\, d\\Omega = \\oint_{\\partial\\Omega} \\left( -\\mathbf{n} \\cdot k(\\rho) \\nabla T \\right) d\\Gamma\n$$\n该方程表明，在稳态下，域内产生的总热量必须等于通过其边界离开域的总热量。\n\n总边界 $\\partial\\Omega$ 由四个不相交的部分组成：热沉边界 $\\Gamma_{\\text{sink}}$、对流边界 $\\Gamma_{\\text{conv}}$、辐射边界 $\\Gamma_{\\text{rad}}$ 以及任何通量为零的其余绝热边界。我们可以将边界积分分解为来自每个部分的贡献：\n$$\n\\oint_{\\partial\\Omega} \\left( -\\mathbf{n} \\cdot k \\nabla T \\right) d\\Gamma = \\int_{\\Gamma_{\\text{sink}}} \\left( -\\mathbf{n} \\cdot k \\nabla T \\right) d\\Gamma + \\int_{\\Gamma_{\\text{conv}}} \\left( -\\mathbf{n} \\cdot k \\nabla T \\right) d\\Gamma + \\int_{\\Gamma_{\\text{rad}}} \\left( -\\mathbf{n} \\cdot k \\nabla T \\right) d\\Gamma\n$$\n现在，我们用给定的边界条件替换通量项 $-\\mathbf{n} \\cdot k \\nabla T$：\n1.  在 $\\Gamma_{\\text{conv}}$ 上：通量由牛顿冷却定律给出，$-\\mathbf{n} \\cdot k \\nabla T = h(T - T_{\\infty})$。\n2.  在 $\\Gamma_{\\text{rad}}$ 上：通量由向大环境辐射的斯特藩-玻尔兹曼定律给出，$-\\mathbf{n} \\cdot k \\nabla T = \\varepsilon \\sigma (T^4 - T_{\\text{sur}}^4)$。\n3.  在 $\\Gamma_{\\text{sink}}$ 上：边界条件为狄利克雷条件，$T = T_{\\text{sink}}$。被积函数 $-\\mathbf{n} \\cdot k \\nabla T$ 本身代表从域传导到热沉的热通量。\n\n代入这些表达式，得到最终的全局能量平衡方程：\n$$\n\\underbrace{\\int_{\\Omega} q \\, d\\Omega}_{\\text{total input}} = \\underbrace{\\int_{\\Gamma_{\\text{sink}}} \\left( -\\mathbf{n} \\cdot k(\\rho) \\nabla T \\right) d\\Gamma}_{\\text{conduction to sink}} + \\underbrace{\\int_{\\Gamma_{\\text{conv}}} h (T - T_{\\infty}) \\, d\\Gamma}_{\\text{convective removal}} + \\underbrace{\\int_{\\Gamma_{\\text{rad}}} \\varepsilon \\sigma \\left( T^4 - T_{\\text{sur}}^4 \\right) d\\Gamma}_{\\text{radiative removal}}\n$$\n至此，推导完成。能量平衡残差 $r$ 是总输入功率与所有功率移除项之和之间的绝对差值，它作为数值解中能量守恒的度量。\n\n### 第2部分：数值方案设计\n\n采用保守的格心有限体积法（FVM）在 $N_x \\times N_y$ 单元的均匀网格上求解控制方程。温度 $T_{i,j}$位于单元 $(i,j)$ 的中心。\n\n**控制方程的离散化：**\n将偏微分方程在单个单元体积 $V_{i,j} = \\Delta x \\Delta y t$ 上积分并应用散度定理，得到：\n$$\n-\\sum_{f \\in \\{\\text{e,w,n,s}\\}} \\left( \\int_{A_f} (k \\nabla T) \\cdot \\mathbf{n}_f dA \\right) = q_{i,j} V_{i,j}\n$$\n其中，求和遍历单元的东、西、南、北四个面。在面 $A_f$ 上的积分是穿过该面的热通量。对于单元 $(i,j)$ 和 $(i+1,j)$ 之间的内表面，通量近似为：\n$$\nQ_{i,j \\to i+1,j} = k_e \\frac{T_{i,j} - T_{i+1,j}}{\\Delta x} (\\Delta y t) = G_{e} (T_{i,j} - T_{i+1,j})\n$$\n其中 $G_e$ 是单元中心之间的热导。界面热导率 $k_e$ 使用谐波平均计算，以恰当处理热导率的巨大差异：\n$$\nk_e = \\frac{2 k_{i,j} k_{i+1,j}}{k_{i,j} + k_{i+1,j}} \\quad \\text{where} \\quad k_{i,j} = k(\\rho_{i,j})\n$$\n其他三个面也有类似的表达式。内部单元 $(i,j)$ 的能量平衡构成一个连接 $T_{i,j}$ 与其四个邻居的线性代数方程：\n$$\nG_e(T_{i,j}-T_{i+1,j}) + G_w(T_{i,j}-T_{i-1,j}) + G_n(T_{i,j}-T_{i,j+1}) + G_s(T_{i,j}-T_{i,j-1}) = q_{i,j} V_{i,j}\n$$\n\n**边界条件的实现：**\n对于与域边界相邻的单元，一个或多个通量项被边界条件表达式替换。\n1.  **热沉（左侧，$i=0$）：** 狄利克雷条件 $T=T_{\\text{sink}}$ 通过半网格热导模型施加。从单元 $(0,j)$ 到热沉的通量被建模为在距离 $\\Delta x/2$ 上的传导：\n    $$ Q_{\\text{sink}} = G_{\\text{sink}} (T_{0,j} - T_{\\text{sink}}), \\quad \\text{where} \\quad G_{\\text{sink}} = \\frac{k_{0,j} (\\Delta y t)}{\\Delta x / 2} $$\n    这在矩阵方程的左手边（LHS）增加了项 $G_{\\text{sink}}T_{0,j}$，在右手边（RHS）矢量中增加了项 $G_{\\text{sink}}T_{\\text{sink}}$。\n\n2.  **对流（顶部，$j=N_y-1$；右侧，$i=N_x-1$）：** 这种罗宾型条件被直接实现。对于顶部边界单元 $(i,N_y-1)$，向北的通量是：\n    $$ Q_{\\text{conv}} = h (T_{i,N_y-1} - T_{\\infty}) (\\Delta x t) $$\n    这等效于到环境温度 $T_{\\infty}$ 的一个热导 $G_{\\text{conv}}=h(\\Delta x t)$，在 LHS 增加了 $G_{\\text{conv}}T_{i,N_y-1}$，在 RHS 增加了 $G_{\\text{conv}}T_{\\infty}$。对右边界应用类似的处理。\n\n3.  **辐射（底部，$j=0$）：** 非线性辐射通量被线性化以便包含在线性系统中。通量为 $Q_{\\text{rad}} = \\varepsilon \\sigma (T^4 - T_{\\text{sur}}^4) A_{\\text{face}}$。我们围绕上一次迭代的温度 $T^{\\text{old}}$ 使用牛顿-拉夫逊线性化：\n    $$ Q_{\\text{rad}}(T) \\approx Q_{\\text{rad}}(T^{\\text{old}}) + \\frac{dQ_{\\text{rad}}}{dT}\\bigg|_{T^{\\text{old}}} (T - T^{\\text{old}}) $$\n    这可以表示为有效的罗宾条件 $Q_{\\text{rad}} \\approx h_{\\text{rad}}(T - T_{\\text{rad,eff}}) A_{\\text{face}}$，其中：\n    $$ h_{\\text{rad}} = 4\\varepsilon\\sigma (T^{\\text{old}})^3, \\quad T_{\\text{rad,eff}} = T^{\\text{old}} - \\frac{\\varepsilon\\sigma((T^{\\text{old}})^4 - T_{\\text{sur}}^4)}{h_{\\text{rad}}} = \\frac{3(T^{\\text{old}})^4 + T_{\\text{sur}}^4}{4(T^{\\text{old}})^3} $$\n    对于每个底部边界单元 $(i,0)$，这在 LHS 贡献了项 $h_{\\text{rad},i,0}(\\Delta x t) T_{i,0}$，在 RHS 贡献了项 $h_{\\text{rad},i,0}(\\Delta x t) T_{\\text{rad,eff},i,0}$。\n\n**求解算法：**\n辐射边界条件的非线性特性需要迭代求解：\n1.  初始化温度场，例如，对所有 $(i,j)$，$T^{(0)}_{i,j} = T_{\\text{sink}}$。\n2.  开始不动点迭代循环（对于 $k = 0, 1, 2, ...$）：\n    a.  对于每个底部边界单元，使用当前温度场 $T^{(k)}$ 计算 $h_{\\text{rad}}$ 和 $T_{\\text{rad,eff}}$。\n    b.  组装全局线性方程组 $A(T^{(k)}) \\mathbf{T} = \\mathbf{b}(T^{(k)})$，其中矢量 $\\mathbf{T}$ 包含未知的单元温度 $T_{i,j}$。\n    c.  求解稀疏线性系统以获得新的温度场 $\\mathbf{T}^{(k+1)}$。\n    d.  通过比较迭代间的最大绝对温度变化来检查收敛性：$\\max_{i,j} |T^{(k+1)}_{i,j} - T^{(k)}_{i,j}|  \\delta_{tol}$。如果收敛，或达到最大迭代次数，则终止。\n    e.  设置 $T^{(k)} \\leftarrow T^{(k+1)}$ 并继续下一次迭代。\n\n### 第3部分：能量平衡残差计算\n\n在温度场收敛后，计算能量平衡残差 $r$ 以验证解的全局能量守恒。\n1.  **总输入功率 ($P_{\\text{in}}$):** 这是所有源单元上生热的总和。\n    $$ P_{\\text{in}} = \\sum_{i,j \\in \\text{source}} Q \\cdot V_{i,j} = (1.0 \\times 10^7 \\text{ W/m}^3) \\cdot (16 \\text{ cells}) \\cdot (\\Delta x \\Delta y t) = 160 \\text{ W} $$\n2.  **热沉移除 ($P_{\\text{sink}}$):** 所有左边界单元流入热沉的通量之和。\n    $$ P_{\\text{sink}} = \\sum_{j=0}^{N_y-1} \\frac{2 k_{0,j} \\Delta y t}{\\Delta x} (T_{0,j} - T_{\\text{sink}}) $$\n3.  **对流移除 ($P_{\\text{conv}}$):** 所有顶部和右侧边界单元的对流通量之和。\n    $$ P_{\\text{conv}} = \\sum_{i=0}^{N_x-1} h(T_{i,N_y-1} - T_{\\infty})(\\Delta x t) + \\sum_{j=0}^{N_y-1} h(T_{N_x-1,j} - T_{\\infty})(\\Delta y t) $$\n4.  **辐射移除 ($P_{\\text{rad}}$):** 所有底部边界单元的辐射通量之和，使用原始的非线性斯特藩-玻尔兹曼定律，如指定。\n    $$ P_{\\text{rad}} = \\sum_{i=0}^{N_x-1} \\varepsilon \\sigma (T_{i,0}^4 - T_{\\text{sur}}^4)(\\Delta x t) $$\n然后将残差计算为绝对差：\n$$\nr = \\left| P_{\\text{in}} - (P_{\\text{sink}} + P_{\\text{conv}} + P_{\\text{rad}}) \\right|\n$$\n该残差量化了收敛解满足原始非线性能量平衡方程的程度。其值的大小是线性化准确性和不动点方案收敛性的一个指标。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases for the thermal topology optimization problem.\n    \"\"\"\n    \n    # --------------------------------------------------------------------------\n    # 1. Define Physical and Numerical Parameters\n    # --------------------------------------------------------------------------\n    L, H, t = 0.10, 0.10, 0.010  # Domain dimensions [m]\n    Nx, Ny = 10, 10                # Number of cells\n    dx, dy = L / Nx, H / Ny          # Cell dimensions [m]\n    \n    k_min, k_max = 0.2, 200.0      # Material thermal conductivities [W/(m.K)]\n    p = 3.0                          # SIMP penalization exponent\n    \n    T_sink = 300.0                   # Sink temperature [K]\n    T_inf = 300.0                    # Ambient fluid temperature [K]\n    T_sur = 300.0                    # Surrounding surface temperature for radiation [K]\n    \n    Q = 1.0e7                        # Volumetric heat generation [W/m^3]\n    sigma = 5.670374419e-8           # Stefan-Boltzmann constant [W/(m^2.K^4)]\n\n    # Convergence parameters\n    max_iter = 50\n    tol = 1e-8\n\n    # Define heat source location (central 4x4 block)\n    q_source = np.zeros((Ny, Nx))\n    for j in range(3, 7):\n        for i in range(3, 7):\n            q_source[j, i] = Q\n            \n    # --------------------------------------------------------------------------\n    # 2. Define Test Cases\n    # --------------------------------------------------------------------------\n    \n    # Test Case A: Uniform solid material, convection, and radiation\n    rho_A = np.ones((Ny, Nx))\n    case_A = {'rho': rho_A, 'h': 1000.0, 'eps': 0.8}\n\n    # Test Case B: Sparse diagonal path, convection, and radiation\n    rho_B = np.full((Ny, Nx), 0.05)\n    for j in range(Ny):\n        for i in range(Nx):\n            if abs(i - j) = 1:\n                rho_B[j, i] = 1.0\n    case_B = {'rho': rho_B, 'h': 1000.0, 'eps': 0.8}\n\n    # Test Case C: Uniform solid material, pure conduction to sink\n    rho_C = np.ones((Ny, Nx))\n    case_C = {'rho': rho_C, 'h': 0.0, 'eps': 0.0}\n\n    test_cases = [case_A, case_B, case_C]\n    results = []\n\n    # --------------------------------------------------------------------------\n    # 3. Main Loop over Test Cases\n    # --------------------------------------------------------------------------\n    for case in test_cases:\n        h = case['h']\n        eps = case['eps']\n        rho = case['rho']\n\n        # Calculate cell-wise thermal conductivity\n        k_field = k_min + rho**p * (k_max - k_min)\n        \n        # Initialize temperature field\n        T = np.full((Ny, Nx), T_sink)\n        \n        for iter_count in range(max_iter):\n            T_old = T.copy()\n            \n            # Assemble the linear system A*T = b\n            A = lil_matrix((Nx * Ny, Nx * Ny))\n            b = np.zeros(Nx * Ny)\n            \n            for j in range(Ny):       # y-direction, rows\n                for i in range(Nx):   # x-direction, columns\n                    k_idx = j * Nx + i\n                    k_cell = k_field[j, i]\n                    \n                    # Volumetric heat source term\n                    b[k_idx] += q_source[j, i] * dx * dy * t\n                    \n                    # West face\n                    if i == 0:  # Left boundary (sink)\n                        G_sink = 2.0 * k_cell * dy * t / dx\n                        A[k_idx, k_idx] += G_sink\n                        b[k_idx] += G_sink * T_sink\n                    else: # Internal face\n                        k_neighbor = k_field[j, i - 1]\n                        k_w = 2.0 * k_cell * k_neighbor / (k_cell + k_neighbor)\n                        G_w = k_w * dy * t / dx\n                        A[k_idx, k_idx] += G_w\n                        A[k_idx, k_idx - 1] -= G_w\n                        \n                    # East face\n                    if i == Nx - 1: # Right boundary (convection)\n                        G_conv = h * dy * t\n                        A[k_idx, k_idx] += G_conv\n                        b[k_idx] += G_conv * T_inf\n                    else: # Internal face\n                        k_neighbor = k_field[j, i + 1]\n                        k_e = 2.0 * k_cell * k_neighbor / (k_cell + k_neighbor)\n                        G_e = k_e * dy * t / dx\n                        A[k_idx, k_idx] += G_e\n                        A[k_idx, k_idx + 1] -= G_e\n\n                    # South face\n                    if j == 0: # Bottom boundary (radiation)\n                        if eps > 0:\n                            T_old_cell = T_old[j, i]\n                            # Avoid division by zero if T_old is close to 0\n                            if T_old_cell  1e-6: T_old_cell = 1e-6\n                            \n                            h_rad = 4.0 * eps * sigma * (T_old_cell**3)\n                            T_rad_eff = (3.0 * T_old_cell**4 + T_sur**4) / (4.0 * T_old_cell**3)\n                            G_rad = h_rad * dx * t\n                            A[k_idx, k_idx] += G_rad\n                            b[k_idx] += G_rad * T_rad_eff\n                        # if eps=0, it's adiabatic (no flux), do nothing\n                    else: # Internal face\n                        k_neighbor = k_field[j - 1, i]\n                        k_s = 2.0 * k_cell * k_neighbor / (k_cell + k_neighbor)\n                        G_s = k_s * dx * t / dy\n                        A[k_idx, k_idx] += G_s\n                        A[k_idx, k_idx - Nx] -= G_s\n                        \n                    # North face\n                    if j == Ny - 1: # Top boundary (convection)\n                        G_conv = h * dx * t\n                        A[k_idx, k_idx] += G_conv\n                        b[k_idx] += G_conv * T_inf\n                    else: # Internal face\n                        k_neighbor = k_field[j + 1, i]\n                        k_n = 2.0 * k_cell * k_neighbor / (k_cell + k_neighbor)\n                        G_n = k_n * dx * t / dy\n                        A[k_idx, k_idx] += G_n\n                        A[k_idx, k_idx + Nx] -= G_n\n            \n            # Solve the linear system\n            A_csc = csc_matrix(A)\n            T_flat = spsolve(A_csc, b)\n            T = T_flat.reshape((Ny, Nx))\n            \n            # Check for convergence\n            max_diff = np.max(np.abs(T - T_old))\n            if max_diff  tol:\n                break\n        \n        # ----------------------------------------------------------------------\n        # 4. Calculate Energy Balance Residual\n        # ----------------------------------------------------------------------\n        \n        # Total power input from volumetric generation\n        P_in = np.sum(q_source) * dx * dy * t\n        \n        # Power removal at the sink (left boundary)\n        P_sink = 0.0\n        for j in range(Ny):\n            k_cell = k_field[j, 0]\n            G_sink = 2.0 * k_cell * dy * t / dx\n            P_sink += G_sink * (T[j, 0] - T_sink)\n            \n        # Power removal by convection (top and right boundaries)\n        P_conv = 0.0\n        # a) Top boundary\n        if h > 0:\n            for i in range(Nx):\n                P_conv += h * (T[Ny - 1, i] - T_inf) * dx * t\n            # b) Right boundary\n            for j in range(Ny):\n                P_conv += h * (T[j, Nx - 1] - T_inf) * dy * t\n            \n        # Power removal by radiation (bottom boundary)\n        P_rad = 0.0\n        if eps > 0:\n            for i in range(Nx):\n                P_rad += eps * sigma * (T[0, i]**4 - T_sur**4) * dx * t\n        \n        # Total power output\n        P_out = P_sink + P_conv + P_rad\n        \n        # Energy balance residual\n        residual = abs(P_in - P_out)\n        results.append(f\"{residual:.6g}\")\n\n    # Final print statement\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "有了可靠的正向求解器，基于梯度的优化下一步便是计算目标函数相对于设计变量的变化率，即“灵敏度”。本练习  将应用强大的伴随法，为一个非线性热问题高效地计算灵敏度。更关键的是，它还引入了复步法作为验证伴随法灵敏度正确性的“黄金标准”，这是开发可靠优化代码的一项必备技能。",
            "id": "3998277",
            "problem": "考虑在区域 $[0,L]$ 上的一个一维稳态热传导问题，其两端温度为给定值。状态变量 $T(x)$ 满足能量平衡定律和 Fourier 热传导定律，得到如下非线性边值问题：\n$$\n\\frac{d}{dx}\\left(k(T,\\theta)\\frac{dT}{dx}\\right) + q(x) = 0,\\quad x\\in(0,L),\n$$\n满足狄利克雷边界条件\n$$\nT(0)=T_{\\mathrm{left}},\\quad T(L)=T_{\\mathrm{right}}.\n$$\n热导率是温度和参数的函数，\n$$\nk(T,\\theta) = k_0 + \\theta\\,\\exp\\left(\\beta\\,T\\right),\n$$\n其中 $k_00$ 是基准热导率，$\\beta0$ 是温度敏感性系数，$\\theta$ 是影响热导率的一个设计参数。目标泛函，在拓扑优化中称为热柔度，其表达式为：\n$$\nJ(T) = \\int_0^L q(x)\\,T(x)\\,dx,\n$$\n其中 $q(x)$ 是给定的体热源分布。\n\n您的任务是：\n1. 从能量平衡和 Fourier 定律出发，使用二阶中心差分法，在包含 $N$ 个区间的均匀网格（网格间距 $h=L/N$）上推导离散残差，其中界面热导率通过算术平均值计算。对于内部节点 $i=1,\\dots,N-1$，定义用于强制执行离散化能量平衡的离散残差 $F_i(T,\\theta)$。\n2. 通过对残差关于内部节点温度进行微分，推导内部节点的离散雅可比矩阵 $\\partial F/\\partial T$，并完全考虑 $k$ 对 $T$ 的依赖性。同时，通过对残差关于 $\\theta$ 进行微分，推导内部节点的向量 $\\partial F/\\partial\\theta$。\n3. 使用离散梯形法则定义离散目标函数 $J_h(T)$，并通过伴随方法推导离散灵敏度 $\\frac{dJ_h}{d\\theta}$。引入求解以下线性系统的伴随向量 $\\lambda$：\n$$\n\\left(\\frac{\\partial F}{\\partial T}\\right)^{\\!\\top} \\lambda = \\frac{\\partial J_h}{\\partial T},\n$$\n并证明\n$$\n\\frac{dJ_h}{d\\theta} = -\\,\\lambda^{\\top}\\,\\frac{\\partial F}{\\partial \\theta}.\n$$\n解释与固定温度边界相一致的伴随问题的边界条件。\n4. 实现牛顿法，在网格上求解关于 $T(x)$ 的非线性正问题。使用推导出的离散残差和雅可比矩阵。然后实现伴随灵敏度计算。\n5. 使用复步微分估计来验证伴随灵敏度。具体来说，使用复数运算计算在 $\\theta + \\mathrm{i}\\,\\varepsilon$（其中 $\\varepsilon$ 是一个小的正实数）处的 $J_h$，并报告以下估计值：\n$$\n\\left.\\frac{dJ_h}{d\\theta}\\right|_{\\mathrm{csd}} \\approx \\frac{\\operatorname{Im}\\,J_h\\!\\left(T(\\theta+\\mathrm{i}\\,\\varepsilon)\\right)}{\\varepsilon}.\n$$\n\n使用以下科学上一致且自洽的参数集作为测试套件。对于每个测试用例，您必须：\n- 求解正问题以获得 $T(x)$。\n- 计算伴随灵敏度 $\\frac{dJ_h}{d\\theta}$。\n- 使用 $\\varepsilon=10^{-30}$ 计算复步灵敏度估计。\n- 输出伴随灵敏度与复步灵敏度估计之间的绝对差，格式为浮点数。\n\n所有物理量均使用国际单位制。程序的最终输出应为无量纲的绝对差。热源定义为：\n$$\nq(x) = q_0\\left(1 + \\sin\\left(\\pi x/L\\right)\\right),\n$$\n其中 $q_0\\ge 0$。\n\n测试套件参数集：\n- 用例 A (一般非线性传导): $L=0.1\\,\\mathrm{m}$, $N=200$, $k_0=10\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$, $\\beta=10^{-2}\\,\\mathrm{K}^{-1}$, $\\theta=5\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$, $q_0=10^6\\,\\mathrm{W}/\\mathrm{m}^3$, $T_{\\mathrm{left}}=300\\,\\mathrm{K}$, $T_{\\mathrm{right}}=310\\,\\mathrm{K}$。\n- 用例 B (零源边界情况): $L=0.1\\,\\mathrm{m}$, $N=200$, $k_0=10\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$, $\\beta=10^{-2}\\,\\mathrm{K}^{-1}$, $\\theta=3\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$, $q_0=0\\,\\mathrm{W}/\\mathrm{m}^3$, $T_{\\mathrm{left}}=300\\,\\mathrm{K}$, $T_{\\mathrm{right}}=300\\,\\mathrm{K}$。\n- 用例 C (更强非线性): $L=0.1\\,\\mathrm{m}$, $N=200$, $k_0=10\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$, $\\beta=5\\times10^{-2}\\,\\mathrm{K}^{-1}$, $\\theta=8\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$, $q_0=5\\times10^5\\,\\mathrm{W}/\\mathrm{m}^3$, $T_{\\mathrm{left}}=280\\,\\mathrm{K}$, $T_{\\mathrm{right}}=320\\,\\mathrm{K}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[resultA,resultB,resultC]”），列表中的每个结果是相应测试用例的伴随灵敏度与复步灵敏度之间的绝对差，表示为浮点数。",
            "solution": "该问题已经过验证，被认为是科学上可靠、适定且自洽的。因此，我们可以着手提供一个完整的解法。\n\n解法分为五个部分：\n1.  使用有限差分法推导控制非线性边值问题的离散残差。\n2.  推导牛顿-拉夫逊求解方法所需的雅可比矩阵和参数导数向量。\n3.  推导热柔度目标泛函的伴随灵敏度公式。\n4.  描述数值实现，包括使用牛顿求解器求解正问题和使用伴随方法计算灵敏度。\n5.  解释用于验证伴随灵敏度结果的复步方法。\n\n### 1. 离散化与离散残差\n\n一维区域 $[0, L]$ 被离散化为一个包含 $N$ 个区间的均匀网格，从而产生 $N+1$ 个网格点 $x_i = i \\cdot h$（其中 $i=0, 1, \\dots, N$），$h=L/N$ 是网格间距。内部节点处的温度 $T_1, \\dots, T_{N-1}$ 是未知数，而边界温度 $T_0 = T_{\\mathrm{left}}$ 和 $T_N = T_{\\mathrm{right}}$ 是给定的。\n\n控制方程为：\n$$\n\\frac{d}{dx}\\left(k(T,\\theta)\\frac{dT}{dx}\\right) + q(x) = 0\n$$\n我们通过在每个内部节点 $x_i$ 周围的控制体 $[x_{i-1/2}, x_{i+1/2}]$ 上对该方程进行积分，来应用有限体积/有限差分法：\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\left(\\frac{d}{dx}\\left(k\\frac{dT}{dx}\\right) + q(x)\\right) dx = 0\n$$\n这得到：\n$$\n\\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i+1/2}} - \\left. \\left(k\\frac{dT}{dx}\\right) \\right|_{x_{i-1/2}} + \\int_{x_{i-1/2}}^{x_{i+1/2}} q(x) dx \\approx 0\n$$\n使用二阶中心差分来处理导数，并使用中点法则来处理积分，我们得到节点 $i$ 处的离散方程：\n$$\nk_{i+1/2} \\frac{T_{i+1} - T_i}{h} - k_{i-1/2} \\frac{T_i - T_{i-1}}{h} + q_i h = 0\n$$\n其中 $T_i = T(x_i)$，$q_i = q(x_i)$，并且 $k_{i\\pm1/2}$ 是控制体界面上的热导率。根据题目要求，界面热导率通过相邻节点热导率的算术平均值来计算：\n$$\nk_{i+1/2} = \\frac{k(T_i, \\theta) + k(T_{i+1}, \\theta)}{2} \\equiv \\frac{k_i + k_{i+1}}{2}\n$$\n将此代入平衡方程并除以 $h$ 得到：\n$$\n\\frac{1}{2h^2} \\left[ (k_i + k_{i+1}) (T_{i+1} - T_i) - (k_{i-1} + k_i) (T_i - T_{i-1}) \\right] + q_i = 0\n$$\n对于每个内部节点 $i \\in \\{1, \\dots, N-1\\}$，离散残差定义为该方程的左侧。令 $\\mathbf{T}$ 为内部温度向量 $[T_1, \\dots, T_{N-1}]^T$。节点 $i$ 的残差 $F_i(\\mathbf{T}, \\theta)$ 为：\n$$\nF_i(\\mathbf{T}, \\theta) = \\frac{1}{2h^2} \\left[ (k_i + k_{i+1}) (T_{i+1} - T_i) - (k_{i-1} + k_i) (T_i - T_{i-1}) \\right] + q_i\n$$\n对于 $i=1$，$T_{i-1}$ 是固定的边界值 $T_0 = T_{\\mathrm{left}}$。对于 $i=N-1$，$T_{i+1}$ 是固定的边界值 $T_N = T_{\\mathrm{right}}$。\n\n### 2. 雅可比矩阵与参数导数\n\n为使用牛顿法求解非线性系统 $\\mathbf{F}(\\mathbf{T}, \\theta) = \\mathbf{0}$，我们需要雅可比矩阵 $\\mathcal{J} = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{T}}$ 和参数导数向量 $\\frac{\\partial \\mathbf{F}}{\\partial \\theta}$。\n\n热导率函数为 $k(T, \\theta) = k_0 + \\theta \\exp(\\beta T)$。其偏导数为：\n$$\n\\frac{\\partial k}{\\partial T}(T, \\theta) = \\theta \\beta \\exp(\\beta T) \\equiv k'(T)\n$$\n$$\n\\frac{\\partial k}{\\partial \\theta}(T, \\theta) = \\exp(\\beta T)\n$$\n雅可比矩阵 $\\mathcal{J}$ 是一个 $(N-1) \\times (N-1)$ 矩阵，其元素为 $\\mathcal{J}_{ij} = \\frac{\\partial F_i}{\\partial T_j}$。由于 $F_i$ 仅依赖于 $T_{i-1}, T_i, T_{i+1}$，因此雅可比矩阵是三对角的。对于行 $i$（对应于 $F_i$）的非零元素为：\n\n- **对角线项 ($j=i$):**\n$$\n\\frac{\\partial F_i}{\\partial T_i} = \\frac{1}{2h^2} \\frac{\\partial}{\\partial T_i} \\left[ (k_i + k_{i+1}) (T_{i+1} - T_i) - (k_{i-1} + k_i) (T_i - T_{i-1}) \\right]\n$$\n$$\n\\frac{\\partial F_i}{\\partial T_i} = \\frac{1}{2h^2} \\left[ k'_i (T_{i+1} - T_i) - (k_i + k_{i+1}) - k'_i (T_i - T_{i-1}) - (k_{i-1} + k_i) \\right]\n$$\n\n- **上对角线项 ($j=i+1$):** (对于 $i  N-1$)\n$$\n\\frac{\\partial F_i}{\\partial T_{i+1}} = \\frac{1}{2h^2} \\frac{\\partial}{\\partial T_{i+1}} \\left[ (k_i + k_{i+1}) (T_{i+1} - T_i) \\right] = \\frac{1}{2h^2} \\left[ k'_{i+1} (T_{i+1} - T_i) + (k_i + k_{i+1}) \\right]\n$$\n\n- **下对角线项 ($j=i-1$):** (对于 $i > 1$)\n$$\n\\frac{\\partial F_i}{\\partial T_{i-1}} = \\frac{1}{2h^2} \\frac{\\partial}{\\partial T_{i-1}} \\left[ -(k_{i-1} + k_i) (T_i - T_{i-1}) \\right] = \\frac{1}{2h^2} \\left[ -k'_{i-1} (T_i - T_{i-1}) + (k_{i-1} + k_i) \\right]\n$$\n\n残差向量关于设计参数 $\\theta$ 的导数是一个向量，其分量为：\n$$\n\\frac{\\partial F_i}{\\partial \\theta} = \\frac{1}{2h^2} \\left[ \\left(\\frac{\\partial k_i}{\\partial \\theta} + \\frac{\\partial k_{i+1}}{\\partial \\theta}\\right) (T_{i+1} - T_i) - \\left(\\frac{\\partial k_{i-1}}{\\partial \\theta} + \\frac{\\partial k_i}{\\partial \\theta}\\right) (T_i - T_{i-1}) \\right]\n$$\n$$\n\\frac{\\partial F_i}{\\partial \\theta} = \\frac{1}{2h^2} \\left[ (\\exp(\\beta T_i) + \\exp(\\beta T_{i+1})) (T_{i+1} - T_i) - (\\exp(\\beta T_{i-1}) + \\exp(\\beta T_i)) (T_i - T_{i-1}) \\right]\n$$\n\n### 3. 伴随灵敏度分析\n\n目标泛函 $J(T) = \\int_0^L q(x) T(x) dx$ 在网格 $x_0, \\dots, x_N$ 上使用梯形法则进行离散化：\n$$\nJ_h(\\mathbf{T}) = h \\left( \\frac{q_0 T_0 + q_N T_N}{2} + \\sum_{i=1}^{N-1} q_i T_i \\right)\n$$\n状态方程决定了 $\\mathbf{T}$ 是 $\\theta$ 的隐函数，即 $\\mathbf{T} = \\mathbf{T}(\\theta)$，满足 $\\mathbf{F}(\\mathbf{T}(\\theta), \\theta) = \\mathbf{0}$。我们寻求全导数 $\\frac{dJ_h}{d\\theta}$。应用链式法则：\n$$\n\\frac{dJ_h}{d\\theta} = \\frac{\\partial J_h}{\\partial \\theta} + \\frac{\\partial J_h}{\\partial \\mathbf{T}} \\frac{d\\mathbf{T}}{d\\theta}\n$$\n由于 $J_h$ 对 $\\theta$ 没有显式依赖，$\\frac{\\partial J_h}{\\partial \\theta}=0$。状态方程对 $\\theta$ 的导数给出：\n$$\n\\frac{d\\mathbf{F}}{d\\theta} = \\frac{\\partial \\mathbf{F}}{\\partial \\theta} + \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{T}} \\frac{d\\mathbf{T}}{d\\theta} = \\mathbf{0} \\implies \\frac{d\\mathbf{T}}{d\\theta} = - \\left( \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{T}} \\right)^{-1} \\frac{\\partial \\mathbf{F}}{\\partial \\theta}\n$$\n将此代入灵敏度表达式，得到直接法：\n$$\n\\frac{dJ_h}{d\\theta} = - \\frac{\\partial J_h}{\\partial \\mathbf{T}} \\left( \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{T}} \\right)^{-1} \\frac{\\partial \\mathbf{F}}{\\partial \\theta}\n$$\n伴随方法通过将伴随向量 $\\boldsymbol{\\lambda}$ 定义为以下线性系统的解来避免显式的矩阵求逆：\n$$\n\\left( \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{T}} \\right)^\\top \\boldsymbol{\\lambda} = \\left( \\frac{\\partial J_h}{\\partial \\mathbf{T}} \\right)^\\top\n$$\n右侧是目标函数梯度的转置，其分量为 $\\frac{\\partial J_h}{\\partial T_j} = h q_j$（对于 $j=1, \\dots, N-1$）。\n如此定义 $\\boldsymbol{\\lambda}$ 后，我们可以写出 $\\boldsymbol{\\lambda}^\\top = \\frac{\\partial J_h}{\\partial \\mathbf{T}} \\left( \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{T}} \\right)^{-1}$。将此代入直接灵敏度公式，得到伴随灵敏度表达式：\n$$\n\\frac{dJ_h}{d\\theta} = - \\boldsymbol{\\lambda}^\\top \\frac{\\partial \\mathbf{F}}{\\partial \\theta}\n$$\n这种方法计算效率很高，无论设计参数的数量多少，都只需要求解一个线性系统（伴随方程）。\n\n伴随问题的边界条件通过此公式隐式处理。原始变量是 $N-1$ 个内部温度，因此雅可比矩阵 $\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{T}}$ 是一个 $(N-1) \\times (N-1)$ 矩阵。因此，伴随向量 $\\boldsymbol{\\lambda}$ 也有 $N-1$ 个分量，对应于内部节点。这是在连续伴随问题上施加齐次狄利克雷边界条件（即 $\\lambda(0)=0, \\lambda(L)=0$）的离散模拟，这在原始问题具有固定（狄利克雷）边界条件时是正确的条件。\n\n### 4. 数值实现\n非线性正问题 $\\mathbf{F}(\\mathbf{T}, \\theta) = \\mathbf{0}$ 使用牛顿法求解。从一个初始猜测 $\\mathbf{T}^{(0)}$（例如，线性分布）开始，我们通过求解以下线性系统来迭代计算更新量 $\\Delta \\mathbf{T}^{(k)}$：\n$$\n\\mathcal{J}(\\mathbf{T}^{(k)}) \\Delta \\mathbf{T}^{(k)} = - \\mathbf{F}(\\mathbf{T}^{(k)})\n$$\n并更新解 $\\mathbf{T}^{(k+1)} = \\mathbf{T}^{(k)} + \\Delta \\mathbf{T}^{(k)}$，直到残差 $\\mathbf{F}$ 的范数低于指定的容差。由于雅可比矩阵 $\\mathcal{J}$ 是三对角的，每次迭代中的线性系统都可以使用带状矩阵求解器高效求解。\n\n一旦正问题收敛到解 $\\mathbf{T}$，伴随灵敏度通过以下步骤计算：\n1.  在收敛的温度 $\\mathbf{T}$ 处组装雅可比矩阵 $\\mathcal{J}$。\n2.  组装目标函数梯度向量 $\\left( \\frac{\\partial J_h}{\\partial \\mathbf{T}} \\right)^\\top$。\n3.  求解线性伴随系统 $\\mathcal{J}^\\top \\boldsymbol{\\lambda} = \\left( \\frac{\\partial J_h}{\\partial \\mathbf{T}} \\right)^\\top$ 以获得伴随向量 $\\boldsymbol{\\lambda}$。三对角矩阵的转置仍然是三对角的，因此该系统也可以高效求解。\n4.  组装参数导数向量 $\\frac{\\partial \\mathbf{F}}{\\partial \\theta}$。\n5.  将最终灵敏度计算为点积 $\\frac{dJ_h}{d\\theta} = - \\boldsymbol{\\lambda} \\cdot \\frac{\\partial \\mathbf{F}}{\\partial \\theta}$。\n\n### 5. 复步验证\n伴随灵敏度通过复步微分（CSD）方法进行验证，该方法提供了一个高度准确的数值导数估计，且没有有限差分中的相消误差。过程如下：\n1.  用一个小的虚数步长扰动设计参数 $\\theta$：$\\theta_c = \\theta + i \\varepsilon$，其中 $\\varepsilon$ 是一个非常小的实数（例如，$10^{-30}$）。\n2.  求解正问题 $\\mathbf{F}(\\mathbf{T}_c, \\theta_c) = \\mathbf{0}$ 以获得复数值的温度场 $\\mathbf{T}_c$。这通过使用相同的牛顿求解器完成，但所有变量和运算都在复数域上定义。实数值的边界条件被视为虚部为零的复数。\n3.  计算复数值的目标函数 $J_h(\\mathbf{T}_c)$。\n4.  灵敏度通过结果的虚部进行估计：\n$$\n\\left.\\frac{dJ_h}{d\\theta}\\right|_{\\mathrm{csd}} = \\frac{\\operatorname{Im}[J_h(\\mathbf{T}(\\theta + i\\varepsilon))]}{\\varepsilon}\n$$\n该结果基于复解析函数的泰勒级数展开，其精度可达机器精度。伴随结果与 CSD 结果之间的绝对差可作为对所推导和实现的伴随灵敏度表达式正确性的稳健验证。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\n# Handle numpy.complex deprecation for compatibility\nnp.complex = np.complex128 if hasattr(np, 'complex') else complex\n\ndef get_k(T, theta, beta, k0):\n    \"\"\"Computes thermal conductivity k(T, theta).\"\"\"\n    return k0 + theta * np.exp(beta * T)\n\ndef get_k_prime_T(T, theta, beta):\n    \"\"\"Computes derivative of k w.r.t. T.\"\"\"\n    return theta * beta * np.exp(beta * T)\n\ndef get_dk_dtheta(T, beta):\n    \"\"\"Computes derivative of k w.r.t. theta.\"\"\"\n    return np.exp(beta * T)\n\ndef assemble_system(T_full, params, dtype=np.float64):\n    \"\"\"\n    Assembles the residual F and the Jacobian J for the interior nodes.\n    T_full is the temperature vector of size N+1 including boundaries.\n    \"\"\"\n    N, h, k0, beta, theta, q_vec = params['N'], params['h'], params['k0'], params['beta'], params['theta'], params['q_vec']\n    \n    num_unknowns = N - 1\n    F = np.zeros(num_unknowns, dtype=dtype)\n    # Banded Jacobian: J_banded[0,:]=upper, J_banded[1,:]=main, J_banded[2,:]=lower\n    J_banded = np.zeros((3, num_unknowns), dtype=dtype)\n    \n    # Pre-compute k and its derivatives for all nodes\n    k = get_k(T_full, theta, beta, k0)\n    k_prime_T = get_k_prime_T(T_full, theta, beta)\n    \n    c = 1.0 / (2.0 * h**2)\n\n    for i in range(1, N): # Loop over interior nodes\n        idx = i - 1 # 0-based index for F and J\n        \n        # Temperatures\n        T_im1, T_i, T_ip1 = T_full[i-1], T_full[i], T_full[i+1]\n        \n        # Conductivities\n        k_im1, k_i, k_ip1 = k[i-1], k[i], k[i+1]\n        \n        # Residual F_i\n        term1 = (k_i + k_ip1) * (T_ip1 - T_i)\n        term2 = (k_im1 + k_i) * (T_i - T_im1)\n        F[idx] = c * (term1 - term2) + q_vec[i]\n        \n        # Jacobian entries for F_i\n        \n        # Main diagonal: dF_i/dT_i\n        dkp_dT_i = k_prime_T[i]\n        J_banded[1, idx] = c * (dkp_dT_i * (T_ip1 - T_i) - (k_i + k_ip1) - dkp_dT_i * (T_i - T_im1) - (k_im1 + k_i))\n\n        # Upper diagonal: dF_i/dT_{i+1}\n        if i  N - 1:\n            dkp_dT_ip1 = k_prime_T[i+1]\n            J_banded[0, idx + 1] = c * (dkp_dT_ip1 * (T_ip1 - T_i) + (k_i + k_ip1))\n\n        # Lower diagonal: dF_i/dT_{i-1}\n        if i > 1:\n            dkp_dT_im1 = k_prime_T[i-1]\n            J_banded[2, idx - 1] = c * (-dkp_dT_im1 * (T_i - T_im1) + (k_im1 + k_i))\n\n    return F, J_banded\n\ndef solve_forward(params, dtype=np.float64):\n    \"\"\"\n    Solves the nonlinear forward problem T(x) using Newton's method.\n    \"\"\"\n    N, L, T_left, T_right = params['N'], params['L'], params['T_left'], params['T_right']\n    \n    # Initial guess: linear temperature profile\n    T_full = np.linspace(T_left, T_right, N + 1, dtype=dtype)\n    \n    # Newton's method\n    max_iter = 50\n    tol = 1e-10\n    for it in range(max_iter):\n        T_interior = T_full[1:-1]\n        F, J_banded = assemble_system(T_full, params, dtype)\n        \n        res_norm = np.linalg.norm(F)\n        if res_norm  tol:\n            break\n        \n        # Solve J * delta_T = -F\n        delta_T = solve_banded((1, 1), J_banded, -F)\n        T_interior += delta_T\n        T_full[1:-1] = T_interior\n    \n    return T_full\n\ndef compute_adjoint_sensitivity(T_full, params):\n    \"\"\"\n    Computes dJ/dtheta using the adjoint method.\n    \"\"\"\n    N, h, k0, beta, theta, q_vec = params['N'], params['h'], params['k0'], params['beta'], params['theta'], params['q_vec']\n    num_unknowns = N - 1\n    \n    # 1. Get Jacobian at converged T\n    _, J_banded = assemble_system(T_full, params, dtype=np.float64)\n    \n    # 2. Compute dJ/dT (RHS of adjoint equation)\n    dJ_dT = h * q_vec[1:-1]\n    \n    # 3. Solve adjoint system J^T * lambda = dJ/dT\n    # For J^T, the upper and lower diagonals are swapped.\n    J_T_banded = np.zeros_like(J_banded)\n    J_T_banded[1, :] = J_banded[1, :]\n    J_T_banded[0, 1:] = J_banded[2, :-1]\n    J_T_banded[2, :-1] = J_banded[0, 1:]\n    \n    adjoint_lambda = solve_banded((1, 1), J_T_banded, dJ_dT)\n    \n    # 4. Compute dF/dtheta\n    dF_dtheta = np.zeros(num_unknowns, dtype=np.float64)\n    exp_beta_T = get_dk_dtheta(T_full, beta)\n    \n    c = 1.0 / (2.0 * h**2)\n    for i in range(1, N):\n        idx = i - 1\n        T_im1, T_i, T_ip1 = T_full[i-1], T_full[i], T_full[i+1]\n        exp_im1, exp_i, exp_ip1 = exp_beta_T[i-1], exp_beta_T[i], exp_beta_T[i+1]\n        \n        term1 = (exp_i + exp_ip1) * (T_ip1 - T_i)\n        term2 = (exp_im1 + exp_i) * (T_i - T_im1)\n        dF_dtheta[idx] = c * (term1 - term2)\n        \n    # 5. Compute sensitivity\n    sensitivity = -np.dot(adjoint_lambda, dF_dtheta)\n    \n    return sensitivity\n\ndef compute_cs_sensitivity(params, epsilon=1e-30):\n    \"\"\"\n    Computes dJ/dtheta using the complex-step method.\n    \"\"\"\n    # Create a complex copy of params\n    params_cs = params.copy()\n    params_cs['theta'] = params['theta'] + 1j * epsilon\n    params_cs['T_left'] = complex(params['T_left'])\n    params_cs['T_right'] = complex(params['T_right'])\n\n    # Solve forward problem with complex arithmetic\n    T_full_cs = solve_forward(params_cs, dtype=np.complex128)\n    \n    # Compute complex objective function J_h\n    h, N, q_vec = params_cs['h'], params_cs['N'], params_cs['q_vec']\n    J_h_cs = h * ( (q_vec[0] * T_full_cs[0] + q_vec[N] * T_full_cs[N]) / 2.0 + np.sum(q_vec[1:-1] * T_full_cs[1:-1]) )\n\n    # Estimate derivative\n    sensitivity = np.imag(J_h_cs) / epsilon\n    \n    return sensitivity\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'L': 0.1, 'N': 200, 'k0': 10.0, 'beta': 1e-2, 'theta': 5.0, 'q0': 1e6, 'T_left': 300.0, 'T_right': 310.0},\n        # Case B\n        {'L': 0.1, 'N': 200, 'k0': 10.0, 'beta': 1e-2, 'theta': 3.0, 'q0': 0.0, 'T_left': 300.0, 'T_right': 300.0},\n        # Case C\n        {'L': 0.1, 'N': 200, 'k0': 10.0, 'beta': 5e-2, 'theta': 8.0, 'q0': 5e5, 'T_left': 280.0, 'T_right': 320.0},\n    ]\n\n    results = []\n    \n    for case_params in test_cases:\n        N = case_params['N']\n        L = case_params['L']\n        q0 = case_params['q0']\n        h = L / N\n        case_params['h'] = h\n        \n        x_vec = np.linspace(0, L, N + 1)\n        q_vec = q0 * (1 + np.sin(np.pi * x_vec / L))\n        case_params['q_vec'] = q_vec\n        \n        # 1. Solve real forward problem\n        T_real = solve_forward(case_params, dtype=np.float64)\n        \n        # 2. Compute adjoint sensitivity\n        adj_sens = compute_adjoint_sensitivity(T_real, case_params)\n        \n        # 3. Compute complex-step sensitivity for validation\n        cs_sens = compute_cs_sensitivity(case_params)\n        \n        # 4. Calculate absolute difference and store\n        abs_diff = np.abs(adj_sens - cs_sens)\n        results.append(abs_diff)\n        \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}