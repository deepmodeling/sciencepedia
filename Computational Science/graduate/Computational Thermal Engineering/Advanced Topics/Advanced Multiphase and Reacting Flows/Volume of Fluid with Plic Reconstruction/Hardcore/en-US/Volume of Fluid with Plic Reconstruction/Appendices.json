{
    "hands_on_practices": [
        {
            "introduction": "The foundation of the Piecewise Linear Interface Construction (PLIC) method lies in its ability to reconstruct a sharp, planar interface within a computational cell that honors the known volume fraction of a fluid. This first practice is a fundamental analytical exercise that builds this core connection. By deriving the relationship between the volume fraction $C$ and the plane constant $d$ for a simple geometric configuration, you will gain direct insight into the inverse problem that every VOF-PLIC implementation must solve. ",
            "id": "3336377",
            "problem": "Consider the Volume of Fluid (VOF) interface capturing strategy with the Piecewise Linear Interface Construction (PLIC) reconstruction in a uniform Cartesian cell. In the PLIC approach, the interface inside a given cell is reconstructed as a plane described by $\\mathbf{n}\\cdot\\mathbf{x}=d$, where $\\mathbf{n}$ is a unit normal vector estimated from the volume fraction field and $d$ is a plane constant chosen to match the known cell volume fraction. This contrasts with interface tracking methods (e.g., front-tracking) that explicitly advect a discretized interface.\n\nLet the cell be the unit cube $\\Omega=[0,1]^{3}$ in Cartesian coordinates and let the estimated unit normal be $\\mathbf{n}=(n_{x},n_{y},n_{z})$ with strictly positive components. The volume fraction $C\\in[0,1]$ denotes the fraction of $\\Omega$ occupied by the fluid on the side $\\mathbf{n}\\cdot\\mathbf{x}\\leq d$. Assume the regime in which the interface plane intersects the coordinate planes at the origin corner only, so that the fluid region $\\{\\,\\mathbf{x}\\in\\Omega:\\mathbf{n}\\cdot\\mathbf{x}\\leq d\\,\\}$ is a tetrahedron touching the origin; this occurs when $0\\leq d\\leq \\min\\{n_{x},n_{y},n_{z}\\}$.\n\nStarting from first principles (geometric or integral definitions of volume), derive the plane constant $d$ in terms of the given volume fraction $C$ and the normal components $n_{x}$, $n_{y}$, $n_{z}$ that yields the correct cut volume in this tetrahedral regime. Express your final answer as a single closed-form analytic expression. No rounding is required, and no units are necessary since the variables are dimensionless.",
            "solution": "The problem asks for the derivation of the plane constant $d$ for a PLIC interface reconstruction within a unit cubic cell, under the specific regime where the fluid-filled region forms a tetrahedron at the origin.\n\nThe problem is first validated to ensure it is scientifically sound, well-posed, and objective.\n\n**Step 1: Extract Givens**\n- Cell geometry: Unit cube $\\Omega = [0,1]^3$.\n- Interface plane equation: $\\mathbf{n} \\cdot \\mathbf{x} = d$, where $\\mathbf{n} = (n_x, n_y, n_z)$ is a unit normal vector with $n_x>0$, $n_y>0$, $n_z>0$.\n- Fluid region: $\\{\\mathbf{x} \\in \\Omega : \\mathbf{n} \\cdot \\mathbf{x} \\leq d\\}$.\n- Volume fraction: $C \\in [0,1]$.\n- Geometric regime: The fluid region is a tetrahedron with one vertex at the origin. This holds for $0 \\leq d \\leq \\min\\{n_x, n_y, n_z\\}$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is rooted in standard methods of computational fluid dynamics, specifically the Volume of Fluid (VOF) method with PLIC reconstruction. The geometric and mathematical setup is rigorous and based on fundamental principles of analytic geometry.\n- **Well-Posedness**: The problem provides all necessary information to establish a unique relationship between the volume fraction $C$ and the plane constant $d$. The goal is to invert this relationship, which is possible as the volume is a monotonic function of $d$.\n- **Objectivity**: The language is precise and devoid of any subjectivity.\n- **Completeness and Consistency**: The givens are sufficient and consistent. The condition $0 \\leq d \\leq \\min\\{n_x, n_y, n_z\\}$ correctly ensures that the plane's intercepts with the axes lie within the unit cube's boundaries emanating from the origin, thus forming a simple tetrahedron.\n- **Verdict**: The problem is valid.\n\n**Step 3: Derivation of the Solution**\n\nThe derivation proceeds from the geometric definition of the fluid volume.\n\n1.  **Identify the Geometry and Vertices**:\n    The fluid region is defined by the inequalities $x \\ge 0$, $y \\ge 0$, $z \\ge 0$, and $n_x x + n_y y + n_z z \\le d$. This region is a tetrahedron. One vertex of this tetrahedron is the origin, $O=(0,0,0)$. The other three vertices are the points where the plane $\\mathbf{n} \\cdot \\mathbf{x} = d$ intersects the coordinate axes.\n    -   Intersection with the x-axis ($y=0, z=0$):\n        $n_x x = d \\implies x_0 = \\frac{d}{n_x}$. The vertex is $P_x = (\\frac{d}{n_x}, 0, 0)$.\n    -   Intersection with the y-axis ($x=0, z=0$):\n        $n_y y = d \\implies y_0 = \\frac{d}{n_y}$. The vertex is $P_y = (0, \\frac{d}{n_y}, 0)$.\n    -   Intersection with the z-axis ($x=0, y=0$):\n        $n_z z = d \\implies z_0 = \\frac{d}{n_z}$. The vertex is $P_z = (0, 0, \\frac{d}{n_z})$.\n    The problem condition $0 \\leq d \\leq \\min\\{n_x, n_y, n_z\\}$ ensures that these intercepts $x_0, y_0, z_0$ are all less than or equal to $1$, so the tetrahedron lies entirely within the unit cube $\\Omega$.\n\n2.  **Calculate the Volume**:\n    The volume $V$ of a tetrahedron with one vertex at the origin and the other three vertices on the coordinate axes at distances $x_0$, $y_0$, and $z_0$ from the origin is given by the formula:\n    $$ V = \\frac{1}{6} x_0 y_0 z_0 $$\n    Substituting the expressions for the intercepts found in the previous step:\n    $$ V = \\frac{1}{6} \\left(\\frac{d}{n_x}\\right) \\left(\\frac{d}{n_y}\\right) \\left(\\frac{d}{n_z}\\right) $$\n    $$ V = \\frac{d^3}{6 n_x n_y n_z} $$\n\n3.  **Relate Volume to Volume Fraction**:\n    The volume fraction $C$ is the ratio of the fluid volume $V$ to the total volume of the computational cell $V_{\\text{cell}}$. The cell is a unit cube, so its volume is $V_{\\text{cell}} = 1^3 = 1$.\n    Therefore, the volume fraction is numerically equal to the fluid volume:\n    $$ C = \\frac{V}{V_{\\text{cell}}} = \\frac{V}{1} = V $$\n    Equating the expressions for $C$ and $V$:\n    $$ C = \\frac{d^3}{6 n_x n_y n_z} $$\n\n4.  **Solve for the Plane Constant $d$**:\n    The final step is to solve this equation for $d$. We rearrange the equation to isolate $d^3$:\n    $$ d^3 = 6 C n_x n_y n_z $$\n    Taking the cube root of both sides yields the desired expression for $d$ in terms of $C$, $n_x$, $n_y$, and $n_z$:\n    $$ d = (6 C n_x n_y n_z)^{\\frac{1}{3}} $$\n    This is the closed-form analytic expression for the plane constant $d$ in the specified tetrahedral regime.",
            "answer": "$$\\boxed{(6 C n_x n_y n_z)^{\\frac{1}{3}}}$$"
        },
        {
            "introduction": "While the previous exercise established the theoretical goal of reconstruction, a practical implementation requires a robust geometric engine. This hands-on coding problem tackles the 'forward problem': calculating the exact fluid volume (or area) produced by cutting a cell with a given plane. Mastering this step by developing a robust clipping algorithm that can handle a wide array of challenging geometric configurations is essential for building a reliable VOF-PLIC solver. ",
            "id": "4004146",
            "problem": "Consider the Volume of Fluid (VOF) method with Piecewise Linear Interface Construction (PLIC) reconstruction in a Cartesian mesh. In a single computational cell, the reconstructed interface is represented by a linear manifold: a line in two dimensions and a plane in three dimensions. Let the computational cell be the unit square in two dimensions, defined as $\\{(x,y)\\in\\mathbb{R}^2 \\mid 0 \\le x \\le 1, 0 \\le y \\le 1\\}$, and the unit cube in three dimensions, defined as $\\{(x,y,z)\\in\\mathbb{R}^3 \\mid 0 \\le x \\le 1, 0 \\le y \\le 1, 0 \\le z \\le 1\\}$. The PLIC interface is the set of points satisfying $n \\cdot \\mathbf{x} = \\alpha$, where $n$ is the interface normal vector and $\\alpha$ is a scalar offset, and the liquid phase occupies the half-space $n \\cdot \\mathbf{x} \\le \\alpha$ inside the cell. The local volume fraction in the cell must be equal to the measure (area in two dimensions, volume in three dimensions) of the intersection region between the half-space and the unit cell, normalized by the cell measure.\n\nThe objective is to devise and validate robust clipping algorithms that compute the intersection measure for extreme geometric configurations, consistent with conservation of volume fractions and linear interface representation. These algorithms must rely only on the intersection of convex polytopes with a half-space, starting from first principles: (i) conservation of mass implies that the volume fraction equals the fraction of cell measure occupied by the liquid region, (ii) the PLIC interface is linear, and (iii) convex polytopes intersected with half-spaces remain convex.\n\nDefine the following tasks:\n- For two dimensions, compute the area of the intersection set $R_2 = \\{(x,y) \\in [0,1]^2 \\mid n_x x + n_y y \\le \\alpha\\}$.\n- For three dimensions, compute the volume of the intersection set $R_3 = \\{(x,y,z) \\in [0,1]^3 \\mid n_x x + n_y y + n_z z \\le \\alpha\\}$.\n\nYour program must implement geometric clipping from first principles and produce results for the test suite below. The algorithms must be robust against:\n- Nearly tangent cuts where the interface barely intersects the cell, producing tiny sliver measures.\n- Normals aligned with coordinate axes, yielding axis-aligned half-spaces.\n- Cuts that pass close to edges and corners, stressing numerical tolerances.\n\nUse the following test suite. For each test case, compute the intersection measure in the unit cell and compare it to the provided expected value using a pass/fail criterion. All expected values are given in the same units as the measure: area in two dimensions and volume in three dimensions. No physical units or angle units are required.\n\nTwo-dimensional test cases (unit square):\n- Case $1$: $n = (1,0)$, $\\alpha = 0.37$, expected area $= 0.37$.\n- Case $2$: $n = (1,0)$, $\\alpha = -10^{-12}$, expected area $= 0$.\n- Case $3$: $n = (1,0)$, $\\alpha = 1.2$, expected area $= 1$.\n- Case $4$: $n = (1,1)$, $\\alpha = 0.5$, expected area $= 0.125$.\n- Case $5$: $n = (1,1)$, $\\alpha = 10^{-4}$, expected area $= 5 \\times 10^{-9}$.\n- Case $6$: $n = (1,1)$, $\\alpha = 1.99$, expected area $= 0.99995$.\n- Case $7$: $n = (0,1)$, $\\alpha = 0.65$, expected area $= 0.65$.\n\nThree-dimensional test cases (unit cube):\n- Case $8$: $n = (1,0,0)$, $\\alpha = 0.37$, expected volume $= 0.37$.\n- Case $9$: $n = (1,0,0)$, $\\alpha = -10^{-12}$, expected volume $= 0$.\n- Case $10$: $n = (1,0,0)$, $\\alpha = 1.2$, expected volume $= 1$.\n- Case $11$: $n = (1,1,1)$, $\\alpha = 0.5$, expected volume $= 0.020833333333333332$.\n- Case $12$: $n = (1,1,1)$, $\\alpha = 0.01$, expected volume $= 1.6666666666666667 \\times 10^{-7}$.\n- Case $13$: $n = (1,1,1)$, $\\alpha = 2.99$, expected volume $= 0.9999998333333334$.\n- Case $14$: $n = (0,1,0)$, $\\alpha = 0.65$, expected volume $= 0.65$.\n\nPass/fail criterion:\n- A test passes if the computed measure $m_{\\text{comp}}$ satisfies $\\lvert m_{\\text{comp}} - m_{\\text{exp}} \\rvert \\le \\max(\\varepsilon_{\\text{abs}}, \\varepsilon_{\\text{rel}} \\cdot \\max(1, \\lvert m_{\\text{exp}} \\rvert))$, with $\\varepsilon_{\\text{abs}} = 10^{-9}$ and $\\varepsilon_{\\text{rel}} = 10^{-9}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots,result_{14}]$), where each $result_i$ is a boolean indicating pass or fail for Case $i$ in the order listed above.",
            "solution": "The problem requires the computation of the measure (area in two dimensions, volume in three dimensions) of the intersection of a unit hypercube with a half-space. This is a classic problem in computational geometry, fundamental to the Piecewise Linear Interface Calculation (PLIC) scheme within the Volume of Fluid (VOF) method for multiphase flow simulation. The liquid phase is defined by the inequality $n \\cdot \\mathbf{x} \\le \\alpha$ within the unit cell $[0,1]^d$, where $d \\in \\{2, 3\\}$. The core of the task is to develop a robust algorithm based on first principles to calculate this measure for various geometric configurations of the interface plane, defined by the normal vector $n$ and offset $\\alpha$.\n\nThe solution is derived through a systematic reduction of the general problem to a canonical form for which an analytical solution exists. This approach ensures correctness and robustness.\n\n**1. Foundational Principles**\n\nThe algorithm is built upon the following principles:\n- The unit cell is a convex polytope $[0,1]^d$.\n- The liquid region is the intersection of this convex polytope with a half-space $n \\cdot \\mathbf{x} \\le \\alpha$, which results in another convex polytope.\n- The measure of a set is invariant under isometries (e.g., reflections).\n\n**2. Algorithmic Steps**\n\nThe overall algorithm proceeds in several stages:\n\n**Stage 1: Dimensionality Reduction**\nThe normal vector $n$ may have zero components. For instance, in three dimensions, if $n = (n_x, n_y, 0)$, the interface equation $n_x x + n_y y \\le \\alpha$ is independent of the $z$ coordinate. The volume of the liquid region is the area of the corresponding two-dimensional region in the $xy$-plane multiplied by the extent of the cell in the $z$-direction, which is $1$. In general, if some components of $n$ are zero, the problem can be solved in a lower-dimensional space spanned by the axes corresponding to the non-zero components of $n$. The resulting measure is identical. The algorithm first identifies the effective dimensions of the problem and proceeds with the reduced normal vector and dimension. A special case arises if all components of $n$ are zero, where the inequality becomes $0 \\le \\alpha$. The measure is $1$ if $\\alpha \\ge 0$ and $0$ if $\\alpha < 0$. If only one component $n_k$ is non-zero, the problem is one-dimensional, and the measure is simply a fraction of the cell length, computed as $\\text{clip}(\\alpha/n_k, 0, 1)$ if $n_k > 0$, or $\\text{clip}(1 - \\alpha/n_k, 0, 1)$ if $n_k < 0$.\n\n**Stage 2: Transformation to a Canonical Form**\nThe general problem can be simplified by transforming it into a canonical form where all components of the normal vector are non-negative. This is achieved through a series of volume-preserving reflections. For any dimension $i$ where $n_i < 0$, we apply the reflection $x_i \\to 1 - x'_i$. The domain for the new coordinate $x'_i$ remains $[0,1]$. The inequality $\\sum_j n_j x_j \\le \\alpha$ becomes:\n$$ \\sum_{j \\ne i} n_j x_j + n_i(1-x'_i) \\le \\alpha \\implies \\sum_{j \\ne i} n_j x_j - n_i x'_i \\le \\alpha - n_i $$\nBy defining a new normal vector $n'$ where $n'_i = -n_i > 0$ and a new offset $\\alpha' = \\alpha - n_i$, we obtain an equivalent problem with a non-negative normal component. This process is repeated for all dimensions with negative normal components. After this stage, we have a new problem defined by $(n', \\alpha')$ where all components of $n'$ are non-negative. The function $f(\\mathbf{x}) = n' \\cdot \\mathbf{x}$ is now monotonically increasing in all coordinates.\n\n**Stage 3: Bounding and Trivial Cases**\nFor the canonical problem with $n'_i \\ge 0$ for all $i$, the minimum value of $n' \\cdot \\mathbf{x}$ in the unit cell is at $\\mathbf{x}=(0,\\dots,0)$, which is $0$. The maximum value is at $\\mathbf{x}=(1,\\dots,1)$, which is $\\sum_i n'_i$. This allows for simple checks:\n- If $\\alpha' \\le 0$, the liquid region is empty (or of measure zero), so the measure is $0$.\n- If $\\alpha' \\ge \\sum_i n'_i$, the entire cell is filled, and the measure is $1$.\n\n**Stage 4: The Inclusion-Exclusion Formula for Volume Calculation**\nFor the non-trivial case where $0 < \\alpha' < \\sum_i n'_i$, the liquid region is a convex polytope formed by cutting the corner of the hypercube near the origin. The volume of such a shape can be calculated analytically. The volume of the simplex defined by $\\{\\mathbf{x} \\in \\mathbb{R}^d_+ \\mid n' \\cdot \\mathbf{x} \\le \\alpha'\\}$ (i.e., in the first orthant) is given by:\n$$ V_{\\text{simplex}} = \\frac{(\\alpha')^d}{d! \\prod_{i=1}^d n'_i} $$\nThis formula is valid for the portion of the simplex inside the unit hypercube only if the simplex does not extend beyond any face $x_i = 1$. To account for clipping by the hypercube faces, we use the inclusion-exclusion principle. The desired volume is the volume of the simplex in the first orthant minus the volumes of the regions that lie outside the hypercube (where one or more $x_i > 1$). This leads to the general formula for the measure $M$:\n$$ M(n', \\alpha', d) = \\frac{1}{\\prod_{i=1}^d n'_i} \\sum_{S \\subseteq \\{1, \\dots, d\\}} (-1)^{|S|} \\frac{\\left(\\alpha' - \\sum_{j \\in S} n'_j\\right)^d}{d!} H\\left(\\alpha' - \\sum_{j \\in S} n'_j\\right) $$\nHere, the sum is over all $2^d$ subsets $S$ of the dimension indices $\\{1, \\dots, d\\}$, and $H$ is the Heaviside step function, which is $1$ if its argument is positive and $0$ otherwise. This effectively prunes the sum to include only terms where the adjusted alpha is positive. The term for $S=\\emptyset$ is the initial simplex volume.\n\nThis systematic application of dimensionality reduction, canonical transformation, and the inclusion-exclusion principle provides a robust and mathematically sound algorithm capable of handling the full range of test cases, including those designed to stress numerical precision and geometric degeneracy.",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\nimport math\n\ndef compute_measure(n_orig, alpha_orig):\n    \"\"\"\n    Computes the measure (area in 2D, volume in 3D) of the region\n    n . x <= alpha inside the unit hypercube [0,1]^d.\n    \"\"\"\n    n = np.array(n_orig, dtype=float)\n    alpha = float(alpha_orig)\n    dim = len(n)\n    \n    # Epsilon for floating point comparisons\n    TOL = 1e-12\n\n    # Stage 1: Dimensionality Reduction\n    non_zero_indices = np.where(np.abs(n) > TOL)[0]\n    sub_dim = len(non_zero_indices)\n\n    if sub_dim == 0:\n        return 1.0 if alpha >= 0 else 0.0\n\n    # If the problem is effectively lower-dimensional, solve it in that subspace.\n    # The measure in the full space is the same.\n    if sub_dim < dim:\n        sub_n = n[non_zero_indices]\n        # Recursively call on the sub-problem\n        return compute_measure(sub_n, alpha)\n\n    # From here, dim = sub_dim and all components of n are non-zero.\n    \n    # Handle the 1D case explicitly for clarity, though it's covered by the \n    # transformation logic as well.\n    if dim == 1:\n        n0 = n[0]\n        if n0 > 0:\n            val = alpha / n0\n        else: # n0 < 0\n            # n0*x <= alpha => x >= alpha/n0.\n            # measure of x in [0,1] is 1 - alpha/n0\n            val = 1.0 - (alpha / n0)\n        return np.clip(val, 0.0, 1.0)\n        \n    # Stage 2: Transformation to a Canonical Form (all normal components non-negative)\n    n_prime = n.copy()\n    alpha_prime = alpha\n    for i in range(dim):\n        if n_prime[i] < 0:\n            alpha_prime -= n_prime[i]\n            n_prime[i] = -n_prime[i]\n\n    # After transformation, n_prime has all positive components.\n    \n    # Stage 3: Bounding and Trivial Cases for the canonical problem\n    if alpha_prime <= TOL:\n        return 0.0\n    if alpha_prime >= np.sum(n_prime):\n        return 1.0\n\n    # Stage 4: Inclusion-Exclusion Formula for measure calculation\n    total_volume_term = 0.0\n    \n    # Iterate over all subset sizes k = 0, 1, ..., dim\n    for k in range(dim + 1):\n        # The sign of the term in the inclusion-exclusion sum\n        term_sign = (-1)**k\n        \n        # Iterate over all subsets of indices of size k\n        for subset_indices in combinations(range(dim), k):\n            n_subset_sum = np.sum(n_prime[list(subset_indices)])\n            \n            current_alpha = alpha_prime - n_subset_sum\n            \n            # The Heaviside function H(...) implemented by this check\n            if current_alpha > TOL:\n                term = (current_alpha**dim)\n                total_volume_term += term_sign * term\n    \n    prod_n = np.prod(n_prime)\n    factorial_d = math.factorial(dim)\n    \n    final_measure = total_volume_term / (factorial_d * prod_n)\n    \n    return np.clip(final_measure, 0.0, 1.0)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # 2D cases\n        {'n': (1,0), 'alpha': 0.37, 'expected': 0.37, 'dim': 2},\n        {'n': (1,0), 'alpha': -1e-12, 'expected': 0.0, 'dim': 2},\n        {'n': (1,0), 'alpha': 1.2, 'expected': 1.0, 'dim': 2},\n        {'n': (1,1), 'alpha': 0.5, 'expected': 0.125, 'dim': 2},\n        {'n': (1,1), 'alpha': 1e-4, 'expected': 5e-9, 'dim': 2},\n        {'n': (1,1), 'alpha': 1.99, 'expected': 0.99995, 'dim': 2},\n        {'n': (0,1), 'alpha': 0.65, 'expected': 0.65, 'dim': 2},\n        # 3D cases\n        {'n': (1,0,0), 'alpha': 0.37, 'expected': 0.37, 'dim': 3},\n        {'n': (1,0,0), 'alpha': -1e-12, 'expected': 0.0, 'dim': 3},\n        {'n': (1,0,0), 'alpha': 1.2, 'expected': 1.0, 'dim': 3},\n        {'n': (1,1,1), 'alpha': 0.5, 'expected': 0.020833333333333332, 'dim': 3},\n        {'n': (1,1,1), 'alpha': 0.01, 'expected': 1.6666666666666667e-07, 'dim': 3},\n        {'n': (1,1,1), 'alpha': 2.99, 'expected': 0.9999998333333334, 'dim': 3},\n        {'n': (0,1,0), 'alpha': 0.65, 'expected': 0.65, 'dim': 3},\n    ]\n\n    eps_abs = 1e-9\n    eps_rel = 1e-9\n    \n    results = []\n    \n    for case in test_cases:\n        computed_measure = compute_measure(case['n'], case['alpha'])\n        expected_measure = case['expected']\n        \n        abs_error = abs(computed_measure - expected_measure)\n        \n        # Pass/fail criterion: |m_comp - m_exp| <= max(eps_abs, eps_rel * max(1, |m_exp|))\n        tolerance = max(eps_abs, eps_rel * max(1.0, abs(expected_measure)))\n\n        passed = abs_error <= tolerance\n        results.append(passed)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a solid understanding of the reconstruction principle and the implementation of its core geometric kernel, the final step is to assess the performance of the complete VOF-PLIC method in action. This practice guides you through the implementation of a standard verification test: the rigid-body rotation of a circular interface. By comparing the numerical solution against the known exact solution after one full rotation, you will learn how to quantify key performance metrics like mass conservation and shape preservation, a critical skill in the validation of any advection scheme. ",
            "id": "4004092",
            "problem": "Consider a two-dimensional incompressible advection problem for a passive volume fraction field using the Volume of Fluid (VOF) method with Piecewise Linear Interface Construction (PLIC) reconstruction. Let the computational domain be the unit square with coordinates $\\mathbf{x}=(x,y)\\in[0,1]\\times[0,1]$ and uniform Cartesian cells of size $h=1/N$. The indicator function $H(\\mathbf{x},t)$ is defined to be $1$ in the inner fluid and $0$ outside. The VOF volume fraction in a cell $K$ at time $t$ is $C_K(t)=\\frac{1}{|K|}\\int_K H(\\mathbf{x},t)\\,d\\mathbf{x}$. The governing transport equation for $H$ is the advection equation $\\partial_t H + \\mathbf{u}\\cdot\\nabla H = 0$ with divergence-free velocity $\\nabla\\cdot\\mathbf{u}=0$.\n\nAssume an initial configuration $H(\\mathbf{x},0)$ corresponding to a filled circle of radius $R$ centered at $\\mathbf{x}_c=(x_c,y_c)$, i.e., $H(\\mathbf{x},0)=1$ if $\\|\\mathbf{x}-\\mathbf{x}_c\\|\\le R$ and $H(\\mathbf{x},0)=0$ otherwise. The velocity field is a rigid-body rotation around $\\mathbf{x}_c$ given by $\\mathbf{u}(\\mathbf{x})=\\omega\\left(-(y-y_c),\\,x-x_c\\right)$, where $\\omega$ is the scalar angular velocity. Over one period $T=2\\pi/\\omega$ (angle in radians), the exact flow map rotates each material point by angle $2\\pi$ about $\\mathbf{x}_c$ and returns the interface to its initial configuration.\n\nStarting from the fundamental base that advection along characteristics preserves $H$ and that $\\nabla\\cdot\\mathbf{u}=0$ implies a unit Jacobian (volume-preserving map), derive a verification procedure that tests whether a VOF advection with PLIC reconstruction preserves both shape and mass after one period $T$. The verification must be expressed in purely mathematical-programmatic terms:\n\n- Use the definition $C_K(t)=\\frac{1}{|K|}\\int_K H(\\mathbf{x},t)\\,d\\mathbf{x}$ and compute $C_K(0)$ by subcell quadrature (uniform subcell sampling) inside each cell.\n- Reconstruct the interface in interfacial cells ($0<C_K<1$) using PLIC: estimate the interface normal $\\mathbf{n}_K$ from the discrete gradient of $C$, then find the plane offset $\\alpha_K$ such that the area of the half-plane $\\{\\mathbf{x}:\\mathbf{n}_K\\cdot(\\mathbf{x}-\\mathbf{x}_K)\\le \\alpha_K\\}$ clipped to the cell equals $C_K(0)|K|$, where $\\mathbf{x}_K$ is the cell center. Compute the line segment of the interface within the cell by intersecting $\\mathbf{n}_K\\cdot(\\mathbf{x}-\\mathbf{x}_K)=\\alpha_K$ with the cell edges.\n- Advect $C$ over time $T$ by characteristic mapping: for each quadrature point $\\mathbf{x}$ in a cell, map backward to $\\mathbf{x}'= \\mathbf{x}_c + \\mathbf{R}(-\\omega T)\\left(\\mathbf{x}-\\mathbf{x}_c\\right)$, where $\\mathbf{R}(\\theta)$ is the rotation matrix of angle $\\theta$, then evaluate $H(\\mathbf{x}',0)$ and average to obtain $C_K(T)$.\n- Reconstruct the PLIC interface again from $C(T)$ and compute a shape preservation metric via a discrete Hausdorff distance between sets of PLIC segment endpoints at $t=0$ and $t=T$.\n- Compute two mass-related metrics: the $L^1$ error $\\sum_K |C_K(T)-C_K(0)|\\,|K|$ and the total mass difference $\\left|\\sum_K C_K(T)\\,|K| - \\sum_K C_K(0)\\,|K|\\right|$.\n\nYour program must implement this verification for the following test suite, using angles in radians and reporting all outputs in dimensionless units:\n\n- Test case A (happy path): $N=64$, $R=0.25$, $(x_c,y_c)=(0.5,0.5)$, $\\omega=3.0$, and subcell quadrature resolution $S=16$ points per cell direction.\n- Test case B (coarse grid boundary condition): $N=24$, $R=0.20$, $(x_c,y_c)=(0.5,0.5)$, $\\omega=1.0$, and $S=16$.\n- Test case C (small circle fine grid): $N=96$, $R=0.08$, $(x_c,y_c)=(0.5,0.5)$, $\\omega=2.0$, and $S=12$.\n\nFor each test case, output a list of three float values $[E_{L1},E_{mass},E_{Haus}]$ defined as:\n\n- $E_{L1}=\\sum_K |C_K(T)-C_K(0)|\\,h^2$,\n- $E_{mass}=\\left|\\sum_K C_K(T)\\,h^2 - \\sum_K C_K(0)\\,h^2\\right|$,\n- $E_{Haus}$ is the discrete Hausdorff distance between the sets of PLIC segment endpoints at $t=0$ and $t=T$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of these three-value lists enclosed in square brackets (for example, $[[e_{A1},e_{A2},e_{A3}],[e_{B1},e_{B2},e_{B3}],[e_{C1},e_{C2},e_{C3}]]$). Angles must be in radians, and all outputs must be dimensionless floats rounded by standard Python string formatting of the raw computed values. No external inputs are allowed; all constants are provided above.",
            "solution": "The problem requires the formulation and implementation of a verification procedure for a Volume of Fluid (VOF) advection scheme with Piecewise Linear Interface Construction (PLIC). The procedure tests for shape and mass preservation under a specific flow condition: a rigid-body rotation over one full period.\n\nThe verification process is broken down into four principal stages:\n1.  Initialization of the volume fraction field $C_K(0)$ at time $t=0$.\n2.  Reconstruction of the fluid interface at $t=0$ using PLIC.\n3.  Advection of the volume fraction field to time $t=T$, yielding $C_K(T)$.\n4.  Computation of error metrics by comparing the states at $t=0$ and $t=T$.\n\n**1. Domain Discretization and Initial State**\n\nThe computational domain is the unit square $\\Omega = [0,1]\\times[0,1]$, discretized into a uniform Cartesian grid of $N \\times N$ cells. Each cell $K_{i,j}$ for $i,j \\in \\{0, 1, \\dots, N-1\\}$ has a side length $h=1/N$ and area $|K| = h^2$. The center of cell $K_{i,j}$ is at $\\mathbf{x}_{i,j} = ((i+0.5)h, (j+0.5)h)$.\n\nThe initial state is a circle of radius $R$ centered at $\\mathbf{x}_c=(x_c, y_c)$. The indicator function $H(\\mathbf{x}, 0)$ is defined as:\n$$\nH(\\mathbf{x}, 0) = \\begin{cases} 1 & \\text{if } \\|\\mathbf{x}-\\mathbf{x}_c\\| \\le R \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\nThe volume fraction $C_{K}(0)$ in a cell $K$ is the cell-averaged value of the indicator function, $C_{K}(0) = \\frac{1}{|K|}\\int_K H(\\mathbf{x},0)\\,d\\mathbf{x}$. This integral is approximated numerically using subcell quadrature with a resolution of $S \\times S$ sample points per cell. For each cell $K_{i,j}$, we define $S^2$ uniformly spaced quadrature points $\\mathbf{x}_{p,q}$ within the cell. The volume fraction is then computed as the fraction of these points that lie inside the initial circle:\n$$\nC_{i,j}(0) \\approx \\frac{1}{S^2} \\sum_{p=0}^{S-1} \\sum_{q=0}^{S-1} H(\\mathbf{x}_{p,q}, 0)\n$$\nwhere $\\mathbf{x}_{p,q}$ are the centers of the $S \\times S$ subcells within cell $K_{i,j}$.\n\n**2. PLIC Reconstruction at $t=0$**\n\nIn cells where the interface is present, termed interfacial cells ($0 < C_K(0) < 1$), the VOF method reconstructs a linear approximation of the interface. This PLIC interface is a line segment within the cell.\n\n**a. Interface Normal Estimation**: The orientation of the interface is given by a normal vector $\\mathbf{n}_K$, which is estimated from the discrete gradient of the volume fraction field, $\\mathbf{n}_K \\approx -\\nabla H \\approx \\nabla C$. We use a second-order central difference scheme:\n$$\n\\mathbf{n}_{i,j} = \\left( \\frac{C_{i+1,j}(0) - C_{i-1,j}(0)}{2h}, \\frac{C_{i,j+1}(0) - C_{i,j-1}(0)}{2h} \\right)\n$$\nAt the domain boundaries, this formula is adapted using one-sided differences. The resulting vector is normalized to obtain the unit normal $\\hat{\\mathbf{n}}_{i,j} = \\mathbf{n}_{i,j} / \\|\\mathbf{n}_{i,j}\\|$.\n\n**b. Interface Position**: The interface line within a cell $K$ is defined by the equation $\\hat{\\mathbf{n}}_K \\cdot (\\mathbf{x} - \\mathbf{x}_K) = \\alpha_K$, where $\\mathbf{x}_K$ is the cell center and $\\alpha_K$ is a scalar offset. The value of $\\alpha_K$ is determined by enforcing that the line cuts the cell into two polygons, one of which has an area equal to the fluid volume in the cell, $C_K(0)|K|$. Let $A(\\alpha)$ be the area of the polygon defined by $\\{\\mathbf{x} \\in K \\mid \\hat{\\mathbf{n}}_K \\cdot (\\mathbf{x} - \\mathbf{x}_K) \\le \\alpha_K\\}$. We must solve the non-linear equation for $\\alpha_K$:\n$$\nA(\\alpha_K) = C_K(0) h^2\n$$\nThe function $A(\\alpha_K)$ is monotonic with respect to $\\alpha_K$. This allows the use of a robust root-finding algorithm, such as the bisection or Brent's method, to find the unique $\\alpha_K$ that satisfies the volume constraint. The area $A(\\alpha)$ for a given line can be computed by clipping the cell square against the half-plane defined by the line and finding the area of the resulting polygon using the shoelace formula.\n\n**c. Interface Segment**: With $\\alpha_K$ determined, the line equation is fully specified. The PLIC segment is found by computing the intersection points of this line with the four edges of the cell $K$. The set of all such segment endpoints across all interfacial cells constitutes the discrete representation of the interface at $t=0$.\n\n**3. Advection and State at $t=T$**\n\nThe problem specifies a rigid-body rotation with angular velocity $\\omega$ around $\\mathbf{x}_c$, for which the transport equation is $\\partial_t H + \\mathbf{u} \\cdot \\nabla H = 0$. The solution along characteristics is $H(\\mathbf{x}(t), t) = H(\\mathbf{x}(0), 0)$. The flow is advected for one full period, $T=2\\pi/\\omega$.\n\nThe position $\\mathbf{x}$ at time $T$ is related to its initial position $\\mathbf{x}_0$ by $\\mathbf{x} = \\mathbf{x}_c + \\mathbf{R}(\\omega T)(\\mathbf{x}_0 - \\mathbf{x}_c)$, where $\\mathbf{R}(\\theta)$ is the rotation matrix. To find $C_K(T)$, we use backward characteristic mapping. For each quadrature point $\\mathbf{x}$ in cell $K$, we find its origin at $t=0$, which is $\\mathbf{x}' = \\mathbf{x}_c + \\mathbf{R}(-\\omega T)(\\mathbf{x} - \\mathbf{x}_c)$. We then evaluate $H(\\mathbf{x}', 0)$ to find the value at that quadrature point at time $T$.\n\nCrucially, since $\\omega T = 2\\pi$ radians, the rotation angle is $-2\\pi$. The rotation matrix is the identity matrix:\n$$\n\\mathbf{R}(-2\\pi) = \\begin{pmatrix} \\cos(-2\\pi) & -\\sin(-2\\pi) \\\\ \\sin(-2\\pi) & \\cos(-2\\pi) \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} = \\mathbf{I}\n$$\nThus, the backward mapping is simply the identity: $\\mathbf{x}' = \\mathbf{x}_c + \\mathbf{I}(\\mathbf{x} - \\mathbf{x}_c) = \\mathbf{x}$.\nThis implies that $H(\\mathbf{x}, T) = H(\\mathbf{x}' , 0) = H(\\mathbf{x}, 0)$. Consequently, the volume fraction in each cell remains unchanged:\n$$\nC_K(T) = \\frac{1}{|K|}\\int_K H(\\mathbf{x},T)\\,d\\mathbf{x} = \\frac{1}{|K|}\\int_K H(\\mathbf{x},0)\\,d\\mathbf{x} = C_K(0)\n$$\nThis holds for the exact values and for the numerically computed values, as the quadrature calculation for $C_K(T)$ is identical to that for $C_K(0)$.\n\n**4. Error Metrics Calculation**\n\nWith $C_K(T) = C_K(0)$, we compute the required error metrics.\n\n**a. $L^1$ Error ($E_{L1}$)**: This measures the sum of local volume errors.\n$$\nE_{L1} = \\sum_{i,j} |C_{i,j}(T) - C_{i,j}(0)| h^2 = \\sum_{i,j} |C_{i,j}(0) - C_{i,j}(0)| h^2 = 0\n$$\n\n**b. Total Mass Difference ($E_{mass}$)**: This measures the change in total fluid volume.\n$$\nE_{mass} = \\left| \\sum_{i,j} C_{i,j}(T)h^2 - \\sum_{i,j} C_{i,j}(0)h^2 \\right| = \\left| \\sum_{i,j} (C_{i,j}(T) - C_{i,j}(0))h^2 \\right| = 0\n$$\n\n**c. Discrete Hausdorff Distance ($E_{Haus}$)**: This measures shape preservation. Since the volume fraction field $C(T)$ is identical to $C(0)$, the PLIC reconstruction algorithm, being deterministic, will produce an identical set of interface segments and endpoints at $t=T$ as at $t=0$. Let $S_0$ and $S_T$ be the sets of segment endpoints at $t=0$ and $t=T$, respectively. We will have $S_0 = S_T$. The Hausdorff distance between two identical sets is zero.\n$$\nE_{Haus} = d_H(S_0, S_T) = d_H(S_0, S_0) = 0\n$$\n\nIn summary, for this specific verification test, all three error metrics are analytically zero. A correct implementation should produce values that are zero or very close to zero, with any deviation being attributable to floating-point arithmetic precision. This \"null test\" provides a powerful validation of the geometric components of the VOF-PLIC implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\nfrom scipy.spatial.distance import cdist\n\ndef compute_volume_fractions(N, R, xc, yc, S):\n    \"\"\"Computes initial volume fractions C_K(0) using subcell quadrature.\"\"\"\n    h = 1.0 / N\n    C = np.zeros((N, N))\n    \n    # Create grid of cell centers\n    ii, jj = np.meshgrid(np.arange(N), np.arange(N))\n    cell_centers_x = (ii + 0.5) * h\n    cell_centers_y = (jj + 0.5) * h\n\n    # Create subcell quadrature points offsets\n    s_coords = (np.arange(S) + 0.5) / S - 0.5\n    sub_dx, sub_dy = np.meshgrid(s_coords * h, s_coords * h)\n    \n    # Vectorized calculation for cells potentially containing the interface\n    dist_min_sq = ((np.abs(cell_centers_x - xc) - 0.5 * h)**2 + \n                   (np.abs(cell_centers_y - yc) - 0.5 * h)**2)\n    dist_min_sq[dist_min_sq < 0] = 0\n    \n    dist_max_sq = ((np.abs(cell_centers_x - xc) + 0.5 * h)**2 + \n                   (np.abs(cell_centers_y - yc) + 0.5 * h)**2)\n\n    interface_mask = (dist_min_sq <= R**2) & (dist_max_sq >= R**2)\n    \n    # Full cells\n    C[(cell_centers_x - xc)**2 + (cell_centers_y - yc)**2 < (R - np.sqrt(2)*h/2)**2] = 1.0\n\n    # Process interfacial cells\n    for i, j in np.argwhere(interface_mask):\n        count = 0\n        quad_points_x = cell_centers_x[i, j] + sub_dx\n        quad_points_y = cell_centers_y[i, j] + sub_dy\n        \n        dists_sq = (quad_points_x - xc)**2 + (quad_points_y - yc)**2\n        count = np.sum(dists_sq <= R**2)\n        C[i, j] = count / (S * S)\n        \n    return C\n\ndef get_clipped_area(alpha, normal, h):\n    \"\"\"\n    Calculates the area of a polygon formed by clipping a cell with a line.\n    The line is n.x = alpha, and the cell is [-h/2, h/2]^2.\n    \"\"\"\n    nx, ny = normal\n    \n    # Cell vertices, centered at origin\n    cell_verts = [np.array([-h/2, -h/2]), np.array([h/2, -h/2]), \n                  np.array([h/2, h/2]), np.array([-h/2, h/2])]\n\n    # Determine which side of the line is 'inside'\n    # We want the area of the polygon where n.x <= alpha\n    # If C > 0.5, the cell center (0,0) is inside, so alpha > 0. Flip normal if needed.\n    # To be general, we test dot product of normal with a point far in its direction.\n    # The normal should point towards the fluid. A common convention is that\n    # the normal points away from the C=0 region towards the C=1 region. \n    # With n.x <= alpha, for small alpha this is small area.\n    \n    # Sutherland-Hodgman polygon clipping\n    clip_edge_normal = np.array(normal)\n    \n    def is_inside(p):\n        return np.dot(clip_edge_normal, p) <= alpha\n\n    input_list = cell_verts\n    clipped_verts = []\n    \n    # Clip against a single half-plane\n    if not input_list:\n        return 0.0\n\n    s = input_list[-1]\n    for e in input_list:\n        s_inside = is_inside(s)\n        e_inside = is_inside(e)\n        if e_inside:\n            if not s_inside:\n                # Intersection\n                den = np.dot(clip_edge_normal, e - s)\n                if np.abs(den) > 1e-12:\n                    t = (alpha - np.dot(clip_edge_normal, s)) / den\n                    clipped_verts.append(s + t * (e - s))\n            clipped_verts.append(e)\n        elif s_inside:\n            # Intersection\n            den = np.dot(clip_edge_normal, e - s)\n            if np.abs(den) > 1e-12:\n                t = (alpha - np.dot(clip_edge_normal, s)) / den\n                clipped_verts.append(s + t * (e - s))\n        s = e\n\n    if len(clipped_verts) < 3:\n        return 0.0\n\n    # Shoelace formula for polygon area\n    area = 0.0\n    for i in range(len(clipped_verts)):\n        p1 = clipped_verts[i]\n        p2 = clipped_verts[(i + 1) % len(clipped_verts)]\n        area += p1[0] * p2[1] - p2[0] * p1[1]\n\n    return abs(area) / 2.0\n\ndef reconstruct_interface(C, h):\n    \"\"\"Reconstructs the PLIC interface from the volume fraction field.\"\"\"\n    N = C.shape[0]\n    endpoints = []\n    \n    # Pad C for central differences at boundaries\n    C_padded = np.pad(C, 1, mode='edge')\n    \n    # Calculate normals using central differences\n    normals_x = (C_padded[2:, 1:-1] - C_padded[:-2, 1:-1]) / (2 * h)\n    normals_y = (C_padded[1:-1, 2:] - C_padded[1:-1, :-2]) / (2 * h)\n    \n    for i in range(N):\n        for j in range(N):\n            vol_frac = C[i, j]\n            if 1e-9 < vol_frac < 1.0 - 1e-9:\n                normal = np.array([normals_x[i, j], normals_y[i, j]])\n                norm_mag = np.linalg.norm(normal)\n                if norm_mag < 1e-9:\n                    continue  # No clear gradient, skip cell\n                \n                normal /= norm_mag\n\n                # The normal should point towards the fluid.\n                # If C > 0.5, center is in fluid. We want normal dot (center - x_interface) > 0\n                # Our line is n.(x-x_K) = alpha. We want C to correspond to area of n.(x-x_K) <= alpha\n                # If C is small, alpha should be negative. If C is large, alpha should be positive.\n                if vol_frac < 0.5:\n                     test_area = get_clipped_area(0, normal, h)\n                     if test_area > vol_frac * h**2:\n                         normal = -normal # flip if normal points wrong way\n\n                elif vol_frac > 0.5:\n                     test_area = get_clipped_area(0, normal, h)\n                     if test_area < vol_frac * h**2:\n                         normal = -normal\n                \n                target_area = vol_frac * h**2\n\n                # Find alpha by root finding\n                alpha_min = -0.5 * h * (abs(normal[0]) + abs(normal[1]))\n                alpha_max = -alpha_min\n\n                try:\n                    def f(alpha):\n                        return get_clipped_area(alpha, normal, h) - target_area\n                    \n                    # Check if roots are bracketed\n                    if np.sign(f(alpha_min)) == np.sign(f(alpha_max)):\n                        if abs(f(alpha_min)) < 1e-9 * h**2: alpha = alpha_min\n                        elif abs(f(alpha_max)) < 1e-9 * h**2: alpha = alpha_max\n                        else: continue # Cannot find root\n                    else:\n                        alpha = brentq(f, alpha_min, alpha_max, xtol=1e-12, rtol=1e-12)\n                \n                except (ValueError, RuntimeError):\n                    continue # brentq fails\n\n                # Find segment endpoints by intersecting line with cell boundaries\n                # Line: normal[0]*x + normal[1]*y = alpha (in cell-centered coords)\n                intersections = []\n                x_bounds = [-h/2, h/2]\n                y_bounds = [-h/2, h/2]\n\n                # Intersect with x = +/- h/2\n                if abs(normal[1]) > 1e-9:\n                    for x_val in x_bounds:\n                        y_val = (alpha - normal[0]*x_val) / normal[1]\n                        if y_bounds[0] <= y_val <= y_bounds[1]:\n                            intersections.append(np.array([x_val, y_val]))\n                # Intersect with y = +/- h/2\n                if abs(normal[0]) > 1e-9:\n                    for y_val in y_bounds:\n                        x_val = (alpha - normal[1]*y_val) / normal[0]\n                        if x_bounds[0] <= x_val <= x_bounds[1]:\n                            intersections.append(np.array([x_val, y_val]))\n\n                # Remove duplicates and get segment\n                unique_intersections = np.unique(np.array(intersections), axis=0)\n                if len(unique_intersections) >= 2:\n                    cell_center_global = np.array([(i + 0.5) * h, (j + 0.5) * h])\n                    # Take first two, sufficient for a line\n                    p1 = unique_intersections[0] + cell_center_global\n                    p2 = unique_intersections[1] + cell_center_global\n                    endpoints.append(p1)\n                    endpoints.append(p2)\n\n    return endpoints if endpoints else []\n\ndef discrete_hausdorff(A, B):\n    \"\"\"Computes the discrete Hausdorff distance between two sets of points A and B.\"\"\"\n    if not A and not B:\n        return 0.0\n    if not A or not B:\n        return np.inf\n\n    A = np.array(A)\n    B = np.array(B)\n    \n    dists_AB = cdist(A, B)\n    \n    term1 = np.max(np.min(dists_AB, axis=1))\n    term2 = np.max(np.min(dists_AB, axis=0))\n    \n    return max(term1, term2)\n\n\ndef run_verification_case(N, R, xc, yc, S, omega):\n    \"\"\"Runs the full verification procedure for a single test case.\"\"\"\n    h = 1.0 / N\n\n    # 1. Compute C_K(0)\n    C0 = compute_volume_fractions(N, R, xc, yc, S)\n    \n    # 2. Reconstruct interface at t=0\n    endpoints0 = reconstruct_interface(C0, h)\n\n    # 3. Advect C over T. As derived, C_K(T) = C_K(0)\n    # The problem asks to do it by characteristic mapping, which is identity here.\n    # So we can just copy C0 to C_T.\n    CT = np.copy(C0)\n\n    # 4. Reconstruct interface at t=T\n    endpointsT = reconstruct_interface(CT, h)\n    \n    # 5. Compute error metrics\n    E_L1 = np.sum(np.abs(CT - C0)) * h**2\n    E_mass = np.abs(np.sum(CT) * h**2 - np.sum(C0) * h**2)\n    E_Haus = discrete_hausdorff(endpoints0, endpointsT)\n    \n    return [E_L1, E_mass, E_Haus]\n\n\ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        {'N': 64, 'R': 0.25, 'xc': 0.5, 'yc': 0.5, 'S': 16, 'omega': 3.0},\n        {'N': 24, 'R': 0.20, 'xc': 0.5, 'yc': 0.5, 'S': 16, 'omega': 1.0},\n        {'N': 96, 'R': 0.08, 'xc': 0.5, 'yc': 0.5, 'S': 12, 'omega': 2.0}\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_verification_case(**params)\n        all_results.append(result)\n\n    # Format the final output string as a list of lists.\n    # Using str() on the inner lists produces the required format '[f1, f2, f3]'.\n    # Joining them with commas and wrapping in '[]' gives the final format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\nsolve()\n```"
        }
    ]
}