{
    "hands_on_practices": [
        {
            "introduction": "任何离散元法（DEM）模拟的基础在于对颗粒间作用力的精确建模。虽然非线性的赫兹理论为弹性接触提供了精确的描述，但其计算成本可能过高。本练习将引导您开发并验证一个线性化的接触模型，这是一种提高计算效率的常用技术，并帮助您量化模型在准确性与计算速度之间的权衡 。",
            "id": "3947595",
            "problem": "考虑将离散元法（DEM）应用于两个球形颗粒之间的无摩擦、弹性的法向接触。在计算热工学中，此类接触定律控制着机械接触，并影响热接触传导。要求您根据小变形、各向同性线弹性和球体间无粘附接触的假设，用一个非线性接触模型来验证一个线性化刚度模型。非线性模型应基于经典的球体弹性接触理论，而线性化模型应通过在指定参考重叠量附近进行一阶泰勒展开来构建。您的任务是计算并比较力-位移曲线，并量化由线性化引入的误差。\n\n从牛顿力学和广为接受的小变形弹性接触理论等基本原理出发，按以下步骤进行：\n\n1. 对于杨氏模量为 $E_1$ 和 $E_2$、泊松比为 $\\nu_1$ 和 $\\nu_2$、半径为 $R_1$ 和 $R_2$ 的两个球体，推导它们之间法向接触的等效弹性模量 $E^\\ast$ 和等效半径 $R^\\ast$。\n2. 设法向接近量（重叠量）为 $\\delta \\ge 0$，单位为米（m）。非线性法向接触力模型应为球体的弹性接触定律，用 $E^\\ast$、$R^\\ast$ 和 $\\delta$ 表示。通过对非线性力相对于 $\\delta$ 在参考重叠量 $\\delta_{\\mathrm{ref}}$ 处进行一阶泰勒展开来构建线性化模型，以使线性化模型在 $\\delta_{\\mathrm{ref}}$ 处的力与切向刚度均与非线性模型匹配。\n3. 对于每个测试用例，在区间 $[\\delta_{\\min}, \\delta_{\\max}]$ 上的均匀间隔网格上对重叠量 $\\delta$ 进行采样，其中 $\\delta_{\\min}$ 严格为正，以避免在相对误差评估中出现除以零的情况。使用 $\\delta_{\\min} = \\delta_{\\max}/N_{\\mathrm{s}}$，其中 $N_{\\mathrm{s}}$ 是采样点数。\n4. 对于每个采样的 $\\delta$，计算非线性力（单位：牛顿，N）和线性化力（单位：牛顿，N）。使用逐点无量纲相对误差来量化线性化误差，该误差定义为绝对差值除以非线性力。将这些误差汇总为每个测试用例的两个度量指标：\n   - 在采样 $\\delta$ 值上的均方根相对误差。\n   - 在采样 $\\delta$ 值上的最大相对误差。\n5. 所有输入均使用国际单位制（SI）。半径 $R_1$、$R_2$ 的单位为米（m），杨氏模量 $E$ 的单位为帕斯卡（Pa），重叠量 $\\delta$ 的单位为米（m），力的单位为牛顿（N）。相对误差度量指标是无量纲数。您的程序必须将这些度量指标输出为四舍五入到六位小数的十进制浮点数。\n\n测试套件：\n使用以下五个科学上合理的测试用例，旨在探究一系列材料刚度、颗粒尺寸和线性化参考重叠量。对于每个用例，设置 $\\delta_{\\mathrm{ref}} = f_{\\mathrm{ref}} \\, \\delta_{\\max}$ 和 $\\delta_{\\min} = \\delta_{\\max}/N_{\\mathrm{s}}$。\n\n- 用例 A（典型的刚性接触，材料和尺寸相同）：\n  - $E_1 = 200 \\times 10^9$ Pa, $\\nu_1 = 0.30$, $E_2 = 200 \\times 10^9$ Pa, $\\nu_2 = 0.30$\n  - $R_1 = 0.005$ m, $R_2 = 0.005$ m\n  - $\\delta_{\\max} = 5 \\times 10^{-6}$ m, $f_{\\mathrm{ref}} = 0.5$, $N_{\\mathrm{s}} = 200$\n\n- 用例 B（软接触，近乎不可压缩的橡胶，材料和尺寸相同）：\n  - $E_1 = 10 \\times 10^6$ Pa, $\\nu_1 = 0.49$, $E_2 = 10 \\times 10^6$ Pa, $\\nu_2 = 0.49$\n  - $R_1 = 0.01$ m, $R_2 = 0.01$ m\n  - $\\delta_{\\max} = 50 \\times 10^{-6}$ m, $f_{\\mathrm{ref}} = 0.5$, $N_{\\mathrm{s}} = 200$\n\n- 用例 C（刚-软接触，尺寸相同）：\n  - $E_1 = 200 \\times 10^9$ Pa, $\\nu_1 = 0.30$, $E_2 = 10 \\times 10^6$ Pa, $\\nu_2 = 0.49$\n  - $R_1 = 0.002$ m, $R_2 = 0.002$ m\n  - $\\delta_{\\max} = 2 \\times 10^{-6}$ m, $f_{\\mathrm{ref}} = 0.5$, $N_{\\mathrm{s}} = 200$\n\n- 用例 D（刚性接触，小颗粒，在范围下限附近线性化）：\n  - $E_1 = 200 \\times 10^9$ Pa, $\\nu_1 = 0.30$, $E_2 = 200 \\times 10^9$ Pa, $\\nu_2 = 0.30$\n  - $R_1 = 0.001$ m, $R_2 = 0.001$ m\n  - $\\delta_{\\max} = 1 \\times 10^{-6}$ m, $f_{\\mathrm{ref}} = 0.1$, $N_{\\mathrm{s}} = 200$\n\n- 用例 E（刚性接触，中等颗粒，在范围上限附近线性化）：\n  - $E_1 = 200 \\times 10^9$ Pa, $\\nu_1 = 0.30$, $E_2 = 200 \\times 10^9$ Pa, $\\nu_2 = 0.30$\n  - $R_1 = 0.003$ m, $R_2 = 0.003$ m\n  - $\\delta_{\\max} = 3 \\times 10^{-6}$ m, $f_{\\mathrm{ref}} = 0.9$, $N_{\\mathrm{s}} = 200$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。对于每个测试用例，输出均方根相对误差，紧接着是最大相对误差（每个用例两个数字），两者都四舍五入到六位小数。因此，总输出必须是按用例 A 到 E 顺序排列的包含 10 个数字的扁平列表，例如 $\\left[ \\text{A\\_rms}, \\text{A\\_max}, \\text{B\\_rms}, \\text{B\\_max}, \\ldots, \\text{E\\_rms}, \\text{E\\_max} \\right]$。",
            "solution": "所提出的问题要求使用经典的两个弹性球体间的非线性赫兹接触理论来验证一个线性化的法向接触力模型。这项任务与离散元法（DEM）等计算方法相关，在这些方法中，简化的力定律可以显著降低计算成本。该分析涉及推导力模型，在指定的重叠范围内对其进行采样，并量化线性化误差。\n\n该问题具有科学依据，提法明确，并提供了所有必要的参数和程序。它基于接触力学和数值分析的既定原理。因此，该问题被认为是有效的，下面给出了完整的解决方案。\n\n**1. 接触模型的理论构建**\n\n两个接触的弹性球体之间的相互作用由其材料属性（杨氏模量 $E$ 和泊松比 $\\nu$）及其几何形状（半径 $R$）来描述。下标 $1$ 和 $2$ 表示这两个球体。\n\n**1.1. 等效材料和几何属性**\n\n通过定义等效杨氏模量 $E^\\ast$ 和等效半径 $R^\\ast$，可以简化双球系统的响应。这些参数将两个球体的属性组合成一个球体与平面接触问题的等效值。\n\n等效杨氏模量 $E^\\ast$ 由以下关系定义：\n$$\n\\frac{1}{E^\\ast} = \\frac{1-\\nu_1^2}{E_1} + \\frac{1-\\nu_2^2}{E_2}\n$$\n可以计算为：\n$$\nE^\\ast = \\left( \\frac{1-\\nu_1^2}{E_1} + \\frac{1-\\nu_2^2}{E_2} \\right)^{-1}\n$$\n等效半径 $R^\\ast$ 由两个球体的曲率定义：\n$$\n\\frac{1}{R^\\ast} = \\frac{1}{R_1} + \\frac{1}{R_2}\n$$\n可以计算为：\n$$\nR^\\ast = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1}\n$$\n\n**1.2. 非线性法向接触力模型（赫兹理论）**\n\n在无摩擦、无粘附、小变形的弹性接触假设下，法向接触力 $F_{nl}$ 与法向重叠量（接近量）$\\delta$ 之间的关系由赫兹接触理论给出：\n$$\nF_{nl}(\\delta) = \\frac{4}{3} E^\\ast \\sqrt{R^\\ast} \\delta^{3/2} \\quad \\text{for} \\quad \\delta \\ge 0\n$$\n当 $\\delta  0$（无接触）时，力为零。由于幂律关系 $F_{nl} \\propto \\delta^{3/2}$，该模型是非线性的。\n\n**1.3. 线性化法向接触力模型**\n\n通过对非线性力 $F_{nl}(\\delta)$ 在指定的参考重叠量 $\\delta_{\\mathrm{ref}}$ 处进行一阶泰勒展开，可以构建一个线性化力模型 $F_{lin}(\\delta)$。展开的一般形式是：\n$$\nF_{lin}(\\delta) = F_{nl}(\\delta_{\\mathrm{ref}}) + \\left. \\frac{dF_{nl}}{d\\delta} \\right|_{\\delta=\\delta_{\\mathrm{ref}}} (\\delta - \\delta_{\\mathrm{ref}})\n$$\n这确保了线性化模型在 $\\delta = \\delta_{\\mathrm{ref}}$ 处的力与切向刚度均与非线性模型匹配。\n\n首先，我们通过对 $F_{nl}(\\delta)$ 求导来确定切向刚度 $k_t(\\delta)$：\n$$\nk_t(\\delta) = \\frac{dF_{nl}}{d\\delta} = \\frac{d}{d\\delta} \\left( \\frac{4}{3} E^\\ast \\sqrt{R^\\ast} \\delta^{3/2} \\right) = \\frac{4}{3} E^\\ast \\sqrt{R^\\ast} \\left( \\frac{3}{2} \\delta^{1/2} \\right) = 2 E^\\ast \\sqrt{R^\\ast} \\sqrt{\\delta}\n$$\n在 $\\delta_{\\mathrm{ref}}$ 处计算力与刚度：\n$$\nF_{nl}(\\delta_{\\mathrm{ref}}) = \\frac{4}{3} E^\\ast \\sqrt{R^\\ast} \\delta_{\\mathrm{ref}}^{3/2}\n$$\n$$\nk_t(\\delta_{\\mathrm{ref}}) = 2 E^\\ast \\sqrt{R^\\ast} \\sqrt{\\delta_{\\mathrm{ref}}}\n$$\n将这些代入泰勒展开公式：\n$$\nF_{lin}(\\delta) = \\frac{4}{3} E^\\ast \\sqrt{R^\\ast} \\delta_{\\mathrm{ref}}^{3/2} + \\left( 2 E^\\ast \\sqrt{R^\\ast} \\sqrt{\\delta_{\\mathrm{ref}}} \\right) (\\delta - \\delta_{\\mathrm{ref}})\n$$\n我们可以通过提取公因式来简化此表达式：\n$$\nF_{lin}(\\delta) = E^\\ast \\sqrt{R^\\ast} \\left( \\frac{4}{3} \\delta_{\\mathrm{ref}}^{3/2} + 2\\delta\\sqrt{\\delta_{\\mathrm{ref}}} - 2\\delta_{\\mathrm{ref}}^{3/2} \\right)\n$$\n$$\nF_{lin}(\\delta) = E^\\ast \\sqrt{R^\\ast} \\left( 2\\delta\\sqrt{\\delta_{\\mathrm{ref}}} - \\frac{2}{3} \\delta_{\\mathrm{ref}}^{3/2} \\right)\n$$\n线性化力模型的最终形式是：\n$$\nF_{lin}(\\delta) = 2 E^\\ast \\sqrt{R^\\ast \\delta_{\\mathrm{ref}}} \\left( \\delta - \\frac{1}{3} \\delta_{\\mathrm{ref}} \\right)\n$$\n该模型在 $\\delta$ 上是仿射的，表现出恒定的刚度 $k_t(\\delta_{\\mathrm{ref}})$。\n\n**2. 误差量化**\n\n为了评估线性化的准确性，我们计算逐点相对误差，然后将其汇总为两个度量指标。该分析在区间 $[\\delta_{\\min}, \\delta_{\\max}]$ 内的 $N_{\\mathrm{s}}$ 个均匀间隔的重叠量 $\\delta$ 采样点网格上进行，其中 $\\delta_{\\min} = \\delta_{\\max}/N_{\\mathrm{s}}$。采样从一个严格为正的值开始，以避免在计算相对误差时出现除以零的情况，因为 $F_{nl}(0) = 0$。\n\n逐点无量纲相对误差 $\\epsilon(\\delta)$ 定义为：\n$$\n\\epsilon(\\delta) = \\frac{|F_{nl}(\\delta) - F_{lin}(\\delta)|}{F_{nl}(\\delta)}\n$$\n根据这些逐点误差，为每个测试用例计算两个汇总度量指标：\n1.  **均方根相对误差 (RMSRE)**：对于一组采样重叠量 $\\{\\delta_i\\}_{i=1}^{N_{\\mathrm{s}}}$，RMSRE 由下式给出：\n    $$\n    \\text{RMSRE} = \\sqrt{\\frac{1}{N_{\\mathrm{s}}} \\sum_{i=1}^{N_{\\mathrm{s}}} \\left( \\epsilon(\\delta_i) \\right)^2}\n    $$\n2.  **最大相对误差 (MRE)**：这是在采样重叠量上逐点相对误差的最大值：\n    $$\n    \\text{MRE} = \\max_{i} \\{ \\epsilon(\\delta_i) \\}\n    $$\n\n**3. 计算步骤**\n\n该解决方案以 Python 脚本的形式实现，对问题陈述中提供的每个测试用例执行以下步骤：\n1.  根据两个球体的给定属性（$R_1, \\nu_1, E_1, R_2, \\nu_2, E_2$）计算等效半径 $R^\\ast$ 和等效模量 $E^\\ast$。\n2.  确定分析范围的参数：参考重叠量 $\\delta_{\\mathrm{ref}} = f_{\\mathrm{ref}} \\, \\delta_{\\max}$ 和最小重叠量 $\\delta_{\\min} = \\delta_{\\max}/N_{\\mathrm{s}}$。\n3.  生成一个包含 $N_{\\mathrm{s}}$ 个从 $\\delta_{\\min}$ 到 $\\delta_{\\max}$ 均匀间隔的 $\\delta$ 值的数组。\n4.  对于 $\\delta$ 数组中的每个值，使用推导的公式计算相应的非线性力 $F_{nl}(\\delta)$ 和线性化力 $F_{lin}(\\delta)$。\n5.  计算所有采样点的逐点相对误差 $\\epsilon(\\delta)$。\n6.  从逐点误差数组中计算 RMSRE 和 MRE。\n7.  存储得到的 RMSRE 和 MRE 值。\n8.  处理完所有测试用例后，将结果格式化为单个列表，并按规定格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... # Scipy is not required for this solution.\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing nonlinear and linearized contact models\n    for a series of test cases.\n    \"\"\"\n\n    def compute_errors_for_case(E1, nu1, R1, E2, nu2, R2, delta_max, f_ref, Ns):\n        \"\"\"\n        Computes the RMS and max relative errors for a single test case.\n\n        Args:\n            E1, nu1, R1: Properties of sphere 1 (Young's modulus, Poisson's ratio, radius).\n            E2, nu2, R2: Properties of sphere 2.\n            delta_max (float): Maximum overlap for the analysis range.\n            f_ref (float): Factor to determine the reference overlap from delta_max.\n            Ns (int): Number of sample points.\n\n        Returns:\n            tuple: A tuple containing (rms_relative_error, max_relative_error).\n        \"\"\"\n        # Step 1: Calculate effective material and geometric properties\n        E_star = 1.0 / ((1.0 - nu1**2) / E1 + (1.0 - nu2**2) / E2)\n        \n        # Handle the case of a sphere on a flat plane (R2 -> infinity)\n        if R2 == float('inf'):\n            R_star = R1\n        else:\n            R_star = 1.0 / (1.0 / R1 + 1.0 / R2)\n\n        # Step 2: Define analysis range and reference overlap\n        delta_ref = f_ref * delta_max\n        delta_min = delta_max / Ns\n\n        # Step 3: Generate the grid of overlap values\n        delta = np.linspace(delta_min, delta_max, Ns)\n\n        # Step 4: Compute nonlinear and linearized forces\n        # Nonlinear force: F_nl = (4/3) * E* * sqrt(R*) * delta^(3/2)\n        hertz_const = (4.0 / 3.0) * E_star * np.sqrt(R_star)\n        F_nl = hertz_const * delta**1.5\n\n        # Linearized force: F_lin = 2 * E* * sqrt(R* * delta_ref) * (delta - delta_ref/3)\n        lin_const = 2.0 * E_star * np.sqrt(R_star * delta_ref)\n        F_lin = lin_const * (delta - delta_ref / 3.0)\n        \n        # Step 5: Calculate pointwise relative error\n        # The problem statement defines error as absolute difference divided by nonlinear force.\n        relative_error = np.abs(F_nl - F_lin) / F_nl\n\n        # Step 6: Compute aggregate error metrics\n        rms_relative_error = np.sqrt(np.mean(relative_error**2))\n        max_relative_error = np.max(relative_error)\n\n        return rms_relative_error, max_relative_error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {'E1': 200e9, 'nu1': 0.30, 'R1': 0.005, 'E2': 200e9, 'nu2': 0.30, 'R2': 0.005, \n         'delta_max': 5e-6, 'f_ref': 0.5, 'Ns': 200},\n        # Case B\n        {'E1': 10e6, 'nu1': 0.49, 'R1': 0.01, 'E2': 10e6, 'nu2': 0.49, 'R2': 0.01, \n         'delta_max': 50e-6, 'f_ref': 0.5, 'Ns': 200},\n        # Case C\n        {'E1': 200e9, 'nu1': 0.30, 'R1': 0.002, 'E2': 10e6, 'nu2': 0.49, 'R2': 0.002, \n         'delta_max': 2e-6, 'f_ref': 0.5, 'Ns': 200},\n        # Case D\n        {'E1': 200e9, 'nu1': 0.30, 'R1': 0.001, 'E2': 200e9, 'nu2': 0.30, 'R2': 0.001, \n         'delta_max': 1e-6, 'f_ref': 0.1, 'Ns': 200},\n        # Case E\n        {'E1': 200e9, 'nu1': 0.30, 'R1': 0.003, 'E2': 200e9, 'nu2': 0.30, 'R2': 0.003, \n         'delta_max': 3e-6, 'f_ref': 0.9, 'Ns': 200},\n    ]\n\n    results = []\n    for case in test_cases:\n        rms_err, max_err = compute_errors_for_case(**case)\n        results.append(f\"{rms_err:.6f}\")\n        results.append(f\"{max_err:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在知道每个颗粒所受的力之后，下一步是积分运动方程，以更新它们随时间变化的位置和速度。速度Verlet算法因其出色的能量守恒特性和数值稳定性，已成为分子和颗粒动力学模拟的基石。在此练习中，您将实现这一至关重要的积分方案，并探索其准确性和稳定性等基本特性，这对于确保任何DEM模拟的物理真实性都至关重要 。",
            "id": "3947654",
            "problem": "一个由刚性球形颗粒组成的系统通过离散元法（DEM）进行建模，其中相互作用和运动由 Newton 定律描述。考虑一个质量为 $m$、绕其中心的转动惯量为 $I$ 的单个刚性球形颗粒。令 $\\mathbf{x}(t)$ 表示颗粒位置，$\\mathbf{v}(t)$ 表示其线速度，$\\boldsymbol{\\omega}(t)$ 表示其角速度，$\\boldsymbol{\\theta}(t)$ 表示其以弧度表示的朝向矢量。合力 $\\mathbf{F}$ 和力矩 $\\boldsymbol{\\tau}$ 源于弹簧和接触等相互作用，可能带有无滑移约束，但就本问题而言，它们是确定性的，并且在每个时刻最多取决于位置和朝向。基本依据是牛顿第二平动定律和转动定律：\n$$m \\,\\frac{d^2 \\mathbf{x}}{dt^2} = \\mathbf{F}(\\mathbf{x}, t), \\quad I \\,\\frac{d \\boldsymbol{\\omega}}{dt} = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}, t),$$\n以及运动学关系\n$$\\frac{d \\boldsymbol{\\theta}}{dt} = \\boldsymbol{\\omega}.$$\n\n你的任务是：\n1. 从第一性原理推导一个用于 DEM 的 Velocity-Verlet 时间积分方案，该方案在一个时间步长 $\\Delta t$ 内更新位置 $\\mathbf{x}$、线速度 $\\mathbf{v}$ 和角速度 $\\boldsymbol{\\omega}$。推导必须从上述基本定律开始，不得引入任何快捷公式。推导过程应明确陈述并使用加速度 $\\mathbf{a}(t) = \\mathbf{F}(\\mathbf{x}(t), t)/m$ 和角加速度 $\\boldsymbol{\\alpha}(t) = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}(t), t)/I$，并且必须从时间步 $n$ 的值推导出 $\\mathbf{x}^{n+1}$、$\\mathbf{v}^{n+1}$ 和 $\\boldsymbol{\\omega}^{n+1}$ 的显式更新公式。\n2. 讨论该方案对于依赖于位置的力和力矩的形式精度阶数和稳定性特性，包括对由 $m \\, d^2 x/dt^2 = -k x$ 定义的一维谐振子及其转动模拟 $I \\, d^2 \\theta/dt^2 = -k_t \\theta$ 的线性稳定性分析。明确陈述用自然角频率和 $\\Delta t$ 表示的稳定性条件。所有角度必须以弧度表示。\n3. 实现一个完整、可运行的程序，将推导出的 Velocity-Verlet 方案应用于以下科学上真实的测试套件。使用国际单位制（SI）：质量单位为 $\\mathrm{kg}$，刚度单位为 $\\mathrm{N/m}$，转动惯量单位为 $\\mathrm{kg\\,m^2}$，时间单位为 $\\mathrm{s}$，扭转刚度单位为 $\\mathrm{N\\,m/rad}$，角度单位为弧度。程序必须按规定产生定量输出。\n\n测试套件：\n- 精度测试（针对依赖于位置的力和力矩的单步局部截断误差）：\n    - 平动谐振子：$m = 1.0$，$k = 100.0$，初始位置 $x_0 = 0.1$ $\\mathrm{m}$，初始速度 $v_0 = 0.0$ $\\mathrm{m/s}$，时间步长 $\\Delta t_1 = 0.01$ $\\mathrm{s}$ 和 $\\Delta t_2 = 0.005$ $\\mathrm{s}$。使用 $x(t) = x_0 \\cos(\\omega t) + v_0 \\frac{\\sin(\\omega t)}{\\omega}$ 和 $v(t) = -x_0 \\omega \\sin(\\omega t) + v_0 \\cos(\\omega t)$（其中 $\\omega = \\sqrt{k/m}$）计算一步后的精确解。在对 $\\Delta t_1$ 和 $\\Delta t_2$ 进行一个 Velocity-Verlet 步之后，测量绝对误差 $\\varepsilon_x(\\Delta t)$ 和 $\\varepsilon_v(\\Delta t)$，然后将比率 $\\varepsilon_x(\\Delta t_1)/\\varepsilon_x(\\Delta t_2)$ 和 $\\varepsilon_v(\\Delta t_1)/\\varepsilon_v(\\Delta t_2)$ 报告为浮点数。\n    - 转动谐振子：$I = 0.004$，$k_t = 0.5$，初始朝向 $\\theta_0 = 0.1$ $\\mathrm{rad}$，初始角速度 $\\omega_0 = 0.0$ $\\mathrm{rad/s}$，时间步长 $\\Delta t_1 = 0.01$ $\\mathrm{s}$ 和 $\\Delta t_2 = 0.005$ $\\mathrm{s}$。使用 $\\theta(t) = \\theta_0 \\cos(\\Omega t) + \\omega_0 \\frac{\\sin(\\Omega t)}{\\Omega}$ 和 $\\omega(t) = -\\theta_0 \\Omega \\sin(\\Omega t) + \\omega_0 \\cos(\\Omega t)$（其中 $\\Omega = \\sqrt{k_t/I}$）。在对两个时间步长进行一个 Velocity-Verlet 步之后，测量角速度的绝对误差 $\\varepsilon_\\omega(\\Delta t)$，并将比率 $\\varepsilon_\\omega(\\Delta t_1)/\\varepsilon_\\omega(\\Delta t_2)$ 报告为浮点数。\n\n- 稳定性测试（谐振子在多个步长后的有界性）：\n    - 平动谐振子，参数为 $m = 1.0$，$k = 100.0$，初始条件 $x_0 = 0.1$ $\\mathrm{m}$，$v_0 = 0.0$ $\\mathrm{m/s}$。使用 Velocity-Verlet 方案和三个时间步长模拟 $N = 2000$ 步：$\\Delta t_{\\text{small}} = 0.05$ $\\mathrm{s}$，$\\Delta t_{\\text{border}} = 0.2$ $\\mathrm{s}$，以及 $\\Delta t_{\\text{large}} = 0.25$ $\\mathrm{s}$。将有界性定义为在模拟过程中最大绝对位置不超过初始绝对位置的10倍，并且没有数值溢出。对于每个时间步长，输出一个布尔值，指示运动是否保持有界。\n\n最终输出格式：\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表应按以下顺序包含六个条目：$[\\varepsilon_x(\\Delta t_1)/\\varepsilon_x(\\Delta t_2), \\varepsilon_v(\\Delta t_1)/\\varepsilon_v(\\Delta t_2), \\varepsilon_\\omega(\\Delta t_1)/\\varepsilon_\\omega(\\Delta t_2), \\text{bounded}(\\Delta t_{\\text{small}}), \\text{bounded}(\\Delta t_{\\text{border}}), \\text{bounded}(\\Delta t_{\\text{large}})]$。所有三个比率必须是浮点数，三个有界性指标必须是布尔值。程序不得读取任何输入，并且必须是完全自包含的。",
            "solution": "问题陈述被评估为有效。它在 Newton 力学和数值分析的原理（特别是关于离散元法（DEM））方面具有科学依据。该问题是适定的，提供了推导唯一且有意义的解所需的所有参数和条件。语言客观且无歧义。因此，提供一个完整的解决方案。\n\n### 1. Velocity-Verlet 积分方案的推导\n\nVelocity-Verlet 算法由位置 $\\mathbf{x}(t)$ 和速度 $\\mathbf{v}(t)$ 的泰勒级数展开推导而来。基本运动方程如下：\n$$m \\frac{d^2 \\mathbf{x}}{dt^2} = \\mathbf{F}(\\mathbf{x}, t) \\implies \\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{x}, t)$$\n$$I \\frac{d \\boldsymbol{\\omega}}{dt} = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}, t) \\implies \\frac{d\\boldsymbol{\\omega}}{dt} = \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}, t)$$\n其中 $\\mathbf{a}(t)$ 是线加速度，$\\boldsymbol{\\alpha}(t)$ 是角加速度。运动学关系为 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}$ 和 $\\frac{d\\boldsymbol{\\theta}}{dt} = \\boldsymbol{\\omega}$。\n\n令系统在时间 $t_n = n \\Delta t$ 的状态为 $(\\mathbf{x}^n, \\mathbf{v}^n, \\boldsymbol{\\theta}^n, \\boldsymbol{\\omega}^n)$。我们寻求在时间 $t_{n+1} = t_n + \\Delta t$ 时的状态。\n\n**步骤1：位置和朝向更新**\n我们从位置矢量 $\\mathbf{x}(t)$ 在时间 $t_n$ 附近的泰勒级数展开开始：\n$$\\mathbf{x}(t_n + \\Delta t) = \\mathbf{x}(t_n) + \\frac{d\\mathbf{x}}{dt}\\bigg|_{t_n} \\Delta t + \\frac{1}{2} \\frac{d^2\\mathbf{x}}{dt^2}\\bigg|_{t_n} \\Delta t^2 + O(\\Delta t^3)$$\n代入运动学关系 $\\mathbf{v} = d\\mathbf{x}/dt$ 和加速度的定义 $\\mathbf{a} = d^2\\mathbf{x}/dt^2$：\n$$\\mathbf{x}^{n+1} \\approx \\mathbf{x}^n + \\mathbf{v}^n \\Delta t + \\frac{1}{2} \\mathbf{a}^n \\Delta t^2$$\n这是位置更新公式，其精度为二阶。局部误差为 $O(\\Delta t^3)$。\n\n相同的推导过程也适用于朝向矢量 $\\boldsymbol{\\theta}$，只需将线性量替换为其转动对应量：\n$$\\boldsymbol{\\theta}^{n+1} \\approx \\boldsymbol{\\theta}^n + \\boldsymbol{\\omega}^n \\Delta t + \\frac{1}{2} \\boldsymbol{\\alpha}^n \\Delta t^2$$\n\n**步骤2：速度和角速度更新**\n为了更新速度，我们使用 $\\mathbf{v}(t)$ 在 $t_n$ 附近的泰勒展开：\n$$\\mathbf{v}(t_n + \\Delta t) = \\mathbf{v}(t_n) + \\frac{d\\mathbf{v}}{dt}\\bigg|_{t_n} \\Delta t + O(\\Delta t^2) = \\mathbf{v}^n + \\mathbf{a}^n \\Delta t + O(\\Delta t^2)$$\n这是一个简单的前向欧拉步，只有一阶精度。Velocity-Verlet 方案的关键是通过平均时间步开始和结束时的加速度来提高此精度。\n$$\\mathbf{v}^{n+1} \\approx \\mathbf{v}^n + \\frac{\\mathbf{a}^n + \\mathbf{a}^{n+1}}{2} \\Delta t$$\n为了使用这个公式，我们需要加速度 $\\mathbf{a}^{n+1} = \\mathbf{a}(\\mathbf{x}^{n+1}, t_{n+1})$，而它依赖于新计算的位置 $\\mathbf{x}^{n+1}$。这表明了以下操作顺序：\n1. 使用步骤1中的公式计算新位置 $\\mathbf{x}^{n+1}$。\n2. 使用新位置 $\\mathbf{x}^{n+1}$ 计算力 $\\mathbf{F}(\\mathbf{x}^{n+1}, t_{n+1})$，从而得到新的加速度 $\\mathbf{a}^{n+1}$。\n3. 使用平均加速度公式计算新速度 $\\mathbf{v}^{n+1}$。\n\n一个时间步的完整 Velocity-Verlet 算法如下：\n1. 更新位置：$\\mathbf{x}^{n+1} = \\mathbf{x}^{n} + \\mathbf{v}^{n}\\Delta t + \\frac{1}{2}\\mathbf{a}^{n}\\Delta t^2$。\n2. 计算新加速度：$\\mathbf{a}^{n+1} = \\mathbf{F}(\\mathbf{x}^{n+1}, t_{n+1})/m$。\n3. 更新速度：$\\mathbf{v}^{n+1} = \\mathbf{v}^{n} + \\frac{1}{2}(\\mathbf{a}^{n} + \\mathbf{a}^{n+1})\\Delta t$。\n\n同样的逻辑适用于转动动力学：\n1. 更新朝向：$\\boldsymbol{\\theta}^{n+1} = \\boldsymbol{\\theta}^{n} + \\boldsymbol{\\omega}^{n}\\Delta t + \\frac{1}{2}\\boldsymbol{\\alpha}^{n}\\Delta t^2$。\n2. 计算新角加速度：$\\boldsymbol{\\alpha}^{n+1} = \\boldsymbol{\\tau}(\\boldsymbol{\\theta}^{n+1}, t_{n+1})/I$。\n3. 更新角速度：$\\boldsymbol{\\omega}^{n+1} = \\boldsymbol{\\omega}^{n} + \\frac{1}{2}(\\boldsymbol{\\alpha}^{n} + \\boldsymbol{\\alpha}^{n+1})\\Delta t$。\n\n### 2. 精度和稳定性分析\n\n**精度阶数**\n局部截断误差是在假设时间 $t_n$ 的状态是精确的情况下，单步内产生的误差。\n对于位置，泰勒展开给出：\n$$ \\mathbf{x}_{\\text{exact}}(t_n+\\Delta t) = \\mathbf{x}^n + \\mathbf{v}^n \\Delta t + \\frac{1}{2} \\mathbf{a}^n \\Delta t^2 + \\frac{1}{6} \\dot{\\mathbf{a}}^n \\Delta t^3 + O(\\Delta t^4) $$\n数值计算的位置是 $\\mathbf{x}^{n+1} = \\mathbf{x}^n + \\mathbf{v}^n \\Delta t + \\frac{1}{2} \\mathbf{a}^n \\Delta t^2$。因此局部误差为 $E_x = \\mathbf{x}_{\\text{exact}}^{n+1} - \\mathbf{x}^{n+1} = \\frac{1}{6} \\dot{\\mathbf{a}}^n \\Delta t^3 + O(\\Delta t^4)$。位置更新的局部误差为 $O(\\Delta t^3)$。然而，对于从静止开始（$v_0=0$）的谐振子这一特定测试用例，我们有 $\\dot{\\mathbf{a}} = (d\\mathbf{a}/d\\mathbf{x})\\mathbf{v}$，所以 $\\dot{\\mathbf{a}}(t=0) = 0$。误差主项消失，误差变为 $E_x = \\frac{1}{24}\\ddot{\\mathbf{a}}^n \\Delta t^4 + O(\\Delta t^5)$，即 $O(\\Delta t^4)$。\n\n对于速度，我们将 $\\mathbf{a}^{n+1}$ 在 $t_n$ 附近展开：\n$$ \\mathbf{a}^{n+1} = \\mathbf{a}(\\mathbf{x}^{n+1}) \\approx \\mathbf{a}(\\mathbf{x}^n + \\mathbf{v}^n\\Delta t + \\dots) \\approx \\mathbf{a}^n + \\frac{d\\mathbf{a}}{dt}\\bigg|_{t_n} \\Delta t + O(\\Delta t^2) = \\mathbf{a}^n + \\dot{\\mathbf{a}}^n \\Delta t + O(\\Delta t^2) $$\n将此代入速度更新规则：\n$$ \\mathbf{v}^{n+1} = \\mathbf{v}^n + \\frac{1}{2}(\\mathbf{a}^n + \\mathbf{a}^n + \\dot{\\mathbf{a}}^n \\Delta t + O(\\Delta t^2)) \\Delta t = \\mathbf{v}^n + \\mathbf{a}^n \\Delta t + \\frac{1}{2} \\dot{\\mathbf{a}}^n \\Delta t^2 + O(\\Delta t^3) $$\n精确速度为 $\\mathbf{v}_{\\text{exact}}(t_n+\\Delta t) = \\mathbf{v}^n + \\mathbf{a}^n\\Delta t + \\frac{1}{2}\\dot{\\mathbf{a}}^n\\Delta t^2 + \\frac{1}{6}\\ddot{\\mathbf{a}}^n\\Delta t^3 + O(\\Delta t^4)$。局部误差为 $E_v = \\mathbf{v}_{\\text{exact}}^{n+1} - \\mathbf{v}^{n+1} = \\frac{1}{6}\\ddot{\\mathbf{a}}^n\\Delta t^3 + O(\\Delta t^4)$。\n更仔细的分析表明，位置和速度的局部误差通常为 $O(\\Delta t^3)$。对于 $\\dot{\\mathbf{a}}(0)=0$ 的特定情况，位置误差为 $O(\\Delta t^4)$。该方案的全局误差低一阶，使其成为一个二阶方法，即 $O(\\Delta t^2)$。\n\n**线性稳定性分析**\n我们分析一维谐振子，$m \\ddot{x} = -k x$，即 $\\ddot{x} = -\\omega^2 x$，其中 $\\omega = \\sqrt{k/m}$。Velocity-Verlet 方程为：\n1. $x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2 = x_n + v_n \\Delta t - \\frac{1}{2} \\omega^2 x_n \\Delta t^2$\n2. $v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t = v_n - \\frac{1}{2} \\omega^2 (x_n + x_{n+1}) \\Delta t$\n我们可以将此系统表示为对状态向量 $\\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}$ 的矩阵变换。将(1)中的 $x_{n+1}$ 代入(2)得到系统矩阵，或称放大矩阵 $\\mathbf{M}$：\n$$\n\\begin{pmatrix} x_{n+1} \\\\ v_{n+1} \\end{pmatrix} = \\mathbf{M} \\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix} = \n\\begin{pmatrix} 1 - \\frac{1}{2} (\\omega \\Delta t)^2  \\Delta t \\\\ -\\omega^2 \\Delta t (1 - \\frac{1}{4} (\\omega \\Delta t)^2)  1 - \\frac{1}{2} (\\omega \\Delta t)^2 \\end{pmatrix}\n\\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}\n$$\n如果 $\\mathbf{M}$ 的特征值 $\\lambda$ 满足 $|\\lambda| \\le 1$，则系统是稳定的。特征值是特征方程 $\\lambda^2 - \\text{Tr}(\\mathbf{M})\\lambda + \\det(\\mathbf{M}) = 0$ 的解。\n迹为 $\\text{Tr}(\\mathbf{M}) = 2 - (\\omega \\Delta t)^2$。行列式为 $\\det(\\mathbf{M}) = 1$。方程变为：\n$$ \\lambda^2 - (2 - (\\omega \\Delta t)^2)\\lambda + 1 = 0 $$\n为使特征值位于单位圆上（即 $|\\lambda|=1$ 且振荡不增长），此二次方程的判别式必须为非正：\n$$ (2 - (\\omega \\Delta t)^2)^2 - 4 \\le 0 \\implies -2 \\le 2 - (\\omega \\Delta t)^2 \\le 2 $$\n右侧不等式 $-(\\omega \\Delta t)^2 \\le 0$ 恒成立。左侧不等式给出了稳定性条件：\n$$ (\\omega \\Delta t)^2 \\le 4 \\implies \\omega \\Delta t \\le 2 $$\n因此，对于谐振子，Velocity-Verlet 方案是条件稳定的。时间步长 $\\Delta t$ 的选择必须使其小于或等于 $2/\\omega$，其中 $\\omega$ 是系统中的最高自然频率。同样的条件 $\\Omega \\Delta t \\le 2$ 也适用于转动振子。\n\n### 3. 实现与测试套件结果\n\n提供的 Python 代码实现了所推导的 Velocity-Verlet 算法，并将其应用于指定的测试套件。\n\n**精度测试**\n- **平动振子：** $m=1.0$，$k=100.0$，所以 $\\omega=10.0$ rad/s。初始条件是 $x_0=0.1, v_0=0.0$。由于 $v_0=0$，我们有 $\\dot{a}(0)=0$。位置的局部截断误差预期为 $O(\\Delta t^4)$，速度的局部截断误差预期为 $O(\\Delta t^3)$。当时间步从 $\\Delta t_1$ 减半到 $\\Delta t_2$ 时，位置误差应减少 $(2)^4=16$ 倍，速度误差应减少 $(2)^3=8$ 倍。\n- **转动振子：** $I=0.004$，$k_t=0.5$，所以 $\\Omega=\\sqrt{125} \\approx 11.18$ rad/s。初始条件是 $\\theta_0=0.1, \\omega_0=0.0$。角速度的局部截断误差为 $O(\\Delta t^3)$，因此误差比预期为 $(2)^3=8$。\n\n**稳定性测试**\n稳定性条件是 $\\Delta t \\le 2/\\omega = 2/10.0 = 0.2$ s。\n- $\\Delta t_{\\text{small}} = 0.05$ s: $\\omega \\Delta t = 0.5  2$。预计模拟将是稳定且有界的。\n- $\\Delta t_{\\text{border}} = 0.2$ s: $\\omega \\Delta t = 2.0$。模拟处于稳定性极限。能量应该守恒，运动应保持有界。\n- $\\Delta t_{\\text{large}} = 0.25$ s: $\\omega \\Delta t = 2.5 > 2$。预计模拟将是不稳定的，振幅会指数级增长，并最终溢出或超过指定的界限。\n\n代码计算了这些测试的结果，并按要求格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, analyzes, and implements the Velocity-Verlet integration scheme\n    for a DEM problem, as specified in the problem statement.\n    \"\"\"\n\n    # --- Part 1: Accuracy Tests ---\n\n    # --- Translational Harmonic Oscillator ---\n    m_t = 1.0\n    k_t = 100.0\n    x0_t = 0.1\n    v0_t = 0.0\n    dt_t1 = 0.01\n    dt_t2 = 0.005\n\n    omega_t = np.sqrt(k_t / m_t)\n\n    def run_trans_step(x0, v0, dt, k, m):\n        # Initial acceleration\n        a0 = -k * x0 / m\n        # Update position\n        x1 = x0 + v0 * dt + 0.5 * a0 * dt**2\n        # Update acceleration\n        a1 = -k * x1 / m\n        # Update velocity\n        v1 = v0 + 0.5 * (a0 + a1) * dt\n        return x1, v1\n    \n    # Numerical results for one step\n    x1_num_dt1, v1_num_dt1 = run_trans_step(x0_t, v0_t, dt_t1, k_t, m_t)\n    x1_num_dt2, v1_num_dt2 = run_trans_step(x0_t, v0_t, dt_t2, k_t, m_t)\n\n    # Exact solutions after one step\n    x1_exact_dt1 = x0_t * np.cos(omega_t * dt_t1)\n    v1_exact_dt1 = -x0_t * omega_t * np.sin(omega_t * dt_t1)\n    x1_exact_dt2 = x0_t * np.cos(omega_t * dt_t2)\n    v1_exact_dt2 = -x0_t * omega_t * np.sin(omega_t * dt_t2)\n\n    # Absolute errors\n    eps_x_dt1 = np.abs(x1_num_dt1 - x1_exact_dt1)\n    eps_v_dt1 = np.abs(v1_num_dt1 - v1_exact_dt1)\n    eps_x_dt2 = np.abs(x1_num_dt2 - x1_exact_dt2)\n    eps_v_dt2 = np.abs(v1_num_dt2 - v1_exact_dt2)\n\n    # Ratios of errors\n    ratio_x = eps_x_dt1 / eps_x_dt2\n    ratio_v = eps_v_dt1 / eps_v_dt2\n\n    # --- Rotational Harmonic Oscillator ---\n    I_r = 0.004\n    kt_r = 0.5\n    theta0_r = 0.1\n    omega0_r = 0.0\n    dt_r1 = 0.01\n    dt_r2 = 0.005\n\n    Omega_r = np.sqrt(kt_r / I_r)\n\n    def run_rot_step(theta0, omega0, dt, kt, I):\n        # Initial angular acceleration\n        alpha0 = -kt * theta0 / I\n        # Update orientation (though not explicitly needed for omega error)\n        theta1 = theta0 + omega0 * dt + 0.5 * alpha0 * dt**2\n        # Update angular acceleration\n        alpha1 = -kt * theta1 / I\n        # Update angular velocity\n        omega1 = omega0 + 0.5 * (alpha0 + alpha1) * dt\n        return omega1\n\n    # Numerical omega after one step\n    omega1_num_dt1 = run_rot_step(theta0_r, omega0_r, dt_r1, kt_r, I_r)\n    omega1_num_dt2 = run_rot_step(theta0_r, omega0_r, dt_r2, kt_r, I_r)\n\n    # Exact omega after one step\n    omega1_exact_dt1 = -theta0_r * Omega_r * np.sin(Omega_r * dt_r1)\n    omega1_exact_dt2 = -theta0_r * Omega_r * np.sin(Omega_r * dt_r2)\n\n    # Absolute errors\n    eps_omega_dt1 = np.abs(omega1_num_dt1 - omega1_exact_dt1)\n    eps_omega_dt2 = np.abs(omega1_num_dt2 - omega1_exact_dt2)\n\n    # Ratio of errors\n    ratio_omega = eps_omega_dt1 / eps_omega_dt2\n\n\n    # --- Part 2: Stability Tests ---\n    \n    # Parameters for stability test\n    m_s = 1.0\n    k_s = 100.0\n    x0_s = 0.1\n    v0_s = 0.0\n    N_s = 2000\n    dt_small = 0.05\n    dt_border = 0.2\n    dt_large = 0.25\n    dts_s = [dt_small, dt_border, dt_large]\n    \n    boundedness_results = []\n    \n    def check_boundedness(dt, k, m, x0, v0, N):\n        x = x0\n        v = v0\n        max_abs_x = np.abs(x0)\n        bound = 10.0 * np.abs(x0)\n        \n        for _ in range(N):\n            # Velocity-Verlet update\n            a = -k * x / m\n            x_new = x + v * dt + 0.5 * a * dt**2\n            a_new = -k * x_new / m\n            v_new = v + 0.5 * (a + a_new) * dt\n            \n            x, v = x_new, v_new\n            \n            # Check for overflow and bound\n            if not np.isfinite(x):\n                return False\n            \n            if np.abs(x)  max_abs_x:\n                max_abs_x = np.abs(x)\n            \n            if max_abs_x  bound:\n                return False\n                \n        return True\n\n    for dt_val in dts_s:\n        is_bounded = check_boundedness(dt_val, k_s, m_s, x0_s, v0_s, N_s)\n        boundedness_results.append(is_bounded)\n        \n    is_bounded_small, is_bounded_border, is_bounded_large = boundedness_results\n\n    # Final result assembly\n    results = [\n        ratio_x, \n        ratio_v, \n        ratio_omega, \n        is_bounded_small, \n        is_bounded_border, \n        is_bounded_large\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{results[0]},{results[1]},{results[2]},{str(results[3]).lower()},{str(results[4]).lower()},{str(results[5]).lower()}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在力学模型的基础上，我们可以引入热现象来研究复杂的热-力耦合系统。本练习专注于模拟接触颗粒间的传导传热，这一过程直接依赖于由机械力决定的接触面积。您将结合赫兹接触力学和热传导理论的原理，来建立并验证一个颗粒间热流模型，这是热-DEM模拟中的一个关键组成部分 。",
            "id": "3947631",
            "problem": "给定两个弹性球体的半径、弹性模量、泊松比、热导率，以及指定的法向载荷和温差，请从第一性原理出发，推导一个预测这两个球体接触面上传导传热的预测模型，并用解析解验证一个简化的离散元法（DEM）传导模型。推导过程必须从傅里叶热传导定律和 Hertz 弹性接触理论开始，并仅使用基本定律和经过充分检验的事实。\n\n假设接触处的界面热阻可忽略不计，且在热传导方面，球体局部表现为半无限体。物理情景如下：两个球体在法向载荷作用下被压在一起，形成一个半径为a的圆形接触面；远离接触区域，一个球体维持在较高的均匀温度，另一个则维持在较低的均匀温度。在这些假设下，通过接触面的总传热量取决于接触半径和材料的热导率。通过考虑每个球体的收缩（扩展）热阻并将它们串联相加，可以得到该传导问题的解析解。\n\n从 Hertz 理论开始，建立法向载荷与弹性球体接触半径之间的关系，并从傅里叶定律出发，建立温度梯度与热通量之间的关系。对于两个弹性球体，其等效半径和等效弹性模量由球形接触的标准组合定义。仅使用这些基本原理推导接触半径和双球体系统总热阻的表达式，然后通过将温差除以总热阻来计算解析传热量。\n\n定义一个简化的离散元法（DEM）传导模型，该模型将每个球体的热收缩表示为一个电阻器，其值与接触半径和热导率成反比，但带有一个可能偏离精确解析常数的模型常数。将这两个电阻器视为串联，以获得 DEM 预测的总热阻，从而得到 DEM 预测的传热量。\n\n您的程序必须：\n- 使用 Hertz 理论计算在法向载荷 $F$ 作用下两个球体的接触半径。\n- 在给定的温差 $\\Delta T$ 下，计算球体间的解析总热阻及相应的解析传热量 $Q_{\\mathrm{anal}}$。\n- 使用模型常数 $C_{\\mathrm{DEM}}$ 计算 DEM 预测的总热阻及相应的 DEM 预测传热量 $Q_{\\mathrm{DEM}}$。\n- 对每个测试用例，返回相对误差 $\\varepsilon = \\left| Q_{\\mathrm{DEM}} - Q_{\\mathrm{anal}} \\right| / Q_{\\mathrm{anal}}$，结果为浮点数。\n\n单位和角度说明：\n- 所有长度单位必须是米 ($\\mathrm{m}$)。\n- 所有力的单位必须是牛顿 ($\\mathrm{N}$)。\n- 所有弹性模量的单位必须是帕斯卡 ($\\mathrm{Pa}$)。\n- 所有热导率的单位必须是瓦特每米开尔文 ($\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$)。\n- 所有温差的单位必须是开尔文 ($\\mathrm{K}$)。\n- 本问题不涉及角度。\n- 最终传热量的单位必须是瓦特 ($\\mathrm{W}$)，但程序要求的输出是每个测试用例的无量纲相对误差。\n\n使用的基本原理和定义：\n- 傅里叶热传导定律：$\\mathbf{q} = -k \\nabla T$，其中 $\\mathbf{q}$ 是热通量矢量， $k$ 是热导率， $T$ 是温度。\n- 热阻 $R$ 通过 $Q = \\Delta T / R$ 将净传热量与温差联系起来。\n- 适用于法向载荷 $F$ 下两个弹性球体接触的 Hertz 理论：接触半径 $a$ 的关系式为 $a = \\left( \\dfrac{3 F R_{\\mathrm{eff}}}{4 E_{\\mathrm{eff}}} \\right)^{1/3}$，其中 $R_{\\mathrm{eff}} = \\left( \\dfrac{1}{R_1} + \\dfrac{1}{R_2} \\right)^{-1}$ 且 $E_{\\mathrm{eff}} = \\left( \\dfrac{1 - \\nu_1^2}{E_1} + \\dfrac{1 - \\nu_2^2}{E_2} \\right)^{-1}$，其中 $E_i$ 是球体 $i$ 的杨氏模量，$\\nu_i$ 是其泊松比。\n- 对于一个带有半径为 $a$ 的圆形接触面的半无限体，其扩展热阻与 $a$ 和 $k$ 成反比。将两个球体的热阻串联处理以获得总热阻。\n\n测试套件：\n提供以下三个测试用例以验证不同机制和覆盖范围。在每种情况下，计算上述相对误差 $\\varepsilon$。\n\n- 情况 $1$（理想情况，相同材料，中等载荷）：\n    - $R_1 = 0.010$ $\\mathrm{m}$，$R_2 = 0.010$ $\\mathrm{m}$\n    - $E_1 = 200 \\times 10^{9}$ $\\mathrm{Pa}$，$\\nu_1 = 0.30$\n    - $E_2 = 200 \\times 10^{9}$ $\\mathrm{Pa}$，$\\nu_2 = 0.30$\n    - $k_1 = 54$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$，$k_2 = 54$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$\n    - $F = 50$ $\\mathrm{N}$\n    - $\\Delta T = 20$ $\\mathrm{K}$\n    - $C_{\\mathrm{DEM}} = 4.0$\n\n- 情况 $2$（边界情况：极小载荷，不同材料且其中一种导热性低）：\n    - $R_1 = 0.005$ $\\mathrm{m}$，$R_2 = 0.007$ $\\mathrm{m}$\n    - $E_1 = 200 \\times 10^{9}$ $\\mathrm{Pa}$，$\\nu_1 = 0.30$\n    - $E_2 = 3 \\times 10^{9}$ $\\mathrm{Pa}$，$\\nu_2 = 0.35$\n    - $k_1 = 54$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$，$k_2 = 0.25$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$\n    - $F = 0.05$ $\\mathrm{N}$\n    - $\\Delta T = 5$ $\\mathrm{K}$\n    - $C_{\\mathrm{DEM}} = 3.5$\n\n- 情况 $3$（边界情况：大载荷，材料差异显著）：\n    - $R_1 = 0.020$ $\\mathrm{m}$，$R_2 = 0.010$ $\\mathrm{m}$\n    - $E_1 = 110 \\times 10^{9}$ $\\mathrm{Pa}$，$\\nu_1 = 0.34$\n    - $E_2 = 70 \\times 10^{9}$ $\\mathrm{Pa}$，$\\nu_2 = 0.20$\n    - $k_1 = 400$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$，$k_2 = 1.4$ $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$\n    - $F = 300$ $\\mathrm{N}$\n    - $\\Delta T = 50$ $\\mathrm{K}$\n    - $C_{\\mathrm{DEM}} = 4.2$\n\n最终输出格式：\n您的程序应产生单行输出，其中包含三个测试用例的相对误差，形式为逗号分隔的列表，并用方括号括起，例如 $\\left[ \\varepsilon_1, \\varepsilon_2, \\varepsilon_3 \\right]$。列表中的条目必须是浮点数。不应打印任何额外文本。",
            "solution": "问题陈述已经过验证，被确定为计算热工学领域一个适定的、有科学依据的问题。它没有矛盾、歧义和事实错误。为给定的测试用例提供了所有必需的物理参数和常数。任务是基于第一性原理推导并实现一个两球体间传热的模型，并将其与简化的离散元法（DEM）模型进行比较。\n\n推导和计算过程如下：\n\n**1. 接触力学：Hertz 理论**\n两个弹性球体接触时的力学相互作用由 Hertz 理论描述。该理论提供了法向压缩力 $F$ 与由此产生的圆形接触区域半径 $a$ 之间的关系。该关系是球体几何形状和材料属性的函数。\n\n首先，为双球体系统定义一个等效曲率半径 $R_{\\mathrm{eff}}$。对于半径为 $R_1$ 和 $R_2$ 的球体，其表达式为：\n$$R_{\\mathrm{eff}} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1}$$\n其次，定义一个等效杨氏模量 $E_{\\mathrm{eff}}$，以考虑两个球体的弹性特性。给定它们各自的杨氏模量 $E_1$ 和 $E_2$ 以及泊松比 $\\nu_1$ 和 $\\nu_2$，等效模量为：\n$$E_{\\mathrm{eff}} = \\left( \\frac{1 - \\nu_1^2}{E_1} + \\frac{1 - \\nu_2^2}{E_2} \\right)^{-1}$$\n利用这些等效属性，Hertz 理论给出的法向载荷 $F$ 下的接触半径 $a$ 的方程为：\n$$a = \\left( \\frac{3 F R_{\\mathrm{eff}}}{4 E_{\\mathrm{eff}}} \\right)^{1/3}$$\n\n**2. 传导传热的解析模型**\n热流由傅里叶定律 $\\mathbf{q} = -k \\nabla T$ 控制。对于指定的稳态条件，温度场满足拉普拉斯方程 $\\nabla^2 T = 0$。该问题假设，就热流从微小接触区域收缩或扩展而言，每个球体都表现为半无限体。\n\n对于热导率为 $k$ 的单个半无限介质，与热流通过其表面上半径为 $a$ 的等温圆形斑块相关的热阻被称为收缩（或扩展）热阻 $R_{\\mathrm{const}}$。这是传热学中的一个标准结果，由下式给出：\n$$R_{\\mathrm{const}} = \\frac{1}{4 k a}$$\n问题陈述指出，双球体接触的总热阻可以通过将单个收缩热阻串联来建模。当物理界面的热阻可忽略不计时，这种方法是合适的。因此，总解析热阻 $R_{\\mathrm{anal}}$ 是球体 1 和球体 2 的热阻之和：\n$$R_{\\mathrm{anal}} = R_{1, \\mathrm{anal}} + R_{2, \\mathrm{anal}} = \\frac{1}{4 k_1 a} + \\frac{1}{4 k_2 a}$$\n提取公因子，我们得到：\n$$R_{\\mathrm{anal}} = \\frac{1}{4 a} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right)$$\n由于温差 $\\Delta T$ 产生的通过热阻 $R$ 的总传热速率 $Q$ 由关系式 $Q = \\Delta T / R$ 给出。因此，解析传热速率 $Q_{\\mathrm{anal}}$ 为：\n$$Q_{\\mathrm{anal}} = \\frac{\\Delta T}{R_{\\mathrm{anal}}} = \\frac{\\Delta T}{\\frac{1}{4 a} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right)}$$\n\n**3. 简化的 DEM 传导模型**\n为了进行比较，提出了一个在 DEM 模拟中常见的简化模型。该模型在函数形式上与热阻的解析解相同，但用一个通用的模型常数 $C_{\\mathrm{DEM}}$ 替代了精确的解析常数 $4$。\n\n在这个 DEM 模型中，单个球体 $i$ 的热阻为：\n$$R_{i, \\mathrm{DEM}} = \\frac{1}{C_{\\mathrm{DEM}} k_i a}$$\n同样，将这些热阻串联相加，得到 DEM 预测的总热阻 $R_{\\mathrm{DEM}}$：\n$$R_{\\mathrm{DEM}} = R_{1, \\mathrm{DEM}} + R_{2, \\mathrm{DEM}} = \\frac{1}{C_{\\mathrm{DEM}} k_1 a} + \\frac{1}{C_{\\mathrm{DEM}} k_2 a}$$\n简化后得到：\n$$R_{\\mathrm{DEM}} = \\frac{1}{C_{\\mathrm{DEM}} a} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right)$$\n因此，DEM 预测的传热速率 $Q_{\\mathrm{DEM}}$ 为：\n$$Q_{\\mathrm{DEM}} = \\frac{\\Delta T}{R_{\\mathrm{DEM}}} = \\frac{\\Delta T}{\\frac{1}{C_{\\mathrm{DEM}} a} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right)}$$\n\n**4. 相对误差计算**\n最后一步是通过计算相对误差 $\\varepsilon$ 来量化 DEM 预测与解析解之间的差异：\n$$\\varepsilon = \\frac{\\left| Q_{\\mathrm{DEM}} - Q_{\\mathrm{anal}} \\right|}{Q_{\\mathrm{anal}}}$$\n通过代入 $Q_{\\mathrm{DEM}}$ 和 $Q_{\\mathrm{anal}}$ 的推导表达式，我们可以简化这个表达式。令公共项为 $Z = a \\Delta T / \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right)$。那么 $Q_{\\mathrm{DEM}} = C_{\\mathrm{DEM}} \\cdot Z$ 且 $Q_{\\mathrm{anal}} = 4 \\cdot Z$。\n$$\\varepsilon = \\frac{\\left| C_{\\mathrm{DEM}} \\cdot Z - 4 \\cdot Z \\right|}{4 \\cdot Z} = \\frac{\\left| C_{\\mathrm{DEM}} - 4 \\right| \\cdot Z}{4 \\cdot Z}$$\n由于所有物理参数均为正数，所以 $Z > 0$，因此可以消去：\n$$\\varepsilon = \\frac{\\left| C_{\\mathrm{DEM}} - 4 \\right|}{4}$$\n这个结果表明，相对误差仅取决于 DEM 常数 $C_{\\mathrm{DEM}}$ 与解析常数 $4$ 之间的偏差。所要求的程序将执行完整的逐步计算以得出此误差值，从而验证整个建模过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the relative error between an analytical\n    and a simplified DEM model for heat conduction between two elastic spheres.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains:\n    # (R1, R2, E1, nu1, E2, nu2, k1, k2, F, delta_T, C_dem)\n    test_cases = [\n        # Case 1 (happy path, identical materials, moderate load)\n        (0.010, 0.010, 200e9, 0.30, 200e9, 0.30, 54.0, 54.0, 50.0, 20.0, 4.0),\n        # Case 2 (edge: very small load, dissimilar materials)\n        (0.005, 0.007, 200e9, 0.30, 3e9, 0.35, 54.0, 0.25, 0.05, 5.0, 3.5),\n        # Case 3 (edge: large load, strongly dissimilar materials)\n        (0.020, 0.010, 110e9, 0.34, 70e9, 0.20, 400.0, 1.4, 300.0, 50.0, 4.2),\n    ]\n\n    def calculate_relative_error(params):\n        \"\"\"\n        Computes the relative error for a single set of parameters.\n        \"\"\"\n        R1, R2, E1, nu1, E2, nu2, k1, k2, F, delta_T, C_dem = params\n\n        # Step 1: Compute contact radius 'a' using Hertz theory.\n        \n        # Effective radius of curvature\n        R_eff = (1.0 / R1 + 1.0 / R2)**(-1.0)\n        \n        # Effective Young's modulus\n        E_eff = ((1.0 - nu1**2) / E1 + (1.0 - nu2**2) / E2)**(-1.0)\n        \n        # Contact radius\n        a = (3.0 * F * R_eff / (4.0 * E_eff))**(1.0/3.0)\n\n        # Step 2: Compute analytical heat transfer Q_anal.\n        \n        # Analytical total thermal resistance\n        R_anal = (1.0 / (4.0 * a)) * (1.0 / k1 + 1.0 / k2)\n        \n        # Analytical heat transfer\n        # Check for R_anal being zero to avoid division by zero, though physically impossible here.\n        if R_anal == 0:\n            Q_anal = float('inf') if delta_T  0 else 0.0\n        else:\n            Q_anal = delta_T / R_anal\n            \n        # Step 3: Compute DEM-predicted heat transfer Q_dem.\n        \n        # DEM-predicted total thermal resistance\n        R_dem = (1.0 / (C_dem * a)) * (1.0 / k1 + 1.0 / k2)\n        \n        # DEM-predicted heat transfer\n        if R_dem == 0:\n            Q_dem = float('inf') if delta_T  0 else 0.0\n        else:\n            Q_dem = delta_T / R_dem\n            \n        # Step 4: Compute the relative error epsilon.\n        \n        # Avoid division by zero if the analytical solution yields zero heat transfer.\n        if Q_anal == 0.0:\n            # If both are zero, error is 0. If only Q_anal is zero, error is infinite.\n            return 0.0 if Q_dem == 0.0 else float('inf')\n            \n        error = np.abs(Q_dem - Q_anal) / Q_anal\n        \n        return error\n\n    results = []\n    for case in test_cases:\n        result = calculate_relative_error(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}