{
    "hands_on_practices": [
        {
            "introduction": "在任何追踪流体体积分数的方法中，其核心挑战之一是如何在单个计算网格内精确地重构两种流体之间的界面。本练习将直面这一基本问题，要求您实现一个核心算法，该算法利用网格内的流体体积分数 $F$ 和界面法向量 $\\mathbf{n}$ 来确定分段线性界面的精确位置 。这项实践是理解流体体积（VOF）法和耦合水平集与流体体积（CLSVOF）法在微观层面如何工作的关键，它将抽象的体积分数值与具体的几何表示联系起来，是计算界面曲率和相间通量等后续步骤的基础。",
            "id": "3967973",
            "problem": "您的任务是在耦合水平集和流体体积（Coupled Level-Set and Volume-of-Fluid, CLSVOF）方法中，为一个二维控制体重构分段线性界面，并构建其中未知的平面常数。该二维控制体是一个正方形单元格，其左下角的位置向量为 $\\mathbf{r}_0 = (x_0,y_0)$，边长为 $L$ 米。单元格内部的界面由平面水平集表示\n$$\n\\mathbf{n}\\cdot\\mathbf{x} = \\alpha,\n$$\n其中 $\\mathbf{n}=(n_x,n_y)$ 是一个根据水平集函数的梯度估计的非零法向量，$\\alpha$ 是一个以米为单位的标量。液体区域由半空间定义\n$$\n\\Omega_\\ell(\\alpha) = \\left\\{ \\mathbf{x}\\in \\mathbb{R}^2 \\ \\big|\\ \\mathbf{n}\\cdot \\mathbf{x} \\le \\alpha \\right\\}.\n$$\n单元格内的流体体积分数 $F$（无量纲）根据第一性原理定义为指示函数（亥维赛函数）的面积平均值，\n$$\nF \\;=\\; \\frac{1}{L^2}\\iint_{\\mathcal{C}} H\\!\\left(\\alpha - \\mathbf{n}\\cdot\\mathbf{x}\\right)\\, dA,\n$$\n其中 $\\mathcal{C}=\\left\\{(x,y)\\ \\big|\\ x_0\\le x\\le x_0+L,\\ y_0\\le y\\le y_0+L\\right\\}$ 是该单元格，$H(\\cdot)$ 是亥维赛阶跃函数。给定局部的流体体积分数 $F$ 和一个基于梯度的界面法线估计值 $\\mathbf{n}$，该法向量的长度可能不为1。请构建 $\\alpha$，使得在给定的几何构型下，上述关于 $F$ 的定义精确成立。您必须：\n- 在重构之前将 $\\mathbf{n}$ 归一化为单位长度。\n- 将液体区域视为 $\\{\\mathbf{x}\\in\\mathcal{C}\\mid \\mathbf{n}\\cdot \\mathbf{x} \\le \\alpha\\}$。\n- 通过将 $\\alpha$ 分别设置为单元格角点上 $\\mathbf{n}\\cdot\\mathbf{x}$ 的最小值和最大值来处理 $F=0$ 和 $F=1$ 的边界情况。\n- 对于 $F\\in(0,1)$，通过求解上述积分定义给出的非线性方程来计算 $\\alpha$，不得使用任何关于多边形面积作为 $\\alpha$ 函数的闭式快捷方法。使用半空间 $\\mathbf{n}\\cdot\\mathbf{x}\\le \\alpha$ 对正方形单元格进行几何裁剪，以精确计算任何试验 $\\alpha$ 对应的面积，然后利用由单调性保证的区间求根方法来确定 $\\alpha$。\n\n以米为单位表示每个测试用例的最终 $\\alpha$，并精确到小数点后 $8$ 位。\n\n您必须实现一个完整、可运行的程序，该程序：\n- 不接受任何输入，也不读取任何文件。\n- 仅使用 Python 标准库，如果需要，可以使用指定的数值库。\n- 对于每个测试用例，按规定计算 $\\alpha$ 并将结果汇编成一个列表。\n\n使用以下测试套件。每个测试用例都是一个元组 $(x_0,y_0,L,n_x,n_y,F)$，所有量均采用国际单位制 (SI)，其中 $L$ 和 $\\alpha$ 以米为单位，$F$ 是无量纲的：\n- 测试 1：$(0.0,0.0,1.0,1.0,1.0,0.5)$。\n- 测试 2：$(0.0,0.0,1.0,0.3,0.95,0.0)$。\n- 测试 3：$(0.0,0.0,1.0,0.3,0.95,1.0)$。\n- 测试 4：$(1.0,2.0,2.0,-1.0,2.0,0.25)$。\n- 测试 5：$(0.0,0.0,1.0,10^{-6},1.0,0.3)$。\n- 测试 6：$(5.0,-3.0,1.0,1.0,1.0,0.5)$。\n- 测试 7：$(0.0,0.0,1.0,-1.0,-1.0,0.75)$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的重构平面常数 $\\alpha$ 列表（以米为单位，精确到小数点后 $8$ 位）。例如，输出格式为\n$$\n[\\alpha_1,\\alpha_2,\\dots,\\alpha_7]\n$$\n其中每个 $\\alpha_k$ 均以米为单位并四舍五入到 $8$ 位小数。不应打印任何其他文本。",
            "solution": "该问题要求在一个正方形计算单元内，为二维分段线性界面表示构建平面常数 $\\alpha$。这是计算流体力学中的一项基本任务，尤其对于像耦合水平集和流体体积 (CLSVOF) 这样的界面捕捉方法而言。必须确定平面常数 $\\alpha$，使得单元格内液体区域的面积（由单元格与半空间 $\\mathbf{n}\\cdot\\mathbf{x} \\le \\alpha$ 的交集定义）与给定的流体体积分数 (VOF) $F$ 完全对应。\n\n控制 VOF 分数 $F$、单元格几何形状、界面法线 $\\mathbf{n}$ 和平面常数 $\\alpha$ 之间关系的方程是液相指示函数在单元格域 $\\mathcal{C}$ 上的积分：\n$$\nF = \\frac{1}{L^2} \\iint_{\\mathcal{C}} H(\\alpha - \\mathbf{n}\\cdot\\mathbf{x}) \\, dA\n$$\n此处，$\\mathcal{C}$ 是正方形单元格 $[x_0, x_0+L] \\times [y_0, y_0+L]$，其面积为 $L^2$，$\\mathbf{n}$ 是界面法向量，$H(\\cdot)$ 是亥维赛阶跃函数。该积分计算液体区域的面积 $A(\\alpha) = \\text{Area}(\\{ \\mathbf{x} \\in \\mathcal{C} \\mid \\mathbf{n}\\cdot\\mathbf{x} \\le \\alpha \\})$，然后由总单元格面积 $L^2$ 进行归一化。\n\n问题是在给定 $(x_0, y_0, L, n_x, n_y, F)$ 的情况下求 $\\alpha$。这可以重新表述为求解函数：\n$$\ng(\\alpha) = A(\\alpha) - F L^2 = 0\n$$\n的根的问题。\n\n求解方法如下：\n\n1.  **预处理**：根据规定，首先将给定的法向量 $\\mathbf{n}=(n_x, n_y)$ 归一化以获得单位法向量 $\\hat{\\mathbf{n}}$：\n    $$\n    \\hat{\\mathbf{n}} = \\frac{\\mathbf{n}}{\\|\\mathbf{n}\\|} = \\frac{(n_x, n_y)}{\\sqrt{n_x^2 + n_y^2}}\n    $$\n    所有后续涉及法线的计算都将使用这个单位向量 $\\hat{\\mathbf{n}}$。\n\n2.  **界定解的范围**：函数 $\\hat{\\mathbf{n}}\\cdot\\mathbf{x}$ 是 $\\mathbf{x}=(x,y)$ 的线性函数，因此其在凸域 $\\mathcal{C}$ 上的极值必定出现在单元格的顶点处。设单元格的四个顶点为 $P_1, P_2, P_3, P_4$。我们可以定义 $\\alpha$ 的界限：\n    $$\n    \\alpha_{min} = \\min_{i=1,2,3,4} (\\hat{\\mathbf{n}} \\cdot P_i)\n    $$\n    $$\n    \\alpha_{max} = \\max_{i=1,2,3,4} (\\hat{\\mathbf{n}} \\cdot P_i)\n    $$\n    如果 $\\alpha \\le \\alpha_{min}$，分离线 $\\hat{\\mathbf{n}}\\cdot\\mathbf{x} = \\alpha$ 要么不与单元格相交，要么仅在极小点处相切，因此液体面积 $A(\\alpha)$ 为 $0$。如果 $\\alpha \\ge \\alpha_{max}$，整个单元格都浸没在液体区域中，因此 $A(\\alpha) = L^2$。因此，解 $\\alpha$ 必须位于区间 $[\\alpha_{min}, \\alpha_{max}]$ 内。\n\n3.  **边界情况**：问题明确了边界 VOF 分数的处理方式：\n    - 如果 $F=0$，液体面积为零。这对应于区间的下界，因此我们设置 $\\alpha = \\alpha_{min}$。\n    - 如果 $F=1$，整个单元格都是液体。这对应于区间的上界，因此我们设置 $\\alpha = \\alpha_{max}$。\n\n4.  **对 $F \\in (0,1)$ 进行求根**：对于中间的 VOF 分数，我们必须求解 $g(\\alpha)=0$。液体面积函数 $A(\\alpha)$ 相对于 $\\alpha$ 是单调不减的。这确保了 $g(\\alpha)$ 也是单调的，从而保证在区间 $[\\alpha_{min}, \\alpha_{max}]$ 内存在唯一根。因此，使用区间法是合适的。由于其简单性和鲁棒性，我们将使用二分法。\n    二分法算法以区间 $[\\alpha_{low}, \\alpha_{high}] = [\\alpha_{min}, \\alpha_{max}]$ 初始化。在每次迭代中，选择一个中点 $\\alpha_{mid} = (\\alpha_{low} + \\alpha_{high}) / 2$。计算面积 $A(\\alpha_{mid})$。\n    - 如果 $A(\\alpha_{mid})  F L^2$，则试验面积太小，意味着 $\\alpha_{mid}$ 太小。更新下界：$\\alpha_{low} = \\alpha_{mid}$。\n    - 否则，试验面积太大或正确，因此 $\\alpha_{mid}$ 是一个可能的值或过大的值。更新上界：$\\alpha_{high} = \\alpha_{mid}$。\n    重复此过程固定的迭代次数，以达到高精度。\n\n5.  **几何面积计算**：问题的核心是计算给定试验 $\\alpha$ 的 $A(\\alpha)$，这必须通过几何裁剪来完成，而不能借助预先推导的解析公式。这包括两个步骤：\n    a. **多边形裁剪**：液体面积是由正方形单元格 $\\mathcal{C}$ 与半平面 $\\hat{\\mathbf{n}}\\cdot\\mathbf{x} \\le \\alpha$ 相交形成的多边形的面积。我们使用 Sutherland-Hodgman 算法来执行此裁剪过程。由其四个顶点按顺序表示的正方形单元格是“被裁剪多边形”。半平面定义了裁剪边界。该算法处理被裁剪多边形的每条边，生成一个新的顶点列表，构成裁剪后的多边形。对于端点为 $S$ 和 $E$ 的边，算法根据 $S$ 和 $E$ 是否在半平面内（即满足 $\\hat{\\mathbf{n}}\\cdot\\mathbf{x} - \\alpha \\le 0$）来输出顶点。当一条边穿过边界线 $\\hat{\\mathbf{n}}\\cdot\\mathbf{x} = \\alpha$ 时，计算交点 $I$ 并将其添加到新的顶点列表中。线段 $S$ 和 $E$ 与直线的交点可以通过参数化线段为 $P(t) = S+t(E-S)$（对于 $t\\in[0,1]$）来找到并求解 $t$：\n    $$\n    t = \\frac{\\alpha - \\hat{\\mathbf{n}} \\cdot S}{\\hat{\\mathbf{n}} \\cdot (E - S)}\n    $$\n    b. **多边形面积**：一旦确定了裁剪后多边形的顶点，就使用鞋带公式 (Shoelace formula) 计算其面积。对于一个有 $k$ 个顶点 $(x_1, y_1), (x_2, y_2), \\dots, (x_k, y_k)$ 顺序排列的多边形，其面积为：\n    $$\n    A = \\frac{1}{2} \\left| \\sum_{i=1}^{k} (x_i y_{i+1} - x_{i+1} y_i) \\right|\n    $$\n    其中 $(x_{k+1}, y_{k+1})$ 被视为 $(x_1, y_1)$。\n\n    通过整合这些组件，我们构建了一个鲁棒的程序来为任何有效的输入集找到 $\\alpha$。最终的程序为每个提供的测试用例实现了这一逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    # Test cases: (x0, y0, L, nx, ny, F)\n    test_cases = [\n        (0.0, 0.0, 1.0, 1.0, 1.0, 0.5),\n        (0.0, 0.0, 1.0, 0.3, 0.95, 0.0),\n        (0.0, 0.0, 1.0, 0.3, 0.95, 1.0),\n        (1.0, 2.0, 2.0, -1.0, 2.0, 0.25),\n        (0.0, 0.0, 1.0, 1e-6, 1.0, 0.3),\n        (5.0, -3.0, 1.0, 1.0, 1.0, 0.5),\n        (0.0, 0.0, 1.0, -1.0, -1.0, 0.75),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha = reconstruct_alpha(*case)\n        results.append(f\"{alpha:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef polygon_area(vertices):\n    \"\"\"\n    Calculates the area of a polygon using the Shoelace formula.\n    Assumes vertices are ordered (e.g., counter-clockwise).\n    \"\"\"\n    if len(vertices)  3:\n        return 0.0\n    \n    verts_array = np.array(vertices)\n    x = verts_array[:, 0]\n    y = verts_array[:, 1]\n    \n    # Use np.roll to cycle the arrays for the shoelace formula\n    area = 0.5 * np.abs(np.dot(x, np.roll(y, -1)) - np.dot(y, np.roll(x, -1)))\n    return area\n\ndef clip_polygon(subject_polygon, n_unit, alpha):\n    \"\"\"\n    Clips a convex polygon against the half-plane n_unit . x - alpha = 0.\n    Implementation of the Sutherland-Hodgman algorithm for a single clipping plane.\n    \"\"\"\n    clipped_vertices = []\n    num_vertices = len(subject_polygon)\n\n    for i in range(num_vertices):\n        start_point = subject_polygon[i]\n        end_point = subject_polygon[(i + 1) % num_vertices]\n\n        # Evaluate the half-plane condition g(x) = n . x - alpha\n        g_start = np.dot(n_unit, start_point) - alpha\n        g_end = np.dot(n_unit, end_point) - alpha\n        \n        is_start_inside = g_start = 0\n        is_end_inside = g_end = 0\n\n        # Case 1: Both vertices are inside\n        if is_start_inside and is_end_inside:\n            clipped_vertices.append(end_point)\n        # Case 2: Start is inside, End is outside\n        elif is_start_inside and not is_end_inside:\n            # Calculate intersection\n            # Denominator should not be zero unless edge is parallel to the line\n            denominator = np.dot(n_unit, end_point - start_point)\n            if abs(denominator) > 1e-15:\n                t = (alpha - np.dot(n_unit, start_point)) / denominator\n                intersection = start_point + t * (end_point - start_point)\n                clipped_vertices.append(intersection)\n        # Case 3: Both vertices are outside - do nothing\n        elif not is_start_inside and not is_end_inside:\n            pass\n        # Case 4: Start is outside, End is inside\n        elif not is_start_inside and is_end_inside:\n            # Calculate intersection\n            denominator = np.dot(n_unit, end_point - start_point)\n            if abs(denominator) > 1e-15:\n                t = (alpha - np.dot(n_unit, start_point)) / denominator\n                intersection = start_point + t * (end_point - start_point)\n                clipped_vertices.append(intersection)\n            clipped_vertices.append(end_point)\n    \n    return clipped_vertices\n\ndef reconstruct_alpha(x0, y0, L, nx, ny, F):\n    \"\"\"\n    Computes the plane constant alpha for a single test case.\n    \"\"\"\n    n_vec = np.array([nx, ny])\n    norm_n = np.linalg.norm(n_vec)\n    \n    # Per problem, n is non-zero so norm_n > 0\n    n_unit = n_vec / norm_n\n\n    # Define cell vertices\n    corners = [\n        np.array([x0, y0]),\n        np.array([x0 + L, y0]),\n        np.array([x0 + L, y0 + L]),\n        np.array([x0, y0 + L]),\n    ]\n\n    # Find bracketing values for alpha\n    dot_products = [np.dot(n_unit, p) for p in corners]\n    alpha_min = min(dot_products)\n    alpha_max = max(dot_products)\n\n    # Handle boundary cases F=0 and F=1\n    if F = 1e-9: # Use a tolerance for floating point comparison\n        return alpha_min\n    if F >= 1.0 - 1e-9:\n        return alpha_max\n\n    target_area = F * L**2\n\n    # Bisection method to find alpha\n    alpha_low = alpha_min\n    alpha_high = alpha_max\n    \n    # 100 iterations are more than sufficient for double precision\n    for _ in range(100):\n        alpha_mid = (alpha_low + alpha_high) / 2.0\n        \n        # Calculate area for the current alpha_mid\n        clipped_poly = clip_polygon(corners, n_unit, alpha_mid)\n        current_area = polygon_area(clipped_poly)\n        \n        if current_area  target_area:\n            alpha_low = alpha_mid\n        else:\n            alpha_high = alpha_mid\n            \n    return (alpha_low + alpha_high) / 2.0\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何静态表示界面之后，下一步是模拟作用在其上的关键物理力——表面张力。本练习将介绍连续表面力（CSF）模型，并让您直面一个在多相流模拟中普遍存在的棘手问题：寄生流（parasitic currents）。您将通过模拟一个静态液滴，亲身体验离散的压力梯度力与表面张力之间的不平衡如何催生非物理的虚假流动。完成这项实践不仅能让您掌握评估多相流求解器准确性的“试金石”测试，更能深刻理解为何在计算中实现精确的“力平衡”离散格式至关重要。",
            "id": "3968030",
            "problem": "一个静止的圆形液滴被嵌入一个方形域内的静止、不可压缩的两相流体中。其界面通过耦合水平集和流体体积法（CLSVOF）进行演化，具体而言，曲率由水平集表示法计算，而用于连续表面力（CSF）模型的颜色函数则由通过对水平集进行正则化Heaviside函数处理得到的平滑体积分数构建。目标是通过加密网格，在名义上的力平衡离散化方案下，评估由毛细力和压力离散不平衡引起的寄生速度。\n\n从带有连续表面力模型的不可压缩两相流的动量平衡方程开始：\n$$\n\\rho \\frac{\\partial \\boldsymbol{u}}{\\partial t} = -\\nabla p + \\mu \\nabla^2 \\boldsymbol{u} + \\sigma \\kappa \\delta(\\phi) \\boldsymbol{n}\n$$\n其中 $\\rho$ 是密度，$\\boldsymbol{u}$ 是速度， $p$ 是压力，$\\mu$ 是粘度，$\\sigma$ 是表面张力系数，$\\kappa$ 是平均曲率，$\\delta(\\phi)$ 是一个集中在由水平集函数 $\\phi$ 表示的界面上的正则化 Dirac 分布，而 $\\boldsymbol{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$ 是单位法向量。\n\n对于处于力学平衡状态的静止液滴，连续介质的力平衡条件意味着 $-\\nabla p + \\sigma \\kappa \\delta(\\phi) \\boldsymbol{n} = \\boldsymbol{0}$。在耦合水平集和流体体积法（CLSVOF）下，连续表面力（CSF）项实现为 $\\sigma \\kappa \\nabla F$，其中 $F$ 是通过对水平集函数应用正则化 Heaviside 函数得到的平滑体积分数（颜色函数）。使用力平衡离散化方法时，很自然地会选择 $p = \\sigma \\kappa F$，在曲率恒定且导数精确的情况下，这理想地抵消了毛细力项。在实践中，离散近似会引入一个残差，从而产生寄生速度。\n\n在边长为 $L$ 的二维方形域中实现以下内容：\n- 使用均匀的笛卡尔网格，包含 $N \\times N$ 个网格单元，尺寸为 $\\Delta x = \\Delta y = L/N$。\n- 将一个半径为 $R$ 的圆形液滴置于域中心 $(L/2, L/2)$。\n- 将水平集场定义为到圆周的符号距离函数：\n$$\n\\phi(x,y) = \\sqrt{(x - L/2)^2 + (y - L/2)^2} - R,\n$$\n液滴内部为负值。\n- 定义正则化的 Heaviside 函数，其平滑半宽为 $\\varepsilon$，\n$$\nH_\\varepsilon(\\phi) =\n\\begin{cases}\n0,  \\phi \\le -\\varepsilon, \\\\\n1,  \\phi \\ge \\varepsilon, \\\\\n\\frac{1}{2}\\left(1 + \\frac{\\phi}{\\varepsilon} + \\frac{1}{\\pi}\\sin\\left(\\pi \\frac{\\phi}{\\varepsilon}\\right)\\right),  \\text{otherwise},\n\\end{cases}\n$$\n并设置颜色函数 $F = H_\\varepsilon(\\phi)$。\n- 通过 $\\kappa = \\nabla \\cdot \\boldsymbol{n}$（其中 $\\boldsymbol{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$）从水平集计算曲率，使用二阶中心差分和周期性边界条件。\n- 计算连续表面力（CSF）为 $\\boldsymbol{f}_\\sigma = \\sigma \\kappa \\nabla F$，并从 $p = \\sigma \\kappa F$ 计算离散压力梯度；然后形成离散残差（不平衡量），\n$$\n\\boldsymbol{r} = \\boldsymbol{f}_\\sigma - \\nabla p,\n$$\n在连续介质的链式法则意义上，当曲率变化占主导时，该残差可简化为 $\\boldsymbol{r} \\approx -\\sigma F \\nabla \\kappa$。在所考虑的短时间内，将粘性视为可忽略不计，并从静止状态计算单步显式 Euler 速度更新，\n$$\n\\boldsymbol{u}^{(1)} = \\boldsymbol{0} + \\Delta t \\frac{\\boldsymbol{r}}{\\rho}\n$$\n将寄生速度的振幅定义为域上 $\\boldsymbol{u}^{(1)}$ 的最大模，\n$$\nU_{\\max} = \\max_{i,j} \\left\\| \\boldsymbol{u}^{(1)}_{i,j} \\right\\|\n$$\n\n使用以下物理参数（确保整个计算过程中单位一致，并以米/秒为单位报告速度）：$\\rho = 1000\\,\\text{kg}\\,\\text{m}^{-3}$，$\\sigma = 0.0728\\,\\text{N}\\,\\text{m}^{-1}$，$L = 1\\,\\text{m}$，$R = 0.25\\,\\text{m}$，$\\Delta t = 10^{-3}\\,\\text{s}$，$\\varepsilon = 1.5 \\Delta x$。对导数采用周期性边界条件。\n\n您的程序必须为以下每个测试用例计算 $U_{\\max}$。最终输出应为单行，包含一个用逗号分隔的 Python 列表，结果按指定顺序排列。\n\n测试套件：\n1. $N = 16$。\n2. $N = 32$。\n3. $N = 64$。\n4. $N = 128$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），每个结果都是一个以米/秒为单位的浮点数。不应打印其他任何文本。",
            "solution": "该问题要求计算在一个静止圆形液滴的耦合水平集和流体体积法（CLSVOF）模拟中，由数值力不平衡引起的寄生速度。该分析在一系列网格加密的二维笛卡尔网格上进行。\n\n### 问题验证\n\n首先，根据所需标准对问题陈述进行验证。\n\n**步骤 1：提取给定条件**\n\n*   **控制方程**：不可压缩两相流的动量平衡方程为 $\\rho \\frac{\\partial \\boldsymbol{u}}{\\partial t} = -\\nabla p + \\mu \\nabla^2 \\boldsymbol{u} + \\sigma \\kappa \\delta(\\phi) \\boldsymbol{n}$。\n*   **系统配置**：一个半径为 $R$ 的静止圆形液滴位于边长为 $L$ 的方形域内，中心在 $(L/2, L/2)$，周围是静止流体。粘度 $\\mu$ 被视为可忽略。\n*   **数值网格**：一个包含 $N \\times N$ 个单元的均匀笛卡尔网格，网格间距为 $\\Delta x = \\Delta y = L/N$。\n*   **水平集函数**：界面由符号距离函数 $\\phi(x,y) = \\sqrt{(x - L/2)^2 + (y - L/2)^2} - R$ 描述。\n*   **颜色函数**：平滑的颜色函数 $F$ 定义为 $F = H_\\varepsilon(\\phi)$，其中 $H_\\varepsilon(\\phi)$ 是一个正则化的 Heaviside 函数，平滑半宽为 $\\varepsilon = 1.5 \\Delta x$。该函数定义如下：\n    $$\n    H_\\varepsilon(\\phi) =\n    \\begin{cases}\n    0,  \\phi \\le -\\varepsilon, \\\\\n    1,  \\phi \\ge \\varepsilon, \\\\\n    \\frac{1}{2}\\left(1 + \\frac{\\phi}{\\varepsilon} + \\frac{1}{\\pi}\\sin\\left(\\pi \\frac{\\phi}{\\varepsilon}\\right)\\right),  \\text{otherwise}.\n    \\end{cases}\n    $$\n*   **数值离散化**：所有空间导数都将使用带有周期性边界条件的二阶中心差分进行计算。\n*   **力项**：连续表面力（CSF）为 $\\boldsymbol{f}_\\sigma = \\sigma \\kappa \\nabla F$。压力设置为 $p = \\sigma \\kappa F$。\n*   **曲率**：曲率由水平集函数计算得出：$\\kappa = \\nabla \\cdot \\boldsymbol{n}$，其中单位法向量为 $\\boldsymbol{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$。\n*   **力残差**：离散力不平衡为 $\\boldsymbol{r} = \\boldsymbol{f}_\\sigma - \\nabla p$。\n*   **速度更新**：使用从静止状态（$\\boldsymbol{u}^{(0)} = \\boldsymbol{0}$）开始的单步显式 Euler 更新：$\\boldsymbol{u}^{(1)} = \\Delta t \\frac{\\boldsymbol{r}}{\\rho}$。\n*   **输出度量**：寄生速度振幅是速度场的最大模：$U_{\\max} = \\max_{i,j} \\left\\| \\boldsymbol{u}^{(1)}_{i,j} \\right\\|$。\n*   **物理参数**：$\\rho = 1000\\,\\text{kg}\\,\\text{m}^{-3}$，$\\sigma = 0.0728\\,\\text{N}\\,\\text{m}^{-1}$，$L = 1\\,\\text{m}$，$R = 0.25\\,\\text{m}$，$\\Delta t = 10^{-3}\\,\\text{s}$。\n*   **测试套件**：将对 $N \\in \\{16, 32, 64, 128\\}$ 进行计算。\n\n**步骤 2：使用提取的给定条件进行验证**\n\n*   **科学依据**：该问题在计算流体力学领域有坚实的理论基础，特别是关于多相流的数值模拟。CLSVOF 方法、连续表面力模型以及寄生流的分析都是成熟且重要的课题。其控制方程和数值模型均为标准模型。\n*   **适定性**：该问题在计算上是适定的。它指定了一个确定性算法，包含了所有必要的函数、参数和边界条件。对于给定的网格分辨率（偶数 $N$），没有网格点恰好位于液滴的精确中心，从而避免了法向量 $\\boldsymbol{n}$ 定义中的奇异点。\n*   **客观性**：问题陈述使用了精确、客观和技术性的语言，没有任何主观因素。\n*   **一致性与完整性**：该问题是自洽的。所有变量、常数和程序都已定义。不存在矛盾之处。所选参数在物理上是现实的（标准状况下水的性质）。\n\n**步骤 3：结论与行动**\n\n该问题被判定为**有效**。它代表了一个标准的数值实验，用以评估力平衡表面张力离散化方案的准确性。将按要求提供解决方案。\n\n### 求解方法\n\n对于每个指定的网格分辨率 $N$，最大寄生速度振幅 $U_{\\max}$ 的计算通过一系列步骤进行。\n\n1.  **网格生成**：在方形域 $[0, L] \\times [0, L]$ 上构建一个二维网格。对于 $i, j \\in \\{0, 1, \\dots, N-1\\}$，单元中心 $(x_i, y_j)$ 定义为 $x_i = (i + 0.5)\\Delta x$ 和 $y_j = (j + 0.5)\\Delta y$，其中 $\\Delta x = \\Delta y = L/N$。\n\n2.  **场初始化**：在每个网格点上，使用其解析定义计算水平集函数的标量场 $\\phi_{i,j}$：$\\phi_{i,j} = \\sqrt{(x_i - L/2)^2 + (y_j - L/2)^2} - R$。\n\n3.  **颜色函数构建**：通过对水平集场应用正则化 Heaviside 函数 $H_\\varepsilon$ 来获得平滑的颜色函数场 $F_{i,j}$，即 $F_{i,j} = H_\\varepsilon(\\phi_{i,j})$，平滑宽度为 $\\varepsilon = 1.5\\Delta x$。\n\n4.  **离散导数算子**：对所有空间导数均使用带有周期性边界条件的二阶中心差分。对于网格上的通用标量场 $q$，其离散梯度 $\\nabla_d q$ 计算如下：\n    $$\n    (\\nabla_d q)_{i,j} = \\left( \\frac{q_{i+1,j} - q_{i-1,j}}{2\\Delta x}, \\frac{q_{i,j+1} - q_{i,j-1}}{2\\Delta y} \\right)\n    $$\n    对于向量场 $\\boldsymbol{v} = (v_x, v_y)$，其离散散度 $\\nabla_d \\cdot \\boldsymbol{v}$ 为：\n    $$\n    (\\nabla_d \\cdot \\boldsymbol{v})_{i,j} = \\frac{(v_x)_{i+1,j} - (v_x)_{i-1,j}}{2\\Delta x} + \\frac{(v_y)_{i,j+1} - (v_y)_{i,j-1}}{2\\Delta y}\n    $$\n    在这两种情况下，索引都对 $N$ 取模以强制实现周期性。\n\n5.  **曲率计算**：曲率场 $\\kappa$ 的计算分两个阶段。首先，计算水平集函数的梯度 $\\nabla_d \\phi$。然后通过在每个点上对该梯度进行归一化来找到单位法向量场 $\\boldsymbol{n}$：$\\boldsymbol{n}_{i,j} = (\\nabla_d \\phi)_{i,j} / \\lVert (\\nabla_d \\phi)_{i,j} \\rVert$。在实践中，为防止除以零，分母会加上一个小的容差。其次，计算单位法向量场的散度以得到曲率：$\\kappa_{i,j} = (\\nabla_d \\cdot \\boldsymbol{n})_{i,j}$。\n\n6.  **力的计算**：\n    *   直接计算压力场：$p_{i,j} = \\sigma \\kappa_{i,j} F_{i,j}$。\n    *   计算颜色函数的离散梯度 $(\\nabla_d F)_{i,j}$。\n    *   然后组合得到 CSF 向量场：$(\\boldsymbol{f}_\\sigma)_{i,j} = \\sigma \\kappa_{i,j} (\\nabla_d F)_{i,j}$。\n    *   计算离散压力梯度向量场 $(\\nabla_d p)_{i,j}$。\n\n7.  **残差与速度**：每个网格点上的力不平衡（残差）是离散 CSF 和压力梯度之间的差：$\\boldsymbol{r}_{i,j} = (\\boldsymbol{f}_\\sigma)_{i,j} - (\\nabla_d p)_{i,j}$。此残差驱动寄生流。从静止状态开始，经过一个短暂时间 $\\Delta t$ 的单步显式 Euler 时间步长可得到速度场：\n    $$\n    \\boldsymbol{u}^{(1)}_{i,j} = \\frac{\\Delta t}{\\rho} \\boldsymbol{r}_{i,j}\n    $$\n\n8.  **最大寄生速度**：在每个网格点计算速度向量的模 $\\lVert \\boldsymbol{u}^{(1)}_{i,j} \\rVert$。整个域上的最大值即为所需度量 $U_{\\max}$：\n    $$\n    U_{\\max} = \\max_{i,j} \\sqrt{ (u_x^{(1)})_{i,j}^2 + (u_y^{(1)})_{i,j}^2 }\n    $$\n对测试套件 $\\{16, 32, 64, 128\\}$ 中的每个 $N$ 值重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum parasitic velocity for a stationary droplet\n    using a CLSVOF method for different grid resolutions.\n    \"\"\"\n\n    # Physical parameters\n    rho = 1000.0   # kg/m^3\n    sigma = 0.0728 # N/m\n    L = 1.0        # m\n    R = 0.25       # m\n    dt = 1e-3      # s\n\n    # Grid resolutions to test\n    test_cases = [16, 32, 64, 128]\n    \n    results = []\n\n    for N in test_cases:\n        # 1. Grid Generation\n        dx = L / N\n        dy = L / N\n        x = (np.arange(N) + 0.5) * dx\n        y = (np.arange(N) + 0.5) * dy\n        X, Y = np.meshgrid(x, y)\n\n        # 2. Field Initialization: Level-Set Function\n        phi = np.sqrt((X - L/2)**2 + (Y - L/2)**2) - R\n\n        # 3. Color Function Construction\n        eps = 1.5 * dx\n        \n        def regularized_heaviside(phi_field, epsilon):\n            H = np.zeros_like(phi_field)\n            \n            # Region |phi| = epsilon\n            mask = np.abs(phi_field) = epsilon\n            phi_norm = phi_field[mask] / epsilon\n            H[mask] = 0.5 * (1 + phi_norm + (1/np.pi) * np.sin(np.pi * phi_norm))\n            \n            # Region phi >= epsilon\n            H[phi_field >= epsilon] = 1.0\n            \n            # Region phi = -epsilon is already 0.0\n            return H\n\n        F = regularized_heaviside(phi, eps)\n\n        # 4. Discrete Derivative Operators\n        def gradient(q, hx, hy):\n            \"\"\"Computes gradient using 2nd-order central differences with periodic BCs.\"\"\"\n            grad_x = (np.roll(q, -1, axis=1) - np.roll(q, 1, axis=1)) / (2 * hx)\n            grad_y = (np.roll(q, -1, axis=0) - np.roll(q, 1, axis=0)) / (2 * hy)\n            return grad_x, grad_y\n\n        def divergence(vx, vy, hx, hy):\n            \"\"\"Computes divergence using 2nd-order central differences with periodic BCs.\"\"\"\n            dvx_dx = (np.roll(vx, -1, axis=1) - np.roll(vx, 1, axis=1)) / (2 * hx)\n            dvy_dy = (np.roll(vy, -1, axis=0) - np.roll(vy, 1, axis=0)) / (2 * hy)\n            return dvx_dx + dvy_dy\n\n        # 5. Curvature Calculation\n        phi_gx, phi_gy = gradient(phi, dx, dy)\n        norm_grad_phi = np.sqrt(phi_gx**2 + phi_gy**2) + 1e-15 # Add epsilon for stability\n        \n        nx = phi_gx / norm_grad_phi\n        ny = phi_gy / norm_grad_phi\n        \n        kappa = divergence(nx, ny, dx, dy)\n        \n        # 6. Force Calculation\n        p = sigma * kappa * F\n        \n        F_gx, F_gy = gradient(F, dx, dy)\n        f_sigma_x = sigma * kappa * F_gx\n        f_sigma_y = sigma * kappa * F_gy\n        \n        p_gx, p_gy = gradient(p, dx, dy)\n\n        # 7. Residual and Velocity\n        r_x = f_sigma_x - p_gx\n        r_y = f_sigma_y - p_gy\n        \n        u_x = (dt / rho) * r_x\n        u_y = (dt / rho) * r_y\n\n        # 8. Maximum Parasitic Velocity\n        u_mag = np.sqrt(u_x**2 + u_y**2)\n        U_max = np.max(u_mag)\n        results.append(U_max)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本练习是一项综合性的实践，它将前面所学的几何重构和力模型等概念融为一体，是CLSVOF方法的一个缩影。您将为一个由相变驱动的移动界面实现一个完整的时间步更新算法 。这项任务要求您协同处理水平集函数 $\\phi$（用于精确几何计算）和流体体积分数 $F$（用于保证质量守恒）的对流输运，并执行对 $\\phi$ 的重新初始化以维持其符号距离特性。通过这个练习，您将深入理解CLSVOF方法如何耦合两种互补的界面追踪技术，以发挥它们各自的优势，从而构建一个既精确又守恒的强大数值工具。",
            "id": "3967984",
            "problem": "您需要为一个经历相变的二维界面实现耦合水平集-流体体积（CLSVOF）方法的单步显式更新，该实现适用于计算热工领域的进阶研究生学习。耦合水平集-流体体积（CLSVOF）方法结合了水平集函数 $ \\phi $（用于将界面表示为有符号距离函数）和流体体积分数 $ F \\in [0,1] $（用于确保输运相分数的守恒）。更新步骤必须使用扩展速度场来平流输运 $ \\phi $，使其与相变一致，同时 $ F $ 的更新必须是守恒的。\n\n更新步骤基于以下基本定律和定义：\n\n- 水平集平流方程为 $ \\partial \\phi / \\partial t + \\mathbf{u}_{\\text{ext}} \\cdot \\nabla \\phi = 0 $，其中 $ \\mathbf{u}_{\\text{ext}} $ 是一个扩展速度，定义为使界面沿其法线方向移动，并与相变一致。\n- 流体体积守恒定律为 $ \\partial F / \\partial t + \\nabla \\cdot (F \\mathbf{u}_{\\text{ext}}) = 0 $，必须对其进行离散化以确保 $ F $ 的守恒性。\n- 扩展速度定义为 $ \\mathbf{u}_{\\text{ext}} = V_n \\, \\mathbf{n} $，其中 $ \\mathbf{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert $ 是界面的单位法向量，$ V_n $ 是由单相 Stefan 条件给出的法向界面速度。对于传导驱动的相变，Stefan 条件为 $ \\rho L V_n = ( \\mathbf{q}_\\ell - \\mathbf{q}_s ) \\cdot \\mathbf{n} $，其中 $ \\rho $ 是密度，$ L $ 是潜热，$ \\mathbf{q}_\\ell = -k_\\ell \\nabla T_\\ell $ 是液体热通量，$ \\mathbf{q}_s = -k_s \\nabla T_s $ 是固体热通量。在本问题中，请使用符号约定 $ V_n = ( k_\\ell \\nabla T_\\ell - k_s \\nabla T_s ) \\cdot \\mathbf{n} / ( \\rho L ) $。\n- 平流后将 $ \\phi $ 重新初始化为有符号距离函数的过程，是通过在短暂的伪时间 $ \\tau $ 内对重新初始化方程 $ \\partial \\phi / \\partial \\tau + S_\\epsilon(\\phi_0)( \\lVert \\nabla \\phi \\rVert - 1 ) = 0 $ 进行积分来完成的。其中 $ \\phi_0 $ 是重新初始化前的场，$ S_\\epsilon(\\phi_0) = \\phi_0 / \\sqrt{ \\phi_0^2 + \\epsilon^2 } $ 是一个正则化的符号函数。重新初始化是为了保持有符号距离属性，以便进行精确的法向量计算。\n\n您必须在单个程序中实现以下内容：\n\n- 考虑一个方形域 $ [0,1] \\times [0,1] $，两个坐标方向均为周期性边界条件。网格分辨率为 $ N_x = 64 $，$ N_y = 64 $，均匀间距为 $ \\Delta x = 1/N_x $ 和 $ \\Delta y = 1/N_y $。所有空间维度单位为米，因此 $ \\Delta x $ 和 $ \\Delta y $ 的单位为米。\n- 将水平集 $ \\phi(x,y) $ 初始化为距离中心在 $ (x_c, y_c) = (0.5, 0.5) $ 米、半径为 $ R = 0.25 $ 米的圆的有符号距离。圆内 $ \\phi  0 $，圆外 $ \\phi > 0 $。流体体积分数 $ F $ 必须初始化为 $ \\phi $ 的平滑 Heaviside 函数，$ F = H_\\epsilon(\\phi) $，其中 $ \\epsilon = 2 \\Delta x $，并且当 $ \\phi \\le -\\epsilon $ 时 $ H_\\epsilon(\\phi) = 0 $，当 $ \\phi \\ge \\epsilon $ 时 $ H_\\epsilon(\\phi) = 1 $，否则 $ H_\\epsilon(\\phi) = \\frac{1}{2}\\left( 1 + \\frac{\\phi}{\\epsilon} + \\frac{1}{\\pi} \\sin \\left( \\frac{\\pi \\phi}{\\epsilon} \\right) \\right) $。\n- 定义恒定的材料属性：$ \\rho = 1000 \\, \\mathrm{kg/m^3} $，$ L = 3.34 \\times 10^5 \\, \\mathrm{J/kg} $，$ k_s = 1.0 \\, \\mathrm{W/(m\\cdot K)} $，$ k_\\ell = 2.0 \\, \\mathrm{W/(m\\cdot K)} $。\n- 对于每个测试用例，定义解析温度梯度 $ \\nabla T_s = (\\alpha, 0) $ 和 $ \\nabla T_\\ell = (-\\alpha, 0) $（单位为开尔文每米），其中 $ \\alpha $ 由测试套件指定。使用当前由 $ \\phi $ 计算出的 $ \\mathbf{n} $，逐点计算界面法向速度 $ V_n = \\left( k_\\ell \\nabla T_\\ell - k_s \\nabla T_s \\right) \\cdot \\mathbf{n} / (\\rho L) $。然后设置 $ \\mathbf{u}_{\\text{ext}} = V_n \\, \\mathbf{n} $。没有整体流动，只有相变引起的运动，因此 $ \\mathbf{u}_{\\text{ext}} $ 是纯法向的。\n- 根据 Courant–Friedrichs–Lewy (CFL) 条件计算稳定时间步长 $ \\Delta t = \\mathrm{CFL} \\cdot \\min(\\Delta x, \\Delta y) / \\max_{i,j} \\lVert \\mathbf{u}_{\\text{ext}} \\rVert $，其中 $ \\mathrm{CFL} = 0.5 $。如果 $ \\max \\lVert \\mathbf{u}_{\\text{ext}} \\rVert = 0 $，则使用 $ \\Delta t = \\mathrm{CFL} \\cdot \\min(\\Delta x, \\Delta y) / 10^{-12} $ 以避免除以零。时间单位为秒。\n- 通过对 $ \\partial \\phi / \\partial t + \\mathbf{u}_{\\text{ext}} \\cdot \\nabla \\phi = 0 $ 进行显式一阶迎风离散化来更新 $ \\phi $，两个方向均采用周期性边界条件。\n- 使用 Godunov 型离散格式对 $ \\lVert \\nabla \\phi \\rVert $ 和 $ S_\\epsilon(\\phi_0) $（其中 $ \\epsilon = \\Delta x $）进行处理，通过在短暂的伪时间内对重新初始化方程进行积分，将 $ \\phi $ 重新初始化为有符号距离函数。使用至少 $ 15 $ 个伪时间步，步长为 $ \\Delta \\tau = 0.3 \\min(\\Delta x, \\Delta y) $。\n- 使用守恒的有限体积迎风通量法对 $ \\partial F / \\partial t + \\nabla \\cdot (F \\mathbf{u}_{\\text{ext}}) = 0 $ 进行求解来更新 $ F $，采用周期性边界条件，确保离散更新在数值舍入误差范围内保持 $ F $ 的总积分守恒。不要对 $ F $ 进行裁剪；而是要度量任何对 $ F \\in [0,1] $ 的违反情况。\n- 更新后，为每个测试用例计算以下度量指标：\n    1. $ m_0 = \\left| \\sum_{i,j} F^{n+1}_{i,j} - \\sum_{i,j} F^{n}_{i,j} \\right| $，$ F $ 的无量纲离散守恒误差。\n    2. $ m_1 = \\sum_{i,j} \\max(0, F^{n+1}_{i,j} - 1) + \\sum_{i,j} \\max(0, -F^{n+1}_{i,j}) $，一个衡量物理边界 $ F \\in [0,1] $ 违反程度的无量纲度量。\n    3. $ m_2 = \\sqrt{ \\frac{1}{N_x N_y} \\sum_{i,j} \\left( H_\\epsilon(\\phi^{n+1}_{i,j}) - F^{n+1}_{i,j} \\right)^2 } $，更新后的 $ F $ 与更新后的 $ \\phi $ 的平滑 Heaviside 函数之间的无量纲均方根一致性误差，使用与上文相同的 $ \\epsilon $。\n- 通过将 $ \\alpha $ 设置为三个不同的值，实现以下测试套件：\n    - 测试用例 A：$ \\alpha = 0.0 $。\n    - 测试用例 B：$ \\alpha = 1.0 $。\n    - 测试用例 C：$ \\alpha = 5.0 $。\n- 您的程序应生成单行输出，包含九个标量结果 $ [m_0^\\mathrm{A}, m_1^\\mathrm{A}, m_2^\\mathrm{A}, m_0^\\mathrm{B}, m_1^\\mathrm{B}, m_2^\\mathrm{B}, m_0^\\mathrm{C}, m_1^\\mathrm{C}, m_2^\\mathrm{C}] $，形式为方括号括起来的逗号分隔列表，每个条目表示为无单位的十进制数。\n\n所有物理参数必须使用正确的单位处理：长度单位为米，时间单位为秒，密度单位为千克每立方米，导热系数单位为瓦特每米开尔文，潜热单位为焦耳每千克，温度梯度单位为开尔文每米。不使用角度。算法必须从给定的基本定律开始，除了标准的数值离散化方法外，不应引入任何捷径或预先推导的公式。测试套件确保覆盖了零相变速度、中等法向速度和较大法向速度的情况。程序必须是完全自包含的，并且不需要任何输入。",
            "solution": "用户提供了一个有效的问题陈述，要求为二维相变场景实现耦合水平集-流体体积（CLSVOF）方法的单步更新。该问题在计算热工领域具有科学依据，问题设定良好且客观。所有必需的方程、参数和数值方法都已指定。我将着手提供一个完整的解决方案。\n\n对于每个测试用例，实现将遵循一系列不同的步骤：\n1.  **初始化**：将一个大小为 $1 \\times 1$ 的方形计算域离散化为 $64 \\times 64$ 的网格。水平集函数 $\\phi$ 被初始化为到以 $(0.5, 0.5)$ 为中心、半径为 $R=0.25$ 的圆的有符号距离函数。流体体积分数函数 $F$ 被初始化为 $\\phi$ 的正则化 Heaviside 函数，记为 $H_\\epsilon(\\phi)$，平滑宽度为 $\\epsilon = 2\\Delta x$。\n2.  **速度场计算**：计算驱动界面运动的扩展速度场 $\\mathbf{u}_{\\text{ext}}$。该速度垂直于界面，$\\mathbf{u}_{\\text{ext}} = V_n \\mathbf{n}$。\n    -   单位法向量 $\\mathbf{n} = \\nabla\\phi / \\lVert \\nabla\\phi \\rVert$ 是根据水平集场计算得出的，其中梯度 $\\nabla\\phi$ 使用二阶中心差分计算。强制执行周期性边界条件。为防止除以零，在分母上增加了一个小容差。\n    -   法向速度 $V_n$ 由 Stefan 条件确定，$V_n = ( k_\\ell \\nabla T_\\ell - k_s \\nabla T_s ) \\cdot \\mathbf{n} / (\\rho L)$。问题指定了恒定的温度梯度 $\\nabla T_s = (\\alpha, 0)$ 和 $\\nabla T_\\ell = (-\\alpha, 0)$，这可将表达式简化为 $V_n = -(k_\\ell + k_s)\\alpha n_x / (\\rho L)$，其中 $n_x$ 是法向量的 x 分量。\n3.  **时间步长确定**：使用 Courant–Friedrichs–Lewy (CFL) 条件计算稳定的时间步长 $\\Delta t$：$\\Delta t = \\mathrm{CFL} \\cdot \\min(\\Delta x, \\Delta y) / \\max \\lVert \\mathbf{u}_{\\text{ext}} \\rVert$，其中 $\\mathrm{CFL} = 0.5$。\n4.  **水平集平流**：水平集函数 $\\phi$ 根据方程 $\\partial \\phi / \\partial t + \\mathbf{u}_{\\text{ext}} \\cdot \\nabla \\phi = 0$ 进行时间平流。该方程使用显式一阶迎风格式进行离散化。空间导数 $\\nabla \\phi$ 使用单边差分进行近似，差分方向根据每个网格单元处速度分量的符号选择，以确保数值稳定性。\n5.  **水平集重新初始化**：平流后，$\\phi$ 场可能不再是有符号距离函数。通过求解方程 $\\partial \\phi / \\partial \\tau + S_\\epsilon(\\phi_0)( \\lVert \\nabla \\phi \\rVert - 1 ) = 0$ 若干伪时间步长 $\\tau$ 来对其进行重新初始化。这里，$\\phi_0$ 是平流后的水平集场，$S_\\epsilon$ 是一个平滑的符号函数，可保持零水平集静止。Hamilton-Jacobi 项 $\\lVert \\nabla \\phi \\rVert$ 使用 Godunov 型迎风格式进行离散化，这对此类问题是标准做法，并根据信息传播方向（由 $S_\\epsilon(\\phi_0)$ 指示）选择适当的单边差分。\n6.  **流体体积平流**：通过求解守恒定律 $\\partial F / \\partial t + \\nabla \\cdot (F \\mathbf{u}_{\\text{ext}}) = 0$ 来更新流体体积分数 $F$。使用守恒的有限体积法。穿过每个单元面的通量 $F \\mathbf{u}_{\\text{ext}}$ 使用一阶迎风格式计算。单元面上的 $F$ 值取自上风向单元，由该面法向速度的符号确定。这种离散化确保了流体总体积 $\\sum F_{i,j}$ 在机器精度内是守恒的。\n7.  **度量指标计算**：最后，计算三个指定的度量指标以评估更新步骤的性能：\n    -   $m_0$：离散守恒误差，计算为更新前后 $F$ 值总和的绝对差。\n    -   $m_1$：对边界 $F \\in [0,1]$ 违反情况的总和。\n    -   $m_2$：衡量更新后的 $F$ 场与更新后的 $\\phi$ 场的 Heaviside 函数之间一致性的均方根误差。\n\n对参数 $\\alpha$ 的三个指定值重复整个过程，该参数控制相变速度的大小。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a single explicit update step of the Coupled Level-Set Volume-of-Fluid (CLSVOF)\n    method for a two-dimensional interface undergoing phase change.\n    \"\"\"\n\n    def heaviside_smooth(phi, epsilon):\n        \"\"\"\n        Computes the smoothed Heaviside function H_epsilon(phi).\n        \"\"\"\n        F = np.zeros_like(phi)\n        mask = np.abs(phi) = epsilon\n        phi_masked = phi[mask]\n        F[mask] = 0.5 * (1 + phi_masked / epsilon + (1 / np.pi) * np.sin(np.pi * phi_masked / epsilon))\n        F[phi > epsilon] = 1.0\n        F[phi  -epsilon] = 0.0\n        return F\n\n    def sign_smooth(phi, epsilon):\n        \"\"\"\n        Computes the regularized sign function S_epsilon(phi).\n        \"\"\"\n        return phi / np.sqrt(phi**2 + epsilon**2)\n\n    def run_case(alpha, Nx, Ny, R, x_c, y_c, rho, L_heat, ks, kl):\n        \"\"\"\n        Executes the full CLSVOF update step for a given test case alpha.\n        \"\"\"\n        # --- 1. Initialization ---\n        dx = 1.0 / Nx\n        dy = 1.0 / Ny\n        x = np.linspace(0.5 * dx, 1.0 - 0.5 * dx, Nx)\n        y = np.linspace(0.5 * dy, 1.0 - 0.5 * dy, Ny)\n        xx, yy = np.meshgrid(x, y)\n\n        phi = np.sqrt((xx - x_c)**2 + (yy - y_c)**2) - R\n        eps_H = 2.0 * dx\n        F_initial = heaviside_smooth(phi, eps_H)\n        \n        sum_F_initial = np.sum(F_initial)\n        F = F_initial.copy()\n        \n        # --- 2. Velocity Field Calculation ---\n        grad_phi_x = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * dx)\n        grad_phi_y = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2.0 * dy)\n        norm_grad_phi = np.sqrt(grad_phi_x**2 + grad_phi_y**2)\n        \n        nx = grad_phi_x / (norm_grad_phi + 1e-12)\n        ny = grad_phi_y / (norm_grad_phi + 1e-12)\n\n        Vn = -(kl + ks) * alpha * nx / (rho * L_heat)\n        u_ext_x = Vn * nx\n        u_ext_y = Vn * ny\n\n        # --- 3. Time Step Determination ---\n        max_vel = np.max(np.sqrt(u_ext_x**2 + u_ext_y**2))\n        CFL = 0.5\n        dt = CFL * min(dx, dy) / (max_vel if max_vel > 1e-15 else 1e-12)\n\n        # --- 4. Level-Set Advection ---\n        phi_dx_b = (phi - np.roll(phi, 1, axis=1)) / dx\n        phi_dx_f = (np.roll(phi, -1, axis=1) - phi) / dx\n        phi_dy_b = (phi - np.roll(phi, 1, axis=0)) / dy\n        phi_dy_f = (np.roll(phi, -1, axis=0) - phi) / dy\n        \n        advection_term = (np.maximum(u_ext_x, 0) * phi_dx_b + np.minimum(u_ext_x, 0) * phi_dx_f +\n                          np.maximum(u_ext_y, 0) * phi_dy_b + np.minimum(u_ext_y, 0) * phi_dy_f)\n        phi_advected = phi - dt * advection_term\n\n        # --- 5. Level-Set Reinitialization ---\n        phi_reinit = phi_advected.copy()\n        phi_0 = phi_advected.copy()\n        eps_reinit = dx\n        dtau = 0.3 * min(dx, dy)\n        num_reinit_steps = 15\n        \n        sign_phi0 = sign_smooth(phi_0, eps_reinit)\n\n        for _ in range(num_reinit_steps):\n            phi_x_m = (phi_reinit - np.roll(phi_reinit, 1, axis=1)) / dx\n            phi_x_p = (np.roll(phi_reinit, -1, axis=1) - phi_reinit) / dx\n            phi_y_m = (phi_reinit - np.roll(phi_reinit, 1, axis=0)) / dy\n            phi_y_p = (np.roll(phi_reinit, -1, axis=0) - phi_reinit) / dy\n\n            grad_phi_mag_sq = np.zeros_like(phi_reinit)\n            \n            mask_pos = sign_phi0 > 0\n            term_x_sq_pos = np.maximum(np.maximum(phi_x_m[mask_pos], 0)**2, np.minimum(phi_x_p[mask_pos], 0)**2)\n            term_y_sq_pos = np.maximum(np.maximum(phi_y_m[mask_pos], 0)**2, np.minimum(phi_y_p[mask_pos], 0)**2)\n            grad_phi_mag_sq[mask_pos] = term_x_sq_pos + term_y_sq_pos\n            \n            mask_neg = sign_phi0  0\n            term_x_sq_neg = np.maximum(np.minimum(phi_x_m[mask_neg], 0)**2, np.maximum(phi_x_p[mask_neg], 0)**2)\n            term_y_sq_neg = np.maximum(np.minimum(phi_y_m[mask_neg], 0)**2, np.maximum(phi_y_p[mask_neg], 0)**2)\n            grad_phi_mag_sq[mask_neg] = term_x_sq_neg + term_y_sq_neg\n\n            grad_phi_mag = np.sqrt(grad_phi_mag_sq)\n            phi_reinit -= dtau * sign_phi0 * (grad_phi_mag - 1)\n        \n        phi_final = phi_reinit\n\n        # --- 6. Volume-of-Fluid Advection ---\n        u_face_x = (u_ext_x + np.roll(u_ext_x, -1, axis=1)) / 2.0\n        u_face_y = (u_ext_y + np.roll(u_ext_y, -1, axis=0)) / 2.0\n\n        flux_x = np.maximum(u_face_x, 0) * F + np.minimum(u_face_x, 0) * np.roll(F, -1, axis=1)\n        flux_y = np.maximum(u_face_y, 0) * F + np.minimum(u_face_y, 0) * np.roll(F, -1, axis=0)\n\n        div_flux_x = (flux_x - np.roll(flux_x, 1, axis=1)) / dx\n        div_flux_y = (flux_y - np.roll(flux_y, 1, axis=0)) / dy\n        \n        F_final = F - dt * (div_flux_x + div_flux_y)\n\n        # --- 7. Metric Calculation ---\n        sum_F_final = np.sum(F_final)\n        m0 = np.abs(sum_F_final - sum_F_initial)\n        m1 = np.sum(np.maximum(0, F_final - 1.0)) + np.sum(np.maximum(0, -F_final))\n        F_from_phi_final = heaviside_smooth(phi_final, eps_H)\n        m2 = np.sqrt(np.mean((F_from_phi_final - F_final)**2))\n        \n        return m0, m1, m2\n\n    # Define constants and test cases\n    Nx, Ny = 64, 64\n    R, x_c, y_c = 0.25, 0.5, 0.5\n    rho = 1000.0\n    L_heat = 3.34e5\n    ks = 1.0\n    kl = 2.0\n    \n    test_cases_alpha = [0.0, 1.0, 5.0]\n    results = []\n\n    for alpha in test_cases_alpha:\n        m0, m1, m2 = run_case(alpha, Nx, Ny, R, x_c, y_c, rho, L_heat, ks, kl)\n        results.extend([m0, m1, m2])\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}