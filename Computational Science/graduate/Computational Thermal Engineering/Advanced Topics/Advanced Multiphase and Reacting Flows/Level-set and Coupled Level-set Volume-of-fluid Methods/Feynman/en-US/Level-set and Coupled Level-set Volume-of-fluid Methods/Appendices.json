{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of modern Volume-of-Fluid (VOF) and Coupled Level-Set VOF (CLSVOF) methods is the accurate geometric representation of the fluid interface within each computational cell. The Piecewise-Linear Interface Calculation (PLIC) is a powerful technique that approximates the interface as a straight line or plane. This exercise challenges you to tackle the fundamental inverse problem: given a known volume fraction $F$ and an interface normal vector $\\mathbf{n}$ in a cell, you must reconstruct the precise position of the interface plane . Mastering this practice provides direct experience with the geometric clipping and root-finding algorithms at the heart of high-fidelity interface tracking.",
            "id": "3967973",
            "problem": "You are tasked with constructing the unknown plane constant in a piecewise-linear interface reconstruction for a two-dimensional control volume in a Coupled Level-Set and Volume-of-Fluid (CLSVOF) method. The two-dimensional control volume is a square cell with lower-left corner at position vector $\\mathbf{r}_0 = (x_0,y_0)$ and side length $L$ in meters. The interface inside the cell is represented by the planar level set\n$$\n\\mathbf{n}\\cdot\\mathbf{x} = \\alpha,\n$$\nwhere $\\mathbf{n}=(n_x,n_y)$ is a nonzero normal vector estimated from the gradient of a level-set function and $\\alpha$ is a scalar with units of meters. The liquid region is defined by the half-space\n$$\n\\Omega_\\ell(\\alpha) = \\left\\{ \\mathbf{x}\\in \\mathbb{R}^2 \\ \\big|\\ \\mathbf{n}\\cdot \\mathbf{x} \\le \\alpha \\right\\}.\n$$\nThe Volume-of-Fluid fraction $F$ inside the cell (dimensionless) is defined from first principles by the area average of the indicator (Heaviside) function,\n$$\nF \\;=\\; \\frac{1}{L^2}\\iint_{\\mathcal{C}} H\\!\\left(\\alpha - \\mathbf{n}\\cdot\\mathbf{x}\\right)\\, dA,\n$$\nwhere $\\mathcal{C}=\\left\\{(x,y)\\ \\big|\\ x_0\\le x\\le x_0+L,\\ y_0\\le y\\le y_0+L\\right\\}$ is the cell and $H(\\cdot)$ is the Heaviside step function. You are given the local Volume-of-Fluid fraction $F$ and a gradient-based estimate of the interface normal $\\mathbf{n}$ that may not be unit length. Construct $\\alpha$ such that the above definition of $F$ holds exactly in the given geometric configuration. You must:\n- Normalize $\\mathbf{n}$ to unit length prior to reconstruction.\n- Treat the liquid region as $\\{\\mathbf{x}\\in\\mathcal{C}\\mid \\mathbf{n}\\cdot \\mathbf{x} \\le \\alpha\\}$.\n- Handle the boundary cases $F=0$ and $F=1$ by setting $\\alpha$ equal to the minimum and maximum possible values of $\\mathbf{n}\\cdot\\mathbf{x}$ over the cell corners, respectively.\n- For $F\\in(0,1)$, compute $\\alpha$ by solving the nonlinear equation given by the integral definition above without using any closed-form shortcut for polygon areas as a function of $\\alpha$. Use geometric clipping of the square cell by the half-space $\\mathbf{n}\\cdot\\mathbf{x}\\le \\alpha$ to exactly compute the area at any trial $\\alpha$, and then use a bracketing root-finding method justified by monotonicity to determine $\\alpha$.\n\nExpress the final $\\alpha$ for each test case in meters, rounded to exactly $8$ decimal places.\n\nYou must implement a complete, runnable program that:\n- Accepts no input and reads no files.\n- Uses only the Python standard library and, if desired, the specified numerical libraries.\n- For each test case, computes $\\alpha$ as specified and assembles the results into a single list.\n\nUse the following test suite. Each test case is a tuple $(x_0,y_0,L,n_x,n_y,F)$ with all quantities in the International System of Units (SI), where $L$ and $\\alpha$ are in meters and $F$ is dimensionless:\n- Test $1$: $(0.0,0.0,1.0,1.0,1.0,0.5)$.\n- Test $2$: $(0.0,0.0,1.0,0.3,0.95,0.0)$.\n- Test $3$: $(0.0,0.0,1.0,0.3,0.95,1.0)$.\n- Test $4$: $(1.0,2.0,2.0,-1.0,2.0,0.25)$.\n- Test $5$: $(0.0,0.0,1.0,10^{-6},1.0,0.3)$.\n- Test $6$: $(5.0,-3.0,1.0,1.0,1.0,0.5)$.\n- Test $7$: $(0.0,0.0,1.0,-1.0,-1.0,0.75)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of the reconstructed plane constants $\\alpha$ in meters, rounded to exactly $8$ decimal places, enclosed in square brackets. For example, an output of the form\n$$\n[\\alpha_1,\\alpha_2,\\dots,\\alpha_7]\n$$\nwith each $\\alpha_k$ rounded to $8$ decimal places in meters. No other text should be printed.",
            "solution": "The problem requires the construction of the plane constant $\\alpha$ for a two-dimensional, piecewise-linear interface representation within a square computational cell. This is a fundamental task in computational fluid dynamics, particularly for interface-capturing methods like the Coupled Level-Set and Volume-of-Fluid (CLSVOF) method. The plane constant $\\alpha$ must be determined such that the area of the liquid region inside the cell, defined by the intersection of the cell with the half-space $\\mathbf{n}\\cdot\\mathbf{x} \\le \\alpha$, corresponds exactly to a given Volume-of-Fluid (VOF) fraction $F$.\n\nThe governing relationship between the VOF fraction $F$, the cell geometry, the interface normal $\\mathbf{n}$, and the plane constant $\\alpha$ is given by the integral of the indicator function for the liquid phase over the cell domain $\\mathcal{C}$:\n$$\nF = \\frac{1}{L^2} \\iint_{\\mathcal{C}} H(\\alpha - \\mathbf{n}\\cdot\\mathbf{x}) \\, dA\n$$\nHere, $\\mathcal{C}$ is the square cell $[x_0, x_0+L] \\times [y_0, y_0+L]$ with area $L^2$, $\\mathbf{n}$ is the interface normal vector, and $H(\\cdot)$ is the Heaviside step function. The integral computes the area of the liquid region, $A(\\alpha) = \\text{Area}(\\{ \\mathbf{x} \\in \\mathcal{C} \\mid \\mathbf{n}\\cdot\\mathbf{x} \\le \\alpha \\})$, which is then normalized by the total cell area $L^2$.\n\nThe problem is to find $\\alpha$ given $(x_0, y_0, L, n_x, n_y, F)$. This can be reformulated as a root-finding problem for the function:\n$$\ng(\\alpha) = A(\\alpha) - F L^2 = 0\n$$\n\nThe solution methodology proceeds as follows:\n\n1.  **Preprocessing**: As stipulated, the given normal vector $\\mathbf{n}=(n_x, n_y)$ is first normalized to obtain a unit normal vector $\\hat{\\mathbf{n}}$:\n    $$\n    \\hat{\\mathbf{n}} = \\frac{\\mathbf{n}}{\\|\\mathbf{n}\\|} = \\frac{(n_x, n_y)}{\\sqrt{n_x^2 + n_y^2}}\n    $$\n    All subsequent calculations involving the normal will use this unit vector $\\hat{\\mathbf{n}}$.\n\n2.  **Bracketing the Solution**: The function $\\hat{\\mathbf{n}}\\cdot\\mathbf{x}$ is a linear function of $\\mathbf{x}=(x,y)$, so its extrema over the convex domain $\\mathcal{C}$ must occur at the cell's vertices. Let the four vertices of the cell be $P_1, P_2, P_3, P_4$. We can define the bounds for $\\alpha$:\n    $$\n    \\alpha_{min} = \\min_{i=1,2,3,4} (\\hat{\\mathbf{n}} \\cdot P_i)\n    $$\n    $$\n    \\alpha_{max} = \\max_{i=1,2,3,4} (\\hat{\\mathbf{n}} \\cdot P_i)\n    $$\n    If $\\alpha  \\alpha_{min}$, the separating line $\\hat{\\mathbf{n}}\\cdot\\mathbf{x} = \\alpha$ does not intersect the cell, and the liquid area $A(\\alpha)$ is $0$. If $\\alpha \\ge \\alpha_{max}$, the entire cell is submerged in the liquid region, so $A(\\alpha) = L^2$. Consequently, the solution $\\alpha$ must lie in the interval $[\\alpha_{min}, \\alpha_{max}]$.\n\n3.  **Boundary Cases**: The problem specifies the handling of boundary VOF fractions:\n    - If $F=0$, the liquid area is zero. This corresponds to the lower bound of the interval, so we set $\\alpha = \\alpha_{min}$.\n    - If $F=1$, the entire cell is liquid. This corresponds to the upper bound, so we set $\\alpha = \\alpha_{max}$.\n\n4.  **Root-Finding for $F \\in (0,1)$**: For intermediate VOF fractions, we must solve $g(\\alpha)=0$. The liquid area function $A(\\alpha)$ is monotonically non-decreasing with respect to $\\alpha$. This ensures that $g(\\alpha)$ is also monotonic, guaranteeing a unique root within the interval $[\\alpha_{min}, \\alpha_{max}]$. A bracketing method is therefore appropriate. We will use the bisection method due to its simplicity and robustness.\n    The bisection algorithm is initialized with the interval $[\\alpha_{low}, \\alpha_{high}] = [\\alpha_{min}, \\alpha_{max}]$. In each iteration, a midpoint $\\alpha_{mid} = (\\alpha_{low} + \\alpha_{high}) / 2$ is chosen. The area $A(\\alpha_{mid})$ is computed.\n    - If $A(\\alpha_{mid})  F L^2$, the trial area is too small, implying $\\alpha_{mid}$ is too small. The lower bound is updated: $\\alpha_{low} = \\alpha_{mid}$.\n    - Otherwise, the trial area is too large or correct, so $\\alpha_{mid}$ is a potential or too-large value. The upper bound is updated: $\\alpha_{high} = \\alpha_{mid}$.\n    This process is repeated for a fixed number of iterations sufficient to achieve high precision.\n\n5.  **Geometric Area Calculation**: The core of the problem is the computation of $A(\\alpha)$ for a given trial $\\alpha$, which must be done by geometric clipping without recourse to pre-derived analytical formulas. This involves two steps:\n    a. **Polygon Clipping**: The liquid area is the area of the polygon formed by intersecting the square cell $\\mathcal{C}$ with the half-plane $\\hat{\\mathbf{n}}\\cdot\\mathbf{x} \\le \\alpha$. We use the Sutherland-Hodgman algorithm for this clipping procedure. The square cell, represented by its four vertices in order, is the \"subject polygon\". The half-plane defines the clipping boundary. The algorithm processes each edge of the subject polygon, generating a new list of vertices that form the clipped polygon. For an edge with endpoints $S$ and $E$, the algorithm outputs vertices based on whether $S$ and $E$ are inside the half-plane (i.e., satisfy $\\hat{\\mathbf{n}}\\cdot\\mathbf{x} - \\alpha \\le 0$). Where an edge crosses the boundary line $\\hat{\\mathbf{n}}\\cdot\\mathbf{x} = \\alpha$, the intersection point $I$ is computed and added to the new vertex list. The intersection of a line segment between $S$ and $E$ and the line is found by parameterizing the segment as $P(t) = S+t(E-S)$ for $t\\in[0,1]$ and solving for $t$:\n    $$\n    t = \\frac{\\alpha - \\hat{\\mathbf{n}} \\cdot S}{\\hat{\\mathbf{n}} \\cdot (E - S)}\n    $$\n    b. **Polygon Area**: Once the vertices of the clipped polygon are determined, its area is calculated using the Shoelace formula. For a polygon with $k$ vertices $(x_1, y_1), (x_2, y_2), \\dots, (x_k, y_k)$ ordered sequentially, the area is:\n    $$\n    A = \\frac{1}{2} \\left| \\sum_{i=1}^{k} (x_i y_{i+1} - x_{i+1} y_i) \\right|\n    $$\n    where $(x_{k+1}, y_{k+1})$ is taken to be $(x_1, y_1)$.\n\n    By integrating these components, we construct a robust procedure to find $\\alpha$ for any valid set of inputs. The final program implements this logic for each provided test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    # Test cases: (x0, y0, L, nx, ny, F)\n    test_cases = [\n        (0.0, 0.0, 1.0, 1.0, 1.0, 0.5),\n        (0.0, 0.0, 1.0, 0.3, 0.95, 0.0),\n        (0.0, 0.0, 1.0, 0.3, 0.95, 1.0),\n        (1.0, 2.0, 2.0, -1.0, 2.0, 0.25),\n        (0.0, 0.0, 1.0, 1e-6, 1.0, 0.3),\n        (5.0, -3.0, 1.0, 1.0, 1.0, 0.5),\n        (0.0, 0.0, 1.0, -1.0, -1.0, 0.75),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha = reconstruct_alpha(*case)\n        results.append(f\"{alpha:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef polygon_area(vertices):\n    \"\"\"\n    Calculates the area of a polygon using the Shoelace formula.\n    Assumes vertices are ordered (e.g., counter-clockwise).\n    \"\"\"\n    if len(vertices)  3:\n        return 0.0\n    \n    verts_array = np.array(vertices)\n    x = verts_array[:, 0]\n    y = verts_array[:, 1]\n    \n    # Use np.roll to cycle the arrays for the shoelace formula\n    area = 0.5 * np.abs(np.dot(x, np.roll(y, -1)) - np.dot(y, np.roll(x, -1)))\n    return area\n\ndef clip_polygon(subject_polygon, n_unit, alpha):\n    \"\"\"\n    Clips a convex polygon against the half-plane n_unit . x - alpha = 0.\n    Implementation of the Sutherland-Hodgman algorithm for a single clipping plane.\n    \"\"\"\n    clipped_vertices = []\n    num_vertices = len(subject_polygon)\n\n    for i in range(num_vertices):\n        start_point = subject_polygon[i]\n        end_point = subject_polygon[(i + 1) % num_vertices]\n\n        # Evaluate the half-plane condition g(x) = n . x - alpha\n        g_start = np.dot(n_unit, start_point) - alpha\n        g_end = np.dot(n_unit, end_point) - alpha\n        \n        is_start_inside = g_start = 0\n        is_end_inside = g_end = 0\n\n        # Case 1: Both vertices are inside\n        if is_start_inside and is_end_inside:\n            clipped_vertices.append(end_point)\n        # Case 2: Start is inside, End is outside\n        elif is_start_inside and not is_end_inside:\n            # Calculate intersection\n            # Denominator should not be zero unless edge is parallel to the line\n            denominator = np.dot(n_unit, end_point - start_point)\n            if abs(denominator) > 1e-15:\n                t = (alpha - np.dot(n_unit, start_point)) / denominator\n                intersection = start_point + t * (end_point - start_point)\n                clipped_vertices.append(intersection)\n        # Case 3: Both vertices are outside - do nothing\n        elif not is_start_inside and not is_end_inside:\n            pass\n        # Case 4: Start is outside, End is inside\n        elif not is_start_inside and is_end_inside:\n            # Calculate intersection\n            denominator = np.dot(n_unit, end_point - start_point)\n            if abs(denominator) > 1e-15:\n                t = (alpha - np.dot(n_unit, start_point)) / denominator\n                intersection = start_point + t * (end_point - start_point)\n                clipped_vertices.append(intersection)\n            clipped_vertices.append(end_point)\n    \n    return clipped_vertices\n\ndef reconstruct_alpha(x0, y0, L, nx, ny, F):\n    \"\"\"\n    Computes the plane constant alpha for a single test case.\n    \"\"\"\n    n_vec = np.array([nx, ny])\n    norm_n = np.linalg.norm(n_vec)\n    \n    # Per problem, n is non-zero so norm_n > 0\n    n_unit = n_vec / norm_n\n\n    # Define cell vertices\n    corners = [\n        np.array([x0, y0]),\n        np.array([x0 + L, y0]),\n        np.array([x0 + L, y0 + L]),\n        np.array([x0, y0 + L]),\n    ]\n\n    # Find bracketing values for alpha\n    dot_products = [np.dot(n_unit, p) for p in corners]\n    alpha_min = min(dot_products)\n    alpha_max = max(dot_products)\n\n    # Handle boundary cases F=0 and F=1\n    if F = 1e-9: # Use a tolerance for floating point comparison\n        return alpha_min\n    if F >= 1.0 - 1e-9:\n        return alpha_max\n\n    target_area = F * L**2\n\n    # Bisection method to find alpha\n    alpha_low = alpha_min\n    alpha_high = alpha_max\n    \n    # 100 iterations are more than sufficient for double precision\n    for _ in range(100):\n        alpha_mid = (alpha_low + alpha_high) / 2.0\n        \n        # Calculate area for the current alpha_mid\n        clipped_poly = clip_polygon(corners, n_unit, alpha_mid)\n        current_area = polygon_area(clipped_poly)\n        \n        if current_area  target_area:\n            alpha_low = alpha_mid\n        else:\n            alpha_high = alpha_mid\n            \n    return (alpha_low + alpha_high) / 2.0\n\nsolve()\n```"
        },
        {
            "introduction": "In methods that use a level-set function $\\phi$ to define the interface, it is common practice to define material properties like density or thermal conductivity using a continuous profile that varies smoothly across a narrow band around the interface. While this \"diffuse interface\" approach avoids numerical difficulties associated with sharp discontinuities, it introduces a modeling error. This practice provides a clear, quantitative look at this trade-off by analyzing a simple 1D steady heat conduction problem . By computing the error in both the material property representation and the resulting physical heat flux, you will develop a deeper understanding of how the numerical smoothing parameter $\\epsilon$ impacts the physical accuracy of a simulation.",
            "id": "3968048",
            "problem": "A one-dimensional, steady heat conduction problem is considered to assess the consequences of using a smoothed Heaviside function in a level-set formulation for mixture property evaluation, as is common in Coupled Level-Set Volume-of-Fluid (CLSVOF) methods. Let the domain be the interval $[0,L]$ with unit cross-sectional area, and let an interface separating two materials be located at $x=x_0$. The level-set function is $ \\phi(x) = x - x_0 $. The mixture rule for thermal conductivity uses a smoothed Heaviside function $ H_{\\epsilon}(\\phi) $ with smoothing half-width $ \\epsilon  0 $:\n$$\nk(\\phi) = k_1 + (k_2 - k_1)\\, H_{\\epsilon}(\\phi),\n$$\nwhere $ k_1 $ and $ k_2 $ are the constant thermal conductivities of material $1$ and material $2$, respectively, in units of $\\mathrm{W/(m\\,K)}$. The exact sharp-interface conductivity is\n$$\nk_{\\mathrm{exact}}(x) =\n\\begin{cases}\nk_1,  x  x_0, \\\\\nk_2,  x  x_0.\n\\end{cases}\n$$\nUse the following standard smoothed Heaviside function:\n$$\nH_{\\epsilon}(\\phi) =\n\\begin{cases}\n0,  \\phi  -\\epsilon, \\\\\n\\dfrac{1}{2}\\left[1 + \\dfrac{\\phi}{\\epsilon} + \\dfrac{1}{\\pi}\\sin\\!\\left(\\pi \\dfrac{\\phi}{\\epsilon}\\right)\\right],  |\\phi| \\le \\epsilon, \\\\\n1,  \\phi  \\epsilon.\n\\end{cases}\n$$\n\nUnder steady conditions, Fourierâ€™s law $ q(x) = -k(x)\\, \\dfrac{dT}{dx} $ applies and the governing equation $ \\dfrac{d}{dx}\\!\\left(k(x)\\, \\dfrac{dT}{dx}\\right) = 0 $ implies a constant heat flux $ q $ throughout the domain. With boundary temperatures $ T(0) = T_{\\mathrm{hot}} $ and $ T(L) = T_{\\mathrm{cold}} $ (in $\\mathrm{K}$), the flux for any spatially varying conductivity $ k(x) $ is\n$$\nq = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\displaystyle \\int_{0}^{L} \\dfrac{dx}{k(x)}} \\quad \\text{in} \\quad \\mathrm{W/m^2}.\n$$\n\nYour task is to compute two error metrics that quantify the impact of finite $ \\epsilon $:\n1. The mean absolute property error\n$$\nE_{\\mathrm{prop}} = \\dfrac{1}{L} \\int_{0}^{L} \\left| k(\\phi(x)) - k_{\\mathrm{exact}}(x) \\right|\\, dx \\quad \\text{in} \\quad \\mathrm{W/(m\\,K)}.\n$$\n2. The relative flux error (expressed as a decimal, not a percentage),\n$$\nE_{\\mathrm{flux}} = \\dfrac{q_{\\mathrm{smooth}} - q_{\\mathrm{exact}}}{\\left| q_{\\mathrm{exact}} \\right|},\n$$\nwhere\n$$\nq_{\\mathrm{exact}} = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\dfrac{x_0}{k_1} + \\dfrac{L - x_0}{k_2}}, \\quad\nq_{\\mathrm{smooth}} = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\displaystyle \\int_{0}^{L} \\dfrac{dx}{k(\\phi(x))}}.\n$$\n\nTo ensure scientific realism, all parameters must be used with their physical units as indicated. Angles in trigonometric functions are in radians.\n\nImplement a program that, for each of the following test cases, computes $ E_{\\mathrm{prop}} $ (in $\\mathrm{W/(m\\,K)}$) and $ E_{\\mathrm{flux}} $ (decimal):\n\n- Test case $1$ (happy path, moderate contrast): $ L = 1.0\\,\\mathrm{m} $, $ x_0 = 0.5\\,\\mathrm{m} $, $ k_1 = 0.6\\,\\mathrm{W/(m\\,K)} $, $ k_2 = 15.0\\,\\mathrm{W/(m\\,K)} $, $ \\epsilon = 0.01\\,\\mathrm{m} $, $ T_{\\mathrm{hot}} = 400\\,\\mathrm{K} $, $ T_{\\mathrm{cold}} = 300\\,\\mathrm{K} $.\n- Test case $2$ (strong contrast, small $ \\epsilon $): $ L = 1.0\\,\\mathrm{m} $, $ x_0 = 0.5\\,\\mathrm{m} $, $ k_1 = 0.1\\,\\mathrm{W/(m\\,K)} $, $ k_2 = 100.0\\,\\mathrm{W/(m\\,K)} $, $ \\epsilon = 0.001\\,\\mathrm{m} $, $ T_{\\mathrm{hot}} = 400\\,\\mathrm{K} $, $ T_{\\mathrm{cold}} = 300\\,\\mathrm{K} $.\n- Test case $3$ (degenerate contrast, zero jump): $ L = 1.0\\,\\mathrm{m} $, $ x_0 = 0.5\\,\\mathrm{m} $, $ k_1 = 1.0\\,\\mathrm{W/(m\\,K)} $, $ k_2 = 1.0\\,\\mathrm{W/(m\\,K)} $, $ \\epsilon = 0.2\\,\\mathrm{m} $, $ T_{\\mathrm{hot}} = 350\\,\\mathrm{K} $, $ T_{\\mathrm{cold}} = 300\\,\\mathrm{K} $.\n- Test case $4$ (large $ \\epsilon $, large contrast): $ L = 1.0\\,\\mathrm{m} $, $ x_0 = 0.5\\,\\mathrm{m} $, $ k_1 = 0.2\\,\\mathrm{W/(m\\,K)} $, $ k_2 = 20.0\\,\\mathrm{W/(m\\,K)} $, $ \\epsilon = 0.3\\,\\mathrm{m} $, $ T_{\\mathrm{hot}} = 500\\,\\mathrm{K} $, $ T_{\\mathrm{cold}} = 300\\,\\mathrm{K} $.\n- Test case $5$ (interface near boundary, reversed contrast): $ L = 1.0\\,\\mathrm{m} $, $ x_0 = 0.1\\,\\mathrm{m} $, $ k_1 = 10.0\\,\\mathrm{W/(m\\,K)} $, $ k_2 = 0.5\\,\\mathrm{W/(m\\,K)} $, $ \\epsilon = 0.05\\,\\mathrm{m} $, $ T_{\\mathrm{hot}} = 310\\,\\mathrm{K} $, $ T_{\\mathrm{cold}} = 300\\,\\mathrm{K} $.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Report the values sequentially by test case, with each test case contributing two numbers $[E_{\\mathrm{prop}}, E_{\\mathrm{flux}}]$. Thus, the final output format must be\n$$\n[ E_{\\mathrm{prop,1}}, E_{\\mathrm{flux,1}}, E_{\\mathrm{prop,2}}, E_{\\mathrm{flux,2}}, E_{\\mathrm{prop,3}}, E_{\\mathrm{flux,3}}, E_{\\mathrm{prop,4}}, E_{\\mathrm{flux,4}}, E_{\\mathrm{prop,5}}, E_{\\mathrm{flux,5}} ].\n$$\nAll outputs for $ E_{\\mathrm{prop}} $ must be in $\\mathrm{W/(m\\,K)}$, and all outputs for $ E_{\\mathrm{flux}} $ must be decimals (dimensionless).",
            "solution": "The user-provided problem has been analyzed and validated against the specified criteria.\n\n### Step 1: Extract Givens\n- **Domain and Physics**: One-dimensional, steady heat conduction in the domain $[0,L]$ with unit cross-sectional area.\n- **Interface Location**: $x=x_0$.\n- **Level-Set Function**: $\\phi(x) = x - x_0$.\n- **Smoothed Thermal Conductivity**: $k(\\phi) = k_1 + (k_2 - k_1)\\, H_{\\epsilon}(\\phi)$, where $k_1$ and $k_2$ are constant conductivities and $\\epsilon  0$ is the smoothing half-width.\n- **Smoothed Heaviside Function**:\n$$\nH_{\\epsilon}(\\phi) =\n\\begin{cases}\n0,  \\phi  -\\epsilon, \\\\\n\\dfrac{1}{2}\\left[1 + \\dfrac{\\phi}{\\epsilon} + \\dfrac{1}{\\pi}\\sin\\!\\left(\\pi \\dfrac{\\phi}{\\epsilon}\\right)\\right],  |\\phi| \\le \\epsilon, \\\\\n1,  \\phi  \\epsilon.\n\\end{cases}\n$$\n- **Exact (Sharp) Thermal Conductivity**:\n$$\nk_{\\mathrm{exact}}(x) =\n\\begin{cases}\nk_1,  x  x_0, \\\\\nk_2,  x  x_0.\n\\end{cases}\n$$\n- ** Governing Equation and Heat Flux**: The governing equation $\\dfrac{d}{dx}\\!\\left(k(x)\\, \\dfrac{dT}{dx}\\right) = 0$ implies constant heat flux $q$. With boundary temperatures $T(0) = T_{\\mathrm{hot}}$ and $T(L) = T_{\\mathrm{cold}}$, the flux is given by $q = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\int_{0}^{L} \\frac{dx}{k(x)}}$.\n- **Error Metrics to Compute**:\n  1. Mean absolute property error: $E_{\\mathrm{prop}} = \\dfrac{1}{L} \\int_{0}^{L} \\left| k(\\phi(x)) - k_{\\mathrm{exact}}(x) \\right|\\, dx$.\n  2. Relative flux error: $E_{\\mathrm{flux}} = \\dfrac{q_{\\mathrm{smooth}} - q_{\\mathrm{exact}}}{\\left| q_{\\mathrm{exact}} \\right|}$, where $q_{\\mathrm{exact}}$ and $q_{\\mathrm{smooth}}$ are fluxes computed with $k_{\\mathrm{exact}}(x)$ and $k(\\phi(x))$, respectively.\n- **Flux Formulas**:\n$$\nq_{\\mathrm{exact}} = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\dfrac{x_0}{k_1} + \\dfrac{L - x_0}{k_2}}, \\quad\nq_{\\mathrm{smooth}} = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\displaystyle \\int_{0}^{L} \\dfrac{dx}{k(\\phi(x))}}.\n$$\n- **Test Cases**: Five sets of parameters ($L, x_0, k_1, k_2, \\epsilon, T_{\\mathrm{hot}}, T_{\\mathrm{cold}}$) are provided.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the established principles of heat transfer (Fourier's law of heat conduction) and standard numerical techniques for multiphase flows (level-set methods, diffuse interface modeling). The formulation is objective, mathematically precise, and internally consistent. All parameters, constants, and boundary conditions required for a solution are provided. The functions are well-defined and the integrals are convergent for positive conductivities. A unique, stable solution exists for each test case. An inspection of the parameters for all test cases confirms that the smoothing region $[x_0 - \\epsilon, x_0 + \\epsilon]$ is always fully contained within the domain $[0,L]$, avoiding boundary complications. The problem is a valid, well-posed scientific exercise in computational thermal engineering.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A step-by-step solution will be developed.\n\nThe solution requires the calculation of two quantities, $E_{\\mathrm{prop}}$ and $E_{\\mathrm{flux}}$, for each test case. The derivation for each is presented below.\n\n**Calculation of Mean Absolute Property Error ($E_{\\mathrm{prop}}$)**\n\nThe definition is $E_{\\mathrm{prop}} = \\dfrac{1}{L} \\int_{0}^{L} \\left| k(\\phi(x)) - k_{\\mathrm{exact}}(x) \\right|\\, dx$.\nThe integrand is non-zero only where the smoothed conductivity $k(\\phi(x))$ differs from the exact sharp-interface conductivity $k_{\\mathrm{exact}}(x)$. By definition of $H_{\\epsilon}(\\phi)$, this occurs exclusively within the smoothing band where $|\\phi(x)| \\le \\epsilon$, which corresponds to the spatial interval $[x_0 - \\epsilon, x_0 + \\epsilon]$.\nTherefore, the integral reduces to:\n$$\nL \\cdot E_{\\mathrm{prop}} = \\int_{x_0 - \\epsilon}^{x_0 + \\epsilon} \\left| k(\\phi(x)) - k_{\\mathrm{exact}}(x) \\right|\\, dx\n$$\nThis integral is split at the interface location $x=x_0$:\n$$\nL \\cdot E_{\\mathrm{prop}} = \\int_{x_0 - \\epsilon}^{x_0} |k(\\phi(x)) - k_1|\\,dx + \\int_{x_0}^{x_0 + \\epsilon} |k(\\phi(x)) - k_2|\\,dx\n$$\nSubstituting $k(\\phi(x)) = k_1 + (k_2 - k_1)H_{\\epsilon}(\\phi(x))$:\n$$\nL \\cdot E_{\\mathrm{prop}} = \\int_{x_0 - \\epsilon}^{x_0} |(k_2 - k_1)H_{\\epsilon}(\\phi(x))|\\,dx + \\int_{x_0}^{x_0 + \\epsilon} |k_1 - k_2 + (k_2 - k_1)H_{\\epsilon}(\\phi(x))|\\,dx\n$$\nSince $H_{\\epsilon} \\ge 0$, and for $H_{\\epsilon}$'s argument range, $0 \\le H_{\\epsilon} \\le 1$, this simplifies to:\n$$\nL \\cdot E_{\\mathrm{prop}} = |k_2 - k_1| \\left( \\int_{x_0 - \\epsilon}^{x_0} H_{\\epsilon}(\\phi(x))\\,dx + \\int_{x_0}^{x_0 + \\epsilon} (1 - H_{\\epsilon}(\\phi(x)))\\,dx \\right)\n$$\nWe perform a change of variables $u = \\phi(x) = x - x_0$, so $du = dx$. The integration limits become $[-\\epsilon, 0]$ and $[0, \\epsilon]$ respectively.\n$$\nL \\cdot E_{\\mathrm{prop}} = |k_2 - k_1| \\left( \\int_{-\\epsilon}^{0} H_{\\epsilon}(u)\\,du + \\int_{0}^{\\epsilon} (1 - H_{\\epsilon}(u))\\,du \\right)\n$$\nThe function $H_{\\epsilon}(u)$ has the property that $H_{\\epsilon}(u) + H_{\\epsilon}(-u) = 1$ for $|u| \\le \\epsilon$. Thus, $1 - H_{\\epsilon}(u) = H_{\\epsilon}(-u)$. The second integral becomes $\\int_{0}^{\\epsilon} H_{\\epsilon}(-u)\\,du$. With a substitution $v = -u$, this becomes $\\int_{0}^{-\\epsilon} H_{\\epsilon}(v)(-dv) = \\int_{-\\epsilon}^{0} H_{\\epsilon}(v)\\,dv$, proving the two integrals are identical. We need only evaluate one of them.\n$$\n\\int_{-\\epsilon}^{0} H_{\\epsilon}(u)\\,du = \\int_{-\\epsilon}^{0} \\dfrac{1}{2}\\left[1 + \\dfrac{u}{\\epsilon} + \\dfrac{1}{\\pi}\\sin\\!\\left(\\pi \\dfrac{u}{\\epsilon}\\right)\\right]\\,du\n$$\nThe antiderivative is $\\frac{1}{2} \\left[u + \\frac{u^2}{2\\epsilon} - \\frac{\\epsilon}{\\pi^2}\\cos\\left(\\pi \\frac{u}{\\epsilon}\\right)\\right]$. Evaluating from $-\\epsilon$ to $0$:\n$$\n= \\frac{1}{2} \\left[ \\left(0 + 0 - \\frac{\\epsilon}{\\pi^2}\\cos(0)\\right) - \\left(-\\epsilon + \\frac{(-\\epsilon)^2}{2\\epsilon} - \\frac{\\epsilon}{\\pi^2}\\cos(-\\pi)\\right) \\right]\n= \\frac{1}{2} \\left[ -\\frac{\\epsilon}{\\pi^2} - \\left(-\\epsilon + \\frac{\\epsilon}{2} + \\frac{\\epsilon}{\\pi^2}\\right) \\right]\n= \\frac{1}{2} \\left[ \\frac{\\epsilon}{2} - \\frac{2\\epsilon}{\\pi^2} \\right] = \\epsilon\\left(\\frac{1}{4} - \\frac{1}{\\pi^2}\\right)\n$$\nThe total integral is twice this value:\n$$\nL \\cdot E_{\\mathrm{prop}} = |k_2 - k_1| \\cdot 2 \\epsilon\\left(\\frac{1}{4} - \\frac{1}{\\pi^2}\\right) = |k_2 - k_1| \\epsilon\\left(\\frac{1}{2} - \\frac{2}{\\pi^2}\\right)\n$$\nFinally, the mean absolute property error has the analytical solution:\n$$\nE_{\\mathrm{prop}} = \\frac{|k_2 - k_1|\\epsilon}{L} \\left(\\frac{1}{2} - \\frac{2}{\\pi^2}\\right)\n$$\n\n**Calculation of Relative Flux Error ($E_{\\mathrm{flux}}$)**\n\nThe relative flux error is $E_{\\mathrm{flux}} = (q_{\\mathrm{smooth}} - q_{\\mathrm{exact}}) / |q_{\\mathrm{exact}}|$. The calculation of $q_{\\mathrm{exact}}$ is straightforward from the provided formula. The calculation of $q_{\\mathrm{smooth}}$ requires evaluating the total thermal resistance with the smoothed conductivity profile:\n$$\nR_{\\mathrm{smooth}} = \\int_{0}^{L} \\dfrac{dx}{k(\\phi(x))}\n$$\nThe integral is decomposed into three parts based on the definition of $H_{\\epsilon}(\\phi)$:\n$$\nR_{\\mathrm{smooth}} = \\int_{0}^{x_0 - \\epsilon} \\frac{dx}{k_1} + \\int_{x_0 - \\epsilon}^{x_0 + \\epsilon} \\frac{dx}{k_1 + (k_2 - k_1)H_{\\epsilon}(x-x_0)} + \\int_{x_0 + \\epsilon}^{L} \\frac{dx}{k_2}\n$$\nThe first and third integrals are trivial, representing the thermal resistance of the pure material regions:\n$$\nR_1 = \\frac{x_0 - \\epsilon}{k_1} \\quad \\text{and} \\quad R_2 = \\frac{L - (x_0 + \\epsilon)}{k_2}\n$$\nThe middle integral, over the diffuse interface region, does not possess a simple closed-form analytical solution due to the complexity of the integrand's denominator.\n$$\nR_{\\mathrm{mid}} = \\int_{x_0 - \\epsilon}^{x_0 + \\epsilon} \\frac{dx}{k_1 + (k_2 - k_1) \\frac{1}{2}\\left[1 + \\frac{x-x_0}{\\epsilon} + \\frac{1}{\\pi}\\sin\\!\\left(\\pi \\frac{x-x_0}{\\epsilon}\\right)\\right]}\n$$\nThis integral must be computed using numerical quadrature. By changing variables to $u=x-x_0$, the integral simplifies to a form suitable for standard numerical integrators:\n$$\nR_{\\mathrm{mid}} = \\int_{-\\epsilon}^{\\epsilon} \\frac{du}{k_1 + (k_2 - k_1) H_{\\epsilon}(u)}\n$$\nThe total smoothed resistance is $R_{\\mathrm{smooth}} = R_1 + R_{\\mathrm{mid}} + R_2$. The smoothed flux is $q_{\\mathrm{smooth}} = (T_{\\mathrm{hot}} - T_{\\mathrm{cold}}) / R_{\\mathrm{smooth}}$. The relative flux error $E_{\\mathrm{flux}}$ is then computed from these quantities.\n\nFor the special case where $k_1 = k_2$, we observe that $k(\\phi(x)) = k_1 + (k_1-k_1)H_{\\epsilon}(\\phi(x)) = k_1$. The smoothed conductivity is identical to the exact conductivity, $k_1$. Consequently, $E_{\\mathrm{prop}} = 0$ and $q_{\\mathrm{smooth}}=q_{\\mathrm{exact}}$, which means $E_{\\mathrm{flux}} = 0$. This provides a consistency check for the implementation (Test Case 3).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes property and flux errors for a 1D steady heat conduction problem\n    with a smoothed interface, as specified in the problem statement.\n    \"\"\"\n    # Define the test cases from the problem statement:\n    # (L, x0, k1, k2, eps, Thot, Tcold)\n    test_cases = [\n        (1.0, 0.5, 0.6, 15.0, 0.01, 400.0, 300.0),\n        (1.0, 0.5, 0.1, 100.0, 0.001, 400.0, 300.0),\n        (1.0, 0.5, 1.0, 1.0, 0.2, 350.0, 300.0),\n        (1.0, 0.5, 0.2, 20.0, 0.3, 500.0, 300.0),\n        (1.0, 0.1, 10.0, 0.5, 0.05, 310.0, 300.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L, x0, k1, k2, eps, Thot, Tcold = case\n        \n        # --- Task 1: Compute Mean Absolute Property Error (E_prop) ---\n        # The analytical formula derived in the solution is used:\n        # E_prop = (|k2 - k1| * eps / L) * (1/2 - 2 / pi^2)\n        E_prop_factor = 0.5 - 2 / (np.pi**2)\n        E_prop = (np.abs(k2 - k1) * eps / L) * E_prop_factor\n        \n        # --- Task 2: Compute Relative Flux Error (E_flux) ---\n        \n        # Handle the degenerate case where k1 and k2 are identical.\n        # In this case, k_smooth = k_exact = k1, so both errors are zero.\n        if np.isclose(k1, k2):\n            E_flux = 0.0\n            results.extend([E_prop, E_flux])\n            continue\n        \n        # Handle the degenerate case of zero temperature difference.\n        if np.isclose(Thot, Tcold):\n            # Both q_exact and q_smooth are zero, so the error is zero.\n            E_flux = 0.0\n            results.extend([E_prop, E_flux])\n            continue\n\n        # Calculate q_exact using the sharp-interface thermal resistance.\n        R_exact = x0 / k1 + (L - x0) / k2\n        q_exact = (Thot - Tcold) / R_exact\n        \n        # Calculate q_smooth using numerical integration for the smoothed resistance.\n        \n        # Define the smoothed Heaviside function for the region |phi| = epsilon.\n        def H_eps_func(phi, epsilon):\n            phi_scaled = phi / epsilon\n            return 0.5 * (1.0 + phi_scaled + (1.0 / np.pi) * np.sin(np.pi * phi_scaled))\n            \n        # Define the integrand for the thermal resistance in the smoothed region.\n        # This is the reciprocal of the smoothed conductivity k(phi).\n        def resistance_integrand(phi, epsilon, k1, k2):\n            k_smooth = k1 + (k2 - k1) * H_eps_func(phi, epsilon)\n            return 1.0 / k_smooth\n            \n        # Numerically integrate to find the resistance of the smoothed region.\n        # The integration is over u = x - x0 from -eps to eps.\n        R_mid, _ = quad(resistance_integrand, -eps, eps, args=(eps, k1, k2))\n        \n        # Calculate the total thermal resistance for the smoothed case.\n        # It's the sum of resistances from the two pure-material regions and the\n        # numerically computed resistance of the smoothed interface region.\n        # The problem setup ensures x0-eps > 0 and x0+eps  L.\n        R_smooth_pure1 = (x0 - eps) / k1\n        R_smooth_pure2 = (L - (x0 + eps)) / k2\n        R_smooth = R_smooth_pure1 + R_mid + R_smooth_pure2\n        \n        q_smooth = (Thot - Tcold) / R_smooth\n        \n        # Calculate the final relative flux error.\n        E_flux = (q_smooth - q_exact) / np.abs(q_exact)\n        \n        results.extend([E_prop, E_flux])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12g}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Modeling surface tension accurately is a central challenge in multiphase flow simulation, and numerical errors can lead to unphysical \"parasitic velocities\" even in an otherwise stationary fluid. These spurious currents arise from a discrete imbalance between the capillary force and the pressure gradient that should perfectly balance it at equilibrium. This advanced practice invites you to diagnose this critical issue by implementing a balanced-force discretization for a static circular droplet and measuring the magnitude of parasitic velocities as the grid is refined . This exercise offers direct insight into the numerical stability and accuracy of the Continuum Surface Force (CSF) model, a widely used technique in level-set and VOF frameworks.",
            "id": "3968030",
            "problem": "A stationary, circular droplet is embedded in a quiescent, incompressible, two-phase fluid within a square domain. The interface is evolved by a Coupled Level-Set and Volume-of-Fluid method (CLSVOF) in the sense that curvature is computed from the level-set representation while the color function used in the Continuum Surface Force (CSF) is built from a smoothed volume fraction obtained via a regularized Heaviside of the level set. The goal is to assess parasitic velocities arising from discrete imbalance of capillary and pressure forces under nominally balanced-force discretization by refining the grid.\n\nStart from the incompressible two-phase momentum balance with the Continuum Surface Force model:\n$$\n\\rho \\frac{\\partial \\boldsymbol{u}}{\\partial t} = -\\nabla p + \\mu \\nabla^2 \\boldsymbol{u} + \\sigma \\kappa \\delta(\\phi) \\boldsymbol{n},\n$$\nwhere $\\rho$ is density, $\\boldsymbol{u}$ is velocity, $p$ is pressure, $\\mu$ is viscosity, $\\sigma$ is surface tension coefficient, $\\kappa$ is mean curvature, $\\delta(\\phi)$ is a regularized Dirac distribution concentrated at the interface represented by a level-set function $\\phi$, and $\\boldsymbol{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$ is the unit normal.\n\nFor a stationary droplet at mechanical equilibrium, the continuous balanced-force condition implies that $-\\nabla p + \\sigma \\kappa \\delta(\\phi) \\boldsymbol{n} = \\boldsymbol{0}$. Under Coupled Level-Set Volume-of-Fluid (CLSVOF), the CSF term is implemented as $\\sigma \\kappa \\nabla F$, where $F$ is a smoothed volume fraction (color function) derived from the level set via a regularized Heaviside function. Using a balanced-force discretization, it is natural to choose $p = \\sigma \\kappa F$, which ideally cancels the capillary term for constant curvature and exact derivatives. In practice, discrete approximations induce a residual, which generates parasitic velocities.\n\nImplement the following in a two-dimensional square domain of side length $L$:\n- Use a uniform Cartesian grid with $N \\times N$ cells of size $\\Delta x = \\Delta y = L/N$.\n- Center a circular droplet of radius $R$ at the domain center $(L/2, L/2)$.\n- Define the level-set field as the signed distance to the circle:\n$$\n\\phi(x,y) = \\sqrt{(x - L/2)^2 + (y - L/2)^2} - R,\n$$\nwith negative values inside the droplet.\n- Define the regularized Heaviside function with smoothing half-width $\\varepsilon$,\n$$\nH_\\varepsilon(\\phi) =\n\\begin{cases}\n0,  \\phi \\le -\\varepsilon, \\\\\n1,  \\phi \\ge \\varepsilon, \\\\\n\\frac{1}{2}\\left(1 + \\frac{\\phi}{\\varepsilon} + \\frac{1}{\\pi}\\sin\\left(\\pi \\frac{\\phi}{\\varepsilon}\\right)\\right),  \\text{otherwise},\n\\end{cases}\n$$\nand set the color function $F = H_\\varepsilon(\\phi)$.\n- Compute curvature from the level set via $\\kappa = \\nabla \\cdot \\boldsymbol{n}$ with $\\boldsymbol{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$ using second-order central differences and periodic boundary conditions.\n- Compute the CSF as $\\boldsymbol{f}_\\sigma = \\sigma \\kappa \\nabla F$, and the discrete pressure gradient from $p = \\sigma \\kappa F$; then form the discrete residual (the imbalance),\n$$\n\\boldsymbol{r} = \\boldsymbol{f}_\\sigma - \\nabla p,\n$$\nwhich, in the continuous chain-rule sense, reduces to $\\boldsymbol{r} \\approx -\\sigma F \\nabla \\kappa$ when curvature variations dominate. Treat viscosity as negligible for the short time considered and compute a single explicit Euler update for velocity from rest,\n$$\n\\boldsymbol{u}^{(1)} = \\boldsymbol{0} + \\Delta t \\frac{\\boldsymbol{r}}{\\rho}.\n$$\nDefine the parasitic velocity amplitude as the maximum magnitude of $\\boldsymbol{u}^{(1)}$ over the domain,\n$$\nU_{\\max} = \\max_{i,j} \\left\\| \\boldsymbol{u}^{(1)}_{i,j} \\right\\|.\n$$\n\nUse the following physical parameters (ensure units are consistent throughout and report speeds in meters per second): $\\rho = 1000\\,\\text{kg}\\,\\text{m}^{-3}$, $\\sigma = 0.0728\\,\\text{N}\\,\\text{m}^{-1}$, $L = 1\\,\\text{m}$, $R = 0.25\\,\\text{m}$, $\\Delta t = 10^{-3}\\,\\text{s}$, $\\varepsilon = 1.5 \\Delta x$. Employ periodic boundary conditions for derivatives.\n\nYour program must compute $U_{\\max}$ for each test case below. The final output should be a single line containing a comma-separated Python list with the results ordered as specified.\n\nTest suite:\n1. $N = 16$.\n2. $N = 32$.\n3. $N = 64$.\n4. $N = 128$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is a floating-point number in meters per second. No other text should be printed.",
            "solution": "The problem requires the computation of parasitic velocities arising from numerical force imbalances in a Coupled Level-Set and Volume-of-Fluid (CLSVOF) simulation of a stationary, circular droplet. The analysis is performed on a two-dimensional Cartesian grid for a series of grid refinements.\n\n### Problem Validation\n\nFirst, the problem statement is validated against the required criteria.\n\n**Step 1: Extract Givens**\n\n*   **Governing Equation**: The incompressible two-phase momentum balance is given as $\\rho \\frac{\\partial \\boldsymbol{u}}{\\partial t} = -\\nabla p + \\mu \\nabla^2 \\boldsymbol{u} + \\sigma \\kappa \\delta(\\phi) \\boldsymbol{n}$.\n*   **System Configuration**: A stationary, circular droplet of radius $R$ is centered at $(L/2, L/2)$ in a quiescent fluid within a square domain of side length $L$. Viscosity $\\mu$ is considered negligible.\n*   **Numerical Grid**: A uniform Cartesian grid of $N \\times N$ cells with spacing $\\Delta x = \\Delta y = L/N$.\n*   **Level-Set Function**: The interface is described by the signed distance function $\\phi(x,y) = \\sqrt{(x - L/2)^2 + (y - L/2)^2} - R$.\n*   **Color Function**: A smoothed color function $F$ is defined as $F = H_\\varepsilon(\\phi)$, where $H_\\varepsilon(\\phi)$ is a regularized Heaviside function with smoothing half-width $\\varepsilon = 1.5 \\Delta x$. The function is defined as:\n    $$\n    H_\\varepsilon(\\phi) =\n    \\begin{cases}\n    0,  \\phi \\le -\\varepsilon, \\\\\n    1,  \\phi \\ge \\varepsilon, \\\\\n    \\frac{1}{2}\\left(1 + \\frac{\\phi}{\\varepsilon} + \\frac{1}{\\pi}\\sin\\left(\\pi \\frac{\\phi}{\\varepsilon}\\right)\\right),  \\text{otherwise}.\n    \\end{cases}\n    $$\n*   **Numerical Discretization**: All spatial derivatives are to be computed using second-order central differences with periodic boundary conditions.\n*   **Force Terms**: The Continuum Surface Force (CSF) is $\\boldsymbol{f}_\\sigma = \\sigma \\kappa \\nabla F$. The pressure is set to $p = \\sigma \\kappa F$.\n*   **Curvature**: Curvature is computed from the level-set function: $\\kappa = \\nabla \\cdot \\boldsymbol{n}$, where the unit normal is $\\boldsymbol{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$.\n*   **Force Residual**: The discrete force imbalance is $\\boldsymbol{r} = \\boldsymbol{f}_\\sigma - \\nabla p$.\n*   **Velocity Update**: A single explicit Euler step from rest ($\\boldsymbol{u}^{(0)} = \\boldsymbol{0}$) is used: $\\boldsymbol{u}^{(1)} = \\Delta t \\frac{\\boldsymbol{r}}{\\rho}$.\n*   **Output Metric**: The parasitic velocity amplitude is the maximum magnitude of the velocity field: $U_{\\max} = \\max_{i,j} \\left\\| \\boldsymbol{u}^{(1)}_{i,j} \\right\\|$.\n*   **Physical Parameters**: $\\rho = 1000\\,\\text{kg}\\,\\text{m}^{-3}$, $\\sigma = 0.0728\\,\\text{N}\\,\\text{m}^{-1}$, $L = 1\\,\\text{m}$, $R = 0.25\\,\\text{m}$, $\\Delta t = 10^{-3}\\,\\text{s}$.\n*   **Test Suite**: The computation is to be performed for $N \\in \\{16, 32, 64, 128\\}$.\n\n**Step 2: Validate Using Extracted Givens**\n\n*   **Scientific Grounding**: The problem is well-grounded in the field of computational fluid dynamics, specifically concerning the numerical simulation of multiphase flows. The CLSVOF method, the Continuum Surface Force model, and the analysis of parasitic currents are established and important topics. The governing equations and numerical models are standard.\n*   **Well-Posedness**: The problem is computationally well-posed. It specifies a deterministic algorithm with all necessary functions, parameters, and boundary conditions. For the given grid resolutions (even $N$), no grid point lies at the droplet's exact center, avoiding the singularity in the definition of the normal vector $\\boldsymbol{n}$.\n*   **Objectivity**: The problem is stated in precise, objective, and technical language, free from any subjective elements.\n*   **Consistency and Completeness**: The problem is self-contained. All variables, constants, and procedures are defined. There are no contradictions. The chosen parameters are physically realistic (properties of water at standard conditions).\n\n**Step 3: Verdict and Action**\n\nThe problem is deemed **valid**. It represents a standard numerical experiment to assess the accuracy of a force-balanced surface tension discretization scheme. The solution will be provided as requested.\n\n### Solution Methodology\n\nThe computation of the maximum parasitic velocity amplitude, $U_{\\max}$, proceeds through a sequence of steps for each specified grid resolution $N$.\n\n1.  **Grid Generation**: A two-dimensional grid is constructed over the square domain $[0, L] \\times [0, L]$. The cell centers $(x_i, y_j)$ are defined as $x_i = (i + 0.5)\\Delta x$ and $y_j = (j + 0.5)\\Delta y$ for $i, j \\in \\{0, 1, \\dots, N-1\\}$, where $\\Delta x = \\Delta y = L/N$.\n\n2.  **Field Initialization**: The scalar field for the level-set function, $\\phi_{i,j}$, is computed at each grid point using its analytical definition: $\\phi_{i,j} = \\sqrt{(x_i - L/2)^2 + (y_j - L/2)^2} - R$.\n\n3.  **Color Function Construction**: The smoothed color function field, $F_{i,j}$, is obtained by applying the regularized Heaviside function $H_\\varepsilon$ to the level-set field, $F_{i,j} = H_\\varepsilon(\\phi_{i,j})$, with a smoothing width $\\varepsilon = 1.5\\Delta x$.\n\n4.  **Discrete Derivative Operators**: Second-order central differences with periodic boundary conditions are used for all spatial derivatives. For a generic scalar field $q$ on the grid, the discrete gradient $\\nabla_d q$ is computed as:\n    $$\n    (\\nabla_d q)_{i,j} = \\left( \\frac{q_{i+1,j} - q_{i-1,j}}{2\\Delta x}, \\frac{q_{i,j+1} - q_{i,j-1}}{2\\Delta y} \\right)\n    $$\n    For a vector field $\\boldsymbol{v} = (v_x, v_y)$, the discrete divergence $\\nabla_d \\cdot \\boldsymbol{v}$ is:\n    $$\n    (\\nabla_d \\cdot \\boldsymbol{v})_{i,j} = \\frac{(v_x)_{i+1,j} - (v_x)_{i-1,j}}{2\\Delta x} + \\frac{(v_y)_{i,j+1} - (v_y)_{i,j-1}}{2\\Delta y}\n    $$\n    In both cases, indices are evaluated modulo $N$ to enforce periodicity.\n\n5.  **Curvature Calculation**: The curvature field $\\kappa$ is computed in two stages. First, the gradient of the level-set function, $\\nabla_d \\phi$, is calculated. The unit normal vector field $\\boldsymbol{n}$ is then found by normalizing this gradient at each point: $\\boldsymbol{n}_{i,j} = (\\nabla_d \\phi)_{i,j} / \\lVert (\\nabla_d \\phi)_{i,j} \\rVert$. A small tolerance is added to the denominator to prevent division by zero in practice. Second, the divergence of the unit normal field is computed to yield the curvature: $\\kappa_{i,j} = (\\nabla_d \\cdot \\boldsymbol{n})_{i,j}$.\n\n6.  **Force Calculation**:\n    *   The pressure field is computed directly: $p_{i,j} = \\sigma \\kappa_{i,j} F_{i,j}$.\n    *   The discrete gradient of the color function, $(\\nabla_d F)_{i,j}$, is calculated.\n    *   The CSF vector field is then assembled: $(\\boldsymbol{f}_\\sigma)_{i,j} = \\sigma \\kappa_{i,j} (\\nabla_d F)_{i,j}$.\n    *   The discrete pressure gradient vector field, $(\\nabla_d p)_{i,j}$, is computed.\n\n7.  **Residual and Velocity**: The force imbalance (residual) at each grid point is the difference between the discrete CSF and pressure gradient: $\\boldsymbol{r}_{i,j} = (\\boldsymbol{f}_\\sigma)_{i,j} - (\\nabla_d p)_{i,j}$. This residual drives the parasitic flow. A single explicit Euler time step yields the velocity field after a short time $\\Delta t$ from a state of rest:\n    $$\n    \\boldsymbol{u}^{(1)}_{i,j} = \\frac{\\Delta t}{\\rho} \\boldsymbol{r}_{i,j}\n    $$\n\n8.  **Maximum Parasitic Velocity**: The magnitude of the velocity vector is computed at each grid point, $\\lVert \\boldsymbol{u}^{(1)}_{i,j} \\rVert$. The maximum value over the entire domain is the desired metric, $U_{\\max}$:\n    $$\n    U_{\\max} = \\max_{i,j} \\sqrt{ (u_x^{(1)})_{i,j}^2 + (u_y^{(1)})_{i,j}^2 }\n    $$\nThis procedure is repeated for each value of $N$ in the test suite $\\{16, 32, 64, 128\\}$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum parasitic velocity for a stationary droplet\n    using a CLSVOF method for different grid resolutions.\n    \"\"\"\n\n    # Physical parameters\n    rho = 1000.0   # kg/m^3\n    sigma = 0.0728 # N/m\n    L = 1.0        # m\n    R = 0.25       # m\n    dt = 1e-3      # s\n\n    # Grid resolutions to test\n    test_cases = [16, 32, 64, 128]\n    \n    results = []\n\n    for N in test_cases:\n        # 1. Grid Generation\n        dx = L / N\n        dy = L / N\n        x = (np.arange(N) + 0.5) * dx\n        y = (np.arange(N) + 0.5) * dy\n        X, Y = np.meshgrid(x, y)\n\n        # 2. Field Initialization: Level-Set Function\n        phi = np.sqrt((X - L/2)**2 + (Y - L/2)**2) - R\n\n        # 3. Color Function Construction\n        eps = 1.5 * dx\n        \n        def regularized_heaviside(phi_field, epsilon):\n            H = np.zeros_like(phi_field)\n            \n            # Region |phi|  epsilon\n            mask = np.abs(phi_field)  epsilon\n            phi_norm = phi_field[mask] / epsilon\n            H[mask] = 0.5 * (1 + phi_norm + (1/np.pi) * np.sin(np.pi * phi_norm))\n            \n            # Region phi >= epsilon\n            H[phi_field >= epsilon] = 1.0\n            \n            # Region phi = -epsilon is already 0.0\n            return H\n\n        F = regularized_heaviside(phi, eps)\n\n        # 4. Discrete Derivative Operators\n        def gradient(q, hx, hy):\n            \"\"\"Computes gradient using 2nd-order central differences with periodic BCs.\"\"\"\n            grad_x = (np.roll(q, -1, axis=1) - np.roll(q, 1, axis=1)) / (2 * hx)\n            grad_y = (np.roll(q, -1, axis=0) - np.roll(q, 1, axis=0)) / (2 * hy)\n            return grad_x, grad_y\n\n        def divergence(vx, vy, hx, hy):\n            \"\"\"Computes divergence using 2nd-order central differences with periodic BCs.\"\"\"\n            dvx_dx = (np.roll(vx, -1, axis=1) - np.roll(vx, 1, axis=1)) / (2 * hx)\n            dvy_dy = (np.roll(vy, -1, axis=0) - np.roll(vy, 1, axis=0)) / (2 * hy)\n            return dvx_dx + dvy_dy\n\n        # 5. Curvature Calculation\n        phi_gx, phi_gy = gradient(phi, dx, dy)\n        norm_grad_phi = np.sqrt(phi_gx**2 + phi_gy**2) + 1e-15 # Add epsilon for stability\n        \n        nx = phi_gx / norm_grad_phi\n        ny = phi_gy / norm_grad_phi\n        \n        kappa = divergence(nx, ny, dx, dy)\n        \n        # 6. Force Calculation\n        p = sigma * kappa * F\n        \n        F_gx, F_gy = gradient(F, dx, dy)\n        f_sigma_x = sigma * kappa * F_gx\n        f_sigma_y = sigma * kappa * F_gy\n        \n        p_gx, p_gy = gradient(p, dx, dy)\n\n        # 7. Residual and Velocity\n        r_x = f_sigma_x - p_gx\n        r_y = f_sigma_y - p_gy\n        \n        u_x = (dt / rho) * r_x\n        u_y = (dt / rho) * r_y\n\n        # 8. Maximum Parasitic Velocity\n        u_mag = np.sqrt(u_x**2 + u_y**2)\n        U_max = np.max(u_mag)\n        results.append(U_max)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}