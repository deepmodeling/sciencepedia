{
    "hands_on_practices": [
        {
            "introduction": "In level-set formulations, sharp interfaces are replaced by thin transition regions where material properties like thermal conductivity, $k$, vary smoothly. This is typically achieved using a smoothed Heaviside function, $H_\\epsilon(\\phi)$, but this numerical convenience introduces modeling errors that depend on the smoothing width $\\epsilon$. This practice explores these consequences in a controlled one-dimensional heat conduction problem, allowing you to precisely quantify how the choice of $\\epsilon$ impacts both the property representation and a critical physical observable like the overall heat flux .",
            "id": "3968048",
            "problem": "A one-dimensional, steady heat conduction problem is considered to assess the consequences of using a smoothed Heaviside function in a level-set formulation for mixture property evaluation, as is common in Coupled Level-Set Volume-of-Fluid (CLSVOF) methods. Let the domain be the interval $[0,L]$ with unit cross-sectional area, and let an interface separating two materials be located at $x=x_0$. The level-set function is $ \\phi(x) = x - x_0 $. The mixture rule for thermal conductivity uses a smoothed Heaviside function $ H_{\\epsilon}(\\phi) $ with smoothing half-width $ \\epsilon  0 $:\n$$\nk(\\phi) = k_1 + (k_2 - k_1)\\, H_{\\epsilon}(\\phi),\n$$\nwhere $ k_1 $ and $ k_2 $ are the constant thermal conductivities of material $1$ and material $2$, respectively, in units of $\\mathrm{W/(m\\,K)}$. The exact sharp-interface conductivity is\n$$\nk_{\\mathrm{exact}}(x) =\n\\begin{cases}\nk_1,  x  x_0, \\\\\nk_2,  x  x_0.\n\\end{cases}\n$$\nUse the following standard smoothed Heaviside function:\n$$\nH_{\\epsilon}(\\phi) =\n\\begin{cases}\n0,  \\phi  -\\epsilon, \\\\\n\\dfrac{1}{2}\\left[1 + \\dfrac{\\phi}{\\epsilon} + \\dfrac{1}{\\pi}\\sin\\!\\left(\\pi \\dfrac{\\phi}{\\epsilon}\\right)\\right],  |\\phi| \\le \\epsilon, \\\\\n1,  \\phi  \\epsilon.\n\\end{cases}\n$$\n\nUnder steady conditions, Fourier’s law $ q(x) = -k(x)\\, \\dfrac{dT}{dx} $ applies and the governing equation $ \\dfrac{d}{dx}\\!\\left(k(x)\\, \\dfrac{dT}{dx}\\right) = 0 $ implies a constant heat flux $ q $ throughout the domain. With boundary temperatures $ T(0) = T_{\\mathrm{hot}} $ and $ T(L) = T_{\\mathrm{cold}} $ (in $\\mathrm{K}$), the flux for any spatially varying conductivity $ k(x) $ is\n$$\nq = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\displaystyle \\int_{0}^{L} \\dfrac{dx}{k(x)}} \\quad \\text{in} \\quad \\mathrm{W/m^2}.\n$$\n\nYour task is to compute two error metrics that quantify the impact of finite $ \\epsilon $:\n1. The mean absolute property error\n$$\nE_{\\mathrm{prop}} = \\dfrac{1}{L} \\int_{0}^{L} \\left| k(\\phi(x)) - k_{\\mathrm{exact}}(x) \\right|\\, dx \\quad \\text{in} \\quad \\mathrm{W/(m\\,K)}.\n$$\n2. The relative flux error (expressed as a decimal, not a percentage),\n$$\nE_{\\mathrm{flux}} = \\dfrac{q_{\\mathrm{smooth}} - q_{\\mathrm{exact}}}{\\left| q_{\\mathrm{exact}} \\right|},\n$$\nwhere\n$$\nq_{\\mathrm{exact}} = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\dfrac{x_0}{k_1} + \\dfrac{L - x_0}{k_2}}, \\quad\nq_{\\mathrm{smooth}} = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\displaystyle \\int_{0}^{L} \\dfrac{dx}{k(\\phi(x))}}.\n$$\n\nTo ensure scientific realism, all parameters must be used with their physical units as indicated. Angles in trigonometric functions are in radians.\n\nImplement a program that, for each of the following test cases, computes $ E_{\\mathrm{prop}} $ (in $\\mathrm{W/(m\\,K)}$) and $ E_{\\mathrm{flux}} $ (decimal):\n\n- Test case $1$ (happy path, moderate contrast): $ L = 1.0\\,\\mathrm{m} $, $ x_0 = 0.5\\,\\mathrm{m} $, $ k_1 = 0.6\\,\\mathrm{W/(m\\,K)} $, $ k_2 = 15.0\\,\\mathrm{W/(m\\,K)} $, $ \\epsilon = 0.01\\,\\mathrm{m} $, $ T_{\\mathrm{hot}} = 400\\,\\mathrm{K} $, $ T_{\\mathrm{cold}} = 300\\,\\mathrm{K} $.\n- Test case $2$ (strong contrast, small $ \\epsilon $): $ L = 1.0\\,\\mathrm{m} $, $ x_0 = 0.5\\,\\mathrm{m} $, $ k_1 = 0.1\\,\\mathrm{W/(m\\,K)} $, $ k_2 = 100.0\\,\\mathrm{W/(m\\,K)} $, $ \\epsilon = 0.001\\,\\mathrm{m} $, $ T_{\\mathrm{hot}} = 400\\,\\mathrm{K} $, $ T_{\\mathrm{cold}} = 300\\,\\mathrm{K} $.\n- Test case $3$ (degenerate contrast, zero jump): $ L = 1.0\\,\\mathrm{m} $, $ x_0 = 0.5\\,\\mathrm{m} $, $ k_1 = 1.0\\,\\mathrm{W/(m\\,K)} $, $ k_2 = 1.0\\,\\mathrm{W/(m\\,K)} $, $ \\epsilon = 0.2\\,\\mathrm{m} $, $ T_{\\mathrm{hot}} = 350\\,\\mathrm{K} $, $ T_{\\mathrm{cold}} = 300\\,\\mathrm{K} $.\n- Test case $4$ (large $ \\epsilon $, large contrast): $ L = 1.0\\,\\mathrm{m} $, $ x_0 = 0.5\\,\\mathrm{m} $, $ k_1 = 0.2\\,\\mathrm{W/(m\\,K)} $, $ k_2 = 20.0\\,\\mathrm{W/(m\\,K)} $, $ \\epsilon = 0.3\\,\\mathrm{m} $, $ T_{\\mathrm{hot}} = 500\\,\\mathrm{K} $, $ T_{\\mathrm{cold}} = 300\\,\\mathrm{K} $.\n- Test case $5$ (interface near boundary, reversed contrast): $ L = 1.0\\,\\mathrm{m} $, $ x_0 = 0.1\\,\\mathrm{m} $, $ k_1 = 10.0\\,\\mathrm{W/(m\\,K)} $, $ k_2 = 0.5\\,\\mathrm{W/(m\\,K)} $, $ \\epsilon = 0.05\\,\\mathrm{m} $, $ T_{\\mathrm{hot}} = 310\\,\\mathrm{K} $, $ T_{\\mathrm{cold}} = 300\\,\\mathrm{K} $.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Report the values sequentially by test case, with each test case contributing two numbers $[E_{\\mathrm{prop}}, E_{\\mathrm{flux}}]$. Thus, the final output format must be\n$$\n[ E_{\\mathrm{prop,1}}, E_{\\mathrm{flux,1}}, E_{\\mathrm{prop,2}}, E_{\\mathrm{flux,2}}, E_{\\mathrm{prop,3}}, E_{\\mathrm{flux,3}}, E_{\\mathrm{prop,4}}, E_{\\mathrm{flux,4}}, E_{\\mathrm{prop,5}}, E_{\\mathrm{flux,5}} ].\n$$\nAll outputs for $ E_{\\mathrm{prop}} $ must be in $\\mathrm{W/(m\\,K)}$, and all outputs for $ E_{\\mathrm{flux}} $ must be decimals (dimensionless).",
            "solution": "The user-provided problem has been analyzed and validated against the specified criteria.\n\n### Step 1: Extract Givens\n- **Domain and Physics**: One-dimensional, steady heat conduction in the domain $[0,L]$ with unit cross-sectional area.\n- **Interface Location**: $x=x_0$.\n- **Level-Set Function**: $\\phi(x) = x - x_0$.\n- **Smoothed Thermal Conductivity**: $k(\\phi) = k_1 + (k_2 - k_1)\\, H_{\\epsilon}(\\phi)$, where $k_1$ and $k_2$ are constant conductivities and $\\epsilon  0$ is the smoothing half-width.\n- **Smoothed Heaviside Function**:\n$$\nH_{\\epsilon}(\\phi) =\n\\begin{cases}\n0,  \\phi  -\\epsilon, \\\\\n\\dfrac{1}{2}\\left[1 + \\dfrac{\\phi}{\\epsilon} + \\dfrac{1}{\\pi}\\sin\\!\\left(\\pi \\dfrac{\\phi}{\\epsilon}\\right)\\right],  |\\phi| \\le \\epsilon, \\\\\n1,  \\phi  \\epsilon.\n\\end{cases}\n$$\n- **Exact (Sharp) Thermal Conductivity**:\n$$\nk_{\\mathrm{exact}}(x) =\n\\begin{cases}\nk_1,  x  x_0, \\\\\nk_2,  x  x_0.\n\\end{cases}\n$$\n- ** Governing Equation and Heat Flux**: The governing equation $\\dfrac{d}{dx}\\!\\left(k(x)\\, \\dfrac{dT}{dx}\\right) = 0$ implies constant heat flux $q$. With boundary temperatures $T(0) = T_{\\mathrm{hot}}$ and $T(L) = T_{\\mathrm{cold}}$, the flux is given by $q = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\int_{0}^{L} \\frac{dx}{k(x)}}$.\n- **Error Metrics to Compute**:\n  1. Mean absolute property error: $E_{\\mathrm{prop}} = \\dfrac{1}{L} \\int_{0}^{L} \\left| k(\\phi(x)) - k_{\\mathrm{exact}}(x) \\right|\\, dx$.\n  2. Relative flux error: $E_{\\mathrm{flux}} = \\dfrac{q_{\\mathrm{smooth}} - q_{\\mathrm{exact}}}{\\left| q_{\\mathrm{exact}} \\right|}$, where $q_{\\mathrm{exact}}$ and $q_{\\mathrm{smooth}}$ are fluxes computed with $k_{\\mathrm{exact}}(x)$ and $k(\\phi(x))$, respectively.\n- **Flux Formulas**:\n$$\nq_{\\mathrm{exact}} = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\dfrac{x_0}{k_1} + \\dfrac{L - x_0}{k_2}}, \\quad\nq_{\\mathrm{smooth}} = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\displaystyle \\int_{0}^{L} \\dfrac{dx}{k(\\phi(x))}}.\n$$\n- **Test Cases**: Five sets of parameters ($L, x_0, k_1, k_2, \\epsilon, T_{\\mathrm{hot}}, T_{\\mathrm{cold}}$) are provided.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the established principles of heat transfer (Fourier's law of heat conduction) and standard numerical techniques for multiphase flows (level-set methods, diffuse interface modeling). The formulation is objective, mathematically precise, and internally consistent. All parameters, constants, and boundary conditions required for a solution are provided. The functions are well-defined and the integrals are convergent for positive conductivities. A unique, stable solution exists for each test case. An inspection of the parameters for all test cases confirms that the smoothing region $[x_0 - \\epsilon, x_0 + \\epsilon]$ is always fully contained within the domain $[0,L]$, avoiding boundary complications. The problem is a valid, well-posed scientific exercise in computational thermal engineering.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A step-by-step solution will be developed.\n\nThe solution requires the calculation of two quantities, $E_{\\mathrm{prop}}$ and $E_{\\mathrm{flux}}$, for each test case. The derivation for each is presented below.\n\n**Calculation of Mean Absolute Property Error ($E_{\\mathrm{prop}}$)**\n\nThe definition is $E_{\\mathrm{prop}} = \\dfrac{1}{L} \\int_{0}^{L} \\left| k(\\phi(x)) - k_{\\mathrm{exact}}(x) \\right|\\, dx$.\nThe integrand is non-zero only where the smoothed conductivity $k(\\phi(x))$ differs from the exact sharp-interface conductivity $k_{\\mathrm{exact}}(x)$. By definition of $H_{\\epsilon}(\\phi)$, this occurs exclusively within the smoothing band where $|\\phi(x)| \\le \\epsilon$, which corresponds to the spatial interval $[x_0 - \\epsilon, x_0 + \\epsilon]$.\nTherefore, the integral reduces to:\n$$\nL \\cdot E_{\\mathrm{prop}} = \\int_{x_0 - \\epsilon}^{x_0 + \\epsilon} \\left| k(\\phi(x)) - k_{\\mathrm{exact}}(x) \\right|\\, dx\n$$\nThis integral is split at the interface location $x=x_0$:\n$$\nL \\cdot E_{\\mathrm{prop}} = \\int_{x_0 - \\epsilon}^{x_0} |k(\\phi(x)) - k_1|\\,dx + \\int_{x_0}^{x_0 + \\epsilon} |k(\\phi(x)) - k_2|\\,dx\n$$\nSubstituting $k(\\phi(x)) = k_1 + (k_2 - k_1)H_{\\epsilon}(\\phi(x))$:\n$$\nL \\cdot E_{\\mathrm{prop}} = \\int_{x_0 - \\epsilon}^{x_0} |(k_2 - k_1)H_{\\epsilon}(\\phi(x))|\\,dx + \\int_{x_0}^{x_0 + \\epsilon} |k_1 - k_2 + (k_2 - k_1)H_{\\epsilon}(\\phi(x))|\\,dx\n$$\nSince $H_{\\epsilon} \\ge 0$, and for $H_{\\epsilon}$'s argument range, $0 \\le H_{\\epsilon} \\le 1$, this simplifies to:\n$$\nL \\cdot E_{\\mathrm{prop}} = |k_2 - k_1| \\left( \\int_{x_0 - \\epsilon}^{x_0} H_{\\epsilon}(\\phi(x))\\,dx + \\int_{x_0}^{x_0 + \\epsilon} (1 - H_{\\epsilon}(\\phi(x)))\\,dx \\right)\n$$\nWe perform a change of variables $u = \\phi(x) = x - x_0$, so $du = dx$. The integration limits become $[-\\epsilon, 0]$ and $[0, \\epsilon]$ respectively.\n$$\nL \\cdot E_{\\mathrm{prop}} = |k_2 - k_1| \\left( \\int_{-\\epsilon}^{0} H_{\\epsilon}(u)\\,du + \\int_{0}^{\\epsilon} (1 - H_{\\epsilon}(u))\\,du \\right)\n$$\nThe function $H_{\\epsilon}(u)$ has the property that $H_{\\epsilon}(u) + H_{\\epsilon}(-u) = 1$ for $|u| \\le \\epsilon$. Thus, $1 - H_{\\epsilon}(u) = H_{\\epsilon}(-u)$. The second integral becomes $\\int_{0}^{\\epsilon} H_{\\epsilon}(-u)\\,du$. With a substitution $v = -u$, this becomes $\\int_{0}^{-\\epsilon} H_{\\epsilon}(v)(-dv) = \\int_{-\\epsilon}^{0} H_{\\epsilon}(v)\\,dv$, proving the two integrals are identical. We need only evaluate one of them.\n$$\n\\int_{-\\epsilon}^{0} H_{\\epsilon}(u)\\,du = \\int_{-\\epsilon}^{0} \\dfrac{1}{2}\\left[1 + \\dfrac{u}{\\epsilon} + \\dfrac{1}{\\pi}\\sin\\!\\left(\\pi \\dfrac{u}{\\epsilon}\\right)\\right]\\,du\n$$\nThe antiderivative is $\\frac{1}{2} \\left[u + \\frac{u^2}{2\\epsilon} - \\frac{\\epsilon}{\\pi^2}\\cos\\left(\\pi \\frac{u}{\\epsilon}\\right)\\right]$. Evaluating from $-\\epsilon$ to $0$:\n$$\n= \\frac{1}{2} \\left[ \\left(0 + 0 - \\frac{\\epsilon}{\\pi^2}\\cos(0)\\right) - \\left(-\\epsilon + \\frac{(-\\epsilon)^2}{2\\epsilon} - \\frac{\\epsilon}{\\pi^2}\\cos(-\\pi)\\right) \\right]\n= \\frac{1}{2} \\left[ -\\frac{\\epsilon}{\\pi^2} - \\left(-\\epsilon + \\frac{\\epsilon}{2} + \\frac{\\epsilon}{\\pi^2}\\right) \\right]\n= \\frac{1}{2} \\left[ \\frac{\\epsilon}{2} - \\frac{2\\epsilon}{\\pi^2} \\right] = \\epsilon\\left(\\frac{1}{4} - \\frac{1}{\\pi^2}\\right)\n$$\nThe total integral is twice this value:\n$$\nL \\cdot E_{\\mathrm{prop}} = |k_2 - k_1| \\cdot 2 \\epsilon\\left(\\frac{1}{4} - \\frac{1}{\\pi^2}\\right) = |k_2 - k_1| \\epsilon\\left(\\frac{1}{2} - \\frac{2}{\\pi^2}\\right)\n$$\nFinally, the mean absolute property error has the analytical solution:\n$$\nE_{\\mathrm{prop}} = \\frac{|k_2 - k_1|\\epsilon}{L} \\left(\\frac{1}{2} - \\frac{2}{\\pi^2}\\right)\n$$\n\n**Calculation of Relative Flux Error ($E_{\\mathrm{flux}}$)**\n\nThe relative flux error is $E_{\\mathrm{flux}} = (q_{\\mathrm{smooth}} - q_{\\mathrm{exact}}) / |q_{\\mathrm{exact}}|$. The calculation of $q_{\\mathrm{exact}}$ is straightforward from the provided formula. The calculation of $q_{\\mathrm{smooth}}$ requires evaluating the total thermal resistance with the smoothed conductivity profile:\n$$\nR_{\\mathrm{smooth}} = \\int_{0}^{L} \\dfrac{dx}{k(\\phi(x))}\n$$\nThe integral is decomposed into three parts based on the definition of $H_{\\epsilon}(\\phi)$:\n$$\nR_{\\mathrm{smooth}} = \\int_{0}^{x_0 - \\epsilon} \\frac{dx}{k_1} + \\int_{x_0 - \\epsilon}^{x_0 + \\epsilon} \\frac{dx}{k_1 + (k_2 - k_1)H_{\\epsilon}(x-x_0)} + \\int_{x_0 + \\epsilon}^{L} \\frac{dx}{k_2}\n$$\nThe first and third integrals are trivial, representing the thermal resistance of the pure material regions:\n$$\nR_1 = \\frac{x_0 - \\epsilon}{k_1} \\quad \\text{and} \\quad R_2 = \\frac{L - (x_0 + \\epsilon)}{k_2}\n$$\nThe middle integral, over the diffuse interface region, does not possess a simple closed-form analytical solution due to the complexity of the integrand's denominator.\n$$\nR_{\\mathrm{mid}} = \\int_{x_0 - \\epsilon}^{x_0 + \\epsilon} \\frac{dx}{k_1 + (k_2 - k_1) \\frac{1}{2}\\left[1 + \\frac{x-x_0}{\\epsilon} + \\frac{1}{\\pi}\\sin\\!\\left(\\pi \\frac{x-x_0}{\\epsilon}\\right)\\right]}\n$$\nThis integral must be computed using numerical quadrature. By changing variables to $u=x-x_0$, the integral simplifies to a form suitable for standard numerical integrators:\n$$\nR_{\\mathrm{mid}} = \\int_{-\\epsilon}^{\\epsilon} \\frac{du}{k_1 + (k_2 - k_1) H_{\\epsilon}(u)}\n$$\nThe total smoothed resistance is $R_{\\mathrm{smooth}} = R_1 + R_{\\mathrm{mid}} + R_2$. The smoothed flux is $q_{\\mathrm{smooth}} = (T_{\\mathrm{hot}} - T_{\\mathrm{cold}}) / R_{\\mathrm{smooth}}$. The relative flux error $E_{\\mathrm{flux}}$ is then computed from these quantities.\n\nFor the special case where $k_1 = k_2$, we observe that $k(\\phi(x)) = k_1 + (k_1-k_1)H_{\\epsilon}(\\phi(x)) = k_1$. The smoothed conductivity is identical to the exact conductivity, $k_1$. Consequently, $E_{\\mathrm{prop}} = 0$ and $q_{\\mathrm{smooth}}=q_{\\mathrm{exact}}$, which means $E_{\\mathrm{flux}} = 0$. This provides a consistency check for the implementation (Test Case 3).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes property and flux errors for a 1D steady heat conduction problem\n    with a smoothed interface, as specified in the problem statement.\n    \"\"\"\n    # Define the test cases from the problem statement:\n    # (L, x0, k1, k2, eps, Thot, Tcold)\n    test_cases = [\n        (1.0, 0.5, 0.6, 15.0, 0.01, 400.0, 300.0),\n        (1.0, 0.5, 0.1, 100.0, 0.001, 400.0, 300.0),\n        (1.0, 0.5, 1.0, 1.0, 0.2, 350.0, 300.0),\n        (1.0, 0.5, 0.2, 20.0, 0.3, 500.0, 300.0),\n        (1.0, 0.1, 10.0, 0.5, 0.05, 310.0, 300.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L, x0, k1, k2, eps, Thot, Tcold = case\n        \n        # --- Task 1: Compute Mean Absolute Property Error (E_prop) ---\n        # The analytical formula derived in the solution is used:\n        # E_prop = (|k2 - k1| * eps / L) * (1/2 - 2 / pi^2)\n        E_prop_factor = 0.5 - 2 / (np.pi**2)\n        E_prop = (np.abs(k2 - k1) * eps / L) * E_prop_factor\n        \n        # --- Task 2: Compute Relative Flux Error (E_flux) ---\n        \n        # Handle the degenerate case where k1 and k2 are identical.\n        # In this case, k_smooth = k_exact = k1, so both errors are zero.\n        if np.isclose(k1, k2):\n            E_flux = 0.0\n            results.extend([E_prop, E_flux])\n            continue\n        \n        # Handle the degenerate case of zero temperature difference.\n        if np.isclose(Thot, Tcold):\n            # Both q_exact and q_smooth are zero, so the error is zero.\n            E_flux = 0.0\n            results.extend([E_prop, E_flux])\n            continue\n\n        # Calculate q_exact using the sharp-interface thermal resistance.\n        R_exact = x0 / k1 + (L - x0) / k2\n        q_exact = (Thot - Tcold) / R_exact\n        \n        # Calculate q_smooth using numerical integration for the smoothed resistance.\n        \n        # Define the smoothed Heaviside function for the region |phi| = epsilon.\n        def H_eps_func(phi, epsilon):\n            phi_scaled = phi / epsilon\n            return 0.5 * (1.0 + phi_scaled + (1.0 / np.pi) * np.sin(np.pi * phi_scaled))\n            \n        # Define the integrand for the thermal resistance in the smoothed region.\n        # This is the reciprocal of the smoothed conductivity k(phi).\n        def resistance_integrand(phi, epsilon, k1, k2):\n            k_smooth = k1 + (k2 - k1) * H_eps_func(phi, epsilon)\n            return 1.0 / k_smooth\n            \n        # Numerically integrate to find the resistance of the smoothed region.\n        # The integration is over u = x - x0 from -eps to eps.\n        R_mid, _ = quad(resistance_integrand, -eps, eps, args=(eps, k1, k2))\n        \n        # Calculate the total thermal resistance for the smoothed case.\n        # It's the sum of resistances from the two pure-material regions and the\n        # numerically computed resistance of the smoothed interface region.\n        # The problem setup ensures x0-eps  0 and x0+eps  L.\n        R_smooth_pure1 = (x0 - eps) / k1\n        R_smooth_pure2 = (L - (x0 + eps)) / k2\n        R_smooth = R_smooth_pure1 + R_mid + R_smooth_pure2\n        \n        q_smooth = (Thot - Tcold) / R_smooth\n        \n        # Calculate the final relative flux error.\n        E_flux = (q_smooth - q_exact) / np.abs(q_exact)\n        \n        results.extend([E_prop, E_flux])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12g}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A central challenge in simulating multiphase flows is the accurate modeling of surface tension, often handled with the Continuum Surface Force (CSF) model. On a discrete grid, an imbalance between the discretized pressure gradient and the surface tension force can generate spurious \"parasitic\" velocities, even for a physically static interface. This exercise guides you through diagnosing these numerical artifacts for a stationary droplet, a classic benchmark problem, and investigating how their magnitude scales with grid refinement—a crucial validation test for any multiphase solver .",
            "id": "3968030",
            "problem": "A stationary, circular droplet is embedded in a quiescent, incompressible, two-phase fluid within a square domain. The interface is evolved by a Coupled Level-Set and Volume-of-Fluid method (CLSVOF) in the sense that curvature is computed from the level-set representation while the color function used in the Continuum Surface Force (CSF) is built from a smoothed volume fraction obtained via a regularized Heaviside of the level set. The goal is to assess parasitic velocities arising from discrete imbalance of capillary and pressure forces under nominally balanced-force discretization by refining the grid.\n\nStart from the incompressible two-phase momentum balance with the Continuum Surface Force model:\n$$\n\\rho \\frac{\\partial \\boldsymbol{u}}{\\partial t} = -\\nabla p + \\mu \\nabla^2 \\boldsymbol{u} + \\sigma \\kappa \\delta(\\phi) \\boldsymbol{n},\n$$\nwhere $\\rho$ is density, $\\boldsymbol{u}$ is velocity, $p$ is pressure, $\\mu$ is viscosity, $\\sigma$ is surface tension coefficient, $\\kappa$ is mean curvature, $\\delta(\\phi)$ is a regularized Dirac distribution concentrated at the interface represented by a level-set function $\\phi$, and $\\boldsymbol{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$ is the unit normal.\n\nFor a stationary droplet at mechanical equilibrium, the continuous balanced-force condition implies that $-\\nabla p + \\sigma \\kappa \\delta(\\phi) \\boldsymbol{n} = \\boldsymbol{0}$. Under Coupled Level-Set Volume-of-Fluid (CLSVOF), the CSF term is implemented as $\\sigma \\kappa \\nabla F$, where $F$ is a smoothed volume fraction (color function) derived from the level set via a regularized Heaviside function. Using a balanced-force discretization, it is natural to choose $p = \\sigma \\kappa F$, which ideally cancels the capillary term for constant curvature and exact derivatives. In practice, discrete approximations induce a residual, which generates parasitic velocities.\n\nImplement the following in a two-dimensional square domain of side length $L$:\n- Use a uniform Cartesian grid with $N \\times N$ cells of size $\\Delta x = \\Delta y = L/N$.\n- Center a circular droplet of radius $R$ at the domain center $(L/2, L/2)$.\n- Define the level-set field as the signed distance to the circle:\n$$\n\\phi(x,y) = \\sqrt{(x - L/2)^2 + (y - L/2)^2} - R,\n$$\nwith negative values inside the droplet.\n- Define the regularized Heaviside function with smoothing half-width $\\varepsilon$,\n$$\nH_\\varepsilon(\\phi) =\n\\begin{cases}\n0,  \\phi \\le -\\varepsilon, \\\\\n1,  \\phi \\ge \\varepsilon, \\\\\n\\frac{1}{2}\\left(1 + \\frac{\\phi}{\\varepsilon} + \\frac{1}{\\pi}\\sin\\left(\\pi \\frac{\\phi}{\\varepsilon}\\right)\\right),  \\text{otherwise},\n\\end{cases}\n$$\nand set the color function $F = H_\\varepsilon(\\phi)$.\n- Compute curvature from the level set via $\\kappa = \\nabla \\cdot \\boldsymbol{n}$ with $\\boldsymbol{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$ using second-order central differences and periodic boundary conditions.\n- Compute the CSF as $\\boldsymbol{f}_\\sigma = \\sigma \\kappa \\nabla F$, and the discrete pressure gradient from $p = \\sigma \\kappa F$; then form the discrete residual (the imbalance),\n$$\n\\boldsymbol{r} = \\boldsymbol{f}_\\sigma - \\nabla p,\n$$\nwhich, in the continuous chain-rule sense, reduces to $\\boldsymbol{r} \\approx -\\sigma F \\nabla \\kappa$ when curvature variations dominate. Treat viscosity as negligible for the short time considered and compute a single explicit Euler update for velocity from rest,\n$$\n\\boldsymbol{u}^{(1)} = \\boldsymbol{0} + \\Delta t \\frac{\\boldsymbol{r}}{\\rho}.\n$$\nDefine the parasitic velocity amplitude as the maximum magnitude of $\\boldsymbol{u}^{(1)}$ over the domain,\n$$\nU_{\\max} = \\max_{i,j} \\left\\| \\boldsymbol{u}^{(1)}_{i,j} \\right\\|.\n$$\n\nUse the following physical parameters (ensure units are consistent throughout and report speeds in meters per second): $\\rho = 1000\\,\\text{kg}\\,\\text{m}^{-3}$, $\\sigma = 0.0728\\,\\text{N}\\,\\text{m}^{-1}$, $L = 1\\,\\text{m}$, $R = 0.25\\,\\text{m}$, $\\Delta t = 10^{-3}\\,\\text{s}$, $\\varepsilon = 1.5 \\Delta x$. Employ periodic boundary conditions for derivatives.\n\nYour program must compute $U_{\\max}$ for each test case below. The final output should be a single line containing a comma-separated Python list with the results ordered as specified.\n\nTest suite:\n1. $N = 16$.\n2. $N = 32$.\n3. $N = 64$.\n4. $N = 128$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is a floating-point number in meters per second. No other text should be printed.",
            "solution": "The problem requires the computation of parasitic velocities arising from numerical force imbalances in a Coupled Level-Set and Volume-of-Fluid (CLSVOF) simulation of a stationary, circular droplet. The analysis is performed on a two-dimensional Cartesian grid for a series of grid refinements.\n\n### Problem Validation\n\nFirst, the problem statement is validated against the required criteria.\n\n**Step 1: Extract Givens**\n\n*   **Governing Equation**: The incompressible two-phase momentum balance is given as $\\rho \\frac{\\partial \\boldsymbol{u}}{\\partial t} = -\\nabla p + \\mu \\nabla^2 \\boldsymbol{u} + \\sigma \\kappa \\delta(\\phi) \\boldsymbol{n}$.\n*   **System Configuration**: A stationary, circular droplet of radius $R$ is centered at $(L/2, L/2)$ in a quiescent fluid within a square domain of side length $L$. Viscosity $\\mu$ is considered negligible.\n*   **Numerical Grid**: A uniform Cartesian grid of $N \\times N$ cells with spacing $\\Delta x = \\Delta y = L/N$.\n*   **Level-Set Function**: The interface is described by the signed distance function $\\phi(x,y) = \\sqrt{(x - L/2)^2 + (y - L/2)^2} - R$.\n*   **Color Function**: A smoothed color function $F$ is defined as $F = H_\\varepsilon(\\phi)$, where $H_\\varepsilon(\\phi)$ is a regularized Heaviside function with smoothing half-width $\\varepsilon = 1.5 \\Delta x$. The function is defined as:\n    $$\n    H_\\varepsilon(\\phi) =\n    \\begin{cases}\n    0,  \\phi \\le -\\varepsilon, \\\\\n    1,  \\phi \\ge \\varepsilon, \\\\\n    \\frac{1}{2}\\left(1 + \\frac{\\phi}{\\varepsilon} + \\frac{1}{\\pi}\\sin\\left(\\pi \\frac{\\phi}{\\varepsilon}\\right)\\right),  \\text{otherwise}.\n    \\end{cases}\n    $$\n*   **Numerical Discretization**: All spatial derivatives are to be computed using second-order central differences with periodic boundary conditions.\n*   **Force Terms**: The Continuum Surface Force (CSF) is $\\boldsymbol{f}_\\sigma = \\sigma \\kappa \\nabla F$. The pressure is set to $p = \\sigma \\kappa F$.\n*   **Curvature**: Curvature is computed from the level-set function: $\\kappa = \\nabla \\cdot \\boldsymbol{n}$, where the unit normal is $\\boldsymbol{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$.\n*   **Force Residual**: The discrete force imbalance is $\\boldsymbol{r} = \\boldsymbol{f}_\\sigma - \\nabla p$.\n*   **Velocity Update**: A single explicit Euler step from rest ($\\boldsymbol{u}^{(0)} = \\boldsymbol{0}$) is used: $\\boldsymbol{u}^{(1)} = \\Delta t \\frac{\\boldsymbol{r}}{\\rho}$.\n*   **Output Metric**: The parasitic velocity amplitude is the maximum magnitude of the velocity field: $U_{\\max} = \\max_{i,j} \\left\\| \\boldsymbol{u}^{(1)}_{i,j} \\right\\|$.\n*   **Physical Parameters**: $\\rho = 1000\\,\\text{kg}\\,\\text{m}^{-3}$, $\\sigma = 0.0728\\,\\text{N}\\,\\text{m}^{-1}$, $L = 1\\,\\text{m}$, $R = 0.25\\,\\text{m}$, $\\Delta t = 10^{-3}\\,\\text{s}$.\n*   **Test Suite**: The computation is to be performed for $N \\in \\{16, 32, 64, 128\\}$.\n\n**Step 2: Validate Using Extracted Givens**\n\n*   **Scientific Grounding**: The problem is well-grounded in the field of computational fluid dynamics, specifically concerning the numerical simulation of multiphase flows. The CLSVOF method, the Continuum Surface Force model, and the analysis of parasitic currents are established and important topics. The governing equations and numerical models are standard.\n*   **Well-Posedness**: The problem is computationally well-posed. It specifies a deterministic algorithm with all necessary functions, parameters, and boundary conditions. For the given grid resolutions (even $N$), no grid point lies at the droplet's exact center, avoiding the singularity in the definition of the normal vector $\\boldsymbol{n}$.\n*   **Objectivity**: The problem is stated in precise, objective, and technical language, free from any subjective elements.\n*   **Consistency and Completeness**: The problem is self-contained. All variables, constants, and procedures are defined. There are no contradictions. The chosen parameters are physically realistic (properties of water at standard conditions).\n\n**Step 3: Verdict and Action**\n\nThe problem is deemed **valid**. It represents a standard numerical experiment to assess the accuracy of a force-balanced surface tension discretization scheme. The solution will be provided as requested.\n\n### Solution Methodology\n\nThe computation of the maximum parasitic velocity amplitude, $U_{\\max}$, proceeds through a sequence of steps for each specified grid resolution $N$.\n\n1.  **Grid Generation**: A two-dimensional grid is constructed over the square domain $[0, L] \\times [0, L]$. The cell centers $(x_i, y_j)$ are defined as $x_i = (i + 0.5)\\Delta x$ and $y_j = (j + 0.5)\\Delta y$ for $i, j \\in \\{0, 1, \\dots, N-1\\}$, where $\\Delta x = \\Delta y = L/N$.\n\n2.  **Field Initialization**: The scalar field for the level-set function, $\\phi_{i,j}$, is computed at each grid point using its analytical definition: $\\phi_{i,j} = \\sqrt{(x_i - L/2)^2 + (y_j - L/2)^2} - R$.\n\n3.  **Color Function Construction**: The smoothed color function field, $F_{i,j}$, is obtained by applying the regularized Heaviside function $H_\\varepsilon$ to the level-set field, $F_{i,j} = H_\\varepsilon(\\phi_{i,j})$, with a smoothing width $\\varepsilon = 1.5\\Delta x$.\n\n4.  **Discrete Derivative Operators**: Second-order central differences with periodic boundary conditions are used for all spatial derivatives. For a generic scalar field $q$ on the grid, the discrete gradient $\\nabla_d q$ is computed as:\n    $$\n    (\\nabla_d q)_{i,j} = \\left( \\frac{q_{i+1,j} - q_{i-1,j}}{2\\Delta x}, \\frac{q_{i,j+1} - q_{i,j-1}}{2\\Delta y} \\right)\n    $$\n    For a vector field $\\boldsymbol{v} = (v_x, v_y)$, the discrete divergence $\\nabla_d \\cdot \\boldsymbol{v}$ is:\n    $$\n    (\\nabla_d \\cdot \\boldsymbol{v})_{i,j} = \\frac{(v_x)_{i+1,j} - (v_x)_{i-1,j}}{2\\Delta x} + \\frac{(v_y)_{i,j+1} - (v_y)_{i,j-1}}{2\\Delta y}\n    $$\n    In both cases, indices are evaluated modulo $N$ to enforce periodicity.\n\n5.  **Curvature Calculation**: The curvature field $\\kappa$ is computed in two stages. First, the gradient of the level-set function, $\\nabla_d \\phi$, is calculated. The unit normal vector field $\\boldsymbol{n}$ is then found by normalizing this gradient at each point: $\\boldsymbol{n}_{i,j} = (\\nabla_d \\phi)_{i,j} / \\lVert (\\nabla_d \\phi)_{i,j} \\rVert$. A small tolerance is added to the denominator to prevent division by zero in practice. Second, the divergence of the unit normal field is computed to yield the curvature: $\\kappa_{i,j} = (\\nabla_d \\cdot \\boldsymbol{n})_{i,j}$.\n\n6.  **Force Calculation**:\n    *   The pressure field is computed directly: $p_{i,j} = \\sigma \\kappa_{i,j} F_{i,j}$.\n    *   The discrete gradient of the color function, $(\\nabla_d F)_{i,j}$, is calculated.\n    *   The CSF vector field is then assembled: $(\\boldsymbol{f}_\\sigma)_{i,j} = \\sigma \\kappa_{i,j} (\\nabla_d F)_{i,j}$.\n    *   The discrete pressure gradient vector field, $(\\nabla_d p)_{i,j}$, is computed.\n\n7.  **Residual and Velocity**: The force imbalance (residual) at each grid point is the difference between the discrete CSF and pressure gradient: $\\boldsymbol{r}_{i,j} = (\\boldsymbol{f}_\\sigma)_{i,j} - (\\nabla_d p)_{i,j}$. This residual drives the parasitic flow. A single explicit Euler time step yields the velocity field after a short time $\\Delta t$ from a state of rest:\n    $$\n    \\boldsymbol{u}^{(1)}_{i,j} = \\frac{\\Delta t}{\\rho} \\boldsymbol{r}_{i,j}\n    $$\n\n8.  **Maximum Parasitic Velocity**: The magnitude of the velocity vector is computed at each grid point, $\\lVert \\boldsymbol{u}^{(1)}_{i,j} \\rVert$. The maximum value over the entire domain is the desired metric, $U_{\\max}$:\n    $$\n    U_{\\max} = \\max_{i,j} \\sqrt{ (u_x^{(1)})_{i,j}^2 + (u_y^{(1)})_{i,j}^2 }\n    $$\nThis procedure is repeated for each value of $N$ in the test suite $\\{16, 32, 64, 128\\}$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum parasitic velocity for a stationary droplet\n    using a CLSVOF method for different grid resolutions.\n    \"\"\"\n\n    # Physical parameters\n    rho = 1000.0   # kg/m^3\n    sigma = 0.0728 # N/m\n    L = 1.0        # m\n    R = 0.25       # m\n    dt = 1e-3      # s\n\n    # Grid resolutions to test\n    test_cases = [16, 32, 64, 128]\n    \n    results = []\n\n    for N in test_cases:\n        # 1. Grid Generation\n        dx = L / N\n        dy = L / N\n        x = (np.arange(N) + 0.5) * dx\n        y = (np.arange(N) + 0.5) * dy\n        X, Y = np.meshgrid(x, y)\n\n        # 2. Field Initialization: Level-Set Function\n        phi = np.sqrt((X - L/2)**2 + (Y - L/2)**2) - R\n\n        # 3. Color Function Construction\n        eps = 1.5 * dx\n        \n        def regularized_heaviside(phi_field, epsilon):\n            H = np.zeros_like(phi_field)\n            \n            # Region |phi|  epsilon\n            mask = np.abs(phi_field)  epsilon\n            phi_norm = phi_field[mask] / epsilon\n            H[mask] = 0.5 * (1 + phi_norm + (1/np.pi) * np.sin(np.pi * phi_norm))\n            \n            # Region phi = epsilon\n            H[phi_field = epsilon] = 1.0\n            \n            # Region phi = -epsilon is already 0.0\n            return H\n\n        F = regularized_heaviside(phi, eps)\n\n        # 4. Discrete Derivative Operators\n        def gradient(q, hx, hy):\n            \"\"\"Computes gradient using 2nd-order central differences with periodic BCs.\"\"\"\n            grad_x = (np.roll(q, -1, axis=1) - np.roll(q, 1, axis=1)) / (2 * hx)\n            grad_y = (np.roll(q, -1, axis=0) - np.roll(q, 1, axis=0)) / (2 * hy)\n            return grad_x, grad_y\n\n        def divergence(vx, vy, hx, hy):\n            \"\"\"Computes divergence using 2nd-order central differences with periodic BCs.\"\"\"\n            dvx_dx = (np.roll(vx, -1, axis=1) - np.roll(vx, 1, axis=1)) / (2 * hx)\n            dvy_dy = (np.roll(vy, -1, axis=0) - np.roll(vy, 1, axis=0)) / (2 * hy)\n            return dvx_dx + dvy_dy\n\n        # 5. Curvature Calculation\n        phi_gx, phi_gy = gradient(phi, dx, dy)\n        norm_grad_phi = np.sqrt(phi_gx**2 + phi_gy**2) + 1e-15 # Add epsilon for stability\n        \n        nx = phi_gx / norm_grad_phi\n        ny = phi_gy / norm_grad_phi\n        \n        kappa = divergence(nx, ny, dx, dy)\n        \n        # 6. Force Calculation\n        p = sigma * kappa * F\n        \n        F_gx, F_gy = gradient(F, dx, dy)\n        f_sigma_x = sigma * kappa * F_gx\n        f_sigma_y = sigma * kappa * F_gy\n        \n        p_gx, p_gy = gradient(p, dx, dy)\n\n        # 7. Residual and Velocity\n        r_x = f_sigma_x - p_gx\n        r_y = f_sigma_y - p_gy\n        \n        u_x = (dt / rho) * r_x\n        u_y = (dt / rho) * r_y\n\n        # 8. Maximum Parasitic Velocity\n        u_mag = np.sqrt(u_x**2 + u_y**2)\n        U_max = np.max(u_mag)\n        results.append(U_max)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A complete Coupled Level-Set and Volume-of-Fluid (CLSVOF) method requires the careful orchestration of several distinct algorithms to leverage the strengths of each component. This capstone practice integrates these pieces into a single, coherent update step for a physically relevant scenario: conduction-driven phase change. You will implement the coupled advection of the level-set function $\\phi$ and the volume-of-fluid fraction $F$, including the use of an extension velocity and the essential reinitialization of $\\phi$, providing a holistic, hands-on view of the CLSVOF method in action .",
            "id": "3967984",
            "problem": "You are to implement a single explicit update step of the Coupled Level-Set Volume-of-Fluid (CLSVOF) method for a two-dimensional interface undergoing phase change, suitable for advanced graduate study in computational thermal engineering. The Coupled Level-Set Volume-of-Fluid (CLSVOF) method combines a level-set function $ \\phi $ to represent the interface as a signed distance function and a volume-of-fluid fraction $ F \\in [0,1] $ to ensure conservation of the transported phase fraction. The update must use an extension velocity field to advect $ \\phi $ consistent with phase change, while the update of $ F $ must be conservative.\n\nThe update step is based on the following fundamental laws and definitions:\n\n- The level-set advection equation is $ \\partial \\phi / \\partial t + \\mathbf{u}_{\\text{ext}} \\cdot \\nabla \\phi = 0 $, where $ \\mathbf{u}_{\\text{ext}} $ is an extension velocity defined to move the interface along its normal direction, consistent with phase change.\n- The volume-of-fluid conservation law is $ \\partial F / \\partial t + \\nabla \\cdot (F \\mathbf{u}_{\\text{ext}}) = 0 $, which must be discretized to ensure conservation of $ F $.\n- The extension velocity is defined as $ \\mathbf{u}_{\\text{ext}} = V_n \\, \\mathbf{n} $, where $ \\mathbf{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert $ is the unit normal vector to the interface and $ V_n $ is a normal interface velocity from the one-phase Stefan condition. For conduction-driven phase change, the Stefan condition is $ \\rho L V_n = ( \\mathbf{q}_\\ell - \\mathbf{q}_s ) \\cdot \\mathbf{n} $, where $ \\rho $ is density, $ L $ is latent heat, $ \\mathbf{q}_\\ell = -k_\\ell \\nabla T_\\ell $ is the liquid heat flux, and $ \\mathbf{q}_s = -k_s \\nabla T_s $ is the solid heat flux. For this problem, use the sign convention $ V_n = ( k_\\ell \\nabla T_\\ell - k_s \\nabla T_s ) \\cdot \\mathbf{n} / ( \\rho L ) $.\n- The reinitialization of $ \\phi $ toward a signed distance function after advection is accomplished by integrating the reinitialization equation $ \\partial \\phi / \\partial \\tau + S_\\epsilon(\\phi_0)( \\lVert \\nabla \\phi \\rVert - 1 ) = 0 $ over a short pseudo-time $ \\tau $, where $ \\phi_0 $ is the pre-reinitialization field and $ S_\\epsilon(\\phi_0) = \\phi_0 / \\sqrt{ \\phi_0^2 + \\epsilon^2 } $ is a regularized sign function. The reinitialization is needed to maintain the signed-distance property for accurate normal calculations.\n\nYou must implement the following in a single program:\n\n- Consider a square domain $ [0,1] \\times [0,1] $ with periodic boundary conditions in both coordinates. The grid resolution is $ N_x = 64 $, $ N_y = 64 $, with uniform spacings $ \\Delta x = 1/N_x $ and $ \\Delta y = 1/N_y $. All spatial dimensions are in meters, so $ \\Delta x $ and $ \\Delta y $ are in meters.\n- Initialize the level-set $ \\phi(x,y) $ as the signed distance from a circle of radius $ R = 0.25 $ meters centered at $ (x_c, y_c) = (0.5, 0.5) $ meters. Inside the circle, $ \\phi  0 $, and outside, $ \\phi  0 $. The volume-of-fluid fraction $ F $ must be initialized as a smoothed Heaviside of $ \\phi $, $ F = H_\\epsilon(\\phi) $, with $ \\epsilon = 2 \\Delta x $ and $ H_\\epsilon(\\phi) = 0 $ if $ \\phi \\le -\\epsilon $, $ H_\\epsilon(\\phi) = 1 $ if $ \\phi \\ge \\epsilon $, and $ H_\\epsilon(\\phi) = \\frac{1}{2}\\left( 1 + \\frac{\\phi}{\\epsilon} + \\frac{1}{\\pi} \\sin \\left( \\frac{\\pi \\phi}{\\epsilon} \\right) \\right) $ otherwise.\n- Define constant material properties $ \\rho = 1000 \\, \\mathrm{kg/m^3} $, $ L = 3.34 \\times 10^5 \\, \\mathrm{J/kg} $, $ k_s = 1.0 \\, \\mathrm{W/(m\\cdot K)} $, $ k_\\ell = 2.0 \\, \\mathrm{W/(m\\cdot K)} $.\n- For each test case, define analytic temperature gradients $ \\nabla T_s = (\\alpha, 0) $ and $ \\nabla T_\\ell = (-\\alpha, 0) $ (units of Kelvin per meter), with $ \\alpha $ specified by the test suite. Compute the interface normal velocity $ V_n = \\left( k_\\ell \\nabla T_\\ell - k_s \\nabla T_s \\right) \\cdot \\mathbf{n} / (\\rho L) $ pointwise using the current $ \\mathbf{n} $ from $ \\phi $. Then set $ \\mathbf{u}_{\\text{ext}} = V_n \\, \\mathbf{n} $. There is no bulk flow, only phase-change-induced motion, and thus $ \\mathbf{u}_{\\text{ext}} $ is purely normal.\n- Compute the stable time step from the Courant–Friedrichs–Lewy (CFL) condition $ \\Delta t = \\mathrm{CFL} \\cdot \\min(\\Delta x, \\Delta y) / \\max_{i,j} \\lVert \\mathbf{u}_{\\text{ext}} \\rVert $, with $ \\mathrm{CFL} = 0.5 $. If $ \\max \\lVert \\mathbf{u}_{\\text{ext}} \\rVert = 0 $, use $ \\Delta t = \\mathrm{CFL} \\cdot \\min(\\Delta x, \\Delta y) / 10^{-12} $ to avoid division by zero. Time is in seconds.\n- Update $ \\phi $ by an explicit first-order upwind discretization of $ \\partial \\phi / \\partial t + \\mathbf{u}_{\\text{ext}} \\cdot \\nabla \\phi = 0 $ with periodic boundary conditions in both directions.\n- Reinitialize $ \\phi $ toward a signed-distance function by integrating the reinitialization equation over a small pseudo-time using a Godunov-type discretization for $ \\lVert \\nabla \\phi \\rVert $ and $ S_\\epsilon(\\phi_0) $ with $ \\epsilon = \\Delta x $. Use at least $ 15 $ pseudo-time steps with step size $ \\Delta \\tau = 0.3 \\min(\\Delta x, \\Delta y) $.\n- Update $ F $ using a conservative finite-volume upwind flux method applied to $ \\partial F / \\partial t + \\nabla \\cdot (F \\mathbf{u}_{\\text{ext}}) = 0 $ with periodic boundary conditions, ensuring that the discrete update preserves the total integral of $ F $ up to numerical roundoff. Do not clip $ F $; instead, measure any violation of $ F \\in [0,1] $.\n- After the update, compute the following metrics for each test case:\n    1. $ m_0 = \\left| \\sum_{i,j} F^{n+1}_{i,j} - \\sum_{i,j} F^{n}_{i,j} \\right| $, a dimensionless discrete conservation error of $ F $.\n    2. $ m_1 = \\sum_{i,j} \\max(0, F^{n+1}_{i,j} - 1) + \\sum_{i,j} \\max(0, -F^{n+1}_{i,j}) $, a dimensionless measure of the violation of the physical bound $ F \\in [0,1] $.\n    3. $ m_2 = \\sqrt{ \\frac{1}{N_x N_y} \\sum_{i,j} \\left( H_\\epsilon(\\phi^{n+1}_{i,j}) - F^{n+1}_{i,j} \\right)^2 } $, a dimensionless root-mean-square consistency error between the updated $ F $ and the smoothed Heaviside of the updated $ \\phi $, using the same $ \\epsilon $ as above.\n- Implement the following test suite by setting $ \\alpha $ to three different values:\n    - Test case A: $ \\alpha = 0.0 $.\n    - Test case B: $ \\alpha = 1.0 $.\n    - Test case C: $ \\alpha = 5.0 $.\n- Your program should produce a single line of output containing the nine scalar results $ [m_0^\\mathrm{A}, m_1^\\mathrm{A}, m_2^\\mathrm{A}, m_0^\\mathrm{B}, m_1^\\mathrm{B}, m_2^\\mathrm{B}, m_0^\\mathrm{C}, m_1^\\mathrm{C}, m_2^\\mathrm{C}] $ as a comma-separated list enclosed in square brackets, with each entry expressed as a decimal number with no units.\n\nAll physical parameters must be treated with correct units: length in meters, time in seconds, density in kilograms per cubic meter, thermal conductivity in watts per meter per Kelvin, latent heat in joules per kilogram, temperature gradient in kelvin per meter. Angles are not used. The algorithm must start from the given fundamental laws and should not introduce shortcuts or pre-derived formulas beyond standard numerical discretizations. The test suite ensures coverage of zero phase-change velocity, moderate normal velocity, and larger normal velocity. The program must be fully self-contained and require no input.",
            "solution": "The user has provided a valid problem statement to implement a single update step of the Coupled Level-Set Volume-of-Fluid (CLSVOF) method for a two-dimensional phase change scenario. The problem is scientifically grounded in computational thermal engineering, well-posed, and objective. All necessary equations, parameters, and numerical methods are specified. I will proceed with a complete solution.\n\nThe implementation will follow a sequence of distinct steps for each test case:\n1.  **Initialization**: A square computational domain of size $1 \\times 1$ is discretized into a $64 \\times 64$ grid. The level-set function, $\\phi$, is initialized as a signed distance function to a circle of radius $R=0.25$ centered at $(0.5, 0.5)$. The volume-of-fluid function, $F$, is initialized as a regularized Heaviside function of $\\phi$, denoted as $H_\\epsilon(\\phi)$, with a smoothing width of $\\epsilon = 2\\Delta x$.\n2.  **Velocity Field Calculation**: The extension velocity field, $\\mathbf{u}_{\\text{ext}}$, which drives the interface motion, is calculated. This velocity is normal to the interface, $\\mathbf{u}_{\\text{ext}} = V_n \\mathbf{n}$.\n    -   The unit normal vector, $\\mathbf{n} = \\nabla\\phi / \\lVert \\nabla\\phi \\rVert$, is computed from the level-set field using second-order central differences for the gradient $\\nabla\\phi$. Periodic boundary conditions are enforced. To prevent division by zero, a small tolerance is added to the denominator.\n    -   The normal velocity, $V_n$, is determined by the Stefan condition, $V_n = ( k_\\ell \\nabla T_\\ell - k_s \\nabla T_s ) \\cdot \\mathbf{n} / (\\rho L)$. The problem specifies constant temperature gradients $\\nabla T_s = (\\alpha, 0)$ and $\\nabla T_\\ell = (-\\alpha, 0)$, which simplifies the expression to $V_n = -(k_\\ell + k_s)\\alpha n_x / (\\rho L)$, where $n_x$ is the x-component of the normal vector.\n3.  **Time Step Determination**: A stable time step, $\\Delta t$, is computed using the Courant–Friedrichs–Lewy (CFL) condition: $\\Delta t = \\mathrm{CFL} \\cdot \\min(\\Delta x, \\Delta y) / \\max \\lVert \\mathbf{u}_{\\text{ext}} \\rVert$, with $\\mathrm{CFL} = 0.5$.\n4.  **Level-Set Advection**: The level-set function $\\phi$ is advected in time according to $\\partial \\phi / \\partial t + \\mathbf{u}_{\\text{ext}} \\cdot \\nabla \\phi = 0$. This equation is discretized using an explicit first-order upwind scheme. The spatial derivative $\\nabla \\phi$ is approximated using one-sided differences chosen based on the sign of the velocity components at each grid cell, ensuring numerical stability.\n5.  **Level-Set Reinitialization**: After advection, the $\\phi$ field may no longer be a signed distance function. It is reinitialized by solving the equation $\\partial \\phi / \\partial \\tau + S_\\epsilon(\\phi_0)( \\lVert \\nabla \\phi \\rVert - 1 ) = 0$ for a number of pseudo-time steps $\\tau$. Here, $\\phi_0$ is the level-set field after advection, and $S_\\epsilon$ is a smoothed sign function that keeps the zero-level-set stationary. The Hamilton-Jacobi term, $\\lVert \\nabla \\phi \\rVert$, is discretized using a Godunov-type upwind scheme, which is standard for such problems and selects appropriate one-sided differences based on the direction of information propagation (as indicated by $S_\\epsilon(\\phi_0)$).\n6.  **Volume-of-Fluid Advection**: The volume-of-fluid fraction $F$ is updated by solving the conservation law $\\partial F / \\partial t + \\nabla \\cdot (F \\mathbf{u}_{\\text{ext}}) = 0$. A conservative finite-volume method is used. The flux $F \\mathbf{u}_{\\text{ext}}$ across each cell face is computed using a first-order upwind scheme. The value of $F$ at a cell face is taken from the upwind cell, determined by the sign of the normal velocity at that face. This discretization ensures that the total volume of fluid, $\\sum F_{i,j}$, is conserved up to machine precision.\n7.  **Metric Calculation**: Finally, three specified metrics are computed to evaluate the performance of the update step:\n    -   $m_0$: The discrete conservation error, calculated as the absolute difference between the sum of $F$ values before and after the update.\n    -   $m_1$: The sum of violations of the bound $F \\in [0,1]$.\n    -   $m_2$: The root-mean-square error measuring the consistency between the updated $F$ field and the Heaviside function of the updated $\\phi$ field.\n\nThis entire process is repeated for the three specified values of the parameter $\\alpha$, which controls the magnitude of the phase-change velocity.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a single explicit update step of the Coupled Level-Set Volume-of-Fluid (CLSVOF)\n    method for a two-dimensional interface undergoing phase change.\n    \"\"\"\n\n    def heaviside_smooth(phi, epsilon):\n        \"\"\"\n        Computes the smoothed Heaviside function H_epsilon(phi).\n        \"\"\"\n        F = np.zeros_like(phi)\n        mask = np.abs(phi) = epsilon\n        phi_masked = phi[mask]\n        F[mask] = 0.5 * (1 + phi_masked / epsilon + (1 / np.pi) * np.sin(np.pi * phi_masked / epsilon))\n        F[phi  epsilon] = 1.0\n        F[phi  -epsilon] = 0.0\n        return F\n\n    def sign_smooth(phi, epsilon):\n        \"\"\"\n        Computes the regularized sign function S_epsilon(phi).\n        \"\"\"\n        return phi / np.sqrt(phi**2 + epsilon**2)\n\n    def run_case(alpha, Nx, Ny, R, x_c, y_c, rho, L, ks, kl):\n        \"\"\"\n        Executes the full CLSVOF update step for a given test case alpha.\n        \"\"\"\n        # --- 1. Initialization ---\n        dx = 1.0 / Nx\n        dy = 1.0 / Ny\n        x = np.linspace(0.5 * dx, 1.0 - 0.5 * dx, Nx)\n        y = np.linspace(0.5 * dy, 1.0 - 0.5 * dy, Ny)\n        xx, yy = np.meshgrid(x, y)\n\n        phi = np.sqrt((xx - x_c)**2 + (yy - y_c)**2) - R\n        eps_H = 2.0 * dx\n        F_initial = heaviside_smooth(phi, eps_H)\n        \n        sum_F_initial = np.sum(F_initial)\n        F = F_initial.copy()\n        \n        # --- 2. Velocity Field Calculation ---\n        grad_phi_x = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * dx)\n        grad_phi_y = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2.0 * dy)\n        norm_grad_phi = np.sqrt(grad_phi_x**2 + grad_phi_y**2)\n        \n        nx = grad_phi_x / (norm_grad_phi + 1e-12)\n        ny = grad_phi_y / (norm_grad_phi + 1e-12)\n\n        Vn = -(kl + ks) * alpha * nx / (rho * L)\n        u_ext_x = Vn * nx\n        u_ext_y = Vn * ny\n\n        # --- 3. Time Step Determination ---\n        max_vel = np.max(np.sqrt(u_ext_x**2 + u_ext_y**2))\n        CFL = 0.5\n        dt = CFL * min(dx, dy) / (max_vel if max_vel  1e-15 else 1e-12)\n\n        # --- 4. Level-Set Advection ---\n        phi_dx_b = (phi - np.roll(phi, 1, axis=1)) / dx\n        phi_dx_f = (np.roll(phi, -1, axis=1) - phi) / dx\n        phi_dy_b = (phi - np.roll(phi, 1, axis=0)) / dy\n        phi_dy_f = (np.roll(phi, -1, axis=0) - phi) / dy\n        \n        advection_term = (np.maximum(u_ext_x, 0) * phi_dx_b + np.minimum(u_ext_x, 0) * phi_dx_f +\n                          np.maximum(u_ext_y, 0) * phi_dy_b + np.minimum(u_ext_y, 0) * phi_dy_f)\n        phi_advected = phi - dt * advection_term\n\n        # --- 5. Level-Set Reinitialization ---\n        phi_reinit = phi_advected.copy()\n        phi_0 = phi_advected.copy()\n        eps_reinit = dx\n        dtau = 0.3 * min(dx, dy)\n        num_reinit_steps = 15\n        \n        sign_phi0 = sign_smooth(phi_0, eps_reinit)\n\n        for _ in range(num_reinit_steps):\n            phi_x_m = (phi_reinit - np.roll(phi_reinit, 1, axis=1)) / dx\n            phi_x_p = (np.roll(phi_reinit, -1, axis=1) - phi_reinit) / dx\n            phi_y_m = (phi_reinit - np.roll(phi_reinit, 1, axis=0)) / dy\n            phi_y_p = (np.roll(phi_reinit, -1, axis=0) - phi_reinit) / dy\n\n            grad_phi_mag_sq = np.zeros_like(phi_reinit)\n            \n            mask_pos = sign_phi0  0\n            term_x_sq_pos = np.maximum(np.maximum(phi_x_m[mask_pos], 0)**2, np.minimum(phi_x_p[mask_pos], 0)**2)\n            term_y_sq_pos = np.maximum(np.maximum(phi_y_m[mask_pos], 0)**2, np.minimum(phi_y_p[mask_pos], 0)**2)\n            grad_phi_mag_sq[mask_pos] = term_x_sq_pos + term_y_sq_pos\n            \n            mask_neg = sign_phi0  0\n            term_x_sq_neg = np.maximum(np.minimum(phi_x_m[mask_neg], 0)**2, np.maximum(phi_x_p[mask_neg], 0)**2)\n            term_y_sq_neg = np.maximum(np.minimum(phi_y_m[mask_neg], 0)**2, np.maximum(phi_y_p[mask_neg], 0)**2)\n            grad_phi_mag_sq[mask_neg] = term_x_sq_neg + term_y_sq_neg\n\n            grad_phi_mag = np.sqrt(grad_phi_mag_sq)\n            phi_reinit -= dtau * sign_phi0 * (grad_phi_mag - 1)\n        \n        phi_final = phi_reinit\n\n        # --- 6. Volume-of-Fluid Advection ---\n        u_face_x = (u_ext_x + np.roll(u_ext_x, -1, axis=1)) / 2.0\n        u_face_y = (u_ext_y + np.roll(u_ext_y, -1, axis=0)) / 2.0\n\n        flux_x = np.maximum(u_face_x, 0) * F + np.minimum(u_face_x, 0) * np.roll(F, -1, axis=1)\n        flux_y = np.maximum(u_face_y, 0) * F + np.minimum(u_face_y, 0) * np.roll(F, -1, axis=0)\n\n        div_flux_x = (flux_x - np.roll(flux_x, 1, axis=1)) / dx\n        div_flux_y = (flux_y - np.roll(flux_y, 1, axis=0)) / dy\n        \n        F_final = F - dt * (div_flux_x + div_flux_y)\n\n        # --- 7. Metric Calculation ---\n        sum_F_final = np.sum(F_final)\n        m0 = np.abs(sum_F_final - sum_F_initial)\n        m1 = np.sum(np.maximum(0, F_final - 1.0)) + np.sum(np.maximum(0, -F_final))\n        F_from_phi_final = heaviside_smooth(phi_final, eps_H)\n        m2 = np.sqrt(np.mean((F_from_phi_final - F_final)**2))\n        \n        return m0, m1, m2\n\n    # Define constants and test cases\n    Nx, Ny = 64, 64\n    R, x_c, y_c = 0.25, 0.5, 0.5\n    rho = 1000.0\n    L = 3.34e5\n    ks = 1.0\n    kl = 2.0\n    \n    test_cases_alpha = [0.0, 1.0, 5.0]\n    results = []\n\n    for alpha in test_cases_alpha:\n        m0, m1, m2 = run_case(alpha, Nx, Ny, R, x_c, y_c, rho, L, ks, kl)\n        results.extend([m0, m1, m2])\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}