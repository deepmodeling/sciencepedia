{
    "hands_on_practices": [
        {
            "introduction": "在水平集方法中，像密度或热导率这样的物理属性通常使用一个正则化的亥维赛德函数在界面上平滑过渡。这种做法引入了一个有限厚度的“弥散界面”，它简化了数值实现，但可能引入误差。本练习  将通过量化一个简单的一维热传导问题中热导率的误差以及由此产生的热通量误差，让您深入探究这种权衡关系，从而深刻理解平滑参数 $\\epsilon$ 的影响。",
            "id": "3968048",
            "problem": "本文考虑一个一维稳态热传导问题，以评估在混合物性评估的水平集公式中使用平滑亥维赛德函数所带来的影响，这在耦合水平集-流体体积法 (CLSVOF) 中很常见。设域为区间 $[0,L]$，横截面积为单位面积，两种材料的界面位于 $x=x_0$。水平集函数为 $ \\phi(x) = x - x_0 $。热导率的混合法则使用平滑亥维赛德函数 $ H_{\\epsilon}(\\phi) $，其平滑半宽度为 $ \\epsilon > 0 $：\n$$\nk(\\phi) = k_1 + (k_2 - k_1)\\, H_{\\epsilon}(\\phi),\n$$\n其中 $ k_1 $ 和 $ k_2 $ 分别是材料1和材料2的恒定热导率，单位为 $\\mathrm{W/(m\\,K)}$。精确的清晰界面热导率为\n$$\nk_{\\mathrm{exact}}(x) =\n\\begin{cases}\nk_1, & x < x_0, \\\\\nk_2, & x > x_0.\n\\end{cases}\n$$\n使用以下标准的平滑亥维赛德函数：\n$$\nH_{\\epsilon}(\\phi) =\n\\begin{cases}\n0, & \\phi \\le -\\epsilon, \\\\\n\\dfrac{1}{2}\\left[1 + \\dfrac{\\phi}{\\epsilon} + \\dfrac{1}{\\pi}\\sin\\!\\left(\\pi \\dfrac{\\phi}{\\epsilon}\\right)\\right], & |\\phi| \\le \\epsilon, \\\\\n1, & \\phi > \\epsilon.\n\\end{cases}\n$$\n\n在稳态条件下，傅里叶定律 $ q(x) = -k(x)\\, \\dfrac{dT}{dx} $ 适用，且控制方程 $ \\dfrac{d}{dx}\\!\\left(k(x)\\, \\dfrac{dT}{dx}\\right) = 0 $ 意味着整个域内的热通量 $ q $ 为常数。当边界温度为 $ T(0) = T_{\\mathrm{hot}} $ 和 $ T(L) = T_{\\mathrm{cold}} $ (单位为 $\\mathrm{K}$) 时，对于任意空间变化的热导率 $ k(x) $，其通量为\n$$\nq = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\displaystyle \\int_{0}^{L} \\dfrac{dx}{k(x)}} \\quad \\text{in} \\quad \\mathrm{W/m^2}.\n$$\n\n您的任务是计算两个误差度量，用以量化有限 $ \\epsilon $ 的影响：\n1. 平均绝对物性误差\n$$\nE_{\\mathrm{prop}} = \\dfrac{1}{L} \\int_{0}^{L} \\left| k(\\phi(x)) - k_{\\mathrm{exact}}(x) \\right|\\, dx \\quad \\text{in} \\quad \\mathrm{W/(m\\,K)}.\n$$\n2. 相对通量误差（以小数而非百分比表示），\n$$\nE_{\\mathrm{flux}} = \\dfrac{q_{\\mathrm{smooth}} - q_{\\mathrm{exact}}}{\\left| q_{\\mathrm{exact}} \\right|},\n$$\n其中\n$$\nq_{\\mathrm{exact}} = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\dfrac{x_0}{k_1} + \\dfrac{L - x_0}{k_2}}, \\quad\nq_{\\mathrm{smooth}} = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\displaystyle \\int_{0}^{L} \\dfrac{dx}{k(\\phi(x))}}.\n$$\n\n为确保科学真实性，所有参数必须使用其指定的物理单位。三角函数中的角度以弧度为单位。\n\n请实现一个程序，为以下每个测试用例计算 $ E_{\\mathrm{prop}} $ (单位为 $\\mathrm{W/(m\\,K)}$) 和 $ E_{\\mathrm{flux}} $ (小数)：\n\n- 测试用例 $1$ (正常情况，中等对比度)：$ L = 1.0\\,\\mathrm{m} $, $ x_0 = 0.5\\,\\mathrm{m} $, $ k_1 = 0.6\\,\\mathrm{W/(m\\,K)} $, $ k_2 = 15.0\\,\\mathrm{W/(m\\,K)} $, $ \\epsilon = 0.01\\,\\mathrm{m} $, $ T_{\\mathrm{hot}} = 400\\,\\mathrm{K} $, $ T_{\\mathrm{cold}} = 300\\,\\mathrm{K} $。\n- 测试用例 $2$ (强对比度，小 $ \\epsilon $ )：$ L = 1.0\\,\\mathrm{m} $, $ x_0 = 0.5\\,\\mathrm{m} $, $ k_1 = 0.1\\,\\mathrm{W/(m\\,K)} $, $ k_2 = 100.0\\,\\mathrm{W/(m\\,K)} $, $ \\epsilon = 0.001\\,\\mathrm{m} $, $ T_{\\mathrm{hot}} = 400\\,\\mathrm{K} $, $ T_{\\mathrm{cold}} = 300\\,\\mathrm{K} $。\n- 测试用例 $3$ (退化对比度，零跳跃)：$ L = 1.0\\,\\mathrm{m} $, $ x_0 = 0.5\\,\\mathrm{m} $, $ k_1 = 1.0\\,\\mathrm{W/(m\\,K)} $, $ k_2 = 1.0\\,\\mathrm{W/(m\\,K)} $, $ \\epsilon = 0.2\\,\\mathrm{m} $, $ T_{\\mathrm{hot}} = 350\\,\\mathrm{K} $, $ T_{\\mathrm{cold}} = 300\\,\\mathrm{K} $。\n- 测试用例 $4$ (大 $ \\epsilon $，大对比度)：$ L = 1.0\\,\\mathrm{m} $, $ x_0 = 0.5\\,\\mathrm{m} $, $ k_1 = 0.2\\,\\mathrm{W/(m\\,K)} $, $ k_2 = 20.0\\,\\mathrm{W/(m\\,K)} $, $ \\epsilon = 0.3\\,\\mathrm{m} $, $ T_{\\mathrm{hot}} = 500\\,\\mathrm{K} $, $ T_{\\mathrm{cold}} = 300\\,\\mathrm{K} $。\n- 测试用例 $5$ (界面靠近边界，反转对比度)：$ L = 1.0\\,\\mathrm{m} $, $ x_0 = 0.1\\,\\mathrm{m} $, $ k_1 = 10.0\\,\\mathrm{W/(m\\,K)} $, $ k_2 = 0.5\\,\\mathrm{W/(m\\,K)} $, $ \\epsilon = 0.05\\,\\mathrm{m} $, $ T_{\\mathrm{hot}} = 310\\,\\mathrm{K} $, $ T_{\\mathrm{cold}} = 300\\,\\mathrm{K} $。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。按测试用例顺序报告值，每个测试用例贡献两个数 $[E_{\\mathrm{prop}}, E_{\\mathrm{flux}}]$。因此，最终输出格式必须为\n$$\n[ E_{\\mathrm{prop,1}}, E_{\\mathrm{flux,1}}, E_{\\mathrm{prop,2}}, E_{\\mathrm{flux,2}}, E_{\\mathrm{prop,3}}, E_{\\mathrm{flux,3}}, E_{\\mathrm{prop,4}}, E_{\\mathrm{flux,4}}, E_{\\mathrm{prop,5}}, E_{\\mathrm{flux,5}} ].\n$$\n所有 $ E_{\\mathrm{prop}} $ 的输出单位必须是 $\\mathrm{W/(m\\,K)}$，所有 $ E_{\\mathrm{flux}} $ 的输出必须是小数（无量纲）。",
            "solution": "已根据指定标准对用户提供的问题进行了分析和验证。\n\n### 步骤1：提取给定信息\n- **域和物理**：一维稳态热传导，域为 $[0,L]$，横截面积为单位面积。\n- **界面位置**：$x=x_0$。\n- **水平集函数**：$\\phi(x) = x - x_0$。\n- **平滑热导率**：$k(\\phi) = k_1 + (k_2 - k_1)\\, H_{\\epsilon}(\\phi)$，其中 $k_1$ 和 $k_2$ 是恒定热导率，$\\epsilon > 0$ 是平滑半宽度。\n- **平滑亥维赛德函数**：\n$$\nH_{\\epsilon}(\\phi) =\n\\begin{cases}\n0, & \\phi \\le -\\epsilon, \\\\\n\\dfrac{1}{2}\\left[1 + \\dfrac{\\phi}{\\epsilon} + \\dfrac{1}{\\pi}\\sin\\!\\left(\\pi \\dfrac{\\phi}{\\epsilon}\\right)\\right], & |\\phi| \\le \\epsilon, \\\\\n1, & \\phi > \\epsilon.\n\\end{cases}\n$$\n- **精确（清晰）热导率**：\n$$\nk_{\\mathrm{exact}}(x) =\n\\begin{cases}\nk_1, & x < x_0, \\\\\nk_2, & x > x_0.\n\\end{cases}\n$$\n- **控制方程和热通量**：控制方程 $\\dfrac{d}{dx}\\!\\left(k(x)\\, \\dfrac{dT}{dx}\\right) = 0$ 意味着热通量 $q$ 为常数。边界温度为 $T(0) = T_{\\mathrm{hot}}$ 和 $T(L) = T_{\\mathrm{cold}}$ 时，通量由 $q = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\int_{0}^{L} \\frac{dx}{k(x)}}$ 给出。\n- **待计算的误差度量**：\n  1. 平均绝对物性误差：$E_{\\mathrm{prop}} = \\dfrac{1}{L} \\int_{0}^{L} \\left| k(\\phi(x)) - k_{\\mathrm{exact}}(x) \\right|\\, dx$。\n  2. 相对通量误差：$E_{\\mathrm{flux}} = \\dfrac{q_{\\mathrm{smooth}} - q_{\\mathrm{exact}}}{\\left| q_{\\mathrm{exact}} \\right|}$，其中 $q_{\\mathrm{exact}}$ 和 $q_{\\mathrm{smooth}}$ 分别是用 $k_{\\mathrm{exact}}(x)$ 和 $k(\\phi(x))$ 计算的通量。\n- **通量公式**：\n$$\nq_{\\mathrm{exact}} = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\dfrac{x_0}{k_1} + \\dfrac{L - x_0}{k_2}}, \\quad\nq_{\\mathrm{smooth}} = \\dfrac{T_{\\mathrm{hot}} - T_{\\mathrm{cold}}}{\\displaystyle \\int_{0}^{L} \\dfrac{dx}{k(\\phi(x))}}.\n$$\n- **测试用例**：提供了五组参数 ($L, x_0, k_1, k_2, \\epsilon, T_{\\mathrm{hot}}, T_{\\mathrm{cold}}$)。\n\n### 步骤2：使用提取的给定信息进行验证\n该问题在传热学（傅里叶热传导定律）的既定原理和多相流（水平集方法，扩散界面模型）的标准数值技术方面具有科学依据。其公式是客观的、数学上精确且内部一致的。求解所需的所有参数、常数和边界条件均已提供。对于正的热导率，函数定义良好且积分收敛。每个测试用例都存在唯一、稳定的解。对所有测试用例参数的检查证实，平滑区域 $[x_0 - \\epsilon, x_0 + \\epsilon]$ 始终完全包含在域 $[0,L]$ 内，从而避免了边界复杂性。该问题是计算热工学中一个有效、适定的科学练习。\n\n### 步骤3：结论与行动\n问题是**有效的**。将逐步给出解答。\n\n该解答需要为每个测试用例计算两个量：$E_{\\mathrm{prop}}$ 和 $E_{\\mathrm{flux}}$。下面给出了每个量的推导过程。\n\n**平均绝对物性误差 ($E_{\\mathrm{prop}}$) 的计算**\n\n定义为 $E_{\\mathrm{prop}} = \\dfrac{1}{L} \\int_{0}^{L} \\left| k(\\phi(x)) - k_{\\mathrm{exact}}(x) \\right|\\, dx$。\n被积函数仅在平滑热导率 $k(\\phi(x))$ 与精确的清晰界面热导率 $k_{\\mathrm{exact}}(x)$ 不同之处非零。根据 $H_{\\epsilon}(\\phi)$ 的定义，这仅发生在平滑带 $|\\phi(x)| \\le \\epsilon$ 内，该区域对应于空间区间 $[x_0 - \\epsilon, x_0 + \\epsilon]$。\n因此，积分简化为：\n$$\nL \\cdot E_{\\mathrm{prop}} = \\int_{x_0 - \\epsilon}^{x_0 + \\epsilon} \\left| k(\\phi(x)) - k_{\\mathrm{exact}}(x) \\right|\\, dx\n$$\n该积分在界面位置 $x=x_0$ 处被分割：\n$$\nL \\cdot E_{\\mathrm{prop}} = \\int_{x_0 - \\epsilon}^{x_0} |k(\\phi(x)) - k_1|\\,dx + \\int_{x_0}^{x_0 + \\epsilon} |k(\\phi(x)) - k_2|\\,dx\n$$\n代入 $k(\\phi(x)) = k_1 + (k_2 - k_1)H_{\\epsilon}(\\phi(x))$：\n$$\nL \\cdot E_{\\mathrm{prop}} = \\int_{x_0 - \\epsilon}^{x_0} |(k_2 - k_1)H_{\\epsilon}(\\phi(x))|\\,dx + \\int_{x_0}^{x_0 + \\epsilon} |k_1 - k_2 + (k_2 - k_1)H_{\\epsilon}(\\phi(x))|\\,dx\n$$\n由于 $H_{\\epsilon} \\ge 0$，并且对于 $H_{\\epsilon}$ 的参数范围，$0 \\le H_{\\epsilon} \\le 1$，这可以简化为：\n$$\nL \\cdot E_{\\mathrm{prop}} = |k_2 - k_1| \\left( \\int_{x_0 - \\epsilon}^{x_0} H_{\\epsilon}(\\phi(x))\\,dx + \\int_{x_0}^{x_0 + \\epsilon} (1 - H_{\\epsilon}(\\phi(x)))\\,dx \\right)\n$$\n我们进行变量替换 $u = \\phi(x) = x - x_0$，因此 $du = dx$。积分限分别变为 $[-\\epsilon, 0]$ 和 $[0, \\epsilon]$。\n$$\nL \\cdot E_{\\mathrm{prop}} = |k_2 - k_1| \\left( \\int_{-\\epsilon}^{0} H_{\\epsilon}(u)\\,du + \\int_{0}^{\\epsilon} (1 - H_{\\epsilon}(u))\\,du \\right)\n$$\n函数 $H_{\\epsilon}(u)$ 具有属性 $H_{\\epsilon}(u) + H_{\\epsilon}(-u) = 1$（对于 $|u| \\le \\epsilon$）。因此，$1 - H_{\\epsilon}(u) = H_{\\epsilon}(-u)$。第二个积分变为 $\\int_{0}^{\\epsilon} H_{\\epsilon}(-u)\\,du$。通过替换 $v = -u$，它变为 $\\int_{0}^{-\\epsilon} H_{\\epsilon}(v)(-dv) = \\int_{-\\epsilon}^{0} H_{\\epsilon}(v)\\,dv$，证明了这两个积分是相同的。我们只需要计算其中一个。\n$$\n\\int_{-\\epsilon}^{0} H_{\\epsilon}(u)\\,du = \\int_{-\\epsilon}^{0} \\dfrac{1}{2}\\left[1 + \\dfrac{u}{\\epsilon} + \\dfrac{1}{\\pi}\\sin\\!\\left(\\pi \\dfrac{u}{\\epsilon}\\right)\\right]\\,du\n$$\n其原函数为 $\\frac{1}{2} \\left[u + \\frac{u^2}{2\\epsilon} - \\frac{\\epsilon}{\\pi^2}\\cos\\left(\\pi \\frac{u}{\\epsilon}\\right)\\right]$。从 $-\\epsilon$到 $0$ 求值：\n$$\n= \\frac{1}{2} \\left[ \\left(0 + 0 - \\frac{\\epsilon}{\\pi^2}\\cos(0)\\right) - \\left(-\\epsilon + \\frac{(-\\epsilon)^2}{2\\epsilon} - \\frac{\\epsilon}{\\pi^2}\\cos(-\\pi)\\right) \\right]\n= \\frac{1}{2} \\left[ -\\frac{\\epsilon}{\\pi^2} - \\left(-\\epsilon + \\frac{\\epsilon}{2} + \\frac{\\epsilon}{\\pi^2}\\right) \\right]\n= \\frac{1}{2} \\left[ \\frac{\\epsilon}{2} - \\frac{2\\epsilon}{\\pi^2} \\right] = \\epsilon\\left(\\frac{1}{4} - \\frac{1}{\\pi^2}\\right)\n$$\n总积分是这个值的两倍：\n$$\nL \\cdot E_{\\mathrm{prop}} = |k_2 - k_1| \\cdot 2 \\epsilon\\left(\\frac{1}{4} - \\frac{1}{\\pi^2}\\right) = |k_2 - k_1| \\epsilon\\left(\\frac{1}{2} - \\frac{2}{\\pi^2}\\right)\n$$\n最后，平均绝对物性误差有解析解：\n$$\nE_{\\mathrm{prop}} = \\frac{|k_2 - k_1|\\epsilon}{L} \\left(\\frac{1}{2} - \\frac{2}{\\pi^2}\\right)\n$$\n\n**相对通量误差 ($E_{\\mathrm{flux}}$) 的计算**\n\n相对通量误差为 $E_{\\mathrm{flux}} = (q_{\\mathrm{smooth}} - q_{\\mathrm{exact}}) / |q_{\\mathrm{exact}}|$。$q_{\\mathrm{exact}}$ 的计算可以从提供的公式直接得出。$q_{\\mathrm{smooth}}$ 的计算需要评估平滑热导率剖面下的总热阻：\n$$\nR_{\\mathrm{smooth}} = \\int_{0}^{L} \\dfrac{dx}{k(\\phi(x))}\n$$\n根据 $H_{\\epsilon}(\\phi)$ 的定义，该积分被分解为三个部分：\n$$\nR_{\\mathrm{smooth}} = \\int_{0}^{x_0 - \\epsilon} \\frac{dx}{k_1} + \\int_{x_0 - \\epsilon}^{x_0 + \\epsilon} \\frac{dx}{k_1 + (k_2 - k_1)H_{\\epsilon}(x-x_0)} + \\int_{x_0 + \\epsilon}^{L} \\frac{dx}{k_2}\n$$\n第一和第三个积分是平凡的，代表纯材料区域的热阻：\n$$\nR_1 = \\frac{x_0 - \\epsilon}{k_1} \\quad \\text{and} \\quad R_2 = \\frac{L - (x_0 + \\epsilon)}{k_2}\n$$\n中间的积分，即扩散界面区域上的积分，由于被积函数分母的复杂性，没有简单的闭式解析解。\n$$\nR_{\\mathrm{mid}} = \\int_{x_0 - \\epsilon}^{x_0 + \\epsilon} \\frac{dx}{k_1 + (k_2 - k_1) \\frac{1}{2}\\left[1 + \\frac{x-x_0}{\\epsilon} + \\frac{1}{\\pi}\\sin\\!\\left(\\pi \\frac{x-x_0}{\\epsilon}\\right)\\right]}\n$$\n该积分必须使用数值积分来计算。通过变量替换为 $u=x-x_0$，积分简化为适合标准数值积分器的形式：\n$$\nR_{\\mathrm{mid}} = \\int_{-\\epsilon}^{\\epsilon} \\frac{du}{k_1 + (k_2 - k_1) H_{\\epsilon}(u)}\n$$\n总平滑热阻为 $R_{\\mathrm{smooth}} = R_1 + R_{\\mathrm{mid}} + R_2$。平滑通量为 $q_{\\mathrm{smooth}} = (T_{\\mathrm{hot}} - T_{\\mathrm{cold}}) / R_{\\mathrm{smooth}}$。然后根据这些量计算相对通量误差 $E_{\\mathrm{flux}}$。\n\n对于 $k_1 = k_2$ 的特殊情况，我们观察到 $k(\\phi(x)) = k_1 + (k_1-k_1)H_{\\epsilon}(\\phi(x)) = k_1$。平滑热导率与精确热导率 $k_1$ 相同。因此，$E_{\\mathrm{prop}} = 0$ 并且 $q_{\\mathrm{smooth}}=q_{\\mathrm{exact}}$，这意味着 $E_{\\mathrm{flux}} = 0$。这为实现提供了一致性检查（测试用例3）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes property and flux errors for a 1D steady heat conduction problem\n    with a smoothed interface, as specified in the problem statement.\n    \"\"\"\n    # Define the test cases from the problem statement:\n    # (L, x0, k1, k2, eps, Thot, Tcold)\n    test_cases = [\n        (1.0, 0.5, 0.6, 15.0, 0.01, 400.0, 300.0),\n        (1.0, 0.5, 0.1, 100.0, 0.001, 400.0, 300.0),\n        (1.0, 0.5, 1.0, 1.0, 0.2, 350.0, 300.0),\n        (1.0, 0.5, 0.2, 20.0, 0.3, 500.0, 300.0),\n        (1.0, 0.1, 10.0, 0.5, 0.05, 310.0, 300.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L, x0, k1, k2, eps, Thot, Tcold = case\n        \n        # --- Task 1: Compute Mean Absolute Property Error (E_prop) ---\n        # The analytical formula derived in the solution is used:\n        # E_prop = (|k2 - k1| * eps / L) * (1/2 - 2 / pi^2)\n        E_prop_factor = 0.5 - 2 / (np.pi**2)\n        E_prop = (np.abs(k2 - k1) * eps / L) * E_prop_factor\n        \n        # --- Task 2: Compute Relative Flux Error (E_flux) ---\n        \n        # Handle the degenerate case where k1 and k2 are identical.\n        # In this case, k_smooth = k_exact = k1, so both errors are zero.\n        if np.isclose(k1, k2):\n            E_flux = 0.0\n            results.extend([E_prop, E_flux])\n            continue\n        \n        # Handle the degenerate case of zero temperature difference.\n        if np.isclose(Thot, Tcold):\n            # Both q_exact and q_smooth are zero, so the error is zero.\n            E_flux = 0.0\n            results.extend([E_prop, E_flux])\n            continue\n\n        # Calculate q_exact using the sharp-interface thermal resistance.\n        R_exact = x0 / k1 + (L - x0) / k2\n        q_exact = (Thot - Tcold) / R_exact\n        \n        # Calculate q_smooth using numerical integration for the smoothed resistance.\n        \n        # Define the smoothed Heaviside function for the region |phi| = epsilon.\n        def H_eps_func(phi, epsilon):\n            phi_scaled = phi / epsilon\n            return 0.5 * (1.0 + phi_scaled + (1.0 / np.pi) * np.sin(np.pi * phi_scaled))\n            \n        # Define the integrand for the thermal resistance in the smoothed region.\n        # This is the reciprocal of the smoothed conductivity k(phi).\n        def resistance_integrand(phi, epsilon, k1, k2):\n            k_smooth = k1 + (k2 - k1) * H_eps_func(phi, epsilon)\n            return 1.0 / k_smooth\n            \n        # Numerically integrate to find the resistance of the smoothed region.\n        # The integration is over u = x - x0 from -eps to eps.\n        R_mid, _ = quad(resistance_integrand, -eps, eps, args=(eps, k1, k2))\n        \n        # Calculate the total thermal resistance for the smoothed case.\n        # It's the sum of resistances from the two pure-material regions and the\n        # numerically computed resistance of the smoothed interface region.\n        # The problem setup ensures x0-eps > 0 and x0+eps  L.\n        R_smooth_pure1 = (x0 - eps) / k1\n        R_smooth_pure2 = (L - (x0 + eps)) / k2\n        R_smooth = R_smooth_pure1 + R_mid + R_smooth_pure2\n        \n        q_smooth = (Thot - Tcold) / R_smooth\n        \n        # Calculate the final relative flux error.\n        E_flux = (q_smooth - q_exact) / np.abs(q_exact)\n        \n        results.extend([E_prop, E_flux])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12g}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "与水平集方法中的弥散表示相反，流体体积 (Volume-of-Fluid, VOF) 方法旨在维持一个尖锐的界面。现代 VOF 方法（如分段线性界面重构，PLIC）的一个核心任务是在每个计算单元内重构这个尖锐的界面。本实践  要求您实现一个基本的几何算法：在一个二维单元内找到一个平面界面的精确位置，使其与给定的流体体积分数 $F$ 完全匹配，这是实现精确界面追踪的关键一步。",
            "id": "3967973",
            "problem": "您的任务是在耦合水平集与流体体积 (Coupled Level-Set and Volume-of-Fluid, CLSVOF) 方法中，为一个二维控制体重构分段线性界面，并构建其中未知的平面常数。该二维控制体是一个方形单元，其左下角的位置向量为 $\\mathbf{r}_0 = (x_0,y_0)$，边长为 $L$ 米。单元内部的界面由平面水平集表示\n$$\n\\mathbf{n}\\cdot\\mathbf{x} = \\alpha,\n$$\n其中 $\\mathbf{n}=(n_x,n_y)$ 是一个非零法向量，根据水平集函数的梯度估计得出，$\\alpha$ 是一个以米为单位的标量。液体区域由半空间定义\n$$\n\\Omega_\\ell(\\alpha) = \\left\\{ \\mathbf{x}\\in \\mathbb{R}^2 \\ \\big|\\ \\mathbf{n}\\cdot \\mathbf{x} \\le \\alpha \\right\\}。\n$$\n根据第一性原理，单元内的流体体积分数 $F$（无量纲）由指示（亥维赛）函数的面积平均值定义，\n$$\nF \\;=\\; \\frac{1}{L^2}\\iint_{\\mathcal{C}} H\\!\\left(\\alpha - \\mathbf{n}\\cdot\\mathbf{x}\\right)\\, dA,\n$$\n其中 $\\mathcal{C}=\\left\\{(x,y)\\ \\big|\\ x_0\\le x\\le x_0+L,\\ y_0\\le y\\le y_0+L\\right\\}$ 是该单元，$H(\\cdot)$ 是亥维赛阶跃函数。给定局部的流体体积分数 $F$ 和一个基于梯度的界面法线估计值 $\\mathbf{n}$（其长度可能不是单位长度）。请构建 $\\alpha$，使得在给定的几何构型中，上述关于 $F$ 的定义精确成立。您必须：\n- 在重构之前将 $\\mathbf{n}$ 归一化为单位长度。\n- 将液体区域视为 $\\{\\mathbf{x}\\in\\mathcal{C}\\mid \\mathbf{n}\\cdot \\mathbf{x} \\le \\alpha\\}$。\n- 通过将 $\\alpha$ 分别设置为 $\\mathbf{n}\\cdot\\mathbf{x}$ 在单元角点上的最小值和最大值来处理 $F=0$ 和 $F=1$ 的边界情况。\n- 对于 $F\\in(0,1)$ 的情况，通过求解上述积分定义的非线性方程来计算 $\\alpha$，而不使用任何关于多边形面积作为 $\\alpha$ 函数的闭式快捷方法。使用半空间 $\\mathbf{n}\\cdot\\mathbf{x}\\le \\alpha$ 对方形单元进行几何裁剪，以精确计算任意试验 $\\alpha$ 下的面积，然后使用由单调性保证的区间求根方法来确定 $\\alpha$。\n\n对于每个测试用例，以米为单位表示最终的 $\\alpha$，并精确到 $8$ 位小数。\n\n您必须实现一个完整、可运行的程序，该程序：\n- 不接受任何输入，也不读取任何文件。\n- 仅使用 Python 标准库，以及（如果需要）指定的数值库。\n- 对于每个测试用例，按规定计算 $\\alpha$ 并将结果汇编成一个列表。\n\n请使用以下测试套件。每个测试用例都是一个元组 $(x_0,y_0,L,n_x,n_y,F)$，所有量均采用国际单位制 (SI)，其中 $L$ 和 $\\alpha$ 的单位为米，$F$ 为无量纲：\n- 测试 1：$(0.0,0.0,1.0,1.0,1.0,0.5)$。\n- 测试 2：$(0.0,0.0,1.0,0.3,0.95,0.0)$。\n- 测试 3：$(0.0,0.0,1.0,0.3,0.95,1.0)$。\n- 测试 4：$(1.0,2.0,2.0,-1.0,2.0,0.25)$。\n- 测试 5：$(0.0,0.0,1.0,10^{-6},1.0,0.3)$。\n- 测试 6：$(5.0,-3.0,1.0,1.0,1.0,0.5)$。\n- 测试 7：$(0.0,0.0,1.0,-1.0,-1.0,0.75)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的重构平面常数 $\\alpha$（单位为米，精确到 8 位小数）列表。例如，输出形式为\n$$\n[\\alpha_1,\\alpha_2,\\dots,\\alpha_7]\n$$\n其中每个 $\\alpha_k$ 以米为单位，并精确到 8 位小数。不应打印任何其他文本。",
            "solution": "该问题要求在一个方形计算单元内，为二维分段线性界面表示构建平面常数 $\\alpha$。这是计算流体动力学中的一项基本任务，特别是对于像耦合水平集与流体体积 (CLSVOF) 方法这样的界面捕捉方法。平面常数 $\\alpha$ 的确定必须使得单元内液体区域的面积（该区域由单元与半空间 $\\mathbf{n}\\cdot\\mathbf{x} \\le \\alpha$ 的交集定义）与给定的流体体积分数 (VOF) $F$ 完全对应。\n\nVOF 分数 $F$、单元几何形状、界面法线 $\\mathbf{n}$ 和平面常数 $\\alpha$ 之间的控制关系由液相指示函数在单元域 $\\mathcal{C}$ 上的积分给出：\n$$\nF = \\frac{1}{L^2} \\iint_{\\mathcal{C}} H(\\alpha - \\mathbf{n}\\cdot\\mathbf{x}) \\, dA\n$$\n此处，$\\mathcal{C}$ 是方形单元 $[x_0, x_0+L] \\times [y_0, y_0+L]$，面积为 $L^2$；$\\mathbf{n}$ 是界面法向量；$H(\\cdot)$ 是亥维赛阶跃函数。该积分计算液体区域的面积 $A(\\alpha) = \\text{Area}(\\{ \\mathbf{x} \\in \\mathcal{C} \\mid \\mathbf{n}\\cdot\\mathbf{x} \\le \\alpha \\})$，然后用单元总面积 $L^2$ 进行归一化。\n\n问题是在给定 $(x_0, y_0, L, n_x, n_y, F)$ 的情况下求 $\\alpha$。这可以重构为对以下函数的求根问题：\n$$\ng(\\alpha) = A(\\alpha) - F L^2 = 0\n$$\n\n求解方法如下：\n\n1.  **预处理**：按照规定，首先将给定的法向量 $\\mathbf{n}=(n_x, n_y)$ 归一化，以获得单位法向量 $\\hat{\\mathbf{n}}$：\n    $$\n    \\hat{\\mathbf{n}} = \\frac{\\mathbf{n}}{\\|\\mathbf{n}\\|} = \\frac{(n_x, n_y)}{\\sqrt{n_x^2 + n_y^2}}\n    $$\n    所有后续涉及法线的计算都将使用这个单位向量 $\\hat{\\mathbf{n}}$。\n\n2.  **界定解的范围**：函数 $\\hat{\\mathbf{n}}\\cdot\\mathbf{x}$ 是 $\\mathbf{x}=(x,y)$ 的线性函数，因此其在凸域 $\\mathcal{C}$ 上的极值必然出现在单元的顶点上。设单元的四个顶点为 $P_1, P_2, P_3, P_4$。我们可以为 $\\alpha$ 定义界限：\n    $$\n    \\alpha_{min} = \\min_{i=1,2,3,4} (\\hat{\\mathbf{n}} \\cdot P_i)\n    $$\n    $$\n    \\alpha_{max} = \\max_{i=1,2,3,4} (\\hat{\\mathbf{n}} \\cdot P_i)\n    $$\n    如果 $\\alpha  \\alpha_{min}$，分割线 $\\hat{\\mathbf{n}}\\cdot\\mathbf{x} = \\alpha$ 不与单元相交，液体面积 $A(\\alpha)$ 为 $0$。如果 $\\alpha \\ge \\alpha_{max}$，整个单元都浸没在液体区域中，因此 $A(\\alpha) = L^2$。因此，解 $\\alpha$ 必须位于区间 $[\\alpha_{min}, \\alpha_{max}]$ 内。\n\n3.  **边界情况**：问题规定了边界 VOF 分数的处理方式：\n    - 如果 $F=0$，液体面积为零。这对应于区间的下界，因此我们设置 $\\alpha = \\alpha_{min}$。\n    - 如果 $F=1$，整个单元都是液体。这对应于区间的上界，因此我们设置 $\\alpha = \\alpha_{max}$。\n\n4.  **对于 $F \\in (0,1)$ 的求根**：对于中间的 VOF 分数，我们必须求解 $g(\\alpha)=0$。液体面积函数 $A(\\alpha)$ 是关于 $\\alpha$ 单调不减的。这确保了 $g(\\alpha)$ 也是单调的，从而保证在区间 $[\\alpha_{min}, \\alpha_{max}]$ 内有唯一根。因此，使用区间法是合适的。我们将因其简单性和稳健性而使用二分法。\n    二分法算法以区间 $[\\alpha_{low}, \\alpha_{high}] = [\\alpha_{min}, \\alpha_{max}]$ 进行初始化。在每次迭代中，选择一个中点 $\\alpha_{mid} = (\\alpha_{low} + \\alpha_{high}) / 2$。计算面积 $A(\\alpha_{mid})$。\n    - 如果 $A(\\alpha_{mid})  F L^2$，则试验面积太小，意味着 $\\alpha_{mid}$ 太小。更新下界：$\\alpha_{low} = \\alpha_{mid}$。\n    - 否则，试验面积太大或恰好正确，因此 $\\alpha_{mid}$ 是一个潜在的或过大的值。更新上界：$\\alpha_{high} = \\alpha_{mid}$。\n    重复此过程足够多的迭代次数，以达到高精度。\n\n5.  **几何面积计算**：问题的核心是计算给定试验 $\\alpha$ 的 $A(\\alpha)$，这必须通过几何裁剪完成，而不依赖于预先推导的解析公式。这包括两个步骤：\n    a. **多边形裁剪**：液体面积是通过将方形单元 $\\mathcal{C}$ 与半平面 $\\hat{\\mathbf{n}}\\cdot\\mathbf{x} \\le \\alpha$ 相交而形成的多边形的面积。我们使用 Sutherland-Hodgman 算法进行此裁剪过程。方形单元（由其四个有序顶点表示）是“主体多边形”。半平面定义了裁剪边界。该算法处理主体多边形的每条边，生成构成裁剪后多边形的新顶点列表。对于端点为 $S$ 和 $E$ 的边，算法根据 $S$ 和 $E$ 是否在半平面内（即，满足 $\\hat{\\mathbf{n}}\\cdot\\mathbf{x} - \\alpha \\le 0$）来输出顶点。当一条边穿过边界线 $\\hat{\\mathbf{n}}\\cdot\\mathbf{x} = \\alpha$ 时，计算交点 $I$ 并将其添加到新的顶点列表中。$S$ 和 $E$ 之间的线段与该直线的交点可以通过将线段参数化为 $P(t) = S+t(E-S)$（其中 $t\\in[0,1]$）并求解 $t$ 来找到：\n    $$\n    t = \\frac{\\alpha - \\hat{\\mathbf{n}} \\cdot S}{\\hat{\\mathbf{n}} \\cdot (E - S)}\n    $$\n    b. **多边形面积**：一旦确定了裁剪后多边形的顶点，就使用鞋带公式计算其面积。对于一个具有 $k$ 个顺序排列的顶点 $(x_1, y_1), (x_2, y_2), \\dots, (x_k, y_k)$ 的多边形，其面积为：\n    $$\n    A = \\frac{1}{2} \\left| \\sum_{i=1}^{k} (x_i y_{i+1} - x_{i+1} y_i) \\right|\n    $$\n    其中 $(x_{k+1}, y_{k+1})$ 被视为 $(x_1, y_1)$。\n\n    通过整合这些组件，我们构建了一个稳健的程序，可以为任何有效的输入集找到 $\\alpha$。最终的程序为每个提供的测试用例实现了这一逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    # Test cases: (x0, y0, L, nx, ny, F)\n    test_cases = [\n        (0.0, 0.0, 1.0, 1.0, 1.0, 0.5),\n        (0.0, 0.0, 1.0, 0.3, 0.95, 0.0),\n        (0.0, 0.0, 1.0, 0.3, 0.95, 1.0),\n        (1.0, 2.0, 2.0, -1.0, 2.0, 0.25),\n        (0.0, 0.0, 1.0, 1e-6, 1.0, 0.3),\n        (5.0, -3.0, 1.0, 1.0, 1.0, 0.5),\n        (0.0, 0.0, 1.0, -1.0, -1.0, 0.75),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha = reconstruct_alpha(*case)\n        results.append(f\"{alpha:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef polygon_area(vertices):\n    \"\"\"\n    Calculates the area of a polygon using the Shoelace formula.\n    Assumes vertices are ordered (e.g., counter-clockwise).\n    \"\"\"\n    if len(vertices)  3:\n        return 0.0\n    \n    verts_array = np.array(vertices)\n    x = verts_array[:, 0]\n    y = verts_array[:, 1]\n    \n    # Use np.roll to cycle the arrays for the shoelace formula\n    area = 0.5 * np.abs(np.dot(x, np.roll(y, -1)) - np.dot(y, np.roll(x, -1)))\n    return area\n\ndef clip_polygon(subject_polygon, n_unit, alpha):\n    \"\"\"\n    Clips a convex polygon against the half-plane n_unit . x - alpha = 0.\n    Implementation of the Sutherland-Hodgman algorithm for a single clipping plane.\n    \"\"\"\n    clipped_vertices = []\n    num_vertices = len(subject_polygon)\n\n    for i in range(num_vertices):\n        start_point = subject_polygon[i]\n        end_point = subject_polygon[(i + 1) % num_vertices]\n\n        # Evaluate the half-plane condition g(x) = n . x - alpha\n        g_start = np.dot(n_unit, start_point) - alpha\n        g_end = np.dot(n_unit, end_point) - alpha\n        \n        is_start_inside = g_start = 0\n        is_end_inside = g_end = 0\n\n        # Case 1: Both vertices are inside\n        if is_start_inside and is_end_inside:\n            clipped_vertices.append(end_point)\n        # Case 2: Start is inside, End is outside\n        elif is_start_inside and not is_end_inside:\n            # Calculate intersection\n            # Denominator should not be zero unless edge is parallel to the line\n            denominator = np.dot(n_unit, end_point - start_point)\n            if abs(denominator) > 1e-15:\n                t = (alpha - np.dot(n_unit, start_point)) / denominator\n                intersection = start_point + t * (end_point - start_point)\n                clipped_vertices.append(intersection)\n        # Case 3: Both vertices are outside - do nothing\n        elif not is_start_inside and not is_end_inside:\n            pass\n        # Case 4: Start is outside, End is inside\n        elif not is_start_inside and is_end_inside:\n            # Calculate intersection\n            denominator = np.dot(n_unit, end_point - start_point)\n            if abs(denominator) > 1e-15:\n                t = (alpha - np.dot(n_unit, start_point)) / denominator\n                intersection = start_point + t * (end_point - start_point)\n                clipped_vertices.append(intersection)\n            clipped_vertices.append(end_point)\n    \n    return clipped_vertices\n\ndef reconstruct_alpha(x0, y0, L, nx, ny, F):\n    \"\"\"\n    Computes the plane constant alpha for a single test case.\n    \"\"\"\n    n_vec = np.array([nx, ny])\n    norm_n = np.linalg.norm(n_vec)\n    \n    # Per problem, n is non-zero so norm_n > 0\n    n_unit = n_vec / norm_n\n\n    # Define cell vertices\n    corners = [\n        np.array([x0, y0]),\n        np.array([x0 + L, y0]),\n        np.array([x0 + L, y0 + L]),\n        np.array([x0, y0 + L]),\n    ]\n\n    # Find bracketing values for alpha\n    dot_products = [np.dot(n_unit, p) for p in corners]\n    alpha_min = min(dot_products)\n    alpha_max = max(dot_products)\n\n    # Handle boundary cases F=0 and F=1\n    if F = 1e-9: # Use a tolerance for floating point comparison\n        return alpha_min\n    if F >= 1.0 - 1e-9:\n        return alpha_max\n\n    target_area = F * L**2\n\n    # Bisection method to find alpha\n    alpha_low = alpha_min\n    alpha_high = alpha_max\n    \n    # 100 iterations are more than sufficient for double precision\n    for _ in range(100):\n        alpha_mid = (alpha_low + alpha_high) / 2.0\n        \n        # Calculate area for the current alpha_mid\n        clipped_poly = clip_polygon(corners, n_unit, alpha_mid)\n        current_area = polygon_area(clipped_poly)\n        \n        if current_area  target_area:\n            alpha_low = alpha_mid\n        else:\n            alpha_high = alpha_mid\n            \n    return (alpha_low + alpha_high) / 2.0\n\nsolve()\n```"
        },
        {
            "introduction": "耦合水平集与流体体积 (CLSVOF) 方法结合了两种方法的优点：利用水平集函数 $\\phi$ 的光滑几何信息和流体体积函数 $F$ 的质量守恒特性。这个综合性练习  将指导您为一个真实的相变问题实现一个完整的 CLSVOF 更新步骤。您将处理 $\\phi$ 和 $F$ 的对流、水平集场的关键重初始化过程，并评估该方法的守恒性和一致性，从而将 CLSVOF 算法的所有核心组件融会贯通。",
            "id": "3967984",
            "problem": "你需要实现耦合水平集-流体体积 (CLSVOF) 方法的一个显式单步更新，该更新适用于正在经历相变的二维界面，适合计算热工学领域的高级研究生学习。耦合水平集-流体体积 (CLSVOF) 方法结合了用于将界面表示为有符号距离函数的水平集函数 $ \\phi $ 和用于确保输运相分数守恒的流体体积分数 $ F \\in [0,1] $。更新必须使用一个扩展速度场来平流与相变一致的 $ \\phi $，而 $ F $ 的更新必须是守恒的。\n\n该更新步骤基于以下基本定律和定义：\n\n- 水平集平流方程为 $ \\partial \\phi / \\partial t + \\mathbf{u}_{\\text{ext}} \\cdot \\nabla \\phi = 0 $，其中 $ \\mathbf{u}_{\\text{ext}} $ 是一个扩展速度，其定义为沿界面法线方向移动界面，与相变保持一致。\n- 流体体积守恒定律为 $ \\partial F / \\partial t + \\nabla \\cdot (F \\mathbf{u}_{\\text{ext}}) = 0 $，该方程必须被离散化以确保 $ F $ 的守恒。\n- 扩展速度定义为 $ \\mathbf{u}_{\\text{ext}} = V_n \\, \\mathbf{n} $，其中 $ \\mathbf{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert $ 是界面的单位法向量，$ V_n $ 是来自单相 Stefan 条件的法向界面速度。对于传导驱动的相变，Stefan 条件为 $ \\rho L V_n = ( \\mathbf{q}_\\ell - \\mathbf{q}_s ) \\cdot \\mathbf{n} $，其中 $ \\rho $ 是密度，$ L $ 是潜热，$ \\mathbf{q}_\\ell = -k_\\ell \\nabla T_\\ell $ 是液相热通量，$ \\mathbf{q}_s = -k_s \\nabla T_s $ 是固相热通量。对于本问题，使用符号约定 $ V_n = ( k_\\ell \\nabla T_\\ell - k_s \\nabla T_s ) \\cdot \\mathbf{n} / ( \\rho L ) $。\n- 平流后将 $ \\phi $ 重新初始化为有符号距离函数是通过在一个短的伪时间 $ \\tau $ 内积分重新初始化方程 $ \\partial \\phi / \\partial \\tau + S_\\epsilon(\\phi_0)( \\lVert \\nabla \\phi \\rVert - 1 ) = 0 $ 来完成的，其中 $ \\phi_0 $ 是重新初始化前的场，$ S_\\epsilon(\\phi_0) = \\phi_0 / \\sqrt{ \\phi_0^2 + \\epsilon^2 } $ 是一个正则化的符号函数。需要进行重新初始化以保持有符号距离特性，从而进行精确的法向量计算。\n\n你必须在一个程序中实现以下内容：\n\n- 考虑一个方形域 $ [0,1] \\times [0,1] $，在两个坐标方向上都有周期性边界条件。网格分辨率为 $ N_x = 64 $，$ N_y = 64 $，均匀间距为 $ \\Delta x = 1/N_x $ 和 $ \\Delta y = 1/N_y $。所有空间维度以米为单位，因此 $ \\Delta x $ 和 $ \\Delta y $ 的单位是米。\n- 将水平集 $ \\phi(x,y) $ 初始化为距离一个半径为 $ R = 0.25 $ 米、圆心位于 $ (x_c, y_c) = (0.5, 0.5) $ 米的圆的有符号距离。圆内 $ \\phi  0 $，圆外 $ \\phi  0 $。流体体积分数 $ F $ 必须初始化为 $ \\phi $ 的平滑亥维赛德函数 $ F = H_\\epsilon(\\phi) $，其中 $ \\epsilon = 2 \\Delta x $，$ H_\\epsilon(\\phi) = 0 $ 如果 $ \\phi \\le -\\epsilon $，$ H_\\epsilon(\\phi) = 1 $ 如果 $ \\phi \\ge \\epsilon $，否则 $ H_\\epsilon(\\phi) = \\frac{1}{2}\\left( 1 + \\frac{\\phi}{\\epsilon} + \\frac{1}{\\pi} \\sin \\left( \\frac{\\pi \\phi}{\\epsilon} \\right) \\right) $。\n- 定义恒定的材料属性：$ \\rho = 1000 \\, \\mathrm{kg/m^3} $，$ L = 3.34 \\times 10^5 \\, \\mathrm{J/kg} $，$ k_s = 1.0 \\, \\mathrm{W/(m\\cdot K)} $，$ k_\\ell = 2.0 \\, \\mathrm{W/(m\\cdot K)} $。\n- 对于每个测试用例，定义解析温度梯度 $ \\nabla T_s = (\\alpha, 0) $ 和 $ \\nabla T_\\ell = (-\\alpha, 0) $（单位为开尔文/米），其中 $ \\alpha $ 由测试套件指定。使用当前从 $ \\phi $ 得到的 $ \\mathbf{n} $，逐点计算界面法向速度 $ V_n = \\left( k_\\ell \\nabla T_\\ell - k_s \\nabla T_s \\right) \\cdot \\mathbf{n} / (\\rho L) $。然后设置 $ \\mathbf{u}_{\\text{ext}} = V_n \\, \\mathbf{n} $。没有整体流动，只有相变引起的运动，因此 $ \\mathbf{u}_{\\text{ext}} $ 是纯法向的。\n- 根据 Courant–Friedrichs–Lewy (CFL) 条件 $ \\Delta t = \\mathrm{CFL} \\cdot \\min(\\Delta x, \\Delta y) / \\max_{i,j} \\lVert \\mathbf{u}_{\\text{ext}} \\rVert $ 计算稳定时间步长，其中 $ \\mathrm{CFL} = 0.5 $。如果 $ \\max \\lVert \\mathbf{u}_{\\text{ext}} \\rVert = 0 $，则使用 $ \\Delta t = \\mathrm{CFL} \\cdot \\min(\\Delta x, \\Delta y) / 10^{-12} $ 以避免除以零。时间单位为秒。\n- 使用 $ \\partial \\phi / \\partial t + \\mathbf{u}_{\\text{ext}} \\cdot \\nabla \\phi = 0 $ 的显式一阶迎风离散和两个方向的周期性边界条件来更新 $ \\phi $。\n- 通过使用针对 $ \\lVert \\nabla \\phi \\rVert $ 的 Godunov 型离散和 $ S_\\epsilon(\\phi_0) $（其中 $ \\epsilon = \\Delta x $），在一个小的伪时间内积分重新初始化方程，将 $ \\phi $ 重新初始化为有符号距离函数。使用至少 $ 15 $ 个伪时间步，步长为 $ \\Delta \\tau = 0.3 \\min(\\Delta x, \\Delta y) $。\n- 使用应用于 $ \\partial F / \\partial t + \\nabla \\cdot (F \\mathbf{u}_{\\text{ext}}) = 0 $ 的守恒有限体积迎风通量法并结合周期性边界条件来更新 $ F $，确保离散更新在数值舍入误差范围内保持 $ F $ 的总积分守恒。不要裁剪 $ F $；而是测量任何对 $ F \\in [0,1] $ 的违反情况。\n- 更新后，为每个测试用例计算以下指标：\n    1. $ m_0 = \\left| \\sum_{i,j} F^{n+1}_{i,j} - \\sum_{i,j} F^{n}_{i,j} \\right| $，$ F $ 的无量纲离散守恒误差。\n    2. $ m_1 = \\sum_{i,j} \\max(0, F^{n+1}_{i,j} - 1) + \\sum_{i,j} \\max(0, -F^{n+1}_{i,j}) $，一个衡量对物理边界 $ F \\in [0,1] $ 违反程度的无量纲量。\n    3. $ m_2 = \\sqrt{ \\frac{1}{N_x N_y} \\sum_{i,j} \\left( H_\\epsilon(\\phi^{n+1}_{i,j}) - F^{n+1}_{i,j} \\right)^2 } $，更新后的 $ F $ 和更新后的 $ \\phi $ 的平滑亥维赛德函数之间的无量纲均方根一致性误差，使用与上述相同的 $ \\epsilon $。\n- 通过将 $ \\alpha $ 设置为三个不同的值来实现以下测试套件：\n    - 测试用例 A: $ \\alpha = 0.0 $。\n    - 测试用例 B: $ \\alpha = 1.0 $。\n    - 测试用例 C: $ \\alpha = 5.0 $。\n- 你的程序应生成单行输出，包含九个标量结果 $ [m_0^\\mathrm{A}, m_1^\\mathrm{A}, m_2^\\mathrm{A}, m_0^\\mathrm{B}, m_1^\\mathrm{B}, m_2^\\mathrm{B}, m_0^\\mathrm{C}, m_1^\\mathrm{C}, m_2^\\mathrm{C}] $，形式为用方括号括起来的逗号分隔列表，其中每个条目表示为无单位的小数。\n\n所有物理参数必须使用正确的单位：长度单位为米，时间单位为秒，密度单位为千克/立方米，导热系数单位为瓦特/（米·开尔文），潜热单位为焦耳/千克，温度梯度单位为开尔文/米。不使用角度。算法必须从给定的基本定律开始，除了标准的数值离散化之外，不应引入捷径或预先推导的公式。测试套件确保覆盖零相变速度、中等法向速度和较大法向速度的情况。程序必须是完全自包含的，并且不需要任何输入。",
            "solution": "用户提供了一个有效的问题陈述，要求实现耦合水平集-流体体积 (CLSVOF) 方法在二维相变场景下的单步更新。该问题在计算热工学领域具有科学依据，问题设定良好且客观。所有必要的方程、参数和数值方法都已指定。我将着手提供一个完整的解决方案。\n\n对于每个测试用例，实现将遵循一系列不同的步骤：\n1.  **初始化**：一个大小为 $1 \\times 1$ 的方形计算域被离散化为一个 $64 \\times 64$ 的网格。水平集函数 $\\phi$ 被初始化为一个到以 $(0.5, 0.5)$ 为中心、半径为 $R=0.25$ 的圆的有符号距离函数。流体体积分数 $F$ 被初始化为 $\\phi$ 的一个正则化亥维赛德函数，记作 $H_\\epsilon(\\phi)$，平滑宽度为 $\\epsilon = 2\\Delta x$。\n2.  **速度场计算**：计算驱动界面运动的扩展速度场 $\\mathbf{u}_{\\text{ext}}$。该速度垂直于界面，即 $\\mathbf{u}_{\\text{ext}} = V_n \\mathbf{n}$。\n    -   单位法向量 $\\mathbf{n} = \\nabla\\phi / \\lVert \\nabla\\phi \\rVert$ 是通过使用二阶中心差分计算梯度 $\\nabla\\phi$ 从水平集场中计算出来的。强制执行周期性边界条件。为防止除以零，在分母上增加一个小的容差。\n    -   法向速度 $V_n$ 由 Stefan 条件确定，$V_n = ( k_\\ell \\nabla T_\\ell - k_s \\nabla T_s ) \\cdot \\mathbf{n} / (\\rho L)$。问题指定了恒定的温度梯度 $\\nabla T_s = (\\alpha, 0)$ 和 $\\nabla T_\\ell = (-\\alpha, 0)$，这使得表达式简化为 $V_n = -(k_\\ell + k_s)\\alpha n_x / (\\rho L)$，其中 $n_x$ 是法向量的 x 分量。\n3.  **时间步长确定**：使用 Courant–Friedrichs–Lewy (CFL) 条件计算一个稳定的时间步长 $\\Delta t$：$\\Delta t = \\mathrm{CFL} \\cdot \\min(\\Delta x, \\Delta y) / \\max \\lVert \\mathbf{u}_{\\text{ext}} \\rVert$，其中 $\\mathrm{CFL} = 0.5$。\n4.  **水平集平流**：水平集函数 $\\phi$ 根据 $\\partial \\phi / \\partial t + \\mathbf{u}_{\\text{ext}} \\cdot \\nabla \\phi = 0$ 进行时间推进。该方程使用显式一阶迎风格式进行离散。空间导数 $\\nabla \\phi$ 使用单边差分进行近似，差分方向根据每个网格单元中速度分量的符号选择，以确保数值稳定性。\n5.  **水平集重新初始化**：平流后，$\\phi$ 场可能不再是一个有符号距离函数。通过求解方程 $\\partial \\phi / \\partial \\tau + S_\\epsilon(\\phi_0)( \\lVert \\nabla \\phi \\rVert - 1 ) = 0$ 进行多个伪时间步 $\\tau$ 的演化来重新初始化它。这里，$\\phi_0$ 是平流后的水平集场，$S_\\epsilon$ 是一个平滑的符号函数，它使零水平集保持静止。Hamilton-Jacobi 项 $\\lVert \\nabla \\phi \\rVert$ 使用 Godunov 型迎风格式进行离散，这对此类问题是标准做法，它根据信息传播的方向（由 $S_\\epsilon(\\phi_0)$ 指示）选择合适的单边差分。\n6.  **流体体积分数平流**：通过求解守恒定律 $\\partial F / \\partial t + \\nabla \\cdot (F \\mathbf{u}_{\\text{ext}}) = 0$ 来更新流体体积分数 $F$。使用守恒的有限体积法。穿过每个单元面的通量 $F \\mathbf{u}_{\\text{ext}}$ 使用一阶迎风格式计算。单元面上的 $F$ 值取自上风单元，由该面上法向速度的符号确定。这种离散化确保了流体的总体积 $\\sum F_{i,j}$ 在机器精度范围内是守恒的。\n7.  **指标计算**：最后，计算三个指定的指标来评估更新步骤的性能：\n    -   $m_0$：离散守恒误差，计算为更新前后 $F$ 值总和的绝对差。\n    -   $m_1$：对边界 $F \\in [0,1]$ 违反情况的总和。\n    -   $m_2$：衡量更新后的 $F$ 场与更新后的 $\\phi$ 场的亥维赛德函数之间一致性的均方根误差。\n\n对于参数 $\\alpha$ 的三个指定值，重复整个过程，该参数控制相变速度的大小。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a single explicit update step of the Coupled Level-Set Volume-of-Fluid (CLSVOF)\n    method for a two-dimensional interface undergoing phase change.\n    \"\"\"\n\n    def heaviside_smooth(phi, epsilon):\n        \"\"\"\n        Computes the smoothed Heaviside function H_epsilon(phi).\n        \"\"\"\n        F = np.zeros_like(phi)\n        mask = np.abs(phi) = epsilon\n        phi_masked = phi[mask]\n        F[mask] = 0.5 * (1 + phi_masked / epsilon + (1 / np.pi) * np.sin(np.pi * phi_masked / epsilon))\n        F[phi > epsilon] = 1.0\n        F[phi  -epsilon] = 0.0\n        return F\n\n    def sign_smooth(phi, epsilon):\n        \"\"\"\n        Computes the regularized sign function S_epsilon(phi).\n        \"\"\"\n        return phi / np.sqrt(phi**2 + epsilon**2)\n\n    def run_case(alpha, Nx, Ny, R, x_c, y_c, rho, L, ks, kl):\n        \"\"\"\n        Executes the full CLSVOF update step for a given test case alpha.\n        \"\"\"\n        # --- 1. Initialization ---\n        dx = 1.0 / Nx\n        dy = 1.0 / Ny\n        x = np.linspace(0.5 * dx, 1.0 - 0.5 * dx, Nx)\n        y = np.linspace(0.5 * dy, 1.0 - 0.5 * dy, Ny)\n        xx, yy = np.meshgrid(x, y)\n\n        phi = np.sqrt((xx - x_c)**2 + (yy - y_c)**2) - R\n        eps_H = 2.0 * dx\n        F_initial = heaviside_smooth(phi, eps_H)\n        \n        sum_F_initial = np.sum(F_initial)\n        F = F_initial.copy()\n        \n        # --- 2. Velocity Field Calculation ---\n        grad_phi_x = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * dx)\n        grad_phi_y = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2.0 * dy)\n        norm_grad_phi = np.sqrt(grad_phi_x**2 + grad_phi_y**2)\n        \n        nx = grad_phi_x / (norm_grad_phi + 1e-12)\n        ny = grad_phi_y / (norm_grad_phi + 1e-12)\n\n        Vn = -(kl + ks) * alpha * nx / (rho * L)\n        u_ext_x = Vn * nx\n        u_ext_y = Vn * ny\n\n        # --- 3. Time Step Determination ---\n        max_vel = np.max(np.sqrt(u_ext_x**2 + u_ext_y**2))\n        CFL = 0.5\n        dt = CFL * min(dx, dy) / (max_vel if max_vel > 1e-15 else 1e-12)\n\n        # --- 4. Level-Set Advection ---\n        phi_dx_b = (phi - np.roll(phi, 1, axis=1)) / dx\n        phi_dx_f = (np.roll(phi, -1, axis=1) - phi) / dx\n        phi_dy_b = (phi - np.roll(phi, 1, axis=0)) / dy\n        phi_dy_f = (np.roll(phi, -1, axis=0) - phi) / dy\n        \n        advection_term = (np.maximum(u_ext_x, 0) * phi_dx_b + np.minimum(u_ext_x, 0) * phi_dx_f +\n                          np.maximum(u_ext_y, 0) * phi_dy_b + np.minimum(u_ext_y, 0) * phi_dy_f)\n        phi_advected = phi - dt * advection_term\n\n        # --- 5. Level-Set Reinitialization ---\n        phi_reinit = phi_advected.copy()\n        phi_0 = phi_advected.copy()\n        eps_reinit = dx\n        dtau = 0.3 * min(dx, dy)\n        num_reinit_steps = 15\n        \n        sign_phi0 = sign_smooth(phi_0, eps_reinit)\n\n        for _ in range(num_reinit_steps):\n            phi_x_m = (phi_reinit - np.roll(phi_reinit, 1, axis=1)) / dx\n            phi_x_p = (np.roll(phi_reinit, -1, axis=1) - phi_reinit) / dx\n            phi_y_m = (phi_reinit - np.roll(phi_reinit, 1, axis=0)) / dy\n            phi_y_p = (np.roll(phi_reinit, -1, axis=0) - phi_reinit) / dy\n\n            grad_phi_mag_sq = np.zeros_like(phi_reinit)\n            \n            mask_pos = sign_phi0 > 0\n            term_x_sq_pos = np.maximum(np.maximum(phi_x_m[mask_pos], 0)**2, np.minimum(phi_x_p[mask_pos], 0)**2)\n            term_y_sq_pos = np.maximum(np.maximum(phi_y_m[mask_pos], 0)**2, np.minimum(phi_y_p[mask_pos], 0)**2)\n            grad_phi_mag_sq[mask_pos] = term_x_sq_pos + term_y_sq_pos\n            \n            mask_neg = sign_phi0  0\n            term_x_sq_neg = np.maximum(np.minimum(phi_x_m[mask_neg], 0)**2, np.maximum(phi_x_p[mask_neg], 0)**2)\n            term_y_sq_neg = np.maximum(np.minimum(phi_y_m[mask_neg], 0)**2, np.maximum(phi_y_p[mask_neg], 0)**2)\n            grad_phi_mag_sq[mask_neg] = term_x_sq_neg + term_y_sq_neg\n\n            grad_phi_mag = np.sqrt(grad_phi_mag_sq)\n            phi_reinit -= dtau * sign_phi0 * (grad_phi_mag - 1)\n        \n        phi_final = phi_reinit\n\n        # --- 6. Volume-of-Fluid Advection ---\n        u_face_x = (u_ext_x + np.roll(u_ext_x, -1, axis=1)) / 2.0\n        u_face_y = (u_ext_y + np.roll(u_ext_y, -1, axis=0)) / 2.0\n\n        flux_x = np.maximum(u_face_x, 0) * F + np.minimum(u_face_x, 0) * np.roll(F, -1, axis=1)\n        flux_y = np.maximum(u_face_y, 0) * F + np.minimum(u_face_y, 0) * np.roll(F, -1, axis=0)\n\n        div_flux_x = (flux_x - np.roll(flux_x, 1, axis=1)) / dx\n        div_flux_y = (flux_y - np.roll(flux_y, 1, axis=0)) / dy\n        \n        F_final = F - dt * (div_flux_x + div_flux_y)\n\n        # --- 7. Metric Calculation ---\n        sum_F_final = np.sum(F_final)\n        m0 = np.abs(sum_F_final - sum_F_initial)\n        m1 = np.sum(np.maximum(0, F_final - 1.0)) + np.sum(np.maximum(0, -F_final))\n        F_from_phi_final = heaviside_smooth(phi_final, eps_H)\n        m2 = np.sqrt(np.mean((F_from_phi_final - F_final)**2))\n        \n        return m0, m1, m2\n\n    # Define constants and test cases\n    Nx, Ny = 64, 64\n    R, x_c, y_c = 0.25, 0.5, 0.5\n    rho = 1000.0\n    L = 3.34e5\n    ks = 1.0\n    kl = 2.0\n    \n    test_cases_alpha = [0.0, 1.0, 5.0]\n    results = []\n\n    for alpha in test_cases_alpha:\n        m0, m1, m2 = run_case(alpha, Nx, Ny, R, x_c, y_c, rho, L, ks, kl)\n        results.extend([m0, m1, m2])\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}