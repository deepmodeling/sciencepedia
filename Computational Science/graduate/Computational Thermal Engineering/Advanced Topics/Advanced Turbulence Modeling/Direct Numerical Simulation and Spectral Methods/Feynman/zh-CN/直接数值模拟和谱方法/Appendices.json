{
    "hands_on_practices": [
        {
            "introduction": "许多实际的传热和流体问题，例如管道流和电子设备散热，都涉及固体壁面，这需要不同于周期性边界的处理方法。对于这类有界区域问题，切比雪夫多项式和配置法是标准的谱方法。这个练习  将指导您构建一个切比雪夫微分矩阵，并用它来精确计算边界上的物理量，例如壁面热通量，这是求解壁湍流直接数值模拟中的一项核心技能。",
            "id": "3946956",
            "problem": "考虑一个无量纲的一维导热域 $y \\in [-1,1]$，其热导率设为1。根据傅里叶热传导定律，垂直于壁面的热通量由 $q_y(y) = -\\partial_y T(y)$ 给出。在使用谱方法的直接数值模拟中，Chebyshev–Gauss–Lobatto 配置法是近似导数的一种标准方法。Chebyshev–Gauss–Lobatto 节点为 $y_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j = 0,1,\\dots,N$，$N$ 是多项式阶数。定义交替权重 $c_j = (-1)^j \\, w_j$，其中 $w_0 = w_N = 2$ 且当 $1 \\le j \\le N-1$ 时 $w_j = 1$。Chebyshev 一阶微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 满足\n$$\nD_{ij} = \\begin{cases}\n\\frac{c_i}{c_j} \\, \\frac{1}{y_i - y_j},  i \\ne j, \\\\\n-\\sum_{k\\ne i} D_{ik},  i = j,\n\\end{cases}\n$$\n由此可得谱配置近似 $\\left.\\frac{dT}{dy}\\right|_{y=y_i} \\approx \\sum_{j=0}^{N} D_{ij} \\, T(y_j)$，其中 $i=0,\\dots,N$。\n\n你的任务是实现一个程序，该程序能为给定的 $N$ 构建矩阵 $D$，在 Chebyshev–Gauss–Lobatto 节点上计算指定的解析温度分布 $T(y)$，通过矩阵-向量乘法在所有节点上计算 $\\partial_y T$ 的谱近似，提取壁面 $y=+1$ 和 $y=-1$ 处的壁面法向热通量，并将其与从 $T(y)$ 的已知导数得到的精确解析通量进行比较。热导率为1，因此请以无量纲单位报告通量和误差。所有的三角函数求值必须使用弧度作为角度单位。对于每个测试用例，报告的数值误差必须是 $y=+1$ 和 $y=-1$ 处绝对误差的最大值，即\n$$\n\\varepsilon = \\max\\left( \\left| q_y^{\\text{num}}(+1) - q_y^{\\text{exact}}(+1) \\right|, \\, \\left| q_y^{\\text{num}}(-1) - q_y^{\\text{exact}}(-1) \\right| \\right),\n$$\n其中 $q_y^{\\text{num}}(\\pm 1)$ 通过 Chebyshev 微分得到，$q_y^{\\text{exact}}(\\pm 1)$ 通过解析导数得到。\n\n使用以下测试套件，它涵盖了一组具有代表性的解析分布和分辨率：\n- 案例1 (多项式，理想情况): $T(y) = y^4$, $N=8$。\n- 案例2 (指数函数，中等梯度): $T(y) = \\exp(3 y)$, $N=24$。\n- 案例3 (双曲余弦，中等分辨率): $T(y) = \\cosh(5 y)$, $N=16$。\n- 案例4 (正弦函数，弧度，较小的 N): $T(y) = \\sin(\\pi y)$, $N=8$。\n- 案例5 (指数函数，陡峭梯度): $T(y) = \\exp(10 y)$, $N=32$。\n\n对于每个案例，计算并返回如上定义的单个浮点数 $\\varepsilon$。你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表 (例如，$[result_1,result_2,\\dots]$)。由于所有量都是无量纲的，输出中不需要物理单位；角度在整个计算过程中必须以弧度处理。",
            "solution": "该问题是有效的，因为它基于傅里叶热传导定律的原理以及成熟的 Chebyshev 谱配置数值技术，具有科学依据。该问题是适定的、客观的，并包含了推导出唯一、可验证解所需的所有信息。我们着手进行求解。\n\n问题的核心是使用 Chebyshev 谱方法计算一维域 $y \\in [-1, 1]$ 边界上的温度梯度 $\\partial_y T$，并将所得热通量与精确解析解进行比较。在热导率为1的情况下，根据傅里叶定律，热通量定义为 $q_y(y) = -\\partial_y T(y)$。\n\n**步骤1：使用 Chebyshev–Gauss–Lobatto 节点进行域离散化**\n\n谱方法要求在特定的一组点（即节点）上计算函数值。对于这个问题，我们使用 Chebyshev–Gauss–Lobatto (CGL) 节点，这些节点是 N 阶第一类 Chebyshev 多项式的极值点。这些节点分布在区间 $[-1, 1]$ 内，并由以下公式给出：\n$$y_j = \\cos\\left(\\frac{\\pi j}{N}\\right) \\quad \\text{for } j = 0, 1, \\dots, N$$\n其中 $N$ 是多项式阶数。这组 $N+1$ 个节点包括了边界点，因为 $y_0 = \\cos(0) = 1$ 且 $y_N = \\cos(\\pi) = -1$。这些节点并非均匀分布；它们在边界 $y=\\pm 1$ 附近聚集，这一特性对于解析输运现象中经常遇到的陡峭梯度或边界层非常有利。\n\n**步骤2：构建 Chebyshev 微分矩阵**\n\n一个由其在 CGL 节点上的值所表示的函数，其谱导数是通过与一个 Chebyshev 微分矩阵 $D$ 相乘来计算的。这个矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 的构建方式如下。\n\n首先，我们为每个节点 $j$ 定义一组交替权重 $c_j$：\n$$c_j = (-1)^j \\, w_j$$\n其中权重 $w_j$ 由 $w_0 = w_N = 2$ 给出，且当 $1 \\le j \\le N-1$ 时 $w_j = 1$。\n\n然后定义微分矩阵 $D$ 的元素。非对角元素为：\n$$D_{ij} = \\frac{c_i}{c_j} \\, \\frac{1}{y_i - y_j} \\quad \\text{for } i \\ne j$$\n对角元素由常数函数的导数必须为零这一条件确定。如果我们用向量 $\\mathbf{f} = [k, k, \\dots, k]^T$ 表示常数函数 $f(y)=k$，那么它的导数向量必须是 $\\mathbf{0}$。数值导数为 $D\\mathbf{f} = k(D\\mathbf{1})$，其中 $\\mathbf{1}$ 是一个全1向量。为了使 $D\\mathbf{1}$ 为零，矩阵每一行的元素之和必须为零：$\\sum_{j=0}^{N} D_{ij} = 0$。这给出了对角元素的公式：\n$$D_{ii} = -\\sum_{k=0, k\\ne i}^{N} D_{ik}$$\n这种构造方法确保了对于任何阶数不高于 $N$ 的多项式，该微分矩阵都是精确的。\n\n**步骤3：温度梯度和热通量的近似**\n\n设解析温度分布为 $T(y)$。我们首先在 CGL 节点上计算该函数的值，以获得离散温度向量 $\\mathbf{T}$：\n$$\\mathbf{T} = [T(y_0), T(y_1), \\dots, T(y_N)]^T$$\n然后通过矩阵-向量乘积得到每个节点上温度梯度的谱近似：\n$$\n\\begin{pmatrix}\n (dT/dy)|_{y_0} \\\\\n (dT/dy)|_{y_1} \\\\\n \\vdots \\\\\n (dT/dy)|_{y_N}\n\\end{pmatrix}_{\\text{num}}\n\\approx D \\mathbf{T}\n$$\n随后，通过应用傅里叶定律，可以求得数值热通量向量 $\\mathbf{q}_y^{\\text{num}}$：\n$$\\mathbf{q}_y^{\\text{num}} = - D \\mathbf{T}$$\n\n**步骤4：计算壁面热通量和数值误差**\n\n主要目标是计算位于 $y = +1$ 和 $y = -1$ 处的壁面热通量。它们分别对应于节点 $y_0$ 和 $y_N$。\n\n数值壁面通量是向量 $\\mathbf{q}_y^{\\text{num}}$ 的第一个和最后一个分量：\n$$q_y^{\\text{num}}(+1) = - (D \\mathbf{T})_0$$\n$$q_y^{\\text{num}}(-1) = - (D \\mathbf{T})_N$$\n\n为了评估该近似的准确性，我们将这些数值与从温度分布的解析导数 $T'(y) = \\frac{dT}{dy}$ 推导出的精确通量进行比较。精确通量为：\n$$q_y^{\\text{exact}}(+1) = -T'(1)$$\n$$q_y^{\\text{exact}}(-1) = -T'(-1)$$\n\n每个测试用例的最终误差 $\\varepsilon$ 定义为两个壁面处绝对误差的最大值：\n$$\\varepsilon = \\max\\left( \\left| q_y^{\\text{num}}(+1) - q_y^{\\text{exact}}(+1) \\right|, \\, \\left| q_y^{\\text{num}}(-1) - q_y^{\\text{exact}}(-1) \\right| \\right)$$\n\n将此过程应用于每个测试用例，方法是代入相应的函数 $T(y)$、其解析导数 $T'(y)$ 以及指定的多项式阶数 $N$。例如，在案例1中，$T(y)=y^4$ 且 $N=8$，其解析导数为 $T'(y)=4y^3$。由于多项式的阶数（4）小于或等于 $N=8$，谱微分是精确的，因此误差 $\\varepsilon$ 预计在机器精度的量级。对于非多项式函数，误差将是有限的，并且随着 $N$ 的增加而迅速减小（谱收敛）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the (N+1)x(N+1) Chebyshev differentiation matrix.\n    \n    Args:\n        N (int): The polynomial degree.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the differentiation \n                                       matrix D and the node locations y.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.]]), np.array([0.])\n    \n    # Chebyshev-Gauss-Lobatto nodes\n    j = np.arange(N + 1)\n    y = np.cos(np.pi * j / N)\n    \n    # Alternating weights\n    w = np.ones(N + 1)\n    w[0] = w[N] = 2.0\n    c = (-1)**j * w\n    \n    # Tile y and c for vectorized computation of off-diagonal elements\n    y_col = y[:, np.newaxis]\n    y_row = y[np.newaxis, :]\n    c_col = c[:, np.newaxis]\n    c_row = c[np.newaxis, :]\n    \n    # Compute off-diagonal elements\n    diff = y_col - y_row\n    # Add identity to avoid division by zero on the diagonal\n    diff += np.identity(N + 1)\n    \n    D = (c_col / c_row) / diff\n    \n    # Set diagonal elements to zero, as they were placeholders\n    np.fill_diagonal(D, 0)\n    \n    # Compute diagonal elements from row-sum condition\n    D_diag = -np.sum(D, axis=1)\n    np.fill_diagonal(D, D_diag)\n    \n    return D, y\n\ndef calculate_wall_flux_error(N, T_func, T_prime_func):\n    \"\"\"\n    Computes the maximum absolute error of the wall-normal heat flux.\n    \n    Args:\n        N (int): The polynomial degree.\n        T_func (callable): The analytic temperature profile T(y).\n        T_prime_func (callable): The analytic derivative T'(y).\n        \n    Returns:\n        float: The maximum error epsilon.\n    \"\"\"\n    # Construct the differentiation matrix and nodes\n    D, y = compute_chebyshev_diff_matrix(N)\n    \n    # Evaluate temperature at the nodes\n    T_at_nodes = T_func(y)\n    \n    # Compute the numerical derivative via matrix-vector product\n    dT_dy_num = D @ T_at_nodes\n    \n    # The walls are at y = +1 (node 0) and y = -1 (node N)\n    # Numerical heat flux q = -dT/dy\n    q_num_p1 = -dT_dy_num[0]\n    q_num_m1 = -dT_dy_num[N]\n    \n    # Exact heat flux\n    q_exact_p1 = -T_prime_func(1.0)\n    q_exact_m1 = -T_prime_func(-1.0)\n    \n    # Calculate errors at each wall\n    error_p1 = np.abs(q_num_p1 - q_exact_p1)\n    error_m1 = np.abs(q_num_m1 - q_exact_m1)\n    \n    # Return the maximum of the two errors\n    return np.maximum(error_p1, error_m1)\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: polynomial, happy path\n        {'N': 8, 'T': lambda y: y**4, 'Tp': lambda y: 4 * y**3, 'name': 'y^4, N=8'},\n        # Case 2: exponential, moderate gradient\n        {'N': 24, 'T': lambda y: np.exp(3 * y), 'Tp': lambda y: 3 * np.exp(3 * y), 'name': 'exp(3y), N=24'},\n        # Case 3: hyperbolic cosine, moderate resolution\n        {'N': 16, 'T': lambda y: np.cosh(5 * y), 'Tp': lambda y: 5 * np.sinh(5 * y), 'name': 'cosh(5y), N=16'},\n        # Case 4: sine in radians, small N\n        {'N': 8, 'T': lambda y: np.sin(np.pi * y), 'Tp': lambda y: np.pi * np.cos(np.pi * y), 'name': 'sin(pi*y), N=8'},\n        # Case 5: exponential, steep gradient\n        {'N': 32, 'T': lambda y: np.exp(10 * y), 'Tp': lambda y: 10 * np.exp(10 * y), 'name': 'exp(10y), N=32'},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = calculate_wall_flux_error(case['N'], case['T'], case['Tp'])\n        results.append(f\"{error:.16e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了空间微分的工具后，下一步是将它们集成到一个完整的流体动力学模拟算法中。直接模拟不可压缩流体（如纳维-斯托克斯方程所描述的）需要一种特殊技术来强制执行速度场的无散度约束。这个练习  将引导您完成压力修正法的一个时间步长，这是不可压缩流DNS中的基石算法，展示了如何使用谱算子来求解流动动力学，同时保持流体的不可压缩性。",
            "id": "3946876",
            "problem": "给定二维空间中的不可压缩Navier–Stokes方程，用于描述速度场 $\\mathbf{u}(x,y,t)$ 和压力场 $p(x,y,t)$。方程以无量纲形式表示，定义在一个方形周期性域上：\n$$\n\\mathbf{u}_t + \\mathbf{N}(\\mathbf{u}) = -\\nabla p + \\nu \\nabla^2 \\mathbf{u},\\qquad \\nabla\\cdot\\mathbf{u}=0,\n$$\n其中 $\\mathbf{N}(\\mathbf{u})$ 表示非线性对流算子，$\\nu$ 是运动粘度。任务是，在傅里叶伪谱离散化框架内，实现增量压力修正法的单个时间步，并量化投影如何消除中间速度场中产生的散度。\n\n请仅从基本原理出发，实现以下内容：\n\n- 在周期性域 $[0,2\\pi]^2$ 上使用傅里叶伪谱离散化，该域上有 $N\\times N$ 个均匀间隔的网格点。设 $N$ 为正整数，网格间距满足 $dx=dy=2\\pi/N$。使用标准的离散傅里叶变换，其波数为整数值，并与 $[0,2\\pi]$ 的周期性一致。\n\n- 通过流函数 $\\psi(x,y)$ 构建一个无散度的初始速度场，使得 $\\mathbf{u}=\\nabla^\\perp\\psi$，其中 $\\mathbf{u}(x,y,0)=\\left(\\partial_y\\psi,-\\partial_x\\psi\\right)$。取 $\\psi(x,y)=\\sin(x)\\sin(y)$。所有量均为无量纲。\n\n- 将非线性对流算子 $\\mathbf{N}(\\mathbf{u})$ 离散化为 $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$。在物理空间中，使用谱导数构建 $\\nabla\\mathbf{u}$，然后计算逐点乘积，并变换回傅里叶空间。通过将傅里叶空间中满足 $|k_x|>N/3$ 或 $|k_y|>N/3$ 的模态置零，对非线性项应用经典的2/3去混叠规则。\n\n- 对忽略压力的中间速度 $\\mathbf{u}^\\star$ 执行一个显式前向欧拉步。然后，执行增量压力修正（投影），以获得满足离散不可压缩约束的 $\\mathbf{u}^{n+1}$。仅使用基本控制方程和周期性谱表示来推导压力增量和投影算子的必要关系；不要使用任何预先给出的公式。\n\n- 使用标量散度场的离散 $L^2$ 范数量化散度，其定义为\n$$\n\\|\\nabla\\cdot\\mathbf{v}\\|_{2}=\\left(\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1} \\left(\\nabla\\cdot\\mathbf{v}(x_j,y_k)\\right)^2\\,dx\\,dy\\right)^{1/2},\n$$\n其中 $\\mathbf{v}$ 是对应时间的速度场。每个测试案例报告三个量：初始速度 $\\mathbf{u}^n$ 的散度离散 $L^2$ 范数、中间速度 $\\mathbf{u}^\\star$ 的散度离散 $L^2$ 范数，以及投影后速度 $\\mathbf{u}^{n+1}$ 的散度离散 $L^2$ 范数。\n\n您的程序必须为以下参数集测试套件生成结果，每个参数集均以无量纲单位表示：\n\n- 测试1：$N=64$, $\\Delta t=10^{-3}$, $\\nu=10^{-3}$，激活非线性对流。\n- 测试2：$N=64$, $\\Delta t=10^{-6}$, $\\nu=10^{-3}$，激活非线性对流。\n- 测试3：$N=64$, $\\Delta t=5\\times 10^{-3}$, $\\nu=0$，激活非线性对流。\n- 测试4：$N=64$, $\\Delta t=10^{-3}$, $\\nu=10^{-3}$，禁用非线性对流（即，取 $\\mathbf{N}(\\mathbf{u})=\\mathbf{0}$）。\n\n对于每个测试案例，程序必须计算并输出一个包含三个实数（每个都是浮点数）的列表：$[\\|\\nabla\\cdot\\mathbf{u}^n\\|_2,\\ \\|\\nabla\\cdot\\mathbf{u}^\\star\\|_2,\\ \\|\\nabla\\cdot\\mathbf{u}^{n+1}\\|_2]$。\n\n最终输出格式要求：\n\n- 您的程序应生成单行输出，其中包含一个列表的列表，每个子列表对应一个测试案例，并按上述顺序列出三个浮点数。格式必须严格如下：\n$$\n[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]],\n$$\n其中每个 $a_i$、$b_i$ 和 $c_i$ 均为小数值。\n\n所有计算均以无量纲单位进行。角度以弧度为单位。程序不应需要任何外部输入，必须自包含且可在现代环境中运行。实现的核心必须源于控制方程和谱表示，而非预先给出的简化公式。",
            "solution": "起点是周期性域上的不可压缩Navier–Stokes方程\n$$\n\\mathbf{u}_t + \\mathbf{N}(\\mathbf{u}) = -\\nabla p + \\nu \\nabla^2 \\mathbf{u},\\qquad \\nabla\\cdot\\mathbf{u}=0,\n$$\n增量压力修正法的步骤是，首先在没有压力项的情况下形成一个中间速度，然后使用通过泊松问题计算出的标量压力增量来修正该速度，以施加无散度约束。该推导仅依赖于方程、周期性边界条件和标准的谱恒等式。\n\n基本基底与表示：\n\n- 在具有 $N\\times N$ 个网格点的 $[0,2\\pi]^2$ 周期性域中，使用与 $2\\pi$ 周期区间上的离散傅里叶变换一致的整数谱波数 $k_x$ 和 $k_y$。用帽子符号表示场的离散傅里叶变换，例如 $\\widehat{u_x}(k_x,k_y)$。\n\n- 谱微分恒等式是公认的：对于每个模态 $(k_x,k_y)$，$\\partial_x$ 对应于乘以 $\\mathrm{i}k_x$，$\\partial_y$ 对应于乘以 $\\mathrm{i}k_y$，而拉普拉斯算子 $\\nabla^2$ 对应于乘以 $-(k_x^2+k_y^2)$。\n\n- 傅里叶空间中的散度为 $\\widehat{\\nabla\\cdot\\mathbf{u}}=\\mathrm{i}k_x\\widehat{u_x}+\\mathrm{i}k_y\\widehat{u_y}$，其逆变换得到 $\\nabla\\cdot\\mathbf{u}(x,y)$。\n\n通过流函数进行无散度初始化：\n\n- 设流函数为 $\\psi(x,y)=\\sin(x)\\sin(y)$。定义初始速度 $\\mathbf{u}(x,y,0)=\\left(\\partial_y\\psi,-\\partial_x\\psi\\right)=\\left(\\cos(y)\\sin(x),-\\cos(x)\\sin(y)\\right)$，根据构造，该速度场是无散度的，因为 $\\nabla\\cdot\\nabla^\\perp\\psi=0$。\n\n非线性项与伪谱计算：\n\n- 非线性对流算子是 $\\mathbf{N}(\\mathbf{u})=(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$。其x分量为 $N_x=u_x\\partial_x u_x+u_y\\partial_y u_x$，y分量为 $N_y=u_x\\partial_x u_y+u_y\\partial_y u_y$。\n\n- 在傅里叶空间中，通过将 $\\widehat{u_x}$ 和 $\\widehat{u_y}$ 乘以 $\\mathrm{i}k_x$ 或 $\\mathrm{i}k_y$ 来计算 $\\partial_x u_x$、$\\partial_y u_x$、$\\partial_x u_y$ 和 $\\partial_y u_y$，然后变换到物理空间以形成定义 $N_x$ 和 $N_y$ 的乘积。将 $N_x$ 和 $N_y$ 变换回傅里叶空间。通过将傅里叶空间中满足 $|k_x|>N/3$ 或 $|k_y|>N/3$ 的模态置零，对非线性项应用2/3去混叠规则。这是控制二次非线性伪谱计算中混叠误差的成熟方法。\n\n无压力的中间步骤：\n\n- 用显式前向欧拉步对中间速度 $\\mathbf{u}^\\star$ 进行时间离散化。记 $\\Delta t$ 为时间步长。从无压力的动量方程出发，傅里叶空间中的中间更新为\n$$\n\\widehat{\\mathbf{u}^\\star} = \\widehat{\\mathbf{u}^n} + \\Delta t\\left(-\\widehat{\\mathbf{N}(\\mathbf{u}^n)} + \\nu \\widehat{\\nabla^2 \\mathbf{u}^n}\\right),\n$$\n其中 $\\widehat{\\nabla^2 \\mathbf{u}^n}=-(k_x^2+k_y^2)\\widehat{\\mathbf{u}^n}$。\n\n- 中间速度通常不满足 $\\nabla\\cdot\\mathbf{u}^\\star=0$，因为负责施加不可压缩性的压力项被忽略了。\n\n通过亥姆霍兹分解进行增量压力修正：\n\n- 在周期性域中，向量场 $\\mathbf{u}^\\star$ 可以唯一地分解为一个无散度部分和一个标量势的梯度：\n$$\n\\mathbf{u}^\\star = \\mathbf{u}^{n+1} + \\Delta t \\nabla \\phi,\n$$\n其中 $\\nabla\\cdot\\mathbf{u}^{n+1}=0$，$\\phi$ 是压力增量除以密度（在无量纲形式下）。对该分解取散度，得到\n$$\n\\nabla\\cdot\\mathbf{u}^\\star = \\Delta t \\nabla^2 \\phi,\n$$\n这意味着压力增量满足一个泊松方程，\n$$\n\\nabla^2 \\phi = \\frac{1}{\\Delta t}\\nabla\\cdot\\mathbf{u}^\\star.\n$$\n\n- 对于非零模态，在傅里叶空间中，该泊松方程简化为\n$$\n-(k_x^2+k_y^2)\\widehat{\\phi} = \\frac{1}{\\Delta t}\\left(\\mathrm{i}k_x\\widehat{u^\\star_x}+\\mathrm{i}k_y\\widehat{u^\\star_y}\\right),\n$$\n因此对于 $(k_x,k_y)\\neq(0,0)$，\n$$\n\\widehat{\\phi} = -\\frac{\\mathrm{i}k_x\\widehat{u^\\star_x}+\\mathrm{i}k_y\\widehat{u^\\star_y}}{(k_x^2+k_y^2)\\Delta t}.\n$$\n零模态 $\\widehat{\\phi}(0,0)$ 在相差一个加性常数的情况下是不确定的，可以设为0。\n\n- 然后通过减去压力增量的梯度来获得修正后的速度：\n$$\n\\widehat{\\mathbf{u}^{n+1}} = \\widehat{\\mathbf{u}^\\star} - \\Delta t\\,\\mathrm{i}\\mathbf{k}\\,\\widehat{\\phi}.\n$$\n结合前面的关系，得到熟悉的傅里叶空间中到无散度场上的勒雷（Leray）投影算子：\n$$\n\\widehat{\\mathbf{u}^{n+1}} = \\left(\\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^\\top}{\\|\\mathbf{k}\\|^2}\\right)\\widehat{\\mathbf{u}^\\star},\n$$\n对于 $(k_x,k_y)\\neq(0,0)$，其中 $\\mathbf{k}=(k_x,k_y)$，$\\mathbf{I}$ 是单位矩阵。该构造直接源于亥姆霍兹分解和泊松方程的解，除了谱表示和控制方程外，不需要任何简化公式。对于零模态，设置 $\\widehat{\\mathbf{u}^{n+1}}=\\widehat{\\mathbf{u}^\\star}$，因为 $\\mathbf{k}=\\mathbf{0}$ 会使投影不确定，但常数模态的散度为零。\n\n散度量化：\n\n- 对于任何速度场 $\\mathbf{v}$，在傅里叶空间中计算其散度 $\\widehat{\\nabla\\cdot\\mathbf{v}}=\\mathrm{i}k_x\\widehat{v_x}+\\mathrm{i}k_y\\widehat{v_y}$，进行逆变换得到 $\\nabla\\cdot\\mathbf{v}(x,y)$，然后计算离散 $L^2$ 范数\n$$\n\\|\\nabla\\cdot\\mathbf{v}\\|_{2}=\\left(\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1} \\left(\\nabla\\cdot\\mathbf{v}(x_j,y_k)\\right)^2\\,dx\\,dy\\right)^{1/2},\n$$\n其中 $dx=dy=2\\pi/N$。\n\n每个测试案例的算法步骤：\n\n1. 建立网格 $x_j=j\\,dx$ 和 $y_k=k\\,dy$，其中 $j,k\\in\\{0,\\dots,N-1\\}$，$dx=dy=2\\pi/N$。通过缩放为整数波数的离散傅里叶频率函数建立傅里叶波数 $k_x$ 和 $k_y$。\n\n2. 在物理空间中通过流函数初始化速度场 $\\mathbf{u}^n$，然后计算其傅里叶变换 $\\widehat{u_x^n}$ 和 $\\widehat{u_y^n}$。\n\n3. 计算谱导数以在物理空间中获得 $\\partial_x \\mathbf{u}^n$ 和 $\\partial_y \\mathbf{u}^n$，形成非线性项 $(\\mathbf{u}^n\\cdot\\nabla)\\mathbf{u}^n$，将其变换到傅里叶空间，并应用2/3去混叠滤波器。\n\n4. 计算 $\\widehat{\\nabla^2 \\mathbf{u}^n}=-(k_x^2+k_y^2)\\widehat{\\mathbf{u}^n}$。\n\n5. 形成中间速度 $\\widehat{\\mathbf{u}^\\star}=\\widehat{\\mathbf{u}^n}+\\Delta t\\left(-\\widehat{\\mathbf{N}(\\mathbf{u}^n)}+\\nu\\widehat{\\nabla^2\\mathbf{u}^n}\\right)$。\n\n6. 计算 $\\|\\nabla\\cdot\\mathbf{u}^n\\|_2$ 和 $\\|\\nabla\\cdot\\mathbf{u}^\\star\\|_2$。\n\n7. 使用傅里叶空间投影算子将 $\\widehat{\\mathbf{u}^\\star}$ 投影到无散度子空间，以获得 $\\widehat{\\mathbf{u}^{n+1}}$。\n\n8. 计算 $\\|\\nabla\\cdot\\mathbf{u}^{n+1}\\|_2$。\n\n测试套件覆盖范围：\n\n- 测试1使用 $N=64$, $\\Delta t=10^{-3}$, $\\nu=10^{-3}$，并激活对流项，代表一个典型的直接数值模拟步骤。\n\n- 测试2使用非常小的时间步长 $\\Delta t=10^{-6}$，以检查极限行为和数值舍入误差的影响。\n\n- 测试3设置 $\\nu=0$（无粘）和 $\\Delta t=5\\times 10^{-3}$，以关注对流非线性以及在没有扩散时投影的作用。\n\n- 测试4禁用非线性项，只留下扩散；由于 $\\nabla^2$ 与散度可交换，且初始场是无散度的，因此中间速度的散度预计会保持在接近数值精度的零值。\n\n程序为每个测试案例输出一个列表，其中包含三个浮点数 $[\\|\\nabla\\cdot\\mathbf{u}^n\\|_2,\\ \\|\\nabla\\cdot\\mathbf{u}^\\star\\|_2,\\ \\|\\nabla\\cdot\\mathbf{u}^{n+1}\\|_2]$。所有结果汇总为单行输出，即这些列表的列表，严格按照要求的格式。投影步骤必须将散度范数从中间值减小到接近机器精度的值，从而证明通过源于控制方程和谱表示的投影消除了散度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef spectral_wavenumbers(N):\n    \"\"\"\n    Return 2D arrays of integer Fourier wavenumbers kx, ky and k^2 for a 2π-periodic domain.\n    \"\"\"\n    k1d = np.fft.fftfreq(N) * N  # integer wavenumbers consistent with 2π periodicity\n    kx, ky = np.meshgrid(k1d, k1d, indexing='ij')\n    k2 = kx**2 + ky**2\n    return kx, ky, k2\n\ndef dealias_mask(N):\n    \"\"\"\n    2/3-rule dealiasing mask: keep modes with |k|= N/3 in each direction.\n    \"\"\"\n    k1d = np.fft.fftfreq(N) * N\n    kx, ky = np.meshgrid(k1d, k1d, indexing='ij')\n    cutoff = N // 3\n    mask = (np.abs(kx) = cutoff)  (np.abs(ky) = cutoff)\n    return mask\n\ndef streamfunction_initial_u(N):\n    \"\"\"\n    Construct divergence-free initial velocity from psi = sin(x) sin(y).\n    u = (∂ψ/∂y, -∂ψ/∂x) = (cos(y) sin(x), -cos(x) sin(y))\n    \"\"\"\n    L = 2.0 * np.pi\n    x = np.linspace(0.0, L, N, endpoint=False)\n    y = np.linspace(0.0, L, N, endpoint=False)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    ux = np.cos(Y) * np.sin(X)\n    uy = -np.cos(X) * np.sin(Y)\n    return ux, uy\n\ndef fft2(field):\n    return np.fft.fft2(field)\n\ndef ifft2(field_hat):\n    return np.fft.ifft2(field_hat)\n\ndef compute_divergence_norm(ux_hat, uy_hat, kx, ky, dx, dy):\n    \"\"\"\n    Compute L2 norm of divergence: ||∇·u||_2 over the domain using discrete sum.\n    \"\"\"\n    div_hat = 1j * kx * ux_hat + 1j * ky * uy_hat\n    div = np.real(ifft2(div_hat))\n    norm = np.sqrt(np.sum(div**2) * dx * dy)\n    return norm\n\ndef compute_nonlinear_term_hat(ux_hat, uy_hat, kx, ky, N, mask):\n    \"\"\"\n    Compute (u · ∇) u pseudo-spectrally with 2/3-rule dealiasing.\n    \"\"\"\n    # Spectral derivatives of u components\n    dux_dx_hat = 1j * kx * ux_hat\n    dux_dy_hat = 1j * ky * ux_hat\n    duy_dx_hat = 1j * kx * uy_hat\n    duy_dy_hat = 1j * ky * uy_hat\n\n    # Transform derivatives to physical space\n    dux_dx = np.real(ifft2(dux_dx_hat))\n    dux_dy = np.real(ifft2(dux_dy_hat))\n    duy_dx = np.real(ifft2(duy_dx_hat))\n    duy_dy = np.real(ifft2(duy_dy_hat))\n\n    # Velocity in physical space\n    ux = np.real(ifft2(ux_hat))\n    uy = np.real(ifft2(uy_hat))\n\n    # Nonlinear term in physical space\n    Nx = ux * dux_dx + uy * dux_dy\n    Ny = ux * duy_dx + uy * duy_dy\n\n    # Transform back to Fourier space\n    Nx_hat = fft2(Nx)\n    Ny_hat = fft2(Ny)\n\n    # Apply 2/3 de-aliasing to nonlinear term\n    Nx_hat = Nx_hat * mask\n    Ny_hat = Ny_hat * mask\n\n    return Nx_hat, Ny_hat\n\ndef incremental_pressure_correction_step(N, dt, nu, nonlinear_active=True):\n    \"\"\"\n    Perform one incremental pressure correction step for given parameters.\n    Returns divergence norms: [||div u^n||2, ||div u*||2, ||div u^{n+1}||2].\n    \"\"\"\n    # Grid and spectral wavenumbers\n    L = 2.0 * np.pi\n    dx = L / N\n    dy = L / N\n    kx, ky, k2 = spectral_wavenumbers(N)\n    mask = dealias_mask(N)\n\n    # Initial velocity from streamfunction\n    ux, uy = streamfunction_initial_u(N)\n\n    # Fourier transforms of initial velocity\n    ux_hat = fft2(ux)\n    uy_hat = fft2(uy)\n\n    # Divergence norm of initial velocity\n    divn = compute_divergence_norm(ux_hat, uy_hat, kx, ky, dx, dy)\n\n    # Nonlinear term\n    if nonlinear_active:\n        Nx_hat, Ny_hat = compute_nonlinear_term_hat(ux_hat, uy_hat, kx, ky, N, mask)\n    else:\n        Nx_hat = np.zeros_like(ux_hat)\n        Ny_hat = np.zeros_like(uy_hat)\n\n    # Diffusion term in spectral space: nu * ∇^2 u = -nu * k^2 * u_hat\n    lap_ux_hat = -k2 * ux_hat\n    lap_uy_hat = -k2 * uy_hat\n\n    # Intermediate velocity u* via explicit Euler: u* = u^n + dt * ( -N(u^n) + nu ∇^2 u^n )\n    ux_star_hat = ux_hat + dt * (-Nx_hat + nu * lap_ux_hat)\n    uy_star_hat = uy_hat + dt * (-Ny_hat + nu * lap_uy_hat)\n\n    # Divergence norm of intermediate velocity\n    div_star = compute_divergence_norm(ux_star_hat, uy_star_hat, kx, ky, dx, dy)\n\n    # Projection to divergence-free subspace in Fourier space (Leray projector)\n    # For k != 0: u^{n+1}_hat = u*_hat - k (k · u*_hat) / |k|^2\n    # Handle k^2 = 0 (zero mode) separately.\n    u_dot_k_hat = kx * ux_star_hat + ky * uy_star_hat\n    # Avoid division by zero: create factor with zeros where k2 == 0\n    factor = np.zeros_like(u_dot_k_hat, dtype=np.complex128)\n    nonzero = k2 != 0\n    factor[nonzero] = u_dot_k_hat[nonzero] / k2[nonzero]\n    ux_new_hat = ux_star_hat - kx * factor\n    uy_new_hat = uy_star_hat - ky * factor\n\n    # Divergence norm of projected velocity\n    div_new = compute_divergence_norm(ux_new_hat, uy_new_hat, kx, ky, dx, dy)\n\n    return [divn, div_star, div_new]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, dt, nu, nonlinear_active)\n    test_cases = [\n        (64, 1e-3, 1e-3, True),     # Test 1\n        (64, 1e-6, 1e-3, True),     # Test 2\n        (64, 5e-3, 0.0, True),      # Test 3\n        (64, 1e-3, 1e-3, False),    # Test 4\n    ]\n\n    results = []\n    for N, dt, nu, nonlinear_active in test_cases:\n        norms = incremental_pressure_correction_step(N, dt, nu, nonlinear_active)\n        # Convert to Python floats for clean printing\n        results.append([float(norms[0]), float(norms[1]), float(norms[2])])\n\n    # Final print statement in the exact required format: one single line, list of lists.\n    print(f\"[{','.join([str(item) for item in results])}]\")\n\nsolve()\n```"
        }
    ]
}