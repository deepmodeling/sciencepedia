{
    "hands_on_practices": [
        {
            "introduction": "在构建任何数值模拟代码时，首要步骤是验证其核心算子的准确性。本实践将聚焦于傅里叶谱方法的基础——微分运算。通过将数值计算得到的导数与一系列已知函数的解析解进行比较，您将亲手验证该方法的“谱精度”，并深入理解其在不同情况下的表现，包括如何处理不同频率成分的函数。",
            "id": "3946953",
            "problem": "考虑一个在一维空间上定义、长度为 $2\\pi$、具有周期性边界条件的光滑周期性温度场。目标是通过将数值计算的导数与解析推导的参考导数进行比较，来验证通过快速傅里叶变换 (FFT) 实现的谱方法微分的准确性。该测试必须使用 $L^2$ 和 $L^\\infty$ 误差范数来量化差异。三角函数的角度单位必须是弧度。所有量均为无量纲；不需要物理单位。\n\n从周期函数的傅里叶级数基本表示和傅里叶变换的微分性质出发，设计并实现一个伪谱微分算子，用于计算在 $[0,2\\pi)$ 区间上 $N$ 个等距点上采样的周期函数的一阶空间导数。程序必须：\n- 在区间 $[0,2\\pi)$ 上为 $j=0,\\dots,N-1$ 构建等距网格点 $x_j$。\n- 对于每个测试用例，在此网格上计算构造的温度场 $T(x)$。\n- 使用与周期函数的傅里叶级数微分性质一致的、基于傅里叶变换的方法计算谱导数。\n- 为每个构造场推导并计算精确的解析导数 $T'(x)$。\n- 计算误差场 $e(x_j)=T'_{\\text{num}}(x_j)-T'_{\\text{ref}}(x_j)$。\n- 使用以下范数报告误差：\n  - $L^2$ 误差定义为 $\\left(\\sum_{j=0}^{N-1} |e(x_j)|^2\\,\\Delta x\\right)^{1/2}$，其中 $\\Delta x = 2\\pi/N$。\n  - $L^\\infty$ 误差定义为 $\\max_{0\\le j \\le N-1} |e(x_j)|$。\n所有三角函数计算都必须使用弧度。\n\n测试套件。使用以下构造场和分辨率：\n1. 理想情况（带限，良好解析）：$N=32$, $T(x)=\\sin(3x)+\\tfrac{1}{2}\\cos(2x)$。\n2. 非2的幂且为奇数大小：$N=33$, $T(x)=\\sin(9x)$。\n3. 接近奈奎斯特模式：$N=64$, $T(x)=\\cos(31x)$。\n4. 易混叠的光滑但非带限函数：$N=64$, $T(x)=\\exp(\\sin(x))$。\n\n对于每种情况，通过谱方法微分计算数值导数，并与精确的解析导数进行比较。然后计算并返回 $L^2$ 和 $L^\\infty$ 误差范数。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。该列表必须按上述顺序包含每个测试用例的 $L^2$ 误差和 $L^\\infty$ 误差，每个值四舍五入到八位小数。例如，输出格式必须是\n$[L2\\_1,L\\infty\\_1,L2\\_2,L\\infty\\_2,L2\\_3,L\\infty\\_3,L2\\_4,L\\infty\\_4]$，\n其中 $L2\\_k$ 和 $L\\infty\\_k$ 分别表示测试用例 $k$ 的 $L^2$ 和 $L^\\infty$ 误差。",
            "solution": "问题陈述已经过仔细审查，并被确定为有效的。它在科学上基于傅里叶分析的原理，是数值适定的，并且是计算科学中的一个客观练习。任务是实现并验证一个伪谱微分算子，这是求解偏微分方程的一种标准技术，尤其在直接数值模拟 (DNS) 等对精度要求极高的领域。所有必需的参数、函数和误差度量定义都已提供，从而可以得到一个唯一且可验证的解。\n\n### 伪谱微分的理论基础\n\n该方法基于傅里叶级数的微分性质。一个在空间域 $[0, 2\\pi)$ 上周期的、足够光滑的函数 $T(x)$ 可以用其复傅里叶级数表示：\n$$\nT(x) = \\sum_{k=-\\infty}^{\\infty} \\hat{T}_k e^{ikx}\n$$\n其中 $k$ 代表整数波数，$\\hat{T}_k$ 是复傅里叶系数。空间导数 $T'(x)$ 是通过对该级数逐项对 $x$ 求导得到的：\n$$\nT'(x) = \\frac{d}{dx} \\sum_{k=-\\infty}^{\\infty} \\hat{T}_k e^{ikx} = \\sum_{k=-\\infty}^{\\infty} (ik) \\hat{T}_k e^{ikx}\n$$\n这个基本性质表明，物理空间中的微分等价于在傅里叶空间中乘以 $ik$，其中 $i$ 是虚数单位。\n\n### 通过离散傅里叶变换的数值实现\n\n在计算环境中，连续函数 $T(x)$ 由其在 $N$ 个等距点组成的离散网格上的采样值表示：$x_j = j \\frac{2\\pi}{N}$，其中 $j=0, 1, \\dots, N-1$。伪谱法（或配置法）涉及以下步骤：\n\n1.  **正向变换**：使用快速傅里叶变换 (FFT) 将函数采样值向量 $T_j = T(x_j)$ 变换到离散傅里叶域。这将产生一个离散傅里叶系数向量 $\\hat{T}_k$。\n    $$\n    \\hat{T}_k = \\mathcal{F}\\{T_j\\} = \\sum_{j=0}^{N-1} T_j e^{-i 2\\pi jk/N}\n    $$\n\n2.  **波数向量**：FFT 输出的索引 $k=0, 1, \\dots, N-1$ 必须映射到相应的物理波数。对于长度为 $L=2\\pi$ 的域，波数是整数。标准的 FFT 库生成的系数顺序需要一个特定的波数向量 $\\boldsymbol{\\kappa}$ 才能进行正确的乘法。该向量由 $\\boldsymbol{\\kappa} = [0, 1, \\dots, k_{\\text{max}}, -k_{\\text{Ny}}, \\dots, -1]$ 给出，其中 $k_{\\text{max}}$ 和奈奎斯特波数 $k_{\\text{Ny}}$ 的处理取决于 $N$ 是偶数还是奇数。\n\n3.  **奈奎斯特频率处理（对于偶数 $N$）**：当 $N$ 为偶数时，奈奎斯特波数为 $k_{\\text{Ny}} = N/2$。网格上对应的模式为 $e^{i(N/2)x_j} = e^{i\\pi j} = (-1)^j$。实函数 $\\cos(k_{\\text{Ny}}x)$ 的导数是 $-k_{\\text{Ny}}\\sin(k_{\\text{Ny}}x)$。在网格点 $x_j$ 处，$\\sin(k_{\\text{Ny}}x_j) = \\sin(\\pi j) = 0$。因此，奈奎斯特模式的余弦部分的导数无法表示，因为它在网格上处处为零。为了保持实值输入函数的导数为实值并避免歧义，与奈奎斯特波数对应的傅里叶系数实际上乘以 $0$。这是谱方法代码中的一个标准约定。\n\n4.  **傅里叶空间中的微分**：如果 $N$ 是偶数，则形成一个修改后的波数向量 $\\boldsymbol{\\kappa}'$，其中奈奎斯特分量被设置为零。然后通过逐元素相乘计算导数的傅里叶系数 $\\widehat{T'}_k$：\n    $$\n    \\widehat{T'}_k = (i \\kappa'_k) \\hat{T}_k\n    $$\n\n5.  **逆变换**：通过对修改后的系数 $\\widehat{T'}_k$ 应用逆 FFT (iFFT) 来恢复物理空间中的导数 $T'_{\\text{num},j}$。\n    $$\n    T'_{\\text{num},j} = \\mathcal{F}^{-1}\\{\\widehat{T'}_k\\} = \\frac{1}{N} \\sum_{k=0}^{N-1} \\widehat{T'}_k e^{i 2\\pi jk/N}\n    $$\n    由于浮点运算，对实信号的变换后导数进行 iFFT 的结果可能会有可忽略的虚部，通过取结果的实部将其丢弃。\n\n### 误差分析\n\n数值导数 $T'_{\\text{num}}$ 的准确性通过将其与在网格点 $x_j$ 上计算的精确解析导数 $T'_{\\text{ref}}$ 进行比较来评估。误差场定义为 $e(x_j)=T'_{\\text{num}}(x_j)-T'_{\\text{ref}}(x_j)$。该误差的大小使用两个标准范数进行量化：\n\n-   离散 $L^2$ 误差范数，它测量域上的均方根误差：\n    $$\n    \\|e\\|_{L^2} = \\left( \\sum_{j=0}^{N-1} |e(x_j)|^2 \\Delta x \\right)^{1/2} \\quad \\text{其中} \\quad \\Delta x = \\frac{2\\pi}{N}\n    $$\n-   $L^\\infty$ 误差范数，它测量域中任意点的最大绝对误差：\n    $$\n    \\|e\\|_{L^\\infty} = \\max_{0 \\le j \\le N-1} |e(x_j)|\n    $$\n\n对于良好解析的带限函数（即所有活动波数 $k$ 满足 $|k|  N/2$），微分误差主要由浮点运算引起，应接近机器精度。对于非带限函数，误差主要由混叠引起，即无法在网格上表示的高波数内容被错误地折叠到低波数上，导致离散化误差，该误差不会随着机器精度的提高而消失。所提供的测试用例旨在探究这些行为。",
            "answer": "```python\nimport numpy as np\n\ndef spectral_derivative(T_values, N):\n    \"\"\"\n    Computes the first derivative of a periodic function using the Fourier spectral method.\n\n    Args:\n        T_values (np.ndarray): The function values at N equispaced points in [0, 2*pi).\n        N (int): The number of grid points.\n\n    Returns:\n        np.ndarray: The numerical derivative at the grid points.\n    \"\"\"\n    # 1. Forward FFT to get Fourier coefficients\n    T_hat = np.fft.fft(T_values)\n\n    # 2. Define the wavenumber vector kappa\n    # For a domain of length L=2*pi, the wavenumbers are integers.\n    # np.fft.fftfreq(N) gives frequencies f in cycles per sample.\n    # Multiply by N to get frequencies in cycles per domain length.\n    # Since L=2*pi, these are the wavenumbers k.\n    kappa = np.fft.fftfreq(N, d=1.0/N)\n\n    # 3. Handle the Nyquist frequency for even N\n    # The derivative of the Nyquist mode cos(N/2*x) is not representable\n    # on the grid. To keep the derivative of a real function real, its\n    # corresponding derivative coefficient is set to zero.\n    if N % 2 == 0:\n        kappa[N // 2] = 0.0\n\n    # 4. Multiply by i*kappa in Fourier space\n    T_prime_hat = 1j * kappa * T_hat\n\n    # 5. Inverse FFT to get the derivative in physical space\n    T_prime_num = np.fft.ifft(T_prime_hat)\n\n    # The result should be real; take the real part to discard negligible\n    # imaginary components due to floating-point error.\n    return np.real(T_prime_num)\n\ndef solve():\n    \"\"\"\n    Executes the verification test for spectral differentiation across all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 32,\n            \"T_func\": lambda x: np.sin(3 * x) + 0.5 * np.cos(2 * x),\n            \"T_prime_func\": lambda x: 3 * np.cos(3 * x) - np.sin(2 * x),\n        },\n        {\n            \"N\": 33,\n            \"T_func\": lambda x: np.sin(9 * x),\n            \"T_prime_func\": lambda x: 9 * np.cos(9 * x),\n        },\n        {\n            \"N\": 64,\n            \"T_func\": lambda x: np.cos(31 * x),\n            \"T_prime_func\": lambda x: -31 * np.sin(31 * x),\n        },\n        {\n            \"N\": 64,\n            \"T_func\": lambda x: np.exp(np.sin(x)),\n            \"T_prime_func\": lambda x: np.cos(x) * np.exp(np.sin(x)),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        T_func = case[\"T_func\"]\n        T_prime_func = case[\"T_prime_func\"]\n\n        # Construct grid and evaluate functions\n        delta_x = 2 * np.pi / N\n        x_grid = np.arange(0, N) * delta_x\n        \n        T_values = T_func(x_grid)\n        T_prime_ref = T_prime_func(x_grid)\n\n        # Compute numerical derivative\n        T_prime_num = spectral_derivative(T_values, N)\n\n        # Compute error field\n        error = T_prime_num - T_prime_ref\n\n        # Compute L2 and Linf error norms\n        l2_error = np.sqrt(np.sum(error**2) * delta_x)\n        linf_error = np.max(np.abs(error))\n\n        results.append(f\"{l2_error:.8f}\")\n        results.append(f\"{linf_error:.8f}\")\n    \n    # Print the final output in the required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "傅里叶方法是处理周期性区域的理想选择，但许多实际工程问题涉及物理边界（即“壁面”）。对于这类非周期性问题，切比雪夫谱方法是首选工具。本练习将指导您构建并应用切比雪夫微分矩阵来计算温度梯度，特别是关注工程中至关重要的物理量——壁面热通量。",
            "id": "3946956",
            "problem": "考虑一个无量纲的一维导热域 $y \\in [-1,1]$，其热导率设为1。根据傅里叶热传导定律，壁面法向热通量由 $q_y(y) = -\\partial_y T(y)$ 给出。在使用谱方法的直接数值模拟中，Chebyshev–Gauss–Lobatto 配置法是近似导数的标准方法。Chebyshev–Gauss–Lobatto 节点为 $y_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j = 0,1,\\dots,N$，$N$ 是多项式阶数。定义交替权重 $c_j = (-1)^j \\, w_j$，其中 $w_0 = w_N = 2$，$w_j = 1$ ($1 \\le j \\le N-1$)。Chebyshev 一阶微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 满足\n$$\nD_{ij} = \\begin{cases}\n\\frac{c_i}{c_j} \\, \\frac{1}{y_i - y_j},  i \\ne j, \\\\\n-\\sum_{k\\ne i} D_{ik},  i = j,\n\\end{cases}\n$$\n由此可得谱配置近似 $\\left.\\frac{dT}{dy}\\right|_{y=y_i} \\approx \\sum_{j=0}^{N} D_{ij} \\, T(y_j)$，其中 $i=0,\\dots,N$。\n\n您的任务是实现一个程序，该程序为给定的 $N$ 构建 $D$，在 Chebyshev–Gauss–Lobatto 节点上计算指定的解析温度分布 $T(y)$，通过矩阵-向量乘法计算所有节点上 $\\partial_y T$ 的谱近似值，提取壁面 $y=+1$ 和 $y=-1$ 处的法向热通量，并将其与从 $T(y)$ 的已知导数获得的精确解析通量进行比较。热导率为1，因此请以无量纲单位报告通量和误差。所有的三角函数求值都必须使用弧度作为角度单位。对于每个测试用例，报告的数值误差必须是 $y=+1$ 和 $y=-1$ 两处绝对误差的最大值，即\n$$\n\\varepsilon = \\max\\left( \\left| q_y^{\\text{num}}(+1) - q_y^{\\text{exact}}(+1) \\right|, \\, \\left| q_y^{\\text{num}}(-1) - q_y^{\\text{exact}}(-1) \\right| \\right),\n$$\n其中 $q_y^{\\text{num}}(\\pm 1)$ 通过 Chebyshev 微分获得，$q_y^{\\text{exact}}(\\pm 1)$ 通过解析导数获得。\n\n使用以下测试套件，它涵盖了一组有代表性的解析分布和分辨率：\n- 案例1（多项式，理想情况）：$T(y) = y^4$，$N=8$。\n- 案例2（指数函数，中等梯度）：$T(y) = \\exp(3 y)$，$N=24$。\n- 案例3（双曲余弦，中等分辨率）：$T(y) = \\cosh(5 y)$，$N=16$。\n- 案例4（正弦函数，以弧度为单位，小 $N$）：$T(y) = \\sin(\\pi y)$，$N=8$。\n- 案例5（指数函数，陡峭梯度）：$T(y) = \\exp(10 y)$，$N=32$。\n\n对每个案例，计算并返回如上定义的单个浮点数 $\\varepsilon$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[result_1,result_2,\\dots]$）。由于所有量都是无量纲的，因此输出中不需要物理单位；整个计算过程中角度必须以弧度处理。",
            "solution": "该问题是有效的，因为它基于傅里叶热传导定律的原理和已建立的 Chebyshev 谱配置法数值技术，具有科学依据。该问题是适定的、客观的，并包含了推导唯一、可验证解所需的所有信息。我们开始求解。\n\n问题的核心是使用 Chebyshev 谱方法计算一维域 $y \\in [-1, 1]$ 边界处的温度梯度 $\\partial_y T$，并将所得热通量与精确的解析解进行比较。在热导率为1的情况下，热通量根据傅里叶定律定义为 $q_y(y) = -\\partial_y T(y)$。\n\n**步骤1：使用 Chebyshev–Gauss–Lobatto 节点进行域离散化**\n\n谱方法要求在特定的点集（即节点）上对函数进行求值。对于此问题，我们使用 Chebyshev–Gauss–Lobatto (CGL) 节点，它们是 N 阶第一类 Chebyshev 多项式的极值点。这些节点分布在区间 $[-1, 1]$ 内，由公式给出：\n$$y_j = \\cos\\left(\\frac{\\pi j}{N}\\right) \\quad \\text{for } j = 0, 1, \\dots, N$$\n其中 $N$ 是多项式阶数。这组 $N+1$ 个节点包括了边界点，因为 $y_0 = \\cos(0) = 1$ 和 $y_N = \\cos(\\pi) = -1$。这些节点不是均匀分布的；它们在边界 $y=\\pm 1$ 附近聚集，这一特性对于解析输运现象中经常遇到的陡峭梯度或边界层非常有利。\n\n**步骤2：构建 Chebyshev 微分矩阵**\n\n一个由其在 CGL 节点上的值所表示的函数的谱导数，是通过与一个 Chebyshev 微分矩阵 $D$ 相乘来计算的。这个矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 的构建方法如下。\n\n首先，我们为每个节点 $j$ 定义一组交替权重 $c_j$：\n$$c_j = (-1)^j \\, w_j$$\n其中权重 $w_j$ 由 $w_0 = w_N = 2$ 和 $w_j = 1$ ($1 \\le j \\le N-1$) 给出。\n\n然后定义微分矩阵 $D$ 的元素。非对角元素为：\n$$D_{ij} = \\frac{c_i}{c_j} \\, \\frac{1}{y_i - y_j} \\quad \\text{for } i \\ne j$$\n对角元素由常数函数的导数必须为零的条件确定。如果我们将常数函数 $f(y)=k$ 表示为向量 $\\mathbf{f} = [k, k, \\dots, k]^T$，其导数向量必须为 $\\mathbf{0}$。数值导数为 $D\\mathbf{f} = k(D\\mathbf{1})$，其中 $\\mathbf{1}$ 是一个全1向量。为了使 $D\\mathbf{1}$ 为零，每行元素的总和必须为零：$\\sum_{j=0}^{N} D_{ij} = 0$。这给出了对角元素的公式：\n$$D_{ii} = -\\sum_{k=0, k\\ne i}^{N} D_{ik}$$\n这种构造确保了微分矩阵对于阶数不高于 $N$ 的任何多项式都是精确的。\n\n**步骤3：近似温度梯度和热通量**\n\n设解析温度分布为 $T(y)$。我们首先在 CGL 节点上计算该函数的值，以获得一个离散的温度向量 $\\mathbf{T}$：\n$$\\mathbf{T} = [T(y_0), T(y_1), \\dots, T(y_N)]^T$$\n然后通过矩阵-向量乘积得到每个节点上温度梯度的谱近似：\n$$\n\\begin{pmatrix}\n (dT/dy)|_{y_0} \\\\\n (dT/dy)|_{y_1} \\\\\n \\vdots \\\\\n (dT/dy)|_{y_N}\n\\end{pmatrix}_{\\text{num}}\n\\approx D \\mathbf{T}\n$$\n随后，应用傅里叶定律可以找到数值热通量向量 $\\mathbf{q}_y^{\\text{num}}$：\n$$\\mathbf{q}_y^{\\text{num}} = - D \\mathbf{T}$$\n\n**步骤4：评估壁面热通量和数值误差**\n\n主要目标是评估位于 $y = +1$ 和 $y = -1$ 处的壁面热通量。这些位置分别对应于节点 $y_0$ 和 $y_N$。\n\n数值壁面通量是向量 $\\mathbf{q}_y^{\\text{num}}$ 的第一个和最后一个分量：\n$$q_y^{\\text{num}}(+1) = - (D \\mathbf{T})_0$$\n$$q_y^{\\text{num}}(-1) = - (D \\mathbf{T})_N$$\n\n为了评估这种近似的准确性，我们将这些数值与从温度分布的解析导数 $T'(y) = \\frac{dT}{dy}$ 推导出的精确通量进行比较。精确通量为：\n$$q_y^{\\text{exact}}(+1) = -T'(1)$$\n$$q_y^{\\text{exact}}(-1) = -T'(-1)$$\n\n每个测试用例的最终误差 $\\varepsilon$ 定义为两个壁面上绝对误差的最大值：\n$$\\varepsilon = \\max\\left( \\left| q_y^{\\text{num}}(+1) - q_y^{\\text{exact}}(+1) \\right|, \\, \\left| q_y^{\\text{num}}(-1) - q_y^{\\text{exact}}(-1) \\right| \\right)$$\n\n此过程应用于每个测试用例，方法是代入相应的函数 $T(y)$、其解析导数 $T'(y)$ 和指定的多项式阶数 $N$。例如，在案例1中，$T(y)=y^4$ 且 $N=8$，解析导数为 $T'(y)=4y^3$。由于多项式的阶数（4）小于或等于 $N=8$，谱微分是精确的，误差 $\\varepsilon$ 预计在机器精度的量级上。对于非多项式函数，误差将是有限的，并且会随着 $N$ 的增加而迅速减小（谱收敛）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the (N+1)x(N+1) Chebyshev differentiation matrix.\n    \n    Args:\n        N (int): The polynomial degree.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the differentiation \n                                       matrix D and the node locations y.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.]]), np.array([0.])\n    \n    # Chebyshev-Gauss-Lobatto nodes\n    j = np.arange(N + 1)\n    y = np.cos(np.pi * j / N)\n    \n    # Alternating weights\n    w = np.ones(N + 1)\n    w[0] = w[N] = 2.0\n    c = (-1)**j * w\n    \n    # Tile y and c for vectorized computation of off-diagonal elements\n    y_col = y[:, np.newaxis]\n    y_row = y[np.newaxis, :]\n    c_col = c[:, np.newaxis]\n    c_row = c[np.newaxis, :]\n    \n    # Compute off-diagonal elements\n    diff = y_col - y_row\n    # Add identity to avoid division by zero on the diagonal\n    diff += np.identity(N + 1)\n    \n    D = (c_col / c_row) / diff\n    \n    # Set diagonal elements to zero, as they were placeholders\n    np.fill_diagonal(D, 0)\n    \n    # Compute diagonal elements from row-sum condition\n    D_diag = -np.sum(D, axis=1)\n    np.fill_diagonal(D, D_diag)\n    \n    return D, y\n\ndef calculate_wall_flux_error(N, T_func, T_prime_func):\n    \"\"\"\n    Computes the maximum absolute error of the wall-normal heat flux.\n    \n    Args:\n        N (int): The polynomial degree.\n        T_func (callable): The analytic temperature profile T(y).\n        T_prime_func (callable): The analytic derivative T'(y).\n        \n    Returns:\n        float: The maximum error epsilon.\n    \"\"\"\n    # Construct the differentiation matrix and nodes\n    D, y = compute_chebyshev_diff_matrix(N)\n    \n    # Evaluate temperature at the nodes\n    T_at_nodes = T_func(y)\n    \n    # Compute the numerical derivative via matrix-vector product\n    dT_dy_num = D @ T_at_nodes\n    \n    # The walls are at y = +1 (node 0) and y = -1 (node N)\n    # Numerical heat flux q = -dT/dy\n    q_num_p1 = -dT_dy_num[0]\n    q_num_m1 = -dT_dy_num[N]\n    \n    # Exact heat flux\n    q_exact_p1 = -T_prime_func(1.0)\n    q_exact_m1 = -T_prime_func(-1.0)\n    \n    # Calculate errors at each wall\n    error_p1 = np.abs(q_num_p1 - q_exact_p1)\n    error_m1 = np.abs(q_num_m1 - q_exact_m1)\n    \n    # Return the maximum of the two errors\n    return np.maximum(error_p1, error_m1)\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: polynomial, happy path\n        {'N': 8, 'T': lambda y: y**4, 'Tp': lambda y: 4 * y**3, 'name': 'y^4, N=8'},\n        # Case 2: exponential, moderate gradient\n        {'N': 24, 'T': lambda y: np.exp(3 * y), 'Tp': lambda y: 3 * np.exp(3 * y), 'name': 'exp(3y), N=24'},\n        # Case 3: hyperbolic cosine, moderate resolution\n        {'N': 16, 'T': lambda y: np.cosh(5 * y), 'Tp': lambda y: 5 * np.sinh(5 * y), 'name': 'cosh(5y), N=16'},\n        # Case 4: sine in radians, small N\n        {'N': 8, 'T': lambda y: np.sin(np.pi * y), 'Tp': lambda y: np.pi * np.cos(np.pi * y), 'name': 'sin(pi*y), N=8'},\n        # Case 5: exponential, steep gradient\n        {'N': 32, 'T': lambda y: np.exp(10 * y), 'Tp': lambda y: 10 * np.exp(10 * y), 'name': 'exp(10y), N=32'},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = calculate_wall_flux_error(case['N'], case['T'], case['Tp'])\n        results.append(f\"{error:.16e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从简单的标量方程过渡到复杂的流体动力学纳维-斯托克斯方程，会引入一个核心挑战：如何满足不可压缩性约束（即速度场的散度为零，$ \\nabla \\cdot \\mathbf{u} = 0 $）。压力修正法是解决这一问题的经典算法。本实践将带您完成直接数值模拟中的一个完整时间步，通过量化中间速度场的散度并在修正后验证其消除，来直观地展示一个非无散场是如何通过“投影”操作恢复其物理上的不可压缩性的。",
            "id": "3946876",
            "problem": "给定二维空间中的不可压缩Navier–Stokes方程，用于描述一个速度场 $\\mathbf{u}(x,y,t)$ 和一个压力场 $p(x,y,t)$，方程为无量纲形式，定义在一个方形周期性域上：\n$$\n\\mathbf{u}_t + \\mathbf{N}(\\mathbf{u}) = -\\nabla p + \\nu \\nabla^2 \\mathbf{u},\\qquad \\nabla\\cdot\\mathbf{u}=0,\n$$\n其中 $\\mathbf{N}(\\mathbf{u})$ 表示非线性对流算子，$\\nu$ 是运动粘度。任务是在Fourier伪谱离散化框架内，实现增量压力修正法的单个时间步，并量化投影过程如何消除中间速度中产生的散度。\n\n仅从基本原理出发，实现以下内容：\n\n- 在周期性域 $[0,2\\pi]^2$ 上使用Fourier伪谱离散化，网格点为 $N\\times N$ 个均匀间隔的点。设 $N$ 为正整数，网格间距满足 $dx=dy=2\\pi/N$。使用标准的离散Fourier变换，其波数为整数值且与 $[0,2\\pi]$ 周期性一致。\n\n- 通过流函数 $\\psi(x,y)$ 构建一个无散度的初始速度场，使得 $\\mathbf{u}=\\nabla^\\perp\\psi$，即 $\\mathbf{u}(x,y,0)=\\left(\\partial_y\\psi,-\\partial_x\\psi\\right)$。取 $\\psi(x,y)=\\sin(x)\\sin(y)$。所有物理量均为无量纲。\n\n- 在物理空间中将非线性对流算子 $\\mathbf{N}(\\mathbf{u})$ 离散为 $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$，使用谱导数计算 $\\nabla\\mathbf{u}$，然后计算逐点乘积并变换回Fourier空间。对Fourier空间中的非线性项应用经典的2/3去混叠规则，即将 $|k_x|N/3$ 或 $|k_y|N/3$ 的模态置零。\n\n- 对忽略压力项的中间速度 $\\mathbf{u}^\\star$ 执行单个显式前向Euler步。然后执行增量压力修正（投影）以获得满足离散不可压缩约束的 $\\mathbf{u}^{n+1}$。仅使用基本控制方程和周期性谱表示来推导压力增量和投影算子的必要关系式；不要使用任何预先给定的公式。\n\n- 使用标量散度场的离散 $L^2$ 范数量化散度，其定义为\n$$\n\\|\\nabla\\cdot\\mathbf{v}\\|_{2}=\\left(\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1} \\left(\\nabla\\cdot\\mathbf{v}(x_j,y_k)\\right)^2\\,dx\\,dy\\right)^{1/2},\n$$\n对于在相应时间的速度场 $\\mathbf{v}$。每个测试用例报告三个量：初始速度 $\\mathbf{u}^n$ 的散度的离散 $L^2$ 范数、中间速度 $\\mathbf{u}^\\star$ 的散度的离散 $L^2$ 范数，以及投影后速度 $\\mathbf{u}^{n+1}$ 的散度的离散 $L^2$ 范数。\n\n您的程序必须为以下参数集测试套件生成结果，每个参数集均以无量纲单位表示：\n\n- 测试 1：$N=64$, $\\Delta t=10^{-3}$, $\\nu=10^{-3}$，激活非线性对流项。\n- 测试 2：$N=64$, $\\Delta t=10^{-6}$, $\\nu=10^{-3}$，激活非线性对流项。\n- 测试 3：$N=64$, $\\Delta t=5\\times 10^{-3}$, $\\nu=0$，激活非线性对流项。\n- 测试 4：$N=64$, $\\Delta t=10^{-3}$, $\\nu=10^{-3}$，禁用非线性对流项（即，取 $\\mathbf{N}(\\mathbf{u})=\\mathbf{0}$）。\n\n对于每个测试用例，程序必须计算并输出一个包含三个实数（每个为浮点数）的列表：$[\\|\\nabla\\cdot\\mathbf{u}^n\\|_2,\\ \\|\\nabla\\cdot\\mathbf{u}^\\star\\|_2,\\ \\|\\nabla\\cdot\\mathbf{u}^{n+1}\\|_2]$。\n\n最终输出格式要求：\n\n- 您的程序应生成单行输出，其中包含一个列表的列表，每个子列表对应一个测试用例，其中包含上述顺序的三个浮点数。格式必须与以下完全一致：\n$$\n[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]],\n$$\n其中每个 $a_i$、$b_i$ 和 $c_i$ 都是十进制数。\n\n所有计算都应以无量纲单位进行。角度以弧度为单位。程序不应需要外部输入，必须是自包含的，并可在现代环境中运行。实现的核心必须遵循控制方程和谱表示，而不是依赖预先给定的简化公式。",
            "solution": "出发点是不可压缩的Navier–Stokes方程\n$$\n\\mathbf{u}_t + \\mathbf{N}(\\mathbf{u}) = -\\nabla p + \\nu \\nabla^2 \\mathbf{u},\\qquad \\nabla\\cdot\\mathbf{u}=0,\n$$\n定义在一个周期性域上。增量压力修正法的步骤是：首先生成一个不含压力项的中间速度，然后使用从Poisson问题计算出的标量压力增量对其进行修正，以强制执行无散度约束。该推导仅依赖于方程、周期性边界条件和标准的谱恒等式。\n\n基本基底与表示：\n\n- 在具有 $N\\times N$ 个网格点的 $[0,2\\pi]^2$ 周期性域中，使用与 $2\\pi$ 周期区间上的离散Fourier变换一致的整数谱波数 $k_x$ 和 $k_y$。用帽子符号表示场的离散Fourier变换，例如 $\\widehat{u_x}(k_x,k_y)$。\n\n- 谱微分恒等式是已知的：对于每个模态 $(k_x,k_y)$，$\\partial_x$ 对应于乘以 $\\mathrm{i}k_x$，$\\partial_y$ 对应于乘以 $\\mathrm{i}k_y$，拉普拉斯算子 $\\nabla^2$ 对应于乘以 $-(k_x^2+k_y^2)$。\n\n- Fourier空间中的散度为 $\\widehat{\\nabla\\cdot\\mathbf{u}}=\\mathrm{i}k_x\\widehat{u_x}+\\mathrm{i}k_y\\widehat{u_y}$，其逆变换得到 $\\nabla\\cdot\\mathbf{u}(x,y)$。\n\n通过流函数进行无散度初始化：\n\n- 令流函数为 $\\psi(x,y)=\\sin(x)\\sin(y)$。定义初始速度为 $\\mathbf{u}(x,y,0)=\\left(\\partial_y\\psi,-\\partial_x\\psi\\right)=\\left(\\cos(y)\\sin(x),-\\cos(x)\\sin(y)\\right)$，根据构造，该速度场是无散度的，因为 $\\nabla\\cdot\\nabla^\\perp\\psi=0$。\n\n非线性项与伪谱计算：\n\n- 非线性对流算子为 $\\mathbf{N}(\\mathbf{u})=(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$。其$x$分量是 $N_x=u_x\\partial_x u_x+u_y\\partial_y u_x$，其$y$分量是 $N_y=u_x\\partial_x u_y+u_y\\partial_y u_y$。\n\n- 在Fourier空间中，通过将 $\\widehat{u_x}$ 和 $\\widehat{u_y}$ 乘以 $\\mathrm{i}k_x$ 或 $\\mathrm{i}k_y$ 来计算 $\\partial_x u_x$、$\\partial_y u_x$、$\\partial_x u_y$ 和 $\\partial_y u_y$，然后变换到物理空间以形成定义 $N_x$ 和 $N_y$ 的乘积。将 $N_x$ 和 $N_y$ 变换回Fourier空间。对非线性项应用2/3去混叠规则，即将 $|k_x|N/3$ 或 $|k_y|N/3$ 的Fourier模态置零。这遵循了在二次非线性的伪谱计算中控制混叠误差的成熟方法。\n\n无压力项的中间步骤：\n\n- 使用前向Euler步对中间速度 $\\mathbf{u}^\\star$ 进行显式时间离散。记 $\\Delta t$ 为时间步长。从不含压力项的动量方程出发，Fourier空间中的中间更新公式为\n$$\n\\widehat{\\mathbf{u}^\\star} = \\widehat{\\mathbf{u}^n} + \\Delta t\\left(-\\widehat{\\mathbf{N}(\\mathbf{u}^n)} + \\nu \\widehat{\\nabla^2 \\mathbf{u}^n}\\right),\n$$\n其中 $\\widehat{\\nabla^2 \\mathbf{u}^n}=-(k_x^2+k_y^2)\\widehat{\\mathbf{u}^n}$。\n\n- 中间速度通常不满足 $\\nabla\\cdot\\mathbf{u}^\\star=0$，因为负责强制不可压缩性的压力项被忽略了。\n\n通过Helmholtz分解进行增量压力修正：\n\n- 在周期性域中，向量场 $\\mathbf{u}^\\star$ 可以唯一地分解为一个无散度部分和一个标量势的梯度：\n$$\n\\mathbf{u}^\\star = \\mathbf{u}^{n+1} + \\Delta t \\nabla \\phi,\n$$\n其中 $\\nabla\\cdot\\mathbf{u}^{n+1}=0$，$\\phi$ 是增量压力除以密度（在无量纲形式下）。对该分解式取散度，\n$$\n\\nabla\\cdot\\mathbf{u}^\\star = \\Delta t \\nabla^2 \\phi,\n$$\n这导出了一个关于压力增量的Poisson方程，\n$$\n\\nabla^2 \\phi = \\frac{1}{\\Delta t}\\nabla\\cdot\\mathbf{u}^\\star.\n$$\n\n- 在Fourier空间中，对于非零模态，此Poisson方程简化为\n$$\n-(k_x^2+k_y^2)\\widehat{\\phi} = \\frac{1}{\\Delta t}\\left(\\mathrm{i}k_x\\widehat{u^\\star_x}+\\mathrm{i}k_y\\widehat{u^\\star_y}\\right),\n$$\n因此对于 $(k_x,k_y)\\neq(0,0)$，\n$$\n\\widehat{\\phi} = -\\frac{\\mathrm{i}k_x\\widehat{u^\\star_x}+\\mathrm{i}k_y\\widehat{u^\\star_y}}{(k_x^2+k_y^2)\\Delta t}.\n$$\n零模态 $\\widehat{\\phi}(0,0)$ 在相差一个可加常数的意义下是不确定的，可以设为0。\n\n- 然后通过减去压力增量的梯度来获得修正后的速度：\n$$\n\\widehat{\\mathbf{u}^{n+1}} = \\widehat{\\mathbf{u}^\\star} - \\Delta t\\,\\mathrm{i}\\mathbf{k}\\,\\widehat{\\phi}.\n$$\n结合前面的关系式，可得到熟悉的、投影到无散度场上的Fourier空间Leray投影算子：\n$$\n\\widehat{\\mathbf{u}^{n+1}} = \\left(\\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^\\top}{\\|\\mathbf{k}\\|^2}\\right)\\widehat{\\mathbf{u}^\\star},\n$$\n对于 $(k_x,k_y)\\neq(0,0)$，其中 $\\mathbf{k}=(k_x,k_y)$ 且 $\\mathbf{I}$ 是单位矩阵。这个构造直接源于Helmholtz分解和Poisson方程的解，除了谱表示和控制方程外，不需要任何简化公式。在零模态处，设置 $\\widehat{\\mathbf{u}^{n+1}}=\\widehat{\\mathbf{u}^\\star}$，因为 $\\mathbf{k}=\\mathbf{0}$ 会使投影不确定，但常数模态的散度为零。\n\n散度量化：\n\n- 对于任意速度场 $\\mathbf{v}$，在Fourier空间中计算散度为 $\\widehat{\\nabla\\cdot\\mathbf{v}}=\\mathrm{i}k_x\\widehat{v_x}+\\mathrm{i}k_y\\widehat{v_y}$，进行逆变换得到 $\\nabla\\cdot\\mathbf{v}(x,y)$，然后计算离散 $L^2$ 范数\n$$\n\\|\\nabla\\cdot\\mathbf{v}\\|_{2}=\\left(\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1} \\left(\\nabla\\cdot\\mathbf{v}(x_j,y_k)\\right)^2\\,dx\\,dy\\right)^{1/2},\n$$\n其中 $dx=dy=2\\pi/N$。\n\n每个测试用例的算法步骤：\n\n1. 设置网格 $x_j=j\\,dx$ 和 $y_k=k\\,dy$（其中 $j,k\\in\\{0,\\dots,N-1\\}$, $dx=dy=2\\pi/N$），并通过将离散Fourier频率函数缩放为整数波数得到Fourier波数 $k_x$ 和 $k_y$。\n\n2. 从流函数在物理空间中初始化速度场 $\\mathbf{u}^n$，然后计算其Fourier变换 $\\widehat{u_x^n}$ 和 $\\widehat{u_y^n}$。\n\n3. 计算谱导数以在物理空间中获得 $\\partial_x \\mathbf{u}^n$ 和 $\\partial_y \\mathbf{u}^n$，构建非线性项 $(\\mathbf{u}^n\\cdot\\nabla)\\mathbf{u}^n$，将其变换到Fourier空间，并应用2/3去混叠滤波器。\n\n4. 计算 $\\widehat{\\nabla^2 \\mathbf{u}^n}=-(k_x^2+k_y^2)\\widehat{\\mathbf{u}^n}$。\n\n5. 构建中间速度 $\\widehat{\\mathbf{u}^\\star}=\\widehat{\\mathbf{u}^n}+\\Delta t\\left(-\\widehat{\\mathbf{N}(\\mathbf{u}^n)}+\\nu\\widehat{\\nabla^2\\mathbf{u}^n}\\right)$。\n\n6. 计算 $\\|\\nabla\\cdot\\mathbf{u}^n\\|_2$ 和 $\\|\\nabla\\cdot\\mathbf{u}^\\star\\|_2$。\n\n7. 使用Fourier空间投影算子将 $\\widehat{\\mathbf{u}^\\star}$ 投影到无散度子空间上，以获得 $\\widehat{\\mathbf{u}^{n+1}}$。\n\n8. 计算 $\\|\\nabla\\cdot\\mathbf{u}^{n+1}\\|_2$。\n\n测试套件覆盖范围：\n\n- 测试 1 使用 $N=64$, $\\Delta t=10^{-3}$, $\\nu=10^{-3}$，并激活对流项，代表一个典型的直接数值模拟步骤。\n\n- 测试 2 使用一个非常小的时间步 $\\Delta t=10^{-6}$，以检查极限行为和数值舍入误差的影响。\n\n- 测试 3 设置 $\\nu=0$（无粘）和 $\\Delta t=5\\times 10^{-3}$，以在没有扩散的情况下，重点关注对流非线性以及投影的作用。\n\n- 测试 4 禁用非线性项，只留下扩散项；由于 $\\nabla^2$ 与散度算子可交换，且初始场是无散度的，因此预期中间散度在数值精度范围内将保持接近于零。\n\n程序为每个测试用例输出一个包含三个浮点数的列表 $[\\|\\nabla\\cdot\\mathbf{u}^n\\|_2,\\ \\|\\nabla\\cdot\\mathbf{u}^\\star\\|_2,\\ \\|\\nabla\\cdot\\mathbf{u}^{n+1}\\|_2]$。汇总成单行，总输出是这些列表的列表，严格遵循要求的格式。投影步骤必须将散度范数从中间值减小到接近机器精度的值，从而证明通过从控制方程和谱表示推导出的投影过程消除了散度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef spectral_wavenumbers(N):\n    \"\"\"\n    Return 2D arrays of integer Fourier wavenumbers kx, ky and k^2 for a 2π-periodic domain.\n    \"\"\"\n    k1d = np.fft.fftfreq(N) * N  # integer wavenumbers consistent with 2π periodicity\n    kx, ky = np.meshgrid(k1d, k1d, indexing='ij')\n    k2 = kx**2 + ky**2\n    return kx, ky, k2\n\ndef dealias_mask(N):\n    \"\"\"\n    2/3-rule dealiasing mask: keep modes with |k|= N/3 in each direction.\n    \"\"\"\n    k1d = np.fft.fftfreq(N) * N\n    kx, ky = np.meshgrid(k1d, k1d, indexing='ij')\n    cutoff = N // 3\n    mask = (np.abs(kx) = cutoff)  (np.abs(ky) = cutoff)\n    return mask\n\ndef streamfunction_initial_u(N):\n    \"\"\"\n    Construct divergence-free initial velocity from psi = sin(x) sin(y).\n    u = (∂ψ/∂y, -∂ψ/∂x) = (cos(y) sin(x), -cos(x) sin(y))\n    \"\"\"\n    L = 2.0 * np.pi\n    x = np.linspace(0.0, L, N, endpoint=False)\n    y = np.linspace(0.0, L, N, endpoint=False)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    ux = np.cos(Y) * np.sin(X)\n    uy = -np.cos(X) * np.sin(Y)\n    return ux, uy\n\ndef fft2(field):\n    return np.fft.fft2(field)\n\ndef ifft2(field_hat):\n    return np.fft.ifft2(field_hat)\n\ndef compute_divergence_norm(ux_hat, uy_hat, kx, ky, dx, dy):\n    \"\"\"\n    Compute L2 norm of divergence: ||∇·u||_2 over the domain using discrete sum.\n    \"\"\"\n    div_hat = 1j * kx * ux_hat + 1j * ky * uy_hat\n    div = np.real(ifft2(div_hat))\n    norm = np.sqrt(np.sum(div**2) * dx * dy)\n    return norm\n\ndef compute_nonlinear_term_hat(ux_hat, uy_hat, kx, ky, N, mask):\n    \"\"\"\n    Compute (u · ∇) u pseudo-spectrally with 2/3-rule dealiasing.\n    \"\"\"\n    # Spectral derivatives of u components\n    dux_dx_hat = 1j * kx * ux_hat\n    dux_dy_hat = 1j * ky * ux_hat\n    duy_dx_hat = 1j * kx * uy_hat\n    duy_dy_hat = 1j * ky * uy_hat\n\n    # Transform derivatives to physical space\n    dux_dx = np.real(ifft2(dux_dx_hat))\n    dux_dy = np.real(ifft2(dux_dy_hat))\n    duy_dx = np.real(ifft2(duy_dx_hat))\n    duy_dy = np.real(ifft2(duy_dy_hat))\n\n    # Velocity in physical space\n    ux = np.real(ifft2(ux_hat))\n    uy = np.real(ifft2(uy_hat))\n\n    # Nonlinear term in physical space\n    Nx = ux * dux_dx + uy * dux_dy\n    Ny = ux * duy_dx + uy * duy_dy\n\n    # Transform back to Fourier space\n    Nx_hat = fft2(Nx)\n    Ny_hat = fft2(Ny)\n\n    # Apply 2/3 de-aliasing to nonlinear term\n    Nx_hat = Nx_hat * mask\n    Ny_hat = Ny_hat * mask\n\n    return Nx_hat, Ny_hat\n\ndef incremental_pressure_correction_step(N, dt, nu, nonlinear_active=True):\n    \"\"\"\n    Perform one incremental pressure correction step for given parameters.\n    Returns divergence norms: [||div u^n||2, ||div u*||2, ||div u^{n+1}||2].\n    \"\"\"\n    # Grid and spectral wavenumbers\n    L = 2.0 * np.pi\n    dx = L / N\n    dy = L / N\n    kx, ky, k2 = spectral_wavenumbers(N)\n    mask = dealias_mask(N)\n\n    # Initial velocity from streamfunction\n    ux, uy = streamfunction_initial_u(N)\n\n    # Fourier transforms of initial velocity\n    ux_hat = fft2(ux)\n    uy_hat = fft2(uy)\n\n    # Divergence norm of initial velocity\n    divn = compute_divergence_norm(ux_hat, uy_hat, kx, ky, dx, dy)\n\n    # Nonlinear term\n    if nonlinear_active:\n        Nx_hat, Ny_hat = compute_nonlinear_term_hat(ux_hat, uy_hat, kx, ky, N, mask)\n    else:\n        Nx_hat = np.zeros_like(ux_hat)\n        Ny_hat = np.zeros_like(uy_hat)\n\n    # Diffusion term in spectral space: nu * ∇^2 u = -nu * k^2 * u_hat\n    lap_ux_hat = -k2 * ux_hat\n    lap_uy_hat = -k2 * uy_hat\n\n    # Intermediate velocity u* via explicit Euler: u* = u^n + dt * ( -N(u^n) + nu ∇^2 u^n )\n    ux_star_hat = ux_hat + dt * (-Nx_hat + nu * lap_ux_hat)\n    uy_star_hat = uy_hat + dt * (-Ny_hat + nu * lap_uy_hat)\n\n    # Divergence norm of intermediate velocity\n    div_star = compute_divergence_norm(ux_star_hat, uy_star_hat, kx, ky, dx, dy)\n\n    # Projection to divergence-free subspace in Fourier space (Leray projector)\n    # For k != 0: u^{n+1}_hat = u*_hat - k (k · u*_hat) / |k|^2\n    # Handle k^2 = 0 (zero mode) separately.\n    u_dot_k_hat = kx * ux_star_hat + ky * uy_star_hat\n    # Avoid division by zero: create factor with zeros where k2 == 0\n    factor = np.zeros_like(u_dot_k_hat, dtype=np.complex128)\n    nonzero = k2 != 0\n    factor[nonzero] = u_dot_k_hat[nonzero] / k2[nonzero]\n    ux_new_hat = ux_star_hat - kx * factor\n    uy_new_hat = uy_star_hat - ky * factor\n\n    # Divergence norm of projected velocity\n    div_new = compute_divergence_norm(ux_new_hat, uy_new_hat, kx, ky, dx, dy)\n\n    return [divn, div_star, div_new]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, dt, nu, nonlinear_active)\n    test_cases = [\n        (64, 1e-3, 1e-3, True),     # Test 1\n        (64, 1e-6, 1e-3, True),     # Test 2\n        (64, 5e-3, 0.0, True),      # Test 3\n        (64, 1e-3, 1e-3, False),    # Test 4\n    ]\n\n    results = []\n    for N, dt, nu, nonlinear_active in test_cases:\n        norms = incremental_pressure_correction_step(N, dt, nu, nonlinear_active)\n        # Convert to Python floats for clean printing\n        results.append([float(norms[0]), float(norms[1]), float(norms[2])])\n\n    # Final print statement in the exact required format: one single line, list of lists.\n    print(f\"[{','.join([str(item) for item in results])}]\")\n\nsolve()\n```"
        }
    ]
}