{
    "hands_on_practices": [
        {
            "introduction": "This exercise bridges the gap between fundamental chemical principles and numerical computation. By deriving the charge balance function for an aqueous system and implementing a robust bracketing algorithm, you will build a foundational understanding of how geochemical equilibrium problems are formulated and solved as a single non-linear equation . The bisection method, while simple, guarantees convergence once a root is bracketed, making it an indispensable tool for analysis and as a fallback for more complex solvers.",
            "id": "4094375",
            "problem": "Consider an aqueous solution at temperature $25\\,^{\\circ}\\mathrm{C}$ containing weak acid-base systems and strong electrolytes. The goal is to numerically solve an electroneutrality condition expressed as a non-linear algebraic equation in terms of the acidity $\\mathrm{pH}$. The fundamental starting point is the principle of electroneutrality, which states that the sum of positive charges equals the sum of negative charges at equilibrium, along with equilibrium mass-action relationships and total mass-balance constraints for the acid-base systems. Assume ideal solution behavior so that chemical activities are approximated by molar concentrations.\n\nLet the weak acid system be the inorganic carbon system $\\mathrm{H_{2}CO_{3}^{*}}/\\mathrm{HCO_{3}^{-}}/\\mathrm{CO_{3}^{2-}}$ with first and second acid dissociation constants denoted $K_{1}$ and $K_{2}$, respectively. Let the autoprotolysis of water be characterized by the ionic product $K_{w}$. All constants are at $25\\,^{\\circ}\\mathrm{C}$:\n- $K_{1} = 10^{-6.3}$,\n- $K_{2} = 10^{-10.3}$,\n- $K_{w} = 10^{-14}$.\n\nDefine the total concentration of Dissolved Inorganic Carbon (DIC) as $C_{\\mathrm{T}}$ in $\\mathrm{mol/L}$, and the total concentrations of strong electrolyte ions sodium and chloride as $C_{\\mathrm{Na}}$ and $C_{\\mathrm{Cl}}$ in $\\mathrm{mol/L}$, respectively. Treat sodium and chloride as fully dissociated.\n\nFor a given $\\mathrm{pH}$, denote $H = [\\mathrm{H^{+}}] = 10^{-\\mathrm{pH}}$ and $[\\mathrm{OH^{-}}] = K_{w}/H$. Using mass-action and conservation for the carbonate system, the species concentrations $[\\mathrm{H_{2}CO_{3}^{*}}]$, $[\\mathrm{HCO_{3}^{-}}]$, and $[\\mathrm{CO_{3}^{2-}}]$ are functions of $H$, $K_{1}$, $K_{2}$, and $C_{\\mathrm{T}}$ obtainable from the dissociation equilibria and total $C_{\\mathrm{T}}$ constraint. Construct the electroneutrality function $f(\\mathrm{pH})$ as the difference between the sum of positive charges and the sum of negative charges,\n$$\nf(\\mathrm{pH}) = \\left( [\\mathrm{H^{+}}] + C_{\\mathrm{Na}} \\right) - \\left( [\\mathrm{OH^{-}}] + C_{\\mathrm{Cl}} + [\\mathrm{HCO_{3}^{-}}] + 2[\\mathrm{CO_{3}^{2-}}] \\right),\n$$\nexpressed entirely as a function of $\\mathrm{pH}$ via $H=10^{-\\mathrm{pH}}$ and the carbonate speciation functions.\n\nTask:\n1. Starting from the above fundamental principles (electroneutrality, mass-action, and mass-balance), derive mathematically how to express $[\\mathrm{H_{2}CO_{3}^{*}}]$, $[\\mathrm{HCO_{3}^{-}}]$, and $[\\mathrm{CO_{3}^{2-}}]$ in terms of $H$, $K_{1}$, $K_{2}$, and $C_{\\mathrm{T}}$ without introducing any shortcut formulas not derivable from these principles.\n2. Using these expressions, formulate a bisection algorithm to solve $f(\\mathrm{pH}) = 0$ over a closed bracket $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$ under the assumptions that $f$ is continuous on the bracket and changes sign at the endpoints. Explicitly justify the continuity of $f(\\mathrm{pH})$ and explain why a sign change $f(\\mathrm{pH}_{\\min}) \\cdot f(\\mathrm{pH}_{\\max})  0$ implies the existence of a root in the bracket.\n3. Implement the bisection method to find $\\mathrm{pH}$ for each test case below, using a tolerance of $10^{-8}$ for the bracket width or for $|f(\\mathrm{pH})|$, whichever criterion you choose to enforce. All concentrations must be handled in $\\mathrm{mol/L}$, and the final $\\mathrm{pH}$ is dimensionless. The solution must not rely on any external input and must be numerically stable.\n\nTest Suite (each entry is $(C_{\\mathrm{T}}, C_{\\mathrm{Na}}, C_{\\mathrm{Cl}}, \\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max})$):\n- Case A (general freshwater carbonate system): $(2.0 \\times 10^{-3},\\; 1.0 \\times 10^{-3},\\; 1.0 \\times 10^{-3},\\; 4,\\; 10)$.\n- Case B (acidic chloride-rich system): $(1.0 \\times 10^{-4},\\; 0.0,\\; 1.0 \\times 10^{-3},\\; 0,\\; 7)$.\n- Case C (basic sodium-rich system): $(1.0 \\times 10^{-3},\\; 5.0 \\times 10^{-4},\\; 0.0,\\; 4,\\; 14)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the three computed $\\mathrm{pH}$ values for Cases A, B, and C, as a comma-separated list enclosed in square brackets, with each $\\mathrm{pH}$ rounded to six decimal places, for example, $[\\mathrm{pH}_{A},\\mathrm{pH}_{B},\\mathrm{pH}_{C}]$.",
            "solution": "The problem requires finding the equilibrium $\\mathrm{pH}$ of an aqueous solution containing the inorganic carbon system and strong electrolytes by numerically solving the electroneutrality equation. This is a fundamental problem in computational geochemistry. The solution comprises three main parts as requested: deriving the governing equations from first principles, formulating the numerical algorithm, and implementing the solution.\n\n### Part 1: Derivation of Carbonate Species Concentrations\n\nThe speciation of the carbonate system in water is governed by chemical equilibria and a mass balance constraint. We begin by stating these fundamental relationships. All concentrations are in $\\mathrm{mol/L}$.\n\nLet $H = [\\mathrm{H^{+}}]$. The dissociation reactions for the carbonate system are:\n1.  $\\mathrm{H_{2}CO_{3}^{*}} \\rightleftharpoons \\mathrm{H^{+}} + \\mathrm{HCO_{3}^{-}}$\n2.  $\\mathrm{HCO_{3}^{-}} \\rightleftharpoons \\mathrm{H^{+}} + \\mathrm{CO_{3}^{2-}}$\n\nAssuming ideal solution behavior, the law of mass action yields the equilibrium constant expressions:\n$$\nK_{1} = \\frac{[\\mathrm{H^{+}}][\\mathrm{HCO_{3}^{-}}]}{[\\mathrm{H_{2}CO_{3}^{*}}]} = \\frac{H \\cdot [\\mathrm{HCO_{3}^{-}}]}{[\\mathrm{H_{2}CO_{3}^{*}}]}\n$$\n$$\nK_{2} = \\frac{[\\mathrm{H^{+}}][\\mathrm{CO_{3}^{2-}}]}{[\\mathrm{HCO_{3}^{-}}]} = \\frac{H \\cdot [\\mathrm{CO_{3}^{2-}}]}{[\\mathrm{HCO_{3}^{-}}]}\n$$\n\nThe total concentration of Dissolved Inorganic Carbon, $C_{\\mathrm{T}}$, is given by the mass balance equation:\n$$\nC_{\\mathrm{T}} = [\\mathrm{H_{2}CO_{3}^{*}}] + [\\mathrm{HCO_{3}^{-}}] + [\\mathrm{CO_{3}^{2-}}]\n$$\n\nOur objective is to express the concentration of each carbonate species ($[\\mathrm{H_{2}CO_{3}^{*}}]$, $[\\mathrm{HCO_{3}^{-}}]$, and $[\\mathrm{CO_{3}^{2-}}]$) as a function of known quantities: $H$, $C_{\\mathrm{T}}$, $K_{1}$, and $K_{2}$.\n\nFrom the equilibrium expressions, we can express $[\\mathrm{H_{2}CO_{3}^{*}}]$ and $[\\mathrm{CO_{3}^{2-}}]$ in terms of $[\\mathrm{HCO_{3}^{-}}]$ and $H$:\n$$\n[\\mathrm{H_{2}CO_{3}^{*}}] = \\frac{H \\cdot [\\mathrm{HCO_{3}^{-}}]}{K_{1}}\n$$\n$$\n[\\mathrm{CO_{3}^{2-}}] = \\frac{K_{2} \\cdot [\\mathrm{HCO_{3}^{-}}]}{H}\n$$\n\nNext, we substitute these expressions into the mass balance equation for $C_{\\mathrm{T}}$:\n$$\nC_{\\mathrm{T}} = \\left( \\frac{H \\cdot [\\mathrm{HCO_{3}^{-}}]}{K_{1}} \\right) + [\\mathrm{HCO_{3}^{-}}] + \\left( \\frac{K_{2} \\cdot [\\mathrm{HCO_{3}^{-}}]}{H} \\right)\n$$\n\nWe factor out $[\\mathrm{HCO_{3}^{-}}]$:\n$$\nC_{\\mathrm{T}} = [\\mathrm{HCO_{3}^{-}}] \\left( \\frac{H}{K_{1}} + 1 + \\frac{K_{2}}{H} \\right)\n$$\n\nTo simplify the term in the parenthesis, we find a common denominator, which is $K_{1}H$:\n$$\nC_{\\mathrm{T}} = [\\mathrm{HCO_{3}^{-}}] \\left( \\frac{H^2 + K_{1}H + K_{1}K_{2}}{K_{1}H} \\right)\n$$\n\nNow, we can solve for $[\\mathrm{HCO_{3}^{-}}]$:\n$$\n[\\mathrm{HCO_{3}^{-}}] = C_{\\mathrm{T}} \\left( \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\n\nWith this expression for $[\\mathrm{HCO_{3}^{-}}]$, we can find the expressions for the other two species by back-substitution:\n$$\n[\\mathrm{H_{2}CO_{3}^{*}}] = \\frac{H}{K_{1}} [\\mathrm{HCO_{3}^{-}}] = \\frac{H}{K_{1}} C_{\\mathrm{T}} \\left( \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} \\right) = C_{\\mathrm{T}} \\left( \\frac{H^2}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\n$$\n[\\mathrm{CO_{3}^{2-}}] = \\frac{K_{2}}{H} [\\mathrm{HCO_{3}^{-}}] = \\frac{K_{2}}{H} C_{\\mathrm{T}} \\left( \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} \\right) = C_{\\mathrm{T}} \\left( \\frac{K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\nThese are the required expressions for the carbonate species concentrations.\n\n### Part 2: Bisection Algorithm Formulation\n\nThe core of the problem is to solve the electroneutrality equation, $f(\\mathrm{pH}) = 0$. The function $f(\\mathrm{pH})$ represents the net charge in the solution and is defined as the sum of all positive charges minus the sum of all negative charges.\n\nThe cations (positive ions) are $\\mathrm{H^{+}}$ and $\\mathrm{Na^{+}}$. The anions (negative ions) are $\\mathrm{OH^{-}}$, $\\mathrm{Cl^{-}}$, $\\mathrm{HCO_{3}^{-}}$, and $\\mathrm{CO_{3}^{2-}}$. The charge of the carbonate ion, $\\mathrm{CO_{3}^{2-}}$, is $-2$, so its concentration is multiplied by $2$ in the charge balance.\n$$\nf(\\mathrm{pH}) = \\sum (\\mathrm{positive\\;charges}) - \\sum (\\mathrm{negative\\;charges})\n$$\n$$\nf(\\mathrm{pH}) = \\left( [\\mathrm{H^{+}}] + [\\mathrm{Na^{+}}] \\right) - \\left( [\\mathrm{OH^{-}}] + [\\mathrm{Cl^{-}}] + [\\mathrm{HCO_{3}^{-}}] + 2 \\cdot [\\mathrm{CO_{3}^{2-}}] \\right)\n$$\nGiven that $\\mathrm{Na^{+}}$ and $\\mathrm{Cl^{-}}$ are from strong electrolytes, their concentrations are $C_{\\mathrm{Na}}$ and $C_{\\mathrm{Cl}}$ respectively. We use the expressions from Part 1 and the autoprotolysis of water, $[\\mathrm{OH^{-}}] = K_{w}/H$, where $H = 10^{-\\mathrm{pH}}$.\n$$\nf(\\mathrm{pH}) = \\left( H + C_{\\mathrm{Na}} \\right) - \\left( \\frac{K_{w}}{H} + C_{\\mathrm{Cl}} + [\\mathrm{HCO_{3}^{-}}] + 2[\\mathrm{CO_{3}^{2-}}] \\right)\n$$\nSubstituting the derived species concentrations:\n$$\n[\\mathrm{HCO_{3}^{-}}] + 2[\\mathrm{CO_{3}^{2-}}] = C_{\\mathrm{T}} \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} + 2 \\cdot C_{\\mathrm{T}} \\frac{K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}} = C_{\\mathrm{T}} \\frac{K_{1}H + 2K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}}\n$$\nThus, the final function to be solved is:\n$$\nf(\\mathrm{pH}) = H + C_{\\mathrm{Na}} - \\frac{K_{w}}{H} - C_{\\mathrm{Cl}} - C_{\\mathrm{T}} \\left( \\frac{K_{1}H + 2K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\nwhere $H=10^{-\\mathrm{pH}}$.\n\nThe bisection method is an iterative root-finding algorithm that applies to continuous functions. The justification for its use here rests on two properties of $f(\\mathrm{pH})$: continuity and the existence of a root within the given bracket.\n\n**Continuity of $f(\\mathrm{pH})$**:\nThe function $f(\\mathrm{pH})$ is a composition and algebraic sum of several simpler functions of $\\mathrm{pH}$:\n1.  $H(\\mathrm{pH}) = 10^{-\\mathrm{pH}}$ is continuous for all real $\\mathrm{pH}$.\n2.  The term $K_{w}/H$ is continuous for all $H0$, i.e., for any finite $\\mathrm{pH}$.\n3.  The carbonate speciation terms are rational functions of $H$. Their denominator is $D(H) = H^2 + K_{1}H + K_{1}K_{2}$. Since all parameters ($H$, $K_{1}$, $K_{2}$) are strictly positive for any physical solution, the denominator $D(H)$ is always positive and never zero. Therefore, the carbonate terms are continuous functions of $H$.\nSince $f(\\mathrm{pH})$ is constructed from sums, differences, and compositions of these continuous functions, it is itself a continuous function of $\\mathrm{pH}$ on any interval $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$ with $0 \\le \\mathrm{pH}_{\\min}  \\mathrm{pH}_{\\max}  \\infty$.\n\n**Existence of a Root**:\nThe Bisection Method relies on the **Intermediate Value Theorem (IVT)**. The IVT states that if a function $g(x)$ is continuous on a closed interval $[a, b]$, then for any value $N$ between $g(a)$ and $g(b)$, there must exist at least one point $c \\in [a, b]$ such that $g(c) = N$.\nIn our case, the problem specifies a search bracket $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$ and assumes a sign change, i.e., $f(\\mathrm{pH}_{\\min}) \\cdot f(\\mathrm{pH}_{\\max})  0$. This means that one of $f(\\mathrm{pH}_{\\min})$ or $f(\\mathrm{pH}_{\\max})$ is positive and the other is negative. Consequently, the value $N=0$ lies between $f(\\mathrm{pH}_{\\min})$ and $f(\\mathrm{pH}_{\\max})$. Since $f(\\mathrm{pH})$ is continuous on this interval, the IVT guarantees the existence of at least one root $\\mathrm{pH}_{\\text{root}} \\in (\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max})$ such that $f(\\mathrm{pH}_{\\text{root}}) = 0$.\n\n**The Bisection Algorithm**:\nLet the search interval be $[a, b]$, initialized to $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$. We require $f(a)$ and $f(b)$ to have opposite signs. The algorithm proceeds as follows:\n1.  Set a tolerance $\\epsilon$ (e.g., $10^{-8}$).\n2.  Repeat while the width of the interval $(b-a)$ is greater than $\\epsilon$:\n    a. Calculate the midpoint of the interval: $m = a + (b-a)/2$.\n    b. Evaluate the function at the midpoint, $f(m)$.\n    c. If $f(a)$ and $f(m)$ have opposite signs (i.e., $f(a) \\cdot f(m)  0$), then the root must lie in the interval $[a, m]$. Update the interval by setting $b = m$.\n    d. Otherwise, the root must lie in $[m, b]$ (i.e., $f(m) \\cdot f(b) \\le 0$). Update the interval by setting $a = m$.\n3.  Once the loop terminates, the interval $[a, b]$ is smaller than the tolerance $\\epsilon$. The root can be approximated as the midpoint of this final interval, $(a+b)/2$.\n\nThis algorithm is guaranteed to converge to a root, halving the interval of uncertainty at each iteration.\n\n### Part 3: Implementation\n\nThe bisection algorithm is implemented in Python. A function computes the value of the electroneutrality function $f(\\mathrm{pH})$ for a given set of parameters. A second function implements the bisection search. This process is applied to each of the three test cases. The constants are defined as $K_{1} = 10^{-6.3}$, $K_{2} = 10^{-10.3}$, and $K_{w} = 10^{-14}$. A stopping criterion based on the interval width being less than a tolerance of $10^{-8}$ is used.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the pH of an aqueous carbonate system using the bisection method.\n    The function sets up the problem parameters for three test cases and computes\n    the equilibrium pH for each by finding the root of the electroneutrality equation.\n    \"\"\"\n\n    # Define constants at 25 degrees Celsius\n    K1 = 10**(-6.3)\n    K2 = 10**(-10.3)\n    KW = 10**(-14.0)\n\n    # Define the test cases from the problem statement.\n    # Each tuple: (C_T, C_Na, C_Cl, pH_min, pH_max)\n    test_cases = [\n        # Case A: General freshwater carbonate system\n        (2.0e-3, 1.0e-3, 1.0e-3, 4.0, 10.0),\n        # Case B: Acidic chloride-rich system\n        (1.0e-4, 0.0, 1.0e-3, 0.0, 7.0),\n        # Case C: Basic sodium-rich system\n        (1.0e-3, 5.0e-4, 0.0, 4.0, 14.0),\n    ]\n\n    def electroneutrality_func(ph, C_T, C_Na, C_Cl):\n        \"\"\"\n        Calculates the value of the electroneutrality function f(pH).\n\n        f(pH) = (sum of positive charges) - (sum of negative charges)\n        \"\"\"\n        H = 10**(-ph)\n        OH = KW / H\n\n        # Carbonate speciation term: [HCO3-] + 2*[CO3^2-]\n        # Denominator of the speciation fractions\n        denominator = H**2 + K1 * H + K1 * K2\n        \n        # Avoid division by zero, though for H0 denominator is always  0\n        if denominator == 0:\n            # This case is physically impossible for H  0\n            return np.inf\n\n        # [HCO3-] + 2*[CO3^2-] = C_T * (K1*H / denom) + 2 * C_T * (K1*K2 / denom)\n        carbonate_charge_term = C_T * (K1 * H + 2 * K1 * K2) / denominator\n        \n        # Calculate net charge (the function f(pH) we want to find the root of)\n        # f(pH) = [H+] + [Na+] - ([OH-] + [Cl-] + [HCO3-] + 2*[CO3^2-])\n        net_charge = (H + C_Na) - (OH + C_Cl + carbonate_charge_term)\n\n        return net_charge\n\n    def bisection_solver(params, tol=1.0e-8, max_iter=100):\n        \"\"\"\n        Finds the root of the electroneutrality function using the bisection method.\n        \"\"\"\n        C_T, C_Na, C_Cl, ph_min, ph_max = params\n        \n        a = ph_min\n        b = ph_max\n        \n        f_a = electroneutrality_func(a, C_T, C_Na, C_Cl)\n        f_b = electroneutrality_func(b, C_T, C_Na, C_Cl)\n\n        # Check if a root is guaranteed to be in the interval\n        if f_a * f_b = 0:\n            # This case should not occur with the problem's given brackets\n            # but is good practice to check.\n            if abs(f_a)  tol: return a\n            if abs(f_b)  tol: return b\n            raise ValueError(\"Bisection method fails: f(a) and f(b) must have opposite signs.\")\n            \n        for _ in range(max_iter):\n            mid = a + (b - a) / 2\n            f_mid = electroneutrality_func(mid, C_T, C_Na, C_Cl)\n\n            if abs(f_mid)  tol or (b - a) / 2  tol:\n                return mid\n            \n            # Update the interval\n            if f_a * f_mid  0:\n                b = mid\n            else:\n                a = mid\n                f_a = f_mid # Update f_a to f_mid\n\n        return (a + b) / 2\n\n    results = []\n    for case in test_cases:\n        ph_solution = bisection_solver(case)\n        results.append(f\"{ph_solution:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world geochemical systems are described by multiple interacting equations, where concentrations can vary over many orders of magnitude. This practice explores the critical technique of scaling to improve the numerical conditioning of the Jacobian matrix within a Newton-Raphson solver, a vital step for ensuring solver robustness and accuracy . Properly balancing the equations prevents numerical precision issues and allows the solver to converge on chemically complex systems.",
            "id": "4094368",
            "problem": "Consider a non-linear algebraic system in computational geochemistry described by the vector equation $F(x)=0$, where $F:\\mathbb{R}^n\\to\\mathbb{R}^n$ aggregates mass-balance, charge-balance, and mass-action residuals for an aqueous multicomponent system. At an iterate $x_k$, denote the Jacobian matrix by $J(x_k)\\in\\mathbb{R}^{n\\times n}$. In Newton-Raphson (NR) iteration, the step $\\Delta x_k$ solves $J(x_k)\\Delta x_k=-F(x_k)$. When residual components $F_i(x_k)$ span several orders of magnitude, naive NR can yield poorly conditioned linear systems that degrade robustness. A practical remedy is to left-scale the system with a diagonal matrix $D$ to balance rows, i.e., solve $D^{-1}J(x_k)\\Delta x_k=-D^{-1}F(x_k)$, with $D=\\mathrm{diag}(d_1,\\dots,d_n)$ and $d_i0$.\n\nDesign criteria: you must design a diagonal scaling matrix $D$ so that the scaled residual $D^{-1}F(x_k)$ has components of comparable magnitude across $i=1,\\dots,n$ for multicomponent systems spanning orders of magnitude. Your design must be justified from first principles by appealing to Newton-Raphson iteration and matrix conditioning arguments. Implement and compare two concrete, unit-consistent scaling designs:\n- Residual-only scaling: $D^{(R)}$ with $d^{(R)}_i=\\max\\!\\big(|F_i(x_k)|,r_{\\min}\\big)$, where $r_{\\min}0$ is a small floor to avoid zero scaling.\n- Jacobian-informed scaling: $D^{(RJ)}$ with $d^{(RJ)}_i=\\max\\!\\big(\\|J_{i,:}(x_k)S\\|_2,\\;|F_i(x_k)|,\\;r_{\\min}\\big)$, where $S=\\mathrm{diag}(s_1,\\dots,s_n)$ encodes typical variable scales $s_j0$ and $J_{i,:}$ denotes row $i$ of $J$. This choice targets both balanced residuals and balanced row norms of the scaled operator $D^{-1}JS$.\n\nYou must compute, for each scaling design and each test case, two quantitative balance metrics:\n- Residual balance metric $q_F = \\dfrac{\\max_i |(D^{-1}F)_i|}{\\min_i |(D^{-1}F)_i| + \\eta}$,\n- Row-norm balance metric $q_J = \\dfrac{\\max_i \\| (D^{-1}JS)_{i,:} \\|_2}{\\min_i \\| (D^{-1}JS)_{i,:} \\|_2 + \\eta}$,\nwhere $\\eta0$ is a tiny regularizer to avoid division by zero in the metric definition. Smaller $q_F$ and $q_J$ indicate better balance across components or rows.\n\nAll quantities in this problem are dimensionless and expressed in consistent internal numerical units; no physical unit conversion is required. Angles do not appear. Percentages do not appear. You must implement your solution for the following test suite, which provides explicit $F$, $J$, and $s$ vectors to evaluate the scaling designs:\n\nTest case $1$ (moderate geochemical residual spread):\n- $F^{(1)}=\\big[10^{-6},\\;-10^{-3},\\;5\\cdot 10^{-2},\\;-10^{-12},\\;2\\cdot 10^{-4},\\;-5\\cdot 10^{-8}\\big]$,\n- $J^{(1)}=\\begin{bmatrix}\n5.0\\cdot 10^{1}  10^{-2}  0  10^{-6}  -2\\cdot 10^{-1}  10^{-1} \\\\\n10^{-1}  3.0  1.0  0  0  0 \\\\\n0  5\\cdot 10^{-1}  10.0  0  0  0 \\\\\n10^{-12}  0  0  10^{-8}  0  0 \\\\\n0  0  0  0  2.0  0 \\\\\n0  0  0  0  0  1.5\n\\end{bmatrix}$,\n- $s^{(1)}=\\big[1,\\;10^{-3},\\;10^{-3},\\;1,\\;10^{-3},\\;10^{-3}\\big]$.\n\nTest case $2$ (extreme residual and sensitivity contrasts):\n- $F^{(2)}=\\big[10^{-12},\\;-3\\cdot 10^{-3},\\;2\\cdot 10^{2},\\;-10^{-9},\\;0,\\;-5.0\\big]$,\n- $J^{(2)}=\\begin{bmatrix}\n10^{-4}  0  0  0  0  0 \\\\\n0  10^{2}  10^{1}  0  0  0 \\\\\n0  0  10^{3}  0  0  0 \\\\\n0  0  0  10^{-9}  0  0 \\\\\n0  0  0  0  10^{-2}  0 \\\\\n1.0  1.0  -1.0  0  0  5\\cdot 10^{-1}\n\\end{bmatrix}$,\n- $s^{(2)}=\\big[1,\\;10^{-3},\\;10^{-3},\\;1,\\;10^{-3},\\;10^{-3}\\big]$.\n\nTest case $3$ (near-singular Jacobian rows with small residuals):\n- $F^{(3)}=\\big[10^{-8},\\;-10^{-8},\\;5\\cdot 10^{-8},\\;-5\\cdot 10^{-8},\\;10^{-9},\\;-10^{-9}\\big]$,\n- $J^{(3)}=\\begin{bmatrix}\n10^{-10}  10^{-10}  10^{-10}  0  0  0 \\\\\n0  10^{-10}  0  0  0  0 \\\\\n10^{-5}  0  10^{-5}  0  0  0 \\\\\n0  0  0  10^{-12}  0  0 \\\\\n0  0  0  0  10^{-10}  0 \\\\\n0  0  0  0  0  10^{-10}\n\\end{bmatrix}$,\n- $s^{(3)}=\\big[1,\\;10^{-4},\\;10^{-4},\\;1,\\;10^{-6},\\;10^{-6}\\big]$.\n\nUse $r_{\\min}=10^{-20}$ and $\\eta=10^{-30}$ in all cases. For each test case, compute four floats in the order\n$\\big[q_F^{(R)},\\;q_F^{(RJ)},\\;q_J^{(R)},\\;q_J^{(RJ)}\\big]$.\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case contributing a list of four floats, i.e.,\n$[\\,[q_F^{(R,1)},q_F^{(RJ,1)},q_J^{(R,1)},q_J^{(RJ,1)}],\\,[q_F^{(R,2)},q_F^{(RJ,2)},q_J^{(R,2)},q_J^{(RJ,2)}],\\,[q_F^{(R,3)},q_F^{(RJ,3)},q_J^{(R,3)},q_J^{(RJ,3)}]\\,]$.",
            "solution": "The problem is found to be valid. It is scientifically grounded in the principles of numerical linear algebra applied to solving non-linear systems, specifically the Newton-Raphson method. The problem is well-posed, with all necessary data and definitions provided for a unique, verifiable solution. The language is objective and formal.\n\nThe problem addresses a critical issue in the numerical solution of non-linear algebraic systems, $F(x)=0$, which frequently arise in computational geochemistry from mass-balance, charge-balance, and mass-action laws. The Newton-Raphson (NR) method is a standard iterative technique for solving such systems. Given an iterate $x_k$, the method computes a correction step $\\Delta x_k$ by solving the linear system:\n$$ J(x_k) \\Delta x_k = -F(x_k) $$\nwhere $J(x_k)$ is the Jacobian matrix of $F$ evaluated at $x_k$. The next iterate is then $x_{k+1} = x_k + \\Delta x_k$.\n\nA primary challenge in geochemical modeling is that the components of the residual vector $F(x_k)$ and the entries of the Jacobian $J(x_k)$ can span many orders of magnitude. This can lead to a poorly conditioned Jacobian matrix. The condition number of a matrix, $\\kappa(J)$, quantifies the sensitivity of the solution $\\Delta x_k$ to perturbations in $J(x_k)$ and $F(x_k)$. A large condition number can amplify numerical errors, degrading the accuracy and robustness of the NR iteration.\n\nRow scaling, or left-preconditioning with a diagonal matrix $D^{-1}$, is a common strategy to mitigate poor conditioning. The linear system is transformed into:\n$$ (D^{-1}J(x_k)) \\Delta x_k = -D^{-1}F(x_k) $$\nThe goal is to choose the positive diagonal entries $d_i$ of $D$ such that the new system matrix, $D^{-1}J(x_k)$, is better conditioned than the original $J(x_k)$. A well-conditioned matrix often has rows (or columns) with norms of a similar magnitude, typically close to $1$. This prevents equations with very large or very small coefficients from disproportionately influencing the solution or being lost due to finite-precision arithmetic.\n\nThe problem asks for the design and evaluation of two such scaling strategies.\n\n**1. Residual-only Scaling ($D^{(R)}$)**\n\nThis strategy focuses on balancing the right-hand side of the linear system, the scaled residual vector $D^{-1}F(x_k)$. The scaling factors are defined as:\n$$ d^{(R)}_i = \\max\\left(|F_i(x_k)|, r_{\\min}\\right) $$\nwhere $r_{\\min}  0$ is a small regularization parameter to prevent division by zero or by a numerically small value if a residual component $F_i(x_k)$ is close to zero. By this design, the $i$-th component of the scaled residual becomes:\n$$ \\left( (D^{(R)})^{-1}F(x_k) \\right)_i = \\frac{F_i(x_k)}{\\max\\left(|F_i(x_k)|, r_{\\min}\\right)} $$\nIf $|F_i(x_k)| \\gg r_{\\min}$, the magnitude of this scaled component is $|F_i(x_k)|/|F_i(x_k)| = 1$. This scaling normalizes each residual component to have a magnitude of approximately unity, ensuring that the NR step gives comparable weight to reducing each residual relative to its current size. This improves the balance of the target vector but does not explicitly address the conditioning of the Jacobian matrix itself.\n\n**2. Jacobian-informed Scaling ($D^{(RJ)}$)**\n\nThis is a more sophisticated approach that considers both the residuals and the Jacobian rows. It also incorporates column scaling via a diagonal matrix $S = \\mathrm{diag}(s_j)$, where $s_j$ represents the typical scale of the variable $x_j$. The scaling factors are defined as:\n$$ d^{(RJ)}_i = \\max\\left(\\|J_{i,:}(x_k)S\\|_2, |F_i(x_k)|, r_{\\min}\\right) $$\nHere, $J_{i,:}$ is the $i$-th row of the Jacobian. The term $\\|J_{i,:}(x_k)S\\|_2$ is the Euclidean norm of the $i$-th row of the column-scaled Jacobian $JS$. This scaling aims to achieve two goals simultaneously:\n- By including $\\|J_{i,:}(x_k)S\\|_2$, it seeks to normalize the rows of the fully scaled Jacobian $D^{-1}JS$. If this norm is the dominant term in the $\\max$ function for row $i$, then the $i$-th row of $D^{-1}JS$ will have a Euclidean norm of approximately $1$. Balancing row norms is a powerful heuristic for reducing the condition number of the system matrix.\n- By including $|F_i(x_k)|$, it retains the residual-balancing properties of the first method. The $\\max$ operator ensures that the scaling factor is large enough to control both the row norm and the residual component.\n\n**Evaluation Metrics**\n\nTo quantitatively assess the effectiveness of these scaling strategies, we compute two balance metrics for each:\n\n- **Residual Balance Metric ($q_F$)**:\n$$ q_F = \\frac{\\max_i |(D^{-1}F)_i|}{\\min_i |(D^{-1}F)_i| + \\eta} $$\nThis metric measures the ratio of the largest to the smallest magnitude in the scaled residual vector. A value of $q_F$ close to $1$ indicates that all residual components have been successfully scaled to a comparable magnitude.\n\n- **Row-norm Balance Metric ($q_J$)**:\n$$ q_J = \\frac{\\max_i \\| (D^{-1}JS)_{i,:} \\|_2}{\\min_i \\| (D^{-1}JS)_{i,:} \\|_2 + \\eta} $$\nThis metric measures the ratio of the largest to the smallest Euclidean norm among the rows of the fully scaled Jacobian matrix $D^{-1}JS$. A value of $q_J$ close to $1$ indicates that the scaling has successfully balanced the sensitivities of the equations.\n\nThe parameter $\\eta  0$ is a small regularizer added to the denominator to prevent division by zero in cases where a minimum value might be zero.\n\nThe procedure for each test case is as follows:\n1. For a given scaling method (R or RJ), construct the diagonal matrix $D$.\n2. Compute the scaled quantities $D^{-1}F$ and $D^{-1}JS$.\n3. From these quantities, calculate the metrics $q_F$ and $q_J$ using the provided formulas.\nThis process is repeated for both scaling methods on all three test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the geochemistry scaling problem for the given test cases.\n    \"\"\"\n    # Define constants\n    r_min = 1e-20\n    eta = 1e-30\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"F\": np.array([1e-6, -1e-3, 5e-2, -1e-12, 2e-4, -5e-8]),\n            \"J\": np.array([\n                [5.0e1, 1e-2, 0, 1e-6, -2e-1, 1e-1],\n                [1e-1, 3.0, 1.0, 0, 0, 0],\n                [0, 5e-1, 10.0, 0, 0, 0],\n                [1e-12, 0, 0, 1e-8, 0, 0],\n                [0, 0, 0, 0, 2.0, 0],\n                [0, 0, 0, 0, 0, 1.5]\n            ]),\n            \"s\": np.array([1, 1e-3, 1e-3, 1, 1e-3, 1e-3]),\n        },\n        {\n            \"F\": np.array([1e-12, -3e-3, 2e2, -1e-9, 0, -5.0]),\n            \"J\": np.array([\n                [1e-4, 0, 0, 0, 0, 0],\n                [0, 1e2, 1e1, 0, 0, 0],\n                [0, 0, 1e3, 0, 0, 0],\n                [0, 0, 0, 1e-9, 0, 0],\n                [0, 0, 0, 0, 1e-2, 0],\n                [1.0, 1.0, -1.0, 0, 0, 5e-1]\n            ]),\n            \"s\": np.array([1, 1e-3, 1e-3, 1, 1e-3, 1e-3]),\n        },\n        {\n            \"F\": np.array([1e-8, -1e-8, 5e-8, -5e-8, 1e-9, -1e-9]),\n            \"J\": np.array([\n                [1e-10, 1e-10, 1e-10, 0, 0, 0],\n                [0, 1e-10, 0, 0, 0, 0],\n                [1e-5, 0, 1e-5, 0, 0, 0],\n                [0, 0, 0, 1e-12, 0, 0],\n                [0, 0, 0, 0, 1e-10, 0],\n                [0, 0, 0, 0, 0, 1e-10]\n            ]),\n            \"s\": np.array([1, 1e-4, 1e-4, 1, 1e-6, 1e-6]),\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        F = case[\"F\"]\n        J = case[\"J\"]\n        s = case[\"s\"]\n        \n        S = np.diag(s)\n        JS = J @ S\n        abs_F = np.abs(F)\n\n        # --- Residual-only scaling (R) ---\n        d_R = np.maximum(abs_F, r_min)\n        D_R_inv = np.diag(1.0 / d_R)\n        \n        # Metric q_F for D^(R)\n        F_scaled_R = D_R_inv @ F\n        abs_F_scaled_R = np.abs(F_scaled_R)\n        q_F_R = np.max(abs_F_scaled_R) / (np.min(abs_F_scaled_R) + eta)\n        \n        # Metric q_J for D^(R)\n        D_R_inv_JS = D_R_inv @ JS\n        row_norms_R = np.linalg.norm(D_R_inv_JS, axis=1, ord=2)\n        q_J_R = np.max(row_norms_R) / (np.min(row_norms_R) + eta)\n\n        # --- Jacobian-informed scaling (RJ) ---\n        row_norms_JS = np.linalg.norm(JS, axis=1, ord=2)\n        d_RJ = np.maximum.reduce([row_norms_JS, abs_F, np.full_like(abs_F, r_min)])\n        D_RJ_inv = np.diag(1.0 / d_RJ)\n        \n        # Metric q_F for D^(RJ)\n        F_scaled_RJ = D_RJ_inv @ F\n        abs_F_scaled_RJ = np.abs(F_scaled_RJ)\n        q_F_RJ = np.max(abs_F_scaled_RJ) / (np.min(abs_F_scaled_RJ) + eta)\n        \n        # Metric q_J for D^(RJ)\n        D_RJ_inv_JS = D_RJ_inv @ JS\n        row_norms_RJ = np.linalg.norm(D_RJ_inv_JS, axis=1, ord=2)\n        q_J_RJ = np.max(row_norms_RJ) / (np.min(row_norms_RJ) + eta)\n        \n        case_results = [q_F_R, q_F_RJ, q_J_R, q_J_RJ]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "When a system of equations is highly non-linear, such as those including activity corrections, standard Newton methods can easily fail without a sufficiently close initial guess. This advanced practice introduces the powerful homotopy continuation method, which constructs a continuous path from a simple, solvable problem (e.g., an ideal solution) to the complex target problem . This globalization technique dramatically expands the convergence basin of the solver, enabling solutions to problems that would otherwise be intractable.",
            "id": "4094405",
            "problem": "Consider a carbonate aqueous system at standard conditions where sodium and chloride provide a background electrolyte. The objective is to solve a non-linear algebraic equilibrium model that includes the law of mass action and charge balance, and to construct and traverse a homotopy continuation from an ideal solution approximation to a full activity-coefficient model using the Davies equation. Let the vector of unknowns be $\\ell = (\\ln m_{\\mathrm{H}^+}, \\ln m_{\\mathrm{HCO}_3^-}, \\ln m_{\\mathrm{CO}_3^{2-}})$, where $m_i$ denotes molar concentration in $\\mathrm{mol/L}$, and activities are $a_i = \\gamma_i m_i$.\n\nFundamental base:\n- Law of mass action for acid dissociation and water autoprotolysis, using activities:\n  - First dissociation of carbonic acid: $K_1 = \\dfrac{a_{\\mathrm{H}^+} a_{\\mathrm{HCO}_3^-}}{a_{\\mathrm{H}_2\\mathrm{CO}_3}}$.\n  - Second dissociation: $K_2 = \\dfrac{a_{\\mathrm{H}^+} a_{\\mathrm{CO}_3^{2-}}}{a_{\\mathrm{HCO}_3^-}}$.\n  - Water autoprotolysis: $K_w = a_{\\mathrm{H}^+} a_{\\mathrm{OH}^-}$.\n- Electroneutrality: $\\sum z_i m_i = 0$ for all charged species $i$, where $z_i$ is the charge of species $i$.\n- Total inorganic carbon mass balance: $C_T = m_{\\mathrm{H}_2\\mathrm{CO}_3} + m_{\\mathrm{HCO}_3^-} + m_{\\mathrm{CO}_3^{2-}}$.\n- Ionic strength definition: $I = \\dfrac{1}{2} \\sum_i m_i z_i^2$.\n- Davies equation for activity coefficients of ions at $25^\\circ\\mathrm{C}$: $\\log_{10} \\gamma_i = -A z_i^2\\left( \\dfrac{\\sqrt{I}}{1+\\sqrt{I}} - 0.3 I \\right)$ with $A = 0.509$. Neutral species are taken as $\\gamma=1$.\n\nLet the known totals of sodium and chloride be $N_T$ and $Cl_T$ respectively, assumed to be present only as $\\mathrm{Na}^+$ and $\\mathrm{Cl}^-$. Constants at $25^\\circ\\mathrm{C}$ are $K_1 = 10^{-6.3}$, $K_2 = 10^{-10.3}$, and $K_w = 10^{-14}$.\n\nDefine a homotopy $H(\\ell,t) = F_t(\\ell)$ where $t \\in [0,1]$ controls the extent to which activity effects are included. Specifically, compute the ionic strength $I(\\ell)$ from current concentrations and use a scaled ionic strength $I_t(\\ell) = t\\, I(\\ell)$ in the Davies equation to obtain $\\gamma_i(t)$, so that $\\gamma_i(0)=1$ for all ions (ideal solution) and $\\gamma_i(1)$ is the full Davies value. Construct $F_t(\\ell)=0$ as the system:\n- Carbon mass balance:\n  $$F_{t,1}(\\ell) = m_{\\mathrm{H}_2\\mathrm{CO}_3} + m_{\\mathrm{HCO}_3^-} + m_{\\mathrm{CO}_3^{2-}} - C_T,$$\n  with $m_{\\mathrm{H}_2\\mathrm{CO}_3} = \\dfrac{a_{\\mathrm{H}^+} a_{\\mathrm{HCO}_3^-}}{K_1}$ and $a_{\\mathrm{H}^+} = \\gamma_{\\mathrm{H}^+}(t) m_{\\mathrm{H}^+}$, $a_{\\mathrm{HCO}_3^-} = \\gamma_{\\mathrm{HCO}_3^-}(t) m_{\\mathrm{HCO}_3^-}$, and $\\gamma_{\\mathrm{H}_2\\mathrm{CO}_3}=1$.\n- Second dissociation equilibrium:\n  $$F_{t,2}(\\ell) = a_{\\mathrm{H}^+} a_{\\mathrm{CO}_3^{2-}} - K_2 a_{\\mathrm{HCO}_3^-},$$\n  with $a_{\\mathrm{CO}_3^{2-}} = \\gamma_{\\mathrm{CO}_3^{2-}}(t) m_{\\mathrm{CO}_3^{2-}}$.\n- Electroneutrality:\n  $$F_{t,3}(\\ell) = N_T + m_{\\mathrm{H}^+} - \\left(Cl_T + m_{\\mathrm{OH}^-} + m_{\\mathrm{HCO}_3^-} + 2 m_{\\mathrm{CO}_3^{2-}} \\right),$$\n  where $m_{\\mathrm{OH}^-}$ is determined implicitly by $K_w = a_{\\mathrm{H}^+} a_{\\mathrm{OH}^-}$ as $m_{\\mathrm{OH}^-} = \\dfrac{K_w}{a_{\\mathrm{H}^+}\\, \\gamma_{\\mathrm{OH}^-}(t)}$.\n\nThe task is to:\n1. Implement a Newton method in the variables $\\ell$ with a numerical Jacobian to solve $F_t(\\ell)=0$ at fixed $t$ and with a line search to robustly decrease the residual.\n2. Implement a homotopy continuation strategy that starts at $t=0$ (ideal solution) and advances $t$ to $t=1$ using adaptive step size $\\Delta t$ selection to maintain Newton method convergence. Use the previous solution at $t$ as the initial guess for $t+\\Delta t$. If Newton converges in few iterations, increase $\\Delta t$; if it converges slowly or fails, reduce $\\Delta t$ and retry.\n3. Compute the negative base-10 logarithm of the hydrogen ion activity at $t=1$, $pH = -\\log_{10}\\left(a_{\\mathrm{H}^+}\\right)$, for each test case.\n\nTest suite:\n- Case A (general case): $C_T = 2.0\\times 10^{-3}\\ \\mathrm{mol/L}$, $N_T = 1.0\\times 10^{-2}\\ \\mathrm{mol/L}$, $Cl_T = 1.0\\times 10^{-2}\\ \\mathrm{mol/L}$.\n- Case B (high ionic strength): $C_T = 2.0\\times 10^{-3}\\ \\mathrm{mol/L}$, $N_T = 0.5\\ \\mathrm{mol/L}$, $Cl_T = 0.5\\ \\mathrm{mol/L}$.\n- Case C (low carbon boundary): $C_T = 1.0\\times 10^{-5}\\ \\mathrm{mol/L}$, $N_T = 1.0\\times 10^{-3}\\ \\mathrm{mol/L}$, $Cl_T = 1.0\\times 10^{-3}\\ \\mathrm{mol/L}$.\n\nAnswer specification:\n- For each test case, output the final $pH$ at $t=1$ as a float number rounded to four decimal places. $pH$ is unitless.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[pH_A,pH_B,pH_C]$), in the order of the test cases listed above.",
            "solution": "The problem statement is assessed as valid. It presents a well-posed and scientifically grounded challenge in computational geochemistry, requiring the numerical solution of a system of non-linear algebraic equations representing chemical equilibria. The problem is self-contained, with all necessary constants, equations, and boundary conditions clearly specified. The use of a homotopy continuation method is an appropriate and standard technique for transitioning from a simplified ideal model to a more complex, non-ideal one.\n\nThe solution is implemented by first formulating the system of three non-linear equations, $F_t(\\ell) = 0$, based on the principles of mass balance, chemical equilibrium, and charge balance. The vector of unknowns, $\\ell$, contains the natural logarithms of the molar concentrations of the primary ionic species: $\\ell = (\\ln m_{\\mathrm{H}^+}, \\ln m_{\\mathrm{HCO}_3^-}, \\ln m_{\\mathrm{CO}_3^{2-}})$. Using logarithms as variables is a common practice that aids numerical stability and naturally enforces the physical constraint of positive concentrations.\n\nThe system of equations $F_t(\\ell)=0$ is defined as:\n1.  **Carbon Mass Balance ($F_{t,1}$):** This equation ensures that the sum of the concentrations of all dissolved inorganic carbon species equals the specified total, $C_T$.\n    $$F_{t,1}(\\ell) = m_{\\mathrm{H}_2\\mathrm{CO}_3} + m_{\\mathrm{HCO}_3^-} + m_{\\mathrm{CO}_3^{2-}} - C_T = 0$$\n    Here, $m_{\\mathrm{HCO}_3^-} = e^{\\ell_1}$ and $m_{\\mathrm{CO}_3^{2-}} = e^{\\ell_2}$. The concentration of carbonic acid, $m_{\\mathrm{H}_2\\mathrm{CO}_3}$, is expressed via the law of mass action for the first dissociation of $\\mathrm{H}_2\\mathrm{CO}_3$: $m_{\\mathrm{H}_2\\mathrm{CO}_3} = (a_{\\mathrm{H}^+} a_{\\mathrm{HCO}_3^-}) / K_1$, where activities are $a_i = \\gamma_i m_i$.\n\n2.  **Second Dissociation Equilibrium ($F_{t,2}$):** This equation represents the equilibrium for the dissociation of bicarbonate to carbonate.\n    $$F_{t,2}(\\ell) = a_{\\mathrm{H}^+} a_{\\mathrm{CO}_3^{2-}} - K_2 a_{\\mathrm{HCO}_3^-} = 0$$\n\n3.  **Electroneutrality ($F_{t,3}$):** This equation enforces charge balance, stating that the sum of positive charges must equal the sum of negative charges in the solution.\n    $$F_{t,3}(\\ell) = (N_T + m_{\\mathrm{H}^+}) - (Cl_T + m_{\\mathrm{OH}^-} + m_{\\mathrm{HCO}_3^-} + 2 m_{\\mathrm{CO}_3^{2-}}) = 0$$\n    The concentration of the hydroxide ion, $m_{\\mathrm{OH}^-}$, is determined from the water autoprotolysis constant, $K_w = a_{\\mathrm{H}^+} a_{\\mathrm{OH}^-}$.\n\nA key complexity is that the activity coefficients, $\\gamma_i$, depend on the ionic strength, $I = \\frac{1}{2} \\sum_i m_i z_i^2$, which in turn depends on the concentrations of all ions, including $m_{\\mathrm{OH}^-}$. This creates an implicit relationship. This challenge is addressed by implementing a fixed-point iteration within each evaluation of the function $F_t(\\ell)$. For a given $\\ell$, this iterative procedure calculates a self-consistent set of ionic strength and activity coefficients. The homotopy parameter $t \\in [0,1]$ scales the ionic strength, $I_t = t \\cdot I$, allowing a gradual transition from the ideal solution ($\\gamma_i=1$ at $t=0$) to the full Davies model ($t=1$). The Davies equation is given by $\\log_{10} \\gamma_i = -A z_i^2\\left( \\frac{\\sqrt{I_t}}{1+\\sqrt{I_t}} - 0.3 I_t \\right)$.\n\nThe system $F_t(\\ell)=0$ is solved using a robust Newton-Raphson method. The iterative update rule is $\\ell_{k+1} = \\ell_k - \\lambda J_k^{-1} F_t(\\ell_k)$. The Jacobian matrix, $J_k$, which contains the partial derivatives of $F_t$ with respect to the components of $\\ell$, is computed numerically using a finite difference scheme. To ensure robust convergence, a backtracking line search is employed to find an appropriate step length $\\lambda \\in (0,1]$ that guarantees a sufficient decrease in the norm of the residual vector, $\\|F_t\\|$.\n\nThe homotopy continuation method orchestrates the overall solution process. It begins by solving the system for the ideal case ($t=0$) using an initial chemical guess. The solution at a given step $t_i$ is then used as the initial guess for the Newton solver at the next step, $t_{i+1} = t_i + \\Delta t$. The step size $\\Delta t$ is adapted based on the performance of the Newton solver: it is increased if convergence is rapid and decreased if convergence is slow or fails, ensuring a stable path-following from $t=0$ to $t=1$.\n\nUpon successful continuation to $t=1$, the final vector $\\ell_{final}$ is obtained. The hydrogen ion activity is calculated as $a_{\\mathrm{H}^+} = \\gamma_{\\mathrm{H}^+}(1) \\cdot e^{\\ell_{final,0}}$, from which the final pH is determined as $pH = -\\log_{10}(a_{\\mathrm{H}^+})$. This procedure is applied to each test case to generate the required results.",
            "answer": "```python\nimport numpy as np\nfrom numpy.linalg import norm, solve as linsolve\n\ndef solve():\n    \"\"\"\n    Main solver function that encapsulates the entire logic as per the problem specification.\n    \"\"\"\n\n    # --- Start of self-contained definitions ---\n\n    # Constants\n    K1 = 10**-6.3\n    K2 = 10**-10.3\n    KW = 10**-14.0\n    A_DAVIES = 0.509\n    \n    def compute_auxiliary_vars(l, t, N_T, Cl_T):\n        \"\"\"\n        Computes self-consistent ionic strength, activity coefficients, and\n        concentrations of dependent species (m_OH, m_H2CO3) for a given state (l, t).\n        \"\"\"\n        m_H = np.exp(l[0])\n        m_HCO3 = np.exp(l[1])\n        m_CO3 = np.exp(l[2])\n\n        # Fixed-point iteration for ionic strength I\n        I = 0.5 * (m_H + m_HCO3 + 4 * m_CO3 + N_T + Cl_T)\n\n        for _ in range(10): # 10 iterations typically suffice for convergence\n            I_scaled = t * I\n            \n            if I_scaled  1e-15: # Ideal solution or very low I\n                gamma_H = 1.0\n                gamma_OH = 1.0\n                gamma_HCO3 = 1.0\n                gamma_CO3 = 1.0\n            else:\n                sqrt_I_scaled = np.sqrt(I_scaled)\n                davies_term = (sqrt_I_scaled / (1.0 + sqrt_I_scaled)) - 0.3 * I_scaled\n                \n                log10_gamma_H = -A_DAVIES * (1**2) * davies_term\n                log10_gamma_CO3 = -A_DAVIES * (-2**2) * davies_term\n                \n                gamma_H = 10**log10_gamma_H\n                gamma_OH = gamma_H  # z^2 = (-1)^2 = 1^2\n                gamma_HCO3 = gamma_H # z^2 = (-1)^2 = 1^2\n                gamma_CO3 = 10**log10_gamma_CO3\n            \n            denominator = gamma_H * m_H * gamma_OH\n            m_OH = KW / denominator if denominator  1e-30 else 0.0\n\n            I = 0.5 * (m_H + m_HCO3 + 4 * m_CO3 + m_OH + N_T + Cl_T)\n\n        gammas = {'H': gamma_H, 'OH': gamma_OH, 'HCO3': gamma_HCO3, 'CO3': gamma_CO3}\n        \n        a_H = gammas['H'] * m_H\n        a_HCO3 = gammas['HCO3'] * m_HCO3\n        m_H2CO3 = (a_H * a_HCO3) / K1\n\n        return {'gammas': gammas, 'm_H2CO3': m_H2CO3, 'm_OH': m_OH}\n\n    def system_function(l, t, params):\n        \"\"\"\n        Computes the residual vector F(l, t) for the system of non-linear equations.\n        \"\"\"\n        C_T, N_T, Cl_T = params['C_T'], params['N_T'], params['Cl_T']\n        \n        aux = compute_auxiliary_vars(l, t, N_T, Cl_T)\n        gammas, m_H2CO3, m_OH = aux['gammas'], aux['m_H2CO3'], aux['m_OH']\n\n        m_H = np.exp(l[0])\n        m_HCO3 = np.exp(l[1])\n        m_CO3 = np.exp(l[2])\n\n        F1 = m_H2CO3 + m_HCO3 + m_CO3 - C_T\n        \n        a_H = gammas['H'] * m_H\n        a_HCO3 = gammas['HCO3'] * m_HCO3\n        a_CO3 = gammas['CO3'] * m_CO3\n        F2 = a_H * a_CO3 - K2 * a_HCO3\n        \n        F3 = (N_T + m_H) - (Cl_T + m_OH + m_HCO3 + 2 * m_CO3)\n        \n        return np.array([F1, F2, F3])\n\n    def numerical_jacobian(F_func, l, t, params):\n        \"\"\"\n        Computes the Jacobian matrix of F_func w.r.t. l using finite differences.\n        \"\"\"\n        f0 = F_func(l, t, params)\n        n = len(l)\n        J = np.zeros((n, n))\n        h = 1e-8\n        \n        for j in range(n):\n            l_plus_h = l.copy()\n            l_plus_h[j] += h\n            f_plus_h = F_func(l_plus_h, t, params)\n            J[:, j] = (f_plus_h - f0) / h\n            \n        return J\n\n    def newton_solver(F_func, l_guess, t, params, tol=1e-10, max_iter=25):\n        \"\"\"\n        Solves F(l) = 0 using Newton's method with a backtracking line search.\n        \"\"\"\n        l = l_guess.copy()\n        alpha = 1e-4\n        beta = 0.5\n        \n        for i in range(max_iter):\n            F_val = F_func(l, t, params)\n            norm_F = norm(F_val)\n\n            if norm_F  tol:\n                return l, True, i + 1\n\n            J_val = numerical_jacobian(F_func, l, t, params)\n            \n            try:\n                delta_l = linsolve(J_val, -F_val)\n            except np.linalg.LinAlgError:\n                return l, False, i + 1\n\n            lambda_step = 1.0\n            for _ in range(10): # Max 10 backtracking steps\n                l_new = l + lambda_step * delta_l\n                F_new_norm = norm(F_func(l_new, t, params))\n                if F_new_norm  (1 - alpha * lambda_step) * norm_F:\n                    break\n                lambda_step *= beta\n            else: # No suitable step found\n                return l, False, i + 1\n            \n            l = l_new\n\n        return l, norm(F_func(l, t, params))  tol, max_iter\n\n    def solve_case(params):\n        \"\"\"\n        Performs homotopy continuation to solve the geochemical system for a given case.\n        \"\"\"\n        m_H_guess = 1e-7\n        m_HCO3_guess = params['C_T']\n        m_CO3_guess = K2 * m_HCO3_guess / m_H_guess if m_H_guess  0 else 1e-10\n        l_guess = np.log(np.array([m_H_guess, m_HCO3_guess, m_CO3_guess]))\n\n        t = 0.0\n        dt, min_dt, max_dt = 0.05, 1e-5, 0.2\n        \n        l_current, converged, _ = newton_solver(system_function, l_guess, t, params)\n        if not converged:\n            m_H_guess = 1e-4\n            m_HCO3_guess = K1 * params['C_T'] / m_H_guess if m_H_guess  0 else 1e-5\n            m_CO3_guess = K2 * m_HCO3_guess / m_H_guess if m_H_guess  0 else 1e-10\n            l_guess = np.log(np.array([m_H_guess, m_HCO3_guess, m_CO3_guess]))\n            l_current, converged, _ = newton_solver(system_function, l_guess, t, params)\n            if not converged:\n                raise RuntimeError(\"Initial solver failed for t=0\")\n\n        while t  1.0:\n            t_next = min(1.0, t + dt)\n            l_next, converged, iters = newton_solver(system_function, l_current, t_next, params)\n\n            if converged:\n                l_current, t = l_next, t_next\n                if iters  4: dt = min(dt * 1.5, max_dt)\n            else:\n                dt *= 0.5\n                if dt  min_dt: raise RuntimeError(f\"Homotopy failed at t={t}\")\n        \n        l_final = l_current\n        m_H_final = np.exp(l_final[0])\n        gamma_H_final = compute_auxiliary_vars(l_final, 1.0, params['N_T'], params['Cl_T'])['gammas']['H']\n        a_H_final = gamma_H_final * m_H_final\n        return -np.log10(a_H_final)\n\n    # --- End of self-contained definitions ---\n\n    test_cases = [\n        {'C_T': 2.0e-3, 'N_T': 1.0e-2, 'Cl_T': 1.0e-2}, # Case A\n        {'C_T': 2.0e-3, 'N_T': 0.5, 'Cl_T': 0.5},       # Case B\n        {'C_T': 1.0e-5, 'N_T': 1.0e-3, 'Cl_T': 1.0e-3}, # Case C\n    ]\n\n    results = []\n    for params in test_cases:\n        pH_final = solve_case(params)\n        results.append(f\"{pH_final:.4f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}