{
    "hands_on_practices": [
        {
            "introduction": "Solving for equilibrium pH is a cornerstone of aqueous geochemistry. This first practice connects fundamental chemical principles—mass action, mass balance, and electroneutrality—directly to a numerical solution. By deriving the governing non-linear equation for a carbonate system from scratch and implementing the robust bisection method, you will build a foundational understanding of how geochemical problems are formulated and solved computationally .",
            "id": "4094375",
            "problem": "Consider an aqueous solution at temperature $25\\,^{\\circ}\\mathrm{C}$ containing weak acid-base systems and strong electrolytes. The goal is to numerically solve an electroneutrality condition expressed as a non-linear algebraic equation in terms of the acidity $\\mathrm{pH}$. The fundamental starting point is the principle of electroneutrality, which states that the sum of positive charges equals the sum of negative charges at equilibrium, along with equilibrium mass-action relationships and total mass-balance constraints for the acid-base systems. Assume ideal solution behavior so that chemical activities are approximated by molar concentrations.\n\nLet the weak acid system be the inorganic carbon system $\\mathrm{H_{2}CO_{3}^{*}}/\\mathrm{HCO_{3}^{-}}/\\mathrm{CO_{3}^{2-}}$ with first and second acid dissociation constants denoted $K_{1}$ and $K_{2}$, respectively. Let the autoprotolysis of water be characterized by the ionic product $K_{w}$. All constants are at $25\\,^{\\circ}\\mathrm{C}$:\n- $K_{1} = 10^{-6.3}$,\n- $K_{2} = 10^{-10.3}$,\n- $K_{w} = 10^{-14}$.\n\nDefine the total concentration of Dissolved Inorganic Carbon (DIC) as $C_{\\mathrm{T}}$ in $\\mathrm{mol/L}$, and the total concentrations of strong electrolyte ions sodium and chloride as $C_{\\mathrm{Na}}$ and $C_{\\mathrm{Cl}}$ in $\\mathrm{mol/L}$, respectively. Treat sodium and chloride as fully dissociated.\n\nFor a given $\\mathrm{pH}$, denote $H = [\\mathrm{H^{+}}] = 10^{-\\mathrm{pH}}$ and $[\\mathrm{OH^{-}}] = K_{w}/H$. Using mass-action and conservation for the carbonate system, the species concentrations $[\\mathrm{H_{2}CO_{3}^{*}}]$, $[\\mathrm{HCO_{3}^{-}}]$, and $[\\mathrm{CO_{3}^{2-}}]$ are functions of $H$, $K_{1}$, $K_{2}$, and $C_{\\mathrm{T}}$ obtainable from the dissociation equilibria and total $C_{\\mathrm{T}}$ constraint. Construct the electroneutrality function $f(\\mathrm{pH})$ as the difference between the sum of positive charges and the sum of negative charges,\n$$\nf(\\mathrm{pH}) = \\left( [\\mathrm{H^{+}}] + C_{\\mathrm{Na}} \\right) - \\left( [\\mathrm{OH^{-}}] + C_{\\mathrm{Cl}} + [\\mathrm{HCO_{3}^{-}}] + 2[\\mathrm{CO_{3}^{2-}}] \\right),\n$$\nexpressed entirely as a function of $\\mathrm{pH}$ via $H=10^{-\\mathrm{pH}}$ and the carbonate speciation functions.\n\nTask:\n1. Starting from the above fundamental principles (electroneutrality, mass-action, and mass-balance), derive mathematically how to express $[\\mathrm{H_{2}CO_{3}^{*}}]$, $[\\mathrm{HCO_{3}^{-}}]$, and $[\\mathrm{CO_{3}^{2-}}]$ in terms of $H$, $K_{1}$, $K_{2}$, and $C_{\\mathrm{T}}$ without introducing any shortcut formulas not derivable from these principles.\n2. Using these expressions, formulate a bisection algorithm to solve $f(\\mathrm{pH}) = 0$ over a closed bracket $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$ under the assumptions that $f$ is continuous on the bracket and changes sign at the endpoints. Explicitly justify the continuity of $f(\\mathrm{pH})$ and explain why a sign change $f(\\mathrm{pH}_{\\min}) \\cdot f(\\mathrm{pH}_{\\max})  0$ implies the existence of a root in the bracket.\n3. Implement the bisection method to find $\\mathrm{pH}$ for each test case below, using a tolerance of $10^{-8}$ for the bracket width or for $|f(\\mathrm{pH})|$, whichever criterion you choose to enforce. All concentrations must be handled in $\\mathrm{mol/L}$, and the final $\\mathrm{pH}$ is dimensionless. The solution must not rely on any external input and must be numerically stable.\n\nTest Suite (each entry is $(C_{\\mathrm{T}}, C_{\\mathrm{Na}}, C_{\\mathrm{Cl}}, \\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max})$):\n- Case A (general freshwater carbonate system): $(2.0 \\times 10^{-3},\\; 1.0 \\times 10^{-3},\\; 1.0 \\times 10^{-3},\\; 4,\\; 10)$.\n- Case B (acidic chloride-rich system): $(1.0 \\times 10^{-4},\\; 0.0,\\; 1.0 \\times 10^{-3},\\; 0,\\; 7)$.\n- Case C (basic sodium-rich system): $(1.0 \\times 10^{-3},\\; 5.0 \\times 10^{-4},\\; 0.0,\\; 4,\\; 14)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the three computed $\\mathrm{pH}$ values for Cases A, B, and C, as a comma-separated list enclosed in square brackets, with each $\\mathrm{pH}$ rounded to six decimal places, for example, $[\\mathrm{pH}_{A},\\mathrm{pH}_{B},\\mathrm{pH}_{C}]$.",
            "solution": "The problem requires finding the equilibrium $\\mathrm{pH}$ of an aqueous solution containing the inorganic carbon system and strong electrolytes by numerically solving the electroneutrality equation. This is a fundamental problem in computational geochemistry. The solution comprises three main parts as requested: deriving the governing equations from first principles, formulating the numerical algorithm, and implementing the solution.\n\n### Part 1: Derivation of Carbonate Species Concentrations\n\nThe speciation of the carbonate system in water is governed by chemical equilibria and a mass balance constraint. We begin by stating these fundamental relationships. All concentrations are in $\\mathrm{mol/L}$.\n\nLet $H = [\\mathrm{H^{+}}]$. The dissociation reactions for the carbonate system are:\n1.  $\\mathrm{H_{2}CO_{3}^{*}} \\rightleftharpoons \\mathrm{H^{+}} + \\mathrm{HCO_{3}^{-}}$\n2.  $\\mathrm{HCO_{3}^{-}} \\rightleftharpoons \\mathrm{H^{+}} + \\mathrm{CO_{3}^{2-}}$\n\nAssuming ideal solution behavior, the law of mass action yields the equilibrium constant expressions:\n$$\nK_{1} = \\frac{[\\mathrm{H^{+}}][\\mathrm{HCO_{3}^{-}}]}{[\\mathrm{H_{2}CO_{3}^{*}}]} = \\frac{H \\cdot [\\mathrm{HCO_{3}^{-}}]}{[\\mathrm{H_{2}CO_{3}^{*}}]}\n$$\n$$\nK_{2} = \\frac{[\\mathrm{H^{+}}][\\mathrm{CO_{3}^{2-}}]}{[\\mathrm{HCO_{3}^{-}}]} = \\frac{H \\cdot [\\mathrm{CO_{3}^{2-}}]}{[\\mathrm{HCO_{3}^{-}}]}\n$$\n\nThe total concentration of Dissolved Inorganic Carbon, $C_{\\mathrm{T}}$, is given by the mass balance equation:\n$$\nC_{\\mathrm{T}} = [\\mathrm{H_{2}CO_{3}^{*}}] + [\\mathrm{HCO_{3}^{-}}] + [\\mathrm{CO_{3}^{2-}}]\n$$\n\nOur objective is to express the concentration of each carbonate species ($[\\mathrm{H_{2}CO_{3}^{*}}]$, $[\\mathrm{HCO_{3}^{-}}]$, and $[\\mathrm{CO_{3}^{2-}}]$) as a function of known quantities: $H$, $C_{\\mathrm{T}}$, $K_{1}$, and $K_{2}$.\n\nFrom the equilibrium expressions, we can express $[\\mathrm{H_{2}CO_{3}^{*}}]$ and $[\\mathrm{CO_{3}^{2-}}]$ in terms of $[\\mathrm{HCO_{3}^{-}}]$ and $H$:\n$$\n[\\mathrm{H_{2}CO_{3}^{*}}] = \\frac{H \\cdot [\\mathrm{HCO_{3}^{-}}]}{K_{1}}\n$$\n$$\n[\\mathrm{CO_{3}^{2-}}] = \\frac{K_{2} \\cdot [\\mathrm{HCO_{3}^{-}}]}{H}\n$$\n\nNext, we substitute these expressions into the mass balance equation for $C_{\\mathrm{T}}$:\n$$\nC_{\\mathrm{T}} = \\left( \\frac{H \\cdot [\\mathrm{HCO_{3}^{-}}]}{K_{1}} \\right) + [\\mathrm{HCO_{3}^{-}}] + \\left( \\frac{K_{2} \\cdot [\\mathrm{HCO_{3}^{-}}]}{H} \\right)\n$$\n\nWe factor out $[\\mathrm{HCO_{3}^{-}}]$:\n$$\nC_{\\mathrm{T}} = [\\mathrm{HCO_{3}^{-}}] \\left( \\frac{H}{K_{1}} + 1 + \\frac{K_{2}}{H} \\right)\n$$\n\nTo simplify the term in the parenthesis, we find a common denominator, which is $K_{1}H$:\n$$\nC_{\\mathrm{T}} = [\\mathrm{HCO_{3}^{-}}] \\left( \\frac{H^2 + K_{1}H + K_{1}K_{2}}{K_{1}H} \\right)\n$$\n\nNow, we can solve for $[\\mathrm{HCO_{3}^{-}}]$:\n$$\n[\\mathrm{HCO_{3}^{-}}] = C_{\\mathrm{T}} \\left( \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\n\nWith this expression for $[\\mathrm{HCO_{3}^{-}}]$, we can find the expressions for the other two species by back-substitution:\n$$\n[\\mathrm{H_{2}CO_{3}^{*}}] = \\frac{H}{K_{1}} [\\mathrm{HCO_{3}^{-}}] = \\frac{H}{K_{1}} C_{\\mathrm{T}} \\left( \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} \\right) = C_{\\mathrm{T}} \\left( \\frac{H^2}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\n$$\n[\\mathrm{CO_{3}^{2-}}] = \\frac{K_{2}}{H} [\\mathrm{HCO_{3}^{-}}] = \\frac{K_{2}}{H} C_{\\mathrm{T}} \\left( \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} \\right) = C_{\\mathrm{T}} \\left( \\frac{K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\nThese are the required expressions for the carbonate species concentrations.\n\n### Part 2: Bisection Algorithm Formulation\n\nThe core of the problem is to solve the electroneutrality equation, $f(\\mathrm{pH}) = 0$. The function $f(\\mathrm{pH})$ represents the net charge in the solution and is defined as the sum of all positive charges minus the sum of all negative charges.\n\nThe cations (positive ions) are $\\mathrm{H^{+}}$ and $\\mathrm{Na^{+}}$. The anions (negative ions) are $\\mathrm{OH^{-}}$, $\\mathrm{Cl^{-}}$, $\\mathrm{HCO_{3}^{-}}$, and $\\mathrm{CO_{3}^{2-}}$. The charge of the carbonate ion, $\\mathrm{CO_{3}^{2-}}$, is $-2$, so its concentration is multiplied by $2$ in the charge balance.\n$$\nf(\\mathrm{pH}) = \\sum (\\mathrm{positive\\;charges}) - \\sum (\\mathrm{negative\\;charges})\n$$\n$$\nf(\\mathrm{pH}) = \\left( [\\mathrm{H^{+}}] + [\\mathrm{Na^{+}}] \\right) - \\left( [\\mathrm{OH^{-}}] + [\\mathrm{Cl^{-}}] + [\\mathrm{HCO_{3}^{-}}] + 2 \\cdot [\\mathrm{CO_{3}^{2-}}] \\right)\n$$\nGiven that $\\mathrm{Na^{+}}$ and $\\mathrm{Cl^{-}}$ are from strong electrolytes, their concentrations are $C_{\\mathrm{Na}}$ and $C_{\\mathrm{Cl}}$ respectively. We use the expressions from Part 1 and the autoprotolysis of water, $[\\mathrm{OH^{-}}] = K_{w}/H$, where $H = 10^{-\\mathrm{pH}}$.\n$$\nf(\\mathrm{pH}) = \\left( H + C_{\\mathrm{Na}} \\right) - \\left( \\frac{K_{w}}{H} + C_{\\mathrm{Cl}} + [\\mathrm{HCO_{3}^{-}}] + 2[\\mathrm{CO_{3}^{2-}}] \\right)\n$$\nSubstituting the derived species concentrations:\n$$\n[\\mathrm{HCO_{3}^{-}}] + 2[\\mathrm{CO_{3}^{2-}}] = C_{\\mathrm{T}} \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} + 2 \\cdot C_{\\mathrm{T}} \\frac{K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}} = C_{\\mathrm{T}} \\frac{K_{1}H + 2K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}}\n$$\nThus, the final function to be solved is:\n$$\nf(\\mathrm{pH}) = H + C_{\\mathrm{Na}} - \\frac{K_{w}}{H} - C_{\\mathrm{Cl}} - C_{\\mathrm{T}} \\left( \\frac{K_{1}H + 2K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\nwhere $H=10^{-\\mathrm{pH}}$.\n\nThe bisection method is an iterative root-finding algorithm that applies to continuous functions. The justification for its use here rests on two properties of $f(\\mathrm{pH})$: continuity and the existence of a root within the given bracket.\n\n**Continuity of $f(\\mathrm{pH})$**:\nThe function $f(\\mathrm{pH})$ is a composition and algebraic sum of several simpler functions of $\\mathrm{pH}$:\n1.  $H(\\mathrm{pH}) = 10^{-\\mathrm{pH}}$ is continuous for all real $\\mathrm{pH}$.\n2.  The term $K_{w}/H$ is continuous for all $H0$, i.e., for any finite $\\mathrm{pH}$.\n3.  The carbonate speciation terms are rational functions of $H$. Their denominator is $D(H) = H^2 + K_{1}H + K_{1}K_{2}$. Since all parameters ($H$, $K_{1}$, $K_{2}$) are strictly positive for any physical solution, the denominator $D(H)$ is always positive and never zero. Therefore, the carbonate terms are continuous functions of $H$.\nSince $f(\\mathrm{pH})$ is constructed from sums, differences, and compositions of these continuous functions, it is itself a continuous function of $\\mathrm{pH}$ on any interval $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$ with $0 \\le \\mathrm{pH}_{\\min}  \\mathrm{pH}_{\\max}  \\infty$.\n\n**Existence of a Root**:\nThe Bisection Method relies on the **Intermediate Value Theorem (IVT)**. The IVT states that if a function $g(x)$ is continuous on a closed interval $[a, b]$, then for any value $N$ between $g(a)$ and $g(b)$, there must exist at least one point $c \\in [a, b]$ such that $g(c) = N$.\nIn our case, the problem specifies a search bracket $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$ and assumes a sign change, i.e., $f(\\mathrm{pH}_{\\min}) \\cdot f(\\mathrm{pH}_{\\max})  0$. This means that one of $f(\\mathrm{pH}_{\\min})$ or $f(\\mathrm{pH}_{\\max})$ is positive and the other is negative. Consequently, the value $N=0$ lies between $f(\\mathrm{pH}_{\\min})$ and $f(\\mathrm{pH}_{\\max})$. Since $f(\\mathrm{pH})$ is continuous on this interval, the IVT guarantees the existence of at least one root $\\mathrm{pH}_{\\text{root}} \\in (\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max})$ such that $f(\\mathrm{pH}_{\\text{root}}) = 0$.\n\n**The Bisection Algorithm**:\nLet the search interval be $[a, b]$, initialized to $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$. We require $f(a)$ and $f(b)$ to have opposite signs. The algorithm proceeds as follows:\n1.  Set a tolerance $\\epsilon$ (e.g., $10^{-8}$).\n2.  Repeat while the width of the interval $(b-a)$ is greater than $\\epsilon$:\n    a. Calculate the midpoint of the interval: $m = a + (b-a)/2$.\n    b. Evaluate the function at the midpoint, $f(m)$.\n    c. If $f(a)$ and $f(m)$ have opposite signs (i.e., $f(a) \\cdot f(m)  0$), then the root must lie in the interval $[a, m]$. Update the interval by setting $b = m$.\n    d. Otherwise, the root must lie in $[m, b]$ (i.e., $f(m) \\cdot f(b) \\le 0$). Update the interval by setting $a = m$.\n3.  Once the loop terminates, the interval $[a, b]$ is smaller than the tolerance $\\epsilon$. The root can be approximated as the midpoint of this final interval, $(a+b)/2$.\n\nThis algorithm is guaranteed to converge to a root, halving the interval of uncertainty at each iteration.\n\n### Part 3: Implementation\n\nThe bisection algorithm is implemented in Python. A function computes the value of the electroneutrality function $f(\\mathrm{pH})$ for a given set of parameters. A second function implements the bisection search. This process is applied to each of the three test cases. The constants are defined as $K_{1} = 10^{-6.3}$, $K_{2} = 10^{-10.3}$, and $K_{w} = 10^{-14}$. A stopping criterion based on the interval width being less than a tolerance of $10^{-8}$ is used.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the pH of an aqueous carbonate system using the bisection method.\n    The function sets up the problem parameters for three test cases and computes\n    the equilibrium pH for each by finding the root of the electroneutrality equation.\n    \"\"\"\n\n    # Define constants at 25 degrees Celsius\n    K1 = 10**(-6.3)\n    K2 = 10**(-10.3)\n    KW = 10**(-14.0)\n\n    # Define the test cases from the problem statement.\n    # Each tuple: (C_T, C_Na, C_Cl, pH_min, pH_max)\n    test_cases = [\n        # Case A: General freshwater carbonate system\n        (2.0e-3, 1.0e-3, 1.0e-3, 4.0, 10.0),\n        # Case B: Acidic chloride-rich system\n        (1.0e-4, 0.0, 1.0e-3, 0.0, 7.0),\n        # Case C: Basic sodium-rich system\n        (1.0e-3, 5.0e-4, 0.0, 4.0, 14.0),\n    ]\n\n    def electroneutrality_func(ph, C_T, C_Na, C_Cl):\n        \"\"\"\n        Calculates the value of the electroneutrality function f(pH).\n\n        f(pH) = (sum of positive charges) - (sum of negative charges)\n        \"\"\"\n        H = 10**(-ph)\n        OH = KW / H\n\n        # Carbonate speciation term: [HCO3-] + 2*[CO3^2-]\n        # Denominator of the speciation fractions\n        denominator = H**2 + K1 * H + K1 * K2\n        \n        # Avoid division by zero, though for H0 denominator is always  0\n        if denominator == 0:\n            # This case is physically impossible for H  0\n            return np.inf\n\n        # [HCO3-] + 2*[CO3^2-] = C_T * (K1*H / denom) + 2 * C_T * (K1*K2 / denom)\n        carbonate_charge_term = C_T * (K1 * H + 2 * K1 * K2) / denominator\n        \n        # Calculate net charge (the function f(pH) we want to find the root of)\n        # f(pH) = [H+] + [Na+] - ([OH-] + [Cl-] + [HCO3-] + 2*[CO3^2-])\n        net_charge = (H + C_Na) - (OH + C_Cl + carbonate_charge_term)\n\n        return net_charge\n\n    def bisection_solver(params, tol=1.0e-8, max_iter=100):\n        \"\"\"\n        Finds the root of the electroneutrality function using the bisection method.\n        \"\"\"\n        C_T, C_Na, C_Cl, ph_min, ph_max = params\n        \n        a = ph_min\n        b = ph_max\n        \n        f_a = electroneutrality_func(a, C_T, C_Na, C_Cl)\n        f_b = electroneutrality_func(b, C_T, C_Na, C_Cl)\n\n        # Check if a root is guaranteed to be in the interval\n        if f_a * f_b = 0:\n            # This case should not occur with the problem's given brackets\n            # but is good practice to check.\n            if abs(f_a)  tol: return a\n            if abs(f_b)  tol: return b\n            raise ValueError(\"Bisection method fails: f(a) and f(b) must have opposite signs.\")\n            \n        for _ in range(max_iter):\n            mid = a + (b - a) / 2\n            f_mid = electroneutrality_func(mid, C_T, C_Na, C_Cl)\n\n            if abs(f_mid)  tol or (b - a) / 2  tol:\n                return mid\n            \n            # Update the interval\n            if f_a * f_mid  0:\n                b = mid\n            else:\n                a = mid\n                f_a = f_mid # Update f_a to f_mid\n\n        return (a + b) / 2\n\n    results = []\n    for case in test_cases:\n        ph_solution = bisection_solver(case)\n        results.append(f\"{ph_solution:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "As we move from single equations to large, multi-species systems, the efficiency of our numerical methods becomes paramount. Newton-based solvers rely on the Jacobian matrix, which for geochemical systems is typically sparse. This practice focuses on uncovering this structure, demonstrating how the Jacobian's sparsity pattern is a direct mathematical representation of the chemical reaction network defined by the stoichiometric matrix . Understanding this link is the first step toward developing highly efficient and scalable geochemical solvers.",
            "id": "4094338",
            "problem": "Consider a non-linear algebraic system for chemical speciation at equilibrium in computational geochemistry constructed from independent components and complexes. Let there be $n_c$ independent components and $n_x$ complexes, with total species count $n_s = n_c + n_x$. Define the stoichiometric matrix $S \\in \\mathbb{R}^{n_c \\times n_x}$ whose entry $S_{i j} \\ge 0$ is the stoichiometric coefficient of component $i$ in complex $j$. Define the integer charge vector $z \\in \\mathbb{Z}^{n_s}$ for all species ordered as independent components first followed by complexes. The unknowns are the species molalities arranged as $\\{m_k\\}_{k=1}^{n_s}$, and we use their natural logarithms $\\{\\ln m_k\\}_{k=1}^{n_s}$ for numerical solution.\n\nFrom fundamental laws of chemical equilibrium and conservation:\n- The mass action law for complex $j$ states $m_j \\propto \\prod_{i=1}^{n_c} m_i^{S_{i j}}$, which in logarithmic form yields residuals of the type $R_j^{\\mathrm{ma}} = \\ln m_j - \\sum_{i=1}^{n_c} S_{i j} \\ln m_i - \\ln K_j$, where $K_j$ is the equilibrium constant for complex $j$.\n- The mass balance for component $i$ enforces $R_i^{\\mathrm{mb}} = m_i + \\sum_{j=1}^{n_x} S_{i j} m_j - T_i$, where $T_i$ is the total concentration of component $i$.\n- The electroneutrality constraint enforces $R^{\\mathrm{en}} = \\sum_{k=1}^{n_s} z_k m_k = 0$ when present.\n\nWe are concerned only with the Jacobian sparsity pattern, which is the binary structure indicating which partial derivatives $\\partial R / \\partial x$ are structurally non-zero, not their numerical values. For this, it suffices to identify whether a residual depends on a variable. We impose a canonical ordering of rows (residuals) and columns (variables) as follows:\n- Rows: first the $n_x$ complex mass action residuals $\\{R_j^{\\mathrm{ma}}\\}_{j=1}^{n_x}$, then the $n_c$ component mass balance residuals $\\{R_i^{\\mathrm{mb}}\\}_{i=1}^{n_c}$, and finally the single electroneutrality residual $R^{\\mathrm{en}}$ if present. Thus, the number of residuals is $m = n_x + n_c + \\delta_{\\mathrm{en}}$, where $\\delta_{\\mathrm{en}} \\in \\{0,1\\}$ indicates whether $R^{\\mathrm{en}}$ is included.\n- Columns: first the $n_c$ independent component variables $\\{\\ln m_i\\}_{i=1}^{n_c}$, then the $n_x$ complex variables $\\{\\ln m_j\\}_{j=1}^{n_x}$ mapped to columns $n_c + j$.\n\nUsing only the stoichiometric matrix $S$ and charge vector $z$, construct the Jacobian sparsity pattern $P \\in \\{0,1\\}^{m \\times n_s}$ based on the following structural dependency rules derived from the above fundamental equations:\n- For each complex mass action residual $R_j^{\\mathrm{ma}}$, the non-zero entries are at its own complex variable column and at the independent component columns $i$ for which $S_{i j} \\neq 0$.\n- For each component mass balance residual $R_i^{\\mathrm{mb}}$, the non-zero entries are at its own component variable column $i$ and at the complex variable columns $n_c + j$ for which $S_{i j} \\neq 0$.\n- For the electroneutrality residual $R^{\\mathrm{en}}$, the non-zero entries are at all species variable columns $k$ for which $z_k \\neq 0$.\n\nIdentify and report the index pairs of non-zero entries grouped into block structures corresponding to independent components, complexes, and constraints. Use the following block definitions with row and column index conventions specified above:\n- Block $A$: complex mass action residuals versus independent component variables, i.e., pairs $(\\text{row } j, \\text{col } i)$ where $S_{i j} \\neq 0$ and $j \\in \\{0,\\dots,n_x-1\\}$, $i \\in \\{0,\\dots,n_c-1\\}$.\n- Block $B$: complex mass action residuals versus complex variables (the diagonal in this sub-block), i.e., pairs $(\\text{row } j, \\text{col } n_c + j)$ for $j \\in \\{0,\\dots,n_x-1\\}$.\n- Block $C$: component mass balance residuals versus independent component variables (the diagonal in this sub-block), i.e., pairs $(\\text{row } n_x + i, \\text{col } i)$ for $i \\in \\{0,\\dots,n_c-1\\}$.\n- Block $D$: component mass balance residuals versus complex variables, i.e., pairs $(\\text{row } n_x + i, \\text{col } n_c + j)$ where $S_{i j} \\neq 0$.\n- Block $E$: electroneutrality residual versus all species variables with non-zero charge, i.e., pairs $(\\text{row } n_x + n_c, \\text{col } k)$ where $z_k \\neq 0$ provided the electroneutrality residual is included.\n\nYour task is to implement a program that, for each test case, constructs these blocks and outputs the following list for that test case:\n$[m, n_s, A, B, C, D, E]$,\nwhere $m$ and $n_s$ are integers and each block is a list of index pairs $[r, c]$ as integers. If the electroneutrality residual is not included in a test case, output an empty list for $E$.\n\nTest suite:\n- Case $1$ (happy path, multiple components and complexes, with charges):\n$n_c = 3$, $n_x = 2$, components ordered as $(\\mathrm{H}^+, \\mathrm{Na}^+, \\mathrm{Cl}^-)$ and complexes ordered as $(\\mathrm{HCl}, \\mathrm{NaCl})$.\n$$\nS = \\begin{bmatrix}\n1  0 \\\\\n0  1 \\\\\n1  1\n\\end{bmatrix}, \\quad\nz = \\begin{bmatrix}\n1 \\\\ 1 \\\\ -1 \\\\ 0 \\\\ 0\n\\end{bmatrix}, \\quad \\text{include electroneutrality}.\n$$\n- Case $2$ (edge case, one complex, with charges):\n$n_c = 2$, $n_x = 1$, components ordered as $(\\mathrm{Ca}^{2+}, \\mathrm{CO}_3^{2-})$ and complex $(\\mathrm{CaCO}_3)$.\n$$\nS = \\begin{bmatrix}\n1 \\\\\n1\n\\end{bmatrix}, \\quad\nz = \\begin{bmatrix}\n2 \\\\ -2 \\\\ 0\n\\end{bmatrix}, \\quad \\text{include electroneutrality}.\n$$\n- Case $3$ (boundary case, no complexes, with charges):\n$n_c = 2$, $n_x = 0$, components ordered as $(\\mathrm{H}^+, \\mathrm{OH}^-)$ and no complexes.\n$$\nS = \\begin{bmatrix}\n\\ \\\\\n\\ \n\\end{bmatrix} \\text{ of shape } (2,0), \\quad\nz = \\begin{bmatrix}\n1 \\\\ -1\n\\end{bmatrix}, \\quad \\text{include electroneutrality}.\n$$\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in the order listed above. Each test case result must be a list with the structure $[m, n_s, A, B, C, D, E]$. For example, it should look like $[[\\cdots],[\\cdots],[\\cdots]]$ when printed, where all entries are integers, booleans, floats, or lists of these.",
            "solution": "The problem as stated is valid. It is scientifically grounded in the principles of chemical equilibrium, mathematically well-posed, and presented objectively. It requests the construction of the Jacobian sparsity pattern for a system of non-linear algebraic equations common in computational geochemistry. This is a deterministic task based on a clear set of rules derived from fundamental chemical laws.\n\nWe will construct the specified index blocks ($A, B, C, D, E$) that together define the sparsity pattern of the Jacobian matrix. The solution proceeds by systematically translating the provided dependency rules into an algorithm.\n\n**System Definition**\n\nThe problem concerns a chemical system at equilibrium containing $n_c$ independent components and $n_x$ complexes, making a total of $n_s = n_c + n_x$ species. The state of the system is described by the vector of species molalities $\\{m_k\\}_{k=1}^{n_s}$. For numerical stability, the solver operates on the natural logarithms of the molalities, $\\{\\ln m_k\\}_{k=1}^{n_s}$.\n\nThe system is governed by a set of non-linear algebraic equations, expressed as residuals that must be zero at equilibrium:\n1.  **Mass Action Law (for $n_x$ complexes):** For each complex $j$, the law of mass action defines an equilibrium relationship. In logarithmic form, this gives a residual $R_j^{\\mathrm{ma}}$:\n    $$R_j^{\\mathrm{ma}} = \\ln m_{n_c+j} - \\sum_{i=1}^{n_c} S_{i j} \\ln m_i - \\ln K_j = 0$$\n    Here, $S_{ij}$ (from the stoichiometric matrix $S \\in \\mathbb{R}^{n_c \\times n_x}$) is the number of units of component $i$ per unit of complex $j$, $K_j$ is the equilibrium constant, and we use the convention that species indices $k=1, \\dots, n_c$ correspond to components and $k=n_c+1, \\dots, n_s$ correspond to complexes.\n\n2.  **Mass Balance (for $n_c$ components):** For each component $i$, the total concentration $T_i$ must be conserved. This gives a residual $R_i^{\\mathrm{mb}}$:\n    $$R_i^{\\mathrm{mb}} = m_i + \\sum_{j=1}^{n_x} S_{i j} m_{n_c+j} - T_i = 0$$\n\n3.  **Electroneutrality (optional):** The total charge of the solution must be zero. This gives a single residual $R^{\\mathrm{en}}$:\n    $$R^{\\mathrm{en}} = \\sum_{k=1}^{n_s} z_k m_k = 0$$\n    where $z_k$ is the integer charge of species $k$.\n\n**Jacobian Sparsity Pattern**\n\nThe Jacobian matrix $J$ contains the partial derivatives of each residual with respect to each variable, $J_{pq} = \\partial R_p / \\partial x_q$, where $R_p$ are the residuals and $x_q = \\ln m_q$ are the variables. The sparsity pattern is a binary matrix indicating which of these derivatives are structurally non-zero. The ordering of rows (residuals) and columns (variables) is specified as:\n-   **Rows (index $r$):** $n_x$ residuals $\\{R_j^{\\mathrm{ma}}\\}$, followed by $n_c$ residuals $\\{R_i^{\\mathrm{mb}}\\}$, and one optional $R^{\\mathrm{en}}$. Total rows $m = n_x + n_c + \\delta_{\\mathrm{en}}$.\n-   **Columns (index $c$):** $n_c$ variables $\\{\\ln m_i\\}$, followed by $n_x$ variables $\\{\\ln m_j\\}$. Total columns $n_s$.\n\nThe structural dependencies are:\n-   $\\partial R_j^{\\mathrm{ma}} / \\partial (\\ln m_k)$: This residual is linear in the log-molalities. The derivative is non-zero for its own complex variable $\\ln m_{n_c+j}$ and for component variables $\\ln m_i$ where $S_{ij} \\neq 0$.\n-   $\\partial R_i^{\\mathrm{mb}} / \\partial (\\ln m_k)$: This residual is a function of molalities $m_k$. Using the chain rule, $\\partial R_i^{\\mathrm{mb}} / \\partial(\\ln m_k) = (\\partial R_i^{\\mathrm{mb}}/\\partial m_k) \\cdot (\\partial m_k/\\partial \\ln m_k) = (\\partial R_i^{\\mathrm{mb}}/\\partial m_k) \\cdot m_k$. Since $m_k  0$, the derivative is structurally non-zero if and only if $R_i^{\\mathrm{mb}}$ depends on $m_k$. This occurs for its own component $m_i$ and for complexes $m_{n_c+j}$ where component $i$ is a constituent ($S_{ij} \\neq 0$).\n-   $\\partial R^{\\mathrm{en}} / \\partial (\\ln m_k)$: Similarly, this derivative is structurally non-zero for any species $k$ that has a non-zero charge, $z_k \\neq 0$.\n\n**Algorithmic Construction of Sparsity Blocks**\n\nWe implement an algorithm that takes the stoichiometric matrix $S$, charge vector $z$, and the electroneutrality flag $\\delta_{\\mathrm{en}}$ as input. All indices are 0-based in the implementation. The dimensions are $n_c = \\text{S.shape}[0]$, $n_x = \\text{S.shape}[1]$, $n_s = n_c + n_x$, and $m = n_x + n_c + \\delta_{\\mathrm{en}}$.\n\n1.  **Block $A$ (Mass Action vs. Components):** These entries correspond to $\\partial R_j^{\\mathrm{ma}} / \\partial(\\ln m_i)$. The non-zero pairs are $(r, c) = (j, i)$ for $j \\in \\{0, \\dots, n_x-1\\}$ and $i \\in \\{0, \\dots, n_c-1\\}$, where $S_{ij} \\neq 0$. We iterate through all $(i, j)$ and if $S_{ij} \\neq 0$, we add the coordinate pair $[j, i]$ to list $A$.\n\n2.  **Block $B$ (Mass Action vs. Complexes):** These entries correspond to $\\partial R_j^{\\mathrm{ma}} / \\partial(\\ln m_{n_c+j})$. The non-zero pairs are $(r, c) = (j, n_c+j)$ for $j \\in \\{0, \\dots, n_x-1\\}$. This forms a diagonal structure. We iterate $j$ from $0$ to $n_x-1$ and add $[j, n_c+j]$ to list $B$.\n\n3.  **Block $C$ (Mass Balance vs. Components):** These entries correspond to $\\partial R_i^{\\mathrm{mb}} / \\partial(\\ln m_i)$. The non-zero pairs are $(r, c) = (n_x+i, i)$ for $i \\in \\{0, \\dots, n_c-1\\}$. This also forms a diagonal structure. We iterate $i$ from $0$ to $n_c-1$ and add $[n_x+i, i]$ to list $C$.\n\n4.  **Block $D$ (Mass Balance vs. Complexes):** These entries correspond to $\\partial R_i^{\\mathrm{mb}} / \\partial(\\ln m_{n_c+j})$. The non-zero pairs are $(r, c) = (n_x+i, n_c+j)$ for $i \\in \\{0, \\dots, n_c-1\\}$ and $j \\in \\{0, \\dots, n_x-1\\}$, where $S_{ij} \\neq 0$. This block structure is effectively the transpose of $S$. We iterate through all $(i, j)$ and if $S_{ij} \\neq 0$, we add $[n_x+i, n_c+j]$ to list $D$.\n\n5.  **Block $E$ (Electroneutrality vs. All Species):** If electroneutrality is included ($\\delta_{\\mathrm{en}}=1$), these entries correspond to $\\partial R^{\\mathrm{en}} / \\partial(\\ln m_k)$. The row index is fixed at $r = n_x+n_c$. The non-zero pairs are $(r, c) = (n_x+n_c, k)$ for all species $k \\in \\{0, \\dots, n_s-1\\}$ where $z_k \\neq 0$. We iterate $k$ from $0$ to $n_s-1$ and if $z_k \\neq 0$, add $[n_x+n_c, k]$ to list $E$. If $\\delta_{\\mathrm{en}}=0$, $E$ is an empty list.\n\nThe final output for each test case is a list containing the computed dimensions and the five block lists: $[m, n_s, A, B, C, D, E]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the result.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: happy path, multiple components and complexes, with charges\n        {\n            \"S\": np.array([[1, 0], [0, 1], [1, 1]]),\n            \"z\": np.array([1, 1, -1, 0, 0]),\n            \"include_en\": True\n        },\n        # Case 2: edge case, one complex, with charges\n        {\n            \"S\": np.array([[1], [1]]),\n            \"z\": np.array([2, -2, 0]),\n            \"include_en\": True\n        },\n        # Case 3: boundary case, no complexes, with charges\n        {\n            \"S\": np.array([[], []]).reshape(2, 0),\n            \"z\": np.array([1, -1]),\n            \"include_en\": True\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        S = case[\"S\"]\n        z = case[\"z\"]\n        include_en = case[\"include_en\"]\n\n        # Determine dimensions based on the shapes of S and z\n        if S.ndim == 1:\n            S = S.reshape(-1, 1) # Handle 1D array for single complex\n        \n        n_c = S.shape[0]  # Number of components\n        n_x = S.shape[1]  # Number of complexes\n        n_s = n_c + n_x   # Total number of species\n        delta_en = 1 if include_en else 0\n        m = n_x + n_c + delta_en # Total number of residuals/rows\n\n        # Initialize lists for each block of non-zero indices\n        A, B, C, D, E = [], [], [], [], []\n\n        # Find non-zero indices in S for blocks A and D\n        # S_ij is coeff of component i in complex j\n        # In numpy, S[i,j]\n        component_indices, complex_indices = np.nonzero(S)\n\n        # Block A: mass action residuals vs. independent component variables\n        # (row j, col i) for S_ij != 0\n        A = sorted([[int(j), int(i)] for i, j in zip(component_indices, complex_indices)])\n\n        # Block B: mass action residuals vs. complex variables (diagonal)\n        # (row j, col n_c + j)\n        B = [[j, n_c + j] for j in range(n_x)]\n\n        # Block C: component mass balance residuals vs. independent component variables (diagonal)\n        # (row n_x + i, col i)\n        C = [[n_x + i, i] for i in range(n_c)]\n\n        # Block D: component mass balance residuals vs. complex variables\n        # (row n_x + i, col n_c + j) for S_ij != 0\n        D = sorted([[n_x + int(i), n_c + int(j)] for i, j in zip(component_indices, complex_indices)])\n        \n        # Block E: electroneutrality residual vs. all species variables\n        if include_en:\n            en_row = n_x + n_c\n            charged_species_indices, = np.nonzero(z)\n            E = [[en_row, int(k)] for k in charged_species_indices]\n\n        case_result = [m, n_s, A, B, C, D, E]\n        results.append(case_result)\n    \n    # Custom string representation to match format without spaces\n    def list_to_compact_str(item):\n        if isinstance(item, list):\n            return f\"[{','.join(map(list_to_compact_str, item))}]\"\n        return str(item)\n\n    # Convert the list of results to a single string\n    # The default str() in Python adds spaces, which we avoid for exactness.\n    # The prompt's example format is `[[...],[...],[...]]`, which is compact.\n    output_str = list_to_compact_str(results)\n\n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Many realistic geochemical models, especially those including non-ideal activity corrections, result in highly non-linear systems that can be difficult for standard solvers to converge. This advanced practice introduces homotopy continuation, a powerful strategy for ensuring global convergence. You will implement a method that starts from a simple, solvable problem (an ideal solution) and incrementally deforms it into the full, complex problem, effectively guiding the solver along a path to the correct solution . This technique is essential for building robust solvers capable of handling real-world complexity.",
            "id": "4094405",
            "problem": "Consider a carbonate aqueous system at standard conditions where sodium and chloride provide a background electrolyte. The objective is to solve a non-linear algebraic equilibrium model that includes the law of mass action and charge balance, and to construct and traverse a homotopy continuation from an ideal solution approximation to a full activity-coefficient model using the Davies equation. Let the vector of unknowns be $\\ell = (\\ln m_{\\mathrm{H}^+}, \\ln m_{\\mathrm{HCO}_3^-}, \\ln m_{\\mathrm{CO}_3^{2-}})$, where $m_i$ denotes molar concentration in $\\mathrm{mol/L}$, and activities are $a_i = \\gamma_i m_i$.\n\nFundamental base:\n- Law of mass action for acid dissociation and water autoprotolysis, using activities:\n  - First dissociation of carbonic acid: $K_1 = \\dfrac{a_{\\mathrm{H}^+} a_{\\mathrm{HCO}_3^-}}{a_{\\mathrm{H}_2\\mathrm{CO}_3}}$.\n  - Second dissociation: $K_2 = \\dfrac{a_{\\mathrm{H}^+} a_{\\mathrm{CO}_3^{2-}}}{a_{\\mathrm{HCO}_3^-}}$.\n  - Water autoprotolysis: $K_w = a_{\\mathrm{H}^+} a_{\\mathrm{OH}^-}$.\n- Electroneutrality: $\\sum z_i m_i = 0$ for all charged species $i$, where $z_i$ is the charge of species $i$.\n- Total inorganic carbon mass balance: $C_T = m_{\\mathrm{H}_2\\mathrm{CO}_3} + m_{\\mathrm{HCO}_3^-} + m_{\\mathrm{CO}_3^{2-}}$.\n- Ionic strength definition: $I = \\dfrac{1}{2} \\sum_i m_i z_i^2$.\n- Davies equation for activity coefficients of ions at $25^\\circ\\mathrm{C}$: $\\log_{10} \\gamma_i = -A z_i^2\\left( \\dfrac{\\sqrt{I}}{1+\\sqrt{I}} - 0.3 I \\right)$ with $A = 0.509$. Neutral species are taken as $\\gamma=1$.\n\nLet the known totals of sodium and chloride be $N_T$ and $Cl_T$ respectively, assumed to be present only as $\\mathrm{Na}^+$ and $\\mathrm{Cl}^-$. Constants at $25^\\circ\\mathrm{C}$ are $K_1 = 10^{-6.3}$, $K_2 = 10^{-10.3}$, and $K_w = 10^{-14}$.\n\nDefine a homotopy $H(\\ell,t) = F_t(\\ell)$ where $t \\in [0,1]$ controls the extent to which activity effects are included. Specifically, compute the ionic strength $I(\\ell)$ from current concentrations and use a scaled ionic strength $I_t(\\ell) = t\\, I(\\ell)$ in the Davies equation to obtain $\\gamma_i(t)$, so that $\\gamma_i(0)=1$ for all ions (ideal solution) and $\\gamma_i(1)$ is the full Davies value. Construct $F_t(\\ell)=0$ as the system:\n- Carbon mass balance:\n  $$F_{t,1}(\\ell) = m_{\\mathrm{H}_2\\mathrm{CO}_3} + m_{\\mathrm{HCO}_3^-} + m_{\\mathrm{CO}_3^{2-}} - C_T,$$\n  with $m_{\\mathrm{H}_2\\mathrm{CO}_3} = \\dfrac{a_{\\mathrm{H}^+} a_{\\mathrm{HCO}_3^-}}{K_1}$ and $a_{\\mathrm{H}^+} = \\gamma_{\\mathrm{H}^+}(t) m_{\\mathrm{H}^+}$, $a_{\\mathrm{HCO}_3^-} = \\gamma_{\\mathrm{HCO}_3^-}(t) m_{\\mathrm{HCO}_3^-}$, and $\\gamma_{\\mathrm{H}_2\\mathrm{CO}_3}=1$.\n- Second dissociation equilibrium:\n  $$F_{t,2}(\\ell) = a_{\\mathrm{H}^+} a_{\\mathrm{CO}_3^{2-}} - K_2 a_{\\mathrm{HCO}_3^-},$$\n  with $a_{\\mathrm{CO}_3^{2-}} = \\gamma_{\\mathrm{CO}_3^{2-}}(t) m_{\\mathrm{CO}_3^{2-}}$.\n- Electroneutrality:\n  $$F_{t,3}(\\ell) = N_T + m_{\\mathrm{H}^+} - \\left(Cl_T + m_{\\mathrm{OH}^-} + m_{\\mathrm{HCO}_3^-} + 2 m_{\\mathrm{CO}_3^{2-}} \\right),$$\n  where $m_{\\mathrm{OH}^-}$ is determined implicitly by $K_w = a_{\\mathrm{H}^+} a_{\\mathrm{OH}^-}$ as $m_{\\mathrm{OH}^-} = \\dfrac{K_w}{a_{\\mathrm{H}^+}\\, \\gamma_{\\mathrm{OH}^-}(t)}$.\n\nThe task is to:\n1. Implement a Newton method in the variables $\\ell$ with a numerical Jacobian to solve $F_t(\\ell)=0$ at fixed $t$ and with a line search to robustly decrease the residual.\n2. Implement a homotopy continuation strategy that starts at $t=0$ (ideal solution) and advances $t$ to $t=1$ using adaptive step size $\\Delta t$ selection to maintain Newton method convergence. Use the previous solution at $t$ as the initial guess for $t+\\Delta t$. If Newton converges in few iterations, increase $\\Delta t$; if it converges slowly or fails, reduce $\\Delta t$ and retry.\n3. Compute the negative base-10 logarithm of the hydrogen ion activity at $t=1$, $pH = -\\log_{10}\\left(a_{\\mathrm{H}^+}\\right)$, for each test case.\n\nTest suite:\n- Case A (general case): $C_T = 2.0\\times 10^{-3}\\ \\mathrm{mol/L}$, $N_T = 1.0\\times 10^{-2}\\ \\mathrm{mol/L}$, $Cl_T = 1.0\\times 10^{-2}\\ \\mathrm{mol/L}$.\n- Case B (high ionic strength): $C_T = 2.0\\times 10^{-3}\\ \\mathrm{mol/L}$, $N_T = 0.5\\ \\mathrm{mol/L}$, $Cl_T = 0.5\\ \\mathrm{mol/L}$.\n- Case C (low carbon boundary): $C_T = 1.0\\times 10^{-5}\\ \\mathrm{mol/L}$, $N_T = 1.0\\times 10^{-3}\\ \\mathrm{mol/L}$, $Cl_T = 1.0\\times 10^{-3}\\ \\mathrm{mol/L}$.\n\nAnswer specification:\n- For each test case, output the final $pH$ at $t=1$ as a float number rounded to four decimal places. $pH$ is unitless.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[pH_A,pH_B,pH_C]$), in the order of the test cases listed above.",
            "solution": "The problem statement is assessed as valid. It presents a well-posed and scientifically grounded challenge in computational geochemistry, requiring the numerical solution of a system of non-linear algebraic equations representing chemical equilibria. The problem is self-contained, with all necessary constants, equations, and boundary conditions clearly specified. The use of a homotopy continuation method is an appropriate and standard technique for transitioning from a simplified ideal model to a more complex, non-ideal one.\n\nThe solution is implemented by first formulating the system of three non-linear equations, $F_t(\\ell) = 0$, based on the principles of mass balance, chemical equilibrium, and charge balance. The vector of unknowns, $\\ell$, contains the natural logarithms of the molar concentrations of the primary ionic species: $\\ell = (\\ln m_{\\mathrm{H}^+}, \\ln m_{\\mathrm{HCO}_3^-}, \\ln m_{\\mathrm{CO}_3^{2-}})$. Using logarithms as variables is a common practice that aids numerical stability and naturally enforces the physical constraint of positive concentrations.\n\nThe system of equations $F_t(\\ell)=0$ is defined as:\n1.  **Carbon Mass Balance ($F_{t,1}$):** This equation ensures that the sum of the concentrations of all dissolved inorganic carbon species equals the specified total, $C_T$.\n    $$F_{t,1}(\\ell) = m_{\\mathrm{H}_2\\mathrm{CO}_3} + m_{\\mathrm{HCO}_3^-} + m_{\\mathrm{CO}_3^{2-}} - C_T = 0$$\n    Here, $m_{\\mathrm{HCO}_3^-} = e^{\\ell_1}$ and $m_{\\mathrm{CO}_3^{2-}} = e^{\\ell_2}$. The concentration of carbonic acid, $m_{\\mathrm{H}_2\\mathrm{CO}_3}$, is expressed via the law of mass action for the first dissociation of $\\mathrm{H}_2\\mathrm{CO}_3$: $m_{\\mathrm{H}_2\\mathrm{CO}_3} = (a_{\\mathrm{H}^+} a_{\\mathrm{HCO}_3^-}) / K_1$, where activities are $a_i = \\gamma_i m_i$.\n\n2.  **Second Dissociation Equilibrium ($F_{t,2}$):** This equation represents the equilibrium for the dissociation of bicarbonate to carbonate.\n    $$F_{t,2}(\\ell) = a_{\\mathrm{H}^+} a_{\\mathrm{CO}_3^{2-}} - K_2 a_{\\mathrm{HCO}_3^-} = 0$$\n\n3.  **Electroneutrality ($F_{t,3}$):** This equation enforces charge balance, stating that the sum of positive charges must equal the sum of negative charges in the solution.\n    $$F_{t,3}(\\ell) = (N_T + m_{\\mathrm{H}^+}) - (Cl_T + m_{\\mathrm{OH}^-} + m_{\\mathrm{HCO}_3^-} + 2 m_{\\mathrm{CO}_3^{2-}}) = 0$$\n    The concentration of the hydroxide ion, $m_{\\mathrm{OH}^-}$, is determined from the water autoprotolysis constant, $K_w = a_{\\mathrm{H}^+} a_{\\mathrm{OH}^-}$.\n\nA key complexity is that the activity coefficients, $\\gamma_i$, depend on the ionic strength, $I = \\frac{1}{2} \\sum_i m_i z_i^2$, which in turn depends on the concentrations of all ions, including $m_{\\mathrm{OH}^-}$. This creates an implicit relationship. This challenge is addressed by implementing a fixed-point iteration within each evaluation of the function $F_t(\\ell)$. For a given $\\ell$, this iterative procedure calculates a self-consistent set of ionic strength and activity coefficients. The homotopy parameter $t \\in [0,1]$ scales the ionic strength, $I_t = t \\cdot I$, allowing a gradual transition from the ideal solution ($\\gamma_i=1$ at $t=0$) to the full Davies model ($t=1$). The Davies equation is given by $\\log_{10} \\gamma_i = -A z_i^2\\left( \\frac{\\sqrt{I_t}}{1+\\sqrt{I_t}} - 0.3 I_t \\right)$.\n\nThe system $F_t(\\ell)=0$ is solved using a robust Newton-Raphson method. The iterative update rule is $\\ell_{k+1} = \\ell_k - \\lambda J_k^{-1} F_t(\\ell_k)$. The Jacobian matrix, $J_k$, which contains the partial derivatives of $F_t$ with respect to the components of $\\ell$, is computed numerically using a finite difference scheme. To ensure robust convergence, a backtracking line search is employed to find an appropriate step length $\\lambda \\in (0,1]$ that guarantees a sufficient decrease in the norm of the residual vector, $\\|F_t\\|$.\n\nThe homotopy continuation method orchestrates the overall solution process. It begins by solving the system for the ideal case ($t=0$) using an initial chemical guess. The solution at a given step $t_i$ is then used as the initial guess for the Newton solver at the next step, $t_{i+1} = t_i + \\Delta t$. The step size $\\Delta t$ is adapted based on the performance of the Newton solver: it is increased if convergence is rapid and decreased if convergence is slow or fails, ensuring a stable path-following from $t=0$ to $t=1$.\n\nUpon successful continuation to $t=1$, the final vector $\\ell_{final}$ is obtained. The hydrogen ion activity is calculated as $a_{\\mathrm{H}^+} = \\gamma_{\\mathrm{H}^+}(1) \\cdot e^{\\ell_{final,0}}$, from which the final pH is determined as $pH = -\\log_{10}(a_{\\mathrm{H}^+})$. This procedure is applied to each test case to generate the required results.",
            "answer": "```python\nimport numpy as np\nfrom numpy.linalg import norm, solve as linsolve\n\ndef solve():\n    \"\"\"\n    Main solver function that encapsulates the entire logic as per the problem specification.\n    \"\"\"\n\n    # --- Start of self-contained definitions ---\n\n    # Constants\n    K1 = 10**-6.3\n    K2 = 10**-10.3\n    KW = 10**-14.0\n    A_DAVIES = 0.509\n    \n    def compute_auxiliary_vars(l, t, N_T, Cl_T):\n        \"\"\"\n        Computes self-consistent ionic strength, activity coefficients, and\n        concentrations of dependent species (m_OH, m_H2CO3) for a given state (l, t).\n        \"\"\"\n        m_H = np.exp(l[0])\n        m_HCO3 = np.exp(l[1])\n        m_CO3 = np.exp(l[2])\n\n        # Fixed-point iteration for ionic strength I\n        I = 0.5 * (m_H + m_HCO3 + 4 * m_CO3 + N_T + Cl_T)\n\n        for _ in range(10): # 10 iterations typically suffice for convergence\n            I_scaled = t * I\n            \n            if I_scaled  1e-15: # Ideal solution or very low I\n                gamma_H = 1.0\n                gamma_OH = 1.0\n                gamma_HCO3 = 1.0\n                gamma_CO3 = 1.0\n            else:\n                sqrt_I_scaled = np.sqrt(I_scaled)\n                davies_term = (sqrt_I_scaled / (1.0 + sqrt_I_scaled)) - 0.3 * I_scaled\n                \n                log10_gamma_H = -A_DAVIES * (1**2) * davies_term\n                log10_gamma_CO3 = -A_DAVIES * (-2**2) * davies_term\n                \n                gamma_H = 10**log10_gamma_H\n                gamma_OH = gamma_H  # z^2 = (-1)^2 = 1^2\n                gamma_HCO3 = gamma_H # z^2 = (-1)^2 = 1^2\n                gamma_CO3 = 10**log10_gamma_CO3\n            \n            denominator = gamma_H * m_H * gamma_OH\n            m_OH = KW / denominator if denominator  1e-30 else 0.0\n\n            I = 0.5 * (m_H + m_HCO3 + 4 * m_CO3 + m_OH + N_T + Cl_T)\n\n        gammas = {'H': gamma_H, 'OH': gamma_OH, 'HCO3': gamma_HCO3, 'CO3': gamma_CO3}\n        \n        a_H = gammas['H'] * m_H\n        a_HCO3 = gammas['HCO3'] * m_HCO3\n        m_H2CO3 = (a_H * a_HCO3) / K1\n\n        return {'gammas': gammas, 'm_H2CO3': m_H2CO3, 'm_OH': m_OH}\n\n    def system_function(l, t, params):\n        \"\"\"\n        Computes the residual vector F(l, t) for the system of non-linear equations.\n        \"\"\"\n        C_T, N_T, Cl_T = params['C_T'], params['N_T'], params['Cl_T']\n        \n        aux = compute_auxiliary_vars(l, t, N_T, Cl_T)\n        gammas, m_H2CO3, m_OH = aux['gammas'], aux['m_H2CO3'], aux['m_OH']\n\n        m_H = np.exp(l[0])\n        m_HCO3 = np.exp(l[1])\n        m_CO3 = np.exp(l[2])\n\n        F1 = m_H2CO3 + m_HCO3 + m_CO3 - C_T\n        \n        a_H = gammas['H'] * m_H\n        a_HCO3 = gammas['HCO3'] * m_HCO3\n        a_CO3 = gammas['CO3'] * m_CO3\n        F2 = a_H * a_CO3 - K2 * a_HCO3\n        \n        F3 = (N_T + m_H) - (Cl_T + m_OH + m_HCO3 + 2 * m_CO3)\n        \n        return np.array([F1, F2, F3])\n\n    def numerical_jacobian(F_func, l, t, params):\n        \"\"\"\n        Computes the Jacobian matrix of F_func w.r.t. l using finite differences.\n        \"\"\"\n        f0 = F_func(l, t, params)\n        n = len(l)\n        J = np.zeros((n, n))\n        h = 1e-8\n        \n        for j in range(n):\n            l_plus_h = l.copy()\n            l_plus_h[j] += h\n            f_plus_h = F_func(l_plus_h, t, params)\n            J[:, j] = (f_plus_h - f0) / h\n            \n        return J\n\n    def newton_solver(F_func, l_guess, t, params, tol=1e-10, max_iter=25):\n        \"\"\"\n        Solves F(l) = 0 using Newton's method with a backtracking line search.\n        \"\"\"\n        l = l_guess.copy()\n        alpha = 1e-4\n        beta = 0.5\n        \n        for i in range(max_iter):\n            F_val = F_func(l, t, params)\n            norm_F = norm(F_val)\n\n            if norm_F  tol:\n                return l, True, i + 1\n\n            J_val = numerical_jacobian(F_func, l, t, params)\n            \n            try:\n                delta_l = linsolve(J_val, -F_val)\n            except np.linalg.LinAlgError:\n                return l, False, i + 1\n\n            lambda_step = 1.0\n            for _ in range(10): # Max 10 backtracking steps\n                l_new = l + lambda_step * delta_l\n                F_new_norm = norm(F_func(l_new, t, params))\n                if F_new_norm  (1 - alpha * lambda_step) * norm_F:\n                    break\n                lambda_step *= beta\n            else: # No suitable step found\n                return l, False, i + 1\n            \n            l = l_new\n\n        return l, norm(F_func(l, t, params))  tol, max_iter\n\n    def solve_case(params):\n        \"\"\"\n        Performs homotopy continuation to solve the geochemical system for a given case.\n        \"\"\"\n        m_H_guess = 1e-7\n        m_HCO3_guess = params['C_T']\n        m_CO3_guess = K2 * m_HCO3_guess / m_H_guess if m_H_guess  0 else 1e-10\n        l_guess = np.log(np.array([m_H_guess, m_HCO3_guess, m_CO3_guess]))\n\n        t = 0.0\n        dt, min_dt, max_dt = 0.05, 1e-5, 0.2\n        \n        l_current, converged, _ = newton_solver(system_function, l_guess, t, params)\n        if not converged:\n            m_H_guess = 1e-4\n            m_HCO3_guess = K1 * params['C_T'] / m_H_guess if m_H_guess  0 else 1e-5\n            m_CO3_guess = K2 * m_HCO3_guess / m_H_guess if m_H_guess  0 else 1e-10\n            l_guess = np.log(np.array([m_H_guess, m_HCO3_guess, m_CO3_guess]))\n            l_current, converged, _ = newton_solver(system_function, l_guess, t, params)\n            if not converged:\n                raise RuntimeError(\"Initial solver failed for t=0\")\n\n        while t  1.0:\n            t_next = min(1.0, t + dt)\n            l_next, converged, iters = newton_solver(system_function, l_current, t_next, params)\n\n            if converged:\n                l_current, t = l_next, t_next\n                if iters  4: dt = min(dt * 1.5, max_dt)\n            else:\n                dt *= 0.5\n                if dt  min_dt: raise RuntimeError(f\"Homotopy failed at t={t}\")\n        \n        l_final = l_current\n        m_H_final = np.exp(l_final[0])\n        gamma_H_final = compute_auxiliary_vars(l_final, 1.0, params['N_T'], params['Cl_T'])['gammas']['H']\n        a_H_final = gamma_H_final * m_H_final\n        return -np.log10(a_H_final)\n\n    # --- End of self-contained definitions ---\n\n    test_cases = [\n        {'C_T': 2.0e-3, 'N_T': 1.0e-2, 'Cl_T': 1.0e-2}, # Case A\n        {'C_T': 2.0e-3, 'N_T': 0.5, 'Cl_T': 0.5},       # Case B\n        {'C_T': 1.0e-5, 'N_T': 1.0e-3, 'Cl_T': 1.0e-3}, # Case C\n    ]\n\n    results = []\n    for params in test_cases:\n        pH_final = solve_case(params)\n        results.append(f\"{pH_final:.4f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}