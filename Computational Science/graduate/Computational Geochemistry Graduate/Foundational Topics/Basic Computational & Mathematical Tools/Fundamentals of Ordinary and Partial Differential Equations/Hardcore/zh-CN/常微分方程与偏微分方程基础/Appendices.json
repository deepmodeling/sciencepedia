{
    "hands_on_practices": [
        {
            "introduction": "扩散方程是模拟多孔介质中物质传输的基石。本练习将介绍冯·诺依曼稳定性分析，这是一种强大的数学工具，用于判断数值格式是否会产生稳定、不发散的解。掌握这种分析方法  对于理解显式时间步进法的稳定性限制至关重要，这是计算建模中的一个基本概念。",
            "id": "4079415",
            "problem": "在等温和孔隙度恒定的条件下，对长度为 $L$ 的均匀、饱和水的沉积物岩心中保守性水相示踪剂的一维扩散进行建模。设 $C(x,t)$ 表示溶解示踪剂的浓度（单位孔隙水体积的摩尔数）。在没有平流和化学反应的假设下，控制方程由质量守恒和菲克第一扩散定律得出：守恒陈述为 $\\partial C/\\partial t + \\partial J/\\partial x = 0$，通量为 $J = -D\\,\\partial C/\\partial x$，其中 $D$ 是常数有效扩散系数。将两者结合得到扩散方程 $\\partial C/\\partial t = D\\,\\partial^{2} C/\\partial x^{2}$。\n\n考虑一个空间步长为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格，以及以下通过时间上采用前向欧拉法和空间上采用中心二阶有限差分得到的显式时间推进格式：\n$$\nC_{j}^{n+1} \\;=\\; C_{j}^{n} \\;+\\; \\alpha \\,\\big(C_{j+1}^{n} \\;-\\; 2\\,C_{j}^{n} \\;+\\; C_{j-1}^{n}\\big),\n$$\n其中 $j$ 是空间索引，$n$ 是时间索引，$\\alpha \\equiv D\\,\\Delta t/\\Delta x^{2}$ 是无量纲扩散数（也称为傅里叶数）。\n\n假设采用周期性边界条件，使得傅里叶模能够张成离散解空间，并从上述的控制守恒定律和本构关系以及给定的离散化格式出发，进行冯·诺依曼稳定性分析。施加充分必要条件，即对于所有可分辨的波数，放大因子的模不应超过1。确定允许的最大值 $\\alpha_{\\max}$，使得该格式在所有 $0 \\leq \\alpha \\leq \\alpha_{\\max}$ 的情况下都是稳定的。请以一个无单位的精确数字形式提供答案。",
            "solution": "用户提供了一个有效的问题陈述。所给出的控制偏微分方程、其有限差分格式以及分析方法都是标准的、适定的。该问题具有科学依据，陈述规范，并包含了推导唯一解所需的所有信息。\n\n任务是针对给定的一维扩散方程的显式有限差分格式，进行冯·诺依曼稳定性分析，以求出无量纲扩散数 $\\alpha$ 的最大允许值。\n\n有限差分格式由下式给出：\n$$\nC_{j}^{n+1} \\;=\\; C_{j}^{n} \\;+\\; \\alpha \\,\\big(C_{j+1}^{n} \\;-\\; 2\\,C_{j}^{n} \\;+\\; C_{j-1}^{n}\\big)\n$$\n其中 $C_j^n$ 表示在空间索引 $j$ 和时间索引 $n$ 处的浓度，$\\alpha = \\frac{D \\Delta t}{\\Delta x^2}$。\n\n在冯·诺依曼稳定性分析中，我们考察解的单个傅里叶模随时间演化的放大情况。一个离散傅里叶模可以表示为：\n$$\nC_j^n = \\hat{C}^n(k) \\exp(i k x_j)\n$$\n其中 $x_j = j \\Delta x$ 是空间坐标，$k$ 是波数，$i = \\sqrt{-1}$，$\\hat{C}^n(k)$ 是在时间层 $n$ 的模的振幅。\n\n由于有限差分方程的线性特性，在下一个时间步 $n+1$，此单个模式的解将具有以下形式：\n$$\nC_j^{n+1} = \\hat{C}^{n+1}(k) \\exp(i k x_j)\n$$\n放大因子 $\\mathcal{G}(k)$ 定义为连续时间步上振幅的比值：\n$$\n\\mathcal{G}(k) = \\frac{\\hat{C}^{n+1}(k)}{\\hat{C}^n(k)}\n$$\n因此，我们可以写成 $C_j^{n+1} = \\mathcal{G}(k) C_j^n$。该格式稳定的充分必要条件是，对于所有可能的波数，放大因子的模不大于1，即 $|\\mathcal{G}(k)| \\le 1$。\n\n我们将傅里叶模的表示代入有限差分格式。\n对于项 $C_j^n$，我们有 $\\hat{C}^n \\exp(i k j \\Delta x)$。\n对于 $C_{j+1}^n$，我们有 $\\hat{C}^n \\exp(i k (j+1) \\Delta x) = \\hat{C}^n \\exp(i k j \\Delta x) \\exp(i k \\Delta x)$。\n对于 $C_{j-1}^n$，我们有 $\\hat{C}^n \\exp(i k (j-1) \\Delta x) = \\hat{C}^n \\exp(i k j \\Delta x) \\exp(-i k \\Delta x)$。\n对于 $C_j^{n+1}$，我们有 $\\mathcal{G} \\hat{C}^n \\exp(i k j \\Delta x)$。\n\n将这些代入格式中得到：\n$$\n\\mathcal{G} \\hat{C}^n \\exp(i k j \\Delta x) = \\hat{C}^n \\exp(i k j \\Delta x) + \\alpha \\left[ \\hat{C}^n \\exp(i k j \\Delta x) \\exp(i k \\Delta x) - 2\\hat{C}^n \\exp(i k j \\Delta x) + \\hat{C}^n \\exp(i k j \\Delta x) \\exp(-i k \\Delta x) \\right]\n$$\n我们可以用公共非零项 $\\hat{C}^n \\exp(i k j \\Delta x)$ 除以方程两边，以求解 $\\mathcal{G}$：\n$$\n\\mathcal{G} = 1 + \\alpha \\left( \\exp(i k \\Delta x) - 2 + \\exp(-i k \\Delta x) \\right)\n$$\n使用欧拉公式 $\\exp(i\\theta) + \\exp(-i\\theta) = 2\\cos(\\theta)$，其中 $\\theta = k \\Delta x$，我们简化括号中的表达式：\n$$\n\\mathcal{G} = 1 + \\alpha \\left( 2\\cos(k \\Delta x) - 2 \\right) = 1 + 2\\alpha \\left( \\cos(k \\Delta x) - 1 \\right)\n$$\n接着，我们使用三角恒等式 $\\cos(\\theta) - 1 = -2\\sin^2(\\theta/2)$：\n$$\n\\mathcal{G} = 1 + 2\\alpha \\left( -2\\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\right)\n$$\n$$\n\\mathcal{G} = 1 - 4\\alpha \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\n放大因子 $\\mathcal{G}$ 是一个实数。稳定性条件是 $|\\mathcal{G}| \\le 1$，这等价于两个不等式 $-1 \\le \\mathcal{G} \\le 1$。\n\n让我们分析每个不等式：\n1. $\\mathcal{G} \\le 1$：\n   $$1 - 4\\alpha \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le 1$$\n   $$-4\\alpha \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le 0$$\n   由于 $\\alpha = D \\Delta t / \\Delta x^2$ 是非负的（因为 $D \\ge 0$, $\\Delta t > 0$, 且 $\\Delta x^{2} > 0$）并且 $\\sin^2(\\cdot)$ 总是非负的，所以乘积 $-4\\alpha \\sin^2(\\cdot)$ 总是小于或等于零。因此，这个不等式总是成立的，对 $\\alpha$ 没有施加任何限制。\n\n2. $\\mathcal{G} \\ge -1$：\n   $$1 - 4\\alpha \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\ge -1$$\n   $$2 \\ge 4\\alpha \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)$$\n   $$\\alpha \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le \\frac{2}{4}$$\n   $$\\alpha \\le \\frac{1}{2\\sin^2\\left(\\frac{k \\Delta x}{2}\\right)}$$\n这个条件必须对网格上能表示的所有波数 $k$ 都成立。为确保这一点，我们必须考虑“最坏情况”，即对 $\\alpha$ 施加最严格（即最小）上界的情况。这发生在分母 $2\\sin^2(k \\Delta x / 2)$ 达到其最大值时。\n\n函数 $\\sin^2(\\theta)$ 的最大值是 $1$。参数是 $\\theta = k \\Delta x / 2$。项 $\\sin^2(k \\Delta x / 2)$ 在网格上可分辨的最高频率（振荡最剧烈）模式下达到其最大值 $1$，该模式对应波长为 $2 \\Delta x$。这就是奈奎斯特频率，此时波数为 $k = \\pi/\\Delta x$，使得参数 $k \\Delta x / 2 = \\pi/2$。\n\n对于这个“最坏情况”的模式，我们有：\n$$\n\\sin^2\\left(\\frac{\\pi \\Delta x}{2 \\Delta x}\\right) = \\sin^2\\left(\\frac{\\pi}{2}\\right) = 1^2 = 1\n$$\n将这个最大值代入稳定性不等式，得到对 $\\alpha$ 最严格的条件：\n$$\n\\alpha \\le \\frac{1}{2(1)} \\implies \\alpha \\le \\frac{1}{2}\n$$\n因此，为使格式对所有可分辨的模式都稳定，无量纲扩散数 $\\alpha$ 必须不大于 $1/2$。允许的最大值 $\\alpha_{\\max}$ 就是这个上界。\n$$\n\\alpha_{\\max} = \\frac{1}{2}\n$$",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "扩散使溶质散开，而平流则使其随流体一起迁移，这一过程由平流方程描述。本动手练习  将一种简单的中心差分格式与更稳健的迎风格式进行对比，揭示了前者为何会导致非物理振荡。通过分析和实践，您将学习到迎风原理及其在创建稳定且符合物理现实的输运模型中的关键作用。",
            "id": "4079372",
            "problem": "考虑一种无反应、无衰减的溶解示踪剂，在具有恒定平流速度的饱和、均质多孔介质中的一维守恒输运。溶解浓度的质量守恒控制方程为线性平流（或纯输运）方程\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\n其中 $u(x,t)$ 是无量纲浓度，$a$ 是一个单位为长度/时间的恒定速度。\n\n您的任务如下。\n\n1) 从局部守恒的概念出发，使用空间步长为 $\\Delta x$、时间增量为 $\\Delta t$ 的均匀网格，构建一个对空间导数使用中心差分、对时间导数使用向前差分的有限差分格式。对该格式进行 Fourier 模态 (von Neumann) 稳定性分析，以确定作为无量纲波数和 Courant 数 $r = |a| \\Delta t / \\Delta x$ 函数的放大因子。利用此分析从基本原理出发，解释为何用于平流的中心差分会在数值解中产生振荡。\n\n2) 从相同的守恒陈述和网格出发，基于选择与上游状态一致的数值通量，构建一个一阶迎风离散格式。推导 $a > 0$ 和 $a  0$ 两种情况下的显式更新公式。通过证明更新可以写成相邻值的凸组合，并找出对 Courant 数 $r$ 的相应条件，来证明其单调性的一个充分条件。\n\n3) 在长度为 $L = 1$ 的周期性区域上，使用 $N$ 个间距为 $\\Delta x = L/N$ 的均匀分布点，实现这两种格式。使用分段常数初始条件\n$$\nu(x,0) =\n\\begin{cases}\n1,  x \\in [0.2, 0.4),\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n在 $[0,1)$ 上作周期性解释，使得区间 $[0.2,0.4)$ 像通常一样在区域内回绕。对于下面的每个测试用例，计算单个显式时间步长 $\\Delta t = r \\Delta x / |a|$。施加周期性边界条件。\n\n对于每个测试用例，在每个格式计算一个时间步后，计算以下三个诊断量：\n- 一个布尔值 $B_{\\mathrm{FTCS}}$，如果中心格式的任何节点值位于闭区间 $[0,1]$ 之外，则为真 (true)，否则为假 (false)。\n- 一个布尔值 $B_{\\mathrm{UP}}$，如果迎风格式的任何节点值位于闭区间 $[0,1]$ 之外，则为真 (true)，否则为假 (false)。\n- 一个浮点数 $\\rho_{\\mathrm{TV}}$，定义为一个迎风步后的全变分与初始全变分之比，其中周期性网格函数 $v_i$ 的全变分为\n$$\nTV(v) = \\sum_{i=0}^{N-1} \\left| v_{i+1} - v_{i} \\right|,\n$$\n使用周期性索引 $v_{N} \\equiv v_{0}$。报告 $\\rho_{\\mathrm{TV}}$，四舍五入到 $6$ 位小数。\n\n测试套件（所有用例均使用 $L = 1$ 和上述初始条件）：\n- 用例 A：$N = 200$, $a = +1$, $r = 0.5$。\n- 用例 B：$N = 200$, $a = +1$, $r = 1.0$。\n- 用例 C：$N = 200$, $a = +1$, $r = 1.2$。\n- 用例 D：$N = 200$, $a = -1$, $r = 0.8$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由四个内部列表组成的逗号分隔列表，每个测试用例一个，顺序与上面列出的顺序相同。每个内部列表必须具有 $[B_{\\mathrm{FTCS}}, B_{\\mathrm{UP}}, \\rho_{\\mathrm{TV}}]$ 的形式，其中布尔值写为 $True$ 或 $False$，$\\rho_{\\mathrm{TV}}$ 精确打印到小数点后 $6$ 位。例如，\n$$\n\\left[\\,[True,False,0.875000],[\\dots],\\dots\\,\\right].\n$$",
            "solution": "该问题提出了一系列与一维线性平流方程数值解相关的任务，该方程是计算地球化学中用于守恒输运的一个基础模型。这些任务是推导和分析两种常见的有限差分格式——时间向前、空间中心 (FTCS) 格式和一阶迎风格式——然后实现它们，为一组给定的测试用例计算特定的诊断量。每个任务将按顺序进行处理。\n\n### 1. FTCS 格式：推导与稳定性分析\n\n控制偏微分方程 (PDE) 是线性平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\n其中 $u(x,t)$ 是浓度，$a$ 是恒定的平流速度。\n\n为了构建所要求的有限差分格式，我们用空间步长为 $\\Delta x$、时间增量为 $\\Delta t$ 的均匀网格对区域进行离散化。设 $u_i^n \\approx u(i\\Delta x, n\\Delta t)$。时间导数 $\\frac{\\partial u}{\\partial t}$ 使用向前差分近似：\n$$\n\\left. \\frac{\\partial u}{\\partial t} \\right|_{i,n} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\n空间导数 $\\frac{\\partial u}{\\partial x}$ 使用中心差分近似：\n$$\n\\left. \\frac{\\partial u}{\\partial x} \\right|_{i,n} \\approx \\frac{u_{i+1}^n - u_{i-1}^n}{2\\Delta x}\n$$\n将这些近似代入 PDE 得到：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_{i+1}^n - u_{i-1}^n}{2\\Delta x} = 0\n$$\n求解新时间步的值 $u_i^{n+1}$，得到 FTCS 格式的显式更新公式：\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{2 \\Delta x} (u_{i+1}^n - u_{i-1}^n)\n$$\n我们定义一个修正的 Courant 数 $r' = \\frac{a \\Delta t}{\\Delta x}$。问题将 Courant 数定义为 $r = \\frac{|a| \\Delta t}{\\Delta x}$，所以 $r' = \\text{sign}(a) r$。该格式为：\n$$\nu_i^{n+1} = u_i^n - \\frac{r'}{2} (u_{i+1}^n - u_{i-1}^n)\n$$\n为了进行 von Neumann 稳定性分析，我们考察形如 $u_i^n = G^n e^{jki\\Delta x}$ 的单个 Fourier 模态的行为，其中 $G$ 是复放大因子，$k$ 是波数，$j=\\sqrt{-1}$。将其代入差分方程：\n$$\nG^{n+1} e^{jki\\Delta x} = G^n e^{jki\\Delta x} - \\frac{r'}{2} \\left( G^n e^{jk(i+1)\\Delta x} - G^n e^{jk(i-1)\\Delta x} \\right)\n$$\n两边同除以 $G^n e^{jki\\Delta x}$ 可分离出放大因子 $G$：\n$$\nG = 1 - \\frac{r'}{2} \\left( e^{jk\\Delta x} - e^{-jk\\Delta x} \\right)\n$$\n使用欧拉恒等式 $e^{j\\theta} - e^{-j\\theta} = 2j \\sin(\\theta)$，其中 $\\theta = k\\Delta x$，我们得到：\n$$\nG = 1 - j r' \\sin(k\\Delta x)\n$$\n为使格式稳定，放大因子的模必须对所有波数都满足 $|G| \\leq 1$。$G$ 的模的平方为：\n$$\n|G|^2 = (\\text{Re}(G))^2 + (\\text{Im}(G))^2 = 1^2 + (-r' \\sin(k\\Delta x))^2 = 1 + (r' \\sin(k\\Delta x))^2\n$$\n代入 $r' = \\text{sign}(a) r$，我们有 $(r')^2 = r^2$。因此：\n$$\n|G|^2 = 1 + r^2 \\sin^2(k\\Delta x)\n$$\n对于任何非零 Courant 数 $r>0$ 和任何使得 $\\sin(k\\Delta x) \\neq 0$ 的波数 $k$，项 $r^2 \\sin^2(k\\Delta x)$ 严格为正。因此， $|G|^2 > 1$，这意味着 $|G| > 1$。该格式在每个时间步都会放大某些 Fourier 模态，使其对于线性平流方程是**无条件不稳定**的。\n\n这种不稳定性表现为虚假振荡。关于该格式为何会产生振荡（即初始数据中不存在的新极值）的一个更直接的解释是，其更新公式不是相邻值的凸组合。重写该格式：\n$$\nu_i^{n+1} = \\left(\\frac{r'}{2}\\right) u_{i-1}^n + (1) u_i^n + \\left(-\\frac{r'}{2}\\right) u_{i+1}^n\n$$\n要使其成为凸组合，所有系数都必须为非负。然而，如果 $r' > 0$（即 $a>0$），$u_{i+1}^n$ 的系数为负。如果 $r'  0$（即 $a0$），$u_{i-1}^n$ 的系数为负。由于模板系数之一始终为负，该格式不满足离散极值原理。因此，值 $u_i^{n+1}$ 可能超出范围 $[\\min(u_{i-1}^n, u_i^n, u_{i+1}^n), \\max(u_{i-1}^n, u_i^n, u_{i+1}^n)]$，导致产生非物理振荡（下冲和过冲）。\n\n### 2. 一阶迎风格式：推导与单调性\n\n迎风格式是从有限体积的观点推导出来的。将方程的守恒形式 $\\frac{\\partial u}{\\partial t} + \\frac{\\partial F}{\\partial x} = 0$（其中通量为 $F=au$）在一个单元 $[x_{i-1/2}, x_{i+1/2}] \\times [t_n, t_{n+1}]$ 上积分，得到：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2} - F_{i-1/2})\n$$\n迎风原理规定，单元交界面上的通量（例如 $F_{i+1/2}$）由“迎风”单元的状态决定，即信息流出的那个单元。\n$$\nF_{i+1/2} = \\begin{cases} a u_i^n,  \\text{if } a > 0 \\\\ a u_{i+1}^n,  \\text{if } a  0 \\end{cases}\n$$\n这导致了两种取决于 $a$ 符号的不同的更新公式。\n\n**情况 1：$a > 0$** (流向右侧)\n通量为 $F_{i+1/2} = a u_i^n$ 和 $F_{i-1/2} = a u_{i-1}^n$。代入有限体积公式：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (a u_i^n - a u_{i-1}^n)\n$$\n使用 Courant 数 $r = \\frac{a \\Delta t}{\\Delta x}$（因为 $a>0$，所以 $|a|=a$）：\n$$\nu_i^{n+1} = u_i^n - r(u_i^n - u_{i-1}^n) = (1-r)u_i^n + r u_{i-1}^n\n$$\n\n**情况 2：$a  0$** (流向左侧)\n通量为 $F_{i+1/2} = a u_{i+1}^n$ 和 $F_{i-1/2} = a u_i^n$。代入得到：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (a u_{i+1}^n - a u_i^n)\n$$\n使用 Courant 数 $r = \\frac{|a| \\Delta t}{\\Delta x} = \\frac{-a \\Delta t}{\\Delta x}$，这意味着 $\\frac{a \\Delta t}{\\Delta x} = -r$：\n$$\nu_i^{n+1} = u_i^n - (-r)(u_{i+1}^n - u_i^n) = (1-r)u_i^n + r u_{i+1}^n\n$$\n\n为了证明单调性的一个充分条件，我们证明更新是相邻值的凸组合。\n在两种情况（$a>0$ 和 $a0$）下，更新公式都具有形式 $u_i^{n+1} = (1-r)u_i^n + r u_k^n$，其中 $u_k^n$ 是一个相邻单元的值（$u_{i-1}^n$ 或 $u_{i+1}^n$）。\n要使其成为凸组合，必须满足两个条件：\n1. 系数之和必须为 1：$(1-r) + r = 1$。这总是成立的。\n2. 所有系数必须为非负。根据定义，$r = \\frac{|a| \\Delta t}{\\Delta x} \\ge 0$。第二个条件是 $1-r \\ge 0$，这意味着 $r \\le 1$。\n\n因此，一阶迎风格式保持单调的一个充分条件是 $0 \\le r \\le 1$。这就是该格式的 Courant-Friedrichs-Lewy (CFL) 条件。如果满足该条件，$u_i^{n+1}$ 是前一时间步两个值的加权平均，这确保了其值介于这两个值之间，从而防止新极值的形成。\n\n### 3. 数值实现\n\n该实现涉及将周期性区域 $[0,1)$ 离散化为 $N$ 个网格点 $x_i = i(L/N)$，其中 $i=0, \\dots, N-1$。分段常数初始条件被映射到该网格上。对于每个测试用例，使用上面推导的 FTCS 和迎风格式计算大小为 $\\Delta t = r \\Delta x / |a|$ 的单个时间步。周期性边界条件通过使用数组滚动操作来处理，这种操作很自然地实现了所需的回绕索引。在该时间步之后，计算三个诊断量：\n- $B_{\\mathrm{FTCS}}$：一个布尔值，指示 FTCS 解中的任何值是否位于初始范围 $[0,1]$ 之外。\n- $B_{\\mathrm{UP}}$：一个布尔值，指示迎风解中的任何值是否位于初始范围 $[0,1]$ 之外。对于 $r \\le 1$，由于单调性，预期该值为假。对于 $r > 1$，它可能为真。\n- $\\rho_{\\mathrm{TV}}$：迎风解的全变分与初始全变分之比。周期性网格函数 $v_i$ 的全变分为 $TV(v) = \\sum_{i=0}^{N-1} |v_{i+1} - v_i|$，其中 $v_N \\equiv v_0$。对于给定的方波初始条件，初始全变分为 $TV(u(x,0)) = |1-0| + |0-1| = 2$。\n最终答案中的代码将对所有指定的测试用例执行这些计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection problem using FTCS and Upwind schemes\n    for a suite of test cases and computes specified diagnostics.\n    \"\"\"\n    test_cases = [\n        # (N, a, r)\n        (200, 1.0, 0.5),  # Case A\n        (200, 1.0, 1.0),  # Case B\n        (200, 1.0, 1.2),  # Case C\n        (200, -1.0, 0.8), # Case D\n    ]\n\n    all_results = []\n\n    for N, a, r in test_cases:\n        # Domain and Grid Setup\n        L = 1.0\n        dx = L / N\n        dt = r * dx / abs(a)\n        x = np.linspace(0, L, N, endpoint=False)\n\n        # Initial Condition: Piecewise-constant (boxcar) function\n        u0 = np.zeros(N)\n        u0[(x >= 0.2)  (x  0.4)] = 1.0\n\n        # --- Scheme Implementations for one time step ---\n\n        # 1. FTCS (Forward-Time, Centered-Space) Scheme\n        # u_i^{n+1} = u_i^n - (a*dt / (2*dx)) * (u_{i+1}^n - u_{i-1}^n)\n        u_prev = np.roll(u0, 1)   # u_{i-1}\n        u_next = np.roll(u0, -1)  # u_{i+1}\n        u_ftcs = u0 - (a * dt / (2.0 * dx)) * (u_next - u_prev)\n        \n        # 2. First-Order Upwind Scheme\n        u_upwind = np.zeros(N)\n        if a > 0:\n            # u_i^{n+1} = u_i^n - r * (u_i^n - u_{i-1}^n)\n            u_prev = np.roll(u0, 1)\n            u_upwind = u0 - r * (u0 - u_prev)\n        else: # a  0\n            # u_i^{n+1} = u_i^n + r * (u_{i+1}^n - u_i^n)\n            u_next = np.roll(u0, -1)\n            u_upwind = u0 + r * (u_next - u0)\n\n        # --- Diagnostic Calculations ---\n\n        # B_FTCS: Boolean check for oscillations in FTCS solution\n        # The problem asks if any value lies outside [0,1].\n        # Floating point precision requires a small tolerance for comparison.\n        # However, the problem text implies a strict check, so we avoid tolerance.\n        B_ftcs = np.any((u_ftcs  0.0) | (u_ftcs > 1.0))\n\n        # B_UP: Boolean check for oscillations in Upwind solution\n        B_up = np.any((u_upwind  0.0) | (u_upwind > 1.0))\n\n        # rho_TV: Ratio of Total Variation for the upwind scheme\n        def calculate_tv(v):\n            return np.sum(np.abs(np.roll(v, -1) - v))\n\n        tv_initial = calculate_tv(u0)\n        tv_upwind = calculate_tv(u_upwind)\n        \n        rho_tv = tv_upwind / tv_initial if tv_initial > 0 else 0.0\n\n        # Assemble the results for the current case\n        case_result_str = f\"[{str(B_ftcs)},{str(B_up)},{rho_tv:.6f}]\"\n        all_results.append(case_result_str)\n\n    # Format the final output string as a list of lists representation\n    final_output = f\"[{','.join(all_results)}]\"\n    print(final_output)\n\nsolve()\n\n```"
        },
        {
            "introduction": "平流-扩散-反应 (ADR) 方程整合了控制溶质归宿的关键过程。但是，我们如何确定我们编写的复杂数值求解器是正确的呢？本练习介绍了“人造解法”(Method of Manufactured Solutions, MMS)，这是代码验证的黄金标准 。通过构建一个已知精确解的问题，您将学习如何系统地衡量求解器的误差，并确认其达到了预期的理论收敛阶。",
            "id": "4079440",
            "problem": "考虑在一饱和地球化学柱中的一维溶质运移，其由平流-扩散-反应 (Advection–Diffusion–Reaction, ADR) 偏微分方程 (Partial Differential Equation, PDE) 建模。令 $u(x,t)$ 表示水相浓度，单位为 $\\mathrm{mol}\\,\\mathrm{m}^{-3}$，空间坐标 $x \\in [0,L]$ 单位为 $\\mathrm{m}$，时间 $t \\in [0,T]$ 单位为 $\\mathrm{s}$。ADR PDE 为\n$$\n\\frac{\\partial u}{\\partial t} + a\\,\\frac{\\partial u}{\\partial x} \\;=\\; D\\,\\frac{\\partial^2 u}{\\partial x^2} \\;-\\; k\\,u \\;+\\; s(x,t),\n$$\n其中 $a$ 是平流速度，单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$；$D$ 是扩散（水动力弥散）系数，单位为 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$；$k$ 是一阶反应速率常数，单位为 $\\mathrm{s}^{-1}$；$s(x,t)$ 是源项，单位为 $\\mathrm{mol}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$，表示外部输入。\n\n使用人造解法 (method of manufactured solutions)，定义精确浓度场\n$$\nu_{\\mathrm{m}}(x,t) \\;=\\; \\sin\\!\\big(2\\pi x/L\\big)\\,\\mathrm{e}^{-t} \\;+\\; \\tfrac{1}{2}\\,x\\,(L-x),\n$$\n其中域长度 $L = 1$ $\\mathrm{m}$，最终时间 $T = 0.1$ $\\mathrm{s}$。施加与人造解匹配的狄利克雷 (Dirichlet) 边界条件，使得对于所有 $t \\in [0,T]$ 都有 $u(0,t) = u_{\\mathrm{m}}(0,t)$ 和 $u(L,t) = u_{\\mathrm{m}}(L,t)$，以及初始条件 $u(x,0) = u_{\\mathrm{m}}(x,0)$ 对所有 $x \\in [0,L]$ 成立。从上述 ADR 定义出发，推导源项 $s(x,t)$，使 $u_{\\mathrm{m}}(x,t)$ 成为对于任意常数 $a$、$D$ 和 $k$ 的连续 ADR PDE 的精确解。\n\n通过具有 $N$ 个内部点（因此包括边界在内共有 $N+2$ 个节点）的均匀网格来离散化空间域，间距为 $h = L/(N+1)$。对一阶导数 $\\partial u/\\partial x$ 使用迎风有限差分，对二阶导数 $\\partial^2 u/\\partial x^2$ 使用二阶中心差分，对 $\\partial u/\\partial t$ 使用前向欧拉时间积分器。具体来说，对于给定的 $a$ 的符号，使用相应的迎风单边差分。令时间步长 $\\Delta t$ 满足显式稳定性条件，取\n$$\n\\Delta t \\;=\\; 0.4 \\times \\min\\!\\left(\\frac{h}{|a|}, \\; \\frac{h^2}{2D}, \\; \\frac{1}{k}\\right),\n$$\n约定分母为零的项在最小值计算中视为 $+\\infty$。使用前向欧拉方法从 $t=0$ 积分到 $t=T$，在当前时间层级上计算人造源项 $s(x,t)$，并在每个时间步强制施加来自 $u_{\\mathrm{m}}(x,t)$ 的狄利克雷边界值。达到 $t=T$ 后，计算相对离散 $L^2$ 误差\n$$\nE_h \\;=\\; \\frac{\\left(\\,h \\sum_{i=0}^{N+1} \\big(u_i(T) - u_{\\mathrm{m}}(x_i,T)\\big)^2\\,\\right)^{1/2}}{\\left(\\,h \\sum_{i=0}^{N+1} \\big(u_{\\mathrm{m}}(x_i,T)\\big)^2\\,\\right)^{1/2}},\n$$\n该误差为无量纲。使用网格加密 $N \\in \\{40, 80, 160\\}$，估计观测到的收敛阶\n$$\np \\;=\\; \\frac{\\ln\\!\\big(E_{h_2}/E_{h_3}\\big)}{\\ln\\!\\big(h_2/h_3\\big)},\n$$\n其中 $h_j = L/(N_j+1)$ 且 $N_2=80$, $N_3=160$。\n\n测试集：\n- 集合 $\\mathrm{A}$ (扩散主导): $a = 0.05$ $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $D = 1.0\\times 10^{-3}$ $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$, $k = 0.1$ $\\mathrm{s}^{-1}$。\n- 集合 $\\mathrm{B}$ (平流主导，正速度): $a = 1.0$ $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $D = 1.0\\times 10^{-4}$ $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$, $k = 0.1$ $\\mathrm{s}^{-1}$。\n- 集合 $\\mathrm{C}$ (平流主导，负速度): $a = -1.0$ $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $D = 1.0\\times 10^{-4}$ $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$, $k = 0.1$ $\\mathrm{s}^{-1}$。\n- 集合 $\\mathrm{D}$ (反应主导): $a = 0.01$ $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $D = 1.0\\times 10^{-4}$ $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$, $k = 5.0$ $\\mathrm{s}^{-1}$。\n\n您的程序必须：\n- 推导并实现人造源项 $s(x,t)$，该源项来自 ADR PDE 和 $u_{\\mathrm{m}}(x,t)$。\n- 对于每个参数集 $\\mathrm{A}$、$\\mathrm{B}$、$\\mathrm{C}$ 和 $\\mathrm{D}$，计算 $N \\in \\{40,80,160\\}$ 时的相对离散 $L^2$ 误差 $E_{h}$，然后使用上述公式计算 $p$。\n- 生成单行输出，其中包含四个集合的观测收敛阶，形式为方括号内以逗号分隔的列表，顺序为 $\\mathrm{A}$、$\\mathrm{B}$、$\\mathrm{C}$、$\\mathrm{D}$，每个浮点数四舍五入到三位小数，例如 $[p_A,p_B,p_C,p_D]$。\n\n所有输出均为无量纲，且必须以浮点数形式报告。不涉及角度。不涉及百分比。",
            "solution": "用户提供的问题是一个适定 (well-posed) 的计算科学练习，具体是使用人造解法进行代码验证的偏微分方程（PDE）数值求解。该问题具有科学依据、内容自洽，并且所有参数和方法都已明确定义。将通过首先推导必要的源项，然后基于指定的有限差分格式开发数值模型，最后使用该模型计算几种物理情景下的经验收敛阶来解决此问题。\n\n### 1. 人造源项的推导\n\n该问题由平流-扩散-反应 (ADR) 方程控制：\n$$\n\\frac{\\partial u}{\\partial t} + a\\,\\frac{\\partial u}{\\partial x} \\;=\\; D\\,\\frac{\\partial^2 u}{\\partial x^2} \\;-\\; k\\,u \\;+\\; s(x,t)\n$$\n必须选择源项 $s(x,t)$，使得人造解 $u_{\\mathrm{m}}(x,t)$ 是此 PDE 的一个精确解。我们可以通过重排 ADR 方程并代入 $u_{\\mathrm{m}}(x,t)$ 来求得 $s(x,t)$：\n$$\ns(x,t) = \\frac{\\partial u_{\\mathrm{m}}}{\\partial t} + a\\,\\frac{\\partial u_{\\mathrm{m}}}{\\partial x} - D\\,\\frac{\\partial^2 u_{\\mathrm{m}}}{\\partial x^2} + k\\,u_{\\mathrm{m}}\n$$\n人造解给出如下：\n$$\nu_{\\mathrm{m}}(x,t) \\;=\\; \\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} \\;+\\; \\frac{1}{2}\\,x\\,(L-x)\n$$\n为了求得 $s(x,t)$，我们首先计算 $u_{\\mathrm{m}}(x,t)$ 的必要偏导数：\n\\begin{itemize}\n    \\item 时间导数：\n    $$\n    \\frac{\\partial u_{\\mathrm{m}}}{\\partial t} = -\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t}\n    $$\n    \\item 一阶空间导数：\n    $$\n    \\frac{\\partial u_{\\mathrm{m}}}{\\partial x} = \\frac{2\\pi}{L}\\cos\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} + \\frac{L}{2} - x\n    $$\n    \\item 二阶空间导数：\n    $$\n    \\frac{\\partial^2 u_{\\mathrm{m}}}{\\partial x^2} = -\\left(\\frac{2\\pi}{L}\\right)^2\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} - 1\n    $$\n\\end{itemize}\n将这些表达式代入 $s(x,t)$ 的方程中：\n$$\ns(x,t) = \\left[-\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t}\\right] + a\\left[\\frac{2\\pi}{L}\\cos\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} + \\frac{L}{2} - x\\right] - D\\left[-\\left(\\frac{2\\pi}{L}\\right)^2\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} - 1\\right] + k\\left[\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} + \\frac{1}{2}\\,x\\,(L-x)\\right]\n$$\n按其对 $x$ 和 $t$ 的函数依赖性对各项进行分组：\n$$\ns(x,t) = \\left(k - 1 + D\\left(\\frac{2\\pi}{L}\\right)^2\\right)\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\mathrm{e}^{-t} + \\left(\\frac{2\\pi a}{L}\\right)\\cos\\!\\left(\\frac{2\\pi x}{L}\\right)\\mathrm{e}^{-t} + a\\left(\\frac{L}{2} - x\\right) + D + \\frac{k}{2}x(L-x)\n$$\n这就是将在数值模型中实现的源项的解析表达式。\n\n### 2. 数值离散化\n\nPDE 在均匀空间网格 $x_i = i h$ (其中 $i \\in \\{0, 1, \\dots, N+1\\}$, $h = L/(N+1)$ 是网格间距) 上进行离散化。时间离散化为 $t_n = n \\Delta t$。我们将 $u(x_i, t_n)$ 的数值近似值表示为 $u_i^n$。\n\n指定的数值格式为：\n\\begin{itemize}\n    \\item **时间导数**：前向欧拉，$\\frac{\\partial u}{\\partial t} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}$。\n    \\item **扩散项**：二阶中心差分，$\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2}$。\n    \\item **平流项**：一阶迎风差分。其形式取决于速度 $a$ 的符号：\n    \\begin{itemize}\n        \\item 如果 $a \\ge 0$ (向右流动)，则使用后向差分：$\\frac{\\partial u}{\\partial x} \\approx \\frac{u_i^n - u_{i-1}^n}{h}$。\n        \\item 如果 $a  0$ (向左流动)，则使用前向差分：$\\frac{\\partial u}{\\partial x} \\approx \\frac{u_{i+1}^n - u_i^n}{h}$。\n    \\end{itemize}\n\\end{itemize}\n\n将 PDE 重排为 $\\frac{\\partial u}{\\partial t} = \\dots$ 并代入离散近似，得到更新规则 $u_i^{n+1} = u_i^n + \\Delta t (\\dots)$。\n\n对于 $a \\ge 0$：\n$$\nu_i^{n+1} = u_i^n + \\Delta t \\left[ D\\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2} - a\\frac{u_i^n - u_{i-1}^n}{h} - k u_i^n + s(x_i, t_n) \\right]\n$$\n对于 $a  0$：\n$$\nu_i^{n+1} = u_i^n + \\Delta t \\left[ D\\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2} - a\\frac{u_{i+1}^n - u_i^n}{h} - k u_i^n + s(x_i, t_n) \\right]\n$$\n这些方程应用于所有内部网格点 $i \\in \\{1, 2, \\dots, N\\}$。边界值由狄利克雷条件固定：$u_0^{n+1} = u_{\\mathrm{m}}(0, t_{n+1}) = 0$ 和 $u_{N+1}^{n+1} = u_{\\mathrm{m}}(L, t_{n+1}) = 0$。\n\n### 3. 时间步长和收敛性分析\n\n选择时间步长 $\\Delta t$ 以满足前向欧拉格式的显式稳定性条件：\n$$\n\\Delta t \\;=\\; 0.4 \\times \\min\\!\\left(\\frac{h}{|a|}, \\; \\frac{h^2}{2D}, \\; \\frac{1}{k}\\right)\n$$\n因子 $0.4$ 是一个安全系数，确保平流和扩散的 Courant–Friedrichs–Lewy (CFL) 条件以及反应项的稳定性条件都得到满足。\n\n模拟从初始条件 $u_i^0 = u_{\\mathrm{m}}(x_i, 0)$ 开始，并进行到最终时间 $T$。数值解 $u_i(T)$ 的精度通过相对离散 $L^2$ 误差来量化：\n$$\nE_h \\;=\\; \\frac{\\left(\\,h \\sum_{i=0}^{N+1} \\big(u_i(T) - u_{\\mathrm{m}}(x_i,T)\\big)^2\\,\\right)^{1/2}}{\\left(\\,h \\sum_{i=0}^{N+1} \\big(u_{\\mathrm{m}}(x_i,T)\\big)^2\\,\\right)^{1/2}}\n$$\n观测到的收敛阶 $p$ 是通过计算两种不同网格分辨率 $h_2$ (对应 $N_2=80$) 和 $h_3$ (对应 $N_3=160$) 的误差来估计的：\n$$\np \\;=\\; \\frac{\\ln\\!\\big(E_{h_2}/E_{h_3}\\big)}{\\ln\\!\\big(h_2/h_3\\big)}\n$$\n该数值格式对时间积分（前向欧拉）和平流（迎风法）采用一阶方法，对扩散采用二阶方法。总体精度受最低阶项的限制，因此理论收敛阶预计为 $p \\approx 1$。\n\n### 4. 实现\n\n该算法使用 `numpy` 库在 Python 中实现，以进行高效的向量化操作。定义一个函数，用于为给定的参数集 $(a, D, k)$ 和网格大小 $N$ 运行模拟。此函数初始化网格和解向量，计算稳定的时间步长，并在时间循环中迭代更新解。在循环内部，源项在当前时间进行评估，并根据 $a$ 的符号选择适当的迎风格式。达到最终时间 $T$ 后，该函数计算并返回相对 $L^2$ 误差。脚本的主体部分循环遍历四个测试集，为 $N=80$ 和 $N=160$ 调用模拟函数，为每个测试集计算收敛阶 $p$，并按指定格式打印结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and prints the observed convergence rates for the ADR equation\n    solution for four different parameter sets.\n    \"\"\"\n\n    def u_manufactured(x: np.ndarray, t: float, L: float) -> np.ndarray:\n        \"\"\"\n        Calculates the manufactured solution u_m(x, t).\n        \"\"\"\n        term1 = np.sin(2 * np.pi * x / L) * np.exp(-t)\n        term2 = 0.5 * x * (L - x)\n        return term1 + term2\n\n    def source_manufactured(x: np.ndarray, t: float, a: float, D: float, k: float, L: float) -> np.ndarray:\n        \"\"\"\n        Calculates the manufactured source term s(x, t).\n        \"\"\"\n        pi_term = 2 * np.pi / L\n        exp_t = np.exp(-t)\n        \n        sin_term = np.sin(pi_term * x)\n        cos_term = np.cos(pi_term * x)\n        \n        # Grouping terms as derived in the solution\n        term1 = (k - 1 + D * pi_term**2) * sin_term * exp_t\n        term2 = a * pi_term * cos_term * exp_t\n        term3 = a * (L/2 - x)\n        term4 = D\n        term5 = k * 0.5 * x * (L - x)\n\n        return term1 + term2 + term3 + term4 + term5\n\n    def run_simulation(N: int, a: float, D: float, k: float, L: float, T: float) -> float:\n        \"\"\"\n        Runs one simulation for a given grid size and parameter set.\n        \n        Returns:\n            The relative discrete L2 error.\n        \"\"\"\n        # Grid setup\n        h = L / (N + 1)\n        x = np.linspace(0, L, N + 2)\n\n        # Time step calculation based on stability criteria\n        # Handle cases where denominators might be zero\n        dt_adv = h / abs(a) if a != 0 else np.inf\n        dt_diff = h**2 / (2 * D) if D != 0 else np.inf\n        dt_react = 1 / k if k != 0 else np.inf\n        \n        dt = 0.4 * min(dt_adv, dt_diff, dt_react)\n        \n        num_steps = int(np.ceil(T / dt))\n        dt = T / num_steps  # Adjust dt to hit T exactly\n\n        # Initial condition\n        u = u_manufactured(x, 0, L)\n        \n        # Time-stepping loop\n        t = 0\n        for n in range(num_steps):\n            t = n * dt\n            u_n = u.copy()\n            \n            # Evaluate source term for interior points at current time t\n            s = source_manufactured(x[1:-1], t, a, D, k, L)\n\n            # Slicing for vectorized update\n            u_interior = u_n[1:-1]\n            u_left = u_n[0:-2]\n            u_right = u_n[2:]\n\n            # Diffusion and reaction terms\n            diffusion_term = D * (u_left - 2 * u_interior + u_right) / h**2\n            reaction_term = -k * u_interior\n\n            # Advection term (upwinding)\n            if a >= 0:\n                advection_term = -a * (u_interior - u_left) / h\n            else: # a  0\n                advection_term = -a * (u_right - u_interior) / h\n\n            # Update interior points\n            u[1:-1] = u_interior + dt * (diffusion_term + advection_term + reaction_term + s)\n\n            # Boundary conditions for the next step (t + dt) are u_m(0, t+dt) and u_m(L, t+dt)\n            # which are both 0 for all t > 0.\n            u[0] = u_manufactured(x[0], t + dt, L)\n            u[-1] = u_manufactured(x[-1], t + dt, L)\n\n        # Final time reached\n        t_final = T\n        u_exact_T = u_manufactured(x, t_final, L)\n\n        # Compute relative discrete L2 error\n        # The sqrt(h) factor in numerator and denominator can be cancelled if numpy's\n        # default L2 norm is used, but we'll implement the formula exactly for clarity.\n        err_numerator_sq = h * np.sum((u - u_exact_T)**2)\n        err_denominator_sq = h * np.sum(u_exact_T**2)\n        \n        if err_denominator_sq == 0:\n            return 0.0 if err_numerator_sq == 0 else np.inf\n            \n        error = np.sqrt(err_numerator_sq) / np.sqrt(err_denominator_sq)\n        \n        return error\n\n    def calculate_convergence_rate(params: tuple) -> float:\n        \"\"\"\n        Calculates the convergence rate for a given parameter set.\n        \"\"\"\n        a, D, k = params\n        L, T = 1.0, 0.1\n        N_vals = {'N2': 80, 'N3': 160}\n\n        h2 = L / (N_vals['N2'] + 1)\n        h3 = L / (N_vals['N3'] + 1)\n        \n        E_h2 = run_simulation(N_vals['N2'], a, D, k, L, T)\n        E_h3 = run_simulation(N_vals['N3'], a, D, k, L, T)\n        \n        # Handle cases where error might be zero\n        if E_h2 == 0 or E_h3 == 0:\n            return np.nan # Or some other indicator of non-standard convergence\n            \n        p = np.log(E_h2 / E_h3) / np.log(h2 / h3)\n        return p\n\n    # Test suite from the problem statement\n    test_cases = [\n        (0.05, 1.0e-3, 0.1),    # Set A: diffusion-dominated\n        (1.0, 1.0e-4, 0.1),     # Set B: advection-dominated, positive a\n        (-1.0, 1.0e-4, 0.1),    # Set C: advection-dominated, negative a\n        (0.01, 1.0e-4, 5.0),    # Set D: reaction-dominated\n    ]\n\n    results = []\n    for case in test_cases:\n        p = calculate_convergence_rate(case)\n        results.append(p)\n\n    # Format output as specified: [p_A,p_B,p_C,p_D] rounded to 3 decimal places.\n    print(f\"[{','.join([f'{r:.3f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}