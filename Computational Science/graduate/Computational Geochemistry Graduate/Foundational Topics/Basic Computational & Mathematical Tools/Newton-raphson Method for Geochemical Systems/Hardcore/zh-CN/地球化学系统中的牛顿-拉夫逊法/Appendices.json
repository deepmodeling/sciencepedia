{
    "hands_on_practices": [
        {
            "introduction": "构建雅可比矩阵是牛顿-拉夫逊方法的核心，而活度系数对摩尔浓度的导数往往是其中最复杂的项。本练习将通过一个标准的地球化学模型（戴维斯方程）提供应用链式法则的实践机会。掌握这种解析推导对于理解物种相互作用如何被编码在雅可比矩阵中至关重要 。",
            "id": "4092033",
            "problem": "在水地球化学系统中，求解非线性质量作用和质量平衡方程的Newton–Raphson方法需要雅可比矩阵项，这些项涉及活度系数对组成的敏感性。考虑离子的活度系数的Davies模型，其中活度系数的以10为底的对数由下式给出\n$$\n\\log_{10}\\gamma_{i} = -A z_{i}^{2}\\left(\\frac{\\sqrt{I}}{1+\\sqrt{I}} - 0.3\\, I\\right),\n$$\n离子强度的定义为\n$$\nI=\\frac{1}{2}\\sum_{j} m_{j} z_{j}^{2},\n$$\n其中 $m_{j}$ 是物种 $j$ 的质量摩尔浓度，$z_{j}$ 是其电荷数，$A$ 是Debye–Hückel常数（依赖于温度）。仅使用这些定义和标准微积分，推导偏导数\n$$\n\\frac{\\partial \\ln \\gamma_{i}}{\\partial m_{k}}\n$$\n用 $A$、$z_{i}$、$z_{k}$ 和 $I$ 表示的闭式解析表达式。你的最终答案必须是一个单一的简化解析表达式。不需要进行数值计算或四舍五入，最终答案中也不应包含单位。",
            "solution": "该问题被认为是有效的，因为它基于已建立的物理化学模型（Davies方程，离子强度），具有科学依据，是良定的、客观的，并包含获得唯一解所需的所有必要信息。\n\n目标是推导偏导数 $\\frac{\\partial \\ln \\gamma_{i}}{\\partial m_{k}}$ 的闭式解析表达式。活度系数 $\\gamma_i$ 由Davies模型给出，其值取决于离子强度 $I$，而离子强度 $I$ 又取决于系统中所有物种的质量摩尔浓度 $m_j$ （包括 $m_k$）。\n\n首先，我们使用对数的换底公式 $\\ln x = \\ln(10) \\log_{10} x$，将给定的活度系数的以10为底的对数 $\\log_{10} \\gamma_i$ 与自然对数 $\\ln \\gamma_i$ 联系起来。将此应用于 $\\gamma_i$ 可得：\n$$\n\\ln \\gamma_i = \\ln(10) \\log_{10} \\gamma_i\n$$\n将Davies方程代入此关系式可得：\n$$\n\\ln \\gamma_i = \\ln(10) \\left[ -A z_{i}^{2}\\left(\\frac{\\sqrt{I}}{1+\\sqrt{I}} - 0.3 I\\right) \\right]\n$$\n$$\n\\ln \\gamma_i = -A \\ln(10) z_{i}^{2}\\left(\\frac{\\sqrt{I}}{1+\\sqrt{I}} - 0.3 I\\right)\n$$\n我们需要求 $\\ln \\gamma_i$ 对特定物种 $k$ 的质量摩尔浓度 $m_k$ 的偏导数。由于 $\\ln \\gamma_i$ 是离子强度 $I$ 的显函数，而 $I$ 是所有质量摩尔浓度 $m_j$ （包括 $m_k$）的函数，我们必须应用偏微分的链式法则：\n$$\n\\frac{\\partial \\ln \\gamma_i}{\\partial m_k} = \\frac{d(\\ln \\gamma_i)}{dI} \\frac{\\partial I}{\\partial m_k}\n$$\n我们将分别计算右侧的每一项。\n\n第一项是 $\\ln \\gamma_i$ 对 $I$ 的导数。为清晰起见，令 $C_i = -A \\ln(10) z_i^2$，该项相对于 $I$ 是常数。\n$$\n\\frac{d(\\ln \\gamma_i)}{dI} = \\frac{d}{dI} \\left[ C_i \\left(\\frac{I^{1/2}}{1+I^{1/2}} - 0.3 I\\right) \\right] = C_i \\left[ \\frac{d}{dI}\\left(\\frac{I^{1/2}}{1+I^{1/2}}\\right) - \\frac{d}{dI}(0.3 I) \\right]\n$$\n我们计算括号内两项的导数。第二项的导数很简单：\n$$\n\\frac{d}{dI}(0.3 I) = 0.3\n$$\n对于第一项，我们使用商法则，其中 $u = I^{1/2}$ 且 $v = 1+I^{1/2}$。它们对 $I$ 的导数分别是 $u' = \\frac{1}{2}I^{-1/2}$ 和 $v' = \\frac{1}{2}I^{-1/2}$。\n$$\n\\frac{d}{dI}\\left(\\frac{I^{1/2}}{1+I^{1/2}}\\right) = \\frac{u'v - uv'}{v^2} = \\frac{(\\frac{1}{2}I^{-1/2})(1+I^{1/2}) - I^{1/2}(\\frac{1}{2}I^{-1/2})}{(1+I^{1/2})^2}\n$$\n$$\n= \\frac{\\frac{1}{2}I^{-1/2} + \\frac{1}{2} - \\frac{1}{2}}{(1+I^{1/2})^2} = \\frac{\\frac{1}{2}I^{-1/2}}{(1+I^{1/2})^2} = \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^2}\n$$\n结合这些结果，我们得到 $\\frac{d(\\ln \\gamma_i)}{dI}$ 的表达式：\n$$\n\\frac{d(\\ln \\gamma_i)}{dI} = -A \\ln(10) z_i^2 \\left( \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^2} - 0.3 \\right)\n$$\n链式法则所需的第二项是离子强度 $I$ 对质量摩尔浓度 $m_k$ 的偏导数。离子强度的定义是：\n$$\nI = \\frac{1}{2}\\sum_{j} m_{j} z_{j}^{2}\n$$\n我们对 $m_k$ 求偏导数：\n$$\n\\frac{\\partial I}{\\partial m_k} = \\frac{\\partial}{\\partial m_k} \\left( \\frac{1}{2}\\sum_{j} m_{j} z_{j}^{2} \\right) = \\frac{1}{2}\\sum_{j} z_{j}^{2} \\frac{\\partial m_j}{\\partial m_k}\n$$\n偏导数 $\\frac{\\partial m_j}{\\partial m_k}$ 在 $j=k$ 时等于 $1$，在 $j \\neq k$ 时等于 $0$。这是克罗内克δ符号 $\\delta_{jk}$ 的定义。因此，求和中只有 $j=k$ 的项是非零的。\n$$\n\\frac{\\partial I}{\\partial m_k} = \\frac{1}{2}\\sum_{j} z_{j}^{2} \\delta_{jk} = \\frac{1}{2} z_k^2\n$$\n最后，我们将推导出的两个分量相乘，得到 $\\frac{\\partial \\ln \\gamma_i}{\\partial m_k}$ 的完整表达式：\n$$\n\\frac{\\partial \\ln \\gamma_i}{\\partial m_k} = \\left[ -A \\ln(10) z_i^2 \\left( \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^2} - 0.3 \\right) \\right] \\cdot \\left[ \\frac{1}{2} z_k^2 \\right]\n$$\n简化此表达式可得到最终答案：\n$$\n\\frac{\\partial \\ln \\gamma_i}{\\partial m_k} = -\\frac{A \\ln(10) z_i^2 z_k^2}{2} \\left( \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^2} - 0.3 \\right)\n$$\n这个表达式可以将负号吸收到括号内，写成一种略有不同的形式：\n$$\n\\frac{\\partial \\ln \\gamma_i}{\\partial m_k} = \\frac{A \\ln(10) z_i^2 z_k^2}{2} \\left( 0.3 - \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^2} \\right)\n$$\n两种形式是等价的。我们将以后者作为最终答案。",
            "answer": "$$\\boxed{\\frac{A \\ln(10) z_{i}^{2} z_{k}^{2}}{2} \\left( 0.3 - \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^{2}} \\right)}$$"
        },
        {
            "introduction": "一个数学上正确的雅可比矩阵并不能保证求解器的鲁棒性，因为地球化学体系常常涉及浓度差异巨大的物种，这会带来数值计算上的挑战。本练习旨在激发对数值模型中变量选择的批判性思考。通过分析使用摩尔浓度与其对数形式的优劣，您将深入理解数值稳定性、矩阵条件数以及如何施加物理约束等基本概念 。",
            "id": "4091986",
            "problem": "考虑一个在恒定温度和压力下的水相络合体系，其中一个二价金属阳离子 $\\text{M}^{2+}$ 和一个一价配体阴离子 $\\text{L}^{-}$ 通过反应 $\\text{M}^{2+} + \\text{L}^{-} \\rightleftharpoons \\text{ML}^{+}$ 形成络合物 $\\text{ML}^{+}$。设未知物种的质量摩尔浓度为 $\\mathbf{m} = (m_M, m_L, m_{ML})^{\\top}$，总分析质量摩尔浓度为 $M_T$ 和 $L_T$。活度模型为 $a_i = \\gamma_i m_i$，其中 $\\gamma_i$ 是活度系数，它通过一个 Davies 型公式平滑地依赖于离子强度 $I$，例如 $\\log_{10}\\gamma_i = -A z_i^2\\left(\\frac{\\sqrt{I}}{1 + \\sqrt{I}} - 0.3\\, I\\right)$，其中 $z_i$ 是物种 $i$ 的化学计量电荷，$A$ 是一个与溶剂相关的常数。离子强度的定义为 $I = \\tfrac{1}{2}\\sum_i z_i^2 m_i$。反应的平衡常数 $K$ 由平衡时的质量作用定律 $K = \\dfrac{a_{ML}}{a_M a_L}$ 定义。\n\n通过在平衡时强制执行质量平衡和质量作用定律，可以构建一个标准的用于牛顿-拉夫逊方法的非线性残差。使用物种质量摩尔浓度 $\\mathbf{m}$，一个可能的残差向量是\n$$\n\\mathbf{R}(\\mathbf{m}) =\n\\begin{pmatrix}\nm_M + m_{ML} - M_T \\\\\nm_L + m_{ML} - L_T \\\\\n\\ln K - \\left(\\ln \\gamma_{ML} + \\ln m_{ML}\\right) + \\left(\\ln \\gamma_M + \\ln m_M\\right) + \\left(\\ln \\gamma_L + \\ln m_L\\right)\n\\end{pmatrix}.\n$$\n另一种公式使用对数变换变量 $\\mathbf{y} = (y_M, y_L, y_{ML})^{\\top}$，其中 $y_i = \\ln m_i$，并将残差定义为复合函数 $\\mathbf{G}(\\mathbf{y}) = \\mathbf{R}(\\exp(\\mathbf{y}))$，其中 $\\exp(\\mathbf{y})$ 表示从 $\\mathbf{y}$ 回到 $\\mathbf{m}$ 的按分量进行的指数映射。\n\n牛顿-拉夫逊方法使用雅可比矩阵对这些残差进行线性化，并迭代求解 $J(\\mathbf{x}^{(k)})\\,\\Delta \\mathbf{x}^{(k)} = -\\mathbf{F}(\\mathbf{x}^{(k)})$，然后进行更新 $\\mathbf{x}^{(k+1)} = \\mathbf{x}^{(k)} + \\Delta \\mathbf{x}^{(k)}$，其中 $\\mathbf{F}$ 是残差，$J$ 是其关于所选变量的雅可比矩阵。\n\n从第一性原理出发，分析在使用物种质量摩尔浓度 $\\mathbf{m}$ 与对数变换变量 $\\mathbf{y}$ 时，针对所述络合体系的残差的光滑性以及牛顿-拉夫逊方法的数值稳健性，并考虑以下因素：\n- $\\gamma_i$ 对离子强度 $I$ 的平滑依赖性以及 $I = \\tfrac{1}{2}\\sum_i z_i^2 m_i$ 的定义。\n- 水溶液中所有物种 $i$ 的正值约束 $m_i > 0$。\n- 当物种浓度跨越多个数量级时，变量缩放对雅可比矩阵和条件数的影响。\n\n下列哪些陈述是正确的？选择所有适用项。\n\nA. 使用变量 $\\mathbf{y} = \\ln \\mathbf{m}$ 可以确保迭代值 $\\mathbf{m} = \\exp(\\mathbf{y})$ 保持严格为正，这减少了对步长裁剪等保护策略的需求，并且通常能提高在高度稀释体系中的稳健性。\n\nB. 关于 $\\mathbf{y}$ 的雅可比矩阵在 $\\mathbf{m} = \\exp(\\mathbf{y})$ 处满足 $J_{\\mathbf{y}}(\\mathbf{y}) = J_{\\mathbf{m}}(\\mathbf{m})\\,\\mathrm{diag}(\\mathbf{m})$；当物种质量摩尔浓度相差多个数量级时，这种列缩放倾向于减小条件数的差异，从而常常增强牛顿-拉夫逊方法的稳健性。\n\nC. 如果活度系数遵循 Davies 型模型，变换到 $\\mathbf{y} = \\ln \\mathbf{m}$ 会在 $m_i=0$ 处引入不可微性，这会降低光滑性，并使得牛顿-拉夫逊方法与在 $\\mathbf{m}$ 中工作相比更不可靠。\n\nD. 牛顿-拉夫逊方法在如 $\\mathbf{y} = \\ln \\mathbf{m}$ 这样的光滑重参数化下是不变的，因此无论在 $\\mathbf{m}$ 空间还是在 $\\mathbf{y}$ 空间求解，其收敛行为都是相同的。\n\nE. 在 $\\mathbf{y} = \\ln \\mathbf{m}$ 空间工作可以普遍消除由络合化学计量引起的病态问题，并保证无论初始猜测如何都能快速收敛。\n\n请提供您的选择，并基于离子强度、活度、质量作用定律和牛顿-拉夫逊线性化的基本定义来证明您的选择，不假设超出这些原理的任何专门的求解器技巧。",
            "solution": "问题的核心是比较牛顿-拉夫逊方法在应用于以两组不同变量（物种质量摩尔浓度 $\\mathbf{m}$ 及其对数 $\\mathbf{y} = \\ln \\mathbf{m}$）表示的同一方程组时的数值特性。\n\n**A. 正确。** 化学质量摩尔浓度 $m_i$ 必须为正值。当直接使用 $\\mathbf{m}$ 作为变量时，牛顿迭代步 $\\mathbf{m}^{(k+1)} = \\mathbf{m}^{(k)} + \\Delta \\mathbf{m}^{(k)}$ 无法内在保证 $m_i^{(k+1)} > 0$。如果某次迭代的步长过大，可能导致浓度变为非物理的负值，进而因 $\\ln m_i$ 无定义而导致算法失败。为了避免这种情况，需要采取步长缩减等额外的保护措施。相反，当使用对数变换变量 $\\mathbf{y} = \\ln \\mathbf{m}$ 时，浓度通过反向变换 $m_i = e^{y_i}$ 计算得出。由于指数函数对于任何实数输入其值域均为正，因此任何迭代步都能保证浓度的正值性，从而自动满足了物理约束，提高了算法的稳健性。\n\n**B. 正确。** 根据多元链式法则，两个雅可比矩阵 $J_{\\mathbf{y}}$ 和 $J_{\\mathbf{m}}$ 之间的关系为 $J_{\\mathbf{y}} = J_{\\mathbf{m}}\\,\\mathrm{diag}(\\mathbf{m})$。质量作用定律残差对浓度 $m_i$ 的偏导数通常包含 $1/m_i$ 形式的项。在地球化学体系中，物种浓度常跨越多个数量级，导致 $1/m_i$ 项的数值差异巨大。这会使雅可比矩阵 $J_{\\mathbf{m}}$ 的列尺度严重不平衡，导致矩阵病态，从而影响线性求解的精度和稳定性。对数变换通过右乘一个对角矩阵 $\\mathrm{diag}(\\mathbf{m})$ 对雅可比矩阵的列进行了缩放，这恰好抵消了 $1/m_i$ 项，使得各列的范数更加均衡。这种预处理效应改善了矩阵的条件数，从而增强了牛顿法的数值稳健性。\n\n**C. 不正确。** 该陈述错误地归因了光滑性问题。不可微性（源于 $\\ln m_i$ 项和Davies方程中的 $\\sqrt{I}$ 项）存在于原始 $\\mathbf{m}$-空间可行域的边界（即 $m_i=0$ 处）。对数变换将整个无约束的 $\\mathbf{y}$-空间映射到 $\\mathbf{m}$-空间的严格为正的内部，有效地使求解过程远离了这些边界奇点。因此，从求解器的角度来看，变换后的残差函数在其整个定义域（所有 $\\mathbf{y} \\in \\mathbb{R}^3$）上是光滑的。这种变换实际上*改善*了问题的光滑性，而不是降低了可靠性。\n\n**D. 不正确。** 牛顿法在非线性的变量重参数化下不是不变的。在 $\\mathbf{m}$-空间和 $\\mathbf{y}$-空间中生成的迭代序列是不同的，它们在各自的空间中遵循不同的路径到达解。正如选项A和B所分析的，这两种公式具有截然不同的数值收敛行为和稳健性，证明了其非不变性。\n\n**E. 不正确。** 该陈述过于绝对。“普遍消除”和“保证……快速收敛”的说法是不准确的。虽然对数变换是一种非常强大的技术，能够显著改善由浓度尺度差异引起的病态问题，但它并不能解决所有可能的病态来源。此外，牛顿法本质上是一种局部收敛方法。即使使用了对数变换，如果初始猜测距离真解太远，算法仍然可能发散。该变换扩大了收敛域，但不能保证全局收敛。",
            "answer": "$$\\boxed{AB}$$"
        },
        {
            "introduction": "对于复杂的地球化学体系，手动推导雅可比矩阵既费力又容易出错，而现代计算科学为此提供了强大的替代方案。这个编码练习将介绍前向模式自动微分，一种以编程方式计算精确导数的技术。通过实现一个简单的自动微分框架，您将学会如何自动化构建雅可比矩阵，这项技能将极大地加速复杂地球化学模型的开发过程 。",
            "id": "4092063",
            "problem": "要求您使用对偶数实现一个前向模式自动微分引擎，用于计算由质量作用定律和活度系数控制的地球化学平衡系统中牛顿-拉夫逊（Newton-Raphson）更新所需的导数。该系统必须根据基本的地球化学定义和质量作用关系进行定义，并且必须产生可进行数值测试的输出。\n\n此任务的基础包括计算地球化学中以下广为接受的定义和定律：\n- 水溶液中物种 $i$ 的活度定义为 $a_i = \\gamma_i m_i$，其中 $m_i$ 是质量摩尔浓度（单位：mol/kg 水），$\\gamma_i$ 是活度系数（无量纲）。\n- 水溶液的离子强度 $I$ 定义为 $I = \\frac{1}{2}\\sum_i m_i z_i^2$，其中 $z_i$ 是物种 $i$ 的电荷数。\n- $25\\,^\\circ\\text{C}$ 时的 Davies 方程表示带电物种活度系数的常用对数（以 10 为底）为\n$$\\log_{10} \\gamma_i = -A z_i^2 \\left(\\frac{\\sqrt{I}}{1 + \\sqrt{I}} - 0.3 I\\right),$$\n其中 $A = 0.509$ 是 $25\\,^\\circ\\text{C}$ 时的 Debye-Hückel 常数。中性物种的 $z_i=0$，因此 $\\gamma_i = 1$。\n- 对于一个化学计量系数为 $\\nu_{r,i}$、平衡常数为 $K_r$ 的反应 $r$，其通用质量作用残差定义为：\n$$R_r(\\mathbf{m}) = \\sum_i \\nu_{r,i} \\ln a_i - \\ln K_r,$$\n在平衡状态下该式等于 $0$。\n\n您的程序必须：\n1. 使用对偶数实现一个前向模式自动微分框架，以在所有计算中传播导数 $\\frac{\\partial}{\\partial m_k}$。\n2. 对于每个系统，通过 Davies 方程计算 $I(\\mathbf{m})$ 和 $\\gamma_i(I)$，并计算 $a_i(\\mathbf{m}) = \\gamma_i m_i$。\n3. 使用自动微分，为每个测试用例中指定的索引 $(i,k)$ 计算并返回值 $\\frac{\\partial a_i}{\\partial m_k}$ 和 $\\frac{\\partial R_r}{\\partial m_k}$，而无需手动编写导数公式。\n\n下面定义了三个必需的测试用例，每个用例都包含物种列表、电荷数 $z_i$、质量摩尔浓度 $m_i$ (mol/kg)、一个具有化学计量系数 $\\nu_{r,i}$ 的单一反应以及一个平衡常数 $K_r$（无量纲）。对于每个用例，程序必须按顺序计算以下输出：$\\frac{\\partial a_{i^\\ast}}{\\partial m_{k_1}}$、$\\frac{\\partial a_{i^\\ast}}{\\partial m_{k_2}}$、$\\frac{\\partial R_r}{\\partial m_{k_1}}$ 和 $R_r$。\n\n案例 1（中等离子强度，氯化钠及其中性离子对）：\n- 物种：$\\text{Na}^+$, $\\text{Cl}^-$, $\\text{NaCl}^0$。\n- 电荷：$z = [1, -1, 0]$。\n- 质量摩尔浓度：$m = [0.1, 0.1, 10^{-8}]$ (mol/kg)。\n- 反应：$\\text{NaCl}^0 \\rightleftharpoons \\text{Na}^+ + \\text{Cl}^-$，化学计量系数 $\\nu = [1, 1, -1]$，平衡常数 $K = 0.78$。\n- 输出目标：$i^\\ast$ 指 $\\text{Na}^+$（索引 0），$k_1 = \\text{Na}^+$（索引 0），$k_2 = \\text{Cl}^-$（索引 1）。\n\n案例 2（极稀盐酸）：\n- 物种：$\\text{H}^+$, $\\text{Cl}^-$, $\\text{HCl}^0$。\n- 电荷：$z = [1, -1, 0]$。\n- 质量摩尔浓度：$m = [10^{-6}, 10^{-6}, 10^{-12}]$ (mol/kg)。\n- 反应：$\\text{HCl}^0 \\rightleftharpoons \\text{H}^+ + \\text{Cl}^-$，化学计量系数 $\\nu = [1, 1, -1]$，平衡常数 $K = 10^{-8}$。\n- 输出目标：$i^\\ast$ 指 $\\text{H}^+$（索引 0），$k_1 = \\text{H}^+$（索引 0），$k_2 = \\text{Cl}^-$（索引 1）。\n\n案例 3（高离子强度氯化钙及其中性络合物）：\n- 物种：$\\text{Ca}^{2+}$, $\\text{Cl}^-$, $\\text{CaCl}_2^0$。\n- 电荷：$z = [2, -1, 0]$。\n- 质量摩尔浓度：$m = [0.5, 1.0, 10^{-6}]$ (mol/kg)。\n- 反应：$\\text{CaCl}_2^0 \\rightleftharpoons \\text{Ca}^{2+} + 2\\,\\text{Cl}^-$，化学计量系数 $\\nu = [1, 2, -1]$，平衡常数 $K = 0.3$。\n- 输出目标：$i^\\ast$ 指 $\\text{Ca}^{2+}$（索引 0），$k_1 = \\text{Ca}^{2+}$（索引 0），$k_2 = \\text{Cl}^-$（索引 1）。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n- 案例 1：$\\left[\\frac{\\partial a_{\\text{Na}^+}}{\\partial m_{\\text{Na}^+}}, \\frac{\\partial a_{\\text{Na}^+}}{\\partial m_{\\text{Cl}^-}}, \\frac{\\partial R}{\\partial m_{\\text{Na}^+}}, R\\right]$。\n- 案例 2：$\\left[\\frac{\\partial a_{\\text{H}^+}}{\\partial m_{\\text{H}^+}}, \\frac{\\partial a_{\\text{H}^+}}{\\partial m_{\\text{Cl}^-}}, \\frac{\\partial R}{\\partial m_{\\text{H}^+}}, R\\right]$。\n- 案例 3：$\\left[\\frac{\\partial a_{\\text{Ca}^{2+}}}{\\partial m_{\\text{Ca}^{2+}}}, \\frac{\\partial a_{\\text{Ca}^{2+}}}{\\partial m_{\\text{Cl}^-}}, \\frac{\\partial R}{\\partial m_{\\text{Ca}^{2+}}}, R\\right]$。\n\n将所有十二个数字连接成一个列表，并将每个数字四舍五入到六位小数。例如，程序必须打印：\n$$\\left[\\text{c}_{1,1}, \\text{c}_{1,2}, \\text{c}_{1,3}, \\text{c}_{1,4}, \\text{c}_{2,1}, \\ldots, \\text{c}_{3,4}\\right],$$\n其中 $\\text{c}_{i,j}$ 是计算得出并四舍五入到六位小数的浮点数。\n\n不允许外部输入。活度和残差是无量纲的；质量摩尔浓度必须按规定以 $\\mathrm{mol}/\\mathrm{kg}$ 为单位处理，质量作用残差中的所有对数必须是自然对数。请通过对所有物种使用严格为正的质量摩尔浓度来确保科学真实性。",
            "solution": "待实现的系统依赖于应用于地球化学活度模型和质量作用残差的链式法则，通过前向模式自动微分来表达。用于地球化学系统的牛顿-拉夫逊方法需要残差向量相对于自变量（在此情境下为物种的质量摩尔浓度）的雅可比矩阵。我们展示了如何通过对偶数将导数传播嵌入到算术运算中，从而自动获得这些导数。\n\n我们从定义开始。对于物种 $i$，活度为 $a_i = \\gamma_i m_i$，其中 $m_i$ 是质量摩尔浓度，$\\gamma_i$ 是活度系数。对于一个化学计量系数为 $\\nu_{r,i}$、平衡常数为 $K_r$ 的单一反应 $r$，其残差为\n$$ R_r(\\mathbf{m}) = \\sum_i \\nu_{r,i} \\ln a_i - \\ln K_r. $$\n离子强度为\n$$ I(\\mathbf{m}) = \\frac{1}{2}\\sum_i m_i z_i^2. $$\n活度系数的常用对数的 Davies 方程为\n$$ \\log_{10} \\gamma_i = -A z_i^2 \\left(\\frac{\\sqrt{I}}{1 + \\sqrt{I}} - 0.3 I\\right), $$\n其中 $A = 0.509$。转换为自然对数，我们得到\n$$ \\ln \\gamma_i = \\ln(10)\\, \\log_{10} \\gamma_i = -\\ln(10)\\,A z_i^2 \\left(\\frac{\\sqrt{I}}{1 + \\sqrt{I}} - 0.3 I\\right). $$\n因此，$\\gamma_i = \\exp(\\ln \\gamma_i)$，活度为 $a_i = \\gamma_i m_i$。\n\n为了计算 $\\frac{\\partial a_i}{\\partial m_k}$，我们应用乘法法则：\n$$ \\frac{\\partial a_i}{\\partial m_k} = \\frac{\\partial}{\\partial m_k}\\left(\\gamma_i m_i\\right) = \\gamma_i \\delta_{ik} + m_i \\frac{\\partial \\gamma_i}{\\partial m_k}, $$\n其中 $\\delta_{ik}$ 是克罗内克（Kronecker）δ函数，而 $\\frac{\\partial \\gamma_i}{\\partial m_k}$ 通过 $I(\\mathbf{m})$ 经由链式法则获得。具体来说，\n$$ \\frac{\\partial \\gamma_i}{\\partial m_k} = \\gamma_i \\frac{\\partial \\ln \\gamma_i}{\\partial m_k}, $$\n并且\n$$ \\frac{\\partial \\ln \\gamma_i}{\\partial m_k} = -\\ln(10)\\,A z_i^2 \\left( \\frac{\\partial}{\\partial m_k}\\left(\\frac{\\sqrt{I}}{1+\\sqrt{I}}\\right) - 0.3 \\frac{\\partial I}{\\partial m_k} \\right). $$\n$I$ 的导数为\n$$ \\frac{\\partial I}{\\partial m_k} = \\frac{1}{2} z_k^2. $$\n令 $s = \\sqrt{I}$；则\n$$ \\frac{\\partial}{\\partial m_k}\\left(\\frac{s}{1+s}\\right) = \\frac{(1+s)\\frac{\\partial s}{\\partial m_k} - s \\frac{\\partial s}{\\partial m_k}}{(1+s)^2} = \\frac{\\frac{\\partial s}{\\partial m_k}}{(1+s)^2}. $$\n由于 $s = I^{1/2}$，我们有\n$$ \\frac{\\partial s}{\\partial m_k} = \\frac{1}{2} I^{-1/2} \\frac{\\partial I}{\\partial m_k} = \\frac{z_k^2}{4 \\sqrt{I}}. $$\n将这些组合在一起可以得到一个显式公式，但我们的目标是避免显式地编写这些导数代码，而是实现前向模式自动微分。在前向模式自动微分中，每个 $m_k$ 被表示为一个对偶数 $M_k = m_k + \\varepsilon \\,\\frac{\\partial}{\\partial m_k}$，并且每个算术运算都被重载以同时传播原始值和导数向量。对于多变量情况，导数部分是 $\\mathbb{R}^n$ 中的一个向量，其种子向量等于变量 $m_k$ 的标准基向量 $e_k$。\n\n实现步骤如下：\n1. 将每个质量摩尔浓度 $m_i$ 表示为一个对偶数，其原始值为 $m_i$，导数向量等于第 $i$ 个标准基向量。\n2. 使用对偶数算术计算 $I(\\mathbf{m}) = \\frac{1}{2} \\sum_i m_i z_i^2$；这将同时得到 $I$ 和 $\\nabla I$。\n3. 通过对偶数 $\\sqrt{\\cdot}$ 运算计算 $s = \\sqrt{I}$。\n4. 通过对偶数算术计算 Davies 项 $t = \\frac{s}{1+s} - 0.3 I$。\n5. 通过对偶数 $\\exp$ 运算计算 $\\ln \\gamma_i = -\\ln(10)\\,A z_i^2 \\, t$，然后计算 $\\gamma_i = \\exp(\\ln \\gamma_i)$。\n6. 通过对偶数乘法计算 $a_i = \\gamma_i \\, m_i$。\n7. 通过对偶数 $\\ln$ 运算计算残差 $R_r(\\mathbf{m}) = \\sum_i \\nu_{r,i} \\ln a_i - \\ln K_r$。\n8. 从 $a_i$ 和 $R_r$ 的导数向量中提取与目标索引 $k$ 相对应的导数分量。\n\n由于对偶数算术自动执行链式法则，导数 $\\frac{\\partial a_i}{\\partial m_k}$ 和 $\\frac{\\partial R_r}{\\partial m_k}$ 的获得无需编写显式的解析导数，从而确保了即使在通过像 $\\sqrt{\\cdot}$ 和 $\\exp(\\cdot)$ 这样的嵌套函数时也能正确、稳定地传播。\n\n该测试套件包括三种情景：\n- 案例 1 检查了具有单价离子的中等离子强度情况，评估了自敏感度和交叉敏感度以及包含中性络合物的质量作用残差；这测试了典型的“理想路径”。\n- 案例 2 检查了接近稀释极限时的行为，此时 $\\gamma_i \\approx 1$，但通过 $\\sqrt{I}$ 的链式法则可能很敏感；这通过使用严格为正的质量摩尔浓度来避免零离子强度，作为一个边界案例。\n- 案例 3 检查了高离子强度和多价离子的情况，此时活度系数的非线性非常显著；这着重测试了在非线性区域中的导数传播。\n\n最终程序输出一行，包含十二个数字（每个案例四个），以逗号分隔列表的形式用方括号括起来，每个浮点数四舍五入到六位小数，顺序与问题陈述中指定的一致。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Forward-mode automatic differentiation using dual numbers with vector derivatives.\nclass Dual:\n    def __init__(self, value: float, deriv: np.ndarray):\n        self.value = float(value)\n        # Ensure derivative is a 1-D numpy array of floats\n        self.deriv = np.array(deriv, dtype=float)\n\n    def __add__(self, other):\n        other = to_dual(other, self.deriv.size)\n        return Dual(self.value + other.value, self.deriv + other.deriv)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        other = to_dual(other, self.deriv.size)\n        return Dual(self.value - other.value, self.deriv - other.deriv)\n\n    def __rsub__(self, other):\n        other = to_dual(other, self.deriv.size)\n        return Dual(other.value - self.value, other.deriv - self.deriv)\n\n    def __mul__(self, other):\n        other = to_dual(other, self.deriv.size)\n        # Product rule: d(u*v) = u' * v + u * v'\n        return Dual(self.value * other.value, self.deriv * other.value + self.value * other.deriv)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __truediv__(self, other):\n        other = to_dual(other, self.deriv.size)\n        # Quotient rule: d(u/v) = (u' * v - u * v') / v^2\n        denom = other.value * other.value\n        return Dual(self.value / other.value, (self.deriv * other.value - self.value * other.deriv) / denom)\n\n    def __rtruediv__(self, other):\n        other = to_dual(other, self.deriv.size)\n        # other / self\n        denom = self.value * self.value\n        return Dual(other.value / self.value, (other.deriv * self.value - other.value * self.deriv) / denom)\n\n    def __pow__(self, power):\n        # Only support scalar power for simplicity\n        if isinstance(power, (int, float)):\n            if self.value == 0 and power != int(power) and power  1:\n                raise ValueError(\"Dual power with non-integer exponent requires positive base.\")\n            val = self.value ** power\n            # d(x^p) = p * x^(p-1) dx\n            coeff = power * (self.value ** (power - 1)) if self.value != 0 else 0.0\n            return Dual(val, coeff * self.deriv)\n        else:\n            raise NotImplementedError(\"Power with Dual exponent not implemented.\")\n\ndef to_dual(x, nvars):\n    if isinstance(x, Dual):\n        return x\n    else:\n        return Dual(float(x), np.zeros(nvars, dtype=float))\n\ndef dual_sqrt(x: Dual) -> Dual:\n    if x.value  0.0:\n        raise ValueError(\"Sqrt of negative Dual value encountered.\")\n    if x.value == 0.0:\n        # For geochemical ionic strength I, we expect strictly positive due to positive molalities.\n        # If I is exactly zero, derivative is undefined, but this case is avoided by problem constraints.\n        # Handle numerically for robustness, though not strictly needed here.\n        eps = 1e-30\n        val = np.sqrt(x.value + eps)\n        deriv = (0.5 / val) * x.deriv\n        return Dual(val, deriv)\n    val = np.sqrt(x.value)\n    deriv = (0.5 / val) * x.deriv\n    return Dual(val, deriv)\n\ndef dual_log(x: Dual) -> Dual:\n    if x.value = 0.0:\n        raise ValueError(\"Log of non-positive Dual value encountered.\")\n    return Dual(np.log(x.value), x.deriv / x.value)\n\ndef dual_exp(x: Dual) -> Dual:\n    val = np.exp(x.value)\n    return Dual(val, val * x.deriv)\n\ndef make_dual_vars(m_values):\n    n = len(m_values)\n    vars_dual = []\n    for i, mv in enumerate(m_values):\n        deriv = np.zeros(n, dtype=float)\n        deriv[i] = 1.0\n        vars_dual.append(Dual(float(mv), deriv))\n    return vars_dual\n\ndef davies_gamma_dual(z_list, m_dual_list, A=0.509):\n    \"\"\"\n    Compute gamma_i for all species using Davies equation via dual arithmetic.\n    Returns list of Dual gamma_i.\n    \"\"\"\n    n = len(m_dual_list)\n    # Ionic strength I = 0.5 * sum(m_i * z_i^2)\n    I = Dual(0.0, np.zeros(n, dtype=float))\n    for mi, zi in zip(m_dual_list, z_list):\n        I = I + mi * (zi * zi * 1.0)\n\n    I = I * 0.5\n    s = dual_sqrt(I)\n    # term = s/(1+s) - 0.3 * I\n    term = s / (1.0 + s) - I * 0.3\n    # ln(gamma_i) = ln(10) * log10(gamma_i) = -ln(10) * A * z_i^2 * term\n    ln10 = np.log(10.0)\n    gammas = []\n    for zi in z_list:\n        if zi == 0:\n            # Neutral species: gamma = 1.0 exactly\n            gammas.append(Dual(1.0, np.zeros(n, dtype=float)))\n        else:\n            ln_gamma_i = (-ln10 * A * (zi * zi)) * term\n            gamma_i = dual_exp(ln_gamma_i)\n            gammas.append(gamma_i)\n    return gammas\n\ndef compute_system_outputs(names, z, m, nu, K, i_target, k1, k2):\n    \"\"\"\n    For a given system, compute:\n    d a_i_target / d m_{k1}, d a_i_target / d m_{k2}, dR/dm_{k1}, R\n    \"\"\"\n    # Create dual variables for molalities\n    m_dual = make_dual_vars(m)\n    # Compute gamma_i via Davies\n    gamma_dual = davies_gamma_dual(z, m_dual, A=0.509)\n    # Activities a_i = gamma_i * m_i\n    a_dual = [gamma_dual[i] * m_dual[i] for i in range(len(m))]\n    # Residual R = sum nu_i * ln(a_i) - ln(K)  (natural logs)\n    R = Dual(0.0, np.zeros(len(m), dtype=float))\n    for i in range(len(m)):\n        R = R + nu[i] * dual_log(a_dual[i])\n    R = R - np.log(K)\n\n    # Extract derivatives and values\n    d_a_i_dm_k1 = a_dual[i_target].deriv[k1]\n    d_a_i_dm_k2 = a_dual[i_target].deriv[k2]\n    dR_dm_k1 = R.deriv[k1]\n    R_val = R.value\n\n    return d_a_i_dm_k1, d_a_i_dm_k2, dR_dm_k1, R_val\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (names, z, m, nu, K, i_target, k1, k2)\n    test_cases = [\n        # Case 1: Na+, Cl-, NaCl0\n        ([\"Na+\", \"Cl-\", \"NaCl0\"], [1, -1, 0], [0.1, 0.1, 1e-8], [1, 1, -1], 0.78, 0, 0, 1),\n        # Case 2: H+, Cl-, HCl0 (very dilute)\n        ([\"H+\", \"Cl-\", \"HCl0\"], [1, -1, 0], [1e-6, 1e-6, 1e-12], [1, 1, -1], 1e-8, 0, 0, 1),\n        # Case 3: Ca2+, Cl-, CaCl2^0 (high ionic strength)\n        ([\"Ca2+\", \"Cl-\", \"CaCl20\"], [2, -1, 0], [0.5, 1.0, 1e-6], [1, 2, -1], 0.3, 0, 0, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        names, z, m, nu, K, i_target, k1, k2 = case\n        d_ai_dm_k1, d_ai_dm_k2, dR_dm_k1, R_val = compute_system_outputs(names, z, m, nu, K, i_target, k1, k2)\n        # Round to six decimal places as required\n        results.extend([\n            round(d_ai_dm_k1, 6),\n            round(d_ai_dm_k2, 6),\n            round(dR_dm_k1, 6),\n            round(R_val, 6),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}