{
    "hands_on_practices": [
        {
            "introduction": "Before a geochemical system can be solved numerically, we must be able to construct its Jacobian matrix. This practice exercise challenges you to derive a key component of the Jacobian by hand: the sensitivity of an ion's activity coefficient, $\\gamma_i$, to changes in species molality, $m_k$. This requires applying the chain rule through the ionic strength $I$ and the Davies equation, a fundamental skill for understanding how species interactions are captured within the Newton-Raphson framework .",
            "id": "4092033",
            "problem": "A Newton–Raphson method for solving nonlinear mass-action and mass-balance equations in aqueous geochemical systems requires Jacobian entries that involve the sensitivity of the activity coefficients to composition. Consider the Davies model for the activity coefficient of an ion, where the base-10 logarithm of the activity coefficient is given by\n$$\n\\log_{10}\\gamma_{i} = -A z_{i}^{2}\\left(\\frac{\\sqrt{I}}{1+\\sqrt{I}} - 0.3\\, I\\right),\n$$\nand the ionic strength is defined by\n$$\nI=\\frac{1}{2}\\sum_{j} m_{j} z_{j}^{2},\n$$\nwith $m_{j}$ the molality of species $j$, $z_{j}$ its charge number, and $A$ the Debye–Hückel constant (temperature-dependent). Using only these definitions and standard calculus, derive a closed-form analytic expression for the partial derivative\n$$\n\\frac{\\partial \\ln \\gamma_{i}}{\\partial m_{k}}\n$$\nin terms of $A$, $z_{i}$, $z_{k}$, and $I$. Your final answer must be a single simplified analytic expression. No numerical evaluation or rounding is required and no units should be included in the final answer.",
            "solution": "The problem is deemed valid as it is scientifically grounded in established physical chemistry models (Davies equation, ionic strength), is well-posed, objective, and contains all necessary information for a unique solution.\n\nThe objective is to derive a closed-form analytic expression for the partial derivative $\\frac{\\partial \\ln \\gamma_{i}}{\\partial m_{k}}$. The activity coefficient $\\gamma_i$ is given by the Davies model, and its value depends on the ionic strength $I$, which in turn depends on the molalities $m_j$ of all species in the system.\n\nFirst, we relate the given base-10 logarithm of the activity coefficient, $\\log_{10} \\gamma_i$, to the natural logarithm, $\\ln \\gamma_i$, using the change of base formula for logarithms: $\\ln x = \\ln(10) \\log_{10} x$. Applying this to $\\gamma_i$ gives:\n$$\n\\ln \\gamma_i = \\ln(10) \\log_{10} \\gamma_i\n$$\nSubstituting the Davies equation into this relationship yields:\n$$\n\\ln \\gamma_i = \\ln(10) \\left[ -A z_{i}^{2}\\left(\\frac{\\sqrt{I}}{1+\\sqrt{I}} - 0.3 I\\right) \\right]\n$$\n$$\n\\ln \\gamma_i = -A \\ln(10) z_{i}^{2}\\left(\\frac{\\sqrt{I}}{1+\\sqrt{I}} - 0.3 I\\right)\n$$\nWe need to find the partial derivative of $\\ln \\gamma_i$ with respect to the molality of a specific species $k$, denoted as $m_k$. Since $\\ln \\gamma_i$ is an explicit function of the ionic strength $I$, and $I$ is a function of all molalities $m_j$ (including $m_k$), we must apply the chain rule for partial differentiation:\n$$\n\\frac{\\partial \\ln \\gamma_i}{\\partial m_k} = \\frac{d(\\ln \\gamma_i)}{dI} \\frac{\\partial I}{\\partial m_k}\n$$\nWe will compute each term on the right-hand side separately.\n\nThe first term is the derivative of $\\ln \\gamma_i$ with respect to $I$. For clarity, let $C_i = -A \\ln(10) z_i^2$, which is constant with respect to $I$.\n$$\n\\frac{d(\\ln \\gamma_i)}{dI} = \\frac{d}{dI} \\left[ C_i \\left(\\frac{I^{1/2}}{1+I^{1/2}} - 0.3 I\\right) \\right] = C_i \\left[ \\frac{d}{dI}\\left(\\frac{I^{1/2}}{1+I^{1/2}}\\right) - \\frac{d}{dI}(0.3 I) \\right]\n$$\nWe evaluate the derivatives of the two terms inside the parentheses. The derivative of the second term is straightforward:\n$$\n\\frac{d}{dI}(0.3 I) = 0.3\n$$\nFor the first term, we use the quotient rule, where $u = I^{1/2}$ and $v = 1+I^{1/2}$. The derivatives with respect to $I$ are $u' = \\frac{1}{2}I^{-1/2}$ and $v' = \\frac{1}{2}I^{-1/2}$.\n$$\n\\frac{d}{dI}\\left(\\frac{I^{1/2}}{1+I^{1/2}}\\right) = \\frac{u'v - uv'}{v^2} = \\frac{(\\frac{1}{2}I^{-1/2})(1+I^{1/2}) - I^{1/2}(\\frac{1}{2}I^{-1/2})}{(1+I^{1/2})^2}\n$$\n$$\n= \\frac{\\frac{1}{2}I^{-1/2} + \\frac{1}{2} - \\frac{1}{2}}{(1+I^{1/2})^2} = \\frac{\\frac{1}{2}I^{-1/2}}{(1+I^{1/2})^2} = \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^2}\n$$\nCombining these results, we obtain the expression for $\\frac{d(\\ln \\gamma_i)}{dI}$:\n$$\n\\frac{d(\\ln \\gamma_i)}{dI} = -A \\ln(10) z_i^2 \\left( \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^2} - 0.3 \\right)\n$$\nThe second term required for the chain rule is the partial derivative of the ionic strength $I$ with respect to the molality $m_k$. The definition of ionic strength is:\n$$\nI = \\frac{1}{2}\\sum_{j} m_{j} z_{j}^{2}\n$$\nWe take the partial derivative with respect to $m_k$:\n$$\n\\frac{\\partial I}{\\partial m_k} = \\frac{\\partial}{\\partial m_k} \\left( \\frac{1}{2}\\sum_{j} m_{j} z_{j}^{2} \\right) = \\frac{1}{2}\\sum_{j} z_{j}^{2} \\frac{\\partial m_j}{\\partial m_k}\n$$\nThe partial derivative $\\frac{\\partial m_j}{\\partial m_k}$ is equal to $1$ if $j=k$ and $0$ if $j \\neq k$. This is the definition of the Kronecker delta, $\\delta_{jk}$. Therefore, only the term in the summation where $j=k$ is non-zero.\n$$\n\\frac{\\partial I}{\\partial m_k} = \\frac{1}{2}\\sum_{j} z_{j}^{2} \\delta_{jk} = \\frac{1}{2} z_k^2\n$$\nFinally, we multiply the two derived components to obtain the complete expression for $\\frac{\\partial \\ln \\gamma_i}{\\partial m_k}$:\n$$\n\\frac{\\partial \\ln \\gamma_i}{\\partial m_k} = \\left[ -A \\ln(10) z_i^2 \\left( \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^2} - 0.3 \\right) \\right] \\cdot \\left[ \\frac{1}{2} z_k^2 \\right]\n$$\nSimplifying this expression yields the final answer:\n$$\n\\frac{\\partial \\ln \\gamma_i}{\\partial m_k} = -\\frac{A \\ln(10) z_i^2 z_k^2}{2} \\left( \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^2} - 0.3 \\right)\n$$\nThis expression can be written with the negative sign absorbed into the parenthesis for a slightly different form:\n$$\n\\frac{\\partial \\ln \\gamma_i}{\\partial m_k} = \\frac{A \\ln(10) z_i^2 z_k^2}{2} \\left( 0.3 - \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^2} \\right)\n$$\nBoth forms are equivalent. We will provide the latter as the final answer.",
            "answer": "$$\\boxed{\\frac{A \\ln(10) z_{i}^{2} z_{k}^{2}}{2} \\left( 0.3 - \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^{2}} \\right)}$$"
        },
        {
            "introduction": "A correct analytical derivative is not sufficient; the robustness of the Newton-Raphson solver heavily depends on how the problem is formulated. This thought experiment explores the critical choice between using raw species molalities, $\\mathbf{m}$, and their logarithms, $\\mathbf{y} = \\ln \\mathbf{m}$, as the primary variables. You will analyze how this transformation impacts numerical stability, particularly regarding positivity constraints and the conditioning of the Jacobian matrix, which are crucial considerations for real-world solvers .",
            "id": "4091986",
            "problem": "Consider an aqueous complexation system at fixed temperature and pressure in which a divalent metal cation $M^{2+}$ and a monovalent ligand anion $L^{-}$ form the complex $ML^{+}$ via the reaction $M^{2+} + L^{-} \\rightleftharpoons ML^{+}$. Let the unknown species molalities be $\\mathbf{m} = (m_M, m_L, m_{ML})^{\\top}$, and let the total analytical molalities be $M_T$ and $L_T$. Activities are modeled as $a_i = \\gamma_i m_i$, where $\\gamma_i$ are activity coefficients that depend smoothly on ionic strength $I$ through a Davies-type formula, for example $\\log_{10}\\gamma_i = -A z_i^2\\left(\\frac{\\sqrt{I}}{1 + \\sqrt{I}} - 0.3\\, I\\right)$ with $z_i$ the stoichiometric charge of species $i$ and $A$ a solvent-dependent constant. The ionic strength is defined by $I = \\tfrac{1}{2}\\sum_i z_i^2 m_i$. The equilibrium constant $K$ for the reaction is defined by the mass action law $K = \\dfrac{a_{ML}}{a_M a_L}$ at equilibrium.\n\nA standard nonlinear residual for Newton-Raphson is constructed by enforcing mass balances and mass action at equilibrium. Using species molalities $\\mathbf{m}$, one possible residual vector is\n$$\n\\mathbf{R}(\\mathbf{m}) =\n\\begin{pmatrix}\nm_M + m_{ML} - M_T \\\\\nm_L + m_{ML} - L_T \\\\\n\\ln K - \\left(\\ln \\gamma_{ML} + \\ln m_{ML}\\right) + \\left(\\ln \\gamma_M + \\ln m_M\\right) + \\left(\\ln \\gamma_L + \\ln m_L\\right)\n\\end{pmatrix}.\n$$\nAn alternative formulation uses log-transformed variables $\\mathbf{y} = (y_M, y_L, y_{ML})^{\\top}$ with $y_i = \\ln m_i$ and defines a residual as the composition $\\mathbf{G}(\\mathbf{y}) = \\mathbf{R}(\\exp(\\mathbf{y}))$, where $\\exp(\\mathbf{y})$ denotes the componentwise exponential mapping from $\\mathbf{y}$ back to $\\mathbf{m}$.\n\nThe Newton-Raphson method linearizes these residuals using the Jacobian matrices and iteratively solves $J(\\mathbf{x}^{(k)})\\,\\Delta \\mathbf{x}^{(k)} = -\\mathbf{F}(\\mathbf{x}^{(k)})$ followed by $\\mathbf{x}^{(k+1)} = \\mathbf{x}^{(k)} + \\Delta \\mathbf{x}^{(k)}$, where $\\mathbf{F}$ is the residual and $J$ its Jacobian with respect to the chosen variables.\n\nFrom first principles, analyze the smoothness of the residuals and the numerical robustness of Newton-Raphson when using species molalities $\\mathbf{m}$ versus log-transformed variables $\\mathbf{y}$ for the complexation system described, taking into account:\n- The smooth dependence of $\\gamma_i$ on ionic strength $I$ and the definition $I = \\tfrac{1}{2}\\sum_i z_i^2 m_i$.\n- The positivity constraint $m_i > 0$ for all species $i$ in aqueous solutions.\n- The effect of variable scaling on the Jacobian and conditioning when species span multiple orders of magnitude.\n\nWhich of the following statements are correct? Select all that apply.\n\nA. Using variables $\\mathbf{y} = \\ln \\mathbf{m}$ ensures that the iterates $\\mathbf{m} = \\exp(\\mathbf{y})$ remain strictly positive, which reduces the need for safeguard strategies such as step clipping and typically improves robustness in highly dilute regimes.\n\nB. The Jacobian with respect to $\\mathbf{y}$ satisfies $J_{\\mathbf{y}}(\\mathbf{y}) = J_{\\mathbf{m}}(\\mathbf{m})\\,\\mathrm{diag}(\\mathbf{m})$ at $\\mathbf{m} = \\exp(\\mathbf{y})$; this column scaling tends to reduce conditioning disparities when species molalities vary over many orders of magnitude, often enhancing Newton-Raphson robustness.\n\nC. If the activity coefficients follow a Davies-type model, transforming to $\\mathbf{y} = \\ln \\mathbf{m}$ introduces non-differentiability at $m_i = 0$, which degrades smoothness and makes Newton-Raphson less reliable compared to working in $\\mathbf{m}$.\n\nD. Newton-Raphson is invariant under smooth reparameterizations such as $\\mathbf{y} = \\ln \\mathbf{m}$, so its convergence behavior is identical whether one solves in $\\mathbf{m}$ or in $\\mathbf{y}$.\n\nE. Working in $\\mathbf{y} = \\ln \\mathbf{m}$ universally eliminates ill-conditioning arising from complexation stoichiometry and guarantees rapid convergence regardless of the initial guess.\n\nProvide your choices and justify them based on fundamental definitions of ionic strength, activity, mass action, and Newton-Raphson linearization, without assuming any specialized solver tricks beyond these principles.",
            "solution": "The user wants me to validate the problem statement and, if valid, provide a detailed solution including an analysis of all options.\n\n**Problem Validation**\n\n**Step 1: Extract Givens**\n-   **System:** An aqueous complexation system at fixed temperature and pressure.\n-   **Reaction:** $M^{2+} + L^{-} \\rightleftharpoons ML^{+}$.\n-   **Unknowns:** A vector of species molalities, $\\mathbf{m} = (m_M, m_L, m_{ML})^{\\top}$.\n-   **Constants:** Total analytical molalities $M_T$ and $L_T$. Equilibrium constant $K$.\n-   **Species Charges:** $z_M = +2$, $z_L = -1$, $z_{ML} = +1$.\n-   **Activity Model:** $a_i = \\gamma_i m_i$. Activity coefficients $\\gamma_i$ depend smoothly on ionic strength $I$.\n-   **Ionic Strength:** $I = \\tfrac{1}{2}\\sum_i z_i^2 m_i$.\n-   **Activity Coefficient Formula Example:** Davies-type, $\\log_{10}\\gamma_i = -A z_i^2\\left(\\frac{\\sqrt{I}}{1 + \\sqrt{I}} - 0.3\\, I\\right)$.\n-   **Mass Action Law:** $K = \\dfrac{a_{ML}}{a_M a_L}$.\n-   **Residual in m-space:**\n    $$\n    \\mathbf{R}(\\mathbf{m}) =\n    \\begin{pmatrix}\n    m_M + m_{ML} - M_T \\\\\n    m_L + m_{ML} - L_T \\\\\n    \\ln K - \\left(\\ln \\gamma_{ML} + \\ln m_{ML}\\right) + \\left(\\ln \\gamma_M + \\ln m_M\\right) + \\left(\\ln \\gamma_L + \\ln m_L\\right)\n    \\end{pmatrix}\n    $$\n-   **Transformation to y-space:** $\\mathbf{y} = (y_M, y_L, y_{ML})^{\\top}$ with $y_i = \\ln m_i$.\n-   **Residual in y-space:** $\\mathbf{G}(\\mathbf{y}) = \\mathbf{R}(\\exp(\\mathbf{y}))$.\n-   **Numerical Method:** Newton-Raphson, defined by the iterative system $J(\\mathbf{x}^{(k)})\\,\\Delta \\mathbf{x}^{(k)} = -\\mathbf{F}(\\mathbf{x}^{(k)})$ and update $\\mathbf{x}^{(k+1)} = \\mathbf{x}^{(k)} + \\Delta \\mathbf{x}^{(k)}$.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientifically Grounded:** The problem describes a standard chemical equilibrium calculation, a cornerstone of aqueous geochemistry. All provided equations—mass balance, mass action, ionic strength, and the Davies model for activity coefficients—are fundamental principles and standard models in the field. The setup is scientifically and factually sound.\n-   **Well-Posed:** The problem is a request to analyze and compare two different numerical formulations for solving a well-defined system of nonlinear equations. For given positive total concentrations $M_T$ and $L_T$, a unique positive solution for the species molalities $\\mathbf{m}$ is expected to exist. The question itself is well-posed, asking for a comparative analysis of numerical properties.\n-   **Objective:** The problem is phrased in precise, mathematical language. It asks for an analysis based on first principles of numerical methods and chemical thermodynamics, avoiding any subjectivity.\n\nUpon review, the problem statement exhibits none of the invalidity flaws. It is scientifically sound, well-posed, objective, complete, and poses a meaningful, non-trivial question in computational geochemistry.\n\n**Step 3: Verdict and Action**\nThe problem is valid. I will proceed with the solution derivation and option analysis.\n\n**Principle-Based Derivation and Solution**\n\nThe core of the problem is to compare the numerical properties of the Newton-Raphson method applied to a system of equations expressed in terms of two different sets of variables: the species molalities $\\mathbf{m}$ and their logarithms $\\mathbf{y} = \\ln \\mathbf{m}$.\n\n**1. Positivity Constraint and Domain**\nChemical molalities, $m_i$, must be strictly positive. This imposes the constraint $m_i > 0$ for all $i$.\n-   **Formulation in $\\mathbf{m}$:** The independent variables are $\\mathbf{m}$ themselves. The Newton-Raphson update is $\\mathbf{m}^{(k+1)} = \\mathbf{m}^{(k)} + \\Delta \\mathbf{m}^{(k)}$. There is no inherent mechanism in this update to enforce the positivity constraint $m_i^{(k+1)} > 0$. If an iterate $\\mathbf{m}^{(k)}$ is near the boundary of the feasible domain (i.e., some $m_i$ is very small), a full Newton step $\\Delta \\mathbf{m}^{(k)}$ can easily result in a negative, non-physical value for $m_i^{(k+1)}$. This would cause the algorithm to fail, as terms like $\\ln m_i$ in the residual $\\mathbf{R}(\\mathbf{m})$ would become undefined. To prevent this, solvers using this formulation must implement safeguards, such as line-search algorithms (i.e., taking a shorter step $\\alpha \\Delta \\mathbf{m}^{(k)}$ with $0 < \\alpha < 1$) or clipping negative values, which can compromise the convergence rate and robustness.\n-   **Formulation in $\\mathbf{y} = \\ln \\mathbf{m}$:** The independent variables are $\\mathbf{y}$. The domain for $\\mathbf{y}$ is $\\mathbb{R}^3$, which is unconstrained. The molalities are recovered via the component-wise transformation $\\mathbf{m} = \\exp(\\mathbf{y})$, i.e., $m_i = e^{y_i}$. Since the exponential function $e^x$ is strictly positive for any real $x$, any iterate $\\mathbf{y}^{(k+1)}$ in $\\mathbb{R}^3$ will produce a vector of molalities $\\mathbf{m}^{(k+1)}$ where every component is strictly positive. This variable transformation elegantly and automatically satisfies the positivity constraint without any additional logic, thereby enhancing the stability and robustness of the algorithm.\n\n**2. Jacobian and Conditioning**\nThe relationship between the Jacobians of the two systems is found using the multivariate chain rule. Let $\\mathbf{m}(\\mathbf{y}) = \\exp(\\mathbf{y})$. The residual in y-space is $\\mathbf{G}(\\mathbf{y}) = \\mathbf{R}(\\mathbf{m}(\\mathbf{y}))$.\nThe Jacobian of $\\mathbf{G}$ with respect to $\\mathbf{y}$ is:\n$$ J_{\\mathbf{y}} = \\frac{\\partial \\mathbf{G}}{\\partial \\mathbf{y}} = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{m}} \\frac{\\partial \\mathbf{m}}{\\partial \\mathbf{y}} $$\nLet $J_{\\mathbf{m}} = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{m}}$. The Jacobian of the transformation is a diagonal matrix:\n$$ \\frac{\\partial \\mathbf{m}}{\\partial \\mathbf{y}} = \\mathrm{diag}\\left(\\frac{\\partial e^{y_M}}{\\partial y_M}, \\frac{\\partial e^{y_L}}{\\partial y_L}, \\frac{\\partial e^{y_{ML}}}{\\partial y_{ML}}\\right) = \\mathrm{diag}(e^{y_M}, e^{y_L}, e^{y_{ML}}) = \\mathrm{diag}(m_M, m_L, m_{ML}) = \\mathrm{diag}(\\mathbf{m}) $$\nThus, we have the relationship $J_{\\mathbf{y}} = J_{\\mathbf{m}}\\,\\mathrm{diag}(\\mathbf{m})$. This means the columns of $J_{\\mathbf{y}}$ are the columns of $J_{\\mathbf{m}}$ scaled by the corresponding molalities.\n\nLet's examine the structure of $J_{\\mathbf{m}} = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{m}}$.\nThe first two rows corresponding to mass balances are simple:\n$\\frac{\\partial R_1}{\\partial m_M}=1$, $\\frac{\\partial R_1}{\\partial m_L}=0$, $\\frac{\\partial R_1}{\\partial m_{ML}}=1$.\n$\\frac{\\partial R_2}{\\partial m_M}=0$, $\\frac{\\partial R_2}{\\partial m_L}=1$, $\\frac{\\partial R_2}{\\partial m_{ML}}=1$.\nThe third row, from the mass action law, is more complex. Let's rewrite $R_3$ as $\\ln\\left(\\frac{a_M a_L}{a_{ML}}\\right) - \\ln K = 0$.\n$$ R_3 = (\\ln m_M + \\ln \\gamma_M) + (\\ln m_L + \\ln \\gamma_L) - (\\ln m_{ML} + \\ln \\gamma_{ML}) - \\ln K $$\nThe partial derivatives are of the form $\\frac{\\partial R_3}{\\partial m_j}$. For instance, with respect to $m_M$:\n$$ \\frac{\\partial R_3}{\\partial m_M} = \\frac{1}{m_M} + \\frac{\\partial(\\ln \\gamma_M)}{\\partial m_M} + \\frac{\\partial(\\ln \\gamma_L)}{\\partial m_M} - \\frac{\\partial(\\ln \\gamma_{ML})}{\\partial m_M} $$\nThe activity coefficient terms $\\frac{\\partial(\\ln \\gamma_i)}{\\partial m_M} = \\frac{1}{\\gamma_i} \\frac{\\partial \\gamma_i}{\\partial I} \\frac{\\partial I}{\\partial m_M}$ are generally well-behaved. However, the term $\\frac{1}{m_M}$ becomes very large as $m_M \\to 0$. In geochemical systems, concentrations can span many orders of magnitude (e.g., $10^{-2}$ to $10^{-12}$ molal). If $m_M$ is a trace species, the entry $(\\frac{\\partial R_3}{\\partial m_M})$ can be enormous, while the other entries in the first column of $J_{\\mathbf{m}}$ are of order $1$. This leads to a Jacobian matrix with columns of vastly different scales, which is often a source of ill-conditioning. An ill-conditioned matrix amplifies numerical errors during the linear solve step $J\\,\\Delta \\mathbf{x} = -\\mathbf{F}$.\n\nNow consider the corresponding column in $J_{\\mathbf{y}}$. The first column of $J_{\\mathbf{y}}$ is the first column of $J_{\\mathbf{m}}$ scaled by $m_M$.\nThe $(3,1)$ entry of $J_{\\mathbf{y}}$ is $m_M \\frac{\\partial R_3}{\\partial m_M} = m_M \\left( \\frac{1}{m_M} + \\dots \\right) = 1 + m_M(\\dots)$.\nThe problematic $\\frac{1}{m_M}$ term is neutralized. The log transformation has the effect of scaling the columns of the Jacobian, which balances their norms and typically leads to a much better-conditioned matrix. This improves the numerical stability and robustness of the Newton-Raphson method.\n\n**3. Invariance**\nNewton's method is not invariant under general nonlinear reparameterizations. An affine transformation $\\mathbf{x}'=A\\mathbf{x}+b$ preserves the Newton iterates (i.e., the new iterates are just the transformed old iterates), but a nonlinear one like $\\mathbf{y} = \\ln \\mathbf{m}$ does not. The sequence of iterates $\\{\\mathbf{y}^{(k)}\\}$ generates a sequence $\\{\\mathbf{m}^{(k)} = \\exp(\\mathbf{y}^{(k)})\\}$ that traces a different path through the solution space than the sequence generated by solving in $\\mathbf{m}$ directly. As shown above, these paths have very different numerical properties.\n\n**Option-by-Option Analysis**\n\n**A. Using variables $\\mathbf{y} = \\ln \\mathbf{m}$ ensures that the iterates $\\mathbf{m} = \\exp(\\mathbf{y})$ remain strictly positive, which reduces the need for safeguard strategies such as step clipping and typically improves robustness in highly dilute regimes.**\nThis statement is consistent with our analysis in point 1. The transformation $\\mathbf{m} = \\exp(\\mathbf{y})$ inherently respects the positivity constraint. This is a primary reason for its use, as it avoids the complexities and potential convergence issues of imposing this constraint manually on the untransformed problem, particularly when concentrations are small.\n**Verdict: Correct.**\n\n**B. The Jacobian with respect to $\\mathbf{y}$ satisfies $J_{\\mathbf{y}}(\\mathbf{y}) = J_{\\mathbf{m}}(\\mathbf{m})\\,\\mathrm{diag}(\\mathbf{m})$ at $\\mathbf{m} = \\exp(\\mathbf{y})$; this column scaling tends to reduce conditioning disparities when species molalities vary over many orders of magnitude, often enhancing Newton-Raphson robustness.**\nThis statement is consistent with our analysis in point 2. The mathematical relationship between the Jacobians is correctly stated. The effect of this column scaling is precisely to counteract the ill-conditioning caused by terms like $1/m_j$ in the Jacobian $J_{\\mathbf{m}}$, which arise from the mass action law. This preconditioning-like effect improves numerical robustness, especially for systems with a wide range of concentrations.\n**Verdict: Correct.**\n\n**C. If the activity coefficients follow a Davies-type model, transforming to $\\mathbf{y} = \\ln \\mathbf{m}$ introduces non-differentiability at $m_i = 0$, which degrades smoothness and makes Newton-Raphson less reliable compared to working in $\\mathbf{m}$.**\nThis statement misattributes the source of the smoothness problem. The non-differentiability (due to $\\ln m_i$ and the $\\sqrt{I}$ in the Davies model) exists at the boundary $m_i=0$ of the *untransformed* problem domain. The transformation to $\\mathbf{y}$-space maps the entire unconstrained space $\\mathbb{R}^3$ to the strictly positive part of the $\\mathbf{m}$-space, effectively removing the boundary from consideration. The transformed residual $\\mathbf{G}(\\mathbf{y})$ is a smooth function for all $\\mathbf{y} \\in \\mathbb{R}^3$. The transformation thus *improves* the smoothness properties from the perspective of the solver by working in an unconstrained domain where the function is everywhere smooth.\n**Verdict: Incorrect.**\n\n**D. Newton-Raphson is invariant under smooth reparameterizations such as $\\mathbf{y} = \\ln \\mathbf{m}$, so its convergence behavior is identical whether one solves in $\\mathbf{m}$ or in $\\mathbf{y}$.**\nThis statement is false. As discussed in point 3, Newton's method is not invariant under nonlinear reparameterizations. The very fact that options A and B describe significant improvements in robustness proves that the convergence behavior is not identical. The transformation alters the geometry of the search space and the nature of the steps taken, leading to different sequences of iterates and different convergence properties.\n**Verdict: Incorrect.**\n\n**E. Working in $\\mathbf{y} = \\ln \\mathbf{m}$ universally eliminates ill-conditioning arising from complexation stoichiometry and guarantees rapid convergence regardless of the initial guess.**\nThis statement uses absolute and overly strong language. \"Universally eliminates\" is too strong; while the log transform significantly improves conditioning from one common source, it may not fix all possible sources of ill-conditioning. \"Guarantees rapid convergence regardless of the initial guess\" is false. Newton's method is a local-convergence method. Its success and speed depend on starting sufficiently close to the solution. While the log transform often enlarges the basin of attraction (the set of \"good\" initial guesses), it does not make it infinite. A sufficiently poor initial guess can still lead to divergence.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{AB}$$"
        },
        {
            "introduction": "Manually deriving the full Jacobian for a complex geochemical system is tedious and error-prone. Modern solvers automate this process using techniques like automatic differentiation (AD), which calculates exact derivatives numerically. This coding exercise guides you through implementing a simple forward-mode AD engine to compute the same derivatives you previously considered analytically, bridging the gap between theory and practical, robust implementation .",
            "id": "4092063",
            "problem": "You are asked to implement a forward-mode automatic differentiation engine, using dual numbers, to compute derivatives required by Newton-Raphson updates in a geochemical equilibrium system governed by mass-action laws with activity coefficients. The system must be defined in terms of fundamental geochemical definitions and mass-action relationships and must produce numerically testable outputs.\n\nThe fundamental base for this task comprises the following widely accepted definitions and laws in computational geochemistry:\n- The activity of an aqueous species $i$ is defined as $a_i = \\gamma_i m_i$, where $m_i$ is molality (in mol/kg of water) and $\\gamma_i$ is the activity coefficient (dimensionless).\n- The ionic strength $I$ of an aqueous solution is defined as $I = \\frac{1}{2}\\sum_i m_i z_i^2$, where $z_i$ is the charge number of species $i$.\n- The Davies equation at $25\\,^{\\circ}\\mathrm{C}$ expresses the base-10 logarithm of the activity coefficient for charged species as\n$$\\log_{10} \\gamma_i = -A z_i^2 \\left(\\frac{\\sqrt{I}}{1 + \\sqrt{I}} - 0.3 I\\right),$$\nwhere $A = 0.509$ is the Debye-Hückel constant at $25\\,^{\\circ}\\mathrm{C}$. Neutral species have $z_i=0$ and thus $\\gamma_i = 1$.\n- A general mass-action residual for a reaction $r$ with stoichiometric coefficients $\\nu_{r,i}$ and equilibrium constant $K_r$ is defined as:\n$$R_r(\\mathbf{m}) = \\sum_i \\nu_{r,i} \\ln a_i - \\ln K_r,$$\nwhich equals $0$ at equilibrium.\n\nYour program must:\n1. Implement a forward-mode automatic differentiation framework using dual numbers to propagate derivatives $\\frac{\\partial}{\\partial m_k}$ through all computations.\n2. Compute $I(\\mathbf{m})$, $\\gamma_i(I)$ via the Davies equation, and $a_i(\\mathbf{m}) = \\gamma_i m_i$ for each system.\n3. Using automatic differentiation, compute and return values of $\\frac{\\partial a_i}{\\partial m_k}$ and $\\frac{\\partial R_r}{\\partial m_k}$ for specified indices $(i,k)$ in each test case, without manually coding derivative formulas.\n\nThe three required test cases are defined below, each with species list, charge numbers $z_i$, molalities $m_i$ (in mol/kg), a single reaction with stoichiometric coefficients $\\nu_{r,i}$, and an equilibrium constant $K_r$ (dimensionless). For each case, the program must compute the following outputs in order: $\\frac{\\partial a_{i^\\ast}}{\\partial m_{k_1}}$, $\\frac{\\partial a_{i^\\ast}}{\\partial m_{k_2}}$, $\\frac{\\partial R_r}{\\partial m_{k_1}}$, and $R_r$.\n\nCase $1$ (moderate ionic strength, sodium chloride with a neutral ion pair):\n- Species: $\\text{Na}^+$, $\\text{Cl}^-$, $\\text{NaCl}^0$.\n- Charges: $z = [1, -1, 0]$.\n- Molalities: $m = [0.1, 0.1, 10^{-8}]$ (mol/kg).\n- Reaction: $\\text{NaCl}^0 \\rightleftharpoons \\text{Na}^+ + \\text{Cl}^-$ with stoichiometry $\\nu = [1, 1, -1]$ and $K = 0.78$.\n- Output targets: $i^\\ast$ refers to $\\text{Na}^+$ (index $0$), $k_1 = \\text{Na}^+$ (index $0$), $k_2 = \\text{Cl}^-$ (index $1$).\n\nCase $2$ (very dilute hydrochloric acid):\n- Species: $\\text{H}^+$, $\\text{Cl}^-$, $\\text{HCl}^0$.\n- Charges: $z = [1, -1, 0]$.\n- Molalities: $m = [10^{-6}, 10^{-6}, 10^{-12}]$ (mol/kg).\n- Reaction: $\\text{HCl}^0 \\rightleftharpoons \\text{H}^+ + \\text{Cl}^-$ with stoichiometry $\\nu = [1, 1, -1]$ and $K = 10^{-8}$.\n- Output targets: $i^\\ast$ refers to $\\text{H}^+$ (index $0$), $k_1 = \\text{H}^+$ (index $0$), $k_2 = \\text{Cl}^-$ (index $1$).\n\nCase $3$ (high ionic strength calcium chloride with a neutral complex):\n- Species: $\\text{Ca}^{2+}$, $\\text{Cl}^-$, $\\text{CaCl}_2^0$.\n- Charges: $z = [2, -1, 0]$.\n- Molalities: $m = [0.5, 1.0, 10^{-6}]$ (mol/kg).\n- Reaction: $\\text{CaCl}_2^0 \\rightleftharpoons \\text{Ca}^{2+} + 2\\,\\text{Cl}^-$ with stoichiometry $\\nu = [1, 2, -1]$ and $K = 0.3$.\n- Output targets: $i^\\ast$ refers to $\\text{Ca}^{2+}$ (index $0$), $k_1 = \\text{Ca}^{2+}$ (index $0$), $k_2 = \\text{Cl}^-$ (index $1$).\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n- Case $1$: $\\left[\\frac{\\partial a_{\\text{Na}^+}}{\\partial m_{\\text{Na}^+}}, \\frac{\\partial a_{\\text{Na}^+}}{\\partial m_{\\text{Cl}^-}}, \\frac{\\partial R}{\\partial m_{\\text{Na}^+}}, R\\right]$.\n- Case $2$: $\\left[\\frac{\\partial a_{\\text{H}^+}}{\\partial m_{\\text{H}^+}}, \\frac{\\partial a_{\\text{H}^+}}{\\partial m_{\\text{Cl}^-}}, \\frac{\\partial R}{\\partial m_{\\text{H}^+}}, R\\right]$.\n- Case $3$: $\\left[\\frac{\\partial a_{\\text{Ca}^{2+}}}{\\partial m_{\\text{Ca}^{2+}}}, \\frac{\\partial a_{\\text{Ca}^{2+}}}{\\partial m_{\\text{Cl}^-}}, \\frac{\\partial R}{\\partial m_{\\text{Ca}^{2+}}}, R\\right]$.\n\nConcatenate all twelve numbers into a single list and round each to six decimal places. For example, the program must print:\n$$\\left[\\text{c}_{1,1}, \\text{c}_{1,2}, \\text{c}_{1,3}, \\text{c}_{1,4}, \\text{c}_{2,1}, \\ldots, \\text{c}_{3,4}\\right],$$\nwhere $\\text{c}_{i,j}$ are the computed floats rounded to six decimal places.\n\nNo external input is allowed. The activities and residuals are dimensionless; molalities must be treated in $\\mathrm{mol}/\\mathrm{kg}$ as specified, and all logarithms in the mass-action residual must be natural logarithms. Ensure scientific realism by using strictly positive molalities for all species.",
            "solution": "The system to be implemented relies on the chain rule applied to geochemical activity models and mass-action residuals, expressed through forward-mode automatic differentiation. The Newton-Raphson method for geochemical systems requires the Jacobian of the residual vector with respect to independent variables, which in this context are species molalities. We show how to obtain these derivatives automatically by embedding derivative propagation in the arithmetic via dual numbers.\n\nWe start with the definitions. For species $i$, the activity is $a_i = \\gamma_i m_i$, where $m_i$ is molality and $\\gamma_i$ is the activity coefficient. The residual for a single reaction $r$ with stoichiometric coefficients $\\nu_{r,i}$ and equilibrium constant $K_r$ is\n$$ R_r(\\mathbf{m}) = \\sum_i \\nu_{r,i} \\ln a_i - \\ln K_r. $$\nThe ionic strength is\n$$ I(\\mathbf{m}) = \\frac{1}{2}\\sum_i m_i z_i^2. $$\nThe Davies equation for the base-10 logarithm of the activity coefficient is\n$$ \\log_{10} \\gamma_i = -A z_i^2 \\left(\\frac{\\sqrt{I}}{1 + \\sqrt{I}} - 0.3 I\\right), $$\nwith $A = 0.509$. Converting to natural logarithm, we have\n$$ \\ln \\gamma_i = \\ln(10)\\, \\log_{10} \\gamma_i = -\\ln(10)\\,A z_i^2 \\left(\\frac{\\sqrt{I}}{1 + \\sqrt{I}} - 0.3 I\\right). $$\nTherefore, $\\gamma_i = \\exp(\\ln \\gamma_i)$, and the activities are $a_i = \\gamma_i m_i$.\n\nTo compute $\\frac{\\partial a_i}{\\partial m_k}$, we apply the product rule:\n$$ \\frac{\\partial a_i}{\\partial m_k} = \\frac{\\partial}{\\partial m_k}\\left(\\gamma_i m_i\\right) = \\gamma_i \\delta_{ik} + m_i \\frac{\\partial \\gamma_i}{\\partial m_k}, $$\nwhere $\\delta_{ik}$ is the Kronecker delta and $\\frac{\\partial \\gamma_i}{\\partial m_k}$ is obtained via the chain rule through $I(\\mathbf{m})$. Specifically,\n$$ \\frac{\\partial \\gamma_i}{\\partial m_k} = \\gamma_i \\frac{\\partial \\ln \\gamma_i}{\\partial m_k}, $$\nand\n$$ \\frac{\\partial \\ln \\gamma_i}{\\partial m_k} = -\\ln(10)\\,A z_i^2 \\left( \\frac{\\partial}{\\partial m_k}\\left(\\frac{\\sqrt{I}}{1+\\sqrt{I}}\\right) - 0.3 \\frac{\\partial I}{\\partial m_k} \\right). $$\nThe derivative of $I$ is\n$$ \\frac{\\partial I}{\\partial m_k} = \\frac{1}{2} z_k^2. $$\nLet $s = \\sqrt{I}$; then\n$$ \\frac{\\partial}{\\partial m_k}\\left(\\frac{s}{1+s}\\right) = \\frac{(1+s)\\frac{\\partial s}{\\partial m_k} - s \\frac{\\partial s}{\\partial m_k}}{(1+s)^2} = \\frac{\\frac{\\partial s}{\\partial m_k}}{(1+s)^2}. $$\nSince $s = I^{1/2}$, we have\n$$ \\frac{\\partial s}{\\partial m_k} = \\frac{1}{2} I^{-1/2} \\frac{\\partial I}{\\partial m_k} = \\frac{z_k^2}{4 \\sqrt{I}}. $$\nPutting this together yields an explicit formula, but our objective is to avoid coding these derivatives explicitly and instead implement forward-mode automatic differentiation. In forward-mode automatic differentiation, each $m_k$ is represented as a dual number $M_k = m_k + \\varepsilon \\,\\frac{\\partial}{\\partial m_k}$, and every arithmetic operation is overloaded to propagate both the primal value and the derivative vector. For multiple variables, the derivative part is a vector in $\\mathbb{R}^n$, with a seed vector equal to the standard basis $e_k$ for the variable $m_k$.\n\nThe implementation steps are:\n1. Represent each molality $m_i$ as a dual number with primal value $m_i$ and derivative vector equal to the $i$-th standard basis vector.\n2. Compute $I(\\mathbf{m}) = \\frac{1}{2} \\sum_i m_i z_i^2$ using dual arithmetic; this yields both $I$ and $\\nabla I$.\n3. Compute $s = \\sqrt{I}$ via dual $\\sqrt{\\cdot}$.\n4. Compute the Davies term $t = \\frac{s}{1+s} - 0.3 I$ via dual arithmetic.\n5. Compute $\\ln \\gamma_i = -\\ln(10)\\,A z_i^2 \\, t$ and then $\\gamma_i = \\exp(\\ln \\gamma_i)$ via dual $\\exp$.\n6. Compute $a_i = \\gamma_i \\, m_i$ via dual multiplication.\n7. Compute the residual $R_r(\\mathbf{m}) = \\sum_i \\nu_{r,i} \\ln a_i - \\ln K_r$ via dual $\\ln$.\n8. Extract derivative components from the derivative vectors of $a_i$ and $R_r$ corresponding to targeted indices $k$.\n\nBecause dual arithmetic enforces the chain rule automatically, the derivatives $\\frac{\\partial a_i}{\\partial m_k}$ and $\\frac{\\partial R_r}{\\partial m_k}$ are obtained without writing the explicit analytic derivatives, ensuring correct and stable propagation even through nested functions like $\\sqrt{\\cdot}$ and $\\exp(\\cdot)$.\n\nThe test suite comprises three scenarios:\n- Case $1$ checks moderate ionic strength with monovalent ions, evaluating self- and cross-sensitivities and the mass-action residual with a neutral complex; this tests the typical \"happy path.\"\n- Case $2$ checks behavior near the dilute limit, where $\\gamma_i \\approx 1$ but the chain rule through $\\sqrt{I}$ can be sensitive; this serves as an edge case avoiding zero ionic strength by using strictly positive molalities.\n- Case $3$ checks high ionic strength and multivalent ions, where activity coefficient nonlinearity is significant; this stresses derivative propagation in nonlinear regimes.\n\nThe final program outputs a single line with twelve numbers (four per case) as a comma-separated list enclosed in square brackets, with each float rounded to six decimal places, in the order specified in the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Forward-mode automatic differentiation using dual numbers with vector derivatives.\nclass Dual:\n    def __init__(self, value: float, deriv: np.ndarray):\n        self.value = float(value)\n        # Ensure derivative is a 1-D numpy array of floats\n        self.deriv = np.array(deriv, dtype=float)\n\n    def __add__(self, other):\n        other = to_dual(other, self.deriv.size)\n        return Dual(self.value + other.value, self.deriv + other.deriv)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        other = to_dual(other, self.deriv.size)\n        return Dual(self.value - other.value, self.deriv - other.deriv)\n\n    def __rsub__(self, other):\n        other = to_dual(other, self.deriv.size)\n        return Dual(other.value - self.value, other.deriv - self.deriv)\n\n    def __mul__(self, other):\n        other = to_dual(other, self.deriv.size)\n        # Product rule: d(u*v) = u' * v + u * v'\n        return Dual(self.value * other.value, self.deriv * other.value + self.value * other.deriv)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __truediv__(self, other):\n        other = to_dual(other, self.deriv.size)\n        # Quotient rule: d(u/v) = (u' * v - u * v') / v^2\n        denom = other.value * other.value\n        return Dual(self.value / other.value, (self.deriv * other.value - self.value * other.deriv) / denom)\n\n    def __rtruediv__(self, other):\n        other = to_dual(other, self.deriv.size)\n        # other / self\n        denom = self.value * self.value\n        return Dual(other.value / self.value, (other.deriv * self.value - other.value * self.deriv) / denom)\n\n    def __pow__(self, power):\n        # Only support scalar power for simplicity\n        if isinstance(power, (int, float)):\n            if self.value <= 0 and power != int(power):\n                raise ValueError(\"Dual power with non-integer exponent requires positive base.\")\n            val = self.value ** power\n            # d(x^p) = p * x^(p-1) dx\n            coeff = power * (self.value ** (power - 1)) if self.value != 0 else 0.0\n            return Dual(val, coeff * self.deriv)\n        else:\n            raise NotImplementedError(\"Power with Dual exponent not implemented.\")\n\ndef to_dual(x, nvars):\n    if isinstance(x, Dual):\n        return x\n    else:\n        return Dual(float(x), np.zeros(nvars, dtype=float))\n\ndef dual_sqrt(x: Dual) -> Dual:\n    if x.value <= 0.0:\n        # For geochemical ionic strength I, we expect strictly positive due to positive molalities.\n        # If extremely small, numerical safety: use tiny positive epsilon\n        eps = 1e-30\n        val = np.sqrt(x.value + eps)\n        deriv = (0.5 / val) * x.deriv\n        return Dual(val, deriv)\n    val = np.sqrt(x.value)\n    deriv = (0.5 / val) * x.deriv\n    return Dual(val, deriv)\n\ndef dual_log(x: Dual) -> Dual:\n    if x.value <= 0.0:\n        raise ValueError(\"Log of non-positive Dual value encountered.\")\n    return Dual(np.log(x.value), x.deriv / x.value)\n\ndef dual_exp(x: Dual) -> Dual:\n    val = np.exp(x.value)\n    return Dual(val, val * x.deriv)\n\ndef make_dual_vars(m_values):\n    n = len(m_values)\n    vars_dual = []\n    for i, mv in enumerate(m_values):\n        deriv = np.zeros(n, dtype=float)\n        deriv[i] = 1.0\n        vars_dual.append(Dual(float(mv), deriv))\n    return vars_dual\n\ndef davies_gamma_dual(z_list, m_dual_list, A=0.509):\n    \"\"\"\n    Compute gamma_i for all species using Davies equation via dual arithmetic.\n    Returns list of Dual gamma_i.\n    \"\"\"\n    n = len(m_dual_list)\n    # Ionic strength I = 0.5 * sum(m_i * z_i^2)\n    I = Dual(0.0, np.zeros(n, dtype=float))\n    for mi, zi in zip(m_dual_list, z_list):\n        I = I + mi * (zi * zi * 1.0)\n\n    I = I * 0.5\n    s = dual_sqrt(I)\n    # term = s/(1+s) - 0.3 * I\n    term = s / (1.0 + s) - I * 0.3\n    # ln(gamma_i) = ln(10) * log10(gamma_i) = -ln(10) * A * z_i^2 * term\n    ln10 = np.log(10.0)\n    gammas = []\n    for zi in z_list:\n        if zi == 0:\n            # Neutral species: gamma = 1.0 exactly\n            gammas.append(Dual(1.0, np.zeros(n, dtype=float)))\n        else:\n            ln_gamma_i = (-ln10 * A * (zi * zi)) * term\n            gamma_i = dual_exp(ln_gamma_i)\n            gammas.append(gamma_i)\n    return gammas\n\ndef compute_system_outputs(names, z, m, nu, K, i_target, k1, k2):\n    \"\"\"\n    For a given system, compute:\n    d a_i_target / d m_{k1}, d a_i_target / d m_{k2}, dR/dm_{k1}, R\n    \"\"\"\n    # Create dual variables for molalities\n    m_dual = make_dual_vars(m)\n    # Compute gamma_i via Davies\n    gamma_dual = davies_gamma_dual(z, m_dual, A=0.509)\n    # Activities a_i = gamma_i * m_i\n    a_dual = [gamma_dual[i] * m_dual[i] for i in range(len(m))]\n    # Residual R = sum nu_i * ln(a_i) - ln(K)  (natural logs)\n    R = Dual(0.0, np.zeros(len(m), dtype=float))\n    for i in range(len(m)):\n        R = R + nu[i] * dual_log(a_dual[i])\n    R = R - np.log(K)\n\n    # Extract derivatives and values\n    d_a_i_dm_k1 = a_dual[i_target].deriv[k1]\n    d_a_i_dm_k2 = a_dual[i_target].deriv[k2]\n    dR_dm_k1 = R.deriv[k1]\n    R_val = R.value\n\n    return d_a_i_dm_k1, d_a_i_dm_k2, dR_dm_k1, R_val\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (names, z, m, nu, K, i_target, k1, k2)\n    test_cases = [\n        # Case 1: Na+, Cl-, NaCl0\n        ([\"Na+\", \"Cl-\", \"NaCl0\"], [1, -1, 0], [0.1, 0.1, 1e-8], [1, 1, -1], 0.78, 0, 0, 1),\n        # Case 2: H+, Cl-, HCl0 (very dilute)\n        ([\"H+\", \"Cl-\", \"HCl0\"], [1, -1, 0], [1e-6, 1e-6, 1e-12], [1, 1, -1], 1e-8, 0, 0, 1),\n        # Case 3: Ca2+, Cl-, CaCl2^0 (high ionic strength)\n        ([\"Ca2+\", \"Cl-\", \"CaCl20\"], [2, -1, 0], [0.5, 1.0, 1e-6], [1, 2, -1], 0.3, 0, 0, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        names, z, m, nu, K, i_target, k1, k2 = case\n        d_ai_dm_k1, d_ai_dm_k2, dR_dm_k1, R_val = compute_system_outputs(names, z, m, nu, K, i_target, k1, k2)\n        # Round to six decimal places as required\n        results.extend([\n            round(d_ai_dm_k1, 6),\n            round(d_ai_dm_k2, 6),\n            round(dR_dm_k1, 6),\n            round(R_val, 6),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}