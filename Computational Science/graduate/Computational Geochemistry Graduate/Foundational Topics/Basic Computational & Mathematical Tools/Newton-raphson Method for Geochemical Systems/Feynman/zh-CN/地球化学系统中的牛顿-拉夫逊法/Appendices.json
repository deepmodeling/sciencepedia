{
    "hands_on_practices": [
        {
            "introduction": "牛顿-拉夫逊方法的核心在于雅可比矩阵，它包含了每个方程对每个变量的敏感度。对于地球化学体系而言，这意味着我们需要计算质量作用定律等方程的残差如何随摩尔浓度的变化而改变。本练习将引导你亲手推导这样一个关键的雅可比矩阵项，将物理化学模型（如用于计算活度系数的戴维斯方程）与数值方法的核心微积分运算联系起来 ()。",
            "id": "4092033",
            "problem": "一种用于求解水地球化学体系中非线性质量作用和质量平衡方程的牛顿-拉夫逊方法，需要雅可比矩阵元，这些矩阵元涉及活度系数对组成的灵敏度。考虑离子的活度系数的戴维斯模型，其中活度系数的常用对数（以10为底的对数）由下式给出\n$$\n\\log_{10}\\gamma_{i} = -A z_{i}^{2}\\left(\\frac{\\sqrt{I}}{1+\\sqrt{I}} - 0.3\\, I\\right),\n$$\n且离子强度定义为\n$$\nI=\\frac{1}{2}\\sum_{j} m_{j} z_{j}^{2},\n$$\n其中 $m_{j}$ 是物种 $j$ 的质量摩尔浓度，$z_{j}$ 是其电荷数，$A$ 是德拜-休克尔常数（与温度相关）。仅使用这些定义和标准微积分，推导偏导数\n$$\n\\frac{\\partial \\ln \\gamma_{i}}{\\partial m_{k}}\n$$\n的闭合形式解析表达式，并用 $A$、$z_{i}$、$z_{k}$ 和 $I$ 表示。您的最终答案必须是单个简化的解析表达式。不需要进行数值计算或四舍五入，最终答案中不应包含单位。",
            "solution": "该问题被认为是有效的，因为它科学地基于已建立的物理化学模型（戴维斯方程、离子强度），问题表述清晰、客观，并包含获得唯一解所需的所有必要信息。\n\n目标是推导偏导数 $\\frac{\\partial \\ln \\gamma_{i}}{\\partial m_{k}}$ 的闭合形式解析表达式。活度系数 $\\gamma_i$ 由戴维斯模型给出，其值取决于离子强度 $I$，而离子强度 $I$ 又取决于体系中所有物种的质量摩尔浓度 $m_j$。\n\n首先，我们使用对数的换底公式 $\\ln x = \\ln(10) \\log_{10} x$，将给定的活度系数的常用对数 $\\log_{10} \\gamma_i$ 与自然对数 $\\ln \\gamma_i$ 联系起来。将此应用于 $\\gamma_i$ 可得：\n$$\n\\ln \\gamma_i = \\ln(10) \\log_{10} \\gamma_i\n$$\n将戴维斯方程代入此关系式，得到：\n$$\n\\ln \\gamma_i = \\ln(10) \\left[ -A z_{i}^{2}\\left(\\frac{\\sqrt{I}}{1+\\sqrt{I}} - 0.3 I\\right) \\right]\n$$\n$$\n\\ln \\gamma_i = -A \\ln(10) z_{i}^{2}\\left(\\frac{\\sqrt{I}}{1+\\sqrt{I}} - 0.3 I\\right)\n$$\n我们需要求 $\\ln \\gamma_i$ 对特定物种 $k$ 的质量摩尔浓度（记为 $m_k$）的偏导数。由于 $\\ln \\gamma_i$ 是离子强度 $I$ 的显式函数，而 $I$ 是所有质量摩尔浓度 $m_j$（包括 $m_k$）的函数，我们必须应用链式法则进行偏微分：\n$$\n\\frac{\\partial \\ln \\gamma_i}{\\partial m_k} = \\frac{d(\\ln \\gamma_i)}{dI} \\frac{\\partial I}{\\partial m_k}\n$$\n我们将分别计算右侧的每一项。\n\n第一项是 $\\ln \\gamma_i$ 对 $I$ 的导数。为清楚起见，令 $C_i = -A \\ln(10) z_i^2$，该项相对于 $I$ 是常数。\n$$\n\\frac{d(\\ln \\gamma_i)}{dI} = \\frac{d}{dI} \\left[ C_i \\left(\\frac{I^{1/2}}{1+I^{1/2}} - 0.3 I\\right) \\right] = C_i \\left[ \\frac{d}{dI}\\left(\\frac{I^{1/2}}{1+I^{1/2}}\\right) - \\frac{d}{dI}(0.3 I) \\right]\n$$\n我们计算括号内两项的导数。第二项的导数很简单：\n$$\n\\frac{d}{dI}(0.3 I) = 0.3\n$$\n对于第一项，我们使用商法则，其中 $u = I^{1/2}$ 且 $v = 1+I^{1/2}$。它们对 $I$ 的导数分别为 $u' = \\frac{1}{2}I^{-1/2}$ 和 $v' = \\frac{1}{2}I^{-1/2}$。\n$$\n\\frac{d}{dI}\\left(\\frac{I^{1/2}}{1+I^{1/2}}\\right) = \\frac{u'v - uv'}{v^2} = \\frac{(\\frac{1}{2}I^{-1/2})(1+I^{1/2}) - I^{1/2}(\\frac{1}{2}I^{-1/2})}{(1+I^{1/2})^2}\n$$\n$$\n= \\frac{\\frac{1}{2}I^{-1/2} + \\frac{1}{2} - \\frac{1}{2}}{(1+I^{1/2})^2} = \\frac{\\frac{1}{2}I^{-1/2}}{(1+I^{1/2})^2} = \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^2}\n$$\n结合这些结果，我们得到 $\\frac{d(\\ln \\gamma_i)}{dI}$ 的表达式：\n$$\n\\frac{d(\\ln \\gamma_i)}{dI} = -A \\ln(10) z_i^2 \\left( \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^2} - 0.3 \\right)\n$$\n链式法则所需的第二项是离子强度 $I$ 对质量摩尔浓度 $m_k$ 的偏导数。离子强度的定义是：\n$$\nI = \\frac{1}{2}\\sum_{j} m_{j} z_{j}^{2}\n$$\n我们对 $m_k$ 求偏导数：\n$$\n\\frac{\\partial I}{\\partial m_k} = \\frac{\\partial}{\\partial m_k} \\left( \\frac{1}{2}\\sum_{j} m_{j} z_{j}^{2} \\right) = \\frac{1}{2}\\sum_{j} z_{j}^{2} \\frac{\\partial m_j}{\\partial m_k}\n$$\n偏导数 $\\frac{\\partial m_j}{\\partial m_k}$ 在 $j=k$ 时等于 $1$，在 $j \\neq k$ 时等于 $0$。这是克罗内克δ函数 $\\delta_{jk}$ 的定义。因此，求和式中只有 $j=k$ 的项不为零。\n$$\n\\frac{\\partial I}{\\partial m_k} = \\frac{1}{2}\\sum_{j} z_{j}^{2} \\delta_{jk} = \\frac{1}{2} z_k^2\n$$\n最后，我们将推导出的两个部分相乘，得到 $\\frac{\\partial \\ln \\gamma_i}{\\partial m_k}$ 的完整表达式：\n$$\n\\frac{\\partial \\ln \\gamma_i}{\\partial m_k} = \\left[ -A \\ln(10) z_i^2 \\left( \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^2} - 0.3 \\right) \\right] \\cdot \\left[ \\frac{1}{2} z_k^2 \\right]\n$$\n简化此表达式得到最终答案：\n$$\n\\frac{\\partial \\ln \\gamma_i}{\\partial m_k} = -\\frac{A \\ln(10) z_i^2 z_k^2}{2} \\left( \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^2} - 0.3 \\right)\n$$\n这个表达式可以写成另一种稍有不同的形式，将负号吸收到括号内：\n$$\n\\frac{\\partial \\ln \\gamma_i}{\\partial m_k} = \\frac{A \\ln(10) z_i^2 z_k^2}{2} \\left( 0.3 - \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^2} \\right)\n$$\n两种形式是等价的。我们将以后者作为最终答案。",
            "answer": "$$\\boxed{\\frac{A \\ln(10) z_{i}^{2} z_{k}^{2}}{2} \\left( 0.3 - \\frac{1}{2\\sqrt{I}(1+\\sqrt{I})^{2}} \\right)}$$"
        },
        {
            "introduction": "在掌握了如何计算导数之后，本练习将重点从“如何计算”转向“选择什么变量”。变量的选择（例如，使用摩尔浓度 $m_i$ 还是其对数 $\\ln m_i$）会极大地影响牛顿-拉夫逊求解器的稳定性和效率。这个思想实验将引导你分析不同变量选择的优劣，重点关注正值约束和矩阵条件数等关键数值概念，这些对于构建稳健的地球化学模型至关重要 ()。",
            "id": "4091986",
            "problem": "考虑一个恒温恒压下的水相络合体系，其中一个二价金属阳离子 $M^{2+}$ 和一个一价配体阴离子 $L^{-}$ 通过反应 $M^{2+} + L^{-} \\rightleftharpoons ML^{+}$ 形成络合物 $ML^{+}$。设未知物种的质量摩尔浓度为 $\\mathbf{m} = (m_M, m_L, m_{ML})^{\\top}$，总分析质量摩尔浓度为 $M_T$ 和 $L_T$。活度模型为 $a_i = \\gamma_i m_i$，其中 $\\gamma_i$ 是活度系数，它通过 Davies 型公式光滑地依赖于离子强度 $I$，例如 $\\log_{10}\\gamma_i = -A z_i^2\\left(\\frac{\\sqrt{I}}{1 + \\sqrt{I}} - 0.3\\, I\\right)$，其中 $z_i$ 是物种 $i$ 的化学计量电荷，$A$ 是一个与溶剂相关的常数。离子强度的定义为 $I = \\tfrac{1}{2}\\sum_i z_i^2 m_i$。该反应的平衡常数 $K$ 由平衡时的质量作用定律定义：$K = \\dfrac{a_{ML}}{a_M a_L}$。\n\n通过在平衡状态下强制满足质量平衡和质量作用定律，可以为牛顿-拉夫逊法构建一个标准的非线性残差。使用物种质量摩尔浓度 $\\mathbf{m}$，一个可能的残差向量是\n$$\n\\mathbf{R}(\\mathbf{m}) =\n\\begin{pmatrix}\nm_M + m_{ML} - M_T \\\\\nm_L + m_{ML} - L_T \\\\\n\\ln K - \\left(\\ln \\gamma_{ML} + \\ln m_{ML}\\right) + \\left(\\ln \\gamma_M + \\ln m_M\\right) + \\left(\\ln \\gamma_L + \\ln m_L\\right)\n\\end{pmatrix}.\n$$\n另一种方法是使用对数变换后的变量 $\\mathbf{y} = (y_M, y_L, y_{ML})^{\\top}$（其中 $y_i = \\ln m_i$），并将残差定义为复合函数 $\\mathbf{G}(\\mathbf{y}) = \\mathbf{R}(\\exp(\\mathbf{y}))$，其中 $\\exp(\\mathbf{y})$ 表示从 $\\mathbf{y}$ 映射回 $\\mathbf{m}$ 的逐分量指数映射。\n\n牛顿-拉夫逊法使用雅可比矩阵将这些残差线性化，并迭代求解 $J(\\mathbf{x}^{(k)})\\,\\Delta \\mathbf{x}^{(k)} = -\\mathbf{F}(\\mathbf{x}^{(k)})$，然后进行更新 $\\mathbf{x}^{(k+1)} = \\mathbf{x}^{(k)} + \\Delta \\mathbf{x}^{(k)}$，其中 $\\mathbf{F}$ 是残差，$J$ 是其关于所选变量的雅可比矩阵。\n\n从第一性原理出发，分析在所述络合体系中，使用物种质量摩尔浓度 $\\mathbf{m}$ 与使用对数变换变量 $\\mathbf{y}$ 时，牛顿-拉夫逊法的残差光滑性和数值稳健性，并考虑以下因素：\n- $\\gamma_i$ 对离子强度 $I$ 的光滑依赖关系以及 $I = \\tfrac{1}{2}\\sum_i z_i^2 m_i$ 的定义。\n- 水溶液中所有物种 $i$ 必须满足的正值约束 $m_i > 0$。\n- 当物种浓度跨越多个数量级时，变量缩放对雅可比矩阵和条件数的影响。\n\n下列哪些陈述是正确的？选择所有适用项。\n\nA. 使用变量 $\\mathbf{y} = \\ln \\mathbf{m}$ 能确保迭代值 $\\mathbf{m} = \\exp(\\mathbf{y})$ 保持严格为正，从而减少了对步长裁剪等保障策略的需求，并通常能提高在高度稀释体系中的稳健性。\n\nB. 关于 $\\mathbf{y}$ 的雅可比矩阵在 $\\mathbf{m} = \\exp(\\mathbf{y})$ 处满足 $J_{\\mathbf{y}}(\\mathbf{y}) = J_{\\mathbf{m}}(\\mathbf{m})\\,\\mathrm{diag}(\\mathbf{m})$；当物种的质量摩尔浓度跨越多个数量级时，这种列缩放倾向于减小条件数的差异，从而时常能增强牛顿-拉夫逊法的稳健性。\n\nC. 如果活度系数遵循 Davies 型模型，变换到 $\\mathbf{y} = \\ln \\mathbf{m}$ 会在 $m_i = 0$ 处引入不可微性，这会降低光滑性，使得牛顿-拉夫逊法与在 $\\mathbf{m}$ 中求解相比更不可靠。\n\nD. 牛顿-拉夫逊法在如 $\\mathbf{y} = \\ln \\mathbf{m}$ 的光滑重参数化下是不变的，因此无论在 $\\mathbf{m}$ 空间还是在 $\\mathbf{y}$ 空间求解，其收敛行为都是相同的。\n\nE. 在 $\\mathbf{y} = \\ln \\mathbf{m}$ 空间中求解，可以普遍消除由络合化学计量引起的病态问题，并保证无论初始猜测值如何都能快速收敛。\n\n请根据离子强度、活度、质量作用和牛顿-拉夫逊线性化的基本定义提供您的选择并说明理由，不要假定超出这些原理的任何专门的求解器技巧。",
            "solution": "用户希望我验证问题陈述，如果有效，则提供一个包含所有选项分析的详细解决方案。\n\n**问题验证**\n\n**第一步：提取已知条件**\n- **体系：** 恒温恒压下的水相络合体系。\n- **反应：** $M^{2+} + L^{-} \\rightleftharpoons ML^{+}$。\n- **未知数：** 物种质量摩尔浓度向量，$\\mathbf{m} = (m_M, m_L, m_{ML})^{\\top}$。\n- **常数：** 总分析质量摩尔浓度 $M_T$ 和 $L_T$。平衡常数 $K$。\n- **物种电荷：** $z_M = +2$, $z_L = -1$, $z_{ML} = +1$。\n- **活度模型：** $a_i = \\gamma_i m_i$。活度系数 $\\gamma_i$ 光滑地依赖于离子强度 $I$。\n- **活度系数公式示例：** Davies 型，$\\log_{10}\\gamma_i = -A z_i^2\\left(\\frac{\\sqrt{I}}{1 + \\sqrt{I}} - 0.3\\, I\\right)$。\n- **质量作用定律：** $K = \\dfrac{a_{ML}}{a_M a_L}$。\n- **m空间中的残差：**\n$$\n\\mathbf{R}(\\mathbf{m}) =\n\\begin{pmatrix}\nm_M + m_{ML} - M_T \\\\\nm_L + m_{ML} - L_T \\\\\n\\ln K - \\left(\\ln \\gamma_{ML} + \\ln m_{ML}\\right) + \\left(\\ln \\gamma_M + \\ln m_M\\right) + \\left(\\ln \\gamma_L + \\ln m_L\\right)\n\\end{pmatrix}\n$$\n- **到y空间的变换：** $\\mathbf{y} = (y_M, y_L, y_{ML})^{\\top}$，其中 $y_i = \\ln m_i$。\n- **y空间中的残差：** $\\mathbf{G}(\\mathbf{y}) = \\mathbf{R}(\\exp(\\mathbf{y}))$。\n- **数值方法：** 牛顿-拉夫逊法，由迭代系统 $J(\\mathbf{x}^{(k)})\\,\\Delta \\mathbf{x}^{(k)} = -\\mathbf{F}(\\mathbf{x}^{(k)})$ 和更新步骤 $\\mathbf{x}^{(k+1)} = \\mathbf{x}^{(k)} + \\Delta \\mathbf{x}^{(k)})$ 定义。\n\n**第二步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题描述了一个标准的化学平衡计算，这是水地球化学的基石。所有给出的方程——质量平衡、质量作用、离子强度和用于活度系数的 Davies 模型——都是该领域的基本原理和标准模型。该设置在科学上和事实上都是合理的。\n- **适定性：** 该问题要求分析和比较用于求解一个适定非线性方程组的两种不同数值公式。对于给定的正总浓度 $M_T$ 和 $L_T$，预期存在一个唯一的物种质量摩尔浓度正解 $\\mathbf{m}$。问题本身是适定的，要求对数值属性进行比较分析。\n- **客观性：** 该问题以精确的数学语言表述。它要求基于数值方法和化学热力学的第一性原理进行分析，避免任何主观性。\n\n经审查，该问题陈述没有任何无效性缺陷。它在科学上是合理的、适定的、客观的、完整的，并提出了一个在计算地球化学领域中有意义且不平凡的问题。\n\n**第三步：结论与行动**\n问题有效。我将继续进行解决方案的推导和选项分析。\n\n**基于原理的推导与解法**\n\n问题的核心是比较牛顿-拉夫逊法应用于一个方程组时的数值性质，该方程组用两组不同的变量表示：物种质量摩尔浓度 $\\mathbf{m}$ 和它们的对数 $\\mathbf{y} = \\ln \\mathbf{m}$。\n\n**1. 正值约束与定义域**\n化学质量摩尔浓度 $m_i$ 必须严格为正。这对所有 $i$ 施加了约束 $m_i > 0$。\n- **在 $\\mathbf{m}$ 空间中的表示法：** 自变量是 $\\mathbf{m}$ 本身。牛顿-拉夫逊更新为 $\\mathbf{m}^{(k+1)} = \\mathbf{m}^{(k)} + \\Delta \\mathbf{m}^{(k)}$。此更新中没有内在机制来强制执行正值约束 $m_i^{(k+1)} > 0$。如果一个迭代值 $\\mathbf{m}^{(k)}$ 接近可行域的边界（即某个 $m_i$ 非常小），一个完整的牛顿步长 $\\Delta \\mathbf{m}^{(k)}$ 很容易导致 $m_i^{(k+1)}$ 出现非物理的负值。这将导致算法失败，因为残差 $\\mathbf{R}(\\mathbf{m})$ 中的 $\\ln m_i$ 等项将变得无定义。为防止这种情况，使用此表示法的求解器必须实施保障措施，例如线搜索算法（即取一个较小的步长 $\\alpha \\Delta \\mathbf{m}^{(k)}$，其中 $0  \\alpha  1$）或裁剪负值，但这可能会损害收敛速度和稳健性。\n- **在 $\\mathbf{y} = \\ln \\mathbf{m}$ 空间中的表示法：** 自变量是 $\\mathbf{y}$。$\\mathbf{y}$ 的定义域是 $\\mathbb{R}^3$，是无约束的。质量摩尔浓度通过逐分量变换 $\\mathbf{m} = \\exp(\\mathbf{y})$（即 $m_i = e^{y_i}$）恢复。由于指数函数 $e^x$ 对任何实数 $x$ 都严格为正，$\\mathbb{R}^3$ 中的任何迭代值 $\\mathbf{y}^{(k+1)}$ 都会产生一个质量摩尔浓度向量 $\\mathbf{m}^{(k+1)}$，其中每个分量都严格为正。这种变量变换无需任何额外逻辑即可优雅地自动满足正值约束，从而增强算法的稳定性和稳健性。\n\n**2. 雅可比矩阵与条件数**\n两个系统的雅可比矩阵之间的关系可以用多元链式法则找到。设 $\\mathbf{m}(\\mathbf{y}) = \\exp(\\mathbf{y})$。y空间中的残差为 $\\mathbf{G}(\\mathbf{y}) = \\mathbf{R}(\\mathbf{m}(\\mathbf{y}))$。\n$\\mathbf{G}$ 关于 $\\mathbf{y}$ 的雅可比矩阵是：\n$$ J_{\\mathbf{y}} = \\frac{\\partial \\mathbf{G}}{\\partial \\mathbf{y}} = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{m}} \\frac{\\partial \\mathbf{m}}{\\partial \\mathbf{y}} $$\n设 $J_{\\mathbf{m}} = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{m}}$。变换的雅可比矩阵是一个对角矩阵：\n$$ \\frac{\\partial \\mathbf{m}}{\\partial \\mathbf{y}} = \\mathrm{diag}\\left(\\frac{\\partial e^{y_M}}{\\partial y_M}, \\frac{\\partial e^{y_L}}{\\partial y_L}, \\frac{\\partial e^{y_{ML}}}{\\partial y_{ML}}\\right) = \\mathrm{diag}(e^{y_M}, e^{y_L}, e^{y_{ML}}) = \\mathrm{diag}(m_M, m_L, m_{ML}) = \\mathrm{diag}(\\mathbf{m}) $$\n因此，我们得到关系 $J_{\\mathbf{y}} = J_{\\mathbf{m}}\\,\\mathrm{diag}(\\mathbf{m})$。这意味着 $J_{\\mathbf{y}}$ 的列是 $J_{\\mathbf{m}}$ 的列乘以相应的质量摩尔浓度进行缩放。\n\n我们来研究 $J_{\\mathbf{m}} = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{m}}$ 的结构。\n对应于质量平衡的前两行很简单：\n$\\frac{\\partial R_1}{\\partial m_M}=1$, $\\frac{\\partial R_1}{\\partial m_L}=0$, $\\frac{\\partial R_1}{\\partial m_{ML}}=1$。\n$\\frac{\\partial R_2}{\\partial m_M}=0$, $\\frac{\\partial R_2}{\\partial m_L}=1$, $\\frac{\\partial R_2}{\\partial m_{ML}}=1$。\n来自质量作用定律的第三行则更复杂。我们重写 $R_3$ 为 $\\ln\\left(\\frac{a_M a_L}{a_{ML}}\\right) - \\ln K = 0$。\n$$ R_3 = (\\ln m_M + \\ln \\gamma_M) + (\\ln m_L + \\ln \\gamma_L) - (\\ln m_{ML} + \\ln \\gamma_{ML}) - \\ln K $$\n偏导数的形式为 $\\frac{\\partial R_3}{\\partial m_j}$。例如，关于 $m_M$ 的偏导数是：\n$$ \\frac{\\partial R_3}{\\partial m_M} = \\frac{1}{m_M} + \\frac{\\partial(\\ln \\gamma_M)}{\\partial m_M} + \\frac{\\partial(\\ln \\gamma_L)}{\\partial m_M} - \\frac{\\partial(\\ln \\gamma_{ML})}{\\partial m_M} $$\n活度系数项 $\\frac{\\partial(\\ln \\gamma_i)}{\\partial m_M} = \\frac{1}{\\gamma_i} \\frac{\\partial \\gamma_i}{\\partial I} \\frac{\\partial I}{\\partial m_M}$通常是良态的。然而，当 $m_M \\to 0$ 时，$\\frac{1}{m_M}$ 项会变得非常大。在地球化学体系中，浓度可以跨越多个数量级（例如，$10^{-2}$到$10^{-12}$ molal）。如果 $m_M$ 是痕量物种，矩阵项 $(\\frac{\\partial R_3}{\\partial m_M})$ 可能变得巨大，而 $J_{\\mathbf{m}}$ 第一列中的其他项数量级为 $1$。这会导致雅可比矩阵的列具有差异巨大的尺度，这通常是病态的来源。病态矩阵会在线性求解步骤 $J\\,\\Delta \\mathbf{x} = -\\mathbf{F}$ 中放大数值误差。\n\n现在考虑 $J_{\\mathbf{y}}$ 中相应的列。$J_{\\mathbf{y}}$ 的第一列是 $J_{\\mathbf{m}}$ 的第一列乘以 $m_M$ 进行缩放。\n$J_{\\mathbf{y}}$ 的 $(3,1)$ 项是 $m_M \\frac{\\partial R_3}{\\partial m_M} = m_M \\left( \\frac{1}{m_M} + \\dots \\right) = 1 + m_M(\\dots)$。有问题的 $\\frac{1}{m_M}$ 项被消除了。对数变换的效果是对雅可比矩阵的列进行缩放，这平衡了它们的范数，并通常会得到一个条件数好得多的矩阵。这提高了牛顿-拉夫逊法的数值稳定性和稳健性。\n\n**3. 不变性**\n牛顿法在一般的非线性重参数化下不是不变的。仿射变换 $\\mathbf{x}'=A\\mathbf{x}+b$ 保持牛顿迭代（即新的迭代值只是变换后的旧迭代值），但像 $\\mathbf{y} = \\ln \\mathbf{m}$ 这样的非线性变换则不然。迭代序列 $\\{\\mathbf{y}^{(k)}\\}$ 生成的序列 $\\{\\mathbf{m}^{(k)} = \\exp(\\mathbf{y}^{(k)})\\}$ 在解空间中描绘的路径，与直接在 $\\mathbf{m}$ 空间中求解生成的序列所描绘的路径不同。如上所示，这些路径具有非常不同的数值性质。\n\n**逐项分析**\n\n**A. 使用变量 $\\mathbf{y} = \\ln \\mathbf{m}$ 能确保迭代值 $\\mathbf{m} = \\exp(\\mathbf{y})$ 保持严格为正，从而减少了对步长裁剪等保障策略的需求，并通常能提高在高度稀释体系中的稳健性。**\n这个陈述与我们在第1点的分析一致。变换 $\\mathbf{m} = \\exp(\\mathbf{y})$ 内在地满足了正值约束。这是使用它的一个主要原因，因为它避免了在未变换问题上手动施加此约束的复杂性和潜在的收敛问题，特别是在浓度很小的时候。\n**结论：正确。**\n\n**B. 关于 $\\mathbf{y}$ 的雅可比矩阵在 $\\mathbf{m} = \\exp(\\mathbf{y})$ 处满足 $J_{\\mathbf{y}}(\\mathbf{y}) = J_{\\mathbf{m}}(\\mathbf{m})\\,\\mathrm{diag}(\\mathbf{m})$；当物种的质量摩尔浓度跨越多个数量级时，这种列缩放倾向于减小条件数的差异，从而时常能增强牛顿-拉夫逊法的稳健性。**\n这个陈述与我们在第2点的分析一致。雅可比矩阵之间的数学关系陈述正确。这种列缩放的效果正是为了抵消由质量作用定律引起的雅可比矩阵 $J_{\\mathbf{m}}$ 中的 $1/m_j$ 项所导致的病态条件。这种类似预处理的效果提高了数值稳健性，特别是对于浓度范围很宽的系统。\n**结论：正确。**\n\n**C. 如果活度系数遵循 Davies 型模型，变换到 $\\mathbf{y} = \\ln \\mathbf{m}$ 会在 $m_i = 0$ 处引入不可微性，这会降低光滑性，使得牛顿-拉夫逊法与在 $\\mathbf{m}$ 中求解相比更不可靠。**\n该陈述错误地归因了光滑性问题的来源。不可微性（由于 $\\ln m_i$ 和 Davies 模型中的 $\\sqrt{I}$）存在于*未变换*问题定义域的边界 $m_i=0$ 处。变换到 $\\mathbf{y}$ 空间将整个无约束空间 $\\mathbb{R}^3$ 映射到 $\\mathbf{m}$ 空间的严格正值部分，从而有效地从考虑中移除了边界。变换后的残差 $\\mathbf{G}(\\mathbf{y})$ 对于所有 $\\mathbf{y} \\in \\mathbb{R}^3$ 都是一个光滑函数。因此，通过在一个函数处处光滑的无约束域中工作，这种变换实际上*改善*了求解器的光滑性。\n**结论：不正确。**\n\n**D. 牛顿-拉夫逊法在如 $\\mathbf{y} = \\ln \\mathbf{m}$ 的光滑重参数化下是不变的，因此无论在 $\\mathbf{m}$ 空间还是在 $\\mathbf{y}$ 空间求解，其收敛行为都是相同的。**\n这个陈述是错误的。如第3点所讨论，牛顿法在非线性重参数化下不是不变的。选项A和B描述了稳健性的显著改善，这一事实本身就证明了收敛行为并不相同。变换改变了搜索空间的几何形状和所采取的步长性质，导致了不同的迭代序列和不同的收敛属性。\n**结论：不正确。**\n\n**E. 在 $\\mathbf{y} = \\ln \\mathbf{m}$ 空间中求解，可以普遍消除由络合化学计量引起的病态问题，并保证无论初始猜测值如何都能快速收敛。**\n这个陈述使用了绝对化和过于强烈的措辞。“普遍消除”过于绝对；虽然对数变换显著改善了来自一个常见来源的条件数，但它可能无法修复所有可能的病态来源。“保证无论初始猜测值如何都能快速收敛”是错误的。牛顿法是一种局部收敛方法。其成功和速度取决于是否从足够接近解的初始点开始。虽然对数变换通常会扩大吸引盆（“好的”初始猜测的集合），但它并不能使其无限大。一个足够差的初始猜测仍然可能导致发散。\n**结论：不正确。**",
            "answer": "$$\\boxed{AB}$$"
        },
        {
            "introduction": "对于复杂的体系，手动推导雅可比矩阵的每一项既乏味又容易出错。最后的这项动手实践将带你进入现代计算地球化学的前沿，通过实现一个前向模式的自动微分 (AD) 引擎来解决这个问题。通过将数值及其导数作为一个整体（即“对偶数”）进行处理，你将构建一个能够自动计算牛顿-拉夫逊方法所需精确导数的工具，它结合了第一个练习的分析严谨性和第二个练习的数值策略 ()。",
            "id": "4092063",
            "problem": "您需要实现一个前向模式自动微分引擎，使用对偶数来计算在由质量作用定律和活度系数控制的地球化学平衡体系中，牛顿-拉夫逊更新所需的导数。该系统必须根据基本的地球化学定义和质量作用关系来定义，并且必须产生可进行数值检验的输出。\n\n此任务的基础包括以下在计算地球化学中被广泛接受的定义和定律：\n- 水溶液中物种 $i$ 的活度定义为 $a_i = \\gamma_i m_i$，其中 $m_i$ 是质量摩尔浓度（单位：mol/kg水），$\\gamma_i$ 是活度系数（无量纲）。\n- 水溶液的离子强度 $I$ 定义为 $I = \\frac{1}{2}\\sum_i m_i z_i^2$，其中 $z_i$ 是物种 $i$ 的电荷数。\n- $25\\,^{\\circ}\\mathrm{C}$ 下的 Davies 方程表示带电物种活度系数的以10为底的对数为\n$$\\log_{10} \\gamma_i = -A z_i^2 \\left(\\frac{\\sqrt{I}}{1 + \\sqrt{I}} - 0.3 I\\right),$$\n其中 $A = 0.509$ 是 $25\\,^{\\circ}\\mathrm{C}$ 下的 Debye-Hückel 常数。中性物种的 $z_i=0$，因此 $\\gamma_i = 1$。\n- 对于一个化学计量系数为 $\\nu_{r,i}$、平衡常数为 $K_r$ 的反应 $r$，其通用的质量作用残差定义为：\n$$R_r(\\mathbf{m}) = \\sum_i \\nu_{r,i} \\ln a_i - \\ln K_r,$$\n该值在平衡时等于 $0$。\n\n您的程序必须：\n1. 使用对偶数实现一个前向模式自动微分框架，以在所有计算中传播导数 $\\frac{\\partial}{\\partial m_k}$。\n2. 对每个系统，通过 Davies 方程计算 $I(\\mathbf{m})$ 和 $\\gamma_i(I)$，以及 $a_i(\\mathbf{m}) = \\gamma_i m_i$。\n3. 使用自动微分，计算并返回每个测试用例中指定索引 $(i,k)$ 的 $\\frac{\\partial a_i}{\\partial m_k}$ 和 $\\frac{\\partial R_r}{\\partial m_k}$ 的值，而无需手动编写导数公式。\n\n下面定义了三个必需的测试用例，每个用例都包含物种列表、电荷数 $z_i$、质量摩尔浓度 $m_i$（单位：mol/kg）、一个单一反应及其化学计量系数 $\\nu_{r,i}$ 和平衡常数 $K_r$（无量纲）。对于每个案例，程序必须按顺序计算以下输出：$\\frac{\\partial a_{i^\\ast}}{\\partial m_{k_1}}$、$\\frac{\\partial a_{i^\\ast}}{\\partial m_{k_2}}$、$\\frac{\\partial R_r}{\\partial m_{k_1}}$ 和 $R_r$。\n\n案例 1（中等离子强度，氯化钠及中性离子对）：\n- 物种：$\\text{Na}^+$, $\\text{Cl}^-$, $\\text{NaCl}^0$。\n- 电荷：$z = [1, -1, 0]$。\n- 质量摩尔浓度：$m = [0.1, 0.1, 10^{-8}]$ (mol/kg)。\n- 反应：$\\text{Na}^+ + \\text{Cl}^- \\rightleftharpoons \\text{NaCl}^0$，化学计量系数 $\\nu = [1, 1, -1]$，平衡常数 $K = 0.78$。\n- 输出目标：$i^\\ast$ 指 $\\text{Na}^+$（索引 $0$），$k_1 = \\text{Na}^+$（索引 $0$），$k_2 = \\text{Cl}^-$（索引 $1$）。\n\n案例 2（极稀盐酸）：\n- 物种：$\\text{H}^+$, $\\text{Cl}^-$, $\\text{HCl}^0$。\n- 电荷：$z = [1, -1, 0]$。\n- 质量摩尔浓度：$m = [10^{-6}, 10^{-6}, 10^{-12}]$ (mol/kg)。\n- 反应：$\\text{H}^+ + \\text{Cl}^- \\rightleftharpoons \\text{HCl}^0$，化学计量系数 $\\nu = [1, 1, -1]$，平衡常数 $K = 10^{-8}$。\n- 输出目标：$i^\\ast$ 指 $\\text{H}^+$（索引 $0$），$k_1 = \\text{H}^+$（索引 $0$），$k_2 = \\text{Cl}^-$（索引 $1$）。\n\n案例 3（高离子强度氯化钙及中性络合物）：\n- 物种：$\\text{Ca}^{2+}$, $\\text{Cl}^-$, $\\text{CaCl}_2^0$。\n- 电荷：$z = [2, -1, 0]$。\n- 质量摩尔浓度：$m = [0.5, 1.0, 10^{-6}]$ (mol/kg)。\n- 反应：$\\text{Ca}^{2+} + 2\\,\\text{Cl}^- \\rightleftharpoons \\text{CaCl}_2^0$，化学计量系数 $\\nu = [1, 2, -1]$，平衡常数 $K = 0.3$。\n- 输出目标：$i^\\ast$ 指 $\\text{Ca}^{2+}$（索引 $0$），$k_1 = \\text{Ca}^{2+}$（索引 $0$），$k_2 = \\text{Cl}^-$（索引 $1$）。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n- 案例 1：$\\left[\\frac{\\partial a_{\\text{Na}^+}}{\\partial m_{\\text{Na}^+}}, \\frac{\\partial a_{\\text{Na}^+}}{\\partial m_{\\text{Cl}^-}}, \\frac{\\partial R}{\\partial m_{\\text{Na}^+}}, R\\right]$。\n- 案例 2：$\\left[\\frac{\\partial a_{\\text{H}^+}}{\\partial m_{\\text{H}^+}}, \\frac{\\partial a_{\\text{H}^+}}{\\partial m_{\\text{Cl}^-}}, \\frac{\\partial R}{\\partial m_{\\text{H}^+}}, R\\right]$。\n- 案例 3：$\\left[\\frac{\\partial a_{\\text{Ca}^{2+}}}{\\partial m_{\\text{Ca}^{2+}}}, \\frac{\\partial a_{\\text{Ca}^{2+}}}{\\partial m_{\\text{Cl}^-}}, \\frac{\\partial R}{\\partial m_{\\text{Ca}^{2+}}}, R\\right]$。\n\n将所有十二个数字连接成一个列表，并将每个数字四舍五入到六位小数。例如，程序必须打印：\n$$\\left[\\text{c}_{1,1}, \\text{c}_{1,2}, \\text{c}_{1,3}, \\text{c}_{1,4}, \\text{c}_{2,1}, \\ldots, \\text{c}_{3,4}\\right],$$\n其中 $\\text{c}_{i,j}$ 是计算出的浮点数，已四舍五入到六位小数。\n\n不允许外部输入。活度和残差是无量纲的；质量摩尔浓度必须按规定以 $\\mathrm{mol}/\\mathrm{kg}$ 为单位处理，质量作用残差中的所有对数必须是自然对数。通过对所有物种使用严格为正的质量摩尔浓度来确保科学真实性。",
            "solution": "待实现的系统依赖于应用于地球化学活度模型和质量作用残差的链式法则，通过前向模式自动微分来表达。地球化学系统的牛顿-拉夫逊方法需要残差向量相对于自变量（在此情境下为物种的质量摩尔浓度）的雅可比矩阵。我们展示如何通过对偶数将导数传播嵌入算术运算中，从而自动获得这些导数。\n\n我们从定义开始。对于物种 $i$，活度为 $a_i = \\gamma_i m_i$，其中 $m_i$ 是质量摩尔浓度，$\\gamma_i$ 是活度系数。对于一个化学计量系数为 $\\nu_{r,i}$、平衡常数为 $K_r$ 的单一反应 $r$，其残差为\n$$ R_r(\\mathbf{m}) = \\sum_i \\nu_{r,i} \\ln a_i - \\ln K_r. $$\n离子强度为\n$$ I(\\mathbf{m}) = \\frac{1}{2}\\sum_i m_i z_i^2. $$\n活度系数以10为底的对数的 Davies 方程为\n$$ \\log_{10} \\gamma_i = -A z_i^2 \\left(\\frac{\\sqrt{I}}{1 + \\sqrt{I}} - 0.3 I\\right), $$\n其中 $A = 0.509$。转换为自然对数，我们得到\n$$ \\ln \\gamma_i = \\ln(10)\\, \\log_{10} \\gamma_i = -\\ln(10)\\,A z_i^2 \\left(\\frac{\\sqrt{I}}{1 + \\sqrt{I}} - 0.3 I\\right). $$\n因此，$\\gamma_i = \\exp(\\ln \\gamma_i)$，活度为 $a_i = \\gamma_i m_i$。\n\n为了计算 $\\frac{\\partial a_i}{\\partial m_k}$，我们应用乘积法则：\n$$ \\frac{\\partial a_i}{\\partial m_k} = \\frac{\\partial}{\\partial m_k}\\left(\\gamma_i m_i\\right) = \\gamma_i \\delta_{ik} + m_i \\frac{\\partial \\gamma_i}{\\partial m_k}, $$\n其中 $\\delta_{ik}$ 是克罗内克δ函数，而 $\\frac{\\partial \\gamma_i}{\\partial m_k}$ 通过 $I(\\mathbf{m})$ 经由链式法则获得。具体来说，\n$$ \\frac{\\partial \\gamma_i}{\\partial m_k} = \\gamma_i \\frac{\\partial \\ln \\gamma_i}{\\partial m_k}, $$\n并且\n$$ \\frac{\\partial \\ln \\gamma_i}{\\partial m_k} = -\\ln(10)\\,A z_i^2 \\left( \\frac{\\partial}{\\partial m_k}\\left(\\frac{\\sqrt{I}}{1+\\sqrt{I}}\\right) - 0.3 \\frac{\\partial I}{\\partial m_k} \\right). $$\n$I$ 的导数为\n$$ \\frac{\\partial I}{\\partial m_k} = \\frac{1}{2} z_k^2. $$\n令 $s = \\sqrt{I}$；则\n$$ \\frac{\\partial}{\\partial m_k}\\left(\\frac{s}{1+s}\\right) = \\frac{(1+s)\\frac{\\partial s}{\\partial m_k} - s \\frac{\\partial s}{\\partial m_k}}{(1+s)^2} = \\frac{\\frac{\\partial s}{\\partial m_k}}{(1+s)^2}. $$\n由于 $s = I^{1/2}$，我们有\n$$ \\frac{\\partial s}{\\partial m_k} = \\frac{1}{2} I^{-1/2} \\frac{\\partial I}{\\partial m_k} = \\frac{z_k^2}{4 \\sqrt{I}}. $$\n将这些放在一起可以得到一个显式公式，但我们的目标是避免显式地编写这些导数代码，而是实现前向模式自动微分。在前向模式自动微分中，每个 $m_k$ 表示为一个对偶数 $M_k = m_k + \\varepsilon \\,\\frac{\\partial}{\\partial m_k}$，并且每个算术运算都被重载以传播原始值和导数向量。对于多个变量，导数部分是 $\\mathbb{R}^n$ 中的一个向量，其种子向量等于变量 $m_k$ 的标准基 $e_k$。\n\n实现步骤如下：\n1. 将每个质量摩尔浓度 $m_i$ 表示为一个对偶数，其原始值为 $m_i$，导数向量等于第 $i$ 个标准基向量。\n2. 使用对偶数算术计算 $I(\\mathbf{m}) = \\frac{1}{2} \\sum_i m_i z_i^2$；这将同时产生 $I$ 和 $\\nabla I$。\n3. 通过对偶数 $\\sqrt{\\cdot}$ 计算 $s = \\sqrt{I}$。\n4. 通过对偶数算术计算 Davies 项 $t = \\frac{s}{1+s} - 0.3 I$。\n5. 计算 $\\ln \\gamma_i = -\\ln(10)\\,A z_i^2 \\, t$，然后通过对偶数 $\\exp$ 计算 $\\gamma_i = \\exp(\\ln \\gamma_i)$。\n6. 通过对偶数乘法计算 $a_i = \\gamma_i \\, m_i$。\n7. 通过对偶数 $\\ln$ 计算残差 $R_r(\\mathbf{m}) = \\sum_i \\nu_{r,i} \\ln a_i - \\ln K_r$。\n8. 从 $a_i$ 和 $R_r$ 的导数向量中提取与目标索引 $k$ 对应的导数分量。\n\n因为对偶数算术自动执行链式法则，所以导数 $\\frac{\\partial a_i}{\\partial m_k}$ 和 $\\frac{\\partial R_r}{\\partial m_k}$ 无需编写显式的解析导数即可获得，确保了即使通过像 $\\sqrt{\\cdot}$ 和 $\\exp(\\cdot)$ 这样的嵌套函数，也能正确和稳定地传播。\n\n测试套件包括三种情景：\n- 案例 1 检验中等离子强度和一价离子，评估自敏感度和交叉敏感度以及带有中性络合物的质量作用残差；这测试了典型的“顺利路径”。\n- 案例 2 检验接近稀释极限时的行为，此时 $\\gamma_i \\approx 1$ 但通过 $\\sqrt{I}$ 的链式法则可能很敏感；这通过使用严格为正的质量摩尔浓度，作为一个避免零离子强度的边界情况。\n- 案例 3 检验高离子强度和多价离子，此时活度系数的非线性非常显著；这检验了非线性区域中的导数传播。\n\n最终程序输出一行，包含十二个数字（每个案例四个），格式为一个用方括号括起来的逗号分隔列表，每个浮点数四舍五入到六位小数，顺序如问题陈述中所指定。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Forward-mode automatic differentiation using dual numbers with vector derivatives.\nclass Dual:\n    def __init__(self, value: float, deriv: np.ndarray):\n        self.value = float(value)\n        # Ensure derivative is a 1-D numpy array of floats\n        self.deriv = np.array(deriv, dtype=float)\n\n    def __add__(self, other):\n        other = to_dual(other, self.deriv.size)\n        return Dual(self.value + other.value, self.deriv + other.deriv)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        other = to_dual(other, self.deriv.size)\n        return Dual(self.value - other.value, self.deriv - other.deriv)\n\n    def __rsub__(self, other):\n        other = to_dual(other, self.deriv.size)\n        return Dual(other.value - self.value, other.deriv - self.deriv)\n\n    def __mul__(self, other):\n        other = to_dual(other, self.deriv.size)\n        # Product rule: d(u*v) = u' * v + u * v'\n        return Dual(self.value * other.value, self.deriv * other.value + self.value * other.deriv)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __truediv__(self, other):\n        other = to_dual(other, self.deriv.size)\n        # Quotient rule: d(u/v) = (u' * v - u * v') / v^2\n        denom = other.value * other.value\n        return Dual(self.value / other.value, (self.deriv * other.value - self.value * other.deriv) / denom)\n\n    def __rtruediv__(self, other):\n        other = to_dual(other, self.deriv.size)\n        # other / self\n        denom = self.value * self.value\n        return Dual(other.value / self.value, (other.deriv * self.value - other.value * self.deriv) / denom)\n\n    def __pow__(self, power):\n        # Only support scalar power for simplicity\n        if isinstance(power, (int, float)):\n            if self.value == 0 and power != int(power) and power  1:\n                raise ValueError(\"Dual power with non-integer exponent requires positive base.\")\n            val = self.value ** power\n            # d(x^p) = p * x^(p-1) dx\n            coeff = power * (self.value ** (power - 1)) if self.value != 0 else 0.0\n            return Dual(val, coeff * self.deriv)\n        else:\n            raise NotImplementedError(\"Power with Dual exponent not implemented.\")\n\ndef to_dual(x, nvars):\n    if isinstance(x, Dual):\n        return x\n    else:\n        return Dual(float(x), np.zeros(nvars, dtype=float))\n\ndef dual_sqrt(x: Dual) -> Dual:\n    if x.value == 0.0:\n        # For geochemical ionic strength I, we expect strictly positive due to positive molalities.\n        # If extremely small, numerical safety: use tiny positive epsilon\n        eps = 1e-30\n        val = np.sqrt(x.value + eps)\n        deriv = (0.5 / val) * x.deriv\n        return Dual(val, deriv)\n    val = np.sqrt(x.value)\n    deriv = (0.5 / val) * x.deriv\n    return Dual(val, deriv)\n\ndef dual_log(x: Dual) -> Dual:\n    if x.value = 0.0:\n        raise ValueError(\"Log of non-positive Dual value encountered.\")\n    return Dual(np.log(x.value), x.deriv / x.value)\n\ndef dual_exp(x: Dual) -> Dual:\n    val = np.exp(x.value)\n    return Dual(val, val * x.deriv)\n\ndef make_dual_vars(m_values):\n    n = len(m_values)\n    vars_dual = []\n    for i, mv in enumerate(m_values):\n        deriv = np.zeros(n, dtype=float)\n        deriv[i] = 1.0\n        vars_dual.append(Dual(float(mv), deriv))\n    return vars_dual\n\ndef davies_gamma_dual(z_list, m_dual_list, A=0.509):\n    \"\"\"\n    Compute gamma_i for all species using Davies equation via dual arithmetic.\n    Returns list of Dual gamma_i.\n    \"\"\"\n    n = len(m_dual_list)\n    # Ionic strength I = 0.5 * sum(m_i * z_i^2)\n    I = Dual(0.0, np.zeros(n, dtype=float))\n    for mi, zi in zip(m_dual_list, z_list):\n        I = I + mi * (zi * zi * 1.0)\n\n    I = I * 0.5\n    s = dual_sqrt(I)\n    # term = s/(1+s) - 0.3 * I\n    term = s / (1.0 + s) - I * 0.3\n    # ln(gamma_i) = ln(10) * log10(gamma_i) = -ln(10) * A * z_i^2 * term\n    ln10 = np.log(10.0)\n    gammas = []\n    for zi in z_list:\n        if zi == 0:\n            # Neutral species: gamma = 1.0 exactly\n            gammas.append(Dual(1.0, np.zeros(n, dtype=float)))\n        else:\n            ln_gamma_i = (-ln10 * A * (zi * zi)) * term\n            gamma_i = dual_exp(ln_gamma_i)\n            gammas.append(gamma_i)\n    return gammas\n\ndef compute_system_outputs(names, z, m, nu, K, i_target, k1, k2):\n    \"\"\"\n    For a given system, compute:\n    d a_i_target / d m_{k1}, d a_i_target / d m_{k2}, dR/dm_{k1}, R\n    \"\"\"\n    # Create dual variables for molalities\n    m_dual = make_dual_vars(m)\n    # Compute gamma_i via Davies\n    gamma_dual = davies_gamma_dual(z, m_dual, A=0.509)\n    # Activities a_i = gamma_i * m_i\n    a_dual = [gamma_dual[i] * m_dual[i] for i in range(len(m))]\n    # Residual R = sum nu_i * ln(a_i) - ln(K)  (natural logs)\n    R = Dual(0.0, np.zeros(len(m), dtype=float))\n    for i in range(len(m)):\n        R = R + nu[i] * dual_log(a_dual[i])\n    R = R - np.log(K)\n\n    # Extract derivatives and values\n    d_a_i_dm_k1 = a_dual[i_target].deriv[k1]\n    d_a_i_dm_k2 = a_dual[i_target].deriv[k2]\n    dR_dm_k1 = R.deriv[k1]\n    R_val = R.value\n\n    return d_a_i_dm_k1, d_a_i_dm_k2, dR_dm_k1, R_val\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (names, z, m, nu, K, i_target, k1, k2)\n    test_cases = [\n        # Case 1: Na+, Cl-, NaCl0\n        ([\"Na+\", \"Cl-\", \"NaCl0\"], [1, -1, 0], [0.1, 0.1, 1e-8], [1, 1, -1], 0.78, 0, 0, 1),\n        # Case 2: H+, Cl-, HCl0 (very dilute)\n        ([\"H+\", \"Cl-\", \"HCl0\"], [1, -1, 0], [1e-6, 1e-6, 1e-12], [1, 1, -1], 1e-8, 0, 0, 1),\n        # Case 3: Ca2+, Cl-, CaCl2^0 (high ionic strength)\n        ([\"Ca2+\", \"Cl-\", \"CaCl20\"], [2, -1, 0], [0.5, 1.0, 1e-6], [1, 2, -1], 0.3, 0, 0, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        names, z, m, nu, K, i_target, k1, k2 = case\n        d_ai_dm_k1, d_ai_dm_k2, dR_dm_k1, R_val = compute_system_outputs(names, z, m, nu, K, i_target, k1, k2)\n        # Round to six decimal places as required\n        results.extend([\n            round(d_ai_dm_k1, 6),\n            round(d_ai_dm_k2, 6),\n            round(dR_dm_k1, 6),\n            round(R_val, 6),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}