{
    "hands_on_practices": [
        {
            "introduction": "在任何动力学研究中，首要步骤是将单个化学物种的可测量变化与反应的整体速率明确地联系起来。这个关系由反应的化学计量决定。本练习旨在巩固反应速率的基本定义，及其与物种生成或消耗速率之间的联系，这是构建任何动力学模型的基础概念 。",
            "id": "4096808",
            "problem": "碳酸盐矿物的水溶是地球化学反应输运中的一个核心过程。考虑一个与过量方解石接触的、等温且充分混合的水溶液控制体积。总的正向溶解反应以摩尔为基础写为\n$$\\mathrm{CaCO_3(s)} + \\mathrm{CO_2(aq)} + \\mathrm{H_2O(l)} \\rightarrow \\mathrm{Ca^{2+}(aq)} + 2\\,\\mathrm{HCO_3^{-}(aq)}.$$\n所有物种均以摩尔为基础处理，固态方解石过量存在，以维持正向反应的持续进行。定义化学计量系数 $\\nu_i$，其符号约定为：反应物 $\\nu_i<0$，生成物 $\\nu_i>0$。令 $n_i$ 为液相中物种 $i$ 的摩尔数。令 $\\xi$ 为反应进度，令 $V$ 为水溶液体积。体积反应速率 $r$ 定义为 $r = \\frac{1}{V}\\frac{d\\xi}{dt}$，物种 $i$ 的体积生成（或消耗）速率 $r_i$ 定义为 $r_i = \\frac{1}{V}\\frac{dn_i}{dt}$。\n\n仅使用质量守恒定律和反应进度的定义，推导 $r_i$ 和 $r$ 之间以 $\\nu_i$ 表示的关系。然后，对于上述方解石溶解反应，一个反应输运模拟报告的正向体积反应速率为 $r = 3.26815 \\times 10^{-7}$ mol m$^{-3}$ s$^{-1}$。计算与所述符号约定一致的水合钙离子的体积生成速率 $r_{\\mathrm{Ca^{2+}}}$。以 mol m$^{-3}$ s$^{-1}$ 为单位表示最终数值答案，并将答案四舍五入至四位有效数字。",
            "solution": "该问题被验证为具有科学依据、良定且客观。它基于化学动力学和化学计量学的基本原理在地球化学中的应用。所有定义都是标准的，所需数据也已提供，因此该问题是可解的。\n\n该问题要求做两件事：首先，利用化学计量系数 $\\nu_i$ 推导物种 $i$ 的体积生成速率（记为 $r_i$）与总反应的体积反应速率（$r$）之间的一般关系；其次，应用此关系计算特定反应中水合钙离子的生成速率 $r_{\\mathrm{Ca^{2+}}}$。\n\n物种 $i$ 的摩尔数 $n_i$ 的变化与反应进度 $\\xi$ 之间的基本关系由反应的化学计量关系定义。对于反应进度的微分变化 $d\\xi$，物种 $i$ 摩尔数的相应微分变化 $dn_i$ 由下式给出：\n$$dn_i = \\nu_i d\\xi$$\n其中 $\\nu_i$ 是物种 $i$ 的化学计量系数。该方程是通过反应化学计量关系表达的质量守恒定律的直接结果。\n\n为了将其与反应速率联系起来，我们对时间 $t$ 求导：\n$$\\frac{dn_i}{dt} = \\nu_i \\frac{d\\xi}{dt}$$\n问题将物种 $i$ 的体积生成速率定义为 $r_i = \\frac{1}{V}\\frac{dn_i}{dt}$，将总的体积反应速率定义为 $r = \\frac{1}{V}\\frac{d\\xi}{dt}$，其中 $V$ 是水溶液的恒定体积。假设体积 $V$ 恒定，我们可以将上式两边同除以 $V$：\n$$\\frac{1}{V}\\frac{dn_i}{dt} = \\nu_i \\left(\\frac{1}{V}\\frac{d\\xi}{dt}\\right)$$\n将 $r_i$ 和 $r$ 的定义代入此方程，得到一般关系：\n$$r_i = \\nu_i r$$\n这是所要求推导的第一部分。它表明，任何物种的生成或消耗速率都与总反应速率成正比，比例常数即为该物种的化学计量系数。\n\n接下来，我们将此结果应用于特定的方解石溶解反应：\n$$\\mathrm{CaCO_3(s)} + \\mathrm{CO_2(aq)} + \\mathrm{H_2O(l)} \\rightarrow \\mathrm{Ca^{2+}(aq)} + 2\\,\\mathrm{HCO_3^{-}(aq)}$$\n我们的任务是计算水合钙离子的体积生成速率 $r_{\\mathrm{Ca^{2+}}}$。因此，物种 $i$ 是 $\\mathrm{Ca^{2+}}$。\n\n从配平的化学方程式中，我们确定 $\\mathrm{Ca^{2+}}$ 的化学计量系数。物种 $\\mathrm{Ca^{2+}}$ 是生成物，其化学计量数为 $1$。根据问题陈述中给出的符号约定（生成物 $\\nu_i > 0$），化学计量系数为 $\\nu_{\\mathrm{Ca^{2+}}} = +1$。\n\n问题陈述中指出，正向体积反应速率为 $r = 3.26815 \\times 10^{-7} \\, \\text{mol m}^{-3} \\text{s}^{-1}$。\n\n使用推导出的关系式 $r_i = \\nu_i r$，我们现在可以计算 $r_{\\mathrm{Ca^{2+}}}$：\n$$r_{\\mathrm{Ca^{2+}}} = \\nu_{\\mathrm{Ca^{2+}}} \\cdot r$$\n代入已知值：\n$$r_{\\mathrm{Ca^{2+}}} = (+1) \\cdot (3.26815 \\times 10^{-7} \\, \\text{mol m}^{-3} \\text{s}^{-1})$$\n$$r_{\\mathrm{Ca^{2+}}} = 3.26815 \\times 10^{-7} \\, \\text{mol m}^{-3} \\text{s}^{-1}$$\n问题要求将最终答案四舍五入至四位有效数字。第五位有效数字是 $1$，小于 $5$，因此我们向下舍入。\n$$r_{\\mathrm{Ca^{2+}}} \\approx 3.268 \\times 10^{-7} \\, \\text{mol m}^{-3} \\text{s}^{-1}$$",
            "answer": "$$\\boxed{3.268 \\times 10^{-7}}$$"
        },
        {
            "introduction": "地球化学系统通常涉及多种反应物，导致复杂的速率定律。然而，当其中一种反应物的浓度远超其他反应物，或其浓度被缓冲时，动力学过程可以得到显著简化。本练习将演示推导伪一级反应速率定律这一强大技术，从而对控制微分方程进行解析求解 。这是地球化学建模中一种常见且必要的简化方法，它能使复杂问题变得易于处理。",
            "id": "4096828",
            "problem": "在一个代表沉积物柱中孔隙水控制体积的混合均匀的含水微域中，一个双分子反应根据 $A + B \\to P$ 将溶解的反应物 $A$ 和溶解的氧化剂 $B$ 转化为惰性产物 $P$。假设以下物理上合理的条件：\n\n- 基元步骤的质量作用速率定律成立，在稀溶液条件下，活度可近似为浓度，因此体积反应速率满足 $r = k[A][B]$，其中 $k$ 是在所关注的时间窗口内不随温度变化的速率常数。\n- 氧化剂 $B$ 通过与大型外部储库（例如，与上覆大气的气液交换）的快速交换而被缓冲，从而在控制体积内精确地维持 $[B](t) = B_0$ 恒定。\n- 系统对于 $A$ 和 $P$ 是封闭的（没有平流输入或输出），并且溶液保持等温，因此 $k$ 是恒定的。\n\n从速率定律的微分形式和质量作用动力学所蕴含的物种平衡出发，推导一个闭式解析表达式，用于计算将 $A$ 的浓度从其初始值 $[A](0) = A_0$ 降低到 $[A](t) = A_0/2$ 所需的时间。将您的最终结果表示为仅包含 $k$ 和 $B_0$ 的简化解析表达式。如果进行数值计算，时间应以秒为单位报告。不要代入数值。最终的方框答案中不要包含单位。",
            "solution": "用户提供的问题陈述已经过验证，被认为是科学合理的、适定的、客观的且内部一致的。它代表了化学动力学中的一个标准问题，具体来说是一个准一级反应情景。可以开始求解过程。\n\n问题指定了一个双分子基元反应 $A + B \\to P$。根据质量作用动力学原理，反应物 $A$ 的浓度（记作 $[A]$）的变化率与反应的体积反应速率 $r$ 通过其化学计量系数（为-1）相关联。\n$$\n\\frac{d[A]}{dt} = -r\n$$\n速率定律为 $r = k[A][B]$，其中 $k$ 是二级速率常数，$[A]$ 是反应物 $A$ 的浓度，$[B]$ 是反应物 $B$ 的浓度。将速率定律代入 $A$ 的物种平衡，得到控制微分方程：\n$$\n\\frac{d[A]}{dt} = -k[A][B]\n$$\n提供的一个关键条件是，由于缓冲作用，反应物 $B$ 的浓度随时间保持恒定，即对于所有 $t \\ge 0$，都有 $[B](t) = B_0$。将此条件代入微分方程，可简化系统：\n$$\n\\frac{d[A]}{dt} = -k[A]B_0\n$$\n该方程描述了一个准一级反应，因为真实的二级速率常数 $k$ 与恒定浓度 $B_0$ 的乘积表现为单个的准一级速率常数。我们定义这个常数为 $k' = k B_0$。微分方程变为：\n$$\n\\frac{d[A]}{dt} = -k'[A]\n$$\n这是一个一阶线性齐次常微分方程。它可以通过分离变量法求解。重排方程以分离变量 $[A]$ 和 $t$：\n$$\n\\frac{1}{[A]} d[A] = -k' dt = -k B_0 dt\n$$\n为了找到 $A$ 的浓度作为时间的函数，我们对此方程从初始状态（时间 $t=0$，浓度为 $[A](0) = A_0$）积分到任意状态（时间 $t$，浓度为 $[A](t)$）。\n$$\n\\int_{A_0}^{[A](t)} \\frac{1}{[A]} d[A] = \\int_0^t -k B_0 dt\n$$\n左侧的积分是浓度的自然对数：\n$$\n\\left[ \\ln([A]) \\right]_{A_0}^{[A](t)} = \\ln([A](t)) - \\ln(A_0) = \\ln\\left(\\frac{[A](t)}{A_0}\\right)\n$$\n右侧的积分是：\n$$\n-k B_0 \\int_0^t dt = -k B_0 [t]_0^t = -k B_0 t\n$$\n令两个结果相等，得到积分速率定律：\n$$\n\\ln\\left(\\frac{[A](t)}{A_0}\\right) = -k B_0 t\n$$\n问题要求的是使 $A$ 的浓度降低到其初始值一半所需的特定时间，我们可将其记作 $t_{1/2}$。该条件表示为 $[A](t_{1/2}) = A_0/2$。我们将其代入积分速率定律：\n$$\n\\ln\\left(\\frac{A_0/2}{A_0}\\right) = -k B_0 t_{1/2}\n$$\n简化对数的参数：\n$$\n\\ln\\left(\\frac{1}{2}\\right) = -k B_0 t_{1/2}\n$$\n使用对数恒等式 $\\ln(1/x) = -\\ln(x)$，我们得到：\n$$\n-\\ln(2) = -k B_0 t_{1/2}\n$$\n最后，我们通过除以 $-k B_0$ 来求解时间 $t_{1/2}$：\n$$\nt_{1/2} = \\frac{\\ln(2)}{k B_0}\n$$\n这是在指定的准一级反应条件下，反应物 $A$ 的半衰期的闭式解析表达式，仅用给定的常数 $k$ 和 $B_0$ 表示。",
            "answer": "$$\\boxed{\\frac{\\ln(2)}{k B_0}}$$"
        },
        {
            "introduction": "尽管解析解十分优雅，但大多数现实世界中的地球化学问题，特别是涉及快速反应和物质输运的“刚性”系统，都必须依赖数值方法求解。算子分裂法是一种常用策略，它将不同过程解耦处理，但同时也引入了误差。这个基于编程的实践将理论付诸实践，要求你实现并评估一种常见的数值方案 。通过将算子分裂法的结果与完全耦合解进行比较，你将亲身体会到计算效率与准确性之间的权衡，这也是计算地球化学领域的一个核心主题。",
            "id": "4096819",
            "problem": "您的任务是构建、分析和计算一个算子分裂法相对于全耦合解的精度，该问题涉及一个充分混合的地球化学反应器中的刚性反应输运问题。背景是一个连续搅拌釜反应器（CSTR），它代表了一维反应输运系统中的单个控制体积。两种水相物质，$C$（例如，溶解的钙）和 $D$（例如，溶解的碳酸盐），当相对于指定的溶解度达到过饱和状态时，可以通过反应 $C + D \\rightarrow S$ 沉淀为固相 $S$。目标是评估算子分裂误差作为时间步长 $\\Delta t$ 和动力学耦合强度的函数。\n\n基础理论：\n- 具有流入和流出（停留时间为 $\\tau$）的连续搅拌釜反应器（CSTR）的质量守恒。\n- 基于质量作用动力学和输运定律的确定性常微分方程（ODE）。\n- 由饱和指数决定的速率定律所控制的过饱和驱动的动力学沉淀。\n- 对全耦合系统使用刚性求解器进行数值积分，并采用顺序算子分裂方案。\n\n模型规格：\n- 水相物质浓度 $C(t)$ 和 $D(t)$ 的单位为 $\\mathrm{mol/L}$，固相 $S(t)$ 的单位为 $\\mathrm{mol/L}$（作为每单位体积沉淀质量的体积当量）。\n- 流入浓度是恒定的：$C_{\\mathrm{in}}$ 和 $D_{\\mathrm{in}}$，单位为 $\\mathrm{mol/L}$。\n- 停留时间为 $\\tau$，单位为 $\\mathrm{s}$。\n- 溶度积为 $K_{\\mathrm{sp}}$，单位为 $\\mathrm{mol^2/L^2}$。\n- 沉淀速率定律为 $r(t) = k \\,\\max\\!\\left( C(t) D(t) - K_{\\mathrm{sp}}, 0 \\right)$，其中 $k$ 的单位为 $\\mathrm{L/(mol\\cdot s)}$；忽略溶解过程（无负速率）。\n- 全耦合常微分方程组为\n$$\n\\frac{dC}{dt} = \\frac{C_{\\mathrm{in}} - C}{\\tau} - r(t), \\quad\n\\frac{dD}{dt} = \\frac{D_{\\mathrm{in}} - D}{\\tau} - r(t), \\quad\n\\frac{dS}{dt} = r(t).\n$$\n- 初始条件为 $C(0) = 0$，$D(0) = 0$，$S(0) = 0$。\n\n要实现的算子分裂：\n- 在每个时间步长 $\\Delta t$ 内进行顺序的类 Strang 一阶分裂，包括：\n  1. 一个时长为 $\\Delta t$ 的纯输运子步骤，其中 $r(t)=0$。\n  2. 一个时长为 $\\Delta t$ 的纯反应子步骤，其中输运被关闭（没有流入/流出项）。\n- 对于 CSTR 中的纯输运子步骤，使用 $C$ 和 $D$ 的线性输运常微分方程的精确解。\n- 对于纯反应子步骤，使用后向欧拉时间离散化来更新 $C$、$D$ 和 $S$，同时强制非负性和仅沉淀约束 $r \\ge 0$。\n- 您必须确保纯反应子步骤在化学计量上是守恒的，即在该子步骤中，$C$ 和 $D$ 的消耗量相等，并且 $S$ 的增加量与此相同。\n\n精度评估：\n- 对于每个测试用例，使用刚性常微分方程积分器计算在固定时间范围 $T$ 内的参考全耦合解，然后使用固定的时间步长 $\\Delta t$ 计算在相同时间范围 $T$ 内的算子分裂解。报告最终浓度的绝对误差，形式为 $|C_{\\mathrm{split}}(T) - C_{\\mathrm{ref}}(T)|$、 $|D_{\\mathrm{split}}(T) - D_{\\mathrm{ref}}(T)|$ 和 $|S_{\\mathrm{split}}(T) - S_{\\mathrm{ref}}(T)|$。\n\n参数和单位：\n- 使用 $C_{\\mathrm{in}} = 1 \\times 10^{-3}\\,\\mathrm{mol/L}$，$D_{\\mathrm{in}} = 1 \\times 10^{-3}\\,\\mathrm{mol/L}$，$\\tau = 300\\,\\mathrm{s}$，$K_{\\mathrm{sp}} = 2 \\times 10^{-7}\\,\\mathrm{mol^2/L^2}$，以及 $T = 3600\\,\\mathrm{s}$。\n- 耦合强度由动力学常数 $k$ 表征，单位为 $\\mathrm{L/(mol\\cdot s)}$。\n- 所有报告的误差必须以 $\\mathrm{mol/L}$ 为单位的十进制浮点数表示。\n\n测试套件：\n- 用例 1：$\\Delta t = 10\\,\\mathrm{s}$，$k = 1 \\times 10^{-1}\\,\\mathrm{L/(mol\\cdot s)}$（中等时间步长，慢反应）。\n- 用例 2：$\\Delta t = 100\\,\\mathrm{s}$，$k = 10\\,\\mathrm{L/(mol\\cdot s)}$（刚性反应，中等时间步长）。\n- 用例 3：$\\Delta t = 600\\,\\mathrm{s}$，$k = 10\\,\\mathrm{L/(mol\\cdot s)}$（刚性反应，大时间步长）。\n- 用例 4：$\\Delta t = 0.5\\,\\mathrm{s}$，$k = 1 \\times 10^{-3}\\,\\mathrm{L/(mol\\cdot s)}$（极小时间步长，极慢反应）。\n\n数值要求：\n- 全耦合解必须使用能够处理大 $k$ 值和快速瞬变的刚性积分器计算。\n- 算子分裂解必须对纯输运子步骤使用精确的 CSTR 输运更新，并对纯反应子步骤使用后向欧拉法，以确保在刚性条件下的稳定性。\n- 在所有时刻强制执行 $C \\ge 0$，$D \\ge 0$ 和 $S \\ge 0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表，每个内部列表包含对应测试用例的三个误差 $\\left[|C_{\\mathrm{split}}(T) - C_{\\mathrm{ref}}(T)|,|D_{\\mathrm{split}}(T) - D_{\\mathrm{ref}}(T)|,|S_{\\mathrm{split}}(T) - S_{\\mathrm{ref}}(T)|\\right]$。例如，输出应类似于 $[[e_{C,1},e_{D,1},e_{S,1}],[e_{C,2},e_{D,2},e_{S,2}],\\dots]$，其中每个 $e_{\\cdot,i}$ 是一个单位为 $\\mathrm{mol/L}$ 的十进制浮点数。",
            "solution": "该问题是有效的。它提出了一个在计算地球化学领域中定义明确、有科学依据的任务，特别是评估算子分裂法在刚性反应输运问题中的精度。所有必要的参数、方程和数值程序都已明确定义。\n\n解决方案将分为三个主要部分：\n1.  一个使用刚性求解器计算常微分方程（ODE）全耦合系统的参考解的函数。\n2.  一个使用指定的顺序算子分裂方案计算近似解的函数。\n3.  一个主程序，为每个测试用例执行这两种计算，计算绝对误差，并按要求格式化结果。\n\n### 1. 全耦合参考解\n\n系统状态由向量 $Y(t) = [C(t), D(t), S(t)]^T$ 描述。控制常微分方程组为：\n$$\n\\frac{dY}{dt} = f(t, Y)\n$$\n其中\n$$\n\\begin{align*}\n\\frac{dC}{dt} = \\frac{C_{\\mathrm{in}} - C}{\\tau} - r(t) \\\\\n\\frac{dD}{dt} = \\frac{D_{\\mathrm{in}} - D}{\\tau} - r(t) \\\\\n\\frac{dS}{dt} = r(t)\n\\end{align*}\n$$\n反应速率 $r(t)$ 由 $r(t) = k \\cdot \\max(C(t)D(t) - K_{\\mathrm{sp}}, 0)$ 给出。这是一个刚性系统，特别是当速率常数 $k$ 值很大时。我们将使用 `scipy.integrate.solve_ivp` 函数及 `'Radau'` 方法，这是一种适用于刚性问题的隐式 Runge-Kutta 方法。求解器将从 $t=0$ 运行到 $t=T$，初始条件为 $Y(0) = [0, 0, 0]^T$。此求解器在 $t=T$ 时得到的高精度结果将作为我们的参考解，即 $[C_{\\mathrm{ref}}(T), D_{\\mathrm{ref}}(T), S_{\\mathrm{ref}}(T)]$。\n\n### 2. 算子分裂解\n\n算子分裂法在每个小时间步长 $\\Delta t$ 内将输运过程和反应过程解耦。我们将使用顺序非迭代（Lie-Trotter）分裂方案。对于从 $t_i$ 到 $t_{i+1} = t_i + \\Delta t$ 的每个时间步，我们执行两个子步骤：\n\n**子步骤 A：纯输运**\n首先，我们求解时长为 $\\Delta t$ 的纯输运方程：\n$$\n\\frac{dC}{dt} = \\frac{C_{\\mathrm{in}} - C}{\\tau}, \\quad \\frac{dD}{dt} = \\frac{D_{\\mathrm{in}} - D}{\\tau}, \\quad \\frac{dS}{dt} = 0\n$$\n从时间 $t_i$ 的状态 $[C_i, D_i, S_i]$ 开始，这些线性常微分方程有精确的解析解。输运子步骤之后的状态，记为 $[C^*, D^*, S^*]$，是：\n$$\n\\begin{align*}\nC^* = C_{\\mathrm{in}} + (C_i - C_{\\mathrm{in}}) e^{-\\Delta t/\\tau} \\\\\nD^* = D_{\\mathrm{in}} + (D_i - D_{\\mathrm{in}}) e^{-\\Delta t/\\tau} \\\\\nS^* = S_i\n\\end{align*}\n$$\n\n**子步骤 B：纯反应**\n接下来，我们从中间状态 $[C^*, D^*, S^*]$ 开始，求解时长为 $\\Delta t$ 的纯反应方程：\n$$\n\\frac{dC}{dt} = -r(t), \\quad \\frac{dD}{dt} = -r(t), \\quad \\frac{dS}{dt} = r(t)\n$$\n为了稳定性，我们使用后向（隐式）欧拉法。设 $\\Delta C_{\\mathrm{rxn}}$ 为在时间步长 $\\Delta t$ 内反应消耗的 $C$（和 $D$）的总量。那么在时间 $t_{i+1}$ 的状态是 $C_{i+1} = C^* - \\Delta C_{\\mathrm{rxn}}$，$D_{i+1} = D^* - \\Delta C_{\\mathrm{rxn}}$，以及 $S_{i+1} = S^* + \\Delta C_{\\mathrm{rxn}}$。$C$ 的后向欧拉离散化为：\n$$\n\\frac{C_{i+1} - C^*}{\\Delta t} = -r(t_{i+1}) \\implies \\frac{-(C^* - C_{i+1})}{\\Delta t} = -k \\cdot \\max(C_{i+1}D_{i+1} - K_{\\mathrm{sp}}, 0)\n$$\n将 $C_{i+1}$ 和 $D_{i+1}$ 用 $\\Delta C_{\\mathrm{rxn}}$ 的表达式代入：\n$$\n\\frac{\\Delta C_{\\mathrm{rxn}}}{\\Delta t} = k \\cdot \\max((C^* - \\Delta C_{\\mathrm{rxn}})(D^* - \\Delta C_{\\mathrm{rxn}}) - K_{\\mathrm{sp}}, 0)\n$$\n如果输运后的离子活度积 $IAP = C^*D^*$ 小于或等于 $K_{\\mathrm{sp}}$，则不发生反应，且 $\\Delta C_{\\mathrm{rxn}} = 0$。如果 $IAP > K_{\\mathrm{sp}}$，我们必须求解 $\\Delta C_{\\mathrm{rxn}} > 0$：\n$$\n\\frac{\\Delta C_{\\mathrm{rxn}}}{k \\Delta t} = (C^* - \\Delta C_{\\mathrm{rxn}})(D^* - \\Delta C_{\\mathrm{rxn}}) - K_{\\mathrm{sp}}\n$$\n这可以重新整理为关于 $\\Delta C_{\\mathrm{rxn}}$ 的一元二次方程：\n$$\n(\\Delta C_{\\mathrm{rxn}})^2 - \\left( C^* + D^* + \\frac{1}{k \\Delta t} \\right) \\Delta C_{\\mathrm{rxn}} + (C^*D^* - K_{\\mathrm{sp}}) = 0\n$$\n这是一个形如 $a x^2 + b x + c = 0$ 的方程，其中 $x = \\Delta C_{\\mathrm{rxn}}$，$a=1$，$b = -(C^* + D^* + 1/(k \\Delta t))$，以及 $c = C^*D^* - K_{\\mathrm{sp}}$。具有物理意义的解是两个正根中较小的一个，可以使用公式 $x = 2c / (-b + \\sqrt{b^2 - 4ac})$ 可靠地求得。我们还必须强制执行浓度不能为负的物理约束，因此 $\\Delta C_{\\mathrm{rxn}} \\le \\min(C^*, D^*)$。\n\n这个过程重复 $N = T/\\Delta t$ 步，以获得最终状态 $[C_{\\mathrm{split}}(T), D_{\\mathrm{split}}(T), S_{\\mathrm{split}}(T)]$。\n\n### 3. 误差计算\n\n对于由一组参数 $(\\Delta t, k)$ 定义的每个测试用例，我们将计算 $Y_{\\mathrm{ref}}(T)$ 和 $Y_{\\mathrm{split}}(T)$。然后计算绝对误差向量为 $|Y_{\\mathrm{split}}(T) - Y_{\\mathrm{ref}}(T)|$。最终输出将是一个包含所有测试用例的这些误差向量的列表。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Constructs, analyzes, and computes the accuracy of an operator-splitting method\n    versus a fully coupled solution for a stiff reactive transport problem.\n    \"\"\"\n\n    # General parameters from the problem statement\n    C_in = 1e-3  # mol/L\n    D_in = 1e-3  # mol/L\n    tau = 300.0  # s\n    K_sp = 2e-7  # mol^2/L^2\n    T = 3600.0   # s\n    y0 = [0.0, 0.0, 0.0]  # Initial conditions [C(0), D(0), S(0)]\n\n    # Test cases from the problem statement\n    test_cases = [\n        {'dt': 10.0, 'k': 1e-1},  # Case 1\n        {'dt': 100.0, 'k': 10.0}, # Case 2\n        {'dt': 600.0, 'k': 10.0}, # Case 3\n        {'dt': 0.5, 'k': 1e-3}    # Case 4\n    ]\n\n    def compute_reference_solution(k_val):\n        \"\"\"\n        Computes the reference solution using a stiff ODE solver for the\n        fully coupled system.\n        \"\"\"\n        def ode_system(t, y, k):\n            C, D, S = y\n            # Ensure non-negativity for physical realism during intermediate steps\n            C = max(0.0, C)\n            D = max(0.0, D)\n            \n            dydt = np.zeros(3)\n            \n            transport_C = (C_in - C) / tau\n            transport_D = (D_in - D) / tau\n            \n            ion_product = C * D\n            rate = 0.0\n            if ion_product > K_sp:\n                rate = k * (ion_product - K_sp)\n            \n            dydt[0] = transport_C - rate\n            dydt[1] = transport_D - rate\n            dydt[2] = rate\n            \n            return dydt\n\n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=[0, T],\n            y0=y0,\n            method='Radau',\n            args=(k_val,),\n            dense_output=True,\n            atol=1e-12, # Strict tolerances for a high-quality reference\n            rtol=1e-9\n        )\n        return sol.sol(T)\n\n    def compute_split_solution(k_val, dt_val):\n        \"\"\"\n        Computes the solution using the sequential operator-splitting method.\n        \"\"\"\n        y = np.array(y0, dtype=float)\n        num_steps = int(round(T / dt_val))\n\n        for _ in range(num_steps):\n            # 1. Transport-only substep (exact solution)\n            C_i, D_i, S_i = y\n            exp_term = np.exp(-dt_val / tau)\n            C_star = C_in + (C_i - C_in) * exp_term\n            D_star = D_in + (D_i - D_in) * exp_term\n            S_star = S_i\n\n            # 2. Reaction-only substep (Backward Euler)\n            ion_product = C_star * D_star\n            delta_C_rxn = 0.0\n\n            if ion_product > K_sp:\n                # Solve quadratic equation for Delta_C_rxn\n                # a*x^2 + b*x + c = 0 where x = delta_C_rxn\n                a = 1.0\n                b = -(C_star + D_star + 1.0 / (k_val * dt_val))\n                c = ion_product - K_sp\n                \n                discriminant = b**2 - 4 * a * c\n                \n                if discriminant >= 0:\n                    # Use numerically stable formula for smaller root\n                    # x_small = 2c / (-b + sqrt(b^2 - 4ac))\n                    sqrt_discriminant = np.sqrt(discriminant)\n                    denominator = -b + sqrt_discriminant\n                    if denominator > 0:\n                        delta_C_rxn_unconstrained = (2.0 * c) / denominator\n                    else:\n                        # This case is unlikely given the problem physics\n                        delta_C_rxn_unconstrained = 0.0\n                else:\n                    # Discriminant should not be negative based on analysis\n                    delta_C_rxn_unconstrained = 0.0\n\n                # Enforce non-negativity constraint\n                delta_C_rxn = min(delta_C_rxn_unconstrained, C_star, D_star)\n\n            # Update state vector\n            y[0] = C_star - delta_C_rxn\n            y[1] = D_star - delta_C_rxn\n            y[2] = S_star + delta_C_rxn\n\n        return y\n\n    all_errors = []\n    for params in test_cases:\n        k = params['k']\n        dt = params['dt']\n        \n        # Compute both solutions\n        y_ref = compute_reference_solution(k)\n        y_split = compute_split_solution(k, dt)\n        \n        # Calculate absolute errors\n        errors = np.abs(y_split - y_ref).tolist()\n        all_errors.append(errors)\n    \n    # Format the output as specified\n    sublist_strings = [f\"[{e_c},{e_d},{e_s}]\" for e_c, e_d, e_s in all_errors]\n    final_output = f\"[{','.join(sublist_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}