{
    "hands_on_practices": [
        {
            "introduction": "在离子交换建模中，不同的研究领域和历史背景发展出了多种选择性系数的定义约定，其中Vanselow ($K_V$) 和Gaines–Thomas ($K_{GT}$) 约定最为常用。虽然它们都旨在描述交换反应的相对亲和力，但其数学形式和对交换剂相组成的假设有所不同。这项练习将引导你通过严格的数学推导，建立这两种重要约定之间的转换关系，并应用于具体计算。掌握这种转换能力是理解和比较不同文献来源数据的基本功，也是构建统一热力学模型的第一步。",
            "id": "4083684",
            "problem": "考虑在带有固定负电荷位点 $\\mathrm{X^{-}}$ 的均相理想交换剂上，水溶液中的钠离子 $\\mathrm{Na^{+}}$ 与钙离子 $\\mathrm{Ca^{2+}}$ 之间发生的二元离子交换。交换剂相包含 $\\mathrm{NaX}$ 和 $\\mathrm{CaX_{2}}$，其化学计量关系由电荷平衡决定。假设溶液相和交换剂相均为理想行为，因此交换剂相活度可以用适当的组成分数来表示。该交换反应可写为\n$$2\\,\\mathrm{NaX} + \\mathrm{Ca^{2+}} \\rightleftharpoons \\mathrm{CaX_{2}} + 2\\,\\mathrm{Na^{+}}.$$\n从该反应以活度表示的平衡常数的标准定义出发，并结合此次二元交换的 Vanselow 选择性系数 $K_{V}$ 和 Gaines–Thomas 选择性系数 $K_{GT}$ 的常规定义：\n- 在 Vanselow 框架中，交换剂相活度由基于反离子摩尔数的摩尔分数 $x_{\\mathrm{Na}}$ 和 $x_{\\mathrm{Ca}}$ 表示，其中 $x_{i} = n_{i,\\mathrm{X}}/\\sum_{j} n_{j,\\mathrm{X}}$，$n_{i,\\mathrm{X}}$ 是交换剂上反离子 $i$ 的物质的量。\n- 在 Gaines–Thomas 框架中，交换剂相活度由当量（电荷）分数 $E_{\\mathrm{Na}}$ 和 $E_{\\mathrm{Ca}}$ 表示，其中 $E_{i} = z_{i} n_{i,\\mathrm{X}}/\\sum_{j} z_{j} n_{j,\\mathrm{X}}$，$z_{i}$ 是离子 $i$ 的电荷数。\n\n根据这些定义和反应的化学计量关系，推导出一个仅用 $n_{\\mathrm{Na},\\mathrm{X}}$ 和 $n_{\\mathrm{Ca},\\mathrm{X}}$ 表示 $K_{GT}$ 与 $K_V$ 关系的闭式表达式。然后，对于一个交换剂样品，其中 $n_{\\mathrm{Na},\\mathrm{X}} = 0.54$ mol，$n_{\\mathrm{Ca},\\mathrm{X}} = 0.18$ mol，且测得的 Vanselow 选择性系数 $K_{V} = 0.87$，计算相应的 Gaines–Thomas 选择性系数 $K_{GT}$。将最终系数表示为无量纲数，并将答案保留四位有效数字。",
            "solution": "问题要求针对一个特定的离子交换反应，推导 Gaines–Thomas 选择性系数 $K_{GT}$ 与 Vanselow 选择性系数 $K_V$ 之间的关系，然后根据给定的 $K_V$ 值和交换剂相的组成计算 $K_{GT}$。\n\n离子交换反应如下所示：\n$$2\\,\\mathrm{NaX} + \\mathrm{Ca^{2+}} \\rightleftharpoons \\mathrm{CaX_{2}} + 2\\,\\mathrm{Na^{+}}$$\n其中 $\\mathrm{X^{-}}$ 代表交换剂上的一个固定负电荷位点。对于任何处于平衡状态的反应，其平衡条件是反应物的化学势等于产物的化学势。对于此反应，该条件通过质量作用定律，并以活度 $a_i$ 表示。热力学平衡常数 $K_{eq}$ 为：\n$$K_{eq} = \\frac{a_{\\mathrm{CaX_2}} \\cdot (a_{\\mathrm{Na^+}})^2}{(a_{\\mathrm{NaX}})^2 \\cdot a_{\\mathrm{Ca^{2+}}}}$$\n水相物质的活度为 $a_{\\mathrm{Na^+}}$ 和 $a_{\\mathrm{Ca^{2+}}}$。交换剂相物质的活度为 $a_{\\mathrm{NaX}}$ 和 $a_{\\mathrm{CaX_2}}$。\n\n选择性系数是操作上定义的“实用”平衡常数，其中交换剂相物质的活度被可测量的组成分数所取代。问题指出了两种这样的惯例。\n\n1.  **Vanselow 选择性系数 ($K_V$)**：在此框架中，交换剂物质的活度由交换剂上相应反离子的摩尔分数表示。设 $n_{\\mathrm{Na,X}}$ 和 $n_{\\mathrm{Ca,X}}$ 分别为交换剂上钠离子和钙离子的物质的量。摩尔分数为：\n    $$x_{\\mathrm{Na}} = \\frac{n_{\\mathrm{Na,X}}}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}}$$\n    $$x_{\\mathrm{Ca}} = \\frac{n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}}$$\n    通过用这些摩尔分数替代交换剂相物质的活度（$a_{\\mathrm{NaX}} \\rightarrow x_{\\mathrm{Na}}$，$a_{\\mathrm{CaX_2}} \\rightarrow x_{\\mathrm{Ca}}$），Vanselow 选择性系数定义为：\n    $$K_V = \\frac{x_{\\mathrm{Ca}} \\cdot (a_{\\mathrm{Na^+}})^2}{x_{\\mathrm{Na}}^2 \\cdot a_{\\mathrm{Ca^{2+}}}}$$\n\n2.  **Gaines–Thomas 选择性系数 ($K_{GT}$)**：在此框架中，交换剂物质的活度由反离子的当量（电荷）分数表示。离子的电荷数分别为 $z_{\\mathrm{Na}} = 1$ 和 $z_{\\mathrm{Ca}} = 2$。当量分数为：\n    $$E_{\\mathrm{Na}} = \\frac{z_{\\mathrm{Na}} n_{\\mathrm{Na,X}}}{z_{\\mathrm{Na}} n_{\\mathrm{Na,X}} + z_{\\mathrm{Ca}} n_{\\mathrm{Ca,X}}} = \\frac{n_{\\mathrm{Na,X}}}{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}}$$\n    $$E_{\\mathrm{Ca}} = \\frac{z_{\\mathrm{Ca}} n_{\\mathrm{Ca,X}}}{z_{\\mathrm{Na}} n_{\\mathrm{Na,X}} + z_{\\mathrm{Ca}} n_{\\mathrm{Ca,X}}} = \\frac{2n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}}$$\n    通过用这些当量分数替代活度（$a_{\\mathrm{NaX}} \\rightarrow E_{\\mathrm{Na}}$，$a_{\\mathrm{CaX_2}} \\rightarrow E_{\\mathrm{Ca}}$），Gaines–Thomas 选择性系数定义为：\n    $$K_{GT} = \\frac{E_{\\mathrm{Ca}} \\cdot (a_{\\mathrm{Na^+}})^2}{E_{\\mathrm{Na}}^2 \\cdot a_{\\mathrm{Ca^{2+}}}}$$\n\n为了找到 $K_{GT}$ 和 $K_V$ 之间的关系，我们可以将它们的定义表达式相比。包含水相活度的项会消去：\n$$\\frac{K_{GT}}{K_V} = \\frac{\\left( \\frac{E_{\\mathrm{Ca}} \\cdot (a_{\\mathrm{Na^+}})^2}{E_{\\mathrm{Na}}^2 \\cdot a_{\\mathrm{Ca^{2+}}}} \\right)}{\\left( \\frac{x_{\\mathrm{Ca}} \\cdot (a_{\\mathrm{Na^+}})^2}{x_{\\mathrm{Na}}^2 \\cdot a_{\\mathrm{Ca^{2+}}}} \\right)} = \\frac{E_{\\mathrm{Ca}} \\cdot x_{\\mathrm{Na}}^2}{E_{\\mathrm{Na}}^2 \\cdot x_{\\mathrm{Ca}}}$$\n现在，我们将用 $n_{\\mathrm{Na,X}}$ 和 $n_{\\mathrm{Ca,X}}$ 表示的 $x_i$ 和 $E_i$ 的定义代入该比值：\n$$x_{\\mathrm{Na}}^2 = \\left( \\frac{n_{\\mathrm{Na,X}}}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}} \\right)^2$$\n$$x_{\\mathrm{Ca}} = \\frac{n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}}$$\n$$E_{\\mathrm{Na}}^2 = \\left( \\frac{n_{\\mathrm{Na,X}}}{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}} \\right)^2$$\n$$E_{\\mathrm{Ca}} = \\frac{2n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}}$$\n将这些代入 $K_{GT}/K_V$ 的比值表达式中：\n$$\\frac{K_{GT}}{K_V} = \\frac{\\left( \\frac{2n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}} \\right) \\left( \\frac{n_{\\mathrm{Na,X}}}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}} \\right)^2}{\\left( \\frac{n_{\\mathrm{Na,X}}}{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}} \\right)^2 \\left( \\frac{n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}} \\right)}$$\n我们可以重排并简化这个表达式：\n$$\\frac{K_{GT}}{K_V} = \\frac{2n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}} \\cdot \\frac{n_{\\mathrm{Na,X}}^2}{(n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}})^2} \\cdot \\frac{(n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}})^2}{n_{\\mathrm{Na,X}}^2} \\cdot \\frac{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Ca,X}}}$$\n消去项：\n\\begin{itemize}\n    \\item 分子和分母中的 $n_{\\mathrm{Ca,X}}$。\n    \\item 分子和分母中的 $n_{\\mathrm{Na,X}}^2$。\n    \\item 分子和分母中的一个因子 $(n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}})$。\n    \\item 分子和分母中的一个因子 $(n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}})$。\n\\end{itemize}\n这样剩下：\n$$\\frac{K_{GT}}{K_V} = \\frac{2(n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}})}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}}$$\n这就是用 $n_{\\mathrm{Na,X}}$ 和 $n_{\\mathrm{Ca,X}}$ 表示 $K_{GT}$ 与 $K_V$ 关系的闭式表达式。\n\n问题的第二部分是计算在给定条件下 $K_{GT}$ 的值：\n$$n_{\\mathrm{Na,X}} = 0.54\\,\\mathrm{mol}$$\n$$n_{\\mathrm{Ca,X}} = 0.18\\,\\mathrm{mol}$$\n$$K_V = 0.87$$\n首先，我们计算转换因子的值：\n$$\\frac{2(n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}})}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}} = \\frac{2(0.54 + 2(0.18))}{0.54 + 0.18} = \\frac{2(0.54 + 0.36)}{0.72} = \\frac{2(0.90)}{0.72}$$\n该比值简化为：\n$$\\frac{1.8}{0.72} = 2.5$$\n现在我们可以计算 $K_{GT}$：\n$$K_{GT} = K_V \\cdot \\frac{2(n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}})}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}} = 0.87 \\cdot 2.5$$\n$$K_{GT} = 2.175$$\n问题要求将最终答案保留四位有效数字。计算出的值 $2.175$ 已经有四位有效数字，因此无需进一步四舍五入。",
            "answer": "$$\\boxed{2.175}$$"
        },
        {
            "introduction": "任何可靠的地球化学模型的基石都是一套内部一致的热力学数据。然而，实验测得的选择性系数往往由于测量误差而违背热力学基本定律，例如吉布斯自由能作为状态函数所要求的循环一致性原则。这项练习将向你介绍一个在计算地球化学中至关重要的实践任务：数据协调。你将学习如何通过加权最小二乘法，将一组有噪声且不一致的实验数据投影到满足热力学一致性的数学流形上，从而“修正”数据，确保其可用于构建稳健的多组分模型。",
            "id": "4083667",
            "problem": "考虑一组在固定内含状态（温度、压力、离子强度）下，于单一固相交换剂上，满足热力学平衡（TE）的一组有限单价阳离子之间的无量纲离子交换选择性系数。设离子集合由 $i \\in \\{1,\\dots,n\\}$ 索引，对于一个有向有序对 $(i,j)$，测得的无量纲选择性系数为 $K_{ij}^{\\mathrm{meas}}  0$。通过 $k_{ij}^{\\mathrm{meas}} = \\ln K_{ij}^{\\mathrm{meas}}$ 定义对数测量值。循环一致性条件断言，对于任何返回到其起始离子的不同索引的闭环 $(i_{1},i_{2},\\dots,i_{m},i_{1})$，沿该环路的对数之和必须为零，即 $\\sum_{\\ell=1}^{m} k_{i_{\\ell} i_{\\ell+1}}^{\\ast} = 0$，其中 $i_{m+1} \\equiv i_{1}$，并且 $k_{ij}^{\\ast}$ 是与热力学平衡一致的调整后值。等价地，存在一个标量交换势向量 $(t_{1},\\dots,t_{n})$，使得对于所有有向测量对 $(i,j)$，都有 $k_{ij}^{\\ast} = t_{i} - t_{j}$。后者由一致的 $k_{ij}^{\\ast}$ 构成的流形自动满足所有循环约束。\n\n给定通常违反循环一致性的带噪声的测量值，您必须计算测量的对数值到由 $(t_{1},\\dots,t_{n})$ 的存在性所定义的一致值流形上的最小二乘投影，其中使用与每个有向测量对 $(i,j)$ 相关的非负权重 $w_{ij}$。也就是说，找到使加权平方差异和 $\\sum_{(i,j)} w_{ij}\\left((t_{i} - t_{j}) - k_{ij}^{\\mathrm{meas}}\\right)^{2}$ 最小化的 $t$，然后对所有测量对定义 $k_{ij}^{\\ast} = t_{i} - t_{j}$ 和 $K_{ij}^{\\ast} = \\exp(k_{ij}^{\\ast})$。因为势在测量图的每个连通分量上仅在相差一个加性常数的情况下确定，所以您必须通过将每个连通分量中的一个 $t$ 设置为 $0$ 来固定规范，这会在每个分量上产生唯一的最小化子。\n\n将应用于每个测量对的对数域校正量化为 $\\Delta_{ij} = k_{ij}^{\\ast} - k_{ij}^{\\mathrm{meas}}$。对于每个测试用例，报告校正场的两个摘要指标：由 $\\sqrt{\\frac{\\sum_{(i,j)} w_{ij}\\,\\Delta_{ij}^{2}}{\\sum_{(i,j)} w_{ij}}}$ 定义的加权均方根（RMS）校正和最大绝对校正 $\\max_{(i,j)} |\\Delta_{ij}|$。所有量均为无量纲，且必须表示为十进制数（无百分号）。\n\n编写一个完整的、可运行的程序，构建上述的最小二乘投影，并为以下测试套件生成所要求的指标和调整后的选择性系数。每个测试用例由一个有序的离子名称列表和一个有序的有向测量对列表定义，后者包含其无量纲系数和权重，按必须报告输出的确切顺序给出：\n\n- 测试用例 1：\n    - 离子：$\\text{\"Na\"}$、$\\text{\"K\"}$、$\\text{\"Li\"}$。\n    - 带权重的测量对（有序）：$(\\text{\"Na\"},\\text{\"K\"},\\,2.0,\\,1.0)$、$(\\text{\"K\"},\\text{\"Li\"},\\,1.5,\\,1.0)$、$(\\text{\"Li\"},\\text{\"Na\"},\\,0.4,\\,1.0)$。\n\n- 测试用例 2：\n    - 离子：$\\text{\"Na\"}$、$\\text{\"K\"}$、$\\text{\"Cs\"}$、$\\text{\"Li\"}$。\n    - 带权重的测量对（有序）：$(\\text{\"Na\"},\\text{\"K\"},\\,3.0,\\,10.0)$、$(\\text{\"K\"},\\text{\"Cs\"},\\,0.9,\\,1.0)$、$(\\text{\"Cs\"},\\text{\"Li\"},\\,1.2,\\,1.0)$、$(\\text{\"Na\"},\\text{\"Li\"},\\,2.5,\\,5.0)$。\n\n- 测试用例 3：\n    - 离子：$\\text{\"Na\"}$、$\\text{\"K\"}$、$\\text{\"Li\"}$、$\\text{\"Cs\"}$。\n    - 带权重的测量对（有序）：$(\\text{\"Na\"},\\text{\"K\"},\\,1.8,\\,1.0)$、$(\\text{\"Li\"},\\text{\"Cs\"},\\,0.7,\\,1.0)$。\n\n您的程序应为每个测试用例计算：\n- 对数域中的加权均方根校正，$\\sqrt{\\frac{\\sum w_{ij}\\Delta_{ij}^{2}}{\\sum w_{ij}}}$。\n- 对数域中的最大绝对校正，$\\max |\\Delta_{ij}|$.\n- 调整后的无量纲选择性系数 $K_{ij}^{\\ast}$ 的列表，按输入的确切顺序排列。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个列表，格式为 $[\\text{RMS},\\;\\text{MAXABS},\\;[K_{1}^{\\ast},\\dots,K_{m}^{\\ast}]]$, 并在每个测试用例内保留输入对的顺序。例如，格式正确的输出应类似于 $[[\\dots],[\\dots],[\\dots]]$，所有量均为十进制数。",
            "solution": "该问题要求对一组带噪声的、通过实验测量的离子交换选择性系数 $K_{ij}^{\\mathrm{meas}}$进行调整，使其具有热力学一致性。热力学一致性通过存在一组标量交换势 $(t_1, \\dots, t_n)$ 来表达，使得调整后的对数选择性系数 $k_{ij}^{\\ast} = \\ln K_{ij}^{\\ast}$ 可以写成一个简单的差值，$k_{ij}^{\\ast} = t_i - t_j$。此条件对于任何交换反应闭环都自动满足循环一致性规则 $\\sum_{\\ell=1}^{m} k_{i_{\\ell} i_{\\ell+1}}^{\\ast} = 0$。\n\n任务是找到在加权最小二乘意义上最接近测量值 $k_{ij}^{\\mathrm{meas}} = \\ln K_{ij}^{\\mathrm{meas}}$ 的热力学一致值 $k_{ij}^{\\ast}$。这被表述为一个优化问题：找到势向量 $t = (t_1, \\dots, t_n)$，以最小化加权平方差异和 $S(t)$：\n$$\nS(t) = \\sum_{(i,j) \\in E} w_{ij} \\left( (t_i - t_j) - k_{ij}^{\\mathrm{meas}} \\right)^2\n$$\n其中 $E$ 是所有有向测量对 $(i,j)$ 的集合，$w_{ij} \\ge 0$ 是相关的权重。\n\n为求 $S(t)$ 的最小值，我们将关于每个势 $t_m$ 的偏导数设为零：\n$$\n\\frac{\\partial S}{\\partial t_m} = 0 \\quad \\text{对于 } m = 1, \\dots, n\n$$\n导数计算如下：\n$$\n\\frac{\\partial S}{\\partial t_m} = \\sum_{(i,j) \\in E} 2 w_{ij} \\left( (t_i - t_j) - k_{ij}^{\\mathrm{meas}} \\right) \\frac{\\partial(t_i - t_j)}{\\partial t_m}\n$$\n偏导数 $\\frac{\\partial(t_i - t_j)}{\\partial t_m}$ 在 $i=m$ 时为 $1$，在 $j=m$ 时为 $-1$，否则为 $0$。这可以用克罗内克 delta 符号写为 $\\delta_{im} - \\delta_{jm}$。将此代入方程并令结果为零，得到：\n$$\n\\sum_{(i,j) \\in E} w_{ij} \\left( (t_i - t_j) - k_{ij}^{\\mathrm{meas}} \\right) (\\delta_{im} - \\delta_{jm}) = 0\n$$\n根据克罗内克 delta 分解求和，我们对每个 $m$ 得到：\n$$\n\\sum_{j \\text{ s.t. } (m,j)\\in E} w_{mj}((t_m - t_j) - k_{mj}^{\\mathrm{meas}}) - \\sum_{i \\text{ s.t. } (i,m)\\in E} w_{im}((t_i - t_m) - k_{im}^{\\mathrm{meas}}) = 0\n$$\n重排此方程，将未知势 $t$ 与已知测量值 $k^{\\mathrm{meas}}$ 分开，得到一个线性方程组：\n$$\n\\left( \\sum_{j \\text{ s.t. } (m,j)\\in E} w_{mj} + \\sum_{i \\text{ s.t. } (i,m)\\in E} w_{im} \\right) t_m - \\sum_{j \\text{ s.t. } (m,j)\\in E} w_{mj}t_j - \\sum_{i \\text{ s.t. } (i,m)\\in E} w_{im}t_i = \\sum_{j \\text{ s.t. } (m,j)\\in E} w_{mj} k_{mj}^{\\mathrm{meas}} - \\sum_{i \\text{ s.t. } (i,m)\\in E} w_{im} k_{im}^{\\mathrm{meas}}\n$$\n这是一个包含 $n$ 个变量的 $n$ 个线性方程组，可以写成矩阵形式 $At = b$。矩阵 $A$ 是测量图的加权图拉普拉斯矩阵，其中离子是节点，测量是加权边。其元素为：\n$$\nA_{mm} = \\sum_{j \\neq m} (w_{mj} + w_{jm}) \\quad (\\text{如果已测量})\n$$\n$$\nA_{mk} = -(w_{mk} + w_{km}) \\quad \\text{对于 } m \\neq k \\quad (\\text{如果已测量})\n$$\n向量 $b$ 的元素为：\n$$\nb_m = \\sum_{j \\text{ s.t. } (m,j)\\in E} w_{mj} k_{mj}^{\\mathrm{meas}} - \\sum_{i \\text{ s.t. } (i,m)\\in E} w_{im} k_{im}^{\\mathrm{meas}}\n$$\n图拉普拉斯矩阵 $A$ 是奇异的。其零空间由所有条目均相等的向量组成，这反映了物理原理，即势 $t_i$ 仅在相差一个加性常数的情况下确定 ($t_i \\to t_i + c$)。这被称为规范自由度。如果测量图是不连通的，这种自由度独立地适用于每个连通分量。\n\n为了获得唯一解，我们必须固定规范。问题指定通过将图中每个连通分量的一个势 $t_p$ 设置为零来做到这一点。在计算上，这是通过以下方式实现的：\n1. 识别由测量定义的图的连通分量。\n2. 对每个分量，选择一个参考离子（节点）$p$ 并施加约束 $t_p = 0$。这通过将矩阵 $A$ 的第 $p$ 行替换为一行零（除了在第 $p$ 列为 $1$），并将 $b$ 的第 $p$ 个元素设置为 $0$ 来实现。\n3. 在为 $C$ 个连通分量中的每一个应用一个这样的约束后，得到的 $n \\times n$ 矩阵是满秩（秩为 $n$），并且系统 $At=b$ 有唯一解，可以使用标准线性求解器找到。\n\n一旦找到唯一的势向量 $t$，就可以计算调整后的值和所需的指标：\n1. 调整后的对数选择性：对于每个测量对 $(i,j)$，$k_{ij}^{\\ast} = t_i - t_j$。\n2. 调整后的选择性系数：$K_{ij}^{\\ast} = \\exp(k_{ij}^{\\ast})$。\n3. 对数域中的校正：$\\Delta_{ij} = k_{ij}^{\\ast} - k_{ij}^{\\mathrm{meas}}$。\n4. 加权 RMS 校正：$\\sqrt{\\frac{\\sum_{(i,j)} w_{ij}\\,\\Delta_{ij}^{2}}{\\sum_{(i,j)} w_{ij}}}$。\n5. 最大绝对校正：$\\max_{(i,j)} |\\Delta_{ij}|$。\n\n这个过程提供了一种将带噪声的测量值投影到热力学一致流形上的严谨方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse.csgraph import connected_components\n\ndef process_case(ions_list, measured_pairs):\n    \"\"\"\n    Processes a single test case for ion exchange selectivity coefficient adjustment.\n\n    Args:\n        ions_list (list): A list of ion names.\n        measured_pairs (list): A list of tuples, each containing\n                               (from_ion, to_ion, K_meas, weight).\n\n    Returns:\n        list: A list containing [RMS_correction, MaxAbs_correction, [K_star_list]].\n    \"\"\"\n    ion_map = {name: i for i, name in enumerate(ions_list)}\n    n_ions = len(ions_list)\n    \n    # The system is At = b, where A is the weighted graph Laplacian.\n    A = np.zeros((n_ions, n_ions), dtype=np.float64)\n    b = np.zeros(n_ions, dtype=np.float64)\n    \n    log_k_meas = []\n    weights = []\n    \n    # Adjacency matrix for connectivity analysis\n    conn_matrix = np.zeros((n_ions, n_ions), dtype=np.int8)\n\n    for from_ion, to_ion, K_meas, w in measured_pairs:\n        i = ion_map[from_ion]\n        j = ion_map[to_ion]\n        k_meas = np.log(K_meas)\n        \n        log_k_meas.append(k_meas)\n        weights.append(w)\n        \n        # Build the Laplacian matrix A and vector b\n        # A is symmetric, representing the undirected graph structure for the potential problem.\n        A[i, i] += w\n        A[j, j] += w\n        A[i, j] -= w\n        A[j, i] -= w\n        \n        # b_m = sum_{j} w_mj k_mj - sum_{i} w_im k_im\n        b[i] += w * k_meas\n        b[j] -= w * k_meas\n        \n        # Mark edge for connectivity graph\n        conn_matrix[i, j] = 1\n        conn_matrix[j, i] = 1\n\n    # Find connected components to apply gauge fixing\n    n_components, labels = connected_components(csgraph=conn_matrix, directed=False)\n    \n    # Identify a reference node for each component and apply the constraint t_ref = 0.\n    # We select the node with the smallest index in each component as the reference.\n    ref_nodes = {}\n    for i, label in enumerate(labels):\n        if label not in ref_nodes:\n            ref_nodes[label] = i\n    \n    for ref_node_idx in ref_nodes.values():\n        # Enforce t_ref = 0 by modifying the corresponding row in the system At=b.\n        A[ref_node_idx, :] = 0.0\n        A[ref_node_idx, ref_node_idx] = 1.0\n        b[ref_node_idx] = 0.0\n        \n    # Solve for the potentials t. After applying constraints, A is non-singular.\n    t = np.linalg.solve(A, b)\n\n    # Calculate adjusted values and performance metrics\n    deltas = []\n    k_star_list = []\n    \n    for idx, (from_ion, to_ion, K_meas, w) in enumerate(measured_pairs):\n        i = ion_map[from_ion]\n        j = ion_map[to_ion]\n        \n        k_star = t[i] - t[j]\n        k_star_list.append(k_star)\n        \n        delta = k_star - log_k_meas[idx]\n        deltas.append(delta)\n        \n    deltas = np.array(deltas)\n    weights = np.array(weights)\n    \n    sum_w = np.sum(weights)\n    if sum_w == 0:\n        rms_corr = 0.0\n    else:\n        rms_corr = np.sqrt(np.sum(weights * deltas**2) / sum_w)\n    \n    if len(deltas) == 0:\n        max_abs_corr = 0.0\n    else:\n        max_abs_corr = np.max(np.abs(deltas))\n        \n    K_star_list = np.exp(k_star_list).tolist()\n    \n    return [rms_corr, max_abs_corr, K_star_list]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"ions\": [\"Na\", \"K\", \"Li\"],\n            \"pairs\": [(\"Na\", \"K\", 2.0, 1.0), (\"K\", \"Li\", 1.5, 1.0), (\"Li\", \"Na\", 0.4, 1.0)]\n        },\n        {\n            \"ions\": [\"Na\", \"K\", \"Cs\", \"Li\"],\n            \"pairs\": [(\"Na\", \"K\", 3.0, 10.0), (\"K\", \"Cs\", 0.9, 1.0), (\"Cs\", \"Li\", 1.2, 1.0), (\"Na\", \"Li\", 2.5, 5.0)]\n        },\n        {\n            \"ions\": [\"Na\", \"K\", \"Li\", \"Cs\"],\n            \"pairs\": [(\"Na\", \"K\", 1.8, 1.0), (\"Li\", \"Cs\", 0.7, 1.0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case[\"ions\"], case[\"pairs\"])\n        results.append(result)\n\n    result_strings = []\n    for res in results:\n        rms, max_abs, k_stars = res\n        # Format K_star list to not have spaces for a compact representation\n        k_stars_str = f\"[{','.join(map(str, k_stars))}]\"\n        # Format the full result for one test case\n        result_strings.append(f\"[{rms},{max_abs},{k_stars_str}]\")\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在拥有了一套经过验证和协调的热力学参数后，计算地球化学的核心任务便是求解描述复杂系统化学平衡的非线性方程组。这项练习将带你深入地球化学模拟器的“引擎室”，亲手构建一个用于多组分离子交换平衡计算的数值求解器。你将推导Gaines–Thomas模型下的残差函数和雅可比矩阵，并实现带有阻尼和归一化策略的牛顿-拉夫逊算法，以确保求解过程的收敛性和物理真实性。完成这项练习将使你对计算模型的内部工作原理有深刻的理解。",
            "id": "4083708",
            "problem": "考虑一个由 Gaines–Thomas 惯例描述的多组分离子交换体系，其中交换相由 $N$ 种水相阳离子的当量分数 $\\{E_i\\}_{i=1}^N$ 表示，这些阳离子具有整数电荷 $\\{z_i\\}_{i=1}^N$ 和正的水相活度 $\\{a_i\\}_{i=1}^N$。固定一个由 $r$ 索引的参考阳离子，并假设阳离子 $i$ 和参考阳离子 $r$ 之间交换的热力学选择性系数 $\\{K_{ir}^{\\mathrm{GT}}\\}_{i \\neq r}$ 已知。当量分数满足闭合约束 $\\sum_{i=1}^N E_i = 1$ 以及由 Gaines–Thomas 选择性系数所蕴含的质量作用关系：\n$$\nK_{ij}^{\\mathrm{GT}} = \\frac{E_i^{z_j}/E_j^{z_i}}{a_i^{z_j}/a_j^{z_i}} \\quad \\text{对于任意一对 } i,j.\n$$\n对于每个 $i \\neq r$，关注与固定参考阳离子 $r$ 的成对交换，质量作用关系变为：\n$$\nE_i^{z_r} = K_{ir}^{\\mathrm{GT}} \\, E_r^{z_i} \\, \\frac{a_i^{z_r}}{a_r^{z_i}}.\n$$\n您将需要以未知交换相分数 $\\{E_i\\}_{i=1}^N$ 为变量，构建非线性方程组，推导牛顿-拉夫逊方法所需的雅可比矩阵，并实现一个带有阻尼和缩放的、稳健的牛顿-拉夫逊求解器，该求解器在整个迭代过程中强制满足闭合条件 $\\sum_{i=1}^N E_i = 1$。科学依据必须从质量作用定律和 Gaines–Thomas 定义出发，并推导出一个不使用任何简化公式的计算方案。\n\n任务如下：\n- 使用与参考阳离子相关的 $N-1$ 个质量作用关系和单个闭合方程，推导一个维度为 $N$ 的残差函数 $\\mathbf{F}(\\mathbf{E}) = \\mathbf{0}$。对质量作用关系进行对数变换，以避免数值下溢，并确保正性约束在公式中显式表达。\n- 对所有方程和所有未知数，推导雅可比矩阵元素 $\\partial F_k / \\partial E_j$。\n- 讨论用于强制执行 $\\sum_{i=1}^N E_i = 1$ 的缩放策略，以及在迭代期间用于维持 $E_i  0$ 的阻尼作用。实现一种方法，在每个被接受的牛顿步之后对迭代结果进行归一化，以精确满足闭合条件。\n- 在一个程序中实现一个带有回溯线搜索（阻尼）的牛顿-拉夫逊求解器，该程序接受预定义的测试用例，并输出收敛后的交换相分数。\n\n本问题中的所有量均为无量纲。您的程序必须实现该方法，并解决以下测试套件，每个套件由一个元组 $(\\{z_i\\}, \\{a_i\\}, \\{K_{ir}^{\\mathrm{GT}}\\}, r)$ 描述：\n1. 包含一价和二价阳离子的正常三元体系：$N=3$，物种顺序为 $\\{\\mathrm{Na}^+, \\mathrm{K}^+, \\mathrm{Ca}^{2+}\\}$，$r = 0$（参考离子为 $\\mathrm{Na}^+$），电荷 $\\{z_i\\} = \\{1, 1, 2\\}$，活度 $\\{a_i\\} = \\{0.01, 0.005, 0.002\\}$，选择性系数 $\\{K_{ir}^{\\mathrm{GT}}\\}$ 其中 $K_{1,0}^{\\mathrm{GT}} = 0.8$ 且 $K_{2,0}^{\\mathrm{GT}} = 3.0$。\n2. 具有强烈二价偏好的二元交换：$N=2$，物种顺序为 $\\{\\mathrm{Na}^+, \\mathrm{Ca}^{2+}\\}$，$r = 0$，电荷 $\\{1, 2\\}$，活度 $\\{0.001, 0.1\\}$，选择性系数 $K_{1,0}^{\\mathrm{GT}} = 15.0$。\n3. 含痕量一价离子的边缘情况：$N=3$，物种 $\\{\\mathrm{Na}^+, \\mathrm{Li}^+, \\mathrm{Ca}^{2+}\\}$，$r = 0$，电荷 $\\{1, 1, 2\\}$，活度 $\\{0.01, 10^{-8}, 0.005\\}$，选择性系数 $K_{1,0}^{\\mathrm{GT}} = 0.9$，$K_{2,0}^{\\mathrm{GT}} = 2.0$。\n4. 选择性相等、活度相等的平衡一价三元体系：$N=3$，物种 $\\{\\mathrm{Na}^+, \\mathrm{K}^+, \\mathrm{NH}_4^+\\}$，$r = 0$，电荷 $\\{1, 1, 1\\}$，活度 $\\{0.1, 0.1, 0.1\\}$，选择性系数 $K_{1,0}^{\\mathrm{GT}} = 1.0$，$K_{2,0}^{\\mathrm{GT}} = 1.0$。\n\n您的程序应生成单行输出，其中包含测试用例的交换相分数解，格式为一个由方括号括起来的逗号分隔列表，其中每个元素本身是代表该用例的 $\\{E_i\\}$ 的、由方括号括起来的浮点数逗号分隔列表（例如，“[[E_1,E_2,...],[...],...]”）。输出不得包含空格。\n\n因此，要求的最终输出类型是浮点数列表的列表。数值求解器必须是确定性的，并且只能使用指定的运行时环境。",
            "solution": "该问题是有效的，因为它科学地基于化学平衡原理（Gaines-Thomas 离子交换模型），是一个包含 $N$ 个方程和 $N$ 个未知数的适定问题，并且所有必要数据都已客观地提供。任务是推导并实现一个数值求解器，这是计算科学中的一个标准流程。\n\n### 1. 非线性方程组的构建\n\n所关注的体系涉及 $N$ 种阳离子，未知数是它们在交换相中的当量分数，记为向量 $\\mathbf{E} = (E_1, E_2, \\dots, E_N)^T$。这些未知数必须满足两组条件：质量作用定律和闭合约束。\n\n阳离子 $i$ 与参考阳离子 $r$ 交换的 Gaines-Thomas 质量作用关系由下式给出：\n$$\nK_{ir}^{\\mathrm{GT}} = \\frac{E_i^{z_r}/E_r^{z_i}}{a_i^{z_r}/a_r^{z_i}}\n$$\n其中 $z_i$ 和 $z_r$ 是整数电荷，$a_i$ 和 $a_r$ 是水相活度。整理该表达式可得：\n$$\nE_i^{z_r} = K_{ir}^{\\mathrm{GT}} \\, E_r^{z_i} \\, \\frac{a_i^{z_r}}{a_r^{z_i}}\n$$\n这提供了 $N-1$ 个方程，每个 $i \\neq r$ 对应一个。\n\n为了提高数值稳定性并自然地处理正性约束 $E_i  0$，我们按照问题陈述的建议，对这 $N-1$ 个方程取自然对数：\n$$\nz_r \\ln E_i = \\ln(K_{ir}^{\\mathrm{GT}}) + z_i \\ln E_r + z_r \\ln a_i - z_i \\ln a_r\n$$\n通过将每个方程设为零，我们可以为 $i \\in \\{1, \\dots, N\\}, i \\neq r$ 定义一组 $N-1$ 个残差函数 $F_i(\\mathbf{E})$：\n$$\nF_i(\\mathbf{E}) = z_r \\ln E_i - z_i \\ln E_r - \\left( \\ln(K_{ir}^{\\mathrm{GT}}) + z_r \\ln a_i - z_i \\ln a_r \\right) = 0\n$$\n对于给定的问题实例，括号中的项是一个常数。我们将其定义为常数 $C_i$：\n$$\nC_i = \\ln(K_{ir}^{\\mathrm{GT}}) + z_r \\ln a_i - z_i \\ln a_r = \\ln\\left(K_{ir}^{\\mathrm{GT}} \\frac{a_i^{z_r}}{a_r^{z_i}}\\right)\n$$\n因此，这 $N-1$ 个质量作用残差方程为：\n$$\nF_i(\\mathbf{E}) = z_r \\ln E_i - z_i \\ln E_r - C_i = 0 \\quad \\text{对于 } i \\neq r\n$$\n闭合系统所需的第 $N$ 个方程是闭合约束，它指出所有当量分数的总和必须为1：\n$$\n\\sum_{j=1}^N E_j = 1\n$$\n我们将其构建为一个残差方程，并将其分配给索引 $r$：\n$$\nF_r(\\mathbf{E}) = \\sum_{j=1}^N E_j - 1 = 0\n$$\n将这些方程组合起来，得到最终的 $N$ 维残差向量函数 $\\mathbf{F}(\\mathbf{E}) = (F_1, \\dots, F_N)^T$，在解处该函数必须等于零向量 $\\mathbf{0}$。\n\n### 2. 雅可比矩阵的推导\n\n牛顿-拉夫逊方法需要残差函数 $\\mathbf{F}(\\mathbf{E})$ 的雅可比矩阵 $J$，其元素由 $J_{ki} = \\partial F_k / \\partial E_i$ 给出。我们针对每种类型的残差方程推导这些偏导数。\n\n**情况1：质量作用方程 ($k \\neq r$)**\n残差为 $F_k(\\mathbf{E}) = z_r \\ln E_k - z_k \\ln E_r - C_k$。我们计算它对每个 $E_i$ 的偏导数：\n- 如果 $i=k$：导数是关于 $E_k$ 的。\n$$\n\\frac{\\partial F_k}{\\partial E_k} = \\frac{\\partial}{\\partial E_k} (z_r \\ln E_k) = \\frac{z_r}{E_k}\n$$\n- 如果 $i=r$：导数是关于 $E_r$ 的。\n$$\n\\frac{\\partial F_k}{\\partial E_r} = \\frac{\\partial}{\\partial E_r} (-z_k \\ln E_r) = -\\frac{z_k}{E_r}\n$$\n- 如果 $i \\neq k$ 且 $i \\neq r$：变量 $E_i$ 不出现在 $F_k$ 中。\n$$\n\\frac{\\partial F_k}{\\partial E_i} = 0\n$$\n\n**情况2：闭合方程 ($k = r$)**\n残差为 $F_r(\\mathbf{E}) = \\sum_{j=1}^N E_j - 1$。\n- 对于任何 $i \\in \\{1, \\dots, N\\}$：\n$$\n\\frac{\\partial F_r}{\\partial E_i} = \\frac{\\partial}{\\partial E_i} \\left( \\sum_{j=1}^N E_j - 1 \\right) = 1\n$$\n总之，雅可比矩阵 $J$ 的元素为：\n$$\nJ_{ki} = \\frac{\\partial F_k}{\\partial E_i} = \\begin{cases}\n1  \\text{如果 } k=r \\\\\nz_r/E_k  \\text{如果 } k \\neq r \\text{ 且 } i=k \\\\\n-z_k/E_r  \\text{如果 } k \\neq r \\text{ 且 } i=r \\\\\n0  \\text{如果 } k \\neq r \\text{ 且 } i \\notin \\{k, r\\}\n\\end{cases}\n$$\n\n### 3. 带有阻尼和归一化的牛顿-拉夫逊方法\n\n牛顿-拉夫逊迭代通过求解线性系统：\n$$\nJ(\\mathbf{E}^{(m)}) \\Delta\\mathbf{E}^{(m)} = -\\mathbf{F}(\\mathbf{E}^{(m)})\n$$\n来求解更新步长 $\\Delta\\mathbf{E}^{(m)}$，然后设置 $\\mathbf{E}^{(m+1)} = \\mathbf{E}^{(m)} + \\Delta\\mathbf{E}^{(m)}$，从而将当前估计值 $\\mathbf{E}^{(m)}$ 更新为新的估计值 $\\mathbf{E}^{(m+1)}$。为确保稳健性，我们引入了阻尼和归一化。\n\n**为保证正性 ($E_i  0$) 的阻尼**：我们公式中的对数项 $\\ln(E_i)$ 要求所有分数 $E_i$ 在整个迭代过程中保持严格为正。一个完整的牛顿步长 $\\Delta\\mathbf{E}$ 并不能保证这一点。我们引入一个阻尼因子 $\\alpha \\in (0, 1]$，并使用一个较小的步长进行更新，$\\mathbf{E}_{\\text{trial}} = \\mathbf{E}^{(m)} + \\alpha \\Delta\\mathbf{E}^{(m)}$。采用回溯线搜索来找到一个合适的 $\\alpha$：\n1. 从 $\\alpha = 1$ 开始。\n2. 检查 $\\mathbf{E}_{\\text{trial}}$ 的所有分量是否为正。\n3. 如果不是，则减小 $\\alpha$（例如，$\\alpha \\leftarrow \\alpha/2$）并重复，直到实现正性。\n这确保了任何对数的参数始终有效，从而防止数值计算失败。\n\n**为满足闭合条件 ($\\sum E_i = 1$) 的归一化**：问题要求迭代值满足闭合约束。尽管牛顿步长被构造成位于平面 $\\sum \\Delta E_i = 0$ 上（如果初始时 $\\sum E_i^{(m)} = 1$），但浮点误差可能会累积。为了在每一步之后都精确地强制执行该约束，我们对更新后的向量进行归一化。在找到一个保持正性的阻尼步长 $\\alpha \\Delta\\mathbf{E}^{(m)}$ 后，我们按如下方式形成新的迭代值 $\\mathbf{E}^{(m+1)}$：\n1. 计算试验向量：$\\mathbf{E}_{\\text{trial}} = \\mathbf{E}^{(m)} + \\alpha \\Delta\\mathbf{E}^{(m)}$。\n2. 对其进行归一化：$\\mathbf{E}^{(m+1)} = \\frac{\\mathbf{E}_{\\text{trial}}}{\\sum_{j=1}^N E_{\\text{trial},j}}$。\n这种到和为一的向量单纯形上的投影确保了关键的物理约束始终被满足，从而有助于求解器的稳定性。\n\n迭代过程从一个初始猜测开始，通常是均匀分布 $\\mathbf{E}^{(0)} = (1/N, \\dots, 1/N)^T$，这个猜测同时满足正性约束和闭合约束。迭代持续进行，直到残差向量的范数 $\\|\\mathbf{F}(\\mathbf{E})\\|$ 小于预定义的公差。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define and run the test suite for the ion exchange problem.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (charges, activities, selectivity_coeffs, ref_index)\n    test_cases = [\n        # 1. Happy path ternary system\n        (\n            np.array([1, 1, 2], dtype=float),       # charges {z_i}\n            np.array([0.01, 0.005, 0.002]),       # activities {a_i}\n            np.array([0.8, 3.0]),                  # K_ir values for i != r\n            0                                      # reference index r\n        ),\n        # 2. Binary exchange with strong divalent preference\n        (\n            np.array([1, 2], dtype=float),\n            np.array([0.001, 0.1]),\n            np.array([15.0]),\n            0\n        ),\n        # 3. Edge case with trace monovalent\n        (\n            np.array([1, 1, 2], dtype=float),\n            np.array([0.01, 1e-8, 0.005]),\n            np.array([0.9, 2.0]),\n            0\n        ),\n        # 4. Balanced monovalent ternary\n        (\n            np.array([1, 1, 1], dtype=float),\n            np.array([0.1, 0.1, 0.1]),\n            np.array([1.0, 1.0]),\n            0\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        charges, activities, k_ir_values, ref_index = case\n        e_fractions = _newton_ion_exchange(charges, activities, k_ir_values, ref_index)\n        results.append(e_fractions.tolist())\n\n    # Format the final output string exactly as specified.\n    # Example: [[0.1,0.2],[0.3,0.4]]\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]' for res in results])}]\"\n    print(output_str)\n\n\ndef _newton_ion_exchange(charges, activities, k_ir_values, ref_index, tol=1e-12, max_iter=100):\n    \"\"\"\n    Solves the multi-component ion exchange system using Newton-Raphson.\n\n    Args:\n        charges (np.ndarray): Array of integer charges {z_i}.\n        activities (np.ndarray): Array of aqueous activities {a_i}.\n        k_ir_values (np.ndarray): Array of Gaines-Thomas selectivity coefficients {K_ir}\n                               for non-reference species i.\n        ref_index (int): The 0-based index of the reference cation r.\n        tol (float): Convergence tolerance for the norm of the residual.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        np.ndarray: Converged vector of exchanger equivalent fractions {E_i}.\n    \"\"\"\n    N = len(charges)\n    z = charges\n    a = activities\n    r = ref_index\n\n    # Map K_ir values to their corresponding species indices\n    non_ref_indices = [i for i in range(N) if i != r]\n    K_map = dict(zip(non_ref_indices, k_ir_values))\n\n    # Pre-calculate constants C_i for the residual equations\n    # C_i = ln(K_ir) + z_r*ln(a_i) - z_i*ln(a_r)\n    C = {}\n    with np.errstate(divide='ignore'): # activities can be very small\n        log_a = np.log(a)\n    for i in non_ref_indices:\n        C[i] = np.log(K_map[i]) + z[r] * log_a[i] - z[i] * log_a[r]\n\n    # Initial guess for E: uniform distribution\n    E = np.full(N, 1.0 / N, dtype=float)\n\n    for _ in range(max_iter):\n        # 1. Construct Residual vector F\n        F = np.zeros(N, dtype=float)\n        \n        # Logarithms require E > 0. This is guarded by the line search.\n        # However, a check here protects the first iteration if E is bad.\n        if np.any(E = 0):\n            raise ValueError(\"Fractions must be positive.\")\n        log_E = np.log(E)\n\n        for k in range(N):\n            if k == r:\n                F[k] = np.sum(E) - 1.0\n            else:\n                F[k] = z[r] * log_E[k] - z[k] * log_E[r] - C[k]\n\n        # 2. Check for convergence\n        if np.linalg.norm(F)  tol:\n            return E\n\n        # 3. Construct Jacobian matrix J\n        J = np.zeros((N, N), dtype=float)\n        for k in range(N):\n            if k == r:\n                J[k, :] = 1.0\n            else:\n                J[k, k] = z[r] / E[k]\n                J[k, r] = -z[k] / E[r]\n        \n        # 4. Solve for the Newton step delta_E\n        try:\n            delta_E = np.linalg.solve(J, -F)\n        except np.linalg.LinAlgError:\n            raise RuntimeError(\"Jacobian is singular. Failed to find solution.\")\n\n        # 5. Backtracking line search for step size alpha to ensure E > 0\n        alpha = 1.0\n        while True:\n            E_trial = E + alpha * delta_E\n            if np.all(E_trial > 0):\n                E = E_trial\n                break\n            alpha /= 2.0\n            if alpha  1e-10: # Failsafe\n                raise RuntimeError(\"Line search failed. Could not maintain positivity.\")\n\n        # 6. Normalize E to enforce closure constraint\n        E /= np.sum(E)\n\n    # If loop finishes, convergence was not reached\n    raise RuntimeError(f\"Newton's method did not converge within {max_iter} iterations.\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}