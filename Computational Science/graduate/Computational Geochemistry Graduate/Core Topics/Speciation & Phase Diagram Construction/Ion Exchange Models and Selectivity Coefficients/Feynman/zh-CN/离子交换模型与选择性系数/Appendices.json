{
    "hands_on_practices": [
        {
            "introduction": "不同的离子交换模型采用不同的方式来表示交换剂相的组成，从而导致了像范塞洛（Vanselow, $K_V$）和盖恩斯-托马斯（Gaines-Thomas, $K_{GT}$）这样不同的选择性系数定义。本练习旨在提供推导这些惯例之间数学关系的基本实践，这是比较和利用来自不同文献来源数据的关键技能。这项练习将加深您对这些模型背后热力学假设的理解。",
            "id": "4083684",
            "problem": "考虑在带有固定负电荷位点 $\\mathrm{X^{-}}$ 的均相理想交换剂上，水溶液中的钠离子 $\\mathrm{Na^{+}}$ 和钙离子 $\\mathrm{Ca^{2+}}$ 之间发生的二元离子交换。交换剂相含有化学计量比由电荷平衡决定的 $\\mathrm{NaX}$ 和 $\\mathrm{CaX_{2}}$。假设溶液相和交换剂相均为理想行为，因此交换剂相的活度可以用适当的组分分数表示。交换反应可写为\n$$2\\,\\mathrm{NaX} + \\mathrm{Ca^{2+}} \\rightleftharpoons \\mathrm{CaX_{2}} + 2\\,\\mathrm{Na^{+}}.$$\n从该反应以活度表示的平衡常数的标准定义出发，并结合此二元交换的 Vanselow 选择性系数 $K_{V}$ 和 Gaines–Thomas 选择性系数 $K_{GT}$ 的常规定义：\n- 在 Vanselow 框架中，以基于反离子计数的摩尔分数 $x_{\\mathrm{Na}}$ 和 $x_{\\mathrm{Ca}}$ 表示交换剂相活度，其中 $x_{i} = n_{i,\\mathrm{X}}/\\sum_{j} n_{j,\\mathrm{X}}$，$n_{i,\\mathrm{X}}$ 是交换剂上反离子 $i$ 的量。\n- 在 Gaines–Thomas 框架中，以当量（电荷）分数 $y_{\\mathrm{Na}}$ 和 $y_{\\mathrm{Ca}}$ 表示交换剂相活度，其中 $y_{i} = z_{i} n_{i,\\mathrm{X}}/\\sum_{j} z_{j} n_{j,\\mathrm{X}}$，$z_{i}$ 是离子 $i$ 的离子电荷。\n\n根据这些定义和反应化学计量，推导出一个仅用 $n_{\\mathrm{Na},\\mathrm{X}}$ 和 $n_{\\mathrm{Ca},\\mathrm{X}}$ 表示 $K_{GT}$ 与 $K_{V}$ 关系的封闭形式表达式。然后，对于一个交换剂样品，其中 $n_{\\mathrm{Na},\\mathrm{X}} = 0.54$ mol 且 $n_{\\mathrm{Ca},\\mathrm{X}} = 0.18$ mol，以及测得的 Vanselow 选择性系数 $K_{V} = 0.87$，计算相应的 Gaines–Thomas 选择性系数 $K_{GT}$。将最终系数表示为无量纲数，答案取四位有效数字。",
            "solution": "该问题要求推导特定离子交换反应中 Gaines–Thomas 选择性系数 $K_{GT}$ 与 Vanselow 选择性系数 $K_V$ 之间的关系，然后根据给定的 $K_V$ 值和交换剂相组成计算 $K_{GT}$。\n\n离子交换反应如下：\n$$2\\,\\mathrm{NaX} + \\mathrm{Ca^{2+}} \\rightleftharpoons \\mathrm{CaX_{2}} + 2\\,\\mathrm{Na^{+}}$$\n其中 $\\mathrm{X^{-}}$ 代表交换剂上的一个固定负电荷位点。对于任何处于平衡的反应，吉布斯-杜亥姆方程指出，当反应物的化学势等于产物的化学势时，反应即达到平衡状态。对于此反应，该关系通过质量作用定律使用活度 $a_i$ 来表示。热力学平衡常数 $K_{eq}$ 为：\n$$K_{eq} = \\frac{a_{\\mathrm{CaX_2}} \\cdot (a_{\\mathrm{Na^+}})^2}{(a_{\\mathrm{NaX}})^2 \\cdot a_{\\mathrm{Ca^{2+}}}}$$\n水相物质的活度为 $a_{\\mathrm{Na^+}}$ 和 $a_{\\mathrm{Ca^{2+}}}$。交换剂相物质的活度为 $a_{\\mathrm{NaX}}$ 和 $a_{\\mathrm{CaX_2}}$。\n\n选择性系数是操作上定义的“实用”平衡常数，其中交换剂相物质的活度被可测量的组分分数所取代。题目指明了两种这样的约定。\n\n1.  **Vanselow 选择性系数 ($K_V$)**：在此框架中，交换剂物质的活度由交换剂上相应反离子的摩尔分数表示。设 $n_{\\mathrm{Na,X}}$ 和 $n_{\\mathrm{Ca,X}}$ 分别为交换剂上钠离子和钙离子的摩尔量。摩尔分数为：\n    $$x_{\\mathrm{Na}} = \\frac{n_{\\mathrm{Na,X}}}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}}$$\n    $$x_{\\mathrm{Ca}} = \\frac{n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}}$$\n    通过用这些摩尔分数替代交换剂相物质的活度（$a_{\\mathrm{NaX}} \\rightarrow x_{\\mathrm{Na}}$，$a_{\\mathrm{CaX_2}} \\rightarrow x_{\\mathrm{Ca}}$），Vanselow 选择性系数定义为：\n    $$K_V = \\frac{x_{\\mathrm{Ca}} \\cdot (a_{\\mathrm{Na^+}})^2}{x_{\\mathrm{Na}}^2 \\cdot a_{\\mathrm{Ca^{2+}}}}$$\n\n2.  **Gaines–Thomas 选择性系数 ($K_{GT}$)**：在此框架中，交换剂物质的活度由反离子的当量（电荷）分数表示。离子的电荷为 $z_{\\mathrm{Na}} = 1$ 和 $z_{\\mathrm{Ca}} = 2$。当量分数为：\n    $$y_{\\mathrm{Na}} = \\frac{z_{\\mathrm{Na}} n_{\\mathrm{Na,X}}}{z_{\\mathrm{Na}} n_{\\mathrm{Na,X}} + z_{\\mathrm{Ca}} n_{\\mathrm{Ca,X}}} = \\frac{n_{\\mathrm{Na,X}}}{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}}$$\n    $$y_{\\mathrm{Ca}} = \\frac{z_{\\mathrm{Ca}} n_{\\mathrm{Ca,X}}}{z_{\\mathrm{Na}} n_{\\mathrm{Na,X}} + z_{\\mathrm{Ca}} n_{\\mathrm{Ca,X}}} = \\frac{2n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}}$$\n    通过用这些当量分数替代活度（$a_{\\mathrm{NaX}} \\rightarrow y_{\\mathrm{Na}}$，$a_{\\mathrm{CaX_2}} \\rightarrow y_{\\mathrm{Ca}}$），Gaines–Thomas 选择性系数定义为：\n    $$K_{GT} = \\frac{y_{\\mathrm{Ca}} \\cdot (a_{\\mathrm{Na^+}})^2}{y_{\\mathrm{Na}}^2 \\cdot a_{\\mathrm{Ca^{2+}}}}$$\n\n为求出 $K_{GT}$ 和 $K_V$ 之间的关系，可将其定义表达式相除。涉及水相活度的项相互抵消：\n$$\\frac{K_{GT}}{K_V} = \\frac{\\left( \\frac{y_{\\mathrm{Ca}} \\cdot (a_{\\mathrm{Na^+}})^2}{y_{\\mathrm{Na}}^2 \\cdot a_{\\mathrm{Ca^{2+}}}} \\right)}{\\left( \\frac{x_{\\mathrm{Ca}} \\cdot (a_{\\mathrm{Na^+}})^2}{x_{\\mathrm{Na}}^2 \\cdot a_{\\mathrm{Ca^{2+}}}} \\right)} = \\frac{y_{\\mathrm{Ca}} \\cdot x_{\\mathrm{Na}}^2}{y_{\\mathrm{Na}}^2 \\cdot x_{\\mathrm{Ca}}}$$\n现在，将以 $n_{\\mathrm{Na,X}}$ 和 $n_{\\mathrm{Ca,X}}$ 表示的 $x_i$ 和 $y_i$ 的定义代入该比值中：\n$$x_{\\mathrm{Na}}^2 = \\left( \\frac{n_{\\mathrm{Na,X}}}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}} \\right)^2$$\n$$x_{\\mathrm{Ca}} = \\frac{n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}}$$\n$$y_{\\mathrm{Na}}^2 = \\left( \\frac{n_{\\mathrm{Na,X}}}{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}} \\right)^2$$\n$$y_{\\mathrm{Ca}} = \\frac{2n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}}$$\n将这些代入 $K_{GT}/K_V$ 的比值表达式中：\n$$\\frac{K_{GT}}{K_V} = \\frac{\\left( \\frac{2n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}} \\right) \\left( \\frac{n_{\\mathrm{Na,X}}}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}} \\right)^2}{\\left( \\frac{n_{\\mathrm{Na,X}}}{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}} \\right)^2 \\left( \\frac{n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}} \\right)}$$\n我们可以重排并简化此表达式：\n$$\\frac{K_{GT}}{K_V} = \\frac{2n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}} \\cdot \\frac{n_{\\mathrm{Na,X}}^2}{(n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}})^2} \\cdot \\frac{(n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}})^2}{n_{\\mathrm{Na,X}}^2} \\cdot \\frac{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Ca,X}}}$$\n消去项：\n\\begin{itemize}\n    \\item 分子和分母中的 $n_{\\mathrm{Ca,X}}$。\n    \\item 分子和分母中的 $n_{\\mathrm{Na,X}}^2$。\n    \\item 分子和分母中的一个因子 $(n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}})$。\n    \\item 分子和分母中的一个因子 $(n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}})$。\n\\end{itemize}\n剩下：\n$$\\frac{K_{GT}}{K_V} = 2 \\cdot \\frac{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}}$$\n这就是以 $n_{\\mathrm{Na,X}}$ 和 $n_{\\mathrm{Ca,X}}$ 表示的 $K_{GT}$ 与 $K_V$ 关系的封闭形式表达式。\n\n问题的第二部分是计算在给定条件下 $K_{GT}$ 的值：\n$$n_{\\mathrm{Na,X}} = 0.54\\,\\mathrm{mol}$$\n$$n_{\\mathrm{Ca,X}} = 0.18\\,\\mathrm{mol}$$\n$$K_V = 0.87$$\n首先，我们计算转换因子的值：\n$$\\frac{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}} = \\frac{0.54 + 2(0.18)}{0.54 + 0.18} = \\frac{0.54 + 0.36}{0.72} = \\frac{0.90}{0.72}$$\n该比值简化为：\n$$\\frac{0.90}{0.72} = \\frac{90}{72} = \\frac{10 \\times 9}{8 \\times 9} = \\frac{10}{8} = \\frac{5}{4} = 1.25$$\n现在我们可以计算 $K_{GT}$：\n$$K_{GT} = K_V \\cdot 2 \\cdot \\left( \\frac{n_{\\mathrm{Na,X}} + 2n_{\\mathrm{Ca,X}}}{n_{\\mathrm{Na,X}} + n_{\\mathrm{Ca,X}}} \\right) = 0.87 \\cdot 2 \\cdot 1.25$$\n$$K_{GT} = 0.87 \\cdot 2.5$$\n$$K_{GT} = 2.175$$\n题目要求最终答案保留四位有效数字。计算值 $2.175$ 已有四位有效数字，因此无需进一步舍入。",
            "answer": "$$\\boxed{2.175}$$"
        },
        {
            "introduction": "选择性系数的实验测量值往往带有噪声，当将多个交换对的数据放在一起考虑时，它们可能不满足热力学一致性。本练习介绍了一种强大的计算方法，通过将数据集投影到最接近的热力学有效流形上，来“清洗”这些数据。这确保了最终得到的参数遵循热力学定律，从而适用于稳健的多组分模型。",
            "id": "4083667",
            "problem": "考虑在固定的强度状态（温度、压力、离子强度）下，对于单一固相交换剂上有限的一组单价阳离子，当满足热力学平衡（TE）时的一组无量纲离子交换选择性系数。设离子集由 $i \\in \\{1,\\dots,n\\}$ 索引，对于一个有向有序对 $(i,j)$，测得的无量纲选择性系数为 $K_{ij}^{\\mathrm{meas}}  0$。通过 $k_{ij}^{\\mathrm{meas}} = \\ln K_{ij}^{\\mathrm{meas}}$ 定义对数测量值。循环一致性条件断言，对于任何回到起始离子的不同索引的闭环 $(i_{1},i_{2},\\dots,i_{m},i_{1})$，沿该环路的对数和必须为零，即 $\\sum_{\\ell=1}^{m} k_{i_{\\ell} i_{\\ell+1}}^{\\ast} = 0$，其中 $i_{m+1} \\equiv i_{1}$，$k_{ij}^{\\ast}$ 是与 TE 一致的调整值。等价地，存在一个标量交换势向量 $(t_{1},\\dots,t_{n})$，使得对于所有测量的有向对 $(i,j)$，有 $k_{ij}^{\\ast} = t_{i} - t_{j}$。后者由一致的 $k_{ij}^{\\ast}$ 构成的流形自动满足所有循环约束。\n\n给定通常违反循环一致性的含噪声测量值。您必须使用与每个测量的有向对 $(i,j)$ 相关的非负权重 $w_{ij}$，计算测量的对数值到由 $(t_{1},\\dots,t_{n})$ 的存在性所定义的一致值流形上的最小二乘投影。也就是说，找到使加权平方差之和 $\\sum_{(i,j)} w_{ij}\\left((t_{i} - t_{j}) - k_{ij}^{\\mathrm{meas}}\\right)^{2}$ 最小化的 $t$，然后为所有测量对定义 $k_{ij}^{\\ast} = t_{i} - t_{j}$ 和 $K_{ij}^{\\ast} = \\exp(k_{ij}^{\\ast})$。因为势在测量图的每个连通分量上仅能以一个加法常数为精度确定，您必须通过将每个连通分量中的一个 $t$ 设置为 $0$ 来固定规范，这将在每个分量上产生一个唯一的极小值点。\n\n将应用于每个测量对的对数域校正量化为 $\\Delta_{ij} = k_{ij}^{\\ast} - k_{ij}^{\\mathrm{meas}}$。对于每个测试用例，报告校正场的两个汇总指标：由 $\\sqrt{\\frac{\\sum_{(i,j)} w_{ij}\\,\\Delta_{ij}^{2}}{\\sum_{(i,j)} w_{ij}}}$ 定义的加权均方根（RMS）校正和最大绝对校正 $\\max_{(i,j)} |\\Delta_{ij}|$。所有量均为无量纲，且必须表示为十进制数（不带百分号）。\n\n编写一个完整的、可运行的程序，构建上述最小二乘投影，并为以下测试套件生成所要求的指标和调整后的选择性系数。每个测试用例由一个有序的离子名称列表和一个有序的测量有向对列表（包含其无量纲系数和权重）定义，输出必须严格按照给定的顺序报告：\n\n- 测试用例 $1$：\n    - 离子：$\\text{\"Na\"}$、$\\text{\"K\"}$、$\\text{\"Li\"}$。\n    - 带权重的测量对（有序）：$(\\text{\"Na\"},\\text{\"K\"},\\,2.0,\\,1.0)$、$(\\text{\"K\"},\\text{\"Li\"},\\,1.5,\\,1.0)$、$(\\text{\"Li\"},\\text{\"Na\"},\\,0.4,\\,1.0)$。\n\n- 测试用例 $2$：\n    - 离子：$\\text{\"Na\"}$、$\\text{\"K\"}$、$\\text{\"Cs\"}$、$\\text{\"Li\"}$。\n    - 带权重的测量对（有序）：$(\\text{\"Na\"},\\text{\"K\"},\\,3.0,\\,10.0)$、$(\\text{\"K\"},\\text{\"Cs\"},\\,0.9,\\,1.0)$、$(\\text{\"Cs\"},\\text{\"Li\"},\\,1.2,\\,1.0)$、$(\\text{\"Na\"},\\text{\"Li\"},\\,2.5,\\,5.0)$。\n\n- 测试用例 $3$：\n    - 离子：$\\text{\"Na\"}$、$\\text{\"K\"}$、$\\text{\"Li\"}$、$\\text{\"Cs\"}$。\n    - 带权重的测量对（有序）：$(\\text{\"Na\"},\\text{\"K\"},\\,1.8,\\,1.0)$、$(\\text{\"Li\"},\\text{\"Cs\"},\\,0.7,\\,1.0)$。\n\n您的程序应为每个测试用例计算：\n- 对数域中的加权均方根校正，$\\sqrt{\\frac{\\sum w_{ij}\\Delta_{ij}^{2}}{\\sum w_{ij}}}$。\n- 对数域中的最大绝对校正，$\\max |\\Delta_{ij}|$.\n- 按照输入顺序排列的、测量对的调整后无量纲选择性系数列表 $K_{ij}^{\\ast}$。\n\n最终输出格式：您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。其中每个测试用例的结果本身是一个列表，格式为 $[\\text{RMS},\\;\\text{MAXABS},\\;[K_{1}^{\\ast},\\dots,K_{m}^{\\ast}]]$，并在每个测试用例内保持输入对的顺序。例如，一个正确格式化的输出看起来像 $[[\\dots],[\\dots],[\\dots]]$，所有量都使用十进制数。",
            "solution": "该问题要求调整一组含噪声的、通过实验测量的离子交换选择性系数 $K_{ij}^{\\mathrm{meas}}$，使其满足热力学一致性。热力学一致性通过存在一组标量交换势 $(t_1, \\dots, t_n)$ 来表达，使得调整后的对数选择性系数 $k_{ij}^{\\ast} = \\ln K_{ij}^{\\ast}$ 可以写成简单的差值形式 $k_{ij}^{\\ast} = t_i - t_j$。这个条件自动满足了循环一致性规则，即对于任何交换反应的闭环，$\\sum_{\\ell=1}^{m} k_{i_{\\ell} i_{\\ell+1}}^{\\ast} = 0$。\n\n任务是找到在加权最小二乘意义上最接近测量值 $k_{ij}^{\\mathrm{meas}} = \\ln K_{ij}^{\\mathrm{meas}}$ 的热力学一致值 $k_{ij}^{\\ast}$。这被表述为一个优化问题：找到势向量 $t = (t_1, \\dots, t_n)$，以最小化加权平方差之和 $S(t)$：\n$$\nS(t) = \\sum_{(i,j) \\in E} w_{ij} \\left( (t_i - t_j) - k_{ij}^{\\mathrm{meas}} \\right)^2\n$$\n其中 $E$ 是所有测量的有向对 $(i,j)$ 的集合，$w_{ij} \\ge 0$ 是相关的权重。\n\n为找到 $S(t)$ 的最小值，我们将关于每个势 $t_m$ 的偏导数设为零：\n$$\n\\frac{\\partial S}{\\partial t_m} = 0 \\quad \\text{对于 } m = 1, \\dots, n\n$$\n导数计算如下：\n$$\n\\frac{\\partial S}{\\partial t_m} = \\sum_{(i,j) \\in E} 2 w_{ij} \\left( (t_i - t_j) - k_{ij}^{\\mathrm{meas}} \\right) \\frac{\\partial(t_i - t_j)}{\\partial t_m}\n$$\n偏导数 $\\frac{\\partial(t_i - t_j)}{\\partial t_m}$ 在 $i=m$ 时为 $1$，在 $j=m$ 时为 $-1$，否则为 $0$。这可以用克罗内克δ函数写作 $\\delta_{im} - \\delta_{jm}$。将此代入方程并将结果设为零，得到：\n$$\n\\sum_{(i,j) \\in E} w_{ij} \\left( (t_i - t_j) - k_{ij}^{\\mathrm{meas}} \\right) (\\delta_{im} - \\delta_{jm}) = 0\n$$\n根据克罗内克δ函数拆分求和，对每个 $m$ 可得：\n$$\n\\sum_{j \\text{ s.t. } (m,j)\\in E} w_{mj}((t_m - t_j) - k_{mj}^{\\mathrm{meas}}) - \\sum_{i \\text{ s.t. } (i,m)\\in E} w_{im}((t_i - t_m) - k_{im}^{\\mathrm{meas}}) = 0\n$$\n整理此方程，将未知势 $t$ 与已知的测量值 $k^{\\mathrm{meas}}$ 分开，得到一个线性方程组：\n$$\n\\left( \\sum_{j \\text{ s.t. } (m,j)\\in E} w_{mj} + \\sum_{i \\text{ s.t. } (i,m)\\in E} w_{im} \\right) t_m - \\sum_{j \\text{ s.t. } (m,j)\\in E} w_{mj}t_j - \\sum_{i \\text{ s.t. } (i,m)\\in E} w_{im}t_i = \\sum_{j \\text{ s.t. } (m,j)\\in E} w_{mj} k_{mj}^{\\mathrm{meas}} - \\sum_{i \\text{ s.t. } (i,m)\\in E} w_{im} k_{im}^{\\mathrm{meas}}\n$$\n这是一个包含 $n$ 个变量的 $n$ 个线性方程组，可以写成矩阵形式 $At = b$。矩阵 $A$ 是测量图的加权图拉普拉斯矩阵，其中离子是节点，测量是加权边。其元素为：\n$$\nA_{mm} = \\sum_{j \\neq m} (w_{mj} + w_{jm}) \\quad (\\text{如果已测量})\n$$\n$$\nA_{mk} = -(w_{mk} + w_{km}) \\quad \\text{对于 } m \\neq k \\quad (\\text{如果已测量})\n$$\n向量 $b$ 的元素为：\n$$\nb_m = \\sum_{j \\text{ s.t. } (m,j)\\in E} w_{mj} k_{mj}^{\\mathrm{meas}} - \\sum_{i \\text{ s.t. } (i,m)\\in E} w_{im} k_{im}^{\\mathrm{meas}}\n$$\n图拉普拉斯矩阵 $A$ 是奇异的。它的零空间由所有分量都相等的向量组成，这反映了物理原理，即势 $t_i$ 仅能以一个加法常数为精度确定 ($t_i \\to t_i + c$)。这被称为规范自由度。如果测量图是不连通的，则此自由度独立地应用于每个连通分量。\n\n为获得唯一解，我们必须固定规范。问题指定通过将图的每个连通分量中的一个势 $t_p$ 设为零来实现。在计算上，这是通过以下步骤完成的：\n1. 识别由测量定义的图的连通分量。\n2. 对每个分量，选择一个参考离子（节点）$p$ 并施加约束 $t_p = 0$。这是通过将矩阵 $A$ 的第 $p$ 行替换为除第 $p$ 列为 $1$ 外全为零的行，并将 $b$ 的第 $p$ 个元素设为 $0$ 来实现的。\n3. 为 $C$ 个连通分量中的每一个施加一个这样的约束后，得到的 $n \\times n$ 矩阵是满秩（$n$）的，并且系统 $At=b$ 有一个唯一解，该解可以使用标准的线性求解器找到。\n\n一旦找到唯一的势向量 $t$，就可以计算调整值和所需的指标：\n1. 调整后的对数选择性：对于每个测量对 $(i,j)$，$k_{ij}^{\\ast} = t_i - t_j$。\n2. 调整后的选择性系数：$K_{ij}^{\\ast} = \\exp(k_{ij}^{\\ast})$。\n3. 对数域中的校正：$\\Delta_{ij} = k_{ij}^{\\ast} - k_{ij}^{\\mathrm{meas}}$。\n4. 加权RMS校正：$\\sqrt{\\frac{\\sum_{(i,j)} w_{ij}\\,\\Delta_{ij}^{2}}{\\sum_{(i,j)} w_{ij}}}$。\n5. 最大绝对校正：$\\max_{(i,j)} |\\Delta_{ij}|$。\n\n这个过程提供了一种严谨的方法，将含噪声的测量值投影到热力学一致的流形上。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse.csgraph import connected_components\n\ndef process_case(ions_list, measured_pairs):\n    \"\"\"\n    Processes a single test case for ion exchange selectivity coefficient adjustment.\n\n    Args:\n        ions_list (list): A list of ion names.\n        measured_pairs (list): A list of tuples, each containing\n                               (from_ion, to_ion, K_meas, weight).\n\n    Returns:\n        list: A list containing [RMS_correction, MaxAbs_correction, [K_star_list]].\n    \"\"\"\n    ion_map = {name: i for i, name in enumerate(ions_list)}\n    n_ions = len(ions_list)\n    \n    # The system is At = b, where A is the weighted graph Laplacian.\n    A = np.zeros((n_ions, n_ions), dtype=np.float64)\n    b = np.zeros(n_ions, dtype=np.float64)\n    \n    log_k_meas = []\n    weights = []\n    \n    # Adjacency matrix for connectivity analysis\n    conn_matrix = np.zeros((n_ions, n_ions), dtype=np.int8)\n\n    for from_ion, to_ion, K_meas, w in measured_pairs:\n        i = ion_map[from_ion]\n        j = ion_map[to_ion]\n        k_meas = np.log(K_meas)\n        \n        log_k_meas.append(k_meas)\n        weights.append(w)\n        \n        # Build the Laplacian matrix A and vector b\n        # A is symmetric, representing the undirected graph structure for the potential problem.\n        A[i, i] += w\n        A[j, j] += w\n        A[i, j] -= w\n        A[j, i] -= w\n        \n        # b_m = sum_{j} w_mj k_mj - sum_{i} w_im k_im\n        b[i] += w * k_meas\n        b[j] -= w * k_meas\n        \n        # Mark edge for connectivity graph\n        conn_matrix[i, j] = 1\n        conn_matrix[j, i] = 1\n\n    # Find connected components to apply gauge fixing\n    n_components, labels = connected_components(csgraph=conn_matrix, directed=False)\n    \n    # Identify a reference node for each component and apply the constraint t_ref = 0.\n    # We select the node with the smallest index in each component as the reference.\n    ref_nodes = {}\n    for i, label in enumerate(labels):\n        if label not in ref_nodes:\n            ref_nodes[label] = i\n    \n    for ref_node_idx in ref_nodes.values():\n        # Enforce t_ref = 0 by modifying the corresponding row in the system At=b.\n        A[ref_node_idx, :] = 0.0\n        A[ref_node_idx, ref_node_idx] = 1.0\n        b[ref_node_idx] = 0.0\n        \n    # Solve for the potentials t. After applying constraints, A is non-singular.\n    t = np.linalg.solve(A, b)\n\n    # Calculate adjusted values and performance metrics\n    deltas = []\n    k_star_list = []\n    \n    for idx, (from_ion, to_ion, K_meas, w) in enumerate(measured_pairs):\n        i = ion_map[from_ion]\n        j = ion_map[to_ion]\n        \n        k_star = t[i] - t[j]\n        k_star_list.append(k_star)\n        \n        delta = k_star - log_k_meas[idx]\n        deltas.append(delta)\n        \n    deltas = np.array(deltas)\n    weights = np.array(weights)\n    \n    sum_w = np.sum(weights)\n    if sum_w == 0:\n        rms_corr = 0.0\n    else:\n        rms_corr = np.sqrt(np.sum(weights * deltas**2) / sum_w)\n    \n    if len(deltas) == 0:\n        max_abs_corr = 0.0\n    else:\n        max_abs_corr = np.max(np.abs(deltas))\n        \n    K_star_list = np.exp(k_star_list).tolist()\n    \n    return [rms_corr, max_abs_corr, K_star_list]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"ions\": [\"Na\", \"K\", \"Li\"],\n            \"pairs\": [(\"Na\", \"K\", 2.0, 1.0), (\"K\", \"Li\", 1.5, 1.0), (\"Li\", \"Na\", 0.4, 1.0)]\n        },\n        {\n            \"ions\": [\"Na\", \"K\", \"Cs\", \"Li\"],\n            \"pairs\": [(\"Na\", \"K\", 3.0, 10.0), (\"K\", \"Cs\", 0.9, 1.0), (\"Cs\", \"Li\", 1.2, 1.0), (\"Na\", \"Li\", 2.5, 5.0)]\n        },\n        {\n            \"ions\": [\"Na\", \"K\", \"Li\", \"Cs\"],\n            \"pairs\": [(\"Na\", \"K\", 1.8, 1.0), (\"Li\", \"Cs\", 0.7, 1.0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case[\"ions\"], case[\"pairs\"])\n        results.append(result)\n\n    result_strings = []\n    for res in results:\n        rms, max_abs, k_stars = res\n        # Format K_star list to not have spaces for a compact representation\n        k_stars_str = f\"[{','.join(map(str, k_stars))}]\"\n        # Format the full result for one test case\n        result_strings.append(f\"[{rms},{max_abs},{k_stars_str}]\")\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "预测离子在溶液和交换剂之间的平衡分布是计算地球化学的核心任务。本练习通过实现一个牛顿-拉弗森（Newton-Raphson）求解器来解决非线性质量作用方程组，从而让您深入了解如何构建此类预测的数值引擎。掌握这项技能是理解和开发现代地球化学模拟软件的基石。",
            "id": "4083708",
            "problem": "考虑一个由 Gaines–Thomas 惯例描述的多组分离子交换体系，其中交换相由 $N$ 种水相阳离子的当量分数 $\\{E_i\\}_{i=1}^N$ 表示，这些阳离子的整数电荷为 $\\{z_i\\}_{i=1}^N$，水相活度为正值 $\\{a_i\\}_{i=1}^N$。固定一个参考阳离子，索引为 $r$，并假设阳离子 $i$ 与参考阳离子 $r$ 交换的热力学选择性系数 $\\{K_{ir}^{\\mathrm{GT}}\\}_{i \\neq r}$ 已知。当量分数满足闭合约束 $\\sum_{i=1}^N E_i = 1$ 以及由 Gaines–Thomas 选择性系数所蕴含的质量作用关系：\n$$\nK_{ij}^{\\mathrm{GT}} = \\frac{E_i^{z_j}/E_j^{z_i}}{a_i^{z_j}/a_j^{z_i}} \\quad \\text{对于任意一对 } i,j.\n$$\n关注与固定参考阳离子 $r$ 的成对交换，对于每个 $i \\neq r$，质量作用关系变为：\n$$\nE_i^{z_r} = K_{ir}^{\\mathrm{GT}} \\, E_r^{z_i} \\, \\frac{a_i^{z_r}}{a_r^{z_i}}.\n$$\n您将根据未知的交换相分数 $\\{E_i\\}_{i=1}^N$ 建立非线性方程组，推导牛顿-拉弗森方法所需的雅可比矩阵，并实现一个带有阻尼和缩放的稳健的牛顿-拉弗森求解器，该求解器在整个迭代过程中强制执行闭合约束 $\\sum_{i=1}^N E_i = 1$。科学依据必须从质量作用定律和 Gaines–Thomas 定义出发，并推导出一个计算方案，而不借助任何简化公式。\n\n任务如下：\n- 使用与参考阳离子相关的 $N-1$ 个质量作用关系和单个闭合方程，推导一个维度为 $N$ 的残差函数 $\\mathbf{F}(\\mathbf{E}) = \\mathbf{0}$。对质量作用关系进行对数变换，以避免数值下溢，并确保在公式中明确体现正性约束。\n- 推导所有方程和所有未知数的雅可比矩阵元素 $\\partial F_k / \\partial E_j$。\n- 讨论用以强制执行 $\\sum_{i=1}^N E_i = 1$ 的缩放策略，以及阻尼在迭代期间维持 $E_i  0$ 的作用。实现一种方法，在每个被接受的牛顿步之后精确地归一化迭代值以满足闭合约束。\n- 在一个程序中实现一个带有回溯线搜索（阻尼）的牛顿-拉弗森求解器，该程序接受预定义的测试用例并输出收敛的交换相分数。\n\n此问题中的所有量均为无量纲。您的程序必须实现该方法并求解以下测试套件，每个套件由一个元组 $(\\{z_i\\}, \\{a_i\\}, \\{K_{ir}^{\\mathrm{GT}}\\}, r)$ 描述：\n1. 正常情况的三元体系，含一价和二价阳离子：$N=3$，物种顺序为 $\\{\\mathrm{Na}^+, \\mathrm{K}^+, \\mathrm{Ca}^{2+}\\}$，$r = 0$（参考离子为 $\\mathrm{Na}^+$），电荷 $\\{z_i\\} = \\{1, 1, 2\\}$，活度 $\\{a_i\\} = \\{0.01, 0.005, 0.002\\}$，选择性系数 $\\{K_{ir}^{\\mathrm{GT}}\\}$ 其中 $K_{1,0}^{\\mathrm{GT}} = 0.8$ 且 $K_{2,0}^{\\mathrm{GT}} = 3.0$。\n2. 具有强烈二价离子偏好的二元交换：$N=2$，物种顺序为 $\\{\\mathrm{Na}^+, \\mathrm{Ca}^{2+}\\}$，$r = 0$，电荷 $\\{1, 2\\}$，活度 $\\{0.001, 0.1\\}$，选择性系数 $K_{1,0}^{\\mathrm{GT}} = 15.0$。\n3. 含痕量一价离子的边缘情况：$N=3$，物种 $\\{\\mathrm{Na}^+, \\mathrm{Li}^+, \\mathrm{Ca}^{2+}\\}$，$r = 0$，电荷 $\\{1, 1, 2\\}$，活度 $\\{0.01, 10^{-8}, 0.005\\}$，选择性系数 $K_{1,0}^{\\mathrm{GT}} = 0.9$，$K_{2,0}^{\\mathrm{GT}} = 2.0$。\n4. 选择性系数和活度均相等的平衡三元一价体系：$N=3$，物种 $\\{\\mathrm{Na}^+, \\mathrm{K}^+, \\mathrm{NH}_4^+\\}$，$r = 0$，电荷 $\\{1, 1, 1\\}$，活度 $\\{0.1, 0.1, 0.1\\}$，选择性系数 $K_{1,0}^{\\mathrm{GT}} = 1.0$，$K_{2,0}^{\\mathrm{GT}} = 1.0$。\n\n您的程序应生成单行输出，其中包含测试用例的交换相分数解，格式为方括号括起来的逗号分隔列表，其中每个元素本身是代表该用例 $\\{E_i\\}$ 的、由方括号括起来的逗号分隔浮点数列表（例如：\"[[E_1,E_2,...],[...],...]\"）。输出不得包含任何空格。\n\n因此，要求的最终输出类型是浮点数列表的列表。数值求解器必须是确定性的，并且只能使用指定的运行时环境。",
            "solution": "该问题是有效的，因为它基于化学平衡原理（Gaines-Thomas 离子交换模型），是适定的（一个由 N 个方程组成的方程组对应 N 个未知数），并且客观地表述了所有必需的数据。任务是推导并实现一个数值求解器，这是计算科学中的标准程序。\n\n### 1. 非线性方程组的构建\n\n该体系涉及 $N$ 种阳离子，未知量是它们在交换相中的当量分数，表示为向量 $\\mathbf{E} = (E_1, E_2, \\dots, E_N)^T$。这些未知量必须满足两组条件：质量作用定律和闭合约束。\n\n阳离子 $i$ 与参考阳离子 $r$ 交换的 Gaines-Thomas 质量作用关系如下：\n$$\nK_{ir}^{\\mathrm{GT}} = \\frac{E_i^{z_r}/E_r^{z_i}}{a_i^{z_r}/a_r^{z_i}}\n$$\n其中 $z_i$ 和 $z_r$ 是整数电荷，$a_i$ 和 $a_r$ 是水相活度。重新整理此表达式可得：\n$$\nE_i^{z_r} = K_{ir}^{\\mathrm{GT}} \\, E_r^{z_i} \\, \\frac{a_i^{z_r}}{a_r^{z_i}}\n$$\n这为每个 $i \\neq r$ 提供了一个方程，总共 $N-1$ 个方程。\n\n为提高数值稳定性并自然地处理正性约束 $E_i > 0$，我们按照问题陈述的建议，对这 $N-1$ 个方程取自然对数：\n$$\nz_r \\ln E_i = \\ln(K_{ir}^{\\mathrm{GT}}) + z_i \\ln E_r + z_r \\ln a_i - z_i \\ln a_r\n$$\n我们可以为 $i \\in \\{1, \\dots, N\\}, i \\neq r$ 定义一组 $N-1$ 个残差函数 $F_i(\\mathbf{E})$，方法是将每个方程设为零：\n$$\nF_i(\\mathbf{E}) = z_r \\ln E_i - z_i \\ln E_r - \\left( \\ln(K_{ir}^{\\mathrm{GT}}) + z_r \\ln a_i - z_i \\ln a_r \\right) = 0\n$$\n对于给定的问题实例，括号中的项是一个常数。我们将此常数定义为 $C_i$：\n$$\nC_i = \\ln(K_{ir}^{\\mathrm{GT}}) + z_r \\ln a_i - z_i \\ln a_r = \\ln\\left(K_{ir}^{\\mathrm{GT}} \\frac{a_i^{z_r}}{a_r^{z_i}}\\right)\n$$\n因此，$N-1$ 个质量作用残差方程为：\n$$\nF_i(\\mathbf{E}) = z_r \\ln E_i - z_i \\ln E_r - C_i = 0 \\quad \\text{对于 } i \\neq r\n$$\n闭合系统所需的第 $N$ 个方程是闭合约束，即所有当量分数的总和必须为 1：\n$$\n\\sum_{j=1}^N E_j = 1\n$$\n我们将其构建为一个残差方程，并将其分配给索引 $r$：\n$$\nF_r(\\mathbf{E}) = \\sum_{j=1}^N E_j - 1 = 0\n$$\n将这些组合起来，得到最终的 $N$ 维残差向量函数 $\\mathbf{F}(\\mathbf{E}) = (F_1, \\dots, F_N)^T$，在解处，该函数必须等于零向量 $\\mathbf{0}$。\n\n### 2. 雅可比矩阵的推导\n\n牛顿-拉弗森法需要残差函数 $\\mathbf{F}(\\mathbf{E})$ 的雅可比矩阵 $J$，其元素由 $J_{ki} = \\partial F_k / \\partial E_i$ 给出。我们为每种类型的残差方程推导这些偏导数。\n\n**情况 1：质量作用方程 ($k \\neq r$)**\n残差为 $F_k(\\mathbf{E}) = z_r \\ln E_k - z_k \\ln E_r - C_k$。我们计算其对每个 $E_i$ 的偏导数：\n- 如果 $i=k$：导数是关于 $E_k$ 的。\n$$\n\\frac{\\partial F_k}{\\partial E_k} = \\frac{\\partial}{\\partial E_k} (z_r \\ln E_k) = \\frac{z_r}{E_k}\n$$\n- 如果 $i=r$：导数是关于 $E_r$ 的。\n$$\n\\frac{\\partial F_k}{\\partial E_r} = \\frac{\\partial}{\\partial E_r} (-z_k \\ln E_r) = -\\frac{z_k}{E_r}\n$$\n- 如果 $i \\neq k$ 且 $i \\neq r$：变量 $E_i$ 未出现在 $F_k$ 中。\n$$\n\\frac{\\partial F_k}{\\partial E_i} = 0\n$$\n\n**情况 2：闭合方程 ($k = r$)**\n残差为 $F_r(\\mathbf{E}) = \\sum_{j=1}^N E_j - 1$。\n- 对于任意 $i \\in \\{1, \\dots, N\\}$：\n$$\n\\frac{\\partial F_r}{\\partial E_i} = \\frac{\\partial}{\\partial E_i} \\left( \\sum_{j=1}^N E_j - 1 \\right) = 1\n$$\n总而言之，雅可比矩阵 $J$ 的元素为：\n$$\nJ_{ki} = \\frac{\\partial F_k}{\\partial E_i} = \\begin{cases}\n1  \\text{如果 } k=r \\\\\nz_r/E_k  \\text{如果 } k \\neq r \\text{ 且 } i=k \\\\\n-z_k/E_r  \\text{如果 } k \\neq r \\text{ 且 } i=r \\\\\n0  \\text{如果 } k \\neq r \\text{ 且 } i \\notin \\{k, r\\}\n\\end{cases}\n$$\n\n### 3. 带阻尼和归一化的牛顿-拉弗森法\n\n牛顿-拉弗森迭代通过求解线性系统来将当前估计值 $\\mathbf{E}^{(m)}$ 更新为新的估计值 $\\mathbf{E}^{(m+1)}$：\n$$\nJ(\\mathbf{E}^{(m)}) \\Delta\\mathbf{E}^{(m)} = -\\mathbf{F}(\\mathbf{E}^{(m)})\n$$\n求解更新步长 $\\Delta\\mathbf{E}^{(m)}$，然后设置 $\\mathbf{E}^{(m+1)} = \\mathbf{E}^{(m)} + \\Delta\\mathbf{E}^{(m)}$。为确保稳健性，我们引入阻尼和归一化。\n\n**为保证正性（$E_i  0$）的阻尼**：我们公式中的对数项 $\\ln(E_i)$ 要求所有分数 $E_i$ 在整个迭代过程中保持严格为正。一个完整的牛顿步长 $\\Delta\\mathbf{E}$ 并不能保证这一点。我们引入一个阻尼因子 $\\alpha \\in (0, 1]$，并以一个较小的步长进行更新，$\\mathbf{E}_{\\text{trial}} = \\mathbf{E}^{(m)} + \\alpha \\Delta\\mathbf{E}^{(m)}$。采用回溯线搜索来寻找合适的 $\\alpha$：\n1. 从 $\\alpha = 1$ 开始。\n2. 检查 $\\mathbf{E}_{\\text{trial}}$ 的所有分量是否为正。\n3. 如果不是，减小 $\\alpha$（例如，$\\alpha \\leftarrow \\alpha/2$）并重复，直到实现正性。\n这确保了任何对数的参数始终有效，防止数值计算失败。\n\n**为保证闭合性（$\\sum E_i = 1$）的归一化**：问题要求迭代值满足闭合约束。尽管牛顿步长被构造为位于平面 $\\sum \\Delta E_i = 0$ 上（如果初始时 $\\sum E_i^{(m)} = 1$），但浮点误差可能会累积。为在每步之后精确地强制执行此约束，我们对更新后的向量进行归一化。在找到一个保持正性的阻尼步长 $\\alpha \\Delta\\mathbf{E}^{(m)}$ 后，我们按以下方式形成新的迭代值 $\\mathbf{E}^{(m+1)}$：\n1. 计算试验向量：$\\mathbf{E}_{\\text{trial}} = \\mathbf{E}^{(m)} + \\alpha \\Delta\\mathbf{E}^{(m)}$。\n2. 将其归一化：$\\mathbf{E}^{(m+1)} = \\frac{\\mathbf{E}_{\\text{trial}}}{\\sum_{j=1}^N E_{\\text{trial},j}}$。\n这种到单位和单纯形上的投影确保了关键的物理约束始终得到满足，有助于求解器的稳定性。\n\n迭代过程始于一个初始猜测，通常是均匀分布 $\\mathbf{E}^{(0)} = (1/N, \\dots, 1/N)^T$，它同时满足正性和闭合性。迭代持续进行，直到残差向量的范数 $\\|\\mathbf{F}(\\mathbf{E})\\|$ 小于预定义的容差。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define and run the test suite for the ion exchange problem.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (charges, activities, selectivity_coeffs, ref_index)\n    test_cases = [\n        # 1. Happy path ternary system\n        (\n            np.array([1, 1, 2], dtype=float),       # charges {z_i}\n            np.array([0.01, 0.005, 0.002]),       # activities {a_i}\n            np.array([0.8, 3.0]),                  # K_ir values for i != r\n            0                                      # reference index r\n        ),\n        # 2. Binary exchange with strong divalent preference\n        (\n            np.array([1, 2], dtype=float),\n            np.array([0.001, 0.1]),\n            np.array([15.0]),\n            0\n        ),\n        # 3. Edge case with trace monovalent\n        (\n            np.array([1, 1, 2], dtype=float),\n            np.array([0.01, 1e-8, 0.005]),\n            np.array([0.9, 2.0]),\n            0\n        ),\n        # 4. Balanced monovalent ternary\n        (\n            np.array([1, 1, 1], dtype=float),\n            np.array([0.1, 0.1, 0.1]),\n            np.array([1.0, 1.0]),\n            0\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        charges, activities, k_ir_values, ref_index = case\n        e_fractions = _newton_ion_exchange(charges, activities, k_ir_values, ref_index)\n        results.append(e_fractions.tolist())\n\n    # Format the final output string exactly as specified.\n    # Example: [[0.1,0.2],[0.3,0.4]]\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]' for res in results])}]\"\n    print(output_str)\n\n\ndef _newton_ion_exchange(charges, activities, k_ir_values, ref_index, tol=1e-12, max_iter=100):\n    \"\"\"\n    Solves the multi-component ion exchange system using Newton-Raphson.\n\n    Args:\n        charges (np.ndarray): Array of integer charges {z_i}.\n        activities (np.ndarray): Array of aqueous activities {a_i}.\n        k_ir_values (np.ndarray): Array of Gaines-Thomas selectivity coefficients {K_ir}\n                               for non-reference species i.\n        ref_index (int): The 0-based index of the reference cation r.\n        tol (float): Convergence tolerance for the norm of the residual.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        np.ndarray: Converged vector of exchanger equivalent fractions {E_i}.\n    \"\"\"\n    N = len(charges)\n    z = charges\n    a = activities\n    r = ref_index\n\n    # Map K_ir values to their corresponding species indices\n    non_ref_indices = [i for i in range(N) if i != r]\n    K_map = dict(zip(non_ref_indices, k_ir_values))\n\n    # Pre-calculate constants C_i for the residual equations\n    # C_i = ln(K_ir) + z_r*ln(a_i) - z_i*ln(a_r)\n    C = {}\n    with np.errstate(divide='ignore'): # activities can be very small\n        log_a = np.log(a)\n    for i in non_ref_indices:\n        C[i] = np.log(K_map[i]) + z[r] * log_a[i] - z[i] * log_a[r]\n\n    # Initial guess for E: uniform distribution\n    E = np.full(N, 1.0 / N, dtype=float)\n\n    for _ in range(max_iter):\n        # 1. Construct Residual vector F\n        F = np.zeros(N, dtype=float)\n        \n        # Logarithms require E > 0. This is guarded by the line search.\n        # However, a check here protects the first iteration if E is bad.\n        if np.any(E = 0):\n            raise ValueError(\"Fractions must be positive.\")\n        log_E = np.log(E)\n\n        for k in range(N):\n            if k == r:\n                F[k] = np.sum(E) - 1.0\n            else:\n                F[k] = z[r] * log_E[k] - z[k] * log_E[r] - C[k]\n\n        # 2. Check for convergence\n        if np.linalg.norm(F)  tol:\n            return E\n\n        # 3. Construct Jacobian matrix J\n        J = np.zeros((N, N), dtype=float)\n        for k in range(N):\n            if k == r:\n                J[k, :] = 1.0\n            else:\n                J[k, k] = z[r] / E[k]\n                J[k, r] = -z[k] / E[r]\n        \n        # 4. Solve for the Newton step delta_E\n        try:\n            delta_E = np.linalg.solve(J, -F)\n        except np.linalg.LinAlgError:\n            raise RuntimeError(\"Jacobian is singular. Failed to find solution.\")\n\n        # 5. Backtracking line search for step size alpha to ensure E > 0\n        alpha = 1.0\n        while True:\n            E_trial = E + alpha * delta_E\n            if np.all(E_trial > 0):\n                E = E_trial\n                break\n            alpha /= 2.0\n            if alpha  1e-10: # Failsafe\n                raise RuntimeError(\"Line search failed. Could not maintain positivity.\")\n\n        # 6. Normalize E to enforce closure constraint\n        E /= np.sum(E)\n\n    # If loop finishes, convergence was not reached\n    raise RuntimeError(f\"Newton's method did not converge within {max_iter} iterations.\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}