{
    "hands_on_practices": [
        {
            "introduction": "本练习将带你实践瑞利蒸馏模型最核心的应用之一。通过从第一性原理出发推导瑞利方程，你将学会如何利用已知的初始同位素比率 $R_0$、残留相的同位素比率 $R$ 以及分馏系数 $\\alpha$，来反推体系演化的程度，即剩余物质分数 $f$。这项基本计算是理解和应用瑞利分馏模型解决地球化学问题的第一步。",
            "id": "4097486",
            "problem": "一个封闭系统脱气事件在恒定的同位素分馏条件下，以微小增量从硅酸盐熔体中移除氢。设氘与氕的重-轻同位素比值用 $R \\equiv N_{\\mathrm{D}}/N_{\\mathrm{H}}$ 表示，其中 $N_{\\mathrm{D}}$ 和 $N_{\\mathrm{H}}$ 分别是熔体中氘原子和氕原子的数量。脱气开始时，熔体的初始同位素比值为 $R_{0}$。在任何瞬间，产物（离开系统的蒸气）的同位素比值 $R_{\\mathrm{p}}$ 与瞬时熔体比值 $R$ 通过一个恒定的平衡分馏因子 $\\alpha$ 相关联，定义为 $\\alpha \\equiv R_{\\mathrm{p}}/R$。假设 $\\alpha > 0$ 且 $\\alpha \\neq 1$，并且除了在其形成时移除蒸气外，系统在质量上保持封闭。\n\n在脱气进行后，您采集了残余熔体同位素比值 $R$ 的单次测量值，并且您通过独立的约束条件已知 $R_{0}$ 和 $\\alpha$。将熔体中残余轻同位素的分数定义为 $f \\equiv N_{\\mathrm{H}}/N_{\\mathrm{H},0}$，其中 $N_{\\mathrm{H},0}$ 是熔体中轻同位素的初始量。\n\n给定值 $R_{0} = 1.5576 \\times 10^{-4}$，$R = 1.5645 \\times 10^{-4}$ 和 $\\alpha = 0.9850$，请在所述假设下，从适用于封闭系统瑞利分馏的第一性原理出发，根据这些数据推断 $f$。作为推理的一部分，请包括适当的检查，以确保推断出的 $f$ 满足物理边界 $0  f \\leq 1$，并且随着 $f$ 减小，$R$ 的变化方向与给定的 $\\alpha$ 一致。将您的最终答案 $f$ 表示为一个纯数，并四舍五入到四位有效数字。",
            "solution": "首先将对问题进行验证，以确保其科学上合理、提法恰当且客观。\n\n### 步骤1：提取已知条件\n- 重-轻同位素比值定义为 $R \\equiv N_{\\mathrm{D}}/N_{\\mathrm{H}}$。\n- 熔体的初始同位素比值为 $R_{0}$。\n- 产物（蒸气）的同位素比值为 $R_{\\mathrm{p}}$。\n- 平衡分馏因子是一个常数，定义为 $\\alpha \\equiv R_{\\mathrm{p}}/R$。\n- 分馏因子的约束条件为 $\\alpha > 0$ 且 $\\alpha \\neq 1$。\n- 系统是一个正在进行脱气的封闭系统，蒸气在形成时被移除。\n- 熔体中残余轻同位素的分数定义为 $f \\equiv N_{\\mathrm{H}}/N_{\\mathrm{H},0}$。\n- 轻同位素的初始量为 $N_{\\mathrm{H},0}$。\n- 给定的数值为 $R_{0} = 1.5576 \\times 10^{-4}$，$R = 1.5645 \\times 10^{-4}$ 和 $\\alpha = 0.9850$。\n- 任务是推断 $f$ 的值。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题描述了瑞利分馏的经典案例，这是地球化学和其他领域用于描述从有限储库中连续移除产物的系统中同位素分馏的基本模型。同位素比值、分馏因子 $\\alpha$ 和残余分数 $f$ 的定义都是标准的。硅酸盐熔体脱气过程中的氢同位素分馏是一个经过充分研究的、具有地球化学意义的过程。该问题具有科学依据。\n2.  **适定性**：该问题提供了所有必要的参数（$R_{0}$、$R$、$\\alpha$），以通过控制性瑞利方程确定唯一的未知变量 $f$。问题设定是自洽的，足以得到唯一解。\n3.  **客观性**：该问题使用精确的、定量的语言和已确立的科学定义进行陈述。没有主观或模棱两可的术语。\n4.  **一致性**：一个关键的检查是同位素变化方向与 $\\alpha$ 值之间的一致性。给定的分馏因子是 $\\alpha = 0.9850$，小于1。这表示产物（蒸气）相对于源（熔体）贫化重同位素（D）。因此，随着脱气的进行和物质的移除，残余熔体必须逐渐富集重同位素。这要求最终比值 $R$ 大于初始比值 $R_{0}$。提供的数据是 $R = 1.5645 \\times 10^{-4}$ 和 $R_{0} = 1.5576 \\times 10^{-4}$。确实，$R  R_{0}$，这与 $\\alpha  1$ 所隐含的物理过程是一致的。数据是内部一致的。\n5.  **真实性**：同位素比值是地球 D/H 系统的典型值，分馏因子对于岩浆温度下硅酸盐熔体和富水蒸气相之间的氢同位素分配来说是一个合理的值。\n\n### 步骤3：结论与行动\n该问题是有效的。它是瑞利分馏模型的一个适定的、科学上合理的、内部一致的应用。现在可以推导求解。\n\n### 推导与求解\n所描述的过程是瑞利分馏。我们从基本定义出发，推导控制方程。设 $N_{\\mathrm{H}}$ 和 $N_{\\mathrm{D}}$ 是在任何时候熔体储库中轻（氕）和重（氘）同位素的量。熔体中的同位素比值为 $R = N_{\\mathrm{D}}/N_{\\mathrm{H}}$。\n\n考虑从熔体中移除的无穷小量的蒸气。设这个增量包含 $dN_{\\mathrm{H}}$ 的轻同位素和 $dN_{\\mathrm{D}}$ 的重同位素。这个无穷小产物的同位素比值 $R_{\\mathrm{p}}$ 由移除量的比值给出：\n$$R_{\\mathrm{p}} = \\frac{dN_{\\mathrm{D}}}{dN_{\\mathrm{H}}}$$\n问题陈述，该产物比值通过恒定的分馏因子 $\\alpha$ 与瞬时熔体比值 $R$ 相关：\n$$R_{\\mathrm{p}} = \\alpha R$$\n代入比值的表达式，我们得到：\n$$\\frac{dN_{\\mathrm{D}}}{dN_{\\mathrm{H}}} = \\alpha \\frac{N_{\\mathrm{D}}}{N_{\\mathrm{H}}}$$\n这个微分方程可以通过分离重、轻同位素的变量来重新整理以进行积分：\n$$\\frac{dN_{\\mathrm{D}}}{N_{\\mathrm{D}}} = \\alpha \\frac{dN_{\\mathrm{H}}}{N_{\\mathrm{H}}}$$\n我们将此方程从初始状态（量为 $N_{\\mathrm{H},0}$ 和 $N_{\\mathrm{D},0}$）积分到最终状态（量为 $N_{\\mathrm{H}}$ 和 $N_{\\mathrm{D}}$）：\n$$\\int_{N_{\\mathrm{D},0}}^{N_{\\mathrm{D}}} \\frac{dN_{\\mathrm{D}}}{N_{\\mathrm{D}}} = \\alpha \\int_{N_{\\mathrm{H},0}}^{N_{\\mathrm{H}}} \\frac{dN_{\\mathrm{H}}}{N_{\\mathrm{H}}}$$\n计算积分得出：\n$$\\ln(N_{\\mathrm{D}}) - \\ln(N_{\\mathrm{D},0}) = \\alpha \\left[ \\ln(N_{\\mathrm{H}}) - \\ln(N_{\\mathrm{H},0}) \\right]$$\n使用对数的性质，这变为：\n$$\\ln\\left(\\frac{N_{\\mathrm{D}}}{N_{\\mathrm{D},0}}\\right) = \\alpha \\ln\\left(\\frac{N_{\\mathrm{H}}}{N_{\\mathrm{H},0}}\\right) = \\ln\\left[ \\left(\\frac{N_{\\mathrm{H}}}{N_{\\mathrm{H},0}}\\right)^{\\alpha} \\right]$$\n对两边取指数，得到每种同位素残余量之间的关系：\n$$\\frac{N_{\\mathrm{D}}}{N_{\\mathrm{D},0}} = \\left(\\frac{N_{\\mathrm{H}}}{N_{\\mathrm{H},0}}\\right)^{\\alpha}$$\n为了用同位素比值 $R$ 和 $R_{0}$ 表示，我们使用 $N_{\\mathrm{D}} = R N_{\\mathrm{H}}$ 和 $N_{\\mathrm{D},0} = R_{0} N_{\\mathrm{H},0}$：\n$$\\frac{R N_{\\mathrm{H}}}{R_{0} N_{\\mathrm{H},0}} = \\left(\\frac{N_{\\mathrm{H}}}{N_{\\mathrm{H},0}}\\right)^{\\alpha}$$\n重新整理以求解同位素比值的比率 $R/R_{0}$：\n$$\\frac{R}{R_{0}} = \\frac{N_{\\mathrm{H},0}}{N_{\\mathrm{H}}} \\left(\\frac{N_{\\mathrm{H}}}{N_{\\mathrm{H},0}}\\right)^{\\alpha} = \\left(\\frac{N_{\\mathrm{H}}}{N_{\\mathrm{H},0}}\\right)^{-1} \\left(\\frac{N_{\\mathrm{H}}}{N_{\\mathrm{H},0}}\\right)^{\\alpha} = \\left(\\frac{N_{\\mathrm{H}}}{N_{\\mathrm{H},0}}\\right)^{\\alpha-1}$$\n问题将残余轻同位素的分数定义为 $f \\equiv N_{\\mathrm{H}}/N_{\\mathrm{H},0}$。代入此定义可得到瑞利分馏方程的标准形式：\n$$\\frac{R}{R_{0}} = f^{\\alpha-1}$$\n我们需要求解 $f$。对两边取自然对数：\n$$\\ln\\left(\\frac{R}{R_{0}}\\right) = (\\alpha-1)\\ln(f)$$\n分离出 $\\ln(f)$：\n$$\\ln(f) = \\frac{\\ln(R/R_{0})}{\\alpha-1}$$\n最后，我们可以通过取指数来求解 $f$：\n$$f = \\exp\\left(\\frac{\\ln(R/R_{0})}{\\alpha-1}\\right)$$\n现在，我们代入给定值：\n$R_{0} = 1.5576 \\times 10^{-4}$\n$R = 1.5645 \\times 10^{-4}$\n$\\alpha = 0.9850$\n\n首先，计算比率 $R/R_{0}$：\n$$\\frac{R}{R_{0}} = \\frac{1.5645 \\times 10^{-4}}{1.5576 \\times 10^{-4}} = \\frac{1.5645}{1.5576} \\approx 1.004430$$\n接下来，计算项 $\\alpha-1$：\n$$\\alpha-1 = 0.9850 - 1 = -0.0150$$\n现在，将这些代入 $f$ 的表达式中：\n$$f = \\exp\\left(\\frac{\\ln(1.5645/1.5576)}{-0.0150}\\right)$$\n$$f \\approx \\exp\\left(\\frac{\\ln(1.004430)}{-0.0150}\\right) \\approx \\exp\\left(\\frac{0.0044202}{-0.0150}\\right) \\approx \\exp(-0.29468)$$\n$$f \\approx 0.74476$$\n问题要求答案四舍五入到四位有效数字。\n$$f \\approx 0.7448$$\n作为对物理边界的最终检查，计算出的值 $f \\approx 0.7448$ 介于0和1之间，这对于残余物种的分数是物理上必需的。这证实了结果的有效性。它表明大约 $74.48\\%$ 的原始氢（氕）保留在熔体中。",
            "answer": "$$\\boxed{0.7448}$$"
        },
        {
            "introduction": "在实际研究中，分馏系数 $\\alpha$ 往往是需要通过实验数据来确定的未知参数。本练习将指导你如何将非线性的瑞利方程转化为线性形式，从而应用统计回归方法从一系列 $(f, R)$ 数据点中估算 $\\alpha$ 及其不确定性。你将通过处理初始比率 $R_0$ 已知和未知两种情况，掌握加权最小二乘法和贝叶斯线性回归等关键的计算地球化学数据分析技术。",
            "id": "4097453",
            "problem": "在计算地球化学中，您正在使用瑞利分馏模型来模拟封闭系统移除过程中的同位素演化。设残余物的同位素比值为 $R$，定义为残余物中重同位素与轻同位素的比值，并设 $f$ 表示原始储库的剩余分数。瞬时产物相对于储库发生分馏，其分馏因子为 $\\alpha$，定义为移除过程中产物与储库的同位素比值之比。初始同位素比值（当 $f = 1$ 时）为 $R_0$。测量提供了多个 $f$ 值下的 $R$ 值及其相关的不确定度，但 $R_0$ 可能被直接测量，也可能没有。您的任务是：\n- 从瑞利分馏的同位素分馏和质量平衡的基本定义出发，推导出一个关于适当变换变量之间的线性关系，该关系允许通过线性回归估算分馏因子 $\\alpha$。解释当 $R_0$ 已知时与当 $R_0$ 不确定且未被直接测量时，应分别使用哪种回归形式。\n- 设计算法，(i) 当 $R_0$ 已知时，使用符合统计学原理的零截距线性回归公式估算 $\\alpha$；(ii) 当 $R_0$ 未被直接测量但其不确定度由 $\\ln R_0$ 的高斯先验表征时，通过将 $\\ln R_0$ 视为具有高斯先验的讨厌参数，使用贝叶斯线性回归估算 $\\alpha$。在这两种情况下，报告与假定的高斯测量噪声一致的 $\\alpha$ 的一倍标准差不确定度，并且在贝叶斯情况下，与指定的先验一致。\n- 使用对数的一阶不确定度传播来变换测量不确定度：如果在某一点 $R$ 的测量不确定度为 $\\sigma_R$，则 $\\ln R$ 的不确定度为 $\\sigma_{\\ln R} \\approx \\sigma_R / R$。当使用 $\\ln(R/R_0)$ 且 $R_0$ 已知时，不确定度相同，$\\sigma_{\\ln(R/R_0)} \\approx \\sigma_R / R$，假设 $R_0$ 没有不确定度。\n\n本问题中所有量均为无量纲。您的程序必须为以下测试套件实现所要求的估算过程。每个测试案例指定了 $f$、测量的 $R$ 和 $\\sigma_R$ 的数组；对于已知 $R_0$ 的情况，提供了常数 $R_0$；对于未知 $R_0$ 的情况，通过其均值和标准差指定了 $\\ln R_0$ 的高斯先验，并通过其标准差指定了斜率的高斯先验。对于每个测试案例，计算两个输出：估算的 $\\alpha$ 及其一倍标准差不确定度，两者都表示为小数（无量纲），并四舍五入到六位小数。\n\n测试套件：\n- 案例 A（已知 $R_0$，宽 $f$ 范围）：\n  - $f = [1.0, 0.8, 0.6, 0.5, 0.35]$\n  - $R_0 = 0.0112372$\n  - $R = [0.0112372, 0.0112435, 0.0112516, 0.0112567, 0.0112668]$\n  - $\\sigma_R = [5 \\times 10^{-7}, 5 \\times 10^{-7}, 5 \\times 10^{-7}, 5 \\times 10^{-7}, 5 \\times 10^{-7}]$\n- 案例 B（未知 $R_0$，对 $\\ln R_0$ 有信息先验）：\n  - $f = [1.0, 0.7, 0.5, 0.3, 0.15]$\n  - $R = [0.0020550, 0.0020631, 0.0020708, 0.0020824, 0.0020983]$\n  - $\\sigma_R = [2 \\times 10^{-6}, 2 \\times 10^{-6}, 2 \\times 10^{-6}, 2 \\times 10^{-6}, 2 \\times 10^{-6}]$\n  - $\\ln R_0$ 的先验：均值 $\\mu_{\\ln R_0} = \\ln(0.0020)$，标准差 $\\sigma_{\\ln R_0} = 0.1$\n  - 斜率的先验：标准差 $\\sigma_{\\text{slope}} = 1.0$\n- 案例 C（已知 $R_0$，$f$ 接近 1，弱分馏）：\n  - $f = [1.0, 0.95, 0.9]$\n  - $R_0 = 0.0112372$\n  - $R = [0.0112372, 0.0112369, 0.0112366]$\n  - $\\sigma_R = [3 \\times 10^{-7}, 3 \\times 10^{-7}, 3 \\times 10^{-7}]$\n- 案例 D（未知 $R_0$，对 $\\ln R_0$ 有宽先验，非常小的 $f$）：\n  - $f = [1.0, 0.5, 0.25, 0.125, 0.0625]$\n  - $R = [0.0032000, 0.0032111, 0.0032223, 0.0032333, 0.0032444]$\n  - $\\sigma_R = [8 \\times 10^{-7}, 8 \\times 10^{-7}, 8 \\times 10^{-7}, 8 \\times 10^{-7}, 8 \\times 10^{-7}]$\n  - $\\ln R_0$ 的先验：均值 $\\mu_{\\ln R_0} = \\ln(0.0035)$，标准差 $\\sigma_{\\ln R_0} = 0.2$\n  - 斜率的先验：标准差 $\\sigma_{\\text{slope}} = 2.0$\n- 案例 E（已知 $R_0$，一个点具有高测量不确定度）：\n  - $f = [1.0, 0.8, 0.6, 0.4]$\n  - $R_0 = 0.002055$\n  - $R = [0.0020550, 0.0020619, 0.0020708, 0.0020834]$\n  - $\\sigma_R = [1 \\times 10^{-6}, 1 \\times 10^{-5}, 1 \\times 10^{-6}, 1 \\times 10^{-6}]$\n\n算法要求：\n- 对于已知 $R_0$ 的情况，使用 $y = \\ln(R/R_0)$ 对 $x = \\ln f$ 的零截距加权线性回归。设权重为 $w_i = 1 / \\sigma_{y_i}^2$，其中 $\\sigma_{y_i} \\approx \\sigma_{R_i} / R_i$。计算斜率 $\\hat{s}$ 及其方差 $\\operatorname{Var}(\\hat{s})$，并报告 $\\hat{\\alpha} = \\hat{s} + 1$ 和 $\\sigma_{\\alpha} = \\sqrt{\\operatorname{Var}(\\hat{s})}$。\n- 对于未知 $R_0$ 的情况，使用 $y = \\ln R$ 对 $x = \\ln f$ 的贝叶斯线性回归，截距为 $b = \\ln R_0$，斜率为 $m = \\alpha - 1$。假设似然为 $y_i \\sim \\mathcal{N}(m x_i + b, \\sigma_{y_i}^2)$，并有独立的高斯先验 $m \\sim \\mathcal{N}(\\mu_m, \\sigma_m^2)$ 和 $b \\sim \\mathcal{N}(\\mu_b, \\sigma_b^2)$。计算 $(m, b)$ 的后验均值和协方差；报告 $\\hat{\\alpha} = \\mathbb{E}[m] + 1$ 和 $\\sigma_{\\alpha} = \\sqrt{\\operatorname{Var}(m)}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含 $10$ 个数字：对于从 A 到 E 的五个案例中的每一个，依次输出估算的 $\\alpha$ 及其一倍标准差不确定度，每个数字都四舍五入到六位小数。例如，格式应为 $[\\alpha_A,\\sigma_A,\\alpha_B,\\sigma_B,\\alpha_C,\\sigma_C,\\alpha_D,\\sigma_D,\\alpha_E,\\sigma_E]$，所有值均为小数且无单位（无量纲）。",
            "solution": "用户提供的问题陈述已经过分析，并被认为是**有效的**。它以同位素地球化学原理为科学基础，是良定的，提供了所有必要信息，并且表述客观。任务涉及标准推导以及将已建立的统计方法（加权最小二乘法和贝叶斯线性回归）应用于地球化学数据。该问题是非平凡的、一致的且可验证的。\n\n### 线性关系的推导\n\n瑞利分馏过程描述了一个系统中同位素比值的演化，其中产物从一个有限储库中被连续且不可逆地移除。我们被要求从该模型的基本原理推导出一个线性关系。\n\n设在任何给定时间，储库中重同位素和轻同位素的摩尔数分别为 $N_h$ 和 $N_l$。储库中的同位素比值为 $R = N_h/N_l$。从储库中移除无穷小量的物质，其中含有 $dN_h$ 和 $dN_l$ 摩尔的重同位素和轻同位素。这种瞬时产物的同位素比值为 $R_p = dN_h/dN_l$。\n\n分馏因子 $\\alpha$ 定义为产物与储库中同位素比值之比：\n$$\n\\alpha = \\frac{R_p}{R}\n$$\n代入 $R_p$ 和 $R$ 的定义得到：\n$$\n\\alpha = \\frac{dN_h/dN_l}{N_h/N_l}\n$$\n这个方程可以重新排列成一个可分离的微分形式：\n$$\n\\frac{dN_h}{N_h} = \\alpha \\frac{dN_l}{N_l}\n$$\n为了找到初始状态和最终状态之间的关系，我们将此方程从初始状态（用下标 $0$ 表示）积分到一个后续状态：\n$$\n\\int_{N_{h,0}}^{N_h} \\frac{d\\tilde{N}_h}{\\tilde{N}_h} = \\alpha \\int_{N_{l,0}}^{N_l} \\frac{d\\tilde{N}_l}{\\tilde{N}_l}\n$$\n假设在整个过程中 $\\alpha$ 是恒定的，积分得到：\n$$\n\\ln\\left(\\frac{N_h}{N_{h,0}}\\right) = \\alpha \\ln\\left(\\frac{N_l}{N_{l,0}}\\right)\n$$\n我们可以用同位素比值 $R = N_h/N_l$ 和 $R_0 = N_{h,0}/N_{l,0}$ 来表示 $N_h$ 和 $N_{h,0}$：\n$$\n\\ln\\left(\\frac{R N_l}{R_0 N_{l,0}}\\right) = \\alpha \\ln\\left(\\frac{N_l}{N_{l,0}}\\right)\n$$\n使用对数的性质，我们分离各项：\n$$\n\\ln\\left(\\frac{R}{R_0}\\right) + \\ln\\left(\\frac{N_l}{N_{l,0}}\\right) = \\alpha \\ln\\left(\\frac{N_l}{N_{l,0}}\\right)\n$$\n重新整理得到：\n$$\n\\ln\\left(\\frac{R}{R_0}\\right) = (\\alpha - 1) \\ln\\left(\\frac{N_l}{N_{l,0}}\\right)\n$$\n原始储库的剩余分数 $f$ 通常近似为主要（轻）同位素的剩余分数，$f \\approx N_l/N_{l,0}$，特别是当重同位素稀有时。将 $f$ 代入方程，得到经典的瑞利分馏方程：\n$$\n\\ln\\left(\\frac{R}{R_0}\\right) = (\\alpha - 1) \\ln f\n$$\n这个方程提供了所需的线性关系。\n\n- **当 $R_0$ 已知时：** 我们可以定义变量 $y = \\ln(R/R_0)$ 和 $x = \\ln f$。模型变为 $y = m x$，其中斜率为 $m = \\alpha - 1$。这是一个通过原点 $(0,0)$ 的线性模型。分馏因子 $\\alpha$ 可以通过强制过原点的线性回归的斜率来估算。\n\n- **当 $R_0$ 未知或不确定时：** 我们不能直接构造变量 $y = \\ln(R/R_0)$。相反，我们将瑞利方程重新排列为：\n$$\n\\ln R = (\\alpha - 1) \\ln f + \\ln R_0\n$$\n这是一个 $y = m x + b$ 形式的线性模型，其中 $y = \\ln R$，$x = \\ln f$，斜率为 $m = \\alpha - 1$，截距为 $b = \\ln R_0$。$\\alpha$ 和 $R_0$ 都可以通过标准线性回归的斜率和截距来估算。\n\n### 算法设计\n\n**i. 已知 $R_0$：零截距加权线性回归**\n\n当 $R_0$ 已知且没有不确定度时，我们使用模型 $y_i = m x_i + \\epsilon_i$，其中：\n- $y_i = \\ln(R_i/R_0)$\n- $x_i = \\ln f_i$\n- $m = \\alpha - 1$\n- 误差 $\\epsilon_i$ 被假定为相互独立且服从均值为 $0$、方差为 $\\sigma_{y_i}^2$ 的正态分布。\n\n不确定度 $\\sigma_{y_i}$ 是从测量不确定度 $\\sigma_{R_i}$ 通过对数的一阶近似传播得到的：$\\sigma_{y_i} = \\sigma_{\\ln(R_i/R_0)} \\approx \\sigma_{R_i}/R_i$。我们使用加权线性回归来解释异方差性（不同的不确定度）。权重为 $w_i = 1/\\sigma_{y_i}^2$。\n\n斜率的最佳估计 $\\hat{m}$ 是使加权残差平方和 $\\chi^2 = \\sum_i w_i (y_i - m x_i)^2$ 最小化的值。解为：\n$$\n\\hat{m} = \\frac{\\sum_i w_i x_i y_i}{\\sum_i w_i x_i^2}\n$$\n该估计的方差为：\n$$\n\\operatorname{Var}(\\hat{m}) = \\frac{1}{\\sum_i w_i x_i^2}\n$$\n由此，我们计算 $\\alpha$ 的估计值及其一倍标准差不确定度 $\\sigma_\\alpha$：\n$$\n\\hat{\\alpha} = \\hat{m} + 1 \\quad \\text{和} \\quad \\sigma_\\alpha = \\sqrt{\\operatorname{Var}(\\hat{m})}\n$$\n$f=1$ 处的数据点对应于 $x=\\ln(1)=0$ 和 $y=\\ln(R_0/R_0)=0$。这个点 $(0,0)$ 对于估算斜率不提供任何信息，因此从求和中排除。\n\n**ii. 未知 $R_0$：贝叶斯线性回归**\n\n当 $R_0$ 未被直接测量并被视为具有相关先验的讨厌参数时，我们使用模型 $y_i = m x_i + b + \\epsilon_i$，其中：\n- $y_i = \\ln R_i$\n- $x_i = \\ln f_i$\n- $m = \\alpha - 1$\n- $b = \\ln R_0$\n- 误差 $\\epsilon_i$ 服从 $\\mathcal{N}(0, \\sigma_{y_i}^2)$ 分布，其中 $\\sigma_{y_i} \\approx \\sigma_{R_i}/R_i$。\n\n设参数向量为 $\\boldsymbol{\\theta} = [m, b]^T$。模型的矩阵形式为 $\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\theta} + \\boldsymbol{\\epsilon}$，其中 $\\mathbf{X}$ 是设计矩阵，$\\boldsymbol{\\epsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma}_y)$，$\\boldsymbol{\\Sigma}_y$ 是方差 $\\sigma_{y_i}^2$ 的对角矩阵。似然为 $p(\\mathbf{y}|\\boldsymbol{\\theta}) \\propto \\exp(-\\frac{1}{2}(\\mathbf{y}-\\mathbf{X}\\boldsymbol{\\theta})^T \\boldsymbol{\\Sigma}_y^{-1} (\\mathbf{y}-\\mathbf{X}\\boldsymbol{\\theta}))$。\n\n我们假设参数具有独立的高斯先验：\n- 斜率：$m \\sim \\mathcal{N}(\\mu_m, \\sigma_m^2)$。根据指定，我们采用零均值先验，$\\mu_m=0$，方差 $\\sigma_m^2$ 由先验标准差的平方给出。\n- 截距：$b \\sim \\mathcal{N}(\\mu_b, \\sigma_b^2)$，其中给定了 $\\mu_b=\\mu_{\\ln R_0}$ 和 $\\sigma_b^2=\\sigma_{\\ln R_0}^2$。\n\n$\\boldsymbol{\\theta}$ 的先验分布为 $p(\\boldsymbol{\\theta}) \\propto \\exp(-\\frac{1}{2}(\\boldsymbol{\\theta}-\\boldsymbol{\\mu}_0)^T \\boldsymbol{\\Sigma}_0^{-1} (\\boldsymbol{\\theta}-\\boldsymbol{\\mu}_0))$，其中 $\\boldsymbol{\\mu}_0 = [\\mu_m, \\mu_b]^T$，$\\boldsymbol{\\Sigma}_0$ 是对角先验协方差矩阵。\n\n$\\boldsymbol{\\theta}$ 的后验分布也是高斯分布，$\\boldsymbol{\\theta} | \\mathbf{y} \\sim \\mathcal{N}(\\boldsymbol{\\mu}_N, \\boldsymbol{\\Sigma}_N)$，其后验协方差 $\\boldsymbol{\\Sigma}_N$ 和均值 $\\boldsymbol{\\mu}_N$ 由下式给出：\n$$\n\\boldsymbol{\\Sigma}_N = \\left(\\mathbf{X}^T \\boldsymbol{\\Sigma}_y^{-1} \\mathbf{X} + \\boldsymbol{\\Sigma}_0^{-1}\\right)^{-1}\n$$\n$$\n\\boldsymbol{\\mu}_N = \\boldsymbol{\\Sigma}_N \\left(\\mathbf{X}^T \\boldsymbol{\\Sigma}_y^{-1} \\mathbf{y} + \\boldsymbol{\\Sigma}_0^{-1} \\boldsymbol{\\mu}_0\\right)\n$$\n斜率 $m$ 的估计值是其后验均值，$\\mathbb{E}[m] = (\\boldsymbol{\\mu}_N)_1$，其方差是后验协方差矩阵的相应对角元素，$\\operatorname{Var}(m) = (\\boldsymbol{\\Sigma}_N)_{11}$。所需的输出则为：\n$$\n\\hat{\\alpha} = \\mathbb{E}[m] + 1 \\quad \\text{和} \\quad \\sigma_\\alpha = \\sqrt{\\operatorname{Var}(m)}\n$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_known_r0(f, R, sigma_R, R0):\n    \"\"\"\n    Estimates alpha and its uncertainty for known R0 using weighted linear \n    regression through the origin.\n    \"\"\"\n    f_arr = np.array(f, dtype=float)\n    R_arr = np.array(R, dtype=float)\n    sigma_R_arr = np.array(sigma_R, dtype=float)\n    \n    # Exclude the point at f=1, as it provides no information on the slope.\n    # The model is y = m*x, so the point (0,0) is automatically satisfied.\n    mask = f_arr  1.0\n    if not np.any(mask):\n        return np.nan, np.nan # Not enough data to determine slope\n\n    # Transformed variables and uncertainties\n    x = np.log(f_arr[mask])\n    y = np.log(R_arr[mask] / R0)\n    sigma_y = sigma_R_arr[mask] / R_arr[mask]\n    \n    # Weights for WLS\n    w = 1.0 / sigma_y**2\n    \n    # Calculate slope and its variance for y = m*x\n    sum_wxy = np.sum(w * x * y)\n    sum_wx2 = np.sum(w * x**2)\n    \n    m_hat = sum_wxy / sum_wx2\n    var_m_hat = 1.0 / sum_wx2\n    \n    # Calculate alpha from the slope m = alpha - 1\n    alpha_hat = m_hat + 1.0\n    sigma_alpha = np.sqrt(var_m_hat)\n    \n    return alpha_hat, sigma_alpha\n\ndef solve_unknown_r0(f, R, sigma_R, prior_lnR0_mean, prior_lnR0_std, prior_slope_std):\n    \"\"\"\n    Estimates alpha and its uncertainty for unknown R0 using Bayesian linear regression.\n    \"\"\"\n    f_arr = np.array(f, dtype=float)\n    R_arr = np.array(R, dtype=float)\n    sigma_R_arr = np.array(sigma_R, dtype=float)\n    \n    # Transformed variables and uncertainties\n    x = np.log(f_arr)\n    y = np.log(R_arr)\n    sigma_y = sigma_R_arr / R_arr\n    \n    # Weight matrix (inverse of data covariance matrix)\n    W = np.diag(1.0 / sigma_y**2)\n    \n    # Design matrix for y = m*x + b\n    # Column 0 for slope (m), column 1 for intercept (b)\n    X = np.vstack((x, np.ones_like(x))).T\n\n    # Prior distributions\n    # Slope (m) prior: N(0, prior_slope_std^2)\n    # Intercept (b = ln R0) prior: N(prior_lnR0_mean, prior_lnR0_std^2)\n    mu_m = 0.0\n    sigma_m = prior_slope_std\n    mu_b = prior_lnR0_mean\n    sigma_b = prior_lnR0_std\n\n    mu_0 = np.array([mu_m, mu_b])\n    Sigma_0_inv = np.diag([1.0 / sigma_m**2, 1.0 / sigma_b**2])\n\n    # Posterior distribution calculation\n    Sigma_N_inv = X.T @ W @ X + Sigma_0_inv\n    Sigma_N = np.linalg.inv(Sigma_N_inv)\n    \n    mu_N = Sigma_N @ (X.T @ W @ y + Sigma_0_inv @ mu_0)\n    \n    # Extract posterior mean and variance for the slope m\n    m_hat_posterior_mean = mu_N[0]\n    m_hat_posterior_var = Sigma_N[0, 0]\n\n    # Calculate alpha from the slope m = alpha - 1\n    alpha_hat = m_hat_posterior_mean + 1.0\n    sigma_alpha = np.sqrt(m_hat_posterior_var)\n    \n    return alpha_hat, sigma_alpha\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A (known R0)\n        {\n            \"type\": \"known_r0\",\n            \"f\": [1.0, 0.8, 0.6, 0.5, 0.35],\n            \"R0\": 0.0112372,\n            \"R\": [0.0112372, 0.0112435, 0.0112516, 0.0112567, 0.0112668],\n            \"sigma_R\": [5e-7, 5e-7, 5e-7, 5e-7, 5e-7],\n        },\n        # Case B (unknown R0)\n        {\n            \"type\": \"unknown_r0\",\n            \"f\": [1.0, 0.7, 0.5, 0.3, 0.15],\n            \"R\": [0.0020550, 0.0020631, 0.0020708, 0.0020824, 0.0020983],\n            \"sigma_R\": [2e-6, 2e-6, 2e-6, 2e-6, 2e-6],\n            \"prior_lnR0_mean\": np.log(0.0020),\n            \"prior_lnR0_std\": 0.1,\n            \"prior_slope_std\": 1.0,\n        },\n        # Case C (known R0)\n        {\n            \"type\": \"known_r0\",\n            \"f\": [1.0, 0.95, 0.9],\n            \"R0\": 0.0112372,\n            \"R\": [0.0112372, 0.0112369, 0.0112366],\n            \"sigma_R\": [3e-7, 3e-7, 3e-7],\n        },\n        # Case D (unknown R0)\n        {\n            \"type\": \"unknown_r0\",\n            \"f\": [1.0, 0.5, 0.25, 0.125, 0.0625],\n            \"R\": [0.0032000, 0.0032111, 0.0032223, 0.0032333, 0.0032444],\n            \"sigma_R\": [8e-7, 8e-7, 8e-7, 8e-7, 8e-7],\n            \"prior_lnR0_mean\": np.log(0.0035),\n            \"prior_lnR0_std\": 0.2,\n            \"prior_slope_std\": 2.0,\n        },\n        # Case E (known R0, high uncertainty point)\n        {\n            \"type\": \"known_r0\",\n            \"f\": [1.0, 0.8, 0.6, 0.4],\n            \"R0\": 0.002055,\n            \"R\": [0.0020550, 0.0020619, 0.0020708, 0.0020834],\n            \"sigma_R\": [1e-6, 1e-5, 1e-6, 1e-6],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[\"type\"] == \"known_r0\":\n            alpha, sigma = solve_known_r0(\n                case[\"f\"], case[\"R\"], case[\"sigma_R\"], case[\"R0\"]\n            )\n        elif case[\"type\"] == \"unknown_r0\":\n            alpha, sigma = solve_unknown_r0(\n                case[\"f\"], case[\"R\"], case[\"sigma_R\"], \n                case[\"prior_lnR0_mean\"], case[\"prior_lnR0_std\"], case[\"prior_slope_std\"]\n            )\n        results.extend([alpha, sigma])\n\n    # Format output to six decimal places\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的同位素分馏过程往往比恒定分馏系数的模型更为复杂，例如，温度的变化会直接影响 $\\alpha$ 的值。本练习旨在挑战你将瑞利蒸馏模型从代数方程推广到微分方程形式，以描述分馏系数随温度（以及剩余分数 $f$）变化时的同位素演化路径。通过建立并求解该常微分方程，你将能够模拟更贴近自然过程的复杂场景，并掌握进行数值积分求解的计算方法。",
            "id": "4097501",
            "problem": "一个经历瑞利蒸馏的封闭储库，在瞬时平衡分配的条件下，每一步都会损失微量的挥发性组分。设该组分拥有一对同位素，重同位素的储库摩尔数为$N_h$，轻同位素的储库摩尔数为$N_l$，并定义瞬时储库同位素比值为$R = N_h / N_l$。令$N = N_h + N_l$为该组分的储库总摩尔数，并定义剩余分数$f = N / N_0$，其中$N_0$是初始总摩尔数，因此$f \\in (0,1]$。假设分馏因子依赖于温度，记为$\\alpha(T)$，并定义为产物同位素比值与储库同位素比值的平衡比，即$\\alpha(T) = R_{\\mathrm{product}} / R_{\\mathrm{reservoir}}$，其中$R_{\\mathrm{product}}$是在该步骤中移除的微量物质的同位素比值。温度通过一个已知的映射$T = T(f)$随$f$确定性地变化，单位为开尔文。\n\n任务：\n- 从同位素质量平衡和分馏因子的定义出发，当$\\alpha$通过$T = T(f)$依赖于温度时，建立储库同位素比值$R$作为剩余分数$f$的函数的控制性常微分方程 (ODE)。解释对$f$的对数依赖关系的出现以及$\\alpha(T(f))$在ODE中的作用，不要使用任何快捷公式。\n- 在给定$R(1) = R_0$、$\\alpha(T)$的特定函数形式以及$T(f)$的特定映射的情况下，概述获得$R(f)$的积分过程，阐明所使用的任何近似以及导致对$f$进行积分的变量数学变换。\n- 基于导出的ODE，实现一个程序，使用对$f$的稳健求积法，为给定的参数集数值计算$R(f)$。该程序必须使用以下分馏因子模型：\n  $$ \\alpha(T) = \\exp\\!\\left(\\frac{A}{T^2} + \\frac{B}{T} + C\\right), $$\n  其中$A$、$B$和$C$是无量纲系数，$T$的单位是开尔文。使用指定为以下任一形式的温度模型：\n  1. 线性模型：$$T(f) = T_{\\min} + \\left(T_{\\max} - T_{\\min}\\right) f,$$\n  2. 恒定模型：$$T(f) = T_{\\mathrm{const}},$$\n  3. 幂律模型：$$T(f) = T_{\\min} + \\left(T_{\\max} - T_{\\min}\\right) f^{p}.$$\n  所有温度必须以开尔文为单位，且$p$是无量纲的。同位素比值$R$是无量纲的。\n- 假设重同位素相对于轻同位素是痕量的，因此在典型的地球化学系统中，任何援引$R \\ll 1$的近似在物理上都是合理的。\n\n您的程序必须为以下每个测试用例计算$R(f_{\\mathrm{end}})$，其中$R_0$是初始比值$R(1)$，$f_{\\mathrm{end}}$是最终剩余分数：\n1. $R_0 = 0.002$，$f_{\\mathrm{end}} = 0.3$，线性温度模型，$T_{\\min} = 280\\,\\mathrm{K}$，$T_{\\max} = 300\\,\\mathrm{K}$，分馏系数为$A = 2.0$，$B = 0.5$，$C = -0.0005$。\n2. $R_0 = 0.002$，$f_{\\mathrm{end}} = 0.5$，恒定温度模型，$T_{\\mathrm{const}} = 298\\,\\mathrm{K}$，分馏系数为$A = 0.0$，$B = 0.0$，$C = 0.002$。\n3. $R_0 = 0.0015$，$f_{\\mathrm{end}} = 0.1$，幂律温度模型，$T_{\\min} = 270\\,\\mathrm{K}$，$T_{\\max} = 320\\,\\mathrm{K}$，$p = 0.5$，分馏系数为$A = 1.0$，$B = -0.2$，$C = 0.0002$。\n4. $R_0 = 0.0025$，$f_{\\mathrm{end}} = 0.99$，幂律温度模型，$T_{\\min} = 295\\,\\mathrm{K}$，$T_{\\max} = 300\\,\\mathrm{K}$，$p = 2.0$，分馏系数为$A = 3.0$，$B = 0.0$，$C = 0.0$。\n5. $R_0 = 0.001$，$f_{\\mathrm{end}} = 0.01$，线性温度模型，$T_{\\min} = 260\\,\\mathrm{K}$，$T_{\\max} = 310\\,\\mathrm{K}$，分馏系数为$A = 0.5$，$B = 0.3$，$C = -0.0003$。\n\n所有输出必须表示为无量纲浮点数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个$r_i$是第$i$个测试用例计算出的$R(f_{\\mathrm{end}})$值，顺序如上所列。",
            "solution": "该问题要求推导并随后对控制同位素分馏的方程进行数值求解，该过程为瑞利蒸馏过程，其中分馏因子$\\alpha$依赖于温度$T$，而温度$T$又是组分剩余分数$f$的确定性函数。推导从质量平衡的基本原理出发。\n\n**1. 控制性常微分方程 (ODE) 的建立**\n\n令$N_h$和$N_l$分别表示储库中重同位素和轻同位素的摩尔数。该组分的总摩尔数为$N = N_h + N_l$。储库的同位素比值定义为$R = N_h / N_l$。\n\n在瑞利过程中，从储库中移出微量的组分$dN^{\\mathrm{prod}}$。此移除导致储库总摩尔数发生变化$dN$，其中$dN = -dN^{\\mathrm{prod}}$。由于移出的量为正，$dN^{\\mathrm{prod}}  0$，因此$dN$是一个负值。储库中重同位素和轻同位素的摩尔数变化分别为$dN_h$和$dN_l$。\n\n被移除产物的同位素比值为$R_{\\mathrm{product}} = dN_h^{\\mathrm{prod}} / dN_l^{\\mathrm{prod}}$。质量守恒要求每种同位素的移除量等于储库中该同位素变化量的负值，因此$dN_h^{\\mathrm{prod}} = -dN_h$，$dN_l^{\\mathrm{prod}} = -dN_l$。所以，\n$$ R_{\\mathrm{product}} = \\frac{-dN_h}{-dN_l} = \\frac{dN_h}{dN_l} $$\n分馏因子$\\alpha$定义为产物的同位素组成与储库的同位素组成之比：\n$$ \\alpha = \\frac{R_{\\mathrm{product}}}{R_{\\mathrm{reservoir}}} = \\frac{dN_h/dN_l}{N_h/N_l} $$\n这给出了同位素丰度微分变化之间的直接关系：\n$$ dN_h = \\alpha R dN_l $$\n为了找到储库比值$R$的演化，我们使用商法则对$R = N_h / N_l$进行微分：\n$$ dR = \\frac{N_l dN_h - N_h dN_l}{N_l^2} = \\frac{dN_h}{N_l} - \\frac{N_h}{N_l} \\frac{dN_l}{N_l} = \\frac{dN_h}{N_l} - R \\frac{dN_l}{N_l} $$\n将$dN_h = \\alpha R dN_l$代入此表达式，得到：\n$$ dR = \\frac{\\alpha R dN_l}{N_l} - R \\frac{dN_l}{N_l} = (\\alpha - 1) R \\frac{dN_l}{N_l} $$\n该方程将储库同位素比值的变化与轻同位素丰度的分数变化联系起来。为了用总摩尔数$N$来表示，我们使用问题中陈述的近似，即重同位素是痕量组分，即$N_h \\ll N_l$。这意味着总摩尔数$N = N_h + N_l \\approx N_l$，因此微分变化$dN \\approx dN_l$。在这个标准且物理上合理的近似下，方程变为：\n$$ \\frac{dR}{R} = (\\alpha - 1) \\frac{dN}{N} $$\n这是同位素地球化学中的一个开创性方程。最后一步是将自变量从总摩尔数$N$更改为剩余分数$f$。分数$f$定义为$f = N/N_0$，其中$N_0$是过程开始时（$f=1$）的初始总摩尔数。对此定义进行微分得到$df = dN/N_0$，或$dN = N_0 df$。将此式和$N = N_0 f$代入$dN/N$的表达式中：\n$$ \\frac{dN}{N} = \\frac{N_0 df}{N_0 f} = \\frac{df}{f} $$\n此代换直接得到关于$R$作为$f$的函数的控制性ODE：\n$$ \\frac{dR}{df} = \\frac{R}{f}(\\alpha - 1) $$\n问题指明分馏因子$\\alpha$是温度$T$的函数，而温度$T$本身是剩余分数$f$的函数，即$\\alpha = \\alpha(T(f))$。因此，ODE的最终形式为：\n$$ \\frac{dR}{df} = \\frac{R}{f}(\\alpha(T(f)) - 1) $$\n对$f$的对数依赖关系的出现是$df/f$项的直接结果。积分后，该项将产生自然对数$\\ln(f)$。$\\alpha(T(f))$的作用是作为这个一阶线性ODE中的可变系数。与$\\alpha$为常数的简单情况不同，这里分馏的程度随着过程的演化而变化，由预设的温度路径$T(f)$决定。\n\n**2. 积分过程**\n\n导出的ODE是可分离的。我们可以重新排列各项，将变量$R$和$f$分组到方程的两边：\n$$ \\frac{dR}{R} = \\frac{\\alpha(T(f)) - 1}{f} df $$\n为了找到在最终分数$f_{\\mathrm{end}}$时的同位素比值$R(f_{\\mathrm{end}})$，我们从初始状态（在$f=1$时，比值为$R_0$）到最终状态（在$f=f_{\\mathrm{end}}$时，比值为$R(f_{\\mathrm{end}})$）对两边进行积分。我们使用积分哑变量$f'$以避免与积分上限混淆。\n$$ \\int_{R_0}^{R(f_{\\mathrm{end}})} \\frac{dR}{R} = \\int_{1}^{f_{\\mathrm{end}}} \\frac{\\alpha(T(f')) - 1}{f'} df' $$\n左侧积分得到：\n$$ \\int_{R_0}^{R(f_{\\mathrm{end}})} \\frac{dR}{R} = \\left[ \\ln R \\right]_{R_0}^{R(f_{\\mathrm{end}})} = \\ln(R(f_{\\mathrm{end}})) - \\ln(R_0) = \\ln\\left(\\frac{R(f_{\\mathrm{end}})}{R_0}\\right) $$\n将其与右侧相等，得到：\n$$ \\ln\\left(\\frac{R(f_{\\mathrm{end}})}{R_0}\\right) = \\int_{1}^{f_{\\mathrm{end}}} \\frac{\\alpha(T(f')) - 1}{f'} df' $$\n对两边取指数，得到$R(f_{\\mathrm{end}})$的解：\n$$ R(f_{\\mathrm{end}}) = R_0 \\exp\\left( \\int_{1}^{f_{\\mathrm{end}}} \\frac{\\alpha(T(f')) - 1}{f'} df' \\right) $$\n此推导中使用的唯一近似是$R \\ll 1$。从$N$到$f$的变量变换在积分内部引入了因子$1/f'$。对于$\\alpha(T(f))$的一般函数形式，该积分没有简单的解析解。因此，必须进行数值计算。该过程包括：\n1.  定义被积函数，$g(f') = (\\alpha(T(f')) - 1) / f'$。\n2.  使用稳健的数值积分方法（例如Python中`scipy.integrate.quad`提供的方法）来计算定积分$I = \\int_{1}^{f_{\\mathrm{end}}} g(f') df'$。\n3.  计算最终同位素比值为$R(f_{\\mathrm{end}}) = R_0 \\exp(I)$。\n\n**3. 数值计算**\n\n程序将实现此积分过程。对于每个测试用例，它将为$\\alpha(T)$和$T(f)$模型定义具体参数。将构造一个被积函数来计算给定$f$时的$(\\alpha(T(f)) - 1)/f$。此函数将被传递给SciPy库中的数值求积例程，以在区间$[1, f_{\\mathrm{end}}]$上计算积分。然后通过将初始比率$R_0$乘以积分值的指数来计算最终比率$R(f_{\\mathrm{end}})$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves for the final isotopic ratio in a Rayleigh distillation model with\n    temperature-dependent fractionation.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"R0\": 0.002, \"f_end\": 0.3, \"model\": \"linear\",\n            \"T_params\": {\"Tmin\": 280.0, \"Tmax\": 300.0},\n            \"alpha_params\": {\"A\": 2.0, \"B\": 0.5, \"C\": -0.0005}\n        },\n        {\n            \"R0\": 0.002, \"f_end\": 0.5, \"model\": \"constant\",\n            \"T_params\": {\"Tconst\": 298.0},\n            \"alpha_params\": {\"A\": 0.0, \"B\": 0.0, \"C\": 0.002}\n        },\n        {\n            \"R0\": 0.0015, \"f_end\": 0.1, \"model\": \"power\",\n            \"T_params\": {\"Tmin\": 270.0, \"Tmax\": 320.0, \"p\": 0.5},\n            \"alpha_params\": {\"A\": 1.0, \"B\": -0.2, \"C\": 0.0002}\n        },\n        {\n            \"R0\": 0.0025, \"f_end\": 0.99, \"model\": \"power\",\n            \"T_params\": {\"Tmin\": 295.0, \"Tmax\": 300.0, \"p\": 2.0},\n            \"alpha_params\": {\"A\": 3.0, \"B\": 0.0, \"C\": 0.0}\n        },\n        {\n            \"R0\": 0.001, \"f_end\": 0.01, \"model\": \"linear\",\n            \"T_params\": {\"Tmin\": 260.0, \"Tmax\": 310.0},\n            \"alpha_params\": {\"A\": 0.5, \"B\": 0.3, \"C\": -0.0003}\n        }\n    ]\n\n    # --- Helper functions for physical models ---\n\n    def alpha_model(T, A, B, C):\n        \"\"\"Calculates the fractionation factor alpha(T).\"\"\"\n        return np.exp(A / T**2 + B / T + C)\n\n    def T_linear(f, Tmin, Tmax):\n        \"\"\"Linear temperature model T(f).\"\"\"\n        return Tmin + (Tmax - Tmin) * f\n\n    def T_constant(f, Tconst):\n        \"\"\"Constant temperature model T(f).\"\"\"\n        # f is unused but kept for consistent function signature.\n        return Tconst\n\n    def T_power(f, Tmin, Tmax, p):\n        \"\"\"Power-law temperature model T(f).\"\"\"\n        return Tmin + (Tmax - Tmin) * f**p\n\n    # Map model names to temperature functions\n    T_models = {\n        \"linear\": T_linear,\n        \"constant\": T_constant,\n        \"power\": T_power\n    }\n\n    def integrand(f_prime, case_params):\n        \"\"\"\n        Calculates the value of the integrand for the Rayleigh equation:\n        (alpha(T(f')) - 1) / f'\n        \n        Args:\n            f_prime (float): The remaining fraction (variable of integration).\n            case_params (dict): A dictionary containing all parameters for the case.\n        \"\"\"\n        # Unpack parameters\n        model_type = case_params[\"model\"]\n        T_params = case_params[\"T_params\"]\n        alpha_params = case_params[\"alpha_params\"]\n\n        # Calculate temperature T(f')\n        T_func = T_models[model_type]\n        # The ** operator unpacks the dictionary into keyword arguments\n        T = T_func(f_prime, **T_params)\n\n        # Calculate fractionation factor alpha(T)\n        alpha = alpha_model(T, **alpha_params)\n\n        # Return the integrand value\n        # A small epsilon is added to f_prime to avoid division by zero if f_prime=0,\n        # though integration limits should prevent this.\n        return (alpha - 1.0) / (f_prime + 1e-15)\n\n    results = []\n    for case in test_cases:\n        # Perform the numerical integration\n        # The integral is from f=1 to f=f_end\n        integral_value, _ = quad(\n            integrand, \n            1.0, \n            case[\"f_end\"], \n            args=(case,)\n        )\n\n        # Calculate the final isotopic ratio R(f_end)\n        R_f_end = case[\"R0\"] * np.exp(integral_value)\n        results.append(R_f_end)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}