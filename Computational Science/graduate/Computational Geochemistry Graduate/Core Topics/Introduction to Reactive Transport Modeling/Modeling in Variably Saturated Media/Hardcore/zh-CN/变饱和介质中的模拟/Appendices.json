{
    "hands_on_practices": [
        {
            "introduction": "在模拟入渗或污染物运移等任何动态过程之前，我们需要定义一个物理上真实的初始状态。本练习将指导您构建一个静水平衡下的含水量剖面，这是许多渗流带模拟的常见起点。通过应用 van Genuchten 模型，您将学习如何将给定的地下水位深度转化为连续的含水量剖面，这是数值模拟的一项基本技能。",
            "id": "4087278",
            "problem": "考虑一个代表包气带的一维垂直土柱，其范围从高程 $z = 0$ 的地表延伸到高程 $z = -5\\,\\mathrm{m}$ 的区域底部。垂直坐标 $z$ 向上为正。地下水位位于高程 $z_{\\mathrm{wt}} = -3\\,\\mathrm{m}$ 处。假设在重力作用下处于静水力平衡，无气体压力梯度，且毛细上升带由一个广泛接受的毛管压力-饱和度关系确定。该土壤为均质、各向同性介质，其特征为具有恒定的孔隙度 $\\phi$ 和可用 van Genuchten (VG) 模型参数描述的持水曲线。体积含水量 $\\theta$ 通过 $\\theta = \\theta_{s} S_{w}$ 与饱和度相关联，其中 $\\theta_{r}$ 为残余含水量，$\\theta_{s} = \\phi$ 为饱和含水量，在非饱和区（地下水位以上）存在一个有效饱和度函数 $S_{e}(h)$，其中 $h$ 表示毛管吸力水头。静水力平衡意味着在地下水位以上，吸力水头 $h$ 等于到地下水位的垂直距离；在地下水位以下，压力水头为非负值。\n\n给定以下适用于中等粗质地土壤的物理上合理的参数：\n- 孔隙度 $\\phi = 0.35$ (无量纲)，饱和含水量 $\\theta_{s} = 0.35$，残余含水量 $\\theta_{r} = 0.05$。\n- van Genuchten 参数 $\\alpha = 2.0\\,\\mathrm{m}^{-1}$ 和 $n = 2.0$，其中 $m = 1 - \\frac{1}{n}$。\n- 水密度 $\\rho_{w} = 1000\\,\\mathrm{kg\\,m}^{-3}$。\n\n任务：\n1. 使用静水力平衡和 van Genuchten 有效饱和度关系，为 $z \\in [-5,0]$ 范围内的初始体积含水量剖面 $\\theta(z)$ 指定一个分段表达式，该表达式需与位于 $z_{\\mathrm{wt}} = -3\\,\\mathrm{m}$ 的地下水位及相关的毛细上升带相一致。\n2. 计算区域内单位水平面积上的初始总水质量，\n$$\nM = \\rho_{w} \\int_{-5}^{0} \\theta(z)\\,\\mathrm{d}z,\n$$\n并以 $\\mathrm{kg\\,m}^{-2}$ 为单位表示最终答案。将您的答案四舍五入到四位有效数字。\n3. 从第一性原理验证计算出的初始质量与区域孔隙度和饱和度相一致，即在给定假设下，它可以等价地写为 $\\rho_{w} \\int \\phi S_{w}(z)\\,\\mathrm{d}z$。\n\n仅提供 $M$ 的最终数值作为您的最终答案，并遵循上述的四舍五入说明和单位规范。",
            "solution": "在尝试求解之前，对问题进行验证。\n\n步骤 1：提取的已知条件\n- 区域：一维垂直土柱，从 $z = 0$（地表）到 $z = -5\\,\\mathrm{m}$。\n- 坐标系：$z$ 向上为正。\n- 地下水位：$z_{\\mathrm{wt}} = -3\\,\\mathrm{m}$。\n- 物理假设：重力作用下的静水力平衡，无气体压力梯度。\n- 土壤性质：均质、各向同性介质。\n- 孔隙度：$\\phi = 0.35$。\n- 饱和含水量：$\\theta_{s} = 0.35$。\n- 残余含水量：$\\theta_{r} = 0.05$。\n- 含水量关系：$\\theta = \\theta_{s} S_{w}$。\n- van Genuchten (VG) 参数：$\\alpha = 2.0\\,\\mathrm{m}^{-1}$，$n = 2.0$，以及 $m = 1 - \\frac{1}{n}$。\n- 静水水头：地下水位以上，吸力水头 $h$ 等于到地下水位的垂直距离。\n- 水密度：$\\rho_{w} = 1000\\,\\mathrm{kg\\,m}^{-3}$。\n- 任务 1：为 $z \\in [-5,0]$ 范围内的初始体积含水量剖面 $\\theta(z)$ 指定一个分段表达式。\n- 任务 2：计算单位水平面积上的初始总水质量，$M = \\rho_{w} \\int_{-5}^{0} \\theta(z)\\,\\mathrm{d}z$，单位为 $\\mathrm{kg\\,m}^{-2}$，并四舍五入到四位有效数字。\n- 任务 3：验证质量计算与关系式 $\\rho_{w} \\int \\phi S_{w}(z)\\,\\mathrm{d}z$ 的一致性。\n\n步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，使用了包气带水文学的标准原理，如静水力平衡和用于土壤持水性的 van Genuchten 模型。所有参数（$\\phi$, $\\theta_r$, $\\theta_s$, $\\alpha$, $n$, $\\rho_w$）均已提供，量纲一致，并且对于天然土壤是物理上合理的。问题陈述客观、无歧义且适定，能够导出一个唯一且有意义的解。初始条件 $\\theta_s = \\phi$ 是对于完全饱和介质的标准假设。所定义的任务逻辑结构清晰，并且利用给定信息是可解的。该问题被认为是有效的。\n\n步骤 3：结论与行动\n问题有效。下面提供详细解法。\n\n解题过程通过解决问题陈述中列出的三个任务来进行。\n\n任务 1：初始体积含水量剖面 $\\theta(z)$\n\n土柱区域 $z \\in [-5, 0]$ 被位于 $z_{\\mathrm{wt}} = -3\\,\\mathrm{m}$ 的地下水位分为两个区域。\n\n1.  饱和区：对于高程在地下水位或以下的位置，$z \\in [-5, -3]$，土壤完全饱和。体积含水量 $\\theta$ 等于饱和含水量 $\\theta_s$，而已知 $\\theta_s$ 等于孔隙度 $\\phi$。\n    $$ \\theta(z) = \\theta_s = 0.35 \\quad \\text{for } z \\in [-5, -3] $$\n\n2.  非饱和区（包气带）：对于高程在地下水位以上的位置，$z \\in (-3, 0]$，体积含水量是毛管吸力水头 $h$ 的函数。在静水力平衡下，高程 $z$ 处的吸力水头 $h$ 是该点在地下水位上方的垂直距离：\n    $$ h(z) = z - z_{\\mathrm{wt}} = z - (-3) = z + 3 \\quad (\\text{for } z  -3) $$\n    van Genuchten 模型通过有效饱和度 $S_e(h)$ 将含水量与吸力水头联系起来：\n    $$ \\theta(h) = \\theta_r + (\\theta_s - \\theta_r) S_e(h) $$\n    其中\n    $$ S_e(h) = \\left[1 + (\\alpha h)^n\\right]^{-m} $$\n    给定参数为：$\\theta_s = 0.35$，$\\theta_r = 0.05$，$\\alpha = 2.0\\,\\mathrm{m}^{-1}$，以及 $n = 2.0$。参数 $m$ 由 $n$ 导出：\n    $$ m = 1 - \\frac{1}{n} = 1 - \\frac{1}{2.0} = 0.5 $$\n    将这些值和 $h(z)$ 的表达式代入 $\\theta$ 的方程：\n    $$ \\theta(z) = 0.05 + (0.35 - 0.05) \\left[1 + (2.0 (z+3))^{2.0}\\right]^{-0.5} $$\n    $$ \\theta(z) = 0.05 + 0.30 \\left[1 + 4(z+3)^2\\right]^{-0.5} \\quad \\text{for } z \\in (-3, 0] $$\n    \n结合这两个部分，区域 $z \\in [-5, 0]$ 内初始含水量剖面 $\\theta(z)$ 的完整分段表达式为：\n$$\n\\theta(z) =\n\\begin{cases}\n0.35  \\text{for } z \\in [-5, -3] \\\\\n0.05 + 0.30 \\left[1 + 4(z+3)^2\\right]^{-\\frac{1}{2}}  \\text{for } z \\in (-3, 0]\n\\end{cases}\n$$\n该函数在 $z = -3$ 处是连续的，因为 $\\lim_{z\\to -3^+} \\theta(z) = 0.05 + 0.30(1)^{-0.5} = 0.35$，这与饱和区的值相匹配。\n\n任务 2：单位面积上的总水质量\n\n单位水平面积上的总水质量 $M$，通过对整个土柱深度的总水量进行积分，再乘以水的密度 $\\rho_w$ 来计算。\n$$ M = \\rho_{w} \\int_{-5}^{0} \\theta(z)\\,\\mathrm{d}z $$\n该积分必须根据 $\\theta(z)$ 的分段定义进行拆分：\n$$ M = \\rho_{w} \\left[ \\int_{-5}^{-3} \\theta(z)\\,\\mathrm{d}z + \\int_{-3}^{0} \\theta(z)\\,\\mathrm{d}z \\right] $$\n第一个积分，针对饱和区，为：\n$$ I_1 = \\int_{-5}^{-3} 0.35\\,\\mathrm{d}z = 0.35 [z]_{-5}^{-3} = 0.35(-3 - (-5)) = 0.35(2) = 0.70\\,\\mathrm{m} $$\n第二个积分，针对非饱和区，为：\n$$ I_2 = \\int_{-3}^{0} \\left( 0.05 + 0.30 \\left[1 + 4(z+3)^2\\right]^{-\\frac{1}{2}} \\right)\\,\\mathrm{d}z $$\n这可以拆分为两项：\n$$ I_2 = \\int_{-3}^{0} 0.05\\,\\mathrm{d}z + 0.30 \\int_{-3}^{0} \\frac{1}{\\sqrt{1 + 4(z+3)^2}}\\,\\mathrm{d}z $$\n第一项是：\n$$ \\int_{-3}^{0} 0.05\\,\\mathrm{d}z = 0.05[z]_{-3}^0 = 0.05(0 - (-3)) = 0.05(3) = 0.15\\,\\mathrm{m} $$\n对于第二项，我们进行换元。令 $u = 2(z+3)$。则 $\\mathrm{d}u = 2\\,\\mathrm{d}z$，所以 $\\mathrm{d}z = \\frac{1}{2}\\mathrm{d}u$。积分上下限从 $z = -3 \\rightarrow u = 2(-3+3)=0$ 变为 $z=0 \\rightarrow u = 2(0+3)=6$。\n$$ 0.30 \\int_{0}^{6} \\frac{1}{\\sqrt{1 + u^2}} \\left(\\frac{1}{2}\\,\\mathrm{d}u\\right) = 0.15 \\int_{0}^{6} \\frac{1}{\\sqrt{1 + u^2}}\\,\\mathrm{d}u $$\n$\\frac{1}{\\sqrt{1+u^2}}$ 的积分是反双曲正弦函数 $\\arcsinh(u)$，也可以写成对数形式 $\\ln(u + \\sqrt{u^2+1})$。\n$$ 0.15 \\left[ \\arcsinh(u) \\right]_{0}^{6} = 0.15 (\\arcsinh(6) - \\arcsinh(0)) = 0.15 \\arcsinh(6) $$\n使用对数形式进行计算：\n$$ 0.15 \\left[ \\ln(u + \\sqrt{u^2+1}) \\right]_{0}^{6} = 0.15 \\left( \\ln(6 + \\sqrt{6^2+1}) - \\ln(0 + \\sqrt{0^2+1}) \\right) $$\n$$ = 0.15 (\\ln(6 + \\sqrt{37}) - \\ln(1)) = 0.15 \\ln(6 + \\sqrt{37}) $$\n所以，$I_2$ 的总值为：\n$$ I_2 = 0.15 + 0.15 \\ln(6 + \\sqrt{37}) \\,\\mathrm{m} $$\n积分后的总水柱高度是 $I_1$ 和 $I_2$ 的和：\n$$ \\int_{-5}^{0} \\theta(z)\\,\\mathrm{d}z = I_1 + I_2 = 0.70 + 0.15 + 0.15 \\ln(6 + \\sqrt{37}) = 0.85 + 0.15 \\ln(6 + \\sqrt{37}) $$\n数值上，$\\sqrt{37} \\approx 6.08276$，所以 $\\ln(6 + \\sqrt{37}) \\approx \\ln(12.08276) \\approx 2.49178$。\n$$ \\int_{-5}^{0} \\theta(z)\\,\\mathrm{d}z \\approx 0.85 + 0.15(2.49178) \\approx 0.85 + 0.373767 = 1.223767\\,\\mathrm{m} $$\n现在，我们使用 $\\rho_{w} = 1000\\,\\mathrm{kg\\,m}^{-3}$ 计算总质量 $M$：\n$$ M = 1000\\,\\mathrm{kg\\,m}^{-3} \\times 1.223767\\,\\mathrm{m} = 1223.767\\,\\mathrm{kg\\,m}^{-2} $$\n四舍五入到四位有效数字，我们得到：\n$$ M \\approx 1224\\,\\mathrm{kg\\,m}^{-2} $$\n\n任务 3：一致性验证\n\n问题要求验证计算出的初始质量与表达式 $M = \\rho_{w} \\int \\phi S_{w}(z)\\,\\mathrm{d}z$ 相一致。\n问题陈述提供了两个关系：$\\theta = \\theta_s S_w$ 和 $\\theta_s = \\phi$。将它们结合起来得到：\n$$ \\theta(z) = \\phi S_w(z) $$\n这个方程在区域内的所有 $z$ 都成立。将其代入质量的积分中：\n$$ M = \\rho_{w} \\int_{-5}^{0} \\theta(z)\\,\\mathrm{d}z = \\rho_{w} \\int_{-5}^{0} \\phi S_{w}(z)\\,\\mathrm{d}z $$\n由于 $\\phi$ 是一个常数，这可以写成：\n$$ M = \\rho_{w} \\phi \\int_{-5}^{0} S_{w}(z)\\,\\mathrm{d}z $$\n这证实了基于 $\\theta(z)$ 的 $M$ 计算在定义上等同于基于 $\\phi S_w(z)$ 的计算。我们对 $\\int \\theta(z)\\,\\mathrm{d}z$ 的计算内在地就计算了 $\\int \\phi S_w(z)\\,\\mathrm{d}z$。因此，一致性由问题陈述本身提供的定义所验证，无需单独计算。任务 2 中的计算就是这个积分的具体实施。\n饱和度 $S_w(z)$ 可以表示为：\n$$\nS_w(z) = \\frac{\\theta(z)}{\\phi} =\n\\begin{cases}\n1  \\text{for } z \\in [-5, -3] \\\\\n\\frac{0.05}{0.35} + \\frac{0.30}{0.35} \\left[1 + 4(z+3)^2\\right]^{-\\frac{1}{2}}  \\text{for } z \\in (-3, 0]\n\\end{cases}\n$$\n在整个区域上对 $\\phi S_w(z)$ 进行积分将得出相同的水量，从而证实了结果。",
            "answer": "$$\n\\boxed{1224}\n$$"
        },
        {
            "introduction": "自然界的土壤很少是均质的。本练习挑战您模拟水分入渗到一个分层土壤柱中的过程，这是一个更为现实的场景。您将使用与 Mualem-van Genuchten 参数相关联的 Green-Ampt 近似法，通过计算来探索入渗通量和湿润锋速度在不同土壤类型界面处如何发生突变，这突显了土壤非均质性在控制水分运动中的关键作用。",
            "id": "4087276",
            "problem": "一个位于包气带中的垂直一维变饱和土柱由两个不同的土层构成，两层之间在深度 $z_\\mathrm{I}$（从土壤表面向下测量，单位为米）处有一个界面。目标是构建一个具有层特定 Mualem–van Genuchten (MvG) 水力参数的分层土壤模型，并使用尖锐湿润锋近似法，量化湿润锋穿过土层界面前后瞬间的入渗通量和湿润锋速度的变化。\n\n计算基础是非饱和多孔介质中耦合的质量守恒和 Darcy–Buckingham 流动。令 $z$ 表示向下的垂直坐标，$t$ 表示时间（秒），$\\theta(z,t)$ 表示体积含水量（无量纲），$h(z,t)$ 表示压力水头（米），$q(z,t)$ 表示达西通量（入渗通量）（米/秒）。控制原理如下：\n- 一维质量守恒：$\\dfrac{\\partial \\theta}{\\partial t} + \\dfrac{\\partial q}{\\partial z} = 0$。\n- Darcy–Buckingham 定律：$q = -K(h)\\left(\\dfrac{\\partial h}{\\partial z} + 1\\right)$，其中 $K(h)$ 是非饱和导水率（米/秒）。\n\n每个土层 $i\\in\\{1,2\\}$ 由 Mualem–van Genuchten 土壤-水分持留曲线和导水率模型表征，其参数为 $(\\theta_{s,i},\\theta_{r,i},\\alpha_i,n_i,K_{s,i},\\ell_i)$，其中 $\\theta_{s,i}$ 是饱和体积含水量，$\\theta_{r,i}$ 是残余体积含水量，$\\alpha_i$ 是进气值反函数参数（1/米），$n_i1$ 是一个形状参数，$m_i=1-1/n_i$，$K_{s,i}$ 是饱和导水率（米/秒），$\\ell_i$ 是孔隙连通性参数（无量纲）。定义有效饱和度 $S_e(\\theta) = \\dfrac{\\theta-\\theta_r}{\\theta_s-\\theta_r}$。当 $h  0$ 时，van Genuchten 压力水头关系为\n$$\nh(\\theta) = -\\dfrac{1}{\\alpha}\\left(S_e(\\theta)^{-\\frac{1}{m}} - 1\\right)^{\\frac{1}{n}},\n$$\nMualem 导水率模型为\n$$\nK(h) = K_s\\,S_e(h)^{\\ell}\\left[1 - \\left(1 - S_e(h)^{\\frac{1}{m}}\\right)^m\\right]^2.\n$$\n\n假设整个土柱初始体积含水量 $\\theta_i$ 均匀，对于两个土层均有 $\\theta_{r,i}  \\theta_i  \\theta_{s,i}$，并且从时间 $t=0$ 开始，地表有强度为 $R$（米/秒）的恒定降雨强迫。采用 Green–Ampt 尖锐锋近似法，其中湿润锋上方的区域瞬时饱和，下方的区域保持初始含水量 $\\theta_i$。在此近似下，对于一个由 $(\\theta_s,\\theta_r,\\alpha,n,K_s)$ 和初始条件 $\\theta_i$ 表征的土层，在湿润锋深度 $z_f$（米）处的入渗能力建模为\n$$\nq_\\mathrm{cap}(z_f) = K_s\\left(1 + \\dfrac{\\Psi_f}{z_f}\\right),\n$$\n其中 $\\Psi_f$ 是有效湿润锋吸力水头（米）。实际入渗通量为 $q(t) = \\min\\{R,\\,q_\\mathrm{cap}(z_f(t))\\}$。湿润锋速度由质量守恒定义为\n$$\nv = \\dfrac{dz_f}{dt} = \\dfrac{q}{\\theta_s - \\theta_i}.\n$$\n为了将 Green–Ampt 吸力参数 $\\Psi_f$ 与 MvG 持留曲线联系起来，将 $\\Psi_f$ 定义为从 $\\theta_i$ 过渡到 $\\theta_s$ 过程中的平均毛管吸力，\n$$\n\\Psi_f = -\\dfrac{1}{\\theta_s - \\theta_i}\\int_{\\theta_i}^{\\theta_s} h(\\theta)\\,d\\theta,\n$$\n由于在非饱和条件下 $h(\\theta)  0$，这将得到一个正值。\n\n在一个界面位于 $z_\\mathrm{I}$ 的分层介质中，令 $z_f(t)$ 表示尖锐湿润锋的深度。在穿过界面前瞬间 ($z_f\\to z_\\mathrm{I}^-$)，入渗能力和湿润锋速度由上层参数决定。穿过界面后瞬间 ($z_f\\to z_\\mathrm{I}^+$)，它们由下层参数决定。任务是使用上述关系和特定于各层的 MvG 参数，计算界面穿越前后瞬间的入渗通量 $q$ 和湿润锋速度 $v$。所有通量和速度必须以米/秒表示，深度以米表示。\n\n实现一个程序，该程序：\n- 对于每个测试用例，通过上述积分定义，根据给定的 MvG 参数计算每个土层的 Green–Ampt 湿润锋吸力 $\\Psi_f$。\n- 使用适当的土层参数和 $q_\\mathrm{cap}(z_\\mathrm{I})$ 计算 $q_\\mathrm{before} = \\min\\{R,\\,K_{s,1}(1 + \\Psi_{f,1}/z_\\mathrm{I})\\}$ 和 $q_\\mathrm{after} = \\min\\{R,\\,K_{s,2}(1 + \\Psi_{f,2}/z_\\mathrm{I})\\}$。\n- 计算 $v_\\mathrm{before} = q_\\mathrm{before}/(\\theta_{s,1}-\\theta_i)$ 和 $v_\\mathrm{after} = q_\\mathrm{after}/(\\theta_{s,2}-\\theta_i)$。\n- 生成单行输出，其中包含一个列表，每个元素对应一个测试用例，本身是一个包含四个浮点数的列表 $[q_\\mathrm{before}, q_\\mathrm{after}, v_\\mathrm{before}, v_\\mathrm{after}]$，所有数值单位均为米/秒。\n\n使用以下测试套件，该套件探讨了一个典型案例、一个边界条件、一个降雨限制的边缘案例以及一个不变性检验：\n- 测试用例 1（典型路径，上层导水性高于下层）：\n  - $z_\\mathrm{I} = 0.30$\n  - 上层 (1)：$\\theta_{s,1} = 0.41$，$\\theta_{r,1} = 0.065$，$\\alpha_1 = 7.5$， $n_1 = 1.89$， $K_{s,1} = 4\\times 10^{-5}$\n  - 下层 (2)：$\\theta_{s,2} = 0.46$，$\\theta_{r,2} = 0.095$，$\\alpha_2 = 1.9$， $n_2 = 1.31$， $K_{s,2} = 1\\times 10^{-6}$\n  - 初始条件：$\\theta_i = 0.10$\n  - 降雨：$R = 1\\times 10^{-4}$\n- 测试用例 2（边界情况，降雨量等于上层饱和导水率）：\n  - $z_\\mathrm{I} = 0.25$\n  - 上层 (1)：$\\theta_{s,1} = 0.43$，$\\theta_{r,1} = 0.070$，$\\alpha_1 = 5.5$， $n_1 = 1.60$， $K_{s,1} = 5\\times 10^{-5}$\n  - 下层 (2)：$\\theta_{s,2} = 0.45$，$\\theta_{r,2} = 0.080$，$\\alpha_2 = 4.0$， $n_2 = 1.50$， $K_{s,2} = 1.2\\times 10^{-5}$\n  - 初始条件：$\\theta_i = 0.20$\n  - 降雨：$R = 5\\times 10^{-5}$\n- 测试用例 3（边缘情况，两层均受降雨限制）：\n  - $z_\\mathrm{I} = 0.40$\n  - 上层 (1)：$\\theta_{s,1} = 0.39$，$\\theta_{r,1} = 0.050$，$\\alpha_1 = 6.0$， $n_1 = 1.70$， $K_{s,1} = 2\\times 10^{-5}$\n  - 下层 (2)：$\\theta_{s,2} = 0.42$，$\\theta_{r,2} = 0.060$，$\\alpha_2 = 3.0$， $n_2 = 1.40$， $K_{s,2} = 8\\times 10^{-6}$\n  - 初始条件：$\\theta_i = 0.12$\n  - 降雨：$R = 1\\times 10^{-6}$\n- 测试用例 4（不变性检验，土层相同）：\n  - $z_\\mathrm{I} = 0.20$\n  - 上层 (1)：$\\theta_{s,1} = 0.41$，$\\theta_{r,1} = 0.065$，$\\alpha_1 = 7.5$， $n_1 = 1.89$， $K_{s,1} = 5\\times 10^{-5}$\n  - 下层 (2)：$\\theta_{s,2} = 0.41$，$\\theta_{r,2} = 0.065$，$\\alpha_2 = 7.5$， $n_2 = 1.89$， $K_{s,2} = 5\\times 10^{-5}$\n  - 初始条件：$\\theta_i = 0.15$\n  - 降雨：$R = 7\\times 10^{-5}$\n\n您的程序应生成单行输出，其中包含一个列表的列表形式的结果，每个内部列表按 $[q_\\mathrm{before}, q_\\mathrm{after}, v_\\mathrm{before}, v_\\mathrm{after}]$ 的顺序排列，单位为米/秒，针对四个测试用例，例如 $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$。",
            "solution": "目标是分析入渗尖锐湿润锋在穿过一维垂直土柱中两个不同土层之间的界面时的行为。此分析在 Green–Ampt 近似法的框架内进行，其关键参数——有效湿润锋吸力水头 $\\Psi_f$——由物理上更详细的 Mualem–van Genuchten (MvG) 土壤水力特性模型推导得出。我们的任务是计算湿润锋到达深度 $z_\\mathrm{I}$ 的界面之前瞬间 ($z_f \\to z_\\mathrm{I}^-$) 和之后瞬间 ($z_f \\to z_\\mathrm{I}^+$) 的入渗通量 $q$ 和湿润锋速度 $v$。\n\n求解方法按顺序对每个土层进行一系列计算，最终在界面处评估通量和速度。\n\n首先，我们必须确定每个土层的有效湿润锋吸力水头 $\\Psi_f$。该参数代表了湿润锋上的积分毛管驱动力。问题将其定义为含水量从初始状态 $\\theta_i$ 变化到饱和状态 $\\theta_s$ 期间的平均基质势水头：\n$$\n\\Psi_f = -\\dfrac{1}{\\theta_s - \\theta_i}\\int_{\\theta_i}^{\\theta_s} h(\\theta)\\,d\\theta\n$$\n非饱和条件下（$h  0$）的压力水头 $h(\\theta)$ 由 van Genuchten 持留曲线给出：\n$$\nh(\\theta) = -\\dfrac{1}{\\alpha}\\left(S_e(\\theta)^{-\\frac{1}{m}} - 1\\right)^{\\frac{1}{n}}\n$$\n其中 $S_e(\\theta) = \\frac{\\theta-\\theta_r}{\\theta_s-\\theta_r}$ 是有效饱和度，且 $m=1-1/n$。由于 $h(\\theta)$ 是负值，$\\Psi_f$ 是一个正值。\n\n为了计算 $\\Psi_f$ 的积分，我们进行变量替换，从体积含水量 $\\theta$ 替换为有效饱和度 $S_e$。根据 $S_e$ 的定义，我们有 $\\theta = \\theta_r + S_e(\\theta_s - \\theta_r)$，这意味着微分关系为 $d\\theta = (\\theta_s - \\theta_r)dS_e$。积分限也随之改变：当 $\\theta = \\theta_i$ 时，下限变为 $S_{e,i} = \\frac{\\theta_i - \\theta_r}{\\theta_s - \\theta_r}$；当 $\\theta=\\theta_s$ 时，上限变为 $S_e=1$。将这些代入 $\\Psi_f$ 的积分中，得到：\n$$\n\\Psi_f = -\\dfrac{1}{\\theta_s - \\theta_i} \\int_{S_{e,i}}^{1} \\left[-\\dfrac{1}{\\alpha}\\left(S_e^{-\\frac{1}{m}} - 1\\right)^{\\frac{1}{n}}\\right] (\\theta_s - \\theta_r)dS_e\n$$\n简化此表达式可得到适合数值积分的形式：\n$$\n\\Psi_f = \\dfrac{\\theta_s - \\theta_r}{\\alpha(\\theta_s - \\theta_i)} \\int_{S_{e,i}}^{1} \\left(S_e^{-\\frac{1}{m}} - 1\\right)^{\\frac{1}{n}} dS_e\n$$\n该积分没有通用的解析解，必须使用每个土层特定的 MvG 参数 $(\\theta_{s,i}, \\theta_{r,i}, \\alpha_i, n_i)$ 和初始条件 $\\theta_i$ 进行数值计算。\n\n一旦计算出上层的 $\\Psi_{f,1}$ 和下层的 $\\Psi_{f,2}$，我们就可以确定入渗通量和湿润锋速度。问题指出，在湿润锋到达深度为 $z_\\mathrm{I}$ 的界面之前，该过程由土层 1 的性质决定。入渗能力为：\n$$\nq_{\\mathrm{cap},1}(z_\\mathrm{I}) = K_{s,1}\\left(1 + \\dfrac{\\Psi_{f,1}}{z_\\mathrm{I}}\\right)\n$$\n实际入渗通量受降雨率 $R$ 的限制：\n$$\nq_\\mathrm{before} = \\min\\{R, q_{\\mathrm{cap},1}(z_\\mathrm{I})\\}\n$$\n在湿润锋穿过界面后，该过程由土层 2 的性质决定，此时湿润锋仍有效位于深度 $z_\\mathrm{I}$：\n$$\nq_{\\mathrm{cap},2}(z_\\mathrm{I}) = K_{s,2}\\left(1 + \\dfrac{\\Psi_{f,2}}{z_\\mathrm{I}}\\right)\n$$\n相应的通量为：\n$$\nq_\\mathrm{after} = \\min\\{R, q_{\\mathrm{cap},2}(z_\\mathrm{I})\\}\n$$\n湿润锋速度 $v = dz_f/dt$ 源自锋面上的质量守恒，即通量 $q$ 必须等于湿润剖面中储水量的变化率。对于尖锐锋，这给出：\n$$\nv = \\dfrac{q}{\\theta_s - \\theta_i}\n$$\n将此应用于界面前后的条件，并使用相应土层的饱和含水量，我们得到：\n$$\nv_\\mathrm{before} = \\dfrac{q_\\mathrm{before}}{\\theta_{s,1} - \\theta_i}\n$$\n$$\nv_\\mathrm{after} = \\dfrac{q_\\mathrm{after}}{\\theta_{s,2} - \\theta_i}\n$$\n这套完整的方程组定义了需要为每个测试用例实现的算法。计算的核心是 $\\Psi_f$ 积分的数值计算，随后直接应用代数公式计算通量和速度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes infiltration flux and wetting front speed across a soil layer interface.\n\n    This program implements a layered soil model using Mualem-van Genuchten (MvG)\n    hydraulic parameters and a Green-Ampt sharp-front approximation. It calculates\n    the change in infiltration flux (q) and wetting front speed (v) as the\n    wetting front crosses the interface between an upper layer (1) and a lower\n    layer (2).\n\n    The main steps for each test case are:\n    1. Compute the effective wetting-front suction head (Psi_f) for each layer by\n       numerically integrating the MvG water retention curve.\n    2. Calculate the infiltration capacity (q_cap) at the interface depth z_I\n       using the parameters for the layer the front is in.\n    3. Determine the actual infiltration flux (q) by comparing q_cap with the\n       surface rainfall rate R. This is done for conditions immediately before\n       and after the front crosses z_I.\n    4. Calculate the wetting front speed (v) based on mass conservation, using\n       the determined flux and the water content difference for each layer.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (happy path, upper layer more conductive than lower)\n        {\n            \"z_I\": 0.30,\n            \"layer1\": {\"theta_s\": 0.41, \"theta_r\": 0.065, \"alpha\": 7.5, \"n\": 1.89, \"K_s\": 4e-5},\n            \"layer2\": {\"theta_s\": 0.46, \"theta_r\": 0.095, \"alpha\": 1.9, \"n\": 1.31, \"K_s\": 1e-6},\n            \"initial\": {\"theta_i\": 0.10},\n            \"rainfall\": {\"R\": 1e-4},\n        },\n        # Test case 2 (boundary, rainfall equals upper-layer saturation conductivity)\n        {\n            \"z_I\": 0.25,\n            \"layer1\": {\"theta_s\": 0.43, \"theta_r\": 0.070, \"alpha\": 5.5, \"n\": 1.60, \"K_s\": 5e-5},\n            \"layer2\": {\"theta_s\": 0.45, \"theta_r\": 0.080, \"alpha\": 4.0, \"n\": 1.50, \"K_s\": 1.2e-5},\n            \"initial\": {\"theta_i\": 0.20},\n            \"rainfall\": {\"R\": 5e-5},\n        },\n        # Test case 3 (edge, rainfall-limited in both layers)\n        {\n            \"z_I\": 0.40,\n            \"layer1\": {\"theta_s\": 0.39, \"theta_r\": 0.050, \"alpha\": 6.0, \"n\": 1.70, \"K_s\": 2e-5},\n            \"layer2\": {\"theta_s\": 0.42, \"theta_r\": 0.060, \"alpha\": 3.0, \"n\": 1.40, \"K_s\": 8e-6},\n            \"initial\": {\"theta_i\": 0.12},\n            \"rainfall\": {\"R\": 1e-6},\n        },\n        # Test case 4 (invariance, identical layers)\n        {\n            \"z_I\": 0.20,\n            \"layer1\": {\"theta_s\": 0.41, \"theta_r\": 0.065, \"alpha\": 7.5, \"n\": 1.89, \"K_s\": 5e-5},\n            \"layer2\": {\"theta_s\": 0.41, \"theta_r\": 0.065, \"alpha\": 7.5, \"n\": 1.89, \"K_s\": 5e-5},\n            \"initial\": {\"theta_i\": 0.15},\n            \"rainfall\": {\"R\": 7e-5},\n        },\n    ]\n\n    def h_integrand(Se, m, n):\n        \"\"\"\n        The integrand part of the Psi_f calculation, derived from the van Genuchten model.\n        h(Se) = -1/alpha * (Se**(-1/m) - 1)**(1/n)\n        The integral for Psi_f includes this term.\n        \"\"\"\n        # The term Se**(-1/m) can be very large near Se=0, but the lower limit\n        # Se_i is always  0.\n        term = Se**(-1.0/m) - 1.0\n        # If term becomes negative due to precision issues near Se=1, handle it.\n        if term  0:\n            return 0.0\n        return term**(1.0/n)\n\n    def compute_psi_f(layer_params, theta_i):\n        \"\"\"\n        Computes the effective wetting-front suction head Psi_f for a given layer.\n        \"\"\"\n        theta_s = layer_params[\"theta_s\"]\n        theta_r = layer_params[\"theta_r\"]\n        alpha = layer_params[\"alpha\"]\n        n = layer_params[\"n\"]\n        \n        # Ensure denominators are not zero to avoid division errors.\n        if theta_s = theta_r or theta_s = theta_i:\n            return 0.0 # Or raise an error for invalid input\n\n        m = 1.0 - 1.0/n\n        Se_i = (theta_i - theta_r) / (theta_s - theta_r)\n        \n        # The lower limit must be  0.\n        if Se_i = 0: Se_i = 1e-9 # A small apx for numerical stability\n\n        integral_val, _ = quad(h_integrand, Se_i, 1.0, args=(m, n))\n        \n        prefactor = (theta_s - theta_r) / (alpha * (theta_s - theta_i))\n        \n        return prefactor * integral_val\n\n    results = []\n    for case in test_cases:\n        z_I = case[\"z_I\"]\n        R = case[\"rainfall\"][\"R\"]\n        theta_i = case[\"initial\"][\"theta_i\"]\n        \n        # Layer 1 parameters\n        p1 = case[\"layer1\"]\n        theta_s1, K_s1 = p1[\"theta_s\"], p1[\"K_s\"]\n        \n        # Layer 2 parameters\n        p2 = case[\"layer2\"]\n        theta_s2, K_s2 = p2[\"theta_s\"], p2[\"K_s\"]\n        \n        # --- Calculations ---\n        \n        # Compute Psi_f for each layer\n        psi_f1 = compute_psi_f(p1, theta_i)\n        psi_f2 = compute_psi_f(p2, theta_i)\n        \n        # Calculate infiltration capacity at the interface (z_f = z_I)\n        q_cap1 = K_s1 * (1.0 + psi_f1 / z_I)\n        q_cap2 = K_s2 * (1.0 + psi_f2 / z_I)\n        \n        # Determine actual flux before and after\n        q_before = min(R, q_cap1)\n        q_after = min(R, q_cap2)\n        \n        # Calculate front speed before and after\n        delta_theta1 = theta_s1 - theta_i\n        v_before = q_before / delta_theta1 if delta_theta1 > 0 else 0\n        \n        delta_theta2 = theta_s2 - theta_i\n        v_after = q_after / delta_theta2 if delta_theta2 > 0 else 0\n        \n        results.append([q_before, q_after, v_before, v_after])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们模型中的参数，例如 van Genuchten 方程中的参数，通常是不确定的，必须通过实验数据来估算。这个高级练习将向您介绍一种强大的模型校准方法：贝叶斯推断。您将实现一个最大后验（MAP）估计，以在给定一组含噪声测量数据的情况下，找出最可能的土壤水力参数，这是现代计算地球化学和水文学中的一项核心任务。",
            "id": "4087271",
            "problem": "您的任务是根据体积含水量对压力水头的含噪测量数据，为非饱和介质（包气带）中的水力参数构建贝叶斯后验分布。正向模型是 Van Genuchten 持水曲线，该模型广泛用于包气带建模。您的程序必须实现后验分布的构建，并使用最大后验（MAP）估计器，通过高斯似然和反映专家知识的高斯先验，提取后验均值的数值近似。\n\n基本原理：\n- 贝叶斯定理：后验密度 $p(\\boldsymbol{\\theta} \\mid \\boldsymbol{y})$ 正比于似然 $p(\\boldsymbol{y} \\mid \\boldsymbol{\\theta})$ 和先验 $p(\\boldsymbol{\\theta})$ 的乘积。\n- 独立测量误差的高斯似然：如果每次测量 $y_i$ 都建模为 $y_i = f_i(\\boldsymbol{\\theta}) + \\varepsilon_i$，其中 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$ 且在 $i$ 上独立，则 $p(\\boldsymbol{y} \\mid \\boldsymbol{\\theta})$ 是高斯分布。\n- 多元高斯先验 $p(\\boldsymbol{\\theta})$，其均值为 $\\boldsymbol{\\mu}$，协方差为 $\\boldsymbol{\\Sigma}$，用于编码专家知识。\n\n正向模型：\n- 对于压力水头 $h$（以吸力表示，单位为米，取正值）和参数 $\\boldsymbol{\\theta} = (\\theta_r,\\theta_s,\\alpha,n)$，体积含水量函数由下式给出\n$$\n\\theta(h;\\boldsymbol{\\theta}) = \\theta_r + (\\theta_s - \\theta_r)\\left[1 + (\\alpha h)^n\\right]^{-m}, \\quad m = 1 - \\frac{1}{n}.\n$$\n此处，$\\theta_r$ 和 $\\theta_s$ 是无量纲的残余含水量和饱和含水量（$\\theta$ 是无量纲的），$\\alpha$ 的单位是 $\\mathrm{m}^{-1}$，$n$ 是无量纲的。\n\n为获得最大后验（MAP）估计所需最小化的后验目标函数：\n- 负对数后验（不计加法常数）为\n$$\n\\Phi(\\boldsymbol{\\theta}) = \\frac{1}{2\\sigma^2}\\sum_{i=1}^{N}\\left[y_i - \\theta(h_i;\\boldsymbol{\\theta})\\right]^2 + \\frac{1}{2}(\\boldsymbol{\\theta}-\\boldsymbol{\\mu})^\\top \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{\\theta}-\\boldsymbol{\\mu}).\n$$\n最小化 $\\Phi(\\boldsymbol{\\theta})$ 可得出 MAP 估计。围绕 MAP 的拉普拉斯近似使用高斯-牛顿海森近似来提供后验的局部高斯近似：\n$$\n\\boldsymbol{\\Sigma}_{\\text{post}} \\approx \\left(\\boldsymbol{\\Sigma}^{-1} + \\mathbf{J}_f^\\top \\mathbf{W} \\mathbf{J}_f \\right)^{-1},\n$$\n其中 $\\mathbf{J}_f$ 是在 MAP 处评估的正向模型残差的雅可比矩阵，$\\mathbf{W} = \\sigma^{-2}\\mathbf{I}$。\n\n实现要求：\n- 通过连接数据残差和先验残差，使用非线性最小二乘公式：\n$$\n\\mathbf{r}_{\\text{data}}(\\boldsymbol{\\theta}) = \\frac{1}{\\sigma}\\left[\\theta(h_i;\\boldsymbol{\\theta}) - y_i\\right]_{i=1}^N,\\quad\n\\mathbf{r}_{\\text{prior}}(\\boldsymbol{\\theta}) = \\mathbf{L}(\\boldsymbol{\\theta}-\\boldsymbol{\\mu}),\n$$\n其中 $\\mathbf{L}$ 满足 $\\mathbf{L}^\\top \\mathbf{L} = \\boldsymbol{\\Sigma}^{-1}$（例如，可通过对 $\\boldsymbol{\\Sigma}^{-1}$ 进行 Cholesky 分解获得）。最小化 $\\frac{1}{2}\\|\\mathbf{r}_{\\text{data}}\\|_2^2 + \\frac{1}{2}\\|\\mathbf{r}_{\\text{prior}}\\|_2^2$ 等价于最小化 $\\Phi(\\boldsymbol{\\theta})$。\n- 应用物理上合理的边界：$\\theta_r \\in [0,0.2]$，$\\theta_s \\in [0.2,0.6]$，$\\alpha \\in [0.01,10]$ $\\mathrm{m}^{-1}$，$n \\in [1.1,3.0]$。\n\n数据生成：\n- 使用固定的真实参数矢量 $\\boldsymbol{\\theta}_{\\text{true}} = (\\theta_r,\\theta_s,\\alpha,n) = (0.05,0.45,0.8,1.6)$。\n- 使用 $N = 8$ 个压力水头（吸力），单位为米：$(0.01,0.03,0.10,0.30,0.60,1.00,2.00,3.00)$。\n- 对每个测试用例，通过 $y_i = \\theta(h_i;\\boldsymbol{\\theta}_{\\text{true}}) + \\varepsilon_i$ 生成合成测量数据，其中 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$，并使用确定性伪随机种子以确保可复现性。\n\n测试套件：\n- 情况 A（理想路径）：测量误差标准差 $\\sigma = 0.01$，先验均值 $\\boldsymbol{\\mu}_A = (0.04,0.40,1.00,1.50)$，先验协方差为对角矩阵，对角线元素为 $(0.01^2,0.05^2,0.50^2,0.30^2)$，确定性种子为 $2025$。\n- 情况 B（数据主导边缘）：$\\sigma = 0.002$，先验均值 $\\boldsymbol{\\mu}_B = (0.10,0.55,0.10,2.50)$，先验协方差为对角矩阵，对角线元素为 $(0.05^2,0.10^2,1.00^2,0.60^2)$，确定性种子为 $2026$。\n- 情况 C（先验主导边缘）：$\\sigma = 0.03$，先验均值 $\\boldsymbol{\\mu}_C = (0.05,0.45,0.90,1.70)$，先验协方差为对角矩阵，对角线元素为 $(0.01^2,0.02^2,0.05^2,0.05^2)$，确定性种子为 $2027$。\n\n单位要求和输出：\n- 参数 $\\theta_r$ 和 $\\theta_s$ 是无量纲的体积含水量，必须作为无量纲数字报告。\n- 参数 $\\alpha$ 必须以 $\\mathrm{m}^{-1}$ 为单位报告。\n- 参数 $n$ 是无量纲的。\n- 您的程序应生成单行输出，其中包含所有测试用例的 MAP 参数估计值，聚合在一个用方括号括起来的逗号分隔列表中。顺序必须是 $[\\theta_{r,A},\\theta_{s,A},\\alpha_A,n_A,\\theta_{r,B},\\theta_{s,B},\\alpha_B,n_B,\\theta_{r,C},\\theta_{s,C},\\alpha_C,n_C]$。所有输出必须是浮点数。\n\n您的实现必须是一个完整的、可运行的程序，对每个测试用例执行以下步骤：\n- 使用上述定义构建包含数据和先验贡献的残差向量。\n- 从先验均值初始化，求解约束非线性最小二乘问题以获得 MAP。\n- 构建高斯-牛顿海森近似并对其求逆，以得出局部后验协方差（输出中不要求，但必须在内部计算）。\n- 将 MAP 参数矢量附加到最终输出列表中。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result1,result2,result3]$）。",
            "solution": "根据指定的验证标准对用户提供的问题进行严格评估。\n\n### 步骤 1：提取已知条件\n\n- **正向模型 (Van Genuchten)**：体积含水量 $\\theta$ 作为压力水头 $h$（吸力，单位m）的函数由下式给出：\n$$ \\theta(h;\\boldsymbol{\\theta}) = \\theta_r + (\\theta_s - \\theta_r)\\left[1 + (\\alpha h)^n\\right]^{-m}, \\quad m = 1 - \\frac{1}{n} $$\n其中参数矢量为 $\\boldsymbol{\\theta} = (\\theta_r, \\theta_s, \\alpha, n)$。$\\theta_r$ 是残余含水量（无量纲），$\\theta_s$ 是饱和含水量（无量纲），$\\alpha$ 是一个曲线形态参数（$\\mathrm{m}^{-1}$），$n$ 是一个曲线形态参数（无量纲）。\n\n- **贝叶斯框架**：\n  - **后验**：$p(\\boldsymbol{\\theta} \\mid \\boldsymbol{y}) \\propto p(\\boldsymbol{y} \\mid \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta})$。\n  - **似然**：高斯分布，基于独立测量误差 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$，其中 $y_i = \\theta(h_i;\\boldsymbol{\\theta}) + \\varepsilon_i$。\n  - **先验**：多元高斯分布，$p(\\boldsymbol{\\theta}) \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$。\n\n- **MAP 估计的目标函数**：最小化负对数后验 $\\Phi(\\boldsymbol{\\theta})$：\n$$ \\Phi(\\boldsymbol{\\theta}) = \\frac{1}{2\\sigma^2}\\sum_{i=1}^{N}\\left[y_i - \\theta(h_i;\\boldsymbol{\\theta})\\right]^2 + \\frac{1}{2}(\\boldsymbol{\\theta}-\\boldsymbol{\\mu})^\\top \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{\\theta}-\\boldsymbol{\\mu}) $$\n\n- **非线性最小二乘 (NLS) 公式**：最小化 $0.5 \\sum_j r_j^2$，其中残差向量 $\\mathbf{r}$ 是数据残差和先验残差的串联：\n  - $\\mathbf{r}_{\\text{data}}(\\boldsymbol{\\theta}) = \\frac{1}{\\sigma}\\left[\\theta(h_i;\\boldsymbol{\\theta}) - y_i\\right]_{i=1}^N$\n  - $\\mathbf{r}_{\\text{prior}}(\\boldsymbol{\\theta}) = \\mathbf{L}(\\boldsymbol{\\theta}-\\boldsymbol{\\mu})$，其中 $\\mathbf{L}^\\top \\mathbf{L} = \\boldsymbol{\\Sigma}^{-1}$。\n  - 优化应在先验均值 $\\boldsymbol{\\mu}$ 处初始化。\n\n- **后验协方差近似**：$\\boldsymbol{\\Sigma}_{\\text{post}} \\approx \\left(\\boldsymbol{\\Sigma}^{-1} + \\mathbf{J}_f^\\top \\mathbf{W} \\mathbf{J}_f \\right)^{-1}$，其中 $\\mathbf{J}_f$ 是正向模型的雅可比矩阵，$\\mathbf{W} = \\sigma^{-2}\\mathbf{I}$。这必须在内部计算。\n\n- **参数边界**：\n  - $\\theta_r \\in [0, 0.2]$\n  - $\\theta_s \\in [0.2, 0.6]$\n  - $\\alpha \\in [0.01, 10]$ $\\mathrm{m}^{-1}$\n  - $n \\in [1.1, 3.0]$\n\n- **数据生成设置**：\n  - 真实参数：$\\boldsymbol{\\theta}_{\\text{true}} = (0.05, 0.45, 0.8, 1.6)$。\n  - 压力水头 ($h$)：$(0.01, 0.03, 0.10, 0.30, 0.60, 1.00, 2.00, 3.00)$ m。\n  - 合成数据：$y_i = \\theta(h_i;\\boldsymbol{\\theta}_{\\text{true}}) + \\varepsilon_i$，其中 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$，使用指定的种子以确保可复现性。\n\n- **测试用例**：\n  - **情况 A**：$\\sigma = 0.01$，$\\boldsymbol{\\mu}_A = (0.04, 0.40, 1.00, 1.50)$，diag($\\boldsymbol{\\Sigma}_A$) = $(0.01^2, 0.05^2, 0.50^2, 0.30^2)$，种子 = $2025$。\n  - **情况 B**：$\\sigma = 0.002$，$\\boldsymbol{\\mu}_B = (0.10, 0.55, 0.10, 2.50)$，diag($\\boldsymbol{\\Sigma}_B$) = $(0.05^2, 0.10^2, 1.00^2, 0.60^2)$，种子 = $2026$。\n  - **情况 C**：$\\sigma = 0.03$，$\\boldsymbol{\\mu}_C = (0.05, 0.45, 0.90, 1.70)$，diag($\\boldsymbol{\\Sigma}_C$) = $(0.01^2, 0.02^2, 0.05^2, 0.05^2)$，种子 = $2027$。\n\n- **输出格式**：包含所有情况的 MAP 估计值的单个列表：$[\\theta_{r,A},\\theta_{s,A},\\alpha_A,n_A,\\theta_{r,B},\\theta_{s,B},\\alpha_B,n_B,\\theta_{r,C},\\theta_{s,C},\\alpha_C,n_C]$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n对问题的有效性进行评估：\n- **科学依据**：是。该问题植根于水文地质学和计算统计学，使用标准模型 (Van Genuchten) 和方法（贝叶斯推断、MAP 估计）。上下文是包气带建模，这是相关的。\n- **适定性**：是。该问题描述了一个明确定义的数值优化任务：找到指定目标函数的最小值。包含先验（正则化）和参数边界有助于约束问题，从而促进稳定且唯一的数值解的存在。\n- **客观性**：是。该问题以数学精度陈述，提供了所有必要的函数、数据和约束。没有主观或含糊的语言。\n- **缺陷清单**：\n  1.  **科学/事实不准确**：无。所涉及的物理和数学是标准的。\n  2.  **无法形式化/不相关**：无。该问题可直接形式化，并与指定领域相关。\n  3.  **设置不完整/矛盾**：无。所有必需的信息（模型、参数、数据、约束、种子、初始猜测）都已提供并且内部一致。\n  4.  **不切实际/不可行**：无。参数值、边界和物理情景对于土壤物理学研究是合理的。\n  5.  **病态/结构不良**：无。该问题是一个标准的、结构良好的反演问题（参数估计）。\n  6.  **伪深刻/琐碎**：无。这是一个需要数值求解器的非平凡优化问题。\n  7.  **无法通过科学方法验证**：无。该过程是确定性的（给定种子），并且可以独立验证。\n\n### 步骤 3：结论与行动\n\n问题是**有效的**。将开发一个解决方案。\n\n### 基于原则的设计\n\n该解决方案将通过求解一个约束非线性最小二乘问题来找到 Van Genuchten 参数 $(\\theta_r, \\theta_s, \\alpha, n)$ 的最大后验（MAP）估计。此方法等同于最小化后验概率密度函数的负对数。\n\n1.  **正向模型**：Van Genuchten 函数 $\\theta(h; \\boldsymbol{\\theta})$ 作为可调用的 Python 函数实现。该函数将参数矢量 $\\boldsymbol{\\theta}$ 和压力水头矢量 $\\mathbf{h}$ 映射到模型预测的体积含水量矢量。\n\n2.  **合成数据生成**：对于每个测试用例，生成合成测量数据 $\\mathbf{y}$。这包括在给定的真实参数 $\\boldsymbol{\\theta}_{\\text{true}}$ 下评估正向模型，并添加具有指定标准差 $\\sigma$ 和固定伪随机种子的高斯噪声以实现可复现性。\n\n3.  **目标函数构建**：负对数后验 $\\Phi(\\boldsymbol{\\theta})$ 由两项组成：数据失配项（来自似然）和先验失配项（来自先验）。为了使用非线性最小二乘求解器（其最小化残差向量的平方和），我们构建一个复合残差向量 $\\mathbf{r}(\\boldsymbol{\\theta})$，其平方范数与 $\\Phi(\\boldsymbol{\\theta})$ 成正比。\n    - **数据残差 ($\\mathbf{r}_{\\text{data}}$)**：定义为 $\\frac{1}{\\sigma}(\\theta(\\mathbf{h}; \\boldsymbol{\\theta}) - \\mathbf{y})$。对这些项进行平方和求和，可以重建 $\\Phi(\\boldsymbol{\\theta})$ 的数据失配项（按 $2$ 缩放）。\n    - **先验残差 ($\\mathbf{r}_{\\text{prior}}$)**：先验项是 $(\\boldsymbol{\\theta}-\\boldsymbol{\\mu})^\\top \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{\\theta}-\\boldsymbol{\\mu})$。我们使用逆协方差矩阵的 Cholesky 分解 $\\boldsymbol{\\Sigma}^{-1} = \\mathbf{L}^\\top \\mathbf{L}$ 来定义先验残差为 $\\mathbf{r}_{\\text{prior}} = \\mathbf{L}(\\boldsymbol{\\theta}-\\boldsymbol{\\mu})$。由于给定的先验协方差 $\\boldsymbol{\\Sigma}$ 是对角矩阵，其元素为 $\\sigma_{p,j}^2$，其逆矩阵 $\\boldsymbol{\\Sigma}^{-1}$ 也是对角矩阵，元素为 $1/\\sigma_{p,j}^2$。矩阵 $\\mathbf{L}$ 可以选择为对角矩阵，其元素为 $1/\\sigma_{p,j}$。这将计算简化为逐元素操作。\n    - **总残差**：传递给求解器的最终残差向量是数据残差和先验残差的串联：$\\mathbf{r} = [\\mathbf{r}_{\\text{data}}, \\mathbf{r}_{\\text{prior}}]$。\n\n4.  **数值优化**：使用 `scipy.optimize.least_squares` 函数及 'trust-region reflective' (`trf`) 方法。该求解器适用于约束非线性最小二乘问题。优化使用先验均值 $\\boldsymbol{\\mu}$ 作为 $\\boldsymbol{\\theta}$ 的初始猜测值进行初始化，并严格执行物理上合理的边界。求解器迭代调整 $\\boldsymbol{\\theta}$ 以最小化 $\\frac{1}{2}\\|\\mathbf{r}(\\boldsymbol{\\theta})\\|_2^2$，从而得出 MAP 参数估计。\n\n5.  **后验协方差计算（内部）**：按照要求，使用高斯-牛顿法近似后验协方差。复合残差向量 $\\mathbf{r}$ 关于参数 $\\boldsymbol{\\theta}$ 的雅可比矩阵 $\\mathbf{J}$ 从 `least_squares` 的输出中获得。目标函数的海森矩阵的高斯-牛顿近似为 $\\mathbf{H}_{\\text{GN}} \\approx \\mathbf{J}^\\top\\mathbf{J}$。后验协方差矩阵即为该海森矩阵的逆：$\\boldsymbol{\\Sigma}_{\\text{post}} \\approx (\\mathbf{J}^\\top\\mathbf{J})^{-1}$。此计算是为了完整性而执行，但结果不包含在最终输出中。\n\n6.  **工作流自动化**：从数据生成到优化的整个过程被封装在一个循环中，该循环遍历三个指定的测试用例。生成的 MAP 参数矢量被收集并聚合成一个单一的扁平列表，以便进行最终的输出格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef van_genuchten(h, params):\n    \"\"\"\n    Computes the Van Genuchten water retention curve.\n\n    Args:\n        h (np.ndarray): Array of pressure heads (suction, positive in meters).\n        params (tuple or np.ndarray): Parameter vector (theta_r, theta_s, alpha, n).\n\n    Returns:\n        np.ndarray: Array of volumetric water contents.\n    \"\"\"\n    theta_r, theta_s, alpha, n = params\n    \n    # The physical constraint m = 1 - 1/n requires n  1.\n    # The optimizer bounds should enforce this, but as a safeguard:\n    if n = 1.0:\n        return np.full_like(h, np.nan)\n        \n    m = 1.0 - 1.0 / n\n    \n    # This calculation is robust for the given bounds.\n    vg_term = 1.0 + (alpha * h)**n\n    theta_model = theta_r + (theta_s - theta_r) * (vg_term**(-m))\n    \n    return theta_model\n\ndef solve():\n    \"\"\"\n    Main function to run the Bayesian MAP estimation for all test cases.\n    \"\"\"\n    # Define ground truth and experimental conditions\n    theta_true = np.array([0.05, 0.45, 0.8, 1.6])\n    h_values = np.array([0.01, 0.03, 0.10, 0.30, 0.60, 1.00, 2.00, 3.00])\n    param_bounds = ([0.0, 0.2, 0.01, 1.1], [0.2, 0.6, 10.0, 3.0])\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (sigma, prior_mean, prior_covariance_diagonal, random_seed)\n    test_cases = [\n        # Case A: Happy path\n        (0.01, np.array([0.04, 0.40, 1.00, 1.50]), np.array([0.01**2, 0.05**2, 0.50**2, 0.30**2]), 2025),\n        # Case B: Data-dominated\n        (0.002, np.array([0.10, 0.55, 0.10, 2.50]), np.array([0.05**2, 0.10**2, 1.00**2, 0.60**2]), 2026),\n        # Case C: Prior-dominated\n        (0.03, np.array([0.05, 0.45, 0.90, 1.70]), np.array([0.01**2, 0.02**2, 0.05**2, 0.05**2]), 2027),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        sigma, mu_prior, sigma_prior_diag, seed = case\n        \n        # 1. Generate synthetic measurement data\n        rng = np.random.default_rng(seed)\n        true_model_output = van_genuchten(h_values, theta_true)\n        noise = rng.normal(0, sigma, size=h_values.shape[0])\n        y_data = true_model_output + noise\n\n        # 2. Define the residual function for the least-squares solver\n        def residuals(theta):\n            # Calculate data residuals\n            model_output = van_genuchten(h_values, theta)\n            \n            # This handles the case where n = 1, which should be prevented by bounds.\n            if np.any(np.isnan(model_output)):\n                return np.full(h_values.shape[0] + theta.shape[0], 1e12)\n                \n            r_data = (model_output - y_data) / sigma\n            \n            # Calculate prior residuals\n            # For a diagonal covariance matrix, L is also diagonal with L_ii = 1/sqrt(Sigma_ii)\n            r_prior = (theta - mu_prior) / np.sqrt(sigma_prior_diag)\n            \n            return np.concatenate((r_data, r_prior))\n\n        # 3. Solve for the MAP estimate using constrained nonlinear least squares\n        initial_guess = mu_prior\n        \n        ls_result = least_squares(\n            residuals,\n            initial_guess,\n            bounds=param_bounds,\n            method='trf', # Trust Region Reflective is suitable for bounds\n            jac='2-point' # Use finite differences for the Jacobian\n        )\n        \n        map_estimate = ls_result.x\n        \n        # 4. (Internal Requirement) Compute the posterior covariance matrix\n        # The Jacobian of the combined residual vector is returned by the solver.\n        J = ls_result.jac\n        # The Gauss-Newton Hessian approximation is H_GN = J^T * J.\n        H_gn = J.T @ J\n        try:\n            # The posterior covariance is the inverse of the Hessian.\n            # This step is required by the prompt but the result is not used in the final output.\n            _ = np.linalg.inv(H_gn)\n        except np.linalg.LinAlgError:\n            # This may happen if the Hessian is singular, though unlikely with a prior.\n            pass\n        \n        all_results.extend(map_estimate.tolist())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}