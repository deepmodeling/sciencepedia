{
    "hands_on_practices": [
        {
            "introduction": "在对晶体等周期性体系进行密度泛函理论计算时，许多物理量（如总能量、应力）需要在倒空间的布里渊区内进行积分。在实际计算中，该积分被离散化的 $k$ 点网格求和所替代，因此 $k$ 点的密度是一个至关重要的收敛性参数。本练习旨在通过一个简化的赤铁矿能量模型，让学生亲手实践如何通过改变 $k$ 点密度来研究材料弹性常数的收敛性，从而深刻理解布里渊区采样对于精确预测宏观物理性质的重要性。",
            "id": "4076814",
            "problem": "你需要编写一个完整且可运行的程序，来模拟通过$k$点网格进行的布里渊区采样如何影响在密度泛函理论（DFT）中计算得到的弹性常数的收敛性，该理论应用于赤铁矿（氧化铁(III)，Fe$_2$O$_3$）。计算必须遵循基本定义，即应力是总能量对应变的导数，而弹性常数是应力对应变的导数。该建模必须是纯数学和自洽的，使用一个在倒易空间（$k$空间）上定义的、综合但科学上合理的各向异性能量密度，并且不得依赖任何外部DFT软件或数据。\n\n请使用以下基本原理：\n\n- 周期性固体中的 Kohn–Sham 密度泛函理论（DFT）总能量是$k$空间能量密度在布里渊区上的积分，该积分可通过均匀网格上的$k$点求和来近似。\n- 在微小单轴应变 $\\epsilon_{ii}$ 下，沿主方向 $i$ 的柯西应力 $\\sigma_{ii}$ 为 $\\sigma_{ii} = \\frac{1}{V_{cell}} \\frac{\\partial E_{tot}}{\\partial \\epsilon_{ii}}$，其中 $E_{tot}$ 是总能量，$V_{cell}$ 是晶胞体积。\n- 沿方向 $i$ 的弹性常数 $C_{ii}$ 是 $C_{ii} = \\frac{\\partial \\sigma_{ii}}{\\partial \\epsilon_{ii}}$ 在 $\\epsilon_{ii} \\to 0$ 时的取值，即总能量对应变的二阶导数除以 $V_{cell}$。\n\n定义一个综合的、单位为电子伏特（electronvolts）的、每个$k$点的各向异性$k$空间能量密度，以模拟赤铁矿的各向异性，形式如下\n$$\nE(\\mathbf{k}; \\epsilon_d) = E_0(\\mathbf{k}) + \\epsilon_d\\, G_d(\\mathbf{k}) + \\frac{1}{2}\\,\\epsilon_d^2\\, H_d(\\mathbf{k}),\n$$\n其中方向 $d \\in \\{a,c\\}$ 对应沿晶体学 $a$ 轴（面内）或 $c$ 轴（面外）施加的应变。使用以下具体形式：\n$$\nE_0(\\mathbf{k}) = c_1\\left[\\cos(k_x) + \\cos(k_y) + \\cos(k_z)\\right] + c_2\\left[\\cos(k_x)\\cos(k_y) + \\alpha\\,\\cos^2(k_z)\\right],\n$$\n$$\nG_a(\\mathbf{k}) = g_{x0}\\left[\\cos^2(k_x) + 0.5\\,\\cos^2(k_y) + 0.2\\,\\cos^2(k_z)\\right], \\quad\nH_a(\\mathbf{k}) = h_{x0}\\left[\\cos^2(k_x) + \\gamma_x\\,\\cos^2(k_y) + \\delta_x\\,\\cos^2(k_z)\\right],\n$$\n$$\nG_c(\\mathbf{k}) = g_{z0}\\left[0.3\\,\\cos^2(k_x) + 0.3\\,\\cos^2(k_y) + 1.0\\,\\cos^2(k_z)\\right], \\quad\nH_c(\\mathbf{k}) = h_{z0}\\left[\\gamma_z\\,\\cos^2(k_x) + \\gamma_z\\,\\cos^2(k_y) + 1.0\\,\\cos^2(k_z)\\right].\n$$\n使用以下常数\n$$\nc_1 = 2.0,\\; c_2 = -1.0,\\; \\alpha = 0.7,\\; g_{x0} = 5.0,\\; g_{z0} = 4.0,\\; h_{x0} = 500.0,\\; h_{z0} = 400.0,\\; \\gamma_x = 0.8,\\; \\delta_x = 0.5,\\; \\gamma_z = 0.6.\n$$\n选择这些常数是为了在综合模型中产生实际量级的弹性常数和方向各向异性。\n\n通过一个包含 $N_k \\times N_k \\times N_k$ 个点的均匀 Monkhorst–Pack 网格来近似布里渊区积分，点的坐标为\n$$\nk_i(m) = 2\\pi\\left(\\frac{m+1/2}{N_k} - \\frac{1}{2}\\right), \\quad m=0,1,\\ldots,N_k-1, \\quad i\\in\\{x,y,z\\}.\n$$\n将总能量 $E_{tot}(\\epsilon_d)$ 计算为所有$k$点上 $E(\\mathbf{k}; \\epsilon_d)$ 的简单平均值。设晶胞体积为 $V_{cell} = 300\\,\\mathrm{\\AA}^3$，并使用以下公式从 $\\mathrm{eV}/\\mathrm{\\AA}^3$ 转换为吉帕（gigapascals）\n$$\nc_{\\mathrm{GPa}} = 160.21766208\\,\\mathrm{GPa}\\; \\text{per}\\; \\mathrm{eV}/\\mathrm{\\AA}^3.\n$$\n\n你的程序必须：\n\n- 对于每个测试用例，使用中心差分法计算以 $\\mathrm{GPa}$ 为单位的应力 $\\sigma_d(\\epsilon)$\n$$\n\\sigma_d(\\epsilon) \\approx \\frac{E_{tot}(+\\epsilon) - E_{tot}(-\\epsilon)}{2\\,\\epsilon\\,V_{cell}}\\; c_{\\mathrm{GPa}}.\n$$\n- 使用二阶中心差分法计算以 $\\mathrm{GPa}$ 为单位的弹性常数 $C_d$\n$$\nC_d \\approx \\frac{E_{tot}(+\\epsilon) - 2\\,E_{tot}(0) + E_{tot}(-\\epsilon)}{\\epsilon^2\\,V_{cell}}\\; c_{\\mathrm{GPa}}.\n$$\n- 计算小应变下的应力变化 $\\Delta \\sigma_d(\\epsilon) = \\sigma_d(\\epsilon) - \\sigma_d(0)$，其中 $\\sigma_d(0)$ 将使用一个更小的对称步长 $\\delta = \\epsilon/10$ 的中心差分法来近似：\n$$\n\\sigma_d(0) \\approx \\frac{E_{tot}(+\\delta) - E_{tot}(-\\delta)}{2\\,\\delta\\,V_{cell}}\\; c_{\\mathrm{GPa}}.\n$$\n\n角度单位必须是弧度。所有应力和弹性常数必须以 $\\mathrm{GPa}$ 表示。\n\n测试套件：\n为以下参数集 $(N_k, \\epsilon, d)$ 计算结果：\n- $(N_k=\\;8,\\, \\epsilon=\\;10^{-3},\\, d=\\;a)$,\n- $(N_k=\\;2,\\, \\epsilon=\\;10^{-3},\\, d=\\;a)$,\n- $(N_k=\\;16,\\, \\epsilon=\\;10^{-3},\\, d=\\;a)$,\n- $(N_k=\\;8,\\, \\epsilon=\\;10^{-3},\\, d=\\;c)$,\n- $(N_k=\\;8,\\, \\epsilon=\\;10^{-5},\\, d=\\;c)$,\n- $(N_k=\\;16,\\, \\epsilon=\\;10^{-3},\\, d=\\;c)$.\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。每个测试用例的结果必须是 $[C_d, \\Delta \\sigma_d(\\epsilon)]$ 形式的二元列表（单位为 GPa），且顺序与上述测试套件中的顺序相同。例如，输出格式必须为\n$$\n\\big[ [C_1, \\Delta \\sigma_1], [C_2, \\Delta \\sigma_2], \\ldots \\big].\n$$",
            "solution": "用户要求编写一个程序，用于模拟密度泛函理论（DFT）中弹性常数的收敛性与$k$点采样网格密度的关系。该模型基于倒易空间中一个综合的、依赖于应变的各向异性能量密度函数。\n\n### 第一步：问题验证\n\n首先，我将根据指定标准验证问题陈述。\n\n#### 已知条件提取\n已知条件如下：\n1.  **框架**：针对周期性固体的 Kohn-Sham DFT。总能量 $E_{tot}$ 是一个布里渊区积分，通过在均匀$k$点网格上求和来近似。\n2.  **物理定义**：\n    -   柯西应力: $\\sigma_{ii} = \\frac{1}{V_{cell}} \\frac{\\partial E_{tot}}{\\partial \\epsilon_{ii}}$\n    -   弹性常数: $C_{ii} = \\frac{\\partial \\sigma_{ii}}{\\partial \\epsilon_{ii}}$ 在 $\\epsilon_{ii} \\to 0$ 时。\n3.  **综合能量密度模型**：$E(\\mathbf{k}; \\epsilon_d) = E_0(\\mathbf{k}) + \\epsilon_d\\, G_d(\\mathbf{k}) + \\frac{1}{2}\\,\\epsilon_d^2\\, H_d(\\mathbf{k})$，应变方向为 $d \\in \\{a,c\\}$。\n4.  **能量分量函数**：\n    -   $E_0(\\mathbf{k}) = c_1\\left[\\cos(k_x) + \\cos(k_y) + \\cos(k_z)\\right] + c_2\\left[\\cos(k_x)\\cos(k_y) + \\alpha\\,\\cos^2(k_z)\\right]$\n    -   $G_a(\\mathbf{k}) = g_{x0}\\left[\\cos^2(k_x) + 0.5\\,\\cos^2(k_y) + 0.2\\,\\cos^2(k_z)\\right]$\n    -   $H_a(\\mathbf{k}) = h_{x0}\\left[\\cos^2(k_x) + \\gamma_x\\,\\cos^2(k_y) + \\delta_x\\,\\cos^2(k_z)\\right]$\n    -   $G_c(\\mathbf{k}) = g_{z0}\\left[0.3\\,\\cos^2(k_x) + 0.3\\,\\cos^2(k_y) + 1.0\\,\\cos^2(k_z)\\right]$\n    -   $H_c(\\mathbf{k}) = h_{z0}\\left[\\gamma_z\\,\\cos^2(k_x) + \\gamma_z\\,\\cos^2(k_y) + 1.0\\,\\cos^2(k_z)\\right]$\n5.  **模型常数**：$c_1 = 2.0$, $c_2 = -1.0$, $\\alpha = 0.7$, $g_{x0} = 5.0$, $g_{z0} = 4.0$, $h_{x0} = 500.0$, $h_{z0} = 400.0$, $\\gamma_x = 0.8$, $\\delta_x = 0.5$, $\\gamma_z = 0.6$。\n6.  **物理常数**：$V_{cell} = 300\\,\\mathrm{\\AA}^3$, $c_{\\mathrm{GPa}} = 160.21766208\\,\\mathrm{GPa} / (\\mathrm{eV}/\\mathrm{\\AA}^3)$。\n7.  **数值方案**：\n    -   $k$点网格：$N_k \\times N_k \\times N_k$ 的 Monkhorst-Pack 网格，坐标为 $k_i(m) = 2\\pi\\left(\\frac{m+1/2}{N_k} - \\frac{1}{2}\\right)$，$m=0, \\dots, N_k-1$。\n    -   总能量：$E_{tot}(\\epsilon_d)$ 是网格点上 $E(\\mathbf{k}; \\epsilon_d)$ 的算术平均值。\n    -   应力计算: $\\sigma_d(\\epsilon) \\approx \\frac{E_{tot}(+\\epsilon) - E_{tot}(-\\epsilon)}{2\\,\\epsilon\\,V_{cell}}\\, c_{\\mathrm{GPa}}$。\n    -   弹性常数计算: $C_d \\approx \\frac{E_{tot}(+\\epsilon) - 2\\,E_{tot}(0) + E_{tot}(-\\epsilon)}{\\epsilon^2\\,V_{cell}}\\, c_{\\mathrm{GPa}}$。\n    -   应力变化计算: $\\Delta \\sigma_d(\\epsilon) = \\sigma_d(\\epsilon) - \\sigma_d(0)$，其中 $\\sigma_d(0)$ 使用相同的中心差分公式但步长为 $\\delta = \\epsilon/10$ 来计算。\n8.  **测试套件**：$(N_k, \\epsilon, d)$ 集合为 $(8, 10^{-3}, a)$, $(2, 10^{-3}, a)$, $(16, 10^{-3}, a)$, $(8, 10^{-3}, c)$, $(8, 10^{-5}, c)$, $(16, 10^{-3}, c)$。\n9.  **输出格式**：一个二元列表的列表：`[[C1, dS1], [C2, dS2], ...]`。\n\n#### 验证分析\n-   **科学依据**：该问题使用了一个综合模型，但已明确说明。其基本原理——布里渊区积分、$k$点采样，以及将应力和弹性常数定义为能量导数——是固态物理和计算材料科学的基础。使用简化模型来分离和研究特定的数值效应（$k$点收敛性）是一种标准且有效的教学和研究技术。该问题在科学上是合理的。\n-   **适定性**：问题被完全指定。所有必需的数学函数、常数、数值方法和测试参数均已提供。不存在任何可能阻碍为每个测试用例计算出唯一解的歧义。\n-   **客观性**：问题以精确的数学语言表述，不含主观或基于观点的断言。\n-   **潜在的平凡性**：有必要对所提出的计算进行严格审视。总能量是应变 $\\epsilon_d$ 的二次函数的平均值，因此其本身也是一个二次函数：$E_{tot}(\\epsilon_d) = \\bar{E}_0 + \\epsilon_d \\bar{G}_d + \\frac{1}{2} \\epsilon_d^2 \\bar{H}_d$，其中带上划线的量是相应能量分量的$k$点平均值。\n    -   弹性常数 $C_d$ 的公式是用于二阶导数的标准二阶中心差分。应用于二次函数时，该公式是精确的，并得出 $C_d = \\frac{\\bar{H}_d}{V_{cell}}$。结果依赖于$k$点网格（通过 $\\bar{H}_d$），但与有限差分步长 $\\epsilon$ 无关。\n    -   应力 $\\sigma_d(\\epsilon)$ 的公式，定义为 $\\frac{E_{tot}(+\\epsilon) - E_{tot}(-\\epsilon)}{2\\,\\epsilon\\,V_{cell}}$，是在*零*应变下评估*一阶*导数的二阶中心差分。对于二次函数 $E_{tot}(\\epsilon_d)$，这也是精确的，并得出 $\\frac{\\bar{G}_d}{V_{cell}}$。\n    -   用于 $\\sigma_d(0)$ 的公式使用了不同的步长 $\\delta$，但由于该公式对于二次函数是精确的，它会得出相同的结果：$\\frac{\\bar{G}_d}{V_{cell}}$。\n    -   因此，所要求的量 $\\Delta \\sigma_d(\\epsilon) = \\sigma_d(\\epsilon) - \\sigma_d(0)$ 将（在浮点精度范围内）恒等于零。虽然这可能使问题看起来微不足道，但这是指定模型和数值方法的直接结果。它作为一个教学示例，说明了有限差分法在多项式函数上的性质。问题的非平凡部分仍然是 $C_d$ 的计算及其随 $N_k$ 的收敛性。该问题并非不适定或根本上是平凡的；相反，它包含一个经过仔细分析后才会显现的特征。\n\n#### 结论\n该问题是有效的。这是一个定义明确的计算任务，基于合理的物理原理，尽管它采用了综合模型。所有必要信息都已提供。\n\n### 第二步：解决方案设计\n\n该解决方案将使用 Python 实现，并利用 `numpy` 库进行高效的基于数组的计算。\n\n1.  **常量定义**：所有物理和模型常量将在脚本开头定义，以确保清晰。\n2.  **K点网格生成**：一个辅助函数将为给定的 $N_k$ 生成 Monkhorst-Pack $k$点网格。它将生成三个三维数组 $k_x, k_y, k_z$，代表网格中每个点的坐标。这可以通过使用 `numpy.linspace` 和 `numpy.meshgrid` 来高效实现。\n3.  **总能量计算**：一个核心函数 `calculate_total_energy(Nk, strain, direction)` 将为一组给定的参数计算总能量。\n    -   它将首先生成$k$点网格。\n    -   然后，它将计算 $\\cos(k_i)$ 和 $\\cos^2(k_i)$ 的数组。\n    -   利用这些，它将为指定的方向 $d$ 计算能量分量数组 $E_0(\\mathbf{k})$、 $G_d(\\mathbf{k})$ 和 $H_d(\\mathbf{k})$。这些计算在整个网格上都是向量化的。\n    -   每个$k$点的总能量 $E(\\mathbf{k}; \\epsilon_d)$ 根据其定义进行组装。\n    -   最后，函数返回 $E(\\mathbf{k}; \\epsilon_d)$ 数组的平均值，即 $E_{tot}$。\n4.  **主计算循环**：程序将遍历测试套件中的每个元组。对于每个情况 $(N_k, \\epsilon, d)$：\n    -   它通过调用 `calculate_total_energy` 计算所需的能量：$E_{tot}(+\\epsilon)$、$E_{tot}(-\\epsilon)$ 和 $E_{tot}(0)$。\n    -   它使用提供的二阶差分公式计算弹性常数 $C_d$。\n    -   它使用步长 $\\epsilon$ 的中心差分公式计算应力项 $\\sigma_d(\\epsilon)$。\n    -   它通过以应变 $\\pm\\delta = \\pm\\epsilon/10$ 调用 `calculate_total_energy` 并应用步长为 $\\delta$ 的中心差分公式来计算应力项 $\\sigma_d(0)$。\n    -   它计算应力变化 $\\Delta \\sigma_d(\\epsilon) = \\sigma_d(\\epsilon) - \\sigma_d(0)$。\n    -   存储配对 $[C_d, \\Delta \\sigma_d(\\epsilon)]$。\n5.  **输出**：处理完所有测试用例后，结果列表将被格式化为指定的字符串 `[[C1, dS1], [C2, dS2], ...]` 并打印到标准输出。\n\n此设计以结构化和计算高效的方式直接实现了问题陈述中指定的流程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of modeling elastic constant convergence in DFT.\n    \"\"\"\n\n    # --- Define model and physical constants ---\n    constants = {\n        'c1': 2.0,\n        'c2': -1.0,\n        'alpha': 0.7,\n        'g_x0': 5.0,\n        'g_z0': 4.0,\n        'h_x0': 500.0,\n        'h_z0': 400.0,\n        'gamma_x': 0.8,\n        'delta_x': 0.5,\n        'gamma_z': 0.6,\n        'V_cell': 300.0,  # in Angstrom^3\n        'c_GPa': 160.21766208  # GPa per eV/Angstrom^3\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (8, 1e-3, 'a'),\n        (2, 1e-3, 'a'),\n        (16, 1e-3, 'a'),\n        (8, 1e-3, 'c'),\n        (8, 1e-5, 'c'),\n        (16, 1e-3, 'c'),\n    ]\n\n    def calculate_total_energy(Nk, strain, direction, consts):\n        \"\"\"\n        Calculates the total energy for a given k-point grid, strain, and direction.\n\n        Args:\n            Nk (int): The dimension of the NkxNkxNk k-point grid.\n            strain (float): The magnitude of the applied strain, epsilon_d.\n            direction (str): The strain direction, either 'a' or 'c'.\n            consts (dict): A dictionary of model and physical constants.\n\n        Returns:\n            float: The total energy, E_tot, averaged over the k-point grid.\n        \"\"\"\n        # Generate the 1D k-point coordinates for one dimension\n        m = np.arange(Nk)\n        k_coords = 2 * np.pi * ((m + 0.5) / Nk - 0.5)\n\n        # Create the 3D grid of k-points\n        kx, ky, kz = np.meshgrid(k_coords, k_coords, k_coords, indexing='ij')\n\n        # Calculate cosine terms for vectorization\n        cos_kx = np.cos(kx)\n        cos_ky = np.cos(ky)\n        cos_kz = np.cos(kz)\n        \n        cos2_kx = cos_kx**2\n        cos2_ky = cos_ky**2\n        cos2_kz = cos_kz**2\n\n        # Calculate the E0(k) component\n        E0_k = consts['c1'] * (cos_kx + cos_ky + cos_kz) + \\\n               consts['c2'] * (cos_kx * cos_ky + consts['alpha'] * cos2_kz)\n\n        # Select and calculate Gd(k) and Hd(k) components based on direction\n        if direction == 'a':\n            Gd_k = consts['g_x0'] * (cos2_kx + 0.5 * cos2_ky + 0.2 * cos2_kz)\n            Hd_k = consts['h_x0'] * (cos2_kx + consts['gamma_x'] * cos2_ky + consts['delta_x'] * cos2_kz)\n        elif direction == 'c':\n            Gd_k = consts['g_z0'] * (0.3 * cos2_kx + 0.3 * cos2_ky + 1.0 * cos2_kz)\n            Hd_k = consts['h_z0'] * (consts['gamma_z'] * cos2_kx + consts['gamma_z'] * cos2_ky + 1.0 * cos2_kz)\n        else:\n            raise ValueError(\"Direction must be 'a' or 'c'\")\n\n        # Calculate the strain-dependent energy for each k-point\n        E_k = E0_k + strain * Gd_k + 0.5 * strain**2 * Hd_k\n\n        # The total energy is the average over all k-points\n        E_tot = np.mean(E_k)\n        \n        return E_tot\n\n    results = []\n    for case in test_cases:\n        Nk, epsilon, direction = case\n        \n        # Calculate energies needed for finite differences\n        E_plus_eps = calculate_total_energy(Nk, epsilon, direction, constants)\n        E_minus_eps = calculate_total_energy(Nk, -epsilon, direction, constants)\n        E_0 = calculate_total_energy(Nk, 0.0, direction, constants)\n\n        # Calculate the elastic constant C_d in GPa\n        C_d = (E_plus_eps - 2 * E_0 + E_minus_eps) / (epsilon**2 * constants['V_cell']) * constants['c_GPa']\n\n        # Calculate stress change delta_sigma_d\n        # 1. Compute sigma_d(epsilon) using step size `epsilon`\n        sigma_eps = (E_plus_eps - E_minus_eps) / (2 * epsilon * constants['V_cell']) * constants['c_GPa']\n        \n        # 2. Compute sigma_d(0) using a smaller step size `delta`\n        delta = epsilon / 10.0\n        E_plus_delta = calculate_total_energy(Nk, delta, direction, constants)\n        E_minus_delta = calculate_total_energy(Nk, -delta, direction, constants)\n        sigma_0 = (E_plus_delta - E_minus_delta) / (2 * delta * constants['V_cell']) * constants['c_GPa']\n\n        # 3. Compute the difference\n        delta_sigma_d = sigma_eps - sigma_0\n        \n        results.append(f\"[{C_d},{delta_sigma_d}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "密度泛函理论计算的核心产物之一是体系的基态电子密度 $\\rho(\\mathbf{r})$，它蕴含了关于化学键和电子结构的所有信息。一个关键的后处理步骤是从连续的电子密度中提取化学信息，例如分配给每个原子的电荷。本练习将介绍 Bader 的“分子中的原子”(AIM)理论，并通过在一个简化的方解石模型上实现一种基于网格的电荷划分算法，让学生掌握如何定量分析矿物中化学键的离子性和共价性。",
            "id": "4076822",
            "problem": "考虑在晶体环境中的电子密度，该密度通过密度泛函理论（DFT; density functional theory）进行建模。在 Born–Oppenheimer 近似下，电子基态由 Kohn–Sham (KS) 轨道描述，而物理上可观测的电子密度为 $$\\rho(\\mathbf{r}) = \\sum_{i}^{\\text{occ}} |\\psi_i(\\mathbf{r})|^2,$$ 其中 $\\psi_i(\\mathbf{r})$ 是已占据的 KS 轨道。Bader 的分子中原子（AIM; Bader AIM）理论将原子盆定义为空间中的区域，其边界为 $\\rho(\\mathbf{r})$ 梯度场中的零通量面，即满足 $$\\nabla \\rho(\\mathbf{r}) \\cdot \\mathbf{n}(\\mathbf{r}) = 0,$$ 的曲面，其中 $\\mathbf{n}(\\mathbf{r})$ 是局部表面法向量。在一个盆 $\\Omega_i$ 内对 $\\rho(\\mathbf{r})$ 进行积分，可以得到分配给原子 $i$ 的电子数，记为 $$N_i = \\int_{\\Omega_i} \\rho(\\mathbf{r}) \\, d^3\\mathbf{r}.$$ 原子 $i$ 的 Bader 电荷为 $$Q_i = Z_i - N_i,$$ 其中 $Z_i$ 是原子 $i$ 的原子序数。\n\n在地球化学中，通过将计算出的电荷划分与形式氧化态进行比较，可以合理解释矿物中键合的离子性与共价性。在方解石（碳酸钙，$\\mathrm{CaCO_3}$）中，形式氧化态为 $\\mathrm{Ca}^{2+}$、$\\mathrm{C}^{4+}$ 和 $\\mathrm{O}^{2-}$。\n\n对于本问题，通过以原子核为中心的球对称高斯函数的叠加，来近似一个方解石化学式单位的 DFT 推导电子密度。设原子位置（单位为 $\\mathrm{\\AA}$）如下：\n- $\\mathbf{R}_{\\mathrm{Ca}} = (0.0, 0.0, 0.0)$,\n- $\\mathbf{R}_{\\mathrm{C}} = (2.36, 0.0, 0.0)$,\n- $\\mathbf{R}_{\\mathrm{O}_1} = (3.64, 0.0, 0.0)$,\n- $\\mathbf{R}_{\\mathrm{O}_2} = (1.72, 1.108, 0.0)$,\n- $\\mathbf{R}_{\\mathrm{O}_3} = (1.72, -1.108, 0.0)$,\n\n其中 $\\mathrm{C-O}$ 键长约为 $1.28\\,\\mathrm{\\AA}$，$\\mathrm{O-C-O}$ 键角为 $120$ 度（角度单位：度）。将电子密度建模为\n$$\\rho(\\mathbf{r}) = \\sum_{i \\in \\{\\mathrm{Ca}, \\mathrm{C}, \\mathrm{O}_1, \\mathrm{O}_2, \\mathrm{O}_3\\}} \\frac{E_i}{(2\\pi \\sigma_i^2)^{3/2}} \\exp\\left(-\\frac{\\|\\mathbf{r} - \\mathbf{R}_i\\|^2}{2 \\sigma_i^2}\\right),$$\n其中 $E_i$（单位：电子）是与原子 $i$ 相关联的高斯函数所携带的总电子数，$\\sigma_i$（单位：$\\mathrm{\\AA}$）是宽度参数。\n\n使用三维空间中的 $26$-邻域连通性，通过在 $\\rho(\\mathbf{r})$ 上执行最速上升，将每个格点分配给其所到达的原子盆，以此对 Bader AIM 划分进行离散近似。对于体积为 $h^3$ 的体素，通过对所有分配给原子 $i$ 的格点上的 $\\rho(\\mathbf{r}) h^3$ 值求和来近似计算 $N_i$ 的积分。各原子序数分别为 $Z_{\\mathrm{Ca}} = 20$，$Z_{\\mathrm{C}} = 6$ 和 $Z_{\\mathrm{O}} = 8$。\n\n设计一个程序，该程序：\n1. 构建一个三维笛卡尔网格，该网格在每个坐标方向上以 $1.0 \\ \\mathrm{\\AA}$ 的边距包围所有原子，并使用均匀的网格间距 $h$（单位：$\\mathrm{\\AA}$）。\n2. 使用参数 $(E_i, \\sigma_i)$ 在每个格点上计算 $\\rho(\\mathbf{r})$ 的值。\n3. 对每个格点执行离散最速上升分配，将其分配给与上升终点位置最近的原子核位置相关联的盆。\n4. 为每个原子计算 $N_i$，然后计算 $Q_i = Z_i - N_i$，最后计算所得到的 Bader 电荷集与形式氧化态电荷集 $\\{+2, +4, -2, -2, -2\\}$ 之间的均方根偏差（RMSD）：\n$$\\mathrm{RMSD} = \\sqrt{\\frac{1}{5} \\sum_{i=1}^{5} \\left(Q_i - q_i^{\\mathrm{formal}}\\right)^2}.$$\n\n物理和数值单位：\n- 距离和网格间距必须以 $\\mathrm{\\AA}$ 为单位。\n- 电子数 $E_i$ 和积分得到的 $N_i$ 必须以电子为单位。\n- Bader 电荷 $Q_i$ 和 RMSD 必须以电子为单位。\n\n测试套件：\n- 情况 A（中等共价性）：$h = 0.12$, $\\sigma_{\\mathrm{Ca}} = 0.60$, $\\sigma_{\\mathrm{C}} = 0.35$, $\\sigma_{\\mathrm{O}} = 0.45$, $E_{\\mathrm{Ca}} = 19.0$, $E_{\\mathrm{C}} = 4.6$, $E_{\\mathrm{O}_1} = 8.8$, $E_{\\mathrm{O}_2} = 8.8$, $E_{\\mathrm{O}_3} = 8.8$。\n- 情况 B（强离子性分配）：$h = 0.10$, $\\sigma_{\\mathrm{Ca}} = 0.60$, $\\sigma_{\\mathrm{C}} = 0.35$, $\\sigma_{\\mathrm{O}} = 0.45$, $E_{\\mathrm{Ca}} = 18.0$, $E_{\\mathrm{C}} = 2.0$, $E_{\\mathrm{O}_1} = 10.0$, $E_{\\mathrm{O}_2} = 10.0$, $E_{\\mathrm{O}_3} = 10.0$。\n- 情况 C（近共价性与粗分辨率）：$h = 0.25$, $\\sigma_{\\mathrm{Ca}} = 0.60$, $\\sigma_{\\mathrm{C}} = 0.35$, $\\sigma_{\\mathrm{O}} = 0.45$, $E_{\\mathrm{Ca}} = 20.0$, $E_{\\mathrm{C}} = 6.0$, $E_{\\mathrm{O}_1} = 8.0$, $E_{\\mathrm{O}_2} = 8.0$, $E_{\\mathrm{O}_3} = 8.0$。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result_A,result_B,result_C]”），列表中的每个条目是对应情况 A、B、C 的 RMSD（一个以电子为单位的浮点数），并严格按照 A、B、C 的顺序排列。",
            "solution": "该问题要求针对方解石（$\\mathrm{CaCO_3}$）化学式单位的简化电子密度模型，实现一个基于网格的 Bader 分子中原子（AIM）分析。最终目标是针对三种不同的参数集，计算所得到的 Bader 电荷与形式氧化态电荷之间的均方根偏差（RMSD）。\n\n对于每个测试用例，该解决方案系统地执行以下步骤：\n1.  **系统离散化**：构建一个三维笛卡尔网格以包围整个分子体系。\n2.  **密度计算**：在每个格点上计算模型电子密度（即高斯函数的叠加）。\n3.  **Bader 盆划分**：使用最速上升算法将每个格点分配到一个原子盆中。\n4.  **电荷计算**：通过在每个原子盆上对密度进行积分，求得该原子的总电子数，并由此推导出 Bader 电荷。\n5.  **RMSD 计算**：确定计算出的 Bader 电荷与参考形式电荷之间的 RMSD。\n\n### 1. 模型和网格构建\n该问题将 $\\mathrm{CaCO_3}$ 单位的电子密度 $\\rho(\\mathbf{r})$ 定义为五个球对称高斯函数的和，每个函数以原子 $i \\in \\{\\mathrm{Ca}, \\mathrm{C}, \\mathrm{O}_1, \\mathrm{O}_2, \\mathrm{O}_3\\}$ 的位置 $\\mathbf{R}_i$ 为中心：\n$$\n\\rho(\\mathbf{r}) = \\sum_{i} \\rho_i(\\mathbf{r}) = \\sum_{i} \\frac{E_i}{(2\\pi \\sigma_i^2)^{3/2}} \\exp\\left(-\\frac{\\|\\mathbf{r} - \\mathbf{R}_i\\|^2}{2 \\sigma_i^2}\\right)\n$$\n此处，$E_i$ 是与原子 $i$ 的高斯函数相关联的电子数，$\\sigma_i$ 是其宽度。项 $(2\\pi \\sigma_i^2)^{-3/2}$ 是三维高斯函数的归一化因子，确保 $\\int \\rho_i(\\mathbf{r}) \\, d^3\\mathbf{r} = E_i$。\n\n连续函数 $\\rho(\\mathbf{r})$ 被离散化到一个均匀的三维笛卡尔网格上。首先，确定原子位置的最小和最大坐标。然后，通过将此边界框在每个方向上扩展 $1.0 \\, \\mathrm{\\AA}$ 的边距来定义网格域。这确保了指数衰减的电子密度在网格边界处可忽略不计。\n格点由坐标向量 $\\mathbf{x}$、$\\mathbf{y}$ 和 $\\mathbf{z}$ 定义，这些向量以每个测试用例指定的均匀间距 $h$ 创建。由此生成三维坐标数组 $X、Y、Z$，代表每个格点的位置 $\\mathbf{r}$。\n\n### 2. 电子密度计算\n网格建立后，在每个点 $(X, Y, Z)$ 上计算 $\\rho(\\mathbf{r})$ 的值。这通过矢量化操作高效完成。对于每个原子 $i$，其贡献 $\\rho_i(\\mathbf{r})$ 在整个网格上进行计算。每个格点到原子中心 $\\mathbf{R}_i$ 的距离平方 $\\|\\mathbf{r} - \\mathbf{R}_i\\|^2$ 计算为 $(X - R_{ix})^2 + (Y - R_{iy})^2 + (Z - R_{iz})^2$。总密度 `rho_grid` 是所有五个原子贡献的总和。\n\n### 3. Bader 盆划分\n分析的核心是将空间划分为原子盆。根据 AIM 理论，盆是由密度梯度的零通量面分隔的区域。在网格上识别这些盆的一个实用方法是沿最速上升路径进行。从任何点 $\\mathbf{r}$ 开始的最速上升路径将终止于 $\\rho(\\mathbf{r})$ 的一个局部最大值点。所有通向同一最大值点的点都属于同一个盆。\n\n所实现的算法如下：\n- 一个与网格具有相同维度的三维整数数组 `basin_map` 被初始化为一个哨兵值（例如 -1），以跟踪每个格点的盆分配情况。\n- 我们遍历每个格点 $(ix, iy, iz)$。如果一个点尚未被分配到一个盆，我们从该点开始进行最速上升追踪。\n- 通过从当前格点重复移动到其 26 个邻居中密度值最高的那个邻居来追踪路径。\n- 追踪在以下两种情况之一终止：\n    1.  达到局部最大值：当前点的密度大于或等于其所有邻居的密度。\n    2.  路径到达一个已被分配到某个盆的格点（记忆化）。\n- 当在索引为 `final_idx` 的最终格点终止时，确定相应的原子 ID `basin_id`。根据规定，这是其原子核 $\\mathbf{R}_i$ 与 `final_idx` 的真实空间坐标欧几里得距离最近的原子的索引。\n- 然后将此 `basin_id` 分配给追踪路径上的每个点，从而高效地填充 `basin_map`。这种记忆化确保了对任何给定格点的上升计算只执行一次。\n\n### 4. 电荷和 RMSD 计算\n`basin_map` 完成后，通过对其分配的盆 $\\Omega_i$ 上的密度 $\\rho(\\mathbf{r})$ 进行数值积分来计算每个原子 $i$ 的总电子数 $N_i$。对于离散网格，此积分通过对属于该盆的所有体素求和来近似：\n$$\nN_i = \\int_{\\Omega_i} \\rho(\\mathbf{r}) \\, d^3\\mathbf{r} \\approx \\sum_{\\mathbf{r}_k \\in \\Omega_i} \\rho(\\mathbf{r}_k) h^3\n$$\n其中 $h^3$ 是单个体素的体积。这是通过从 `basin_map` 为每个原子 $i$ 创建一个布尔掩码，将其应用于 `rho_grid`，对所得的密度值求和，然后乘以体素体积来计算的。\n\n然后，每个原子的 Bader 电荷 $Q_i$ 计算为其核电荷（原子序数 $Z_i$）与其积分电子数 $N_i$ 之间的差值：\n$$\nQ_i = Z_i - N_i\n$$\n最后，计算得到的 Bader 电荷集 $\\{Q_i\\}$ 与形式氧化态电荷集 $\\{q_i^{\\text{formal}}\\} = \\{+2, +4, -2, -2, -2\\}$ 之间的均方根偏差（RMSD）：\n$$\n\\mathrm{RMSD} = \\sqrt{\\frac{1}{N_{\\text{atoms}}} \\sum_{i=1}^{N_{\\text{atoms}}} \\left(Q_i - q_i^{\\text{formal}}\\right)^2}\n$$\n其中 $N_{\\text{atoms}} = 5$。对所提供的三个测试用例中的每一个都重复此完整过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_rmsd(case_params):\n    \"\"\"\n    Calculates the RMSD between computed Bader charges and formal charges for a given case.\n    \"\"\"\n    h, sigmas, Es = case_params\n\n    # Define atomic properties\n    atom_pos = np.array([\n        [0.0, 0.0, 0.0],       # Ca\n        [2.36, 0.0, 0.0],      # C\n        [3.64, 0.0, 0.0],      # O1\n        [1.72, 1.108, 0.0],    # O2\n        [1.72, -1.108, 0.0]    # O3\n    ])\n    Zs = np.array([20, 6, 8, 8, 8])\n    formal_charges = np.array([2.0, 4.0, -2.0, -2.0, -2.0])\n    num_atoms = len(atom_pos)\n\n    # 1. Construct the 3D grid\n    margin = 1.0\n    min_coords = np.min(atom_pos, axis=0) - margin\n    max_coords = np.max(atom_pos, axis=0) + margin\n\n    x_coords = np.arange(min_coords[0], max_coords[0] + h / 2, h)\n    y_coords = np.arange(min_coords[1], max_coords[1] + h / 2, h)\n    z_coords = np.arange(min_coords[2], max_coords[2] + h / 2, h)\n\n    grid_shape = (len(x_coords), len(y_coords), len(z_coords))\n    X, Y, Z = np.meshgrid(x_coords, y_coords, z_coords, indexing='ij')\n\n    # 2. Evaluate the electron density on the grid\n    rho_grid = np.zeros(grid_shape, dtype=np.float64)\n    for i in range(num_atoms):\n        sigma = sigmas[i]\n        E = Es[i]\n        R = atom_pos[i]\n\n        prefactor = E / ((2 * np.pi * sigma**2)**1.5)\n        dist_sq = (X - R[0])**2 + (Y - R[1])**2 + (Z - R[2])**2\n        rho_grid += prefactor * np.exp(-dist_sq / (2 * sigma**2))\n\n    # 3. Perform steepest-ascent assignment\n    basin_map = np.full(grid_shape, -1, dtype=int)\n    \n    # Pre-generate neighbor offsets for 26-connectivity\n    neighbor_offsets = []\n    for di in [-1, 0, 1]:\n        for dj in [-1, 0, 1]:\n            for dk in [-1, 0, 1]:\n                if di == 0 and dj == 0 and dk == 0:\n                    continue\n                neighbor_offsets.append((di, dj, dk))\n\n    # Iterate over all grid points to assign basins\n    for ix in range(grid_shape[0]):\n        for iy in range(grid_shape[1]):\n            for iz in range(grid_shape[2]):\n                if basin_map[ix, iy, iz] != -1:\n                    continue\n\n                path = []\n                curr_idx = (ix, iy, iz)\n\n                while True:\n                    path.append(curr_idx)\n\n                    # Find neighbor with max rho\n                    max_rho_neighbor = -1.0\n                    next_idx = None\n                    curr_rho = rho_grid[curr_idx]\n\n                    for offset in neighbor_offsets:\n                        ni, nj, nk = curr_idx[0] + offset[0], curr_idx[1] + offset[1], curr_idx[2] + offset[2]\n\n                        # Boundary check\n                        if 0 = ni  grid_shape[0] and 0 = nj  grid_shape[1] and 0 = nk  grid_shape[2]:\n                            neighbor_rho = rho_grid[ni, nj, nk]\n                            if neighbor_rho > max_rho_neighbor:\n                                max_rho_neighbor = neighbor_rho\n                                next_idx = (ni, nj, nk)\n\n                    # Termination condition 1: local maximum found\n                    if max_rho_neighbor = curr_rho:\n                        final_idx = curr_idx\n                        final_pos_real = np.array([x_coords[final_idx[0]], y_coords[final_idx[1]], z_coords[final_idx[2]]])\n                        distances_sq = np.sum((atom_pos - final_pos_real)**2, axis=1)\n                        basin_id = np.argmin(distances_sq)\n                        break\n\n                    # Termination condition 2: path connects to a solved region\n                    if basin_map[next_idx] != -1:\n                        basin_id = basin_map[next_idx]\n                        break\n\n                    # Continue ascent\n                    curr_idx = next_idx\n\n                # Assign basin ID to all points in the traced path (memoization)\n                for p_idx in path:\n                    basin_map[p_idx] = basin_id\n\n    # 4. Compute Bader charges\n    N_atoms = np.zeros(num_atoms, dtype=np.float64)\n    voxel_volume = h**3\n\n    for i in range(num_atoms):\n        basin_mask = (basin_map == i)\n        N_atoms[i] = np.sum(rho_grid[basin_mask]) * voxel_volume\n        \n    Q_atoms = Zs - N_atoms\n\n    # 5. Compute RMSD\n    rmsd = np.sqrt(np.mean((Q_atoms - formal_charges)**2))\n    return rmsd\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Order of atoms: Ca, C, O1, O2, O3\n    \n    # Case A: moderate covalency\n    case_A_params = (\n        0.12,  # h\n        [0.60, 0.35, 0.45, 0.45, 0.45],  # sigmas\n        [19.0, 4.6, 8.8, 8.8, 8.8]       # Es\n    )\n\n    # Case B: strongly ionic allocation\n    case_B_params = (\n        0.10,  # h\n        [0.60, 0.35, 0.45, 0.45, 0.45],  # sigmas\n        [18.0, 2.0, 10.0, 10.0, 10.0]    # Es\n    )\n\n    # Case C: nearly covalent and coarse resolution\n    case_C_params = (\n        0.25,  # h\n        [0.60, 0.35, 0.45, 0.45, 0.45],  # sigmas\n        [20.0, 6.0, 8.0, 8.0, 8.0]       # Es\n    )\n    \n    test_cases = [case_A_params, case_B_params, case_C_params]\n    \n    results = []\n    for case in test_cases:\n        rmsd = calculate_rmsd(case)\n        results.append(rmsd)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在地球化学中，理解矿物表面和流体界面发生的化学反应的机理与速率至关重要，而反应能垒是决定反应速率的关键。本练习旨在介绍一种在原子尺度上寻找反应路径和计算能垒的强大工具——“微动弹性带”(Nudged Elastic Band, NEB)方法。学生将通过在一个模拟矿物表面反应的二维解析势能面上实现一个简化的攀爬像微动弹性带(Climbing Image Nudged Elastic Band, CI-NEB)算法，从而获得确定过渡态和计算活化能的实践经验，为研究更复杂的地球化学过程打下基础。",
            "id": "4076877",
            "problem": "考虑一个与地球化学相关的表面反应，其中吸附的二氧化碳在碳酸钙表面经历水化和碳酸盐形成。在密度泛函理论 (Density Functional Theory, DFT) 中使用的玻恩-奥本海默 (Born–Oppenheimer) 近似下，反应能垒是沿最小能量路径 (Minimum Energy Path, MEP) 的鞍点能量与反应物能量最低点能量之间的差值。微动弹性带 (Nudged Elastic Band, NEB) 方法通过由谐波弹簧连接的离散映像点链来近似 MEP，并在一个投影力下弛豫这些映像点。该投影力移除了真实力沿路径的分量，同时保留了沿路径的弹簧力。爬升映像 (Climbing Image, CI) 改进方法修改能量最高的映像点，通过反转真实力的平行分量并移除弹簧力，使其收敛到鞍点。\n\n您将实现一个简化的带爬升映像的 NEB 算法，该算法作用于一个二维解析势能面。该势能面表示 DFT 基态能量 $E(\\mathbf{R})$ 作为原子核坐标 $\\mathbf{R} = (x,y)$（单位为埃）的函数。该势的构造使其具有对应于初始态 $(x_{\\mathrm{react}}, y_{\\mathrm{react}})$ 和最终态 $(x_{\\mathrm{prod}}, y_{\\mathrm{prod}})$ 的能量最低点，这两个状态由与协同水化和碳酸盐形成步骤相关的能垒隔开。纯净的方解石表面由以下公式描述：\n$$\nE(x,y) = E_0 \\left[x(1-x)\\right]^2 + K_y y^2 + D \\exp\\left(-\\frac{(x-x_b)^2 + (y-y_b)^2}{\\sigma^2}\\right),\n$$\n其中 $x$ 和 $y$ 的单位是埃，$E(x,y)$ 的单位是电子伏特，$E_0$ 控制沿 $x$ 轴的基准双阱，$K_y$ 对 $y$ 方向的偏离进行惩罚，$D$ 设定鞍点附近能垒的陡峭度和高度，$(x_b,y_b)$ 定位能垒中心，$\\sigma$ 设定能垒宽度。表面缺陷通过减小 $D$ 来模拟（物理上反映了过渡态的局域稳定化），这会降低能垒。对于纯净表面和有缺陷的表面，所有其他参数保持不变。\n\n您必须推导并实现：\n- 梯度 $\\nabla E(x,y)$ 及其在 NEB 力投影中的应用。对于位置为 $\\mathbf{R}_i$、单位切向量为 $\\hat{\\tau}_i$ 的内部映像点 $i$，NEB 力为\n$$\n\\mathbf{F}_i^{\\mathrm{NEB}} = \\left[-\\nabla E(\\mathbf{R}_i)\\right] - \\left(\\left[-\\nabla E(\\mathbf{R}_i)\\right]\\cdot \\hat{\\tau}_i\\right)\\hat{\\tau}_i + k\\left(\\left\\|\\mathbf{R}_{i+1}-\\mathbf{R}_i\\right\\| - \\left\\|\\mathbf{R}_i-\\mathbf{R}_{i-1}\\right\\|\\right)\\hat{\\tau}_i,\n$$\n其中 $k$ 是弹簧常数，单位为 $\\mathrm{eV}/\\text{\\AA}^2$。对于爬升映像点 $c$（每次迭代中能量最高的内部映像点），使用\n$$\n\\mathbf{F}_c^{\\mathrm{CI}} = \\left[-\\nabla E(\\mathbf{R}_c)\\right] + 2\\left(\\nabla E(\\mathbf{R}_c)\\cdot \\hat{\\tau}_c\\right)\\hat{\\tau}_c,\n$$\n并将其弹簧力设置为零。\n- 一个简单的显式更新规则\n$$\n\\mathbf{R}_i^{(n+1)} = \\mathbf{R}_i^{(n)} + \\alpha \\,\\mathbf{F}_i^{(n)},\n$$\n端点固定，其中 $\\alpha$ 是一个小步长，单位为 $\\text{\\AA}^2/\\mathrm{eV}$。当所有内部映像点上力的最大范数低于容差 $\\varepsilon$（单位为 $\\mathrm{eV}/\\text{\\AA}$）或达到最大迭代次数时，即为收敛。\n\n在所有情况下，使用以下物理上一致的参数值、单位和端点：\n- 端点：$(x_{\\mathrm{react}}, y_{\\mathrm{react}}) = (0,0)$ 和 $(x_{\\mathrm{prod}}, y_{\\mathrm{prod}}) = (1,0)$，单位为埃。\n- 能垒中心和宽度：$(x_b, y_b) = (0.5, 0)$ 和 $\\sigma = 0.15$，单位为埃。\n- 能量参数：$E_0 = 0.8$，单位为电子伏特，$K_y = 0.1$，单位为电子伏特每平方埃。\n- 收敛标准：$\\varepsilon = 10^{-5}$，单位为电子伏特每埃，以及 $N_{\\mathrm{max}} = 10000$ 次迭代。\n\n您的程序必须为每个测试用例计算能垒高度\n$$\n\\Delta E^\\ddagger = \\max_i E(\\mathbf{R}_i^{\\star}) - E(\\mathbf{R}_{\\mathrm{react}}),\n$$\n其中 $\\mathbf{R}_i^{\\star}$ 是收敛后的 NEB 映像点位置，并以电子伏特为单位报告该值，四舍五入到六位小数。\n\n测试套件：\n- 情况 1（纯净，标准）：映像点数 $N = 15$，弹簧常数 $k = 5.0$，单位为 $\\mathrm{eV}/\\text{\\AA}^2$，步长 $\\alpha = 0.01$，单位为 $\\text{\\AA}^2/\\mathrm{eV}$，能垒振幅 $D = 0.15$，单位为电子伏特。\n- 情况 2（缺陷，中等）：$N = 15$, $k = 5.0$ 单位为 $\\mathrm{eV}/\\text{\\AA}^2$, $\\alpha = 0.01$ 单位为 $\\text{\\AA}^2/\\mathrm{eV}$, $D = 0.05$ 单位为电子伏特。\n- 情况 3（缺陷，边界映像）：$N = 3$, $k = 5.0$ 单位为 $\\mathrm{eV}/\\text{\\AA}^2$, $\\alpha = 0.02$ 单位为 $\\text{\\AA}^2/\\mathrm{eV}$, $D = 0.05$ 单位为电子伏特。\n- 情况 4（纯净，弱弹簧）：$N = 21$, $k = 0.2$ 单位为 $\\mathrm{eV}/\\text{\\AA}^2$, $\\alpha = 0.02$ 单位为 $\\text{\\AA}^2/\\mathrm{eV}$, $D = 0.15$ 单位为电子伏特。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,result_3,result_4]$），其中每个 $result_i$ 是能垒高度 $\\Delta E^\\ddagger$，以电子伏特为单位，四舍五入到六位小数。",
            "solution": "用户要求实现一个爬升映像微动弹性带 (Climbing Image Nudged Elastic Band, CI-NEB) 算法，以在二维解析势能面 (potential energy surface, PES) 上寻找反应能垒。解决方案涉及推导势的梯度、实现迭代的 CI-NEB 优化方案，并将其应用于几个测试用例。\n\n### **1. 势能面和梯度**\n\n问题提供了一个二维解析势能面 $E(x,y)$，单位为电子伏特，它是原子核坐标 $\\mathbf{R} = (x,y)$（单位为埃）的函数：\n$$\nE(x,y) = E_0 \\left[x(1-x)\\right]^2 + K_y y^2 + D \\exp\\left(-\\frac{(x-x_b)^2 + (y-y_b)^2}{\\sigma^2}\\right)\n$$\nNEB 方法需要每个映像点上的真实力，即势能梯度的负值 $\\mathbf{F}^{\\mathrm{true}} = -\\nabla E(\\mathbf{R})$。我们通过求 $E(x,y)$ 对 $x$ 和 $y$ 的偏导数来推导梯度 $\\nabla E(\\mathbf{R}) = \\left(\\frac{\\partial E}{\\partial x}, \\frac{\\partial E}{\\partial y}\\right)$。\n\n关于 $x$ 的偏导数是：\n$$\n\\frac{\\partial E}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( E_0 \\left[x^2-2x^3+x^4\\right] + K_y y^2 + D \\exp\\left(-\\frac{(x-x_b)^2 + (y-y_b)^2}{\\sigma^2}\\right) \\right)\n$$\n$$\n\\frac{\\partial E}{\\partial x} = E_0 (2x - 6x^2 + 4x^3) - \\frac{2D(x-x_b)}{\\sigma^2} \\exp\\left(-\\frac{(x-x_b)^2 + (y-y_b)^2}{\\sigma^2}\\right)\n$$\n$E_0(2x - 6x^2 + 4x^3)$ 这一项可以因式分解为 $2E_0x(1-x)(1-2x)$。\n\n关于 $y$ 的偏导数是：\n$$\n\\frac{\\partial E}{\\partial y} = \\frac{\\partial}{\\partial y} \\left( E_0 \\left[x(1-x)\\right]^2 + K_y y^2 + D \\exp\\left(-\\frac{(x-x_b)^2 + (y-y_b)^2}{\\sigma^2}\\right) \\right)\n$$\n$$\n\\frac{\\partial E}{\\partial y} = 2K_y y - \\frac{2D(y-y_b)}{\\sigma^2} \\exp\\left(-\\frac{(x-x_b)^2 + (y-y_b)^2}{\\sigma^2}\\right)\n$$\n这些梯度分量的解析表达式对于计算驱动优化的力至关重要。\n\n### **2. CI-NEB 算法**\n\nNEB 方法通过一个由 N 个映像点组成的离散链 $\\left\\{\\mathbf{R}_0, \\mathbf{R}_1, \\ldots, \\mathbf{R}_{N-1}\\right\\}$ 来近似最小能量路径 (MEP)，其中 $\\mathbf{R}_0$ 和 $\\mathbf{R}_{N-1}$ 分别是固定的反应物和产物态。内部映像点 $\\mathbf{R}_1, \\ldots, \\mathbf{R}_{N-2}$ 通过弛豫来寻找 MEP。\n\n**初始化：**\n映像点链通过在固定的端点 $\\mathbf{R}_{\\mathrm{react}} = (0,0)$ 和 $\\mathbf{R}_{\\mathrm{prod}} = (1,0)$ 之间进行线性插值来初始化：\n$$\n\\mathbf{R}_i^{(0)} = \\mathbf{R}_{\\mathrm{react}} + \\frac{i}{N-1}(\\mathbf{R}_{\\mathrm{prod}} - \\mathbf{R}_{\\mathrm{react}}) \\quad \\text{for } i \\in [0, N-1]\n$$\n\n**力的计算：**\n每个映像点上的力是投影分量的和。其核心是局部路径切线 $\\hat{\\tau}_i$ 的定义。我们使用一个数值上稳定的定义：\n$$\n\\hat{\\tau}_i = \\frac{\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}}{\\left\\|\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}\\right\\|}\n$$\n对于一个标准的（非爬升的）内部映像点 $i$，力由垂直于路径的真实势能力分量和平行于路径的弹簧力组成。弹簧力确保映像点大致等间距。\n$$\n\\mathbf{F}_i^{\\mathrm{NEB}} = \\mathbf{F}_{i,\\perp}^{\\mathrm{true}} + \\mathbf{F}_{i,\\parallel}^{\\mathrm{spring}}\n$$\n其中 $\\mathbf{F}_i^{\\mathrm{true}} = -\\nabla E(\\mathbf{R}_i)$。这可以分解为：\n$$\n\\mathbf{F}_{i,\\perp}^{\\mathrm{true}} = \\mathbf{F}_i^{\\mathrm{true}} - (\\mathbf{F}_i^{\\mathrm{true}} \\cdot \\hat{\\tau}_i)\\hat{\\tau}_i\n$$\n$$\n\\mathbf{F}_{i,\\parallel}^{\\mathrm{spring}} = k\\left(\\left\\|\\mathbf{R}_{i+1}-\\mathbf{R}_i\\right\\| - \\left\\|\\mathbf{R}_i-\\mathbf{R}_{i-1}\\right\\|\\right)\\hat{\\tau}_i\n$$\n将它们组合起来，就得到了问题陈述中提供的表达式。\n\n**爬升映像改进：**\n爬升映像 (Climbing Image, CI) 修改确保能量最高的映像点精确地收敛到鞍点。在每次迭代中，会识别出势能最高的内部映像点 $\\mathbf{R}_c$。此映像点上的弹簧力被移除，并且平行于切线的真实力分量被反转。这会驱动映像点沿路径“上坡”朝向鞍点。爬升映像点上的力是：\n$$\n\\mathbf{F}_c^{\\mathrm{CI}} = \\left[-\\nabla E(\\mathbf{R}_c)\\right] + 2\\left(\\nabla E(\\mathbf{R}_c)\\cdot \\hat{\\tau}_c\\right)\\hat{\\tau}_c = \\mathbf{F}_c^{\\mathrm{true}} - 2(\\mathbf{F}_c^{\\mathrm{true}}\\cdot\\hat{\\tau}_c)\\hat{\\tau}_c\n$$\n这等价于 $\\mathbf{F}_{c,\\perp}^{\\mathrm{true}} - \\mathbf{F}_{c,\\parallel}^{\\mathrm{true}}$，其中真实力的平行分量被反转。\n\n### **3. 迭代优化和能垒计算**\n\n内部映像点的位置使用简单的显式（欧拉）方案进行迭代更新：\n$$\n\\mathbf{R}_i^{(n+1)} = \\mathbf{R}_i^{(n)} + \\alpha \\,\\mathbf{F}_i^{(n)}\n$$\n其中 $\\alpha$ 是一个小步长参数，$\\mathbf{F}_i^{(n)}$ 是在第 $n$ 次迭代时作用于映像点 $i$ 的总 NEB 或 CI 力。\n\n迭代过程持续进行，直到任何内部映像点上力的最大范数 $\\max_{i=1...N-2} \\|\\mathbf{F}_i\\|$ 降到指定的容差 $\\varepsilon = 10^{-5}\\,\\mathrm{eV}/\\text{\\AA}$ 以下，或达到最大迭代次数 $N_{\\mathrm{max}} = 10000$。\n\n收敛后，位置表示为 $\\mathbf{R}_i^{\\star}$。反应能垒高度 $\\Delta E^\\ddagger$ 计算为收敛路径上的最大能量与反应物态能量之间的差值：\n$$\n\\Delta E^\\ddagger = \\max_{i=0...N-1} E(\\mathbf{R}_i^{\\star}) - E(\\mathbf{R}_{\\mathrm{react}})\n$$\n该过程应用于所提供的四个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the CI-NEB problem for all test cases.\n    \"\"\"\n\n    # ------------------ Global Parameters ------------------\n    # Potential Energy Surface parameters as defined in the problem\n    E0 = 0.8  # eV\n    Ky = 0.1  # eV/Å^2\n    xb, yb = 0.5, 0.0  # Å\n    sigma = 0.15  # Å\n\n    # Convergence criteria\n    epsilon = 1e-5  # eV/Å\n    N_max = 10000  # Maximum iterations\n\n    # Endpoint coordinates\n    R_react = np.array([0.0, 0.0])  # Å\n    R_prod = np.array([1.0, 0.0])   # Å\n\n    # ------------------ Helper Functions ------------------\n    def potential_energy(R, D):\n        \"\"\"Calculates the potential energy E(R) for a given position R = (x, y) and parameter D.\"\"\"\n        x, y = R\n        term1 = E0 * (x * (1.0 - x))**2\n        term2 = Ky * y**2\n        exp_arg = -((x - xb)**2 + (y - yb)**2) / sigma**2\n        term3 = D * np.exp(exp_arg)\n        return term1 + term2 + term3\n\n    def gradient(R, D):\n        \"\"\"Calculates the gradient ∇E(R) for a given position R = (x, y) and parameter D.\"\"\"\n        x, y = R\n        grad = np.zeros(2)\n        exp_term_val = np.exp(-((x - xb)**2 + (y - yb)**2) / sigma**2)\n        \n        # dE/dx\n        grad[0] = 2.0 * E0 * x * (1.0 - x) * (1.0 - 2.0 * x)\n        grad[0] -= D * exp_term_val * (2.0 * (x - xb) / sigma**2)\n        \n        # dE/dy\n        grad[1] = 2.0 * Ky * y\n        grad[1] -= D * exp_term_val * (2.0 * (y - yb) / sigma**2)\n        \n        return grad\n\n    def run_neb_case(N, k, alpha, D):\n        \"\"\"\n        Runs a single CI-NEB calculation for a given set of parameters.\n        \n        Args:\n            N (int): Number of images in the band.\n            k (float): Spring constant in eV/Å^2.\n            alpha (float): Step size in Å^2/eV.\n            D (float): Barrier amplitude in eV.\n\n        Returns:\n            float: The calculated reaction barrier height in eV.\n        \"\"\"\n        # 1. Initialization\n        images = np.zeros((N, 2))\n        images[0, :] = R_react\n        images[-1, :] = R_prod\n        # Linear interpolation for interior images\n        for i in range(1, N - 1):\n            images[i, :] = R_react + i / (N - 1.0) * (R_prod - R_react)\n\n        # 2. Main optimization loop\n        for _ in range(N_max):\n            # Calculate energies of all images to find the climbing image\n            energies = np.array([potential_energy(R, D) for R in images])\n            \n            # Interior images are from index 1 to N-2. \n            # np.argmax on the slice energies[1:-1] gives a relative index.\n            # Add 1 to get the global index in the `images` array.\n            climbing_image_idx = np.argmax(energies[1:-1]) + 1\n            \n            # Calculate true forces F_true = -∇E for mobile images\n            true_forces = np.array([-gradient(images[i], D) for i in range(1, N - 1)])\n            \n            # Storage for total NEB/CI forces on mobile images\n            total_forces = np.zeros_like(true_forces)\n\n            # Calculate tangents and NEB/CI forces for mobile images\n            for i in range(1, N - 1):\n                # Tangent vector (stable definition: R_{i+1} - R_{i-1})\n                tau_vec = images[i+1] - images[i-1]\n                tau_norm = np.linalg.norm(tau_vec)\n                tau_hat = tau_vec / tau_norm if tau_norm > 1e-12 else np.zeros(2)\n\n                # Get true force for this image (index is i-1 in true_forces array)\n                F_true = true_forces[i-1]\n\n                if i == climbing_image_idx:\n                    # Climbing image force: F_true - 2 * F_parallel\n                    F_parallel_comp = np.dot(F_true, tau_hat)\n                    total_forces[i-1] = F_true - 2.0 * F_parallel_comp * tau_hat\n                else:\n                    # Regular NEB image force\n                    # Perpendicular component of true force: F_true - F_parallel\n                    F_perp_true = F_true - np.dot(F_true, tau_hat) * tau_hat\n                    \n                    # Parallel component from springs\n                    d_i_plus_1 = np.linalg.norm(images[i+1] - images[i])\n                    d_i_minus_1 = np.linalg.norm(images[i] - images[i-1])\n                    F_parallel_spring = k * (d_i_plus_1 - d_i_minus_1) * tau_hat\n                    \n                    total_forces[i-1] = F_perp_true + F_parallel_spring\n\n            # Check for convergence\n            max_force_norm = np.max(np.linalg.norm(total_forces, axis=1))\n            if max_force_norm  epsilon:\n                break\n\n            # Update positions of mobile images\n            images[1:-1] += alpha * total_forces\n\n        # 3. Post-processing: Calculate barrier height\n        final_energies = np.array([potential_energy(R, D) for R in images])\n        E_max = np.max(final_energies)\n        # Energy of reactant is simply the energy at R_react\n        E_react = potential_energy(R_react, D) \n        barrier_height = E_max - E_react\n        \n        return barrier_height\n\n    # ------------------ Main Execution ------------------\n    # Define the test cases from the problem statement\n    test_cases = [\n        # (N, k, alpha, D)\n        (15, 5.0, 0.01, 0.15),  # Case 1\n        (15, 5.0, 0.01, 0.05),  # Case 2\n        (3,  5.0, 0.02, 0.05),  # Case 3\n        (21, 0.2, 0.02, 0.15)   # Case 4\n    ]\n\n    results = []\n    for case_params in test_cases:\n        N, k, alpha, D_case = case_params\n        barrier = run_neb_case(N, k, alpha, D_case)\n        results.append(round(barrier, 6))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}