{
    "hands_on_practices": [
        {
            "introduction": "分子动力学模拟通常使用周期性边界条件（PBC）来消除小模拟体系中的表面效应，从而模拟体相系统。正确计算周期性系统中的粒子间距离是计算力和能量的基础。本练习将指导您实现最小镜像约定（minimum image convention），这是处理周期性边界下粒子相互作用的核心算法。",
            "id": "2458300",
            "problem": "你需要编写一个完整、可运行的程序，以演示分子动力学 (MD) 模拟中周期性边界条件下的最小镜像约定的效果。该程序必须用两种方式计算正交周期性模拟盒子中两个粒子之间的欧几里得距离：(1) 忽略周期性的朴素欧几里得距离，以及 (2) 应用最小镜像约定后的欧几里得距离。距离必须以纳米 (nm) 为单位表示，并四舍五入保留恰好六位小数。\n\n背景和基本原理：在采用周期性边界条件 (PBC) 的分子动力学 (MD) 模拟中，通过对有限的模拟盒子进行无限平铺来模拟宏观体系的行为。两个粒子之间的物理距离被解释为一个粒子与另一个粒子的任何周期性镜像之间的最小距离。其底层的几何规则源自欧几里得距离的定义和晶格的平移对称性。对于边长为 $L_x$、$L_y$ 和 $L_z$ 的正交盒子，最小距离是通过沿每个轴选择整数倍盒子长度的平移，以最小化位移矢量的欧几里得范数来获得的。你的程序必须实现这一规则。\n\n你的任务：\n- 定义一个函数，给定两个以纳米为单位的三维位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 以及以纳米为单位的盒子边长 $(L_x,L_y,L_z)$，该函数返回两个值：\n  1) 以纳米为单位的朴素欧几里得距离 $d_{\\text{naive}} = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert$，\n  2) 以纳米为单位的最小镜像约定距离 $d_{\\text{mic}}$，通过将位移分量平移 $(L_x,L_y,L_z)$ 的整数倍以最小化其范数来获得。\n- 将盒子视为正交且轴对齐的。\n- 粒子的位置可能位于主盒子区间之外。你的实现必须仍然能利用周期性正确计算 $d_{\\text{mic}}$。\n- 为了使你的实现清晰，请在程序中包含一个多行伪代码字符串（不打印），概述你所实现的最小镜像约定逻辑。\n\n数值和单位要求：\n- 所有距离必须以纳米 (nm) 为单位。\n- 报告的距离需四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n你的程序必须按规定顺序为以下 $5$ 个测试用例计算 $[d_{\\text{naive}}, d_{\\text{mic}}]$。\n\n1) 正常情况，盒子内的小间距：\n- 盒子： $(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.5\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.5\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.7\\,\\text{nm},\\,1.2\\,\\text{nm},\\,1.6\\,\\text{nm}\\,)$\n\n2) 沿一个轴穿越周期性边界：\n- 盒子： $(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.1\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.9\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n\n3) 各向异性盒子和沿多轴的环绕：\n- 盒子： $(L_x,L_y,L_z) = (\\,2.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,5.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,1.9\\,\\text{nm},\\,0.2\\,\\text{nm},\\,4.8\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.1\\,\\text{nm},\\,3.9\\,\\text{nm},\\,0.3\\,\\text{nm}\\,)$\n\n4) 沿一个轴恰好为半个盒子长度的间距（临界情况）：\n- 盒子： $(L_x,L_y,L_z) = (\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n\n5) 位置在主盒子区间之外：\n- 盒子： $(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm}\\,)$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的数对列表。每个数对对应指定顺序的一个测试用例，并且必须采用 $[d_{\\text{naive}},d_{\\text{mic}}]$ 的形式，两个值都以纳米为单位四舍五入到恰好 $6$ 位小数。输出中不得包含空格。\n- 例如，要求的整体格式为 $[[a_1,b_1],[a_2,b_2],\\dots]$，其中每个 $a_k$ 和 $b_k$ 都是以纳米为单位且恰好有 $6$ 位小数的浮点数。",
            "solution": "所提出的问题是计算统计力学中的一个基础练习，具体涉及在分子动力学 (MD) 模拟中实现周期性边界条件 (PBC)。使用 PBC 是一种标准且必要的技术，通过模拟少量有限的粒子来近似宏观系统的性质。它减轻了小系统中本会占主导地位的严重表面效应。该问题的核心是正确计算粒子间距离，这由最小镜像约定 (MIC) 所规定。\n\n该问题陈述清晰，具有科学依据，并为获得唯一且可验证的解提供了所有必要的数据。我们将进行严谨的推导和实现。\n\n设正交模拟盒子由一组对应于边长的三个正交矢量定义，$\\mathbf{L} = (L_x, L_y, L_z)$。两个粒子 $i$ 和 $j$ 的位置由矢量 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 给出。\n\n首先，我们定义朴素欧几里得距离 $d_{\\text{naive}}$。这是非周期性三维欧几里得空间中的标准距离。它由位移矢量 $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$ 的范数计算得出。\n$$\nd_{\\text{naive}} = \\lVert \\Delta\\mathbf{r} \\rVert = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}\n$$\n其中 $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y, \\Delta z)$。此计算忽略了模拟盒子的周期性，并将系统视为孤立在真空中。\n\n其次，我们讨论最小镜像约定距离 $d_{\\text{mic}}$。在周期性系统中，模拟盒子在所有方向上无限复制。位于位置 $\\mathbf{r}$ 的粒子在位置 $\\mathbf{r} + n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}$ 处有一个无限的周期性镜像晶格，其中 $n_x, n_y, n_z$ 是任意整数。粒子 $i$ 和粒子 $j$ 之间的物理距离是粒子 $i$ 与粒子 $j$ 的*任何*周期性镜像之间的最短距离。\n\n数学上，这表示为：\n$$\nd_{\\text{mic}} = \\min_{n_x, n_y, n_z \\in \\mathbb{Z}} \\left\\lVert (\\mathbf{r}_j - \\mathbf{r}_i) - (n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}) \\right\\rVert\n$$\n对于正交盒子，范数的最小化可以对每个笛卡尔分量独立进行。让我们考虑位移矢量的 $x$ 分量，$\\Delta x = x_j - x_i$。我们必须找到一个整数 $n_x$ 来最小化 $|\\Delta x - n_x L_x|$。当 $n_x$ 是最接近比值 $\\Delta x / L_x$ 的整数时，即可实现这一点。这就是“最近整数函数”，通常表示为 $\\text{nint}(s)$ 或通过 `round(s)` 实现。\n\n因此，经 MIC 调整后的位移分量 $\\Delta x'$ 为：\n$$\n\\Delta x' = \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right)\n$$\n此公式正确地将位移矢量分量“环绕”到区间 $[-L_x/2, L_x/2]$ 内。同样的逻辑也适用于 $y$ 和 $z$ 分量。完整的经 MIC 调整后的位移矢量 $\\Delta\\mathbf{r}'$ 则为：\n$$\n\\Delta\\mathbf{r}' = \\left( \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right), \\Delta y - L_y \\cdot \\text{round}\\left(\\frac{\\Delta y}{L_y}\\right), \\Delta z - L_z \\cdot \\text{round}\\left(\\frac{\\Delta z}{L_z}\\right) \\right)\n$$\n这种矢量运算是稳健的，并且能正确处理粒子坐标可能位于主模拟盒子之外的情况，因为只有它们的相对位移才是重要的。\n\n最小镜像距离 $d_{\\text{mic}}$ 是此调整后位移矢量的欧几里得范数：\n$$\nd_{\\text{mic}} = \\lVert \\Delta\\mathbf{r}' \\rVert = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2}\n$$\n\n所提供的测试用例将使用此既定方法进行求解。实现将利用 `numpy` 库进行高效的矢量运算。对于每个测试用例，我们将计算 $d_{\\text{naive}}$ 和 $d_{\\text{mic}}$，并按要求将结果四舍五入到精确的 $6$ 位小数进行报告。对于位移恰好为盒子长度一半的特殊情况，例如 $\\Delta x = L_x/2$，由 `round` 函数处理。该函数通常会四舍五入到最近的偶数（例如，在 `numpy` 中），但无论调整后位移的符号选择如何，最终的距离都是唯一的 $L_x/2$。对于 $\\Delta x = L_x/2$，$\\Delta x' = L_x/2 - L_x \\cdot \\text{round}(0.5) = L_x/2 - L_x \\cdot 0 = L_x/2$。其大小是明确的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating naive and minimum image convention (MIC)\n    distances for a set of test cases in a molecular dynamics context.\n    \"\"\"\n\n    # Per the problem specification, this multi-line string contains the\n    # pseudocode explaining the implemented MIC logic. It is not printed.\n    # noinspection PyUnusedLocal\n    MIC_PSEUDOCODE = \"\"\"\n    function calculate_minimum_image_distance(r_i, r_j, box_dims):\n        // r_i, r_j: 3D position vectors [x, y, z] of two particles in nm.\n        // box_dims: 3D vector of orthorhombic box lengths [L_x, L_y, L_z] in nm.\n\n        // 1. Calculate the raw displacement vector.\n        //    This is a simple vector subtraction.\n        delta_r = r_j - r_i\n\n        // 2. Apply the minimum image convention to each component of the displacement vector.\n        //    For an orthorhombic box, this can be done independently for each axis.\n        //    The principle is to find the closest periodic image by shifting the displacement\n        //    by an integer number of box lengths. This is mathematically equivalent to\n        //    finding the nearest integer multiple of the box length to subtract.\n        \n        //    Let dr_c be a component of delta_r (e.g., delta_x) and L_c be the\n        //    corresponding box length (e.g., L_x).\n        //    The scaled displacement is s = dr_c / L_c.\n        //    The nearest integer number of box lengths to shift by is n = round(s).\n        //    The MIC-adjusted displacement component is dr'_c = dr_c - n * L_c.\n\n        //    In vector notation, this is:\n        mic_delta_r = delta_r - box_dims * np.round(delta_r / box_dims)\n        \n        // 3. Calculate the Euclidean norm (length) of the MIC-adjusted displacement vector.\n        //    This is the final minimum image distance.\n        distance_mic = sqrt(mic_delta_r[0]^2 + mic_delta_r[1]^2 + mic_delta_r[2]^2)\n        \n        return distance_mic\n    \"\"\"\n\n    def compute_distances(r_i_tuple, r_j_tuple, box_dims_tuple):\n        \"\"\"\n        Calculates naive and MIC distances for a single pair of particles.\n        \n        Args:\n            r_i_tuple (tuple): Position of particle i.\n            r_j_tuple (tuple): Position of particle j.\n            box_dims_tuple (tuple): Orthorhombic box dimensions (Lx, Ly, Lz).\n        \n        Returns:\n            A list containing two floats: [d_naive, d_mic].\n        \"\"\"\n        r_i = np.array(r_i_tuple, dtype=float)\n        r_j = np.array(r_j_tuple, dtype=float)\n        box_dims = np.array(box_dims_tuple, dtype=float)\n\n        # 1. Naive Euclidean distance\n        delta_r_naive = r_j - r_i\n        d_naive = np.linalg.norm(delta_r_naive)\n\n        # 2. Minimum Image Convention (MIC) distance\n        # The logic delta_r - L * round(delta_r / L) correctly finds the\n        # shortest vector in a periodic lattice.\n        delta_r_mic = delta_r_naive - box_dims * np.round(delta_r_naive / box_dims)\n        d_mic = np.linalg.norm(delta_r_mic)\n        \n        return [d_naive, d_mic]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1) Happy path, small separation\n        {'r_i': (0.5, 1.0, 1.5), 'r_j': (0.7, 1.2, 1.6), 'box': (3.0, 3.0, 3.0)},\n        # 2) Crossing a periodic boundary\n        {'r_i': (0.1, 1.0, 1.0), 'r_j': (2.9, 1.0, 1.0), 'box': (3.0, 3.0, 3.0)},\n        # 3) Anisotropic box and multi-axis wrapping\n        {'r_i': (1.9, 0.2, 4.8), 'r_j': (0.1, 3.9, 0.3), 'box': (2.0, 4.0, 5.0)},\n        # 4) Exactly half-box separation\n        {'r_i': (0.0, 0.0, 0.0), 'r_j': (2.0, 0.0, 0.0), 'box': (4.0, 4.0, 4.0)},\n        # 5) Positions outside the primary box\n        {'r_i': (-0.1, -0.1, -0.1), 'r_j': (3.1, 3.1, 3.1), 'box': (3.0, 3.0, 3.0)},\n    ]\n\n    result_strings = []\n    for case in test_cases:\n        d_naive, d_mic = compute_distances(case['r_i'], case['r_j'], case['box'])\n        \n        # Format the numbers to exactly 6 decimal places and create the pair string.\n        # This ensures trailing zeros are included and meets the formatting requirement.\n        result_strings.append(f\"[{d_naive:.6f},{d_mic:.6f}]\")\n\n    # Final print statement in the exact required format: [[a1,b1],[a2,b2],...]\n    # without spaces between elements.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在分子动力学模拟中，选择合适的时间步长（timestep）至关重要，它直接影响到模拟的稳定性、准确性和计算效率。过大的时间步长会导致能量不守恒，甚至使模拟“爆炸”。本练习通过一个简化的谐振子模型，让您亲手探索数值积分稳定性的极限，并理解为何系统中最高频率的振动（“最硬”的模式）决定了稳定时间步长的上限。",
            "id": "2458247",
            "problem": "要求您实现一个独立的、基于第一性原理的计算实验，以研究在分子动力学（MD）中代表蛋白质刚性简正模的单一维谐振模式的时间步长稳定性。该系统是一个质量为 $m$ 的粒子，被限制在力常数为 $k$ 的谐波势中，其演化遵循牛顿第二定律。整个过程使用约化无量纲单位；不要为任何量附加物理单位。\n\n动力学由牛顿第二定律 $m \\,\\ddot{x}(t) = - k \\, x(t)$ 定义，初始条件为 $x(0) = x_0$ 和 $\\dot{x}(0) = v_0$。总能量为 $E(t) = \\tfrac{1}{2} m \\,\\dot{x}(t)^2 + \\tfrac{1}{2} k \\, x(t)^2$。对于给定的离散时间步长 $dt$，模拟总时长为 $T$ 的运动，并在轨迹中监控 $E(t)$。\n\n对于选定的 $dt$，如果在任何模拟步骤中发生以下三个事件中的任何一个，则定义为发生了“爆炸”：\n- 计算出的总能量 $E(t)$ 变为非有限值（即，不是一个实数、有限的数）。\n- 相对能量误差超过指定的容差，即在模拟结束前的任何时间 $t$，有 $\\lvert E(t) - E(0) \\rvert / E(0)  \\varepsilon$。\n- 位置的绝对值超过一个从初始能量导出的预设界限，即对于任何 $t$，有 $\\lvert x(t) \\rvert  B \\, A_0$，其中 $A_0 = \\sqrt{2 E(0)/k}$。\n\n对于下面的每个测试用例，给定参数集 $(m, k, x_0, v_0, T, \\varepsilon, B)$ 和一个有序的时间步长列表 $[dt_1, dt_2, \\dots, dt_n]$。对每个测试用例，按给定顺序分别为列表中的每个 $dt_i$ 单独模拟该系统，并根据上述定义，找出导致爆炸的最小 $dt_i$。如果所列的 $dt_i$ 都没有导致爆炸，则返回哨兵值 $-1.0$。\n\n使用以下四个测试用例。下面所有的符号和数字都应解释为约化无量纲单位。\n\n测试用例 1:\n- 参数: $m = 1.0$, $k = 1.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 100.0$, $\\varepsilon = 0.20$, $B = 100.0$。\n- 要测试的时间步长（按升序排列）: $[0.1, 0.5, 1.5, 1.9, 2.0, 2.1]$。\n\n测试用例 2:\n- 参数: $m = 1.0$, $k = 16.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 20.0$, $\\varepsilon = 0.10$, $B = 100.0$。\n- 要测试的时间步长（按升序排列）: $[0.05, 0.10, 0.30, 0.49, 0.50, 0.51]$。\n\n测试用例 3:\n- 参数: $m = 2.0$, $k = 0.5$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 50.0$, $\\varepsilon = 0.05$, $B = 1000.0$。\n- 要测试的时间步长（按升序排列）: $[0.50, 1.00, 2.00, 3.00, 3.50]$。\n\n测试用例 4:\n- 参数: $m = 1.0$, $k = 100.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 8.0$, $\\varepsilon = 0.15$, $B = 100.0$。\n- 要测试的时间步长（按升序排列）: $[0.02, 0.10, 0.19, 0.20, 0.25]$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。每个结果都必须是一个浮点数，四舍五入到六位小数，其顺序与上述测试用例的顺序相同。例如，如果四个测试用例的结果是 $r_1$、$r_2$、$r_3$ 和 $r_4$，您的程序必须精确打印\n\"[r1,r2,r3,r4]\"\n其中每个 $r_i$ 都格式化为六位小数，且不含任何其他文本。\n\n任何内部出现的角度量都必须以弧度处理。此问题中的所有值根据其构造都是无量纲的，因此输出中不应显示任何物理单位。",
            "solution": "该问题要求进行一项计算实验，以确定一维谐振子的数值积分方案的稳定性极限，该谐振子可作为分子动力学（MD）模拟中刚性振动模式的模型。该问题是适定的，并有科学依据。它构成了对数值积分稳定性的直接测试，这是计算科学中的一个基本概念。\n\n该系统由简谐振子的运动方程描述：\n$$\nm \\frac{d^2x}{dt^2} = -k x(t)\n$$\n其中 $m$ 是质量，$k$ 是力常数，$x(t)$ 是位置。此振子的角频率为 $\\omega = \\sqrt{k/m}$。动力学将使用离散时间步长 $dt$ 从初始条件 $x(0) = x_0$ 和 $\\dot{x}(0) = v_0$ 开始进行演化。\n\n问题陈述并未指定数值积分算法。对于牛顿力学的 MD 模拟，Velocity-Verlet 算法因其时间可逆性和辛性而成为一种标准、广泛使用且稳健的选择，这些特性使其具有良好的长期能量守恒性。因此，Velocity-Verlet 积分器是适合实现的算法。\n\nVelocity-Verlet 算法包含以下步骤，用于将系统从时间 $t$ 推进到 $t+dt$：\n1.  计算半步速度：\n    $$\n    v(t + \\tfrac{1}{2}dt) = v(t) + \\tfrac{1}{2} a(t) dt\n    $$\n2.  将位置更新到完整的新时间步：\n    $$\n    x(t + dt) = x(t) + v(t + \\tfrac{1}{2}dt) dt\n    $$\n3.  计算新位置处的加速度。加速度由力 $F(x) = -kx$ 导出，因此 $a(x) = F(x)/m = -(k/m)x$：\n    $$\n    a(t + dt) = -\\frac{k}{m} x(t + dt)\n    $$\n4.  计算新时间下的全步速度：\n    $$\n    v(t + dt) = v(t + \\tfrac{1}{2}dt) + \\tfrac{1}{2} a(t + dt) dt\n    $$\n\n对于每个测试用例，我们都得到了一组参数 $(m, k, x_0, v_0, T, \\varepsilon, B)$ 和一个有序的时间步长列表 $[dt_1, dt_2, \\dots]$。任务是从该列表中找出导致模拟变得不稳定或“爆炸”的最小 $dt_i$。对于给定的 $dt$，模拟运行总时间 $T$，这对应于 $N_{steps} = \\lfloor T/dt \\rfloor$ 个积分步。\n\n在模拟循环开始之前，我们必须为爆炸判据建立基线。初始总能量 $E(0)$ 计算如下：\n$$\nE(0) = \\frac{1}{2} m v_0^2 + \\frac{1}{2} k x_0^2\n$$\n问题陈述说明，对于所有测试用例，$x_0$、$v_0$、$m$ 和 $k$ 均为正数，这确保了 $E(0)  0$。然后将特征振幅 $A_0$ 定义为：\n$$\nA_0 = \\sqrt{\\frac{2 E(0)}{k}}\n$$\n这个 $A_0$ 代表了精确解析解中的最大位移。\n\n模拟通过迭代 Velocity-Verlet 算法 $N_{steps}$ 次来进行。每步之后，我们获得新状态 $(x(t+dt), v(t+dt))$ 并检查三种爆炸条件：\n1.  **能量的有限性**：新步长的总能量 $E(t+dt) = \\frac{1}{2} m v(t+dt)^2 + \\frac{1}{2} k x(t+dt)^2$ 必须是一个有限实数。在计算上，这通过验证该值是否为 `NaN`（非数值）或无穷大来检查。此条件用于检测灾难性的数值溢出。\n2.  **相对能量守恒**：当前能量与初始能量的相对偏差不得超过容差 $\\varepsilon$。\n    $$\n    \\frac{\\lvert E(t+dt) - E(0) \\rvert}{E(0)}  \\varepsilon\n    $$\n    此条件用于检测数值积分误差何时导致总能量出现显著的、非物理的漂移，即使轨迹尚未发散到无穷大。\n3.  **位置界限**：位置的绝对值不得超过特征振幅的一个很大倍数。\n    $$\n    \\lvert x(t+dt) \\rvert  B \\cdot A_0\n    $$\n    这是对轨迹发散的另一个实用检查，即粒子逃逸到离势能最小值非物理的大距离处。\n\n每个测试用例的整体流程如下：\n遍历所提供的时间步长列表 $dt_i$（按升序排列）。对于每个 $dt_i$：\n- 运行一次总时长为 $T$ 的完整模拟。\n- 在模拟的每一步，检查三个爆炸条件。\n- 如果在模拟过程中的任何时刻满足任何一个条件，则认为该 $dt_i$ 下的模拟是不稳定的。这个 $dt_i$ 就是该测试用例的结果，然后我们继续处理下一个测试用例。\n- 如果模拟在时间 $T$ 内完成且未发生任何爆炸，则认为该 $dt_i$ 是稳定的。然后我们继续测试列表中的下一个 $dt_i$。\n\n如果给定测试用例列表中的所有时间步长都导致了稳定的模拟，则该测试用例的结果为哨兵值 $-1.0$。\n\n该实现将包含一个主函数，用于遍历所有测试用例。该函数将为每个测试用例调用一个子函数，而该子函数又会遍历所提供的 $dt$ 值并调用一个模拟函数。模拟函数实现 Velocity-Verlet 循环和上述的稳定性检查。最终输出是一个列表，其中包含每个用例的最小爆炸 $dt$ 值，如果未找到，则为 $-1.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(m, k, x0, v0, T, epsilon, B, dt) - bool:\n    \"\"\"\n    Runs a simulation of a 1D harmonic oscillator using the Velocity-Verlet algorithm.\n\n    Args:\n        m (float): Mass.\n        k (float): Force constant.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        T (float): Total simulation time.\n        epsilon (float): Relative energy error tolerance.\n        B (float): Position bound factor.\n        dt (float): Time step.\n\n    Returns:\n        bool: True if an explosion occurs, False otherwise.\n    \"\"\"\n    if dt = 0:\n        return False  # A time step of zero or less is not meaningful.\n\n    num_steps = int(T / dt)\n    \n    # Initial conditions\n    x = float(x0)\n    v = float(v0)\n    \n    # Calculate initial energy and derived bounds for explosion criteria\n    e0 = 0.5 * m * v**2 + 0.5 * k * x**2\n    \n    # The problem constraints ensure e0  0, so no division by zero.\n    a0 = np.sqrt(2 * e0 / k)\n    x_bound = B * a0\n\n    # Initial acceleration\n    a = -(k / m) * x\n    \n    # Main simulation loop\n    for _ in range(num_steps):\n        # Velocity-Verlet integrator\n        # v(t + dt/2)\n        v_half = v + 0.5 * a * dt\n        # x(t + dt)\n        x = x + v_half * dt\n        # a(t + dt)\n        a_new = -(k / m) * x\n        # v(t + dt)\n        v = v_half + 0.5 * a_new * dt\n        \n        # Update acceleration for the next step\n        a = a_new\n        \n        # Calculate current energy at the full step\n        e_current = 0.5 * m * v**2 + 0.5 * k * x**2\n        \n        # --- Check for explosion conditions ---\n        \n        # 1. Non-finite energy (numerical overflow)\n        if not np.isfinite(e_current):\n            return True  # Explosion\n            \n        # 2. Relative energy error exceeds tolerance\n        # In the case e0 is 0, any change would be an infinite relative error.\n        # But for the given test cases, e0 is always positive.\n        if abs(e_current - e0) / e0  epsilon:\n            return True  # Explosion\n        \n        # 3. Position exceeds bound\n        if abs(x)  x_bound:\n            return True  # Explosion\n            \n    return False  # No explosion occurred\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            'params': (1.0, 1.0, 1.0, 1.0, 100.0, 0.20, 100.0),\n            'dts': [0.1, 0.5, 1.5, 1.9, 2.0, 2.1],\n        },\n        {\n            'params': (1.0, 16.0, 1.0, 1.0, 20.0, 0.10, 100.0),\n            'dts': [0.05, 0.10, 0.30, 0.49, 0.50, 0.51],\n        },\n        {\n            'params': (2.0, 0.5, 1.0, 1.0, 50.0, 0.05, 1000.0),\n            'dts': [0.50, 1.00, 2.00, 3.00, 3.50],\n        },\n        {\n            'params': (1.0, 100.0, 1.0, 1.0, 8.0, 0.15, 100.0),\n            'dts': [0.02, 0.10, 0.19, 0.20, 0.25],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m, k, x0, v0, T, epsilon, B = case['params']\n        dts = case['dts']\n        \n        explosion_dt = -1.0\n        # The 'dts' lists are sorted, so we find the smallest by breaking on the first hit.\n        for dt in dts:\n            if run_simulation(m, k, x0, v0, T, epsilon, B, dt):\n                explosion_dt = dt\n                break\n        \n        results.append(f\"{explosion_dt:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "计算化学反应或物理过程（如离子穿过通道）的自由能垒是计算地球化学中的一个核心任务。然而，由于这些“稀有事件”的发生频率极低，常规分子动力学模拟难以充分采样。本练习将介绍一种强大的增强采样技术——伞形采样（umbrella sampling），并指导您使用加权直方图分析方法（WHAM）从有偏的模拟数据中重建无偏的平均力势（PMF），从而量化能量景观。",
            "id": "2458249",
            "problem": "您将模拟单个氨基酸侧链沿疏水性碳纳米管轴线的可逆拉伸过程，该过程由一维反应坐标 $z$（单位为 $\\mathrm{nm}$）表示，$z=0$ 位于纳米管中心，并沿其轴线增加。目标是从在谐波伞形势下获得的偏置采样数据中，恢复平均力势 (PMF)，记为 $W(z)$（单位为 $\\mathrm{kJ/mol}$）。请完全在绝对温度为 $T$（单位为 $\\mathrm{K}$）的一维经典正则系综中进行计算，并将坐标限制在间距为 $\\Delta z$（单位也为 $\\mathrm{nm}$）的均匀网格 $z \\in [z_{\\min}, z_{\\max}]$ 上。\n\n定义：\n\n- PMF $W(z)$ 由正则概率密度 $P(z)$ 定义，相差一个加性常数：\n$$\nW(z) = -k_\\mathrm{B} T \\ln P(z) + C,\n$$\n其中 $k_\\mathrm{B}$ 是玻尔兹曼常数，$C$ 是任意常数。当以每摩尔的能量表示时，使用气体常数 $R$ 代替 $k_\\mathrm{B}$，其中 $R = 8.314462618 \\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$；您必须始终以 $\\mathrm{kJ/mol}$ 为单位处理能量，并使用 $\\beta = \\frac{1}{R_\\mathrm{kJ}T}$，其中 $R_\\mathrm{kJ} = R/1000$，单位为 $\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$。\n\n- 在伞形采样窗口 $i$ 中，附加的谐波偏置势为\n$$\nU_i(z) = \\tfrac{1}{2} k_i \\left(z - z_i\\right)^2,\n$$\n其中力常数为 $k_i$（单位为 $\\mathrm{kJ\\,mol^{-1}\\,nm^{-2}}$），中心为 $z_i$（单位为 $\\mathrm{nm}$）。窗口 $i$ 中的偏置平衡分布与 $\\exp\\!\\left[-\\beta (W(z) + U_i(z))\\right]$ 成正比。\n\n在本练习中，代表氨基酸-纳米管相互作用的内在PMF由平滑势垒建模：\n$$\nW^\\ast(z) = H \\exp\\!\\left(-\\frac{z^2}{\\sigma^2}\\right),\n$$\n其中势垒振幅为 $H$（单位为 $\\mathrm{kJ/mol}$），宽度参数为 $\\sigma$（单位为 $\\mathrm{nm}$）。这个 $W^\\ast(z)$ 用于生成偏置直方图，但在从偏置数据重构PMF时，您必须仅使用直方图和已知的偏置，并遵循上述正则定义。均匀的 $z$ 网格和直方图构建定义如下。\n\n- 网格：$z_{\\min} = -1.0 \\,\\mathrm{nm}$，$z_{\\max} = +1.0 \\,\\mathrm{nm}$，$\\Delta z = 0.02 \\,\\mathrm{nm}$。设网格点为 $z_j = z_{\\min} + j \\,\\Delta z$，整数 $j$ 的取值范围应包含 $z_{\\max}$。\n\n- 在每个窗口 $i$ 中，偏置概率密度与 $\\exp\\!\\left[-\\beta \\left(W^\\ast(z_j) + U_i(z_j)\\right)\\right]$ 成正比。窗口 $i$ 中箱 $j$ 的直方图计数为\n$$\nn_i(z_j) = \\mathrm{round}\\!\\left(N_i \\, \\pi_i(z_j)\\, \\Delta z\\right),\n$$\n其中 $N_i$ 是窗口 $i$ 中采样的总构型数，$\\pi_i(z_j)$ 是满足 $\\sum_j \\pi_i(z_j)\\,\\Delta z = 1$ 的归一化离散偏置概率，$\\mathrm{round}(\\cdot)$ 表示四舍五入到最近的整数。\n\n您的任务是：对于下面指定的每个测试用例，从 $W^\\ast(z)$ 和提供的伞形参数构建偏置直方图 $\\{n_i(z_j)\\}$，然后，仅使用 $\\{n_i(z_j)\\}$、已知的 $U_i(z_j)$ 和上述正则定义，重构无偏置的离散概率 $P(z_j)$ 和相差一个加性常数的PMF $W(z_j)$。最后，报告PMF势垒高度\n$$\n\\Delta W = \\max_j W(z_j) - \\min_j W(z_j)\n$$\n单位为 $\\mathrm{kJ/mol}$。最终的 $\\Delta W$ 值四舍五入到三位小数。\n\n测试套件（四个独立案例）。每个案例定义了温度 $T$（单位为 $\\mathrm{K}$）、势垒参数 $H$（单位为 $\\mathrm{kJ/mol}$）和 $\\sigma$（单位为 $\\mathrm{nm}$）、一组由中心 $z_i$（单位为 $\\mathrm{nm}$）和公共谐波力常数 $k_i \\equiv k$（单位为 $\\mathrm{kJ\\,mol^{-1}\\,nm^{-2}}$）定义的伞形窗口，以及每个窗口相等的样本数 $N_i \\equiv N$：\n\n- A案例（理想情况）：\n  - $T = 300$, $H = 10$, $\\sigma = 0.25$,\n  - $k = 200$,\n  - $z_i$ 从 $-0.8$ 到 $+0.8$ 均匀分布，间距为 $0.2$,\n  - 每个窗口 $N = 200000$。\n\n- B案例（更宽的势垒，更稀疏的窗口）：\n  - $T = 300$, $H = 15$, $\\sigma = 0.20$,\n  - $k = 150$,\n  - $z_i$ 从 $-0.9$ 到 $+0.9$ 均匀分布，间距为 $0.3$,\n  - 每个窗口 $N = 250000$。\n\n- C案例（更高的温度）：\n  - $T = 350$, $H = 9$, $\\sigma = 0.30$,\n  - $k = 200$,\n  - $z_i$ 从 $-0.8$ 到 $+0.8$ 均匀分布，间距为 $0.2$,\n  - 每个窗口 $N = 200000$。\n\n- D案例（边缘覆盖情况）：\n  - $T = 300$, $H = 6$, $\\sigma = 0.35$,\n  - $k = 100$,\n  - $z_i$ 从 $-0.8$ 到 $+0.8$ 均匀分布，间距为 $0.4$,\n  - 每个窗口 $N = 300000$。\n\n要求的最终输出格式：您的程序应生成一行，其中包含A、B、C和D案例的四个势垒高度 $\\Delta W$ 的列表，按此顺序排列，单位为 $\\mathrm{kJ/mol}$，四舍五入到三位小数，格式为方括号括起来的逗号分隔列表，例如，“[$x_1,x_2,x_3,x_4$]”。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于统计力学的原理，问题设定良好，并提供了客观、明确的定义和数据。它构成了一个标准的、尽管是理想化的计算化学练习，具体来说是从伞形采样数据中重构平均力势 (PMF)。我们现在将继续提供完整的解决方案。\n\n基本任务是从一组偏置直方图 $\\{n_i(z_j)\\}$ 中恢复一维PMF，$W(z)$。每个直方图 $i$ 的数据是在已知谐波偏置势 $U_i(z)$ 的影响下生成的。这是一个经典的反问题，可以使用加权直方图分析方法 (WHAM) 解决，该方法提供了一种最优的、自洽的方式来组合来自多个偏置模拟的数据。\n\n首先，我们建立必要的物理和数学框架。系统处于温度为 $T$ 的正则系综中。在坐标 $z$ 处观察到系统的无偏置概率为 $P(z)$，它通过以下关系定义了PMF：\n$$\nW(z) = -k_\\mathrm{B} T \\ln P(z) + C\n$$\n对于摩尔能量，我们使用气体常数 $R$。由于能量要求以 $\\mathrm{kJ/mol}$ 为单位，我们定义 $R_{\\mathrm{kJ}} = R/1000$ 和逆热能 $\\beta = \\frac{1}{R_\\mathrm{kJ} T}$。那么，对于一组离散坐标箱 $z_j$ 的PMF由下式给出：\n$$\nW(z_j) = -\\frac{1}{\\beta} \\ln P(z_j) + C'\n$$\n其中 $P(z_j)$ 是在 $z_j$ 处的概率密度。更方便的是使用处于箱 $j$ 中的概率 $p_j = P(z_j) \\Delta z$，其中 $\\Delta z$ 是箱宽。集合 $\\{p_j\\}$ 形成一个概率分布，$\\sum_j p_j = 1$。PMF可以表示为：\n$$\nW(z_j) = -\\frac{1}{\\beta} \\ln p_j + C''\n$$\n常数 $C''$ 包含了项 $\\frac{1}{\\beta} \\ln(\\Delta z)$，在计算势垒高度 $\\Delta W = \\max_j W(z_j) - \\min_j W(z_j)$ 时可以忽略。\n\n在每个伞形采样窗口 $i$ 中，施加了一个偏置 $U_i(z)$。偏置概率分布 $P_i(z)$ 与无偏置分布 $P(z)$ 的关系如下：\n$$\nP_i(z) = \\frac{P(z) \\exp(-\\beta U_i(z))}{\\int P(z') \\exp(-\\beta U_i(z')) dz'}\n$$\n分母是一个归一化常数，与施加偏置的自由能 $F_i$ 相关：$\\exp(-\\beta F_i) = \\int P(z') \\exp(-\\beta U_i(z')) dz'$。\n\nWHAM方程通过组合所有 $M$ 个窗口的数据，为无偏置概率 $\\{p_j\\}$ 提供了最优估计。这些方程是：\n$$\np_j = \\frac{\\sum_{i=1}^{M} n_{ij}}{\\sum_{i=1}^{M} N_i \\exp(-\\beta (U_{ij} - F_i))}\n$$\n$$\nF_i = -\\frac{1}{\\beta} \\ln \\left( \\sum_{j} p_j \\exp(-\\beta U_{ij}) \\right)\n$$\n此处，$n_{ij}$ 是窗口 $i$ 中箱 $j$ 的样本数，$N_i$ 是窗口 $i$ 的总样本数，$U_{ij} = U_i(z_j)$ 是偏置势能，$\\{F_i\\}$ 是相对于无偏置状态的窗口自由能。这些方程是耦合的，必须自洽地求解。自由能 $\\{F_i\\}$ 仅在相差一个加性常数的情况下确定，因此我们可以在迭代过程中固定一个（例如，$F_1 = 0$）以确保收敛。\n\n对每个测试用例，求解过程分两个主要阶段实施：\n\n**阶段1：数据生成**\n\n首先，我们根据问题规范生成“实验”数据（直方图 $\\{n_{ij}\\}$）。这涉及到使用提供的模型PMF，$W^\\ast(z)$。此阶段仅用于生成输入数据；$W^\\ast(z)$ 在后续的重构中不被使用。\n\n1.  建立一个从 $z_{\\min} = -1.0$到 $z_{\\max} = +1.0$，间距为 $\\Delta z = 0.02$ 的均匀 $z_j$ 坐标网格。\n2.  对于每个窗口 $i$，其中心为 $z_i$，力常数为 $k_i$：\n    a. 在网格上计算真实的PMF $W^\\ast(z_j) = H \\exp(-z_j^2/\\sigma^2)$ 和偏置势 $U_{ij} = \\frac{1}{2} k_i (z_j - z_i)^2$。\n    b. 总势能为 $E_{ij} = W^\\ast(z_j) + U_{ij}$。\n    c. 箱 $j$ 的未归一化偏置概率为 $q_{ij} = \\exp(-\\beta E_{ij})$。\n    d. 计算归一化概率密度 $\\pi_i(z_j)$ 为 $\\pi_i(z_j) = q_{ij} / (\\sum_k q_{ik} \\Delta z)$。\n    e. 生成直方图计数：$n_{ij} = \\mathrm{round}(N_i \\cdot \\pi_i(z_j) \\cdot \\Delta z)$。\n\n**阶段2：PMF重构和势垒计算**\n\n其次，我们使用生成的直方图 $\\{n_{ij}\\}$、已知的偏置 $\\{U_{ij}\\}$ 和样本数 $\\{N_i\\}$ 来重构PMF。\n\n1.  **初始化**：初始化自由能，例如，对所有 $i=1, \\dots, M$，令 $F_i = 0$。\n2.  **自洽迭代**：迭代求解WHAM方程，直到 $\\{F_i\\}$ 的值收敛。\n    a. 使用当前的 $\\{F_i\\}$ 计算更新的、未归一化的概率分布 $\\{p'_j\\}$：\n       $$\n       p'_j = \\frac{\\sum_{i=1}^{M} n_{ij}}{\\sum_{i=1}^{M} N_i \\exp(-\\beta (U_{ij} - F_i))}\n       $$\n    b. 归一化分布：$p_j = p'_j / (\\sum_k p'_k)$。\n    c. 使用更新的 $\\{p_j\\}$ 计算新的自由能 $\\{F_i^{\\text{new}}\\}$：\n       $$\n       F_i^{\\text{new}} = -\\frac{1}{\\beta} \\ln \\left( \\sum_{j} p_j \\exp(-\\beta U_{ij}) \\right)\n       $$\n    d. 平移自由能以强制执行一致的参考，例如，通过设置 $F_1^{\\text{new}} = 0$ 来防止数值漂移。\n    e. 重复此过程，直到 $\\{F_i\\}$ 在两次迭代之间的变化小于一个小的容差。\n3.  **最终计算**：\n    a. 一旦获得收敛的概率 $\\{p_j\\}$，就为所有概率非零的箱（$p_j  0$）计算PMF：$W_j = -\\frac{1}{\\beta} \\ln(p_j)$。\n    b. 通过将其最小值设置为零来平移PMF：$W_j^{\\text{final}} = W_j - \\min_k W_k$。\n    c. 势垒高度是最终PMF的最大值：$\\Delta W = \\max_j W_j^{\\text{final}}$。\n\n此程序应用于指定的四个测试用例中的每一个。收集并报告得到的 $\\Delta W$ 值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the PMF reconstruction problem for all test cases.\n    \"\"\"\n    # Universal constants and grid parameters\n    R_KJ = 8.314462618 / 1000  # Gas constant in kJ/mol/K\n    Z_MIN, Z_MAX, DZ = -1.0, 1.0, 0.02\n    \n    # Grid setup (ensuring z_max is included)\n    num_bins = int(round((Z_MAX - Z_MIN) / DZ)) + 1\n    z_grid = np.linspace(Z_MIN, Z_MAX, num_bins)\n\n    # Test suite definition\n    test_cases = [\n        { # Case A\n            \"T\": 300, \"H\": 10, \"sigma\": 0.25, \"k\": 200,\n            \"z_i_range\": (-0.8, 0.8), \"z_i_step\": 0.2, \"N\": 200000\n        },\n        { # Case B\n            \"T\": 300, \"H\": 15, \"sigma\": 0.20, \"k\": 150,\n            \"z_i_range\": (-0.9, 0.9), \"z_i_step\": 0.3, \"N\": 250000\n        },\n        { # Case C\n            \"T\": 350, \"H\": 9, \"sigma\": 0.30, \"k\": 200,\n            \"z_i_range\": (-0.8, 0.8), \"z_i_step\": 0.2, \"N\": 200000\n        },\n        { # Case D\n            \"T\": 300, \"H\": 6, \"sigma\": 0.35, \"k\": 100,\n            \"z_i_range\": (-0.8, 0.8), \"z_i_step\": 0.4, \"N\": 300000\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_w = process_case(case, z_grid, R_KJ, DZ)\n        results.append(f\"{delta_w:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef process_case(case_params, z_grid, r_kj, dz):\n    \"\"\"\n    Generates histograms and runs WHAM for a single test case.\n    \"\"\"\n    # Unpack parameters\n    T = case_params[\"T\"]\n    H = case_params[\"H\"]\n    sigma = case_params[\"sigma\"]\n    k = case_params[\"k\"]\n    z_i_start, z_i_end = case_params[\"z_i_range\"]\n    z_i_step = case_params[\"z_i_step\"]\n    N_samples_per_window = case_params[\"N\"]\n\n    # Umbrella window centers\n    z_i_centers = np.arange(z_i_start, z_i_end + z_i_step * 0.1, z_i_step)\n    num_windows = len(z_i_centers)\n    num_bins = len(z_grid)\n    \n    beta = 1.0 / (r_kj * T)\n\n    # --- Stage 1: Data Generation ---\n    W_star = H * np.exp(-z_grid**2 / sigma**2)\n    \n    histograms = np.zeros((num_windows, num_bins))\n    bias_potentials = np.zeros((num_windows, num_bins))\n    \n    for i in range(num_windows):\n        z_i = z_i_centers[i]\n        U_i = 0.5 * k * (z_grid - z_i)**2\n        bias_potentials[i, :] = U_i\n        \n        total_potential = W_star + U_i\n        \n        # Biased probability density\n        unnormalized_prob = np.exp(-beta * total_potential)\n        normalization_const = np.sum(unnormalized_prob) * dz\n        prob_density_pi = unnormalized_prob / normalization_const\n        \n        # Histogram counts\n        counts = np.round(N_samples_per_window * prob_density_pi * dz)\n        histograms[i, :] = counts\n        \n    N_i_array = np.full(num_windows, N_samples_per_window)\n\n    # --- Stage 2: PMF Reconstruction (WHAM) ---\n    F = np.zeros(num_windows)  # Initial guess for free energies\n    \n    max_iter = 1000\n    tolerance = 1e-9\n    \n    for iteration in range(max_iter):\n        F_old = F.copy()\n        \n        # Calculate unnormalized probabilities p'_j\n        # Numerator: total counts in each bin\n        numerator = np.sum(histograms, axis=0)\n        \n        # Denominator: sum over windows\n        # Use broadcasting for efficient computation\n        log_weights = -beta * (bias_potentials - F[:, np.newaxis])\n        # Handle potential overflow in exp by subtracting max value, though\n        # standard WHAM is usually stable enough for typical parameters.\n        exp_weights = np.exp(log_weights)\n        denominator_terms = N_i_array[:, np.newaxis] * exp_weights\n        denominator = np.sum(denominator_terms, axis=0)\n\n        # Avoid division by zero for empty bins\n        p_unnormalized = np.zeros_like(numerator)\n        valid_bins_mask = denominator > 0\n        p_unnormalized[valid_bins_mask] = numerator[valid_bins_mask] / denominator[valid_bins_mask]\n        \n        # Normalize probabilities\n        p_sum = np.sum(p_unnormalized)\n        p = p_unnormalized / p_sum if p_sum > 0 else p_unnormalized\n\n        # Update free energies F_i\n        # Sum term for F_i calculation: sum_j p_j * exp(-beta * U_ij)\n        sum_terms = np.sum(p[np.newaxis, :] * np.exp(-beta * bias_potentials), axis=1)\n\n        # Avoid log(0)\n        valid_F_mask = sum_terms > 0\n        F[valid_F_mask] = -(1.0 / beta) * np.log(sum_terms[valid_F_mask])\n        \n        # Shift F to keep F[0] = 0 for stability\n        F -= F[0]\n\n        # Check for convergence\n        if np.max(np.abs(F - F_old))  tolerance:\n            break\n            \n    # --- Final Calculation ---\n    # Calculate PMF from converged probabilities\n    valid_pmf_bins = p > 0\n    W = np.full_like(p, np.inf)\n    W[valid_pmf_bins] = -(1.0 / beta) * np.log(p[valid_pmf_bins])\n    \n    # Normalize PMF to have minimum of 0\n    min_W = np.min(W)\n    W -= min_W\n    \n    # Barrier height is the maximum of the final PMF\n    delta_W = np.max(W[np.isfinite(W)])\n    \n    return delta_W\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}