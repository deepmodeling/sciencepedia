{
    "hands_on_practices": [
        {
            "introduction": "分子动力学模拟通常使用周期性边界条件（Periodic Boundary Conditions, PBC）来模拟宏观块状材料，以消除有限尺寸体系中不合实际的表面效应。在这样的周期性体系中，正确计算粒子间的相互作用力是任何MD模拟得以进行的首要步骤。本练习  旨在提供实现最小镜像约定（Minimum Image Convention, MIC）的实践经验，这是在周期性盒子中寻找两个粒子间最短距离的基本几何规则。",
            "id": "2458300",
            "problem": "您需要编写一个完整、可运行的程序，来演示在分子动力学 (MD) 模拟中，周期性边界条件的最小镜像约定的效果。该程序必须用两种方式计算正交周期性模拟盒子中两个粒子间的欧几里得距离：(1) 忽略周期性的朴素欧几里得距离，以及 (2) 应用最小镜像约定后的欧几里得距离。距离必须以纳米 (nm) 表示，并四舍五入到恰好六位小数。\n\n背景与基本原理：在具有周期性边界条件 (PBC) 的分子动力学 (MD) 模拟中，通过对有限的模拟盒子进行无限平铺来模仿体行为。两个粒子间的物理距离被解释为一个粒子与另一个粒子的任何周期性镜像之间的最小距离。其潜在的几何规则源于欧几里得距离的定义和晶格的平移对称性。对于边长为 $L_x$、$L_y$ 和 $L_z$ 的正交盒子，最小距离是通过沿每个轴选择整数倍盒子长度的平移，以最小化位移矢量的欧几里得范数来获得的。您的程序必须实现这一规则。\n\n您的任务：\n- 定义一个函数，给定两个三维位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$（单位为纳米）以及盒子长度 $(L_x,L_y,L_z)$（单位为纳米），返回两个值：\n  1) 朴素欧几里得距离 $d_{\\text{naive}} = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert$（单位为 nm），\n  2) 最小镜像约定距离 $d_{\\text{mic}}$（单位为 nm），该距离通过将位移分量平移 $(L_x,L_y,L_z)$ 的整数倍以最小化范数来获得。\n- 将盒子视为正交且与坐标轴对齐。\n- 位置可能位于主盒子区间之外。您的实现必须仍然能利用周期性正确计算 $d_{\\text{mic}}$。\n- 为了使您的实现清晰，请在程序中包含一个多行伪代码字符串（不打印），概述您所实现的最小镜像约定逻辑。\n\n数值和单位要求：\n- 所有距离必须以纳米 (nm) 为单位。\n- 报告的距离必须四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n您的程序必须按规定顺序为以下 $5$ 个测试用例计算 $[d_{\\text{naive}}, d_{\\text{mic}}]$。\n\n1) 正常路径，盒子内的小分离：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.5\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.5\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.7\\,\\text{nm},\\,1.2\\,\\text{nm},\\,1.6\\,\\text{nm}\\,)$\n\n2) 沿一个轴穿越周期性边界：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.1\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.9\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n\n3) 各向异性盒子及沿多轴的回绕：\n- 盒子：$(L_x,L_y,L_z) = (\\,2.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,5.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,1.9\\,\\text{nm},\\,0.2\\,\\text{nm},\\,4.8\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.1\\,\\text{nm},\\,3.9\\,\\text{nm},\\,0.3\\,\\text{nm}\\,)$\n\n4) 沿一个轴恰好为半个盒子长度的分离（临界情况）：\n- 盒子：$(L_x,L_y,L_z) = (\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n\n5) 位置在主盒子区间之外：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm}\\,)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表由方括号括起来的数对组成。每个数对对应指定顺序的一个测试用例，并且必须具有 $[d_{\\text{naive}},d_{\\text{mic}}]$ 的形式，两个值都以纳米为单位，四舍五入到恰好 $6$ 位小数。输出中不得有空格。\n- 例如，要求的整体格式类似于 $[[a_1,b_1],[a_2,b_2],\\dots]$，其中每个 $a_k$ 和 $b_k$ 是浮点数，单位为纳米，且恰好有 $6$ 位小数。",
            "solution": "所提出的问题是计算统计力学中的一个基础练习，具体涉及在分子动力学 (MD) 模拟中周期性边界条件 (PBC) 的实现。使用 PBC 是通过模拟少量有限粒子来近似宏观系统性质的一种标准且必要的技术。它减轻了否则会主导小系统行为的严重表面效应。这个问题的核心是正确计算粒子间距离，这由最小镜像约定 (MIC) 所支配。\n\n该问题陈述清晰，具有科学依据，并为唯一且可验证的解决方案提供了所有必要的数据。我们将进行严谨的推导和实现。\n\n设正交模拟盒子由一组对应于边长的三个正交矢量定义，$\\mathbf{L} = (L_x, L_y, L_z)$。两个粒子 $i$ 和 $j$ 的位置由矢量 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 给出。\n\n首先，我们定义朴素欧几里得距离 $d_{\\text{naive}}$。这是非周期性三维欧几里得空间中的标准距离。它由位移矢量 $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$ 的范数计算得出。\n$$\nd_{\\text{naive}} = \\lVert \\Delta\\mathbf{r} \\rVert = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}\n$$\n其中 $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y, \\Delta z)$。这个计算忽略了模拟盒子的周期性，并将系统视为孤立在真空中。\n\n其次，我们讨论最小镜像约定距离 $d_{\\text{mic}}$。在周期性系统中，模拟盒子在所有方向上无限复制。位于位置 $\\mathbf{r}$ 的粒子具有一个无限的周期性镜像晶格，其位置为 $\\mathbf{r} + n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}$，其中 $n_x, n_y, n_z$ 是任意整数。粒子 $i$ 和粒子 $j$ 之间的物理距离是粒子 $i$ 与粒子 $j$ 的*任何*周期性镜像之间的最短距离。\n\n在数学上，这表示为：\n$$\nd_{\\text{mic}} = \\min_{n_x, n_y, n_z \\in \\mathbb{Z}} \\left\\lVert (\\mathbf{r}_j - \\mathbf{r}_i) - (n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}) \\right\\rVert\n$$\n对于正交盒子，范数的最小化可以对每个笛卡尔分量独立进行。让我们考虑位移矢量的 $x$ 分量，$\\Delta x = x_j - x_i$。我们必须找到一个整数 $n_x$ 来最小化 $|\\Delta x - n_x L_x|$。当 $n_x$ 是与比率 $\\Delta x / L_x$ 最接近的整数时，即可实现此目标。这就是“最近整数函数”，通常表示为 $\\text{nint}(s)$ 或通过 `round(s)` 实现。\n\n因此，MIC校正后的位移分量 $\\Delta x'$ 为：\n$$\n\\Delta x' = \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right)\n$$\n这个公式正确地将位移矢量分量“回绕”到区间 $[-L_x/2, L_x/2]$ 内。同样的逻辑也适用于 $y$ 和 $z$ 分量。完整的MIC校正后的位移矢量 $\\Delta\\mathbf{r}'$ 则为：\n$$\n\\Delta\\mathbf{r}' = \\left( \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right), \\Delta y - L_y \\cdot \\text{round}\\left(\\frac{\\Delta y}{L_y}\\right), \\Delta z - L_z \\cdot \\text{round}\\left(\\frac{\\Delta z}{L_z}\\right) \\right)\n$$\n这种矢量运算是稳健的，并且能正确处理粒子坐标可能位于主模拟盒子之外的情况，因为只有它们的相对位移是重要的。\n\n最小镜像距离 $d_{\\text{mic}}$ 是这个校正后位移矢量的欧几里得范数：\n$$\nd_{\\text{mic}} = \\lVert \\Delta\\mathbf{r}' \\rVert = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2}\n$$\n\n提供的测试用例将使用这种既定方法来解决。实现将利用 `numpy` 库进行高效的矢量算术。对于每个测试用例，我们将计算 $d_{\\text{naive}}$ 和 $d_{\\text{mic}}$，并按要求将结果四舍五入到恰好 $6$ 位小数进行报告。对于位移恰好为半个盒子长度的特殊情况，例如 $\\Delta x = L_x/2$，由 `round` 函数处理，该函数通常会四舍五入到最近的偶数（例如，在 `numpy` 中），但无论校正后位移的符号选择如何，最终的距离都是唯一的 $L_x/2$。对于 $\\Delta x = L_x/2$，$\\Delta x' = L_x/2 - L_x \\cdot \\text{round}(0.5) = L_x/2 - L_x \\cdot 0 = L_x/2$。其大小是明确的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating naive and minimum image convention (MIC)\n    distances for a set of test cases in a molecular dynamics context.\n    \"\"\"\n\n    # Per the problem specification, this multi-line string contains the\n    # pseudocode explaining the implemented MIC logic. It is not printed.\n    # noinspection PyUnusedLocal\n    MIC_PSEUDOCODE = \"\"\"\n    function calculate_minimum_image_distance(r_i, r_j, box_dims):\n        // r_i, r_j: 3D position vectors [x, y, z] of two particles in nm.\n        // box_dims: 3D vector of orthorhombic box lengths [L_x, L_y, L_z] in nm.\n\n        // 1. Calculate the raw displacement vector.\n        //    This is a simple vector subtraction.\n        delta_r = r_j - r_i\n\n        // 2. Apply the minimum image convention to each component of the displacement vector.\n        //    For an orthorhombic box, this can be done independently for each axis.\n        //    The principle is to find the closest periodic image by shifting the displacement\n        //    by an integer number of box lengths. This is mathematically equivalent to\n        //    finding the nearest integer multiple of the box length to subtract.\n        \n        //    Let dr_c be a component of delta_r (e.g., delta_x) and L_c be the\n        //    corresponding box length (e.g., L_x).\n        //    The scaled displacement is s = dr_c / L_c.\n        //    The nearest integer number of box lengths to shift by is n = round(s).\n        //    The MIC-adjusted displacement component is dr'_c = dr_c - n * L_c.\n\n        //    In vector notation, this is:\n        mic_delta_r = delta_r - box_dims * np.round(delta_r / box_dims)\n        \n        // 3. Calculate the Euclidean norm (length) of the MIC-adjusted displacement vector.\n        //    This is the final minimum image distance.\n        distance_mic = sqrt(mic_delta_r[0]^2 + mic_delta_r[1]^2 + mic_delta_r[2]^2)\n        \n        return distance_mic\n    \"\"\"\n\n    def compute_distances(r_i_tuple, r_j_tuple, box_dims_tuple):\n        \"\"\"\n        Calculates naive and MIC distances for a single pair of particles.\n        \n        Args:\n            r_i_tuple (tuple): Position of particle i.\n            r_j_tuple (tuple): Position of particle j.\n            box_dims_tuple (tuple): Orthorhombic box dimensions (Lx, Ly, Lz).\n        \n        Returns:\n            A list containing two floats: [d_naive, d_mic].\n        \"\"\"\n        r_i = np.array(r_i_tuple, dtype=float)\n        r_j = np.array(r_j_tuple, dtype=float)\n        box_dims = np.array(box_dims_tuple, dtype=float)\n\n        # 1. Naive Euclidean distance\n        delta_r_naive = r_j - r_i\n        d_naive = np.linalg.norm(delta_r_naive)\n\n        # 2. Minimum Image Convention (MIC) distance\n        # The logic delta_r - L * round(delta_r / L) correctly finds the\n        # shortest vector in a periodic lattice.\n        delta_r_mic = delta_r_naive - box_dims * np.round(delta_r_naive / box_dims)\n        d_mic = np.linalg.norm(delta_r_mic)\n        \n        return [d_naive, d_mic]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1) Happy path, small separation\n        {'r_i': (0.5, 1.0, 1.5), 'r_j': (0.7, 1.2, 1.6), 'box': (3.0, 3.0, 3.0)},\n        # 2) Crossing a periodic boundary\n        {'r_i': (0.1, 1.0, 1.0), 'r_j': (2.9, 1.0, 1.0), 'box': (3.0, 3.0, 3.0)},\n        # 3) Anisotropic box and multi-axis wrapping\n        {'r_i': (1.9, 0.2, 4.8), 'r_j': (0.1, 3.9, 0.3), 'box': (2.0, 4.0, 5.0)},\n        # 4) Exactly half-box separation\n        {'r_i': (0.0, 0.0, 0.0), 'r_j': (2.0, 0.0, 0.0), 'box': (4.0, 4.0, 4.0)},\n        # 5) Positions outside the primary box\n        {'r_i': (-0.1, -0.1, -0.1), 'r_j': (3.1, 3.1, 3.1), 'box': (3.0, 3.0, 3.0)},\n    ]\n\n    result_strings = []\n    for case in test_cases:\n        d_naive, d_mic = compute_distances(case['r_i'], case['r_j'], case['box'])\n        \n        # Format the numbers to exactly 6 decimal places and create the pair string.\n        # This ensures trailing zeros are included and meets the formatting requirement.\n        result_strings.append(f\"[{d_naive:.6f},{d_mic:.6f}]\")\n\n    # Final print statement in the exact required format: [[a1,b1],[a2,b2],...]\n    # without spaces between elements.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在建立好模拟体系之后，下一步是通过数值积分来使其随时间演化。MD模拟的准确性和稳定性严重依赖于积分时间步长 $dt$ 的选择。本练习  通过一个简单但具有代表性的分子内部高频振动模型，引导您探索过大的时间步长如何导致能量不守恒和模拟“爆炸”，从而帮助您建立对这一关键参数的直观理解。",
            "id": "2458247",
            "problem": "要求您实现一个独立的、基于第一性原理的计算实验，以研究代表分子动力学 (MD) 中蛋白质刚性简正模的单一维谐振模式的时间步长稳定性。该系统是一个质量为 $m$ 的粒子，被限制在力常数为 $k$ 的谐波势中，根据牛顿第二定律演化。全程使用约化无量纲单位；不要给任何量附加物理单位。\n\n动力学由牛顿第二定律 $m \\,\\ddot{x}(t) = - k \\, x(t)$ 定义，初始条件为 $x(0) = x_0$ 和 $\\dot{x}(0) = v_0$。总能量为 $E(t) = \\tfrac{1}{2} m \\,\\dot{x}(t)^2 + \\tfrac{1}{2} k \\, x(t)^2$。对于给定的离散时间步长 $dt$，在总模拟时间 $T$ 内模拟运动，并在轨迹中监测 $E(t)$。\n\n定义对于选定的 $dt$，如果在任何模拟步骤中发生以下三个事件之一，则发生了“爆炸”：\n- 计算出的总能量 $E(t)$ 变为非有限值（即，不是一个实数、有限数）。\n- 相对能量误差超过指定容差，即对于直到模拟结束的任何时间 $t$，有 $\\lvert E(t) - E(0) \\rvert / E(0) > \\varepsilon$。\n- 位置的绝对值超过了从初始能量导出的预设界限，即对于任何 $t$，有 $\\lvert x(t) \\rvert > B \\, A_0$，其中 $A_0 = \\sqrt{2 E(0)/k}$。\n\n对于下面的每个测试用例，都给定了一组参数 $(m, k, x_0, v_0, T, \\varepsilon, B)$ 和一个有序的时间步长列表 $[dt_1, dt_2, \\dots, dt_n]$。对于每个测试用例，按给定顺序分别为列表中的每个 $dt_i$ 模拟系统，并找出列表中导致上述定义下发生爆炸的最小 $dt_i$。如果列出的 $dt_i$ 均未导致爆炸，则返回哨兵值 $-1.0$。\n\n使用以下四个测试用例。下面所有符号和数字都应解释为约化无量纲单位。\n\n测试用例 1:\n- 参数: $m = 1.0$, $k = 1.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 100.0$, $\\varepsilon = 0.20$, $B = 100.0$。\n- 待测试的时间步长（按升序排列）: $[0.1, 0.5, 1.5, 1.9, 2.0, 2.1]$。\n\n测试用例 2:\n- 参数: $m = 1.0$, $k = 16.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 20.0$, $\\varepsilon = 0.10$, $B = 100.0$。\n- 待测试的时间步长（按升序排列）: $[0.05, 0.10, 0.30, 0.49, 0.50, 0.51]$。\n\n测试用例 3:\n- 参数: $m = 2.0$, $k = 0.5$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 50.0$, $\\varepsilon = 0.05$, $B = 1000.0$。\n- 待测试的时间步长（按升序排列）: $[0.50, 1.00, 2.00, 3.00, 3.50]$。\n\n测试用例 4:\n- 参数: $m = 1.0$, $k = 100.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 8.0$, $\\varepsilon = 0.15$, $B = 100.0$。\n- 待测试的时间步长（按升序排列）: $[0.02, 0.10, 0.19, 0.20, 0.25]$。\n\n您的程序必须产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个结果必须是浮点数，保留六位小数，并与上述测试用例的顺序相同。例如，如果四个测试用例的结果是 $r_1$、$r_2$、$r_3$ 和 $r_4$，您的程序必须精确打印\n“[r1,r2,r3,r4]”\n其中每个 $r_i$ 都格式化为六位小数，且无附加文本。\n\n如果内部出现任何角度量，必须以弧度处理。本问题中的所有值通过构造都是无量纲的，因此输出中不应显示任何物理单位。",
            "solution": "该问题要求进行一个计算实验，以确定一维谐振子数值积分方案的稳定性极限，该谐振子可作为分子动力学 (MD) 模拟中刚性振动模式的模型。这个问题提法明确且具有科学依据。它直接测试了数值积分稳定性，这是计算科学中的一个基本概念。\n\n该系统由简谐振子的运动方程描述：\n$$\nm \\frac{d^2x}{dt^2} = -k x(t)\n$$\n其中 $m$ 是质量，$k$ 是力常数，$x(t)$ 是位置。此振子的角频率为 $\\omega = \\sqrt{k/m}$。动力学将使用离散时间步长 $dt$ 从初始条件 $x(0) = x_0$ 和 $\\dot{x}(0) = v_0$ 开始传播。\n\n问题陈述没有指定数值积分算法。对于牛顿力学的 MD 模拟，Velocity-Verlet 算法因其时间可逆性和辛性质而成为一种标准、广泛使用且稳健的选择，这些特性使其具有良好的长期能量守恒性。因此，Velocity-Verlet 积分器是适合实现的算法。\n\nVelocity-Verlet 算法包含以下步骤，用于将系统从时间 $t$推进到 $t+dt$：\n1.  计算半步速度：\n    $$\n    v(t + \\tfrac{1}{2}dt) = v(t) + \\tfrac{1}{2} a(t) dt\n    $$\n2.  将位置更新到完整的新时间步：\n    $$\n    x(t + dt) = x(t) + v(t + \\tfrac{1}{2}dt) dt\n    $$\n3.  计算新位置处的加速度。加速度由力 $F(x) = -kx$ 导出，因此 $a(x) = F(x)/m = -(k/m)x$：\n    $$\n    a(t + dt) = -\\frac{k}{m} x(t + dt)\n    $$\n4.  计算新时间下的全步速度：\n    $$\n    v(t + dt) = v(t + \\tfrac{1}{2}dt) + \\tfrac{1}{2} a(t + dt) dt\n    $$\n\n对于每个测试用例，我们都有一组参数 $(m, k, x_0, v_0, T, \\varepsilon, B)$ 和一个有序的时间步长列表 $[dt_1, dt_2, \\dots]$。任务是从这个列表中找出导致模拟变得不稳定或“爆炸”的最小 $dt_i$。对于给定的 $dt$，模拟运行总时间 $T$，对应于 $N_{steps} = \\lfloor T/dt \\rfloor$ 个积分步。\n\n在模拟循环开始之前，我们必须为爆炸标准建立基线。初始总能量 $E(0)$ 计算如下：\n$$\nE(0) = \\frac{1}{2} m v_0^2 + \\frac{1}{2} k x_0^2\n$$\n问题指出，对于所有测试用例，$x_0$、$v_0$、$m$ 和 $k$ 均为正数，确保 $E(0) > 0$。然后将特征振幅 $A_0$ 定义为：\n$$\nA_0 = \\sqrt{\\frac{2 E(0)}{k}}\n$$\n这个 $A_0$ 代表了精确解析解中的最大位移。\n\n模拟通过迭代 Velocity-Verlet 算法 $N_{steps}$ 次来进行。每一步之后，我们获得新状态 $(x(t+dt), v(t+dt))$ 并检查三个爆炸条件：\n1.  **能量的有限性**：新步骤的总能量，$E(t+dt) = \\frac{1}{2} m v(t+dt)^2 + \\frac{1}{2} k x(t+dt)^2$，必须是一个有限实数。在计算上，这通过验证值是否为 `NaN`（非数字）或无穷大来检查。此条件可检测灾难性的数值溢出。\n2.  **相对能量守恒**：当前能量与初始能量的相对偏差不得超过容差 $\\varepsilon$。\n    $$\n    \\frac{\\lvert E(t+dt) - E(0) \\rvert}{E(0)} > \\varepsilon\n    $$\n    此条件检测数值积分误差何时导致总能量出现显著的、非物理的漂移，即使轨迹尚未发散到无穷大。\n3.  **位置界限**：位置的绝对值不得超过特征振幅的某个大倍数。\n    $$\n    \\lvert x(t+dt) \\rvert > B \\cdot A_0\n    $$\n    这是对轨迹发散的另一个实际检查，其中粒子逃逸到离势能最小值非物理的大距离处。\n\n每个测试用例的总体过程如下：\n遍历所提供的时间步长列表 $dt_i$（按升序排序）。对于每个 $dt_i$：\n- 运行总时间为 $T$ 的完整模拟。\n- 在模拟的每一步，检查三个爆炸条件。\n- 如果在模拟过程中的任何时刻满足任何条件，则认为该 $dt_i$ 的模拟是不稳定的。此 $dt_i$ 是该测试用例的结果，然后我们继续处理下一个测试用例。\n- 如果在时间 $T$ 内完成模拟而没有发生任何爆炸，则认为该 $dt_i$ 是稳定的。然后我们继续测试列表中的下一个 $dt_i$。\n\n如果给定测试用例列表中的所有时间步长都导致了稳定的模拟，则该测试用例的结果为哨兵值 $-1.0$。\n\n实现将包含一个主函数，该函数遍历所有测试用例。此函数将为每个测试用例调用一个子函数，该子函数又会遍历提供的 $dt$ 值并调用一个模拟函数。模拟函数实现 Velocity-Verlet 循环和上述稳定性检查。最终输出是每种情况下导致爆炸的最小 $dt$ 列表，如果找不到，则为 $-1.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(m, k, x0, v0, T, epsilon, B, dt) -> bool:\n    \"\"\"\n    Runs a simulation of a 1D harmonic oscillator using the Velocity-Verlet algorithm.\n\n    Args:\n        m (float): Mass.\n        k (float): Force constant.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        T (float): Total simulation time.\n        epsilon (float): Relative energy error tolerance.\n        B (float): Position bound factor.\n        dt (float): Time step.\n\n    Returns:\n        bool: True if an explosion occurs, False otherwise.\n    \"\"\"\n    if dt <= 0:\n        return False  # A time step of zero or less is not meaningful.\n\n    num_steps = int(T / dt)\n    \n    # Initial conditions\n    x = float(x0)\n    v = float(v0)\n    \n    # Calculate initial energy and derived bounds for explosion criteria\n    e0 = 0.5 * m * v**2 + 0.5 * k * x**2\n    \n    # The problem constraints ensure e0 > 0, so no division by zero.\n    a0 = np.sqrt(2 * e0 / k)\n    x_bound = B * a0\n\n    # Initial acceleration\n    a = -(k / m) * x\n    \n    # Main simulation loop\n    for _ in range(num_steps):\n        # Velocity-Verlet integrator\n        # v(t + dt/2)\n        v_half = v + 0.5 * a * dt\n        # x(t + dt)\n        x = x + v_half * dt\n        # a(t + dt)\n        a_new = -(k / m) * x\n        # v(t + dt)\n        v = v_half + 0.5 * a_new * dt\n        \n        # Update acceleration for the next step\n        a = a_new\n        \n        # Calculate current energy at the full step\n        e_current = 0.5 * m * v**2 + 0.5 * k * x**2\n        \n        # --- Check for explosion conditions ---\n        \n        # 1. Non-finite energy (numerical overflow)\n        if not np.isfinite(e_current):\n            return True  # Explosion\n            \n        # 2. Relative energy error exceeds tolerance\n        # In the case e0 is 0, any change would be an infinite relative error.\n        # But for the given test cases, e0 is always positive.\n        if abs(e_current - e0) / e0 > epsilon:\n            return True  # Explosion\n        \n        # 3. Position exceeds bound\n        if abs(x) > x_bound:\n            return True  # Explosion\n            \n    return False  # No explosion occurred\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            'params': (1.0, 1.0, 1.0, 1.0, 100.0, 0.20, 100.0),\n            'dts': [0.1, 0.5, 1.5, 1.9, 2.0, 2.1],\n        },\n        {\n            'params': (1.0, 16.0, 1.0, 1.0, 20.0, 0.10, 100.0),\n            'dts': [0.05, 0.10, 0.30, 0.49, 0.50, 0.51],\n        },\n        {\n            'params': (2.0, 0.5, 1.0, 1.0, 50.0, 0.05, 1000.0),\n            'dts': [0.50, 1.00, 2.00, 3.00, 3.50],\n        },\n        {\n            'params': (1.0, 100.0, 1.0, 1.0, 8.0, 0.15, 100.0),\n            'dts': [0.02, 0.10, 0.19, 0.20, 0.25],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m, k, x0, v0, T, epsilon, B = case['params']\n        dts = case['dts']\n        \n        explosion_dt = -1.0\n        # The 'dts' lists are sorted, so we find the smallest by breaking on the first hit.\n        for dt in dts:\n            if run_simulation(m, k, x0, v0, T, epsilon, B, dt):\n                explosion_dt = dt\n                break\n        \n        results.append(f\"{explosion_dt:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一次长时间的MD模拟会产生一系列按时间顺序排列的构象，但这些数据点在统计上并非相互独立的。如果不考虑这种时间相关性，而直接套用标准公式来计算平均值和不确定度，将会严重低估真实的统计误差。本练习  深入探讨了自相关的概念，并指导您应用分块平均法（block-averaging method），这是一种获得统计可靠不确定度估计的稳健技术，适用于计算径向分布函数或扩散系数等物理性质。",
            "id": "4090898",
            "problem": "在一个与地球化学水溶液相关的经典分子动力学（MD）模拟中，你通过将氧-氧间距按宽度为 $\\Delta r$ 的箱格进行直方图统计，从而在固定的 $r$ 箱格中计算氧-氧径向分布函数（RDF），记为 $g(r)$。设 $A_k$ 表示对这个特定 $g(r)$ 箱格的每帧贡献（例如，在时间索引 $k$ 处的归一化箱格计数），在总轨迹长度 $T = 20\\,\\mathrm{ns}$ 上每 $\\Delta t = 10\\,\\mathrm{fs}$ 采样一次。对 $A_k$ 的归一化自相关函数进行的独立分析表明，其呈现近似指数衰减，$\\rho_A(t) \\approx \\exp(-t/\\tau_c)$，相关时间为 $\\tau_c \\approx 5\\,\\mathrm{ps}$。你还希望使用相同的轨迹，通过爱因斯坦关系式，从均方位移（MSD）中估计水的自扩散系数 $D$，并且你需要一个对 $D$ 的统计上可靠的不确定度估计。\n\n从时间相关函数的基本定义以及遍历平稳过程中时间平均收敛于系综平均这一事实出发，论证自相关如何影响时间平均估计量的方差。利用此论证来解释积分自相关时间的含义，以及它如何改变有效独立样本数。然后，设计一个分块平均法，该方法能够对 $g(r)$ 箱格中的不确定度给出无偏估计，并且可以适用于 $D$。\n\n以下哪个步骤是正确的？\n\nA. 将每一帧都视为独立的。将 $g(r)$ 箱格的标准误计算为 $\\sqrt{\\hat{\\sigma}^2/N}$，其中 $\\hat{\\sigma}^2$ 是所有帧中 $A_k$ 的样本方差，$N = T/\\Delta t$。对于 $D$，对整个轨迹的 MSD 拟合一条直线以获得斜率，并将线性回归的标准误作为不确定度，因为对多个时间原点进行平均会使 MSD 点有效地独立。\n\nB. 从轨迹中估计 $A_k$ 的归一化自相关函数 $\\rho_A(t)$，并通过对 $\\rho_A(t)$ 进行时间积分来计算积分自相关时间 $\\tau_{\\mathrm{int}}$。选择一个满足 $L \\gg \\tau_{\\mathrm{int}}$ 的非重叠块长度 $L$（例如，此处 $L \\approx 100\\,\\mathrm{ps}$），将轨迹划分为 $M = T/L$ 个非重叠块，计算块均值 $\\{\\bar{A}^{(m)}\\}_{m=1}^M$，然后通过块均值的样本方差除以 $M$（使用无偏分母 $(M-1)$）来估计总体均值的方差。检查当 $L$ 增加到数倍于 $\\tau_{\\mathrm{int}}$ 以上时，估计的标准误是否达到平台期。对于 $D$，计算独立的逐块估计值 $D^{(m)}$（例如，通过在每个块内，对远小于 $L$ 但大于弹道区的延迟时间计算 MSD 斜率得到），然后使用相同的块方差方法来获得 $D$ 的不确定度。\n\nC. 使用长度为 $L \\approx \\tau_c$ 的重叠块以最大化块的数量。从所有重叠块均值的样本方差中计算 $g(r)$ 均值的方差。对于 $D$，对所有时间原点的速度自相关函数进行平均，积分一次得到 $D$，并使用重叠块的数量作为不确定度的有效自由度。\n\nD. 计算 $A_k$ 的积分自相关时间，然后将有效样本量设置为 $N_{\\mathrm{eff}} = N$。因为 $A_k$ 是有界的（作为直方图贡献），所以相关性很弱，在 $N \\to \\infty$ 的极限下会消失，因此朴素的标准误 $\\sqrt{\\hat{\\sigma}^2/N}$ 是渐进无偏的。对于 $D$，通过有放回地重采样时间点来对 MSD 时间序列进行自助法（bootstrap）处理以获得斜率分布；使用其标准差作为不确定度。\n\n选择唯一的最佳选项。",
            "solution": "用户要求对一个关于分子动力学（MD）模拟数据统计分析的计算地球化学问题进行严格验证，然后提供详细的解答并评估所给选项。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n-   **系统与模拟：** 氯化钠水溶液的经典分子动力学（MD）模拟。\n-   **可观测量：**\n    1.  氧-氧径向分布函数 $g(r)$，特指单个直方图箱格内的值。\n    2.  水的自扩散系数 $D$，将通过爱因斯坦关系式从均方位移（MSD）中估计。\n-   **轨迹数据：**\n    -   对 $g(r)$ 箱格的每帧贡献记为 $A_k$。\n    -   采样间隔：$\\Delta t = 10\\,\\mathrm{fs}$。\n    -   总轨迹长度：$T = 20\\,\\mathrm{ns}$。\n-   **相关性信息：**\n    -   $A_k$ 的归一化自相关函数给定为 $\\rho_A(t) \\approx \\exp(-t/\\tau_c)$。\n    -   相关时间常数为 $\\tau_c \\approx 5\\,\\mathrm{ps}$。\n-   **核心任务：** 从时间相关函数和遍历性的基本原理出发，解释自相关如何影响时间平均估计量的方差，以及积分自相关时间的意义。在此基础上，设计一个分块平均法来估计 $g(r)$ 箱格值和扩散系数 $D$ 的不确定度。\n\n**步骤2：使用已知条件进行验证**\n\n-   **科学基础：** 该问题稳固地建立在计算化学和计算物理的标准实践之上。使用自相关函数、分块平均、RDF 和 MSD 等统计工具分析 MD 模拟中的时间相关数据是一个基础课题。给定的参数（$\\Delta t = 10\\,\\mathrm{fs}$，$T = 20\\,\\mathrm{ns}$，$\\tau_c \\approx 5\\,\\mathrm{ps}$）对于水溶液模拟是物理上现实的。所引用的基本原理（遍历性、相关变量的中心极限定理）是统计力学的基石。该问题在科学上是合理的。\n-   **适定性：** 问题提出了一个清晰且可回答的问题。它要求找到估计时间相关数据统计不确定度的正确程序，这是时间序列分析中一个有既定解决方案的明确定义的问题。\n-   **客观性：** 语言技术性强且精确，没有主观或模糊的术语。\n-   **一致性与完备性：** 所提供的信息是自洽的，足以制定出正确的统计程序。明确指出了存在显著的相关性（$\\tau_c \\approx 5\\,\\mathrm{ps} \\gg \\Delta t = 0.01\\,\\mathrm{ps}$），这使得问题的核心部分不容忽视。没有矛盾之处。\n\n**步骤3：结论与行动**\n\n问题陈述是**有效的**。它在科学上合理、适定，并为评估所提出的程序提供了清晰的基础。现在进入解答阶段。\n\n### 推导与选项分析\n\n**1. 时间平均中不确定度的基本原理**\n\n可观测量 $A$ 在 $N$ 个离散时间步长的模拟中的时间平均由 $\\bar{A} = \\frac{1}{N} \\sum_{k=1}^N A_k$ 给出。均值方差的标准公式 $\\mathrm{Var}(\\bar{A}) = \\mathrm{Var}(A)/N$ 仅在样本 $A_k$ 是独立同分布（i.i.d.）时有效。在 MD 模拟中，连续的构型是相关的，因此样本 $A_k$ 不是独立的。\n\n对于平稳、相关的时间序列，其均值方差的正确表达式为：\n$$ \\mathrm{Var}(\\bar{A}) = \\frac{\\mathrm{Var}(A)}{N} \\left[ 1 + 2 \\sum_{k=1}^{N-1} \\left(1-\\frac{k}{N}\\right) \\rho_A(k\\Delta t) \\right] $$\n其中 $\\rho_A(k\\Delta t)$ 是延迟 $k$ 个时间步长时的归一化自相关函数。\n\n对于 $N \\gg 1$ 且相关性衰减足够快的长轨迹，这可以近似为：\n$$ \\mathrm{Var}(\\bar{A}) \\approx \\frac{\\mathrm{Var}(A)}{N} \\left[ 1 + 2 \\sum_{k=1}^{\\infty} \\rho_A(k\\Delta t) \\right] $$\n方括号中的项是*统计效率因子*（statistical inefficiency），$s$。我们可以定义一个*有效独立样本数*，$N_{\\mathrm{eff}} = N/s$。均值的方差可以简洁地写成 $\\mathrm{Var}(\\bar{A}) \\approx \\mathrm{Var}(A)/N_{\\mathrm{eff}}$。\n\n*积分自相关时间* $\\tau_{\\mathrm{int}}$ 是一个衡量相关性持续性的连续时间度量：\n$$ \\tau_{\\mathrm{int}} = \\int_0^\\infty \\rho_A(t) dt $$\n对于给定的指数衰减 $\\rho_A(t) \\approx \\exp(-t/\\tau_c)$，该积分的计算结果为 $\\tau_{\\mathrm{int}} \\approx \\tau_c = 5\\,\\mathrm{ps}$。统计效率因子可与 $\\tau_{\\mathrm{int}}$ 相关联：$s \\approx 2\\tau_{\\mathrm{int}}/\\Delta t$。\n\n在这个问题中，$s \\approx 2 \\times (5\\,\\mathrm{ps}) / (0.01\\,\\mathrm{ps}) = 1000$。这意味着假设 $s=1$ 的朴素标准误计算会低估真实统计误差约 $\\sqrt{s} \\approx \\sqrt{1000} \\approx 31.6$ 倍。\n\n**2. 分块平均法**\n\n直接计算 $\\tau_{\\mathrm{int}}$（以及 $s$）在统计上可能存在较大噪音。一种更稳健且被广泛接受的方法是**分块平均法**。\n1.  将总长度为 $T$ 的轨迹划分为 $M$ 个非重叠的块，每个块的长度为 $L = T/M$。\n2.  计算每个块中可观测量的平均值，得到一组块均值 $\\{\\bar{A}^{(1)}, \\bar{A}^{(2)}, \\dots, \\bar{A}^{(M)}\\}$。\n3.  关键在于，块长度 $L$ 的选择必须远大于积分自相关时间，即 $L \\gg \\tau_{\\mathrm{int}}$。这确保了连续块之间的相关性可以忽略不计，从而使块均值 $\\{\\bar{A}^{(m)}\\}$ 近似为独立同分布（i.i.d.）的随机变量。\n4.  由于块均值现在实际上是独立的，标准的统计公式可以应用于它们。总体均值为 $\\bar{A} = \\frac{1}{M} \\sum_{m=1}^M \\bar{A}^{(m)}$。\n5.  块均值方差的无偏估计为 $\\hat{\\sigma}_{\\bar{A}^{(m)}}^2 = \\frac{1}{M-1} \\sum_{m=1}^M (\\bar{A}^{(m)} - \\bar{A})^2$。\n6.  总体均值的方差则估计为 $\\widehat{\\mathrm{Var}}(\\bar{A}) = \\frac{\\hat{\\sigma}_{\\bar{A}^{(m)}}^2}{M}$。标准误是该值的平方根。\n7.  为确保 $L$ 足够大，应该对几个递增的 $L$ 值计算估计误差。对于较小的 $L$（此时块均值仍然相关），误差估计值会错误地偏小；随着 $L$ 的增加，一旦 $L \\gg \\tau_{\\mathrm{int}}$，误差估计值将增大并达到一个恒定的平台值。这个平台值就是正确的不确定度估计。\n\n该程序直接适用于 $g(r)$ 箱格值。对于从 MSD 斜率导出的扩散系数 $D$，也采用相同的原理：\n1.  将轨迹划分为 $M$ 个长度为 $L \\gg \\tau_D$ 的块，其中 $\\tau_D$ 是与扩散相关的相关时间。\n2.  对于每个块 $m$，通过计算该块内的 MSD 并求其斜率，来独立地估计扩散系数 $D^{(m)}$。MSD 拟合必须使用远小于块长度 $L$（以保证 MSD 本身有良好的统计性）但又足够大以处于菲克（线性）扩散区的延迟时间 $\\tau$。\n3.  将集合 $\\{D^{(1)}, D^{(2)}, \\dots, D^{(M)}\\}$ 视为 i.i.d. 样本，并如上所述计算均值和标准误。\n\n**3. 选项评估**\n\n**选项 A：** 该选项建议将所有 $N = T/\\Delta t = 2 \\times 10^6$ 帧都视为独立的。这从根本上是错误的，因为它忽略了强时间相关性（$\\tau_c / \\Delta t = 500$），导致对真实不确定度的严重低估。对 MSD 分析的理由也是不正确的；对时间原点进行平均可以改善 MSD 曲线的统计性，但并不能消除不同延迟时间的 MSD 点之间的相关性，这使得标准的线性回归误差估计无效。\n**结论：****错误**。\n\n**选项 B：** 该选项精确地描述了正确的分块平均法。\n-   它正确地指出了条件 $L \\gg \\tau_{\\mathrm{int}}$（建议 $L \\approx 100\\,\\mathrm{ps}$，这是给定 $\\tau_c \\approx 5\\,\\mathrm{ps}$ 的20倍）。\n-   它正确地概述了划分为非重叠块、计算块均值，然后使用适当的 $M-1$ 分母从块均值的样本方差计算总体均值方差的过程。\n-   它包括了随着 $L$ 增加检查估计误差是否达到平台期的关键步骤。\n-   它通过计算逐块估计值 $D^{(m)}$ 并执行相同的统计分析，正确地将该程序应用于扩散系数 $D$。\n**结论：****正确**。\n\n**选项 C：** 该选项建议使用长度为 $L \\approx \\tau_c$ 的重叠块。这个块长度太短；块均值将仍然相关，误差会被低估。虽然存在处理重叠块的方法，但它们比简单地将块均值视为独立要复杂得多。使用重叠块的数量作为自由度是一种不正确的简化。\n**结论：****错误**。\n\n**选项 D：** 该选项做出了一个明显错误的声明，即 $N_{\\mathrm{eff}} = N$ 并且相关性可以忽略。认为有界性意味着弱相关性的推理是谬误的。对于扩散系数，它建议通过重采样单个时间点来进行标准的自助法（bootstrap）。对于相关的时间序列，这是不正确的，因为它破坏了时间相关结构。正确的方法应该是*分块自助法*（block bootstrap），这是选项 B 中分块平均法的重采样类似方法。\n**结论：****错误**。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}