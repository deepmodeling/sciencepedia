{
    "hands_on_practices": [
        {
            "introduction": "真实含水层的属性，如水力传导率 $K(\\mathbf{x})$，通常表现出方向依赖性，例如沿着沉积层方向的渗透性可能更高。本练习将引导您探索几何各向异性的概念，学习如何通过变异函数来量化这种空间结构的定向差异。通过将相关的物理参数（如主次方向上的相关长度和旋转角度）转化为地质统计学模型中核心的数学形式，您将掌握描述和建模复杂非均质场的关键技能。",
            "id": "4100369",
            "problem": "考虑一个二维 (2D) 二阶平稳随机场 $Z(\\mathbf{x})$，它代表了一个含水层的对数水力传导系数，其均值为零，协方差仅通过一个线性映射的欧几里得范数 $\\|\\mathbf{A}\\mathbf{h}\\|$ 依赖于一个变换后的滞后向量 $\\mathbf{h} \\in \\mathbb{R}^{2}$，其中 $\\mathbf{A}$ 是一个固定的、可逆的 $2 \\times 2$ 矩阵，用于编码几何各向异性。半变异函数定义为 $\\gamma(\\mathbf{h}) = \\frac{1}{2}\\,\\mathbb{E}\\!\\left[(Z(\\mathbf{x}+\\mathbf{h}) - Z(\\mathbf{x}))^{2}\\right]$，对于二阶平稳性，协方差 $C(\\mathbf{h}) = \\mathbb{E}\\!\\left[Z(\\mathbf{x})Z(\\mathbf{x}+\\mathbf{h})\\right]$ 仅依赖于 $\\mathbf{h}$。假设在变换空间中采用带块金效应的指数协方差模型，因此半变异函数的形式为\n$$\n\\gamma(\\mathbf{h}) = c_{n} + c_{s}\\left(1 - \\exp\\!\\left(-\\|\\mathbf{A}\\mathbf{h}\\|\\right)\\right),\n$$\n其中 $c_{n} > 0$ 是块金方差，$c_{s} > 0$ 是结构方差。\n\n设各向异性由两个主相关长度 $L_{1}$（长轴）和 $L_{2}$（短轴），以及从全局坐标轴到主轴的一个旋转角 $\\theta$（以度为单位）来表征。从主轴坐标系中无量纲变换距离为\n$$\nr^{2} = \\left(\\frac{y_{1}}{L_{1}}\\right)^{2} + \\left(\\frac{y_{2}}{L_{2}}\\right)^{2},\n$$\n的要求出发，其中 $\\mathbf{y} = \\mathbf{R}^{\\top}\\mathbf{h}$ 且 $\\mathbf{R}$ 是对应于角度 $\\theta$ 的 $2 \\times 2$ 旋转矩阵，推导出一个典范矩阵 $\\mathbf{A}$，使得对所有 $\\mathbf{h}$ 都有 $\\|\\mathbf{A}\\mathbf{h}\\| = r$。然后，使用推导出的形式，计算在给定物理滞后大小 $h_{0}$ 下，沿主方向的半变异函数值，即 $\\mathbf{h}_{\\text{maj}}$ 与主长轴对齐时的 $\\gamma_{\\text{maj}} = \\gamma(\\mathbf{h}_{\\text{maj}})$，以及 $\\mathbf{h}_{\\text{min}}$ 与主短轴对齐时的 $\\gamma_{\\text{min}} = \\gamma(\\mathbf{h}_{\\text{min}})$，参数如下：\n- $L_{1} = 150\\,\\mathrm{m}$，\n- $L_{2} = 60\\,\\mathrm{m}$，\n- $\\theta = 35^{\\circ}$，\n- $c_{n} = 0.02$，\n- $c_{s} = 0.28$，\n- $h_{0} = 50\\,\\mathrm{m}$。\n\n将无量纲比率\n$$\n\\frac{\\gamma_{\\text{maj}}}{\\gamma_{\\text{min}}}\n$$\n作为最终答案报告，四舍五入到四位有效数字。最终答案以无单位的纯数形式表示。",
            "solution": "该问题要求推导表征几何各向异性的矩阵 $\\mathbf{A}$，然后用它来计算给定滞后距离下沿主轴的半变异函数值的比率。\n\n首先，我们建立全局坐标系（用于滞后向量 $\\mathbf{h}$）和主轴坐标系（用于向量 $\\mathbf{y}$）之间的关系。该变换由 $\\mathbf{y} = \\mathbf{R}^{\\top}\\mathbf{h}$ 给出，其中 $\\mathbf{R}$ 是角度 $\\theta$ 的旋转矩阵。\n对应于逆时针旋转角度 $\\theta$ 的旋转矩阵 $\\mathbf{R}$ 是：\n$$\n\\mathbf{R} = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix}\n$$\n它的转置将坐标从全局坐标系变换到旋转后的坐标系，其形式为：\n$$\n\\mathbf{R}^{\\top} = \\begin{pmatrix} \\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta \\end{pmatrix}\n$$\n\n问题陈述，在主轴坐标系中，无量纲变换距离的平方 $r^2$ 由下式给出：\n$$\nr^2 = \\left(\\frac{y_1}{L_1}\\right)^2 + \\left(\\frac{y_2}{L_2}\\right)^2\n$$\n其中 $y_1$ 和 $y_2$ 是向量 $\\mathbf{y} = \\begin{pmatrix} y_1 \\\\ y_2 \\end{pmatrix}$ 的分量。这个表达式可以写成矩阵形式。让我们定义一个对角缩放矩阵 $\\mathbf{S}$ 为：\n$$\n\\mathbf{S} = \\begin{pmatrix} \\frac{1}{L_1}  0 \\\\ 0  \\frac{1}{L_2} \\end{pmatrix}\n$$\n那么，$r^2$ 可以表示为向量 $\\mathbf{S}\\mathbf{y}$ 的欧几里得范数的平方：\n$$\nr^2 = \\mathbf{y}^{\\top}\\mathbf{S}^{\\top}\\mathbf{S}\\mathbf{y} = (\\mathbf{S}\\mathbf{y})^{\\top}(\\mathbf{S}\\mathbf{y}) = \\|\\mathbf{S}\\mathbf{y}\\|^2\n$$\n由于缩放矩阵 $\\mathbf{S}$ 是对角的，所以 $\\mathbf{S}^{\\top} = \\mathbf{S}$。\n\n我们需要找到一个矩阵 $\\mathbf{A}$ 使得 $r = \\|\\mathbf{A}\\mathbf{h}\\|$。我们可以将 $\\mathbf{y} = \\mathbf{R}^{\\top}\\mathbf{h}$ 代入 $r$ 的表达式中：\n$$\nr = \\|\\mathbf{S}\\mathbf{y}\\| = \\|\\mathbf{S}(\\mathbf{R}^{\\top}\\mathbf{h})\\| = \\|(\\mathbf{S}\\mathbf{R}^{\\top})\\mathbf{h}\\|\n$$\n通过与 $r = \\|\\mathbf{A}\\mathbf{h}\\|$ 进行比较，我们可以确定典范矩阵 $\\mathbf{A}$ 为：\n$$\n\\mathbf{A} = \\mathbf{S}\\mathbf{R}^{\\top} = \\begin{pmatrix} \\frac{1}{L_1}  0 \\\\ 0  \\frac{1}{L_2} \\end{pmatrix} \\begin{pmatrix} \\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta \\end{pmatrix} = \\begin{pmatrix} \\frac{\\cos\\theta}{L_1}  \\frac{\\sin\\theta}{L_1} \\\\ -\\frac{\\sin\\theta}{L_2}  \\frac{\\cos\\theta}{L_2} \\end{pmatrix}\n$$\n这就完成了矩阵 $\\mathbf{A}$ 的推导。\n\n接下来，我们需要计算沿各向异性的主长轴和主短轴，滞后大小为 $h_0$ 时的半变异函数值 $\\gamma_{\\text{maj}}$ 和 $\\gamma_{\\text{min}}$。半变异函数模型为：\n$$\n\\gamma(\\mathbf{h}) = c_{n} + c_{s}\\left(1 - \\exp(-\\|\\mathbf{A}\\mathbf{h}\\|)\\right)\n$$\n主长轴对应于最大相关长度 $L_1$ 的方向。在主轴坐标系（$\\mathbf{y}$ 坐标）中，这是 $y_1$ 轴。沿该轴长度为 $h_0$ 的向量是 $\\mathbf{y}_{\\text{maj}}' = \\begin{pmatrix} h_0 \\\\ 0 \\end{pmatrix}$。\n主短轴对应于最小相关长度 $L_2$ 的方向。在 $\\mathbf{y}$ 坐标系中，这是 $y_2$ 轴。沿该轴长度为 $h_0$ 的向量是 $\\mathbf{y}_{\\text{min}}' = \\begin{pmatrix} 0 \\\\ h_0 \\end{pmatrix}$。\n\n为了在全局坐标系中找到对应的滞后向量 $\\mathbf{h}_{\\text{maj}}$ 和 $\\mathbf{h}_{\\text{min}}$，我们使用逆变换 $\\mathbf{h} = \\mathbf{R}\\mathbf{y}$。\n对于主长轴：\n$$\n\\mathbf{h}_{\\text{maj}} = \\mathbf{R}\\mathbf{y}_{\\text{maj}}' = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix} \\begin{pmatrix} h_0 \\\\ 0 \\end{pmatrix} = h_0 \\begin{pmatrix} \\cos\\theta \\\\ \\sin\\theta \\end{pmatrix}\n$$\n对于主短轴：\n$$\n\\mathbf{h}_{\\text{min}} = \\mathbf{R}\\mathbf{y}_{\\text{min}}' = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix} \\begin{pmatrix} 0 \\\\ h_0 \\end{pmatrix} = h_0 \\begin{pmatrix} -\\sin\\theta \\\\ \\cos\\theta \\end{pmatrix}\n$$\n现在我们计算这两个滞后向量的变换距离 $\\|\\mathbf{A}\\mathbf{h}\\|$。\n对于 $\\mathbf{h}_{\\text{maj}}$：\n$$\n\\|\\mathbf{A}\\mathbf{h}_{\\text{maj}}\\| = r_{\\text{maj}}\n$$\n我们知道 $r^2 = (\\frac{y_1}{L_1})^2 + (\\frac{y_2}{L_2})^2$ 且 $\\mathbf{y} = \\mathbf{R}^{\\top}\\mathbf{h}$。对于 $\\mathbf{h}_{\\text{maj}}$，对应的 $\\mathbf{y}$ 向量是 $\\mathbf{y}_{\\text{maj}} = \\mathbf{R}^{\\top}\\mathbf{h}_{\\text{maj}} = \\mathbf{R}^{\\top}(\\mathbf{R}\\mathbf{y}_{\\text{maj}}') = (\\mathbf{R}^{\\top}\\mathbf{R})\\mathbf{y}_{\\text{maj}}' = \\mathbf{I}\\mathbf{y}_{\\text{maj}}' = \\mathbf{y}_{\\text{maj}}' = \\begin{pmatrix} h_0 \\\\ 0 \\end{pmatrix}$。\n所以，$y_1 = h_0$ 且 $y_2 = 0$。变换距离是：\n$$\n\\|\\mathbf{A}\\mathbf{h}_{\\text{maj}}\\| = \\sqrt{\\left(\\frac{h_0}{L_1}\\right)^2 + \\left(\\frac{0}{L_2}\\right)^2} = \\frac{h_0}{L_1}\n$$\n对于 $\\mathbf{h}_{\\text{min}}$：\n对应的 $\\mathbf{y}$ 向量是 $\\mathbf{y}_{\\text{min}} = \\mathbf{R}^{\\top}\\mathbf{h}_{\\text{min}} = \\mathbf{y}_{\\text{min}}' = \\begin{pmatrix} 0 \\\\ h_0 \\end{pmatrix}$。\n所以，$y_1 = 0$ 且 $y_2 = h_0$。变换距离是：\n$$\n\\|\\mathbf{A}\\mathbf{h}_{\\text{min}}\\| = \\sqrt{\\left(\\frac{0}{L_1}\\right)^2 + \\left(\\frac{h_0}{L_2}\\right)^2} = \\frac{h_0}{L_2}\n$$\n因此，沿主方向的半变异函数值为：\n$$\n\\gamma_{\\text{maj}} = c_n + c_s\\left(1 - \\exp\\left(-\\frac{h_0}{L_1}\\right)\\right)\n$$\n$$\n\\gamma_{\\text{min}} = c_n + c_s\\left(1 - \\exp\\left(-\\frac{h_0}{L_2}\\right)\\right)\n$$\n注意，旋转角 $\\theta$ 没有出现在这些最终表达式中，因为计算是沿着主轴本身进行的。\n\n现在，我们代入给定的参数值：\n$L_1 = 150\\,\\mathrm{m}$，$L_2 = 60\\,\\mathrm{m}$，$h_0 = 50\\,\\mathrm{m}$，$c_n = 0.02$，$c_s = 0.28$。\n指数的无量纲比率为：\n$$\n\\frac{h_0}{L_1} = \\frac{50}{150} = \\frac{1}{3}\n$$\n$$\n\\frac{h_0}{L_2} = \\frac{50}{60} = \\frac{5}{6}\n$$\n将这些值代入 $\\gamma_{\\text{maj}}$ 和 $\\gamma_{\\text{min}}$ 的表达式中：\n$$\n\\gamma_{\\text{maj}} = 0.02 + 0.28\\left(1 - \\exp\\left(-\\frac{1}{3}\\right)\\right)\n$$\n$$\n\\gamma_{\\text{min}} = 0.02 + 0.28\\left(1 - \\exp\\left(-\\frac{5}{6}\\right)\\right)\n$$\n我们计算其数值：\n$$\n\\exp\\left(-\\frac{1}{3}\\right) \\approx 0.7165313\n$$\n$$\n\\exp\\left(-\\frac{5}{6}\\right) \\approx 0.4345982\n$$\n因此，\n$$\n\\gamma_{\\text{maj}} \\approx 0.02 + 0.28(1 - 0.7165313) = 0.02 + 0.28(0.2834687) \\approx 0.02 + 0.0793712 \\approx 0.0993712\n$$\n$$\n\\gamma_{\\text{min}} \\approx 0.02 + 0.28(1 - 0.4345982) = 0.02 + 0.28(0.5654018) \\approx 0.02 + 0.1583125 \\approx 0.1783125\n$$\n最后，我们计算所求的比率：\n$$\n\\frac{\\gamma_{\\text{maj}}}{\\gamma_{\\text{min}}} \\approx \\frac{0.0993712}{0.1783125} \\approx 0.557285\n$$\n四舍五入到四位有效数字，结果是 $0.5573$。",
            "answer": "$$\n\\boxed{0.5573}\n$$"
        },
        {
            "introduction": "为了在计算机上进行模拟，我们需要一种方法将连续的随机场（如对数水力传导率场 $Y(\\mathbf{x})$）用有限数量的变量来表示。Karhunen-Loève (KL) 展开为此提供了最优的解决方案，它将复杂的随机场分解为一系列确定的空间模式（特征函数）和互不相关的随机系数。通过这个编程实践，您将亲手实现这一强大的降维技术，并通过数值诊断来验证离散化和截断的准确性，这是进行高效不确定性量化的基础。",
            "id": "4100373",
            "problem": "考虑一个实值二阶平稳高斯随机场 $Y(\\mathbf{x})$，它表示在一维有界域 $D = [0,L]$（无单位）上的对数水力传导率。其协方差是各向同性的，由函数 $C(\\mathbf{h}) = \\sigma^2 \\exp(-\\lVert \\mathbf{h} \\rVert/\\ell)$ 给出，其中 $\\sigma^2$ 是方差，$\\ell$ 是相关长度。Karhunen–Loève 展开利用协方差积分算子的特征对，在域 $D$ 上提供了 $Y(\\mathbf{x})$ 的一个正交表示。您的任务是使用协方差算子的一致对称离散化来构建一个有限维近似，并计算可量化的诊断指标以验证该离散化和截断。\n\n从二阶平稳高斯随机场的定义、协方差函数的定义以及有界域上协方差积分算子的 Karhunen–Loève 特征问题的刻画这些基本概念出发，推导一个基于求积的数值格式来近似该算子的特征对。使用 $D$ 上的 $N$ 个点的均匀网格和复合梯形法则，构造协方差积分算子的一个对称正定矩阵近似，从而得到一个良定的实对称特征值问题。然后，使用前 $M$ 个特征对来定义有限维 Karhunen–Loève 截断。\n\n您的程序必须：\n- 在 $[0,L]$ 上构建一个均匀网格 $\\{x_i\\}_{i=0}^{N-1}$，其间距为 $\\Delta x = L/(N-1)$，并构建复合梯形求积权重 $\\{w_i\\}_{i=0}^{N-1}$，其中 $w_0 = w_{N-1} = \\Delta x/2$，对于内部点则为 $w_i = \\Delta x$。\n- 使用指定的 $C(\\mathbf{h})$ 函数，组装协方差核矩阵，其元素为 $K_{ij} = C(|x_i - x_j|)$。\n- 使用求积权重推导并实现协方差积分算子的一个对称矩阵近似，该近似导出一个实对称特征值问题，其特征值近似于连续算子的特征值，其特征向量近似于网格上的特征函数。\n- 计算所有特征值并按降序排序。令 $\\{\\lambda_k\\}_{k=1}^{N}$ 表示这些特征值。\n- 对于给定的截断水平 $M \\le N$，计算捕获方差比 $R_M = \\left(\\sum_{k=1}^{M} \\lambda_k\\right)\\Big/\\left(\\sum_{k=1}^{N} \\lambda_k\\right)$。\n- 通过计算相对迹误差 $E = \\left|\\left(\\sum_{k=1}^{N} \\lambda_k\\right) - \\sigma^2 L\\right|/(\\sigma^2 L)$ 来验证协方差算子离散化的迹性质。\n\n您的程序必须实现上述步骤，并为以下 $(L, N, \\sigma^2, \\ell, M)$ 参数集（所有量均为无量纲）的测试套件生成结果：\n- 测试用例 A (一般情况): $(L, N, \\sigma^2, \\ell, M) = (1, 60, 1, 0.2, 10)$。\n- 测试用例 B (短相关长度): $(L, N, \\sigma^2, \\ell, M) = (1, 60, 1, 0.05, 10)$。\n- 测试用例 C (长相关长度): $(L, N, \\sigma^2, \\ell, M) = (1, 60, 1, 0.5, 10)$。\n- 测试用例 D (边界截断): $(L, N, \\sigma^2, \\ell, M) = (1, 60, 1, 0.2, 60)$。\n\n对于每个测试用例，您的程序必须输出数对 $[R_M, E]$，其中 $R_M$ 是捕获方差比，$E$ 是相对迹误差。$R_M$ 和 $E$ 都必须四舍五入到 6 位小数。\n\n最终输出格式：\n- 您的程序必须打印单行，其中包含按 A、B、C、D 顺序排列的四个测试用例的结果列表。\n- 每个结果都必须是一个包含两个浮点数 $[R_M, E]$ 的列表，且均四舍五入到 6 位小数。\n- 最终打印的行必须严格为单个列表的列表，例如 $[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]]$，不含任何额外文本。\n\n不允许任何外部输入，也不得读取或写入任何外部文件。不涉及角度。不涉及物理单位；所有量均为无量纲。",
            "solution": "该问题要求对一维域 $D = [0,L]$ 上的二阶平稳高斯随机场 $Y(\\mathbf{x})$ 的 Karhunen-Loève (KL) 展开进行数值近似。此任务的科学基础在于积分算子的谱理论。\n\nKL 展开将一个随机过程表示为一系列正交函数（即该过程协方差算子的特征函数）的无穷级数。级数中的系数是不相关的随机变量。对于一个零均值、协方差函数为 $C(\\mathbf{x}, \\mathbf{x'})$ 的随机场 $Y(\\mathbf{x})$，其特征函数 $\\phi_k(\\mathbf{x})$ 和对应的特征值 $\\lambda_k$ 是第二类 Fredholm 积分方程的解：\n$$\n\\int_D C(\\mathbf{x}, \\mathbf{x'}) \\phi_k(\\mathbf{x'}) d\\mathbf{x'} = \\lambda_k \\phi_k(\\mathbf{x})\n$$\n问题指定了一个一维域 $D=[0,L]$ 和一个平稳、各向同性的协方差函数 $C(\\mathbf{h}) = \\sigma^2 \\exp(-\\lVert \\mathbf{h} \\rVert/\\ell)$，其中 $\\mathbf{h} = x - x'$ 是分离向量。因此，$C(x, x') = \\sigma^2 \\exp(-|x - x'|/\\ell)$。\n\n为了数值求解此积分方程，我们对域和积分算子进行离散化。\n首先，我们在区间 $[0,L]$ 上建立一个包含 $N$ 个点的均匀网格 $\\{x_i\\}_{i=0}^{N-1}$，其中 $x_i = i \\cdot \\Delta x$，网格间距为 $\\Delta x = L/(N-1)$。\n该积分使用求积法则进行近似。问题指定了复合梯形法则。函数 $f(x')$ 在 $[0,L]$ 上的积分近似为：\n$$\n\\int_0^L f(x') dx' \\approx \\sum_{j=0}^{N-1} f(x_j) w_j\n$$\n其中 $\\{w_j\\}_{j=0}^{N-1}$ 是求积权重。对于梯形法则，这些权重为 $w_0 = w_{N-1} = \\Delta x/2$，对于 $j \\in \\{1, 2, \\dots, N-2\\}$ 则为 $w_j = \\Delta x$。\n\n将此求积法应用于每个网格点 $x_i$ 上的 KL 积分方程，可以得到一个线性方程组：\n$$\n\\sum_{j=0}^{N-1} C(x_i, x_j) w_j \\phi_k(x_j) \\approx \\lambda_k \\phi_k(x_i) \\quad \\text{for } i = 0, 1, \\dots, N-1\n$$\n让我们定义连续实体的离散对应物：\n- 协方差矩阵 $\\mathbf{K}$ 是一个 $N \\times N$ 的矩阵，其元素为 $K_{ij} = C(x_i, x_j) = \\sigma^2 \\exp(-|x_i - x_j|/\\ell)$。\n- 求积权重矩阵 $\\mathbf{W}$ 是一个对角矩阵，其元素为 $W_{jj} = w_j$。\n- 特征向量 $\\mathbf{v}_k$ 是一个长度为 $N$ 的列向量，其元素是特征函数在网格点上的值，即 $v_{k,i} = \\phi_k(x_i)$。\n\n根据这些定义，该方程组可以写成矩阵形式的广义特征值问题：\n$$\n\\mathbf{K W} \\mathbf{v}_k = \\lambda_k \\mathbf{v}_k\n$$\n其中 $\\lambda_k$ 现在表示近似特征值。矩阵 $\\mathbf{K}$ 是对称的，因为 $K_{ij} = C(|x_i - x_j|) = C(|x_j - x_i|) = K_{ji}$。然而，由于 $\\mathbf{W}$ 不是单位矩阵的倍数，矩阵乘积 $\\mathbf{K W}$ 通常是非对称的。求解非对称特征值问题在数值上可能不够稳定，并且可能产生复特征值，这对于一个已知的自伴算子来说是不理想的。\n\n问题陈述正确地要求推导出一个实对称特征值问题。这可以通过相似变换来实现。设 $\\mathbf{W}^{1/2}$ 是元素为 $\\sqrt{w_j}$ 的对角矩阵。我们定义一个新向量 $\\mathbf{u}_k = \\mathbf{W}^{1/2} \\mathbf{v}_k$，这意味着 $\\mathbf{v}_k = \\mathbf{W}^{-1/2} \\mathbf{u}_k$。将此代入广义特征值问题：\n$$\n\\mathbf{K W} (\\mathbf{W}^{-1/2} \\mathbf{u}_k) = \\lambda_k (\\mathbf{W}^{-1/2} \\mathbf{u}_k)\n$$\n从左侧乘以 $\\mathbf{W}^{1/2}$：\n$$\n\\mathbf{W}^{1/2} \\mathbf{K W}^{1/2} \\mathbf{u}_k = \\lambda_k \\mathbf{W}^{1/2} \\mathbf{W}^{-1/2} \\mathbf{u}_k\n$$\n这可以简化为一个标准的对称特征值问题：\n$$\n\\mathbf{A} \\mathbf{u}_k = \\lambda_k \\mathbf{u}_k\n$$\n其中矩阵 $\\mathbf{A} = \\mathbf{W}^{1/2} \\mathbf{K} \\mathbf{W}^{1/2}$ 是对称的。其元素为 $A_{ij} = \\sqrt{w_i} K_{ij} \\sqrt{w_j}$。这种表述保证了计算出的特征值 $\\{\\lambda_k\\}_{k=1}^N$ 是实数，并且我们可以使用为对称矩阵设计的高效数值求解器。\n\n求解过程是先构建该矩阵 $\\mathbf{A}$，然后求解其特征值。这些特征值近似于原始连续算子的特征值。为了验证，计算了两个诊断量：\n1. 截断为 $M$ 项的捕获方差比 $R_M$：\n$$\nR_M = \\frac{\\sum_{k=1}^{M} \\lambda_k}{\\sum_{k=1}^{N} \\lambda_k}\n$$\n该指标衡量了离散化场的总方差中，被前 $M$ 个 KL 模态所捕获的比例。\n2. 相对迹误差 $E$。协方差算子的一个基本性质是其迹等于域上的积分方差。对于平稳过程，$C(x,x) = C(0) = \\sigma^2$。\n$$\n\\text{Tr}(\\mathcal{C}) = \\int_0^L C(x,x) dx = \\int_0^L \\sigma^2 dx = \\sigma^2 L\n$$\n迹也是所有特征值的和，即 $\\sum_{k=1}^{\\infty} \\lambda_k$。我们的数值近似应保持此性质。离散化算子矩阵 $\\mathbf{A}$ 的迹为 $\\text{Tr}(\\mathbf{A}) = \\sum_{k=1}^N \\lambda_k$。利用迹的循环性质，$\\text{Tr}(\\mathbf{A}) = \\text{Tr}(\\mathbf{W}^{1/2} \\mathbf{K} \\mathbf{W}^{1/2}) = \\text{Tr}(\\mathbf{K W})$。$\\mathbf{KW}$ 的迹为 $\\sum_{i=0}^{N-1} (\\mathbf{KW})_{ii} = \\sum_{i=0}^{N-1} K_{ii} W_{ii} = \\sum_{i=0}^{N-1} \\sigma^2 w_i = \\sigma^2 \\sum_{i=0}^{N-1} w_i$。梯形权重之和恰好是区间的长度，即 $\\sum w_i = L$。因此，计算出的特征值之和理论上应等于 $\\sigma^2 L$。相对迹误差 $E$ 量化了由浮点运算引起的任何偏差：\n$$\nE = \\frac{\\left| \\left(\\sum_{k=1}^{N} \\lambda_k\\right) - \\sigma^2 L \\right|}{\\sigma^2 L}\n$$\n\n算法如下：\n1. 对于每个测试用例 $(L, N, \\sigma^2, \\ell, M)$，构建网格 $\\{x_i\\}$ 和梯形权重 $\\{w_i\\}$。\n2. 组装 $N \\times N$ 的协方差矩阵 $\\mathbf{K}$，其元素为 $K_{ij} = \\sigma^2 \\exp(-|x_i - x_j|/\\ell)$。\n3. 构建对称矩阵 $\\mathbf{A}$，其元素为 $A_{ij} = \\sqrt{w_i} K_{ij} \\sqrt{w_j}$。\n4. 计算 $\\mathbf{A}$ 的 $N$ 个实特征值并按降序排序。\n5. 使用排序后的特征值计算 $R_M$ 和 $E$。\n6. 将结果四舍五入到 6 位小数，并按要求格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed for this solution.\n\ndef solve():\n    \"\"\"\n    Computes diagnostics for the Karhunen–Loève expansion of a\n    Gaussian random field using quadrature-based discretization.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, N, sigma^2, l, M)\n        (1.0, 60, 1.0, 0.2, 10),      # Test case A (general case)\n        (1.0, 60, 1.0, 0.05, 10),     # Test case B (short correlation length)\n        (1.0, 60, 1.0, 0.5, 10),      # Test case C (long correlation length)\n        (1.0, 60, 1.0, 0.2, 60),      # Test case D (boundary truncation)\n    ]\n\n    results = []\n    for L, N, sigma_sq, ell, M in test_cases:\n        # Step 1: Construct grid and quadrature weights\n        # Create a uniform grid of N points on [0, L]\n        x = np.linspace(0, L, N)\n        delta_x = L / (N - 1)\n\n        # Create composite trapezoidal quadrature weights\n        w = np.full(N, delta_x)\n        w[0] = delta_x / 2.0\n        w[-1] = delta_x / 2.0\n\n        # Step 2: Assemble the covariance kernel matrix K\n        # K_ij = C(|x_i - x_j|) = sigma^2 * exp(-|x_i - x_j| / l)\n        # Create a matrix of pairwise distances |x_i - x_j|\n        dist_matrix = np.abs(np.subtract.outer(x, x))\n        K = sigma_sq * np.exp(-dist_matrix / ell)\n\n        # Step 3: Derive and implement the symmetric matrix approximation A\n        # A = W^(1/2) * K * W^(1/2)\n        # This can be implemented efficiently using broadcasting\n        w_sqrt = np.sqrt(w)\n        A = np.outer(w_sqrt, w_sqrt) * K\n\n        # Step 4: Compute all eigenvalues and sort them\n        # Use np.linalg.eigvalsh for symmetric matrices. It's faster and more stable,\n        # and returns only the real eigenvalues.\n        eigenvalues = np.linalg.eigvalsh(A)\n        # Sort eigenvalues in descending order\n        eigenvalues = np.sort(eigenvalues)[::-1]\n\n        # Step 5: Compute diagnostics\n        # Captured Variance Ratio R_M\n        # The sum of all eigenvalues is the total variance of the discretized field\n        total_variance_discrete = np.sum(eigenvalues)\n        # The sum of the first M eigenvalues is the captured variance\n        captured_variance = np.sum(eigenvalues[:M])\n        \n        # Guard against division by zero if total variance is zero (unlikely but safe)\n        if total_variance_discrete > 0:\n            R_M = captured_variance / total_variance_discrete\n        else:\n            R_M = 1.0 if M > 0 else 0.0\n\n        # Relative Trace Error E\n        # The theoretical trace of the continuous operator is sigma^2 * L\n        total_variance_continuous = sigma_sq * L\n        \n        # The trace of a matrix is the sum of its eigenvalues.\n        # This sum should ideally be equal to total_variance_continuous.\n        # The error E measures the deviation due to numerical precision.\n        if total_variance_continuous > 0:\n            E = np.abs(total_variance_discrete - total_variance_continuous) / total_variance_continuous\n        else:\n            E = np.abs(total_variance_discrete)\n\n        # Round results to 6 decimal places\n        R_M_rounded = round(R_M, 6)\n        E_rounded = round(E, 6)\n\n        results.append([R_M_rounded, E_rounded])\n    \n    # Final print statement in the exact required format.\n    # The format is a list of lists, e.g., [[val1, val2], [val3, val4]]\n    # str() on a list correctly formats it with brackets and commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "随机建模的最终目标通常是评估系统响应（如污染物浓度 $C$）的不确定性。这需要将输入参数（如非均质传导率场 $K(\\mathbf{x})$）的不确定性传播到模型输出中，这一过程称为不确定性量化。本综合性编程练习将带您走过一个完整的应用流程：从构建随机输入场到通过物理模型进行运移计算，最终通过比较不同蒙特卡洛采样策略（包括拉丁超立方和拟蒙特卡洛方法）的效率，来估计污染物浓度超标的概率。",
            "id": "4100352",
            "problem": "您的任务是设计并实现一个计算实验，以比较蒙特卡洛(MC)、拉丁超立方采样(LHS)和准蒙特卡洛(QMC)方法，用于估计非均质含水层中污染物浓度的超限概率，并经验性地量化它们的收敛速率。其背景是计算地球化学中的含水层非均质性随机建模，该建模基于地下水流和反应输运的第一性原理。\n\n使用以下基本原理：\n\n- 达西定律：比流量为 $q(x) = K(x)\\,i$，其中 $K(x)$ 是水力传导系数，$i$ 是水力梯度（无量纲）。孔隙水流速为 $v(x) = q(x)/n = K(x)\\,i/n$，其中 $n$ 是孔隙度（无量纲）。\n- 沿长度为 $L$ 的一维（$1$-dimensional）流线的传播时间为 $t = \\int_0^L \\frac{1}{v(x)}\\,dx = \\frac{n}{i}\\int_0^L \\frac{1}{K(x)}\\,dx$。\n- 沿流径溶解浓度的一阶衰减得出 $C_{\\text{obs}} = C_0\\,\\exp(-\\lambda\\,t)$，其中 $C_0$ 是源浓度，$\\lambda$ 是一阶衰减率。\n- 水力传导系数场的不确定性由对数水力传导系数 $Y(x) = \\log K(x)$ 表示，该系数被建模为具有平方指数协方差和在 $[0,L]$ 上截断的Karhunen–Loève展开的高斯随机场，并采用齐次Neumann边界条件。近似特征函数是余弦模态 $\\phi_j(x) = \\sqrt{2}\\cos\\left(\\frac{j\\pi x}{L}\\right)$，对于 $j=1,\\dots,m$，相应的模态方差衰减为 $\\lambda_j = \\sigma_Y^2\\exp\\left(-\\left(\\frac{j\\pi \\ell}{L}\\right)^2\\right)$，其中 $\\ell$ 是相关长度，$\\sigma_Y$ 是 $Y(x)$ 的标准差。对于 $m$ 个模态和独立的标准正态系数 $\\xi_j \\sim \\mathcal{N}(0,1)$，截断场为 $Y(x) = \\mu_Y + \\sum_{j=1}^m \\sqrt{\\lambda_j}\\,\\xi_j\\,\\phi_j(x)$。\n- 一阶衰减率是不确定的，并建模为对数正态分布，$\\lambda = \\exp(\\mu_\\lambda + \\sigma_\\lambda Z)$，其中 $Z\\sim\\mathcal{N}(0,1)$。\n\n您的程序必须：\n\n1. 对于每个测试用例，定义含水层参数，将 $[0,L]$ 离散化为 $G$ 个等距点，并使用梯形法则来近似 $t = \\frac{n}{i}\\int_0^L \\frac{1}{K(x)}\\,dx$。计算 $C_{\\text{obs}} = C_0\\,\\exp(-\\lambda\\,t)$ 以及超限事件 $C_{\\text{obs}} > C_{\\text{thr}}$。\n2. 为随机变量 $(\\xi_1,\\dots,\\xi_m,Z)$ 实现三种采样策略：\n   - 蒙特卡洛(MC)：对每个分量从标准正态分布中进行独立抽样。\n   - 拉丁超立方采样(LHS)：在 $[0,1]^d$ 上进行拉丁超立方采样，其中 $d=m+1$，然后通过标准正态累积分布函数(CDF)的反函数映射以获得 $(\\xi_1,\\dots,\\xi_m,Z)$。\n   - 准蒙特卡洛(QMC)：在 $[0,1]^d$ 上使用带加扰的Sobol序列，然后通过标准正态CDF的反函数映射以获得 $(\\xi_1,\\dots,\\xi_m,Z)$。\n   在应用标准正态CDF的反函数之前，将均匀分布的值裁剪到 $(\\varepsilon,1-\\varepsilon)$（其中 $\\varepsilon=10^{-12}$）以避免无穷大。\n3. 对于每种方法和每个样本量 $N$（在指定的集合中），通过指示函数的样本均值来估计超限概率 $p = \\mathbb{P}(C_{\\text{obs}} > C_{\\text{thr}})$。\n4. 对于每个测试用例，使用标准蒙特卡洛法和 $N_{\\text{ref}}$ 个样本计算一个高精度参考概率 $p_{\\text{ref}}$。\n5. 对于每种方法，在每个 $N$ 处计算绝对误差 $e_N = |p_N - p_{\\text{ref}}|$，并对所提供的样本量范围内的 $\\log(e_N)$ 与 $\\log(N)$ 进行线性回归，以估计经验收敛率指数 $\\alpha$，其定义为 $e_N \\approx c\\,N^{-\\alpha}$，因此 $\\alpha = -\\frac{d\\,\\log(e_N)}{d\\,\\log(N)}$。将 $\\alpha$ 报告为正数。\n\n物理单位和数值处理：\n\n- 使用 $L$ 单位为米（$\\mathrm{m}$），$K$ 单位为米/天（$\\mathrm{m/day}$），$t$ 单位为天（$\\mathrm{day}$），$\\lambda$ 单位为天倒数（$\\mathrm{day}^{-1}$），浓度单位为毫克/升（$\\mathrm{mg/L}$）。虽然中间量带有单位，但最终输出是概率和收敛指数，它们是无量纲的。\n- 使用梯形法则对 $[0,L]$ 上的 $\\frac{1}{K(x)}$ 进行数值积分。\n- 使用下面指定的固定种子以保证可复现性。\n\n测试套件：\n\n对于每个用例，请严格按照所提供的参数和样本量进行。\n\n- 用例 1：\n  - $L = 100\\,\\mathrm{m}$, $n = 0.30$, $i = 0.01$, $C_0 = 100\\,\\mathrm{mg/L}$, $C_{\\text{thr}} = 10\\,\\mathrm{mg/L}$,\n  - $\\ell = 20\\,\\mathrm{m}$, $\\mu_Y = \\log(10)$, $\\sigma_Y = 0.5$, $m = 5$, $G = 200$,\n  - $\\mu_\\lambda = \\log(0.05\\,\\mathrm{day}^{-1})$, $\\sigma_\\lambda = 0.3$,\n  - 样本量 $N \\in \\{64,256,1024\\}$，参考样本量 $N_{\\text{ref}} = 20000$,\n  - 种子：MC $= 12345$, LHS $= 23456$, QMC $= 34567$。\n\n- 用例 2：\n  - $L = 200\\,\\mathrm{m}$, $n = 0.35$, $i = 0.005$, $C_0 = 50\\,\\mathrm{mg/L}$, $C_{\\text{thr}} = 5\\,\\mathrm{mg/L}$,\n  - $\\ell = 50\\,\\mathrm{m}$, $\\mu_Y = \\log(5)$, $\\sigma_Y = 0.8$, $m = 7$, $G = 300$,\n  - $\\mu_\\lambda = \\log(0.02\\,\\mathrm{day}^{-1})$, $\\sigma_\\lambda = 0.5$,\n  - 样本量 $N \\in \\{64,256,1024\\}$，参考样本量 $N_{\\text{ref}} = 20000$,\n  - 种子：MC $= 12346$, LHS $= 23457$, QMC $= 34568$。\n\n- 用例 3：\n  - $L = 50\\,\\mathrm{m}$, $n = 0.25$, $i = 0.02$, $C_0 = 30\\,\\mathrm{mg/L}$, $C_{\\text{thr}} = 25\\,\\mathrm{mg/L}$,\n  - $\\ell = 5\\,\\mathrm{m}$, $\\mu_Y = \\log(15)$, $\\sigma_Y = 0.4$, $m = 4$, $G = 150$,\n  - $\\mu_\\lambda = \\log(0.1\\,\\mathrm{day}^{-1})$, $\\sigma_\\lambda = 0.2$,\n  - 样本量 $N \\in \\{64,256,1024\\}$，参考样本量 $N_{\\text{ref}} = 20000$,\n  - 种子：MC $= 12347$, LHS $= 23458$, QMC $= 34569$。\n\n最终输出格式规范：\n\n- 对于每个测试用例，按顺序生成一个包含9个浮点数的列表：$[p_{\\text{MC}}^{N_{\\max}}, p_{\\text{LHS}}^{N_{\\max}}, p_{\\text{QMC}}^{N_{\\max}}, e_{\\text{MC}}^{N_{\\max}}, e_{\\text{LHS}}^{N_{\\max}}, e_{\\text{QMC}}^{N_{\\max}}, \\alpha_{\\text{MC}}, \\alpha_{\\text{LHS}}, \\alpha_{\\text{QMC}}]$，其中 $N_{\\max}$ 是集合中最大的样本量（此处为1024），$e^{N_{\\max}}$ 是在 $N_{\\max}$ 时相对于 $p_{\\text{ref}}$ 的绝对误差，$\\alpha$ 是通过对三个 $N$ 值进行对数-对数回归得出的经验收敛指数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，其本身也是如上所述的列表。例如，打印的输出必须看起来像 `[[\\ldots],[\\ldots],[\\ldots]]`。",
            "solution": "该解决方案实现了一个计算实验，以比较蒙特卡洛(MC)、拉丁超立方采样(LHS)和准蒙特卡洛(QMC)方法在随机水文地质模型中进行不确定性量化的效率。总体设计包含一个主过程，该过程遍历每个已定义的测试用例。对于每个用例，它首先建立一个高精度参考解，然后评估每种采样方法的性能和收敛速率。该实现基于所提供的物理和数学原理。\n\n实验的核心是一个函数，它将一组随机输入变量确定性地映射到一个模型输出。随机输入是 $(\\xi_1, \\dots, \\xi_m, Z)$，它们是 $d=m+1$ 个独立的标准正态随机变量。输出是一个二元指示器，用于判断污染物浓度 $C_{\\text{obs}}$ 是否超过阈值 $C_{\\text{thr}}$。该模型的实现过程如下：\n\n首先，将一维空间域 $[0, L]$ 离散化为 $G$ 个等距点 $x_k$，其中 $k=0, \\dots, G-1$。在此网格上构建对数水力传导系数场 $Y(x) = \\mu_Y + \\sum_{j=1}^m \\sqrt{\\lambda_j}\\,\\xi_j\\,\\phi_j(x)$ 的Karhunen-Loève表示。为提高效率，模态方差（特征值）$\\lambda_j = \\sigma_Y^2\\exp\\left(-\\left(\\frac{j\\pi \\ell}{L}\\right)^2\\right)$ 和特征函数在网格点上的值 $\\phi_j(x_k) = \\sqrt{2}\\cos\\left(\\frac{j\\pi x_k}{L}\\right)$ 会被预先计算。对于随机向量 $(\\xi_1, \\dots, \\xi_m)$ 的给定实现，计算场 $Y(x_k)$。此操作被向量化以同时计算场的 $N$ 个实现，从而得到一个大小为 $N \\times G$ 的矩阵。\n\n其次，从对数水力传导系数场 $Y(x)$，通过 $K(x) = \\exp(Y(x))$ 得到水力传导系数场。平流传播时间 $t = \\frac{n}{i}\\int_0^L \\frac{1}{K(x)}\\,dx$ 按照规定使用梯形法则进行数值积分来计算。`numpy.trapz` 沿被积函数值矩阵 $\\frac{1}{K(x_k)}$（大小为 $N \\times G$）的空间维度应用，从而得到一个包含 $N$ 个传播时间的向量。\n\n第三，对于 $N$ 个实现中的每一个，使用其对数正态定义 $\\lambda = \\exp(\\mu_\\lambda + \\sigma_\\lambda Z)$ 计算不确定的一阶衰减率 $\\lambda$，其中 $Z$ 是输入随机向量的第 $(m+1)$ 个分量。\n\n最后，计算流径末端的观测浓度 $C_{\\text{obs}} = C_0\\,\\exp(-\\lambda\\,t)$，对 $N$ 个实现中的每一个都进行计算。模型输出是超限事件的指示器，如果 $C_{\\text{obs}} > C_{\\text{thr}}$ 则为1，否则为0。\n\n为驱动此模型，实现了三种采样策略来生成 $d$ 维标准正态输入向量的 $N$ 个样本：\n1.  **蒙特卡洛(MC)：** 使用 `numpy.random.default_rng().standard_normal()` 生成样本，该函数从标准正态分布中产生独立的伪随机抽样。\n2.  **拉丁超立方采样(LHS)：** 使用 `scipy.stats.qmc.LatinHypercube` 在单位超立方体 $[0,1]^d$ 中生成一个 $N \\times d$ 的拉丁超立方样本。然后使用标准正态累积分布函数(CDF)的反函数 `scipy.stats.norm.ppf()` 将这些均匀样本转换到标准正态空间。\n3.  **准蒙特卡洛(QMC)：** 使用 `scipy.stats.qmc.Sobol` 生成一个 $N \\times d$ 的低差异Sobol序列，并启用了加扰以获得更好的误差属性。与LHS类似，这些均匀样本通过标准正态CDF的反函数映射到标准正态空间。对于LHS和QMC，在进行反CDF变换之前，均匀样本被裁剪到区间 $[\\varepsilon, 1-\\varepsilon]$（其中 $\\varepsilon=10^{-12}$），以防止在正态分布的尾部附近出现数值不稳定性。\n\n对于每个测试用例，分析过程首先使用大量的标准MC样本（$N_{\\text{ref}}$）计算一个高精度参考概率 $p_{\\text{ref}}$。然后，对于三种采样方法中的每一种以及指定的集合中的每个样本量 $N$，将超限概率 $p_N$ 估计为指示器输出的样本均值。接着计算绝对误差 $e_N = |p_N - p_{\\text{ref}}|$。为估计经验收敛速率 $\\alpha$，对误差的对数 $\\log(e_N)$ 与样本量的对数 $\\log(N)$ 进行线性回归。基于理论误差尺度 $e_N \\approx c N^{-\\alpha}$，速率 $\\alpha$ 由对数-对数图的斜率的负值给出。这是使用 `scipy.stats.linregress` 计算的。\n\n每个测试用例最终报告的值包括最大样本量（$N_{\\max} = 1024$）时的概率估计 $p_N$ 和误差 $e_N$，以及每种方法的估计收敛速率 $\\alpha$。所有随机抽样过程都使用指定的种子进行初始化，以确保可复现性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import qmc, norm, linregress\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment for all test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"L\": 100.0, \"n\": 0.30, \"i\": 0.01, \"C0\": 100.0, \"C_thr\": 10.0,\n            \"ell\": 20.0, \"mu_Y\": np.log(10.0), \"sigma_Y\": 0.5, \"m\": 5, \"G\": 200,\n            \"mu_lambda\": np.log(0.05), \"sigma_lambda\": 0.3,\n            \"sample_sizes\": [64, 256, 1024], \"N_ref\": 20000,\n            \"seeds\": {\"MC\": 12345, \"LHS\": 23456, \"QMC\": 34567},\n        },\n        {\n            \"L\": 200.0, \"n\": 0.35, \"i\": 0.005, \"C0\": 50.0, \"C_thr\": 5.0,\n            \"ell\": 50.0, \"mu_Y\": np.log(5.0), \"sigma_Y\": 0.8, \"m\": 7, \"G\": 300,\n            \"mu_lambda\": np.log(0.02), \"sigma_lambda\": 0.5,\n            \"sample_sizes\": [64, 256, 1024], \"N_ref\": 20000,\n            \"seeds\": {\"MC\": 12346, \"LHS\": 23457, \"QMC\": 34568},\n        },\n        {\n            \"L\": 50.0, \"n\": 0.25, \"i\": 0.02, \"C0\": 30.0, \"C_thr\": 25.0,\n            \"ell\": 5.0, \"mu_Y\": np.log(15.0), \"sigma_Y\": 0.4, \"m\": 4, \"G\": 150,\n            \"mu_lambda\": np.log(0.1), \"sigma_lambda\": 0.2,\n            \"sample_sizes\": [64, 256, 1024], \"N_ref\": 20000,\n            \"seeds\": {\"MC\": 12347, \"LHS\": 23458, \"QMC\": 34569},\n        },\n    ]\n\n    all_case_results = []\n    for params in test_cases:\n        p_ref, model_evaluator = setup_and_compute_reference(params)\n        \n        case_p_Nmax, case_e_Nmax, case_alphas = [], [], []\n\n        methods = [\"MC\", \"LHS\", \"QMC\"]\n        for method_name in methods:\n            p_Nmax, e_Nmax, alpha = analyze_method(\n                method_name, params, p_ref, model_evaluator\n            )\n            case_p_Nmax.append(p_Nmax)\n            case_e_Nmax.append(e_Nmax)\n            case_alphas.append(alpha)\n\n        # Combine results in the specified order for this case\n        combined_results = case_p_Nmax + case_e_Nmax + case_alphas\n        all_case_results.append(combined_results)\n\n    # Format the final output string as specified\n    print(f\"[{','.join(map(str, all_case_results))}]\")\n\ndef setup_and_compute_reference(params):\n    \"\"\"\n    Sets up the model evaluator and computes the reference probability.\n    \"\"\"\n    m = params[\"m\"]\n    d = m + 1\n    \n    # Pre-compute parts of the model that do not depend on random samples\n    x_grid = np.linspace(0, params[\"L\"], params[\"G\"])\n    j_vals = np.arange(1, m + 1)\n    \n    # Eigenvalues of the Karhunen-Loeve expansion\n    lambda_j = (params[\"sigma_Y\"]**2) * np.exp(-(j_vals * np.pi * params[\"ell\"] / params[\"L\"])**2)\n    sqrt_lambda_j = np.sqrt(lambda_j)\n    \n    # Eigenfunctions evaluated on the grid\n    phi_j_x = np.sqrt(2) * np.cos(np.pi * np.outer(j_vals, x_grid) / params[\"L\"])\n    \n    def evaluate_model(samples_norm):\n        \"\"\"Vectorized evaluation of the physics model for N samples.\"\"\"\n        N_samples = samples_norm.shape[0]\n        xi_samples = samples_norm[:, :m]\n        Z_samples = samples_norm[:, m]\n\n        # Construct log-conductivity field Y(x) for N samples\n        Y_x_perturbation = (xi_samples @ np.diag(sqrt_lambda_j)) @ phi_j_x\n        Y_x = params[\"mu_Y\"] + Y_x_perturbation\n\n        # Compute hydraulic conductivity K(x) and travel time t\n        K_x = np.exp(Y_x)\n        integrand = 1.0 / K_x\n        integral_val = np.trapz(integrand, x=x_grid, axis=1)\n        t = (params[\"n\"] / params[\"i\"]) * integral_val\n\n        # Compute decay rate lambda and final concentration C_obs\n        lam = np.exp(params[\"mu_lambda\"] + params[\"sigma_lambda\"] * Z_samples)\n        C_obs = params[\"C0\"] * np.exp(-lam * t)\n        \n        # Return exceedance event indicator\n        return (C_obs > params[\"C_thr\"]).astype(int)\n\n    # Compute reference probability using a dedicated high-N MC run\n    ref_seed = sum(params[\"seeds\"].values()) # Deterministic seed for reproducibility\n    ref_rng = np.random.default_rng(ref_seed)\n    ref_samples = ref_rng.standard_normal(size=(params[\"N_ref\"], d))\n    p_ref = np.mean(evaluate_model(ref_samples))\n    \n    return p_ref, evaluate_model\n\ndef analyze_method(method_name, params, p_ref, model_evaluator):\n    \"\"\"\n    Analyzes a single sampling method (MC, LHS, or QMC).\n    \"\"\"\n    m = params[\"m\"]\n    d = m + 1\n    seed = params[\"seeds\"][method_name]\n    sample_sizes = params[\"sample_sizes\"]\n    N_max = max(sample_sizes)\n    eps = 1e-12\n\n    log_errors = []\n    log_Ns = []\n    p_Nmax, e_Nmax = None, None\n\n    for N in sample_sizes:\n        # 1. Generate samples\n        if method_name == \"MC\":\n            rng = np.random.default_rng(seed)\n            samples_norm = rng.standard_normal(size=(N, d))\n        else:\n            if method_name == \"LHS\":\n                sampler = qmc.LatinHypercube(d=d, seed=seed)\n            elif method_name == \"QMC\":\n                sampler = qmc.Sobol(d=d, scramble=True, seed=seed)\n            \n            samples_unif = sampler.random(n=N)\n            samples_unif = np.clip(samples_unif, eps, 1 - eps)\n            samples_norm = norm.ppf(samples_unif)\n        \n        # 2. Estimate probability and error\n        p_N = np.mean(model_evaluator(samples_norm))\n        e_N = abs(p_N - p_ref)\n\n        if e_N > 0:\n            log_errors.append(np.log(e_N))\n            log_Ns.append(np.log(N))\n\n        if N == N_max:\n            p_Nmax = p_N\n            e_Nmax = e_N\n\n    # 3. Fit convergence rate\n    if len(log_Ns) >= 2:\n        slope, _, _, _, _ = linregress(log_Ns, log_errors)\n        alpha = -slope\n    else:\n        alpha = 0.0  # Not enough data for regression\n\n    return p_Nmax, e_Nmax, alpha\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}