{
    "hands_on_practices": [
        {
            "introduction": "为了理解全局隐式方法的必要性，我们从一个实践演示入手，探讨简化耦合可能带来的后果。本练习  要求您实现并比较两种处理沉淀问题的方案：一种是完全耦合的隐式方案，另一种则使用滞后的孔隙度。通过量化由此产生的质量守恒误差，您将对为何严格的全局耦合对地球化学模拟的物理保真度至关重要获得切实的理解。",
            "id": "4080936",
            "problem": "考虑一个空间均匀的封闭孔隙水控制体，其中单一水相反应物发生沉淀，将水相质量转化为固体矿物。设体积孔隙度为 $\\phi$，水相浓度为 $c$（单位为 $\\mathrm{mol\\,m^{-3}}$），矿物摩尔体积为 $V_m$（单位为 $\\mathrm{m^3\\,mol^{-1}}$）。假设为一级动力学速率定律，反应速率系数为 $k$（单位为 $\\mathrm{s^{-1}}$）。忽略平流和扩散；系统仅通过反应演化。\n\n作为基本依据，使用以下两个表达质量守恒和孔隙度演化的常微分方程（ODE）：\n- 每单位总体积的水相质量守恒：$\\dfrac{d}{dt}\\left(\\phi\\,c\\right) = -k\\,c$。\n- 由矿物形成引起的孔隙度演化：$\\dfrac{d\\phi}{dt} = -V_m\\,k\\,c$。\n\n这些 ODE 将 $\\phi$ 和 $c$ 耦合在一起，在时间上离散化后体现为一个全局隐式非线性残差。考虑一个从 $(\\phi^n,c^n)$ 到 $(\\phi^{n+1},c^{n+1})$、大小为 $\\Delta t$ 的单个时间步上的全隐式时间离散化。全局隐式残差在累积项内部使用更新后的孔隙度 $\\phi^{n+1}$。相比之下，一种常见的近似方法是在残差中使用滞后的孔隙度 $\\phi^n$，从而忽略了累积项内部的孔隙度更新，但在计算出 $c^{n+1}$ 后仍然单独更新 $\\phi$。\n\n您的任务是：\n1. 从上述两个 ODE 出发，推导全隐式离散系统，其中 $\\phi^{n+1}$ 和 $c^{n+1}$ 同时出现在累积项和汇项中，从而实现全局耦合。在另一个推导中，写出在非线性残差中使用 $\\phi^n$ 代替 $\\phi^{n+1}$，从而忽略累积项中孔隙度更新的格式。\n2. 解析地证明，滞后孔隙度残差忽略了一个与 $c^{n+1}\\left(\\phi^{n+1}-\\phi^n\\right)/\\Delta t$ 成正比的项，因此不能满足与全局隐式残差相同的离散质量守恒恒等式。用 $\\Delta t$、$k$、$V_m$ 和 $c^{n+1}$ 表示每步的质量误差。\n3. 使用恒定的 $\\Delta t$、初始条件 $\\phi(0)=\\phi_0$ 和 $c(0)=c_0$ 以及参数 $V_m$，在总时间 $T$ 内实现两种时间积分格式。对于全局隐式格式，在每一步中，通过同时求解两个离散方程，从 $(\\phi^n,c^n)$ 求解 $(\\phi^{n+1},c^{n+1})$。对于滞后孔隙度格式，在累积项中使用 $\\phi^n$ 更新 $c^{n+1}$，然后根据孔隙度演化方程更新 $\\phi^{n+1}$。\n4. 将最终时间 $T$ 的累积质量误差定义为滞后孔隙度格式预测的每单位总体积的水相质量与全局隐式格式预测的相应值之间的带符号差值，即 $E_{\\mathrm{cum}} = \\phi^{N}_{\\mathrm{lag}}\\,c^{N}_{\\mathrm{lag}} - \\phi^{N}_{\\mathrm{glob}}\\,c^{N}_{\\mathrm{glob}}$（单位为 $\\mathrm{mol\\,m^{-3}}$），其中 $N=T/\\Delta t$ 是整数步数。对每个指定的测试用例量化 $E_{\\mathrm{cum}}$，并以 $\\mathrm{mol\\,m^{-3}}$ 为单位表示数值答案。\n\n除非另有说明，所有测试用例均使用以下物理上一致的参数值：\n- 初始孔隙度 $\\phi_0 = 0.30$（无量纲）。\n- 初始浓度 $c_0 = 100.0$（单位为 $\\mathrm{mol\\,m^{-3}}$）。\n- 矿物摩尔体积 $V_m = 3.7\\times 10^{-5}$（单位为 $\\mathrm{m^3\\,mol^{-1}}$）。\n\n在以下 $(\\Delta t, k, T)$ 测试套件上实现这两种格式，其中 $\\Delta t$ 和 $T$ 的单位为 $\\mathrm{s}$，$k$ 的单位为 $\\mathrm{s^{-1}}$：\n- 测试用例 1：$\\Delta t = 1.0$，$k = 1.0\\times 10^{-4}$，$T = 1000.0$。\n- 测试用例 2：$\\Delta t = 100.0$，$k = 1.0\\times 10^{-4}$，$T = 100000.0$。\n- 测试用例 3：$\\Delta t = 1000.0$，$k = 1.0\\times 10^{-4}$，$T = 100000.0$。\n- 测试用例 4：$\\Delta t = 100.0$，$k = 0.0$，$T = 100000.0$。\n- 测试用例 5：$\\Delta t = 500.0$，$k = 5.0\\times 10^{-3}$，$T = 10000.0$。\n\n对于每个测试用例，计算如上定义的 $E_{\\mathrm{cum}}$，并以 $\\mathrm{mol\\,m^{-3}}$ 为单位，将结果作为浮点数提供。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$）。列表中的每个结果必须按顺序对应于测试用例 1 到 5。\n\n此问题不涉及角度。所有物理答案必须以 $\\mathrm{mol\\,m^{-3}}$ 为单位，并以浮点数形式打印。不允许使用基于百分比的答案。程序必须是完整且可运行的。",
            "solution": "该问题要求对两种用于描述多孔介质中矿物沉淀的耦合常微分方程（ODE）组的数值时间积分格式进行批判性比较。核心任务包括推导全局隐式格式和简化的滞后孔隙度格式的离散方程，解析地量化后者的质量守恒误差，并实现这两种格式以计算给定测试用例集的累积误差。\n\n控制连续系统由水相质量守恒和孔隙度演化方程给出：\n$$\n\\frac{d}{dt}\\left(\\phi\\,c\\right) = -k\\,c \\quad (1)\n$$\n$$\n\\frac{d\\phi}{dt} = -V_m\\,k\\,c \\quad (2)\n$$\n其中 $\\phi$ 是孔隙度，$c$ 是水相浓度，$k$ 是一级反应速率系数，$V_m$ 是固体矿物产物的摩尔体积。\n\n### 任务1：数值格式的推导\n\n我们考虑从时间 $t^n$ 到 $t^{n+1}$，步长为 $\\Delta t$ 的单个时间步，状态变量从 $(\\phi^n, c^n)$ 演化到 $(\\phi^{n+1}, c^{n+1})$。全隐式（向后欧拉）时间离散在未来的时间层 $t^{n+1}$ 对所有项（包括非线性系数）进行求值。\n\n**全局隐式格式：**\n对两个 ODE 应用全隐式离散化，得到一个耦合的非线性系统。\n对于方程 $(1)$，时间导数近似为 $\\frac{\\phi^{n+1}c^{n+1} - \\phi^n c^n}{\\Delta t}$。右侧的汇项在 $t^{n+1}$ 处求值。这给出了离散质量守恒方程：\n$$\n\\frac{\\phi^{n+1}c^{n+1} - \\phi^n c^n}{\\Delta t} = -k c^{n+1} \\quad (3)\n$$\n对于方程 $(2)$，相同的离散方法给出了离散孔隙度演化方程：\n$$\n\\frac{\\phi^{n+1} - \\phi^n}{\\Delta t} = -V_m k c^{n+1} \\quad (4)\n$$\n方程 $(3)$ 和 $(4)$ 构成了关于两个未知数 $\\phi^{n+1}$ 和 $c^{n+1}$ 的两个非线性代数方程组。为了求解该系统，我们可以从方程 $(4)$ 中用 $c^{n+1}$ 表示 $\\phi^{n+1}$：\n$$\n\\phi^{n+1} = \\phi^n - \\Delta t V_m k c^{n+1} \\quad (5)\n$$\n将此 $\\phi^{n+1}$ 的表达式代入方程 $(3)$，得到一个关于 $c^{n+1}$ 的单一方程：\n$$\n\\frac{(\\phi^n - \\Delta t V_m k c^{n+1})c^{n+1} - \\phi^n c^n}{\\Delta t} = -k c^{n+1}\n$$\n整理此方程可得到关于 $c^{n+1}$ 的二次方程：\n$$\n\\phi^n c^{n+1} - \\Delta t V_m k (c^{n+1})^2 - \\phi^n c^n = -\\Delta t k c^{n+1}\n$$\n$$\n(\\Delta t V_m k)(c^{n+1})^2 - (\\phi^n + \\Delta t k)c^{n+1} + \\phi^n c^n = 0 \\quad (6)\n$$\n这个二次方程可以求解 $c^{n+1}$。一旦求得 $c^{n+1}$，就可以通过方程 $(5)$ 确定 $\\phi^{n+1}$。\n\n**滞后孔隙度格式：**\n该格式是一种简化，其中累积项 $\\frac{d}{dt}(\\phi c)$ 中的孔隙度被显式处理，即在时间 $t^n$ 进行求值。这解耦了系统，允许顺序求解。\n离散质量守恒方程变为：\n$$\n\\frac{\\phi^n c^{n+1} - \\phi^n c^n}{\\Delta t} = -k c^{n+1} \\quad (7)\n$$\n现在该方程对于未知数 $c^{n+1}$ 是线性的，可以直接求解：\n$$\n\\phi^n c^{n+1} + \\Delta t k c^{n+1} = \\phi^n c^n\n$$\n$$\nc^{n+1} = \\frac{\\phi^n c^n}{\\phi^n + \\Delta t k} \\quad (8)\n$$\n求解出 $c^{n+1}$ 后，使用与之前相同的全隐式方程，即方程 $(4)$，来更新孔隙度：\n$$\n\\phi^{n+1} = \\phi^n - \\Delta t V_m k c^{n+1} \\quad (9)\n$$\n\n### 任务2：质量守恒误差分析\n\n质量守恒的全局隐式残差是：对于离散系统的精确解，该残差必须为零：\n$$\nR_{\\mathrm{glob}}^{n+1} = \\frac{\\phi^{n+1}c^{n+1} - \\phi^n c^n}{\\Delta t} + k c^{n+1}\n$$\n我们可以通过在分子中加上和减去 $\\phi^n c^{n+1}$ 来重写它：\n$$\nR_{\\mathrm{glob}}^{n+1} = \\frac{\\phi^n c^{n+1} - \\phi^n c^n + \\phi^{n+1}c^{n+1} - \\phi^n c^{n+1}}{\\Delta t} + k c^{n+1}\n$$\n$$\nR_{\\mathrm{glob}}^{n+1} = \\left( \\frac{\\phi^n c^{n+1} - \\phi^n c^n}{\\Delta t} + k c^{n+1} \\right) + \\frac{(\\phi^{n+1} - \\phi^n)c^{n+1}}{\\Delta t}\n$$\n括号中的项是滞后孔隙度格式中关于浓度的残差 $R_{\\mathrm{lag},c}^{n+1}$。根据设计，滞后格式将此项设为零。因此，滞后孔隙度格式从正确的全局隐式质量平衡方程中省略了第二项 $\\frac{(\\phi^{n+1} - \\phi^n)c^{n+1}}{\\Delta t}$。这个省略是质量守恒误差的来源。\n\n每步质量误差就是这个被忽略的项。题目要求我们用 $\\Delta t$、$k$、$V_m$ 和 $c^{n+1}$ 来表示它。我们可以使用孔隙度演化方程 $\\frac{\\phi^{n+1} - \\phi^n}{\\Delta t} = -V_m k c^{n+1}$ 来替换差商：\n$$\n\\text{质量误差率} = \\frac{(\\phi^{n+1} - \\phi^n)c^{n+1}}{\\Delta t} = \\left(\\frac{\\phi^{n+1} - \\phi^n}{\\Delta t}\\right)c^{n+1} = (-V_m k c^{n+1})c^{n+1}\n$$\n$$\n\\text{质量误差率} = -V_m k (c^{n+1})^2\n$$\n这个量，单位为 $\\mathrm{mol\\,m^{-3}\\,s^{-1}}$，表示相对于保持质量守恒的全局隐式格式，滞后孔隙度格式在每个时间步中人为损失质量的速率（因为符号为负）。\n\n### 任务3和4：实现与误差量化\n\n这两种格式通过使用恒定步长 $\\Delta t$ 从 $t=0$ 到 $t=T$ 的时间步进循环来实现。\n\n**全局隐式格式的实现：**\n在每个时间步 $n$，给定 $(\\phi^n, c^n)$：\n1.  处理 $k=0$ 的特殊情况。方程 $(6)$ 变为 $-\\phi^n c^{n+1} + \\phi^n c^n = 0$，所以 $c^{n+1} = c^n$。从方程 $(5)$，$\\phi^{n+1} = \\phi^n$。状态是静态的。\n2.  对于 $k>0$，求解二次方程 $(6)$，$A(c^{n+1})^2 + B c^{n+1} + C = 0$，其中 $A = \\Delta t V_m k$，$B = -(\\phi^n + \\Delta t k)$，$C = \\phi^n c^n$。物理上有意义的根是较小的那个，当 $\\Delta t \\to 0$ 时，它趋近于 $c^n$。为避免相减过程中的抵消误差，我们使用该根的稳定二次公式：\n    $$\n    c^{n+1} = \\frac{-B - \\sqrt{B^2 - 4AC}}{2A} = \\frac{2C}{-B + \\sqrt{B^2 - 4AC}}\n    $$\n    $$\n    c^{n+1} = \\frac{2(\\phi^n c^n)}{(\\phi^n + \\Delta t k) + \\sqrt{(\\phi^n + \\Delta t k)^2 - 4(\\Delta t V_m k)(\\phi^n c^n)}}\n    $$\n3.  使用方程 $(5)$ 计算新的孔隙度 $\\phi^{n+1}$。\n4.  重复 $N = T/\\Delta t$ 步。\n\n**滞后孔隙度格式的实现：**\n在每个时间步 $n$，给定 $(\\phi^n, c^n)$：\n1.  使用方程 $(8)$ 中的直接公式计算新浓度 $c^{n+1}$。\n2.  使用方程 $(9)$ 计算新孔隙度 $\\phi^{n+1}$。\n3.  重复 $N = T/\\Delta t$ 步。\n\n**累积误差计算：**\n对于每个测试用例，我们从 $(\\phi_0, c_0)$ 开始，对两种模拟都运行 $N=T/\\Delta t$ 步。我们得到最终状态 $(\\phi^N_{\\mathrm{glob}}, c^N_{\\mathrm{glob}})$ 和 $(\\phi^N_{\\mathrm{lag}}, c^N_{\\mathrm{lag}})$。然后计算累积质量误差：\n$$\nE_{\\mathrm{cum}} = \\phi^{N}_{\\mathrm{lag}} c^{N}_{\\mathrm{lag}} - \\phi^{N}_{\\mathrm{glob}} c^{N}_{\\mathrm{glob}}\n$$\n对所提供的所有五个测试用例重复此计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It runs two different time-integration schemes for a coupled ODE system\n    and calculates the difference in final mass.\n    \"\"\"\n    # Define constants and initial conditions from the problem statement.\n    phi_0 = 0.30  # Initial porosity (dimensionless)\n    c_0 = 100.0   # Initial concentration (mol/m^3)\n    V_m = 3.7e-5  # Mineral molar volume (m^3/mol)\n\n    # Define the test cases.\n    test_cases = [\n        # (dt, k, T)\n        (1.0, 1.0e-4, 1000.0),      # Test case 1\n        (100.0, 1.0e-4, 100000.0),   # Test case 2\n        (1000.0, 1.0e-4, 100000.0),  # Test case 3\n        (100.0, 0.0, 100000.0),      # Test case 4\n        (500.0, 5.0e-3, 10000.0)      # Test case 5\n    ]\n\n    results = []\n\n    for dt, k, T in test_cases:\n        num_steps = int(T / dt)\n\n        # Run globally implicit simulation\n        phi_glob, c_glob = run_simulation(\n            'globally_implicit', phi_0, c_0, V_m, k, dt, num_steps\n        )\n        # Run lagged porosity simulation\n        phi_lag, c_lag = run_simulation(\n            'lagged_porosity', phi_0, c_0, V_m, k, dt, num_steps\n        )\n\n        # Calculate the final aqueous mass per bulk volume for each scheme\n        mass_glob = phi_glob * c_glob\n        mass_lag = phi_lag * c_lag\n\n        # Calculate the cumulative mass error\n        E_cum = mass_lag - mass_glob\n        results.append(E_cum)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\n\ndef run_simulation(scheme_type, phi_n, c_n, V_m, k, dt, num_steps):\n    \"\"\"\n    Runs a time-stepping simulation for the given scheme.\n\n    Args:\n        scheme_type (str): 'globally_implicit' or 'lagged_porosity'.\n        phi_n (float): Initial porosity.\n        c_n (float): Initial concentration.\n        V_m (float): Mineral molar volume.\n        k (float): Reaction rate coefficient.\n        dt (float): Time step size.\n        num_steps (int): Number of time steps.\n\n    Returns:\n        tuple: A tuple containing the final porosity and final concentration.\n    \"\"\"\n    for _ in range(num_steps):\n        if k == 0.0:\n            # If there is no reaction, phi and c do not change.\n            c_np1 = c_n\n            phi_np1 = phi_n\n        elif scheme_type == 'globally_implicit':\n            # Solve the quadratic equation for c^(n+1)\n            # A*x^2 + B*x + C = 0 where x = c^(n+1)\n            A = dt * V_m * k\n            B = -(phi_n + dt * k)\n            C = phi_n * c_n\n            \n            # Use the numerically stable quadratic formula for the smaller root\n            discriminant = B**2 - 4 * A * C\n            # The problem parameters ensure the discriminant is non-negative.\n            c_np1 = (2 * C) / (-B + np.sqrt(discriminant))\n\n            # Update porosity\n            phi_np1 = phi_n - dt * V_m * k * c_np1\n\n        elif scheme_type == 'lagged_porosity':\n            # Sequentially update c and then phi\n            c_np1 = (phi_n * c_n) / (phi_n + dt * k)\n            phi_np1 = phi_n - dt * V_m * k * c_np1\n        else:\n            raise ValueError(\"Unknown scheme type\")\n            \n        c_n, phi_n = c_np1, phi_np1\n        \n    return phi_n, c_n\n\n\n# Execute the main function\nsolve()\n\n```"
        },
        {
            "introduction": "在认识到完全耦合的重要性之后，我们现在转向一项基本任务：构建模拟所需的控制方程组。在此练习  中，您将从第一性原理出发，为一个耦合的平流-弥散-反应系统推导其完全隐式的非线性残差方程。这项纸笔练习旨在锻炼一项核心技能，即将连续的物理定律转化为计算机可以求解的离散代数系统，这构成了全局隐式求解器的根基。",
            "id": "4081042",
            "problem": "考虑一个长度为 $L$、横截面积恒为 $A$ 的一维饱和反应性多孔柱，它被离散为 $N$ 个宽度为 $\\Delta x$ 的均匀有限体积单元（因此每个单元的体积为 $V_{i} = A \\Delta x$）。设孔隙度在空间上均匀且等于 $\\phi$，孔隙水对流速度为常数 $u > 0$ 且方向从左到右，水动力弥散系数为常数 $D > 0$。输运了两种溶解的主要组分：浓度为 $c_{\\mathrm{Ca}}(x,t)$ 的钙和浓度为 $c_{\\mathrm{CO_3}}(x,t)$ 的碳酸根。这些组分通过可逆反应 $\\mathrm{CaCO_3(s)} \\rightleftharpoons \\mathrm{Ca^{2+}} + \\mathrm{CO_3^{2-}}$ 与矿物相（方解石）发生反应，其单位体积矿物质量为 $m(x,t)$。\n\n假设以下物理上标准的输运和反应原理作为基本依据：\n\n- 在包含对流-弥散和反应的饱和多孔介质中，每个溶解组分的局部质量守恒：对于组分 $j \\in \\{\\mathrm{Ca}, \\mathrm{CO_3}\\}$，\n$$\n\\phi \\frac{\\partial c_{j}}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(u \\, c_{j} - D \\frac{\\partial c_{j}}{\\partial x}\\right) = \\nu_{j} \\, r,\n$$\n其中 $\\nu_{\\mathrm{Ca}} = 1$ 和 $\\nu_{\\mathrm{CO_3}} = 1$ 是溶解产生溶解组分的化学计量系数（正值表示生成），$r$ 是体积反应速率。\n\n- 矿物的局部质量守恒：\n$$\n\\frac{\\partial m}{\\partial t} = - r,\n$$\n因此，矿物溶解（$r > 0$）会减少 $m$ 并生成溶解组分，而沉淀（$r  0$）会增加 $m$ 并消耗溶解组分。\n\n- 一个经过充分检验的、用于描述单位体积方解石溶解/沉淀的过渡态理论（Transition-State Theory）形式的速率定律：\n$$\nr = k \\, s \\left(\\frac{c_{\\mathrm{Ca}} c_{\\mathrm{CO_3}}}{K_{\\mathrm{eq}}} - 1\\right),\n$$\n其中 $k  0$ 是动力学常数，$s  0$ 是单位体积的有效反应表面积（在本次推导中假设其在空间和时间上为常数），$K_{\\mathrm{eq}}  0$ 是平衡常数。\n\n请使用后向欧拉法进行时间积分，为内部单元 $i$ 在时间 $t^{n+1}$ 的耦合系统推导一个守恒的、全隐式的有限体积残差。在 $t^{n+1}$ 时刻计算所有通量和反应速率，从而使输运和反应被隐式地嵌入并全局耦合。对流项使用与 $u  0$ 一致的迎风离散格式，弥散项使用中心差分格式。记单元 $i$ 和 $i+1$ 之间的面为 $i+1/2$，单元 $i-1$ 和 $i$ 之间的面为 $i-1/2$。对于任意溶解组分 $j$，在时间 $t^{n+1}$ 定义守恒的面通量：\n$$\nF_{j,i+\\frac{1}{2}}^{n+1} = u \\, c_{j,i}^{n+1} - D \\frac{c_{j,i+1}^{n+1} - c_{j,i}^{n+1}}{\\Delta x}, \\quad\nF_{j,i-\\frac{1}{2}}^{n+1} = u \\, c_{j,i-1}^{n+1} - D \\frac{c_{j,i}^{n+1} - c_{j,i-1}^{n+1}}{\\Delta x}.\n$$\n\n令 $r_{i}^{n+1} = k \\, s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right)$ 为在 $t^{n+1}$ 时刻计算的以单元为中心的反应速率。从给定的定律出发，使用在控制体积 $V_{i}$ 上的有限体积积分和在时间区间 $[t^{n}, t^{n+1}]$ 上的后向欧拉法，推导三个耦合的残差 $R_{\\mathrm{Ca},i}$、$R_{\\mathrm{CO_3},i}$ 和 $R_{m,i}$。每个残差都用 $(A, \\Delta x, \\phi, \\Delta t, u, D, k, s, K_{\\mathrm{eq}})$、未知量 $(c_{\\mathrm{Ca},i-1}^{n+1}, c_{\\mathrm{Ca},i}^{n+1}, c_{\\mathrm{Ca},i+1}^{n+1}, c_{\\mathrm{CO_3},i-1}^{n+1}, c_{\\mathrm{CO_3},i}^{n+1}, c_{\\mathrm{CO_3},i+1}^{n+1}, m_{i}^{n+1})$ 以及已知的上一时刻值 $(c_{\\mathrm{Ca},i}^{n}, c_{\\mathrm{CO_3},i}^{n}, m_{i}^{n})$ 表示。您推导的残差必须确保每个控制体积中面通量和反应源项的精确平衡。\n\n请以闭合形式给出单元 $i$ 的最终残差向量。无需进行数值计算或四舍五入，最终表达式中不包含单位。",
            "solution": "用户要求推导一维多孔介质中耦合反应输运系统的全隐式有限体积残差。问题陈述已经过验证，被认为是科学上合理、适定且完整的。因此，我们可以进行推导。\n\n该系统涉及三个未知场：溶解钙的浓度 $c_{\\mathrm{Ca}}(x,t)$；溶解碳酸根的浓度 $c_{\\mathrm{CO_3}}(x,t)$；以及单位体积的矿物方解石质量 $m(x,t)$。所提供的控制性偏微分方程（PDEs）如下：\n对于溶解组分 $j \\in \\{\\mathrm{Ca}, \\mathrm{CO_3}\\}$：\n$$ \\phi \\frac{\\partial c_{j}}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(u \\, c_{j} - D \\frac{\\partial c_{j}}{\\partial x}\\right) = \\nu_{j} \\, r $$\n对于矿物相：\n$$ \\frac{\\partial m}{\\partial t} = - r $$\n反应速率 $r$ 由过渡态理论（TST）速率定律给出：\n$$ r = k \\, s \\left(\\frac{c_{\\mathrm{Ca}} c_{\\mathrm{CO_3}}}{K_{\\mathrm{eq}}} - 1\\right) $$\n其中化学计量系数为 $\\nu_{\\mathrm{Ca}}=1$ 和 $\\nu_{\\mathrm{CO_3}}=1$。\n\n我们的目标是使用有限体积法对内部单元 $i$ 的这三个耦合偏微分方程进行离散化。离散化将是全隐式的，采用后向欧拉格式进行时间积分。每个方程的残差（记为 $R_j$）是一个表达式，对于新时间步 $t^{n+1}$ 的未知数解，该表达式必须等于零。\n\n我们首先将每个偏微分方程在单元 $i$ 的控制体积（即 $V_i = A \\Delta x$）上进行积分。这对应于在空间区间 $[x_{i-1/2}, x_{i+1/2}]$ 上的积分。\n\n**1. 钙的残差，$R_{\\mathrm{Ca},i}$**\n\n钙的控制方程为：\n$$ \\phi \\frac{\\partial c_{\\mathrm{Ca}}}{\\partial t} + \\frac{\\partial F_{\\mathrm{Ca}}}{\\partial x} = r $$\n其中 $F_{\\mathrm{Ca}} = u \\, c_{\\mathrm{Ca}} - D \\frac{\\partial c_{\\mathrm{Ca}}}{\\partial x}$ 是钙的总通量。在控制体积 $V_i = A \\Delta x$ 上积分得到：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( \\phi \\frac{\\partial c_{\\mathrm{Ca}}}{\\partial t} \\right) A \\, dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( \\frac{\\partial F_{\\mathrm{Ca}}}{\\partial x} \\right) A \\, dx = \\int_{x_{i-1/2}}^{x_{i+1/2}} r \\, A \\, dx $$\n假设以单元为中心的值是单元平均值的良好近似，并对通量项应用微积分基本定理，我们得到半离散方程：\n$$ \\phi A \\Delta x \\frac{d c_{\\mathrm{Ca},i}}{dt} + A \\left( F_{\\mathrm{Ca},i+1/2} - F_{\\mathrm{Ca},i-1/2} \\right) = r_i A \\Delta x $$\n现在，我们应用后向欧拉法进行时间离散化。时间导数近似为 $\\frac{d c_{\\mathrm{Ca},i}}{dt} \\approx \\frac{c_{\\mathrm{Ca},i}^{n+1} - c_{\\mathrm{Ca},i}^{n}}{\\Delta t}$，并且所有其他项都在新的时间层 $n+1$ 上计算。这就得到了全离散方程：\n$$ \\phi A \\Delta x \\frac{c_{\\mathrm{Ca},i}^{n+1} - c_{\\mathrm{Ca},i}^{n}}{\\Delta t} + A \\left( F_{\\mathrm{Ca},i+1/2}^{n+1} - F_{\\mathrm{Ca},i-1/2}^{n+1} \\right) - r_i^{n+1} A \\Delta x = 0 $$\n该方程的左侧就是残差 $R_{\\mathrm{Ca},i}$。我们代入所提供的通量和反应速率的离散表达式：\n- $ F_{\\mathrm{Ca},i+1/2}^{n+1} = u \\, c_{\\mathrm{Ca},i}^{n+1} - D \\frac{c_{\\mathrm{Ca},i+1}^{n+1} - c_{\\mathrm{Ca},i}^{n+1}}{\\Delta x} $\n- $ F_{\\mathrm{Ca},i-1/2}^{n+1} = u \\, c_{\\mathrm{Ca},i-1}^{n+1} - D \\frac{c_{\\mathrm{Ca},i}^{n+1} - c_{\\mathrm{Ca},i-1}^{n+1}}{\\Delta x} $\n- $ r_{i}^{n+1} = k \\, s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right) $\n\n将这些代入残差方程，得到 $R_{\\mathrm{Ca},i}$ 的最终形式：\n$$ R_{\\mathrm{Ca},i} = \\phi A \\Delta x \\frac{c_{\\mathrm{Ca},i}^{n+1} - c_{\\mathrm{Ca},i}^{n}}{\\Delta t} + A \\left( u c_{\\mathrm{Ca},i}^{n+1} - D \\frac{c_{\\mathrm{Ca},i+1}^{n+1} - c_{\\mathrm{Ca},i}^{n+1}}{\\Delta x} \\right) - A \\left( u c_{\\mathrm{Ca},i-1}^{n+1} - D \\frac{c_{\\mathrm{Ca},i}^{n+1} - c_{\\mathrm{Ca},i-1}^{n+1}}{\\Delta x} \\right) - A \\Delta x k s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right) $$\n\n**2. 碳酸根的残差，$R_{\\mathrm{CO_3},i}$**\n\n由于 $\\nu_{\\mathrm{CO_3}}=1$，碳酸根的控制方程在形式上与钙的控制方程相同。\n$$ \\phi \\frac{\\partial c_{\\mathrm{CO_3}}}{\\partial t} + \\frac{\\partial F_{\\mathrm{CO_3}}}{\\partial x} = r $$\n推导过程完全相同。我们在控制体积上积分，应用后向欧拉格式，并代入离散的通量和反应速率。这导致了一个残差 $R_{\\mathrm{CO_3},i}$，其结构与 $R_{\\mathrm{Ca},i}$ 相同，但用碳酸根浓度表示：\n$$ R_{\\mathrm{CO_3},i} = \\phi A \\Delta x \\frac{c_{\\mathrm{CO_3},i}^{n+1} - c_{\\mathrm{CO_3},i}^{n}}{\\Delta t} + A \\left( u c_{\\mathrm{CO_3},i}^{n+1} - D \\frac{c_{\\mathrm{CO_3},i+1}^{n+1} - c_{\\mathrm{CO_3},i}^{n+1}}{\\Delta x} \\right) - A \\left( u c_{\\mathrm{CO_3},i-1}^{n+1} - D \\frac{c_{\\mathrm{CO_3},i}^{n+1} - c_{\\mathrm{CO_3},i-1}^{n+1}}{\\Delta x} \\right) - A \\Delta x k s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right) $$\n注意，$R_{\\mathrm{Ca},i}$ 和 $R_{\\mathrm{CO_3},i}$ 都通过非线性反应项耦合在一起，该项同时依赖于 $c_{\\mathrm{Ca},i}^{n+1}$ 和 $c_{\\mathrm{CO_3},i}^{n+1}$。\n\n**3. 矿物的残差，$R_{m,i}$**\n\n矿物质量 $m$ 的控制方程是：\n$$ \\frac{\\partial m}{\\partial t} = -r $$\n这个方程在每个空间位置都是一个关于时间的常微分方程，因为它不包含空间导数。我们再次在控制体积 $V_i = A \\Delta x$ 上积分：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( \\frac{\\partial m}{\\partial t} \\right) A \\, dx = - \\int_{x_{i-1/2}}^{x_{i+1/2}} r \\, A \\, dx $$\n用单元中心值近似被积函数，得到半离散形式：\n$$ A \\Delta x \\frac{d m_i}{dt} = - r_i A \\Delta x $$\n应用后向欧拉格式，我们得到：\n$$ A \\Delta x \\frac{m_i^{n+1} - m_i^n}{\\Delta t} = - r_i^{n+1} A \\Delta x $$\n将所有项移到一边，得到残差 $R_{m,i}$：\n$$ R_{m,i} = A \\Delta x \\left( \\frac{m_i^{n+1} - m_i^n}{\\Delta t} \\right) + r_i^{n+1} A \\Delta x = 0 $$\n代入 $r_i^{n+1}$ 的表达式：\n$$ R_{m,i} = A \\Delta x \\left( \\frac{m_i^{n+1} - m_i^n}{\\Delta t} \\right) + A \\Delta x k s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right) $$\n这个残差将矿物质量 $m_i^{n+1}$ 与溶解浓度 $c_{\\mathrm{Ca},i}^{n+1}$ 和 $c_{\\mathrm{CO_3},i}^{n+1}$ 耦合起来。\n\n推导出的三个残差 $R_{\\mathrm{Ca},i}$、$R_{\\mathrm{CO_3},i}$ 和 $R_{m,i}$，为每个内部单元 $i$ 的三个未知数 ($c_{\\mathrm{Ca},i}^{n+1}$, $c_{\\mathrm{CO_3},i}^{n+1}$, $m_i^{n+1}$) 构成了一个包含三个耦合非线性代数方程的系统。当为所有单元组装这些方程时，它们在一个全局隐式方法中被同时求解。单元 $i$ 的残差向量在最终答案中给出。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\phi A \\Delta x \\frac{c_{\\mathrm{Ca},i}^{n+1} - c_{\\mathrm{Ca},i}^{n}}{\\Delta t} + A \\left( u c_{\\mathrm{Ca},i}^{n+1} - D \\frac{c_{\\mathrm{Ca},i+1}^{n+1} - c_{\\mathrm{Ca},i}^{n+1}}{\\Delta x} \\right) - A \\left( u c_{\\mathrm{Ca},i-1}^{n+1} - D \\frac{c_{\\mathrm{Ca},i}^{n+1} - c_{\\mathrm{Ca},i-1}^{n+1}}{\\Delta x} \\right) - A \\Delta x k s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right) \\\\\n\\\\\n\\phi A \\Delta x \\frac{c_{\\mathrm{CO_3},i}^{n+1} - c_{\\mathrm{CO_3},i}^{n}}{\\Delta t} + A \\left( u c_{\\mathrm{CO_3},i}^{n+1} - D \\frac{c_{\\mathrm{CO_3},i+1}^{n+1} - c_{\\mathrm{CO_3},i}^{n+1}}{\\Delta x} \\right) - A \\left( u c_{\\mathrm{CO_3},i-1}^{n+1} - D \\frac{c_{\\mathrm{CO_3},i}^{n+1} - c_{\\mathrm{CO_3},i-1}^{n+1}}{\\Delta x} \\right) - A \\Delta x k s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right) \\\\\n\\\\\nA \\Delta x \\left( \\frac{m_i^{n+1} - m_i^n}{\\Delta t} \\right) + A \\Delta x k s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "一旦建立了非线性残差方程组，下一个挑战便是如何高效且稳健地求解它。这节高阶练习  将深入探讨求解器的核心：牛顿-拉弗森法及其雅可比矩阵。您将通过计算，对精确的手动推导雅可比矩阵、通过自动微分生成的雅可比矩阵以及一个特意设置的不完整雅可比矩阵进行比较，从而探索雅可比矩阵的准确性对求解器收敛性的影响，并将其与非精确牛顿法的强大理论框架联系起来。",
            "id": "4081056",
            "problem": "考虑一个纯化学模型问题，该问题捕捉了计算地球化学中耦合系统全局隐式方法所遇到的基本非线性和耦合特性。我们研究水中弱酸的电中性与水的自电离问题。令 $h$ 表示氢离子浓度 $[\\mathrm{H}^+]$，$o$ 表示氢氧根离子浓度 $[\\mathrm{OH}^-]$，以及 $a$ 表示共轭碱浓度 $[\\mathrm{A}^-]$。该模型由三个基于经过充分检验的地球化学关系的非线性方程定义：水的自电离的质量作用定律、电中性以及包含电离质量作用关系的总酸质量平衡。\n\n残差向量 $\\mathbf{F}(\\mathbf{x})$ 将 $\\mathbb{R}^3$ 映射到 $\\mathbb{R}^3$，其中 $\\mathbf{x} = [h,a,o]^\\top$，参数为 $(K_w, K_a, C_T)$：\n- 水的自电离 (质量作用定律): $$f_1(h,a,o) = h\\,o - K_w.$$\n- 电中性: $$f_2(h,a,o) = h - a - o.$$\n- 总酸质量平衡，包含电离关系 $[\\mathrm{HA}] = \\dfrac{h\\,a}{K_a}$: $$f_3(h,a,o) = C_T - a - \\dfrac{h\\,a}{K_a}.$$\n\n牛顿法通过求解线性系统 $$\\mathbf{J}(\\mathbf{x}_k)\\,\\mathbf{s}_k = -\\mathbf{F}(\\mathbf{x}_k),$$ 来更新 $\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\mathbf{s}_k$，其中 $\\mathbf{J}(\\mathbf{x}) = \\dfrac{\\partial \\mathbf{F}}{\\partial \\mathbf{x}}$ 是雅可比矩阵。非精确牛顿法理论研究非精确求解牛顿线性系统的影响。如果步长 $\\mathbf{s}_k$ 满足强迫条件 $$\\frac{\\left\\| \\mathbf{J}(\\mathbf{x}_k)\\,\\mathbf{s}_k + \\mathbf{F}(\\mathbf{x}_k) \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_k) \\right\\|_2} \\le \\eta_k,$$ 那么，在解附近满足标准正则性假设的条件下，下一步的残差范数服从以下形式的收缩估计 $$\\frac{\\left\\|\\mathbf{F}(\\mathbf{x}_{k+1})\\right\\|_2}{\\left\\|\\mathbf{F}(\\mathbf{x}_k)\\right\\|_2} \\lesssim \\eta_k,$$ 对于线性问题，在极限情况下等式成立；对于具有 Lipschitz 连续雅可比矩阵的非线性问题，当 $\\mathbf{x}_k$ 趋近于解时，比例常数趋近于 $1$。\n\n您需要比较三种雅可比矩阵的构造方法：\n1. 从 $\\mathbf{F}(\\mathbf{x})$ 解析计算得到的手动推导的雅可比矩阵 $\\mathbf{J}_{\\text{hand}}(\\mathbf{x})$。\n2. 通过前向模式对偶数计算的自动微分 (AD) 雅可比矩阵 $\\mathbf{J}_{\\text{AD}}(\\mathbf{x})$。\n3. 一个不完整的手动雅可比矩阵 $\\tilde{\\mathbf{J}}(\\mathbf{x})$，其中缺少交叉导数项 $\\dfrac{\\partial f_3}{\\partial h}$，即设置 $\\dfrac{\\partial f_3}{\\partial h} = 0$，同时保持所有其他项与 $\\mathbf{J}_{\\text{hand}}(\\mathbf{x})$ 相同。\n\n从一个初始猜测值开始 $$h_0 = \\sqrt{K_w}, \\quad a_0 = \\min(C_T, h_0), \\quad o_0 = \\frac{K_w}{h_0},$$ 对精确和不完整雅可比矩阵各执行一次牛顿更新：\n- 精确步：求解 $\\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0)\\,\\mathbf{s}_{\\text{exact}} = -\\mathbf{F}(\\mathbf{x}_0)$ 并设置 $\\mathbf{x}^{+}_{\\text{exact}} = \\mathbf{x}_0 + \\mathbf{s}_{\\text{exact}}$。\n- 不完整步：求解 $\\tilde{\\mathbf{J}}(\\mathbf{x}_0)\\,\\mathbf{s}_{\\text{inc}} = -\\mathbf{F}(\\mathbf{x}_0)$ 并设置 $\\mathbf{x}^{+}_{\\text{inc}} = \\mathbf{x}_0 + \\mathbf{s}_{\\text{inc}}$。\n\n为每个测试案例计算以下五个量化指标：\n- 在初始猜测值处，手动推导的雅可比矩阵与 AD 雅可比矩阵之差的弗罗贝尼乌斯范数：$$\\left\\| \\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0) - \\mathbf{J}_{\\text{AD}}(\\mathbf{x}_0) \\right\\|_F.$$\n- 在初始猜测值处，由不完整雅可比矩阵引起的非精确牛顿强迫项：$$\\eta = \\frac{\\left\\| \\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0)\\,\\mathbf{s}_{\\text{inc}} + \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}.$$\n- 不完整雅可比矩阵步的观测收缩率：$$r_{\\text{inc}} = \\frac{\\left\\| \\mathbf{F}(\\mathbf{x}^{+}_{\\text{inc}}) \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}.$$\n- 观测收缩率与强迫项之比：$$\\rho = \\frac{r_{\\text{inc}}}{\\eta}.$$\n- 精确雅可比矩阵步的观测收缩率：$$r_{\\text{exact}} = \\frac{\\left\\| \\mathbf{F}(\\mathbf{x}^{+}_{\\text{exact}}) \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}.$$\n\n参数的选择保证了科学真实性和数值合理性。隐含使用摩尔浓度单位；您无需输出浓度，只需输出无量纲指标。以下四个测试案例构成了测试套件，必须完全按照给定的方式使用：\n- 测试案例 1 (中等强度弱酸): $(K_w, K_a, C_T) = (10^{-14}, 1.8\\times 10^{-5}, 10^{-2})$。\n- 测试案例 2 (极弱酸，稀释): $(K_w, K_a, C_T) = (10^{-14}, 10^{-9}, 10^{-3})$。\n- 测试案例 3 (较强酸行为): $(K_w, K_a, C_T) = (10^{-14}, 10^{-1}, 10^{-3})$。\n- 测试案例 4 (总酸浓度极稀): $(K_w, K_a, C_T) = (10^{-14}, 10^{-6}, 10^{-8})$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试案例，并且本身是一个包含五个浮点数的列表，顺序为 $[\\left\\| \\mathbf{J}_{\\text{hand}} - \\mathbf{J}_{\\text{AD}} \\right\\|_F,\\ \\eta,\\ r_{\\text{inc}},\\ \\rho,\\ r_{\\text{exact}}]$。例如，输出格式必须为 `[[m11,m12,m13,m14,m15],[m21,m22,m23,m24,m25],[m31,m32,m33,m34,m35],[m41,m42,m43,m44,m45]]`, 其中每个 `mij` 是一个浮点数的小数表示。不应打印任何其他文本。",
            "solution": "所提供的问题是计算科学领域一个有效的练习，具体位于数值分析和计算地球化学的交叉点。它在科学上基于基本的化学原理，在数学上是适定的，并且解决方案所需的所有组件都已明确指定。我将继续提供详细的解决方案。\n\n这个问题的核心是应用和分析牛顿法，以求解一个模拟水中弱酸平衡的非线性方程组。该系统由残差函数 $\\mathbf{F}(\\mathbf{x}) = \\mathbf{0}$ 表示，捕捉了化学物质浓度之间的基本非线性关系和耦合。\n\n设状态向量为 $\\mathbf{x} = [h, a, o]^\\top$，其中 $h$、$a$ 和 $o$ 分别是 $\\mathrm{H}^+$、$\\mathrm{A}^-$ 和 $\\mathrm{OH}^-$ 的浓度。方程组由以下各式给出：\n$$f_1(h,a,o) = h\\,o - K_w = 0 \\quad (\\text{水的自电离})$$\n$$f_2(h,a,o) = h - a - o = 0 \\quad (\\text{电中性})$$\n$$f_3(h,a,o) = C_T - a - \\frac{h\\,a}{K_a} = 0 \\quad (\\text{总酸质量平衡})$$\n这里，$K_w$ 是水的离子积，$K_a$ 是酸的电离常数，$C_T$ 是酸物质（$\\mathrm{HA} + \\mathrm{A}^-$）的总浓度。\n\n牛顿法通过求解线性系统 $\\mathbf{J}(\\mathbf{x}_k)\\,\\mathbf{s}_k = -\\mathbf{F}(\\mathbf{x}_k)$ 来得到更新步长 $\\mathbf{s}_k$，从而迭代地优化估计值 $\\mathbf{x}_k$，其中 $\\mathbf{J}(\\mathbf{x})$ 是 $\\mathbf{F}(\\mathbf{x})$ 的雅可比矩阵。然后，下一个迭代值为 $\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\mathbf{s}_k$。\n\n**1. 雅可比矩阵推导**\n\n雅可比矩阵 $\\mathbf{J}(\\mathbf{x})$ 是一个一阶偏导数矩阵，$\\mathbf{J}_{ij} = \\frac{\\partial f_i}{\\partial x_j}$，其中 $\\mathbf{x} = [x_1, x_2, x_3]^\\top = [h, a, o]^\\top$。\n\n**手动推导的雅可比矩阵, $\\mathbf{J}_{\\text{hand}}(\\mathbf{x})$**：\n我们计算 $\\mathbf{F}$ 的每个分量的偏导数：\n- 对于 $f_1(h,a,o) = h\\,o - K_w$:\n  $$ \\frac{\\partial f_1}{\\partial h} = o, \\quad \\frac{\\partial f_1}{\\partial a} = 0, \\quad \\frac{\\partial f_1}{\\partial o} = h $$\n- 对于 $f_2(h,a,o) = h - a - o$:\n  $$ \\frac{\\partial f_2}{\\partial h} = 1, \\quad \\frac{\\partial f_2}{\\partial a} = -1, \\quad \\frac{\\partial f_2}{\\partial o} = -1 $$\n- 对于 $f_3(h,a,o) = C_T - a - \\frac{h\\,a}{K_a}$:\n  $$ \\frac{\\partial f_3}{\\partial h} = -\\frac{a}{K_a}, \\quad \\frac{\\partial f_3}{\\partial a} = -1 - \\frac{h}{K_a}, \\quad \\frac{\\partial f_3}{\\partial o} = 0 $$\n\n将这些导数组合起来，得到解析的雅可比矩阵：\n$$ \\mathbf{J}_{\\text{hand}}(\\mathbf{x}) = \\begin{pmatrix} o  0  h \\\\ 1  -1  -1 \\\\ -a/K_a  -1 - h/K_a  0 \\end{pmatrix} $$\n\n**自动微分雅可比矩阵, $\\mathbf{J}_{\\text{AD}}(\\mathbf{x})$**：\n自动微分 (AD) 是一种计算技术，用于评估由计算机程序指定的函数的导数。我们使用基于对偶数的前向模式 AD。一个对偶数的形式为 $z = u + \\epsilon v$，其中 $u$ 是“原始”部分，$v$ 是“切线”部分，$\\epsilon$ 是一个无穷小量，满足 $\\epsilon^2 = 0$。通过泰勒展开，函数求值 $f(u + \\epsilon v)$ 得到 $f(u) + \\epsilon f'(u)v$。\n\n为了计算雅可比矩阵的第 $j$ 列 $\\frac{\\partial \\mathbf{F}}{\\partial x_j}$，我们用输入向量 $\\mathbf{x} + \\epsilon \\mathbf{e}_j$ 来评估 $\\mathbf{F}$，其中 $\\mathbf{e}_j$ 是第 $j$ 个标准基向量。结果的切线部分，$\\mathbf{F}(\\mathbf{x} + \\epsilon \\mathbf{e}_j) = \\mathbf{F}(\\mathbf{x}) + \\epsilon \\frac{\\partial \\mathbf{F}}{\\partial x_j}(\\mathbf{x})$，给出了所需的列。对于一个 3 变量系统，此过程执行 3 次以构建完整的雅可比矩阵 $\\mathbf{J}_{\\text{AD}}(\\mathbf{x})$。第一个指标 $\\left\\| \\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0) - \\mathbf{J}_{\\text{AD}}(\\mathbf{x}_0) \\right\\|_F$ 用作验证手动推导是否正确。我们期望这个范数在机器精度范围内为零。\n\n**不完整雅可比矩阵, $\\tilde{\\mathbf{J}}(\\mathbf{x})$**：\n这个雅可比矩阵是通过在解析雅可比矩阵中故意引入一个错误来构造的。按照规定，我们将交叉导数项 $\\frac{\\partial f_3}{\\partial h}$ 设置为零：\n$$ \\tilde{\\mathbf{J}}(\\mathbf{x}) = \\begin{pmatrix} o  0  h \\\\ 1  -1  -1 \\\\ 0  -1 - h/K_a  0 \\end{pmatrix} $$\n这种类型的近似在计算科学中很常见，其中某些耦合项可能被忽略以简化雅可比矩阵的结构（例如，用于块对角预处理），或者因为它们被假定为很小。\n\n**2. 非精确牛顿框架与指标**\n\n使用近似雅可比矩阵 $\\tilde{\\mathbf{J}}$ 代替真实雅可比矩阵 $\\mathbf{J}$，将牛顿迭代转化为非精确牛顿法。步长 $\\mathbf{s}_{\\text{inc}}$ 是通过求解 $\\tilde{\\mathbf{J}}(\\mathbf{x}_0) \\mathbf{s}_{\\text{inc}} = -\\mathbf{F}(\\mathbf{x}_0)$ 计算得出的。\n\n此步长未能满足真实牛顿线性系统的程度，由该系统的残差来衡量：\n$$ \\mathbf{r}_{\\text{lin}} = \\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0) \\mathbf{s}_{\\text{inc}} + \\mathbf{F}(\\mathbf{x}_0) $$\n非精确牛顿强迫项 $\\eta$ 是该线性残差的归一化大小：\n$$ \\eta = \\frac{\\left\\| \\mathbf{r}_{\\text{lin}} \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2} = \\frac{\\left\\| \\left(\\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0) - \\tilde{\\mathbf{J}}(\\mathbf{x}_0)\\right) \\mathbf{s}_{\\text{inc}} \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2} $$\n非精确牛顿法理论指出，如果 $\\eta$ 足够小，仍然可以实现收敛。该理论预测非线性残差范数的单步收缩率 $\\left\\| \\mathbf{F}(\\mathbf{x}_{k+1}) \\right\\|_2 / \\left\\| \\mathbf{F}(\\mathbf{x}_k) \\right\\|_2$ 与 $\\eta_k$ 成正比。\n\n所需的指标将此比较形式化：\n- $r_{\\text{inc}} = \\frac{\\left\\| \\mathbf{F}(\\mathbf{x}^{+}_{\\text{inc}}) \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}$：使用不完整雅可比矩阵时观测到的残差范数单步收缩率。\n- $\\rho = \\frac{r_{\\text{inc}}}{\\eta}$：该比率将观测到的收缩率与强迫项进行比较。接近 $1$ 的 $\\rho$ 值表明强迫项 $\\eta$ 是该方法性能的一个精确预测指标。\n- $r_{\\text{exact}} = \\frac{\\left\\| \\mathbf{F}(\\mathbf{x}^{+}_{\\text{exact}}) \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}$：真实牛顿步的观测收缩率，它可作为二次收敛的基准（即，该值应非常小）。\n\n**3. 计算流程**\n\n对于由参数 $(K_w, K_a, C_T)$ 定义的每个测试案例：\n1.  计算初始猜测值 $\\mathbf{x}_0 = [h_0, a_0, o_0]^\\top$，其中 $h_0 = \\sqrt{K_w}$，$a_0 = \\min(C_T, h_0)$，$o_0 = K_w/h_0$。\n2.  评估残差向量 $\\mathbf{F}(\\mathbf{x}_0)$。\n3.  在 $\\mathbf{x}_0$ 处构造三个雅可比矩阵：$\\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0)$、$\\mathbf{J}_{\\text{AD}}(\\mathbf{x}_0)$ 和 $\\tilde{\\mathbf{J}}(\\mathbf{x}_0)$。\n4.  计算差值的弗罗贝尼乌斯范数 $\\left\\| \\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0) - \\mathbf{J}_{\\text{AD}}(\\mathbf{x}_0) \\right\\|_F$。\n5.  求解两个线性系统以找到步长：\n    -   $\\mathbf{s}_{\\text{exact}} = - (\\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0))^{-1} \\mathbf{F}(\\mathbf{x}_0)$。\n    -   $\\mathbf{s}_{\\text{inc}} = - (\\tilde{\\mathbf{J}}(\\mathbf{x}_0))^{-1} \\mathbf{F}(\\mathbf{x}_0)$。\n6.  计算更新后的状态 $\\mathbf{x}^{+}_{\\text{exact}} = \\mathbf{x}_0 + \\mathbf{s}_{\\text{exact}}$ 和 $\\mathbf{x}^{+}_{\\text{inc}} = \\mathbf{x}_0 + \\mathbf{s}_{\\text{inc}}$。\n7.  计算强迫项 $\\eta = \\frac{\\left\\| \\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0)\\mathbf{s}_{\\text{inc}} + \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}$。\n8.  评估新的残差 $\\mathbf{F}(\\mathbf{x}^{+}_{\\text{inc}})$ 和 $\\mathbf{F}(\\mathbf{x}^{+}_{\\text{exact}})$。\n9.  计算收缩率 $r_{\\text{inc}}$、$\\rho$ 和 $r_{\\text{exact}}$。\n10. 收集这五个指标用于最终输出。对所有四个测试案例重复此过程。",
            "answer": "```python\nimport numpy as np\n\nclass Dual:\n    \"\"\"\n    A simple implementation of a dual number for forward-mode automatic differentiation.\n    \"\"\"\n    def __init__(self, u, v=0.0):\n        # u: primal part, v: tangent part\n        self.u = u\n        self.v = v\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.u + other.u, self.v + other.v)\n        return Dual(self.u + other, self.v)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.u - other.u, self.v - other.v)\n        return Dual(self.u - other, self.v)\n\n    def __rsub__(self, other):\n        return Dual(other - self.u, -self.v)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.u * other.u, self.u * other.v + self.v * other.u)\n        return Dual(self.u * other, self.v * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __truediv__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.u / other.u, (self.v * other.u - self.u * other.v) / (other.u ** 2))\n        return Dual(self.u / other, self.v / other)\n        \n    def __rtruediv__(self, other):\n        return Dual(other / self.u, -other * self.v / (self.u ** 2))\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        (1e-14, 1.8e-5, 1e-2),  # Case 1: moderately weak acid\n        (1e-14, 1e-9, 1e-3),   # Case 2: very weak acid, dilute\n        (1e-14, 1e-1, 1e-3),   # Case 3: stronger acid behavior\n        (1e-14, 1e-6, 1e-8),   # Case 4: extremely dilute total acid\n    ]\n\n    results = []\n\n    for Kw, Ka, Ct in test_cases:\n        # --- State and Function Definitions ---\n        \n        def F_vec(x, Kw, Ka, Ct):\n            \"\"\" Residual vector F(x) \"\"\"\n            h, a, o = x\n            f1 = h * o - Kw\n            f2 = h - a - o\n            f3 = Ct - a - (h * a) / Ka\n            return np.array([f1, f2, f3])\n\n        def J_hand(x, Ka):\n            \"\"\" Hand-derived Jacobian J_hand(x) \"\"\"\n            h, a, o = x\n            J = np.array([\n                [o, 0, h],\n                [1, -1, -1],\n                [-a / Ka, -1 - h / Ka, 0]\n            ])\n            return J\n\n        def J_AD(x, Kw, Ka, Ct):\n            \"\"\" AD-computed Jacobian J_AD(x) \"\"\"\n            J = np.zeros((3, 3))\n            \n            def F_dual(x_dual, Kw, Ka, Ct):\n                h, a, o = x_dual\n                f1 = h * o - Kw\n                f2 = h - a - o\n                f3 = Ct - a - (h * a) / Ka\n                return [f1, f2, f3]\n\n            for j in range(3):\n                x_dual = [Dual(val, 1.0 if i == j else 0.0) for i, val in enumerate(x)]\n                F_res_dual = F_dual(x_dual, Kw, Ka, Ct)\n                J[:, j] = [res.v for res in F_res_dual]\n            return J\n            \n        def J_incomplete(x, Ka):\n            \"\"\" Incomplete Jacobian J_tilde(x) \"\"\"\n            h, a, o = x\n            J = np.array([\n                [o, 0, h],\n                [1, -1, -1],\n                [0, -1 - h / Ka, 0]\n            ])\n            return J\n\n        # --- Step 1: Initial Guess ---\n        h0 = np.sqrt(Kw)\n        a0 = min(Ct, h0)\n        o0 = Kw / h0\n        x0 = np.array([h0, a0, o0])\n\n        # --- Step 2: Evaluate residuals and Jacobians at x0 ---\n        F_x0 = F_vec(x0, Kw, Ka, Ct)\n        J_hand_x0 = J_hand(x0, Ka)\n        J_ad_x0 = J_AD(x0, Kw, Ka, Ct)\n        J_inc_x0 = J_incomplete(x0, Ka)\n\n        # --- Step 3: Compute Metrics ---\n\n        # Metric 1: Frobenius norm of Jacobian difference\n        metric1 = np.linalg.norm(J_hand_x0 - J_ad_x0, 'fro')\n\n        # --- Solve linear systems for Newton steps ---\n        s_exact = np.linalg.solve(J_hand_x0, -F_x0)\n        s_inc = np.linalg.solve(J_inc_x0, -F_x0)\n\n        # --- Update states ---\n        x_plus_exact = x0 + s_exact\n        x_plus_inc = x0 + s_inc\n\n        # --- Evaluate new residuals ---\n        F_x_plus_exact = F_vec(x_plus_exact, Kw, Ka, Ct)\n        F_x_plus_inc = F_vec(x_plus_inc, Kw, Ka, Ct)\n        \n        # Norms of residuals\n        norm_F_x0 = np.linalg.norm(F_x0, 2)\n        norm_F_x_plus_exact = np.linalg.norm(F_x_plus_exact, 2)\n        norm_F_x_plus_inc = np.linalg.norm(F_x_plus_inc, 2)\n        \n        # Prevent division by zero if initial residual is zero\n        if norm_F_x0 == 0:\n            # This case corresponds to starting at the solution. All metrics would be 0 or undefined.\n            # Setting them to 0 is a reasonable convention.\n            metric2 = 0.0\n            metric3 = 0.0\n            metric4 = 0.0\n            metric5 = 0.0\n        else:\n            # Metric 2: Inexact Newton forcing term (eta)\n            linear_residual = J_hand_x0 @ s_inc + F_x0\n            metric2 = np.linalg.norm(linear_residual, 2) / norm_F_x0\n            \n            # Metric 3: Observed contraction for incomplete Jacobian (r_inc)\n            metric3 = norm_F_x_plus_inc / norm_F_x0\n            \n            # Metric 4: Ratio of observed contraction to forcing term (rho)\n            metric4 = metric3 / metric2 if metric2 != 0 else float('inf')\n\n            # Metric 5: Observed contraction for exact Jacobian (r_exact)\n            metric5 = norm_F_x_plus_exact / norm_F_x0\n        \n        case_results = [metric1, metric2, metric3, metric4, metric5]\n        results.append(case_results)\n    \n    # Final print statement in the exact required format.\n    # The format '[[m11,...],[m21,...],...]' is constructed by str(list_of_lists)\n    # and removing spaces, which is more robust than manual string formatting.\n    formatted_results = str(results).replace(\" \", \"\")\n    print(formatted_results)\n\nsolve()\n```"
        }
    ]
}