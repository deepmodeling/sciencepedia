{
    "hands_on_practices": [
        {
            "introduction": "任何微动弹性带（NEB）计算都始于对反应路径的初始猜测。本练习将实践最常见的初始路径生成方法：在反应物和产物状态之间进行线性插值，同时处理周期性边界条件（PBC）这一关键复杂性。掌握这项技能是建立晶体材料中扩散或反应模拟计算的基础。",
            "id": "4093358",
            "problem": "给定代表反应物和产物的两种原子结构，用于描述吸附物在晶体表面上的跳跃，以及一个周期性模拟晶胞。您的任务是，在周期性边界条件下，通过直线线性插值方法为 Nudged Elastic Band (NEB) 方法构建一个初始的图像路径，并评估该路径上每一步图像间的最大原子位移。结构由以埃（Angstrom）为单位的笛卡尔坐标指定。周期性晶胞由一个 $3 \\times 3$ 的矩阵指定，其列向量是三个以埃为单位的晶格矢量。中间图像的数量是一个整数 $N \\geq 0$。\n\n其物理和数学基础如下：\n- 在周期性晶格中，如果两个原子位置之差是晶格矢量的整数线性组合，则这两个位置是等效的。设晶胞矩阵为 $\\mathbf{M} = [\\mathbf{a}\\ \\mathbf{b}\\ \\mathbf{c}] \\in \\mathbb{R}^{3 \\times 3}$，其列向量为 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$。笛卡尔坐标 $\\mathbf{r}$ 对应的分数坐标 $\\mathbf{f}$ 满足 $\\mathbf{r} = \\mathbf{M}\\mathbf{f}$，即 $\\mathbf{f} = \\mathbf{M}^{-1}\\mathbf{r}$。\n- 两个笛卡尔坐标 $\\mathbf{r}^{(R)}$（反应物）和 $\\mathbf{r}^{(P)}$（产物）之间的最小镜像位移通过以下方式获得：计算分数位移 $\\Delta \\mathbf{f} = \\mathbf{M}^{-1}(\\mathbf{r}^{(P)} - \\mathbf{r}^{(R)})$，通过 $\\Delta \\mathbf{f}_{\\text{min}} = \\Delta \\mathbf{f} - \\mathrm{round}(\\Delta \\mathbf{f})$ 将 $\\Delta \\mathbf{f}$ 包装到区间 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$ 内，然后通过 $\\Delta \\mathbf{r}_{\\text{min}} = \\mathbf{M}\\Delta \\mathbf{f}_{\\text{min}}$ 映射回笛卡尔坐标。这种包装操作反映了选择与周期性等效性一致的最短位移矢量。\n- 包含 $N$ 个中间图像的初始 NEB 路径通过线性插值构建。对于图像索引 $k = 1, 2, \\dots, N$，插值参数为 $t_k = \\dfrac{k}{N+1}$，图像坐标为 $\\mathbf{r}^{(k)} = \\mathrm{wrap}\\left(\\mathbf{r}^{(R)} + t_k\\,\\Delta \\mathbf{r}_{\\text{min}}\\right)$，其中 $\\mathrm{wrap}(\\cdot)$ 函数通过 $\\mathbf{f} = \\mathbf{M}^{-1}\\mathbf{r}$ 将笛卡尔坐标映射到分数坐标，通过 $\\mathbf{f}_{\\text{wrap}} = \\mathbf{f} - \\mathrm{floor}(\\mathbf{f})$ 将其包装到 $[0,1)^3$ 区间内，然后通过 $\\mathbf{r}_{\\text{wrap}} = \\mathbf{M}\\mathbf{f}_{\\text{wrap}}$ 返回到笛卡尔坐标。端点 $\\mathbf{r}^{(R)}$ 和 $\\mathbf{r}^{(P)}$ 也必须包装到主晶胞中。\n- 步进最大原子位移是沿路径上连续图像计算得出的。设有序序列为 $\\{\\mathbf{r}^{(0)}, \\mathbf{r}^{(1)}, \\dots, \\mathbf{r}^{(N)}, \\mathbf{r}^{(N+1)}\\}$，其中 $\\mathbf{r}^{(0)}$ 是包装后的反应物，$\\mathbf{r}^{(1)}$ 到 $\\mathbf{r}^{(N)}$ 是包装后的中间图像，而 $\\mathbf{r}^{(N+1)}$ 是包装后的产物。对于每一步 $s = 0, 1, \\dots, N$，计算每个原子的最小镜像步进位移 $\\Delta \\mathbf{r}^{(s)}_i = \\mathbf{M}\\left(\\mathbf{M}^{-1}(\\mathbf{r}^{(s+1)}_i - \\mathbf{r}^{(s)}_i) - \\mathrm{round}\\left[\\mathbf{M}^{-1}(\\mathbf{r}^{(s+1)}_i - \\mathbf{r}^{(s)}_i)\\right]\\right)$，取其欧几里得范数 $\\|\\Delta \\mathbf{r}^{(s)}_i\\|_2$，然后取所有原子 $i$ 中的最大值。报告所有步骤的这些最大值的列表。\n\n实现一个程序，对每个测试用例执行以下操作：\n1. 给定晶胞矩阵 $\\mathbf{M}$、反应物坐标 $\\mathbf{R} \\in \\mathbb{R}^{M \\times 3}$、产物坐标 $\\mathbf{P} \\in \\mathbb{R}^{M \\times 3}$ 以及中间图像数 $N$，在周期性边界条件下计算 $N$ 个线性插值的图像。\n2. 使用最小镜像约定，计算路径上 $N+1$ 个最大原子步进位移的列表，以埃为单位表示为浮点数，并四舍五入到六位小数。\n\n使用以下测试套件。每个测试用例指定为 $(\\mathbf{M}, \\mathbf{R}, \\mathbf{P}, N)$：\n\n- 测试用例 1（正交晶胞，吸附物跨越边界）：\n  - $\\mathbf{M} = \\mathrm{diag}(10.0, 10.0, 10.0)$ 埃。\n  - $\\mathbf{R} = \\begin{bmatrix} 9.8  5.0  5.0 \\\\ 2.0  2.0  2.0 \\\\ 4.0  4.0  4.0 \\end{bmatrix}$ 埃。\n  - $\\mathbf{P} = \\begin{bmatrix} 0.2  5.0  5.0 \\\\ 2.0  2.0  2.0 \\\\ 4.1  4.0  4.0 \\end{bmatrix}$ 埃。\n  - $N = 3$。\n\n- 测试用例 2（三斜晶胞，混合运动）：\n  - $\\mathbf{M} = \\begin{bmatrix} 8.0  2.0  0.5 \\\\ 0.0  7.5  1.0 \\\\ 0.0  0.0  6.0 \\end{bmatrix}$ 埃（列是晶格矢量）。\n  - $\\mathbf{R} = \\begin{bmatrix} 7.9  3.0  5.8 \\\\ 1.0  1.0  1.0 \\end{bmatrix}$ 埃。\n  - $\\mathbf{P} = \\begin{bmatrix} 0.2  3.1  0.1 \\\\ 0.9  0.9  0.9 \\end{bmatrix}$ 埃。\n  - $N = 4$。\n\n- 测试用例 3（无中间图像）：\n  - $\\mathbf{M} = \\mathrm{diag}(5.0, 5.0, 5.0)$ 埃。\n  - $\\mathbf{R} = \\begin{bmatrix} 0.0  0.0  0.0 \\\\ 4.5  2.5  3.5 \\end{bmatrix}$ 埃。\n  - $\\mathbf{P} = \\begin{bmatrix} 1.0  1.0  1.0 \\\\ 4.5  2.4  3.5 \\end{bmatrix}$ 埃。\n  - $N = 0$。\n\n- 测试用例 4（相同结构）：\n  - $\\mathbf{M} = \\mathrm{diag}(7.5, 7.5, 7.5)$ 埃。\n  - $\\mathbf{R} = \\begin{bmatrix} 3.0  3.0  3.0 \\\\ 6.0  1.0  1.0 \\end{bmatrix}$ 埃。\n  - $\\mathbf{P} = \\begin{bmatrix} 3.0  3.0  3.0 \\\\ 6.0  1.0  1.0 \\end{bmatrix}$ 埃。\n  - $N = 5$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个元素对应一个测试用例，其本身是一个包含 $N+1$ 个浮点值（以埃为单位）的列表，四舍五入到六位小数。例如，一个有效的输出看起来像这样一行：$[\\,[v_{1,0}, v_{1,1}, \\dots],\\,[v_{2,0}, v_{2,1}, \\dots],\\,[v_{3,0}, \\dots],\\,[v_{4,0}, \\dots]\\,]$，其中 $v_{i,s}$ 是测试用例 $i$ 中步骤 $s$ 的最大步进位移。",
            "solution": "用户的要求是验证并解决一个来自计算地球化学领域的问题，该问题具体涉及 Nudged Elastic Band (NEB) 计算的设置。\n\n### **问题验证**\n\n**步骤 1：提取已知信息**\n\n- **晶胞矩阵**：一个 $3 \\times 3$ 的矩阵 $\\mathbf{M}$，其列向量是埃为单位的晶格矢量。\n- **反应物原子坐标**：一个 $M \\times 3$ 的笛卡尔坐标矩阵 $\\mathbf{R}$，单位为埃，其中 $M$ 是原子数。\n- **产物原子坐标**：一个 $M \\times 3$ 的笛卡尔坐标矩阵 $\\mathbf{P}$，单位为埃。\n- **中间图像数量**：一个非负整数 $N$，$N \\geq 0$。\n- **分数坐标**：$\\mathbf{f} = \\mathbf{M}^{-1}\\mathbf{r}$，对应于笛卡尔坐标 $\\mathbf{r}$。\n- **最小镜像位移**：$\\Delta \\mathbf{r}_{\\text{min}} = \\mathbf{M}\\Delta \\mathbf{f}_{\\text{min}}$，其中 $\\Delta \\mathbf{f}_{\\text{min}} = \\Delta \\mathbf{f} - \\mathrm{round}(\\Delta \\mathbf{f})$ 且 $\\Delta \\mathbf{f} = \\mathbf{M}^{-1}(\\mathbf{r}^{(P)} - \\mathbf{r}^{(R)})$。$\\mathrm{round}$ 函数按元素应用。得到的分数位移矢量 $\\Delta\\mathbf{f}_{\\text{min}}$ 的分量在区间 $[-\\frac{1}{2}, \\frac{1}{2})$ 内。\n- **坐标包装**：$\\mathrm{wrap}(\\mathbf{r})$ 将笛卡尔坐标 $\\mathbf{r}$ 映射到分数坐标 $\\mathbf{f} = \\mathbf{M}^{-1}\\mathbf{r}$，然后通过 $\\mathbf{f}_{\\text{wrap}} = \\mathbf{f} - \\mathrm{floor}(\\mathbf{f})$ 将 $\\mathbf{f}$ 的分量包装到 $[0,1)$ 内，最后通过 $\\mathbf{r}_{\\text{wrap}} = \\mathbf{M}\\mathbf{f}_{\\text{wrap}}$ 映射回笛卡尔坐标。\n- **路径生成**：路径由 $N+2$ 个图像组成，索引为 $k=0, \\dots, N+1$。图像 $k$ 的坐标由 $\\mathbf{r}^{(k)}$ 给出，其中 $\\mathbf{r}^{(0)} = \\mathrm{wrap}(\\mathbf{R})$，$\\mathbf{r}^{(N+1)} = \\mathrm{wrap}(\\mathbf{P})$，对于 $k=1, \\dots, N$，$\\mathbf{r}^{(k)} = \\mathrm{wrap}\\left(\\mathbf{R} + \\frac{k}{N+1}\\Delta \\mathbf{r}_{\\text{min}}\\right)$。\n- **步进位移**：对于每一步 $s=0, \\dots, N$，最大原子位移是连续图像 $\\mathbf{r}^{(s)}$ 和 $\\mathbf{r}^{(s+1)}$ 之间每个原子的最小镜像位移的欧几里得范数的最大值。即 $\\max_{i=1,\\dots,M} \\|\\Delta \\mathbf{r}_{\\text{min}}(\\mathbf{r}^{(s)}_i, \\mathbf{r}^{(s+1)}_i)\\|_2$。\n- **输出**：一个列表，其中包含每个测试用例的 $N+1$ 个最大步进位移的列表，其值四舍五入到六位小数。\n\n**步骤 2：使用提取的已知信息进行验证**\n\n- **科学上合理**：该问题描述了在周期系统中生成反应路径初始猜测的标准线性插值方法，这是计算材料科学和化学中与 NEB 等方法一起使用的核心技术。其数学形式（分数坐标、最小镜像约定）是标准且正确的。该问题在科学上是合理的。\n- **适定**：问题提供了完整的算法描述。所有函数（$\\mathrm{round}$、$\\mathrm{floor}$、$\\mathrm{wrap}$）、变量（$\\mathbf{M}、\\mathbf{R}、\\mathbf{P}、N$）和过程都得到了明确的定义。对于任何有效的输入集，都可以计算出唯一、稳定且有意义的解。$N=0$ 的情况也定义明确。\n- **客观**：问题使用精确的数学语言陈述，没有任何主观性或意见。\n- **缺陷清单**：该问题未表现出任何无效性缺陷。它不是科学上不合理、不可形式化、不完整、矛盾、不切实际、不适定、微不足道或无法验证的。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。将提供完整解决方案。\n\n### **求解推导**\n\n任务是生成一个连接反应物态 $\\mathbf{R}$ 和产物态 $\\mathbf{P}$ 的原子构型序列（图像），然后分析这些图像的几何间距。这个过程是像 Nudged Elastic Band (NEB) 方法这类更高级计算方法的标准先决条件，NEB 方法会优化这样的初始路径，以找到最小能量路径及其相关的活化能垒。\n\n解决方案是通过实现问题陈述中定义的精确算法步骤来构建的。\n\n**1. 坐标系与周期性**\n在晶体材料的模拟中，系统被定义在一个由三个晶格矢量描述的周期性晶胞内，这三个矢量构成了晶胞矩阵 $\\mathbf{M}$ 的列。笛卡尔坐标中的位置矢量 $\\mathbf{r}$ 可以等效地用相对于这些晶格矢量的分数坐标 $\\mathbf{f}$ 来表示。变换关系如下：\n$$ \\mathbf{r} = \\mathbf{M}\\mathbf{f} \\quad \\iff \\quad \\mathbf{f} = \\mathbf{M}^{-1}\\mathbf{r} $$\n周期性意味着点 $\\mathbf{r}$ 与任何点 $\\mathbf{r} + n_a\\mathbf{a} + n_b\\mathbf{b} + n_c\\mathbf{c}$ 是等效的，其中 $\\mathbf{a}, \\mathbf{b}, \\mathbf{c}$ 是晶格矢量，$n_a, n_b, n_c$ 是整数。在分数坐标中，这意味着 $\\mathbf{f}$ 对于任何整数矢量 $\\mathbf{n}$ 都与 $\\mathbf{f} + \\mathbf{n}$ 等效。\n\n**2. 最小镜像约定 (MIC)**\n为了找到周期系统中两个原子位置 $\\mathbf{r}^{(A)}$ 和 $\\mathbf{r}^{(B)}$ 之间的“最短”位移矢量，我们使用最小镜像约定。原始位移为 $\\Delta\\mathbf{r} = \\mathbf{r}^{(B)} - \\mathbf{r}^{(A)}$。我们将其转换为分数坐标：\n$$ \\Delta\\mathbf{f} = \\mathbf{M}^{-1}(\\mathbf{r}^{(B)} - \\mathbf{r}^{(A)}) $$\n然后将 $\\Delta\\mathbf{f}$ 的每个分量包装到区间 $[-\\frac{1}{2}, \\frac{1}{2})$ 内。这通过减去最近的整数来实现：\n$$ \\Delta\\mathbf{f}_{\\text{min}} = \\Delta\\mathbf{f} - \\mathrm{round}(\\Delta\\mathbf{f}) $$\n其中 $\\mathrm{round}(\\cdot)$ 是按元素应用的。笛卡尔坐标中的最小位移矢量则为：\n$$ \\Delta\\mathbf{r}_{\\text{min}} = \\mathbf{M}\\Delta\\mathbf{f}_{\\text{min}} $$\n此过程首先应用于整个反应，即每个原子的反应物 $\\mathbf{R}$ 和产物 $\\mathbf{P}$ 之间，从而产生矩阵 $\\Delta\\mathbf{R}_{\\text{min}}$。\n\n**3. 初始路径生成**\n初始路径是一个由 $N+2$ 个图像组成的序列，索引从 $k=0$ 到 $k=N+1$。中间图像 $\\mathbf{r}^{(k)}$ 是使用总最小位移矢量 $\\Delta\\mathbf{R}_{\\text{min}}$ 通过线性插值生成的。在包装之前，图像 $k$ 的插值位置是 $\\mathbf{R} + \\frac{k}{N+1}\\Delta\\mathbf{R}_{\\text{min}}$。为确保所有坐标都位于主晶胞内（在分数空间中通常为 $[0,1)^3$），会应用一个包装程序。图像 $k$ 坐标的完整定义是：\n$$ \\mathbf{r}^{(k)} = \\mathrm{wrap}\\left(\\mathbf{R} + \\frac{k}{N+1}\\Delta\\mathbf{R}_{\\text{min}}\\right), \\quad k \\in \\{0, 1, \\dots, N+1\\} $$\n$\\mathrm{wrap}(\\cdot)$ 函数通过将笛卡尔矢量转换为分数坐标，对各分量取模1（通过 $\\mathbf{f}_{\\text{wrap}} = \\mathbf{f} - \\mathrm{floor}(\\mathbf{f})$），然后再转换回笛卡尔坐标来实现这一点。这个单一公式正确地生成了整个路径，包括在 $k=0$ 和 $k=N+1$ 处的包装后的端点。\n\n**4. 步进位移计算**\n最后一步是量化生成路径 $\\{\\mathbf{r}^{(0)}, \\mathbf{r}^{(1)}, \\dots, \\mathbf{r}^{(N+1)}\\}$ 上连续图像之间的“距离”。对于每一步 $s$（从图像 $\\mathbf{r}^{(s)}$ 到 $\\mathbf{r}^{(s+1)}$），以及对于每个原子 $i$，我们必须再次计算最小镜像位移矢量 $\\Delta\\mathbf{r}_{\\text{min}}(\\mathbf{r}^{(s)}_i, \\mathbf{r}^{(s+1)}_i)$。这一点至关重要，因为路径插值与包装相结合，可能导致连续的图像位于不同的周期性晶胞中。在计算完给定步骤中所有原子的最小位移矢量集后，我们求出它们的欧几里得范数 $\\|\\Delta\\mathbf{r}_{\\text{min}, i}^{(s)}\\|_2$。这些范数的最大值即为该步骤的特征位移：\n$$ d_s = \\max_{i=1,\\dots,M} \\|\\Delta\\mathbf{r}_{\\text{min}}(\\mathbf{r}^{(s)}_i, \\mathbf{r}^{(s+1)}_i)\\|_2 $$\n对从 $s=0$ 到 $s=N$ 的所有 $N+1$ 个步骤重复此计算。所得的值列表 $[d_0, d_1, \\dots, d_N]$ 是一个测试用例的最终输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases for NEB path initialization.\n    \"\"\"\n\n    def calculate_path_displacements(M, R, P, N):\n        \"\"\"\n        Calculates the maximum atomic step displacements for an initial NEB path.\n\n        Args:\n            M (np.ndarray): 3x3 cell matrix.\n            R (np.ndarray): Mx3 reactant coordinates.\n            P (np.ndarray): Mx3 product coordinates.\n            N (int): Number of intermediate images.\n\n        Returns:\n            list: A list of N+1 maximum atomic displacements.\n        \"\"\"\n        M = np.array(M, dtype=float)\n        R = np.array(R, dtype=float)\n        P = np.array(P, dtype=float)\n        \n        try:\n            M_inv = np.linalg.inv(M)\n        except np.linalg.LinAlgError:\n            # This case should not happen with valid problem inputs.\n            return []\n\n        def to_fractional(cart_coords, m_inv):\n            # Handles both single vector (3,) and matrix of vectors (M, 3)\n            return cart_coords @ m_inv.T\n\n        def to_cartesian(frac_coords, m):\n            # Handles both single vector (3,) and matrix of vectors (M, 3)\n            return frac_coords @ m.T\n\n        def get_min_image_disp(r1, r2, m, m_inv):\n            \"\"\"Calculates minimum image displacement from r1 to r2.\"\"\"\n            cart_disp = r2 - r1\n            frac_disp = to_fractional(cart_disp, m_inv)\n            # np.round rounds .5 to the nearest even integer, which is a standard\n            # way to implement the rounding for MIC.\n            frac_disp_min = frac_disp - np.round(frac_disp)\n            cart_disp_min = to_cartesian(frac_disp_min, m)\n            return cart_disp_min\n\n        def wrap_coords(cart_coords, m, m_inv):\n            \"\"\"Wraps Cartesian coordinates into the primary cell [0,1)^3.\"\"\"\n            frac_coords = to_fractional(cart_coords, m_inv)\n            wrapped_frac = frac_coords - np.floor(frac_coords)\n            wrapped_cart = to_cartesian(wrapped_frac, m)\n            return wrapped_cart\n\n        # 1. Calculate the total minimum image displacement for the path\n        dR_min = get_min_image_disp(R, P, M, M_inv)\n\n        # 2. Generate the path of N+2 images (indices 0 to N+1)\n        path_images = []\n        num_images = N + 2\n        for k in range(num_images):\n            t_k = k / (N + 1) if (N + 1) > 0 else (0.0 if k == 0 else 1.0)\n            \n            interp_coords = R + t_k * dR_min\n            image_k = wrap_coords(interp_coords, M, M_inv)\n            path_images.append(image_k)\n\n        # 3. Calculate step-wise maximum displacements\n        max_displacements = []\n        for s in range(N + 1):\n            img_s = path_images[s]\n            img_s_plus_1 = path_images[s+1]\n            \n            # Calculate minimum image displacement vectors for all atoms in this step\n            step_disp_vectors = get_min_image_disp(img_s, img_s_plus_1, M, M_inv)\n            \n            # Calculate norms of displacement vectors\n            step_disp_magnitudes = np.linalg.norm(step_disp_vectors, axis=1)\n            \n            # Find the maximum displacement for this step\n            max_disp = np.max(step_disp_magnitudes) if step_disp_magnitudes.size > 0 else 0.0\n            max_displacements.append(max_disp)\n            \n        return max_displacements\n\n    test_cases = [\n        # Test Case 1\n        (\n            [[10.0, 0.0, 0.0], [0.0, 10.0, 0.0], [0.0, 0.0, 10.0]],\n            [[9.8, 5.0, 5.0], [2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],\n            [[0.2, 5.0, 5.0], [2.0, 2.0, 2.0], [4.1, 4.0, 4.0]],\n            3\n        ),\n        # Test Case 2\n        (\n            [[8.0, 0.0, 0.0], [2.0, 7.5, 0.0], [0.5, 1.0, 6.0]], # Problem states columns are vectors, numpy takes rows. Transposing.\n            [[7.9, 3.0, 5.8], [1.0, 1.0, 1.0]],\n            [[0.2, 3.1, 0.1], [0.9, 0.9, 0.9]],\n            4\n        ),\n        # Test Case 3\n        (\n            [[5.0, 0.0, 0.0], [0.0, 5.0, 0.0], [0.0, 0.0, 5.0]],\n            [[0.0, 0.0, 0.0], [4.5, 2.5, 3.5]],\n            [[1.0, 1.0, 1.0], [4.5, 2.4, 3.5]],\n            0\n        ),\n        # Test Case 4\n        (\n            [[7.5, 0.0, 0.0], [0.0, 7.5, 0.0], [0.0, 0.0, 7.5]],\n            [[3.0, 3.0, 3.0], [6.0, 1.0, 1.0]],\n            [[3.0, 3.0, 3.0], [6.0, 1.0, 1.0]],\n            5\n        ),\n    ]\n\n    all_results = []\n    for m_cols, r, p, n in test_cases:\n        # The problem states columns are lattice vectors. Numpy's convention is rows.\n        # We perform calculations with M.T where M is the matrix of column vectors.\n        # Or, we can just use M as specified if we are careful with post/pre multiplication.\n        # r' = M*f' means f' = M^-1 * r'. In numpy, with rows as coords: r' = f'*M.T, f' = r'*(M.T)^-1\n        # The code uses AT, where A is the input matrix, so it treats input as row vectors.\n        # Let's transpose the input of M to align with the math `r = Mf`.\n        m_mat = np.array(m_cols, dtype=float).T\n        result = calculate_path_displacements(m_mat, r, p, n)\n        all_results.append(result)\n\n    # Format the final output string exactly as required.\n    formatted_case_results = []\n    for res_list in all_results:\n        # Format each float to 6 decimal places and join into a string list\n        list_str = '[' + ','.join(f'{val:.6f}' for val in res_list) + ']'\n        formatted_case_results.append(list_str)\n    \n    final_output = '[' + ','.join(formatted_case_results) + ']'\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "生成初始路径后，NEB方法会迭代地优化中间“图像”（image）的位置，以收敛到最小能量路径（MEP）。爬山微动弹性带（CI-NEB）是一种强大的改进方法，它能确保其中一个图像精确地收敛到过渡态鞍点。本练习将深入探讨CI-NEB算法的核心：计算作用在“爬山”图像上的独特驱动力，该力旨在沿路径切线方向将此图像推向能量高处，从而直接定位过渡态。",
            "id": "3752891",
            "problem": "考虑一个二维势能面，旨在模拟高熵合金（HEA）扩散中常见的无序势能形貌，其中反应路径通过微动弹性带（Nudged Elastic Band, NEB）方法识别，并由爬山镜像（Climbing Image, CI）修正进行优化。设势能由光滑标量场 $V(\\mathbf{r})$ 定义，其中 $\\mathbf{r} = (x,y)$，力场由负梯度 $-\\nabla V(\\mathbf{r})$ 给出。离散路径由一系列镜像点 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ 表示，其中端点 $i=0$ 和 $i=N-1$ 是固定的。假设所有量都是无量纲的。\n\n基本依据与定义：\n- 镜像点 $i$ 处的能量为 $E_i = V(\\mathbf{r}_i)$，梯度为 $\\nabla V(\\mathbf{r}_i)$。\n- 在内部镜像点 $i$ 处的NEB路径切线是单位向量 $\\hat{\\boldsymbol{\\tau}}_i$，它与点 $i$ 处的路径方向对齐，并由相邻镜像点构造。您必须仅使用相邻镜像点选择一个数学上一致的切线定义，并稳健地处理近简并的相邻点差异，以避免除以零。\n- 爬山镜像修正旨在使内部镜像点中能量最高的那个点，沿路径切线方向上坡移动，在垂直于路径的子空间中下坡移动，且该镜像点不受弹簧力作用。\n\n任务：\n1. 对于下方的每个测试用例，识别出能量最大的内部镜像点，并根据上述描述应用爬山镜像修正，计算该镜像点的更新力：该力应严格驱动镜像点沿路径切线上坡移动，并垂直于路径下坡移动，同时移除该镜像点上的任何弹簧力贡献。\n2. 使用向量投影和内积，验证计算出的力同时满足以下两点：\n   - 其切向分量使其上坡移动（沿着路径上 $V$ 增加的方向）。\n   - 其垂直分量使其下坡移动（与能量梯度的垂直分量方向相反）。\n3. 为进行验证，在能量最大的镜像点 $i^\\star$ 处使用以下量化检查：\n   - 令 $\\hat{\\boldsymbol{\\tau}} = \\hat{\\boldsymbol{\\tau}}_{i^\\star}$，$\\mathbf{g} = \\nabla V(\\mathbf{r}_{i^\\star})$，并定义投影 $\\mathbf{g}_{\\parallel} = (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}})\\hat{\\boldsymbol{\\tau}}$ 和 $\\mathbf{g}_{\\perp} = \\mathbf{g} - \\mathbf{g}_{\\parallel}$。令 $\\mathbf{F}$ 表示您计算的爬山镜像力。在 $\\epsilon = 10^{-8}$ 的绝对容差内验证以下所有条件：\n     - $\\mathbf{F}$ 的切向分量与上坡运动匹配：$\\mathbf{F}\\cdot\\hat{\\boldsymbol{\\tau}}$ 等于 $+\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}$。\n     - $\\mathbf{F}$ 的垂直分量相对于梯度是下坡的：$\\mathbf{F} - (\\mathbf{F}\\cdot\\hat{\\boldsymbol{\\tau}})\\hat{\\boldsymbol{\\tau}}$ 等于 $-\\mathbf{g}_{\\perp}$。\n     - 下坡条件在能量上是一致的：$\\left(\\mathbf{F} - (\\mathbf{F}\\cdot\\hat{\\boldsymbol{\\tau}})\\hat{\\boldsymbol{\\tau}}\\right)\\cdot \\mathbf{g}_{\\perp} \\le 0$。\n   通过逻辑与（仅当所有三个条件在容差范围内都成立时为真）将这三个检查汇总为单个布尔值。\n4. 重要的算法要求：\n   - 对于内部镜像点 $i$ 处的切线 $\\hat{\\boldsymbol{\\tau}}_i$，使用从 $\\mathbf{r}_{i+1}-\\mathbf{r}_{i-1}$ 推导出的有限差分方向并将其归一化。如果其范数低于一个小阈值，您必须稳健地选择一个备选的非零方向（例如，优先选择范数较大的 $\\mathbf{r}_{i}-\\mathbf{r}_{i-1}$ 或 $\\mathbf{r}_{i+1}-\\mathbf{r}_{i}$，或作为最后手段选择一个与 $\\nabla V(\\mathbf{r}_i)$ 相关的方向）并将其归一化。端点不参与爬山过程。\n   - 所有计算都是无量纲的。\n   - 使用下面定义的势能函数及其解析梯度。\n\n势能定义：\n- 令\n$$\nV(x,y) = (x^2 - 1)^2 + a\\, y^2 + b \\sin(3x)\\cos(2y) + c\\, x + d \\sin(5y),\n$$\n其中常数 $a = 0.15$，$b = 0.10$，$c = 0.05$，$d = 0.03$。\n- 其梯度为\n$$\n\\nabla V(x,y) = \\Big(4x(x^2-1) + 3b\\cos(3x)\\cos(2y) + c,\\; 2a y - 2b \\sin(3x)\\sin(2y) + 5d \\cos(5y)\\Big).\n$$\n\n测试套件：\n对于每个用例，给定一个镜像点坐标列表 $\\{(x_i,y_i)\\}_{i=0}^{N-1}$。\n- 用例1（穿过势垒的直线路径）：\n  $\\{(-1.4,\\,0.0),\\; (-1.0,\\,0.0),\\; (-0.6,\\,0.0),\\; (-0.2,\\,0.0),\\; (0.2,\\,0.0),\\; (0.6,\\,0.0),\\; (1.0,\\,0.0)\\}$。\n- 用例2（对各向异性梯度进行采样的弯曲路径）：\n  $\\{(-1.2,\\,-0.3),\\; (-0.8,\\,-0.15),\\; (-0.4,\\,-0.02),\\; (0.0,\\,0.06),\\; (0.4,\\,0.12),\\; (0.8,\\,0.22),\\; (1.0,\\,0.4)\\}$。\n- 用例3（最大值点附近的近简并相邻点差异）：\n  $\\{(-0.9,\\,0.0),\\; (-0.001,\\,0.02),\\; (0.0,\\,0.02),\\; (0.0000005,\\,0.0200001),\\; (0.9,\\,0.0)\\}$。\n\n程序要求：\n- 完全按照给定的公式实现解析的 $V(x,y)$ 和 $\\nabla V(x,y)$。\n- 对于每个用例，识别出具有最大 $V$ 值的内部镜像点，并为该镜像点计算爬山镜像力 $\\mathbf{F}$，其计算方式需确保沿 $\\hat{\\boldsymbol{\\tau}}$ 方向上坡运动，垂直于 $\\hat{\\boldsymbol{\\tau}}$ 方向下坡运动，且该镜像点上没有弹簧力。\n- 使用 $\\epsilon = 10^{-8}$ 的绝对容差执行上述三个验证检查，并通过逻辑与为每个用例生成一个布尔值。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3]\"），其中每个结果是对应测试用例的布尔值。",
            "solution": "该问题要求在给定的二维势能面 $V(x,y)$ 上，为微动弹性带（Nudged Elastic Band, NEB）模拟计算并验证爬山镜像力。爬山镜像（Climbing Image, CI）修正是用于将NEB路径收敛到最小能量路径（Minimal Energy Path, MEP）的标准技术，其中能量最高的镜像点会收敛到一个一阶鞍点（即过渡态）。\n\n问题的核心在于根据所提供的描述和验证标准，正确解释爬山镜像力的定义。一个常规的NEB镜像点受到两种力的作用：一种是平行于路径切线的弹簧力 $\\mathbf{F}_{s, \\parallel}$，它确保了镜像点的均匀间隔；另一种是真实势能力（potential force）的垂直分量 $\\mathbf{F}_{\\text{pot}, \\perp}$，它使垂直于路径方向的能量最小化。势能力是势能的负梯度，即 $\\mathbf{F}_{\\text{pot}} = -\\nabla V$。\n\n被指定为 $\\mathbf{r}_{i^\\star}$ 的爬山镜像点（能量最高的内部镜像点）则被区别对待。问题描述指出，其弹簧力被移除。它被驱动沿路径切线“上坡”移动，并垂直于路径“下坡”移动。设 $\\mathbf{g} = \\nabla V(\\mathbf{r}_{i^\\star})$ 为爬山镜像点处的势能梯度，$\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ 为该点处的路径单位切向量。“上坡”和“下坡”分别指势能增加和减少的方向。最陡峭的上升方向由 $\\mathbf{g}$ 给出。\n\n爬山镜像点上的力 $\\mathbf{F}_{\\text{CI}}$ 由其平行于和垂直于切线 $\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ 的分量定义：\n$\\mathbf{F}_{\\text{CI}} = \\mathbf{F}_{\\parallel} + \\mathbf{F}_{\\perp}$。\n\n问题的验证标准明确了这些分量：\n1.  力的切向分量使镜像点“上坡”移动。指定的检查是 $\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star} = \\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star}$。这意味着力的平行分量等于梯度的平行分量：$\\mathbf{F}_{\\parallel} = (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star} = \\mathbf{g}_{\\parallel}$。这个力分量沿切线方向推动镜像点，使其朝该切线方向上势能增加的方向移动，从而实现“攀爬”能垒。\n\n2.  力的垂直分量使镜像点“下坡”移动。检查是 $\\mathbf{F}_{\\text{CI}} - (\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star} = -\\mathbf{g}_{\\perp}$。这意味着力的垂直分量是梯度的垂直分量的负值：$\\mathbf{F}_{\\perp} = -\\mathbf{g}_{\\perp}$。这个力分量作用于最小化垂直于路径的超平面内的势能，从而将镜像点松弛到最小能量路径（MEP）上。\n\n结合这些分量，爬山镜像力为：\n$$\n\\mathbf{F}_{\\text{CI}} = \\mathbf{g}_{\\parallel} - \\mathbf{g}_{\\perp}\n$$\n其中 $\\mathbf{g}_{\\parallel} = (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ 且 $\\mathbf{g}_{\\perp} = \\mathbf{g} - \\mathbf{g}_{\\parallel}$。这个公式等价于反转梯度CI力的标准定义，即 $\\mathbf{F}_{\\text{CI}} = -\\mathbf{g} + 2\\mathbf{g}_{\\parallel}$。\n\n解决每个测试用例的算法如下：\n1.  给定一条路径 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$，识别出内部镜像点，即 $\\{\\mathbf{r}_i\\}_{i=1}^{N-2}$。\n2.  为每个内部镜像点计算势能 $E_i = V(\\mathbf{r}_i)$。找到能量最大镜像点对应的索引 $i^\\star$。\n3.  确定爬山镜像点 $\\mathbf{r}_{i^\\star}$ 处的切向量 $\\hat{\\boldsymbol{\\tau}}_{i^\\star}$。主要定义是其相邻点之间的归一化向量：$\\mathbf{t} = \\mathbf{r}_{i^\\star+1} - \\mathbf{r}_{i^\\star-1}$。对于 $\\|\\mathbf{t}\\|$ 接近零的情况，需要进行稳健性检查。指定的备用方法是使用 $\\mathbf{r}_{i^\\star} - \\mathbf{r}_{i^\\star-1}$ 或 $\\mathbf{r}_{i^\\star+1} - \\mathbf{r}_{i^\\star}$ 中范数较大的那个向量的归一化形式。\n4.  计算梯度向量 $\\mathbf{g} = \\nabla V(\\mathbf{r}_{i^\\star})$。\n5.  计算爬山镜像力 $\\mathbf{F}_{\\text{CI}} = (\\mathbf{g} \\cdot \\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star} - (\\mathbf{g} - (\\mathbf{g} \\cdot \\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star})$。\n6.  执行三个验证检查，容差为 $\\epsilon=10^{-8}$：\n    a. 检查 1: $|\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star} - \\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star}|  \\epsilon$。\n    b. 检查 2: $\\|\\mathbf{F}_{\\perp} - (-\\mathbf{g}_{\\perp})\\|  \\epsilon$，其中 $\\mathbf{F}_{\\perp} = \\mathbf{F}_{\\text{CI}} - (\\mathbf{F}_{\\text{CI}}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star}$ 且 $\\mathbf{g}_{\\perp} = \\mathbf{g} - (\\mathbf{g}\\cdot\\hat{\\boldsymbol{\\tau}}_{i^\\star})\\hat{\\boldsymbol{\\tau}}_{i^\\star}$。\n    c. 检查 3: $\\mathbf{F}_{\\perp} \\cdot \\mathbf{g}_{\\perp} \\le 0$。如果前一个检查通过，此条件应为真，因为它变为 $-(\\mathbf{g}_{\\perp}\\cdot\\mathbf{g}_{\\perp}) = -\\|\\mathbf{g}_{\\perp}\\|^2 \\le 0$。\n7.  当且仅当所有三个检查都通过时，该测试用例的最终结果为 `True`。\n\n实现将使用为势能 $V(x,y)$ 及其梯度 $\\nabla V(x,y)$ 提供的解析表达式：\n$V(x,y) = (x^2 - 1)^2 + a\\, y^2 + b \\sin(3x)\\cos(2y) + c\\, x + d \\sin(5y)$\n$\\nabla V(x,y) = \\Big(4x(x^2-1) + 3b\\cos(3x)\\cos(2y) + c,\\; 2a y - 2b \\sin(3x)\\sin(2y) + 5d \\cos(5y)\\Big)$\n其中 $a = 0.15$，$b = 0.10$，$c = 0.05$，$d = 0.03$。计算中使用了 `numpy` 库的数值向量运算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the climbing image force verification problem for three test cases.\n    \"\"\"\n\n    # Constants for the potential energy function\n    a = 0.15\n    b = 0.10\n    c = 0.05\n    d = 0.03\n\n    def potential(r):\n        \"\"\"Calculates the potential energy V(x,y) at a given point r = [x, y].\"\"\"\n        x, y = r\n        term1 = (x**2 - 1)**2\n        term2 = a * y**2\n        term3 = b * np.sin(3 * x) * np.cos(2 * y)\n        term4 = c * x\n        term5 = d * np.sin(5 * y)\n        return term1 + term2 + term3 + term4 + term5\n\n    def gradient(r):\n        \"\"\"Calculates the gradient of the potential energy grad V(x,y) at a point r = [x, y].\"\"\"\n        x, y = r\n        grad_x = 4 * x * (x**2 - 1) + 3 * b * np.cos(3 * x) * np.cos(2 * y) + c\n        grad_y = 2 * a * y - 2 * b * np.sin(3 * x) * np.sin(2 * y) + 5 * d * np.cos(5 * y)\n        return np.array([grad_x, grad_y])\n\n    # Test suite provided in the problem statement\n    test_cases = [\n        # Case 1: straight path across a barrier\n        [(-1.4, 0.0), (-1.0, 0.0), (-0.6, 0.0), (-0.2, 0.0), (0.2, 0.0), (0.6, 0.0), (1.0, 0.0)],\n        # Case 2: bent path sampling anistropic gradients\n        [(-1.2, -0.3), (-0.8, -0.15), (-0.4, -0.02), (0.0, 0.06), (0.4, 0.12), (0.8, 0.22), (1.0, 0.4)],\n        # Case 3: near-degenerate neighbor differences around the maximum\n        [(-0.9, 0.0), (-0.001, 0.02), (0.0, 0.02), (0.0000005, 0.0200001), (0.9, 0.0)],\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        path = np.array(case)\n        num_images = len(path)\n        \n        # Interior images are from index 1 to N-2\n        interior_indices = range(1, num_images - 1)\n        interior_images = path[1:num_images - 1]\n        \n        # 1. Find the interior image with the maximal energy\n        energies = [potential(r) for r in interior_images]\n        # Get the global index of the max energy image\n        i_star = np.argmax(energies) + 1 \n        r_istar = path[i_star]\n\n        # 2. Compute the tangent vector at the climbing image\n        r_prev = path[i_star - 1]\n        r_next = path[i_star + 1]\n        \n        # Primary tangent definition\n        t = r_next - r_prev\n        norm_t = np.linalg.norm(t)\n        \n        tangent_threshold = 1e-9\n        if norm_t  tangent_threshold:\n            # Fallback tangent definition\n            t1 = r_istar - r_prev\n            t2 = r_next - r_istar\n            if np.linalg.norm(t1) > np.linalg.norm(t2):\n                t_alt = t1\n            else:\n                t_alt = t2\n            \n            norm_t_alt = np.linalg.norm(t_alt)\n            # The problem provides no case where second fallback is needed.\n            if norm_t_alt  tangent_threshold:\n                 # This path shouldn't be taken with the given test cases.\n                 # Fallback to gradient if all else fails, normalized.\n                 g_temp = gradient(r_istar)\n                 tau_hat = g_temp / np.linalg.norm(g_temp)\n            else:\n                 tau_hat = t_alt / norm_t_alt\n        else:\n            tau_hat = t / norm_t\n\n        # 3. Compute climbing image force from its components\n        g = gradient(r_istar)\n        g_dot_tau = np.dot(g, tau_hat)\n        \n        g_parallel = g_dot_tau * tau_hat\n        g_perp = g - g_parallel\n        \n        # Force is defined as F_CI = g_parallel - g_perp\n        F = g_parallel - g_perp\n        \n        # 4. Perform verification checks\n        epsilon = 1e-8\n\n        # Check 1: F_parallel component matches g_parallel component\n        F_dot_tau = np.dot(F, tau_hat)\n        check1 = abs(F_dot_tau - g_dot_tau)  epsilon\n        \n        # Check 2: F_perp component equals -g_perp\n        F_perp = F - F_dot_tau * tau_hat\n        check2 = np.linalg.norm(F_perp - (-g_perp))  epsilon\n\n        # Check 3: F_perp is energetically downhill with respect to g_perp\n        # This will be = 0 if check2 is met, due to F_perp ≈ -g_perp\n        dot_product_perp = np.dot(F_perp, g_perp)\n        check3 = dot_product_perp = 0.0 # Strict check as per definition\n\n        # Aggregate results\n        final_check = check1 and check2 and check3\n        results.append(final_check)\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "使用NEB方法计算反应能垒的最终目的通常是为了理解宏观的反应动力学。本练习将演示如何利用NEB计算得到的能垒来预测实际的动力学结果。通过在过渡态理论（TST）框架下，结合振动自由能校正和路径简并度等因素，你将学会如何比较相互竞争的反应机理，并确定在特定温度下哪条路径是主导反应通道。",
            "id": "4093306",
            "problem": "使用带有爬升像精化的微动弹性带 (Nudged Elastic Band, NEB) 方法，研究了矿物-流体反应网络中的一个表面介导的氧化还原步骤，以解析鞍点。两条不同的机理路径，路径1和路径2，连接了硅酸盐表面上相同的初始态与相同的最终态。对于每条路径，鞍点附近的三个能量最高的NEB图像在约化路径坐标 $s \\in \\{-1, 0, +1\\}$ 中等间距分布，其总电子能是相对于初始态（设为 $0$）报告的。这些图像的能量为：\n- 路径1: $E_{-1} = 0.740$ eV, $E_{0} = 0.755$ eV, $E_{+1} = 0.748$ eV。\n- 路径2: $E_{-1} = 0.705$ eV, $E_{0} = 0.710$ eV, $E_{+1} = 0.707$ eV。\n\n假设在鞍点附近，每条路径的最小能量路径上的能量分布可以用一个拟合给定三点的关于 $s$ 的二次多项式来近似。在温度 $T$ 下，对能垒的振动自由能校正（包括零点振动和有限温度振动贡献）以过渡态和初始态振动自由能之差 $\\Delta F_{\\mathrm{vib}}^{\\ddagger}(T)$ 的形式给出。在 $T = 600$ K 时，这些校正值为：\n- 路径1: $\\Delta F_{\\mathrm{vib}}^{\\ddagger}(600\\,\\mathrm{K}) = 0.045$ eV。\n- 路径2: $\\Delta F_{\\mathrm{vib}}^{\\ddagger}(600\\,\\mathrm{K}) = 0.035$ eV。\n\n你可以假设典则过渡态理论 (TST) 适用，且透射系数等于 $1$，并且两条路径的指前因子之间的唯一区别来自于对称等价的反应构型数（简并度）。路径1的简并度因子为 $g_{1} = 2$，路径2的简并度因子为 $g_{2} = 6$。使用玻尔兹曼常数 $k_{B} = 8.617\\,333\\,262 \\times 10^{-5}$ eV K$^{-1}$。\n\n任务：\n1. 对于每条路径，通过将一个关于 $s$ 的二次函数拟合到三个NEB图像的能量，并计算其顶点能量，来确定相对于初始态的鞍点能量。\n2. 对于每条路径，根据公式 $\\Delta G^{\\ddagger}(T) = E_{\\mathrm{saddle}} + \\Delta F_{\\mathrm{vib}}^{\\ddagger}(T)$ 构建在 $T = 600$ K 时的吉布斯自由能垒。\n3. 使用典则过渡态理论 (TST) 并考虑给定的简并度，计算在 $T = 600$ K 时，通过路径1进行的反应通量占总反应通量的分数。\n\n将最终结果表示为一个无量纲的小数，并将答案四舍五入至三位有效数字。",
            "solution": "该问题被认为是具有科学依据、提法得当且客观的。它提供了一套完整且一致的数据和假设，这对于基于计算化学和化学动力学的既定原理得出唯一解是必要的。所有必需的数据都已提供，任务也已明确说明。因此，有必要提供完整的解题过程。\n\n总体任务是确定通过特定路径（路径1）进行的反应通量占总通量的分数。这将通过问题陈述中概述的三个主要步骤来完成：\n1. 通过将二次多项式拟合到所提供的微动弹性带 (NEB) 图像能量，确定每条路径的电子能垒。\n2. 通过引入给定的振动自由能校正，计算每条路径的吉布斯活化自由能 $\\Delta G^{\\ddagger}$。\n3. 使用典则过渡态理论 (TST) 的速率表达式，包括简并度因子，以求出相对速率，进而求出通量分数。\n\n**步骤1：鞍点能量的确定**\n\n对于每条路径，过渡态附近的能量分布可用二次多项式 $E(s) = as^2 + bs + c$ 来近似，其中 $s$ 是约化路径坐标。给定的三个点是 $(s, E)$：$(-1, E_{-1})$、$(0, E_{0})$ 和 $(1, E_{+1})$。\n\n该二次函数的系数可以通过求解以下线性方程组来确定：\n$E(-1) = a(-1)^2 + b(-1) + c = a - b + c = E_{-1}$\n$E(0) = a(0)^2 + b(0) + c = c = E_{0}$\n$E(1) = a(1)^2 + b(1) + c = a + b + c = E_{+1}$\n\n从第二个方程可知，$c = E_{0}$。\n将 $c$ 代入另外两个方程，得到：\n$a - b = E_{-1} - E_{0}$\n$a + b = E_{+1} - E_{0}$\n\n将这两个方程相加，得到 $2a = E_{-1} + E_{+1} - 2E_{0}$，所以 $a = \\frac{E_{+1} + E_{-1} - 2E_{0}}{2}$。\n用第二个方程减去第一个方程，得到 $2b = E_{+1} - E_{-1}$，所以 $b = \\frac{E_{+1} - E_{-1}}{2}$。\n\n鞍点（能量分布的最高点）对应于此抛物线的顶点，其位置在 $s_{\\mathrm{vertex}} = -\\frac{b}{2a}$。该顶点的能量 $E_{\\mathrm{saddle}}$ 由下式给出：\n$E_{\\mathrm{saddle}} = E(s_{\\mathrm{vertex}}) = a\\left(-\\frac{b}{2a}\\right)^2 + b\\left(-\\frac{b}{2a}\\right) + c = \\frac{b^2}{4a} - \\frac{b^2}{2a} + c = c - \\frac{b^2}{4a}$。\n\n代入 $a$、$b$ 和 $c$ 的表达式：\n$$E_{\\mathrm{saddle}} = E_{0} - \\frac{\\left(\\frac{E_{+1} - E_{-1}}{2}\\right)^2}{4\\left(\\frac{E_{+1} + E_{-1} - 2E_{0}}{2}\\right)} = E_{0} - \\frac{(E_{+1} - E_{-1})^2}{8(E_{+1} + E_{-1} - 2E_{0})}$$\n\n现在，我们将此公式应用于每条路径。\n\n对于路径1：\n$E_{-1,1} = 0.740\\,\\text{eV}$, $E_{0,1} = 0.755\\,\\text{eV}$, $E_{+1,1} = 0.748\\,\\text{eV}$。\n$$E_{\\mathrm{saddle}, 1} = 0.755 - \\frac{(0.748 - 0.740)^2}{8(0.748 + 0.740 - 2 \\times 0.755)}$$\n$$E_{\\mathrm{saddle}, 1} = 0.755 - \\frac{(0.008)^2}{8(1.488 - 1.510)} = 0.755 - \\frac{0.000064}{8(-0.022)} = 0.755 + \\frac{0.000064}{0.176}$$\n$$E_{\\mathrm{saddle}, 1} \\approx 0.755 + 0.0003636... = 0.7553636... \\,\\text{eV}$$\n\n对于路径2：\n$E_{-1,2} = 0.705\\,\\text{eV}$, $E_{0,2} = 0.710\\,\\text{eV}$, $E_{+1,2} = 0.707\\,\\text{eV}$。\n$$E_{\\mathrm{saddle}, 2} = 0.710 - \\frac{(0.707 - 0.705)^2}{8(0.707 + 0.705 - 2 \\times 0.710)}$$\n$$E_{\\mathrm{saddle}, 2} = 0.710 - \\frac{(0.002)^2}{8(1.412 - 1.420)} = 0.710 - \\frac{0.000004}{8(-0.008)} = 0.710 + \\frac{0.000004}{0.064}$$\n$$E_{\\mathrm{saddle}, 2} = 0.710 + 0.0000625 = 0.7100625 \\,\\text{eV}$$\n\n**步骤2：吉布斯自由能垒的计算**\n\n吉布斯活化自由能 $\\Delta G^{\\ddagger}(T)$ 由电子鞍点能量与振动自由能校正之和给出：$\\Delta G^{\\ddagger}(T) = E_{\\mathrm{saddle}} + \\Delta F_{\\mathrm{vib}}^{\\ddagger}(T)$。温度为 $T = 600\\,\\text{K}$。\n\n对于路径1：\n$\\Delta F_{\\mathrm{vib,1}}^{\\ddagger}(600\\,\\text{K}) = 0.045\\,\\text{eV}$。\n$$\\Delta G_1^{\\ddagger} = E_{\\mathrm{saddle}, 1} + \\Delta F_{\\mathrm{vib,1}}^{\\ddagger} \\approx 0.7553636... + 0.045 = 0.8003636... \\,\\text{eV}$$\n\n对于路径2：\n$\\Delta F_{\\mathrm{vib,2}}^{\\ddagger}(600\\,\\text{K}) = 0.035\\,\\text{eV}$。\n$$\\Delta G_2^{\\ddagger} = E_{\\mathrm{saddle}, 2} + \\Delta F_{\\mathrm{vib,2}}^{\\ddagger} = 0.7100625 + 0.035 = 0.7450625 \\,\\text{eV}$$\n\n**步骤3：反应通量分数的计算**\n\n根据典则过渡态理论，路径 $i$ 的速率常数与 $\\exp(-\\Delta G_i^{\\ddagger} / k_B T)$ 成正比。包含简并度因子 $g_i$ 后，有效速率常数可写为：\n$$k_i = g_i \\cdot (\\text{pre-exponential terms}) \\cdot \\exp\\left(-\\frac{\\Delta G_i^{\\ddagger}}{k_B T}\\right)$$\n问题陈述指出，指前因子的唯一区别来自简并度，因此所有其他项（例如 $\\frac{k_B T}{h}$）对两条路径都是相同的，在计算比率时会相互抵消。\n\n总反应速率是各路径速率之和：$k_{\\mathrm{total}} = k_1 + k_2$。通过路径1的通量占总通量的分数，记为 $f_1$，是路径1的速率与总速率之比：\n$$f_1 = \\frac{k_1}{k_1 + k_2} = \\frac{g_1 \\exp\\left(-\\frac{\\Delta G_1^{\\ddagger}}{k_B T}\\right)}{g_1 \\exp\\left(-\\frac{\\Delta G_1^{\\ddagger}}{k_B T}\\right) + g_2 \\exp\\left(-\\frac{\\Delta G_2^{\\ddagger}}{k_B T}\\right)}$$\n为简化起见，我们可以将分子和分母同时除以路径1的项：\n$$f_1 = \\frac{1}{1 + \\frac{g_2}{g_1} \\frac{\\exp(-\\Delta G_2^{\\ddagger}/k_B T)}{\\exp(-\\Delta G_1^{\\ddagger}/k_B T)}} = \\frac{1}{1 + \\frac{g_2}{g_1} \\exp\\left(\\frac{\\Delta G_1^{\\ddagger} - \\Delta G_2^{\\ddagger}}{k_B T}\\right)}$$\n\n我们需要计算指数的参数。首先，我们确定热能 $k_B T$：\n$k_B = 8.617333262 \\times 10^{-5}\\,\\text{eV K}^{-1}$\n$T = 600\\,\\text{K}$\n$$k_B T = (8.617333262 \\times 10^{-5}) \\times 600 \\approx 0.051704\\,\\text{eV}$$\n\n接下来，我们求出吉布斯自由能垒的差值：\n$$\\Delta G_1^{\\ddagger} - \\Delta G_2^{\\ddagger} \\approx 0.8003636... - 0.7450625 = 0.0553011... \\,\\text{eV}$$\n\n简并度之比为 $\\frac{g_2}{g_1} = \\frac{6}{2} = 3$。\n\n现在我们可以计算分数 $f_1$：\n$$f_1 = \\left(1 + 3 \\cdot \\exp\\left(\\frac{0.0553011...}{0.051704}\\right)\\right)^{-1}$$\n$$f_1 \\approx \\left(1 + 3 \\cdot \\exp(1.070113)\\right)^{-1}$$\n$$f_1 \\approx (1 + 3 \\cdot 2.91570)^{-1}$$\n$$f_1 \\approx (1 + 8.74710)^{-1}$$\n$$f_1 \\approx (9.74710)^{-1} \\approx 0.10260$$\n\n将结果四舍五入到三位有效数字，我们得到 $0.103$。",
            "answer": "$$\\boxed{0.103}$$"
        }
    ]
}