{
    "hands_on_practices": [
        {
            "introduction": "晶体尺寸分布（CSD）建模的核心是求解群体平衡方程，这是一个描述晶体数量密度如何随时间演变的偏微分方程。本练习将介绍有限体积法，这是一种求解像 CSD 方程这样的守恒律的强大数值技术。通过构建一个简单的求解器，您将深入理解数值格式如何通过守恒性和正定性等性质来保证物理真实性，这对于精确的模拟至关重要。",
            "id": "4075782",
            "problem": "考虑计算地球化学中晶体尺寸分布模型所使用的晶体尺寸空间中的连续性方程，其中数密度 $n(L,t)$ 因尺寸增长率 $G(L,t)$ 和源项 $J(L,t)$ 而演化：\n$$\n\\frac{\\partial n}{\\partial t} + \\frac{\\partial}{\\partial L}\\big(G\\,n\\big) = J.\n$$\n此处 $L$ 表示晶体尺寸。您需要在 $L$ 空间中的均匀网格上设计一个有限体积离散化方案，该方案在封闭边界条件下能同时保持正定性和离散数守恒。此任务纯粹是数学和算法层面的：为这个带源项的标量守恒律推导、实现并测试一个守恒的、保持正定性的格式。\n\n基本原理：\n- 该方程是尺寸空间中的一个带源项的一维守恒律。\n- 对一个控制体积积分一个守恒律，得到的变化率等于通过边界的净通量加上内部源。\n\n设置与单位：\n- 尺寸域为 $L \\in [L_{\\min}, L_{\\max}]$，其中 $L_{\\min} = 0\\,\\mu\\mathrm{m}$ 且 $L_{\\max} = 100\\,\\mu\\mathrm{m}$。\n- 使用具有 $N$ 个单元和间距 $\\Delta L$ 的均匀网格，其中 $N = 100$，因此 $\\Delta L = 1\\,\\mu\\mathrm{m}$。\n- 时间单位为秒，即 $t$ 的单位为 $\\mathrm{s}$。\n- 数密度 $n$ 的单位为 $\\mathrm{\\#}\\,\\mu\\mathrm{m}^{-1}$。\n- 源项 $J$ 的单位为 $\\mathrm{\\#}\\,\\mu\\mathrm{m}^{-1}\\,\\mathrm{s}^{-1}$。\n- 增长率 $G$ 的单位为 $\\mu\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- 使用封闭边界条件，意味着在 $L=L_{\\min}$ 和 $L=L_{\\max}$ 处通量为零。\n\n设计要求：\n- 通过在每个单元上对守恒律进行积分，并根据面上 $G$ 的符号采用单调的迎风格式来近似面通量，从而推导有限体积更新公式。该设计必须确保离散格式：\n  - 在满足 Courant–Friedrichs–Lewy (CFL) 条件的情况下，保持 $n$ 的正定性。\n  - 在封闭边界条件下且无源项时，保持离散数守恒（即 $n$ 在整个域上的积分守恒），并在有源项时能再现正确的变化量。\n- 解释当 $G$ 可能在空间上变化且符号可正可负时，如何根据相邻单元的平均值计算 $L_{i+\\frac{1}{2}}$ 处的面通量。\n\n算法约束：\n- 根据面上 $G$ 的最大幅值选择一个时间步长 $\\Delta t$ 以满足 CFL 条件：如果 CFL 数小于或等于 1，则更新必须对 $n \\ge 0$ 保持正定性。\n- 在指定的网格上实现该格式，并采用封闭边界。\n\n测试套件：\n对于所有测试，将最终结果表示为从指定单位计算出的数值中导出的无量纲浮点数或布尔值。程序必须运行以下三种情况，每种情况都从一个初始条件开始，使用受 CFL 限制的时间步长步进到最终时间，并调整最后一步以精确达到最终时间。\n\n- 情况 A（恒定正增长，无源项）：\n  - $G(L) = +1\\,\\mu\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n  - $J(L) = 0$。\n  - 初始条件：$n(L,0) = \\exp\\!\\big(-\\frac{(L - 50)^2}{2\\cdot 10^2}\\big)$。\n  - 最终时间：$T = 45\\,\\mathrm{s}$。\n  - 计算正定性检查和如下定义的离散守恒误差：\n    $$\n    \\left| \\sum_i n_i(T)\\,\\Delta L - \\sum_i n_i(0)\\,\\Delta L - \\int_0^T \\int_{L_{\\min}}^{L_{\\max}} J(L)\\,\\mathrm{d}L\\,\\mathrm{d}t \\right|.\n    $$\n  - 在封闭边界下，预期的变化量为 $0$。\n\n- 情况 B（空间变化的正增长，均匀源项）：\n  - $G(L) = 0.5 + 0.5\\frac{L}{100}\\,\\mu\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n  - $J(L) = 0.001\\,\\mathrm{\\#}\\,\\mu\\mathrm{m}^{-1}\\,\\mathrm{s}^{-1}$ (恒定)。\n  - 初始条件：$n(L,0) = 0$。\n  - 最终时间：$T = 10\\,\\mathrm{s}$。\n  - 计算正定性检查和如下定义的离散守恒误差：\n    $$\n    \\left| \\sum_i n_i(T)\\,\\Delta L - \\sum_i n_i(0)\\,\\Delta L - \\int_0^T \\int_{L_{\\min}}^{L_{\\max}} J(L)\\,\\mathrm{d}L\\,\\mathrm{d}t \\right|.\n    $$\n  - 预期的增加量为 $J \\cdot (L_{\\max}-L_{\\min}) \\cdot T = 0.001 \\cdot 100 \\cdot 10 = 1.0$（积分后为无量纲的数值）。\n\n- 情况 C（恒定负增长，无源项）：\n  - $G(L) = -0.8\\,\\mu\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n  - $J(L) = 0$。\n  - 初始条件：$n(L,0) = \\exp\\!\\big(-\\frac{(L - 70)^2}{2\\cdot 8^2}\\big)$。\n  - 最终时间：$T = 40\\,\\mathrm{s}$。\n  - 计算正定性检查和如情况 A 中的离散守恒误差。\n\n通量计算要求：\n- 您必须在您的解决方案中明确解释，如何根据面上 $G$ 的符号决定的迎风选择，从相邻单元的平均值计算面通量 $F_{i+\\frac{1}{2}}$，并说明为什么这种方法能保证正定性。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序完全如下：\n  - $[\\text{positivity\\_A}, \\text{error\\_A}, \\text{positivity\\_B}, \\text{error\\_B}, \\text{positivity\\_C}, \\text{error\\_C}]$,\n  其中每个 positivity 值是布尔值，每个 error 值是浮点数。",
            "solution": "问题要求为控制晶体尺寸分布的一维连续性方程设计并实现一个有限体积格式，该方程由下式给出：\n$$\n\\frac{\\partial n}{\\partial t} + \\frac{\\partial}{\\partial L}\\big(G\\,n\\big) = J\n$$\n其中 $n(L,t)$ 是在时间 $t$ 尺寸为 $L$ 的晶体的数密度，$G(L,t)$ 是依赖于尺寸的增长率，$J(L,t)$ 是一个源项。该格式必须是守恒的、保持正定性的，并在具有封闭边界条件的均匀网格上实现。\n\n推导和实现过程如下。\n\n**1. 有限体积离散化**\n\n我们将空间域 $L \\in [L_{\\min}, L_{\\max}]$（其中 $L_{\\min} = 0\\,\\mu\\mathrm{m}$，$L_{\\max} = 100\\,\\mu\\mathrm{m}$）离散化为 $N=100$ 个均匀单元。每个单元 $C_i$ 由区间 $[L_{i-1/2}, L_{i+1/2}]$ 定义，$i=1, \\dots, N$。单元宽度为 $\\Delta L = (L_{\\max} - L_{\\min})/N = 1\\,\\mu\\mathrm{m}$。单元交界面位于 $L_{i+1/2} = L_{\\min} + (i+1)\\Delta L$，其中 $i=-1, 0, \\dots, N-1$（为便于实现，使用从零开始的索引 $i=0, \\dots, N-1$），使得 $L_{-1/2} = L_{\\min}$ 和 $L_{N-1/2} = L_{\\max}$。单元中心为 $L_i = L_{\\min} + (i+1/2)\\Delta L$。请注意，在典型的代码实现中（单元索引从0开始，$i=0, ..., N-1$），交界面是 $L_{i+1/2}$（$i=0, ..., N$），其中 $L_{1/2}$ 是第一个交界面，单元中心是 $L_i = (i+0.5)\\Delta L$。我们将使用后一种约定。\n\n我们将控制性偏微分方程（PDE）在一个单元 $C_i = [L_{i-1/2}, L_{i+1/2}]$ 上积分：\n$$\n\\int_{L_{i-1/2}}^{L_{i+1/2}} \\frac{\\partial n}{\\partial t} \\, \\mathrm{d}L + \\int_{L_{i-1/2}}^{L_{i+1/2}} \\frac{\\partial (Gn)}{\\partial L} \\, \\mathrm{d}L = \\int_{L_{i-1/2}}^{L_{i+1/2}} J \\, \\mathrm{d}L\n$$\n对第二项应用微积分基本定理，并假设 $n$ 足够光滑，我们得到：\n$$\n\\Delta L \\frac{\\mathrm{d} n_i}{\\mathrm{d} t} + \\big(Gn\\big)\\big|_{L_{i+1/2}} - \\big(Gn\\big)\\big|_{L_{i-1/2}} = J_i \\Delta L\n$$\n此处，$n_i(t) = \\frac{1}{\\Delta L} \\int_{L_{i-1/2}}^{L_{i+1/2}} n(L,t) \\, \\mathrm{d}L$ 是单元平均数密度，$J_i(t) = \\frac{1}{\\Delta L} \\int_{L_{i-1/2}}^{L_{i+1/2}} J(L,t) \\, \\mathrm{d}L$ 是单元平均源项，我们将其近似为 $J_i(t) \\approx J(L_i, t)$。项 $F(L, t) = G(L, t) n(L, t)$ 是晶体通量。该方程可以用数值通量 $F_{i\\pm 1/2}$ 来重写，该通量近似了单元交界面上的连续通量：\n$$\n\\frac{\\mathrm{d} n_i}{\\mathrm{d} t} = -\\frac{1}{\\Delta L} \\left( F_{i+1/2} - F_{i-1/2} \\right) + J_i\n$$\n这是一个关于单元平均值 $n_i$ 的半离散常微分方程组。\n\n**2. 数值通量和边界条件**\n\n为确保稳定性和正定性，我们采用一阶迎风格式。交界面处的通量取决于信息流动的方向，该方向由该交界面上增长率 $G$ 的符号决定。在单元 $i$（左侧）和单元 $i+1$（右侧）之间的交界面上的数值通量 $F_{i+1/2}$ 按如下方式计算：\n$$\nF_{i+1/2} =\n\\begin{cases}\nG_{i+1/2} \\, n_i  & \\text{if } G_{i+1/2} \\geq 0 \\\\\nG_{i+1/2} \\, n_{i+1} & \\text{if } G_{i+1/2}  0\n\\end{cases}\n$$\n其中 $G_{i+1/2} = G(L_{i+1/2})$。如果增长率为正，晶体从较小尺寸（单元 $i$）“生长”到较大尺寸（单元 $i+1$），因此单元 $i$ 中的状态决定了通量。反之，如果增长率为负（溶解），晶体从单元 $i+1$ “收缩”到单元 $i$，因此使用单元 $i+1$ 中的状态。这种选择确保了格式是单调的，并避免了非物理振荡。\n\n问题指定了封闭边界条件，意味着在域边界 $L_{\\min}$（交界面 $L_{1/2}$）和 $L_{\\max}$（交界面 $L_{N+1/2}$）处通量为零。这通过将边通量设置为零来实现：\n$$\nF_{1/2} = 0 \\quad \\text{and} \\quad F_{N+1/2} = 0\n$$\n\n**3. 全离散格式及其性质**\n\n我们使用时间步长为 $\\Delta t$ 的前向欧拉法进行时间离散化：\n$$\n\\frac{n_i^{k+1} - n_i^k}{\\Delta t} = -\\frac{1}{\\Delta L} \\left( F_{i+1/2}^k - F_{i-1/2}^k \\right) + J_i^k\n$$\n其中上标 $k$ 表示时间层 $t_k = k\\Delta t$。单元平均值 $n_i$ 的显式更新法则为：\n$$\nn_i^{k+1} = n_i^k - \\frac{\\Delta t}{\\Delta L} \\left( F_{i+1/2}^k - F_{i-1/2}^k \\right) + \\Delta t J_i^k\n$$\n\n**正定性保持：** 迎风通量公式是保持 $n_i$ 正定性的关键。为了证明这一点，我们将通量定义代入更新方程。让我们使用 $G$ 的正部和负部重写通量，其中 $G^+ = \\max(G, 0)$ 且 $G^- = \\min(G, 0)$：\n$$\nF_{i+1/2} = G_{i+1/2}^+ n_i + G_{i+1/2}^- n_{i+1}\n$$\n更新方程变为：\n$$\nn_i^{k+1} = n_i^k - \\frac{\\Delta t}{\\Delta L} \\left[ (G_{i+1/2}^+ n_i^k + G_{i+1/2}^- n_{i+1}^k) - (G_{i-1/2}^+ n_{i-1}^k + G_{i-1/2}^- n_i^k) \\right] + \\Delta t J_i^k\n$$\n根据各项乘以的单元平均值重新整理：\n$$\nn_i^{k+1} = n_i^k \\left(1 - \\frac{\\Delta t}{\\Delta L}(G_{i+1/2}^+ - G_{i-1/2}^-)\\right) + n_{i-1}^k \\left(\\frac{\\Delta t}{\\Delta L}G_{i-1/2}^+\\right) + n_{i+1}^k \\left(-\\frac{\\Delta t}{\\Delta L}G_{i+1/2}^-\\right) + \\Delta t J_i^k\n$$\n为使 $n_i^{k+1}$ 保持非负，假设对所有 $j$ 都有 $n_j^k \\ge 0$ 且 $J_i^k \\ge 0$，则 $n_j^k$各项的系数必须都为非负。由于 $G_{i-1/2}^+ \\ge 0$ 且 $G_{i+1/2}^- \\le 0$，因此 $n_{i-1}^k$ 和 $n_{i+1}^k$ 的系数是非负的。正定性因而取决于 $n_i^k$ 的系数是否为非负：\n$$\n1 - \\frac{\\Delta t}{\\Delta L}(G_{i+1/2}^+ - G_{i-1/2}^-) \\ge 0 \\implies \\Delta t \\le \\frac{\\Delta L}{G_{i+1/2}^+ - G_{i-1/2}^-}\n$$\n这个条件必须对所有单元 $i$ 成立。在所提供的所有测试用例中，$G$ 的符号不发生改变，对于这些特殊情况，该条件可以简化。如果 G>0，则 $G^-=0$，条件变为 $\\Delta t \\le \\Delta L / G_{i+1/2}$。如果 G0，则 $G^+=0$，条件变为 $\\Delta t \\le \\Delta L/(-G_{i-1/2}) = \\Delta L/|G_{i-1/2}|$。这两种情况都可以由 Courant–Friedrichs–Lewy (CFL) 条件所概括：\n$$\n\\Delta t \\le \\frac{\\Delta L}{\\max_{L} |G(L)|}\n$$\n这对应于问题中指定的 CFL 数 $C = \\frac{\\max|G|\\Delta t}{\\Delta L} \\le 1$。\n\n**离散守恒性：** 为了验证守恒性，我们将全离散更新方程对所有单元 $i=1, \\dots, N$ 求和：\n$$\n\\sum_{i=1}^{N} n_i^{k+1} \\Delta L = \\sum_{i=1}^{N} n_i^{k} \\Delta L - \\Delta t \\sum_{i=1}^{N} (F_{i+1/2}^k - F_{i-1/2}^k) + \\Delta t \\sum_{i=1}^{N} J_i^k \\Delta L\n$$\n通量之和构成一个伸缩级数：\n$$\n\\sum_{i=1}^{N} (F_{i+1/2}^k - F_{i-1/2}^k) = F_{N+1/2}^k - F_{1/2}^k\n$$\n应用封闭边界条件 $F_{1/2}^k = 0$ 和 $F_{N+1/2}^k = 0$，此和为零。晶体总数 $\\mathcal{N}^k = \\sum_{i=1}^{N} n_i^k \\Delta L$ 的方程变为：\n$$\n\\mathcal{N}^{k+1} = \\mathcal{N}^{k} + \\Delta t \\sum_{i=1}^{N} J_i^k \\Delta L\n$$\n这表明从一个时间步到下一个时间步，离散晶体总数的变化量恰好等于该时间步内源项所增加的晶体总数。在无源项（$J=0$）的情况下，晶体总数是精确守恒的，即 $\\mathcal{N}^{k+1} = \\mathcal{N}^{k}$。因此，该格式是离散守恒的。\n\n推导出的数值格式满足所有要求：它基于有限体积公式，使用保持正定性的迎风通量，遵守封闭边界条件，并且是离散守恒的。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the crystal size distribution problem for three test cases.\n    \"\"\"\n\n    def run_simulation(G_func, J_func, n0_func, T_final, N, L_min, L_max):\n        \"\"\"\n        Runs a single simulation of the finite volume scheme.\n\n        Args:\n            G_func (callable): Growth rate function G(L).\n            J_func (callable): Source term function J(L).\n            n0_func (callable): Initial condition function n(L, 0).\n            T_final (float): Final simulation time.\n            N (int): Number of grid cells.\n            L_min (float): Minimum size of the domain.\n            L_max (float): Maximum size of the domain.\n\n        Returns:\n            tuple: A tuple containing (positivity_check, conservation_error).\n        \"\"\"\n        # 1. Setup Grid\n        dL = (L_max - L_min) / N\n        L_centers = L_min + (np.arange(N) + 0.5) * dL\n        L_faces = L_min + np.arange(N + 1) * dL\n\n        # 2. Set Initial Condition and Total Source\n        n = n0_func(L_centers)\n        n_initial_total = np.sum(n * dL)\n        \n        # The source J is constant in space and time for the relevant case\n        # allowing for direct calculation of the total source integral.\n        # J_val = 0 for cases A and C.\n        j_val_at_center_0 = J_func(L_centers)[0] if N > 0 else 0\n        total_source_integral = j_val_at_center_0 * (L_max - L_min) * T_final\n        \n        # 3. Determine Time Step from CFL condition\n        G_at_faces = G_func(L_faces)\n        G_max = np.max(np.abs(G_at_faces))\n        \n        # CFL number = 1 for positivity. We use 1.0.\n        # If G_max is zero, dt can be any value, T_final will suffice.\n        if G_max == 0:\n            dt = T_final\n        else:\n            dt = dL / G_max\n        \n        # Adjust dt to hit T_final exactly\n        num_steps = int(np.ceil(T_final / dt))\n        if num_steps == 0:\n            num_steps = 1\n        dt_actual = T_final / num_steps\n\n        # 4. Main Time-Stepping Loop\n        for _ in range(num_steps):\n            # Calculate fluxes at internal faces (F_1/2 to F_N-1/2)\n            # In 0-indexed python, this corresponds to F[1] through F[N-1]\n            F = np.zeros(N + 1)\n            G_at_faces = G_func(L_faces)\n            \n            # Using a loop for clarity, for N=100 performance is not critical\n            for i in range(1, N): # Corresponds to interfaces L_{1/2} to L_{N-1/2}\n                G_val = G_at_faces[i]\n                if G_val >= 0:\n                    F[i] = G_val * n[i - 1] # Upwind from cell i-1\n                else:\n                    F[i] = G_val * n[i]     # Upwind from cell i\n            \n            # Boundary fluxes F[0] (at L_min) and F[N] (at L_max) are zero\n            \n            # Update cell averages using forward Euler\n            J_at_centers = J_func(L_centers)\n            n_new = n - (dt_actual / dL) * (F[1:] - F[:-1]) + dt_actual * J_at_centers\n            n = n_new\n\n        # 5. Compute Final Metrics\n        n_final = n\n        \n        # Positivity check: all elements of n must be non-negative\n        positivity_check = bool(np.all(n_final >= 0.0))\n        \n        # Conservation error\n        n_final_total = np.sum(n_final * dL)\n        \n        conservation_error = abs(n_final_total - n_initial_total - total_source_integral)\n        \n        return positivity_check, conservation_error\n\n    # --- Test Case Definitions ---\n    N = 100\n    L_min = 0.0\n    L_max = 100.0\n    \n    # Case A\n    G_A = lambda L: np.full_like(L, 1.0, dtype=float)\n    J_A = lambda L: np.zeros_like(L, dtype=float)\n    n0_A = lambda L: np.exp(-(L - 50.0)**2 / (2.0 * 10.0**2))\n    T_A = 45.0\n\n    # Case B\n    G_B = lambda L: 0.5 + 0.5 * L / 100.0\n    J_B = lambda L: np.full_like(L, 0.001, dtype=float)\n    n0_B = lambda L: np.zeros_like(L, dtype=float)\n    T_B = 10.0\n\n    # Case C\n    G_C = lambda L: np.full_like(L, -0.8, dtype=float)\n    J_C = lambda L: np.zeros_like(L, dtype=float)\n    n0_C = lambda L: np.exp(-(L - 70.0)**2 / (2.0 * 8.0**2))\n    T_C = 40.0\n\n    test_cases_params = [\n        (G_A, J_A, n0_A, T_A),\n        (G_B, J_B, n0_B, T_B),\n        (G_C, J_C, n0_C, T_C),\n    ]\n\n    results = []\n    for g_func, j_func, n0_func, T_val in test_cases_params:\n        pos, err = run_simulation(g_func, j_func, n0_func, T_val, N, L_min, L_max)\n        results.extend([pos, err])\n    \n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然正演模拟可以根据已知的动力学速率预测 CSD，但地球化学家的一个关键任务是反过来：从观测到的 CSD 推断动力学速率。本练习将探讨矩量法，这是一种将完整的 CSD 转化为几个关键统计指标的经典技术。您将推导这些矩量（如晶体总数和平均尺寸）的变化率如何直接关联到潜在的成核速率 $J$ 和生长速率 $G$，从而为定量分析提供一个强大的工具。",
            "id": "4075728",
            "problem": "使用晶体尺寸分布 (CSD) 框架来分析硅酸盐熔体中的一个晶体群。令 $n(L,t)$ 表示在时间 $t$、线性尺寸为 $L$ 的晶体的数密度，其中 $L \\geq 0$。假设初次成核速率 $J$ 和线性生长速率 $G$ 均为常数，且不存在聚集、破碎或溶解。尺寸分布的演化由尺寸空间中的数量守恒决定：晶体以速率 $G$ 在 $L$ 上平移，新晶体通过成核在 $L=0$ 处注入。定义 $k$ 阶矩 $m_k(t) = \\int_{0}^{\\infty} L^{k} n(L,t)\\,\\mathrm{d}L$ 和平均晶体长度 $\\langle L \\rangle(t) = m_1(t)/m_0(t)$。\n\n仅从 $n(L,t)$ 的守恒陈述、$m_k$ 和 $\\langle L \\rangle$ 的定义以及 $J$ 和 $G$ 为常数的假设出发，推导在某一瞬间 $t^{\\ast}$ 的线性生长速率 $G$ 的闭式表达式，该表达式用可测量的物理量 $m_0(t^{\\ast})$、$\\langle L \\rangle(t^{\\ast})$、时间导数 $\\mathrm{d}\\langle L \\rangle/\\mathrm{d}t\\big|_{t^{\\ast}}$ 以及成核速率 $J$ (在这些条件下等于 $\\mathrm{d}m_0/\\mathrm{d}t$) 来表示。然后，使用在 $t^{\\ast}$ 时刻实验测得的以下数值计算 $G$：\n- $m_0(t^{\\ast}) = 1.045 \\times 10^{9}\\ \\mathrm{m}^{-3}$，\n- $\\langle L \\rangle(t^{\\ast}) = 34.7\\ \\mathrm{\\mu m}$，\n- $\\mathrm{d}\\langle L \\rangle/\\mathrm{d}t\\big|_{t^{\\ast}} = 0.1185\\ \\mathrm{\\mu m}\\,\\mathrm{s}^{-1}$，\n- $J = \\mathrm{d}m_0/\\mathrm{d}t\\big|_{t^{\\ast}} = 2.13 \\times 10^{7}\\ \\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$。\n\n将 $G$ 的最终值以微米/秒 ($\\mathrm{\\mu m}\\,\\mathrm{s}^{-1}$) 为单位表示，并将答案四舍五入到四位有效数字。在您的推导中，请明确说明 $L=0$ 处边界条件的作用，并解释它是如何进入矩方程以及最终的 $G$ 表达式的。",
            "solution": "我们从晶体尺寸分布 (CSD) 的尺寸空间中的数量守恒出发。对于恒定的线性生长速率 $G$ 和在 $L=0$ 处的初次成核，尺寸分布通过在 $L0$ 的范围内以速率 $G$ 在 $L$ 上平移而演化，并且晶体以速率 $J$ 在 $L=0$ 处注入。一个明确表示边界效应的标准形式是\n$$\n\\frac{\\partial n(L,t)}{\\partial t} + G\\,\\frac{\\partial n(L,t)}{\\partial L} = 0,\\quad L0,\n$$\n以及一个在 $L=0$ 处的边界条件，该条件强制了通过成核注入新晶体，\n$$\nG\\,n(0,t) = J.\n$$\n该边界条件表明，离开尺寸空间中 $L=0$ 位置的晶体对流通量 $G n(0,t)$ 等于成核速率 $J$，从而确保初次成核在 $L=0$ 处充当一个源。\n\n定义 $k$ 阶矩\n$$\nm_k(t) = \\int_{0}^{\\infty} L^{k}\\,n(L,t)\\,\\mathrm{d}L,\n$$\n并注意平均尺寸为 $\\langle L \\rangle(t) = \\frac{m_1(t)}{m_0(t)}$。为了获得矩演化方程，将守恒方程乘以 $L^{k}$ 并在 $L\\in[0,\\infty)$ 上积分：\n$$\n\\frac{\\mathrm{d} m_k}{\\mathrm{d} t} + G \\int_{0}^{\\infty} L^{k}\\,\\frac{\\partial n}{\\partial L}\\,\\mathrm{d}L = 0.\n$$\n该积分项通过分部积分法处理：\n$$\n\\int_{0}^{\\infty} L^{k}\\,\\frac{\\partial n}{\\partial L}\\,\\mathrm{d}L = \\left[L^{k} n(L,t)\\right]_{0}^{\\infty} - k \\int_{0}^{\\infty} L^{k-1} n(L,t)\\,\\mathrm{d}L.\n$$\n假设当 $L \\to \\infty$ 时，$n(L,t) \\to 0$ 的速度足够快，则上边界项消失。在下边界 $L=0$ 处，当 $k\\geq 1$ 时，该项等于 $0$，但当 $k=0$ 时，该项等于 $-n(0,t)$。因此：\n\n- 对于 $k \\geq 1$，\n$$\n\\frac{\\mathrm{d} m_k}{\\mathrm{d} t} - G\\,k\\,m_{k-1} = 0 \\quad \\Rightarrow \\quad \\frac{\\mathrm{d} m_k}{\\mathrm{d} t} = k\\,G\\,m_{k-1}.\n$$\n\n- 对于 $k = 0$，\n$$\n\\frac{\\mathrm{d} m_0}{\\mathrm{d} t} + G \\left( - n(0,t) \\right) = 0 \\quad \\Rightarrow \\quad \\frac{\\mathrm{d} m_0}{\\mathrm{d} t} = G\\,n(0,t).\n$$\n应用边界条件 $G\\,n(0,t) = J$，我们得到\n$$\n\\frac{\\mathrm{d} m_0}{\\mathrm{d} t} = J.\n$$\n\n矩方程明确显示了 $L=0$ 处边界条件的作用：它将边界通量项 $G n(0,t)$ 转换为成核速率 $J$，使得零阶矩根据 $\\mathrm{d} m_0/\\mathrm{d} t = J$ 演化，并确保高阶矩的动力学完全由尺寸空间中的平移驱动。如果不强制执行 $G n(0,t) = J$，零阶矩的演化将依赖于未知的边界值 $n(0,t)$，并且后续的推导将无法得出用可观测量表示的闭式表达式。\n\n我们现在使用 $k=1$ 的一阶矩方程：\n$$\n\\frac{\\mathrm{d} m_1}{\\mathrm{d} t} = 1 \\cdot G \\cdot m_0 = G\\,m_0.\n$$\n平均尺寸为 $\\langle L \\rangle = \\frac{m_1}{m_0}$，因此根据商法则，\n$$\n\\frac{\\mathrm{d} \\langle L \\rangle}{\\mathrm{d} t} = \\frac{\\frac{\\mathrm{d} m_1}{\\mathrm{d} t}\\, m_0 - m_1\\,\\frac{\\mathrm{d} m_0}{\\mathrm{d} t}}{m_0^{2}} = \\frac{G\\,m_0^{2} - m_0\\,\\langle L \\rangle\\, J}{m_0^{2}} = G - \\frac{\\langle L \\rangle\\,J}{m_0}.\n$$\n求解 $G$ 可得所需的用可观测量表示的表达式：\n$$\nG = \\frac{\\mathrm{d} \\langle L \\rangle}{\\mathrm{d} t} + \\frac{\\langle L \\rangle\\,J}{m_0}.\n$$\n\n我们现在使用所提供的数据计算在 $t^{\\ast}$ 时刻的 $G$。首先计算比值 $\\frac{J}{m_0}$：\n$$\n\\frac{J}{m_0} = \\frac{2.13 \\times 10^{7}\\ \\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}}{1.045 \\times 10^{9}\\ \\mathrm{m}^{-3}} = \\left(\\frac{2.13}{1.045}\\right) \\times 10^{-2}\\ \\mathrm{s}^{-1} \\approx 2.03827751196172 \\times 10^{-2}\\ \\mathrm{s}^{-1}.\n$$\n乘以 $\\langle L \\rangle$：\n$$\n\\frac{\\langle L \\rangle\\,J}{m_0} \\approx 34.7\\ \\mathrm{\\mu m} \\times 2.03827751196172 \\times 10^{-2}\\ \\mathrm{s}^{-1} \\approx 0.707282296650717\\ \\mathrm{\\mu m}\\,\\mathrm{s}^{-1}.\n$$\n加上 $\\frac{\\mathrm{d} \\langle L \\rangle}{\\mathrm{d} t}$：\n$$\nG \\approx 0.1185\\ \\mathrm{\\mu m}\\,\\mathrm{s}^{-1} + 0.707282296650717\\ \\mathrm{\\mu m}\\,\\mathrm{s}^{-1} = 0.825782296650717\\ \\mathrm{\\mu m}\\,\\mathrm{s}^{-1}.\n$$\n四舍五入到四位有效数字，并以微米/秒为单位表示，可得\n$$\nG \\approx 0.8258\\ \\mathrm{\\mu m}\\,\\mathrm{s}^{-1}.\n$$\n\n最后，关于边界条件，该推导的关键在于正确处理 $L=0$ 处的边界。将成核建模为边界通量 $G n(0,t) = J$ 可以确保零阶矩服从 $\\mathrm{d} m_0/\\mathrm{d} t = J$，且高阶矩按 $\\mathrm{d} m_k/\\mathrm{d} t = k G m_{k-1}$ 演化。如果边界以不同方式处理（例如，如果成核表示为通过 $L$ 中的狄拉克δ项的体积源而未施加通量边界条件，或者如果存在溶解导致在 $L=0$ 处形成一个汇），则矩方程中的边界项将会改变。这将改变 $\\mathrm{d} \\langle L \\rangle/\\mathrm{d} t$ 和 $G$ 之间的关系，可能引入涉及 $n(0,t)$ 或汇/源速率的附加项。同样，测量域的截断（有限的最大可探测尺寸）会重新引入一个非零的上边界项 $\\left[L^{k} n\\right]_{0}^{L_{\\max}}$，如果不加以考虑，这可能会导致 $G$ 的估计产生偏差。因此，在 $L=0$ 处一个物理上一致且明确陈述的边界条件，对于获得用可观测量表示的 $G$ 的闭式表达式至关重要。",
            "answer": "$$\\boxed{0.8258}$$"
        },
        {
            "introduction": "来自薄片或颗粒计数器的真实 CSD 数据由分箱计数组成，这些计数不可避免地会受到统计噪声的影响，尤其是在晶体数量稀少的分布尾部。本练习解决了计数统计中固有的异方差性（即方差不恒定）问题，并阐明了为什么加权线性回归对于准确的模型拟合至关重要 。通过实现这一技术，您将学会如何正确地估计 CSD 参数及其置信区间，确保您的科学结论在统计上是稳健的。",
            "id": "4075737",
            "problem": "您的任务是实现一个程序，在一个科学上真实的晶体尺寸分布分析中，使用加权线性回归来估计对数转换后的晶体布居密度与晶体尺寸关系的斜率的不确定性。具体来说，请考虑分箱的晶体尺寸数据，其中箱中心由 $L_i$ 表示（单位为毫米），箱宽由 $\\Delta L_i$ 表示（单位为毫米），观测到的箱内计数由 $n_i$ 表示（无量纲）。箱 $i$ 中单位尺寸的晶体布居密度为计数除以箱宽，即 $n_i / \\Delta L_i$，其自然对数被建模为尺寸的线性函数。由于计数统计的原因，计数变异性是异方差的，必须使用基于计数过程中经过充分检验的事实的适当加权方案来解决此问题。\n\n您的程序必须从以下基本前提开始：箱内计数 $n_i$ 由一个计数过程生成，其中变异性随平均计数的增加而增加。在使用自然对数来线性化关系的情况下，必须对转换后观测值的变异性进行近似，而不能依赖于等方差假设。您必须对 $\\ln(n_i / \\Delta L_i)$ 与 $L_i$ 进行加权线性回归，其权重反映了由计数过程和对数转换所隐含的方差的倒数，并且该权重仅由观测到的 $n_i$ 和基本近似确定。然后，您必须使用大样本正态近似，在置信水平 $c$ 下计算斜率的双侧置信区间，并报告斜率和区间界限。斜率必须以 $\\mathrm{mm}^{-1}$ 为单位表示，其置信区间界限也必须以 $\\mathrm{mm}^{-1}$ 为单位。您的程序必须以纯数值形式生成结果；不要打印单位字符串。\n\n以一种普遍适用、数学上和逻辑上严谨的方式实现以下步骤：\n- 构建转换后的响应 $y_i = \\ln(n_i / \\Delta L_i)$。\n- 为每个观测值采用一个权重，该权重反映由计数过程和对数转换引起的异方差性，且仅取决于 $n_i$。\n- 对 $y_i$ 与 $L_i$ 拟合一个加权线性模型，以获得斜率和截距。\n- 使用置信水平为 $c$ 的大样本正态近似，计算反映加权和异方差性的斜率的双侧置信区间。\n\n测试套件：\n将您的程序应用于以下参数集，每个参数集的置信水平均为 $c = 0.95$。\n\n情况 $1$（具有不同箱宽和高计数的一般情况）：\n- $L = [\\,0.25,\\,0.50,\\,0.75,\\,1.00,\\,1.25,\\,1.50,\\,1.75,\\,2.00\\,]$，单位 $\\mathrm{mm}$。\n- $\\Delta L = [\\,0.20,\\,0.20,\\,0.20,\\,0.20,\\,0.20,\\,0.25,\\,0.25,\\,0.30\\,]$，单位 $\\mathrm{mm}$。\n- $n = [\\,520,\\,400,\\,310,\\,250,\\,195,\\,150,\\,118,\\,90\\,]$。\n\n情况 $2$（具有小计数和可变箱宽的边界情况）：\n- $L = [\\,0.10,\\,0.30,\\,0.60,\\,1.00,\\,1.50,\\,2.20\\,]$，单位 $\\mathrm{mm}$。\n- $\\Delta L = [\\,0.10,\\,0.10,\\,0.20,\\,0.20,\\,0.30,\\,0.40\\,]$，单位 $\\mathrm{mm}$。\n- $n = [\\,12,\\,9,\\,7,\\,5,\\,4,\\,3\\,]$。\n\n情况 $3$（密度在不同尺寸上近似恒定且箱宽均匀的边缘情况）：\n- $L = [\\,0.50,\\,0.90,\\,1.30,\\,1.70,\\,2.10,\\,2.50\\,]$，单位 $\\mathrm{mm}$。\n- $\\Delta L = [\\,0.40,\\,0.40,\\,0.40,\\,0.40,\\,0.40,\\,0.40\\,]$，单位 $\\mathrm{mm}$。\n- $n = [\\,100,\\,98,\\,102,\\,99,\\,101,\\,100\\,]$。\n\n情况 $4$（尺寸范围和箱宽变化剧烈的边缘情况）：\n- $L = [\\,0.20,\\,0.40,\\,0.80,\\,1.60,\\,3.20\\,]$，单位 $\\mathrm{mm}$。\n- $\\Delta L = [\\,0.20,\\,0.20,\\,0.40,\\,0.80,\\,1.60\\,]$，单位 $\\mathrm{mm}$。\n- $n = [\\,800,\\,500,\\,280,\\,120,\\,40\\,]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个结果对应一个测试用例，并且本身是一个包含三个浮点数的列表，顺序为 $[\\text{斜率},\\text{下界},\\text{上界}]$。输出不得包含空格。例如，总输出格式必须为 $[[m_1,\\ell_1,u_1],[m_2,\\ell_2,u_2],[m_3,\\ell_3,u_3],[m_4,\\ell_4,u_4]]$，其中每个 $m_i$、$\\ell_i$ 和 $u_i$ 都是浮点数，代表以 $\\mathrm{mm}^{-1}$ 为单位的值。",
            "solution": "用户要求编写一个程序，使用加权线性回归来估计对数转换的晶体尺寸分布（CSD）模型的斜率及其置信区间。该问题在科学上和数学上都是适定的。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n- **模型：** 假设晶体布居密度的自然对数 $\\ln(n_i / \\Delta L_i)$ 与晶体尺寸 $L_i$ 之间存在线性关系。\n- **自变量 ($x_i$)：** 箱中心 $L_i$，单位为 $\\mathrm{mm}$。\n- **因变量 ($y_i$)：** 布居密度的自然对数，$y_i = \\ln(n_i / \\Delta L_i)$。\n- **布居密度：** $n_i / \\Delta L_i$，其中 $n_i$ 是无量纲的观测箱内计数，$\\Delta L_i$ 是箱宽，单位为 $\\mathrm{mm}$。\n- **加权方案：** 要求进行加权线性回归，权重需反映来自计数过程和对数转换的异方差性。权重必须根据观测计数 $n_i$ 确定。\n- **任务：** 计算 $y_i$ 对 $x_i=L_i$ 回归的斜率 $m$ 及其双侧置信区间（下界 $\\ell$，上界 $u$）。\n- **置信水平：** $c = 0.95$。\n- **近似方法：** 对置信区间使用大样本正态近似。\n- **输出单位：** 斜率和区间界限的单位为 $\\mathrm{mm}^{-1}$。\n- **测试用例：** 提供了四组关于 $L$、$\\Delta L$ 和 $n$ 的特定数据集。\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题是有效的。\n- **科学依据：** 该问题是统计分析在地球化学中的一个标准应用。CSD分析是一种基本工具。假设箱内计数 $n_i$ 服从计数过程（意味着泊松统计，其中方差近似于均值）是这类分析的基石。随后对对数转换变量使用不确定性传播，并使用加权最小二乘法来处理由此产生的异方差性，是一种严谨且成熟的方法论。\n- **适定性：** 问题提供了推导唯一、有意义解所需的所有必要数据和约束。方法的选择（WLS，正态近似）已经指定，没有歧义。\n- **客观性：** 问题使用精确、客观和正式的科学语言进行描述。\n\n**第 3 步：结论与行动**\n该问题是有效的，可以按所述方法解决。\n\n### 基于原理的解决方案\n\n目标是执行形式为 $y_i = m x_i + b$ 的加权线性回归，其中 $x_i = L_i$ 是晶体尺寸，$y_i = \\ln(n_i / \\Delta L_i)$ 是对数布居密度。关键在于根据数据的统计特性推导出适当的权重 $w_i$。\n\n**1. 权重的推导**\n箱内计数 $n_i$ 代表观测到的事件（晶体落入某个尺寸箱）的数量。此类计数过程基本上由泊松分布描述。均值为 $\\lambda$ 的泊松分布随机变量的一个关键特性是其方差也为 $\\lambda$。因此，对于计数 $n_i$，我们有 $\\mathrm{Var}(n_i) = E[n_i]$。在没有 $E[n_i]$ 完整模型的情况下，一个标准且稳健的近似方法是使用观测到的计数本身作为其均值和方差的估计：\n$$ \\mathrm{Var}(n_i) \\approx n_i $$\n箱 $i$ 中的布居密度为 $N_i = n_i / \\Delta L_i$。由于 $\\Delta L_i$ 对每个箱来说是一个固定的常数，因此 $N_i$ 的方差为：\n$$ \\mathrm{Var}(N_i) = \\mathrm{Var}\\left(\\frac{n_i}{\\Delta L_i}\\right) = \\frac{1}{(\\Delta L_i)^2} \\mathrm{Var}(n_i) \\approx \\frac{n_i}{(\\Delta L_i)^2} $$\n回归是在对数转换后的变量 $y_i = \\ln(N_i)$ 上进行的。为了找到 $y_i$ 的方差，我们使用不确定性传播公式。对于函数 $f(X)$，方差的一阶近似为 $\\mathrm{Var}(f(X)) \\approx (f'(E[X]))^2 \\mathrm{Var}(X)$。在这里，$f(N_i) = \\ln(N_i)$，所以 $f'(N_i) = 1/N_i$。\n$$ \\mathrm{Var}(y_i) = \\mathrm{Var}(\\ln(N_i)) \\approx \\left(\\frac{1}{E[N_i]}\\right)^2 \\mathrm{Var}(N_i) $$\n使用观测值 $N_i$ 和 $n_i$ 作为其期望的估计，我们得到：\n$$ \\mathrm{Var}(y_i) \\approx \\left(\\frac{1}{N_i}\\right)^2 \\mathrm{Var}(N_i) \\approx \\left(\\frac{\\Delta L_i}{n_i}\\right)^2 \\left(\\frac{n_i}{(\\Delta L_i)^2}\\right) = \\frac{1}{n_i} $$\n这个简洁而优雅的结果表明，对数转换后的布居密度的方差与原始计数成反比。\n\n在加权线性回归中，最优权重 $w_i$ 是每个观测值方差的倒数。因此，正确的加权方案是：\n$$ w_i = \\frac{1}{\\mathrm{Var}(y_i)} \\approx n_i $$\n这与问题中权重仅取决于 $n_i$ 的要求相符。\n\n**2. 加权线性回归公式**\n斜率 $m$ 和截距 $b$ 是通过最小化加权残差平方和 $S = \\sum_{i} w_i (y_i - (m x_i + b))^2$ 来找到的。斜率 $m$ 的解由以下公式给出：\n$$ m = \\frac{ (\\sum w_i) (\\sum w_i x_i y_i) - (\\sum w_i x_i) (\\sum w_i y_i) }{ (\\sum w_i) (\\sum w_i x_i^2) - (\\sum w_i x_i)^2 } $$\n为便于计算，我们定义以下总和，其中 $x_i = L_i$ 和 $y_i = \\ln(n_i/\\Delta L_i)$：\n- $S_w = \\sum w_i$\n- $S_{wx} = \\sum w_i x_i$\n- $S_{wy} = \\sum w_i y_i$\n- $S_{wxx} = \\sum w_i x_i^2$\n- $S_{wxy} = \\sum w_i x_i y_i$\n\n那么斜率为：\n$$ m = \\frac{S_w S_{wxy} - S_{wx} S_{wy}}{S_w S_{wxx} - (S_{wx})^2} $$\n\n**3. 斜率的置信区间**\n当方差 $\\mathrm{Var}(y_i) = \\sigma_i^2$ 已知时（或像本例中一样近似，其中 $\\sigma_i^2=1/w_i$），估计斜率 $m$ 的方差由以下公式给出：\n$$ \\mathrm{Var}(m) = \\frac{1}{\\sum w_i (x_i - \\bar{x}_w)^2} $$\n其中 $\\bar{x}_w = (\\sum w_i x_i) / (\\sum w_i)$ 是 $x_i$ 的加权平均值。分母可以计算为：\n$$ \\sum w_i (x_i - \\bar{x}_w)^2 = S_{wxx} - \\frac{(S_{wx})^2}{S_w} $$\n斜率的标准误 $SE(m)$ 是其方差的平方根：\n$$ SE(m) = \\sqrt{\\mathrm{Var}(m)} = \\left( S_{wxx} - \\frac{(S_{wx})^2}{S_w} \\right)^{-1/2} $$\n使用大样本正态近似，在置信水平 $c$ 下，斜率 $m$ 的双侧置信区间构造如下：\n$$ [ \\ell, u ] = [ m - z_{\\alpha/2} \\cdot SE(m), \\quad m + z_{\\alpha/2} \\cdot SE(m) ] $$\n其中 $\\alpha = 1 - c$。对于 $c = 0.95$，我们有 $\\alpha = 0.05$，来自标准正态分布的临界值为 $z_{\\alpha/2} = z_{0.025} \\approx 1.95996$。\n\n**4. 算法摘要**\n对于每个测试用例：\n1.  定义向量 $x_i = L_i$、$n_i$ 和 $\\Delta L_i$。\n2.  计算转换后的响应变量 $y_i = \\ln(n_i / \\Delta L_i)$。\n3.  设置权重 $w_i = n_i$。\n4.  计算五个总和：$S_w$、$S_{wx}$、$S_{wy}$、$S_{wxx}$、$S_{wxy}$。\n5.  使用其公式计算斜率 $m$。\n6.  计算斜率的标准误 $SE(m)$。\n7.  确定 $95\\%$ 置信区间的临界值 $z_{0.025}$。\n8.  计算下界 $\\ell = m - z_{0.025} \\cdot SE(m)$ 和上界 $u = m + z_{0.025} \\cdot SE(m)$。\n9.  返回三元组 $[m, \\ell, u]$。\n此过程将为所有提供的测试用例实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the slope and confidence interval for log-transformed crystal size\n    distribution data using weighted linear regression.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": np.array([0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75, 2.00]),\n            \"dL\": np.array([0.20, 0.20, 0.20, 0.20, 0.20, 0.25, 0.25, 0.30]),\n            \"n\": np.array([520, 400, 310, 250, 195, 150, 118, 90]),\n            \"c\": 0.95\n        },\n        {\n            \"L\": np.array([0.10, 0.30, 0.60, 1.00, 1.50, 2.20]),\n            \"dL\": np.array([0.10, 0.10, 0.20, 0.20, 0.30, 0.40]),\n            \"n\": np.array([12, 9, 7, 5, 4, 3]),\n            \"c\": 0.95\n        },\n        {\n            \"L\": np.array([0.50, 0.90, 1.30, 1.70, 2.10, 2.50]),\n            \"dL\": np.array([0.40, 0.40, 0.40, 0.40, 0.40, 0.40]),\n            \"n\": np.array([100, 98, 102, 99, 101, 100]),\n            \"c\": 0.95\n        },\n        {\n            \"L\": np.array([0.20, 0.40, 0.80, 1.60, 3.20]),\n            \"dL\": np.array([0.20, 0.20, 0.40, 0.80, 1.60]),\n            \"n\": np.array([800, 500, 280, 120, 40]),\n            \"c\": 0.95\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        dL = case[\"dL\"]\n        n = case[\"n\"]\n        c = case[\"c\"]\n\n        # Step 1: Define variables for the regression\n        # Independent variable x is crystal size L\n        x = L\n        # Dependent variable y is log population density\n        # Population density N = n / dL\n        y = np.log(n / dL)\n        \n        # Step 2: Determine weights\n        # Based on Poisson counting statistics and propagation of uncertainty for\n        # the log transform, Var(ln(N)) is approx 1/n.\n        # Weights w are the inverse of the variance.\n        w = n\n\n        # Step 3: Calculate sums for weighted linear regression\n        S_w = np.sum(w)\n        S_wx = np.sum(w * x)\n        S_wy = np.sum(w * y)\n        S_wxx = np.sum(w * x * x)\n        S_wxy = np.sum(w * x * y)\n\n        # Step 4: Calculate the slope (m) of the weighted regression\n        numerator_m = S_w * S_wxy - S_wx * S_wy\n        denominator_m = S_w * S_wxx - S_wx**2\n        \n        # Handle potential division by zero if all x are identical\n        if np.isclose(denominator_m, 0):\n            # This case shouldn't occur with the given test data.\n            # A vertical line has an infinite slope, but more realistically,\n            # this implies no basis to estimate a slope. \n            # We would report NaN or handle as an error.\n            m = np.nan\n            se_m = np.nan\n        else:\n            m = numerator_m / denominator_m\n        \n            # Step 5: Calculate the standard error of the slope\n            # The denominator of Var(m) is the weighted sum of squares of x\n            ss_xx_w = S_wxx - (S_wx**2) / S_w\n        \n            if ss_xx_w == 0:\n                se_m = np.nan\n            else:\n                var_m = 1.0 / ss_xx_w\n                se_m = np.sqrt(var_m)\n\n        # Step 6: Calculate the confidence interval\n        if np.isnan(m) or np.isnan(se_m):\n            lower_bound, upper_bound = np.nan, np.nan\n        else:\n            alpha = 1 - c\n            z_critical = norm.ppf(1 - alpha / 2.0)\n            margin_of_error = z_critical * se_m\n            lower_bound = m - margin_of_error\n            upper_bound = m + margin_of_error\n\n        results.append([m, lower_bound, upper_bound])\n\n    # Final print statement in the exact required format.\n    # Convert each inner list to a string without spaces\n    result_strings = [f\"[{','.join(f'{v:.10f}' for v in res)}]\" for res in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}