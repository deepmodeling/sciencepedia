{
    "hands_on_practices": [
        {
            "introduction": "To begin our hands-on exploration, we first address a foundational challenge in simulating stochastic systems: ensuring the numerical method respects the fundamental physics of thermal equilibrium. This exercise uses the Ornstein-Uhlenbeck process, a cornerstone model for thermal relaxation, to expose a common flaw in simple integrators known as \"numerical heating.\" By deriving this artifact analytically and then constructing bias-free alternatives, you will gain a crucial understanding of how to ensure your simulations correctly reproduce the fluctuation-dissipation theorem and maintain physical fidelity over long times .",
            "id": "4001111",
            "problem": "Consider a test species of mass $m$ immersed in an isotropic Maxwellian background at temperature $T_\\mathrm{b}$, undergoing small-angle Coulomb collisions. In computational fusion science and engineering, a widely used reduced model is a Langevin representation of Coulomb collisions in velocity space, where the randomization of particle velocities is represented by a stochastic differential equation (SDE). Assume the following physically justified base, which is standard for small-angle Coulomb collisions when the background is treated as stationary and Maxwellian:\n\n- The velocity $\\mathbf{v}(t) \\in \\mathbb{R}^3$ of a test particle evolves under linear drag with rate $\\nu$ and isotropic diffusion consistent with the fluctuation-dissipation relation, such that the stationary distribution is Maxwellian with variance per component equal to $k_\\mathrm{B} T_\\mathrm{b}/m$, where $k_\\mathrm{B}$ is the Boltzmann constant.\n\n- The continuous-time model is a $3$-dimensional Ornstein–Uhlenbeck process (OU) driven by a standard Wiener process with the above physical parameters.\n\nYour task is to quantify the numerical heating produced by a basic explicit time discretization and to design bias-free alternatives or post-processing that remove this heating, all from first principles:\n\n1. Starting from the above continuous-time base, derive the explicit Euler–Maruyama discretization of the OU velocity SDE in $3$ dimensions with time step $\\Delta t$. Then, from first principles using only linearity, isotropy, and the fluctuation-dissipation relation, derive a closed-form expression for the stationary mean squared speed $S_\\infty = \\mathbb{E}\\left[\\,\\|\\mathbf{v}\\|^2\\,\\right]$ predicted by this discrete scheme as a function of $m$, $k_\\mathrm{B}$, $T_\\mathrm{b}$, $\\nu$, and $\\Delta t$. From this, obtain a dimensionless relative bias $R_\\mathrm{EM}(\\nu \\Delta t)$ defined as the ratio of the Euler–Maruyama stationary mean squared speed to the exact Maxwellian value. Express $R_\\mathrm{EM}$ strictly in terms of the dimensionless parameter $a = \\nu \\Delta t$.\n\n2. Using the same base, construct at least two bias-free alternatives and justify them mathematically by tracking the second moment:\n   - An exact discrete-time OU update obtained by solving the linear SDE over one time step $\\Delta t$.\n   - A modified explicit Euler–Maruyama scheme that preserves the exact Maxwellian variance in discrete time by adjusting the per-step noise amplitude while keeping the same drag term.\n   Optionally, propose a post-processing operation that rescales velocities after each explicit step to remove any energy bias and justify how it enforces the correct second moment.\n\n3. Implement a program that, for each test case in the suite below, computes the following dimensionless quantities:\n   - $R_\\mathrm{EM}$, the Euler–Maruyama relative bias derived in part $1$.\n   - $R_\\mathrm{OU}$, the relative bias for the exact OU update from part $2$.\n   - $R_\\mathrm{bal}$, the relative bias for the modified explicit scheme with adjusted noise from part $2$.\n   If you propose the optional post-processing rescaling, you may comment on it in your derivation, but you do not need to include it in the outputs. All outputs must be dimensionless floats rounded to $6$ decimal places.\n\nThe program must use the following test suite. Each tuple specifies $(m,\\;T_\\mathrm{b},\\;\\nu,\\;\\Delta t)$, where $m$ is in $\\mathrm{kg}$, $T_\\mathrm{b}$ is in $\\mathrm{K}$, $\\nu$ is in $\\mathrm{s}^{-1}$, and $\\Delta t$ is in $\\mathrm{s}$:\n\n- Case $1$ (happy path): $(3.345\\times 10^{-27},\\;1.16045\\times 10^{8},\\;1.0\\times 10^{5},\\;1.0\\times 10^{-6})$.\n- Case $2$ (moderate time step): $(3.345\\times 10^{-27},\\;1.16045\\times 10^{8},\\;3.0\\times 10^{5},\\;2.0\\times 10^{-6})$.\n- Case $3$ (near stability boundary): $(3.345\\times 10^{-27},\\;1.16045\\times 10^{8},\\;1.0\\times 10^{5},\\;1.9\\times 10^{-5})$.\n- Case $4$ (very small time step): $(3.345\\times 10^{-27},\\;1.16045\\times 10^{8},\\;2.0\\times 10^{5},\\;5.0\\times 10^{-9})$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by case and by method as\n$[R_\\mathrm{EM}^{(1)},R_\\mathrm{OU}^{(1)},R_\\mathrm{bal}^{(1)},R_\\mathrm{EM}^{(2)},R_\\mathrm{OU}^{(2)},R_\\mathrm{bal}^{(2)},R_\\mathrm{EM}^{(3)},R_\\mathrm{OU}^{(3)},R_\\mathrm{bal}^{(3)},R_\\mathrm{EM}^{(4)},R_\\mathrm{OU}^{(4)},R_\\mathrm{bal}^{(4)}]$.\n\nAll outputs must be dimensionless floats rounded to $6$ decimal places. No other text should be printed. Ensure scientific realism in your derivations and numerical design, and do not assume any relations beyond the stated base and standard properties of the Ornstein–Uhlenbeck process and Gaussian white noise.",
            "solution": "The problem as stated is scientifically sound, well-posed, and contains all necessary information for a rigorous solution. It is a standard, albeit important, exercise in the field of computational statistical mechanics and plasma physics. We may therefore proceed with the derivation and implementation.\n\nThe physical system is a test particle of mass $m$ in a thermal bath at temperature $T_\\mathrm{b}$. Its velocity $\\mathbf{v}(t)$ is governed by the $3$-dimensional Ornstein-Uhlenbeck (OU) process, which models linear drag and stochastic forcing. The corresponding stochastic differential equation (SDE) is:\n$$d\\mathbf{v}(t) = -\\nu \\mathbf{v}(t) dt + \\sigma d\\mathbf{W}(t)$$\nHere, $\\nu$ is the collision frequency representing drag, $\\mathbf{W}(t)$ is a $3$-dimensional standard Wiener process, and $\\sigma$ is the diffusion coefficient. The fluctuation-dissipation theorem dictates the relationship between drag and diffusion to ensure the system relaxes to a Maxwellian distribution at temperature $T_\\mathrm{b}$. The stationary velocity distribution is Gaussian with mean $\\mathbf{0}$ and covariance $\\mathbb{E}[\\mathbf{v}\\mathbf{v}^T] = \\frac{k_\\mathrm{B} T_\\mathrm{b}}{m}\\mathbf{I}$, where $k_\\mathrm{B}$ is the Boltzmann constant and $\\mathbf{I}$ is the identity matrix. Let $V_{th}^2 = k_\\mathrm{B} T_\\mathrm{b}/m$ be the variance per velocity component. The stationary covariance $C = V_{th}^2 \\mathbf{I}$ must satisfy the continuous Lyapunov equation for the OU process, $-2\\nu C + \\sigma^2 \\mathbf{I} = 0$. Substituting $C$, we find $\\sigma^2 = 2\\nu V_{th}^2 = 2\\nu \\frac{k_\\mathrm{B} T_\\mathrm{b}}{m}$.\n\nThe exact stationary mean squared speed, corresponding to the mean kinetic energy, is $S_{\\infty, \\text{exact}} = \\mathbb{E}[\\|\\mathbf{v}\\|^2] = \\mathbb{E}[v_x^2+v_y^2+v_z^2] = 3 V_{th}^2 = 3 \\frac{k_\\mathrm{B} T_\\mathrm{b}}{m}$.\n\n### Part 1: Euler–Maruyama Discretization and Numerical Heating\n\nThe SDE is discretized using the explicit Euler-Maruyama scheme with time step $\\Delta t$. The velocity at step $n+1$ is updated from the velocity at step $n$:\n$$\\mathbf{v}_{n+1} = \\mathbf{v}_n - \\nu \\mathbf{v}_n \\Delta t + \\sigma \\sqrt{\\Delta t} \\mathbf{Z}_n$$\nwhere $\\mathbf{v}_n \\equiv \\mathbf{v}(n\\Delta t)$ and $\\mathbf{Z}_n$ is a vector of three independent standard normal random variables, $N(0,1)$. Substituting the expression for $\\sigma$:\n$$\\mathbf{v}_{n+1} = (1 - \\nu \\Delta t) \\mathbf{v}_n + \\sqrt{2\\nu \\frac{k_\\mathrm{B} T_\\mathrm{b}}{m} \\Delta t} \\mathbf{Z}_n$$\nTo find the stationary mean squared speed $S_{\\infty, \\text{EM}} = \\lim_{n\\to\\infty} \\mathbb{E}[\\|\\mathbf{v}_n\\|^2]$ of this discrete process, we analyze the evolution of the second moment, $S_n = \\mathbb{E}[\\|\\mathbf{v}_n\\|^2]$.\n$$\\|\\mathbf{v}_{n+1}\\|^2 = \\mathbf{v}_{n+1}^T \\mathbf{v}_{n+1} = \\left\\| (1 - \\nu \\Delta t) \\mathbf{v}_n + \\sqrt{2\\nu V_{th}^2 \\Delta t} \\mathbf{Z}_n \\right\\|^2$$\n$$= (1 - \\nu \\Delta t)^2 \\|\\mathbf{v}_n\\|^2 + 2(1 - \\nu \\Delta t)\\sqrt{2\\nu V_{th}^2 \\Delta t} (\\mathbf{v}_n^T \\mathbf{Z}_n) + (2\\nu V_{th}^2 \\Delta t) \\|\\mathbf{Z}_n\\|^2$$\nTaking the expectation and using the facts that $\\mathbf{Z}_n$ is independent of $\\mathbf{v}_n$, $\\mathbb{E}[\\mathbf{Z}_n]=\\mathbf{0}$, and $\\mathbb{E}[\\|\\mathbf{Z}_n\\|^2] = 3$, we get a map for the second moment:\n$$S_{n+1} = (1 - \\nu \\Delta t)^2 S_n + 3(2\\nu V_{th}^2 \\Delta t) = (1 - \\nu \\Delta t)^2 S_n + 6\\nu V_{th}^2 \\Delta t$$\nIn the stationary state, $S_{n+1} = S_n = S_{\\infty, \\text{EM}}$.\n$$S_{\\infty, \\text{EM}} = (1 - \\nu \\Delta t)^2 S_{\\infty, \\text{EM}} + 6\\nu V_{th}^2 \\Delta t$$\n$$S_{\\infty, \\text{EM}} [1 - (1 - \\nu \\Delta t)^2] = 6\\nu V_{th}^2 \\Delta t$$\n$$S_{\\infty, \\text{EM}} [2\\nu \\Delta t - (\\nu \\Delta t)^2] = 6\\nu V_{th}^2 \\Delta t$$\nAssuming $\\nu\\Delta t \\neq 0$ and the stability condition $|\\nu\\Delta t - 1|1$ (i.e., $0  \\nu\\Delta t  2$) holds, we can divide by $\\nu\\Delta t$:\n$$S_{\\infty, \\text{EM}} (2 - \\nu \\Delta t) = 6 V_{th}^2$$\nThe stationary mean squared speed for the Euler-Maruyama scheme is thus:\n$$S_{\\infty, \\text{EM}}(m, k_\\mathrm{B}, T_\\mathrm{b}, \\nu, \\Delta t) = \\frac{6 V_{th}^2}{2 - \\nu \\Delta t} = \\frac{6 k_\\mathrm{B} T_\\mathrm{b}}{m(2 - \\nu \\Delta t)}$$\nThe dimensionless relative bias $R_\\mathrm{EM}$ is the ratio of this numerical result to the exact one:\n$$R_\\mathrm{EM} = \\frac{S_{\\infty, \\text{EM}}}{S_{\\infty, \\text{exact}}} = \\frac{6 V_{th}^2 / (2 - \\nu \\Delta t)}{3 V_{th}^2} = \\frac{2}{2 - \\nu \\Delta t}$$\nExpressing this in terms of the dimensionless parameter $a = \\nu \\Delta t$:\n$$R_\\mathrm{EM}(a) = \\frac{2}{2 - a}$$\nThis result clearly shows \"numerical heating\": for any $a>0$, $R_\\mathrm{EM}(a) > 1$, meaning the numerical scheme leads to a stationary state that is hotter than the physical equilibrium. The error is first-order in $a$, since $R_\\mathrm{EM}(a) \\approx 1 + a/2$ for small $a$.\n\n### Part 2: Bias-Free Numerical Schemes\n\nWe construct two alternatives that preserve the exact stationary second moment.\n\n**Alternative 1: Exact Discrete-Time OU Update**\nThe linear SDE for the OU process can be solved analytically over a time step $\\Delta t$. The solution is:\n$$\\mathbf{v}((n+1)\\Delta t) = e^{-\\nu \\Delta t} \\mathbf{v}(n\\Delta t) + \\int_{n\\Delta t}^{(n+1)\\Delta t} e^{-\\nu((n+1)\\Delta t - s)} \\sigma d\\mathbf{W}(s)$$\nThe integral term represents a Gaussian random variable with mean zero. Its covariance matrix is $\\text{Var} \\cdot \\mathbf{I}$, where the variance is given by the Itō isometry:\n$$\\text{Var} = \\sigma^2 \\int_0^{\\Delta t} (e^{-\\nu u})^2 du = (2\\nu V_{th}^2) \\left[ \\frac{1-e^{-2\\nu u}}{2\\nu} \\right]_0^{\\Delta t} = V_{th}^2 (1 - e^{-2\\nu \\Delta t})$$\nThus, the exact discrete-time update rule is:\n$$\\mathbf{v}_{n+1} = e^{-\\nu \\Delta t} \\mathbf{v}_n + \\sqrt{V_{th}^2(1-e^{-2\\nu \\Delta t})} \\mathbf{Z}_n$$\nBy construction, this is an exact sampling of the OU process path at discrete times. The stationary distribution of this scheme is identical to the continuous process. The stationary mean squared speed $S_{\\infty, \\text{OU}}$ satisfies:\n$$S_{\\infty, \\text{OU}} = (e^{-\\nu\\Delta t})^2 S_{\\infty, \\text{OU}} + 3V_{th}^2(1-e^{-2\\nu\\Delta t})$$\n$$S_{\\infty, \\text{OU}}(1 - e^{-2\\nu\\Delta t}) = 3V_{th}^2(1-e^{-2\\nu\\Delta t}) \\implies S_{\\infty, \\text{OU}} = 3V_{th}^2 = S_{\\infty, \\text{exact}}$$\nTherefore, the relative bias $R_\\mathrm{OU}$ for this scheme is identically $1$.\n\n**Alternative 2: Modified (Balanced) Explicit Scheme**\nWe can modify the noise term in the explicit Euler-Maruyama scheme to enforce the correct stationary variance while retaining the simple $(1-\\nu\\Delta t)$ drag term. Let the modified scheme be:\n$$\\mathbf{v}_{n+1} = (1 - \\nu \\Delta t) \\mathbf{v}_n + C_{\\text{noise}} \\mathbf{Z}_n$$\nThe evolution of the second moment is $S_{n+1} = (1 - \\nu \\Delta t)^2 S_n + 3C_{\\text{noise}}^2$. We require that in the stationary state, $S_n = S_{n+1} = S_{\\infty, \\text{exact}} = 3V_{th}^2$.\n$$3V_{th}^2 = (1 - \\nu \\Delta t)^2 (3V_{th}^2) + 3C_{\\text{noise}}^2$$\n$$C_{\\text{noise}}^2 = V_{th}^2 [1 - (1-\\nu \\Delta t)^2] = V_{th}^2 [2\\nu \\Delta t - (\\nu \\Delta t)^2]$$\nThe modified scheme, which we call \"balanced\", is:\n$$\\mathbf{v}_{n+1} = (1 - \\nu \\Delta t) \\mathbf{v}_n + \\sqrt{V_{th}^2(2\\nu\\Delta t - (\\nu\\Delta t)^2)} \\mathbf{Z}_n$$\nBy construction, this scheme ensures $\\mathbb{E}[\\|\\mathbf{v}\\|^2] \\to 3V_{th}^2$ as $n\\to\\infty$. Therefore, its relative bias $R_\\mathrm{bal}$ is identically $1$. This scheme is a variance-corrected explicit method and is stable for the same range $0  \\nu\\Delta t  2$ as the original Euler-Maruyama scheme.\n\n**Optional Post-Processing Rescaling**\nAn alternative to modifying the scheme is to apply a corrective post-processing step. After a standard Euler-Maruyama step producing $\\mathbf{v}'_{n+1}$, one could rescale the velocity: $\\mathbf{v}_{n+1} = c \\cdot \\mathbf{v}'_{n+1}$. To enforce the correct stationary variance, we require $\\mathbb{E}[\\|\\mathbf{v}_{n+1}\\|^2] = c^2 \\mathbb{E}[\\|\\mathbf{v}'_{n+1}\\|^2] = c^2 S_{\\infty, \\text{EM}} = S_{\\infty, \\text{exact}}$. This implies the scaling factor must be $c = \\sqrt{S_{\\infty, \\text{exact}} / S_{\\infty, \\text{EM}}} = \\sqrt{1/R_\\mathrm{EM}} = \\sqrt{(2-a)/2}$. This removes the energy bias on average.\n\n### Part 3: Implementation\nThe implementation requires calculating $R_\\mathrm{EM}$, $R_\\mathrm{OU}$, and $R_\\mathrm{bal}$ for the given test cases. As derived, these quantities depend only on the dimensionless parameter $a = \\nu \\Delta t$.\n- $R_\\mathrm{EM}(a) = 2/(2-a)$\n- $R_\\mathrm{OU}(a) = 1$\n- $R_\\mathrm{bal}(a) = 1$\n\nThe physical constants $m$ and $T_\\mathrm{b}$ are extraneous for computing these relative dimensionless quantities, which is a testament to the power of dimensional analysis in physical modeling. The program below computes these values for the specified test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the relative bias for three different numerical schemes for the\n    Ornstein-Uhlenbeck process, based on analytical derivations.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple represents (mass, temperature, collision_freq, timestep).\n    # The physical values m and T_b are not needed for the relative bias calculation.\n    test_cases = [\n        # (m, T_b, nu, dt)\n        (3.345e-27, 1.16045e8, 1.0e5, 1.0e-6),  # Case 1\n        (3.345e-27, 1.16045e8, 3.0e5, 2.0e-6),  # Case 2\n        (3.345e-27, 1.16045e8, 1.0e5, 1.9e-5),  # Case 3\n        (3.345e-27, 1.16045e8, 2.0e5, 5.0e-9),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        _m, _T_b, nu, dt = case\n        \n        # The relevant parameter is the dimensionless product a = nu * dt\n        a = nu * dt\n\n        # 1. Euler-Maruyama relative bias (R_EM).\n        # Derived in the solution as R_EM = 2 / (2 - a).\n        # This formula is valid for 0  a  2, which holds for all test cases.\n        r_em = 2.0 / (2.0 - a)\n\n        # 2. Exact Ornstein-Uhlenbeck update relative bias (R_OU).\n        # This scheme is exact by construction, so its bias is identically 1.\n        r_ou = 1.0\n\n        # 3. Balanced (variance-corrected) explicit scheme relative bias (R_bal).\n        # This scheme is also correct by construction, so its bias is identically 1.\n        r_bal = 1.0\n\n        # Append results for the current case.\n        results.extend([r_em, r_ou, r_bal])\n\n    # Format the final output string as a comma-separated list of floats\n    # rounded to 6 decimal places, enclosed in square brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having established the importance of the integration algorithm itself, we now turn to another critical aspect of numerical simulation: the choice of the time step, $\\Delta t$. In realistic models of Coulomb collisions, the interaction strength varies dramatically with particle velocity, making a fixed time step inefficient and potentially unstable. This practice guides you through the derivation of an adaptive time-stepping scheme that adjusts $\\Delta t$ based on local plasma conditions, ensuring that both the deterministic drift and the stochastic diffusion are resolved accurately at every step, a vital skill for building robust and efficient simulation codes .",
            "id": "4001155",
            "problem": "Consider test-particle Coulomb collisions in a homogeneous, stationary, isotropic plasma background modeled by a Langevin equation for the particle velocity. Let the test-particle velocity be the vector $\\mathbf{v}\\in\\mathbb{R}^3$. The Itô Stochastic Differential Equation (SDE) for $\\mathbf{v}$ is of the form\n$$\n\\mathrm{d}\\mathbf{v} \\;=\\; \\mathbf{a}(\\mathbf{v})\\,\\mathrm{d}t \\;+\\; \\mathbf{B}(\\mathbf{v})\\,\\mathrm{d}\\mathbf{W}_t,\n$$\nwhere $\\mathbf{a}(\\mathbf{v})$ is the deterministic drift, $\\mathbf{B}(\\mathbf{v})$ is the diffusion amplitude, and $\\mathbf{W}_t$ is a three-dimensional Wiener process with independent and identically distributed (i.i.d.) components. The associated symmetric diffusion tensor is $\\mathbf{D}(\\mathbf{v}) = \\tfrac{1}{2}\\,\\mathbf{B}(\\mathbf{v})\\,\\mathbf{B}(\\mathbf{v})^{\\mathsf{T}}$. In a standard pitch-angle and energy scattering model for Coulomb collisions, two effective rates govern the time scales: an energy slowing-down rate $\\nu_s(\\mathbf{v})$ and a pitch-angle scattering rate $\\nu_D(\\mathbf{v})$, each with the physical unit $\\mathrm{s}^{-1}$. Assume a forward Euler–Maruyama discretization is used to advance the SDE over time step $\\Delta t$:\n$$\n\\mathbf{v}_{n+1} \\;=\\; \\mathbf{v}_n \\;+\\; \\mathbf{a}(\\mathbf{v}_n)\\,\\Delta t \\;+\\; \\sqrt{2}\\,\\mathbf{R}_n,\n$$\nwhere $\\mathbf{R}_n$ is a mean-zero Gaussian random vector with covariance $\\mathbb{E}[\\mathbf{R}_n \\mathbf{R}_n^{\\mathsf{T}}] = \\mathbf{D}(\\mathbf{v}_n)\\,\\Delta t$. To control both the weak bias from the explicit drift discretization and the sampling variance from the stochastic term, one must impose restrictions on $\\Delta t$ relative to the local collision time scales and the local diffusion geometry. Let the local diffusion tensor be represented in terms of the unit vector $\\widehat{\\mathbf{v}} = \\mathbf{v}/\\|\\mathbf{v}\\|$ as\n$$\n\\mathbf{D}(\\mathbf{v}) \\;=\\; D_{\\perp}(\\mathbf{v})\\,\\mathbf{I} \\;+\\; \\bigl(D_{\\parallel}(\\mathbf{v}) - D_{\\perp}(\\mathbf{v})\\bigr)\\,\\widehat{\\mathbf{v}}\\,\\widehat{\\mathbf{v}}^{\\mathsf{T}},\n$$\nwith $D_{\\parallel}$ and $D_{\\perp}$ the parallel and perpendicular velocity-space diffusion coefficients, respectively, having physical unit $\\mathrm{m}^2\\,\\mathrm{s}^{-3}$. Denote by $\\lambda_{\\max}(\\mathbf{v})$ the largest eigenvalue of $\\mathbf{D}(\\mathbf{v})$.\n\nYour tasks are:\n- Starting only from the SDE definition, dimensional analysis, and the properties of the Euler–Maruyama method, derive principled constraints on the time step $\\Delta t$ that ensure: (i) the explicit drift bias is small compared to the rates $\\nu_s$ and $\\nu_D$; and (ii) the one-step stochastic increment has a standard deviation that is a small fraction of the local speed $\\|\\mathbf{v}\\|$ in the most diffusive direction. Introduce two user-selected, dimensionless tolerances: a drift-bias tolerance $\\delta_b\\in(0,1)$ and a variance tolerance $\\delta_v\\in(0,1)$, and express the constraints in terms of $\\nu_s$, $\\nu_D$, $\\lambda_{\\max}$, $\\|\\mathbf{v}\\|$, $\\delta_b$, and $\\delta_v$.\n- Propose an adaptive selection rule for $\\Delta t$ that satisfies both constraints simultaneously using only local quantities at the beginning of the step.\n\nThen, implement a program that, for each test case below, constructs the diffusion tensor $\\mathbf{D}(\\mathbf{v})$ from $D_{\\parallel}$ and $D_{\\perp}$, computes $\\lambda_{\\max}$, applies your adaptive selection rule, and returns the selected $\\Delta t$ in seconds. The numerical inputs are given, and all outputs must be expressed in seconds. For numerical output formatting, round each $\\Delta t$ to six significant digits.\n\nTest suite (each case is a tuple containing $(\\mathbf{v},\\nu_s,\\nu_D,D_{\\parallel},D_{\\perp},\\delta_b,\\delta_v)$, with $\\mathbf{v}$ in $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $\\nu_s$ and $\\nu_D$ in $\\mathrm{s}^{-1}$, and $D_{\\parallel}$ and $D_{\\perp}$ in $\\mathrm{m}^2\\,\\mathrm{s}^{-3}$):\n- Case A (general, drift-limited): $\\bigl([\\;10^6,\\,0,\\,0\\;],\\; 50,\\; 30,\\; 10^{10},\\; 5\\times 10^9,\\; 0.1,\\; 0.05\\bigr)$.\n- Case B (high-rate drift limit): $\\bigl([\\;2\\times 10^6,\\,2\\times 10^6,\\,0\\;],\\; 400,\\; 100,\\; 10^8,\\; 10^8,\\; 0.05,\\; 0.2\\bigr)$.\n- Case C (strongly anisotropic diffusion, diffusion-limited): $\\bigl([\\;5\\times 10^5,\\,-5\\times 10^5,\\,10^6\\;],\\; 1,\\; 1,\\; 10^7,\\; 2\\times 10^{11},\\; 0.5,\\; 0.05\\bigr)$.\n- Case D (small speed, variance-sensitive): $\\bigl([\\;3\\times 10^3,\\,0,\\,0\\;],\\; 0.1,\\; 0.2,\\; 10^5,\\; 10^5,\\; 0.5,\\; 0.01\\bigr)$.\n- Case E (weak collisions, bias-limited with moderate diffusion): $\\bigl([\\;3\\times 10^6,\\,4\\times 10^6,\\,0\\;],\\; 0.5,\\; 0.05,\\; 2\\times 10^9,\\; 2\\times 10^9,\\; 0.1,\\; 0.2\\bigr)$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases A through E. Each list element must be the selected time step $\\Delta t$ in seconds, rounded to six significant digits (for example, $[0.00123456,0.00234567,\\dots]$).",
            "solution": "The user-provided problem is assessed as valid. It is scientifically grounded in the physics of Coulomb collisions and the numerical analysis of stochastic differential equations. The problem is well-posed, objective, and contains all necessary information to derive a unique and meaningful solution.\n\nWe are tasked with deriving and implementing an adaptive time-step selection rule for the Euler-Maruyama discretization of a Langevin equation modeling test-particle Coulomb collisions. The Itô Stochastic Differential Equation (SDE) for the particle velocity $\\mathbf{v} \\in \\mathbb{R}^3$ is\n$$\n\\mathrm{d}\\mathbf{v} \\;=\\; \\mathbf{a}(\\mathbf{v})\\,\\mathrm{d}t \\;+\\; \\mathbf{B}(\\mathbf{v})\\,\\mathrm{d}\\mathbf{W}_t\n$$\nThe corresponding forward Euler-Maruyama scheme advances the velocity from time step $n$ to $n+1$ via\n$$\n\\mathbf{v}_{n+1} \\;=\\; \\mathbf{v}_n \\;+\\; \\mathbf{a}(\\mathbf{v}_n)\\,\\Delta t \\;+\\; \\sqrt{2}\\,\\mathbf{R}_n,\n$$\nwhere the random vector $\\mathbf{R}_n$ has covariance $\\mathbb{E}[\\mathbf{R}_n \\mathbf{R}_n^{\\mathsf{T}}] = \\mathbf{D}(\\mathbf{v}_n)\\,\\Delta t$, and the symmetric diffusion tensor is $\\mathbf{D}(\\mathbf{v}) = \\tfrac{1}{2}\\,\\mathbf{B}(\\mathbf{v})\\,\\mathbf{B}(\\mathbf{v})^{\\mathsf{T}}$.\n\nThe derivation proceeds in three steps: deriving a constraint from the drift term, deriving a constraint from the diffusion term, and combining them into a single adaptive rule.\n\n### 1. Drift-Bias Constraint\n\nThe first constraint aims to control the error from the explicit discretization of the drift term $\\mathbf{a}(\\mathbf{v})$. The problem requires that the time step $\\Delta t$ be chosen such that the weak bias is small, with respect to the characteristic collision rates $\\nu_s(\\mathbf{v})$ and $\\nu_D(\\mathbf{v})$. In numerical methods for differential equations, a standard accuracy and stability requirement for an explicit scheme like forward Euler is that the time step must be smaller than the characteristic time scales of the system.\n\nThe provided rates, the energy slowing-down rate $\\nu_s$ and the pitch-angle scattering rate $\\nu_D$, represent the inverse time scales for the two principal collisional effects on the particle's velocity. To resolve the fastest of these processes numerically, the time step $\\Delta t$ must be a fraction of the shortest characteristic time, which is $1/\\max(\\nu_s, \\nu_D)$.\n\nWe introduce the dimensionless drift-bias tolerance $\\delta_b \\in (0,1)$ as the maximum allowable \"fraction\" of the characteristic time to be taken in a single step. This leads to the Courant-Friedrichs-Lewy (CFL)-like condition:\n$$\n\\Delta t \\cdot \\max(\\nu_s(\\mathbf{v}), \\nu_D(\\mathbf{v})) \\le \\delta_b\n$$\nThis ensures that the change due to drift over one time step is a controlled fraction of what would happen over the characteristic time of the fastest collisional process. Solving for $\\Delta t$ gives the first constraint:\n$$\n\\Delta t_{\\text{bias}} = \\frac{\\delta_b}{\\max(\\nu_s(\\mathbf{v}), \\nu_D(\\mathbf{v}))}\n$$\n\n### 2. Variance Constraint\n\nThe second constraint limits the magnitude of the stochastic velocity increment in a single step. The problem requires that the standard deviation of the one-step increment, in the most diffusive direction, be a small fraction of the local particle speed $\\|\\mathbf{v}\\|$.\n\nThe stochastic increment in the Euler-Maruyama step is $\\Delta\\mathbf{v}_{\\text{stoch}} = \\sqrt{2}\\,\\mathbf{R}_n$. The covariance of this random vector is:\n$$\n\\mathbb{E}[\\Delta\\mathbf{v}_{\\text{stoch}} (\\Delta\\mathbf{v}_{\\text{stoch}})^{\\mathsf{T}}] = 2\\,\\mathbb{E}[\\mathbf{R}_n \\mathbf{R}_n^{\\mathsf{T}}] = 2\\,\\mathbf{D}(\\mathbf{v}_n)\\,\\Delta t\n$$\nThe variance of the velocity change along an arbitrary direction, given by a unit vector $\\widehat{\\mathbf{u}}$, is $\\widehat{\\mathbf{u}}^{\\mathsf{T}} (2\\,\\mathbf{D}(\\mathbf{v}_n)\\,\\Delta t) \\widehat{\\mathbf{u}}$. The \"most diffusive direction\" corresponds to the eigenvector of the covariance matrix $2\\,\\mathbf{D}(\\mathbf{v}_n)\\,\\Delta t$ associated with its largest eigenvalue. Let $\\lambda_{\\max}(\\mathbf{v})$ be the largest eigenvalue of the diffusion tensor $\\mathbf{D}(\\mathbf{v})$. Then the maximum variance of the stochastic increment is $2\\,\\lambda_{\\max}(\\mathbf{v}_n)\\,\\Delta t$.\n\nThe standard deviation in this direction is the square root of the variance:\n$$\n\\sigma_{\\max} = \\sqrt{2\\,\\lambda_{\\max}(\\mathbf{v}_n)\\,\\Delta t}\n$$\nThis standard deviation is constrained to be a fraction $\\delta_v \\in (0,1)$ of the particle speed $\\|\\mathbf{v}_n\\|$:\n$$\n\\sqrt{2\\,\\lambda_{\\max}(\\mathbf{v}_n)\\,\\Delta t} \\le \\delta_v \\|\\mathbf{v}_n\\|\n$$\nSquaring both sides and solving for $\\Delta t$ yields the second constraint:\n$$\n\\Delta t \\le \\frac{\\delta_v^2 \\|\\mathbf{v}_n\\|^2}{2\\,\\lambda_{\\max}(\\mathbf{v}_n)}\n$$\nThus, the variance-limited time step is:\n$$\n\\Delta t_{\\text{var}} = \\frac{\\delta_v^2 \\|\\mathbf{v}\\|^2}{2\\,\\lambda_{\\max}(\\mathbf{v})}\n$$\nWe must first determine $\\lambda_{\\max}(\\mathbf{v})$. The diffusion tensor is given as:\n$$\n\\mathbf{D}(\\mathbf{v}) \\;=\\; D_{\\perp}(\\mathbf{v})\\,\\mathbf{I} \\;+\\; \\bigl(D_{\\parallel}(\\mathbf{v}) - D_{\\perp}(\\mathbf{v})\\bigr)\\,\\widehat{\\mathbf{v}}\\,\\widehat{\\mathbf{v}}^{\\mathsf{T}}\n$$\nwhere $\\widehat{\\mathbf{v}} = \\mathbf{v}/\\|\\mathbf{v}\\|$ is the unit vector along $\\mathbf{v}$. This a symmetric matrix representing a rank-$1$ update to a scaled identity matrix. Its eigenvalues can be found by considering eigenvectors parallel and perpendicular to $\\widehat{\\mathbf{v}}$.\n- For an eigenvector $\\mathbf{x}$ parallel to $\\widehat{\\mathbf{v}}$ (i.e., $\\mathbf{x} = \\widehat{\\mathbf{v}}$), and using $\\widehat{\\mathbf{v}}^{\\mathsf{T}}\\widehat{\\mathbf{v}}=1$:\n$$\n\\mathbf{D}\\widehat{\\mathbf{v}} = D_{\\perp}\\widehat{\\mathbf{v}} + (D_{\\parallel} - D_{\\perp})\\widehat{\\mathbf{v}}(\\widehat{\\mathbf{v}}^{\\mathsf{T}}\\widehat{\\mathbf{v}}) = D_{\\perp}\\widehat{\\mathbf{v}} + (D_{\\parallel} - D_{\\perp})\\widehat{\\mathbf{v}} = D_{\\parallel}\\widehat{\\mathbf{v}}\n$$\nThus, one eigenvalue is $\\lambda_1 = D_{\\parallel}(\\mathbf{v})$.\n- For any eigenvector $\\mathbf{x}$ perpendicular to $\\widehat{\\mathbf{v}}$ (i.e., $\\widehat{\\mathbf{v}}^{\\mathsf{T}}\\mathbf{x}=0$):\n$$\n\\mathbf{D}\\mathbf{x} = D_{\\perp}\\mathbf{x} + (D_{\\parallel} - D_{\\perp})\\widehat{\\mathbf{v}}(\\widehat{\\mathbf{v}}^{\\mathsf{T}}\\mathbf{x}) = D_{\\perp}\\mathbf{x} + (D_{\\parallel} - D_{\\perp})\\widehat{\\mathbf{v}}(0) = D_{\\perp}\\mathbf{x}\n$$\nThus, any vector in the plane perpendicular to $\\widehat{\\mathbf{v}}$ is an eigenvector with eigenvalue $\\lambda_{2,3} = D_{\\perp}(\\mathbf{v})$.\nThe eigenvalues of $\\mathbf{D}(\\mathbf{v})$ are $\\{ D_{\\parallel}, D_{\\perp}, D_{\\perp} \\}$. The largest eigenvalue is therefore:\n$$\n\\lambda_{\\max}(\\mathbf{v}) = \\max(D_{\\parallel}(\\mathbf{v}), D_{\\perp}(\\mathbf{v}))\n$$\nThis greatly simplifies the calculation.\n\n### 3. Adaptive Time-Step Selection Rule\n\nTo ensure that both the drift-bias and variance constraints are satisfied simultaneously, the time step $\\Delta t$ for the next integration step must be less than or equal to both $\\Delta t_{\\text{bias}}$ and $\\Delta t_{\\text{var}}$. The most general and robust choice that satisfies this is the minimum of the two.\n\nThe proposed adaptive selection rule for $\\Delta t$ at the beginning of a step (state $\\mathbf{v}_n$) is:\n$$\n\\Delta t = \\min(\\Delta t_{\\text{bias}}, \\Delta t_{\\text{var}}) = \\min\\left( \\frac{\\delta_b}{\\max(\\nu_s, \\nu_D)}, \\frac{\\delta_v^2 \\|\\mathbf{v}\\|^2}{2 \\max(D_{\\parallel}, D_{\\perp})} \\right)\n$$\nThis rule uses only local quantities available at state $\\mathbf{v}_n$ to determine the appropriate time step for advancing to $\\mathbf{v}_{n+1}$. In the case of zero diffusion ($\\max(D_{\\parallel}, D_{\\perp}) = 0$), the variance constraint is considered inactive (i.e., $\\Delta t_{\\text{var}} \\to \\infty$). In the case of zero velocity ($\\|\\mathbf{v}\\|=0$), we assume isotropic diffusion ($D_{\\parallel}=D_{\\perp}$) and note the variance constraint becomes $\\Delta t_{\\text{var}} = 0$ if diffusion is present. All test cases have non-zero velocity and diffusion.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef format_to_significant_figures(value, sig_figs):\n    \"\"\"\n    Rounds and formats a number to a specified number of significant figures,\n    avoiding scientific notation as requested by the output format.\n    \"\"\"\n    if value == 0:\n        return f\"0.{'0' * (sig_figs-1)}\"\n\n    # Round to the correct number of significant figures\n    order_of_magnitude = math.floor(math.log10(abs(value)))\n    decimals_to_round = sig_figs - 1 - order_of_magnitude\n    rounded_value = round(value, int(decimals_to_round))\n\n    # Format the rounded value to display trailing zeros\n    # This ensures the output string has the correct number of significant digits\n    decimals_to_format = max(0, decimals_to_round)\n    return f\"{rounded_value:.{int(decimals_to_format)}f}\"\n\ndef solve():\n    \"\"\"\n    Calculates the adaptive time step for Langevin simulations of Coulomb collisions\n    based on derived constraints for drift-bias and stochastic variance.\n    \"\"\"\n    \n    # Test suite from the problem statement.\n    # Each case is a tuple: (v, nu_s, nu_D, D_parallel, D_perp, delta_b, delta_v)\n    test_cases = [\n        # Case A: general, drift-limited\n        (np.array([1e6, 0, 0]), 50, 30, 1e10, 5e9, 0.1, 0.05),\n        # Case B: high-rate drift limit\n        (np.array([2e6, 2e6, 0]), 400, 100, 1e8, 1e8, 0.05, 0.2),\n        # Case C: strongly anisotropic diffusion, diffusion-limited\n        (np.array([5e5, -5e5, 1e6]), 1, 1, 1e7, 2e11, 0.5, 0.05),\n        # Case D: small speed, variance-sensitive\n        (np.array([3e3, 0, 0]), 0.1, 0.2, 1e5, 1e5, 0.5, 0.01),\n        # Case E: weak collisions, bias-limited with moderate diffusion\n        (np.array([3e6, 4e6, 0]), 0.5, 0.05, 2e9, 2e9, 0.1, 0.2),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        v, nu_s, nu_D, D_parallel, D_perp, delta_b, delta_v = case\n        \n        # 1. Drift-Bias Constraint\n        # The time step must resolve the fastest collisional process.\n        max_nu = max(nu_s, nu_D)\n        # Avoid division by zero if collision rates are zero.\n        if max_nu > 0:\n            dt_bias = delta_b / max_nu\n        else:\n            dt_bias = float('inf')\n            \n        # 2. Variance Constraint\n        # The stochastic step size should be a small fraction of the particle speed.\n        v_norm = np.linalg.norm(v)\n        lambda_max = max(D_parallel, D_perp)\n        \n        # Avoid division by zero if there is no diffusion.\n        # Handle the case where v_norm is zero.\n        if lambda_max > 0 and v_norm > 0:\n            dt_var = (delta_v**2 * v_norm**2) / (2 * lambda_max)\n        elif v_norm == 0 and lambda_max > 0:\n            # At zero speed, any stochastic kick is infinitely large relative to the speed.\n            # The time step must be zero to satisfy the constraint.\n            dt_var = 0.0\n        else: # No diffusion\n            dt_var = float('inf')\n            \n        # 3. Adaptive Time-Step Selection Rule\n        # The final time step must satisfy both constraints.\n        delta_t = min(dt_bias, dt_var)\n        \n        results.append(delta_t)\n\n    # Format results to exactly six significant digits.\n    formatted_results = [format_to_significant_figures(r, 6) for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a robust single-particle integrator in hand, the final step is to apply it within an ensemble of computational \"markers\" to measure macroscopic quantities. This practice bridges the gap between single-particle dynamics and ensemble statistics by tackling the question of simulation design: how many particles are enough? You will learn to perform error budgeting by deriving the contributions of both numerical integration bias (from finite $\\Delta t$) and statistical noise (from finite ensemble size $N$), culminating in a practical method to determine the minimum number of particles needed to achieve a desired accuracy for an ensemble average .",
            "id": "4001134",
            "problem": "Consider the one-dimensional Langevin formulation for Coulomb collisions in a magnetized plasma, modeled for the velocity component $v(t)$ of a test particle of mass $m$ interacting with a thermal background of temperature $T$. The stochastic dynamics are described by the Stochastic Differential Equation (SDE)\n$$\n\\mathrm{d}v = -\\nu\\, v\\, \\mathrm{d}t + \\sqrt{2\\, \\nu\\, v_{\\mathrm{th}}^2}\\, \\mathrm{d}W_t,\n$$\nwhere $\\nu$ is the collisional friction (slowing-down) rate, $v_{\\mathrm{th}}^2$ is the thermal speed squared given by the Einstein relation $v_{\\mathrm{th}}^2 = \\frac{k_{\\mathrm{B}} T}{m}$ (with $k_{\\mathrm{B}}$ the Boltzmann constant), and $W_t$ is a standard Wiener process. You will estimate ensemble-averaged mean velocity using $N$ numerical markers integrated with the Euler–Maruyama scheme,\n$$\nv_{n+1} = v_n - \\nu\\, v_n\\, \\Delta t + \\sqrt{2\\, \\nu\\, v_{\\mathrm{th}}^2\\, \\Delta t}\\, \\xi_n,\n$$\nwhere $\\xi_n$ are independent standard normal random variables and $\\Delta t$ is the time step. The estimator of the mean at time $t = M \\Delta t$ is the sample mean $\\bar{v}_M = \\frac{1}{N}\\sum_{i=1}^N v_M^{(i)}$.\n\nStarting from fundamental definitions and well-tested facts, namely linear SDEs, the Euler–Maruyama discretization, and the Einstein relation for fluctuation–dissipation, derive the following quantities:\n- The exact mean $\\mathbb{E}[v(t)]$ and exact variance $\\mathrm{Var}[v(t)]$ of the Ornstein–Uhlenbeck process represented by the SDE above.\n- The discrete-time mean produced by Euler–Maruyama after $M$ steps and its time-discretization bias at $t = M \\Delta t$, defined as $b_{\\Delta t} = \\left|\\mathbb{E}_{\\mathrm{EM}}[v_M] - \\mathbb{E}[v(t)]\\right|$, where $\\mathbb{E}_{\\mathrm{EM}}[v_M]$ denotes the expectation under the Euler–Maruyama scheme.\n- The Euler–Maruyama variance at step $M$, and the sampling variance of the sample mean estimator $\\bar{v}_M$ with $N$ independent markers.\n\nUsing these derivations, impose a sufficiency criterion for the ensemble size $N$ at a confidence level $p$ (for example, $p = 0.95$) and an absolute tolerance $\\varepsilon$ on the mean estimate expressed in meters per second (m/s). Specifically, require that the sum of the absolute discretization bias $b_{\\Delta t}$ and the half-width of the normal-approximate confidence interval for $\\bar{v}_M$ be bounded by $\\varepsilon$. Use the standard Gaussian quantile $z_p$ for the chosen confidence level to obtain a minimal integer $N_{\\min}$ that satisfies\n$$\nb_{\\Delta t} + z_p \\sqrt{\\frac{\\mathrm{Var}[v_M]_{\\mathrm{EM}}}{N}} \\le \\varepsilon.\n$$\nIf $\\varepsilon \\le b_{\\Delta t}$, declare the requirement impossible and set $N_{\\min} = -1$ for that case.\n\nWrite a complete, runnable program that:\n- Computes $N_{\\min}$ for each test case below, using the derived formulas.\n- Outputs a single line containing the results for all test cases as a comma-separated list enclosed in square brackets and with no spaces, e.g., \"[n1,n2,n3,n4]\".\n- Uses the unit meters per second (m/s) for all velocity-based tolerances and quantities. The final outputs are integers with no unit symbol.\n\nUse the following constants and assumptions in your program:\n- Boltzmann constant $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\ \\mathrm{J/K}$.\n- Electronvolt–joule conversion $E_{\\mathrm{eV}} = 1.602176634 \\times 10^{-19}\\ \\mathrm{J}$.\n- Use $z_{0.95} = 1.95996398454005$ as the normal quantile for a two-sided $95\\%$ confidence level.\n\nTest Suite (each case must satisfy $M = t_{\\mathrm{final}}/\\Delta t$ is an integer):\n1. Case 1 (happy path, ion-like): $m = 3.343 \\times 10^{-27}\\ \\mathrm{kg}$, $T = 10{,}000\\ \\mathrm{eV}$, $\\nu = 5.0 \\times 10^{4}\\ \\mathrm{s}^{-1}$, $v_0 = 2\\, v_{\\mathrm{th}}$, $t_{\\mathrm{final}} = 2.0 \\times 10^{-3}\\ \\mathrm{s}$, $\\Delta t = 2.0 \\times 10^{-6}\\ \\mathrm{s}$, $\\varepsilon = 5.0 \\times 10^{4}\\ \\mathrm{m/s}$, $p = 0.95$.\n2. Case 2 (coarse time step, bias-dominated): $m = 3.343 \\times 10^{-27}\\ \\mathrm{kg}$, $T = 2{,}000\\ \\mathrm{eV}$, $\\nu = 1.0 \\times 10^{5}\\ \\mathrm{s}^{-1}$, $v_0 = 1.5\\, v_{\\mathrm{th}}$, $t_{\\mathrm{final}} = 1.0 \\times 10^{-5}\\ \\mathrm{s}$, $\\Delta t = 5.0 \\times 10^{-6}\\ \\mathrm{s}$, $\\varepsilon = 3.0 \\times 10^{4}\\ \\mathrm{m/s}$, $p = 0.95$.\n3. Case 3 (electron-like, high collisionality): $m = 9.10938356 \\times 10^{-31}\\ \\mathrm{kg}$, $T = 500\\ \\mathrm{eV}$, $\\nu = 2.0 \\times 10^{6}\\ \\mathrm{s}^{-1}$, $v_0 = 1.0\\, v_{\\mathrm{th}}$, $t_{\\mathrm{final}} = 1.0 \\times 10^{-5}\\ \\mathrm{s}$, $\\Delta t = 1.0 \\times 10^{-8}\\ \\mathrm{s}$, $\\varepsilon = 2.0 \\times 10^{5}\\ \\mathrm{m/s}$, $p = 0.95$.\n4. Case 4 (near-step-stability boundary): $m = 5.008 \\times 10^{-27}\\ \\mathrm{kg}$, $T = 20{,}000\\ \\mathrm{eV}$, $\\nu = 2.0 \\times 10^{5}\\ \\mathrm{s}^{-1}$, $v_0 = 0.5\\, v_{\\mathrm{th}}$, $t_{\\mathrm{final}} = 9.0 \\times 10^{-4}\\ \\mathrm{s}$, $\\Delta t = 9.0 \\times 10^{-6}\\ \\mathrm{s}$, $\\varepsilon = 1.0 \\times 10^{5}\\ \\mathrm{m/s}$, $p = 0.95$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\").",
            "solution": "The problem requires the derivation of analytical expressions for the statistics of a one-dimensional Ornstein-Uhlenbeck process and its Euler-Maruyama discretization, followed by the calculation of a minimum sample size $N_{\\min}$ needed to achieve a specified accuracy for the ensemble mean.\n\nThe governing Stochastic Differential Equation (SDE) is:\n$$ \\mathrm{d}v(t) = -\\nu v(t) \\mathrm{d}t + \\sqrt{2 \\nu v_{\\mathrm{th}}^2} \\mathrm{d}W_t $$\nwith initial condition $v(0) = v_0$. This is a standard Ornstein-Uhlenbeck process, which can be written in the form $\\mathrm{d}X_t = \\theta (\\mu - X_t) \\mathrm{d}t + \\sigma \\mathrm{d}W_t$. By comparing the forms, we identify the parameters:\n- Reversion rate: $\\theta = \\nu$\n- Long-term mean: $\\mu = 0$\n- Volatility: $\\sigma = \\sqrt{2 \\nu v_{\\mathrm{th}}^2}$\nThe thermal velocity squared is defined by the Einstein relation as $v_{\\mathrm{th}}^2 = \\frac{k_{\\mathrm{B}} T}{m}$.\n\n**1. Exact Mean and Variance of the Continuous Process**\n\nThe general solution for an Ornstein-Uhlenbeck process starting at $v_0$ is given by:\n$$ v(t) = v_0 e^{-\\theta t} + \\mu (1 - e^{-\\theta t}) + \\int_0^t \\sigma e^{-\\theta(t-s)} \\mathrm{d}W_s $$\nSubstituting the specific parameters for this problem ($\\theta = \\nu, \\mu = 0$), we get:\n$$ v(t) = v_0 e^{-\\nu t} + \\int_0^t \\sqrt{2 \\nu v_{\\mathrm{th}}^2} e^{-\\nu(t-s)} \\mathrm{d}W_s $$\n\nThe exact mean, $\\mathbb{E}[v(t)]$, is found by taking the expectation of the solution. The expectation of the Itô integral is zero.\n$$ \\mathbb{E}[v(t)] = \\mathbb{E}[v_0 e^{-\\nu t}] = v_0 e^{-\\nu t} $$\nThe mean velocity decays exponentially from its initial value $v_0$ to the long-term mean of $0$.\n\nThe exact variance, $\\mathrm{Var}[v(t)]$, is computed using the Itô isometry property, which states that $\\mathrm{Var}\\left[\\int_0^t f(s) \\mathrm{d}W_s\\right] = \\int_0^t \\mathbb{E}[f(s)^2] \\mathrm{d}s$.\n$$ \\mathrm{Var}[v(t)] = \\mathrm{Var}\\left[\\int_0^t \\sigma e^{-\\nu(t-s)} \\mathrm{d}W_s\\right] = \\int_0^t \\left(\\sigma e^{-\\nu(t-s)}\\right)^2 \\mathrm{d}s $$\n$$ \\mathrm{Var}[v(t)] = \\sigma^2 \\int_0^t e^{-2\\nu(t-s)} \\mathrm{d}s = \\sigma^2 \\left[ \\frac{e^{-2\\nu(t-s)}}{2\\nu} \\right]_0^t = \\frac{\\sigma^2}{2\\nu} (1 - e^{-2\\nu t}) $$\nSubstituting $\\sigma^2 = 2 \\nu v_{\\mathrm{th}}^2$:\n$$ \\mathrm{Var}[v(t)] = \\frac{2 \\nu v_{\\mathrm{th}}^2}{2\\nu} (1 - e^{-2\\nu t}) = v_{\\mathrm{th}}^2 (1 - e^{-2\\nu t}) $$\nAs $t \\to \\infty$, the variance approaches $v_{\\mathrm{th}}^2$, consistent with the system reaching thermal equilibrium.\n\n**2. Mean and Variance of the Euler–Maruyama Discretization**\n\nThe Euler-Maruyama (EM) scheme for the SDE is given as:\n$$ v_{n+1} = v_n - \\nu v_n \\Delta t + \\sqrt{2 \\nu v_{\\mathrm{th}}^2 \\Delta t} \\xi_n = (1 - \\nu \\Delta t) v_n + \\sqrt{2 \\nu v_{\\mathrm{th}}^2 \\Delta t} \\xi_n $$\nwhere $\\xi_n$ are independent standard normal random variables ($\\mathbb{E}[\\xi_n]=0$, $\\mathrm{Var}[\\xi_n]=1$).\n\nThe mean of the EM scheme, $\\mathbb{E}_{\\mathrm{EM}}[v_M]$, after $M$ steps is found by taking the expectation of the recurrence relation:\n$$ \\mathbb{E}_{\\mathrm{EM}}[v_{n+1}] = \\mathbb{E}_{\\mathrm{EM}}[(1 - \\nu \\Delta t) v_n] + \\mathbb{E}_{\\mathrm{EM}}[\\sqrt{2 \\nu v_{\\mathrm{th}}^2 \\Delta t} \\xi_n] = (1 - \\nu \\Delta t) \\mathbb{E}_{\\mathrm{EM}}[v_n] $$\nThis forms a geometric progression. Starting with the deterministic initial condition $\\mathbb{E}_{\\mathrm{EM}}[v_0] = v_0$, we obtain after $M$ steps:\n$$ \\mathbb{E}_{\\mathrm{EM}}[v_M] = (1 - \\nu \\Delta t)^M v_0 $$\n\nThe time-discretization bias at time $t = M \\Delta t$ is defined as $b_{\\Delta t} = |\\mathbb{E}_{\\mathrm{EM}}[v_M] - \\mathbb{E}[v(t)]|$.\n$$ b_{\\Delta t} = |v_0 (1 - \\nu \\Delta t)^M - v_0 e^{-\\nu M \\Delta t}| = |v_0| \\left| (1 - \\nu \\Delta t)^M - e^{-\\nu M \\Delta t} \\right| $$\n\nThe variance of the EM scheme, $\\mathrm{Var}[v_M]_{\\mathrm{EM}}$, is also found from the recurrence. Let $V_n = \\mathrm{Var}[v_n]_{\\mathrm{EM}}$. Since $v_n$ (which depends on $\\xi_0, \\dots, \\xi_{n-1}$) and $\\xi_n$ are independent:\n$$ V_{n+1} = \\mathrm{Var}[(1 - \\nu \\Delta t) v_n] + \\mathrm{Var}[\\sqrt{2 \\nu v_{\\mathrm{th}}^2 \\Delta t} \\xi_n] = (1 - \\nu \\Delta t)^2 V_n + 2 \\nu v_{\\mathrm{th}}^2 \\Delta t $$\nThis is a linear recurrence relation of the form $V_{n+1} = aV_n + b$ with $a = (1-\\nu\\Delta t)^2$ and $b = 2\\nu v_{\\mathrm{th}}^2 \\Delta t$. Starting with $V_0 = 0$ (since $v_0$ is deterministic), the solution after $M$ steps is the sum of a geometric series:\n$$ V_M = b \\sum_{k=0}^{M-1} a^k = b \\frac{1-a^M}{1-a} $$\nSubstituting for $a$ and $b$:\n$$ 1-a = 1 - (1 - 2\\nu\\Delta t + (\\nu\\Delta t)^2) = 2\\nu\\Delta t - (\\nu\\Delta t)^2 = \\nu\\Delta t (2-\\nu\\Delta t) $$\nThus, the variance at step $M$ is:\n$$ \\mathrm{Var}[v_M]_{\\mathrm{EM}} = \\frac{2 \\nu v_{\\mathrm{th}}^2 \\Delta t}{\\nu \\Delta t (2-\\nu\\Delta t)} (1 - (1-\\nu\\Delta t)^{2M}) = \\frac{2 v_{\\mathrm{th}}^2}{2 - \\nu\\Delta t} \\left(1 - (1 - \\nu\\Delta t)^{2M}\\right) $$\nFor numerical stability of the variance, we require $|a|1$, which implies $|1-\\nu\\Delta t|1$, or $0  \\nu\\Delta t  2$.\n\n**3. Sampling Variance and Minimum Ensemble Size ($N_{\\min}$)**\n\nThe sample mean $\\bar{v}_M$ is an estimator for $\\mathbb{E}_{\\mathrm{EM}}[v_M]$. For $N$ independent markers, its variance is:\n$$ \\mathrm{Var}[\\bar{v}_M] = \\mathrm{Var}\\left[\\frac{1}{N}\\sum_{i=1}^N v_M^{(i)}\\right] = \\frac{1}{N^2} \\sum_{i=1}^N \\mathrm{Var}[v_M^{(i)}] = \\frac{N \\cdot \\mathrm{Var}[v_M]_{\\mathrm{EM}}}{N^2} = \\frac{\\mathrm{Var}[v_M]_{\\mathrm{EM}}}{N} $$\nThe standard error of the mean is $\\sqrt{\\mathrm{Var}[\\bar{v}_M]} = \\sqrt{\\mathrm{Var}[v_M]_{\\mathrm{EM}} / N}$.\n\nThe problem requires that the total error, comprising the absolute discretization bias $b_{\\Delta t}$ and the statistical uncertainty, be bounded by a tolerance $\\varepsilon$. The statistical uncertainty is represented by the half-width of the normal-approximate confidence interval, $z_p \\sqrt{\\mathrm{Var}[\\bar{v}_M]}$. The criterion is:\n$$ b_{\\Delta t} + z_p \\sqrt{\\frac{\\mathrm{Var}[v_M]_{\\mathrm{EM}}}{N}} \\le \\varepsilon $$\nwhere $z_p$ is the standard Gaussian quantile for a two-sided confidence level $p$.\n\nFirst, a solution for $N$ is only possible if the fixed bias is less than the total allowed error, i.e., $b_{\\Delta t}  \\varepsilon$. If $\\varepsilon \\le b_{\\Delta t}$, the requirement cannot be met, regardless of the ensemble size $N$. In this case, we set $N_{\\min} = -1$.\n\nIf $\\varepsilon > b_{\\Delta t}$, we can rearrange the inequality to solve for $N$:\n$$ z_p \\sqrt{\\frac{\\mathrm{Var}[v_M]_{\\mathrm{EM}}}{N}} \\le \\varepsilon - b_{\\Delta t} $$\n$$ \\frac{\\mathrm{Var}[v_M]_{\\mathrm{EM}}}{N} \\le \\left(\\frac{\\varepsilon - b_{\\Delta t}}{z_p}\\right)^2 $$\n$$ N \\ge \\mathrm{Var}[v_M]_{\\mathrm{EM}} \\left(\\frac{z_p}{\\varepsilon - b_{\\Delta t}}\\right)^2 $$\nSince $N$ must be an integer, we take the ceiling of the right-hand side to find the minimum required number of markers:\n$$ N_{\\min} = \\left\\lceil \\mathrm{Var}[v_M]_{\\mathrm{EM}} \\left(\\frac{z_p}{\\varepsilon - b_{\\Delta t}}\\right)^2 \\right\\rceil $$\nThese derived formulas will be implemented to solve the test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the minimum ensemble size N_min for several test cases based on derived formulas\n    for the Langevin formulation of Coulomb collisions.\n    \"\"\"\n    KB = 1.380649e-23  # Boltzmann constant in J/K\n    E_EV = 1.602176634e-19  # Electronvolt in J\n    Z_095 = 1.95996398454005  # Gaussian quantile for 95% confidence\n\n    test_cases = [\n        # Case 1 (happy path, ion-like)\n        {'m': 3.343e-27, 'T_eV': 10000.0, 'nu': 5.0e4, 'v0_factor': 2.0, 't_final': 2.0e-3, 'dt': 2.0e-6, 'epsilon': 5.0e4, 'p': 0.95},\n        # Case 2 (coarse time step, bias-dominated)\n        {'m': 3.343e-27, 'T_eV': 2000.0, 'nu': 1.0e5, 'v0_factor': 1.5, 't_final': 1.0e-5, 'dt': 5.0e-6, 'epsilon': 3.0e4, 'p': 0.95},\n        # Case 3 (electron-like, high collisionality)\n        {'m': 9.10938356e-31, 'T_eV': 500.0, 'nu': 2.0e6, 'v0_factor': 1.0, 't_final': 1.0e-5, 'dt': 1.0e-8, 'epsilon': 2.0e5, 'p': 0.95},\n        # Case 4 (near-step-stability boundary)\n        {'m': 5.008e-27, 'T_eV': 20000.0, 'nu': 2.0e5, 'v0_factor': 0.5, 't_final': 9.0e-4, 'dt': 9.0e-6, 'epsilon': 1.0e5, 'p': 0.95},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        m, T_eV, nu, v0_factor, t_final, dt, epsilon, p = \\\n            case['m'], case['T_eV'], case['nu'], case['v0_factor'], case['t_final'], case['dt'], case['epsilon'], case['p']\n\n        # Pre-calculations\n        v_th_sq = (T_eV * E_EV) / m\n        v_th = np.sqrt(v_th_sq)\n        v0 = v0_factor * v_th\n        \n        # Consistent time and number of steps\n        M = int(round(t_final / dt))\n        t = M * dt\n        \n        # Quantile for the given confidence level (only p=0.95 used here)\n        z_p = Z_095\n\n        # 1. Calculate time-discretization bias (b_delta_t)\n        # Exact mean\n        E_exact = v0 * np.exp(-nu * t)\n        \n        # Euler-Maruyama mean\n        # Need to handle potential for large M causing underflow if v0 is large,\n        # but numpy handles large exponents.\n        base = 1.0 - nu * dt\n        E_em = v0 * (base ** M)\n        \n        bias = np.abs(E_em - E_exact)\n\n        # 2. Check sufficiency criterion\n        if epsilon = bias:\n            results.append(-1)\n            continue\n\n        # 3. Calculate Euler-Maruyama variance (Var[v_M]_EM)\n        nu_dt = nu * dt\n        # The term (1 - nu*dt) can be negative if nu*dt > 1\n        # The power is 2M, so the result is always positive.\n        term_pow = (1.0 - nu_dt) ** (2 * M)\n        \n        # Stability condition: 0  nu*dt  2 implies (2-nu*dt) > 0.\n        # Test cases respect this.\n        var_em = (2.0 * v_th_sq) / (2.0 - nu_dt) * (1.0 - term_pow)\n\n        # 4. Calculate N_min\n        n_raw = var_em * (z_p / (epsilon - bias))**2\n        n_min = int(np.ceil(n_raw))\n        \n        results.append(n_min)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}