{
    "hands_on_practices": [
        {
            "introduction": "陀螺平均算符 $\\Gamma_0(b)$ 是回旋动理学中描述有限拉莫尔半径 (FLR) 效应的数学核心。本练习将巩固您对这一关键算符行为的理解，通过数值计算并推导其渐近极限，您将为设计和分析准中性求解器的稳定性与准确性获得关键洞见，尤其是在不同波数区间。",
            "id": "4035322",
            "problem": "在计算聚变科学与工程的回旋动理学（GK）准中性求解器中，有限拉莫尔半径（FLR）极化响应在傅里叶空间中由标量回旋平均算子 $\\Gamma_0(b)$ 描述，其中 $b$ 定义为 $b = \\rho_i^2 k_\\perp^2$，$ \\rho_i$ 是离子拉莫尔半径，$k_\\perp$ 是垂直波数。对于麦克斯韦离子响应，$\\Gamma_0(b)$ 源于与圆周运动相关的因子的回旋相位平均，可以表示为以下对回旋相位角积分的形式：\n$$\n\\Gamma_0(b) \\equiv \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp\\!\\big(-b\\,(1-\\cos\\theta)\\big)\\,\\mathrm{d}\\theta,\n$$\n其中角度 $\\theta$ 以弧度为单位。该量是无量纲的。算子 $\\Gamma_0(b)$ 编码了准中性约束如何在数值求解器中耦合各种模式，并且是预条件子和矩阵组装策略的核心。对 $b \\ll 1$ 和 $b \\gg 1$ 情况下的 $\\Gamma_0(b)$ 进行稳健的数值评估和渐近分析，对于设计精确高效的求解器至关重要。\n\n仅从上述积分定义和标准的、广为接受的数学事实出发，推导 $\\Gamma_0(b)$ 在 $b \\to 0$ 和 $b \\to \\infty$ 时的领头渐近行为，并使其适用于求解器设计。然后，实现一个程序来：\n- 对一组跨越 $b \\in [10^{-3}, 10^{1}]$ 的指定 $b$ 值，高精度地数值计算 $\\Gamma_0(b)$。\n- 基于 $b \\to 0$ 展开式的前几个非平凡项，实现截断到 $b^2$ 阶的小 $b$ 渐近近似。\n- 基于 $b \\to \\infty$ 展开式的领头阶项，实现大 $b$ 渐近近似。\n- 在每个渐近近似的预期使用范围内，量化其相对误差。\n- 在提供的测试集中，检查 $\\Gamma_0(b)$ 的单调性，这与傅里叶空间求解器中准中性算子的条件数有关。\n\n使用以下 $b$ 的测试集（无量纲）：\n- $b = 10^{-3}$，\n- $b = 10^{-2}$，\n- $b = 10^{-1}$，\n- $b = 1$，\n- $b = 3$，\n- $b = 10$。\n\n对于误差分析，使用小 $b$ 子集 $\\{10^{-3}, 10^{-2}\\}$ 和大 $b$ 子集 $\\{3, 10\\}$ 来计算每个子集中的最大相对误差。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含：\n- 上述六个 $b$ 值对应的 $\\Gamma_0(b)$ 的数值（六个浮点数）。\n- 一个布尔值，指示 $\\Gamma_0(b)$ 在按所列顺序排列的六个 $b$ 值上是否严格单调递减。\n- 小 $b$ 渐近近似在小 $b$ 子集上的最大相对误差（浮点数）。\n- 大 $b$ 渐近近似在大 $b$ 子集上的最大相对误差（浮点数）。\n\n由于 $b$ 是无量纲的，因此不需要物理单位。积分定义中的角度 $\\theta$ 必须按弧度处理。最终输出格式必须严格为：\n$$\n[\\Gamma_0(10^{-3}),\\Gamma_0(10^{-2}),\\Gamma_0(10^{-1}),\\Gamma_0(1),\\Gamma_0(3),\\Gamma_0(10),\\text{monotone},E_{\\text{small}},E_{\\text{large}}].\n$$",
            "solution": "该问题要求对计算聚变科学中的回旋平均算子 $\\Gamma_0(b)$ 进行多步分析，其定义为积分：\n$$\n\\Gamma_0(b) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp\\!\\big(-b\\,(1-\\cos\\theta)\\big)\\,\\mathrm{d}\\theta\n$$\n分析过程包括推导无量纲参数 $b$ 在其值较小和较大时的渐近行为，实现一个数值方案以精确计算其值，并将数值结果与渐近近似进行比较。\n\n首先，我将推导 $b \\to 0$ 和 $b \\to \\infty$ 时的渐近展开式。这些推导将仅从积分定义和标准数学原理出发。\n\n**小 $b$ ($b \\to 0$) 的渐近分析**\n\n当 $b$ 值较小时，被积函数中指数的参数很小。因此我们可以使用指数函数的泰勒级数展开，$e^x = 1 + x + \\frac{x^2}{2!} + \\mathcal{O}(x^3)$。令 $x = -b(1-\\cos\\theta)$。将此代入指数函数，我们将被积函数展开如下：\n$$\n\\exp\\big(-b(1-\\cos\\theta)\\big) = 1 - b(1-\\cos\\theta) + \\frac{b^2}{2}(1-\\cos\\theta)^2 + \\mathcal{O}(b^3)\n$$\n将此展开式代入 $\\Gamma_0(b)$ 的积分中，可以进行逐项积分：\n$$\n\\Gamma_0(b) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\left[ 1 - b(1-\\cos\\theta) + \\frac{b^2}{2}(1-\\cos\\theta)^2 + \\mathcal{O}(b^3) \\right] \\mathrm{d}\\theta\n$$\n我们在区间 $[0, 2\\pi]$ 上计算必要的积分：\n1.  常数项的积分：$\\int_0^{2\\pi} 1\\,\\mathrm{d}\\theta = 2\\pi$。\n2.  $b$ 的线性项的积分：$\\int_0^{2\\pi} (1-\\cos\\theta)\\,\\mathrm{d}\\theta = \\left[\\theta - \\sin\\theta\\right]_0^{2\\pi} = 2\\pi$。\n3.  $b$ 的二次项的积分：\n$$\n\\int_0^{2\\pi} (1-\\cos\\theta)^2\\,\\mathrm{d}\\theta = \\int_0^{2\\pi} (1 - 2\\cos\\theta + \\cos^2\\theta)\\,\\mathrm{d}\\theta\n$$\n使用恒等式 $\\cos^2\\theta = \\frac{1}{2}(1+\\cos(2\\theta))$，积分变为：\n$$\n\\int_0^{2\\pi} \\left(1 - 2\\cos\\theta + \\frac{1}{2} + \\frac{1}{2}\\cos(2\\theta)\\right)\\,\\mathrm{d}\\theta = \\int_0^{2\\pi} \\left(\\frac{3}{2} - 2\\cos\\theta + \\frac{1}{2}\\cos(2\\theta)\\right)\\,\\mathrm{d}\\theta\n$$\n余弦项在一个完整周期上的积分为零，剩下：\n$$\n\\left[\\frac{3}{2}\\theta\\right]_0^{2\\pi} = 3\\pi\n$$\n将这些结果代回 $\\Gamma_0(b)$ 的展开式中：\n$$\n\\Gamma_0(b) = \\frac{1}{2\\pi} \\left[ 2\\pi - b(2\\pi) + \\frac{b^2}{2}(3\\pi) + \\mathcal{O}(b^3) \\right] = 1 - b + \\frac{3}{4}b^2 + \\mathcal{O}(b^3)\n$$\n问题要求近似在 $b^2$ 阶截断。因此，小 $b$ 的渐近近似为：\n$$\n\\Gamma_{0, \\text{small}}(b) = 1 - b + \\frac{3}{4}b^2\n$$\n\n**大 $b$ ($b \\to \\infty$) 的渐近分析**\n\n当 $b$ 值较大时，该积分主要由指数 $-b(1-\\cos\\theta)$ 取最大值的区域贡献。由于 $b > 0$ 且 $1-\\cos\\theta \\ge 0$，指数始终为非正数。其最大值为 $0$，出现在 $1-\\cos\\theta$ 为最小值时，即在 $\\theta=0$ 和 $\\theta=2\\pi$ 处。这提示我们使用拉普拉斯方法。\n\n在最大值点 $\\theta=0$ 附近，我们可以使用其泰勒展开来近似 $\\cos\\theta$：$\\cos\\theta \\approx 1 - \\frac{\\theta^2}{2}$。指数中的项变为：\n$$\n-b(1-\\cos\\theta) \\approx -b\\left(1 - \\left(1-\\frac{\\theta^2}{2}\\right)\\right) = -\\frac{b\\theta^2}{2}\n$$\n被积函数在 $\\theta=0$ 附近呈尖峰状。因此我们可以用一个在 $\\theta=0$ 小邻域上的高斯积分来近似该积分。因为对于 $b \\gg 1$，峰非常窄，将积分限扩展到 $(-\\infty, \\infty)$ 引入的误差可以忽略不计。\n$$\n\\Gamma_0(b) \\approx \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{b\\theta^2}{2}\\right) \\mathrm{d}\\theta\n$$\n这是一个标准的高斯积分，形式为 $\\int_{-\\infty}^{\\infty} e^{-ax^2} \\mathrm{d}x = \\sqrt{\\pi/a}$。在我们的例子中，变量是 $\\theta$，系数是 $a=b/2$。\n$$\n\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{b\\theta^2}{2}\\right) \\mathrm{d}\\theta = \\sqrt{\\frac{\\pi}{b/2}} = \\sqrt{\\frac{2\\pi}{b}}\n$$\n将此结果代回 $\\Gamma_0(b)$ 的表达式中：\n$$\n\\Gamma_0(b) \\approx \\frac{1}{2\\pi} \\sqrt{\\frac{2\\pi}{b}} = \\frac{1}{\\sqrt{2\\pi b}}\n$$\n这是大 $b$ 时的领头阶渐近行为。大 $b$ 的渐近近似为：\n$$\n\\Gamma_{0, \\text{large}}(b) = \\frac{1}{\\sqrt{2\\pi b}}\n$$\n\n**$\\Gamma_0(b)$ 的单调性**\n\n$\\Gamma_0(b)$ 对 $b$ 的导数可以通过在积分号下求导得到：\n$$\n\\frac{\\mathrm{d}\\Gamma_0(b)}{\\mathrm{d}b} = \\frac{1}{2\\pi} \\int_0^{2\\pi} \\frac{\\partial}{\\partial b} \\exp(-b(1-\\cos\\theta))\\,\\mathrm{d}\\theta = \\frac{1}{2\\pi} \\int_0^{2\\pi} -(1-\\cos\\theta)\\exp(-b(1-\\cos\\theta))\\,\\mathrm{d}\\theta\n$$\n对于任何 $\\theta \\in [0, 2\\pi]$，项 $1-\\cos\\theta \\ge 0$。指数项对于实数参数总是正的。因此，被积函数 $-(1-\\cos\\theta)\\exp(-b(1-\\cos\\theta))$ 是非正的。对于所有 $\\theta \\in (0, 2\\pi)$，被积函数是严格为负的。因此，对于任何 $b \\ge 0$，该积分必定严格为负。\n$$\n\\frac{\\mathrm{d}\\Gamma_0(b)}{\\mathrm{d}b}  0\n$$\n这证明了 $\\Gamma_0(b)$ 是 $b$ 的一个严格单调递减函数（对于 $b \\ge 0$）。计算任务将对离散的测试点集验证这一点。\n\n**数值实现策略**\n\n问题的数值部分包括四个主要任务：\n1.  **高精度计算**：$\\Gamma_0(b)$ 的积分将使用数值积分计算。`scipy.integrate.quad` 函数是合适的，因为被积函数是光滑且行为良好的。\n2.  **渐近值计算**：推导出的公式 $\\Gamma_{0, \\text{small}}(b)$ 和 $\\Gamma_{0, \\text{large}}(b)$ 将作为函数实现。\n3.  **误差分析**：将计算相对误差，定义为 $E_{\\text{rel}} = |\\text{近似值} - \\text{数值}| / |\\text{数值}|$。将在小 $b$ 子集 $\\{10^{-3}, 10^{-2}\\}$ 和大 $b$ 子集 $\\{3, 10\\}$ 上找到最大相对误差。\n4.  **单调性检查**：将检查为有序测试集 $b$ 值计算出的 $\\Gamma_0(b)$ 数值，以确认它们构成一个严格递减的序列。\n\n实现将按要求封装在一个 Python 脚本中。最终输出将是一行，包含六个 $\\Gamma_0(b)$ 的数值、单调性检查的布尔结果以及两个最大相对误差值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes numerical and asymptotic values for the gyroaveraging operator Gamma_0(b),\n    and performs error and monotonicity analysis as per the problem statement.\n    \"\"\"\n\n    # --- Test Suite ---\n    b_values = [1e-3, 1e-2, 1e-1, 1.0, 3.0, 10.0]\n    small_b_subset = [1e-3, 1e-2]\n    large_b_subset = [3.0, 10.0]\n\n    # --- Function Definitions ---\n\n    def integrand(theta, b):\n        \"\"\"The integrand for Gamma_0(b).\"\"\"\n        return np.exp(-b * (1.0 - np.cos(theta))) / (2.0 * np.pi)\n\n    def gamma0_numeric(b):\n        \"\"\"Computes Gamma_0(b) using numerical quadrature.\"\"\"\n        # quad returns a tuple (result, error_estimate)\n        result, _ = integrate.quad(integrand, 0, 2 * np.pi, args=(b,))\n        return result\n\n    def gamma0_small_b_asymptotic(b):\n        \"\"\"Asymptotic approximation for small b, truncated at O(b^2).\"\"\"\n        return 1.0 - b + 0.75 * b**2\n\n    def gamma0_large_b_asymptotic(b):\n        \"\"\"Leading-order asymptotic approximation for large b.\"\"\"\n        return 1.0 / np.sqrt(2.0 * np.pi * b)\n\n    # --- Calculations ---\n\n    # 1. Compute numerical values of Gamma_0(b) for all test cases.\n    numeric_results = [gamma0_numeric(b) for b in b_values]\n\n    # 2. Check for strict monotonicity.\n    # The list is strictly decreasing if each element is greater than the next.\n    is_monotone = all(numeric_results[i] > numeric_results[i+1] \n                      for i in range(len(numeric_results) - 1))\n\n    # 3. Compute maximum relative error for the small-b approximation.\n    errors_small = []\n    for b in small_b_subset:\n        numeric_val = gamma0_numeric(b)\n        asymptotic_val = gamma0_small_b_asymptotic(b)\n        relative_error = np.abs((asymptotic_val - numeric_val) / numeric_val)\n        errors_small.append(relative_error)\n    max_error_small = max(errors_small)\n\n    # 4. Compute maximum relative error for the large-b approximation.\n    errors_large = []\n    for b in large_b_subset:\n        numeric_val = gamma0_numeric(b)\n        asymptotic_val = gamma0_large_b_asymptotic(b)\n        relative_error = np.abs((asymptotic_val - numeric_val) / numeric_val)\n        errors_large.append(relative_error)\n    max_error_large = max(errors_large)\n\n    # --- Format and Print Output ---\n    \n    # Combine all results into a single list for printing.\n    final_results = numeric_results + [is_monotone, max_error_small, max_error_large]\n\n    # The final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在周期性区域上进行离散化时，准中性方程常常因物理上的规范自由度而导致一个奇异的线性系统。本练习将教授一种基本技巧——拉格朗日乘子法，用以施加约束来消除这种奇异性，从而确保得到唯一且具有物理意义的解。掌握这种方法对于为周期性等离子体模型开发稳健的求解器至关重要。",
            "id": "4035353",
            "problem": "您需要为一个在周期性域上适定的静电势，构建并实现一个离散的准中性求解器，方法是通过拉格朗日乘子强制施加磁通面平均约束。您必须从第一性原理推导出该约束，并实现相应的增广线性系统，以使离散化的准中性方程有唯一解。本问题中的所有量都是无量纲的，不需要物理单位。\n\n起点和基本原理：在磁化等离子体的静电回旋动理学（GK）理论中，准中性要求微扰电荷密度的总和为零，即\n$$\n\\left\\langle \\sum_{s} q_{s}\\,\\delta n_{s} \\right\\rangle \\;=\\; 0,\n$$\n其中 $q_{s}$ 是粒子种类 $s$ 的电荷，$\\delta n_{s}$ 是粒子种类 $s$ 的微扰密度，尖括号 $\\langle \\cdot \\rangle$ 表示磁通面平均（即在磁通面上的极向平均）。在一种常见的静电、长波长排序中，静电势 $\\phi$ 与电荷不平衡之间的线性化关系可以通过一个作用于 $\\phi$ 的自伴、非负极化算子来建模，该算子平衡了非玻尔兹曼响应。在一维周期性离散化中，这可以抽象为一个对称半正定矩阵方程\n$$\nA\\,\\phi \\;=\\; b,\n$$\n其中 $A \\in \\mathbb{R}^{N \\times N}$ 是半正定的，具有由常数向量张成的一维零空间（由于周期性和规范自由度），$\\phi \\in \\mathbb{R}^{N}$ 是在 $N$ 个网格点上势的未知向量，而 $b \\in \\mathbb{R}^{N}$ 是一个已知向量，表示来自动力学粒子种类的净电荷不平衡。周期性域意味着给 $\\phi$ 加上一个常数不会改变物理场，因此离散算子 $A$ 的零空间包含常数向量，除非有一个约束来固定 $\\phi$ 的平均值，否则该方程没有唯一解。\n\n磁通面平均约束：设 $w \\in \\mathbb{R}^{N}$ 是一个非负权重向量，满足 $\\sum_{j=0}^{N-1} w_{j} = 1$，它定义了一个离散的磁通面平均。$\\phi$ 的离散磁通面平均是 $C^{T}\\phi$，其中 $C = w$。为了固定规范，施加约束\n$$\nC^{T}\\,\\phi \\;=\\; \\gamma,\n$$\n其中 $\\gamma \\in \\mathbb{R}$ 是一个给定的标量（通常 $\\gamma = 0$）。\n\n拉格朗日乘子公式：引入一个拉格朗日乘子 $\\lambda \\in \\mathbb{R}$ 来施加约束，并考虑由对称算子 $A$ 构建的约束二次泛函：\n$$\n\\mathcal{J}(\\phi,\\lambda) \\;=\\; \\tfrac{1}{2}\\,\\phi^{T} A \\phi \\;-\\; b^{T}\\phi \\;+\\; \\lambda \\,\\left( C^{T}\\phi - \\gamma \\right).\n$$\n通过将关于 $\\phi$ 和 $\\lambda$ 的变分设为零，推导出一阶最优性条件。证明平稳条件产生了 Karush-Kuhn-Tucker (KKT) 系统\n$$\n\\begin{bmatrix}\nA  C \\\\\nC^{T}  0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\phi \\\\ \\lambda\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\nb \\\\ \\gamma\n\\end{bmatrix}.\n$$\n从线性代数的角度论证，如果 $A$ 是对称半正定的，且 $\\operatorname{null}(A)=\\operatorname{span}\\{ \\mathbf{1} \\}$ 并且 $C^{T}\\mathbf{1}\\neq 0$（由于 $\\sum_{j} w_{j} = 1$ 该条件成立），那么增广系统有唯一的解 $(\\phi,\\lambda)$。\n\n离散算子和可测试的实现：在一个具有 $N$ 个点的一维周期性网格上，点由 $j \\in \\{0,1,\\dots,N-1\\}$ 索引，通过离散周期拉普拉斯算子来近似极化算子。定义周期性二阶差分矩阵 $L \\in \\mathbb{R}^{N \\times N}$ 为\n$$\n(L\\phi)_{j} \\;=\\; \\phi_{j+1} - 2\\,\\phi_{j} + \\phi_{j-1},\n$$\n采用周期性索引，使得 $\\phi_{-1} \\equiv \\phi_{N-1}$ 且 $\\phi_{N} \\equiv \\phi_{0}$。使用半正定算子\n$$\nA \\;=\\; -\\,L,\n$$\n这样常数向量就位于 $A$ 的零空间中。如上所述，使用拉格朗日乘子实现该约束。\n\n算法任务：编写一个完整、可运行的程序，该程序\n- 为指定的 $N$ 构建矩阵 $A$；\n- 构建定义 $C=w$ 的权重向量 $w$ 和目标平均值 $\\gamma$；\n- 构建右侧项 $b$；\n- 求解增广 KKT 系统以得到 $(\\phi,\\lambda)$；\n- 计算两个残差\n$$\nr_{\\mathrm{eq}} \\;=\\; \\left\\| A\\,\\phi + C\\,\\lambda - b \\right\\|_{2}, \\qquad\nr_{\\mathrm{con}} \\;=\\; \\left| C^{T}\\phi - \\gamma \\right|,\n$$\n并返回单个标量\n$$\nr \\;=\\; \\max\\{ r_{\\mathrm{eq}},\\, r_{\\mathrm{con}} \\}.\n$$\n\n测试套件：您的程序必须为以下四个测试用例中的每一个计算标量 $r$，并在单行上输出列表 $[r_{1},r_{2},r_{3},r_{4}]$。所有量都是无量纲的，角度必须以弧度为单位。对于下面的每个案例，索引 $j$ 从 $0$ 到 $N-1$。\n\n- 案例 1（正常路径，零平均强迫项）：$N=8$。权重 $w_{j} = 1/N$。目标 $\\gamma = 0$。右侧项 $b_{j} = \\sin\\!\\left( 2\\pi \\cdot 2 \\cdot j / N \\right)$。\n- 案例 2（纯规范，非零目标平均值）：$N=8$。权重 $w_{j} = 1/N$。目标 $\\gamma = 1.2$。所有 $j$ 的右侧项 $b_{j} = 0$。\n- 案例 3（非均匀平均权重和不一致均值）：$N=8$。未归一化的权重 $\\tilde{w}_{j} = 1 + 0.2\\,\\sin\\!\\left( 2\\pi \\cdot j / N \\right)$ 且 $w = \\tilde{w}/\\sum_{k}\\tilde{w}_{k}$。目标 $\\gamma = -0.4$。右侧项 $b_{j} = \\cos\\!\\left( 2\\pi \\cdot j / N \\right) + 0.1$。\n- 案例 4（小系统边缘情况）：$N=3$。权重 $w_{j} = 1/N$。目标 $\\gamma = 0$。右侧项 $b = [1, -2, 1]$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[r_{1},r_{2},r_{3},r_{4}]$，其中每个 $r_{i}$ 是为相应测试用例定义的上述标量。例如，输出行可能看起来像\n$[1e-14,1e-14,2e-14,0.0]$\n这取决于数值舍入误差。不应打印任何额外文本。",
            "solution": "问题的核心是为离散准中性方程找到一个唯一的解，其抽象形式是一个欠定线性系统 $A\\,\\phi = b$，其中矩阵 $A \\in \\mathbb{R}^{N \\times N}$ 是对称半正定的，具有由常数向量 $\\mathbf{1} = [1, 1, \\dots, 1]^T$ 张成的一维零空间。为了使系统适定，我们必须引入一个额外的约束来固定规范自由度。该问题建议使用拉格朗日乘子法，对势的离散磁通面平均值施加一个约束，$C^T\\phi = \\gamma$。\n\n首先，我们从约束优化问题中推导增广 Karush-Kuhn-Tucker (KKT) 系统。任务是找到泛函 $\\mathcal{J}(\\phi, \\lambda)$ 相对于势 $\\phi \\in \\mathbb{R}^N$ 和拉格朗日乘子 $\\lambda \\in \\mathbb{R}$ 的一个驻点。该泛函由下式给出：\n$$\n\\mathcal{J}(\\phi,\\lambda) \\;=\\; \\tfrac{1}{2}\\,\\phi^{T} A \\phi \\;-\\; b^{T}\\phi \\;+\\; \\lambda \\,\\left( C^{T}\\phi - \\gamma \\right)\n$$\n为了找到驻点，我们将关于 $\\phi$ 和 $\\lambda$ 的梯度设为零。关于向量 $\\phi$ 的梯度是：\n$$\n\\nabla_{\\phi} \\mathcal{J} = \\frac{\\partial}{\\partial \\phi} \\left( \\tfrac{1}{2}\\,\\phi^{T} A \\phi - b^{T}\\phi + \\lambda C^{T}\\phi - \\lambda\\gamma \\right) = A\\phi - b + \\lambda C\n$$\n将其设为零可得第一个最优性条件：\n$$\nA\\phi + C\\lambda = b\n$$\n关于标量 $\\lambda$ 的梯度是：\n$$\n\\frac{\\partial}{\\partial \\lambda} \\mathcal{J} = \\frac{\\partial}{\\partial \\lambda} \\left( \\tfrac{1}{2}\\,\\phi^{T} A \\phi - b^{T}\\phi + \\lambda C^{T}\\phi - \\lambda\\gamma \\right) = C^T\\phi - \\gamma\n$$\n将其设为零可得第二个最优性条件，即原始约束：\n$$\nC^T\\phi = \\gamma\n$$\n将这两个线性方程组合成一个分块矩阵系统，我们得到指定的 KKT 系统：\n$$\n\\begin{bmatrix}\nA  C \\\\\nC^{T}  0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\phi \\\\ \\lambda\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\nb \\\\ \\gamma\n\\end{bmatrix}\n$$\n接下来，我们证明这个 $(N+1) \\times (N+1)$ 的增广系统是非奇异的，因此拥有唯一的解 $(\\phi, \\lambda)$。一个矩阵是非奇异的，当且仅当其零空间只包含零向量。设增广矩阵为 $M$。我们考察齐次系统 $M \\begin{pmatrix} v \\\\ \\alpha \\end{pmatrix} = \\mathbf{0}$，对于某个向量 $v \\in \\mathbb{R}^N$ 和标量 $\\alpha \\in \\mathbb{R}$：\n$$\n\\begin{bmatrix}\nA  C \\\\\nC^{T}  0\n\\end{bmatrix}\n\\begin{bmatrix}\nv \\\\ \\alpha\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\n\\mathbf{0} \\\\ 0\n\\end{bmatrix}\n$$\n该分块系统展开为两个方程：\n1. $Av + C\\alpha = \\mathbf{0}$\n2. $C^T v = 0$\n\n从方程 (1)，我们有 $Av = -\\alpha C$。根据线性代数基本定理，这个线性系统有解的条件是右侧项必须与 $A$ 的零空间正交。因为 $A$ 是对称的且 $\\operatorname{null}(A) = \\operatorname{span}\\{\\mathbf{1}\\}$，所以我们必须有 $\\mathbf{1}^T(-\\alpha C)=0$。\n$$\n-\\alpha (\\mathbf{1}^T C) = 0\n$$\n向量 $C$ 被定义为权重向量 $w$，题目给定 $\\sum_{j=0}^{N-1} w_j = 1$。这个和恰好是点积 $\\mathbf{1}^T w = \\mathbf{1}^T C$。因为 $\\mathbf{1}^T C = 1 \\neq 0$，上述条件要求 $\\alpha = 0$。\n\n将 $\\alpha=0$ 代回方程 (1) 得到 $Av = \\mathbf{0}$。这意味着 $v$ 必须在 $A$ 的零空间中。因此，$v$ 必须是常数向量的标量倍：对于某个标量 $k$，$v = k\\mathbf{1}$。\n\n现在，我们使用方程 (2)，$C^T v = 0$。代入 $v = k\\mathbf{1}$，我们得到：\n$$\nC^T(k\\mathbf{1}) = k(C^T\\mathbf{1}) = k \\cdot 1 = 0\n$$\n这意味着 $k=0$，进而意味着 $v=\\mathbf{0}$。\n既然我们已经证明了 $\\alpha=0$ 和 $v=\\mathbf{0}$ 是齐次系统的唯一解，那么增广矩阵 $M$ 的零空间是平凡的。因此，$M$ 是可逆的，对于任何给定的 $b$ 和 $\\gamma$，KKT 系统都有唯一的解。\n\n对于实现，极化算子 $A$ 取为一维周期性离散拉普拉斯算子的负数，即 $A = -L$。对于大小为 $N$ 的网格，矩阵 $L$ 是一个 $N \\times N$ 的循环矩阵，其元素为：\n$$\nL_{ij} = \\begin{cases} -2  \\text{若 } i=j \\\\ 1  \\text{若 } |i-j|=1 \\\\ 1  \\text{若 } \\{i,j\\}=\\{0, N-1\\} \\\\ 0  \\text{其他情况} \\end{cases}\n$$\n该算法通过为每个测试用例构建该矩阵 $A$、约束向量 $C=w$、向量 $b$ 和标量 $\\gamma$ 来进行。然后，组装增广的 $(N+1) \\times (N+1)$ KKT 矩阵及其对应的右侧向量。求解这个线性系统以得到包含 $\\phi$ 和 $\\lambda$ 的解向量。最后，计算残差 $r_{\\mathrm{eq}} = \\left\\| A\\,\\phi + C\\,\\lambda - b \\right\\|_{2}$ 和 $r_{\\mathrm{con}} = \\left| C^{T}\\phi - \\gamma \\right|$，并报告它们的最大值。",
            "answer": "```python\nimport numpy as np\n\ndef construct_A(N):\n    \"\"\"\n    Constructs the positive semidefinite matrix A = -L, where L is the\n    1D periodic discrete Laplacian matrix of size N x N.\n    \"\"\"\n    if N  3:\n        if N == 1: return np.array([[0.0]])\n        if N == 2: return np.array([[2.0, -2.0], [-2.0, 2.0]])\n\n    # Main diagonal\n    L = np.diag(-2 * np.ones(N))\n    # Super-diagonal and sub-diagonal\n    L += np.diag(np.ones(N - 1), k=1)\n    L += np.diag(np.ones(N - 1), k=-1)\n    # Periodic boundary conditions\n    L[0, N - 1] = 1.0\n    L[N - 1, 0] = 1.0\n    return -L\n\ndef solve_kkt_system(N, C, gamma, b):\n    \"\"\"\n    Solves the augmented KKT system for phi and lambda, and computes\n    the final residual r = max(r_eq, r_con).\n    \"\"\"\n    # 1. Construct the matrix A\n    A = construct_A(N)\n\n    # 2. Build the augmented KKT matrix M\n    M = np.zeros((N + 1, N + 1))\n    M[:N, :N] = A\n    M[:N, N] = C\n    M[N, :N] = C.T\n    \n    # 3. Build the augmented right-hand side vector RHS\n    RHS = np.zeros(N + 1)\n    RHS[:N] = b\n    RHS[N] = gamma\n\n    # 4. Solve the augmented system M * sol = RHS\n    try:\n        sol = np.linalg.solve(M, RHS)\n    except np.linalg.LinAlgError:\n        # In case of singularity, which shouldn't happen for a valid setup\n        return np.inf\n\n    # 5. Extract phi and the Lagrange multiplier lambda\n    phi = sol[:N]\n    lmbda = sol[N]\n\n    # 6. Compute the two residuals\n    # r_eq = || A*phi + C*lambda - b ||_2\n    r_eq = np.linalg.norm(A @ phi + C * lmbda - b)\n    \n    # r_con = | C^T*phi - gamma |\n    r_con = np.abs(C.T @ phi - gamma)\n\n    # 7. Return the maximum of the two residuals\n    return max(r_eq, r_con)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    j_indices = {\n        'case1': np.arange(8),\n        'case2': np.arange(8),\n        'case3': np.arange(8),\n        'case4': np.arange(3),\n    }\n\n    # Case 1: happy path, zero-average forcing\n    N1 = 8\n    w1 = np.full(N1, 1.0 / N1)\n    gamma1 = 0.0\n    b1 = np.sin(2.0 * np.pi * 2.0 * j_indices['case1'] / N1)\n    \n    # Case 2: pure gauge, nonzero target average\n    N2 = 8\n    w2 = np.full(N2, 1.0 / N2)\n    gamma2 = 1.2\n    b2 = np.zeros(N2)\n\n    # Case 3: nonuniform average weights and inconsistent mean\n    N3 = 8\n    j3 = j_indices['case3']\n    w_tilde3 = 1.0 + 0.2 * np.sin(2.0 * np.pi * j3 / N3)\n    w3 = w_tilde3 / np.sum(w_tilde3)\n    gamma3 = -0.4\n    b3 = np.cos(2.0 * np.pi * j3 / N3) + 0.1\n\n    # Case 4: small system edge case\n    N4 = 3\n    w4 = np.full(N4, 1.0 / N4)\n    gamma4 = 0.0\n    b4 = np.array([1.0, -2.0, 1.0])\n\n    test_cases = [\n        (N1, w1, gamma1, b1),\n        (N2, w2, gamma2, b2),\n        (N3, w3, gamma3, b3),\n        (N4, w4, gamma4, b4),\n    ]\n\n    results = []\n    for N, C, gamma, b in test_cases:\n        result = solve_kkt_system(N, C, gamma, b)\n        results.append(result)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "等离子体中电子的响应通常是非线性的（例如，绝热响应 $\\exp(\\phi)$），这使得准中性条件转化为一个非线性方程。通过本次实践，您将为求解此非线性问题实现并比较两种经典的迭代方案：牛顿法和皮卡法。这种动手比较将揭示它们迥异的收敛特性，并帮助您理解在不同物理情境下计算复杂性与稳健性之间的权衡。",
            "id": "4035342",
            "problem": "考虑静电回旋动理学中单个傅里叶模上的非线性准中性条件，该条件由电荷守恒、绝热电子响应和有限拉莫尔半径 (FLR) 极化推导得出。从以下基本要素出发：\n\n- 绝热电子响应：$n_{e} = n_{0} \\exp\\!\\left(\\frac{e \\varphi}{T_{e}}\\right)$，其中 $n_{0}$ 是参考密度，$e$ 是元电荷，$T_{e}$ 是电子温度，$\\varphi$ 是静电势。\n- 对于此单模诊断，离子回旋中心密度微扰设为零，$n_{i,\\text{gc}} = n_{0} (1 + s)$，其中 $s$ 是一个给定的无量纲分数偏移，代表一个小的源或汇。\n- FLR 极化闭合：离子极化密度通过算子 $\\Gamma_{0}(b)$ 修正准中性，其中 $b = k_{\\perp}^{2} \\rho_{i}^{2}$，$\\Gamma_{0}(b) = I_{0}(b) e^{-b}$，并且 $I_{0}$ 是第一类零阶修正贝塞尔函数。定义无量纲温度比 $\\tau = T_{e}/T_{i}$，以及有效极化系数 $a = \\tau \\left(1 - \\Gamma_{0}(b)\\right)$。\n\n在标准归一化 $\\varphi \\rightarrow \\frac{e \\varphi}{T_{e}}$ 下，$\\varphi$ 变为无量纲，且 $n_{e} / n_{0} = \\exp(\\varphi)$，单模准中性约束简化为求解 $\\varphi$ 使得\n$$\nF(\\varphi) \\equiv \\exp(\\varphi) - \\left(1 + s\\right) - a \\, \\varphi = 0,\n$$\n其中 $a = \\tau \\left(1 - I_{0}(b) e^{-b}\\right)$ 且 $b = k_{\\perp}^{2} \\rho_{i}^{2}$。\n\n你的任务是为标量非线性方程 $F(\\varphi) = 0$ 实现两种求解器：\n- 一种从第一性原理推导的 Newton 方法。\n- 一种通过将准中性方程重排为 $\\varphi = G(\\varphi)$ 形式得到的 Picard (不动点) 迭代法，其中 $G(\\varphi)$ 的选择基于控制物理过程，且不引入额外的近似。\n\n对于收敛性评估，使用残差 $\\left|F(\\varphi)\\right|$ 和绝对容差 $\\varepsilon$。将每种方法的迭代次数定义为在 $\\left|F(\\varphi)\\right|  \\varepsilon$ 之前执行的更新步数。如果方法在 $N_{\\max}$ 次迭代内未能达到容差，或遇到无效操作（例如，不动点映射中对数的参数为非正数），则报告迭代次数为整数 $-1$。\n\n实现以下参数值的测试套件，每个测试用例指定为元组 $(k_{\\perp}, \\rho_{i}, \\tau, s, \\varphi_{0}, \\varepsilon, N_{\\max})$：\n- A例 (理想情况，小FLR): $(k_{\\perp}, \\rho_{i}, \\tau, s, \\varphi_{0}, \\varepsilon, N_{\\max}) = \\left($ $0.3$, $0.5$, $1.0$, $0.05$, $0.0$, $10^{-12}$, $50$ $\\right)$。\n- B例 (接近收缩边界，中等FLR): $(k_{\\perp}, \\rho_{i}, \\tau, s, \\varphi_{0}, \\varepsilon, N_{\\max}) = \\left($ $4.0$, $0.3$, $1.5$, $0.01$, $0.0$, $10^{-10}$, $50$ $\\right)$。\n- C例 (强FLR，Picard法困难): $(k_{\\perp}, \\rho_{i}, \\tau, s, \\varphi_{0}, \\varepsilon, N_{\\max}) = \\left($ $6.0$, $0.3$, $2.5$, $0.05$, $0.0$, $10^{-10}$, $50$ $\\right)$。\n- D例 (边界情况，波数为零): $(k_{\\perp}, \\rho_{i}, \\tau, s, \\varphi_{0}, \\varepsilon, N_{\\max}) = \\left($ $0.0$, $0.5$, $1.0$, $0.05$, $0.2$, $10^{-14}$, $50$ $\\right)$。\n\n此处所有变量均为无量纲。角度未出现，输出中也不需要物理单位。\n\n算法要求：\n- 根据上述基本定义，使用 $F(\\varphi)$ 及其导数 $F'(\\varphi)$ 推导 Newton 更新公式。\n- 直接从准中性方程和绝热电子响应推导 Picard 映射 $G(\\varphi)$，不引入任何快捷公式。\n- 对两种方法均使用每个测试用例中提供的初始猜测值 $\\varphi_{0}$，并应用指定的容差 $\\varepsilon$ 和最大迭代次数 $N_{\\max}$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一对 $[\\text{Newton\\_iterations}, \\text{Picard\\_iterations}]$，整体输出是这些对的列表。例如，输出必须如下所示：\n$$\n\\left[ [n_{A}, p_{A}], [n_{B}, p_{B}], [n_{C}, p_{C}], [n_{D}, p_{D}] \\right],\n$$\n其中 $n_{X}$ 和 $p_{X}$ 是为 X 例定义的整数。",
            "solution": "本问题要求为标量非线性方程 $F(\\varphi) = \\exp(\\varphi) - (1 + s) - a\\varphi = 0$ 实现牛顿法和皮卡法两种求解器。首先，我们推导两种方法的迭代公式。\n\n**牛顿法**\n\n牛顿法的迭代更新公式为：\n$$\n\\varphi_{k+1} = \\varphi_k - \\frac{F(\\varphi_k)}{F'(\\varphi_k)}\n$$\n我们需要计算 $F(\\varphi)$ 的导数 $F'(\\varphi)$：\n$$\nF'(\\varphi) = \\frac{d}{d\\varphi} \\left( \\exp(\\varphi) - (1 + s) - a\\varphi \\right) = \\exp(\\varphi) - a\n$$\n因此，针对此问题的牛顿法迭代公式为：\n$$\n\\varphi_{k+1} = \\varphi_k - \\frac{\\exp(\\varphi_k) - (1+s) - a\\varphi_k}{\\exp(\\varphi_k) - a}\n$$\n\n**皮卡法（不动点迭代）**\n\n皮卡法要求将方程 $F(\\varphi)=0$ 重写为不动点形式 $\\varphi = G(\\varphi)$。根据问题的物理背景，$\\exp(\\varphi)$ 来自归一化的绝热电子密度 $n_e/n_0$。我们可以从中反解出电势 $\\varphi = \\ln(n_e/n_0)$。\n从准中性方程 $F(\\varphi)=0$ 中，我们可以将电子密度项分离出来：\n$$\n\\exp(\\varphi) = (1+s) + a\\varphi\n$$\n将此表达式代入 $\\varphi = \\ln(n_e/n_0)$，我们得到不动点映射函数 $G(\\varphi)$：\n$$\n\\varphi = G(\\varphi) = \\ln\\left((1+s) + a\\varphi\\right)\n$$\n对应的皮卡迭代公式为：\n$$\n\\varphi_{k+1} = \\ln\\left((1+s) + a\\varphi_k\\right)\n$$\n当 $|G'(\\varphi)|  1$ 时，此迭代收敛。其中 $G'(\\varphi) = a / ((1+s) + a\\varphi)$。\n\n**实现细节**\n\n对于每个测试用例，我们首先根据给定的物理参数 $(k_{\\perp}, \\rho_{i}, \\tau)$ 计算出系数 $b = (k_{\\perp}\\rho_{i})^2$ 和 $a = \\tau(1-I_0(b)e^{-b})$。然后，我们从初始猜测值 $\\varphi_0$ 开始，分别应用牛顿法和皮卡法的迭代公式。在每一步迭代中，我们计算残差 $|F(\\varphi)|$ 并检查其是否小于容差 $\\varepsilon$。如果满足条件，则记录迭代次数。如果迭代次数达到 $N_{\\max}$ 仍未收敛，或在计算过程中遇到数学错误（如对非正数取对数），则认为该方法失败，迭代次数记为 -1。\n\n特别地，对于 D 例，其中 $k_{\\perp}=0$，因此 $b=0$ 且 $\\Gamma_0(0)=1$，导致 $a=0$。方程简化为 $\\exp(\\varphi) = 1+s$，其精确解为 $\\varphi = \\ln(1+s)$。皮卡法 $\\varphi_{k+1} = \\ln(1+s)$ 会在一步内收敛。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import i0\n\ndef newton_solver(a, s, phi0, epsilon, N_max):\n    \"\"\"\n    Solves F(phi) = exp(phi) - (1+s) - a*phi = 0 using Newton's method.\n    \"\"\"\n    phi = float(phi0)\n    for i in range(N_max):\n        # Pre-compute exp(phi) for efficiency\n        # Handle potential overflow, though unlikely with given test cases\n        try:\n            exp_phi = np.exp(phi)\n        except OverflowError:\n            return -1\n\n        # Calculate residual F(phi)\n        f_val = exp_phi - (1.0 + s) - a * phi\n        \n        # Check for convergence before the update step\n        if np.abs(f_val)  epsilon:\n            return i\n            \n        # Calculate derivative F'(phi)\n        fp_val = exp_phi - a\n        \n        # Denominator close to zero can lead to instability or errors\n        if abs(fp_val)  1e-15: # A small threshold to avoid division by zero\n            return -1\n        \n        # Newton's update step\n        phi = phi - f_val / fp_val\n\n        # Check for non-finite values (NaN, Inf) after update\n        if not np.isfinite(phi):\n            return -1\n\n    # Final check after N_max iterations\n    try:\n        exp_phi = np.exp(phi)\n    except OverflowError:\n        return -1\n    f_val = exp_phi - (1.0 + s) - a * phi\n    if np.abs(f_val)  epsilon:\n        return N_max\n    else:\n        return -1\n\ndef picard_solver(a, s, phi0, epsilon, N_max):\n    \"\"\"\n    Solves F(phi) = 0 using the Picard iteration phi = ln((1+s) + a*phi).\n    \"\"\"\n    phi = float(phi0)\n    for i in range(N_max):\n        # Calculate residual F(phi) before the update\n        try:\n            exp_phi = np.exp(phi)\n        except OverflowError:\n            return -1\n        f_val = exp_phi - (1.0 + s) - a * phi\n\n        # Check for convergence before the update step\n        if np.abs(f_val)  epsilon:\n            return i\n            \n        # Argument for the logarithm in the Picard map\n        log_arg = (1.0 + s) + a * phi\n        \n        # Check for invalid logarithm argument\n        if log_arg = 0:\n            return -1\n            \n        # Picard's update step\n        phi = np.log(log_arg)\n        \n        # Check for non-finite values after update\n        if not np.isfinite(phi):\n            return -1\n            \n    # Final check after N_max iterations\n    try:\n        exp_phi = np.exp(phi)\n    except OverflowError:\n        return -1\n    f_val = exp_phi - (1.0 + s) - a * phi\n    if np.abs(f_val)  epsilon:\n        return N_max\n    else:\n        return -1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases: (k_perp, rho_i, tau, s, phi0, epsilon, N_max)\n    test_cases = [\n        (0.3, 0.5, 1.0, 0.05, 0.0, 1e-12, 50),   # Case A\n        (4.0, 0.3, 1.5, 0.01, 0.0, 1e-10, 50),   # Case B\n        (6.0, 0.3, 2.5, 0.05, 0.0, 1e-10, 50),   # Case C\n        (0.0, 0.5, 1.0, 0.05, 0.2, 1e-14, 50),   # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        k_perp, rho_i, tau, s, phi0, epsilon, N_max = case\n        \n        # Calculate the intermediate parameters b and a\n        b = (k_perp * rho_i)**2\n        \n        # The term I_0(b) * exp(-b) can be computed with a single function\n        # scipy.special.i0e for better numerical stability, but i0 also works\n        # for these parameters as b is not excessively large.\n        gamma0 = i0(b) * np.exp(-b)\n        \n        a = tau * (1.0 - gamma0)\n        \n        # Run both solvers\n        n_iters = newton_solver(a, s, phi0, epsilon, N_max)\n        p_iters = picard_solver(a, s, phi0, epsilon, N_max)\n        \n        results.append([n_iters, p_iters])\n\n    # Format the output string as specified\n    # The default str() for a list, e.g., str([1, 2]), is '[1, 2]', which does not have spaces\n    # and matches the required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}