{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握基于标记的 delta-f ($ \\delta f $) 算法，理论知识必须与实际操作技能相辅相成。本章提供了一系列动手实践练习，旨在帮助您逐步掌握 $ \\delta f $ 模拟代码的关键组成部分，从初始标记加载到高级边界条件处理。第一个实践  聚焦于任何 $ \\delta f $ 模拟中最关键的第一步：初始化标记分布。您将学习如何实现“静启动”方案，通过确保初始的净扰动电荷和电流为零来最小化模拟初期的伪噪声，这项练习将加深您对离散标记属性与连续物理矩之间联系的理解。",
            "id": "4008329",
            "problem": "你的任务是在计算聚变科学与工程领域，为基于标记点的差分分布函数（delta-f）方法推导并实现一种“静启动”加载方案。在基于标记点的 delta-f 方法中，总分布函数被分解为 $f = f_0 + \\delta f$，其中 $f_0$ 是一个已知的平衡态，$\\delta f$ 是一个由携带权重的计算标记点表示的小微扰。“静启动”的目标是初始化标记点，使得在 $t=0$ 时，净微扰电荷和净微扰平行电流均为零，从而最小化非物理的瞬态场。\n\n从以下基本依据出发：\n\n- 沿引导磁场方向的磁化等离子体的动力学描述由 $f(\\boldsymbol{x},\\boldsymbol{v},t)$ 的弗拉索夫方程（Vlasov equation）与麦克斯韦方程组（Maxwell equations）耦合所描述。对于微扰 $\\delta f$，电荷密度微扰和平行电流微扰由下式给出：\n$$\\delta n(\\boldsymbol{x},t) = \\int \\delta f(\\boldsymbol{x},\\boldsymbol{v},t)\\,\\mathrm{d}^3 v,\\qquad \\delta j_{\\parallel}(\\boldsymbol{x},t) = \\int v_{\\parallel}\\,\\delta f(\\boldsymbol{x},\\boldsymbol{v},t)\\,\\mathrm{d}^3 v.$$\n- 在基于标记点的表示法中，设标记点索引为 $p$，其平行速度为 $v_{\\parallel p}$，权重为 $w_p$，用于对平衡态 $f_0$ 进行采样，则离散矩近似为：\n$$\\delta n \\approx \\sum_{p} w_p,\\qquad \\delta j_{\\parallel} \\approx \\sum_{p} w_p\\, v_{\\parallel p}.$$\n- 因此，“静启动”的一个充分条件是：\n$$\\sum_{p} w_p = 0\\quad\\text{且}\\quad \\sum_{p} w_p\\, v_{\\parallel p} = 0.$$\n\n设计一个方案，该方案能构建速度对称对并分配权重，以确保两个约束条件都得到满足。该方案必须是自洽的且物理上合理的。你可以假设速度空间是一维平行速度空间，并且所有标记点在位形空间中均匀分布，因此空间形状函数不会对求和产生偏差。平行速度 $v_{\\parallel}$ 必须以米/秒 (m/s) 为单位表示。权重 $w_p$ 是无量纲的。\n\n你的推导必须从第一性原理和上述核心定义出发，说明为什么在 $v_{\\parallel}$ 中进行对称配对并选择适当的权重可以实现 $\\sum_{p} w_p = 0$ 和 $\\sum_{p} w_p v_{\\parallel p} = 0$。这包括一种数学上精确的方法，用于从一个 $v_{\\parallel}$ 的偶函数形式的目标形状函数（例如，一个关于 $v_{\\parallel}^2$ 的函数）构造权重，并在不破坏零电流约束的情况下强制执行零净电荷约束。\n\n然后，实现一个完整、可运行的程序，该程序能够：\n\n- 对给定的热速度 $v_{\\mathrm{th}}$（单位为 $\\mathrm{m/s}$），使用高斯-埃尔米特（Gauss–Hermite）节点集或 $v_{\\parallel}$ 上的均匀网格，构建 $M$ 个速度对称对 $\\{\\pm v_i\\}_{i=1}^M$。\n- 从一个选定的偶振幅函数 $a(v)$ 计算对级权重 $w_i$，并通过对集合 $\\{w_i\\}_{i=1}^M$ 进行均值移除步骤来强制执行离散的零净电荷约束，该步骤不违反每对的零电流条件。\n- 为一对中的两个标记点分配相同的权重，即 $w_{(+v_i)} = w_{(-v_i)} = w_i$，并构建大小为 $2M$ 的完整标记点集。\n- 报告每个测试用例的净电荷矩的绝对值 $|\\sum_p w_p|$（无量纲）和净电流矩的绝对值 $\\left|\\sum_p w_p v_{\\parallel p}\\right|$（单位为 $\\mathrm{m/s}$）。\n\n测试套件：\n\n提供以下测试用例来检验你的实现。对于所有情况，不使用角度，因此不需要角度单位。通过使用合理的热速度来确保科学真实性。\n\n- 情况 1（理想路径）：$M=10$，热速度 $v_{\\mathrm{th}} = 2.0\\times 10^{5}\\,\\mathrm{m/s}$，速度网格类型为“Hermite”，使用 $2M$ 个高斯-埃尔米特节点，振幅 $a(v) = \\varepsilon \\exp\\!\\left(-\\frac{v^2}{v_{\\mathrm{th}}^2}\\right)\\left(\\frac{v^2}{v_{\\mathrm{th}}^2} - 1\\right)$，其中 $\\varepsilon = 10^{-3}$。\n- 情况 2（最小对数的边界情况）：$M=1$，热速度 $v_{\\mathrm{th}} = 3.0\\times 10^{5}\\,\\mathrm{m/s}$，速度网格类型为“Uniform”，在 $[0, 2 v_{\\mathrm{th}}]$ 上，振幅 $a(v) = \\varepsilon$，其中 $\\varepsilon = 10^{-2}$。\n- 情况 3（非平凡的偶函数尾部形状）：$M=7$，热速度 $v_{\\mathrm{th}} = 1.5\\times 10^{5}\\,\\mathrm{m/s}$，速度网格类型为“Hermite”，使用 $2M$ 个节点，振幅 $a(v) = \\varepsilon \\left(1 + \\left(\\frac{v}{v_{\\mathrm{th}}}\\right)^4\\right)^{-1}$，其中 $\\varepsilon = 5\\times 10^{-4}$。\n- 情况 4（均匀网格上更大的动态范围）：$M=16$，热速度 $v_{\\mathrm{th}} = 4.0\\times 10^{5}\\,\\mathrm{m/s}$，速度网格类型为“Uniform”，在 $[0, 4 v_{\\mathrm{th}}]$ 上，振幅 $a(v) = \\varepsilon \\left(\\frac{v}{v_{\\mathrm{th}}}\\right)^2 \\exp\\!\\left(-\\frac{v}{v_{\\mathrm{th}}}\\right)$，其中 $\\varepsilon = 2\\times 10^{-3}$。\n\n答案规格：\n\n- 对每个测试用例，计算两个浮点数：$|\\sum_p w_p|$（无量纲）和 $\\left|\\sum_p w_p v_{\\parallel p}\\right|$（单位为 $\\mathrm{m/s}$）。\n- 你的程序应生成一行输出，其中包含所有测试用例的结果，形式为用方括号括起来的逗号分隔列表，按测试用例和指标的顺序排列，即 $[c_1, j_1, c_2, j_2, c_3, j_3, c_4, j_4]$，其中 $c_k$ 是情况 $k$ 的 $|\\sum_p w_p|$，$j_k$ 是情况 $k$ 的 $\\left|\\sum_p w_p v_{\\parallel p}\\right|$。",
            "solution": "该问题要求为基于标记点的 delta-f ($\\delta f$) PIC（particle-in-cell）算法推导并实现一种“静启动”加载方案。“静启动”是通过初始化计算标记点来实现的，使得在初始时刻 $t=0$ 时，净微扰电荷和净微扰平行电流均为零。这可以最大程度地减少模拟开始时产生的虚假的非物理场。\n\n根据所提供的定义，微扰电荷密度 $\\delta n$ 和平行电流密度 $\\delta j_{\\parallel}$ 的离散近似由对所有计算标记点 $p$ 的求和给出：\n$$ \\delta n \\approx \\sum_{p} w_p $$\n$$ \\delta j_{\\parallel} \\approx \\sum_{p} w_p v_{\\parallel p} $$\n其中 $w_p$ 是标记点 $p$ 的权重，$v_{\\parallel p}$ 是其平行速度。因此，“静启动”条件就是这两个和必须为零的约束：\n$$ \\sum_{p} w_p = 0 \\quad (\\text{零净电荷}) $$\n$$ \\sum_{p} w_p v_{\\parallel p} = 0 \\quad (\\text{零净电流}) $$\n\n我们现在将推导一个构造性算法，以生成一组满足这两个条件的标记点速度 $\\{v_{\\parallel p}\\}$ 和权重 $\\{w_p\\}$。\n\n该方案的核心是从速度空间中的对称对来构建标记点总体。设标记点总数为 $2M$，由 $M$ 对组成。对于每一对，索引为 $i$（其中 $i$ 从 $1$ 到 $M$），我们定义两个标记点，一个具有正速度，另一个具有负速度。\n\n设基础正速度集合为 $\\{v_i\\}_{i=1}^M$，其中每个 $v_i \\ge 0$。第 $i$ 对标记点的速度将是：\n$$ v_{\\parallel, i, +} = +v_i $$\n$$ v_{\\parallel, i, -} = -v_i $$\n为通过构造满足零电流条件，我们为给定对中的两个标记点分配*相同*的权重。设此对级权重为 $w_i$。\n$$ w_{i, +} = w_i $$\n$$ w_{i, -} = w_i $$\n\n让我们验证这种构造是否保证净平行电流为零。电流的总和可以按对分组：\n$$ \\sum_{p} w_p v_{\\parallel p} = \\sum_{i=1}^{M} \\left( w_{i,+} v_{\\parallel, i, +} + w_{i,-} v_{\\parallel, i, -} \\right) $$\n代入配对速度和权重的定义：\n$$ \\sum_{i=1}^{M} \\left( w_i (+v_i) + w_i (-v_i) \\right) = \\sum_{i=1}^{M} w_i (v_i - v_i) = \\sum_{i=1}^{M} (w_i \\cdot 0) = 0 $$\n这表明，速度的对称配对 $(\\pm v_i)$ 与相同的权重 $(w_i)$ 天然满足零电流条件，而与 $v_i$ 和 $w_i$ 的具体值无关。即使在有限精度运算中，这也成立，因为每对的相消 $(v_i - v_i)$ 都是精确的。\n\n接下来，我们处理零电荷条件 $\\sum_{p} w_p = 0$。使用相同的基于对的分组：\n$$ \\sum_{p} w_p = \\sum_{i=1}^{M} (w_{i,+} + w_{i,-}) = \\sum_{i=1}^{M} (w_i + w_i) = 2 \\sum_{i=1}^{M} w_i $$\n因此，为了使总电荷为零，我们必须对对级权重强制执行以下条件：\n$$ \\sum_{i=1}^{M} w_i = 0 $$\n\n对级权重 $w_i$ 是根据速度空间中期望的初始微扰形状确定的，该形状由一个振幅函数 $a(v)$ 描述。对于在速度上对称的物理微扰（例如加热），$a(v)$ 通常是 $v$ 的偶函数，例如 $v^2$ 的函数。我们首先通过在正基础速度 $v_i$ 处评估振幅函数来计算一组“原始”权重 $w'_i$：\n$$ w'_i = a(v_i) \\quad \\text{for } i=1, \\dots, M $$\n这些原始权重的和 $S = \\sum_{i=1}^{M} w'_i$ 通常不为零。\n\n为了强制执行零和约束，我们应用均值移除校正。我们计算原始权重的平均值：\n$$ \\bar{w}' = \\frac{1}{M} \\sum_{j=1}^{M} w'_j $$\n然后，通过从每个原始权重中减去该平均值来获得最终的对级权重 $w_i$：\n$$ w_i = w'_i - \\bar{w}' $$\n让我们验证这组校正后的权重之和是否为零：\n$$ \\sum_{i=1}^{M} w_i = \\sum_{i=1}^{M} (w'_i - \\bar{w}') = \\left(\\sum_{i=1}^{M} w'_i\\right) - \\sum_{i=1}^{M} \\bar{w}' = (M\\bar{w}') - M\\bar{w}' = 0 $$\n此过程成功地生成了一组对级权重 $\\{w_i\\}$，其和为零（在机器精度范围内），从而满足零电荷条件 $\\sum_p w_p = 0$。由于此调整是在将对级权重 $w_i$ 分配给 $(\\pm v_i)$ 标记点之前进行的，因此保证零电流的对称结构得以保留。因此，该方案是自洽的。\n\n基础正速度集合 $\\{v_i\\}_{i=1}^M$ 可以通过多种方式生成。问题指定了两种：\n1.  **均匀网格**：对于给定的速度范围，例如 $[0, v_{\\max}]$，和 $M$ 对，可以均匀地采样速度。一种稳健的方法是选择 $M$ 个子区间的中心，即 $v_i = (i-0.5) \\frac{v_{\\max}}{M}$，对于 $i=1, \\dots, M$。\n2.  **高斯-埃尔米特网格**：高斯-埃尔米特求积（Gauss-Hermite quadrature）的节点天然适合于对高斯权重函数进行采样，这在等离子体物理学中很常见。对于总共 $2M$ 个标记点，计算埃尔米特多项式 $H_{2M}(x)$ 的 $2M$ 个根。这些根关于 $x=0$ 对称。我们选择 $M$ 个正根 $\\{x_j\\}_{j=1}^M$。然后将这些根通过一个特征热速度 $v_{\\mathrm{th}}$ 进行缩放，以获得物理速度：$v_i = v_{\\mathrm{th}} x_i$。当底层分布函数 $f_0$ 是麦克斯韦分布时，此方法特别有效。\n\n总结来说，算法如下：\n1.  选择对的数量 $M$。\n2.  使用指定的网格类型生成一组 $M$ 个正速度 $\\{v_i\\}_{i=1}^M$。\n3.  使用给定的振幅函数 $a(v)$ 计算原始权重 $\\{w'_i\\}_{i=1}^M$，使得 $w'_i = a(v_i)$。\n4.  计算原始权重的平均值 $\\bar{w}' = \\frac{1}{M}\\sum_i w'_i$。\n5.  计算最终的、校正后的对级权重 $w_i = w'_i - \\bar{w}'$。\n6.  将完整的 $2M$ 个标记点构造为 $\\{(\\pm v_i, w_i)\\}_{i=1}^M$。根据构造，这组标记点具有 $\\sum_p w_p v_{\\parallel p} = 0$ 和 $\\sum_p w_p = 0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.polynomial.hermite import hermgauss\n\ndef solve():\n    \"\"\"\n    Derives and implements a quiet-start loading scheme for a marker-based\n    delta-f algorithm, ensuring zero net charge and current perturbations.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"M\": 10,\n            \"v_th\": 2.0e5,\n            \"grid_type\": \"Hermite\",\n            \"grid_param\": None,  # Not used for Hermite\n            \"a_func\": lambda v, v_th, eps: eps * np.exp(-(v/v_th)**2) * ((v/v_th)**2 - 1),\n            \"epsilon\": 1e-3,\n        },\n        {\n            \"M\": 1,\n            \"v_th\": 3.0e5,\n            \"grid_type\": \"Uniform\",\n            \"grid_param\": 2.0,  # Grid range is [0, grid_param * v_th]\n            \"a_func\": lambda v, v_th, eps: eps * np.ones_like(v),\n            \"epsilon\": 1e-2,\n        },\n        {\n            \"M\": 7,\n            \"v_th\": 1.5e5,\n            \"grid_type\": \"Hermite\",\n            \"grid_param\": None,\n            \"a_func\": lambda v, v_th, eps: eps / (1 + (v/v_th)**4),\n            \"epsilon\": 5e-4,\n        },\n        {\n            \"M\": 16,\n            \"v_th\": 4.0e5,\n            \"grid_type\": \"Uniform\",\n            \"grid_param\": 4.0,\n            \"a_func\": lambda v, v_th, eps: eps * (v/v_th)**2 * np.exp(-v/v_th),\n            \"epsilon\": 2e-3,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        M = case[\"M\"]\n        v_th = case[\"v_th\"]\n        grid_type = case[\"grid_type\"]\n        grid_param = case[\"grid_param\"]\n        a_func = case[\"a_func\"]\n        epsilon = case[\"epsilon\"]\n\n        # Step 1: Construct M positive velocities {v_i}\n        if grid_type == \"Hermite\":\n            # hermgauss provides 2M symmetric roots for H_{2M}(x)\n            # Scaling for nodes is v = v_th * x, matching exp(-v^2/v_th^2) to exp(-x^2)\n            nodes, _ = hermgauss(2 * M)\n            # Take the M positive roots\n            positive_velocities = nodes[M:] * v_th\n        elif grid_type == \"Uniform\":\n            # Generate M points on [0, v_max] as cell centers\n            # This avoids v=0 and is more robust for M=1\n            v_max = grid_param * v_th\n            delta_v = v_max / M\n            indices = np.arange(1, M + 1)\n            positive_velocities = (indices - 0.5) * delta_v\n        \n        # Step 2: Compute raw pair-level weights w'_i\n        raw_weights = a_func(positive_velocities, v_th, epsilon)\n        \n        # Step 3: Enforce zero-net-charge via mean removal\n        if M > 0:\n            mean_raw_weight = np.mean(raw_weights)\n            final_pair_weights = raw_weights - mean_raw_weight\n        else: # Handle empty case\n            final_pair_weights = np.array([])\n\n        # Step 4: Construct the full marker set and calculate moments\n        # The full set consists of M pairs: (+v_i, w_i) and (-v_i, w_i)\n        \n        # Velocities: [+v_1, ..., +v_M, -v_1, ..., -v_M]\n        full_velocities = np.concatenate([positive_velocities, -positive_velocities])\n        \n        # Weights: [w_1, ..., w_M, w_1, ..., w_M]\n        full_weights = np.concatenate([final_pair_weights, final_pair_weights])\n\n        # Calculate net charge and current moments\n        # These should be zero up to machine precision\n        net_charge = np.sum(full_weights)\n        net_current = np.sum(full_weights * full_velocities)\n        \n        results.extend([abs(net_charge), abs(net_current)])\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join(f'{r:.18e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "$ \\delta f $ 算法的核心是粒子与场之间的自洽循环，其中场求解器是连接两者的桥梁。本次实践  专注于场求解环节，特别是在聚变研究中常见的剪切平板位形下的实现。您将推导并实现场向对齐坐标系下的垂直拉普拉斯算子 $ \\nabla_\\perp^2 $，这一任务不仅涉及处理非平凡的坐标变换，还要求您将连续介质方程离散化，从而深刻理解其数值实现过程。",
            "id": "4008349",
            "problem": "考虑一个局域剪切平板中的静电回旋动理学 delta-微扰 ($\\delta f$) 格式。该剪切平板使用具有欧几里得度规的垂直笛卡尔坐标 $(x,y)$ 以及沿磁力线的平行坐标 $z$。假设磁场强度 $B_0$ 均匀且磁剪切 $s$ 为常数。通过变换 $\\alpha = y - s x z$ 定义场向副法线坐标 $\\alpha$，其中 $x$ 保持不变，$z$ 作为沿磁场的坐标。垂直拉普拉斯算子作用于与磁力线横向的平面内。\n\n从第一性原理出发，使用欧几里得空间中梯度和拉普拉斯算子的标准定义，并在固定 $z$ 的情况下，对从 $(x,y)$ 到 $(x,\\alpha)$ 的坐标变换应用链式法则，以推导在场向坐标 $(x,\\alpha)$ 中，对于恒定剪切 $s$ 的垂直拉普拉斯算子 $\\nabla_\\perp^2$ 的显式形式。使用偏导数、梯度和在标准正交基下拉普拉斯算子的基本定义，仔细论证推导的每一步。\n\n使用推导出的 $\\nabla_\\perp^2$ 形式，为剪切平板中的静电准中性方程构建一个二阶精确的离散算子，\n$$\n- \\alpha_p \\nabla_\\perp^2 \\phi + \\beta_p \\phi = \\rho_\\delta,\n$$\n其中 $\\phi$ 是静电势，$\\alpha_p$ 和 $\\beta_p$ 是常系数（例如，$\\alpha_p$ 可以表示极化响应，$\\beta_p$ 表示德拜或绝热响应），$\\rho_\\delta$ 是在基于标记点的 delta-微扰算法中由标记点权重产生的电荷密度。在归一化单位下，所有物理量都是无量纲的。该离散算子必须在 $x$ 和 $\\alpha$ 方向上使用均匀网格，并采用周期性边界条件，对横向平面中所有需要的导数使用二阶中心差分。\n\n为评估您的离散算子，请在 $(x,\\alpha)$ 平面上定义测试势为\n$$\n\\phi(x,\\alpha) = \\sin\\left(\\frac{2\\pi x}{L_x}\\right)\\cos\\left(\\frac{2\\pi \\alpha}{L_\\alpha}\\right),\n$$\n其中 $L_x$ 和 $L_\\alpha$ 是区域长度。对于基于标记点的电荷密度，请使用标准的网格云 (CIC) 格式，在周期性边界条件下，将一组带有权重的 delta-微扰标记点投射到 $(x,\\alpha)$ 网格上。CIC 格式必须确保总标记点权重等于离散 $\\rho_\\delta$ 在整个区域上的积分，即该格式在面积上积分时必须保持 $\\sum_k w_k$ 不变。具体来说，使用双线性权重将每个标记点投射到其最近的四个网格节点上，并按单元面积进行归一化，以使投射后的场在所选归一化方案中具有正确的单位。\n\n您的程序必须：\n- 推导并实现恒定剪切 $s$ 下 $(x,\\alpha)$ 坐标中垂直拉普拉斯算子 $\\nabla_\\perp^2$ 的离散形式，使用二阶中心差分，并正确处理因剪切而产生的任何混合导数。\n- 对于每个测试案例，使用链式法则和 $\\phi(x,\\alpha)$ 的精确导数，解析地计算连续的 $\\nabla_\\perp^2 \\phi$ 以进行比较。\n- 构建离散的准中性方程左侧 $- \\alpha_p \\nabla_\\perp^2 \\phi + \\beta_p \\phi$ 和由标记点投射得到的右侧 $\\rho_\\delta$。\n- 为每个测试案例报告两个标量诊断量：离散 $\\nabla_\\perp^2 \\phi$ 与解析 $\\nabla_\\perp^2 \\phi$ 之间的均方根 (RMS) 误差，以及准中性残差 $- \\alpha_p \\nabla_\\perp^2 \\phi + \\beta_p \\phi - \\rho_\\delta$ 在整个网格上的均方根范数。\n\n所有量均为无量纲；不需要物理单位。任何角度（如果存在）都必须作为三角函数的无量纲参数处理。\n\n使用以下测试套件，其中每个案例指定 $(N_x,N_\\alpha,L_x,L_\\alpha,s,z,\\alpha_p,\\beta_p,\\text{markers})$。此处 $N_x$ 和 $N_\\alpha$ 分别是 $x$ 和 $\\alpha$ 方向上的均匀网格点数；$z$ 是评估算子时所在的平行坐标值；标记点以三元组 $(x_k,\\alpha_k,w_k)$ 的形式给出：\n\n- 测试案例 1：$(N_x,N_\\alpha,L_x,L_\\alpha,s,z,\\alpha_p,\\beta_p) = (16,16,1.0,1.0,0.0,0.0,1.0,0.0)$，标记点 $[(0.25,0.75,0.5),(0.9,0.1,-0.25)]$。\n- 测试案例 2：$(N_x,N_\\alpha,L_x,L_\\alpha,s,z,\\alpha_p,\\beta_p) = (32,20,1.0,0.8,0.2,1.0,0.7,0.3)$，标记点 $[(0.10,0.20,1.0),(0.70,0.50,-0.5),(0.60,0.30,0.8),(0.95,0.78,-0.3)]$。\n- 测试案例 3：$(N_x,N_\\alpha,L_x,L_\\alpha,s,z,\\alpha_p,\\beta_p) = (12,12,1.0,1.0,1.0,1.5,1.0,0.0)$，标记点 $[(0.20,0.20,0.3),(0.80,0.90,-0.2),(0.55,0.40,0.1)]$。\n- 测试案例 4：$(N_x,N_\\alpha,L_x,L_\\alpha,s,z,\\alpha_p,\\beta_p) = (8,8,0.6,0.5,0.2,-1.0,0.5,0.0)$，标记点 $[(0.10,0.10,0.2),(0.40,0.20,-0.1),(0.55,0.42,0.05),(0.30,0.48,-0.07),(0.02,0.05,0.12)]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试案例的顺序排列结果，每个测试案例贡献其两个诊断量 $(\\nabla_\\perp^2 \\phi \\text{ 的 RMS 误差},\\ \\text{准中性残差的 RMS})$。例如，输出格式必须为\n$$\n[\\text{err}_1,\\text{res}_1,\\text{err}_2,\\text{res}_2,\\text{err}_3,\\text{res}_3,\\text{err}_4,\\text{res}_4].\n$$",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于已建立的回旋动理学理论，特别是在局域剪切平板几何中的 $\\delta f$ 格式。该问题是适定的，为一项计算验证任务提供了一套完整且一致的参数、定义和目标。所有术语都已定义，并且所需的数值方法（二阶中心差分，网格云）在该领域是标准方法。该问题是计算等离子体物理学中一个明确定义的练习，没有歧义或矛盾。因此，我们可以继续进行求解。\n\n解决方案的结构如下：首先，在场向坐标 $(x, \\alpha)$ 中推导垂直拉普拉斯算子 $\\nabla_\\perp^2$ 的解析形式。其次，详细说明使用二阶有限差分对该算子进行离散化的过程。第三，对指定测试势的 $\\nabla_\\perp^2 \\phi$ 进行解析评估，为准确性提供基准。第四，指定用于构建基于标记点的电荷密度 $\\rho_\\delta$ 的网格云 (CIC) 粒子投射格式。最后，构建完整的离散准中性方程和所需的诊断指标。\n\n### 1. 在场向坐标中推导垂直拉普拉斯算子\n\n我们从标准笛卡尔坐标系 $(x, y, z)$ 开始。垂直拉普拉斯算子在 $(x, y)$ 平面中定义为 $\\nabla_\\perp^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$。\n\n问题引入了场向坐标 $(x', \\alpha)$，其中从 $(x, y)$ 的变换在固定的平行坐标 $z$ 处定义：\n$$\nx' = x\n$$\n$$\n\\alpha = y - s x z\n$$\n为简单起见，我们将 $x'$ 记为 $x$。我们必须用 $\\frac{\\partial}{\\partial x}$ 和 $\\frac{\\partial}{\\partial \\alpha}$ 来表示偏导数算子 $\\frac{\\partial}{\\partial x}$ 和 $\\frac{\\partial}{\\partial y}$。我们使用链式法则。对于任何可微函数 $f(x, \\alpha)$：\n\n关于原始笛卡尔坐标 $x$ 的偏导数为：\n$$\n\\frac{\\partial f}{\\partial x}\\bigg|_{y,z} = \\frac{\\partial f}{\\partial x}\\bigg|_{\\alpha,z} \\frac{\\partial x}{\\partial x}\\bigg|_{y,z} + \\frac{\\partial f}{\\partial \\alpha}\\bigg|_{x,z} \\frac{\\partial \\alpha}{\\partial x}\\bigg|_{y,z}\n$$\n根据变换方程，$\\frac{\\partial x}{\\partial x} = 1$ 且 $\\frac{\\partial \\alpha}{\\partial x} = -sz$。因此，算子为：\n$$\n\\frac{\\partial}{\\partial x} \\longrightarrow \\frac{\\partial}{\\partial x} - sz \\frac{\\partial}{\\partial \\alpha}\n$$\n\n关于原始笛卡尔坐标 $y$ 的偏导数为：\n$$\n\\frac{\\partial f}{\\partial y}\\bigg|_{x,z} = \\frac{\\partial f}{\\partial x}\\bigg|_{\\alpha,z} \\frac{\\partial x}{\\partial y}\\bigg|_{x,z} + \\frac{\\partial f}{\\partial \\alpha}\\bigg|_{x,z} \\frac{\\partial \\alpha}{\\partial y}\\bigg|_{x,z}\n$$\n根据变换方程，$\\frac{\\partial x}{\\partial y} = 0$ 且 $\\frac{\\partial \\alpha}{\\partial y} = 1$。因此，算子为：\n$$\n\\frac{\\partial}{\\partial y} \\longrightarrow \\frac{\\partial}{\\partial \\alpha}\n$$\n\n现在我们构建二阶导数算子。算子 $\\frac{\\partial^2}{\\partial x^2}$ 变为：\n$$\n\\frac{\\partial^2}{\\partial x^2} \\longrightarrow \\left(\\frac{\\partial}{\\partial x} - sz \\frac{\\partial}{\\partial \\alpha}\\right) \\left(\\frac{\\partial}{\\partial x} - sz \\frac{\\partial}{\\partial \\alpha}\\right) = \\frac{\\partial^2}{\\partial x^2} - 2sz \\frac{\\partial^2}{\\partial x \\partial \\alpha} + (sz)^2 \\frac{\\partial^2}{\\partial \\alpha^2}\n$$\n算子 $\\frac{\\partial^2}{\\partial y^2}$ 变为：\n$$\n\\frac{\\partial^2}{\\partial y^2} \\longrightarrow \\left(\\frac{\\partial}{\\partial \\alpha}\\right) \\left(\\frac{\\partial}{\\partial \\alpha}\\right) = \\frac{\\partial^2}{\\partial \\alpha^2}\n$$\n\n将这两个分量相加，得到新坐标系下的垂直拉普拉斯算子 $\\nabla_\\perp^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$：\n$$\n\\nabla_\\perp^2 = \\left(\\frac{\\partial^2}{\\partial x^2} - 2sz \\frac{\\partial^2}{\\partial x \\partial \\alpha} + s^2 z^2 \\frac{\\partial^2}{\\partial \\alpha^2}\\right) + \\frac{\\partial^2}{\\partial \\alpha^2}\n$$\n$$\n\\nabla_\\perp^2 = \\frac{\\partial^2}{\\partial x^2} - 2sz \\frac{\\partial^2}{\\partial x \\partial \\alpha} + (1 + s^2 z^2) \\frac{\\partial^2}{\\partial \\alpha^2}\n$$\n这就是在剪切平板坐标中所需的垂直拉普拉斯算子的解析形式。\n\n### 2. 拉普拉斯算子的离散化\n\n我们将区域 $(x, \\alpha) \\in [0, L_x) \\times [0, L_\\alpha)$ 离散到一个大小为 $N_x \\times N_\\alpha$ 的均匀网格上。网格点为 $(x_i, \\alpha_j)$，其中 $x_i = i \\Delta x$ ($i=0, \\dots, N_x-1$) 且 $\\alpha_j = j \\Delta \\alpha$ ($j=0, \\dots, N_\\alpha-1$)。网格间距为 $\\Delta x = L_x/N_x$ 和 $\\Delta \\alpha = L_\\alpha/N_\\alpha$。令 $\\phi_{i,j} = \\phi(x_i, \\alpha_j)$。\n\n我们使用二阶中心差分格式，并考虑周期性边界条件：\n$$\n\\frac{\\partial^2 \\phi}{\\partial x^2}\\bigg|_{i,j} \\approx \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{(\\Delta x)^2}\n$$\n$$\n\\frac{\\partial^2 \\phi}{\\partial \\alpha^2}\\bigg|_{i,j} \\approx \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{(\\Delta \\alpha)^2}\n$$\n混合偏导数也用二阶中心格式近似：\n$$\n\\frac{\\partial^2 \\phi}{\\partial x \\partial \\alpha}\\bigg|_{i,j} \\approx \\frac{\\phi_{i+1,j+1} - \\phi_{i+1,j-1} - \\phi_{i-1,j+1} + \\phi_{i-1,j-1}}{4 \\Delta x \\Delta \\alpha}\n$$\n将这些离散形式代入 $\\nabla_\\perp^2$ 的解析表达式，即可得到离散算子 $(\\nabla_\\perp^2 \\phi)_{i,j}$。\n\n### 3. 测试势的解析拉普拉斯算子\n\n测试势由 $\\phi(x,\\alpha) = \\sin(k_x x)\\cos(k_\\alpha \\alpha)$ 给出，其中 $k_x = 2\\pi/L_x$ 且 $k_\\alpha = 2\\pi/L_\\alpha$。\n我们解析地计算其偏导数：\n$$\n\\frac{\\partial^2 \\phi}{\\partial x^2} = -k_x^2 \\sin(k_x x)\\cos(k_\\alpha \\alpha) = -k_x^2 \\phi\n$$\n$$\n\\frac{\\partial^2 \\phi}{\\partial \\alpha^2} = -k_\\alpha^2 \\sin(k_x x)\\cos(k_\\alpha \\alpha) = -k_\\alpha^2 \\phi\n$$\n$$\n\\frac{\\partial^2 \\phi}{\\partial x \\partial \\alpha} = \\frac{\\partial}{\\partial \\alpha} \\left( k_x \\cos(k_x x)\\cos(k_\\alpha \\alpha) \\right) = -k_x k_\\alpha \\cos(k_x x)\\sin(k_\\alpha \\alpha)\n$$\n将这些代入推导出的 $\\nabla_\\perp^2$ 公式中：\n$$\n(\\nabla_\\perp^2 \\phi)_{\\text{analytic}} = (-k_x^2 \\phi) - 2sz (-k_x k_\\alpha \\cos(k_x x)\\sin(k_\\alpha \\alpha)) + (1 + s^2 z^2) (-k_\\alpha^2 \\phi)\n$$\n$$\n(\\nabla_\\perp^2 \\phi)_{\\text{analytic}} = -\\left(k_x^2 + (1+s^2z^2)k_\\alpha^2\\right)\\phi + 2szk_x k_\\alpha \\cos(k_x x)\\sin(k_\\alpha \\alpha)\n$$\n此表达式在每个网格点 $(x_i, \\alpha_j)$ 上的值，作为计算数值误差的精确解。\n\n### 4. 网格云 (CIC) 标记点投射\n\n准中性方程的右侧项 $\\rho_\\delta$ 是通过将带权重的标记点投射到网格上构建的。对于位于位置 $(x_k, \\alpha_k)$、权重为 $w_k$ 的标记点 $k$，我们使用双线性插值 (CIC) 格式。\n首先，我们找到标记点的逻辑坐标和其所在网格单元的左下角索引：\n$$\nu_k = x_k / \\Delta x, \\quad v_k = \\alpha_k / \\Delta \\alpha\n$$\n$$\ni = \\lfloor u_k \\rfloor, \\quad j = \\lfloor v_k \\rfloor\n$$\n在单元内的相对距离为：\n$$\n\\delta u_k = u_k - i, \\quad \\delta v_k = v_k - j\n$$\n权重 $w_k$ 使用双线性权重分配到周围的四个网格节点 $(i,j)$、$(i+1,j)$、$(i,j+1)$ 和 $(i+1,j+1)$：\n$$\nW_{i,j} = (1-\\delta u_k)(1-\\delta v_k)\n$$\n$$\nW_{i+1,j} = \\delta u_k(1-\\delta v_k)\n$$\n$$\nW_{i,j+1} = (1-\\delta u_k)\\delta v_k\n$$\n$$\nW_{i+1,j+1} = \\delta u_k \\delta v_k\n$$\n问题要求所得的场 $\\rho_\\delta$ 是一个电荷密度。因此，每个节点上投射的电荷 $w_k W$ 必须除以单元面积 $\\Delta x \\Delta \\alpha$。标记点 $k$ 对节点 $(i', j')$ 处电荷密度的贡献是 $\\frac{w_k W_{i',j'}}{\\Delta x \\Delta \\alpha}$。总电荷密度网格是所有标记点贡献的总和，其中网格索引应用了周期性边界条件。\n\n### 5. 诊断量\n\n所需的两个诊断量计算如下：\n\n1.  **$\\nabla_\\perp^2 \\phi$ 的均方根误差**：这衡量了离散拉普拉斯算子的准确性。\n    $$\n    \\text{err}_{\\text{RMS}} = \\sqrt{\\frac{1}{N_x N_\\alpha} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_\\alpha-1} \\left[ (\\nabla_\\perp^2 \\phi)_{\\text{discrete}, i,j} - (\\nabla_\\perp^2 \\phi)_{\\text{analytic}, i,j} \\right]^2}\n    $$\n2.  **准中性残差的均方根**：这衡量了离散系统的满足程度。残差场 $R$ 定义为：\n    $$\n    R_{i,j} = - \\alpha_p (\\nabla_\\perp^2 \\phi)_{\\text{discrete},i,j} + \\beta_p \\phi_{i,j} - \\rho_{\\delta, i,j}\n    $$\n    均方根残差则为：\n    $$\n    \\text{res}_{\\text{RMS}} = \\sqrt{\\frac{1}{N_x N_\\alpha} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_\\alpha-1} R_{i,j}^2}\n    $$\n将对所提供的每个测试案例执行这些计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the gyrokinetic sheared slab problem for a set of test cases.\n    \"\"\"\n    \n    test_cases = [\n        {'Nx': 16, 'Na': 16, 'Lx': 1.0, 'La': 1.0, 's': 0.0, 'z': 0.0, 'alpha_p': 1.0, 'beta_p': 0.0, \n         'markers': [(0.25, 0.75, 0.5), (0.9, 0.1, -0.25)]},\n        {'Nx': 32, 'Na': 20, 'Lx': 1.0, 'La': 0.8, 's': 0.2, 'z': 1.0, 'alpha_p': 0.7, 'beta_p': 0.3, \n         'markers': [(0.10, 0.20, 1.0), (0.70, 0.50, -0.5), (0.60, 0.30, 0.8), (0.95, 0.78, -0.3)]},\n        {'Nx': 12, 'Na': 12, 'Lx': 1.0, 'La': 1.0, 's': 1.0, 'z': 1.5, 'alpha_p': 1.0, 'beta_p': 0.0, umar\n         'markers': [(0.20, 0.20, 0.3), (0.80, 0.90, -0.2), (0.55, 0.40, 0.1)]},\n        {'Nx': 8, 'Na': 8, 'Lx': 0.6, 'La': 0.5, 's': 0.2, 'z': -1.0, 'alpha_p': 0.5, 'beta_p': 0.0, \n         'markers': [(0.10, 0.10, 0.2), (0.40, 0.20, -0.1), (0.55, 0.42, 0.05), (0.30, 0.48, -0.07), (0.02, 0.05, 0.12)]}\n    ]\n\n    results = []\n\n    def calculate_discrete_laplacian(phi, dx, da, s, z):\n        \"\"\"\n        Computes the discrete perpendicular Laplacian using 2nd-order central differences.\n        Periodic boundary conditions are handled using np.roll.\n        \"\"\"\n        # Second derivative in x\n        phi_xp1 = np.roll(phi, -1, axis=0)\n        phi_xm1 = np.roll(phi, 1, axis=0)\n        d2phi_dx2 = (phi_xp1 - 2 * phi + phi_xm1) / (dx**2)\n\n        # Second derivative in alpha\n        phi_ap1 = np.roll(phi, -1, axis=1)\n        phi_am1 = np.roll(phi, 1, axis=1)\n        d2phi_da2 = (phi_ap1 - 2 * phi + phi_am1) / (da**2)\n        \n        # Mixed derivative\n        phi_xp1_ap1 = np.roll(np.roll(phi, -1, axis=0), -1, axis=1)\n        phi_xp1_am1 = np.roll(np.roll(phi, -1, axis=0), 1, axis=1)\n        phi_xm1_ap1 = np.roll(np.roll(phi, 1, axis=0), -1, axis=1)\n        phi_xm1_am1 = np.roll(np.roll(phi, 1, axis=0), 1, axis=1)\n        d2phi_dxda = (phi_xp1_ap1 - phi_xp1_am1 - phi_xm1_ap1 + phi_xm1_am1) / (4 * dx * da)\n\n        nabla2_phi = d2phi_dx2 - 2 * s * z * d2phi_dxda + (1 + (s * z)**2) * d2phi_da2\n        return nabla2_phi\n\n    def calculate_analytic_laplacian(x_mesh, a_mesh, Lx, La, s, z):\n        \"\"\"\n        Computes the analytical Laplacian of the test potential on the grid.\n        \"\"\"\n        kx = 2 * np.pi / Lx\n        ka = 2 * np.pi / La\n        \n        phi = np.sin(kx * x_mesh) * np.cos(ka * a_mesh)\n        \n        term1 = -(kx**2 + (1 + (s * z)**2) * ka**2) * phi\n        term2 = 2 * s * z * kx * ka * np.cos(kx * x_mesh) * np.sin(ka * a_mesh)\n        \n        return term1 + term2\n\n    def deposit_cic(markers, Nx, Na, Lx, La):\n        \"\"\"\n        Deposits markers onto a grid using Cloud-In-Cell (CIC) scheme.\n        \"\"\"\n        dx = Lx / Nx\n        da = La / Na\n        cell_area = dx * da\n        rho_delta = np.zeros((Nx, Na))\n\n        for (xp, ap, w) in markers:\n            # Handle periodic wrap-around for particle positions\n            xp = xp % Lx\n            ap = ap % La\n            \n            u = xp / dx\n            v = ap / da\n            \n            i = int(u)\n            j = int(v)\n            \n            du = u - i\n            dv = v - j\n            \n            # Bilinear weights\n            w_ij   = (1 - du) * (1 - dv)\n            w_ip1j = du * (1 - dv)\n            w_ijp1 = (1 - du) * dv\n            w_ip1jp1 = du * dv\n            \n            # Deposit charge density (weight/area)\n            charge_density_contribution = w / cell_area\n            \n            # Apply periodic boundary conditions for indices\n            ip1 = (i + 1) % Nx\n            jp1 = (j + 1) % Na\n            \n            rho_delta[i, j]     += charge_density_contribution * w_ij\n            rho_delta[ip1, j]   += charge_density_contribution * w_ip1j\n            rho_delta[i, jp1]   += charge_density_contribution * w_ijp1\n            rho_delta[ip1, jp1] += charge_density_contribution * w_ip1jp1\n            \n        return rho_delta\n    \n    def rms(field):\n        \"\"\"Computes the Root Mean Square of a 2D field.\"\"\"\n        return np.sqrt(np.mean(field**2))\n\n    for case in test_cases:\n        Nx, Na, Lx, La = case['Nx'], case['Na'], case['Lx'], case['La']\n        s, z, alpha_p, beta_p = case['s'], case['z'], case['alpha_p'], case['beta_p']\n        markers = case['markers']\n\n        dx = Lx / Nx\n        da = La / Na\n\n        # Create grid\n        x_pts = np.linspace(0, Lx, Nx, endpoint=False)\n        a_pts = np.linspace(0, La, Na, endpoint=False)\n        x_mesh, a_mesh = np.meshgrid(x_pts, a_pts, indexing='ij')\n\n        # Define test potential on the grid\n        kx = 2 * np.pi / Lx\n        ka = 2 * np.pi / La\n        phi_grid = np.sin(kx * x_mesh) * np.cos(ka * a_mesh)\n\n        # 1. Calculate discrete and analytic Laplacians\n        nabla2_phi_discrete = calculate_discrete_laplacian(phi_grid, dx, da, s, z)\n        nabla2_phi_analytic = calculate_analytic_laplacian(x_mesh, a_mesh, Lx, La, s, z)\n        \n        # 2. Calculate RMS error of the Laplacian\n        laplacian_error = rms(nabla2_phi_discrete - nabla2_phi_analytic)\n        results.append(laplacian_error)\n\n        # 3. Construct the RHS charge density from markers\n        rho_delta_grid = deposit_cic(markers, Nx, Na, Lx, La)\n\n        # 4. Calculate the quasineutrality residual\n        residual_field = -alpha_p * nabla2_phi_discrete + beta_p * phi_grid - rho_delta_grid\n        \n        # 5. Calculate RMS residual\n        residual_rms = rms(residual_field)\n        results.append(residual_rms)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "实际的聚变模拟通常在具有特定周期性的通量管（flux-tube）区域中进行，这要求对边界条件进行精细处理。这项高级实践  深入探讨了球管表示（ballooning representation）下所需的“扭曲-平移”（twist-shift）边界条件的实现。掌握这一概念对于在现代环形几何中正确模拟等离子体湍流至关重要，并有助于理解局部物理与全局磁拓扑结构之间的相互作用。",
            "id": "4008405",
            "problem": "考虑一个用于回旋动理学（GK）模拟的局域、场向磁通管模型，该模型处于剪切平板近似下，具有副法向坐标 $y$、类径向坐标 $x$ 和极向角坐标 $\\theta$。设磁剪切为常数，记为 $\\hat{s}$。在气球模表示中，沿着一条磁力线定义类克莱布施（Clebsch）标签 $\\alpha$ 为以下不变组合：\n$$\n\\alpha \\equiv y - \\hat{s}\\, x\\, \\theta,\n$$\n这与在此局域模型中磁场 $\\mathbf{B}$ 满足 $\\mathbf{B}\\cdot\\nabla \\alpha = 0$ 的性质一致，因此标签 $\\alpha$ 沿磁力线为常数。对于一个使用标记点（此后称为“delta-$f$ 标记点”）来表示 delta 分布函数 ($\\delta f$) 的磁通管模拟，必须构建边界条件，以强制 $y$ 和 $\\theta$ 的周期性，同时保持气球模表示所蕴含的物理不变性。\n\n假设如下：\n- 副法向坐标 $y$ 存在于长度为 $L_y$ 的周期性域中，因此 $y \\in [0,L_y)$，并且其值以 $L_y$ 为模进行等同。\n- 极向角坐标 $\\theta$ 存在于端点等同的周期性域中，此处取为 $\\theta \\in [-\\Theta,\\Theta]$ 且 $\\Theta = \\pi$，角度以弧度（$\\mathrm{radians}$）为单位。\n- delta-$f$ 标记点携带一个恒定的权重 $w$，在应用边界映射时该权重不得改变。\n\n从与磁化等离子体理论和气球模表示一致的基本几何性质出发，推导当标记点 $(x,y,\\theta)$ 穿过极向角边界 $\\theta = \\pm \\Theta$ 时必须应用的边界映射，以强制 $\\alpha$ 的不变性。然后，推导如何通过将 $y$ 包裹到 $[0,L_y)$ 内来强制其周期性，并解释在此包裹操作下不变量 $\\alpha$ 的作用。你的推导必须从上述 $\\alpha$ 的定义以及在局域剪切平板中 $\\mathbf{B}\\cdot\\nabla \\alpha = 0$ 的要求开始，并且不得假定任何未经这些基础证明的快捷边界条件公式。\n\n实现一个程序，该程序：\n1. 将一个通用相空间增量 $(\\delta y, \\delta \\theta)$ 应用于标记点状态 $(x,y,\\theta)$。\n2. 通过在 $\\theta$ 上进行最小足够数量的 $2\\pi$ 位移，并在 $y$ 上进行保持不变量 $\\alpha$ 的补偿位移，反复映射穿过 $\\theta = \\pm \\Theta$ 来强制极向边界。\n3. 通过取模 $L_y$ 将 $y$ 包裹到 $[0,L_y)$ 中，以强制 $y$ 的周期性边界。\n4. 验证 $\\alpha$ 在模 $L_y$ 下的不变性，即计算最小绝对差\n$$\n\\epsilon_\\alpha \\equiv \\min_{n \\in \\mathbb{Z}} \\left| \\left( \\alpha_{\\text{after}} - \\alpha_{\\text{before}} \\right) - n L_y \\right|,\n$$\n并通过计算\n$$\n\\epsilon_w \\equiv \\left| w_{\\text{after}} - w_{\\text{before}} \\right|.\n$$\n来验证 delta-$f$ 标记点权重 $w$ 的不变性。\n你的程序必须为一小组测试用例中的每个用例生成数值对 $[\\epsilon_\\alpha,\\epsilon_w]$。\n\n所有角度必须以弧度（$\\mathrm{radians}$）表示。不需要其他物理单位；坐标和参数应被视为无量纲实数。输出值必须是浮点数。\n\n使用以下输入参数集的测试套件，每个参数集指定为 $(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w)$：\n\n- 案例 1（正剪切和向上极向穿越的正常路径）：$(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.3,\\, 0.7 \\cdot 1.0,\\, 0.9\\pi,\\, 0.8,\\, 1.0,\\, 0.3\\pi,\\, 0.15,\\, 0.5)$。\n- 案例 2（零剪切，靠近边界）：$(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.5,\\, 0.95 \\cdot 1.2,\\, -0.95\\pi,\\, 0.0,\\, 1.2,\\, 0.2\\pi,\\, 0.1,\\, 1.0)$。\n- 案例 3（精确上边界穿越，副法向增量较小）：$(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.25,\\, 0.99 \\cdot 0.8,\\, \\pi,\\, 0.7,\\, 0.8,\\, 0.1\\pi,\\, 0.02,\\, 0.25)$。\n- 案例 4（负 $x$ 值，向下极向穿越和导致包裹的大副法向增量）：$(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (-0.4,\\, 0.1,\\, -0.99\\pi,\\, 0.6,\\, 1.0,\\, -0.2\\pi,\\, 1.3,\\, 0.75)$。\n- 案例 5（大剪切引起的位移，需要多次包裹）：$(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.7,\\, 0.05,\\, 0.95\\pi,\\, 1.5,\\, 2.0,\\, 0.3\\pi,\\, 1.1,\\, 0.33)$。\n\n对于每个案例：\n- 计算 $\\alpha_{\\text{before}} = y - \\hat{s}\\, x\\, \\theta$。\n- 应用增量 $(\\delta y,\\delta\\theta)$。\n- 通过应用将 $\\theta$ 带入 $[-\\pi,\\pi]$ 所需的最小次数的位移 $\\theta \\mapsto \\theta \\pm 2\\pi$ 来强制 $\\theta$ 的周期性，并为每次此类位移应用保持 $\\alpha$ 的补偿 $y$ 位移 $y \\mapsto y \\pm 2\\pi\\, \\hat{s}\\, x$。\n- 通过 $y \\mapsto y \\bmod L_y$ 将 $y$ 包裹到 $[0,L_y)$ 来强制 $y$ 的周期性。\n- 计算 $\\alpha_{\\text{after}}$ 以及误差 $\\epsilon_\\alpha$ 和 $\\epsilon_w$。\n\n你的程序应生成单行输出，其中包含结果，格式为方括号内由逗号分隔的列表，每个元素是对应测试案例的列表 $[\\epsilon_\\alpha,\\epsilon_w]$，顺序如上所列。例如，输出格式必须像 $[ [a_1,b_1],[a_2,b_2],\\dots,[a_5,b_5] ]$ 这样，其中每个 $a_i$ 和 $b_i$ 都是浮点数。",
            "solution": "该问题要求推导和实现剪切平板几何中 delta-$f$ 标记点的边界条件，确保其具有与气球模表示一致的正确变换性质。\n\n我们从模型的基本给定条件开始。坐标是类径向坐标 $x$、副法向坐标 $y$ 和极向角坐标 $\\theta$。磁剪切 $\\hat{s}$ 是常数。在气球模表示中，一个关键量是类克莱布施（Clebsch）标签 $\\alpha$，定义为：\n$$\n\\alpha \\equiv y - \\hat{s}\\, x\\, \\theta\n$$\n这个标签是沿磁力线的不变量，在此局域模型中数学上表示为 $\\mathbf{B}\\cdot\\nabla \\alpha = 0$。我们的任务是为 $y$ 和 $\\theta$ 构建尊重此不变性的边界映射。在这些几何变换下，标记点权重 $w$ 是恒定的。\n\n**1. 极向角边界条件的推导**\n\n极向角 $\\theta$ 定义在周期性域 $\\theta \\in [-\\pi, \\pi]$ 中。物理空间在边界处是连续的，这意味着 $\\theta = \\pi$ 处的点与 $\\theta = -\\pi$ 处的点是等同的。一条穿过 $\\theta = \\pi$ 边界的粒子轨迹会从 $\\theta = -\\pi$ 处重新出现。这对应于展开坐标空间中形式为 $\\theta \\mapsto \\theta \\pm 2\\pi$ 的映射。\n\n设标记点的状态为 $(x, y, \\theta)$。考虑一个变换，其中极向角移动了 $2\\pi$ 的整数倍，代表 $k$ 次完整的极向旋转，其中 $k \\in \\mathbb{Z}$：\n$$\n\\theta' = \\theta + 2\\pi k\n$$\n坐标 $(x, y, \\theta)$ 和 $(x, y', \\theta')$ 必须表示相同的物理状态，这要求磁力线标签 $\\alpha$ 必须保持不变。设 $\\alpha_{\\text{old}}$ 是变换前的值，$\\alpha_{\\text{new}}$ 是变换后的值。\n$$\n\\alpha_{\\text{old}} = y - \\hat{s}\\, x\\, \\theta\n$$\n$$\n\\alpha_{\\text{new}} = y' - \\hat{s}\\, x\\, \\theta' = y' - \\hat{s}\\, x\\, (\\theta + 2\\pi k)\n$$\n为了使 $\\alpha$ 保持不变，我们必须有 $\\alpha_{\\text{new}} = \\alpha_{\\text{old}}$：\n$$\ny' - \\hat{s}\\, x\\, (\\theta + 2\\pi k) = y - \\hat{s}\\, x\\, \\theta\n$$\n$$\ny' - \\hat{s}\\, x\\, \\theta - 2\\pi k \\hat{s}\\, x = y - \\hat{s}\\, x\\, \\theta\n$$\n解出 $y'$，我们得到必要的补偿位移：\n$$\ny' = y + 2\\pi k \\hat{s}\\, x\n$$\n因此，对于极向包裹的完整变换是：\n$$\n\\theta \\mapsto \\theta' = \\theta + 2\\pi k \\\\\ny \\mapsto y' = y + 2\\pi k \\hat{s}\\, x\n$$\n这就是众所周知的“扭曲-位移”（twist-shift）边界条件。对于一个穿过 $\\theta$ 边界的标记点，我们必须确定合适的整数 $k$，将其新的 $\\theta$ 坐标映射回主域 $[-\\pi, \\pi]$，并对 $y$ 应用相应的位移。\n\n**2. 副法向边界条件的推导及其对 $\\alpha$ 的影响**\n\n副法向坐标 $y$ 在长度为 $L_y$ 的域中是周期性的，即 $y \\in [0, L_y)$。对于任何整数 $n \\in \\mathbb{Z}$，$y$ 处的点与 $y + n L_y$ 处的点在物理上是相同的。\n\n让我们研究一下这种周期性如何影响不变量 $\\alpha$。考虑一个只将 $y$ 按其周期的整数倍进行位移的变换：\n$$\ny \\mapsto y' = y + n L_y\n$$\n$\\alpha$ 的新值是：\n$$\n\\alpha' = y' - \\hat{s}\\, x\\, \\theta = (y + n L_y) - \\hat{s}\\, x\\, \\theta = (y - \\hat{s}\\, x\\, \\theta) + n L_y\n$$\n$$\n\\alpha' = \\alpha + n L_y\n$$\n这表明，在 $y$ 的周期性下，$\\alpha$ 并非严格不变。相反，$\\alpha$ 是在模 $L_y$ 的意义下守恒的。物理量必须在 $y$ 方向上以 $L_y$ 为周期，这意味着磁力线标签本身也必须展现出具有相同周期的周期性结构。这是磁通管模型的一个基本一致性要求。\n\n**3. 算法步骤与不变性验证**\n\n在增量 $(\\delta y, \\delta \\theta)$ 之后更新标记点状态 $(x, y, \\theta)$ 并验证不变性的完整算法如下：\n\n设初始状态为 $(x_0, y_0, \\theta_0, w_0)$，参数为 $\\hat{s}$ 和 $L_y$。\n\n1.  **计算初始不变量**：计算 $\\alpha_{\\text{before}} = y_0 - \\hat{s}\\, x_0\\, \\theta_0$。初始权重为 $w_{\\text{before}} = w_0$。\n\n2.  **应用通用增量**：标记点的坐标由给定的增量更新，这些增量代表了相空间中的通用位移。\n    $$\n    y_1 = y_0 + \\delta y \\\\\n    \\theta_1 = \\theta_0 + \\delta \\theta\n    $$\n\n3.  **强制极向周期性**：新角度 $\\theta_1$ 必须被映射回主域 $[-\\pi, \\pi]$。新角度 $\\theta_2$ 是通过在 $[-\\pi,\\pi]$ 中找到与 $\\theta_1$ 相差 $2\\pi$ 整数倍的等效值来确定的。这可以通过模运算计算：$\\theta_2 = (\\theta_1 + \\pi) \\pmod{2\\pi} - \\pi$。由于此映射产生的总角度位移为 $\\Delta\\theta_{\\text{map}} = \\theta_2 - \\theta_1$。此位移必须是 $2\\pi$ 的整数倍，因此对于某个整数 $k$，有 $\\Delta\\theta_{\\text{map}} = 2\\pi k$。根据我们的推导，对应的 $y$ 的位移是 $\\Delta y_{\\text{map}} = 2\\pi k \\hat{s}\\, x_0 = \\Delta\\theta_{\\text{map}} \\hat{s}\\, x_0$。更新后的坐标是：\n    $$\n    \\theta_2 = (\\theta_1 + \\pi) \\pmod{2\\pi} - \\pi \\\\\n    y_2 = y_1 + (\\theta_2 - \\theta_1) \\hat{s}\\, x_0\n    $$\n\n4.  **强制副法向周期性**：坐标 $y_2$ 必须被映射到域 $[0, L_y)$。这通过模运算实现：\n    $$\n    y_3 = y_2 \\pmod{L_y}\n    $$\n\n5.  **最终状态与不变量**：最终的标记点状态为 $(x_{\\text{after}}, y_{\\text{after}}, \\theta_{\\text{after}}, w_{\\text{after}}) = (x_0, y_3, \\theta_2, w_0)$。最终不变量为 $\\alpha_{\\text{after}} = y_3 - \\hat{s}\\, x_0\\, \\theta_2$。标记点权重不受这些几何操作的影响，因此 $w_{\\text{after}} = w_0$。\n\n6.  **验证不变性**：\n    *   标记点权重的变化为 $\\epsilon_w = |w_{\\text{after}} - w_{\\text{before}}| = |w_0 - w_0| = 0$。这在浮点精度范围内必须成立。\n    *   问题要求计算 $\\epsilon_\\alpha \\equiv \\min_{n \\in \\mathbb{Z}} | (\\alpha_{\\text{after}} - \\alpha_{\\text{before}}) - n L_y |$。此量衡量 $\\alpha$ 的总变化量与最近的 $L_y$ 整数倍之间的距离。它是对 $\\alpha$ 在模 $L_y$ 下守恒性的检验。在一个数值上精确的实现中，此值应对应于一个步长内 $\\alpha$ 的物理变化量，模 $L_y$。在增量上的物理变化是 $\\Delta\\alpha_{\\text{phys}} = \\delta y - \\hat{s}\\, x_0\\, \\delta\\theta$。坐标更新和边界映射的组合确保 $(\\alpha_{\\text{after}} - \\alpha_{\\text{before}}) \\pmod{L_y}$ 等价于 $\\Delta\\alpha_{\\text{phys}} \\pmod{L_y}$。因此，$\\epsilon_\\alpha$ 的值通常不为零，反映了这种物理变化，但通过完整坐标映射对其进行的计算应该是自洽的，并且没有来自边界实现本身的数值伪影。对于差值 $\\Delta\\alpha = \\alpha_{\\text{after}} - \\alpha_{\\text{before}}$，计算 $\\epsilon_\\alpha$ 的最稳健方法是在零附近的对称区间内找到余数，例如 $\\epsilon_\\alpha = |(\\Delta\\alpha + L_y/2) \\pmod{L_y} - L_y/2|$。\n\n这就完成了原理的推导和实现的算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the marker boundary condition problem for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is (x, y, theta, s_hat, L_y, d_theta, d_y, w)\n    test_cases = [\n        (0.3, 0.7 * 1.0, 0.9 * np.pi, 0.8, 1.0, 0.3 * np.pi, 0.15, 0.5),\n        (0.5, 0.95 * 1.2, -0.95 * np.pi, 0.0, 1.2, 0.2 * np.pi, 0.1, 1.0),\n        (0.25, 0.99 * 0.8, np.pi, 0.7, 0.8, 0.1 * np.pi, 0.02, 0.25),\n        (-0.4, 0.1, -0.99 * np.pi, 0.6, 1.0, -0.2 * np.pi, 1.3, 0.75),\n        (0.7, 0.05, 0.95 * np.pi, 1.5, 2.0, 0.3 * np.pi, 1.1, 0.33),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x, y_before, theta_before, s_hat, L_y, d_theta, d_y, w = case\n        \n        # The marker weight `w` is invariant under coordinate transformations.\n        w_before = w\n        w_after = w\n        \n        # 1. Compute initial alpha invariant\n        alpha_before = y_before - s_hat * x * theta_before\n        \n        # 2. Apply generic increments\n        y_intermediate = y_before + d_y\n        theta_intermediate = theta_before + d_theta\n        \n        # 3. Enforce poloidal periodicity (theta in [-pi, pi])\n        # The new angle is wrapped into the principal domain.\n        theta_after = (theta_intermediate + np.pi) % (2.0 * np.pi) - np.pi\n        \n        # The total change in theta due to wrapping is a multiple of 2*pi.\n        theta_shift = theta_after - theta_intermediate\n        \n        # Apply the compensating \"twist-shift\" to y to preserve alpha.\n        y_after_theta_bc = y_intermediate + theta_shift * s_hat * x\n        \n        # 4. Enforce binormal periodicity (y in [0, L_y))\n        y_after = y_after_theta_bc % L_y\n        \n        # 5. Compute final alpha invariant\n        alpha_after = y_after - s_hat * x * theta_after\n        \n        # 6. Verify invariances\n        \n        # Calculate the error in w invariance\n        epsilon_w = abs(w_after - w_before)\n        \n        # Calculate the minimal absolute difference for alpha modulo L_y.\n        # This measures the distance of the total change in alpha to the nearest\n        # integer multiple of L_y.\n        alpha_diff = alpha_after - alpha_before\n        \n        # A robust way to compute `min |alpha_diff - n*L_y|` is to find the\n        # remainder in a symmetric interval [-L_y/2, L_y/2].\n        epsilon_alpha = abs((alpha_diff + L_y / 2.0) % L_y - L_y / 2.0)\n        \n        results.append([epsilon_alpha, epsilon_w])\n\n    # Final print statement in the exact required format.\n    # The list comprehension formats each inner list [a, b] into a string \"[a,b]\".\n    # The outer join then combines them with commas.\n    print(f\"[{','.join([str(r) for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}