{
    "hands_on_practices": [
        {
            "introduction": "A crucial first step in any Particle-In-Cell (PIC) or delta-f simulation is the initial loading of computational markers. A naive or random initialization can introduce large, unphysical noise in the initial charge and current densities, leading to spurious fields that can dominate the early-time evolution. This exercise  guides you through the design and implementation of a \"quiet start\" scheme, a fundamental technique that constructs a marker distribution with zero net charge and current perturbation by design, ensuring a clean and physically meaningful start to your simulation.",
            "id": "4008329",
            "problem": "You are tasked to derive and implement a quiet-start loading scheme for the marker-based difference distribution function (delta-f) method in computational fusion science and engineering. In the marker-based delta-f approach, the total distribution function is decomposed as $f = f_0 + \\delta f$, where $f_0$ is a known equilibrium and $\\delta f$ is a small perturbation represented by computational markers carrying weights. The goal of a quiet-start is to initialize markers such that the net perturbation charge and the net perturbation parallel current are both zero at $t=0$, minimizing unphysical transient fields.\n\nStart from the following fundamental base:\n\n- The kinetic description of a magnetized plasma along a guiding magnetic field direction is governed by the Vlasov equation for $f(\\boldsymbol{x},\\boldsymbol{v},t)$ coupled to the Maxwell equations. For the perturbation $\\delta f$, the charge density perturbation and parallel current perturbation are given by\n$$\\delta n(\\boldsymbol{x},t) = \\int \\delta f(\\boldsymbol{x},\\boldsymbol{v},t)\\,\\mathrm{d}^3 v,\\qquad \\delta j_{\\parallel}(\\boldsymbol{x},t) = \\int v_{\\parallel}\\,\\delta f(\\boldsymbol{x},\\boldsymbol{v},t)\\,\\mathrm{d}^3 v.$$\n- In a marker-based representation, with markers indexed by $p$ having parallel velocity $v_{\\parallel p}$ and weight $w_p$ sampling an equilibrium $f_0$, the discrete moments are approximated as\n$$\\delta n \\approx \\sum_{p} w_p,\\qquad \\delta j_{\\parallel} \\approx \\sum_{p} w_p\\, v_{\\parallel p}.$$\n- Therefore, a sufficient condition for a quiet-start is\n$$\\sum_{p} w_p = 0\\quad\\text{and}\\quad \\sum_{p} w_p\\, v_{\\parallel p} = 0.$$\n\nDesign a scheme that constructs velocity-symmetric pairs and assigns weights to ensure both constraints are satisfied. The scheme must be self-consistent and physically plausible. You may assume a one-dimensional parallel velocity space and that all markers are uniformly distributed in configuration space, so spatial shape functions do not bias the sums. The parallel velocity $v_{\\parallel}$ must be expressed in meters per second (m/s). The weights $w_p$ are dimensionless.\n\nYour derivation must show, from first principles and core definitions above, why symmetric pairing in $v_{\\parallel}$ and an appropriate choice of weights achieves $\\sum_{p} w_p = 0$ and $\\sum_{p} w_p v_{\\parallel p} = 0$, including a mathematically precise way to construct weights from an even target shape function of $v_{\\parallel}$ (for example, a function of $v_{\\parallel}^2$) and to enforce the zero-net-charge constraint without breaking the zero-current constraint.\n\nThen, implement a complete, runnable program that:\n\n- Constructs $M$ velocity-symmetric pairs $\\{\\pm v_i\\}_{i=1}^M$ for a specified thermal speed $v_{\\mathrm{th}}$ in $\\mathrm{m/s}$ using either a Gauss–Hermite node set or a uniform grid in $v_{\\parallel}$.\n- Computes pair-level weights $w_i$ from a chosen even amplitude function $a(v)$ and enforces the discrete zero-net-charge constraint by a mean-removal step on the set $\\{w_i\\}_{i=1}^M$ that does not violate the zero-current condition of each pair.\n- Assigns the same weight to both markers in a pair, i.e., $w_{(+v_i)} = w_{(-v_i)} = w_i$, and constructs the full marker set of size $2M$.\n- Reports the absolute value of the net charge moment $|\\sum_p w_p|$ (dimensionless) and the absolute value of the net current moment $\\left|\\sum_p w_p v_{\\parallel p}\\right|$ in $\\mathrm{m/s}$ for each test case.\n\nTest Suite:\n\nProvide the following test cases to exercise your implementation. For all cases, angles are not used, so no angle unit is required. Ensure scientific realism by using plausible thermal speeds.\n\n- Case $1$ (happy path): $M=10$, $v_{\\mathrm{th}} = 2.0\\times 10^{5}\\,\\mathrm{m/s}$, velocity grid type \"Hermite\" with $2M$ Gauss–Hermite nodes, amplitude $a(v) = \\varepsilon \\exp\\!\\left(-\\frac{v^2}{v_{\\mathrm{th}}^2}\\right)\\left(\\frac{v^2}{v_{\\mathrm{th}}^2} - 1\\right)$ with $\\varepsilon = 10^{-3}$.\n- Case $2$ (boundary with minimal pairs): $M=1$, $v_{\\mathrm{th}} = 3.0\\times 10^{5}\\,\\mathrm{m/s}$, velocity grid type \"Uniform\" on $[0, 2 v_{\\mathrm{th}}]$, amplitude $a(v) = \\varepsilon$ with $\\varepsilon = 10^{-2}$.\n- Case $3$ (nontrivial even tail shape): $M=7$, $v_{\\mathrm{th}} = 1.5\\times 10^{5}\\,\\mathrm{m/s}$, velocity grid type \"Hermite\" with $2M$ nodes, amplitude $a(v) = \\varepsilon \\left(1 + \\left(\\frac{v}{v_{\\mathrm{th}}}\\right)^4\\right)^{-1}$ with $\\varepsilon = 5\\times 10^{-4}$.\n- Case $4$ (larger dynamic range on uniform grid): $M=16$, $v_{\\mathrm{th}} = 4.0\\times 10^{5}\\,\\mathrm{m/s}$, velocity grid type \"Uniform\" on $[0, 4 v_{\\mathrm{th}}]$, amplitude $a(v) = \\varepsilon \\left(\\frac{v}{v_{\\mathrm{th}}}\\right)^2 \\exp\\!\\left(-\\frac{v}{v_{\\mathrm{th}}}\\right)$ with $\\varepsilon = 2\\times 10^{-3}$.\n\nAnswer Specification:\n\n- For each test case, compute two floats: $|\\sum_p w_p|$ (dimensionless) and $\\left|\\sum_p w_p v_{\\parallel p}\\right|$ in $\\mathrm{m/s}$.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, in the order of the test cases and metrics, i.e., $[c_1, j_1, c_2, j_2, c_3, j_3, c_4, j_4]$ where $c_k$ is $|\\sum_p w_p|$ and $j_k$ is $\\left|\\sum_p w_p v_{\\parallel p}\\right|$ for case $k$.",
            "solution": "The problem requires the derivation and implementation of a quiet-start loading scheme for a marker-based delta-f ($\\delta f$) particle-in-cell algorithm. A quiet start is achieved by initializing the computational markers such that the net perturbation charge and net perturbation parallel current are both zero at the initial time, $t=0$. This minimizes the generation of spurious, unphysical fields at the beginning of a simulation.\n\nBased on the provided definitions, the discrete approximations for the perturbation charge density, $\\delta n$, and parallel current density, $\\delta j_{\\parallel}$, are given by the sums over all computational markers $p$:\n$$ \\delta n \\approx \\sum_{p} w_p $$\n$$ \\delta j_{\\parallel} \\approx \\sum_{p} w_p v_{\\parallel p} $$\nwhere $w_p$ is the weight of marker $p$ and $v_{\\parallel p}$ is its parallel velocity. The quiet-start conditions are thus the constraints that these two sums must be zero:\n$$ \\sum_{p} w_p = 0 \\quad (\\text{zero net charge}) $$\n$$ \\sum_{p} w_p v_{\\parallel p} = 0 \\quad (\\text{zero net current}) $$\n\nWe will now derive a constructive algorithm to generate a set of marker velocities $\\{v_{\\parallel p}\\}$ and weights $\\{w_p\\}$ that satisfy these two conditions simultaneously.\n\nThe core of the scheme is to construct the marker population from symmetric pairs in velocity space. Let the total number of markers be $2M$, composed of $M$ pairs. For each pair, indexed by $i$ (where $i$ ranges from $1$ to $M$), we define two markers, one with positive velocity and one with negative velocity.\n\nLet the set of base positive velocities be $\\{v_i\\}_{i=1}^M$, where each $v_i \\ge 0$. The $i$-th pair of markers will have velocities:\n$$ v_{\\parallel, i, +} = +v_i $$\n$$ v_{\\parallel, i, -} = -v_i $$\nTo satisfy the zero-current condition by construction, we assign the *same* weight to both markers within a given pair. Let this pair-level weight be denoted by $w_i$.\n$$ w_{i, +} = w_i $$\n$$ w_{i, -} = w_i $$\n\nLet us verify that this construction guarantees zero net parallel current. The total sum for the current can be grouped by pairs:\n$$ \\sum_{p} w_p v_{\\parallel p} = \\sum_{i=1}^{M} \\left( w_{i,+} v_{\\parallel, i, +} + w_{i,-} v_{\\parallel, i, -} \\right) $$\nSubstituting the definitions for the paired velocities and weights:\n$$ \\sum_{i=1}^{M} \\left( w_i (+v_i) + w_i (-v_i) \\right) = \\sum_{i=1}^{M} w_i (v_i - v_i) = \\sum_{i=1}^{M} (w_i \\cdot 0) = 0 $$\nThis demonstrates that the symmetric pairing of velocities $(\\pm v_i)$ with identical weights $(w_i)$ inherently satisfies the zero-current condition, irrespective of the specific values of $v_i$ and $w_i$. This holds true even in finite-precision arithmetic, as the cancellation $(v_i - v_i)$ is exact for each pair.\n\nNext, we address the zero-charge condition, $\\sum_{p} w_p = 0$. Using the same pair-based grouping:\n$$ \\sum_{p} w_p = \\sum_{i=1}^{M} (w_{i,+} + w_{i,-}) = \\sum_{i=1}^{M} (w_i + w_i) = 2 \\sum_{i=1}^{M} w_i $$\nFor the total charge to be zero, we must therefore enforce the condition on the pair-level weights:\n$$ \\sum_{i=1}^{M} w_i = 0 $$\n\nThe pair-level weights $w_i$ are determined based on a desired initial perturbation shape in velocity space, described by an amplitude function $a(v)$. For physical perturbations that are symmetric in velocity (e.g., heating), $a(v)$ would typically be an even function of $v$, such as a function of $v^2$. We first compute a set of \"raw\" weights, $w'_i$, by evaluating the amplitude function at the positive base velocities $v_i$:\n$$ w'_i = a(v_i) \\quad \\text{for } i=1, \\dots, M $$\nThe sum of these raw weights, $S = \\sum_{i=1}^{M} w'_i$, will not be zero in general.\n\nTo enforce the zero-sum constraint, we apply a mean-removal correction. We compute the mean of the raw weights:\n$$ \\bar{w}' = \\frac{1}{M} \\sum_{j=1}^{M} w'_j $$\nThe final pair-level weights $w_i$ are then obtained by subtracting this mean from each raw weight:\n$$ w_i = w'_i - \\bar{w}' $$\nLet us verify that this set of corrected weights sums to zero:\n$$ \\sum_{i=1}^{M} w_i = \\sum_{i=1}^{M} (w'_i - \\bar{w}') = \\left(\\sum_{i=1}^{M} w'_i\\right) - \\sum_{i=1}^{M} \\bar{w}' = (M\\bar{w}') - M\\bar{w}' = 0 $$\nThis procedure successfully produces a set of pair-level weights $\\{w_i\\}$ whose sum is zero (up to machine precision), thus satisfying the zero-charge condition $\\sum_p w_p = 0$. Since this adjustment is made to the pair-level weights $w_i$ before they are assigned to the $(\\pm v_i)$ markers, the symmetric structure that guarantees zero current is preserved. The scheme is therefore self-consistent.\n\nThe set of base positive velocities $\\{v_i\\}_{i=1}^M$ can be generated in several ways. The problem specifies two:\n1.  **Uniform Grid**: For a given velocity range, say $[0, v_{\\max}]$, and $M$ pairs, the velocities can be sampled uniformly. A robust method is to choose the centers of $M$ subintervals, i.e., $v_i = (i-0.5) \\frac{v_{\\max}}{M}$ for $i=1, \\dots, M$.\n2.  **Gauss-Hermite Grid**: The nodes of Gauss-Hermite quadrature are naturally suited for sampling functions against a Gaussian weight, common in plasma physics. For $2M$ total markers, one computes the $2M$ roots of the Hermite polynomial $H_{2M}(x)$. These roots are symmetric about $x=0$. We select the $M$ positive roots, $\\{x_j\\}_{j=1}^M$. These are then scaled by a characteristic thermal speed, $v_{\\mathrm{th}}$, to obtain physical velocities: $v_i = v_{\\mathrm{th}} x_i$. This method is particularly effective when the underlying distribution function $f_0$ is Maxwellian.\n\nIn summary, the algorithm is:\n1.  Choose the number of pairs, $M$.\n2.  Generate a set of $M$ positive velocities $\\{v_i\\}_{i=1}^M$ using a specified grid type.\n3.  Compute raw weights $\\{w'_i\\}_{i=1}^M$ using a given amplitude function $a(v)$, such that $w'_i = a(v_i)$.\n4.  Compute the mean of the raw weights, $\\bar{w}' = \\frac{1}{M}\\sum_i w'_i$.\n5.  Compute the final, corrected pair-level weights $w_i = w'_i - \\bar{w}'$.\n6.  Construct the full set of $2M$ markers as $\\{(\\pm v_i, w_i)\\}_{i=1}^M$. By construction, this set of markers has $\\sum_p w_p v_{\\parallel p} = 0$ and $\\sum_p w_p = 0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.polynomial.hermite import hermgauss\n\ndef solve():\n    \"\"\"\n    Derives and implements a quiet-start loading scheme for a marker-based\n    delta-f algorithm, ensuring zero net charge and current perturbations.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"M\": 10,\n            \"v_th\": 2.0e5,\n            \"grid_type\": \"Hermite\",\n            \"grid_param\": None,  # Not used for Hermite\n            \"a_func\": lambda v, v_th, eps: eps * np.exp(-(v/v_th)**2) * ((v/v_th)**2 - 1),\n            \"epsilon\": 1e-3,\n        },\n        {\n            \"M\": 1,\n            \"v_th\": 3.0e5,\n            \"grid_type\": \"Uniform\",\n            \"grid_param\": 2.0,  # Grid range is [0, grid_param * v_th]\n            \"a_func\": lambda v, v_th, eps: eps * np.ones_like(v),\n            \"epsilon\": 1e-2,\n        },\n        {\n            \"M\": 7,\n            \"v_th\": 1.5e5,\n            \"grid_type\": \"Hermite\",\n            \"grid_param\": None,\n            \"a_func\": lambda v, v_th, eps: eps / (1 + (v/v_th)**4),\n            \"epsilon\": 5e-4,\n        },\n        {\n            \"M\": 16,\n            \"v_th\": 4.0e5,\n            \"grid_type\": \"Uniform\",\n            \"grid_param\": 4.0,\n            \"a_func\": lambda v, v_th, eps: eps * (v/v_th)**2 * np.exp(-v/v_th),\n            \"epsilon\": 2e-3,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        M = case[\"M\"]\n        v_th = case[\"v_th\"]\n        grid_type = case[\"grid_type\"]\n        grid_param = case[\"grid_param\"]\n        a_func = case[\"a_func\"]\n        epsilon = case[\"epsilon\"]\n\n        # Step 1: Construct M positive velocities {v_i}\n        if grid_type == \"Hermite\":\n            # hermgauss provides 2M symmetric roots for H_{2M}(x)\n            # Scaling for nodes is v = v_th * x, matching exp(-v^2/v_th^2) to exp(-x^2)\n            nodes, _ = hermgauss(2 * M)\n            # Take the M positive roots\n            positive_velocities = nodes[M:] * v_th\n        elif grid_type == \"Uniform\":\n            # Generate M points on [0, v_max] as cell centers\n            # This avoids v=0 and is more robust for M=1\n            v_max = grid_param * v_th\n            delta_v = v_max / M\n            indices = np.arange(1, M + 1)\n            positive_velocities = (indices - 0.5) * delta_v\n        \n        # Step 2: Compute raw pair-level weights w'_i\n        raw_weights = a_func(positive_velocities, v_th, epsilon)\n        \n        # Step 3: Enforce zero-net-charge via mean removal\n        if M > 0:\n            mean_raw_weight = np.mean(raw_weights)\n            final_pair_weights = raw_weights - mean_raw_weight\n        else: # Handle empty case\n            final_pair_weights = np.array([])\n\n        # Step 4: Construct the full marker set and calculate moments\n        # The full set consists of M pairs: (+v_i, w_i) and (-v_i, w_i)\n        \n        # Velocities: [+v_1, ..., +v_M, -v_1, ..., -v_M]\n        full_velocities = np.concatenate([positive_velocities, -positive_velocities])\n        \n        # Weights: [w_1, ..., w_M, w_1, ..., w_M]\n        full_weights = np.concatenate([final_pair_weights, final_pair_weights])\n\n        # Calculate net charge and current moments\n        # These should be zero up to machine precision\n        net_charge = np.sum(full_weights)\n        net_current = np.sum(full_weights * full_velocities)\n        \n        results.extend([abs(net_charge), abs(net_current)])\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join(f'{r:.18e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The heart of a delta-f simulation is the self-consistent loop where marker data is used to compute the electromagnetic fields, which in turn dictate the marker motion. In the study of magnetically confined plasmas, this requires solving field equations in specialized, field-aligned coordinate systems. This practice  involves deriving and discretizing the perpendicular Laplacian operator, $\\nabla_\\perp^2$, in a sheared slab geometry, a canonical model for exploring plasma microinstabilities. You will learn to handle the mixed-derivative terms that arise from magnetic shear and verify your numerical operator against an analytical solution, a core skill in code development.",
            "id": "4008349",
            "problem": "Consider an electrostatic gyrokinetic delta-perturbation ($\\delta f$) formulation in a local sheared slab. The sheared slab uses perpendicular Cartesian coordinates $(x,y)$ with Euclidean metric and a parallel coordinate $z$ along the magnetic field lines. Assume a uniform magnetic field magnitude $B_0$ and constant magnetic shear $s$. Define the field-aligned binormal coordinate $\\alpha$ by the transformation $\\alpha = y - s x z$, with $x$ unchanged and $z$ serving as the coordinate along the magnetic field. The perpendicular Laplacian operator acts within the plane transverse to the magnetic field lines.\n\nStarting from first principles, use the standard definition of the gradient and Laplacian in Euclidean space and apply the chain rule under the coordinate transformation from $(x,y)$ to $(x,\\alpha)$ at fixed $z$ to derive the explicit form of the perpendicular Laplacian $\\nabla_\\perp^2$ in field-aligned coordinates $(x,\\alpha)$ for constant shear $s$. Carefully justify each step of the derivation using only the fundamental definitions of partial derivatives, gradients, and the Laplacian in an orthonormal basis.\n\nUsing the derived form of $\\nabla_\\perp^2$, construct a second-order accurate discrete operator for the electrostatic quasineutrality equation in the sheared slab,\n$$\n- \\alpha_p \\nabla_\\perp^2 \\phi + \\beta_p \\phi = \\rho_\\delta,\n$$\nwhere $\\phi$ is the electrostatic potential, $\\alpha_p$ and $\\beta_p$ are constant coefficients (for example, $\\alpha_p$ can encode polarization response and $\\beta_p$ Debye or adiabatic response), and $\\rho_\\delta$ is the charge density arising from marker weights in the marker-based delta-perturbation algorithm. All quantities are dimensionless in normalized units. The discrete operator must use uniform grids in $x$ and $\\alpha$ with periodic boundary conditions and second-order central differences for all required derivatives in the transverse plane.\n\nTo evaluate your discrete operator, define the test potential on the $(x,\\alpha)$ plane by\n$$\n\\phi(x,\\alpha) = \\sin\\left(\\frac{2\\pi x}{L_x}\\right)\\cos\\left(\\frac{2\\pi \\alpha}{L_\\alpha}\\right),\n$$\nwhere $L_x$ and $L_\\alpha$ are the domain lengths. For the marker-based charge density, deposit a set of delta-perturbation markers with weights onto the $(x,\\alpha)$ grid using a standard Cloud-In-Cell (CIC) scheme under periodic boundary conditions. The CIC scheme must ensure that the total marker weight equals the integral of the discrete $\\rho_\\delta$ over the domain, i.e., the scheme must preserve $\\sum_k w_k$ when integrated over area. Explicitly, use bilinear weights to deposit each marker onto its four nearest grid nodes, normalized by the cell area so that the deposited field has the correct units in the chosen normalization.\n\nYour program must:\n- Derive and implement the discrete form of the perpendicular Laplacian $\\nabla_\\perp^2$ in $(x,\\alpha)$ coordinates for constant shear $s$ using second-order central differences, including correct treatment of any mixed derivatives that arise due to the shear.\n- Compute the continuous $\\nabla_\\perp^2 \\phi$ analytically for comparison, using the chain rule and exact derivatives of $\\phi(x,\\alpha)$ for each test case.\n- Construct the discrete quasineutrality left-hand side $- \\alpha_p \\nabla_\\perp^2 \\phi + \\beta_p \\phi$ and the marker-deposited right-hand side $\\rho_\\delta$.\n- Report two scalar diagnostics for each test case: the root-mean-square (RMS) error between the discrete $\\nabla_\\perp^2 \\phi$ and the analytic $\\nabla_\\perp^2 \\phi$, and the RMS norm of the quasineutrality residual $- \\alpha_p \\nabla_\\perp^2 \\phi + \\beta_p \\phi - \\rho_\\delta$ over the grid.\n\nAll quantities are dimensionless; no physical units are required. Angles, if any, must be treated as dimensionless arguments to trigonometric functions.\n\nUse the following test suite, where each case specifies $(N_x,N_\\alpha,L_x,L_\\alpha,s,z,\\alpha_p,\\beta_p,\\text{markers})$. Here $N_x$ and $N_\\alpha$ are the number of uniform grid points in $x$ and $\\alpha$, respectively; $z$ is the parallel coordinate value at which the operator is evaluated; and markers are given as triples $(x_k,\\alpha_k,w_k)$:\n\n- Test case $1$: $(N_x,N_\\alpha,L_x,L_\\alpha,s,z,\\alpha_p,\\beta_p) = (16,16,1.0,1.0,0.0,0.0,1.0,0.0)$, markers $[(0.25,0.75,0.5),(0.9,0.1,-0.25)]$.\n- Test case $2$: $(N_x,N_\\alpha,L_x,L_\\alpha,s,z,\\alpha_p,\\beta_p) = (32,20,1.0,0.8,0.2,1.0,0.7,0.3)$, markers $[(0.10,0.20,1.0),(0.70,0.50,-0.5),(0.60,0.30,0.8),(0.95,0.78,-0.3)]$.\n- Test case $3$: $(N_x,N_\\alpha,L_x,L_\\alpha,s,z,\\alpha_p,\\beta_p) = (12,12,1.0,1.0,1.0,1.5,1.0,0.0)$, markers $[(0.20,0.20,0.3),(0.80,0.90,-0.2),(0.55,0.40,0.1)]$.\n- Test case $4$: $(N_x,N_\\alpha,L_x,L_\\alpha,s,z,\\alpha_p,\\beta_p) = (8,8,0.6,0.5,0.2,-1.0,0.5,0.0)$, markers $[(0.10,0.10,0.2),(0.40,0.20,-0.1),(0.55,0.42,0.05),(0.30,0.48,-0.07),(0.02,0.05,0.12)]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases, where each test case contributes its two diagnostics $(\\text{RMS error of } \\nabla_\\perp^2 \\phi,\\ \\text{RMS residual of quasineutrality})$. For example, the output format must be\n$$\n[\\text{err}_1,\\text{res}_1,\\text{err}_2,\\text{res}_2,\\text{err}_3,\\text{res}_3,\\text{err}_4,\\text{res}_4].\n$$",
            "solution": "The solution is structured as follows: First, the analytical form of the perpendicular Laplacian operator, $\\nabla_\\perp^2$, is derived in field-aligned coordinates $(x, \\alpha)$. Second, the discretization of this operator using second-order finite differences is detailed. Third, the analytical evaluation of $\\nabla_\\perp^2 \\phi$ for the specified test potential provides a benchmark for accuracy. Fourth, the Cloud-In-Cell (CIC) particle deposition scheme for constructing the marker-based charge density $\\rho_\\delta$ is specified. Finally, the full discrete quasineutrality equation and the required diagnostic metrics are formulated.\n\n### 1. Derivation of the Perpendicular Laplacian in Field-Aligned Coordinates\n\nWe begin in a standard Cartesian coordinate system $(x, y, z)$. The perpendicular Laplacian is defined in the $(x, y)$ plane as $\\nabla_\\perp^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$.\n\nThe problem introduces field-aligned coordinates $(x', \\alpha)$ where the transformation from $(x, y)$ is defined at a fixed parallel coordinate $z$:\n$$\nx' = x\n$$\n$$\n\\alpha = y - s x z\n$$\nFor simplicity, we will denote $x'$ as $x$. We must express the partial derivative operators $\\frac{\\partial}{\\partial x}$ and $\\frac{\\partial}{\\partial y}$ in terms of $\\frac{\\partial}{\\partial x}$ and $\\frac{\\partial}{\\partial \\alpha}$. We use the chain rule. For any differentiable function $f(x, \\alpha)$:\n\nThe partial derivative with respect to the original Cartesian $x$ is:\n$$\n\\frac{\\partial f}{\\partial x}\\bigg|_{y,z} = \\frac{\\partial f}{\\partial x}\\bigg|_{\\alpha,z} \\frac{\\partial x}{\\partial x}\\bigg|_{y,z} + \\frac{\\partial f}{\\partial \\alpha}\\bigg|_{x,z} \\frac{\\partial \\alpha}{\\partial x}\\bigg|_{y,z}\n$$\nFrom the transformation equations, $\\frac{\\partial x}{\\partial x} = 1$ and $\\frac{\\partial \\alpha}{\\partial x} = -sz$. Thus, the operator is:\n$$\n\\frac{\\partial}{\\partial x} \\longrightarrow \\frac{\\partial}{\\partial x} - sz \\frac{\\partial}{\\partial \\alpha}\n$$\n\nThe partial derivative with respect to the original Cartesian $y$ is:\n$$\n\\frac{\\partial f}{\\partial y}\\bigg|_{x,z} = \\frac{\\partial f}{\\partial x}\\bigg|_{\\alpha,z} \\frac{\\partial x}{\\partial y}\\bigg|_{x,z} + \\frac{\\partial f}{\\partial \\alpha}\\bigg|_{x,z} \\frac{\\partial \\alpha}{\\partial y}\\bigg|_{x,z}\n$$\nFrom the transformation equations, $\\frac{\\partial x}{\\partial y} = 0$ and $\\frac{\\partial \\alpha}{\\partial y} = 1$. Thus, the operator is:\n$$\n\\frac{\\partial}{\\partial y} \\longrightarrow \\frac{\\partial}{\\partial \\alpha}\n$$\n\nNow we construct the second-derivative operators. The operator $\\frac{\\partial^2}{\\partial x^2}$ becomes:\n$$\n\\frac{\\partial^2}{\\partial x^2} \\longrightarrow \\left(\\frac{\\partial}{\\partial x} - sz \\frac{\\partial}{\\partial \\alpha}\\right) \\left(\\frac{\\partial}{\\partial x} - sz \\frac{\\partial}{\\partial \\alpha}\\right) = \\frac{\\partial^2}{\\partial x^2} - 2sz \\frac{\\partial^2}{\\partial x \\partial \\alpha} + (sz)^2 \\frac{\\partial^2}{\\partial \\alpha^2}\n$$\nThe operator $\\frac{\\partial^2}{\\partial y^2}$ becomes:\n$$\n\\frac{\\partial^2}{\\partial y^2} \\longrightarrow \\left(\\frac{\\partial}{\\partial \\alpha}\\right) \\left(\\frac{\\partial}{\\partial \\alpha}\\right) = \\frac{\\partial^2}{\\partial \\alpha^2}\n$$\n\nSumming these two components gives the perpendicular Laplacian $\\nabla_\\perp^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ in the new coordinates:\n$$\n\\nabla_\\perp^2 = \\left(\\frac{\\partial^2}{\\partial x^2} - 2sz \\frac{\\partial^2}{\\partial x \\partial \\alpha} + s^2 z^2 \\frac{\\partial^2}{\\partial \\alpha^2}\\right) + \\frac{\\partial^2}{\\partial \\alpha^2}\n$$\n$$\n\\nabla_\\perp^2 = \\frac{\\partial^2}{\\partial x^2} - 2sz \\frac{\\partial^2}{\\partial x \\partial \\alpha} + (1 + s^2 z^2) \\frac{\\partial^2}{\\partial \\alpha^2}\n$$\nThis is the required analytical form of the perpendicular Laplacian in the sheared slab coordinates.\n\n### 2. Discretization of the Laplacian Operator\n\nWe discretize the domain $(x, \\alpha) \\in [0, L_x) \\times [0, L_\\alpha)$ onto a uniform grid of size $N_x \\times N_\\alpha$. The grid points are $(x_i, \\alpha_j)$ where $x_i = i \\Delta x$ for $i=0, \\dots, N_x-1$ and $\\alpha_j = j \\Delta \\alpha$ for $j=0, \\dots, N_\\alpha-1$. The grid spacings are $\\Delta x = L_x/N_x$ and $\\Delta \\alpha = L_\\alpha/N_\\alpha$. Let $\\phi_{i,j} = \\phi(x_i, \\alpha_j)$.\n\nWe use second-order central difference stencils, respecting the periodic boundary conditions:\n$$\n\\frac{\\partial^2 \\phi}{\\partial x^2}\\bigg|_{i,j} \\approx \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{(\\Delta x)^2}\n$$\n$$\n\\frac{\\partial^2 \\phi}{\\partial \\alpha^2}\\bigg|_{i,j} \\approx \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{(\\Delta \\alpha)^2}\n$$\nThe mixed partial derivative is also approximated with a second-order central stencil:\n$$\n\\frac{\\partial^2 \\phi}{\\partial x \\partial \\alpha}\\bigg|_{i,j} \\approx \\frac{\\phi_{i+1,j+1} - \\phi_{i+1,j-1} - \\phi_{i-1,j+1} + \\phi_{i-1,j-1}}{4 \\Delta x \\Delta \\alpha}\n$$\nSubstituting these discrete forms into the analytical expression for $\\nabla_\\perp^2$ yields the discrete operator $(\\nabla_\\perp^2 \\phi)_{i,j}$.\n\n### 3. Analytical Laplacian of the Test Potential\n\nThe test potential is given by $\\phi(x,\\alpha) = \\sin(k_x x)\\cos(k_\\alpha \\alpha)$, where $k_x = 2\\pi/L_x$ and $k_\\alpha = 2\\pi/L_\\alpha$.\nWe compute its partial derivatives analytically:\n$$\n\\frac{\\partial^2 \\phi}{\\partial x^2} = -k_x^2 \\sin(k_x x)\\cos(k_\\alpha \\alpha) = -k_x^2 \\phi\n$$\n$$\n\\frac{\\partial^2 \\phi}{\\partial \\alpha^2} = -k_\\alpha^2 \\sin(k_x x)\\cos(k_\\alpha \\alpha) = -k_\\alpha^2 \\phi\n$$\n$$\n\\frac{\\partial^2 \\phi}{\\partial x \\partial \\alpha} = \\frac{\\partial}{\\partial \\alpha} \\left( k_x \\cos(k_x x)\\cos(k_\\alpha \\alpha) \\right) = -k_x k_\\alpha \\cos(k_x x)\\sin(k_\\alpha \\alpha)\n$$\nSubstituting these into the derived formula for $\\nabla_\\perp^2$:\n$$\n(\\nabla_\\perp^2 \\phi)_{\\text{analytic}} = (-k_x^2 \\phi) - 2sz (-k_x k_\\alpha \\cos(k_x x)\\sin(k_\\alpha \\alpha)) + (1 + s^2 z^2) (-k_\\alpha^2 \\phi)\n$$\n$$\n(\\nabla_\\perp^2 \\phi)_{\\text{analytic}} = -\\left(k_x^2 + (1+s^2z^2)k_\\alpha^2\\right)\\phi + 2szk_x k_\\alpha \\cos(k_x x)\\sin(k_\\alpha \\alpha)\n$$\nThis expression, evaluated at each grid point $(x_i, \\alpha_j)$, serves as the exact solution for calculating the numerical error.\n\n### 4. Cloud-In-Cell (CIC) Marker Deposition\n\nThe right-hand side of the quasineutrality equation, $\\rho_\\delta$, is constructed by depositing weighted markers onto the grid. For a marker $k$ with weight $w_k$ at position $(x_k, \\alpha_k)$, we use a bilinear interpolation (CIC) scheme.\nFirst, we find the marker's logical coordinates and the index of the lower-left grid cell:\n$$\nu_k = x_k / \\Delta x, \\quad v_k = \\alpha_k / \\Delta \\alpha\n$$\n$$\ni = \\lfloor u_k \\rfloor, \\quad j = \\lfloor v_k \\rfloor\n$$\nThe fractional distances within the cell are:\n$$\n\\delta u_k = u_k - i, \\quad \\delta v_k = v_k - j\n$$\nThe weight $w_k$ is distributed to the four surrounding grid nodes $(i,j)$, $(i+1,j)$, $(i,j+1)$, and $(i+1,j+1)$ using bilinear weights:\n$$\nW_{i,j} = (1-\\delta u_k)(1-\\delta v_k)\n$$\n$$\nW_{i+1,j} = \\delta u_k(1-\\delta v_k)\n$$\n$$\nW_{i,j+1} = (1-\\delta u_k)\\delta v_k\n$$\n$$\nW_{i+1,j+1} = \\delta u_k \\delta v_k\n$$\nThe problem requires that the resulting field $\\rho_\\delta$ be a charge density. Therefore, the deposited charge $w_k W$ at each node must be divided by the cell area, $\\Delta x \\Delta \\alpha$. The contribution of marker $k$ to the charge density at node $(i', j')$ is $\\frac{w_k W_{i',j'}}{\\Delta x \\Delta \\alpha}$. The total charge density grid is the sum of contributions from all markers, with periodic boundary conditions applied to the grid indices.\n\n### 5. Diagnostics\n\nThe two required diagnostics are computed as follows:\n\n1.  **RMS error of $\\nabla_\\perp^2 \\phi$**: This measures the accuracy of the discrete Laplacian operator.\n    $$\n    \\text{err}_{\\text{RMS}} = \\sqrt{\\frac{1}{N_x N_\\alpha} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_\\alpha-1} \\left[ (\\nabla_\\perp^2 \\phi)_{\\text{discrete}, i,j} - (\\nabla_\\perp^2 \\phi)_{\\text{analytic}, i,j} \\right]^2}\n    $$\n2.  **RMS residual of quasineutrality**: This measures how well the discrete system is satisfied. The residual field $R$ is defined as:\n    $$\n    R_{i,j} = - \\alpha_p (\\nabla_\\perp^2 \\phi)_{\\text{discrete},i,j} + \\beta_p \\phi_{i,j} - \\rho_{\\delta, i,j}\n    $$\n    The RMS residual is then:\n    $$\n    \\text{res}_{\\text{RMS}} = \\sqrt{\\frac{1}{N_x N_\\alpha} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_\\alpha-1} R_{i,j}^2}\n    $$\nThese calculations will be performed for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the gyrokinetic sheared slab problem for a set of test cases.\n    \"\"\"\n    \n    test_cases = [\n        {'Nx': 16, 'Na': 16, 'Lx': 1.0, 'La': 1.0, 's': 0.0, 'z': 0.0, 'alpha_p': 1.0, 'beta_p': 0.0, \n         'markers': [(0.25, 0.75, 0.5), (0.9, 0.1, -0.25)]},\n        {'Nx': 32, 'Na': 20, 'Lx': 1.0, 'La': 0.8, 's': 0.2, 'z': 1.0, 'alpha_p': 0.7, 'beta_p': 0.3, \n         'markers': [(0.10, 0.20, 1.0), (0.70, 0.50, -0.5), (0.60, 0.30, 0.8), (0.95, 0.78, -0.3)]},\n        {'Nx': 12, 'Na': 12, 'Lx': 1.0, 'La': 1.0, 's': 1.0, 'z': 1.5, 'alpha_p': 1.0, 'beta_p': 0.0, \n         'markers': [(0.20, 0.20, 0.3), (0.80, 0.90, -0.2), (0.55, 0.40, 0.1)]},\n        {'Nx': 8, 'Na': 8, 'Lx': 0.6, 'La': 0.5, 's': 0.2, 'z': -1.0, 'alpha_p': 0.5, 'beta_p': 0.0, \n         'markers': [(0.10, 0.10, 0.2), (0.40, 0.20, -0.1), (0.55, 0.42, 0.05), (0.30, 0.48, -0.07), (0.02, 0.05, 0.12)]}\n    ]\n\n    results = []\n\n    def calculate_discrete_laplacian(phi, dx, da, s, z):\n        \"\"\"\n        Computes the discrete perpendicular Laplacian using 2nd-order central differences.\n        Periodic boundary conditions are handled using np.roll.\n        \"\"\"\n        # Second derivative in x\n        phi_xp1 = np.roll(phi, -1, axis=0)\n        phi_xm1 = np.roll(phi, 1, axis=0)\n        d2phi_dx2 = (phi_xp1 - 2 * phi + phi_xm1) / (dx**2)\n\n        # Second derivative in alpha\n        phi_ap1 = np.roll(phi, -1, axis=1)\n        phi_am1 = np.roll(phi, 1, axis=1)\n        d2phi_da2 = (phi_ap1 - 2 * phi + phi_am1) / (da**2)\n        \n        # Mixed derivative\n        phi_xp1_ap1 = np.roll(np.roll(phi, -1, axis=0), -1, axis=1)\n        phi_xp1_am1 = np.roll(np.roll(phi, -1, axis=0), 1, axis=1)\n        phi_xm1_ap1 = np.roll(np.roll(phi, 1, axis=0), -1, axis=1)\n        phi_xm1_am1 = np.roll(np.roll(phi, 1, axis=0), 1, axis=1)\n        d2phi_dxda = (phi_xp1_ap1 - phi_xp1_am1 - phi_xm1_ap1 + phi_xm1_am1) / (4 * dx * da)\n\n        nabla2_phi = d2phi_dx2 - 2 * s * z * d2phi_dxda + (1 + (s * z)**2) * d2phi_da2\n        return nabla2_phi\n\n    def calculate_analytic_laplacian(x_mesh, a_mesh, Lx, La, s, z):\n        \"\"\"\n        Computes the analytical Laplacian of the test potential on the grid.\n        \"\"\"\n        kx = 2 * np.pi / Lx\n        ka = 2 * np.pi / La\n        \n        phi = np.sin(kx * x_mesh) * np.cos(ka * a_mesh)\n        \n        term1 = -(kx**2 + (1 + (s * z)**2) * ka**2) * phi\n        term2 = 2 * s * z * kx * ka * np.cos(kx * x_mesh) * np.sin(ka * a_mesh)\n        \n        return term1 + term2\n\n    def deposit_cic(markers, Nx, Na, Lx, La):\n        \"\"\"\n        Deposits markers onto a grid using Cloud-In-Cell (CIC) scheme.\n        \"\"\"\n        dx = Lx / Nx\n        da = La / Na\n        cell_area = dx * da\n        rho_delta = np.zeros((Nx, Na))\n\n        for (xp, ap, w) in markers:\n            # Handle periodic wrap-around for particle positions\n            xp = xp % Lx\n            ap = ap % La\n            \n            u = xp / dx\n            v = ap / da\n            \n            i = int(u)\n            j = int(v)\n            \n            du = u - i\n            dv = v - j\n            \n            # Bilinear weights\n            w_ij   = (1 - du) * (1 - dv)\n            w_ip1j = du * (1 - dv)\n            w_ijp1 = (1 - du) * dv\n            w_ip1jp1 = du * dv\n            \n            # Deposit charge density (weight/area)\n            charge_density_contribution = w / cell_area\n            \n            # Apply periodic boundary conditions for indices\n            ip1 = (i + 1) % Nx\n            jp1 = (j + 1) % Na\n            \n            rho_delta[i, j]     += charge_density_contribution * w_ij\n            rho_delta[ip1, j]   += charge_density_contribution * w_ip1j\n            rho_delta[i, jp1]   += charge_density_contribution * w_ijp1\n            rho_delta[ip1, jp1] += charge_density_contribution * w_ip1jp1\n            \n        return rho_delta\n    \n    def rms(field):\n        \"\"\"Computes the Root Mean Square of a 2D field.\"\"\"\n        return np.sqrt(np.mean(field**2))\n\n    for case in test_cases:\n        Nx, Na, Lx, La = case['Nx'], case['Na'], case['Lx'], case['La']\n        s, z, alpha_p, beta_p = case['s'], case['z'], case['alpha_p'], case['beta_p']\n        markers = case['markers']\n\n        dx = Lx / Nx\n        da = La / Na\n\n        # Create grid\n        x_pts = np.linspace(0, Lx, Nx, endpoint=False)\n        a_pts = np.linspace(0, La, Na, endpoint=False)\n        x_mesh, a_mesh = np.meshgrid(x_pts, a_pts, indexing='ij')\n\n        # Define test potential on the grid\n        kx = 2 * np.pi / Lx\n        ka = 2 * np.pi / La\n        phi_grid = np.sin(kx * x_mesh) * np.cos(ka * a_mesh)\n\n        # 1. Calculate discrete and analytic Laplacians\n        nabla2_phi_discrete = calculate_discrete_laplacian(phi_grid, dx, da, s, z)\n        nabla2_phi_analytic = calculate_analytic_laplacian(x_mesh, a_mesh, Lx, La, s, z)\n        \n        # 2. Calculate RMS error of the Laplacian\n        laplacian_error = rms(nabla2_phi_discrete - nabla2_phi_analytic)\n        results.append(laplacian_error)\n\n        # 3. Construct the RHS charge density from markers\n        rho_delta_grid = deposit_cic(markers, Nx, Na, Lx, La)\n\n        # 4. Calculate the quasineutrality residual\n        residual_field = -alpha_p * nabla2_phi_discrete + beta_p * phi_grid - rho_delta_grid\n        \n        # 5. Calculate RMS residual\n        residual_rms = rms(residual_field)\n        results.append(residual_rms)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "To efficiently simulate turbulence in the core of a tokamak, modern gyrokinetic codes often use a \"flux tube\" computational domain that follows a magnetic field line for a few turns around the device. This clever choice of domain, however, introduces unique boundary conditions to correctly represent the global topology of the torus within a local simulation. This exercise  focuses on deriving and implementing the \"twist-shift\" boundary conditions that are essential for such flux-tube models. By preserving a key invariant of the motion, this technique ensures that markers crossing the domain boundaries do so in a way that is physically consistent with the sheared magnetic field structure.",
            "id": "4008405",
            "problem": "Consider a local, field-aligned flux-tube model for gyrokinetic (GK) simulations in a sheared slab approximation with binormal coordinate $y$, radial-like coordinate $x$, and poloidal angle coordinate $\\theta$. Let the magnetic shear be constant, denoted by $\\hat{s}$. In the ballooning representation, define the Clebsch-like label $\\alpha$ along a magnetic field line by the invariant combination\n$$\n\\alpha \\equiv y - \\hat{s}\\, x\\, \\theta,\n$$\nwhich is consistent with the property that the magnetic field $\\mathbf{B}$ satisfies $\\mathbf{B}\\cdot\\nabla \\alpha = 0$ in this local model and thus the label $\\alpha$ is constant along a field line. For a flux-tube simulation with the delta distribution function ($\\delta f$) represented by markers (hereafter \"delta-$f$ markers\"), one must construct boundary conditions that enforce periodicity in both $y$ and $\\theta$ while preserving the physical invariance implied by the ballooning representation.\n\nAssume the following:\n- The binormal coordinate $y$ lives in a periodic domain of length $L_y$, so $y \\in [0,L_y)$ and values are identified modulo $L_y$.\n- The poloidal angle coordinate $\\theta$ lives in a periodic domain with endpoints identified, here taken as $\\theta \\in [-\\Theta,\\Theta]$ with $\\Theta = \\pi$, and angles are in $\\mathrm{radians}$.\n- The delta-$f$ marker carries a constant weight $w$ that must not change when a boundary mapping is applied.\n\nStarting from fundamental geometric properties consistent with magnetized plasma theory and the ballooning representation, derive the boundary maps that must be applied to a marker $(x,y,\\theta)$ whenever it crosses the poloidal angle boundary at $\\theta = \\pm \\Theta$ so that the invariance of $\\alpha$ is enforced. Then, derive how the periodicity in $y$ is enforced by wrapping $y$ into $[0,L_y)$ and explain the role of the invariant $\\alpha$ under this wrap. Your derivation must begin from the definition of $\\alpha$ above and the requirement that $\\mathbf{B}\\cdot\\nabla \\alpha = 0$ in a local sheared slab, and it must not assume any shortcut boundary condition formulas not justified by those foundations.\n\nImplement a program that:\n1. Applies a generic phase-space increment $(\\delta y, \\delta \\theta)$ to a marker state $(x,y,\\theta)$.\n2. Enforces the poloidal boundary by repeatedly mapping across $\\theta = \\pm \\Theta$ with the minimally sufficient number of $2\\pi$ shifts in $\\theta$ and compensating shifts in $y$ that preserve the invariant $\\alpha$.\n3. Enforces the $y$ periodic boundary by wrapping $y$ modulo $L_y$ into $[0,L_y)$.\n4. Verifies the invariance of $\\alpha$ modulo $L_y$, i.e., computes the minimal absolute difference\n$$\n\\epsilon_\\alpha \\equiv \\min_{n \\in \\mathbb{Z}} \\left| \\left( \\alpha_{\\text{after}} - \\alpha_{\\text{before}} \\right) - n L_y \\right|,\n$$\nand also verifies the invariance of the delta-$f$ marker weight $w$ by computing\n$$\n\\epsilon_w \\equiv \\left| w_{\\text{after}} - w_{\\text{before}} \\right|.\n$$\nYour program must produce, for a small set of test cases, the pair $[\\epsilon_\\alpha,\\epsilon_w]$ for each case.\n\nAll angles must be expressed in $\\mathrm{radians}$. There are no other physical units required; coordinates and parameters are to be treated as dimensionless reals. The output values must be floating-point numbers.\n\nUse the following test suite of input parameter sets, each specified as $(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w)$:\n\n- Case $1$ (happy path with positive shear and upward poloidal crossing): $(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.3,\\, 0.7 \\cdot 1.0,\\, 0.9\\pi,\\, 0.8,\\, 1.0,\\, 0.3\\pi,\\, 0.15,\\, 0.5)$.\n- Case $2$ (zero shear, near boundaries): $(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.5,\\, 0.95 \\cdot 1.2,\\, -0.95\\pi,\\, 0.0,\\, 1.2,\\, 0.2\\pi,\\, 0.1,\\, 1.0)$.\n- Case $3$ (exact upper boundary crossing with small binormal increment): $(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.25,\\, 0.99 \\cdot 0.8,\\, \\pi,\\, 0.7,\\, 0.8,\\, 0.1\\pi,\\, 0.02,\\, 0.25)$.\n- Case $4$ (negative $x$, downward poloidal crossing and large binormal increment causing wrap): $(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (-0.4,\\, 0.1,\\, -0.99\\pi,\\, 0.6,\\, 1.0,\\, -0.2\\pi,\\, 1.3,\\, 0.75)$.\n- Case $5$ (large shear-induced shift requiring multiple wraps): $(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.7,\\, 0.05,\\, 0.95\\pi,\\, 1.5,\\, 2.0,\\, 0.3\\pi,\\, 1.1,\\, 0.33)$.\n\nFor each case:\n- Compute $\\alpha_{\\text{before}} = y - \\hat{s}\\, x\\, \\theta$.\n- Apply the increments $(\\delta y,\\delta\\theta)$.\n- Enforce $\\theta$ periodicity by applying the minimal number of shifts $\\theta \\mapsto \\theta \\pm 2\\pi$ needed to bring $\\theta$ into $[-\\pi,\\pi]$, and for each such shift apply the compensating $y$ shift $y \\mapsto y \\pm 2\\pi\\, \\hat{s}\\, x$ that preserves $\\alpha$.\n- Enforce $y$ periodicity by wrapping $y$ into $[0,L_y)$ via $y \\mapsto y \\bmod L_y$.\n- Compute $\\alpha_{\\text{after}}$ and the errors $\\epsilon_\\alpha$ and $\\epsilon_w$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each element being the list $[\\epsilon_\\alpha,\\epsilon_w]$ for the corresponding test case in the order listed above. For example, the output format must be like $[ [a_1,b_1],[a_2,b_2],\\dots,[a_5,b_5] ]$ where each $a_i$ and $b_i$ are floating-point numbers.",
            "solution": "The problem requires the derivation and implementation of boundary conditions for a delta-$f$ marker in a sheared slab geometry, ensuring the correct transformation properties consistent with the ballooning representation.\n\nWe begin from the fundamental givens of the model. The coordinates are a radial-like coordinate $x$, a binormal coordinate $y$, and a poloidal angle coordinate $\\theta$. The magnetic shear, $\\hat{s}$, is constant. A key quantity in the ballooning representation is the Clebsch-like label $\\alpha$, defined as:\n$$\n\\alpha \\equiv y - \\hat{s}\\, x\\, \\theta\n$$\nThis label is an invariant along a magnetic field line, which is mathematically expressed as $\\mathbf{B}\\cdot\\nabla \\alpha = 0$ within this local model. Our task is to construct boundary mappings for $y$ and $\\theta$ that respect this invariance property. The marker weight, $w$, is constant under these geometric transformations.\n\n**1. Derivation of the Poloidal Angle Boundary Condition**\n\nThe poloidal angle $\\theta$ is defined in a periodic domain $\\theta \\in [-\\pi, \\pi]$. The physical space is continuous at the boundaries, meaning that the point at $\\theta = \\pi$ is identified with the point at $\\theta = -\\pi$. A particle trajectory that crosses the boundary at $\\theta = \\pi$ re-emerges at $\\theta = -\\pi$. This corresponds to a mapping in the unwrapped coordinate space of the form $\\theta \\mapsto \\theta \\pm 2\\pi$.\n\nLet a marker's state be $(x, y, \\theta)$. Consider a transformation where the poloidal angle is shifted by an integer multiple of $2\\pi$, representing $k$ full poloidal turns, where $k \\in \\mathbb{Z}$:\n$$\n\\theta' = \\theta + 2\\pi k\n$$\nThe coordinates $(x, y, \\theta)$ and $(x, y', \\theta')$ must represent the same physical state, which requires that the field-line label $\\alpha$ be preserved. Let $\\alpha_{\\text{old}}$ be the value before the transformation and $\\alpha_{\\text{new}}$ be the value after.\n$$\n\\alpha_{\\text{old}} = y - \\hat{s}\\, x\\, \\theta\n$$\n$$\n\\alpha_{\\text{new}} = y' - \\hat{s}\\, x\\, \\theta' = y' - \\hat{s}\\, x\\, (\\theta + 2\\pi k)\n$$\nFor $\\alpha$ to be invariant, we must have $\\alpha_{\\text{new}} = \\alpha_{\\text{old}}$:\n$$\ny' - \\hat{s}\\, x\\, (\\theta + 2\\pi k) = y - \\hat{s}\\, x\\, \\theta\n$$\n$$\ny' - \\hat{s}\\, x\\, \\theta - 2\\pi k \\hat{s}\\, x = y - \\hat{s}\\, x\\, \\theta\n$$\nSolving for $y'$, we find the necessary compensatory shift:\n$$\ny' = y + 2\\pi k \\hat{s}\\, x\n$$\nThus, the complete transformation for a poloidal wrap-around is:\n$$\n\\theta \\mapsto \\theta' = \\theta + 2\\pi k \\\\\ny \\mapsto y' = y + 2\\pi k \\hat{s}\\, x\n$$\nThis is the well-known \"twist-shift\" boundary condition. For a marker crossing the $\\theta$ boundary, we must identify the appropriate integer $k$ that maps its new $\\theta$ coordinate back into the principal domain $[-\\pi, \\pi]$ and apply the corresponding shift to $y$.\n\n**2. Derivation of the Binormal Boundary Condition and its effect on $\\alpha$**\n\nThe binormal coordinate $y$ is periodic in a domain of length $L_y$, i.e., $y \\in [0, L_y)$. A point at $y$ is physically identical to a point at $y + n L_y$ for any integer $n \\in \\mathbb{Z}$.\n\nLet's examine how this periodicity affects the invariant $\\alpha$. Consider a transformation that only shifts $y$ by an integer multiple of its period:\n$$\ny \\mapsto y' = y + n L_y\n$$\nThe new value of $\\alpha$ is:\n$$\n\\alpha' = y' - \\hat{s}\\, x\\, \\theta = (y + n L_y) - \\hat{s}\\, x\\, \\theta = (y - \\hat{s}\\, x\\, \\theta) + n L_y\n$$\n$$\n\\alpha' = \\alpha + n L_y\n$$\nThis demonstrates that $\\alpha$ is not strictly invariant under the periodicity in $y$. Instead, $\\alpha$ is conserved *modulo* $L_y$. Physical quantities must be periodic in $y$ with period $L_y$, which implies that the field-line labels themselves must exhibit a periodic structure with the same period. This is a fundamental consistency requirement of the flux-tube model.\n\n**3. Algorithmic Procedure and Invariance Verification**\n\nThe full algorithm to update a marker's state $(x, y, \\theta)$ after an increment $(\\delta y, \\delta \\theta)$ and verify the invariances is as follows:\n\nLet the initial state be $(x_0, y_0, \\theta_0, w_0)$, with parameters $\\hat{s}$ and $L_y$.\n\n1.  **Compute Initial Invariant**: Calculate $\\alpha_{\\text{before}} = y_0 - \\hat{s}\\, x_0\\, \\theta_0$. The initial weight is $w_{\\text{before}} = w_0$.\n\n2.  **Apply Generic Increment**: The marker's coordinates are updated by the given increments, which represent a generic displacement in phase space.\n    $$\n    y_1 = y_0 + \\delta y \\\\\n    \\theta_1 = \\theta_0 + \\delta \\theta\n    $$\n\n3.  **Enforce Poloidal Periodicity**: The new angle $\\theta_1$ must be mapped back to the principal domain $[-\\pi, \\pi]$. The new angle, $\\theta_2$, is found by finding the value in $[-\\pi,\\pi]$ that is equivalent to $\\theta_1$ up to a multiple of $2\\pi$. This can be computed via a modulo operation: $\\theta_2 = (\\theta_1 + \\pi) \\pmod{2\\pi} - \\pi$. The total angular shift due to this mapping is $\\Delta\\theta_{\\text{map}} = \\theta_2 - \\theta_1$. This shift must be a multiple of $2\\pi$, so $\\Delta\\theta_{\\text{map}} = 2\\pi k$ for some integer $k$. From our derivation, the corresponding shift in $y$ is $\\Delta y_{\\text{map}} = 2\\pi k \\hat{s}\\, x_0 = \\Delta\\theta_{\\text{map}} \\hat{s}\\, x_0$. The updated coordinates are:\n    $$\n    \\theta_2 = (\\theta_1 + \\pi) \\pmod{2\\pi} - \\pi \\\\\n    y_2 = y_1 + (\\theta_2 - \\theta_1) \\hat{s}\\, x_0\n    $$\n\n4.  **Enforce Binormal Periodicity**: The coordinate $y_2$ must be mapped to the domain $[0, L_y)$. This is achieved with a modulo operation:\n    $$\n    y_3 = y_2 \\pmod{L_y}\n    $$\n\n5.  **Final State and Invariants**: The final marker state is $(x_{\\text{after}}, y_{\\text{after}}, \\theta_{\\text{after}}, w_{\\text{after}}) = (x_0, y_3, \\theta_2, w_0)$.\n    The final invariant is $\\alpha_{\\text{after}} = y_3 - \\hat{s}\\, x_0\\, \\theta_2$.\n    The marker weight is unchanged by these geometric operations, so $w_{\\text{after}} = w_0$.\n\n6.  **Verify Invariances**:\n    *   The change in the marker weight is $\\epsilon_w = |w_{\\text{after}} - w_{\\text{before}}| = |w_0 - w_0| = 0$. This must be true to within floating-point precision.\n    *   The problem asks to compute $\\epsilon_\\alpha \\equiv \\min_{n \\in \\mathbb{Z}} | (\\alpha_{\\text{after}} - \\alpha_{\\text{before}}) - n L_y |$. This quantity measures the distance of the total change in $\\alpha$ to the nearest integer multiple of $L_y$. It is a check on the conservation of $\\alpha$ modulo $L_y$. In a numerically exact implementation, this value should correspond to the physical change in $\\alpha$ over the step, modulo $L_y$. The physical change over the increment is $\\Delta\\alpha_{\\text{phys}} = \\delta y - \\hat{s}\\, x_0\\, \\delta\\theta$. The combination of the coordinate update and boundary mappings ensures that $(\\alpha_{\\text{after}} - \\alpha_{\\text{before}}) \\pmod{L_y}$ is equivalent to $\\Delta\\alpha_{\\text{phys}} \\pmod{L_y}$. The value $\\epsilon_\\alpha$ will thus be non-zero in general, reflecting this physical change, but its computation through the full coordinate mapping should be self-consistent and free of numerical artifacts from the boundary implementation itself. The most robust way to calculate $\\epsilon_\\alpha$ for a difference $\\Delta\\alpha = \\alpha_{\\text{after}} - \\alpha_{\\text{before}}$ is by finding the remainder in a symmetric interval around zero, e.g., $\\epsilon_\\alpha = |(\\Delta\\alpha + L_y/2) \\pmod{L_y} - L_y/2|$.\n\nThis completes the derivation of the principles and the algorithm for implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the marker boundary condition problem for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is (x, y, theta, s_hat, L_y, d_theta, d_y, w)\n    test_cases = [\n        (0.3, 0.7 * 1.0, 0.9 * np.pi, 0.8, 1.0, 0.3 * np.pi, 0.15, 0.5),\n        (0.5, 0.95 * 1.2, -0.95 * np.pi, 0.0, 1.2, 0.2 * np.pi, 0.1, 1.0),\n        (0.25, 0.99 * 0.8, np.pi, 0.7, 0.8, 0.1 * np.pi, 0.02, 0.25),\n        (-0.4, 0.1, -0.99 * np.pi, 0.6, 1.0, -0.2 * np.pi, 1.3, 0.75),\n        (0.7, 0.05, 0.95 * np.pi, 1.5, 2.0, 0.3 * np.pi, 1.1, 0.33),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x, y_before, theta_before, s_hat, L_y, d_theta, d_y, w = case\n        \n        # The marker weight `w` is invariant under coordinate transformations.\n        w_before = w\n        w_after = w\n        \n        # 1. Compute initial alpha invariant\n        alpha_before = y_before - s_hat * x * theta_before\n        \n        # 2. Apply generic increments\n        y_intermediate = y_before + d_y\n        theta_intermediate = theta_before + d_theta\n        \n        # 3. Enforce poloidal periodicity (theta in [-pi, pi])\n        # The new angle is wrapped into the principal domain.\n        theta_after = (theta_intermediate + np.pi) % (2.0 * np.pi) - np.pi\n        \n        # The total change in theta due to wrapping is a multiple of 2*pi.\n        theta_shift = theta_after - theta_intermediate\n        \n        # Apply the compensating \"twist-shift\" to y to preserve alpha.\n        y_after_theta_bc = y_intermediate + theta_shift * s_hat * x\n        \n        # 4. Enforce binormal periodicity (y in [0, L_y))\n        y_after = y_after_theta_bc % L_y\n        \n        # 5. Compute final alpha invariant\n        alpha_after = y_after - s_hat * x * theta_after\n        \n        # 6. Verify invariances\n        \n        # Calculate the error in w invariance\n        epsilon_w = abs(w_after - w_before)\n        \n        # Calculate the minimal absolute difference for alpha modulo L_y.\n        # This measures the distance of the total change in alpha to the nearest\n        # integer multiple of L_y.\n        alpha_diff = alpha_after - alpha_before\n        \n        # A robust way to compute `min |alpha_diff - n*L_y|` is to find the\n        # remainder in a symmetric interval [-L_y/2, L_y/2].\n        epsilon_alpha = abs((alpha_diff + L_y / 2.0) % L_y - L_y / 2.0)\n        \n        results.append([epsilon_alpha, epsilon_w])\n\n    # Final print statement in the exact required format.\n    # The list comprehension formats each inner list [a, b] into a string \"[a,b]\".\n    # The outer join then combines them with commas.\n    print(f\"[{','.join([str(r) for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}