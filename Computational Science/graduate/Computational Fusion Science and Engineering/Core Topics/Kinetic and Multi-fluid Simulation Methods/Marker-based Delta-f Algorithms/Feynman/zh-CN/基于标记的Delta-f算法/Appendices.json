{
    "hands_on_practices": [
        {
            "introduction": "在粒子模拟 (PIC) 中，最小化初始的数值噪音至关重要。一个“安静启动”方案通过构造特定的初始标记点分布，使其产生的净微扰电荷和净微扰电流均为零。本练习  将提供设计并实现这样一种方案的动手实践，这是任何稳定且精确的 $\\delta f$ 模拟都必须具备的关键第一步。",
            "id": "4008329",
            "problem": "您的任务是为计算聚变科学与工程中的基于标记点的差分分布函数（delta-f）方法推导并实现一种静启动加载方案。在基于标记点的 delta-f 方法中，总分布函数被分解为 $f = f_0 + \\delta f$，其中 $f_0$ 是一个已知的平衡态，而 $\\delta f$ 是一个由携带权重的计算标记点所表示的小扰动。静启动的目标是初始化标记点，使得在 $t=0$ 时，净扰动电荷和净扰动平行电流均为零，从而最小化非物理的瞬态场。\n\n从以下基本依据出发：\n\n- 沿引导磁场方向的磁化等离子体的动力学描述由关于 $f(\\boldsymbol{x},\\boldsymbol{v},t)$ 的 Vlasov 方程与 Maxwell 方程组耦合决定。对于扰动 $\\delta f$，电荷密度扰动和平行电流扰动由以下公式给出\n$$\\delta n(\\boldsymbol{x},t) = \\int \\delta f(\\boldsymbol{x},\\boldsymbol{v},t)\\,\\mathrm{d}^3 v,\\qquad \\delta j_{\\parallel}(\\boldsymbol{x},t) = \\int v_{\\parallel}\\,\\delta f(\\boldsymbol{x},\\boldsymbol{v},t)\\,\\mathrm{d}^3 v.$$\n- 在基于标记点的表示中，标记点以 $p$ 为索引，具有平行速度 $v_{\\parallel p}$ 和权重 $w_p$，对平衡态 $f_0$ 进行采样，离散矩近似为\n$$\\delta n \\approx \\sum_{p} w_p,\\qquad \\delta j_{\\parallel} \\approx \\sum_{p} w_p\\, v_{\\parallel p}.$$\n- 因此，静启动的一个充分条件是\n$$\\sum_{p} w_p = 0\\quad\\text{and}\\quad \\sum_{p} w_p\\, v_{\\parallel p} = 0.$$\n\n设计一个方案，构建速度对称的配对，并分配权重以确保两个约束条件都得到满足。该方案必须是自洽且物理上合理的。您可以假设平行速度空间是一维的，并且所有标记点在位形空间中均匀分布，因此空间形状函数不会对求和产生偏差。平行速度 $v_{\\parallel}$ 必须以米/秒（m/s）为单位表示。权重 $w_p$ 是无量纲的。\n\n您的推导必须从第一性原理和上述核心定义出发，说明为什么在 $v_{\\parallel}$ 中进行对称配对以及选择适当的权重可以实现 $\\sum_{p} w_p = 0$ 和 $\\sum_{p} w_p v_{\\parallel p} = 0$。这包括一种数学上精确的方法，用于从一个关于 $v_{\\parallel}$ 的偶函数目标形状函数（例如，一个关于 $v_{\\parallel}^2$ 的函数）构建权重，并在不破坏零电流约束的情况下强制执行零净电荷约束。\n\n然后，实现一个完整、可运行的程序，该程序：\n\n- 针对指定的热速度 $v_{\\mathrm{th}}$（单位为 m/s），使用 Gauss-Hermite 节点集或 $v_{\\parallel}$ 上的均匀网格，构建 $M$ 个速度对称配对 $\\{\\pm v_i\\}_{i=1}^M$。\n- 从一个选定的偶函数振幅函数 $a(v)$ 计算配对级别的权重 $w_i$，并通过对集合 $\\{w_i\\}_{i=1}^M$ 进行均值移除步骤来强制执行离散的零净电荷约束，该步骤不违反每个配对的零电流条件。\n- 为配对中的两个标记点分配相同的权重，即 $w_{(+v_i)} = w_{(-v_i)} = w_i$，并构建大小为 $2M$ 的完整标记点集。\n- 报告每个测试用例的净电荷矩的绝对值 $|\\sum_p w_p|$（无量纲）和净电流矩的绝对值 $\\left|\\sum_p w_p v_{\\parallel p}\\right|$（单位为 m/s）。\n\n测试套件：\n\n提供以下测试用例来检验您的实现。对于所有用例，不使用角度，因此不需要角度单位。通过使用合理的物理热速度来确保科学真实性。\n\n- 用例 1 (正常路径): $M=10$, $v_{\\mathrm{th}} = 2.0\\times 10^{5}\\,\\mathrm{m/s}$, 速度网格类型 “Hermite”，使用 $2M$ 个 Gauss-Hermite 节点，振幅 $a(v) = \\varepsilon \\exp\\!\\left(-\\frac{v^2}{v_{\\mathrm{th}}^2}\\right)\\left(\\frac{v^2}{v_{\\mathrm{th}}^2} - 1\\right)$，其中 $\\varepsilon = 10^{-3}$。\n- 用例 2 (最少配对数的边界情况): $M=1$, $v_{\\mathrm{th}} = 3.0\\times 10^{5}\\,\\mathrm{m/s}$, 速度网格类型 “Uniform”，作用于 $[0, 2 v_{\\mathrm{th}}]$，振幅 $a(v) = \\varepsilon$，其中 $\\varepsilon = 10^{-2}$。\n- 用例 3 (非平凡偶函数尾部形状): $M=7$, $v_{\\mathrm{th}} = 1.5\\times 10^{5}\\,\\mathrm{m/s}$, 速度网格类型 “Hermite”，使用 $2M$ 个节点，振幅 $a(v) = \\varepsilon \\left(1 + \\left(\\frac{v}{v_{\\mathrm{th}}}\\right)^4\\right)^{-1}$，其中 $\\varepsilon = 5\\times 10^{-4}$。\n- 用例 4 (均匀网格上更大的动态范围): $M=16$, $v_{\\mathrm{th}} = 4.0\\times 10^{5}\\,\\mathrm{m/s}$, 速度网格类型 “Uniform”，作用于 $[0, 4 v_{\\mathrm{th}}]$，振幅 $a(v) = \\varepsilon \\left(\\frac{v}{v_{\\mathrm{th}}}\\right)^2 \\exp\\!\\left(-\\frac{v}{v_{\\mathrm{th}}}\\right)$，其中 $\\varepsilon = 2\\times 10^{-3}$。\n\n答案规格：\n\n- 对于每个测试用例，计算两个浮点数：$|\\sum_p w_p|$（无量纲）和 $\\left|\\sum_p w_p v_{\\parallel p}\\right|$（单位为 m/s）。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为方括号内用逗号分隔的列表，并按测试用例和指标的顺序排列，即 $[c_1, j_1, c_2, j_2, c_3, j_3, c_4, j_4]$，其中 $c_k$ 是用例 $k$ 的 $|\\sum_p w_p|$，$j_k$ 是用例 $k$ 的 $\\left|\\sum_p w_p v_{\\parallel p}\\right|$。",
            "solution": "该问题要求为基于标记点的 delta-f ($\\delta f$) 粒子模拟算法推导并实现一种静启动加载方案。静启动通过初始化计算标记点来实现，使得在初始时刻 $t=0$ 时，净扰动电荷和净扰动平行电流均为零。这可以最大限度地减少模拟开始时产生的伪非物理场。\n\n根据所提供的定义，扰动电荷密度 $\\delta n$ 和平行电流密度 $\\delta j_{\\parallel}$ 的离散近似由所有计算标记点 $p$ 的总和给出：\n$$ \\delta n \\approx \\sum_{p} w_p $$\n$$ \\delta j_{\\parallel} \\approx \\sum_{p} w_p v_{\\parallel p} $$\n其中 $w_p$ 是标记点 $p$ 的权重，$v_{\\parallel p}$ 是其平行速度。因此，静启动条件就是这两个总和必须为零的约束：\n$$ \\sum_{p} w_p = 0 \\quad (\\text{零净电荷}) $$\n$$ \\sum_{p} w_p v_{\\parallel p} = 0 \\quad (\\text{零净电流}) $$\n\n现在我们将推导一种构造性算法，以生成一组同时满足这两个条件的标记点速度 $\\{v_{\\parallel p}\\}$ 和权重 $\\{w_p\\}$。\n\n该方案的核心是从速度空间中的对称配对来构建标记点总体。假设标记点总数为 $2M$，由 $M$ 个配对组成。对于每个以 $i$ 索引的配对（其中 $i$ 从 $1$ 到 $M$），我们定义两个标记点，一个具有正速度，另一个具有负速度。\n\n设基础正速度集合为 $\\{v_i\\}_{i=1}^M$，其中每个 $v_i \\ge 0$。第 $i$ 个配对的标记点将具有以下速度：\n$$ v_{\\parallel, i, +} = +v_i $$\n$$ v_{\\parallel, i, -} = -v_i $$\n为了通过构造满足零电流条件，我们为给定配对中的两个标记点分配*相同*的权重。将此配对级别的权重表示为 $w_i$。\n$$ w_{i, +} = w_i $$\n$$ w_{i, -} = w_i $$\n\n让我们验证这种构造保证了净平行电流为零。电流的总和可以按配对分组：\n$$ \\sum_{p} w_p v_{\\parallel p} = \\sum_{i=1}^{M} \\left( w_{i,+} v_{\\parallel, i, +} + w_{i,-} v_{\\parallel, i, -} \\right) $$\n代入配对速度和权重的定义：\n$$ \\sum_{i=1}^{M} \\left( w_i (+v_i) + w_i (-v_i) \\right) = \\sum_{i=1}^{M} w_i (v_i - v_i) = \\sum_{i=1}^{M} (w_i \\cdot 0) = 0 $$\n这表明，速度 $(\\pm v_i)$ 与相同权重 $(w_i)$ 的对称配对内在地满足了零电流条件，而与 $v_i$ 和 $w_i$ 的具体值无关。即使在有限精度算术中，这也成立，因为对于每个配对，抵消项 $(v_i - v_i)$ 都是精确的。\n\n接下来，我们处理零电荷条件 $\\sum_{p} w_p = 0$。使用相同的基于配对的分组：\n$$ \\sum_{p} w_p = \\sum_{i=1}^{M} (w_{i,+} + w_{i,-}) = \\sum_{i=1}^{M} (w_i + w_i) = 2 \\sum_{i=1}^{M} w_i $$\n因此，为了使总电荷为零，我们必须对配对级别的权重强制执行以下条件：\n$$ \\sum_{i=1}^{M} w_i = 0 $$\n\n配对级别的权重 $w_i$ 是根据速度空间中期望的初始扰动形状来确定的，该形状由一个振幅函数 $a(v)$ 描述。对于速度上对称的物理扰动（例如，加热），$a(v)$ 通常是 $v$ 的偶函数，例如 $v^2$ 的函数。我们首先通过在基础正速度 $v_i$ 处评估振幅函数来计算一组“原始”权重 $w'_i$：\n$$ w'_i = a(v_i) \\quad \\text{for } i=1, \\dots, M $$\n这些原始权重的总和 $S = \\sum_{i=1}^{M} w'_i$ 通常不为零。\n\n为了强制执行零和约束，我们应用均值移除校正。我们计算原始权重的均值：\n$$ \\bar{w}' = \\frac{1}{M} \\sum_{j=1}^{M} w'_j $$\n然后，通过从每个原始权重中减去这个均值来获得最终的配对级别权重 $w_i$：\n$$ w_i = w'_i - \\bar{w}' $$\n让我们验证这组校正后的权重总和为零：\n$$ \\sum_{i=1}^{M} w_i = \\sum_{i=1}^{M} (w'_i - \\bar{w}') = \\left(\\sum_{i=1}^{M} w'_i\\right) - \\sum_{i=1}^{M} \\bar{w}' = (M\\bar{w}') - M\\bar{w}' = 0 $$\n这个过程成功地生成了一组配对级别的权重 $\\{w_i\\}$，其总和为零（在机器精度范围内），从而满足了零电荷条件 $\\sum_p w_p = 0$。由于此调整是在将配对级别权重 $w_i$ 分配给 $(\\pm v_i)$ 标记点之前进行的，因此保证零电流的对称结构得以保留。因此，该方案是自洽的。\n\n基础正速度集合 $\\{v_i\\}_{i=1}^M$ 可以通过几种方式生成。问题指定了两种：\n1.  **均匀网格**：对于给定的速度范围，例如 $[0, v_{\\max}]$，和 $M$ 个配对，可以均匀采样速度。一个稳健的方法是选择 $M$ 个子区间的中心，即 $v_i = (i-0.5) \\frac{v_{\\max}}{M}$，其中 $i=1, \\dots, M$。\n2.  **Gauss-Hermite 网格**：Gauss-Hermite 求积的节点天然适合对高斯权重函数进行采样，这在等离子体物理学中很常见。对于总共 $2M$ 个标记点，可以计算 Hermite 多项式 $H_{2M}(x)$ 的 $2M$ 个根。这些根关于 $x=0$ 对称。我们选择 $M$ 个正根 $\\{x_j\\}_{j=1}^M$。然后将这些根通过一个特征热速度 $v_{\\mathrm{th}}$ 进行缩放，以获得物理速度：$v_i = v_{\\mathrm{th}} x_i$。当底层分布函数 $f_0$ 是麦克斯韦分布时，此方法特别有效。\n\n总而言之，该算法如下：\n1.  选择配对的数量 $M$。\n2.  使用指定的网格类型生成一组 $M$ 个正速度 $\\{v_i\\}_{i=1}^M$。\n3.  使用给定的振幅函数 $a(v)$ 计算原始权重 $\\{w'_i\\}_{i=1}^M$，使得 $w'_i = a(v_i)$。\n4.  计算原始权重的均值 $\\bar{w}' = \\frac{1}{M}\\sum_i w'_i$。\n5.  计算最终校正后的配对级别权重 $w_i = w'_i - \\bar{w}'$。\n6.  将 $2M$ 个标记点的完整集合构建为 $\\{(\\pm v_i, w_i)\\}_{i=1}^M$。通过这种构造，这组标记点满足 $\\sum_p w_p v_{\\parallel p} = 0$ 和 $\\sum_p w_p = 0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.polynomial.hermite import hermgauss\n\ndef solve():\n    \"\"\"\n    Derives and implements a quiet-start loading scheme for a marker-based\n    delta-f algorithm, ensuring zero net charge and current perturbations.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"M\": 10,\n            \"v_th\": 2.0e5,\n            \"grid_type\": \"Hermite\",\n            \"grid_param\": None,  # Not used for Hermite\n            \"a_func\": lambda v, v_th, eps: eps * np.exp(-(v/v_th)**2) * ((v/v_th)**2 - 1),\n            \"epsilon\": 1e-3,\n        },\n        {\n            \"M\": 1,\n            \"v_th\": 3.0e5,\n            \"grid_type\": \"Uniform\",\n            \"grid_param\": 2.0,  # Grid range is [0, grid_param * v_th]\n            \"a_func\": lambda v, v_th, eps: eps * np.ones_like(v),\n            \"epsilon\": 1e-2,\n        },\n        {\n            \"M\": 7,\n            \"v_th\": 1.5e5,\n            \"grid_type\": \"Hermite\",\n            \"grid_param\": None,\n            \"a_func\": lambda v, v_th, eps: eps / (1 + (v/v_th)**4),\n            \"epsilon\": 5e-4,\n        },\n        {\n            \"M\": 16,\n            \"v_th\": 4.0e5,\n            \"grid_type\": \"Uniform\",\n            \"grid_param\": 4.0,\n            \"a_func\": lambda v, v_th, eps: eps * (v/v_th)**2 * np.exp(-v/v_th),\n            \"epsilon\": 2e-3,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        M = case[\"M\"]\n        v_th = case[\"v_th\"]\n        grid_type = case[\"grid_type\"]\n        grid_param = case[\"grid_param\"]\n        a_func = case[\"a_func\"]\n        epsilon = case[\"epsilon\"]\n\n        # Step 1: Construct M positive velocities {v_i}\n        if grid_type == \"Hermite\":\n            # hermgauss provides 2M symmetric roots for H_{2M}(x)\n            # Scaling for nodes is v = v_th * x, matching exp(-v^2/v_th^2) to exp(-x^2)\n            nodes, _ = hermgauss(2 * M)\n            # Take the M positive roots\n            positive_velocities = nodes[M:] * v_th\n        elif grid_type == \"Uniform\":\n            # Generate M points on [0, v_max] as cell centers\n            # This avoids v=0 and is more robust for M=1\n            v_max = grid_param * v_th\n            delta_v = v_max / M\n            indices = np.arange(1, M + 1)\n            positive_velocities = (indices - 0.5) * delta_v\n        \n        # Step 2: Compute raw pair-level weights w'_i\n        raw_weights = a_func(positive_velocities, v_th, epsilon)\n        \n        # Step 3: Enforce zero-net-charge via mean removal\n        if M > 0:\n            mean_raw_weight = np.mean(raw_weights)\n            final_pair_weights = raw_weights - mean_raw_weight\n        else: # Handle empty case\n            final_pair_weights = np.array([])\n\n        # Step 4: Construct the full marker set and calculate moments\n        # The full set consists of M pairs: (+v_i, w_i) and (-v_i, w_i)\n        \n        # Velocities: [+v_1, ..., +v_M, -v_1, ..., -v_M]\n        full_velocities = np.concatenate([positive_velocities, -positive_velocities])\n        \n        # Weights: [w_1, ..., w_M, w_1, ..., w_M]\n        full_weights = np.concatenate([final_pair_weights, final_pair_weights])\n\n        # Calculate net charge and current moments\n        # These should be zero up to machine precision\n        net_charge = np.sum(full_weights)\n        net_current = np.sum(full_weights * full_velocities)\n        \n        results.extend([abs(net_charge), abs(net_current)])\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join(f'{r:.18e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "初始化粒子后，PIC 循环的核心步骤之一是根据粒子所代表的电荷密度求解静电势。本练习  深入探讨了在剪切平板几何（一种研究等离子体湍流的常用模型）中这一过程。你将推导并实现场向坐标系下的离散拉普拉斯算子，这项任务将架起连续介质物理与实际计算实现之间的桥梁。",
            "id": "4008349",
            "problem": "考虑一个局部剪切平板中的静电回旋动理学 $\\delta f$ 微扰方法。该剪切平板使用具有欧几里得度规的垂直笛卡尔坐标 $(x,y)$ 和沿磁力线的平行坐标 $z$。假设磁场强度 $B_0$ 均匀，磁剪切 $s$ 为常数。通过坐标变换 $\\alpha = y - s x z$ 定义场向双法向坐标 $\\alpha$，其中 $x$ 保持不变，$z$ 作为沿磁场的坐标。垂直拉普拉斯算子作用于垂直于磁力线的平面内。\n\n从第一性原理出发，使用欧几里得空间中梯度和拉普拉斯算子的标准定义，并在固定 $z$ 的情况下，对从 $(x,y)$ 到 $(x,\\alpha)$ 的坐标变换应用链式法则，以推导在场向坐标 $(x,\\alpha)$ 中，对于恒定剪切 $s$ 的垂直拉普拉斯算子 $\\nabla_\\perp^2$ 的显式形式。仔细使用偏导数、梯度和标准正交基中拉普拉斯算子的基本定义，论证推导的每一步。\n\n使用推导出的 $\\nabla_\\perp^2$ 形式，为剪切平板中的静电准中性方程构建一个二阶精确的离散算子：\n$$\n- \\alpha_p \\nabla_\\perp^2 \\phi + \\beta_p \\phi = \\rho_\\delta,\n$$\n其中 $\\phi$ 是静电势，$\\alpha_p$ 和 $\\beta_p$ 是常数系数（例如，$\\alpha_p$ 可以表示极化响应，$\\beta_p$ 可以表示德拜或绝热响应），$\\rho_\\delta$ 是在基于标记点的 $\\delta f$ 微扰算法中由标记点权重产生的电荷密度。在归一化单位中，所有量都是无量纲的。该离散算子必须在 $x$ 和 $\\alpha$ 方向上使用均匀网格，并采用周期性边界条件，对横向平面中所有需要的导数使用二阶中心差分。\n\n为了评估您的离散算子，请在 $(x,\\alpha)$ 平面上定义测试势为\n$$\n\\phi(x,\\alpha) = \\sin\\left(\\frac{2\\pi x}{L_x}\\right)\\cos\\left(\\frac{2\\pi \\alpha}{L_\\alpha}\\right),\n$$\n其中 $L_x$ 和 $L_\\alpha$ 是区域长度。对于基于标记点的电荷密度，请使用标准的网格云 (CIC) 格式，在周期性边界条件下，将一组带权重的 $\\delta f$ 微扰标记点分布到 $(x,\\alpha)$ 网格上。CIC 格式必须确保总标记点权重等于离散 $\\rho_\\delta$ 在整个区域上的积分，即该格式在对面积积分时必须保持 $\\sum_k w_k$ 不变。具体来说，使用双线性权重将每个标记点分布到其最近的四个网格节点上，并用单元格面积进行归一化，以使沉积的场在所选的归一化方案中具有正确的单位。\n\n您的程序必须：\n- 对于恒定剪切 $s$，在 $(x,\\alpha)$ 坐标下，使用二阶中心差分推导并实现垂直拉普拉斯算子 $\\nabla_\\perp^2$ 的离散形式，包括正确处理由剪切引起的任何混合导数。\n- 对每个测试用例，使用链式法则和 $\\phi(x,\\alpha)$ 的精确导数，解析计算连续的 $\\nabla_\\perp^2 \\phi$ 以进行比较。\n- 构建离散的准中性方程左侧项 $- \\alpha_p \\nabla_\\perp^2 \\phi + \\beta_p \\phi$ 和由标记点沉积的右侧项 $\\rho_\\delta$。\n- 为每个测试用例报告两个标量诊断量：离散 $\\nabla_\\perp^2 \\phi$ 与解析 $\\nabla_\\perp^2 \\phi$ 之间的均方根 (RMS) 误差，以及整个网格上准中性残差 $- \\alpha_p \\nabla_\\perp^2 \\phi + \\beta_p \\phi - \\rho_\\delta$ 的均方根范数。\n\n所有量都是无量纲的；不需要物理单位。如果存在角度，必须将其视为三角函数的无量纲参数。\n\n使用以下测试套件，其中每个用例指定 $(N_x,N_\\alpha,L_x,L_\\alpha,s,z,\\alpha_p,\\beta_p,\\text{markers})$。这里 $N_x$ 和 $N_\\alpha$ 分别是 $x$ 和 $\\alpha$ 方向上均匀网格点的数量；$z$ 是评估算子时所在的平行坐标值；标记点以三元组 $(x_k,\\alpha_k,w_k)$ 的形式给出：\n\n- 测试用例 1：$(N_x,N_\\alpha,L_x,L_\\alpha,s,z,\\alpha_p,\\beta_p) = (16,16,1.0,1.0,0.0,0.0,1.0,0.0)$，标记点 $[(0.25,0.75,0.5),(0.9,0.1,-0.25)]$。\n- 测试用例 2：$(N_x,N_\\alpha,L_x,L_\\alpha,s,z,\\alpha_p,\\beta_p) = (32,20,1.0,0.8,0.2,1.0,0.7,0.3)$，标记点 $[(0.10,0.20,1.0),(0.70,0.50,-0.5),(0.60,0.30,0.8),(0.95,0.78,-0.3)]$。\n- 测试用例 3：$(N_x,N_\\alpha,L_x,L_\\alpha,s,z,\\alpha_p,\\beta_p) = (12,12,1.0,1.0,1.0,1.5,1.0,0.0)$，标记点 $[(0.20,0.20,0.3),(0.80,0.90,-0.2),(0.55,0.40,0.1)]$。\n- 测试用例 4：$(N_x,N_\\alpha,L_x,L_\\alpha,s,z,\\alpha_p,\\beta_p) = (8,8,0.6,0.5,0.2,-1.0,0.5,0.0)$，标记点 $[(0.10,0.10,0.2),(0.40,0.20,-0.1),(0.55,0.42,0.05),(0.30,0.48,-0.07),(0.02,0.05,0.12)]$。\n\n您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，形式为方括号括起来的逗号分隔列表，每个测试用例贡献其两个诊断量 $(\\nabla_\\perp^2 \\phi \\text{ 的 RMS 误差}, \\text{ 准中性残差的 RMS 值})$。例如，输出格式必须是\n$$\n[\\text{err}_1,\\text{res}_1,\\text{err}_2,\\text{res}_2,\\text{err}_3,\\text{res}_3,\\text{err}_4,\\text{res}_4].\n$$",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于成熟的回旋动理学理论，特别是在局部剪切平板几何中的 $\\delta f$ 微扰方法。该问题提法恰当，为一项计算验证任务提供了一套完整且一致的参数、定义和目标。所有术语都已定义，并且所需的数值方法（二阶中心差分、网格云）在该领域是标准的。该问题是计算等离子体物理学中一个明确定义的练习，没有歧义或矛盾。因此，我们可以着手解决问题。\n\n解决方案的结构如下：首先，在场向坐标 $(x, \\alpha)$ 中推导垂直拉普拉斯算子 $\\nabla_\\perp^2$ 的解析形式。其次，详细说明使用二阶有限差分对该算子进行离散化的过程。第三，对指定的测试势进行 $\\nabla_\\perp^2 \\phi$ 的解析评估，为准确性提供基准。第四，指定用于构建基于标记点的电荷密度 $\\rho_\\delta$ 的网格云 (CIC) 粒子沉积格式。最后，阐述完整的离散准中性方程和所需的诊断度量。\n\n### 1. 在场向坐标中推导垂直拉普拉斯算子\n\n我们从标准笛卡尔坐标系 $(x, y, z)$ 开始。垂直拉普拉斯算子在 $(x, y)$ 平面中定义为 $\\nabla_\\perp^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$。\n\n问题引入了场向坐标 $(x', \\alpha)$，其中从 $(x, y)$ 的变换是在固定的平行坐标 $z$ 处定义的：\n$$\nx' = x\n$$\n$$\n\\alpha = y - s x z\n$$\n为简单起见，我们将 $x'$ 记为 $x$。我们必须用 $\\frac{\\partial}{\\partial x}$ 和 $\\frac{\\partial}{\\partial \\alpha}$ 来表示偏导数算子 $\\frac{\\partial}{\\partial x}$ 和 $\\frac{\\partial}{\\partial y}$。我们使用链式法则。对于任何可微函数 $f(x, \\alpha)$：\n\n关于原始笛卡尔坐标 $x$ 的偏导数是：\n$$\n\\frac{\\partial f}{\\partial x}\\bigg|_{y,z} = \\frac{\\partial f}{\\partial x}\\bigg|_{\\alpha,z} \\frac{\\partial x}{\\partial x}\\bigg|_{y,z} + \\frac{\\partial f}{\\partial \\alpha}\\bigg|_{x,z} \\frac{\\partial \\alpha}{\\partial x}\\bigg|_{y,z}\n$$\n根据变换方程，$\\frac{\\partial x}{\\partial x} = 1$ 且 $\\frac{\\partial \\alpha}{\\partial x} = -sz$。因此，算子为：\n$$\n\\frac{\\partial}{\\partial x} \\longrightarrow \\frac{\\partial}{\\partial x} - sz \\frac{\\partial}{\\partial \\alpha}\n$$\n\n关于原始笛卡尔坐标 $y$ 的偏导数是：\n$$\n\\frac{\\partial f}{\\partial y}\\bigg|_{x,z} = \\frac{\\partial f}{\\partial x}\\bigg|_{\\alpha,z} \\frac{\\partial x}{\\partial y}\\bigg|_{x,z} + \\frac{\\partial f}{\\partial \\alpha}\\bigg|_{x,z} \\frac{\\partial \\alpha}{\\partial y}\\bigg|_{x,z}\n$$\n根据变换方程，$\\frac{\\partial x}{\\partial y} = 0$ 且 $\\frac{\\partial \\alpha}{\\partial y} = 1$。因此，算子为：\n$$\n\\frac{\\partial}{\\partial y} \\longrightarrow \\frac{\\partial}{\\partial \\alpha}\n$$\n\n现在我们构造二阶导数算子。算子 $\\frac{\\partial^2}{\\partial x^2}$ 变为：\n$$\n\\frac{\\partial^2}{\\partial x^2} \\longrightarrow \\left(\\frac{\\partial}{\\partial x} - sz \\frac{\\partial}{\\partial \\alpha}\\right) \\left(\\frac{\\partial}{\\partial x} - sz \\frac{\\partial}{\\partial \\alpha}\\right) = \\frac{\\partial^2}{\\partial x^2} - 2sz \\frac{\\partial^2}{\\partial x \\partial \\alpha} + (sz)^2 \\frac{\\partial^2}{\\partial \\alpha^2}\n$$\n算子 $\\frac{\\partial^2}{\\partial y^2}$ 变为：\n$$\n\\frac{\\partial^2}{\\partial y^2} \\longrightarrow \\left(\\frac{\\partial}{\\partial \\alpha}\\right) \\left(\\frac{\\partial}{\\partial \\alpha}\\right) = \\frac{\\partial^2}{\\partial \\alpha^2}\n$$\n\n将这两个分量相加，得到新坐标系下的垂直拉普拉斯算子 $\\nabla_\\perp^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$：\n$$\n\\nabla_\\perp^2 = \\left(\\frac{\\partial^2}{\\partial x^2} - 2sz \\frac{\\partial^2}{\\partial x \\partial \\alpha} + s^2 z^2 \\frac{\\partial^2}{\\partial \\alpha^2}\\right) + \\frac{\\partial^2}{\\partial \\alpha^2}\n$$\n$$\n\\nabla_\\perp^2 = \\frac{\\partial^2}{\\partial x^2} - 2sz \\frac{\\partial^2}{\\partial x \\partial \\alpha} + (1 + s^2 z^2) \\frac{\\partial^2}{\\partial \\alpha^2}\n$$\n这就是在剪切平板坐标中所需的垂直拉普拉斯算子的解析形式。\n\n### 2. 拉普拉斯算子的离散化\n\n我们将区域 $(x, \\alpha) \\in [0, L_x) \\times [0, L_\\alpha)$ 离散化到一个大小为 $N_x \\times N_\\alpha$ 的均匀网格上。网格点为 $(x_i, \\alpha_j)$，其中 $x_i = i \\Delta x$，$i=0, \\dots, N_x-1$；$\\alpha_j = j \\Delta \\alpha$，$j=0, \\dots, N_\\alpha-1$。网格间距为 $\\Delta x = L_x/N_x$ 和 $\\Delta \\alpha = L_\\alpha/N_\\alpha$。令 $\\phi_{i,j} = \\phi(x_i, \\alpha_j)$。\n\n我们使用二阶中心差分格式，并考虑周期性边界条件：\n$$\n\\frac{\\partial^2 \\phi}{\\partial x^2}\\bigg|_{i,j} \\approx \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{(\\Delta x)^2}\n$$\n$$\n\\frac{\\partial^2 \\phi}{\\partial \\alpha^2}\\bigg|_{i,j} \\approx \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{(\\Delta \\alpha)^2}\n$$\n混合偏导数也用二阶中心格式近似：\n$$\n\\frac{\\partial^2 \\phi}{\\partial x \\partial \\alpha}\\bigg|_{i,j} \\approx \\frac{\\phi_{i+1,j+1} - \\phi_{i+1,j-1} - \\phi_{i-1,j+1} + \\phi_{i-1,j-1}}{4 \\Delta x \\Delta \\alpha}\n$$\n将这些离散形式代入 $\\nabla_\\perp^2$ 的解析表达式，得到离散算子 $(\\nabla_\\perp^2 \\phi)_{i,j}$。\n\n### 3. 测试势的解析拉普拉斯\n\n测试势由 $\\phi(x,\\alpha) = \\sin(k_x x)\\cos(k_\\alpha \\alpha)$ 给出，其中 $k_x = 2\\pi/L_x$ 且 $k_\\alpha = 2\\pi/L_\\alpha$。\n我们解析地计算其偏导数：\n$$\n\\frac{\\partial^2 \\phi}{\\partial x^2} = -k_x^2 \\sin(k_x x)\\cos(k_\\alpha \\alpha) = -k_x^2 \\phi\n$$\n$$\n\\frac{\\partial^2 \\phi}{\\partial \\alpha^2} = -k_\\alpha^2 \\sin(k_x x)\\cos(k_\\alpha \\alpha) = -k_\\alpha^2 \\phi\n$$\n$$\n\\frac{\\partial^2 \\phi}{\\partial x \\partial \\alpha} = \\frac{\\partial}{\\partial \\alpha} \\left( k_x \\cos(k_x x)\\cos(k_\\alpha \\alpha) \\right) = -k_x k_\\alpha \\cos(k_x x)\\sin(k_\\alpha \\alpha)\n$$\n将这些代入推导出的 $\\nabla_\\perp^2$ 公式中：\n$$\n(\\nabla_\\perp^2 \\phi)_{\\text{analytic}} = (-k_x^2 \\phi) - 2sz (-k_x k_\\alpha \\cos(k_x x)\\sin(k_\\alpha \\alpha)) + (1 + s^2 z^2) (-k_\\alpha^2 \\phi)\n$$\n$$\n(\\nabla_\\perp^2 \\phi)_{\\text{analytic}} = -\\left(k_x^2 + (1+s^2z^2)k_\\alpha^2\\right)\\phi + 2szk_x k_\\alpha \\cos(k_x x)\\sin(k_\\alpha \\alpha)\n$$\n在每个网格点 $(x_i, \\alpha_j)$ 上评估此表达式，它将作为计算数值误差的精确解。\n\n### 4. 网格云 (CIC) 标记点沉积\n\n准中性方程的右侧项 $\\rho_\\delta$ 是通过将带权重的标记点沉积到网格上构建的。对于位于位置 $(x_k, \\alpha_k)$、权重为 $w_k$ 的标记点 $k$，我们使用双线性插值 (CIC) 格式。\n首先，我们找到标记点的逻辑坐标和左下角网格单元的索引：\n$$\nu_k = x_k / \\Delta x, \\quad v_k = \\alpha_k / \\Delta \\alpha\n$$\n$$\ni = \\lfloor u_k \\rfloor, \\quad j = \\lfloor v_k \\rfloor\n$$\n在单元格内的分数距离是：\n$$\n\\delta u_k = u_k - i, \\quad \\delta v_k = v_k - j\n$$\n权重 $w_k$ 使用双线性权重分布到周围的四个网格节点 $(i,j)$, $(i+1,j)$, $(i,j+1)$ 和 $(i+1,j+1)$：\n$$\nW_{i,j} = (1-\\delta u_k)(1-\\delta v_k)\n$$\n$$\nW_{i+1,j} = \\delta u_k(1-\\delta v_k)\n$$\n$$\nW_{i,j+1} = (1-\\delta u_k)\\delta v_k\n$$\n$$\nW_{i+1,j+1} = \\delta u_k \\delta v_k\n$$\n问题要求所得的场 $\\rho_\\delta$ 是一个电荷密度。因此，每个节点上沉积的电荷 $w_k W$ 必须除以单元格面积 $\\Delta x \\Delta \\alpha$。标记点 $k$ 对节点 $(i', j')$ 处电荷密度的贡献是 $\\frac{w_k W_{i',j'}}{\\Delta x \\Delta \\alpha}$。总电荷密度网格是所有标记点贡献的总和，其中网格索引应用了周期性边界条件。\n\n### 5. 诊断量\n\n所需的两个诊断量计算如下：\n\n1.  **$\\nabla_\\perp^2 \\phi$ 的均方根误差**：这用于衡量离散拉普拉斯算子的准确性。\n    $$\n    \\text{err}_{\\text{RMS}} = \\sqrt{\\frac{1}{N_x N_\\alpha} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_\\alpha-1} \\left[ (\\nabla_\\perp^2 \\phi)_{\\text{discrete}, i,j} - (\\nabla_\\perp^2 \\phi)_{\\text{analytic}, i,j} \\right]^2}\n    $$\n2.  **准中性的均方根残差**：这用于衡量离散系统被满足的程度。残差场 $R$ 定义为：\n    $$\n    R_{i,j} = - \\alpha_p (\\nabla_\\perp^2 \\phi)_{\\text{discrete},i,j} + \\beta_p \\phi_{i,j} - \\rho_{\\delta, i,j}\n    $$\n    均方根残差则为：\n    $$\n    \\text{res}_{\\text{RMS}} = \\sqrt{\\frac{1}{N_x N_\\alpha} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_\\alpha-1} R_{i,j}^2}\n    $$\n将对提供的每个测试用例执行这些计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the gyrokinetic sheared slab problem for a set of test cases.\n    \"\"\"\n    \n    test_cases = [\n        {'Nx': 16, 'Na': 16, 'Lx': 1.0, 'La': 1.0, 's': 0.0, 'z': 0.0, 'alpha_p': 1.0, 'beta_p': 0.0, \n         'markers': [(0.25, 0.75, 0.5), (0.9, 0.1, -0.25)]},\n        {'Nx': 32, 'Na': 20, 'Lx': 1.0, 'La': 0.8, 's': 0.2, 'z': 1.0, 'alpha_p': 0.7, 'beta_p': 0.3, \n         'markers': [(0.10, 0.20, 1.0), (0.70, 0.50, -0.5), (0.60, 0.30, 0.8), (0.95, 0.78, -0.3)]},\n        {'Nx': 12, 'Na': 12, 'Lx': 1.0, 'La': 1.0, 's': 1.0, 'z': 1.5, 'alpha_p': 1.0, 'beta_p': 0.0, \n         'markers': [(0.20, 0.20, 0.3), (0.80, 0.90, -0.2), (0.55, 0.40, 0.1)]},\n        {'Nx': 8, 'Na': 8, 'Lx': 0.6, 'La': 0.5, 's': 0.2, 'z': -1.0, 'alpha_p': 0.5, 'beta_p': 0.0, \n         'markers': [(0.10, 0.10, 0.2), (0.40, 0.20, -0.1), (0.55, 0.42, 0.05), (0.30, 0.48, -0.07), (0.02, 0.05, 0.12)]}\n    ]\n\n    results = []\n\n    def calculate_discrete_laplacian(phi, dx, da, s, z):\n        \"\"\"\n        Computes the discrete perpendicular Laplacian using 2nd-order central differences.\n        Periodic boundary conditions are handled using np.roll.\n        \"\"\"\n        # Second derivative in x\n        phi_xp1 = np.roll(phi, -1, axis=0)\n        phi_xm1 = np.roll(phi, 1, axis=0)\n        d2phi_dx2 = (phi_xp1 - 2 * phi + phi_xm1) / (dx**2)\n\n        # Second derivative in alpha\n        phi_ap1 = np.roll(phi, -1, axis=1)\n        phi_am1 = np.roll(phi, 1, axis=1)\n        d2phi_da2 = (phi_ap1 - 2 * phi + phi_am1) / (da**2)\n        \n        # Mixed derivative\n        phi_xp1_ap1 = np.roll(np.roll(phi, -1, axis=0), -1, axis=1)\n        phi_xp1_am1 = np.roll(np.roll(phi, -1, axis=0), 1, axis=1)\n        phi_xm1_ap1 = np.roll(np.roll(phi, 1, axis=0), -1, axis=1)\n        phi_xm1_am1 = np.roll(np.roll(phi, 1, axis=0), 1, axis=1)\n        d2phi_dxda = (phi_xp1_ap1 - phi_xp1_am1 - phi_xm1_ap1 + phi_xm1_am1) / (4 * dx * da)\n\n        nabla2_phi = d2phi_dx2 - 2 * s * z * d2phi_dxda + (1 + (s * z)**2) * d2phi_da2\n        return nabla2_phi\n\n    def calculate_analytic_laplacian(x_mesh, a_mesh, Lx, La, s, z):\n        \"\"\"\n        Computes the analytical Laplacian of the test potential on the grid.\n        \"\"\"\n        kx = 2 * np.pi / Lx\n        ka = 2 * np.pi / La\n        \n        phi = np.sin(kx * x_mesh) * np.cos(ka * a_mesh)\n        \n        term1 = -(kx**2 + (1 + (s * z)**2) * ka**2) * phi\n        term2 = 2 * s * z * kx * ka * np.cos(kx * x_mesh) * np.sin(ka * a_mesh)\n        \n        return term1 + term2\n\n    def deposit_cic(markers, Nx, Na, Lx, La):\n        \"\"\"\n        Deposits markers onto a grid using Cloud-In-Cell (CIC) scheme.\n        \"\"\"\n        dx = Lx / Nx\n        da = La / Na\n        cell_area = dx * da\n        rho_delta = np.zeros((Nx, Na))\n\n        for (xp, ap, w) in markers:\n            # Handle periodic wrap-around for particle positions\n            xp = xp % Lx\n            ap = ap % La\n            \n            u = xp / dx\n            v = ap / da\n            \n            i = int(u)\n            j = int(v)\n            \n            du = u - i\n            dv = v - j\n            \n            # Bilinear weights\n            w_ij   = (1 - du) * (1 - dv)\n            w_ip1j = du * (1 - dv)\n            w_ijp1 = (1 - du) * dv\n            w_ip1jp1 = du * dv\n            \n            # Deposit charge density (weight/area)\n            charge_density_contribution = w / cell_area\n            \n            # Apply periodic boundary conditions for indices\n            ip1 = (i + 1) % Nx\n            jp1 = (j + 1) % Na\n            \n            rho_delta[i, j]     += charge_density_contribution * w_ij\n            rho_delta[ip1, j]   += charge_density_contribution * w_ip1j\n            rho_delta[i, jp1]   += charge_density_contribution * w_ijp1\n            rho_delta[ip1, jp1] += charge_density_contribution * w_ip1jp1\n            \n        return rho_delta\n    \n    def rms(field):\n        \"\"\"Computes the Root Mean Square of a 2D field.\"\"\"\n        return np.sqrt(np.mean(field**2))\n\n    for case in test_cases:\n        Nx, Na, Lx, La = case['Nx'], case['Na'], case['Lx'], case['La']\n        s, z, alpha_p, beta_p = case['s'], case['z'], case['alpha_p'], case['beta_p']\n        markers = case['markers']\n\n        dx = Lx / Nx\n        da = La / Na\n\n        # Create grid\n        x_pts = np.linspace(0, Lx, Nx, endpoint=False)\n        a_pts = np.linspace(0, La, Na, endpoint=False)\n        x_mesh, a_mesh = np.meshgrid(x_pts, a_pts, indexing='ij')\n\n        # Define test potential on the grid\n        kx = 2 * np.pi / Lx\n        ka = 2 * np.pi / La\n        phi_grid = np.sin(kx * x_mesh) * np.cos(ka * a_mesh)\n\n        # 1. Calculate discrete and analytic Laplacians\n        nabla2_phi_discrete = calculate_discrete_laplacian(phi_grid, dx, da, s, z)\n        nabla2_phi_analytic = calculate_analytic_laplacian(x_mesh, a_mesh, Lx, La, s, z)\n        \n        # 2. Calculate RMS error of the Laplacian\n        laplacian_error = rms(nabla2_phi_discrete - nabla2_phi_analytic)\n        results.append(laplacian_error)\n\n        # 3. Construct the RHS charge density from markers\n        rho_delta_grid = deposit_cic(markers, Nx, Na, Lx, La)\n\n        # 4. Calculate the quasineutrality residual\n        residual_field = -alpha_p * nabla2_phi_discrete + beta_p * phi_grid - rho_delta_grid\n        \n        # 5. Calculate RMS residual\n        residual_rms = rms(residual_field)\n        results.append(residual_rms)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现代回旋动理学模拟通常使用磁通管模型和展气球坐标来高效地捕捉等离子体行为。这引入了粒子必须遵守的独特的“扭曲平移”边界条件，以保持物理上的一致性。最后的这个实践  将指导你推导和实现这些高级边界条件，确保当标记点在周期性区域中移动时，场线不变量 $\\alpha$ 得到正确处理。",
            "id": "4008405",
            "problem": "考虑一个用于回旋动理学（GK）模拟的局域、场向通量管模型，该模型采用剪切平板近似，并使用副法向坐标 $y$、类径向坐标 $x$ 和极向角坐标 $\\theta$。设磁剪切为常数，记作 $\\hat{s}$。在气球模表示中，沿磁力线定义一个类克莱布施（Clebsch）标号 $\\alpha$，其形式为一个不变组合：\n$$\n\\alpha \\equiv y - \\hat{s}\\, x\\, \\theta,\n$$\n这与此局域模型中磁场 $\\mathbf{B}$ 满足 $\\mathbf{B}\\cdot\\nabla \\alpha = 0$ 的性质一致，因此标号 $\\alpha$ 沿磁力线为常数。对于一个使用标记点（下文称“delta-$f$标记点”）表示delta分布函数（$\\delta f$）的通量管模拟，必须构建边界条件，以强制 $y$ 和 $\\theta$ 的周期性，同时保持气球模表示所蕴含的物理不变性。\n\n假设如下：\n- 副法向坐标 $y$ 位于一个长度为 $L_y$ 的周期性区域，即 $y \\in [0,L_y)$，且值以 $L_y$ 为模进行等同。\n- 极向角坐标 $\\theta$ 位于一个端点等同的周期性区域，此处取为 $\\theta \\in [-\\Theta,\\Theta]$，其中 $\\Theta = \\pi$，角度单位为 $\\mathrm{radians}$（弧度）。\n- delta-$f$标记点携带一个恒定的权重 $w$，当施加边界映射时，该权重必须保持不变。\n\n从与磁化等离子体理论和气球模表示相一致的基本几何性质出发，推导当一个标记点 $(x,y,\\theta)$ 穿过极向角边界 $\\theta = \\pm \\Theta$ 时必须施加的边界映射，以强制 $\\alpha$ 的不变性。然后，推导如何通过将 $y$ 包裹到 $[0,L_y)$ 中来强制 $y$ 的周期性，并解释在此包裹操作下不变量 $\\alpha$ 的作用。你的推导必须从上述 $\\alpha$ 的定义和在局域剪切平板中 $\\mathbf{B}\\cdot\\nabla \\alpha = 0$ 的要求开始，并且不得假定任何未经这些基础证明的快捷边界条件公式。\n\n实现一个程序，该程序：\n1. 将一个通用的相空间增量 $(\\delta y, \\delta \\theta)$ 施加到一个标记点状态 $(x,y,\\theta)$ 上。\n2. 通过以最小足够数量的 $2\\pi$ 的 $\\theta$ 位移和保持不变量 $\\alpha$ 的 $y$ 补偿位移，重复地跨越 $\\theta = \\pm \\Theta$ 进行映射，来强制施加极向边界。\n3. 通过将 $y$ 按模 $L_y$ 包裹到 $[0,L_y)$ 中，来强制施加 $y$ 的周期性边界。\n4. 验证 $\\alpha$ 在模 $L_y$ 意义下的不变性，即，计算最小绝对差\n$$\n\\epsilon_\\alpha \\equiv \\min_{n \\in \\mathbb{Z}} \\left| \\left( \\alpha_{\\text{after}} - \\alpha_{\\text{before}} \\right) - n L_y \\right|,\n$$\n并同时通过计算\n$$\n\\epsilon_w \\equiv \\left| w_{\\text{after}} - w_{\\text{before}} \\right|\n$$\n来验证delta-$f$标记点权重 $w$ 的不变性。\n你的程序必须为一小组测试用例生成每个用例的数对 $[\\epsilon_\\alpha,\\epsilon_w]$。\n\n所有角度必须以 $\\mathrm{radians}$（弧度）表示。不需要其他物理单位；坐标和参数应被视为无量纲实数。输出值必须是浮点数。\n\n使用以下输入参数集的测试套件，每个指定为 $(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w)$：\n\n- 用例 $1$（正剪切和向上极向穿越的常规路径）：$(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.3,\\, 0.7 \\cdot 1.0,\\, 0.9\\pi,\\, 0.8,\\, 1.0,\\, 0.3\\pi,\\, 0.15,\\, 0.5)$。\n- 用例 $2$（零剪切，靠近边界）：$(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.5,\\, 0.95 \\cdot 1.2,\\, -0.95\\pi,\\, 0.0,\\, 1.2,\\, 0.2\\pi,\\, 0.1,\\, 1.0)$。\n- 用例 $3$（精确上边界穿越，伴有小的副法向增量）：$(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.25,\\, 0.99 \\cdot 0.8,\\, \\pi,\\, 0.7,\\, 0.8,\\, 0.1\\pi,\\, 0.02,\\, 0.25)$。\n- 用例 $4$（负 $x$，向下极向穿越和导致包裹的大副法向增量）：$(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (-0.4,\\, 0.1,\\, -0.99\\pi,\\, 0.6,\\, 1.0,\\, -0.2\\pi,\\, 1.3,\\, 0.75)$。\n- 用例 $5$（大剪切引起的位移，需要多次包裹）：$(x,y,\\theta,\\hat{s},L_y,\\delta\\theta,\\delta y,w) = (0.7,\\, 0.05,\\, 0.95\\pi,\\, 1.5,\\, 2.0,\\, 0.3\\pi,\\, 1.1,\\, 0.33)$。\n\n对于每个用例：\n- 计算 $\\alpha_{\\text{before}} = y - \\hat{s}\\, x\\, \\theta$。\n- 施加增量 $(\\delta y,\\delta\\theta)$。\n- 通过施加将 $\\theta$ 带入 $[-\\pi,\\pi]$ 所需的最小次数的位移 $\\theta \\mapsto \\theta \\pm 2\\pi$，并对每次此类位移施加保持 $\\alpha$ 的补偿性 $y$ 位移 $y \\mapsto y \\pm 2\\pi\\, \\hat{s}\\, x$，来强制 $\\theta$ 的周期性。\n- 通过 $y \\mapsto y \\bmod L_y$ 将 $y$ 包裹到 $[0,L_y)$ 中，来强制 $y$ 的周期性。\n- 计算 $\\alpha_{\\text{after}}$ 以及误差 $\\epsilon_\\alpha$ 和 $\\epsilon_w$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素是对应于上述顺序的测试用例的列表 $[\\epsilon_\\alpha,\\epsilon_w]$。例如，输出格式必须类似于 $[ [a_1,b_1],[a_2,b_2],\\dots,[a_5,b_5] ]$，其中每个 $a_i$ 和 $b_i$ 都是浮点数。",
            "solution": "该问题要求在一个剪切平板几何中，为delta-$f$标记点推导并实现边界条件，确保与气球模表示一致的正确变换性质。\n\n我们从模型的基本给定条件开始。坐标为类径向坐标 $x$、副法向坐标 $y$ 和极向角坐标 $\\theta$。磁剪切 $\\hat{s}$ 是常数。气球模表示中的一个关键量是类克莱布施（Clebsch）标号 $\\alpha$，定义为：\n$$\n\\alpha \\equiv y - \\hat{s}\\, x\\, \\theta\n$$\n该标号是沿磁力线的不变量，在此局域模型中数学上表示为 $\\mathbf{B}\\cdot\\nabla \\alpha = 0$。我们的任务是为 $y$ 和 $\\theta$ 构建尊重此不变性的边界映射。在这些几何变换下，标记点权重 $w$ 是恒定的。\n\n**1. 极向角边界条件的推导**\n\n极向角 $\\theta$ 定义在一个周期性区域 $\\theta \\in [-\\pi, \\pi]$ 中。物理空间在边界处是连续的，意味着 $\\theta = \\pi$ 处的点与 $\\theta = -\\pi$ 处的点等同。一个穿过 $\\theta = \\pi$ 边界的粒子轨道会在 $\\theta = -\\pi$ 处重新出现。这对应于展开坐标空间中一个形式为 $\\theta \\mapsto \\theta \\pm 2\\pi$ 的映射。\n\n设一个标记点的状态为 $(x, y, \\theta)$。考虑一个变换，其中极向角移动了 $2\\pi$ 的整数倍，代表了 $k$ 次完整的极向旋转，其中 $k \\in \\mathbb{Z}$：\n$$\n\\theta' = \\theta + 2\\pi k\n$$\n坐标 $(x, y, \\theta)$ 和 $(x, y', \\theta')$ 必须代表相同的物理状态，这要求磁力线标号 $\\alpha$ 保持不变。设 $\\alpha_{\\text{old}}$ 为变换前的值，$\\alpha_{\\text{new}}$ 为变换后的值。\n$$\n\\alpha_{\\text{old}} = y - \\hat{s}\\, x\\, \\theta\n$$\n$$\n\\alpha_{\\text{new}} = y' - \\hat{s}\\, x\\, \\theta' = y' - \\hat{s}\\, x\\, (\\theta + 2\\pi k)\n$$\n为了使 $\\alpha$ 保持不变，我们必须有 $\\alpha_{\\text{new}} = \\alpha_{\\text{old}}$：\n$$\ny' - \\hat{s}\\, x\\, (\\theta + 2\\pi k) = y - \\hat{s}\\, x\\, \\theta\n$$\n$$\ny' - \\hat{s}\\, x\\, \\theta - 2\\pi k \\hat{s}\\, x = y - \\hat{s}\\, x\\, \\theta\n$$\n解出 $y'$，我们得到必要的补偿位移：\n$$\ny' = y + 2\\pi k \\hat{s}\\, x\n$$\n因此，对于一次极向环绕的完整变换是：\n$$\n\\theta \\mapsto \\theta' = \\theta + 2\\pi k \\\\\ny \\mapsto y' = y + 2\\pi k \\hat{s}\\, x\n$$\n这就是著名的“扭曲-平移”（twist-shift）边界条件。对于一个穿过 $\\theta$ 边界的标记点，我们必须确定合适的整数 $k$，该整数将其新的 $\\theta$ 坐标映射回主域 $[-\\pi, \\pi]$，并对 $y$ 施加相应的位移。\n\n**2. 副法向边界条件的推导及其对 $\\alpha$ 的影响**\n\n副法向坐标 $y$ 在一个长度为 $L_y$ 的区域内是周期性的，即 $y \\in [0, L_y)$。$y$ 处的一个点与 $y + n L_y$ 处的点在物理上是等同的，其中 $n \\in \\mathbb{Z}$ 为任意整数。\n\n让我们研究这种周期性如何影响不变量 $\\alpha$。考虑一个只将 $y$ 移动其周期整数倍的变换：\n$$\ny \\mapsto y' = y + n L_y\n$$\n$\\alpha$ 的新值为：\n$$\n\\alpha' = y' - \\hat{s}\\, x\\, \\theta = (y + n L_y) - \\hat{s}\\, x\\, \\theta = (y - \\hat{s}\\, x\\, \\theta) + n L_y\n$$\n$$\n\\alpha' = \\alpha + n L_y\n$$\n这表明，在 $y$ 的周期性下，$\\alpha$ 并非严格不变。而是，$\\alpha$ 在模 $L_y$ 意义下是守恒的。物理量必须在 $y$ 方向上以 $L_y$ 为周期，这意味着磁力线标号本身也必须展现出具有相同周期的周期性结构。这是通量管模型的一个基本一致性要求。\n\n**3. 算法流程与不变性验证**\n\n在施加一个增量 $(\\delta y, \\delta \\theta)$ 后，更新一个标记点状态 $(x, y, \\theta)$ 并验证不变性的完整算法如下：\n\n设初始状态为 $(x_0, y_0, \\theta_0, w_0)$，参数为 $\\hat{s}$ 和 $L_y$。\n\n1.  **计算初始不变量**：计算 $\\alpha_{\\text{before}} = y_0 - \\hat{s}\\, x_0\\, \\theta_0$。初始权重为 $w_{\\text{before}} = w_0$。\n\n2.  **施加通用增量**：标记点的坐标由给定的增量更新，这代表了相空间中的一个通用位移。\n    $$\n    y_1 = y_0 + \\delta y \\\\\n    \\theta_1 = \\theta_0 + \\delta \\theta\n    $$\n\n3.  **强制极向周期性**：新角度 $\\theta_1$ 必须被映射回主域 $[-\\pi, \\pi]$。新角度 $\\theta_2$ 是通过找到在 $[-\\pi,\\pi]$ 内与 $\\theta_1$ 相差 $2\\pi$ 整数倍的等效值来确定的。这可以通过模运算计算：$\\theta_2 = (\\theta_1 + \\pi) \\pmod{2\\pi} - \\pi$。由于此映射产生的总角度位移为 $\\Delta\\theta_{\\text{map}} = \\theta_2 - \\theta_1$。该位移必须是 $2\\pi$ 的整数倍，即 $\\Delta\\theta_{\\text{map}} = 2\\pi k$（对于某个整数 $k$）。根据我们的推导，$y$ 中相应的位移是 $\\Delta y_{\\text{map}} = 2\\pi k \\hat{s}\\, x_0 = \\Delta\\theta_{\\text{map}} \\hat{s}\\, x_0$。更新后的坐标是：\n    $$\n    \\theta_2 = (\\theta_1 + \\pi) \\pmod{2\\pi} - \\pi \\\\\n    y_2 = y_1 + (\\theta_2 - \\theta_1) \\hat{s}\\, x_0\n    $$\n\n4.  **强制副法向周期性**：坐标 $y_2$ 必须被映射到区域 $[0, L_y)$。这通过模运算实现：\n    $$\n    y_3 = y_2 \\pmod{L_y}\n    $$\n\n5.  **最终状态和不变量**：最终的标记点状态为 $(x_{\\text{after}}, y_{\\text{after}}, \\theta_{\\text{after}}, w_{\\text{after}}) = (x_0, y_3, \\theta_2, w_0)$。最终的不变量是 $\\alpha_{\\text{after}} = y_3 - \\hat{s}\\, x_0\\, \\theta_2$。标记点权重在这些几何操作下保持不变，所以 $w_{\\text{after}} = w_0$。\n\n6.  **验证不变性**：\n    *   标记点权重的变化是 $\\epsilon_w = |w_{\\text{after}} - w_{\\text{before}}| = |w_0 - w_0| = 0$。这必须在浮点精度范围内成立。\n    *   问题要求计算 $\\epsilon_\\alpha \\equiv \\min_{n \\in \\mathbb{Z}} | (\\alpha_{\\text{after}} - \\alpha_{\\text{before}}) - n L_y |$。这个量度量了 $\\alpha$ 的总变化量与 $L_y$ 的最近整数倍之间的距离。这是对 $\\alpha$ 在模 $L_y$ 意义下守恒性的一个检验。在一个数值精确的实现中，这个值应该对应于一个步长内 $\\alpha$ 的物理变化量（模 $L_y$）。在该增量上的物理变化是 $\\Delta\\alpha_{\\text{phys}} = \\delta y - \\hat{s}\\, x_0\\, \\delta\\theta$。坐标更新和边界映射的组合确保了 $(\\alpha_{\\text{after}} - \\alpha_{\\text{before}}) \\pmod{L_y}$ 与 $\\Delta\\alpha_{\\text{phys}} \\pmod{L_y}$ 等价。因此，$\\epsilon_\\alpha$ 的值通常不为零，反映了这种物理变化，但通过完整坐标映射对其进行计算应该是自洽的，并且没有来自边界实现本身的数值伪影。对于一个差值 $\\Delta\\alpha = \\alpha_{\\text{after}} - \\alpha_{\\text{before}}$，计算 $\\epsilon_\\alpha$ 最稳健的方法是找到在零点周围的对称区间内的余数，例如 $\\epsilon_\\alpha = |(\\Delta\\alpha + L_y/2) \\pmod{L_y} - L_y/2|$。\n\n这完成了原理推导和实现算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the marker boundary condition problem for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is (x, y, theta, s_hat, L_y, d_theta, d_y, w)\n    test_cases = [\n        (0.3, 0.7 * 1.0, 0.9 * np.pi, 0.8, 1.0, 0.3 * np.pi, 0.15, 0.5),\n        (0.5, 0.95 * 1.2, -0.95 * np.pi, 0.0, 1.2, 0.2 * np.pi, 0.1, 1.0),\n        (0.25, 0.99 * 0.8, np.pi, 0.7, 0.8, 0.1 * np.pi, 0.02, 0.25),\n        (-0.4, 0.1, -0.99 * np.pi, 0.6, 1.0, -0.2 * np.pi, 1.3, 0.75),\n        (0.7, 0.05, 0.95 * np.pi, 1.5, 2.0, 0.3 * np.pi, 1.1, 0.33),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x, y_before, theta_before, s_hat, L_y, d_theta, d_y, w = case\n        \n        # The marker weight `w` is invariant under coordinate transformations.\n        w_before = w\n        w_after = w\n        \n        # 1. Compute initial alpha invariant\n        alpha_before = y_before - s_hat * x * theta_before\n        \n        # 2. Apply generic increments\n        y_intermediate = y_before + d_y\n        theta_intermediate = theta_before + d_theta\n        \n        # 3. Enforce poloidal periodicity (theta in [-pi, pi])\n        # The new angle is wrapped into the principal domain.\n        theta_after = (theta_intermediate + np.pi) % (2.0 * np.pi) - np.pi\n        \n        # The total change in theta due to wrapping is a multiple of 2*pi.\n        theta_shift = theta_after - theta_intermediate\n        \n        # Apply the compensating \"twist-shift\" to y to preserve alpha.\n        y_after_theta_bc = y_intermediate + theta_shift * s_hat * x\n        \n        # 4. Enforce binormal periodicity (y in [0, L_y))\n        y_after = y_after_theta_bc % L_y\n        \n        # 5. Compute final alpha invariant\n        alpha_after = y_after - s_hat * x * theta_after\n        \n        # 6. Verify invariances\n        \n        # Calculate the error in w invariance\n        epsilon_w = abs(w_after - w_before)\n        \n        # Calculate the minimal absolute difference for alpha modulo L_y.\n        # This measures the distance of the total change in alpha to the nearest\n        # integer multiple of L_y.\n        alpha_diff = alpha_after - alpha_before\n        \n        # A robust way to compute `min |alpha_diff - n*L_y|` is to find the\n        # remainder in a symmetric interval [-L_y/2, L_y/2].\n        epsilon_alpha = abs((alpha_diff + L_y / 2.0) % L_y - L_y / 2.0)\n        \n        results.append([epsilon_alpha, epsilon_w])\n\n    # Final print statement in the exact required format.\n    # The list comprehension formats each inner list [a, b] into a string \"[a,b]\".\n    # The outer join then combines them with commas.\n    print(f\"[{','.join([str(r) for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}