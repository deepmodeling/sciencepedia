{
    "hands_on_practices": [
        {
            "introduction": "Before simulating a complex plasma, we must first ensure our numerical methods can accurately capture the motion of a single charged particle. In a magnetized plasma, the fundamental motion is gyration around magnetic field lines. This exercise  delves into the accuracy of the Boris algorithm, the standard particle integrator in PIC codes, by quantifying the numerical phase error it introduces into this cyclotron motion. By deriving and applying a time-step constraint, you will develop a crucial skill: selecting simulation parameters that preserve the physical fidelity of the underlying particle dynamics.",
            "id": "4027304",
            "problem": "Consider a single charged particle moving in a uniform magnetic field in the context of the Particle-In-Cell (PIC) method used in computational fusion science and engineering. The motion is governed by the Lorentz force law starting from first principles. Specifically, the equation of motion is $m \\, d\\mathbf{v}/dt = q\\, \\mathbf{v}\\times\\mathbf{B}$ for a constant $\\mathbf{B}$ and zero electric field, which yields uniform circular motion in the plane perpendicular to $\\mathbf{B}$. The continuous cyclotron angular frequency is defined by $\\Omega_c = |q|B/m$.\n\nYour tasks are:\n\n- Derive from the Lorentz force law and the definition of cyclotron motion the continuous-time uniform circular motion properties and relate them to the discrete-time update used in the standard PIC velocity integrator (widely known as the Boris pusher) under the assumption of zero electric field and uniform magnetic field. Starting from the discretized update that preserves the speed and rotates the velocity vector, derive the discrete phase advance per time step as a function of $\\Delta t$ and $\\Omega_c$, and from this derive a constraint on $\\Delta t$ such that the magnitude of the per-step relative phase error does not exceed a prescribed tolerance $\\eta$. Express the final constraint explicitly as an inequality in seconds for $\\Delta t$ using $\\Omega_c$ and $\\eta$, and specify the angle unit as radians.\n\n- Evaluate the accuracy loss as $\\Delta t$ approaches a fraction $f$ of the physical cyclotron period $2\\pi/\\Omega_c$. Quantify accuracy loss by computing all of the following metrics:\n    1. The relative numerical cyclotron frequency error $(\\Omega_{\\text{num}}/\\Omega_c - 1)$, which is dimensionless.\n    2. The relative numerical period error $\\left( (2\\pi/\\Omega_{\\text{num}}) / (2\\pi/\\Omega_c) - 1 \\right)$, which is dimensionless.\n    3. The per-step phase error in radians, defined as $(\\theta - \\Omega_c \\Delta t)$, where $\\theta$ is the discrete phase advance per step.\n    4. A boolean indicating whether the derived $\\Delta t$ constraint is met, i.e., whether $\\Delta t \\leq \\Delta t_{\\max}(\\eta,\\Omega_c)$.\n    5. The end-of-period position error in meters defined as the Euclidean norm of the difference between the numerical position after one physical cyclotron period and the exact position after one period (which returns to the initial position for uniform circular motion).\n\nUse the following physically consistent parameters for the test suite. The particle is an electron with charge magnitude $|q| = 1.602176634\\times 10^{-19}\\ \\mathrm{C}$, mass $m = 9.1093837015\\times 10^{-31}\\ \\mathrm{kg}$, and the magnetic field magnitude is $B = 5\\ \\mathrm{T}$ oriented along the $+\\hat{\\mathbf{z}}$ axis. The initial perpendicular speed is $v_\\perp = 1.0\\times 10^{5}\\ \\mathrm{m/s}$, the initial position is $\\mathbf{x}(0) = (r_L, 0, 0)$ and the initial velocity is $\\mathbf{v}(0) = (0, v_\\perp, 0)$, where $r_L = v_\\perp/\\Omega_c$ is the Larmor radius. Angles must be in radians and time in seconds. The discrete position update should use the trapezoidal rule consistent with second-order accuracy: $\\mathbf{x}^{n+1} = \\mathbf{x}^{n} + \\Delta t \\, (\\mathbf{v}^{n} + \\mathbf{v}^{n+1})/2$.\n\nEvaluate the metrics for the following four test cases, each specified by the pair $(f,\\eta)$ with $\\Delta t = f \\times (2\\pi/\\Omega_c)$:\n\n- Case $1$: $(f=\\;0.05,\\ \\eta=\\;0.01)$.\n- Case $2$: $(f=\\;0.25,\\ \\eta=\\;0.01)$.\n- Case $3$: $(f=\\;0.50,\\ \\eta=\\;0.05)$.\n- Case $4$: $(f=\\;1.00,\\ \\eta=\\;0.01)$.\n\nFor each case, compute and output the following six quantities in the fixed order listed below:\n- The relative numerical cyclotron frequency error $(\\Omega_{\\text{num}}/\\Omega_c - 1)$ (dimensionless).\n- The relative numerical period error $\\left( (2\\pi/\\Omega_{\\text{num}}) / (2\\pi/\\Omega_c) - 1 \\right)$ (dimensionless).\n- The per-step phase error $(\\theta - \\Omega_c \\Delta t)$ in radians.\n- The boolean indicating if the $\\Delta t$ constraint is satisfied for the given $\\eta$.\n- The derived upper bound $\\Delta t_{\\max}(\\eta,\\Omega_c)$ in seconds.\n- The end-of-period position error (meters).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the exact order listed above for each test case, concatenated sequentially across all four cases. For example, the output should be of the form $[\\text{case1\\_val1},\\text{case1\\_val2},\\ldots,\\text{case4\\_val6}]$. All angles must be in radians, all times must be in seconds, and distances must be in meters. No percentage signs are permitted; all relative errors must be dimensionless real numbers.",
            "solution": "The problem requires a two-part analysis of a charged particle's motion in a uniform magnetic field, as modeled by the Particle-In-Cell (PIC) method. First, we must derive a constraint on the discrete time step $\\Delta t$ based on a tolerable phase error. Second, we must evaluate several accuracy metrics for specified test cases.\n\n### Part 1: Derivation of the Time Step Constraint\n\n#### Continuous Motion under Lorentz Force\nThe motion of a particle with mass $m$ and charge $q$ in a magnetic field $\\mathbf{B}$ and zero electric field ($\\mathbf{E}=0$) is governed by the Lorentz force law:\n$$ m \\frac{d\\mathbf{v}}{dt} = q(\\mathbf{v} \\times \\mathbf{B}) $$\nLet the magnetic field be uniform and aligned with the $\\hat{\\mathbf{z}}$-axis, $\\mathbf{B} = B\\hat{\\mathbf{z}}$. The equation of motion separates into components parallel and perpendicular to $\\mathbf{B}$. The parallel velocity $v_z$ is constant, as $\\frac{dv_z}{dt}=0$. The perpendicular components of velocity, $v_x$ and $v_y$, evolve according to:\n$$ \\frac{dv_x}{dt} = \\frac{qB}{m} v_y $$\n$$ \\frac{dv_y}{dt} = -\\frac{qB}{m} v_x $$\nFor an electron, $q = -e  0$. We define the cyclotron angular frequency as $\\Omega_c = |q|B/m = eB/m > 0$. The equations become:\n$$ \\frac{dv_x}{dt} = -\\Omega_c v_y $$\n$$ \\frac{dv_y}{dt} = \\Omega_c v_x $$\nThis system describes uniform circular motion in the $xy$-plane with angular frequency $\\Omega_c$. The velocity vector $\\mathbf{v}_\\perp = (v_x, v_y)$ rotates clockwise with this frequency. After a time interval $\\Delta t$, the velocity vector undergoes a rotation by an angle $\\phi_c = \\Omega_c \\Delta t$.\n\n#### Discrete Velocity Update (Boris Pusher)\nThe Boris algorithm is a standard velocity integrator in PIC codes. For $\\mathbf{E}=0$, the velocity update from time step $n$ to $n+1$ reduces to a pure rotation. The update is given by:\n$$ \\mathbf{v}^{n+1} - \\mathbf{v}^n = (\\mathbf{v}^{n+1} + \\mathbf{v}^n) \\times \\mathbf{t} $$\nwhere $\\mathbf{t} = \\frac{q\\mathbf{B}\\Delta t}{2m}$. This can be rearranged to express $\\mathbf{v}^{n+1}$ explicitly, yielding a rotation of $\\mathbf{v}^n$.\n\nLet's consider the perpendicular velocity vector $\\mathbf{v}_\\perp$. The update corresponds to a rotation by an angle $\\theta$ given by:\n$$ \\tan\\left(\\frac{\\theta}{2}\\right) = \\left|\\frac{qB\\Delta t}{2m}\\right| = \\frac{|q|B\\Delta t}{2m} = \\frac{\\Omega_c \\Delta t}{2} $$\nThe discrete phase advance per time step is therefore:\n$$ \\theta = 2 \\arctan\\left(\\frac{\\Omega_c \\Delta t}{2}\\right) $$\nThe numerical method thus rotates the velocity vector by a discrete angle $\\theta$ in each step $\\Delta t$, which is an approximation to the continuous rotation $\\phi_c = \\Omega_c \\Delta t$.\n\n#### Time Step Constraint from Phase Error\nThe numerical cyclotron frequency is $\\Omega_{\\text{num}} = \\theta / \\Delta t$. The exact frequency is $\\Omega_c$. The problem requires constraining the per-step relative phase error, which we define as $|\\frac{\\theta-\\Omega_c\\Delta t}{\\Omega_c\\Delta t}|$, to be less than or equal to a tolerance $\\eta$:\n$$ \\frac{|\\theta - \\Omega_c \\Delta t|}{\\Omega_c \\Delta t} \\leq \\eta $$\nTo derive a constraint on $\\Delta t$, we use the Taylor series expansion of $\\arctan(x)$ for small $x$: $\\arctan(x) = x - x^3/3 + O(x^5)$. Let $u = \\frac{\\Omega_c \\Delta t}{2}$. The phase advance is:\n$$ \\theta = 2 \\arctan(u) \\approx 2\\left(u - \\frac{u^3}{3}\\right) = 2u - \\frac{2u^3}{3} = \\Omega_c \\Delta t - \\frac{2}{3}\\left(\\frac{\\Omega_c \\Delta t}{2}\\right)^3 = \\Omega_c \\Delta t - \\frac{(\\Omega_c \\Delta t)^3}{12} $$\nThe phase error per step is $\\theta - \\Omega_c \\Delta t \\approx - \\frac{(\\Omega_c \\Delta t)^3}{12}$. For $\\Omega_c \\Delta t > 0$, the numerical phase advance $\\theta$ is always slightly less than the true phase advance $\\Omega_c \\Delta t$, meaning the numerical particle lags.\n\nThe magnitude of the relative phase error is approximately:\n$$ \\frac{|\\theta - \\Omega_c \\Delta t|}{\\Omega_c \\Delta t} \\approx \\frac{(\\Omega_c \\Delta t)^3 / 12}{\\Omega_c \\Delta t} = \\frac{(\\Omega_c \\Delta t)^2}{12} $$\nApplying the tolerance $\\eta$:\n$$ \\frac{(\\Omega_c \\Delta t)^2}{12} \\leq \\eta $$\n$$ (\\Omega_c \\Delta t)^2 \\leq 12\\eta $$\n$$ \\Omega_c \\Delta t \\leq \\sqrt{12\\eta} $$\nThis yields the explicit constraint on the time step $\\Delta t$:\n$$ \\Delta t \\leq \\frac{\\sqrt{12\\eta}}{\\Omega_c} $$\nWe define the maximum allowed time step as $\\Delta t_{\\max}(\\eta, \\Omega_c) = \\frac{\\sqrt{12\\eta}}{\\Omega_c}$.\n\n### Part 2: Evaluation of Accuracy Metrics\n\nWe will now calculate the six specified metrics for each test case.\n\n**Physical and Simulation Parameters:**\n- Electron charge magnitude: $|q| = e = 1.602176634 \\times 10^{-19}\\ \\mathrm{C}$\n- Electron mass: $m = 9.1093837015 \\times 10^{-31}\\ \\mathrm{kg}$\n- Magnetic field: $B = 5\\ \\mathrm{T}$\n- Initial perpendicular speed: $v_\\perp = 1.0 \\times 10^5\\ \\mathrm{m/s}$\n- Cyclotron frequency: $\\Omega_c = eB/m$\n- Physical cyclotron period: $T_c = 2\\pi/\\Omega_c$\n- Larmor radius: $r_L = v_\\perp/\\Omega_c$\n- Initial position: $\\mathbf{x}(0) = (r_L, 0, 0)$\n- Initial velocity: $\\mathbf{v}(0) = (0, v_\\perp, 0)$\n- Time step: $\\Delta t = f \\cdot T_c = f \\cdot (2\\pi/\\Omega_c)$\n\nFor each case $(f, \\eta)$, we perform the following calculations:\n\n1.  **Relative Numerical Cyclotron Frequency Error:**\n    $\\Omega_{\\text{num}} = \\theta/\\Delta t = \\frac{2}{\\Delta t} \\arctan(\\frac{\\Omega_c \\Delta t}{2})$.\n    The error is $\\frac{\\Omega_{\\text{num}}}{\\Omega_c} - 1 = \\frac{2}{\\Omega_c \\Delta t}\\arctan\\left(\\frac{\\Omega_c \\Delta t}{2}\\right) - 1$.\n\n2.  **Relative Numerical Period Error:**\n    $T_{\\text{num}} = 2\\pi/\\Omega_{\\text{num}}$.\n    The error is $\\frac{T_{\\text{num}}}{T_c} - 1 = \\frac{2\\pi/\\Omega_{\\text{num}}}{2\\pi/\\Omega_c} - 1 = \\frac{\\Omega_c}{\\Omega_{\\text{num}}} - 1$.\n\n3.  **Per-step Phase Error:**\n    This is the difference between the discrete and continuous phase advance per step: $\\theta - \\Omega_c \\Delta t = 2 \\arctan(\\frac{\\Omega_c \\Delta t}{2}) - \\Omega_c \\Delta t$.\n\n4.  **$\\Delta t$ Constraint Check:**\n    A boolean value indicating if $\\Delta t \\leq \\Delta t_{\\max}(\\eta, \\Omega_c)$, where $\\Delta t_{\\max}$ is the derived upper bound.\n\n5.  **Derived Upper Bound $\\Delta t_{\\max}$:**\n    The calculated value $\\Delta t_{\\max}(\\eta, \\Omega_c) = \\frac{\\sqrt{12\\eta}}{\\Omega_c}$.\n\n6.  **End-of-Period Position Error:**\n    We simulate the particle motion for one physical cyclotron period, $T_c$. The number of steps is $N = T_c/\\Delta t = 1/f$, which is an integer for all test cases. The exact final position after one period is the initial position, $\\mathbf{x}_{\\text{exact}}(T_c) = \\mathbf{x}(0)$. The numerical final position, $\\mathbf{x}^N$, is computed by iterating the velocity and position updates.\n    - Velocity update (clockwise rotation by $\\theta$):\n      $$ \\begin{pmatrix} v_x^{k+1} \\\\ v_y^{k+1} \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta \\end{pmatrix} \\begin{pmatrix} v_x^k \\\\ v_y^k \\end{pmatrix} $$\n    - Position update (trapezoidal rule):\n      $$ \\mathbf{x}^{k+1} = \\mathbf{x}^{k} + \\frac{\\Delta t}{2}(\\mathbf{v}^k + \\mathbf{v}^{k+1}) $$\n    We start with $\\mathbf{x}^0 = \\mathbf{x}(0)$ and $\\mathbf{v}^0 = \\mathbf{v}(0)$ and iterate $N$ times. The final position error is the Euclidean distance $\\|\\mathbfx^N - \\mathbf{x}(0)\\|$. A direct iterative calculation is performed, as it is robust and computationally inexpensive for the small values of $N$ in the test cases.\n\nThe following Python code implements this procedure to compute the required metrics for the four given test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the particle-in-cell accuracy problem for a single electron\n    gyrating in a uniform magnetic field.\n    \"\"\"\n    # Physical constants\n    Q_E = 1.602176634e-19  # Electron charge magnitude in C\n    M_E = 9.1093837015e-31 # Electron mass in kg\n\n    # Test suite parameters\n    B_MAG = 5.0             # Magnetic field magnitude in T\n    V_PERP = 1.0e5          # Perpendicular speed in m/s\n\n    test_cases = [\n        (0.05, 0.01),\n        (0.25, 0.01),\n        (0.50, 0.05),\n        (1.00, 0.01)\n    ]\n\n    results = []\n\n    # Derived physical quantities\n    omega_c = (Q_E * B_MAG) / M_E\n    T_c = 2.0 * np.pi / omega_c\n    r_L = V_PERP / omega_c\n\n    # Initial conditions\n    x0 = np.array([r_L, 0.0, 0.0])\n    v0 = np.array([0.0, V_PERP, 0.0])\n\n    for f, eta in test_cases:\n        # Simulation parameters for the current case\n        dt = f * T_c\n        num_steps = int(round(1.0 / f))\n\n        # Argument for arctan\n        arg_tan = omega_c * dt / 2.0\n\n        # Discrete phase advance per step\n        theta = 2.0 * np.arctan(arg_tan)\n\n        # Numerical cyclotron frequency\n        omega_num = theta / dt\n\n        # --- Metric 1: Relative numerical cyclotron frequency error ---\n        rel_freq_error = omega_num / omega_c - 1.0\n\n        # --- Metric 2: Relative numerical period error ---\n        rel_period_error = omega_c / omega_num - 1.0\n\n        # --- Metric 3: Per-step phase error ---\n        phase_error_per_step = theta - omega_c * dt\n        \n        # --- Metric 5: Derived upper bound dt_max ---\n        dt_max = np.sqrt(12.0 * eta) / omega_c\n        \n        # --- Metric 4: dt constraint check ---\n        is_constraint_met = dt = dt_max\n\n        # --- Metric 6: End-of-period position error ---\n        # Initialize numerical position and velocity\n        x_num = np.copy(x0[:2]) # Use 2D vectors for simulation\n        v_num = np.copy(v0[:2])\n\n        # Rotation matrix components for clockwise rotation by theta\n        cos_theta = np.cos(theta)\n        sin_theta = np.sin(theta)\n\n        # Perform simulation for one physical period\n        for _ in range(num_steps):\n            v_old = np.copy(v_num)\n            \n            # Boris velocity update (rotation)\n            v_num[0] = v_old[0] * cos_theta + v_old[1] * sin_theta\n            v_num[1] = -v_old[0] * sin_theta + v_old[1] * cos_theta\n            \n            # Trapezoidal position update\n            x_num += 0.5 * dt * (v_old + v_num)\n\n        # Calculate final position error\n        pos_error = np.linalg.norm(x_num - x0[:2])\n\n        # Append results for the current case\n        results.extend([\n            rel_freq_error,\n            rel_period_error,\n            phase_error_per_step,\n            is_constraint_met,\n            dt_max,\n            pos_error\n        ])\n    \n    # Format the final output string\n    output_str = f\"[{','.join(f'{r:.8e}' if isinstance(r, float) else str(r) for r in results)}]\"\n    # Special formatting to match bool 'True'/'False' conventions\n    output_str = output_str.replace(\"True\", \"True\").replace(\"False\", \"False\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "As particles move, they create currents that act as sources for the electromagnetic fields. A naive calculation of these currents can lead to a violation of the discrete continuity equation, $\\nabla \\cdot \\mathbf{J} + \\partial \\rho / \\partial t = 0$, causing unphysical charge to appear or disappear. This practice  guides you through implementing the Esirkepov method, a sophisticated and elegant current-deposition scheme that guarantees exact charge conservation. Completing this exercise provides hands-on experience with a critical algorithm that ensures the mathematical self-consistency and physical validity of a modern PIC simulation.",
            "id": "4027253",
            "problem": "Consider a one-dimensional, periodic, electrostatic Particle-In-Cell (PIC) scheme for a single spatial dimension $x \\in [0,L)$ with $N$ uniform grid cells of width $\\Delta x = L/N$, and fields and sources staggered on a Yee-type grid: charge density $\\rho$ at cell centers and current density $J$ at faces. The objective is to implement a semi-implicit PIC step with a predictor–corrector scheme for current deposition, using an Esirkepov-type update that guarantees discrete charge conservation. All quantities are in normalized units, so $L$, $\\Delta x$, time step $\\Delta t$, charge $q$, mass $m$, and vacuum permittivity $\\varepsilon_0$ are dimensionless.\n\nFundamental base:\n- The discrete continuity equation follows from Maxwell’s equations and charge conservation, requiring that for each cell center index $i$,\n$$\\rho_i^{n+1} - \\rho_i^n + \\Delta t \\, \\frac{J_{i+1/2}^{n+1/2} - J_{i-1/2}^{n+1/2}}{\\Delta x} = 0,$$\nwhere superscripts denote time levels and subscripts denote staggered spatial indices. This is the discrete statement of $\\partial \\rho / \\partial t + \\nabla \\cdot J = 0$.\n- Particles obey Newton’s second law for electrostatics: for each particle $p$ with position $x_p$ and velocity $v_p$, the force is $F_p = q_p E(x_p)$ and $\\mathrm{d}v_p/\\mathrm{d}t = (q_p/m_p) E(x_p)$ with $\\mathrm{d}x_p/\\mathrm{d}t = v_p$.\n- A predictor–corrector semi-implicit step centers the particle velocity update at the half time step using a field predicted from an intermediate current. The current deposition must be integrated along the particle trajectory between $x_p^n$ and $x_p^{n+1}$ so that the discrete continuity equation is satisfied exactly.\n\nDefinitions:\n- Particle-In-Cell (PIC) computes charge and current from particle motion on a mesh via a shape function, solves fields on the mesh, and interpolates fields back to particle positions.\n- Esirkepov-type charge-conserving current deposition constructs the current by integrating along the particle path between time levels so that the discrete continuity equation is satisfied for the chosen grid staggering and shape functions.\n- Nearest Grid Point (NGP) assigns particle charge to the nearest cell center; for current deposition, the integrated flux across faces is attributed to those faces the particle crosses.\n\nTask:\n- Implement a one-dimensional semi-implicit PIC update with a predictor–corrector scheme:\n  1. Predictor: Using $E^n$ and positions $x_p^n$, compute predicted half-step velocities $v_{p}^{n+1/2,\\ast}$ and predicted positions $x_p^{\\ast}$ after one full time step, and deposit a predicted current $J^{\\ast}$ at faces by integrating particle flux along the path from $x_p^n$ to $x_p^{\\ast}$ using an Esirkepov-type update consistent with the chosen shape model and grid staggering.\n  2. Field prediction: Compute $E^{n+1/2}$ semi-implicitly from $E^n$ and $J^{\\ast}$ via a centered update consistent with Ampère’s law in the electrostatic limit.\n  3. Corrector: Using $E^{n+1/2}$, compute corrected half-step velocities $v_{p}^{n+1/2}$ and corrected end positions $x_p^{n+1}$, and deposit the final current $J^{n+1/2}$ by integrating particle flux along the path from $x_p^n$ to $x_p^{n+1}$ with the same Esirkepov-type update.\n  4. Deposit $\\rho^n$ and $\\rho^{n+1}$ at cell centers from particle positions at times $t^n$ and $t^{n+1}$.\n  5. Compute, for each cell $i$, the discrete continuity residual\n  $$r_i = \\rho_i^{n+1} - \\rho_i^n + \\Delta t \\, \\frac{J_{i+1/2}^{n+1/2} - J_{i-1/2}^{n+1/2}}{\\Delta x},$$\n  and report the maximum absolute residual $\\max_i |r_i|$.\n\nAlgorithmic constraints:\n- Use a periodic domain and the Yee staggering described above.\n- Use a shape consistent for both charge and current deposition. You must integrate the current along particle trajectories so that the discrete continuity equation holds to numerical precision. For charge deposition, use Nearest Grid Point (NGP) to cell centers. For current deposition, use a trajectory-based Esirkepov-type update that assigns to each face crossed by a particle an appropriate contribution proportional to the charge transported across the face over the time step, with sign determined by direction of motion. This guarantees discrete charge conservation when combined with NGP.\n- Use a single semi-implicit field predictor that centers the field update at the half time step by using the predicted current. You may assume the electrostatic limit for the field update.\n\nNumerical units:\n- All quantities are dimensionless and normalized; there are no physical units in this problem. Report all numerical answers as dimensionless floating-point numbers.\n\nTest suite:\nImplement the program to run the following five test cases. Each test defines $L$, $N$, $\\Delta t$, arrays of particle positions $\\{x_p^n\\}$, velocities $\\{v_p^n\\}$, charges $\\{q_p\\}$, and masses $\\{m_p\\}$ at time $t^n$, and initializes $E^n$ to zero at faces. For each test, perform one full predictor–corrector step and compute the single scalar $\\max_i |r_i|$.\n\n- Test $1$ (happy path, small displacements): $L = 1$, $N = 16$, $\\Delta t = 0.1$, one species with $q_p = +1$ and $m_p = 1$ for all particles, particles at positions $\\{0.1, 0.3, 0.55, 0.9\\}$ and velocities $\\{0.05, -0.03, 0.02, -0.04\\}$.\n- Test $2$ (multi-face crossings): $L = 1$, $N = 16$, $\\Delta t = 0.6$, one species with $q_p = +1$ and $m_p = 1$, particles at positions $\\{0.05, 0.95\\}$ and velocities $\\{0.9, -0.9\\}$.\n- Test $3$ (periodic boundary wrap-around): $L = 1$, $N = 16$, $\\Delta t = 0.4$, one species with $q_p = +1$ and $m_p = 1$, particles at positions $\\{0.93, 0.02\\}$ and velocities $\\{0.3, -0.25\\}$.\n- Test $4$ (stationary particles): $L = 1$, $N = 16$, $\\Delta t = 0.2$, one species with $q_p = +1$ and $m_p = 1$, particles at positions $\\{0.1, 0.4, 0.7\\}$ and velocities $\\{0, 0, 0\\}$.\n- Test $5$ (two-species current cancellation): $L = 1$, $N = 16$, $\\Delta t = 0.2$, two species with charges $\\{+1, +1, -1, -1\\}$ and masses all $1$, particles at positions $\\{0.125, 0.375, 0.625, 0.875\\}$ and velocities $\\{0.2, 0.2, 0.2, 0.2\\}$.\n\nOutput requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the five tests in order, for example, $[r_1,r_2,r_3,r_4,r_5]$, where each $r_k$ is the computed maximum absolute residual for test $k$ as a floating-point number.",
            "solution": "The user has provided a problem statement that requires the implementation and verification of a one-dimensional, semi-implicit, charge-conserving Particle-In-Cell (PIC) algorithm. The first step is to validate the problem statement.\n\n### Step 1: Extract Givens\n- **Domain**: One-dimensional, periodic, $x \\in [0,L)$.\n- **Grid**: $N$ uniform cells, cell width $\\Delta x = L/N$.\n- **Staggering**: Yee-type. Charge density $\\rho$ at cell centers $x_i = (i+0.5)\\Delta x$. Current density $J$ and Electric field $E$ at cell faces $x_j = j\\Delta x$.\n- **Governing Equations**:\n    1.  Discrete continuity equation: $\\rho_i^{n+1} - \\rho_i^n + \\Delta t \\, \\frac{J_{i+1/2}^{n+1/2} - J_{i-1/2}^{n+1/2}}{\\Delta x} = 0$.\n    2.  Particle equations of motion: $\\mathrm{d}x_p/\\mathrm{d}t = v_p$, $\\mathrm{d}v_p/\\mathrm{d}t = (q_p/m_p) E(x_p)$.\n- **Shape function**: Nearest Grid Point (NGP) for charge deposition.\n- **Current deposition**: Esirkepov-type, trajectory-integrated, charge-conserving scheme consistent with NGP.\n- **Algorithm**: A single predictor-corrector step.\n    1.  **Predictor**: From $(x_p^n, v_p^n, E^n)$, compute predicted velocity $v_p^{n+1/2, \\ast}$, predicted position $x_p^{\\ast}$, and predicted current $J^{\\ast}$.\n    2.  **Field prediction**: From $E^n$ and $J^{\\ast}$, compute $E^{n+1/2}$ using a centered, semi-implicit update in the electrostatic limit.\n    3.  **Corrector**: From $(x_p^n, v_p^n)$ and $E^{n+1/2}$, compute corrected velocity $v_p^{n+1/2}$, corrected position $x_p^{n+1}$, and final current $J^{n+1/2}$.\n    4.  **Charge deposition**: Compute $\\rho^n$ and $\\rho^{n+1}$ from particle positions $x_p^n$ and $x_p^{n+1}$.\n    5.  **Verification**: Compute the maximum absolute continuity residual, $\\max_i |r_i|$.\n- **Initial Conditions**: For all tests, $E^n = \\mathbf{0}$.\n- **Test Cases**: Five distinct sets of parameters ($L, N, \\Delta t$) and particle data ($\\{x_p^n\\}, \\{v_p^n\\}, \\{q_p\\}, \\{m_p\\}$) are provided.\n- **Output**: A single list of the five computed maximum absolute residuals.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem describes a standard PIC method, a cornerstone of computational plasma physics. The predictor-corrector approach, Yee grid, and Esirkepov current deposition are all well-established, scientifically sound concepts. The governing equations are fundamental.\n- **Well-Posed**: The problem provides all necessary parameters, initial conditions, and a clear algorithmic structure. The task is to compute a well-defined numerical quantity. A unique, stable, and meaningful result (the charge-conservation residual, which should be near zero) is expected.\n- **Objective**: The problem is formulated with precise, unambiguous mathematical and algorithmic terms. The test cases are objective and computationally verifiable.\n\nThe problem does not exhibit any of the invalidity flaws:\n1.  It is scientifically sound.\n2.  It is a formalizable problem central to the specified topic.\n3.  It is self-contained. The ambiguity in \"semi-implicit ... centered update\" for the field is resolved by the standard practice in such schemes, which is to advance the field by a half-step using the predicted current. Given the provided inputs and required outputs for each substep, this interpretation is unique and consistent.\n4.  The test cases are numerically feasible and designed to test specific aspects of the algorithm (e.g., boundary-crossing, multi-cell travel).\n5.  The problem is well-structured and leads to a unique numerical result.\n6.  The problem is not trivial; it requires a careful and correct implementation of a non-trivial algorithm (Esirkepov deposition).\n7.  The result is scientifically verifiable through independent implementation.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Principle-Based Design and Solution\n\nThe core of the problem is to implement a single step of a particle-in-cell (PIC) simulation and verify that the implementation respects the discrete charge continuity equation. This is achieved by using a specific \"charge-conserving\" current deposition scheme, namely the Esirkepov method.\n\n**1. Grid and Quantities**\n- The domain of length $L$ is divided into $N$ cells of width $\\Delta x = L/N$.\n- Cell $i$ covers the spatial region $[i\\Delta x, (i+1)\\Delta x)$. Its center is at $(i+0.5)\\Delta x$.\n- Faces are located at positions $j\\Delta x$ for $j \\in \\{0, 1, ..., N-1\\}$. Due to periodicity, face $N$ is identical to face $0$.\n- Charge density $\\rho_i$ is defined at cell centers. For NGP, $\\rho_i = \\frac{1}{\\Delta x} \\sum_{p \\in \\text{cell } i} q_p$.\n- Current $J_j$ and electric field $E_j$ are defined at faces. The problem uses the symbol $J$ for current density, but in a 1D context, this is equivalent to current (charge per unit time), as confirmed by the units of the continuity equation. Thus, $J \\sim q/\\Delta t$.\n\n**2. Predictor-Corrector Algorithm**\n\n**Step A: Initial State ($t=t^n$)**\nWe are given particle positions $x_p^n$, velocities $v_p^n$, and field $E^n=0$. The initial charge density $\\rho^n$ is calculated by depositing particle charges onto the grid using the NGP scheme.\n\n**Step B: Predictor Stage**\nThe goal is to obtain a predicted current $J^\\ast$ to estimate the field at the half-time-step, $E^{n+1/2}$.\n1.  **Particle Push (Prediction)**: We first predict the particle trajectories. A standard leapfrog-like half-step gives a predicted velocity at $t^{n+1/2}$. Since $E^n(x_p^n) = 0$, the velocity is unchanged initially.\n    $$v_{p}^{n+1/2, \\ast} = v_p^n + \\frac{q_p}{m_p} E^n(x_p^n) \\frac{\\Delta t}{2} = v_p^n$$\n    The predicted position at $t^{n+1}$ is then found by advancing $x_p^n$ for a full time step $\\Delta t$ using this predicted velocity.\n    $$x_p^{\\ast} = x_p^n + v_{p}^{n+1/2, \\ast} \\Delta t = x_p^n + v_p^n \\Delta t$$\n2.  **Current Deposition (Prediction)**: The predicted current $J^\\ast$ is deposited using the Esirkepov scheme. For each particle, we trace its (unwrapped) trajectory from $x_p^n$ to $x_p^\\ast$. For every grid face the particle trajectory crosses, a current of $q_p/\\Delta t$ is added to that face's total current (with sign depending on direction). This method guarantees that the change in charge in any cell, as determined by NGP, is exactly balanced by the net current flux into that cell.\n\n**Step C: Field Prediction**\nThe semi-implicit field update is based on Ampère's law in the electrostatic limit, $\\partial E / \\partial t = -J/\\varepsilon_0$. With normalized units ($\\varepsilon_0=1$), we have $\\partial E / \\partial t = -J$. A centered, half-step update for $E$ using the predicted current $J^\\ast$ is:\n$$E_j^{n+1/2} = E_j^n - J_j^{\\ast} \\frac{\\Delta t}{2}$$\nSince $E^n=0$, this simplifies to $E_j^{n+1/2} = - J_j^{\\ast} \\Delta t / 2$.\n\n**Step D: Corrector Stage**\nThis stage refines the particle kinematics using the predicted field $E^{n+1/2}$.\n1.  **Particle Push (Correction)**: The velocity is updated from $t^n$ to $t^{n+1/2}$. This requires the field $E^{n+1/2}$ at the particle position $x_p^n$. Consistency with NGP charge deposition implies a 0th-order field interpolation. We first compute a cell-centered field $E_{c,i}^{n+1/2} = (E_i^{n+1/2} + E_{i+1}^{n+1/2})/2$ and then apply this field to all particles within cell $i$.\n    $$v_p^{n+1/2} = v_p^n + \\frac{q_p}{m_p} E^{n+1/2}(x_p^n) \\frac{\\Delta t}{2}$$\n    The particle position is then advanced to $t^{n+1}$ using this corrected half-step velocity.\n    $$x_p^{n+1} = x_p^n + v_p^{n+1/2} \\Delta t$$\n    Particle positions are wrapped into the domain $[0, L)$ using the modulo operator.\n2.  **Current Deposition (Correction)**: The final current for the time step, $J^{n+1/2}$, is deposited using the same Esirkepov scheme, but this time along the corrected trajectory from $x_p^n$ to $x_p^{n+1}$.\n\n**Step E: Final State ($t=t^{n+1}$)**\nThe final charge density, $\\rho^{n+1}$, is calculated by depositing all particles at their final positions, $x_p^{n+1}$, onto the grid using the NGP scheme.\n\n**Step F: Verification**\nThe explicit purpose of the Esirkepov scheme is to satisfy the discrete continuity equation. We verify this by computing the residual for each cell $i$:\n$$r_i = \\rho_i^{n+1} - \\rho_i^n + \\Delta t \\, \\frac{J_{i+1}^{n+1/2} - J_i^{n+1/2}}{\\Delta x}$$\nThe indices for $J$ correspond to the faces bounding cell $i$. The maximum absolute residual, $\\max_i |r_i|$, should be zero to within machine floating-point precision, confirming the charge-conserving property of the algorithm.",
            "answer": "```python\nimport numpy as np\n\ndef _calculate_residual(L, N, dt, x_n, v_n, q, m):\n    \"\"\"\n    Performs one semi-implicit predictor-corrector PIC step and calculates\n    the maximum absolute continuity residual.\n\n    Args:\n        L (float): Length of the periodic domain.\n        N (int): Number of grid cells.\n        dt (float): Time step.\n        x_n (list): Initial particle positions.\n        v_n (list): Initial particle velocities.\n        q (list): Particle charges.\n        m (list): Particle masses.\n\n    Returns:\n        float: The maximum absolute value of the continuity equation residual.\n    \"\"\"\n    dx = L / N\n    num_particles = len(x_n)\n\n    # Convert initial lists to numpy arrays for vectorized operations\n    x_n = np.array(x_n, dtype=np.float64)\n    v_n = np.array(v_n, dtype=np.float64)\n    q = np.array(q, dtype=np.float64)\n    m = np.array(m, dtype=np.float64)\n\n    # Step A: Initial Charge Deposition (rho^n)\n    # rho is charge density, defined at cell centers.\n    rho_n = np.zeros(N, dtype=np.float64)\n    for p in range(num_particles):\n        cell_idx = int(np.floor(x_n[p] / dx))\n        rho_n[cell_idx % N] += q[p] / dx\n\n    # Initial E-field is zero at faces.\n    E_n = np.zeros(N, dtype=np.float64)\n\n    # Step B: Predictor\n    # 1. Interpolate E-field to particles. Since E_n is zero, this is trivial.\n    E_interp_pred = np.zeros(num_particles, dtype=np.float64)\n\n    # 2. Predict velocity and position\n    v_n_half_star = v_n + (q / m) * E_interp_pred * (dt / 2.0)\n    x_star_unwrapped = x_n + v_n_half_star * dt\n\n    # 3. Deposit predicted current J* using Esirkepov method\n    J_star = np.zeros(N, dtype=np.float64)\n    for p in range(num_particles):\n        charge_flux = q[p] / dt\n        cell_start_idx = int(np.floor(x_n[p] / dx))\n        cell_end_idx = int(np.floor(x_star_unwrapped[p] / dx))\n\n        if v_n_half_star[p] > 0:\n            for k in range(cell_start_idx, cell_end_idx):\n                face_idx = (k + 1) % N\n                J_star[face_idx] += charge_flux\n        elif v_n_half_star[p]  0:\n            for k in range(cell_end_idx, cell_start_idx):\n                face_idx = (k + 1) % N\n                J_star[face_idx] -= charge_flux\n\n    # Step C: Field Prediction\n    # E^{n+1/2} = E^n - J* * dt/2 (with eps0=1)\n    E_n_half = E_n - J_star * (dt / 2.0)\n\n    # Step D: Corrector\n    # 1. Interpolate E^{n+1/2} to particle positions x^n\n    E_interp_corr = np.zeros(num_particles, dtype=np.float64)\n    for p in range(num_particles):\n        cell_idx = int(np.floor(x_n[p] / dx))\n        # Field at cell center is average of fields at bracketing faces\n        E_left_face = E_n_half[cell_idx % N]\n        E_right_face = E_n_half[(cell_idx + 1) % N]\n        E_interp_corr[p] = (E_left_face + E_right_face) / 2.0\n\n    # 2. Compute corrected velocities and positions\n    v_n_half = v_n + (q / m) * E_interp_corr * (dt / 2.0)\n    x_n_plus_1_unwrapped = x_n + v_n_half * dt\n    x_n_plus_1 = np.mod(x_n_plus_1_unwrapped, L)\n\n    # 3. Deposit final current J^{n+1/2}\n    J_n_half = np.zeros(N, dtype=np.float64)\n    for p in range(num_particles):\n        charge_flux = q[p] / dt\n        cell_start_idx = int(np.floor(x_n[p] / dx))\n        cell_end_idx = int(np.floor(x_n_plus_1_unwrapped[p] / dx))\n        \n        if v_n_half[p] > 0:\n            for k in range(cell_start_idx, cell_end_idx):\n                face_idx = (k + 1) % N\n                J_n_half[face_idx] += charge_flux\n        elif v_n_half[p]  0:\n            for k in range(cell_end_idx, cell_start_idx):\n                face_idx = (k + 1) % N\n                J_n_half[face_idx] -= charge_flux\n\n    # Step E: Final Charge Deposition (rho^{n+1})\n    rho_n_plus_1 = np.zeros(N, dtype=np.float64)\n    for p in range(num_particles):\n        cell_idx = int(np.floor(x_n_plus_1[p] / dx))\n        rho_n_plus_1[cell_idx % N] += q[p] / dx\n\n    # Step F: Compute Discrete Continuity Residual\n    residuals = np.zeros(N, dtype=np.float64)\n    for i in range(N):\n        # For cell i, faces are i and i+1.\n        J_right = J_n_half[(i + 1) % N]\n        J_left = J_n_half[i]\n        \n        div_J = (J_right - J_left) / dx\n        residuals[i] = (rho_n_plus_1[i] - rho_n[i]) + dt * div_J\n    \n    return np.max(np.abs(residuals))\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test 1 (happy path, small displacements)\n        {'L': 1.0, 'N': 16, 'dt': 0.1, \n         'x_n': [0.1, 0.3, 0.55, 0.9], \n         'v_n': [0.05, -0.03, 0.02, -0.04], \n         'q': [1.0, 1.0, 1.0, 1.0], \n         'm': [1.0, 1.0, 1.0, 1.0]},\n        # Test 2 (multi-face crossings)\n        {'L': 1.0, 'N': 16, 'dt': 0.6, \n         'x_n': [0.05, 0.95],\n         'v_n': [0.9, -0.9],\n         'q': [1.0, 1.0],\n         'm': [1.0, 1.0]},\n        # Test 3 (periodic boundary wrap-around)\n        {'L': 1.0, 'N': 16, 'dt': 0.4,\n         'x_n': [0.93, 0.02],\n         'v_n': [0.3, -0.25],\n         'q': [1.0, 1.0],\n         'm': [1.0, 1.0]},\n        # Test 4 (stationary particles)\n        {'L': 1.0, 'N': 16, 'dt': 0.2,\n         'x_n': [0.1, 0.4, 0.7],\n         'v_n': [0.0, 0.0, 0.0],\n         'q': [1.0, 1.0, 1.0],\n         'm': [1.0, 1.0, 1.0]},\n        # Test 5 (two-species current cancellation)\n        {'L': 1.0, 'N': 16, 'dt': 0.2,\n         'x_n': [0.125, 0.375, 0.625, 0.875],\n         'v_n': [0.2, 0.2, 0.2, 0.2],\n         'q': [1.0, 1.0, -1.0, -1.0],\n         'm': [1.0, 1.0, 1.0, 1.0]}\n    ]\n\n    results = []\n    for case in test_cases:\n        max_residual = _calculate_residual(\n            case['L'], case['N'], case['dt'],\n            case['x_n'], case['v_n'], case['q'], case['m']\n        )\n        results.append(max_residual)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "With the core components of the particle pusher and field-particle coupling in place, a critical final step is to verify the behavior of the simulation as a whole. A robust PIC code must respect the fundamental conservation laws of physics. This practice  focuses on implementing diagnostics to monitor the total energy of the system—the sum of electric field, magnetic field, and relativistic particle kinetic energies. Tracking energy conservation is the most important validation test for a simulation, allowing you to detect numerical instabilities and ensure the physical integrity of your results.",
            "id": "4027302",
            "problem": "You are to implement diagnostics for a one-dimensional periodic Particle-In-Cell (PIC) plasma simulation to compute discrete field energy and particle kinetic energy at each time step, and to verify discrete energy conservation over time. The program must be self-contained and produce a single line of output as specified below. All quantities are to be handled in the International System of Units (SI). Angles in trigonometric functions must be interpreted in radians.\n\nThe physical and numerical setting is a one-dimensional domain of length $L$ with $N_x$ uniformly spaced grid points and periodic boundary conditions. Electromagnetic fields are given as arrays sampled on this grid over a sequence of $N_t$ time steps. Particles are represented by their velocities over time. The discrete diagnostics must return the maximum relative drift of the total energy over the simulation time series.\n\nFundamental base and core definitions:\n- Maxwell's equations in vacuum, expressed in terms of the electric field $\\mathbf{E}$ and magnetic field $\\mathbf{B}$, and the charge and current densities $\\rho$ and $\\mathbf{J}$, lead, via the Poynting theorem, to the continuous energy conservation law:\n$$\n\\frac{\\partial}{\\partial t}\\left(\\frac{\\varepsilon_0}{2}\\|\\mathbf{E}\\|^2 + \\frac{1}{2\\mu_0}\\|\\mathbf{B}\\|^2\\right) + \\nabla\\cdot\\left(\\frac{1}{\\mu_0}\\mathbf{E}\\times\\mathbf{B}\\right) = -\\mathbf{E}\\cdot\\mathbf{J}.\n$$\nWith periodic boundaries, the domain integral of the divergence term vanishes, and electric work on charges transfers energy between fields and particles. The relativistic kinetic energy of particle $i$ of mass $m_i$ and speed $v_i$ is given by\n$$\nK_i = m_i c^2(\\gamma_i - 1),\\quad \\gamma_i = \\frac{1}{\\sqrt{1 - \\frac{v_i^2}{c^2}}}.\n$$\nIn the one-dimensional setting described, the discrete field energies at time step $n$ must be computed as Riemann sums over the grid:\n$$\nU_E^{(n)} = \\frac{\\varepsilon_0}{2}\\sum_{j=0}^{N_x-1} E_{j}^{(n)2}\\,\\Delta x,\\quad\nU_B^{(n)} = \\frac{1}{2\\mu_0}\\sum_{j=0}^{N_x-1} B_{j}^{(n)2}\\,\\Delta x,\n$$\nwhere $\\Delta x = L/N_x$, and $E_j^{(n)}$ and $B_j^{(n)}$ are the field samples at grid point $j$ and time step $n$. The discrete particle kinetic energy at time step $n$ must be computed as\n$$\nU_K^{(n)} = \\sum_{i=1}^{N_p} m_i c^2\\left(\\frac{1}{\\sqrt{1 - \\frac{v_i^{(n)2}}{c^2}}} - 1\\right),\n$$\nwhere $N_p$ is the number of particles and $v_i^{(n)}$ is the speed of particle $i$ at time step $n$. The total energy at time step $n$ is\n$$\nU_{\\text{tot}}^{(n)} = U_E^{(n)} + U_B^{(n)} + U_K^{(n)}.\n$$\nThe diagnostic must compute the maximum relative drift over the time series, defined for a nonzero initial total energy $U_{\\text{tot}}^{(0)}$ as\n$$\n\\delta = \\frac{\\max_n U_{\\text{tot}}^{(n)} - \\min_n U_{\\text{tot}}^{(n)}}{U_{\\text{tot}}^{(0)}}.\n$$\nIf $U_{\\text{tot}}^{(0)} = 0$, define $\\delta = 0$.\n\nImplement the following test suite. For each case, construct the indicated arrays of fields and particle velocities, compute $\\delta$ as defined above, and add it to the output list.\n\nConstants to use in all cases:\n- Speed of light: $c = 299{,}792{,}458\\ \\mathrm{m/s}$.\n- Vacuum permeability: $\\mu_0 = 4\\pi\\times10^{-7}\\ \\mathrm{H/m}$.\n- Vacuum permittivity: $\\varepsilon_0 = 1/(\\mu_0 c^2)\\ \\mathrm{F/m}$.\n\nTest Suite:\n1. Vacuum standing wave, no particles (happy path, field energy exchange without particle energy):\n   - Domain length: $L = 1.0\\ \\mathrm{m}$.\n   - Grid points: $N_x = 256$, $\\Delta x = L/N_x$.\n   - Time steps: $N_t = 100$.\n   - Electric field amplitude: $E_0 = 1.0\\times10^3\\ \\mathrm{V/m}$.\n   - Wavenumber: $k = 2\\pi/L$.\n   - Angular frequency: $\\omega = c k$.\n   - Period: $T = 2\\pi/\\omega$.\n   - Time step: $\\Delta t = T/N_t$.\n   - For $n=0,\\dots,N_t-1$, $t_n = n\\Delta t$; for $j=0,\\dots,N_x-1$, $x_j = j\\Delta x$.\n   - Fields:\n     $$\n     E_j^{(n)} = E_0\\cos(k x_j)\\cos(\\omega t_n),\\quad B_j^{(n)} = \\frac{E_0}{c}\\cos(k x_j)\\sin(\\omega t_n).\n     $$\n   - No particles: $N_p = 0$.\n\n2. Zero fields and zero particles (boundary case with identically zero energy):\n   - Domain length: $L = 1.0\\ \\mathrm{m}$.\n   - Grid points: $N_x = 32$.\n   - Time steps: $N_t = 10$.\n   - Fields: $E_j^{(n)} = 0$, $B_j^{(n)} = 0$ for all $j,n$.\n   - No particles: $N_p = 0$.\n\n3. Particles only, constant velocities, no fields (particle energy constant):\n   - Domain length: $L = 1.0\\ \\mathrm{m}$.\n   - Grid points: $N_x = 16$.\n   - Time steps: $N_t = 50$.\n   - Fields: $E_j^{(n)} = 0$, $B_j^{(n)} = 0$ for all $j,n$.\n   - Particles: $N_p = 2$.\n   - Masses: $m_1 = 9.10938356\\times10^{-31}\\ \\mathrm{kg}$ (electron), $m_2 = 3.34358372\\times10^{-27}\\ \\mathrm{kg}$ (deuteron).\n   - Velocities: $v_1^{(n)} = 1.0\\times10^5\\ \\mathrm{m/s}$, $v_2^{(n)} = 2.0\\times10^5\\ \\mathrm{m/s}$ for all $n$.\n\n4. Slowly drifting field amplitudes, no particles (edge case producing measurable energy drift):\n   - Domain length: $L = 1.0\\ \\mathrm{m}$.\n   - Grid points: $N_x = 256$, $\\Delta x = L/N_x$.\n   - Time steps: $N_t = 100$.\n   - Electric field amplitude: $E_0 = 1.0\\times10^3\\ \\mathrm{V/m}$.\n   - Wavenumber: $k = 2\\pi/L$.\n   - Angular frequency: $\\omega = c k$.\n   - Period: $T = 2\\pi/\\omega$.\n   - Time step: $\\Delta t = T/N_t$.\n   - Time-varying amplitude factor: $f_n = 1 - \\alpha\\frac{n}{N_t - 1}$ with $\\alpha = 0.02$.\n   - For $n=0,\\dots,N_t-1$, $t_n = n\\Delta t$; for $j=0,\\dots,N_x-1$, $x_j = j\\Delta x$.\n   - Fields:\n     $$\n     E_j^{(n)} = f_n\\,E_0\\cos(k x_j)\\cos(\\omega t_n),\\quad B_j^{(n)} = \\frac{E_0}{c}\\cos(k x_j)\\sin(\\omega t_n).\n     $$\n   - No particles: $N_p = 0$.\n\nRequired outputs:\n- For each test case, compute the maximum relative drift $\\delta$ of the total energy over all time steps as defined above.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\").\n- Each result must be a floating-point number rounded to eight decimal places.\n\nAll computations must be performed in SI units, and all trigonometric arguments are in radians. The program must not read any input, and must use only the standard libraries and the specified numerical libraries. The program should implement the diagnostics and evaluate them on the given test suite, outputting a single line in the specified format.",
            "solution": "The energy diagnostics in a Particle-In-Cell (PIC) simulation arise from the Poynting theorem and relativistic particle mechanics. The goal is to compute the discrete electric field energy, magnetic field energy, and particle kinetic energy at each time step and to verify energy conservation by measuring the drift of total energy over time.\n\nPrinciple-based derivation:\n1. Starting from Maxwell's equations in vacuum and the Lorentz force law, one finds the Poynting theorem,\n$$\n\\frac{\\partial}{\\partial t}\\left(\\frac{\\varepsilon_0}{2}\\|\\mathbf{E}\\|^2 + \\frac{1}{2\\mu_0}\\|\\mathbf{B}\\|^2\\right) + \\nabla\\cdot\\left(\\frac{1}{\\mu_0}\\mathbf{E}\\times\\mathbf{B}\\right) = -\\mathbf{E}\\cdot\\mathbf{J}.\n$$\nIntegrating over a periodic domain removes the divergence term due to zero net flux, and the right-hand side represents the work done by the electric field on charges, transferring energy to particle kinetic energy. In the absence of external sources and with perfect current deposition, the total energy should be conserved.\n\n2. In a one-dimensional discretization with uniform spacing $\\Delta x$, the domain integrals become Riemann sums. At each time step $n$, define\n$$\nU_E^{(n)} = \\frac{\\varepsilon_0}{2}\\sum_{j=0}^{N_x-1} E_{j}^{(n)2}\\,\\Delta x,\\quad\nU_B^{(n)} = \\frac{1}{2\\mu_0}\\sum_{j=0}^{N_x-1} B_{j}^{(n)2}\\,\\Delta x.\n$$\nThese are discrete approximations to the continuous field energies $\\frac{\\varepsilon_0}{2}\\int E^2\\,dx$ and $\\frac{1}{2\\mu_0}\\int B^2\\,dx$ on the uniform grid.\n\n3. Particle kinetic energy must be computed relativistically to ensure consistency with high-speed motion that can occur in plasma simulations. For each particle $i$ with mass $m_i$ and speed $v_i^{(n)}$ at time step $n$,\n$$\nK_i^{(n)} = m_i c^2\\left(\\gamma_i^{(n)} - 1\\right),\\quad \\gamma_i^{(n)} = \\frac{1}{\\sqrt{1 - \\frac{v_i^{(n)2}}{c^2}}}.\n$$\nThe total particle energy is then\n$$\nU_K^{(n)} = \\sum_{i=1}^{N_p} K_i^{(n)}.\n$$\nThe total energy across fields and particles is\n$$\nU_{\\text{tot}}^{(n)} = U_E^{(n)} + U_B^{(n)} + U_K^{(n)}.\n$$\n\n4. To verify discrete energy conservation, define the maximum relative drift $\\delta$:\n$$\n\\delta = \\begin{cases}\n\\frac{\\max_n U_{\\text{tot}}^{(n)} - \\min_n U_{\\text{tot}}^{(n)}}{U_{\\text{tot}}^{(0)}}  \\text{if } U_{\\text{tot}}^{(0)} \\neq 0,\\\\\n0  \\text{if } U_{\\text{tot}}^{(0)} = 0.\n\\end{cases}\n$$\nThis quantity is dimensionless and reflects the largest fractional variation of the total energy over time, normalized by the initial energy. For an exactly energy-conserving discrete scheme and exact arithmetic, $\\delta$ would be zero; in practice, numerical roundoff and discretization produce small nonzero values.\n\nAlgorithmic design:\n- Construct the spatial grid $x_j = j\\Delta x$ for $j=0,\\dots,N_x-1$ with $\\Delta x = L/N_x$.\n- Construct the time grid $t_n = n\\Delta t$ for $n=0,\\dots,N_t-1$ with $\\Delta t$ as specified.\n- For each test case, generate the arrays $E_j^{(n)}$ and $B_j^{(n)}$ according to the formulas provided, ensuring trigonometric arguments are in radians.\n- For particle-only cases, generate $v_i^{(n)}$ arrays of the specified constant velocities and compute $\\gamma_i^{(n)}$ for each particle and time step.\n- Compute $U_E^{(n)}$ and $U_B^{(n)}$ using the Riemann sums with the constants $\\varepsilon_0$ and $\\mu_0$.\n- Compute $U_K^{(n)}$ for the particles using the relativistic kinetic energy formula.\n- Form $U_{\\text{tot}}^{(n)}$ and evaluate $\\delta$ as the normalized maximum range of this time series; if $U_{\\text{tot}}^{(0)} = 0$, set $\\delta = 0$.\n- Repeat for all four test cases.\n\nCase expectations:\n- In the vacuum standing wave with $E_j^{(n)} = E_0\\cos(k x_j)\\cos(\\omega t_n)$ and $B_j^{(n)} = (E_0/c)\\cos(k x_j)\\sin(\\omega t_n)$, note that $1/\\mu_0 = \\varepsilon_0 c^2$ and $\\cos^2(\\omega t_n) + \\sin^2(\\omega t_n) = 1$. Therefore,\n$$\nU_E^{(n)} + U_B^{(n)} = \\frac{\\varepsilon_0}{2}\\sum_j \\left(E_0^2\\cos^2(kx_j)\\cos^2(\\omega t_n) + c^2\\left(\\frac{E_0}{c}\\right)^2\\cos^2(kx_j)\\sin^2(\\omega t_n)\\right)\\Delta x,\n$$\nwhich simplifies to\n$$\n\\frac{\\varepsilon_0}{2}E_0^2\\sum_j \\cos^2(kx_j)\\Delta x,\n$$\nconstant in time. With no particles, the total energy is constant, so $\\delta$ should be near zero up to numerical roundoff.\n\n- The zero fields and zero particles case has identically zero energy at all times; per the definition, set $\\delta = 0$ to avoid division by zero.\n\n- The particles-only case with constant velocities has constant particle energy and zero field energy; thus $\\delta$ is near zero.\n\n- The drifting field amplitude case introduces a controlled variation via the factor $f_n = 1 - \\alpha\\frac{n}{N_t - 1}$ in $E_j^{(n)}$ while keeping $B_j^{(n)}$ fixed in amplitude. This produces a measurable drift in the total energy, so $\\delta$ should be on the order of the prescribed amplitude variation.\n\nImplementation details:\n- Use double-precision floating-point arithmetic via the numerical library.\n- Compute the drift values and round them to eight decimal places for output.\n- Aggregate the four results into a single list printed as a single line.\n\nThe final program implements this algorithm and outputs the list of $\\delta$ values for the specified test suite cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants in SI units\nc = 299_792_458.0  # m/s\nmu0 = 4.0e-7 * np.pi  # H/m\neps0 = 1.0 / (mu0 * c * c)  # F/m\n\ndef compute_field_energy(E_series, B_series, dx):\n    \"\"\"\n    Compute electric and magnetic field energies for each time step.\n    E_series, B_series: arrays of shape (Nt, Nx)\n    Returns U_E (Nt,), U_B (Nt,)\n    \"\"\"\n    # Electric field energy: (eps0/2) * sum_j E^2 * dx\n    U_E = 0.5 * eps0 * np.sum(E_series**2, axis=1) * dx\n    # Magnetic field energy: (1/(2*mu0)) * sum_j B^2 * dx\n    U_B = 0.5 / mu0 * np.sum(B_series**2, axis=1) * dx\n    return U_E, U_B\n\ndef compute_particle_energy(v_series, masses):\n    \"\"\"\n    Compute relativistic particle kinetic energy for each time step.\n    v_series: array of shape (Nt, Np) giving particle speeds (1D).\n    masses: array of shape (Np,)\n    Returns U_K (Nt,)\n    \"\"\"\n    if v_series is None or masses is None or len(masses) == 0:\n        # No particles\n        return np.zeros(1)  # Will be broadcasted later to Nt\n    Nt = v_series.shape[0]\n    Np = v_series.shape[1]\n    masses = np.asarray(masses)\n    # Ensure masses align with particles\n    assert masses.shape[0] == Np, \"Masses must align with particle count.\"\n    # gamma = 1/sqrt(1 - v^2/c^2)\n    gamma = 1.0 / np.sqrt(1.0 - (v_series**2) / (c**2))\n    # K_i = m_i c^2 (gamma - 1); sum over particles\n    K = masses[np.newaxis, :] * (c**2) * (gamma - 1.0)\n    U_K = np.sum(K, axis=1)\n    return U_K\n\ndef max_relative_drift(total_energy_t):\n    \"\"\"\n    Compute maximum relative drift: (max - min) / initial.\n    If initial energy is zero, return 0.0.\n    \"\"\"\n    maxE = float(np.max(total_energy_t))\n    minE = float(np.min(total_energy_t))\n    initE = float(total_energy_t[0])\n    if abs(initE) == 0.0:\n        return 0.0\n    return (maxE - minE) / initE\n\ndef generate_case_vacuum_standing_wave():\n    # Case 1 parameters\n    L = 1.0\n    Nx = 256\n    dx = L / Nx\n    Nt = 100\n    E0 = 1.0e3\n    k = 2.0 * np.pi / L\n    omega = c * k\n    T = 2.0 * np.pi / omega\n    dt = T / Nt\n    # Grids\n    x = np.arange(Nx) * dx\n    t = np.arange(Nt) * dt\n    # Fields\n    cos_kx = np.cos(k * x)[np.newaxis, :]  # shape (1, Nx)\n    cos_om_t = np.cos(omega * t)[:, np.newaxis]  # shape (Nt, 1)\n    sin_om_t = np.sin(omega * t)[:, np.newaxis]\n    E_series = E0 * cos_kx * cos_om_t\n    B_series = (E0 / c) * cos_kx * sin_om_t\n    # No particles\n    v_series = None\n    masses = None\n    return E_series, B_series, v_series, masses, dx\n\ndef generate_case_zero():\n    # Case 2 parameters\n    L = 1.0\n    Nx = 32\n    dx = L / Nx\n    Nt = 10\n    # Fields zero\n    E_series = np.zeros((Nt, Nx), dtype=float)\n    B_series = np.zeros((Nt, Nx), dtype=float)\n    # No particles\n    v_series = None\n    masses = None\n    return E_series, B_series, v_series, masses, dx\n\ndef generate_case_particles_only():\n    # Case 3 parameters\n    L = 1.0\n    Nx = 16\n    dx = L / Nx\n    Nt = 50\n    # Fields zero\n    E_series = np.zeros((Nt, Nx), dtype=float)\n    B_series = np.zeros((Nt, Nx), dtype=float)\n    # Particles: 2, constant velocities\n    m_e = 9.10938356e-31\n    m_D = 3.34358372e-27\n    masses = np.array([m_e, m_D], dtype=float)\n    v1 = 1.0e5\n    v2 = 2.0e5\n    v_series = np.tile(np.array([v1, v2], dtype=float), (Nt, 1))\n    return E_series, B_series, v_series, masses, dx\n\ndef generate_case_drifting_fields():\n    # Case 4 parameters\n    L = 1.0\n    Nx = 256\n    dx = L / Nx\n    Nt = 100\n    E0 = 1.0e3\n    k = 2.0 * np.pi / L\n    omega = c * k\n    T = 2.0 * np.pi / omega\n    dt = T / Nt\n    alpha = 0.02\n    # Grids\n    x = np.arange(Nx) * dx\n    t = np.arange(Nt) * dt\n    # Amplitude factor f_n\n    f = 1.0 - alpha * (np.arange(Nt) / (Nt - 1))\n    f = f[:, np.newaxis]  # shape (Nt, 1)\n    cos_kx = np.cos(k * x)[np.newaxis, :]  # shape (1, Nx)\n    cos_om_t = np.cos(omega * t)[:, np.newaxis]  # shape (Nt, 1)\n    sin_om_t = np.sin(omega * t)[:, np.newaxis]\n    # Fields with drifting E amplitude; B fixed amplitude\n    E_series = (f * E0) * cos_kx * cos_om_t\n    B_series = (E0 / c) * cos_kx * sin_om_t\n    # No particles\n    v_series = None\n    masses = None\n    return E_series, B_series, v_series, masses, dx\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        generate_case_vacuum_standing_wave(),\n        generate_case_zero(),\n        generate_case_particles_only(),\n        generate_case_drifting_fields(),\n    ]\n\n    results = []\n    for (E_series, B_series, v_series, masses, dx) in test_cases:\n        Nt = E_series.shape[0]\n        # Field energies\n        U_E, U_B = compute_field_energy(E_series, B_series, dx)\n        # Particle energies\n        U_K = compute_particle_energy(v_series, masses)\n        if U_K.shape[0] != Nt:\n            # Broadcast U_K to Nt if no particles (single zero)\n            U_K = np.zeros(Nt, dtype=float)\n        # Total energy\n        U_tot = U_E + U_B + U_K\n        # Drift\n        drift = max_relative_drift(U_tot)\n        # Round to eight decimal places for output\n        results.append(f\"{drift:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}