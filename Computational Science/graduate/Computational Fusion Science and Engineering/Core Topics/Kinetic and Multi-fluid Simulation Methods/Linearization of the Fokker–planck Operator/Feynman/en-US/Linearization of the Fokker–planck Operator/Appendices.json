{
    "hands_on_practices": [
        {
            "introduction": "To solve the Fokker-Planck equation computationally, we often transform the continuous integro-differential operator into a matrix. This practice guides you through the analytical calculation of the matrix elements for a simplified linearized operator using Sonine polynomials, which form a natural basis for describing perturbations around a Maxwellian equilibrium. Mastering this technique () is a foundational step in developing spectral codes for kinetic simulations.",
            "id": "4002778",
            "problem": "In computational fusion science and engineering, collisional relaxation of a single ion species near a Maxwellian equilibrium is often modeled by a simplified linearized Fokker–Planck operator. Consider a spatially homogeneous, isotropic perturbation to a Maxwellian distribution,\n$$\nf_0(\\mathbf{v}) = n \\left(\\frac{m}{2\\pi T}\\right)^{3/2} \\exp\\!\\left(-\\frac{m v^{2}}{2T}\\right),\n$$\nwhere $n$ is the number density, $m$ is the particle mass, $T$ is the temperature, and $v = |\\mathbf{v}|$. Let the dimensionless speed be $c = v / v_{\\mathrm{th}}$ with $v_{\\mathrm{th}} = \\sqrt{2T/m}$, so that $f_0(\\mathbf{v}) \\propto \\exp(-c^{2})$. The perturbation is expanded in Sonine polynomials as\n$$\n\\delta f(\\mathbf{v}) = f_0(\\mathbf{v}) \\sum_{p=0}^{P} a_p S_p(c^{2}),\n$$\nwhere $S_p(x)$ are Sonine polynomials defined by the associated Laguerre polynomials $S_p(x) \\equiv L_p^{(1/2)}(x)$, and $\\{a_p\\}$ are scalar coefficients. Assume the simplified Lenard–Bernstein (LB) form of the linearized Fokker–Planck operator,\n$$\nL[\\delta f] \\equiv \\nu \\,\\nabla_{\\mathbf{v}} \\cdot \\left( \\mathbf{v}\\,\\delta f + \\frac{T}{m}\\,\\nabla_{\\mathbf{v}} \\delta f \\right),\n$$\nwith constant like-species collision frequency $\\nu$, which leaves $f_0$ stationary. For a truncated expansion with $P=1$, write $\\delta f(\\mathbf{v}) = f_0(\\mathbf{v})\\left(a_0 S_0(c^{2}) + a_1 S_1(c^{2})\\right)$, where $S_0(x)=1$ and $S_1(x)=\\frac{3}{2}-x$.\n\nEvaluate $L[\\delta f]$ and compute the coupling coefficients $M_{pq}$, for $p,q \\in \\{0,1\\}$, defined by\n$$\nL\\!\\left[f_0(\\mathbf{v})\\,S_q(c^{2})\\right] = f_0(\\mathbf{v}) \\sum_{p=0}^{1} M_{pq}\\,S_p(c^{2}).\n$$\nProvide the final answer as the closed-form analytic expression for the $2\\times 2$ coupling matrix $M$ in terms of $\\nu$. No numerical approximation is required.",
            "solution": "The problem is well-posed, scientifically grounded, and provides all necessary information to compute the coupling matrix $M$. We proceed with the solution.\n\nThe coupling coefficients $M_{pq}$ for $p, q \\in \\{0, 1\\}$ are defined by the relation\n$$\nL\\!\\left[f_0(\\mathbf{v})\\,S_q(c^{2})\\right] = f_0(\\mathbf{v}) \\sum_{p=0}^{1} M_{pq}\\,S_p(c^{2})\n$$\nwhere $L$ is the linearized Lenard–Bernstein operator, $f_0$ is the Maxwellian background distribution, and $S_q$ are Sonine polynomials. The basis functions for the expansion are $f_0(\\mathbf{v})S_0(c^2)$ and $f_0(\\mathbf{v})S_1(c^2)$. We must compute the action of the operator $L$ on each of these basis functions and then project the result back onto the basis.\n\nThe operator is given by\n$$\nL[h] \\equiv \\nu \\,\\nabla_{\\mathbf{v}} \\cdot \\left( \\mathbf{v}\\,h + \\frac{T}{m}\\,\\nabla_{\\mathbf{v}} h \\right)\n$$\nwhere $h$ is the perturbation function. The dimensionless speed squared is $c^2 = \\frac{v^2}{v_{\\mathrm{th}}^2} = \\frac{v^2}{2T/m} = \\frac{mv^2}{2T}$. The Maxwellian distribution is proportional to $\\exp(-c^2)$, specifically $f_0(\\mathbf{v}) = N \\exp\\left(-\\frac{mv^2}{2T}\\right)$ for some normalization constant $N$.\n\nFirst, we calculate the gradient of $f_0$:\n$$\n\\nabla_{\\mathbf{v}} f_0(\\mathbf{v}) = \\nabla_{\\mathbf{v}} \\left( N \\exp\\left(-\\frac{mv^2}{2T}\\right) \\right) = N \\exp\\left(-\\frac{mv^2}{2T}\\right) \\left(-\\frac{m}{2T}\\right) \\nabla_{\\mathbf{v}}(v^2)\n$$\nSince $\\nabla_{\\mathbf{v}}(v^2) = \\nabla_{\\mathbf{v}}(\\mathbf{v} \\cdot \\mathbf{v}) = 2\\mathbf{v}$, we have\n$$\n\\nabla_{\\mathbf{v}} f_0(\\mathbf{v}) = f_0(\\mathbf{v}) \\left(-\\frac{m}{2T}\\right) (2\\mathbf{v}) = -\\frac{m}{T}\\mathbf{v}f_0(\\mathbf{v})\n$$\n\n**Calculation for the first column of M (q=0):**\nWe need to compute $L[f_0 S_0]$. The first Sonine polynomial is $S_0(c^2) = 1$. Thus, we are computing $L[f_0]$.\n$$\nL[f_0] = \\nu \\,\\nabla_{\\mathbf{v}} \\cdot \\left( \\mathbf{v}\\,f_0 + \\frac{T}{m}\\,\\nabla_{\\mathbf{v}} f_0 \\right)\n$$\nSubstituting the expression for $\\nabla_{\\mathbf{v}} f_0$:\n$$\nL[f_0] = \\nu \\,\\nabla_{\\mathbf{v}} \\cdot \\left( \\mathbf{v}\\,f_0 + \\frac{T}{m}\\left(-\\frac{m}{T}\\mathbf{v}f_0\\right) \\right) = \\nu \\,\\nabla_{\\mathbf{v}} \\cdot \\left( \\mathbf{v}\\,f_0 - \\mathbf{v}\\,f_0 \\right) = \\nu \\,\\nabla_{\\mathbf{v}} \\cdot (\\mathbf{0}) = 0\n$$\nThis confirms the operator leaves the Maxwellian stationary. Now we express this result in the basis $\\{S_0, S_1\\}$:\n$$\nL[f_0 S_0] = 0 = f_0(v) \\left( M_{00} S_0(c^2) + M_{10} S_1(c^2) \\right)\n$$\nSince $S_0=1$ and $S_1 = \\frac{3}{2}-c^2$ are linearly independent functions of $c^2$, their coefficients must be zero. Therefore, $M_{00} = 0$ and $M_{10} = 0$. This gives the first column of the matrix $M$.\n\n**Calculation for the second column of M (q=1):**\nWe need to compute $L[f_0 S_1]$. The second Sonine polynomial is $S_1(c^2) = \\frac{3}{2} - c^2$. Let $h_1(\\mathbf{v}) = f_0(\\mathbf{v})S_1(c^2)$. First, we compute $\\nabla_{\\mathbf{v}} h_1$ using the product rule:\n$$\n\\nabla_{\\mathbf{v}} h_1 = S_1(c^2) \\nabla_{\\mathbf{v}} f_0 + f_0 \\nabla_{\\mathbf{v}} S_1(c^2)\n$$\nWe need the gradient of $S_1(c^2)$:\n$$\n\\nabla_{\\mathbf{v}} S_1(c^2) = \\nabla_{\\mathbf{v}}\\left(\\frac{3}{2} - c^2\\right) = -\\nabla_{\\mathbf{v}} c^2 = -\\nabla_{\\mathbf{v}}\\left(\\frac{mv^2}{2T}\\right) = -\\frac{m}{2T}(2\\mathbf{v}) = -\\frac{m}{T}\\mathbf{v}\n$$\nSubstituting the gradients into the expression for $\\nabla_{\\mathbf{v}} h_1$:\n$$\n\\nabla_{\\mathbf{v}} h_1 = S_1(c^2)\\left(-\\frac{m}{T}\\mathbf{v}f_0\\right) + f_0\\left(-\\frac{m}{T}\\mathbf{v}\\right) = -\\frac{m}{T}\\mathbf{v}f_0 \\left(S_1(c^2) + 1\\right)\n$$\nNow, we form the argument of the divergence in the operator $L$:\n$$\n\\mathbf{J} = \\mathbf{v} h_1 + \\frac{T}{m}\\nabla_{\\mathbf{v}} h_1 = \\mathbf{v} f_0 S_1(c^2) + \\frac{T}{m}\\left(-\\frac{m}{T}\\mathbf{v}f_0 (S_1(c^2) + 1) \\right)\n$$\n$$\n\\mathbf{J} = \\mathbf{v} f_0 S_1(c^2) - \\mathbf{v}f_0(S_1(c^2) + 1) = \\mathbf{v} f_0 S_1(c^2) - \\mathbf{v} f_0 S_1(c^2) - \\mathbf{v} f_0 = -\\mathbf{v}f_0\n$$\nNow we can compute $L[h_1]$ by taking the divergence of $\\mathbf{J}$:\n$$\nL[h_1] = \\nu \\nabla_{\\mathbf{v}} \\cdot \\mathbf{J} = \\nu \\nabla_{\\mathbf{v}} \\cdot (-\\mathbf{v} f_0) = -\\nu \\left( (\\nabla_{\\mathbf{v}} \\cdot \\mathbf{v})f_0 + \\mathbf{v} \\cdot (\\nabla_{\\mathbf{v}} f_0) \\right)\n$$\nIn three dimensions, $\\nabla_{\\mathbf{v}} \\cdot \\mathbf{v} = 3$. We previously found $\\nabla_{\\mathbf{v}} f_0 = -\\frac{m}{T}\\mathbf{v}f_0$. So,\n$$\n\\mathbf{v} \\cdot (\\nabla_{\\mathbf{v}} f_0) = \\mathbf{v} \\cdot \\left(-\\frac{m}{T}\\mathbf{v}f_0\\right) = -\\frac{m v^2}{T}f_0\n$$\nUsing the relation $c^2 = \\frac{mv^2}{2T}$, we can write $\\frac{mv^2}{T} = 2c^2$. This gives $\\mathbf{v} \\cdot (\\nabla_{\\mathbf{v}} f_0) = -2c^2 f_0$.\nSubstituting these results back into the expression for $L[h_1]$:\n$$\nL[h_1] = -\\nu (3 f_0 - 2c^2 f_0) = \\nu (2c^2 - 3) f_0\n$$\nNow we must project this result onto the basis $\\{S_0, S_1\\}$:\n$$\nL[f_0 S_1] = f_0 \\left( M_{01} S_0(c^2) + M_{11} S_1(c^2) \\right)\n$$\n$$\n\\nu (2c^2 - 3) f_0 = f_0 \\left( M_{01}(1) + M_{11}\\left(\\frac{3}{2} - c^2\\right) \\right)\n$$\nDividing by $f_0$ and rearranging terms on the right side:\n$$\n2\\nu c^2 - 3\\nu = \\left(M_{01} + \\frac{3}{2}M_{11}\\right) - M_{11}c^2\n$$\nFor this equality to hold for all values of $c^2$, the coefficients of the powers of $c^2$ must be equal.\nEquating coefficients of $c^2$:\n$$\n2\\nu = -M_{11} \\implies M_{11} = -2\\nu\n$$\nEquating the constant terms:\n$$\n-3\\nu = M_{01} + \\frac{3}{2}M_{11}\n$$\nSubstituting the value of $M_{11}$:\n$$\n-3\\nu = M_{01} + \\frac{3}{2}(-2\\nu) = M_{01} - 3\\nu \\implies M_{01} = 0\n$$\nThis gives the second column of the matrix $M$.\n\n**Assembling the coupling matrix M:**\nThe matrix $M$ is formed by the coefficients $M_{pq}$:\n$$\nM = \\begin{pmatrix} M_{00} & M_{01} \\\\ M_{10} & M_{11} \\end{pmatrix}\n$$\nSubstituting the calculated values:\n$$\nM = \\begin{pmatrix} 0 & 0 \\\\ 0 & -2\\nu \\end{pmatrix}\n$$\nThis is the final expression for the coupling matrix.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & 0 \\\\\n0 & -2\\nu\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "A critical step in developing reliable simulation software is verifying that the discretized model preserves the fundamental physical principles of the continuous system. This hands-on exercise () has you implement a numerical test to confirm that a discretized linearized collision operator correctly respects the conservation of particles, momentum, and energy. You will construct the operator using a Gauss-Hermite quadrature and verify that it properly annihilates the discrete collision invariants, a key benchmark for any kinetic code.",
            "id": "4002748",
            "problem": "You are to implement, in software, a discrete verification that a linearized collision operator widely used in computational fusion science and engineering preserves the collision invariants when linearized about a Maxwellian equilibrium. The focus is the linearization of the Fokker–Planck operator, instantiated in the Bhatnagar–Gross–Krook (BGK) model, and its discrete null space under a spectrally accurate quadrature on velocity space.\n\nStarting point (fundamental base):\n- The continuous Fokker–Planck collision operator, when linearized about a Maxwellian equilibrium $f_0(\\boldsymbol{v})$, has a null space spanned by the collision invariants weighted by the equilibrium: $\\{f_0(\\boldsymbol{v}), v_i f_0(\\boldsymbol{v}), (v^2 - 3 T / m) f_0(\\boldsymbol{v})\\}$, where $m$ is particle mass, $T$ is temperature (energy per particle), and $v^2 = \\boldsymbol{v} \\cdot \\boldsymbol{v}$. These correspond to conservation of number, momentum, and energy.\n- In the Bhatnagar–Gross–Krook (BGK) model, the collision operator can be written as a relaxation towards a local equilibrium that matches density, momentum, and energy. When linearized about $f_0(\\boldsymbol{v})$, this relaxation is a projection that annihilates the subspace spanned by the above invariants.\n\nYour task is to:\n1. Construct a three-dimensional discrete velocity-space grid using Gauss–Hermite nodes and weights, appropriate for integrals of the form $\\int \\mathrm{d}^3v \\, e^{-(\\text{scaled velocity})^2} \\times \\text{polynomial}$. Use the change of variables $u_i = \\sqrt{m/(2T)} v_i$, which makes the Maxwellian $f_0(\\boldsymbol{v})$ proportional to $e^{-u^2}$ with $u^2 = u_x^2 + u_y^2 + u_z^2$.\n2. Define the Maxwellian equilibrium \n$$\nf_0(\\boldsymbol{v}) = n \\left(\\frac{m}{2 \\pi T}\\right)^{3/2} \\exp\\left(- \\frac{m v^2}{2 T}\\right),\n$$ \nwhere $n$ is number density. Express all velocities in $\\mathrm{m/s}$, mass in $\\mathrm{kg}$, temperature in $\\mathrm{J}$, and density in $\\mathrm{m^{-3}}$.\n3. Define the discrete inner product \n$$\n\\langle g, h \\rangle = \\int \\mathrm{d}^3 v \\, \\frac{g(\\boldsymbol{v}) h(\\boldsymbol{v})}{f_0(\\boldsymbol{v})},\n$$ \nand approximate it using the three-dimensional Gauss–Hermite quadrature induced by the $u$-variables and the Jacobian. Ensure that the discretization is self-consistent with the change of variables.\n4. Construct the discrete versions of the invariant basis functions \n$$\n\\phi_0(\\boldsymbol{v}) = f_0(\\boldsymbol{v}), \\quad \\phi_i(\\boldsymbol{v}) = v_i f_0(\\boldsymbol{v}), \\quad \\phi_E(\\boldsymbol{v}) = \\left(v^2 - \\frac{3T}{m}\\right) f_0(\\boldsymbol{v}).\n$$\n5. Form the Gram matrix $G_{ab} = \\langle \\phi_a, \\phi_b \\rangle$ with $a,b \\in \\{0, x, y, z, E\\}$, and the projection of any discrete function $g$ onto the span of the invariants via coefficients $c = G^{-1} b$, where $b_a = \\langle \\phi_a, g \\rangle$. The linearized BGK collision operator is then \n$$\nC_L[g] = -\\nu \\left(g - \\sum_a c_a \\phi_a \\right),\n$$ \nwhere $\\nu$ is a collision frequency in $\\mathrm{s^{-1}}$.\n6. Verify, numerically, that $C_L[\\phi]$ is annihilated to machine precision for each basis function $\\phi \\in \\{\\phi_0, \\phi_x, \\phi_y, \\phi_z, \\phi_E\\}$ by reporting the maximum relative residual\n$$\nr = \\max_{\\phi \\in \\{\\phi_0, \\phi_x, \\phi_y, \\phi_z, \\phi_E\\}} \\frac{\\| C_L[\\phi] \\|}{\\nu \\| \\phi \\|},\n$$\nwhere $\\|g\\| = \\sqrt{\\langle g, g \\rangle}$. The expectation is that $r$ will be at or near floating-point roundoff (machine precision).\n\nYour program must implement the entire construction and verification pipeline and produce results for the following test suite. For each parameter set, compute and return the single scalar $r$ as defined above.\n\nTest suite:\n- Case $1$ (deuterium-like ions): $m = 3.344 \\times 10^{-27} \\, \\mathrm{kg}$, $T = 3{,}000 \\times 1.602176634 \\times 10^{-19} \\, \\mathrm{J}$, $n = 10^{19} \\, \\mathrm{m^{-3}}$, $\\nu = 10^{5} \\, \\mathrm{s^{-1}}$, Gauss–Hermite points per dimension $N = 6$.\n- Case $2$ (electrons): $m = 9.10938356 \\times 10^{-31} \\, \\mathrm{kg}$, $T = 10{,}000 \\times 1.602176634 \\times 10^{-19} \\, \\mathrm{J}$, $n = 5 \\times 10^{20} \\, \\mathrm{m^{-3}}$, $\\nu = 2 \\times 10^{6} \\, \\mathrm{s^{-1}}$, $N = 8$.\n- Case $3$ (protons, minimal quadrature): $m = 1.67262192369 \\times 10^{-27} \\, \\mathrm{kg}$, $T = 100 \\times 1.602176634 \\times 10^{-19} \\, \\mathrm{J}$, $n = 10^{16} \\, \\mathrm{m^{-3}}$, $\\nu = 3 \\times 10^{3} \\, \\mathrm{s^{-1}}$, $N = 3$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3]$), where $r_i$ is the maximum relative residual for Case $i$, reported as floating-point numbers. No other text should be printed.\n\nScientific realism and numerical details:\n- Use units as specified above. The angle unit is not applicable because the velocity-space quadrature is Cartesian and does not involve angles.\n- The Gauss–Hermite quadrature must be applied in product form in $3$ dimensions using the transformed variables $u_i$ with the Jacobian factor. The computation must be performed in double precision.\n- The null space verification should be \"to machine precision,\" meaning $r$ should be dominated by floating-point rounding error under the specified quadrature orders.",
            "solution": "The objective is to numerically verify that a discrete representation of the linearized Bhatnagar–Gross–Krook (BGK) collision operator, $C_L$, preserves the collision invariants. This is a fundamental consistency check in computational kinetic theory. The operator is linearized about a Maxwellian equilibrium distribution, $f_0(\\boldsymbol{v})$. Its null space is spanned by a set of functions $\\{\\phi_a\\}$ corresponding to the conserved quantities: particle number, momentum, and energy. The verification involves constructing the operator on a discrete velocity-space grid and demonstrating that it annihilates each basis function $\\phi_a$ to within machine precision.\n\nThe linearized BGK operator is given by:\n$$\nC_L[g] = -\\nu \\left(g - \\mathcal{P}[g]\\right)\n$$\nwhere $\\nu$ is the collision frequency, and $\\mathcal{P}[g]$ is the projection of a function $g$ onto the null space spanned by the collision invariants. The basis functions for this null space are:\n$$\n\\phi_0(\\boldsymbol{v}) = f_0(\\boldsymbol{v}) \\qquad (\\text{number})\n$$\n$$\n\\phi_i(\\boldsymbol{v}) = v_i f_0(\\boldsymbol{v}) \\quad \\text{for } i \\in \\{x, y, z\\} \\qquad (\\text{momentum})\n$$\n$$\n\\phi_E(\\boldsymbol{v}) = \\left(v^2 - \\frac{3T}{m}\\right) f_0(\\boldsymbol{v}) \\qquad (\\text{energy})\n$$\nHere, $m$ is the particle mass, $T$ is the temperature in Joules, $\\boldsymbol{v}$ is the velocity vector, and $v^2 = \\boldsymbol{v} \\cdot \\boldsymbol{v}$. The Maxwellian equilibrium distribution is:\n$$\nf_0(\\boldsymbol{v}) = n \\left(\\frac{m}{2 \\pi T}\\right)^{3/2} \\exp\\left(- \\frac{m v^2}{2 T}\\right)\n$$\nwhere $n$ is the number density.\n\nBy construction, if we apply the operator $C_L$ to any of the basis functions $\\phi_k$, the projection term becomes $\\mathcal{P}[\\phi_k] = \\phi_k$. This results in $C_L[\\phi_k] = -\\nu(\\phi_k - \\phi_k) = 0$. Our task is to verify this property holds for a discrete version of the operator.\n\n**Step 1: Velocity Space Discretization and Gauss-Hermite Quadrature**\n\nIntegrals over velocity space weighted by the Maxwellian are best handled by a change of variables and Gauss-Hermite quadrature. We introduce a scaled, dimensionless velocity $\\boldsymbol{u}$:\n$$\nu_i = \\sqrt{\\frac{m}{2T}} v_i \\implies v_i = \\sqrt{\\frac{2T}{m}} u_i\n$$\nLet's define the thermal velocity $v_{th} = \\sqrt{2T/m}$, so $\\boldsymbol{v} = \\boldsymbol{u} v_{th}$. The Maxwellian simplifies to $f_0(\\boldsymbol{u}) = n (m/(2\\pi T))^{3/2} \\exp(-u^2)$, where $u^2 = u_x^2 + u_y^2 + u_z^2$. The volume element transforms as $\\mathrm{d}^3v = (\\sqrt{2T/m})^3 \\mathrm{d}^3u = v_{th}^3 \\mathrm{d}^3u$.\n\nA three-dimensional grid is constructed as the tensor product of one-dimensional Gauss-Hermite quadrature nodes. For a given order $N$, we obtain $N$ nodes $u^{(j)}$ and weights $w^{(j)}$ that approximate one-dimensional integrals of the form $\\int_{-\\infty}^{\\infty} e^{-x^2} f(x) \\mathrm{d}x \\approx \\sum_{j=1}^N w^{(j)} f(u^{(j)})$. The 3D grid consists of $N^3$ points $\\boldsymbol{u}_{ijk} = (u^{(i)}, u^{(j)}, u^{(k)})$ with corresponding composite weights $W_{ijk} = w^{(i)} w^{(j)} w^{(k)}$.\n\n**Step 2: Discrete Inner Product and Gram Matrix**\n\nThe projection $\\mathcal{P}$ is defined with respect to the inner product:\n$$\n\\langle g, h \\rangle = \\int \\mathrm{d}^3 v \\, \\frac{g(\\boldsymbol{v}) h(\\boldsymbol{v})}{f_0(\\boldsymbol{v})}\n$$\nThe basis functions can be written as $\\phi_a(\\boldsymbol{v}) = P_a(\\boldsymbol{v})f_0(\\boldsymbol{v})$, where $P_a(\\boldsymbol{v})$ are polynomials in velocity: $P_0=1$, $P_i=v_i$, and $P_E=v^2-3T/m$. Substituting this into the inner product for two basis functions $\\phi_a$ and $\\phi_b$:\n$$\n\\langle \\phi_a, \\phi_b \\rangle = \\int \\mathrm{d}^3 v \\, \\frac{(P_a f_0)(P_b f_0)}{f_0} = \\int \\mathrm{d}^3 v \\, P_a(\\boldsymbol{v}) P_b(\\boldsymbol{v}) f_0(\\boldsymbol{v})\n$$\nThis integral is of a form suitable for our chosen quadrature. After changing variables to $\\boldsymbol{u}$:\n$$\n\\langle \\phi_a, \\phi_b \\rangle = \\int (v_{th}^3 \\mathrm{d}^3u) \\, P_a(\\boldsymbol{u}v_{th}) P_b(\\boldsymbol{u}v_{th}) \\left( n \\left(\\frac{m}{2 \\pi T}\\right)^{3/2} e^{-u^2} \\right)\n$$\n$$\n= n \\left(\\frac{v_{th}^2 m}{2 \\pi T}\\right)^{3/2} \\int \\mathrm{d}^3u \\, P_a(\\boldsymbol{u}v_{th}) P_b(\\boldsymbol{u}v_{th}) e^{-u^2} = \\frac{n}{\\pi^{3/2}} \\int \\mathrm{d}^3u \\, P_a(\\boldsymbol{u}v_{th}) P_b(\\boldsymbol{u}v_{th}) e^{-u^2}\n$$\nThe discretization of this inner product is therefore:\n$$\n\\langle \\phi_a, \\phi_b \\rangle \\approx \\frac{n}{\\pi^{3/2}} \\sum_{ijk} W_{ijk} \\, P_a(\\boldsymbol{v}_{ijk}) P_b(\\boldsymbol{v}_{ijk})\n$$\nwhere the sum is over all $N^3$ grid points. For numerical stability, we work with the polynomial parts $P_a$ directly. We compute the $5 \\times 5$ Gram matrix $G_{ab} = \\langle \\phi_a, \\phi_b \\rangle$ using this discrete formula. The Gauss-Hermite quadrature of order $N$ is exact for polynomials of degree up to $2N-1$. The highest-degree polynomial in the Gram matrix calculation is $P_E^2$, which is of degree $4$. Thus, $2N-1 \\ge 4 \\implies N \\ge 2.5$. The minimal order $N=3$ suffices for an exact (to machine precision) computation of $G$.\n\n**Step 3: Projection and Verification**\n\nThe projection of a function $g$ is $\\mathcal{P}[g] = \\sum_a c_a \\phi_a$, where the coefficients $c_a$ are found by solving the linear system $G c = b$, with $b_a = \\langle \\phi_a, g \\rangle$.\n\nTo verify the null space property, we take $g$ to be one of the basis functions, $\\phi_k$. The vector $b$ is then $b_a = \\langle \\phi_a, \\phi_k \\rangle = G_{ak}$, which is the $k$-th column of the Gram matrix. Solving $G c = G_k$ should yield $c$ as the $k$-th standard basis vector, $e_k$ (a vector of zeros with a $1$ at position $k$).\n\nNumerically, we compute $c = G^{-1}b$. The discrete residual function is then $\\text{res}_k = \\phi_k - \\sum_a c_a \\phi_a$. We measure the \"size\" of this residual using the norm $\\|f\\| = \\sqrt{\\langle f, f \\rangle}$. The verification metric is the maximum relative residual:\n$$\nr = \\max_{k \\in \\{0,x,y,z,E\\}} \\frac{\\| C_L[\\phi_k] \\|}{\\nu \\| \\phi_k \\|} = \\max_k \\frac{\\|-\\nu(\\phi_k - \\mathcal{P}[\\phi_k])\\|}{\\nu\\|\\phi_k\\|} = \\max_k \\frac{\\|\\text{res}_k\\|}{\\|\\phi_k\\|}\n$$\nThe norm of the residual, $\\|\\text{res}_k\\|^2 = \\langle \\text{res}_k, \\text{res}_k \\rangle$, can be calculated stably by first finding the polynomial part of the residual, $P_{res,k} = P_k - \\sum_a c_a P_a$, and then using the quadrature formula:\n$$\n\\|\\text{res}_k\\|^2 \\approx \\frac{n}{\\pi^{3/2}} \\sum_{ijk} W_{ijk} \\, (P_{res,k}(\\boldsymbol{v}_{ijk}))^2\n$$\nThe squared norm of the original function is simply a diagonal element of the Gram matrix, $\\|\\phi_k\\|^2 = \\langle \\phi_k, \\phi_k \\rangle = G_{kk}$. The final check is whether the computed maximum relative residual, $r$, is on the order of machine floating-point precision, which would confirm the conservation property of the discrete operator.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_hermite\n\ndef solve():\n    \"\"\"\n    Main solver function to run verification for all test cases.\n    \"\"\"\n    # Conversion factor from electron-volts to Joules\n    EV_TO_J = 1.602176634e-19\n    \n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case 1: Deuterium-like ions\n        {'m': 3.344e-27, 'T': 3000 * EV_TO_J, 'n': 1e19, 'nu': 1e5, 'N': 6},\n        # Case 2: Electrons\n        {'m': 9.10938356e-31, 'T': 10000 * EV_TO_J, 'n': 5e20, 'nu': 2e6, 'N': 8},\n        # Case 3: Protons, minimal quadrature\n        {'m': 1.67262192369e-27, 'T': 100 * EV_TO_J, 'n': 1e16, 'nu': 3e3, 'N': 3},\n    ]\n\n    results = []\n    for params in test_cases:\n        r = calculate_max_relative_residual(**params)\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_max_relative_residual(m, T, n, nu, N):\n    \"\"\"\n    Constructs the discrete linearized BGK operator and verifies its null space.\n\n    Args:\n        m (float): Particle mass in kg.\n        T (float): Temperature in Joules.\n        n (float): Number density in m^-3.\n        nu (float): Collision frequency in s^-1.\n        N (int): Number of Gauss-Hermite points per dimension.\n\n    Returns:\n        float: The maximum relative residual 'r'.\n    \"\"\"\n    # 1. Construct velocity-space grid\n    nodes_1d, weights_1d = roots_hermite(N)\n    \n    # Create 3D grid points (u-space) and weights via tensor product\n    ux_grid, uy_grid, uz_grid = np.meshgrid(nodes_1d, nodes_1d, nodes_1d, indexing='ij')\n    u_grid = np.stack([ux_grid.ravel(), uy_grid.ravel(), uz_grid.ravel()], axis=-1)\n    \n    wx_grid, wy_grid, wz_grid = np.meshgrid(weights_1d, weights_1d, weights_1d, indexing='ij')\n    W_grid = (wx_grid * wy_grid * wz_grid).ravel()\n\n    # 2. Define basis functions and physical quantities on the grid\n    v_th = np.sqrt(2 * T / m)\n    v_grid = u_grid * v_th\n    \n    # Polynomial parts P_a of the basis functions, evaluated on the v-grid\n    P_0_vec = np.ones(N**3)\n    P_x_vec = v_grid[:, 0]\n    P_y_vec = v_grid[:, 1]\n    P_z_vec = v_grid[:, 2]\n    v_sq_vec = np.sum(v_grid**2, axis=1)\n    P_E_vec = v_sq_vec - 3 * T / m\n    \n    P_list = [P_0_vec, P_x_vec, P_y_vec, P_z_vec, P_E_vec]\n\n    # 3. Compute Gram matrix using the discrete inner product\n    prefactor = n / (np.pi**1.5)\n    def inner_product_P(Pa_vec, Pb_vec):\n        \"\"\"Computes the inner product integral for two polynomial parts.\"\"\"\n        integrand = Pa_vec * Pb_vec\n        integral_val = np.sum(W_grid * integrand)\n        return prefactor * integral_val\n\n    G = np.zeros((5, 5))\n    for a in range(5):\n        for b in range(5):\n            G[a, b] = inner_product_P(P_list[a], P_list[b])\n\n    # 4. Verify null space property for each basis function\n    max_rel_residual = 0.0\n    for k in range(5):\n        P_k_vec = P_list[k]\n        \n        # The vector b for solving Gc = b is the k-th column of G\n        b = G[:, k]\n        \n        # Solve for projection coefficients c\n        c = np.linalg.solve(G, b)\n        \n        # Compute the polynomial part of the residual function\n        P_proj_k_vec = np.zeros_like(P_k_vec)\n        for a in range(5):\n            P_proj_k_vec += c[a] * P_list[a]\n        \n        P_res_k_vec = P_k_vec - P_proj_k_vec\n        \n        # Compute norms of the residual and the original function\n        # ||res_k||^2 = <res_k, res_k>\n        norm_res_k_sq = inner_product_P(P_res_k_vec, P_res_k_vec)\n        \n        # ||phi_k||^2 = <phi_k, phi_k> = G[k, k]\n        norm_phi_k_sq = G[k, k]\n        \n        if norm_phi_k_sq == 0:\n            rel_residual_k = 0.0 if norm_res_k_sq == 0 else np.inf\n        else:\n            # Use abs to handle potential negative signs from floating point error\n            rel_residual_k = np.sqrt(np.abs(norm_res_k_sq) / np.abs(norm_phi_k_sq))\n        \n        if rel_residual_k > max_rel_residual:\n            max_rel_residual = rel_residual_k\n            \n    return max_rel_residual\n\nsolve()\n```"
        },
        {
            "introduction": "Computational models must operate on finite domains, which introduces artificial boundaries that can violate fundamental conservation laws. This exercise () explores how naive boundary conditions break particle conservation in a truncated Fokker-Planck model and challenges you to implement a physically-motivated correction. By deriving and applying a zero-flux Robin condition, you will not only restore conservation but also ensure the numerical stability of the simulation, a crucial consideration in practical code development.",
            "id": "4002762",
            "problem": "Consider a one-dimensional, isotropic, simplified Fokker–Planck model used in computational fusion science and engineering to represent collisional relaxation in velocity space. Let $v \\in [-V_{\\max}, V_{\\max}]$ denote the truncated velocity coordinate. The simplified collisional flux is modeled by the Lenard–Bernstein form, which is consistent with the fluctuation–dissipation relation and admits a Maxwellian equilibrium. Define the flux\n$$\nJ(v,f) = \\nu\\, v\\, f(v) + D\\, \\frac{\\partial f}{\\partial v}(v),\n$$\nwith constant drag coefficient $\\nu$ and diffusion coefficient $D$ satisfying $D = \\nu\\, v_{\\mathrm{th}}^2$, where $v_{\\mathrm{th}}$ is the thermal speed. The collisional operator is given by the divergence of the flux,\n$$\n\\mathcal{C}[f](v) = \\frac{\\partial}{\\partial v} J(v,f).\n$$\nAssume a Maxwellian equilibrium\n$$\nf_0(v) = \\frac{1}{\\sqrt{2\\pi} v_{\\mathrm{th}}} \\exp\\!\\left(-\\frac{v^2}{2 v_{\\mathrm{th}}^2}\\right),\n$$\nand consider a small perturbation $\\delta f(v)$ such that $f(v) = f_0(v) + \\delta f(v)$ with $|\\delta f| \\ll f_0$. The linearized operator acting on $\\delta f$ is\n$$\n\\mathcal{C}[\\delta f](v) = \\frac{\\partial}{\\partial v}\\Big(\\nu\\, v\\, \\delta f(v) + D\\, \\frac{\\partial \\delta f}{\\partial v}(v)\\Big),\n$$\nbecause $f_0$ satisfies $\\frac{\\partial}{\\partial v}\\big(\\nu v f_0 + D \\frac{\\partial f_0}{\\partial v}\\big) = 0$ when $D = \\nu v_{\\mathrm{th}}^2$.\n\nIn an infinite velocity domain, the total particle number $N = \\int_{-\\infty}^{\\infty} f(v)\\, dv$ is conserved under the collisional dynamics, since\n$$\n\\frac{dN}{dt} = \\int_{-\\infty}^{\\infty} \\mathcal{C}[f](v)\\, dv = \\left.J(v,f)\\right|_{-\\infty}^{\\infty} = 0,\n$$\nprovided $J \\to 0$ sufficiently fast at $|v| \\to \\infty$. When velocity space is truncated to $[-V_{\\max}, V_{\\max}]$ and discretized, conservation is generally broken and depends sensitively on boundary conditions applied at $v = \\pm V_{\\max}$.\n\nYour task is to:\n\n1. Derive from first principles how velocity-space truncation and different boundary conditions affect discrete particle conservation for the linearized operator $\\mathcal{C}[\\delta f]$ on the truncated domain. Begin from the conservation form of the operator and the relation between total particle change and boundary fluxes. Explain why truncation and boundary conditions such as Dirichlet, Neumann, and zero-flux Robin lead to different conservation properties.\n\n2. Propose and justify a correction strategy that restores particle conservation without compromising stability. The correction must be derived from the requirement of zero net boundary flux and must preserve the self-adjoint negative semi-definite character of the discrete operator in the weighted energy norm associated with the flux form. Provide mathematical reasoning for stability.\n\n3. Implement a program that, for a specified set of test cases, computes the discrete non-conservation error both before and after applying your correction strategy. Use a finite-volume interpretation of the discrete divergence, so that the net particle change equals the difference of the boundary fluxes. For the perturbation, use\n$$\n\\delta f(v) = \\epsilon\\, f_0(v)\\, H_3\\!\\left(\\frac{v}{v_{\\mathrm{th}}}\\right),\n$$\nwhere $H_3(\\xi) = \\xi^3 - 3\\xi$ is the third probabilists' Hermite polynomial and $\\epsilon$ is a small amplitude. Set $\\nu = 1, v_{\\mathrm{th}} = 1$, and $D = 1$ to work in dimensionless units so that all quantities are dimensionless.\n\nDefine the discrete boundary fluxes in terms of boundary conditions at $v = \\pm V_{\\max}$ as follows:\n- Dirichlet: impose $\\delta f(\\pm V_{\\max}) = 0$ and approximate $\\frac{\\partial \\delta f}{\\partial v}$ at the boundaries using one-sided second-order finite differences based on interior points and the prescribed boundary value.\n- Neumann: impose $\\frac{\\partial \\delta f}{\\partial v}(\\pm V_{\\max}) = 0$; approximate the boundary value by extrapolation from interior points and set the derivative to zero in the flux.\n- Zero-flux Robin (correction): enforce $J(\\pm V_{\\max}, f) = 0$, i.e.,\n$$\n\\frac{\\partial f}{\\partial v}(\\pm V_{\\max}) = -\\frac{\\nu}{D}\\, (\\pm V_{\\max})\\, f(\\pm V_{\\max}),\n$$\nand take the boundary fluxes to be identically zero.\n\nFor each test case, compute the pre-correction error\n$$\nE_{\\mathrm{pre}} = J(V_{\\max}, f) - J(-V_{\\max}, f),\n$$\nusing the specified boundary condition, and the post-correction error\n$$\nE_{\\mathrm{post}} = 0,\n$$\nunder the zero-flux correction.\n\nAll computations are dimensionless.\n\nTest suite:\n- Case 1 (happy path): $V_{\\max} = 5$, $N = 200$ grid points, $\\epsilon = 0.1$, Dirichlet boundary conditions.\n- Case 2 (edge small domain): $V_{\\max} = 2$, $N = 50$ grid points, $\\epsilon = 0.1$, Dirichlet boundary conditions.\n- Case 3 (alternative boundary): $V_{\\max} = 5$, $N = 200$ grid points, $\\epsilon = 0.1$, Neumann boundary conditions.\n- Case 4 (correction baseline): $V_{\\max} = 5$, $N = 200$ grid points, $\\epsilon = 0.1$, zero-flux Robin boundary conditions.\n- Case 5 (coarse grid): $V_{\\max} = 3$, $N = 21$ grid points, $\\epsilon = 0.1$, Dirichlet boundary conditions.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where for each test case you append the two floats $E_{\\mathrm{pre}}$ and $E_{\\mathrm{post}}$ in that order. For example, the output format must be\n$$\n[ E_{\\mathrm{pre}}^{(1)}, E_{\\mathrm{post}}^{(1)}, E_{\\mathrm{pre}}^{(2)}, E_{\\mathrm{post}}^{(2)}, \\ldots, E_{\\mathrm{pre}}^{(5)}, E_{\\mathrm{post}}^{(5)} ].\n$$",
            "solution": "The problem requires a three-part response: first, a derivation of how domain truncation and boundary conditions affect particle conservation for a linearized Fokker–Planck operator; second, the proposal and justification of a conservation-restoring correction; and third, a numerical implementation to quantify the conservation error.\n\n**1. Particle Conservation on a Truncated Domain**\n\nThe total number of particles, $N$, in the one-dimensional velocity domain truncated to $[-V_{\\max}, V_{\\max}]$ is given by the integral of the distribution function $f(v,t)$:\n$$\nN(t) = \\int_{-V_{\\max}}^{V_{\\max}} f(v, t) \\, dv\n$$\nThe rate of change of the total particle number is found by differentiating with respect to time, $t$:\n$$\n\\frac{dN}{dt} = \\frac{d}{dt} \\int_{-V_{\\max}}^{V_{\\max}} f(v, t) \\, dv = \\int_{-V_{\\max}}^{V_{\\max}} \\frac{\\partial f}{\\partial t} \\, dv\n$$\nThe time evolution of the distribution function is governed by the Fokker–Planck equation, $\\frac{\\partial f}{\\partial t} = \\mathcal{C}[f](v)$, where the collisional operator $\\mathcal{C}[f](v)$ is given by the divergence of the particle flux $J(v,f)$. In one dimension, this is $\\mathcal{C}[f](v) = \\frac{\\partial}{\\partial v} J(v,f)$. Substituting this into the previous equation yields:\n$$\n\\frac{dN}{dt} = \\int_{-V_{\\max}}^{V_{\\max}} \\frac{\\partial}{\\partial v} J(v,f) \\, dv\n$$\nBy the fundamental theorem of calculus, this integral evaluates to the difference in the flux at the boundaries of the domain:\n$$\n\\frac{dN}{dt} = J(V_{\\max}, f) - J(-V_{\\max}, f)\n$$\nThis equation is the cornerstone of particle conservation analysis. It states that the total number of particles within the domain is conserved if and only if the net flux across the boundaries is zero. For the linearized problem, we consider a perturbation $f = f_0 + \\delta f$. The background Maxwellian $f_0$ has zero flux, $J(v, f_0) = 0$, due to the condition $D = \\nu v_{\\mathrm{th}}^2$. Therefore, the total flux is $J(v, f) = J(v, f_0) + J(v, \\delta f) = J(v, \\delta f)$. The rate of change of the number of perturbed particles, $\\delta N = \\int \\delta f dv$, is then:\n$$\n\\frac{d(\\delta N)}{dt} = J(V_{\\max}, \\delta f) - J(-V_{\\max}, \\delta f)\n$$\nwhere the flux for the perturbation is $J(v, \\delta f) = \\nu v \\delta f(v) + D \\frac{\\partial \\delta f}{\\partial v}(v)$. Consequently, discrete particle conservation depends entirely on how the boundary conditions imposed at $v = \\pm V_{\\max}$ determine the boundary fluxes.\n\n- **Dirichlet Boundary Conditions**: We impose $\\delta f(\\pm V_{\\max}) = 0$. The flux at the right boundary becomes $J(V_{\\max}, \\delta f) = \\nu V_{\\max} \\cdot 0 + D \\frac{\\partial \\delta f}{\\partial v}(V_{\\max}) = D \\frac{\\partial \\delta f}{\\partial v}(V_{\\max})$. Similarly, at the left boundary, $J(-V_{\\max}, \\delta f) = D \\frac{\\partial \\delta f}{\\partial v}(-V_{\\max})$. For a general perturbation $\\delta f$, the derivatives at the boundaries are not guaranteed to be zero or equal. Thus, $J(V_{\\max}, \\delta f) - J(-V_{\\max}, \\delta f)$ is generally non-zero, leading to a violation of particle number conservation.\n\n- **Neumann Boundary Conditions**: We impose $\\frac{\\partial \\delta f}{\\partial v}(\\pm V_{\\max}) = 0$. The flux at the right boundary becomes $J(V_{\\max}, \\delta f) = \\nu V_{\\max} \\delta f(V_{\\max}) + D \\cdot 0 = \\nu V_{\\max} \\delta f(V_{\\max})$. At the left boundary, it is $J(-V_{\\max}, \\delta f) = -\\nu V_{\\max} \\delta f(-V_{\\max})$. Particle conservation requires $J(V_{\\max}, \\delta f) = J(-V_{\\max}, \\delta f)$, which simplifies to $V_{\\max} \\delta f(V_{\\max}) = -V_{\\max} \\delta f(-V_{\\max})$, or $\\delta f(V_{\\max}) = -\\delta f(-V_{\\max})$. This condition is satisfied if the perturbation $\\delta f$ is an odd function of $v$. The specified test perturbation $\\delta f(v) = \\epsilon f_0(v) H_3(v/v_{\\mathrm{th}})$ is an odd function, as $f_0(v)$ is even and the Hermite polynomial $H_3(\\xi) = \\xi^3 - 3\\xi$ is odd. Therefore, for this specific perturbation, Neumann boundary conditions should be particle-conserving, provided the numerical extrapolation of $\\delta f$ at the boundaries preserves this symmetry. For an arbitrary perturbation (e.g., one with both even and odd components), Neumann conditions do not guarantee conservation.\n\n**2. Conservation-Restoring Correction and Stability Analysis**\n\nThe analysis above directly points to the correction strategy: to ensure particle conservation, the boundary conditions must enforce zero net flux.\n\n- **Proposed Correction**: The most direct way to enforce particle conservation is to impose zero-flux boundary conditions, $J(\\pm V_{\\max}, \\delta f) = 0$. This is a type of Robin boundary condition:\n$$\n\\nu (\\pm V_{\\max}) \\delta f(\\pm V_{\\max}) + D \\frac{\\partial \\delta f}{\\partial v}(\\pm V_{\\max}) = 0\n$$\nWith these conditions, the net flux $J(V_{\\max}, \\delta f) - J(-V_{\\max}, \\delta f) = 0 - 0 = 0$, and particle number is conserved by construction at the semi-discrete level. This condition is physically motivated, as it corresponds to reflecting boundaries in velocity space from which no particles can escape.\n\n- **Justification and Stability**: The proposed zero-flux boundary condition not only enforces conservation but also preserves the desirable mathematical structure of the collision operator. The linearized operator $\\mathcal{C}$ is self-adjoint and negative semi-definite in a weighted inner product space, which guarantees the stability of the time-dependent solution. To prove this, we use the weighted inner product $\\langle g, h \\rangle_{w} = \\int_{-V_{\\max}}^{V_{\\max}} g(v)h(v) w(v) dv$ with weight $w(v) = 1/f_0(v)$.\n\nFirst, we rewrite the flux $J(v, \\delta f)$ using the fact that $J(v, f_0)=0$:\n$$\nJ(v, \\delta f) = \\nu v \\delta f + D \\frac{\\partial \\delta f}{\\partial v} = D\\left( \\frac{\\nu v_{\\mathrm{th}}^2}{D} \\frac{v}{v_{\\mathrm{th}}^2} \\delta f + \\frac{\\partial \\delta f}{\\partial v} \\right) = D f_0 \\left( \\frac{-\\frac{v}{v_{\\mathrm{th}}^2} \\delta f}{f_0} + \\frac{1}{f_0}\\frac{\\partial \\delta f}{\\partial v} \\right) = D f_0 \\frac{\\partial}{\\partial v}\\left(\\frac{\\delta f}{f_0}\\right)\n$$\nNow we examine the inner product of $\\mathcal{C}[\\delta f]$ with an arbitrary test function $\\delta g$:\n$$\n\\langle \\mathcal{C}[\\delta f], \\delta g \\rangle_{f_0^{-1}} = \\int_{-V_{\\max}}^{V_{\\max}} \\left(\\frac{\\partial J}{\\partial v}(\\delta f)\\right) \\frac{\\delta g}{f_0} dv\n$$\nIntegrating by parts:\n$$\n= \\left[ J(v, \\delta f) \\frac{\\delta g(v)}{f_0(v)} \\right]_{-V_{\\max}}^{V_{\\max}} - \\int_{-V_{\\max}}^{V_{\\max}} J(v, \\delta f) \\frac{\\partial}{\\partial v}\\left(\\frac{\\delta g}{f_0}\\right) dv\n$$\nThe zero-flux boundary condition, $J(\\pm V_{\\max}, \\delta f) = 0$, makes the boundary term vanish. Substituting the alternative expression for the flux into the remaining integral:\n$$\n= - \\int_{-V_{\\max}}^{V_{\\max}} \\left(D f_0 \\frac{\\partial}{\\partial v}\\left(\\frac{\\delta f}{f_0}\\right)\\right) \\frac{\\partial}{\\partial v}\\left(\\frac{\\delta g}{f_0}\\right) dv = -D \\int_{-V_{\\max}}^{V_{\\max}} f_0 \\left(\\frac{\\partial}{\\partial v}\\frac{\\delta f}{f_0}\\right) \\left(\\frac{\\partial}{\\partial v}\\frac{\\delta g}{f_0}\\right) dv\n$$\nThis final expression is symmetric with respect to $\\delta f$ and $\\delta g$, proving that the operator $\\mathcal{C}$ is self-adjoint in this weighted space: $\\langle \\mathcal{C}[\\delta f], \\delta g \\rangle_{f_0^{-1}} = \\langle \\delta f, \\mathcal{C}[\\delta g] \\rangle_{f_0^{-1}}$.\n\nFor negative semi-definiteness, we set $\\delta g = \\delta f$:\n$$\n\\langle \\mathcal{C}[\\delta f], \\delta f \\rangle_{f_0^{-1}} = -D \\int_{-V_{\\max}}^{V_{\\max}} f_0(v) \\left( \\frac{\\partial}{\\partial v}\\left(\\frac{\\delta f}{f_0}\\right) \\right)^2 dv\n$$\nSince $D > 0$, $f_0(v) > 0$, and the squared term is non-negative, the integrand is non-negative. Therefore, the integral is greater than or equal to zero, and the entire expression is less than or equal to zero: $\\langle \\mathcal{C}[\\delta f], \\delta f \\rangle_{f_0^{-1}} \\le 0$. This proves that the operator is negative semi-definite, which ensures that solutions to $\\frac{\\partial \\delta f}{\\partial t} = \\mathcal{C}[\\delta f]$ do not grow in time in the associated energy norm, guaranteeing stability.\n\n**3. Numerical Implementation**\n\nThe following program implements the calculation of the pre-correction non-conservation error, $E_{\\mathrm{pre}}$, for the specified boundary conditions and test cases. The post-correction error, $E_{\\mathrm{post}}$, is always $0$ by definition of the correction strategy.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the discrete non-conservation error for a linearized Fokker-Planck\n    operator under different boundary conditions and a proposed correction.\n    \"\"\"\n    \n    # Test suite from the problem statement\n    test_cases = [\n        # (V_max, N, epsilon, boundary_condition_type)\n        (5.0, 200, 0.1, \"Dirichlet\"),\n        (2.0, 50, 0.1, \"Dirichlet\"),\n        (5.0, 200, 0.1, \"Neumann\"),\n        (5.0, 200, 0.1, \"Zero-flux Robin\"),\n        (3.0, 21, 0.1, \"Dirichlet\"),\n    ]\n\n    results = []\n\n    # Dimensionless parameters\n    nu = 1.0\n    v_th = 1.0\n    D = 1.0  # D = nu * v_th**2\n\n    # Helper functions for the distribution\n    def f0(v, v_th_val):\n        return (1.0 / (np.sqrt(2.0 * np.pi) * v_th_val)) * np.exp(-v**2 / (2.0 * v_th_val**2))\n\n    def H3(xi):\n        return xi**3 - 3.0 * xi\n\n    def delta_f(v, v_th_val, eps):\n        xi = v / v_th_val\n        return eps * f0(v, v_th_val) * H3(xi)\n\n    for V_max, N, epsilon, bc_type in test_cases:\n        # 1. Setup grid and evaluate the perturbation\n        v_grid = np.linspace(-V_max, V_max, N)\n        dv = v_grid[1] - v_grid[0]\n        \n        # Evaluate delta_f on all grid points\n        df_vals = delta_f(v_grid, v_th, epsilon)\n\n        J_plus = 0.0\n        J_minus = 0.0\n\n        # 2. Compute boundary fluxes based on a given BC type\n        if bc_type == \"Dirichlet\":\n            # BC imposes delta_f(+/- V_max) = 0.\n            # J = nu*v*delta_f + D*d(delta_f)/dv\n            # The delta_f term is zero at the boundary.\n            \n            # Right boundary flux at v = V_max\n            # Use second-order one-sided difference for derivative, with delta_f(V_max)=0\n            # d(df)/dv approx (3*df(v_N-1) - 4*df(v_N-2) + df(v_N-3)) / (2*dv)\n            # with df(v_N-1) = 0\n            df_deriv_plus = (-4.0 * df_vals[-2] + df_vals[-3]) / (2.0 * dv)\n            J_plus = D * df_deriv_plus\n\n            # Left boundary flux at v = -V_max\n            # d(df)/dv approx (-3*df(v_0) + 4*df(v_1) - df(v_2)) / (2*dv)\n            # with df(v_0) = 0\n            df_deriv_minus = (4.0 * df_vals[1] - df_vals[2]) / (2.0 * dv)\n            J_minus = D * df_deriv_minus\n\n        elif bc_type == \"Neumann\":\n            # BC imposes d(delta_f)/dv (+/- V_max) = 0.\n            # J = nu*v*delta_f + D*d(delta_f)/dv\n            # The derivative term is zero at the boundary.\n            \n            # Value of delta_f at the boundary must be extrapolated from interior points\n            # such that the numerical derivative is zero.\n            # From (3*df(v_N-1) - 4*df(v_N-2) + df(v_N-3)) / (2*dv) = 0\n            df_at_plus = (4.0 / 3.0) * df_vals[-2] - (1.0 / 3.0) * df_vals[-3]\n            \n            # From (-3*df(v_0) + 4*df(v_1) - df(v_2)) / (2*dv) = 0\n            df_at_minus = (4.0 / 3.0) * df_vals[1] - (1.0 / 3.0) * df_vals[2]\n            \n            J_plus = nu * V_max * df_at_plus\n            J_minus = nu * (-V_max) * df_at_minus\n            \n        elif bc_type == \"Zero-flux Robin\":\n            # The boundary condition itself is J(+/- V_max) = 0.\n            # This is the conservation-enforcing condition.\n            J_plus = 0.0\n            J_minus = 0.0\n\n        # 3. Compute pre- and post-correction errors\n        # As per the problem, the total distribution is f = f0 + delta_f.\n        # The flux J(v,f) = J(v, f0) + J(v, delta_f).\n        # Since J(v, f0) = 0, the total flux is just J(v, delta_f).\n        E_pre = J_plus - J_minus\n        \n        # The correction strategy is to enforce zero-flux boundary conditions,\n        # which by definition results in a zero net flux.\n        E_post = 0.0\n        \n        results.append(E_pre)\n        results.append(E_post)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}