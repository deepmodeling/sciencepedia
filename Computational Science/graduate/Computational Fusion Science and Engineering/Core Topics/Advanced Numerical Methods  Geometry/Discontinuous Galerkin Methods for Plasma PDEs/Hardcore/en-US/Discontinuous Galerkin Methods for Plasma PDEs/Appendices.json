{
    "hands_on_practices": [
        {
            "introduction": "In the Discontinuous Galerkin (DG) method, integrals in the weak form are evaluated numerically using quadrature rules. This exercise  probes the theoretical underpinnings of this process, focusing on the concept of *degree of exactness* for the widely used Gauss and Gauss-Lobatto quadrature. By deriving these properties from first principles, you will gain a fundamental understanding of how to select an appropriate quadrature rule to ensure that polynomial terms, such as those in a mass matrix, are integrated exactly.",
            "id": "3967443",
            "problem": "Consider a one-dimensional reference element $\\Omega_{r} = [-1,1]$ used in a Discontinuous Galerkin (DG) discretization of a scalar conservation law relevant to collisionless plasma dynamics, for example a configuration-space advection term in the Vlasov equation, a Partial Differential Equation (PDE) of the form $\\partial_{t} f + \\partial_{x}(a f) = 0$ with a constant advection speed $a$. On each element, the approximate solution $f_{h}(x,t)$ and a test function $\\phi_{h}(x)$ are polynomials of degree at most $p$ in $x$, i.e., they belong to a finite-dimensional space $\\mathcal{P}_{p}(\\Omega_{r})$. In forming the DG weak form, volume contributions require the exact evaluation of integrals of the form\n$$\nI = \\int_{-1}^{1} f_{h}(x,t)\\,\\phi_{h}(x)\\,\\mathrm{d}x,\n$$\nwhich, under an affine mapping from a physical cell to $\\Omega_{r}$, have an integrand that is a polynomial of degree at most $2p$. You are to rely on the foundational properties of polynomial quadrature rules built from the orthogonality of Legendre polynomials on $\\Omega_{r}$ with weight $w(x) = 1$.\n\nUsing only these foundational properties, and without invoking any pre-stated shortcut formulas, do the following:\n\n1. Derive and state the degree-of-exactness conditions for an $n$-point Gauss quadrature rule on $\\Omega_{r}$ with weight $w(x) = 1$, and for an $n$-point Gauss–Lobatto quadrature rule on $\\Omega_{r}$ with the same weight, where the Gauss–Lobatto rule includes the endpoints $x=-1$ and $x=1$ among its nodes.\n\n2. From your derived exactness conditions, determine the minimum number of quadrature points $n$ required so that each rule exactly integrates the product of two degree-$p$ polynomials on $\\Omega_{r}$, i.e., any integrand in $\\mathcal{P}_{2p}(\\Omega_{r})$.\n\nExpress your final answers for the two minimum $n$ values as a single row matrix. No rounding is required, and no units are involved.",
            "solution": "The problem as stated is scientifically grounded, well-posed, objective, and self-contained. It presents a standard, non-trivial question in the field of numerical analysis, specifically concerning the application of quadrature rules within the Discontinuous Galerkin (DG) method. All terms are clearly defined, and the premises are consistent with established mathematical principles. The problem is therefore deemed valid and a formal solution can be constructed.\n\nThe problem requires the derivation of properties for two types of quadrature rules on the reference interval $\\Omega_{r} = [-1,1]$ with a weight function $w(x) = 1$. The goal is to determine the minimum number of points, $n$, for each rule to exactly integrate a polynomial of degree at most $2p$. An $n$-point quadrature rule approximates an integral as a weighted sum:\n$$\n\\int_{-1}^{1} g(x)\\,\\mathrm{d}x \\approx \\sum_{i=1}^{n} w_i g(x_i)\n$$\nwhere $x_i$ are the quadrature nodes and $w_i$ are the corresponding weights. The rule is said to have a degree of exactness of $d$ if it computes the integral exactly for any polynomial $g(x)$ of degree at most $d$, but not for some polynomial of degree $d+1$. An $n$-point rule has $2n$ free parameters ($n$ nodes and $n$ weights), suggesting a maximum possible degree of exactness of $2n-1$.\n\n**1. Derivation of Degree-of-Exactness Conditions**\n\n**Gauss Quadrature (Gauss-Legendre)**\n\nFor a standard $n$-point Gauss quadrature, all $n$ nodes and $n$ weights are chosen to maximize the degree of exactness. The foundational principle for this is the use of orthogonal polynomials. For the weight function $w(x) = 1$ on $[-1,1]$, the relevant orthogonal polynomials are the Legendre polynomials, $L_k(x)$. They satisfy the orthogonality condition:\n$$\n\\int_{-1}^{1} L_j(x) L_k(x) \\,\\mathrm{d}x = \\frac{2}{2k+1} \\delta_{jk}\n$$\nwhere $\\delta_{jk}$ is the Kronecker delta.\n\nThe core idea of Gauss quadrature is to select the $n$ nodes $x_i$ as the roots of the $n$-th degree Legendre polynomial, $L_n(x)$. These roots are all real, distinct, and lie within the interval $(-1,1)$.\n\nLet $P(x)$ be any polynomial of degree at most $2n-1$. We can perform polynomial division of $P(x)$ by $L_n(x)$ to obtain:\n$$\nP(x) = Q(x) L_n(x) + R(x)\n$$\nwhere the quotient $Q(x)$ and the remainder $R(x)$ are both polynomials of degree at most $n-1$.\n\nEvaluating the integral of $P(x)$:\n$$\n\\int_{-1}^{1} P(x) \\,\\mathrm{d}x = \\int_{-1}^{1} Q(x) L_n(x) \\,\\mathrm{d}x + \\int_{-1}^{1} R(x) \\,\\mathrm{d}x\n$$\nSince $Q(x)$ is a polynomial of degree at most $n-1$, it can be expressed as a linear combination of Legendre polynomials $L_0(x), \\dots, L_{n-1}(x)$. Due to the orthogonality of Legendre polynomials, the first integral on the right-hand side is zero:\n$$\n\\int_{-1}^{1} Q(x) L_n(x) \\,\\mathrm{d}x = 0\n$$\nThus, the exact integral is simply $\\int_{-1}^{1} P(x) \\,\\mathrm{d}x = \\int_{-1}^{1} R(x) \\,\\mathrm{d}x$.\n\nNow, let's evaluate the quadrature sum for $P(x)$:\n$$\n\\sum_{i=1}^{n} w_i P(x_i) = \\sum_{i=1}^{n} w_i \\left( Q(x_i) L_n(x_i) + R(x_i) \\right)\n$$\nBy construction, the nodes $x_i$ are the roots of $L_n(x)$, so $L_n(x_i) = 0$ for all $i=1, \\dots, n$. The sum simplifies to:\n$$\n\\sum_{i=1}^{n} w_i P(x_i) = \\sum_{i=1}^{n} w_i R(x_i)\n$$\nThe $n$ weights $w_i$ are chosen to make the quadrature rule exact for all polynomials of degree up to $n-1$. With this choice, the quadrature sum for $R(x)$ (a polynomial of degree at most $n-1$) is exact:\n$$\n\\sum_{i=1}^{n} w_i R(x_i) = \\int_{-1}^{1} R(x)\\,\\mathrm{d}x\n$$\nCombining these results, we find that for any polynomial $P(x)$ of degree at most $2n-1$:\n$$\n\\int_{-1}^{1} P(x) \\,\\mathrm{d}x = \\sum_{i=1}^{n} w_i P(x_i)\n$$\nThis shows that the rule is exact. To prove this is the maximal degree, consider $P(x) = (L_n(x))^2$, which is a polynomial of degree $2n$. The exact integral is $\\int_{-1}^{1} (L_n(x))^2 \\,\\mathrm{d}x  0$. However, the quadrature sum is $\\sum w_i (L_n(x_i))^2 = 0$ since $L_n(x_i)=0$. Thus, the rule is not exact for degree $2n$.\n\n*   **Degree-of-Exactness for Gauss Quadrature:** An $n$-point Gauss quadrature rule is exact for all polynomials of degree up to $2n-1$.\n\n**Gauss–Lobatto Quadrature**\n\nFor an $n$-point Gauss-Lobatto quadrature, two nodes are fixed at the endpoints, $x_1 = -1$ and $x_n = 1$. This leaves $n-2$ interior nodes and all $n$ weights as free parameters, for a total of $2n-2$ degrees of freedom. We thus expect a maximal degree of exactness of $2n-3$.\n\nThe foundational principle is to choose the $n-2$ interior nodes to be the roots of the derivative of the $(n-1)$-th degree Legendre polynomial, $L'_{n-1}(x)$. $L'_{n-1}(x)$ is a polynomial of degree $n-2$ with distinct roots in $(-1,1)$. The full set of $n$ nodes are the roots of the polynomial $(x^2-1)L'_{n-1}(x)$.\n\nLet $P(x)$ be any polynomial of degree at most $2n-3$. Consider its interpolating polynomial, $q_{n-1}(x)$, of degree at most $n-1$ that passes through the $n$ Gauss-Lobatto nodes (i.e., $P(x_i) = q_{n-1}(x_i)$ for $i=1, \\dots, n$). The difference $P(x) - q_{n-1}(x)$ is a polynomial of degree at most $2n-3$ that is zero at all $n$ nodes. Therefore, it can be written as:\n$$\nP(x) - q_{n-1}(x) = (x^2-1)L'_{n-1}(x) C(x)\n$$\nwhere $C(x)$ is a polynomial. The degree of $(x^2-1)L'_{n-1}(x)$ is $2+(n-2) = n$. Since the degree of the left side is at most $2n-3$, the degree of $C(x)$ is at most $(2n-3) - n = n-3$.\n\nThe error of the quadrature rule is given by:\n$$\nE[P] = \\int_{-1}^{1} P(x) \\,\\mathrm{d}x - \\sum_{i=1}^{n} w_i P(x_i)\n$$\nThe weights $w_i$ are defined to make the rule exact for all polynomials of degree up to $n-1$. Since $q_{n-1}(x)$ has degree at most $n-1$ and $P(x_i)=q_{n-1}(x_i)$,\n$$\n\\sum_{i=1}^{n} w_i P(x_i) = \\sum_{i=1}^{n} w_i q_{n-1}(x_i) = \\int_{-1}^{1} q_{n-1}(x) \\,\\mathrm{d}x\n$$\nThe error becomes:\n$$\nE[P] = \\int_{-1}^{1} (P(x) - q_{n-1}(x)) \\,\\mathrm{d}x = \\int_{-1}^{1} (x^2-1)L'_{n-1}(x) C(x) \\,\\mathrm{d}x\n$$\nTo evaluate this integral, we use integration by parts with $u = (x^2-1)C(x)$ and $dv = L'_{n-1}(x)dx$, so $v = L_{n-1}(x)$.\n$$\nE[P] = \\left[ (x^2-1)C(x)L_{n-1}(x) \\right]_{-1}^{1} - \\int_{-1}^{1} L_{n-1}(x) \\frac{d}{dx}\\left((x^2-1)C(x)\\right) \\,\\mathrm{d}x\n$$\nThe boundary term is zero because of the $(x^2-1)$ factor. The derivative $\\frac{d}{dx}((x^2-1)C(x))$ is a polynomial. The degree of $(x^2-1)C(x)$ is at most $2 + (n-3) = n-1$. Thus, its derivative has degree at most $n-2$. By the orthogonality property of Legendre polynomials, the integral of $L_{n-1}(x)$ against any polynomial of degree less than $n-1$ is zero. Therefore, the error integral is zero.\nThis proves the rule is exact for any polynomial $P(x)$ of degree up to $2n-3$. A polynomial of degree $2n-2$, such as $(x^2-1)(L'_{n-1}(x))^2$, can be shown to not be integrated exactly.\n\n*   **Degree-of-Exactness for Gauss-Lobatto Quadrature:** An $n$-point Gauss-Lobatto quadrature rule is exact for all polynomials of degree up to $2n-3$.\n\n**2. Minimum Number of Quadrature Points**\n\nThe problem requires the exact integration of the product of two polynomials of degree at most $p$. The resulting integrand, $f_h \\phi_h$, is a polynomial of degree at most $p+p=2p$. Therefore, the quadrature rule must have a degree of exactness of at least $2p$.\n\n**For Gauss Quadrature:**\nWe require the degree of exactness to be at least $2p$. Using the derived condition:\n$$\n2n-1 \\ge 2p\n$$\nSolving for $n$:\n$$\n2n \\ge 2p + 1\n$$\n$$\nn \\ge p + \\frac{1}{2}\n$$\nSince the number of points $n$ must be an integer, the minimum number of points required is:\n$$\nn_{Gauss} = \\lceil p + 0.5 \\rceil = p+1\n$$\n\n**For Gauss–Lobatto Quadrature:**\nWe again require the degree of exactness to be at least $2p$. Using the derived condition:\n$$\n2n-3 \\ge 2p\n$$\nSolving for $n$:\n$$\n2n \\ge 2p+3\n$$\n$$\nn \\ge p + \\frac{3}{2}\n$$\nSince $n$ must be an integer, the minimum number of points required is:\n$$\nn_{Lobatto} = \\lceil p + 1.5 \\rceil = p+2\n$$\n\nThe final answer is the pair of minimum values for $n$, for the Gauss and Gauss-Lobatto rules, respectively.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} p+1  p+2 \\end{pmatrix} } $$"
        },
        {
            "introduction": "This practice  moves from the abstract theory of quadrature to its concrete application in assembling the building blocks of a DG solver. You will first derive the specific nodes and weights for a low-order case ($p=2$) and then use them to construct an element mass matrix, directly illustrating the powerful concept of mass lumping that arises in nodal DG methods. The exercise extends this skill to evaluating a surface integral, a common and essential step for computing numerical fluxes across element boundaries.",
            "id": "3967527",
            "problem": "In a high-order Discontinuous Galerkin (DG) discretization of a plasma Partial Differential Equation (PDE) relevant to computational fusion science and engineering, consider a one-dimensional reference element $\\hat{K}=[-1,1]$ with a nodal Lagrange basis of polynomial degree $p=2$. The nodes are chosen to coincide with the Gauss–Lobatto–Legendre (GLL) quadrature nodes, and the same GLL rule is used to assemble element integrals in the Discontinuous Galerkin Spectral Element Method (DGSEM).\n\nTask 1 (GLL quadrature on the reference element): Starting from the defining properties of GLL quadrature—namely, inclusion of the endpoints of the interval and exactness for polynomials up to degree $2N-3$ for $N$ nodes—derive the nodes and weights for the case $p=2$ (so $N=p+1=3$) on $\\hat{K}=[-1,1]$. Do not invoke pre-tabulated formulas; instead, determine the interior node using the derivative of the Legendre polynomial of degree $p$ and determine the weights by enforcing exactness on monomials.\n\nTask 2 (DGSEM mass matrix assembly): Let $\\{\\ell_i(s)\\}_{i=0}^{2}$ be the nodal Lagrange basis built at the GLL nodes on $\\hat{K}$. Using the GLL quadrature from Task 1 to approximate integrals, assemble the quadrature-based element mass matrix $\\mathbf{M}$ with entries\n$$\nM_{ij}\\equiv \\int_{-1}^{1}\\ell_i(s)\\,\\ell_j(s)\\,\\mathrm{d}s\n$$\napproximated by the GLL rule from Task 1. Compute $\\det(\\mathbf{M})$.\n\nTask 3 (Surface integral with curved geometry relevant to DG fluxes): Consider a curved boundary segment $\\Gamma$ in the poloidal cross-section of a tokamak, modeled as a circular arc of radius $R$ and central angle $\\Theta$ (in radians), with arc length $L=R\\,\\Theta$. Let the mapping from the reference coordinate $s\\in[-1,1]$ to $\\Gamma$ be parameterized by arc length so that the geometric Jacobian is constant, $J_{\\Gamma}(s)=\\left|\\frac{\\mathrm{d}\\boldsymbol{r}}{\\mathrm{d}s}\\right|=\\frac{L}{2}$. Suppose the numerical flux density normal to $\\Gamma$ arising from a polynomial reconstruction of a gyrokinetic boundary operator is approximated on $\\Gamma$ by\n$$\nq(s)=\\alpha+\\beta\\,s+\\gamma\\,s^{2},\n$$\nwith coefficients $\\alpha=\\frac{5}{4}$, $\\beta=-\\frac{3}{2}$, and $\\gamma=\\frac{7}{6}$. Using the same $N=3$ GLL quadrature from Task 1 in $s$, evaluate the surface integral\n$$\nI\\equiv \\int_{\\Gamma} q\\,\\mathrm{d}\\sigma \\;=\\;\\int_{-1}^{1} q(s)\\,J_{\\Gamma}(s)\\,\\mathrm{d}s.\n$$\nYou may assume $R0$ and $\\Theta0$ are physically realistic, but you must keep the answer symbolic in terms of $L$ when appropriate.\n\nFinal quantity to report: Compute\n$$\nS\\equiv \\det(\\mathbf{M})+\\frac{I}{L}.\n$$\nExpress your final answer as a single simplified rational number with no units. No rounding is required. Angles are in radians.",
            "solution": "The problem statement is critically validated before any attempt at a solution.\n\n### Step 1: Extract Givens\n- **Context**: Discontinuous Galerkin (DG) discretization for a plasma Partial Differential Equation (PDE) in computational fusion science and engineering.\n- **Reference Element**: $\\hat{K} = [-1,1]$.\n- **Polynomial Degree**: $p=2$.\n- **Basis**: Nodal Lagrange basis.\n- **Quadrature Nodes**: Gauss–Lobatto–Legendre (GLL) nodes.\n- **Number of Nodes**: $N = p+1 = 3$.\n- **Integration Rule**: GLL quadrature corresponding to the $N=3$ nodes.\n- **Method**: Discontinuous Galerkin Spectral Element Method (DGSEM).\n\n- **Task 1: GLL Quadrature Derivation**\n  - Derive nodes and weights for $N=3$ GLL quadrature on $\\hat{K}=[-1,1]$.\n  - GLL Properties: Includes endpoints $[-1,1]$; exact for polynomials up to degree $2N-3$.\n  - Node Derivation Method: Interior node is a root of the derivative of the Legendre polynomial of degree $p=2$, i.e., $P_2'(s)$.\n  - Weight Derivation Method: Enforce exactness on monomials.\n\n- **Task 2: Mass Matrix Assembly**\n  - Basis Functions: Nodal Lagrange basis $\\{\\ell_i(s)\\}_{i=0}^{2}$ built at the GLL nodes.\n  - Mass Matrix Definition: $M_{ij} \\equiv \\int_{-1}^{1}\\ell_i(s)\\,\\ell_j(s)\\,\\mathrm{d}s$.\n  - Assembly Method: Approximate the integral using the GLL quadrature from Task 1.\n  - Required Calculation: $\\det(\\mathbf{M})$.\n\n- **Task 3: Surface Integral Calculation**\n  - Geometry: Circular arc $\\Gamma$ with radius $R$, central angle $\\Theta$, and arc length $L=R\\Theta$.\n  - Mapping: From reference coordinate $s \\in [-1,1]$ to $\\Gamma$.\n  - Jacobian: Constant, $J_{\\Gamma}(s) = \\frac{L}{2}$.\n  - Flux Function: $q(s) = \\alpha+\\beta\\,s+\\gamma\\,s^2$.\n  - Coefficients: $\\alpha=\\frac{5}{4}$, $\\beta=-\\frac{3}{2}$, $\\gamma=\\frac{7}{6}$.\n  - Integral Definition: $I \\equiv \\int_{\\Gamma} q\\,\\mathrm{d}\\sigma = \\int_{-1}^{1} q(s)\\,J_{\\Gamma}(s)\\,\\mathrm{d}s$.\n  - Integration Method: Use the $N=3$ GLL quadrature from Task 1.\n\n- **Final Quantity**: $S \\equiv \\det(\\mathbf{M})+\\frac{I}{L}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the established criteria:\n- **Scientifically Grounded**: The problem is well-grounded in the theory of numerical methods, specifically the Discontinuous Galerkin method using spectral elements and Gauss-Lobatto-Legendre quadrature. These are standard and widely used techniques in computational science and engineering, including for plasma physics simulations in fusion research. All concepts are mathematically sound.\n- **Well-Posed**: The problem is structured as a sequence of well-defined tasks. Each task has a clear objective and sufficient information for a unique solution. The final quantity $S$ is a deterministic combination of the results from the tasks.\n- **Objective**: The problem is stated in precise, objective, mathematical language. It is free of ambiguity, subjectivity, or opinion.\n- **Consistency and Completeness**: The provided information is self-consistent and sufficient. The degree $p=2$ correctly implies $N=3$ nodes. The methods for deriving the quadrature rule and assembling the matrix are explicitly prescribed. All necessary coefficients and functions are defined.\n- **Realism**: The setup is a standard, albeit simplified, representation of a calculation performed within a DG code. The use of a 1D reference element, GLL nodes, Lagrange basis, and numerical quadrature for mass and flux integrals is canonical. The constant Jacobian is a valid simplification for an arc parameterized by its normalized length.\n\n### Step 3: Verdict and Action\nThe problem is **valid** as it is scientifically sound, well-posed, objective, and self-contained. The solution process will now proceed.\n\n#### Task 1: GLL Quadrature Derivation for $p=2$ ($N=3$)\n\nFor a polynomial degree $p=2$, the number of GLL nodes is $N=p+1=3$. The GLL nodes on the reference interval $[-1,1]$ consist of the endpoints $s=-1$ and $s=1$, and the interior nodes are the roots of the derivative of the Legendre polynomial of degree $p$. Here, $p=2$.\n\nThe Legendre polynomial of degree $p=2$ is $P_2(s) = \\frac{1}{2}(3s^2-1)$.\nIts derivative is $P_2'(s) = 3s$.\nSetting the derivative to zero, $3s=0$, gives the single interior root $s=0$.\nThus, the three GLL nodes are $s_0 = -1$, $s_1 = 0$, and $s_2 = 1$.\n\nThe quadrature rule is $\\int_{-1}^{1} f(s)\\,\\mathrm{d}s \\approx \\sum_{i=0}^{2} w_i f(s_i)$. For $N=3$ nodes, this rule must be exact for all polynomials of degree up to $2N-3 = 2(3)-3 = 3$. We enforce this condition on the monomial basis $\\{1, s, s^2\\}$ to find the weights $w_0, w_1, w_2$.\n\nFor $f(s)=1$:\n$\\int_{-1}^{1} 1\\,\\mathrm{d}s = 2$.\nThe quadrature sum is $w_0 f(s_0) + w_1 f(s_1) + w_2 f(s_2) = w_0(1) + w_1(1) + w_2(1) = w_0+w_1+w_2$.\nSo, $w_0+w_1+w_2 = 2$.\n\nFor $f(s)=s$:\n$\\int_{-1}^{1} s\\,\\mathrm{d}s = 0$.\nThe quadrature sum is $w_0(-1) + w_1(0) + w_2(1) = -w_0+w_2$.\nSo, $-w_0+w_2 = 0 \\implies w_0 = w_2$.\n\nFor $f(s)=s^2$:\n$\\int_{-1}^{1} s^2\\,\\mathrm{d}s = \\left[\\frac{s^3}{3}\\right]_{-1}^{1} = \\frac{1}{3} - (-\\frac{1}{3}) = \\frac{2}{3}$.\nThe quadrature sum is $w_0(-1)^2 + w_1(0)^2 + w_2(1)^2 = w_0+w_2$.\nSo, $w_0+w_2 = \\frac{2}{3}$.\n\nWe now solve the system of linear equations:\n1. $w_0+w_1+w_2 = 2$\n2. $w_0 = w_2$\n3. $w_0+w_2 = \\frac{2}{3}$\n\nFrom (2) and (3), we have $2w_0 = \\frac{2}{3}$, which gives $w_0=\\frac{1}{3}$. Consequently, $w_2=\\frac{1}{3}$.\nSubstituting these into (1): $\\frac{1}{3} + w_1 + \\frac{1}{3} = 2 \\implies w_1 = 2 - \\frac{2}{3} = \\frac{4}{3}$.\nThe GLL quadrature nodes and weights for $N=3$ are:\nNodes: $s_0=-1, s_1=0, s_2=1$.\nWeights: $w_0=\\frac{1}{3}, w_1=\\frac{4}{3}, w_2=\\frac{1}{3}$.\n\n#### Task 2: DGSEM Mass Matrix Assembly\n\nThe element mass matrix entries are approximated using the GLL quadrature:\n$M_{ij} = \\int_{-1}^{1}\\ell_i(s)\\,\\ell_j(s)\\,\\mathrm{d}s \\approx \\sum_{k=0}^{2} w_k \\ell_i(s_k) \\ell_j(s_k)$.\nThe nodal Lagrange basis functions $\\{\\ell_i(s)\\}_{i=0}^2$ are defined by the property $\\ell_i(s_j) = \\delta_{ij}$, where $\\delta_{ij}$ is the Kronecker delta.\n\nUsing this property, the sum simplifies dramatically. The product $\\ell_i(s_k)\\ell_j(s_k)$ is non-zero only if $k=i$ and $k=j$. This can only happen if $i=j$.\nIf $i \\neq j$, $M_{ij} \\approx \\sum_{k=0}^{2} w_k (0) = 0$.\nIf $i = j$, the sum has only one non-zero term, which occurs when $k=i$:\n$M_{ii} \\approx \\sum_{k=0}^{2} w_k \\ell_i(s_k) \\ell_i(s_k) = w_i (\\ell_i(s_i))^2 = w_i(1)^2 = w_i$.\n\nThus, the quadrature-based mass matrix $\\mathbf{M}$ is a diagonal matrix whose entries are the quadrature weights. This is known as mass lumping and is a key feature of the DGSEM.\n$$\n\\mathbf{M} = \n\\begin{pmatrix}\nw_0  0  0 \\\\\n0  w_1  0 \\\\\n0  0  w_2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{1}{3}  0  0 \\\\\n0  \\frac{4}{3}  0 \\\\\n0  0  \\frac{1}{3}\n\\end{pmatrix}\n$$\nThe determinant of this diagonal matrix is the product of its diagonal elements:\n$\\det(\\mathbf{M}) = w_0 w_1 w_2 = \\left(\\frac{1}{3}\\right) \\left(\\frac{4}{3}\\right) \\left(\\frac{1}{3}\\right) = \\frac{4}{27}$.\n\n#### Task 3: Surface Integral Evaluation\n\nThe integral to evaluate is $I = \\int_{-1}^{1} q(s)\\,J_{\\Gamma}(s)\\,\\mathrm{d}s$. We are given $J_{\\Gamma}(s) = \\frac{L}{2}$.\nThe integrand is $q(s)J_{\\Gamma}(s) = \\frac{L}{2}(\\alpha+\\beta s+\\gamma s^2)$, which is a polynomial of degree $2$. Since the $N=3$ GLL rule is exact for polynomials up to degree $3$, the quadrature yields the exact integral value.\n$I = \\sum_{k=0}^{2} w_k q(s_k) J_{\\Gamma}(s_k) = \\frac{L}{2} \\sum_{k=0}^{2} w_k q(s_k)$.\n\nThe flux function is $q(s) = \\frac{5}{4} - \\frac{3}{2}s + \\frac{7}{6}s^2$. We evaluate it at the GLL nodes:\n$q(s_0) = q(-1) = \\frac{5}{4} - \\frac{3}{2}(-1) + \\frac{7}{6}(-1)^2 = \\frac{5}{4} + \\frac{3}{2} + \\frac{7}{6} = \\frac{15+18+14}{12} = \\frac{47}{12}$.\n$q(s_1) = q(0) = \\frac{5}{4}$.\n$q(s_2) = q(1) = \\frac{5}{4} - \\frac{3}{2}(1) + \\frac{7}{6}(1)^2 = \\frac{15-18+14}{12} = \\frac{11}{12}$.\n\nNow, we compute the sum:\n$\\sum_{k=0}^{2} w_k q(s_k) = w_0 q(s_0) + w_1 q(s_1) + w_2 q(s_2)$\n$= \\frac{1}{3}\\left(\\frac{47}{12}\\right) + \\frac{4}{3}\\left(\\frac{5}{4}\\right) + \\frac{1}{3}\\left(\\frac{11}{12}\\right)$\n$= \\frac{47}{36} + \\frac{20}{12} + \\frac{11}{36} = \\frac{47}{36} + \\frac{60}{36} + \\frac{11}{36} = \\frac{47+60+11}{36} = \\frac{118}{36} = \\frac{59}{18}$.\n\nSo, the integral $I$ is:\n$I = \\frac{L}{2} \\left(\\frac{59}{18}\\right) = \\frac{59L}{36}$.\n\nThe problem requires the quantity $\\frac{I}{L}$:\n$\\frac{I}{L} = \\frac{1}{L}\\left(\\frac{59L}{36}\\right) = \\frac{59}{36}$.\n\n#### Final Quantity Calculation\n\nThe final task is to compute $S \\equiv \\det(\\mathbf{M})+\\frac{I}{L}$.\nUsing the results from the previous tasks:\n$S = \\frac{4}{27} + \\frac{59}{36}$.\nTo sum these fractions, we find the least common multiple of the denominators $27 = 3^3$ and $36 = 2^2 \\times 3^2$. The LCM is $2^2 \\times 3^3 = 4 \\times 27 = 108$.\n$S = \\frac{4 \\times 4}{27 \\times 4} + \\frac{59 \\times 3}{36 \\times 3} = \\frac{16}{108} + \\frac{177}{108}$.\n$S = \\frac{16 + 177}{108} = \\frac{193}{108}$.\nThe numerator $193$ is a prime number, so the fraction is in its simplest form.",
            "answer": "$$\\boxed{\\frac{193}{108}}$$"
        },
        {
            "introduction": "This final practice  serves as a capstone, challenging you to build a complete numerical solver for a challenging problem in plasma physics: the Brio-Wu magnetohydrodynamics (MHD) shock tube. By implementing a finite-volume scheme (equivalent to a $p=0$ DG method), you will confront the practical aspects of solving a system of conservation laws, including the crucial choice of a numerical flux. This exercise provides a framework for comparing a simple, diffusive flux (Rusanov) with a more sophisticated entropy-satisfying one (HLLE) and quantifying their performance in capturing shocks and other complex wave phenomena.",
            "id": "3967471",
            "problem": "Consider the one-dimensional ideal Magnetohydrodynamics (MHD) equations for a shock tube with a constant longitudinal magnetic field. The unknown conserved state in each cell is the vector $q = [\\rho, \\rho u, \\rho v, \\rho w, B_y, B_z, E]$ where $\\rho$ is the mass density, $u, v, w$ are the velocity components, $B_y, B_z$ are the transverse magnetic field components, and $E$ is the total energy. The longitudinal magnetic field $B_x$ is uniform and constant. The primitive variables are $[\\rho, u, v, w, p, B_x, B_y, B_z]$ where the pressure $p$ is recovered from the conserved state via $p = (\\gamma - 1)\\left(E - \\tfrac{1}{2}\\rho(u^2+v^2+w^2) - \\tfrac{1}{2}(B_x^2 + B_y^2 + B_z^2)\\right)$ with adiabatic index $\\gamma  1$. The conservative form of the ideal MHD equations in one spatial dimension $x$ is\n$$\n\\frac{\\partial q}{\\partial t} + \\frac{\\partial F(q)}{\\partial x} = 0,\n$$\nwith flux $F(q) = [F_1, F_2, F_3, F_4, F_5, F_6, F_7]$ given by\n$$\nF_1 = \\rho u, \\quad F_2 = \\rho u^2 + p + \\tfrac{1}{2}(B_x^2 + B_y^2 + B_z^2) - B_x^2,\n$$\n$$\nF_3 = \\rho u v - B_x B_y, \\quad F_4 = \\rho u w - B_x B_z, \\quad F_5 = u B_y - v B_x, \\quad F_6 = u B_z - w B_x,\n$$\n$$\nF_7 = \\left(E + p + \\tfrac{1}{2}(B_x^2 + B_y^2 + B_z^2)\\right) u - B_x (u B_x + v B_y + w B_z).\n$$\nThe Brio–Wu shock tube initial condition is defined on the domain $x \\in [0,1]$ with a discontinuity at $x_0 = 0.5$. For $x  x_0$, the left state is\n$$\n\\rho_L = 1, \\quad u_L=v_L=w_L=0, \\quad p_L = 1, \\quad B_{x,L} = 0.75, \\quad B_{y,L} = 1, \\quad B_{z,L} = 0,\n$$\nand for $x \\ge x_0$, the right state is\n$$\n\\rho_R = 0.125, \\quad u_R=v_R=w_R=0, \\quad p_R = 0.1, \\quad B_{x,R} = 0.75, \\quad B_{y,R} = -1, \\quad B_{z,R} = 0,\n$$\nwith adiabatic index $\\gamma = 2$. The longitudinal magnetic field $B_x$ is constant and equal to $0.75$ everywhere.\n\nYour task is to implement a piecewise-constant Discontinuous Galerkin (DG) discretization (which is equivalent to a finite-volume method) for the one-dimensional ideal MHD equations on a uniform mesh. The semi-discrete DG weak form over each cell $I_i = [x_{i-\\tfrac{1}{2}}, x_{i+\\tfrac{1}{2}}]$ for the piecewise constant approximation $q_i(t)$ reads\n$$\n\\frac{d q_i}{d t} = -\\frac{1}{\\Delta x}\\left(\\hat{F}_{i+\\tfrac{1}{2}} - \\hat{F}_{i-\\tfrac{1}{2}}\\right),\n$$\nwhere $\\Delta x$ is the uniform cell size and $\\hat{F}_{i\\pm \\tfrac{1}{2}}$ are numerical fluxes computed from the left and right states at each interface. Advance the solution in time using a Strong Stability Preserving (SSP) third-order Runge–Kutta method. Impose transmissive (zero-gradient) boundary conditions by copying edge states into ghost cells at both domain ends.\n\nImplement and compare the following two numerical fluxes:\n- The Rusanov (local Lax–Friedrichs) flux, defined by\n$$\n\\hat{F}^{\\mathrm{Rus}}(q_L, q_R) = \\tfrac{1}{2}\\left(F(q_L) + F(q_R)\\right) - \\tfrac{1}{2}s_{\\max}(q_R - q_L),\n$$\nwith $s_{\\max} = \\max\\left(|u_L| + c_{f,L}, |u_R| + c_{f,R}\\right)$, where $c_f$ is the fast magnetosonic speed.\n- The Harten–Lax–van Leer Einfeldt (HLLE) flux, an entropy-satisfying two-wave solver, defined by\n$$\nS_L = \\min(u_L - c_{f,L}, u_R - c_{f,R}), \\quad S_R = \\max(u_L + c_{f,L}, u_R + c_{f,R}),\n$$\n$$\n\\hat{F}^{\\mathrm{HLLE}}(q_L, q_R) =\n\\begin{cases}\nF(q_L),  S_L \\ge 0,\\\\\nF(q_R),  S_R \\le 0,\\\\\n\\dfrac{S_R F(q_L) - S_L F(q_R) + S_L S_R (q_R - q_L)}{S_R - S_L},  \\text{otherwise}.\n\\end{cases}\n$$\nUse the standard one-dimensional fast magnetosonic speed formula\n$$\na^2 = \\frac{\\gamma p}{\\rho}, \\quad c_a^2 = \\frac{B_x^2 + B_y^2 + B_z^2}{\\rho}, \\quad c_{a,x}^2 = \\frac{B_x^2}{\\rho},\n$$\n$$\nc_f^2 = \\tfrac{1}{2}\\left(a^2 + c_a^2 + \\sqrt{\\left(a^2 + c_a^2\\right)^2 - 4 a^2 c_{a,x}^2}\\right).\n$$\n\nDefine two quantitative diagnostics to measure numerical artifacts in the transverse magnetic field $B_y$ in the post-shock region:\n- Overshoot amplitude $\\mathcal{O}$: let $R = \\{x \\in [0.7, 0.9]\\}$ denote the sample region at the final time. Let $m$ be the median of $B_y$ over $R$. Define\n$$\n\\mathcal{O} = \\max_{x \\in R} B_y(x) - m.\n$$\n- Post-shock oscillation magnitude $\\sigma$: define\n$$\n\\sigma = \\sqrt{\\frac{1}{|R|}\\int_{R} \\left(B_y(x) - m\\right)^2 \\, dx},\n$$\nwhich is approximated by the sample standard deviation over the chosen cells in $R$.\n\nAdopt the following numerical setup for all runs: uniform mesh on $[0,1]$ with the Brio–Wu initial data described above, constant $B_x = 0.75$, adiabatic index $\\gamma = 2$, transmissive boundary conditions, and SSP Runge–Kutta third order time stepping with a Courant–Friedrichs–Lewy (CFL) number. Stop each simulation at final time $t_{\\mathrm{final}} = 0.1$. The units are nondimensional; report all outputs as dimensionless real numbers.\n\nTest suite:\n- Case 1: number of cells $N = 200$, CFL $= 0.4$, flux type Rusanov.\n- Case 2: number of cells $N = 200$, CFL $= 0.4$, flux type HLLE.\n- Case 3: number of cells $N = 100$, CFL $= 0.4$, flux type Rusanov.\n- Case 4: number of cells $N = 100$, CFL $= 0.4$, flux type HLLE.\n\nFor each case, compute the pair $[\\mathcal{O}, \\sigma]$ defined above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to one test case and is itself a list $[\\mathcal{O},\\sigma]$. For example, the output format must be exactly of the form\n$$\n[\\,[\\mathcal{O}_1,\\sigma_1],[\\mathcal{O}_2,\\sigma_2],[\\mathcal{O}_3,\\sigma_3],[\\mathcal{O}_4,\\sigma_4]\\,].\n$$",
            "solution": "The problem presented is a well-defined initial value problem for the one-dimensional ideal Magnetohydrodynamics (MHD) equations, a standard model in computational plasma physics. It specifies the governing equations, a classic benchmark initial condition (the Brio–Wu shock tube), the numerical domain and parameters, the discretization method (piecewise-constant Discontinuous Galerkin, equivalent to a finite-volume scheme), the time integration scheme (SSP-RK3), specific numerical flux functions (Rusanov and HLLE), boundary conditions (transmissive), and precise diagnostics for analysis. All components are scientifically sound, mathematically consistent, and computationally tractable. The problem is therefore deemed valid and a solution can be constructed.\n\nThe core of the task is to implement a finite-volume solver for the hyperbolic system of conservation laws $\\frac{\\partial q}{\\partial t} + \\frac{\\partial F(q)}{\\partial x} = 0$. The solution is advanced in time using a method of lines approach, where the spatial and temporal discretizations are handled separately.\n\n**1. State Variables and Conversions**\n\nThe solver operates on the vector of conserved variables $q = [\\rho, \\rho u, \\rho v, \\rho w, B_y, B_z, E]^T$. However, the calculation of the flux function $F(q)$ and the characteristic wave speeds requires the primitive variables $W = [\\rho, u, v, w, p, B_y, B_z]^T$. The longitudinal magnetic field $B_x$ and the adiabatic index $\\gamma$ are constant parameters.\n\nConversion from conserved variables $q$ to primitive variables $W$:\nGiven a state vector $q=(q_1, ..., q_7)^T$:\n- Mass density: $\\rho = q_1$\n- Velocity components: $u = q_2/\\rho$, $v = q_3/\\rho$, $w = q_4/\\rho$\n- Transverse magnetic field components: $B_y = q_5$, $B_z = q_6$\n- Total energy density: $E = q_7$\n- Thermal pressure $p$ is derived from the total energy:\n$$p = (\\gamma - 1)\\left(E - \\frac{1}{2}\\rho(u^2+v^2+w^2) - \\frac{1}{2}(B_x^2 + B_y^2 + B_z^2)\\right)$$\n\nConversion from primitive variables $W$ to conserved variables $q$:\nGiven a primitive vector $W=[\\rho, u, v, w, p, B_y, B_z]^T$:\n- $q_1 = \\rho$\n- $q_2 = \\rho u$\n- $q_3 = \\rho v$\n- $q_4 = \\rho w$\n- $q_5 = B_y$\n- $q_6 = B_z$\n- Total energy density $E$ is computed and stored in $q_7$:\n$$E = \\frac{p}{\\gamma-1} + \\frac{1}{2}\\rho(u^2+v^2+w^2) + \\frac{1}{2}(B_x^2 + B_y^2 + B_z^2)$$\n\nA check for positivity of density $\\rho$ and pressure $p$ must be maintained throughout the simulation to ensure physical realizability.\n\n**2. Spatial Discretization: Finite-Volume Method**\n\nThe domain $x \\in [0,1]$ is divided into $N$ uniform cells $I_i = [x_{i-1/2}, x_{i+1/2}]$ of width $\\Delta x = 1/N$. The solution within each cell is approximated by a piecewise constant value $q_i(t)$, which represents the cell average of the conserved state. The semi-discrete form of the governing equations for cell $I_i$ is:\n$$ \\frac{d q_i}{d t} = L(q)_i = -\\frac{1}{\\Delta x}\\left(\\hat{F}_{i+1/2} - \\hat{F}_{i-1/2}\\right) $$\nHere, $\\hat{F}_{i \\pm 1/2}$ is the numerical flux at the cell interface $x_{i \\pm 1/2}$, which is computed using the states from the adjacent cells, $q_i$ and $q_{i \\pm 1}$.\n\n**3. Numerical Fluxes**\n\nThe numerical flux function approximates the solution to the Riemann problem at each cell interface. The problem requires implementing two common approximate Riemann solvers.\n\n**a. Fast Magnetosonic Speed Calculation**\nBoth flux functions depend on the fast magnetosonic speed $c_f$, the maximum characteristic speed of the MHD system. For a given state, it is calculated as:\n$$ c_f = \\sqrt{\\frac{1}{2}\\left(a^2 + c_a^2 + \\sqrt{(a^2 + c_a^2)^2 - 4 a^2 c_{a,x}^2}\\right)} $$\nwhere $a^2 = \\gamma p / \\rho$ is the squared sound speed, $c_a^2 = (B_x^2+B_y^2+B_z^2)/\\rho$ is the squared total Alfvén speed, and $c_{a,x}^2 = B_x^2/\\rho$ is the squared longitudinal Alfvén speed.\n\n**b. Rusanov (Local Lax-Friedrichs) Flux**\nThis is a dissipative flux given by:\n$$ \\hat{F}^{\\mathrm{Rus}}(q_L, q_R) = \\frac{1}{2}\\left(F(q_L) + F(q_R)\\right) - \\frac{1}{2}s_{\\max}(q_R - q_L) $$\nThe dissipation is controlled by $s_{\\max} = \\max\\left(|u_L| + c_{f,L}, |u_R| + c_{f,R}\\right)$, which is the maximum signal velocity at the interface based on the left ($L$) and right ($R$) states.\n\n**c. Harten-Lax-van Leer-Einfeldt (HLLE) Flux**\nThe HLLE flux is a more sophisticated two-wave approximate Riemann solver that provides better resolution of contact discontinuities. It is constructed based on estimates of the minimum ($S_L$) and maximum ($S_R$) signal speeds at the interface:\n$$ S_L = \\min(u_L - c_{f,L}, u_R - c_{f,R}), \\quad S_R = \\max(u_L + c_{f,L}, u_R + c_{f,R}) $$\nThe flux is then:\n$$ \\hat{F}^{\\mathrm{HLLE}}(q_L, q_R) =\n\\begin{cases}\nF(q_L),  S_L \\ge 0 \\\\\nF(q_R),  S_R \\le 0 \\\\\n\\frac{S_R F(q_L) - S_L F(q_R) + S_L S_R (q_R - q_L)}{S_R - S_L},  \\text{otherwise}\n\\end{cases}\n$$\nThe first two cases correspond to supersonic flow where the Riemann fan is entirely to one side of the interface, so the flux is simply the upwind flux.\n\n**4. Time Integration: SSP Runge-Kutta 3**\n\nTo advance the solution in time, we use a third-order Strong Stability Preserving (SSP) Runge-Kutta method. Given a solution $q^n$ at time $t_n$, the solution at $t_{n+1} = t_n + \\Delta t$ is found via three stages:\n$$ q^{(1)} = q^n + \\Delta t L(q^n) $$\n$$ q^{(2)} = \\frac{3}{4}q^n + \\frac{1}{4}\\left(q^{(1)} + \\Delta t L(q^{(1)})\\right) $$\n$$ q^{n+1} = \\frac{1}{3}q^n + \\frac{2}{3}\\left(q^{(2)} + \\Delta t L(q^{(2)})\\right) $$\nwhere $L(q)$ is the spatial operator defined previously. The timestep $\\Delta t$ is restricted by the Courant-Friedrichs-Lewy (CFL) condition:\n$$ \\Delta t = \\text{CFL} \\cdot \\frac{\\Delta x}{\\max_i(|u_i| + c_{f,i})} $$\nThe maximum is taken over all cells in the computational domain.\n\n**5. Boundary and Initial Conditions**\n\nThe initial condition is the Brio-Wu shock tube, which involves two piecewise constant states separated by a discontinuity at $x=0.5$. The initial conserved state in each cell is calculated from the corresponding primitive variables. Transmissive (zero-gradient or outflow) boundary conditions are imposed by setting the state in the ghost cells equal to the state in the adjacent interior cell. For a grid with $N$ cells and one ghost cell on each side, this means $q_0 = q_1$ and $q_{N+1} = q_N$.\n\n**6. Diagnostics**\n\nAt the final time $t_{\\mathrm{final}} = 0.1$, two diagnostics are computed to quantify numerical artifacts in the transverse magnetic field $B_y$ within the spatial region $R = [0.7, 0.9]$.\n- **Overshoot $\\mathcal{O}$**: The maximum value of $B_y(x)$ in region $R$ minus the median value $m$ of $B_y(x)$ in $R$. This measures the peak of non-physical oscillations.\n- **Oscillation Magnitude $\\sigma$**: The standard deviation of $B_y(x)$ with respect to the median $m$ over the region $R$, computed as $\\sigma = \\sqrt{\\text{mean}((B_y(x_i) - m)^2)}$ for all cells $i$ whose centers $x_i$ are in $R$. This quantifies the overall oscillatory energy.\n\nThe implementation will proceed by setting up the initial state, entering a time loop that repeatedly applies the SSP-RK3 update with the chosen numerical flux, and finally computing the required diagnostics from the final solution state.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the MHD simulations and print the results.\n    \"\"\"\n    \n    # Global physical parameters\n    GAMMA = 2.0\n    BX_CONST = 0.75\n\n    def conserved_to_primitives(q):\n        \"\"\"\n        Converts a matrix of conserved variables Q to primitive variables W.\n        q: (..., 7) array for [rho, rho*u, rho*v, rho*w, By, Bz, E]\n        Returns: (..., 7) array for [rho, u, v, w, p, By, Bz]\n        \"\"\"\n        W = np.zeros_like(q)\n        rho = q[..., 0]\n        \n        # Avoid division by zero for vacuum states if any\n        inv_rho = np.divide(1.0, rho, out=np.zeros_like(rho), where=rho  1e-12)\n\n        W[..., 0] = rho\n        W[..., 1] = q[..., 1] * inv_rho  # u\n        W[..., 2] = q[..., 2] * inv_rho  # v\n        W[..., 3] = q[..., 3] * inv_rho  # w\n        W[..., 5] = q[..., 4]  # By\n        W[..., 6] = q[..., 5]  # Bz\n\n        u, v, w = W[..., 1], W[..., 2], W[..., 3]\n        By, Bz = W[..., 5], W[..., 6]\n        \n        kin_energy = 0.5 * rho * (u**2 + v**2 + w**2)\n        mag_energy = 0.5 * (BX_CONST**2 + By**2 + Bz**2)\n        \n        pressure = (GAMMA - 1.0) * (q[..., 6] - kin_energy - mag_energy)\n        W[..., 4] = np.maximum(pressure, 1e-12) # Pressure floor\n\n        return W\n\n    def primitives_to_conserved(W):\n        \"\"\"\n        Converts a matrix of primitive variables W to conserved variables Q.\n        W: (..., 7) array for [rho, u, v, w, p, By, Bz]\n        Returns: (..., 7) array for [rho, rho*u, rho*v, rho*w, By, Bz, E]\n        \"\"\"\n        Q = np.zeros_like(W)\n        rho, u, v, w, p, By, Bz = [W[..., i] for i in range(7)]\n\n        Q[..., 0] = rho\n        Q[..., 1] = rho * u\n        Q[..., 2] = rho * v\n        Q[..., 3] = rho * w\n        Q[..., 4] = By\n        Q[..., 5] = Bz\n        \n        kin_energy = 0.5 * rho * (u**2 + v**2 + w**2)\n        mag_energy = 0.5 * (BX_CONST**2 + By**2 + Bz**2)\n        \n        Q[..., 6] = p / (GAMMA - 1.0) + kin_energy + mag_energy\n        return Q\n\n    def get_flux(q):\n        \"\"\"Computes the analytical flux F(q).\"\"\"\n        W = conserved_to_primitives(q)\n        rho, u, v, w, p, By, Bz = [W[..., i] for i in range(7)]\n        \n        B_sq = BX_CONST**2 + By**2 + Bz**2\n        p_tot = p + 0.5 * B_sq\n        \n        F = np.zeros_like(q)\n        F[..., 0] = rho * u\n        F[..., 1] = rho * u**2 + p_tot - BX_CONST**2\n        F[..., 2] = rho * u * v - BX_CONST * By\n        F[..., 3] = rho * u * w - BX_CONST * Bz\n        F[..., 4] = u * By - v * BX_CONST\n        F[..., 5] = u * Bz - w * BX_CONST\n\n        E = q[..., 6]\n        v_dot_B = u * BX_CONST + v * By + w * Bz\n        F[..., 6] = (E + p_tot) * u - BX_CONST * v_dot_B\n        \n        return F\n\n    def get_fast_magnetosonic_speed(q):\n        \"\"\"Computes the fast magnetosonic speed.\"\"\"\n        W = conserved_to_primitives(q)\n        rho, u, v, w, p, By, Bz = [W[..., i] for i in range(7)]\n        \n        # Avoid division by zero\n        inv_rho = np.divide(1.0, rho, out=np.zeros_like(rho), where=rho  1e-12)\n\n        p = np.maximum(p, 1e-12)\n        a_sq = GAMMA * p * inv_rho\n        \n        B_sq = BX_CONST**2 + By**2 + Bz**2\n        ca_sq = B_sq * inv_rho\n        cax_sq = (BX_CONST**2) * inv_rho\n        \n        term = np.sqrt(np.maximum((a_sq + ca_sq)**2 - 4 * a_sq * cax_sq, 0))\n        cf_sq = 0.5 * (a_sq + ca_sq + term)\n        \n        return np.sqrt(cf_sq)\n\n    def rusanov_flux(q_L, q_R):\n        F_L = get_flux(q_L)\n        F_R = get_flux(q_R)\n        \n        W_L = conserved_to_primitives(q_L)\n        W_R = conserved_to_primitives(q_R)\n        \n        cf_L = get_fast_magnetosonic_speed(q_L)\n        cf_R = get_fast_magnetosonic_speed(q_R)\n        \n        s_max = np.maximum(np.abs(W_L[..., 1]) + cf_L, np.abs(W_R[..., 1]) + cf_R)\n        \n        return 0.5 * (F_L + F_R) - 0.5 * s_max[..., np.newaxis] * (q_R - q_L)\n\n    def hlle_flux(q_L, q_R):\n        F_L = get_flux(q_L)\n        F_R = get_flux(q_R)\n        \n        W_L = conserved_to_primitives(q_L)\n        W_R = conserved_to_primitives(q_R)\n        \n        u_L, u_R = W_L[..., 1], W_R[..., 1]\n        \n        cf_L = get_fast_magnetosonic_speed(q_L)\n        cf_R = get_fast_magnetosonic_speed(q_R)\n\n        S_L = np.minimum(u_L - cf_L, u_R - cf_R)\n        S_R = np.maximum(u_L + cf_L, u_R + cf_R)\n\n        S_L_ge_0 = (S_L = 0)\n        S_R_le_0 = (S_R = 0)\n        \n        # Vectorized conditional logic\n        num = (S_R[..., np.newaxis] * F_L - S_L[..., np.newaxis] * F_R + \n               (S_L * S_R)[..., np.newaxis] * (q_R - q_L))\n        den = S_R - S_L\n        den[den == 0] = 1.0 # Avoid division by zero, num will be zero there\n        \n        F_hlle = num / den[..., np.newaxis]\n        \n        F_hat = np.where(S_L_ge_0[..., np.newaxis], F_L, F_hlle)\n        F_hat = np.where(S_R_le_0[..., np.newaxis], F_R, F_hat)\n        \n        return F_hat\n\n    def run_simulation(N, cfl_number, flux_type):\n        # Setup grid\n        num_ghost = 1\n        x_min, x_max = 0.0, 1.0\n        dx = (x_max - x_min) / N\n        # Grid with ghost cells\n        x = np.linspace(x_min - (num_ghost - 0.5) * dx, x_max + (num_ghost - 0.5) * dx, N + 2 * num_ghost)\n        \n        # Initial conditions\n        W_L = np.array([1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0]) # rho, u, v, w, p, By, Bz\n        W_R = np.array([0.125, 0.0, 0.0, 0.0, 0.1, -1.0, 0.0])\n\n        q = np.zeros((N + 2 * num_ghost, 7))\n        q[x  0.5, :] = primitives_to_conserved(W_L)\n        q[x = 0.5, :] = primitives_to_conserved(W_R)\n\n        flux_func = rusanov_flux if flux_type == \"Rusanov\" else hlle_flux\n\n        def compute_rhs(q_state):\n            q_current = np.copy(q_state)\n            \n            # Apply transmissive boundary conditions\n            q_current[0, :] = q_current[1, :]\n            q_current[-1, :] = q_current[-2, :]\n            \n            # States at interfaces\n            q_L = q_current[:-1, :]\n            q_R = q_current[1:, :]\n            \n            # Numerical flux at interfaces\n            F_hat = flux_func(q_L, q_R)\n            \n            # RHS: -1/dx * (F_{i+1/2} - F_{i-1/2})\n            rhs = np.zeros_like(q_current)\n            rhs[1:-1, :] = -1.0/dx * (F_hat[1:, :] - F_hat[:-1, :])\n            return rhs\n\n        t = 0.0\n        t_final = 0.1\n\n        while t  t_final:\n            # Calculate dt from CFL condition\n            W = conserved_to_primitives(q[1:-1, :])\n            speeds = np.abs(W[..., 1]) + get_fast_magnetosonic_speed(q[1:-1, :])\n            max_speed = np.max(speeds)\n            \n            dt = cfl_number * dx / max_speed\n            if t + dt  t_final:\n                dt = t_final - t\n\n            # SSP-RK3 steps\n            q_n = np.copy(q)\n            \n            k1 = compute_rhs(q_n)\n            q1 = q_n + dt * k1\n            \n            k2 = compute_rhs(q1)\n            q2 = 0.75 * q_n + 0.25 * (q1 + dt * k2)\n\n            k3 = compute_rhs(q2)\n            q = (1.0/3.0) * q_n + (2.0/3.0) * (q2 + dt * k3)\n            \n            t += dt\n\n        # Post-processing and diagnostics\n        x_centers = np.linspace(x_min + 0.5 * dx, x_max - 0.5 * dx, N)\n        sample_indices = np.where((x_centers = 0.7)  (x_centers = 0.9))[0]\n        \n        # Get final By from interior cells\n        By_final = conserved_to_primitives(q[1:-1, :])[..., 5]\n        By_sample = By_final[sample_indices]\n\n        if len(By_sample) == 0:\n            return [0.0, 0.0]\n\n        m = np.median(By_sample)\n        overshoot = np.max(By_sample) - m\n        oscillation = np.sqrt(np.mean((By_sample - m)**2)) # std with ddof=0\n\n        return [overshoot, oscillation]\n\n    # Test suite\n    test_cases = [\n        {'N': 200, 'CFL': 0.4, 'flux_type': 'Rusanov'},\n        {'N': 200, 'CFL': 0.4, 'flux_type': 'HLLE'},\n        {'N': 100, 'CFL': 0.4, 'flux_type': 'Rusanov'},\n        {'N': 100, 'CFL': 0.4, 'flux_type': 'HLLE'}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case['N'], case['CFL'], case['flux_type'])\n        results.append(result)\n    \n    # Format the final output string\n    # Convert each inner list to its string representation\n    result_strings = ['[{:.6f},{:.6f}]'.format(r[0], r[1]) for r in results]\n    # Join them with commas and enclose in brackets\n    output_string = f\"[{','.join(result_strings)}]\"\n    print(output_string)\n\nsolve()\n```"
        }
    ]
}