{
    "hands_on_practices": [
        {
            "introduction": "理论分析与数值模拟之间的验证是计算科学的基石。本练习旨在通过一个基础但关键的实践，将抽象的冯·诺依曼稳定性分析与数值模拟的实际输出联系起来。你将通过对一个简单的平流方程求解器进行单傅里叶模态的数值实验，并对结果进行时间傅里叶变换，从而直接测量数值色散和耗散，并将其与理论预测进行比较。这项实践将为你提供一项核心的验证与确认（VV）技能。",
            "id": "4022200",
            "problem": "考虑一维线性平流方程 $ \\partial_t u + a \\, \\partial_x u = 0 $，该方程定义在长度为 $ L $ 的周期性域上，并在一个包含 $ N_x $ 个点、间距为 $ \\Delta x = L/N_x $ 的均匀网格上进行离散。使用一阶迎风有限差分法，其中 Courant–Friedrichs–Lewy 数为 $ \\lambda = a \\Delta t / \\Delta x $（对于 $ a > 0 $），离散时间步长为 $ \\Delta t $，即更新规则为 $ u_i^{n+1} = u_i^n - \\lambda \\left( u_i^n - u_{i-1}^n \\right) $，并采用周期性索引。该格式在计算流体动力学和计算聚变科学与工程中被广泛用于控制双曲输运中的数值耗散和数值色散，并可作为一个受控环境，用以根据冯·诺依曼分析来验证数值色散和阻尼。\n\n您的任务是设计并实现一个完整、可运行的程序，该程序能够：\n\n1. 使用单个复傅里叶模 $ u_i^0 = \\exp\\!\\left( i k x_i \\right) $ 初始化场，其中 $ k = 2\\pi m/L $，$ x_i = i \\Delta x $，并且 $ m \\in \\{0,1,\\dots,N_x-1\\} $ 是一个整数模指数。\n2. 使用上述迎风格式将解在时间上推进 $ N_t $ 个时间步。\n3. 在每个时间步 $ n $，通过离散空间傅里叶投影 $ a_m^n = \\frac{1}{N_x} \\sum_{i=0}^{N_x-1} u_i^n \\exp\\!\\left( - i k x_i \\right) $ 提取所选空间傅里叶模 $ m $ 的复振幅。\n4. 根据时间序列 $ \\{ a_m^n \\}_{n=0}^{N_t-1} $，执行时间快速傅里叶变换（FFT）以估计该模的数值角频率 $ \\omega_{\\text{num}}(k) $ 和数值增长（阻尼）率 $ \\gamma_{\\text{num}}(k) $：\n   - 定义离散角频率网格 $ \\omega_j = 2\\pi f_j $，其中 $ f_j $ 是以时间单位周期数为单位、间距为 $ \\Delta t $ 的 FFT 频率。将 $ \\omega_{\\text{num}}(k) $ 识别为与功率谱 $ P(\\omega) = | \\mathcal{F}[a_m^n](\\omega) |^2 $ 的最大值相对应的角频率。\n   - 使用主谱峰的半峰全宽（FWHM）直接从时间谱估计 $ \\gamma_{\\text{num}}(k) $，取 $ \\gamma_{\\text{num}}(k) = -\\frac{1}{2} \\text{FWHM} $。如果谱峰位于频率边界，以至于只有一个单侧半最大值交叉点可用，则通过两倍的单侧半宽来近似 $ \\text{FWHM} $。\n5. 对同一格式独立执行冯·诺依曼稳定性和色散分析，以获得放大因子 $ G(k) $，并由此通过关系式 $ G(k) = \\exp((\\gamma_{\\text{vn}} - i\\omega_{\\text{vn}})\\Delta t) $ 得到预测的角频率 $\\omega_{\\text{vn}}(k)$ 和增长率 $\\gamma_{\\text{vn}}(k)$，即 $\\omega_{\\text{vn}}(k) = -\\arg(G(k))/\\Delta t$ 和 $\\gamma_{\\text{vn}}(k) = \\ln |G(k)| / \\Delta t$。\n6. 通过报告绝对差 $ |\\omega_{\\text{num}}(k) - \\omega_{\\text{vn}}(k)| $ 和 $ |\\gamma_{\\text{num}}(k) - \\gamma_{\\text{vn}}(k)| $，将您从时间 FFT 测得的 $ \\omega_{\\text{num}}(k) $ 和 $ \\gamma_{\\text{num}}(k) $ 与冯·诺依曼预测的 $ \\omega_{\\text{vn}}(k) $ 和 $ \\gamma_{\\text{vn}}(k) $ 进行比较。\n\n假设使用无量纲单位，其中 $ a = 1 $（长度/单位时间），因此角频率 $ \\omega $ 必须以弧度/单位时间表示，增长/阻尼率 $ \\gamma $ 必须以 1/单位时间表示。角度以弧度为单位。\n\n您的程序必须对所有测试使用以下固定参数：$ N_x = 256 $，$ L = 1 $，$ a = 1 $，以及 $ N_t = 4096 $。使用下面列出的三元组 $ (\\lambda, m) $ 构建测试套件，这些三元组用于探测不同的区域：\n- 一般情况: $ (\\lambda, m) = (0.5, 12) $。\n- 边界库朗数（当 $ k \\neq 0 $ 时无数值耗散）: $ (\\lambda, m) = (1.0, 20) $。\n- 接近奈奎斯特模的高波数: $ (\\lambda, m) = (0.9, 128) $。\n\n对于每个测试用例，计算第 $ 6 $ 项中描述的两个绝对差，结果为浮点数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个二元列表 $ [|\\omega_{\\text{num}}-\\omega_{\\text{vn}}|, |\\gamma_{\\text{num}}-\\gamma_{\\text{vn}}|] $。例如，输出格式必须是 $ [[d_{\\omega,1},d_{\\gamma,1}],[d_{\\omega,2},d_{\\gamma,2}],[d_{\\omega,3},d_{\\gamma,3}]] $，所有条目均采用上述指定单位。",
            "solution": "所述问题在科学上是合理的、自洽的且适定的。它展示了一个计算物理学中的标准验证和确认练习，特别是针对应用于双曲偏微分方程的数值方法。参数、初始条件、数值格式和分析方法都得到了清晰且正确的定义。未检测到任何缺陷、矛盾或模糊之处。因此，我们可以进行形式化的求解。\n\n求解过程涉及两个平行的轨道：使用冯·诺依曼方法的理论分析和直接数值模拟。然后对两者的结果进行比较。\n\n### 1. 理论分析：冯·诺依曼色散和稳定性\n\n我们分析一阶迎风格式的数值特性，\n$$ u_i^{n+1} = u_i^n - \\lambda \\left( u_i^n - u_{i-1}^n \\right) $$\n其中 $\\lambda = a \\Delta t / \\Delta x$ 是库朗数。我们将单个傅里叶模 ansatz，$u_i^n = \\hat{u}^n(k) e^{i k x_i}$，代入该格式。振幅 $\\hat{u}^n(k)$ 预计会根据 $\\hat{u}^{n+1}(k) = G(k) \\hat{u}^n(k)$ 演化，其中 $G(k)$ 是复放大因子。\n\n代入 ansatz 并使用 $x_i = i \\Delta x$:\n$$ G(k) \\hat{u}^n(k) e^{i k i \\Delta x} = \\hat{u}^n(k) e^{i k i \\Delta x} - \\lambda \\left( \\hat{u}^n(k) e^{i k i \\Delta x} - \\hat{u}^n(k) e^{i k (i-1) \\Delta x} \\right) $$\n除以公因子 $\\hat{u}^n(k) e^{i k i \\Delta x}$:\n$$ G(k) = 1 - \\lambda \\left( 1 - e^{-i k \\Delta x} \\right) $$\n令 $\\tilde{k} = k \\Delta x$ 为归一化波数。放大因子为：\n$$ G(\\tilde{k}) = 1 - \\lambda (1 - e^{-i\\tilde{k}}) = (1 - \\lambda + \\lambda \\cos\\tilde{k}) + i (\\lambda \\sin\\tilde{k}) $$\n从放大因子 $G(k)$，我们可以提取理论上的数值增长率 $\\gamma_{\\text{vn}}(k)$ 和角频率 $\\omega_{\\text{vn}}(k)$。这些量由关系式 $G(k) = \\exp((\\gamma_{\\text{vn}} - i\\omega_{\\text{vn}})\\Delta t)$ 定义。这与物理波 $e^{i(kx-\\omega t)}$ 的演化约定一致。因此，冯·诺依曼预测为：\n$$ \\gamma_{\\text{vn}}(k) = \\frac{\\ln|G(k)|}{\\Delta t} $$\n$$ \\omega_{\\text{vn}}(k) = -\\frac{\\arg(G(k))}{\\Delta t} $$\n将为每个测试用例三元组 $(\\lambda, m)$ 计算这些值。\n\n### 2. 数值模拟与测量\n\n数值部分的核心是模拟单个纯傅里叶模的演化，并分析其随时间的行为。\n\n**初始化：** 空间网格在长度为 $L=1$ 的域上有 $N_x=256$ 个点，因此 $\\Delta x = L/N_x = 1/256$。初始条件是单个复模 $u_i^0 = \\exp(i k x_i)$，其波数为 $k = 2 \\pi m / L$。\n\n**时间演化：** 使用迎风格式将场 $u$ 推进 $N_t = 4096$ 步。在每一步 $n$，我们将解投影到初始傅里叶模上，以获得其复振幅：\n$$ a_m^n = \\frac{1}{N_x} \\sum_{i=0}^{N_x-1} u_i^n \\exp(-i k x_i) $$\n这等价于场 $u^n$ 的离散傅里叶变换的第 $m$ 个分量。序列 $\\{a_m^n\\}_{n=0}^{N_t-1}$ 跟踪了我们感兴趣的模随时间的振幅和相位。对于一个理想的格式，我们应有 $a_m^n = (G(k))^n$。\n\n**频谱分析：** 我们对复时间序列 $\\{a_m^n\\}$ 执行时间快速傅里叶变换（FFT）。离散时间步长为 $\\Delta t = \\lambda \\Delta x / a$。\n$$ \\mathcal{F}[a_m^n](\\omega_j) = \\sum_{n=0}^{N_t-1} a_m^n e^{-i \\omega_j n \\Delta t} $$\n得到的功率谱 $P(\\omega_j) = |\\mathcal{F}[a_m^n](\\omega_j)|^2$ 将会有一个尖锐的峰值。\n\n**参数估计：**\n1.  **数值频率 $\\omega_{\\text{num}}(k)$**：这被识别为与功率谱 $P(\\omega_j)$ 的最大值相对应的角频率 $\\omega_j$。\n2.  **数值增长率 $\\gamma_{\\text{num}}(k)$**：这是根据谱峰的半峰全宽（FWHM）估计的。对于洛伦兹峰，衰减指数信号（$e^{-\\gamma_0 t}$）的功率谱的 FWHM 与衰减率 $\\gamma_0$ 之间的关系是 $\\text{FWHM} = 2\\gamma_0$。问题将估计定义为 $\\gamma_{\\text{num}}(k) = -\\frac{1}{2}\\text{FWHM}$。负号正确地将宽度（一个正量）转换为阻尼率（一个负增长率）。为了找到 FWHM，我们定位峰值，找到半峰功率水平，然后在峰的两侧找到谱线穿过此水平的频率。为了准确性，使用了离散频率点之间的线性插值。如果峰值位于频率边界（例如奈奎斯特频率），则找到单侧宽度并加倍，如问题所述。\n\n### 3. 比较\n\n最后，对于每个测试用例，计算理论预测值与数值测量值之间的绝对差：\n$$ d_\\omega = |\\omega_{\\text{num}}(k) - \\omega_{\\text{vn}}(k)| $$\n$$ d_\\gamma = |\\gamma_{\\text{num}}(k) - \\gamma_{\\text{vn}}(k)| $$\n这些差异量化了基于时间 FFT 的测量技术在恢复冯·诺依曼分析预测的属性方面的准确性。实现将精确遵循这些步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing numerical vs. theoretical dispersion and diffusion\n    for the 1D linear advection equation.\n    \"\"\"\n\n    # --- Fixed Parameters ---\n    N_x = 256\n    L = 1.0\n    a = 1.0\n    N_t = 4096\n    \n    # --- Test Suite ---\n    test_cases = [\n        (0.5, 12),   # General case\n        (1.0, 20),   # Boundary Courant number (exact translation)\n        (0.9, 128),  # High wavenumber (Nyquist mode)\n    ]\n\n    results = []\n\n    def _calculate_fwhm(omega_axis, power_spectrum):\n        \"\"\"\n        Calculates the Full Width at Half Maximum (FWHM) of a peak in a power spectrum.\n        Uses linear interpolation for sub-grid accuracy. Handles boundary peaks.\n        \"\"\"\n        if not np.any(power_spectrum):\n            return 0.0\n\n        peak_idx = np.argmax(power_spectrum)\n        peak_omega = omega_axis[peak_idx]\n        peak_power = power_spectrum[peak_idx]\n        \n        if peak_power == 0:\n            return 0.0\n\n        half_max_power = peak_power / 2.0\n\n        # --- Find left crossing ---\n        # Find indices of points to the left of the peak that are below half-max\n        left_indices = np.where(power_spectrum[:peak_idx] = half_max_power)[0]\n        omega_left = None\n        if left_indices.size > 0:\n            idx1 = left_indices[-1]\n            idx2 = idx1 + 1\n            if idx2  peak_idx + 1:\n                p1, p2 = power_spectrum[idx1], power_spectrum[idx2]\n                w1, w2 = omega_axis[idx1], omega_axis[idx2]\n                if (p2 - p1) != 0:\n                    omega_left = w1 + (w2 - w1) * (half_max_power - p1) / (p2 - p1)\n\n        # --- Find right crossing ---\n        # Find indices of points to the right of the peak that are below half-max\n        right_indices = np.where(power_spectrum[peak_idx + 1:] = half_max_power)[0]\n        omega_right = None\n        if right_indices.size > 0:\n            idx2 = right_indices[0] + peak_idx + 1\n            idx1 = idx2 - 1\n            if idx1 > peak_idx - 1:\n                p1, p2 = power_spectrum[idx1], power_spectrum[idx2]\n                w1, w2 = omega_axis[idx1], omega_axis[idx2]\n                if (p2 - p1) != 0:\n                    omega_right = w1 + (w2 - w1) * (half_max_power - p1) / (p2 - p1)\n        \n        # --- Calculate FWHM based on available crossings ---\n        if omega_left is not None and omega_right is not None:\n            return omega_right - omega_left\n        elif omega_left is not None: # Right crossing not found (peak at boundary)\n            return 2 * (peak_omega - omega_left)\n        elif omega_right is not None: # Left crossing not found (peak at boundary)\n            return 2 * (omega_right - peak_omega)\n        else: # No crossings found (e.g., a single delta-function-like peak)\n            return 0.0\n\n    for lam, m in test_cases:\n        # --- Derived Parameters ---\n        delta_x = L / N_x\n        delta_t = lam * delta_x / a\n        k = 2 * np.pi * m / L\n\n        # --- 1. Theoretical (von Neumann) Analysis ---\n        k_tilde = k * delta_x\n        # Amplification factor G = 1 - lambda * (1 - exp(-i*k_tilde))\n        G = 1.0 - lam * (1.0 - np.exp(-1j * k_tilde))\n        \n        # Theoretical growth rate and angular frequency from G = exp((gamma - i*omega)*dt)\n        gamma_vn = np.log(np.abs(G)) / delta_t\n        omega_vn = -np.angle(G) / delta_t\n\n        # --- 2. Numerical Simulation ---\n        # Initialize field u with a single Fourier mode\n        x_grid = np.arange(N_x) * delta_x\n        u = np.exp(1j * k * x_grid)\n        \n        a_m_series = np.zeros(N_t, dtype=np.complex128)\n\n        # Time evolution loop\n        for n in range(N_t):\n            # Project onto the mode m to get its amplitude\n            # This is equivalent to the m-th component of the un-normalized FFT divided by N_x\n            a_m_series[n] = np.fft.fft(u)[m] / N_x\n            \n            # Update u using first-order upwind scheme with periodic boundaries\n            u_prev = np.roll(u, 1)\n            u = u - lam * (u - u_prev)\n            \n        # --- 3. Numerical Measurement from Simulation ---\n        # Temporal FFT of the modal amplitude time series\n        temporal_freqs = np.fft.fftfreq(N_t, d=delta_t)\n        temporal_omega = 2 * np.pi * temporal_freqs\n        \n        spectrum = np.fft.fft(a_m_series)\n        power_spectrum = np.abs(spectrum)**2\n\n        # For FWHM calculation, it's easier to work with a shifted spectrum\n        shifted_omega = np.fft.fftshift(temporal_omega)\n        shifted_power = np.fft.fftshift(power_spectrum)\n\n        # Find numerical frequency from the peak of the power spectrum\n        peak_idx = np.argmax(power_spectrum)\n        # The resulting frequency from FFT is naturally consistent with the (gamma - i*omega) convention\n        omega_num = temporal_omega[peak_idx]\n\n        # Estimate numerical growth rate from FWHM of the spectral peak\n        fwhm = _calculate_fwhm(shifted_omega, shifted_power)\n        gamma_num = -0.5 * fwhm\n\n        # --- 4. Comparison ---\n        diff_omega = np.abs(omega_num - omega_vn)\n        diff_gamma = np.abs(gamma_num - gamma_vn)\n        \n        results.append([diff_omega, diff_gamma])\n\n    # --- Final Output Formatting ---\n    # Create the final string in the format [[d_w1, d_g1],[d_w2, d_g2],...]\n    result_strings = [f\"[{r[0]},{r[1]}]\" for r in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "仅仅知道数值格式存在误差是不够的，我们还必须了解这些误差如何随着网格加密而减小，这即是格式的收敛阶。本练习将通过理查森外推法（Richardson extrapolation）这一强大工具，来量化和比较不同数值格式的误差收敛特性。通过分析一阶迎风格式和二阶Lax-Wendroff格式，你将学会如何精确地确定色散误差和耗散误差各自的收敛阶，这对于选择合适的数值方法和预测计算成本至关重要。",
            "id": "4022216",
            "problem": "考虑守恒形式的一维线性平流方程，其相速为常数，由 $u_t + c\\,u_x = 0$ 给出，其中 $u(x,t)$ 表示一个标量场，$c$ 是物理平流速度。目标是通过使用傅里叶分析和跨网格加密的 Richardson 外推法来量化和控制数值扩散和色散。在计算聚变科学与工程的背景下进行研究，其中精确的波传播（例如，磁流体动力学波包）需要将色散误差（相速失真）与耗散误差（振幅衰减）分开。\n\n你将分析均匀网格上的两种显式有限差分格式：\n- 一阶迎风格式（时间上为前向欧拉，空间上为一阶迎风），其更新方程定义为\n$$\nu_j^{n+1} = u_j^n - \\lambda\\left(u_j^n - u_{j-1}^n\\right),\n$$\n其中 $u_j^n$ 近似于 $u(jh, n\\Delta t)$，$h$ 是网格间距，$\\Delta t$ 是时间步长，$j$ 和 $n$ 是整数，$\\lambda = c\\,\\Delta t / h$ 是 Courant-Friedrichs-Lewy (CFL) 数。\n- 二阶 Lax–Wendroff 格式（时间上和空间上均为二阶），定义为\n$$\nu_j^{n+1} = u_j^n - \\frac{\\lambda}{2}\\left(u_{j+1}^n - u_{j-1}^n\\right) + \\frac{\\lambda^2}{2}\\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right).\n$$\n\n使用 Von Neumann 傅里叶分析：代入单个傅里叶模式 $u_j^n = \\hat{u}^n \\exp(i k j h)$，其中波数 $k$ 的单位为弧度/米，并推导复数放大因子 $G(\\theta,\\lambda)$，其中 $\\theta = k h$ 是每个网格单元的无量纲相角。关系式 $G = \\exp(-i \\omega_{\\mathrm{num}} \\Delta t)$ 和 $|G| = \\exp(\\sigma_{\\mathrm{num}} \\Delta t)$ 定义了数值角频率 $\\omega_{\\mathrm{num}}$ 和数值阻尼率 $\\sigma_{\\mathrm{num}}$。精确角频率为 $\\omega_{\\mathrm{exact}} = c\\,k$，平流方程的精确阻尼率为 $\\sigma_{\\mathrm{exact}} = 0$。数值相速为 $c_{\\mathrm{num}} = \\omega_{\\mathrm{num}}/k$。\n\n将色散误差大小定义为 $E_{\\mathrm{disp}}(h) = |c_{\\mathrm{num}}(h) - c|$，耗散误差大小定义为 $E_{\\mathrm{diss}}(h) = |\\sigma_{\\mathrm{num}}(h) - \\sigma_{\\mathrm{exact}}| = |\\sigma_{\\mathrm{num}}(h)|$。对于固定的 CFL 数 $\\lambda$ 和固定的物理平流速度 $c$，通过将 $h$ 减半并相应地将 $\\Delta t$ 减半来加密网格（以保持 $\\lambda$ 不变）。使用 Richardson 外推法通过以下公式估计每个误差分量的观测收敛阶 $p$：\n$$\np \\approx \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)}.\n$$\n为每种格式的色散误差和耗散误差分别计算此 $p$。\n\n角度量必须以弧度处理。物理平流速度 $c$ 必须以 $\\mathrm{m/s}$ 表示和解释，波数 $k$ 以 $\\mathrm{rad/m}$ 表示，网格间距 $h$ 以 $\\mathrm{m}$ 表示，时间步长 $\\Delta t$ 以 $\\mathrm{s}$ 表示，阻尼率以 $\\mathrm{s}^{-1}$ 表示。所有输出必须是无量纲浮点数。\n\n实现一个程序，该程序：\n- 对每个测试用例和每种格式，使用傅里叶分析计算在固定 $\\lambda$ 下两种网格加密（$h$ 和 $h/2$）的放大因子，然后计算 $E_{\\mathrm{disp}}(h)$、$E_{\\mathrm{disp}}(h/2)$、$E_{\\mathrm{diss}}(h)$ 和 $E_{\\mathrm{diss}}(h/2)$，最后返回 Richardson 阶数估计值 $p_{\\mathrm{disp}}$ 和 $p_{\\mathrm{diss}}$。\n- 将所有结果汇总到一行中，格式为方括号内以逗号分隔的列表，按测试用例排序为 $[p_{\\mathrm{disp}}^{\\mathrm{upwind}}, p_{\\mathrm{diss}}^{\\mathrm{upwind}}, p_{\\mathrm{disp}}^{\\mathrm{LW}}, p_{\\mathrm{diss}}^{\\mathrm{LW}}]$，并为所有测试用例连接起来。\n\n使用以下测试参数套件以确保覆盖范围：\n- 测试用例 1（一般情况）：$c = 1.7\\,\\mathrm{m/s}$，$\\lambda = 0.65$，$k = 7.5\\,\\mathrm{rad/m}$，$h = 0.12\\,\\mathrm{m}$，$h/2 = 0.06\\,\\mathrm{m}$。\n- 测试用例 2（长波极限）：$c = 1.7\\,\\mathrm{m/s}$，$\\lambda = 0.65$，$k = 1.2\\,\\mathrm{rad/m}$，$h = 0.12\\,\\mathrm{m}$，$h/2 = 0.06\\,\\mathrm{m}$。\n- 测试用例 3（近奈奎斯特挑战）：$c = 1.7\\,\\mathrm{m/s}$，$\\lambda = 0.65$，$k = 26.0\\,\\mathrm{rad/m}$，$h = 0.12\\,\\mathrm{m}$，$h/2 = 0.06\\,\\mathrm{m}$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，按测试用例 1、测试用例 2、测试用例 3 的顺序排列，每个测试用例贡献四个浮点数，顺序如上所述，总共十二个浮点数，例如 $[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8,r_9,r_{10},r_{11},r_{12}]$。",
            "solution": "问题分析首先要验证其前提。该问题是偏微分方程数值分析中的一个标准练习，具体而言是采用 Von Neumann 稳定性和相误差分析来研究线性平流方程的有限差分格式。所有提供的方程、定义和参数在科学上都是合理的、适定的和一致的。因此，该问题被认为是有效的，可以构建一个完整的解决方案。\n\n问题的核心是量化波传播模拟中的数值误差，这是计算聚变科学的一个关键方面，其中像磁流体动力学波这样的现象必须以高保真度建模。该分析将误差分为两类：耗散（或阻尼）误差，它导致非物理的振幅衰减；以及色散误差，它导致不同波长的波以不正确的速度传播。\n\n控制方程是一维线性平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0\n$$\n其中 $u(x,t)$ 是一个标量， $c$ 是恒定的平流速度。对于初始廓线 $u(x,0) = f(x)$，其精确解为 $u(x,t) = f(x-ct)$，表示初始廓线以速度 $c$ 进行纯平移。对于单个傅里叶模式 $u(x,t) = \\exp(i(kx - \\omega t))$，精确色散关系为 $\\omega = ck$，精确阻尼率为 $\\sigma_{\\mathrm{exact}} = 0$。\n\n我们在间距为 $h$、时间步长为 $\\Delta t$ 的均匀网格上分析两种有限差分格式。\n\n**一阶迎风 (FOU) 格式**\n对于正的平流速度 $c > 0$，空间上的迎风方向是向左。在时间上使用前向差分，在空间上使用后向差分，该格式为：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} + c \\frac{u_j^n - u_{j-1}^n}{h} = 0\n$$\n重新整理后得到问题陈述中的更新方程：\n$$\nu_j^{n+1} = u_j^n - \\lambda \\left(u_j^n - u_{j-1}^n\\right)\n$$\n其中 $\\lambda = c \\Delta t / h$ 是 Courant-Friedrichs-Lewy (CFL) 数。\n\n**二阶 Lax–Wendroff (LW) 格式**\n该格式由时间上的二阶泰勒级数展开推导而来，其形式如下：\n$$\nu_j^{n+1} = u_j^n - \\frac{\\lambda}{2}\\left(u_{j+1}^n - u_{j-1}^n\\right) + \\frac{\\lambda^2}{2}\\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right)\n$$\n\n**Von Neumann 傅里叶分析**\n为了找到每种格式的数值特性，我们代入单个傅里傅模式 $u_j^n = \\hat{u}^n \\exp(ikjh)$，其中 $k$ 是波数，$j$ 是空间索引。解通过复数放大因子 $G$ 向前推进一个时间步，使得 $u_j^{n+1} = G u_j^n$。\n\n对于 FOU 格式，代入后得到：\n$$\nG \\hat{u}^n e^{ikjh} = \\hat{u}^n e^{ikjh} - \\lambda \\left(\\hat{u}^n e^{ikjh} - \\hat{u}^n e^{ik(j-1)h}\\right)\n$$\n除以 $\\hat{u}^n e^{ikjh}$ 并引入无量纲相角 $\\theta = kh$：\n$$\nG_{\\mathrm{FOU}}(\\theta, \\lambda) = 1 - \\lambda(1 - e^{-i\\theta}) = 1 - \\lambda(1 - (\\cos\\theta - i\\sin\\theta))\n$$\n$$\nG_{\\mathrm{FOU}}(\\theta, \\lambda) = \\left(1 - \\lambda(1-\\cos\\theta)\\right) + i\\lambda\\sin\\theta\n$$\n注意这里虚部为正，但问题中定义的 $\\omega_{\\mathrm{num}}$ 包含负号，因此最终的相速度方向是正确的。\n\n对于 LW 格式，代入后得到：\n$$\nG = 1 - \\frac{\\lambda}{2}(e^{i\\theta} - e^{-i\\theta}) + \\frac{\\lambda^2}{2}(e^{i\\theta} - 2 + e^{-i\\theta})\n$$\n使用恒等式 $e^{i\\theta} - e^{-i\\theta} = 2i\\sin\\theta$ 和 $e^{i\\theta} + e^{-i\\theta} = 2\\cos\\theta$：\n$$\nG_{\\mathrm{LW}}(\\theta, \\lambda) = 1 - i\\lambda\\sin\\theta + \\lambda^2(\\cos\\theta - 1)\n$$\n$$\nG_{\\mathrm{LW}}(\\theta, \\lambda) = \\left(1 - \\lambda^2(1-\\cos\\theta)\\right) - i\\lambda\\sin\\theta\n$$\n\n**误差量化**\n复数放大因子 $G$ 通过以下关系编码了数值阻尼率 $\\sigma_{\\mathrm{num}}$ 和数值频率 $\\omega_{\\mathrm{num}}$：\n$$\n|G| = e^{\\sigma_{\\mathrm{num}}\\Delta t} \\quad \\text{and} \\quad \\arg(G) = -\\omega_{\\mathrm{num}}\\Delta t\n$$\n由此，我们推导出数值特性：\n$$\n\\sigma_{\\mathrm{num}}(h) = \\frac{\\ln|G(kh, \\lambda)|}{\\Delta t} = \\frac{c}{\\lambda h}\\ln|G(kh, \\lambda)|\n$$\n$$\n\\omega_{\\mathrm{num}}(h) = -\\frac{\\arg(G(kh, \\lambda))}{\\Delta t} = -\\frac{c}{\\lambda h}\\arg(G(kh, \\lambda))\n$$\n数值相速为 $c_{\\mathrm{num}} = \\omega_{\\mathrm{num}}/k$。误差则定义为：\n- 耗散误差：$E_{\\mathrm{diss}}(h) = |\\sigma_{\\mathrm{num}}(h) - \\sigma_{\\mathrm{exact}}| = |\\sigma_{\\mathrm{num}}(h)|$，因为 $\\sigma_{\\mathrm{exact}}=0$。\n- 色散误差：$E_{\\mathrm{disp}}(h) = |c_{\\mathrm{num}}(h) - c|$。\n\n**用于收敛阶的 Richardson 外推法**\n对于一个数值方法，其误差 $E(h)$ 表现为 $E(h) \\approx C h^p$（其中 $C$ 为某个常数，$p$ 为收敛阶），我们可以通过比较在两个不同网格 $h$ 和 $h/2$ 上的误差来估计 $p$：\n$$\nE(h) \\approx C h^p \\quad \\text{and} \\quad E(h/2) \\approx C (h/2)^p = C h^p / 2^p\n$$\n取其比值得出 $E(h)/E(h/2) \\approx 2^p$。解出 $p$ 即得到问题中提供的公式：\n$$\np \\approx \\frac{\\log(E(h)/E(h/2))}{\\log(2)}\n$$\n对每种格式的 $E_{\\mathrm{disp}}$ 和 $E_{\\mathrm{diss}}$ 都执行此计算，以找出它们各自的观测收敛阶 $p_{\\mathrm{disp}}$ 和 $p_{\\mathrm{diss}}$。该实现将遍历给定的测试用例，为每个用例计算这四个阶参数，并汇总结果。\n\n理论上，FOU 格式在空间和时间上是一阶的，因此我们预期 $p_{\\mathrm{disp}} \\approx 1$ 和 $p_{\\mathrm{diss}} \\approx 1$。LW 格式是二阶的，其主截断误差项与导致色散的 $u_{xxx}$ 成正比，而一个更高阶的项与导致耗散的 $u_{xxxx}$ 成正比。因此，我们预期 $p_{\\mathrm{disp}} \\approx 2$ 和 $p_{\\mathrm{diss}} \\approx 3$。提供的测试用例探索了 $\\theta=kh$ 的不同区域，以检验这些理论阶数是否成立。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical diffusion and dispersion problem by implementing\n    Von Neumann analysis and Richardson extrapolation for two finite difference schemes.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1 (general case)\n        {'c': 1.7, 'lam': 0.65, 'k': 7.5, 'h1': 0.12, 'h2': 0.06},\n        # Test Case 2 (long-wave limit)\n        {'c': 1.7, 'lam': 0.65, 'k': 1.2, 'h1': 0.12, 'h2': 0.06},\n        # Test Case 3 (near-Nyquist challenge)\n        {'c': 1.7, 'lam': 0.65, 'k': 26.0, 'h1': 0.12, 'h2': 0.06},\n    ]\n\n    def calculate_errors(c, lam, k, h, scheme):\n        \"\"\"\n        Calculates the dispersive and dissipative errors for a given scheme and parameters.\n\n        Args:\n            c (float): Physical advection speed.\n            lam (float): CFL number.\n            k (float): Wavenumber.\n            h (float): Grid spacing.\n            scheme (str): 'upwind' or 'lw' (Lax-Wendroff).\n\n        Returns:\n            tuple: A tuple containing (E_disp, E_diss).\n        \"\"\"\n        theta = k * h\n        delta_t = lam * h / c\n\n        if scheme == 'upwind':\n            # G = 1 - lam * (1 - exp(-i*theta))\n            G = 1.0 - lam * (1.0 - np.exp(-1j * theta))\n        elif scheme == 'lw':\n            # G = 1 - lam^2*(1-cos(theta)) - i*lam*sin(theta)\n            G = 1.0 - lam**2 * (1.0 - np.cos(theta)) - 1j * lam * np.sin(theta)\n        else:\n            raise ValueError(\"Unknown scheme type\")\n\n        mag_G = np.abs(G)\n        arg_G = np.angle(G)\n\n        # Handle the case where mag_G is 0 to avoid log errors.\n        if mag_G > 1e-15:\n            sigma_num = np.log(mag_G) / delta_t\n        else:\n            sigma_num = -np.inf\n        \n        # omega_num = -arg(G) / delta_t\n        # Special handling for FOU which is defined with +i*sin(theta) in our derivation\n        if scheme == 'upwind':\n             # G = (1-lam(1-cos)) + i*lam*sin. For c>0, omega must be positive.\n             # arg(G) is positive. omega = -arg(G)/dt is wrong.\n             # Let's adjust for the convention.\n             # In my derivation for FOU G has +i*sin term. The text in problem has -i*sin term for LW\n             # The problem states u_j^{n+1} = u_j^n - \\lambda(u_j^n - u_{j-1}^n)\n             # G = 1 - \\lambda(1 - exp(-i*theta)) = (1-lam+lam*cos) + i*lam*sin\n             # For a forward propagating wave exp(i(kx-wt)), G must be exp(-i*w*dt) * damping.\n             # So arg(G) = -w*dt. This means w = -arg(G)/dt. This is correct.\n             pass\n\n        omega_num = -arg_G / delta_t\n        \n        # For k=0, c_num is undefined. But k is never 0 in test cases.\n        c_num = omega_num / k\n\n        E_disp = np.abs(c_num - c)\n        E_diss = np.abs(sigma_num)\n\n        return E_disp, E_diss\n\n    def calculate_p(E_h, E_h_half):\n        \"\"\"\n        Calculates the observed order of convergence p using Richardson extrapolation.\n        \"\"\"\n        if E_h_half = 0 or E_h = 0:\n            return np.nan\n        \n        ratio = E_h / E_h_half\n        if ratio = 1.0:\n             # Error doesn't decrease or increases, order is = 0 or undefined\n             # log2 will handle this by giving a non-positive number.\n             pass\n\n        return np.log2(ratio)\n\n    results = []\n    for case in test_cases:\n        c, lam, k, h1, h2 = case['c'], case['lam'], case['k'], case['h1'], case['h2']\n\n        # Upwind Scheme\n        E_disp_up_h1, E_diss_up_h1 = calculate_errors(c, lam, k, h1, 'upwind')\n        E_disp_up_h2, E_diss_up_h2 = calculate_errors(c, lam, k, h2, 'upwind')\n        p_disp_up = calculate_p(E_disp_up_h1, E_disp_up_h2)\n        p_diss_up = calculate_p(E_diss_up_h1, E_diss_up_h2)\n\n        # Lax-Wendroff Scheme\n        E_disp_lw_h1, E_diss_lw_h1 = calculate_errors(c, lam, k, h1, 'lw')\n        E_disp_lw_h2, E_diss_lw_h2 = calculate_errors(c, lam, k, h2, 'lw')\n        p_disp_lw = calculate_p(E_disp_lw_h1, E_disp_lw_h2)\n        p_diss_lw = calculate_p(E_diss_lw_h1, E_diss_lw_h2)\n        \n        results.extend([p_disp_up, p_diss_up, p_disp_lw, p_diss_lw])\n\n    # Format output as a comma-separated list of floats within brackets.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在计算聚变科学等复杂系统的模拟中，实用的数值格式设计往往需要在不同性能指标之间做出权衡。例如，为了保证等离子体密度和压力等物理量的正定性而引入的修正，可能会对格式的精度产生副作用。本练习将引导你分析一种在磁流体动力学（MHD）模拟中常用的保正通量修正方法，并量化这种修正对磁声波传播所带来的额外数值耗散与频散。这项实践让你将误差分析技能应用于前沿的聚变研究问题，学会评估和理解复杂物理模型中数值方法设计的内在权衡。",
            "id": "4022280",
            "problem": "您的任务是为一维可压缩磁流体动力学（MHD）设计并分析一种保正性数值通量修正方法，并在代表聚变等离子体建模的线性波测试中，量化其对数值耗散和数值色散的副作用。从一维理想可压缩MHD的守恒律形式和采用均匀网格间距的有限体积法（FVM）出发。使用以下基本依据：\n\n- 一维理想可压缩磁流体动力学（MHD）中的质量、动量和能量守恒律。\n- 声速 $c_s$ 的定义由 $c_s^2 = \\gamma p / \\rho$ 给出，其中 $\\gamma$ 为绝热指数，$p$ 为压力，$\\rho$ 为密度。\n- Alfvén 速度 $c_A$ 的定义由 $c_A^2 = B^2 / (\\mu_0 \\rho)$ 给出，其中 $B$ 为磁场大小，$\\mu_0$ 为自由空间磁导率。\n- 对于相对于背景磁场的平行传播，快磁声波和慢磁声波的特征速度分别为 $c_f = \\max(c_s, c_A)$ 和 $c_{slow} = \\min(c_s, c_A)$。\n- Courant-Friedrichs-Lewy (CFL) 数为 $\\mathrm{CFL} = a \\Delta t / \\Delta x$，其中 $a$ 是 Rusanov（局部 Lax-Friedrichs）通量中选用的特征速度，$\\Delta t$ 是时间步长，$\\Delta x$ 是网格间距。\n\n在 Rusanov 通量框架内，通过一个乘法因子增加其耗散系数来设计一个保正性通量修正，并分析其在数值耗散和色散方面引起的变化。Rusanov 通量参数 $a$ 必须选择为与所考虑波相关的特征速度的一个物理上合理的上界。保正性修正被建模为将 Rusanov 粘性乘以一个因子 $ \\beta \\ge 1$，并统一应用于所有特征场。在线性化和特征分解下，将每个压缩波视为速度为 $c$ 的解耦标量平流模式。\n\n对于波数为 $k$、网格间距为 $\\Delta x$ 的线性傅里叶模式，定义无量纲波数 $\\kappa = k \\Delta x$。使用一阶显式欧拉时间推进和耗散由 $\\beta$ 缩放的一阶 Rusanov 通量，推导标量特征场的离散放大因子 $g(\\kappa)$，并利用 $g$ 的复对数计算数值角频率 $\\omega_{\\mathrm{num}}$ 和阻尼率 $\\gamma_{\\mathrm{num}}$。然后计算数值相速度 $c_{\\mathrm{num}} = \\omega_{\\mathrm{num}} / k$。通过与未修正基线（$\\beta = 1$）相比的以下差异，来量化保正性修正的副作用：\n- 相对相速度误差，定义为 $\\Delta \\varepsilon = \\left(\\frac{c_{\\mathrm{num}}^{(\\beta)} - c_{\\mathrm{num}}^{(1)}}{c}\\right)$（无量纲），以及\n- 超额阻尼率，定义为 $\\Delta \\gamma = \\gamma_{\\mathrm{num}}^{(\\beta)} - \\gamma_{\\mathrm{num}}^{(1)}$（单位为 $\\mathrm{s}^{-1}$）。\n\n您必须在一个单一、完整、可运行的程序中实现这些计算，并遵守最终答案规范中说明的执行环境约束。所有带物理单位的量必须得到一致处理，并以要求的单位报告。角度始终以弧度为单位。\n\n使用以下参数集测试套件；每个测试为一个线性波定义了物理和数值参数，并且必须独立处理：\n\n- 测试 1（声波，无磁场）：$c_s = 2.0 \\times 10^{5}\\ \\mathrm{m/s}$，$B = 0$ 故 $c_A = 0$，选择 $c = c_s$，选择 $a = c$，网格间距 $\\Delta x = 1.0 \\times 10^{-3}\\ \\mathrm{m}$，无量纲波数 $\\kappa = \\pi/3$，$\\mathrm{CFL} = 0.8$，保正性缩放因子 $\\beta = 1.4$。\n- 测试 2（快磁声波，平行传播）：$c_s = 1.0 \\times 10^{5}\\ \\mathrm{m/s}$，$c_A = 2.0 \\times 10^{5}\\ \\mathrm{m/s}$，选择 $c = c_f = \\max(c_s, c_A)$，选择 $a = c_f$，网格间距 $\\Delta x = 1.0 \\times 10^{-3}\\ \\mathrm{m}$，无量纲波数 $\\kappa = 0.5$，$\\mathrm{CFL} = 0.9$，保正性缩放因子 $\\beta = 1.2$。\n- 测试 3（慢磁声波，平行传播，高波数）：$c_s = 1.0 \\times 10^{5}\\ \\mathrm{m/s}$，$c_A = 2.0 \\times 10^{5}\\ \\mathrm{m/s}$，选择 $c = c_{slow} = \\min(c_s, c_A)$，选择 $a = c_f = \\max(c_s, c_A)$，网格间距 $\\Delta x = 1.0 \\times 10^{-3}\\ \\mathrm{m}$，无量纲波数 $\\kappa = 0.9\\pi$，$\\mathrm{CFL} = 0.9$，保正性缩放因子 $\\beta = 1.2$。\n- 测试 4（接近稳定性极限的声波）：$c_s = 1.5 \\times 10^{5}\\ \\mathrm{m/s}$，$B = 0$ 故 $c_A = 0$，选择 $c = c_s$，选择 $a = c$，网格间距 $\\Delta x = 1.0 \\times 10^{-3}\\ \\mathrm{m}$，无量纲波数 $\\kappa = \\pi/8$，$\\mathrm{CFL} = 0.99$，保正性缩放因子 $\\beta = 1.6$。\n\n对于每个测试，计算：\n- 相对相速度误差的差异 $\\Delta \\varepsilon$（无量纲），以及\n- 超额阻尼率 $\\Delta \\gamma$（单位为 $\\mathrm{s}^{-1}$）。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，格式与此完全一致：\n$[ [\\Delta \\varepsilon_1, \\Delta \\gamma_1], [\\Delta \\varepsilon_2, \\Delta \\gamma_2], [\\Delta \\varepsilon_3, \\Delta \\gamma_3], [\\Delta \\varepsilon_4, \\Delta \\gamma_4] ]$。",
            "solution": "我们从一维理想可压缩磁流体动力学（MHD）守恒律开始，使用有限体积法（FVM）在间距为 $\\Delta x$ 的均匀网格上进行离散化。对于线性分析，在密度、压力和磁场沿 $x$ 轴方向恒定的均匀平衡态附近，特征场会解耦成以恒定速度平流信息的波。在平行传播中，压缩模式是速度为 $c_f = \\max(c_s, c_A)$ 的快磁声波和速度为 $c_{slow} = \\min(c_s, c_A)$ 的慢磁声波；在没有磁场（$B=0$）的情况下，压缩波简化为速度为 $c = c_s$ 的声波。\n\n我们考虑一个一阶显式欧拉时间推进格式和一个一阶 Rusanov（局部 Lax-Friedrichs）通量，用于处理在线性化设定下服从 $\\partial_t u + c \\partial_x u = 0$ 的单个特征标量场 $u(x,t)$。在界面 $i+1/2$ 处的数值通量定义为\n$$\nF_{i+1/2} = \\frac{1}{2} c \\left(u_i + u_{i+1} \\right) - \\frac{1}{2} \\beta a \\left(u_{i+1} - u_i \\right) ,\n$$\n其中 $a$ 是 Rusanov 通量所选用的特征速度，$\\beta \\ge 1$ 是一个乘法缩放因子，它作为一种保正性修正来增强数值粘性。在时间层 $n$ 的单元平均值 $u_i^n$ 的前向欧拉更新为\n$$\nu_i^{n+1} = u_i^{n} - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right) .\n$$\n\n为了分析傅里叶模式的色散和耗散，考虑一个模式 $u_i^n = U^n e^{\\mathrm{i} i \\kappa}$，其中 $\\kappa = k \\Delta x$ 是无量纲波数，$k$ 是物理波数，单位为 $\\mathrm{rad/m}$。使用离散傅里叶恒等式，\n$$\nu_{i+1} - u_{i-1} = 2\\mathrm{i} \\sin(\\kappa) u_i, \\quad u_{i+1} - 2u_i + u_{i-1} = -4 \\sin^2\\left(\\frac{\\kappa}{2}\\right) u_i .\n$$\n代入更新方程可得到离散放大因子 $g(\\kappa)$：\n$$\ng(\\kappa) = 1 - \\mathrm{i} \\left(\\frac{c\\Delta t}{\\Delta x}\\right) \\sin(\\kappa) - 2 \\beta \\left(\\frac{a \\Delta t}{\\Delta x}\\right) \\sin^2\\left(\\frac{\\kappa}{2}\\right)\n$$\n其中 $\\lambda = \\frac{c \\Delta t}{\\Delta x}$ 是平流 Courant 数。复放大因子 $g$ 控制着色散和耗散。将 $g$ 写为 $g = r e^{\\mathrm{i}\\phi}$，其中 $r = |g|$，辐角为 $\\phi = \\arg(g)$，单步演化为 $U^{n+1} = g U^n$，对应于连续表示 $U(t+\\Delta t) = \\exp\\left( (\\gamma_{\\mathrm{num}} + \\mathrm{i}\\omega_{\\mathrm{num}}) \\Delta t \\right) U(t)$。因此，\n$$\n\\ln(g) = \\ln(r) + \\mathrm{i} \\phi = \\gamma_{\\mathrm{num}} \\Delta t + \\mathrm{i}\\omega_{\\mathrm{num}} \\Delta t .\n$$\n因此，数值角频率 $\\omega_{\\mathrm{num}}$ 和阻尼率 $\\gamma_{\\mathrm{num}}$ 可通过 $g$ 的复对数获得：\n$$\n\\omega_{\\mathrm{num}} = \\frac{\\operatorname{Im} (\\ln g)}{\\Delta t}, \\quad \\gamma_{\\mathrm{num}} = \\frac{\\operatorname{Re} (\\ln g)}{\\Delta t} .\n$$\n然而，为了与物理波 $e^{i(kx - \\omega t)}$ 的约定保持一致，我们将频率定义为 $\\omega_{\\mathrm{phys}} > 0$ 用于正向传播。放大因子应为 $G \\approx e^{i(-c k)\\Delta t} = e^{-i\\omega_{\\text{exact}}\\Delta t}$。因此，数值频率应从 $e^{-i\\omega_{\\text{num}}\\Delta t}$ 定义，给出 $\\omega_{\\text{num}} = -\\operatorname{Im}(\\ln g)/\\Delta t$。同样，阻尼（振幅衰减）对应于负的增长率 $\\gamma_{\\mathrm{num}}$，因此 $e^{\\gamma_{\\text{num}}\\Delta t} = |g|$ 给出 $\\gamma_{\\text{num}} = \\operatorname{Re}(\\ln g) / \\Delta t$。\n数值相速度为 $c_{\\mathrm{num}} = \\omega_{\\mathrm{num}} / k$。\n\n保正性设计原理：在多空间维度和完全可压缩 MHD 问题中，当检测到保正性违背时，可以通过将一个低阶单调通量（例如 Rusanov 通量）混合到高阶通量中，来保证高阶格式中密度和压力的正性。一阶格式单调性的一个充分条件是 $u_i$ 的更新是其相邻状态的凸组合，这在 $u_{i-1}$、$u_i$ 和 $u_{i+1}$ 的系数为非负且和为一时成立。对于带有修正 Rusanov 通量的标量线性平流方程，一个守恒的更新可以表示为\n$$\nu_i^{n+1} = \\alpha_{-1} u_{i-1}^{n} + \\alpha_0 u_i^n + \\alpha_{+1} u_{i+1}^n\n$$\n其中\n$$\n\\alpha_{\\pm 1} = \\frac{\\Delta t}{2\\Delta x} \\left( \\beta a \\mp c \\right), \\quad \\alpha_0 = 1 - \\frac{\\Delta t}{\\Delta x} \\beta a .\n$$\n$\\alpha_{\\pm 1}$ 和 $\\alpha_0$ 的非负性要求\n$$\n\\frac{\\Delta t}{\\Delta x} \\beta a \\le 1 \\quad \\text{和} \\quad \\beta a \\ge |c|,\n$$\n如果我们选择 $a$ 作为所有特征速度的上界并且 $\\beta \\ge 1$，则后一个条件自动满足。在这些条件下，该格式是单调的，因此在线性层面上对凸不变量是保正的。这为增加 $\\beta$ 提供了动机，以便在非线性 MHD 中作为后备方案应用时，防止密度和压力出现负值。增加 $\\beta$ 的副作用是增加了人工粘性，这主要通过增加负实部（阻尼）来修改 $g(\\kappa)$，其次通过改变虚部（色散）来修改它。\n\n计算每个测试用例所需指标的算法步骤：\n1. 确定适用于该测试的物理波速 $c$：对于声波，$c = c_s$；对于快磁声波，$c = c_f = \\max(c_s, c_A)$；对于慢磁声波，$c = c_{slow} = \\min(c_s, c_A)$。\n2. 根据测试规范选择 Rusanov 特征速度 $a$（对于 MHD 通常为 $a = c_f$，对于声学问题为 $a = c_s$）。\n3. 给定网格间距 $\\Delta x$ 和无量纲波数 $\\kappa$，计算物理波数 $k = \\kappa / \\Delta x$，单位为 $\\mathrm{rad/m}$。\n4. 使用指定的 Courant-Friedrichs-Lewy 数计算时间步长 $\\Delta t = \\mathrm{CFL} \\, \\Delta x / a$。\n5. 通过以下公式构建基线（$\\beta = 1$）和保正性修正（$\\beta$ 为指定值）的放大因子 $g(\\kappa)$：\n$$\ng(\\kappa) = 1 - \\mathrm{i} \\left(\\frac{c \\Delta t}{\\Delta x}\\right) \\sin(\\kappa) - 2 \\beta \\left(\\frac{a \\Delta t}{\\Delta x}\\right) \\sin^2\\left(\\frac{\\kappa}{2}\\right) .\n$$\n6. 对两种情况计算 $\\ln(g)$，然后如上计算 $\\omega_{\\mathrm{num}}$ 和 $\\gamma_{\\mathrm{num}}$，并得到 $c_{\\mathrm{num}} = \\omega_{\\mathrm{num}}/k$。\n7. 报告差异 $\\Delta \\varepsilon = \\left(\\frac{c_{\\mathrm{num}}^{(\\beta)} - c_{\\mathrm{num}}^{(1)}}{c}\\right)$（无量纲）和 $\\Delta \\gamma = \\gamma_{\\mathrm{num}}^{(\\beta)} - \\gamma_{\\mathrm{num}}^{(1)}$（单位为 $\\mathrm{s}^{-1}$）。注意增长率 $\\gamma$ 为负时表示阻尼。\n\n科学真实性：所选的速度和网格间距与聚变等离子体参数一致，其中 $c_s$ 和 $c_A$ 可在 $10^5\\ \\mathrm{m/s}$ 的量级，而 $\\Delta x = 10^{-3}\\ \\mathrm{m}$ 在简化模型尺度上是合理的离散化。该分析遵循线性化特征场，这是色散-耗散研究的一种标准且经过充分检验的方法。单位被一致地处理。\n\n该测试套件包含四个案例，涵盖了声波和磁声波、中等和接近边界的 CFL 数，以及低波数和高波数，从而确保了对色散和耗散行为的覆盖。最终程序输出为单行，包含一个由数对 $[\\Delta \\varepsilon_i, \\Delta \\gamma_i]$（$i=1,2,3,4$）组成的列表，其格式与 $[ [\\Delta \\varepsilon_1, \\Delta \\gamma_1], [\\Delta \\varepsilon_2, \\Delta \\gamma_2], [\\Delta \\varepsilon_3, \\Delta \\gamma_3], [\\Delta \\varepsilon_4, \\Delta \\gamma_4] ]$ 完全一致。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_metrics(c, a, dx, kappa, CFL, beta_pos):\n    \"\"\"\n    Compute delta phase error (dimensionless) and excess damping rate (1/s)\n    due to positivity-preserving modification (beta_pos) relative to baseline (beta=1).\n    Parameters:\n        c       : physical wave speed (m/s)\n        a       : Rusanov characteristic speed (m/s)\n        dx      : grid spacing (m)\n        kappa   : dimensionless wavenumber (radians)\n        CFL     : Courant-Friedrichs-Lewy number (dimensionless)\n        beta_pos: positivity scaling factor (>=1, dimensionless)\n    Returns:\n        (delta_rel_phase_error, delta_damping_rate)\n    \"\"\"\n    # Physical wavenumber (rad/m)\n    k = kappa / dx\n    # Time step from CFL\n    dt = CFL * dx / a\n\n    # Helper to compute amplification factor g for given beta\n    def amplification(beta):\n        lam_adv = (c * dt) / dx\n        lam_diss = (a * dt) / dx\n        g = 1.0 - 1j * lam_adv * np.sin(kappa) - 2.0 * beta * lam_diss * (np.sin(kappa / 2.0) ** 2)\n        return g\n\n    # Baseline (beta=1.0) and positivity-preserving (beta=beta_pos)\n    g_base = amplification(1.0)\n    g_pos = amplification(beta_pos)\n\n    # Complex logarithm to get numerical angular frequency and growth/damping rate\n    # Convention: wave is exp(i*(k*x - omega*t)), so G ~ exp(-i*omega*dt)\n    # Damping: amplitude decays as exp(gamma*t) where gamma  0 for damping. |G|=exp(gamma*dt)\n    ln_base = np.log(g_base)\n    ln_pos = np.log(g_pos)\n\n    omega_base = -np.imag(ln_base) / dt  # rad/s\n    omega_pos = -np.imag(ln_pos) / dt    # rad/s\n\n    gamma_base = np.real(ln_base) / dt  # 1/s\n    gamma_pos = np.real(ln_pos) / dt    # 1/s\n\n    # Numerical phase speeds (m/s)\n    c_num_base = omega_base / k if k != 0 else c\n    c_num_pos = omega_pos / k if k != 0 else c\n\n    # Side effects: differences relative to baseline\n    delta_rel_phase_error = (c_num_pos - c_num_base) / c  # dimensionless\n    # Excess damping rate is the difference in growth rates.\n    # A more negative growth rate means more damping.\n    delta_damping_rate = gamma_pos - gamma_base           # 1/s\n\n    return float(delta_rel_phase_error), float(delta_damping_rate)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: Acoustic wave, no magnetic field\n        {\"c_s\": 2.0e5, \"c_A\": 0.0, \"choose_c\": \"acoustic\", \"a_rule\": \"acoustic\",\n         \"dx\": 1.0e-3, \"kappa\": np.pi/3.0, \"CFL\": 0.8, \"beta_pos\": 1.4},\n        # Test 2: Fast magnetosonic wave, parallel propagation\n        {\"c_s\": 1.0e5, \"c_A\": 2.0e5, \"choose_c\": \"fast\", \"a_rule\": \"fast\",\n         \"dx\": 1.0e-3, \"kappa\": 0.5, \"CFL\": 0.9, \"beta_pos\": 1.2},\n        # Test 3: Slow magnetosonic wave, high wavenumber\n        {\"c_s\": 1.0e5, \"c_A\": 2.0e5, \"choose_c\": \"slow\", \"a_rule\": \"fast\",\n         \"dx\": 1.0e-3, \"kappa\": 0.9*np.pi, \"CFL\": 0.9, \"beta_pos\": 1.2},\n        # Test 4: Acoustic wave near stability limit\n        {\"c_s\": 1.5e5, \"c_A\": 0.0, \"choose_c\": \"acoustic\", \"a_rule\": \"acoustic\",\n         \"dx\": 1.0e-3, \"kappa\": np.pi/8.0, \"CFL\": 0.99, \"beta_pos\": 1.6},\n    ]\n\n    results = []\n    for case in test_cases:\n        c_s = case[\"c_s\"]\n        c_A = case[\"c_A\"]\n        # Select wave speed c\n        if case[\"choose_c\"] == \"acoustic\":\n            c = c_s\n        elif case[\"choose_c\"] == \"fast\":\n            c = max(c_s, c_A)\n        elif case[\"choose_c\"] == \"slow\":\n            c = min(c_s, c_A)\n        else:\n            raise ValueError(\"Unknown choose_c rule\")\n\n        # Select Rusanov speed a\n        if case[\"a_rule\"] == \"acoustic\":\n            a = c_s\n        elif case[\"a_rule\"] == \"fast\":\n            a = max(c_s, c_A)\n        else:\n            raise ValueError(\"Unknown a_rule\")\n\n        dx = case[\"dx\"]\n        kappa = case[\"kappa\"]\n        CFL = case[\"CFL\"]\n        beta_pos = case[\"beta_pos\"]\n\n        delta_rel_phase_error, delta_damping_rate = compute_metrics(\n            c=c, a=a, dx=dx, kappa=kappa, CFL=CFL, beta_pos=beta_pos\n        )\n        results.append([delta_rel_phase_error, delta_damping_rate])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```"
        }
    ]
}