{
    "hands_on_practices": [
        {
            "introduction": "At the heart of Adaptive Mesh Refinement (AMR) are the interfaces where coarse and fine grids meet. To accurately compute physical quantities on fine-grid cells near these boundaries, the numerical stencil requires data from \"ghost\" cells that effectively extend the fine grid into the coarse region. This exercise guides you through the geometric reasoning needed to determine the minimum width of this ghost-cell layer, a fundamental step in ensuring the structural integrity and correctness of any patch-based AMR simulation. ",
            "id": "3946715",
            "problem": "Consider a one-dimensional patch-based Adaptive Mesh Refinement (AMR) discretization for a resistive Magnetohydrodynamics (MHD) plasma simulation, with refinement ratio $r \\in \\mathbb{N}$ between a coarse level and a fine level. The fine-level cell size is $h_{f} = h_{c}/r$, where $h_{c}$ is the coarse-level cell size. The time advance on the fine level uses a $p$-th order, symmetric, cell-centered, explicit finite-volume scheme whose spatial discretization requires a compact symmetric stencil of radius $s$ fine cells on each side of the target fine cell (that is, the stencil touches $2s+1$ fine cells centered at the target).\n\nAt a coarse-fine interface, the fine level abuts the coarse level directly. The fine level maintains a ghost layer of width $g$ fine cells outside the patch boundary to enable valid stencil evaluations for fine-level cells adjacent to the interface. Ghost values are populated from the coarse level by a conservative prolongation consistent with the same accuracy order $p$, using a compact, symmetric stencil in coarse cells that does not require data beyond coarse interior cells directly adjacent to the interface. To ensure conservative flux reconciliation and avoid fractional coarse supports, the ghost region must align to complete coarse-cell blocks, so $g$ must be a multiple of $r$.\n\nStarting from these definitions and constraints, derive the minimal fine-level ghost width $g$ (in fine cells) as a function of the fine-level stencil radius $s$ and the integer refinement ratio $r$, such that:\n- Every fine-level stencil centered at any fine interior cell that touches the interface (i.e., within the first $s$ fine cells next to the boundary) is entirely covered by either fine interior or fine ghost data.\n- The coarse-to-fine prolongation needed to populate the fine ghost layer can be formed from complete coarse-cell blocks immediately adjoining the interface, with no requirement of accessing coarse data beyond the nearest coarse interior cells.\n\nGive your final answer as a closed-form analytical expression $g(s,r)$.",
            "solution": "The problem asks for the minimal fine-level ghost width, denoted by $g$, as a function of the fine-level stencil radius, $s$, and the integer refinement ratio, $r$. The derivation must satisfy two principal constraints outlined in the problem statement.\n\nFirst, we analyze the constraint imposed by the fine-level numerical stencil. The scheme is described as using a compact symmetric stencil of radius $s$ fine cells. This means that to compute the updated value for a fine cell at index $i$, data from all cells in the closed interval $[i-s, i+s]$ are required.\n\nLet us define the one-dimensional domain such that the fine-level patch occupies the region $x  0$, with the coarse-fine interface located at $x=0$. The fine-level cells are indexed $j=1, 2, 3, \\dots$ for interior cells. The ghost cells, which are required to provide boundary data, will occupy the region $x  0$ and can be indexed $j=0, -1, -2, \\dots$.\n\nThe problem states that the ghost layer must be sufficiently wide so that \"Every fine-level stencil centered at any fine interior cell that touches the interface (i.e., within the first $s$ fine cells next to the boundary) is entirely covered by either fine interior or fine ghost data.\"\n\nLet's consider the fine interior cell that imposes the most stringent requirement on the ghost-cell width. This is the cell closest to the interface, at index $j=1$. The stencil for this cell spans from index $1-s$ to $1+s$. The cells with indices from $1$ to $1+s$ are within the fine-level patch's interior. The cells with indices from $1-s$ to $0$ must be provided by the ghost layer.\n\nThe required ghost-cell indices are $\\{0, -1, \\dots, 1-s\\}$. The number of cells in this set is $0 - (1-s) + 1 = s$. Therefore, to service the stencil of the first interior fine cell, the ghost layer must have a width of at least $s$ cells. This gives us our first constraint on $g$:\n$$\ng \\ge s\n$$\nAny other interior cell $j$ where $1  j \\le s$ also has a stencil that crosses the interface, requiring ghost cells with indices from $j-s$ to $0$. Since $j1$, the lowest index required is $j-s  1-s$, so the requirement from cell $j=1$ is indeed the most demanding.\n\nSecond, we analyze the constraint related to the grid structure and the prolongation operator. The problem explicitly states that \"To ensure conservative flux reconciliation and avoid fractional coarse supports, the ghost region must align to complete coarse-cell blocks, so $g$ must be a multiple of $r$.\"\n\nHere, $r$ is the refinement ratio, meaning one coarse cell has the same width as $r$ fine cells ($h_c = r h_f$). The constraint that the ghost region of width $g h_f$ must be made of \"complete coarse-cell blocks\" means its total width must be an integer multiple of the coarse cell width $h_c$.\n$$\ng h_f = k h_c\n$$\nfor some positive integer $k \\in \\mathbb{N}$ (since $g0$). Substituting $h_c = r h_f$, we get:\n$$\ng h_f = k (r h_f)\n$$\n$$\ng = k r\n$$\nThis provides the second constraint: $g$ must be an integer multiple of $r$. The information about the prolongation stencil's order $p$ and its symmetry serves as the physical and numerical justification for this structural constraint, ensuring that the source data for interpolation (the coarse cells) align perfectly with the target region (the fine ghost cells). The problem formulation implies that satisfying this structural alignment is sufficient, and we do not need to independently use $p$ to determine the stencil width of the prolongation operator itself.\n\nWe must find the minimal value of $g$ that satisfies both constraints simultaneously:\n1. $g \\ge s$\n2. $g = k r$ for some $k \\in \\{1, 2, 3, \\dots\\}$\n\nCombining these two conditions, we have:\n$$\nk r \\ge s\n$$\nSolving for the integer $k$:\n$$\nk \\ge \\frac{s}{r}\n$$\nSince we seek the minimal possible value for $g$, we must find the smallest integer $k$ that satisfies this inequality. The smallest integer greater than or equal to a real number $x$ is given by the ceiling function, $\\lceil x \\rceil$.\nTherefore, the minimal integer value for $k$ is:\n$$\nk_{min} = \\left\\lceil \\frac{s}{r} \\right\\rceil\n$$\nSubstituting this minimal value of $k$ back into the expression for $g$, we obtain the minimal required ghost width:\n$$\ng(s, r) = k_{min} \\cdot r = r \\left\\lceil \\frac{s}{r} \\right\\rceil\n$$\nThis expression gives the smallest number of ghost cells, $g$, that is both larger than or equal to the stencil radius $s$ and is an integer multiple of the refinement ratio $r$.",
            "answer": "$$\n\\boxed{r \\left\\lceil \\frac{s}{r} \\right\\rceil}\n$$"
        },
        {
            "introduction": "With a properly structured multi-level grid, the next challenge is to evolve the simulation in time both stably and efficiently. Explicit schemes are constrained by the Courant–Friedrichs–Lewy (CFL) condition, which dictates that finer grids require smaller time steps. This practice explores how \"subcycling\"—taking multiple small time steps on fine levels for each single step on a coarse level—provides an elegant solution. You will derive the master time step constraint that guarantees stability across all levels of the AMR hierarchy simultaneously. ",
            "id": "3946763",
            "problem": "Consider explicit finite volume discretization of the ideal Magnetohydrodynamics (MHD) equations in conservative form on a uniform Cartesian base mesh with spacing $h_0$ in $d$ spatial dimensions. The mesh employs block-structured Adaptive Mesh Refinement (AMR), with refinement ratio $r$, so that the level-$\\ell$ spacing is $h_{\\ell} = h_0 / r^{\\ell}$. Assume an upwind numerical flux constructed from a stable Riemann solver with a spectral radius bounded by the maximum characteristic wave speed $a$, defined as the maximum over all directions and all MHD characteristic families (including fast magnetosonic waves) of the absolute values of the eigenvalues of the flux Jacobians. The time integration is performed explicitly with a Strong Stability Preserving Runge–Kutta (SSP RK) method, using level-dependent time steps $\\Delta t_{\\ell} = \\Delta t_0 / r^{\\ell}$ (with subcycling in time). Let the chosen Courant number $C$ satisfy $0  C \\leq 1$, and assume standard conservative flux differencing using one-cell face fluxes per direction on each level.\n\nStarting from the foundational stability requirement for explicit schemes approximating hyperbolic conservation laws—namely, that information must not travel more than one cell per time step in any direction—derive the Courant–Friedrichs–Lewy (CFL) condition that guarantees stability for the described explicit MHD scheme in $d$ dimensions. Express this condition in terms of $h_{\\ell}$, $a$, $d$, and $C$. Then, using the prescribed AMR time step schedule $\\Delta t_{\\ell} = \\Delta t_0 / r^{\\ell}$, show that there exists a maximum base-level time step $\\Delta t_{0,\\max}$ that ensures the CFL condition is satisfied simultaneously on all refinement levels. Provide the final expression for $\\Delta t_{0,\\max}$ in closed form, in terms of $h_0$, $a$, $d$, and $C$.\n\nYour final answer must be a single analytic expression. No numerical evaluation is required.",
            "solution": "The problem requires the derivation of the Courant–Friedrichs–Lewy (CFL) stability condition for an explicit finite volume scheme for ideal Magnetohydrodynamics (MHD) on a $d$-dimensional adaptive mesh, and from this, the determination of the maximum permissible time step on the base grid level.\n\nThe starting point is the foundational principle of stability for explicit numerical methods for hyperbolic partial differential equations. The CFL condition dictates that the numerical domain of dependence of a computational cell must contain the physical domain of dependence. For a simple one-dimensional scheme, this is commonly expressed as the Courant number $C = a \\frac{\\Delta t}{\\Delta x}$ being less than some constant, typically $1$. The problem defines $C$ as the upper bound for this ratio, so the stability condition is $a \\frac{\\Delta t}{h} \\leq C$.\n\nWe must extend this to a $d$-dimensional Cartesian grid with uniform spacing $h_{\\ell}$ at refinement level $\\ell$. The problem states the use of an explicit finite volume method with \"one-cell face fluxes per direction.\" This corresponds to a method-of-lines formulation where the spatial operator is a sum of one-dimensional flux difference operators, one for each spatial dimension:\n$$\n\\frac{dU_{i_1, \\dots, i_d}}{dt} = -\\sum_{k=1}^{d} \\frac{1}{h_{\\ell}} \\left( \\hat{F}_{k, i_k+1/2} - \\hat{F}_{k, i_k-1/2} \\right)\n$$\nwhere $U$ is the vector of conserved quantities in a cell and $\\hat{F}$ is the numerical flux. For an explicit time integration scheme (like the SSP RK method mentioned), the time step $\\Delta t_{\\ell}$ is limited by the spectral radius of the discretized spatial operator. For the summation of one-dimensional operators, the total spectral radius is bounded by the sum of the spectral radii of the individual operators.\n\nThe maximum characteristic wave speed is given as $a$. This speed is isotropic, meaning it is the maximum propagation speed in any direction. The spectral radius of the one-dimensional flux difference operator in direction $k$ is proportional to $a / h_{\\ell}$. Summing the contributions from all $d$ dimensions gives the stability condition:\n$$\n\\Delta t_{\\ell} \\sum_{k=1}^{d} \\frac{a}{h_{\\ell}} \\leq C\n$$\nSince the sum consists of $d$ identical terms, this simplifies to the CFL condition for a given level $\\ell$:\n$$\n\\Delta t_{\\ell} \\frac{d \\cdot a}{h_{\\ell}} \\leq C\n$$\nThis expression provides the required stability condition in terms of $h_{\\ell}$, $a$, $d$, and $C$.\n\nNext, we must analyze this condition in the context of the prescribed adaptive mesh refinement (AMR) structure. The problem states that the grid spacing and time step on level $\\ell$ are related to the base-level ($\\ell=0$) values by a refinement ratio $r$:\n$$\nh_{\\ell} = \\frac{h_0}{r^{\\ell}}\n$$\n$$\n\\Delta t_{\\ell} = \\frac{\\Delta t_0}{r^{\\ell}}\n$$\nThis time-stepping scheme is known as subcycling, where finer levels evolve with smaller time steps. To ensure stability across the entire AMR hierarchy, the CFL condition must be satisfied on every level $\\ell = 0, 1, 2, \\ldots$.\n\nWe substitute the AMR-specific expressions for $h_{\\ell}$ and $\\Delta t_{\\ell}$ into the level-$\\ell$ CFL condition:\n$$\n\\left( \\frac{\\Delta t_0}{r^{\\ell}} \\right) \\frac{d \\cdot a}{\\left( \\frac{h_0}{r^{\\ell}} \\right)} \\leq C\n$$\nThe factor of $r^{\\ell}$ in the denominator of both $\\Delta t_{\\ell}$ and $h_{\\ell}$ cancels out:\n$$\n\\frac{\\Delta t_0 \\cdot r^{\\ell}}{r^{\\ell}} \\frac{d \\cdot a}{h_0} \\leq C\n$$\n$$\n\\frac{\\Delta t_0 \\cdot d \\cdot a}{h_0} \\leq C\n$$\nThis resulting inequality is a condition on the base-level time step $\\Delta t_0$ that is entirely independent of the refinement level $\\ell$. This demonstrates that if we choose a $\\Delta t_0$ that satisfies this condition, the CFL criterion will hold simultaneously on all refinement levels. The set of all valid $\\Delta t_0$ values is non-empty and has an upper bound. Therefore, a maximum base-level time step, $\\Delta t_{0,\\max}$, exists.\n\nTo find the expression for this maximum time step, we solve the inequality for $\\Delta t_0$:\n$$\n\\Delta t_0 \\leq \\frac{C \\cdot h_0}{d \\cdot a}\n$$\nThe maximum allowed value for the base-level time step, $\\Delta t_{0,\\max}$, is achieved when the equality holds:\n$$\n\\Delta t_{0,\\max} = \\frac{C h_0}{d a}\n$$\nThis is the final expression for the maximum base-level time step that ensures stability for the entire AMR grid structure under the specified subcycling scheme.",
            "answer": "$$\\boxed{\\frac{C h_0}{d a}}$$"
        },
        {
            "introduction": "The power of AMR comes from its ability to dynamically change the grid in response to evolving physical features. This requires a robust set of rules for deciding when and where to refine or coarsen the mesh. Simply reacting to instantaneous conditions can lead to \"grid thrashing,\" an inefficient state where cells are rapidly toggled back and forth. This final practice challenges you to translate physical principles into a working algorithm by designing a hysteresis policy, a crucial technique that introduces memory and stability into the adaptive logic. ",
            "id": "3946761",
            "problem": "You are tasked with designing a refinement threshold and a hysteresis policy for adaptive mesh refinement in a one-dimensional magnetohydrodynamics (MHD) plasma simulation using the current-density magnitude and vorticity. The aim is to decide, for each mesh cell and at each discrete time step, whether it should be flagged as refined or coarse, while preventing rapid oscillation of refinement decisions as the fields evolve. You must derive the thresholds from first principles and implement the hysteresis policy algorithmically.\n\nFundamental base and definitions:\n- Maxwell–Ampère law (quasi-static limit without displacement current): $\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$, where $\\mathbf{B}$ is magnetic field, $\\mathbf{J}$ is current density, and $\\mu_0$ is the permeability of free space.\n- Vorticity definition: $\\boldsymbol{\\omega} = \\nabla \\times \\mathbf{u}$, where $\\mathbf{u}$ is fluid velocity.\n- Characteristic scales: a reference magnetic-field magnitude $B_0$ (in Tesla, $\\,\\mathrm{T}$), a reference flow speed $U_0$ (in meters per second, $\\,\\mathrm{m/s}$), and a reference macroscopic length $L_0$ (in meters, $\\,\\mathrm{m}$).\n- Mesh spacing: $h$ (in meters, $\\,\\mathrm{m}$).\n- Current-density magnitude $J = \\|\\mathbf{J}\\|$ (in amperes per square meter, $\\,\\mathrm{A/m^2}$) and vorticity magnitude $\\omega = \\|\\boldsymbol{\\omega}\\|$ (in inverse seconds, $\\,\\mathrm{s^{-1}}$).\n\nDerivation mandate:\n- Starting from the above fundamental laws and definitions, derive a refinement threshold that responds to the smallest of the implied physical length scales associated with current sheets and shear layers. Use the fact that a magnetic variation over a length scale $\\ell_B$ implies $J \\sim B_0/(\\mu_0 \\ell_B)$, whereas a velocity variation over $\\ell_u$ implies $\\omega \\sim U_0/\\ell_u$. Define suitable characteristic normalizations $J_0$ and $\\omega_0$ from $B_0$, $U_0$, and $L_0$, and then construct a dimensionless trigger metric based on $J/J_0$ and $\\omega/\\omega_0$. You must logically justify the combination rule you use to merge the two triggers into a single refinement decision. Do not assume or quote a pre-made refinement formula; derive it from the requirement that the mesh should resolve the smallest active scale relative to $h$.\n- Design a hysteresis policy with two distinct thresholds (one for refinement and one for coarsening) and temporal dwell-time conditions (minimum consecutive time steps) to prevent rapid back-and-forth toggling when the metric fluctuates near a threshold. Explain why the policy avoids thrashing and respects the physics-derived threshold.\n\nAlgorithmic requirements:\n- The refinement state of each cell at each time step is binary: refined or coarse.\n- Use a single scalar dimensionless trigger metric per cell per time $M(t,i)$ derived from $J(t,i)$ and $\\omega(t,i)$ and the characteristic scales.\n- Define a refinement threshold $T_{\\mathrm{refine}}$ and a coarsening threshold $T_{\\mathrm{coarsen}}$, with $T_{\\mathrm{coarsen}}  T_{\\mathrm{refine}}$ to implement hysteresis, and dwell-time integers $N_{\\uparrow}$ and $N_{\\downarrow}$ for refinement and coarsening persistence, respectively.\n- Initialization: all cells start as coarse at the first time step.\n- State update at each time step:\n  - If $M(t,i) \\ge T_{\\mathrm{refine}}$ for at least $N_{\\uparrow}$ consecutive steps, switch the cell to refined.\n  - If $M(t,i) \\le T_{\\mathrm{coarsen}}$ for at least $N_{\\downarrow}$ consecutive steps, switch the cell to coarse.\n  - Otherwise, maintain the current state.\n- Count the total number of state toggles across all cells and time steps for each test case.\n- The units for physical quantities are mandatory:\n  - $J$ must be in $\\,\\mathrm{A/m^2}$.\n  - $\\omega$ must be in $\\,\\mathrm{s^{-1}}$.\n  - $B_0$ in $\\,\\mathrm{T}$.\n  - $U_0$ in $\\,\\mathrm{m/s}$.\n  - $L_0$ and $h$ in $\\,\\mathrm{m}$.\n\nTest suite and parameters:\n- Use $\\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{H/m}$.\n\n- Test Case 1 (happy path):\n  - $B_0 = 5\\,\\mathrm{T}$, $U_0 = 2 \\times 10^{4}\\,\\mathrm{m/s}$, $L_0 = 0.1\\,\\mathrm{m}$, $h = 0.01\\,\\mathrm{m}$, $\\kappa = 2$ (resolution factor), $\\gamma = 0.7$ (hysteresis ratio), $N_{\\uparrow} = 2$, $N_{\\downarrow} = 3$.\n  - Time steps: $T = 8$, cells: $N = 8$.\n  - Define dimensionless multipliers for current density and vorticity as follows, and then set $J(t,i) = J_0 \\times a_{t,i}$ and $\\omega(t,i) = \\omega_0 \\times b_{t,i}$, where $J_0 = B_0/(\\mu_0 L_0)$ and $\\omega_0 = U_0/L_0$:\n    - For cells $i \\in \\{0,1,2,3\\}$, $a_{t,i} = [6,6,6,4,4,4,4,4]$, $b_{t,i} = [2,2,2,2,2,2,2,2]$.\n    - For cells $i \\in \\{4,5,6,7\\}$, $a_{t,i} = [3,3,3,3,3,3,3,3]$, $b_{t,i} = [3,3,3,3,3,3,3,3]$.\n\n- Test Case 2 (boundary conditions near thresholds):\n  - $B_0 = 5\\,\\mathrm{T}$, $U_0 = 2 \\times 10^{4}\\,\\mathrm{m/s}$, $L_0 = 0.1\\,\\mathrm{m}$, $h = 0.02\\,\\mathrm{m}$, $\\kappa = 2$, $\\gamma = 0.8$, $N_{\\uparrow} = 2$, $N_{\\downarrow} = 3$.\n  - Time steps: $T = 8$, cells: $N = 8$.\n  - Dimensionless multipliers:\n    - For cells $i \\in \\{0,1\\}$, $a_{t,i} = [2.5,2.5,2.4,2.4,2.4,2.0,2.0,2.0]$, $b_{t,i} = [0,0,0,0,0,0,0,0]$.\n    - For cells $i \\in \\{2,3\\}$, $a_{t,i} = [2.5,2.4,2.5,2.4,2.5,2.4,2.5,2.4]$, $b_{t,i} = [0,0,0,0,0,0,0,0]$.\n    - For cells $i \\in \\{4,5,6,7\\}$, $a_{t,i} = [1.8,1.8,1.8,1.8,1.8,1.8,1.8,1.8]$, $b_{t,i} = [0,0,0,0,0,0,0,0]$.\n\n- Test Case 3 (spiky signals and hysteresis robustness):\n  - $B_0 = 5\\,\\mathrm{T}$, $U_0 = 2 \\times 10^{4}\\,\\mathrm{m/s}$, $L_0 = 0.1\\,\\mathrm{m}$, $h = 0.01\\,\\mathrm{m}$, $\\kappa = 2$, $\\gamma = 0.7$, $N_{\\uparrow} = 2$, $N_{\\downarrow} = 3$.\n  - Time steps: $T = 10$, cells: $N = 10$.\n  - Dimensionless multipliers:\n    - For cells $i \\in \\{0,1,2,3,4\\}$, $a_{t,i} = [6,3,6,3,6,3,6,3,6,3]$, $b_{t,i} = [0,0,0,0,0,0,0,0,0,0]$.\n    - For cells $i \\in \\{5,6,7\\}$, $a_{t,i} = [6,6,3,3,6,6,3,3,6,6]$, $b_{t,i} = [0,0,0,0,0,0,0,0,0,0]$.\n    - For cells $i \\in \\{8,9\\}$, $a_{t,i} = [6,6,6,6,6,6,6,6,6,6]$, $b_{t,i} = [0,0,0,0,0,0,0,0,0,0]$.\n\nOutput specification:\n- For each test case, after processing all time steps, compute:\n  1. The final count of refined cells (an integer).\n  2. The total number of refinement-state toggles across all cells and times (an integer).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list of the form $[R_{\\mathrm{final}},T_{\\mathrm{toggles}}]$. For example: $[[r_1,t_1],[r_2,t_2],[r_3,t_3]]$.\n\nAll numerical values and outputs must be computed in the specified units, and angles, if any appear, must be in radians; however, no angles are used in this problem. The final output must be a list of lists as described and must be printed exactly as one line.",
            "solution": "We begin by establishing physically motivated characteristic scales and the refinement decision criterion from fundamental laws. Magnetohydrodynamics (MHD) couples Maxwell’s equations and fluid dynamics. In the quasi-static limit without displacement current, the Maxwell–Ampère law gives $\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$. Consider a magnetic field $\\mathbf{B}$ that varies over a characteristic length scale $\\ell_B$ with magnitude $B_0$. Dimensionally, this implies $J \\sim B_0 / (\\mu_0 \\ell_B)$. Similarly, for the fluid velocity $\\mathbf{u}$ varying over $\\ell_u$ with magnitude $U_0$, the vorticity magnitude obeys $\\omega \\sim U_0 / \\ell_u$. These relations identify inverse-scale proxies: large $J$ and large $\\omega$ indicate small physical structures (current sheets and shear layers) that demand finer resolution.\n\nTo quantify these triggers with dimensionless numbers, choose reference scales $J_0$ and $\\omega_0$ such that a “macroscopic” variation over $L_0$ corresponds to $J_0 \\equiv B_0 / (\\mu_0 L_0)$ and $\\omega_0 \\equiv U_0 / L_0$. Then $J/J_0 \\sim L_0 / \\ell_B$ and $\\omega/\\omega_0 \\sim L_0 / \\ell_u$. The smallest active physical length scale in a cell is $\\ell_{\\min} = \\min(\\ell_B,\\ell_u)$, and the requirement to resolve this scale using a mesh of spacing $h$ can be expressed as $\\ell_{\\min} \\le \\kappa h$ for some resolution factor $\\kappa$ (e.g., $\\kappa = 2$ means at least two cells per smallest scale). In terms of the dimensionless proxies, $\\ell_B \\le \\kappa h$ implies $J/J_0 \\ge L_0/(\\kappa h)$, and $\\ell_u \\le \\kappa h$ implies $\\omega/\\omega_0 \\ge L_0/(\\kappa h)$. A conservative single scalar trigger metric should respond to the smallest scale, so the maximum of the two normalized indicators is the appropriate choice:\n$$\nM \\equiv \\max\\!\\left(\\frac{J}{J_0},\\,\\frac{\\omega}{\\omega_0}\\right).\n$$\nThis choice follows directly from the need to detect the minimum of $\\ell_B$ and $\\ell_u$: since $J/J_0 \\sim L_0/\\ell_B$ and $\\omega/\\omega_0 \\sim L_0/\\ell_u$, taking the maximum of these ratios corresponds to the minimum of the associated length scales.\n\nTherefore, the physics-derived refinement threshold becomes\n$$\nT_{\\mathrm{refine}} = \\frac{L_0}{\\kappa h},\n$$\nand a cell should be refined when $M \\ge T_{\\mathrm{refine}}$. To avoid refinement thrashing, we introduce hysteresis via a coarsening threshold $T_{\\mathrm{coarsen}} = \\gamma\\, T_{\\mathrm{refine}}$ with $0  \\gamma  1$, and we impose dwell-time requirements: $N_{\\uparrow}$ consecutive time steps above $T_{\\mathrm{refine}}$ are required to refine, and $N_{\\downarrow}$ consecutive time steps below $T_{\\mathrm{coarsen}}$ are required to coarsen. Values of $M$ between thresholds, i.e., $T_{\\mathrm{coarsen}}  M  T_{\\mathrm{refine}}$, do not change the state and reset the counters. This policy creates a buffer band and persistence criteria that eliminate rapid toggling due to small oscillations in $M$.\n\nAlgorithm design:\n1. Compute $J_0 = B_0/(\\mu_0 L_0)$ and $\\omega_0 = U_0/L_0$ (note that $B_0$ is in $\\mathrm{T}$, $U_0$ in $\\mathrm{m/s}$, $L_0$ in $\\mathrm{m}$, so $J_0$ is in $\\mathrm{A/m^2}$ and $\\omega_0$ in $\\mathrm{s^{-1}}$).\n2. For each cell $i$ and time $t$, compute the dimensionless metric\n   $$\n   M(t,i) = \\max\\!\\left(\\frac{J(t,i)}{J_0},\\,\\frac{\\omega(t,i)}{\\omega_0}\\right).\n   $$\n3. Compute thresholds $T_{\\mathrm{refine}} = L_0/(\\kappa h)$ and $T_{\\mathrm{coarsen}} = \\gamma T_{\\mathrm{refine}}$.\n4. Initialize all cells as coarse. Maintain two counters per cell: $c_{\\uparrow}(i)$ and $c_{\\downarrow}(i)$.\n5. For each time step:\n   - If $M(t,i) \\ge T_{\\mathrm{refine}}$, set $c_{\\uparrow}(i) \\leftarrow c_{\\uparrow}(i) + 1$, $c_{\\downarrow}(i) \\leftarrow 0$. If the cell is coarse and $c_{\\uparrow}(i) \\ge N_{\\uparrow}$, switch it to refined and increment the global toggle counter.\n   - Else if $M(t,i) \\le T_{\\mathrm{coarsen}}$, set $c_{\\downarrow}(i) \\leftarrow c_{\\downarrow}(i) + 1$, $c_{\\uparrow}(i) \\leftarrow 0$. If the cell is refined and $c_{\\downarrow}(i) \\ge N_{\\downarrow}$, switch it to coarse and increment the global toggle counter.\n   - Else (within the hysteresis band), reset both counters to zero and keep the current state.\n6. After the last time step, count the number of refined cells and report the total number of toggles.\n\nWhy this avoids thrashing:\n- The two-threshold band $[T_{\\mathrm{coarsen}}, T_{\\mathrm{refine}}]$ ensures that small fluctuations that cross a single threshold do not immediately reverse the decision; in physical terms, it respects the uncertainty band where neither strong current sheets nor strong shear layers are definitively present relative to the mesh spacing.\n- The dwell times $N_{\\uparrow}$ and $N_{\\downarrow}$ enforce persistence, requiring sustained evidence of under-resolution or over-resolution before making changes, which is consistent with the practical evolution of plasma structures in magnetohydrodynamics.\n\nApplication to the test suite:\n- Test Case 1 uses $B_0 = 5$, $U_0 = 2 \\times 10^{4}$, $L_0 = 0.1$, $h = 0.01$, $\\kappa = 2$, $\\gamma = 0.7$, $N_{\\uparrow} = 2$, $N_{\\downarrow} = 3$, implying $J_0 = B_0 / (\\mu_0 L_0)$ and $\\omega_0 = U_0 / L_0$, with $T_{\\mathrm{refine}} = L_0/(\\kappa h) = 0.1/(2 \\cdot 0.01) = 5$ and $T_{\\mathrm{coarsen}} = \\gamma T_{\\mathrm{refine}} = 3.5$. The provided signals cause early refinement of the first four cells with no coarsening, yielding a nonzero refined count and a small number of toggles.\n- Test Case 2 uses $h = 0.02$, $\\gamma = 0.8$, so $T_{\\mathrm{refine}} = 2.5$ and $T_{\\mathrm{coarsen}} = 2.0$. Designed oscillations near thresholds with equality test cases exercise the hysteresis: refinement requires persistence above $2.5$, and coarsening requires persistence at or below $2.0$; the specified sequences cause refinement followed by coarsening for the first two cells, while others do not toggle.\n- Test Case 3 replicates spiky signals, $T = 10$, $N = 10$, $h = 0.01$, $\\gamma = 0.7$. Alternating high-low values with $N_{\\uparrow} = 2$ and $N_{\\downarrow} = 3$ prevent coarsening during brief low intervals and thus avoid thrashing; cells with sustained high signals refine once and remain refined.\n\nThe program computes $J_0$, $\\omega_0$, thresholds, applies the hysteresis logic across time steps, and produces the final counts and toggle totals for each test case. The final output format is a single line containing a list of lists: $[[R_{\\mathrm{final}},T_{\\mathrm{toggles}}],\\ldots]$, as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nMU0 = 4.0 * np.pi * 1e-7  # Permeability of free space (H/m)\n\ndef apply_hysteresis(J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down):\n    \"\"\"\n    Apply refinement hysteresis policy to time series of J and vorticity W.\n    J, W: arrays of shape (T, N) with physical units (A/m^2) and (1/s).\n    Returns (final_refined_count, total_toggles).\n    \"\"\"\n    T, N = J.shape\n\n    # Characteristic scales\n    J0 = B0 / (MU0 * L0)\n    W0 = U0 / L0\n\n    # Dimensionless metric M = max(J/J0, W/W0)\n    M = np.maximum(J / J0, W / W0)\n\n    # Thresholds\n    T_refine = L0 / (kappa * h)\n    T_coarsen = gamma * T_refine\n\n    # State and counters\n    refined = np.zeros(N, dtype=bool)\n    up_count = np.zeros(N, dtype=int)\n    down_count = np.zeros(N, dtype=int)\n    toggles = 0\n\n    for t in range(T):\n        mt = M[t]\n        # Update counters and states per cell\n        for i in range(N):\n            if mt[i] = T_refine:\n                up_count[i] += 1\n                down_count[i] = 0\n                if (not refined[i]) and (up_count[i] = N_up):\n                    refined[i] = True\n                    toggles += 1\n            elif mt[i] = T_coarsen:\n                down_count[i] += 1\n                up_count[i] = 0\n                if refined[i] and (down_count[i] = N_down):\n                    refined[i] = False\n                    toggles += 1\n            else:\n                # Within hysteresis band: reset counters\n                up_count[i] = 0\n                down_count[i] = 0\n\n    final_refined_count = int(np.sum(refined))\n    return final_refined_count, toggles\n\ndef build_case_1():\n    # Parameters\n    B0 = 5.0       # Tesla\n    U0 = 2.0e4     # m/s\n    L0 = 0.1       # m\n    h = 0.01       # m\n    kappa = 2.0\n    gamma = 0.7\n    N_up = 2\n    N_down = 3\n\n    T = 8\n    N = 8\n\n    # Dimensionless multipliers a (for J) and b (for W)\n    a = np.zeros((T, N))\n    b = np.zeros((T, N))\n\n    # Cells 0..3: a_t = [6,6,6,4,4,4,4,4], b_t = [2,2,2,2,2,2,2,2]\n    pattern_a_early = [6, 6, 6, 4, 4, 4, 4, 4]\n    pattern_b_early = [2, 2, 2, 2, 2, 2, 2, 2]\n    for i in range(4):\n        a[:, i] = pattern_a_early\n        b[:, i] = pattern_b_early\n\n    # Cells 4..7: a_t = [3]*8, b_t = [3]*8\n    pattern_a_late = [3]*T\n    pattern_b_late = [3]*T\n    for i in range(4, 8):\n        a[:, i] = pattern_a_late\n        b[:, i] = pattern_b_late\n\n    # Convert to physical units\n    J0 = B0 / (MU0 * L0)\n    W0 = U0 / L0\n    J = a * J0\n    W = b * W0\n\n    return (J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down)\n\ndef build_case_2():\n    # Parameters\n    B0 = 5.0       # Tesla\n    U0 = 2.0e4     # m/s\n    L0 = 0.1       # m\n    h = 0.02       # m\n    kappa = 2.0\n    gamma = 0.8\n    N_up = 2\n    N_down = 3\n\n    T = 8\n    N = 8\n\n    a = np.zeros((T, N))\n    b = np.zeros((T, N))\n\n    # Cells 0..1: a_t = [2.5,2.5,2.4,2.4,2.4,2.0,2.0,2.0], b_t = zeros\n    pattern_a_01 = [2.5, 2.5, 2.4, 2.4, 2.4, 2.0, 2.0, 2.0]\n    for i in range(2):\n        a[:, i] = pattern_a_01\n        b[:, i] = [0]*T\n\n    # Cells 2..3: a_t alternating 2.5 and 2.4, b_t zeros\n    pattern_a_23 = [2.5, 2.4, 2.5, 2.4, 2.5, 2.4, 2.5, 2.4]\n    for i in range(2, 4):\n        a[:, i] = pattern_a_23\n        b[:, i] = [0]*T\n\n    # Cells 4..7: a_t = [1.8]*8, b_t = zeros\n    pattern_a_47 = [1.8]*T\n    for i in range(4, 8):\n        a[:, i] = pattern_a_47\n        b[:, i] = [0]*T\n\n    # Convert to physical units\n    J0 = B0 / (MU0 * L0)\n    W0 = U0 / L0\n    J = a * J0\n    W = b * W0\n\n    return (J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down)\n\ndef build_case_3():\n    # Parameters\n    B0 = 5.0       # Tesla\n    U0 = 2.0e4     # m/s\n    L0 = 0.1       # m\n    h = 0.01       # m\n    kappa = 2.0\n    gamma = 0.7\n    N_up = 2\n    N_down = 3\n\n    T = 10\n    N = 10\n\n    a = np.zeros((T, N))\n    b = np.zeros((T, N))\n\n    # Cells 0..4: a_t = [6,3,6,3,6,3,6,3,6,3], b_t zeros\n    pattern_a_04 = [6, 3, 6, 3, 6, 3, 6, 3, 6, 3]\n    for i in range(5):\n        a[:, i] = pattern_a_04\n        b[:, i] = [0]*T\n\n    # Cells 5..7: a_t = [6,6,3,3,6,6,3,3,6,6], b_t zeros\n    pattern_a_57 = [6, 6, 3, 3, 6, 6, 3, 3, 6, 6]\n    for i in range(5, 8):\n        a[:, i] = pattern_a_57\n        b[:, i] = [0]*T\n\n    # Cells 8..9: a_t = [6]*10, b_t zeros\n    pattern_a_89 = [6]*T\n    for i in range(8, 10):\n        a[:, i] = pattern_a_89\n        b[:, i] = [0]*T\n\n    # Convert to physical units\n    J0 = B0 / (MU0 * L0)\n    W0 = U0 / L0\n    J = a * J0\n    W = b * W0\n\n    return (J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        build_case_1(),\n        build_case_2(),\n        build_case_3(),\n    ]\n\n    results = []\n    for case in test_cases:\n        J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down = case\n        final_refined_count, toggles = apply_hysteresis(\n            J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down\n        )\n        results.append([final_refined_count, toggles])\n\n    # Final print statement in the exact required format.\n    # Single line output: list of [R_final, T_toggles] per test case.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```"
        }
    ]
}