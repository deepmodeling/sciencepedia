{
    "hands_on_practices": [
        {
            "introduction": "Courant-Friedrichs-Lewy (CFL) 条件是显式数值格式最基本的速度限制。在采用时间子循环（即不同层级使用不同时间步长）的自适应网格加密（AMR）中，确保所有层级同时满足稳定性是一个关键的设计挑战。本练习  将引导你从第一性原理出发，推导出一个精心设计的时间步进方案如何保证全局稳定性，这是实现稳定AMR模拟的基石。",
            "id": "3946763",
            "problem": "考虑在$d$维空间中，在间距为$h_0$的均匀笛卡尔基础网格上，对守恒形式的理想磁流体动力学（MHD）方程进行显式有限体积离散化。该网格采用块结构自适应网格加密（AMR），加密比为$r$，因此第$\\ell$层级网格的间距为$h_{\\ell} = h_0 / r^{\\ell}$。假设采用迎风格式数值通量，该通量由一个稳定的黎曼求解器构造，其谱半径受最大特征波速$a$的限制。$a$定义为通量雅可比矩阵特征值绝对值在所有方向和所有MHD特征族（包括快磁声波）上的最大值。时间积分采用强稳定保持龙格-库塔（SSP RK）方法进行显式计算，使用与层级相关的时间步长$\\Delta t_{\\ell} = \\Delta t_0 / r^{\\ell}$（时间上进行子循环）。设所选的库朗数$C$满足$0  C \\leq 1$，并假设在每一层级上，每个方向采用每个单元面一个通量的标准守恒通量差分法。\n\n从逼近双曲守恒律的显式格式的基本稳定性要求出发——即信息在任何方向上每个时间步长传播的距离不能超过一个单元格——推导保证所述$d$维显式MHD格式稳定的Courant–Friedrichs–Lewy (CFL) 条件。用$h_{\\ell}$、$a$、$d$和$C$表示该条件。然后，使用规定的AMR时间步长方案$\\Delta t_{\\ell} = \\Delta t_0 / r^{\\ell}$，证明存在一个最大基础层时间步长$\\Delta t_{0,\\max}$，该步长能确保CFL条件在所有加密层上同时满足。以$h_0$、$a$、$d$和$C$的形式，给出$\\Delta t_{0,\\max}$的封闭形式最终表达式。\n\n你的最终答案必须是单一的解析表达式。不需要进行数值计算。",
            "solution": "该问题要求为在$d$维自适应网格上求解理想磁流体动力学（MHD）的显式有限体积格式推导Courant–Friedrichs–Lewy (CFL) 稳定性条件，并由此确定基础网格层上允许的最大时间步长。\n\n出发点是双曲偏微分方程显式数值方法的稳定性基本原理。CFL条件规定，计算单元的数值依赖域必须包含物理依赖域。对于简单的一维格式，这通常表示为库朗数$C = a \\frac{\\Delta t}{\\Delta x}$小于某个常数（通常为1）。本问题将$C$定义为此比率的上限，因此稳定性条件为$a \\frac{\\Delta t}{h} \\leq C$。\n\n我们必须将其推广到在加密层级$\\ell$上具有均匀间距$h_{\\ell}$的$d$维笛卡尔网格。问题陈述了使用显式有限体积方法，且“每个方向一个单元面通量”。这对应于一种线方法（method-of-lines）公式，其中空间算子是每个空间维度一个的一维通量差分算子之和：\n$$\n\\frac{dU_{i_1, \\dots, i_d}}{dt} = -\\sum_{k=1}^{d} \\frac{1}{h_{\\ell}} \\left( \\hat{F}_{k, i_k+1/2} - \\hat{F}_{k, i_k-1/2} \\right)\n$$\n其中$U$是单元中守恒量的向量，$\\hat{F}$是数值通量。对于显式时间积分格式（如所提及的SSP RK方法），时间步长$\\Delta t_{\\ell}$受到离散化空间算子谱半径的限制。对于一维算子的求和，总谱半径受单个算子谱半径之和的限制。\n\n最大特征波速给定为$a$。该速度是各向同性的，意味着它是任何方向上的最大传播速度。在$k$方向上的一维通量差分算子的谱半径与$a / h_{\\ell}$成正比。将所有$d$个维度的贡献相加，得到稳定性条件：\n$$\n\\Delta t_{\\ell} \\sum_{k=1}^{d} \\frac{a}{h_{\\ell}} \\leq C\n$$\n由于该和由$d$个相同项组成，因此对于给定的层级$\\ell$，CFL条件简化为：\n$$\n\\Delta t_{\\ell} \\frac{d \\cdot a}{h_{\\ell}} \\leq C\n$$\n该表达式以$h_{\\ell}$、$a$、$d$和$C$的形式提供了所需的稳定性条件。\n\n接下来，我们必须在规定的自适应网格加密（AMR）结构的背景下分析此条件。问题陈述，层级$\\ell$上的网格间距和时间步长通过加密比$r$与基础层（$\\ell=0$）的值相关联：\n$$\nh_{\\ell} = \\frac{h_0}{r^{\\ell}}\n$$\n$$\n\\Delta t_{\\ell} = \\frac{\\Delta t_0}{r^{\\ell}}\n$$\n这种时间步进方案称为子循环（subcycling），其中更精细的层级使用更小的时间步长进行演化。为确保整个AMR层级结构的稳定性，CFL条件必须在每一层$\\ell = 0, 1, 2, \\ldots$上都得到满足。\n\n我们将AMR特定的$h_{\\ell}$和$\\Delta t_{\\ell}$表达式代入层级$\\ell$的CFL条件中：\n$$\n\\left( \\frac{\\Delta t_0}{r^{\\ell}} \\right) \\frac{d \\cdot a}{\\left( \\frac{h_0}{r^{\\ell}} \\right)} \\leq C\n$$\n$\\Delta t_{\\ell}$和$h_{\\ell}$分母中的因子$r^{\\ell}$相互抵消：\n$$\n\\frac{\\Delta t_0 \\cdot r^{\\ell}}{r^{\\ell}} \\frac{d \\cdot a}{h_0} \\leq C\n$$\n$$\n\\frac{\\Delta t_0 \\cdot d \\cdot a}{h_0} \\leq C\n$$\n由此得到的不等式是关于基础层时间步长$\\Delta t_0$的条件，它完全独立于加密层级$\\ell$。这表明，如果我们选择一个满足此条件的$\\Delta t_0$，CFL准则将在所有加密层上同时成立。所有有效的$\\Delta t_0$值的集合非空且有上界。因此，存在一个最大基础层时间步长$\\Delta t_{0,\\max}$。\n\n为求得该最大时间步长的表达式，我们对$\\Delta t_0$求解该不等式：\n$$\n\\Delta t_0 \\leq \\frac{C \\cdot h_0}{d \\cdot a}\n$$\n当等式成立时，达到基础层时间步长的最大允许值$\\Delta t_{0,\\max}$：\n$$\n\\Delta t_{0,\\max} = \\frac{C h_0}{d a}\n$$\n这就是保证在指定的子循环方案下整个AMR网格结构稳定性的最大基础层时间步长的最终表达式。",
            "answer": "$$\\boxed{\\frac{C h_0}{d a}}$$"
        },
        {
            "introduction": "自适应网格加密（AMR）的一大挑战是，在粗细网格边界上的操作（如插值）可能会违背基本的物理定律。在磁流体力学（MHD）中，保持磁场无散度约束（$\\nabla \\cdot \\mathbf{B} = 0$）对于物理准确性和数值稳定性至关重要。本练习  将具体展示插值过程如何引入伪磁散度，并引导你完成一种标准的修正技术——投影法，以清除这种非物理的误差。",
            "id": "3946755",
            "problem": "在磁流体力学 (MHD) 中，麦克斯韦方程组要求磁场是无散的，即 $\\nabla \\cdot \\mathbf{B} = 0$。在自适应网格加密 (AMR) 中，如果插值未能保持离散无散约束，那么从粗网格到细网格的插值会在加密片上引入虚假的散度。考虑一个二维加密片，它对应一个占据单位正方形 $\\Omega = [0,1] \\times [0,1]$ 的单一粗网格单元，空间坐标为 $(x,y)$，加密比为 $r=2$（因此该加密片由四个细网格单元组成）。粗网格层级的磁场由一个标量势 $\\psi(x,y)$ 通过二维旋度得到，$\\mathbf{B} = \\nabla \\times (\\psi \\,\\hat{\\mathbf{z}})$，其中 $\\hat{\\mathbf{z}}$ 是平面外方向的单位向量，因此 $B_x = \\partial \\psi / \\partial y$ 且 $B_y = -\\partial \\psi / \\partial x$。设粗网格层级的标量势为 $\\psi(x,y) = x^{2}y - \\frac{1}{3}y^{3}$，这在粗网格层级上产生一个无散磁场。\n\n在加密片上，插值的定义如下：对于 $\\mathbf{B}$ 的每个分量，根据粗网格单元在 $(0,0)$、$(1,0)$、$(0,1)$ 和 $(1,1)$ 的顶点值，在 $\\Omega$ 上构建双线性插值；将此插值场表示为 $\\widehat{\\mathbf{B}}(x,y) = (\\widehat{B}_x(x,y),\\widehat{B}_y(x,y))$。然后，加密片上的离散散度由双线性插值的连续散度来近似，即 $\\nabla \\cdot \\widehat{\\mathbf{B}}(x,y)$。\n\n从上述的 MHD 无散约束和 AMR 插值定义出发，推导由加密片上的双线性插值引起的散度误差 $\\nabla \\cdot \\widehat{\\mathbf{B}}(x,y)$。然后，在加密片上设计一个基于投影的校正：求解带有齐次诺伊曼边界条件的泊松方程，\n$$\n\\nabla^{2}\\phi(x,y) = \\nabla \\cdot \\widehat{\\mathbf{B}}(x,y), \\quad \\text{其中 } \\frac{\\partial \\phi}{\\partial n}\\bigg|_{\\partial \\Omega} = 0,\n$$\n找到一个标量势 $\\phi(x,y)$，使得校正后的场 $\\mathbf{B}_{\\text{corr}} = \\widehat{\\mathbf{B}} - \\nabla \\phi$ 是无散的，并且在加密片边界上保持粗网格层级的法向分量。请提供 $\\phi(x,y)$ 的一个闭式解析表达式。如果选择积分常数，请通过要求 $\\phi(0,0) = 0$ 来固定它。最终答案必须是 $\\phi(x,y)$ 的单个闭式解析表达式；不要包含任何单位。",
            "solution": "首先对问题进行验证，以确保其具有科学依据、是适定的且自洽的。\n\n**步骤 1：提取已知条件**\n-   定义域为单位正方形 $\\Omega = [0,1] \\times [0,1]$，坐标为 $(x,y)$。\n-   粗网格层级的磁场 $\\mathbf{B}$ 由标量势 $\\psi(x,y) = x^{2}y - \\frac{1}{3}y^{3}$ 通过 $\\mathbf{B} = \\nabla \\times (\\psi \\,\\hat{\\mathbf{z}})$ 推导得出。\n-   粗网格层级场分量的显式形式为 $B_x = \\frac{\\partial \\psi}{\\partial y}$ 和 $B_y = -\\frac{\\partial \\psi}{\\partial x}$。\n-   加密片上的插值场 $\\widehat{\\mathbf{B}}(x,y)$ 是通过对 $\\Omega$ 四个角点 $(0,0)$、$(1,0)$、$(0,1)$ 和 $(1,1)$ 处的粗网格场值进行双线性插值得到的。\n-   必须通过求解泊松方程 $\\nabla^{2}\\phi(x,y) = \\nabla \\cdot \\widehat{\\mathbf{B}}(x,y)$ 来找到校正势 $\\phi(x,y)$。\n-   $\\phi$ 的边界条件为齐次诺伊曼条件：$\\frac{\\partial \\phi}{\\partial n}\\big|_{\\partial \\Omega} = 0$。\n-   提供了固定积分常数的条件：$\\phi(0,0) = 0$。\n-   校正后的场定义为 $\\mathbf{B}_{\\text{corr}} = \\widehat{\\mathbf{B}} - \\nabla \\phi$。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学依据**：该问题探讨了磁流体力学 (MHD) 中的一个标准数值问题，该问题与在自适应网格加密 (AMR) 中保持无散约束 $\\nabla \\cdot \\mathbf{B} = 0$ 有关。使用矢量势（这里是二维标量势 $\\psi$）来定义无散场、插值引起的散度概念，以及使用投影方法（求解泊松方程）来校正此散度，这些都是计算物理学中标准且成熟的技术。\n-   **适定性**：该问题定义了一个完整的数学任务。初始场是明确给定的。插值方案是指定的（双线性）。校正势的方程是一个适定的泊松方程。边界条件（齐次诺伊曼）和固定条件（$\\phi(0,0)=0$）足以保证唯一解。粗网格层级的场被验证为无散的：$B_x = x^2 - y^2$，$B_y = -2xy$，因此 $\\nabla \\cdot \\mathbf{B} = \\frac{\\partial}{\\partial x}(x^2 - y^2) + \\frac{\\partial}{\\partial y}(-2xy) = 2x - 2x = 0$。设置是自洽的。\n-   **客观性**：问题以精确、客观的数学语言陈述。\n\n**结论与行动**\n该问题是有效的，因为它具有科学依据、适定且内部一致。我们现在将继续进行求解。\n\n**步骤 3：求解推导**\n\n首先，我们使用给定的标量势 $\\psi(x,y) = x^{2}y - \\frac{1}{3}y^{3}$ 来确定粗网格层级的磁场 $\\mathbf{B}(x,y)$。\n磁场的分量是：\n$$\nB_x(x,y) = \\frac{\\partial \\psi}{\\partial y} = \\frac{\\partial}{\\partial y}\\left(x^{2}y - \\frac{1}{3}y^{3}\\right) = x^{2} - y^{2}\n$$\n$$\nB_y(x,y) = -\\frac{\\partial \\psi}{\\partial x} = -\\frac{\\partial}{\\partial x}\\left(x^{2}y - \\frac{1}{3}y^{3}\\right) = -2xy\n$$\n所以，粗网格层级的场为 $\\mathbf{B}(x,y) = (x^{2} - y^{2}, -2xy)$。\n\n接下来，我们计算该场在单位正方形 $\\Omega$ 四个角点的值：\n-   在 $(0,0)$ 处：$\\mathbf{B}(0,0) = (0^{2} - 0^{2}, -2(0)(0)) = (0,0)$。\n-   在 $(1,0)$ 处：$\\mathbf{B}(1,0) = (1^{2} - 0^{2}, -2(1)(0)) = (1,0)$。\n-   在 $(0,1)$ 处：$\\mathbf{B}(0,1) = (0^{2} - 1^{2}, -2(0)(1)) = (-1,0)$。\n-   在 $(1,1)$ 处：$\\mathbf{B}(1,1) = (1^{2} - 1^{2}, -2(1)(1)) = (0,-2)$。\n\n现在，我们在 $\\Omega$ 上构建双线性插值 $\\widehat{\\mathbf{B}}(x,y) = (\\widehat{B}_x(x,y), \\widehat{B}_y(x,y))$。单位正方形上函数 $f$ 的通用形式由下式给出：\n$$\n\\widehat{f}(x,y) = f(0,0)(1-x)(1-y) + f(1,0)x(1-y) + f(0,1)(1-x)y + f(1,1)xy\n$$\n将此应用于 $\\mathbf{B}$ 的每个分量：\n对于 $\\widehat{B}_x(x,y)$：\n$$\n\\widehat{B}_x(x,y) = (0)(1-x)(1-y) + (1)x(1-y) + (-1)(1-x)y + (0)xy\n$$\n$$\n\\widehat{B}_x(x,y) = x(1-y) - (1-x)y = x - xy - y + xy = x - y\n$$\n对于 $\\widehat{B}_y(x,y)$：\n$$\n\\widehat{B}_y(x,y) = (0)(1-x)(1-y) + (0)x(1-y) + (0)(1-x)y + (-2)xy\n$$\n$$\n\\widehat{B}_y(x,y) = -2xy\n$$\n插值磁场为 $\\widehat{\\mathbf{B}}(x,y) = (x-y, -2xy)$。\n\n下一步是计算散度误差 $\\nabla \\cdot \\widehat{\\mathbf{B}}(x,y)$。\n$$\n\\nabla \\cdot \\widehat{\\mathbf{B}} = \\frac{\\partial \\widehat{B}_x}{\\partial x} + \\frac{\\partial \\widehat{B}_y}{\\partial y} = \\frac{\\partial}{\\partial x}(x-y) + \\frac{\\partial}{\\partial y}(-2xy) = 1 - 2x\n$$\n这个非零结果是由插值引入的虚假散度。\n\n我们现在需要通过在 $\\Omega$ 上求解带有齐次诺伊曼边界条件的泊松方程 $\\nabla^{2}\\phi = 1 - 2x$ 来找到标量势 $\\phi(x,y)$。该方程为：\n$$\n\\frac{\\partial^{2}\\phi}{\\partial x^{2}} + \\frac{\\partial^{2}\\phi}{\\partial y^{2}} = 1 - 2x\n$$\n边界条件为：\n-   对于 $y \\in [0,1]$，$\\frac{\\partial \\phi}{\\partial x}(0,y) = 0$\n-   对于 $y \\in [0,1]$，$\\frac{\\partial \\phi}{\\partial x}(1,y) = 0$\n-   对于 $x \\in [0,1]$，$\\frac{\\partial \\phi}{\\partial y}(x,0) = 0$\n-   对于 $x \\in [0,1]$，$\\frac{\\partial \\phi}{\\partial y}(x,1) = 0$\n\n由于源项 $1-2x$ 与 $y$ 无关，并且水平边界（$y=0$ 和 $y=1$）上关于 $y$ 的导数的边界条件是齐次的，我们可以寻找一个只依赖于 $x$ 的解，即 $\\phi(x,y) = \\phi(x)$。在此假设下，$\\frac{\\partial^{2}\\phi}{\\partial y^{2}} = 0$，并且关于 $y$ 的边界条件自动满足。\n问题简化为一维常微分方程：\n$$\n\\frac{d^{2}\\phi}{dx^{2}} = 1 - 2x\n$$\n边界条件为 $\\frac{d\\phi}{dx}(0) = 0$ 和 $\\frac{d\\phi}{dx}(1) = 0$。\n\n对 $x$ 积分一次：\n$$\n\\frac{d\\phi}{dx} = \\int (1-2x) \\,dx = x - x^{2} + C_1\n$$\n应用第一个边界条件 $\\frac{d\\phi}{dx}(0)=0$：\n$$\n0 - 0^{2} + C_1 = 0 \\implies C_1=0\n$$\n这得到 $\\frac{d\\phi}{dx} = x - x^{2}$。让我们用第二个边界条件 $\\frac{d\\phi}{dx}(1)=0$ 来验证：\n$$\n1 - 1^{2} = 0\n$$\n条件得到满足，所以我们导数的形式是正确的。\n\n再次对 $\\frac{d\\phi}{dx}$ 关于 $x$ 积分：\n$$\n\\phi(x) = \\int (x - x^{2}) \\,dx = \\frac{1}{2}x^{2} - \\frac{1}{3}x^{3} + C_2\n$$\n解的形式为 $\\phi(x,y) = \\frac{1}{2}x^{2} - \\frac{1}{3}x^{3} + C_2$。为了确定常数 $C_2$，我们使用最终条件 $\\phi(0,0) = 0$：\n$$\n\\phi(0,0) = \\frac{1}{2}(0)^{2} - \\frac{1}{3}(0)^{3} + C_2 = 0 \\implies C_2 = 0\n$$\n因此，满足所有给定条件的唯一标量势是：\n$$\n\\phi(x,y) = \\frac{1}{2}x^{2} - \\frac{1}{3}x^{3}\n$$\n这个表达式构成了所要求的闭式解析表达式。校正后的场 $\\mathbf{B}_{\\text{corr}} = \\widehat{\\mathbf{B}} - \\nabla \\phi$ 通过构造保证是无散的，因为 $\\nabla \\cdot \\mathbf{B}_{\\text{corr}} = \\nabla \\cdot \\widehat{\\mathbf{B}} - \\nabla^2\\phi = (1-2x) - (1-2x) = 0$。齐次诺伊曼边界条件确保了校正项 $\\nabla \\phi$ 的法向分量在边界上为零，从而保持了插值场 $\\widehat{\\mathbf{B}}$ 的法向分量。",
            "answer": "$$\n\\boxed{\\frac{1}{2}x^{2} - \\frac{1}{3}x^{3}}\n$$"
        },
        {
            "introduction": "自适应网格加密（AMR）的“智能”体现在其网格加密和粗化的标准上。一个优秀的策略必须具备物理动机（在小尺度结构出现处加密）和数值鲁棒性（避免快速、浪费的网格状态切换）。本练习  是一项算法挑战，要求你设计并实现一个完整的加密策略，包括推导基于物理的触发器和用于确保稳定高效的滞后效应策略。",
            "id": "3946761",
            "problem": "你的任务是为一维磁流体力学（MHD）等离子体模拟设计一种自适应网格加密的加密阈值和滞后策略，该模拟使用电流密度大小和涡量。目标是，在每个离散时间步为每个网格单元决定是将其标记为加密还是粗化，同时防止随着场的演化而导致加密决策的快速振荡。你必须从第一性原理出发推导阈值，并以算法形式实现滞后策略。\n\n基本原理和定义：\n- 麦克斯韦-安培定律（准静态极限，无位移电流）：$\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$，其中 $\\mathbf{B}$ 是磁场，$\\mathbf{J}$ 是电流密度，$\\mu_0$ 是真空磁导率。\n- 涡量定义：$\\boldsymbol{\\omega} = \\nabla \\times \\mathbf{u}$，其中 $\\mathbf{u}$ 是流体速度。\n- 特征尺度：参考磁场大小 $B_0$（单位：特斯拉, $\\,\\mathrm{T}$），参考流速 $U_0$（单位：米/秒, $\\,\\mathrm{m/s}$），以及参考宏观长度 $L_0$（单位：米, $\\,\\mathrm{m}$）。\n- 网格间距：$h$（单位：米, $\\,\\mathrm{m}$）。\n- 电流密度大小 $J = \\|\\mathbf{J}\\|$（单位：安培/平方米, $\\,\\mathrm{A/m^2}$）和涡量大小 $\\omega = \\|\\boldsymbol{\\omega}\\|$（单位：秒的倒数, $\\,\\mathrm{s^{-1}}$）。\n\n推导要求：\n- 从上述基本定律和定义出发，推导出一个加密阈值，该阈值能响应与电流片和剪切层相关的最小隐含物理长度尺度。利用以下事实：在长度尺度 $\\ell_B$ 上的磁场变化意味着 $J \\sim B_0/(\\mu_0 \\ell_B)$，而在 $\\ell_u$ 上的速度变化意味着 $\\omega \\sim U_0/\\ell_u$。根据 $B_0$、$U_0$ 和 $L_0$ 定义合适的特征归一化量 $J_0$ 和 $\\omega_0$，然后基于 $J/J_0$ 和 $\\omega/\\omega_0$ 构建一个无量纲触发度量。你必须从逻辑上证明你用于将两个触发器合并为单个加密决策的组合规则的合理性。不要假设或引用现成的加密公式；要从网格应解析相对于 $h$ 的最小活动尺度的要求中推导出它。\n- 设计一个具有两个不同阈值（一个用于加密，一个用于粗化）的滞后策略，以防止度量在阈值附近波动时发生快速的来回切换。解释为什么该策略能避免抖动并尊重从物理原理推导出的阈值。\n\n算法要求：\n- 每个单元在每个时间步的加密状态是二元的：加密或粗化。\n- 每个单元在每个时间点使用一个从 $J(t,i)$ 和 $\\omega(t,i)$ 及特征尺度推导出的标量无量纲触发度量 $M(t,i)$。\n- 定义一个加密阈值 $T_{\\mathrm{refine}}$ 和一个粗化阈值 $T_{\\mathrm{coarsen}}$，其中 $T_{\\mathrm{coarsen}}  T_{\\mathrm{refine}}$ 以实现滞后，并定义驻留时间整数 $N_{\\uparrow}$ 和 $N_{\\downarrow}$，分别表示加密和粗化的持续性要求。\n- 初始化：在第一个时间步，所有单元都以粗化状态开始。\n- 每个时间步的状态更新：\n  - 如果 $M(t,i) \\ge T_{\\mathrm{refine}}$ 至少持续 $N_{\\uparrow}$ 个连续时间步，则将该单元切换为加密状态。\n  - 如果 $M(t,i) \\le T_{\\mathrm{coarsen}}$ 至少持续 $N_{\\downarrow}$ 个连续时间步，则将该单元切换为粗化状态。\n  - 否则，保持当前状态。\n- 对每个测试用例，计算所有单元和所有时间步中状态切换的总次数。\n- 物理量的单位是强制性的：\n  - $J$ 的单位必须是 $\\,\\mathrm{A/m^2}$。\n  - $\\omega$ 的单位必须是 $\\,\\mathrm{s^{-1}}$。\n  - $B_0$ 的单位是 $\\,\\mathrm{T}$。\n  - $U_0$ 的单位是 $\\,\\mathrm{m/s}$。\n  - $L_0$ 和 $h$ 的单位是 $\\,\\mathrm{m}$。\n\n测试套件和参数：\n- 使用 $\\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{H/m}$。\n\n- 测试用例 1（理想路径）：\n  - $B_0 = 5\\,\\mathrm{T}$，$U_0 = 2 \\times 10^{4}\\,\\mathrm{m/s}$，$L_0 = 0.1\\,\\mathrm{m}$，$h = 0.01\\,\\mathrm{m}$，$\\kappa = 2$（分辨率因子），$\\gamma = 0.7$（滞后比），$N_{\\uparrow} = 2$，$N_{\\downarrow} = 3$。\n  - 时间步数：$T = 8$，单元数：$N = 8$。\n  - 如下定义电流密度和涡量的无量纲乘数，然后设置 $J(t,i) = J_0 \\times a_{t,i}$ 和 $\\omega(t,i) = \\omega_0 \\times b_{t,i}$，其中 $J_0 = B_0/(\\mu_0 L_0)$ 且 $\\omega_0 = U_0/L_0$：\n    - 对于单元 $i \\in \\{0,1,2,3\\}$，$a_{t,i} = [6,6,6,4,4,4,4,4]$，$b_{t,i} = [2,2,2,2,2,2,2,2]$。\n    - 对于单元 $i \\in \\{4,5,6,7\\}$，$a_{t,i} = [3,3,3,3,3,3,3,3]$，$b_{t,i} = [3,3,3,3,3,3,3,3]$。\n\n- 测试用例 2（阈值附近的边界条件）：\n  - $B_0 = 5\\,\\mathrm{T}$，$U_0 = 2 \\times 10^{4}\\,\\mathrm{m/s}$，$L_0 = 0.1\\,\\mathrm{m}$，$h = 0.02\\,\\mathrm{m}$，$\\kappa = 2$，$\\gamma = 0.8$，$N_{\\uparrow} = 2$，$N_{\\downarrow} = 3$。\n  - 时间步数：$T = 8$，单元数：$N = 8$。\n  - 无量纲乘数：\n    - 对于单元 $i \\in \\{0,1\\}$，$a_{t,i} = [2.5,2.5,2.4,2.4,2.4,2.0,2.0,2.0]$，$b_{t,i} = [0,0,0,0,0,0,0,0]$。\n    - 对于单元 $i \\in \\{2,3\\}$，$a_{t,i} = [2.5,2.4,2.5,2.4,2.5,2.4,2.5,2.4]$，$b_{t,i} = [0,0,0,0,0,0,0,0]$。\n    - 对于单元 $i \\in \\{4,5,6,7\\}$，$a_{t,i} = [1.8,1.8,1.8,1.8,1.8,1.8,1.8,1.8]$，$b_{t,i} = [0,0,0,0,0,0,0,0]$。\n\n- 测试用例 3（尖峰信号与滞后鲁棒性）：\n  - $B_0 = 5\\,\\mathrm{T}$，$U_0 = 2 \\times 10^{4}\\,\\mathrm{m/s}$，$L_0 = 0.1\\,\\mathrm{m}$，$h = 0.01\\,\\mathrm{m}$，$\\kappa = 2$，$\\gamma = 0.7$，$N_{\\uparrow} = 2$，$N_{\\downarrow} = 3$。\n  - 时间步数：$T = 10$，单元数：$N = 10$。\n  - 无量纲乘数：\n    - 对于单元 $i \\in \\{0,1,2,3,4\\}$，$a_{t,i} = [6,3,6,3,6,3,6,3,6,3]$，$b_{t,i} = [0,0,0,0,0,0,0,0,0,0]$。\n    - 对于单元 $i \\in \\{5,6,7\\}$，$a_{t,i} = [6,6,3,3,6,6,3,3,6,6]$，$b_{t,i} = [0,0,0,0,0,0,0,0,0,0]$。\n    - 对于单元 $i \\in \\{8,9\\}$，$a_{t,i} = [6,6,6,6,6,6,6,6,6,6]$，$b_{t,i} = [0,0,0,0,0,0,0,0,0,0]$。\n\n输出规格：\n- 对于每个测试用例，在处理完所有时间步后，计算：\n  1. 加密单元的最终数量（一个整数）。\n  2. 所有单元和所有时间点上加密状态切换的总次数（一个整数）。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个形式为 $[R_{\\mathrm{final}},T_{\\mathrm{toggles}}]$ 的双元素列表。例如：$[[r_1,t_1],[r_2,t_2],[r_3,t_3]]$。\n\n所有数值和输出必须以指定的单位进行计算，如果出现角度，则必须以弧度为单位；但是，本问题中不使用角度。最终输出必须是如上所述的列表的列表，并且必须精确地打印为一行。",
            "solution": "我们首先从基本定律出发，建立基于物理动机的特征尺度和加密决策准则。磁流体力学（MHD）将 Maxwell 方程组与流体动力学耦合起来。在没有位移电流的准静态极限下，麦克斯韦-安培定律为 $\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$。考虑一个磁场 $\\mathbf{B}$，其大小为 $B_0$，在特征长度尺度 $\\ell_B$ 上变化。从量纲上看，这意味着 $J \\sim B_0 / (\\mu_0 \\ell_B)$。类似地，对于在 $\\ell_u$ 上变化、大小为 $U_0$ 的流体速度 $\\mathbf{u}$，其涡量大小服从 $\\omega \\sim U_0 / \\ell_u$。这些关系确定了逆尺度代理：大的 $J$ 和大的 $\\omega$ 表明存在需要更精细分辨率的小物理结构（电流片和剪切层）。\n\n为了用无量纲数来量化这些触发条件，我们选择参考尺度 $J_0$ 和 $\\omega_0$，使得在 $L_0$ 上的“宏观”变化对应于 $J_0 \\equiv B_0 / (\\mu_0 L_0)$ 和 $\\omega_0 \\equiv U_0 / L_0$。于是有 $J/J_0 \\sim L_0 / \\ell_B$ 和 $\\omega/\\omega_0 \\sim L_0 / \\ell_u$。一个单元中最小的活动物理长度尺度为 $\\ell_{\\min} = \\min(\\ell_B,\\ell_u)$，使用间距为 $h$ 的网格来解析此尺度的要求可以表示为 $\\ell_{\\min} \\le \\kappa h$，其中 $\\kappa$ 是某个分辨率因子（例如，$\\kappa = 2$ 意味着每个最小尺度至少有两个单元）。用无量纲代理表示，$\\ell_B \\le \\kappa h$ 意味着 $J/J_0 \\ge L_0/(\\kappa h)$，而 $\\ell_u \\le \\kappa h$ 意味着 $\\omega/\\omega_0 \\ge L_0/(\\kappa h)$。一个保守的单一标量触发度量应该响应最小的尺度，因此选择两个归一化指标的最大值是合适的：\n$$\nM \\equiv \\max\\!\\left(\\frac{J}{J_0},\\,\\frac{\\omega}{\\omega_0}\\right).\n$$\n这一选择直接源于检测 $\\ell_B$ 和 $\\ell_u$ 最小值的需要：因为 $J/J_0 \\sim L_0/\\ell_B$ 且 $\\omega/\\omega_0 \\sim L_0/\\ell_u$，取这些比率的最大值就对应于相关长度尺度的最小值。\n\n因此，从物理推导出的加密阈值变为\n$$\nT_{\\mathrm{refine}} = \\frac{L_0}{\\kappa h},\n$$\n当 $M \\ge T_{\\mathrm{refine}}$ 时，单元应被加密。为避免加密抖动，我们通过粗化阈值 $T_{\\mathrm{coarsen}} = \\gamma\\, T_{\\mathrm{refine}}$（其中 $0  \\gamma  1$）引入滞后，并施加驻留时间要求：需要连续 $N_{\\uparrow}$ 个时间步高于 $T_{\\mathrm{refine}}$ 才能加密，需要连续 $N_{\\downarrow}$ 个时间步低于 $T_{\\mathrm{coarsen}}$ 才能粗化。介于阈值之间的 $M$ 值，即 $T_{\\mathrm{coarsen}}  M  T_{\\mathrm{refine}}$，不改变状态并重置计数器。该策略创建了一个缓冲带和持续性标准，从而消除了由 $M$ 的小幅振荡引起的快速切换。\n\n算法设计：\n1. 计算 $J_0 = B_0/(\\mu_0 L_0)$ 和 $\\omega_0 = U_0/L_0$（注意 $B_0$ 单位为 $\\mathrm{T}$，$U_0$ 单位为 $\\mathrm{m/s}$，$L_0$ 单位为 $\\mathrm{m}$，因此 $J_0$ 单位为 $\\mathrm{A/m^2}$，$\\omega_0$ 单位为 $\\mathrm{s^{-1}}$）。\n2. 对每个单元 $i$ 和时间 $t$，计算无量纲度量\n   $$\n   M(t,i) = \\max\\!\\left(\\frac{J(t,i)}{J_0},\\,\\frac{\\omega(t,i)}{\\omega_0}\\right).\n   $$\n3. 计算阈值 $T_{\\mathrm{refine}} = L_0/(\\kappa h)$ 和 $T_{\\mathrm{coarsen}} = \\gamma T_{\\mathrm{refine}}$。\n4. 将所有单元初始化为粗化状态。为每个单元维护两个计数器：$c_{\\uparrow}(i)$ 和 $c_{\\downarrow}(i)$。\n5. 对每个时间步：\n   - 如果 $M(t,i) \\ge T_{\\mathrm{refine}}$，则设置 $c_{\\uparrow}(i) \\leftarrow c_{\\uparrow}(i) + 1$，$c_{\\downarrow}(i) \\leftarrow 0$。如果单元是粗化的且 $c_{\\uparrow}(i) \\ge N_{\\uparrow}$，则将其切换为加密状态，并增加全局切换计数器。\n   - 否则，如果 $M(t,i) \\le T_{\\mathrm{coarsen}}$，则设置 $c_{\\downarrow}(i) \\leftarrow c_{\\downarrow}(i) + 1$，$c_{\\uparrow}(i) \\leftarrow 0$。如果单元是加密的且 $c_{\\downarrow}(i) \\ge N_{\\downarrow}$，则将其切换为粗化状态，并增加全局切换计数器。\n   - 否则（在滞后带内），将两个计数器都重置为零并保持当前状态。\n6. 在最后一个时间步之后，统计加密单元的数量并报告总切换次数。\n\n为何此方法能避免抖动：\n- 双阈值带 $[T_{\\mathrm{coarsen}}, T_{\\mathrm{refine}}]$ 确保了跨越单个阈值的小波动不会立即逆转决策；从物理角度看，它尊重了这样一个不确定性区间：相对于网格间距，其中既没有明确存在的强电流片，也没有明确存在的强剪切层。\n- 驻留时间 $N_{\\uparrow}$ 和 $N_{\\downarrow}$ 强制要求持续性，即在做出更改之前需要有持续的分辨率不足或分辨率过高的证据，这与磁流体力学中等离子体结构的实际演化过程相符。\n\n在测试套件上的应用：\n- 测试用例 1 使用 $B_0 = 5$，$U_0 = 2 \\times 10^{4}$，$L_0 = 0.1$，$h = 0.01$，$\\kappa = 2$，$\\gamma = 0.7$，$N_{\\uparrow} = 2$，$N_{\\downarrow} = 3$，这意味着 $J_0 = B_0 / (\\mu_0 L_0)$ 和 $\\omega_0 = U_0 / L_0$，其中 $T_{\\mathrm{refine}} = L_0/(\\kappa h) = 0.1/(2 \\cdot 0.01) = 5$ 且 $T_{\\mathrm{coarsen}} = \\gamma T_{\\mathrm{refine}} = 3.5$。所提供的信号导致前四个单元早期被加密且没有发生粗化，从而产生非零的加密单元计数和少量的切换次数。\n- 测试用例 2 使用 $h = 0.02$，$\\gamma = 0.8$，因此 $T_{\\mathrm{refine}} = 2.5$ 且 $T_{\\mathrm{coarsen}} = 2.0$。设计的阈值附近的振荡以及等式测试用例检验了滞后效应：加密需要持续高于 2.5，而粗化需要持续等于或低于 2.0；指定的序列导致前两个单元先加密后粗化，而其他单元不发生切换。\n- 测试用例 3 复制了尖峰信号，$T = 10$，$N = 10$，$h = 0.01$，$\\gamma = 0.7$。交替的高低值与 $N_{\\uparrow} = 2$ 和 $N_{\\downarrow} = 3$ 的设置防止了在短暂的低值区间内发生粗化，从而避免了抖动；具有持续高信号的单元加密一次后保持加密状态。\n\n程序计算 $J_0$、$\\omega_0$、阈值，跨时间步应用滞后逻辑，并为每个测试用例生成最终计数和切换总数。最终输出格式为包含列表的列表的单行字符串：$[[R_{\\mathrm{final}},T_{\\mathrm{toggles}}],\\ldots]$，符合要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nMU0 = 4.0 * np.pi * 1e-7  # Permeability of free space (H/m)\n\ndef apply_hysteresis(J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down):\n    \"\"\"\n    Apply refinement hysteresis policy to time series of J and vorticity W.\n    J, W: arrays of shape (T, N) with physical units (A/m^2) and (1/s).\n    Returns (final_refined_count, total_toggles).\n    \"\"\"\n    T, N = J.shape\n\n    # Characteristic scales\n    J0 = B0 / (MU0 * L0)\n    W0 = U0 / L0\n\n    # Dimensionless metric M = max(J/J0, W/W0)\n    M = np.maximum(J / J0, W / W0)\n\n    # Thresholds\n    T_refine = L0 / (kappa * h)\n    T_coarsen = gamma * T_refine\n\n    # State and counters\n    refined = np.zeros(N, dtype=bool)\n    up_count = np.zeros(N, dtype=int)\n    down_count = np.zeros(N, dtype=int)\n    toggles = 0\n\n    for t in range(T):\n        mt = M[t]\n        # Update counters and states per cell\n        for i in range(N):\n            if mt[i] = T_refine:\n                up_count[i] += 1\n                down_count[i] = 0\n                if (not refined[i]) and (up_count[i] = N_up):\n                    refined[i] = True\n                    toggles += 1\n            elif mt[i] = T_coarsen:\n                down_count[i] += 1\n                up_count[i] = 0\n                if refined[i] and (down_count[i] = N_down):\n                    refined[i] = False\n                    toggles += 1\n            else:\n                # Within hysteresis band: reset counters\n                up_count[i] = 0\n                down_count[i] = 0\n\n    final_refined_count = int(np.sum(refined))\n    return final_refined_count, toggles\n\ndef build_case_1():\n    # Parameters\n    B0 = 5.0       # Tesla\n    U0 = 2.0e4     # m/s\n    L0 = 0.1       # m\n    h = 0.01       # m\n    kappa = 2.0\n    gamma = 0.7\n    N_up = 2\n    N_down = 3\n\n    T = 8\n    N = 8\n\n    # Dimensionless multipliers a (for J) and b (for W)\n    a = np.zeros((T, N))\n    b = np.zeros((T, N))\n\n    # Cells 0..3: a_t = [6,6,6,4,4,4,4,4], b_t = [2,2,2,2,2,2,2,2]\n    pattern_a_early = [6, 6, 6, 4, 4, 4, 4, 4]\n    pattern_b_early = [2, 2, 2, 2, 2, 2, 2, 2]\n    for i in range(4):\n        a[:, i] = pattern_a_early\n        b[:, i] = pattern_b_early\n\n    # Cells 4..7: a_t = [3]*8, b_t = [3]*8\n    pattern_a_late = [3]*T\n    pattern_b_late = [3]*T\n    for i in range(4, 8):\n        a[:, i] = pattern_a_late\n        b[:, i] = pattern_b_late\n\n    # Convert to physical units\n    J0 = B0 / (MU0 * L0)\n    W0 = U0 / L0\n    J = a * J0\n    W = b * W0\n\n    return (J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down)\n\ndef build_case_2():\n    # Parameters\n    B0 = 5.0       # Tesla\n    U0 = 2.0e4     # m/s\n    L0 = 0.1       # m\n    h = 0.02       # m\n    kappa = 2.0\n    gamma = 0.8\n    N_up = 2\n    N_down = 3\n\n    T = 8\n    N = 8\n\n    a = np.zeros((T, N))\n    b = np.zeros((T, N))\n\n    # Cells 0..1: a_t = [2.5,2.5,2.4,2.4,2.4,2.0,2.0,2.0], b_t = zeros\n    pattern_a_01 = [2.5, 2.5, 2.4, 2.4, 2.4, 2.0, 2.0, 2.0]\n    for i in range(2):\n        a[:, i] = pattern_a_01\n        b[:, i] = [0]*T\n\n    # Cells 2..3: a_t alternating 2.5 and 2.4, b_t zeros\n    pattern_a_23 = [2.5, 2.4, 2.5, 2.4, 2.5, 2.4, 2.5, 2.4]\n    for i in range(2, 4):\n        a[:, i] = pattern_a_23\n        b[:, i] = [0]*T\n\n    # Cells 4..7: a_t = [1.8]*8, b_t = zeros\n    pattern_a_47 = [1.8]*T\n    for i in range(4, 8):\n        a[:, i] = pattern_a_47\n        b[:, i] = [0]*T\n\n    # Convert to physical units\n    J0 = B0 / (MU0 * L0)\n    W0 = U0 / L0\n    J = a * J0\n    W = b * W0\n\n    return (J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down)\n\ndef build_case_3():\n    # Parameters\n    B0 = 5.0       # Tesla\n    U0 = 2.0e4     # m/s\n    L0 = 0.1       # m\n    h = 0.01       # m\n    kappa = 2.0\n    gamma = 0.7\n    N_up = 2\n    N_down = 3\n\n    T = 10\n    N = 10\n\n    a = np.zeros((T, N))\n    b = np.zeros((T, N))\n\n    # Cells 0..4: a_t = [6,3,6,3,6,3,6,3,6,3], b_t zeros\n    pattern_a_04 = [6, 3, 6, 3, 6, 3, 6, 3, 6, 3]\n    for i in range(5):\n        a[:, i] = pattern_a_04\n        b[:, i] = [0]*T\n\n    # Cells 5..7: a_t = [6,6,3,3,6,6,3,3,6,6], b_t zeros\n    pattern_a_57 = [6, 6, 3, 3, 6, 6, 3, 3, 6, 6]\n    for i in range(5, 8):\n        a[:, i] = pattern_a_57\n        b[:, i] = [0]*T\n\n    # Cells 8..9: a_t = [6]*10, b_t zeros\n    pattern_a_89 = [6]*T\n    for i in range(8, 10):\n        a[:, i] = pattern_a_89\n        b[:, i] = [0]*T\n\n    # Convert to physical units\n    J0 = B0 / (MU0 * L0)\n    W0 = U0 / L0\n    J = a * J0\n    W = b * W0\n\n    return (J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        build_case_1(),\n        build_case_2(),\n        build_case_3(),\n    ]\n\n    results = []\n    for case in test_cases:\n        J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down = case\n        final_refined_count, toggles = apply_hysteresis(\n            J, W, B0, U0, L0, h, kappa, gamma, N_up, N_down\n        )\n        results.append([final_refined_count, toggles])\n\n    # Final print statement in the exact required format.\n    # Single line output: list of [R_final, T_toggles] per test case.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```"
        }
    ]
}