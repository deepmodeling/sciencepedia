{
    "hands_on_practices": [
        {
            "introduction": "第一个实践旨在建立对辛积分器来源的深刻、基础的理解。你将从基本的哈密顿原理出发，利用生成函数，为物理学中的基石模型——谐振子——推导出一个完整的辛积分器。这个练习将揭开数值方法“黑箱”的神秘面纱，展示支撑其长期稳定性的优美几何结构。",
            "id": "4049887",
            "problem": "在一个用于描述环形约束装置中靠近磁轴的导心的小振幅径向振荡的降阶单自由度模型中，其在正则坐标下的动力学由以下二次哈密顿量近似：\n$$\nH(q,p) \\;=\\; \\frac{1}{2 m}\\,p^{2} \\;+\\; \\frac{1}{2}\\,k\\,q^{2},\n$$\n其中 $m>0$ 是一个等效质量参数，$k>0$ 则代表了等效势的局部二次曲率。令 $h>0$ 为一个固定的时间步长。仅使用基本变分原理和正则变换的定义，通过引入一个第一类生成函数 $S_{1}(q,Q;h)$ 来构造一个辛单步方法，其中 $q$ 和 $Q$ 分别表示相隔时间 $h$ 的连续时间节点上的旧位形位置和新位形位置。构造过程必须从哈密顿原理和第一类生成函数的定义开始，并且必须对一个时间步长内的作用量采用对称近似，以获得一个二阶、时间可逆的映射。从得到的 $S_{1}(q,Q;h)$ 出发，推导出从 $(q_{n},p_{n})$ 到 $(q_{n+1},p_{n+1})$ 的显式更新关系，并证明该映射是线性的和辛的。用 $m$、$k$ 和 $h$ 的符号形式表示所有中间关系。\n\n请用 $m$、$k$ 和 $h$ 给出生成函数 $S_{1}(q,Q;h)$ 的闭式表达式作为你的最终答案。最终答案中不应包含任何数值计算或四舍五入，也无需物理单位。",
            "solution": "本问题要求使用第一类生成函数 $S_{1}(q,Q;h)$ 为简谐振子构造一个辛单步方法。该构造必须从第一性原理（特别是哈密顿原理）推导得出，并对作用量积分采用对称近似。\n\n系统的哈密顿量由下式给出\n$$ H(q,p) = \\frac{1}{2 m}\\,p^{2} + \\frac{1}{2}\\,k\\,q^{2} $$\n其中 $q$ 是位置，$p$ 是动量，$m>0$ 是等效质量，$k>0$ 是弹簧常数。相应的拉格朗日量 $L(q, \\dot{q}) = p\\dot{q} - H$ 可以通过先将 $p$ 表示为 $\\dot{q}$ 的函数来求得。根据哈密顿方程 $\\dot{q} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m}$，我们有 $p = m\\dot{q}$。将此代入拉格朗日量的定义中，得到\n$$ L(q, \\dot{q}) = (m\\dot{q})\\dot{q} - \\left(\\frac{1}{2m}(m\\dot{q})^2 + \\frac{1}{2}kq^2\\right) = \\frac{1}{2}m\\dot{q}^2 - \\frac{1}{2}kq^2 $$\n\n哈密顿原理指出，系统在位形空间中两点 $q(t_n)$ 和 $q(t_{n+1})$ 之间的轨迹使作用量积分 $A = \\int_{t_n}^{t_{n+1}} L(q(t), \\dot{q}(t)) dt$ 取极值。在正则变换理论中，第一类生成函数 $S_1(q, Q; h)$ 通过以下关系式将时间 $t_n$ 的旧坐标 $(q,p)$ 与时间 $t_{n+1} = t_n+h$ 的新坐标 $(Q,P)$ 联系起来\n$$ p = \\frac{\\partial S_1}{\\partial q} \\quad \\text{and} \\quad P = -\\frac{\\partial S_1}{\\partial Q} $$\n生成函数本身是沿真实路径的作用量积分的近似：$S_1(q, Q; h) \\approx \\int_{t_n}^{t_{n+1}} L(q(t), \\dot{q}(t)) dt$。\n\n为了构造一个二阶、时间可逆的映射，我们必须对作用量积分使用对称近似。最自然的对称近似是中点法则，即将区间 $[t_n, t_{n+1}]$（时长为 $h$）上的连续拉格朗日量 $L(q(t), \\dot{q}(t))$ 近似为它在时间中点 $t_n + h/2$ 处的值。中点处的位置和速度通过对称有限差分来近似：\n$$ q(t_n+h/2) \\approx \\frac{q+Q}{2} \\quad \\text{and} \\quad \\dot{q}(t_n+h/2) \\approx \\frac{Q-q}{h} $$\n其中 $q = q(t_n)$ 且 $Q = q(t_{n+1})$。作用量积分于是近似为\n$$ A \\approx h \\cdot L\\left(\\frac{q+Q}{2}, \\frac{Q-q}{h}\\right) $$\n代入拉格朗日量的表达式，我们将我们的生成函数定义为：\n$$ S_1(q, Q; h) = h \\left[ \\frac{1}{2}m\\left(\\frac{Q-q}{h}\\right)^2 - \\frac{1}{2}k\\left(\\frac{q+Q}{2}\\right)^2 \\right] $$\n$$ S_1(q, Q; h) = \\frac{m}{2h}(Q-q)^2 - \\frac{kh}{8}(q+Q)^2 $$\n这就是所要求的生成函数。\n\n接下来，我们推导从 $(q_n, p_n)$ 到 $(q_{n+1}, p_{n+1})$ 的显式更新关系。我们令 $q=q_n$，$p=p_n$，$Q=q_{n+1}$，以及 $P=p_{n+1}$。使用 $S_1$ 的定义关系：\n$$ p_n = \\frac{\\partial S_1}{\\partial q_n} = \\frac{m}{2h} \\cdot 2(q_{n+1}-q_n)(-1) - \\frac{kh}{8} \\cdot 2(q_n+q_{n+1})(1) = -\\frac{m}{h}(q_{n+1}-q_n) - \\frac{kh}{4}(q_n+q_{n+1}) $$\n$$ p_{n+1} = -\\frac{\\partial S_1}{\\partial q_{n+1}} = -\\left[ \\frac{m}{2h} \\cdot 2(q_{n+1}-q_n)(1) - \\frac{kh}{8} \\cdot 2(q_n+q_{n+1})(1) \\right] = -\\frac{m}{h}(q_{n+1}-q_n) + \\frac{kh}{4}(q_n+q_{n+1}) $$\n这两个方程隐式地定义了该映射。我们重新整理它们，以求解 $(q_{n+1}, p_{n+1})$ 作为 $(q_n, p_n)$ 的显式函数。首先，分离含有 $q_n$ 和 $q_{n+1}$ 的项：\n$$ p_n = \\left(\\frac{m}{h} - \\frac{kh}{4}\\right)q_n - \\left(\\frac{m}{h} + \\frac{kh}{4}\\right)q_{n+1} \\quad (1) $$\n$$ p_{n+1} = \\left(\\frac{m}{h} + \\frac{kh}{4}\\right)q_n - \\left(\\frac{m}{h} - \\frac{kh}{4}\\right)q_{n+1} \\quad (2) $$\n从方程(1)中，我们求解 $q_{n+1}$：\n$$ \\left(\\frac{m}{h} + \\frac{kh}{4}\\right)q_{n+1} = \\left(\\frac{m}{h} - \\frac{kh}{4}\\right)q_n - p_n $$\n$$ q_{n+1} = \\frac{\\frac{m}{h} - \\frac{kh}{4}}{\\frac{m}{h} + \\frac{kh}{4}} q_n - \\frac{1}{\\frac{m}{h} + \\frac{kh}{4}} p_n = \\frac{4m-kh^2}{4m+kh^2}q_n - \\frac{4h}{4m+kh^2}p_n $$\n现在我们通过将 $q_{n+1}$ 的这个表达式代入方程(2)来求 $p_{n+1}$。为简化代数运算，令 $A = \\frac{m}{h} + \\frac{kh}{4}$ 和 $B = \\frac{m}{h} - \\frac{kh}{4}$。该映射为 $q_{n+1} = \\frac{B}{A}q_n - \\frac{1}{A}p_n$ 和 $p_{n+1} = A q_n - B q_{n+1}$。\n$$ p_{n+1} = A q_n - B\\left(\\frac{B}{A}q_n - \\frac{1}{A}p_n\\right) = \\left(A - \\frac{B^2}{A}\\right)q_n + \\frac{B}{A}p_n = \\frac{A^2-B^2}{A}q_n + \\frac{B}{A}p_n $$\n我们计算各项：\n$$ A^2 - B^2 = (A-B)(A+B) = \\left( \\frac{kh}{2} \\right) \\left( \\frac{2m}{h} \\right) = km $$\n所以，$q_n$ 的系数是 $\\frac{km}{A} = \\frac{km}{\\frac{m}{h} + \\frac{kh}{4}} = \\frac{4hkm}{4m+kh^2}$。$p_n$ 的系数是 $\\frac{B}{A} = \\frac{4m-kh^2}{4m+kh^2}$。\n完整的更新关系是：\n$$ q_{n+1} = \\frac{4m-kh^2}{4m+kh^2}\\,q_n - \\frac{4h}{4m+kh^2}\\,p_n $$\n$$ p_{n+1} = \\frac{4hkm}{4m+kh^2}\\,q_n + \\frac{4m-kh^2}{4m+kh^2}\\,p_n $$\n该变换是线性的，因为它可以表示为矩阵形式。令 $z_n = \\begin{pmatrix} q_n \\\\ p_n \\end{pmatrix}$。则 $z_{n+1} = M z_n$，其中映射矩阵 $M$ 为\n$$ M = \\frac{1}{4m+kh^2} \\begin{pmatrix} 4m - kh^2 & -4h \\\\ 4hkm & 4m - kh^2 \\end{pmatrix} $$\n为了证明该映射是辛的，我们必须证明雅可比矩阵 $M$ 满足 $M^T J M = J$，其中 $J = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}$。对于一个 $2 \\times 2$ 矩阵，此条件等价于 $\\det(M)=1$。\n$$ \\det(M) = \\left( \\frac{1}{4m+kh^2} \\right)^2 \\left[ (4m-kh^2)^2 - (-4h)(4hkm) \\right] $$\n$$ \\det(M) = \\frac{1}{(4m+kh^2)^2} \\left[ (16m^2 - 8mkh^2 + k^2h^4) + 16h^2km \\right] $$\n$$ \\det(M) = \\frac{1}{(4m+kh^2)^2} \\left[ 16m^2 + 8mkh^2 + k^2h^4 \\right] = \\frac{(4m+kh^2)^2}{(4m+kh^2)^2} = 1 $$\n由于 $\\det(M)=1$，该映射是辛的。此方法从作用量的对称近似推导而来，是隐式中点法则，它是一个二阶、时间可逆且辛的积分器。该构造满足了问题的所有要求。\n\n问题要求给出生成函数 $S_1(q,Q;h)$ 的闭式表达式。根据上述推导，其表达式为：\n$$ S_1(q, Q; h) = \\frac{m}{2h}(Q-q)^2 - \\frac{kh}{8}(q+Q)^2 $$",
            "answer": "$$ \\boxed{ \\frac{m}{2h}(Q-q)^2 - \\frac{kh}{8}(q+Q)^2 } $$"
        },
        {
            "introduction": "现在我们从基础理论转向计算聚变科学中的一个关键实际应用：模拟带电粒子在磁场中的运动。这个动手实践问题要求你实现著名的 Boris 算法，这是一个经典的保结构几何积分器例子。通过数值实验，你将验证其最重要的特性之一——精确的时间可逆性，这一特性对长期等离子体模拟的保真度至关重要。",
            "id": "4049930",
            "problem": "考虑在与计算聚变科学与工程相关的磁化等离子体动力学背景下，单个带电粒子在静磁场中的运动。该电荷为 $q$、质量为 $m$ 的粒子遵循牛顿第二定律和洛伦兹磁力：$m \\,\\dfrac{d\\mathbf{v}}{dt} = q\\,\\mathbf{v}\\times\\mathbf{B}(\\mathbf{r})$ 以及 $\\dfrac{d\\mathbf{r}}{dt} = \\mathbf{v}$，其中 $\\mathbf{r}\\in\\mathbb{R}^3$ 是位置，$\\mathbf{v}\\in\\mathbb{R}^3$ 是速度，$\\mathbf{B}(\\mathbf{r})\\in\\mathbb{R}^3$ 是一个无散磁场。从这些基本定律出发，构建一个单步、显式、保结构的、且时间可逆的几何算法。该算法必须从第一性原理出发，通过使用流的对称分裂来推导，以保持纯磁动力学的典范几何性质，即相空间体积守恒和精确时间对称性。您推导的格式不应引入任何人为耗散，并且必须与静磁场中动能的不变性（因为 $\\mathbf{v}\\cdot(\\mathbf{v}\\times\\mathbf{B})=0$）相一致。\n\n您的程序必须实现所推导的可逆格式，并通过执行以下计算实验，为每个测试用例数值上地展示其精确的时间对称性属性：从 $(\\mathbf{r}_0,\\mathbf{v}_0)$ 开始，以时间步长 $h$ 向前积分 $N$ 步到 $(\\mathbf{r}_N,\\mathbf{v}_N)$，然后从 $(\\mathbf{r}_N,\\mathbf{v}_N)$ 开始，以时间步长 $-h$ 向后积分 $N$ 步，并验证最终状态 $(\\mathbf{r}_{\\text{rev}},\\mathbf{v}_{\\text{rev}})$ 在数值精度范围内与初始状态 $(\\mathbf{r}_0,\\mathbf{v}_0)$ 相匹配。如果 $\\|\\mathbf{r}_{\\text{rev}}-\\mathbf{r}_0\\|_\\infty$ 和 $\\|\\mathbf{v}_{\\text{rev}}-\\mathbf{v}_0\\|_\\infty$ 均小于一个与机器精度和初始数据尺度成比例的容差，则判定为时间对称。程序中的所有量都必须使用国际单位制（SI单位）处理：米 (m)、秒 (s)、千克 (kg) 和库仑 (C)。角度（如果内部使用）必须以弧度解释。\n\n该测试套件包含五组科学上合理的参数集，旨在探测磁化运动的不同状态和边界情况：\n- 测试1（均匀场，中等步长）：$q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[0,0,B_0\\right]$ 其中 $B_0=3\\,\\text{T}$， $h=1.0\\times 10^{-9}\\,\\text{s}$， $N=100$， $\\mathbf{r}_0=[0.1,0.0,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[1.0\\times 10^{5},2.0\\times 10^{5},0.0]\\,\\text{m/s}$。\n- 测试2（零场边界情况）：$q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[0,0,0\\right]\\,\\text{T}$， $h=2.0\\times 10^{-9}\\,\\text{s}$， $N=50$， $\\mathbf{r}_0=[-0.3,0.2,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[-5.0\\times 10^{4},1.0\\times 10^{5},1.0\\times 10^{5}]\\,\\text{m/s}$。\n- 测试3（非均匀无散场）：$q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[\\alpha x,-\\alpha y,B_0\\right]$ 其中 $\\alpha=0.5\\,\\text{T/m}$ 且 $B_0=1.0\\,\\text{T}$， $h=5.0\\times 10^{-10}\\,\\text{s}$， $N=200$， $\\mathbf{r}_0=[0.0,0.0,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[2.0\\times 10^{5},0.0,1.0\\times 10^{5}]\\,\\text{m/s}$。\n- 测试4（强场，小步长）：$q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[0,0,B_0\\right]$ 其中 $B_0=10\\,\\text{T}$， $h=1.0\\times 10^{-10}\\,\\text{s}$， $N=1000$， $\\mathbf{r}_0=[0.0,0.5,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[3.0\\times 10^{5},-1.0\\times 10^{5},0.0]\\,\\text{m/s}$。\n- 测试5（长时积分，小步长，随机初始状态）：$q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[\\alpha x,-\\alpha y,B_0\\right]$ 其中 $\\alpha=0.2\\,\\text{T/m}$ 且 $B_0=2.0\\,\\text{T}$， $h=2.0\\times 10^{-10}\\,\\text{s}$， $N=2000$， $\\mathbf{r}_0=[0.2,-0.1,0.05]\\,\\text{m}$， $\\mathbf{v}_0=[1.5\\times 10^{5},1.2\\times 10^{5},-0.5\\times 10^{5}]\\,\\text{m/s}$。\n\n对于每个测试，计算一个布尔值，指示积分器是否在数值精度内具有时间对称性，其定义为 $\\|\\mathbf{r}_{\\text{rev}}-\\mathbf{r}_0\\|_\\infty \\le \\varepsilon_r$ 和 $\\|\\mathbf{v}_{\\text{rev}}-\\mathbf{v}_0\\|_\\infty \\le \\varepsilon_v$，其中容差为 $\\varepsilon_r = 10^{-11}\\max\\{1,\\|\\mathbf{r}_0\\|_2\\}$ 和 $\\varepsilon_v = 10^{-11}\\max\\{1,\\|\\mathbf{v}_0\\|_2\\}$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5]”），其中每个“result”是按上述顺序对应测试的布尔值。",
            "solution": "## 问题验证\n\n### 第一步：提取已知信息\n\n问题提供了以下物理定律和定义：\n- 位置运动方程：$\\dfrac{d\\mathbf{r}}{dt} = \\mathbf{v}$。\n- 速度运动方程（洛伦兹力）：$m \\,\\dfrac{d\\mathbf{v}}{dt} = q\\,\\mathbf{v}\\times\\mathbf{B}(\\mathbf{r})$。\n- 变量：位置 $\\mathbf{r}\\in\\mathbb{R}^3$，速度 $\\mathbf{v}\\in\\mathbb{R}^3$，电荷 $q$，质量 $m$。\n- 磁场：$\\mathbf{B}(\\mathbf{r})\\in\\mathbb{R}^3$，为静场且无散（$\\nabla \\cdot \\mathbf{B} = 0$）。\n\n计算任务要求：\n- 构建一个单步、显式、保结构的、且时间可逆的几何算法。\n- 该算法必须使用对称分裂从第一性原理推导。\n- 该算法必须在数值上展示时间对称性。\n- 先以步长 $h$ 向前积分 $N$ 步，再以步长 $-h$ 向后积分 $N$ 步。\n- 如果 $\\|\\mathbf{r}_{\\text{rev}}-\\mathbf{r}_0\\|_\\infty \\le \\varepsilon_r$ 且 $\\|\\mathbf{v}_{\\text{rev}}-\\mathbf{v}_0\\|_\\infty \\le \\varepsilon_v$，则确认时间对称性。\n- 容差：$\\varepsilon_r = 10^{-11}\\max\\{1,\\|\\mathbf{r}_0\\|_2\\}$ 和 $\\varepsilon_v = 10^{-11}\\max\\{1,\\|\\mathbf{v}_0\\|_2\\}$。\n\n问题提供了五个测试用例，其参数如下：\n- **测试1：** $q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[0,0,3\\right]\\,\\text{T}$， $h=1.0\\times 10^{-9}\\,\\text{s}$， $N=100$， $\\mathbf{r}_0=[0.1,0.0,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[1.0\\times 10^{5},2.0\\times 10^{5},0.0]\\,\\text{m/s}$。\n- **测试2：** $q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[0,0,0\\right]\\,\\text{T}$， $h=2.0\\times 10^{-9}\\,\\text{s}$， $N=50$， $\\mathbf{r}_0=[-0.3,0.2,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[-5.0\\times 10^{4},1.0\\times 10^{5},1.0\\times 10^{5}]\\,\\text{m/s}$。\n- **测试3：** $q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[\\alpha x,-\\alpha y,B_0\\right]$ 其中 $\\alpha=0.5\\,\\text{T/m}$， $B_0=1.0\\,\\text{T}$， $h=5.0\\times 10^{-10}\\,\\text{s}$， $N=200$， $\\mathbf{r}_0=[0.0,0.0,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[2.0\\times 10^{5},0.0,1.0\\times 10^{5}]\\,\\text{m/s}$。\n- **测试4：** $q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[0,0,10\\right]\\,\\text{T}$， $h=1.0\\times 10^{-10}\\,\\text{s}$， $N=1000$， $\\mathbf{r}_0=[0.0,0.5,0.0]\\,\\text{m}$， $\\mathbf{v}_0=[3.0\\times 10^{5},-1.0\\times 10^{5},0.0]\\,\\text{m/s}$。\n- **测试5：** $q=1.602176634\\times 10^{-19}\\,\\text{C}$， $m=1.67262192369\\times 10^{-27}\\,\\text{kg}$， $\\mathbf{B}(\\mathbf{r})=\\left[\\alpha x,-\\alpha y,B_0\\right]$ 其中 $\\alpha=0.2\\,\\text{T/m}$， $B_0=2.0\\,\\text{T}$， $h=2.0\\times 10^{-10}\\,\\text{s}$， $N=2000$， $\\mathbf{r}_0=[0.2,-0.1,0.05]\\,\\text{m}$， $\\mathbf{v}_0=[1.5\\times 10^{5},1.2\\times 10^{5},-0.5\\times 10^{5}]\\,\\text{m/s}$。\n\n### 第二步：使用提取的已知信息进行验证\n\n1.  **科学上可靠：** 该问题基于经典电动力学的基本定律——牛顿第二定律和洛伦兹力，这准确地描述了带电粒子在磁场中的运动。指定的粒子参数对应于质子，磁场强度和速度是聚变等离子体环境的特征。非均匀磁场 $\\mathbf{B}(\\mathbf{r})=\\left[\\alpha x,-\\alpha y,B_0\\right]$ 是物理上有效的，因为它是无散的：$\\nabla \\cdot \\mathbf{B} = \\frac{\\partial(\\alpha x)}{\\partial x} + \\frac{\\partial(-\\alpha y)}{\\partial y} + \\frac{\\partial B_0}{\\partial z} = \\alpha - \\alpha + 0 = 0$。\n2.  **适定的：** 为该系统构建时间可逆的几何积分器是计算物理学中的一个经典课题。对算法的要求是具体的，并导向一族定义明确的解（对称分裂格式）。验证时间对称性的数值实验有明确定义和具体容差。所有必要的数据均已提供。\n3.  **客观的：** 问题以精确、客观和数学化的语言陈述。没有主观或基于观点的断言。\n4.  **相关的：** 该问题明确属于*计算聚变科学与工程*领域中的*保结构几何算法*范畴。\n\n该问题没有科学缺陷、矛盾和歧义。\n\n### 第三步：结论与行动\n问题有效。将提供解决方案。\n\n## 算法推导与求解\n\n目标是为控制带电粒子在磁场中运动的常微分方程组构建一个保结构的数值积分器：\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\frac{q}{m} \\mathbf{v} \\times \\mathbf{B}(\\mathbf{r})\n$$\n令系统的状态由相空间向量 $\\mathbf{z} = (\\mathbf{r}, \\mathbf{v})$ 表示。系统在时间步长 $h$ 内的演化可以由一个流映射 $\\Phi_h$ 表示，使得 $\\mathbf{z}(t+h) = \\Phi_h(\\mathbf{z}(t))$。保结构的几何积分器是 $\\Phi_h$ 的一个近似，它保留了真实流的关键几何性质，例如相空间体积守恒（辛性）和时间可逆性。\n\n构建此类积分器的一种标准方法是算子分裂。控制动力学的向量场 $\\dot{\\mathbf{z}} = F(\\mathbf{z})$ 被分裂成两个或多个部分，其中每个部分对应一个可精确求解的子系统。对于此问题，我们可以将动力学分为自由漂移部分（A）和速度旋转部分（B）：\n- **A部分（自由漂移/Drift）：**\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = \\mathbf{0}\n$$\n对于时间步长 $h$，其精确流 $\\Phi_A^h$ 为：\n$$\n\\mathbf{r}(t+h) = \\mathbf{r}(t) + h \\mathbf{v}(t), \\quad \\mathbf{v}(t+h) = \\mathbf{v}(t)\n$$\n- **B部分（速度旋转/Kick）：**\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{0}, \\quad \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m} \\mathbf{v} \\times \\mathbf{B}(\\mathbf{r})\n$$\n对于时间步长 $h$，其精确流 $\\Phi_B^h$ 保持位置恒定，$\\mathbf{r}(t+h) = \\mathbf{r}(t)$，并围绕由磁场向量 $\\mathbf{B}(\\mathbf{r})$ 定义的轴旋转速度向量 $\\mathbf{v}$，其回旋频率为 $\\omega_c = |q|\\|\\mathbf{B}\\|/m$。由于在此子步骤中 $\\mathbf{r}$ 是恒定的，$\\mathbf{B}(\\mathbf{r})$ 也是恒定的，因此该子系统描述了一个纯粹的旋转。这种旋转保持了速度的大小 $\\|\\mathbf{v}\\|$，从而保持动能守恒。\n\n为了构建一个时间可逆的积分器，我们使用这些精确流的对称组合。Strang分裂方法提供了一个二阶精度且对称的格式：\n$$\n\\Phi_h^{\\text{approx}} = \\Phi_A^{h/2} \\circ \\Phi_B^h \\circ \\Phi_A^{h/2}\n$$\n该组合从右到左解读：一个半步漂移，一个整步旋转，然后是另一个半步漂移。让我们将其转化为一个显式算法，以将状态从时间 $t_n$ 的 $(\\mathbf{r}_n, \\mathbf{v}_n)$ 更新到时间 $t_{n+1} = t_n + h$ 的 $(\\mathbf{r}_{n+1}, \\mathbf{v}_{n+1})$：\n\n1.  **第一个半步漂移（应用 $\\Phi_A^{h/2}$）：** 使用当前速度将位置推进半个时间步。\n    $$\n    \\mathbf{r}_{n+1/2} = \\mathbf{r}_n + \\frac{h}{2} \\mathbf{v}_n\n    $$\n2.  **整步旋转（应用 $\\Phi_B^h$）：** 将速度旋转一个完整的时间步。该格式的关键思想是在时间中心位置 $\\mathbf{r}_{n+1/2}$ 处评估磁场 $\\mathbf{B}$。这种中心化处理是该方法对称性和准确性的关键。速度更新求解 $\\frac{d\\mathbf{v}}{dt} = \\frac{q}{m} \\mathbf{v} \\times \\mathbf{B}(\\mathbf{r}_{n+1/2})$。针对此旋转子问题，一个标准的、计算高效且精确的实现是Boris算法。它源自于对速度方程的中心差分近似：\n    $$\n    \\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{h} = \\frac{q}{m} \\left( \\frac{\\mathbf{v}_{n+1} + \\mathbf{v}_n}{2} \\right) \\times \\mathbf{B}(\\mathbf{r}_{n+1/2})\n    $$\n    该方程可以显式地解出 $\\mathbf{v}_{n+1}$，得到以下步骤：\n    a. 定义无量纲旋转向量 $\\boldsymbol{\\tau} = \\frac{q h}{2m} \\mathbf{B}(\\mathbf{r}_{n+1/2})$。\n    b. 计算中间速度 $\\mathbf{v}' = \\mathbf{v}_n + \\mathbf{v}_n \\times \\boldsymbol{\\tau}$。\n    c. 计算新速度 $\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{2}{1 + \\|\\boldsymbol{\\tau}\\|^2} (\\mathbf{v}' \\times \\boldsymbol{\\tau})$。\n\n3.  **第二个半步漂移（应用 $\\Phi_A^{h/2}$）：** 通过使用*新计算出*的速度 $\\mathbf{v}_{n+1}$，将中间步位置 $\\mathbf{r}_{n+1/2}$ 推进半个时间步，计算出最终位置。\n    $$\n    \\mathbf{r}_{n+1} = \\mathbf{r}_{n+1/2} + \\frac{h}{2} \\mathbf{v}_{n+1}\n    $$\n这个三步过程构成了一个积分器的完整时间步。它是显式的，因为每一步都可以直接从前一步的结果计算得出。它是保体积的，因为流 $\\Phi_A$（剪切变换）和 $\\Phi_B$（子空间中的旋转）的雅可比矩阵行列式都为1，总的雅可比矩阵是它们的乘积。它是时间可逆的，因为组合是对称的。使用时间步长 $-h$ 应用该格式会精确地反转用步长 $h$ 执行的变换，这一特性将通过数值进行验证。最后，该格式与能量守恒是一致的。对于均匀磁场，动能精确守恒。对于非均匀场，总能量不完全守恒，但表现出优异的长期行为，能量有界振荡，这是几何积分器的一个特征。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a structure-preserving geometric algorithm (Boris algorithm) for\n    charged particle motion in a magnetic field and verifies its time symmetry.\n    \"\"\"\n\n    # Define physical constants for the proton\n    Q_PROTON = 1.602176634e-19  # Elementary charge in Coulombs\n    M_PROTON = 1.67262192369e-27 # Proton mass in kg\n\n    # Define the test cases as specified in the problem statement\n    test_cases = [\n        {\n            \"q\": Q_PROTON, \"m\": M_PROTON, \"B_func_type\": \"uniform\",\n            \"B_params\": {\"B0\": 3.0}, \"h\": 1.0e-9, \"N\": 100,\n            \"r0\": np.array([0.1, 0.0, 0.0]),\n            \"v0\": np.array([1.0e5, 2.0e5, 0.0])\n        },\n        {\n            \"q\": Q_PROTON, \"m\": M_PROTON, \"B_func_type\": \"zero\",\n            \"B_params\": {}, \"h\": 2.0e-9, \"N\": 50,\n            \"r0\": np.array([-0.3, 0.2, 0.0]),\n            \"v0\": np.array([-5.0e4, 1.0e5, 1.0e5])\n        },\n        {\n            \"q\": Q_PROTON, \"m\": M_PROTON, \"B_func_type\": \"linear_nonuniform\",\n            \"B_params\": {\"alpha\": 0.5, \"B0\": 1.0}, \"h\": 5.0e-10, \"N\": 200,\n            \"r0\": np.array([0.0, 0.0, 0.0]),\n            \"v0\": np.array([2.0e5, 0.0, 1.0e5])\n        },\n        {\n            \"q\": Q_PROTON, \"m\": M_PROTON, \"B_func_type\": \"uniform\",\n            \"B_params\": {\"B0\": 10.0}, \"h\": 1.0e-10, \"N\": 1000,\n            \"r0\": np.array([0.0, 0.5, 0.0]),\n            \"v0\": np.array([3.0e5, -1.0e5, 0.0])\n        },\n        {\n            \"q\": Q_PROTON, \"m\": M_PROTON, \"B_func_type\": \"linear_nonuniform\",\n            \"B_params\": {\"alpha\": 0.2, \"B0\": 2.0}, \"h\": 2.0e-10, \"N\": 2000,\n            \"r0\": np.array([0.2, -0.1, 0.05]),\n            \"v0\": np.array([1.5e5, 1.2e5, -0.5e5])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        q = case[\"q\"]\n        m = case[\"m\"]\n        h = case[\"h\"]\n        N = case[\"N\"]\n        r0 = case[\"r0\"]\n        v0 = case[\"v0\"]\n        \n        # Define the magnetic field function based on test case parameters\n        if case[\"B_func_type\"] == \"uniform\":\n            B0 = case[\"B_params\"][\"B0\"]\n            B_func = lambda r: np.array([0.0, 0.0, B0])\n        elif case[\"B_func_type\"] == \"zero\":\n            B_func = lambda r: np.array([0.0, 0.0, 0.0])\n        elif case[\"B_func_type\"] == \"linear_nonuniform\":\n            alpha = case[\"B_params\"][\"alpha\"]\n            B0 = case[\"B_params\"][\"B0\"]\n            B_func = lambda r: np.array([alpha * r[0], -alpha * r[1], B0])\n        \n        # Pre-calculate charge-to-mass ratio for efficiency\n        q_over_m = q / m\n\n        def boris_step(r, v, time_step):\n            \"\"\"\n            Performs one step of the Boris algorithm.\n            \"\"\"\n            # First half position drift\n            r_half = r + 0.5 * time_step * v\n            \n            # Evaluate B-field at the midpoint position\n            B_mid = B_func(r_half)\n            \n            # Velocity rotation\n            t_vec = (q_over_m * time_step / 2.0) * B_mid\n            t_mag_sq = np.dot(t_vec, t_vec)\n            \n            v_prime = v + np.cross(v, t_vec)\n            s_vec = (2.0 / (1.0 + t_mag_sq)) * t_vec\n            v_new = v + np.cross(v_prime, s_vec)\n            \n            # Second half position drift\n            r_new = r_half + 0.5 * time_step * v_new\n            \n            return r_new, v_new\n            \n        # Forward integration\n        r_fwd, v_fwd = np.copy(r0), np.copy(v0)\n        for _ in range(N):\n            r_fwd, v_fwd = boris_step(r_fwd, v_fwd, h)\n            \n        # Backward integration\n        r_rev, v_rev = np.copy(r_fwd), np.copy(v_fwd)\n        for _ in range(N):\n            r_rev, v_rev = boris_step(r_rev, v_rev, -h)\n            \n        # Verification of time symmetry\n        eps_r_scale = max(1.0, np.linalg.norm(r0))\n        eps_v_scale = max(1.0, np.linalg.norm(v0))\n        \n        tol_r = 1e-11 * eps_r_scale\n        tol_v = 1e-11 * eps_v_scale\n        \n        err_r = np.linalg.norm(r_rev - r0, ord=np.inf)\n        err_v = np.linalg.norm(v_rev - v0, ord=np.inf)\n        \n        is_symmetric = (err_r = tol_r) and (err_v = tol_v)\n        results.append(is_symmetric)\n\n    # Format the final output as a comma-separated list of lowercase booleans\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在构建并实现了一个几何积分器之后，这最后一个实践将探讨*为什么*这些方法在长期模拟中如此强大。你将定量分析和比较一个辛积分器与一个标准的非辛龙格-库塔方法在相位精度上的表现。这个练习为后向误差分析（Backward Error Analysis, BEA）的理论预测提供了一个具体的展示，说明了保持几何结构如何导致有界的能量误差和在数千个周期内卓越的相位保持能力。",
            "id": "4049892",
            "problem": "考虑均匀磁场中单电荷离子的平面回旋运动，将其作为磁约束聚变装置中快动力学的基准模型。使用洛伦兹力定律作为基本依据，将问题纯粹用数学术语表述如下。\n\n从洛伦兹力定律出发，考虑一个电荷为 $q$、质量为 $m$ 的粒子在均匀磁场 $\\mathbf{B} = B \\,\\hat{\\mathbf{z}}$ 中运动，且不存在电场。设 $\\mathbf{r}(t) = (x(t), y(t))$ 为位置，$\\mathbf{v}(t) = (v_x(t), v_y(t))$ 为垂直于磁场 $\\mathbf{B}$ 的平面内的速度。其控制方程为\n$$\nm \\,\\frac{d\\mathbf{v}}{dt} = q\\,\\mathbf{v} \\times \\mathbf{B}, \\qquad \\frac{d\\mathbf{r}}{dt} = \\mathbf{v}.\n$$\n定义回旋频率 $\\Omega = \\frac{q B}{m}$ 和 $2\\times 2$ 的标准辛矩阵 $J = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$。于是，平面内速度的演化是一个线性哈密顿系统\n$$\n\\frac{d\\mathbf{v}}{dt} = \\Omega\\,J\\,\\mathbf{v}.\n$$\n\n需要完成的任务：\n\n1. 利用哈密顿结构和后向误差分析（BEA），推导应用于线性系统 $\\frac{d\\mathbf{v}}{dt} = \\Omega\\,J\\,\\mathbf{v}$ 的辛隐式中点法的修正频率。从第一性原理出发，展示该方法的单步映射如何用生成元的凯莱变换表示，并获得修正的每步角增量。利用此结果推导隐式中点法在总时间 $T$ 上的长时相位误差表达式。\n\n2. 对于经典的显式四阶 Runge–Kutta 方法（四阶 Runge–Kutta），通过在生成元上评估其稳定性多项式，计算其应用于相同线性系统的单步映射。将每步角增量确定为在纯虚数步长参数下评估的稳定性函数的复自变量。利用此结果推导在总时间 $T$ 上的长时相位误差。\n\n3. 将相位误差定义为数值累积相位与精确累积相位 $ \\Omega T $ 之差在 $[-\\pi,\\pi]$ 内的主值（角度单位为弧度）。具体来说，如果 $\\theta_{\\text{num}}$ 是时间 $T$ 后的总数值相位，则相位误差为包裹角\n$$\n\\Delta\\phi = \\mathrm{wrap}\\!\\left(\\theta_{\\text{num}} - \\Omega T\\right),\n$$\n其中 $\\mathrm{wrap}(\\phi) = \\left((\\phi + \\pi) \\bmod 2\\pi\\right) - \\pi$。\n\n4. 实现一个完整的、可运行的程序，对给定的测试集，计算每种情况下的三个量：\n   - BEA 预测的隐式中点法的长时相位误差，\n   - 隐式中点法的数值累积长时相位误差（使用推导的每步角增量），\n   - 四阶 Runge–Kutta 方法的数值累积长时相位误差（使用其稳定性函数的复自变量）。\n   所有角度必须以弧度为单位。\n\n使用以下测试集，它涵盖了一般情况、精细时间步长方案以及逐渐变粗的方案，以探究长时行为：\n- 物理参数（所有情况均恒定）：$q = 1.602\\times 10^{-19}$ 库仑，$m = 3.34358\\times 10^{-27}$ 千克，$B = 3.5$ 特斯拉。\n- 根据这些参数，计算 $\\Omega = \\frac{qB}{m}$ 和回旋周期 $T_c = \\frac{2\\pi}{\\Omega}$。\n- 情况由每个周期的步数 $N_p$ 和要模拟的周期数 $N_{\\text{per}}$ 指定：\n  1. 情况 A（理想路径）：$N_p = 64$, $N_{\\text{per}} = 1000$。\n  2. 情况 B（精细步长，极长时间）：$N_p = 128$, $N_{\\text{per}} = 50000$。\n  3. 情况 C（中等粗糙）：$N_p = 8$, $N_{\\text{per}} = 2000$。\n  4. 情况 D（粗糙，接近非辛伪影可见的边缘）：$N_p = 4$, $N_{\\text{per}} = 500$。\n\n对于每种情况，计算时间步长 $h = \\frac{T_c}{N_p}$、总时间 $T = N_{\\text{per}}\\,T_c$ 和整数步数 $N = \\frac{T}{h} = N_{\\text{per}}\\,N_p$。角度必须以弧度为单位。\n\n你的程序应该生成单行输出，其中包含一个由四个子列表组成的逗号分隔列表的结果，每个子列表对应一个测试用例，并按指定顺序包含三个相位误差。例如，格式必须是\n$$\n[\\,[e_{A,\\mathrm{BEA}},e_{A,\\mathrm{IM}},e_{A,\\mathrm{RK4}}],\\,[e_{B,\\mathrm{BEA}},e_{B,\\mathrm{IM}},e_{B,\\mathrm{RK4}}],\\,[e_{C,\\mathrm{BEA}},e_{C,\\mathrm{IM}},e_{C,\\mathrm{RK4}}],\\,[e_{D,\\mathrm{BEA}},e_{D,\\mathrm{IM}},e_{D,\\mathrm{RK4}}]\\,],\n$$\n其中所有数值量均以弧度为单位。最终输出必须是这种方括号逗号分隔格式的单行文本，并且所有条目都必须是浮点数（不打印单位，但根据问题定义，角度以弧度为单位）。",
            "solution": "用户提供的问题陈述具有科学依据，提法恰当，客观完整。这是计算物理和数值分析中的一个标准问题，侧重于哈密顿系统的几何积分算法的性质。该问题是有效的，可以按所述方式解决。\n\n该问题要求分析和计算两种数值方法——辛隐式中点法和显式四阶 Runge–Kutta (RK4) 方法——应用于均匀磁场中带电粒子平面回旋运动时的相位误差。速度 $\\mathbf{v} \\in \\mathbb{R}^2$ 的控制方程是线性哈密顿系统：\n$$\n\\frac{d\\mathbf{v}}{dt} = \\Omega J \\mathbf{v},\n$$\n其中 $\\Omega = \\frac{qB}{m}$ 是回旋频率，而 $J = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$ 是标准辛矩阵。精确解是速度平面上的一个旋转，由 $\\mathbf{v}(t) = e^{t\\Omega J} \\mathbf{v}(0)$ 给出，其中 $e^{t\\Omega J} = \\begin{pmatrix} \\cos(\\Omega t)  \\sin(\\Omega t) \\\\ -\\sin(\\Omega t)  \\cos(\\Omega t) \\end{pmatrix}$。在时间 $T$ 内累积的总相位为 $\\theta_{\\text{exact}} = \\Omega T$。\n\n**1. 隐式中点法分析**\n\n对于常微分方程 (ODE) $\\frac{d\\mathbf{y}}{dt} = f(\\mathbf{y})$，隐式中点法由下式给出：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h f\\left(\\frac{\\mathbf{y}_n + \\mathbf{y}_{n+1}}{2}\\right),\n$$\n其中 $h$ 是时间步长。对于我们的线性系统 $f(\\mathbf{v}) = \\Omega J \\mathbf{v}$，这变为：\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + h \\Omega J \\left(\\frac{\\mathbf{v}_n + \\mathbf{v}_{n+1}}{2}\\right).\n$$\n为求单步映射 $\\mathbf{v}_{n+1} = S_{\\text{IM}} \\mathbf{v}_n$，我们求解 $\\mathbf{v}_{n+1}$：\n$$\n\\left(I - \\frac{h\\Omega}{2}J\\right) \\mathbf{v}_{n+1} = \\left(I + \\frac{h\\Omega}{2}J\\right) \\mathbf{v}_n.\n$$\n$$\nS_{\\text{IM}} = \\left(I - \\frac{h\\Omega}{2}J\\right)^{-1} \\left(I + \\frac{h\\Omega}{2}J\\right).\n$$\n该表达式是矩阵 $\\frac{h\\Omega J}{2}$ 的凯莱变换。由于 $\\Omega J$ 是一个斜对称矩阵，映射 $S_{\\text{IM}}$ 是正交的，并保持二次不变量 $\\mathbf{v}^T\\mathbf{v}$（动能），因此它是一个辛映射。它表示通过某个数值角度 $\\theta_{\\text{step,IM}}$ 的精确旋转。\n\n为求此角度，我们分析该映射的特征值。生成元矩阵 $\\Omega J$ 的特征值为 $\\pm i\\Omega$。单步映射 $S_{\\text{IM}}$ 的特征值通过将凯莱变换作为标量函数 $c(\\lambda) = \\frac{1+\\lambda/2}{1-\\lambda/2}$ 应用于 $h\\Omega J$ 的特征值（即 $\\pm i h\\Omega$）来得到。令 $\\alpha = h\\Omega$。$S_{\\text{IM}}$ 的特征值为：\n$$\n\\lambda_{\\text{IM}} = \\frac{1 + i\\alpha/2}{1 - i\\alpha/2}.\n$$\n这是一个单位圆上的复数，我们可以写成 $e^{i\\theta_{\\text{step,IM}}}$。每步角增量是该特征值的自变量：\n$$\n\\theta_{\\text{step,IM}} = \\arg\\left(\\frac{1 + i\\alpha/2}{1 - i\\alpha/2}\\right) = 2 \\arctan\\left(\\frac{\\alpha}{2}\\right).\n$$\n经过 $N$ 步后累积的总数值相位为 $\\theta_{\\text{num,IM}} = N \\theta_{\\text{step,IM}}$。相对于精确相位 $\\Omega T = N\\alpha$ 的相位误差为 $\\Delta\\phi_{\\text{IM}} = \\mathrm{wrap}(N\\theta_{\\text{step,IM}} - N\\alpha)$。\n\n辛方法的后向误差分析（BEA）断言，数值流是某个修正哈密顿量的精确流。这意味着数值解根据一个修正频率 $\\tilde{\\Omega}$ 演化。修正频率的定义是，使用该频率在一个步长 $h$ 内的精确演化与数值角增量相匹配：$\\tilde{\\Omega} h = \\theta_{\\text{step,IM}}$。\n$$\n\\tilde{\\Omega} = \\frac{\\theta_{\\text{step,IM}}}{h} = \\frac{2}{h} \\arctan\\left(\\frac{h\\Omega}{2}\\right) = \\frac{2}{h} \\arctan\\left(\\frac{\\alpha}{2}\\right).\n$$\nBEA 预测的在总时间 $T$ 上的相位误差是使用修正频率累积的总相位与使用精确频率累积的总相位之差：\n$$\n\\Delta\\phi_{\\text{BEA}} = \\mathrm{wrap}(\\tilde{\\Omega}T - \\Omega T) = \\mathrm{wrap}((\\tilde{\\Omega} - \\Omega)T).\n$$\n代入 $T=Nh$ 和 $\\tilde{\\Omega}$ 的表达式，我们发现：\n$$\n(\\tilde{\\Omega} - \\Omega)T = \\left(\\frac{2}{h} \\arctan\\left(\\frac{\\alpha}{2}\\right) - \\Omega\\right)Nh = N\\left(2\\arctan\\left(\\frac{\\alpha}{2}\\right) - \\Omega h\\right) = N(\\theta_{\\text{step,IM}} - \\alpha).\n$$\n因此，BEA 预测的相位误差和直接计算的数值相位误差是相同的表达式，这与预期相符。\n\n**2. 四阶 Runge–Kutta 方法分析**\n\n对于线性常微分方程 $\\frac{d\\mathbf{y}}{dt} = A\\mathbf{y}$，一个 Runge-Kutta 方法产生单步映射 $\\mathbf{y}_{n+1} = R(hA)\\mathbf{y}_n$，其中 $R(z)$ 是该方法的稳定性函数。对于经典的四阶 Runge-Kutta (RK4) 方法，其稳定性函数是指数函数到 4 次项的截断泰勒级数：\n$$\nR(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}.\n$$\n我们系统的单步映射是 $\\mathbf{v}_{n+1} = R(h\\Omega J)\\mathbf{v}_n$。本征模式的演化由该映射的特征值决定，即 $R(\\pm i h\\Omega)$。令 $\\alpha = h\\Omega$。我们计算 $R(i\\alpha)$：\n$$\nR(i\\alpha) = 1 + (i\\alpha) + \\frac{(i\\alpha)^2}{2} + \\frac{(i\\alpha)^3}{6} + \\frac{(i\\alpha)^4}{24} = \\left(1 - \\frac{\\alpha^2}{2} + \\frac{\\alpha^4}{24}\\right) + i\\left(\\alpha - \\frac{\\alpha^3}{6}\\right).\n$$\n该方法不是辛方法；对于 $\\alpha \\neq 0$，模 $|R(i\\alpha)|$ 并不恒等于 $1$。每步角增量是 $R(i\\alpha)$ 的复自变量：\n$$\n\\theta_{\\text{step,RK4}} = \\arg(R(i\\alpha)) = \\mathrm{atan2}\\left(\\alpha - \\frac{\\alpha^3}{6}, 1 - \\frac{\\alpha^2}{2} + \\frac{\\alpha^4}{24}\\right).\n$$\n经过 $N$ 步后累积的总数值相位为 $\\theta_{\\text{num,RK4}} = N \\theta_{\\text{step,RK4}}$。相位误差为：\n$$\n\\Delta\\phi_{\\text{RK4}} = \\mathrm{wrap}(\\theta_{\\text{num,RK4}} - \\Omega T) = \\mathrm{wrap}(N(\\theta_{\\text{step,RK4}} - \\alpha)).\n$$\n\n**3. 计算公式摘要**\n\n对于由 ($N_p$, $N_{\\text{per}}$) 定义的每个测试用例：\n- 时间步长参数：$\\alpha = h\\Omega = (\\frac{T_c}{N_p})\\Omega = (\\frac{2\\pi/\\Omega}{N_p})\\Omega = \\frac{2\\pi}{N_p}$。\n- 总步数：$N = N_p N_{\\text{per}}$。\n- 相位误差定义：$\\mathrm{wrap}(\\phi) = ((\\phi + \\pi) \\pmod{2\\pi}) - \\pi$。\n- 隐式中点法（BEA 和数值）相位误差：\n$$\ne_{\\text{IM}} = \\mathrm{wrap}\\left(N \\left(2\\arctan\\left(\\frac{\\alpha}{2}\\right) - \\alpha\\right)\\right).\n$$\n- 四阶 Runge-Kutta 相位误差：\n$$\ne_{\\text{RK4}} = \\mathrm{wrap}\\left(N \\left(\\mathrm{atan2}\\left(\\alpha - \\frac{\\alpha^3}{6}, 1 - \\frac{\\alpha^2}{2} + \\frac{\\alpha^4}{24}\\right) - \\alpha\\right)\\right).\n$$\n这些公式在所提供的程序中被直接实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and prints the phase errors for numerical integrators applied to\n    charged particle gyromotion, as specified in the problem statement.\n    \"\"\"\n\n    # Physical parameters\n    q = 1.602e-19  # Charge in Coulombs\n    m = 3.34358e-27  # Mass in kilograms (Deuteron)\n    B = 3.5  # Magnetic field in Tesla\n\n    # Derived physical quantities\n    Omega = (q * B) / m  # Cyclotron frequency in rad/s\n\n    # Test cases: (Number of steps per period, Number of periods)\n    test_cases = [\n        (64, 1000),      # Case A\n        (128, 50000),    # Case B\n        (8, 2000),       # Case C\n        (4, 500),        # Case D\n    ]\n\n    # Wrapper function to map an angle to the interval [-pi, pi]\n    def wrap_angle(phi):\n        return ((phi + np.pi) % (2 * np.pi)) - np.pi\n\n    all_results = []\n    \n    for case in test_cases:\n        Np, Nper = case\n        \n        # Total number of steps\n        N = Np * Nper\n        \n        # Dimensionless step size parameter a = h*Omega\n        # h = Tc / Np = (2*pi/Omega) / Np = 2*pi / (Omega * Np)\n        # a = h * Omega = 2*pi / Np\n        alpha = 2 * np.pi / Np\n\n        # --- 1. Implicit Midpoint (IM) Method Phase Error ---\n        # The BEA-predicted error and the numerically accumulated error are\n        # mathematically identical for this problem.\n        \n        # Per-step angular increment for IM\n        theta_step_im = 2 * np.arctan(alpha / 2)\n        \n        # Total difference in accumulated angle over N steps\n        # This is N * (numerical_angle_per_step - exact_angle_per_step)\n        total_phase_diff_im = N * (theta_step_im - alpha)\n        \n        # Wrap the final error to [-pi, pi]\n        error_im = wrap_angle(total_phase_diff_im)\n        error_bea = error_im  # As derived, they are the same\n\n        # --- 2. Fourth-Order Runge-Kutta (RK4) Method Phase Error ---\n        \n        # Real and imaginary parts of the stability function R(i*alpha)\n        # R(z) = 1 + z + z^2/2 + z^3/6 + z^4/24\n        # R(i*a) = (1 - a^2/2 + a^4/24) + i*(a - a^3/6)\n        rk4_re = 1 - (alpha**2) / 2 + (alpha**4) / 24\n        rk4_im = alpha - (alpha**3) / 6\n        \n        # Per-step angular increment for RK4 is the argument of R(i*alpha)\n        theta_step_rk4 = np.arctan2(rk4_im, rk4_re)\n        \n        # Total difference in accumulated angle over N steps\n        total_phase_diff_rk4 = N * (theta_step_rk4 - alpha)\n        \n        # Wrap the final error to [-pi, pi]\n        error_rk4 = wrap_angle(total_phase_diff_rk4)\n\n        all_results.append([error_bea, error_im, error_rk4])\n\n    # Format the final output string exactly as specified.\n    # The output should be a single line: [[...],[...],[...],[...]]\n    result_str = \"[\" + ','.join([f\"[{e[0]},{e[1]},{e[2]}]\" for e in all_results]) + \"]\"\n    \n    print(result_str)\n\nsolve()\n```"
        }
    ]
}