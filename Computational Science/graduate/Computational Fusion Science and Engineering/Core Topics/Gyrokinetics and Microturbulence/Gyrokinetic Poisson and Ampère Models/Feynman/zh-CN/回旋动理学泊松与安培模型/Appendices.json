{
    "hands_on_practices": [
        {
            "introduction": "回旋动理学模型是建立在一系列特定尺度排序之上的简化模型。掌握这些模型的关键一步是理解如何简化麦克斯韦方程组。本练习  将引导你通过定量分析，证明在低频极限下为何通常可以忽略安培定律中的位移电流项，这是许多回旋动理学模拟（尤其是静电和磁静模型）的基础。",
            "id": "3988909",
            "problem": "一个均匀、磁化的准中性等离子体，处于均匀平衡磁场 $\\mathbf{B}_0$ 中，该系统可用低频回旋动理学级数来描述。其特征涨落频率 $\\omega$ 满足 $\\omega \\ll \\Omega_i$（离子回旋频率）。考虑一个具有平行电场 $E_\\parallel(t) = \\Re\\{E_0 \\exp(-\\mathrm{i}\\,\\omega t)\\}$ 且碰撞可忽略的单一线性平面波微扰。假设：\n- 在涨落时间尺度上，离子对平行传导电流的贡献可以忽略，\n- 电子对平行传导电流的贡献占主导地位，并且可以用冷电子平行动量方程（忽略电子压力梯度和碰撞）来建模，\n- 系统采用国际单位制，位移电流是麦克斯韦-安培定律中的 $\\epsilon_0\\,\\partial_t E_\\parallel$ 项。\n\n从麦克斯韦-安培定律和冷电子平行动量方程出发，仅使用基本常数和定义，推导比值\n$$\n\\mathcal{R} \\equiv \\frac{\\left|\\epsilon_0\\,\\partial_t E_\\parallel\\right|}{\\left|J_\\parallel\\right|}\n$$\n的解析估计，并仅用 $\\omega$ 和电子等离子体频率 $\\omega_{pe}$ 表示。\n\n您必须清楚地陈述您使用的任何中间关系以及在回旋动理学级数下证明其合理性的假设。请以 $\\omega$ 和 $\\omega_{pe}$ 的单个闭合形式表达式给出您的最终答案。不需要进行数值计算，最终表达式中也不应包含单位。答案必须是单个表达式，而不是不等式或方程。",
            "solution": "该问题被验证为自洽、有科学依据且良定的。推导过程直接源于所给出的物理定律和定义。\n\n目标是计算比值 $\\mathcal{R} \\equiv \\frac{\\left|\\epsilon_0\\,\\partial_t E_\\parallel\\right|}{\\left|J_\\parallel\\right|}$，其中分子表示位移电流密度的平行分量的幅值，分母表示传导电流密度的平行分量的幅值。我们考虑的是具有谐波时间依赖性的单一线性平面波微扰，因此任何微扰量 $Q(t)$ 都可以表示为 $Q(t) = \\Re\\{Q_0 \\exp(-\\mathrm{i}\\,\\omega t)\\}$。在复数表示法中，这意味着时间导数算子可以替换为 $\\frac{\\partial}{\\partial t} \\to -\\mathrm{i}\\,\\omega$。\n\n首先，我们计算分子，即平行位移电流密度项 $\\epsilon_0\\,\\partial_t E_\\parallel$ 的幅值。应用谐波时间依赖性替换：\n$$\n\\epsilon_0 \\frac{\\partial E_\\parallel}{\\partial t} = \\epsilon_0 (-\\mathrm{i}\\,\\omega E_\\parallel) = -\\mathrm{i}\\,\\omega \\epsilon_0 E_\\parallel\n$$\n因此，其幅值为：\n$$\n\\left|\\epsilon_0\\,\\partial_t E_\\parallel\\right| = |-\\mathrm{i}\\,\\omega \\epsilon_0 E_\\parallel| = \\omega \\epsilon_0 |E_\\parallel|\n$$\n\n接下来，我们计算分母，即平行传导电流密度 $|J_\\parallel|$ 的幅值。问题陈述指出，离子的贡献可以忽略，因此平行电流由电子的贡献主导，$J_\\parallel \\approx J_{e\\parallel}$。电子电流密度定义为 $J_{e\\parallel} = -n_e e v_{e\\parallel}$，其中 $-e$ 是电子电荷，$n_e$ 是电子数密度，$v_{e\\parallel}$ 是平行电子流体速度。在线性微扰的背景下，对于密度为 $n_0$ 的静态均匀平衡态，我们有：\n$$\nJ_\\parallel = -n_0 e v_{e\\parallel}\n$$\n\n为了求得 $v_{e\\parallel}$，我们使用问题陈述中指定的冷电子平行动量方程，忽略电子压力和碰撞。该方程的线性化形式为：\n$$\nm_e \\frac{\\partial v_{e\\parallel}}{\\partial t} = -e E_\\parallel\n$$\n其中 $m_e$ 是电子质量。我们已经从两边消去了恒定的平衡密度 $n_0$。应用谐波时间依赖性替换 $\\frac{\\partial}{\\partial t} \\to -\\mathrm{i}\\,\\omega$：\n$$\nm_e (-\\mathrm{i}\\,\\omega) v_{e\\parallel} = -e E_\\parallel\n$$\n求解平行速度 $v_{e\\parallel}$ 的复振幅，用电场 $E_\\parallel$ 表示：\n$$\nv_{e\\parallel} = \\frac{-e E_\\parallel}{-\\mathrm{i}\\,\\omega m_e} = \\frac{e}{\\mathrm{i}\\,\\omega m_e} E_\\parallel\n$$\n\n现在，我们将 $v_{e\\parallel}$ 的这个表达式代回到平行电流密度 $J_\\parallel$ 的方程中：\n$$\nJ_\\parallel = -n_0 e v_{e\\parallel} = -n_0 e \\left( \\frac{e}{\\mathrm{i}\\,\\omega m_e} E_\\parallel \\right) = -\\frac{n_0 e^2}{\\mathrm{i}\\,\\omega m_e} E_\\parallel\n$$\n为了用电子等离子体频率 $\\omega_{pe}$ 来表示，我们使用其定义：$\\omega_{pe}^2 \\equiv \\frac{n_0 e^2}{\\epsilon_0 m_e}$。这意味着 $n_0 e^2 / m_e = \\epsilon_0 \\omega_{pe}^2$。将此代入 $J_\\parallel$ 的表达式中：\n$$\nJ_\\parallel = -\\frac{\\epsilon_0 \\omega_{pe}^2}{\\mathrm{i}\\,\\omega} E_\\parallel = \\mathrm{i} \\frac{\\epsilon_0 \\omega_{pe}^2}{\\omega} E_\\parallel\n$$\n那么，平行传导电流的幅值为：\n$$\n|J_\\parallel| = \\left| \\mathrm{i} \\frac{\\epsilon_0 \\omega_{pe}^2}{\\omega} E_\\parallel \\right| = \\frac{\\epsilon_0 \\omega_{pe}^2}{\\omega} |E_\\parallel|\n$$\n\n最后，我们使用推导出的位移电流和传导电流的幅值来组合比值 $\\mathcal{R}$：\n$$\n\\mathcal{R} = \\frac{\\left|\\epsilon_0\\,\\partial_t E_\\parallel\\right|}{\\left|J_\\parallel\\right|} = \\frac{\\omega \\epsilon_0 |E_\\parallel|}{\\frac{\\epsilon_0 \\omega_{pe}^2}{\\omega} |E_\\parallel|}\n$$\n$\\epsilon_0 |E_\\parallel|$ 项相互抵消，得到最终表达式：\n$$\n\\mathcal{R} = \\frac{\\omega}{\\frac{\\omega_{pe}^2}{\\omega}} = \\frac{\\omega^2}{\\omega_{pe}^2}\n$$\n这个结果仅用涨落频率 $\\omega$ 和电子等离子体频率 $\\omega_{pe}$ 表示，符合要求。",
            "answer": "$$\n\\boxed{\\frac{\\omega^{2}}{\\omega_{pe}^{2}}}\n$$"
        },
        {
            "introduction": "一旦确定了模型的控制方程（如回旋动理学泊松方程），就必须将其离散化以便进行计算机模拟。本练习  探讨了模型中的一个核心项——长波长极化密度项 $\\nabla_{\\perp}^2 \\phi$ 的数值特性。通过比较“完美”的谱方法表示与实用的有限差分格式，本练习引入了数值色散的概念，并让你亲手推导它，从而深刻理解数值方法如何影响物理结果的准确性。",
            "id": "3988929",
            "problem": "考虑一个位于周期性平板中的均匀、磁化的准中性等离子体，其背景磁场大小恒为 $B_0$，方向沿 $\\hat{\\boldsymbol{z}}$。在回旋动理学理论的长波极限下，静电准中性闭合包含垂直极化项 $-\\sum_{s} \\frac{n_{0s} m_s}{B_0^2} \\nabla_{\\perp}^2 \\phi$，其中 $n_{0s}$ 和 $m_s$ 分别表示粒子种类 $s$ 的平衡密度和质量，而 $\\phi$ 是静电势。假设在坐标 $(x,y)$ 中为二维垂直动力学，区域长度为 $L_x$ 和 $L_y$，并在两个方向上施加周期性边界条件。\n\n要求您比较垂直极化算子 $-\\sum_{s} \\frac{n_{0s} m_s}{B_0^2} \\nabla_{\\perp}^2 \\phi$ 作用于单一傅里叶模式 $\\phi(x,y) = \\Re\\{\\Phi \\exp(i k_x x + i k_y y)\\}$ 时的两种数值离散化方法，其中波数 $k_x$ 和 $k_y$ 为实数。\n\n- 谱方法离散化：在傅里叶表示中，垂直拉普拉斯算子作用于平面波返回连续谱本征值 $-(k_x^2 + k_y^2)$。\n- 有限差分离散化：在一个均匀网格上，$x$ 和 $y$ 方向分别有 $N_x$ 和 $N_y$ 个点，定义网格间距 $h_x = L_x/N_x$ 和 $h_y = L_y/N_y$。用标准的二阶中心差分来近似二阶导数，\n$$\n\\left.\\frac{\\partial^2 \\phi}{\\partial x^2}\\right|_{j,l} \\approx \\frac{\\phi_{j+1,l} - 2 \\phi_{j,l} + \\phi_{j-1,l}}{h_x^2}, \\quad\n\\left.\\frac{\\partial^2 \\phi}{\\partial y^2}\\right|_{j,l} \\approx \\frac{\\phi_{j,l+1} - 2 \\phi_{j,l} + \\phi_{j,l-1}}{h_y^2},\n$$\n其中 $(j,l)$ 是网格点 $(x_j, y_l) = (j h_x, l h_y)$ 的索引，整数 $j \\in [0, N_x-1]$ 且 $l \\in [0, N_y-1]$，而 $\\phi_{j,l} = \\Re\\{\\Phi \\exp(i k_x x_j + i k_y y_l)\\}$。\n\n从上述连续和离散算子的基本定义出发，推导作用于平面波的有限差分拉普拉斯算子的离散傅里叶符号（本征值），并用它来定义数值色散因子 $\\mathcal{D}(k_x, k_y; h_x, h_y)$，其定义为有限差分极化算子本征值与谱（连续）极化算子本征值作用于同一平面波时的比率。将 $\\mathcal{D}(k_x, k_y; h_x, h_y)$ 表示为仅含 $k_x$、$k_y$、$h_x$ 和 $h_y$ 的单一闭式解析表达式。\n\n只需报告 $\\mathcal{D}(k_x, k_y; h_x, h_y)$ 的表达式。无需进行数值计算。",
            "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据，问题设定良好，客观，并包含足够的信息以获得唯一解。\n\n任务是推导数值色散因子 $\\mathcal{D}(k_x, k_y; h_x, h_y)$，它被定义为有限差分极化算子的本征值与谱（连续）极化算子的本征值在作用于单一傅里叶模式 $\\phi(x,y) = \\Re\\{\\Phi \\exp(i k_x x + i k_y y)\\}$ 时的比率。\n\n垂直极化算子由 $P = -\\sum_{s} \\frac{n_{0s} m_s}{B_0^2} \\nabla_{\\perp}^2$ 给出。我们定义常数系数为 $C_p = \\sum_{s} \\frac{n_{0s} m_s}{B_0^2}$，它是正定的。那么算子为 $P = -C_p \\nabla_{\\perp}^2$，其中 $\\nabla_{\\perp}^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$。\n\n由于算子 $P$ 是一个线性的实值微分算子，它作用于一个复函数的实部等于它作用于该复函数后结果的实部。即，$P(\\Re\\{f\\}) = \\Re\\{P(f)\\}$。此外，如果得到的本征值是实数，那么本征函数的实部也是具有相同本征值的本征函数。因此，我们可以通过处理复指数函数 $\\phi_c(x,y) = \\Phi \\exp(i k_x x + i k_y y)$ 来简化分析，其中 $\\phi(x,y) = \\Re\\{\\phi_c(x,y)\\}$。\n\n首先，我们确定连续谱极化算子的本征值 $\\Lambda_{cont}$。我们将垂直拉普拉斯算子 $\\nabla_{\\perp}^2$ 应用于复势 $\\phi_c(x,y)$：\n$$\n\\nabla_{\\perp}^2 \\phi_c = \\left(\\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}\\right) \\left[ \\Phi \\exp(i k_x x + i k_y y) \\right]\n$$\n偏导数为：\n$$\n\\frac{\\partial^2}{\\partial x^2} \\phi_c = \\frac{\\partial}{\\partial x} (i k_x \\phi_c) = (i k_x)^2 \\phi_c = -k_x^2 \\phi_c\n$$\n$$\n\\frac{\\partial^2}{\\partial y^2} \\phi_c = \\frac{\\partial}{\\partial y} (i k_y \\phi_c) = (i k_y)^2 \\phi_c = -k_y^2 \\phi_c\n$$\n将这些结果相加，我们得到拉普拉斯算子的作用：\n$$\n\\nabla_{\\perp}^2 \\phi_c = (-k_x^2 - k_y^2) \\phi_c = -(k_x^2 + k_y^2) \\phi_c\n$$\n因此，连续谱拉普拉斯算子 $\\nabla_{\\perp}^2$ 的本征值为 $\\lambda_{cont} = -(k_x^2 + k_y^2)$。连续谱极化算子为 $P_{cont} = -C_p \\nabla_{\\perp}^2$。其本征值 $\\Lambda_{cont}$ 为：\n$$\n\\Lambda_{cont} = -C_p \\lambda_{cont} = C_p (k_x^2 + k_y^2)\n$$\n\n接下来，我们确定极化算子的有限差分离散化的本征值 $\\Lambda_{FD}$。离散算子作用于在网格点 $(x_j, y_l) = (j h_x, l h_y)$ 上计算的势，记为 $\\phi_{j,l}$。网格上的复势为 $\\phi_{c,j,l} = \\Phi \\exp(i k_x x_j + i k_y y_l)$。拉普拉斯算子的有限差分近似 $\\nabla_{FD}^2$ 由下式给出：\n$$\n\\nabla_{FD}^2 \\phi_{j,l} = \\frac{\\phi_{j+1,l} - 2\\phi_{j,l} + \\phi_{j-1,l}}{h_x^2} + \\frac{\\phi_{j,l+1} - 2\\phi_{j,l} + \\phi_{j,l-1}}{h_y^2}\n$$\n我们计算该离散算子对 $\\phi_{c,j,l}$ 的作用。首先分析对应于 $x$ 导数的项：\n$$\n\\frac{\\phi_{c,j+1,l} - 2\\phi_{c,j,l} + \\phi_{c,j-1,l}}{h_x^2}\n$$\n我们使用关系式 $\\phi_{c,j\\pm 1,l} = \\Phi \\exp(i k_x (j\\pm 1) h_x + i k_y l h_y) = \\phi_{c,j,l} \\exp(\\pm i k_x h_x)$。将这些代入表达式中得到：\n$$\n\\frac{\\phi_{c,j,l}\\exp(i k_x h_x) - 2\\phi_{c,j,l} + \\phi_{c,j,l}\\exp(-i k_x h_x)}{h_x^2} = \\frac{\\phi_{c,j,l}}{h_x^2} \\left[ \\exp(i k_x h_x) + \\exp(-i k_x h_x) - 2 \\right]\n$$\n使用欧拉恒等式 $\\exp(i\\theta) + \\exp(-i\\theta) = 2\\cos(\\theta)$，表达式变为：\n$$\n\\frac{\\phi_{c,j,l}}{h_x^2} [2\\cos(k_x h_x) - 2] = \\frac{2\\phi_{c,j,l}}{h_x^2} [\\cos(k_x h_x) - 1]\n$$\n使用三角恒等式 $\\cos(\\theta) - 1 = -2\\sin^2(\\theta/2)$，我们得到：\n$$\n\\frac{2\\phi_{c,j,l}}{h_x^2} \\left[ -2\\sin^2\\left(\\frac{k_x h_x}{2}\\right) \\right] = -\\frac{4}{h_x^2}\\sin^2\\left(\\frac{k_x h_x}{2}\\right) \\phi_{c,j,l}\n$$\n通过对 $y$ 导数项执行相同的过程，我们发现：\n$$\n\\frac{\\phi_{c,j,l+1} - 2\\phi_{c,j,l} + \\phi_{c,j,l-1}}{h_y^2} = -\\frac{4}{h_y^2}\\sin^2\\left(\\frac{k_y h_y}{2}\\right) \\phi_{c,j,l}\n$$\n将各项相加，离散拉普拉斯算子对 $\\phi_{c,j,l}$ 的作用是：\n$$\n\\nabla_{FD}^2 \\phi_{c,j,l} = \\left[ -\\frac{4}{h_x^2}\\sin^2\\left(\\frac{k_x h_x}{2}\\right) - \\frac{4}{h_y^2}\\sin^2\\left(\\frac{k_y h_y}{2}\\right) \\right] \\phi_{c,j,l}\n$$\n因此，有限差分拉普拉斯算子的本征值 $\\lambda_{FD}$ 是：\n$$\n\\lambda_{FD} = -\\left[ \\frac{4}{h_x^2}\\sin^2\\left(\\frac{k_x h_x}{2}\\right) + \\frac{4}{h_y^2}\\sin^2\\left(\\frac{k_y h_y}{2}\\right) \\right]\n$$\n有限差分极化算子为 $P_{FD} = -C_p \\nabla_{FD}^2$。其本征值 $\\Lambda_{FD}$ 为：\n$$\n\\Lambda_{FD} = -C_p \\lambda_{FD} = C_p \\left[ \\frac{4}{h_x^2}\\sin^2\\left(\\frac{k_x h_x}{2}\\right) + \\frac{4}{h_y^2}\\sin^2\\left(\\frac{k_y h_y}{2}\\right) \\right]\n$$\n\n最后，我们计算数值色散因子 $\\mathcal{D}(k_x, k_y; h_x, h_y)$，即 $\\Lambda_{FD}$ 与 $\\Lambda_{cont}$ 的比率：\n$$\n\\mathcal{D}(k_x, k_y; h_x, h_y) = \\frac{\\Lambda_{FD}}{\\Lambda_{cont}} = \\frac{C_p \\left[ \\frac{4}{h_x^2}\\sin^2\\left(\\frac{k_x h_x}{2}\\right) + \\frac{4}{h_y^2}\\sin^2\\left(\\frac{k_y h_y}{2}\\right) \\right]}{C_p (k_x^2 + k_y^2)}\n$$\n常数系数 $C_p$ 被消去，得到数值色散因子的最终表达式：\n$$\n\\mathcal{D}(k_x, k_y; h_x, h_y) = \\frac{\\frac{4}{h_x^2}\\sin^2\\left(\\frac{k_x h_x}{2}\\right) + \\frac{4}{h_y^2}\\sin^2\\left(\\frac{k_y h_y}{2}\\right)}{k_x^2 + k_y^2}\n$$",
            "answer": "$$\n\\boxed{\\frac{\\frac{4}{h_x^2}\\sin^2\\left(\\frac{k_x h_x}{2}\\right) + \\frac{4}{h_y^2}\\sin^2\\left(\\frac{k_y h_y}{2}\\right)}{k_x^2 + k_y^2}}\n$$"
        },
        {
            "introduction": "回旋平均是模型中引入有限拉莫尔半径（FLR）效应的物理机制，它并非一个简单的微分算子，而是一个积分算子。本练习  是一个直接的计算任务：将回旋平均算子实现为一个离散的数值积分，并对照已知的解析结果（即零阶贝塞尔函数 $J_0$）来验证其准确性。这个过程是开发可靠的回旋动理学代码的核心步骤，确保了物理效应被精确地转化为计算算法。",
            "id": "3988923",
            "problem": "探讨回旋相位平均在计算聚变科学与工程中推导回旋动理学泊松模型和安培模型时的作用。在强而均匀的磁场中，洛伦兹力使带电粒子围绕磁力线进行快速的圆周运动，从而在由粒子种类回旋半径决定的环上对场进行采样。回旋平均算子作用于一个标量场，其方式是在固定的导心位置上，对该场在粒子的拉莫尔轨道上进行平均。这一操作是垂直波数耦合如何进入回旋动理学泊松方程以及平行电流响应如何进入回旋动理学安培定律的基础。\n\n请实现一个离散的、实空间求积近似的回旋平均算子，该算子作用于一个具有垂直波数大小的单色平面波。此实现必须使用对回旋相角（以弧度表示）的均匀求积。设平面波表示为形式为 $e^{\\mathrm{i} \\boldsymbol{k}_\\perp \\cdot \\boldsymbol{r}}$ 的复数场，其中 $\\boldsymbol{k}_\\perp$ 与 $x$ 轴对齐，导心固定在原点。离散回旋平均必须计算为在以原点为中心、半径为 $\\rho_s$ 的圆上 $N_\\theta$ 个等距点的均匀平均。实空间求积应直接在环上的点采样场值并对这些值进行平均。\n\n验证目标是，对于所选的单色场和所述几何结构，离散回旋平均能够在指定的容差范围内，再现预期的零阶贝塞尔因子，该因子是无量纲参数 $k_\\perp \\rho_s$ 的函数。角度必须以弧度为单位，所有量均为无量纲。程序必须为每个测试用例计算离散求积结果与参考零阶贝塞尔函数求值之间的绝对误差，然后将此误差与测试用例特定的容差进行比较，以确定布尔验证结果。\n\n使用以下测试套件，涵盖 $k_\\perp \\rho_s$ 的小、中、大值，以及粗略和精细的求积分辨率，以探测收敛性和边界条件：\n- 测试用例 1：$k_\\perp = 0.2$，$\\rho_s = 0.5$， $N_\\theta = 64$，容差 $= 10^{-12}$。\n- 测试用例 2：$k_\\perp = 3.0$，$\\rho_s = 1.0$， $N_\\theta = 128$，容差 $= 10^{-10}$。\n- 测试用例 3：$k_\\perp = 10.0$，$\\rho_s = 2.0$， $N_\\theta = 1024$，容差 $= 10^{-8}$。\n- 测试用例 4：$k_\\perp = 5.0$，$\\rho_s = 1.0$， $N_\\theta = 4$，容差 $= 10^{-6}$。\n- 测试用例 5：$k_\\perp = 0.0$，$\\rho_s = 1.0$， $N_\\theta = 16$，容差 $= 10^{-15}$。\n- 测试用例 6：$k_\\perp = 3.0$，$\\rho_s = 1.0$， $N_\\theta = 2048$，容差 $= 10^{-13}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”）。每个结果必须是一个布尔值，指示该测试用例的绝对误差是否小于或等于指定的容差。",
            "solution": "所述问题具有科学依据，提法明确，并包含了获得唯一解所需的所有信息。它描述了计算等离子体物理学中一个标准的数值验证任务，特别是关于回旋平均算子的实现，这在回旋动理学理论中是基础性的。因此，该问题被认为是有效的。\n\n问题的核心是计算作用于单色平面波的回旋平均算子的离散近似，并将其与已知的解析结果进行比较。\n\n在固定导心位置 $\\boldsymbol{R}$ 处，标量场 $\\phi(\\boldsymbol{r})$ 的连续回旋平均定义为在垂直于磁场的平面内，沿圆形拉莫尔轨道的平均值：\n$$\n\\langle \\phi \\rangle_g (\\boldsymbol{R}) = \\frac{1}{2\\pi} \\int_0^{2\\pi} \\phi(\\boldsymbol{R} + \\boldsymbol{\\rho}_s(\\theta)) \\, d\\theta\n$$\n其中 $\\boldsymbol{\\rho}_s(\\theta)$ 是由回旋相角 $\\theta \\in [0, 2\\pi)$ 参数化的回旋半径矢量。\n\n对于此问题，标量场是一个平面波，$\\phi(\\boldsymbol{r}) = e^{\\mathrm{i} \\boldsymbol{k}_\\perp \\cdot \\boldsymbol{r}}$。导心位于原点，因此 $\\boldsymbol{R} = \\boldsymbol{0}$。粒子在回旋环上的位置因此是 $\\boldsymbol{r} = \\boldsymbol{\\rho}_s(\\theta)$。波矢量 $\\boldsymbol{k}_\\perp$ 与 $x$ 轴对齐，因此我们可以写成 $\\boldsymbol{k}_\\perp = (k_\\perp, 0, 0)$。回旋半径矢量位于 $x$-$y$ 平面内，由 $\\boldsymbol{\\rho}_s(\\theta) = (\\rho_s \\cos\\theta, \\rho_s \\sin\\theta, 0)$ 给出。\n\n指数中的点积为 $\\boldsymbol{k}_\\perp \\cdot \\boldsymbol{r} = k_\\perp \\rho_s \\cos\\theta$。将此代入场表达式，然后再代入回旋平均积分中，得到：\n$$\n\\langle e^{\\mathrm{i} \\boldsymbol{k}_\\perp \\cdot \\boldsymbol{r}} \\rangle_g = \\frac{1}{2\\pi} \\int_0^{2\\pi} e^{\\mathrm{i} k_\\perp \\rho_s \\cos\\theta} \\, d\\theta\n$$\n这个积分是第一类零阶贝塞尔函数 $J_0(z)$ 的一个标准积分表示，其宗量是无量纲参数 $z = k_\\perp \\rho_s$：\n$$\nJ_0(z) = \\frac{1}{2\\pi} \\int_0^{2\\pi} e^{\\mathrm{i} z \\cos\\theta} \\, d\\theta\n$$\n这个解析结果是我们数值验证的参考值。请注意，对于实数 $z$，$J_0(z)$ 是一个实值函数。\n\n问题要求一个离散的、实空间的求积近似。这通过将连续积分替换为在回旋环上 $N_\\theta$ 个均匀间隔点上的离散和来实现。回旋相角取为 $\\theta_j = \\frac{2\\pi j}{N_\\theta}$，其中 $j = 0, 1, \\dots, N_\\theta - 1$。回旋平均的离散近似，我们可以表示为 $\\hat{J}_0(z)$，是这些点上场值的算术平均值：\n$$\n\\hat{J}_0(z) = \\frac{1}{N_\\theta} \\sum_{j=0}^{N_\\theta-1} e^{\\mathrm{i} z \\cos(\\theta_j)}\n$$\n这种数值计算等同于将梯形法则应用于一个周期函数的一个周期，已知其具有优异的收敛性质。\n\n由于余弦函数的对称性，和的虚部 $\\sum_j \\sin(z \\cos\\theta_j)$ 在连续极限下计算为零，并且在对称点集的离散和中，预期其在机器精度范围内为零。因此，数值结果取为复数和的实部。\n\n每个测试用例的总体算法如下：\n$1$. 给定参数 $k_\\perp$、$\\rho_s$ 和 $N_\\theta$，计算无量纲宗量 $z = k_\\perp \\rho_s$。\n$2$. 生成一个包含 $N_\\theta$ 个角度的数组，$\\theta_j = \\frac{2\\pi j}{N_\\theta}$，其中 $j \\in \\{0, 1, ..., N_\\theta - 1\\}$。\n$3$. 通过对所有角度上的 $e^{\\mathrm{i} z \\cos(\\theta_j)}$ 值进行平均，计算离散回旋平均 $\\hat{J}_0(z)$。结果是该平均值的实部。\n$4$. 使用标准库函数（例如 `scipy.special.j0`）计算参考值 $J_0(z)$。\n$5$. 计算绝对误差：$|\\hat{J}_0(z) - J_0(z)|$。\n$6$. 将此误差与测试用例指定的容差进行比较。如果误差小于或等于容差，则结果为 `True`，否则为 `False`。\n\n对所有提供的测试用例重复此过程。一个特殊的用例是测试用例 5，其中 $k_\\perp = 0$。这导致 $z = 0$，此时场在任何地方都是 $e^0 = 1$。离散平均值恰好为 $1$，参考值为 $J_0(0) = 1$。误差恰好为 $0$，可作为对实现的稳健性检查。测试用例 4，对于一个快速振荡的被积函数（$z=5$）使用非常粗略的求积（$N_\\theta=4$），预期会产生较大误差，并且无法通过其严格容差的验证检查，这展示了数值方法的局限性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import j0\n\ndef solve():\n    \"\"\"\n    Computes a discrete gyroaverage of a plane wave and validates it against\n    the analytical zero-order Bessel function result for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (k_perp, rho_s, N_theta, tolerance)\n    test_cases = [\n        (0.2, 0.5, 64, 1e-12),\n        (3.0, 1.0, 128, 1e-10),\n        (10.0, 2.0, 1024, 1e-8),\n        (5.0, 1.0, 4, 1e-6),\n        (0.0, 1.0, 16, 1e-15),\n        (3.0, 1.0, 2048, 1e-13),\n    ]\n\n    results = []\n    for k_perp, rho_s, N_theta, tolerance in test_cases:\n        # 1. Calculate the dimensionless parameter z = k_perp * rho_s\n        z = k_perp * rho_s\n\n        # 2. Compute the discrete gyroaverage using a uniform quadrature with N_theta points.\n        # Generate N_theta equally spaced angles in the interval [0, 2*pi).\n        # Using endpoint=False is crucial for a symmetric set of points for the discrete sum.\n        theta_points = np.linspace(0.0, 2.0 * np.pi, N_theta, endpoint=False)\n        \n        # Evaluate the complex field exp(i * z * cos(theta)) at each discrete angle.\n        field_values = np.exp(1j * z * np.cos(theta_points))\n        \n        # The discrete gyroaverage is the arithmetic mean of the field values.\n        # The analytical result J0(z) for real z is real. The imaginary part of the\n        # discrete sum should be zero to within machine precision due to symmetry.\n        # We take the real part of the numerical average for comparison.\n        discrete_j0 = np.real(np.mean(field_values))\n\n        # 3. Obtain the reference value from the zero-order Bessel function of the first kind.\n        reference_j0 = j0(z)\n\n        # 4. Calculate the absolute error between the discrete quadrature and the reference value.\n        absolute_error = np.abs(discrete_j0 - reference_j0)\n\n        # 5. Compare the absolute error to the specified tolerance to get the boolean result.\n        validation_result = absolute_error = tolerance\n        results.append(validation_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}