{
    "hands_on_practices": [
        {
            "introduction": "在回旋动理学理论中，回旋平均是核心操作，它将物理量在快轮回旋运动尺度上进行平均。在数值模拟中，这个连续的积分运算必须被离散求和所取代。本练习旨在探索这种离散近似的准确性，帮助您理解如何根据物理参数 $k_{\\perp}\\rho$ 来确定保证所需精度所需的最小计算网格点数，这是进行任何回旋动理学数值研究都必须掌握的基本技能。",
            "id": "3987734",
            "problem": "考虑在回旋动理学（GK）理论中的回旋平均，其定义为快变相位在回旋相位上的平均。假设一个带电粒子在均匀磁场中作回旋运动，并考虑与垂直空间变化相关的平面波因子。沿圆形拉莫尔轨道的平面波因子可以写成回旋相位 $\\,\\theta\\,$ 的函数，形式为 $\\,\\exp\\!\\left(i\\,k_{\\perp}\\rho\\cos\\theta\\right)\\,$，其中 $\\,k_{\\perp}\\,$ 是垂直波矢的大小，$\\,\\rho\\,$ 是拉莫尔半径，$\\,\\theta\\,$ 是以弧度为单位的回旋相位角。连续回旋平均是周期为 $\\,2\\pi\\,$ 的平均值\n$$\n\\frac{1}{2\\pi}\\int_{0}^{2\\pi} \\exp\\!\\left(i\\,k_{\\perp}\\rho\\cos\\theta\\right)\\,d\\theta,\n$$\n这是计算聚变科学与工程中的一个标准量。\n\n在实践中，数值回旋平均用 $\\,\\theta\\,$ 上的 $\\,N_{\\theta}\\,$ 个等距点的离散和来代替连续积分。定义离散均匀网格上的回旋相位样本为 $\\,\\theta_{n} = \\frac{2\\pi n}{N_{\\theta}}\\,$（其中 $\\,n=0,1,\\dots,N_{\\theta}-1\\,$），以及离散回旋平均近似\n$$\n\\mathcal{G}_{N_{\\theta}}\\!\\left(k_{\\perp}\\rho\\right) \\equiv \\frac{1}{N_{\\theta}}\\sum_{n=0}^{N_{\\theta}-1} \\exp\\!\\left(i\\,k_{\\perp}\\rho\\cos\\theta_{n}\\right).\n$$\n角度必须以弧度处理。无量纲参数 $\\,k_{\\perp}\\rho\\,$ 应通过回旋动理学标度视为从较小值变化到较大值。\n\n你的任务是分析用 $\\,N_{\\theta}\\,$ 个点离散化回旋相位对回旋平均精度的影响，并对于给定的容差 $\\,\\varepsilon\\,$，确定最小的 $\\,N_{\\theta}\\,$ 使得\n$$\n\\left|\\mathcal{G}_{N_{\\theta}}\\!\\left(k_{\\perp}\\rho\\right) - \\mathcal{G}_{\\infty}\\!\\left(k_{\\perp}\\rho\\right)\\right| \\le \\varepsilon,\n$$\n其中 $\\,\\mathcal{G}_{\\infty}\\!\\left(k_{\\perp}\\rho\\right)\\,$ 表示由上述积分定义的精确连续回旋平均。你必须：\n- 使用指定的离散均匀网格近似 $\\,\\mathcal{G}_{N_{\\theta}}\\!\\left(k_{\\perp}\\rho\\right)\\,$。\n- 从第一性原理计算精确的连续回旋平均 $\\,\\mathcal{G}_{\\infty}\\!\\left(k_{\\perp}\\rho\\right)\\,$，而非通过假设。\n- 对每个测试用例，找到满足容差 $\\,\\varepsilon\\,$ 的最小整数 $\\,N_{\\theta}\\ge 1\\,$。\n\n设计一个程序，对于一组 $(k_{\\perp}\\rho,\\varepsilon)$ 测试用例，返回相应的最小 $\\,N_{\\theta}\\,$ 值。所有角度必须以弧度处理。输出必须是整数。使用以下测试套件以确保覆盖不同区域：\n- 案例 1：$\\,k_{\\perp}\\rho = 0.0\\,$, $\\,\\varepsilon = 10^{-12}\\,$。\n- 案例 2：$\\,k_{\\perp}\\rho = 0.1\\,$, $\\,\\varepsilon = 10^{-10}\\,$。\n- 案例 3：$\\,k_{\\perp}\\rho = 1.0\\,$, $\\,\\varepsilon = 10^{-8}\\,$。\n- 案例 4：$\\,k_{\\perp}\\rho = 2.5\\,$, $\\,\\varepsilon = 10^{-6}\\,$。\n- 案例 5：$\\,k_{\\perp}\\rho = 5.0\\,$, $\\,\\varepsilon = 10^{-6}\\,$。\n- 案例 6：$\\,k_{\\perp}\\rho = 10.0\\,$, $\\,\\varepsilon = 10^{-5}\\,$。\n- 案例 7：$\\,k_{\\perp}\\rho = 20.0\\,$, $\\,\\varepsilon = 10^{-4}\\,$。\n- 案例 8：$\\,k_{\\perp}\\rho = 50.0\\,$, $\\,\\varepsilon = 10^{-3}\\,$。\n\n你的程序应生成单行输出，包含一个用逗号分隔并用方括号括起来的结果列表（例如，\"[n1,n2,n3,n4,n5,n6,n7,n8]\"），其中每个条目是对应测试用例的最小 $\\,N_{\\theta}\\,$，顺序与上面列出的一致。",
            "solution": "问题要求找到所需的最小离散回旋相位采样点数 $N_{\\theta}$，以在指定的容差 $\\varepsilon$ 内近似连续回旋平均。这个问题根植于回旋动理学理论的计算方法，该理论是磁约束聚变能源研究中等离子体物理学的基石。\n\n平面波因子 $\\exp(i k_{\\perp}\\rho\\cos\\theta)$ 的连续回旋平均 $\\mathcal{G}_{\\infty}(k_{\\perp}\\rho)$ 由以下积分定义：\n$$\n\\mathcal{G}_{\\infty}(k_{\\perp}\\rho) = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} \\exp(i k_{\\perp}\\rho \\cos\\theta)\\,d\\theta\n$$\n此处，$k_{\\perp}$ 是垂直波数，$\\rho$ 是拉莫尔半径，$\\theta$ 是回旋相位角。令 $x = k_{\\perp}\\rho$ 为无量纲参数。该积分是零阶第一类贝塞尔函数 $J_0(x)$ 的一个标准表示。这可以通过对 Jacobi-Anger 展开式\n$$\ne^{iz\\cos\\theta} = J_0(z) + 2 \\sum_{k=1}^{\\infty} i^k J_k(z) \\cos(k\\theta)\n$$\n对 $\\theta$ 从 $0$ 到 $2\\pi$ 进行积分来正式证明。求和部分积分为零，因为对于任何整数 $k \\ge 1$，都有 $\\int_{0}^{2\\pi} \\cos(k\\theta) d\\theta = 0$。这剩下：\n$$\n\\frac{1}{2\\pi}\\int_{0}^{2\\pi} e^{ix\\cos\\theta}\\,d\\theta = J_0(x)\n$$\n因此，连续回旋平均的精确值为 $\\mathcal{G}_{\\infty}(k_{\\perp}\\rho) = J_0(k_{\\perp}\\rho)$。由于自变量 $k_{\\perp}\\rho$ 是实数，因此 $J_0(k_{\\perp}\\rho)$ 的值也是实数。这个精确值可以使用标准的科学计算库来计算，特别是在指定的 Python 环境中使用 `scipy.special.j0`。\n\n离散近似 $\\mathcal{G}_{N_{\\theta}}(k_{\\perp}\\rho)$ 由对 $N_{\\theta}$ 个均匀间隔点 $\\theta_n = 2\\pi n / N_{\\theta}$（其中 $n=0, 1, \\dots, N_{\\theta}-1$）的求和给出：\n$$\n\\mathcal{G}_{N_{\\theta}}(k_{\\perp}\\rho) = \\frac{1}{N_{\\theta}}\\sum_{n=0}^{N_{\\theta}-1} \\exp\\left(i k_{\\perp}\\rho \\cos\\theta_{n}\\right)\n$$\n这代表了将梯形法则应用于一个 $2\\pi$周期函数，已知这种方法可以提供高（谱）精度。这个和的结果 $\\mathcal{G}_{N_{\\theta}}$ 通常是一个复数。\n\n目标是找到满足容差条件的最小整数 $N_{\\theta} \\ge 1$：\n$$\n\\left|\\mathcal{G}_{N_{\\theta}}(k_{\\perp}\\rho) - J_0(k_{\\perp}\\rho)\\right| \\le \\varepsilon\n$$\n此处的绝对值表示复数误差的模。\n\n为每个 $(k_{\\perp}\\rho, \\varepsilon)$ 测试用例找到最小 $N_{\\theta}$ 的算法是一个迭代搜索过程：\n1.  从测试用例中设置参数 $x = k_{\\perp}\\rho$ 和容差 $\\varepsilon$。\n2.  计算精确的参考值 $G_{\\infty} = J_0(x)$。\n3.  将点数初始化为允许的最小值 $N_{\\theta} = 1$。\n4.  开始一个迭代增加 $N_{\\theta}$ 的循环：\n    a. 对于当前的 $N_{\\theta}$，生成相位角 $\\theta_n = \\frac{2\\pi n}{N_{\\theta}}$（其中 $n \\in \\{0, \\dots, N_{\\theta}-1\\}$）。\n    b. 计算离散平均值 $G_{N_{\\theta}} = \\frac{1}{N_{\\theta}}\\sum_{n=0}^{N_{\\theta}-1} \\exp(i x \\cos\\theta_n)$。\n    c. 计算误差大小 $E = |G_{N_{\\theta}} - G_{\\infty}|$。\n    d. 如果 $E \\le \\varepsilon$，则条件满足。当前的 $N_{\\theta}$ 是最小整数值，因此该测试用例的搜索终止，并记录 $N_{\\theta}$ 的值。\n    e. 如果 $E > \\varepsilon$，则将 $N_{\\theta}$ 增加 1 并继续循环。\n\n这个搜索过程必然会收敛，因为离散和是该积分的一个收敛的数值近似。\n\n当 $k_{\\perp}\\rho = 0$ 时会出现一个特殊情况。在这种情况下，$J_0(0) = 1$。离散和变为 $\\mathcal{G}_{N_{\\theta}}(0) = \\frac{1}{N_{\\theta}}\\sum_{n=0}^{N_{\\theta}-1} \\exp(0) = \\frac{1}{N_{\\theta}} \\cdot N_{\\theta} = 1$。误差对于任何 $N_{\\theta} \\ge 1$ 恒为零。因此，所需的最小点数为 $N_{\\theta}=1$。对于所有其他 $k_{\\perp}\\rho > 0$ 的情况，迭代搜索提供了解决方案。\n\n实现将使用 `numpy` 进行高效的计算矢量化，并使用 `scipy.special.j0` 进行贝塞尔函数的高精度计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import j0\n\ndef solve():\n    \"\"\"\n    Solves the gyro-averaging problem for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 1e-12),    # Case 1\n        (0.1, 1e-10),    # Case 2\n        (1.0, 1e-8),     # Case 3\n        (2.5, 1e-6),     # Case 4\n        (5.0, 1e-6),     # Case 5\n        (10.0, 1e-5),    # Case 6\n        (20.0, 1e-4),    # Case 7\n        (50.0, 1e-3),    # Case 8\n    ]\n\n    def find_min_N_theta(k_perp_rho, epsilon):\n        \"\"\"\n        Finds the minimum integer N_theta >= 1 that satisfies the error tolerance.\n        \n        Args:\n            k_perp_rho (float): The dimensionless parameter k_perp * rho.\n            epsilon (float): The error tolerance.\n            \n        Returns:\n            int: The smallest N_theta satisfying the condition.\n        \"\"\"\n        # The exact continuous gyroaverage is the Bessel function J0(k_perp*rho).\n        g_infinity = j0(k_perp_rho)\n\n        # Handle the special case k_perp_rho = 0, where the error is always 0.\n        # The problem asks for the minimum N_theta >= 1.\n        if k_perp_rho == 0.0:\n            return 1\n\n        # Start search for minimum N_theta from 1.\n        n_theta = 1\n        while True:\n            # Generate N_theta equally spaced gyrophase angles in [0, 2*pi).\n            theta_n = np.linspace(0.0, 2.0 * np.pi, n_theta, endpoint=False)\n            \n            # Calculate the discrete gyroaverage using complex exponentials.\n            # np.mean is equivalent to np.sum(...)/n_theta.\n            g_n_theta = np.mean(np.exp(1j * k_perp_rho * np.cos(theta_n)))\n            \n            # Calculate the error as the magnitude of the complex difference.\n            error = np.abs(g_n_theta - g_infinity)\n            \n            # Check if the error is within the specified tolerance.\n            if error = epsilon:\n                return n_theta\n            \n            # If not, increment N_theta and continue the search.\n            n_theta += 1\n\n    results = []\n    for case in test_cases:\n        k_perp_rho, epsilon = case\n        min_n = find_min_N_theta(k_perp_rho, epsilon)\n        results.append(min_n)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在掌握了基本的回旋平均计算之后，我们将注意力转向一个具体但至关重要的函数 $\\Gamma_{0}(b)$，它代表了麦克斯韦分布函数的回旋平均响应。这个函数在回旋动理学模型中无处不在。本练习要求您设计一个在不同物理区间（对应长波和短波极限）内都能稳定计算 $\\Gamma_{0}(b)$ 的算法，它突显了在科学计算中直接实现数学公式可能遇到的数值问题，并教授了根据物理状态选择合适数值方法的重要性。",
            "id": "3987719",
            "problem": "给定一个无量纲参数 $b = k_{\\perp}^{2}\\rho^{2}$，该参数源于磁化等离子体回旋动理学级数中的回旋平均。我们关注的量是标度化的修正贝塞尔函数组合 $\\Gamma_{0}(b)$，其定义为 $\\Gamma_{0}(b) = I_{0}(b)\\,\\mathrm{e}^{-b}$，其中 $I_{0}$ 是零阶第一类修正贝塞尔函数。请从 $I_{0}$ 和指数函数的基本定义出发，设计一个数值稳定且一致精确的算法，用于在一系列非负 $b$ 值的网格上计算 $\\Gamma_{0}(b)$。您的算法必须：\n- 在所有输入值上，将绝对误差控制在不超过预设容差 $\\varepsilon$。\n- 明确处理小 $b$（长波，$b \\ll 1$）、中等 $b$（量级为1）和大 $b$（短波，$b \\gg 1$）这几种情况下的数值条件问题。\n- 为所使用的任何截断展开提供有原则的停止判据，并基于从基本定义推导出的界限来证明其合理性。\n\n您必须从第一性原理出发推导该算法，从第一类修正贝塞尔函数和指数函数的级数及积分定义开始，并用清晰的误差估计来证明每种近似和区间选择的合理性。解释为什么对于大 $b$ 值，直接分别计算 $I_{0}(b)$ 和 $\\mathrm{e}^{-b}$ 可能会是病态的，并说明您的方法如何缓解此问题。\n\n将您的算法实现为一个程序，对于下方的每个测试用例，在指定的网格上计算 $\\Gamma_{0}(b)$，并将其与基于经过良好测试的特殊函数实现的高精度参考值进行比较。对于每个测试用例，报告网格上的最大绝对误差，该误差为一个标量值。使用绝对误差容差 $\\varepsilon = 10^{-12}$。\n\n测试套件：\n- 用例 $1$ (小 $b$): $b \\in \\{\\,0,\\,10^{-12},\\,10^{-8},\\,10^{-4},\\,10^{-2}\\,\\}$。\n- 用例 $2$ (中等 $b$): $b \\in \\{\\,5\\times 10^{-2},\\,5\\times 10^{-1},\\,1,\\,2,\\,5,\\,10\\,\\}$。\n- 用例 $3$ (大 $b$): $b \\in \\{\\,50,\\,100,\\,10^{3},\\,10^{6}\\,\\}$。\n- 用例 $4$ (回旋动理学构造): 通过将 $k_{\\perp} \\in \\{\\,0,\\,1,\\,5,\\,20\\,\\}$ 与 $\\rho \\in \\{\\,0,\\,10^{-3},\\,10^{-2},\\,10^{-1}\\,\\}$ 配对，为所有配对形成 $b = k_{\\perp}^{2}\\rho^{2}$ 来构建网格。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按顺序排列的从用例 $1$ 到 $4$ 的四个最大绝对误差，格式为方括号括起来的逗号分隔列表。例如，一个可接受的格式是 $[e_{1},e_{2},e_{3},e_{4}]$，其中每个 $e_{i}$ 是一个浮点数。不应打印任何额外文本。",
            "solution": "问题是设计并实现一个数值稳定的算法来计算函数 $\\Gamma_{0}(b) = I_{0}(b)\\,\\mathrm{e}^{-b}$，其中参数 $b$ 为非负值。这里，$I_{0}(b)$ 是零阶第一类修正贝塞尔函数。参数 $b = k_{\\perp}^{2}\\rho^{2}$ 出现在磁化等离子体的回旋动理学理论中，代表归一化的垂直波数的平方。一个鲁棒的算法必须能处理大范围的 $b$ 值，从 $b \\ll 1$（长波极限）到 $b \\gg 1$（短波极限），同时将绝对误差保持在指定的容差 $\\varepsilon = 10^{-12}$ 以下。\n\n一种朴素的直接计算方法，即分别计算 $I_{0}(b)$ 和 $\\mathrm{e}^{-b}$ 然后相乘，充满了数值风险，尤其是在 $b$ 值较大时。函数 $I_{0}(b)$ 呈指数增长，近似于 $I_{0}(b) \\sim \\mathrm{e}^{b}/\\sqrt{2\\pi b}$，而 $\\mathrm{e}^{-b}$ 呈指数衰减。对于大 $b$ 值，$I_{0}(b)$ 将上溢标准的双精度浮点表示（当 $b \\gtrsim 710$ 时，其最大值约为 $10^{308}$），而 $\\mathrm{e}^{-b}$ 将下溢为零（当 $b \\gtrsim 740$ 时）。即便在达到这些极限之前，一个非常大的数与一个非常小的数相乘也可能导致相对精度的严重损失，这种效应被称为灾难性抵消。此外，如下文将详述，$I_0(b)$ 的标准级数表示由于浮点加法的限制，对于大 $b$ 值会变得数值不稳定。\n\n因此，一个可靠的算法必须通过将 $b$ 的定义域划分为不同区间，并为每个区间使用不同的数值策略来构建。\n\n### **从第一性原理推导**\n\n我们从第一类修正贝塞尔函数的基本积分定义开始：\n$$\nI_{0}(b) = \\frac{1}{\\pi} \\int_{0}^{\\pi} \\mathrm{e}^{b \\cos\\theta} d\\theta\n$$\n由此，函数 $\\Gamma_{0}(b)$ 可以表示为：\n$$\n\\Gamma_{0}(b) = I_{0}(b)\\,\\mathrm{e}^{-b} = \\mathrm{e}^{-b} \\left( \\frac{1}{\\pi} \\int_{0}^{\\pi} \\mathrm{e}^{b \\cos\\theta} d\\theta \\right) = \\frac{1}{\\pi} \\int_{0}^{\\pi} \\mathrm{e}^{b(\\cos\\theta - 1)} d\\theta\n$$\n这种积分形式在数值计算上具有更好的条件，因为指数的参数 $b(\\cos\\theta - 1)$ 始终为非正数，从而防止了上溢。通过在 $b$ 的不同极限下近似这个积分或其组成部分，可以得出不同的计算策略。一个特殊情况是 $b=0$，此时 $\\Gamma_{0}(0) = I_{0}(0)\\mathrm{e}^{0} = 1 \\cdot 1 = 1$。\n\n### **区间 1：小到中等 $b$ ($0  b \\le b_{\\text{switch}}$)**\n\n对于小 $b$ 值，最有效的方法是使用 $I_{0}(b)$ 的泰勒级数展开。该级数可以通过在积分定义中展开指数函数 $\\mathrm{e}^{b\\cos\\theta}$ 并逐项积分得到。结果是：\n$$\nI_{0}(b) = \\sum_{k=0}^{\\infty} \\frac{1}{(k!)^2} \\left(\\frac{b}{2}\\right)^{2k} = 1 + \\frac{b^2}{4} + \\frac{b^4}{64} + \\dots\n$$\n该级数对所有 $b$ 收敛。在其数值实现中，我们使用各项 $t_k = \\frac{(b/2)^{2k}}{(k!)^2}$ 的递推关系：\n$$\nt_k = t_{k-1} \\cdot \\frac{b^2}{4k^2}, \\quad \\text{其中 } t_0 = 1\n$$\n在此区间，我们通过对该级数求和来计算 $I_{0}(b)$，然后将结果乘以 $\\mathrm{e}^{-b}$，后者可以使用标准库函数精确计算。\n\n**数值条件和 $b_{\\text{switch}}$ 的选择**：\n虽然泰勒级数在数学上是收敛的，但对于大 $b$ 值，其求和在数值上变得不稳定。只要 $b^2/(4k^2) > 1$（即 $k  b/2$），项 $t_k$ 就会初始增加。对于大 $b$ 值，最大项会变得非常巨大。在浮点运算中对数量级差异巨大的项进行求和会导致精度损失。具体来说，如果部分和 $S$ 远大于一个新项 $t$，那么加法 $S+t$ 将会丢失 $t$ 的大部分甚至全部有效位。能够可靠求和的 $I_0(b)$ 的最大值取决于浮点精度。对于`float64`（约有 $16$ 位十进制精度），如果求和结果远超 $\\approx 10^{10}$--$10^{12}$，则结果将变得不可靠。这对应于 $b \\approx 25$--$30$。我们选择一个保守的切换点 $b_{\\text{switch}} = 20$。对于 $b \\le 20$，$I_0(20) \\approx 2.2 \\times 10^7 \\ll 10^{16-1}=10^{15}$，求和是稳定的。\n\n**停止判据**：\n$I_{0}(b)$ 的级数所有项均为正。截断误差是所有被忽略项的和。此误差由一个几何级数界定。一个简单有效的停止判据是持续求和，直到下一个要加的项 $t_{k+1}$ 小于目标绝对误差 $\\varepsilon = 10^{-12}$。由于对于 $b \\ge 0$，$\\mathrm{e}^{-b} \\le 1$，最终乘积 $\\Gamma_0(b)$ 的绝对误差将由 $I_0(b)$ 的绝对误差界定。因此，我们求和直到 $t_k  \\varepsilon$。\n\n### **区间 2：大 $b$ ($b > b_{\\text{switch}}$)**\n\n对于大 $b$ 值，我们回到稳定化的积分形式 $\\Gamma_0(b) = \\frac{1}{\\pi} \\int_0^\\pi \\mathrm{e}^{-b(1-\\cos\\theta)} d\\theta$。项 $b(1-\\cos\\theta)$ 很大，除非 $\\theta \\approx 0$。这表明可以使用拉普拉斯方法进行渐近近似。对于小 $\\theta$，我们有 $1-\\cos\\theta \\approx \\theta^2/2 - \\theta^4/24 + \\dots$。保留第一项，我们得到：\n$$\n\\Gamma_0(b) \\approx \\frac{1}{\\pi} \\int_0^\\infty \\mathrm{e}^{-b\\theta^2/2} d\\theta = \\frac{1}{\\pi} \\frac{1}{2} \\int_{-\\infty}^\\infty \\mathrm{e}^{-b\\theta^2/2} d\\theta = \\frac{1}{2\\pi} \\sqrt{\\frac{2\\pi}{b}} = \\frac{1}{\\sqrt{2\\pi b}}\n$$\n这是 $\\Gamma_0(b)$ 渐近展开的主导项。$I_0(b)$ 的完整渐近级数是：\n$$\nI_0(b) \\sim \\frac{\\mathrm{e}^b}{\\sqrt{2\\pi b}} \\sum_{k=0}^{\\infty} \\frac{[(2k-1)!!]^2}{k!\\,(8b)^k}\n$$\n其中按照约定 $(-1)!!=1$。乘以 $\\mathrm{e}^{-b}$ 可以抵消不稳定的指数增长，从而得到一个用于 $\\Gamma_0(b)$ 的数值稳定的渐近级数：\n$$\n\\Gamma_0(b) \\sim \\frac{1}{\\sqrt{2\\pi b}} \\sum_{k=0}^{\\infty} a_k, \\quad \\text{其中 } a_k = \\frac{[(2k-1)!!]^2}{k!\\,(8b)^k}\n$$\n项 $a_k$ 可以通过递推关系计算：\n$$\na_k = a_{k-1} \\cdot \\frac{(2k-1)^2}{8kb}, \\quad \\text{其中 } a_0 = 1\n$$\n\n**停止判据**：\n渐近级数是发散的，但如果进行最优截断，其部分和能提供极好的近似。误差的量级与第一个被忽略的项相当。因此，我们可以对级数求和，并在下一项对总和的贡献的绝对值，即 $|a_k \\cdot P|$，小于我们的目标容差 $\\varepsilon$ 时停止。\n\n### **混合算法总结**\n\n1.  如果 $b=0$，返回 $1.0$。\n2.  定义一个切换点，$b_{\\text{switch}} = 20.0$。\n3.  如果 $0  b \\le b_{\\text{switch}}$:\n    a. 初始化和 $S=1.0$ 与项 $t=1.0$。\n    b. 对于 $k=1, 2, \\dots$，更新项 $t \\leftarrow t \\cdot b^2 / (4k^2)$ 和和 $S \\leftarrow S+t$。\n    c. 当 $t  \\varepsilon$ 时停止。\n    d. 返回 $S \\cdot \\mathrm{e}^{-b}$。\n4.  如果 $b > b_{\\text{switch}}$:\n    a. 初始化和 $S=1.0$ 与项 $a=1.0$。\n    b. 计算前置因子 $P = 1/\\sqrt{2\\pi b}$。\n    c. 对于 $k=1, 2, \\dots$，更新项 $a \\leftarrow a \\cdot (2k-1)^2 / (8kb)$ 和和 $S \\leftarrow S+a$。\n    d. 当 $|a \\cdot P|  \\varepsilon$ 时停止。\n    e. 返回 $S \\cdot P$。\n\n这种混合算法在所有 $b \\ge 0$ 的情况下都是数值稳定的，并且旨在满足指定的误差容差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0e\nimport math\n\ndef gamma0_custom(b: float, eps: float = 1e-12) -> float:\n    \"\"\"\n    Computes Gamma0(b) = I0(b) * exp(-b) using a numerically stable hybrid algorithm.\n    \n    Args:\n        b: A non-negative float, the dimensionless parameter.\n        eps: The desired absolute error tolerance.\n\n    Returns:\n        The computed value of Gamma0(b).\n    \"\"\"\n    if b  0:\n        raise ValueError(\"Parameter b must be non-negative.\")\n    if b == 0.0:\n        return 1.0\n\n    # Switch point between Taylor series and asymptotic expansion.\n    # Chosen to maintain stability of the Taylor series summation in float64.\n    b_switch = 20.0\n\n    if b = b_switch:\n        # Regime 1: Small to moderate b.\n        # Use Taylor series for I0(b), then multiply by exp(-b).\n        # I_0(b) = sum_{k=0 to inf} ( (b/2)^2k / (k!)^2 )\n        # Recurrence: term_k = term_{k-1} * b^2 / (4*k^2)\n        term = 1.0\n        current_sum = 1.0\n        k = 1\n        b_sq_over_4 = b * b / 4.0\n        while True:\n            term *= b_sq_over_4 / (k * k)\n            current_sum += term\n            k += 1\n            # Stopping criterion: The absolute error in I0(b) should be less than eps.\n            # Since exp(-b) = 1, this ensures the final absolute error is also = eps.\n            if term  eps:\n                break\n        \n        i0_val = current_sum\n        return i0_val * math.exp(-b)\n        \n    else:\n        # Regime 2: Large b.\n        # Use asymptotic series for Gamma0(b) = I0(b)*exp(-b).\n        # Gamma0(b) ~ 1/sqrt(2*pi*b) * sum_{k=0 to inf} a_k where\n        # a_k = [(2k-1)!!]^2 / (k! * (8b)^k)\n        # Recurrence: a_k = a_{k-1} * (2k-1)^2 / (k * 8b)\n        term = 1.0\n        current_sum = 1.0\n        k = 1\n        eight_b = 8.0 * b\n        prefactor = 1.0 / math.sqrt(2.0 * math.pi * b)\n\n        while True:\n            term *= (2.0 * k - 1.0)**2 / (k * eight_b)\n            current_sum += term\n            k += 1\n            # Stopping criterion: absolute error on Gamma0(b).\n            # The error of a truncated asymptotic series is on the order of the\n            # first neglected term. We stop when its contribution is = eps.\n            if abs(term * prefactor)  eps:\n                break\n\n        return current_sum * prefactor\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute max absolute errors.\n    \"\"\"\n    error_tolerance = 1e-12\n\n    test_cases = [\n        # Case 1 (small b)\n        np.array([0, 1e-12, 1e-8, 1e-4, 1e-2]),\n        # Case 2 (intermediate b)\n        np.array([5e-2, 5e-1, 1, 2, 5, 10]),\n        # Case 3 (large b)\n        np.array([50, 100, 1e3, 1e6]),\n        # Case 4 (gyrokinetic construction)\n        np.array(\n            [k_perp**2 * rho**2 for k_perp in [0, 1, 5, 20] for rho in [0, 1e-3, 1e-2, 1e-1]]\n        )\n    ]\n\n    max_errors = []\n\n    for b_grid in test_cases:\n        # Avoid duplicate calculations by using a unique set of b values\n        unique_b = np.unique(b_grid)\n        \n        my_values = np.array([gamma0_custom(b, error_tolerance) for b in unique_b])\n        ref_values = i0e(unique_b)\n        \n        abs_errors = np.abs(my_values - ref_values)\n        max_error = np.max(abs_errors) if abs_errors.size > 0 else 0.0\n        max_errors.append(max_error)\n\n    # Format the final output string\n    output_str = f\"[{','.join(f'{err:.1e}' for err in max_errors)}]\"\n    print(output_str)\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "掌握了必要的数值工具后，我们现在可以将其应用于一个真实的物理问题。本练习将回旋平均的概念应用于回旋动理学中的准中性条件，这是静电湍流模型中的一个核心方程。这个练习将非绝热分布、极化密度和回旋平均因子（如 $\\Gamma_{0}$）等抽象概念联系起来，以求解一个可观测的物理量——自洽的静电势 $\\phi$，具体展示了回旋动理学框架如何用于描述等离子体的集体行为。",
            "id": "3987725",
            "problem": "考虑一个均匀磁化等离子体，其中包含单电荷离子和电子，该等离子体支持一个波矢大小为 $k_{\\perp}$ 的单一垂直静电傅里叶模式。在标准的静电回旋动理学近似下进行分析（频率远小于回旋频率，$k_{\\perp} \\rho_{s}$ 为有限值但 $k_{\\parallel} \\rho_{s}$ 很小，且涨落很弱以致线性化有效）。离子和电子的非绝热回旋中心分布函数在傅里叶空间中被规定为 $g_{s}(\\mathbf{k}, v_{\\parallel}, v_{\\perp}) = \\alpha_{s} F_{Ms}(v_{\\parallel}, v_{\\perp})$，其中 $F_{Ms}$ 是局域麦克斯韦分布，归一化后满足 $\\int d^{3}v\\,F_{Ms} = n_{s}$。\n\n给定：\n- 离子电荷 $q_{i} = +e$，电子电荷 $q_{e} = -e$，其中元电荷 $e = 1.602 \\times 10^{-19}$ 库仑。\n- 离子密度 $n_{i} = 5.00 \\times 10^{19}$ 每立方米，电子密度 $n_{e} = 5.00 \\times 10^{19}$ 每立方米。\n- 离子温度 $T_{i} = 5.00$ 千电子伏特，电子温度 $T_{e} = 8.00$ 千电子伏特。使用 $1~\\mathrm{eV} = 1.602 \\times 10^{-19}$ 焦耳将能量单位转换为焦耳。\n- 非绝热振幅 $\\alpha_{i} = 2.00 \\times 10^{-2}$ 和 $\\alpha_{e} = 1.00 \\times 10^{-2}$。\n- 对于给定的 $k_{\\perp}$ 和各粒子种类的热回旋半径，回旋平均因子为：$\\Gamma_{0}(b_{i}) = 7.60 \\times 10^{-1}$ 和 $\\Gamma_{0}(b_{e}) = 9.90 \\times 10^{-1}$，其中 $\\Gamma_{0}(b) \\equiv I_{0}(b)\\exp(-b)$ 且 $I_{0}$ 是零阶第一类修正贝塞尔函数。\n\n假设两种粒子都对极化密度有贡献，并且不要忽略电子极化。应用此单一模式的静电回旋动理学准中性关系，计算静电势的傅里叶分量 $\\phi(\\mathbf{k})$。以伏特为单位表示最终答案，并将其四舍五入到四位有效数字。不涉及角度。",
            "solution": "合适的出发点是线性化的静电回旋动理学准中性关系，该关系由泊松方程经过回旋平均和回旋动理学近似推导得出。对于单一傅里叶模式，回旋中心非绝热响应与极化密度之间的电荷平衡可以写作\n$$\n\\sum_{s} q_{s} \\int d^{3}v\\, J_{0}\\!\\left(k_{\\perp}\\frac{v_{\\perp}}{\\Omega_{s}}\\right) g_{s}(\\mathbf{k}, v_{\\parallel}, v_{\\perp}) \\;=\\; \\sum_{s} \\frac{q_{s}^{2} n_{s}}{T_{s}}\\left(1 - \\Gamma_{0}(b_{s})\\right)\\,\\phi(\\mathbf{k}),\n$$\n其中 $J_{0}$ 是零阶第一类贝塞尔函数，$\\Omega_{s}$ 是粒子种类的回旋频率，$b_{s} = k_{\\perp}^{2}\\rho_{s}^{2}$（其中 $\\rho_{s}$ 是热回旋半径），以及 $\\Gamma_{0}(b_{s}) \\equiv I_{0}(b_{s})\\exp(-b_{s})$ 表示麦克斯韦分布在拉莫轨道上的回旋平均。\n\n根据给定的 $g_{s} = \\alpha_{s} F_{Ms}$ 和麦克斯韦归一化条件 $\\int d^{3}v\\,F_{Ms} = n_{s}$，粒子种类 $s$ 的回旋平均非绝热密度计算为\n$$\n\\int d^{3}v\\, J_{0}\\!\\left(k_{\\perp}\\frac{v_{\\perp}}{\\Omega_{s}}\\right) g_{s} \\;=\\; \\alpha_{s} \\int d^{3}v\\, J_{0}\\!\\left(k_{\\perp}\\frac{v_{\\perp}}{\\Omega_{s}}\\right) F_{Ms} \\;=\\; \\alpha_{s} n_{s} \\Gamma_{0}(b_{s}).\n$$\n将此结果代入准中性关系，得到\n$$\n\\sum_{s} q_{s} \\alpha_{s} n_{s} \\Gamma_{0}(b_{s}) \\;=\\; \\phi(\\mathbf{k}) \\sum_{s} \\frac{q_{s}^{2} n_{s}}{T_{s}}\\left(1 - \\Gamma_{0}(b_{s})\\right),\n$$\n因此\n$$\n\\phi(\\mathbf{k}) \\;=\\; \\frac{\\sum_{s} q_{s} \\alpha_{s} n_{s} \\Gamma_{0}(b_{s})}{\\sum_{s} \\frac{q_{s}^{2} n_{s}}{T_{s}}\\left(1 - \\Gamma_{0}(b_{s})\\right)}.\n$$\n\n现在我们对离子 ($s=i$) 和电子 ($s=e$) 计算该表达式。使用 $q_{i} = +e$ 和 $q_{e} = -e$。分子变为\n$$\n\\mathcal{N} \\;=\\; q_{i}\\alpha_{i}n_{i}\\Gamma_{0}(b_{i}) + q_{e}\\alpha_{e}n_{e}\\Gamma_{0}(b_{e})\n\\;=\\; e\\left[\\alpha_{i}n_{i}\\Gamma_{0}(b_{i}) - \\alpha_{e}n_{e}\\Gamma_{0}(b_{e})\\right].\n$$\n分母变为\n$$\n\\mathcal{D} \\;=\\; \\frac{q_{i}^{2}n_{i}}{T_{i}}\\left(1 - \\Gamma_{0}(b_{i})\\right) + \\frac{q_{e}^{2}n_{e}}{T_{e}}\\left(1 - \\Gamma_{0}(b_{e})\\right)\n\\;=\\; e^{2}\\left[\\frac{n_{i}}{T_{i}}\\left(1 - \\Gamma_{0}(b_{i})\\right) + \\frac{n_{e}}{T_{e}}\\left(1 - \\Gamma_{0}(b_{e})\\right)\\right].\n$$\n因此，\n$$\n\\phi(\\mathbf{k}) \\;=\\; \\frac{e\\left[\\alpha_{i}n_{i}\\Gamma_{0}(b_{i}) - \\alpha_{e}n_{e}\\Gamma_{0}(b_{e})\\right]}{e^{2}\\left[\\frac{n_{i}}{T_{i}}\\left(1 - \\Gamma_{0}(b_{i})\\right) + \\frac{n_{e}}{T_{e}}\\left(1 - \\Gamma_{0}(b_{e})\\right)\\right]}\n\\;=\\; \\frac{\\alpha_{i}n_{i}\\Gamma_{0}(b_{i}) - \\alpha_{e}n_{e}\\Gamma_{0}(b_{e})}{e\\left[\\frac{n_{i}}{T_{i}}\\left(1 - \\Gamma_{0}(b_{i})\\right) + \\frac{n_{e}}{T_{e}}\\left(1 - \\Gamma_{0}(b_{e})\\right)\\right]}.\n$$\n\n接下来，将温度单位转换为焦耳。使用 $1~\\mathrm{eV} = 1.602 \\times 10^{-19}$ 焦耳，我们有\n$$\nT_{i} = 5.00 \\times 10^{3} \\times 1.602 \\times 10^{-19} = 8.010 \\times 10^{-16} \\text{ 焦耳},\n$$\n$$\nT_{e} = 8.00 \\times 10^{3} \\times 1.602 \\times 10^{-19} = 1.2816 \\times 10^{-15} \\text{ 焦耳}.\n$$\n\n计算分子：\n$$\n\\alpha_{i}n_{i}\\Gamma_{0}(b_{i}) = (2.00 \\times 10^{-2})(5.00 \\times 10^{19})(7.60 \\times 10^{-1}) = (1.00 \\times 10^{18})(0.760) = 7.60 \\times 10^{17},\n$$\n$$\n\\alpha_{e}n_{e}\\Gamma_{0}(b_{e}) = (1.00 \\times 10^{-2})(5.00 \\times 10^{19})(9.90 \\times 10^{-1}) = (5.00 \\times 10^{17})(0.990) = 4.95 \\times 10^{17}.\n$$\n因此，分子中的净电荷密度项为\n$$\n\\alpha_{i}n_{i}\\Gamma_{0}(b_{i}) - \\alpha_{e}n_{e}\\Gamma_{0}(b_{e}) = \\left(7.60 - 4.95\\right) \\times 10^{17} = 2.65 \\times 10^{17}.\n$$\n\n计算分母的方括号部分：\n$$\n\\frac{n_{i}}{T_{i}}\\left(1 - \\Gamma_{0}(b_{i})\\right) = \\frac{5.00 \\times 10^{19}}{8.010 \\times 10^{-16}}\\left(1 - 0.760\\right)\n= \\left(6.242 \\times 10^{34}\\right)\\left(0.240\\right) = 1.498 \\times 10^{34},\n$$\n$$\n\\frac{n_{e}}{T_{e}}\\left(1 - \\Gamma_{0}(b_{e})\\right) = \\frac{5.00 \\times 10^{19}}{1.2816 \\times 10^{-15}}\\left(1 - 0.990\\right)\n= \\left(3.902 \\times 10^{34}\\right)\\left(0.010\\right) = 3.902 \\times 10^{32}.\n$$\n求和，\n$$\n\\frac{n_{i}}{T_{i}}\\left(1 - \\Gamma_{0}(b_{i})\\right) + \\frac{n_{e}}{T_{e}}\\left(1 - \\Gamma_{0}(b_{e})\\right)\n= \\left(1.498 \\times 10^{34}\\right) + \\left(0.03902 \\times 10^{34}\\right) = 1.537 \\times 10^{34}.\n$$\n\n现在进行 $\\phi(\\mathbf{k})$ 的数值计算。使用 $e = 1.602 \\times 10^{-19}$，\n$$\n\\phi(\\mathbf{k}) = \\frac{2.65 \\times 10^{17}}{\\,1.602 \\times 10^{-19}\\, \\times \\left(1.537 \\times 10^{34}\\right)}\n= \\frac{2.65 \\times 10^{17}}{2.462 \\times 10^{15}} = 107.636...\n$$\n\n因此，给定模式的静电势在四舍五入到四位有效数字后约为 $107.6$ 伏特。",
            "answer": "$$\\boxed{107.6}$$"
        }
    ]
}