{
    "hands_on_practices": [
        {
            "introduction": "The foundation of modeling RF-driven transport lies in understanding where the wave-particle interaction is strongest. This happens at spatial locations where the wave frequency matches a natural frequency of the particles, such as the cyclotron frequency. This first practice provides a fundamental calculation to pinpoint the location of the ion cyclotron resonance layer in a tokamak, connecting the external RF source parameters to the internal magnetic field structure. Mastering this calculation is the first step toward building predictive models of RF heating and current drive. ",
            "id": "4034062",
            "problem": "In quasi-linear modeling of Radio Frequency (RF)-driven transport in magnetized plasmas, the resonant interaction between waves and particles is localized where the particle’s cyclotron frequency matches the applied RF angular frequency. Consider a large-aspect-ratio tokamak with toroidal magnetic field on the outboard midplane given by the standard equilibrium scaling $B_{\\phi}(R) = B_{0}\\,R_{0}/R$, where $R$ is the major radius, $R_{0}$ is the magnetic axis major radius, and $B_{0}$ is the on-axis toroidal magnetic field. Assume the poloidal magnetic field is negligible for the purpose of locating the cyclotron resonance layer and that finite Larmor radius, relativistic, and Doppler-shift effects are negligible.\n\nStarting from the Lorentz force law for a charged particle in a static magnetic field, derive the cyclotron frequency for a minority ion species of charge $Z_{m} e$ and mass $m_{m}$. Then, imposing the fundamental ion cyclotron resonance condition that the RF angular frequency equals the local cyclotron frequency, determine the major-radius location $R_{\\text{res}}$ of the resonance layer as a function of $Z_{m}$, $e$, $m_{m}$, $B_{0}$, $R_{0}$, and the RF angular frequency $\\omega_{\\text{RF}}$.\n\nFinally, evaluate $R_{\\text{res}}$ numerically for an Ion Cyclotron Range of Frequencies (ICRF) minority heating scenario with the following parameters:\n- Magnetic axis major radius $R_{0} = 3.0\\,\\text{m}$,\n- On-axis toroidal field $B_{0} = 5.3\\,\\text{T}$,\n- Minority species is helium-$3$ with charge state $Z_{m} = 2$ and mass $m_{m} = 3\\,m_{p}$,\n- Proton mass $m_{p} = 1.67262192369 \\times 10^{-27}\\,\\text{kg}$,\n- Elementary charge $e = 1.602176634 \\times 10^{-19}\\,\\text{C}$,\n- RF frequency $f = 80.0\\,\\text{MHz}$, with $\\omega_{\\text{RF}} = 2\\pi f$.\n\nExpress your final numerical answer for $R_{\\text{res}}$ in meters and round to four significant figures.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It presents a standard calculation in the field of plasma physics concerning Ion Cyclotron Range of Frequencies (ICRF) heating in a tokamak. The provided parameters are physically realistic for a large fusion experiment.\n\nThe first step is to derive the cyclotron frequency, $\\omega_{c}$, for a charged particle in a static magnetic field. The motion of a particle with charge $q$ and mass $m$ in a magnetic field $\\vec{B}$ is governed by the Lorentz force law, $\\vec{F} = q(\\vec{v} \\times \\vec{B})$. Equating this to the Newtonian force, $\\vec{F} = m\\vec{a}$, we get the equation of motion:\n$$m \\frac{d\\vec{v}}{dt} = q(\\vec{v} \\times \\vec{B})$$\nThis equation describes a helical trajectory, where the particle undergoes uniform circular motion in the plane perpendicular to the magnetic field, superimposed with a constant velocity parallel to the field. The magnetic force provides the necessary centripetal force for the circular motion. For the component of velocity perpendicular to the field, $v_{\\perp}$, the magnitude of the force is $|F| = |q|v_{\\perp}B$. The centripetal acceleration for circular motion of radius $r_{L}$ (the Larmor radius) is $a_c = v_{\\perp}^{2}/r_{L}$. Applying Newton's second law in the perpendicular plane:\n$$|q|v_{\\perp}B = m \\frac{v_{\\perp}^{2}}{r_{L}}$$\nThe angular frequency of this gyromotion, known as the cyclotron frequency $\\omega_{c}$, is defined as $\\omega_{c} = v_{\\perp}/r_{L}$. From the force balance equation, we can solve for $\\omega_{c}$:\n$$\\omega_{c} = \\frac{|q|B}{m}$$\nFor the specified minority ion species, the charge is $q = Z_{m}e$ and the mass is $m = m_{m}$. Since $Z_{m}$ is the charge state number and $e$ is the elementary charge, both are defined as positive, so we have $|q| = Z_{m}e$. The magnetic field in the tokamak is primarily toroidal and varies with the major radius $R$ as $B(R) = B_{\\phi}(R) = B_{0}R_{0}/R$. Substituting these into the cyclotron frequency formula gives the local cyclotron frequency as a function of major radius:\n$$\\omega_{c,m}(R) = \\frac{Z_{m}e B(R)}{m_{m}} = \\frac{Z_{m}e}{m_{m}} \\frac{B_{0}R_{0}}{R}$$\nThe second step is to find the location of the fundamental cyclotron resonance, $R_{\\text{res}}$. This resonance occurs where the applied RF wave's angular frequency, $\\omega_{\\text{RF}}$, matches the local cyclotron frequency of the ion species, $\\omega_{c,m}(R)$. The resonance condition is:\n$$\\omega_{\\text{RF}} = \\omega_{c,m}(R_{\\text{res}})$$\nSubstituting the expression for $\\omega_{c,m}(R)$:\n$$\\omega_{\\text{RF}} = \\frac{Z_{m}e B_{0}R_{0}}{m_{m}R_{\\text{res}}}$$\nSolving for the resonance major radius, $R_{\\text{res}}$, we obtain the symbolic expression:\n$$R_{\\text{res}} = \\frac{Z_{m}e B_{0}R_{0}}{m_{m}\\omega_{\\text{RF}}}$$\nThe final step is to evaluate $R_{\\text{res}}$ numerically using the provided parameters:\nMagnetic axis major radius: $R_{0} = 3.0\\,\\text{m}$\nOn-axis toroidal field: $B_{0} = 5.3\\,\\text{T}$\nMinority species charge state: $Z_{m} = 2$\nMinority species mass: $m_{m} = 3\\,m_{p}$\nProton mass: $m_{p} = 1.67262192369 \\times 10^{-27}\\,\\text{kg}$\nElementary charge: $e = 1.602176634 \\times 10^{-19}\\,\\text{C}$\nRF frequency: $f = 80.0\\,\\text{MHz} = 80.0 \\times 10^{6}\\,\\text{Hz}$\n\nThe RF angular frequency is $\\omega_{\\text{RF}} = 2\\pi f$. Substituting this into the expression for $R_{\\text{res}}$:\n$$R_{\\text{res}} = \\frac{Z_{m}e B_{0}R_{0}}{m_{m}(2\\pi f)}$$\nNow we substitute the numerical values:\n$$m_{m} = 3 \\times (1.67262192369 \\times 10^{-27}\\,\\text{kg}) = 5.01786577107 \\times 10^{-27}\\,\\text{kg}$$\nPlugging all values into the equation for $R_{\\text{res}}$:\n$$R_{\\text{res}} = \\frac{(2)(1.602176634 \\times 10^{-19}\\,\\text{C})(5.3\\,\\text{T})(3.0\\,\\text{m})}{(3 \\times 1.67262192369 \\times 10^{-27}\\,\\text{kg})(2\\pi \\times 80.0 \\times 10^{6}\\,\\text{s}^{-1})}$$\n$$R_{\\text{res}} = \\frac{5.09483301764 \\times 10^{-18}\\,\\text{C}\\cdot\\text{T}\\cdot\\text{m}}{2.5222045500 \\times 10^{-18}\\,\\text{kg}\\cdot\\text{s}^{-1}}$$\nThe units simplify correctly to meters, as shown by dimensional analysis:\n$$ \\frac{\\text{C}\\cdot\\text{T}\\cdot\\text{m}}{\\text{kg}\\cdot\\text{s}^{-1}} = \\frac{(\\text{A}\\cdot\\text{s})\\cdot(\\text{kg}\\cdot\\text{s}^{-2}\\cdot\\text{A}^{-1})\\cdot\\text{m}}{\\text{kg}\\cdot\\text{s}^{-1}} = \\frac{\\text{kg}\\cdot\\text{m}\\cdot\\text{s}^{-1}}{\\text{kg}\\cdot\\text{s}^{-1}} = \\text{m} $$\nPerforming the calculation:\n$$R_{\\text{res}} \\approx 2.02000522... \\,\\text{m}$$\nRounding the result to four significant figures as requested:\n$$R_{\\text{res}} \\approx 2.020\\,\\text{m}$$\nThis result indicates that the resonance layer is located on the high-field side of the tokamak, as $R_{\\text{res}}  R_{0}$.",
            "answer": "$$\\boxed{2.020}$$"
        },
        {
            "introduction": "Moving from the continuous physics of the Fokker–Planck equation to a computational model requires careful consideration of the numerical algorithm. Explicit time-stepping schemes are straightforward to implement but are only stable for sufficiently small time steps, a constraint known as the Courant–Friedrichs–Lewy (CFL) condition. This exercise delves into the heart of numerical stability for diffusion problems, requiring you to derive the time step limit for a forward Euler scheme. Understanding this constraint is essential for developing efficient and reliable simulation tools. ",
            "id": "4034053",
            "problem": "Consider a one-dimensional velocity-space Fokker–Planck equation for electrons in a magnetized plasma subject to Radio Frequency (RF) waves, where quasi-linear (QL) diffusion in velocity space is modeled as\n$$\n\\frac{\\partial f(v,t)}{\\partial t} \\;=\\; \\frac{\\partial}{\\partial v}\\!\\left( D_{vv}(v)\\,\\frac{\\partial f(v,t)}{\\partial v} \\right).\n$$\nYou discretize the velocity space on a uniform grid with spacing $\\Delta v$ and approximate the divergence form using a conservative centered scheme with nodal values $f_{j}^{n} \\approx f(v_{j},t^{n})$ and face-centered diffusion $D_{j+\\frac{1}{2}} \\approx D_{vv}\\!\\left(v_{j+\\frac{1}{2}}\\right)$. The explicit forward Euler update is\n$$\nf_{j}^{n+1} \\;=\\; f_{j}^{n} \\;+\\; \\frac{\\Delta t}{\\Delta v}\\left[\\,J^{n}_{j+\\frac{1}{2}} \\;-\\; J^{n}_{j-\\frac{1}{2}}\\,\\right], \n\\quad\\text{where}\\quad \nJ^{n}_{j+\\frac{1}{2}} \\;=\\; -\\,D_{j+\\frac{1}{2}}^{n}\\,\\frac{f_{j+1}^{n} - f_{j}^{n}}{\\Delta v}.\n$$\nAssume periodic boundary conditions so that a Fourier-mode stability analysis is admissible when $D_{vv}$ is approximated by its maximum value. Let the diffusion be localized around a resonant velocity with a Gaussian profile\n$$\nD_{vv}(v) \\;=\\; D_{0}\\,\\exp\\!\\left(-\\frac{(v - v_{\\mathrm{res}})^{2}}{2\\,\\sigma^{2}}\\right),\n$$\nwith amplitude $D_{0}$, resonance $v_{\\mathrm{res}}$, and width $\\sigma$. The Courant–Friedrichs–Lewy (CFL) condition for stability of a diffusion operator is commonly written in the form\n$$\n\\Delta t \\;\\le\\; C\\,\\frac{\\Delta v^{2}}{\\max_{v} D_{vv}(v)},\n$$\nwhere $C$ is a scheme-dependent constant. Starting from the discrete operator defined above, use a von Neumann analysis for the constant-coefficient case to determine the constant $C$ for the explicit forward Euler scheme and justify the replacement $\\max_{v} D_{vv}(v)$ for variable coefficients. Briefly contrast the stability properties of a semi-implicit Crank–Nicolson scheme and a fully implicit backward Euler scheme for the same operator.\n\nTake the following physically consistent parameters:\n- Grid spacing $\\Delta v = 1.0 \\times 10^{5}$ m/s.\n- Amplitude $D_{0} = 4.0 \\times 10^{11}$ m$^{2}$/s$^{3}$.\n- Resonance $v_{\\mathrm{res}} = 2.5 \\times 10^{6}$ m/s.\n- Width $\\sigma = 3.0 \\times 10^{5}$ m/s.\n\nAssume that $D_{vv}(v)$ attains its maximum at $v = v_{\\mathrm{res}}$. Compute the maximum stable timestep for the explicit scheme based on your derived $C$ and the given parameters. Express the final timestep in seconds and round your answer to four significant figures. The final reported answer must be only this timestep.",
            "solution": "The fundamental base is the one-dimensional Fokker–Planck equation with quasi-linear diffusion,\n$$\n\\frac{\\partial f(v,t)}{\\partial t} \\;=\\; \\frac{\\partial}{\\partial v}\\!\\left( D_{vv}(v)\\,\\frac{\\partial f(v,t)}{\\partial v} \\right),\n$$\nwhich represents conservative diffusion in velocity space driven by Radio Frequency waves. On a uniform grid with spacing $\\Delta v$, a consistent second-order conservative discretization for the diffusive flux is\n$$\nJ_{j+\\frac{1}{2}} \\;=\\; -\\,D_{j+\\frac{1}{2}}\\;\\frac{f_{j+1}-f_{j}}{\\Delta v},\n$$\nand the divergence is approximated by\n$$\n\\left.\\frac{\\partial J}{\\partial v}\\right|_{v_j} \\;\\approx\\; \\frac{J_{j+\\frac{1}{2}} - J_{j-\\frac{1}{2}}}{\\Delta v}.\n$$\nUsing explicit forward Euler in time, the fully discrete update is\n$$\nf^{n+1}_{j} \\;=\\; f^{n}_{j} \\;+\\; \\frac{\\Delta t}{\\Delta v}\\left[\\,J^{n}_{j+\\frac{1}{2}} - J^{n}_{j-\\frac{1}{2}}\\,\\right].\n$$\n\nTo analyze stability, we first consider the constant-coefficient case $D_{vv}(v) \\equiv D$ with periodic boundary conditions. In this case, the discrete operator reduces to $D$ times the standard second-difference (discrete Laplacian). Indeed,\n$$\n\\frac{J_{j+\\frac{1}{2}} - J_{j-\\frac{1}{2}}}{\\Delta v}\n\\;=\\;\n-\\,\\frac{D}{\\Delta v}\\left[\\frac{f_{j+1}-f_{j}}{\\Delta v} - \\frac{f_{j}-f_{j-1}}{\\Delta v}\\right]\n\\;=\\;\nD\\,\\frac{f_{j+1} - 2 f_{j} + f_{j-1}}{\\Delta v^{2}}.\n$$\nTherefore, the semi-discrete system is\n$$\n\\frac{d f_{j}}{dt} \\;=\\; D\\,\\frac{f_{j+1} - 2 f_{j} + f_{j-1}}{\\Delta v^{2}},\n$$\nand the forward Euler update becomes\n$$\nf^{n+1}_{j} \\;=\\; f^{n}_{j} \\;+\\; \\Delta t\\,D\\,\\frac{f^{n}_{j+1} - 2 f^{n}_{j} + f^{n}_{j-1}}{\\Delta v^{2}}.\n$$\nFor von Neumann analysis, consider a Fourier mode $f^{n}_{j} = \\hat{f}^{n}\\,\\exp(i k v_{j})$ with $v_{j} = j\\,\\Delta v$ and wavenumber $k$. Substituting into the update yields the amplification factor $g(k)$:\n$$\ng(k) \\;=\\; 1 + \\Delta t\\,D\\,\\frac{\\exp(i k \\Delta v) - 2 + \\exp(-i k \\Delta v)}{\\Delta v^{2}}\n\\;=\\; 1 - \\Delta t\\,D\\,\\frac{4 \\sin^{2}\\!\\left(\\frac{k \\Delta v}{2}\\right)}{\\Delta v^{2}}.\n$$\nStability of forward Euler for real negative coefficients requires $|g(k)| \\le 1$ for all $k$. Since $g(k)$ is real and decreases with $\\sin^{2}(k \\Delta v/2)$, the most restrictive condition occurs at the highest resolvable wavenumber where $\\sin^{2}(k \\Delta v/2) = 1$. Thus,\n$$\ng_{\\min} \\;=\\; 1 \\;-\\; \\Delta t\\,D\\,\\frac{4}{\\Delta v^{2}}.\n$$\nThe forward Euler stability interval on the negative real axis is $-2 \\le \\Delta t\\,D\\,\\lambda \\le 0$ when $\\lambda \\le 0$. Translating to this discrete operator gives\n$$\n-2 \\;\\le\\; -\\,\\Delta t\\,D\\,\\frac{4}{\\Delta v^{2}} \\;\\le\\; 0\n\\quad\\Rightarrow\\quad\n\\Delta t \\;\\le\\; \\frac{\\Delta v^{2}}{2 D}.\n$$\nTherefore, the scheme-dependent constant for the explicit forward Euler with second-order central differences is\n$$\nC \\;=\\; \\frac{1}{2}.\n$$\n\nFor variable coefficients $D_{vv}(v)$, the discrete operator in conservative form remains symmetric negative semidefinite. A sufficient stability condition for the explicit scheme can be obtained by bounding the spectral radius using the largest local diffusivity. This yields\n$$\n\\Delta t \\;\\le\\; \\frac{\\Delta v^{2}}{2\\,\\max_{v} D_{vv}(v)},\n$$\nwhich is the diffusion Courant–Friedrichs–Lewy (CFL) condition with $C = 1/2$ and $\\max_{v} D_{vv}(v)$ replacing $D$.\n\nWe now contrast with semi-implicit and fully implicit schemes:\n\n1. Crank–Nicolson (semi-implicit) scheme for diffusion is defined by trapezoidal time integration of the linear operator, leading to an amplification factor\n$$\ng_{\\mathrm{CN}}(k) \\;=\\; \\frac{1 - \\frac{\\Delta t}{2}\\,D\\,\\frac{4 \\sin^{2}(k \\Delta v/2)}{\\Delta v^{2}}}{1 + \\frac{\\Delta t}{2}\\,D\\,\\frac{4 \\sin^{2}(k \\Delta v/2)}{\\Delta v^{2}}}.\n$$\nFor $D \\ge 0$, $|g_{\\mathrm{CN}}(k)| \\le 1$ for any $\\Delta t > 0$, so Crank–Nicolson is unconditionally stable (A-stable) for this linear diffusion operator.\n\n2. Backward Euler (fully implicit) scheme has amplification factor\n$$\ng_{\\mathrm{BE}}(k) \\;=\\; \\frac{1}{1 + \\Delta t\\,D\\,\\frac{4 \\sin^{2}(k \\Delta v/2)}{\\Delta v^{2}}},\n$$\nwhich satisfies $0  |g_{\\mathrm{BE}}(k)| \\le 1$ for all $\\Delta t > 0$. Thus, backward Euler is also unconditionally stable.\n\nFinally, we compute the explicit maximum stable timestep for the given parameters. The Gaussian profile attains its maximum at the resonance, so\n$$\n\\max_{v} D_{vv}(v) \\;=\\; D_{vv}(v_{\\mathrm{res}}) \\;=\\; D_{0}.\n$$\nWith $\\Delta v = 1.0 \\times 10^{5}$ and $D_{0} = 4.0 \\times 10^{11}$, we have\n$$\n\\Delta v^{2} \\;=\\; (1.0 \\times 10^{5})^{2} \\;=\\; 1.0 \\times 10^{10},\n$$\nand the CFL limit for the explicit scheme is\n$$\n\\Delta t_{\\max} \\;=\\; \\frac{\\Delta v^{2}}{2\\,D_{0}}\n\\;=\\; \\frac{1.0 \\times 10^{10}}{2 \\times 4.0 \\times 10^{11}}\n\\;=\\; \\frac{1.0 \\times 10^{10}}{8.0 \\times 10^{11}}\n\\;=\\; 1.25 \\times 10^{-2}.\n$$\nExpressed in seconds and rounded to four significant figures, the maximum stable timestep is $1.250 \\times 10^{-2}$.",
            "answer": "$$\\boxed{1.250 \\times 10^{-2}}$$"
        },
        {
            "introduction": "Realistic transport modeling in a tokamak must account for the complex orbital trajectories of particles, which are classified as either 'passing' or 'trapped'. The effect of RF waves on a particle is determined by the cumulative interactions along its entire orbit, a concept captured by bounce-averaging the quasi-linear diffusion coefficient. This advanced practice guides you through the implementation of a bounce-averaging algorithm, a cornerstone of modern transport codes. You will confront and solve the numerical challenge of handling integrable singularities that arise at the turning points of trapped particle orbits, a common feature in kinetic calculations. ",
            "id": "4034073",
            "problem": "Implement a complete, runnable program that computes a bounce-averaged quasi-linear diffusion coupling for a simplified large-aspect-ratio tokamak model, suitable for modeling Radio Frequency (RF) driven transport. The task is to integrate a model diffusion tensor along guiding-center orbits and produce the bounce average. All quantities are to be treated as dimensionless, and angles must be in radians.\n\nThe fundamental base shall be the following, which is to be used to derive the algorithm:\n- Guiding-center invariants: total speed $v$ and magnetic moment $\\mu$.\n- The magnetic field variation on a circular, large-aspect-ratio tokamak, $B(\\theta) = B_0 (1 + \\epsilon \\cos \\theta)$ with $B_0$ normalized to $1$ and $0  \\epsilon  1$.\n- The pitch parameter $\\lambda = \\mu B_0 / (m v^2/2)$ that classifies orbits into trapped or passing.\n- Parallel velocity along the field line given by $v_\\parallel(\\theta) = v \\sqrt{1 - \\lambda \\, B(\\theta)/B_0}$, assuming constant $v$ and $\\mu$.\n- Time element from the guiding-center equation along the field line: $dt = (q R_0 / |v_\\parallel(\\theta)|) \\, d\\theta$, where $q$ is the safety factor and $R_0$ is the major radius.\n\nThe bounce average of a quantity $D(\\theta)$ along a trapped orbit is defined as\n$$\n\\langle D \\rangle_{\\text{bounce}} = \\frac{1}{T_b} \\, \\oint D(\\theta) \\, dt,\n$$\nwhere the bounce period is\n$$\nT_b = \\oint dt.\n$$\nFor passing orbits, replace the bounce average with the transit average over one poloidal period $0 \\le \\theta  2\\pi$,\n$$\n\\langle D \\rangle_{\\text{transit}} = \\frac{1}{T_t} \\int_0^{2\\pi} D(\\theta) \\, dt, \\quad T_t = \\int_0^{2\\pi} dt.\n$$\n\nYou must implement a model of the quasi-linear diffusion tensor $D_{ij}(\\mathbf{r},\\mathbf{v})$ that captures resonant RF coupling in a simplified but scientifically plausible form. For this assignment, use the following two scalar components, parameterized by $D_0$, resonance speed $v_{\\text{res}}$, spectral width $\\sigma_v$, RF poloidal asymmetry amplitude $a_{\\text{rf}}$, RF phase $\\theta_{\\text{rf}}$, and field-scaling exponent $\\alpha$:\n- Parallel diffusion component\n$$\nD_{\\parallel\\parallel}(\\theta) = D_0 \\, \\exp\\!\\left(-\\frac{(v_\\parallel(\\theta) - v_{\\text{res}})^2}{2 \\sigma_v^2}\\right) \\, \\left[ 1 + a_{\\text{rf}} \\cos\\!\\left(\\theta - \\theta_{\\text{rf}}\\right) \\right],\n$$\n- Perpendicular diffusion component\n$$\nD_{\\perp\\perp}(\\theta) = D_0 \\, \\left( \\frac{B(\\theta)}{B_0} \\right)^{\\alpha} \\, \\exp\\!\\left(-\\frac{(v_\\parallel(\\theta) - v_{\\text{res}})^2}{2 \\sigma_v^2}\\right).\n$$\n\nYou must compute the appropriate average for each orbit type:\n- If the orbit is passing, detect $1 - \\lambda (1 + \\epsilon) \\ge 0$ and compute the transit average over $0 \\le \\theta \\le 2\\pi$.\n- If the orbit is trapped, detect $1 - \\lambda (1 + \\epsilon)  0$, compute turning points at angles $\\pm \\theta_b$ such that $v_\\parallel(\\theta_b)=0$, and compute the bounce average over the trapped domain $-\\theta_b \\le \\theta \\le \\theta_b$.\n\nYou must implement and compare three numerical quadrature choices for the time-weighted integrals:\n1. Uniform-grid trapezoidal rule.\n2. Gauss–Legendre quadrature with fixed number of nodes.\n3. Adaptive quadrature with error control.\n\nNear trapped-particle turning points, the time-weighted integrand behaves as $1/\\sqrt{\\text{distance to the turning point}}$. To ensure numerical stability, you must select a variable substitution that removes endpoint singularities for methods (1) and (2), and use an adaptive integrator for method (3). A valid substitution is $\\theta = \\theta_b \\sin \\phi$ with $\\phi \\in [-\\pi/2, \\pi/2]$, so that $d\\theta = \\theta_b \\cos \\phi \\, d\\phi$ and the integrand remains finite at the endpoints.\n\nYour program must implement the following steps for each test case:\n- Determine whether the orbit is passing or trapped using $1 - \\lambda (1 + \\epsilon)$.\n- Compute the appropriate average for $D_{\\parallel\\parallel}(\\theta)$ and $D_{\\perp\\perp}(\\theta)$ using each of the three quadrature methods.\n- Return, for each test case, a list of six floats in the order\n$$\n[\\langle D_{\\parallel\\parallel} \\rangle_{\\text{trap}}, \\langle D_{\\parallel\\parallel} \\rangle_{\\text{gauss}}, \\langle D_{\\parallel\\parallel} \\rangle_{\\text{adaptive}}, \\langle D_{\\perp\\perp} \\rangle_{\\text{trap}}, \\langle D_{\\perp\\perp} \\rangle_{\\text{gauss}}, \\langle D_{\\perp\\perp} \\rangle_{\\text{adaptive}}].\n$$\nIf the orbit is passing, interpret $\\langle \\cdot \\rangle_{\\text{trap}}$ as the transit average computed with the corresponding quadrature choice.\n\nTest suite and parameters (all dimensionless):\n- Case $1$ (passing, near resonance):\n  - $\\epsilon = 0.3$, $\\lambda = 0.5$, $v = 1.0$, $q = 1.7$, $R_0 = 3.0$, $D_0 = 0.01$, $v_{\\text{res}} = 0.7$, $\\sigma_v = 0.15$, $a_{\\text{rf}} = 0.2$, $\\theta_{\\text{rf}} = 0.0$, $\\alpha = 0.5$.\n- Case $2$ (marginally trapped, sensitive endpoints):\n  - $\\epsilon = 0.3$, $\\lambda = 0.78$, $v = 1.0$, $q = 1.7$, $R_0 = 3.0$, $D_0 = 0.01$, $v_{\\text{res}} = 0.7$, $\\sigma_v = 0.15$, $a_{\\text{rf}} = 0.2$, $\\theta_{\\text{rf}} = 0.0$, $\\alpha = 0.5$.\n- Case $3$ (deeply trapped, strong endpoint behavior):\n  - $\\epsilon = 0.3$, $\\lambda = 0.95$, $v = 1.0$, $q = 1.7$, $R_0 = 3.0$, $D_0 = 0.01$, $v_{\\text{res}} = 0.7$, $\\sigma_v = 0.15$, $a_{\\text{rf}} = 0.2$, $\\theta_{\\text{rf}} = 0.0$, $\\alpha = 0.5$.\n- Case $4$ (passing, off-resonance):\n  - $\\epsilon = 0.3$, $\\lambda = 0.5$, $v = 1.0$, $q = 1.7$, $R_0 = 3.0$, $D_0 = 0.01$, $v_{\\text{res}} = 2.0$, $\\sigma_v = 0.15$, $a_{\\text{rf}} = 0.2$, $\\theta_{\\text{rf}} = 0.0$, $\\alpha = 0.5$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, one inner list per test case, in the specified order. For example:\n$[$$[r_{1,1},r_{1,2},r_{1,3},r_{1,4},r_{1,5},r_{1,6}]$$,$$[r_{2,1},\\dots,r_{2,6}]$$,$$\\dots$$]$.",
            "solution": "The problem requires the computation of bounce-averaged or transit-averaged quasi-linear diffusion coefficients for a particle in a simplified large-aspect-ratio tokamak magnetic field. The solution necessitates a careful implementation of numerical integration techniques, including provisions for handling integrable singularities that arise in the case of trapped particle orbits.\n\nFirst, we establish the physical and mathematical framework provided. The system is described by a set of dimensionless parameters and functions. The magnetic field strength along a field line is given by $B(\\theta) = B_0 (1 + \\epsilon \\cos \\theta)$, where $\\theta$ is the poloidal angle. We are given $B_0=1$. The particle's state is characterized by its total speed $v$ and magnetic moment $\\mu$, which are invariants of motion. The pitch parameter, $\\lambda = \\mu B_0 / (m v^2/2)$, is a convenient dimensionless quantity combining these invariants. The particle's parallel velocity along the magnetic field line is derived from energy conservation and is given by $v_\\parallel(\\theta) = v \\sqrt{1 - \\lambda B(\\theta)/B_0}$.\n\nThe core of the problem is to compute the average of a quantity $D(\\theta)$ over a particle's orbit. The type of average depends on the particle's orbit classification, which is determined by the sign of $v_\\parallel^2$ over the entire poloidal domain $\\theta \\in [0, 2\\pi]$.\nThe condition for a particle to be passing is that its parallel velocity never vanishes, which means $1 - \\lambda B(\\theta)/B_0 \\ge 0$ for all $\\theta$. Since $B(\\theta)$ is maximum at $\\theta=0$, this condition simplifies to $1 - \\lambda (1+\\epsilon) \\ge 0$.\nThe condition for a particle to be trapped is that its parallel velocity becomes zero at some points, i.e., $1 - \\lambda (1+\\epsilon)  0$. These points are the turning points or \"banana tips\" of the orbit. The turning points $\\pm\\theta_b$ are found by solving $v_\\parallel(\\pm\\theta_b) = 0$, which yields $1 - \\lambda(1 + \\epsilon \\cos\\theta_b) = 0$, or $\\theta_b = \\arccos\\left(\\frac{1/\\lambda - 1}{\\epsilon}\\right)$. A trapped particle is confined to the region $-\\theta_b \\le \\theta \\le \\theta_b$.\n\nThe time element for integration along the guiding-center orbit is $dt = (q R_0 / |v_\\parallel(\\theta)|) d\\theta$. The bounce/transit average of a quantity $D(\\theta)$ is defined as $\\langle D \\rangle = \\frac{\\oint D(\\theta) dt}{\\oint dt}$. The constant factor $q R_0$ appears in both the numerator and the denominator, and thus cancels out. The resulting expressions are:\nFor passing orbits (transit average):\n$$\n\\langle D \\rangle_{\\text{transit}} = \\frac{\\int_0^{2\\pi} D(\\theta)/|v_\\parallel(\\theta)| \\, d\\theta}{\\int_0^{2\\pi} 1/|v_\\parallel(\\theta)| \\, d\\theta}\n$$\nFor trapped orbits (bounce average):\n$$\n\\langle D \\rangle_{\\text{bounce}} = \\frac{\\oint D(\\theta)/|v_\\parallel(\\theta)| \\, d\\theta}{\\oint 1/|v_\\parallel(\\theta)| \\, d\\theta} = \\frac{2 \\int_{-\\theta_b}^{\\theta_b} D(\\theta)/|v_\\parallel(\\theta)| \\, d\\theta}{2 \\int_{-\\theta_b}^{\\theta_b} 1/|v_\\parallel(\\theta)| \\, d\\theta}\n$$\nGiven that both diffusion coefficient models, $D_{\\parallel\\parallel}(\\theta)$ and $D_{\\perp\\perp}(\\theta)$, are even functions of $\\theta$ (since $\\theta_{\\text{rf}} = 0$ in all test cases), the integrals can be simplified:\n$$\n\\langle D \\rangle_{\\text{bounce}} = \\frac{\\int_0^{\\theta_b} D(\\theta)/|v_\\parallel(\\theta)| \\, d\\theta}{\\int_0^{\\theta_b} 1/|v_\\parallel(\\theta)| \\, d\\theta}\n$$\n\nThe diffusion coefficients to be averaged are the parallel component:\n$$\nD_{\\parallel\\parallel}(\\theta) = D_0 \\, \\exp\\!\\left(-\\frac{(v_\\parallel(\\theta) - v_{\\text{res}})^2}{2 \\sigma_v^2}\\right) \\, \\left[ 1 + a_{\\text{rf}} \\cos\\!\\left(\\theta - \\theta_{\\text{rf}}\\right) \\right]\n$$\nand the perpendicular component:\n$$\nD_{\\perp\\perp}(\\theta) = D_0 \\, \\left( \\frac{B(\\theta)}{B_0} \\right)^{\\alpha} \\, \\exp\\!\\left(-\\frac{(v_\\parallel(\\theta) - v_{\\text{res}})^2}{2 \\sigma_v^2}\\right)\n$$\nwhere $D_0, v_{\\text{res}}, \\sigma_v, a_{\\text{rf}}, \\theta_{\\text{rf}}, \\alpha$ are given parameters.\n\nThe numerical implementation must address three different quadrature methods.\nFor passing orbits, the integrands are continuous and well-behaved over the interval $[0, 2\\pi]$, so standard quadrature schemes can be applied directly.\nFor trapped orbits, the term $1/|v_\\parallel(\\theta)|$ introduces an integrable singularity at the turning point $\\theta = \\theta_b$, because $v_\\parallel(\\theta) \\propto \\sqrt{\\cos\\theta - \\cos\\theta_b} \\approx \\sqrt{(\\theta_b-\\theta)\\sin\\theta_b}$ for $\\theta \\approx \\theta_b$. The integrand behaves as $1/\\sqrt{\\theta_b - \\theta}$ near the upper limit.\n\nThe three specified numerical integration methods are implemented as follows:\n$1$. **Uniform-grid Trapezoidal Rule**: For trapped orbits, to handle the singularity, we employ the specified change of variables: $\\theta = \\theta_b \\sin\\phi$. This maps the integration domain $\\theta \\in [0, \\theta_b]$ to $\\phi \\in [0, \\pi/2]$. The differential element becomes $d\\theta = \\theta_b \\cos\\phi \\, d\\phi$. The integrand $f(\\theta)/|v_\\parallel(\\theta)|$ transforms into a new function of $\\phi$, $g(\\phi) = \\frac{f(\\theta_b \\sin\\phi)}{|v_\\parallel(\\theta_b \\sin\\phi)|} \\theta_b \\cos\\phi$. Near the singularity at $\\theta=\\theta_b$, which corresponds to $\\phi=\\pi/2$, the behavior of $|v_\\parallel|$ is proportional to $\\sqrt{\\cos\\phi}$, while the numerator contains a $\\cos\\phi$ term. Thus, the transformed integrand goes to a finite value as $\\phi \\to \\pi/2$, removing the singularity. The trapezoidal rule is then applied to a uniform grid in $\\phi$. For passing orbits, the trapezoidal rule is applied directly on a uniform grid in $\\theta \\in [0, 2\\pi]$.\n\n$2$. **Gauss-Legendre Quadrature**: This method is highly efficient for smooth functions. For trapped orbits, it requires the same singularity-removing transformation $\\theta = \\theta_b \\sin\\phi$ as the trapezoidal rule. The integration is then performed over $\\phi \\in [0, \\pi/2]$ using a fixed number of nodes. For passing orbits, the method is applied directly over $\\theta \\in [0, 2\\pi]$.\n\n$3$. **Adaptive Quadrature**: We use `scipy.integrate.quad`, a powerful routine from the SciPy library. This integrator uses an adaptive algorithm that automatically refines the subintervals of integration, particularly around difficult regions like singularities, to achieve a specified error tolerance. It is capable of handling the integrable square-root singularity in the trapped-particle case directly, without any change of variables. Therefore, for both passing and trapped cases, we can apply this method to the original integrands over their respective domains, $[0, 2\\pi]$ or $[0, \\theta_b]$.\n\nThe algorithm proceeds by first classifying the orbit based on the parameters $\\epsilon$ and $\\lambda$. Then, for each of the two diffusion components, $D_{\\parallel\\parallel}$ and $D_{\\perp\\perp}$, it computes the required integrals for the numerator (e.g., $\\int D_{\\parallel\\parallel}/|v_\\parallel| d\\theta$) and the denominator ($\\int 1/|v_\\parallel| d\\theta$) using each of the three quadrature methods. Finally, the ratio of these integrals is taken to find the average, and the six resulting values are compiled for each test case.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad, fixed_quad\n\ndef solve():\n    \"\"\"\n    Main function to solve the bounce-averaged quasi-linear diffusion problem\n    for the specified test cases.\n    \"\"\"\n\n    # Test cases as provided in the problem statement.\n    test_cases = [\n        # Case 1 (passing, near resonance)\n        {'epsilon': 0.3, 'lam': 0.5, 'v': 1.0, 'q': 1.7, 'R0': 3.0, 'D0': 0.01,\n         'v_res': 0.7, 'sigma_v': 0.15, 'a_rf': 0.2, 'theta_rf': 0.0, 'alpha': 0.5},\n        # Case 2 (marginally trapped, sensitive endpoints)\n        {'epsilon': 0.3, 'lam': 0.78, 'v': 1.0, 'q': 1.7, 'R0': 3.0, 'D0': 0.01,\n         'v_res': 0.7, 'sigma_v': 0.15, 'a_rf': 0.2, 'theta_rf': 0.0, 'alpha': 0.5},\n        # Case 3 (deeply trapped, strong endpoint behavior)\n        {'epsilon': 0.3, 'lam': 0.95, 'v': 1.0, 'q': 1.7, 'R0': 3.0, 'D0': 0.01,\n         'v_res': 0.7, 'sigma_v': 0.15, 'a_rf': 0.2, 'theta_rf': 0.0, 'alpha': 0.5},\n        # Case 4 (passing, off-resonance)\n        {'epsilon': 0.3, 'lam': 0.5, 'v': 1.0, 'q': 1.7, 'R0': 3.0, 'D0': 0.01,\n         'v_res': 2.0, 'sigma_v': 0.15, 'a_rf': 0.2, 'theta_rf': 0.0, 'alpha': 0.5},\n    ]\n\n    # Parameters for numerical integration methods\n    N_TRAPZ_POINTS = 4001 # Number of points for trapezoidal rule\n    N_GAUSS_POINTS = 200   # Number of nodes for Gauss-Legendre quadrature\n\n    results = []\n    for params in test_cases:\n        results.append(compute_averages_for_case(params, N_TRAPZ_POINTS, N_GAUSS_POINTS))\n\n    # Format the final output as a string representing a list of lists.\n    output_str = \"[\" + \",\".join([f\"[{','.join(map(str, r))}]\" for r in results]) + \"]\"\n    print(output_str)\n\ndef compute_averages_for_case(params, n_trapz_points, n_gauss_points):\n    \"\"\"\n    Computes quake-linear averages for a single set of physical parameters.\n    \"\"\"\n    # Unpack parameters\n    eps = params['epsilon']\n    lam = params['lam']\n    v = params['v']\n    D0 = params['D0']\n    v_res = params['v_res']\n    sigma_v = params['sigma_v']\n    a_rf = params['a_rf']\n    theta_rf = params['theta_rf']\n    alpha = params['alpha']\n    \n    # B0 is normalized to 1\n    B0 = 1.0\n\n    # Define physical functions\n    def B_field(theta):\n        return B0 * (1.0 + eps * np.cos(theta))\n\n    def v_parallel(theta):\n        # Use np.maximum to avoid sqrt of small negative numbers due to precision\n        radicand = 1.0 - lam * B_field(theta) / B0\n        return v * np.sqrt(np.maximum(0.0, radicand))\n\n    def resonance_factor(theta):\n        vp = v_parallel(theta)\n        return np.exp(-(vp - v_res)**2 / (2 * sigma_v**2))\n\n    def D_parallel(theta):\n        res_factor = resonance_factor(theta)\n        return D0 * res_factor * (1.0 + a_rf * np.cos(theta - theta_rf))\n\n    def D_perpendicular(theta):\n        res_factor = resonance_factor(theta)\n        return D0 * (B_field(theta) / B0)**alpha * res_factor\n\n    # Determine orbit type\n    is_passing = (1.0 - lam * (1.0 + eps)) >= -1e-12 # Tolerance for float comparison\n\n    # --- Integrands for averaging ---\n    # The integrands are of the form X(theta) / |v_parallel(theta)|\n    # A small epsilon is added to the denominator to prevent division by zero at exact\n    # turning points, which can occur with discrete evaluation.\n    # The adaptive method handles this naturally, but fixed-grid methods need care.\n    den_eps = 1e-15\n    \n    def integrand_den(theta):\n        return 1.0 / (np.abs(v_parallel(theta)) + den_eps)\n    \n    def integrand_num_par(theta):\n        return D_parallel(theta) / (np.abs(v_parallel(theta)) + den_eps)\n        \n    def integrand_num_perp(theta):\n        return D_perpendicular(theta) / (np.abs(v_parallel(theta)) + den_eps)\n\n    case_results = []\n    \n    if is_passing:\n        # --- PASSING ORBIT ---\n        # Integration over [0, 2*pi]\n        a, b = 0.0, 2.0 * np.pi\n\n        # Method 1: Trapezoidal rule\n        theta_grid = np.linspace(a, b, n_trapz_points)\n        integral_den_trap = np.trapz(integrand_den(theta_grid), theta_grid)\n        integral_num_par_trap = np.trapz(integrand_num_par(theta_grid), theta_grid)\n        integral_num_perp_trap = np.trapz(integrand_num_perp(theta_grid), theta_grid)\n\n        # Method 2: Gauss-Legendre quadrature\n        integral_den_gauss = fixed_quad(integrand_den, a, b, n=n_gauss_points)[0]\n        integral_num_par_gauss = fixed_quad(integrand_num_par, a, b, n=n_gauss_points)[0]\n        integral_num_perp_gauss = fixed_quad(integrand_num_perp, a, b, n=n_gauss_points)[0]\n\n        # Method 3: Adaptive quadrature\n        integral_den_quad = quad(integrand_den, a, b)[0]\n        integral_num_par_quad = quad(integrand_num_par, a, b)[0]\n        integral_num_perp_quad = quad(integrand_num_perp, a, b)[0]\n\n    else:\n        # --- TRAPPED ORBIT ---\n        # Calculate turning point theta_b\n        cos_theta_b_arg = (1.0 / lam - 1.0) / eps\n        # Clamp argument to arccos to handle potential floating point errors\n        theta_b = np.arccos(np.clip(cos_theta_b_arg, -1.0, 1.0))\n        \n        # Integration over [0, theta_b]\n        a, b = 0.0, theta_b\n        \n        # --- Methods 1  2: Use variable substitution theta = theta_b * sin(phi) ---\n        a_phi, b_phi = 0.0, np.pi / 2.0\n\n        def create_transformed_integrand(integrand_func):\n            def transformed_integrand(phi):\n                theta = theta_b * np.sin(phi)\n                # The d_theta term from the substitution\n                d_theta_d_phi = theta_b * np.cos(phi)\n                return integrand_func(theta) * d_theta_d_phi\n            return transformed_integrand\n\n        integrand_den_phi = create_transformed_integrand(integrand_den)\n        integrand_num_par_phi = create_transformed_integrand(integrand_num_par)\n        integrand_num_perp_phi = create_transformed_integrand(integrand_num_perp)\n\n        # Method 1: Trapezoidal rule on transformed integrand\n        phi_grid = np.linspace(a_phi, b_phi, n_trapz_points)\n        integral_den_trap = np.trapz(integrand_den_phi(phi_grid), phi_grid)\n        integral_num_par_trap = np.trapz(integrand_num_par_phi(phi_grid), phi_grid)\n        integral_num_perp_trap = np.trapz(integrand_num_perp_phi(phi_grid), phi_grid)\n\n        # Method 2: Gauss-Legendre on transformed integrand\n        integral_den_gauss = fixed_quad(integrand_den_phi, a_phi, b_phi, n=n_gauss_points)[0]\n        integral_num_par_gauss = fixed_quad(integrand_num_par_phi, a_phi, b_phi, n=n_gauss_points)[0]\n        integral_num_perp_gauss = fixed_quad(integrand_num_perp_phi, a_phi, b_phi, n=n_gauss_points)[0]\n\n        # --- Method 3: Adaptive quadrature on original singular integrand ---\n        integral_den_quad = quad(integrand_den, a, b)[0]\n        integral_num_par_quad = quad(integrand_num_par, a, b)[0]\n        integral_num_perp_quad = quad(integrand_num_perp, a, b)[0]\n\n    # Calculate averages. Handle potential division by zero.\n    avg_par_trap = integral_num_par_trap / integral_den_trap if integral_den_trap != 0 else 0.0\n    avg_par_gauss = integral_num_par_gauss / integral_den_gauss if integral_den_gauss != 0 else 0.0\n    avg_par_quad = integral_num_par_quad / integral_den_quad if integral_den_quad != 0 else 0.0\n    \n    avg_perp_trap = integral_num_perp_trap / integral_den_trap if integral_den_trap != 0 else 0.0\n    avg_perp_gauss = integral_num_perp_gauss / integral_den_gauss if integral_den_gauss != 0 else 0.0\n    avg_perp_quad = integral_num_perp_quad / integral_den_quad if integral_den_quad != 0 else 0.0\n\n    return [avg_par_trap, avg_par_gauss, avg_par_quad,\n            avg_perp_trap, avg_perp_gauss, avg_perp_quad]\n\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}