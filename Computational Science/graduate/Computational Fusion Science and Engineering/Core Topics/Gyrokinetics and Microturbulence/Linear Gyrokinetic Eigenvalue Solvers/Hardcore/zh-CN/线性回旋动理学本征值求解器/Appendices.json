{
    "hands_on_practices": [
        {
            "introduction": "在构建复杂的求解器之前，验证其核心组件的正确性至关重要。本练习聚焦于回旋平均算符 $\\Gamma_0$，该算符用于描述有限拉莫尔半径 (FLR) 效应，这是回旋动理学理论的基石。通过这项练习，你将亲手实现该算符，并对照其长波长近似来验证实现的准确性，从而掌握计算科学中验证代码和测试收敛阶数的基本技能。",
            "id": "4001870",
            "problem": "您的任务是设计并实现一个简短的收敛性研究，该研究旨在分离线性回旋动理学极限下回旋平均算符的影响，并量化长波范围内的误差标度。该研究必须完全由一个程序执行，并按如下规定产生单行输出。\n\n从以下基本基础开始：\n\n1. 线性化、无碰撞、静电回旋动理学描述通过第一类零阶贝塞尔函数 $J_0$ 引入了回旋平均算符。在对麦克斯韦分布进行速度空间平均时，这给出了标准函数\n$$\n\\Gamma_0(b_s) \\equiv I_0(b_s)\\,e^{-b_s},\n$$\n其中 $I_0$ 是第一类修正贝塞尔函数，$b_s \\equiv k_\\perp^2 \\rho_s^2$，$k_\\perp$ 是垂直波数，$\\rho_s$ 是粒子种类的拉莫尔半径。\n\n2. 在解析长波极限 $k_\\perp \\rho_s \\ll 1$下，我们有 $b_s \\ll 1$，小宗量展开得出\n$$\n\\Gamma_0(b_s) = 1 - b_s + \\mathcal{O}(b_s^2).\n$$\n\n3. 对于一个简单的静电漂移波类标量本征问题，其灵感来自于具有绝热电子和回旋动理学离子的准中性条件（忽略平行动态和无碰撞阻尼以分离有限拉莫尔半径效应），可以将模式频率 $\\omega$ 的广义本征值问题表示为以下形式\n$$\nA(b_s)\\,\\varphi = \\omega\\,B(b_s)\\,\\varphi,\n$$\n其中 $\\varphi$ 是标量势振幅，$A(b_s)$ 编码了抗磁驱动，$B(b_s)$ 编码了极化响应。保持小 $b_s$ 长波结构的最小闭合是\n$$\nA(b_s) = \\omega_\\star, \\qquad B(b_s) = 1 + \\alpha\\,[1 - \\Gamma_0(b_s)],\n$$\n其中 $\\omega_\\star$ 和 $\\alpha$ 为常数（均为无量纲）。在长波极限下，将 $\\Gamma_0(b_s)$ 替换为其一阶近似 $1 - b_s$ 会得到一个近似算符\n$$\nB_{\\text{lin}}(b_s) = 1 + \\alpha\\,b_s.\n$$\n当用其代替 $B(b_s)$ 时，会产生一个近似本征值 $\\omega_{\\text{lin}}$。\n\n您的程序必须执行以下操作：\n\n- 使用其定义 $\\Gamma_0(b_s) = I_0(b_s)\\,e^{-b_s}$ 计算精确的 $\\Gamma_0(b_s)$，并计算其长波近似 $\\Gamma_{0,\\text{lin}}(b_s) = 1 - b_s$。\n- 通过求解上述 $A$ 和 $B$（以及类似地对于 $B_{\\text{lin}}$）的广义本征问题 $A\\varphi = \\omega B \\varphi$，构建精确的标量本征值 $\\omega$ 及其长波近似 $\\omega_{\\text{lin}}$。这是一个 $1\\times 1$ 的广义本征问题，因此除了标量形式外，不需要进行矩阵组装；然而，其逻辑必须遵循本征问题的定义，而不是任何不相关的公式。\n\n- 量化相对误差\n$$\n\\varepsilon_{\\Gamma}(b_s) \\equiv \\frac{\\left|\\Gamma_0(b_s) - \\Gamma_{0,\\text{lin}}(b_s)\\right|}{\\left|\\Gamma_0(b_s)\\right|}, \\qquad\n\\varepsilon_{\\omega}(b_s) \\equiv \\frac{\\left|\\omega(b_s) - \\omega_{\\text{lin}}(b_s)\\right|}{\\left|\\omega(b_s)\\right|}.\n$$\n- 对 $b_s$ 值的几何序列使用对数-对数回归，估计经验标度指数 $p_\\Gamma$ 和 $p_\\omega$，它们由模型 $\\varepsilon_{\\Gamma}(b_s) \\approx C_\\Gamma\\,b_s^{p_\\Gamma}$ 和 $\\varepsilon_{\\omega}(b_s) \\approx C_\\omega\\,b_s^{p_\\omega}$ 中对小 $b_s$ 的最佳拟合斜率定义。基于小 $b_s$ 展开的理论表明，如果实现正确，$p_\\Gamma = 2$ 且 $p_\\omega = 2$，因为 $\\Gamma_0(b_s)$ 中被忽略的第一项是 $\\mathcal{O}(b_s^2)$ 并且本征值平滑地依赖于 $\\Gamma_0$。\n\n测试套件和所需输出：\n\n1. Gamma 函数标度测试：\n   - 使用 $b_s \\in \\{10^{-1}, 5\\times 10^{-2}, 2.5\\times 10^{-2}, 1.25\\times 10^{-2}, 6.25\\times 10^{-3}\\}$。\n   - 对每个 $b_s$ 计算 $\\varepsilon_{\\Gamma}(b_s)$，并通过 $\\log \\varepsilon_{\\Gamma}$ 对 $\\log b_s$ 的最小二乘拟合来估计 $p_\\Gamma$。\n\n2. 本征值标度测试（正常路径）：\n   - 参数：$\\alpha = 0.5$，$\\omega_\\star = 1.0$。\n   - 使用与第 1 项中相同的 $b_s$ 值集合。\n   - 对每个 $b_s$ 计算 $\\varepsilon_{\\omega}(b_s)$，并通过 $\\log \\varepsilon_{\\omega}$ 对 $\\log b_s$ 的最小二乘拟合来估计 $p_\\omega$。\n\n3. 本征值误差大小的边界小 $b_s$ 情况：\n   - 参数：$\\alpha = 0.5$，$\\omega_\\star = 1.0$。\n   - 使用单个值 $b_s = 10^{-8}$。\n   - 以浮点数形式计算绝对误差 $|\\omega(b_s) - \\omega_{\\text{lin}}(b_s)|$。\n\n4. 回旋平均函数的中等 $b_s$ 检查：\n   - 使用 $b_s = 10^{-1}$。\n   - 以浮点数形式计算绝对误差 $|\\Gamma_0(b_s) - \\Gamma_{0,\\text{lin}}(b_s)|$。\n\n此问题中的所有量都是无量纲的，并且必须无单位报告。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个逗号分隔的 Python 列表，该列表有四个条目：\n  - 第一个条目是估计的 $p_\\Gamma$，四舍五入到三位小数。\n  - 第二个条目是估计的 $p_\\omega$，四舍五入到三位小数。\n  - 第三个条目是第 3 项中的绝对误差，四舍五入到十二位小数。\n  - 第四个条目是第 4 项中的绝对误差，四舍五入到十二位小数。\n- 例如，语法正确的输出格式如下所示：“[2.000,2.000,0.000000000001,0.000123456789]”。您的值会有所不同，但格式必须匹配。\n\n您的程序必须是自包含的，不得读取任何输入，并且必须使用上面给出的指定测试套件值和参数选择。不允许有其他输出。",
            "solution": "问题陈述已经过仔细验证。它具有科学依据，问题提出得当且客观。解决一个唯一且有意义的解所需的所有定义、数据和参数均已提供。该问题是计算等离子体物理学中一个标准的、尽管简化的代码验证练习，旨在测试回旋平均算符的实现，并量化一个常见的长波近似的收敛阶。因此，该问题被认为是**有效的**。\n\n解决方案首先建立数学框架，然后概述每个指定任务的计算过程。\n\n### 数学公式\n\n问题的核心在于回旋平均算符，在静电回旋动理学模型中，它由函数 $\\Gamma_0(b_s)$ 表示。其形式化定义为：\n$$\n\\Gamma_0(b_s) = I_0(b_s) e^{-b_s}\n$$\n其中 $I_0$ 是第一类修正贝塞尔函数，$b_s = k_\\perp^2 \\rho_s^2$ 是一个无量纲参数，表示归一化到拉莫尔半径 $\\rho_s$ 的垂直波数 $k_\\perp$ 的平方。\n\n在长波极限下，即 $k_\\perp \\rho_s \\ll 1$ 从而 $b_s \\ll 1$ 时，$\\Gamma_0(b_s)$ 可以通过其在 $b_s=0$ 附近的泰勒级数展开来近似。$I_0(b_s)$ 的展开式为 $1 + \\frac{1}{4}b_s^2 + \\mathcal{O}(b_s^4)$，$e^{-b_s}$ 的展开式为 $1 - b_s + \\frac{1}{2}b_s^2 - \\frac{1}{6}b_s^3 + \\mathcal{O}(b_s^4)$。将这些级数相乘得到：\n$$\n\\Gamma_0(b_s) = \\left(1 + \\frac{1}{4}b_s^2 + \\dots\\right) \\left(1 - b_s + \\frac{1}{2}b_s^2 - \\dots\\right) = 1 - b_s + \\frac{3}{4}b_s^2 + \\mathcal{O}(b_s^3)\n$$\n问题通过在该级数的线性项后截断来定义长波近似：\n$$\n\\Gamma_{0,\\text{lin}}(b_s) = 1 - b_s\n$$\n因此，此近似中的主阶误差为 $\\mathcal{O}(b_s^2)$ 阶。\n\n问题引入了一个关于模式频率 $\\omega$ 的简单标量广义本征值问题：\n$$\nA(b_s)\\,\\varphi = \\omega\\,B(b_s)\\,\\varphi\n$$\n由于这是一个 $1 \\times 1$ 的系统（即所有量都是标量），本征值 $\\omega$ 可以直接求解：\n$$\n\\omega(b_s) = \\frac{A(b_s)}{B(b_s)}\n$$\n使用提供的 $A(b_s) = \\omega_\\star$ 和 $B(b_s) = 1 + \\alpha[1 - \\Gamma_0(b_s)]$ 的形式，我们得到精确的本征值：\n$$\n\\omega(b_s) = \\frac{\\omega_\\star}{1 + \\alpha[1 - \\Gamma_0(b_s)]}\n$$\n用其线性化对应项 $B_{\\text{lin}}(b_s) = 1 + \\alpha b_s$（通过在 $B(b_s)$ 的表达式中使用 $\\Gamma_{0,\\text{lin}}(b_s)$ 导出）替换精确算符 $B(b_s)$，我们得到近似本征值：\n$$\n\\omega_{\\text{lin}}(b_s) = \\frac{\\omega_\\star}{1 + \\alpha b_s}\n$$\n\n### 误差量化与标度分析\n\n$\\Gamma_0(b_s)$ 近似的相对误差定义为：\n$$\n\\varepsilon_{\\Gamma}(b_s) = \\frac{\\left|\\Gamma_0(b_s) - \\Gamma_{0,\\text{lin}}(b_s)\\right|}{\\left|\\Gamma_0(b_s)\\right|}\n$$\n给定泰勒级数，对于小的 $b_s$，分子为 $|\\frac{3}{4}b_s^2 + \\mathcal{O}(b_s^3)|$，分母为 $|1 - b_s + \\mathcal{O}(b_s^2)| \\approx 1$。因此，$\\varepsilon_{\\Gamma}(b_s) \\approx \\frac{3}{4}b_s^2$，这对应于一个标度模型 $\\varepsilon_{\\Gamma}(b_s) \\propto b_s^{p_\\Gamma}$，其预期的理论指数为 $p_\\Gamma = 2$。\n\n类似地，本征值的相对误差为：\n$$\n\\varepsilon_{\\omega}(b_s) = \\frac{\\left|\\omega(b_s) - \\omega_{\\text{lin}}(b_s)\\right|}{\\left|\\omega(b_s)\\right|}\n$$\n差值 $\\omega(b_s) - \\omega_{\\text{lin}}(b_s)$ 与 $B_{\\text{lin}}(b_s) - B(b_s)$ 成正比，而后者又与 $\\Gamma_0(b_s) - \\Gamma_{0,\\text{lin}}(b_s)$ 成正比。因此，误差也按 $\\mathcal{O}(b_s^2)$ 标度，所以我们预期 $p_\\omega = 2$。\n\n为了经验地估计指数 $p_\\Gamma$ 和 $p_\\omega$，我们使用对数-对数线性回归。对于形式为 $\\varepsilon = C b_s^p$ 的模型，取对数可得：\n$$\n\\log(\\varepsilon) = \\log(C) + p \\log(b_s)\n$$\n这是 $\\log(\\varepsilon)$ 和 $\\log(b_s)$ 之间的线性关系，其中斜率是所期望的指数 $p$。我们为小的 $b_s$ 值的几何序列计算误差 $\\varepsilon$，然后对其对数执行线性最小二乘拟合以确定斜率。\n\n### 测试套件的计算计划\n\n1.  **Gamma 函数标度 ($p_\\Gamma$)：**\n    -   提供了一个 $b_s$ 值的几何序列：$\\{10^{-1}, 5\\times 10^{-2}, \\dots, 6.25\\times 10^{-3}\\}$。\n    -   对于每个 $b_s$，使用 `scipy.special.i0` 计算 $\\Gamma_0(b_s)$，而 $\\Gamma_{0,\\text{lin}}(b_s)$ 计算为 $1 - b_s$。\n    -   然后计算相对误差 $\\varepsilon_{\\Gamma}(b_s)$。\n    -   构建数组 $\\log(\\varepsilon_\\Gamma)$ 和 $\\log(b_s)$，并拟合一个线性多项式以找到斜率，这就是我们对 $p_\\Gamma$ 的估计。\n\n2.  **本征值标度 ($p_\\omega$)：**\n    -   使用相同的 $b_s$ 值序列，参数为 $\\alpha = 0.5$ 和 $\\omega_\\star = 1.0$。\n    -   对于每个 $b_s$，使用它们各自的公式计算本征值 $\\omega(b_s)$ 和 $\\omega_{\\text{lin}}(b_s)$。\n    -   计算相对误差 $\\varepsilon_{\\omega}(b_s)$。\n    -   执行与第一个任务中相同的对数-对数线性回归，以估计 $p_\\omega$。\n\n3.  **边界小 $b_s$ 本征值误差：**\n    -   使用 $\\alpha = 0.5$ 和 $\\omega_\\star = 1.0$，为单个小值 $b_s = 10^{-8}$ 计算精确和近似的本征值。\n    -   然后直接计算绝对误差 $|\\omega(b_s) - \\omega_{\\text{lin}}(b_s)|$。\n\n4.  **中等 $b_s$ 回旋平均误差：**\n    -   对于 $b_s = 10^{-1}$，计算精确和近似的回旋平均函数。\n    -   直接计算绝对误差 $|\\Gamma_0(b_s) - \\Gamma_{0,\\text{lin}}(b_s)|$。\n\n这四个结果将被计算、四舍五入到指定精度，并按要求格式化为单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0\n\ndef solve():\n    \"\"\"\n    Performs a convergence study for the gyroaveraging operator and a derived\n    eigenvalue problem, as specified in the problem statement.\n    \"\"\"\n\n    # --- Core Function Definitions ---\n\n    def gamma0(bs: np.ndarray) - np.ndarray:\n        \"\"\"Computes the exact gyroaveraging function Gamma_0(b_s).\"\"\"\n        return i0(bs) * np.exp(-bs)\n\n    def gamma0_lin(bs: np.ndarray) - np.ndarray:\n        \"\"\"Computes the linearized approximation of Gamma_0(b_s).\"\"\"\n        return 1.0 - bs\n\n    def omega(bs: np.ndarray, alpha: float, omega_star: float) - np.ndarray:\n        \"\"\"Computes the exact eigenvalue omega.\"\"\"\n        return omega_star / (1.0 + alpha * (1.0 - gamma0(bs)))\n\n    def omega_lin(bs: np.ndarray, alpha: float, omega_star: float) - np.ndarray:\n        \"\"\"Computes the linearized approximation of the eigenvalue.\"\"\"\n        return omega_star / (1.0 + alpha * bs)\n\n    # --- Test Suite Calculations ---\n\n    # 1. Gamma function scaling test\n    bs_values_p_gamma = np.array([1e-1, 5e-2, 2.5e-2, 1.25e-2, 6.25e-3])\n    gamma0_vals = gamma0(bs_values_p_gamma)\n    gamma0_lin_vals = gamma0_lin(bs_values_p_gamma)\n    \n    eps_gamma = np.abs(gamma0_vals - gamma0_lin_vals) / np.abs(gamma0_vals)\n    \n    log_bs_gamma = np.log(bs_values_p_gamma)\n    log_eps_gamma = np.log(eps_gamma)\n    \n    # Perform a linear least-squares fit (slope is the scaling exponent)\n    p_gamma = np.polyfit(log_bs_gamma, log_eps_gamma, 1)[0]\n\n    # 2. Eigenvalue scaling test (happy path)\n    alpha_p_omega = 0.5\n    omega_star_p_omega = 1.0\n    bs_values_p_omega = np.array([1e-1, 5e-2, 2.5e-2, 1.25e-2, 6.25e-3])\n\n    omega_vals = omega(bs_values_p_omega, alpha_p_omega, omega_star_p_omega)\n    omega_lin_vals = omega_lin(bs_values_p_omega, alpha_p_omega, omega_star_p_omega)\n\n    eps_omega = np.abs(omega_vals - omega_lin_vals) / np.abs(omega_vals)\n    \n    log_bs_omega = np.log(bs_values_p_omega)\n    log_eps_omega = np.log(eps_omega)\n    \n    p_omega = np.polyfit(log_bs_omega, log_eps_omega, 1)[0]\n    \n    # 3. Boundary small-b_s case for eigenvalue error magnitude\n    alpha_err_omega = 0.5\n    omega_star_err_omega = 1.0\n    bs_val_err_omega = 1e-8\n    \n    omega_val_exact = omega(bs_val_err_omega, alpha_err_omega, omega_star_err_omega)\n    omega_val_lin = omega_lin(bs_val_err_omega, alpha_err_omega, omega_star_err_omega)\n    \n    abs_err_omega = np.abs(omega_val_exact - omega_val_lin)\n\n    # 4. Moderate b_s check for the gyroaveraging function\n    bs_val_err_gamma = 1e-1\n    \n    gamma0_val_exact = gamma0(bs_val_err_gamma)\n    gamma0_val_lin = gamma0_lin(bs_val_err_gamma)\n    \n    abs_err_gamma = np.abs(gamma0_val_exact - gamma0_val_lin)\n\n    # --- Final Output Formatting ---\n    # The format string '{value:.Nf}' handles rounding to N decimal places.\n    print(f\"[{p_gamma:.3f},{p_omega:.3f},{abs_err_omega:.12f},{abs_err_gamma:.12f}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当核心组件得到验证后，下一步便是将其应用于解决一个简化但具有实际物理意义的问题。本练习将引导你分析离子温度梯度 (ITG) 不稳定性，这是托卡马克等离子体中驱动湍流的关键机制之一。你将求解一个简化的二次色散关系来计算不稳定性增长率，从而将抽象的算符与具体的物理预测联系起来，体会理论模型如何转化为可量化的结果。",
            "id": "4001971",
            "problem": "考虑在线性、静电、低贝塔极限下的离子温度梯度（ITG）不稳定性，该不稳定性在局域、磁通管、$s$–$\\alpha$ 几何中建模。假设电子是绝热的，且存在单一的具有麦克斯韦背景的离子种类。从满足准中性条件的绝热电子的线性化、无碰撞、静电离子回旋动理学方程出发。在最不稳定的气球模宇称的平行动力学消失的极限下（即，取 $k_{\\parallel} \\rightarrow 0$ 以分离环向 ITG 分支），并采用标准的朗道流体（Padé 型）闭合来处理离子矩，该闭合能够捕捉曲率驱动和有限拉莫尔半径（FLR）效应，可以得到一个简化的、无量纲的、关于复的、抗磁归一化频率 $\\hat{\\omega} = \\omega / \\omega_{\\ast i}$ 的二次色散关系，形式如下：\n$$\n\\hat{\\omega}^2 - \\hat{\\omega}\\left[\\Gamma_0(b)\\left(1 + \\eta_i\\right) + \\hat{\\omega}_d\\right] + \\alpha\\,\\hat{\\omega}_d\\,\\Gamma_0(b) = 0,\n$$\n其中：\n- $\\eta_i = L_n/L_{T_i}$ 是离子温度梯度参数，其中 $L_n$ 是密度梯度标长，$L_{T_i}$ 是离子温度梯度标长，两者均为正常数。\n- $k_y \\rho_i$ 是以回旋半径为单位的副法向波数；定义 $b = \\left(k_y \\rho_i\\right)^2$。\n- $\\Gamma_0(b)$ 是离子回旋平均因子，精确取为零阶 Laguerre（Bessel）FLR 因子 $\\Gamma_0(b) = I_0(b)\\,e^{-b}$，其中 $I_0$ 是零阶第一类修正贝塞尔函数。\n- $s$ 是磁剪切，一个非负实数参数。\n- $\\alpha$ 是 $s$–$\\alpha$ 几何中的归一化压力梯度驱动，一个乘以曲率耦合的非负实数参数。\n- 归一化到 $\\omega_{\\ast i}$ 的曲率漂移频率模型为\n$$\n\\hat{\\omega}_d = \\frac{\\alpha}{1 + s^2},\n$$\n该模型捕捉了磁剪切对平均曲率驱动的稳定化效应。\n\n在此模型中，二次方程的复根定义了 ITG 本征值 $\\hat{\\omega} = \\hat{\\omega}_r + i \\gamma$。不稳定性对应于负的判别式，在这种情况下，增长率为\n$$\n\\gamma_{\\mathrm{num}} = \\frac{1}{2}\\sqrt{4\\,B - A^2},\n$$\n其中\n$$\nA = \\Gamma_0(b)\\left(1 + \\eta_i\\right) + \\hat{\\omega}_d, \\quad B = \\alpha\\,\\hat{\\omega}_d\\,\\Gamma_0(b).\n$$\n如果 $4\\,B - A^2 \\le 0$，则取 $\\gamma_{\\mathrm{num}} = 0$。\n\n对于适用于小等离子体贝塔（静电）和中等 FLR 的基准解析极限，将回旋平均因子近似为其小 $b$ 的二阶渐近展开，\n$$\n\\Gamma_0(b) \\approx \\Gamma_0^{\\mathrm{asym}}(b) = 1 - b + \\frac{b^2}{2},\n$$\n并定义相应的渐近系数\n$$\nA_{\\mathrm{asym}} = \\Gamma_0^{\\mathrm{asym}}(b)\\left(1 + \\eta_i\\right) + \\hat{\\omega}_d, \\quad B_{\\mathrm{asym}} = \\alpha\\,\\hat{\\omega}_d\\,\\Gamma_0^{\\mathrm{asym}}(b),\n$$\n渐近增长率为\n$$\n\\gamma_{\\mathrm{asym}} = \\max\\left\\{0,\\ \\frac{1}{2}\\sqrt{4\\,B_{\\mathrm{asym}} - A_{\\mathrm{asym}}^2}\\right\\}。\n$$\n\n任务。编写一个完整的程序，该程序：\n1. 对于每个提供的测试用例，根据精确的 $\\Gamma_0(b)$ 模型计算 ITG 本征值增长率 $\\gamma_{\\mathrm{num}}$，并根据二阶 $\\Gamma_0^{\\mathrm{asym}}(b)$ 展开计算基准渐近增长率 $\\gamma_{\\mathrm{asym}}$。\n2. 对每个测试用例，返回绝对偏差\n$$\n\\Delta \\gamma = \\left|\\gamma_{\\mathrm{num}} - \\gamma_{\\mathrm{asym}}\\right|。\n$$\n\n重要说明：\n- 所有量均为无量纲。答案中无需物理单位。\n- 不出现角度；无需角度单位。\n- 如果精确模型或渐近模型中的判别式为非负，则将相应的增长率解释为零。\n\n测试套件。使用以下参数集 $(\\eta_i, k_y \\rho_i, s, \\alpha)$：\n- 情况 1（不稳定，中等 FLR）：$(0.8,\\ 0.7,\\ 0.2,\\ 4.0)$。\n- 情况 2（接近阈值）：$(1.5,\\ 0.4,\\ 1.0,\\ 2.7)$。\n- 情况 3（因强剪切而稳定）：$(3.0,\\ 0.7,\\ 3.0,\\ 1.0)$。\n- 情况 4（小 $b$，不稳定）：$(2.0,\\ 0.15,\\ 0.5,\\ 4.0)$。\n\n最终输出格式。您的程序应生成一行输出，其中包含四个结果 $\\Delta \\gamma$，形式为用方括号括起来的逗号分隔列表，每个数字四舍五入到六位小数，例如：“[x1,x2,x3,x4]”。",
            "solution": "该问题是有效的。它在科学上基于等离子体微不稳定性理论，具体来说是一个简化的离子温度梯度（ITG）模模型。该问题是适定的、客观的，并包含所有必要信息以获得唯一的、可验证的解。\n\n任务是为一组给定的等离子体参数，计算由完整回旋平均模型计算出的 ITG 增长率 $\\gamma_{\\mathrm{num}}$ 与渐近模型计算出的增长率 $\\gamma_{\\mathrm{asym}}$ 之间的绝对偏差 $\\Delta \\gamma$。\n\n对于每个测试用例 $(\\eta_i, k_y \\rho_i, s, \\alpha)$，解决此问题的逻辑步骤如下：\n\n首先，我们计算两种模型共有的无量纲参数。归一化的副法向波数的平方 $b$ 定义为\n$$\nb = (k_y \\rho_i)^2.\n$$\n该参数量化了不稳定性相对于离子回旋半径 $\\rho_i$ 的尺度。归一化的曲率漂移频率 $\\hat{\\omega}_d$ 模拟了环向曲率和磁剪切的影响，由下式给出：\n$$\n\\hat{\\omega}_d = \\frac{\\alpha}{1 + s^2}.\n$$\n这里，$\\alpha$ 是代表驱动的归一化压力梯度参数，$s$ 是磁剪切，其在分母中的出现表明其对平均曲率漂移的稳定化效应。\n\n其次，我们使用精确的回旋平均因子 $\\Gamma_0(b)$ 计算增长率 $\\gamma_{\\mathrm{num}}$。色散关系是关于复频率 $\\hat{\\omega}$ 的二次方程。该二次方程的系数（记为 $A$ 和 $B$）取决于等离子体参数。当二次方程的判别式为负时，会出现不稳定性，对应于正的增长率。增长率由该判别式导出。\n\n精确的离子回旋平均因子为\n$$\n\\Gamma_0(b) = I_0(b)\\,e^{-b},\n$$\n其中 $I_0(b)$ 是零阶第一类修正贝塞尔函数。此函数表示垂直电场在离子回旋轨道上的平均，是有限拉莫尔半径（FLR）效应的关键组成部分。\n\n利用此式，我们定义特征多项式的系数：\n$$\nA = \\Gamma_0(b)\\left(1 + \\eta_i\\right) + \\hat{\\omega}_d,\n$$\n$$\nB = \\alpha\\,\\hat{\\omega}_d\\,\\Gamma_0(b).\n$$\n增长率 $\\gamma_{\\mathrm{num}}$ 是项 $4B - A^2$ 正部分的平方根的一半，这对应于关于 $\\hat{\\omega}$ 的二次方程判别式的负值：\n$$\n\\gamma_{\\mathrm{num}} = \\begin{cases} \\frac{1}{2}\\sqrt{4B - A^2}  \\text{若 } 4B - A^2  0 \\\\ 0  \\text{若 } 4B - A^2 \\le 0 \\end{cases}.\n$$\n$\\gamma_{\\mathrm{num}} = 0$ 的值表示稳定或临界稳定模。\n\n第三，我们对渐近增长率 $\\gamma_{\\mathrm{asym}}$ 重复此计算。该模型作为基准，在小 $b$（即 $k_y \\rho_i \\ll 1$）的极限下有效。它用 $\\Gamma_0(b)$ 在 $b=0$ 附近的二阶泰勒展开替换了精确的 $\\Gamma_0(b)$：\n$$\n\\Gamma_0^{\\mathrm{asym}}(b) = 1 - b + \\frac{b^2}{2}.\n$$\n相应的渐近系数为：\n$$\nA_{\\mathrm{asym}} = \\Gamma_0^{\\mathrm{asym}}(b)\\left(1 + \\eta_i\\right) + \\hat{\\omega}_d,\n$$\n$$\nB_{\\mathrm{asym}} = \\alpha\\,\\hat{\\omega}_d\\,\\Gamma_0^{\\mathrm{asym}}(b).\n$$\n然后使用与之前相同的逻辑计算渐近增长率：\n$$\n\\gamma_{\\mathrm{asym}} = \\begin{cases} \\frac{1}{2}\\sqrt{4B_{\\mathrm{asym}} - A_{\\mathrm{asym}}^2}  \\text{若 } 4B_{\\mathrm{asym}} - A_{\\mathrm{asym}}^2  0 \\\\ 0  \\text{若 } 4B_{\\mathrm{asym}} - A_{\\mathrm{asym}}^2 \\le 0 \\end{cases}.\n$$\n\n最后，对于每个参数集，计算两种模型之间的绝对偏差：\n$$\n\\Delta \\gamma = \\left|\\gamma_{\\mathrm{num}} - \\gamma_{\\mathrm{asym}}\\right|.\n$$\n该量度量了对于给定的参数集，由小 $b$ 近似引入的误差。对所有提供的测试用例重复整个过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import i0\n\ndef solve():\n    \"\"\"\n    Computes the absolute discrepancy in ITG growth rates between an exact\n    and an asymptotic model for given plasma parameters.\n    \"\"\"\n\n    # Test cases defined as tuples of (eta_i, k_y_rho_i, s, alpha)\n    test_cases = [\n        (0.8, 0.7, 0.2, 4.0),   # Case 1: unstable, moderate FLR\n        (1.5, 0.4, 1.0, 2.7),   # Case 2: near threshold\n        (3.0, 0.7, 3.0, 1.0),   # Case 3: stable due to strong shear\n        (2.0, 0.15, 0.5, 4.0),  # Case 4: small b, unstable\n    ]\n\n    results = []\n    for eta_i, ky_rho_i, s, alpha in test_cases:\n        # Step 1: Calculate common parameters\n        # b is the squared normalized binormal wavenumber\n        b = ky_rho_i**2\n        # omega_d_hat is the normalized curvature-drift frequency\n        omega_d_hat = alpha / (1.0 + s**2)\n\n        # Step 2: Calculate the numerical growth rate (gamma_num)\n        # Gamma_0(b) is the exact ion gyroaverage factor\n        gamma0_b_num = i0(b) * np.exp(-b)\n        \n        # Coefficients of the quadratic dispersion relation\n        A_num = gamma0_b_num * (1.0 + eta_i) + omega_d_hat\n        B_num = alpha * omega_d_hat * gamma0_b_num\n        \n        # The growth rate is derived from the discriminant of the quadratic\n        discriminant_num = 4.0 * B_num - A_num**2\n        gamma_num = 0.5 * np.sqrt(discriminant_num) if discriminant_num  0 else 0.0\n\n        # Step 3: Calculate the asymptotic growth rate (gamma_asym)\n        # Gamma_0(b) is approximated by its second-order expansion\n        gamma0_b_asym = 1.0 - b + 0.5 * b**2\n        \n        # Coefficients for the asymptotic model\n        A_asym = gamma0_b_asym * (1.0 + eta_i) + omega_d_hat\n        B_asym = alpha * omega_d_hat * gamma0_b_asym\n        \n        # Calculate the asymptotic growth rate\n        discriminant_asym = 4.0 * B_asym - A_asym**2\n        gamma_asym = 0.5 * np.sqrt(discriminant_asym) if discriminant_asym  0 else 0.0\n\n        # Step 4: Compute the absolute discrepancy\n        delta_gamma = np.abs(gamma_num - gamma_asym)\n        results.append(delta_gamma)\n\n    # Format the results to six decimal places as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    \n    # Print the final output in the required format\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真正的科学研究不仅关心“答案是什么”，更关心“答案如何随参数变化”。这个高级练习将介绍强大的伴随方法，它对于分析回旋动理学中常见的非厄米算符至关重要。通过计算特征值对物理参数的导数（即敏感性），你将学习如何高效地探索系统的稳定性边界和参数依赖性，这是进行模型优化和不确定性量化的关键一步。",
            "id": "4001903",
            "problem": "要求您实现一个完整的程序，计算简化的线性回旋动理学算子的主导特征值相对于副法向波数和离子温度梯度标长的伴随敏度。背景是简化回旋流体闭合下的平板离子温度梯度（ITG）动力学，其中电子为绝热的。计算必须通过与一小组测试用例的有限差分近似进行比较来验证。程序必须是自包含的，并且无需用户输入即可生成指定格式的所需输出。\n\n其基本基础是在绝热电子的漂移波动力学下，耦合的离子密度和离子温度涨落的线性化，表示为状态向量的非厄米特征值问题。这种表示反映了简化回旋流体近似下的线性回旋动理学行为，并能够通过伴随方法对非正规算子进行严格的敏度分析。该分析纯粹从数学上表述为一个依赖于参数的复矩阵及其特征对。\n\n定义依赖于参数的复矩阵算子如下。设 $k_y$ 为无量纲的副法向波数，$L_T$ 为无量纲的离子温度梯度标长。引入具有指定值的固定无量纲常数：\n- $L_n = 2.0$，\n- $a_T = 0.7$，\n- $\\beta = 0.9$，\n- $\\nu = 0.05$，\n- $g_0 = 0.2$，\n- $c_{\\mathrm{FLR}} = 0.3$。\n\n通过以下公式定义温度梯度耦合函数和有限拉莫尔半径稳定化函数\n$$\n\\alpha(L_T) = a_T \\frac{L_n}{L_T}, \\qquad \\gamma(k_y) = g_0 + c_{\\mathrm{FLR}} k_y^2.\n$$\n该算子是 $2 \\times 2$ 的复矩阵\n$$\nA(k_y,L_T) =\n\\begin{pmatrix}\n- i k_y  i k_y \\,\\alpha(L_T) \\\\\ni k_y \\,\\beta  -\\left(\\nu + i k_y \\,\\gamma(k_y)\\right)\n\\end{pmatrix},\n$$\n其中 $i$ 是虚数单位。此定义反映了在简化回旋流体设置中，线性的漂移波平流（$-i k_y$）、温度梯度驱动（$i k_y \\alpha$）以及稳定化/阻尼（$\\nu$ 和 $i k_y \\gamma$）。\n\n您必须对 $A(k_y,L_T)$ 的主导特征值 $\\lambda(k_y,L_T)$（定义为虚部最大的特征值）实现基于伴随的敏度分析。对于每个测试用例，使用伴随方法计算复导数 $\\partial \\lambda / \\partial k_y$ 和 $\\partial \\lambda / \\partial L_T$，并通过独立扰动 $k_y$ 和 $L_T$ 计算中心有限差分近似来验证这些导数。您的实现必须包含鲁棒的模式跟踪，以确保在 $(k_y \\pm h, L_T)$ 和 $(k_y, L_T \\pm h)$ 处的有限差分扰动通过最小化复平面中的距离，与未扰动的 $\\lambda(k_y,L_T)$ 匹配到相同的本征模分支。对扰动使用一个小的实数正步长 $h$，并确保您的选择在数值上是稳定的。\n\n您的程序必须为每个测试用例计算伴随敏度和有限差分之间的相对误差：\n$$\n\\mathrm{err}_{k_y} = \\frac{\\left|\\frac{\\partial \\lambda}{\\partial k_y}\\big|_{\\mathrm{adj}} - \\frac{\\partial \\lambda}{\\partial k_y}\\big|_{\\mathrm{fd}}\\right|}{\\max\\left(\\left|\\frac{\\partial \\lambda}{\\partial k_y}\\big|_{\\mathrm{fd}}\\right|, \\epsilon\\right)}, \\quad\n\\mathrm{err}_{L_T} = \\frac{\\left|\\frac{\\partial \\lambda}{\\partial L_T}\\big|_{\\mathrm{adj}} - \\frac{\\partial \\lambda}{\\partial L_T}\\big|_{\\mathrm{fd}}\\right|}{\\max\\left(\\left|\\frac{\\partial \\lambda}{\\partial L_T}\\big|_{\\mathrm{fd}}\\right|, \\epsilon\\right)},\n$$\n其中 $\\epsilon$ 是用于数值正则化的小实数正常数。\n\n使用以下参数值测试套件实现程序：\n- 案例 1：$k_y = 0.4$, $L_T = 3.0$\n- 案例 2：$k_y = 0.1$, $L_T = 6.0$\n- 案例 3：$k_y = 1.0$, $L_T = 1.5$\n- 案例 4：$k_y = 0.05$, $L_T = 2.5$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,\\dots]$）。对于每个案例，该列表必须按顺序包含该案例的两个浮点数 $\\mathrm{err}_{k_y}$ 和 $\\mathrm{err}_{L_T}$，并将所有案例的结果连接起来，总共得到 8 个数字。所有量都是无量纲的，不需要进行物理单位转换。本问题不使用角度。不得使用百分比；所有比率必须表示为小数值。",
            "solution": "所提出的问题在科学上和数学上都是有效的。这是一个定义明确的计算科学练习，特别是在对一个模拟物理系统的非厄米特征值问题进行敏度分析方面。所有必要的数据和定义都已提供，目标明确。问题是自包含的、一致的，并且可以使用标准数值方法求解。因此，我们可以着手解决。\n\n该问题要求对依赖于参数的矩阵 $A(k_y, L_T)$ 的主导特征值进行敏度分析，该矩阵代表了离子温度梯度（ITG）模的简化线性回旋动理学算子。特征值 $\\lambda$ 相对于参数 $p$ 的敏度是导数 $\\partial \\lambda / \\partial p$。我们将使用两种方法计算此导数：伴随方法（解析上精确）和有限差分方法（作为数值验证）。\n\n系统由 $2 \\times 2$ 复矩阵描述：\n$$\nA(k_y, L_T) =\n\\begin{pmatrix}\n- i k_y  i k_y \\,\\alpha(L_T) \\\\\ni k_y \\,\\beta  -\\left(\\nu + i k_y \\,\\gamma(k_y)\\right)\n\\end{pmatrix}\n$$\n其中 $k_y$ 是副法向波数，$L_T$ 是离子温度梯度标长，$i$ 是虚数单位。函数 $\\alpha(L_T)$ 和 $\\gamma(k_y)$ 定义为：\n$$\n\\alpha(L_T) = a_T \\frac{L_n}{L_T}, \\qquad \\gamma(k_y) = g_0 + c_{\\mathrm{FLR}} k_y^2\n$$\n常数给定为 $L_n = 2.0$, $a_T = 0.7$, $\\beta = 0.9$, $\\nu = 0.05$, $g_0 = 0.2$, 和 $c_{\\mathrm{FLR}} = 0.3$。\n\n系统线性扰动的演化由一个特征值问题控制。如果状态向量是 $z$，其时间演化为 $\\partial z / \\partial t = A z$。假设一个模态解 $z(t) = x e^{\\lambda t}$，我们得到右特征值问题：\n$$\nA x = \\lambda x\n$$\n特征值 $\\lambda$ 是复频率。虚部 $\\Im(\\lambda)$ 是模的增长率。“主导”特征值是具有最大增长率的特征值，即具有最大虚部的特征值。\n\n**伴随敏度分析**\n\n矩阵 $A$ 是非厄米矩阵，这对于具有自由能来源（如温度梯度）和耗散的系统是典型的。对于此类系统，左、右特征向量不是彼此的简单共轭转置。特征值 $\\lambda$ 对参数 $p$ 的敏度可以使用相应的左特征向量 $\\psi$ 推导得出。左特征值问题定义为 $\\psi^\\dagger A = \\lambda \\psi^\\dagger$，其中 $\\psi^\\dagger$ 是 $\\psi$ 的共轭转置。一个等价的表述是伴随矩阵 $A^\\dagger = A^T_c$（共轭转置）的右特征值问题：\n$$\nA^\\dagger \\psi = \\lambda^* \\psi\n$$\n其中 $\\lambda^*$ 是 $\\lambda$ 的复共轭。因此，$A$ 的关于特征值 $\\lambda$ 的左特征向量是 $A^\\dagger$ 的关于特征值 $\\lambda^*$ 的右特征向量。\n\n通过对特征值方程 $A x = \\lambda x$ 关于参数 $p$ 求导，并从左边乘以 $\\psi^\\dagger$，可以推导出著名的特征值敏度公式：\n$$\n\\frac{\\partial \\lambda}{\\partial p} = \\frac{\\psi^\\dagger \\left( \\frac{\\partial A}{\\partial p} \\right) x}{\\psi^\\dagger x}\n$$\n这个公式是精确的，并且避免了计算特征向量导数的需要。\n\n要应用此公式，我们首先需要矩阵 $A$ 相对于参数 $k_y$ 和 $L_T$ 的导数。\n相对于 $L_T$ 的导数是：\n$$\n\\frac{\\partial A}{\\partial L_T} = \\begin{pmatrix} 0  i k_y \\frac{\\partial \\alpha}{\\partial L_T} \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} 0  -i k_y \\frac{a_T L_n}{L_T^2} \\\\ 0  0 \\end{pmatrix}\n$$\n相对于 $k_y$ 的导数是：\n$$\n\\frac{\\partial A}{\\partial k_y} = \\frac{\\partial}{\\partial k_y} \\begin-pmatrix} - i k_y  i k_y \\alpha(L_T) \\\\ i k_y \\beta  -\\nu - i k_y g_0 - i c_{\\mathrm{FLR}} k_y^3 \\end{pmatrix} = \\begin{pmatrix} -i  i \\alpha(L_T) \\\\ i \\beta  -i g_0 - 3 i c_{\\mathrm{FLR}} k_y^2 \\end{pmatrix} = \\begin{pmatrix} -i  i \\alpha(L_T) \\\\ i \\beta  -i (g_0 + 3 c_{\\mathrm{FLR}} k_y^2) \\end{pmatrix}\n$$\n\n对于每个参数 $p \\in \\{k_y, L_T\\}$，伴随敏度的计算过程如下：\n$1$. 对于给定的对 $(k_y, L_T)$，构造矩阵 $A$。\n$2$. 求解右特征值问题 $A x_j = \\lambda_j x_j$ 以找到所有特征值和特征向量。\n$3$. 将虚部最大的特征值识别为主导特征值 $\\lambda$，并找到其对应的右特征向量 $x$。\n$4$. 构造伴随矩阵 $A^\\dagger$。\n$5$. 求解伴随特征值问题 $A^\\dagger \\psi_j = \\mu_j \\psi_j$。\n$6$. 通过找到特征值 $\\mu_j$ 是 $\\lambda$ 的复共轭（即 $\\mu_j \\approx \\lambda^*$）的特征向量 $\\psi_j$，来识别与 $\\lambda$ 对应的伴随特征向量 $\\psi$。\n$7$. 计算矩阵导数 $\\partial A / \\partial p$。\n$8$. 使用公式 $\\frac{\\psi^\\dagger (\\partial A / \\partial p) x}{\\psi^\\dagger x}$ 计算敏度 $\\partial \\lambda / \\partial p$。\n\n**有限差分验证**\n\n为验证伴随敏度，我们使用中心有限差分公式计算数值近似：\n$$\n\\frac{\\partial \\lambda}{\\partial p} \\bigg|_{\\mathrm{fd}} \\approx \\frac{\\lambda(p+h) - \\lambda(p-h)}{2h}\n$$\n其中 $h$ 是一个小的实数正步长。一个数值上稳定的 $h$ 的选择必须足够小以最小化截断误差，但又要足够大以避免浮点运算中的灾难性抵消。我们将使用 $h = 10^{-7}$。\n\n一个关键步骤是**模式跟踪**。当我们计算扰动矩阵（例如 $A(k_y+h, L_T)$）的特征值时，会得到一组新的特征值。我们必须识别出这些新特征值中哪一个对应于未扰动系统的主导模式。这可以通过在复平面中找到与原始主导特征值 $\\lambda(k_y, L_T)$ 最接近的新特征值来实现。具体来说，我们计算扰动矩阵的特征值 $\\{\\lambda'_j\\}$，并选择使距离 $|\\lambda'_j - \\lambda(p)|$ 最小的那个，即 $\\lambda(p+h)$。对扰动 $p-h$ 应用相同的过程。\n\n**误差计算**\n\n最后，对于每个测试用例和每个参数，我们计算伴随结果和有限差分结果之间的相对误差：\n$$\n\\mathrm{err}_{p} = \\frac{\\left|\\frac{\\partial \\lambda}{\\partial p}\\big|_{\\mathrm{adj}} - \\frac{\\partial \\lambda}{\\partial p}\\big|_{\\mathrm{fd}}\\right|}{\\max\\left(\\left|\\frac{\\partial \\lambda}{\\partial p}\\big|_{\\mathrm{fd}}\\right|, \\epsilon\\right)}\n$$\n正则化参数 $\\epsilon$ 防止除以一个非常小的数或零。我们选择 $\\epsilon = 10^{-14}$。一个小的误差验证了我们伴随方法实现的正确性。\n\n下面的实现将对问题陈述中提供的每个测试用例系统地执行这些计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and validates adjoint-based sensitivities of a gyrofluid eigenvalue problem.\n    \"\"\"\n\n    # --- Fixed dimensionless constants ---\n    L_n = 2.0\n    a_T = 0.7\n    beta = 0.9\n    nu = 0.05\n    g_0 = 0.2\n    c_FLR = 0.3\n\n    # --- Numerical parameters ---\n    h = 1e-7  # Step size for finite differences\n    epsilon = 1e-14  # Regularization for error calculation\n\n    # --- Test cases ---\n    test_cases = [\n        (0.4, 3.0),  # Case 1: ky, LT\n        (0.1, 6.0),  # Case 2: ky, LT\n        (1.0, 1.5),  # Case 3: ky, LT\n        (0.05, 2.5), # Case 4: ky, LT\n    ]\n\n    # --- Helper functions for matrix construction ---\n    def alpha(LT):\n        return a_T * L_n / LT\n\n    def gamma(ky):\n        return g_0 + c_FLR * ky**2\n\n    def get_A(ky, LT):\n        \"\"\"Constructs the operator matrix A.\"\"\"\n        a = alpha(LT)\n        g = gamma(ky)\n        A = np.array([\n            [-1j * ky, 1j * ky * a],\n            [1j * ky * beta, -(nu + 1j * ky * g)]\n        ], dtype=np.complex128)\n        return A\n\n    def get_dA_dky(ky, LT):\n        \"\"\"Constructs the derivative of A with respect to ky.\"\"\"\n        a = alpha(LT)\n        dA = np.array([\n            [-1j, 1j * a],\n            [1j * beta, -1j * (g_0 + 3 * c_FLR * ky**2)]\n        ], dtype=np.complex128)\n        return dA\n\n    def get_dA_dLT(ky, LT):\n        \"\"\"Constructs the derivative of A with respect to LT.\"\"\"\n        dA = np.array([\n            [0, -1j * ky * a_T * L_n / LT**2],\n            [0, 0]\n        ], dtype=np.complex128)\n        return dA\n\n    results = []\n    \n    for ky_0, LT_0 in test_cases:\n        # --- Base Calculation at (ky_0, LT_0) ---\n        A_0 = get_A(ky_0, LT_0)\n        \n        # Solve for right eigenpairs\n        lams, vecs = np.linalg.eig(A_0)\n        \n        # Find dominant mode (largest imaginary part)\n        idx_dom = np.argmax(lams.imag)\n        lam_dom = lams[idx_dom]\n        x_dom = vecs[:, idx_dom]\n        \n        # --- Adjoint Sensitivity Calculation ---\n        \n        # Solve for left eigenpairs (eigenvectors of A dagger)\n        A_adj = A_0.T.conj()\n        lams_adj, vecs_adj = np.linalg.eig(A_adj)\n        \n        # Find the adjoint eigenvector corresponding to the dominant mode\n        idx_adj = np.argmin(np.abs(lams_adj - lam_dom.conj()))\n        psi_dom = vecs_adj[:, idx_adj]\n        \n        # Calculate matrix-vector products\n        denominator = psi_dom.conj().T @ x_dom\n        \n        # Sensitivity w.r.t. ky\n        dA_dky = get_dA_dky(ky_0, LT_0)\n        numerator_ky = psi_dom.conj().T @ dA_dky @ x_dom\n        sens_ky_adj = numerator_ky / denominator\n        \n        # Sensitivity w.r.t. LT\n        dA_dLT = get_dA_dLT(ky_0, LT_0)\n        numerator_LT = psi_dom.conj().T @ dA_dLT @ x_dom\n        sens_LT_adj = numerator_LT / denominator\n\n        # --- Finite-Difference Validation ---\n\n        # Perturbation for ky\n        A_p_ky = get_A(ky_0 + h, LT_0)\n        A_m_ky = get_A(ky_0 - h, LT_0)\n        lams_p_ky, _ = np.linalg.eig(A_p_ky)\n        lams_m_ky, _ = np.linalg.eig(A_m_ky)\n        # Mode tracking\n        lam_p_ky = lams_p_ky[np.argmin(np.abs(lams_p_ky - lam_dom))]\n        lam_m_ky = lams_m_ky[np.argmin(np.abs(lams_m_ky - lam_dom))]\n        sens_ky_fd = (lam_p_ky - lam_m_ky) / (2 * h)\n\n        # Perturbation for LT\n        A_p_LT = get_A(ky_0, LT_0 + h)\n        A_m_LT = get_A(ky_0, LT_0 - h)\n        lams_p_LT, _ = np.linalg.eig(A_p_LT)\n        lams_m_LT, _ = np.linalg.eig(A_m_LT)\n        # Mode tracking\n        lam_p_LT = lams_p_LT[np.argmin(np.abs(lams_p_LT - lam_dom))]\n        lam_m_LT = lams_m_LT[np.argmin(np.abs(lams_m_LT - lam_dom))]\n        sens_LT_fd = (lam_p_LT - lam_m_LT) / (2 * h)\n\n        # --- Error Calculation ---\n        err_ky = np.abs(sens_ky_adj - sens_ky_fd) / max(np.abs(sens_ky_fd), epsilon)\n        err_LT = np.abs(sens_LT_adj - sens_LT_fd) / max(np.abs(sens_LT_fd), epsilon)\n        \n        results.extend([err_ky, err_LT])\n        \n    # Format the final output string\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}