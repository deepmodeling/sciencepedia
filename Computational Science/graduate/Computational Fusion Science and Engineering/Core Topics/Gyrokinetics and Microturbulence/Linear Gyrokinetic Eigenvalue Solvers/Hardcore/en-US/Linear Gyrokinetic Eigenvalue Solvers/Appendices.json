{
    "hands_on_practices": [
        {
            "introduction": "This practice establishes the foundation for building any reliable gyrokinetic solver: code verification. Before assembling complex models, it is crucial to validate the core numerical components. This exercise focuses on the gyroaveraging operator, a fundamental element accounting for finite Larmor radius (FLR) effects, by verifying the convergence of its long-wavelength approximation against the exact form . Mastering this process of quantifying numerical error ensures the robustness and accuracy of the more complex solvers you will build.",
            "id": "4001870",
            "problem": "You are tasked with designing and implementing a short convergence study that isolates the effect of the gyroaveraging operator in the linear gyrokinetic limit and quantifies error scaling in the long-wavelength regime. The study must be carried out entirely by a program that produces a single-line output as specified below.\n\nBegin from the following fundamental base:\n\n1. The linearized, collisionless, electrostatic gyrokinetic description introduces the gyroaveraging operator via the zeroth-order Bessel function of the first kind, $J_0$. In velocity-space averages over a Maxwellian distribution, this gives the standard function\n$$\n\\Gamma_0(b_s) \\equiv I_0(b_s)\\,e^{-b_s},\n$$\nwhere $I_0$ is the modified Bessel function of the first kind and $b_s \\equiv k_\\perp^2 \\rho_s^2$ with $k_\\perp$ the perpendicular wavenumber and $\\rho_s$ the species Larmor radius.\n\n2. In the analytic long-wavelength limit $k_\\perp \\rho_s \\ll 1$, one has $b_s \\ll 1$ and the small-argument expansion yields\n$$\n\\Gamma_0(b_s) = 1 - b_s + \\mathcal{O}(b_s^2).\n$$\n\n3. For a simple electrostatic drift-wave-like scalar eigenproblem inspired by quasi-neutrality with adiabatic electrons and gyrokinetic ions (ignoring parallel dynamics and collisionless damping to isolate finite Larmor radius effects), one may represent a generalized eigenvalue problem for the mode frequency $\\omega$ in the form\n$$\nA(b_s)\\,\\varphi = \\omega\\,B(b_s)\\,\\varphi,\n$$\nwith a scalar potential amplitude $\\varphi$, where $A(b_s)$ encodes the diamagnetic drive and $B(b_s)$ encodes the polarization response. A minimal closure that preserves the small-$b_s$ long-wavelength structure is\n$$\nA(b_s) = \\omega_\\star, \\qquad B(b_s) = 1 + \\alpha\\,[1 - \\Gamma_0(b_s)],\n$$\nwith constant $\\omega_\\star$ and $\\alpha$ (both dimensionless). In the long-wavelength limit, replacing $\\Gamma_0(b_s)$ by its first-order approximation $1 - b_s$ gives an approximate operator\n$$\nB_{\\text{lin}}(b_s) = 1 + \\alpha\\,b_s.\n$$\nThis produces an approximate eigenvalue $\\omega_{\\text{lin}}$ when used in place of $B(b_s)$.\n\nYour program must do the following:\n\n- Compute the exact $\\Gamma_0(b_s)$ using its definition $\\Gamma_0(b_s) = I_0(b_s)\\,e^{-b_s}$, and compute its long-wavelength approximation $\\Gamma_{0,\\text{lin}}(b_s) = 1 - b_s$.\n- Form the exact scalar eigenvalue $\\omega$ and its long-wavelength approximation $\\omega_{\\text{lin}}$ by solving the generalized eigenproblem $A\\varphi = \\omega B \\varphi$ for the above $A$ and $B$ (and analogously for $B_{\\text{lin}}$). This is a $1\\times 1$ generalized eigenproblem, so no matrix assembly is needed beyond the scalar forms; however, the logic must follow from the eigenproblem definition and not any unrelated formula.\n\n- Quantify the relative errors\n$$\n\\varepsilon_{\\Gamma}(b_s) \\equiv \\frac{\\left|\\Gamma_0(b_s) - \\Gamma_{0,\\text{lin}}(b_s)\\right|}{\\left|\\Gamma_0(b_s)\\right|}, \\qquad\n\\varepsilon_{\\omega}(b_s) \\equiv \\frac{\\left|\\omega(b_s) - \\omega_{\\text{lin}}(b_s)\\right|}{\\left|\\omega(b_s)\\right|}.\n$$\n- Using a log-log regression over a geometric sequence of $b_s$ values, estimate the empirical scaling exponents $p_\\Gamma$ and $p_\\omega$ defined by the best-fit slope in the models $\\varepsilon_{\\Gamma}(b_s) \\approx C_\\Gamma\\,b_s^{p_\\Gamma}$ and $\\varepsilon_{\\omega}(b_s) \\approx C_\\omega\\,b_s^{p_\\omega}$ for small $b_s$. Theory based on the small-$b_s$ expansion implies $p_\\Gamma = 2$ and $p_\\omega = 2$ if the implementation is correct, because the first neglected term in $\\Gamma_0(b_s)$ is $\\mathcal{O}(b_s^2)$ and the eigenvalue depends smoothly on $\\Gamma_0$.\n\nTest Suite and required outputs:\n\n1. Gamma function scaling test:\n   - Use $b_s \\in \\{10^{-1}, 5\\times 10^{-2}, 2.5\\times 10^{-2}, 1.25\\times 10^{-2}, 6.25\\times 10^{-3}\\}$.\n   - Compute $\\varepsilon_{\\Gamma}(b_s)$ for each and estimate $p_\\Gamma$ via a least-squares fit in $\\log \\varepsilon_{\\Gamma}$ versus $\\log b_s$.\n\n2. Eigenvalue scaling test (happy path):\n   - Parameters: $\\alpha = 0.5$, $\\omega_\\star = 1.0$.\n   - Use the same set of $b_s$ values as in item 1.\n   - Compute $\\varepsilon_{\\omega}(b_s)$ for each and estimate $p_\\omega$ via a least-squares fit in $\\log \\varepsilon_{\\omega}$ versus $\\log b_s$.\n\n3. Boundary small-$b_s$ case for eigenvalue error magnitude:\n   - Parameters: $\\alpha = 0.5$, $\\omega_\\star = 1.0$.\n   - Use a single value $b_s = 10^{-8}$.\n   - Compute the absolute error $|\\omega(b_s) - \\omega_{\\text{lin}}(b_s)|$ as a float.\n\n4. Moderate $b_s$ check for the gyroaveraging function:\n   - Use $b_s = 10^{-1}$.\n   - Compute the absolute error $|\\Gamma_0(b_s) - \\Gamma_{0,\\text{lin}}(b_s)|$ as a float.\n\nAll quantities in this problem are dimensionless and must be reported without units.\n\nFinal output format:\n\n- Your program should produce a single line of output containing a comma-separated Python list with four entries:\n  - The first entry is the estimated $p_\\Gamma$ rounded to three decimal places.\n  - The second entry is the estimated $p_\\omega$ rounded to three decimal places.\n  - The third entry is the absolute error from item 3 rounded to twelve decimal places.\n  - The fourth entry is the absolute error from item 4 rounded to twelve decimal places.\n- For example, a syntactically correct output format looks like \"[2.000,2.000,0.000000000001,0.000123456789]\". Your values will differ, but the format must match.\n\nYour program must be self-contained, must not read any input, and must use the specified test suite values and parameter choices given above. No other outputs are allowed.",
            "solution": "The problem statement has been meticulously validated. It is scientifically grounded, well-posed, and objective. All definitions, data, and parameters required for a unique and meaningful solution are provided. The problem is a standard, albeit simplified, code verification exercise in computational plasma physics, designed to test the implementation of the gyroaveraging operator and quantify the convergence order of a common long-wavelength approximation. The problem is therefore deemed **valid**.\n\nThe solution proceeds by first establishing the mathematical framework, then outlining the computational procedure for each of the four specified tasks.\n\n### Mathematical Formulation\n\nThe core of the problem lies in the gyroaveraging operator, which in the electrostatic gyrokinetic model is represented by the function $\\Gamma_0(b_s)$. It is formally defined as:\n$$\n\\Gamma_0(b_s) = I_0(b_s) e^{-b_s}\n$$\nwhere $I_0$ is the modified Bessel function of the first kind and $b_s = k_\\perp^2 \\rho_s^2$ is a dimensionless parameter representing the square of the perpendicular wavenumber $k_\\perp$ normalized to the Larmor radius $\\rho_s$.\n\nIn the long-wavelength limit, where $k_\\perp \\rho_s \\ll 1$ and thus $b_s \\ll 1$, $\\Gamma_0(b_s)$ can be approximated by its Taylor series expansion around $b_s=0$. The expansion of $I_0(b_s)$ is $1 + \\frac{1}{4}b_s^2 + \\mathcal{O}(b_s^4)$, and the expansion of $e^{-b_s}$ is $1 - b_s + \\frac{1}{2}b_s^2 - \\frac{1}{6}b_s^3 + \\mathcal{O}(b_s^4)$. Multiplying these series yields:\n$$\n\\Gamma_0(b_s) = \\left(1 + \\frac{1}{4}b_s^2 + \\dots\\right) \\left(1 - b_s + \\frac{1}{2}b_s^2 - \\dots\\right) = 1 - b_s + \\frac{3}{4}b_s^2 + \\mathcal{O}(b_s^3)\n$$\nThe problem defines the long-wavelength approximation by truncating this series after the linear term:\n$$\n\\Gamma_{0,\\text{lin}}(b_s) = 1 - b_s\n$$\nThe leading-order error in this approximation is therefore of order $\\mathcal{O}(b_s^2)$.\n\nThe problem introduces a simple scalar generalized eigenvalue problem for the mode frequency $\\omega$:\n$$\nA(b_s)\\,\\varphi = \\omega\\,B(b_s)\\,\\varphi\n$$\nSince this is a $1 \\times 1$ system (i.e., all quantities are scalars), the eigenvalue $\\omega$ can be solved for directly:\n$$\n\\omega(b_s) = \\frac{A(b_s)}{B(b_s)}\n$$\nUsing the provided forms for $A(b_s) = \\omega_\\star$ and $B(b_s) = 1 + \\alpha[1 - \\Gamma_0(b_s)]$, we obtain the exact eigenvalue:\n$$\n\\omega(b_s) = \\frac{\\omega_\\star}{1 + \\alpha[1 - \\Gamma_0(b_s)]}\n$$\nReplacing the exact operator $B(b_s)$ with its linearized counterpart, $B_{\\text{lin}}(b_s) = 1 + \\alpha b_s$ (derived from using $\\Gamma_{0,\\text{lin}}(b_s)$ in the expression for $B(b_s)$), we obtain the approximate eigenvalue:\n$$\n\\omega_{\\text{lin}}(b_s) = \\frac{\\omega_\\star}{1 + \\alpha b_s}\n$$\n\n### Error Quantification and Scaling Analysis\n\nThe relative error in the approximation of $\\Gamma_0(b_s)$ is defined as:\n$$\n\\varepsilon_{\\Gamma}(b_s) = \\frac{\\left|\\Gamma_0(b_s) - \\Gamma_{0,\\text{lin}}(b_s)\\right|}{\\left|\\Gamma_0(b_s)\\right|}\n$$\nGiven the Taylor series, the numerator is $|\\frac{3}{4}b_s^2 + \\mathcal{O}(b_s^3)|$ and the denominator is $|1 - b_s + \\mathcal{O}(b_s^2)| \\approx 1$ for small $b_s$. Thus, $\\varepsilon_{\\Gamma}(b_s) \\approx \\frac{3}{4}b_s^2$, which corresponds to a scaling model $\\varepsilon_{\\Gamma}(b_s) \\propto b_s^{p_\\Gamma}$ with an expected theoretical exponent of $p_\\Gamma = 2$.\n\nSimilarly, the relative error in the eigenvalue is:\n$$\n\\varepsilon_{\\omega}(b_s) = \\frac{\\left|\\omega(b_s) - \\omega_{\\text{lin}}(b_s)\\right|}{\\left|\\omega(b_s)\\right|}\n$$\nThe difference $\\omega(b_s) - \\omega_{\\text{lin}}(b_s)$ is proportional to $B_{\\text{lin}}(b_s) - B(b_s)$, which is in turn proportional to $\\Gamma_0(b_s) - \\Gamma_{0,\\text{lin}}(b_s)$. The error therefore also scales as $\\mathcal{O}(b_s^2)$, so we expect $p_\\omega = 2$.\n\nTo estimate the exponents $p_\\Gamma$ and $p_\\omega$ empirically, we use a log-log linear regression. For a model of the form $\\varepsilon = C b_s^p$, taking the logarithm yields:\n$$\n\\log(\\varepsilon) = \\log(C) + p \\log(b_s)\n$$\nThis is a linear relationship between $\\log(\\varepsilon)$ and $\\log(b_s)$, where the slope is the desired exponent $p$. We compute the errors $\\varepsilon$ for a geometric sequence of small $b_s$ values, and then perform a linear least-squares fit on their logarithms to determine the slope.\n\n### Computational Plan for Test Suite\n\n1.  **Gamma Function Scaling ($p_\\Gamma$):**\n    -   A geometric sequence of $b_s$ values is provided: $\\{10^{-1}, 5\\times 10^{-2}, \\dots, 6.25\\times 10^{-3}\\}$.\n    -   For each $b_s$, $\\Gamma_0(b_s)$ is computed using `scipy.special.i0`, and $\\Gamma_{0,\\text{lin}}(b_s)$ is computed as $1 - b_s$.\n    -   The relative error $\\varepsilon_{\\Gamma}(b_s)$ is then calculated.\n    -   The arrays $\\log(\\varepsilon_\\Gamma)$ and $\\log(b_s)$ are constructed, and a linear polynomial is fitted to find the slope, which is our estimate for $p_\\Gamma$.\n\n2.  **Eigenvalue Scaling ($p_\\omega$):**\n    -   The same sequence of $b_s$ values is used, with parameters $\\alpha = 0.5$ and $\\omega_\\star = 1.0$.\n    -   For each $b_s$, the eigenvalues $\\omega(b_s)$ and $\\omega_{\\text{lin}}(b_s)$ are computed using their respective formulas.\n    -   The relative error $\\varepsilon_{\\omega}(b_s)$ is calculated.\n    -   A log-log linear regression, identical to the one in the first task, is performed to estimate $p_\\omega$.\n\n3.  **Boundary Small-$b_s$ Eigenvalue Error:**\n    -   Using $\\alpha = 0.5$ and $\\omega_\\star = 1.0$, the exact and approximate eigenvalues are computed for a single small value, $b_s = 10^{-8}$.\n    -   The absolute error $|\\omega(b_s) - \\omega_{\\text{lin}}(b_s)|$ is then calculated directly.\n\n4.  **Moderate $b_s$ Gyroaveraging Error:**\n    -   For $b_s = 10^{-1}$, the exact and approximate gyroaveraging functions are computed.\n    -   The absolute error $|\\Gamma_0(b_s) - \\Gamma_{0,\\text{lin}}(b_s)|$ is calculated directly.\n\nThese four results will be computed, rounded to the specified precision, and formatted into a single output line as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0\n\ndef solve():\n    \"\"\"\n    Performs a convergence study for the gyroaveraging operator and a derived\n    eigenvalue problem, as specified in the problem statement.\n    \"\"\"\n\n    # --- Core Function Definitions ---\n\n    def gamma0(bs: np.ndarray) - np.ndarray:\n        \"\"\"Computes the exact gyroaveraging function Gamma_0(b_s).\"\"\"\n        return i0(bs) * np.exp(-bs)\n\n    def gamma0_lin(bs: np.ndarray) - np.ndarray:\n        \"\"\"Computes the linearized approximation of Gamma_0(b_s).\"\"\"\n        return 1.0 - bs\n\n    def omega(bs: np.ndarray, alpha: float, omega_star: float) - np.ndarray:\n        \"\"\"Computes the exact eigenvalue omega.\"\"\"\n        return omega_star / (1.0 + alpha * (1.0 - gamma0(bs)))\n\n    def omega_lin(bs: np.ndarray, alpha: float, omega_star: float) - np.ndarray:\n        \"\"\"Computes the linearized approximation of the eigenvalue.\"\"\"\n        return omega_star / (1.0 + alpha * bs)\n\n    # --- Test Suite Calculations ---\n\n    # 1. Gamma function scaling test\n    bs_values_p_gamma = np.array([1e-1, 5e-2, 2.5e-2, 1.25e-2, 6.25e-3])\n    gamma0_vals = gamma0(bs_values_p_gamma)\n    gamma0_lin_vals = gamma0_lin(bs_values_p_gamma)\n    \n    eps_gamma = np.abs(gamma0_vals - gamma0_lin_vals) / np.abs(gamma0_vals)\n    \n    log_bs_gamma = np.log(bs_values_p_gamma)\n    log_eps_gamma = np.log(eps_gamma)\n    \n    # Perform a linear least-squares fit (slope is the scaling exponent)\n    p_gamma = np.polyfit(log_bs_gamma, log_eps_gamma, 1)[0]\n\n    # 2. Eigenvalue scaling test (happy path)\n    alpha_p_omega = 0.5\n    omega_star_p_omega = 1.0\n    bs_values_p_omega = np.array([1e-1, 5e-2, 2.5e-2, 1.25e-2, 6.25e-3])\n\n    omega_vals = omega(bs_values_p_omega, alpha_p_omega, omega_star_p_omega)\n    omega_lin_vals = omega_lin(bs_values_p_omega, alpha_p_omega, omega_star_p_omega)\n\n    eps_omega = np.abs(omega_vals - omega_lin_vals) / np.abs(omega_vals)\n    \n    log_bs_omega = np.log(bs_values_p_omega)\n    log_eps_omega = np.log(eps_omega)\n    \n    p_omega = np.polyfit(log_bs_omega, log_eps_omega, 1)[0]\n    \n    # 3. Boundary small-b_s case for eigenvalue error magnitude\n    alpha_err_omega = 0.5\n    omega_star_err_omega = 1.0\n    bs_val_err_omega = 1e-8\n    \n    omega_val_exact = omega(bs_val_err_omega, alpha_err_omega, omega_star_err_omega)\n    omega_val_lin = omega_lin(bs_val_err_omega, alpha_err_omega, omega_star_err_omega)\n    \n    abs_err_omega = np.abs(omega_val_exact - omega_val_lin)\n\n    # 4. Moderate b_s check for the gyroaveraging function\n    bs_val_err_gamma = 1e-1\n    \n    gamma0_val_exact = gamma0(bs_val_err_gamma)\n    gamma0_val_lin = gamma0_lin(bs_val_err_gamma)\n    \n    abs_err_gamma = np.abs(gamma0_val_exact - gamma0_val_lin)\n\n    # --- Final Output Formatting ---\n    # The format string '{value:.Nf}' handles rounding to N decimal places.\n    print(f\"[{p_gamma:.3f},{p_omega:.3f},{abs_err_omega:.12f},{abs_err_gamma:.12f}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building upon a verified understanding of key operators, the next step is to construct and solve a complete eigenvalue problem. This practice guides you through a core task in developing a linear gyrokinetic solver: discretizing the velocity-space dependence of the gyrokinetic equation using a Hermite polynomial expansion . By converting the integro-differential equation into a matrix eigenvalue problem for the Electron Temperature Gradient (ETG) mode, you will gain hands-on experience with the numerical machinery at the heart of modern eigenvalue solvers.",
            "id": "4001874",
            "problem": "Consider the electrostatic, collisionally damped, linear gyrokinetic electron dynamics in slab geometry with adiabatic (Boltzmann) ions and zero magnetic curvature. The objective is to compute the Electron Temperature Gradient (ETG) mode growth rate for specified electron temperature gradient parameter $\\eta_e$, binormal wavenumber normalized to the electron gyroradius $k_y \\rho_e$, and normalized collisionality, and then compare the computed ETG growth rate with a canonical Ion Temperature Gradient (ITG) scaling trend. The results must be expressed in dimensionless units, specifically with all frequencies normalized to the electron diamagnetic frequency magnitude. The angle unit does not apply. No physical units beyond the stated normalization should appear in the output.\n\nStart from the linear electrostatic gyrokinetic equation for electrons,\n$$\n\\left(- i \\omega + i k_{\\parallel} v_{\\parallel} + \\nu_e \\right) g_e = i \\omega_{*e} \\, J_0\\!\\left(k_\\perp \\rho_e\\right) \\, F_{0e} \\left[ 1 + \\eta_e \\left(\\frac{v^2}{v_{\\mathrm{th},e}^2} - \\frac{3}{2}\\right)\\right] \\, \\frac{e \\phi}{T_e},\n$$\nwhere $g_e$ is the non-adiabatic electron distribution function, $F_{0e}$ is the electron Maxwellian, $J_0$ is the Bessel function of the first kind of order zero (arising from gyroaveraging at finite Larmor radius), $k_{\\parallel}$ is the parallel wave number, $v_{\\parallel}$ is the parallel velocity, $\\nu_e$ is a model collision frequency, $\\omega_{*e}$ is the electron diamagnetic frequency, $\\rho_e$ is the electron Larmor radius, $v_{\\mathrm{th},e}$ is the electron thermal speed, $e$ is the elementary charge, $T_e$ is the electron temperature, and $\\phi$ is the electrostatic potential. Assume slab geometry with $k_x = 0$ so that $k_\\perp = k_y$.\n\nProject the velocity-space dependence onto a Hermite polynomial basis in $v_{\\parallel}$, normalized such that the Hermite moments $h_m$ satisfy the streaming relation\n$$\nv_{\\parallel} \\varphi_m(v_{\\parallel}) \\propto \\sqrt{m+1} \\, \\varphi_{m+1}(v_{\\parallel}) + \\sqrt{m} \\, \\varphi_{m-1}(v_{\\parallel}),\n$$\nwith integer $m \\ge 0$ and $\\varphi_m$ denoting orthonormal Hermite functions weighted by the Maxwellian $F_{0e}$. Use a Lenard–Bernstein collision model that damps Hermite moment $h_m$ at a rate proportional to $m$. Truncate the Hermite expansion at $m = M-1$ and apply the standard closure $h_M \\approx 0$.\n\nImpose quasineutrality with Boltzmann ions. In electron-scale slab ETG, ions are Boltzmann, so the ion density perturbation is $\\delta n_i / n_0 = (e \\phi / T_i)$, while the electron density perturbation is $\\delta n_e / n_0 = - (e \\phi / T_e) + \\Gamma_0(b_e) h_0$, where $h_0$ is the electron density moment (the velocity integral of $J_0 g_e$ appropriately normalized) and $\\Gamma_0(b_e) \\equiv I_0(b_e) \\exp(-b_e)$ with $b_e \\equiv (k_\\perp \\rho_e)^2$ and $I_0$ the modified Bessel function of the first kind of order zero. Quasineutrality $e \\delta n_i - e \\delta n_e = 0$ then gives a relation between the dimensionless electrostatic potential $\\hat{\\phi} \\equiv e \\phi / T_e$ and the electron density moment:\n$$\n\\hat{\\phi} = \\frac{\\Gamma_0(b_e)}{1 + \\tau} \\, h_0,\n$$\nwhere $\\tau \\equiv T_e / T_i$. Take $\\tau = 1$.\n\nIn the Hermite representation, the velocity-space structure of the ETG drive $1 + \\eta_e (v^2 / v_{\\mathrm{th},e}^2 - 3/2)$ projects onto the $m=0$ and $m=2$ Hermite moments only. Denote these drive projection coefficients by $a_0 = 1$ and $a_2 = \\eta_e \\sqrt{2}$, with $a_m = 0$ for all other $m$. After substituting the quasineutrality relation to eliminate $\\hat{\\phi}$ in favor of $h_0$, and normalizing frequencies to $\\omega_{*e}$, normalize the parallel streaming factor $k_{\\parallel} v_{\\mathrm{th},e}$ to unity. The resulting eigenvalue problem for the Hermite moment vector $\\mathbf{h} = (h_0, h_1, \\dots, h_{M-1})^\\top$ is\n$$\n\\omega h_m = i \\, \\nu_e \\, m \\, h_m + \\alpha \\left( \\sqrt{m+1} \\, h_{m+1} + \\sqrt{m} \\, h_{m-1} \\right) - C \\, a_m \\, h_0,\n$$\nfor $m = 0, 1, \\dots, M-1$, with $h_{-1} \\equiv 0$, $h_M \\equiv 0$, $\\alpha \\equiv k_{\\parallel} v_{\\mathrm{th},e} / \\omega_{*e} = 1$, and\n$$\nC \\equiv \\frac{\\Gamma_0(b_e)}{1 + \\tau}, \\quad \\Gamma_0(b_e) \\equiv I_0(b_e) \\, e^{-b_e}, \\quad b_e \\equiv (k_y \\rho_e)^2.\n$$\nThis system defines a linear operator $\\mathcal{L}$ such that $\\mathcal{L} \\, \\mathbf{h} = \\omega \\, \\mathbf{h}$. The ETG growth rate is the maximum imaginary part $\\gamma \\equiv \\max\\limits_j \\operatorname{Im}(\\omega_j)$ among eigenvalues $\\omega_j$ of $\\mathcal{L}$. All quantities are dimensionless and frequencies are normalized to the magnitude of the electron diamagnetic frequency, so $\\gamma$ is a dimensionless growth rate.\n\nTo compare with a canonical Ion Temperature Gradient (ITG) scaling trend, define the following dimensionless ITG-like scaling proxy function using the same binormal wavenumber normalization:\n$$\n\\gamma_{\\mathrm{ITG,\\,scale}}(\\eta_e, k_y \\rho_e) \\equiv \\frac{\\sqrt{\\eta_e}}{1 + (k_y \\rho_e)^2}.\n$$\nThis proxy captures the square-root dependence on the temperature gradient parameter and the gyroaveraging reduction with increasing perpendicular wavenumber as a trend reference. The comparison metric for each test case is the ratio\n$$\n\\mathcal{R} \\equiv \\frac{\\gamma_{\\mathrm{ETG}}}{\\gamma_{\\mathrm{ITG,\\,scale}}}.\n$$\n\nImplement the following computational task:\n- Construct the matrix representation of $\\mathcal{L}$ for a chosen Hermite truncation $M$ with the above model assumptions and normalization.\n- Compute all eigenvalues of $\\mathcal{L}$ and determine $\\gamma_{\\mathrm{ETG}}$ as the largest imaginary part.\n- Compute the comparison ratio $\\mathcal{R}$ for each test case using the provided scaling proxy.\n\nUse the following test suite of parameter values $(\\eta_e, k_y \\rho_e, \\nu_e)$:\n1. $(1.0, 0.30, 0.00)$\n2. $(0.2, 0.30, 0.00)$\n3. $(2.0, 1.00, 0.50)$\n4. $(4.0, 0.05, 0.00)$\n5. $(1.5, 2.00, 0.20)$\n\nDesign for coverage:\n- Case 1 is a general collisionless ETG drive at moderate wavenumber (happy path).\n- Case 2 approaches weak drive (boundary), testing near-stability.\n- Case 3 tests finite collisional damping at order-unity wavenumber.\n- Case 4 examines long-wavelength limit where gyroaveraging is weak.\n- Case 5 probes strong gyroaveraging at high wavenumber with moderate collisionality.\n\nFinal output specification:\n- Your program should produce a single line of output containing the concatenated list of numbers in the order $[\\gamma_1, \\mathcal{R}_1, \\gamma_2, \\mathcal{R}_2, \\dots, \\gamma_5, \\mathcal{R}_5]$, where $\\gamma_j$ and $\\mathcal{R}_j$ are the ETG growth rate and comparison ratio for test case $j$, respectively. All values must be floats in the stated normalization. No other text should be printed.",
            "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded in the established principles of linear gyrokinetic theory, is self-contained, and is mathematically well-posed as a linear eigenvalue problem. All necessary parameters and definitions are provided, and the problem is free of contradictions or factual inaccuracies. The single unspecified parameter, the Hermite moment truncation number $M$, is an aspect of the numerical implementation strategy rather than a flaw in the problem's formulation. A solver is reasonably expected to select a value for $M$ that ensures numerical convergence.\n\nThe task is to compute the growth rate of the Electron Temperature Gradient (ETG) mode and compare it to a reference scaling. This requires solving the linear gyrokinetic eigenvalue problem presented in a reduced Hermite moment representation. The governing equation for the vector of Hermite moments $\\mathbf{h} = (h_0, h_1, \\dots, h_{M-1})^\\top$ is given as:\n$$\n\\omega h_m = i \\, \\nu_e \\, m \\, h_m + \\alpha \\left( \\sqrt{m+1} \\, h_{m+1} + \\sqrt{m} \\, h_{m-1} \\right) - C \\, a_m \\, h_0\n$$\nfor $m = 0, 1, \\dots, M-1$, subject to the closure conditions $h_{-1} \\equiv 0$ and $h_M \\equiv 0$. Here, $\\omega$ is the complex mode frequency, normalized to the magnitude of the electron diamagnetic frequency $\\omega_{*e}$. The imaginary part of $\\omega$, denoted $\\gamma \\equiv \\operatorname{Im}(\\omega)$, represents the mode's growth rate. The ETG growth rate is the largest growth rate among all eigenmodes, $\\gamma_{\\mathrm{ETG}} = \\max_j \\operatorname{Im}(\\omega_j)$.\n\nThis system of linear equations defines a matrix eigenvalue problem of the form $\\mathcal{L} \\mathbf{h} = \\omega \\mathbf{h}$, where $\\mathcal{L}$ is a linear operator whose matrix representation we must construct. The elements of the $M \\times M$ matrix $\\mathbf{L}$, denoted $\\mathcal{L}_{mn}$, are determined by identifying the coefficients of each moment $h_n$ in the expression for $\\omega h_m$. The operator $\\mathcal{L}$ can be additively decomposed into three components corresponding to distinct physical effects: parallel streaming, collisional damping, and the ETG drive modified by gyroaveraging and quasineutrality.\n\n$1$. **Parallel Streaming Operator ($\\mathcal{L}_{\\mathrm{stream}}$)**: This component arises from the term $\\alpha (\\sqrt{m+1} h_{m+1} + \\sqrt{m} h_{m-1})$. It couples adjacent Hermite moments and is represented by a real, symmetric, tridiagonal matrix. With the normalization $\\alpha \\equiv k_{\\parallel} v_{\\mathrm{th},e} / \\omega_{*e} = 1$, its non-zero elements are:\n$$\n\\mathcal{L}_{m, m+1}^{\\mathrm{stream}} = \\sqrt{m+1} \\quad \\text{for } m = 0, \\dots, M-2\n$$\n$$\n\\mathcal{L}_{m, m-1}^{\\mathrm{stream}} = \\sqrt{m} \\quad \\text{for } m = 1, \\dots, M-1\n$$\n\n$2$. **Collisional Damping Operator ($\\mathcal{L}_{\\mathrm{coll}}$)**: This component comes from the Lenard–Bernstein model collision term $i \\nu_e m h_m$. It is represented by a diagonal matrix with purely imaginary elements, where $\\nu_e$ is the normalized collision frequency. The damping rate is proportional to the moment index $m$.\n$$\n\\mathcal{L}_{mm}^{\\mathrm{coll}} = i \\nu_e m\n$$\n\n$3$. **Drive Operator ($\\mathcal{L}_{\\mathrm{drive}}$)**: This component, $-C a_m h_0$, represents the source of instability. It couples all moments back to the density perturbation moment $h_0$. It is represented by a matrix that is zero everywhere except for its first column ($n=0$). The coupling strength $C$ is given by\n$$\nC = \\frac{\\Gamma_0(b_e)}{1 + \\tau} \\quad \\text{where} \\quad \\Gamma_0(b_e) = I_0(b_e) e^{-b_e}, \\quad b_e = (k_y \\rho_e)^2, \\quad \\tau = 1\n$$\nThe projection coefficients $a_m$ are non-zero only for $m=0$ ($a_0 = 1$) and $m=2$ ($a_2 = \\eta_e \\sqrt{2}$). The drive matrix elements are:\n$$\n\\mathcal{L}_{m0}^{\\mathrm{drive}} = -C a_m\n$$\n\nThe total operator is the sum $\\mathcal{L} = \\mathcal{L}_{\\mathrm{stream}} + \\mathcal{L}_{\\mathrm{coll}} + \\mathcal{L}_{\\mathrm{drive}}$. The elements of its matrix representation $\\mathbf{L}$ are thus:\n$$\n\\mathcal{L}_{mn} = \\sqrt{m+1} \\, \\delta_{n, m+1} + \\sqrt{m} \\, \\delta_{n, m-1} + i \\nu_e m \\, \\delta_{mn} - C a_m \\, \\delta_{n0}\n$$\nwhere $\\delta_{ij}$ is the Kronecker delta. The Hermite series must be truncated at a sufficiently high moment number, $M$, to ensure the numerical convergence of the eigenvalues. For the parameter regimes under consideration, a choice of $M = 64$ provides adequate resolution of the electron velocity-space dynamics.\n\nThe computational procedure for each test case $(\\eta_e, k_y \\rho_e, \\nu_e)$ is as follows:\n$1$. Calculate the parameters $b_e = (k_y \\rho_e)^2$ and $C = I_0(b_e) e^{-b_e} / 2$.\n$2$. Construct the $M \\times M$ complex matrix $\\mathbf{L}$ using the expression for $\\mathcal{L}_{mn}$.\n$3$. Compute the set of all eigenvalues $\\{\\omega_j\\}$ of $\\mathbf{L}$.\n$4$. Determine the ETG growth rate by finding the maximum imaginary part among all eigenvalues: $\\gamma_{\\mathrm{ETG}} = \\max_j \\operatorname{Im}(\\omega_j)$.\n$5$. Compute the ITG-like scaling proxy: $\\gamma_{\\mathrm{ITG,\\,scale}} = \\sqrt{\\eta_e} / (1 + (k_y \\rho_e)^2)$.\n$6$. Calculate the comparison ratio $\\mathcal{R} = \\gamma_{\\mathrm{ETG}} / \\gamma_{\\mathrm{ITG,\\,scale}}$.\n\nThis process is repeated for all five test cases provided in the problem statement. The resulting values for $\\gamma_{\\mathrm{ETG}}$ and $\\mathcal{R}$ are collected and formatted into the specified output string.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0\n\ndef solve():\n    \"\"\"\n    Solves the linear gyrokinetic eigenvalue problem for the ETG mode,\n    computes the growth rate and a comparison metric for a suite of test cases.\n    \"\"\"\n    \n    # Hermite truncation number. Chosen to be sufficient for convergence.\n    M = 64\n    \n    # Normalization constants from the problem statement.\n    alpha = 1.0\n    tau = 1.0\n\n    # Define the test cases from the problem statement.\n    # Format: (eta_e, k_y_rho_e, nu_e)\n    test_cases = [\n        (1.0, 0.30, 0.00),\n        (0.2, 0.30, 0.00),\n        (2.0, 1.00, 0.50),\n        (4.0, 0.05, 0.00),\n        (1.5, 2.00, 0.20),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        eta_e, ky_rho_e, nu_e = case\n\n        # 1. Construct the matrix representation of the operator L.\n        \n        # Initialize the M x M complex matrix L.\n        L = np.zeros((M, M), dtype=complex)\n        \n        # Moment indices.\n        m_vals = np.arange(M)\n\n        # a) Streaming part (tridiagonal).\n        # Super-diagonal (couples m to m+1)\n        if M  1:\n            super_diag = alpha * np.sqrt(m_vals[:-1] + 1)\n            np.fill_diagonal(L[:, 1:], super_diag)\n        # Sub-diagonal (couples m to m-1)\n        if M  1:\n            sub_diag = alpha * np.sqrt(m_vals[1:])\n            np.fill_diagonal(L[1:, :], sub_diag)\n\n        # b) Collisional damping part (diagonal).\n        # This adds to the main diagonal.\n        np.fill_diagonal(L, L.diagonal() + 1j * nu_e * m_vals)\n\n        # c) Drive part (modifies the first column).\n        # Calculate the coupling coefficient C.\n        b_e = ky_rho_e**2\n        gamma_0_be = i0(b_e) * np.exp(-b_e)\n        C = gamma_0_be / (1.0 + tau)\n\n        # Construct the drive projection vector a_m.\n        a_m = np.zeros(M)\n        a_m[0] = 1.0\n        if M  2:\n            a_m[2] = eta_e * np.sqrt(2.0)\n        \n        # Add the drive term to the first column of L.\n        L[:, 0] -= C * a_m\n\n        # 2. Compute eigenvalues and find the maximum growth rate.\n        eigenvalues = np.linalg.eigvals(L)\n        gamma_etg = np.max(eigenvalues.imag)\n\n        # 3. Compute the comparison metric R.\n        # Guard against eta_e = 0 cases, although not present in test suite.\n        if eta_e > 0:\n            gamma_itg_scale = np.sqrt(eta_e) / (1.0 + ky_rho_e**2)\n            # Avoid division by zero if scaling is zero\n            if gamma_itg_scale > 1e-12:\n                R = gamma_etg / gamma_itg_scale\n            else:\n                R = np.inf if gamma_etg > 0 else 0.0\n        else:\n            gamma_itg_scale = 0.0\n            R = np.inf if gamma_etg > 0 else 0.0\n\n        # Ensure that modes that should be stable are reported with zero growth rate.\n        if gamma_etg  1e-12:\n            gamma_etg = 0.0\n            \n        results.append(gamma_etg)\n        results.append(R)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a working eigenvalue solver, we can move beyond simply finding growth rates to performing more sophisticated model analysis. This advanced practice introduces the adjoint method, a powerful technique for calculating the sensitivity of eigenvalues to model parameters without the need for numerous, costly finite-difference calculations . Implementing this method for a reduced Ion Temperature Gradient (ITG) model will equip you with an essential research tool for understanding parametric dependencies, performing model optimization, and conducting uncertainty quantification.",
            "id": "4001903",
            "problem": "You are asked to implement a complete program that computes adjoint-based sensitivities of the dominant eigenvalue of a simplified linear gyrokinetic operator with respect to the binormal wavenumber and the ion temperature gradient scale length. The context is slab Ion Temperature Gradient (ITG) dynamics with adiabatic electrons under a reduced gyrofluid closure. The computation must be validated against finite-difference approximations for a small set of test cases. The program must be self-contained and produce the required outputs in the specified format without requiring user input.\n\nThe fundamental base is the linearization of coupled ion density and ion temperature fluctuations under drift-wave dynamics with adiabatic electrons, represented as a non-Hermitian eigenvalue problem for the state vector. This representation reflects linear gyrokinetic behavior under a reduced gyrofluid approximation and enables rigorous sensitivity analysis via the adjoint method for non-normal operators. The analysis is formulated purely mathematically in terms of a parameter-dependent complex matrix and its eigenpairs.\n\nDefine the parameter-dependent complex matrix operator as follows. Let $k_y$ be the dimensionless binormal wavenumber and $L_T$ be the dimensionless ion temperature gradient scale length. Introduce fixed dimensionless constants with the specified values:\n- $L_n = 2.0$,\n- $a_T = 0.7$,\n- $\\beta = 0.9$,\n- $\\nu = 0.05$,\n- $g_0 = 0.2$,\n- $c_{\\mathrm{FLR}} = 0.3$.\n\nDefine the temperature gradient coupling and finite Larmor radius stabilization functions by\n$$\n\\alpha(L_T) = a_T \\frac{L_n}{L_T}, \\qquad \\gamma(k_y) = g_0 + c_{\\mathrm{FLR}} k_y^2.\n$$\nThe operator is the $2 \\times 2$ complex matrix\n$$\nA(k_y,L_T) =\n\\begin{pmatrix}\n- i k_y  i k_y \\,\\alpha(L_T) \\\\\ni k_y \\,\\beta  -\\left(\\nu + i k_y \\,\\gamma(k_y)\\right)\n\\end{pmatrix},\n$$\nwhere $i$ is the imaginary unit. This definition reflects linear drift-wave advection ($-i k_y$), temperature-gradient drive ($i k_y \\alpha$), and stabilization/damping ($\\nu$ and $i k_y \\gamma$) in a reduced gyrofluid setting.\n\nYou must implement an adjoint-based sensitivity analysis for the dominant eigenvalue $\\lambda(k_y,L_T)$ of $A(k_y,L_T)$, defined as the eigenvalue with the largest imaginary part. For each test case, compute the complex derivatives $\\partial \\lambda / \\partial k_y$ and $\\partial \\lambda / \\partial L_T$ using the adjoint method and validate those derivatives with central finite-difference approximations computed by perturbing $k_y$ and $L_T$ independently. Your implementation must include robust mode tracking to ensure that the finite-difference perturbations at $(k_y \\pm h, L_T)$ and $(k_y, L_T \\pm h)$ are matched to the same eigenmode branch as the unperturbed $\\lambda(k_y,L_T)$ by minimizing the distance in the complex plane. Use a small real positive step size $h$ for the perturbations and make your choice numerically stable.\n\nYour program must compute for each test case the relative errors between the adjoint sensitivities and the finite differences:\n$$\n\\mathrm{err}_{k_y} = \\frac{\\left|\\frac{\\partial \\lambda}{\\partial k_y}\\big|_{\\mathrm{adj}} - \\frac{\\partial \\lambda}{\\partial k_y}\\big|_{\\mathrm{fd}}\\right|}{\\max\\left(\\left|\\frac{\\partial \\lambda}{\\partial k_y}\\big|_{\\mathrm{fd}}\\right|, \\epsilon\\right)}, \\quad\n\\mathrm{err}_{L_T} = \\frac{\\left|\\frac{\\partial \\lambda}{\\partial L_T}\\big|_{\\mathrm{adj}} - \\frac{\\partial \\lambda}{\\partial L_T}\\big|_{\\mathrm{fd}}\\right|}{\\max\\left(\\left|\\frac{\\partial \\lambda}{\\partial L_T}\\big|_{\\mathrm{fd}}\\right|, \\epsilon\\right)},\n$$\nwhere $\\epsilon$ is a small real positive constant for numerical regularization.\n\nImplement the program using the following test suite of parameter values:\n- Case $1$: $k_y = 0.4$, $L_T = 3.0$,\n- Case $2$: $k_y = 0.1$, $L_T = 6.0$,\n- Case $3$: $k_y = 1.0$, $L_T = 1.5$,\n- Case $4$: $k_y = 0.05$, $L_T = 2.5$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,\\dots]$). The list must contain, in order, for each case, the two floating-point numbers $\\mathrm{err}_{k_y}$ and $\\mathrm{err}_{L_T}$ for that case, concatenated across all cases, yielding $8$ numbers total. All quantities are dimensionless, and no physical unit conversion is required. Angles are not used in this problem. Percentages must not be used; all ratios must be expressed as decimal values.",
            "solution": "The posed problem is scientifically and mathematically valid. It is a well-defined exercise in computational science, specifically in the sensitivity analysis of a non-Hermitian eigenvalue problem that models a physical system. All necessary data and definitions are provided, and the objective is clear. The problem is self-contained, consistent, and solvable using standard numerical methods. We may therefore proceed with the solution.\n\nThe problem requires a sensitivity analysis of the dominant eigenvalue of a parameter-dependent matrix $A(k_y, L_T)$, which represents a simplified linear gyrokinetic operator for Ion Temperature Gradient (ITG) modes. The sensitivity of an eigenvalue $\\lambda$ with respect to a parameter $p$ is the derivative $\\partial \\lambda / \\partial p$. We will compute this derivative using two methods: the adjoint method, which is analytically exact, and the finite-difference method, which serves as a numerical validation.\n\nThe system is described by the $2 \\times 2$ complex matrix:\n$$\nA(k_y, L_T) =\n\\begin{pmatrix}\n- i k_y  i k_y \\,\\alpha(L_T) \\\\\ni k_y \\,\\beta  -\\left(\\nu + i k_y \\,\\gamma(k_y)\\right)\n\\end{pmatrix}\n$$\nwhere $k_y$ is the binormal wavenumber, $L_T$ is the ion temperature gradient scale length, and $i$ is the imaginary unit. The functions $\\alpha(L_T)$ and $\\gamma(k_y)$ are defined as:\n$$\n\\alpha(L_T) = a_T \\frac{L_n}{L_T}, \\qquad \\gamma(k_y) = g_0 + c_{\\mathrm{FLR}} k_y^2\n$$\nThe constants are given as $L_n = 2.0$, $a_T = 0.7$, $\\beta = 0.9$, $\\nu = 0.05$, $g_0 = 0.2$, and $c_{\\mathrm{FLR}} = 0.3$.\n\nThe evolution of the system's linear perturbations is governed by an eigenvalue problem. If the state vector is $z$, its time-evolution is $\\partial z / \\partial t = A z$. Assuming a modal solution $z(t) = x e^{\\lambda t}$, we obtain the right eigenvalue problem:\n$$\nA x = \\lambda x\n$$\nThe eigenvalues $\\lambda$ are complex frequencies. The imaginary part, $\\Im(\\lambda)$, is the growth rate of the mode. The \"dominant\" eigenvalue is the one with the largest growth rate, i.e., the largest imaginary part.\n\n**Adjoint-Based Sensitivity Analysis**\n\nThe matrix $A$ is non-Hermitian, which is typical for systems with sources of free energy (like the temperature gradient) and dissipation. For such systems, the left and right eigenvectors are not simple conjugate transposes of each other. The sensitivity of an eigenvalue $\\lambda$ to a parameter $p$ can be derived using the corresponding left eigenvector $\\psi$. The left eigenvalue problem is defined as $\\psi^\\dagger A = \\lambda \\psi^\\dagger$, where $\\psi^\\dagger$ is the conjugate transpose of $\\psi$. An equivalent formulation is the right eigenvalue problem for the adjoint matrix $A^\\dagger = A^T_c$ (conjugate transpose):\n$$\nA^\\dagger \\psi = \\lambda^* \\psi\n$$\nwhere $\\lambda^*$ is the complex conjugate of $\\lambda$. Thus, the left eigenvector of $A$ for eigenvalue $\\lambda$ is the right eigenvector of $A^\\dagger$ for eigenvalue $\\lambda^*$.\n\nBy differentiating the eigenvalue equation $A x = \\lambda x$ with respect to a parameter $p$ and left-multiplying by $\\psi^\\dagger$, one can derive the well-known formula for the eigenvalue sensitivity:\n$$\n\\frac{\\partial \\lambda}{\\partial p} = \\frac{\\psi^\\dagger \\left( \\frac{\\partial A}{\\partial p} \\right) x}{\\psi^\\dagger x}\n$$\nThis formula is exact and avoids the need to compute the derivative of the eigenvectors.\n\nTo apply this formula, we first need the derivatives of the matrix $A$ with respect to the parameters $k_y$ and $L_T$.\nThe derivative with respect to $L_T$ is:\n$$\n\\frac{\\partial A}{\\partial L_T} = \\begin{pmatrix} 0  i k_y \\frac{\\partial \\alpha}{\\partial L_T} \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} 0  -i k_y \\frac{a_T L_n}{L_T^2} \\\\ 0  0 \\end{pmatrix}\n$$\nThe derivative with respect to $k_y$ is:\n$$\n\\frac{\\partial A}{\\partial k_y} = \\frac{\\partial}{\\partial k_y} \\begin{pmatrix} - i k_y  i k_y \\alpha(L_T) \\\\ i k_y \\beta  -\\nu - i k_y g_0 - i c_{\\mathrm{FLR}} k_y^3 \\end{pmatrix} = \\begin{pmatrix} -i  i \\alpha(L_T) \\\\ i \\beta  -i g_0 - 3 i c_{\\mathrm{FLR}} k_y^2 \\end{pmatrix} = \\begin{pmatrix} -i  i \\alpha(L_T) \\\\ i \\beta  -i (g_0 + 3 c_{\\mathrm{FLR}} k_y^2) \\end{pmatrix}\n$$\n\nThe computational procedure for the adjoint sensitivity is as follows for each parameter $p \\in \\{k_y, L_T\\}$:\n$1$. For a given pair $(k_y, L_T)$, construct the matrix $A$.\n$2$. Solve the right eigenvalue problem $A x_j = \\lambda_j x_j$ to find all eigenvalues and eigenvectors.\n$3$. Identify the dominant eigenvalue $\\lambda$ as the one with the largest imaginary part, and its corresponding right eigenvector $x$.\n$4$. Construct the adjoint matrix $A^\\dagger$.\n$5$. Solve the adjoint eigenvalue problem $A^\\dagger \\psi_j = \\mu_j \\psi_j$.\n$6$. Identify the adjoint eigenvector $\\psi$ corresponding to $\\lambda$ by finding the eigenvector $\\psi_j$ whose eigenvalue $\\mu_j$ is the complex conjugate of $\\lambda$ (i.e., $\\mu_j \\approx \\lambda^*$).\n$7$. Compute the matrix derivative $\\partial A / \\partial p$.\n$8$. Calculate the sensitivity $\\partial \\lambda / \\partial p$ using the formula $\\frac{\\psi^\\dagger (\\partial A / \\partial p) x}{\\psi^\\dagger x}$.\n\n**Finite-Difference Validation**\n\nTo validate the adjoint sensitivities, we compute numerical approximations using the central finite-difference formula:\n$$\n\\frac{\\partial \\lambda}{\\partial p} \\bigg|_{\\mathrm{fd}} \\approx \\frac{\\lambda(p+h) - \\lambda(p-h)}{2h}\n$$\nwhere $h$ is a small, real, positive step size. A numerically stable choice for $h$ must be small enough to minimize truncation error but large enough to avoid catastrophic cancellation from floating-point arithmetic. We will use $h = 10^{-7}$.\n\nA critical step is **mode tracking**. When we compute the eigenvalues of the perturbed matrices, e.g., $A(k_y+h, L_T)$, we obtain a set of new eigenvalues. We must identify which of these new eigenvalues corresponds to the dominant mode of the unperturbed system. This is achieved by finding the new eigenvalue that is closest in the complex plane to the original dominant eigenvalue $\\lambda(k_y, L_T)$. Specifically, we compute the eigenvalues $\\{\\lambda'_j\\}$ of the perturbed matrix and select the one, $\\lambda(p+h)$, that minimizes the distance $|\\lambda'_j - \\lambda(p)|$. The same procedure is applied for the perturbation $p-h$.\n\n**Error Calculation**\n\nFinally, for each test case and for each parameter, we compute the relative error between the adjoint and finite-difference results:\n$$\n\\mathrm{err}_{p} = \\frac{\\left|\\frac{\\partial \\lambda}{\\partial p}\\big|_{\\mathrm{adj}} - \\frac{\\partial \\lambda}{\\partial p}\\big|_{\\mathrm{fd}}\\right|}{\\max\\left(\\left|\\frac{\\partial \\lambda}{\\partial p}\\big|_{\\mathrm{fd}}\\right|, \\epsilon\\right)}\n$$\nThe regularization parameter $\\epsilon$ prevents division by a very small number or zero. We choose $\\epsilon = 10^{-14}$. A small error validates the correctness of our adjoint implementation.\n\nThe following implementation will systematically perform these calculations for each test case provided in the problem statement.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and validates adjoint-based sensitivities of a gyrofluid eigenvalue problem.\n    \"\"\"\n\n    # --- Fixed dimensionless constants ---\n    L_n = 2.0\n    a_T = 0.7\n    beta = 0.9\n    nu = 0.05\n    g_0 = 0.2\n    c_FLR = 0.3\n\n    # --- Numerical parameters ---\n    h = 1e-7  # Step size for finite differences\n    epsilon = 1e-14  # Regularization for error calculation\n\n    # --- Test cases ---\n    test_cases = [\n        (0.4, 3.0),  # Case 1: ky, LT\n        (0.1, 6.0),  # Case 2: ky, LT\n        (1.0, 1.5),  # Case 3: ky, LT\n        (0.05, 2.5), # Case 4: ky, LT\n    ]\n\n    # --- Helper functions for matrix construction ---\n    def alpha(LT):\n        return a_T * L_n / LT\n\n    def gamma(ky):\n        return g_0 + c_FLR * ky**2\n\n    def get_A(ky, LT):\n        \"\"\"Constructs the operator matrix A.\"\"\"\n        a = alpha(LT)\n        g = gamma(ky)\n        A = np.array([\n            [-1j * ky, 1j * ky * a],\n            [1j * ky * beta, -(nu + 1j * ky * g)]\n        ], dtype=np.complex128)\n        return A\n\n    def get_dA_dky(ky, LT):\n        \"\"\"Constructs the derivative of A with respect to ky.\"\"\"\n        a = alpha(LT)\n        dA = np.array([\n            [-1j, 1j * a],\n            [1j * beta, -1j * (g_0 + 3 * c_FLR * ky**2)]\n        ], dtype=np.complex128)\n        return dA\n\n    def get_dA_dLT(ky, LT):\n        \"\"\"Constructs the derivative of A with respect to LT.\"\"\"\n        dA = np.array([\n            [0, -1j * ky * a_T * L_n / LT**2],\n            [0, 0]\n        ], dtype=np.complex128)\n        return dA\n\n    results = []\n    \n    for ky_0, LT_0 in test_cases:\n        # --- Base Calculation at (ky_0, LT_0) ---\n        A_0 = get_A(ky_0, LT_0)\n        \n        # Solve for right eigenpairs\n        lams, vecs = np.linalg.eig(A_0)\n        \n        # Find dominant mode (largest imaginary part)\n        idx_dom = np.argmax(lams.imag)\n        lam_dom = lams[idx_dom]\n        x_dom = vecs[:, idx_dom]\n        \n        # --- Adjoint Sensitivity Calculation ---\n        \n        # Solve for left eigenpairs (eigenvectors of A dagger)\n        A_adj = A_0.T.conj()\n        lams_adj, vecs_adj = np.linalg.eig(A_adj)\n        \n        # Find the adjoint eigenvector corresponding to the dominant mode\n        idx_adj = np.argmin(np.abs(lams_adj - lam_dom.conj()))\n        psi_dom = vecs_adj[:, idx_adj]\n        \n        # Calculate matrix-vector products\n        denominator = psi_dom.conj().T @ x_dom\n        \n        # Sensitivity w.r.t. ky\n        dA_dky = get_dA_dky(ky_0, LT_0)\n        numerator_ky = psi_dom.conj().T @ dA_dky @ x_dom\n        sens_ky_adj = numerator_ky / denominator\n        \n        # Sensitivity w.r.t. LT\n        dA_dLT = get_dA_dLT(ky_0, LT_0)\n        numerator_LT = psi_dom.conj().T @ dA_dLT @ x_dom\n        sens_LT_adj = numerator_LT / denominator\n\n        # --- Finite-Difference Validation ---\n\n        # Perturbation for ky\n        A_p_ky = get_A(ky_0 + h, LT_0)\n        A_m_ky = get_A(ky_0 - h, LT_0)\n        lams_p_ky, _ = np.linalg.eig(A_p_ky)\n        lams_m_ky, _ = np.linalg.eig(A_m_ky)\n        # Mode tracking\n        lam_p_ky = lams_p_ky[np.argmin(np.abs(lams_p_ky - lam_dom))]\n        lam_m_ky = lams_m_ky[np.argmin(np.abs(lams_m_ky - lam_dom))]\n        sens_ky_fd = (lam_p_ky - lam_m_ky) / (2 * h)\n\n        # Perturbation for LT\n        A_p_LT = get_A(ky_0, LT_0 + h)\n        A_m_LT = get_A(ky_0, LT_0 - h)\n        lams_p_LT, _ = np.linalg.eig(A_p_LT)\n        lams_m_LT, _ = np.linalg.eig(A_m_LT)\n        # Mode tracking\n        lam_p_LT = lams_p_LT[np.argmin(np.abs(lams_p_LT - lam_dom))]\n        lam_m_LT = lams_m_LT[np.argmin(np.abs(lams_m_LT - lam_dom))]\n        sens_LT_fd = (lam_p_LT - lam_m_LT) / (2 * h)\n\n        # --- Error Calculation ---\n        err_ky = np.abs(sens_ky_adj - sens_ky_fd) / max(np.abs(sens_ky_fd), epsilon)\n        err_LT = np.abs(sens_LT_adj - sens_LT_fd) / max(np.abs(sens_LT_fd), epsilon)\n        \n        results.extend([err_ky, err_LT])\n        \n    # Format the final output string\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}