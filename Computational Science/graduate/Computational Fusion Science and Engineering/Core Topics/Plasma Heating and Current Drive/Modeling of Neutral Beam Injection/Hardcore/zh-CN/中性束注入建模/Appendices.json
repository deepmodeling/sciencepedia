{
    "hands_on_practices": [
        {
            "introduction": "中性束在等离子体中的衰减主要是由与等离子体粒子的碰撞引起的，其中电子碰撞电离是一个关键过程。这个练习将指导你从动理学理论的第一性原理出发，推导并计算麦克斯韦分布下的电子碰撞电离反应速率系数 $\\langle\\sigma v\\rangle$ 。掌握这项基本计算，对于准确预测中性束穿透深度和功率沉积分布至关重要。",
            "id": "4014438",
            "problem": "一束单能的氘中性粒子($\\mathrm{D}^{0}$)束穿过托卡马克中性束注入线中的一个均匀、静止的等离子体段。等离子体中的电子是各向同性的，并服从麦克斯韦分布，电子温度为 $T_{e} = 2$ keV。在该段中，中性粒子的衰减主要由$\\mathrm{D}^{0}$的电子碰撞电离引起。\n\n从动理论和反应速率系数的定义（即产物 $\\sigma v$ 在速度空间上的平均值）出发，推导在温度为 $T_{e}$ 时，电子对$\\mathrm{D}^{0}$进行电子碰撞电离的麦克斯韦平均速率系数 $\\langle \\sigma v \\rangle$。假设电子碰撞电离截面由用于类氢原子的 Lotz 公式建模，\n$$\n\\sigma_{i}(E_{e}) = \n\\begin{cases}\n\\dfrac{a_{L} \\ln\\!\\left( \\dfrac{E_{e}}{I} \\right)}{E_{e} I}, & E_{e} \\ge I, \\\\\n0, & E_{e} < I,\n\\end{cases}\n$$\n其中 $E_{e}$ 是以电子伏特 (eV) 为单位的电子动能，$I$ 是以 eV 为单位的电离阈值，$a_{L}$ 是 Lotz 系数。使用 $I = 13.6$ eV 和 $a_{L} = 4.5 \\times 10^{-18}$ m$^{2}$ eV$^{2}$。\n\n然后，使用您计算出的 $\\langle \\sigma v \\rangle$，评估沿长度为 $L = 3.0$ m 的直线束线段的透射中性粒子分数，该束线段具有均匀的电子密度 $n_{e} = 1.0 \\times 10^{19}$ m$^{-3}$。将中性束速度视为恒定，其值由束能量 $E_{b} = 80$ keV 和氘原子质量 $m_{D} = 3.3436 \\times 10^{-27}$ kg 决定。假设电子与中性粒子碰撞中的相对速度主要由电子的热运动主导，并忽略任何其他衰减过程（例如与离子的电荷交换或与残余气体的相互作用）。\n\n您可以假设以下物理常数：电子质量 $m_{e} = 9.1093837015 \\times 10^{-31}$ kg 和基本电荷 $e = 1.602176634 \\times 10^{-19}$ C。在适当的情况下，用电子伏特表示任何中间能量，并确保最终 $\\langle \\sigma v \\rangle$ 的单位一致性。\n\n计算最终的透射分数 $N(L)/N(0)$，结果为一个无量纲小数。将您的最终答案四舍五入到三位有效数字。",
            "solution": "该解答分为两个主要部分：首先，推导和计算麦克斯韦平均速率系数 $\\langle \\sigma v \\rangle$；其次，计算中性束的衰减和透射分数。\n\n**第一部分：麦克斯韦平均速率系数 $\\langle \\sigma v \\rangle$ 的推导**\n\n两种粒子1和2之间反应的麦克斯韦平均速率系数定义为其相对速度 $v_{rel} = |\\mathbf{v}_1 - \\mathbf{v}_2|$ 与反应截面 $\\sigma(v_{rel})$ 的乘积在其速度分布上的平均值。\n$$ \\langle \\sigma v \\rangle = \\iint f_1(\\mathbf{v}_1) f_2(\\mathbf{v}_2) |\\mathbf{v}_1 - \\mathbf{v}_2| \\sigma(|\\mathbf{v}_1 - \\mathbf{v}_2|) d^3\\mathbf{v}_1 d^3\\mathbf{v}_2 $$\n在此，粒子1是电子（$e$），粒子2是氘中性粒子（$\\mathrm{D}^0$）。中性束是单能的，因此其速度分布是一个狄拉克δ函数，$f_D(\\mathbf{v}_D) = \\delta(\\mathbf{v}_D - \\mathbf{v}_b)$，其中 $\\mathbf{v}_b$ 是恒定的束速度。电子服从麦克斯韦分布，其归一化分布为\n$$ f_e(\\mathbf{v}_e) = \\left(\\frac{m_e}{2\\pi k_B T_e}\\right)^{3/2} \\exp\\left(-\\frac{m_e v_e^2}{2 k_B T_e}\\right) $$\n将 $f_D$ 的δ函数代入，简化了 $\\langle \\sigma v \\rangle$ 的表达式：\n$$ \\langle \\sigma v \\rangle = \\int f_e(\\mathbf{v}_e) |\\mathbf{v}_e - \\mathbf{v}_b| \\sigma(|\\mathbf{v}_e - \\mathbf{v}_b|) d^3\\mathbf{v}_e $$\n问题陈述中假设相对速度主要由电子热运动主导。这意味着电子热速度远大于中性束速度 ($v_{th,e} \\gg v_b$)。我们来验证这一点：\n给定的电子热能为 $T_e = 2$ keV。特征热速度为 $v_{th,e} = \\sqrt{2 k_B T_e / m_e}$。\n$k_B T_e = 2000 \\text{ eV} \\times (1.602 \\times 10^{-19} \\text{ J/eV}) \\approx 3.204 \\times 10^{-16} \\text{ J}$。\n$v_{th,e} \\approx \\sqrt{2 (3.204 \\times 10^{-16} \\text{ J}) / (9.109 \\times 10^{-31} \\text{ kg})} \\approx 2.65 \\times 10^7 \\text{ m/s}$。\n束能量为 $E_b = 80$ keV。束速度为 $v_b = \\sqrt{2 E_b / m_D}$。\n$E_b = 80000 \\text{ eV} \\times (1.602 \\times 10^{-19} \\text{ J/eV}) \\approx 1.282 \\times 10^{-14} \\text{ J}$。\n$v_b = \\sqrt{2 (1.282 \\times 10^{-14} \\text{ J}) / (3.3436 \\times 10^{-27} \\text{ kg})} \\approx 2.77 \\times 10^6 \\text{ m/s}$。\n由于 $v_b \\approx 0.1 v_{th,e}$，假设 $v_b \\ll v_{th,e}$ 是合理的，我们可以近似相对速度 $|\\mathbf{v}_e - \\mathbf{v}_b| \\approx v_e$。积分变为：\n$$ \\langle \\sigma v \\rangle \\approx \\int f_e(\\mathbf{v}_e) v_e \\sigma(v_e) d^3\\mathbf{v}_e $$\n在速度空间中转换为球坐标（$d^3\\mathbf{v}_e = 4\\pi v_e^2 dv_e$）并对角度部分进行积分，得到：\n$$ \\langle \\sigma v \\rangle = \\int_0^\\infty 4\\pi v_e^2 f_e(v_e) v_e \\sigma(v_e) dv_e = 4\\pi \\left(\\frac{m_e}{2\\pi k_B T_e}\\right)^{3/2} \\int_0^\\infty v_e^3 \\sigma(v_e) \\exp\\left(-\\frac{m_e v_e^2}{2 k_B T_e}\\right) dv_e $$\n我们将积分变量从速度 $v_e$ 更改为动能 $E_e = \\frac{1}{2}m_e v_e^2$。这意味着 $v_e = \\sqrt{2E_e/m_e}$ 且 $dv_e = (1/\\sqrt{2m_e E_e}) dE_e$。项 $v_e^3 dv_e$ 变为 $(2E_e/m_e) (dE_e/m_e) = (2E_e/m_e^2) dE_e$。将这些代入积分，我们得到速率系数作为能量积分的标准公式：\n$$ \\langle \\sigma v \\rangle = \\sqrt{\\frac{8}{\\pi m_e}} (k_B T_e)^{-3/2} \\int_0^\\infty E_e \\sigma(E_e) \\exp\\left(-\\frac{E_e}{k_B T_e}\\right) dE_e $$\nLotz 截面 $\\sigma_i(E_e)$ 是以混合单位（m$^2$, eV）给出的。为了正确执行计算，所有量都必须使用国际单位制（SI）单位。\n以国际单位制（SI）表示的给定值：\n- 基本电荷 $e = 1.602176634 \\times 10^{-19}$ C 给出换算关系 $1 \\text{ eV} = 1.602176634 \\times 10^{-19}$ J。\n- 电离阈值 $I_{SI} = 13.6 \\text{ eV} \\times e = 2.17896 \\times 10^{-18}$ J。\n- 电子热能 $k_B T_e = 2000 \\text{ eV} \\times e = 3.20435 \\times 10^{-16}$ J。\n- Lotz 系数 $a_{L,SI} = 4.5 \\times 10^{-18} \\text{ m}^2 \\text{eV}^2 \\times e^2 = 1.15514 \\times 10^{-55} \\text{ m}^2 \\text{J}^2$。\n- 电子质量 $m_e = 9.1093837 \\times 10^{-31}$ kg。\n\n在国际单位制中，截面为 $\\sigma_i(E_e) = \\frac{a_{L,SI} \\ln(E_e/I_{SI})}{E_e I_{SI}}$（当 $E_e \\ge I_{SI}$ 时），否则为0。\n将此代入 $\\langle \\sigma v \\rangle$ 的积分中：\n$$ \\langle \\sigma v \\rangle = \\sqrt{\\frac{8}{\\pi m_e}} (k_B T_e)^{-3/2} \\int_{I_{SI}}^\\infty E_e \\left[ \\frac{a_{L,SI} \\ln(E_e/I_{SI})}{E_e I_{SI}} \\right] \\exp\\left(-\\frac{E_e}{k_B T_e}\\right) dE_e $$\n被积函数中的 $E_e$ 项消掉了。\n$$ \\langle \\sigma v \\rangle = \\frac{a_{L,SI}}{I_{SI}} \\sqrt{\\frac{8}{\\pi m_e}} (k_B T_e)^{-3/2} \\int_{I_{SI}}^\\infty \\ln\\left(\\frac{E_e}{I_{SI}}\\right) \\exp\\left(-\\frac{E_e}{k_B T_e}\\right) dE_e $$\n我们来解这个积分。令 $x = E_e/k_B T_e$ 和 $x_I = I_{SI}/k_B T_e$。则 $E_e = x k_B T_e$ 且 $dE_e = k_B T_e dx$。\n$$ \\int_{x_I}^\\infty \\ln\\left(\\frac{x k_B T_e}{I_{SI}}\\right) \\exp(-x) (k_B T_e) dx = (k_B T_e) \\int_{x_I}^\\infty \\ln\\left(\\frac{x}{x_I}\\right) e^{-x} dx $$\n积分 $\\int_{x_I}^\\infty (\\ln x - \\ln x_I) e^{-x} dx$ 可以与指数积分函数 $E_1(z) = \\int_z^\\infty (e^{-t}/t) dt$ 联系起来。使用分部积分法，可以证明 $\\int_z^\\infty \\ln(t) e^{-t} dt = \\ln(z)e^{-z} + E_1(z)$。该积分变为：\n$$ \\int_{x_I}^\\infty \\ln(x/x_I) e^{-x} dx = E_1(x_I) $$\n因此，原始的能量积分计算结果为 $(k_B T_e) E_1(x_I)$。\n将此结果代回 $\\langle \\sigma v \\rangle$ 的表达式中：\n$$ \\langle \\sigma v \\rangle = \\frac{a_{L,SI}}{I_{SI}} \\sqrt{\\frac{8}{\\pi m_e}} (k_B T_e)^{-3/2} (k_B T_e) E_1\\left(\\frac{I_{SI}}{k_B T_e}\\right) $$\n$$ \\langle \\sigma v \\rangle = \\frac{a_{L,SI}}{I_{SI}} \\sqrt{\\frac{8}{\\pi m_e k_B T_e}} E_1\\left(\\frac{I_{SI}}{k_B T_e}\\right) $$\n现在，我们计算数值。$E_1$ 的自变量是 $x_I = I_{SI}/(k_B T_e) = (13.6 \\text{ eV})/(2000 \\text{ eV}) = 0.0068$。\n对于小的 $z$，指数积分有级数展开 $E_1(z) \\approx -\\gamma - \\ln(z)$，其中 $\\gamma \\approx 0.57721566$ 是欧拉-马斯刻若尼常数。\n$E_1(0.0068) \\approx -0.577216 - \\ln(0.0068) = -0.577216 - (-4.99003) \\approx 4.4128$。\n我们来计算前置因子：\n$$ \\frac{a_{L,SI}}{I_{SI}} = \\frac{1.15514 \\times 10^{-55} \\text{ m}^2\\text{J}^2}{2.17896 \\times 10^{-18} \\text{ J}} = 5.3013 \\times 10^{-38} \\text{ m}^2\\text{J} $$\n$$ \\sqrt{\\frac{8}{\\pi m_e k_B T_e}} = \\sqrt{\\frac{8}{\\pi (9.10938 \\times 10^{-31})(3.20435 \\times 10^{-16})}} \\approx \\sqrt{8.7221 \\times 10^{45}} \\approx 9.3392 \\times 10^{22} (\\text{kg J})^{-1/2} $$\n将这些结合起来：\n$$ \\langle \\sigma v \\rangle \\approx (5.3013 \\times 10^{-38}) \\times (9.3392 \\times 10^{22}) \\times 4.4128 $$\n$$ \\langle \\sigma v \\rangle \\approx (4.9510 \\times 10^{-15}) \\times 4.4128 \\approx 2.1847 \\times 10^{-14} \\text{ m}^3\\text{s}^{-1} $$\n\n**第二部分：透射中性粒子分数的计算**\n中性束密度 $n_b$ 沿其路径长度 $z$ 的衰减由以下微分方程描述：\n$$ \\frac{d n_b(z)}{dt} = -n_b(z) n_e \\langle \\sigma v \\rangle $$\n使用关系式 $dz = v_b dt$，其中 $v_b$ 是恒定的束速度，我们得到：\n$$ \\frac{d n_b(z)}{dz} = -\\frac{n_b(z) n_e \\langle \\sigma v \\rangle}{v_b} $$\n对于均匀等离子体（$n_e$ 是常数），我们将此方程在路径长度 $L$ 上积分：\n$$ \\int_{n_b(0)}^{n_b(L)} \\frac{dn_b}{n_b} = -\\frac{n_e \\langle \\sigma v \\rangle}{v_b} \\int_0^L dz $$\n$$ \\ln\\left(\\frac{n_b(L)}{n_b(0)}\\right) = -\\frac{n_e \\langle \\sigma v \\rangle L}{v_b} $$\n透射分数为 $N(L)/N(0) = n_b(L)/n_b(0)$。\n$$ \\frac{N(L)}{N(0)} = \\exp\\left(-\\frac{n_e \\langle \\sigma v \\rangle L}{v_b}\\right) $$\n我们需要从其能量 $E_b = 80$ keV 计算束速度 $v_b$。\n$E_{b,SI} = 80 \\times 10^3 \\text{ eV} \\times (1.6021766 \\times 10^{-19} \\text{ J/eV}) = 1.28174 \\times 10^{-14}$ J。\n$m_D = 3.3436 \\times 10^{-27}$ kg。\n$$ v_b = \\sqrt{\\frac{2 E_{b,SI}}{m_D}} = \\sqrt{\\frac{2(1.28174 \\times 10^{-14} \\text{ J})}{3.3436 \\times 10^{-27} \\text{ kg}}} \\approx 2.7688 \\times 10^6 \\text{ m/s} $$\n现在我们计算衰减公式中的指数：\n$$ \\text{Exponent} = \\frac{n_e \\langle \\sigma v \\rangle L}{v_b} = \\frac{(1.0 \\times 10^{19} \\text{ m}^{-3})(2.1847 \\times 10^{-14} \\text{ m}^3\\text{s}^{-1})(3.0 \\text{ m})}{2.7688 \\times 10^6 \\text{ m/s}} $$\n$$ \\text{Exponent} \\approx \\frac{6.5541 \\times 10^5}{2.7688 \\times 10^6} \\approx 0.23671 $$\n透射分数为：\n$$ \\frac{N(L)}{N(0)} = \\exp(-0.23671) \\approx 0.78923 $$\n将最终答案四舍五入到三位有效数字，我们得到 $0.789$。",
            "answer": "$$\\boxed{0.789}$$"
        },
        {
            "introduction": "在中性束注入系统中，高能离子束必须先通过中性化器才能转变为中性粒子束。这个练习旨在通过建立并求解耦合速率方程，来解析地模拟光束穿过气体中性化器时不同粒子组分（离子、中性粒子和残余离子）的演化过程 。这项实践将加深你对决定中性化效率的原子过程间相互竞争的理解。",
            "id": "4014511",
            "problem": "在中性束注入 (NBI) 中使用的一束准直束流，穿过一个长度为 $L$、气体数密度为 $n_g$ 的均匀气体中性化器，并经历两个主要的碰撞过程：将入射离子转换成中性粒子的电荷交换过程，以及将中性粒子转换成残余离子的剥离（电离）过程。假设束流为单组分，且中性化器在空间上是均匀的。其基本原理是双体碰撞动力学理论：一个速度为 $v$ 的粒子，在数密度为 $n_g$、反应截面为 $\\sigma$ 的背景气体中运动时，单位时间内的反应概率为 $n_g \\sigma v$。对于沿中性化器轴向位置 $x$ 变化的束流，使用 $dt = dx / v$ 将时间速率方程转换为空间速率方程。设离子、中性粒子和残余离子的组分分数分别为 $f_i(x)$、$f_n(x)$ 和 $f_r(x)$，初始条件为 $f_i(0) = f_{i0}$，$f_n(0) = f_{n0}$，$f_r(0) = f_{r0}$，且 $f_{i0} + f_{n0} + f_{r0} = 1$。设电荷交换截面为 $\\sigma_{in}$，剥离截面为 $\\sigma_{nr}$。\n\n任务：\n1. 从组分分数的连续性及上述碰撞速率模型出发，推导在均匀中性化器中控制 $f_i(x)$、$f_n(x)$ 和 $f_r(x)$ 变化的耦合微分方程组（以 $x$ 为自变量）。\n2. 解析地求解这些耦合方程，以获得用 $n_g$、$L$、$\\sigma_{in}$、$\\sigma_{nr}$ 及初始分数 $f_{i0}$、$f_{n0}$、$f_{r0}$ 表示的 $f_i(L)$、$f_n(L)$ 和 $f_r(L)$。您必须通过求取适当的数学极限来处理 $n_g \\sigma_{in} = n_g \\sigma_{nr}$ 的特殊情况。\n3. 实现一个完整、可运行的程序，使用您推导的解析解来计算以下测试套件的出口分数。截面单位为 $\\mathrm{m}^2$，$n_g$ 单位为 $\\mathrm{m}^{-3}$，$L$ 单位为 $\\mathrm{m}$。所有报告的组分分数均为无量纲。将每个分数表示为四舍五入到八位小数的浮点数。\n\n测试套件（每个元组列出 $(n_g, L, \\sigma_{in}, \\sigma_{nr}, f_{i0}, f_{n0}, f_{r0})$）：\n- 情况 A（一般情况）：$(1.0 \\times 10^{20}, 1.0, 1.2 \\times 10^{-19}, 2.0 \\times 10^{-20}, 1.0, 0.0, 0.0)$\n- 情况 B（$n_g \\sigma_{in} = n_g \\sigma_{nr}$ 的相等边界情况）：$(5.0 \\times 10^{19}, 0.5, 1.0 \\times 10^{-19}, 1.0 \\times 10^{-19}, 1.0, 0.0, 0.0)$\n- 情况 C（混合初始分数，低密度）：$(1.0 \\times 10^{18}, 1.0, 1.2 \\times 10^{-19}, 2.0 \\times 10^{-20}, 0.7, 0.3, 0.0)$\n- 情况 D（长中性化器，高密度）：$(2.0 \\times 10^{20}, 3.0, 8.0 \\times 10^{-20}, 3.0 \\times 10^{-20}, 1.0, 0.0, 0.0)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含结果。结果是一个由逗号分隔的列表，列表中的每个元素是对应案例的三元组，并用方括号括起来，不含空格，每个分数四舍五入到八位小数。例如，两个案例的输出应如下所示：\"[[f_iA,f_nA,f_rA],[f_iB,f_nB,f_rB]]\"。",
            "solution": "#### 1. 推导微分方程\n根据题设，入射离子分数 $f_i$ 的变化仅由于通过电荷交换（截面 $\\sigma_{in}$）损失：\n$$ \\frac{df_i}{dt} = -f_i \\cdot (n_g \\sigma_{in} v) $$\n中性粒子分数 $f_n$ 因离子电荷交换而增加，因剥离（截面 $\\sigma_{nr}$）而损失：\n$$ \\frac{df_n}{dt} = f_i \\cdot (n_g \\sigma_{in} v) - f_n \\cdot (n_g \\sigma_{nr} v) $$\n残余离子分数 $f_r$ 因中性粒子剥离而增加：\n$$ \\frac{df_r}{dt} = f_n \\cdot (n_g \\sigma_{nr} v) $$\n使用关系式 $dx = v dt$ 将时间导数转换为空间导数，并定义衰减系数 $k_{in} = n_g \\sigma_{in}$ 和 $k_{nr} = n_g \\sigma_{nr}$，我们得到耦合常微分方程组：\n$$\n\\begin{align*}\n\\frac{df_i}{dx} &= -k_{in} f_i \\\\\n\\frac{df_n}{dx} &= k_{in} f_i - k_{nr} f_n \\\\\n\\frac{df_r}{dx} &= k_{nr} f_n\n\\end{align*}\n$$\n\n#### 2. 求解微分方程\n我们依次求解该方程组，初始条件为 $f_i(0)=f_{i0}$，$f_n(0)=f_{n0}$ 和 $f_r(0)=f_{r0}$。\n\n**求解 $f_i(x)$:**\n第一个方程是简单的一阶齐次常微分方程，其解为：\n$$ f_i(x) = f_{i0} e^{-k_{in} x} $$\n\n**求解 $f_n(x)$:**\n将 $f_i(x)$ 的解代入第二个方程，得到一个一阶线性非齐次常微分方程：\n$$ \\frac{df_n}{dx} + k_{nr} f_n = k_{in} f_{i0} e^{-k_{in} x} $$\n我们分两种情况求解。\n\n**情况 1：$k_{in} \\neq k_{nr}$**\n使用积分因子法求解，得到：\n$$ f_n(x) = f_{n0} e^{-k_{nr} x} + \\frac{k_{in} f_{i0}}{k_{nr} - k_{in}} (e^{-k_{in} x} - e^{-k_{nr} x}) $$\n\n**情况 2：$k_{in} = k_{nr} = k$**\n在此退化情况下，方程变为 $\\frac{df_n}{dx} + k f_n = k f_{i0} e^{-k x}$。解为：\n$$ f_n(x) = (f_{n0} + k f_{i0} x) e^{-k x} $$\n\n**求解 $f_r(x)$:**\n利用总分数守恒 $f_i(x) + f_n(x) + f_r(x) = 1$，我们可以直接得到：\n$$ f_r(x) = 1 - f_i(x) - f_n(x) $$\n\n#### 3. 最终解析解\n在 $x=L$ 处，设无量纲光学厚度为 $\\tau_{in} = k_{in}L$ 和 $\\tau_{nr} = k_{nr}L$。\n\n**一般情况 ($\\tau_{in} \\neq \\tau_{nr}$):**\n$$ f_i(L) = f_{i0} e^{-\\tau_{in}} $$\n$$ f_n(L) = f_{n0} e^{-\\tau_{nr}} + \\frac{\\tau_{in} f_{i0}}{\\tau_{nr} - \\tau_{in}} (e^{-\\tau_{in}} - e^{-\\tau_{nr}}) $$\n$$ f_r(L) = 1 - f_i(L) - f_n(L) $$\n\n**特殊情况 ($\\tau_{in} = \\tau_{nr} = \\tau$):**\n$$ f_i(L) = f_{i0} e^{-\\tau} $$\n$$ f_n(L) = (f_{n0} + \\tau f_{i0}) e^{-\\tau} $$\n$$ f_r(L) = 1 - f_i(L) - f_n(L) $$\n这些公式将用于程序实现。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the exit species fractions for a neutral beam passing through a uniform gas neutralizer.\n    The solution is based on the analytical solution of the coupled rate equations.\n    \"\"\"\n\n    test_cases = [\n        # Case A (general case)\n        (1.0e20, 1.0, 1.2e-19, 2.0e-20, 1.0, 0.0, 0.0),\n        # Case B (equality edge case)\n        (5.0e19, 0.5, 1.0e-19, 1.0e-19, 1.0, 0.0, 0.0),\n        # Case C (mixed initial fractions, low density)\n        (1.0e18, 1.0, 1.2e-19, 2.0e-20, 0.7, 0.3, 0.0),\n        # Case D (long neutralizer, high density)\n        (2.0e20, 3.0, 8.0e-20, 3.0e-20, 1.0, 0.0, 0.0),\n    ]\n\n    def calculate_fractions(ng, L, sig_in, sig_nr, f_i0, f_n0, f_r0):\n        \"\"\"\n        Computes the final fractions (f_i, f_n, f_r) based on derived analytical solutions.\n        \n        Args:\n            ng (float): Gas number density (m^-3).\n            L (float): Length of the neutralizer (m).\n            sig_in (float): Charge exchange cross section (m^2).\n            sig_nr (float): Stripping cross section (m^2).\n            f_i0 (float): Initial incident ion fraction.\n            f_n0 (float): Initial neutral fraction.\n            f_r0 (float): Initial residual ion fraction.\n            \n        Returns:\n            tuple: A tuple containing the final fractions (f_i, f_n, f_r).\n        \"\"\"\n        tau_in = ng * sig_in * L\n        tau_nr = ng * sig_nr * L\n\n        # To handle numerical stability, check if tau_in and tau_nr are very close.\n        # A small tolerance is better than direct equality for floating-point numbers.\n        if abs(tau_in - tau_nr)  1e-12:\n            # Special case: tau_in = tau_nr = tau\n            tau = tau_in\n            f_i = f_i0 * np.exp(-tau)\n            f_n = (f_n0 + tau * f_i0) * np.exp(-tau)\n        else:\n            # General case: tau_in != tau_nr\n            exp_in = np.exp(-tau_in)\n            exp_nr = np.exp(-tau_nr)\n            \n            f_i = f_i0 * exp_in\n            f_n = f_n0 * exp_nr + (tau_in * f_i0 / (tau_nr - tau_in)) * (exp_in - exp_nr)\n\n        # f_r is determined by conservation\n        f_r = 1.0 - f_i - f_n\n\n        return f_i, f_n, f_r\n\n    results = []\n    for case in test_cases:\n        f_i, f_n, f_r = calculate_fractions(*case)\n        # Format each triplet of fractions as \"[f_i,f_n,f_r]\" with 8 decimal places\n        result_str = f\"[{f_i:.8f},{f_n:.8f},{f_r:.8f}]\"\n        results.append(result_str)\n\n    # Combine all case strings into the final output format \"[[...],[...],...]\"\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "蒙特卡洛方法是模拟聚变等离子体中复杂随机输运过程的强大工具。这项实践将指导你构建一个简化的蒙特卡洛程序，来模拟中性束粒子在等离子体中的沉积位置，从而提供粒子和能量沉积的空间分布 。通过这个练习，你将获得关于抽样技术和统计收敛性的实践经验，这些都是现代中性束注入模拟程序的核心。",
            "id": "4014426",
            "problem": "您的任务是构建一个完整的、可运行的程序，该程序为中性束注入（NBI）的粒子种类执行科学上真实的蒙特卡洛（MC）采样，并验证沉积直方图的统计收敛性。该程序必须实现一个与测得的全能量、半能量和三分之一能量的粒子种类份额（分别表示为 $f_{1}$、$f_{1/2}$ 和 $f_{1/3}$）一致的采样器，并评估 $N = 10^6$ 次独立中性粒子历史的收敛性。计算模型是沿束线坐标 $x$ 进入长度为 $L$（单位为米）的有限等离子体体积的一维模型。沉积发生在从指数平均自由程模型中采样的首次相互作用点；这基于 Beer–Lambert 衰减定律和标准的首次碰撞模型。\n\n基本和建模假设：\n- 中性束注入（NBI）由具有依赖于粒子种类的平均自由程的中性粒子的一维输运来表示。指数路径长度模型源自 Beer–Lambert 定律，该定律指出 $dI/dx = -I/\\lambda$，从而得出首次相互作用位置的概率密度为 $p(x \\mid \\lambda) = (1/\\lambda)\\exp(-x/\\lambda)$，适用于 $x \\ge 0$，其中 $\\lambda$ 是平均自由程（单位为米）。\n- 测得的能量组分份额 $f_{1}$、$f_{1/2}$、$f_{1/3}$ 满足 $f_{1} + f_{1/2} + f_{1/3} = 1$，并作为粒子种类身份的分类采样概率。因此，沿 $x$ 的沉积概率密度是以下混合形式：\n$$\np(x) = f_{1}\\frac{1}{\\lambda_{1}}e^{-x/\\lambda_{1}} + f_{1/2}\\frac{1}{\\lambda_{1/2}}e^{-x/\\lambda_{1/2}} + f_{1/3}\\frac{1}{\\lambda_{1/3}}e^{-x/\\lambda_{1/3}},\n$$\n该密度被截断到区间 $[0, L]$，因为只记录等离子体体积 $[0, L]$ 内部的沉积。\n- 直方图在覆盖 $[0, L]$ 的 $B$ 个均匀区间（bin）上计算。区间 $i$ 中单位长度的沉积密度通过将该区间的计数除以 $N$ 和区间宽度来估计，因此估计量的单位是 $\\text{每米}$。\n\nMC算法和收敛性验证的要求：\n- 粒子种类采样：根据 $f_{1}$、$f_{1/2}$、$f_{1/3}$ 抽取每个历史的粒子种类身份。\n- 路径长度采样：对于选定的具有平均自由程 $\\lambda_{s}$ 的粒子种类，从指数分布 $p(x \\mid \\lambda_{s})$ 中抽取一个路径长度 $x$。\n- 沉积接受：如果 $x \\in [0, L]$，则接受一个沉积事件；否则，它在建模的等离子体段之外，不计入直方图。\n- 直方图估计：计算一个覆盖 $[0, L]$ 的具有 $B$ 个区间的直方图，通过除以 $N$ 和区间宽度将计数转换为单位长度的沉积密度。\n- 收敛性检查：执行两次独立的MC实现（使用不同的种子），每次规模为 $N = 10^6$，计算每个区间的沉积密度数组，并将每个区间的相对差异定义为\n$$\n\\Delta_i = \n\\begin{cases}\n\\frac{\\lvert h_i^{(1)} - h_i^{(2)} \\rvert}{\\frac{1}{2}(h_i^{(1)} + h_i^{(2)})}  \\text{if } \\frac{1}{2}(h_i^{(1)} + h_i^{(2)})  0, \\\\\n0  \\text{otherwise},\n\\end{cases}\n$$\n其中 $h_i^{(1)}$ 和 $h_i^{(2)}$ 是两次运行中区间 $i$ 的沉积密度。如果 $\\max_i \\Delta_i \\le 0.02$，则测试通过。\n\n物理和数值单位：\n- 所有长度，包括 $L$ 和 $\\lambda$ 值，都必须以米为单位。\n- 不使用角度。\n- 最终输出为布尔值；不打印任何物理单位。\n\n测试套件：\n实现程序以评估以下三个测试用例。对于每个用例，运行两次独立的MC实现，每次有 $N = 10^6$ 个历史，计算如上定义的每个区间的相对差异，并返回最大相对差异是否小于或等于 $0.02$。\n\n- 用例1（通用混合束）：\n  - 粒子种类份额：$f_{1} = 0.60$，$f_{1/2} = 0.25$，$f_{1/3} = 0.15$。\n  - 平均自由程：$\\lambda_{1} = 0.25\\,\\text{m}$，$\\lambda_{1/2} = 0.18\\,\\text{m}$，$\\lambda_{1/3} = 0.12\\,\\text{m}$。\n  - 等离子体段长度：$L = 1.0\\,\\text{m}$。\n  - 区间数量：$B = 100$。\n\n- 用例2（近单一种类边界）：\n  - 粒子种类份额：$f_{1} = 0.98$，$f_{1/2} = 0.02$，$f_{1/3} = 0.00$。\n  - 平均自由程：$\\lambda_{1} = 0.50\\,\\text{m}$，$\\lambda_{1/2} = 0.50\\,\\text{m}$，$\\lambda_{1/3} = 0.50\\,\\text{m}$。\n  - 等离子体段长度：$L = 0.50\\,\\text{m}$。\n  - 区间数量：$B = 50$。\n\n- 用例3（高透明度束，长平均自由程）：\n  - 粒子种类份额：$f_{1} = 0.33$，$f_{1/2} = 0.34$，$f_{1/3} = 0.33$。\n  - 平均自由程：$\\lambda_{1} = 10.0\\,\\text{m}$，$\\lambda_{1/2} = 5.0\\,\\text{m}$，$\\lambda_{1/3} = 3.0\\,\\text{m}$。\n  - 等离子体段长度：$L = 2.0\\,\\text{m}$。\n  - 区间数量：$B = 40$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[ \\text{result}_1, \\text{result}_2, \\text{result}_3 ]$，其中每个 $\\text{result}_i$ 是一个布尔值，指示相应的用例是否满足 $\\le 0.02$ 的每个区间的最大相对差异标准。输出必须严格匹配格式 $[result1,result2,result3]$，不得有额外文本。",
            "solution": "该问题要求实现并验证一个用于中性束注入（NBI）沉积的一维蒙特卡洛模拟。核心任务是基于物理模型对粒子沉积位置进行采样，然后评估所得沉积分布的统计收敛性。\n\n物理模型基于 Beer–Lambert 定律，该定律描述了光束穿过介质时的衰减。该定律导出了首次相互作用距离 $x$ 的概率密度函数 $p(x \\mid \\lambda) = (1/\\lambda)\\exp(-x/\\lambda)$，其中 $\\lambda$ 是平均自由程。NBI束由三种具有不同能量（全能量、半能量和三分之一能量）的粒子种类组成，其特征是具有不同的平均自由程 $\\lambda_{1}$、$\\lambda_{1/2}$ 和 $\\lambda_{1/3}$，以及粒子种类份额 $f_{1}$、$f_{1/2}$ 和 $f_{1/3}$。这些份额满足闭合关系 $f_{1} + f_{1/2} + f_{1/3} = 1$。因此，在位置 $x$ 发生沉积的总概率密度函数是一个混合模型：\n$$\np(x) = f_{1}p(x \\mid \\lambda_{1}) + f_{1/2}p(x \\mid \\lambda_{1/2}) + f_{1/3}p(x \\mid \\lambda_{1/3})\n$$\n模拟仅考虑在长度为 $L$ 的有限等离子体体积内的沉积，即对于 $x \\in [0, L]$。\n\n蒙特卡洛算法通过模拟 $N = 10^6$ 次独立的中性粒子历史来进行。对于每个历史，执行两个连续的采样步骤：\n$1.$ **粒子种类采样**：随机选择中性粒子种类（$s \\in \\{1, 1/2, 1/3\\}$）的身份。这是从一个具有由粒子种类份额 $\\{f_{1}, f_{1/2}, f_{1/3}\\}$ 给出的概率的分类分布中抽样。在计算上，这是通过将区间 $[0, 1)$ 划分为三个长度分别为 $f_{1}$、$f_{1/2}$ 和 $f_{1/3}$ 的段，并确定一个均匀随机数 $u \\in [0, 1)$ 落入哪个段来实现的。\n\n$2.$ **路径长度采样**：一旦选定了具有平均自由程 $\\lambda_s$ 的粒子种类 $s$，就从其相应的指数分布 $p(x \\mid \\lambda_s)$ 中采样路径长度 $x$。使用逆变换采样法最为高效。累积分布函数 (CDF) 为 $F(x) = 1 - \\exp(-x/\\lambda_s)$。将CDF等于一个均匀随机数 $u \\in [0, 1)$ 并求解 $x$，得到采样公式：\n$$\nx = F^{-1}(u) = -\\lambda_s \\ln(1 - u)\n$$\n因为如果 $u$ 在 $[0, 1)$ 上是均匀的，那么 $1-u$ 也在 $[0, 1)$ 上是均匀的，所以我们可以将公式简化为 $x = -\\lambda_s \\ln(u)$。\n\n采样路径长度 $x$ 后，只有当沉积发生在等离子体域内，即 $0 \\le x \\le L$ 时，才会被记录。$x  L$ 的粒子被认为已穿过等离子体段而未发生相互作用，不被计数。\n\n收集到的沉积位置被分箱到一个在区间 $[0, L]$ 上具有 $B$ 个均匀间隔区间的直方图中。因此，区间宽度为 $\\Delta x = L/B$。为了获得沉积密度（单位为 $\\text{m}^{-1}$）的估计值，每个区间 $i$ 中的计数 $C_i$ 通过初始历史总数 $N$ 和区间宽度 $\\Delta x$ 进行归一化。区间 $i$ 中沉积密度的估计量为：\n$$\nh_i = \\frac{C_i}{N \\cdot \\Delta x}\n$$\n为验证统计收敛性，使用不同的随机数生成器种子将整个过程执行两次，产生两个独立的沉积密度直方图 $h^{(1)}$ 和 $h^{(2)}$。每个区间的相对差异 $\\Delta_i$ 计算如下：\n$$\n\\Delta_i = \n\\begin{cases}\n\\frac{\\lvert h_i^{(1)} - h_i^{(2)} \\rvert}{\\frac{1}{2}(h_i^{(1)} + h_i^{(2)})}  \\text{if } \\frac{1}{2}(h_i^{(1)} + h_i^{(2)})  0, \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n如果这些相对差异在所有区间的最大值不超过 $0.02$ 的容差，即如果 $\\max_i \\Delta_i \\le 0.02$，则收敛性测试通过。为每个测试用例返回一个布尔结果。\n\n该实现利用 `numpy` 库进行高效的矢量化操作。在单个数组操作中为粒子种类和路径长度采样生成所有 $N$ 个随机数，比遍历单个历史的性能要高得多。对于给定的测试用例，运行两次独立的模拟。对生成的直方图进行归一化，计算它们的相对差异，并将最大差异与阈值进行比较，以确定最终的布尔结果。对所有三个提供的测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_mc_simulation(N, fractions, lambdas, L, B, seed):\n    \"\"\"\n    Performs a vectorized Monte Carlo simulation for NBI deposition.\n\n    Args:\n        N (int): Total number of particle histories to simulate.\n        fractions (list[float]): Species fractions [f_1, f_1/2, f_1/3].\n        lambdas (list[float]): Mean free paths [lambda_1, lambda_1/2, lambda_1/3] in meters.\n        L (float): Length of the plasma segment in meters.\n        B (int): Number of bins for the histogram.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        numpy.ndarray: The normalized deposition density histogram.\n    \"\"\"\n    # Initialize a random number generator with a specific seed for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # 1. Species Sampling: Draw N species indices (0, 1, or 2) based on fractions.\n    species_indices = rng.choice(3, size=N, p=fractions)\n\n    # 2. Path-Length Sampling (vectorized):\n    # Map the sampled species indices to their corresponding mean free paths.\n    lambdas_per_particle = np.array(lambdas)[species_indices]\n\n    # Generate N uniform random numbers for inverse transform sampling.\n    # rng.random() generates floats in the interval [0.0, 1.0).\n    u = rng.random(size=N)\n\n    # Calculate path lengths x = -lambda * ln(u).\n    # np.log(0) would be -inf, but rng.random() does not produce 0.\n    path_lengths = -lambdas_per_particle * np.log(u)\n\n    # 3. Deposition Acceptance: Filter for particles that deposit within [0, L].\n    # The condition x >= 0 is implicitly met since lambda > 0 and ln(u) = 0.\n    deposited_positions = path_lengths[path_lengths = L]\n\n    # 4. Histogram Estimation: Bin the successful deposition positions.\n    # np.histogram returns counts per bin and the bin edges.\n    counts, _ = np.histogram(deposited_positions, bins=B, range=(0, L))\n\n    # 5. Normalization: Convert counts to deposition density per unit length.\n    bin_width = L / B\n    # Normalize by the total number of initial histories (N), not the number deposited.\n    if N == 0 or bin_width == 0:\n        return np.zeros(B)\n    deposition_density = counts / (N * bin_width)\n\n    return deposition_density\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general mixed beam)\n        {\n            \"fractions\": [0.60, 0.25, 0.15],\n            \"lambdas\": [0.25, 0.18, 0.12],\n            \"L\": 1.0,\n            \"B\": 100,\n        },\n        # Case 2 (near-single-species boundary)\n        {\n            \"fractions\": [0.98, 0.02, 0.00],\n            \"lambdas\": [0.50, 0.50, 0.50],\n            \"L\": 0.50,\n            \"B\": 50,\n        },\n        # Case 3 (highly transparent beam, long mean free paths)\n        {\n            \"fractions\": [0.33, 0.34, 0.33],\n            \"lambdas\": [10.0, 5.0, 3.0],\n            \"L\": 2.0,\n            \"B\": 40,\n        },\n    ]\n    \n    N_histories = 10**6\n    convergence_threshold = 0.02\n    results = []\n\n    for case in test_cases:\n        # Run two independent MC realizations with distinct seeds.\n        h1 = run_mc_simulation(\n            N=N_histories,\n            fractions=case[\"fractions\"],\n            lambdas=case[\"lambdas\"],\n            L=case[\"L\"],\n            B=case[\"B\"],\n            seed=42  # First fixed seed for reproducibility.\n        )\n        h2 = run_mc_simulation(\n            N=N_histories,\n            fractions=case[\"fractions\"],\n            lambdas=case[\"lambdas\"],\n            L=case[\"L\"],\n            B=case[\"B\"],\n            seed=99  # Second fixed seed for reproducibility.\n        )\n\n        # Calculate the per-bin relative difference.\n        avg_h = 0.5 * (h1 + h2)\n        \n        # Use np.errstate to prevent division-by-zero warnings.\n        with np.errstate(divide='ignore', invalid='ignore'):\n            relative_difference = np.abs(h1 - h2) / avg_h\n            # As per the problem spec, where the denominator is zero, the diff is zero.\n            # This handles bins where both runs had zero counts.\n            relative_difference[avg_h == 0] = 0.0\n\n        # Find the maximum relative difference across all bins.\n        max_relative_difference = np.max(relative_difference)\n\n        # Check if the convergence criterion is met.\n        is_converged = max_relative_difference = convergence_threshold\n        results.append(str(is_converged).lower())\n\n    # Print results in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}