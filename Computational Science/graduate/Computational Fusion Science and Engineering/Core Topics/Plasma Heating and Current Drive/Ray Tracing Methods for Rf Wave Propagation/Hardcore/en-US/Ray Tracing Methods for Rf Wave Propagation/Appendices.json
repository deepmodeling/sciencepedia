{
    "hands_on_practices": [
        {
            "introduction": "Before a ray can be traced, the plasma medium it travels through must be defined. Ray tracing codes rely on a continuous representation of the plasma, but equilibrium and profile data are typically available only on a discrete grid. This exercise  explores the crucial choice of interpolation scheme, which must respect both the mathematical structure of the ray equations (requiring smooth gradients) and the physical properties of the plasma profiles (like monotonicity). Mastering this is a vital practical skill for ensuring the accuracy and stability of any ray tracing simulation.",
            "id": "4038226",
            "problem": "In a tokamak equilibrium specified in straight-field-line flux coordinates with poloidal flux label $\\psi \\in [0,\\psi_{\\text{edge}}]$ and poloidal angle $\\theta \\in [-\\pi,\\pi]$ (periodic in $\\theta$), you are given tabulated plasma profiles on a tensor-product grid $\\{\\psi_i\\}_{i=0}^{N_\\psi}$ and $\\{\\theta_j\\}_{j=0}^{N_\\theta-1}$:\n- Electron density $n_e(\\psi)$ defined on $\\{\\psi_i\\}$ and known to be monotone decreasing with $\\psi$.\n- Electron temperature $T_e(\\psi)$ defined on $\\{\\psi_i\\}$ and known to be monotone decreasing with $\\psi$.\n- Magnetic field vector $\\mathbf{B}(\\psi,\\theta)$ defined on $\\{(\\psi_i,\\theta_j)\\}$ and periodic in $\\theta$ with period $2\\pi$.\n\nYou intend to perform high-accuracy Radio Frequency (RF) wave ray tracing in the eikonal or geometric optics limit. The ray path $\\mathbf{x}(s)$ and wavevector $\\mathbf{k}(s)$ follow a Hamiltonian system derived from the dispersion function $D(\\mathbf{x},\\mathbf{k},\\omega)=0$, with $\\omega$ fixed, where $D$ depends smoothly on $n_e$, $T_e$ (through collisionality and dielectric response), and $\\mathbf{B}$ (through cyclotron terms). The governing equations for rays may be written schematically as\n$$\n\\frac{d\\mathbf{x}}{ds} \\propto \\frac{\\partial D}{\\partial \\mathbf{k}}, \\qquad \\frac{d\\mathbf{k}}{ds} \\propto -\\frac{\\partial D}{\\partial \\mathbf{x}},\n$$\nwith proportionality constants involving $\\partial D/\\partial \\omega$. To ensure well-posedness and stability of the numerical integration of these ordinary differential equations (ODEs), $\\nabla_{\\mathbf{x}} D$ and $\\nabla_{\\mathbf{k}} D$ must be continuous and at least locally Lipschitz in $\\mathbf{x}$ and $\\mathbf{k}$. In addition, avoiding spurious turning points or artificial cutoffs requires that the interpolants for flux functions $n_e(\\psi)$ and $T_e(\\psi)$ preserve monotonicity in $\\psi$, while the interpolant for $\\mathbf{B}(\\psi,\\theta)$ must respect $2\\pi$-periodicity in $\\theta$ and provide smooth $\\theta$-derivatives.\n\nYou will construct continuous interpolants over the domain for evaluating $D$ and its gradients at off-grid ray locations. Which of the following strategies is the most appropriate choice to simultaneously satisfy:\n(i) monotonicity preservation for $n_e(\\psi)$ and $T_e(\\psi)$,\n(ii) periodicity and smoothness in $\\theta$ for $\\mathbf{B}(\\psi,\\theta)$,\n(iii) at least $C^1$ continuity in space so that $\\nabla_{\\mathbf{x}} D$ exists and is continuous,\n(iv) avoidance of spurious oscillations or overshoot that could create non-physical extrema, and\n(v) computational efficiency suitable for repeated evaluation during ray tracing?\n\nA. Use unconstrained natural cubic splines in $\\psi$ for $n_e(\\psi)$ and $T_e(\\psi)$, and standard bicubic splines in $(\\psi,\\theta)$ for each component of $\\mathbf{B}(\\psi,\\theta)$ without enforcing periodicity in $\\theta$.\n\nB. Use piecewise linear interpolation in $\\psi$ for $n_e(\\psi)$ and $T_e(\\psi)$, and bilinear interpolation in $(\\psi,\\theta)$ for $\\mathbf{B}(\\psi,\\theta)$; compute gradients of $D$ by differentiating the piecewise linear/bilinear interpolants where defined.\n\nC. For $n_e(\\psi)$ and $T_e(\\psi)$, use a shape-preserving Piecewise Cubic Hermite Interpolating Polynomial (PCHIP) in $\\psi$ to enforce monotonicity with $C^1$ continuity. For $\\mathbf{B}(\\psi,\\theta)$, use a tensor-product interpolant that is PCHIP in $\\psi$ and a periodic cubic spline in $\\theta$ with $2\\pi$-periodic boundary conditions; compute spatial derivatives analytically from the interpolants.\n\nD. For $n_e(\\psi)$ and $T_e(\\psi)$, use an order-$5$ Weighted Essentially Non-Oscillatory (WENO) reconstruction in $\\psi$; for $\\mathbf{B}(\\psi,\\theta)$, use a truncated Fourier series of order $N$ in $\\theta$ combined with polynomial interpolation in $\\psi$; compute $\\nabla_{\\mathbf{x}} D$ using finite differences applied to the reconstructed fields.\n\nE. Fit global Chebyshev polynomials in $\\psi$ to $n_e(\\psi)$ and $T_e(\\psi)$ using least squares, and use non-periodic bicubic interpolation in $(\\psi,\\theta)$ for $\\mathbf{B}(\\psi,\\theta)$; compute derivatives from the fitted polynomials and bicubic surfaces.\n\nChoose the best option and justify your choice by reasoning from the eikonal Hamiltonian formulation, the required continuity of $D$ and its gradients, the known monotonic and periodic structure of the profiles, and the numerical properties of the listed interpolation schemes.",
            "solution": "The problem asks for the most appropriate interpolation strategy for plasma profiles ($n_e$, $T_e$) and the magnetic field ($\\mathbf{B}$) to be used in a high-accuracy RF wave ray tracing code. The ray tracing equations form a Hamiltonian system, which imposes strict requirements on the continuity and differentiability of the underlying fields used to construct the dispersion function $D(\\mathbf{x}, \\mathbf{k}, \\omega)$.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n*   **Coordinates:** Straight-field-line flux coordinates $(\\psi, \\theta)$, where $\\psi \\in [0, \\psi_{\\text{edge}}]$ is the poloidal flux label and $\\theta \\in [-\\pi, \\pi]$ is the poloidal angle.\n*   **Data:**\n    *   Electron density $n_e(\\psi)$ given on a grid $\\{\\psi_i\\}$, known to be monotone decreasing.\n    *   Electron temperature $T_e(\\psi)$ given on a grid $\\{\\psi_i\\}$, known to be monotone decreasing.\n    *   Magnetic field vector $\\mathbf{B}(\\psi, \\theta)$ given on a tensor-product grid $\\{(\\psi_i, \\theta_j)\\}$, known to be periodic in $\\theta$ with period $2\\pi$.\n*   **Physics Model:** Ray tracing in the eikonal (geometric optics) limit.\n*   **Governing Equations:** Hamiltonian ODEs for ray position $\\mathbf{x}(s)$ and wavevector $\\mathbf{k}(s)$:\n    $$ \\frac{d\\mathbf{x}}{ds} \\propto \\frac{\\partial D}{\\partial \\mathbf{k}}, \\qquad \\frac{d\\mathbf{k}}{ds} \\propto -\\frac{\\partial D}{\\partial \\mathbf{x}} $$\n    where $D(\\mathbf{x}, \\mathbf{k}, \\omega) = 0$ is the dispersion relation.\n*   **Requirements on Interpolants:** The problem states five explicit criteria the chosen interpolation strategy must satisfy:\n    1.  (i) Monotonicity preservation for $n_e(\\psi)$ and $T_e(\\psi)$.\n    2.  (ii) Periodicity and smoothness in $\\theta$ for $\\mathbf{B}(\\psi, \\theta)$.\n    3.  (iii) At least $C^1$ continuity in space to ensure $\\nabla_{\\mathbf{x}} D$ is continuous.\n    4.  (iv) Avoidance of spurious oscillations or overshoot.\n    5.  (v) Computational efficiency.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem statement is scientifically sound, well-posed, and objective.\n*   **Scientific Grounding:** The use of Hamiltonian mechanics to describe ray propagation (an application of the eikonal approximation) in a plasma medium described by a dispersion relation is a standard and fundamental technique in plasma physics. The specification of plasma profiles in flux coordinates is standard practice in fusion research.\n*   **Well-Posedness:** The problem sets forth a clear set of well-defined mathematical and numerical constraints (monotonicity, periodicity, $C^1$ continuity, efficiency) and asks for the evaluation of different numerical schemes against these constraints. This is a standard problem in scientific computing.\n*   **Objectivity & Completeness:** The problem is stated in precise, technical language. All necessary information regarding the physical context and numerical requirements is provided. The constraints are not contradictory, although they are challenging to satisfy simultaneously with simple methods. The question seeks the \"most appropriate\" option, which is a reasonable objective in comparing numerical methods.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is valid. I will proceed with the analysis of the options.\n\n### Solution Derivation and Option Analysis\n\nThe core of the problem lies in the properties of the right-hand side of the ray equations. For the numerical integration of the ODE system to be stable and accurate, the vector field defining the dynamics, which involves $\\nabla_{\\mathbf{x}} D$ and $\\nabla_{\\mathbf{k}} D$, must be at least continuous. The dispersion function $D$ depends on $n_e$, $T_e$, and $\\mathbf{B}$. By the chain rule, $\\nabla_{\\mathbf{x}} D$ involves the spatial gradients of these plasma quantities. Therefore, the interpolants for $n_e$, $T_e$, and $\\mathbf{B}$ must be at least $C^1$ (continuously differentiable) in the spatial coordinates. This is the origin of requirement (iii). The other requirements stem from the known physical properties of the profiles and the need to avoid numerical artifacts.\n\n**A. Use unconstrained natural cubic splines in $\\psi$ for $n_e(\\psi)$ and $T_e(\\psi)$, and standard bicubic splines in $(\\psi,\\theta)$ for each component of $\\mathbf{B}(\\psi,\\theta)$ without enforcing periodicity in $\\theta$.**\n\n*   **Analysis:** Natural cubic splines provide $C^2$ continuity, satisfying requirement (iii). However, they are not guaranteed to preserve the monotonicity of the original discrete data. They can introduce spurious oscillations and overshoots, especially in regions of changing curvature, which violates requirements (i) and (iv) and can lead to non-physical results like negative density or artificial turning points for the wave. Standard bicubic splines with default boundary conditions (e.g., `not-a-knot`) are not periodic. This means the interpolated value of $\\mathbf{B}$ and, more critically, its derivatives will have a jump discontinuity at the $\\theta=-\\pi$ and $\\theta=\\pi$ boundary, violating requirement (ii).\n*   **Verdict:** **Incorrect**. This option fails on the critical requirements of monotonicity and periodicity.\n\n**B. Use piecewise linear interpolation in $\\psi$ for $n_e(\\psi)$ and $T_e(\\psi)$, and bilinear interpolation in $(\\psi,\\theta)$ for $\\mathbf{B}(\\psi,\\theta)$; compute gradients of $D$ by differentiating the piecewise linear/bilinear interpolants where defined.**\n\n*   **Analysis:** Piecewise linear interpolation preserves monotonicity (i) and avoids overshoots (iv). However, it is only a $C^0$ continuous function. Its first derivative is piecewise constant and has jump discontinuities at the grid points. Similarly, bilinear interpolation for $\\mathbf{B}$ is $C^0$, but its gradients are discontinuous at the boundaries of each grid cell. This means that the crucial term $\\nabla_{\\mathbf{x}} D$ will be discontinuous throughout the domain. Integrating an ODE with a discontinuous right-hand side is problematic; it requires special handling, and standard high-order solvers will fail to converge properly, leading to large errors and instability. This violates the central requirement (iii) of $C^1$ continuity.\n*   **Verdict:** **Incorrect**. This option fails to provide the necessary smoothness for the Hamiltonian system of ODEs.\n\n**C. For $n_e(\\psi)$ and $T_e(\\psi)$, use a shape-preserving Piecewise Cubic Hermite Interpolating Polynomial (PCHIP) in $\\psi$ to enforce monotonicity with $C^1$ continuity. For $\\mathbf{B}(\\psi,\\theta)$, use a tensor-product interpolant that is PCHIP in $\\psi$ and a periodic cubic spline in $\\theta$ with $2\\pi$-periodic boundary conditions; compute spatial derivatives analytically from the interpolants.**\n\n*   **Analysis:** This option provides a comprehensive and correct solution.\n    *   **For $n_e(\\psi)$ and $T_e(\\psi)$:** PCHIP is a piecewise cubic interpolant specifically designed to be shape-preserving. If the input data is monotonic, the resulting interpolant is guaranteed to be monotonic. It is also, by construction, $C^1$ continuous. This simultaneously satisfies requirements (i), (iii), and (iv).\n    *   **For $\\mathbf{B}(\\psi,\\theta)$:** A tensor-product construction is appropriate for the grid. Using PCHIP in the $\\psi$ direction provides $C^1$ smoothness and good shape-preserving behavior. Using periodic cubic splines in the $\\theta$ direction provides $C^2$ smoothness and correctly enforces the $2\\pi$-periodicity of the function and its first two derivatives at the boundary. This satisfies requirement (ii). The resulting tensor-product surface is $C^1$ in both variables, thus satisfying the global requirement (iii).\n    *   **Efficiency and Gradients:** Both PCHIP and cubic splines are local schemes, meaning evaluation at a point $(\\psi, \\theta)$ only depends on data in the immediate neighborhood. This makes them computationally efficient for repeated evaluations inside an ODE solver, satisfying (v). The piecewise polynomial nature of these splines means their derivatives can be computed analytically and exactly, which is the most accurate and robust way to evaluate $\\nabla_{\\mathbf{x}} D$.\n*   **Verdict:** **Correct**. This strategy systematically addresses and satisfies all five requirements using well-established, appropriate numerical methods.\n\n**D. For $n_e(\\psi)$ and $T_e(\\psi)$, use an order-$5$ Weighted Essentially Non-Oscillatory (WENO) reconstruction in $\\psi$; for $\\mathbf{B}(\\psi,\\theta)$, use a truncated Fourier series of order $N$ in $\\theta$ combined with polynomial interpolation in $\\psi$; compute $\\nabla_{\\mathbf{x}} D$ using finite differences applied to the reconstructed fields.**\n\n*   **Analysis:** WENO schemes are high-order, non-oscillatory methods, often used in solving hyperbolic PDEs with shocks. While they can preserve monotonicity, they are significantly more complex and computationally expensive for simple function interpolation than PCHIP. A truncated Fourier series is an excellent choice for representing a smooth periodic function in $\\theta$. However, the suggestion to use finite differences to compute gradients is a significant drawback. Given that an analytical interpolant is constructed, one should use its analytical derivative. Using finite differences introduces an additional source of truncation error and can be less stable than using analytical derivatives, especially near boundaries or regions of high curvature. This approach is suboptimal for a \"high-accuracy\" ray tracing code compared to analytic differentiation of the interpolant.\n*   **Verdict:** **Incorrect**. While containing valid elements (Fourier series), this option proposes an overly complex scheme for the 1D profiles (WENO) and a suboptimal method for computing gradients (finite differences), making it less \"appropriate\" than option C.\n\n**E. Fit global Chebyshev polynomials in $\\psi$ to $n_e(\\psi)$ and $T_e(\\psi)$ using least squares, and use non-periodic bicubic interpolation in $(\\psi,\\theta)$ for $\\mathbf{B}(\\psi,\\theta)$; compute derivatives from the fitted polynomials and bicubic surfaces.**\n\n*   **Analysis:** Global polynomial fits, including Chebyshev polynomials, are not guaranteed to be monotonic, even if the data is. A least-squares fit will provide a smooth approximation, but it can exhibit oscillations (a distributed version of Gibbs phenomenon) that violate the monotonicity of the physical profiles, thus failing requirement (i). The use of \"non-periodic bicubic interpolation\" for $\\mathbf{B}(\\psi, \\theta)$ is the same fundamental flaw as in option A: it fails to respect the domain's periodicity, violating requirement (ii).\n*   **Verdict:** **Incorrect**. This option fails on the same two fundamental requirements as option A: monotonicity and periodicity.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "The core of a ray tracing simulation is the numerical integration of a system of ordinary differential equations derived from a Hamiltonian. However, not all ODE solvers are suitable for this task, as Hamiltonian systems possess unique geometric properties, such as conservation of energy and phase-space volume, which generic solvers often fail to preserve over long integration times. This practice  challenges you to select an integrator that provides not only local accuracy but also preserves the long-term physical fidelity of the ray trajectory, a hallmark of robust geometric integration techniques.",
            "id": "4038257",
            "problem": "A high-frequency Radio Frequency (RF) wave is launched into a static, axisymmetric tokamak equilibrium with electron density $n_{e}(\\mathbf{x})$ and magnetic field $\\mathbf{B}(\\mathbf{x})$ that are independent of laboratory time. In the geometric optics limit, the wave phase is represented by an eikonal $S(\\mathbf{x})$ with local wavevector $\\mathbf{k}(\\mathbf{x}) = \\nabla S(\\mathbf{x})$, and the cold plasma dispersion relation defines a dispersion function $D(\\mathbf{x},\\mathbf{k},\\omega)=0$ at fixed angular frequency $\\omega$. Rays are integrated over a ray parameter $\\tau$ via a Hamiltonian system\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\frac{\\partial H}{\\partial \\mathbf{k}}, \\qquad \\frac{d\\mathbf{k}}{d\\tau} = -\\frac{\\partial H}{\\partial \\mathbf{x}},\n$$\nwhere $H(\\mathbf{x},\\mathbf{k})$ is a Hamiltonian chosen so that the ray trajectories lie on the dispersion surface $D(\\mathbf{x},\\mathbf{k},\\omega)=0$; for example, one may use $H(\\mathbf{x},\\mathbf{k}) = \\tfrac{1}{2} D(\\mathbf{x},\\mathbf{k},\\omega)$, which is independent of $\\tau$ when the medium is stationary.\n\nFrom first principles of Hamiltonian dynamics, if $H$ has no explicit $\\tau$ dependence, then $dH/d\\tau = 0$ for the exact flow and the symplectic two-form in phase space, $d\\mathbf{k} \\wedge d\\mathbf{x}$, is exactly preserved along the flow (Liouville volume conservation). However, numerical integration introduces truncation error and possibly breaks these invariants unless the method respects the symplectic structure. In practice, RF ray trajectories in a tokamak may traverse large distances, pass near refraction layers and cutoffs where $\\lVert \\nabla n_{e}(\\mathbf{x}) \\rVert$ and $\\lVert \\nabla \\mathbf{B}(\\mathbf{x}) \\rVert$ are large, and can be stiff due to rapid variation of $\\partial H/\\partial \\mathbf{x}$ and $\\partial H/\\partial \\mathbf{k}$.\n\nSelect the most appropriate numerical integrator for this Hamiltonian ray system with the dual goals of (i) controlling local error in regions of strong gradients and (ii) preserving the long-time conservation properties associated with Hamiltonian flow (bounded energy error and phase-space volume preservation). Justify the choice based on conservation properties and error control trade-offs.\n\nWhich option best satisfies these goals?\n\nA. Use an embedded adaptive explicit Runge–Kutta method (such as Dormand–Prince $5(4)$) with state-dependent step size control to enforce a tight local error tolerance everywhere.\n\nB. Use a fixed-step, fourth-order symplectic composition integrator (for example, a Yoshida composition of the leapfrog scheme) applied after a Sundman reparameterization of the ray parameter, introducing a new parameter $s$ defined by $ds/d\\tau = g(\\mathbf{x},\\mathbf{k})$ that clusters steps near refraction layers, while integrating with a constant step $\\Delta s$.\n\nC. Use an implicit Gauss–Legendre Runge–Kutta method of order $2s$ with adaptive, state-dependent step size control, relying on its symplecticity to conserve the Hamiltonian $H$ exactly and preserve phase-space volume, even with varying steps.\n\nD. Use a variable-order linear multistep predictor–corrector scheme (Adams–Bashforth–Moulton) with aggressive adaptivity to minimize computational cost while maintaining acceptable accuracy.\n\nChoose the best option and provide a concise justification tied to the conservation of $H$ and phase-space volume and to the need for reliable error control in stiff regions. Assume computational resources permit implicit solves when needed but prioritize physical fidelity of long integrations across many characteristic times of the ray dynamics.",
            "solution": "The user wants me to select the most appropriate numerical integrator for Hamiltonian ray tracing in a tokamak plasma, with the dual goals of accurate local error control in regions of strong gradients and preservation of long-term conservation properties.\n\n### Step 1: Extract Givens\n- **System:** High-frequency Radio Frequency (RF) wave in a static, axisymmetric tokamak.\n- **Medium Description:** Electron density $n_{e}(\\mathbf{x})$ and magnetic field $\\mathbf{B}(\\mathbf{x})$ are independent of laboratory time.\n- **Ray Dynamics:** Geometric optics limit with eikonal $S(\\mathbf{x})$ and wavevector $\\mathbf{k}(\\mathbf{x}) = \\nabla S(\\mathbf{x})$.\n- **Dispersion Relation:** $D(\\mathbf{x},\\mathbf{k},\\omega)=0$ at a fixed angular frequency $\\omega$.\n- **Governing Equations:** A Hamiltonian system integrated over a ray parameter $\\tau$:\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\frac{\\partial H}{\\partial \\mathbf{k}}, \\qquad \\frac{d\\mathbf{k}}{d\\tau} = -\\frac{\\partial H}{\\partial \\mathbf{x}}\n$$\n- **Hamiltonian:** $H(\\mathbf{x},\\mathbf{k})$ is chosen such that the ray path lies on the dispersion surface. One example is $H(\\mathbf{x},\\mathbf{k}) = \\tfrac{1}{2} D(\\mathbf{x},\\mathbf{k},\\omega)$. The Hamiltonian $H$ has no explicit dependence on $\\tau$.\n- **Exact Invariants:** Since $H$ is time-independent, $dH/d\\tau = 0$. The symplectic two-form $d\\mathbf{k} \\wedge d\\mathbf{x}$ is preserved, implying conservation of phase-space volume.\n- **Numerical Challenges:**\n    1.  Long integration paths.\n    2.  Regions of strong gradients near refraction layers and cutoffs, where $\\lVert \\nabla n_{e}(\\mathbf{x}) \\rVert$ and $\\lVert \\nabla \\mathbf{B}(\\mathbf{x}) \\rVert$ are large.\n    3.  Potential for stiffness due to rapid variation of the right-hand side functions ($\\partial H/\\partial \\mathbf{x}$ and $\\partial H/\\partial \\mathbf{k}$).\n- **Required Integrator Properties:**\n    1.  Control of local error in regions with strong gradients (adaptivity).\n    2.  Preservation of long-time conservation properties: bounded error in the Hamiltonian $H$ and preservation of phase-space volume.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is scientifically sound, well-posed, and objective.\n- **Scientific Grounding:** The description of RF ray tracing in a plasma using Hamiltonian mechanics is a standard and fundamental technique in computational fusion science. The governing equations, the concept of a dispersion relation, and the properties of Hamiltonian systems are all correctly stated and conform to established physical and mathematical principles.\n- **Well-Posedness:** The problem asks to identify the most suitable numerical integrator for a system with specific, well-defined characteristics (Hamiltonian structure) and challenges (stiffness, long-time integration). Comparing different families of numerical methods against these requirements is a standard task in computational science, and a meaningful conclusion can be reached.\n- **Objectivity and Completeness:** The problem is described using precise, technical language. The challenges and goals are objective criteria against which the options can be evaluated. Sufficient information is provided to make a reasoned choice based on the known theoretical properties of the numerical methods listed in the options.\n- **Consistency and Realism:** The problem is internally consistent. The mentioned numerical challenges are exactly those encountered in real-world simulations of this type. The trade-offs between local accuracy, computational cost, and long-term fidelity are central to the field.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the detailed derivation and evaluation of the options.\n\n### Principle-Based Derivation\nThe core of the problem lies in the properties of Hamiltonian systems and how numerical integrators interact with them. The system is described by Hamilton's equations for a phase-space coordinate $\\mathbf{z} = (\\mathbf{x}, \\mathbf{k})$.\n$$\n\\frac{d\\mathbf{z}}{d\\tau} = J \\nabla_{\\mathbf{z}} H(\\mathbf{z}), \\quad \\text{where} \\quad J = \\begin{pmatrix} 0 & I \\\\ -I & 0 \\end{pmatrix}\n$$\nis the standard symplectic matrix. The flow of this system, $\\phi_{\\tau}$, is a *symplectomorphism* or *canonical transformation*, meaning it preserves the symplectic two-form $\\omega = d\\mathbf{k} \\wedge d\\mathbf{x}$. This leads to the conservation of phase-space volume (Liouville's theorem). Since the Hamiltonian $H$ does not explicitly depend on the integration parameter $\\tau$, it is a conserved quantity (an integral of motion) along the exact trajectory:\n$$\n\\frac{dH}{d\\tau} = \\frac{\\partial H}{\\partial \\mathbf{z}} \\cdot \\frac{d\\mathbf{z}}{d\\tau} = (\\nabla_{\\mathbf{z}} H)^T J (\\nabla_{\\mathbf{z}} H) = 0\n$$\nThe two primary goals for the numerical method are (i) adaptivity for local accuracy and (ii) preservation of these geometric/conservation properties for long-time fidelity.\n\nA numerical integrator is called *symplectic* if its one-step map is a canonical transformation. Symplectic integrators do not conserve the original Hamiltonian $H$ exactly. Instead, they exactly conserve a nearby \"shadow\" Hamiltonian, $H_{shadow} = H + \\mathcal{O}((\\Delta \\tau)^p)$, where $p$ is the order of the method and $\\Delta \\tau$ is the step size. This property guarantees that the numerical error in $H$ remains bounded over exponentially long integration times, preventing the secular drift seen with non-symplectic methods. They also exactly preserve phase-space volume.\n\nA key difficulty arises when combining symplecticity with adaptive step sizes. A standard symplectic integrator is only symplectic for a *fixed* step size $\\Delta \\tau$. Applying it with a naively varying step size, $\\Delta \\tau_i$, breaks the property of conserving a shadow Hamiltonian, thereby destroying the favorable long-time energy conservation behavior.\n\nThe problem requires adaptivity to handle regions of strong gradients (refraction/cutoffs). This is where step sizes should be small. A robust solution must therefore reconcile the need for variable effective steps with the requirement of a fixed-step symplectic algorithm. The Sundman transformation, or reparameterization, is the canonical way to achieve this. One introduces a new monotonic integration parameter $s$ (\"fictitious time\") related to the original parameter $\\tau$ by $d\\tau = ds / g(\\mathbf{x}, \\mathbf{k})$, where $g(\\mathbf{x}, \\mathbf{k})$ is a positive-definite \"monitor function\". The new equations of motion become:\n$$\n\\frac{d\\mathbf{x}}{ds} = \\frac{1}{g(\\mathbf{x},\\mathbf{k})} \\frac{\\partial H}{\\partial \\mathbf{k}}, \\quad \\frac{d\\mathbf{k}}{ds} = -\\frac{1}{g(\\mathbf{x},\\mathbf{k})} \\frac{\\partial H}{\\partial \\mathbf{x}}\n$$\nThis new system is also Hamiltonian, with a new Hamiltonian $K(\\mathbf{x}, \\mathbf{k}) = H(\\mathbf{x}, \\mathbf{k}) / g(\\mathbf{x}, \\mathbf{k})$. One can now integrate this new Hamiltonian system using a *fixed-step* ($\\Delta s$) symplectic integrator. By choosing $g(\\mathbf{x}, \\mathbf{k})$ to be large in regions where small steps in $\\tau$ are needed (e.g., where $\\lVert \\nabla_{\\mathbf{z}} H \\rVert$ is large), one achieves adaptive resolution in the physical variables while maintaining the geometric properties of the integrator.\n\n### Option-by-Option Analysis\n\n**A. Use an embedded adaptive explicit Runge–Kutta method (such as Dormand–Prince $5(4)$) with state-dependent step size control to enforce a tight local error tolerance everywhere.**\nThis method is excellent for goal (i), providing robust local error control through adaptivity. However, it is fundamentally a non-symplectic method. When applied to a Hamiltonian system, it will not conserve phase-space volume nor will it exhibit bounded energy error. The value of the Hamiltonian $H$ will typically show a secular drift over long integrations, even with a very tight error tolerance. The cost of reducing this drift by tightening the tolerance is often prohibitive and does not change the qualitative nature of the error growth. This method fails to satisfy goal (ii).\n**Verdict: Incorrect.**\n\n**B. Use a fixed-step, fourth-order symplectic composition integrator (for example, a Yoshida composition of the leapfrog scheme) applied after a Sundman reparameterization of the ray parameter, introducing a new parameter $s$ defined by $ds/d\\tau = g(\\mathbf{x},\\mathbf{k})$ that clusters steps near refraction layers, while integrating with a constant step $\\Delta s$.**\nThis option presents a complete and theoretically sound solution. The Sundman reparameterization ($ds/d\\tau = g(\\mathbf{x},\\mathbf{k})$) provides adaptivity, satisfying goal (i). By choosing a suitable monitor function $g(\\mathbf{x},\\mathbf{k})$, the step size in the physical parameter $\\tau$ becomes small precisely where gradients are large. The integration of the transformed (but still Hamiltonian) system is then performed with a fixed-step symplectic integrator (a Yoshida composition method is a standard high-order choice). This satisfies goal (ii) by preserving the symplectic structure, thus guaranteeing bounded error in the transformed Hamiltonian $K$ and exact phase-space volume preservation. This is the state-of-the-art technique for this class of problems.\n**Verdict: Correct.**\n\n**C. Use an implicit Gauss–Legendre Runge–Kutta method of order $2s$ with adaptive, state-dependent step size control, relying on its symplecticity to conserve the Hamiltonian $H$ exactly and preserve phase-space volume, even with varying steps.**\nThis option contains several inaccuracies. First, while Gauss–Legendre methods are indeed symplectic, they do not \"conserve the Hamiltonian $H$ exactly\" in general. They conserve a shadow Hamiltonian. Second, and more critically, it suggests using standard adaptive step-size control. As explained, naively varying the step size of a symplectic method breaks the long-term conservation of a shadow Hamiltonian, which is the primary reason for using such a method. While the method would preserve phase-space volume at each step, the benefit of bounded energy error would be lost. The approach described in Option B is the correct way to incorporate adaptivity without sacrificing the benefits of symplecticity. Therefore, this option proposes a flawed implementation strategy.\n**Verdict: Incorrect.**\n\n**D. Use a variable-order linear multistep predictor–corrector scheme (Adams–Bashforth–Moulton) with aggressive adaptivity to minimize computational cost while maintaining acceptable accuracy.**\nThis option proposes using a non-geometric integrator. Linear multistep methods, like the explicit Runge-Kutta methods in Option A, are not symplectic. They are designed for general-purpose ODE solving and do not respect the geometric structure of Hamiltonian systems. For long-term integrations, they will suffer from secular drift in the Hamiltonian $H$ and will not conserve phase-space volume. They are unsuitable for problems where long-term fidelity and conservation of physical invariants are a primary concern. This method fails to satisfy goal (ii).\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "In its journey through an inhomogeneous plasma, a wave can encounter a \"cutoff,\" a surface where the conditions for propagation are no longer met and the wave reflects. This physical event must be handled algorithmically within the ray tracing framework by applying the law of specular reflection to the wavevector, $\\mathbf{k}$, and accounting for the associated phase shift predicted by WKB theory. This coding exercise  provides hands-on experience in translating a key physical phenomenon into a concrete computational routine, a common and essential task in the development of physics-based simulation tools.",
            "id": "4038279",
            "problem": "You are to implement a computational reflection handler for geometric ray tracing of Radio Frequency (RF) waves in an inhomogeneous plasma, appropriate for the ray-based high-frequency limit of the Wentzel–Kramers–Brillouin (WKB) approximation. The handler must apply at locally cut-off surfaces where the local squared refractive index $n^2$ transitions from positive to non-positive along the ray trajectory. The fundamental base for this problem is the geometric optics eikonal framework, in which the eikonal phase $S$ obeys the eikonal equation, the local wavevector $\\mathbf{k}$ equals $\\nabla S$, and the ray transport follows Hamiltonian trajectories derived from the dispersion relation. At a turning point associated with a cutoff, specular reflection occurs with the normal component of $\\mathbf{k}$ reversed, and the accumulated phase receives a Maslov index contribution corresponding to an increment of $\\pi/2$.\n\nImplement a reflection handler that, given an incident wavevector $\\mathbf{k} \\in \\mathbb{R}^2$, a surface normal vector $\\mathbf{n} \\in \\mathbb{R}^2$ at the cutoff, an input phase $\\phi$ (in radians), and local squared refractive index values $n^2_{\\mathrm{before}}$ and $n^2_{\\mathrm{after}}$ evaluated immediately before and after crossing the surface along the ray, performs the following:\n- Normalize the surface normal vector to a unit vector (if it is not already).\n- Determine whether a cutoff reflection is triggered using the condition $n^2_{\\mathrm{before}} > 0$ and $n^2_{\\mathrm{after}} \\le 0$. If the condition is not met, leave $\\mathbf{k}$ and $\\phi$ unchanged.\n- If the condition is met, reverse only the normal component of $\\mathbf{k}$ while leaving the tangential component unchanged, consistent with specular reflection, and increment the phase by $\\pi/2$ to account for the turning point in the eikonal.\n\nYour program must implement this handler and apply it to each test case in the suite below. For test cases that specify multiple sequential cutoff events, you must apply the handler sequentially in the order given, accumulating the phase and updating the wavevector at each event.\n\nAll inputs and outputs involving angles must be in radians. All wavevector components must be expressed in $\\mathrm{m}^{-1}$. The final outputs must be rounded to ten decimal places. The required output format is a single line containing all results aggregated as a comma-separated list enclosed in square brackets, where each result is itself a three-element list $[\\text{kx},\\text{ky},\\text{phase}]$ for the final wavevector and phase after processing the case. For example, a valid output line has the form \"[[kx1,ky1,phi1],[kx2,ky2,phi2],...]\" with no spaces.\n\nTest suite:\n1. General oblique incidence onto a planar cutoff: initial $\\mathbf{k} = (1.0, 0.5)$ $\\mathrm{m}^{-1}$, $\\mathbf{n} = (1.0, 0.0)$, $\\phi = 0.0$ radians, $n^2_{\\mathrm{before}} = 0.1$, $n^2_{\\mathrm{after}} = -10^{-6}$.\n2. Boundary case of normal incidence onto a cutoff: initial $\\mathbf{k} = (2.0, 0.0)$ $\\mathrm{m}^{-1}$, $\\mathbf{n} = (3.0, 0.0)$ (non-unit), $\\phi = 1.0$ radians, $n^2_{\\mathrm{before}} = 0.2$, $n^2_{\\mathrm{after}} = 0.0$.\n3. Edge case of near-grazing incidence: initial $\\mathbf{k} = (1.0, 10^{-9})$ $\\mathrm{m}^{-1}$, $\\mathbf{n} = (0.0, 1.0)$, $\\phi = 0.0$ radians, $n^2_{\\mathrm{before}} = 0.3$, $n^2_{\\mathrm{after}} = -10^{-9}$.\n4. No reflection case (no cutoff encountered): initial $\\mathbf{k} = (0.2, 0.3)$ $\\mathrm{m}^{-1}$, $\\mathbf{n} = (1.0, 0.0)$, $\\phi = 2.0$ radians, $n^2_{\\mathrm{before}} = 0.3$, $n^2_{\\mathrm{after}} = 0.2$.\n5. Non-unit normal with oblique incidence: initial $\\mathbf{k} = (0.6, -0.8)$ $\\mathrm{m}^{-1}$, $\\mathbf{n} = (2.0, 2.0)$ (non-unit), $\\phi = -0.5$ radians, $n^2_{\\mathrm{before}} = 0.15$, $n^2_{\\mathrm{after}} = -10^{-4}$.\n6. Sequential reflections at two orthogonal cutoffs: initial $\\mathbf{k} = (1.0, 0.3)$ $\\mathrm{m}^{-1}$, initial $\\phi = 0.2$ radians, then two events in order:\n   - Event 1: $\\mathbf{n} = (1.0, 0.0)$, $n^2_{\\mathrm{before}} = 0.1$, $n^2_{\\mathrm{after}} = 0.0$;\n   - Event 2: $\\mathbf{n} = (0.0, 1.0)$, $n^2_{\\mathrm{before}} = 0.05$, $n^2_{\\mathrm{after}} = -10^{-8}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the exact format: \"[[kx1,ky1,phi1],[kx2,ky2,phi2],[kx3,ky3,phi3],[kx4,ky4,phi4],[kx5,ky5,phi5],[kx6,ky6,phi6]]\", with all numerical values rounded to ten decimal places, expressed in $\\mathrm{m}^{-1}$ for wavevector components and radians for phase.",
            "solution": "The problem statement is scientifically grounded, well-posed, and objective. It correctly describes a standard physical scenario in plasma wave physics: the specular reflection of a high-frequency wave at a cutoff surface, as modeled by the Wentzel–Kramers–Brillouin (WKB) or eikonal approximation. The specified reflection law and phase increment are consistent with established principles of geometric optics and wave mechanics. Thus, the problem is valid, and a solution can be formulated.\n\nThe core of the problem lies in implementing the law of specular reflection for a wavevector $\\mathbf{k}$ at a surface defined by a local normal vector $\\mathbf{n}$. The reflection is conditional, occurring only at a \"cutoff,\" a physical boundary where the medium transitions from being permissive to wave propagation to being non-permissive. In the context of plasma physics, this corresponds to the local squared refractive index, $n^2$, transitioning from a positive value to a non-positive one.\n\nThe fundamental principle of specular reflection dictates that the component of the incident wavevector tangential to the reflection surface remains unchanged, while the component normal (perpendicular) to the surface is reversed. An incident wavevector $\\mathbf{k}_{\\text{inc}}$ can be decomposed into its normal and tangential components relative to the surface normal. First, the provided normal vector $\\mathbf{n}$ must be normalized to obtain a unit normal vector, $\\hat{\\mathbf{n}}$:\n$$ \\hat{\\mathbf{n}} = \\frac{\\mathbf{n}}{\\|\\mathbf{n}\\|} $$\nwhere $\\|\\mathbf{n}\\|$ is the Euclidean norm of $\\mathbf{n}$.\n\nThe component of $\\mathbf{k}_{\\text{inc}}$ normal to the surface, denoted $\\mathbf{k}_{\\perp}$, is the vector projection of $\\mathbf{k}_{\\text{inc}}$ onto $\\hat{\\mathbf{n}}$:\n$$ \\mathbf{k}_{\\perp} = (\\mathbf{k}_{\\text{inc}} \\cdot \\hat{\\mathbf{n}}) \\hat{\\mathbf{n}} $$\nHere, $\\mathbf{k}_{\\text{inc}} \\cdot \\hat{\\mathbf{n}}$ is the scalar projection of $\\mathbf{k}_{\\text{inc}}$ onto $\\hat{\\mathbf{n}}$. The tangential component, $\\mathbf{k}_{\\parallel}$, is the part of $\\mathbf{k}_{\\text{inc}}$ that is orthogonal to $\\hat{\\mathbf{n}}$, found by subtracting the normal component from the original vector:\n$$ \\mathbf{k}_{\\parallel} = \\mathbf{k}_{\\text{inc}} - \\mathbf{k}_{\\perp} $$\n\nAccording to the reflection law, the reflected wavevector, $\\mathbf{k}_{\\text{refl}}$, is constructed by preserving the tangential component and reversing the normal component:\n$$ \\mathbf{k}_{\\text{refl}} = \\mathbf{k}_{\\parallel} - \\mathbf{k}_{\\perp} $$\nSubstituting the expressions for $\\mathbf{k}_{\\parallel}$ and $\\mathbf{k}_{\\perp}$ yields a direct formula for the reflected vector in terms of the incident vector and the unit normal:\n$$ \\mathbf{k}_{\\text{refl}} = (\\mathbf{k}_{\\text{inc}} - \\mathbf{k}_{\\perp}) - \\mathbf{k}_{\\perp} = \\mathbf{k}_{\\text{inc}} - 2\\mathbf{k}_{\\perp} = \\mathbf{k}_{\\text{inc}} - 2(\\mathbf{k}_{\\text{inc}} \\cdot \\hat{\\mathbf{n}})\\hat{\\mathbf{n}} $$\nThis formula provides the updated wavevector $\\mathbf{k}'$ after a reflection event.\n\nThe reflection is triggered if and only if the cutoff condition is met: the squared refractive index before the surface, $n^2_{\\mathrm{before}}$, is positive, and the value after the surface, $n^2_{\\mathrm{after}}$, is non-positive. That is, $n^2_{\\mathrm{before}} > 0$ and $n^2_{\\mathrm{after}} \\le 0$. The case $n^2=0$ represents the exact point of cutoff, and $n^2<0$ represents an evanescent region where propagating wave solutions do not exist within the geometric optics framework. If this condition is not met, the wave propagates across the interface without reflection, and its state $(\\mathbf{k}, \\phi)$ remains unchanged.\n\nIn addition to the change in direction, the wave's phase, $\\phi$, accumulates a specific increment. A reflection at a simple turning point (a WKB cutoff) corresponds to a Maslov index contribution of unity, which results in a phase shift of $+\\pi/2$. Therefore, upon reflection, the new phase $\\phi'$ is given by:\n$$ \\phi' = \\phi + \\frac{\\pi}{2} $$\n\nThe computational handler must therefore execute the following algorithm for each potential reflection event:\n1.  Accept the current wave state $(\\mathbf{k}, \\phi)$ and the surface parameters $(\\mathbf{n}, n^2_{\\mathrm{before}}, n^2_{\\mathrm{after}})$ as input.\n2.  Test the cutoff condition: if $n^2_{\\mathrm{before}} > 0$ and $n^2_{\\mathrm{after}} \\le 0$ is false, return the input state $(\\mathbf{k}, \\phi)$ without modification.\n3.  If the condition is true, proceed to calculate the reflected state.\n4.  Normalize the surface normal vector $\\mathbf{n}$ to get the unit vector $\\hat{\\mathbf{n}}$. A check for a zero-norm vector is a prudent numerical safeguard.\n5.  Compute the new wavevector $\\mathbf{k}' = \\mathbf{k} - 2(\\mathbf{k} \\cdot \\hat{\\mathbf{n}})\\hat{\\mathbf{n}}$.\n6.  Compute the new phase $\\phi' = \\phi + \\pi/2$.\n7.  Return the new state $(\\mathbf{k}', \\phi')$.\n\nFor test cases involving sequential events, this handler is applied iteratively. The output state from the first event serves as the input state for the second event, and so on. The phase accumulation is additive across multiple reflections. The implementation will use vector operations to perform these calculations efficiently for the provided test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RF wave reflection problem by implementing a handler for\n    cutoff events and applying it to a suite of test cases.\n    \"\"\"\n\n    def reflection_handler(k, n, phi, n2_before, n2_after):\n        \"\"\"\n        Applies a specular reflection and phase shift if a cutoff is detected.\n\n        Args:\n            k (np.ndarray): Incident wavevector [kx, ky].\n            n (np.ndarray): Surface normal vector [nx, ny].\n            phi (float): Incident phase in radians.\n            n2_before (float): Squared refractive index before the surface.\n            n2_after (float): Squared refractive index after the surface.\n\n        Returns:\n            tuple: A tuple containing the final wavevector (np.ndarray) and\n                   final phase (float).\n        \"\"\"\n        # Check the cutoff condition: n^2 transitions from positive to non-positive.\n        if not (n2_before > 0 and n2_after = 0):\n            return k, phi\n\n        # 1. Normalize the normal vector to a unit vector.\n        norm_n = np.linalg.norm(n)\n        # As a safeguard, if the normal vector has zero length, no reflection\n        # can be defined. Return the state unchanged.\n        if norm_n == 0:\n            return k, phi\n        n_hat = n / norm_n\n\n        # 2. Reverse the normal component of k, leaving the tangential one unchanged.\n        # This is achieved using the vector reflection formula: k' = k - 2 * (k . n_hat) * n_hat\n        k_reflected = k - 2 * np.dot(k, n_hat) * n_hat\n\n        # 3. Increment the phase by pi/2 (Maslov index contribution).\n        phi_new = phi + np.pi / 2\n\n        return k_reflected, phi_new\n\n    # Define the test cases from the problem statement.\n    # Using a list of dictionaries for clarity and to handle the sequential case.\n    test_cases = [\n        # Case 1: General oblique incidence\n        {\n            \"k_initial\": np.array([1.0, 0.5]), \"phi_initial\": 0.0,\n            \"events\": [\n                {\"n\": np.array([1.0, 0.0]), \"n2_before\": 0.1, \"n2_after\": -1e-6}\n            ]\n        },\n        # Case 2: Boundary case of normal incidence\n        {\n            \"k_initial\": np.array([2.0, 0.0]), \"phi_initial\": 1.0,\n            \"events\": [\n                {\"n\": np.array([3.0, 0.0]), \"n2_before\": 0.2, \"n2_after\": 0.0}\n            ]\n        },\n        # Case 3: Edge case of near-grazing incidence\n        {\n            \"k_initial\": np.array([1.0, 1e-9]), \"phi_initial\": 0.0,\n            \"events\": [\n                {\"n\": np.array([0.0, 1.0]), \"n2_before\": 0.3, \"n2_after\": -1e-9}\n            ]\n        },\n        # Case 4: No reflection case\n        {\n            \"k_initial\": np.array([0.2, 0.3]), \"phi_initial\": 2.0,\n            \"events\": [\n                {\"n\": np.array([1.0, 0.0]), \"n2_before\": 0.3, \"n2_after\": 0.2}\n            ]\n        },\n        # Case 5: Non-unit normal with oblique incidence\n        {\n            \"k_initial\": np.array([0.6, -0.8]), \"phi_initial\": -0.5,\n            \"events\": [\n                {\"n\": np.array([2.0, 2.0]), \"n2_before\": 0.15, \"n2_after\": -1e-4}\n            ]\n        },\n        # Case 6: Sequential reflections\n        {\n            \"k_initial\": np.array([1.0, 0.3]), \"phi_initial\": 0.2,\n            \"events\": [\n                {\"n\": np.array([1.0, 0.0]), \"n2_before\": 0.1, \"n2_after\": 0.0},\n                {\"n\": np.array([0.0, 1.0]), \"n2_before\": 0.05, \"n2_after\": -1e-8}\n            ]\n        }\n    ]\n\n    results_formatted = []\n    # Process each test case\n    for case in test_cases:\n        k_current = case[\"k_initial\"]\n        phi_current = case[\"phi_initial\"]\n        \n        # Apply handler for each event in the sequence\n        for event in case[\"events\"]:\n            k_current, phi_current = reflection_handler(\n                k_current, event[\"n\"], phi_current, event[\"n2_before\"], event[\"n2_after\"]\n            )\n\n        # Round the final results to ten decimal places\n        final_k = np.round(k_current, 10)\n        final_phi = round(phi_current, 10)\n\n        # Format the result for this case as \"[kx,ky,phi]\"\n        results_formatted.append(f\"[{final_k[0]},{final_k[1]},{final_phi}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_formatted)}]\")\n\nsolve()\n```"
        }
    ]
}