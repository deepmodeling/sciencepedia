{
    "hands_on_practices": [
        {
            "introduction": "在计算模拟或实验测量中，我们通常观察到物理量随时间的振荡行为。一个核心任务是从这些时间序列数据中量化振荡的阻尼。本练习将引导你推导振幅的对数衰减与磁流体动力学（MHD）波复频率中的物理阻尼率 $\\gamma$ 之间的关系，这是一个将理论模型与可观测量联系起来的基础技能，对于验证模拟结果和解释实验数据至关重要。",
            "id": "4040061",
            "problem": "考虑在线性磁流体动力学（MHD）框架下，对非均匀磁化等离子体中单一、主导的阿尔芬振荡进行的时域模拟。由于对阿尔芬连续谱的共振吸收，该模式被阻尼。在某个固定空间点上的时间信号被建模为具有复角频率的单模响应，其中可观测的位移或磁场扰动可以很好地用一个形如 $x(t)$ 的函数来近似，其主导阶的时间依赖性源于满足 $\\omega = \\omega_{R} - i \\gamma$ 的本征频率 $\\omega$，其中 $\\omega_{R}  0$ 是实振荡频率，$\\gamma  0$ 是阻尼率。假设处于弱阻尼机制 $\\gamma / \\omega_{R} \\ll 1$，并且在许多周期内，单个傅里叶模式主导了测得的响应，因此模拍和啁啾在主导阶上可以忽略。\n\n通过提取 $|x(t)|$ 在时刻 $\\{t_{n}\\}$ 的连续局部极大值 $\\{A_{n}\\}$，并对任意连续周期设置 $\\delta = \\ln\\!\\left(\\frac{A_{n}}{A_{n+1}}\\right)$，来定义逐周期对数衰减率 $\\delta$。从一个与MHD简正模理论和小 $\\gamma$ 假设一致的有效线性响应基础出发，用实振荡频率 $\\omega_{R}$ 推导出 $\\delta$ 和 $\\gamma$ 之间的关系。简要解释从模拟的时间序列 $x(t)$ 中数值提取 $\\gamma$ 所需的概念性步骤，包括如何确定 $\\omega_{R}$ 以及在计算 $\\delta$ 时如何减轻数值偏差。\n\n以 $\\delta$ 和 $\\omega_{R}$ 表示的 $\\gamma$ 的单一闭式解析表达式的形式给出你的最终答案。无需进行数值计算。",
            "solution": "该问题基于线性磁流体动力学（MHD）的既定原理和阻尼振荡理论，具有科学依据、适定且客观。所有提供的信息都是自洽且一致的，可以进行严格的推导。因此，该问题是有效的，可以构建一个解。\n\n单个线性阻尼的MHD模式的时间演化可以用一个形如\n$$z(t) = C \\exp(-i\\omega t)$$\n的复位移或场扰动 $z(t)$ 来表示，其中 $C$ 是一个复振幅，$\\omega$ 是模式的复角频率。问题陈述 $\\omega = \\omega_{R} - i \\gamma$，其中 $\\omega_{R}  0$ 是实振荡频率，$\\gamma  0$ 是阻尼率。\n\n将复频率代入 $z(t)$ 的表达式，我们得到：\n$$z(t) = C \\exp(-i(\\omega_{R} - i\\gamma) t) = C \\exp(-i\\omega_{R}t - \\gamma t) = C \\exp(-\\gamma t) \\exp(-i\\omega_{R}t)$$\n一个可观测的物理量，例如位移 $x(t)$，是 $z(t)$ 的实部。设复常数 $C$ 以极坐标形式表示为 $C = A_{0} \\exp(i\\phi_{0})$，其中 $A_0$ 是一个实的正初始振幅，$\\phi_{0}$ 是一个初始相位。\n$$z(t) = A_{0} \\exp(i\\phi_{0}) \\exp(-\\gamma t) \\exp(-i\\omega_{R}t) = A_0 \\exp(-\\gamma t) \\exp(i(\\phi_{0} - \\omega_{R}t))$$\n取实部得到可观测信号：\n$$x(t) = \\text{Re}[z(t)] = A_{0} \\exp(-\\gamma t) \\cos(\\omega_{R}t - \\phi_{0})$$\n该方程描述了一个角频率为 $\\omega_{R}$ 的正弦振荡，其振幅随时间呈指数衰减。振幅包络由 $A(t) = A_{0} \\exp(-\\gamma t)$ 给出。\n\n问题基于 $|x(t)|$ 的连续局部极大值 $\\{A_n\\}$ 定义了对数衰减率 $\\delta$。量 $A_n$ 是发生在时刻 $t_n$ 的第 n 个峰值的振幅。“逐周期”一词意味着我们正在比较相隔一个完整振荡周期 $T_{R} = 2\\pi / \\omega_{R}$ 的两个连续峰值的振幅。\n\n设 $A_n$ 为时刻 $t_n$ 的一个峰值的振幅。下一个对应的峰值（例如，下一个正极大值）将在一个周期后，即时刻 $t_{n+1} \\approx t_n + T_R$ 出现。这些峰值的振幅由包络 $A(t)$ 在这些时刻的值给出。在问题指定的弱阻尼机制 $\\gamma / \\omega_{R} \\ll 1$ 中，这是一个极好的近似，因为在一个周期内阻尼很慢。更严谨的计算会涉及通过将其导数设为零来求 $x(t)$ 的极值，这会显示出峰值时刻存在一个量级为 $\\gamma/\\omega_R^2$ 的微小偏移。然而，在弱阻尼假设下，对最终关系式产生的修正是 $(\\gamma/\\omega_R)^2$ 量级的，可以忽略不计。\n\n因此，我们可以陈述：\n$$A_{n} = A(t_n) = A_{0} \\exp(-\\gamma t_{n})$$\n$$A_{n+1} = A(t_{n+1}) = A(t_{n} + T_{R}) = A_{0} \\exp(-\\gamma (t_{n} + T_{R}))$$\n这两个连续振幅的比率为：\n$$\\frac{A_{n}}{A_{n+1}} = \\frac{A_{0} \\exp(-\\gamma t_{n})}{A_{0} \\exp(-\\gamma t_{n} - \\gamma T_{R})} = \\frac{\\exp(-\\gamma t_{n})}{\\exp(-\\gamma t_{n}) \\exp(-\\gamma T_{R})} = \\exp(\\gamma T_{R})$$\n对数衰减率 $\\delta$ 定义为此比率的自然对数：\n$$\\delta = \\ln\\left(\\frac{A_{n}}{A_{n+1}}\\right) = \\ln(\\exp(\\gamma T_{R})) = \\gamma T_{R}$$\n代入周期表达式 $T_{R} = 2\\pi / \\omega_{R}$，我们得到 $\\delta$、$\\gamma$ 和 $\\omega_{R}$ 之间的关系：\n$$\\delta = \\gamma \\frac{2\\pi}{\\omega_{R}}$$\n解出阻尼率 $\\gamma$，得到最终表达式：\n$$\\gamma = \\frac{\\delta \\omega_{R}}{2\\pi}$$\n要从模拟的时间序列 $x(t)$ 中数值提取 $\\gamma$，需要以下概念性步骤：\n1.  **确定实频率 $\\omega_{R}$**：可以通过对时间序列 $x(t)$ 应用快速傅里叶变换（FFT）并确定功率谱 $|\\tilde{x}(\\omega)|^2$ 达到峰值的频率，来找到主导实频率 $\\omega_{R}$。或者，可以测量连续正峰值或过零点之间的平均时间间隔以找到周期 $T_{R}$，然后计算 $\\omega_{R} = 2\\pi/T_{R}$。\n\n2.  **确定对数衰减率 $\\delta$**：需要一种稳健的方法来减轻由噪声或其他伪影引起的数值偏差。不应仅使用两个连续的峰值，而应首先识别时间序列中所有的正局部极大值 $\\{A_n\\}$。根据关系式 $A_n \\approx A_0 \\exp(-\\gamma n T_R)$，$\\ln(A_n)$ 关于周期数 $n$ 的图应为一条直线。该线的斜率为 $m = -\\gamma T_R$。对数衰减率是每个周期的振幅减少量，因此 $\\delta = -m = \\gamma T_R$。对数据点 $(n, \\ln(A_n))$ 进行线性最小二乘拟合，可为斜率 $m$ 提供一个统计上稳健的估计，从而得到 $\\delta$。这种基于回归的方法在许多周期上进行平均，远比两点估计法准确。\n\n3.  **计算阻尼率 $\\gamma$**：利用数值上确定的 $\\delta$ 和 $\\omega_{R}$ 的值，使用推导出的公式 $\\gamma = \\delta \\omega_{R} / (2\\pi)$ 来计算阻尼率。",
            "answer": "$$\\boxed{\\frac{\\delta \\omega_{R}}{2\\pi}}$$"
        },
        {
            "introduction": "在理解了如何测量阻尼之后，一个自然而然的问题是：能量吸收具体发生在等离子体的哪个位置？本练习将物理上的共振条件转化为一个具体的计算任务，要求你通过编程来寻找共振位置，并分析阻尼对等离子体位形（特别是安全因子剖面 $q(r)$）的敏感性。这项实践有助于培养实现物理模型以及进行参数化分析的能力，这对于评估环向Alfvén本征模（TAE）等全局模式的稳定性至关重要。",
            "id": "4039996",
            "problem": "考虑一个理想磁流体力学（MHD）适用的圆形托卡马克等离子体，其大半径为 $R_0$，小半径为 $a$，磁场强度 $B_0$ 均匀，质量密度 $\\rho_0$ 均匀。剪切阿尔芬波的色散关系为 $\\omega^2 = k_\\parallel^2 v_A^2$，其中阿尔芬速度 $v_A = B_0 / \\sqrt{\\mu_0 \\rho_0}$，$\\mu_0$ 是真空磁导率。环向阿尔芬本征模（TAE）是一种全局模，具有环向数 $n$ 和极向数 $m$，它耦合了相邻的极向谐波。在大环径比托卡马克几何中，给定极向谐波的平行波数可以表示为 $k_\\parallel(r) = \\left(n - \\frac{j}{q(r)}\\right)/R_0$，其中对于相邻谐波，$j$ 等于 $m$ 或 $m+1$。安全因子剖面为 $q(r) = q_0 + q_s \\left(\\frac{r}{a}\\right)^p$，其中 $q_0  0$、$q_s  0$ 和 $p  0$，这使得 $q(r)$ 在 $r \\in [0,a]$ 上严格单调递增。阿尔芬波的连续谱共振条件是全局模频率 $\\omega$ 等于局域剪切阿尔芬连续谱频率，这发生在 $\\omega^2 = v_A^2 k_\\parallel(r)^2$ 的位置。全局TAE由于在阿尔芬连续谱中的共振吸收而产生的阻尼，可以通过失谐函数 $$D(\\omega,r) = \\omega^2 - v_A^2 k_\\parallel(r)^2,$$ 在共振位置 $r^\\star$（此处 $D(\\omega,r^\\star)=0$）的斜率来表征。定义一个阻尼对q剖面整形的灵敏度指数，作为一个无量纲的归一化度量：$$S_{\\mathrm{damp}} = \\left(\\frac{v_A}{R_0}\\right)^2 \\left| \\frac{dD}{dr}\\bigg|_{r=r^\\star} \\right|^{-1},$$ 当 $D(\\omega,r)$ 在共振点附近的局域斜率较小时，该指数会增大。该指数分离出了几何和连续谱斜率对共振吸收的贡献，旨在用于灵敏度分析，而非作为一个绝对的阻尼率。您的任务是根据给定的基本关系，推导如何为一个指定的 $q(r)$ 和全局频率 $\\omega$ 计算 $r^\\star$ 和 $S_{\\mathrm{damp}}$。这需要通过识别由 $j=m$ 和 $j=m+1$ 谐波之间的耦合产生的所有可能共振，并选择能产生最大 $S_{\\mathrm{damp}}$（即最强的连续谱阻尼灵敏度）的物理相关共振。为保证数值鲁棒性，如果在共振点 $|dq/dr|$ 为零，则在计算斜率时使用一个正则化下限 $d_0$，令 $|dq/dr|$ 等于 $10^{-8}$（无量纲，单位为每米）。如果在指定参数下，$r \\in [0,a]$ 内不存在共振，则将共振位置报告为 $-1.0$，灵敏度指数报告为 $0.0$。将共振位置以米为单位表示，灵敏度指数以无量纲实数表示。角频率 $\\omega$ 必须以弧度/秒为单位处理。\n\n实现一个程序，在给定四个测试用例的参数后，按如下方式计算共振位置 $r^\\star$ 和灵敏度指数 $S_{\\mathrm{damp}}$：\n- 使用 $v_A$、$k_\\parallel(r)$ 的定义以及共振条件 $\\omega^2 = v_A^2 k_\\parallel(r)^2$。\n- 考虑 $j=m$ 和 $j=m+1$ 两种情况，以及与 $\\omega^2 = v_A^2 k_\\parallel^2$ 一致的 $k_\\parallel$ 共振条件中的两种符号，从而识别候选共振。对于每个候选共振，检查其对应的 $q$ 值是否在给定 $q(r)$ 在 $[0,a]$ 上的取值范围内。对于有效的候选共振，通过对 $q(r)$ 求逆来计算相应的 $r^\\star$。\n- 对于每个有效的候选 $r^\\star$，使用链式法则以及 $k_\\parallel(r)$ 和 $q(r)$ 的给定形式计算在 $r^\\star$ 处的导数 $\\frac{dD}{dr}$，并在需要时使用正则化下限 $d_0$ 计算 $|dq/dr|$ 来评估 $S_{\\mathrm{damp}}$。\n- 选择产生最大 $S_{\\mathrm{damp}}$ 的候选共振进行报告。\n\n使用以下测试套件（除非另有说明，所有量均采用国际单位制）：\n1. $R_0 = 3.0$, $a = 0.9$, $B_0 = 3.2$, $\\rho_0 = 2.0\\times 10^{-7}$, $q_0 = 1.1$, $q_s = 1.4$, $p = 2$, $m = 6$, $n = 6$, $\\omega = 1.0\\times 10^{6}$。\n2. $R_0 = 3.0$, $a = 0.9$, $B_0 = 3.2$, $\\rho_0 = 2.0\\times 10^{-7}$, $q_0 = 1.1$, $q_s = 1.4$, $p = 4$, $m = 6$, $n = 6$, $\\omega = 1.0\\times 10^{6}$。\n3. $R_0 = 3.0$, $a = 0.9$, $B_0 = 3.2$, $\\rho_0 = 2.0\\times 10^{-7}$, $q_0 = 1.1$, $q_s = 0.6$, $p = 1$, $m = 6$, $n = 6$, $\\omega = 1.0\\times 10^{6}$。\n4. $R_0 = 3.0$, $a = 0.9$, $B_0 = 3.2$, $\\rho_0 = 2.0\\times 10^{-7}$, $q_0 = 1.2$, $q_s = 1.8$, $p = 3$, $m = 8$, $n = 5$, $\\omega = 1.0\\times 10^{6}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，您需要输出共振位置（以米为单位，四舍五入到六位小数），后跟灵敏度指数（四舍五入到六位小数）。例如，您的输出格式应为：\n“[r1,S1,r2,S2,r3,S3,r4,S4]”。",
            "solution": "该问题是有效的，因为它在科学上基于聚变等离子体中的磁流体力学（MHD）原理，在数学上是适定的，并且为获得唯一解提供了所有必要的数据和定义。因此，我们可以进行推导和算法设计。\n\n核心任务是计算托卡马克等离子体中环向阿尔芬本征模（TAE）的共振位置 $r^\\star$ 和灵敏度指数 $S_{\\mathrm{damp}}$。通过识别所有可能的连续谱共振，并选择使 $S_{\\mathrm{damp}}$ 最大化的那一个（即对应于对连续谱阻尼的最强灵敏度），即可找到解决方案。\n\n首先，我们确定基本的物理和几何量。等离子体的特征在于其大半径 $R_0$、小半径 $a$、磁场 $B_0$ 和质量密度 $\\rho_0$。关键的速度标度是阿尔芬速度，定义为：\n$$ v_A = \\frac{B_0}{\\sqrt{\\mu_0 \\rho_0}} $$\n其中 $\\mu_0$ 是真空磁导率。安全因子剖面 $q(r)$ 由小半径 $r$ 的一个单调函数给出：\n$$ q(r) = q_0 + q_s \\left(\\frac{r}{a}\\right)^p $$\n因此，等离子体内的 $q$ 值范围是 $[q(0), q(a)]$，即 $[q_0, q_0 + q_s]$。在大环径比近似下，具有环向数 $n$ 和极向谐波 $j$（其中 $j$ 可以是 $m$ 或 $m+1$）的模式的平行波数 $k_\\parallel$ 给出如下：\n$$ k_\\parallel(r) = \\frac{1}{R_0} \\left( n - \\frac{j}{q(r)} \\right) $$\n当全局模频率 $\\omega$ 与局域剪切阿尔芬连续谱频率 $\\omega_A(r) = |k_\\parallel(r)| v_A$ 相匹配时，发生连续谱共振。因此，共振条件为 $\\omega^2 = \\omega_A(r)^2$，即：\n$$ \\omega^2 = v_A^2 k_\\parallel(r)^2 $$\n取平方根并注意到 $\\omega  0$ 和 $v_A  0$，我们得到 $\\omega = v_A |k_\\parallel(r)|$。代入 $k_\\parallel(r)$ 的表达式：\n$$ \\omega = v_A \\left| \\frac{1}{R_0} \\left( n - \\frac{j}{q(r)} \\right) \\right| $$\n重新整理可得在共振位置 $r^\\star$ 处对 $q(r)$ 的条件：\n$$ \\left| n - \\frac{j}{q(r^\\star)} \\right| = \\frac{\\omega R_0}{v_A} $$\n我们定义无量纲归一化频率 $\\Omega = \\omega R_0 / v_A$。条件变为 $|n - j/q^\\star| = \\Omega$。对于每个 $j$ 值，该方程产生两个可能的 $q^\\star$ 解：\n1. $n - j/q^\\star = \\Omega \\implies q^\\star = \\frac{j}{n - \\Omega}$\n2. $n - j/q^\\star = -\\Omega \\implies q^\\star = \\frac{j}{n + \\Omega}$\n\n由于问题涉及极向谐波 $m$ 和 $m+1$ 之间的耦合，我们必须同时考虑 $j=m$ 和 $j=m+1$。这导致在共振点安全因子总共有四个潜在的候选值，我们将其表示为 $q^\\star_{\\text{cand}}$。一个候选共振只有在其对应的 $q^\\star_{\\text{cand}}$ 落在安全因子剖面的物理范围内，即 $q_0 \\le q^\\star_{\\text{cand}} \\le q_0 + q_s$ 时，才是物理上可能的。\n\n对于满足此条件的每个有效 $q^\\star$，我们可以通过对 $q(r)$ 剖面方程求逆来找到相应的共振半径 $r^\\star$：\n$$ q^\\star = q_0 + q_s \\left(\\frac{r^\\star}{a}\\right)^p \\implies r^\\star = a \\left( \\frac{q^\\star - q_0}{q_s} \\right)^{1/p} $$\n条件 $q_0 \\le q^\\star \\le q_0 + q_s$ 确保了 $0 \\le r^\\star \\le a$。\n\n接下来，我们推导灵敏度指数 $S_{\\mathrm{damp}}$ 的表达式。其定义为：\n$$ S_{\\mathrm{damp}} = \\left(\\frac{v_A}{R_0}\\right)^2 \\left| \\frac{dD}{dr}\\bigg|_{r=r^\\star} \\right|^{-1} $$\n其中 $D(\\omega,r) = \\omega^2 - v_A^2 k_\\parallel(r)^2$。我们使用链式法则计算 $D$ 对 $r$ 的导数。\n$$ \\frac{dD}{dr} = -v_A^2 \\frac{d}{dr} \\left( k_\\parallel(r)^2 \\right) = -2 v_A^2 k_\\parallel(r) \\frac{dk_\\parallel}{dr} $$\n$k_\\parallel(r)$ 的导数是：\n$$ \\frac{dk_\\parallel}{dr} = \\frac{d}{dr} \\left[ \\frac{1}{R_0} \\left( n - \\frac{j}{q(r)} \\right) \\right] = \\frac{j}{R_0 q(r)^2} \\frac{dq}{dr} $$\n将此代回，我们得到：\n$$ \\frac{dD}{dr} = -2 v_A^2 k_\\parallel(r) \\frac{j}{R_0 q(r)^2} \\frac{dq}{dr} $$\n在共振位置 $r^\\star$，我们有 $k_\\parallel(r^\\star) = \\pm \\omega / v_A$。代入此式和 $q(r^\\star) = q^{\\star}$：\n$$ \\frac{dD}{dr}\\bigg|_{r=r^\\star} = -2 v_A^2 \\left( \\pm \\frac{\\omega}{v_A} \\right) \\frac{j}{R_0 (q^\\star)^2} \\frac{dq}{dr}\\bigg|_{r=r^\\star} = \\mp \\frac{2 v_A \\omega j}{R_0 (q^\\star)^2} \\frac{dq}{dr}\\bigg|_{r=r^\\star} $$\n灵敏度指数取决于该斜率的绝对值：\n$$ \\left| \\frac{dD}{dr}\\bigg|_{r=r^\\star} \\right| = \\frac{2 v_A \\omega j}{R_0 (q^\\star)^2} \\left| \\frac{dq}{dr}\\bigg|_{r=r^\\star} \\right| $$\n将此代入 $S_{\\mathrm{damp}}$ 的定义中：\n$$ S_{\\mathrm{damp}} = \\left(\\frac{v_A}{R_0}\\right)^2 \\left( \\frac{2 v_A \\omega j}{R_0 (q^\\star)^2} \\left| \\frac{dq}{dr}\\bigg|_{r=r^\\star} \\right| \\right)^{-1} = \\frac{v_A^2}{R_0^2} \\frac{R_0 (q^\\star)^2}{2 v_A \\omega j \\left| \\frac{dq}{dr}\\bigg|_{r=r^\\star} \\right|} $$\n化简后得到灵敏度指数的最终表达式：\n$$ S_{\\mathrm{damp}} = \\frac{v_A (q^\\star)^2}{2 R_0 \\omega j \\left| \\frac{dq}{dr}\\bigg|_{r=r^\\star} \\right|} $$\n为计算该值，我们需要安全因子剖面的导数：\n$$ \\frac{dq}{dr} = \\frac{d}{dr} \\left[ q_0 + q_s \\left(\\frac{r}{a}\\right)^p \\right] = q_s \\frac{p r^{p-1}}{a^p} $$\n问题为该导数为零的情况指定了正则化方法。如果 $p  1$，这可能在 $r^\\star=0$ 处发生。根据题意，如果 $|\\frac{dq}{dr}|_{r=r^\\star}$ 为零，我们必须使用一个下限值 $d_0 = 10^{-8} \\, \\text{m}^{-1}$。\n\n总体算法如下：\n1. 对于给定的一组参数，计算常数项 $v_A$ 和 $\\Omega$。\n2. 确定安全因子的物理范围 $[q_0, q_0 + q_s]$。\n3. 将找到的最佳共振初始化为 $(r^\\star, S_{\\mathrm{damp}}) = (-1.0, 0.0)$。\n4. 遍历两个相关的极向谐波，$j \\in \\{m, m+1\\}$。\n5. 对于每个 $j$，根据 $q^\\star = j/(n \\pm \\Omega)$ 计算两个候选 $q^\\star$ 值。\n6. 对于每个候选 $q^\\star$，检查它是否在物理范围 $[q_0, q_0 + q_s]$ 内。\n7. 如果候选 $q^\\star$ 有效：\n    a. 通过对 $q(r)$ 剖面求逆来计算共振半径 $r^\\star$。\n    b. 计算导数 $|\\frac{dq}{dr}|_{r=r^\\star}$，并在必要时应用正则化下限 $d_0$。\n    c. 使用推导出的公式计算灵敏度指数 $S_{\\mathrm{damp}}$。\n    d. 如果计算出的 $S_{\\mathrm{damp}}$ 大于当前最大值，则将找到的最佳共振更新为新的 $(r^\\star, S_{\\mathrm{damp}})$。\n8. 在检查完所有四个候选值后，存储的 $(r^\\star, S_{\\mathrm{damp}})$ 即为给定参数的结果。如果没有找到有效的共振，则初始值 $(-1.0, 0.0)$ 为正确结果。\n此过程确保我们识别所有可能的共振，并按要求选择具有最大灵敏度指数的共振。",
            "answer": "```python\nimport numpy as np\nfrom scipy.constants import mu_0\n\ndef solve():\n    \"\"\"\n    Solves for the TAE resonance location and damping sensitivity index\n    for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        (3.0, 0.9, 3.2, 2.0e-7, 1.1, 1.4, 2, 6, 6, 1.0e6),\n        (3.0, 0.9, 3.2, 2.0e-7, 1.1, 1.4, 4, 6, 6, 1.0e6),\n        (3.0, 0.9, 3.2, 2.0e-7, 1.1, 0.6, 1, 6, 6, 1.0e6),\n        (3.0, 0.9, 3.2, 2.0e-7, 1.2, 1.8, 3, 8, 5, 1.0e6),\n    ]\n\n    results = []\n    d0 = 1.0e-8\n\n    for params in test_cases:\n        R0, a, B0, rho0, q0, qs, p, m, n, omega = params\n        best_r_star = -1.0\n        max_S_damp = 0.0\n        \n        v_A = B0 / np.sqrt(mu_0 * rho0)\n        Omega = omega * R0 / v_A\n        q_min, q_max = q0, q0 + qs\n\n        for j in [m, m + 1]:\n            q_star_candidates = []\n            if not np.isclose(n - Omega, 0):\n                q_star_candidates.append(j / (n - Omega))\n            if not np.isclose(n + Omega, 0):\n                q_star_candidates.append(j / (n + Omega))\n\n            for q_star in q_star_candidates:\n                if q_min - 1e-9 = q_star = q_max + 1e-9:\n                    if np.isclose(qs, 0): continue\n                    \n                    q_val_for_inversion = np.clip(q_star, q_min, q_max)\n                    \n                    if np.isclose(q_val_for_inversion, q0):\n                        r_star = 0.0\n                    else:\n                        base = (q_val_for_inversion - q0) / qs\n                        r_star = a * (base)**(1.0 / p)\n\n                    dqdr_val_abs = 0.0\n                    if p > 1 and np.isclose(r_star, 0.0):\n                        dqdr_val_abs = d0\n                    else:\n                        if p == 1:\n                            dqdr_val_abs = np.abs(qs / a)\n                        elif p  1 and np.isclose(r_star, 0.0):\n                            dqdr_val_abs = np.inf\n                        else:\n                            dqdr_val_abs = np.abs(qs * p * r_star**(p - 1) / a**p)\n                    \n                    if np.isclose(dqdr_val_abs, 0):\n                        dqdr_val_abs = d0\n                    \n                    S_damp = 0.0\n                    if not (np.isinf(dqdr_val_abs) or dqdr_val_abs == 0):\n                        S_damp = (v_A * q_star**2) / (2 * R0 * omega * j * dqdr_val_abs)\n\n                    if S_damp > max_S_damp:\n                        max_S_damp = S_damp\n                        best_r_star = r_star\n\n        results.extend([best_r_star, max_S_damp])\n    \n    output_str = \",\".join([f\"{val:.6f}\" for val in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本节的最终实践将共振和阻尼的概念整合到一个系统级的计算中。我们不再关注单个模式，而是考虑一个外部天线，它会激发一个宽频谱的波。这项练习通过将天线功率谱与等离子体的共振响应函数进行积分，来计算等离子体吸收的总功率，这是评估波加热效率的关键指标。此问题展示了如何运用数值积分这一强大工具来模拟外部驱动源与等离子体连续谱之间的相互作用。",
            "id": "4040059",
            "problem": "您的任务是在一个归一化的、无量纲的框架下，实现一个由外部天线驱动的磁流体力学（MHD）波的共振吸收和阻尼的计算模型。其物理基础是剪切阿尔芬波满足色散关系 $\\,\\omega = k_{\\parallel} v_A\\,$，并且当驱动频率与连续谱匹配时会发生吸收，从而产生一个共振层。在线性响应框架中，吸收功率与等离子体响应的虚部成正比。为了分离出核心的数学问题，请使用无量纲归一化，其中平行波数由 $\\,\\kappa\\,$ 表示，归一化驱动频率为 $\\,\\Omega\\,$，阻尼宽度为 $\\,\\Gamma\\,$。不使用任何物理单位；所有量均为无量纲，所有输出必须报告为不带单位的十进制浮点数。\n\n从能量守恒和线性化 MHD 响应出发，总共振吸收率被建模为对外部驱动谱的积分。假设外部天线施加的平行波数谱被建模为高斯函数，\n$$\nS(\\kappa; S_0, \\kappa_0, L_\\parallel) = S_0 \\exp\\!\\left(-\\frac{(\\kappa - \\kappa_0)^2}{2\\sigma^2}\\right),\n$$\n其中 $\\,\\sigma = 1/L_\\parallel\\,$ 代表谱宽，而 $\\,L_\\parallel\\,$ 是天线平行相关长度的一个无量纲代理。将共振吸收核建模为以共振条件 $\\,\\kappa = \\Omega\\,$ 为中心的洛伦兹函数，\n$$\n\\mathcal{R}(\\kappa; \\Omega, \\Gamma) = \\frac{\\Gamma}{(\\Omega - \\kappa)^2 + \\Gamma^2}.\n$$\n在这些假设下，总无量纲共振吸收为\n$$\nQ_{\\mathrm{tot}} = \\int_{-\\kappa_{\\max}}^{+\\kappa_{\\max}} S(\\kappa; S_0, \\kappa_0, L_\\parallel)\\,\\mathcal{R}(\\kappa; \\Omega, \\Gamma)\\,d\\kappa,\n$$\n其中 $\\,\\kappa_{\\max}\\,$ 是一个足够大的截断值，以确保数值收敛。\n\n您的程序必须实现一个稳健的数值求积方法，以计算指定参数下的 $\\,Q_{\\mathrm{tot}}\\,$，然后使用这些计算结果来预测加热随天线配置的标度关系。具体来说：\n\n- 对所有积分使用无量纲数值求积，绝对容差为 $\\,10^{-10}\\,$，相对容差为 $\\,10^{-10}\\,$。\n- 对所有积分使用 $\\,\\kappa_{\\max} = 20.0\\,$。\n\n实现以下参数集测试套件以计算 $\\,Q_{\\mathrm{tot}}\\,$。在所有测试中，使用相同的驱动频率 $\\,\\Omega = 3.0\\,$。\n\n$\\,\\bullet\\,$ 测试用例 $\\,1\\,$（基准，匹配驱动）：\n- $\\,S_0 = 1.0\\,$,\n- $\\,L_\\parallel = 4.0\\,$,\n- $\\,k_0 = 3.0\\,$,\n- $\\,\\Gamma = 0.05\\,$.\n\n$\\,\\bullet\\,$ 测试用例 $\\,2\\,$（窄谱，中心未对准）：\n- $\\,S_0 = 1.0\\,$,\n- $\\,L_\\parallel = 12.0\\,$,\n- $\\,k_0 = 3.5\\,$,\n- $\\,\\Gamma = 0.05\\,$.\n\n$\\,\\bullet\\,$ 测试用例 $\\,3\\,$（宽谱，中等阻尼）：\n- $\\,S_0 = 1.0\\,$,\n- $\\,L_\\parallel = 2.0\\,$,\n- $\\,k_0 = 2.8\\,$,\n- $\\,\\Gamma = 0.20\\,$.\n\n$\\,\\bullet\\,$ 测试用例 $\\,4\\,$（驱动振幅减小，共振非常尖锐）：\n- $\\,S_0 = 0.8\\,$,\n- $\\,L_\\parallel = 8.0\\,$,\n- $\\,k_0 = 3.0\\,$,\n- $\\,\\Gamma = 0.01\\,$.\n\n除了四个单点计算之外，还需计算两个标度诊断量，以量化加热如何依赖于天线配置：\n\n$\\,\\bullet\\,$ 标度诊断 $\\,\\mathrm{A}\\,$：当天线与共振匹配时，加热相对于 $\\,L_\\parallel\\,$ 的指数。对于 $\\,S_0 = 1.0\\,$, $\\,\\kappa_0 = \\Omega = 3.0\\,$ 和 $\\,\\Gamma = 0.05\\,$，计算 $\\,L_\\parallel \\in \\{2.0, 4.0, 8.0, 16.0\\}\\,$ 时 的 $\\,Q_{\\mathrm{tot}}\\,$。在对数-对数空间中通过最小二乘法拟合幂律 $\\,Q_{\\mathrm{tot}} \\propto L_\\parallel^\\beta\\,$，以确定 $\\,\\beta\\,$（作为一个浮点数）。\n\n$\\,\\bullet\\,$ 标度诊断 $\\,\\mathrm{B}\\,$：匹配天线中心与未对准天线中心的加热比率。对于 $\\,S_0 = 1.0\\,$, $\\,L_\\parallel = 6.0\\,$, $\\,\\Omega = 3.0\\,$ 和 $\\,\\Gamma = 0.05\\,$，计算\n$$\nR = \\frac{Q_{\\mathrm{tot}}(S_0, \\kappa_0 = \\Omega, L_\\parallel, \\Omega, \\Gamma)}{Q_{\\mathrm{tot}}(S_0, \\kappa_0 = \\Omega + 0.5, L_\\parallel, \\Omega, \\Gamma)}.\n$$\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含四个测试用例的 $\\,Q_{\\mathrm{tot}}\\,$ 值，然后是来自标度诊断 $\\,\\mathrm{A}\\,$ 的指数 $\\,\\beta\\,$，最后是来自标度诊断 $\\,\\mathrm{B}\\,$ 的比率 $\\,R\\,$。每个数值必须四舍五入到六位小数。例如，输出格式必须严格为\n$$\n[Q_1,Q_2,Q_3,Q_4,\\beta,R],\n$$\n其中 $\\,Q_i\\,$, $\\,\\beta\\,$ 和 $\\,R\\,$ 是四舍五入到六位小数的十进制浮点数。",
            "solution": "该问题要求在一个简化的磁流体力学（MHD）波加热模型中计算总共振吸收 $Q_{\\mathrm{tot}}$。该量由一个必须通过数值计算的定积分定义。此外，还必须基于此计算执行两个标度诊断。\n\n出发点是总无量纲共振吸收的显式公式：\n$$\nQ_{\\mathrm{tot}} = \\int_{-\\kappa_{\\max}}^{+\\kappa_{\\max}} S(\\kappa; S_0, \\kappa_0, L_\\parallel)\\,\\mathcal{R}(\\kappa; \\Omega, \\Gamma)\\,d\\kappa\n$$\n此处，$\\kappa$ 是无量纲平行波数，积分在对称区间 $[-\\kappa_{\\max}, +\\kappa_{\\max}]$ 上进行，其中 $\\kappa_{\\max} = 20.0$。\n\n被积函数是两个函数的乘积：\n1. 外部天线功率谱 $S(\\kappa)$，它被建模为高斯函数：\n$$\nS(\\kappa; S_0, \\kappa_0, L_\\parallel) = S_0 \\exp\\!\\left(-\\frac{(\\kappa - \\kappa_0)^2}{2\\sigma^2}\\right)\n$$\n参数包括振幅 $S_0$、中心波数 $\\kappa_0$ 和谱宽 $\\sigma$，谱宽通过 $\\sigma = 1/L_\\parallel$ 与天线平行相关长度 $L_\\parallel$ 相关。\n\n2. 共振吸收核 $\\mathcal{R}(\\kappa)$，它被建模为以共振条件 $\\kappa = \\Omega$ 为中心的洛伦兹函数（在统计学中也称为柯西分布）：\n$$\n\\mathcal{R}(\\kappa; \\Omega, \\Gamma) = \\frac{\\Gamma}{(\\Omega - \\kappa)^2 + \\Gamma^2}\n$$\n参数是归一化驱动频率 $\\Omega$ 和阻尼宽度 $\\Gamma$。洛伦兹形式自然产生于受驱、阻尼谐振子，并代表了等离子体连续谱的频率响应。\n\n高斯函数和洛伦兹函数的乘积通常没有简单的解析积分。因此，数值求积是合适的计算方法。`scipy.integrate.quad` 函数是用于此目的的稳健工具，可为一维积分提供高精度结果。它实现了一种自适应求积方案，适用于像指定的那样表现良好的函数。我们将配置它使用指定的 $10^{-10}$ 绝对容差和 $10^{-10}$ 相对容差。\n\n整个过程如下：\n首先，实现一个通用函数来计算任何给定参数集 $\\{S_0, \\kappa_0, L_\\parallel, \\Omega, \\Gamma\\}$ 下的 $Q_{\\mathrm{tot}}$。该函数将被积函数定义为乘积 $S(\\kappa) \\cdot \\mathcal{R}(\\kappa)$，并使用 `scipy.integrate.quad` 来计算从 $-\\kappa_{\\max}$ 到 $+\\kappa_{\\max}$ 的积分。\n\n其次，通过提供相应的参数集，使用此函数计算四个指定的测试用例。这些用例的共同驱动频率是 $\\Omega = 3.0$。\n\n第三，计算标度诊断量：\n\n- **标度诊断 A**: 这涉及到在幂律关系 $Q_{\\mathrm{tot}} \\propto L_\\parallel^\\beta$ 中确定指数 $\\beta$。为此，我们在保持其他参数固定（$S_0 = 1.0$, $\\kappa_0 = \\Omega = 3.0$, $\\Gamma = 0.05$）的情况下，计算 $L_\\parallel \\in \\{2.0, 4.0, 8.0, 16.0\\}$ 四个值对应的 $Q_{\\mathrm{tot}}$。该幂律关系可以通过取自然对数进行线性化：\n$$\n\\ln(Q_{\\mathrm{tot}}) = \\beta \\ln(L_\\parallel) + \\text{const}\n$$\n这是一个形如 $y = m x + c$ 的方程，其中 $y = \\ln(Q_{\\mathrm{tot}})$，$x = \\ln(L_\\parallel)$，斜率为 $m = \\beta$。我们可以通过对计算出的数据点 $(\\ln(L_\\parallel), \\ln(Q_{\\mathrm{tot}}))$ 进行线性最小二乘回归来找到 $\\beta$。使用 `numpy.polyfit` 函数并设置阶数为 1 是进行这种线性回归的直接且合适的工具。\n\n- **标度诊断 B**: 这需要计算“匹配”天线与“未对准”天线总吸收的比率 $R$。参数为 $S_0 = 1.0$, $L_\\parallel = 6.0$, $\\Omega = 3.0$ 和 $\\Gamma = 0.05$。\n分子是匹配情况下的 $Q_{\\mathrm{tot}}$，此时天线谱以共振为中心，即 $\\kappa_0 = \\Omega = 3.0$。\n分母是未对准情况下的 $Q_{\\mathrm{tot}}$，此时天线谱的中心在 $\\kappa_0 = \\Omega + 0.5 = 3.5$。\n然后该比率计算如下：\n$$\nR = \\frac{Q_{\\mathrm{tot}}(\\kappa_0 = 3.0)}{Q_{\\mathrm{tot}}(\\kappa_0 = 3.5)}\n$$\n\n最后，所有六个结果——来自测试用例的四个 $Q_{\\mathrm{tot}}$ 值、指数 $\\beta$ 和比率 $R$——被收集起来，四舍五入到六位小数，并格式化为所需的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Main function to compute resonant absorption and scaling diagnostics.\n    \"\"\"\n    K_MAX = 20.0\n    ATOL = 1e-10\n    RTOL = 1e-10\n    OMEGA_COMMON = 3.0\n\n    def calculate_Q_tot(S0, L_parallel, kappa0, Omega, Gamma):\n        \"\"\"\n        Computes the total dimensionless resonant absorption Q_tot.\n\n        Args:\n            S0 (float): Amplitude of the antenna spectrum.\n            L_parallel (float): Antenna parallel correlation length.\n            kappa0 (float): Central wavenumber of the antenna spectrum.\n            Omega (float): Normalized drive frequency.\n            Gamma (float): Damping width.\n\n        Returns:\n            float: The value of the integral Q_tot.\n        \"\"\"\n        sigma = 1.0 / L_parallel\n\n        def S_kappa(kappa):\n            \"\"\"Gaussian antenna spectrum.\"\"\"\n            return S0 * np.exp(-((kappa - kappa0)**2) / (2 * sigma**2))\n\n        def R_kappa(kappa):\n            \"\"\"Lorentzian resonant absorption kernel.\"\"\"\n            return Gamma / ((Omega - kappa)**2 + Gamma**2)\n\n        def integrand(kappa):\n            \"\"\"Product of spectrum and kernel.\"\"\"\n            return S_kappa(kappa) * R_kappa(kappa)\n\n        result, _ = integrate.quad(integrand, -K_MAX, K_MAX, epsabs=ATOL, epsrel=RTOL)\n        return result\n\n    # --- Test Case Evaluations ---\n    test_cases_params = [\n        # Case 1: baseline, matched drive\n        {'S0': 1.0, 'L_parallel': 4.0, 'kappa0': 3.0, 'Gamma': 0.05},\n        # Case 2: narrow spectrum, misaligned center\n        {'S0': 1.0, 'L_parallel': 12.0, 'kappa0': 3.5, 'Gamma': 0.05},\n        # Case 3: broad spectrum, moderate damping\n        {'S0': 1.0, 'L_parallel': 2.0, 'kappa0': 2.8, 'Gamma': 0.20},\n        # Case 4: reduced drive amplitude, very sharp resonance\n        {'S0': 0.8, 'L_parallel': 8.0, 'kappa0': 3.0, 'Gamma': 0.01},\n    ]\n\n    q_results = []\n    for params in test_cases_params:\n        # Renaming kappa0 from the problem statement text to match code\n        if 'k_0' in params:\n            params['kappa0'] = params.pop('k_0')\n        q_val = calculate_Q_tot(\n            S0=params['S0'],\n            L_parallel=params['L_parallel'],\n            kappa0=params['kappa0'],\n            Omega=OMEGA_COMMON,\n            Gamma=params['Gamma']\n        )\n        q_results.append(q_val)\n    \n    # --- Scaling Diagnostic A ---\n    # Fit Q_tot ~ L_parallel^beta -> log(Q_tot) ~ beta * log(L_parallel)\n    S0_A = 1.0\n    kappa0_A = 3.0\n    Omega_A = 3.0\n    Gamma_A = 0.05\n    L_parallel_values = np.array([2.0, 4.0, 8.0, 16.0])\n\n    Q_tot_A_values = np.array([\n        calculate_Q_tot(S0_A, lp, kappa0_A, Omega_A, Gamma_A)\n        for lp in L_parallel_values\n    ])\n\n    log_Lp = np.log(L_parallel_values)\n    log_Qt = np.log(Q_tot_A_values)\n\n    # Perform linear regression to find the slope beta\n    # polyfit returns [slope, intercept] for degree 1\n    beta, _ = np.polyfit(log_Lp, log_Qt, 1)\n\n    # --- Scaling Diagnostic B ---\n    # Compute ratio R\n    S0_B = 1.0\n    L_parallel_B = 6.0\n    Omega_B = 3.0\n    Gamma_B = 0.05\n\n    # Matched case\n    kappa0_matched = Omega_B\n    q_matched = calculate_Q_tot(S0_B, L_parallel_B, kappa0_matched, Omega_B, Gamma_B)\n\n    # Misaligned case\n    kappa0_misaligned = Omega_B + 0.5\n    q_misaligned = calculate_Q_tot(S0_B, L_parallel_B, kappa0_misaligned, Omega_B, Gamma_B)\n    \n    R = q_matched / q_misaligned\n\n    # --- Final Output Formatting ---\n    all_results = q_results + [beta, R]\n    \n    # Format each result to six decimal places\n    formatted_results = [f\"{val:.6f}\" for val in all_results]\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}