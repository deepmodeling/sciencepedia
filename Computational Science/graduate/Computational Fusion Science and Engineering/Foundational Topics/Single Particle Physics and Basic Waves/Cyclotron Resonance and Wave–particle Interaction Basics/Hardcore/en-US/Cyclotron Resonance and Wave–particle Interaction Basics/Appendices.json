{
    "hands_on_practices": [
        {
            "introduction": "Before we can understand how waves interact with charged particles, we must first master the description of a single particle's baseline motion in a uniform magnetic field. This fundamental exercise involves solving the Lorentz force law, $m d\\mathbf{v}/dt = q \\mathbf{v} \\times \\mathbf{B}$, to derive the classic helical trajectory of a charged particle. By deriving the parametric equations for position and the time-evolution of the gyrophase, you will build an essential analytical foundation for the concept of gyromotion, which underpins all subsequent studies of cyclotron resonance .",
            "id": "3963557",
            "problem": "A charged particle with charge $q$ and mass $m$ moves in a spatially uniform, time-independent magnetic field $\\mathbf{B} = B_{0}\\,\\hat{\\mathbf{z}}$ and zero electric field. At time $t=0$, the particle has position $\\mathbf{r}_{0} = (x_{0}, y_{0}, z_{0})$ and velocity composed of two parts: a component parallel to $\\mathbf{B}$ of magnitude $v_{\\parallel 0}$ and a component perpendicular to $\\mathbf{B}$ of magnitude $v_{\\perp 0}$. The direction of the perpendicular velocity at $t=0$ is specified by the gyrophase angle $\\phi_{0}$, defined as the polar angle of the perpendicular velocity measured from the $+\\hat{\\mathbf{x}}$ axis toward $+\\hat{\\mathbf{y}}$, so that $v_{x}(0) = v_{\\perp 0} \\cos\\phi_{0}$ and $v_{y}(0) = v_{\\perp 0} \\sin\\phi_{0}$, while $v_{z}(0) = v_{\\parallel 0}$.\n\nStarting only from the Lorentz force law $m\\,d\\mathbf{v}/dt = q\\,\\mathbf{v}\\times\\mathbf{B}$ and kinematics $d\\mathbf{r}/dt=\\mathbf{v}$, derive the parametric equations of motion for the particle. Then, explicitly compute the gyrophase $\\phi(t)$ and the particle position components $(x(t), y(t), z(t))$ after an arbitrary time $t$, expressed in terms of $q$, $m$, $B_{0}$, $v_{\\parallel 0}$, $v_{\\perp 0}$, $\\phi_{0}$, $x_{0}$, $y_{0}$, $z_{0}$, and $t$. Treat the sign of $q$ correctly in your derivation.\n\nExpress the final gyrophase in radians. No numerical substitution is required, and no rounding is needed. Report your final answer as a single row listing $\\phi(t)$, $x(t)$, $y(t)$, and $z(t)$, in that order, as a closed-form analytic expression.",
            "solution": "The problem statement is validated as follows.\n\n### Step 1: Extract Givens\n- Charged particle with charge $q$ and mass $m$.\n- Spatially uniform, time-independent magnetic field $\\mathbf{B} = B_{0}\\,\\hat{\\mathbf{z}}$.\n- Zero electric field, $\\mathbf{E} = \\mathbf{0}$.\n- At time $t=0$:\n    - Position: $\\mathbf{r}(0) = \\mathbf{r}_{0} = (x_{0}, y_{0}, z_{0})$.\n    - Velocity component parallel to $\\mathbf{B}$: magnitude $v_{\\parallel 0}$.\n    - Velocity component perpendicular to $\\mathbf{B}$: magnitude $v_{\\perp 0}$.\n    - Gyrophase angle: $\\phi_{0}$.\n    - Initial velocity components: $v_{x}(0) = v_{\\perp 0} \\cos\\phi_{0}$, $v_{y}(0) = v_{\\perp 0} \\sin\\phi_{0}$, $v_{z}(0) = v_{\\parallel 0}$.\n- Governing equations:\n    - Lorentz force law: $m\\,d\\mathbf{v}/dt = q\\,\\mathbf{v}\\times\\mathbf{B}$.\n    - Kinematics: $d\\mathbf{r}/dt=\\mathbf{v}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded (Critical)**: The problem is a cornerstone of classical electromagnetism and plasma physics. It describes the fundamental motion of a charged particle in a uniform magnetic field, a phenomenon known as cyclotron motion or gyromotion. All principles, laws, and conditions are scientifically established.\n- **Well-Posed**: The problem is well-posed. The governing equations are a system of linear, first-order ordinary differential equations with specified initial conditions. A unique and stable solution exists and can be derived analytically.\n- **Objective (Critical)**: The problem is stated using precise, objective, and standard terminology from physics and mathematics. There are no subjective or opinion-based statements.\n- **Completeness and Consistency**: The problem provides all necessary information (charge, mass, field, and complete initial conditions for position and velocity) to solve the equations of motion. There are no contradictions.\n- **Realism**: The conditions described (a charged particle in a uniform magnetic field) are a standard and physically realizable scenario, commonly used as a first approximation in many areas of physics, including fusion energy, astrophysics, and accelerator physics.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a standard, well-posed problem in physics that is scientifically grounded, objective, and complete. A full solution will be provided.\n\n### Derivation of the Solution\nThe motion of the charged particle is governed by the Lorentz force law. With zero electric field, this is:\n$$m \\frac{d\\mathbf{v}}{dt} = q(\\mathbf{v} \\times \\mathbf{B})$$\nThe particle's velocity is $\\mathbf{v} = (v_x, v_y, v_z)$ and the magnetic field is $\\mathbf{B} = (0, 0, B_0)$. The cross product is:\n$$\\mathbf{v} \\times \\mathbf{B} = \\begin{vmatrix} \\hat{\\mathbf{x}}  \\hat{\\mathbf{y}}  \\hat{\\mathbf{z}} \\\\ v_x  v_y  v_z \\\\ 0  0  B_0 \\end{vmatrix} = v_y B_0 \\hat{\\mathbf{x}} - v_x B_0 \\hat{\\mathbf{y}}$$\nSubstituting this into the Lorentz force law and writing it in component form, we obtain a system of three differential equations for the velocity components:\n$$m \\frac{dv_x}{dt} = q v_y B_0$$\n$$m \\frac{dv_y}{dt} = -q v_x B_0$$\n$$m \\frac{dv_z}{dt} = 0$$\nWe define the cyclotron frequency $\\omega_c = \\frac{q B_0}{m}$. This signed frequency's sign depends on the sign of the charge $q$. The equations of motion for the velocity become:\n$$(1) \\quad \\frac{dv_x}{dt} = \\omega_c v_y$$\n$$(2) \\quad \\frac{dv_y}{dt} = -\\omega_c v_x$$\n$$(3) \\quad \\frac{dv_z}{dt} = 0$$\nFrom equation $(3)$, we see that $v_z$ is constant. Using the initial condition $v_z(0) = v_{\\parallel 0}$, we have:\n$$v_z(t) = v_{\\parallel 0}$$\nfor all time $t$.\n\nTo solve for the perpendicular components, we differentiate equation $(1)$ with respect to time and substitute equation $(2)$:\n$$\\frac{d^2v_x}{dt^2} = \\omega_c \\frac{dv_y}{dt} = \\omega_c(-\\omega_c v_x) = -\\omega_c^2 v_x$$\nThis gives the equation for a simple harmonic oscillator:\n$$\\frac{d^2v_x}{dt^2} + \\omega_c^2 v_x = 0$$\nThe general solution for $v_x(t)$ is of the form $v_x(t) = C_1 \\cos(\\omega_c t) + C_2 \\sin(\\omega_c t)$. We can then find $v_y(t)$ from equation $(1)$:\n$$v_y(t) = \\frac{1}{\\omega_c} \\frac{dv_x}{dt} = \\frac{1}{\\omega_c} (-C_1 \\omega_c \\sin(\\omega_c t) + C_2 \\omega_c \\cos(\\omega_c t)) = -C_1 \\sin(\\omega_c t) + C_2 \\cos(\\omega_c t)$$\nNow we apply the initial conditions at $t=0$:\n$$v_x(0) = v_{\\perp 0} \\cos(\\phi_0) = C_1 \\cos(0) + C_2 \\sin(0) = C_1$$\n$$v_y(0) = v_{\\perp 0} \\sin(\\phi_0) = -C_1 \\sin(0) + C_2 \\cos(0) = C_2$$\nSo, the constants are $C_1 = v_{\\perp 0} \\cos(\\phi_0)$ and $C_2 = v_{\\perp 0} \\sin(\\phi_0)$. Substituting these back into the expressions for $v_x(t)$ and $v_y(t)$:\n$$v_x(t) = v_{\\perp 0} \\cos(\\phi_0) \\cos(\\omega_c t) + v_{\\perp 0} \\sin(\\phi_0) \\sin(\\omega_c t)$$\n$$v_y(t) = -v_{\\perp 0} \\cos(\\phi_0) \\sin(\\omega_c t) + v_{\\perp 0} \\sin(\\phi_0) \\cos(\\omega_c t)$$\nUsing the trigonometric angle subtraction identities:\n$$v_x(t) = v_{\\perp 0} \\cos(\\phi_0 - \\omega_c t)$$\n$$v_y(t) = v_{\\perp 0} \\sin(\\phi_0 - \\omega_c t)$$\nThe perpendicular velocity vector is $\\mathbf{v}_\\perp(t) = (v_x(t), v_y(t))$. Its magnitude is $\\sqrt{v_x^2 + v_y^2} = \\sqrt{v_{\\perp 0}^2(\\cos^2(\\dots) + \\sin^2(\\dots))} = v_{\\perp 0}$, which is constant as expected.\n\nThe gyrophase $\\phi(t)$ is defined as the polar angle of the perpendicular velocity. From our solutions for $v_x(t)$ and $v_y(t)$, we can identify the angle directly by comparing with the standard polar form $v_x = v_{\\perp 0} \\cos(\\phi)$ and $v_y = v_{\\perp 0} \\sin(\\phi)$.\n$$\\phi(t) = \\phi_0 - \\omega_c t = \\phi_0 - \\frac{q B_0}{m} t$$\n\nNext, we find the particle's position $\\mathbf{r}(t) = (x(t), y(t), z(t))$ by integrating the velocity components from the initial position $\\mathbf{r}_0 = (x_0, y_0, z_0)$.\nThe $z$-component is:\n$$z(t) = z_0 + \\int_0^t v_z(t') dt' = z_0 + \\int_0^t v_{\\parallel 0} dt' = z_0 + v_{\\parallel 0} t$$\nThe $x$-component is:\n$$x(t) = x_0 + \\int_0^t v_x(t') dt' = x_0 + \\int_0^t v_{\\perp 0} \\cos(\\phi_0 - \\omega_c t') dt'$$\n$$x(t) = x_0 + v_{\\perp 0} \\left[ \\frac{\\sin(\\phi_0 - \\omega_c t')}{-\\omega_c} \\right]_{0}^{t} = x_0 - \\frac{v_{\\perp 0}}{\\omega_c} \\left[ \\sin(\\phi_0 - \\omega_c t) - \\sin(\\phi_0) \\right]$$\n$$x(t) = x_0 + \\frac{v_{\\perp 0}}{\\omega_c} \\left[ \\sin(\\phi_0) - \\sin(\\phi_0 - \\omega_c t) \\right]$$\nThe $y$-component is:\n$$y(t) = y_0 + \\int_0^t v_y(t') dt' = y_0 + \\int_0^t v_{\\perp 0} \\sin(\\phi_0 - \\omega_c t') dt'$$\n$$y(t) = y_0 + v_{\\perp 0} \\left[ \\frac{\\cos(\\phi_0 - \\omega_c t')}{\\omega_c} \\right]_{0}^{t} = y_0 + \\frac{v_{\\perp 0}}{\\omega_c} \\left[ \\cos(\\phi_0 - \\omega_c t) - \\cos(\\phi_0) \\right]$$\n\nFinally, we substitute $\\omega_c = \\frac{q B_0}{m}$ into the expressions for the gyrophase and position to express them in terms of the given parameters.\n$$\\phi(t) = \\phi_0 - \\frac{q B_0 t}{m}$$\n$$x(t) = x_0 + \\frac{m v_{\\perp 0}}{q B_0} \\left( \\sin(\\phi_0) - \\sin\\left(\\phi_0 - \\frac{q B_0 t}{m}\\right) \\right)$$\n$$y(t) = y_0 + \\frac{m v_{\\perp 0}}{q B_0} \\left( \\cos\\left(\\phi_0 - \\frac{q B_0 t}{m}\\right) - \\cos(\\phi_0) \\right)$$\n$$z(t) = z_0 + v_{\\parallel 0} t$$\nThese are the final parametric equations for the particle's gyrophase and position. The motion is helical, composed of uniform motion along the magnetic field and circular motion (gyromotion) in the plane perpendicular to the field.",
            "answer": "$$\\boxed{\\pmatrix{ \\phi_0 - \\frac{q B_0 t}{m}  x_0 + \\frac{m v_{\\perp 0}}{q B_0} \\left( \\sin(\\phi_0) - \\sin\\left(\\phi_0 - \\frac{q B_0 t}{m}\\right) \\right)  y_0 + \\frac{m v_{\\perp 0}}{q B_0} \\left( \\cos\\left(\\phi_0 - \\frac{q B_0 t}{m}\\right) - \\cos(\\phi_0) \\right)  z_0 + v_{\\parallel 0} t }}$$"
        },
        {
            "introduction": "The essence of cyclotron resonance heating lies in the sustained transfer of energy from an electromagnetic wave to a gyrating particle when the wave frequency matches the particle's natural gyration frequency. This practice moves from analytical derivation to computational simulation, challenging you to numerically integrate the equations of motion for a particle subjected to both a static magnetic field and a time-varying radio frequency (RF) electric field. By calculating the time-averaged energy exchange, you will directly observe the conditions for resonance and explore how the interaction depends on crucial parameters like the relative phase between the particle and the wave .",
            "id": "3963539",
            "problem": "Consider a non-relativistic charged test particle moving in a uniform static magnetic field and a prescribed time-harmonic Radio Frequency (RF) electric field. The computational task is to integrate the particle’s equations of motion and extract time-averaged resonant energy exchange rates as a function of RF phase and initial pitch angle. The physical and mathematical setting is defined as follows.\n\nFundamental base:\n- The particle obeys the non-relativistic Lorentz force law, $$m \\frac{d\\mathbf{v}}{dt} = q \\left( \\mathbf{E}(t) + \\mathbf{v} \\times \\mathbf{B} \\right),$$ and kinematics $$\\frac{d\\mathbf{x}}{dt} = \\mathbf{v},$$ where $m$ is the particle mass, $q$ is the particle charge, $\\mathbf{x}$ is the position, and $\\mathbf{v}$ is the velocity.\n- The static magnetic field is uniform and aligned with the $z$-axis, $$\\mathbf{B} = (0, 0, B_0).$$\n- The RF electric field is spatially uniform and linearly polarized along the $x$-axis, $$\\mathbf{E}(t) = \\left(E_0 \\cos(\\omega t + \\phi), 0, 0\\right),$$ where $E_0$ is the electric field amplitude, $\\omega$ is the angular frequency, and $\\phi$ is the phase offset at $t=0$.\n\nDefinitions and parameters:\n- The cyclotron angular frequency is $$\\Omega = \\frac{q B_0}{m}.$$\n- The initial speed is fixed at $$v_0 = 1.0 \\times 10^6 \\text{ m/s}.$$ The initial pitch angle $$\\alpha$$ is the angle between the initial velocity and the magnetic field direction (the $z$-axis). The initial velocity components are set by $$v_{\\parallel}(0) = v_0 \\cos(\\alpha), \\quad v_{\\perp}(0) = v_0 \\sin(\\alpha),$$ with the perpendicular component initially aligned along the $x$-axis so that $$\\mathbf{v}(0) = \\left(v_{\\perp}(0), 0, v_{\\parallel}(0)\\right).$$\n- Use Deuterium ion parameters: $$q = +e = 1.602176634 \\times 10^{-19} \\text{ C},$$ $$m = 3.343583719 \\times 10^{-27} \\text{ kg}.$$ Use a magnetic field magnitude $$B_0 = 2.0 \\text{ T},$$ and an RF electric field amplitude $$E_0 = 5.0 \\times 10^4 \\text{ V/m}.$$\n- For resonant cases, set $$\\omega = \\Omega.$$ For detuned cases, use $$\\omega = \\lambda \\Omega$$ where $$\\lambda$$ is a specified dimensionless detuning factor.\n\nTarget quantity:\n- The instantaneous energy exchange rate (power transferred to the particle) is $$P(t) = q \\, \\mathbf{v}(t) \\cdot \\mathbf{E}(t).$$\n- The required output for each test case is the time-averaged energy exchange rate over the latter half of the simulation interval, computed as $$\\overline{P} = \\frac{1}{T_2 - T_1} \\int_{T_1}^{T_2} P(t) \\, dt,$$ where $$T_1 = \\frac{T_{\\text{end}}}{2}$$ and $$T_2 = T_{\\text{end}}.$$ The averaging suppresses initial transients and isolates steady resonant exchange. Express $$\\overline{P}$$ in watts (J/s) as a floating-point number.\n\nSimulation protocol:\n- Integrate the equations of motion for $$N_{\\text{cyc}} = 120$$ cyclotron periods, where one period is $$T_{\\Omega} = \\frac{2\\pi}{\\Omega}.$$ Therefore, $$T_{\\text{end}} = N_{\\text{cyc}} \\, T_{\\Omega}.$$ Use angles in radians. The problem is strictly non-relativistic; ensure speeds remain well below $$c.$$ The fields are spatially uniform, so spatial dependence of $$\\mathbf{E}$$ is omitted.\n\nTest suite:\nProvide results for the following test cases, covering a “happy path” resonant case, phase sensitivity, pitch-angle extremes, and a detuned edge case:\n1. $$\\phi = 0,$$ $$\\alpha = \\frac{\\pi}{3},$$ $$\\lambda = 1.0$$ (resonant).\n2. $$\\phi = \\frac{\\pi}{2},$$ $$\\alpha = \\frac{\\pi}{3},$$ $$\\lambda = 1.0$$ (resonant, phase-shifted).\n3. $$\\phi = \\frac{\\pi}{3},$$ $$\\alpha = 0,$$ $$\\lambda = 1.0$$ (resonant, zero pitch angle).\n4. $$\\phi = \\pi,$$ $$\\alpha = \\frac{\\pi}{2},$$ $$\\lambda = 1.0$$ (resonant, perpendicular).\n5. $$\\phi = \\frac{\\pi}{4},$$ $$\\alpha = \\frac{\\pi}{3},$$ $$\\lambda = 1.05$$ (slightly detuned).\n\nAlgorithmic requirements:\n- Implement a numerical integrator for the ordinary differential equations defined above.\n- Compute $$P(t)$$ over the time grid and return $$\\overline{P}$$ for each case.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $$[result_1,result_2,result_3,result_4,result_5]$$), where each $$result_i$$ is the floating-point value of $$\\overline{P}$$ in watts for test case $$i$$. No additional text should be printed.",
            "solution": "The problem statement is evaluated to be valid. It is scientifically grounded in the principles of classical electrodynamics, specifically the non-relativistic Lorentz force law. The setup is a canonical problem in plasma physics concerning cyclotron wave-particle interaction. The problem is well-posed, providing a complete set of ordinary differential equations (ODEs), initial conditions, and physical parameters. All terms are defined unambiguously, and the objective is mathematically precise. The given parameters are physically realistic for a magnetically confined fusion plasma environment. The non-relativistic assumption is justified, as the initial velocity $v_0=1.0\\times 10^6 \\text{ m/s}$ corresponds to $v_0/c \\approx 0.0033$, and even with significant energy gain in the resonant cases, the particle velocity remains well below the speed of light, ensuring relativistic effects are negligible. The problem is formalizable, objective, and internally consistent.\n\nThe solution proceeds by numerically integrating the particle's equations of motion and then computing the specified time-averaged quantity.\n\nThe governing equation is the Lorentz force law:\n$$m \\frac{d\\mathbf{v}}{dt} = q \\left( \\mathbf{E}(t) + \\mathbf{v} \\times \\mathbf{B} \\right)$$\nThe magnetic field is $\\mathbf{B} = (0, 0, B_0)$ and the electric field is $\\mathbf{E}(t) = (E_0 \\cos(\\omega t + \\phi), 0, 0)$. Let $\\mathbf{v} = (v_x, v_y, v_z)$. The cross product $\\mathbf{v} \\times \\mathbf{B}$ is:\n$$ \\mathbf{v} \\times \\mathbf{B} = \\begin{vmatrix} \\mathbf{\\hat{i}}  \\mathbf{\\hat{j}}  \\mathbf{\\hat{k}} \\\\ v_x  v_y  v_z \\\\ 0  0  B_0 \\end{vmatrix} = (v_y B_0, -v_x B_0, 0) $$\nSubstituting the fields and the cross product into the Lorentz force equation and separating into components yields the system of ODEs for the velocity components:\n$$ \\frac{dv_x}{dt} = \\frac{q}{m} \\left( E_0 \\cos(\\omega t + \\phi) + v_y B_0 \\right) $$\n$$ \\frac{dv_y}{dt} = \\frac{q}{m} \\left( -v_x B_0 \\right) $$\n$$ \\frac{dv_z}{dt} = 0 $$\nUsing the definition of the cyclotron frequency, $\\Omega = q B_0 / m$, the system simplifies to:\n$$ \\frac{dv_x}{dt} = \\frac{q E_0}{m} \\cos(\\omega t + \\phi) + \\Omega v_y $$\n$$ \\frac{dv_y}{dt} = -\\Omega v_x $$\n$$ \\frac{dv_z}{dt} = 0 $$\nThe equation for the parallel velocity, $v_z$, implies that it is constant: $v_z(t) = v_z(0) = v_0 \\cos(\\alpha)$. The perpendicular velocity components, $v_x$ and $v_y$, form a coupled, linear, first-order system with a time-dependent driving term. This system constitutes an initial value problem (IVP) that must be solved numerically.\n\nThe initial conditions for the velocity at $t=0$ are derived from the given initial speed $v_0$ and pitch angle $\\alpha$:\n$$ \\mathbf{v}(0) = (v_0 \\sin(\\alpha), 0, v_0 \\cos(\\alpha)) $$\nEach test case provides specific values for the phase offset $\\phi$, pitch angle $\\alpha$, and detuning factor $\\lambda$, where the RF frequency is $\\omega = \\lambda \\Omega$.\n\nThe numerical solution is obtained using a robust IVP solver. The `scipy.integrate.solve_ivp` function from the SciPy library is ideally suited for this task. It implements high-order adaptive-step methods (such as Runge-Kutta-Fehlberg, `RK45`) that ensure accuracy and efficiency. We configure the solver to produce a dense output, which provides a continuous representation of the solution via interpolation. This is crucial for accurately computing the integral of the power over a specific interval.\n\nThe instantaneous power transferred from the electric field to the particle is given by $P(t) = q \\mathbf{v}(t) \\cdot \\mathbf{E}(t)$. Since $\\mathbf{E}(t)$ has only an $x$-component, this simplifies to:\n$$ P(t) = q v_x(t) E_x(t) = q v_x(t) E_0 \\cos(\\omega t + \\phi) $$\nThe target quantity is the time-averaged power, $\\overline{P}$, over the latter half of the total simulation time, $T_{\\text{end}} = N_{\\text{cyc}} T_{\\Omega}$, where $T_{\\Omega} = 2\\pi/\\Omega$:\n$$ \\overline{P} = \\frac{1}{T_2 - T_1} \\int_{T_1}^{T_2} P(t) \\, dt $$\nwith $T_1 = T_{\\text{end}}/2$ and $T_2 = T_{\\text{end}}$.\n\nThe computational procedure for each test case is as follows:\n1.  Define the physical constants $q, m, B_0, E_0$, and the simulation parameters $v_0, N_{\\text{cyc}}$.\n2.  Calculate the derived constants $\\Omega$ and $T_{\\text{end}}$.\n3.  For each test case $(\\phi, \\alpha, \\lambda)$, set up the specific RF frequency $\\omega = \\lambda \\Omega$ and initial velocity vector $\\mathbf{v}(0)$.\n4.  Define a function representing the system of ODEs for $(v_x, v_y, v_z)$.\n5.  Call `scipy.integrate.solve_ivp` to solve the ODEs from $t=0$ to $t=T_{\\text{end}}$, requesting dense output.\n6.  Define a function for the instantaneous power, $P(t)$, which uses the dense solution from the solver to find $v_x(t)$ at any given time $t$.\n7.  Use a numerical quadrature function, `scipy.integrate.quad`, to compute the definite integral of $P(t)$ from $T_1 = T_{\\text{end}}/2$ to $T_2 = T_{\\text{end}}$. This method is highly accurate as it adaptively refines the integration subintervals.\n8.  Divide the integral by the duration of the interval, $(T_2 - T_1)$, to obtain the average power $\\overline{P}$.\n9.  Collect the results for all test cases and format them as specified.\n\nThis methodology provides a rigorous and accurate solution to the posed problem, respecting the principles of both physics and numerical analysis.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp, quad\n\ndef solve():\n    \"\"\"\n    Solves for the time-averaged resonant energy exchange rate for a charged particle\n    in uniform magnetic and time-harmonic electric fields.\n    \"\"\"\n    # Define physical and simulation constants\n    Q = 1.602176634e-19  # Charge of Deuterium ion (C)\n    M = 3.343583719e-27  # Mass of Deuterium ion (kg)\n    B0 = 2.0             # Magnetic field magnitude (T)\n    E0 = 5.0e4           # Electric field amplitude (V/m)\n    V0 = 1.0e6           # Initial speed (m/s)\n    N_CYC = 120.0        # Number of cyclotron periods for simulation\n\n    # Calculate derived constants\n    OMEGA = Q * B0 / M          # Cyclotron angular frequency (rad/s)\n    T_OMEGA = 2.0 * np.pi / OMEGA # Cyclotron period (s)\n    T_END = N_CYC * T_OMEGA     # Total simulation time (s)\n    T1 = T_END / 2.0            # Start time for averaging (s)\n    T2 = T_END                  # End time for averaging (s)\n\n    # Define the test suite\n    test_cases = [\n        # case 1: phi=0, alpha=pi/3, lambda=1.0\n        {'phi': 0.0, 'alpha': np.pi / 3.0, 'lambda_': 1.0},\n        # case 2: phi=pi/2, alpha=pi/3, lambda=1.0\n        {'phi': np.pi / 2.0, 'alpha': np.pi / 3.0, 'lambda_': 1.0},\n        # case 3: phi=pi/3, alpha=0, lambda=1.0\n        {'phi': np.pi / 3.0, 'alpha': 0.0, 'lambda_': 1.0},\n        # case 4: phi=pi, alpha=pi/2, lambda=1.0\n        {'phi': np.pi, 'alpha': np.pi / 2.0, 'lambda_': 1.0},\n        # case 5: phi=pi/4, alpha=pi/3, lambda=1.05\n        {'phi': np.pi / 4.0, 'alpha': np.pi / 3.0, 'lambda_': 1.05},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        phi = case['phi']\n        alpha = case['alpha']\n        lambda_ = case['lambda_']\n\n        omega = lambda_ * OMEGA  # RF angular frequency\n\n        # Set initial velocity components\n        v_perp_0 = V0 * np.sin(alpha)\n        v_para_0 = V0 * np.cos(alpha)\n        v0_vec = np.array([v_perp_0, 0.0, v_para_0])\n\n        # Define the ODE system for the Lorentz force\n        def lorentz_force(t, v):\n            vx, vy, vz = v\n            # dv_x/dt = (q*E_0/m)*cos(omega*t+phi) + Omega*v_y\n            dvx_dt = (Q * E0 / M) * np.cos(omega * t + phi) + OMEGA * vy\n            # dv_y/dt = -Omega*v_x\n            dvy_dt = -OMEGA * vx\n            # dv_z/dt = 0\n            dvz_dt = 0.0\n            return np.array([dvx_dt, dvy_dt, dvz_dt])\n\n        # Numerically integrate the equations of motion\n        sol = solve_ivp(\n            lorentz_force,\n            [0, T_END],\n            v0_vec,\n            method='RK45',      # Standard adaptive Runge-Kutta method\n            dense_output=True,  # Enable continuous solution\n            rtol=1e-8,          # Relative tolerance for accuracy\n            atol=1e-10          # Absolute tolerance for accuracy\n        )\n\n        # Define the instantaneous power function using the interpolated solution\n        def power_func(t):\n            # v_x(t) is the first component of the solution vector\n            vx_t = sol.sol(t)[0]\n            # P(t) = q * v_x(t) * E_x(t)\n            return Q * vx_t * (E0 * np.cos(omega * t + phi))\n\n        # Integrate P(t) from T1 to T2 using adaptive quadrature\n        integral_P, _ = quad(power_func, T1, T2)\n\n        # Calculate the time-averaged power\n        avg_power = integral_P / (T2 - T1)\n        results.append(avg_power)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Realistic plasma simulations involve not one, but billions of particles, which are represented by a finite number of 'macro-particles' in a computational model. This discreteness introduces numerical artifacts, such as 'shot noise' and artificial heating, that can obscure the physical processes we aim to study. This advanced exercise challenges you to build a simulation of a particle ensemble and implement models for numerical noise, using the industry-standard Boris pusher algorithm. You will investigate the effectiveness of mitigation techniques like quiet-start initializations and current smoothing, gaining critical insight into the practical challenges and best practices of computational plasma physics .",
            "id": "3963448",
            "problem": "You are asked to design and implement a minimal, self-consistent computational experiment to evaluate how numerical heating and discrete-particle noise affect cyclotron resonance studies, and to quantify the mitigation offered by quiet-start initialization and current smoothing. Your program must simulate an ensemble of electrons interacting with a uniform magnetic field and a transverse, circularly polarized wave electric field. The focus is on the basic wave–particle interaction dynamics and the influence of numerical noise models, suitable for studies in computational fusion science and engineering.\n\nStart from the fundamental Lorentz force law for a particle of charge $q$ and mass $m$ in electric and magnetic fields,\n$$\n\\frac{d\\mathbf{p}}{dt} = q\\left(\\mathbf{E} + \\mathbf{v}\\times \\mathbf{B}\\right), \\quad \\mathbf{p} = m\\mathbf{v},\n$$\nwhere $\\mathbf{v}$ is velocity and $\\mathbf{p}$ is momentum. Consider electrons with $q = -e$ and $m = m_e$ in a uniform magnetic field $\\mathbf{B} = B_0 \\hat{\\mathbf{z}}$. Define the electron cyclotron frequency as\n$$\n\\Omega_c = \\frac{|q|B_0}{m}.\n$$\nImpose a transverse, right-hand circularly polarized, spatially uniform wave electric field\n$$\n\\mathbf{E}_\\mathrm{w}(t) = E_0\\left[\\cos(\\omega t)\\,\\hat{\\mathbf{x}} - \\sin(\\omega t)\\,\\hat{\\mathbf{y}}\\right],\n$$\nwith drive frequency $\\omega$ chosen relative to $\\Omega_c$ as specified per test case. Assume a ring distribution for initial velocities $|\\mathbf{v}_i(0)| = v_0$ confined to the perpendicular plane, with gyrophases either random or evenly spaced (quiet-start) to study the impact of discrete-particle noise.\n\nModel discrete-particle current noise without solving Maxwell’s equations by a proxy electric field term $\\mathbf{E}_\\mathrm{n}(t)$ constructed from the instantaneous mean current and the first-harmonic coherence of the ensemble’s gyrophases:\n- Compute the mean current density,\n$$\n\\mathbf{J}(t) = n q \\langle \\mathbf{v}(t)\\rangle,\n$$\nwhere $n$ is the electron number density and $\\langle \\cdot \\rangle$ denotes the ensemble mean over macro-particles.\n- Define a deterministic noise proxy field proportional to $\\mathbf{J}(t)$,\n$$\n\\mathbf{E}_{\\mathrm{n,det}}(t) = \\alpha_\\mathrm{det}\\, \\mathbf{J}(t),\n$$\nwith dimensioned coefficient $\\alpha_\\mathrm{det}$ (units of ohms-meters) representing a simplified field solver response to deposited current.\n- Define a stochastic noise field whose amplitude scales with the first azimuthal harmonic of the gyrophase distribution,\n$$\nc_1(t) = \\left|\\frac{1}{N}\\sum_{i=1}^{N} e^{\\mathrm{i}\\theta_i(t)}\\right|,\\quad \\theta_i(t) = \\mathrm{atan2}(v_{y,i}(t), v_{x,i}(t)),\n$$\nand set\n$$\n\\mathbf{E}_{\\mathrm{n,stoch}}(t) \\sim \\mathcal{N}\\left(\\mathbf{0},\\, \\sigma_E^2(t)\\, \\mathbf{I}_{2\\times2}\\right),\\quad \\sigma_E(t) = \\alpha_\\mathrm{stoch}\\, n |q| v_0\\, c_1(t),\n$$\nwith $\\mathbf{I}_{2\\times2}$ the identity on the perpendicular plane, and $\\mathcal{N}$ indicating a zero-mean Gaussian with the given standard deviation and independent components in the $\\hat{\\mathbf{x}}$ and $\\hat{\\mathbf{y}}$ directions.\n- Apply temporal current smoothing as an exponential low-pass filter on the total noise field,\n$$\n\\mathbf{E}_{\\mathrm{n, filt}}(t_{k}) = (1-\\beta)\\,\\mathbf{E}_{\\mathrm{n, filt}}(t_{k-1}) + \\beta\\,\\big(\\mathbf{E}_{\\mathrm{n,det}}(t_{k}) + \\mathbf{E}_{\\mathrm{n,stoch}}(t_{k})\\big),\n$$\nwhere $\\beta \\in (0,1]$ is the smoothing gain (with $\\beta=1$ corresponding to no smoothing).\n\nEvolve the particle velocities using an energy-conserving Boris pusher under the total field\n$$\n\\mathbf{E}_\\mathrm{tot}(t) = \\mathbf{E}_\\mathrm{w}(t) + \\mathbf{E}_{\\mathrm{n, filt}}(t),\n$$\nand constant $\\mathbf{B} = B_0 \\hat{\\mathbf{z}}$. Track the mean kinetic energy per particle\n$$\n\\langle \\mathcal{E}_\\mathrm{K}(t)\\rangle = \\left\\langle \\frac{1}{2} m |\\mathbf{v}(t)|^2 \\right\\rangle,\n$$\nand report the mean energy gain $\\Delta \\langle \\mathcal{E}_\\mathrm{K}\\rangle$ from start to end.\n\nYour implementation must:\n- Use $q = -e$, $m = m_e$, and $B_0$ as specified.\n- Use a ring distribution $|\\mathbf{v}_i(0)| = v_0$ with either random gyrophases (random-start) or evenly spaced gyrophases (quiet-start).\n- Use the Boris pusher for velocity updates and the above noise model and smoothing rule.\n- Treat the wave as spatially uniform and the plasma as homogeneous with given number density $n$.\n\nPhysical constants and parameters for all test cases:\n- Elementary charge $e = 1.602\\,176\\,634\\times 10^{-19}\\,\\mathrm{C}$.\n- Electron mass $m_e = 9.109\\,383\\,7015\\times 10^{-31}\\,\\mathrm{kg}$.\n- Magnetic field amplitude $B_0 = 2.0\\,\\mathrm{T}$.\n- Electron number density $n = 1.0\\times 10^{16}\\,\\mathrm{m}^{-3}$.\n- Ring speed $v_0 = 1.0\\times 10^{5}\\,\\mathrm{m/s}$.\n- Time step $\\Delta t = 5.0\\times 10^{-13}\\,\\mathrm{s}$.\n- Total simulation time $T = 1.0\\times 10^{-9}\\,\\mathrm{s}$.\n- Deterministic noise coefficient $\\alpha_\\mathrm{det} = 5.0\\times 10^{-4}\\,\\Omega \\cdot \\mathrm{m}$.\n- Stochastic noise coefficient $\\alpha_\\mathrm{stoch} = 5.0\\times 10^{-4}\\,\\Omega \\cdot \\mathrm{m}$.\n- Use $\\omega = \\Omega_c$ for resonant cases unless otherwise specified.\n- Electrons are non-relativistic in this setup.\n\nTest suite of parameter sets (each test case is a tuple of $(N, \\text{quiet}, \\beta, E_0, \\text{wave\\_mode})$):\n1. $(200, \\text{False}, 1.0, 1.0, \\text{\"resonant\"})$ — random-start, no smoothing, resonant drive.\n2. $(200, \\text{True}, 1.0, 1.0, \\text{\"resonant\"})$ — quiet-start, no smoothing, resonant drive.\n3. $(200, \\text{False}, 0.3, 1.0, \\text{\"resonant\"})$ — random-start, smoothed current, resonant drive.\n4. $(3000, \\text{False}, 1.0, 1.0, \\text{\"resonant\"})$ — random-start, no smoothing, resonant drive, many particles (reduced shot noise).\n5. $(200, \\text{False}, 1.0, 0.0, \\text{\"none\"})$ — random-start, no smoothing, no wave field (pure numerical heating baseline).\n\nRequired outputs:\n- For each test case, compute the mean energy gain per particle $\\Delta \\langle \\mathcal{E}_\\mathrm{K}\\rangle$ over the simulation duration and express it in electronvolts (eV) as a floating-point number. Use radians for any angle computations.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases above (for example, $[\\text{case1},\\text{case2},\\ldots]$).",
            "solution": "The user-provided problem has been analyzed against the specified validation criteria. The problem is deemed **valid**. It describes a self-contained, scientifically grounded computational experiment in plasma physics. The physical principles (Lorentz force, cyclotron resonance) are sound, and the numerical methods (Boris pusher, quiet-start) are standard in the field. The provided parameters are physically and computationally feasible.\n\nA minor descriptive flaw was identified: the units provided for the noise coefficients $\\alpha_\\mathrm{det}$ and $\\alpha_\\mathrm{stoch}$ are given as Ohms ($\\Omega$), which is dimensionally inconsistent with the equations. The correct units should be Ohm-meters ($\\Omega \\cdot \\text{m}$). However, since the problem is a computational experiment with a proxy model and provides explicit numerical values for these coefficients, this descriptive error does not prevent a unique and correct implementation of the specified algorithm. We shall proceed by using the given numerical values, assuming they are in the correct, consistent units.\n\nThe solution is designed as a computational simulation that evolves an ensemble of electrons under the influence of prescribed electromagnetic fields and a self-generated noise field proxy. The goal is to measure the change in the ensemble's mean kinetic energy.\n\n**1. Fundamental Principles: The Equation of Motion**\n\nThe motion of each electron, a particle with charge $q = -e$ and mass $m = m_e$, is governed by the non-relativistic Lorentz force law:\n$$\n\\frac{d\\mathbf{v}}{dt} = \\frac{q}{m} \\left( \\mathbf{E}_\\mathrm{tot}(t) + \\mathbf{v} \\times \\mathbf{B} \\right)\n$$\nThe static magnetic field is uniform and directed along the $\\hat{\\mathbf{z}}$-axis, $\\mathbf{B} = B_0 \\hat{\\mathbf{z}}$. In such a field, an electron gyrates in the plane perpendicular to $\\mathbf{B}$ with the electron cyclotron frequency, defined as:\n$$\n\\Omega_c = \\frac{|q|B_0}{m} = \\frac{e B_0}{m_e}\n$$\n\n**2. Electromagnetic Fields**\n\nThe total electric field $\\mathbf{E}_\\mathrm{tot}(t)$ is the sum of an external wave field and a self-generated noise field:\n$$\n\\mathbf{E}_\\mathrm{tot}(t) = \\mathbf{E}_\\mathrm{w}(t) + \\mathbf{E}_{\\mathrm{n, filt}}(t)\n$$\n\nThe external wave is a transverse, right-hand circularly polarized electric field, spatially uniform:\n$$\n\\mathbf{E}_\\mathrm{w}(t) = E_0\\left[\\cos(\\omega t)\\,\\hat{\\mathbf{x}} - \\sin(\\omega t)\\,\\hat{\\mathbf{y}}\\right]\n$$\nThe wave frequency $\\omega$ is set to $\\Omega_c$ for resonant interaction, which leads to sustained energy exchange between the wave and the electrons.\n\nThe noise field $\\mathbf{E}_{\\mathrm{n, filt}}(t)$ is a proxy for fields generated by the discrete nature of the plasma current, and it incorporates temporal smoothing. Its calculation is detailed in Section 4.\n\n**3. Numerical Integration: The Boris Algorithm**\n\nTo numerically integrate the equations of motion over time, we employ the Boris algorithm. This is a second-order accurate, explicit leapfrog integrator known for its excellent long-term energy and momentum conserving properties in magnetostatic fields. The algorithm updates particle velocities from a half-time step $t_{k-1/2} = (k-1/2)\\Delta t$ to the next half-time step $t_{k+1/2} = (k+1/2)\\Delta t$, using fields evaluated at the integer time step $t_k = k\\Delta t$.\n\nFor a particle with velocity $\\mathbf{v}_{k-1/2}$ at time $t_{k-1/2}$, the update to $\\mathbf{v}_{k+1/2}$ proceeds in three steps:\n1.  **First Electric Half-Push**: An initial acceleration due to the electric field $\\mathbf{E}_k = \\mathbf{E}_\\mathrm{tot}(t_k)$.\n    $$\n    \\mathbf{v}^- = \\mathbf{v}_{k-1/2} + \\frac{q \\mathbf{E}_k}{m} \\frac{\\Delta t}{2}\n    $$\n2.  **Magnetic Rotation**: The core of the algorithm, which performs a pure rotation of the velocity vector around the magnetic field lines.\n    $$\n    \\mathbf{t} = \\frac{q \\mathbf{B}}{m} \\frac{\\Delta t}{2}\n    $$\n    $$\n    \\mathbf{s} = \\frac{2\\mathbf{t}}{1 + |\\mathbf{t}|^2}\n    $$\n    $$\n    \\mathbf{v}' = \\mathbf{v}^- + \\mathbf{v}^- \\times \\mathbf{t}\n    $$\n    $$\n    \\mathbf{v}^+ = \\mathbf{v}^- + \\mathbf{v}' \\times \\mathbf{s}\n    $$\n3.  **Second Electric Half-Push**: A final acceleration due to the electric field.\n    $$\n    \\mathbf{v}_{k+1/2} = \\mathbf{v}^+ + \\frac{q \\mathbf{E}_k}{m} \\frac{\\Delta t}{2}\n    $$\nSince the problem only involves velocity evolution, the position update step is omitted.\n\n**4. Initial Conditions**\n\nThe simulation starts with an ensemble of $N$ electrons. Their initial velocities are set according to a ring distribution in the plane perpendicular to $\\mathbf{B}$, with speed $|\\mathbf{v}_i(0)| = v_0$ for all particles $i=1, \\dots, N$. The initial gyrophases $\\phi_i(0)$ are distributed either randomly or uniformly, representing different levels of initial numerical noise.\n- **Random-Start**: $\\phi_i(0)$ is drawn from a uniform distribution $\\mathcal{U}[0, 2\\pi)$. This mimics the shot noise of a randomly loaded particle ensemble.\n- **Quiet-Start**: $\\phi_i(0) = \\frac{2\\pi (i-1)}{N}$. This deterministic, evenly spaced distribution minimizes initial discrete particle noise by ensuring that low-order moments of the distribution function are close to zero.\n\nThe initial velocity for particle $i$ is thus:\n$$\n\\mathbf{v}_i(0) = (v_0\\cos(\\phi_i(0)), v_0\\sin(\\phi_i(0)), 0)\n$$\nThe leapfrog scheme requires velocities at $t_{-1/2} = -\\Delta t/2$. We initialize the scheme by setting $\\mathbf{v}_{i, -1/2} = \\mathbf{v}_i(0)$, a common and simple approach which introduces a small, first-order error in the first time step that is negligible over the full simulation.\n\n**5. Noise and Smoothing Model**\n\nThe noise field is computed at each integer time step $t_k$ based on the state of the particle ensemble at the preceding half-time step, $t_{k-1/2}$. This staggered evaluation is standard in particle-in-cell codes.\n\nFirst, the unfiltered noise field is constructed from a deterministic and a stochastic component:\n- **Deterministic Noise**: Proportional to the mean perpendicular current density $\\mathbf{J}(t_k) = n q \\langle \\mathbf{v}_{k-1/2} \\rangle$.\n$$\n\\mathbf{E}_{\\mathrm{n,det}}(t_k) = \\alpha_\\mathrm{det}\\, n q \\langle \\mathbf{v}_{k-1/2} \\rangle\n$$\n- **Stochastic Noise**: A random field whose magnitude depends on the phase coherence of the electrons. The first-harmonic gyrophase coherence $c_1$ is calculated as:\n$$\nc_1(t_k) = \\left|\\frac{1}{N}\\sum_{i=1}^{N} e^{\\mathrm{i}\\theta_i(t_k)}\\right|, \\quad \\text{where } \\theta_i(t_k) = \\mathrm{atan2}(v_{y,i}(t_{k-1/2}), v_{x,i}(t_{k-1/2}))\n$$\nThe standard deviation of the stochastic field components is then:\n$$\n\\sigma_E(t_k) = \\alpha_\\mathrm{stoch}\\, n |q| v_0\\, c_1(t_k)\n$$\nAnd the field itself is drawn from a 2D Gaussian distribution:\n$$\n\\mathbf{E}_{\\mathrm{n,stoch}}(t_k) \\sim \\mathcal{N}\\left(\\mathbf{0},\\, \\sigma_E^2(t_k)\\, \\mathbf{I}_{2\\times2}\\right)\n$$\nThe total raw noise field is $\\mathbf{E}_{\\mathrm{n,raw}}(t_k) = \\mathbf{E}_{\\mathrm{n,det}}(t_k) + \\mathbf{E}_{\\mathrm{n,stoch}}(t_k)$.\n\nThis raw field is then temporally smoothed using an exponential low-pass filter to model the finite response time of a more realistic field solver:\n$$\n\\mathbf{E}_{\\mathrm{n, filt}}(t_{k}) = (1-\\beta)\\,\\mathbf{E}_{\\mathrm{n, filt}}(t_{k-1}) + \\beta\\,\\mathbf{E}_{\\mathrm{n,raw}}(t_{k})\n$$\nwhere $\\beta \\in (0,1]$ is the smoothing gain. The filter is initialized with $\\mathbf{E}_{\\mathrm{n, filt}}(t_{-1}) = \\mathbf{0}$.\n\n**6. Calculation of Energy Gain**\n\nThe primary diagnostic is the mean kinetic energy gain per particle, $\\Delta \\langle \\mathcal{E}_\\mathrm{K}\\rangle$. The initial mean kinetic energy is trivial:\n$$\n\\langle \\mathcal{E}_\\mathrm{K}(0) \\rangle = \\frac{1}{N} \\sum_{i=1}^N \\frac{1}{2}m_e |\\mathbf{v}_i(0)|^2 = \\frac{1}{2} m_e v_0^2\n$$\nThe final mean kinetic energy is computed after the last time step, $t_F = T = N_{steps}\\Delta t$. We approximate the final velocity $\\mathbf{v}_i(T)$ with the velocity at the last half-step, $\\mathbf{v}_{i, N_{steps}-1/2}$:\n$$\n\\langle \\mathcal{E}_\\mathrm{K}(T) \\rangle \\approx \\left\\langle \\frac{1}{2} m_e |\\mathbf{v}_{N_{steps}-1/2}|^2 \\right\\rangle = \\frac{1}{N} \\sum_{i=1}^N \\left( \\frac{1}{2}m_e |\\mathbf{v}_{i, N_{steps}-1/2}|^2 \\right)\n$$\nThe energy gain in Joules is $\\Delta \\langle \\mathcal{E}_\\mathrm{K}\\rangle = \\langle \\mathcal{E}_\\mathrm{K}(T) \\rangle - \\langle \\mathcal{E}_\\mathrm{K}(0) \\rangle$. This value is then converted to electronvolts (eV) by dividing by the elementary charge $e$:\n$$\n\\Delta \\langle \\mathcal{E}_\\mathrm{K}\\rangle \\text{[eV]} = \\frac{\\Delta \\langle \\mathcal{E}_\\mathrm{K}\\rangle \\text{[J]}}{e}\n$$\nThis procedure is repeated for each of the five test cases defined in the problem statement to quantify the impact of quiet-start initialization, current smoothing, particle count, and the presence of the resonant wave.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, quiet, beta, E0, wave_mode):\n    \"\"\"\n    Simulates an ensemble of electrons under cyclotron resonance conditions.\n\n    Args:\n        N (int): Number of macro-particles.\n        quiet (bool): True for quiet-start, False for random-start.\n        beta (float): Smoothing gain for the noise filter.\n        E0 (float): Amplitude of the wave electric field (V/m).\n        wave_mode (str): \"resonant\" or \"none\".\n\n    Returns:\n        float: The mean energy gain per particle in electronvolts (eV).\n    \"\"\"\n    # Physical constants and simulation parameters\n    E_CHARGE = 1.602176634e-19\n    M_ELECTRON = 9.1093837015e-31\n    B0 = 2.0\n    N_DENSITY = 1.0e16\n    V0 = 1.0e5\n    DT = 5.0e-13\n    T_TOTAL = 1.0e-9\n    ALPHA_DET = 5.0e-4\n    ALPHA_STOCH = 5.0e-4\n\n    # Derived constants\n    q = -E_CHARGE\n    m = M_ELECTRON\n    q_over_m = q / m\n    Omega_c = np.abs(q) * B0 / m\n    omega = Omega_c if wave_mode == \"resonant\" else 0.0\n\n    # Initialize particle velocities\n    # Using a fixed seed for reproducibility of the random components.\n    rng = np.random.default_rng(seed=12345)\n    \n    v = np.zeros((N, 3))\n    if quiet:\n        phases = 2 * np.pi * np.arange(N) / N\n    else:\n        phases = rng.uniform(0, 2 * np.pi, N)\n    \n    v[:, 0] = V0 * np.cos(phases)\n    v[:, 1] = V0 * np.sin(phases)\n    \n    initial_mean_ke = 0.5 * m * V0**2\n\n    # Simulation setup\n    num_steps = int(T_TOTAL / DT)\n    E_n_filt = np.zeros(2)\n    v_half = v.copy() \n\n    # Main simulation loop\n    for k in range(num_steps):\n        t = k * DT\n        \n        # Calculate E field at integer time step t_k\n        # 1. External wave field\n        E_wave_k = np.array([E0 * np.cos(omega * t), -E0 * np.sin(omega * t)])\n\n        # 2. Noise proxy fields (using v at t_{k-1/2})\n        mean_v_perp = np.mean(v_half[:, :2], axis=0)\n        J_k = N_DENSITY * q * mean_v_perp\n        E_n_det_k = ALPHA_DET * J_k\n\n        thetas_k = np.arctan2(v_half[:, 1], v_half[:, 0])\n        c1_k = np.abs(np.mean(np.exp(1j * thetas_k)))\n        sigma_E_k = ALPHA_STOCH * N_DENSITY * np.abs(q) * V0 * c1_k\n        E_n_stoch_k = rng.normal(0.0, sigma_E_k, 2)\n        \n        E_n_raw_k = E_n_det_k + E_n_stoch_k\n        E_n_filt = (1 - beta) * E_n_filt + beta * E_n_raw_k\n        \n        E_total_k = E_wave_k + E_n_filt\n        \n        # Boris Pusher for perpendicular velocity\n        # First E-half-push\n        v_minus = v_half[:, :2] + (q_over_m * E_total_k * DT / 2.0)\n        \n        # B-rotation\n        t_z = q_over_m * B0 * DT / 2.0\n        s_z = 2.0 * t_z / (1.0 + t_z**2)\n        \n        v_prime_x = v_minus[:, 0] + v_minus[:, 1] * t_z\n        v_prime_y = v_minus[:, 1] - v_minus[:, 0] * t_z\n        \n        v_plus_x = v_minus[:, 0] + v_prime_y * s_z\n        v_plus_y = v_minus[:, 1] - v_prime_x * s_z\n\n        v_plus = np.column_stack((v_plus_x, v_plus_y))\n        \n        # Second E-half-push\n        v_half_next = v_plus + (q_over_m * E_total_k * DT / 2.0)\n        \n        v_half[:, :2] = v_half_next\n\n    # Calculate final energy gain\n    # Use final half-step velocity as approximation for v(T)\n    final_v_sq = np.sum(v_half**2, axis=1)\n    final_mean_ke = 0.5 * m * np.mean(final_v_sq)\n    \n    delta_ke_joules = final_mean_ke - initial_mean_ke\n    delta_ke_ev = delta_ke_joules / E_CHARGE\n    \n    return delta_ke_ev\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite: (N, quiet, beta, E0, wave_mode)\n    test_cases = [\n        (200, False, 1.0, 1.0, \"resonant\"),\n        (200, True, 1.0, 1.0, \"resonant\"),\n        (200, False, 0.3, 1.0, \"resonant\"),\n        (3000, False, 1.0, 1.0, \"resonant\"),\n        (200, False, 1.0, 0.0, \"none\"),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(*params)\n        results.append(result)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}