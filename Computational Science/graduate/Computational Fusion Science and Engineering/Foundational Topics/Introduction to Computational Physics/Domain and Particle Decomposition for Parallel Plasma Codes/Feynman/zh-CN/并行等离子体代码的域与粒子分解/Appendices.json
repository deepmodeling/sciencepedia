{
    "hands_on_practices": [
        {
            "introduction": "在并行的网格模拟中，区域分解是一种主要的并行策略。然而，这种划分引入了通信的需求，因为一个子区域边缘的计算需要其相邻区域的数据。本练习将引导你对这种通信开销进行基础分析，通过计算必须交换的“晕圈”(halo)数据的大小，为理解并行可扩展性提供一个定量的基础 。",
            "id": "3968570",
            "problem": "一个在计算聚变科学中使用的三维时域有限差分(FDTD)麦克斯韦求解器，在大小为 $N_x \\times N_y \\times N_z$ 的结构化网格上推进电磁场。其并行化使用三维块状（笛卡尔）区域分解，包含 $P_x \\times P_y \\times P_z$ 个进程，因此每个进程拥有一个内部尺寸为 $n_x \\times n_y \\times n_z$ 的矩形子域，其中 $n_x = N_x / P_x$，$n_y = N_y / P_y$，$n_z = N_z / P_z$。在所有三个方向上都施加了周期性边界条件，并且所有进程在拓扑上都是等价的。为了使用一个各向同性模板计算一次场更新，该模板在 $x$、$y$ 和 $z$ 方向上各需要半径为 $h$ 个单元的数据，代码会执行一次单阶段的 halo 交换，通过向所有 $26$ 个邻居发送不相交的面、边和角子块，来完全填充一个 $h$ 个单元厚的 ghost 层。\n\n假设每个网格单元存储 $s$ 个实值状态变量，每个变量均为双精度（每个变量 $8$ 字节）。忽略所有消息头、填充和网络协议开销。仅使用由模板局部性和区域分解所蕴含的几何计数基本原理，推导单个进程在一次足以将场推进一个时间步长的单阶段 halo 交换中所产生的总出站消息量（以字节为单位）。\n\n请用 $N_x$、$N_y$、$N_z$、$P_x$、$P_y$、$P_z$、$h$ 和 $s$ 表示您的最终答案，形式为一个单一的闭式表达式。以字节为单位表示最终的体积。不要简化为数值。不要在最终的方框答案中包含单位。",
            "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据、问题明确、客观且内部一致，描述了并行科学计算中的一个标准场景。\n\n目标是推导单个进程在一次 halo 交换步骤中产生的总出站消息量（以字节为单位）的闭式表达式。该问题涉及用于有限差分求解器的三维区域分解。\n\n每个进程负责一个尺寸为 $n_x \\times n_y \\times n_z$ 的内部网格单元的矩形子域。该子域的维度由下式给出：\n$$n_x = \\frac{N_x}{P_x}$$\n$$n_y = \\frac{N_y}{P_y}$$\n$$n_z = \\frac{N_z}{P_z}$$\n其中 $N_x, N_y, N_z$ 是全局网格的维度，$P_x, P_y, P_z$ 是进程网格的维度。\n\n计算模板需要来自邻近单元（半径最大为 $h$）的数据。这意味着，一个进程要更新其内部域边界上的场值，就需要来自其邻居的数据。这些来自邻近进程所需的数据存储在一个环绕该进程内部域的“ghost 层”或“halo”区域中。该 halo 被指定为在每个方向上都有 $h$ 个单元的厚度。\n\n由于周期性边界条件以及所有进程在拓扑上等价的陈述，系统是对称的。因此，一个进程*发送*给其邻居的总数据量等于它从邻居那里*接收*以填充其自身 ghost 层的总数据量。因此，我们可以计算填充单个进程的 ghost 层所需的数据量。\n\n一个进程的内部域体积为 $V_{interior} = n_x n_y n_z$ 个单元。\n一个进程的逻辑网格，包括其在所有侧面（即在 $x$、$y$ 和 $z$ 方向上的正负面）厚度为 $h$ 的 ghost 层，其维度为 $(n_x + 2h) \\times (n_y + 2h) \\times (n_z + 2h)$。这个扩展网格的总体积是：\n$$V_{total} = (n_x + 2h)(n_y + 2h)(n_z + 2h)$$\n\nghost 层中的单元数 $V_{ghost\\_cells}$ 是扩展网格的总体积减去内部域的体积：\n$$V_{ghost\\_cells} = V_{total} - V_{interior}$$\n$$V_{ghost\\_cells} = (n_x + 2h)(n_y + 2h)(n_z + 2h) - n_x n_y n_z$$\n\n问题陈述指出，每个网格单元存储 $s$ 个实值状态变量，每个变量都以双精度存储，即 $8$ 字节。因此，每个网格单元的数据量为 $8s$ 字节。\n\n总出站消息量（以字节为单位）$M_{volume}$ 是 ghost 层中的单元数乘以每个单元的数据量。\n$$M_{volume} = 8s \\times V_{ghost\\_cells}$$\n$$M_{volume} = 8s \\left[ (n_x + 2h)(n_y + 2h)(n_z + 2h) - n_x n_y n_z \\right]$$\n\n最后，我们代入 $n_x$、$n_y$ 和 $n_z$ 的表达式，以根据要求用全局问题参数来表示该体积。\n$$n_x = \\frac{N_x}{P_x}, \\quad n_y = \\frac{N_y}{P_y}, \\quad n_z = \\frac{N_z}{P_z}$$\n将这些代入 $M_{volume}$ 的表达式中：\n$$M_{volume} = 8s \\left[ \\left(\\frac{N_x}{P_x} + 2h\\right)\\left(\\frac{N_y}{P_y} + 2h\\right)\\left(\\frac{N_z}{P_z} + 2h\\right) - \\frac{N_x N_y N_z}{P_x P_y P_z} \\right]$$\n\n这就是根据指定的几何计数基本原理推导出的、每个进程的总出站消息量（以字节为单位）的最终闭式表达式。该表达式正确地计算了构成 halo 数据的面、边和角子块的体积。",
            "answer": "$$\n\\boxed{8s \\left[ \\left(\\frac{N_x}{P_x} + 2h\\right)\\left(\\frac{N_y}{P_y} + 2h\\right)\\left(\\frac{N_z}{P_z} + 2h\\right) - \\frac{N_x N_y N_z}{P_x P_y P_z} \\right]}\n$$"
        },
        {
            "introduction": "除了分解计算区域，粒子模拟代码的性能还关键性地取决于粒子数据在内存中的组织方式。本练习探讨了两种经典的数据布局——结构体数组 (AoS) 和数组结构体 (SoA)——以及它们对内存占用和带宽需求的影响。通过从第一性原理推导这些性能指标，你将深入理解如何为硬件感知的代码优化做出明智的数据结构选择 。",
            "id": "3968569",
            "problem": "考虑一个使用区域分解的计算聚变科学与工程代码中的大规模并行单元内粒子（particle-in-cell）推进。专注于一个包含 $N_p$ 个粒子的子域，每个粒子有 $k$ 个标量属性（例如，电荷、质量、三个位置分量、三个速度分量和一个单元索引）。每个属性以 $s$ 字节的固定宽度二进制格式存储。实践中使用了两种典型的内存布局：结构体数组（AoS）和数组结构体（SoA）。在结构体数组（AoS）布局中，每个粒子作为一个包含其 $k$ 个属性的连续记录存储，并且每条记录都被填充以满足 $a$ 字节的对齐约束。在数组结构体（SoA）布局中，每个属性都存储在各自长度为 $N_p$ 的连续数组中，在数组基地址处对齐，但没有针对每个粒子的填充。\n\n假设一个时间步进内核，它对每个粒子读取所有 $k$ 个属性，执行算术运算，然后写回所有 $k$ 个属性（对完整的粒子状态进行读-改-写操作）。内存子系统在存储时使用写分配（write-allocate）策略，并可能进行所有权读取（read-for-ownership, RFO）。用参数 $\\rho \\in \\{0,1\\}$ 对RFO效应进行建模，其中 $\\rho=1$ 表示写分配时产生的RFO流量等于写入数据量，而 $\\rho=0$ 表示非临时性存储或以其他方式避免了RFO。\n\n从第一性原理出发——即内存占用（memory footprint）定义为存储的总字节数，内存流量（memory traffic）定义为内核在主存和处理单元之间读取和写入的字节总和——推导以下符号表达式：\n- 结构体数组（array-of-structures）下粒子数组的总内存占用，$M_{\\mathrm{AoS}}$，以字节为单位，\n- 数组结构体（structure-of-arrays）下的总内存占用，$M_{\\mathrm{SoA}}$，以字节为单位，\n- 结构体数组下每个时间步的总内存流量，$B_{\\mathrm{AoS}}$，以字节/时间步为单位，\n- 数组结构体下每个时间步的总内存流量，$B_{\\mathrm{SoA}}$，以字节/时间步为单位。\n\n您的推导应明确考虑结构体数组布局中每个粒子的对齐填充以及由 $\\rho$ 参数化的所有权读取效应。请以字节为单位表示您的最终答案。将最终答案以单行矩阵的形式提供，依次包含 $M_{\\mathrm{AoS}}$，$M_{\\mathrm{SoA}}$，$B_{\\mathrm{AoS}}$ 和 $B_{\\mathrm{SoA}}$。不需要进行数值计算，也不需要四舍五入。不要在最终答案框内包含单位；内存占用和每个时间步的内存流量的单位均为字节。",
            "solution": "问题陈述已经过验证，被认为是合理的。它在科学上基于计算机内存组织和性能建模的原理，问题提出得当，提供了所有必要信息，并且语言客观。因此，我们可以着手对所要求的量进行形式化推导。\n\n问题要求推导与并行单元内粒子代码中内存使用相关的四个表达式：结构体数组（$M_{\\mathrm{AoS}}$）和数组结构体（$M_{\\mathrm{SoA}}$）布局的内存占用，以及相应的每个时间步的内存流量（$B_{\\mathrm{AoS}}$ 和 $B_{\\mathrm{SoA}}$）。推导将从每种布局的定义和内存流量模型出发。\n\n给定的参数是：\n- $N_p$：粒子数量。\n- $k$：每个粒子的标量属性数量。\n- $s$：每个属性的大小（字节）。\n- $a$：结构体数组布局的对齐约束（字节）。\n- $\\rho$：一个参数，值为0或1，用于建模所有权读取（RFO）流量的影响。\n\n**1. 结构体数组（Array-of-Structures）的内存占用 ($M_{\\mathrm{AoS}}$)**\n\n在结构体数组（AoS）布局中，单个粒子的 $k$ 个属性是连续存储的。单个粒子属性的总数据大小是属性数量 $k$ 和每个属性大小 $s$ 的乘积。\n$$ \\text{每个粒子数据大小} = k \\times s \\text{ 字节} $$\n问题指出，每条粒子记录都被填充以满足 $a$ 字节的对齐约束。这意味着为每条粒子记录分配的总大小必须是大于或等于实际数据大小 $ks$ 的 $a$ 的最小倍数。这可以用向上取整函数（ceiling function）来正式表示。设 $S_{\\mathrm{AoS\\_record}}$ 为一条填充后的粒子记录的大小。\n$$ S_{\\mathrm{AoS\\_record}} = a \\times \\left\\lceil \\frac{k s}{a} \\right\\rceil $$\n总内存占用 $M_{\\mathrm{AoS}}$ 是一条填充记录的大小乘以总粒子数 $N_p$。\n$$ M_{\\mathrm{AoS}} = N_p \\times S_{\\mathrm{AoS\\_record}} = N_p a \\left\\lceil \\frac{k s}{a} \\right\\rceil $$\n\n**2. 数组结构体（Structure-of-Arrays）的内存占用 ($M_{\\mathrm{SoA}}$)**\n\n在数组结构体（SoA）布局中， $k$ 个属性中的每一个都存储在各自独立的连续数组中。这些数组中的每一个都保存了所有 $N_p$ 个粒子的特定属性数据。问题明确指出此布局中没有针对每个粒子的填充。\n对于单个属性，一个这样的数组的大小是粒子数 $N_p$ 乘以属性大小 $s$。\n$$ \\text{单个属性数组的大小} = N_p \\times s \\text{ 字节} $$\n因为有 $k$ 个这样的数组，所以总内存占用 $M_{\\mathrm{SoA}}$ 是单个属性数组大小的 $k$ 倍。\n$$ M_{\\mathrm{SoA}} = k \\times (N_p \\times s) = N_p k s $$\n\n**3. 结构体数组（Array-of-Structures）的内存流量 ($B_{\\mathrm{AoS}}$)**\n\n内存流量定义为从主存读取和写入主存的字节总和。内核对每个粒子的所有属性执行一个读-改-写周期。\n\n在AoS布局中，数据的基本单位是粒子记录。访问粒子的任何属性都可能涉及传输包含整个填充记录的缓存行（cache line）。因此，我们基于填充后的记录大小 $S_{\\mathrm{AoS\\_record}}$ 来建模流量。\n\n- **读取流量**：为了执行计算，内核必须读取所有 $N_p$ 个粒子的初始状态。这构成了 $N_p \\times S_{\\mathrm{AoS\\_record}}$ 的读取流量。\n- **写入流量**：修改后，内核写回所有 $N_p$ 个粒子的新状态。这构成了 $N_p \\times S_{\\mathrm{AoS\\_record}}$ 的写入流量。\n- **所有权读取（RFO）流量**：问题引入了一个参数 $\\rho$ 来建模RFO流量，这是写分配策略在写未命中时产生的额外读取流量分量。RFO流量为 $\\rho$ 乘以写入的数据量。写入的数据量就是上面计算的写入流量。\n  $$ \\text{RFO 流量} = \\rho \\times (\\text{写入流量}) = \\rho \\times (N_p \\times S_{\\mathrm{AoS\\_record}}) $$\n\n总内存流量 $B_{\\mathrm{AoS}}$ 是这三个分量的总和。\n$$ B_{\\mathrm{AoS}} = (\\text{读取流量}) + (\\text{写入流量}) + (\\text{RFO 流量}) $$\n$$ B_{\\mathrm{AoS}} = (N_p S_{\\mathrm{AoS\\_record}}) + (N_p S_{\\mathrm{AoS\\_record}}) + (\\rho N_p S_{\\mathrm{AoS\\_record}}) $$\n$$ B_{\\mathrm{AoS}} = (1 + 1 + \\rho) N_p S_{\\mathrm{AoS\\_record}} = (2 + \\rho) N_p S_{\\mathrm{AoS\\_record}} $$\n代入 $S_{\\mathrm{AoS\\_record}}$ 的表达式：\n$$ B_{\\mathrm{AoS}} = (2 + \\rho) N_p a \\left\\lceil \\frac{k s}{a} \\right\\rceil $$\n\n**4. 数组结构体（Structure-of-Arrays）的内存流量 ($B_{\\mathrm{SoA}}$)**\n\n对于SoA布局，逻辑是类似的，但数据量的计算方式不同。所有粒子的总数据有效载荷与内存占用 $M_{\\mathrm{SoA}}$ 相同。我们将此数据量表示为 $V_{\\mathrm{payload}} = N_p k s$。\n\n内核读取所有 $N_p$ 个粒子的全部 $k$ 个属性，然后将它们写回。\n- **读取流量**：内核读取所有属性数组。总读取量为 $V_{\\mathrm{payload}} = N_p k s$。\n- **写入流量**：内核写入所有属性数组。总写入量为 $V_{\\mathrm{payload}} = N_p k s$。\n- **所有权读取（RFO）流量**：这是 $\\rho$ 乘以写入的数据量。\n  $$ \\text{RFO 流量} = \\rho \\times (\\text{写入流量}) = \\rho \\times (N_p k s) $$\n\n总内存流量 $B_{\\mathrm{SoA}}$ 是这些分量的总和。\n$$ B_{\\mathrm{SoA}} = (\\text{读取流量}) + (\\text{写入流量}) + (\\text{RFO 流量}) $$\n$$ B_{\\mathrm{SoA}} = (N_p k s) + (N_p k s) + (\\rho N_p k s) $$\n$$ B_{\\mathrm{SoA}} = (1 + 1 + \\rho) N_p k s = (2 + \\rho) N_p k s $$\n\n总而言之，推导出的四个表达式是：\n- $M_{\\mathrm{AoS}} = N_p a \\lceil \\frac{ks}{a} \\rceil$\n- $M_{\\mathrm{SoA}} = N_p k s$\n- $B_{\\mathrm{AoS}} = (2 + \\rho) N_p a \\lceil \\frac{ks}{a} \\rceil$\n- $B_{\\mathrm{SoA}} = (2 + \\rho) N_p k s$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nN_p a \\left\\lceil \\frac{ks}{a} \\right\\rceil & N_p k s & (2 + \\rho) N_p a \\left\\lceil \\frac{ks}{a} \\right\\rceil & (2 + \\rho) N_p k s\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "正确实现并行算法不仅需要管理数据分布，还必须维护其底层的物理定律。这个高级练习探讨了并行“细胞内粒子”(Particle-In-Cell)代码中一个微妙但关键的问题：当粒子在子区域间的迁移发生延迟时，如何保持电荷守恒。通过分析由此产生的误差并设计一个修正方案，你将看到并行化选择如何直接影响模拟的物理保真度 。",
            "id": "3968634",
            "problem": "考虑一个在一维（$1\\mathrm{D}$）均匀网格上的电荷守恒网格粒子（PIC）算法，该网格通过位于 $x=x_b$ 的界面被分解为两个子域 $\\Omega_{\\mathrm{A}}$ 和 $\\Omega_{\\mathrm{B}}$。其基本控制平衡关系是电荷连续性方程 $\\partial \\rho / \\partial t + \\nabla \\cdot \\mathbf{J} = 0$，其中 $\\rho$ 是电荷密度，$\\mathbf{J}$ 是电流密度。在从 $t^n$ 到 $t^{n+1}=t^n+\\Delta t$ 的离散时间步中，电荷守恒的 PIC 电流分配过程确保了，只要粒子被分配到它们在该步中物理移动到的位置，离散连续性方程在每个子域上都能精确成立。\n\n假设在时间 $t^n$ 和 $t^{n+1}$ 之间，有三个宏粒子从 $\\Omega_{\\mathrm{A}}$ 穿过界面迁移到 $\\Omega_{\\mathrm{B}}$。它们的电荷分别为 $q_1=1.2 \\times 10^{-9}\\ \\mathrm{C}$、$q_2=-0.8 \\times 10^{-9}\\ \\mathrm{C}$ 和 $q_3=0.5 \\times 10^{-9}\\ \\mathrm{C}$。在这一步中，它们的轨迹完全穿过了界面，因此它们应对从 $\\Omega_{\\mathrm{A}}$ 到 $\\Omega_{\\mathrm{B}}$ 的界面电流通量有所贡献。离散时间步长为 $\\Delta t=5.0 \\times 10^{-9}\\ \\mathrm{s}$。然而，由于一个并行通信调度决策，向 $\\Omega_{\\mathrm{B}}$ 的粒子迁移被精确地延迟了一个时间步：接收子域 $\\Omega_{\\mathrm{B}}$ 不在 $t^{n+1}$ 时刻分配这些粒子，而是在 $t^{n+2}$ 时刻接收并分配它们。\n\n从电荷连续性方程和跨子域界面的离散通量定义出发，推导在 $t^{n+1}$ 时刻，由于这一步延迟而在 $\\Omega_{\\mathrm{B}}$ 上引入的净离散电荷守恒误差，该误差表示为电荷变化与分配电流散度之间的不匹配。然后，提出一种延迟电流补偿方案，通过从 $\\Omega_{\\mathrm{A}}$ 向 $\\Omega_{\\mathrm{B}}$ 分配一个等于延迟步骤中遗漏的界面通量的界面修正电流，来在 $t^{n+1}$ 时刻恢复 $\\Omega_{\\mathrm{B}}$ 上的离散电荷连续性。计算这个修正电流的大小，该电流被解释为在时间区间 $[t^n,t^{n+1}]$ 内必须跨越 $x=x_b$ 添加的总界面电流（而非电流密度）。\n\n将你的最终答案四舍五入到四位有效数字。以 $\\mathrm{A}$ 为单位表示最终的电流大小。",
            "solution": "用户希望我按照以下步骤解决问题：\n1.  **验证问题**：我将首先检查问题是否适定、有科学依据且没有致命缺陷。\n2.  **推导解答**：如果问题有效，我将从第一性原理出发推导答案。\n3.  **最终格式化**：我必须对所有数学实体使用 LaTeX，并以特定的方框格式呈现最终答案。\n\n### 第一步：提取已知条件\n-   **系统**：一维（$1\\mathrm{D}$）网格粒子（PIC）模拟，采用区域分解，分为两个子域 $\\Omega_{\\mathrm{A}}$ 和 $\\Omega_{\\mathrm{B}}$。\n-   **界面**：子域由位于 $x=x_b$ 的界面分隔。\n-   **控制原理**：电荷连续性方程 $\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot \\mathbf{J} = 0$。\n-   **粒子迁移**：在时间步 $[t^n, t^{n+1}]$ 期间，三个宏粒子从 $\\Omega_{\\mathrm{A}}$ 迁移到 $\\Omega_{\\mathrm{B}}$。\n-   **粒子电荷**：$q_1 = 1.2 \\times 10^{-9}\\ \\mathrm{C}$，$q_2 = -0.8 \\times 10^{-9}\\ \\mathrm{C}$，$q_3 = 0.5 \\times 10^{-9}\\ \\mathrm{C}$。\n-   **时间步长**：$\\Delta t = t^{n+1} - t^n = 5.0 \\times 10^{-9}\\ \\mathrm{s}$。\n-   **数值缺陷**：由于通信延迟，子域 $\\Omega_{\\mathrm{B}}$ 在 $t^{n+1}$ 时刻未处理迁移的粒子。它们的计入被延迟到 $t^{n+2}$。\n-   **任务 1**：推导在 $t^{n+1}$ 时刻 $\\Omega_{\\mathrm{B}}$ 上的净离散电荷守恒误差。\n-   **任务 2**：提出一种延迟电流补偿方案以恢复电荷连续性。\n-   **任务 3**：计算界面处所需的修正电流的大小。\n-   **输出格式**：最终数值答案必须四舍五入到四位有效数字，并以安培（$\\mathrm{A}$）表示。\n\n### 第二步：使用提取的已知条件进行验证\n-   **科学依据**：该问题在计算等离子体物理学中有充分的依据。并行 PIC 代码中的电荷守恒、区域分解以及界面处的通量修正是该领域的标准和关键课题。连续性方程是物理学的基本定律。所描述的情景是并行算法设计中一个现实且常见的挑战。该问题在科学上是合理的。\n-   **适定性**：问题提供了计算所需电流的所有必要数据（$q_1, q_2, q_3, \\Delta t$）。目标陈述清晰，存在唯一且有意义的解。\n-   **客观性**：问题以精确、客观、技术性的语言陈述，没有任何主观或模棱两可的术语。\n-   **缺陷清单**：问题不违反任何无效标准。它是科学有效的、可形式化的、完整的、现实的且适定的。\n\n### 第三步：结论与行动\n该问题是**有效的**。现在开始求解过程。\n\n### 解题推导\n\n控制电荷守恒的基本原理是连续性方程，其在控制体 $V$ 上的积分形式为：\n$$\n\\frac{d}{dt} \\int_V \\rho \\, dV + \\oint_{\\partial V} \\mathbf{J} \\cdot d\\mathbf{S} = 0\n$$\n其中 $\\rho$ 是电荷密度，$\\mathbf{J}$ 是电流密度，$V$ 是体积，$\\partial V$ 是其边界面。令 $Q_V = \\int_V \\rho \\, dV$ 为体积内的总电荷。该方程表明，一个体积内总电荷的变化率等于流入其中的净电流。\n\n对于占据空间中某个区域的一维子域 $\\Omega_{\\mathrm{B}}$，该方程变为：\n$$\n\\frac{dQ_{\\mathrm{B}}}{dt} = I_{\\text{net, in}}\n$$\n其中 $Q_{\\mathrm{B}}$ 是 $\\Omega_{\\mathrm{B}}$ 内的总电荷，$I_{\\text{net, in}}$ 是通过其边界流入其中的净总电流。在本问题中，相关的边界是位于 $x=x_b$ 的界面，电流从 $\\Omega_{\\mathrm{A}}$ 流向 $\\Omega_{\\mathrm{B}}$。我们将此界面电流记为 $I_b(t)$。\n\n一个电荷守恒的 PIC 算法必须在每个时间步 $\\Delta t = t^{n+1} - t^n$ 满足此方程的离散模拟形式。将该方程在时间区间 $[t^n, t^{n+1}]$ 上积分，得到：\n$$\n\\int_{t^n}^{t^{n+1}} \\frac{dQ_{\\mathrm{B}}}{dt} dt = \\int_{t^n}^{t^{n+1}} I_b(t) dt\n$$\n$$\nQ_{\\mathrm{B}}^{n+1} - Q_{\\mathrm{B}}^n = \\bar{I}_b \\Delta t\n$$\n其中 $Q_{\\mathrm{B}}^n$ 是在 $t^n$ 时刻 $\\Omega_{\\mathrm{B}}$ 内的总电荷，$\\bar{I}_b = \\frac{1}{\\Delta t} \\int_{t^n}^{t^{n+1}} I_b(t) dt$ 是该步中跨界面的时间平均电流。$\\bar{I}_b \\Delta t$ 项代表跨边界转移的总电荷，即所有穿过界面的粒子的净电荷。\n\n在物理系统中，三个电荷分别为 $q_1$、$q_2$ 和 $q_3$ 的粒子从 $\\Omega_{\\mathrm{A}}$ 穿过界面进入 $\\Omega_{\\mathrm{B}}$。物理上进入 $\\Omega_{\\mathrm{B}}$ 的总电荷为：\n$$\n\\Delta Q_{\\text{mig}} = q_1 + q_2 + q_3\n$$\n为了使电荷守恒，记录在 $\\Omega_{\\mathrm{B}}$ 中的电荷变化必须等于此量，并且此变化必须由边界上相应的分配电流通量来解释。物理上正确的时间平均界面电流是：\n$$\n\\bar{I}_{\\text{phys}} = \\frac{\\Delta Q_{\\text{mig}}}{\\Delta t}\n$$\n\n问题指出通信存在一步延迟。在 $t^n \\to t^{n+1}$ 这一步中，子域 $\\Omega_{\\mathrm{B}}$ 没有收到这三个迁移粒子的数据。因此：\n1.  属于 $\\Omega_{\\mathrm{B}}$ 的粒子列表没有用新到达的粒子进行更新。计算出的 $\\Omega_{\\mathrm{B}}$ 内的总电荷在此迁移事件中保持不变，因此代码计算 $\\Delta Q_{\\mathrm{B}, \\text{code}} = Q_{\\mathrm{B}}^{n+1} - Q_{\\mathrm{B}}^n = 0$（相对于迁移的粒子）。\n2.  由于 $\\Omega_{\\mathrm{B}}$ 没有关于粒子穿越其边界的信息，它在界面 $x=x_b$ 处从这些粒子分配的电流为零。分配的界面电流为 $\\bar{I}_{b, \\text{dep}} = 0$。\n\n在 $\\Omega_{\\mathrm{B}}$ 上的离散电荷守恒误差是物理电荷变化与通过分配电流计算的电荷之间的不匹配。\n$$\n\\text{Error} = \\Delta Q_{\\text{phys}} - (\\bar{I}_{b, \\text{dep}} \\Delta t)\n$$\n在这种情况下，$\\Delta Q_{\\text{phys}} = \\Delta Q_{\\text{mig}}$ 且 $\\bar{I}_{b, \\text{dep}} = 0$。因此误差为：\n$$\n\\text{Error} = \\Delta Q_{\\text{mig}} - 0 = \\Delta Q_{\\text{mig}}\n$$\n这意味着净电荷 $\\Delta Q_{\\text{mig}}$ 已经物理上出现在域区域 $\\Omega_{\\mathrm{B}}$ 中，而该子域中的代码没有记录任何相应的电流。这违反了网格上离散形式的高斯定律，导致非物理的静电场。\n\n为了在 $t^{n+1}$ 时刻恢复离散电荷连续性，提出了一种“延迟电流补偿”方法。这涉及在网格上 $\\Omega_{\\mathrm{B}}$ 一侧的界面处分配一个修正电流 $I_{\\text{corr}}$。这个修正必须等于“遗漏的界面通量”，也就是本应分配的电流，即 $\\bar{I}_{\\text{phys}}$。\n$$\nI_{\\text{corr}} = \\bar{I}_{\\text{phys}} = \\frac{\\Delta Q_{\\text{mig}}}{\\Delta t}\n$$\n通过此修正，$\\Omega_{\\mathrm{B}}$ 网格上的离散连续性方程将得到满足，因为由分配电流引起的网格电荷变化将是 $I_{\\text{corr}} \\Delta t = \\Delta Q_{\\text{mig}}$，从而正确反映了物理上的电荷进入（尽管粒子对象本身要到稍后才被计入）。\n\n我们现在计算这个修正电流的大小。\n首先，计算迁移粒子的总电荷：\n$$\n\\Delta Q_{\\text{mig}} = q_1 + q_2 + q_3 = (1.2 \\times 10^{-9}) + (-0.8 \\times 10^{-9}) + (0.5 \\times 10^{-9}) \\ \\mathrm{C}\n$$\n$$\n\\Delta Q_{\\text{mig}} = (1.2 - 0.8 + 0.5) \\times 10^{-9}\\ \\mathrm{C} = 0.9 \\times 10^{-9}\\ \\mathrm{C}\n$$\n时间步长为 $\\Delta t = 5.0 \\times 10^{-9}\\ \\mathrm{s}$。\n修正电流的大小为：\n$$\nI_{\\text{corr}} = \\frac{\\Delta Q_{\\text{mig}}}{\\Delta t} = \\frac{0.9 \\times 10^{-9}\\ \\mathrm{C}}{5.0 \\times 10^{-9}\\ \\mathrm{s}}\n$$\n$$\nI_{\\text{corr}} = \\frac{0.9}{5.0}\\ \\mathrm{A} = 0.18\\ \\mathrm{A}\n$$\n问题要求答案四舍五入到四位有效数字。\n$$\nI_{\\text{corr}} = 0.1800\\ \\mathrm{A}\n$$\n这个修正电流从 $\\Omega_{\\mathrm{A}}$（它知道粒子已经离开并能计算通量）传递到 $\\Omega_{\\mathrm{B}}$，使得尽管粒子数据传输存在延迟，网格上的全局电荷守恒仍能在每个时间步得到维持。",
            "answer": "$$\n\\boxed{0.1800}\n$$"
        }
    ]
}