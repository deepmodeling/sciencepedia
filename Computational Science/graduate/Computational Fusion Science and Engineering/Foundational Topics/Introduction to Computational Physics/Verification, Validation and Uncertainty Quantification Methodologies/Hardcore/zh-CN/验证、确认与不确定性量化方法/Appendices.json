{
    "hands_on_practices": [
        {
            "introduction": "人造解法（Method of Manufactured Solutions, MMS）是代码验证的基石，它使我们能够严格测试数值求解器是否正确地实现了预期的偏微分方程。通过构建一个已知的解析解，我们可以精确计算数值格式的误差，并验证其理论收敛阶。此练习  将指导您为托卡马克等离子体平衡的基本模型——Grad-Shafranov方程——构建一个MMS测试，为您提供在这一关键验证技术方面的实践经验。",
            "id": "4061811",
            "problem": "您的任务是为轴对称二维 Grad–Shafranov 算子设计并实现一种人造解方法，以支持计算聚变科学与工程中的验证与确认（VV）以及不确定性量化（UQ）方法。考虑为极向磁通函数 $\\psi(R,Z)$ 定义的轴对称 Grad–Shafranov 算子\n$$\n\\Delta^\\star \\psi \\equiv R \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) + \\frac{\\partial^2 \\psi}{\\partial Z^2}.\n$$\n在本问题中，您将构造一个人造解并推导相应的源项，从而精确满足偏微分方程（PDE）\n$$\n\\Delta^\\star \\psi(R,Z) = S(R,Z)\n$$\n其中 $R$ 表示大半径，$Z$ 表示垂直坐标。该区域在 $(R,Z)$ 空间中为矩形，其中 $R \\in [R_{\\min}, R_{\\max}]$ 且 $Z \\in [Z_{\\min}, Z_{\\max}]$，您必须施加与人造解一致的 Dirichlet 边界条件。所有量均为无量纲。出现在三角函数内的任何角度都必须以弧度为单位进行解释。\n\n从基本的磁流体动力学平衡考虑出发，Grad–Shafranov 算子 $\\Delta^\\star$ 源于轴对称条件下压力与磁力的平衡，是轴对称平衡的核心模型。为了使用人造解方法进行代码验证，您将预先指定 $\\psi(R,Z)$，然后推导出 $S(R,Z)$ 和边界条件，从而通过构造使偏微分方程得以满足。您将使用二阶有限差分法在均匀网格上数值求解该偏微分方程，并将数值解与精确的人造解进行比较，以计算误差范数和观测到的精度阶。\n\n将人造解定义为可分离形式\n$$\n\\psi(R,Z) = f(R)\\, g(Z),\n$$\n其中\n$$\nf(R) = \\left(R - R_0\\right)^2 e^{-\\alpha R}, \\quad g(Z) = \\left(Z^2 + 1\\right) \\sin(\\beta Z),\n$$\n$R_0$、$\\alpha$ 和 $\\beta$ 是无量纲参数。仅使用代数和微积分，推导所需的源项 $S(R,Z)$，以使 $\\psi(R,Z)$ 精确满足 $\\Delta^\\star \\psi = S$。您必须以 $R$、$Z$、$R_0$、$\\alpha$ 和 $\\beta$ 的形式提供源项，不进行数值近似。在矩形区域的所有边界上施加 Dirichlet 边界条件 $\\psi(R,Z)$。\n\n在均匀的张量积网格上，使用二阶精度的有限差分法对算子 $\\Delta^\\star$ 进行离散化，该网格在 $R$ 方向有 $N_R$ 个点，在 $Z$ 方向有 $N_Z$ 个点。应使用守恒通量近似来构建离散算子中与 $R$ 相关的部分，即，令 $a(R) = 1/R$ 并近似\n$$\n\\frac{\\partial}{\\partial R} \\left( a(R) \\frac{\\partial \\psi}{\\partial R} \\right)\n\\approx \\frac{1}{\\Delta R} \\left( a_{i+\\frac{1}{2}} \\frac{\\psi_{i+1,j} - \\psi_{i,j}}{\\Delta R} - a_{i-\\frac{1}{2}} \\frac{\\psi_{i,j} - \\psi_{i-1,j}}{\\Delta R} \\right),\n$$\n其中 $a_{i\\pm \\frac{1}{2}} = a(R_{i\\pm \\frac{1}{2}})$，$R_{i\\pm \\frac{1}{2}} = \\left(R_i + R_{i\\pm 1}\\right)/2$。$Z$ 的二阶导数应通过标准的二阶中心差分进行近似。通过将边界贡献移到线性系统的右侧来合并 Dirichlet 边界条件。求解得到的稀疏线性系统以获得内部未知数，并通过插入精确人造解 $\\psi(R,Z)$ 的边界值来重构完整解。\n\n计算以下定量验证指标：\n- 均方根误差 $E_{\\mathrm{RMS}}$，定义为\n$$\nE_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_{\\mathrm{int}}} \\sum_{(i,j)\\in \\Omega_{\\mathrm{int}}} \\left(\\psi^{\\mathrm{num}}_{i,j} - \\psi^{\\mathrm{exact}}_{i,j}\\right)^2},\n$$\n其中 $\\Omega_{\\mathrm{int}}$ 索引所有内部网格点，$N_{\\mathrm{int}}$ 是内部点的数量。\n- 最大范数误差 $E_{\\infty}$，定义为\n$$\nE_{\\infty} = \\max_{(i,j)\\in \\Omega_{\\mathrm{int}}} \\left| \\psi^{\\mathrm{num}}_{i,j} - \\psi^{\\mathrm{exact}}_{i,j} \\right|.\n$$\n\n此外，对于一对加密的测试用例，使用以下公式计算观测到的精度阶 $p$\n$$\np = \\frac{\\log\\left(E_{\\mathrm{coarse}} / E_{\\mathrm{fine}}\\right)}{\\log\\left(h_{\\mathrm{coarse}} / h_{\\mathrm{fine}}\\right)},\n$$\n其中 $E$ 是误差范数（分别使用 $E_{\\mathrm{RMS}}$ 和 $E_{\\infty}$ 计算两个 $p$ 值），$h$ 是由 $h = \\max\\{\\Delta R, \\Delta Z\\}$ 定义的最大网格间距。\n\n您的程序必须实现以上内容，并为以下参数值测试套件生成结果，这些测试用例探究了不同的数值和物理方面，包括一般情况、靠近轴的边界情况（$R$ 很小但非零）、在 $Z$ 方向上振荡更剧烈的情况，以及用于观测精度阶估计的一对加密用例。$\\sin$ 和 $\\cos$ 内部的所有角度都以弧度为单位。\n\n- 测试用例 $1$（一般情况）：$R_{\\min} = 1.0$, $R_{\\max} = 3.0$, $Z_{\\min} = -1.0$, $Z_{\\max} = 1.0$, $R_0 = 1.5$, $\\alpha = 0.3$, $\\beta = 4.0$, $N_R = 32$, $N_Z = 32$。\n- 测试用例 $2$（靠近轴的边界情况）：$R_{\\min} = 0.2$, $R_{\\max} = 2.0$, $Z_{\\min} = -1.0$, $Z_{\\max} = 1.0$, $R_0 = 0.9$, $\\alpha = 0.7$, $\\beta = 3.0$, $N_R = 36$, $N_Z = 36$。\n- 测试用例 $3$（$Z$ 方向振荡）：$R_{\\min} = 1.0$, $R_{\\max} = 2.5$, $Z_{\\min} = -2.0$, $Z_{\\max} = 2.0$, $R_0 = 1.2$, $\\alpha = 0.4$, $\\beta = 8.0$, $N_R = 48$, $N_Z = 64$。\n- 测试用例 $4$（加密，粗网格）：$R_{\\min} = 1.0$, $R_{\\max} = 3.0$, $Z_{\\min} = -1.0$, $Z_{\\max} = 1.0$, $R_0 = 1.5$, $\\alpha = 0.3$, $\\beta = 4.0$, $N_R = 24$, $N_Z = 24$。\n- 测试用例 $5$（加密，细网格）：$R_{\\min} = 1.0$, $R_{\\max} = 3.0$, $Z_{\\min} = -1.0$, $Z_{\\max} = 1.0$, $R_0 = 1.5$, $\\alpha = 0.3$, $\\beta = 4.0$, $N_R = 48$, $N_Z = 48$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须按以下顺序排列\n$$\n\\left[ E_{\\mathrm{RMS}}^{(1)}, E_{\\infty}^{(1)}, E_{\\mathrm{RMS}}^{(2)}, E_{\\infty}^{(2)}, E_{\\mathrm{RMS}}^{(3)}, E_{\\infty}^{(3)}, E_{\\mathrm{RMS}}^{(4)}, E_{\\infty}^{(4)}, E_{\\mathrm{RMS}}^{(5)}, E_{\\infty}^{(5)}, p_{\\mathrm{RMS}}^{(4\\rightarrow 5)}, p_{\\infty}^{(4\\rightarrow 5)} \\right],\n$$\n其中上标表示测试用例索引，观测阶 $p_{\\mathrm{RMS}}^{(4\\rightarrow 5)}$ 和 $p_{\\infty}^{(4\\rightarrow 5)}$ 分别使用测试用例 4 和 5 作为粗细网格对进行计算。所有条目必须是浮点数。",
            "solution": "该问题要求为二维轴对称 Grad-Shafranov 算子设计并实现一种人造解方法（Method of Manufactured Solutions, MMS）。这涉及几个阶段：源项的解析推导、所得偏微分方程（PDE）的数值离散化与求解，以及为验证实现而进行的定量误差分析。\n\n### 第 1 步：源项的解析推导\n\nGrad-Shafranov 算子由下式给出\n$$\n\\Delta^\\star \\psi \\equiv R \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) + \\frac{\\partial^2 \\psi}{\\partial Z^2}.\n$$\n展开径向部分，该算子可以重写为\n$$\n\\Delta^\\star \\psi = \\frac{\\partial^2 \\psi}{\\partial R^2} - \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} + \\frac{\\partial^2 \\psi}{\\partial Z^2}.\n$$\n人造解以可分离形式提供，$\\psi(R,Z) = f(R)g(Z)$，其中\n$$\nf(R) = \\left(R - R_0\\right)^2 e^{-\\alpha R}\n$$\n且\n$$\ng(Z) = \\left(Z^2 + 1\\right) \\sin(\\beta Z).\n$$\n我们必须找到源项 $S(R,Z)$，使得 $\\Delta^\\star \\psi(R,Z) = S(R,Z)$ 精确成立。将算子应用于可分离形式可得\n$$\nS(R,Z) = \\Delta^\\star \\psi = g(Z) \\left( \\frac{d^2 f}{dR^2} - \\frac{1}{R} \\frac{df}{dR} \\right) + f(R) \\frac{d^2 g}{dZ^2}.\n$$\n我们通过计算 $f(R)$ 和 $g(Z)$ 的必要导数来进行。\n\n对于 $f(R)$：\n一阶导数为\n$$\n\\frac{df}{dR} = 2(R - R_0)e^{-\\alpha R} - \\alpha (R - R_0)^2 e^{-\\alpha R} = e^{-\\alpha R} (R - R_0) [2 - \\alpha(R - R_0)].\n$$\n二阶导数为\n$$\n\\frac{d^2f}{dR^2} = [2 - 2\\alpha(R-R_0)]e^{-\\alpha R} - \\alpha e^{-\\alpha R} [2(R-R_0) - \\alpha(R-R_0)^2] = e^{-\\alpha R}[2 - 4\\alpha(R-R_0) + \\alpha^2(R-R_0)^2].\n$$\n令作用于 $f$ 的径向算子为 $L_R[f] = \\frac{d^2 f}{dR^2} - \\frac{1}{R} \\frac{df}{dR}$。则\n$$\nL_R[f] = e^{-\\alpha R} \\left( [2 - 4\\alpha(R-R_0) + \\alpha^2(R-R_0)^2] - \\frac{1}{R}(R-R_0)[2 - \\alpha(R-R_0)] \\right).\n$$\n\n对于 $g(Z)$：\n一阶导数为\n$$\n\\frac{dg}{dZ} = 2Z \\sin(\\beta Z) + \\beta(Z^2+1)\\cos(\\beta Z).\n$$\n二阶导数为\n$$\n\\frac{d^2g}{dZ^2} = [2\\sin(\\beta Z) + 2Z\\beta\\cos(\\beta Z)] + [2Z\\beta\\cos(\\beta Z) - \\beta^2(Z^2+1)\\sin(\\beta Z)]\n$$\n$$\n\\frac{d^2g}{dZ^2} = [2 - \\beta^2(Z^2+1)]\\sin(\\beta Z) + 4Z\\beta\\cos(\\beta Z).\n$$\n源项 $S(R,Z)$ 是两部分之和：\n$$\nS(R,Z) = g(Z) \\cdot L_R[f] + f(R) \\cdot \\frac{d^2g}{dZ^2}.\n$$\n这个解析表达式将在数值网格上进行评估，以提供线性系统的右侧项。\n\n### 第 2 步：数值离散化\n\n区域 $[R_{\\min}, R_{\\max}] \\times [Z_{\\min}, Z_{\\max}]$ 使用包含 $R$ 方向 $N_R$ 个点和 $Z$ 方向 $N_Z$ 个点的均匀张量积网格进行离散化。网格间距为 $\\Delta R = (R_{\\max}-R_{\\min})/(N_R-1)$ 和 $\\Delta Z = (Z_{\\max}-Z_{\\min})/(N_Z-1)$。网格点表示为 $(R_i, Z_j)$，其中 $R_i = R_{\\min} + i\\Delta R$（$i=0, \\dots, N_R-1$）且 $Z_j = Z_{\\min} + j\\Delta Z$（$j=0, \\dots, N_Z-1$）。\n\n该偏微分方程使用二阶有限差分格式进行离散化。在内部网格点 $(i,j)$（其中 $i=1, \\dots, N_R-2$ 且 $j=1, \\dots, N_Z-2$）处的离散方程为 $(\\Delta^\\star \\psi)_{i,j} = S_{i,j}$。\n\n径向部分使用指定的守恒通量近似进行离散化：\n$$\n\\left. R \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) \\right|_{i,j} \\approx \\frac{R_i}{(\\Delta R)^2} \\left( a_{i+\\frac{1}{2}}(\\psi_{i+1,j} - \\psi_{i,j}) - a_{i-\\frac{1}{2}}(\\psi_{i,j} - \\psi_{i-1,j}) \\right),\n$$\n其中 $a(R)=1/R$ 且 $a_{i\\pm1/2} = 1/R_{i\\pm1/2}$，$R_{i\\pm1/2} = (R_i + R_{i\\pm1})/2$。\n轴向部分使用标准的二阶中心差分进行离散化：\n$$\n\\left. \\frac{\\partial^2 \\psi}{\\partial Z^2} \\right|_{i,j} \\approx \\frac{\\psi_{i,j+1} - 2\\psi_{i,j} + \\psi_{i,j-1}}{(\\Delta Z)^2}.\n$$\n将这些组合起来，为每个内部点 $(i,j)$ 提供了一个五点模板：\n$$\nC_{i-1,j}\\psi_{i-1,j} + C_{i+1,j}\\psi_{i+1,j} + C_{i,j-1}\\psi_{i,j-1} + C_{i,j+1}\\psi_{i,j+1} + C_{i,j}\\psi_{i,j} = S_{i,j},\n$$\n其中系数为：\n- $C_{i,j} = -\\frac{R_i}{(\\Delta R)^2}(a_{i+\\frac{1}{2}} + a_{i-\\frac{1}{2}}) - \\frac{2}{(\\Delta Z)^2}$ （中心）\n- $C_{i+1,j} = \\frac{R_i}{(\\Delta R)^2} a_{i+\\frac{1}{2}}$ （东）\n- $C_{i-1,j} = \\frac{R_i}{(\\Delta R)^2} a_{i-\\frac{1}{2}}$ （西）\n- $C_{i,j+1} = \\frac{1}{(\\Delta Z)^2}$ （北）\n- $C_{i,j-1} = \\frac{1}{(\\Delta Z)^2}$ （南）\n\n### 第 3 步：线性系统的构建与求解\n\n所有内部点的线性方程组构成一个大型稀疏线性系统 $A\\mathbf{x} = \\mathbf{b}$。\n- $\\mathbf{x}$ 是在 $(N_R-2) \\times (N_Z-2)$ 个内部网格点上未知值 $\\psi_{i,j}$ 的向量，按字典序排列。\n- $A$ 是系数的稀疏矩阵，具有块三对角结构。\n- $\\mathbf{b}$ 是右侧向量，包含源项值 $S_{i,j}$ 以及来自 Dirichlet 边界条件的贡献。\n\n$\\psi$ 的边界值由在边界网格点上求值的精确人造解 $\\psi^{\\mathrm{exact}}(R,Z)$ 给出。对于与边界相邻的内部点 $(i,j)$，涉及边界点的项是已知的，并被移至右侧。例如，对于内部点 $(1,j)$，项 $C_{0,j}\\psi_{0,j}$ 被移走，因此方程的右侧变为 $S_{1,j} - C_{0,j}\\psi^{\\mathrm{exact}}_{0,j}$。此过程应用于与四个边界中任何一个相邻的所有内部点。\n\n使用标准库例程（`scipy.sparse.linalg.spsolve`）求解所得的稀疏线性系统。然后将解向量 $\\mathbf{x}$ 重塑为一个二维数组并放入一个完整网格中，其边界值由 $\\psi^{\\mathrm{exact}}$ 设置，以形成完整的数值解 $\\psi^{\\mathrm{num}}$。\n\n### 第 4 步：误差分析与验证\n\n将数值解与精确的人造解进行比较以计算误差范数。在 $N_{\\mathrm{int}} = (N_R-2)(N_Z-2)$ 个内部点 $\\Omega_{\\mathrm{int}}$ 的集合上，我们计算：\n- 均方根误差：$E_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_{\\mathrm{int}}} \\sum_{(i,j)\\in \\Omega_{\\mathrm{int}}} (\\psi^{\\mathrm{num}}_{i,j} - \\psi^{\\mathrm{exact}}_{i,j})^2}$。\n- 最大范数误差：$E_{\\infty} = \\max_{(i,j)\\in \\Omega_{\\mathrm{int}}} |\\psi^{\\mathrm{num}}_{i,j} - \\psi^{\\mathrm{exact}}_{i,j}|$。\n\n对于使用粗网格（测试用例 4）和细网格（测试用例 5）的加密研究，观测到的精度阶 $p$ 计算如下\n$$\np = \\frac{\\log(E_{\\mathrm{coarse}} / E_{\\mathrm{fine}})}{\\log(h_{\\mathrm{coarse}} / h_{\\mathrm{fine}})},\n$$\n其中 $E$ 是 $E_{\\mathrm{RMS}}$ 或 $E_{\\infty}$，而 $h = \\max\\{\\Delta R, \\Delta Z\\}$ 是最大网格间距。对于指定的二阶格式，我们期望 $p \\approx 2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        {'R_min': 1.0, 'R_max': 3.0, 'Z_min': -1.0, 'Z_max': 1.0, 'R_0': 1.5, 'alpha': 0.3, 'beta': 4.0, 'N_R': 32, 'N_Z': 32},\n        {'R_min': 0.2, 'R_max': 2.0, 'Z_min': -1.0, 'Z_max': 1.0, 'R_0': 0.9, 'alpha': 0.7, 'beta': 3.0, 'N_R': 36, 'N_Z': 36},\n        {'R_min': 1.0, 'R_max': 2.5, 'Z_min': -2.0, 'Z_max': 2.0, 'R_0': 1.2, 'alpha': 0.4, 'beta': 8.0, 'N_R': 48, 'N_Z': 64},\n        {'R_min': 1.0, 'R_max': 3.0, 'Z_min': -1.0, 'Z_max': 1.0, 'R_0': 1.5, 'alpha': 0.3, 'beta': 4.0, 'N_R': 24, 'N_Z': 24},\n        {'R_min': 1.0, 'R_max': 3.0, 'Z_min': -1.0, 'Z_max': 1.0, 'R_0': 1.5, 'alpha': 0.3, 'beta': 4.0, 'N_R': 48, 'N_Z': 48},\n    ]\n\n    results = []\n    errors = []\n\n    for case in test_cases:\n        e_rms, e_inf = run_case(**case)\n        results.extend([e_rms, e_inf])\n        errors.append({'rms': e_rms, 'inf': e_inf})\n\n    # Compute observed order of accuracy for cases 4 and 5\n    case4 = test_cases[3]\n    case5 = test_cases[4]\n    err4 = errors[3]\n    err5 = errors[4]\n\n    dR_c = (case4['R_max'] - case4['R_min']) / (case4['N_R'] - 1)\n    dZ_c = (case4['Z_max'] - case4['Z_min']) / (case4['N_Z'] - 1)\n    h_c = max(dR_c, dZ_c)\n\n    dR_f = (case5['R_max'] - case5['R_min']) / (case5['N_R'] - 1)\n    dZ_f = (case5['Z_max'] - case5['Z_min']) / (case5['N_Z'] - 1)\n    h_f = max(dR_f, dZ_f)\n\n    p_rms = np.log(err4['rms'] / err5['rms']) / np.log(h_c / h_f)\n    p_inf = np.log(err4['inf'] / err5['inf']) / np.log(h_c / h_f)\n\n    results.extend([p_rms, p_inf])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_case(R_min, R_max, Z_min, Z_max, R_0, alpha, beta, N_R, N_Z):\n    \"\"\"\n    Solves the PDE for a single test case and returns error norms.\n    \"\"\"\n    # Define manufactured solution and source term functions\n    def psi_exact_func(R, Z, R_0, alpha, beta):\n        fR = (R - R_0)**2 * np.exp(-alpha * R)\n        gZ = (Z**2 + 1) * np.sin(beta * Z)\n        return fR * gZ\n\n    def source_func(R, Z, R_0, alpha, beta):\n        # Radial part\n        R_minus_R0 = R - R_0\n        df_dR = (2 * R_minus_R0 - alpha * R_minus_R0**2) * np.exp(-alpha * R)\n        d2f_dR2 = (2 - 4 * alpha * R_minus_R0 + alpha**2 * R_minus_R0**2) * np.exp(-alpha * R)\n        L_R_f = d2f_dR2 - df_dR / R\n        gZ = (Z**2 + 1) * np.sin(beta * Z)\n        term1 = L_R_f * gZ\n\n        # Axial part\n        fR = (R - R_0)**2 * np.exp(-alpha * R)\n        Z2_plus_1 = Z**2 + 1\n        d2g_dZ2 = (2 - beta**2 * Z2_plus_1) * np.sin(beta * Z) + 4 * Z * beta * np.cos(beta * Z)\n        term2 = fR * d2g_dZ2\n\n        return term1 + term2\n\n    # Create grid\n    R_vec = np.linspace(R_min, R_max, N_R)\n    Z_vec = np.linspace(Z_min, Z_max, N_Z)\n    dR = R_vec[1] - R_vec[0]\n    dZ = Z_vec[1] - Z_vec[0]\n    R, Z = np.meshgrid(R_vec, Z_vec, indexing='ij')\n\n    # Evaluate exact solution and source term on the grid\n    psi_exact = psi_exact_func(R, Z, R_0, alpha, beta)\n    S = source_func(R, Z, R_0, alpha, beta)\n\n    # Set up the linear system Ax = b for interior points\n    Ni = N_R - 2\n    Nj = N_Z - 2\n    N_int = Ni * Nj\n    \n    A = lil_matrix((N_int, N_int))\n    b = np.zeros(N_int)\n\n    for i in range(1, N_R - 1):\n        for j in range(1, N_Z - 1):\n            k = (i - 1) * Nj + (j - 1)\n            \n            # Source term\n            b[k] = S[i, j]\n\n            # Operator coefficients\n            R_i = R_vec[i]\n            a_ip12 = 1.0 / (R_i + 0.5 * dR)\n            a_im12 = 1.0 / (R_i - 0.5 * dR)\n\n            # Center\n            A[k, k] = -R_i / dR**2 * (a_ip12 + a_im12) - 2.0 / dZ**2\n\n            # West neighbor (i-1)\n            coeff_W = R_i / dR**2 * a_im12\n            if i == 1:\n                b[k] -= coeff_W * psi_exact[0, j]\n            else:\n                A[k, k - Nj] = coeff_W\n\n            # East neighbor (i+1)\n            coeff_E = R_i / dR**2 * a_ip12\n            if i == N_R - 2:\n                b[k] -= coeff_E * psi_exact[N_R - 1, j]\n            else:\n                A[k, k + Nj] = coeff_E\n\n            # South neighbor (j-1)\n            coeff_S = 1.0 / dZ**2\n            if j == 1:\n                b[k] -= coeff_S * psi_exact[i, 0]\n            else:\n                A[k, k - 1] = coeff_S\n\n            # North neighbor (j+1)\n            coeff_N = 1.0 / dZ**2\n            if j == N_Z - 2:\n                b[k] -= coeff_N * psi_exact[i, N_Z - 1]\n            else:\n                A[k, k + 1] = coeff_N\n\n    # Solve the system\n    A = A.tocsc()\n    psi_int_flat = spsolve(A, b)\n    psi_int = psi_int_flat.reshape((Ni, Nj))\n\n    # Reconstruct full solution\n    psi_num = np.copy(psi_exact)\n    psi_num[1:N_R-1, 1:N_Z-1] = psi_int\n\n    # Calculate errors on interior points\n    diff = psi_num[1:N_R-1, 1:N_Z-1] - psi_exact[1:N_R-1, 1:N_Z-1]\n    e_rms = np.sqrt(np.mean(diff**2))\n    e_inf = np.max(np.abs(diff))\n\n    return e_rms, e_inf\n\nsolve()\n```"
        },
        {
            "introduction": "在验证了代码的实现之后，下一个关键步骤是量化其解中的离散化误差。网格收敛指数（Grid Convergence Index, GCI）为此提供了一个标准化和系统化的流程，可以从一系列在加密网格上进行的模拟中估算该误差。本练习  演示了如何为一个来自托卡马克边界代码的模拟量计算观测到的收敛阶和GCI，为建立模拟结果的可信度提供了一种实用方法。",
            "id": "4061829",
            "problem": "针对托卡马克的高保真度边界等离子体输运模拟预测了外偏滤器靶板的峰值热通量，这是一个用 $\\phi$ 表示的标量。使用了三个系统加密的网格，统一加密比为 $r_{21} = r_{32} = r = 2$。在粗网格、中等网格和细网格上计算得到的相应 $\\phi$ 值分别为 $\\phi_{3} = 5.90$ 兆瓦/平方米、$\\phi_{2} = 5.30$ 兆瓦/平方米和 $\\phi_{1} = 5.10$ 兆瓦/平方米。假设物理域固定，且数值方法产生形式为 $\\phi(h) = \\phi_{\\ast} + C h^{p} + \\mathcal{O}(h^{p+1})$ 的光滑离散误差展开式。其中，$h$ 是一个合适的网格间距单参数度量，$\\phi_{\\ast}$ 是网格收敛值，$C$ 是一个与 $h$ 无关的常数，$p$ 是观测到的精度阶。进一步假设这三个网格处于渐近收敛区。网格收敛指数 (GCI) 采用一个安全因子 $F_{s}$ 来提供相对离散不确定度的保守估计。GCI 安全因子取 $F_{s} = 1.25$（这是网格收敛指数的安全因子，不是托卡马克的安全因子）。\n\n从给定的离散误差展开式和恒定加密比下的 Richardson 外推概念出发，推导出从三个解计算观测阶 $p$ 所需的表达式，然后推导细网格到中等网格的网格收敛指数 $\\mathrm{GCI}_{21}$。$\\mathrm{GCI}_{21}$ 被定义为对细网格上相对于网格加密的相对误差的保守估计。然后，利用所提供的数据和 $F_{s}$ 对 $\\mathrm{GCI}_{21}$ 进行数值计算。\n\n仅报告 $\\mathrm{GCI}_{21}$ 的值，形式为无量纲小数（而非百分比），并四舍五入到三位有效数字。",
            "solution": "该问题要求推导观测精度阶 $p$ 和细网格到中等网格的网格收敛指数 $\\mathrm{GCI}_{21}$ 的表达式，然后对 $\\mathrm{GCI}_{21}$ 进行数值计算。\n\n分析从所给定的数值计算标量 $\\phi$ 作为网格间距 $h$ 的函数的离散误差展开式开始：\n$$ \\phi(h) = \\phi_{\\ast} + C h^{p} + \\mathcal{O}(h^{p+1}) $$\n其中 $\\phi_{\\ast}$ 是精确解（网格收敛值），$C$ 是一个常数，$p$ 是精度阶。由于假设网格处于渐近收敛区，我们可以截断高阶项，并将三个系统加密网格（下标1代表细网格，2代表中等网格，3代表粗网格）上的解写为：\n$$ \\phi_1 \\approx \\phi_{\\ast} + C h_1^p $$\n$$ \\phi_2 \\approx \\phi_{\\ast} + C h_2^p $$\n$$ \\phi_3 \\approx \\phi_{\\ast} + C h_3^p $$\n这里，$h_1$、$h_2$ 和 $h_3$ 分别是细网格、中等网格和粗网格的特征网格间距。问题指定了统一的加密比 $r = r_{21} = r_{32} = 2$。根据定义，$r_{21} = h_2 / h_1$ 且 $r_{32} = h_3 / h_2$。因此，我们有 $h_2 = r h_1$ 和 $h_3 = r h_2 = r^2 h_1$。将这些关系代入近似方程中，得到：\n$$ \\phi_1 \\approx \\phi_{\\ast} + C h_1^p \\quad (1)$$\n$$ \\phi_2 \\approx \\phi_{\\ast} + C (r h_1)^p = \\phi_{\\ast} + C h_1^p r^p \\quad (2)$$\n$$ \\phi_3 \\approx \\phi_{\\ast} + C (r^2 h_1)^p = \\phi_{\\ast} + C h_1^p r^{2p} \\quad (3)$$\n\n首先，我们推导观测精度阶 $p$ 的表达式。为了消去未知数 $\\phi_{\\ast}$ 和 $C h_1^p$，我们考虑连续网格上解的差值。\n方程(2)减去方程(1)：\n$$ \\phi_2 - \\phi_1 \\approx (\\phi_{\\ast} + C h_1^p r^p) - (\\phi_{\\ast} + C h_1^p) = C h_1^p (r^p - 1) $$\n方程(3)减去方程(2)：\n$$ \\phi_3 - \\phi_2 \\approx (\\phi_{\\ast} + C h_1^p r^{2p}) - (\\phi_{\\ast} + C h_1^p r^p) = C h_1^p (r^{2p} - r^p) = C h_1^p r^p (r^p - 1) $$\n这两个差值的比值可以消去项 $C h_1^p (r^p - 1)$：\n$$ \\frac{\\phi_3 - \\phi_2}{\\phi_2 - \\phi_1} \\approx \\frac{C h_1^p r^p (r^p - 1)}{C h_1^p (r^p - 1)} = r^p $$\n对两边取自然对数求解 $p$，得到观测精度阶的表达式：\n$$ p = \\frac{\\ln\\left(\\frac{\\phi_3 - \\phi_2}{\\phi_2 - \\phi_1}\\right)}{\\ln(r)} $$\n\n接下来，我们推导 $\\mathrm{GCI}_{21}$ 的表达式。网格收敛指数基于 Richardson 外推，通过消去领头阶误差项来提供 $\\phi_{\\ast}$ 的更精确估计。使用方程(1)和(2)，我们可以消去项 $C h_1^p$：\n由(1)式可知，$C h_1^p \\approx \\phi_1 - \\phi_{\\ast}$。\n将其代入(2)式：\n$$ \\phi_2 \\approx \\phi_{\\ast} + (\\phi_1 - \\phi_{\\ast}) r^p $$\n重新整理以求解外推值 $\\phi_{\\text{ext}}^{21}$，这是我们对 $\\phi_{\\ast}$ 的最佳估计：\n$$ \\phi_2 \\approx \\phi_{\\ast} + r^p \\phi_1 - r^p \\phi_{\\ast} $$\n$$ \\phi_2 - r^p \\phi_1 \\approx \\phi_{\\ast} (1 - r^p) $$\n$$ \\phi_{\\ast} \\approx \\phi_{\\text{ext}}^{21} = \\frac{r^p \\phi_1 - \\phi_2}{r^p - 1} $$\n这个表达式可以重写，以突出对细网格解的修正：\n$$ \\phi_{\\text{ext}}^{21} = \\frac{r^p \\phi_1 - \\phi_1 + \\phi_1 - \\phi_2}{r^p - 1} = \\frac{\\phi_1(r^p - 1)}{r^p - 1} + \\frac{\\phi_1 - \\phi_2}{r^p - 1} = \\phi_1 + \\frac{\\phi_1 - \\phi_2}{r^p - 1} $$\n细网格上的近似绝对误差 $E_a^{21}$，由该修正项的量值估计：\n$$ E_a^{21} = |\\phi_1 - \\phi_{\\text{ext}}^{21}| = \\left| \\frac{\\phi_2 - \\phi_1}{r^p - 1} \\right| $$\n细网格上的近似相对误差 $e_a^{21}$，是此绝对误差用细网格解归一化得到：\n$$ e_a^{21} = \\left| \\frac{E_a^{21}}{\\phi_1} \\right| = \\left| \\frac{\\frac{\\phi_2 - \\phi_1}{r^p - 1}}{\\phi_1} \\right| $$\n网格收敛指数 $\\mathrm{GCI}_{21}$ 定义为此相对误差估计乘以一个安全因子 $F_s$，以提供一个保守的误差界：\n$$ \\mathrm{GCI}_{21} = F_s e_a^{21} = F_s \\left| \\frac{\\frac{\\phi_2 - \\phi_1}{r^p - 1}}{\\phi_1} \\right| = \\frac{F_s}{|\\phi_1|} \\frac{|\\phi_2 - \\phi_1|}{r^p - 1} $$\n这就是所求的 $\\mathrm{GCI}_{21}$ 表达式。\n\n现在，我们使用给定的数据进行数值计算：\n$\\phi_1 = 5.10$，$\\phi_2 = 5.30$，$\\phi_3 = 5.90$，$r=2$ 且 $F_s = 1.25$。\n\n首先，我们计算观测精度阶 $p$：\n解的差值之比为：\n$$ \\frac{\\phi_3 - \\phi_2}{\\phi_2 - \\phi_1} = \\frac{5.90 - 5.30}{5.30 - 5.10} = \\frac{0.60}{0.20} = 3 $$\n根据我们的推导，这个比值等于 $r^p$。因此，$r^p = 2^p = 3$。我们可以显式计算 $p$，尽管这对于下一步来说并非绝对必要。\n$$ p = \\frac{\\ln(3)}{\\ln(2)} \\approx 1.58496 $$\nGCI 计算所需的关键量是 $r^p$，我们已求得其恰好为 $3$。\n\n接下来，我们计算 $\\mathrm{GCI}_{21}$：\n$$ \\mathrm{GCI}_{21} = \\frac{F_s}{|\\phi_1|} \\frac{|\\phi_2 - \\phi_1|}{r^p - 1} $$\n代入数值：\n$$ \\mathrm{GCI}_{21} = \\frac{1.25}{|5.10|} \\frac{|5.30 - 5.10|}{3 - 1} $$\n$$ \\mathrm{GCI}_{21} = \\frac{1.25}{5.10} \\frac{0.20}{2} $$\n$$ \\mathrm{GCI}_{21} = \\frac{1.25}{5.10} \\times 0.10 $$\n$$ \\mathrm{GCI}_{21} = \\frac{0.125}{5.10} \\approx 0.0245098039... $$\n问题要求结果以无量纲小数形式报告，并四舍五入到三位有效数字。\n$$ \\mathrm{GCI}_{21} \\approx 0.0245 $$\n这个值表示，由于离散误差，在包含1.25的安全因子的情况下，细网格解 $\\phi_1$ 的不确定度估计为 $2.45\\%$。",
            "answer": "$$\n\\boxed{0.0245}\n$$"
        },
        {
            "introduction": "时间积分格式的选择对于模拟的效率和可靠性至关重要，特别是对于聚变科学中常见的、存在多个时间尺度的刚性系统。一个方法的稳定性特性，如A-稳定性和L-稳定性，决定了它是否适用于这些具有挑战性的问题。此练习  通过分析一个模型反应扩散方程的几种常见时间积分器来探索这些概念，使您掌握评估和选择适用于刚性物理系统的数值方法的工具。",
            "id": "4061825",
            "problem": "考虑一个简化的磁化等离子体边界中的一维杂质输运模型，其中杂质数密度由一个反应-扩散方程控制。其无量纲形式的控制偏微分方程为\n$$\n\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2} - k\\,u,\n$$\n对于 $x \\in [0,L]$ 和周期性边界条件，其中 $D0$ 是无量纲常数扩散系数，$k \\ge 0$ 是代表有效汇的无量纲线性反应率，$L0$ 是无量纲区域长度。计算聚变科学与工程中的验证、确认和不确定性量化 (VVUQ) 需要（除其他任务外）评估时间积分方法在刚性条件下的稳定性。\n\n用 $N$ 个均匀间隔的点和网格间距 $h = L/N$ 对空间域进行离散化，并使用周期性边界条件下的标准二阶中心差分来近似 $\\partial^2 u / \\partial x^2$，得到一个半离散线性系统\n$$\n\\frac{d \\mathbf{u}}{dt} = A \\mathbf{u},\n$$\n其中 $\\mathbf{u} \\in \\mathbb{R}^N$，$A$ 是表示扩散加反应的循环矩阵。对于周期性边界，$A$ 的特征值是实数且非正的，由下式给出\n$$\n\\lambda_m = -k - \\frac{4D}{h^2}\\sin^2\\!\\left(\\frac{\\pi m}{N}\\right), \\quad m = 0,1,\\ldots,N-1.\n$$\n最负的特征值出现在 $m = N/2$（对于偶数 $N$）处，并简化为\n$$\n\\lambda_{\\min} = -k - \\frac{4D}{h^2}.\n$$\n\n时间积分方法的稳定性分析植根于线性测试方程 $y' = \\lambda y$，其中 $\\lambda \\in \\mathbb{C}$。单步法的绝对稳定函数 $g(\\xi)$ 将 $\\xi = \\Delta t \\lambda$ 映射为每步的放大因子。对于我们关心的方法：\n- 显式 Forward Euler 法有 $g_{\\mathrm{FE}}(\\xi) = 1 + \\xi$。\n- 隐式 Backward Euler 法有 $g_{\\mathrm{BE}}(\\xi) = \\frac{1}{1 - \\xi}$。\n- Crank–Nicolson 法（隐式梯形法则）有 $g_{\\mathrm{CN}}(\\xi) = \\frac{1 + \\xi/2}{1 - \\xi/2}$。\n\n定义：\n- 绝对稳定性（A-稳定性）：如果对于所有满足 $\\mathrm{Re}(\\xi) \\le 0$ 的 $\\xi$，都有 $|g(\\xi)| \\le 1$，则该方法是 A-稳定的。\n- 刚性衰减（L-稳定性）：如果一个 A-稳定的方法满足 $\\lim_{|\\xi|\\to\\infty,\\, \\mathrm{Re}(\\xi) \\le 0} g(\\xi) = 0$，则该方法是 L-稳定的。\n\n任务：\n1. 从离散化算子和对所有满足 $\\mathrm{Re}(\\lambda) \\le 0$ 的 $A$ 的特征值 $\\lambda$ 的稳定性要求 $|g(\\Delta t \\lambda)| \\le 1$ 出发，通过要求在最负特征值处的稳定性，推导出显式 Forward Euler 法的最大稳定时间步长（用 $D$、$k$、$L$ 和 $N$ 表示）。然后，使用该结果定义一个测试时间步长 $\\Delta t_{\\mathrm{test}} = \\alpha \\,\\Delta t_{\\mathrm{FE},\\max}$，其中 $\\alpha0$。\n2. 对每种方法，通过检查 $|g(\\Delta t_{\\mathrm{test}} \\lambda_{\\min})| \\le 1$ 来评估在代表离散系统刚性情况下的 A-稳定性。\n3. 通过使用大的负自变量 $\\xi_{\\mathrm{large}} = -M$（其中 $M \\gg 1$）数值计算刚性极限，并当 $|g(\\xi_{\\mathrm{large}})|  \\varepsilon$ 时（其中 $\\varepsilon$ 是一个小阈值）宣布 L-稳定性成立，来独立评估 L-稳定性。\n4. 将这些结果汇总为一个定量的、可测试的输出，用于一个小测试套件。\n\n所有量均为无量纲。使用以下参数集 $(N, L, D, k, \\alpha, M, \\varepsilon)$ 的测试套件来测试不同的刚性区域：\n- 情况 $1$（理想路径）：$(N, L, D, k, \\alpha, M, \\varepsilon) = (64,\\,1,\\,1,\\,10,\\,10,\\,10^6,\\,10^{-3})$。\n- 情况 $2$（极端刚性的扩散和反应）：$(N, L, D, k, \\alpha, M, \\varepsilon) = (128,\\,1,\\,100,\\,500,\\,10,\\,10^6,\\,10^{-3})$。\n- 情况 $3$（纯反应，无扩散）：$(N, L, D, k, \\alpha, M, \\varepsilon) = (64,\\,1,\\,0,\\,50,\\,10,\\,10^6,\\,10^{-3})$。\n\n对每种情况，计算：\n- 从离散化推导出的 Forward Euler 法的最大稳定时间步长 $\\Delta t_{\\mathrm{FE},\\max}$。\n- Forward Euler、Backward Euler 和 Crank–Nicolson 在 $\\Delta t_{\\mathrm{test}}$ 处的稳定性指标，每个指标都报告为一个由 $|g(\\Delta t_{\\mathrm{test}} \\lambda_{\\min})| \\le 1$ 决定的布尔值。\n- Backward Euler 和 Crank–Nicolson 的 L-稳定性指标，每个指标都报告为一个由 $|g(-M)|  \\varepsilon$ 决定的布尔值。\n\n你的程序应生成单行输出，其中包含结果，形式为按所列顺序排列的三个情况的子列表组成的逗号分隔列表，每个子列表的格式为 $[\\Delta t_{\\mathrm{FE},\\max}, \\mathrm{stable}_{\\mathrm{FE}}, \\mathrm{stable}_{\\mathrm{BE}}, \\mathrm{stable}_{\\mathrm{CN}}, \\mathrm{Lstable}_{\\mathrm{BE}}, \\mathrm{Lstable}_{\\mathrm{CN}}]$，并用方括号括起来。例如，打印的输出应类似于 $[[x_1,b_1,b_2,b_3,b_4,b_5],[x_2,\\ldots],[x_3,\\ldots]]$，其中每个 $x_i$ 是一个浮点数，每个 $b_j$ 是一个布尔值。不应打印任何其他文本。",
            "solution": "该问题被评估为有效，因为它在科学上基于偏微分方程数值分析的原理，其表述清晰、客观且适定，并为其求解提供了完整且一致的数据和定义集。\n\n解决方案的结构如下：\n1.  推导显式 Forward Euler 方法的最大稳定时间步长 $\\Delta t_{\\mathrm{FE},\\max}$。\n2.  在测试时间步长 $\\Delta t_{\\mathrm{test}} = \\alpha \\Delta t_{\\mathrm{FE},\\max}$ 下分析每种方法的稳定性函数。\n3.  分析隐式方法的 L-稳定性属性。\n4.  将这些分析应用于所提供的具体测试用例。\n\n**1. $\\Delta t_{\\mathrm{FE},\\max}$ 的推导**\n\n应用于线性系统 $\\frac{d\\mathbf{u}}{dt} = A\\mathbf{u}$ 的时间积分方法的稳定性由矩阵 $A$ 的特征值决定。绝对稳定性的条件是每个本征模的放大因子 $|g(\\Delta t \\lambda_m)|$ 必须小于或等于 $1$。由于离散化算子的特征值 $\\lambda_m$ 是实数且非正的，因此稳定函数的自变量 $\\xi_m = \\Delta t \\lambda_m$ 也是实数且非正的。\n\n对于显式 Forward Euler (FE) 方法，其稳定函数为 $g_{\\mathrm{FE}}(\\xi) = 1 + \\xi$。稳定性要求是：\n$$\n|g_{\\mathrm{FE}}(\\xi_m)| = |1 + \\Delta t \\lambda_m| \\le 1\n$$\n这个不等式必须对所有特征值 $\\lambda_m$（其中 $m=0, 1, \\dots, N-1$）成立。由于 $\\Delta t  0$ 且 $\\lambda_m \\le 0$，乘积 $\\Delta t \\lambda_m$ 是非正的。该不等式展开为：\n$$\n-1 \\le 1 + \\Delta t \\lambda_m \\le 1\n$$\n各部分减去 $1$ 得到：\n$$\n-2 \\le \\Delta t \\lambda_m \\le 0\n$$\n右侧的不等式 $\\Delta t \\lambda_m \\le 0$ 总是满足的。左侧的不等式给出了稳定性约束：\n$$\n-2 \\le \\Delta t \\lambda_m \\implies \\Delta t \\le \\frac{-2}{\\lambda_m} \\quad (\\text{since } \\lambda_m  0)\n$$\n此条件必须对所有非零特征值成立。最严格的约束来自最负（最大模）的特征值，记为 $\\lambda_{\\min}$。因此，最大稳定时间步长 $\\Delta t_{\\mathrm{FE},\\max}$ 由下式确定：\n$$\n\\Delta t_{\\mathrm{FE},\\max} = \\frac{-2}{\\lambda_{\\min}}\n$$\n问题给出了偶数个网格点 $N$ 时最负特征值的表达式：\n$$\n\\lambda_{\\min} = -k - \\frac{4D}{h^2}\n$$\n代入 $h = L/N$：\n$$\n\\lambda_{\\min} = -k - \\frac{4DN^2}{L^2} = -\\left(k + \\frac{4DN^2}{L^2}\\right)\n$$\n因此，Forward Euler 法的最大稳定时间步长为：\n$$\n\\Delta t_{\\mathrm{FE},\\max} = \\frac{-2}{-\\left(k + \\frac{4DN^2}{L^2}\\right)} = \\frac{2}{k + \\frac{4DN^2}{L^2}}\n$$\n这个公式对于给定的测试用例是良定义的，因为分母 $k + 4DN^2/L^2$ 总是正的（$k \\ge 0, D \\ge 0$，且它们不同时为零）。\n\n**2. 在 $\\Delta t_{\\mathrm{test}}$ 处的稳定性分析**\n\n问题定义了一个测试时间步长 $\\Delta t_{\\mathrm{test}} = \\alpha \\Delta t_{\\mathrm{FE},\\max}$。我们需要为每种方法检查稳定性条件 $|g(\\Delta t_{\\mathrm{test}}\\lambda_{\\min})| \\le 1$。稳定函数的自变量 $\\xi_{\\mathrm{test}}$ 可以大大简化：\n$$\n\\xi_{\\mathrm{test}} = \\Delta t_{\\mathrm{test}} \\lambda_{\\min} = (\\alpha \\Delta t_{\\mathrm{FE},\\max}) \\lambda_{\\min} = \\left(\\alpha \\frac{-2}{\\lambda_{\\min}}\\right) \\lambda_{\\min} = -2\\alpha\n$$\n这个显著的结果表明，在这个特定操作点上的稳定性检查仅取决于参数 $\\alpha$ 和所选的数值方法，而与偏微分方程本身的物理参数 $D, k, L, N$ 无关。\n\n- **Forward Euler (FE)**：$|g_{\\mathrm{FE}}(-2\\alpha)| = |1 + (-2\\alpha)| = |1 - 2\\alpha|$。条件是 $|1-2\\alpha| \\le 1$。对于 $\\alpha = 10$，我们有 $|1-20| = 19$，不满足 $\\le 1$。因此，FE 预期是不稳定的。\n\n- **Backward Euler (BE)**：$|g_{\\mathrm{BE}}(-2\\alpha)| = \\left|\\frac{1}{1 - (-2\\alpha)}\\right| = \\left|\\frac{1}{1 + 2\\alpha}\\right|$。对于 $\\alpha  0$，$1+2\\alpha  1$，所以 $|\\frac{1}{1+2\\alpha}| = \\frac{1}{1+2\\alpha}  1$。该条件总是满足的。因此，BE 是稳定的，这与其 A-稳定性属性相符。\n\n- **Crank–Nicolson (CN)**：$|g_{\\mathrm{CN}}(-2\\alpha)| = \\left|\\frac{1 + (-2\\alpha)/2}{1 - (-2\\alpha)/2}\\right| = \\left|\\frac{1 - \\alpha}{1 + \\alpha}\\right|$。对于 $\\alpha  0$，此值为 $\\frac{|\\alpha-1|}{\\alpha+1}$。条件 $\\frac{|\\alpha-1|}{\\alpha+1} \\le 1$ 等价于 $|\\alpha-1| \\le \\alpha+1$。这对所有 $\\alpha  0$ 都成立。因此，CN 是稳定的，这与其 A-稳定性属性相符。\n\n**3. L-稳定性分析**\n\nL-稳定性要求 A-稳定的方法还需满足 $\\lim_{|\\xi|\\to\\infty, \\mathrm{Re}(\\xi)  0} g(\\xi) = 0$。我们通过对 $\\xi_{\\mathrm{large}} = -M$（其中 $M \\gg 1$）计算 $|g(\\xi_{\\mathrm{large}})|  \\varepsilon$ 来进行数值检验。\n\n- **Backward Euler (BE)**：$|g_{\\mathrm{BE}}(-M)| = \\left|\\frac{1}{1 - (-M)}\\right| = \\frac{1}{1+M}$。当 $M \\to \\infty$ 时，此极限为 $0$。数值检验是 $\\frac{1}{1+M}  \\varepsilon$。对于给定的参数 $M=10^6$ 和 $\\varepsilon=10^{-3}$，我们有 $1/(10^6+1) \\approx 10^{-6}$，它小于 $10^{-3}$。BE 是 L-稳定的。\n\n- **Crank–Nicolson (CN)**：$|g_{\\mathrm{CN}}(-M)| = \\left|\\frac{1 + (-M)/2}{1 - (-M)/2}\\right| = \\left|\\frac{1 - M/2}{1 + M/2}\\right|$。当 $M \\to \\infty$ 时，此极限趋近于 $\\left|\\frac{-M/2}{M/2}\\right| = 1$。数值检验是判断该值是否小于 $\\varepsilon$。对于大的 $M$，该值非常接近 $1$。对于给定的参数，$1$ 不小于 $10^{-3}$。CN 不是 L-稳定的。\n\n**4. 测试用例的计算**\n\n在 $\\Delta t_{\\mathrm{test}}$ 处的稳定性和 L-稳定性的布尔结果对于所有测试用例都是相同的，因为它们仅取决于 $\\alpha$、$M$ 和 $\\varepsilon$，这些值在所有情况中都是常数（或者说 $\\alpha$ 是常数，而 $M, \\varepsilon$ 是常数）。\n- $\\mathrm{stable}_{\\mathrm{FE}}$：$|1 - 2(10)| \\le 1 \\implies 19 \\le 1 \\implies \\text{False}$\n- $\\mathrm{stable}_{\\mathrm{BE}}$：$|\\frac{1}{1+2(10)}| \\le 1 \\implies \\frac{1}{21} \\le 1 \\implies \\text{True}$\n- $\\mathrm{stable}_{\\mathrm{CN}}$：$|\\frac{1-10}{1+10}| \\le 1 \\implies \\frac{9}{11} \\le 1 \\implies \\text{True}$\n- $\\mathrm{Lstable}_{\\mathrm{BE}}$：$\\frac{1}{1+10^6}  10^{-3} \\implies \\text{True}$\n- $\\mathrm{Lstable}_{\\mathrm{CN}}$：$|\\frac{1-10^6/2}{1+10^6/2}|  10^{-3} \\implies \\frac{499999}{500001}  0.001 \\implies \\text{False}$\n\n唯一变化的值是 $\\Delta t_{\\mathrm{FE},\\max}$。\n- **情况 1**：$(N, L, D, k) = (64, 1, 1, 10)$\n  $\\Delta t_{\\mathrm{FE},\\max} = \\frac{2}{10 + 4(1)(64)^2/(1)^2} = \\frac{2}{10 + 16384} = \\frac{2}{16394} \\approx 1.2200195 \\times 10^{-4}$\n\n- **情况 2**：$(N, L, D, k) = (128, 1, 100, 500)$\n  $\\Delta t_{\\mathrm{FE},\\max} = \\frac{2}{500 + 4(100)(128)^2/(1)^2} = \\frac{2}{500 + 400(16384)} = \\frac{2}{500 + 6553600} = \\frac{2}{6554100} \\approx 3.0515155 \\times 10^{-7}$\n\n- **情况 3**：$(N, L, D, k) = (64, 1, 0, 50)$\n  $\\Delta t_{\\mathrm{FE},\\max} = \\frac{2}{50 + 4(0)(64)^2/(1)^2} = \\frac{2}{50} = 0.04$\n\n这些理论结果将在提供的 Python 脚本中实现。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical stability problem for three test cases.\n    \"\"\"\n    # Test suite of parameter sets: (N, L, D, k, alpha, M, epsilon)\n    test_cases = [\n        # Case 1 (happy path)\n        (64, 1.0, 1.0, 10.0, 10.0, 1.0e6, 1.0e-3),\n        # Case 2 (extremely stiff diffusion and reaction)\n        (128, 1.0, 100.0, 500.0, 10.0, 1.0e6, 1.0e-3),\n        # Case 3 (pure reaction, no diffusion)\n        (64, 1.0, 0.0, 50.0, 10.0, 1.0e6, 1.0e-3),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, L, D, k, alpha, M, epsilon = case\n\n        # 1. Calculate the largest stable time step for Forward Euler.\n        # The denominator is k + 4*D*N^2/L^2.\n        # Problem constraints (k=0, D=0, not both zero) ensure the denominator is positive.\n        denominator = k + 4.0 * D * (N**2) / (L**2)\n        dt_fe_max = 2.0 / denominator\n\n        # 2. Assess stability at dt_test for each method.\n        # The argument to the stability function g(xi) is xi = -2*alpha.\n        # This makes the stability check independent of the physical parameters N, L, D, k.\n        \n        # Forward Euler stability function g_FE(xi) = 1 + xi\n        stable_fe = abs(1.0 - 2.0 * alpha) = 1.0\n        \n        # Backward Euler stability function g_BE(xi) = 1 / (1 - xi)\n        stable_be = abs(1.0 / (1.0 - (-2.0 * alpha))) = 1.0\n        \n        # Crank-Nicolson stability function g_CN(xi) = (1 + xi/2) / (1 - xi/2)\n        stable_cn = abs((1.0 + (-2.0 * alpha) / 2.0) / (1.0 - (-2.0 * alpha) / 2.0)) = 1.0\n\n        # 3. Assess L-stability for implicit methods.\n        # The argument is xi = -M. This check is independent of N, L, D, k, alpha.\n\n        # Backward Euler L-stability\n        g_be_large = 1.0 / (1.0 - (-M))\n        lstable_be = abs(g_be_large)  epsilon\n        \n        # Crank-Nicolson L-stability\n        g_cn_large = (1.0 + (-M) / 2.0) / (1.0 - (-M) / 2.0)\n        lstable_cn = abs(g_cn_large)  epsilon\n\n        # 4. Aggregate results for the current case.\n        case_result = [dt_fe_max, stable_fe, stable_be, stable_cn, lstable_be, lstable_cn]\n        all_results.append(case_result)\n\n    # Format the final output string exactly as required.\n    # e.g., [[x1,b1,b2,b3,b4,b5],[x2,...],[x3,...]]\n    result_strings = []\n    for res in all_results:\n        # Convert each item in the list to its string representation.\n        # str(True) -> 'True', str(False) -> 'False'\n        # str(float) -> standard float representation\n        res_str = f\"[{','.join(map(str, res))}]\"\n        result_strings.append(res_str)\n\n    # Join the individual case strings into the final output format.\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}