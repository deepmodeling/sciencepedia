{
    "hands_on_practices": [
        {
            "introduction": "在聚变等离子体中，诊断设备在空间上的离散分布直接决定了我们解析等离子体波动结构的能力。本练习将引导你从第一性原理出发，推导在托卡马克环形几何中，离散探头布置如何导致空间模式的混叠。通过这个推导，你将确定唯一识别特定范围环向模数所需的最小探头数量，这是诊断设计和数据解释的一项核心技能 。",
            "id": "4024285",
            "problem": "在一个环向磁约束装置中，一组 $N$ 个相同的拾取线圈安装在均匀间隔的环向角 $\\phi_{j} = \\frac{2\\pi j}{N}$ 处，其中 $j \\in \\{0,1,\\ldots,N-1\\}$。测量的信号是一个环向周期场 $B(\\phi)$，它可以分解为以整数环向模数 $n \\in \\mathbb{Z}$ 表示的傅里叶级数，即 $B(\\phi) = \\sum_{n \\in \\mathbb{Z}} A_{n} \\exp(i n \\phi)$，其中 $A_{n} \\in \\mathbb{C}$ 是复振幅，$\\phi$ 以弧度为单位。该仪器同时记录所有 $N$ 个位置的 $B(\\phi_{j})$，并且希望使用离散傅里叶分析从这些样本中推断出 $B(\\phi)$ 的环向模数成分，这在计算分析以及计算聚变科学与工程中基于快速傅里叶变换(FFT)的处理流程中是标准做法。\n\n仅从周期域上均匀角度采样的定义以及 $B(\\phi)$ 的整数谐波表示出发，不引用任何预先给出的混叠公式，回答以下问题：\n\n- 推导一个充分必要条件，在该条件下，两个不同的整数环向模数 $n,n' \\in \\mathbb{Z}$ 在所有 $N$ 个探头上产生相同的采样值。表示出与给定模数 $n$ 不可区分的所有模数 $n'$ 的集合。\n\n- 假设物理和诊断方面的考虑意味着存在一个严格的带限 $|n| \\le n_{\\max}$，其中 $n_{\\max} \\ge 1$ 是某个已知的有限整数。确定最小整数 $N_{\\min}$，使得对于每个满足 $|n| \\le n_{\\max}$ 的容许模数，在 $N_{\\min}$ 个探头上采样时，没有其他容许的模数与之不可区分。\n\n用 $n_{\\max}$ 的闭式解析表达式表示你的最终答案。最终答案不需要单位。角度以弧度为单位。",
            "solution": "该问题要求我们首先推导两个不同环向模在被有限数量的探头采样时变得不可区分的条件，其次，确定唯一识别指定带限内所有模所需的最小探头数量。我们将从所提供的定义出发进行形式推导。\n\n首先，我们来解决不可区分性的条件。一个模数为 $n \\in \\mathbb{Z}$ 的单一环向模由复指数函数 $\\exp(i n \\phi)$ 表示。如果两个不同的整数模数 $n$ 和 $n'$ 对应的基函数在所有 $N$ 个采样位置 $\\phi_j = \\frac{2\\pi j}{N}$（其中 $j \\in \\{0, 1, \\ldots, N-1\\}$）上产生相同的值，那么我们称它们对于该测量系统是不可区分的或“混叠”的。这个条件在数学上表示为：\n$$ \\exp(i n \\phi_j) = \\exp(i n' \\phi_j) \\quad \\forall j \\in \\{0, 1, \\ldots, N-1\\} $$\n将两边同时除以 $\\exp(i n' \\phi_j)$（它永远不为零），我们得到：\n$$ \\exp(i n \\phi_j - i n' \\phi_j) = 1 $$\n$$ \\exp\\left(i (n - n') \\phi_j\\right) = 1 $$\n代入采样角 $\\phi_j$ 的定义：\n$$ \\exp\\left(i (n - n') \\frac{2\\pi j}{N}\\right) = 1 $$\n复指数 $\\exp(i\\theta)$ 等于 $1$ 的充分必要条件是其参数 $\\theta$ 是 $2\\pi$ 的整数倍。因此，对于每个 $j$，必须存在一个整数 $k_j$ 使得：\n$$ (n - n') \\frac{2\\pi j}{N} = 2\\pi k_j $$\n这可以简化为条件：对于所有 $j \\in \\{0, 1, \\ldots, N-1\\}$，$(n - n') \\frac{j}{N}$ 必须是整数。\n对于 $j=0$，条件是 $0 = 0$，这是平凡满足的，不提供任何约束。\n我们来考虑 $j=1$ 的情况。条件要求 $(n - n') \\frac{1}{N}$ 必须是整数。设这个整数为 $m \\in \\mathbb{Z}$。\n$$ \\frac{n - n'}{N} = m $$\n$$ n - n' = mN $$\n这是一个从 $j=1$ 的情况推导出的必要条件。我们现在必须验证它对于所有其他 $j$ 值是否充分。如果我们假设 $n - n' = mN$ 对于某个整数 $m$ 成立，那么我们指数方程的左边变为：\n$$ \\exp\\left(i (mN) \\frac{2\\pi j}{N}\\right) = \\exp(i m j 2\\pi) $$\n由于 $m$ 和 $j$ 都是整数，它们的乘积 $mj$ 也是整数。指数函数参数中 $2\\pi i$ 的任何整数倍都会导致结果为 $1$。因此，该条件对所有 $j$ 都成立。\n题目说明模是不同的，所以 $n \\neq n'$，这意味着 $m \\neq 0$。\n因此，两个不同的整数环向模数 $n$ 和 $n'$ 不可区分的充分必要条件是它们的差是采样数 $N$ 的一个非零整数倍。与给定模 $n$ 不可区分的所有模数 $n'$ 的集合由下式给出：\n$$ \\{ n' \\in \\mathbb{Z} \\mid n' = n + mN, \\text{ for some } m \\in \\mathbb{Z} \\} $$\n\n接下来，我们处理问题的第二部分。我们给定一个严格的带限，使得唯一物理上相关的模是那些满足 $|n| \\le n_{\\max}$ 的模，其中 $n_{\\max} \\ge 1$ 是某个整数。容许的模数集合是 $\\mathcal{S} = \\{n \\in \\mathbb{Z} \\mid -n_{\\max} \\le n \\le n_{\\max}\\}$。我们必须找到探头的最小数量 $N_{\\min}$，使得该集合内任意两个不同的模都不是不可区分的。\n\n这意味着对于任何两个不同的模 $n, n' \\in \\mathcal{S}$（即 $n \\neq n'$），它们必须是可区分的。这等价于要求对于 $\\mathcal{S}$ 中任何一对不同的模，不可区分的条件永远不会满足。根据我们之前的推导，这意味着我们必须确保：\n$$ n - n' \\neq mN \\quad \\forall n, n' \\in \\mathcal{S} \\text{ with } n \\neq n', \\text{ and } \\forall m \\in \\mathbb{Z} \\setminus \\{0\\} $$\n让我们分析差值 $n - n'$ 的可能取值范围。由于 $n, n' \\in [-n_{\\max}, n_{\\max}]$，该差值的最大可能值为 $n_{\\max} - (-n_{\\max}) = 2n_{\\max}$，最小值为 $-n_{\\max} - n_{\\max} = -2n_{\\max}$。由于 $n \\neq n'$，差值 $n - n'$ 是一个非零整数。因此，所有可能差值的集合是：\n$$ \\Delta = \\{ k \\in \\mathbb{Z} \\mid -2n_{\\max} \\le k \\le 2n_{\\max}, k \\neq 0 \\} $$\n要求对于任何非零整数 $m$，都有 $n - n' \\neq mN$，这意味着 $N$ 的任何非零倍数都不能是集合 $\\Delta$ 中的元素。$N$ 的非零倍数是 $\\{ \\pm N, \\pm 2N, \\pm 3N, \\ldots \\}$。为确保与 $\\Delta$ 没有重叠，$N$ 的非零倍数的最小绝对值（即 $N$ 本身，因为 $N \\ge 1$）必须大于 $\\Delta$ 中任何元素的最大绝对值。\n$\\Delta$ 中的最大绝对值是 $|2n_{\\max}| = 2n_{\\max}$。\n所以，我们必须满足以下条件：\n$$ N  2n_{\\max} $$\n问题要求满足此条件的最小整数 $N_{\\min}$。严格大于 $2n_{\\max}$ 的最小整数是 $2n_{\\max} + 1$。\n因此，$N_{\\min} = 2n_{\\max} + 1$。\n\n为了验证这一结果，让我们考虑 $N = 2n_{\\max}$ 的情况。如果我们选择 $n=n_{\\max}$ 和 $n'=-n_{\\max}$，这两个模都在容许集合 $\\mathcal{S}$ 中。它们的差是 $n-n' = n_{\\max}-(-n_{\\max}) = 2n_{\\max} = 1 \\cdot N$。由于它们的差是 $N$ 的倍数，这两个模会发生混叠，因此不可区分。这证实了 $N=2n_{\\max}$ 是不够的。因此，所需的最小整数探头数确实是 $2n_{\\max} + 1$。这对应于奈奎斯特-香农采样定理应用于一个周期信号，其傅里叶谱包含在模数范围 $[-n_{\\max}, n_{\\max}]$ 内，总跨度为 $2n_{\\max}$。",
            "answer": "$$\\boxed{2n_{\\max} + 1}$$"
        },
        {
            "introduction": "从实验或模拟中获得的信号进行傅里叶变换是等离子体物理研究中的常用方法，但对频谱的正确解读至关重要。本练习通过一个编码实践，清晰地揭示了谱分辨率和谱采样密度之间的本质区别 。你将通过零填充技术看到，谱分辨率由观测时长 $T_{\\text{obs}}$ 决定，而增加FFT点数仅是增加了谱的插值点，并不能提高真实的分辨能力，从而避免在数据分析中得出错误结论。",
            "id": "4024315",
            "problem": "考虑一个合成的磁涨落信号，该信号代表了在环形聚变装置中测量的等离子体模式。该信号被建模为两个相干模与弱宽带湍流之和，在有限的观测时间内进行均匀采样。设采样率为每秒 $f_s$ 个样本，采集的样本数为 $N_0$，总观测时间为 $T_{\\text{obs}} = N_0 / f_s$。您将比较两个离散谱：一个是采集到的 $N_0$ 个样本的离散傅里叶变换（DFT），另一个是将时间序列补零至更长长度 $N_{\\text{fft}}$（其中 $N_{\\text{fft}} = \\text{pad\\_factor} \\times N_0$）后的DFT。目标是从第一性原理出发，证明补零只增加了频谱采样密度（即更多的DFT点），而不会改变由有限观测时间决定的固有分辨率。\n\n您的任务是：\n\n1. 生成一个离散时间信号 $x[n]$，其中 $n = 0,1,\\dots,N_0-1$，采样间隔 $\\Delta t = 1/f_s$，形式如下\n$$\nx[n] = A_1 \\sin\\left(2\\pi f_1 n \\Delta t \\right) + A_2 \\sin\\left(2\\pi f_2 n \\Delta t \\right) + \\eta[n],\n$$\n其中 $A_1$ 和 $A_2$ 是振幅，$\\eta[n]$ 是方差很小的独立同分布零均值高斯噪声。这两个相干分量可以解释为，例如，等离子体中存在的阿尔芬模和漂移波模。假设 $f_1$ 和 $f_2$ 严格低于奈奎斯特频率 $f_s/2$。\n\n2. 使用快速傅里叶变换（FFT）计算两个单边幅值谱：一个使用原始长度 $N_0$，另一个使用补零后的长度 $N_{\\text{fft}}$。对于两者，都使用返回非负频率分量的实数到复数FFT。设相应的离散频率数组为 $f_k^{(0)}$ 和 $f_k^{(\\text{pad})}$，幅值为 $|X^{(0)}[k]|$ 和 $|X^{(\\text{pad})}[k]|$。\n\n3. 根据有限观测时间，确定其所蕴含的固有分辨率，记为 $\\Delta f_{\\text{intrinsic}}$，并仅从观测时间 $T_{\\text{obs}}$ 推导。以赫兹（Hz）为单位表示 $\\Delta f_{\\text{intrinsic}}$。\n\n4. 确定未补零和补零后频谱的频谱采样密度，其定义为DFT频点间隔。设 $\\Delta f_{\\text{bin}}^{(0)}$ 为未补零的频点间隔，$\\Delta f_{\\text{bin}}^{(\\text{pad})}$ 为补零后的频点间隔。两者都以赫兹（Hz）为单位表示。\n\n5. 对每个频谱执行一个考虑分辨率的峰值计数程序，如下所示：\n   - 在幅值谱 $|X[k]|$ 中识别局部最大值，其值超过全局最大幅值的一小部分（使用固定的0.2倍最大值）。\n   - 使用相应的 $f_k$ 数组将峰值索引转换为频率位置。\n   - 将间隔小于 $\\Delta f_{\\text{intrinsic}}$ 的峰值聚类为单个可分辨特征。将聚类的数量计为可分辨峰的数量。\n\n6. 对于下面的每个测试案例，计算并报告一个五元列表 $[\\Delta f_{\\text{intrinsic}}, \\Delta f_{\\text{bin}}^{(0)}, \\Delta f_{\\text{bin}}^{(\\text{pad})}, N_{\\text{res}}^{(0)}, N_{\\text{res}}^{(\\text{pad})}]$，其中 $N_{\\text{res}}^{(0)}$ 和 $N_{\\text{res}}^{(\\text{pad})}$ 是整数，分别代表未补零和补零后频谱中可分辨峰的数量。\n\n使用以下测试套件，该套件设计用于探测与计算聚变信号分析相关的典型、边界和亚分辨率情况。在所有情况下，使用 $A_1 = A_2 = 1$，噪声标准差为 $0.02$（单位与 $x[n]$ 相同）：\n- 案例1（典型分离）：$f_s = 20000$ Hz, $N_0 = 2048$, $\\text{pad\\_factor} = 8$, $f_1 = 1200$ Hz, $f_2 = f_1 + 5 \\times \\Delta f_{\\text{intrinsic}}$。\n- 案例2（类瑞利边界）：$f_s = 20000$ Hz, $N_0 = 2048$, $\\text{pad\\_factor} = 8$, $f_1 = 3000$ Hz, $f_2 = f_1 + \\Delta f_{\\text{intrinsic}}$。\n- 案例3（亚分辨率分离）：$f_s = 20000$ Hz, $N_0 = 2048$, $\\text{pad\\_factor} = 8$, $f_1 = 4500$ Hz, $f_2 = f_1 + 0.6 \\times \\Delta f_{\\text{intrinsic}}$。\n\n要求：\n- 所有频率量均以赫兹（Hz）表示。\n- 最终程序输出必须是单行，包含一个由逗号分隔的三个五元列表组成的列表，并用方括号括起来，严格按照测试案例的顺序排列。例如，输出必须类似于 $[[a_1,a_2,a_3,a_4,a_5],[b_1,b_2,b_3,b_4,b_5],[c_1,c_2,c_3,c_4,c_5]]$，其中每个 $a_i, b_i, c_i$ 是一个数字（计数为整数，频率量为浮点数，单位为赫兹）。",
            "solution": "该问题要求对离散谱进行分析，以证明频谱分辨率是总观测时间的函数，而不是离散傅里叶变换（DFT）中点数的函数，后者可以通过补零被人为增加。这是信号处理中的一个基本概念，其根源在于傅里叶变换的性质。\n\n### 理论原理\n\n1.  **有限观测与频谱泄漏**：任何测量在时长上都是有限的。一个在时间间隔 $T_{\\text{obs}}$ 内观测到的信号 $x(t)$，在数学上可以建模为“真实”的无限信号乘以一个矩形窗函数 $w(t)$，该窗函数在观测期间为 $1$，其余时间为 $0$。根据卷积定理，时域中的这种乘法对应于频域中的卷积。矩形窗函数的傅里叶变换是一个 sinc 函数：$\\text{FT}\\{w(t)\\} \\propto \\text{sinc}(\\pi f T_{\\text{obs}})$，其中 $f$ 是频率。因此，任何信号分量（例如，纯正弦波，在频域中是一个 delta 函数）的测量谱都与此 sinc 函数进行卷积。这将尖锐谱线的能量扩散成一个带有旁瓣的宽峰，这种现象称为频谱泄漏。\n\n2.  **固有分辨率**：区分两个相邻频率分量的能力称为频谱分辨率。适用于此背景的瑞利判据指出，如果一个分量的 sinc 图案的峰值与另一个分量的第一个零点重合，则这两个分量刚好可分辨。$\\text{sinc}(\\pi f T_{\\text{obs}})$ 函数的第一个零点出现在 $f = \\pm 1/T_{\\text{obs}}$ 处。因此，最小可分辨频率间隔由观测时间决定。这给出了固有频率分辨率：\n    $$\n    \\Delta f_{\\text{intrinsic}} = \\frac{1}{T_{\\text{obs}}} = \\frac{f_s}{N_0}\n    $$\n    其中 $f_s$ 是采样率，$N_0$ 是样本数。这个分辨率极限是根本性的，无法通过对采集到的 $N_0$ 个样本进行后处理来克服。\n\n3.  **DFT 频点间隔与分辨率**：离散傅里叶变换（DFT）计算的是离散频率点（或称“频点”）上的频谱。对于长度为 $N_{\\text{fft}}$ 的 DFT，这些频点之间的间隔为：\n    $$\n    \\Delta f_{\\text{bin}} = \\frac{f_s}{N_{\\text{fft}}}\n    $$\n    在进行DFT之前，将时域信号从其原始长度 $N_0$ 补零至新的长度 $N_{\\text{fft}}  N_0$ 并不会增加新信息或增加 $T_{\\text{obs}}$。它只会增加 $N_{\\text{fft}}$。这减小了频点间隔 $\\Delta f_{\\text{bin}}$，实际上是对频谱进行插值。它提供了一个采样更密集、看起来更平滑的 underlying sinc 形频谱特征图，但它并不改变这些特征的宽度。因此，补零提高了*频谱采样密度*，但没有提高*固有分辨率*。\n\n### 算法流程\n\n遵循这些原理，通过实现指定的流程来解决该问题。\n\n1.  **信号生成**：对于每个测试案例，合成一个离散时间信号 $x[n]$。它包含两个振幅为 $A_1=1$ 和 $A_2=1$、频率为 $f_1$ 和 $f_2$ 的正弦波，外加标准差为 $0.02$ 的零均值高斯噪声 $\\eta[n]$。时间轴由 $n=0, 1, \\dots, N_0-1$ 定义，采样间隔为 $\\Delta t = 1/f_s$。\n\n2.  **参数计算**：为每个案例计算关键的频率度量。给定 $f_s = 20000$ Hz 和 $N_0 = 2048$：\n    -   观测时间: $T_{\\text{obs}} = N_0/f_s = 2048 / 20000 = 0.1024$ s。\n    -   固有分辨率: $\\Delta f_{\\text{intrinsic}} = 1/T_{\\text{obs}} = 1/0.1024 \\approx 9.7656$ Hz。\n    -   未补零频点间隔: $\\Delta f_{\\text{bin}}^{(0)} = f_s/N_0 = 20000/2048 \\approx 9.7656$ Hz。注意 $\\Delta f_{\\text{intrinsic}} = \\Delta f_{\\text{bin}}^{(0)}$。\n    -   补零后长度: $N_{\\text{fft}} = \\text{pad\\_factor} \\times N_0 = 8 \\times 2048 = 16384$。\n    -   补零后频点间隔: $\\Delta f_{\\text{bin}}^{(\\text{pad})} = f_s/N_{\\text{fft}} = 20000/16384 \\approx 1.2207$ Hz。\n\n3.  **频谱分析**：对于长度为 $N_0$ 的原始信号和长度为 $N_{\\text{fft}}$ 的补零信号，使用实数到复数的快速傅里叶变换（`scipy.fft.rfft`）计算单边幅值谱。这会产生幅值数组 $|X^{(0)}[k]|$ 和 $|X^{(\\text{pad})}[k]|$ 以及它们对应的频率数组 $f_k^{(0)}$ 和 $f_k^{(\\text{pad})}$。\n\n4.  **考虑分辨率的峰值计数**：一个自定义程序确定可分辨峰的数量。\n    a.  识别幅值谱中的局部最大值。如果一个点 $|X[k]|$ 大于其紧邻的邻居 $|X[k-1]|$ 和 $|X[k+1]|$，则它是一个局部最大值。\n    b.  筛选这些最大值，只保留那些超过频谱全局最大值 $0.2$ 倍阈值的点。此步骤可剔除由噪声引起的次要峰值。\n    c.  收集幸存峰值的频率。\n    d.  对峰值进行聚类。从频率最低的峰值开始，如果后续峰值与排序列表中前一个峰值的频率间隔小于 $\\Delta f_{\\text{intrinsic}}$，则将它们分到同一聚类中。如果间隔更大，则开始一个新的聚类。\n    e.  聚类的总数 $N_{\\text{res}}$ 即为可分辨频谱特征的数量。此过程应用于未补零和补零后的频谱。\n\n### 分情况讨论结果\n\n对三个指定的测试案例执行此流程。\n\n-   **案例1（典型分离）**：$f_2 - f_1 = 5 \\times \\Delta f_{\\text{intrinsic}} \\approx 48.83$ Hz。频率分离得很好。分析正确地在未补零和补零后的频谱中识别出两个不同的峰。我们预期 $N_{\\text{res}}^{(0)} = 2$ 和 $N_{\\text{res}}^{(\\text{pad})} = 2$。\n\n-   **案例2（类瑞利边界）**：$f_2 - f_1 = \\Delta f_{\\text{intrinsic}} \\approx 9.77$ Hz。频率间隔恰好等于固有分辨率极限。频谱特征（sinc 函数）显著重叠，但两个主峰之间应仍存在一个凹陷，使得局部最大值查找器能够识别出两个峰。两种分析都应能分辨它们，得出 $N_{\\text{res}}^{(0)} = 2$ 和 $N_{\\text{res}}^{(\\text{pad})} = 2$。补零谱通过更好地采样连续形状，在视觉上更清晰地显示了两个峰的存在。\n\n-   **案例3（亚分辨率分离）**：$f_2 - f_1 = 0.6 \\times \\Delta f_{\\text{intrinsic}} \\approx 5.86$ Hz。频率比分辨率极限更近。两个重叠的 sinc 图案合并成一个更宽的单峰。峰值计数算法在感兴趣的区域只会找到一个局部最大值。两种分析都应无法分辨这两个模式，得出 $N_{\\text{res}}^{(0)} = 1$ 和 $N_{\\text{res}}^{(\\text{pad})} = 1$。这个案例至关重要地表明，补零尽管使单峰的形状更平滑，却无法分离不可分辨的分量。\n\n最终输出将包含每个案例的五元列表 $[\\Delta f_{\\text{intrinsic}}, \\Delta f_{\\text{bin}}^{(0)}, \\Delta f_{\\text{bin}}^{(\\text{pad})}, N_{\\text{res}}^{(0)}, N_{\\text{res}}^{(\\text{pad})}]$, 证实了在所有情况下 $N_{\\text{res}}^{(0)}$ 和 $N_{\\text{res}}^{(\\text{pad})}$ 都是相同的，从而验证了基本原理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef count_resolved_peaks(mag_spec, freq_array, delta_f_intrinsic, threshold_frac=0.2):\n    \"\"\"\n    Identifies and clusters peaks in a spectrum to count resolvable features.\n    \n    Args:\n        mag_spec (np.ndarray): The magnitude spectrum.\n        freq_array (np.ndarray): The corresponding frequency array.\n        delta_f_intrinsic (float): The intrinsic frequency resolution.\n        threshold_frac (float): Fraction of the global maximum for peak thresholding.\n        \n    Returns:\n        int: The number of resolvable peaks (clusters).\n    \"\"\"\n    if len(mag_spec)  3:\n        return 0\n\n    global_max = np.max(mag_spec)\n    if global_max == 0:\n        return 0\n    threshold = threshold_frac * global_max\n\n    # Find indices of all local maxima\n    local_max_indices = []\n    for i in range(1, len(mag_spec) - 1):\n        if mag_spec[i] > mag_spec[i-1] and mag_spec[i] > mag_spec[i+1]:\n            local_max_indices.append(i)\n\n    # Filter maxima by the amplitude threshold\n    peak_indices = [i for i in local_max_indices if mag_spec[i] > threshold]\n    \n    if not peak_indices:\n        return 0\n\n    # Get frequencies of the filtered peaks\n    peak_freqs = freq_array[peak_indices]\n    \n    # Cluster peaks based on intrinsic resolution\n    clusters = [[peak_freqs[0]]]\n    for i in range(1, len(peak_freqs)):\n        freq = peak_freqs[i]\n        # Compare with the last frequency in the last cluster\n        if freq - clusters[-1][-1]  delta_f_intrinsic:\n            clusters[-1].append(freq)\n        else:\n            # Start a new cluster\n            clusters.append([freq])\n            \n    return len(clusters)\n\ndef analyze_case(fs, N0, pad_factor, f1_base, f2_offset_factor, A1, A2, noise_stddev, seed):\n    \"\"\"\n    Performs the full analysis for a single test case.\n    \n    Args:\n        fs (float): Sampling frequency in Hz.\n        N0 (int): Number of initial samples.\n        pad_factor (int): Zero-padding factor.\n        f1_base (float): Base frequency for the first sinusoid in Hz.\n        f2_offset_factor (float): Multiplier for delta_f_intrinsic to get f2's offset.\n        A1 (float): Amplitude of the first sinusoid.\n        A2 (float): Amplitude of the second sinusoid.\n        noise_stddev (float): Standard deviation of the Gaussian noise.\n        seed (int): Seed for the random number generator.\n        \n    Returns:\n        list: A five-element list with the analysis results.\n    \"\"\"\n    # 1. Calculate intrinsic resolution and bin spacings\n    T_obs = N0 / fs\n    delta_f_intrinsic = 1.0 / T_obs\n    \n    delta_f_bin_0 = fs / N0\n    \n    N_fft = pad_factor * N0\n    delta_f_bin_pad = fs / N_fft\n\n    # Determine component frequencies for the case\n    f1 = f1_base\n    f2 = f1_base + f2_offset_factor * delta_f_intrinsic\n\n    # 2. Generate the signal\n    rng = np.random.default_rng(seed)\n    delta_t = 1.0 / fs\n    n = np.arange(N0)\n    t = n * delta_t\n    noise = rng.normal(loc=0.0, scale=noise_stddev, size=N0)\n    x = A1 * np.sin(2 * np.pi * f1 * t) + A2 * np.sin(2 * np.pi * f2 * t) + noise\n\n    # 3. Analyze unpadded spectrum\n    X0_k = fft.rfft(x)\n    mag_X0 = np.abs(X0_k)\n    freqs_0 = fft.rfftfreq(N0, d=delta_t)\n    N_res_0 = count_resolved_peaks(mag_X0, freqs_0, delta_f_intrinsic)\n\n    # 4. Analyze zero-padded spectrum\n    Xpad_k = fft.rfft(x, n=N_fft)\n    mag_Xpad = np.abs(Xpad_k)\n    freqs_pad = fft.rfftfreq(N_fft, d=delta_t)\n    N_res_pad = count_resolved_peaks(mag_Xpad, freqs_pad, delta_f_intrinsic)\n    \n    return [delta_f_intrinsic, delta_f_bin_0, delta_f_bin_pad, N_res_0, N_res_pad]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Define common parameters for all test cases\n    common_params = {\n        'fs': 20000.0,\n        'N0': 2048,\n        'pad_factor': 8,\n        'A1': 1.0,\n        'A2': 1.0,\n        'noise_stddev': 0.02\n    }\n\n    # Define the specific parameters for each test case\n    test_cases = [\n        # (f1_base, f2_offset_factor, seed)\n        {'f1_base': 1200.0, 'f2_offset_factor': 5.0, 'seed': 42}, # Case 1\n        {'f1_base': 3000.0, 'f2_offset_factor': 1.0, 'seed': 43}, # Case 2\n        {'f1_base': 4500.0, 'f2_offset_factor': 0.6, 'seed': 44}  # Case 3\n    ]\n    \n    results = []\n    for case_params in test_cases:\n        # Combine common and case-specific parameters\n        params = {**common_params, **case_params}\n        res = analyze_case(**params)\n        results.append(res)\n    \n    # Format the final output string exactly as required\n    case_results_str = []\n    for case_result in results:\n        case_results_str.append(f\"[{','.join(map(str, case_result))}]\")\n    \n    final_output = f\"[{','.join(case_results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "现代聚变实验会产生海量的高速诊断数据，如何有效处理这些数据是一个现实的工程挑战。本练习模拟了在数据采集中设计一个多级抽取系统的过程，这是一种降低数据率的常用技术 。通过此实践，你将应用抗混叠滤波原理来设计一个实用的滤波器链，以确保在降低采样率的同时，关键的物理信号信息得以完整保留而不被破坏。",
            "id": "4024333",
            "problem": "您正在为计算聚变科学与工程中的干涉仪数据设计一个多级抽取链。目标是使用级联抽取器将采样率为 $f_{s,0} = 5\\,\\text{MHz}$ 的高速率离散时间信号转换为速率较低的 $f_{\\text{out}} = 500\\,\\text{kHz}$ 数据流，同时保留信号内容直至保证的通带边缘 $f_p$，并实现以 $\\text{dB}$ 为单位的最小混叠抑制 $A$。该链由一系列整数抽取因子 $\\{M_i\\}_{i=1}^L$ 指定，使得 $\\prod_{i=1}^L M_i = f_{s,0}/f_{\\text{out}}$。每个抽取器前都有一个低通抗混叠滤波器。\n\n从香农-奈奎斯特采样定理和整数因子下采样的定义出发，推导在每个抽取阶段之前，抗混叠滤波器必须满足的条件，以防止带外内容混叠到保留频带中。将每个阶段 $i$ 建模如下：\n- 阶段 $i$ 的输入采样率为 $f_{s,i-1}$，其中 $f_{s,0} = 5\\,\\text{MHz}$。\n- 抽取因子为 $M_i \\in \\mathbb{Z}_{\\ge 2}$，该阶段的输出采样率为 $f_{s,i} = f_{s,i-1}/M_i$。\n- 阶段 $i$ 的折叠（混叠）频率为 $f_{\\text{fold},i} = f_{s,i-1}/(2 M_i)$。\n- 必须端到端保留的通带边缘为 $f_p$，阻带的起始频率不得晚于 $f_{\\text{fold},i}$，以确保没有带外内容发生混叠。\n- 阶段 $i$ 的过渡带宽为 $\\Delta f_i = f_{\\text{fold},i} - f_p$，为使该阶段可行，此值必须为严格正数。\n\n假设每个阶段都采用通过传统凯塞窗方法设计的线性相位有限冲激响应（FIR）低通原型滤波器。使用一个经过充分测试的综合界限来确定最小 FIR 阶数 $N_i$，该阶数能在给定过渡带宽 $\\Delta \\omega_i$（单位为弧度/采样点）的情况下，保证至少 $A$ dB 的阻带衰减，其中 $\\Delta \\omega_i = 2\\pi \\Delta f_i / f_{s,i-1}$。滤波器阶数 $N_i$ 定义为延迟元件的数量，即抽头数减一。使用满足该界限的最小整数 $N_i$。保守地处理每个阶段的衰减要求，即要求每个阶段自身都必须满足完整的 $A$ dB 衰减。如果任何阶段的 $\\Delta f_i \\le 0$，则声明该链不可行。\n\n所有涉及频率的量都必须以 $\\text{Hz}$ 表示。角度以弧度表示。预期的输出是每个阶段的整数滤波器阶数。如果一个测试用例不可行（例如，如果 $\\prod_i M_i \\ne f_{s,0}/f_{\\text{out}}$ 作为整数，或任何阶段的 $\\Delta f_i \\le 0$），则为该用例返回单元素列表 $[-1]$。\n\n您的程序必须实现上述逻辑，并为以下每个测试用例计算各阶段滤波器阶数的列表，每个测试用例指定为一个元组 $(f_{s,0}, f_{\\text{out}}, f_p, A, [M_1, M_2, \\dots, M_L])$：\n- 情况 A（正常多级路径）：$(5{,}000{,}000, 500{,}000, 200{,}000, 80, [5, 2])$。\n- 情况 B（备选阶段排序）：$(5{,}000{,}000, 500{,}000, 200{,}000, 80, [2, 5])$。\n- 情况 C（单级基准）：$(5{,}000{,}000, 500{,}000, 200{,}000, 80, [10])$。\n- 情况 D（近边界保留）：$(5{,}000{,}000, 500{,}000, 245{,}000, 80, [2, 5])$。\n- 情况 E（不可行的保留请求）：$(5{,}000{,}000, 500{,}000, 260{,}000, 80, [2, 5])$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，列表中的每个元素是代表该测试用例各阶段滤波器阶数的整数列表（如果不可行则为 $[-1]$）。例如，包含两个用例的输出应类似于 $[[N_{1,A},N_{2,A}], [N_{1,B},N_{2,B}]]$，其中所有 $N$ 均为整数，且无附加文本。",
            "solution": "如问题所述，需要推导并实现一个设计多级抽取滤波器链的程序。设计目标是确定一系列有限冲激响应（FIR）抗混叠滤波器所需的最小阶数。\n\n### 第 1 步：提取已知条件\n- 初始采样率：$f_{s,0} = 5\\,\\text{MHz} = 5,000,000\\,\\text{Hz}$\n- 最终输出采样率：$f_{\\text{out}} = 500\\,\\text{kHz} = 500,000\\,\\text{Hz}$\n- 总抽取因子：$\\prod_{i=1}^L M_i = f_{s,0}/f_{\\text{out}}$\n- $L$ 个阶段的整数抽取因子序列：$\\{M_i\\}_{i=1}^L$，其中 $M_i \\in \\mathbb{Z}_{\\ge 2}$\n- 保证的通带边缘：$f_p$\n- 每个阶段的最小混叠抑制：$A$ (dB)\n- 阶段 $i$ 的输入采样率：$f_{s,i-1}$\n- 阶段 $i$ 的输出采样率：$f_{s,i} = f_{s,i-1}/M_i$\n- 阶段 $i$ 的折叠频率：$f_{\\text{fold},i} = f_{s,i-1}/(2 M_i)$\n- 阶段 $i$ 的过渡带宽：$\\Delta f_i = f_{\\text{fold},i} - f_p$\n- 阶段 $i$ 的可行性条件：$\\Delta f_i  0$\n- FIR 滤波器设计方法：凯塞窗\n- 阶段 $i$ 的归一化过渡带宽：$\\Delta \\omega_i = 2\\pi \\Delta f_i / f_{s,i-1}$\n- FIR 滤波器阶数界限：满足阻带衰减为 $A\\,\\text{dB}$ 的界限的最小整数 $N_i$。\n- 链不可行的条件：对于任何阶段 $i$，$\\Delta f_i \\le 0$，或 $\\prod M_i \\neq f_{s,0}/f_{\\text{out}}$。在此类情况下，输出为 $[-1]$。\n- 测试用例：\n  - 情况 A：$(f_{s,0}=5000000, f_{\\text{out}}=500000, f_p=200000, A=80, M=[5, 2])$\n  - 情况 B：$(f_{s,0}=5000000, f_{\\text{out}}=500000, f_p=200000, A=80, M=[2, 5])$\n  - 情况 C：$(f_{s,0}=5000000, f_{\\text{out}}=500000, f_p=200000, A=80, M=[10])$\n  - 情况 D：$(f_{s,0}=5000000, f_{\\text{out}}=500000, f_p=245000, A=80, M=[2, 5])$\n  - 情况 E：$(f_{s,0}=5000000, f_{\\text{out}}=500000, f_p=260000, A=80, M=[2, 5])$\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题在科学上基于数字信号处理的既定原则，特别是多速率系统和 FIR 滤波器设计。问题提法明确，提供了为每个测试用例得出唯一解所需的所有参数、定义和约束。语言客观、正式。所描述的任务是数据采集系统设计中的一个标准工程问题。该问题未违反任何无效标准。\n\n### 第 3 步：结论与行动\n问题有效。将提供完整解答。\n\n### 基于原理的设计与推导\n\n通过整数因子 $M$ 进行抽取（或下采样）的过程会降低离散信号的采样率。如果此操作不谨慎执行，可能导致混叠，即原始信号中的高频内容在下采样后的信号中伪装成低频内容。香农-奈奎斯特采样定理规定了避免这种情况的条件。\n\n对于一个输入采样率为 $f_{s,i-1}$、抽取因子为 $M_i$ 的抽取阶段 $i$，输出采样率变为 $f_{s,i} = f_{s,i-1}/M_i$。新的奈奎斯特频率为 $f_{s,i}/2$。输入信号中介于 $f_{s,i}/2$ 和 $f_{s,i-1}/2$ 之间的任何频率内容都将“折叠”到基带 $[0, f_{s,i}/2]$ 中。\n\n为防止这种失真，必须在下采样之前应用一个抗混叠低通滤波器。此滤波器必须满足两个主要约束：\n1.  **通带**：它必须保留所需的信号内容。问题指定必须保留所有直至通带边缘 $f_p$ 的频率。因此，滤波器的通带必须延伸到 $f_p$。\n2.  **阻带**：它必须充分衰减会混叠到保留通带中的频率。第一个也是最关键的折叠作用发生在新的奈奎斯特频率周围，问题将其定义为折叠频率 $f_{\\text{fold},i} = f_{s,i-1}/(2M_i) = f_{s,i}/2$。为保守地防止任何混叠，滤波器的阻带必须在此频率或之前开始。\n\n从通带到阻带的过渡不可能是瞬时的。通带结束点 $f_p$ 与阻带起始点 $f_{\\text{stop},i}$ 之间的频率范围是过渡带宽。为了最大化此带宽从而最小化滤波器复杂度（阶数），我们将阻带起始点精确设置在折叠频率处，即 $f_{\\text{stop},i} = f_{\\text{fold},i}$。\n\n因此，阶段 $i$ 的滤波器过渡带宽，记为 $\\Delta f_i$，为：\n$$ \\Delta f_i = f_{\\text{stop},i} - f_p = f_{\\text{fold},i} - f_p = \\frac{f_{s,i-1}}{2M_i} - f_p $$\n对于一个物理上可实现的滤波器，此过渡带宽必须为严格正数，即 $\\Delta f_i  0$。如果 $f_p \\ge f_{\\text{fold},i}$，则无法同时满足通带和阻带的要求，使得该阶段的设计不可行。\n\nFIR 滤波器所需阶数主要由阻带衰减 $A$ 和归一化过渡带宽 $\\Delta \\omega$ 决定。归一化是相对于滤波器的输入采样率 $f_{s,i-1}$ 进行的。\n$$ \\Delta \\omega_i = 2\\pi \\frac{\\Delta f_i}{f_{s,i-1}} $$\n对于使用凯塞窗方法设计的 FIR 滤波器，一个广泛使用的估算最小滤波器阶数 $N$（定义为抽头数减一）的经验公式由下式给出：\n$$ N \\ge \\frac{A - 8}{2.285 \\, \\Delta\\omega} $$\n其中 $A$ 是以分贝（$\\text{dB}$）为单位的阻带衰减，且大于 21。问题要求采用保守方法，即每个阶段都必须提供完整的衰减 $A$。因此，对于每个阶段 $i$，我们计算满足此界限的最小整数阶数 $N_i$：\n$$ N_i = \\left\\lceil \\frac{A - 8}{2.285 \\, \\Delta\\omega_i} \\right\\rceil $$\n\n对于给定的测试用例 $(f_{s,0}, f_{\\text{out}}, f_p, A, [M_1, \\dots, M_L])$，总体算法如下：\n1.  验证总抽取因子：检查是否 $f_{s,0} = f_{\\text{out}} \\times \\prod_{i=1}^L M_i$。如果不满足，则该链无效。\n2.  初始化当前采样率：$f_{s,\\text{current}} \\leftarrow f_{s,0}$。初始化一个空列表 `orders` 用于存放滤波器阶数。\n3.  对每个阶段 $i=1, \\dots, L$（抽取因子为 $M_i$）进行迭代：\n    a.  设置此阶段的输入采样率：$f_{s,i-1} = f_{s,\\text{current}}$。\n    b.  计算折叠频率：$f_{\\text{fold},i} = f_{s,i-1} / (2 M_i)$。\n    c.  计算过渡带宽：$\\Delta f_i = f_{\\text{fold},i} - f_p$。\n    d.  检查可行性：如果 $\\Delta f_i \\le 0$，则该链不可行。中止并返回 $[-1]$。\n    e.  计算归一化过渡带宽：$\\Delta \\omega_i = (2\\pi \\Delta f_i) / f_{s,i-1}$。\n    f.  计算所需的滤波器阶数：$N_i = \\lceil (A - 8) / (2.285 \\Delta \\omega_i) \\rceil$。\n    g.  将整数 $N_i$ 追加到 `orders` 列表中。\n    h.  更新下一阶段的当前采样率：$f_{s,\\text{current}} = f_{s,i-1} / M_i$。\n4.  如果循环成功完成，返回 `orders` 列表。\n\n此程序将应用于每个测试用例以生成最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the multistage decimation filter design problem.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (fs_0, f_out, f_p, A, [M1, M2, ...])\n        (5000000, 500000, 200000, 80, [5, 2]),      # Case A\n        (5000000, 500000, 200000, 80, [2, 5]),      # Case B\n        (5000000, 500000, 200000, 80, [10]),       # Case C\n        (5000000, 500000, 245000, 80, [2, 5]),      # Case D\n        (5000000, 500000, 260000, 80, [2, 5]),      # Case E\n    ]\n\n    def calculate_filter_orders(fs_0, f_out, f_p, A, M_list):\n        \"\"\"\n        Calculates the required FIR filter orders for a multistage decimation chain.\n\n        Args:\n            fs_0 (int): Initial sampling rate in Hz.\n            f_out (int): Final output sampling rate in Hz.\n            f_p (int): Passband edge to be preserved in Hz.\n            A (float): Required stopband attenuation in dB.\n            M_list (list of int): List of integer decimation factors.\n\n        Returns:\n            list of int: A list of calculated filter orders for each stage,\n                         or [-1] if the chain is infeasible.\n        \"\"\"\n        # Validate total decimation factor. The problem implies integer arithmetic.\n        total_m = np.prod(M_list)\n        if fs_0 != f_out * total_m:\n            return [-1]\n\n        orders = []\n        current_fs = float(fs_0)\n        \n        for M_i in M_list:\n            if M_i  2:  # Decimation factors must be integers >= 2\n                return [-1]\n\n            fs_in_stage = current_fs\n            \n            # Calculate the folding frequency for the current stage\n            f_fold_i = fs_in_stage / (2.0 * M_i)\n            \n            # Calculate the transition width\n            delta_f_i = f_fold_i - f_p\n            \n            # Check for feasibility: transition width must be positive\n            if delta_f_i = 0:\n                return [-1]\n            \n            # Calculate the normalized transition width (radians per sample)\n            delta_omega_i = 2.0 * math.pi * delta_f_i / fs_in_stage\n            \n            # Estimate filter order N using Kaiser's formula\n            # N_i = ceil((A - 8) / (2.285 * delta_omega_i))\n            # The formula is valid for A > 21 dB.\n            if A = 8: # Avoid division by zero or negative arguments to ceil if A is low\n                N_i = 0\n            else:\n                numerator = A - 8.0\n                denominator = 2.285 * delta_omega_i\n                N_i = math.ceil(numerator / denominator)\n            \n            orders.append(int(N_i))\n            \n            # Update the sampling rate for the next stage\n            current_fs /= M_i\n            \n        return orders\n\n    results = []\n    for case in test_cases:\n        result = calculate_filter_orders(*case)\n        results.append(result)\n\n    # Format the final output string exactly as required, without spaces in lists.\n    # E.g., [[84,101],[-1]]\n    str_results = [str(res).replace(\" \", \"\") for res in results]\n    final_output_string = f\"[{','.join(str_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}