{
    "hands_on_practices": [
        {
            "introduction": "In experimental fusion science, plasma properties are often measured by a finite number of probes distributed spatially, such as Mirnov coils arranged around the torus. This exercise challenges you to derive the phenomenon of spatial aliasing from first principles, without relying on pre-quoted formulas. By determining the conditions under which distinct toroidal mode numbers become indistinguishable, you will gain a foundational understanding of the resolution limits inherent in any discretely sampled diagnostic system. ",
            "id": "4024285",
            "problem": "In a toroidal magnetic confinement device, a set of $N$ identical pick-up coils is installed at evenly spaced toroidal angles $\\phi_{j} = \\frac{2\\pi j}{N}$ for $j \\in \\{0,1,\\ldots,N-1\\}$. The measured signal is a toroidally periodic field $B(\\phi)$ that can be decomposed as a Fourier series in integer toroidal mode numbers $n \\in \\mathbb{Z}$, so that $B(\\phi) = \\sum_{n \\in \\mathbb{Z}} A_{n} \\exp(i n \\phi)$, where $A_{n} \\in \\mathbb{C}$ are the complex amplitudes and $\\phi$ is measured in radians. The instrument records $B(\\phi_{j})$ simultaneously at all $N$ locations, and one wishes to infer the toroidal mode number content of $B(\\phi)$ from these samples using a discrete Fourier analysis, as is standard in computational analyses and in fast Fourier transform (FFT)-based pipelines in computational fusion science and engineering.\n\nStarting only from the definitions of uniform angular sampling on a periodic domain and the integer-harmonic representation of $B(\\phi)$, and without invoking any pre-quoted aliasing formulas, answer the following:\n\n- Derive a necessary and sufficient condition under which two distinct integer toroidal mode numbers $n,n' \\in \\mathbb{Z}$ produce identical sample values at all $N$ probes. Express the full set of mode numbers $n'$ that are indistinguishable from a given $n$.\n\n- Suppose physics and diagnostic considerations imply a strict bandlimit $|n| \\le n_{\\max}$ for some known finite integer $n_{\\max} \\ge 1$. Determine the minimal integer $N_{\\min}$ such that, for every admissible mode number with $|n| \\le n_{\\max}$, no other admissible mode number is indistinguishable from it under sampling on $N_{\\min}$ probes.\n\nExpress your final answer as a closed-form analytic expression in terms of $n_{\\max}$. No units are required in the final answer. Angles are measured in radians.",
            "solution": "The problem requires us to first derive the condition under which two distinct toroidal modes are indistinguishable when sampled by a finite number of probes, and second, to determine the minimum number of probes required to uniquely identify all modes within a specified bandlimit. We shall proceed by formal derivation from the provided definitions.\n\nFirst, let us address the condition for indistinguishability. A single toroidal mode with mode number $n \\in \\mathbb{Z}$ is represented by the complex exponential function $\\exp(i n \\phi)$. Two distinct integer mode numbers, $n$ and $n'$, are said to be indistinguishable or \"aliased\" by the measurement system if their corresponding basis functions yield identical values at all $N$ sampling locations $\\phi_j = \\frac{2\\pi j}{N}$ for $j \\in \\{0, 1, \\ldots, N-1\\}$. This condition is mathematically expressed as:\n$$ \\exp(i n \\phi_j) = \\exp(i n' \\phi_j) \\quad \\forall j \\in \\{0, 1, \\ldots, N-1\\} $$\nBy dividing both sides by $\\exp(i n' \\phi_j)$ (which is always non-zero), we obtain:\n$$ \\exp(i n \\phi_j - i n' \\phi_j) = 1 $$\n$$ \\exp\\left(i (n - n') \\phi_j\\right) = 1 $$\nSubstituting the definition of the sampling angles $\\phi_j$:\n$$ \\exp\\left(i (n - n') \\frac{2\\pi j}{N}\\right) = 1 $$\nThe complex exponential $\\exp(i\\theta)$ is equal to $1$ if and only if its argument $\\theta$ is an integer multiple of $2\\pi$. Therefore, for each $j$, there must exist an integer $k_j$ such that:\n$$ (n - n') \\frac{2\\pi j}{N} = 2\\pi k_j $$\nThis simplifies to the condition that $(n - n') \\frac{j}{N}$ must be an integer for all $j \\in \\{0, 1, \\ldots, N-1\\}$.\nFor $j=0$, the condition is $0 = 0$, which is trivially satisfied and provides no constraint.\nLet us consider $j=1$. The condition requires that $(n - n') \\frac{1}{N}$ must be an integer. Let this integer be $m \\in \\mathbb{Z}$.\n$$ \\frac{n - n'}{N} = m $$\n$$ n - n' = mN $$\nThis is a necessary condition derived from the case $j=1$. We must now verify if it is sufficient for all other values of $j$. If we assume $n - n' = mN$ for some integer $m$, the left-hand side of our exponential equation becomes:\n$$ \\exp\\left(i (mN) \\frac{2\\pi j}{N}\\right) = \\exp(i m j 2\\pi) $$\nSince $m$ and $j$ are both integers, their product $mj$ is also an integer. Any integer multiple of $2\\pi i$ in the argument of an exponential function results in a value of $1$. Thus, the condition holds for all $j$.\nThe problem states that the modes are distinct, so $n \\neq n'$, which implies that $m \\neq 0$.\nTherefore, the necessary and sufficient condition for two distinct integer toroidal mode numbers $n$ and $n'$ to be indistinguishable is that their difference is a non-zero integer multiple of the number of samples $N$. The full set of mode numbers $n'$ that are indistinguishable from a given mode $n$ is given by:\n$$ \\{ n' \\in \\mathbb{Z} \\mid n' = n + mN, \\text{ for some } m \\in \\mathbb{Z} \\} $$\n\nNext, we address the second part of the problem. We are given a strict bandlimit, such that the only physically relevant modes are those with $|n| \\le n_{\\max}$ for some integer $n_{\\max} \\ge 1$. The set of admissible mode numbers is $\\mathcal{S} = \\{n \\in \\mathbb{Z} \\mid -n_{\\max} \\le n \\le n_{\\max}\\}$. We must find the minimal number of probes, $N_{\\min}$, such that no two distinct modes within this set are indistinguishable.\n\nThis means that for any two distinct modes $n, n' \\in \\mathcal{S}$ (i.e., $n \\neq n'$), they must be distinguishable. This is equivalent to requiring that the condition for indistinguishability is never met for any pair of distinct modes in $\\mathcal{S}$. From our previous derivation, this means we must ensure that:\n$$ n - n' \\neq mN \\quad \\forall n, n' \\in \\mathcal{S} \\text{ with } n \\neq n', \\text{ and } \\forall m \\in \\mathbb{Z} \\setminus \\{0\\} $$\nLet us analyze the range of possible values for the difference $n - n'$. Since $n, n' \\in [-n_{\\max}, n_{\\max}]$, the maximum possible value for the difference is $n_{\\max} - (-n_{\\max}) = 2n_{\\max}$, and the minimum value is $-n_{\\max} - n_{\\max} = -2n_{\\max}$. As $n \\neq n'$, the difference $n - n'$ is a non-zero integer. Thus, the set of all possible differences is:\n$$ \\Delta = \\{ k \\in \\mathbb{Z} \\mid -2n_{\\max} \\le k \\le 2n_{\\max}, k \\neq 0 \\} $$\nThe requirement that $n - n' \\neq mN$ for any non-zero integer $m$ means that no non-zero multiple of $N$ can be an element of the set $\\Delta$. The non-zero multiples of $N$ are $\\{ \\pm N, \\pm 2N, \\pm 3N, \\ldots \\}$. To ensure no overlap with $\\Delta$, the smallest magnitude of a non-zero multiple of $N$, which is $N$ itself (since $N \\ge 1$), must be larger than the largest magnitude of any element in $\\Delta$.\nThe maximum absolute value in $\\Delta$ is $|2n_{\\max}| = 2n_{\\max}$.\nSo, we must have the condition:\n$$ N > 2n_{\\max} $$\nThe problem asks for the minimal integer $N_{\\min}$ satisfying this condition. The smallest integer strictly greater than $2n_{\\max}$ is $2n_{\\max} + 1$.\nThus, $N_{\\min} = 2n_{\\max} + 1$.\n\nTo confirm this result, let's consider the case where $N = 2n_{\\max}$. If we choose $n=n_{\\max}$ and $n'=-n_{\\max}$, both modes are in the admissible set $\\mathcal{S}$. Their difference is $n-n' = n_{\\max}-(-n_{\\max}) = 2n_{\\max} = 1 \\cdot N$. Since their difference is a multiple of $N$, these two modes would be aliased and therefore indistinguishable. This confirms that $N=2n_{\\max}$ is insufficient. Therefore, the minimal integer number of probes required is indeed $2n_{\\max} + 1$. This corresponds to the Nyquist-Shannon sampling theorem applied to a periodic signal whose Fourier spectrum is contained within the range of mode numbers $[-n_{\\max}, n_{\\max}]$, which has a total span of $2n_{\\max}$.",
            "answer": "$$\\boxed{2n_{\\max} + 1}$$"
        },
        {
            "introduction": "A common task in analyzing both experimental and simulation data is the use of the Fast Fourier Transform (FFT) to identify characteristic frequencies. A frequent pitfall is mistaking the finely-spaced points of a zero-padded spectrum for an increase in true spectral resolution. This hands-on coding exercise demonstrates why spectral resolution is fundamentally limited by the observation time, and how zero padding merely interpolates the spectrum, helping to build critical intuition for correctly interpreting spectral data. ",
            "id": "4024315",
            "problem": "Consider a synthetic magnetic fluctuation signal representative of plasma modes measured in a toroidal fusion device. The signal is modeled as the sum of two coherent modes and weak broadband turbulence, sampled uniformly for a finite observation time. Let the sampling rate be $f_s$ samples per second, let the number of acquired samples be $N_0$, and let the total observation time be $T_{\\text{obs}} = N_0 / f_s$. You will compare two discrete spectra: the Discrete Fourier Transform (DFT) of the acquired $N_0$ samples, and the DFT after zero padding the time series to a longer length $N_{\\text{fft}}$ with $N_{\\text{fft}} = \\text{pad\\_factor} \\times N_0$. The goal is to demonstrate, from first principles, that zero padding only increases the spectral sampling density (more DFT points) but does not change the intrinsic resolution determined by the finite observation time.\n\nYour tasks are:\n\n1. Generate a discrete-time signal $x[n]$ for $n = 0,1,\\dots,N_0-1$ with sampling interval $\\Delta t = 1/f_s$ of the form\n$$\nx[n] = A_1 \\sin\\left(2\\pi f_1 n \\Delta t \\right) + A_2 \\sin\\left(2\\pi f_2 n \\Delta t \\right) + \\eta[n],\n$$\nwhere $A_1$ and $A_2$ are amplitudes and $\\eta[n]$ is independent identically distributed zero-mean Gaussian noise with small variance. The two coherent components can be interpreted as, for example, an AlfvÃ©nic mode and a drift-wave mode present in the plasma. Assume $f_1$ and $f_2$ are strictly below the Nyquist frequency $f_s/2$.\n\n2. Compute two one-sided magnitude spectra using a Fast Fourier Transform (FFT): one using the original length $N_0$ and one using the zero-padded length $N_{\\text{fft}}$. For both, use the real-to-complex FFT that returns nonnegative frequency components. Let the corresponding discrete frequency arrays be $f_k^{(0)}$ and $f_k^{(\\text{pad})}$, and magnitudes be $|X^{(0)}[k]|$ and $|X^{(\\text{pad})}[k]|$.\n\n3. Determine the intrinsic resolution implied by the finite observation time, denoted $\\Delta f_{\\text{intrinsic}}$, purely from the observation time $T_{\\text{obs}}$. Express $\\Delta f_{\\text{intrinsic}}$ in hertz.\n\n4. Determine the spectral sampling density, defined as the DFT bin spacing, for both the unpadded and padded spectra. Let $\\Delta f_{\\text{bin}}^{(0)}$ be the unpadded bin spacing and $\\Delta f_{\\text{bin}}^{(\\text{pad})}$ be the padded bin spacing. Express both in hertz.\n\n5. Implement a resolution-aware peak counting procedure on each spectrum as follows:\n   - Identify local maxima in the magnitude spectrum $|X[k]|$ whose values exceed a fraction of the global maximum magnitude (use a fixed fraction $0.2$ of the maximum).\n   - Convert the peak indices to frequency locations using the corresponding $f_k$ array.\n   - Cluster peaks that are separated by less than $\\Delta f_{\\text{intrinsic}}$ into a single resolvable feature. Count the number of clusters as the number of resolvable peaks.\n\n6. For each test case below, compute and report a five-element list $[\\Delta f_{\\text{intrinsic}}, \\Delta f_{\\text{bin}}^{(0)}, \\Delta f_{\\text{bin}}^{(\\text{pad})}, N_{\\text{res}}^{(0)}, N_{\\text{res}}^{(\\text{pad})}]$, where $N_{\\text{res}}^{(0)}$ and $N_{\\text{res}}^{(\\text{pad})}$ are integers representing the number of resolvable peaks in the unpadded and padded spectra, respectively.\n\nUse the following test suite, designed to probe typical, boundary, and sub-resolution cases relevant to computational fusion signal analysis. In all cases, use $A_1 = A_2 = 1$ and a noise standard deviation of $0.02$ in the same units as $x[n]$:\n- Case 1 (typical separation): $f_s = 20000$ Hz, $N_0 = 2048$, $\\text{pad\\_factor} = 8$, $f_1 = 1200$ Hz, $f_2 = f_1 + 5 \\times \\Delta f_{\\text{intrinsic}}$.\n- Case 2 (Rayleigh-like boundary): $f_s = 20000$ Hz, $N_0 = 2048$, $\\text{pad\\_factor} = 8$, $f_1 = 3000$ Hz, $f_2 = f_1 + \\Delta f_{\\text{intrinsic}}$.\n- Case 3 (sub-resolution separation): $f_s = 20000$ Hz, $N_0 = 2048$, $\\text{pad\\_factor} = 8$, $f_1 = 4500$ Hz, $f_2 = f_1 + 0.6 \\times \\Delta f_{\\text{intrinsic}}$.\n\nRequirements:\n- Express all frequency quantities in hertz.\n- The final program output must be a single line containing a comma-separated list of three five-element lists, enclosed in square brackets, in the exact order of the test cases. For example, the output must look like $[[a_1,a_2,a_3,a_4,a_5],[b_1,b_2,b_3,b_4,b_5],[c_1,c_2,c_3,c_4,c_5]]$ where each $a_i$, $b_i$, $c_i$ is a number (integers for the counts and floating-point numbers in hertz for the frequency quantities).",
            "solution": "The problem requires an analysis of discrete spectra to demonstrate that spectral resolution is a function of the total observation time, not the number of points in a Discrete Fourier Transform (DFT), which can be artificially increased through zero padding. This is a fundamental concept in signal processing, rooted in the properties of the Fourier transform.\n\n### Theoretical Principles\n\n1.  **Finite Observation and Spectral Leakage**: Any measurement is finite in duration. A signal $x(t)$ observed over a time interval $T_{\\text{obs}}$ can be mathematically modeled as the \"true\" infinite signal multiplied by a rectangular window function, $w(t)$, which is $1$ for the duration of the observation and $0$ otherwise. According to the convolution theorem, this multiplication in the time domain corresponds to a convolution in the frequency domain. The Fourier transform of the rectangular window is a sinc function: $\\text{FT}\\{w(t)\\} \\propto \\text{sinc}(\\pi f T_{\\text{obs}})$, where $f$ is frequency. Consequently, the measured spectrum of any signal component (e.g., a pure sinusoid, which is a delta function in the frequency domain) is convolved with this sinc function. This spreads the energy of the sharp spectral line into a broad peak with side lobes, a phenomenon known as spectral leakage.\n\n2.  **Intrinsic Resolution**: The ability to distinguish between two nearby frequency components is called spectral resolution. The Rayleigh criterion, adapted for this context, states that two components are just resolvable if the peak of one component's sinc pattern coincides with the first null of the other's. The first null of the $\\text{sinc}(\\pi f T_{\\text{obs}})$ function occurs at $f = \\pm 1/T_{\\text{obs}}$. Therefore, the minimum resolvable frequency separation is dictated by the observation time. This gives the intrinsic frequency resolution:\n    $$\n    \\Delta f_{\\text{intrinsic}} = \\frac{1}{T_{\\text{obs}}} = \\frac{f_s}{N_0}\n    $$\n    where $f_s$ is the sampling rate and $N_0$ is the number of samples. This resolution limit is fundamental and cannot be overcome by post-processing the acquired $N_0$ samples.\n\n3.  **DFT Bin Spacing vs. Resolution**: The Discrete Fourier Transform (DFT) calculates the spectrum at discrete frequency points, or \"bins.\" The spacing between these bins for a DFT of length $N_{\\text{fft}}$ is:\n    $$\n    \\Delta f_{\\text{bin}} = \\frac{f_s}{N_{\\text{fft}}}\n    $$\n    Zero padding a time-domain signal from its original length $N_0$ to a new length $N_{\\text{fft}} > N_0$ before performing the DFT does not add new information or increase $T_{\\text{obs}}$. It only increases $N_{\\text{fft}}$. This reduces the bin spacing $\\Delta f_{\\text{bin}}$, effectively interpolating the spectrum. It provides a more densely sampled, smoother-looking plot of the underlying sinc-shaped spectral features, but it does not alter the width of these features. Therefore, zero padding improves the *spectral sampling density*, but not the *intrinsic resolution*.\n\n### Algorithmic Procedure\n\nFollowing these principles, the problem is solved by implementing the specified procedure.\n\n1.  **Signal Generation**: For each test case, a discrete-time signal $x[n]$ is synthesized. It consists of two sinusoids with amplitudes $A_1=1$ and $A_2=1$ at frequencies $f_1$ and $f_2$, plus zero-mean Gaussian noise $\\eta[n]$ with a standard deviation of $0.02$. The time axis is defined by $n=0, 1, \\dots, N_0-1$ with a sampling interval $\\Delta t = 1/f_s$.\n\n2.  **Parameter Calculation**: The key frequency metrics are calculated for each case. Given $f_s = 20000$ Hz and $N_0 = 2048$:\n    -   Observation time: $T_{\\text{obs}} = N_0/f_s = 2048 / 20000 = 0.1024$ s.\n    -   Intrinsic resolution: $\\Delta f_{\\text{intrinsic}} = 1/T_{\\text{obs}} = 1/0.1024 \\approx 9.7656$ Hz.\n    -   Unpadded bin spacing: $\\Delta f_{\\text{bin}}^{(0)} = f_s/N_0 = 20000/2048 \\approx 9.7656$ Hz. Note that $\\Delta f_{\\text{intrinsic}} = \\Delta f_{\\text{bin}}^{(0)}$.\n    -   Padded length: $N_{\\text{fft}} = \\text{pad\\_factor} \\times N_0 = 8 \\times 2048 = 16384$.\n    -   Padded bin spacing: $\\Delta f_{\\text{bin}}^{(\\text{pad})} = f_s/N_{\\text{fft}} = 20000/16384 \\approx 1.2207$ Hz.\n\n3.  **Spectral Analysis**: For both the original signal of length $N_0$ and the zero-padded signal of length $N_{\\text{fft}}$, a one-sided magnitude spectrum is computed using the real-to-complex Fast Fourier Transform (`scipy.fft.rfft`). This yields the magnitude arrays $|X^{(0)}[k]|$ and $|X^{(\\text{pad})}[k]|$ and their corresponding frequency arrays $f_k^{(0)}$ and $f_k^{(\\text{pad})}$.\n\n4.  **Resolution-Aware Peak Counting**: A custom procedure determines the number of resolvable peaks.\n    a.  Local maxima in the magnitude spectrum are identified. A point $|X[k]|$ is a local maximum if it is greater than its immediate neighbors, $|X[k-1]|$ and $|X[k+1]|$.\n    b.  These maxima are filtered, keeping only those that exceed a threshold of $0.2$ times the global maximum of the spectrum. This step rejects minor peaks due to noise.\n    c.  The frequencies of the surviving peaks are collected.\n    d.  The peaks are clustered. Starting with the lowest-frequency peak, subsequent peaks are grouped into the same cluster if their frequency separation from the previous peak in the sorted list is less than $\\Delta f_{\\text{intrinsic}}$. If the separation is greater, a new cluster is started.\n    e.  The total number of clusters, $N_{\\text{res}}$, is the count of resolvable spectral features. This process is applied to both the unpadded and padded spectra.\n\n### Case-by-Case Results\n\nThis procedure is executed for the three specified test cases.\n\n-   **Case 1 (Typical Separation)**: $f_2 - f_1 = 5 \\times \\Delta f_{\\text{intrinsic}} \\approx 48.83$ Hz. The frequencies are well separated. The analysis correctly identifies two distinct peaks in both the unpadded and padded spectra. We expect $N_{\\text{res}}^{(0)} = 2$ and $N_{\\text{res}}^{(\\text{pad})} = 2$.\n\n-   **Case 2 (Rayleigh-like Boundary)**: $f_2 - f_1 = \\Delta f_{\\text{intrinsic}} \\approx 9.77$ Hz. The frequencies are separated by exactly the intrinsic resolution limit. The spectral features (sinc functions) overlap significantly, but a dip between the two main peaks should still be present, allowing the local maxima finder to identify two peaks. Both analyses are expected to resolve them, yielding $N_{\\text{res}}^{(0)} = 2$ and $N_{\\text{res}}^{(\\text{pad})} = 2$. The padded spectrum visually clarifies the presence of the two peaks by better sampling the continuous shape.\n\n-   **Case 3 (Sub-Resolution Separation)**: $f_2 - f_1 = 0.6 \\times \\Delta f_{\\text{intrinsic}} \\approx 5.86$ Hz. The frequencies are closer than the resolution limit. The two overlapping sinc patterns merge into a single, broader peak. The peak counting algorithm will find only one local maximum in the region of interest. Both analyses are expected to fail to resolve the two modes, yielding $N_{\\text{res}}^{(0)} = 1$ and $N_{\\text{res}}^{(\\text{pad})} = 1$. This case critically shows that zero padding, despite making the single peak's shape smoother, cannot separate the unresolvable components.\n\nThe final output will consist of the five-element list $[\\Delta f_{\\text{intrinsic}}, \\Delta f_{\\text{bin}}^{(0)}, \\Delta f_{\\text{bin}}^{(\\text{pad})}, N_{\\text{res}}^{(0)}, N_{\\text{res}}^{(\\text{pad})}]$ for each case, confirming that $N_{\\text{res}}^{(0)}$ and $N_{\\text{res}}^{(\\text{pad})}$ are identical in all scenarios, thereby validating the underlying principles.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef count_resolved_peaks(mag_spec, freq_array, delta_f_intrinsic, threshold_frac=0.2):\n    \"\"\"\n    Identifies and clusters peaks in a spectrum to count resolvable features.\n    \n    Args:\n        mag_spec (np.ndarray): The magnitude spectrum.\n        freq_array (np.ndarray): The corresponding frequency array.\n        delta_f_intrinsic (float): The intrinsic frequency resolution.\n        threshold_frac (float): Fraction of the global maximum for peak thresholding.\n        \n    Returns:\n        int: The number of resolvable peaks (clusters).\n    \"\"\"\n    if len(mag_spec) < 3:\n        return 0\n\n    global_max = np.max(mag_spec)\n    if global_max == 0:\n        return 0\n    threshold = threshold_frac * global_max\n\n    # Find indices of all local maxima\n    local_max_indices = []\n    for i in range(1, len(mag_spec) - 1):\n        if mag_spec[i] > mag_spec[i-1] and mag_spec[i] > mag_spec[i+1]:\n            local_max_indices.append(i)\n\n    # Filter maxima by the amplitude threshold\n    peak_indices = [i for i in local_max_indices if mag_spec[i] > threshold]\n    \n    if not peak_indices:\n        return 0\n\n    # Get frequencies of the filtered peaks\n    peak_freqs = freq_array[peak_indices]\n    \n    # Cluster peaks based on intrinsic resolution\n    clusters = [[peak_freqs[0]]]\n    for i in range(1, len(peak_freqs)):\n        freq = peak_freqs[i]\n        # Compare with the last frequency in the last cluster\n        if freq - clusters[-1][-1] < delta_f_intrinsic:\n            clusters[-1].append(freq)\n        else:\n            # Start a new cluster\n            clusters.append([freq])\n            \n    return len(clusters)\n\ndef analyze_case(fs, N0, pad_factor, f1_base, f2_offset_factor, A1, A2, noise_stddev, seed):\n    \"\"\"\n    Performs the full analysis for a single test case.\n    \n    Args:\n        fs (float): Sampling frequency in Hz.\n        N0 (int): Number of initial samples.\n        pad_factor (int): Zero-padding factor.\n        f1_base (float): Base frequency for the first sinusoid in Hz.\n        f2_offset_factor (float): Multiplier for delta_f_intrinsic to get f2's offset.\n        A1 (float): Amplitude of the first sinusoid.\n        A2 (float): Amplitude of the second sinusoid.\n        noise_stddev (float): Standard deviation of the Gaussian noise.\n        seed (int): Seed for the random number generator.\n        \n    Returns:\n        list: A five-element list with the analysis results.\n    \"\"\"\n    # 1. Calculate intrinsic resolution and bin spacings\n    T_obs = N0 / fs\n    delta_f_intrinsic = 1.0 / T_obs\n    \n    delta_f_bin_0 = fs / N0\n    \n    N_fft = pad_factor * N0\n    delta_f_bin_pad = fs / N_fft\n\n    # Determine component frequencies for the case\n    f1 = f1_base\n    f2 = f1_base + f2_offset_factor * delta_f_intrinsic\n\n    # 2. Generate the signal\n    rng = np.random.default_rng(seed)\n    delta_t = 1.0 / fs\n    n = np.arange(N0)\n    t = n * delta_t\n    noise = rng.normal(loc=0.0, scale=noise_stddev, size=N0)\n    x = A1 * np.sin(2 * np.pi * f1 * t) + A2 * np.sin(2 * np.pi * f2 * t) + noise\n\n    # 3. Analyze unpadded spectrum\n    X0_k = fft.rfft(x)\n    mag_X0 = np.abs(X0_k)\n    freqs_0 = fft.rfftfreq(N0, d=delta_t)\n    N_res_0 = count_resolved_peaks(mag_X0, freqs_0, delta_f_intrinsic)\n\n    # 4. Analyze zero-padded spectrum\n    Xpad_k = fft.rfft(x, n=N_fft)\n    mag_Xpad = np.abs(Xpad_k)\n    freqs_pad = fft.rfftfreq(N_fft, d=delta_t)\n    N_res_pad = count_resolved_peaks(mag_Xpad, freqs_pad, delta_f_intrinsic)\n    \n    return [delta_f_intrinsic, delta_f_bin_0, delta_f_bin_pad, N_res_0, N_res_pad]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Define common parameters for all test cases\n    common_params = {\n        'fs': 20000.0,\n        'N0': 2048,\n        'pad_factor': 8,\n        'A1': 1.0,\n        'A2': 1.0,\n        'noise_stddev': 0.02\n    }\n\n    # Define the specific parameters for each test case\n    test_cases = [\n        # (f1_base, f2_offset_factor, seed)\n        {'f1_base': 1200.0, 'f2_offset_factor': 5.0, 'seed': 42}, # Case 1\n        {'f1_base': 3000.0, 'f2_offset_factor': 1.0, 'seed': 43}, # Case 2\n        {'f1_base': 4500.0, 'f2_offset_factor': 0.6, 'seed': 44}  # Case 3\n    ]\n    \n    results = []\n    for case_params in test_cases:\n        # Combine common and case-specific parameters\n        params = {**common_params, **case_params}\n        res = analyze_case(**params)\n        results.append(res)\n    \n    # Format the final output string exactly as required\n    case_results_str = []\n    for case_result in results:\n        case_results_str.append(f\"[{','.join(map(str, case_result))}]\")\n    \n    final_output = f\"[{','.join(case_results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Modern fusion diagnostics can generate data at extremely high rates, often exceeding what can be stored or analyzed in real-time. Decimation, or down-sampling, is a key technique for managing these data streams, but it requires careful anti-aliasing filtering to prevent data corruption. This practice problem places you in the role of a data acquisition system designer, tasked with creating a multistage decimation chain and calculating the required FIR filter orders to ensure signal fidelity, a core skill in computational and experimental engineering. ",
            "id": "4024333",
            "problem": "You are designing a multistage decimation chain for interferometer data in computational fusion science and engineering. The goal is to convert a high-rate discrete-time signal sampled at $f_{s,0} = 5\\,\\text{MHz}$ to a lower-rate stream at $f_{\\text{out}} = 500\\,\\text{kHz}$ using a cascade of decimators while preserving signal content up to a guaranteed passband edge $f_p$ and achieving a minimum alias rejection of $A$ in $\\text{dB}$. The chain is specified by a sequence of integer decimation factors $\\{M_i\\}_{i=1}^L$ such that $\\prod_{i=1}^L M_i = f_{s,0}/f_{\\text{out}}$. Each decimator is preceded by a low-pass anti-aliasing filter.\n\nStarting from the Shannon-Nyquist sampling theorem and the definition of down-sampling by an integer factor, derive the conditions that an anti-aliasing filter must satisfy before each decimation stage to prevent aliasing of out-of-band content into the preserved band. Model each stage $i$ as follows:\n- The input sampling rate to stage $i$ is $f_{s,i-1}$, with $f_{s,0} = 5\\,\\text{MHz}$.\n- The decimation factor is $M_i \\in \\mathbb{Z}_{\\ge 2}$, and the output sampling rate of the stage is $f_{s,i} = f_{s,i-1}/M_i$.\n- The folding (alias) frequency for stage $i$ is $f_{\\text{fold},i} = f_{s,i-1}/(2 M_i)$.\n- The passband edge that must be preserved end-to-end is $f_p$, and the stopband must begin no later than $f_{\\text{fold},i}$ to ensure no aliasing of out-of-band content.\n- The transition width for stage $i$ is $\\Delta f_i = f_{\\text{fold},i} - f_p$, which must be strictly positive for the stage to be feasible.\n\nAssume a linear-phase Finite Impulse Response (FIR) low-pass prototype for each stage designed by a conventional Kaiser window method. Use a well-tested synthesis bound for the minimum FIR order $N_i$ that guarantees a stopband attenuation of at least $A$ in $\\text{dB}$ given the transition width $\\Delta \\omega_i$ in radians per sample, where $\\Delta \\omega_i = 2\\pi \\Delta f_i / f_{s,i-1}$. The filter order $N_i$ is defined as the number of delay elements, i.e., the number of taps minus one. Use the smallest integer $N_i$ that satisfies the bound. Treat the attenuation requirement per stage conservatively by requiring each stage to meet the full $A$ in $\\text{dB}$ on its own. If any stage has $\\Delta f_i \\le 0$, declare the chain infeasible.\n\nAll quantities involving frequency must be expressed in $\\text{Hz}$. Angles are in radians. The expected outputs are integer filter orders per stage. If a test case is infeasible (for example, if $\\prod_i M_i \\ne f_{s,0}/f_{\\text{out}}$ as an integer, or any stage has $\\Delta f_i \\le 0$), return the single-element list $[-1]$ for that case.\n\nYour program must implement the above logic and compute the list of per-stage filter orders for each of the following test cases, each specified as a tuple $(f_{s,0}, f_{\\text{out}}, f_p, A, [M_1, M_2, \\dots, M_L])$:\n- Case A (happy path multistage): $(5{,}000{,}000, 500{,}000, 200{,}000, 80, [5, 2])$.\n- Case B (alternative stage ordering): $(5{,}000{,}000, 500{,}000, 200{,}000, 80, [2, 5])$.\n- Case C (single-stage baseline): $(5{,}000{,}000, 500{,}000, 200{,}000, 80, [10])$.\n- Case D (near-boundary preservation): $(5{,}000{,}000, 500{,}000, 245{,}000, 80, [2, 5])$.\n- Case E (infeasible preservation request): $(5{,}000{,}000, 500{,}000, 260{,}000, 80, [2, 5])$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a list of integers representing the per-stage filter orders for that test case (or $[-1]$ if infeasible). For example, an output with two cases would look like $[[N_{1,A},N_{2,A}], [N_{1,B},N_{2,B}]]$ with all $N$ as integers and no additional text.",
            "solution": "The problem as stated requires the derivation and implementation of a procedure for designing a multistage decimation filter chain. The design goal is to determine the minimum required order for a series of Finite Impulse Response (FIR) anti-aliasing filters.\n\n### Step 1: Extract Givens\n- Initial sampling rate: $f_{s,0} = 5\\,\\text{MHz} = 5,000,000\\,\\text{Hz}$\n- Final output sampling rate: $f_{\\text{out}} = 500\\,\\text{kHz} = 500,000\\,\\text{Hz}$\n- Total decimation factor: $\\prod_{i=1}^L M_i = f_{s,0}/f_{\\text{out}}$\n- Sequence of integer decimation factors for $L$ stages: $\\{M_i\\}_{i=1}^L$, where $M_i \\in \\mathbb{Z}_{\\ge 2}$\n- Guaranteed passband edge: $f_p$\n- Minimum alias rejection per stage: $A$ in $\\text{dB}$\n- Input sampling rate to stage $i$: $f_{s,i-1}$\n- Output sampling rate from stage $i$: $f_{s,i} = f_{s,i-1}/M_i$\n- Folding frequency for stage $i$: $f_{\\text{fold},i} = f_{s,i-1}/(2 M_i)$\n- Transition width for stage $i$: $\\Delta f_i = f_{\\text{fold},i} - f_p$\n- Feasibility condition for stage $i$: $\\Delta f_i > 0$\n- FIR filter design method: Kaiser window\n- Normalized transition width for stage $i$: $\\Delta \\omega_i = 2\\pi \\Delta f_i / f_{s,i-1}$\n- FIR filter order bound: Smallest integer $N_i$ satisfying a bound for a stopband attenuation of $A\\,\\text{dB}$.\n- Condition for infeasible chain: $\\Delta f_i \\le 0$ for any stage $i$, or $\\prod M_i \\neq f_{s,0}/f_{\\text{out}}$. In such cases, the output is $[-1]$.\n- Test cases:\n  - Case A: $(f_{s,0}=5000000, f_{\\text{out}}=500000, f_p=200000, A=80, M=[5, 2])$\n  - Case B: $(f_{s,0}=5000000, f_{\\text{out}}=500000, f_p=200000, A=80, M=[2, 5])$\n  - Case C: $(f_{s,0}=5000000, f_{\\text{out}}=500000, f_p=200000, A=80, M=[10])$\n  - Case D: $(f_{s,0}=5000000, f_{\\text{out}}=500000, f_p=245000, A=80, M=[2, 5])$\n  - Case E: $(f_{s,0}=5000000, f_{\\text{out}}=500000, f_p=260000, A=80, M=[2, 5])$\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the established principles of digital signal processing, specifically multirate systems and FIR filter design. It is well-posed, providing all necessary parameters, definitions, and constraints to arrive at a unique solution for each test case. The language is objective and formal. The described task is a standard engineering problem in data acquisition system design. The problem does not violate any of the invalidity criteria.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Principle-Based Design and Derivation\n\nThe process of decimation, or down-sampling, by an integer factor $M$ reduces the sampling rate of a discrete signal. This operation, if performed without caution, can lead to aliasing, where high-frequency content in the original signal masquerades as low-frequency content in the down-sampled signal. The Shannon-Nyquist sampling theorem dictates the conditions to avoid this.\n\nFor a decimation stage $i$ with input sampling rate $f_{s,i-1}$ and decimation factor $M_i$, the output sampling rate becomes $f_{s,i} = f_{s,i-1}/M_i$. The new Nyquist frequency is $f_{s,i}/2$. Any frequency content in the input signal between $f_{s,i}/2$ and $f_{s,i-1}/2$ will \"fold\" into the baseband $[0, f_{s,i}/2]$.\n\nTo prevent this corruption, an anti-aliasing low-pass filter must be applied before down-sampling. This filter must satisfy two primary constraints:\n1.  **Passband**: It must preserve the desired signal content. The problem specifies that all frequencies up to a passband edge $f_p$ must be preserved. So, the filter's passband must extend up to $f_p$.\n2.  **Stopband**: It must sufficiently attenuate frequencies that would alias into the preserved passband. The first and most critical folding action occurs around the new Nyquist frequency, which the problem defines as the folding frequency $f_{\\text{fold},i} = f_{s,i-1}/(2M_i) = f_{s,i}/2$. To conservatively prevent any aliasing, the filter's stopband must begin at or before this frequency.\n\nThe transition from the passband to the stopband cannot be instantaneous. The frequency range between the end of the passband, $f_p$, and the beginning of the stopband, $f_{\\text{stop},i}$, is the transition width. To maximize this width and thus minimize the filter complexity (order), we set the stopband to begin exactly at the folding frequency, i.e., $f_{\\text{stop},i} = f_{\\text{fold},i}$.\n\nThe transition width for the filter at stage $i$, denoted $\\Delta f_i$, is therefore:\n$$ \\Delta f_i = f_{\\text{stop},i} - f_p = f_{\\text{fold},i} - f_p = \\frac{f_{s,i-1}}{2M_i} - f_p $$\nFor a physically realizable filter, this transition width must be strictly positive, $\\Delta f_i > 0$. If $f_p \\ge f_{\\text{fold},i}$, it is impossible to satisfy both the passband and stopband requirements simultaneously, rendering the design for that stage infeasible.\n\nThe required order of an FIR filter is primarily determined by the stopband attenuation $A$ and the normalized transition width $\\Delta \\omega$. The normalization is with respect to the filter's input sampling rate, $f_{s,i-1}$.\n$$ \\Delta \\omega_i = 2\\pi \\frac{\\Delta f_i}{f_{s,i-1}} $$\nFor an FIR filter designed using the Kaiser window method, a widely used empirical formula for estimating the minimum filter order $N$ (defined as the number of taps minus one) is given by:\n$$ N \\ge \\frac{A - 8}{2.285 \\, \\Delta\\omega} $$\nwhere $A$ is the stopband attenuation in decibels ($\\text{dB}$) and is greater than $21$. The problem requires a conservative approach where each stage must provide the full attenuation $A$. Thus, for each stage $i$, we calculate the minimum integer order $N_i$ that meets this bound:\n$$ N_i = \\left\\lceil \\frac{A - 8}{2.285 \\, \\Delta\\omega_i} \\right\\rceil $$\n\nThe overall algorithm for a given test case $(f_{s,0}, f_{\\text{out}}, f_p, A, [M_1, \\dots, M_L])$ is as follows:\n1.  Verify the overall decimation factor: Check if $f_{s,0} = f_{\\text{out}} \\times \\prod_{i=1}^L M_i$. If not, the chain is invalid.\n2.  Initialize the current sampling rate: $f_{s,\\text{current}} \\leftarrow f_{s,0}$. Initialize an empty list for filter orders, `orders`.\n3.  Iterate for each stage $i=1, \\dots, L$ with decimation factor $M_i$:\n    a.  Set the input sampling rate for this stage: $f_{s,i-1} = f_{s,\\text{current}}$.\n    b.  Calculate the folding frequency: $f_{\\text{fold},i} = f_{s,i-1} / (2 M_i)$.\n    c.  Calculate the transition width: $\\Delta f_i = f_{\\text{fold},i} - f_p$.\n    d.  Check for feasibility: If $\\Delta f_i \\le 0$, the chain is infeasible. Abort and return $[-1]$.\n    e.  Calculate the normalized transition width: $\\Delta \\omega_i = (2\\pi \\Delta f_i) / f_{s,i-1}$.\n    f.  Calculate the required filter order: $N_i = \\lceil (A - 8) / (2.285 \\Delta \\omega_i) \\rceil$.\n    g.  Append the integer $N_i$ to the `orders` list.\n    h.  Update the current sampling rate for the next stage: $f_{s,\\text{current}} = f_{s,i-1} / M_i$.\n4.  If the loop completes successfully, return the list `orders`.\n\nThis procedure will be applied to each test case to generate the final results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the multistage decimation filter design problem.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (fs_0, f_out, f_p, A, [M1, M2, ...])\n        (5000000, 500000, 200000, 80, [5, 2]),      # Case A\n        (5000000, 500000, 200000, 80, [2, 5]),      # Case B\n        (5000000, 500000, 200000, 80, [10]),       # Case C\n        (5000000, 500000, 245000, 80, [2, 5]),      # Case D\n        (5000000, 500000, 260000, 80, [2, 5]),      # Case E\n    ]\n\n    def calculate_filter_orders(fs_0, f_out, f_p, A, M_list):\n        \"\"\"\n        Calculates the required FIR filter orders for a multistage decimation chain.\n\n        Args:\n            fs_0 (int): Initial sampling rate in Hz.\n            f_out (int): Final output sampling rate in Hz.\n            f_p (int): Passband edge to be preserved in Hz.\n            A (float): Required stopband attenuation in dB.\n            M_list (list of int): List of integer decimation factors.\n\n        Returns:\n            list of int: A list of calculated filter orders for each stage,\n                         or [-1] if the chain is infeasible.\n        \"\"\"\n        # Validate total decimation factor. The problem implies integer arithmetic.\n        total_m = np.prod(M_list)\n        if fs_0 != f_out * total_m:\n            return [-1]\n\n        orders = []\n        current_fs = float(fs_0)\n        \n        for M_i in M_list:\n            if M_i < 2:  # Decimation factors must be integers >= 2\n                return [-1]\n\n            fs_in_stage = current_fs\n            \n            # Calculate the folding frequency for the current stage\n            f_fold_i = fs_in_stage / (2.0 * M_i)\n            \n            # Calculate the transition width\n            delta_f_i = f_fold_i - f_p\n            \n            # Check for feasibility: transition width must be positive\n            if delta_f_i <= 0:\n                return [-1]\n            \n            # Calculate the normalized transition width (radians per sample)\n            delta_omega_i = 2.0 * math.pi * delta_f_i / fs_in_stage\n            \n            # Estimate filter order N using Kaiser's formula\n            # N_i = ceil((A - 8) / (2.285 * delta_omega_i))\n            # The formula is valid for A > 21 dB.\n            if A <= 8: # Avoid division by zero or negative arguments to ceil if A is low\n                N_i = 0\n            else:\n                numerator = A - 8.0\n                denominator = 2.285 * delta_omega_i\n                N_i = math.ceil(numerator / denominator)\n            \n            orders.append(int(N_i))\n            \n            # Update the sampling rate for the next stage\n            current_fs /= M_i\n            \n        return orders\n\n    results = []\n    for case in test_cases:\n        result = calculate_filter_orders(*case)\n        results.append(result)\n\n    # Format the final output string exactly as required, without spaces in lists.\n    # E.g., [[84,101],[-1]]\n    str_results = [str(res).replace(\" \", \"\") for res in results]\n    final_output_string = f\"[{','.join(str_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}