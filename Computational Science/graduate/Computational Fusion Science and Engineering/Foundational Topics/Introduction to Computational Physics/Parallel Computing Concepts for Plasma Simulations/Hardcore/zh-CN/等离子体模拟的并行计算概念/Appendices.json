{
    "hands_on_practices": [
        {
            "introduction": "评估并行代码的性能是优化的第一步。本练习将介绍强扩展（strong scaling）这一基本概念，即在处理器数量不断增加的情况下运行一个固定大小的问题。通过分析计算、通信和负载不均衡对总运行时间的贡献，您将学会如何诊断性能瓶颈并量化并行效率，这是任何计算科学家都应具备的关键技能 。",
            "id": "4025625",
            "problem": "一款用于计算聚变科学与工程的回旋动理学湍流求解器，在固定问题规模下，从 $P=128$ 个处理单元强扩展到 $P=256$ 个处理单元。对于每个处理器数量，每个时间步的挂钟时间被分解为三个测量分量：纯计算时间、消息传递接口 (MPI) 通信时间，以及由负载不均衡引起的等待时间（测量为全局同步时相对于平均进程进度的超额时间）。测量结果如下：\n- 在 $P=128$ 时：计算时间 $0.54$ 秒，通信时间 $0.18$ 秒，不均衡时间 $0.03$ 秒（均为每时间步）。\n- 在 $P=256$ 时：计算时间 $0.29$ 秒，通信时间 $0.22$ 秒，不均衡时间 $0.05$ 秒（均为每时间步）。\n\n假设问题规模是固定的，并且在每个 $P$ 下，每个时间步的总挂钟时间是所报告的三个分量之和。将从 $P=128$ 增加到 $P=256$ 时的实际加速比定义为：在相同工作负载下，$P=128$ 时的每时间步总时间与 $P=256$ 时的每时间步总时间之比。将此次处理器数量加倍的并行效率定义为：实际加速比与在固定问题规模下处理器数量加倍时的理想加速比之比。\n\n计算从 $P=128$ 加倍到 $P=256$ 时的并行效率，通过所提供的测量数据明确考虑通信开销和负载不均衡。将您的答案表示为无量纲小数，并四舍五入到四位有效数字。",
            "solution": "首先根据既定准则对问题进行验证。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n- 初始处理单元数：$P_1 = 128$。\n- 最终处理单元数：$P_2 = 256$。\n- 问题规模固定（强扩展）。\n- 在 $P_1 = 128$ 时的测量时间：\n    - 每个时间步的计算时间：$T_{\\text{comp},1} = 0.54$ 秒。\n    - 每个时间步的通信时间：$T_{\\text{comm},1} = 0.18$ 秒。\n    - 每个时间步的负载不均衡时间：$T_{\\text{imb},1} = 0.03$ 秒。\n- 在 $P_2 = 256$ 时的测量时间：\n    - 每个时间步的计算时间：$T_{\\text{comp},2} = 0.29$ 秒。\n    - 每个时间步的通信时间：$T_{\\text{comm},2} = 0.22$ 秒。\n    - 每个时间步的负载不均衡时间：$T_{\\text{imb},2} = 0.05$ 秒。\n- 总时间的定义：每个时间步的总挂钟时间 $T_{\\text{total}}$ 是三个分量之和：$T_{\\text{total}} = T_{\\text{comp}} + T_{\\text{comm}} + T_{\\text{imb}}$。\n- 实际加速比的定义：实际加速比 $S_{\\text{achieved}}$ 是在 $P_1$ 时的总时间与在 $P_2$ 时的总时间之比，即 $S_{\\text{achieved}} = T_{\\text{total},1} / T_{\\text{total},2}$。\n- 并行效率的定义：此次加倍的并行效率 $\\eta$ 是实际加速比与理想加速比之比。\n- 最终答案应为无量纲小数，并四舍五入到四位有效数字。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，因为它描述了高性能计算和计算科学中常见的标准强扩展性能分析。将挂钟时间分解为计算、通信和负载不均衡是一种有效且广泛使用的方法。数值对于扩展性实验是现实的：计算时间减少（如预期地大约减半），而通信和不均衡开销随着处理器数量的增加而增加。问题定义明确，为求得唯一解提供了所有必要的定义和数据。语言客观、精确。问题是自洽的、一致的，并且没有违反任何基本原则。\n\n**步骤 3：结论与行动**\n问题被认为是有效的。将推导解答。\n\n**求解推导**\n\n目标是计算一个回旋动理学湍流求解器从 $P_1 = 128$ 个处理单元强扩展到 $P_2 = 256$ 个处理单元时的并行效率 $\\eta$。\n\n首先，我们计算每个处理器数量下每个时间步的总挂钟时间。根据问题定义，总时间是计算、通信和不均衡分量之和。\n\n对于具有 $P_1 = 128$ 个处理器的初始配置，总时间 $T_{\\text{total},1}$ 为：\n$$T_{\\text{total},1} = T_{\\text{comp},1} + T_{\\text{comm},1} + T_{\\text{imb},1}$$\n代入给定值：\n$$T_{\\text{total},1} = 0.54 \\, \\text{s} + 0.18 \\, \\text{s} + 0.03 \\, \\text{s} = 0.75 \\, \\text{s}$$\n\n对于具有 $P_2 = 256$ 个处理器的最终配置，总时间 $T_{\\text{total},2}$ 为：\n$$T_{\\text{total},2} = T_{\\text{comp},2} + T_{\\text{comm},2} + T_{\\text{imb},2}$$\n代入给定值：\n$$T_{\\text{total},2} = 0.29 \\, \\text{s} + 0.22 \\, \\text{s} + 0.05 \\, \\text{s} = 0.56 \\, \\text{s}$$\n\n接下来，我们计算实际加速比 $S_{\\text{achieved}}$。这被定义为在固定问题规模下，较少处理器数量上的总时间与较多处理器数量上的总时间之比。\n$$S_{\\text{achieved}} = \\frac{T_{\\text{total},1}}{T_{\\text{total},2}}$$\n使用我们计算出的总时间：\n$$S_{\\text{achieved}} = \\frac{0.75}{0.56}$$\n\n对于强扩展问题，理想加速比 $S_{\\text{ideal}}$ 是最终处理器数量与初始处理器数量之比。\n$$S_{\\text{ideal}} = \\frac{P_2}{P_1}$$\n代入给定的处理器数量：\n$$S_{\\text{ideal}} = \\frac{256}{128} = 2$$\n\n最后，并行效率 $\\eta$ 定义为实际加速比与理想加速比之比。\n$$\\eta = \\frac{S_{\\text{achieved}}}{S_{\\text{ideal}}}$$\n代入 $S_{\\text{achieved}}$ 和 $S_{\\text{ideal}}$ 的表达式：\n$$\\eta = \\frac{\\left(\\frac{T_{\\text{total},1}}{T_{\\text{total},2}}\\right)}{S_{\\text{ideal}}} = \\frac{\\left(\\frac{0.75}{0.56}\\right)}{2}$$\n现在，我们计算数值：\n$$\\eta = \\frac{1.3392857...}{2} = 0.669642857...$$\n问题要求答案四舍五入到四位有效数字。\n$$\\eta \\approx 0.6696$$\n这个值代表了并行化的效率，其中效率为 $1$ 表示理想扩展。结果 $\\eta \\approx 0.6696$ 表明，该代码实现了大约 $67\\%$ 的理想加速比，剩余的性能损失归因于处理器数量加倍时通信和负载不均衡开销的增加。",
            "answer": "$$\\boxed{0.6696}$$"
        },
        {
            "introduction": "大多数大规模等离子体模拟都依赖于区域分解（domain decomposition），即将计算网格划分给多个处理器。本练习将指导您设计一种“幽灵单元”（ghost cell）或“光环”（halo）交换机制，这是在结构化网格中相邻子域之间通信边界数据的标准技术。您将实现这一核心通信模式的模拟，计算其内存占用，并验证其正确性，从而对并行代码如何管理数据局部性和进程间通信获得具体的理解 。",
            "id": "4025608",
            "problem": "您的任务是为三维、结构化、有限体积等离子体模拟设计一个消息传递接口（MPI）邻居集合通信方案，用于仅与几何邻居交换电流密度。目标是推导出一个原理清晰的算法并计算其内存占用。您将在软件中实现并模拟该方案，假设采用仅包含面相邻邻居的笛卡尔域分解。您不能依赖实际的 MPI 库；相反，需要构建一个符合三维拓扑几何约束的正确的邻居交换模拟。所有答案必须以字节（bytes）表示，并且您的程序必须以指定的输出格式生成结果。\n\n基本科学背景：在连续介质电动力学中，电荷守恒要求电流密度矢量在单元面之间进行一致交换，以使离散通量在子域之间保持平衡。从电荷连续性方程出发，\n$$\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot \\mathbf{J} = 0,$$\n其中 $\\rho$ 是电荷密度，$\\mathbf{J}$ 是电流密度，有限体积离散化引入了面通量，这些通量在子域边界上耦合了相邻的单元。在笛卡尔分解下，电流密度 $\\mathbf{J} = (J_x, J_y, J_z)$ 在界面上的交换仅限于几何上的面邻居，这与通量的局部性一致。在采用域分解的并行计算中，使用厚度为 $\\delta$ 层的鬼单元，以便每个子域可以使用从相邻子域交换来的数据计算面心通量。\n\n您必须构建一个仅使用沿 $x$、$y$ 和 $z$ 轴的几何面邻居的邻居集合通信方案。周期性边界条件可以环绕邻居索引；非周期性边界则会截断邻居交换。\n\n核心定义与假设：\n- 全局网格尺寸为 $N_x \\times N_y \\times N_z$ 个单元。\n- 进程网格为 $P_x \\times P_y \\times P_z$ 个进程，采用大小相等的块进行笛卡尔分解。假设 $N_x$、$N_y$、$N_z$ 分别能被 $P_x$、$P_y$、$P_z$ 整除。\n- 每个进程拥有一个大小为 $n_x \\times n_y \\times n_z$ 的局部块，其中 $n_x = N_x / P_x$，$n_y = N_y / P_y$，$n_z = N_z / P_z$。\n- 鬼层厚度为 $\\delta$（以单元层数计）。如果 $\\delta$ 超过了沿任一轴 $d \\in \\{x,y,z\\}$ 的局部维度 $n_d$，则在该轴上使用 $\\min(\\delta, n_d)$ 作为交换厚度。\n- 只交换面邻居（$\\pm x$、$\\pm y$、$\\pm z$）。不执行边或角的交换。\n- 电流密度矢量有 $c$ 个分量（使用 $c = 3$），每个分量存储为 $b$ 字节的浮点数（双精度使用 $b = 8$）。\n- 对于任何局部面积为 $A$、厚度为 $t$ 的面，消息大小（以字节计）为 $c \\cdot b \\cdot A \\cdot t$。\n- 对于每个进程，总发送缓冲区大小是发送给现有邻居的面消息之和；总接收缓冲区大小是来自其邻居的传入面消息之和（对于均匀块，这与传出大小相同，但必须一致地计算）。每个进程的内存占用是发送和接收缓冲区大小之和（以字节计）。\n- 周期性是按轴指定的。如果沿轴 $d$ 是周期的，邻居会环绕；否则，沿 $d$ 轴没有邻居的边界进程不会在该面上交换数据。\n\n需要实现的算法任务：\n- 构建具有秩坐标 $(i_x,i_y,i_z)$ 的笛卡尔进程拓扑，并考虑周期性进行面相邻邻居映射。\n- 计算局部块大小 $n_x$、$n_y$、$n_z$ 以及各方向的交换厚度 $t_x = \\min(\\delta, n_x)$、$t_y = \\min(\\delta, n_y)$、$t_z = \\min(\\delta, n_z)$。\n- 计算各面的面积 $A_{x} = n_y n_z$、$A_{y} = n_x n_z$ 和 $A_{z} = n_x n_y$。\n- 通过对所有存在的面邻居 $d \\in \\{x,y,z\\}$ 和方向 $\\pm$ 求和 $c \\cdot b \\cdot A_d \\cdot t_d$，推导出每个进程的发送和接收内存占用。\n- 通过以下方式实现邻居交换模拟：\n  - 为每个进程分配形状为 $(n_x, n_y, n_z, c)$ 的内部数组和形状为 $(n_x + 2\\delta, n_y + 2\\delta, n_z + 2\\delta, c)$ 的带鬼元的扩展数组。\n  - 使用一个关于 $(i,j,k)$、分量索引和进程秩的确定性函数填充内部数组，以进行验证。\n  - 将邻居内部数组的面边界切片复制到具有厚度 $t_x$、$t_y$ 和 $t_z$ 的相应鬼层中。\n  - 验证对于所有存在的邻居，每个进程的鬼元面都等于邻居的内部边界面切片。忽略非周期性方向上不存在的面。\n\n验证与输出：\n- 对于每个测试用例，计算：\n  $1)$ 所有进程中最大的单个进程内存占用（以字节计），\n  $2)$ 所有进程的总内存占用（以字节计），\n  $3)$ 一个布尔值，指示邻居交换是否为所有存在的几何邻居面生成了正确的鬼层。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例排序并展平为：\n  $[$max\\_bytes\\_case\\_1, total\\_bytes\\_case\\_1, validity\\_case\\_1, max\\_bytes\\_case\\_2, total\\_bytes\\_case\\_2, validity\\_case\\_2, \\dots$]$.\n\n测试套件：\n- 案例 $1$（正常路径）：$N_x = 64$，$N_y = 48$，$N_z = 32$；$P_x = 4$，$P_y = 3$，$P_z = 2$；$\\delta = 2$；周期性 $(\\text{True}, \\text{True}, \\text{False})$；$c = 3$；$b = 8$ 字节。\n- 案例 $2$（鬼元为零的边界条件）：$N_x = 64$，$N_y = 48$，$N_z = 32$；$P_x = 4$，$P_y = 3$，$P_z = 2$；$\\delta = 0$；周期性 $(\\text{False}, \\text{False}, \\text{False})$；$c = 3$；$b = 8$ 字节。\n- 案例 $3$（鬼元相对于块尺寸较大的边缘情况）：$N_x = 16$，$N_y = 16$，$N_z = 8$；$P_x = 2$，$P_y = 2$，$P_z = 2$；$\\delta = 3$；周期性 $(\\text{True}, \\text{True}, \\text{True})$；$c = 3$；$b = 8$ 字节。\n- 案例 $4$（各向异性块和混合周期性）：$N_x = 90$，$N_y = 30$，$N_z = 24$；$P_x = 3$，$P_y = 3$，$P_z = 2$；$\\delta = 1$；周期性 $(\\text{False}, \\text{True}, \\text{True})$；$c = 3$；$b = 8$ 字节。\n\n所有内存结果必须以字节为单位。布尔有效性必须是 $\\text{True}$ 或 $\\text{False}$。",
            "solution": "该问题要求为并行计算机上的三维等离子体模拟设计并验证一个邻居通信方案。该解决方案基于域分解、鬼单元交换和笛卡尔进程拓扑的原理，这些都是可扩展科学计算的基础。\n\n**1. 理论框架：域分解与进程拓扑**\n\n大小为 $N_x \\times N_y \\times N_z$ 个单元的全局计算域被分解为 $P_x \\times P_y \\times P_z$ 个进程的笛卡尔网格。每个进程被分配一个唯一的整数秩 $r \\in [0, P_{total}-1]$，其中 $P_{total} = P_x P_y P_z$。这个秩可以映射到进程网格内的一个唯一的三维坐标 $(i_x, i_y, i_z)$，其中 $i_x \\in [0, P_x-1]$，$i_y \\in [0, P_y-1]$，$i_z \\in [0, P_z-1]$。从秩 $r$到坐标的映射由以下公式给出：\n$$i_x = \\lfloor r / (P_y P_z) \\rfloor$$\n$$i_y = \\lfloor (r \\pmod{P_y P_z}) / P_z \\rfloor$$\n$$i_z = r \\pmod{P_z}$$\n逆向映射，即从坐标到秩，是 $r = i_x (P_y P_z) + i_y P_z + i_z$。每个进程管理一个大小为 $n_x \\times n_y \\times n_z$ 的局域子域（块），其中对于每个轴 $d \\in \\{x, y, z\\}$，$n_d = N_d / P_d$。\n\n通信仅限于面相邻的邻居。对于一个位于 $(i_x, i_y, i_z)$ 的进程，其在例如 $+x$ 方向上的邻居位于坐标 $(i_x+1, i_y, i_z)$。该邻居是否存在取决于边界条件。对于 $x$ 轴上的非周期性边界，仅当 $0 \\le i_x+1  P_x$ 时邻居才存在。对于周期性边界，坐标会环绕：$i'_x = (i_x+1) \\pmod{P_x}$。此逻辑适用于所有 $6$ 个方向（$\\pm x, \\pm y, \\pm z$）。\n\n**2. 鬼单元与数据交换**\n\n为了计算子域边界上的物理量（如通量），一个进程需要来自其邻居的数据。这通过用“鬼单元”（也称为晕圈单元）层包围局部数据块来实现。这些鬼单元用来自相邻进程相应内部边界区域的数据填充。鬼层的厚度由 $\\delta$ 给出。\n\n沿轴 $d$ 交换的数据量由有效交换厚度 $t_d$ 决定，定义为 $t_d = \\min(\\delta, n_d)$。这考虑了鬼层厚度 $\\delta$ 大于局部域尺寸 $n_d$ 的情况，此时将交换该轴上的整个局部域。\n\n被交换的数据是电流密度矢量 $\\mathbf{J}$，它有 $c=3$ 个分量，每个分量存储为 $b=8$ 字节的浮点数。更新特定面的鬼区域所需的消息大小是分量数量（$c$）、每个分量的大小（$b$）、面的面积（$A_d$）和交换厚度（$t_d$）的乘积。例如，对于垂直于 $x$ 轴的面的消息大小为：\n$$M_x = c \\cdot b \\cdot A_x \\cdot t_x = c \\cdot b \\cdot (n_y n_z) \\cdot t_x$$\n$M_y = c \\cdot b \\cdot (n_x n_z) \\cdot t_y$ 和 $M_z = c \\cdot b \\cdot (n_x n_y) \\cdot t_z$ 也有类似的表达式。\n\n**3. 内存占用计算**\n\n用于通信的每个进程的内存占用定义为其发送和接收缓冲区大小的总和。一个进程的总发送缓冲区大小是发送给其所有现有邻居的消息大小的总和。总接收缓冲区大小的定义类似。对于坐标为 $(i_x, i_y, i_z)$ 的进程 $r$，我们可以通过对来自所有 $6$ 个潜在邻居方向的贡献求和来计算其内存占用：\n$$M_{proc}(r) = S_{send}(r) + S_{recv}(r)$$\n其中 $S_{send}(r)$ 和 $S_{recv}(r)$ 的计算如下：\n初始化 $S_{send}(r) = 0$ 和 $S_{recv}(r) = 0$。\n对于每个方向 $d \\in \\{x,y,z\\}$ 和符号 $\\sigma \\in \\{-,+\\}$：\n如果 $\\sigma d$ 方向上存在邻居：\n$$S_{send}(r) \\leftarrow S_{send}(r) + M_d$$\n$$S_{recv}(r) \\leftarrow S_{recv}(r) + M_d$$\n由于块大小是均匀的，发送给邻居的消息大小等于从它接收到的消息大小。单个进程的最大内存占用是 $\\max_{r} M_{proc}(r)$，总内存占用是 $\\sum_{r} M_{proc}(r)$。\n\n**4. 算法模拟与验证**\n\n邻居交换的模拟不使用实际的 MPI 库。该过程包括以下步骤：\n1.  **初始化**：为每个进程分配一个形状为 $(n_x, n_y, n_z, c)$ 的内部数据数组。使用一个关于单元索引 $(i, j, k)$、矢量分量索引和进程秩的确定性函数，用唯一值填充该数组。这确保了任何错位的数据都可以被检测到。同时分配一个更大的、形状为 $(n_x + 2\\delta, n_y + 2\\delta, n_z + 2\\delta, c)$ 的带鬼元的扩展数组，并将内部数据复制到其中心。\n2.  **交换模拟**：算法遍历每个进程及其所有存在的邻居。对于每个邻居对，它从邻居的内部数组中识别出数据的边界切片，并将其复制到当前进程的带鬼元的扩展数组中相应的鬼单元区域。例如，要填充进程 $r$ 的 $+x$ 面上的鬼区域，需要从其 $+x$ 邻居的 $-x$ 边界面复制数据。要复制的切片厚度为 $t_x$，高度为 $n_y$，深度为 $n_z$。对所有进程的所有 $6$ 个方向重复此操作。\n3.  **验证**：交换后，验证数据传输的正确性。对于每个进程和每个存在的邻居，将给定鬼区域中的数据与邻居内部数组中相应边界区域的数据进行比较。如果所有进程的所有鬼区域中的所有数据都与它们预期的源切片匹配，则认为交换有效 (`True`)。如果发现任何不匹配，则交换无效 (`False`)。对于 $\\delta=0$ 的情况，鬼层和交换厚度都为零，这导致一个平凡但有效的交换，内存占用为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {'N': (64, 48, 32), 'P': (4, 3, 2), 'delta': 2, 'periodicity': (True, True, False), 'c': 3, 'b': 8},\n        # Case 2 (boundary condition with zero ghost)\n        {'N': (64, 48, 32), 'P': (4, 3, 2), 'delta': 0, 'periodicity': (False, False, False), 'c': 3, 'b': 8},\n        # Case 3 (edge case with large ghost relative to block size)\n        {'N': (16, 16, 8), 'P': (2, 2, 2), 'delta': 3, 'periodicity': (True, True, True), 'c': 3, 'b': 8},\n        # Case 4 (anisotropic blocks and mixed periodicity)\n        {'N': (90, 30, 24), 'P': (3, 3, 2), 'delta': 1, 'periodicity': (False, True, True), 'c': 3, 'b': 8},\n    ]\n\n    results = []\n    for params in test_cases:\n        max_fp, total_fp, is_valid = simulate_case(**params)\n        results.extend([max_fp, total_fp, is_valid])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef simulate_case(N, P, delta, periodicity, c, b):\n    \"\"\"\n    Simulates the neighborhood collective scheme for a single test case.\n    \"\"\"\n    Nx, Ny, Nz = N\n    Px, Py, Pz = P\n    P_total = Px * Py * Pz\n\n    # Local block sizes\n    nx, ny, nz = Nx // Px, Ny // Py, Nz // Pz\n\n    # Per-direction exchange thicknesses\n    tx = min(delta, nx)\n    ty = min(delta, ny)\n    tz = min(delta, nz)\n\n    # Per-face areas\n    Ax = ny * nz\n    Ay = nx * nz\n    Az = nx * ny\n\n    # Message sizes\n    msg_size_x = c * b * Ax * tx\n    msg_size_y = c * b * Ay * ty\n    msg_size_z = c * b * Az * tz\n    msg_sizes = [msg_size_x, msg_size_y, msg_size_z]\n\n    # Process topology and neighbor finding\n    procs = []\n    for r in range(P_total):\n        # Rank to coordinates\n        ix = r // (Py * Pz)\n        iy = (r % (Py * Pz)) // Pz\n        iz = r % Pz\n        \n        proc_info = {'rank': r, 'coord': (ix, iy, iz), 'neighbors': {}}\n        \n        coords = [ix, iy, iz]\n        proc_dims = [Px, Py, Pz]\n\n        # Find neighbors for each of the 6 directions\n        for axis in range(3): # 0:x, 1:y, 2:z\n            for sign in [-1, 1]: # -1: negative, +1: positive\n                neighbor_coord = list(coords)\n                neighbor_coord[axis] += sign\n                \n                is_periodic = periodicity[axis]\n                dim_size = proc_dims[axis]\n                \n                neighbor_rank = None\n                if is_periodic:\n                    neighbor_coord[axis] %= dim_size\n                    # Coord to rank\n                    nix, niy, niz = neighbor_coord\n                    neighbor_rank = nix * Py * Pz + niy * Pz + niz\n                elif 0 = neighbor_coord[axis]  dim_size:\n                    # Coord to rank\n                    nix, niy, niz = neighbor_coord\n                    neighbor_rank = nix * Py * Pz + niy * Pz + niz\n\n                proc_info['neighbors'][(axis, sign)] = neighbor_rank\n        procs.append(proc_info)\n\n    # Memory footprint calculation\n    footprints = []\n    for proc in procs:\n        send_buffer = 0\n        recv_buffer = 0\n        for (axis, sign), neighbor_rank in proc['neighbors'].items():\n            if neighbor_rank is not None:\n                msg_size = msg_sizes[axis]\n                send_buffer += msg_size\n                recv_buffer += msg_size\n        footprints.append(send_buffer + recv_buffer)\n\n    max_footprint = max(footprints) if footprints else 0\n    total_footprint = sum(footprints) if footprints else 0\n\n    # If delta is 0, exchange is trivial and valid, memory is 0.\n    if delta == 0:\n        return 0, 0, True\n\n    # --- Simulation of data exchange ---\n    \n    # 1. Initialize data for all processes\n    sim_data = {}\n    for r in range(P_total):\n        # Deterministic filling function\n        def fill_func(i, j, k, comp, rank):\n            return rank * 10000000 + i * 100000 + j * 1000 + k * 100 + comp\n\n        interior = np.fromfunction(np.vectorize(fill_func), (nx, ny, nz, c), dtype=np.float64, rank=r)\n        \n        ghosted_shape = (nx + 2 * delta, ny + 2 * delta, nz + 2 * delta, c)\n        ghosted = np.full(ghosted_shape, -1.0, dtype=np.float64) # Fill with a sentinel value\n        \n        # Copy interior data to the center of the ghosted array\n        ghosted[delta:delta+nx, delta:delta+ny, delta:delta+nz, :] = interior\n        \n        sim_data[r] = {'interior': interior, 'ghosted': ghosted}\n\n    # 2. Perform the exchange\n    for r in range(P_total):\n        proc = procs[r]\n        for (axis, sign), neighbor_rank in proc['neighbors'].items():\n            if neighbor_rank is not None:\n                neighbor_interior = sim_data[neighbor_rank]['interior']\n                local_ghosted = sim_data[r]['ghosted']\n                \n                # Get source slice from neighbor's interior\n                if axis == 0: # x-axis\n                    src = neighbor_interior[nx-tx:, :, :, :] if sign == -1 else neighbor_interior[:tx, :, :, :]\n                elif axis == 1: # y-axis\n                    src = neighbor_interior[:, ny-ty:, :, :] if sign == -1 else neighbor_interior[:, :ty, :, :]\n                else: # z-axis\n                    src = neighbor_interior[:, :, nz-tz:, :] if sign == -1 else neighbor_interior[:, :, :tz, :]\n                \n                # Get destination view in local ghosted array\n                if axis == 0: # x-axis\n                    dest_view = local_ghosted[delta-tx:delta, delta:delta+ny, delta:delta+nz, :] if sign == -1 \\\n                        else local_ghosted[delta+nx:delta+nx+tx, delta:delta+ny, delta:delta+nz, :]\n                elif axis == 1: # y-axis\n                    dest_view = local_ghosted[delta:delta+nx, delta-ty:delta, delta:delta+nz, :] if sign == -1 \\\n                        else local_ghosted[delta:delta+nx, delta+ny:delta+ny+ty, delta:delta+nz, :]\n                else: # z-axis\n                    dest_view = local_ghosted[delta:delta+nx, delta:delta+ny, delta-tz:delta, :] if sign == -1 \\\n                        else local_ghosted[delta:delta+nx, delta:delta+ny, delta+nz:delta+nz+tz, :]\n\n                dest_view[:] = src\n\n    # 3. Validation\n    is_valid = True\n    for r in range(P_total):\n        proc = procs[r]\n        for (axis, sign), neighbor_rank in proc['neighbors'].items():\n            if neighbor_rank is not None:\n                neighbor_interior = sim_data[neighbor_rank]['interior']\n                local_ghosted = sim_data[r]['ghosted']\n\n                # Re-calculate source slice from neighbor's interior\n                if axis == 0: # x-axis\n                    src_slice = neighbor_interior[nx-tx:, :, :, :] if sign == -1 else neighbor_interior[:tx, :, :, :]\n                elif axis == 1: # y-axis\n                    src_slice = neighbor_interior[:, ny-ty:, :, :] if sign == -1 else neighbor_interior[:, :ty, :, :]\n                else: # z-axis\n                    src_slice = neighbor_interior[:, :, nz-tz:, :] if sign == -1 else neighbor_interior[:, :, :tz, :]\n\n                # Re-calculate destination ghost slice from local ghosted array\n                if axis == 0: # x-axis\n                    ghost_slice = local_ghosted[delta-tx:delta, delta:delta+ny, delta:delta+nz, :] if sign == -1 \\\n                        else local_ghosted[delta+nx:delta+nx+tx, delta:delta+ny, delta:delta+nz, :]\n                elif axis == 1: # y-axis\n                    ghost_slice = local_ghosted[delta:delta+nx, delta-ty:delta, delta:delta+nz, :] if sign == -1 \\\n                        else local_ghosted[delta:delta+nx, delta+ny:delta+ny+ty, delta:delta+nz, :]\n                else: # z-axis\n                    ghost_slice = local_ghosted[delta:delta+nx, delta:delta+ny, delta-tz:delta, :] if sign == -1 \\\n                        else local_ghosted[delta:delta+nx, delta:delta+ny, delta+nz:delta+nz+tz, :]\n                \n                if not np.array_equal(src_slice, ghost_slice):\n                    is_valid = False\n                    break\n        if not is_valid:\n            break\n            \n    return int(max_footprint), int(total_footprint), is_valid\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "现代等离子体模拟通常利用图形处理单元（GPU）其大规模的并行能力，但要实现高性能需要理解其特定架构。本问题探讨了“单指令，多线程”（SIMT）模型中的“线程束分化”（warp divergence）概念，其中条件分支可能导致执行串行化并降低性能。通过比较一个用于边界条件的标准分支实现和一个无分支的算术方法，您将在编写硬件感知代码方面获得实践经验，从而最大限度地减少分化并最大化 GPU 上的计算吞吐量 。",
            "id": "4025556",
            "problem": "考虑一个二维显式有限差分更新，用于表示等离子体中静电势的标量场 $\\phi(x,y)$，该场定义在大小为 $N_x \\times N_y$ 的均匀笛卡尔网格上。设在离散时间步长的更新由一个五点模板定义，该模板使用最近邻值，与等离子体模拟中椭圆或抛物算子的标准离散化方法一致。图形处理器 (GPU) 上的线程遵循单指令多线程 (SIMT) 模型，其中一组 $W$ 个线程以锁步方式执行；这样的一组线程称为一个 warp。当一个 warp 中的线程评估一个分支并采取不同路径时，该 warp 会通过掩蔽的方式串行执行每个路径，这种现象称为 warp 分化。\n\n基本假设：\n- 单指令多线程 (SIMT) warp 执行：如果一个 warp 中的线程在条件分支上发生分化，该 warp 将串行化执行每个被采纳的不同路径，并掩蔽非活动线程，直到再次收敛。\n- 一个 warp有 $W$ 个通道，索引为 $\\ell \\in \\{0,1,\\dots,W-1\\}$。\n- 对于带有一个 if-else 分支的 warp，其总执行时间等于该 warp 中至少有一个通道所采纳的每个路径的周期成本之和。\n- 网格以行主序与线程一一映射：线程索引 $t \\in \\{0,1,\\dots,N_x N_y-1\\}$ 对应坐标 $(x,y)$，其中 $x = t \\bmod N_x$ 且 $y = \\left\\lfloor t / N_x \\right\\rfloor$。\n- 边界条件检测使用谓词“是边界”，对于任何满足 $x=0$、$x=N_x-1$、$y=0$ 或 $y=N_y-1$ 的单元格，该谓词为真。\n\n您将分析由边界条件分支引起的 warp 分化效应，然后为周期性边界条件提出一种无分支的公式。将各路径的周期成本视为与数据无关的常数：内部路径成本为 $C_i$ 周期，边界路径成本为 $C_b$ 周期。对于无分支公式，假设每个 warp 的成本是统一的 $C_f$ 周期，且与线程是否位于边界无关。周期性边界条件的无分支公式必须仅使用索引算术构建，而不使用条件分支。\n\n任务：\n1. 基于 SIMT warp 执行模型，推导出一个基于分支的内核的总周期数公式，形式为对所有 warp 的求和。使用指示函数表达每个 warp 的贡献，这些函数反映了 warp 中是否至少有一个通道是内部通道以及是否至少有一个通道是边界通道。\n2. 提出一种仅使用算术索引变换来访问邻居的周期性边界条件的无分支公式。从逻辑上证明为什么该公式对内部和边界单元格都能产生正确的邻居索引。\n3. 实现一个程序，给定 $(N_x, N_y, W, C_i, C_b, C_f)$，计算基于分支的内核和无分支内核的总周期数，并返回定义为以下比率的加速比\n$$\nS = \\frac{\\text{基于分支的内核的总周期数}}{\\text{无分支内核的总周期数}}。\n$$\n计算必须遵循所提供的 SIMT 模型和映射，并且必须在 $N_x N_y$ 不是 $W$ 的倍数时考虑不完整的 warp。\n\n无分支周期性边界公式要求：\n- 对于每个单元格 $(x,y)$，使用算术环绕定义邻居索引：\n$$\nx_- = (x - 1 + N_x) \\bmod N_x,\\quad x_+ = (x + 1) \\bmod N_x,\n$$\n$$\ny_- = (y - 1 + N_y) \\bmod N_y,\\quad y_+ = (y + 1) \\bmod N_y.\n$$\n- 访问邻居 $(x_-,y)$、$(x_+,y)$、$(x,y_-)$、$(x,y_+)$ 时不使用条件分支。\n\n测试套件：\n评估以下参数集的加速比 $S$。所有量均为无量纲的周期计数和索引。\n\n- 案例 A（一般情况）：$N_x=128$, $N_y=128$, $W=32$, $C_i=80$, $C_b=140$, $C_f=90$。\n- 案例 B（边界密集的小网格）：$N_x=33$, $N_y=33$, $W=32$, $C_i=80$, $C_b=140$, $C_f=95$。\n- 案例 C（一维简化）：$N_x=32$, $N_y=1$, $W=32$, $C_i=50$, $C_b=60$, $C_f=52$。\n- 案例 D（内部为主的大网格）：$N_x=1000$, $N_y=1000$, $W=32$, $C_i=80$, $C_b=160$, $C_f=100$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含按 A、B、C、D 顺序排列的这些案例的加速比，形式为方括号内以逗号分隔的列表。每个加速比必须格式化为四舍五入到六位小数的浮点数，例如，“[1.234567,0.987654,1.000000,1.111111]”。不应打印任何额外文本。",
            "solution": "该问题要求在图形处理器 (GPU) 架构的背景下，分析在二维网格上执行有限差分更新的两种不同实现的计算成本。问题的核心在于为边界条件检查引起的条件分支（`if-else` 语句）的性能影响建模，这种现象在单指令多线程 (SIMT) 执行模型中被称为 warp 分化。\n\n根据要求，分析分为三个部分：为通用的基于分支的内核推导成本公式，为周期性边界条件的专用无分支内核的正确性进行论证，以及实现一个程序来计算后者相对于前者的性能加速比。\n\n### 第 1 部分：基于分支的内核的成本公式\n\n内核的总执行时间是所有 warp 执行时间的总和。我们必须首先确定单个 warp 的成本，然后对所有 warp 求和。\n\n设计算网格维度为 $N_x \\times N_y$。网格单元总数，即线程总数，为 $N_{threads} = N_x N_y$。线程被分组为大小为 $W$ 的 warp。覆盖所有线程所需的 warp 总数 $N_{warps}$ 由 $N_{threads}$ 除以 $W$ 的向上取整给出：\n$$\nN_{warps} = \\left\\lceil \\frac{N_x N_y}{W} \\right\\rceil\n$$\n在整数算术中，这计算为 $(N_x N_y + W - 1) / W$。\n\n让我们考虑一个任意的 warp，索引为 $k$，其中 $k \\in \\{0, 1, \\dots, N_{warps}-1\\}$。此 warp 由一组全局索引 $t$ 在范围 $kW \\le t  \\min((k+1)W, N_x N_y)$ 内的线程组成。每个线程 $t$ 通过指定的行主序映射到网格单元坐标 $(x,y)$：\n$$\nx = t \\bmod N_x \\quad \\text{且} \\quad y = \\lfloor t / N_x \\rfloor\n$$\n如果线程对应的单元格 $(x,y)$ 满足条件 $x=0$、$x=N_x-1$、$y=0$ 或 $y=N_y-1$，则认为该线程位于边界上。我们定义一个布尔函数 $B(t)$，如果线程 $t$ 在边界上，则为真，否则为假。\n\n根据所提供的 SIMT 执行模型，带有 `if-else` 分支的 warp 的成本是该 warp 中至少有一个线程所采纳的所有路径的成本之和。这两个路径是成本为 $C_i$ 的“内部”路径和成本为 $C_b$ 的“边界”路径。\n\n对于给定的 warp $k$，我们可以定义两个指示函数：\n1.  $\\mathbb{1}_{I_k}$：如果 warp $k$ 中至少有一个线程是内部线程（即，在 warp $k$ 中 $\\exists t$ 使得 $\\neg B(t)$），则为 $1$，否则为 $0$。\n2.  $\\mathbb{1}_{B_k}$：如果 warp $k$ 中至少有一个线程是边界线程（即，在 warp $k$ 中 $\\exists t$ 使得 $B(t)$），则为 $1$，否则为 $0$。\n\n因此，warp $k$ 的成本，记为 $C_{warp, k}$，为：\n$$\nC_{warp, k} = \\mathbb{1}_{I_k} C_i + \\mathbb{1}_{B_k} C_b\n$$\n该表达式正确地捕捉了一个 warp 的三种可能性：\n-   如果所有线程都是内部线程，则 $\\mathbb{1}_{I_k}=1$ 且 $\\mathbb{1}_{B_k}=0$，因此 $C_{warp, k}=C_i$。\n-   如果所有线程都是边界线程，则 $\\mathbb{1}_{I_k}=0$ 且 $\\mathbb{1}_{B_k}=1$，因此 $C_{warp, k}=C_b$。\n-   如果 warp 是混合的（同时包含内部和边界线程），它就会发生分化。两条路径都会被执行。$\\mathbb{1}_{I_k}=1$ 且 $\\mathbb{1}_{B_k}=1$，因此 $C_{warp, k}=C_i + C_b$。\n\n整个基于分支的内核的总周期成本 $C_{total, branch}$ 是所有 warp 成本的总和：\n$$\nC_{total, branch} = \\sum_{k=0}^{N_{warps}-1} C_{warp, k} = \\sum_{k=0}^{N_{warps}-1} \\left( \\mathbb{1}_{I_k} C_i + \\mathbb{1}_{B_k} C_b \\right)\n$$\n\n### 第 2 部分：周期性边界条件的无分支公式\n\n问题为周期性边界条件提出了一种特定的无分支实现。该方法用模运算代替条件逻辑来计算邻居索引。对于一个位于 $(x,y)$ 的单元格，其四个最近邻 $(x_-, y)$、$(x_+, y)$、$(x, y_-)$ 和 $(x, y_+)$ 的坐标计算如下：\n$$\nx_- = (x - 1 + N_x) \\bmod N_x, \\quad x_+ = (x + 1) \\bmod N_x\n$$\n$$\ny_- = (y - 1 + N_y) \\bmod N_y, \\quad y_+ = (y + 1) \\bmod N_y\n$$\n\n为了证明该公式的正确性，我们分析它在内部单元格和边界单元格上的行为。\n\n**内部单元格：** 对于一个内部单元格，我们有 $1 \\leq x \\leq N_x-2$ 和 $1 \\leq y \\leq N_y-2$。\n-   对于 $x_-$: 由于 $0 \\leq x-1  N_x$，$(x-1+N_x) \\bmod N_x = x-1$。\n-   对于 $x_+$: 由于 $2 \\leq x+1  N_x$，$(x+1) \\bmod N_x = x+1$。\n同样的逻辑适用于 $y_-$ 和 $y_+$。对于内部单元格，模运算没有效果，公式正确地得出了标准的邻居索引。\n\n**边界单元格：** 我们检查在边界处的行为。让我们考虑 $x$ 维度。\n-   **左边界 ($x=0$):**\n    -   $x_- = (0 - 1 + N_x) \\bmod N_x = (N_x - 1) \\bmod N_x = N_x - 1$。这正确地环绕到最右列，符合周期性条件的要求。\n    -   $x_+ = (0 + 1) \\bmod N_x = 1 \\bmod N_x = 1$。这正确地指向内部的相邻单元格。\n-   **右边界 ($x=N_x-1$):**\n    -   $x_- = (N_x - 1 - 1 + N_x) \\bmod N_x = (2N_x - 2) \\bmod N_x = N_x - 2$。这正确地指向内部的相邻单元格。\n    -   $x_+ = (N_x - 1 + 1) \\bmod N_x = N_x \\bmod N_x = 0$。这正确地环绕到最左列。\n\n对于 $y$ 边界（$y=0$ 和 $y=N_y-1$），逻辑是相同的。因此，使用模运算为所有单元格提供了一种统一的、无分支的机制来访问邻居，通过“环绕”网格边缘正确地实现了周期性边界条件。\n\n这个无分支内核的成本对每个 warp 都是统一的，给定为 $C_f$。总成本 $C_{total, free}$ 就是 warp 的数量乘以这个统一成本：\n$$\nC_{total, free} = N_{warps} \\times C_f = \\left\\lceil \\frac{N_x N_y}{W} \\right\\rceil C_f\n$$\n\n### 第 3 部分：加速比计算\n\n加速比 $S$ 定义为基准（基于分支的）内核与优化后（无分支的）内核的总执行时间之比。\n$$\nS = \\frac{C_{total, branch}}{C_{total, free}} = \\frac{\\sum_{k=0}^{N_{warps}-1} \\left( \\mathbb{1}_{I_k} C_i + \\mathbb{1}_{B_k} C_b \\right)}{\\left\\lceil \\frac{N_x N_y}{W} \\right\\rceil C_f}\n$$\n当 $S>1$ 时，表示无分支公式更快；当 $S1$ 时，表示它更慢。这个比率量化了在通用内核中处理 warp 分化的开销与在非分化内核中使用一组专用但可能更昂贵的算术运算的成本之间的权衡。计算需要遍历每个 warp，确定它是纯内部、纯边界还是混合型，计算其特定成本，将这些成本相加，最后除以无分支方法的总成本。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n# Although numpy is available, it is not required for this implementation.\n\ndef solve():\n    \"\"\"\n    Computes the speedup of a branch-free kernel over a branch-based kernel\n    for a 2D finite-difference update on a GPU, considering warp divergence.\n    \"\"\"\n\n    test_cases = [\n        # Case A: general case\n        (128, 128, 32, 80, 140, 90),\n        # Case B: boundary-heavy small grid\n        (33, 33, 32, 80, 140, 95),\n        # Case C: one-dimensional reduction\n        (32, 1, 32, 50, 60, 52),\n        # Case D: large grid mostly interior\n        (1000, 1000, 32, 80, 160, 100),\n    ]\n\n    results = []\n    for params in test_cases:\n        Nx, Ny, W, Ci, Cb, Cf = params\n\n        N_threads = Nx * Ny\n        \n        # Calculate the total number of warps, accounting for partial warps\n        N_warps = (N_threads + W - 1) // W\n\n        # --- Calculate cost for the branch-based kernel ---\n        total_cost_branch = 0\n        for k in range(N_warps):\n            start_thread_idx = k * W\n            end_thread_idx = min((k + 1) * W, N_threads)\n\n            is_interior_path_taken = False\n            is_boundary_path_taken = False\n\n            for t in range(start_thread_idx, end_thread_idx):\n                x = t % Nx\n                y = t // Nx\n\n                # Check if the thread corresponds to a boundary cell\n                is_boundary = (x == 0) or (x == Nx - 1) or (y == 0) or (y == Ny - 1)\n\n                if is_boundary:\n                    is_boundary_path_taken = True\n                else:\n                    is_interior_path_taken = True\n                \n                # If both paths are taken, the warp is divergent.\n                # We can stop checking threads in this warp as its cost is determined.\n                if is_interior_path_taken and is_boundary_path_taken:\n                    break\n            \n            # Calculate the cost for this specific warp based on divergence\n            warp_cost = 0\n            if is_interior_path_taken:\n                warp_cost += Ci\n            if is_boundary_path_taken:\n                warp_cost += Cb\n            \n            total_cost_branch += warp_cost\n            \n        # --- Calculate cost for the branch-free kernel ---\n        # The cost is uniform for all warps\n        total_cost_free = N_warps * Cf\n\n        # --- Calculate Speedup S ---\n        # Ensure no division by zero, although Cf and N_warps are > 0 in tests\n        speedup = 0.0\n        if total_cost_free > 0:\n            speedup = total_cost_branch / total_cost_free\n            \n        # Format the result to six decimal places\n        results.append(f\"{speedup:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}