{
    "hands_on_practices": [
        {
            "introduction": "评估并行代码的性能是优化的第一步。强标度（Strong scaling）分析是其中一个基本基准，它衡量在固定问题规模下，增加处理器数量能带来多大的加速效果。这个练习  提供了一个回旋动理学求解器的真实场景。它引导您不仅仅是计算一个简单的加速比，而是通过将运行时间分解为计算、通信和负载不平衡三个部分来计算并行效率，从而更深入地理解限制等离子体模拟性能的现实瓶颈。",
            "id": "4025625",
            "problem": "一个用于计算聚变科学与工程的动理学湍流求解器，在固定问题规模下，从 $P=128$ 个处理单元强扩展到 $P=256$ 个处理单元。对于每种处理器数量，每个时间步的挂钟时间被分解为三个测量分量：纯计算时间、消息传递接口（MPI）通信时间以及由负载不平衡引起的等待时间（测量为全局同步时相对于平均进程进度的超额时间）。测量结果如下：\n- 在 $P=128$ 时：计算 $0.54$，通信 $0.18$，不平衡 $0.03$（所有单位均为秒/时间步）。\n- 在 $P=256$ 时：计算 $0.29$，通信 $0.22$，不平衡 $0.05$（所有单位均为秒/时间步）。\n\n假设问题规模是固定的，并且在每个 $P$ 值下，每个时间步的总挂钟时间是所报告的三个分量之和。定义从 $P=128$ 扩展到 $P=256$ 时实现的加速比为：在相同工作负载下，$P=128$ 时的每个时间步总时间与 $P=256$ 时的每个时间步总时间之比。定义此次处理器数量加倍的并行效率为：在固定问题规模下，实现的加速比与理想加速比之比。\n\n通过所提供的测量数据，明确考虑通信开销和负载不平衡，计算从 $P=128$ 加倍到 $P=256$ 时的并行效率。将您的答案表示为无量纲小数，并四舍五入到四位有效数字。",
            "solution": "首先根据既定标准对问题进行验证。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n- 初始处理单元数：$P_1 = 128$。\n- 最终处理单元数：$P_2 = 256$。\n- 问题规模固定（强扩展）。\n- $P_1 = 128$ 时的时间测量值：\n    - 每个时间步的计算时间：$T_{\\text{comp},1} = 0.54$ s。\n    - 每个时间步的通信时间：$T_{\\text{comm},1} = 0.18$ s。\n    - 每个时间步的负载不平衡时间：$T_{\\text{imb},1} = 0.03$ s。\n- $P_2 = 256$ 时的时间测量值：\n    - 每个时间步的计算时间：$T_{\\text{comp},2} = 0.29$ s。\n    - 每个时间步的通信时间：$T_{\\text{comm},2} = 0.22$ s。\n    - 每个时间步的负载不平衡时间：$T_{\\text{imb},2} = 0.05$ s。\n- 总时间的定义：每个时间步的总挂钟时间 $T_{\\text{total}}$ 是三个分量之和：$T_{\\text{total}} = T_{\\text{comp}} + T_{\\text{comm}} + T_{\\text{imb}}$。\n- 实现加速比的定义：实现加速比 $S_{\\text{achieved}}$ 是 $P_1$ 时的总时间与 $P_2$ 时的总时间之比，即 $S_{\\text{achieved}} = T_{\\text{total},1} / T_{\\text{total},2}$。\n- 并行效率的定义：此次加倍的并行效率 $\\eta$ 是实现加速比与理想加速比之比。\n- 最终答案应为无量纲小数，并四舍五入到四位有效数字。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，因为它描述了高性能计算和计算科学中常见的标准强扩展性能分析。将挂钟时间分解为计算、通信和负载不平衡是一种有效且广泛使用的方法。数值对于扩展性实验是切合实际的：计算时间减少（如预期地大约减半），而通信和不平衡开销则随着处理器数量的增加而增加。该问题是适定的，为获得唯一解提供了所有必要的定义和数据。语言客观而精确。该问题是自洽的、一致的，并且没有违反任何基本原则。\n\n**步骤 3：结论与行动**\n该问题被判定为有效。将推导解答。\n\n**解答推导**\n\n目标是计算一个动理学湍流求解器从 $P_1 = 128$ 个处理单元强扩展到 $P_2 = 256$ 个处理单元时的并行效率 $\\eta$。\n\n首先，我们计算每种处理器数量下每个时间步的总挂钟时间。根据问题定义，总时间是计算、通信和不平衡分量的总和。\n\n对于包含 $P_1 = 128$ 个处理器的初始配置，总时间 $T_{\\text{total},1}$ 为：\n$$T_{\\text{total},1} = T_{\\text{comp},1} + T_{\\text{comm},1} + T_{\\text{imb},1}$$\n代入给定值：\n$$T_{\\text{total},1} = 0.54 \\, \\text{s} + 0.18 \\, \\text{s} + 0.03 \\, \\text{s} = 0.75 \\, \\text{s}$$\n\n对于包含 $P_2 = 256$ 个处理器的最终配置，总时间 $T_{\\text{total},2}$ 为：\n$$T_{\\text{total},2} = T_{\\text{comp},2} + T_{\\text{comm},2} + T_{\\text{imb},2}$$\n代入给定值：\n$$T_{\\text{total},2} = 0.29 \\, \\text{s} + 0.22 \\, \\text{s} + 0.05 \\, \\text{s} = 0.56 \\, \\text{s}$$\n\n接下来，我们计算实现的加速比 $S_{\\text{achieved}}$。其定义为在固定问题规模下，较少处理器数量下的总时间与较多处理器数量下的总时间之比。\n$$S_{\\text{achieved}} = \\frac{T_{\\text{total},1}}{T_{\\text{total},2}}$$\n使用我们计算出的总时间：\n$$S_{\\text{achieved}} = \\frac{0.75}{0.56}$$\n\n对于强扩展问题，理想加速比 $S_{\\text{ideal}}$ 是最终处理器数量与初始处理器数量之比。\n$$S_{\\text{ideal}} = \\frac{P_2}{P_1}$$\n代入给定的处理器数量：\n$$S_{\\text{ideal}} = \\frac{256}{128} = 2$$\n\n最后，并行效率 $\\eta$ 定义为实现的加速比与理想加速比之比。\n$$\\eta = \\frac{S_{\\text{achieved}}}{S_{\\text{ideal}}}$$\n代入 $S_{\\text{achieved}}$ 和 $S_{\\text{ideal}}$ 的表达式：\n$$\\eta = \\frac{\\left(\\frac{T_{\\text{total},1}}{T_{\\text{total},2}}\\right)}{S_{\\text{ideal}}} = \\frac{\\left(\\frac{0.75}{0.56}\\right)}{2}$$\n现在，我们计算数值：\n$$\\eta = \\frac{1.3392857...}{2} = 0.669642857...$$\n题目要求答案四舍五入到四位有效数字。\n$$\\eta \\approx 0.6696$$\n该值表示并行化的效率，其中效率为 $1$ 表示理想扩展。结果 $\\eta \\approx 0.6696$ 表明，该代码实现了大约 $67\\%$ 的理想加速比，剩余的性能损失归因于处理器数量加倍时通信和负载不平衡开销的增加。",
            "answer": "$$\\boxed{0.6696}$$"
        },
        {
            "introduction": "在性能分析中发现的通信开销，其根源通常在于子域之间必须交换数据。这个过程被称为“幽灵”或“晕”单元交换（ghost/halo cell exchange），是区域分解方法的核心。本练习  将让您扮演代码开发者的角色，为这一交换过程设计核心逻辑，并分析其内存占用。该交换机制源于电荷守恒等物理定律，是保证并行计算结果正确的关键。",
            "id": "4025608",
            "problem": "你的任务是为三维、结构化、有限体积等离子体模拟设计一种消息传递接口（MPI）邻域集合通信方案，用于仅与几何邻居交换电流密度。目标是推导出一个原理性算法并计算其内存占用。你将在软件中实现并模拟该方案，假设采用笛卡尔域分解，且邻居仅为面相邻的邻居。你不得依赖实际的MPI库；相反，需要构建一个遵循三维拓扑几何约束的、正确的邻域交换模拟。所有答案必须以字节（bytes）表示，并且你的程序必须按照指定的输出格式生成结果。\n\n基础科学背景：在连续介质电动力学中，电荷守恒要求电流密度矢量在单元面之间进行一致的交换，以使子域之间的离散通量保持平衡。从电荷连续性方程\n$$\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot \\mathbf{J} = 0,$$\n开始，其中 $\\rho$ 是电荷密度，$\\mathbf{J}$ 是电流密度，有限体积离散化引入了面通量，这些通量将跨越子域边界的相邻单元耦合起来。在笛卡尔分解下，电流密度 $\\mathbf{J} = (J_x, J_y, J_z)$ 跨界面的交换仅限于几何面邻居，这与通量的局域性一致。在采用域分解的并行计算中，使用厚度为 $\\delta$ 层的幽灵单元（ghost cells），以便每个子域可以使用从相邻子域交换来的数据计算面心通量。\n\n你必须构建一个仅使用沿 $x$、$y$ 和 $z$ 轴的几何面邻居的邻域集合通信方案。周期性边界条件可能会环绕邻居索引；非周期性边界则会截断邻居交换。\n\n核心定义与假设：\n- 全局网格维度为 $N_x \\times N_y \\times N_z$ 个单元。\n- 进程网格为 $P_x \\times P_y \\times P_z$ 个进程，使用大小相等的块进行笛卡尔分解。假设 $N_x$、$N_y$、$N_z$ 分别能被 $P_x$、$P_y$、$P_z$ 整除。\n- 每个进程拥有一个大小为 $n_x \\times n_y \\times n_z$ 的局部块，其中 $n_x = N_x / P_x$，$n_y = N_y / P_y$，$n_z = N_z / P_z$。\n- 幽灵层厚度为 $\\delta$（以单元层数计）。如果 $\\delta$ 超过了沿任一轴 $d \\in \\{x,y,z\\}$ 的局部维度 $n_d$，则沿该轴的交换厚度使用 $\\min(\\delta, n_d)$。\n- 仅交换面邻居（$\\pm x$, $\\pm y$, $\\pm z$）。不执行边或角的交换。\n- 电流密度矢量有 $c$ 个分量（使用 $c = 3$），每个分量以 $b$ 字节的浮点数形式存储（双精度使用 $b = 8$）。\n- 对于任何局部面积为 $A$、厚度为 $t$ 的面，消息大小（以字节计）为 $c \\cdot b \\cdot A \\cdot t$。\n- 对每个进程而言，总发送缓冲区大小是发送给所有存在邻居的面消息之和；总接收缓冲区大小是从其邻居传入的面消息之和（对于均匀块，这与传出大小相同，但必须一致地计算）。每个进程的内存占用是发送和接收缓冲区大小之和（以字节计）。\n- 周期性按轴指定。如果沿轴 $d$ 是周期性的，则邻居会环绕；否则，沿 $d$ 轴没有邻居的边界进程不会沿该面交换数据。\n\n需要实现的算法任务：\n- 构建具有秩坐标 $(i_x,i_y,i_z)$ 和考虑周期性的面相邻邻居映射的笛卡尔进程拓扑。\n- 计算局部块大小 $n_x$、$n_y$、$n_z$ 和各方向的交换厚度 $t_x = \\min(\\delta, n_x)$、$t_y = \\min(\\delta, n_y)$、$t_z = \\min(\\delta, n_z)$。\n- 计算各面的面积 $A_{x} = n_y n_z$、$A_{y} = n_x n_z$ 和 $A_{z} = n_x n_y$。\n- 通过对所有存在的面邻居 $d \\in \\{x,y,z\\}$ 和方向 $\\pm$ 求和 $c \\cdot b \\cdot A_d \\cdot t_d$ 来推导每个进程的发送和接收内存占用。\n- 通过以下方式实现邻域交换模拟：\n  - 为每个进程分配形状为 $(n_x, n_y, n_z, c)$ 的内部数组和形状为 $(n_x + 2\\delta, n_y + 2\\delta, n_z + 2\\delta, c)$ 的带幽灵单元的扩展数组。\n  - 使用一个关于 $(i,j,k)$、分量索引和进程秩的确定性函数填充内部数组，以进行验证。\n  - 将邻居内部数组的面边界切片复制到厚度为 $t_x$、$t_y$ 和 $t_z$ 的相应幽灵层中。\n  - 验证对于所有存在的邻居，每个进程的幽灵面都等于邻居的内部边界切片。在非周期性方向上忽略不存在的面。\n\n验证与输出：\n- 对每个测试用例，计算：\n  $1)$ 所有进程中，单个进程的最大内存占用（以字节计），\n  $2)$ 所有进程的内存占用总和（以字节计），\n  $3)$ 一个布尔值，指示邻域交换是否为所有存在的几何邻居面生成了正确的幽灵层。\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，按测试用例排序并平铺为：\n  $[$max\\_bytes\\_case\\_1, total\\_bytes\\_case\\_1, validity\\_case\\_1, max\\_bytes\\_case\\_2, total\\_bytes\\_case\\_2, validity\\_case\\_2, \\dots$]$。\n\n测试套件：\n- 案例 $1$ (正常路径)：$N_x = 64$，$N_y = 48$，$N_z = 32$；$P_x = 4$，$P_y = 3$，$P_z = 2$；$\\delta = 2$；周期性 $(\\text{True}, \\text{True}, \\text{False})$；$c = 3$；$b = 8$ 字节。\n- 案例 $2$ (幽灵层为零的边界条件)：$N_x = 64$，$N_y = 48$，$N_z = 32$；$P_x = 4$，$P_y = 3$，$P_z = 2$；$\\delta = 0$；周期性 $(\\text{False}, \\text{False}, \\text{False})$；$c = 3$；$b = 8$ 字节。\n- 案例 $3$ (幽灵层相对于块大小过大的边缘情况)：$N_x = 16$，$N_y = 16$，$N_z = 8$；$P_x = 2$，$P_y = 2$，$P_z = 2$；$\\delta = 3$；周期性 $(\\text{True}, \\text{True}, \\text{True})$；$c = 3$；$b = 8$ 字节。\n- 案例 $4$ (各向异性块和混合周期性)：$N_x = 90$，$N_y = 30$，$N_z = 24$；$P_x = 3$，$P_y = 3$，$P_z = 2$；$\\delta = 1$；周期性 $(\\text{False}, \\text{True}, \\text{True})$；$c = 3$；$b = 8$ 字节。\n\n所有内存结果必须以字节为单位。布尔有效性必须是 $\\text{True}$ 或 $\\text{False}$。",
            "solution": "该问题要求为在并行计算机上运行的三维等离子体模拟设计并验证一个邻域通信方案。该解决方案基于域分解、幽灵单元交换和笛卡尔进程拓扑的原则，这些是可扩展科学计算的基础。\n\n**1. 理论框架：域分解与进程拓扑**\n\n大小为 $N_x \\times N_y \\times N_z$ 个单元的全局计算域被分解成一个 $P_x \\times P_y \\times P_z$ 个进程的笛卡尔网格。每个进程被分配一个唯一的整数秩 $r \\in [0, P_{total}-1]$，其中 $P_{total} = P_x P_y P_z$。这个秩可以映射到进程网格内的一个唯一的三维坐标 $(i_x, i_y, i_z)$，其中 $i_x \\in [0, P_x-1]$，$i_y \\in [0, P_y-1]$，$i_z \\in [0, P_z-1]$。从秩 $r$ 到坐标的映射由以下公式给出：\n$$i_x = \\lfloor r / (P_y P_z) \\rfloor$$\n$$i_y = \\lfloor (r \\pmod{P_y P_z}) / P_z \\rfloor$$\n$$i_z = r \\pmod{P_z}$$\n从坐标到秩的反向映射为 $r = i_x (P_y P_z) + i_y P_z + i_z$。每个进程管理一个大小为 $n_x \\times n_y \\times n_z$ 的局部子域（块），其中对于每个轴 $d \\in \\{x, y, z\\}$，$n_d = N_d / P_d$。\n\n通信仅限于面相邻的邻居。对于位于 $(i_x, i_y, i_z)$ 的进程，其在某个方向（例如 $+x$ 方向）的邻居位于坐标 $(i_x+1, i_y, i_z)$。该邻居是否存在取决于边界条件。对于 $x$ 轴上的非周期性边界，只有当 $0 \\le i_x+1  P_x$ 时邻居才存在。对于周期性边界，坐标会环绕：$i'_x = (i_x+1) \\pmod{P_x}$。此逻辑适用于所有 6 个方向（$\\pm x, \\pm y, \\pm z$）。\n\n**2. 幽灵单元与数据交换**\n\n为了计算子域边界上的物理量（如通量），一个进程需要其邻居的数据。这通过用几层“幽灵单元”（也称为晕环单元）包围局部数据块来实现。这些幽灵单元用来自相邻进程相应内部边界区域的数据填充。幽灵层的厚度由 $\\delta$ 给出。\n\n沿轴 $d$ 交换的数据量由有效交换厚度 $t_d$ 决定，定义为 $t_d = \\min(\\delta, n_d)$。这考虑了幽灵层厚度 $\\delta$ 大于局部域大小 $n_d$ 的情况，此时将交换沿该轴的整个局部域。\n\n被交换的数据是电流密度矢量 $\\mathbf{J}$，它有 $c=3$ 个分量，每个分量存储为 $b=8$ 字节的浮点数。为一个特定面更新幽灵区域所需的消息大小是分量数（$c$）、每个分量的大小（$b$）、面的面积（$A_d$）和交换厚度（$t_d$）的乘积。例如，垂直于 $x$ 轴的面的消息大小为：\n$$M_x = c \\cdot b \\cdot A_x \\cdot t_x = c \\cdot b \\cdot (n_y n_z) \\cdot t_x$$\n类似地，对于 $M_y = c \\cdot b \\cdot (n_x n_z) \\cdot t_y$ 和 $M_z = c \\cdot b \\cdot (n_x n_y) \\cdot t_z$ 也存在相似的表达式。\n\n**3. 内存占用计算**\n\n每个进程用于通信的内存占用定义为其发送和接收缓冲区大小的总和。一个进程的总发送缓冲区大小是其所有存在邻居的消息大小之和。总接收缓冲区大小的定义类似。对于位于坐标 $(i_x, i_y, i_z)$ 的进程 $r$，我们可以通过对 6 个潜在邻居方向的贡献求和来计算其内存占用：\n$$M_{proc}(r) = S_{send}(r) + S_{recv}(r)$$\n其中 $S_{send}(r)$ 和 $S_{recv}(r)$ 的计算如下：初始化 $S_{send}(r) = 0$ 和 $S_{recv}(r) = 0$。对于每个方向 $d \\in \\{x,y,z\\}$ 和符号 $\\sigma \\in \\{-,+\\}$：如果在 $\\sigma d$ 方向上存在邻居：\n$$S_{send}(r) \\leftarrow S_{send}(r) + M_d$$\n$$S_{recv}(r) \\leftarrow S_{recv}(r) + M_d$$\n由于块大小是均匀的，发送给邻居的消息大小等于从它接收的消息大小。单个进程的最大内存占用为 $\\max_{r} M_{proc}(r)$，总内存占用为 $\\sum_{r} M_{proc}(r)$。\n\n**4. 算法模拟与验证**\n\n邻域交换的模拟不使用实际的 MPI 库。该过程包括以下步骤：\n1.  **初始化**：为每个进程分配一个形状为 $(n_x, n_y, n_z, c)$ 的内部数据数组。该数组使用一个关于单元索引 $(i, j, k)$、矢量分量索引和进程秩的确定性函数填充唯一值。这确保了任何错位的数据都能被检测到。同时分配一个更大的、带幽灵单元的扩展数组，形状为 $(n_x + 2\\delta, n_y + 2\\delta, n_z + 2\\delta, c)$，并将内部数据复制到其中心。\n2.  **交换模拟**：算法遍历每个进程及其所有存在的邻居。对于每对邻居，它从邻居的内部数组中识别出边界数据切片，并将其复制到当前进程的带幽灵单元的扩展数组中相应的幽灵单元区域。例如，要填充进程 $r$ 的 $+x$ 面上的幽灵区域，数据将从其 $+x$ 邻居的 $-x$ 边界切片复制而来。要复制的切片厚度为 $t_x$，高度为 $n_y$，深度为 $n_z$。对所有进程的所有 6 个方向重复此操作。\n3.  **验证**：交换后，验证数据传输的正确性。对于每个进程和每个存在的邻居，将给定幽灵区域中的数据与邻居内部数组中相应边界区域的数据进行比较。如果所有进程的所有幽灵区域中的所有数据都与其预期的源切片匹配，则交换被视为有效（`True`）。如果发现任何不匹配，则交换无效（`False`）。对于 $\\delta=0$ 的情况，幽灵层和交换厚度均为零，导致一个平凡但有效的交换，内存占用为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {'N': (64, 48, 32), 'P': (4, 3, 2), 'delta': 2, 'periodicity': (True, True, False), 'c': 3, 'b': 8},\n        # Case 2 (boundary condition with zero ghost)\n        {'N': (64, 48, 32), 'P': (4, 3, 2), 'delta': 0, 'periodicity': (False, False, False), 'c': 3, 'b': 8},\n        # Case 3 (edge case with large ghost relative to block size)\n        {'N': (16, 16, 8), 'P': (2, 2, 2), 'delta': 3, 'periodicity': (True, True, True), 'c': 3, 'b': 8},\n        # Case 4 (anisotropic blocks and mixed periodicity)\n        {'N': (90, 30, 24), 'P': (3, 3, 2), 'delta': 1, 'periodicity': (False, True, True), 'c': 3, 'b': 8},\n    ]\n\n    results = []\n    for params in test_cases:\n        max_fp, total_fp, is_valid = simulate_case(**params)\n        results.extend([max_fp, total_fp, is_valid])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef simulate_case(N, P, delta, periodicity, c, b):\n    \"\"\"\n    Simulates the neighborhood collective scheme for a single test case.\n    \"\"\"\n    Nx, Ny, Nz = N\n    Px, Py, Pz = P\n    P_total = Px * Py * Pz\n\n    # Local block sizes\n    nx, ny, nz = Nx // Px, Ny // Py, Nz // Pz\n\n    # Per-direction exchange thicknesses\n    tx = min(delta, nx)\n    ty = min(delta, ny)\n    tz = min(delta, nz)\n\n    # Per-face areas\n    Ax = ny * nz\n    Ay = nx * nz\n    Az = nx * ny\n\n    # Message sizes\n    msg_size_x = c * b * Ax * tx\n    msg_size_y = c * b * Ay * ty\n    msg_size_z = c * b * Az * tz\n    msg_sizes = [msg_size_x, msg_size_y, msg_size_z]\n\n    # Process topology and neighbor finding\n    procs = []\n    for r in range(P_total):\n        # Rank to coordinates\n        ix = r // (Py * Pz)\n        iy = (r % (Py * Pz)) // Pz\n        iz = r % Pz\n        \n        proc_info = {'rank': r, 'coord': (ix, iy, iz), 'neighbors': {}}\n        \n        coords = [ix, iy, iz]\n        proc_dims = [Px, Py, Pz]\n\n        # Find neighbors for each of the 6 directions\n        for axis in range(3): # 0:x, 1:y, 2:z\n            for sign in [-1, 1]: # -1: negative, +1: positive\n                neighbor_coord = list(coords)\n                neighbor_coord[axis] += sign\n                \n                is_periodic = periodicity[axis]\n                dim_size = proc_dims[axis]\n                \n                neighbor_rank = None\n                if is_periodic:\n                    neighbor_coord[axis] %= dim_size\n                    # Coord to rank\n                    nix, niy, niz = neighbor_coord\n                    neighbor_rank = nix * Py * Pz + niy * Pz + niz\n                elif 0 = neighbor_coord[axis]  dim_size:\n                    # Coord to rank\n                    nix, niy, niz = neighbor_coord\n                    neighbor_rank = nix * Py * Pz + niy * Pz + niz\n\n                proc_info['neighbors'][(axis, sign)] = neighbor_rank\n        procs.append(proc_info)\n\n    # Memory footprint calculation\n    footprints = []\n    for proc in procs:\n        send_buffer = 0\n        recv_buffer = 0\n        for (axis, sign), neighbor_rank in proc['neighbors'].items():\n            if neighbor_rank is not None:\n                msg_size = msg_sizes[axis]\n                send_buffer += msg_size\n                recv_buffer += msg_size\n        footprints.append(send_buffer + recv_buffer)\n\n    max_footprint = max(footprints) if footprints else 0\n    total_footprint = sum(footprints) if footprints else 0\n\n    # If delta is 0, exchange is trivial and valid, memory is 0.\n    if delta == 0:\n        return 0, 0, True\n\n    # --- Simulation of data exchange ---\n    \n    # 1. Initialize data for all processes\n    sim_data = {}\n    for r in range(P_total):\n        # Deterministic filling function\n        def fill_func(i, j, k, comp, rank):\n            return rank * 10000000 + i * 100000 + j * 1000 + k * 100 + comp\n\n        interior = np.fromfunction(np.vectorize(fill_func), (nx, ny, nz, c), dtype=np.float64, rank=r)\n        \n        ghosted_shape = (nx + 2 * delta, ny + 2 * delta, nz + 2 * delta, c)\n        ghosted = np.full(ghosted_shape, -1.0, dtype=np.float64) # Fill with a sentinel value\n        \n        # Copy interior data to the center of the ghosted array\n        ghosted[delta:delta+nx, delta:delta+ny, delta:delta+nz, :] = interior\n        \n        sim_data[r] = {'interior': interior, 'ghosted': ghosted}\n\n    # 2. Perform the exchange\n    for r in range(P_total):\n        proc = procs[r]\n        for (axis, sign), neighbor_rank in proc['neighbors'].items():\n            if neighbor_rank is not None:\n                neighbor_interior = sim_data[neighbor_rank]['interior']\n                local_ghosted = sim_data[r]['ghosted']\n                \n                # Get source slice from neighbor's interior\n                if axis == 0: # x-axis\n                    src = neighbor_interior[nx-tx:, :, :, :] if sign == -1 else neighbor_interior[:tx, :, :, :]\n                elif axis == 1: # y-axis\n                    src = neighbor_interior[:, ny-ty:, :, :] if sign == -1 else neighbor_interior[:, :ty, :, :]\n                else: # z-axis\n                    src = neighbor_interior[:, :, nz-tz:, :] if sign == -1 else neighbor_interior[:, :, :tz, :]\n                \n                # Get destination view in local ghosted array\n                if axis == 0: # x-axis\n                    dest_view = local_ghosted[delta-tx:delta, delta:delta+ny, delta:delta+nz, :] if sign == -1 \\\n                        else local_ghosted[delta+nx:delta+nx+tx, delta:delta+ny, delta:delta+nz, :]\n                elif axis == 1: # y-axis\n                    dest_view = local_ghosted[delta:delta+nx, delta-ty:delta, delta:delta+nz, :] if sign == -1 \\\n                        else local_ghosted[delta:delta+nx, delta+ny:delta+ny+ty, delta:delta+nz, :]\n                else: # z-axis\n                    dest_view = local_ghosted[delta:delta+nx, delta:delta+ny, delta-tz:delta, :] if sign == -1 \\\n                        else local_ghosted[delta:delta+nx, delta:delta+ny, delta+nz:delta+nz+tz, :]\n\n                dest_view[:] = src\n\n    # 3. Validation\n    is_valid = True\n    for r in range(P_total):\n        proc = procs[r]\n        for (axis, sign), neighbor_rank in proc['neighbors'].items():\n            if neighbor_rank is not None:\n                neighbor_interior = sim_data[neighbor_rank]['interior']\n                local_ghosted = sim_data[r]['ghosted']\n\n                # Re-calculate source slice from neighbor's interior\n                if axis == 0: # x-axis\n                    src_slice = neighbor_interior[nx-tx:, :, :, :] if sign == -1 else neighbor_interior[:tx, :, :, :]\n                elif axis == 1: # y-axis\n                    src_slice = neighbor_interior[:, ny-ty:, :, :] if sign == -1 else neighbor_interior[:, :ty, :, :]\n                else: # z-axis\n                    src_slice = neighbor_interior[:, :, nz-tz:, :] if sign == -1 else neighbor_interior[:, :, :tz, :]\n\n                # Re-calculate destination ghost slice from local ghosted array\n                if axis == 0: # x-axis\n                    ghost_slice = local_ghosted[delta-tx:delta, delta:delta+ny, delta:delta+nz, :] if sign == -1 \\\n                        else local_ghosted[delta+nx:delta+nx+tx, delta:delta+ny, delta:delta+nz, :]\n                elif axis == 1: # y-axis\n                    ghost_slice = local_ghosted[delta:delta+nx, delta-ty:delta, delta:delta+nz, :] if sign == -1 \\\n                        else local_ghosted[delta:delta+nx, delta+ny:delta+ny+ty, delta:delta+nz, :]\n                else: # z-axis\n                    ghost_slice = local_ghosted[delta:delta+nx, delta:delta+ny, delta-tz:delta, :] if sign == -1 \\\n                        else local_ghosted[delta:delta+nx, delta:delta+ny, delta+nz:delta+nz+tz, :]\n                \n                if not np.array_equal(src_slice, ghost_slice):\n                    is_valid = False\n                    break\n        if not is_valid:\n            break\n            \n    return int(max_footprint), int(total_footprint), is_valid\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "实现高性能不仅需要优秀的算法，还需要对底层硬件架构有深刻的理解。现代的图形处理器（GPU）采用单指令多线程（SIMT）执行模型，其中一组线程（称为“线程束”或“warp”）内的条件分支可能导致性能下降，这种现象被称为线程束分化（warp divergence）。本练习  探讨了在应用边界条件时这一现象的影响。您将分析线程束分化带来的成本，并设计一个无分支的替代方案，从而体会到编写硬件感知代码的重要性。",
            "id": "4025556",
            "problem": "考虑一个在大小为 $N_x \\times N_y$ 的均匀笛卡尔网格上，表示等离子体中静电势的标量场 $\\phi(x,y)$ 的二维显式有限差分更新。假设离散时间步长的更新由一个使用最近邻值的五点模板定义，这与等离子体模拟中椭圆或抛物算子的标准离散化方法一致。图形处理单元（GPU）上的线程遵循单指令多线程（SIMT）模型，其中一组 $W$ 个线程以锁步方式执行；这样的一组线程被称为一个线程束（warp）。当一个线程束中的线程评估一个分支并采取不同路径时，该线程束会通过掩码串行执行每个路径，这种现象称为线程束分化（warp divergence）。\n\n基本假设：\n- 单指令多线程（SIMT）线程束执行：如果一个线程束中的线程在条件分支上发生分化，该线程束将串行执行每个被采用的不同路径，并掩码非活动线程，直到再收敛。\n- 一个线程束有 $W$ 个通道，索引为 $\\ell \\in \\{0,1,\\dots,W-1\\}$。\n- 对于带单个 if-else 分支的线程束，其总执行时间等于该线程束中至少一个通道所采用的每条路径的周期成本之和。\n- 网格以行主序与线程一一映射：线程索引 $t \\in \\{0,1,\\dots,N_x N_y-1\\}$ 对应坐标 $(x,y)$，其中 $x = t \\bmod N_x$ 且 $y = \\left\\lfloor t / N_x \\right\\rfloor$。\n- 边界条件检测使用谓词“是边界”，对于任何满足 $x=0$、$x=N_x-1$、$y=0$ 或 $y=N_y-1$ 的单元格，该谓词为真。\n\n您需要分析由边界条件分支引起的线程束分化效应，然后为周期性边界条件提出一种无分支的公式化方法。将每个路径的周期成本视为与数据无关的常数：内部路径成本为 $C_i$ 个周期，边界路径成本为 $C_b$ 个周期。对于无分支的公式化方法，假设每个线程束的成本是统一的 $C_f$ 个周期，与线程是否位于边界无关。周期性边界条件的无分支公式化方法必须使用不含条件分支的索引算术来构建。\n\n任务：\n1. 根据 SIMT 线程束执行模型，推导基于分支的核函数的总周期数公式，形式为对所有线程束的求和。使用指示函数表达每个线程束的贡献，该指示函数需反映线程束中是否至少有一个通道是内部通道以及是否至少有一个通道是边界通道。\n2. 提出一种仅使用算术索引变换来访问邻居的周期性边界条件的无分支公式化方法。从逻辑上证明为何该方法对内部和边界单元格都能产生正确的邻居索引。\n3. 实现一个程序，给定 $(N_x, N_y, W, C_i, C_b, C_f)$，计算基于分支的核函数和无分支核函数的总周期数，并返回定义为以下比率的加速比 $S$：\n$$\nS = \\frac{\\text{基于分支的核函数的总周期数}}{\\text{无分支核函数的总周期数}}。\n$$\n计算必须遵循所提供的 SIMT 模型和映射，并且必须在 $N_x N_y$ 不是 $W$ 的倍数时考虑部分线程束（partial warps）的情况。\n\n无分支周期性边界公式化要求：\n- 对于每个单元格 $(x,y)$，使用算术环绕定义邻居索引：\n$$\nx_- = (x - 1 + N_x) \\bmod N_x,\\quad x_+ = (x + 1) \\bmod N_x,\n$$\n$$\ny_- = (y - 1 + N_y) \\bmod N_y,\\quad y_+ = (y + 1) \\bmod N_y.\n$$\n- 访问邻居 $(x_-,y)$、$(x_+,y)$、$(x,y_-)$、$(x,y_+)$ 时不使用条件分支。\n\n测试套件：\n为以下参数集评估加速比 $S$。所有量均为无量纲的周期计数和索引。\n\n- 案例 A (通用情况): $N_x=128$, $N_y=128$, $W=32$, $C_i=80$, $C_b=140$, $C_f=90$.\n- 案例 B (边界密集的小网格): $N_x=33$, $N_y=33$, $W=32$, $C_i=80$, $C_b=140$, $C_f=95$.\n- 案例 C (一维简化): $N_x=32$, $N_y=1$, $W=32$, $C_i=50$, $C_b=60$, $C_f=52$.\n- 案例 D (内部为主的大网格): $N_x=1000$, $N_y=1000$, $W=32$, $C_i=80$, $C_b=160$, $C_f=100$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含案例 A、B、C、D 的加速比，按顺序排列，以逗号分隔并用方括号括起。每个加速比必须格式化为浮点数，并四舍五入到六位小数，例如：“[1.234567,0.987654,1.000000,1.111111]”。不应打印任何额外文本。",
            "solution": "该问题要求在图形处理单元（GPU）架构的背景下，分析在二维网格上执行有限差分更新的两种不同实现的计算成本。问题的核心在于为边界条件检查引起的条件分支（`if-else` 语句）的性能影响建模，这种现象在单指令多线程（SIMT）执行模型中被称为线程束分化。\n\n根据要求，分析分为三个部分：为通用的基于分支的核函数推导成本公式，为周期性边界的专用无分支核函数提供合理解释，以及实现一个程序来计算后者相对于前者的性能加速比。\n\n### 第 1 部分：基于分支的核函数的成本公式\n\n核函数的总执行时间是所有线程束执行时间的总和。我们必须首先确定单个线程束的成本，然后对所有线程束进行求和。\n\n假设计算网格的维度为 $N_x \\times N_y$。网格单元的总数，即线程总数，为 $N_{threads} = N_x N_y$。线程被分组为大小为 $W$ 的线程束。覆盖所有线程所需的线程束总数 $N_{warps}$ 由 $N_{threads}$ 除以 $W$ 的向上取整给出：\n$$\nN_{warps} = \\left\\lceil \\frac{N_x N_y}{W} \\right\\rceil\n$$\n在整数算术中，这计算为 $(N_x N_y + W - 1) / W$。\n\n我们考虑一个由索引 $k$ 标识的任意线程束，其中 $k \\in \\{0, 1, \\dots, N_{warps}-1\\}$。该线程束包含一组全局索引为 $t$ 的线程，范围在 $kW \\le t  \\min((k+1)W, N_x N_y)$ 内。每个线程 $t$ 通过指定的行主序映射到坐标为 $(x,y)$ 的网格单元：\n$$\nx = t \\bmod N_x \\quad \\text{和} \\quad y = \\lfloor t / N_x \\rfloor\n$$\n如果线程对应的单元格 $(x,y)$ 满足条件 $x=0$、$x=N_x-1$、$y=0$ 或 $y=N_y-1$，则认为该线程位于边界上。我们定义一个布尔函数 $B(t)$，如果线程 $t$ 在边界上，则为真，否则为假。\n\n根据所提供的 SIMT 执行模型，具有 `if-else` 分支的线程束的成本是该线程束内至少一个线程所采用的所有路径的成本之和。这两条路径是成本为 $C_i$ 的“内部”路径和成本为 $C_b$ 的“边界”路径。\n\n对于给定的线程束 $k$，我们可以定义两个指示函数：\n1.  $\\mathbb{1}_{I_k}$：如果线程束 $k$ 中至少有一个线程是内部线程（即，在线程束 $k$ 中 $\\exists t$ 使得 $\\neg B(t)$），则为 $1$，否则为 $0$。\n2.  $\\mathbb{1}_{B_k}$：如果线程束 $k$ 中至少有一个线程是边界线程（即，在线程束 $k$ 中 $\\exists t$ 使得 $B(t)$），则为 $1$，否则为 $0$。\n\n因此，线程束 $k$ 的成本，记作 $C_{warp, k}$，为：\n$$\nC_{warp, k} = \\mathbb{1}_{I_k} C_i + \\mathbb{1}_{B_k} C_b\n$$\n此表达式正确地捕捉了一个线程束的三种可能性：\n-   如果所有线程都是内部线程，则 $\\mathbb{1}_{I_k}=1$ 且 $\\mathbb{1}_{B_k}=0$，因此 $C_{warp, k}=C_i$。\n-   如果所有线程都是边界线程，则 $\\mathbb{1}_{I_k}=0$ 且 $\\mathbb{1}_{B_k}=1$，因此 $C_{warp, k}=C_b$。\n-   如果线程束是混合的（既包含内部线程也包含边界线程），它就会发生分化。两条路径都会被执行。此时 $\\mathbb{1}_{I_k}=1$ 且 $\\mathbb{1}_{B_k}=1$，因此 $C_{warp, k}=C_i + C_b$。\n\n整个基于分支的核函数的总周期成本 $C_{total, branch}$ 是所有线程束的成本之和：\n$$\nC_{total, branch} = \\sum_{k=0}^{N_{warps}-1} C_{warp, k} = \\sum_{k=0}^{N_{warps}-1} \\left( \\mathbb{1}_{I_k} C_i + \\mathbb{1}_{B_k} C_b \\right)\n$$\n\n### 第 2 部分：周期性边界的无分支公式化方法\n\n该问题为周期性边界条件提出了一种特定的无分支实现。这种方法用模运算代替条件逻辑来计算邻居索引。对于一个位于 $(x,y)$ 的单元格，其四个最近邻 $(x_-, y)$、$(x_+, y)$、$(x, y_-)$ 和 $(x, y_+)$ 的坐标计算如下：\n$$\nx_- = (x - 1 + N_x) \\bmod N_x, \\quad x_+ = (x + 1) \\bmod N_x\n$$\n$$\ny_- = (y - 1 + N_y) \\bmod N_y, \\quad y_+ = (y + 1) \\bmod N_y\n$$\n\n为证明该公式的正确性，我们分析它在内部单元格和边界单元格上的行为。\n\n**内部单元格：** 对于一个内部单元格，我们有 $1 \\leq x \\leq N_x-2$ 和 $1 \\leq y \\leq N_y-2$。\n-   对于 $x_-$：由于 $0 \\leq x-1  N_x$，所以 $(x-1+N_x) \\bmod N_x = x-1$。\n-   对于 $x_+$：由于 $2 \\leq x+1  N_x$，所以 $(x+1) \\bmod N_x = x+1$。\n同样的逻辑适用于 $y_-$ 和 $y_+$。对于内部单元格，模运算没有影响，公式正确地得出了标准的邻居索引。\n\n**边界单元格：** 我们来考察在边界上的行为。让我们考虑 $x$ 维度。\n-   **左边界 ($x=0$)：**\n    -   $x_- = (0 - 1 + N_x) \\bmod N_x = (N_x - 1) \\bmod N_x = N_x - 1$。这正确地环绕到最右边一列，符合周期性条件的要求。\n    -   $x_+ = (0 + 1) \\bmod N_x = 1 \\bmod N_x = 1$。这正确地指向内部的相邻单元格。\n-   **右边界 ($x=N_x-1$)：**\n    -   $x_- = (N_x - 1 - 1 + N_x) \\bmod N_x = (2N_x - 2) \\bmod N_x = N_x - 2$。这正确地指向内部的相邻单元格。\n    -   $x_+ = (N_x - 1 + 1) \\bmod N_x = N_x \\bmod N_x = 0$。这正确地环绕到最左边一列。\n\n$y$ 边界（$y=0$ 和 $y=N_y-1$）的逻辑是相同的。因此，使用模运算提供了一种统一的、无分支的机制来访问所有单元格的邻居，通过在网格边缘“环绕”来正确实现周期性边界条件。\n\n这个无分支核函数的成本对于每个线程束都是统一的，给定为 $C_f$。总成本 $C_{total, free}$ 就是线程束总数乘以这个统一成本：\n$$\nC_{total, free} = N_{warps} \\times C_f = \\left\\lceil \\frac{N_x N_y}{W} \\right\\rceil C_f\n$$\n\n### 第 3 部分：加速比计算\n\n加速比 $S$ 定义为基准（基于分支的）核函数的总执行时间与优化后（无分支的）核函数的总执行时间之比。\n$$\nS = \\frac{C_{total, branch}}{C_{total, free}} = \\frac{\\sum_{k=0}^{N_{warps}-1} \\left( \\mathbb{1}_{I_k} C_i + \\mathbb{1}_{B_k} C_b \\right)}{\\left\\lceil \\frac{N_x N_y}{W} \\right\\rceil C_f}\n$$\n$S>1$ 的值表示无分支公式化方法更快，而 $S1$ 则表示它更慢。该比率量化了在通用核函数中处理线程束分化的开销与在无分化核函数中使用一套专门但可能成本更高的算术运算的成本之间的权衡。计算需要遍历每个线程束，确定它是纯内部、纯边界还是混合型，计算其特定成本，将这些成本相加，最后除以无分支方法的总成本。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n# Although numpy is available, it is not required for this implementation.\n\ndef solve():\n    \"\"\"\n    Computes the speedup of a branch-free kernel over a branch-based kernel\n    for a 2D finite-difference update on a GPU, considering warp divergence.\n    \"\"\"\n\n    test_cases = [\n        # Case A: general case\n        (128, 128, 32, 80, 140, 90),\n        # Case B: boundary-heavy small grid\n        (33, 33, 32, 80, 140, 95),\n        # Case C: one-dimensional reduction\n        (32, 1, 32, 50, 60, 52),\n        # Case D: large grid mostly interior\n        (1000, 1000, 32, 80, 160, 100),\n    ]\n\n    results = []\n    for params in test_cases:\n        Nx, Ny, W, Ci, Cb, Cf = params\n\n        N_threads = Nx * Ny\n        \n        # Calculate the total number of warps, accounting for partial warps\n        N_warps = (N_threads + W - 1) // W\n\n        # --- Calculate cost for the branch-based kernel ---\n        total_cost_branch = 0\n        for k in range(N_warps):\n            start_thread_idx = k * W\n            end_thread_idx = min((k + 1) * W, N_threads)\n\n            is_interior_path_taken = False\n            is_boundary_path_taken = False\n\n            for t in range(start_thread_idx, end_thread_idx):\n                x = t % Nx\n                y = t // Nx\n\n                # Check if the thread corresponds to a boundary cell\n                is_boundary = (x == 0) or (x == Nx - 1) or (y == 0) or (y == Ny - 1)\n\n                if is_boundary:\n                    is_boundary_path_taken = True\n                else:\n                    is_interior_path_taken = True\n                \n                # If both paths are taken, the warp is divergent.\n                # We can stop checking threads in this warp as its cost is determined.\n                if is_interior_path_taken and is_boundary_path_taken:\n                    break\n            \n            # Calculate the cost for this specific warp based on divergence\n            warp_cost = 0\n            if is_interior_path_taken:\n                warp_cost += Ci\n            if is_boundary_path_taken:\n                warp_cost += Cb\n            \n            total_cost_branch += warp_cost\n            \n        # --- Calculate cost for the branch-free kernel ---\n        # The cost is uniform for all warps\n        total_cost_free = N_warps * Cf\n\n        # --- Calculate Speedup S ---\n        # Ensure no division by zero, although Cf and N_warps are > 0 in tests\n        speedup = 0.0\n        if total_cost_free > 0:\n            speedup = total_cost_branch / total_cost_free\n            \n        # Format the result to six decimal places\n        results.append(f\"{speedup:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}