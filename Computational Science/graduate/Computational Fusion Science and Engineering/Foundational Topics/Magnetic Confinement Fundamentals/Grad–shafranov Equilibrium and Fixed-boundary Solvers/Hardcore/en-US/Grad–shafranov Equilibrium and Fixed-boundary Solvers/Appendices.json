{
    "hands_on_practices": [
        {
            "introduction": "The first step in numerically solving any partial differential equation is to accurately approximate its differential operators. This practice focuses on deriving a robust, second-order finite difference stencil for the $\\Delta^*$ operator, the core component of the Grad–Shafranov equation . Mastering this discretization, particularly its conservative form in cylindrical coordinates, is fundamental to building a reliable equilibrium solver.",
            "id": "3986297",
            "problem": "Consider axisymmetric magnetostatic equilibrium used in computational fusion science and engineering for fixed-boundary solvers of the Grad–Shafranov equation. Begin from the fundamental laws of magnetostatics, namely Ampère’s law $\\nabla \\times \\mathbf{B} = \\mu_{0}\\mathbf{J}$ and Gauss’s law for magnetism $\\nabla \\cdot \\mathbf{B} = 0$, together with the magnetohydrodynamic force balance $\\mathbf{J} \\times \\mathbf{B} = \\nabla p$, and the axisymmetric representation of the magnetic field in cylindrical coordinates $(R,\\phi,Z)$ with no toroidal variation. From these fundamental bases and standard definitions of cylindrical-coordinate differential operators, one arrives at an elliptic partial differential equation (partial differential equation (PDE)) for the poloidal flux function $\\psi(R,Z)$ in which a linear, self-adjoint operator acts on $\\psi(R,Z)$.\n\nYour task is to derive a second-order accurate, finite difference stencil on a uniform $(R,Z)$ grid for this linear operator applied to $\\psi(R,Z)$. In particular, the operator contains a weighted radial derivative of the form $R \\,\\partial/\\partial R$ acting on a quantity that includes a factor $1/R$. You must express clearly how to approximate this radial part in a conservative, second-order accurate manner using face-centered weights on a uniform grid. Then complete the two-dimensional stencil by adding the axial part in $Z$ with second-order accuracy.\n\nAfter deriving the stencil symbolically, implement it in a program and verify second-order accuracy by comparing against analytic solutions. Use a uniform tensor-product grid with $N_{R}$ points in $R$ and $N_{Z}$ points in $Z$ including boundaries. Let the grid nodes be $R_{i}$ for $i = 0,\\dots,N_{R}-1$ and $Z_{j}$ for $j = 0,\\dots,N_{Z}-1$, with spacings $\\Delta R = (R_{\\max}-R_{\\min})/(N_{R}-1)$ and $\\Delta Z = (Z_{\\max}-Z_{\\min})/(N_{Z}-1)$. Impose fixed (Dirichlet) boundary values by evaluating the exact analytic $\\psi(R,Z)$ on the boundary. Apply your interior stencil only on indices $i=1,\\dots,N_{R}-2$ and $j=1,\\dots,N_{Z}-2$. All angles in trigonometric functions must be interpreted in radians. All quantities are dimensionless, so report errors as dimensionless numbers.\n\nUse the following test suite of parameter values. For each case, compute the maximum-norm error $E_{\\infty}$, defined as the maximum absolute difference between your discrete operator applied to $\\psi$ and the exact analytic operator evaluated at interior nodes.\n\n- Test case $1$ (null-space check for the weighted radial term):\n  - Domain: $R \\in [0.8,\\,1.2]$, $Z \\in [-0.5,\\,0.5]$.\n  - Resolution: $N_{R} = 33$, $N_{Z} = 33$.\n  - Analytic field: $\\psi(R,Z) = \\tfrac{1}{2} R^{2}$.\n- Test case $2$ (polynomial on a moderate grid):\n  - Domain: $R \\in [1.0,\\,2.0]$, $Z \\in [-1.0,\\,1.0]$.\n  - Resolution: $N_{R} = 33$, $N_{Z} = 33$.\n  - Analytic field: $\\psi(R,Z) = R^{4} + Z^{4} + R^{2} Z$.\n- Test case $3$ (polynomial on a refined grid to assess convergence):\n  - Domain: $R \\in [1.0,\\,2.0]$, $Z \\in [-1.0,\\,1.0]$.\n  - Resolution: $N_{R} = 65$, $N_{Z} = 65$.\n  - Analytic field: $\\psi(R,Z) = R^{4} + Z^{4} + R^{2} Z$.\n- Test case $4$ (trigonometric–hyperbolic field on a domain with smaller $R$):\n  - Domain: $R \\in [0.2,\\,0.9]$, $Z \\in [-0.3,\\,0.3]$.\n  - Resolution: $N_{R} = 49$, $N_{Z} = 49$.\n  - Analytic field: $\\psi(R,Z) = \\sin(R)\\,\\cosh(Z)$.\n- Test case $5$ (refinement of test case $4$):\n  - Domain: $R \\in [0.2,\\,0.9]$, $Z \\in [-0.3,\\,0.3]$.\n  - Resolution: $N_{R} = 97$, $N_{Z} = 97$.\n  - Analytic field: $\\psi(R,Z) = \\sin(R)\\,\\cosh(Z)$.\n\nYour program must:\n- Construct the grid for each test case, evaluate the boundary data from the analytic $\\psi(R,Z)$, apply the derived second-order stencil at interior nodes, and compute $E_{\\infty}$ for each case.\n- Produce as final output a single line containing a Python-style list of the five $E_{\\infty}$ values in the order of the test cases, with no additional text. For example, the output must look like $[e_{1},e_{2},e_{3},e_{4},e_{5}]$ where each $e_{k}$ is a floating-point number.",
            "solution": "The problem requires the derivation of a second-order accurate finite difference stencil for the linear operator found in the Grad–Shafranov equation and its subsequent implementation to verify accuracy.\n\n### Derivation of the Grad–Shafranov Operator\n\nWe begin with the fundamental equations of magnetostatics in a plasma, assuming a static equilibrium ($\\partial/\\partial t = 0$):\n1.  Ampère's Law: $\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J}$\n2.  Gauss's Law for Magnetism: $\\nabla \\cdot \\mathbf{B} = 0$\n3.  Force Balance: $\\mathbf{J} \\times \\mathbf{B} = \\nabla p$\n\nWe work in cylindrical coordinates $(R, \\phi, Z)$ and assume axisymmetry, which means all quantities are independent of the toroidal angle $\\phi$, i.e., $\\partial/\\partial\\phi = 0$.\n\nFrom $\\nabla \\cdot \\mathbf{B} = 0$, the magnetic field $\\mathbf{B}$ can be expressed as the curl of a vector potential $\\mathbf{A}$. For an axisymmetric system, it is convenient to define the poloidal magnetic flux function, $\\psi(R,Z)$, such that the poloidal components of the magnetic field are given by:\n$$ \\mathbf{B}_p = B_R \\hat{R} + B_Z \\hat{Z} = \\frac{1}{R} \\nabla\\psi \\times \\hat{\\phi} $$\nExpanding this definition, we obtain the components:\n$$ B_R(R,Z) = -\\frac{1}{R}\\frac{\\partial\\psi}{\\partial Z} \\quad \\text{and} \\quad B_Z(R,Z) = \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} $$\nThis form automatically satisfies the poloidal part of Gauss's law, $\\nabla \\cdot \\mathbf{B}_p = \\frac{1}{R}\\frac{\\partial}{\\partial R}(R B_R) + \\frac{\\partial B_Z}{\\partial Z} = 0$. The full magnetic field includes a toroidal component, $\\mathbf{B} = \\mathbf{B}_p + B_\\phi(R,Z)\\hat{\\phi}$.\n\nNext, we use Ampère's law to relate the magnetic field to the current density $\\mathbf{J}$. The toroidal component of the current density, $J_\\phi$, is related to the poloidal magnetic field:\n$$ \\mu_0 J_\\phi = (\\nabla \\times \\mathbf{B}_p) \\cdot \\hat{\\phi} = \\frac{\\partial B_R}{\\partial Z} - \\frac{\\partial B_Z}{\\partial R} $$\nSubstituting the expressions for $B_R$ and $B_Z$ in terms of $\\psi$:\n$$ \\mu_0 J_\\phi = \\frac{\\partial}{\\partial Z}\\left(-\\frac{1}{R}\\frac{\\partial\\psi}{\\partial Z}\\right) - \\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}\\right) $$\n$$ \\mu_0 J_\\phi = -\\frac{1}{R}\\frac{\\partial^2\\psi}{\\partial Z^2} - \\left(-\\frac{1}{R^2}\\frac{\\partial\\psi}{\\partial R} + \\frac{1}{R}\\frac{\\partial^2\\psi}{\\partial R^2}\\right) = -\\frac{1}{R}\\left(\\frac{\\partial^2\\psi}{\\partial R^2} - \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} + \\frac{\\partial^2\\psi}{\\partial Z^2}\\right) $$\nThis expression defines the Grad–Shafranov operator, denoted $\\Delta^*$:\n$$ \\Delta^*\\psi \\equiv \\frac{\\partial^2\\psi}{\\partial R^2} - \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} + \\frac{\\partial^2\\psi}{\\partial Z^2} $$\nThe force balance equation relates this to the pressure $p$ and the toroidal field function $F(\\psi) = R B_\\phi$, yielding the full Grad–Shafranov equation $\\Delta^*\\psi = - \\mu_0 R^2 \\frac{dp}{d\\psi} - F \\frac{dF}{d\\psi}$. The present task is to discretize the linear differential operator $\\Delta^*$ acting on $\\psi$. For a conservative finite difference formulation, it is best to write the operator in its self-adjoint form, as suggested by the problem statement:\n$$ \\Delta^*\\psi = R\\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}\\right) + \\frac{\\partial^2\\psi}{\\partial Z^2} $$\nThis is the operator we will discretize.\n\n### Finite Difference Stencil Derivation\n\nWe consider a uniform tensor-product grid with nodes $(R_i, Z_j)$, where $R_i = R_{\\min} + i\\Delta R$ for $i=0, \\dots, N_R-1$ and $Z_j = Z_{\\min} + j\\Delta Z$ for $j=0, \\dots, N_Z-1$. The grid spacings are $\\Delta R = (R_{\\max}-R_{\\min})/(N_R-1)$ and $\\Delta Z = (Z_{\\max}-Z_{\\min})/(N_Z-1)$. Let $\\psi_{i,j} = \\psi(R_i, Z_j)$.\n\nThe discretization is performed at an interior grid node $(i,j)$ where $1 \\le i \\le N_R-2$ and $1 \\le j \\le N_Z-2$.\n\n**Axial Part:** The second partial derivative with respect to $Z$ is approximated using a standard second-order central difference formula:\n$$ \\left. \\frac{\\partial^2\\psi}{\\partial Z^2} \\right|_{i,j} \\approx \\frac{\\psi_{i,j+1} - 2\\psi_{i,j} + \\psi_{i,j-1}}{(\\Delta Z)^2} $$\n\n**Radial Part:** The radial part of the operator is $L_R\\psi = R\\frac{\\partial}{\\partial R}\\left(\\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}\\right)$. To achieve a conservative and second-order accurate discretization, we use a \"face-centered\" or finite-volume-like approach. Let $F_R(R) = \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R}$ be the radial flux. The operator at $R_i$ is $R_i \\frac{\\partial F_R}{\\partial R}|_{R_i}$. We approximate the derivative of the flux using central differences on the cell faces, which are located at half-integer grid indices $R_{i\\pm 1/2} = R_i \\pm \\Delta R/2$:\n$$ \\left. \\frac{\\partial F_R}{\\partial R} \\right|_{R_i} \\approx \\frac{F_R(R_{i+1/2}) - F_R(R_{i-1/2})}{\\Delta R} $$\nThe flux $F_R$ at these face centers is itself approximated using second-order central differences for the derivative of $\\psi$:\n$$ F_R(R_{i+1/2}) = \\left. \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} \\right|_{R_{i+1/2}} \\approx \\frac{1}{R_{i+1/2}} \\frac{\\psi_{i+1,j} - \\psi_{i,j}}{\\Delta R} $$\n$$ F_R(R_{i-1/2}) = \\left. \\frac{1}{R}\\frac{\\partial\\psi}{\\partial R} \\right|_{R_{i-1/2}} \\approx \\frac{1}{R_{i-1/2}} \\frac{\\psi_{i,j} - \\psi_{i-1,j}}{\\Delta R} $$\nSubstituting these into the expression for the operator, the discrete radial operator $(L_R\\psi)_{i,j}$ becomes:\n$$ (L_R\\psi)_{i,j} \\approx R_i \\frac{1}{\\Delta R} \\left( \\frac{1}{R_{i+1/2}} \\frac{\\psi_{i+1,j} - \\psi_{i,j}}{\\Delta R} - \\frac{1}{R_{i-1/2}} \\frac{\\psi_{i,j} - \\psi_{i-1,j}}{\\Delta R} \\right) $$\n$$ (L_R\\psi)_{i,j} \\approx \\frac{R_i}{(\\Delta R)^2} \\left[ \\frac{1}{R_{i-1/2}}\\psi_{i-1,j} - \\left(\\frac{1}{R_{i+1/2}} + \\frac{1}{R_{i-1/2}}\\right)\\psi_{i,j} + \\frac{1}{R_{i+1/2}}\\psi_{i+1,j} \\right] $$\nwhere $R_{i\\pm 1/2} = R_i \\pm \\Delta R/2$.\n\n**Complete Stencil:** Combining the radial and axial parts, we get the complete 5-point stencil for $(\\Delta^*\\psi)_{i,j}$:\n$$ (\\Delta^*\\psi)_{i,j} \\approx \\frac{R_i}{(\\Delta R)^2} \\left[ \\frac{\\psi_{i-1,j}}{R_i-\\frac{\\Delta R}{2}} - \\left(\\frac{1}{R_i+\\frac{\\Delta R}{2}} + \\frac{1}{R_i-\\frac{\\Delta R}{2}}\\right)\\psi_{i,j} + \\frac{\\psi_{i+1,j}}{R_i+\\frac{\\Delta R}{2}} \\right] + \\frac{\\psi_{i,j-1} - 2\\psi_{i,j} + \\psi_{i,j+1}}{(\\Delta Z)^2} $$\nThis stencil is second-order accurate in both $\\Delta R$ and $\\Delta Z$.\n\n### Verification and Implementation\n\nTo verify the second-order accuracy, we apply this discrete operator to known analytic functions $\\psi(R,Z)$ and compare the result with the exact analytical evaluation of $\\Delta^*\\psi$. The maximum-norm error $E_{\\infty}$ over all interior grid points is computed:\n$$ E_{\\infty} = \\max_{1\\le i \\le N_R-2, 1\\le j \\le N_Z-2} \\left| (\\Delta^*\\psi)_{i,j}^{\\text{numerical}} - (\\Delta^*\\psi)(R_i,Z_j)^{\\text{analytic}} \\right| $$\nThe provided test cases allow for checking the null-space property of the radial operator and assessing the convergence rate, which should be quadratic ($E_{\\infty} \\propto (\\Delta R)^2, (\\Delta Z)^2$). For pairs of test cases where the grid resolution is doubled, the error is expected to decrease by a factor of approximately $4$.\nThe implementation will follow the derived stencil, applying it to the interior of the domain, with the full grid of $\\psi$ values (including boundaries) computed from the given analytic functions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_operator(psi, R, Z):\n    \"\"\"\n    Applies the discretized Grad-Shafranov operator Delta* to a function psi.\n\n    Args:\n        psi (np.ndarray): 2D array of psi values on the (R, Z) grid.\n        R (np.ndarray): 1D array of R-coordinates.\n        Z (np.ndarray): 1D array of Z-coordinates.\n\n    Returns:\n        np.ndarray: 2D array of the operator applied to psi.\n    \"\"\"\n    N_R, N_Z = psi.shape\n    if N_R < 3 or N_Z < 3:\n        return np.zeros_like(psi)\n\n    delta_R = R[1] - R[0]\n    delta_Z = Z[1] - Z[0]\n    \n    L_psi = np.zeros_like(psi)\n\n    # Vectorized computation for interior points\n    # psi slices for stencil\n    psi_mid = psi[1:-1, 1:-1]\n    psi_im1 = psi[:-2, 1:-1]\n    psi_ip1 = psi[2:, 1:-1]\n    psi_jm1 = psi[1:-1, :-2]\n    psi_jp1 = psi[1:-1, 2:]\n\n    # R-coordinates for interior points and faces\n    R_int = R[1:-1]\n    R_face_m = R_int - delta_R / 2.0\n    R_face_p = R_int + delta_R / 2.0\n\n    # Reshape R arrays for broadcasting\n    R_int_col = R_int[:, np.newaxis]\n    R_face_m_col = R_face_m[:, np.newaxis]\n    R_face_p_col = R_face_p[:, np.newaxis]\n\n    # Radial part of the operator\n    # Note: A check for R_face_m_col == 0 is needed if R_min=0 and N_R is even,\n    # but the test cases avoid this.\n    term_im1 = psi_im1 / R_face_m_col\n    term_ip1 = psi_ip1 / R_face_p_col\n    term_i = -(1.0/R_face_p_col + 1.0/R_face_m_col) * psi_mid\n    L_R_psi = (R_int_col / (delta_R**2)) * (term_im1 + term_i + term_ip1)\n\n    # Axial part of the operator\n    L_Z_psi = (psi_jp1 - 2.0 * psi_mid + psi_jm1) / (delta_Z**2)\n\n    # Combine parts and store in the interior of the result matrix\n    L_psi[1:-1, 1:-1] = L_R_psi + L_Z_psi\n\n    return L_psi\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute errors.\n    \"\"\"\n    test_cases = [\n        {\n            \"domain\": (0.8, 1.2, -0.5, 0.5),\n            \"resolution\": (33, 33),\n            \"psi_func\": lambda R, Z: 0.5 * R**2,\n            \"L_psi_func\": lambda R, Z: np.zeros_like(R),\n        },\n        {\n            \"domain\": (1.0, 2.0, -1.0, 1.0),\n            \"resolution\": (33, 33),\n            \"psi_func\": lambda R, Z: R**4 + Z**4 + R**2 * Z,\n            \"L_psi_func\": lambda R, Z: 8.0 * R**2 + 12.0 * Z**2,\n        },\n        {\n            \"domain\": (1.0, 2.0, -1.0, 1.0),\n            \"resolution\": (65, 65),\n            \"psi_func\": lambda R, Z: R**4 + Z**4 + R**2 * Z,\n            \"L_psi_func\": lambda R, Z: 8.0 * R**2 + 12.0 * Z**2,\n        },\n        {\n            \"domain\": (0.2, 0.9, -0.3, 0.3),\n            \"resolution\": (49, 49),\n            \"psi_func\": lambda R, Z: np.sin(R) * np.cosh(Z),\n            \"L_psi_func\": lambda R, Z: -np.cos(R) * np.cosh(Z) / R,\n        },\n        {\n            \"domain\": (0.2, 0.9, -0.3, 0.3),\n            \"resolution\": (97, 97),\n            \"psi_func\": lambda R, Z: np.sin(R) * np.cosh(Z),\n            \"L_psi_func\": lambda R, Z: -np.cos(R) * np.cosh(Z) / R,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        R_min, R_max, Z_min, Z_max = case[\"domain\"]\n        N_R, N_Z = case[\"resolution\"]\n        psi_func = case[\"psi_func\"]\n        L_psi_func = case[\"L_psi_func\"]\n\n        # 1. Construct the grid\n        R_coords = np.linspace(R_min, R_max, N_R)\n        Z_coords = np.linspace(Z_min, Z_max, N_Z)\n        R_grid, Z_grid = np.meshgrid(R_coords, Z_coords, indexing='ij')\n\n        # 2. Evaluate analytic psi on the grid\n        psi_analytic = psi_func(R_grid, Z_grid)\n\n        # 3. Apply the discrete operator\n        L_psi_numerical = apply_operator(psi_analytic, R_coords, Z_coords)\n\n        # 4. Evaluate the exact analytic operator\n        L_psi_analytic = L_psi_func(R_grid, Z_grid)\n\n        # 5. Compute the maximum-norm error on the interior\n        error_matrix = L_psi_numerical - L_psi_analytic\n        interior_error = error_matrix[1:-1, 1:-1]\n        E_inf = np.max(np.abs(interior_error))\n        \n        results.append(E_inf)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Before deploying a complex solver, we must verify its correctness. This exercise introduces the Method of Manufactured Solutions (MMS), a powerful code verification technique where we start with a chosen analytic solution and derive the corresponding source terms that make it exact . By implementing this test, you will confirm that your code correctly evaluates all terms in the Grad–Shafranov equation, ensuring the residual is zero to within machine precision.",
            "id": "3986305",
            "problem": "Consider an axisymmetric plasma equilibrium in Magnetohydrodynamics (MHD), with cylindrical coordinates $(R,\\phi,Z)$ and no dependence on the toroidal angle $\\phi$. Let the poloidal magnetic flux function be $\\psi(R,Z)$, the plasma pressure be $p(\\psi)$, and the toroidal field function be $F(\\psi) = R B_{\\phi}$, where $B_{\\phi}$ is the toroidal magnetic field. The Grad–Shafranov equation is the condition for static force balance and compatibility with Maxwell’s equations in such axisymmetric systems, and can be written in the operator form\n$$\n\\Delta^{\\star} \\psi = - \\mu_0 R^2 \\frac{dp}{d\\psi} - \\frac{1}{2} \\frac{d(F^2)}{d\\psi},\n$$\nwhere $\\mu_0$ is the magnetic permeability, and the Grad–Shafranov operator is\n$$\n\\Delta^{\\star} \\psi \\equiv R \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) + \\frac{\\partial^2 \\psi}{\\partial Z^2}.\n$$\nIn fixed-boundary solvers, the domain boundary is prescribed and one verifies an equilibrium by ensuring the residual of the Grad–Shafranov equation vanishes throughout the domain for consistent choices of $p(\\psi)$ and $F(\\psi)$.\n\nYour task is to use the method of manufactured solutions to construct an analytic equilibrium suitable for code verification in a dimensionless formulation with $\\mu_0 = 1$. Specifically:\n\n1. Choose the analytic flux\n$$\n\\psi(R,Z) = k R^4 + m Z^2 + \\psi_0,\n$$\nwith constants $k$, $m$, and $\\psi_0$.\n\n2. Starting from the definition of $\\Delta^{\\star}$, compute $\\Delta^{\\star}\\psi$ for this choice of $\\psi(R,Z)$, and then infer functions $p(\\psi)$ and $F^2(\\psi)$ (equivalently $F^2(\\psi)$) such that the Grad–Shafranov equation is satisfied pointwise in the domain. You must express $p(\\psi)$ and $F^2(\\psi)$ explicitly and ensure that $\\frac{dp}{d\\psi}$ and $\\frac{d(F^2)}{d\\psi}$ depend only on $\\psi$, as required by the physics.\n\n3. Implement a program that evaluates the maximum absolute residual\n$$\n\\mathcal{R}_{\\max} = \\max_{(R,Z) \\in \\Omega} \\left| \\Delta^{\\star}\\psi + R^2 \\frac{dp}{d\\psi} + \\frac{1}{2} \\frac{d(F^2)}{d\\psi} \\right|\n$$\nover a rectangular domain\n$$\n\\Omega = \\{ (R,Z) \\mid R \\in [R_{\\min}, R_{\\max}],\\, Z \\in [-Z_{\\max}, Z_{\\max}] \\},\n$$\non a uniform grid with $N_R$ points in $R$ and $N_Z$ points in $Z$.\n\n4. Use the following test suite of parameters, all dimensionless, to evaluate $\\mathcal{R}_{\\max}$ in each case:\n- Case $1$: $k = 0.25$, $m = 0.75$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$.\n- Case $2$: $k = 0$, $m = 0.5$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$.\n- Case $3$: $k = -0.125$, $m = 0.3$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$.\n- Case $4$: $k = 0.2$, $m = -0.4$, $\\psi_0 = 0$, $R_{\\min} = 1$, $R_{\\max} = 3$, $Z_{\\max} = 1$, $N_R = 101$, $N_Z = 101$, $p_0 = 0$, $f_0 = 10$.\n\nThe constants $p_0$ and $f_0$ are arbitrary offsets for $p(\\psi)$ and $F^2(\\psi)$ that do not affect the residual because only derivatives with respect to $\\psi$ appear. They are included for completeness.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4]$), where $r_i$ is the computed $\\mathcal{R}_{\\max}$ (a float) for Case $i$ in the test suite. Angles do not appear in this problem, and all quantities are dimensionless by construction; therefore, no units are required in the output.",
            "solution": "The objective is to find source functions $p(\\psi)$ and $F(\\psi)$ that satisfy the Grad-Shafranov equation for a prescribed analytic form of $\\psi(R,Z)$. This manufactured solution then provides a test case for which the exact solution is known, allowing for the verification of a numerical solver by checking if it recovers this solution with a residual close to machine precision.\n\nLet the dimensionless Grad-Shafranov equation be\n$$\n\\Delta^{\\star} \\psi = - R^2 \\frac{dp}{d\\psi} - \\frac{1}{2} \\frac{d(F^2)}{d\\psi}\n$$\nwith the operator\n$$\n\\Delta^{\\star} \\psi \\equiv R \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) + \\frac{\\partial^2 \\psi}{\\partial Z^2}\n$$\nThe prescribed analytic flux function is\n$$\n\\psi(R,Z) = k R^4 + m Z^2 + \\psi_0\n$$\n\nFirst, we compute the left-hand side, $\\Delta^{\\star}\\psi$, by evaluating the necessary partial derivatives.\nThe partial derivative with respect to $R$ is:\n$$\n\\frac{\\partial \\psi}{\\partial R} = 4k R^3\n$$\nDividing by $R$:\n$$\n\\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} = 4k R^2\n$$\nTaking the derivative with respect to $R$ again:\n$$\n\\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) = \\frac{\\partial}{\\partial R} (4k R^2) = 8k R\n$$\nMultiplying by $R$ gives the first term of the operator:\n$$\nR \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) = R (8k R) = 8k R^2\n$$\nNext, we compute the partial derivatives with respect to $Z$:\n$$\n\\frac{\\partial \\psi}{\\partial Z} = 2m Z\n$$\n$$\n\\frac{\\partial^2 \\psi}{\\partial Z^2} = 2m\n$$\nCombining these results, we obtain the expression for $\\Delta^{\\star}\\psi$:\n$$\n\\Delta^{\\star}\\psi = 8k R^2 + 2m\n$$\nNow, we substitute this result into the Grad-Shafranov equation:\n$$\n8k R^2 + 2m = - R^2 \\frac{dp}{d\\psi} - \\frac{1}{2} \\frac{d(F^2)}{d\\psi}\n$$\nTo satisfy the physical constraint that the source terms $\\frac{dp}{d\\psi}$ and $\\frac{d(F^2)}{d\\psi}$ must be functions of $\\psi$ only (and thus independent of explicit $(R,Z)$ coordinates), we can rearrange the equation by grouping terms with and without $R^2$:\n$$\n\\left( 8k + \\frac{dp}{d\\psi} \\right) R^2 + \\left( 2m + \\frac{1}{2} \\frac{d(F^2)}{d\\psi} \\right) = 0\n$$\nFor this equation to hold for all values of $R$ and $Z$ within the domain, the coefficients of the powers of $R$ (in this case, $R^2$ and $R^0$) must vanish independently. This yields a system of two equations:\n$$\n8k + \\frac{dp}{d\\psi} = 0 \\implies \\frac{dp}{d\\psi} = -8k\n$$\n$$\n2m + \\frac{1}{2} \\frac{d(F^2)}{d\\psi} = 0 \\implies \\frac{d(F^2)}{d\\psi} = -4m\n$$\nSince $k$ and $m$ are constants, the derivatives $\\frac{dp}{d\\psi}$ and $\\frac{d(F^2)}{d\\psi}$ are also constants. A constant is trivially a function of $\\psi$, so these choices are valid.\nWe can integrate these expressions to find the full forms of $p(\\psi)$ and $F^2(\\psi)$:\n$$\np(\\psi) = \\int (-8k) \\, d\\psi = -8k\\psi + C_p\n$$\n$$\nF^2(\\psi) = \\int (-4m) \\, d\\psi = -4m\\psi + C_f\n$$\nThe integration constants $C_p$ and $C_f$ correspond to the arbitrary offsets $p_0$ and $f_0$ mentioned in the problem, which do not affect the residual calculation.\n\nWith these derived source-term derivatives, the residual of the Grad-Shafranov equation is, by construction, identically zero for all $(R,Z)$:\n$$\n\\mathcal{R}(R,Z) = \\Delta^{\\star}\\psi + R^2 \\frac{dp}{d\\psi} + \\frac{1}{2} \\frac{d(F^2)}{d\\psi}\n$$\n$$\n\\mathcal{R}(R,Z) = (8k R^2 + 2m) + R^2(-8k) + \\frac{1}{2}(-4m)\n$$\n$$\n\\mathcal{R}(R,Z) = 8k R^2 + 2m - 8k R^2 - 2m = 0\n$$\nThe task is to implement a program that calculates this residual on a discrete grid. Due to floating-point arithmetic, the numerically computed residual may not be exactly zero. The program will evaluate $\\mathcal{R}_{\\max} = \\max |\\mathcal{R}(R,Z)|$ over the grid for each test case. This value should be on the order of machine precision, confirming the correctness of the derivation and its implementation.\nThe implementation will proceed as follows:\n1.  For each test case, define the parameters $k, m, R_{\\min}, R_{\\max}, Z_{\\max}, N_R, N_Z$.\n2.  Create a 2D grid of $(R,Z)$ points using `numpy.linspace` and `numpy.meshgrid`.\n3.  On this grid, compute the terms of the residual:\n    -   The manufactured Grad-Shafranov operator term: $(\\Delta^{\\star}\\psi)_{\\text{grid}} = 8k R_{\\text{grid}}^2 + 2m$.\n    -   The manufactured pressure term: $(R^2 \\frac{dp}{d\\psi})_{\\text{grid}} = R_{\\text{grid}}^2 (-8k)$.\n    -   The manufactured magnetic field term: $(\\frac{1}{2} \\frac{d(F^2)}{d\\psi})_{\\text{grid}} = \\frac{1}{2} (-4m) = -2m$.\n4.  Sum these terms to get the residual at each grid point.\n5.  Find the maximum absolute value of the residual array.\n6.  Collect the results for all test cases and print them in the specified format. The constants $\\psi_0$, $p_0$, and $f_0$ are not needed for this calculation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum absolute residual of a manufactured Grad-Shafranov\n    equilibrium for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (k, m, psi_0, R_min, R_max, Z_max, N_R, N_Z, p_0, f_0)\n    test_cases = [\n        (0.25, 0.75, 0, 1, 3, 1, 101, 101, 0, 10),\n        (0, 0.5, 0, 1, 3, 1, 101, 101, 0, 10),\n        (-0.125, 0.3, 0, 1, 3, 1, 101, 101, 0, 10),\n        (0.2, -0.4, 0, 1, 3, 1, 101, 101, 0, 10),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for the current case.\n        # psi_0, p_0, and f_0 are not used in the residual calculation.\n        k, m, _, r_min, r_max, z_max, n_r, n_z, _, _ = case\n\n        # Create the computational grid.\n        # R-coordinates for the grid points.\n        R = np.linspace(r_min, r_max, n_r)\n        # Z-coordinates for the grid points.\n        Z = np.linspace(-z_max, z_max, n_z)\n        # Create 2D meshgrid. R_grid varies along columns, Z_grid along rows.\n        # This is the standard 'xy' indexing.\n        R_grid, Z_grid = np.meshgrid(R, Z)\n\n        # Analytically derive the source term derivatives from the manufactured solution.\n        # The form psi = k*R^4 + m*Z^2 + psi_0 requires:\n        # dp/dpsi = -8*k\n        # d(F^2)/dpsi = -4*m\n        dp_dpsi = -8.0 * k\n        dF2_dpsi = -4.0 * m\n        \n        # Calculate each term of the Grad-Shafranov equation residual.\n        # Term 1: Delta_star_psi = 8*k*R^2 + 2*m\n        delta_star_psi_grid = 8.0 * k * R_grid**2 + 2.0 * m\n        \n        # Term 2: R^2 * dp/dpsi\n        pressure_term = R_grid**2 * dp_dpsi\n        \n        # Term 3: (1/2) * d(F^2)/dpsi\n        field_term = 0.5 * dF2_dpsi\n        \n        # The residual is the sum of these terms. By construction, it should be\n        # analytically zero. The numerical result will be close to machine epsilon.\n        # residual = (8*k*R^2 + 2*m) + R^2*(-8*k) + (1/2)*(-4*m)\n        #          = 8*k*R^2 + 2*m - 8*k*R^2 - 2*m = 0\n        residual_grid = delta_star_psi_grid + pressure_term + field_term\n        \n        # Calculate the maximum absolute residual over the entire domain.\n        max_abs_residual = np.max(np.abs(residual_grid))\n        \n        results.append(max_abs_residual)\n\n    # Final print statement in the exact required format.\n    # The output values are very small floats representing numerical noise,\n    # as the analytical residual is zero.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "The Grad–Shafranov equation is generally nonlinear, requiring iterative techniques for its solution. This advanced practice guides you through the implementation of a complete Newton-Raphson solver, the workhorse for such problems . You will learn to construct the Jacobian matrix and incorporate a line-search globalization strategy, which is critical for ensuring the solver converges robustly from initial guesses that may be far from the true solution.",
            "id": "3986269",
            "problem": "Consider axisymmetric magnetohydrodynamic equilibrium, where the static force balance is given by the equality of the pressure gradient and the Lorentz force, written as $\\nabla p = \\mathbf{j} \\times \\mathbf{B}$. Under axisymmetry in cylindrical coordinates $(R,\\phi,Z)$, the poloidal magnetic flux function $\\psi(R,Z)$ satisfies the Grad–Shafranov equation with fixed boundary conditions. The Grad–Shafranov operator is defined by\n$$\n\\Delta^\\star \\psi \\equiv R \\frac{\\partial}{\\partial R} \\left( \\frac{1}{R} \\frac{\\partial \\psi}{\\partial R} \\right) + \\frac{\\partial^2 \\psi}{\\partial Z^2}.\n$$\nThe equilibrium equation takes the form\n$$\n\\Delta^\\star \\psi = - \\mu_0 R^2 \\frac{dp}{d\\psi} - F(\\psi) \\frac{dF}{d\\psi},\n$$\nwhere $p(\\psi)$ is the pressure profile and $F(\\psi)$ is the toroidal field function. Assume dimensionless normalization such that the permeability of free space $\\mu_0$ is set to $\\mu_0 = 1$ and all quantities are dimensionless.\n\nYou must design and implement a globalization strategy for Newton's method using a line-search with sufficient decrease (Armijo backtracking) to solve the nonlinear fixed-boundary Grad–Shafranov equation on a rectangular computational domain with Dirichlet boundary conditions. The domain is defined as $R \\in [R_{\\min}, R_{\\max}]$ and $Z \\in [Z_{\\min}, Z_{\\max}]$, discretized on a uniform grid. A fixed boundary condition is prescribed by $\\psi_b(R,Z) = R^2$ on the entire boundary, which is a vacuum solution of $\\Delta^\\star \\psi = 0$.\n\nDiscretize $\\Delta^\\star$ on a uniform grid using second-order finite differences with a variable-coefficient self-adjoint form in the $R$-direction. Let $R_i$ and $Z_k$ denote grid nodes, and let $a(R) = 1/R$ with midpoint values $a_{i+1/2} = \\frac{1}{2}\\left( \\frac{1}{R_i} + \\frac{1}{R_{i+1}} \\right)$ and $a_{i-1/2} = \\frac{1}{2}\\left( \\frac{1}{R_i} + \\frac{1}{R_{i-1}} \\right)$. For any interior node $(i,k)$, write the discrete operator\n$$\n(\\Delta^\\star \\psi)_{i,k} \\approx R_i \\frac{1}{\\Delta R^2} \\left[ a_{i+1/2} \\left( \\psi_{i+1,k} - \\psi_{i,k} \\right) - a_{i-1/2} \\left( \\psi_{i,k} - \\psi_{i-1,k} \\right) \\right] + \\frac{\\psi_{i,k+1} - 2\\psi_{i,k} + \\psi_{i,k-1}}{\\Delta Z^2},\n$$\nand incorporate fixed boundary values $\\psi_b$ by moving neighbor boundary contributions to the right-hand side. Represent the unknowns as the vector of interior nodes.\n\nUse the following parametric forms for the source terms:\n$$\np(\\psi) = \\alpha \\psi + \\beta \\psi^2, \\quad \\frac{dp}{d\\psi} = \\alpha + 2\\beta \\psi, \\quad F(\\psi) = \\gamma + \\delta \\psi, \\quad \\frac{dF}{d\\psi} = \\delta.\n$$\nDefine the residual vector for the interior unknowns $\\mathbf{\\psi}$:\n$$\n\\mathbf{r}(\\mathbf{\\psi}) = \\mathbf{L}\\mathbf{\\psi} + \\mathbf{g} + \\mathbf{s}(\\mathbf{\\psi}),\n$$\nwhere $\\mathbf{L}$ is the discrete matrix representing $\\Delta^\\star$ acting on interior nodes, $\\mathbf{g}$ encodes boundary contributions from $\\psi_b$, and the nonlinear source term is\n$$\n\\mathbf{s}(\\mathbf{\\psi}) = R^2 \\left( \\alpha + 2\\beta \\mathbf{\\psi} \\right) + \\delta \\left( \\gamma + \\delta \\mathbf{\\psi} \\right).\n$$\nHere $R^2$ denotes the diagonal vector with entries $R_i^2$ at interior nodes.\n\nApply Newton's method by solving at each iteration the linear system\n$$\n\\mathbf{J}(\\mathbf{\\psi}) \\mathbf{s} = -\\mathbf{r}(\\mathbf{\\psi}),\n$$\nwhere the Jacobian is\n$$\n\\mathbf{J}(\\mathbf{\\psi}) = \\mathbf{L} + \\operatorname{diag}\\left( R^2 \\cdot \\frac{d^2 p}{d\\psi^2} + \\left( \\frac{dF}{d\\psi} \\right)^2 + F(\\psi) \\frac{d^2F}{d\\psi^2} \\right).\n$$\nFor the chosen profiles, $\\frac{d^2 p}{d\\psi^2} = 2\\beta$ and $\\frac{d^2F}{d\\psi^2} = 0$, implying\n$$\n\\mathbf{J} = \\mathbf{L} + \\operatorname{diag}\\left( 2\\beta R^2 + \\delta^2 \\right).\n$$\n\nGlobalize Newton's method using a line-search on the merit function\n$$\n\\Phi(\\mathbf{\\psi}) = \\frac{1}{2} \\lVert \\mathbf{r}(\\mathbf{\\psi}) \\rVert_2^2,\n$$\nwith Armijo backtracking: given the Newton step $\\mathbf{s}$, choose a step length $\\alpha \\in (0,1]$ by backtracking $\\alpha \\leftarrow \\tau \\alpha$ with $\\tau \\in (0,1)$ until\n$$\n\\Phi(\\mathbf{\\psi} + \\alpha \\mathbf{s}) \\le \\Phi(\\mathbf{\\psi}) - c \\alpha \\lVert \\mathbf{r}(\\mathbf{\\psi}) \\rVert_2^2,\n$$\nfor a user-specified parameter $c \\in (0,1)$ ensuring sufficient decrease. Use $\\tau = 1/2$ for backtracking. Terminate when $\\lVert \\mathbf{r}(\\mathbf{\\psi}) \\rVert_2 \\le \\varepsilon$ or after a maximum number of Newton iterations.\n\nImplement the solver on the domain $R \\in [1.0,1.4]$, $Z \\in [-0.2,0.2]$ with a uniform grid having $N_R = 22$ and $N_Z = 22$ nodes. The boundary condition is $\\psi_b(R,Z) = R^2$ on all boundary nodes. Use two possible initial guesses for interior nodes: either the vacuum guess $\\psi^{(0)} = R^2$ or the zero guess $\\psi^{(0)} = 0$.\n\nYour program must implement the above discretization and globalization strategy and run the following test suite. For each test case, output a list containing the final residual norm $\\lVert \\mathbf{r} \\rVert_2$ (as a float), the number of Newton iterations performed (as an integer), the total number of backtracking reductions across all iterations (as an integer), and a success flag (as an integer, $1$ if $\\lVert \\mathbf{r} \\rVert_2 \\le \\varepsilon$, else $0$). Use $\\varepsilon = 10^{-6}$ and a maximum of $50$ Newton iterations.\n\nTest suite parameter sets are $(\\alpha,\\beta,\\gamma,\\delta,c,\\text{init})$:\n1. $(0.2, 0.05, 1.0, 0.1, 10^{-4}, \\text{vacuum})$ as a general case.\n2. $(0.0, 0.0, 1.0, 0.0, 10^{-4}, \\text{vacuum})$ as a vacuum boundary and vacuum interior case.\n3. $(0.6, 0.3, 0.8, 0.3, 10^{-3}, \\text{vacuum})$ as a strongly nonlinear case.\n4. $(0.6, 0.3, 0.8, 0.3, 10^{-4}, \\text{zero})$ as a poor initial guess case.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is itself a list formatted as $[\\,\\lVert \\mathbf{r} \\rVert_2, \\text{iterations}, \\text{backtracks}, \\text{success}\\,]$. For example: \"[[r1,it1,bt1,s1],[r2,it2,bt2,s2],[r3,it3,bt3,s3],[r4,it4,bt4,s4]]\". All quantities are dimensionless, and angles if any must be in radians; no angles appear in this problem.",
            "solution": "The solution to this problem involves constructing a numerical solver based on Newton's method with a line-search globalization strategy. The key steps are discretizing the Grad–Shafranov equation, formulating the residual and Jacobian, and implementing the iterative solution loop.\n\n**1. Discretization and Matrix Formulation**\nFirst, the continuous problem must be converted into a system of algebraic equations. The computational domain is discretized on a uniform grid, and the unknown function $\\psi(R,Z)$ is represented by its values at the $(N_R-2) \\times (N_Z-2)$ interior grid points. These unknowns are organized into a single state vector, $\\mathbf{\\psi}$.\n\nThe discretized Grad–Shafranov equation for the interior nodes can be written in the form of a residual vector equation, $\\mathbf{r}(\\mathbf{\\psi}) = \\mathbf{0}$. As defined in the problem, this is:\n$$ \\mathbf{r}(\\mathbf{\\psi}) = \\mathbf{L}\\mathbf{\\psi} + \\mathbf{g} + \\mathbf{s}(\\mathbf{\\psi}) $$\n- $\\mathbf{L}$ is the sparse matrix representing the discrete $\\Delta^\\star$ operator on the interior nodes. Its entries are derived from the finite difference stencil provided.\n- $\\mathbf{g}$ is a constant vector containing the contributions from the fixed Dirichlet boundary values, $\\psi_b$.\n- $\\mathbf{s}(\\mathbf{\\psi})$ is the vector representing the nonlinear source terms, which depends on the solution $\\mathbf{\\psi}$ itself.\n\n**2. Newton's Method Formulation**\nNewton's method iteratively finds a root of $\\mathbf{r}(\\mathbf{\\psi}) = \\mathbf{0}$ by solving a sequence of linear systems. Starting with an initial guess $\\mathbf{\\psi}^{(k)}$, the update step $\\mathbf{s}^{(k)}$ is found by solving:\n$$ \\mathbf{J}(\\mathbf{\\psi}^{(k)}) \\mathbf{s}^{(k)} = -\\mathbf{r}(\\mathbf{\\psi}^{(k)}) $$\nThe solution is then updated: $\\mathbf{\\psi}^{(k+1)} = \\mathbf{\\psi}^{(k)} + \\alpha_k \\mathbf{s}^{(k)}$, where $\\alpha_k$ is a step length determined by the line search.\n\nThe Jacobian matrix, $\\mathbf{J}$, is the derivative of the residual vector $\\mathbf{r}$ with respect to the state vector $\\mathbf{\\psi}$. For the given source profiles, the Jacobian is correctly identified in the problem statement as:\n$$ \\mathbf{J}(\\mathbf{\\psi}) = \\mathbf{L} + \\operatorname{diag}\\left( 2\\beta R^2 + \\delta^2 \\right) $$\nAn important observation is that for the specific forms of $p(\\psi)$ and $F(\\psi)$ chosen, this Jacobian matrix is constant—it does not depend on the solution $\\mathbf{\\psi}$. This means the underlying system of equations is actually linear.\n\n**3. Line Search and Algorithm**\nThe line search ensures robust convergence by adjusting the step length $\\alpha_k$. The Armijo condition guarantees that each step provides a \"sufficient decrease\" in the merit function $\\Phi(\\mathbf{\\psi}) = \\frac{1}{2} \\lVert \\mathbf{r}(\\mathbf{\\psi}) \\rVert_2^2$. The algorithm proceeds as:\n1.  Initialize $\\mathbf{\\psi}^{(0)}$.\n2.  For $k=0, 1, 2, \\dots$:\n    a.  Compute the residual $\\mathbf{r}(\\mathbf{\\psi}^{(k)})$. Check for convergence ($\\lVert \\mathbf{r} \\rVert_2 \\le \\varepsilon$).\n    b.  Compute the Newton step $\\mathbf{s}^{(k)}$ by solving the linear system $\\mathbf{J} \\mathbf{s}^{(k)} = -\\mathbf{r}(\\mathbf{\\psi}^{(k)})$.\n    c.  Find a step length $\\alpha_k$ (starting from $\\alpha_k=1$ and backtracking) that satisfies the Armijo condition.\n    d.  Update the solution: $\\mathbf{\\psi}^{(k+1)} = \\mathbf{\\psi}^{(k)} + \\alpha_k \\mathbf{s}^{(k)}$.\n\nBecause the problem is linear, Newton's method is expected to find the exact solution in a single iteration if the initial guess is not the solution itself. Therefore, the solver should converge with `iterations = 1` and `backtracks = 0` for most test cases. If the initial guess happens to be the solution, it will converge in `iterations = 0`.",
            "answer": "```python\nimport numpy as np\n\ndef build_operator(R_min, R_max, Z_min, Z_max, N_R, N_Z):\n    \"\"\"\n    Constructs the discrete Grad-Shafranov operator matrix L,\n    the boundary contribution vector g, and related grid information.\n    \"\"\"\n    R_nodes = np.linspace(R_min, R_max, N_R)\n    Z_nodes = np.linspace(Z_min, Z_max, N_Z)\n    delta_R = (R_max - R_min) / (N_R - 1)\n    delta_Z = (Z_max - Z_min) / (N_Z - 1)\n    \n    N_int_R = N_R - 2\n    N_int_Z = N_Z - 2\n    N_int = N_int_R * N_int_Z\n\n    L = np.zeros((N_int, N_int))\n    g = np.zeros(N_int)\n    \n    # Flattened R^2 vector for interior points (row-major)\n    R_int_grid = R_nodes[1:-1, np.newaxis] * np.ones((N_int_R, N_int_Z))\n    R2_vec = (R_int_grid.flatten(order='C'))**2\n    \n    for i in range(N_int_R):\n        for k in range(N_int_Z):\n            m = i * N_int_Z + k\n            \n            i_grid, k_grid = i + 1, k + 1\n            \n            R_i = R_nodes[i_grid]\n            \n            # R-derivative coefficients\n            a_ip_half = 0.5 * (1.0/R_nodes[i_grid] + 1.0/R_nodes[i_grid+1])\n            a_im_half = 0.5 * (1.0/R_nodes[i_grid] + 1.0/R_nodes[i_grid-1])\n            \n            c_i = -R_i * (a_ip_half + a_im_half) / (delta_R**2)\n            c_ip1 = R_i * a_ip_half / (delta_R**2)\n            c_im1 = R_i * a_im_half / (delta_R**2)\n            \n            # Z-derivative coefficients\n            c_k = -2.0 / (delta_Z**2)\n            c_kp1 = 1.0 / (delta_Z**2)\n            c_km1 = 1.0 / (delta_Z**2)\n            \n            # Diagonal element\n            L[m, m] = c_i + c_k\n\n            # Off-diagonal elements for interior neighbors\n            if i > 0:\n                L[m, m - N_int_Z] = c_im1  # psi_{i-1, k}\n            if i < N_int_R - 1:\n                L[m, m + N_int_Z] = c_ip1  # psi_{i+1, k}\n            if k > 0:\n                L[m, m - 1] = c_km1      # psi_{i, k-1}\n            if k < N_int_Z - 1:\n                L[m, m + 1] = c_kp1      # psi_{i, k+1}\n\n            # Boundary contributions moved to RHS vector g\n            # Boundary condition is psi_b(R,Z) = R^2\n            if i == 0:\n                g[m] -= c_im1 * (R_nodes[0]**2)\n            if i == N_int_R - 1:\n                g[m] -= c_ip1 * (R_nodes[-1]**2)\n            if k == 0:\n                # psi_b = R_i^2 at Z_min boundary\n                g[m] -= c_km1 * (R_nodes[i_grid]**2)\n            if k == N_int_Z - 1:\n                # psi_b = R_i^2 at Z_max boundary\n                g[m] -= c_kp1 * (R_nodes[i_grid]**2)\n    \n    return L, g, R2_vec, R_nodes, Z_nodes\n\ndef run_solver(params, L, g, R2_vec, R_nodes, Z_nodes):\n    \"\"\"\n    Executes the Newton-Armijo solver for a given set of parameters.\n    \"\"\"\n    alpha_p, beta_p, gamma_p, delta_p, c, init_type = params\n    \n    N_R = len(R_nodes)\n    N_Z = len(Z_nodes)\n    N_int_R = N_R - 2\n    N_int_Z = N_Z - 2\n    max_iter = 50\n    epsilon = 1e-6\n    tau = 0.5\n\n    # Initialize solution vector psi\n    R_grid_full, _ = np.meshgrid(R_nodes, Z_nodes, indexing='ij')\n    \n    # Set initial guess for interior nodes\n    if init_type == 'vacuum':\n        psi_initial_interior = R_grid_full[1:-1, 1:-1]**2\n    else: # zero guess\n        psi_initial_interior = np.zeros((N_int_R, N_int_Z))\n\n    psi_vec = psi_initial_interior.flatten(order='C')\n\n    # Since the Jacobian is constant for this problem, compute it once\n    J = L + np.diag(2 * beta_p * R2_vec + delta_p**2)\n\n    iter_count = 0\n    total_backtracks = 0\n    final_r_norm = -1.0 # Default value\n\n    while iter_count < max_iter:\n        # Calculate residual vector r\n        s_vec = R2_vec * (alpha_p + 2 * beta_p * psi_vec) + delta_p * (gamma_p + delta_p * psi_vec)\n        r_vec = L @ psi_vec + g + s_vec\n        \n        r_norm = np.linalg.norm(r_vec)\n        \n        if r_norm <= epsilon:\n            final_r_norm = r_norm\n            break\n        \n        # Calculate Newton step s\n        step_s = np.linalg.solve(J, -r_vec)\n        \n        # Armijo backtracking line search\n        step_alpha = 1.0\n        phi_current = 0.5 * r_norm**2\n        armijo_rhs_term = c * r_norm**2\n        \n        local_backtracks = 0\n        while True:\n            psi_vec_new = psi_vec + step_alpha * step_s\n            \n            s_new = R2_vec * (alpha_p + 2 * beta_p * psi_vec_new) + delta_p * (gamma_p + delta_p * psi_vec_new)\n            r_new = L @ psi_vec_new + g + s_new\n            phi_new = 0.5 * np.linalg.norm(r_new)**2\n            \n            if phi_new <= phi_current - step_alpha * armijo_rhs_term:\n                psi_vec = psi_vec_new\n                total_backtracks += local_backtracks\n                break\n            \n            step_alpha *= tau\n            local_backtracks += 1\n            if step_alpha < 1e-12: # Safety break for line search\n                # This indicates a failure in finding a step length\n                # and loop will terminate due to max_iter\n                break\n                \n        iter_count += 1\n    \n    # Final residual after loop\n    s_final = R2_vec * (alpha_p + 2 * beta_p * psi_vec) + delta_p * (gamma_p + delta_p * psi_vec)\n    r_final = L @ psi_vec + g + s_final\n    final_r_norm = np.linalg.norm(r_final)\n\n    success = 1 if final_r_norm <= epsilon else 0\n    \n    return [final_r_norm, iter_count, total_backtracks, success]\n\n\ndef solve():\n    \"\"\"\n    Main function to set up the problem and run the test suite.\n    \"\"\"\n    R_min, R_max = 1.0, 1.4\n    Z_min, Z_max = -0.2, 0.2\n    N_R, N_Z = 22, 22\n\n    test_cases = [\n        # (alpha, beta, gamma, delta, c, init)\n        (0.2, 0.05, 1.0, 0.1, 1e-4, 'vacuum'),\n        (0.0, 0.0, 1.0, 0.0, 1e-4, 'vacuum'),\n        (0.6, 0.3, 0.8, 0.3, 1e-3, 'vacuum'),\n        (0.6, 0.3, 0.8, 0.3, 1e-4, 'zero'),\n    ]\n\n    # Pre-compute grid-dependent quantities\n    L, g, R2_vec, R_nodes, Z_nodes = build_operator(R_min, R_max, Z_min, Z_max, N_R, N_Z)\n\n    results = []\n    for case_params in test_cases:\n        result = run_solver(case_params, L, g, R2_vec, R_nodes, Z_nodes)\n        results.append(result)\n\n    # Format output as specified\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}