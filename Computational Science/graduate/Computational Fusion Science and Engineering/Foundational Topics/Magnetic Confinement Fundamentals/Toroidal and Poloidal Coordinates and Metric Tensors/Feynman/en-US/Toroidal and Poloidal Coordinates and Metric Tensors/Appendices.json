{
    "hands_on_practices": [
        {
            "introduction": "To analyze physical phenomena within a tokamak, we must first establish the geometric framework. This initial practice focuses on deriving the metric tensor and its associated Jacobian for a simplified circular toroidal coordinate system . Mastering this fundamental calculation is the gateway to describing distances, areas, and volumes within the toroidal geometry, forming the essential foundation for virtually all transport and equilibrium calculations in fusion plasma physics.",
            "id": "4056484",
            "problem": "Consider an axisymmetric toroidal plasma in the circular concentric flux-surface approximation used in computational fusion science and engineering. Let the major radius be a constant $R_{0} > 0$, and adopt the flux coordinates $(r,\\theta,\\phi)$ defined by the geometric mapping into cylindrical coordinates $(R,\\phi,Z)$ via $R(r,\\theta) = R_{0} + r \\cos\\theta$ and $Z(r,\\theta) = r \\sin\\theta$, with the toroidal angle $\\phi$ preserved. Assume three-dimensional Euclidean space with the standard Euclidean metric and define the covariant metric tensor $g_{ij}$ induced by this mapping through the covariant basis vectors obtained from the coordinate transformation. Angles $\\theta$ and $\\phi$ are measured in radians.\n\nStarting from the fundamental definition of a metric induced by a smooth coordinate mapping in Euclidean space and the Euclidean line element expressed in cylindrical coordinates, derive the covariant metric tensor $g_{ij}(r,\\theta,\\phi)$ in the $(r,\\theta,\\phi)$ coordinates, compute its determinant $g = \\det(g_{ij})$, and use it to obtain the Jacobian factor $\\sqrt{g}$ of the transformation from Cartesian coordinates to $(r,\\theta,\\phi)$. Provide your final answer as a single closed-form analytic expression for $\\sqrt{g}$ in terms of $r$, $\\theta$, and $R_{0}$. No numerical approximation is required, and no units should be included in the final expression.",
            "solution": "The problem requires the derivation of the Jacobian factor $\\sqrt{g}$ for a specific toroidal coordinate system $(r, \\theta, \\phi)$ used in fusion science. The derivation must proceed from the fundamental definition of the metric tensor $g_{ij}$ induced by the coordinate transformation from Euclidean space.\n\nThe starting point is the infinitesimal line element $ds^2$ in three-dimensional Euclidean space. It is convenient to express this line element in cylindrical coordinates $(R, \\phi, Z)$, where it takes the well-known form:\n$$\nds^2 = dR^2 + R^2 d\\phi^2 + dZ^2\n$$\nThis expression represents the metric of the embedding Euclidean space, described in a coordinate system adapted to the toroidal symmetry.\n\nThe problem provides the transformation from the toroidal coordinates $(r, \\theta, \\phi)$ to the cylindrical coordinates $(R, \\phi, Z)$ as:\n$$\n\\begin{cases}\nR(r, \\theta) = R_0 + r \\cos\\theta \\\\\nZ(r, \\theta) = r \\sin\\theta \\\\\n\\phi = \\phi\n\\end{cases}\n$$\nwhere $R_0$ is the constant major radius.\n\nTo express the line element $ds^2$ in terms of the toroidal coordinates, we must find the differentials $dR$ and $dZ$ in terms of $dr$ and $d\\theta$. Using the chain rule for differentiation, we have:\n$$\ndR = \\frac{\\partial R}{\\partial r} dr + \\frac{\\partial R}{\\partial \\theta} d\\theta\n$$\n$$\ndZ = \\frac{\\partial Z}{\\partial r} dr + \\frac{\\partial Z}{\\partial \\theta} d\\theta\n$$\nWe compute the necessary partial derivatives from the transformation equations:\n$$\n\\frac{\\partial R}{\\partial r} = \\cos\\theta\n$$\n$$\n\\frac{\\partial R}{\\partial \\theta} = -r \\sin\\theta\n$$\n$$\n\\frac{\\partial Z}{\\partial r} = \\sin\\theta\n$$\n$$\n\\frac{\\partial Z}{\\partial \\theta} = r \\cos\\theta\n$$\nSubstituting these into the differential expressions yields:\n$$\ndR = \\cos\\theta \\, dr - r \\sin\\theta \\, d\\theta\n$$\n$$\ndZ = \\sin\\theta \\, dr + r \\cos\\theta \\, d\\theta\n$$\nThe differential $d\\phi$ remains unchanged. Now, we substitute these expressions for $dR$ and $dZ$, along with the expression for $R$, into the cylindrical line element $ds^2$:\n$$\nds^2 = (\\cos\\theta \\, dr - r \\sin\\theta \\, d\\theta)^2 + (R_0 + r \\cos\\theta)^2 d\\phi^2 + (\\sin\\theta \\, dr + r \\cos\\theta \\, d\\theta)^2\n$$\nLet's expand the squared terms involving $dr$ and $d\\theta$:\n$$\n(\\cos\\theta \\, dr - r \\sin\\theta \\, d\\theta)^2 = \\cos^2\\theta \\, dr^2 - 2r \\sin\\theta \\cos\\theta \\, dr d\\theta + r^2 \\sin^2\\theta \\, d\\theta^2\n$$\n$$\n(\\sin\\theta \\, dr + r \\cos\\theta \\, d\\theta)^2 = \\sin^2\\theta \\, dr^2 + 2r \\sin\\theta \\cos\\theta \\, dr d\\theta + r^2 \\cos^2\\theta \\, d\\theta^2\n$$\nSumming these two results gives the poloidal part of the line element, $dR^2 + dZ^2$:\n$$\ndR^2 + dZ^2 = (\\cos^2\\theta + \\sin^2\\theta) dr^2 + (-2r \\sin\\theta \\cos\\theta + 2r \\sin\\theta \\cos\\theta) dr d\\theta + (r^2 \\sin^2\\theta + r^2 \\cos^2\\theta) d\\theta^2\n$$\nUsing the trigonometric identity $\\sin^2\\theta + \\cos^2\\theta = 1$, this simplifies to:\n$$\ndR^2 + dZ^2 = dr^2 + r^2 d\\theta^2\n$$\nSubstituting this simplified expression back into the total line element $ds^2$, we obtain:\n$$\nds^2 = dr^2 + r^2 d\\theta^2 + (R_0 + r \\cos\\theta)^2 d\\phi^2\n$$\nThe general form of the line element in an arbitrary coordinate system $(x^1, x^2, x^3)$ is given by $ds^2 = \\sum_{i,j} g_{ij} dx^i dx^j$. By identifying our coordinates as $(x^1, x^2, x^3) = (r, \\theta, \\phi)$, we can directly read the components of the covariant metric tensor $g_{ij}$ from the coefficients of the differential terms $dr^2$, $d\\theta^2$, and $d\\phi^2$.\n$$\ng_{rr} = 1\n$$\n$$\ng_{\\theta\\theta} = r^2\n$$\n$$\ng_{\\phi\\phi} = (R_0 + r \\cos\\theta)^2\n$$\nSince there are no cross-terms (e.g., $dr d\\theta$), all off-diagonal components are zero: $g_{ij} = 0$ for $i \\neq j$. The metric tensor in matrix form is therefore:\n$$\ng_{ij} = \\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & r^2 & 0 \\\\\n0 & 0 & (R_0 + r \\cos\\theta)^2\n\\end{pmatrix}\n$$\nThe next step is to compute the determinant of the metric tensor, denoted by $g$. For a diagonal matrix, the determinant is the product of its diagonal elements:\n$$\ng = \\det(g_{ij}) = g_{rr} g_{\\theta\\theta} g_{\\phi\\phi} = (1)(r^2)((R_0 + r \\cos\\theta)^2)\n$$\n$$\ng = r^2 (R_0 + r \\cos\\theta)^2\n$$\nThe Jacobian factor of the transformation from Cartesian coordinates to the $(r, \\theta, \\phi)$ coordinates is given by $\\sqrt{g}$. Taking the square root of the determinant, we find:\n$$\n\\sqrt{g} = \\sqrt{r^2 (R_0 + r \\cos\\theta)^2} = |r| |R_0 + r \\cos\\theta|\n$$\nIn the context of toroidal geometry, the coordinate $r$ represents a minor radius and is, by definition, non-negative, so $|r| = r$. The quantity $R = R_0 + r \\cos\\theta$ represents the major radial position in cylindrical coordinates, which for any physical point in space must be non-negative. In typical fusion applications, the domain of interest is $r < R_0$, which guarantees $R > 0$. Therefore, we can drop the absolute value signs.\n$$\n\\sqrt{g} = r (R_0 + r \\cos\\theta)\n$$\nThis expression is the Jacobian factor, which relates the volume element in Cartesian coordinates $dV = dx \\, dy \\, dz$ to the volume element in these toroidal coordinates $dV = \\sqrt{g} \\, dr \\, d\\theta \\, d\\phi$.",
            "answer": "$$\n\\boxed{r(R_{0} + r \\cos \\theta)}\n$$"
        },
        {
            "introduction": "With the metric tensor defined, we can construct differential operators that describe physical processes like heat and particle diffusion. This exercise guides you through building a discrete version of the Laplace-Beltrami operator on a toroidal surface, a task central to solving transport equations computationally . By ensuring the numerical operator retains the self-adjointness of its continuous counterpart, you will practice a crucial technique for developing stable and physically meaningful simulation codes.",
            "id": "4056482",
            "problem": "You are asked to derive and implement a discrete form of the Laplace-Beltrami operator on a two-dimensional flux surface embedded in three-dimensional Euclidean space, and to verify its self-adjointness with respect to the metric-weighted inner product. The flux surface is a circular torus parameterized by the poloidal angle $\\,\\theta\\,$ and toroidal angle $\\,\\phi\\,$, both in radians, with major radius $\\,R_0 > 0\\,$ and minor radius $\\,a > 0\\,$ such that $\\,a < R_0\\,$. The surface is given by the map from angles to Cartesian coordinates,\n$$\n\\mathbf{r}(\\theta,\\phi) = \\big( (R_0 + a \\cos\\theta)\\cos\\phi,\\; (R_0 + a \\cos\\theta)\\sin\\phi,\\; a\\sin\\theta \\big).\n$$\nStarting from the coordinate-invariant definition of the Laplace-Beltrami operator in terms of the metric tensor and the associated volume form, and from the induced metric on the embedded surface obtained via pullback of the Euclidean metric, derive a discretization on a uniform angular grid in $\\,\\theta\\,$ and $\\,\\phi\\,$ that:\n- Is expressed in divergence form using midpoint (edge) coefficients built from the metric quantities.\n- Enforces periodic boundary conditions in $\\,\\theta\\,$ and $\\,\\phi\\,$ (angles are in radians).\n- Is self-adjoint with respect to the discrete metric-weighted inner product\n$$\n\\langle u, v \\rangle = \\sum_{i=0}^{N_\\theta-1}\\sum_{j=0}^{N_\\phi-1} \\sqrt{g(\\theta_i,\\phi_j)}\\,\\Delta\\theta\\,\\Delta\\phi\\; u_{i,j}\\,v_{i,j},\n$$\nwhere $\\,\\Delta\\theta = \\frac{2\\pi}{N_\\theta}\\,$, $\\,\\Delta\\phi = \\frac{2\\pi}{N_\\phi}\\,$, $\\,\\theta_i = i \\Delta\\theta\\,$, $\\,\\phi_j = j \\Delta\\phi\\,$, and $\\,\\sqrt{g}\\,$ is the square root of the determinant of the metric tensor on the surface. Self-adjointness in the discrete sense means the stiffness matrix $\\,A\\,$ of the discrete operator satisfies $\\,W A = (W A)^\\top\\,$, where $\\,W\\,$ is the diagonal matrix of the weights $\\,\\sqrt{g(\\theta_i,\\phi_j)}\\,\\Delta\\theta\\,\\Delta\\phi\\,$.\n\nImplement your derivation by constructing the sparse matrix $\\,A\\,$ on a uniform $\\,N_\\theta \\times N_\\phi\\,$ grid using the divergence-form stencil with shared edge coefficients\n$$\n\\text{edge coefficient along } \\theta: \\quad c_\\theta = \\sqrt{g}\\,g^{\\theta\\theta},\\qquad\n\\text{edge coefficient along } \\phi: \\quad c_\\phi = \\sqrt{g}\\,g^{\\phi\\phi},\n$$\nand midpoint (edge) averaging for $\\,c_\\theta\\,$ along $\\,\\theta\\,$ and appropriate treatment for $\\,c_\\phi\\,$ along $\\,\\phi\\,$ given its dependence on $\\,\\theta\\,$ only. Then verify numerically, for each test case, that $\\,W A\\,$ is symmetric by checking that the maximum absolute difference of $\\,W A - (W A)^\\top\\,$ is less than or equal to a specified tolerance.\n\nAngles must be in radians. No physical unit conversion is required beyond the angle unit.\n\nUse the following test suite, where each tuple is $\\,(\\,R_0,\\,a,\\,N_\\theta,\\,N_\\phi,\\,\\text{tolerance}\\,)\\,$:\n- Case $\\,1\\,$ (happy path): $\\,(\\,3.0,\\,1.0,\\,32,\\,64,\\,10^{-12}\\,)\\,$.\n- Case $\\,2\\,$ (coarse boundary case): $\\,(\\,3.0,\\,1.0,\\,4,\\,4,\\,10^{-12}\\,)\\,$.\n- Case $\\,3\\,$ (near-unity aspect ratio): $\\,(\\,1.2,\\,1.0,\\,16,\\,24,\\,10^{-12}\\,)\\,$.\n- Case $\\,4\\,$ (higher resolution but still computationally moderate): $\\,(\\,2.5,\\,0.5,\\,64,\\,96,\\,10^{-12}\\,)\\,$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\,\\text{result1},\\text{result2},\\text{result3},\\text{result4}\\,]$), where each result is a boolean indicating whether the symmetry criterion $\\lVert W A - (W A)^\\top \\rVert_{\\max} \\le \\text{tolerance}$ holds for the corresponding test case.",
            "solution": "The problem requires the derivation and implementation of a discrete Laplace-Beltrami operator on a toroidal surface and the numerical verification of its self-adjointness. The process involves several steps, starting from the geometric definition of the surface to the construction of a sparse matrix representing the operator.\n\n### 1. Derivation of the Metric Tensor\n\nThe toroidal surface is parameterized by $\\mathbf{r}(\\theta, \\phi)$, where $\\theta \\in [0, 2\\pi)$ is the poloidal angle and $\\phi \\in [0, 2\\pi)$ is the toroidal angle.\n$$ \\mathbf{r}(\\theta,\\phi) = \\big( (R_0 + a \\cos\\theta)\\cos\\phi,\\; (R_0 + a \\cos\\theta)\\sin\\phi,\\; a\\sin\\theta \\big) $$\nThe components of the metric tensor, $g_{ij}$, are induced by the Euclidean metric of the ambient $\\mathbb{R}^3$ space. They are calculated as the inner products of the tangent basis vectors, $\\mathbf{e}_\\theta = \\frac{\\partial \\mathbf{r}}{\\partial \\theta}$ and $\\mathbf{e}_\\phi = \\frac{\\partial \\mathbf{r}}{\\partial \\phi}$.\n\nFirst, we compute the tangent vectors:\n$$ \\mathbf{e}_\\theta = \\frac{\\partial \\mathbf{r}}{\\partial \\theta} = \\begin{pmatrix} -a\\sin\\theta\\cos\\phi \\\\ -a\\sin\\theta\\sin\\phi \\\\ a\\cos\\theta \\end{pmatrix} $$\n$$ \\mathbf{e}_\\phi = \\frac{\\partial \\mathbf{r}}{\\partial \\phi} = \\begin{pmatrix} -(R_0 + a\\cos\\theta)\\sin\\phi \\\\ (R_0 + a\\cos\\theta)\\cos\\phi \\\\ 0 \\end{pmatrix} $$\n\nNext, we calculate the metric tensor components $g_{ij} = \\mathbf{e}_i \\cdot \\mathbf{e}_j$:\n$$ g_{\\theta\\theta} = \\mathbf{e}_\\theta \\cdot \\mathbf{e}_\\theta = (-a\\sin\\theta\\cos\\phi)^2 + (-a\\sin\\theta\\sin\\phi)^2 + (a\\cos\\theta)^2 = a^2\\sin^2\\theta(\\cos^2\\phi + \\sin^2\\phi) + a^2\\cos^2\\theta = a^2 $$\n$$ g_{\\phi\\phi} = \\mathbf{e}_\\phi \\cdot \\mathbf{e}_\\phi = (-(R_0 + a\\cos\\theta)\\sin\\phi)^2 + ((R_0 + a\\cos\\theta)\\cos\\phi)^2 = (R_0 + a\\cos\\theta)^2 $$\n$$ g_{\\theta\\phi} = \\mathbf{e}_\\theta \\cdot \\mathbf{e}_\\phi = a\\sin\\theta\\cos\\phi(R_0 + a\\cos\\theta)\\sin\\phi - a\\sin\\theta\\sin\\phi(R_0 + a\\cos\\theta)\\cos\\phi = 0 $$\n\nThe metric tensor is diagonal, as expected for a surface of revolution with orthogonal parameterization:\n$$ g_{ij} = \\begin{pmatrix} a^2 & 0 \\\\ 0 & (R_0 + a\\cos\\theta)^2 \\end{pmatrix} $$\n\nThe determinant of the metric tensor, $g$, is:\n$$ g = \\det(g_{ij}) = a^2 (R_0 + a\\cos\\theta)^2 $$\nThe volume element on the surface is $\\sqrt{g}\\,d\\theta\\,d\\phi$, where $\\sqrt{g} = a(R_0 + a\\cos\\theta)$. The condition $R_0 > a > 0$ ensures that $\\sqrt{g}$ is always positive.\n\nThe inverse metric tensor, $g^{ij}$, is also diagonal:\n$$ g^{ij} = \\begin{pmatrix} 1/a^2 & 0 \\\\ 0 & 1/(R_0 + a\\cos\\theta)^2 \\end{pmatrix} $$\nThus, $g^{\\theta\\theta} = 1/a^2$ and $g^{\\phi\\phi} = 1/(R_0 + a\\cos\\theta)^2$.\n\n### 2. The Laplace-Beltrami Operator in Divergence Form\n\nFor a scalar function $f(\\theta, \\phi)$, the Laplace-Beltrami operator, $\\Delta_{LB}$, is defined in coordinates as:\n$$ \\Delta_{LB} f = \\frac{1}{\\sqrt{g}} \\sum_{i,j} \\frac{\\partial}{\\partial u^i} \\left( \\sqrt{g} g^{ij} \\frac{\\partial f}{\\partial u^j} \\right) $$\nSubstituting our coordinates and metric components, and using the fact that the metric is diagonal, we obtain the divergence form:\n$$ \\Delta_{LB} f = \\frac{1}{\\sqrt{g}} \\left[ \\frac{\\partial}{\\partial \\theta} \\left( \\sqrt{g} g^{\\theta\\theta} \\frac{\\partial f}{\\partial \\theta} \\right) + \\frac{\\partial}{\\partial \\phi} \\left( \\sqrt{g} g^{\\phi\\phi} \\frac{\\partial f}{\\partial \\phi} \\right) \\right] $$\nThe problem defines edge coefficients $c_\\theta = \\sqrt{g}g^{\\theta\\theta}$ and $c_\\phi = \\sqrt{g}g^{\\phi\\phi}$:\n$$ c_\\theta(\\theta) = a(R_0 + a\\cos\\theta) \\cdot \\frac{1}{a^2} = \\frac{R_0 + a\\cos\\theta}{a} $$\n$$ c_\\phi(\\theta) = a(R_0 + a\\cos\\theta) \\cdot \\frac{1}{(R_0 + a\\cos\\theta)^2} = \\frac{a}{R_0 + a\\cos\\theta} $$\nNote that both coefficients depend only on $\\theta$. The operator can now be written as:\n$$ \\Delta_{LB} f = \\frac{1}{\\sqrt{g}} \\left[ \\frac{\\partial}{\\partial \\theta} \\left( c_\\theta(\\theta) \\frac{\\partial f}{\\partial \\theta} \\right) + \\frac{\\partial}{\\partial \\phi} \\left( c_\\phi(\\theta) \\frac{\\partial f}{\\partial \\phi} \\right) \\right] $$\n\n### 3. Finite Difference Discretization and Self-Adjointness\n\nWe discretize the operator on a uniform grid $(\\theta_i, \\phi_j)$ with spacings $\\Delta\\theta = 2\\pi/N_\\theta$ and $\\Delta\\phi = 2\\pi/N_\\phi$. A second-order accurate finite difference scheme that guarantees self-adjointness is constructed by evaluating fluxes on the edges of the grid cells.\n\nLet $L f = \\frac{\\partial}{\\partial \\theta} ( c_\\theta \\frac{\\partial f}{\\partial \\theta} ) + \\frac{\\partial}{\\partial \\phi} ( c_\\phi \\frac{\\partial f}{\\partial \\phi} )$. Thus, $\\Delta_{LB} f = \\frac{1}{\\sqrt{g}} L f$.\nAt a grid point $(i,j)$, the discrete form of $(Lf)_{i,j}$ is:\n$$ (L f)_{i,j} \\approx \\frac{1}{\\Delta\\theta} \\left[ (c_\\theta \\frac{\\partial f}{\\partial \\theta})_{i+1/2,j} - (c_\\theta \\frac{\\partial f}{\\partial \\theta})_{i-1/2,j} \\right] + \\frac{1}{\\Delta\\phi} \\left[ (c_\\phi \\frac{\\partial f}{\\partial \\phi})_{i,j+1/2} - (c_\\phi \\frac{\\partial f}{\\partial \\phi})_{i,j-1/2} \\right] $$\nUsing centered differences for derivatives and evaluating coefficients at cell edges (midpoints):\n$$ (L f)_{i,j} \\approx \\frac{1}{\\Delta\\theta} \\left[ c_{\\theta,i+1/2} \\frac{f_{i+1,j}-f_{i,j}}{\\Delta\\theta} - c_{\\theta,i-1/2} \\frac{f_{i,j}-f_{i-1,j}}{\\Delta\\theta} \\right] + \\frac{1}{\\Delta\\phi} \\left[ c_{\\phi, i} \\frac{f_{i,j+1}-f_{i,j}}{\\Delta\\phi} - c_{\\phi, i} \\frac{f_{i,j}-f_{i,j-1}}{\\Delta\\phi} \\right] $$\nHere, $c_{\\theta,i\\pm1/2} = c_\\theta(\\theta_{i\\pm1/2})$ and $c_{\\phi,i} = c_\\phi(\\theta_i)$. Since $c_\\phi$ depends only on $\\theta$, its value is constant along the $\\phi$ direction for a given $i$.\n\nThe matrix $A$ of the discrete operator maps the vector of function values $\\mathbf{f}$ to the vector $(\\Delta_{LB} f)_{i,j}$, so $(A\\mathbf{f})_{k} = \\frac{1}{\\sqrt{g}_{i,j}}(L f)_{i,j}$, where $k=i N_\\phi + j$.\nThe self-adjointness condition is that the matrix $WA$ is symmetric, where $W$ is the diagonal matrix of inner product weights $w_{i,j} = \\sqrt{g}_{i,j}\\,\\Delta\\theta\\,\\Delta\\phi$.\nLet's examine an element of the matrix product $S = WA$. For a global index $k$ corresponding to grid point $(i,j)$, the $k$-th diagonal element of $W$ is $W_{k,k}=w_{i,j}$. The action on a vector $\\mathbf{f}$ is:\n$$ (S \\mathbf{f})_k = (W A \\mathbf{f})_k = W_{k,k} (A \\mathbf{f})_k = (\\sqrt{g}_{i,j}\\Delta\\theta\\Delta\\phi) \\left(\\frac{1}{\\sqrt{g}_{i,j}} (L f)_{i,j}\\right) = \\Delta\\theta\\Delta\\phi \\, (L f)_{i,j} $$\nSo, the matrix $S = WA$ is the discrete representation of the operator $\\Delta\\theta\\Delta\\phi \\cdot L$. The symmetry of $S$ (i.e., $S=S^\\top$) is what we need to verify.\n\nLet's look at the off-diagonal elements of $S$. Let $k = i N_\\phi + j$.\nThe coefficient multiplying $f_{i+1,j}$ in the expression for $(S \\mathbf{f})_k$ gives the matrix element $S_{k, l}$ where $l=(i+1)N_\\phi+j$:\n$$ S_{k,l} = \\Delta\\theta\\Delta\\phi \\cdot \\frac{c_{\\theta,i+1/2}}{\\Delta\\theta^2} = \\frac{\\Delta\\phi}{\\Delta\\theta} c_{\\theta,i+1/2} $$\nNow, consider the element $S_{l,k}$. This is the coefficient of $f_{i,j}$ in the expression for $(S\\mathbf{f})_l$. The stencil at point $l=(i+1,j)$ has a term for its neighbor at $(i,j)$:\n$$ \\Delta\\theta\\Delta\\phi \\left( \\dots - c_{\\theta,(i+1)-1/2} \\frac{f_{i+1,j} - f_{i,j}}{\\Delta\\theta^2} \\right) = \\Delta\\theta\\Delta\\phi \\left( \\dots + \\frac{c_{\\theta,i+1/2}}{\\Delta\\theta^2}f_{i,j} \\right)$$\nThe coefficient is $\\frac{\\Delta\\phi}{\\Delta\\theta} c_{\\theta,i+1/2}$. Thus, $S_{k,l} = S_{l,k}$. This symmetry arises from using the same interface coefficient $c_{\\theta,i+1/2}$ for the flux between cells $(i,j)$ and $(i+1,j)$.\n\nA similar argument holds for the $\\phi$ direction. Let $l=iN_\\phi+(j+1)$.\n$$ S_{k,l} = \\Delta\\theta\\Delta\\phi \\cdot \\frac{c_{\\phi,i}}{\\Delta\\phi^2} = \\frac{\\Delta\\theta}{\\Delta\\phi}c_{\\phi,i} $$\nThe element $S_{l,k}$ is the coefficient of $f_{i,j}$ in the expression for $(S\\mathbf{f})_l$. The stencil at $(i,j+1)$ uses coefficient $c_{\\phi,i}$ (it only depends on $i$) and gives:\n$$ \\Delta\\theta\\Delta\\phi \\left( \\dots c_{\\phi,i} \\frac{f_{i,j+2}-2f_{i,j+1}+f_{i,j}}{\\Delta\\phi^2} \\right) = \\Delta\\theta\\Delta\\phi \\left(\\dots + \\frac{c_{\\phi,i}}{\\Delta\\phi^2}f_{i,j} \\right) $$\nThe coefficient is $\\frac{\\Delta\\theta}{\\Delta\\phi} c_{\\phi,i}$. Thus, $S_{k,l}=S_{l,k}$.\nSince all off-diagonal elements are symmetric, the matrix $S = WA$ is symmetric.\n\n### 4. Implementation Strategy\n\nTo verify this numerically, we will construct the sparse matrix $S=WA$ directly. For each grid point $(i, j)$ corresponding to row $k = iN_\\phi+j$, we compute the five stencil entries (center and four neighbors) based on the derived formula for $S$. The neighbors' indices are determined with periodic boundary conditions. The resulting sparse matrix $S$ is then checked for symmetry by computing the maximum absolute element of $S - S^\\top$. This value should be close to zero, within the machine precision limit or a specified tolerance.\n\nThe algorithm is as follows:\n1.  For each test case, set up the grid parameters ($N_\\theta, N_\\phi, \\Delta\\theta, \\Delta\\phi$).\n2.  Compute the coefficient arrays $c_\\theta$ on the $\\theta$-midpoint grid and $c_\\phi$ on the $\\theta$-node grid.\n3.  Initialize data structures for building a sparse matrix (e.g., lists for data, row indices, and column indices).\n4.  Iterate through every grid point $(i, j)$:\n    a. Determine the 1D index $k$ for the current point and the 1D indices for its four neighbors, respecting periodic boundaries.\n    b. Calculate the five non-zero matrix elements for row $k$ of matrix $S = WA$.\n    c. Append these five elements and their corresponding indices to the data structures.\n5.  Construct the sparse matrix $S$ from the collected data.\n6.  Calculate the difference matrix $D = S - S^\\top$.\n7.  Find the maximum absolute value in $D$, $\\|D\\|_{\\max}$.\n8.  Compare $\\|D\\|_{\\max}$ with the given tolerance to determine if the matrix is symmetric.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix\n\ndef create_and_verify_laplacian(R0, a, N_theta, N_phi, tolerance):\n    \"\"\"\n    Derives, implements, and verifies the self-adjointness of a discrete\n    Laplace-Beltrami operator on a toroidal flux surface.\n\n    Args:\n        R0 (float): Major radius of the torus.\n        a (float): Minor radius of the torus.\n        N_theta (int): Number of grid points in the poloidal direction.\n        N_phi (int): Number of grid points in the toroidal direction.\n        tolerance (float): The tolerance for the symmetry check.\n\n    Returns:\n        bool: True if the WA matrix is symmetric within the tolerance, False otherwise.\n    \"\"\"\n    # 1. Grid setup\n    d_theta = 2.0 * np.pi / N_theta\n    d_phi = 2.0 * np.pi / N_phi\n    \n    # 2. Coordinates\n    # Node-centered grid for theta (for c_phi and sqrt(g))\n    theta_nodes = np.arange(N_theta) * d_theta\n    # Edge-centered/midpoint grid for theta (for c_theta)\n    theta_halfs = (np.arange(N_theta) + 0.5) * d_theta\n\n    # 3. Geometric coefficients\n    # c_theta = sqrt(g) * g^{theta,theta} evaluated at midpoints theta_{i+1/2}\n    c_theta_half = (R0 + a * np.cos(theta_halfs)) / a\n    # c_phi = sqrt(g) * g^{phi,phi} evaluated at nodes theta_i\n    c_phi_node = a / (R0 + a * np.cos(theta_nodes))\n\n    # 4. Sparse matrix S = WA construction\n    total_points = N_theta * N_phi\n    # Pre-allocate for a 5-point stencil\n    data = np.zeros(total_points * 5)\n    row_indices = np.zeros(total_points * 5, dtype=int)\n    col_indices = np.zeros(total_points * 5, dtype=int)\n    \n    dv = d_theta * d_phi\n    idx_counter = 0\n\n    for i in range(N_theta):\n        for j in range(N_phi):\n            k = i * N_phi + j  # Current point's 1D index\n\n            # Neighbor indices with periodic boundary conditions\n            ip1 = (i + 1) % N_theta\n            im1 = (i - 1 + N_theta) % N_theta\n            jp1 = (j + 1) % N_phi\n            jm1 = (j - 1 + N_phi) % N_phi\n\n            k_ip1_j = ip1 * N_phi + j\n            k_im1_j = im1 * N_phi + j\n            k_i_jp1 = i * N_phi + jp1\n            k_i_jm1 = i * N_phi + jm1\n\n            # Get coefficients for the finite difference stencil of S=WA\n            # For c_theta, index i corresponds to theta_{i+1/2} and im1 to theta_{i-1/2}\n            c_th_p = c_theta_half[i]\n            c_th_m = c_theta_half[im1]\n            c_ph = c_phi_node[i]\n            \n            # Off-diagonal elements for row k of matrix S = WA\n            \n            # Neighbor i+1\n            s_ip1 = dv * c_th_p / (d_theta**2)\n            data[idx_counter] = s_ip1\n            row_indices[idx_counter] = k\n            col_indices[idx_counter] = k_ip1_j\n            idx_counter += 1\n\n            # Neighbor i-1\n            s_im1 = dv * c_th_m / (d_theta**2)\n            data[idx_counter] = s_im1\n            row_indices[idx_counter] = k\n            col_indices[idx_counter] = k_im1_j\n            idx_counter += 1\n\n            # Neighbor j+1\n            s_jp1 = dv * c_ph / (d_phi**2)\n            data[idx_counter] = s_jp1\n            row_indices[idx_counter] = k\n            col_indices[idx_counter] = k_i_jp1\n            idx_counter += 1\n\n            # Neighbor j-1\n            s_jm1 = dv * c_ph / (d_phi**2)\n            data[idx_counter] = s_jm1\n            row_indices[idx_counter] = k\n            col_indices[idx_counter] = k_i_jm1\n            idx_counter += 1\n            \n            # Diagonal element for row k\n            s_diag = - (s_ip1 + s_im1 + s_jp1 + s_jm1)\n            data[idx_counter] = s_diag\n            row_indices[idx_counter] = k\n            col_indices[idx_counter] = k\n            idx_counter += 1\n            \n    # 5. Create sparse matrix S=WA\n    S = csr_matrix((data, (row_indices, col_indices)), shape=(total_points, total_points))\n    \n    # 6. Check for symmetry: S must equal S^T\n    # The comparison is done by finding the max absolute difference.\n    diff_matrix = S - S.transpose()\n    max_abs_diff = np.abs(diff_matrix).max()\n    \n    return max_abs_diff = tolerance\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3.0, 1.0, 32, 64, 1e-12),\n        (3.0, 1.0, 4, 4, 1e-12),\n        (1.2, 1.0, 16, 24, 1e-12),\n        (2.5, 0.5, 64, 96, 1e-12),\n    ]\n\n    results = []\n    for R0, a, N_theta, N_phi, tolerance in test_cases:\n        is_symmetric = create_and_verify_laplacian(R0, a, N_theta, N_phi, tolerance)\n        results.append(is_symmetric)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While standard coordinates describe the geometry, they may not be the most convenient for describing the physics. This advanced practice explores the concept of \"straight-field-line\" coordinates, which are specifically designed to simplify the representation of the magnetic field itself . By deriving and implementing the transformation to this optimized coordinate system, you will engage with a powerful technique used in equilibrium analysis to make the complex structure of magnetic fields in toroidal devices more tractable.",
            "id": "4056489",
            "problem": "Consider a single nested magnetic flux surface labeled by the radial-like coordinate $\\psi$ in a toroidal device, parameterized by the angular coordinates $(\\theta,\\zeta)$, where $\\theta$ is the poloidal angle and $\\zeta$ is the toroidal angle. All angles are to be treated in radians. Assume the contravariant components of the magnetic field, $B\\cdot\\nabla\\theta$ and $B\\cdot\\nabla\\zeta$, are known functions of $\\theta$ on the surface. These functions can be obtained from the Variational Moments Equilibrium Code (VMEC), but for this problem you will use synthetic functions defined explicitly in the test suite below.\n\nFundamental definitions for straight-field-line construction: A key characteristic of the magnetic field is the safety factor, $q(\\psi)$, which measures the field line pitch. A straight-field-line poloidal angle, denoted $\\theta'$, is any reparameterization $\\theta' = \\Theta(\\theta)$ that makes this pitch independent of the poloidal coordinate on the surface. This condition is expressed by setting the ratio of the contravariant field components in the new coordinate system to be constant: $(B\\cdot\\nabla\\zeta)/(B\\cdot\\nabla\\theta') = q(\\psi)$.\n\nYour tasks are:\n- Starting only from the definitions above and basic calculus of coordinate transformations, derive the integral equation that determines the mapping $\\theta'(\\theta)$ that ensures the pitch is constant on the surface, and show how the safety factor $q(\\psi)$ emerges self-consistently from this construction. Angles must be treated in radians.\n- Devise a numerically stable algorithm to compute $\\theta'(\\theta)$ from discrete samples of $B\\cdot\\nabla\\theta(\\theta)$ and $B\\cdot\\nabla\\zeta(\\theta)$ provided on a uniform grid $\\theta_j = 2\\pi j/N$ for $j=0,\\dots,N-1$, with $N$ an even integer. Your algorithm must:\n  1. Compute the safety factor $q$ from the discrete data using a convergent quadrature rule on $[0,2\\pi)$.\n  2. Compute the derivative $d\\theta'/d\\theta$ and the mapping $\\theta'(\\theta)$ consistent with periodicity $\\theta'(2\\pi)-\\theta'(0)=2\\pi$ and strict monotonicity $d\\theta'/d\\theta0$ for all $\\theta$.\n  3. Verify monotonicity numerically.\n- Implement the algorithm as a program using a uniform grid size $N$ chosen to resolve the highest Fourier mode present in the test suite below. All computations are dimensionless; report angles in radians.\n\nTest suite (each case defines functions of $\\theta$ on $[0,2\\pi)$):\n- Case A (constant pitch): $B\\cdot\\nabla\\theta(\\theta) = 2.0$, $B\\cdot\\nabla\\zeta(\\theta) = 10.0$. The exact safety factor is $q = 5.0$.\n- Case B (moderate poloidal variation in $B\\cdot\\nabla\\zeta$): $B\\cdot\\nabla\\theta(\\theta) = 1.0$, $B\\cdot\\nabla\\zeta(\\theta) = 2.5\\,[1 + 0.3\\cos(3\\theta)]$. The exact safety factor is $q = 2.5$.\n- Case C (poloidal variation in $B\\cdot\\nabla\\theta$): $B\\cdot\\nabla\\theta(\\theta) = 1 + 0.8\\cos\\theta$, $B\\cdot\\nabla\\zeta(\\theta) = 3.0$. The exact safety factor is $q = 3.0 / \\sqrt{1-0.8^2} = 5.0$.\n- Case D (high-mode poloidal variation): $B\\cdot\\nabla\\theta(\\theta) = 1.0$, $B\\cdot\\nabla\\zeta(\\theta) = 2.0\\,[1 + 0.9\\cos(20\\theta)]$. The exact safety factor is $q = 2.0$.\n\nSpecification of the required outputs:\n- For each case, compute and return two values: the estimated safety factor $q$ (float) and a monotonicity flag (boolean) that is true if and only if $d\\theta'/d\\theta0$ at all grid points.\n- Your program must use radians and produce a single line of output containing the results as a flat, comma-separated list enclosed in square brackets, ordered as $[q_A,\\text{mono}_A,q_B,\\text{mono}_B,q_C,\\text{mono}_C,q_D,\\text{mono}_D]$ with no spaces.",
            "solution": "### Derivation of the Straight-Field-Line Transformation\n\nThe goal is to find a coordinate transformation $\\theta' = \\Theta(\\theta)$ that makes the magnetic field lines straight in the $(\\theta', \\zeta)$ plane. This is achieved by ensuring the field line pitch, defined as the ratio of contravariant magnetic field components, is constant on a flux surface. This constant value is the safety factor, $q$.\n$$\n\\frac{B\\cdot\\nabla\\zeta}{B\\cdot\\nabla\\theta'} = q\n$$\nThe contravariant component $B\\cdot\\nabla\\theta'$ in the new coordinate system can be related to the components in the original system using the chain rule for the directional derivative:\n$$\nB\\cdot\\nabla\\theta' = B\\cdot\\nabla(\\Theta(\\theta)) = (B\\cdot\\nabla\\theta) \\frac{d\\Theta}{d\\theta} = (B\\cdot\\nabla\\theta) \\frac{d\\theta'}{d\\theta}\n$$\nSubstituting this into the definition of the constant pitch, we get:\n$$\nq = \\frac{B\\cdot\\nabla\\zeta}{(B\\cdot\\nabla\\theta) \\frac{d\\theta'}{d\\theta}}\n$$\nThis equation can be rearranged to give a first-order ordinary differential equation for $\\theta'(\\theta)$:\n$$\n\\frac{d\\theta'}{d\\theta} = \\frac{1}{q} \\frac{B\\cdot\\nabla\\zeta(\\theta)}{B\\cdot\\nabla\\theta(\\theta)}\n$$\nAt this point, the safety factor $q$ is still an unknown constant. To determine its value, we enforce the physical requirement that the new coordinate $\\theta'$ must also be a valid periodic angle. This means that as $\\theta$ completes one full poloidal turn from $0$ to $2\\pi$, $\\theta'$ must also advance by exactly $2\\pi$. Mathematically, this is expressed as:\n$$\n\\theta'(2\\pi) - \\theta'(0) = \\int_0^{2\\pi} \\frac{d\\theta'}{d\\theta} d\\theta = 2\\pi\n$$\nSubstituting our expression for $\\frac{d\\theta'}{d\\theta}$ into this integral constraint yields:\n$$\n\\int_0^{2\\pi} \\left( \\frac{1}{q} \\frac{B\\cdot\\nabla\\zeta(\\theta)}{B\\cdot\\nabla\\theta(\\theta)} \\right) d\\theta = 2\\pi\n$$\nSince $q$ is constant with respect to $\\theta$, we can factor it out of the integral:\n$$\n\\frac{1}{q} \\int_0^{2\\pi} \\frac{B\\cdot\\nabla\\zeta(\\theta)}{B\\cdot\\nabla\\theta(\\theta)} d\\theta = 2\\pi\n$$\nSolving for $q$, we find that it is determined self-consistently by the geometry of the magnetic field on the surface:\n$$\nq = \\frac{1}{2\\pi} \\int_0^{2\\pi} \\frac{B\\cdot\\nabla\\zeta(\\theta)}{B\\cdot\\nabla\\theta(\\theta)} d\\theta\n$$\nThis result shows that the safety factor is the flux-surface-average of the local field line pitch, $\\frac{B\\cdot\\nabla\\zeta}{B\\cdot\\nabla\\theta}$, with respect to the original poloidal angle $\\theta$.\n\nWith $q$ determined, we have a complete expression for the derivative of the transformation:\n$$\n\\frac{d\\theta'}{d\\theta} = \\frac{\\frac{B\\cdot\\nabla\\zeta(\\theta)}{B\\cdot\\nabla\\theta(\\theta)}}{\\frac{1}{2\\pi} \\int_0^{2\\pi} \\frac{B\\cdot\\nabla\\zeta(\\tilde\\theta)}{B\\cdot\\nabla\\theta(\\tilde\\theta)} d\\tilde\\theta}\n$$\nThe transformation $\\theta'(\\theta)$ itself is found by integrating this derivative. By fixing the phase, for instance by setting $\\theta'(0) = 0$, we obtain the integral equation for the mapping:\n$$\n\\theta'(\\theta) = \\int_0^\\theta \\frac{1}{q} \\frac{B\\cdot\\nabla\\zeta(\\tilde\\theta)}{B\\cdot\\nabla\\theta(\\tilde\\theta)} d\\tilde\\theta\n$$\nThe strict monotonicity condition, $\\frac{d\\theta'}{d\\theta}  0$, ensures that the mapping is one-to-one. This is satisfied if $q$ and the local pitch $\\frac{B\\cdot\\nabla\\zeta(\\theta)}{B\\cdot\\nabla\\theta(\\theta)}$ have the same sign for all $\\theta$. For typical tokamak and stellarator configurations, both $B\\cdot\\nabla\\theta$ and $B\\cdot\\nabla\\zeta$ are positive, guaranteeing positivity.\n\n### Numerical Algorithm\n\nThe derivation above leads to a direct numerical algorithm. The inputs are discrete samples of $B\\cdot\\nabla\\theta$ and $B\\cdot\\nabla\\zeta$ on a uniform grid $\\theta_j = \\frac{2\\pi j}{N}$ for $j=0, \\dots, N-1$.\n\n1.  **Grid Resolution**: The highest frequency present in the test cases is in Case D, with a $\\cos(20\\theta)$ term. According to the Nyquist-Shannon sampling theorem, we need at least $2$ points per wavelength to resolve this mode, which implies $N  2 \\times 20 = 40$. To ensure high accuracy for the numerical integration, a much finer grid is preferred. We select $N=256$, which is an even integer and provides ample resolution.\n\n2.  **Compute Integrand**: At each grid point $\\theta_j$, compute the local pitch $g_j = \\frac{B\\cdot\\nabla\\zeta(\\theta_j)}{B\\cdot\\nabla\\theta(\\theta_j)}$.\n\n3.  **Compute Safety Factor $q$**: The integral for $q$ is $\\frac{1}{2\\pi}\\int_0^{2\\pi} g(\\theta) d\\theta$. For a periodic function sampled on a uniform grid, the trapezoidal rule is spectrally accurate and provides a highly efficient and convergent quadrature. The trapezoidal rule for a periodic interval is:\n    $$\n    \\int_0^{2\\pi} g(\\theta)d\\theta \\approx \\Delta\\theta \\sum_{j=0}^{N-1} g_j = \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} g_j\n    $$\n    Substituting this into the expression for $q$ gives:\n    $$\n    q \\approx \\frac{1}{2\\pi} \\left( \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} g_j \\right) = \\frac{1}{N} \\sum_{j=0}^{N-1} g_j\n    $$\n    Thus, $q$ is computed as the simple arithmetic mean of the sampled $g_j$ values.\n\n4.  **Compute Derivative $\\frac{d\\theta'}{d\\theta}$**: Using the computed value of $q$, the derivative at each grid point is calculated as:\n    $$\n    \\left(\\frac{d\\theta'}{d\\theta}\\right)_j = \\frac{g_j}{q}\n    $$\n\n5.  **Verify Monotonicity**: The monotonicity condition $\\frac{d\\theta'}{d\\theta}  0$ is checked numerically by verifying that $\\left(\\frac{d\\theta'}{d\\theta}\\right)_j  0$ for all grid points $j=0, \\dots, N-1$. A boolean flag is set to true if all values are strictly positive, and false otherwise.\n\n6.  **Compute Mapping $\\theta'(\\theta)$**: Although not required for the final output, the full algorithm includes computing the mapping $\\theta'(\\theta_k) = \\int_0^{\\theta_k} \\frac{g(\\tilde\\theta)}{q} d\\tilde\\theta$. This can be done numerically using a cumulative integration scheme, such as the cumulative trapezoidal rule, on the grid values of $\\frac{d\\theta'}{d\\theta}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the safety factor and checks for monotonicity for straight-field-line\n    coordinate construction for several test cases in toroidal plasma physics.\n    \"\"\"\n\n    # Uniform grid size. N must be even and large enough to resolve the highest\n    # frequency mode (m=20), requiring N  40. N=256 is chosen for high accuracy.\n    N = 256\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of lambda functions for B.grad(theta) and B.grad(zeta).\n    test_cases = [\n        # Case A: constant pitch\n        (lambda theta: 2.0 * np.ones_like(theta), lambda theta: 10.0 * np.ones_like(theta)),\n        # Case B: moderate poloidal variation in B.grad(zeta)\n        (lambda theta: 1.0 * np.ones_like(theta), lambda theta: 2.5 * (1.0 + 0.3 * np.cos(3.0 * theta))),\n        # Case C: poloidal variation in B.grad(theta)\n        (lambda theta: 1.0 + 0.8 * np.cos(theta), lambda theta: 3.0 * np.ones_like(theta)),\n        # Case D: high-mode poloidal variation\n        (lambda theta: 1.0 * np.ones_like(theta), lambda theta: 2.0 * (1.0 + 0.9 * np.cos(20.0 * theta))),\n    ]\n\n    results = []\n    \n    # Create the uniform poloidal angle grid in radians.\n    # endpoint=False is crucial for periodic functions, as theta=2*pi is identified with theta=0.\n    theta_grid = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n    for b_grad_theta_func, b_grad_zeta_func in test_cases:\n        # Step 1: Evaluate the contravariant field components on the grid.\n        B_grad_theta = b_grad_theta_func(theta_grid)\n        B_grad_zeta = b_grad_zeta_func(theta_grid)\n\n        # Step 2: Compute the local field line pitch g(theta).\n        g_theta = B_grad_zeta / B_grad_theta\n\n        # Step 3: Compute the safety factor q.\n        # For a periodic function on a uniform grid, the trapezoidal rule for the integral\n        # in the definition of q simplifies to taking the arithmetic mean of the integrand.\n        # q = (1/(2*pi)) * integral(g(theta) dtheta) from 0 to 2*pi\n        #      ~ (1/(2*pi)) * sum(g_j * delta_theta) = (1/(2*pi)) * sum(g_j * 2*pi/N) = mean(g_j)\n        q = np.mean(g_theta)\n\n        # Step 4: Compute the derivative of the new poloidal angle, d(theta')/d(theta).\n        d_theta_prime_d_theta = g_theta / q\n\n        # Step 5: Verify monotonicity.\n        # The transformation is monotonic if d(theta')/d(theta) > 0 for all theta.\n        monotonicity_flag = np.all(d_theta_prime_d_theta > 0)\n\n        # Append the results for this case to the list.\n        results.append(q)\n        results.append(monotonicity_flag)\n\n    # Final print statement in the exact required format.\n    # Example format: [q_A,mono_A,q_B,mono_B,...]\n    # The default string conversion of a boolean is 'True' or 'False' (capitalized).\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}