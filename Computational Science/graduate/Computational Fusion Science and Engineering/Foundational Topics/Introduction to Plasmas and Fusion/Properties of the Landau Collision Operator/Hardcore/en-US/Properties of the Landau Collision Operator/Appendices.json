{
    "hands_on_practices": [
        {
            "introduction": "The Landau collision operator describes the evolution of a particle distribution through a series of small-angle Coulomb collisions. A key component is the pitch-angle scattering operator, which governs how particle velocities are deflected relative to the magnetic field. This exercise  explores the fundamental structure of this operator by representing it in the basis of Legendre polynomials, a technique central to transport theory. By finding the matrix elements of the operator in this basis, you will uncover its eigenvalues and demonstrate why it is diagonal, a property that greatly simplifies both analytical and computational models.",
            "id": "4033086",
            "problem": "Consider a single-species magnetized plasma in the weakly coupled, small-angle Coulomb collision regime, so that the slow collisional relaxation of the velocity-space distribution function is governed by the Landau form of the Fokker–Planck (FP) operator. Under the assumption that energy diffusion and dynamical friction are negligible compared to pitch-angle scattering at fixed speed, the pitch-angle scattering operator acting on the distribution function can be modeled by an angular diffusion operator at fixed speed $v$, written as $C_{\\mathrm{pa}}[f](v,\\xi)=\\nu_{D}(v)\\,\\frac{\\partial}{\\partial \\xi}\\!\\left[\\left(1-\\xi^{2}\\right)\\frac{\\partial f(v,\\xi)}{\\partial \\xi}\\right]$, where $\\xi=\\cos\\theta$ is the pitch-angle cosine and $\\nu_{D}(v)$ is the deflection frequency arising from Coulomb scattering on a stationary Maxwellian background. Assume $\\nu_{D}(v)$ is a positive, smooth function of $v$.\n\nExpand the distribution function in Legendre polynomials $P_{l}(\\xi)$ as $f(v,\\xi)=\\sum_{l=0}^{\\infty}f_{l}(v)\\,P_{l}(\\xi)$ with the standard orthogonality $\\int_{-1}^{1}P_{l}(\\xi)P_{l'}(\\xi)\\,d\\xi=\\frac{2}{2l+1}\\,\\delta_{ll'}$. Define the spectral projection of $C_{\\mathrm{pa}}[f]$ onto the $l$-th Legendre mode as $(C_{\\mathrm{pa}}f)_{l}(v)\\equiv\\frac{2l+1}{2}\\int_{-1}^{1}P_{l}(\\xi)\\,C_{\\mathrm{pa}}[f](v,\\xi)\\,d\\xi$, and define the matrix elements $M_{ll'}(v)$ by $(C_{\\mathrm{pa}}f)_{l}(v)=\\sum_{l'=0}^{\\infty}M_{ll'}(v)\\,f_{l'}(v)$.\n\nStarting from the above physical modeling assumptions and the fundamental properties of Legendre polynomials implied by rotational symmetry on the unit sphere, derive the closed-form expression for the matrix elements $M_{ll'}(v)$ as a function of $l$, $l'$, and $v$. Your answer must be a single closed-form analytic expression. No numerical evaluation is required and no rounding is permitted. Express your final answer without units.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- **Pitch-Angle Scattering Operator**: $C_{\\mathrm{pa}}[f](v,\\xi)=\\nu_{D}(v)\\,\\frac{\\partial}{\\partial \\xi}\\!\\left[\\left(1-\\xi^{2}\\right)\\frac{\\partial f(v,\\xi)}{\\partial \\xi}\\right]$, where $\\xi = \\cos\\theta$.\n- **Deflection Frequency**: $\\nu_{D}(v)$ is a positive, smooth function of speed $v$.\n- **Distribution Function Expansion**: $f(v,\\xi)=\\sum_{l=0}^{\\infty}f_{l}(v)\\,P_{l}(\\xi)$, where $P_l(\\xi)$ are the Legendre polynomials.\n- **Orthogonality of Legendre Polynomials**: $\\int_{-1}^{1}P_{l}(\\xi)P_{l'}(\\xi)\\,d\\xi=\\frac{2}{2l+1}\\,\\delta_{ll'}$.\n- **Spectral Projection Definition**: $(C_{\\mathrm{pa}}f)_{l}(v)\\equiv\\frac{2l+1}{2}\\int_{-1}^{1}P_{l}(\\xi)\\,C_{\\mathrm{pa}}[f](v,\\xi)\\,d\\xi$.\n- **Matrix Element Definition**: $(C_{\\mathrm{pa}}f)_{l}(v)=\\sum_{l'=0}^{\\infty}M_{ll'}(v)\\,f_{l'}(v)$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem describes the pitch-angle scattering component of the Landau-Fokker-Planck collision operator, a standard and fundamental model in plasma kinetic theory. The use of Legendre polynomials to analyze such an operator is a well-established technique in transport theory. The model is a valid and widely used approximation.\n- **Well-Posedness**: The problem is well-posed. It asks for the matrix elements of a linear operator in a given complete basis. All necessary definitions and mathematical properties (operator form, basis expansion, orthogonality) are provided, allowing for a unique solution to be derived.\n- **Objectivity**: The problem is stated using precise mathematical language, free from ambiguity or subjective claims.\n\n### Step 3: Verdict and Action\nThe problem is scientifically sound, self-contained, and well-posed. It is deemed **valid**. The derivation of the solution can proceed.\n\nOur objective is to find the closed-form expression for the matrix elements $M_{ll'}(v)$. We begin by inserting the Legendre expansion of the distribution function $f(v,\\xi)$ into the expression for the pitch-angle scattering operator $C_{\\mathrm{pa}}[f]$.\nThe speed $v$ acts as a parameter in the operations involving the pitch-angle cosine $\\xi$.\n\n$C_{\\mathrm{pa}}[f](v,\\xi) = \\nu_{D}(v)\\,\\frac{\\partial}{\\partial \\xi}\\!\\left[\\left(1-\\xi^{2}\\right)\\frac{\\partial}{\\partial \\xi} \\left( \\sum_{l'=0}^{\\infty}f_{l'}(v)\\,P_{l'}(\\xi) \\right) \\right]$.\n\nSince the summation and the partial derivatives with respect to $\\xi$ are linear operations, and the coefficients $f_{l'}(v)$ are independent of $\\xi$, we can interchange the order of summation and differentiation:\n\n$C_{\\mathrm{pa}}[f](v,\\xi) = \\nu_{D}(v) \\sum_{l'=0}^{\\infty} f_{l'}(v) \\left( \\frac{d}{d\\xi}\\left[\\left(1-\\xi^{2}\\right)\\frac{d P_{l'}(\\xi)}{d\\xi}\\right] \\right)$.\n\nThe expression within the parentheses is the Legendre differential operator acting on the Legendre polynomial $P_{l'}(\\xi)$. The Legendre polynomials are, by definition, the eigenfunctions of this operator. The Legendre differential equation is:\n$\\frac{d}{d\\xi}\\left[\\left(1-\\xi^{2}\\right)\\frac{d y}{d\\xi}\\right] + l(l+1)y = 0$.\n\nFor $y = P_{l'}(\\xi)$, this gives the eigenvalue relation:\n$\\frac{d}{d\\xi}\\left[\\left(1-\\xi^{2}\\right)\\frac{d P_{l'}(\\xi)}{d\\xi}\\right] = -l'(l'+1)P_{l'}(\\xi)$.\n\nSubstituting this result back into the expression for $C_{\\mathrm{pa}}[f](v,\\xi)$, we find:\n\n$C_{\\mathrm{pa}}[f](v,\\xi) = \\nu_{D}(v) \\sum_{l'=0}^{\\infty} f_{l'}(v) [-l'(l'+1)P_{l'}(\\xi)] = -\\nu_{D}(v) \\sum_{l'=0}^{\\infty} l'(l'+1)f_{l'}(v)P_{l'}(\\xi)$.\n\nThis shows that the action of the operator $C_{\\mathrm{pa}}$ on the expansion of $f$ results in another series of Legendre polynomials, where each coefficient $f_{l'}(v)$ is simply multiplied by a factor of $-\\nu_{D}(v)l'(l'+1)$.\n\nNext, we compute the spectral projection $(C_{\\mathrm{pa}}f)_{l}(v)$ using its definition:\n$(C_{\\mathrm{pa}}f)_{l}(v) = \\frac{2l+1}{2}\\int_{-1}^{1}P_{l}(\\xi)\\,C_{\\mathrm{pa}}[f](v,\\xi)\\,d\\xi$.\n\nSubstitute the series form of $C_{\\mathrm{pa}}[f](v,\\xi)$ into this integral:\n$(C_{\\mathrm{pa}}f)_{l}(v) = \\frac{2l+1}{2}\\int_{-1}^{1}P_{l}(\\xi)\\left( -\\nu_{D}(v) \\sum_{l'=0}^{\\infty} l'(l'+1)f_{l'}(v)P_{l'}(\\xi) \\right)\\,d\\xi$.\n\nThe terms $-\\nu_{D}(v)$, $l'(l'+1)$, and $f_{l'}(v)$ are constant with respect to the integration variable $\\xi$. We can thus move them, along with the summation, outside the integral:\n$(C_{\\mathrm{pa}}f)_{l}(v) = -\\frac{2l+1}{2} \\nu_{D}(v) \\sum_{l'=0}^{\\infty} l'(l'+1)f_{l'}(v) \\int_{-1}^{1} P_{l}(\\xi)P_{l'}(\\xi) \\,d\\xi$.\n\nNow, we use the orthogonality property of the Legendre polynomials, $\\int_{-1}^{1}P_{l}(\\xi)P_{l'}(\\xi)\\,d\\xi=\\frac{2}{2l+1}\\,\\delta_{ll'}$, where $\\delta_{ll'}$ is the Kronecker delta.\n\n$(C_{\\mathrm{pa}}f)_{l}(v) = -\\frac{2l+1}{2} \\nu_{D}(v) \\sum_{l'=0}^{\\infty} l'(l'+1)f_{l'}(v) \\left( \\frac{2}{2l'+1}\\,\\delta_{ll'} \\right)$.\n\nThe Kronecker delta $\\delta_{ll'}$ is zero for all $l' \\neq l$ and one for $l'=l$. This property causes the infinite sum to collapse to a single term corresponding to $l'=l$. In this term, we must replace every instance of $l'$ with $l$.\n\n$(C_{\\mathrm{pa}}f)_{l}(v) = -\\frac{2l+1}{2} \\nu_{D}(v) \\left( l(l+1)f_{l}(v) \\frac{2}{2l+1} \\right)$.\n\nThe factors of $\\frac{2l+1}{2}$ and $\\frac{2}{2l+1}$ cancel out, simplifying the expression to:\n$(C_{\\mathrm{pa}}f)_{l}(v) = -l(l+1)\\nu_{D}(v)f_{l}(v)$.\n\nFinally, we compare this result with the definition of the matrix elements $M_{ll'}(v)$:\n$(C_{\\mathrm{pa}}f)_{l}(v)=\\sum_{l'=0}^{\\infty}M_{ll'}(v)\\,f_{l'}(v)$.\n\nWe have derived that $(C_{\\mathrm{pa}}f)_{l}(v)$ is proportional only to $f_l(v)$. To make the comparison explicit, we can write our result using a Kronecker delta:\n$-l(l+1)\\nu_{D}(v)f_{l}(v) = \\sum_{l'=0}^{\\infty} [-l(l+1)\\nu_{D}(v)\\delta_{ll'}] f_{l'}(v)$.\nNote that we can replace $l$ inside the brackets with $l'$ since the term is non-zero only when $l'=l$:\n$\\sum_{l'=0}^{\\infty} [-l'(l'+1)\\nu_{D}(v)\\delta_{ll'}] f_{l'}(v)$. However, for identifying $M_{ll'}$, the first form is more direct.\n\nBy comparing the coefficients of $f_{l'}(v)$ in the two expressions for $(C_{\\mathrm{pa}}f)_{l}(v)$, we identify the matrix elements:\n$\\sum_{l'=0}^{\\infty}M_{ll'}(v)\\,f_{l'}(v) = \\sum_{l'=0}^{\\infty} [-l(l+1)\\nu_{D}(v)\\delta_{ll'}] f_{l'}(v)$.\n\nThis relation must hold for any arbitrary set of coefficients $f_{l'}(v)$, which implies that the terms inside the sums must be equal for each $l'$. This gives the closed-form expression for the matrix elements:\n$M_{ll'}(v) = -l(l+1)\\nu_{D}(v)\\delta_{ll'}$.\n\nThis result shows that the pitch-angle scattering operator $C_{\\mathrm{pa}}$ is diagonal in the basis of Legendre polynomials, with the eigenvalues being $-l(l+1)\\nu_{D}(v)$.\nFor $l=0$, $M_{0l'}(v) = 0$, which reflects the physical principle of particle number conservation by the collision operator, as the $l=0$ mode is proportional to the particle density at a given speed.",
            "answer": "$$\\boxed{-l(l+1)\\nu_{D}(v)\\delta_{ll'}}$$"
        },
        {
            "introduction": "The coefficients of the Landau operator are defined by Rosenbluth potentials, which are themselves solutions to Poisson-like equations in velocity space. Solving these equations is a critical first step in many kinetic simulations. This practical exercise  guides you through the process of numerically solving for the isotropic Rosenbluth potentials using the finite-difference method. You will transform the continuous differential equations into a discrete linear system, implement appropriate boundary conditions, and verify your solver's accuracy, gaining foundational skills in computational physics.",
            "id": "4033041",
            "problem": "Consider the isotropic Rosenbluth potentials of the Landau collision operator for a background species with distribution function $f_b(v)$ in velocity space. In the isotropic case, the Rosenbluth potentials $H_b(v)$ and $G_b(v)$ satisfy the velocity-space Poisson problems on a bounded spherical domain $v \\in [0, V_{\\max}]$:\n$$\n\\nabla_v^2 H_b(v) = -4\\pi f_b(v), \\quad \\nabla_v^2 G_b(v) = H_b(v),\n$$\nwhere the Laplacian in spherical symmetry reduces to\n$$\n\\nabla_v^2 \\phi(v) \\equiv \\frac{1}{v^2}\\frac{d}{dv}\\!\\left(v^2 \\frac{d\\phi}{dv}\\right),\n$$\nfor any sufficiently smooth isotropic scalar field $\\phi(v)$. The variables $v$, $V_{\\max}$, $H_b$, $G_b$, and $f_b$ are dimensionless, with velocity normalized by the species thermal speed so that all numerical outputs are dimensionless.\n\nImpose the following boundary conditions:\n- Regularity at $v=0$: the physical requirement of finite potentials implies $\\frac{dH_b}{dv}(0)=0$ and $\\frac{dG_b}{dv}(0)=0$.\n- At $v=V_{\\max}$, use either Dirichlet boundary conditions $H_b(V_{\\max})=0$, $G_b(V_{\\max})=0$, or homogeneous Robin boundary conditions $\\frac{dH_b}{dv}(V_{\\max})+\\alpha H_b(V_{\\max})=0$ and $\\frac{dG_b}{dv}(V_{\\max})+\\alpha G_b(V_{\\max})=0$, with a given positive parameter $\\alpha$.\n\nStarting from these definitions and boundary conditions, derive second-order accurate, finite-difference discrete equations on a uniform grid $v_i = i\\,\\Delta v$, $i=0,1,\\dots,N-1$, where $\\Delta v = V_{\\max}/(N-1)$, for both $H_b$ and $G_b$:\n- For interior points $i=1,2,\\dots,N-2$, discretize the operator in conservative divergence form,\n$$\n\\left(\\nabla_v^2 \\phi\\right)_i \\approx \\frac{1}{v_i^2}\\,\\frac{1}{\\Delta v}\\left[ v_{i+\\frac{1}{2}}^2\\,\\frac{\\phi_{i+1}-\\phi_i}{\\Delta v} - v_{i-\\frac{1}{2}}^2\\,\\frac{\\phi_i-\\phi_{i-1}}{\\Delta v} \\right],\n$$\nwith $v_{i\\pm \\frac{1}{2}} \\equiv v_i \\pm \\frac{\\Delta v}{2}$.\n- At $i=0$, enforce regularity via the $v\\to 0$ limit,\n$$\n\\left(\\nabla_v^2 \\phi\\right)_0 \\approx \\frac{6}{\\Delta v^2}\\left(\\phi_1 - \\phi_0\\right),\n$$\nwhich follows from the limit $v\\to 0$ of $\\nabla_v^2 \\phi = \\frac{1}{v^2}\\frac{d}{dv}(v^2 \\phi')$ and the symmetry condition $\\phi'(0)=0$.\n- At $i=N-1$, impose either Dirichlet via $\\phi_{N-1}=0$ or homogeneous Robin via\n$$\n\\frac{\\phi_{N-1}-\\phi_{N-2}}{\\Delta v} + \\alpha\\,\\phi_{N-1} = 0.\n$$\n\nForm the discrete linear system $L\\,\\mathbf{H} = \\mathbf{b}_H$ for $\\mathbf{H} \\equiv \\{H_{b,i}\\}$ and $L\\,\\mathbf{G} = \\mathbf{b}_G$ for $\\mathbf{G} \\equiv \\{G_{b,i}\\}$, where $L$ encodes the above discretization of $\\nabla_v^2$, $\\mathbf{b}_H$ encodes $-4\\pi f_b(v_i)$ with boundary-row modifications consistent with the chosen boundary condition, and $\\mathbf{b}_G$ encodes $H_{b,i}$ with the same boundary-row modifications. Your program must assemble $L$, solve both systems, and report quantitative diagnostics.\n\nTest suite. Use the following parameter sets to exercise different aspects of the solver; all velocities and outputs are dimensionless:\n- Case $\\mathrm{A}$ (happy path): $N=101$, $V_{\\max}=4$, Dirichlet at $v=V_{\\max}$, $f_b(v)=\\exp(-v^2)$.\n- Case $\\mathrm{B}$ (Robin boundary): $N=51$, $V_{\\max}=3$, Robin at $v=V_{\\max}$ with $\\alpha=1$, $f_b(v)=v^2\\exp(-v)$.\n- Case $\\mathrm{C}$ (analytic verification): $N=81$, $V_{\\max}=2.5$, Dirichlet at $v=V_{\\max}$, constant $f_b(v)=c$ with $c=\\frac{1}{4\\pi}$ so that the source $-4\\pi f_b(v)$ equals $-1$. In this case, the exact solutions are\n$$\nH_b(v)=\\frac{4\\pi c}{6}\\left(V_{\\max}^2 - v^2\\right),\\quad\nG_b(v)=\\frac{4\\pi c}{6}\\left(\\frac{v^2}{6}V_{\\max}^2 - \\frac{v^4}{20} - \\frac{V_{\\max}^4}{6} + \\frac{V_{\\max}^4}{20}\\right),\n$$\nobtained by integrating the radial Poisson problem with regularity at $v=0$ and Dirichlet at $v=V_{\\max}$.\n- Case $\\mathrm{D}$ (coarse-grid edge case): $N=3$, $V_{\\max}=1$, Dirichlet at $v=V_{\\max}$, $f_b(v)=\\exp(-v)$.\n\nFor Cases $\\mathrm{A}$, $\\mathrm{B}$, and $\\mathrm{D}$, compute the maximum absolute discrete residuals\n$$\nR_H \\equiv \\max_i \\left| (L\\mathbf{H} - \\mathbf{b}_H)_i \\right|,\\quad R_G \\equiv \\max_i \\left| (L\\mathbf{G} - \\mathbf{b}_G)_i \\right|.\n$$\nFor Case $\\mathrm{C}$, compute the maximum absolute errors relative to the analytic solutions,\n$$\nE_H \\equiv \\max_i \\left| H_{b,i} - H_b^{\\mathrm{exact}}(v_i) \\right|,\\quad E_G \\equiv \\max_i \\left| G_{b,i} - G_b^{\\mathrm{exact}}(v_i) \\right|.\n$$\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[R_H^{\\mathrm{A}}, R_G^{\\mathrm{A}}, R_H^{\\mathrm{B}}, R_G^{\\mathrm{B}}, E_H^{\\mathrm{C}}, E_G^{\\mathrm{C}}, R_H^{\\mathrm{D}}, R_G^{\\mathrm{D}}].\n$$\nAll entries must be decimal numbers. Angles are not involved, so no angle unit is required. No physical units appear because of the chosen normalization.",
            "solution": "The problem requires the numerical solution of a pair of coupled Poisson-like equations in one spatial dimension (velocity magnitude $v$) for the isotropic Rosenbluth potentials, $H_b(v)$ and $G_b(v)$. These potentials are central to the evaluation of the Landau collision operator in plasma physics. The governing equations are:\n$$\n\\nabla_v^2 H_b(v) = -4\\pi f_b(v)\n$$\n$$\n\\nabla_v^2 G_b(v) = H_b(v)\n$$\non a bounded domain $v \\in [0, V_{\\max}]$. Due to spherical symmetry, the Laplacian operator simplifies to $\\nabla_v^2 \\phi(v) = \\frac{1}{v^2}\\frac{d}{dv}(v^2 \\frac{d\\phi}{dv})$.\n\nThe solution strategy involves discretizing these partial differential equations using a finite-difference method on a uniform grid, which transforms the differential equations into a system of linear algebraic equations, $L\\mathbf{\\phi} = \\mathbf{b}$, where $\\mathbf{\\phi}$ represents the solution vector on the grid points. This system is then solved for $\\mathbf{H}$ (the vector of $H_{b,i}$ values) and subsequently for $\\mathbf{G}$ (the vector of $G_{b,i}$ values).\n\nFirst, we establish the discrete domain. A uniform grid in velocity $v$ is defined as $v_i = i \\cdot \\Delta v$ for $i = 0, 1, \\dots, N-1$, where the grid spacing is $\\Delta v = V_{\\max} / (N-1)$. The solution vectors $\\mathbf{H}$ and $\\mathbf{G}$ will have $N$ components, representing the values of the potentials at these grid points.\n\nThe core of the method is the construction of the discrete Laplacian matrix, $L$. This $N \\times N$ matrix represents the linear operator $\\nabla_v^2$. We construct it row by row, with each row corresponding to a grid point $v_i$.\n\nFor an interior grid point $v_i$ where $i \\in \\{1, 2, \\dots, N-2\\}$, the problem provides a second-order accurate conservative finite-difference approximation:\n$$\n(\\nabla_v^2 \\phi)_i \\approx \\frac{1}{v_i^2 \\Delta v^2} \\left[ v_{i+\\frac{1}{2}}^2 (\\phi_{i+1} - \\phi_i) - v_{i-\\frac{1}{2}}^2 (\\phi_i - \\phi_{i-1}) \\right]\n$$\nwhere $v_{i\\pm\\frac{1}{2}} = v_i \\pm \\frac{\\Delta v}{2}$. Rearranging this into the form of a matrix-vector product $(L\\mathbf{\\phi})_i$, we identify the non-zero elements in the $i$-th row of $L$:\n$$\nL_{i, i-1} = \\frac{v_{i-\\frac{1}{2}}^2}{v_i^2 \\Delta v^2}\n$$\n$$\nL_{i, i} = -\\frac{v_{i+\\frac{1}{2}}^2 + v_{i-\\frac{1}{2}}^2}{v_i^2 \\Delta v^2}\n$$\n$$\nL_{i, i+1} = \\frac{v_{i+\\frac{1}{2}}^2}{v_i^2 \\Delta v^2}\n$$\nThis defines the tridiagonal structure of the matrix for the interior points.\n\nAt the origin, $v_0=0$, the interior formula is singular. The physical regularity condition, $\\frac{d\\phi}{dv}(0)=0$, leads to a specific form for the Laplacian in the limit $v \\to 0$. The problem provides the corresponding second-order accurate discretization:\n$$\n(\\nabla_v^2 \\phi)_0 \\approx \\frac{6}{\\Delta v^2}(\\phi_1 - \\phi_0)\n$$\nThis gives the elements for the first row ($i=0$) of the matrix $L$:\n$$\nL_{0, 0} = -\\frac{6}{\\Delta v^2}\n$$\n$$\nL_{0, 1} = \\frac{6}{\\Delta v^2}\n$$\n\nAt the outer boundary, $v_{N-1} = V_{\\max}$, the PDE is replaced by a boundary condition. This means the last row ($i=N-1$) of the matrix $L$ and the corresponding element of the right-hand-side vector $\\mathbf{b}$ are determined by the specified boundary condition.\nFor a Dirichlet condition, $\\phi(V_{\\max}) = 0$, we enforce $\\phi_{N-1}=0$. The equation for the last row becomes trivial:\n$$\nL_{N-1, N-1} = 1, \\quad \\text{and} \\quad b_{N-1} = 0\n$$\nAll other elements $L_{N-1, j}$ for $j \\neq N-1$ are zero.\nFor a homogeneous Robin condition, $\\frac{d\\phi}{dv}(V_{\\max}) + \\alpha \\phi(V_{\\max}) = 0$, we use the provided first-order backward-difference approximation:\n$$\n\\frac{\\phi_{N-1} - \\phi_{N-2}}{\\Delta v} + \\alpha \\phi_{N-1} = 0\n$$\nThis translates to the following matrix elements for the last row:\n$$\nL_{N-1, N-2} = -\\frac{1}{\\Delta v}\n$$\n$$\nL_{N-1, N-1} = \\frac{1}{\\Delta v} + \\alpha\n$$\nThe right-hand-side element is $b_{N-1} = 0$.\n\nWith the matrix $L$ fully defined, we construct the right-hand-side vectors $\\mathbf{b}_H$ and $\\mathbf{b}_G$.\nFor the potential $H_b$, the source term is $-4\\pi f_b(v)$. The vector $\\mathbf{b}_H$ is constructed such that for $i=0, \\dots, N-2$, its elements are $b_{H,i} = -4\\pi f_b(v_i)$. The last element, $b_{H, N-1}$, is set to $0$ to be consistent with the boundary condition modifications made to the last row of $L$.\nWe then solve the linear system $L\\mathbf{H} = \\mathbf{b}_H$ to find the discrete potential $\\mathbf{H} = \\{H_{b,i}\\}$.\n\nNext, we solve for $G_b$. The source term for the $G_b$ equation is $H_b(v)$. We use the just-computed numerical solution $\\mathbf{H}$ as the source. The right-hand-side vector $\\mathbf{b}_G$ is constructed such that $b_{G,i} = H_{b,i}$ for $i=0, \\dots, N-2$. As before, $b_{G, N-1}$ is set to $0$. We then solve the second linear system, $L\\mathbf{G} = \\mathbf{b}_G$, to find the discrete potential $\\mathbf{G} = \\{G_{b,i}\\}$.\n\nFinally, the required diagnostics are computed. For cases A, B, and D, the maximum absolute discrete residual is calculated as $R = \\max_i |(L\\mathbf{\\phi} - \\mathbf{b})_i|$ for both $\\mathbf{H}$ and $\\mathbf{G}$, using the matrix $L$ and vectors $\\mathbf{b}_H$ and $\\mathbf{b}_G$ from the linear solver. This measures the numerical accuracy of the linear solve. For case C, where an analytic solution is known, the diagnostic is the maximum absolute error, $E = \\max_i |\\phi_i - \\phi_{\\text{exact}}(v_i)|$, which measures the discretization error of the finite-difference scheme. The provided code implements this entire procedure for each of the specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n\n    def solve_case(N, V_max, bc_type, f_b, alpha=None, is_analytic_case=False):\n        \"\"\"\n        Solves the Rosenbluth potential equations for a single test case.\n\n        Args:\n            N (int): Number of grid points.\n            V_max (float): Maximum velocity in the domain.\n            bc_type (str): Type of boundary condition, 'dirichlet' or 'robin'.\n            f_b (callable): Background distribution function f_b(v).\n            alpha (float, optional): Parameter for Robin boundary condition.\n            is_analytic_case (bool): Flag for Case C to compute error instead of residual.\n\n        Returns:\n            tuple: A pair of diagnostic values (R_H, R_G) or (E_H, E_G).\n        \"\"\"\n        # 1. Setup grid\n        dv = V_max / (N - 1)\n        v = np.linspace(0, V_max, N)\n\n        # 2. Assemble the discrete Laplacian matrix L\n        L = np.zeros((N, N))\n\n        # Row i=0 (origin)\n        if N > 1:\n            L[0, 0] = -6.0 / dv**2\n            L[0, 1] = 6.0 / dv**2\n\n        # Rows i=1 to N-2 (interior)\n        for i in range(1, N - 1):\n            v_i = v[i]\n            v_minus_half = v_i - dv / 2.0\n            v_plus_half = v_i + dv / 2.0\n            \n            coeff = 1.0 / (v_i**2 * dv**2)\n            \n            L[i, i - 1] = coeff * v_minus_half**2\n            L[i, i + 1] = coeff * v_plus_half**2\n            L[i, i] = -coeff * (v_minus_half**2 + v_plus_half**2)\n\n        # Row i=N-1 (outer boundary)\n        if N > 0:\n            if bc_type == 'dirichlet':\n                L[N - 1, N - 1] = 1.0\n            elif bc_type == 'robin':\n                if alpha is None:\n                    raise ValueError(\"alpha must be provided for Robin boundary condition\")\n                if N > 1:\n                    L[N - 1, N - 2] = -1.0 / dv\n                L[N - 1, N - 1] = 1.0 / dv + alpha\n\n        # 3. Solve for H_b\n        f_b_vals = f_b(v)\n        b_H = -4.0 * np.pi * f_b_vals\n        \n        # Apply boundary conditions to the right-hand-side vector\n        if N > 0:\n            if bc_type == 'dirichlet':\n                b_H[N - 1] = 0.0\n            elif bc_type == 'robin':\n                b_H[N - 1] = 0.0\n\n        H = np.linalg.solve(L, b_H)\n\n        # 4. Solve for G_b\n        b_G = H.copy()  # Source for G is the solution H\n        \n        # Apply boundary conditions to the right-hand-side vector\n        if N > 0:\n            if bc_type == 'dirichlet':\n                b_G[N - 1] = 0.0\n            elif bc_type == 'robin':\n                b_G[N - 1] = 0.0\n\n        G = np.linalg.solve(L, b_G)\n\n        # 5. Calculate diagnostics\n        if is_analytic_case:\n            # Case C: Compute max absolute error against analytic solution\n            # With c = 1/(4*pi), the term 4*pi*c becomes 1.\n            H_exact = (1.0/6.0) * (V_max**2 - v**2)\n            G_exact = (V_max**2 * v**2 / 36.0) - (v**4 / 120.0) - (7.0 * V_max**4 / 360.0)\n            \n            E_H = np.max(np.abs(H - H_exact))\n            E_G = np.max(np.abs(G - G_exact))\n            return E_H, E_G\n        else:\n            # Cases A, B, D: Compute max absolute discrete residual\n            R_H = np.max(np.abs(np.dot(L, H) - b_H))\n            R_G = np.max(np.abs(np.dot(L, G) - b_G))\n            return R_H, R_G\n\n    # Define test cases from the problem statement.\n    test_cases = [\n        {'id': 'A', 'N': 101, 'V_max': 4.0, 'bc_type': 'dirichlet', 'f_b': lambda v: np.exp(-v**2), 'analytic': False},\n        {'id': 'B', 'N': 51, 'V_max': 3.0, 'bc_type': 'robin', 'f_b': lambda v: v**2 * np.exp(-v), 'alpha': 1.0, 'analytic': False},\n        {'id': 'C', 'N': 81, 'V_max': 2.5, 'bc_type': 'dirichlet', 'f_b': lambda v: np.full_like(v, 1.0 / (4.0 * np.pi)), 'analytic': True},\n        {'id': 'D', 'N': 3, 'V_max': 1.0, 'bc_type': 'dirichlet', 'f_b': lambda v: np.exp(-v), 'analytic': False}\n    ]\n\n    results = []\n    for case in test_cases:\n        diag1, diag2 = solve_case(\n            N=case['N'],\n            V_max=case['V_max'],\n            bc_type=case['bc_type'],\n            f_b=case['f_b'],\n            alpha=case.get('alpha'),\n            is_analytic_case=case['analytic']\n        )\n        results.extend([diag1, diag2])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A hallmark of a robust numerical scheme is its ability to respect the fundamental conservation laws of the underlying physics. While the continuous Landau operator perfectly conserves particle number, momentum, and energy, a naive discretization can introduce artificial sources or sinks of these quantities. This advanced practice  tackles this challenge head-on by having you implement a flux-correction algorithm. You will learn to diagnose the non-conservation \"defects\" of a discrete operator and construct a correction that enforces the discrete conservation of momentum and energy exactly, a crucial technique for ensuring the long-term physical fidelity of simulations.",
            "id": "4033037",
            "problem": "Consider the Landau collision operator, which, for binary Coulomb collisions in a plasma, conserves the collision invariants of mass, momentum, and energy. In a one-dimensional velocity-magnitude discretization suitable for isotropic velocity-space modeling, a conservative finite-volume form represents the collision operator acting on a distribution function as a divergence of a flux in velocity space. Let the velocity grid be uniform on the interval $[0, V_{\\max}]$ with $N$ cells, cell centers at $v_i \\in (0, V_{\\max})$ for $i = 0, 1, \\dots, N-1$, uniform spacing $\\Delta v = V_{\\max}/N$, and faces at $v_f = f \\, \\Delta v$ for $f = 0, 1, \\dots, N$. Let the discrete operator on cell $i$ be \n$$\nL_i = \\frac{F_{i+1} - F_{i}}{\\Delta v},\n$$\nwhere $F_f$ is the numerical flux at face $f$ and face indices $i$ denote the left face of cell $i$.\n\nYou are to implement a flux-based discrete collision operator whose flux is defined by a drift-diffusion form parameterized by smooth, positive coefficients representative of the isotropic limit of the Landau operator. Specifically, define the interior face flux for $f = 1, 2, \\dots, N-1$ as\n$$\nF_f = - D(v_f) \\left.\\frac{\\partial f}{\\partial v}\\right|_{f} + A(v_f) \\, f|_{f},\n$$\nwith face-centered diffusion and drag coefficients \n$$\nD(v) = \\nu \\left(1 + \\left(\\frac{v}{v_t}\\right)^2\\right), \\quad A(v) = \\mu \\, v,\n$$\nand with discrete approximations \n$$\n\\left.\\frac{\\partial f}{\\partial v}\\right|_{f} = \\frac{f_i - f_{i-1}}{\\Delta v}, \\quad f|_{f} = \\frac{f_i + f_{i-1}}{2},\n$$\nwhere $i = f$ is the index of the right cell adjacent to face $f$ and $i-1$ is the left cell. Impose zero-flux boundary conditions $F_0 = 0$ and $F_N = 0$. All variables are dimensionless.\n\nAlthough the continuous Landau collision operator exactly conserves momentum and energy, a straightforward discretization may not preserve the first two moments exactly. You must construct a discrete flux correction whose effect is to enforce exact vanishing of the discrete momentum and energy moments of the operator. Define the discrete momentum and energy moment defects of the operator as\n$$\nM_1 = \\sum_{i=0}^{N-1} v_i \\, L_i \\, \\Delta v, \\quad M_2 = \\sum_{i=0}^{N-1} v_i^2 \\, L_i \\, \\Delta v.\n$$\nUsing only the structure of the discrete divergence and the collision invariants, design a correction to the interior face fluxes that is a linear combination of two basis fluxes aligned with the discrete gradients of $v$ and $v^2$ across faces. Determine the coefficients of this linear combination by enforcing $M_1 = 0$ and $M_2 = 0$ exactly in the corrected operator. Keep the boundary fluxes at $f = 0$ and $f = N$ equal to zero after correction.\n\nImplement the following algorithmic steps in a single program:\n1. Construct the uniform velocity grid and the distribution function on cell centers according to the case specification.\n2. Compute the raw fluxes on interior faces using the finite-volume approximations and set boundary fluxes to zero.\n3. Compute the raw operator $L_i$ and the raw defects $M_1$ and $M_2$.\n4. Build two discrete face-aligned basis fluxes using the differences of $v$ and $v^2$ across adjacent cell centers and determine the coefficients of their linear combination by solving the resulting $2 \\times 2$ linear system that imposes the vanishing of the corrected $M_1$ and $M_2$.\n5. Apply the correction to interior face fluxes, recompute $L_i$, and evaluate the corrected defects $M_1$ and $M_2$.\n\nYour program must evaluate the following test suite of parameter sets. In all cases, $v_i$ are the cell centers $v_i = (i + \\tfrac{1}{2}) \\Delta v$ and all quantities are dimensionless.\n- Case A (general \"happy path\"): $N = 64$, $V_{\\max} = 4.0$, $v_t = 1.0$, $\\nu = 0.5$, $\\mu = 0.4$, and \n  $$\n  f(v) = e^{-v^2} + 0.2 \\, \\exp\\left(-\\frac{(v - 1.5)^2}{0.2^2}\\right).\n  $$\n- Case B (coarse-grid boundary condition stress test): $N = 5$, $V_{\\max} = 3.0$, $v_t = 1.0$, $\\nu = 0.1$, $\\mu = 0.2$, and \n  $$\n  f(v) = v.\n  $$\n- Case C (extended high-speed range): $N = 100$, $V_{\\max} = 6.0$, $v_t = 1.0$, $\\nu = 0.2$, $\\mu = 0.1$, and \n  $$\n  f(v) = \\exp\\left(-\\frac{v^2}{2}\\right) + 0.05 \\, \\exp\\left(-\\frac{v}{2}\\right) + 0.1 \\, \\exp\\left(-\\frac{(v - 3)^2}{0.5^2}\\right).\n  $$\n- Case D (near-degenerate diffusion-only baseline): $N = 32$, $V_{\\max} = 2.0$, $v_t = 1.0$, $\\nu = 0.3$, $\\mu = 0.0$, and \n  $$\n  f(v) = 1.\n  $$\n\nFor each case, compute four floats: the absolute raw momentum defect $\\lvert M_1^{\\text{raw}}\\rvert$, the absolute raw energy defect $\\lvert M_2^{\\text{raw}}\\rvert$, the absolute corrected momentum defect $\\lvert M_1^{\\text{corr}}\\rvert$, and the absolute corrected energy defect $\\lvert M_2^{\\text{corr}}\\rvert$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each case’s four results must be grouped as a list. The overall output must thus be a list of length $4$ whose elements are lists of four floats. For example, the format must look like \n$$\n[[x_1, x_2, x_3, x_4],[y_1, y_2, y_3, y_4],[z_1, z_2, z_3, z_4],[w_1, w_2, w_3, w_4]].\n$$",
            "solution": "The problem statement is valid. It presents a well-posed, scientifically grounded problem in computational plasma physics concerning the numerical conservation properties of a discretized collision operator. All necessary parameters and definitions are provided, and the task is algorithmically tractable.\n\nThe core of the problem is to enforce discrete conservation of momentum and energy for a finite-volume discretization of a one-dimensional Landau-like collision operator. The continuous operator conserves these quantities, but numerical discretization often introduces errors, or \"defects,\" that break these fundamental symmetries. The task is to construct and apply a correction to the numerical flux that nullifies these defects exactly.\n\nLet us begin by formalizing the discrete system.\nThe velocity domain is a one-dimensional grid on the interval $[0, V_{\\max}]$, discretized into $N$ uniform cells. The width of each cell is $\\Delta v = V_{\\max}/N$. The cell centers are located at $v_i = (i + \\tfrac{1}{2})\\Delta v$ for $i = 0, 1, \\dots, N-1$. The cell faces are at $v_f_j = j \\Delta v$ for $j = 0, 1, \\dots, N$. We will use the index $i$ for cell-centered quantities and the index $f$ for face-centered quantities.\n\nThe discrete collision operator $L_i$ acting on the distribution function $f_i = f(v_i)$ in cell $i$ is given by the divergence of a numerical flux $F$:\n$$\nL_i = \\frac{F_{i+1} - F_{i}}{\\Delta v}\n$$\nHere, $F_i$ and $F_{i+1}$ are the fluxes at the left and right faces of cell $i$, respectively. The faces of cell $i$ are located at $i \\Delta v$ and $(i+1)\\Delta v$. So, $F_i$ corresponds to the flux at face index $f=i$.\n\nThe numerical flux $F_f$ at an interior face $f$ (for $f = 1, \\dots, N-1$) is defined by a drift-diffusion form:\n$$\nF_f = - D(v_f) \\left.\\frac{\\partial f}{\\partial v}\\right|_{f} + A(v_f) \\, f|_{f}\n$$\nwhere $v_f = f \\Delta v$ is the face location. The face-centered diffusion and advection (drag) coefficients are given by:\n$$\nD(v) = \\nu \\left(1 + \\left(\\frac{v}{v_t}\\right)^2\\right)\n$$\n$$\nA(v) = \\mu \\, v\n$$\nThe gradient and average of the distribution function at face $f$ are approximated using centered differences between the adjacent cells, which are cell $f-1$ and cell $f$:\n$$\n\\left.\\frac{\\partial f}{\\partial v}\\right|_{f} = \\frac{f_f - f_{f-1}}{\\Delta v}\n$$\n$$\nf|_{f} = \\frac{f_f + f_{f-1}}{2}\n$$\nThe problem specifies zero-flux boundary conditions, so $F_0 = 0$ and $F_N = 0$.\n\nThe discrete momentum and energy moment defects, which measure the non-conservation of the operator, are defined as:\n$$\nM_1 = \\sum_{i=0}^{N-1} v_i \\, L_i \\, \\Delta v = \\sum_{i=0}^{N-1} v_i (F_{i+1} - F_i)\n$$\n$$\nM_2 = \\sum_{i=0}^{N-1} v_i^2 \\, L_i \\, \\Delta v = \\sum_{i=0}^{N-1} v_i^2 (F_{i+1} - F_i)\n$$\nOur goal is to find a correction to the interior fluxes, $\\delta F_f$, such that the corrected fluxes $F'_f = F_f + \\delta F_f$ yield zero for the corrected moments $M'_1$ and $M'_2$. The boundary fluxes remain zero: $F'_0 = F_0=0$ and $F'_N = F_N=0$.\n\nWe can simplify the moment sums using summation by parts. For any cell-centered quantity $g_i$, the sum is:\n$$\n\\sum_{i=0}^{N-1} g_i (F_{i+1} - F_i) = \\sum_{i=0}^{N-1} g_i F_{i+1} - \\sum_{i=0}^{N-1} g_i F_i = \\sum_{j=1}^{N} g_{j-1} F_j - \\sum_{i=0}^{N-1} g_i F_i\n$$\nSeparating the boundary and interior terms, and using the zero-flux boundary conditions ($F_0=0, F_N=0$), we get:\n$$\n= (g_{N-1}F_N + \\sum_{f=1}^{N-1} g_{f-1}F_f) - (g_0 F_0 + \\sum_{f=1}^{N-1} g_f F_f) = \\sum_{f=1}^{N-1} (g_{f-1} - g_f)F_f = -\\sum_{f=1}^{N-1} (g_f - g_{f-1})F_f\n$$\nHere, the sum is over interior faces $f=1, ..., N-1$, and $g_f$ and $g_{f-1}$ are the values in the cells to the right and left of face $f$.\nApplying this to the momentum moment ($g_i = v_i$) and energy moment ($g_i = v_i^2$), the conservation conditions $M'_1=0$ and $M'_2=0$ become:\n$$\n\\sum_{f=1}^{N-1} (v_f - v_{f-1}) F'_f = 0\n$$\n$$\n\\sum_{f=1}^{N-1} (v_f^2 - v_{f-1}^2) F'_f = 0\n$$\nwhere $v_f$ and $v_{f-1}$ are the centers of cells $f$ and $f-1$.\n\nThe problem requires constructing the correction flux $\\delta F_f$ as a linear combination of two basis fluxes, which are aligned with the discrete gradients of $v$ and $v^2$. Let these basis fluxes be $\\Psi^1_f$ and $\\Psi^2_f$ for interior faces $f=1, \\dots, N-1$.\n$$\n\\Psi^1_f = \\frac{v_f - v_{f-1}}{\\Delta v}, \\qquad \\Psi^2_f = \\frac{v_f^2 - v_{f-1}^2}{\\Delta v}\n$$\nSince $v_i = (i + 0.5)\\Delta v$, we have $v_f - v_{f-1} = \\Delta v$, making $\\Psi^1_f = 1$ for all $f$.\nThe correction flux is $\\delta F_f = \\alpha \\Psi^1_f + \\beta \\Psi^2_f$, where $\\alpha$ and $\\beta$ are unknown coefficients.\n\nSubstituting $F'_f = F_f + \\delta F_f$ into the conservation conditions gives:\n$$\n\\sum_{f=1}^{N-1} (v_f - v_{f-1}) (F_f + \\alpha \\Psi^1_f + \\beta \\Psi^2_f) = 0\n$$\n$$\n\\sum_{f=1}^{N-1} (v_f^2 - v_{f-1}^2) (F_f + \\alpha \\Psi^1_f + \\beta \\Psi^2_f) = 0\n$$\nRearranging these equations to solve for $\\alpha$ and $\\beta$, we recognize the raw moment defects $M_1 = -\\sum (v_f - v_{f-1})F_f$ and $M_2 = -\\sum (v_f^2 - v_{f-1}^2)F_f$. The equations become:\n$$\n-M_1 + \\alpha \\sum_{f=1}^{N-1} (v_f - v_{f-1})\\Psi^1_f + \\beta \\sum_{f=1}^{N-1} (v_f - v_{f-1})\\Psi^2_f = 0\n$$\n$$\n-M_2 + \\alpha \\sum_{f=1}^{N-1} (v_f^2 - v_{f-1}^2)\\Psi^1_f + \\beta \\sum_{f=1}^{N-1} (v_f^2 - v_{f-1}^2)\\Psi^2_f = 0\n$$\nThis is a $2 \\times 2$ linear system for the coefficients $(\\alpha, \\beta)$:\n$$\n\\mathbf{G} \\begin{pmatrix} \\alpha \\\\ \\beta \\end{pmatrix} = \\begin{pmatrix} M_1 \\\\ M_2 \\end{pmatrix}\n$$\nwhere the Gram matrix $\\mathbf{G}$ has elements:\n$$\nG_{11} = \\sum_{f=1}^{N-1} (v_f - v_{f-1})\\Psi^1_f = \\sum_{f=1}^{N-1} \\Delta v (\\Psi^1_f)^2\n$$\n$$\nG_{12} = \\sum_{f=1}^{N-1} (v_f - v_{f-1})\\Psi^2_f = \\sum_{f=1}^{N-1} \\Delta v \\Psi^1_f \\Psi^2_f\n$$\n$$\nG_{21} = \\sum_{f=1}^{N-1} (v_f^2 - v_{f-1}^2)\\Psi^1_f = \\sum_{f=1}^{N-1} \\Delta v \\Psi^2_f \\Psi^1_f = G_{12}\n$$\n$$\nG_{22} = \\sum_{f=1}^{N-1} (v_f^2 - v_{f-1}^2)\\Psi^2_f = \\sum_{f=1}^{N-1} \\Delta v (\\Psi^2_f)^2\n$$\nThe algorithmic procedure is as follows:\n1.  For each test case, define the grid parameters and the distribution function $f_i$ on the cell centers $v_i$.\n2.  Compute the raw interior fluxes $F_f$ for $f=1, \\dots, N-1$. The full flux vector is $\\mathbf{F} = [0, F_1, \\dots, F_{N-1}, 0]$.\n3.  Compute the raw discrete operator $L_i = (F_{i+1}-F_i)/\\Delta v$ and the raw moment defects $M_1$ and $M_2$.\n4.  Construct the basis fluxes $\\Psi^1_f$ and $\\Psi^2_f$ for the interior faces.\n5.  Assemble the $2 \\times 2$ Gram matrix $\\mathbf{G}$ and the right-hand side vector $[M_1, M_2]^T$.\n6.  Solve the linear system for the coefficients $\\alpha$ and $\\beta$.\n7.  Compute the correction flux $\\delta F_f = \\alpha \\Psi^1_f + \\beta \\Psi^2_f$ and add it to the raw interior fluxes to get the corrected fluxes $F'_f$.\n8.  Recompute the operator $L'_i$ and the moment defects $M'_1$ and $M'_2$ using the corrected fluxes. The corrected defects should be zero to within machine precision.\n9.  Report the absolute values of the raw and corrected defects.\nThis procedure guarantees that the resulting corrected operator $L'_i$ exactly conserves discrete momentum and energy.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A\n        {\n            \"N\": 64, \"V_max\": 4.0, \"v_t\": 1.0, \"nu\": 0.5, \"mu\": 0.4,\n            \"f_func\": lambda v: np.exp(-v**2) + 0.2 * np.exp(-(v - 1.5)**2 / 0.2**2)\n        },\n        # Case B\n        {\n            \"N\": 5, \"V_max\": 3.0, \"v_t\": 1.0, \"nu\": 0.1, \"mu\": 0.2,\n            \"f_func\": lambda v: v\n        },\n        # Case C\n        {\n            \"N\": 100, \"V_max\": 6.0, \"v_t\": 1.0, \"nu\": 0.2, \"mu\": 0.1,\n            \"f_func\": lambda v: np.exp(-v**2 / 2.0) + 0.05 * np.exp(-v / 2.0) + 0.1 * np.exp(-(v - 3.0)**2 / 0.5**2)\n        },\n        # Case D\n        {\n            \"N\": 32, \"V_max\": 2.0, \"v_t\": 1.0, \"nu\": 0.3, \"mu\": 0.0,\n            \"f_func\": lambda v: np.ones_like(v)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Construct grid and distribution function\n        N = case[\"N\"]\n        V_max = case[\"V_max\"]\n        v_t = case[\"v_t\"]\n        nu = case[\"nu\"]\n        mu = case[\"mu\"]\n        f_func = case[\"f_func\"]\n\n        delta_v = V_max / N\n        v_centers = (np.arange(N) + 0.5) * delta_v\n        v_faces = np.arange(N + 1) * delta_v\n        \n        f_centers = f_func(v_centers)\n\n        # Step 2: Compute raw fluxes\n        F_raw = np.zeros(N + 1)\n        \n        # Interior faces f = 1, ..., N-1\n        # Face f is between cell f-1 and cell f\n        v_f_interior = v_faces[1:N]\n        D_f = nu * (1 + (v_f_interior / v_t)**2)\n        A_f = mu * v_f_interior\n        \n        df_dv = (f_centers[1:N] - f_centers[0:N-1]) / delta_v\n        f_avg = (f_centers[1:N] + f_centers[0:N-1]) / 2.0\n        \n        F_raw[1:N] = -D_f * df_dv + A_f * f_avg\n\n        # Step 3: Compute raw operator and defects\n        L_raw = (F_raw[1:N+1] - F_raw[0:N]) / delta_v\n        M1_raw = np.sum(v_centers * L_raw * delta_v)\n        M2_raw = np.sum(v_centers**2 * L_raw * delta_v)\n        \n        # Step 4: Build basis fluxes and solve for correction coefficients\n        \n        # Basis fluxes Psi^1_f and Psi^2_f for INTERIOR faces f = 1..N-1\n        psi1_f = (v_centers[1:N] - v_centers[0:N-1]) / delta_v # This is just 1.0\n        psi2_f = (v_centers[1:N]**2 - v_centers[0:N-1]**2) / delta_v\n\n        # Build the 2x2 Gram matrix G\n        # The terms in the summation by parts are (v_f - v_{f-1}) and (v_f^2 - v_{f-1}^2)\n        # where v_f and v_{f-1} are cell centers.\n        # This is equal to delta_v * psi1_f and delta_v * psi2_f\n        \n        G = np.zeros((2, 2))\n        G[0, 0] = np.sum(delta_v * psi1_f * psi1_f)\n        G[0, 1] = np.sum(delta_v * psi1_f * psi2_f)\n        G[1, 0] = G[0, 1]\n        G[1, 1] = np.sum(delta_v * psi2_f * psi2_f)\n        \n        # Right-hand side is the vector of raw moment defects\n        M_vec = np.array([M1_raw, M2_raw])\n        \n        # Solve G * [alpha, beta]^T = M_vec\n        # Handle the case where M_vec is zero (no correction needed)\n        if np.allclose(M_vec, 0.0):\n            alpha, beta = 0.0, 0.0\n        else:\n            try:\n                # We need to solve for (alpha, beta) from M_vec = G . [alpha,beta]\n                # which is [alpha,beta] = G_inv . M_vec\n                coeffs = np.linalg.solve(G, M_vec)\n                alpha, beta = coeffs[0], coeffs[1]\n            except np.linalg.LinAlgError:\n                # Fallback for singular matrix, although not expected for N=2\n                alpha, beta = 0.0, 0.0\n\n        # Step 5: Apply correction and recompute defects\n        delta_F = alpha * psi1_f + beta * psi2_f\n        \n        F_corr = np.copy(F_raw)\n        F_corr[1:N] = F_raw[1:N] - delta_F # The correction is subtracted based on derivation\n        # Let's re-check the derivation for the sign.\n        # M'_1 = sum (v_f-v_{f-1})F'_f = sum (v_f-v_{f-1})(F_f + delta F_f) = -M1_raw + sum(...)\n        # So we need M1_raw = sum(...) = G[0,0]alpha + G[0,1]beta\n        # So the flux correction is added, delta_F is the correction itself.\n        F_corr[1:N] = F_raw[1:N] + delta_F\n\n        L_corr = (F_corr[1:N+1] - F_corr[0:N]) / delta_v\n        \n        # The summation by parts formulation is more stable for checking conservation\n        M1_corr = -np.sum((v_centers[1:N] - v_centers[0:N-1]) * F_corr[1:N])\n        M2_corr = -np.sum((v_centers[1:N]**2 - v_centers[0:N-1]**2) * F_corr[1:N])\n\n        case_results = [\n            abs(M1_raw),\n            abs(M2_raw),\n            abs(M1_corr),\n            abs(M2_corr)\n        ]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"{results}\")\n\nsolve()\n```"
        }
    ]
}