{
    "hands_on_practices": [
        {
            "introduction": "在异步多任务（AMT）系统中，实现高并行效率需要在单个任务的有效计算工作量与运行时系统管理该任务的开销之间取得谨慎的平衡。这个练习提供了一个实用的模型，用于确定最佳的任务“粒度”，即找到足够大以摊销调度开销但又足够小以暴露足够并行性的任务尺寸。通过从第一性原理出发，您将推导出并行效率与任务计算时间和开销之间的关系，从而掌握性能优化的一个核心原则 。",
            "id": "3951831",
            "problem": "一个计算聚变科学代码中的异步多任务 (AMT) 运行时，调度多个细粒度任务，每个任务在一个大小为 $b$ 的网格数据块上应用一个局部化算子。在目标平台上的经验性微基准测试表明，该运行时会产生每批次 $o = 15~\\mu\\text{s}$ 的恒定调度开销，而由于具有立方复杂度的密集局部操作，一个批次的有效内核时间随 $t(b) = 1.2 b^{3}~\\mu\\text{s}$ 变化。假设有一个大型固定问题，包含 $M$ 个相同的批次，其中 $M \\gg P$。并且，在 $P = 64$ 个相同的工作单元上实现了完美的负载均衡，同时有足够的任务并行性来保持所有工作单元始终处于工作状态。假设 AMT 运行时对每个批次执行其开销和有效内核时间时，两者是相加的，即 $o$ 和 $t(b)$ 之间没有重叠。并且，超出 $o$ 的通信和同步成本可以忽略不计，且在稳态下不会引入额外的串行化。\n\n从第一性原理出发，将并行效率定义为 $E = \\frac{T_{\\text{ideal}}}{T_{\\text{actual}}}$，其中 $T_{\\text{ideal}}$ 是忽略运行时开销的理想并行运行时间，而 $T_{\\text{actual}}$ 是包含每批次开销 $o$ 的实际测量并行运行时间。使用这些定义，为给定的在 $P = 64$ 个工作单元上运行的大型固定问题，推导出一个关于 $b$ 的条件，以保证效率至少达到 $0.90$。报告满足此条件的最小整数 $b$。将你的最终答案表示为一个无量纲整数。",
            "solution": "问题要求找出能确保并行效率至少为 $0.90$ 的最小整数块大小 $b$。我们按照要求，从第一性原理开始分析问题。\n\n整个问题包含 $M$ 个相同的批次，由 $P$ 个工作单元处理。\n与单个批次相关的工作有两个组成部分：\n1.  有效内核工作，持续时间为 $t(b) = 1.2 b^{3}~\\mu\\text{s}$。\n2.  运行时调度开销，持续时间为 $o = 15~\\mu\\text{s}$。\n\n问题指出，对于每个批次，开销和有效内核时间是相加的。因此，在单个工作单元上处理一个批次的总时间是 $t_{\\text{batch}}(b) = t(b) + o$。\n\n对于包含 $M$ 个批次的整个问题，我们可以定义总有效工作量和总开销工作量。我们将总有效计算工作量表示为 $W_{\\text{useful}}$，总开销表示为 $W_{\\text{overhead}}$。\n$$ W_{\\text{useful}} = M \\cdot t(b) = M \\cdot (1.2 b^{3}) $$\n$$ W_{\\text{overhead}} = M \\cdot o = M \\cdot 15 $$\n总实际工作量 $W_{\\text{actual}}$ 是有效工作量和开销之和。\n$$ W_{\\text{actual}} = W_{\\text{useful}} + W_{\\text{overhead}} = M \\cdot (t(b) + o) $$\n\n问题指明了几个关键假设：完美的负载均衡、足以让所有 $P=64$ 个工作单元保持忙碌的任务并行性，以及除每批次开销 $o$ 之外可忽略不计的通信和同步成本。在这些假设下，总工作量被均匀地分配给 $P$ 个工作单元。\n\n现在我们可以定义并行运行时间 $T_{\\text{ideal}}$ 和 $T_{\\text{actual}}$。\n$T_{\\text{ideal}}$ 是在没有开销（$o=0$）情况下的理想并行运行时间。它等于总有效工作量除以工作单元的数量。\n$$ T_{\\text{ideal}} = \\frac{W_{\\text{useful}}}{P} = \\frac{M \\cdot t(b)}{P} $$\n$T_{\\text{actual}}$ 是包含开销的实际测量并行运行时间。它等于总实际工作量除以工作单元的数量。\n$$ T_{\\text{actual}} = \\frac{W_{\\text{actual}}}{P} = \\frac{M \\cdot (t(b) + o)}{P} $$\n\n并行效率 $E$ 定义为理想并行运行时间与实际并行运行时间之比。\n$$ E = \\frac{T_{\\text{ideal}}}{T_{\\text{actual}}} $$\n代入 $T_{\\text{ideal}}$ 和 $T_{\\text{actual}}$ 的表达式：\n$$ E = \\frac{\\frac{M \\cdot t(b)}{P}}{\\frac{M \\cdot (t(b) + o)}{P}} $$\n项 $M$ 和 $P$ 被消去了。这表明，对于此模型，效率与总问题大小和工作单元数量无关，而是由单个任务的“粒度”决定，即其有效工作量与开销的比率。\n$$ E = \\frac{t(b)}{t(b) + o} $$\n该表达式表示用于有效计算的时间所占的比例。\n\n我们得到的条件是效率必须至少为 $0.90$。\n$$ E \\ge 0.90 $$\n$$ \\frac{t(b)}{t(b) + o} \\ge 0.90 $$\n\n现在，我们代入给定的 $t(b)$ 和 $o$ 的表达式。单位（$\\mu\\text{s}$）是一致的，将会被消去，所以我们可以直接使用数值进行计算。\n$t(b) = 1.2 b^3$\n$o = 15$\n$$ \\frac{1.2 b^3}{1.2 b^3 + 15} \\ge 0.90 $$\n为了求解 $b$，我们整理这个不等式。由于 $b$ 是块大小，所以 $b>0$，这意味着 $1.2 b^3 + 15$ 是一个正数，因此我们可以在不等式两边同时乘以它而不用改变不等号的方向。\n$$ 1.2 b^3 \\ge 0.90 \\cdot (1.2 b^3 + 15) $$\n$$ 1.2 b^3 \\ge 0.90 \\cdot 1.2 b^3 + 0.90 \\cdot 15 $$\n$$ 1.2 b^3 \\ge 1.08 b^3 + 13.5 $$\n现在，我们分离出含有 $b^3$ 的项。\n$$ 1.2 b^3 - 1.08 b^3 \\ge 13.5 $$\n$$ 0.12 b^3 \\ge 13.5 $$\n$$ b^3 \\ge \\frac{13.5}{0.12} $$\n$$ b^3 \\ge \\frac{1350}{12} $$\n化简分数：\n$$ b^3 \\ge \\frac{450}{4} = \\frac{225}{2} = 112.5 $$\n为了找到关于 $b$ 的条件，我们对两边取立方根。\n$$ b \\ge \\sqrt[3]{112.5} $$\n我们需要找到满足这个条件的最小整数 $b$。我们可以通过检查整数的立方来估算其值：\n$4^3 = 64$\n$5^3 = 125$\n因为 $64  112.5  125$，我们知道 $4  \\sqrt[3]{112.5}  5$。\n不等式 $b \\ge \\sqrt[3]{112.5}$ 要求 $b$ 大于一个介于 $4$ 和 $5$ 之间的数。由于 $b$ 必须是整数，满足此条件的最小整数值是 $5$。\n\n为了验证，我们来检查一下 $b=4$ 和 $b=5$ 时的效率。\n当 $b=4$ 时：\n$t(4) = 1.2 \\cdot 4^3 = 1.2 \\cdot 64 = 76.8$。\n$E(4) = \\frac{76.8}{76.8 + 15} = \\frac{76.8}{91.8} \\approx 0.8366$，小于 $0.90$。\n当 $b=5$ 时：\n$t(5) = 1.2 \\cdot 5^3 = 1.2 \\cdot 125 = 150$。\n$E(5) = \\frac{150}{150 + 15} = \\frac{150}{165} = \\frac{10}{11} \\approx 0.9091$，大于 $0.90$。\n因此，满足所需效率目标的最小整数值 $b$ 是 $5$。",
            "answer": "$$ \\boxed{5} $$"
        },
        {
            "introduction": "除了单个任务的效率，应用程序的整体性能还受到任务之间数据依赖关系的制约。这个练习探讨了如何通过识别计算工作流中最长的数据依赖链（即“关键路径”），来确定在理想资源下的理论最短执行时间，也称为“完工时间 (makespan)” 。理解关键路径对于预测并行应用的性能极限以及识别优化的瓶颈至关重要。",
            "id": "3951863",
            "problem": "一个计算聚变科学控制循环采用异步多任务（AMT）运行时，其中计算被组织为由依赖未来（dependency futures）链接的任务。考虑单次流水线调用，其中四个计算阶段代表不同的物理模块：阶段 $1$（例如，快速平衡预处理器），阶段 $2$（例如，磁流体动力学更新），阶段 $3$（例如，射频加热核心），以及阶段 $4$（例如，诊断同化）。AMT 运行时使用未来（futures）来链接任务，使得一个任务在其所有输入未来（futures）都满足的瞬间就有资格开始，并且如果资源可用，就绪的任务可以并发执行。假设一个理想化的机器模型，有足够的工作单元（workers）可以并发运行任意数量的就绪任务，并且调度开销可以忽略不计。\n\n阶段 $1$、$2$、$3$ 和 $4$ 的持续时间分别为 $2$、$3$、$1$ 和 $4$ 毫秒。依赖结构如下：阶段 $2$ 依赖于阶段 $1$；阶段 $4$ 依赖于阶段 $3$；阶段 $1$ 和 $3$ 是独立的。没有其他依赖关系。流水线处理单个输入，AMT 运行时在依赖关系满足后立即调度任务。\n\n仅使用基于 AMT 任务调度和遵循依赖的执行的核心定义的第一性原理进行推理（例如，就绪任务可以在时间 $0$ 开始，以及一个任务的最早开始时间由其前驱任务的完成时间决定），确定最小完工时间（makespan），定义为在给定假设下所有四个阶段都已完成的最早时间。以毫秒（ms）为单位表示您的最终答案。无需四舍五入；以单个实数形式提供确切值。",
            "solution": "问题要求计算一组由四个具有指定持续时间和依赖关系的计算任务，在理想化的异步多任务（AMT）运行时下执行时的最小完工时间。完工时间是从第一个任务开始到最后一个任务完成所经过的总时间。这个问题等同于在任务依赖图中寻找关键路径的长度。\n\n设 $S_i$ 为阶段 $i$ 的开始时间，$C_i$ 为其完成时间，其中 $i \\in \\{1, 2, 3, 4\\}$。阶段 $i$ 的持续时间表示为 $T_i$。这些量之间的关系是 $C_i = S_i + T_i$。\n\n根据带有未来（futures）的 AMT 调度规则：\n1.  没有依赖关系的任务可以在时间 $t=0$ 开始。\n2.  有依赖关系的任务只有在其所有前置任务都完成后才能开始。在立即调度的假设下，其开始时间是其所有直接前驱任务完成时间的最大值。\n\n问题指明了两个独立的计算链：\n-   链条 A：阶段 1 $\\rightarrow$ 阶段 2\n-   链条 B：阶段 3 $\\rightarrow$ 阶段 4\n\n由于阶段 $1$ 和 $3$ 是独立的，并且没有前驱任务，它们都可以在时间 $t=0$ 开始。具有足够工作单元的理想化机器模型允许这两条链并发执行。\n\n让我们分析链条 A：\n-   阶段 $1$ 没有前驱任务。其开始时间为 $S_1 = 0$ 毫秒。\n-   阶段 $1$ 的持续时间为 $T_1 = 2$ 毫秒。\n-   阶段 $1$ 的完成时间为 $C_1 = S_1 + T_1 = 0 + 2 = 2$ 毫秒。\n-   阶段 $2$ 依赖于阶段 $1$。因此，其最早开始时间是阶段 $1$ 的完成时间。\n-   阶段 $2$ 的开始时间为 $S_2 = C_1 = 2$ 毫秒。\n-   阶段 $2$ 的持续时间为 $T_2 = 3$ 毫秒。\n-   阶段 $2$ 的完成时间为 $C_2 = S_2 + T_2 = 2 + 3 = 5$ 毫秒。\n完成链条 A 的总时间为 $C_2 = 5$ 毫秒。\n\n现在，我们来分析与链条 A 并行运行的链条 B：\n-   阶段 $3$ 没有前驱任务。其开始时间为 $S_3 = 0$ 毫秒。\n-   阶段 $3$ 的持续时间为 $T_3 = 1$ 毫秒。\n-   阶段 $3$ 的完成时间为 $C_3 = S_3 + T_3 = 0 + 1 = 1$ 毫秒。\n-   阶段 $4$ 依赖于阶段 $3$。因此，其最早开始时间是阶段 $3$ 的完成时间。\n-   阶段 $4$ 的开始时间为 $S_4 = C_3 = 1$ 毫秒。\n-   阶段 $4$ 的持续时间为 $T_4 = 4$ 毫秒。\n-   阶段 $4$ 的完成时间为 $C_4 = S_4 + T_4 = 1 + 4 = 5$ 毫秒。\n完成链条 B 的总时间为 $C_4 = 5$ 毫秒。\n\n完工时间定义为*所有*四个阶段都完成的最早时间。这是所有任务完成时间的最大值。\n完工时间 $= \\max(C_1, C_2, C_3, C_4)$。\n代入计算出的值：\n完工时间 $= \\max(2 \\text{ ms}, 5 \\text{ ms}, 1 \\text{ ms}, 5 \\text{ ms})$。\n这些值的最大值为 $5$ 毫秒。\n\n关键路径是贯穿依赖图的最长路径。在这种情况下，有两条长度相等的关键路径：$1 \\rightarrow 2$ 和 $3 \\rightarrow 4$。路径 $1 \\rightarrow 2$ 的长度是 $T_1 + T_2 = 2+3 = 5$ 毫秒。路径 $3 \\rightarrow 4$ 的长度是 $T_3 + T_4 = 1+4 = 5$ 毫秒。完工时间由最长路径的长度决定，即 $5$ 毫秒。\n因此，最小完工时间是 $5$ 毫秒。",
            "answer": "$$\n\\boxed{5}\n$$"
        },
        {
            "introduction": "关键路径等理论模型为我们提供了性能基准，但由于有限的计算资源和调度决策，实际执行时间往往更长。这项练习将分析一个模拟的执行轨迹，计算关键的性能指标，如工作单元利用率和负载不平衡，从而帮助诊断性能损失的根源 。这种事后性能分析是理解和优化复杂并行应用程序行为的关键步骤。",
            "id": "3951867",
            "problem": "您将获得异步多任务执行的轨迹，这些轨迹以有向无环图的形式表示，其中包含明确的任务开始和结束时间、工作单元分配以及依赖关系。每个任务是一个节点 $i$，其持续时间 $d_i$ 以秒为单位，定义为 $d_i = t_i^{\\text{finish}} - t_i^{\\text{start}}$，其中 $t_i^{\\text{start}}$ 和 $t_i^{\\text{finish}}$ 是以秒为单位的开始和结束时间。每条有向边 $(j \\rightarrow i)$ 表示任务 $i$ 依赖于任务 $j$，因此在任务 $j$ 完成之前无法开始。工作单元是同质资源，任何工作单元在同一时间执行的任务不超过一个。对于每个测试用例，您的程序必须根据任务持续时间计算依赖关系图的关键路径长度，计算在总执行时间（makespan）内工作单元的平均利用率，并根据一个精确的标准量化时间不平衡周期。\n\n其基本原理如下。\n\n- 依赖结构是一个有向无环图 (DAG)。在无限资源下，任务 $i$ 的最早完成时间 $E_i$ 由以下递归公式定义：\n$$\nE_i = d_i + \\max_{j \\in \\mathrm{pred}(i)} E_j,\n$$\n其中 $\\mathrm{pred}(i)$ 是 $i$ 的直接前驱任务集合。如果 $\\mathrm{pred}(i) = \\emptyset$，则 $E_i = d_i$。关键路径长度 $L_{\\mathrm{cp}}$ 为\n$$\nL_{\\mathrm{cp}} = \\max_{i} E_i,\n$$\n它表示在无限资源和给定依赖关系下的最小可能完成时间。\n\n- 设 $W$ 表示工作单元总数，设 $B(t)$ 为在时间 $t$ 正在运行的任务数量（即满足 $t_i^{\\text{start}} \\le t  t_i^{\\text{finish}}$ 的任务）。在时间 $t$ 的利用率为 $U(t) = \\frac{B(t)}{W}$。设总执行时间（makespan）为 $T = \\max_i t_i^{\\text{finish}} - \\min_i t_i^{\\text{start}}$。平均利用率定义为\n$$\n\\bar{U} = \\frac{1}{T} \\int_{0}^{T} \\frac{B(t)}{W} \\, dt,\n$$\n其中时间以秒为单位，$\\bar{U}$ 是一个无量纲的分数。\n\n- 任务在时间 $t$ 的就绪状态定义为其所有依赖项在时间 $t$ 或之前已完成。如果 $\\max_{j \\in \\mathrm{pred}(i)} t_j^{\\text{finish}} \\le t$ 且 $t_i^{\\text{start}} > t$，则任务 $i$ 在时间 $t$ 处于“就绪但未运行”状态。设 $R(t)$ 表示在时间 $t$ 处于“就绪但未运行”状态的任务数量。不平衡指标定义为\n$$\nI(t) = \n\\begin{cases}\n1,   \\text{if } R(t)  0 \\text{ and } W - B(t)  0, \\\\\n0,   \\text{otherwise}.\n\\end{cases}\n$$\n相对于总执行时间的不平衡时间分数是\n$$\n\\phi = \\frac{1}{T} \\int_{0}^{T} I(t) \\, dt,\n$$\n它是一个无量纲的分数。\n\n您的任务是实现一个程序，对于每个测试用例，计算：\n- 关键路径长度 $L_{\\mathrm{cp}}$，以秒为单位。\n- 总执行时间 $T$，以秒为单位。\n- 平均利用率 $\\bar{U}$，作为一个无量纲的分数。\n- 不平衡时间分数 $\\phi$，作为一个无量纲的分数。\n\n计算需要精确执行，利用由 $t_i^{\\text{start}}$ 和 $t_i^{\\text{finish}}$ 引起的事件时间上的分段常数特性；也就是说，如果排序后的唯一事件时间为 $t_0  t_1  \\cdots  t_K$，则积分可简化为求和形式\n$$\n\\bar{U} = \\frac{1}{T} \\sum_{k=0}^{K-1} \\frac{B(t_k)}{W} \\left( t_{k+1} - t_k \\right), \\quad\n\\phi = \\frac{1}{T} \\sum_{k=0}^{K-1} I(t_k) \\left( t_{k+1} - t_k \\right).\n$$\n\n所有时间必须以秒为单位处理。所有输出必须是浮点数。角度单位不适用。\n\n测试套件（所有时间单位为秒，工作单元索引从 $0$ 开始的整数）：\n\n- 测试用例1（平衡执行）：\n    - 工作单元：$W=2$。\n    - 任务：\n        - T1：$t^{\\text{start}} = 0$, $t^{\\text{finish}} = 2$, 工作单元 $0$, 依赖项 $\\emptyset$。\n        - T2：$t^{\\text{start}} = 0$, $t^{\\text{finish}} = 2$, 工作单元 $1$, 依赖项 $\\emptyset$。\n        - T3：$t^{\\text{start}} = 2$, $t^{\\text{finish}} = 4$, 工作单元 $0$, 依赖项 $\\{T1\\}$。\n        - T4：$t^{\\text{start}} = 2$, $t^{\\text{finish}} = 4$, 工作单元 $1$, 依赖项 $\\{T2\\}$。\n\n- 测试用例2（无不平衡的依赖限制阶段）：\n    - 工作单元：$W = 3$。\n    - 任务：\n        - A：$t^{\\text{start}} = 0$, $t^{\\text{finish}} = 3$, 工作单元 $0$, 依赖项 $\\emptyset$。\n        - B：$t^{\\text{start}} = 0$, $t^{\\text{finish}} = 3$, 工作单元 $1$, 依赖项 $\\emptyset$。\n        - C：$t^{\\text{start}} = 0$, $t^{\\text{finish}} = 3$, 工作单元 $2$, 依赖项 $\\emptyset$。\n        - D：$t^{\\text{start}} = 3$, $t^{\\text{finish}} = 6$, 工作单元 $0$, 依赖项 $\\{A,B,C\\}$。\n\n- 测试用例3（调度效率低下导致不平衡）：\n    - 工作单元：$W = 2$。\n    - 任务：\n        - E：$t^{\\text{start}} = 0$, $t^{\\text{finish}} = 3$, 工作单元 $0$, 依赖项 $\\emptyset$。\n        - F：$t^{\\text{start}} = 1$, $t^{\\text{finish}} = 4$, 工作单元 $1$, 依赖项 $\\emptyset$。\n        - H：$t^{\\text{start}} = 3.5$, $t^{\\text{finish}} = 5$, 工作单元 $0$, 依赖项 $\\emptyset$。\n\n- 测试用例4（单工作单元串行链）：\n    - 工作单元：$W = 1$。\n    - 任务：\n        - P：$t^{\\text{start}} = 0$, $t^{\\text{finish}} = 2$, 工作单元 $0$, 依赖项 $\\emptyset$。\n        - Q：$t^{\\text{start}} = 2$, $t^{\\text{finish}} = 5$, 工作单元 $0$, 依赖项 $\\{P\\}$。\n        - R：$t^{\\text{start}} = 5$, $t^{\\text{finish}} = 6$, 工作单元 $0$, 依赖项 $\\{Q\\}$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个测试用例的结果本身是按 $[L_{\\mathrm{cp}}, T, \\bar{U}, \\phi]$ 顺序排列的四个浮点数的列表。例如，一个有效的输出格式是 $[[x_1,y_1,u_1,\\phi_1],[x_2,y_2,u_2,\\phi_2],\\ldots]$，其中每个符号都是一个浮点数。不应打印任何额外文本。",
            "solution": "该问题是有效的，因为它科学地基于并行计算和性能分析的原理，问题定义良好、清晰且一致，并为得出唯一解提供了所有必要的数据。我们将通过为四个指定的指标实现算法来解决它：关键路径长度（$L_{\\mathrm{cp}}$）、总执行时间（$T$）、平均工作单元利用率（$\\bar{U}$）和不平衡时间分数（$\\phi$）。\n\n解决方案的核心在于处理所提供的任务执行轨迹，这是一个有向无环图（DAG），其中节点代表任务，边代表依赖关系。分析涉及用于关键路径的图遍历以及用于利用率和不平衡的时域分析。\n\n首先，我们来形式化数据结构。对于每个测试用例，我们有一组任务。每个任务 $i$ 可以由其属性表示：开始时间 $t_i^{\\text{start}}$、结束时间 $t_i^{\\text{finish}}$ 以及其前驱任务集合 $\\mathrm{pred}(i)$。持续时间为 $d_i = t_i^{\\text{finish}} - t_i^{\\text{start}}$。工作单元的数量为 $W$。\n\n**1. 总执行时间（$T$）计算**\n总执行时间 $T$ 是执行轨迹的总时长，从第一个任务的开始到最后一个任务的完成。根据所提供的定义：\n$$\nT = \\max_i t_i^{\\text{finish}} - \\min_i t_i^{\\text{start}}\n$$\n这可以通过在轨迹中的所有任务中找到所有任务开始时间的最小值和所有任务结束时间的最大值来计算。\n\n**2. 关键路径长度（$L_{\\mathrm{cp}}$）计算**\n关键路径长度 $L_{\\mathrm{cp}}$ 表示依赖关系图中由任务持续时间加权的最长路径。它确立了在无限资源可用情况下的理论最小执行时间。计算基于每个任务 $i$ 的最早完成时间 $E_i$ 的递归定义：\n$$\nE_i = d_i + \\max_{j \\in \\mathrm{pred}(i)} E_j\n$$\n对于没有前驱任务的源任务 $i$（$\\mathrm{pred}(i) = \\emptyset$），该公式简化为 $E_i = d_i$。总的关键路径长度是所有任务中这些最早完成时间的最大值：\n$$\nL_{\\mathrm{cp}} = \\max_i E_i\n$$\n为了实现这一点，我们可以使用带有记忆化（一种动态规划形式）的递归函数，以避免对同一任务多次重复计算 $E_j$。计算给定任务 $i$ 的 $E_i$ 需要其所有前驱任务 $j \\in \\mathrm{pred}(i)$ 的 $E_j$ 值。这自然地映射到对 DAG 的遍历。一个缓存或记忆化字典存储计算出的 $E_i$ 值。该算法遍历所有任务，如果尚未缓存，则递归计算它们的最早完成时间，然后在这些值中找到最大值。\n\n**3. 平均利用率（$\\bar{U}$）计算**\n平均利用率 $\\bar{U}$ 衡量的是在整个总执行时间内工作单元处于繁忙状态的时间比例。形式化定义是一个积分：\n$$\n\\bar{U} = \\frac{1}{T} \\int_{0}^{T} \\frac{B(t)}{W} \\, dt\n$$\n其中 $B(t)$ 是在时间 $t$ 正在运行的任务数。虽然问题建议通过对事件点之间的区间求和来进行数值积分，但存在一种更直接且计算效率更高的方法。繁忙函数 $B(t)$ 的积分 $\\int_{0}^{T} B(t) \\, dt$ 代表总的工作单元-秒数，这仅仅是所有单个任务持续时间的总和。\n$$\n\\int_{0}^{T} B(t) \\, dt = \\sum_i \\int_{0}^{T} \\mathbb{I}(t_i^{\\text{start}} \\le t  t_i^{\\text{finish}}) \\, dt = \\sum_i (t_i^{\\text{finish}} - t_i^{\\text{start}}) = \\sum_i d_i\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。因此，平均利用率可以直接计算为：\n$$\n\\bar{U} = \\frac{\\sum_{i} d_i}{W \\cdot T}\n$$\n这个公式在数学上等价于分段求和，并且更易于实现。\n\n**4. 不平衡时间分数（$\\phi$）计算**\n不平衡时间分数 $\\phi$ 量化了工作单元空闲但有任务准备好执行的低效率时期。不平衡指标 $I(t)$ 为 $1$ 当且仅当至少有一个“就绪但未运行”的任务（$R(t) > 0$）并且至少有一个空闲的工作单元（$W - B(t) > 0$）。\n$$\n\\phi = \\frac{1}{T} \\int_{0}^{T} I(t) \\, dt\n$$\n与利用率不同，这个积分不能简化为对任务属性的简单求和。我们必须使用指定的分段常数评估方法。算法如下：\na. 将所有唯一的任务开始时间（$t_i^{\\text{start}}$）和结束时间（$t_i^{\\text{finish}}$）收集到一个事件点列表中。对这些点进行排序，得到时间轴 $t_0  t_1  \\cdots  t_K$。\nb. 这些事件点定义了一组不相交的时间区间 $[t_k, t_{k+1})$。函数 $B(t)$、$R(t)$ 以及因此 $I(t)$ 在每个开区间内都是常数。\nc. 我们从 $k=0$ 迭代到 $K-1$。对于每个区间，我们选择一个采样点（例如，区间的起始点 $t_k$）并评估不平衡指标 $I(t_k)$。该区间的持续时间为 $\\Delta t_k = t_{k+1} - t_k$。\nd. 在每个 $t_k$，我们计算：\n    i. $B(t_k)$：满足 $t_i^{\\text{start}} \\le t_k  t_i^{\\text{finish}}$ 的任务 $i$ 的数量。\n    ii. $R(t_k)$：处于“就绪但未运行”状态的任务 $i$ 的数量，即 $t_i^{\\text{start}} > t_k$ 并且对于所有前驱任务 $j \\in \\mathrm{pred}(i)$，$t_j^{\\text{finish}} \\le t_k$。\n    iii. 如果 $R(t_k) > 0$ 且 $W - B(t_k) > 0$，则 $I(t_k) = 1$；否则 $I(t_k) = 0$。\ne. 总不平衡时间是不平衡区间持续时间的总和：$\\sum_{k=0}^{K-1} I(t_k) \\cdot \\Delta t_k$。\nf. 最后，$\\phi$ 是这个总不平衡时间除以总执行时间 $T$。\n\n通过实现这四种算法，我们可以系统地分析所提供的执行轨迹，并为每个测试用例计算所需的性能指标。",
            "answer": "完整的、可运行的 Python 3 代码如下。导入的模块必须符合指定的执行环境。\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        {\n            \"W\": 2,\n            \"tasks\": {\n                \"T1\": {\"start\": 0.0, \"finish\": 2.0, \"deps\": []},\n                \"T2\": {\"start\": 0.0, \"finish\": 2.0, \"deps\": []},\n                \"T3\": {\"start\": 2.0, \"finish\": 4.0, \"deps\": [\"T1\"]},\n                \"T4\": {\"start\": 2.0, \"finish\": 4.0, \"deps\": [\"T2\"]},\n            }\n        },\n        {\n            \"W\": 3,\n            \"tasks\": {\n                \"A\": {\"start\": 0.0, \"finish\": 3.0, \"deps\": []},\n                \"B\": {\"start\": 0.0, \"finish\": 3.0, \"deps\": []},\n                \"C\": {\"start\": 0.0, \"finish\": 3.0, \"deps\": []},\n                \"D\": {\"start\": 3.0, \"finish\": 6.0, \"deps\": [\"A\", \"B\", \"C\"]},\n            }\n        },\n        {\n            \"W\": 2,\n            \"tasks\": {\n                \"E\": {\"start\": 0.0, \"finish\": 3.0, \"deps\": []},\n                \"F\": {\"start\": 1.0, \"finish\": 4.0, \"deps\": []},\n                \"H\": {\"start\": 3.5, \"finish\": 5.0, \"deps\": []},\n            }\n        },\n        {\n            \"W\": 1,\n            \"tasks\": {\n                \"P\": {\"start\": 0.0, \"finish\": 2.0, \"deps\": []},\n                \"Q\": {\"start\": 2.0, \"finish\": 5.0, \"deps\": [\"P\"]},\n                \"R\": {\"start\": 5.0, \"finish\": 6.0, \"deps\": [\"Q\"]},\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(process_case(case))\n    \n    # The str() of a list includes spaces, which we should remove for the exact format.\n    # The final format is [[a,b,c,d],[e,f,g,h]], without spaces after commas.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef process_case(case_data):\n    \"\"\"\n    Computes the four metrics for a single test case.\n    \"\"\"\n    W = case_data[\"W\"]\n    tasks_data = case_data[\"tasks\"]\n    task_ids = list(tasks_data.keys())\n\n    # --- 1. Compute Makespan (T) and durations ---\n    min_start_time = float('inf')\n    max_finish_time = float('-inf')\n    all_durations = {}\n    \n    if not tasks_data:\n        return [0.0, 0.0, 0.0, 0.0]\n\n    for tid, tinfo in tasks_data.items():\n        min_start_time = min(min_start_time, tinfo[\"start\"])\n        max_finish_time = max(max_finish_time, tinfo[\"finish\"])\n        all_durations[tid] = tinfo[\"finish\"] - tinfo[\"start\"]\n\n    makespan_T = max_finish_time - min_start_time\n    # Handle the edge case of zero makespan\n    if makespan_T == 0:\n        L_cp = max(all_durations.values()) if all_durations else 0.0\n        return [L_cp, 0.0, 0.0, 0.0]\n\n    # --- 2. Compute Critical Path Length (L_cp) ---\n    memo_E = {}\n    def get_earliest_finish(tid):\n        if tid in memo_E:\n            return memo_E[tid]\n        \n        task_info = tasks_data[tid]\n        duration = all_durations[tid]\n        \n        max_pred_E = 0.0\n        if task_info[\"deps\"]:\n            max_pred_E = max(get_earliest_finish(p) for p in task_info[\"deps\"])\n            \n        result = duration + max_pred_E\n        memo_E[tid] = result\n        return result\n\n    L_cp = 0.0\n    for tid in task_ids:\n        L_cp = max(L_cp, get_earliest_finish(tid))\n\n    # --- 3. Compute Average Utilization (U_bar) ---\n    total_duration_sum = sum(all_durations.values())\n    U_bar = total_duration_sum / (W * makespan_T)\n\n    # --- 4. Compute Imbalance Time Fraction (phi) ---\n    event_points = set([min_start_time, max_finish_time])\n    for tinfo in tasks_data.values():\n        event_points.add(tinfo[\"start\"])\n        event_points.add(tinfo[\"finish\"])\n    \n    sorted_events = sorted(list(event_points))\n    \n    total_imbalance_time = 0.0\n    \n    for i in range(len(sorted_events) - 1):\n        t_k = sorted_events[i]\n        t_k_plus_1 = sorted_events[i+1]\n        interval_duration = t_k_plus_1 - t_k\n        \n        if interval_duration = 1e-9: # Effectively zero\n            continue\n\n        # Evaluate B(t_k) and R(t_k) at the start of the interval [t_k, t_k+1)\n        B_tk = 0\n        for tinfo in tasks_data.values():\n            if tinfo[\"start\"] = t_k  tinfo[\"finish\"]:\n                B_tk += 1\n        \n        idle_workers = W - B_tk\n        \n        # If no idle workers, no imbalance possible in this interval\n        if idle_workers = 0:\n            continue\n\n        R_tk = 0\n        for tid, tinfo in tasks_data.items():\n            if tinfo[\"start\"] > t_k: # Not yet running\n                # Check if all predecessors are finished by time t_k\n                max_pred_finish_time = 0.0\n                if tinfo[\"deps\"]:\n                    max_pred_finish_time = max(tasks_data[p][\"finish\"] for p in tinfo[\"deps\"])\n                \n                if max_pred_finish_time = t_k: # Ready\n                    R_tk += 1\n        \n        I_tk = 1 if R_tk > 0 else 0\n        \n        total_imbalance_time += I_tk * interval_duration\n\n    phi = total_imbalance_time / makespan_T if makespan_T > 0 else 0.0\n    \n    return [round(L_cp, 6), round(makespan_T, 6), round(U_bar, 6), round(phi, 6)]\n\n# To enable running this code standalone for verification\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}