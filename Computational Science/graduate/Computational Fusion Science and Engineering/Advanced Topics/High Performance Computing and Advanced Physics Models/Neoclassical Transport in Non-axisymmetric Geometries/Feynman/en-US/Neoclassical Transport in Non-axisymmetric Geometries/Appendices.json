{
    "hands_on_practices": [
        {
            "introduction": "Before we can analyze transport, we need a precise mathematical description of the complex, twisted magnetic surfaces in a stellarator. This practice  grounds you in the fundamentals of differential geometry by having you derive the metric tensor, whose components like $g_{\\theta\\theta}$ and $g_{\\theta\\zeta}$ define the arc-length element $d\\ell^2$. By calculating these terms directly from a coordinate parameterization of a model stellarator surface, you will develop a foundational skill essential for understanding how geometry dictates the physics of particle motion.",
            "id": "4018915",
            "problem": "Consider a three-dimensional toroidal plasma configuration representative of a non-axisymmetric stellarator-like flux surface. Let $\\psi$ label nested toroidal magnetic flux surfaces, and on a fixed surface $\\psi=\\psi_0$ define the constant minor radius $r=r(\\psi_0)$. Introduce poloidal and toroidal computational angles $(\\theta,\\zeta)$ and let the geometric (cylindrical) coordinates $(R,\\phi,Z)$ be given by the following coordinate mapping:\n$$\nR(\\psi_0,\\theta,\\zeta) \\equiv R_0 + r\\left[\\cos\\theta + \\varepsilon \\cos\\!\\left(m\\theta - n\\zeta\\right)\\right],\\qquad\n\\phi(\\psi_0,\\theta,\\zeta) \\equiv \\zeta,\\qquad\nZ(\\psi_0,\\theta,\\zeta) \\equiv \\kappa\\,r\\left[\\sin\\theta + \\varepsilon_Z \\sin\\!\\left(m\\theta - n\\zeta\\right)\\right],\n$$\nwhere $R_0>0$ is the major radius, $\\kappa>0$ is the elongation, and $\\varepsilon,\\varepsilon_Z$ are shape amplitudes associated with a helical perturbation of mode numbers $m\\in\\mathbb{Z}^+$ and $n\\in\\mathbb{Z}^+$. Embed this surface in Euclidean three-dimensional space using Cartesian coordinates via\n$$\nx = R\\cos\\phi,\\qquad y = R\\sin\\phi,\\qquad z = Z,\n$$\nso that the position vector is $\\boldsymbol{r}(\\theta,\\zeta) = \\big(R(\\theta,\\zeta)\\cos\\zeta,\\;R(\\theta,\\zeta)\\sin\\zeta,\\;Z(\\theta,\\zeta)\\big)$ at fixed $\\psi=\\psi_0$.\n\nStarting from the Euclidean line element $d\\ell^2 = dx^2 + dy^2 + dz^2$ and the definition of covariant metric coefficients $g_{ij} = \\partial_i \\boldsymbol{r}\\cdot \\partial_j \\boldsymbol{r}$ for $i,j\\in\\{\\theta,\\zeta\\}$ at fixed $\\psi=\\psi_0$, derive the metric coefficients $g_{\\theta\\theta}$, $g_{\\zeta\\zeta}$, and $g_{\\theta\\zeta}$ for this mapping without invoking any pre-tabulated geometry formulas. Then compute the arc-length element on the surface,\n$$\nd\\ell^2 \\;=\\; g_{\\theta\\theta}\\,d\\theta^2 \\;+\\; 2\\,g_{\\theta\\zeta}\\,d\\theta\\,d\\zeta \\;+\\; g_{\\zeta\\zeta}\\,d\\zeta^2,\n$$\nas an explicit closed-form analytic function of $(\\theta,\\zeta)$ and the parameters $(R_0,r,\\kappa,\\varepsilon,\\varepsilon_Z,m,n)$. Treat $r$, $R_0$, $\\kappa$, $\\varepsilon$, $\\varepsilon_Z$, $m$, and $n$ as constants with respect to $\\theta$ and $\\zeta$. Your final boxed answer must be a single closed-form analytic expression for $d\\ell^2$ in terms of $\\theta$ and $\\zeta$ only (with any auxiliary phase combinations defined within the expression). No numerical evaluation is required and no rounding is necessary. Express trigonometric arguments in radians.",
            "solution": "The problem is valid. It is a well-posed, scientifically grounded problem in differential geometry applied to plasma physics, requiring the calculation of the metric tensor for a parameterized surface. All necessary information is provided, and the task is to perform a direct derivation without relying on pre-tabulated formulas.\n\nThe objective is to compute the arc-length element $d\\ell^2$ on the specified toroidal surface. The surface is parameterized by the coordinates $(\\theta, \\zeta)$, and its embedding in three-dimensional Euclidean space is given by the position vector $\\boldsymbol{r}(\\theta, \\zeta)$. The arc-length element is defined by the quadratic form $d\\ell^2 = d\\boldsymbol{r} \\cdot d\\boldsymbol{r}$.\n\nThe total differential of the position vector $\\boldsymbol{r}$ is given by\n$$d\\boldsymbol{r} = \\frac{\\partial \\boldsymbol{r}}{\\partial \\theta} d\\theta + \\frac{\\partial \\boldsymbol{r}}{\\partial \\zeta} d\\zeta$$\nThe squared arc-length element is therefore\n$$d\\ell^2 = d\\boldsymbol{r} \\cdot d\\boldsymbol{r} = \\left(\\frac{\\partial \\boldsymbol{r}}{\\partial \\theta} \\cdot \\frac{\\partial \\boldsymbol{r}}{\\partial \\theta}\\right) d\\theta^2 + 2\\left(\\frac{\\partial \\boldsymbol{r}}{\\partial \\theta} \\cdot \\frac{\\partial \\boldsymbol{r}}{\\partial \\zeta}\\right) d\\theta d\\zeta + \\left(\\frac{\\partial \\boldsymbol{r}}{\\partial \\zeta} \\cdot \\frac{\\partial \\boldsymbol{r}}{\\partial \\zeta}\\right) d\\zeta^2$$\nThis expression is of the form $d\\ell^2 = g_{\\theta\\theta}\\,d\\theta^2 + 2 g_{\\theta\\zeta}\\,d\\theta d\\zeta + g_{\\zeta\\zeta}\\,d\\zeta^2$, where the covariant metric coefficients are defined as $g_{ij} = \\partial_i \\boldsymbol{r} \\cdot \\partial_j \\boldsymbol{r}$. Our task is to calculate these coefficients.\n\nFirst, we write the position vector $\\boldsymbol{r}$ in Cartesian coordinates $(x,y,z)$. Using the provided transformations $x = R\\cos\\phi$, $y = R\\sin\\phi$, $z=Z$, and $\\phi=\\zeta$, we have\n$$\\boldsymbol{r}(\\theta,\\zeta) = \\large( R(\\theta,\\zeta)\\cos\\zeta, \\;R(\\theta,\\zeta)\\sin\\zeta, \\;Z(\\theta,\\zeta) \\large)$$\nwhere\n$$R(\\theta,\\zeta) = R_0 + r\\left[\\cos\\theta + \\varepsilon \\cos(m\\theta - n\\zeta)\\right]$$\n$$Z(\\theta,\\zeta) = \\kappa\\,r\\left[\\sin\\theta + \\varepsilon_Z \\sin(m\\theta - n\\zeta)\\right]$$\nTo simplify notation, let the helical phase angle be $\\alpha(\\theta, \\zeta) = m\\theta - n\\zeta$.\n\nNext, we compute the tangent vectors $\\partial_\\theta \\boldsymbol{r} = \\frac{\\partial \\boldsymbol{r}}{\\partial \\theta}$ and $\\partial_\\zeta \\boldsymbol{r} = \\frac{\\partial \\boldsymbol{r}}{\\partial \\zeta}$. This requires the partial derivatives of $R$ and $Z$:\n$$\\frac{\\partial R}{\\partial \\theta} = r\\left[-\\sin\\theta - m\\,\\varepsilon \\sin(m\\theta - n\\zeta)\\right] = -r(\\sin\\theta + m\\varepsilon\\sin\\alpha)$$\n$$\\frac{\\partial R}{\\partial \\zeta} = r\\left[n\\,\\varepsilon \\sin(m\\theta - n\\zeta)\\right] = n r \\varepsilon \\sin\\alpha$$\n$$\\frac{\\partial Z}{\\partial \\theta} = \\kappa r\\left[\\cos\\theta + m\\,\\varepsilon_Z \\cos(m\\theta - n\\zeta)\\right] = \\kappa r(\\cos\\theta + m\\varepsilon_Z\\cos\\alpha)$$\n$$\\frac{\\partial Z}{\\partial \\zeta} = \\kappa r\\left[-n\\,\\varepsilon_Z \\cos(m\\theta - n\\zeta)\\right] = -n\\kappa r \\varepsilon_Z \\cos\\alpha$$\n\nUsing the product and chain rules, the tangent vectors are:\n$$\\partial_\\theta \\boldsymbol{r} = \\left( \\frac{\\partial R}{\\partial \\theta} \\cos\\zeta, \\; \\frac{\\partial R}{\\partial \\theta} \\sin\\zeta, \\; \\frac{\\partial Z}{\\partial \\theta} \\right)$$\n$$\\partial_\\zeta \\boldsymbol{r} = \\left( \\frac{\\partial R}{\\partial \\zeta} \\cos\\zeta - R \\sin\\zeta, \\; \\frac{\\partial R}{\\partial \\zeta} \\sin\\zeta + R \\cos\\zeta, \\; \\frac{\\partial Z}{\\partial \\zeta} \\right)$$\n\nNow we compute the metric coefficients by taking the dot products of these tangent vectors.\nFor $g_{\\theta\\theta}$:\n$$g_{\\theta\\theta} = \\partial_\\theta \\boldsymbol{r} \\cdot \\partial_\\theta \\boldsymbol{r} = \\left(\\frac{\\partial R}{\\partial \\theta}\\right)^2 \\cos^2\\zeta + \\left(\\frac{\\partial R}{\\partial \\theta}\\right)^2 \\sin^2\\zeta + \\left(\\frac{\\partial Z}{\\partial \\theta}\\right)^2$$\n$$g_{\\theta\\theta} = \\left(\\frac{\\partial R}{\\partial \\theta}\\right)^2 + \\left(\\frac{\\partial Z}{\\partial \\theta}\\right)^2$$\nSubstituting the derivatives:\n$$g_{\\theta\\theta} = \\left[-r(\\sin\\theta + m\\varepsilon\\sin\\alpha)\\right]^2 + \\left[\\kappa r(\\cos\\theta + m\\varepsilon_Z\\cos\\alpha)\\right]^2$$\n$$g_{\\theta\\theta} = r^2(\\sin\\theta + m\\varepsilon\\sin\\alpha)^2 + \\kappa^2 r^2(\\cos\\theta + m\\varepsilon_Z\\cos\\alpha)^2$$\n\nFor $g_{\\zeta\\zeta}$:\n$$g_{\\zeta\\zeta} = \\partial_\\zeta \\boldsymbol{r} \\cdot \\partial_\\zeta \\boldsymbol{r} = \\left(\\frac{\\partial R}{\\partial \\zeta} \\cos\\zeta - R \\sin\\zeta\\right)^2 + \\left(\\frac{\\partial R}{\\partial \\zeta} \\sin\\zeta + R \\cos\\zeta\\right)^2 + \\left(\\frac{\\partial Z}{\\partial \\zeta}\\right)^2$$\nExpanding the first two terms:\n$$(\\ldots) = \\left(\\frac{\\partial R}{\\partial \\zeta}\\right)^2\\cos^2\\zeta - 2R\\frac{\\partial R}{\\partial \\zeta}\\cos\\zeta\\sin\\zeta + R^2\\sin^2\\zeta + \\left(\\frac{\\partial R}{\\partial \\zeta}\\right)^2\\sin^2\\zeta + 2R\\frac{\\partial R}{\\partial \\zeta}\\sin\\zeta\\cos\\zeta + R^2\\cos^2\\zeta$$\n$$(\\ldots) = \\left(\\frac{\\partial R}{\\partial \\zeta}\\right)^2(\\cos^2\\zeta+\\sin^2\\zeta) + R^2(\\sin^2\\zeta+\\cos^2\\zeta) = \\left(\\frac{\\partial R}{\\partial \\zeta}\\right)^2 + R^2$$\nThus,\n$$g_{\\zeta\\zeta} = R^2 + \\left(\\frac{\\partial R}{\\partial \\zeta}\\right)^2 + \\left(\\frac{\\partial Z}{\\partial \\zeta}\\right)^2$$\nSubstituting the expressions for $R$ and the derivatives:\n$$g_{\\zeta\\zeta} = \\left(R_0 + r(\\cos\\theta + \\varepsilon \\cos\\alpha)\\right)^2 + (n r \\varepsilon \\sin\\alpha)^2 + (-n\\kappa r \\varepsilon_Z \\cos\\alpha)^2$$\n$$g_{\\zeta\\zeta} = \\left(R_0 + r(\\cos\\theta + \\varepsilon \\cos\\alpha)\\right)^2 + n^2 r^2 \\varepsilon^2 \\sin^2\\alpha + n^2 \\kappa^2 r^2 \\varepsilon_Z^2 \\cos^2\\alpha$$\n\nFor the cross-term $g_{\\theta\\zeta}$:\n$$g_{\\theta\\zeta} = \\partial_\\theta \\boldsymbol{r} \\cdot \\partial_\\zeta \\boldsymbol{r} = \\left(\\frac{\\partial R}{\\partial \\theta} \\cos\\zeta\\right)\\left(\\frac{\\partial R}{\\partial \\zeta} \\cos\\zeta - R \\sin\\zeta\\right) + \\left(\\frac{\\partial R}{\\partial \\theta} \\sin\\zeta\\right)\\left(\\frac{\\partial R}{\\partial \\zeta} \\sin\\zeta + R \\cos\\zeta\\right) + \\frac{\\partial Z}{\\partial \\theta}\\frac{\\partial Z}{\\partial \\zeta}$$\nExpanding the first two terms:\n$$(\\ldots) = \\frac{\\partial R}{\\partial \\theta}\\frac{\\partial R}{\\partial \\zeta}\\cos^2\\zeta - R\\frac{\\partial R}{\\partial \\theta}\\cos\\zeta\\sin\\zeta + \\frac{\\partial R}{\\partial \\theta}\\frac{\\partial R}{\\partial \\zeta}\\sin^2\\zeta + R\\frac{\\partial R}{\\partial \\theta}\\sin\\zeta\\cos\\zeta = \\frac{\\partial R}{\\partial \\theta}\\frac{\\partial R}{\\partial \\zeta}(\\cos^2\\zeta+\\sin^2\\zeta) = \\frac{\\partial R}{\\partial \\theta}\\frac{\\partial R}{\\partial \\zeta}$$\nThus,\n$$g_{\\theta\\zeta} = \\frac{\\partial R}{\\partial \\theta}\\frac{\\partial R}{\\partial \\zeta} + \\frac{\\partial Z}{\\partial \\theta}\\frac{\\partial Z}{\\partial \\zeta}$$\nSubstituting the derivatives:\n$$g_{\\theta\\zeta} = \\left[-r(\\sin\\theta + m\\varepsilon\\sin\\alpha)\\right]\\left[n r \\varepsilon \\sin\\alpha\\right] + \\left[\\kappa r(\\cos\\theta + m\\varepsilon_Z\\cos\\alpha)\\right]\\left[-n\\kappa r \\varepsilon_Z \\cos\\alpha\\right]$$\n$$g_{\\theta\\zeta} = -n r^2 \\varepsilon\\sin\\alpha(\\sin\\theta + m\\varepsilon\\sin\\alpha) - n\\kappa^2 r^2 \\varepsilon_Z\\cos\\alpha(\\cos\\theta + m\\varepsilon_Z\\cos\\alpha)$$\n$$g_{\\theta\\zeta} = -n r^2 \\left[ \\varepsilon\\sin\\theta\\sin\\alpha + m\\varepsilon^2\\sin^2\\alpha + \\kappa^2\\varepsilon_Z\\cos\\theta\\cos\\alpha + \\kappa^2 m\\varepsilon_Z^2\\cos^2\\alpha \\right]$$\n\nFinally, we assemble the complete expression for the arc-length element $d\\ell^2$:\n$$d\\ell^2 = g_{\\theta\\theta}\\,d\\theta^2 + 2\\,g_{\\theta\\zeta}\\,d\\theta\\,d\\zeta + g_{\\zeta\\zeta}\\,d\\zeta^2$$\nSubstituting the derived coefficient expressions yields the final result.\n$$d\\ell^2 = \\left[ r^2(\\sin\\theta + m\\varepsilon\\sin\\alpha)^2 + \\kappa^2 r^2(\\cos\\theta + m\\varepsilon_Z\\cos\\alpha)^2 \\right] d\\theta^2$$\n$$- 2 n r^2 \\left[ \\varepsilon\\sin\\theta\\sin\\alpha + m\\varepsilon^2\\sin^2\\alpha + \\kappa^2\\varepsilon_Z\\cos\\theta\\cos\\alpha + \\kappa^2 m\\varepsilon_Z^2\\cos^2\\alpha \\right] d\\theta d\\zeta$$\n$$+ \\left[ (R_0 + r(\\cos\\theta + \\varepsilon\\cos\\alpha))^2 + n^2 r^2 \\varepsilon^2 \\sin^2\\alpha + n^2 \\kappa^2 r^2 \\varepsilon_Z^2 \\cos^2\\alpha \\right] d\\zeta^2$$\nwhere $\\alpha = m\\theta - n\\zeta$. This is the explicit closed-form analytic expression for the squared arc-length element on the surface as a function of $(\\theta, \\zeta)$ and the given parameters. The trigonometric arguments are implicitly in radians.",
            "answer": "$$\n\\boxed{\n\\begin{aligned}\n\\text{Let } \\alpha = m\\theta - n\\zeta.\\text{ Then } d\\ell^2 = & \\left[ r^2(\\sin\\theta + m\\varepsilon\\sin\\alpha)^2 + \\kappa^2 r^2(\\cos\\theta + m\\varepsilon_Z\\cos\\alpha)^2 \\right] d\\theta^2 \\\\\n& - 2 n r^2 \\left[ \\varepsilon\\sin\\theta\\sin\\alpha + m\\varepsilon^2\\sin^2\\alpha + \\kappa^2\\varepsilon_Z\\cos\\theta\\cos\\alpha + \\kappa^2 m\\varepsilon_Z^2\\cos^2\\alpha \\right] d\\theta d\\zeta \\\\\n& + \\left[ (R_0 + r(\\cos\\theta + \\varepsilon\\cos\\alpha))^2 + n^2 r^2 \\varepsilon^2 \\sin^2\\alpha + n^2 \\kappa^2 r^2 \\varepsilon_Z^2 \\cos^2\\alpha \\right] d\\zeta^2\n\\end{aligned}\n}\n$$"
        },
        {
            "introduction": "Advanced drift-kinetic codes often calculate transport coefficients for particles at a single speed, yielding a monoenergetic coefficient $K(v)$. To obtain a macroscopic transport coefficient $\\langle K \\rangle$ useful in fluid models, one must average these results over the thermal distribution of particles. This computational exercise  tasks you with implementing this crucial convolution with a Maxwellian distribution, demonstrating how to bridge the gap between microscopic kinetic simulations and observable, thermally-averaged transport rates.",
            "id": "4018971",
            "problem": "You are asked to compute thermally averaged neoclassical transport coefficients in non-axisymmetric geometries by convolving monoenergetic results with Maxwellian weights and implementing the integral over speed. The fundamental base for this task is the Maxwell–Boltzmann distribution and the definition of a thermal average. Consider a flux-surface-averaged monoenergetic diffusion-like transport coefficient $K(v)$, which depends on particle speed $v$ and encodes physics such as collision-limited transport, ripple-induced $1/v$-like behavior, and resonance features due to non-axisymmetric magnetic wells. The thermal average of $K(v)$ for a species of mass $m$ at temperature $T$ is defined as the integral of $K(v)$ against the isotropic Maxwellian speed distribution.\n\nUse the following well-tested facts as the starting point:\n\n- The isotropic Maxwellian speed distribution for a particle of mass $m$ and temperature $T$ (with $T$ given in electronvolts and converted to Joules as $T_J = T \\cdot e$, where $e$ is the elementary charge) is\n$$\nf_v(v) = 4\\pi v^2 \\left( \\frac{m}{2\\pi T_J} \\right)^{3/2} \\exp\\!\\left(-\\frac{m v^2}{2 T_J}\\right),\n$$\nwhich is normalized so that\n$$\n\\int_{0}^{\\infty} f_v(v)\\, dv = 1.\n$$\n\n- The thermal average of $K(v)$ is\n$$\n\\langle K \\rangle = \\int_{0}^{\\infty} K(v)\\, f_v(v)\\, dv.\n$$\n\nFor the purposes of algorithmic implementation and testability, take the monoenergetic coefficient to be given by the parametric family\n$$\nK(v) = D_0 \\left[ a \\left(\\frac{v}{v_{\\mathrm{th}}}\\right)^p + b \\left(\\frac{v_{\\mathrm{th}}}{v+\\epsilon}\\right) + \\lambda \\exp\\!\\left( -\\frac{(v - \\eta v_{\\mathrm{th}})^2}{2\\sigma^2} \\right) \\right],\n$$\nwhere $v_{\\mathrm{th}} = \\sqrt{\\frac{2 T_J}{m}}$ is the thermal speed, $D_0$ is a diffusion scale in $\\mathrm{m^2/s}$, and $a$, $p$, $b$, $\\lambda$, $\\eta$ are dimensionless parameters, while $\\epsilon$ and $\\sigma$ have units of $\\mathrm{m/s}$. This form is constructed to capture three qualitative regimes seen in non-axisymmetric neoclassical transport: collision/plateau scaling via $a \\left(\\frac{v}{v_{\\mathrm{th}}}\\right)^p$, ripple/banana-like $1/v$-regularized behavior via $b \\left(\\frac{v_{\\mathrm{th}}}{v+\\epsilon}\\right)$, and non-axisymmetric resonant peaks via the Gaussian term centered near $v \\approx \\eta v_{\\mathrm{th}}$.\n\nYour task is to:\n- Derive an algorithmically convenient representation of the integral for $\\langle K \\rangle$ and implement it numerically.\n- Compute $\\langle K \\rangle$ for the provided test suite.\n- Express the final answers for all cases in $\\mathrm{m^2/s}$ as floating-point numbers.\n\nAngle units are not required. There are no percentages in this task. All physical quantities are to be treated in the International System of Units. Temperature values are provided in electronvolts and must be converted to Joules using the elementary charge.\n\nTest suite and parameters:\nUse the elementary charge $e = 1.602176634\\times 10^{-19}\\ \\mathrm{C}$ (so $1\\ \\mathrm{eV} = e\\ \\mathrm{J}$) and the atomic mass unit $\\mathrm{amu} = 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$. For each case, $m$ is the species mass, $T$ is the temperature in electronvolts, and the other parameters define $K(v)$.\n\n- Case $1$ (happy path, deuterium ions):\n  - $m = 3.343583719\\times 10^{-27}\\ \\mathrm{kg}$,\n  - $T = 1000\\ \\mathrm{eV}$,\n  - $D_0 = 0.5\\ \\mathrm{m^2/s}$,\n  - $a = 0.3$, $p = 1.0$, $b = 0.08$, $\\epsilon = 50.0\\ \\mathrm{m/s}$, $\\lambda = 0.15$, $\\eta = 0.8$, $\\sigma = 1.2\\times 10^{5}\\ \\mathrm{m/s}$.\n\n- Case $2$ (boundary, very low temperature):\n  - $m = 3.343583719\\times 10^{-27}\\ \\mathrm{kg}$,\n  - $T = 1\\ \\mathrm{eV}$,\n  - $D_0 = 0.5\\ \\mathrm{m^2/s}$,\n  - $a = 0.2$, $p = 2.0$, $b = 0.3$, $\\epsilon = 1.0\\ \\mathrm{m/s}$, $\\lambda = 0.0$, $\\eta = 1.0$, $\\sigma = 1.0\\times 10^{5}\\ \\mathrm{m/s}$.\n\n- Case $3$ (electron, high temperature, resonance-dominated):\n  - $m = 9.10938356\\times 10^{-31}\\ \\mathrm{kg}$,\n  - $T = 10000\\ \\mathrm{eV}$,\n  - $D_0 = 0.05\\ \\mathrm{m^2/s}$,\n  - $a = 0.1$, $p = 0.0$, $b = 0.02$, $\\epsilon = 1.0\\times 10^{-3}\\ \\mathrm{m/s}$, $\\lambda = 0.05$, $\\eta = 1.5$, $\\sigma = 2.0\\times 10^{6}\\ \\mathrm{m/s}$.\n\n- Case $4$ (edge case, constant coefficient, heavy impurity):\n  - $m = 183.84\\times \\mathrm{amu}\\ \\mathrm{kg}$,\n  - $T = 50\\ \\mathrm{eV}$,\n  - $D_0 = 0.02\\ \\mathrm{m^2/s}$,\n  - $a = 1.0$, $p = 0.0$, $b = 0.0$, $\\epsilon = 0.0\\ \\mathrm{m/s}$, $\\lambda = 0.0$, $\\eta = 1.0$, $\\sigma = 1.0\\times 10^{5}\\ \\mathrm{m/s}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[result_1,result_2,result_3,result_4]$). Each entry is the thermally averaged coefficient $\\langle K \\rangle$ for the corresponding case, in $\\mathrm{m^2/s}$, as a floating-point number.",
            "solution": "The problem requires the computation of the thermally averaged neoclassical transport coefficient, denoted as $\\langle K \\rangle$. This is achieved by integrating a given monoenergetic transport coefficient, $K(v)$, over all particle speeds $v$, weighted by the Maxwellian speed distribution, $f_v(v)$.\n\nThe fundamental definition of the thermal average is given by the integral:\n$$\n\\langle K \\rangle = \\int_{0}^{\\infty} K(v)\\, f_v(v)\\, dv\n$$\nThe problem provides the explicit forms for both the Maxwellian distribution and the monoenergetic coefficient.\nThe isotropic Maxwellian speed distribution for particles of mass $m$ at a temperature $T$ (in electronvolts, converted to Joules as $T_J = T \\cdot e$) is:\n$$\nf_v(v) = 4\\pi v^2 \\left( \\frac{m}{2\\pi T_J} \\right)^{3/2} \\exp\\!\\left(-\\frac{m v^2}{2 T_J}\\right)\n$$\nThis distribution is normalized such that its integral over all speeds from $0$ to $\\infty$ is $1$.\n\nThe monoenergetic coefficient $K(v)$ is a parametric model designed to capture various transport phenomena:\n$$\nK(v) = D_0 \\left[ a \\left(\\frac{v}{v_{\\mathrm{th}}}\\right)^p + b \\left(\\frac{v_{\\mathrm{th}}}{v+\\epsilon}\\right) + \\lambda \\exp\\!\\left( -\\frac{(v - \\eta v_{\\mathrm{th}})^2}{2\\sigma^2} \\right) \\right]\n$$\nwhere $v_{\\mathrm{th}} = \\sqrt{2 T_J / m}$ is the thermal speed.\n\nTo develop a robust and efficient algorithm, we first simplify the integral by a change of variables. We introduce a dimensionless speed variable $x = v/v_{\\mathrm{th}}$. This implies $v = x v_{\\mathrm{th}}$ and the differential element becomes $dv = v_{\\mathrm{th}} dx$. This change of variables is advantageous as it normalizes the speed by its characteristic thermal scale, making the integrand's behavior more universal across different temperatures and masses.\n\nUnder this transformation, the Maxwellian distribution differential element $f_v(v)dv$ simplifies to a dimensionless form, which we denote $g(x)dx$:\n$$\ng(x)dx = \\frac{4}{\\sqrt{\\pi}} x^2 e^{-x^2} dx\n$$\nThe function $g(x)$ represents the probability distribution for the dimensionless speed $x$, and it is also normalized to unity, $\\int_0^\\infty g(x) dx = 1$.\n\nThe monoenergetic coefficient $K(v)$ is also re-expressed as a function of $x$:\n$$\nK(v(x)) = D_0 \\left[ a x^p + \\frac{b v_{\\mathrm{th}}}{x v_{\\mathrm{th}} + \\epsilon} + \\lambda \\exp\\!\\left( -\\frac{v_{\\mathrm{th}}^2(x - \\eta)^2}{2\\sigma^2} \\right) \\right]\n$$\nCombining these results, the thermal average $\\langle K \\rangle$ is expressed as an integral over the dimensionless speed $x$ from $0$ to $\\infty$:\n$$\n\\langle K \\rangle = \\int_0^\\infty K(v(x)) g(x) dx\n$$\nThe integrand, $I(x) = K(v(x)) g(x)$, consists of terms that are, in general, analytically complex to integrate. However, the presence of the $e^{-x^2}$ factor from $g(x)$ ensures that the integrand decays rapidly for large $x$, making the integral well-behaved and highly suitable for numerical quadrature methods.\n\nThe computational algorithm is thus as follows:\n1.  For each test case, we first calculate the intermediate physical quantities: the temperature in Joules, $T_J = T \\cdot e$, and the corresponding thermal speed, $v_{\\mathrm{th}} = \\sqrt{2T_J/m}$.\n2.  We construct a function that computes the value of the full integrand, $I(x) = K(v(x)) g(x)$, for a given $x$ and the set of parameters for the specific test case.\n3.  We employ a high-quality numerical quadrature routine, specifically `scipy.integrate.quad` from the SciPy library, to evaluate the definite integral of this function over the semi-infinite interval $[0, \\infty)$. This adaptive routine is capable of handling the integrand's behavior, including the potentially sharp resonance peak described by the Gaussian term in $K(v)$.\n\nA special case arises in Case 4, where $p=0$, $b=0$, and $\\lambda=0$. Here, the monoenergetic coefficient simplifies to a constant, $K(v) = D_0 \\cdot a$. The thermal average then becomes:\n$$\n\\langle K \\rangle = \\int_0^\\infty (D_0 \\cdot a) f_v(v) dv = D_0 \\cdot a \\int_0^\\infty f_v(v) dv = D_0 \\cdot a\n$$\nThis is because of the normalization of $f_v(v)$. This analytical result serves as a valuable sanity check for the overall methodology and can be used for direct computation in that specific case. The implemented code will handle this special case for efficiency and accuracy, while using numerical integration for all other cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes thermally averaged neoclassical transport coefficients for a given set of test cases.\n    \"\"\"\n    # Physical constants\n    e_charge = 1.602176634e-19  # Elementary charge in Coulombs\n    amu = 1.66053906660e-27      # Atomic mass unit in kg\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        # Case 1 (happy path, deuterium ions)\n        {\n            \"m\": 3.343583719e-27, \"T\": 1000.0, \"D0\": 0.5,\n            \"a\": 0.3, \"p\": 1.0, \"b\": 0.08, \"epsilon\": 50.0,\n            \"lamb\": 0.15, \"eta\": 0.8, \"sigma\": 1.2e5\n        },\n        # Case 2 (boundary, very low temperature)\n        {\n            \"m\": 3.343583719e-27, \"T\": 1.0, \"D0\": 0.5,\n            \"a\": 0.2, \"p\": 2.0, \"b\": 0.3, \"epsilon\": 1.0,\n            \"lamb\": 0.0, \"eta\": 1.0, \"sigma\": 1.0e5\n        },\n        # Case 3 (electron, high temperature, resonance-dominated)\n        {\n            \"m\": 9.10938356e-31, \"T\": 10000.0, \"D0\": 0.05,\n            \"a\": 0.1, \"p\": 0.0, \"b\": 0.02, \"epsilon\": 1.0e-3,\n            \"lamb\": 0.05, \"eta\": 1.5, \"sigma\": 2.0e6\n        },\n        # Case 4 (edge case, constant coefficient, heavy impurity)\n        {\n            \"m\": 183.84 * amu, \"T\": 50.0, \"D0\": 0.02,\n            \"a\": 1.0, \"p\": 0.0, \"b\": 0.0, \"epsilon\": 0.0,\n            \"lamb\": 0.0, \"eta\": 1.0, \"sigma\": 1.0e5\n        }\n    ]\n\n    def integrand(x, v_th, D0, a, p, b, epsilon, lamb, eta, sigma):\n        \"\"\"\n        The full integrand I(x) = K(v(x)) * g(x) as a function of dimensionless speed x.\n        \"\"\"\n        # --- Monoenergetic coefficient K(v(x)) ---\n        # Term 1: Collision/plateau scaling\n        term1 = a * (x**p)\n\n        # Term 2: Ripple/banana-like 1/v regularized term\n        if b != 0:\n            term2 = b * v_th / (x * v_th + epsilon)\n        else:\n            term2 = 0.0\n\n        # Term 3: Non-axisymmetric resonant peak\n        if lamb != 0:\n            exponent = -((x - eta)**2 * v_th**2) / (2 * sigma**2)\n            term3 = lamb * np.exp(exponent)\n        else:\n            term3 = 0.0\n        \n        K_of_x = D0 * (term1 + term2 + term3)\n\n        # --- Maxwellian speed distribution weighting factor g(x) ---\n        g_x = (4.0 / np.sqrt(np.pi)) * (x**2) * np.exp(-x**2)\n\n        return K_of_x * g_x\n\n    def calculate_K_avg(params):\n        \"\"\"\n        Calculates the thermal average <K> for a single set of parameters.\n        \"\"\"\n        # Unpack parameters\n        m, T, D0 = params[\"m\"], params[\"T\"], params[\"D0\"]\n        a, p, b = params[\"a\"], params[\"p\"], params[\"b\"]\n        epsilon, lamb = params[\"epsilon\"], params[\"lamb\"]\n        eta, sigma = params[\"eta\"], params[\"sigma\"]\n\n        # Handle the analytical case where K(v) is constant\n        if b == 0.0 and lamb == 0.0 and p == 0.0:\n            return D0 * a\n\n        # Calculate intermediate physical quantities\n        T_J = T * e_charge  # Temperature in Joules\n        if T_J <= 0: # Avoid sqrt of non-positive\n            return 0.0\n\n        v_th = np.sqrt(2 * T_J / m) # Thermal speed\n\n        # Perform the numerical integration from 0 to infinity\n        args_tuple = (v_th, D0, a, p, b, epsilon, lamb, eta, sigma)\n        result, _ = quad(integrand, 0, np.inf, args=args_tuple)\n        \n        return result\n\n    results = []\n    for case_params in test_cases:\n        avg_K = calculate_K_avg(case_params)\n        results.append(avg_K)\n    \n    # Print the final results in the specified single-line format\n    print(f\"[{','.join(f'{r:.12g}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In non-axisymmetric devices, the intrinsic radial transport rates for ions and electrons, $\\Gamma_i$ and $\\Gamma_e$, are generally unequal. The plasma responds by building a radial electric field, $E_r$, that adjusts particle drifts until the fluxes balance—a condition known as ambipolarity. This practice  guides you through building a robust numerical root-finder to solve the ambipolarity condition $\\Gamma_i(E_r) = \\Gamma_e(E_r)$ for the self-consistent $E_r$, a critical parameter that strongly governs overall confinement in stellarators.",
            "id": "4018927",
            "problem": "Consider a single flux surface in a non-axisymmetric toroidal geometry parameterized in Boozer coordinates. A drift-kinetic solver (DKS) is assumed to provide neoclassical radial particle flux response coefficients for each species that quantify how the species radial particle flux depends on the radial electric field. For a species $s \\in \\{\\text{ion}, \\text{electron}\\}$, model the species radial particle flux as a function of the radial electric field $E_r$ by\n$$\n\\Gamma_s(E_r) = A_s + B_s E_r + C_s \\tanh\\!\\big( D_s\\, g\\, E_r \\big),\n$$\nwhere $A_s$, $B_s$, $C_s$, and $D_s$ are constant coefficients obtained from the drift-kinetic solver, and $g$ is a geometry factor that scales the effective phase-space precession frequency due to non-axisymmetry (for example, related to effective helical ripple and field-line curvature). Assume singly charged ions and electrons so that the ambipolarity condition reduces to\n$$\n\\Gamma_i(E_r) - \\Gamma_e(E_r) = 0.\n$$\nLet $f(E_r) \\equiv \\Gamma_i(E_r) - \\Gamma_e(E_r)$. Your task is to formulate and implement an iterative numerical scheme to solve $f(E_r) = 0$ for $E_r$ using a damped Newton method with backtracking and a relaxed Picard iteration as a fallback. You must demonstrate convergence properties by finding the solution for three distinct parameter sets that represent different non-axisymmetric geometries and transport regimes.\n\nStart from fundamental neoclassical transport principles: radial ambipolarity on a flux surface and drift-kinetic response coefficients. The target is to design and implement a robust solver that respects these principles and converges to the physically meaningful root of $f(E_r)$.\n\nImplementation requirements:\n- Define the function $f(E_r)$ and its derivative $f'(E_r)$ analytically from the given model. The derivative must be derived from the provided $\\Gamma_s(E_r)$ dependence.\n- Implement a damped Newton method with backtracking that attempts to decrease $|f(E_r)|$ monotonically and includes a safeguard for small $|f'(E_r)|$.\n- Implement a relaxed Picard iteration $E_r^{(k+1)} = E_r^{(k)} - \\lambda f(E_r^{(k)})$ with an adaptive relaxation parameter $\\lambda$ chosen from local information (e.g., using $f'(E_r)$ when available) to ensure convergence when Newton struggles.\n- Use the initial guess $E_r^{(0)} = 0$ for all test cases.\n- Use a stopping criterion based on the residual $|f(E_r)|$, specifically, $|f(E_r)| < \\varepsilon$ with $\\varepsilon = 10^{-9}$, and a maximum of $100$ iterations for each method.\n- Express the final computed radial electric field in volts per meter (V/m), rounded to three significant figures.\n\nAnalytical forms:\n- Using the model above, derive\n$$\nf(E_r) = \\big(A_i - A_e\\big) + \\big(B_i - B_e\\big) E_r + C_i \\tanh\\!\\big( D_i g E_r \\big) - C_e \\tanh\\!\\big( D_e g E_r \\big),\n$$\nand\n$$\nf'(E_r) = \\big(B_i - B_e\\big) + C_i D_i g\\, \\operatorname{sech}^2\\!\\big( D_i g E_r \\big) - C_e D_e g\\, \\operatorname{sech}^2\\!\\big( D_e g E_r \\big).\n$$\n\nTest suite:\nProvide and solve the following three scientifically plausible test cases, each specified by the tuple of parameters $(A_i, B_i, C_i, D_i, A_e, B_e, C_e, D_e, g)$.\n\n- Case $1$ (electron-root regime, typical ripple):\n  - $A_i = 30.8$, $B_i = 10^{-3}$, $C_i = 0.5$, $D_i = 10^{-4}$,\n  - $A_e = 0.8$, $B_e = -10^{-3}$, $C_e = 0.4$, $D_e = 2 \\times 10^{-4}$,\n  - $g = 1.0$.\n- Case $2$ (ion-root regime, reduced ripple):\n  - $A_i = 0.2$, $B_i = 10^{-3}$, $C_i = 0.5$, $D_i = 10^{-4}$,\n  - $A_e = 10.2$, $B_e = -10^{-3}$, $C_e = 0.4$, $D_e = 2 \\times 10^{-4}$,\n  - $g = 0.5$.\n- Case $3$ (edge case with near-cancellation of linear slopes and stronger nonlinearity, enhanced ripple):\n  - $A_i = 0.45$, $B_i = 5.1 \\times 10^{-4}$, $C_i = 0.15$, $D_i = 5 \\times 10^{-5}$,\n  - $A_e = 0.15$, $B_e = 5.0 \\times 10^{-4}$, $C_e = 0.05$, $D_e = 10^{-4}$,\n  - $g = 2.0$.\n\nNumerical details:\n- Use radians for the hyperbolic functions in the analytic expressions and standard mathematical definitions; no angle unit conversion is necessary.\n- The program must compute the root $E_r$ for each case, convert it to volts per meter (V/m), and round to three significant figures.\n\nFinal output specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3]$). Each $result$ must be the final $E_r$ in V/m, rounded to three significant figures, represented as a floating-point number.",
            "solution": "The problem presented is valid. It is scientifically grounded in the principles of neoclassical transport in magnetically confined plasmas, specifically addressing the computation of the ambipolar radial electric field in non-axisymmetric geometries. The problem is well-posed, providing a clearly defined non-linear equation, all necessary parameters for three distinct physical regimes, and explicit requirements for a robust numerical solver. The provided analytical forms for the function and its derivative are mathematically correct. The setup is self-contained, objective, and requires the application of standard numerical analysis techniques to a physically meaningful scenario.\n\nThe core of the problem is to find the root of the ambipolarity condition, which dictates that in a steady state, the total charge flux across a magnetic flux surface must be zero. For a plasma consisting of singly charged ions and electrons, this condition is expressed as $\\Gamma_i(E_r) - \\Gamma_e(E_r) = 0$, where $\\Gamma_s$ is the radial particle flux for species $s$ and $E_r$ is the radial electric field.\n\nThe species flux is modeled by the function:\n$$\n\\Gamma_s(E_r) = A_s + B_s E_r + C_s \\tanh(D_s g E_r)\n$$\nHere, $A_s$ represents diffusive flux components, $B_s E_r$ represents non-resonant drift-related transport, and the hyperbolic tangent term, $C_s \\tanh(D_s g E_r)$, models the characteristic non-linear behavior of resonant particle transport in the low-collisionality regimes of non-axisymmetric devices (e.g., the superbanana-plateau regime). The constant coefficients $A_s$, $B_s$, $C_s$, and $D_s$ are determined from computationally intensive drift-kinetic simulations, and $g$ is a geometry factor related to the magnetic field structure.\n\nOur task is to solve the non-linear equation $f(E_r) = 0$, where $f(E_r)$ is the net charge flux:\n$$\nf(E_r) \\equiv \\Gamma_i(E_r) - \\Gamma_e(E_r) = (A_i - A_e) + (B_i - B_e) E_r + C_i \\tanh(D_i g E_r) - C_e \\tanh(D_e g E_r)\n$$\nTo employ a Newton-Raphson scheme, we require the analytical derivative of $f(E_r)$ with respect to $E_r$. Using the chain rule and the identity $\\frac{d}{dx}\\tanh(x) = \\operatorname{sech}^2(x)$, we obtain:\n$$\nf'(E_r) = \\frac{df}{dE_r} = (B_i - B_e) + C_i D_i g\\, \\operatorname{sech}^2(D_i g E_r) - C_e D_e g\\, \\operatorname{sech}^2(D_e g E_r)\n$$\nThe numerical solution will be sought using a hybrid iterative method, starting from an initial guess of $E_r^{(0)} = 0$.\n\nThe primary solver is a damped Newton method with a backtracking line search. The standard Newton-Raphson update for the $k$-th iteration is:\n$$\nE_r^{(k+1)} = E_r^{(k)} - \\frac{f(E_r^{(k)})}{f'(E_r^{(k)})}\n$$\nThis update can be aggressive and may overshoot the solution or diverge. To enhance robustness, a damping factor $\\alpha \\in (0, 1]$ is introduced:\n$$\nE_r^{(k+1)} = E_r^{(k)} - \\alpha \\frac{f(E_r^{(k)})}{f'(E_r^{(k)})}\n$$\nThe backtracking algorithm determines an appropriate value for $\\alpha$ at each step. It begins with $\\alpha=1$ (the full Newton step) and checks if the new candidate solution $E_r^{(k+1)}$ reduces the magnitude of the residual, i.e., if $|f(E_r^{(k+1)})| < |f(E_r^{(k)})|$. If this condition is not met, $\\alpha$ is successively reduced (e.g., halved) and a new candidate is tested until the condition is satisfied or $\\alpha$ falls below a minimum threshold.\n\nThe Newton method may fail if the derivative $f'(E_r)$ is zero or near-zero, which can occur near local extrema of $f(E_r)$. This is a known feature in neoclassical transport, where multiple roots and local extrema can exist. The problem specifies a fallback mechanism for such situations: a relaxed Picard iteration. The form of this iteration is given as:\n$$\nE_r^{(k+1)} = E_r^{(k)} - \\lambda_k f(E_r^{(k)})\n$$\nThe relaxation parameter $\\lambda_k$ is chosen adaptively using local information. An effective choice for $\\lambda_k$, which connects this method to the Newton scheme, is to approximate the ideal step size by using the derivative: $\\lambda_k \\approx 1/f'(E_r^{(k)})$. To handle cases where $f'(E_r^{(k)})$ is small, we regularize this expression, for instance, by setting $\\lambda_k = 1 / (\\text{sign}(f'(E_r^{(k)})) \\max(|f'(E_r^{(k)})|, \\delta))$, where $\\delta$ is a small positive constant. However, for simplicity and robustness in a fallback scenario, a simpler adaptive scheme can be employed where a small, regularized step is taken in the opposite direction of the residual value, guided by the local slope. The chosen implementation will use the Newton method as its primary workhorse and only resort to a secondary, simpler step if the Newton update fails (due to a near-zero derivative or failure of the backtracking line search).\n\nThe overall algorithm proceeds as follows for each test case:\n1.  Initialize $k=0$, $E_r^{(0)} = 0$.\n2.  For $k$ from $0$ to a maximum of $100$:\n    a.  Calculate the residual $f_k = f(E_r^{(k)})$.\n    b.  Check for convergence: if $|f_k| < 10^{-9}$, terminate and return $E_r^{(k)}$.\n    c.  Calculate the derivative $f'_k = f'(E_r^{(k)})$.\n    d.  Attempt a damped Newton step. If successful (i.e., $|f'(E_r^{(k)})|$ is not too small and backtracking finds a step that reduces the residual), update $E_r^{(k+1)}$ and continue to the next iteration.\n    e.  If the Newton step fails, execute a single relaxed Picard step to generate $E_r^{(k+1)}$. This ensures the iteration makes progress.\n3.  If the maximum number of iterations is reached without convergence, report failure.\n4.  The final converged value of $E_r$ is rounded to three significant figures.\n\nThis hybrid strategy combines the rapid quadratic convergence of the Newton method where the function is well-behaved with the more cautious, robust behavior of a gradient-based method when encountering numerical difficulties, providing a reliable solver for the specified problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve for the ambipolar radial electric field for three test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple of parameters:\n    # (A_i, B_i, C_i, D_i, A_e, B_e, C_e, D_e, g)\n    test_cases = [\n        # Case 1: electron-root regime, typical ripple\n        (30.8, 1e-3, 0.5, 1e-4, 0.8, -1e-3, 0.4, 2e-4, 1.0),\n        # Case 2: ion-root regime, reduced ripple\n        (0.2, 1e-3, 0.5, 1e-4, 10.2, -1e-3, 0.4, 2e-4, 0.5),\n        # Case 3: edge case, enhanced ripple\n        (0.45, 5.1e-4, 0.15, 5e-5, 0.15, 5.0e-4, 0.05, 1e-4, 2.0),\n    ]\n\n    def _f(Er, params):\n        \"\"\"Calculates the net charge flux f(Er).\"\"\"\n        Ai, Bi, Ci, Di, Ae, Be, Ce, De, g = params\n        term_const = Ai - Ae\n        term_linear = (Bi - Be) * Er\n        term_tanh_i = Ci * np.tanh(Di * g * Er)\n        term_tanh_e = Ce * np.tanh(De * g * Er)\n        return term_const + term_linear + term_tanh_i - term_tanh_e\n\n    def _df(Er, params):\n        \"\"\"Calculates the derivative of the net charge flux df/dEr.\"\"\"\n        _, Bi, Ci, Di, _, Be, Ce, De, g = params\n        term_linear = Bi - Be\n        \n        # sech(x) = 1/cosh(x)\n        cosh_i_arg = Di * g * Er\n        sech_sq_i = (1.0 / np.cosh(cosh_i_arg))**2\n        term_sech_i = Ci * Di * g * sech_sq_i\n\n        cosh_e_arg = De * g * Er\n        sech_sq_e = (1.0 / np.cosh(cosh_e_arg))**2\n        term_sech_e = Ce * De * g * sech_sq_e\n        \n        return term_linear + term_sech_i - term_sech_e\n\n    def find_ambipolar_root(params):\n        \"\"\"\n        Finds the root of f(Er) = 0 using a hybrid Newton/Picard method.\n        \"\"\"\n        Er = 0.0\n        max_iter = 100\n        tolerance = 1e-9\n        \n        # Parameters for the numerical methods\n        deriv_min_thresh = 1e-8  # Threshold for small derivative\n        backtrack_min_alpha = 1e-5 # Minimum damping factor in backtracking\n        picard_reg_delta = 1e-2 # Regularization for adaptive Picard lambda\n\n        for _ in range(max_iter):\n            f_val = _f(Er, params)\n\n            if abs(f_val) < tolerance:\n                return Er\n\n            df_val = _df(Er, params)\n            \n            newton_failed = False\n\n            # Attempt Damped Newton Step\n            if abs(df_val) < deriv_min_thresh:\n                newton_failed = True\n            else:\n                newton_step = -f_val / df_val\n                alpha = 1.0  # Start with full Newton step\n                \n                backtrack_success = False\n                while alpha > backtrack_min_alpha:\n                    Er_candidate = Er + alpha * newton_step\n                    f_candidate = _f(Er_candidate, params)\n                    \n                    if abs(f_candidate) < abs(f_val):\n                        Er = Er_candidate\n                        backtrack_success = True\n                        break\n                    \n                    alpha /= 2.0\n                \n                if not backtrack_success:\n                    newton_failed = True\n\n            # Fallback to Relaxed Picard Iteration\n            if newton_failed:\n                # Use an adaptive, regularized lambda for the Picard step\n                # to ensure a safe but productive step.\n                lambda_param = 1.0 / max(abs(df_val), picard_reg_delta)\n                Er = Er - lambda_param * f_val\n        \n        # If loop finishes without convergence, raise an error.\n        raise RuntimeError(f\"Solver failed to converge for params: {params}\")\n\n    def round_to_sig_figs(x, n):\n        \"\"\"Rounds a number x to n significant figures.\"\"\"\n        if x == 0:\n            return 0.0\n        return float(f'{x:.{n-1}e}')\n\n    results = []\n    for case in test_cases:\n        root_Er = find_ambipolar_root(case)\n        rounded_result = round_to_sig_figs(root_Er, 3)\n        results.append(rounded_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}