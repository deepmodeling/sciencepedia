{
    "hands_on_practices": [
        {
            "introduction": "验证的第一步是建立一个现实的前向模型。本练习将指导你从基本物理原理出发，构建一个综合性的合成中子相机响应模型，其中融合了立体角等几何因素、材料衰减和屏蔽等输运过程，以及探测器特性。这是一项基础技能，让你能够为诊断测量创建逼真的仿真。",
            "id": "3948431",
            "problem": "需要构建一个中子相机 (NC) 的合成诊断工具，用于计算来自体中子源的探测计数率。该中子源沿着一条视线 (LoS) 通过准直、有限孔径立体角和结构屏蔽进行观测。目标是从第一性原理出发，推导并实现一个数值算法，该算法能为给定情景输出探测到的计数率。角度必须以弧度表示，所有物理单位必须使用国际单位制 (SI)。最终的数值答案必须以 $\\mathrm{s^{-1}}$ 表示。\n\n出发点和假设：\n- 沿直线 LoS 的中子输运通过沿特征线的一维平衡方程来建模：定向强度的变化率等于局域源项减去与物质相互作用引起的衰减。令 $s$ 表示沿 LoS 的坐标，从孔径平面量入等离子体内部，其中 $s \\in [s_0,s_1]$ 且 $s_0 \\gt 0$。\n- 体中子源是局域各向同性的，并以简化形式表示为线积分发射率密度 $q(s)$，单位为 $\\mathrm{s^{-1}\\,m^{-1}}$。这可以理解为沿 LoS 的单位长度发射率（例如，通过将体发射率在细观察管的 LoS 横截面上积分得到）。\n- 孔径为圆形，半径为 $a$，面积为 $A = \\pi a^2$，其后是一个长度为 $L$ 的圆柱形准直器。接收半角为 $\\theta_c = \\arctan\\!\\left(\\frac{a}{L}\\right)$，只有相对于孔径轴在此角锥内的射线才能通过。\n- 对于小孔径，位置 $s$ 处的点观察孔径的立体角为 $\\Omega(s) = \\frac{A \\cos\\delta}{s^2}$，其中 $\\delta$ 是 LoS 方向与孔径轴之间的固定偏置角。如果 $\\delta \\le \\theta_c$，则通过准直器的透射率为 $1$，否则为 $0$。\n- 路径上的结构屏蔽由通过均匀材料段 $i$ 的路径积分衰减来表示。这些材料段具有宏观衰减系数 $\\mu_i$（单位 $\\mathrm{m^{-1}}$）和厚度 $t_i$（单位 $\\mathrm{m}$），产生总透射因子 $T = \\exp\\!\\left(-\\sum_i \\mu_i t_i\\right)$。假设对于所有 $s \\in [s_0,s_1]$，$T$ 是恒定的。\n- 对于相关的中子能量范围，探测器具有恒定的探测效率 $\\epsilon$（无量纲）。\n\n基本原理：\n- 在稳态条件下，使用沿 LoS 的一维衰减-源平衡的特征线解，并结合由平方反比衰减和孔径立体角分数引起的几何稀释。不要假设任何预先推导的最终诊断公式；相反，应从第一性原理出发，通过对来自 $q(s)$ 的贡献进行积分来推导探测计数率，这些贡献由几何和衰减因子加权。\n\n要求的推导和计算：\n- 将探测计数率 $C$ 推导为局域源 $q(s)$ 在 $s \\in [s_0,s_1]$ 上的线积分。$q(s)$ 乘以进入孔径的各向同性发射分数 $\\frac{\\Omega(s)}{4\\pi}$、透射率 $T$ 和探测效率 $\\epsilon$，同时要满足由 $\\delta$ 和 $\\theta_c$ 定义的准直器接收约束。\n- 实现一个数值积分方法来计算通用 $q(s)$ 的积分。当 $s_0$ 很小时，对 $s \\approx s_0$ 附近的刚性贡献使用适当的绝对和相对容差。角度必须使用弧度。最终探测计数率以 $\\mathrm{s^{-1}}$ 表示。\n\n测试套件：\n为以下参数集实现计算。在每种情况下，产生一个单位为 $\\mathrm{s^{-1}}$ 的标量输出 $C$。\n\n- 案例1（正常路径，轴对齐，恒定发射率，中等屏蔽）：\n  - $a = 0.015\\,\\mathrm{m}$，$L = 0.300\\,\\mathrm{m}$，因此 $\\theta_c = \\arctan\\!\\left(\\frac{0.015}{0.300}\\right)$。\n  - $\\delta = 0.000\\,\\mathrm{rad}$。\n  - $s_0 = 0.200\\,\\mathrm{m}$，$s_1 = 2.500\\,\\mathrm{m}$。\n  - $q(s) = q_0$，其中 $q_0 = 1.0\\times 10^8\\,\\mathrm{s^{-1}\\,m^{-1}}$。\n  - 屏蔽段：钢，$\\mu = 8.0\\,\\mathrm{m^{-1}}$，$t = 0.100\\,\\mathrm{m}$；混凝土，$\\mu = 1.2\\,\\mathrm{m^{-1}}$，$t = 0.500\\,\\mathrm{m}$；硼化聚乙烯，$\\mu = 3.0\\,\\mathrm{m^{-1}}$，$t = 0.050\\,\\mathrm{m}$。\n  - $\\epsilon = 1.0\\times 10^{-6}$。\n\n- 案例2（轴对齐，指数衰减发射率，无屏蔽）：\n  - $a = 0.008\\,\\mathrm{m}$，$L = 0.200\\,\\mathrm{m}$，因此 $\\theta_c = \\arctan\\!\\left(\\frac{0.008}{0.200}\\right)$。\n  - $\\delta = 0.020\\,\\mathrm{rad}$。\n  - $s_0 = 0.500\\,\\mathrm{m}$，$s_1 = 1.500\\,\\mathrm{m}$。\n  - $q(s) = q_0 \\exp\\!\\left(-\\frac{s}{\\lambda}\\right)$，其中 $q_0 = 5.0\\times 10^8\\,\\mathrm{s^{-1}\\,m^{-1}}$，$\\lambda = 0.700\\,\\mathrm{m}$。\n  - 屏蔽段：无（设置所有 $t_i = 0.000\\,\\mathrm{m}$）。\n  - $\\epsilon = 2.0\\times 10^{-6}$。\n\n- 案例3（离轴，被准直器阻挡，恒定发射率）：\n  - $a = 0.005\\,\\mathrm{m}$，$L = 0.050\\,\\mathrm{m}$，因此 $\\theta_c = \\arctan\\!\\left(\\frac{0.005}{0.050}\\right)$。\n  - $\\delta = 0.120\\,\\mathrm{rad}$。\n  - $s_0 = 0.300\\,\\mathrm{m}$，$s_1 = 1.300\\,\\mathrm{m}$。\n  - $q(s) = q_0$，其中 $q_0 = 1.0\\times 10^8\\,\\mathrm{s^{-1}\\,m^{-1}}$。\n  - 屏蔽段：钢，$\\mu = 8.0\\,\\mathrm{m^{-1}}$，$t = 0.200\\,\\mathrm{m}$；钨，$\\mu = 25.0\\,\\mathrm{m^{-1}}$，$t = 0.100\\,\\mathrm{m}$。\n  - $\\epsilon = 1.0\\times 10^{-6}$。\n\n- 案例4（近孔径弦，高斯发射率峰值，重屏蔽）：\n  - $a = 0.012\\,\\mathrm{m}$，$L = 0.500\\,\\mathrm{m}$，因此 $\\theta_c = \\arctan\\!\\left(\\frac{0.012}{0.500}\\right)$。\n  - $\\delta = 0.000\\,\\mathrm{rad}$。\n  - $s_0 = 0.050\\,\\mathrm{m}$，$s_1 = 0.500\\,\\mathrm{m}$。\n  - $q(s) = q_0 \\exp\\!\\left(-\\frac{(s - s_c)^2}{2\\sigma^2}\\right)$，其中 $q_0 = 1.0\\times 10^9\\,\\mathrm{s^{-1}\\,m^{-1}}$，$s_c = 0.200\\,\\mathrm{m}$，$\\sigma = 0.050\\,\\mathrm{m}$。\n  - 屏蔽段：铅，$\\mu = 12.0\\,\\mathrm{m^{-1}}$，$t = 0.300\\,\\mathrm{m}$；混凝土，$\\mu = 1.0\\,\\mathrm{m^{-1}}$，$t = 0.700\\,\\mathrm{m}$。\n  - $\\epsilon = 5.0\\times 10^{-7}$。\n\n- 案例5（角度略低于截止角，线性斜坡发射率，中等屏蔽）：\n  - $a = 0.010\\,\\mathrm{m}$，$L = 0.100\\,\\mathrm{m}$，因此 $\\theta_c = \\arctan\\!\\left(\\frac{0.010}{0.100}\\right)$。\n  - $\\delta = 0.095\\,\\mathrm{rad}$。\n  - $s_0 = 0.400\\,\\mathrm{m}$，$s_1 = 1.800\\,\\mathrm{m}$。\n  - $q(s) = q_0 \\frac{s - s_0}{s_1 - s_0}$ 对于 $s \\in [s_0,s_1]$，其中 $q_0 = 2.0\\times 10^8\\,\\mathrm{s^{-1}\\,m^{-1}}$。\n  - 屏蔽段：硼化聚乙烯，$\\mu = 3.0\\,\\mathrm{m^{-1}}$，$t = 0.100\\,\\mathrm{m}$。\n  - $\\epsilon = 1.0\\times 10^{-6}$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含五个案例的探测计数率。计数率应按上述案例顺序排列，以逗号分隔，并用方括号括起来（例如，$[c_1,c_2,c_3,c_4,c_5]$）。每个 $c_i$ 都必须是单位为 $\\mathrm{s^{-1}}$ 的浮点数。",
            "solution": "我们从第一性原理出发，使用沿直线视线 (LoS) 的带源衰减的特征形式来构建合成中子相机响应。令 $s$ 表示从孔径平面到等离子体内部的距离，$s \\in [s_0,s_1]$，令 $q(s)$ 表示线积分发射率密度，单位为 $\\mathrm{s^{-1}\\,m^{-1}}$。\n\n基于原理的推导：\n1. 考虑在位置 $s$ 处的一个无穷小段 $ds$。该段的各向同性发射通过有限孔径对探测器产生贡献。对于各向同性源，进入孔径的发射中子分数是孔径立体角与全球面立体角之比：\n   $$ f_{\\Omega}(s) = \\frac{\\Omega(s)}{4\\pi}. $$\n   对于一个面积为 $A = \\pi a^2$ 的小圆形孔径，从距离 $s$ 处、相对于孔径法线有偏置角 $\\delta$ 的位置观察，其小孔径立体角为\n   $$ \\Omega(s) = \\frac{A \\cos\\delta}{s^2}. $$\n   这是根据微分立体角定义 $d\\Omega = \\frac{dA \\cos\\delta}{r^2}$，在孔径平面处取 $r = s$ 计算得出的。\n\n2. 准直器规定了角度接收范围。一个半径为 $a$、长度为 $L$ 的圆柱形准直器允许半角范围内的射线通过\n   $$ \\theta_c = \\arctan\\!\\left(\\frac{a}{L}\\right). $$\n   对于一个固定的 LoS 偏置角 $\\delta$，通过准直器的透射率为\n   $$ \\chi(\\delta) = \\begin{cases} 1,  \\delta \\le \\theta_c, \\\\ 0,  \\delta > \\theta_c. \\end{cases} $$\n\n3. 结构衰减通过比尔-朗伯定律沿屏蔽材料的路径段进行建模。对于具有宏观衰减系数 $\\mu_i$ 和厚度 $t_i$ 的材料段 $i$，总透射因子为\n   $$ T = \\exp\\!\\left(-\\sum_i \\mu_i t_i\\right). $$\n   假设屏蔽层位于孔径和等离子体之间，并且对于沿 $s \\in [s_0,s_1]$ 的所有贡献，其穿过路径都相同，则 $T$ 相对于 $s$ 是一个常数。\n\n4. 相关中子能量的探测效率 $\\epsilon$ 乘以计数率。\n\n将这些部分组合在一起，来自无穷小段 $ds$ 的贡献 $dC$ 为\n$$ dC = q(s) \\, ds \\times \\frac{\\Omega(s)}{4\\pi} \\times \\chi(\\delta) \\times T \\times \\epsilon. $$\n代入 $\\Omega(s)$ 的表达式可得\n$$ dC = q(s) \\, ds \\times \\frac{A \\cos\\delta}{4\\pi s^2} \\times \\chi(\\delta) \\times T \\times \\epsilon. $$\n对 $s \\in [s_0,s_1]$ 进行积分，得到探测计数率\n$$ C = \\left( \\frac{A \\cos\\delta}{4\\pi} \\right) \\chi(\\delta) \\, T \\, \\epsilon \\int_{s_0}^{s_1} \\frac{q(s)}{s^2} \\, ds. $$\n该表达式是从第一性原理构建的特征线解：各向同性发射、通过平方反比定律的几何稀释、立体角孔径分数、准直器接收、结构衰减和探测器效率。注意，如果 $\\delta > \\theta_c$，则 $\\chi(\\delta) = 0$ 且 $C = 0$。\n\n算法设计：\n- 对于给定的 $a$ 和 $L$，计算 $A = \\pi a^2$ 和 $\\theta_c = \\arctan\\!\\left(\\frac{a}{L}\\right)$。\n- 通过比较 $\\delta$ 和 $\\theta_c$ 来计算 $\\chi(\\delta)$。\n- 根据屏蔽段列表，使用 $T = \\exp\\!\\left(-\\sum_i \\mu_i t_i\\right)$ 计算 $T$。\n- 根据测试案例定义 $q(s)$：\n  - 恒定：$q(s) = q_0$。\n  - 指数：$q(s) = q_0 \\exp\\!\\left(-\\frac{s}{\\lambda}\\right)$。\n  - 高斯：$q(s) = q_0 \\exp\\!\\left(-\\frac{(s - s_c)^2}{2\\sigma^2}\\right)$。\n  - 线性斜坡：$q(s) = q_0 \\frac{s - s_0}{s_1 - s_0}$。\n- 使用稳健的求积法（例如，通过数值积分的自适应 Gauss–Kronrod 方法）数值计算积分\n  $$ I = \\int_{s_0}^{s_1} \\frac{q(s)}{s^2} \\, ds $$\n  并为预期的动态范围设置合适的绝对容差和相对容差。根据构造，下限 $s_0$ 严格为正，以避免发散。\n- 计算\n  $$ C = \\left( \\frac{A \\cos\\delta}{4\\pi} \\right) \\chi(\\delta) \\, T \\, \\epsilon \\, I. $$\n\n单位和验证：\n- $a$、$L$、$s_0$、$s_1$、$\\lambda$、$s_c$、$\\sigma$ 和 $t_i$ 的单位是 $\\mathrm{m}$。\n- $\\mu_i$ 的单位是 $\\mathrm{m^{-1}}$。\n- $q_0$ 和 $q(s)$ 的单位是 $\\mathrm{s^{-1}\\,m^{-1}}$。\n- $\\epsilon$ 是无量纲的。\n- $\\delta$ 和 $\\theta_c$ 的单位是弧度。\n- 输出 $C$ 的单位是 $\\mathrm{s^{-1}}$。\n- 特殊情况处理：如果 $\\delta > \\theta_c$，输出 $C = 0$；如果屏蔽为零，$T = 1$。\n\n测试套件覆盖原理：\n- 案例1测试了包含多种屏蔽材料和在长弦上具有恒定 $q(s)$ 的通用流程。\n- 案例2测试了非均匀 $q(s)$ 和无屏蔽的情况。\n- 案例3验证了当 $\\delta > \\theta_c$ 时准直器的阻挡效果。\n- 案例4探讨了在重屏蔽下，$s_0$ 较小且 $q(s)$ 呈高斯峰值时的近孔径行为。\n- 案例5研究了在准直边界附近，$q(s)$ 线性变化时的运行情况。\n\n程序输出规范：\n- 按所列顺序，为相应案例生成形如 $[c_1,c_2,c_3,c_4,c_5]$ 的单行输出，其中每个 $c_i$ 是计算出的浮点数计数率，单位为 $\\mathrm{s^{-1}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef attenuation_transmission(materials):\n    \"\"\"\n    Compute total transmission T = exp(-sum(mu_i * t_i)) for given shielding segments.\n    materials: list of (mu, t) pairs with mu in m^-1 and t in m.\n    \"\"\"\n    total_mu_t = sum(mu * t for (mu, t) in materials)\n    return np.exp(-total_mu_t)\n\ndef acceptance_half_angle(a, L):\n    \"\"\"\n    Compute collimator acceptance half-angle theta_c = arctan(a / L).\n    \"\"\"\n    return np.arctan(a / L)\n\ndef solid_angle_factor(a, delta):\n    \"\"\"\n    Compute aperture geometric factor A*cos(delta)/(4*pi) with A = pi*a^2.\n    \"\"\"\n    A = np.pi * a * a\n    return (A * np.cos(delta)) / (4.0 * np.pi)\n\ndef line_integral_q_over_s2(q_func, s0, s1):\n    \"\"\"\n    Numerically compute integral I = int_{s0}^{s1} q(s)/s^2 ds using adaptive quadrature.\n    \"\"\"\n    # Use Gauss-Kronrod (quad) with tolerances suitable for potentially sharp features.\n    I, err = integrate.quad(lambda s: q_func(s) / (s * s), s0, s1, epsabs=1e-9, epsrel=1e-9, limit=200)\n    return I\n\ndef case_constant_q(q0):\n    return lambda s: q0\n\ndef case_exponential_q(q0, lam):\n    return lambda s: q0 * np.exp(-s / lam)\n\ndef case_gaussian_q(q0, sc, sigma):\n    return lambda s: q0 * np.exp(-((s - sc) ** 2) / (2.0 * sigma * sigma))\n\ndef case_linear_ramp_q(q0, s0, s1):\n    span = s1 - s0\n    return lambda s: q0 * ((s - s0) / span)\n\ndef compute_count_rate(a, L, delta, s0, s1, q_func, materials, epsilon):\n    \"\"\"\n    Compute detected count rate C for given parameters under the model:\n    C = [A*cos(delta)/(4*pi)] * chi(delta) * T * epsilon * integral_{s0}^{s1} q(s)/s^2 ds,\n    where chi(delta) is 1 if delta = theta_c, else 0.\n    \"\"\"\n    theta_c = acceptance_half_angle(a, L)\n    if delta > theta_c:\n        return 0.0  # Collimator blocks off-axis LoS\n    T = attenuation_transmission(materials)\n    geom = solid_angle_factor(a, delta)\n    I = line_integral_q_over_s2(q_func, s0, s1)\n    C = geom * T * epsilon * I\n    return C\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"a\": 0.015,\n            \"L\": 0.300,\n            \"delta\": 0.0,\n            \"s0\": 0.200,\n            \"s1\": 2.500,\n            \"q_func\": case_constant_q(1.0e8),\n            \"materials\": [(8.0, 0.100), (1.2, 0.500), (3.0, 0.050)],\n            \"epsilon\": 1.0e-6,\n        },\n        # Case 2\n        {\n            \"a\": 0.008,\n            \"L\": 0.200,\n            \"delta\": 0.020,\n            \"s0\": 0.500,\n            \"s1\": 1.500,\n            \"q_func\": case_exponential_q(5.0e8, 0.700),\n            \"materials\": [],  # No shielding\n            \"epsilon\": 2.0e-6,\n        },\n        # Case 3\n        {\n            \"a\": 0.005,\n            \"L\": 0.050,\n            \"delta\": 0.120,\n            \"s0\": 0.300,\n            \"s1\": 1.300,\n            \"q_func\": case_constant_q(1.0e8),\n            \"materials\": [(8.0, 0.200), (25.0, 0.100)],\n            \"epsilon\": 1.0e-6,\n        },\n        # Case 4\n        {\n            \"a\": 0.012,\n            \"L\": 0.500,\n            \"delta\": 0.0,\n            \"s0\": 0.050,\n            \"s1\": 0.500,\n            \"q_func\": case_gaussian_q(1.0e9, 0.200, 0.050),\n            \"materials\": [(12.0, 0.300), (1.0, 0.700)],\n            \"epsilon\": 5.0e-7,\n        },\n        # Case 5\n        {\n            \"a\": 0.010,\n            \"L\": 0.100,\n            \"delta\": 0.095,\n            \"s0\": 0.400,\n            \"s1\": 1.800,\n            \"q_func\": case_linear_ramp_q(2.0e8, 0.400, 1.800),\n            \"materials\": [(3.0, 0.100)],\n            \"epsilon\": 1.0e-6,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        a = case[\"a\"]\n        L = case[\"L\"]\n        delta = case[\"delta\"]\n        s0 = case[\"s0\"]\n        s1 = case[\"s1\"]\n        q_func = case[\"q_func\"]\n        materials = case[\"materials\"]\n        epsilon = case[\"epsilon\"]\n\n        C = compute_count_rate(a, L, delta, s0, s1, q_func, materials, epsilon)\n        results.append(C)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "建立模型后，我们必须理解其内在能力和局限性。本练习的核心是将一个连续的测量过程（弦积分）离散化为一个矩阵算符，并分析其关键的数学特性，即矩阵的秩和条件数。通过这个过程，你将揭示诊断的几何布局如何决定哪些信息可以被可靠地反演，以及重建结果对测量噪声的敏感度，这对于设计有效的诊断系统至关重要。",
            "id": "3948452",
            "problem": "您的任务是为一个环形磁约束装置中辐射发射率的轴对称弦积分测量构建一个综合诊断正向算子。目的是通过计算在不同弦测量设置下矩阵的秩和2-范数条件数，来检验连续正向算子$H$离散化为矩阵$\\mathbf{H}$对可辨識性的影响。您的程序必须实现几何计算，并为指定的测试套件计算所要求的属性，然后将结果单行输出。\n\n基本基础和物理模型：\n- 考虑一个半径为$R$（单位：$\\mathrm{m}$）的圆形极向截面，以及一个仅取决于径向坐标$r$（$0 \\le r \\le R$）的轴对称非负发射率场$\\epsilon(r)$。\n- 测量是通过与截面相交的直线视线（弦）获得的。每条弦由其碰撞参数$b$（单位：$\\mathrm{m}$）定义，即弦与截面中心之间的最小距离。假设弦足够长，可以完全穿过截面。\n- 在轴对称假设下，每个弦积分信号是$\\epsilon(r)$沿弦穿过等离子体路径的线积分。如果发射率在同心环带上是分段常数，则测量值变为各环带贡献的线性组合，其系数与弦在每个环带内穿过的路径长度成正比。\n\n离散化：\n- 将$[0,R]$离散化为$N$个同心环带（区域），其边界均匀分布为$r_0, r_1, \\dots, r_N$，其中$r_0 = 0$，$r_n = R \\cdot n / N$（对于$n = 1,2,\\dots,N$）。\n- 令$f_n$表示第$n$个环带$(r_{n-1}, r_n]$内的恒定发射率（任意单位）。对于一条碰撞参数为$b$的弦，其测量值$s(b)$离散化为$s(b) = \\sum_{n=1}^{N} H_{n}(b) f_n$，其中$H_n(b)$是弦在第$n$个环带内的路径长度（单位：$\\mathrm{m}$）。\n- 对于$M$条碰撞参数为$b_m$（$m=1,\\dots,M$）的弦，这产生一个线性系统$\\mathbf{s} = \\mathbf{H} \\mathbf{f}$，其中$\\mathbf{H} \\in \\mathbb{R}^{M \\times N}$。\n\n$\\mathbf{H}$的几何确定：\n- 对于每条碰撞参数为$b$的弦，如果 $b  a$，其与半径为$a$的圆的相交长度为$2\\sqrt{a^2 - b^2}$，否则为$0$。环带$(r_{n-1}, r_n]$内的路径长度是与半径为$r_n$和$r_{n-1}$的圆的相交长度之差。如果仪器孔径将可观测半径限制为$R_{\\mathrm{ap}} \\le R$，则有效外边界为$\\min(r_n, R_{\\mathrm{ap}})$，有效内边界为$\\min(r_{n-1}, R_{\\mathrm{ap}})$。\n\n可辨识性度量：\n- 矩阵$\\mathbf{H}$的秩表示可从弦积分测量中辨识的发射率剖面子空间的维度。如果$\\mathrm{rank}(\\mathbf{H}) = N$，则$\\mathbf{f}$在线性意义上是可辨识的；如果 $\\mathrm{rank}(\\mathbf{H})  N$，则某些分量是不可观测的。\n- 2-范数条件数$\\kappa_2(\\mathbf{H})$等于最大奇异值与最小奇异值之比。大的$\\kappa_2(\\mathbf{H})$意味着病态问题，以及推断出的$\\mathbf{f}$对测量噪声的高度敏感性。如果最小奇异值为$0$，则$\\kappa_2(\\mathbf{H})$为无穷大。\n\n任务：\n1. 根据上述几何规则为每个测试用例构建$\\mathbf{H}$。\n2. 计算$\\mathrm{rank}(\\mathbf{H})$和$\\kappa_2(\\mathbf{H})$（使用矩阵2-范数条件数）。\n3. 按指定格式输出结果。\n\n测试套件：\n- 所有测试用例均使用$R = 1.0$ $\\mathrm{m}$和均匀环带。\n- 用例1（基准，方阵系统）：$N = 8$，$M = 8$，碰撞参数$b_m = R \\cdot [0.000, 0.125, 0.250, 0.375, 0.500, 0.625, 0.750, 0.875]$，无孔径限制。\n- 用例2（超定系统）：$N = 8$，$M = 16$，$b_m$在$[0, 0.95 R]$内线性间隔分布，无孔径限制。\n- 用例3（欠定系统）：$N = 8$，$M = 5$，碰撞参数$b_m = R \\cdot [0.000, 0.200, 0.400, 0.600, 0.800]$，无孔径限制。\n- 用例4（弦线聚类，近简并采样）：$N = 8$，$M = 8$，碰撞参数$b_m = R \\cdot [0.680, 0.690, 0.700, 0.710, 0.720, 0.730, 0.740, 0.750]$，无孔径限制。\n- 用例5（有限孔径）：$N = 8$，$M = 8$，与用例1相同的$b_m$，但$R_{\\mathrm{ap}} = 0.700 R$。\n\n输出规范：\n- 对每个用例，计算整数秩和浮点数2-范数条件数（四舍五入到6位小数）。将所有结果按顺序收集到一个列表中，交替出现秩和条件数值，即$[\\mathrm{rank}_1, \\kappa_2(\\mathbf{H}_1), \\mathrm{rank}_2, \\kappa_2(\\mathbf{H}_2), \\dots]$。\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,c_1,r_2,c_2,\\dots]$）。不应打印任何额外文本。\n\n角度单位：\n- 不使用角度；弦仅由其碰撞参数表征。\n\n单位：\n- 几何结构以$\\mathrm{m}$为单位定义，但输出量$\\mathrm{rank}(\\mathbf{H})$和$\\kappa_2(\\mathbf{H})$是无量纲的。输出不需要物理单位。\n\n约束条件：\n- 使用适用于研究生水平计算的标准线性代数工具实现，不调用超出基本基础的任何快捷公式。在处理平方根和奇异值时确保数值鲁棒性。",
            "solution": "该问题陈述经评估是有效的。它具有科学依据，提法恰当，并为聚变等离子体诊断领域的一项计算任务提供了一套完整且一致的要求。\n\n问题的核心是设计一个综合诊断模型，用于模拟具有假定轴对称截面的环形等离子体中的弦积分发射率测量。这在数学上等效于阿贝尔变换问题。我们的任务是离散化这个连续算子，并针对几种测量配置评估其产生的矩阵表示$\\mathbf{H}$的属性。评估的关键指标是矩阵的秩$\\mathrm{rank}(\\mathbf{H})$和2-范数条件数$\\kappa_2(\\mathbf{H})$。\n\n首先，我们形式化该模型。假设连续发射率剖面$\\epsilon(r)$仅依赖于小半径$r$，其中$0 \\le r \\le R$。我们将此剖面离散化为$N$个宽度均匀的同心环带。这些环带由半径$r_n = R \\cdot n / N$（$n=0, 1, \\dots, N$）定义。在每个环带$(r_{n-1}, r_n]$内，假设发射率为常数值$f_n$。这构成了对真实剖面$\\epsilon(r)$的分段常数近似。\n\n测量沿着一条直线视线（或称弦）进行，该视线由其碰撞参数$b$定义，即其到圆形截面中心的最小距离。测得的信号$s(b)$是发射率沿此弦的线积分。在我们的离散模型中，该积分变为一个和式：\n$$\ns(b) = \\sum_{n=1}^{N} H_{n}(b) f_n\n$$\n其中$H_{n}(b)$是碰撞参数为$b$的弦穿过第$n$个环带的路径长度。对于一组具有碰撞参数$b_1, \\dots, b_M$的$M$次测量，我们得到一个线性方程组：\n$$\n\\mathbf{s} = \\mathbf{H} \\mathbf{f}\n$$\n这里，$\\mathbf{s} \\in \\mathbb{R}^M$是测量向量，$\\mathbf{f} \\in \\mathbb{R}^N$是未知的环带发射率向量，而$\\mathbf{H} \\in \\mathbb{R}^{M \\times N}$是我们必须构建的正向算子矩阵。该矩阵的元素$H_{mn}$是第$m$条弦（$b_m$）穿过第$n$个环带的路径长度。\n\n矩阵元素$H_{mn}$的几何计算是核心。根据初等几何，碰撞参数为$b$的弦穿过半径为$a$的圆（其中 $b  a$）的总路径长度为$L(a, b) = 2\\sqrt{a^2 - b^2}$。如果$b \\ge a$，弦不与圆相交，路径长度为$0$。穿过一个环带$(r_{n-1}, r_n]$的路径长度是穿过由其外半径和内半径定义的两个圆的路径长度之差：\n$$\nH_{mn} = L(r_n, b_m) - L(r_{n-1}, b_m)\n$$\n此公式成立的前提是我们定义当$b \\ge a$时$L(a, b) = 0$。\n\n问题还引入了一个可选的仪器孔径$R_{\\mathrm{ap}}$，它将可观测区域限制在$r \\le R_{\\mathrm{ap}}$。为了考虑这一点，我们必须使用有效半径。穿过第$n$个环带的路径长度是使用被孔径截断的半径计算的：$r'_n = \\min(r_n, R_{\\mathrm{ap}})$和$r'_{n-1} = \\min(r_{n-1}, R_{\\mathrm{ap}})$。矩阵元素的公式变为：\n$$\nH_{mn} = L(r'_n, b_m) - L(r'_{n-1}, b_m)\n$$\n在数值实现过程中，当$b_m$非常接近某个有效半径$r'$时必须小心，因为浮点数不精确性可能导致$(r')^2 - b_m^2$项略微为负。我们必须确保平方根的参数为非负数。\n\n一旦为给定的测试用例构建了矩阵$\\mathbf{H}$，我们就分析其属性。\n1. 计算$\\mathbf{H}$的秩$\\mathrm{rank}(\\mathbf{H})$。秩给出线性无关的行（或列）的数量，对应于由测量张成的数据空间的维度。如果$\\mathrm{rank}(\\mathbf{H}) = N$（未知数数量），则在方形或超定系统假设下，发射率剖面$\\mathbf{f}$可从测量$\\mathbf{s}$中唯一确定。如果 $\\mathrm{rank}(\\mathbf{H})  N$，则系统是欠定的或秩亏的，不存在$\\mathbf{f}$的唯一解。\n2. 计算2-范数条件数$\\kappa_2(\\mathbf{H})$。它是$\\mathbf{H}$的最大奇异值与最小奇异值之比，即$\\kappa_2(\\mathbf{H}) = \\sigma_{\\max} / \\sigma_{\\min}$。大的条件数表示一个病态问题，其中测量向量$\\mathbf{s}$中的小误差或噪声可能导致推断解$\\mathbf{f}$中的大误差。如果$\\mathbf{H}$是奇异的或秩亏的（即$\\sigma_{\\min} = 0$），则条件数为无穷大。\n\n实现将通过迭代五个指定的测试用例来进行。对于每个用例，我们定义参数（$N, M, R, \\{b_m\\}, R_{\\mathrm{ap}}$），使用几何公式逐个元素构建矩阵$\\mathbf{H}$，然后使用标准的数值线性代数程序计算其秩和条件数。结果将按规定格式收集和格式化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes a forward operator matrix for synthetic chord-integrated\n    emissivity measurements in a toroidal plasma cross-section.\n    \"\"\"\n\n    def get_h_matrix(R, N, M, b_params, R_ap=None):\n        \"\"\"\n        Constructs the forward operator matrix H.\n\n        Args:\n            R (float): Radius of the circular cross-section.\n            N (int): Number of concentric annuli (emissivity zones).\n            M (int): Number of measurement chords.\n            b_params (np.ndarray): Array of impact parameters for the chords.\n            R_ap (float, optional): Aperture radius limit. Defaults to None.\n\n        Returns:\n            np.ndarray: The M x N forward operator matrix H.\n        \"\"\"\n        # Define annulus radii\n        r = R * np.arange(N + 1) / N\n\n        # Initialize the H matrix\n        H = np.zeros((M, N))\n\n        # Helper function for chord length through a circle of radius 'a'\n        def chord_length(a, b):\n            # Numerically robust calculation of 2 * sqrt(a^2 - b^2)\n            if b >= a:\n                return 0.0\n            return 2.0 * np.sqrt(a**2 - b**2)\n\n        # Populate the H matrix\n        for m in range(M):\n            b = b_params[m]\n            for n in range(N):\n                r_inner = r[n]\n                r_outer = r[n + 1]\n\n                # Apply aperture limit if specified\n                r_eff_inner = r_inner\n                r_eff_outer = r_outer\n                if R_ap is not None:\n                    r_eff_inner = min(r_inner, R_ap)\n                    r_eff_outer = min(r_outer, R_ap)\n\n                # Path length is the difference of lengths through the outer and inner circles\n                # of the (effective) annulus.\n                len_outer = chord_length(r_eff_outer, b)\n                len_inner = chord_length(r_eff_inner, b)\n                H[m, n] = len_outer - len_inner\n        \n        return H\n\n    # Common parameters\n    R_base = 1.0\n\n    # Test suite definition\n    test_cases = [\n        # Case 1: baseline, square system\n        {'N': 8, 'M': 8, 'b_params': R_base * np.array([0.000, 0.125, 0.250, 0.375, 0.500, 0.625, 0.750, 0.875]), 'R_ap': None},\n        # Case 2: overdetermined\n        {'N': 8, 'M': 16, 'b_params': np.linspace(0, 0.95 * R_base, 16), 'R_ap': None},\n        # Case 3: underdetermined\n        {'N': 8, 'M': 5, 'b_params': R_base * np.array([0.000, 0.200, 0.400, 0.600, 0.800]), 'R_ap': None},\n        # Case 4: clustered chords, near-degenerate sampling\n        {'N': 8, 'M': 8, 'b_params': R_base * np.array([0.680, 0.690, 0.700, 0.710, 0.720, 0.730, 0.740, 0.750]), 'R_ap': None},\n        # Case 5: limited aperture\n        {'N': 8, 'M': 8, 'b_params': R_base * np.array([0.000, 0.125, 0.250, 0.375, 0.500, 0.625, 0.750, 0.875]), 'R_ap': 0.700 * R_base},\n    ]\n\n    results = []\n    for case in test_cases:\n        H = get_h_matrix(R_base, case['N'], case['M'], case['b_params'], case['R_ap'])\n\n        # Compute rank and condition number\n        rank = np.linalg.matrix_rank(H)\n        cond_num = np.linalg.cond(H)\n\n        results.append(rank)\n        \n        # Format condition number. np.inf will be handled by str() conversion later\n        if np.isinf(cond_num):\n            results.append(cond_num)\n        else:\n            results.append(round(cond_num, 6))\n\n    # Format the final output string as specified\n    # map(str, ...) correctly handles integers, floats, and np.inf\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "合成诊断的最终目标是进行模型验证。本练习将引导你超越简单的误差度量，进入一个更强大的贝叶斯统计框架。你将学习如何运用贝叶斯证据和贝叶斯因子，对相互竞争的物理模型进行定量比较，并根据“数据”解释支持的强度，从而对哪个模型更优做出严谨的判断。",
            "id": "3948507",
            "problem": "您将获得多对对数证据集，这些对数证据集是通过旨在验证计算聚变科学与工程中竞争性正演模型的独立合成诊断计算得出的。在此设定中，每个模型都会预测诊断可观测量，而模型证据由贝叶斯定理定义。目标是计算证据比，并使用对数证据差来解释支持的强度。\n\n基本原理：贝叶斯定理规定，对于一个假设 $H$，其后验概率为 $p(H \\mid D) = \\dfrac{p(D \\mid H) p(H)}{p(D)}$，其中 $p(D \\mid H)$ 是似然，而 $p(H)$ 是先验概率。假设 $H$ 的证据 $Z(H) = p(D)$ 为\n$$\nZ(H) = \\int p(D \\mid \\theta, H) \\, \\pi(\\theta \\mid H) \\, d\\theta,\n$$\n其中 $\\pi(\\theta \\mid H)$ 是参数 $\\theta$ 的先验密度。对于给定 $H$ 时条件独立的多个诊断 $D_1, D_2, \\ldots, D_N$，联合似然可分解为 $p(D_1, \\ldots, D_N \\mid H) = \\prod_{i=1}^{N} p(D_i \\mid H)$，联合证据也相应地分解。因此，总对数证据是各个诊断对数证据的总和：\n$$\n\\ln Z_{\\text{total}}(H) = \\sum_{i=1}^{N} \\ln Z_i(H).\n$$\n\n比较假设 $H_1$ 和 $H_2$ 的贝叶斯因子 (BF) 是 $K_{12} = \\dfrac{Z(H_1)}{Z(H_2)}$。为了数值稳定性，使用对数表示，定义 $\\Delta = \\ln Z(H_1) - \\ln Z(H_2)$，这意味着 $K_{12} = \\exp(\\Delta)$。\n\n解释：使用 Jeffreys 式解释方法，根据自然对数 $\\Delta$ 的量级进行解释。根据 $|\\Delta|$ 定义一个分类支持代码 $c$ 如下：\n- 如果 $0 \\leq |\\Delta|  1$，则 $c = 0$ (几乎不值一提)。\n- 如果 $1 \\leq |\\Delta|  2.5$，则 $c = 1$ (弱证据)。\n- 如果 $2.5 \\leq |\\Delta|  5$，则 $c = 2$ (中等证据)。\n- 如果 $|\\Delta| \\geq 5$，则 $c = 3$ (强证据)。\n\n根据 $\\Delta$ 的符号定义一个偏好模型指数 $m$，平局容差为 $\\epsilon = 10^{-9}$：如果 $|\\Delta|  \\epsilon$，设置 $m = 0$ (平局)；如果 $\\Delta > 0$，设置 $m = 1$ (支持 $H_1$)；如果 $\\Delta  0$，设置 $m = 2$ (支持 $H_2$)。\n\n您的任务是实现一个程序，为每个测试用例计算 $H_1$ 和 $H_2$ 的总对数证据，然后计算 $\\Delta$、贝叶斯因子 $K_{12}$、支持代码 $c$ 和偏好模型指数 $m$。\n\n测试套件（每个测试用例提供 $H_1$ 和 $H_2$ 的各诊断对数证据）：\n\n- 测试用例 A：$H_1$：[$-12.3$, $5.1$, $-0.8$]；$H_2$：[$-13.0$, $4.0$, $-0.5$]。\n- 测试用例 B：$H_1$：[$1.0$]；$H_2$：[$0.0$]。\n- 测试用例 C：$H_1$：[$-15.0$, $-2.0$]；$H_2$：[$-10.0$, $-1.0$]。\n- 测试用例 D：$H_1$：[$100.000000000001$]；$H_2$：[$100.0$]。\n- 测试用例 E：$H_1$：[$-700.0$, $300.0$, $10.0$]；$H_2$：[$-705.0$, $300.0$, $12.5$]。\n- 测试用例 F：$H_1$：[$-100.0$]；$H_2$：[$-110.0$]。\n- 测试用例 G：$H_1$：[$0.0$, $0.0$]；$H_2$：[$0.0$, $0.0$]。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，[$r_A$, $r_B$, $r_C$, $\\ldots$]），其中每个测试用例的结果 $r$ 本身就是一个形式为 [$K_{12}$, $\\Delta$, $c$, $m$] 的列表。值 $K_{12}$ 和 $\\Delta$ 必须是浮点数，$c$ 和 $m$ 必须是整数。由于所有量都是无量纲的，因此不需要单位。",
            "solution": "该问题定义明确，以贝叶斯推断原理为科学基础，并为获得唯一解提供了所有必要信息。因此，我们可以进行推导和实现。\n\n核心任务是基于来自一组 $N$ 个独立合成诊断的数据，比较两个竞争性物理模型（表示为假设 $H_1$ 和 $H_2$）。该比较是使用每个模型的贝叶斯证据 $Z(H)$ 进行的。\n\n**步骤 1：计算总对数证据**\n\n问题陈述，对于一组 $N$ 个条件独立的诊断，给定假设 $H$ 的总对数证据是每个单独诊断的对数证据之和。设假设 $H_k$ 的各诊断对数证据由集合 $\\{\\ln Z_{i}(H_k)\\}_{i=1}^N$ 给出。因此，总对数证据 $\\ln Z_{\\text{total}}(H_k)$ 为：\n$$\n\\ln Z_{\\text{total}}(H_k) = \\sum_{i=1}^{N} \\ln Z_i(H_k)\n$$\n对于每个测试用例，我们都得到了两个浮点数列表，分别代表 $H_1$ 和 $H_2$ 的各诊断对数证据。我们必须首先对每个列表中的值求和，以获得 $\\ln Z_{\\text{total}}(H_1)$ 和 $\\ln Z_{\\text{total}}(H_2)$。\n\n**步骤 2：计算对数证据差 $\\Delta$**\n\n比较这两个模型的主要量是它们总对数证据的差。这个量，记为 $\\Delta$，定义为：\n$$\n\\Delta = \\ln Z_{\\text{total}}(H_1) - \\ln Z_{\\text{total}}(H_2)\n$$\n$\\Delta$ 的正值表示证据支持模型 $H_1$ 胜过 $H_2$，而负值则表示相反。$\\Delta$ 值接近于零表明证据无法区分这两个模型。\n\n**步骤 3：计算贝叶斯因子 $K_{12}$**\n\n贝叶斯因子 $K_{12}$ 是两个模型证据的比值：\n$$\nK_{12} = \\frac{Z_{\\text{total}}(H_1)}{Z_{\\text{total}}(H_2)}\n$$\n利用对数的性质，贝叶斯因子可以直接从 $\\Delta$ 计算得出：\n$$\n\\ln(K_{12}) = \\ln\\left(\\frac{Z_{\\text{total}}(H_1)}{Z_{\\text{total}}(H_2)}\\right) = \\ln Z_{\\text{total}}(H_1) - \\ln Z_{\\text{total}}(H_2) = \\Delta\n$$\n因此，贝叶斯因子通过对 $\\Delta$ 取指数得到：\n$$\nK_{12} = \\exp(\\Delta)\n$$\n这个值表示，与模型 $H_2$ 相比，在模型 $H_1$ 下观测到的数据的可能性要高多少倍。\n\n**步骤 4：证据强度的分类解释 $c$**\n\n证据的强度使用应用于对数证据差的绝对值 $|\\Delta|$ 的 Jeffreys 式标度进行分类。分类支持代码 $c$ 是一个由以下阈值决定的整数：\n- 如果 $0 \\leq |\\Delta|  1$，则支持可忽略（“几乎不值一提”），我们指定 $c = 0$。\n- 如果 $1 \\leq |\\Delta|  2.5$，则支持为“弱”，我们指定 $c = 1$。\n- 如果 $2.5 \\leq |\\Delta|  5$，则支持为“中等”，我们指定 $c = 2$。\n- 如果 $|\\Delta| \\geq 5$，则支持为“强”，我们指定 $c = 3$。\n\n**步骤 5：确定偏好模型 $m$**\n\n偏好模型指数 $m$ 由 $\\Delta$ 的符号确定。引入了数值容差 $\\epsilon = 10^{-9}$，以处理模型在机器精度内无法区分的情况。\n- 如果 $|\\Delta|  \\epsilon$，则认为模型处于“平局”，我们设置 $m = 0$。\n- 如果 $\\Delta > 0$ (且 $|\\Delta| \\geq \\epsilon$)，证据支持模型 $H_1$，我们设置 $m = 1$。\n- 如果 $\\Delta  0$ (且 $|\\Delta| \\geq \\epsilon$)，证据支持模型 $H_2$，我们设置 $m = 2$。\n\n通过对每个提供的测试用例执行这五个步骤，我们可以计算出所需的元组 $[K_{12}, \\Delta, c, m]$。\n\n单个测试用例的总体算法如下：\n1.  接收两个各诊断对数证据的列表，$L_1$ 用于 $H_1$，$L_2$ 用于 $H_2$。\n2.  计算每个模型的总对数证据：$\\ln Z_1 = \\sum L_1$ 和 $\\ln Z_2 = \\sum L_2$。\n3.  计算差值：$\\Delta = \\ln Z_1 - \\ln Z_2$。\n4.  计算贝叶斯因子：$K_{12} = \\exp(\\Delta)$。\n5.  根据 $|\\Delta|$ 确定支持代码 $c$。\n6.  根据 $\\Delta$ 的符号和容差 $\\epsilon$ 确定偏好模型指数 $m$。\n7.  将结果存储为一个包含四个元素的列表：$[K_{12}, \\Delta, c, m]$。\n此过程将系统地应用于所有测试用例，以生成最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and interprets Bayes factors from log-evidence values for\n    competing scientific models.\n    \"\"\"\n    # Test suite with per-diagnostic log-evidences for H1 and H2.\n    test_cases = [\n        # (log_evidence_H1, log_evidence_H2)\n        ([-12.3, 5.1, -0.8], [-13.0, 4.0, -0.5]),  # Test case A\n        ([1.0], [0.0]),                            # Test case B\n        ([-15.0, -2.0], [-10.0, -1.0]),            # Test case C\n        ([100.000000000001], [100.0]),             # Test case D\n        ([-700.0, 300.0, 10.0], [-705.0, 300.0, 12.5]), # Test case E\n        ([-100.0], [-110.0]),                      # Test case F\n        ([0.0, 0.0], [0.0, 0.0]),                  # Test case G\n    ]\n\n    results = []\n    epsilon = 1e-9\n\n    for h1_logs, h2_logs in test_cases:\n        # Step 1: Calculate total log-evidence for each model\n        ln_z1 = np.sum(h1_logs)\n        ln_z2 = np.sum(h2_logs)\n\n        # Step 2: Calculate the log-evidence difference (Delta)\n        delta = ln_z1 - ln_z2\n\n        # Step 3: Calculate the Bayes factor (K12)\n        k12 = np.exp(delta)\n\n        # Step 4: Determine the categorical support code (c)\n        abs_delta = abs(delta)\n        c = 0 # Default for 0 = |Delta|  1\n        if abs_delta >= 5.0:\n            c = 3 # Strong evidence\n        elif abs_delta >= 2.5:\n            c = 2 # Moderate evidence\n        elif abs_delta >= 1.0:\n            c = 1 # Weak evidence\n\n        # Step 5: Determine the favored model index (m)\n        m = 0 # Default for a tie\n        if abs_delta >= epsilon:\n            if delta > 0:\n                m = 1 # Favor H1\n            else: # delta  0\n                m = 2 # Favor H2\n\n        # Store the result tuple for this test case\n        results.append([k12, delta, c, m])\n\n    # Final print statement in the exact required format.\n    # The output is a list of lists, formatted as a string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}