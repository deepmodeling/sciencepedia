{
    "hands_on_practices": [
        {
            "introduction": "了解空腔能量平衡的第一步是分析能量如何在空腔壁内沉积和转化。本练习通过一个集总热容模型来简化这一复杂过程，让学生能够应用基本的能量守恒定律。通过计算将激光能量转化为腔壁热能所需的时间，你可以对X射线产生过程中的基础热力学响应及其时间尺度有一个定量的理解。",
            "id": "3991144",
            "problem": "柱形黑腔（hohlraum）用于将激光能量转换为X射线，以实现间接驱动惯性约束聚变。内壁由高原子序数金属制成，并在壁厚上被建模为集总热容。考虑一个内半径为 $R$、轴向长度为 $L$ 的黑腔，其两端盖上有两个半径为 $r_{\\mathrm{LEH}}$ 的激光入口孔（LEH）。在相关温度范围内，腔壁具有均匀的厚度 $t$、质量密度 $\\rho$ 和恒定的（有效）比热容 $c_p$。在目标时间段内，入射激光功率被腔壁吸收的净分数（在激光到X射线转换及任何再辐射损失之后）为 $\\eta_{\\mathrm{abs}}$，且激光以恒定功率 $P_L$ 进行能量输送。\n\n从能量守恒和热容的定义出发，推导在内表面积上能量均匀沉积的条件下，将壁温升高 $\\Delta T$ 所需的壁加热时间 $t_h$ 的闭式表达式。使用圆柱几何结构来构建内壁面积，其等于内圆柱表面积加上两个端盖的面积，再减去两个激光入口孔的面积：\n$$\nA_w \\;=\\; 2\\pi R L \\;+\\; 2\\pi R^2 \\;-\\; 2\\pi r_{\\mathrm{LEH}}^2.\n$$\n定义面密度为 $m_a=\\rho\\,t$，并使用集总热容关系 $E_{\\mathrm{req}} \\approx A_w\\,m_a\\,c_p\\,\\Delta T$ 来模拟温升所需的能量。将 $E_{\\mathrm{req}}$ 与吸收的激光能量 $\\eta_{\\mathrm{abs}} P_L t_h$ 关联起来，并求解 $t_h$。\n\n使用以下参数计算 $t_h$ 的数值，并使用指定的单位和精度：\n- $R = 2.00 \\times 10^{-3}$ m, $L = 9.00 \\times 10^{-3}$ m, $r_{\\mathrm{LEH}} = 1.00 \\times 10^{-3}$ m,\n- $t = 1.50 \\times 10^{-4}$ m, $\\rho = 1.93 \\times 10^{4}$ kg/m$^3$, $c_p = 1.29 \\times 10^{2}$ J/kg/K,\n- $\\Delta T = 3.00 \\times 10^{3}$ K, $\\eta_{\\mathrm{abs}} = 0.75$, $P_L = 1.00 \\times 10^{11}$ W.\n\n以纳秒（ns）为单位表示最终的加热时间。将您的答案四舍五入到三位有效数字。",
            "solution": "首先验证问题，以确保其科学上成立、内容自洽且提法恰当。给定参数如下：\n- 内半径: $R = 2.00 \\times 10^{-3}$ m\n- 轴向长度: $L = 9.00 \\times 10^{-3}$ m\n- 激光入口孔 (LEH) 半径: $r_{\\mathrm{LEH}} = 1.00 \\times 10^{-3}$ m\n- 壁厚: $t = 1.50 \\times 10^{-4}$ m\n- 质量密度: $\\rho = 1.93 \\times 10^{4}$ kg/m$^3$\n- 比热容: $c_p = 1.29 \\times 10^{2}$ J/kg/K\n- 壁温升高: $\\Delta T = 3.00 \\times 10^{3}$ K\n- 吸收的激光功率净分数: $\\eta_{\\mathrm{abs}} = 0.75$\n- 激光功率: $P_L = 1.00 \\times 10^{11}$ W\n- 内壁面积: $A_w = 2\\pi R L + 2\\pi R^2 - 2\\pi r_{\\mathrm{LEH}}^2$\n- 面密度: $m_a = \\rho t$\n- 温升所需能量: $E_{\\mathrm{req}} \\approx A_w m_a c_p \\Delta T$\n\n该问题基于能量守恒基本原理，并使用标准集总参数模型进行热分析，这在当前背景下是有效的简化。所提供的参数对于间接驱动惯性约束聚变实验是物理上现实的。问题定义明确，提供了所有必要信息，且没有矛盾之处。因此，该问题被认为是有效的，可以制定解决方案。\n\n解题过程从应用能量守恒原理开始。在加热时间 $t_h$ 内，黑腔壁吸收的总能量 $E_{\\mathrm{abs}}$ 必须等于将壁温升高 $\\Delta T$ 所需的能量，记为 $E_{\\mathrm{req}}$。\n$$\nE_{\\mathrm{abs}} = E_{\\mathrm{req}}\n$$\n吸收的能量是恒定的吸收功率与加热时间的乘积。吸收功率是入射激光功率 $P_L$ 的一部分，比例为 $\\eta_{\\mathrm{abs}}$。\n$$\nE_{\\mathrm{abs}} = (\\eta_{\\mathrm{abs}} P_L) t_h\n$$\n加热腔壁所需的能量由问题陈述中提供的集总热容关系给出。待加热腔壁的总质量是内壁表面积 $A_w$、壁厚 $t$ 和质量密度 $\\rho$ 的乘积。问题通过定义面密度 $m_a = \\rho t$ 来简化此计算。\n$$\nE_{\\mathrm{req}} = A_w m_a c_p \\Delta T\n$$\n将吸收能量和所需能量的表达式相等，我们得到：\n$$\n\\eta_{\\mathrm{abs}} P_L t_h = A_w m_a c_p \\Delta T\n$$\n求解加热时间 $t_h$，得到通用符号表达式：\n$$\nt_h = \\frac{A_w m_a c_p \\Delta T}{\\eta_{\\mathrm{abs}} P_L}\n$$\n现在，我们代入给定的壁面积 $A_w$ 和面密度 $m_a$ 的表达式：\n$$\nA_w = 2\\pi (RL + R^2 - r_{\\mathrm{LEH}}^2)\n$$\n$$\nm_a = \\rho t\n$$\n将这些代入 $t_h$ 的方程，得到完整的闭式表达式：\n$$\nt_h = \\frac{2\\pi (RL + R^2 - r_{\\mathrm{LEH}}^2) (\\rho t) c_p \\Delta T}{\\eta_{\\mathrm{abs}} P_L}\n$$\n这完成了问题的推导部分。下一步是使用提供的参数计算 $t_h$ 的数值。\n\n首先，我们计算分子中的各项。\n内壁面积 $A_w$：\n$$\nA_w = 2\\pi \\left( (2.00 \\times 10^{-3})(9.00 \\times 10^{-3}) + (2.00 \\times 10^{-3})^2 - (1.00 \\times 10^{-3})^2 \\right)\n$$\n$$\nA_w = 2\\pi \\left( 18.0 \\times 10^{-6} + 4.00 \\times 10^{-6} - 1.00 \\times 10^{-6} \\right) \\text{m}^2\n$$\n$$\nA_w = 2\\pi (21.0 \\times 10^{-6}) \\text{ m}^2 = 42.0\\pi \\times 10^{-6} \\text{ m}^2\n$$\n面密度 $m_a$：\n$$\nm_a = \\rho t = (1.93 \\times 10^{4} \\text{ kg/m}^3)(1.50 \\times 10^{-4} \\text{ m}) = 2.895 \\text{ kg/m}^2\n$$\n现在，我们计算所需的总能量 $E_{\\mathrm{req}}$：\n$$\nE_{\\mathrm{req}} = A_w m_a c_p \\Delta T\n$$\n$$\nE_{\\mathrm{req}} = (42.0\\pi \\times 10^{-6} \\text{ m}^2) (2.895 \\text{ kg/m}^2) (1.29 \\times 10^{2} \\text{ J/kg/K}) (3.00 \\times 10^{3} \\text{ K})\n$$\n$$\nE_{\\mathrm{req}} = (42.0 \\times 2.895 \\times 1.29 \\times 3.00) \\pi \\times 10^{-6+2+3} \\text{ J}\n$$\n$$\nE_{\\mathrm{req}} = 469.551 \\pi \\times 10^{-1} \\text{ J} \\approx 147.513 \\text{ J}\n$$\n接下来，我们计算吸收功率 $P_{\\mathrm{abs}}$：\n$$\nP_{\\mathrm{abs}} = \\eta_{\\mathrm{abs}} P_L = (0.75)(1.00 \\times 10^{11} \\text{ W}) = 0.75 \\times 10^{11} \\text{ W}\n$$\n最后，我们计算以秒为单位的加热时间 $t_h$：\n$$\nt_h = \\frac{E_{\\mathrm{req}}}{P_{\\mathrm{abs}}} = \\frac{46.9551 \\pi \\text{ J}}{0.75 \\times 10^{11} \\text{ W}}\n$$\n$$\nt_h = \\frac{147.513...}{0.75 \\times 10^{11}} \\text{ s} \\approx 1.96684 \\times 10^{-9} \\text{ s}\n$$\n问题要求最终答案以纳秒（ns）为单位，其中 $1 \\text{ ns} = 10^{-9} \\text{ s}$。\n$$\nt_h \\approx 1.96684 \\text{ ns}\n$$\n将结果四舍五入到三位有效数字，我们得到：\n$$\nt_h \\approx 1.97 \\text{ ns}\n$$",
            "answer": "$$\\boxed{1.97}$$"
        },
        {
            "introduction": "除了总能量，驱动内爆的X射线场的空间均匀性（即对称性）对聚变成功至关重要。本练习将介绍如何使用勒让德多项式（特别是二阶项 $P_2$）来量化驱动不对称性，并分析其对工程扰动（如激光束指向抖动）的敏感度。这项计算实践将抽象的数学工具与一个关键的工程挑战联系起来，帮助你理解为确保对称内爆所需的激光系统精度。",
            "id": "3991079",
            "problem": "您的任务是开发一个程序，用于计算惯性约束聚变 (ICF) 黑腔 (hohlraum) 中激光束指向的允许角抖动，以使靶丸驱动不对称性的二阶 Legendre 矩（用 $P_2$ 表示）保持在指定的容差以下。计算必须包含基于视界因子的灵敏度分析。允许的抖动必须以弧度为单位返回。最终的程序输出必须将所有测试用例的结果汇总到一行，以方括号括起来的逗号分隔列表形式呈现。\n\n该问题的基本依据如下：\n- 能量守恒：靶丸吸收的辐射通量是来自每个源区域（激光光斑或 X 射线发射区）的贡献之和，并按几何视界因子加权。\n- 辐射视界因子方法：给定靶丸表面元上吸收的通量等于源功率乘以源与该表面元之间的无量纲视界因子。\n- 球谐函数和 Legendre 多项式：角向驱动不对称性由 Legendre 矩表示，其中 $P_2$ 是二阶 Legendre 多项式 $P_2(x) = \\frac{3x^2 - 1}{2}$。\n- 小角度线性化：对于足够小的指向角扰动，视界因子的变化与角度扰动呈线性关系。\n\n假设一个轴对称靶丸，其上吸收的通量分布在 $n_p$ 个极向位置上离散化，这些位置由 $j \\in \\{1,\\dots,n_p\\}$ 索引，其极角为 $\\theta_j \\in [0,\\pi]$，对应的 Gauss-Legendre 求积横坐标为 $\\mu_j = \\cos(\\theta_j)$，权重为 $w_j$，这些权重能在 $[-1,1]$ 区间上对 $\\mu$ 的多项式精确积分至指定阶数。假设有 $n_b$ 个激光束，由 $i \\in \\{1,\\dots,n_b\\}$ 索引，每个激光束的功率为 $P_i$（单位：瓦特）。设从激光束 $i$ 到靶丸表面元 $j$ 的标称视界因子为 $V_{ij}$（无量纲），视界因子相对于指向角 $\\alpha_i$ 的灵敏度为 $S_{ij} = \\frac{\\partial V_{ij}}{\\partial \\alpha_i}$（单位：$\\mathrm{rad}^{-1}$）。表面元 $j$ 上的标称吸收通量定义为\n$$\nq_j = \\sum_{i=1}^{n_b} P_i V_{ij},\n$$\n驱动的标称 $P_2$ 矩（无量纲）定义为\n$$\nA_2 = \\frac{\\sum_{j=1}^{n_p} q_j \\, P_2(\\mu_j) \\, w_j}{\\sum_{j=1}^{n_p} q_j \\, w_j}.\n$$\n假设每个激光束 $i$ 的指向角存在小的角抖动 $\\delta \\alpha_i$，并将表面元 $j$ 处吸收通量的变化近似为\n$$\n\\delta q_j \\approx \\sum_{i=1}^{n_b} P_i S_{ij} \\, \\delta \\alpha_i,\n$$\n这源于一阶 Taylor 展开（小角度线性化）。通过对上述线性泛函的商对每个角度求导，可以推导出 $A_2$ 相应的一阶变化，从而得到灵敏度 $g_i = \\frac{\\partial A_2}{\\partial \\alpha_i}$，它是 $S_{ij}$, $P_i$, $w_j$, $P_2(\\mu_j)$, $q_j$ 以及分母和的线性泛函。对于在无穷范数下有界的最坏情况抖动，即对所有 $i$ 都有 $|\\delta \\alpha_i| \\leq \\Delta$，一个有保证的 $P_2$ 偏移界限是\n$$\n|\\delta A_2| \\leq \\Delta \\sum_{i=1}^{n_b} |g_i|.\n$$\n为确保总 $P_2$ 保持在指定的容差 $T$（无量纲）以下，我们需要满足\n$$\n|A_2| + \\Delta \\sum_{i=1}^{n_b} |g_i| \\leq T,\n$$\n由此得出最大允许抖动幅度\n$$\n\\Delta^\\star =\n\\begin{cases}\n\\frac{T - |A_2|}{\\sum_{i=1}^{n_b} |g_i|},   \\text{if } \\sum_{i=1}^{n_b} |g_i|  0 \\text{ and } T \\geq |A_2|, \\\\\n+\\infty,   \\text{if } \\sum_{i=1}^{n_b} |g_i| = 0 \\text{ and } T \\geq |A_2|, \\\\\n0,   \\text{if } T  |A_2|.\n\\end{cases}\n$$\n您必须对每个测试用例使用上述定义计算 $\\Delta^\\star$。角度必须以弧度表示。最终的程序输出必须是包含结果列表的单行，结果为浮点数，单位为弧度。\n\n提供了 4 阶 Gauss-Legendre 求积的横坐标和权重，所有测试用例都必须使用它们：\n- 横坐标 $\\mu_j$ (对于 $j \\in \\{1,2,3,4\\}$):\n  - $\\mu_1 = -0.8611363116$, $\\mu_2 = -0.3399810436$, $\\mu_3 = 0.3399810436$, $\\mu_4 = 0.8611363116$。\n- 权重 $w_j$ (对于 $j \\in \\{1,2,3,4\\}$):\n  - $w_1 = 0.3478548451$, $w_2 = 0.6521451549$, $w_3 = 0.6521451549$, $w_4 = 0.3478548451$。\n\n您的程序必须实现以下测试套件，并以弧度为单位生成结果：\n\n- 测试用例 1（具有非零灵敏度的一般情况）：\n  - 激光束数量 $n_b = 4$，表面元数量 $n_p = 4$。\n  - 激光束功率（单位：瓦特）：$P = [1.0 \\times 10^{12}, 0.9 \\times 10^{12}, 1.1 \\times 10^{12}, 1.0 \\times 10^{12}]$。\n  - 标称视界因子矩阵 $V$（无量纲）：\n    - 行 1: $[0.020, 0.024, 0.026, 0.023]$\n    - 行 2: $[0.019, 0.023, 0.025, 0.022]$\n    - 行 3: $[0.021, 0.025, 0.027, 0.024]$\n    - 行 4: $[0.020, 0.024, 0.026, 0.023]$\n  - 灵敏度矩阵 $S$（单位：$\\mathrm{rad}^{-1}$）：\n    - 行 1: $[0.0010, 0.0012, 0.0013, 0.0011]$\n    - 行 2: $[0.0009, 0.0011, 0.0012, 0.0010]$\n    - 行 3: $[0.0011, 0.0013, 0.0014, 0.0012]$\n    - 行 4: $[0.0010, 0.0012, 0.0013, 0.0011]$\n  - 容差 $T = 0.01$（无量纲）。\n\n- 测试用例 2（零灵敏度的边缘情况）：\n  - $n_b = 4$, $n_p = 4$。\n  - 激光束功率（单位：瓦特）：$P = [1.0 \\times 10^{12}, 1.0 \\times 10^{12}, 1.0 \\times 10^{12}, 1.0 \\times 10^{12}]$。\n  - 标称视界因子矩阵 $V$（无量纲）：\n    - 行 1: $[0.020, 0.020, 0.020, 0.020]$\n    - 行 2: $[0.020, 0.020, 0.020, 0.020]$\n    - 行 3: $[0.020, 0.020, 0.020, 0.020]$\n    - 行 4: $[0.020, 0.020, 0.020, 0.020]$\n  - 灵敏度矩阵 $S$（单位：$\\mathrm{rad}^{-1}$）为零矩阵：\n    - 行 1: $[0.0, 0.0, 0.0, 0.0]$\n    - 行 2: $[0.0, 0.0, 0.0, 0.0]$\n    - 行 3: $[0.0, 0.0, 0.0, 0.0]$\n    - 行 4: $[0.0, 0.0, 0.0, 0.0]$\n  - 容差 $T = 0.1$（无量纲）。\n\n- 测试用例 3（容差小于标称 $P_2$，导致允许抖动为零的边缘情况）：\n  - $n_b = 4$, $n_p = 4$。\n  - 激光束功率（单位：瓦特）：$P = [1.0 \\times 10^{12}, 1.0 \\times 10^{12}, 1.0 \\times 10^{12}, 1.0 \\times 10^{12}]$。\n  - 标称视界因子矩阵 $V$（无量纲）：\n    - 行 1: $[0.010, 0.060, 0.060, 0.010]$\n    - 行 2: $[0.010, 0.060, 0.060, 0.010]$\n    - 行 3: $[0.010, 0.060, 0.060, 0.010]$\n    - 行 4: $[0.010, 0.060, 0.060, 0.010]$\n  - 灵敏度矩阵 $S$（单位：$\\mathrm{rad}^{-1}$）：\n    - 行 1: $[0.0010, 0.0012, 0.0013, 0.0011]$\n    - 行 2: $[0.0010, 0.0012, 0.0013, 0.0011]$\n    - 行 3: $[0.0010, 0.0012, 0.0013, 0.0011]$\n    - 行 4: $[0.0010, 0.0012, 0.0013, 0.0011]$\n  - 容差 $T = 0.001$（无量纲）。\n\n- 测试用例 4（容差等于标称 $P_2$ 的边界情况）：\n  - $n_b = 4$, $n_p = 4$。\n  - 激光束功率（单位：瓦特）：$P = [1.0 \\times 10^{12}, 1.0 \\times 10^{12}, 1.0 \\times 10^{12}, 1.0 \\times 10^{12}]$。\n  - 标称视界因子矩阵 $V$（无量纲）：\n    - 行 1: $[0.050, 0.010, 0.010, 0.050]$\n    - 行 2: $[0.050, 0.010, 0.010, 0.050]$\n    - 行 3: $[0.050, 0.010, 0.010, 0.050]$\n    - 行 4: $[0.050, 0.010, 0.010, 0.050]$\n  - 灵敏度矩阵 $S$（单位：$\\mathrm{rad}^{-1}$）：\n    - 行 1: $[0.0005, 0.0005, 0.0005, 0.0005]$\n    - 行 2: $[0.0005, 0.0005, 0.0005, 0.0005]$\n    - 行 3: $[0.0005, 0.0005, 0.0005, 0.0005]$\n    - 行 4: $[0.0005, 0.0005, 0.0005, 0.0005]$\n  - 容差 $T$ 必须设定为等于从上述参数计算出的标称 $P_2$（即，对于测试用例 4，$T = |A_2|$）。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来（例如，$[result_1,result_2,result_3,result_4]$），其中每个 $result_k$ 是为测试用例 $k$ 计算出的 $\\Delta^\\star$（以弧度为单位的浮点数）。不应打印任何其他文本。所有角度量必须以弧度为单位，所有与 $P_2$ 相关的值都是无量纲的。每个测试用例的结果类型必须是浮点数，对于特殊情况 $+\\infty$，在适用时应打印为 $inf$。",
            "solution": "所述问题在科学上是合理的，数学上是适定的，并为获得唯一解提供了所有必要信息。其基础模型是惯性约束聚变中驱动不对称性分析的一个标准（尽管简化了）的表示，基于辐射传输、球谐函数和线性灵敏度分析的既定原理。为测试用例提供的所有数据在数值和量纲上都是一致的。因此，有必要提供一个完整的解。\n\n核心任务是为一组激光束在黑腔中计算最大允许角抖动幅度，记为 $\\Delta^\\star$，以使聚变靶丸上的驱动不对称性保持在指定的容差范围内。驱动不对称性由二阶 Legendre 矩 $A_2$ 量化。\n\n推导过程主要分为三个阶段：首先，计算标称（未受扰动的）驱动不对称性 $A_2$；其次，确定该不对称性对每个光束指向微小误差的灵敏度；第三，利用该灵敏度确定最大允许抖动。\n\n我们首先定义各个量及其数学表示。\n该系统由 $n_b$ 个激光束和 $n_p$ 个靶丸表面元组成。靶丸表面元位于极角 $\\theta_j$ 处，对应于 $n_p$ 阶 Gauss-Legendre 求积的横坐标 $\\mu_j = \\cos(\\theta_j)$。相关的求积权重为 $w_j$。对于本问题，$n_p=4$，横坐标和权重已给定。二阶 Legendre 多项式由 $P_2(\\mu) = \\frac{3\\mu^2 - 1}{2}$ 给出。\n\n表面元 $j$ 处吸收的标称辐射通量由所有光束的贡献之和给出：\n$$\nq_j = \\sum_{i=1}^{n_b} P_i V_{ij}\n$$\n其中 $P_i$ 是光束 $i$ 的功率，$V_{ij}$ 是从光束 $i$ 到表面元 $j$ 的无量纲视界因子。在矩阵-向量表示法中，如果我们定义 $\\mathbf{P}$ 为光束功率的列向量（形状为 $n_b \\times 1$），$\\mathbf{q}$ 为表面元通量的列向量（形状为 $n_p \\times 1$），$\\mathbf{V}$ 为视界因子矩阵（形状为 $n_b \\times n_p$），则可以写作 $\\mathbf{q} = \\mathbf{V}^T \\mathbf{P}$。\n\n标称 $P_2$ 驱动不对称性 $A_2$ 是通量分布的归一化二阶 Legendre 矩：\n$$\nA_2 = \\frac{\\sum_{j=1}^{n_p} q_j P_2(\\mu_j) w_j}{\\sum_{j=1}^{n_p} q_j w_j}\n$$\n我们将分子定义为 $N = \\sum_{j=1}^{n_p} q_j P_2(\\mu_j) w_j$，分母定义为 $D = \\sum_{j=1}^{n_p} q_j w_j$。因此，$A_2 = N/D$。分母 $D$ 代表总加权通量，与靶丸吸收的总能量成正比。\n\n下一步是求 $A_2$ 对光束 $i$ 指向角 $\\alpha_i$ 微小变化的灵敏度。该灵敏度为 $g_i = \\frac{\\partial A_2}{\\partial \\alpha_i}$。我们应用商法则求导：\n$$\ng_i = \\frac{\\partial A_2}{\\partial \\alpha_i} = \\frac{1}{D^2} \\left[ \\frac{\\partial N}{\\partial \\alpha_i} D - N \\frac{\\partial D}{\\partial \\alpha_i} \\right]\n$$\n需要计算 $N$ 和 $D$ 对 $\\alpha_i$ 的偏导数。这取决于通量 $q_j$ 对 $\\alpha_i$ 的变化。根据问题陈述，视界因子的变化是 $S_{ij} = \\frac{\\partial V_{ij}}{\\partial \\alpha_i}$。因此，通量的变化为：\n$$\n\\frac{\\partial q_j}{\\partial \\alpha_i} = \\frac{\\partial}{\\partial \\alpha_i} \\left( \\sum_{k=1}^{n_b} P_k V_{kj} \\right) = P_i S_{ij}\n$$\n现在，我们可以计算 $N$ 和 $D$ 的导数：\n$$\n\\frac{\\partial N}{\\partial \\alpha_i} = \\sum_{j=1}^{n_p} \\frac{\\partial q_j}{\\partial \\alpha_i} P_2(\\mu_j) w_j = \\sum_{j=1}^{n_p} (P_i S_{ij}) P_2(\\mu_j) w_j = P_i \\sum_{j=1}^{n_p} S_{ij} P_2(\\mu_j) w_j\n$$\n$$\n\\frac{\\partial D}{\\partial \\alpha_i} = \\sum_{j=1}^{n_p} \\frac{\\partial q_j}{\\partial \\alpha_i} w_j = \\sum_{j=1}^{n_p} (P_i S_{ij}) w_j = P_i \\sum_{j=1}^{n_p} S_{ij} w_j\n$$\n将这些代入 $g_i$ 的表达式中，并除以 $D$，得到一个更简洁的形式：\n$$\ng_i = \\frac{1}{D} \\frac{\\partial N}{\\partial \\alpha_i} - \\frac{N}{D^2} \\frac{\\partial D}{\\partial \\alpha_i} = \\frac{P_i}{D} \\sum_{j=1}^{n_p} S_{ij} P_2(\\mu_j) w_j - \\frac{A_2}{D} \\left( P_i \\sum_{j=1}^{n_p} S_{ij} w_j \\right)\n$$\n提取公因式，我们得到光束 $i$ 灵敏度的最终表达式：\n$$\ng_i = \\frac{P_i}{D} \\left( \\sum_{j=1}^{n_p} S_{ij} P_2(\\mu_j) w_j - A_2 \\sum_{j=1}^{n_p} S_{ij} w_j \\right)\n$$\n必须为每个光束 $i \\in \\{1, \\dots, n_b\\}$ 执行此计算。\n\n问题设定了一个最坏情况的抖动场景，其中每个光束的指向误差 $\\delta \\alpha_i$ 受 $|\\delta \\alpha_i| \\leq \\Delta$ 的限制。不对称性的总变化 $\\delta A_2$ 近似为一阶形式 $\\delta A_2 \\approx \\sum_{i=1}^{n_b} g_i \\delta \\alpha_i$。通过三角不等式可获得此变化幅值的保守上界：\n$$\n|\\delta A_2| \\leq \\sum_{i=1}^{n_b} |g_i| |\\delta \\alpha_i| \\leq \\Delta \\sum_{i=1}^{n_b} |g_i|\n$$\n最终的不对称性为 $A_2^{\\text{final}} = A_2 + \\delta A_2$。为确保总不对称性保持在容差 $T$ 内，即 $|A_2^{\\text{final}}| \\leq T$，我们对上界施加更严格的条件：\n$$\n|A_2| + |\\delta A_2|_{\\text{max}} \\leq T \\implies |A_2| + \\Delta \\sum_{i=1}^{n_b} |g_i| \\leq T\n$$\n解出 $\\Delta$ 即可得到允许的抖动幅度。这导出了最大允许抖动 $\\Delta^\\star$ 的分段定义：\n$$\n\\Delta^\\star =\n\\begin{cases}\n\\frac{T - |A_2|}{\\sum_{i=1}^{n_b} |g_i|},   \\text{if } \\sum_{i=1}^{n_b} |g_i|  0 \\text{ and } T \\geq |A_2| \\\\\n+\\infty,   \\text{if } \\sum_{i=1}^{n_b} |g_i| = 0 \\text{ and } T \\geq |A_2| \\\\\n0,   \\text{if } T  |A_2|\n\\end{cases}\n$$\n$\\Delta^\\star=0$ 的情况表示标称不对称性 $|A_2|$ 已经超过容差 $T$，因此不允许任何抖动。$\\Delta^\\star=+\\infty$ 的情况表示系统对指向误差不敏感（所有 $i$ 的 $g_i=0$），且标称不对称性在容差范围内，因此理论上允许任何大小的抖动（在线性近似的有效范围内）。\n\n为了实现该解法，对每个测试用例执行以下算法：\n1. 定义输入参数：向量 $\\mathbf{P}$, $\\boldsymbol{\\mu}$, $\\mathbf{w}$，以及矩阵 $\\mathbf{V}$, $\\mathbf{S}$。\n2. 计算 Legendre 多项式值的向量 $\\mathbf{P_2}$，其中 $(\\mathbf{P_2})_j = P_2(\\mu_j)$。\n3. 计算标称通量向量 $\\mathbf{q} = \\mathbf{V}^T \\mathbf{P}$。\n4. 计算和 $N = \\mathbf{q}^T (\\mathbf{P_2} \\odot \\mathbf{w})$ 和 $D = \\mathbf{q}^T \\mathbf{w}$，其中 $\\odot$ 表示逐元素乘法。\n5. 计算标称不对称性 $A_2 = N/D$。\n6. 对于测试用例 4，设置容差 $T = |A_2|$。\n7. 对于每个光束 $i$，使用推导出的公式计算灵敏度 $g_i$。这可以向量化。\n8. 计算灵敏度绝对值之和 $\\Sigma_g = \\sum_{i=1}^{n_b} |g_i|$。\n9. 应用分段公式，根据 $T$, $|A_2|$ 和 $\\Sigma_g$ 的值确定 $\\Delta^\\star$。\n10. 得到的 $\\Delta^\\star$ 是该测试用例的最终答案，单位为弧度。\n\n此过程系统地应用于所有提供的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_jitter_limit(case_params):\n    \"\"\"\n    Calculates the allowable angular jitter for a single test case.\n\n    Args:\n        case_params (dict): A dictionary containing all parameters for the test case.\n                            Keys: 'P', 'V', 'S', 'T'.\n\n    Returns:\n        float: The maximum allowable jitter amplitude Delta* in radians.\n    \"\"\"\n    # Step 1: Extract givens and define constants\n    P = np.array(case_params['P'], dtype=float)\n    V = np.array(case_params['V'], dtype=float)\n    S = np.array(case_params['S'], dtype=float)\n    T = case_params['T'] # Can be a float or None\n\n    # Gauss-Legendre quadrature for order 4 (n_p = 4)\n    mu_j = np.array([-0.8611363116, -0.3399810436, 0.3399810436, 0.8611363116])\n    w_j = np.array([0.3478548451, 0.6521451549, 0.6521451549, 0.3478548451])\n    \n    # Step 2: Compute P2(mu_j)\n    # P_2(x) = (3*x^2 - 1) / 2\n    p2_of_mu = 0.5 * (3.0 * mu_j**2 - 1.0)\n    \n    # Step 3: Calculate nominal flux q_j\n    # q_j = sum_i(P_i * V_ij)\n    # This corresponds to V.T @ P in numpy, where V has shape (n_b, n_p)\n    # and P has shape (n_b,).\n    q_j = V.T @ P\n    \n    # Step 4: Calculate nominal asymmetry A_2\n    # A_2 = Numerator / Denominator\n    numerator_A2 = np.dot(q_j, p2_of_mu * w_j)\n    denominator_A2 = np.dot(q_j, w_j)\n    \n    # Handle the case of zero total flux, though physically unlikely with given data.\n    if np.isclose(denominator_A2, 0.0):\n        # If total flux is zero, q_j is all zero, so numerator is also zero.\n        # A_2 is 0/0, which is ill-defined. We define it as 0 in this context.\n        A_2 = 0.0\n    else:\n        A_2 = numerator_A2 / denominator_A2\n        \n    # Step 5: Handle Test Case 4's special tolerance\n    if T is None:\n        T = np.abs(A_2)\n\n    # Step 6: Calculate asymmetry sensitivities g_i\n    # g_i = (P_i / D) * ( sum_j(S_ij * P2_j * w_j) - A_2 * sum_j(S_ij * w_j) )\n    if np.isclose(denominator_A2, 0.0):\n        g_i = np.zeros_like(P)\n    else:\n        # Vectorized calculation for g_i\n        # sum_vec1 is sum_j(S_ij * p2_of_mu_j * w_j) for each i\n        sum_vec1 = S @ (p2_of_mu * w_j)\n        # sum_vec2 is sum_j(S_ij * w_j) for each i\n        sum_vec2 = S @ w_j\n        \n        g_i = (P / denominator_A2) * (sum_vec1 - A_2 * sum_vec2)\n        \n    # Step 7: Calculate sum of absolute sensitivities\n    sum_abs_g = np.sum(np.abs(g_i))\n    \n    # Step 8: Apply piecewise formula to calculate Delta*\n    abs_A2 = np.abs(A_2)\n    \n    # Check for T  |A_2| with a small tolerance for floating point comparisons\n    if T  abs_A2 and not np.isclose(T, abs_A2):\n        delta_star = 0.0\n    else:\n        if np.isclose(sum_abs_g, 0.0):\n            delta_star = np.inf\n        else:\n            delta_star = (T - abs_A2) / sum_abs_g\n\n    return delta_star\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (general case with nonzero sensitivity)\n        {\n            'P': [1.0e12, 0.9e12, 1.1e12, 1.0e12],\n            'V': [\n                [0.020, 0.024, 0.026, 0.023],\n                [0.019, 0.023, 0.025, 0.022],\n                [0.021, 0.025, 0.027, 0.024],\n                [0.020, 0.024, 0.026, 0.023]\n            ],\n            'S': [\n                [0.0010, 0.0012, 0.0013, 0.0011],\n                [0.0009, 0.0011, 0.0012, 0.0010],\n                [0.0011, 0.0013, 0.0014, 0.0012],\n                [0.0010, 0.0012, 0.0013, 0.0011]\n            ],\n            'T': 0.01\n        },\n        # Test Case 2 (edge case with zero sensitivity)\n        {\n            'P': [1.0e12, 1.0e12, 1.0e12, 1.0e12],\n            'V': [\n                [0.020, 0.020, 0.020, 0.020],\n                [0.020, 0.020, 0.020, 0.020],\n                [0.020, 0.020, 0.020, 0.020],\n                [0.020, 0.020, 0.020, 0.020]\n            ],\n            'S': [\n                [0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0, 0.0]\n            ],\n            'T': 0.1\n        },\n        # Test Case 3 (edge case with T  |A_2|)\n        {\n            'P': [1.0e12, 1.0e12, 1.0e12, 1.0e12],\n            'V': [\n                [0.010, 0.060, 0.060, 0.010],\n                [0.010, 0.060, 0.060, 0.010],\n                [0.010, 0.060, 0.060, 0.010],\n                [0.010, 0.060, 0.060, 0.010]\n            ],\n            'S': [\n                [0.0010, 0.0012, 0.0013, 0.0011],\n                [0.0010, 0.0012, 0.0013, 0.0011],\n                [0.0010, 0.0012, 0.0013, 0.0011],\n                [0.0010, 0.0012, 0.0013, 0.0011]\n            ],\n            'T': 0.001\n        },\n        # Test Case 4 (boundary case with T = |A_2|)\n        {\n            'P': [1.0e12, 1.0e12, 1.0e12, 1.0e12],\n            'V': [\n                [0.050, 0.010, 0.010, 0.050],\n                [0.050, 0.010, 0.010, 0.050],\n                [0.050, 0.010, 0.010, 0.050],\n                [0.050, 0.010, 0.010, 0.050]\n            ],\n            'S': [\n                [0.0005, 0.0005, 0.0005, 0.0005],\n                [0.0005, 0.0005, 0.0005, 0.0005],\n                [0.0005, 0.0005, 0.0005, 0.0005],\n                [0.0005, 0.0005, 0.0005, 0.0005]\n            ],\n            'T': None # Placeholder to signify T = |A_2|\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_jitter_limit(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了主动控制驱动对称性，物理学家们利用了等离子体中的各种物理现象，其中横梁能量转移（CBET）是关键机制之一。本练习要求你对激光束之间的能量交换过程进行建模，该过程由一组耦合常微分方程描述。通过求解能量转移的解析解，你将深入了解间接驱动聚变中的一个主要“调节旋钮”，并理解如何动态地重新分配激光能量以塑造X射线驱动，从而优化内爆对称性。",
            "id": "3991159",
            "problem": "考虑一个用于间接驱动惯性约束聚变的圆柱形黑腔中的交叉光束能量转移 (Cross-Beam Energy Transfer, CBET) 的简化模型。交叉光束能量转移 (CBET) 通过在内锥和外锥光束之间重新分配激光束功率，来影响惯性约束聚变靶丸上的 X 射线驱动对称性。假设存在一个沿着公共路径坐标 $z \\in [0,L]$、长度为 $L$ 的一维相互作用区域。令 $P_i(z)$ 和 $P_o(z)$ 分别表示内锥和外锥光束的功率，单位均为瓦特。局部功率交换遵循以下耦合常微分方程组\n$$\\frac{dP_i}{dz} = -K\\,P_i\\,P_o,\\qquad \\frac{dP_o}{dz} = +K\\,P_i\\,P_o,$$\n其中 $K$ 是一个常数 CBET 耦合系数，单位为 $\\mathrm{W}^{-1}\\,\\mathrm{m}^{-1}$。假设初始条件为 $P_i(0)=P_{i0}$ 和 $P_o(0)=P_{o0}$，其中 $P_{i0}$ 和 $P_{o0}$ 的单位均为瓦特。如果在相互作用区域内，吸收和自发辐射可以忽略不计，则总功率 $P_i(z)+P_o(z)$ 是守恒的，这与黑腔设计中对称性控制分析常用的能量平衡假设相一致。\n\n任务：从基本能量守恒论证和给定的局部相互作用模型出发，推导一个算法来计算对于任意给定参数 $(P_{i0},P_{o0},K,L)$ 的最终功率 $P_i(L)$ 和 $P_o(L)$（单位：瓦特），并将其实现为一个完整的、可运行的程序。如果 $P_{i0}$ 或 $P_{o0}$ 为零，或者 $K=0$，或者 $L=0$，则将这些情况作为与控制方程和能量守恒一致的边界情况处理。\n\n单位和输出要求：\n- 所有输入功率的单位必须为瓦特，所有长度的单位必须为米，耦合系数的单位必须为 $\\mathrm{W}^{-1}\\,\\mathrm{m}^{-1}$。\n- 您的程序必须以瓦特为单位输出最终功率。\n- 为便于数值表示，请将每个最终功率四舍五入到 $6$ 位小数。\n\n测试套件：\n使用以下参数集来验证其正确性和边界情况下的行为。对于每种情况，计算 $P_i(L)$ 和 $P_o(L)$（单位：瓦特）。\n- 情况1（一般耦合，中等交换）：$(P_{i0},P_{o0},K,L) = (\\,600000.0\\,\\mathrm{W},\\,400000.0\\,\\mathrm{W},\\,10^{-6}\\,\\mathrm{W}^{-1}\\,\\mathrm{m}^{-1},\\,1.0\\,\\mathrm{m}\\,)$。\n- 情况2（无耦合）：$(P_{i0},P_{o0},K,L) = (\\,600000.0\\,\\mathrm{W},\\,400000.0\\,\\mathrm{W},\\,0.0\\,\\mathrm{W}^{-1}\\,\\mathrm{m}^{-1},\\,5.0\\,\\mathrm{m}\\,)$。\n- 情况3（强交换）：$(P_{i0},P_{o0},K,L) = (\\,800000.0\\,\\mathrm{W},\\,200000.0\\,\\mathrm{W},\\,5\\times 10^{-6}\\,\\mathrm{W}^{-1}\\,\\mathrm{m}^{-1},\\,1.5\\,\\mathrm{m}\\,)$。\n- 情况4（内锥光束功率为零）：$(P_{i0},P_{o0},K,L) = (\\,0.0\\,\\mathrm{W},\\,1000000.0\\,\\mathrm{W},\\,10^{-6}\\,\\mathrm{W}^{-1}\\,\\mathrm{m}^{-1},\\,10.0\\,\\mathrm{m}\\,)$。\n- 情况5（相互作用长度为零）：$(P_{i0},P_{o0},K,L) = (\\,500000.0\\,\\mathrm{W},\\,500000.0\\,\\mathrm{W},\\,10^{-6}\\,\\mathrm{W}^{-1}\\,\\mathrm{m}^{-1},\\,0.0\\,\\mathrm{m}\\,)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，每个用例表示为一个双元素列表 $[P_i(L),P_o(L)]$，且不含空格。例如，输出格式必须与以下完全一样：\n$$[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4],[x_5,y_5]]$$\n其中每个 $x_j$ 和 $y_j$ 是一个以瓦特为单位、四舍五入到 $6$ 位小数的十进制数。",
            "solution": "根据指定标准对问题进行验证。\n\n### 步骤1：提取已知条件\n- **控制方程**：一个描述一维路径 $z \\in [0,L]$ 上内锥功率 $P_i(z)$ 和外锥功率 $P_o(z)$ 的耦合常微分方程组：\n  $$ \\frac{dP_i}{dz} = -K\\,P_i\\,P_o $$\n  $$ \\frac{dP_o}{dz} = +K\\,P_i\\,P_o $$\n- **耦合系数**：$K$ 是一个常数，单位为 $\\mathrm{W}^{-1}\\,\\mathrm{m}^{-1}$。\n- **初始条件**：在 $z=0$ 处，功率为 $P_i(0)=P_{i0}$ 和 $P_o(0)=P_{o0}$，单位为瓦特。\n- **守恒定律**：总功率 $P_i(z)+P_o(z)$ 是守恒的。\n- **任务**：推导一个算法，根据给定参数 $(P_{i0}, P_{o0}, K, L)$ 求出最终功率 $P_i(L)$ 和 $P_o(L)$。\n- **边界情况**：对 $P_{i0}$、$P_{o0}$、$K$ 或 $L$ 为零的情况进行特殊处理。\n- **单位**：功率单位为瓦特 (W)，长度单位为米 (m)，$K$ 的单位为 $\\mathrm{W}^{-1}\\,\\mathrm{m}^{-1}$。\n- **输出精度**：最终功率必须四舍五入到 $6$ 位小数。\n- **测试套件**：\n  - 情况1：$(P_{i0},P_{o0},K,L) = (\\,600000.0\\,\\mathrm{W},\\,400000.0\\,\\mathrm{W},\\,10^{-6}\\,\\mathrm{W}^{-1}\\,\\mathrm{m}^{-1},\\,1.0\\,\\mathrm{m}\\,)$。\n  - 情况2：$(P_{i0},P_{o0},K,L) = (\\,600000.0\\,\\mathrm{W},\\,400000.0\\,\\mathrm{W},\\,0.0\\,\\mathrm{W}^{-1}\\,\\mathrm{m}^{-1},\\,5.0\\,\\mathrm{m}\\,)$。\n  - 情况3：$(P_{i0},P_{o0},K,L) = (\\,800000.0\\,\\mathrm{W},\\,200000.0\\,\\mathrm{W},\\,5\\times 10^{-6}\\,\\mathrm{W}^{-1}\\,\\mathrm{m}^{-1},\\,1.5\\,\\mathrm{m}\\,)$。\n  - 情况4：$(P_{i0},P_{o0},K,L) = (\\,0.0\\,\\mathrm{W},\\,1000000.0\\,\\mathrm{W},\\,10^{-6}\\,\\mathrm{W}^{-1}\\,\\mathrm{m}^{-1},\\,10.0\\,\\mathrm{m}\\,)$。\n  - 情况5：$(P_{i0},P_{o0},K,L) = (\\,500000.0\\,\\mathrm{W},\\,500000.0\\,\\mathrm{W},\\,10^{-6}\\,\\mathrm{W}^{-1}\\,\\mathrm{m}^{-1},\\,0.0\\,\\mathrm{m}\\,)$。\n\n### 步骤2：使用提取的已知条件进行验证\n对问题的有效性进行分析。\n1.  **科学基础**：该模型是交叉光束能量转移 (CBET) 的一个简化唯象表示，而 CBET 是惯性约束聚变研究中一个成熟的物理过程。耦合常微分方程是模拟相互作用的布居数或量的标准数学工具。所述的能量守恒是控制方程的直接数学推论：$\\frac{d}{dz}(P_i + P_o) = -K P_i P_o + K P_i P_o = 0$。该问题在科学上是合理的，并基于等离子体物理学和激光-物质相互作用的原理。\n2.  **适定性**：该问题是一个适定的初值问题。常微分方程组的右侧是利普希茨连续的，这保证了给定初始条件下解的唯一性。\n3.  **客观性与清晰性**：问题使用精确的数学表达式和客观、明确的语言进行表述。所有参数和变量都得到了清晰的定义。\n4.  **完整性与一致性**：问题提供了推导出解所需的所有必要信息（方程、初始条件、参数）。所述的能量守恒与所给的微分方程相一致。不存在矛盾。\n5.  **合理性**：单位在量纲上是一致的。测试用例中的数值代表了高能量密度物理实验中遇到的数量级。\n\n### 步骤3：结论与行动\n该问题是**有效的**。它在科学上是合理的，适定的，内部一致的，并且表述清晰。我们着手推导解。\n\n### 算法推导与求解\n\n该问题要求解关于光束功率 $P_i(z)$ 和 $P_o(z)$ 的耦合常微分方程组：\n$$ \\frac{dP_i}{dz} = -K\\,P_i\\,P_o \\quad (1) $$\n$$ \\frac{dP_o}{dz} = +K\\,P_i\\,P_o \\quad (2) $$\n初始条件为 $P_i(0) = P_{i0}$ 和 $P_o(0) = P_{o0}$。\n\n首先，我们验证总功率的守恒性。将方程 $(1)$ 和 $(2)$ 相加，得到：\n$$ \\frac{d}{dz}(P_i(z) + P_o(z)) = \\frac{dP_i}{dz} + \\frac{dP_o}{dz} = -K P_i P_o + K P_i P_o = 0 $$\n这证实了总功率 $P_T = P_i(z) + P_o(z)$ 沿相互作用路径 $z$ 是一个常数。其值由初始条件设定：\n$$ P_T = P_i(0) + P_o(0) = P_{i0} + P_{o0} $$\n这个守恒定律使我们可以将两个方程的方程组简化为单个方程。我们可以用 $P_i(z)$ 和常数 $P_T$ 来表示 $P_o(z)$：\n$$ P_o(z) = P_T - P_i(z) $$\n将此代入方程 $(1)$，我们得到一个关于 $P_i(z)$ 的单微分方程：\n$$ \\frac{dP_i}{dz} = -K P_i(z) (P_T - P_i(z)) $$\n这是一个标准的一阶非线性常微分方程，具体来说是一个可分离变量的逻辑斯谛型方程。我们分离变量以准备积分：\n$$ \\frac{dP_i}{P_i(P_T - P_i)} = -K\\,dz $$\n该方程在 $P_{i0}  0$ 且 $P_{o0}  0$ 的一般情况下有效。边界情况将分开处理。我们将两边从初始位置 $z=0$ 积分到最终位置 $z=L$：\n$$ \\int_{P_{i0}}^{P_i(L)} \\frac{dP_i}{P_i(P_T - P_i)} = \\int_0^L -K\\,dz = -K L $$\n假设 $P_T \\ne 0$，左侧的积分使用部分分式分解来求解。\n$$ \\frac{1}{P_i(P_T - P_i)} = \\frac{1}{P_T}\\left(\\frac{1}{P_i} + \\frac{1}{P_T - P_i}\\right) $$\n积分过程如下：\n$$ \\frac{1}{P_T} \\int_{P_{i0}}^{P_i(L)} \\left(\\frac{1}{P_i} + \\frac{1}{P_T - P_i}\\right) dP_i = -K L $$\n$$ \\frac{1}{P_T} \\left[ \\ln(P_i) - \\ln(P_T - P_i) \\right]_{P_{i0}}^{P_i(L)} = -K L $$\n代入积分上下限：\n$$ \\frac{1}{P_T} \\left( \\ln\\left(\\frac{P_i(L)}{P_T - P_i(L)}\\right) - \\ln\\left(\\frac{P_{i0}}{P_T - P_{i0}}\\right) \\right) = -K L $$\n注意到 $P_o = P_T - P_i$，我们可以用功率比 $R(z) = P_i(z)/P_o(z)$ 来表示此式：\n$$ \\ln(R(L)) - \\ln(R(0)) = -K P_T L $$\n$$ \\ln\\left(\\frac{R(L)}{R(0)}\\right) = -K P_T L $$\n对两边取指数，得到最终比率 $R(L)$ 与初始比率 $R(0)$ 的关系：\n$$ R(L) = R(0) \\exp(-K P_T L) = \\frac{P_{i0}}{P_{o0}} \\exp(-K(P_{i0}+P_{o0})L) $$\n利用最终比率 $R(L)$ 和守恒定律 $P_i(L) + P_o(L) = P_T$，我们构成一个包含两个代数方程的方程组来求解最终功率 $P_i(L)$ 和 $P_o(L)$：\n$$ P_i(L) = R(L) P_o(L) $$\n$$ R(L) P_o(L) + P_o(L) = P_T \\implies P_o(L) (R(L) + 1) = P_T $$\n由此得到最终外锥功率的解：\n$$ P_o(L) = \\frac{P_T}{R(L) + 1} $$\n以及最终内锥功率的解：\n$$ P_i(L) = P_T - P_o(L) = \\frac{P_T R(L)}{R(L) + 1} $$\n\n**边界情况分析**：\n推导出的解析解依赖于比率 $P_{i0}/P_{o0}$，当 $P_{o0}=0$ 时，该比率无定义。我们必须直接从常微分方程组分析这些情况。\n1.  如果 $K=0$ 或 $L=0$：则 $K L$ 项为零。指数项变为 $\\exp(0)=1$，因此 $R(L)=R(0)$。这意味着功率比不发生变化，因此，各个功率保持其初始值：$P_i(L)=P_{i0}$ 和 $P_o(L)=P_{o0}$。\n2.  如果 $P_{i0}=0$：从方程 $(1)$，$\\frac{dP_i}{dz} = -K P_i P_o$。如果 $P_i(0)=0$，则 $\\frac{dP_i}{dz}$ 初始值为 $0$。这个初值问题的唯一解是对于所有 $z \\ge 0$，$P_i(z)=0$。因此，根据功率守恒，$P_o(z) = P_{o0}$ 对所有 $z$ 成立。所以，$P_i(L)=0$ 且 $P_o(L)=P_{o0}$。\n3.  如果 $P_{o0}=0$：类似地，从方程 $(2)$，$\\frac{dP_o}{dz} = K P_i P_o$。如果 $P_o(0)=0$，则唯一解是对于所有 $z \\ge 0$，$P_o(z)=0$。因此，$P_i(z)=P_{i0}$。所以，$P_o(L)=0$ 且 $P_i(L)=P_{i0}$。\n\n**最终算法**：\n基于上述推导，一个计算 $(P_i(L), P_o(L))$ 的鲁棒算法如下：\n1.  输入参数 $(P_{i0}, P_{o0}, K, L)$。\n2.  检查边界条件：如果 $K=0$、$L=0$、$P_{i0}=0$ 或 $P_{o0}=0$，则没有能量交换。返回初始功率 $(P_{i0}, P_{o0})$。\n3.  对于一般情况：\n    a. 计算总功率：$P_T = P_{i0} + P_{o0}$。\n    b. 计算初始功率比：$R_0 = P_{i0} / P_{o0}$。\n    c. 计算指数因子：$\\alpha = \\exp(-K P_T L)$。\n    d. 计算最终功率比：$R_L = R_0 \\cdot \\alpha$。\n    e. 计算最终功率：\n       $P_o(L) = P_T / (R_L + 1)$。\n       $P_i(L) = P_T - P_o(L)$。\n    f. 返回 $(P_i(L), P_o(L))$。\n4.  将最终计算出的功率四舍五入到 $6$ 位小数以供输出。\n\n该算法为所有指定条件提供了完整且正确的解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the CBET problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (P_i0, P_o0, K, L)\n    test_cases = [\n        # Case 1 (general coupling, moderate exchange)\n        (600000.0, 400000.0, 1e-6, 1.0),\n        # Case 2 (no coupling)\n        (600000.0, 400000.0, 0.0, 5.0),\n        # Case 3 (strong exchange)\n        (800000.0, 200000.0, 5e-6, 1.5),\n        # Case 4 (zero inner-beam power)\n        (0.0, 1000000.0, 1e-6, 10.0),\n        # Case 5 (zero interaction length)\n        (500000.0, 500000.0, 1e-6, 0.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        p_i0, p_o0, K, L = case\n        \n        # Main logic to calculate the result for one case\n        p_i_L, p_o_L = solve_cbet(p_i0, p_o0, K, L)\n        \n        # Round the final powers to 6 decimal places as required.\n        p_i_L_rounded = round(p_i_L, 6)\n        p_o_L_rounded = round(p_o_L, 6)\n        \n        all_results.append((p_i_L_rounded, p_o_L_rounded))\n\n    # Format the results into the exact required string format.\n    # e.g., [[x1,y1],[x2,y2],...] with no spaces.\n    results_str_list = [f\"[{res[0]},{res[1]}]\" for res in all_results]\n    final_output_str = f\"[{','.join(results_str_list)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str)\n\ndef solve_cbet(p_i0, p_o0, K, L):\n    \"\"\"\n    Calculates the final powers P_i(L) and P_o(L) based on the analytical\n    solution to the CBET coupled equations.\n\n    Args:\n        p_i0 (float): Initial power of the inner beam in watts.\n        p_o0 (float): Initial power of the outer beam in watts.\n        K (float): CBET coupling coefficient in W^-1 m^-1.\n        L (float): Interaction length in meters.\n\n    Returns:\n        tuple: A tuple containing (P_i(L), P_o(L)) in watts.\n    \"\"\"\n    # Handle boundary cases where no energy transfer occurs.\n    # This occurs if the coupling K or length L is zero, or if one of the\n    # initial beam powers is zero (no medium for exchange).\n    if K == 0.0 or L == 0.0 or p_i0 == 0.0 or p_o0 == 0.0:\n        return p_i0, p_o0\n\n    # For the general case, apply the derived analytical solution.\n    \n    # 1. Calculate total power (conserved quantity)\n    p_total = p_i0 + p_o0\n    \n    # 2. Calculate the initial ratio of powers. This is safe due to the p_o0==0 check above.\n    r_0 = p_i0 / p_o0\n    \n    # 3. Calculate the argument of the exponential term in the solution for the ratio.\n    exponent_arg = -K * p_total * L\n    \n    # 4. Calculate the ratio of powers at z=L.\n    r_L = r_0 * np.exp(exponent_arg)\n    \n    # 5. Calculate final powers using the final ratio and conservation of power.\n    # P_o(L) = P_total / (R(L) + 1)\n    # P_i(L) = P_total - P_o(L)\n    p_o_L = p_total / (r_L + 1.0)\n    p_i_L = p_total - p_o_L\n    \n    return p_i_L, p_o_L\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}