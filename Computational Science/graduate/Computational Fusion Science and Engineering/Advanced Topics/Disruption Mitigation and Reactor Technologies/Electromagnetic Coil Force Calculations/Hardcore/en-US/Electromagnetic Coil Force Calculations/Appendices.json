{
    "hands_on_practices": [
        {
            "introduction": "Calculating the magnetic field from a current distribution is a cornerstone of magnetostatics, with the Biot-Savart law serving as the fundamental tool. This practice  guides you through the direct numerical implementation of the Biot-Savart law to compute the magnetic field of a circular coil and the subsequent Lorentz force on a second coil. The exercise emphasizes a critical aspect of computational physics: accurately handling near-singular integrands through adaptive quadrature, a technique essential for achieving reliable results when observation points are close to source currents.",
            "id": "3970518",
            "problem": "A single, perfectly conducting, circular filamentary coil with radius $a$ carrying steady current $I$ is centered at the origin and lies in the plane $z=0$. The magnetic field at an observation point $\\mathbf{r}$ due to this coil is defined by the Biot–Savart law, which states that for a current distribution confined to a one-dimensional curve, the magnetic field is given by an integral of the form\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0}{4\\pi}\\int_{\\mathcal{C}} \\frac{I\\,d\\boldsymbol{\\ell}\\times\\mathbf{\\hat{R}}}{R^2},\n$$\nwhere $\\mu_0$ is the magnetic permeability of free space, $d\\boldsymbol{\\ell}$ is the differential line element along the coil centerline $\\mathcal{C}$, $\\mathbf{R}=\\mathbf{r}-\\boldsymbol{\\ell}$ is the vector from a source point on the coil to the observation point, $R=\\|\\mathbf{R}\\|$, and $\\mathbf{\\hat{R}}=\\mathbf{R}/R$.\n\nIn addition to the magnetic field, consider a second circular filamentary coil with the same radius $a$ and current $I_2$, coaxial with the first coil but displaced along the $z$-axis by an offset $z_2$. The Lorentz force on the second coil due to the magnetic field generated by the first coil is given by a line integral of the magnetic part of the Lorentz force,\n$$\n\\mathbf{F} = \\int_{\\mathcal{C}_2} I_2\\, d\\boldsymbol{\\ell}_2 \\times \\mathbf{B}_1(\\boldsymbol{\\ell}_2),\n$$\nwhere $\\mathbf{B}_1$ is the field generated by the first coil, and $d\\boldsymbol{\\ell}_2$ is the differential line element along the second coil $\\mathcal{C}_2$.\n\nStarting from these fundamental laws, write a complete, runnable program that:\n- Represents the circular coil centerline parametrically and evaluates $\\mathbf{B}(\\mathbf{r})$ at arbitrary points $\\mathbf{r}$ using numerically robust quadrature of the Biot–Savart integral.\n- Implements composite quadrature with panel-wise Gaussian rules, together with local panel refinement that triggers when the observation point is close to the coil, in order to accurately resolve near-singular behavior of the integrand.\n- Computes the net force $\\mathbf{F}$ on a second coil using the magnetic field due to the first coil and the magnetic part of the Lorentz force law.\n\nYour solution must treat angles in radians. All physical quantities must be expressed in International System of Units (SI). Specifically:\n- Express magnetic field vectors $\\mathbf{B}$ in Tesla.\n- Express force vectors $\\mathbf{F}$ in Newtons.\n\nDesign the quadrature so that it is numerically stable for observation points not located exactly on the coil centerline. In your solution narrative, explain, from first principles, how to construct a singularity-aware numerical quadrature for the case when the observation point approaches the coil, and outline how one would regularize or subtract singular behavior when the point lies on the coil.\n\nTest Suite:\nUse the following parameter sets and observation points. The coil radius is $a=0.5\\,\\mathrm{m}$ and the current in the source coil is $I_1=15000\\,\\mathrm{A}$ in all cases unless otherwise specified.\n\n1. Magnetic field at an on-axis point: $\\mathbf{r}=(0,0,0.1)\\,\\mathrm{m}$.\n2. Magnetic field at a near-wire off-axis point: $\\mathbf{r}=(0.49,0.0,0.0)\\,\\mathrm{m}$.\n3. Magnetic field at a far off-axis point: $\\mathbf{r}=(1.5,0.0,0.2)\\,\\mathrm{m}$.\n4. Net force on a second coaxial coil located at $z=z_2=0.05\\,\\mathrm{m}$ with current $I_2=12000\\,\\mathrm{A}$ and radius $a=0.5\\,\\mathrm{m}$, due to the first coil at $z=0$ with current $I_1=15000\\,\\mathrm{A}$.\n\nFor each of the first three cases, compute the magnetic field vector $\\mathbf{B}$ in Tesla. For the fourth case, compute the net force vector $\\mathbf{F}$ in Newtons. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is a list of three floating-point numbers:\n$$\n[\\,[B_{x,1},B_{y,1},B_{z,1}],\\,[B_{x,2},B_{y,2},B_{z,2}],\\,[B_{x,3},B_{y,3},B_{z,3}],\\,[F_x,F_y,F_z]\\,].\n$$\nAll angles must be handled in radians. All physical quantities must be expressed in SI units. The numerical values must be returned as floating-point numbers. The final printout must contain only this single line with the nested list of results, without any additional explanatory text.",
            "solution": "The problem requires the numerical computation of the magnetic field $\\mathbf{B}$ generated by a circular filamentary current loop and the magnetic force $\\mathbf{F}$ between two coaxial loops. This is achieved by evaluating the Biot-Savart law and the Lorentz force law integrals using a robust numerical quadrature scheme. The core of the problem lies in handling the near-singular behavior of the Biot-Savart integrand when the observation point is close to the current-carrying wire.\n\n**1. Parametric Representation and Governing Equations**\n\nA circular filamentary coil of radius $a$ centered at the origin in the $z=0$ plane can be parameterized by an angle $\\phi \\in [0, 2\\pi]$. A source point $\\boldsymbol{\\ell}$ on the coil is given by:\n$$\n\\boldsymbol{\\ell}(\\phi) = (a \\cos\\phi, a \\sin\\phi, 0)\n$$\nThe differential line element $d\\boldsymbol{\\ell}$ is tangent to the coil and is found by differentiating $\\boldsymbol{\\ell}(\\phi)$ with respect to the parameter $\\phi$:\n$$\nd\\boldsymbol{\\ell} = \\frac{d\\boldsymbol{\\ell}}{d\\phi}d\\phi = (-a \\sin\\phi, a \\cos\\phi, 0) d\\phi\n$$\nThe Biot-Savart law gives the magnetic field $\\mathbf{B}$ at an observation point $\\mathbf{r}=(x, y, z)$ due to a steady current $I$ in the coil:\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi}\\int_{\\mathcal{C}} \\frac{d\\boldsymbol{\\ell} \\times \\mathbf{R}}{R^3}\n$$\nwhere $\\mathbf{R} = \\mathbf{r} - \\boldsymbol{\\ell}(\\phi)$ is the vector from the source point to the observation point, and $R = \\|\\mathbf{R}\\|$. Substituting the parametric forms, the integral becomes:\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\int_0^{2\\pi} \\frac{(d\\boldsymbol{\\ell}/d\\phi) \\times (\\mathbf{r} - \\boldsymbol{\\ell}(\\phi))}{\\|\\mathbf{r} - \\boldsymbol{\\ell}(\\phi)\\|^3} d\\phi\n$$\nThis is a vector-valued definite integral over the parameter $\\phi$. The integrand is a function $\\mathbf{f}(\\phi) = (f_x(\\phi), f_y(\\phi), f_z(\\phi))$, and each component must be integrated numerically.\n\nThe Lorentz force on a second coil $\\mathcal{C}_2$ with current $I_2$ due to the field $\\mathbf{B}_1$ from the first coil is:\n$$\n\\mathbf{F} = I_2 \\int_{\\mathcal{C}_2} d\\boldsymbol{\\ell}_2 \\times \\mathbf{B}_1(\\boldsymbol{\\ell}_2)\n$$\nFor a coaxial setup, significant simplifications arise from axisymmetry, which will be discussed in Section 4.\n\n**2. Numerical Quadrature Strategy: Composite Gaussian Quadrature**\n\nThe integrals are computed using composite Gauss-Legendre quadrature. The integration domain $[0, 2\\pi]$ is divided into multiple smaller intervals, or panels. On each panel $[\\phi_a, \\phi_b]$, an $N_p$-point Gauss-Legendre quadrature rule is applied. This rule approximates the integral by a weighted sum:\n$$\n\\int_{\\phi_a}^{\\phi_b} f(\\phi) d\\phi \\approx \\frac{\\phi_b - \\phi_a}{2} \\sum_{i=1}^{N_p} w_i f\\left(\\frac{\\phi_b - \\phi_a}{2} \\xi_i + \\frac{\\phi_a + \\phi_b}{2}\\right)\n$$\nwhere $\\xi_i$ and $w_i$ are the standard Gauss-Legendre nodes and weights on the interval $[-1, 1]$. This method is highly accurate for smooth integrands.\n\n**3. Adaptive Refinement for Near-Singularities**\n\nThe primary numerical challenge is the behavior of the Biot-Savart integrand when the observation point $\\mathbf{r}$ is very close to the coil. The denominator $R^3 = \\|\\mathbf{r} - \\boldsymbol{\\ell}(\\phi)\\|^3$ approaches zero, causing the integrand to become sharply peaked. A uniform quadrature grid would require an extremely large number of points to resolve this peak accurately.\n\nTo overcome this, an adaptive mesh refinement strategy is employed. The refinement is based on a geometric criterion:\n1.  The azimuthal angle of the observation point in cylindrical coordinates, $\\phi_{obs} = \\operatorname{atan2}(y, x)$, corresponds to the point on the coil closest to the observation point's projection on the $xy$-plane.\n2.  The integration interval $[0, 2\\pi]$ is initially divided into a set of panels.\n3.  Each panel is checked for possible refinement. A panel $[\\phi_a, \\phi_b]$ is subdivided if it contains the region of closest approach and the minimum distance $R_{min}$ from $\\mathbf{r}$ to the coil segment within that panel is small compared to the panel's arc length, $a(\\phi_b - \\phi_a)$. A typical criterion is to subdivide if $R_{min} < C \\cdot a(\\phi_b - \\phi_a)$ for a chosen constant $C > 1$.\n4.  This process is applied recursively, creating a non-uniform mesh of panels that is very fine near $\\phi_{obs}$ and coarse elsewhere. This concentrates computational effort where the integrand varies most rapidly, ensuring both accuracy and efficiency.\n\n**4. Force Calculation via Symmetry**\n\nFor two coaxial coils, the force calculation can be greatly simplified. Let coil 1 be at $z=0$ and coil 2 be at $z=z_2$, both with radius $a$. The force is $\\mathbf{F} = I_2 \\int_0^{2\\pi} (d\\boldsymbol{\\ell}_2/d\\phi_2) \\times \\mathbf{B}_1(\\boldsymbol{\\ell}_2(\\phi_2)) d\\phi_2$.\n\nDue to axisymmetry, the magnetic field $\\mathbf{B}_1$ at any point $\\boldsymbol{\\ell}_2(\\phi_2) = (a \\cos\\phi_2, a \\sin\\phi_2, z_2)$ on the second coil has only a radial and an axial component in a cylindrical coordinate system aligned with the point. The magnitude of these components, $B_\\rho$ and $B_z$, is constant for all points on coil 2. The field vector in Cartesian coordinates is $\\mathbf{B}_1(\\phi_2) = (B_\\rho \\cos\\phi_2, B_\\rho \\sin\\phi_2, B_z)$, where $B_\\rho$ and $B_z$ can be found by computing the field at a single point, e.g., $(a, 0, z_2)$. At this point, $B_\\rho = B_x$.\n\nThe differential force element is $d\\mathbf{F} = I_2 (d\\boldsymbol{\\ell}_2/d\\phi_2) \\times \\mathbf{B}_1 d\\phi_2$. Performing the cross product and integrating over $\\phi_2 \\in [0, 2\\pi]$:\n$$\nd\\mathbf{F} = I_2 \\left( (a B_z \\cos\\phi_2)\\mathbf{\\hat{i}} + (a B_z \\sin\\phi_2)\\mathbf{\\hat{j}} - (a B_\\rho)\\mathbf{\\hat{k}} \\right) d\\phi_2\n$$\nThe integrals of the $\\cos\\phi_2$ and $\\sin\\phi_2$ terms over $[0, 2\\pi]$ are zero. Thus, the net transverse forces ($F_x, F_y$) are zero, as expected from symmetry. The net axial force is:\n$$\n\\mathbf{F} = \\int_0^{2\\pi} I_2 (-a B_\\rho) \\mathbf{\\hat{k}} d\\phi_2 = -2\\pi a I_2 B_\\rho \\mathbf{\\hat{k}}\n$$\nTherefore, the total force can be found by computing the magnetic field $\\mathbf{B}_1$ at just one point on the second coil, e.g., $\\mathbf{r} = (a, 0, z_2)$, taking its radial component ($B_x$ at this point), and applying the formula for $F_z$.\n\n**5. Regularization for On-Coil Singularities**\n\nThe problem requires an outline for handling the case where the observation point $\\mathbf{r}$ lies *exactly* on the filamentary coil. In this idealized model, the integral for $\\mathbf{B}$ diverges. This is an unphysical artifact of the zero-thickness assumption.\n\nTo obtain a physically meaningful result, one must regularize the integral. A common method is **singularity subtraction**. The procedure is as follows:\n1.  Identify the singular point $\\phi_0$ such that $\\boldsymbol{\\ell}(\\phi_0) = \\mathbf{r}$.\n2.  Approximate the integrand $f(\\phi)$ near $\\phi_0$ with a simpler function $f_{sing}(\\phi)$ that captures the same singular behavior but can be integrated analytically. For a curved wire, the local singular behavior is like that of an infinite straight wire tangent to the curve at $\\phi_0$.\n3.  Rewrite the integral as:\n    $$\n    \\int_0^{2\\pi} f(\\phi) d\\phi = \\int_0^{2\\pi} (f(\\phi) - f_{sing}(\\phi)) d\\phi + \\int_0^{2\\pi} f_{sing}(\\phi) d\\phi\n    $$\n4.  The first term, the \"regularized integral,\" has its singularity canceled. The integrand is now well-behaved and can be computed accurately with numerical quadrature.\n5.  The second term, the \"singular part,\" is evaluated analytically. The sum of these two parts gives the regularized value of the field, which corresponds to a physical model (e.g., the field at the center of a wire of finite radius).\nThis approach separates the problematic part of the integral for analytical treatment, leaving a well-behaved numerical problem.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\n# Physical constants\nMU_0 = 4 * np.pi * 1.0e-7  # Magnetic permeability of free space (T*m/A)\n\ndef _gauss_legendre_quad(func, panel, n_points, func_args):\n    \"\"\"\n    Performs N-point Gauss-Legendre quadrature on a single panel.\n    \n    Args:\n        func: The vector-valued function to integrate.\n        panel: A tuple (a, b) defining the integration interval.\n        n_points: The number of Gaussian points to use.\n        func_args: A tuple of additional arguments to pass to func.\n\n    Returns:\n        np.ndarray: The result of the vector integration.\n    \"\"\"\n    a, b = panel\n    nodes, weights = roots_legendre(n_points)\n    \n    # Map nodes from [-1, 1] to [a, b]\n    mapped_nodes = 0.5 * (b - a) * nodes + 0.5 * (b + a)\n    \n    # Evaluate the function at all mapped nodes\n    # The function is expected to return a (3, k) array where k is the number of nodes\n    f_vals = func(mapped_nodes, *func_args)\n    \n    # Perform the weighted sum for each component (x, y, z)\n    integral_val = 0.5 * (b - a) * np.sum(f_vals * weights[np.newaxis, :], axis=1)\n    \n    return integral_val\n\ndef _calculate_b_integrand(phi, r_obs, a):\n    \"\"\"\n    Calculates the vector integrand of the Biot-Savart law for a circular coil.\n    Expects phi to be a numpy array of evaluation points.\n\n    Args:\n        phi (np.ndarray): Array of angles (source point parameter).\n        r_obs (np.ndarray): Observation point (x, y, z).\n        a (float): Radius of the coil.\n\n    Returns:\n        np.ndarray: A (3, N) array of the vector integrand values.\n    \"\"\"\n    # Source points l(phi) = (a*cos(phi), a*sin(phi), 0)\n    # The shape of phi is (k,), so l_vec has shape (3, k)\n    l_vec = np.array([a * np.cos(phi), a * np.sin(phi), np.zeros_like(phi)])\n    \n    # Differential line elements dl(phi)/dphi = (-a*sin(phi), a*cos(phi), 0)\n    dl_dphi = np.array([-a * np.sin(phi), a * np.cos(phi), np.zeros_like(phi)])\n    \n    # Vector R from source to observation point: R = r_obs - l(phi)\n    # r_obs has shape (3,), we reshape to (3, 1) for broadcasting with l_vec (3, k)\n    r_vec = r_obs.reshape(3, 1) - l_vec\n    \n    # Magnitude of R, with a small epsilon to avoid division by zero if r_obs is on the coil\n    r_mag = np.linalg.norm(r_vec, axis=0)\n    # Add a small machine-epsilon-level value for absolute stability on-coil.\n    r_mag[r_mag == 0] = 1e-15\n\n    # Integrand: (dl/dphi x R) / |R|^3\n    cross_product = np.cross(dl_dphi, r_vec, axisa=0, axisb=0, axisc=0)\n    integrand = cross_product / r_mag**3\n    \n    return integrand\n\ndef calculate_b(r_obs, a, I, n_gauss_points=16, initial_panels=16, refinement_factor=2.0, max_depth=15):\n    \"\"\"\n    Calculates the magnetic field B at an observation point r_obs.\n\n    Uses composite Gauss quadrature with adaptive panel refinement based on\n    proximity to the coil.\n    \"\"\"\n    r_obs = np.array(r_obs, dtype=float)\n    \n    # List to store the final panel intervals for integration\n    final_panels = []\n    \n    # Initial queue of panels to process for refinement\n    # Panel is defined by (start_angle, end_angle, depth)\n    panel_queue = [(i * 2 * np.pi / initial_panels, (i + 1) * 2 * np.pi / initial_panels, 0) for i in range(initial_panels)]\n\n    # Cylindrical coordinates of observation point for distance checking\n    rho_obs = np.sqrt(r_obs[0]**2 + r_obs[1]**2)\n    phi_obs = np.arctan2(r_obs[1], r_obs[0])\n    if phi_obs < 0:\n        phi_obs += 2 * np.pi\n\n    while panel_queue:\n        phi_start, phi_end, depth = panel_queue.pop(0)\n\n        # Find minimum distance from r_obs to the coil segment in this panel\n        min_dist_sq = -1.0\n        if phi_start <= phi_obs < phi_end:\n            # Point of closest approach is inside the panel's angular range\n            min_dist_sq = (rho_obs - a)**2 + r_obs[2]**2\n        else:\n            # Check endpoints\n            l_start = np.array([a * np.cos(phi_start), a * np.sin(phi_start), 0.0])\n            l_end = np.array([a * np.cos(phi_end), a * np.sin(phi_end), 0.0])\n            dist_sq_start = np.sum((r_obs - l_start)**2)\n            dist_sq_end = np.sum((r_obs - l_end)**2)\n            min_dist_sq = min(dist_sq_start, dist_sq_end)\n\n        min_dist = np.sqrt(min_dist_sq)\n\n        # Refinement condition\n        panel_arc_length = a * (phi_end - phi_start)\n        if depth < max_depth and min_dist < refinement_factor * panel_arc_length:\n            phi_mid = (phi_start + phi_end) / 2\n            panel_queue.append((phi_start, phi_mid, depth + 1))\n            panel_queue.append((phi_mid, phi_end, depth + 1))\n        else:\n            final_panels.append((phi_start, phi_end))\n\n    # Integrate over all the final panels\n    b_integral = np.zeros(3)\n    for panel in final_panels:\n        b_integral += _gauss_legendre_quad(\n            _calculate_b_integrand, panel, n_gauss_points, (r_obs, a)\n        )\n\n    return (MU_0 * I / (4 * np.pi)) * b_integral\n\ndef calculate_f(a, I1, I2, z2):\n    \"\"\"\n    Calculates the force on a second coaxial coil.\n    \"\"\"\n    # By symmetry, we only need the field at one point on the second coil,\n    # e.g., at (a, 0, z2), to find the total force.\n    r_obs_force = np.array([a, 0.0, z2])\n    \n    # Calculate B-field from coil 1 at this point\n    # Parameters for high accuracy required for this near-singular case\n    b_field = calculate_b(r_obs_force, a, I1, n_gauss_points=32, initial_panels=32, refinement_factor=2.0, max_depth=20)\n    \n    # The radial component of the B-field is B_x at (a, 0, z2)\n    b_radial = b_field[0]\n    \n    # Force F_z = -2 * pi * a * I2 * B_radial\n    # F_x and F_y are zero by symmetry.\n    fz = -2 * np.pi * a * I2 * b_radial\n    \n    return np.array([0.0, 0.0, fz])\n\ndef solve():\n    # Define the test cases from the problem statement.\n    a = 0.5  # m\n    I1 = 15000.0  # A\n\n    test_cases = [\n        {'type': 'B', 'params': {'r_obs': (0.0, 0.0, 0.1), 'a': a, 'I': I1}},\n        {'type': 'B', 'params': {'r_obs': (0.49, 0.0, 0.0), 'a': a, 'I': I1}},\n        {'type': 'B', 'params': {'r_obs': (1.5, 0.0, 0.2), 'a': a, 'I': I1}},\n        {'type': 'F', 'params': {'a': a, 'I1': I1, 'I2': 12000.0, 'z2': 0.05}}\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'B':\n            result = calculate_b(**case['params'])\n        elif case['type'] == 'F':\n            result = calculate_f(**case['params'])\n        # Convert to a standard list of floats for the output format\n        results.append([float(f) for f in result])\n\n    # Final print statement in the exact required format.\n    # The format uses list-of-lists, so we convert python lists to string representation.\n    # Note: Using repr() on each list ensures the correct bracket format.\n    print(f\"[{','.join(map(repr, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In computational science, verifying a code's correctness is as important as the initial implementation itself. This hands-on exercise  introduces a powerful verification strategy: solving the same problem with multiple, physically distinct methods to ensure they produce consistent results. You will compute the net force on a current loop in a uniform magnetic field using three different approaches: the direct integration of the Lorentz force, the surface integration of the Maxwell stress tensor, and the gradient of the magnetic dipole energy. By confirming that all three methods yield the known analytical result (zero force) within numerical tolerances, you will gain deep insight into the equivalence of these fundamental physical frameworks and build confidence in your computational toolkit.",
            "id": "3970467",
            "problem": "A circular current loop in vacuum is immersed in an externally imposed uniform magnetic field. The goal is to construct a numerical benchmark that computes the net electromagnetic force on the loop by three independent methods grounded in first principles and to compare their outputs against prescribed tolerances. The three methods are: a line-integration of the Lorentz force (Biot–Savart method for forces on current elements in an external field), a numerical surface integration of the Maxwell stress tensor (Finite Element Method (FEM)-style discretization over a spherical control surface), and an energy-gradient method based on magnetic dipole energy. The benchmark must be implemented as a complete, runnable program and produce a single-line output aggregating the results of all test cases.\n\nFundamental base to be used:\n- The Lorentz force law for a current element states that an infinitesimal force $d\\mathbf{F}$ on a line current due to a magnetic field $\\mathbf{B}$ is $d\\mathbf{F} = I\\,d\\boldsymbol{\\ell} \\times \\mathbf{B}$, where $I$ is the current and $d\\boldsymbol{\\ell}$ is the infinitesimal directed length element along the conductor.\n- The Maxwell stress tensor is defined by $\\mathbf{T} = \\frac{1}{\\mu_0}\\left(\\mathbf{B}\\mathbf{B}^\\top - \\frac{1}{2}|\\mathbf{B}|^2\\mathbf{I}\\right)$, where $\\mu_0$ is the permeability of free space, $\\mathbf{I}$ is the identity tensor, and $\\mathbf{B}\\mathbf{B}^\\top$ is the outer product. The net electromagnetic force $\\mathbf{F}$ on matter enclosed by a closed surface with outward normal $\\mathbf{n}$ is given by $\\mathbf{F} = \\oint_S \\mathbf{T}\\cdot\\mathbf{n}\\,dS$.\n- The magnetic dipole moment of a planar loop is $\\mathbf{m} = I\\,A\\,\\mathbf{n}$, where $A$ is the loop area and $\\mathbf{n}$ is the unit normal of the loop plane. The magnetic energy in a magnetic field is $U = -\\mathbf{m}\\cdot\\mathbf{B}$, and the force is $\\mathbf{F} = \\nabla(\\mathbf{m}\\cdot\\mathbf{B})$.\n\nProblem description to be implemented:\n- Consider a single circular loop of radius $R$ carrying steady current $I$, with loop plane unit normal $\\mathbf{n}$ and center at the origin. The externally imposed field is spatially uniform, $\\mathbf{B}_0$, and time independent. Vacuum permeability is $\\mu_0 = 4\\pi\\times10^{-7}\\,\\mathrm{H/m}$.\n- Method $1$ (Biot–Savart force on current elements in an external field): Parameterize the loop by angle $\\phi$ and numerically evaluate the closed line integral of $I\\,d\\boldsymbol{\\ell}\\times \\mathbf{B}_0$ over the loop, discretizing the loop into $N_{\\text{loop}}$ segments. This yields a net force vector in $\\mathrm{N}$.\n- Method $2$ (FEM-style Maxwell stress tensor surface integral): Numerically approximate $\\oint_S \\mathbf{T}(\\mathbf{B}_0)\\cdot\\mathbf{n}\\,dS$ over a sphere of radius $R_s$ centered at the origin using a spherical grid discretized by $N_\\theta$ polar divisions and $N_\\phi$ azimuthal divisions. Use the external field $\\mathbf{B}_0$ to define the tensor at each surface point. This yields a net force vector in $\\mathrm{N}$.\n- Method $3$ (Energy-gradient): Compute $\\mathbf{m} = I\\,\\pi R^2\\,\\mathbf{n}$ and evaluate a finite-difference approximation to $\\nabla(\\mathbf{m}\\cdot\\mathbf{B}_0)$ with a symmetric step $h$ in each Cartesian direction to obtain the net force vector in $\\mathrm{N}$.\n- Units: All forces must be computed in $\\mathrm{N}$, lengths in $\\mathrm{m}$, current in $\\mathrm{A}$, and magnetic field in $\\mathrm{T}$; angles are in radians.\n\nTest suite specification:\n- Case $1$ (baseline): $R = 0.5\\,\\mathrm{m}$, $I = 10{,}000\\,\\mathrm{A}$, $\\mathbf{B}_0 = (2.0, 0.0, 0.0)\\,\\mathrm{T}$, $\\mathbf{n} = (1.0, 0.0, 0.0)$, $R_s = 1.0\\,\\mathrm{m}$, $N_{\\text{loop}} = 2000$, $N_\\theta = 60$, $N_\\phi = 120$, $h = 10^{-4}\\,\\mathrm{m}$, absolute tolerance for force magnitude $t_f = 10^{-4}\\,\\mathrm{N}$, pairwise agreement tolerance $t_a = 5\\times10^{-5}\\,\\mathrm{N}$.\n- Case $2$ (oblique orientation): $R = 0.7\\,\\mathrm{m}$, $I = 5000\\,\\mathrm{A}$, $\\mathbf{B}_0 = (1.0, 1.0, 0.0)\\,\\mathrm{T}$, $\\mathbf{n} = (0.0, 0.0, 1.0)$, $R_s = 1.2\\,\\mathrm{m}$, $N_{\\text{loop}} = 1500$, $N_\\theta = 60$, $N_\\phi = 120$, $h = 5\\times10^{-5}\\,\\mathrm{m}$, $t_f = 2\\times10^{-4}\\,\\mathrm{N}$, $t_a = 10^{-4}\\,\\mathrm{N}$.\n- Case $3$ (small scale/high current): $R = 10^{-6}\\,\\mathrm{m}$, $I = 10^{6}\\,\\mathrm{A}$, $\\mathbf{B}_0 = (0.5, -0.3, 0.2)\\,\\mathrm{T}$, $\\mathbf{n} = (0.577350269, 0.577350269, 0.577350269)$, $R_s = 2\\times10^{-2}\\,\\mathrm{m}$, $N_{\\text{loop}} = 400$, $N_\\theta = 60$, $N_\\phi = 120$, $h = 10^{-6}\\,\\mathrm{m}$, $t_f = 10^{-3}\\,\\mathrm{N}$, $t_a = 5\\times10^{-4}\\,\\mathrm{N}$.\n\nVerification task:\n- For each case, compute the three force vectors. Verify both that each method individually yields a force magnitude less than $t_f$ and that all pairwise differences in force vectors are less than $t_a$ in magnitude. For each case, return a boolean that is $\\mathrm{True}$ if both conditions are met and $\\mathrm{False}$ otherwise.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, e.g., $[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3]$, where each $\\mathrm{result}_i$ is a boolean for Case $i$ following the above verification rule.",
            "solution": "The problem statement is assessed to be **valid**. It presents a well-posed and scientifically grounded task in computational electromagnetism. The problem asks for a numerical benchmark comparing three independent methods for calculating the electromagnetic force on a circular current loop in a uniform external magnetic field. The scenario is a standard textbook case where the analytical solution for the net force is known to be zero. Therefore, this problem serves as a verification test for the numerical accuracy and consistency of different computational physics algorithms. The provided data, parameters, and verification criteria are complete, consistent, and objective.\n\nThe solution will be implemented by creating a Python program that computes the force using the three specified methods for each test case, and then verifies the results against the given tolerances.\n\n**Analytical Ground Truth**\nFor a closed loop of current $I$ in a spatially uniform magnetic field $\\mathbf{B}_0$, the net electromagnetic force is analytically zero. This can be shown from the Lorentz force law:\n$$ \\mathbf{F} = \\oint I \\, d\\boldsymbol{\\ell} \\times \\mathbf{B}_0 $$\nSince both the current $I$ and the magnetic field $\\mathbf{B}_0$ are constant along the integration path, they can be factored out of the integral:\n$$ \\mathbf{F} = I \\left( \\oint d\\boldsymbol{\\ell} \\right) \\times \\mathbf{B}_0 $$\nThe vector integral of the path element $d\\boldsymbol{\\ell}$ over any closed loop is the zero vector, $\\oint d\\boldsymbol{\\ell} = \\mathbf{0}$. Consequently, the net force is zero:\n$$ \\mathbf{F} = I (\\mathbf{0}) \\times \\mathbf{B}_0 = \\mathbf{0} $$\nAll three numerical methods should, in the limit of infinite discretization, yield this zero result. The practical implementation will test how closely they approach zero and agree with each other given the specified numerical parameters.\n\n**Method 1: Lorentz Force Line Integral**\nThis method directly approximates the integral $\\mathbf{F} = \\oint I \\, d\\boldsymbol{\\ell} \\times \\mathbf{B}_0$. The circular loop of radius $R$ is discretized into $N_{\\text{loop}}$ straight line segments.\nFirst, an orthonormal basis $(\\mathbf{u}, \\mathbf{v}, \\mathbf{n})$ is constructed, where $\\mathbf{n}$ is the given loop normal and $(\\mathbf{u}, \\mathbf{v})$ span the plane of the loop. A point on the loop can be parameterized by an angle $\\phi \\in [0, 2\\pi]$:\n$$ \\mathbf{r}(\\phi) = R(\\cos\\phi \\, \\mathbf{u} + \\sin\\phi \\, \\mathbf{v}) $$\nThe loop is discretized by taking $N_{\\text{loop}}$ points $\\mathbf{r}_k = \\mathbf{r}(k \\cdot 2\\pi/N_{\\text{loop}})$ for $k = 0, 1, \\dots, N_{\\text{loop}}$. The $k$-th line element vector is $\\Delta\\boldsymbol{\\ell}_k = \\mathbf{r}_{k+1} - \\mathbf{r}_k$.\nThe total force is then calculated as the vector sum of the forces on each segment:\n$$ \\mathbf{F}_1 \\approx \\sum_{k=0}^{N_{\\text{loop}}-1} I (\\Delta\\boldsymbol{\\ell}_k \\times \\mathbf{B}_0) $$\nNumerically, the sum $\\sum \\Delta\\boldsymbol{\\ell}_k$ will be a small vector close to zero, resulting in a force vector $\\mathbf{F}_1$ whose magnitude is expected to be small.\n\n**Method 2: Maxwell Stress Tensor Surface Integral**\nThis method computes the force by integrating the Maxwell stress tensor $\\mathbf{T}$ over a closed control surface $S$ enclosing the current loop. The problem specifies using the tensor defined by the external field $\\mathbf{B}_0$ only:\n$$ \\mathbf{T}(\\mathbf{B}_0) = \\frac{1}{\\mu_0}\\left(\\mathbf{B}_0\\mathbf{B}_0^\\top - \\frac{1}{2}|\\mathbf{B}_0|^2\\mathbf{I}\\right) $$\nwhere $\\mu_0$ is the permeability of free space and $\\mathbf{I}$ is the $3 \\times 3$ identity tensor. The total force is given by the surface integral:\n$$ \\mathbf{F}_2 = \\oint_S \\mathbf{T}(\\mathbf{B}_0)\\cdot\\mathbf{n}_{\\text{surf}}\\,dS $$\nSince $\\mathbf{B}_0$ is uniform, the tensor $\\mathbf{T}(\\mathbf{B}_0)$ is constant. The integral simplifies to $\\mathbf{F}_2 = \\mathbf{T}(\\mathbf{B}_0) \\cdot \\oint_S \\mathbf{n}_{\\text{surf}}\\,dS$. The integral of the outward normal vector $\\mathbf{n}_{\\text{surf}}$ over any closed surface is zero. Thus, the analytical result is $\\mathbf{F}_2 = \\mathbf{0}$.\nFor the numerical implementation, the specified spherical control surface of radius $R_s$ is discretized into $N_\\theta \\times N_\\phi$ patches using spherical coordinates $(\\theta, \\phi)$. For each patch centered at $(\\theta_i, \\phi_j)$, its area $\\Delta S_{ij} = R_s^2 \\sin\\theta_i \\Delta\\theta \\Delta\\phi$ and normal vector $\\mathbf{n}_{ij}$ are computed. The total force is approximated by the sum:\n$$ \\mathbf{F}_2 \\approx \\sum_{i=0}^{N_{\\theta}-1} \\sum_{j=0}^{N_{\\phi}-1} (\\mathbf{T}(\\mathbf{B}_0) \\cdot \\mathbf{n}_{ij}) \\Delta S_{ij} $$\nThis sum approximates $\\mathbf{T}(\\mathbf{B}_0) \\cdot (\\sum \\mathbf{n}_{ij} \\Delta S_{ij})$, and since the sum of area-weighted normals approximates the zero vector, the resulting force $\\mathbf{F}_2$ should be close to zero.\n\n**Method 3: Energy-Gradient Method**\nThis method is based on the potential energy $U$ of a magnetic dipole $\\mathbf{m}$ in a magnetic field $\\mathbf{B}$, where the force is given by $\\mathbf{F} = \\nabla(\\mathbf{m}\\cdot\\mathbf{B})$. For a planar current loop, the magnetic dipole moment is $\\mathbf{m} = I A \\mathbf{n} = I (\\pi R^2) \\mathbf{n}$. The potential energy of this dipole in the external field $\\mathbf{B}_0$ at a position $\\mathbf{r}$ is $U(\\mathbf{r}) = -\\mathbf{m} \\cdot \\mathbf{B}_0(\\mathbf{r})$.\nSince the field $\\mathbf{B}_0$ is uniform, it does not vary with position, i.e., $\\mathbf{B}_0(\\mathbf{r})$ is a constant vector. Consequently, the potential energy $U$ is constant throughout space, and its gradient is zero:\n$$ \\mathbf{F}_3 = \\nabla U = \\nabla(-\\mathbf{m}\\cdot\\mathbf{B}_0) = \\mathbf{0} $$\nThe numerical method approximates the gradient using a symmetric finite-difference scheme with step size $h$. For instance, the $x$-component of the force is:\n$$ F_{3,x} \\approx \\frac{U(\\mathbf{r} + (h/2)\\hat{\\mathbf{x}}) - U(\\mathbf{r} - (h/2)\\hat{\\mathbf{x}})}{h} $$\nAs $U$ is spatially constant, the numerator is analytically zero. The numerical computation will therefore yield $\\mathbf{F}_3 = \\mathbf{0}$ up to the limits of floating-point precision.\n\n**Verification**\nFor each test case, the three computed force vectors, $\\mathbf{F}_1$, $\\mathbf{F}_2$, and $\\mathbf{F}_3$, are subjected to two checks.\n1. Force Magnitude Check: The magnitude of each force vector must be less than a given absolute tolerance $t_f$.\n   $$ |\\mathbf{F}_i| < t_f \\quad \\text{for } i \\in \\{1, 2, 3\\} $$\n2. Pairwise Agreement Check: The magnitude of the vector difference between any two methods must be less than a given agreement tolerance $t_a$.\n   $$ |\\mathbf{F}_i - \\mathbf{F}_j| < t_a \\quad \\text{for } i, j \\in \\{1, 2, 3\\}, i \\neq j $$\nA test case passes and returns $\\mathrm{True}$ only if both conditions are satisfied. Otherwise, it fails and returns $\\mathrm{False}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.constants import mu_0, pi\n\ndef calculate_force_lorentz(R, I, B0, n, N_loop):\n    \"\"\"\n    Computes the force on a circular loop using the integrated Lorentz force law.\n    Method 1.\n    \"\"\"\n    # Normalize the normal vector to be safe\n    n = n / np.linalg.norm(n)\n    \n    # Create an orthonormal basis (u, v, n) for the loop's plane.\n    # Choose a vector 'w' that is not collinear with 'n'.\n    # A robust choice is the cartesian axis \"least parallel\" to n.\n    if np.abs(n[0]) < 0.9 and np.abs(n[0]) <= np.abs(n[1]) and np.abs(n[0]) <= np.abs(n[2]):\n        w = np.array([1.0, 0.0, 0.0])\n    elif np.abs(n[1]) < 0.9 and np.abs(n[1]) <= np.abs(n[2]):\n        w = np.array([0.0, 1.0, 0.0])\n    else:\n        # This branch covers n being close to z-axis or cases where x and y failed.\n        # If n is (1,0,0) or (0,1,0), prev branches catch it. If n is close to (0,0,1), this works.\n        # It also works if n is, say, (0.95, 0, z), where w=(1,0,0) would be a bad choice.\n        # Using z-axis is as robust as any other axis if not collinear.\n        if not np.allclose(np.abs(n), [0, 0, 1]):\n             w = np.array([0.0, 0.0, 1.0])\n        else: # n is z-axis, w must be different\n             w = np.array([1.0, 0.0, 0.0])\n\n    u = np.cross(w, n)\n    u /= np.linalg.norm(u)\n    v = np.cross(n, u)\n\n    # Discretize the loop into N_loop+1 points to get N_loop segments\n    phi_pts = np.linspace(0, 2 * pi, N_loop + 1, endpoint=True)\n    \n    # Points on the loop: r(phi) = R * (cos(phi) * u + sin(phi) * v)\n    r = R * (np.cos(phi_pts)[:, np.newaxis] * u + np.sin(phi_pts)[:, np.newaxis] * v)\n\n    # Line element vectors dl for each segment\n    dl_segments = r[1:] - r[:-1]\n    \n    # Force F = sum(I * dl x B0)\n    force = I * np.sum(np.cross(dl_segments, B0), axis=0)\n    \n    return force\n\ndef calculate_force_mst(B0, Rs, N_theta, N_phi):\n    \"\"\"\n    Computes the force using the Maxwell Stress Tensor surface integral.\n    Method 2.\n    \"\"\"\n    # Maxwell stress tensor for uniform external field B0\n    B0_outer = np.outer(B0, B0)\n    B0_mag_sq = np.dot(B0, B0)\n    identity = np.identity(3)\n    T = (1.0 / mu_0) * (B0_outer - 0.5 * B0_mag_sq * identity)\n    \n    # Discretize the spherical surface using midpoint rule for integration\n    d_theta = pi / N_theta\n    d_phi = 2 * pi / N_phi\n    \n    theta_centers = np.linspace(d_theta / 2.0, pi - d_theta / 2.0, N_theta)\n    phi_centers = np.linspace(d_phi / 2.0, 2 * pi - d_phi / 2.0, N_phi)\n\n    force = np.zeros(3)\n\n    for theta_i in theta_centers:\n        for phi_j in phi_centers:\n            # Surface element area at the patch center\n            dS = Rs**2 * np.sin(theta_i) * d_theta * d_phi\n            \n            # Outward normal vector at the patch center\n            nx = np.sin(theta_i) * np.cos(phi_j)\n            ny = np.sin(theta_i) * np.sin(phi_j)\n            nz = np.cos(theta_i)\n            normal = np.array([nx, ny, nz])\n            \n            # Force contribution: dF = T . n dS\n            dF = T @ normal * dS\n            force += dF\n            \n    return force\n\ndef calculate_force_energy(R, I, n, B0, h):\n    \"\"\"\n    Computes the force using the energy-gradient method.\n    Method 3.\n    \"\"\"\n    # Magnetic dipole moment\n    m = I * pi * R**2 * n\n    \n    # Potential energy U(pos) = -m . B(pos).\n    # Since B is uniform B0, U is constant.\n    U_const = -np.dot(m, B0)\n    \n    # The finite difference of a constant function is zero.\n    Fx = (U_const - U_const) / h\n    Fy = (U_const - U_const) / h\n    Fz = (U_const - U_const) / h\n    \n    force = np.array([Fx, Fy, Fz])\n    return force\n\ndef verify_case(forces, tf, ta):\n    \"\"\"\n    Verifies the computed forces against magnitude and agreement tolerances.\n    \"\"\"\n    F1, F2, F3 = forces\n\n    # Condition 1: Each force magnitude is less than tf\n    mag_cond = (np.linalg.norm(F1) < tf and \n                np.linalg.norm(F2) < tf and \n                np.linalg.norm(F3) < tf)\n\n    # Condition 2: Pairwise differences are less than ta\n    agree_cond = (np.linalg.norm(F1 - F2) < ta and\n                  np.linalg.norm(F1 - F3) < ta and\n                  np.linalg.norm(F2 - F3) < ta)\n\n    return mag_cond and agree_cond\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (baseline)\n        {\n            \"R\": 0.5, \"I\": 10000.0, \"B0\": np.array([2.0, 0.0, 0.0]),\n            \"n\": np.array([1.0, 0.0, 0.0]), \"Rs\": 1.0, \"N_loop\": 2000,\n            \"N_theta\": 60, \"N_phi\": 120, \"h\": 1e-4, \"tf\": 1e-4, \"ta\": 5e-5\n        },\n        # Case 2 (oblique orientation)\n        {\n            \"R\": 0.7, \"I\": 5000.0, \"B0\": np.array([1.0, 1.0, 0.0]),\n            \"n\": np.array([0.0, 0.0, 1.0]), \"Rs\": 1.2, \"N_loop\": 1500,\n            \"N_theta\": 60, \"N_phi\": 120, \"h\": 5e-5, \"tf\": 2e-4, \"ta\": 1e-4\n        },\n        # Case 3 (small scale/high current)\n        {\n            \"R\": 1e-6, \"I\": 1e6, \"B0\": np.array([0.5, -0.3, 0.2]),\n            \"n\": np.array([0.577350269, 0.577350269, 0.577350269]), \"Rs\": 2e-2,\n            \"N_loop\": 400, \"N_theta\": 60, \"N_phi\": 120, \"h\": 1e-6, \"tf\": 1e-3, \"ta\": 5e-4\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        F1 = calculate_force_lorentz(case[\"R\"], case[\"I\"], case[\"B0\"], case[\"n\"], case[\"N_loop\"])\n        F2 = calculate_force_mst(case[\"B0\"], case[\"Rs\"], case[\"N_theta\"], case[\"N_phi\"])\n        F3 = calculate_force_energy(case[\"R\"], case[\"I\"], case[\"n\"], case[\"B0\"], case[\"h\"])\n        \n        is_valid = verify_case([F1, F2, F3], case[\"tf\"], case[\"ta\"])\n        results.append(is_valid)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Moving beyond analysis to design is a crucial step in engineering. This advanced practice  immerses you in a realistic optimization scenario common in fusion coil design: minimizing the peak electromagnetic forces on a set of conductors while simultaneously achieving a desired magnetic field profile at specific target locations. You will formulate this challenge as a constrained optimization problem and tackle it using a sophisticated and highly efficient technique. The core task involves deriving and implementing an adjoint-based method to compute the objective function's gradient, providing a powerful skill for solving large-scale design and inverse problems.",
            "id": "3970528",
            "problem": "You are asked to formulate and verify an adjoint-based gradient computation for an optimization problem relevant to electromagnetic coil force calculations in computational fusion science and engineering. Consider a coil system discretized into $M$ straight conductor segments with fixed geometry and unknown currents $\\{I_m\\}_{m=1}^M$. Each segment $m$ has center at position $\\mathbf{x}_m \\in \\mathbb{R}^3$, orientation given by a unit vector $\\hat{\\mathbf{s}}_m$, length $L_m$, and cross-sectional area $A_m$. The magnetostatic magnetic field at a set of $K$ target points $\\{\\mathbf{x}_k\\}_{k=1}^K$ due to the coil segments is given by the Biot–Savart law, which in continuous form is a fundamental law:\n$$\n\\mathbf{B}(\\mathbf{x}) \\;=\\; \\frac{\\mu_0}{4\\pi} \\int \\frac{I\\, d\\boldsymbol{\\ell} \\times (\\mathbf{x}-\\mathbf{r})}{\\|\\mathbf{x}-\\mathbf{r}\\|^3} \\, ,\n$$\nwhere $\\mu_0$ is the permeability of free space. Upon discretization along each straight segment using $N_q$ quadrature nodes, the normal component (here, choose the $z$-component) at the target points is a linear function of the currents described by a matrix $\\mathbf{G} \\in \\mathbb{R}^{K\\times M}$:\n$$\n\\mathbf{b}(\\mathbf{I}) \\;=\\; \\mathbf{G}\\,\\mathbf{I} \\, ,\n$$\nwhere $\\mathbf{I} = [I_1,\\dots,I_M]^T$ and $\\mathbf{b}(\\mathbf{I}) \\in \\mathbb{R}^K$ collects the $z$-components at the $K$ targets. The field performance constraint is an equality $\\mathbf{G}\\,\\mathbf{I} = \\mathbf{b}_{\\mathrm{target}}$.\n\nEach segment experiences a Lorentz force density due to a prescribed background magnetic field $\\mathbf{B}_{\\mathrm{back}}(\\mathbf{x})$ (for example, a toroidal background field and its spatial variation). The local Lorentz force density is the fundamental expression\n$$\n\\mathbf{f}(\\mathbf{x}) \\;=\\; \\mathbf{J}(\\mathbf{x}) \\times \\mathbf{B}(\\mathbf{x}) \\, .\n$$\nApproximating the peak along segments by an $\\ell_q$-norm with smoothing, define for segment $m$ the smoothed local magnitude\n$$\nf_m(\\mathbf{I}) \\;=\\; \\frac{\\sqrt{I_m^2 + \\varepsilon^2}}{A_m}\\,\\big\\| \\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\| \\, ,\n$$\nwith smoothing parameter $\\varepsilon > 0$. The peak proxy objective is the $\\ell_q$ norm\n$$\nF_q(\\mathbf{I}) \\;=\\; \\left( \\sum_{m=1}^M \\left[ f_m(\\mathbf{I}) \\right]^q \\right)^{1/q} \\, ,\n$$\nfor some $q \\ge 2$. To enforce the field performance constraint while maintaining computational tractability, consider a quadratic penalty formulation with weight $\\mu > 0$:\n$$\nJ_{\\mu}(\\mathbf{I}) \\;=\\; F_q(\\mathbf{I}) \\;+\\; \\frac{\\mu}{2}\\,\\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 \\, .\n$$\n\nYour tasks are:\n$1.$ Starting only from the fundamental laws stated above (the Biot–Savart law and the Lorentz force density), derive the gradient of $J_{\\mu}(\\mathbf{I})$ with respect to $\\mathbf{I}$ using an adjoint-method viewpoint. Clearly introduce an adjoint variable and show how the gradient can be assembled without explicitly differentiating the forward map beyond first-order linear algebraic operations.\n\n$2.$ Implement a program that\n$2.1.$ Constructs $\\mathbf{G}$ numerically by discretizing each straight segment into $N_q$ uniform quadrature nodes and evaluating the Biot–Savart integral for the $z$-component at each target point (assume the magnetic permeability of free space is $\\mu_0 = 4\\pi \\times 10^{-7}$ in $\\mathrm{H/m}$).\n$2.2.$ Defines the background field $\\mathbf{B}_{\\mathrm{back}}(\\mathbf{x})$ as\n$$\n\\mathbf{B}_{\\mathrm{back}}(x,y,z) \\;=\\; \\begin{bmatrix} 0.10\\,z \\\\ 0 \\\\ 1.50 \\;+\\; 0.05\\,x \\end{bmatrix} \\quad \\text{in Tesla} \\, ,\n$$\nand evaluates it at each segment center to compute $\\big\\|\\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\|$.\n$2.3.$ Uses the following fixed coil geometry and targets:\n$M = 4$ straight segments, each of length $L_m = 0.40$ in $\\mathrm{m}$, centered at positions\n$$\n\\mathbf{x}_1 = [-0.30,\\, 0.00,\\, 0.00]^T,\\;\\; \\mathbf{x}_2 = [-0.10,\\, 0.00,\\, 0.00]^T,\\;\\; \\mathbf{x}_3 = [0.10,\\, 0.00,\\, 0.00]^T,\\;\\; \\mathbf{x}_4 = [0.30,\\, 0.00,\\, 0.00]^T \\, ,\n$$\nwith orientations $\\hat{\\mathbf{s}}_m = [0,\\,1,\\,0]^T$ for all $m$, and cross-sectional areas\n$$\nA_1 = 5.0\\times 10^{-4},\\;\\; A_2 = 4.0\\times 10^{-4},\\;\\; A_3 = 6.0\\times 10^{-4},\\;\\; A_4 = 5.0\\times 10^{-4} \\quad \\text{in } \\mathrm{m}^2 \\, .\n$$\nLet the $K = 2$ target points be\n$$\n\\mathbf{x}_{\\mathrm{t},1} = [0.00,\\, 0.00,\\, 0.20]^T,\\qquad \\mathbf{x}_{\\mathrm{t},2} = [0.00,\\, 0.00,\\, 0.35]^T \\, .\n$$\nDefine the target $z$-components in Tesla as\n$$\n\\mathbf{b}_{\\mathrm{target}} = \\begin{bmatrix} 1.0\\times 10^{-5} \\\\ -0.5\\times 10^{-5} \\end{bmatrix} \\, .\n$$\nUse $N_q = 200$ quadrature nodes per segment for the Biot–Savart discretization.\n$2.4.$ For each test case, construct a baseline current vector $\\mathbf{I}$ by solving the Tikhonov-regularized least-squares problem\n$$\n\\mathbf{I}^\\star \\;=\\; \\arg\\min_{\\mathbf{I}} \\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 \\;+\\; \\alpha \\left\\| \\mathbf{I} \\right\\|_2^2 \\, ,\n$$\nwith $\\alpha = 1.0\\times 10^{-6}$, and use this $\\mathbf{I}^\\star$ to evaluate gradients.\n$2.5.$ Compute the adjoint-based gradient $\\nabla J_{\\mu}(\\mathbf{I}^\\star)$ you derived in task $1$, and verify it against a central finite-difference approximation with step size $h$ for each component:\n$$\n\\left[\\nabla J_{\\mu}(\\mathbf{I}^\\star)\\right]_m \\;\\approx\\; \\frac{J_{\\mu}(\\mathbf{I}^\\star + h\\,\\mathbf{e}_m) - J_{\\mu}(\\mathbf{I}^\\star - h\\,\\mathbf{e}_m)}{2h} \\, ,\n$$\nwhere $\\{\\mathbf{e}_m\\}$ is the standard basis.\n$2.6.$ Report for each test case the relative gradient error\n$$\n\\mathrm{err} \\;=\\; \\frac{\\left\\|\\nabla J_{\\mu}^{\\mathrm{adj}} - \\nabla J_{\\mu}^{\\mathrm{FD}}\\right\\|_2}{\\max\\left(1, \\left\\|\\nabla J_{\\mu}^{\\mathrm{FD}}\\right\\|_2\\right)} \\, ,\n$$\nwhich is dimensionless. Express all reported outputs as pure numbers without units.\n\nTest suite. Run exactly the following three test cases, each specified by $(q,\\mu,\\varepsilon,h)$:\n$1.$ $(4,\\, 5.0,\\, 1.0\\times 10^{-6},\\, 1.0\\times 10^{-7})$.\n$2.$ $(8,\\, 1.0,\\, 1.0\\times 10^{-8},\\, 5.0\\times 10^{-8})$.\n$3.$ $(16,\\, 0.5,\\, 1.0\\times 10^{-10},\\, 2.0\\times 10^{-8})$.\n\nFinal output format. Your program should produce a single line of output containing the three relative gradient errors in the order of the test cases as a comma-separated list enclosed in square brackets, for example, $[\\mathrm{err}_1,\\mathrm{err}_2,\\mathrm{err}_3]$. The outputs are dimensionless real numbers.",
            "solution": "The problem requires the derivation and implementation of an adjoint-based gradient calculation for a specific optimization functional $J_{\\mu}(\\mathbf{I})$ relevant to electromagnetic coil design in fusion science. The derivation must originate from the fundamental physical laws provided, and the implementation must be validated against a finite-difference approximation.\n\nFirst, the derivation of the gradient $\\nabla_{\\mathbf{I}} J_{\\mu}(\\mathbf{I})$ is performed using an adjoint method formulation. The objective functional is given as:\n$$\nJ_{\\mu}(\\mathbf{I}) = F_q(\\mathbf{I}) + \\frac{\\mu}{2}\\,\\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2\n$$\nThis functional consists of two terms. The first, $F_q(\\mathbf{I})$, depends directly on the optimization variables (currents $\\mathbf{I}$). The second is a quadratic penalty term that depends on $\\mathbf{I}$ through a linear \"forward map\" $\\mathbf{b}(\\mathbf{I}) = \\mathbf{G}\\mathbf{I}$, which represents the discretized Biot-Savart law. The gradient of $J_{\\mu}$ is the sum of the gradients of these two terms.\n\nLet's analyze the penalty term first from an adjoint perspective. We can write this part of the functional as $P(\\mathbf{b}(\\mathbf{I}))$, where the state variable is $\\mathbf{b} \\in \\mathbb{R}^K$ and the objective part is $P(\\mathbf{b}) = \\frac{\\mu}{2}\\|\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}}\\|_2^2$. The forward operator mapping the control variables $\\mathbf{I}$ to the state variables $\\mathbf{b}$ is $\\mathbf{b}(\\mathbf{I}) = \\mathbf{G}\\mathbf{I}$.\n\nThe total derivative of $P$ with respect to $\\mathbf{I}$ is given by the chain rule:\n$$\n\\nabla_{\\mathbf{I}} P = \\left(\\frac{d\\mathbf{b}}{d\\mathbf{I}}\\right)^T \\frac{\\partial P}{\\partial \\mathbf{b}}\n$$\nThe term $\\frac{d\\mathbf{b}}{d\\mathbf{I}}$ is the Jacobian of the forward map, which is simply the matrix $\\mathbf{G}$. The term $\\frac{\\partial P}{\\partial \\mathbf{b}}$ is the gradient of the objective with respect to the state. In the context of adjoint methods, this term is defined as the adjoint variable, $\\boldsymbol{\\lambda}$.\n$$\n\\boldsymbol{\\lambda} \\equiv \\frac{\\partial P}{\\partial \\mathbf{b}} = \\nabla_{\\mathbf{b}} \\left( \\frac{\\mu}{2} (\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}})^T (\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}}) \\right) = \\mu (\\mathbf{b} - \\mathbf{b}_{\\mathrm{target}})\n$$\nSubstituting $\\mathbf{b}=\\mathbf{G}\\mathbf{I}$, the adjoint variable is computed after the forward solve:\n$$\n\\boldsymbol{\\lambda} = \\mu (\\mathbf{G}\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}})\n$$\nThe gradient of the penalty term with respect to $\\mathbf{I}$ is then assembled by multiplying the adjoint variable by the transpose of the forward map's Jacobian:\n$$\n\\nabla_{\\mathbf{I}} \\left( \\frac{\\mu}{2}\\,\\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 \\right) = \\mathbf{G}^T \\boldsymbol{\\lambda} = \\mu \\mathbf{G}^T (\\mathbf{G}\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}})\n$$\nThis formulation demonstrates the core idea of the adjoint method: the action of the derivative on a perturbation $\\delta\\mathbf{I}$ is evaluated by first computing the state perturbation $\\delta\\mathbf{b} = \\mathbf{G}\\delta\\mathbf{I}$, then taking an inner product with the adjoint variable $\\boldsymbol{\\lambda}$, which encodes the sensitivity of the objective to the state. This transposes into $\\delta\\mathbf{I}^T (\\mathbf{G}^T \\boldsymbol{\\lambda})$ to find the gradient with respect to $\\mathbf{I}$.\n\nNext, we address the first term, $F_q(\\mathbf{I})$, which is defined as:\n$$\nF_q(\\mathbf{I}) = \\left( \\sum_{m=1}^M \\left[ f_m(\\mathbf{I}) \\right]^q \\right)^{1/q}\n$$\nSince each $f_m(\\mathbf{I})$ depends only on the corresponding current component $I_m$, its gradient can be computed directly by applying the chain rule. The $j$-th component of the gradient $\\nabla_{\\mathbf{I}} F_q(\\mathbf{I})$ is:\n$$\n\\frac{\\partial F_q}{\\partial I_j} = \\frac{1}{q} \\left( \\sum_{m=1}^M [f_m]^q \\right)^{\\frac{1}{q}-1} \\cdot q [f_j]^{q-1} \\frac{\\partial f_j}{\\partial I_j} = \\left( F_q(\\mathbf{I}) \\right)^{1-q} [f_j(\\mathbf{I})]^{q-1} \\frac{d f_j}{d I_j}\n$$\nThe force magnitude proxy $f_m$ for segment $m$ is:\n$$\nf_m(\\mathbf{I}) = \\frac{\\sqrt{I_m^2 + \\varepsilon^2}}{A_m}\\,\\big\\| \\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\|\n$$\nIts derivative with respect to $I_m$ is:\n$$\n\\frac{d f_m}{d I_m} = \\frac{I_m}{\\sqrt{I_m^2 + \\varepsilon^2}} \\frac{\\big\\| \\hat{\\mathbf{s}}_m \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_m)\\big\\|}{A_m}\n$$\nCombining these results, the $j$-th component of the gradient of $F_q$ is:\n$$\n[\\nabla_{\\mathbf{I}} F_q(\\mathbf{I})]_j = \\left( F_q(\\mathbf{I}) \\right)^{1-q} [f_j(\\mathbf{I})]^{q-1} \\frac{I_j}{\\sqrt{I_j^2 + \\varepsilon^2}} \\frac{\\|\\hat{\\mathbf{s}}_j \\times \\mathbf{B}_{\\mathrm{back}}(\\mathbf{x}_j)\\|}{A_j}\n$$\n\nFinally, the full gradient of the objective functional $J_{\\mu}(\\mathbf{I})$ is the sum of the gradients of its two parts:\n$$\n\\nabla_{\\mathbf{I}} J_{\\mu}(\\mathbf{I}) = \\nabla_{\\mathbf{I}} F_q(\\mathbf{I}) + \\mu \\mathbf{G}^T (\\mathbf{G}\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}})\n$$\nThis is the analytical expression for the adjoint-based gradient.\n\nThe implementation plan is as follows:\n$1.$ The response matrix $\\mathbf{G} \\in \\mathbb{R}^{K \\times M}$ is constructed numerically. Each element $G_{km}$ is the $z$-component of the magnetic field at target point $\\mathbf{x}_{\\mathrm{t},k}$ generated by segment $m$ with unit current. This is computed by discretizing the Biot-Savart integral for a straight segment using $N_q=200$ quadrature points. With $\\mathbf{r}(t) = \\mathbf{x}_m + t\\hat{\\mathbf{s}}_m$ for $t \\in [-L_m/2, L_m/2]$ and $\\Delta t = L_m/N_q$, the formula is:\n$$\nG_{km} = \\frac{\\mu_0}{4\\pi} \\sum_{i_q=0}^{N_q-1} \\left[ \\frac{\\hat{\\mathbf{s}}_m \\times (\\mathbf{x}_{\\mathrm{t},k} - \\mathbf{r}(t_{i_q}))}{\\|\\mathbf{x}_{\\mathrm{t},k} - \\mathbf{r}(t_{i_q})\\|^3} \\right]_z \\Delta t\n$$\nwhere $t_{i_q}$ are the midpoints of the quadrature subintervals.\n$2.$ A baseline current vector $\\mathbf{I}^\\star$ is determined by solving the Tikhonov-regularized least-squares problem $\\min_{\\mathbf{I}} \\left\\| \\mathbf{G}\\,\\mathbf{I} - \\mathbf{b}_{\\mathrm{target}} \\right\\|_2^2 + \\alpha \\left\\| \\mathbf{I} \\right\\|_2^2$. The solution is found via the normal equations: $\\mathbf{I}^\\star = (\\mathbf{G}^T \\mathbf{G} + \\alpha \\mathbf{I}_{\\text{identity}})^{-1} \\mathbf{G}^T \\mathbf{b}_{\\mathrm{target}}$.\n$3.$ The adjoint gradient $\\nabla J_{\\mu}^{\\mathrm{adj}}(\\mathbf{I}^\\star)$ is computed using the derived formula.\n$4.$ A validation gradient $\\nabla J_{\\mu}^{\\mathrm{FD}}(\\mathbf{I}^\\star)$ is computed using the central finite-difference formula for each component $m$: $[\\nabla J_{\\mu}^{\\mathrm{FD}}]_m = \\frac{J_{\\mu}(\\mathbf{I}^\\star + h\\mathbf{e}_m) - J_{\\mu}(\\mathbf{I}^\\star - h\\mathbf{e}_m)}{2h}$.\n$5.$ The relative error between the two gradients is calculated as $\\mathrm{err} = \\frac{\\|\\nabla J_{\\mu}^{\\mathrm{adj}} - \\nabla J_{\\mu}^{\\mathrm{FD}}\\|_2}{\\max(1, \\|\\nabla J_{\\mu}^{\\mathrm{FD}}\\|_2)}$. This process is repeated for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to derive and verify the adjoint-based gradient for the coil optimization problem.\n    \"\"\"\n    #\n    # Step 2.1 & 2.3: Define fixed geometry, targets, and constants\n    #\n    MU0 = 4 * np.pi * 1e-7  # Permeability of free space (H/m)\n    M = 4  # Number of coil segments\n    K = 2  # Number of target points\n    N_q = 200 # Number of quadrature nodes per segment\n    ALPHA = 1.0e-6 # Tikhonov regularization parameter\n\n    # Coil segment properties\n    L_m = 0.40  # Length of each segment (m)\n    centers = np.array([\n        [-0.30, 0.00, 0.00],\n        [-0.10, 0.00, 0.00],\n        [0.10, 0.00, 0.00],\n        [0.30, 0.00, 0.00]\n    ])\n    orientations = np.array([[0.0, 1.0, 0.0]] * M)\n    areas = np.array([5.0e-4, 4.0e-4, 6.0e-4, 5.0e-4]) # m^2\n\n    # Target point properties\n    target_points = np.array([\n        [0.00, 0.00, 0.20],\n        [0.00, 0.00, 0.35]\n    ])\n    b_target = np.array([1.0e-5, -0.5e-5]) # Tesla\n\n    #\n    # Helper function for background magnetic field\n    #\n    def B_back(p):\n        x, y, z = p\n        return np.array([0.10 * z, 0.0, 1.50 + 0.05 * x])\n\n    # Pre-compute constants for force calculation\n    C_m = np.array([\n        np.linalg.norm(np.cross(orientations[m], B_back(centers[m])))\n        for m in range(M)\n    ])\n\n    #\n    # Step 2.1: Construct the response matrix G\n    #\n    G = np.zeros((K, M))\n    dt = L_m / N_q\n    t_nodes = -L_m / 2 + (np.arange(N_q) + 0.5) * dt\n\n    for k in range(K):\n        for m in range(M):\n            g_km = 0.0\n            x_t = target_points[k]\n            x_m = centers[m]\n            s_m = orientations[m]\n            \n            for t in t_nodes:\n                r_line = x_m + t * s_m\n                R_vec = x_t - r_line\n                R_norm = np.linalg.norm(R_vec)\n                \n                integrand_vec = np.cross(s_m, R_vec) / (R_norm**3)\n                g_km += integrand_vec[2] # z-component\n\n            G[k, m] = (MU0 / (4 * np.pi)) * g_km * dt\n\n    #\n    # Step 2.4: Compute the baseline current vector I_star\n    #\n    G_T_G = G.T @ G\n    reg_matrix = G_T_G + ALPHA * np.identity(M)\n    rhs = G.T @ b_target\n    I_star = linalg.solve(reg_matrix, rhs, assume_a='sym')\n\n    #\n    # Define objective function and its gradient components\n    #\n    def compute_f_m(I, epsilon):\n        # Smoothed force magnitude proxy for each segment\n        return (np.sqrt(I**2 + epsilon**2) / areas) * C_m\n\n    def compute_F_q(I, q, epsilon):\n        # L_q norm of the force proxies\n        f_vals = compute_f_m(I, epsilon)\n        return np.sum(f_vals**q)**(1.0 / q)\n\n    def compute_J_mu(I, q, mu, epsilon):\n        # Full objective functional\n        F_q_val = compute_F_q(I, q, epsilon)\n        penalty = (mu / 2.0) * np.linalg.norm(G @ I - b_target)**2\n        return F_q_val + penalty\n\n    def compute_adjoint_gradient(I, q, mu, epsilon):\n        # Adjoint-based gradient\n        # Gradient of the penalty term\n        grad_penalty = mu * G.T @ (G @ I - b_target)\n\n        # Gradient of the force term F_q\n        f_vals = compute_f_m(I, epsilon)\n        F_q_val = np.sum(f_vals**q)**(1.0 / q)\n        \n        df_dI = (I / np.sqrt(I**2 + epsilon**2)) * (C_m / areas)\n        \n        # Handle case where F_q is very close to zero\n        if F_q_val < 1e-16:\n             grad_Fq = np.zeros_like(I)\n        else:\n            grad_Fq = (F_q_val**(1 - q)) * (f_vals**(q - 1)) * df_dI\n\n        return grad_Fq + grad_penalty\n\n    def compute_fd_gradient(I, q, mu, epsilon, h):\n        # Central finite-difference gradient for verification\n        grad_fd = np.zeros(M)\n        for m in range(M):\n            I_plus = I.copy()\n            I_plus[m] += h\n            I_minus = I.copy()\n            I_minus[m] -= h\n\n            J_plus = compute_J_mu(I_plus, q, mu, epsilon)\n            J_minus = compute_J_mu(I_minus, q, mu, epsilon)\n            \n            grad_fd[m] = (J_plus - J_minus) / (2.0 * h)\n        return grad_fd\n\n    #\n    # Test suite execution\n    #\n    test_cases = [\n        (4, 5.0, 1.0e-6, 1.0e-7),\n        (8, 1.0, 1.0e-8, 5.0e-8),\n        (16, 0.5, 1.0e-10, 2.0e-8),\n    ]\n\n    results = []\n    for q, mu, epsilon, h in test_cases:\n        # Step 2.5: Compute gradients\n        grad_adj = compute_adjoint_gradient(I_star, q, mu, epsilon)\n        grad_fd = compute_fd_gradient(I_star, q, mu, epsilon, h)\n\n        # Step 2.6: Compute relative error\n        norm_fd = np.linalg.norm(grad_fd)\n        norm_diff = np.linalg.norm(grad_adj - grad_fd)\n        \n        err = norm_diff / max(1.0, norm_fd)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}