{
    "hands_on_practices": [
        {
            "introduction": "理解自组织临界性中的输运雪崩，首先要掌握其触发的物理条件。这个练习将引导我们通过一个简化的解析模型，来确定等离子体剖面在何处变得不稳定。通过计算超过临界梯度的空间区域 ，我们可以从第一性原理层面，为理解更复杂的动态模拟奠定基础。",
            "id": "4044333",
            "problem": "考虑一个磁约束聚变等离子体，其小半径坐标为 $r \\in [0,a]$，平衡电子温度剖面为 $T(r)=T_{0}\\left(1-\\left(\\frac{r}{a}\\right)^{2}\\right)$，其中 $T_{0}>0$ 和 $a>0$ 是常数。在输运的自组织临界性 (SOC) 模型中，当局部驱动的绝对值（通常取为径向温度梯度的量值）超过一个临界阈值时，会触发局部雪崩事件。假设临界阈值由一个参考临界温度剖面 $T_{c}(r)$ 编码，其径向导数在空间上是恒定的，即 $\\partial_{r}T_{c}(r)=-\\frac{T_{c}}{a}$，其中 $T_{c}>0$ 是一个给定的常数，而 $a$ 等于等离子体小半径。\n\n从径向梯度的定义和被解释为局部梯度比较的 SOC 触发条件出发，确定使 $\\partial_{r}T(r)>\\partial_{r}T_{c}(r)$ 成立的 $r$ 的空间区域，并找出系统首次达到此条件的临界半径。基于梯度驱动的雪崩现象学，仅使用给定信息和梯度驱动输运的第一性原理，说明雪崩预计在相对于此临界半径的何处开始。\n\n以 $T_{0}$、$T_{c}$ 和 $a$ 的单个闭合形式表达式报告临界半径 $r_{c}$。以米为单位表示 $r_{c}$。不需要进行数值舍入。",
            "solution": "在尝试求解之前，将首先对问题进行验证，以确保其科学上合理、内容自洽且提法恰当。\n\n### 步骤 1：提取已知条件\n- 等离子体小半径坐标：$r \\in [0,a]$。\n- 平衡电子温度剖面：$T(r)=T_{0}\\left(1-\\left(\\frac{r}{a}\\right)^{2}\\right)$。\n- 常数：$T_{0}>0$ 且 $a>0$。$a$ 是等离子体小半径。\n- 自组织临界性 (SOC) 触发条件是当局部驱动的绝对值（径向温度梯度的量值）超过临界阈值时。\n- 临界阈值由参考临界温度剖面 $T_{c}(r)$ 编码。\n- 临界温度剖面的径向导数是一个常数：$\\partial_{r}T_{c}(r)=-\\frac{T_{c}}{a}$。\n- 常数：$T_{c}>0$。\n- 任务 1：确定使 $\\partial_{r}T(r)>\\partial_{r}T_{c}(r)$ 成立的 $r$ 的空间区域。\n- 任务 2：找出首次满足此条件的临界半径 $r_{c}$（即在该区域的边界处）。\n- 任务 3：说明相对于 $r_c$ 雪崩预计在何处开始。\n- 最终答案：$r_c$ 以 $T_{0}$、$T_{c}$ 和 $a$ 的闭合形式表达式表示，单位为米。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题描述了聚变等离子体中的一个简化输运模型，这是理论和计算等离子体物理中的一种常用方法。温度剖面是标准的抛物线形式。用临界温度梯度来触发输运事件（雪崩）的概念是现代输运理论的核心原则，尤其是在离子温度梯度 (ITG) 和电子温度梯度 (ETG) 湍流的背景下。对于一个解析模型，假设临界梯度在空间上恒定是一个有效的简化。\n\n问题陈述中存在一个潜在的模糊之处。它首先将雪崩的物理触发描述为温度梯度量值 $|\\partial_r T|$ 超过临界阈值 $|\\partial_r T_c|$ 的点。由于对于中心尖峰的温度剖面，两个梯度都预期为负，因此这个物理条件是 $- \\partial_r T(r) > - \\partial_r T_c(r)$，简化为 $\\partial_r T(r)  \\partial_r T_c(r)$。然而，问题接着明确要求确定相反不等式 $\\partial_{r}T(r)  \\partial_{r}T_{c}(r)$ 成立的区域。这不是一个矛盾，而是一个结构化的问题。它要求解出稳定区域（亚临界梯度），然后确定其边界，即临界半径 $r_c$。后续关于雪崩在何处开始的问题正确地回溯到梯度驱动输运的物理原理。\n\n因此，该问题在一个简化的模型框架内具有科学依据，数学上是适定的、客观的，并且内部一致。所有必要的信息都已提供，可以找到 $r_c$ 的唯一解。\n\n### 步骤 3：结论与行动\n问题被认定为有效。将推导解答。\n\n### 解答推导\n电子温度剖面由下式给出：\n$$T(r) = T_{0}\\left(1 - \\left(\\frac{r}{a}\\right)^{2}\\right)$$\n该温度剖面的径向梯度 $\\partial_{r}T(r)$ 通过对小半径坐标 $r$ 求导得到：\n$$\\partial_{r}T(r) = \\frac{d}{dr}\\left[T_{0}\\left(1 - \\frac{r^{2}}{a^{2}}\\right)\\right] = T_{0} \\left(0 - \\frac{2r}{a^{2}}\\right)$$\n$$\\partial_{r}T(r) = -\\frac{2T_{0}r}{a^{2}}$$\n对于 $r0$，该梯度为负，正确地表示了热量从热芯部流向较冷的边缘。\n\n临界温度梯度作为一个常数给出：\n$$\\partial_{r}T_{c}(r) = -\\frac{T_{c}}{a}$$\n\n问题的第一部分要求找出 $\\partial_{r}T(r)  \\partial_{r}T_{c}(r)$ 的空间区域。我们将梯度的表达式代入此不等式：\n$$-\\frac{2T_{0}r}{a^{2}}  -\\frac{T_{c}}{a}$$\n为了解出 $r$，我们将不等式两边乘以 $-1$，这会反转不等号：\n$$\\frac{2T_{0}r}{a^{2}}  \\frac{T_{c}}{a}$$\n由于 $a  0$，我们可以将两边乘以 $a^{2}$ 而不改变不等式：\n$$2T_{0}r  T_{c}a$$\n鉴于 $T_{0}  0$，我们可以除以 $2T_{0}$：\n$$r  \\frac{T_{c}a}{2T_{0}}$$\n该不等式定义了温度梯度为亚临界（即陡峭程度小于临界阈值）的区域。考虑到物理定义域 $r \\in [0,a]$，完整区域为 $0 \\le r  \\frac{T_{c}a}{2T_{0}}$。\n\n临界半径 $r_c$ 是系统恰好处于临界阈值的位置。这发生在上面找到的区域的边界处，此时不等式变为等式：\n$$\\partial_{r}T(r_{c}) = \\partial_{r}T_{c}(r_{c})$$\n代入表达式：\n$$-\\frac{2T_{0}r_{c}}{a^{2}} = -\\frac{T_{c}}{a}$$\n求解 $r_c$：\n$$r_{c} = \\left(\\frac{T_{c}}{a}\\right) \\left(\\frac{a^{2}}{2T_{0}}\\right)$$\n$$r_{c} = \\frac{T_{c}a}{2T_{0}}$$\n这就是临界半径的闭合形式表达式。$a$ 的单位是米，$T_0$ 和 $T_c$ 的单位相互抵消，因此 $r_c$ 的单位是米，符合要求。\n\n最后，我们被要求根据梯度驱动现象学说明雪崩预计在何处开始。当系统不稳定时会触发雪崩，这发生在驱动梯度的量值超过临界阈值时。驱动梯度的量值为 $|\\partial_{r}T(r)| = \\frac{2T_{0}r}{a^{2}}$，临界阈值的量值为 $|\\partial_{r}T_{c}(r)| = \\frac{T_{c}}{a}$。因此，雪崩条件是：\n$$|\\partial_{r}T(r)|  |\\partial_{r}T_{c}(r)|$$\n$$\\frac{2T_{0}r}{a^{2}}  \\frac{T_{c}}{a}$$\n求解 $r$ 得到：\n$$r  \\frac{T_{c}a}{2T_{0}}$$\n将此与临界半径的表达式进行比较，雪崩的起始条件是 $r  r_{c}$。因此，雪崩预计在临界半径 $r_{c}$ 以外的等离子体区域（径向向外）开始，那里的温度梯度变得超临界。临界半径 $r_{c}$ 标志着内部稳定区域 ($r  r_c$) 与外部不稳定或“刚性”区域 ($r  r_c$) 之间的边界。",
            "answer": "$$\\boxed{\\frac{T_{c}a}{2T_{0}}}$$"
        },
        {
            "introduction": "在确定了雪崩的局域触发条件后，下一步是模拟这些不稳定性如何演变成间歇性的大尺度输运事件。本实践将通过实现一个带阈值输运系数的一维输运模型，来动态地观察雪崩的产生和传播 。这个练习不仅能加深对SOC动力学的理解，还能锻炼构建和分析非线性偏微分方程数值解的核心计算技能。",
            "id": "4044295",
            "problem": "考虑一个一维径向对称的输运模型，用于描述在区间 $r \\in [0,a]$ 和时间 $t \\ge 0$ 上归一化温度 $T(r,t)$ 的演化。该模型的建立受到了磁约束聚变等离子体中自组织临界（SOC）和雪崩状事件的启发。温度的演化由以下非线性扩散方程决定\n$$\n\\partial_t T(r,t) = \\partial_r\\left(\\chi\\left(T,\\partial_r T\\right)\\,\\partial_r T\\right) + S(r,t),\n$$\n其中 $\\chi$ 是一个有阈值的输运系数，$S$ 是一个缓慢变化的核心区驱动。全文使用无量纲的归一化单位；不需要物理单位。\n\n你必须从守恒原理和成熟的数值分析理论出发，推导出一个稳定且自洽的数值格式，用于对上述偏微分方程进行空间和时间上的积分。该格式必须在核心区施加对称性，并在边界处施加固定温度：\n- 核心区边界条件（$r=0$ 处）：零梯度（诺伊曼）对称性，即 $\\partial_r T(0,t) = 0$。\n- 边界条件（$r=a$ 处）：固定温度（狄利克雷），即 $T(a,t) = T_{\\text{edge}}$。\n\n有阈值的输运系数由作用在单元交界面处局部温度梯度绝对值上的亥维赛（Heaviside）阶跃函数开关定义：\n$$\n\\chi\\left(T,\\partial_r T\\right) = \\chi_{\\text{low}} + \\left(\\chi_{\\text{high}} - \\chi_{\\text{low}}\\right) H\\!\\left(\\left|\\partial_r T\\right| - g_c\\right),\n$$\n其中 $H(x)$ 是亥维赛阶跃函数，$\\chi_{\\text{low}}$ 是低输运水平，$\\chi_{\\text{high}}$ 是当局部梯度绝对值超过阈值 $g_c$ 时被激活的高输运水平，$g_c$ 是梯度阈值。核心区驱动被设定为一个不依赖于时间的、平滑的局域源：\n$$\nS(r,t) = S_0 \\exp\\!\\left(-\\left(\\frac{r}{r_s}\\right)^2\\right).\n$$\n\n为了展示雪崩状爆发，需要基于全局存储热能的平衡实现一个雪崩探测器。令离散的全局能量为\n$$\nW(t) = \\int_0^a T(r,t)\\,dr,\n$$\n并通过你所选择的空间离散化方法进行自洽的近似。定义瞬时残差\n$$\nR(t) = \\frac{dW}{dt} - \\int_0^a S(r,t)\\,dr,\n$$\n该残差衡量了超出核心区驱动部分的净损失。通过对时间序列应用具有指定窗口大小的中心移动平均来构造一个平滑后的残差 $R_{\\text{sm}}(t)$，并定义一个数据驱动的阈值 $\\theta = k \\,\\sigma_R$，其中 $\\sigma_R$ 是在舍弃初始瞬态过程后，$R(t)$ 在整个模拟过程中的标准差。当 $R_{\\text{sm}}(t)$ 降至 $-\\theta$ 以下，并保持在该值以下直到再次回升到该值以上时，计数一次雪崩状爆发；平滑窗口内的连续穿越必须被视为同一事件的一部分。\n\n你的程序必须：\n- 在 $r$ 方向上使用有限体积法风格的离散化，在 $[0,a]$ 区间上划分 $N$ 个单元的均匀网格，时间步长为 $\\Delta t$，并演化到最终时间 $T_{\\text{end}}$。\n- 使用局部的交界面梯度绝对值，在单元交界面处实现有阈值的 $\\chi$。\n- 施加如上所述的边界条件。\n- 选择一个显式时间步进格式，该格式需满足一个基于 $\\chi$ 最大值和网格间距的稳定性约束，以保持数值稳定性。\n- 在每个时间步计算时间序列 $W(t)$ 和残差 $R(t)$，使用给定的窗口大小构造 $R_{\\text{sm}}(t)$，并使用所述逻辑计数雪崩状爆发。\n\n所有量均为无量纲。初始条件为 $T(r,0)=T_{\\text{edge}}$。\n\n测试套件：\n使用以下四组参数集来测试你的实现。每组参数集指定了 $(N,a,\\Delta t,T_{\\text{end}},\\chi_{\\text{low}},\\chi_{\\text{high}},g_c,S_0,r_s,T_{\\text{edge}},w,k)$，其中 $w$ 是移动平均窗口大小（以时间步为单位），$k$ 是阈值定义 $\\theta = k \\,\\sigma_R$ 中的乘数。\n\n- 案例1（基线慢驱动）：\n  - $N=64$, $a=1$, $\\Delta t=10^{-4}$, $T_{\\text{end}}=6\\times 10^{-1}$,\n  - $\\chi_{\\text{low}}=10^{-2}$, $\\chi_{\\text{high}}=5\\times 10^{-1}$, $g_c=3\\times 10^{-1}$,\n  - $S_0=8\\times 10^{-1}$, $r_s=25\\times 10^{-2}$, $T_{\\text{edge}}=0$,\n  - $w=50$, $k=3$.\n\n- 案例2（更容易的阈值，预期会有更频繁的爆发）：\n  - $N=64$, $a=1$, $\\Delta t=10^{-4}$, $T_{\\text{end}}=6\\times 10^{-1}$,\n  - $\\chi_{\\text{low}}=10^{-2}$, $\\chi_{\\text{high}}=5\\times 10^{-1}$, $g_c=2\\times 10^{-1}$,\n  - $S_0=8\\times 10^{-1}$, $r_s=25\\times 10^{-2}$, $T_{\\text{edge}}=0$,\n  - $w=50$, $k=3$.\n\n- 案例3（无阈值，线性扩散）：\n  - $N=64$, $a=1$, $\\Delta t=10^{-4}$, $T_{\\text{end}}=6\\times 10^{-1}$,\n  - $\\chi_{\\text{low}}=5\\times 10^{-2}$, $\\chi_{\\text{high}}=5\\times 10^{-2}$, $g_c=10^{4}$,\n  - $S_0=8\\times 10^{-1}$, $r_s=25\\times 10^{-2}$, $T_{\\text{edge}}=0$,\n  - $w=50$, $k=3$.\n\n- 案例4（更快的驱动）：\n  - $N=64$, $a=1$, $\\Delta t=10^{-4}$, $T_{\\text{end}}=6\\times 10^{-1}$,\n  - $\\chi_{\\text{low}}=10^{-2}$, $\\chi_{\\text{high}}=5\\times 10^{-1}$, $g_c=3\\times 10^{-1}$,\n  - $S_0=15\\times 10^{-1}$, $r_s=25\\times 10^{-2}$, $T_{\\text{edge}}=0$,\n  - $w=50$, $k=3$.\n\n最终输出规格：\n- 对于每个案例，计算如上定义的探测到的雪崩状爆发的整数数量。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按所列案例的顺序排列，例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$，其中每个 $\\text{result}_i$ 是一个整数。",
            "solution": "用户提供了一个有效的问题陈述。该问题要求开发并实现一种数值格式，用于求解一个一维非线性扩散方程，该方程在简化的聚变等离子体背景下模拟温度输运。目标是计数雪崩状输运事件，这些事件是自组织临界（SOC）的特征。该问题在计算物理学中有科学依据，在数学上是适定的，并为计算唯一解提供了一套完整的参数和定义。\n\n推导和实现将按以下步骤进行：\n1.  使用有限体积法在均匀网格上对控制偏微分方程（PDE）进行离散化。\n2.  实现指定的边界条件：核心区（$r=0$）的零梯度（诺伊曼）条件和边界（$r=a$）的固定温度（狄利克雷）条件。\n3.  采用显式向前欧拉时间步进格式，并确保满足稳定性条件。\n4.  基于边界热通量的时间序列，开发用于探测和计数雪崩的算法。\n\n**1. 有限体积离散化**\n\n控制偏微分方程是一个一维非线性扩散方程：\n$$\n\\partial_t T(r,t) = \\partial_r\\left(\\chi\\left(T,\\partial_r T\\right)\\,\\partial_r T\\right) + S(r,t)\n$$\n该方程是守恒形式 $\\partial_t T = \\partial_r J + S$，其中 $J(r,t) = \\chi \\partial_r T$ 是热通量。这种形式非常适合有限体积离散化，该方法内在地保证了输运物理量（在此情况下为热能密度 $T$）的守恒。\n\n我们定义一个覆盖区域 $r \\in [0, a]$ 的含 $N$ 个单元的均匀网格。每个单元的宽度为 $\\Delta r = a/N$。对于 $i=0, 1, \\dots, N-1$，单元中心位于 $r_i = (i + 1/2)\\Delta r$。对于 $i=-1, 0, \\dots, N-1$，单元边界（或称交界面）位于 $r_{i+1/2} = (i+1)\\Delta r$。物理区域由位于 $r_{-1/2} = 0$ 和 $r_{N-1/2} = a$ 的交界面界定。\n\n我们将偏微分方程在第 $i$ 个单元上（从 $r_{i-1/2}$ 到 $r_{i+1/2}$）进行积分：\n$$\n\\int_{r_{i-1/2}}^{r_{i+1/2}} \\partial_t T \\, dr = \\int_{r_{i-1/2}}^{r_{i+1/2}} \\partial_r J \\, dr + \\int_{r_{i-1/2}}^{r_{i+1/2}} S \\, dr\n$$\n假设 $T_i(t)$ 代表第 $i$ 个单元内的平均温度，则方程左侧变为 $\\Delta r \\frac{d T_i}{dt}$。右侧的通量项使用微积分基本定理计算，源项使用中点法则计算：\n$$\n\\Delta r \\frac{d T_i}{dt} = J(r_{i+1/2}, t) - J(r_{i-1/2}, t) + S(r_i, t) \\Delta r\n$$\n两边同除以 $\\Delta r$，我们得到第 $i$ 个单元内温度演化的半离散方程：\n$$\n\\frac{d T_i}{dt} = \\frac{J_{i+1/2} - J_{i-1/2}}{\\Delta r} + S_i\n$$\n其中 $J_{i+1/2}$ 表示单元 $i$ 和单元 $i+1$ 之间交界面上的通量，$S_i = S(r_i)$。\n\n通量 $J_{i+1/2}$ 使用跨交界面的中心差分来近似梯度进行计算：\n$$\nJ_{i+1/2} = \\chi_{i+1/2} \\left( \\frac{T_{i+1} - T_i}{\\Delta r} \\right)\n$$\n输运系数 $\\chi_{i+1/2}$ 非线性地依赖于该局部梯度的绝对值 $g_{i+1/2} = \\left| \\frac{T_{i+1} - T_i}{\\Delta r} \\right|$：\n$$\n\\chi_{i+1/2} = \\chi_{\\text{low}} + (\\chi_{\\text{high}} - \\chi_{\\text{low}}) H(g_{i+1/2} - g_c)\n$$\n其中 $H$ 是亥维赛阶跃函数。\n\n**2. 边界条件**\n\n-   **核心区边界 ($r=0$)：** 零梯度条件 $\\partial_r T(0,t) = 0$ 意味着核心区的热通量为零。$r=0$ 处的交界面是 $r_{-1/2}$，因此我们设定 $J_{-1/2} = 0$。第一个单元（$i=0$）的方程变为：\n    $$\n    \\frac{d T_0}{dt} = \\frac{J_{1/2}}{\\Delta r} + S_0\n    $$\n\n-   **边界 ($r=a$)：** 固定温度条件为 $T(a,t) = T_{\\text{edge}}$。边界交界面是 $r_{N-1/2} = a$。为了计算进入最后一个物理单元（$i=N-1$）的通量 $J_{N-1/2}$，我们需要该交界面上的梯度。可以通过定义一个“虚”单元值 $T_N$ 来构造一个二阶精度的中心差分，使得 $T_{N-1}$ 和 $T_N$ 的平均值等于所需的边界温度。然而，一种更简单且更常见的有限体积方法是在最后一个单元中心 $r_{N-1} = a - \\Delta r/2$ 和边界 $r=a$ 之间使用单边差分，距离为 $\\Delta r/2$。一种更鲁棒、且能为所有通量保持中心差分结构的方法是，使用已知的边界值 $T_{\\text{edge}}$ 和最后一个单元中心的值 $T_{N-1}$ 来定义边界交界面 $r_{N-1/2}$ 处的梯度。\n    为了保持一致的计算模板，我们可以想象一个虚点 $T_N$，使得线性插值得到边界值，即 $T(a) = (T_{N-1} + T_N)/2 = T_{\\text{edge}}$。这意味着 $T_N = 2T_{\\text{edge}} - T_{N-1}$。那么，交界面 $r_{N-1/2}$ 处的梯度可以自洽地近似为：\n    $$\n    (\\partial_r T)_{N-1/2} \\approx \\frac{T_N - T_{N-1}}{\\Delta r} = \\frac{(2T_{\\text{edge}} - T_{N-1}) - T_{N-1}}{\\Delta r} = \\frac{2(T_{\\text{edge}} - T_{N-1})}{\\Delta r}\n    $$\n    该公式正确地确定了更新单元 $T_{N-1}$ 所需的通量 $J_{N-1/2}$。\n\n**3. 时间积分与稳定性**\n\n我们使用显式向前欧拉格式以步长 $\\Delta t$ 进行时间推进。在时间步 $n$ 处，单元 $i$ 的全离散更新规则为：\n$$\nT_i^{n+1} = T_i^n + \\frac{\\Delta t}{\\Delta r} (J_{i+1/2}^n - J_{i-1/2}^n) + \\Delta t S_i\n$$\n其中所有通量 $J^n$ 都是使用当前时间步的温度 $T^n$ 计算的。显式格式受到稳定性约束的制约。对于扩散方程，这是库朗-弗里德里希斯-列维（CFL）条件，对于我们的非线性问题，该条件为：\n$$\n\\frac{\\chi_{\\max} \\Delta t}{(\\Delta r)^2} \\le \\frac{1}{2}\n$$\n此处 $\\chi_{\\max} = \\chi_{\\text{high}}$。对于所有提供的测试案例，$\\chi_{\\text{high}} = 0.5$（或更小），$\\Delta t = 10^{-4}$，$\\Delta r = 1/64$，得到 $\\frac{0.5 \\cdot 10^{-4}}{(1/64)^2} \\approx 0.2048$，该值小于 $0.5$。因此，所选参数确保了数值稳定性。\n\n**4. 雪崩探测算法**\n\n总热能 $W(t) = \\int_0^a T(r,t) dr$ 被离散化为 $W^n = \\Delta r \\sum_{i=0}^{N-1} T_i^n$。瞬时残差定义为 $R(t) = \\frac{dW}{dt} - \\int_0^a S dr$。根据偏微分方程的守恒形式，我们有 $\\frac{d}{dt}\\int_0^a T dr = J(a,t) - J(0,t) + \\int_0^a S dr$。由于 $J(0,t)=0$，该式简化为 $R(t) = J(a,t)$。在我们的离散系统中，第 $n$ 步的残差就是从边界流出的通量：$R^n = J_{N-1/2}^n$。\n\n探测过程如下：\n1.  运行模拟直到 $T_{\\text{end}}$，在每个时间步将残差 $R^n$ 记录到历史数组 $R_{\\text{hist}}$ 中。\n2.  舍弃初始的瞬态阶段，以专注于统计稳态。我们舍弃模拟数据的前半部分。令 $n_{\\text{steps}} = T_{\\text{end}} / \\Delta t$ 且 $n_{\\text{transient}} = n_{\\text{steps}}/2$。\n3.  对于 $t  t_{\\text{transient}}$，计算残差 $R(t)$ 的标准差 $\\sigma_R$。\n4.  将雪崩阈值定义为 $\\theta = k \\sigma_R$。\n5.  通过对完整的 $R_{\\text{hist}}$ 序列应用窗口大小为 $w$ 的中心移动平均，计算平滑后的残差 $R_{\\text{sm}}(t)$。使用 `mode='nearest'` 的 `scipy.ndimage.uniform_filter1d` 函数适合此目的。\n6.  在后瞬态阶段分析平滑后的残差。当 $R_{\\text{sm}}(t)$ 降至负阈值 $-\\theta$ 以下时，触发一次雪崩。\n7.  为了实现“平滑窗口内的连续穿越必须被视为同一事件的一部分”这一条件，我们首先识别所有 $R_{\\text{sm}}(t)$ 从上方穿越 $-\\theta$ 的时间步（即，$R_{\\text{sm}}(t)  -\\theta$ 且 $R_{\\text{sm}}(t-\\Delta t) \\ge -\\theta$）。将这些时间点视为潜在雪崩的开始时间。\n8.  然后，我们将开始时间间隔小于或等于窗口大小 $w$ 的任意两个潜在雪崩合并。这些合并后事件的总数即为最终结果。\n\n这就完成了数值模型和分析流程的设计。实现将遵循此框架。",
            "answer": "```python\n# 完整的、可运行的 Python 3 代码位于此处。\n# 导入必须遵守指定的执行环境。\nimport numpy as np\nfrom scipy.ndimage import uniform_filter1d\n\ndef solve():\n    \"\"\"\n    主函数，用于为所有测试案例运行模拟并打印结果。\n    \"\"\"\n    test_cases = [\n        # 案例1（基线慢驱动）\n        (64, 1.0, 1e-4, 0.6, 1e-2, 0.5, 0.3, 0.8, 0.25, 0.0, 50, 3.0),\n        # 案例2（更容易的阈值）\n        (64, 1.0, 1e-4, 0.6, 1e-2, 0.5, 0.2, 0.8, 0.25, 0.0, 50, 3.0),\n        # 案例3（无阈值，线性扩散）\n        (64, 1.0, 1e-4, 0.6, 5e-2, 5e-2, 1e4, 0.8, 0.25, 0.0, 50, 3.0),\n        # 案例4（更快的驱动）\n        (64, 1.0, 1e-4, 0.6, 1e-2, 0.5, 0.3, 1.5, 0.25, 0.0, 50, 3.0),\n    ]\n\n    results = []\n    for params in test_cases:\n        count = run_simulation(*params)\n        results.append(count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(N, a, dt, T_end, chi_low, chi_high, g_c, S0, rs, T_edge, w, k):\n    \"\"\"\n    为给定的一组参数执行一次完整的模拟和雪崩分析。\n\n    Args:\n        N (int): 网格单元数。\n        a (float): 区域大小。\n        dt (float): 时间步长。\n        T_end (float): 最终模拟时间。\n        chi_low (float): 低输运系数。\n        chi_high (float): 高输运系数。\n        g_c (float): 用于SOC的梯度阈值。\n        S0 (float): 源振幅。\n        rs (float): 源局域化宽度。\n        T_edge (float): 边界处的固定温度。\n        w (int): 用于雪崩探测的移动平均窗口大小。\n        k (float): 雪崩阈值的乘数。\n\n    Returns:\n        int: 探测到的雪崩状爆发次数。\n    \"\"\"\n    # 1. 初始化\n    dr = a / N\n    r_centers = (np.arange(N) + 0.5) * dr\n\n    T = np.full(N, T_edge)\n    S = S0 * np.exp(-(r_centers / rs)**2)\n\n    n_steps = int(T_end / dt)\n    R_hist = np.zeros(n_steps)\n    \n    # 预计算循环中使用的常量\n    c_chi = chi_high - chi_low\n    dt_dr = dt / dr\n\n    # 2. 时间演化循环\n    for n in range(n_steps):\n        # 用于存储交界面通量的数组，J_faces[i] 对应于交界面 i+1/2 处的通量\n        # J_faces 大小为 N：J_faces[0]...J_faces[N-2] 是内部交界面，J_faces[N-1] 是边界交界面。\n        J_faces = np.zeros(N)\n        \n        # 内部交界面 (i = 0 到 N-2)\n        grad_interior = (T[1:] - T[:-1]) / dr\n        chi_interior = chi_low + c_chi * (np.abs(grad_interior) > g_c)\n        J_faces[:-1] = chi_interior * grad_interior\n\n        # 边界交界面 (i = N-1)\n        grad_edge = 2.0 * (T_edge - T[N-1]) / dr\n        chi_edge = chi_low + c_chi * (np.abs(grad_edge) > g_c)\n        J_faces[-1] = chi_edge * grad_edge\n\n        # 构造大小为 N+1 的完整通量数组 J (J[0] 在 r=0 处, J[N] 在 r=a 处)\n        J = np.zeros(N + 1)\n        J[1:] = J_faces\n        \n        # 更新温度\n        T += dt_dr * (J[1:] - J[:-1]) + dt * S\n        \n        # 存储残差（边界处的通量）\n        R_hist[n] = J[N]\n\n    # 3. 雪崩探测\n    # 舍弃前半部分作为瞬态过程\n    n_transient = n_steps // 2\n    R_analysis = R_hist[n_transient:]\n\n    if len(R_analysis) == 0:\n        return 0\n\n    # 根据未经平滑的后瞬态数据的标准差计算阈值\n    sigma_R = np.std(R_analysis)\n    if sigma_R == 0: # 没有波动，就没有雪崩\n        return 0\n    theta = k * sigma_R\n\n    # 平滑整个残差序列，以避免在瞬态边界处产生边缘效应\n    # 然后分析后瞬态部分。\n    R_sm = uniform_filter1d(R_hist, size=w, mode='nearest')\n    R_sm_analysis = R_sm[n_transient:]\n\n    # 找到向下跌破阈值 -theta 的点\n    is_below = R_sm_analysis  -theta\n    # 在开头添加一个 False 以捕捉在第一步就发生的穿越\n    is_below_padded = np.insert(is_below, 0, False)\n    # 当状态从 False 变为 True 时，发生一次穿越\n    crossings = np.where(np.diff(is_below_padded.astype(int)) == 1)[0]\n\n    if len(crossings) == 0:\n        return 0\n\n    # 合并间距小于平滑窗口 'w' 的事件\n    avalanche_count = 1\n    for i in range(1, len(crossings)):\n        if crossings[i] - crossings[i-1] > w:\n            avalanche_count += 1\n            \n    return avalanche_count\n\nsolve()\n```"
        },
        {
            "introduction": "当模拟产生出类似雪崩的爆发事件后，关键的科学步骤是量化其统计特性，以验证理论模型。本实践将介绍一种严谨的统计方法——Vuong检验，用于比较不同统计模型（如幂律分布与对数正态分布）对雪崩数据的拟合优度 。掌握这种假设检验方法，对于从实验或模拟数据中辨别SOC特征至关重要。",
            "id": "4044372",
            "problem": "你的任务是设计、推导和实现一个似然比假设检验，用以判断在自组织临界性（SOC）输运中观测到的雪崩爆发幅度是由幂律尾描述更好，还是由对数正态或指数替代模型描述更好。其背景是计算聚变科学与工程，在该领域中，与磁约束等离子体中的雪崩相关的爆发事件通常被认为遵循重尾统计。你的解决方案必须从基本定义出发，以证明该检验的合理性，并生成一个能够评估指定合成数据集测试套件的可运行程序。\n\n从以下具有科学依据的基础开始：\n\n- 概率密度函数（PDF）的定义以及独立同分布样本对应的似然。\n- 最大似然估计（MLE）的原理。\n- 通过逐样本对数似然差来比较模型的概念。\n- 在模型误设下，平均对数似然差的渐近正态性，这导出了一个标准化的检验统计量（用于非嵌套模型的 Vuong 检验）。\n\n将爆发幅度变量 $x$ 建模为连续的，且有一个正的尺度下界 $x_{\\min}$。考虑在 $x \\ge x_{\\min}$ 上的三个候选尾部模型：\n\n1. 具有形状参数 $\\alpha  1$ 和下界 $x_{\\min}$ 的连续幂律尾。\n2. 具有速率 $\\lambda  0$ 和下界 $x_{\\min}$ 的移位指数尾。\n3. 在 $x_{\\min}$ 处截断的对数正态分布（参数为 $\\mu \\in \\mathbb{R}$ 和 $\\sigma  0$）。\n\n你的任务是：\n\n- 从第一性原理出发，为每个模型推导在 $x \\ge x_{\\min}$ 上的正确归一化 PDF。\n- 仅使用所提供的基本原理，推导幂律形状参数和指数速率参数的最大似然估计。对于截断对数正态分布的参数，推导对数似然的形式，并解释为何通常不存在闭式解，从而说明数值优化的必要性。\n- 定义逐样本对数似然差 $d_i = \\ln p_{\\mathrm{PL}}(x_i \\mid \\hat{\\theta}_{\\mathrm{PL}}) - \\ln p_{\\mathrm{ALT}}(x_i \\mid \\hat{\\theta}_{\\mathrm{ALT}})$，其中 $p_{\\mathrm{PL}}$ 是带有其 MLE 参数的幂律 PDF，而 $p_{\\mathrm{ALT}}$ 是带有其 MLE 参数的替代 PDF（对数正态或指数）。使用独立同分布变量的中心极限定理和在模型误设下的 MLE 性质，推导标准化统计量\n$$\nV = \\frac{\\sqrt{n} \\,\\bar{d}}{s},\n$$\n其中 $n$ 是样本大小，$\\bar{d} = \\frac{1}{n}\\sum_{i=1}^{n} d_i$，$s$ 是 $\\{d_i\\}_{i=1}^n$ 的样本标准差，并通过标准正态累积分布函数定义一个双边 $p$ 值。\n- 在显著性水平 $\\alpha_{\\mathrm{test}} = 0.05$ 下陈述决策规则：如果双边 p 值小于 0.05 且总对数似然比 $\\sum_{i=1}^{n} d_i$ 为正，则倾向于选择幂律模型；否则，不声称有偏好。\n\n实现一个完整、可运行的程序，该程序：\n\n- 根据指定的模型和参数生成合成数据集。\n- 在每个数据集上为每个模型估计参数。\n- 计算 Vuong 检验统计量和 p 值，以比较幂律模型与对数正态和指数替代模型。\n- 应用决策规则并输出所有测试用例的最终决策。\n\n单位：爆发幅度 $x$ 是无量纲正标量。所有输入和输出均无单位。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n测试套件：\n使用以下四个测试用例，并使用固定的随机种子 $s = 12345$ 以保证可复现性。在每个案例中，从指定的生成分布中抽取 $n$ 个大于 $x_{\\min}$ 的样本。\n\n- 案例 1（幂律主导的雪崩）：$n = 1000$，$x_{\\min} = 1.0$，生成分布为形状参数 $\\alpha = 2.3$ 的幂律分布。\n- 案例 2（对数正态主导的爆发）：$n = 1000$，$x_{\\min} = 1.0$，生成分布为在 $x_{\\min}$ 处截断的对数正态分布，参数为 $\\mu = 0.0, \\sigma = 0.9$。\n- 案例 3（指数限制的输运）：$n = 1000$，$x_{\\min} = 1.0$，生成分布为速率 $\\lambda = 1.2$ 的移位指数分布。\n- 案例 4（稀疏样本，重尾边缘案例）：$n = 30$，$x_{\\min} = 1.0$，生成分布为形状参数 $\\alpha = 1.8$ 的幂律分布。\n\n答案格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个元素对应一个测试用例，并且本身是一个包含两个布尔值的列表，顺序为 $[\\text{倾向于幂律 vs 对数正态}, \\text{倾向于幂律 vs 指数}]$。例如，输出格式必须类似于\n$$\n[[\\mathrm{True},\\mathrm{False}],[\\mathrm{False},\\mathrm{False}],[\\mathrm{True},\\mathrm{True}],[\\mathrm{False},\\mathrm{False}]].\n$$",
            "solution": "经评估，所提供的问题是有效的。它在科学上植根于统计力学和推断，定义和约束完整且一致，问题陈述良好，表述客观。该问题要求对一个与指定科学领域相关的标准（尽管不简单）统计程序进行严谨的推导和实现。我们着手解决。\n\n解决方案分为四个部分：推导三个候选模型的概率密度函数（PDF），推导它们对应的最大似然估计（MLE），构建用于模型比较的 Vuong 检验统计量，以及定义决策规则。\n\n**1. 概率密度函数**\n\n所有模型都描述了在域 $[x_{\\min}, \\infty)$ 上的连续随机变量 $x$，其中 $x_{\\min}  0$。任何模型的 PDF $p(x)$ 都必须归一化，使得 $\\int_{x_{\\min}}^{\\infty} p(x) dx = 1$。\n\n*   **幂律分布**：函数形式为 $p(x) \\propto x^{-\\alpha}$，适用于 $x \\ge x_{\\min}$，形状参数 $\\alpha  1$。归一化常数 $C$ 通过条件 $C \\int_{x_{\\min}}^{\\infty} x^{-\\alpha} dx = 1$ 求得。积分计算如下：\n    $$\n    \\int_{x_{\\min}}^{\\infty} x^{-\\alpha} dx = \\left[ \\frac{x^{-\\alpha+1}}{1-\\alpha} \\right]_{x_{\\min}}^{\\infty} = 0 - \\frac{x_{\\min}^{1-\\alpha}}{1-\\alpha} = \\frac{x_{\\min}^{1-\\alpha}}{\\alpha-1}\n    $$\n    收敛要求指数 $1-\\alpha$ 为负，因此 $\\alpha  1$。归一化常数为 $C = (\\alpha-1)x_{\\min}^{\\alpha-1}$。正确归一化的 PDF 为：\n    $$\n    p_{\\mathrm{PL}}(x | \\alpha, x_{\\min}) = (\\alpha-1)x_{\\min}^{\\alpha-1} x^{-\\alpha}\n    $$\n\n*   **移位指数分布**：函数形式为 $p(x) \\propto e^{-\\lambda(x-x_{\\min})}$，适用于 $x \\ge x_{\\min}$，速率参数 $\\lambda  0$。归一化常数 $C$ 通过 $C \\int_{x_{\\min}}^{\\infty} e^{-\\lambda(x-x_{\\min})} dx = 1$ 求得。令 $y = x-x_{\\min}$，则 $dy = dx$。积分变为 $C \\int_{0}^{\\infty} e^{-\\lambda y} dy = 1$。\n    $$\n    \\int_{0}^{\\infty} e^{-\\lambda y} dy = \\left[ -\\frac{1}{\\lambda}e^{-\\lambda y} \\right]_0^\\infty = 0 - (-\\frac{1}{\\lambda}) = \\frac{1}{\\lambda}\n    $$\n    这要求 $\\lambda  0$。归一化常数为 $C = \\lambda$。归一化的 PDF 为：\n    $$\n    p_{\\mathrm{EXP}}(x | \\lambda, x_{\\min}) = \\lambda e^{-\\lambda(x-x_{\\min})}\n    $$\n\n*   **截断对数正态分布**：该模型是一个标准的对数正态分布（参数为 $\\mu$ 和 $\\sigma$），以 $x \\ge x_{\\min}$ 为条件。标准对数正态变量 $Z$ 的 PDF 为 $p_{LN}(z|\\mu, \\sigma) = \\frac{1}{z \\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln z - \\mu)^2}{2\\sigma^2}\\right)$。截断 PDF 由 $p_{\\mathrm{LNT}}(x) = \\frac{p_{LN}(x)}{\\mathbb{P}(Z \\ge x_{\\min})}$ 给出。分母是生存函数 $S \\equiv \\mathbb{P}(Z \\ge x_{\\min})$，作为归一化因子。\n    $$\n    S = \\int_{x_{\\min}}^{\\infty} p_{LN}(z|\\mu, \\sigma) dz\n    $$\n    令 $u = (\\ln z - \\mu) / \\sigma$。这将积分转换为对标准正态 PDF $\\phi(u) = (1/\\sqrt{2\\pi})e^{-u^2/2}$ 的积分：\n    $$\n    S = \\int_{(\\ln x_{\\min} - \\mu)/\\sigma}^{\\infty} \\phi(u) du = 1 - \\Phi\\left(\\frac{\\ln x_{\\min} - \\mu}{\\sigma}\\right)\n    $$\n    其中 $\\Phi$ 是标准正态累积分布函数（CDF）。使用误差函数， $S = \\frac{1}{2}\\mathrm{erfc}\\left(\\frac{\\ln x_{\\min} - \\mu}{\\sigma\\sqrt{2}}\\right)$。归一化的 PDF 为：\n    $$\n    p_{\\mathrm{LNT}}(x | \\mu, \\sigma, x_{\\min}) = \\frac{1}{S \\cdot x \\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}\\right)\n    $$\n\n**2. 最大似然估计（MLE）**\n\n对于一组 $n$ 个独立同分布的样本 $\\{x_i\\}_{i=1}^n$，对数似然函数为 $\\mathcal{L}(\\theta) = \\sum_{i=1}^n \\ln p(x_i | \\theta)$。MLE $\\hat{\\theta}$ 是使 $\\mathcal{L}(\\theta)$ 最大化的参数矢量 $\\theta$ 的值。\n\n*   **幂律参数 $\\alpha$**：对数似然为：\n    $$\n    \\mathcal{L}(\\alpha) = \\sum_{i=1}^n \\left[ \\ln(\\alpha-1) + (\\alpha-1)\\ln x_{\\min} - \\alpha \\ln x_i \\right] = n\\ln(\\alpha-1) + n(\\alpha-1)\\ln x_{\\min} - \\alpha \\sum_{i=1}^n \\ln x_i\n    $$\n    将关于 $\\alpha$ 的导数设为零，得到 MLE $\\hat{\\alpha}$：\n    $$\n    \\frac{\\partial\\mathcal{L}}{\\partial\\alpha} = \\frac{n}{\\alpha-1} + n\\ln x_{\\min} - \\sum_{i=1}^n \\ln x_i = 0 \\quad \\implies \\quad \\hat{\\alpha}_{\\mathrm{MLE}} = 1 + n \\left( \\sum_{i=1}^n \\ln\\frac{x_i}{x_{\\min}} \\right)^{-1}\n    $$\n*   **指数参数 $\\lambda$**：对数似然为：\n    $$\n    \\mathcal{L}(\\lambda) = \\sum_{i=1}^n \\left[ \\ln\\lambda - \\lambda(x_i - x_{\\min}) \\right] = n\\ln\\lambda - \\lambda \\sum_{i=1}^n (x_i - x_{\\min})\n    $$\n    将关于 $\\lambda$ 的导数设为零，得到 MLE $\\hat{\\lambda}$：\n    $$\n    \\frac{\\partial\\mathcal{L}}{\\partial\\lambda} = \\frac{n}{\\lambda} - \\sum_{i=1}^n (x_i - x_{\\min}) = 0 \\quad \\implies \\quad \\hat{\\lambda}_{\\mathrm{MLE}} = \\frac{n}{\\sum_{i=1}^n (x_i - x_{\\min})} = \\frac{1}{\\bar{x} - x_{\\min}}\n    $$\n*   **截断对数正态参数 $(\\mu, \\sigma)$**：对数似然为：\n    $$\n    \\mathcal{L}(\\mu, \\sigma) = \\sum_{i=1}^n \\ln p_{\\mathrm{LNT}}(x_i) = -n\\ln S(\\mu, \\sigma) - n\\ln\\sigma - \\frac{n}{2}\\ln(2\\pi) - \\sum_{i=1}^n \\ln x_i - \\frac{1}{2\\sigma^2}\\sum_{i=1}^n (\\ln x_i - \\mu)^2\n    $$\n    当将偏导数 $\\partial\\mathcal{L}/\\partial\\mu$ 和 $\\partial\\mathcal{L}/\\partial\\sigma$ 设为零时，归一化因子 $S$ 对 $\\mu$ 和 $\\sigma$ 的依赖性导致了一个耦合的非线性方程组。$\\hat{\\mu}$ 和 $\\hat{\\sigma}$ 没有闭式解。因此，这些参数必须通过数值方法最大化对数似然函数来找到。\n\n**3. 用于非嵌套模型的 Vuong 检验**\n\nVuong 检验为两个非嵌套模型（如幂律分布和对数正态分布）提供了正式的统计比较。设两个竞争模型为 $p_1(x|\\theta_1)$（幂律）和 $p_2(x|\\theta_2)$（替代模型）。该检验基于在各自 MLE 处评估的逐样本对数似然差：\n$$\nd_i = \\ln p_{1}(x_i | \\hat{\\theta}_{1}) - \\ln p_{2}(x_i | \\hat{\\theta}_{2})\n$$\n零假设 $H_0$ 是两个模型与真实数据生成分布的接近程度（在 Kullback-Leibler 意义上）相同，这意味着 $\\mathbb{E}[d_i]=0$。在 $H_0$ 下，中心极限定理指出样本均值 $\\bar{d} = \\frac{1}{n}\\sum_{i=1}^n d_i$ 渐近服从均值为 $0$ 的正态分布。标准化的检验统计量为：\n$$\nV = \\frac{\\sqrt{n} \\, \\bar{d}}{s}\n$$\n其中 $s$ 是差值 $\\{d_i\\}_{i=1}^n$ 的样本标准差，定义为 $s = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^n (d_i - \\bar{d})^2}$。在 $H_0$ 下，统计量 $V$ 在分布上收敛于标准正态变量，即 $V \\sim \\mathcal{N}(0,1)$。双边 $p$ 值计算为 $p = \\mathbb{P}(|Z| \\ge |V_{\\text{obs}}|) = 2(1-\\Phi(|V_{\\text{obs}}|))$，其中 $Z \\sim \\mathcal{N}(0,1)$。\n\n**4. 决策规则**\n\n在选定的显著性水平 $\\alpha_{\\mathrm{test}} = 0.05$ 下，我们可以决定一个模型是否显著优于另一个。倾向于选择幂律模型（$p_1$）而非替代模型（$p_2$）的决策规则基于两个条件：\n1.  检验必须显示模型之间存在统计学上的显著差异，即 $p$ 值必须小于 $\\alpha_{\\mathrm{test}}$。\n2.  差异的方向必须有利于幂律模型。这由总对数似然比 $LR = \\sum_{i=1}^n d_i = n\\bar{d}$ 的符号决定。正的 $LR$ 表明数据在幂律模型下更有可能出现。\n\n因此，我们当且仅当 $p  0.05$ 且 $LR > 0$ 时，倾向于选择幂律模型。否则，我们不能声称偏好幂律模型。这包括模型在统计上无法区分（$p \\ge 0.05$）或替代模型显著更优（$p  0.05$ 且 $LR  0$）的情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats, optimize, special\n\ndef solve():\n    \"\"\"\n    Main function to run the hypothesis tests on the specified test suite.\n    \"\"\"\n    SEED = 12345\n    ALPHA_TEST = 0.05\n    X_MIN = 1.0\n    rng = np.random.default_rng(SEED)\n\n    # --- Data Generation Functions ---\n    def generate_power_law(n, alpha, x_min, rng_instance):\n        u = rng_instance.uniform(low=0.0, high=1.0, size=n)\n        return x_min * (1.0 - u)**(-1.0 / (alpha - 1.0))\n\n    def generate_exponential(n, lam, x_min, rng_instance):\n        u = rng_instance.uniform(low=0.0, high=1.0, size=n)\n        return x_min - (1.0 / lam) * np.log(u)\n\n    def generate_truncated_lognormal(n, mu, sigma, x_min, rng_instance):\n        u = rng_instance.uniform(low=0.0, high=1.0, size=n)\n        # Inverse transform sampling for truncated distribution\n        p_min = stats.norm.cdf((np.log(x_min) - mu) / sigma)\n        v = p_min + u * (1.0 - p_min)\n        return np.exp(mu + sigma * stats.norm.ppf(v))\n\n    # --- Log-PDF Functions (for computing log-likelihoods) ---\n    def logpdf_power_law(x, alpha, x_min):\n        if alpha = 1.0: return -np.inf\n        return np.log(alpha - 1.0) + (alpha - 1.0) * np.log(x_min) - alpha * np.log(x)\n\n    def logpdf_exponential(x, lam, x_min):\n        if lam = 0.0: return -np.inf\n        return np.log(lam) - lam * (x - x_min)\n\n    def logpdf_truncated_lognormal(x, mu, sigma, x_min):\n        if sigma = 0.0: return -np.inf\n        # Use a stable log-sum-exp trick for the normalization term log(S) if needed,\n        # but erfc is generally stable.\n        u_min = (np.log(x_min) - mu) / (sigma * np.sqrt(2.0))\n        # log(S) = log(0.5 * erfc(u_min))\n        log_s = np.log(0.5) + np.log(special.erfc(u_min))\n        if np.isinf(log_s): return -np.inf\n        \n        log_x = np.log(x)\n        log_p_unnormalized = -log_x - np.log(sigma) - 0.5 * np.log(2.0 * np.pi) - (log_x - mu)**2 / (2.0 * sigma**2)\n        return log_p_unnormalized - log_s\n\n    # --- Parameter Estimation Functions ---\n    def fit_power_law(x, x_min):\n        n = len(x)\n        # Clauset-Shalizi-Newman MLE\n        alpha = 1.0 + n / np.sum(np.log(x / x_min))\n        return alpha\n\n    def fit_exponential(x, x_min):\n        lam = 1.0 / (np.mean(x) - x_min)\n        return lam\n\n    def fit_truncated_lognormal(x, x_min):\n        def neg_loglik(params, data, x_min_val):\n            mu, sigma = params\n            log_liks = logpdf_truncated_lognormal(data, mu, sigma, x_min_val)\n            # Penalize invalid parameter ranges\n            if np.any(np.isinf(log_liks)):\n                return np.inf\n            return -np.sum(log_liks)\n\n        # Initial guess from non-truncated log-normal fit\n        log_x = np.log(x)\n        init_mu = np.mean(log_x)\n        init_sigma = np.std(log_x, ddof=1)\n        if init_sigma  1e-6: init_sigma = 1e-6\n\n        result = optimize.minimize(\n            neg_loglik,\n            [init_mu, init_sigma],\n            args=(x, x_min),\n            method='L-BFGS-B',\n            bounds=[(None, None), (1e-9, None)]\n        )\n        return result.x\n\n    # --- Test Suite Definition ---\n    test_cases = [\n        {'name': 'Case 1: PL-Generated', 'n': 1000, 'x_min': 1.0, 'gen': 'pl', 'params': {'alpha': 2.3}},\n        {'name': 'Case 2: LNT-Generated', 'n': 1000, 'x_min': 1.0, 'gen': 'lnt', 'params': {'mu': 0.0, 'sigma': 0.9}},\n        {'name': 'Case 3: Exp-Generated', 'n': 1000, 'x_min': 1.0, 'gen': 'exp', 'params': {'lam': 1.2}},\n        {'name': 'Case 4: Sparse PL', 'n': 30, 'x_min': 1.0, 'gen': 'pl', 'params': {'alpha': 1.8}},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        n, x_min = case['n'], case['x_min']\n        \n        # 1. Generate data\n        if case['gen'] == 'pl':\n            data = generate_power_law(n, case['params']['alpha'], x_min, rng)\n        elif case['gen'] == 'lnt':\n            data = generate_truncated_lognormal(n, case['params']['mu'], case['params']['sigma'], x_min, rng)\n        else: # exp\n            data = generate_exponential(n, case['params']['lam'], x_min, rng)\n        \n        # 2. Fit all models\n        alpha_hat = fit_power_law(data, x_min)\n        lam_hat = fit_exponential(data, x_min)\n        mu_hat, sigma_hat = fit_truncated_lognormal(data, x_min)\n\n        # 3. Compute per-sample log-likelihoods for each fitted model\n        ll_pl = logpdf_power_law(data, alpha_hat, x_min)\n        ll_lnt = logpdf_truncated_lognormal(data, mu_hat, sigma_hat, x_min)\n        ll_exp = logpdf_exponential(data, lam_hat, x_min)\n\n        case_results = []\n        \n        # 4. Vuong Test: Power-Law vs. Log-Normal\n        d_vs_lnt = ll_pl - ll_lnt\n        d_bar_lnt = np.mean(d_vs_lnt)\n        s_lnt = np.std(d_vs_lnt, ddof=1)\n        V_lnt = (np.sqrt(n) * d_bar_lnt / s_lnt) if s_lnt > 1e-10 else 0.0\n        p_val_lnt = 2.0 * stats.norm.sf(np.abs(V_lnt))\n        lr_lnt = np.sum(d_vs_lnt)\n        \n        prefer_pl_vs_lnt = (p_val_lnt  ALPHA_TEST) and (lr_lnt > 0)\n        case_results.append(prefer_pl_vs_lnt)\n\n        # 5. Vuong Test: Power-Law vs. Exponential\n        d_vs_exp = ll_pl - ll_exp\n        d_bar_exp = np.mean(d_vs_exp)\n        s_exp = np.std(d_vs_exp, ddof=1)\n        V_exp = (np.sqrt(n) * d_bar_exp / s_exp) if s_exp > 1e-10 else 0.0\n        p_val_exp = 2.0 * stats.norm.sf(np.abs(V_exp))\n        lr_exp = np.sum(d_vs_exp)\n        \n        prefer_pl_vs_exp = (p_val_exp  ALPHA_TEST) and (lr_exp > 0)\n        case_results.append(prefer_pl_vs_exp)\n        \n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}