{
    "hands_on_practices": [
        {
            "introduction": "自组织临界（SOC）理论的核心思想是，当局部驱动（如温度梯度）超过临界阈值时，会触发输运雪崩。这个练习将这一抽象概念具体化。通过一个简化的抛物线形温度分布，您将通过解析计算，确定等离子体中梯度变得“超临界”的空间区域，从而从第一性原理上理解雪崩可能在何处被触发。",
            "id": "4044333",
            "problem": "考虑一个磁约束聚变等离子体，其小半径坐标为 $r \\in [0,a]$，平衡电子温度分布为 $T(r)=T_{0}\\left(1-\\left(\\frac{r}{a}\\right)^{2}\\right)$，其中 $T_{0}>0$ 和 $a>0$ 是常数。在自组织临界 (SOC) 输运模型中，当局部驱动的绝对值（通常取为径向温度梯度的模）超过一个临界阈值时，会触发局域雪崩事件。假设临界阈值由一个参考临界温度分布 $T_{c}(r)$ 来描述，其径向导数在空间上是恒定的，即 $\\partial_{r}T_{c}(r)=-\\frac{T_{c}}{a}$，其中 $T_{c}>0$ 是一个给定的常数，而 $a$ 等于等离子体的小半径。\n\n从径向梯度的定义和被解释为局部梯度比较的 SOC 触发条件出发，确定满足 $\\partial_{r}T(r)>\\partial_{r}T_{c}(r)$ 的空间区域 $r$，并找出系统首次达到此条件的临界半径。基于梯度驱动的雪崩唯象学，仅使用给定的信息和梯度驱动输运的第一性原理，说明雪崩预期在相对于该临界半径的何处引发。\n\n以 $T_{0}$、$T_{c}$ 和 $a$ 的单个封闭形式表达式报告临界半径 $r_{c}$。以米为单位表示 $r_{c}$。不需要进行数值取整。",
            "solution": "在尝试求解之前，将首先验证问题以确保其科学上合理、内容完备且提法恰当。\n\n### 步骤 1：提取已知条件\n- 等离子体小半径坐标：$r \\in [0,a]$。\n- 平衡电子温度分布：$T(r)=T_{0}\\left(1-\\left(\\frac{r}{a}\\right)^{2}\\right)$。\n- 常数：$T_{0}>0$ 和 $a>0$。$a$ 是等离子体小半径。\n- 自组织临界 (SOC) 触发条件是当局部驱动的绝对值（径向温度梯度的模）超过一个临界阈值时。\n- 临界阈值由参考临界温度分布 $T_{c}(r)$ 描述。\n- 临界温度分布的径向导数是一个常数：$\\partial_{r}T_{c}(r)=-\\frac{T_{c}}{a}$。\n- 常数：$T_{c}>0$。\n- 任务 1：确定满足 $\\partial_{r}T(r)>\\partial_{r}T_{c}(r)$ 的空间区域 $r$。\n- 任务 2：确定首次满足此条件的临界半径 $r_{c}$（即在该区域的边界处）。\n- 任务 3：说明相对于 $r_c$，雪崩预计在何处引发。\n- 最终答案：以 $T_{0}$、$T_{c}$ 和 $a$ 的封闭形式表达式表示 $r_c$，单位为米。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题描述了一个聚变等离子体中的简化输运模型，这是理论和计算等离子体物理学中的一种常用方法。温度分布是标准的抛物线形式。用于触发输运事件（雪崩）的临界温度梯度概念是现代输运理论的核心原则，尤其是在离子温度梯度 (ITG) 和电子温度梯度 (ETG) 湍流的背景下。对于一个解析模型，假设临界梯度在空间上是恒定的，这是一个有效的简化。\n\n问题陈述中存在一个潜在的歧义。它首先将雪崩的物理触发描述为温度梯度的大小 $|\\partial_r T|$ 超过临界阈值 $|\\partial_r T_c|$ 的点。由于对于中心峰化的温度分布，两个梯度都预期为负，因此这个物理条件是 $- \\partial_r T(r) > - \\partial_r T_c(r)$，简化为 $\\partial_r T(r)  \\partial_r T_c(r)$。然而，问题接着明确要求确定相反不等式成立的区域：$\\partial_{r}T(r)  \\partial_{r}T_{c}(r)$。这不是一个矛盾，而是一个结构化的问题。它要求解出稳定区域（亚临界梯度），然后确定其边界，即临界半径 $r_c$。后续关于雪崩在何处引发的问题正确地回归到梯度驱动输运的物理原理。\n\n因此，该问题在一个简化的模型框架内具有科学依据，数学上是适定的、客观的且内部一致的。所有必要的信息都已提供，以找到 $r_c$ 的唯一解。\n\n### 步骤 3：结论与行动\n问题被认定为有效。将推导解答。\n\n### 解答推导\n电子温度分布由下式给出：\n$$T(r) = T_{0}\\left(1 - \\left(\\frac{r}{a}\\right)^{2}\\right)$$\n此温度分布的径向梯度 $\\partial_{r}T(r)$ 通过对小半径坐标 $r$ 求导得到：\n$$\\partial_{r}T(r) = \\frac{d}{dr}\\left[T_{0}\\left(1 - \\frac{r^{2}}{a^{2}}\\right)\\right] = T_{0} \\left(0 - \\frac{2r}{a^{2}}\\right)$$\n$$\\partial_{r}T(r) = -\\frac{2T_{0}r}{a^{2}}$$\n对于 $r0$，该梯度为负，正确地表示了热量从热芯向冷边流动的过程。\n\n临界温度梯度被给定为一个常数：\n$$\\partial_{r}T_{c}(r) = -\\frac{T_{c}}{a}$$\n\n问题的第一部分要求找出 $\\partial_{r}T(r)  \\partial_{r}T_{c}(r)$ 的空间区域。我们将梯度的表达式代入此不等式：\n$$-\\frac{2T_{0}r}{a^{2}}  -\\frac{T_{c}}{a}$$\n为了解出 $r$，我们将两边同乘以 $-1$，这会反转不等号：\n$$\\frac{2T_{0}r}{a^{2}}  \\frac{T_{c}}{a}$$\n由于 $a  0$，我们可以将两边同乘以 $a^{2}$ 而不改变不等式：\n$$2T_{0}r  T_{c}a$$\n鉴于 $T_{0}  0$，我们可以除以 $2T_{0}$：\n$$r  \\frac{T_{c}a}{2T_{0}}$$\n这个不等式定义了温度梯度为亚临界（即陡峭程度小于临界阈值）的区域。考虑到物理区域 $r \\in [0,a]$，完整区域为 $0 \\le r  \\frac{T_{c}a}{2T_{0}}$。\n\n临界半径 $r_c$ 是系统恰好处于临界阈值的位置。这发生在上述区域的边界处，此时不等式变为等式：\n$$\\partial_{r}T(r_{c}) = \\partial_{r}T_{c}(r_{c})$$\n代入表达式：\n$$-\\frac{2T_{0}r_{c}}{a^{2}} = -\\frac{T_{c}}{a}$$\n求解 $r_c$：\n$$r_{c} = \\left(\\frac{T_{c}}{a}\\right) \\left(\\frac{a^{2}}{2T_{0}}\\right)$$\n$$r_{c} = \\frac{T_{c}a}{2T_{0}}$$\n这就是临界半径的封闭形式表达式。$a$ 的单位是米，$T_0$ 和 $T_c$ 的单位相互抵消，因此 $r_c$ 的单位是米，符合要求。\n\n最后，我们被要求根据梯度驱动唯象学说明雪崩预期在何处引发。当系统不稳定时会触发雪崩，这发生在驱动梯度的大小超过临界阈值时。驱动梯度的大小为 $|\\partial_{r}T(r)| = \\frac{2T_{0}r}{a^{2}}$，临界阈值的大小为 $|\\partial_{r}T_{c}(r)| = \\frac{T_{c}}{a}$。因此，雪崩条件是：\n$$|\\partial_{r}T(r)|  |\\partial_{r}T_{c}(r)|$$\n$$\\frac{2T_{0}r}{a^{2}}  \\frac{T_{c}}{a}$$\n求解 $r$ 得出：\n$$r  \\frac{T_{c}a}{2T_{0}}$$\n将此与临界半径的表达式进行比较，雪崩引发的条件是 $r  r_{c}$。因此，雪崩预期在临界半径 $r_{c}$ 径向向外的等离子体区域中引发，在该区域温度梯度变得超临界。临界半径 $r_{c}$ 标志着内部稳定区域（$r  r_c$）与外部不稳定或“刚性”区域（$r  r_c$）之间的边界。",
            "answer": "$$\\boxed{\\frac{T_{c}a}{2T_{0}}}$$"
        },
        {
            "introduction": "在确定了触发雪崩的静态条件之后，下一步是理解这些局部的、离散的触发事件如何演变成全局性的、间歇性的输运现象。这个动手实践要求您构建一个包含阈值非线性的输运方程的数值模拟。通过实现这个简化但物理上合理的模型，您将能直接观察到简单的局部规则如何导致复杂的、类似雪崩的输运爆发的涌现。",
            "id": "4044295",
            "problem": "考虑一个一维径向对称输运模型，用于描述在区间 $r \\in [0,a]$ 上、时间 $t \\ge 0$ 的归一化温度 $T(r,t)$。该模型的提出动机源于磁约束聚变等离子体中的自组织临界（SOC）和雪崩状事件。温度的演化由以下非线性扩散方程控制：\n$$\n\\partial_t T(r,t) = \\partial_r\\left(\\chi\\left(T,\\partial_r T\\right)\\,\\partial_r T\\right) + S(r,t),\n$$\n其中 $\\chi$ 是一个阈值输运系数，$S$ 是一个缓慢变化的芯部驱动。全文使用无量纲归一化单位；无需物理单位。\n\n您必须从守恒原理和经过充分检验的数值分析方法出发，推导出一个稳定且自洽的数值格式，用于在空间和时间上对上述偏微分方程进行积分。该格式必须在芯部强制执行对称性，并在边缘强制执行固定温度：\n- $r=0$ 处的芯部边界条件：零梯度（Neumann）对称性，即 $\\partial_r T(0,t) = 0$。\n- $r=a$ 处的边缘边界条件：固定温度（Dirichlet），即 $T(a,t) = T_{\\text{edge}}$。\n\n阈值输运系数通过对元胞界面处局部温度梯度大小的 Heaviside 阶跃函数来定义：\n$$\n\\chi\\left(T,\\partial_r T\\right) = \\chi_{\\text{low}} + \\left(\\chi_{\\text{high}} - \\chi_{\\text{low}}\\right) H\\!\\left(\\left|\\partial_r T\\right| - g_c\\right),\n$$\n其中 $H(x)$ 是 Heaviside 阶跃函数，$\\chi_{\\text{low}}$ 是低输运水平，$\\chi_{\\text{high}}$ 是当局部梯度大小超过阈值 $g_c$ 时激活的高输运水平，$g_c$ 是梯度阈值。芯部驱动被规定为一个不随时间变化、平滑局域化的源：\n$$\nS(r,t) = S_0 \\exp\\!\\left(-\\left(\\frac{r}{r_s}\\right)^2\\right).\n$$\n\n为展示雪崩状爆发，请基于全局存储热能的平衡实现一个雪崩探测器。设离散全局能量为\n$$\nW(t) = \\int_0^a T(r,t)\\,dr,\n$$\n该能量通过您选择的空间离散化方法进行一致地近似。定义瞬时残差\n$$\nR(t) = \\frac{dW}{dt} - \\int_0^a S(r,t)\\,dr,\n$$\n它衡量了超出芯部驱动的净损失。通过对时间应用具有指定窗口大小的中心移动平均来构造一个平滑残差 $R_{\\text{sm}}(t)$，并定义一个数据驱动的阈值 $\\theta = k \\,\\sigma_R$，其中 $\\sigma_R$ 是在丢弃初始瞬态后，$R(t)$ 在整个模拟过程中的标准差。每当 $R_{\\text{sm}}(t)$ 下降到 $-\\theta$ 以下，并保持在该值以下直到再次回升时，计数一次雪崩状爆发；平滑窗口内的连续穿越必须被视为同一事件的一部分。\n\n您的程序必须：\n- 在 $r$ 方向上使用有限体积法风格的离散化，在 $[0,a]$ 上使用 $N$ 个元胞的均匀网格，时间步长为 $\\Delta t$，并演化到最终时间 $T_{\\text{end}}$。\n- 在元胞界面上使用局部界面梯度大小来实现阈值 $\\chi$。\n- 强制执行上述边界条件。\n- 选择一个显式时间步进格式，该格式需满足基于 $\\chi$ 最大值和网格间距的稳定性约束，以保持数值稳定性。\n- 在每个时间步计算时间序列 $W(t)$ 和残差 $R(t)$，用给定的窗口大小构造 $R_{\\text{sm}}(t)$，并用所述逻辑计数雪崩状爆发。\n\n所有量均为无量纲。初始条件为 $T(r,0)=T_{\\text{edge}}$。\n\n测试套件：\n使用以下四组参数来测试您的实现。每组参数指定 $(N,a,\\Delta t,T_{\\text{end}},\\chi_{\\text{low}},\\chi_{\\text{high}},g_c,S_0,r_s,T_{\\text{edge}},w,k)$，其中 $w$ 是移动平均的窗口大小（以时间步数为单位），$k$ 是阈值定义 $\\theta = k \\,\\sigma_R$ 中的乘数。\n\n- 情况 $1$（基准慢驱动）：\n  - $N=64$, $a=1$, $\\Delta t=10^{-4}$, $T_{\\text{end}}=6\\times 10^{-1}$,\n  - $\\chi_{\\text{low}}=10^{-2}$, $\\chi_{\\text{high}}=5\\times 10^{-1}$, $g_c=3\\times 10^{-1}$,\n  - $S_0=8\\times 10^{-1}$, $r_s=25\\times 10^{-2}$, $T_{\\text{edge}}=0$,\n  - $w=50$, $k=3$。\n\n- 情况 $2$（更容易的阈值，预期爆发更频繁）：\n  - $N=64$, $a=1$, $\\Delta t=10^{-4}$, $T_{\\text{end}}=6\\times 10^{-1}$,\n  - $\\chi_{\\text{low}}=10^{-2}$, $\\chi_{\\text{high}}=5\\times 10^{-1}$, $g_c=2\\times 10^{-1}$,\n  - $S_0=8\\times 10^{-1}$, $r_s=25\\times 10^{-2}$, $T_{\\text{edge}}=0$,\n  - $w=50$, $k=3$。\n\n- 情况 $3$（无阈值，线性扩散）：\n  - $N=64$, $a=1$, $\\Delta t=10^{-4}$, $T_{\\text{end}}=6\\times 10^{-1}$,\n  - $\\chi_{\\text{low}}=5\\times 10^{-2}$, $\\chi_{\\text{high}}=5\\times 10^{-2}$, $g_c=10^{4}$,\n  - $S_0=8\\times 10^{-1}$, $r_s=25\\times 10^{-2}$, $T_{\\text{edge}}=0$,\n  - $w=50$, $k=3$。\n\n- 情况 $4$（更快的驱动）：\n  - $N=64$, $a=1$, $\\Delta t=10^{-4}$, $T_{\\text{end}}=6\\times 10^{-1}$,\n  - $\\chi_{\\text{low}}=10^{-2}$, $\\chi_{\\text{high}}=5\\times 10^{-1}$, $g_c=3\\times 10^{-1}$,\n  - $S_0=15\\times 10^{-1}$, $r_s=25\\times 10^{-2}$, $T_{\\text{edge}}=0$,\n  - $w=50$, $k=3$。\n\n最终输出规范：\n- 对于每种情况，计算如上定义的探测到的雪崩状爆发的整数数量。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按所列情况的顺序列出，例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$，其中每个 $\\text{result}_i$ 是一个整数。",
            "solution": "用户提供了一个有效的问题陈述。该问题要求开发并实现一个数值格式，用于求解一个一维非线性扩散方程，该方程模拟了简化聚变等离子体环境中的温度输运。目标是计数雪崩状输运事件，这些事件是自组织临界（SOC）的特征。该问题在计算物理学上具有科学依据，在数学上是适定的，并为计算唯一解提供了一整套完整的参数和定义。\n\n推导和实现将按以下步骤进行：\n1.  在均匀网格上使用有限体积法对控制偏微分方程（PDE）进行离散化。\n2.  实现指定的边界条件：芯部（$r=0$）的零梯度（Neumann）条件和边缘（$r=a$）的固定温度（Dirichlet）条件。\n3.  采用显式前向欧拉时间步进格式，确保满足稳定性条件。\n4.  基于边界热通量的时间序列，开发用于探测和计数雪崩的算法。\n\n**1. 有限体积法离散化**\n\n控制偏微分方程是一个一维非线性扩散方程：\n$$\n\\partial_t T(r,t) = \\partial_r\\left(\\chi\\left(T,\\partial_r T\\right)\\,\\partial_r T\\right) + S(r,t)\n$$\n该方程是守恒形式 $\\partial_t T = \\partial_r J + S$，其中 $J(r,t) = \\chi \\partial_r T$ 是热通量。这种形式非常适合有限体积法离散化，该方法固有地保证了被输运量（在此情况下为热能密度 $T$）的守恒。\n\n我们在区域 $r \\in [0, a]$ 上定义一个包含 $N$ 个元胞的均匀网格。每个元胞的宽度为 $\\Delta r = a/N$。元胞中心位于 $r_i = (i + 1/2)\\Delta r$，其中 $i=0, 1, \\dots, N-1$。元胞边界，或称界面，位于 $r_{i+1/2} = (i+1)\\Delta r$，其中 $i=-1, 0, \\dots, N-1$。物理区域由位于 $r_{-1/2} = 0$ 和 $r_{N-1/2} = a$ 的界面界定。\n\n我们在第 $i$ 个元胞上，从 $r_{i-1/2}$ 到 $r_{i+1/2}$ 对 PDE 进行积分：\n$$\n\\int_{r_{i-1/2}}^{r_{i+1/2}} \\partial_t T \\, dr = \\int_{r_{i-1/2}}^{r_{i+1/2}} \\partial_r J \\, dr + \\int_{r_{i-1/2}}^{r_{i+1/2}} S \\, dr\n$$\n假设 $T_i(t)$ 代表元胞 $i$ 中的平均温度，左侧变为 $\\Delta r \\frac{d T_i}{dt}$。右侧的通量项使用微积分基本定理，源项使用中点法则进行计算：\n$$\n\\Delta r \\frac{d T_i}{dt} = J(r_{i+1/2}, t) - J(r_{i-1/2}, t) + S(r_i, t) \\Delta r\n$$\n两边除以 $\\Delta r$，我们得到元胞 $i$ 中温度演化的半离散方程：\n$$\n\\frac{d T_i}{dt} = \\frac{J_{i+1/2} - J_{i-1/2}}{\\Delta r} + S_i\n$$\n其中 $J_{i+1/2}$ 表示元胞 $i$ 和元胞 $i+1$ 之间界面的通量，$S_i = S(r_i)$。\n\n通量 $J_{i+1/2}$ 使用跨界面的中心差分来近似梯度：\n$$\nJ_{i+1/2} = \\chi_{i+1/2} \\left( \\frac{T_{i+1} - T_i}{\\Delta r} \\right)\n$$\n输运系数 $\\chi_{i+1/2}$ 非线性地依赖于该局部梯度的大小 $g_{i+1/2} = \\left| \\frac{T_{i+1} - T_i}{\\Delta r} \\right|$：\n$$\n\\chi_{i+1/2} = \\chi_{\\text{low}} + (\\chi_{\\text{high}} - \\chi_{\\text{low}}) H(g_{i+1/2} - g_c)\n$$\n其中 $H$ 是 Heaviside 阶跃函数。\n\n**2. 边界条件**\n\n-   **芯部边界（$r=0$）：** 零梯度条件 $\\partial_r T(0,t) = 0$ 意味着芯部热通量为零。$r=0$ 处的界面是 $r_{-1/2}$，因此我们设置 $J_{-1/2} = 0$。第一个元胞（$i=0$）的方程变为：\n    $$\n    \\frac{d T_0}{dt} = \\frac{J_{1/2}}{\\Delta r} + S_0\n    $$\n\n-   **边缘边界（$r=a$）：** 固定温度条件为 $T(a,t) = T_{\\text{edge}}$。边缘界面是 $r_{N-1/2} = a$。为了计算进入最后一个物理元胞（$i=N-1$）的通量 $J_{N-1/2}$，我们需要该界面上的梯度。可以通过定义一个“虚拟”元胞值 $T_N$ 来构造一个二阶精度的中心差分，使得 $T_{N-1}$ 和 $T_N$ 的平均值给出所需的边界温度。然而，一个更简单且更常见的有限体积法是使用最后一个元胞中心 $r_{N-1} = a - \\Delta r/2$ 与边界 $r=a$ 之间的单边差分。距离为 $\\Delta r/2$。一种更稳健且能为所有通量保持中心差分结构的方法是，使用已知的边界值 $T_{\\text{edge}}$ 和最后一个元胞中心值 $T_{N-1}$ 来定义边界界面 $r_{N-1/2}$ 处的梯度。\n    为了保持一致的模板，我们可以想象一个虚拟点 $T_N$，使得线性插值得到边界值，即 $T(a) = (T_{N-1} + T_N)/2 = T_{\\text{edge}}$。这意味着 $T_N = 2T_{\\text{edge}} - T_{N-1}$。那么，界面 $r_{N-1/2}$ 处的梯度可以一致地近似为：\n    $$\n    (\\partial_r T)_{N-1/2} \\approx \\frac{T_N - T_{N-1}}{\\Delta r} = \\frac{(2T_{\\text{edge}} - T_{N-1}) - T_{N-1}}{\\Delta r} = \\frac{2(T_{\\text{edge}} - T_{N-1})}{\\Delta r}\n    $$\n    此公式正确地确定了更新元胞 $T_{N-1}$ 所需的通量 $J_{N-1/2}$。\n\n**3. 时间积分与稳定性**\n\n我们使用显式前向欧拉格式以时间步长 $\\Delta t$ 向前推进。在时间步 $n$，元胞 $i$ 的全离散更新规则为：\n$$\nT_i^{n+1} = T_i^n + \\frac{\\Delta t}{\\Delta r} (J_{i+1/2}^n - J_{i-1/2}^n) + \\Delta t S_i\n$$\n其中所有通量 $J^n$ 都是使用当前时间步的温度 $T^n$ 计算的。显式格式受到稳定性约束。对于扩散方程，这是 Courant-Friedrichs-Lewy (CFL) 条件，对于我们的非线性问题，该条件为：\n$$\n\\frac{\\chi_{\\max} \\Delta t}{(\\Delta r)^2} \\le \\frac{1}{2}\n$$\n这里，$\\chi_{\\max} = \\chi_{\\text{high}}$。对于所有提供的测试用例，$\\chi_{\\text{high}} = 0.5$（或更小），$\\Delta t = 10^{-4}$，$\\Delta r = 1/64$，得出 $\\frac{0.5 \\cdot 10^{-4}}{(1/64)^2} \\approx 0.2048$，小于 $0.5$。因此，所选参数保证了数值稳定性。\n\n**4. 雪崩探测算法**\n\n总热能 $W(t) = \\int_0^a T(r,t) dr$ 被离散化为 $W^n = \\Delta r \\sum_{i=0}^{N-1} T_i^n$。瞬时残差定义为 $R(t) = \\frac{dW}{dt} - \\int_0^a S dr$。从 PDE 的守恒形式可知，$\\frac{d}{dt}\\int_0^a T dr = J(a,t) - J(0,t) + \\int_0^a S dr$。由于 $J(0,t)=0$，这简化为 $R(t) = J(a,t)$。在我们的离散系统中，第 $n$ 步的残差就是边缘边界处的通量：$R^n = J_{N-1/2}^n$。\n\n探测过程如下：\n1.  运行模拟直到 $T_{\\text{end}}$，在每个时间步将残差 $R^n$ 记录到一个历史数组 $R_{\\text{hist}}$ 中。\n2.  丢弃初始瞬态阶段，以关注统计稳态。我们丢弃模拟数据的前一半。设 $n_{\\text{steps}} = T_{\\text{end}} / \\Delta t$ 且 $n_{\\text{transient}} = n_{\\text{steps}}/2$。\n3.  计算 $t  t_{\\text{transient}}$ 时残差 $R(t)$ 的标准差 $\\sigma_R$。\n4.  将雪崩阈值定义为 $\\theta = k \\sigma_R$。\n5.  通过对完整的 $R_{\\text{hist}}$ 序列应用窗口大小为 $w$ 的中心移动平均，计算平滑残差 $R_{\\text{sm}}(t)$。`scipy.ndimage.uniform_filter1d` 函数（使用 `mode='nearest'`）适合此任务。\n6.  在后瞬态阶段分析平滑残差。当 $R_{\\text{sm}}(t)$ 下降到负阈值 $-\\theta$ 以下时，触发一次雪崩。\n7.  为实现“平滑窗口内的连续穿越必须被视为同一事件的一部分”的条件，我们首先识别所有 $R_{\\text{sm}}(t)$ 从上方穿越 $-\\theta$ 的时间步（即 $R_{\\text{sm}}(t)  -\\theta$ 且 $R_{\\text{sm}}(t-\\Delta t) \\ge -\\theta$）。让这些时间点成为潜在雪崩的开始时间。\n8.  然后，我们将开始时间间隔小于或等于窗口大小 $w$ 的任意两个潜在雪崩合并。这些合并后事件的总数即为最终结果。\n\n这样就完成了数值模型和分析流程的设计。实现将遵循此框架。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import uniform_filter1d\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (baseline slow drive)\n        (64, 1.0, 1e-4, 0.6, 1e-2, 0.5, 0.3, 0.8, 0.25, 0.0, 50, 3.0),\n        # Case 2 (easier threshold)\n        (64, 1.0, 1e-4, 0.6, 1e-2, 0.5, 0.2, 0.8, 0.25, 0.0, 50, 3.0),\n        # Case 3 (no thresholding, linear diffusion)\n        (64, 1.0, 1e-4, 0.6, 5e-2, 5e-2, 1e4, 0.8, 0.25, 0.0, 50, 3.0),\n        # Case 4 (faster drive)\n        (64, 1.0, 1e-4, 0.6, 1e-2, 0.5, 0.3, 1.5, 0.25, 0.0, 50, 3.0),\n    ]\n\n    results = []\n    for params in test_cases:\n        count = run_simulation(*params)\n        results.append(count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(N, a, dt, T_end, chi_low, chi_high, g_c, S0, rs, T_edge, w, k):\n    \"\"\"\n    Performs one full simulation and avalanche analysis for a given set of parameters.\n\n    Args:\n        N (int): Number of grid cells.\n        a (float): Domain size.\n        dt (float): Time step.\n        T_end (float): Final simulation time.\n        chi_low (float): Low transport coefficient.\n        chi_high (float): High transport coefficient.\n        g_c (float): Gradient threshold for SOC.\n        S0 (float): Source amplitude.\n        rs (float): Source localization width.\n        T_edge (float): Fixed temperature at the edge.\n        w (int): Moving average window size for avalanche detection.\n        k (float): Multiplier for avalanche threshold.\n\n    Returns:\n        int: The number of detected avalanche-like bursts.\n    \"\"\"\n    # 1. Initialization\n    dr = a / N\n    r_centers = (np.arange(N) + 0.5) * dr\n\n    T = np.full(N, T_edge)\n    S = S0 * np.exp(-(r_centers / rs)**2)\n\n    n_steps = int(T_end / dt)\n    R_hist = np.zeros(n_steps)\n    \n    # Pre-calculate constants for the loop\n    c_chi = chi_high - chi_low\n    dt_dr = dt / dr\n\n    # 2. Time Evolution Loop\n    for n in range(n_steps):\n        # Array for face fluxes, J[i] corresponds to flux at face i+1/2\n        # J_faces has size N: J_faces[0]...J_faces[N-2] are interior, J_faces[N-1] is edge.\n        J_faces = np.zeros(N)\n        \n        # Interior faces (i = 0 to N-2)\n        grad_interior = (T[1:] - T[:-1]) / dr\n        chi_interior = chi_low + c_chi * (np.abs(grad_interior)  g_c)\n        J_faces[:-1] = chi_interior * grad_interior\n\n        # Edge face (i = N-1)\n        grad_edge = 2.0 * (T_edge - T[N-1]) / dr\n        chi_edge = chi_low + c_chi * (np.abs(grad_edge)  g_c)\n        J_faces[-1] = chi_edge * grad_edge\n\n        # Construct full flux array J of size N+1 (J[0] at r=0, J[N] at r=a)\n        J = np.zeros(N + 1)\n        J[1:] = J_faces\n        \n        # Update Temperature\n        T += dt_dr * (J[1:] - J[:-1]) + dt * S\n        \n        # Store residual (flux at the edge)\n        R_hist[n] = J[N]\n\n    # 3. Avalanche Detection\n    # Discard first half as transient\n    n_transient = n_steps // 2\n    R_analysis = R_hist[n_transient:]\n\n    if len(R_analysis) == 0:\n        return 0\n\n    # Calculate threshold from standard deviation of non-smoothed post-transient data\n    sigma_R = np.std(R_analysis)\n    if sigma_R == 0: # No fluctuations, no avalanches\n        return 0\n    theta = k * sigma_R\n\n    # Smooth the ENTIRE residual series to avoid edge effects at the transient boundary\n    # then analyze the post-transient part.\n    R_sm = uniform_filter1d(R_hist, size=w, mode='nearest')\n    R_sm_analysis = R_sm[n_transient:]\n\n    # Find downward crossings of the threshold -theta\n    is_below = R_sm_analysis  -theta\n    # Add a False at the beginning to catch a crossing at the very first step\n    is_below_padded = np.insert(is_below, 0, False)\n    # A crossing occurs where the state changes from False to True\n    crossings = np.where(np.diff(is_below_padded.astype(int)) == 1)[0]\n\n    if len(crossings) == 0:\n        return 0\n\n    # Merge events closer than the smoothing window 'w'\n    avalanche_count = 1\n    for i in range(1, len(crossings)):\n        if crossings[i] - crossings[i-1]  w:\n            avalanche_count += 1\n            \n    return avalanche_count\n\nsolve()\n```"
        },
        {
            "introduction": "自组织临界的一个关键特征是雪崩事件的统计分布（例如尺寸或持续时间）遵循幂律。然而，在科学研究中，仅仅观察到数据在双对数坐标下近似为直线，并不足以得出存在幂律的结论。这项高级实践将指导您设计并实现一个严谨的假设检验（Vuong 检验），以统计上区分幂律分布与对数正态或指数等其他常见备选分布，这是分析模拟和实验数据时一项至关重要的技能。",
            "id": "4044372",
            "problem": "您的任务是设计、推导并实现一个似然比假设检验，用以判断在自组织临界性（SOC）输运中观测到的雪崩爆发幅度，是否用幂律尾描述比用对数正态或指数替代模型更佳。其背景是计算聚变科学与工程，在该领域中，与磁约束等离子体中的雪崩相关的爆发事件通常被认为遵循重尾统计。您的解决方案必须从基本定义出发，以证明该检验的合理性，并生成一个能够评估指定合成数据集测试套件的可运行程序。\n\n从以下具有科学依据的基础开始：\n\n- 概率密度函数（PDF）的定义以及独立同分布样本的相应似然。\n- 最大似然估计（MLE）的原理。\n- 通过单样本对数似然差比较模型的概念。\n- 在模型设定错误的情况下，平均对数似然差的渐近正态性，这导出了一个标准化的检验统计量（用于非嵌套模型的 Vuong 检验）。\n\n将爆发幅度变量 $x$ 建模为连续变量，且严格受正尺度 $x_{\\min}$ 的下界约束。考虑在 $x \\ge x_{\\min}$ 上的三种候选尾部模型：\n\n1. 具有形状参数 $\\alpha  1$ 和下界 $x_{\\min}$ 的连续幂律尾。\n2. 具有率参数 $\\lambda  0$ 和下界 $x_{\\min}$ 的移位指数尾。\n3. 在 $x_{\\min}$ 以下截断的对数正态分布（参数为 $\\mu \\in \\mathbb{R}$ 和 $\\sigma  0$）。\n\n您的任务是：\n\n- 从第一性原理出发，为每个模型推导在 $x \\ge x_{\\min}$ 上正确归一化的 PDF。\n- 仅使用提供的基本原理，推导幂律形状参数和指数率参数的最大似然估计。对于截断对数正态分布的参数，推导其对数似然的形式，并解释为什么通常不存在闭合形式的解，从而说明进行数值优化的动机。\n- 定义单样本对数似然差 $d_i = \\ln p_{\\mathrm{PL}}(x_i \\mid \\hat{\\theta}_{\\mathrm{PL}}) - \\ln p_{\\mathrm{ALT}}(x_i \\mid \\hat{\\theta}_{\\mathrm{ALT}})$，其中 $p_{\\mathrm{PL}}$ 是使用其 MLE 参数的幂律 PDF，$p_{\\mathrm{ALT}}$ 是使用其 MLE 参数的替代 PDF（对数正态或指数）。利用独立同分布变量的中心极限定理和模型设定错误下 MLE 的性质，推导标准化统计量\n$$\nV = \\frac{\\sqrt{n} \\,\\bar{d}}{s},\n$$\n其中 $n$ 是样本大小，$\\bar{d} = \\frac{1}{n}\\sum_{i=1}^{n} d_i$，$s$ 是 $\\{d_i\\}_{i=1}^n$ 的样本标准差，并通过标准正态累积分布函数定义一个双边 $p$ 值。\n- 在显著性水平 $\\alpha_{\\mathrm{test}} = 0.05$ 下陈述一个决策规则：如果双边 $p$ 值小于 0.05 并且总对数似然比 $\\sum_{i=1}^{n} d_i$ 为正，则倾向于选择幂律模型优于替代模型；否则，不声明偏好。\n\n实现一个完整、可运行的程序，该程序：\n\n- 根据指定的模型和参数生成合成数据集。\n- 对每个数据集上的每个模型进行参数估计。\n- 计算 Vuong 检验统计量和 $p$ 值，以比较幂律模型与对数正态和指数替代模型。\n- 应用决策规则并输出所有测试案例的最终决策。\n\n单位：爆发幅度 $x$ 是无量纲的正标量。所有输入和输出均无单位。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n测试套件：\n使用以下四个测试案例，并固定随机种子 $s = 12345$ 以确保可复现性。在每个案例中，从指定的生成分布中抽取 $n$ 个大于 $x_{\\min}$ 的样本。\n\n- 案例1（幂律主导的雪崩）：$n = 1000$, $x_{\\min} = 1.0$, 生成分布为形状参数 $\\alpha = 2.3$ 的幂律分布。\n- 案例2（对数正态主导的爆发）：$n = 1000$, $x_{\\min} = 1.0$, 生成分布为参数 $\\mu = 0.0, \\sigma = 0.9$ 的在 $x_{\\min}$ 以下截断的对数正态分布。\n- 案例3（指数限制的输运）：$n = 1000$, $x_{\\min} = 1.0$, 生成分布为率参数 $\\lambda = 1.2$ 的移位指数分布。\n- 案例4（稀疏样本，重尾边界情况）：$n = 30$, $x_{\\min} = 1.0$, 生成分布为形状参数 $\\alpha = 1.8$ 的幂律分布。\n\n答案格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个元素对应一个测试案例，并且本身是一个包含两个布尔值的列表，顺序为 $[\\text{倾向于幂律 vs 对数正态}, \\text{倾向于幂律 vs 指数}]$。例如，输出格式必须如下所示\n$$\n[[\\mathrm{True},\\mathrm{False}],[\\mathrm{False},\\mathrm{False}],[\\mathrm{True},\\mathrm{True}],[\\mathrm{False},\\mathrm{False}]].\n$$",
            "solution": "所提供的问题被评估为有效。它在统计力学和推断方面具有科学依据，其定义和约束条件完整且一致，问题表述清晰明确，并且其形式是客观的。该问题要求对与指定科学领域相关的标准（尽管不简单）统计程序进行严格的推导和实现。我们着手进行解答。\n\n解决方案分为四个部分：推导三种候选模型的概率密度函数（PDF），推导它们相应的最大似然估计（MLE），构建用于模型比较的 Vuong 检验统计量，以及定义决策规则。\n\n**1. 概率密度函数**\n\n所有模型都描述了在域 $[x_{\\min}, \\infty)$ 上的连续随机变量 $x$，其中 $x_{\\min}  0$。任何模型的 PDF $p(x)$ 都必须归一化，使得 $\\int_{x_{\\min}}^{\\infty} p(x) dx = 1$。\n\n*   **幂律分布**：其函数形式为 $p(x) \\propto x^{-\\alpha}$，适用于 $x \\ge x_{\\min}$，形状参数 $\\alpha  1$。归一化常数 $C$ 由条件 $C \\int_{x_{\\min}}^{\\infty} x^{-\\alpha} dx = 1$ 得出。该积分的计算结果为：\n    $$\n    \\int_{x_{\\min}}^{\\infty} x^{-\\alpha} dx = \\left[ \\frac{x^{-\\alpha+1}}{1-\\alpha} \\right]_{x_{\\min}}^{\\infty} = 0 - \\frac{x_{\\min}^{1-\\alpha}}{1-\\alpha} = \\frac{x_{\\min}^{1-\\alpha}}{\\alpha-1}\n    $$\n    积分收敛要求指数 $1-\\alpha$ 为负，因此 $\\alpha  1$。归一化常数为 $C = (\\alpha-1)x_{\\min}^{\\alpha-1}$。正确归一化的 PDF 为：\n    $$\n    p_{\\mathrm{PL}}(x | \\alpha, x_{\\min}) = (\\alpha-1)x_{\\min}^{\\alpha-1} x^{-\\alpha}\n    $$\n\n*   **移位指数分布**：其函数形式为 $p(x) \\propto e^{-\\lambda(x-x_{\\min})}$，适用于 $x \\ge x_{\\min}$，率参数 $\\lambda  0$。归一化常数 $C$ 由 $C \\int_{x_{\\min}}^{\\infty} e^{-\\lambda(x-x_{\\min})} dx = 1$ 得出。设 $y = x-x_{\\min}$，则 $dy = dx$。积分变为 $C \\int_{0}^{\\infty} e^{-\\lambda y} dy = 1$。\n    $$\n    \\int_{0}^{\\infty} e^{-\\lambda y} dy = \\left[ -\\frac{1}{\\lambda}e^{-\\lambda y} \\right]_0^\\infty = 0 - (-\\frac{1}{\\lambda}) = \\frac{1}{\\lambda}\n    $$\n    这要求 $\\lambda  0$。归一化常数为 $C = \\lambda$。归一化的 PDF 为：\n    $$\n    p_{\\mathrm{EXP}}(x | \\lambda, x_{\\min}) = \\lambda e^{-\\lambda(x-x_{\\min})}\n    $$\n\n*   **截断对数正态分布**：此模型是一个标准的对数正态分布，参数为 $\\mu$ 和 $\\sigma$，以 $x \\ge x_{\\min}$ 为条件。标准对数正态变量 $Z$ 的 PDF 为 $p_{LN}(z|\\mu, \\sigma) = \\frac{1}{z \\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln z - \\mu)^2}{2\\sigma^2}\\right)$。截断后的 PDF 由 $p_{\\mathrm{LNT}}(x) = \\frac{p_{LN}(x)}{\\mathbb{P}(Z \\ge x_{\\min})}$ 给出。分母是生存函数 $S \\equiv \\mathbb{P}(Z \\ge x_{\\min})$，它作为归一化因子。\n    $$\n    S = \\int_{x_{\\min}}^{\\infty} p_{LN}(z|\\mu, \\sigma) dz\n    $$\n    设 $u = (\\ln z - \\mu) / \\sigma$。这将积分转换为对标准正态 PDF $\\phi(u) = (1/\\sqrt{2\\pi})e^{-u^2/2}$ 的积分：\n    $$\n    S = \\int_{(\\ln x_{\\min} - \\mu)/\\sigma}^{\\infty} \\phi(u) du = 1 - \\Phi\\left(\\frac{\\ln x_{\\min} - \\mu}{\\sigma}\\right)\n    $$\n    其中 $\\Phi$ 是标准正态累积分布函数 (CDF)。使用误差函数，可得 $S = \\frac{1}{2}\\mathrm{erfc}\\left(\\frac{\\ln x_{\\min} - \\mu}{\\sigma\\sqrt{2}}\\right)$。归一化的 PDF 为：\n    $$\n    p_{\\mathrm{LNT}}(x | \\mu, \\sigma, x_{\\min}) = \\frac{1}{S \\cdot x \\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}\\right)\n    $$\n\n**2. 最大似然估计 (MLE)**\n\n对于一组 $n$ 个独立同分布的样本 $\\{x_i\\}_{i=1}^n$，对数似然函数为 $\\mathcal{L}(\\theta) = \\sum_{i=1}^n \\ln p(x_i | \\theta)$。MLE $\\hat{\\theta}$ 是使 $\\mathcal{L}(\\theta)$ 最大化的参数矢量 $\\theta$ 的值。\n\n*   **幂律参数 $\\alpha$**：对数似然函数为：\n    $$\n    \\mathcal{L}(\\alpha) = \\sum_{i=1}^n \\left[ \\ln(\\alpha-1) + (\\alpha-1)\\ln x_{\\min} - \\alpha \\ln x_i \\right] = n\\ln(\\alpha-1) + n(\\alpha-1)\\ln x_{\\min} - \\alpha \\sum_{i=1}^n \\ln x_i\n    $$\n    将关于 $\\alpha$ 的导数设为零，可得 MLE $\\hat{\\alpha}$：\n    $$\n    \\frac{\\partial\\mathcal{L}}{\\partial\\alpha} = \\frac{n}{\\alpha-1} + n\\ln x_{\\min} - \\sum_{i=1}^n \\ln x_i = 0 \\quad \\implies \\quad \\hat{\\alpha}_{\\mathrm{MLE}} = 1 + n \\left( \\sum_{i=1}^n \\ln\\frac{x_i}{x_{\\min}} \\right)^{-1}\n    $$\n*   **指数参数 $\\lambda$**：对数似然函数为：\n    $$\n    \\mathcal{L}(\\lambda) = \\sum_{i=1}^n \\left[ \\ln\\lambda - \\lambda(x_i - x_{\\min}) \\right] = n\\ln\\lambda - \\lambda \\sum_{i=1}^n (x_i - x_{\\min})\n    $$\n    将关于 $\\lambda$ 的导数设为零，可得 MLE $\\hat{\\lambda}$：\n    $$\n    \\frac{\\partial\\mathcal{L}}{\\partial\\lambda} = \\frac{n}{\\lambda} - \\sum_{i=1}^n (x_i - x_{\\min}) = 0 \\quad \\implies \\quad \\hat{\\lambda}_{\\mathrm{MLE}} = \\frac{n}{\\sum_{i=1}^n (x_i - x_{\\min})} = \\frac{1}{\\bar{x} - x_{\\min}}\n    $$\n*   **截断对数正态参数 $(\\mu, \\sigma)$**：对数似然函数为：\n    $$\n    \\mathcal{L}(\\mu, \\sigma) = \\sum_{i=1}^n \\ln p_{\\mathrm{LNT}}(x_i) = -n\\ln S(\\mu, \\sigma) - n\\ln\\sigma - \\frac{n}{2}\\ln(2\\pi) - \\sum_{i=1}^n \\ln x_i - \\frac{1}{2\\sigma^2}\\sum_{i=1}^n (\\ln x_i - \\mu)^2\n    $$\n    当将偏导数 $\\partial\\mathcal{L}/\\partial\\mu$ 和 $\\partial\\mathcal{L}/\\partial\\sigma$ 设为零时，归一化因子 $S$ 对 $\\mu$ 和 $\\sigma$ 的依赖性导致了一个耦合的非线性方程组。$\\hat{\\mu}$ 和 $\\hat{\\sigma}$ 没有闭合形式的解。因此，这些参数必须通过数值最大化对数似然函数来找到。\n\n**3. 用于非嵌套模型的 Vuong 检验**\n\nVuong 检验为两种非嵌套模型（如幂律分布和对数正态分布）提供了正式的统计比较。设两个竞争模型为 $p_1(x|\\theta_1)$（幂律）和 $p_2(x|\\theta_2)$（替代模型）。该检验基于在各自的 MLE 处评估的单样本对数似然差：\n$$\nd_i = \\ln p_{1}(x_i | \\hat{\\theta}_{1}) - \\ln p_{2}(x_i | \\hat{\\theta}_{2})\n$$\n原假设 $H_0$ 是，两个模型与真实数据生成分布的接近程度（在 Kullback-Leibler 意义上）相等，这意味着 $\\mathbb{E}[d_i]=0$。在 $H_0$ 下，中心极限定理指出，样本均值 $\\bar{d} = \\frac{1}{n}\\sum_{i=1}^n d_i$ 渐近服从均值为 $0$ 的正态分布。标准化的检验统计量为：\n$$\nV = \\frac{\\sqrt{n} \\, \\bar{d}}{s}\n$$\n其中 $s$ 是差值 $\\{d_i\\}_{i=1}^n$ 的样本标准差，定义为 $s = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^n (d_i - \\bar{d})^2}$。在 $H_0$ 下，统计量 $V$ 在分布上收敛于一个标准正态变量，$V \\sim \\mathcal{N}(0,1)$。双边 $p$ 值计算为 $p = \\mathbb{P}(|Z| \\ge |V_{\\text{obs}}|) = 2(1-\\Phi(|V_{\\text{obs}}|))$，其中 $Z \\sim \\mathcal{N}(0,1)$。\n\n**4. 决策规则**\n\n在选定的显著性水平 $\\alpha_{\\mathrm{test}} = 0.05$ 下，我们可以决定一个模型是否显著优于另一个模型。倾向于选择幂律模型 ($p_1$) 而非替代模型 ($p_2$) 的决策规则基于两个条件：\n1.  检验必须显示模型之间存在统计上显著的差异，即 $p$ 值必须小于 $\\alpha_{\\mathrm{test}}$。\n2.  差异的方向必须有利于幂律模型。这由总对数似然比 $LR = \\sum_{i=1}^n d_i = n\\bar{d}$ 的符号决定。一个正的 $LR$ 表明数据在幂律模型下更可能出现。\n\n因此，当且仅当 $p  0.05$ 且 $LR  0$ 时，我们倾向于选择幂律模型。否则，我们不能声称对幂律模型有偏好。这包括模型在统计上无法区分（$p \\ge 0.05$）或替代模型显著更优（$p  0.05$ 且 $LR  0$）的情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats, optimize, special\n\ndef solve():\n    \"\"\"\n    Main function to run the hypothesis tests on the specified test suite.\n    \"\"\"\n    SEED = 12345\n    ALPHA_TEST = 0.05\n    X_MIN = 1.0\n    rng = np.random.default_rng(SEED)\n\n    # --- Data Generation Functions ---\n    def generate_power_law(n, alpha, x_min, rng_instance):\n        u = rng_instance.uniform(low=0.0, high=1.0, size=n)\n        return x_min * (1.0 - u)**(-1.0 / (alpha - 1.0))\n\n    def generate_exponential(n, lam, x_min, rng_instance):\n        u = rng_instance.uniform(low=0.0, high=1.0, size=n)\n        return x_min - (1.0 / lam) * np.log(u)\n\n    def generate_truncated_lognormal(n, mu, sigma, x_min, rng_instance):\n        u = rng_instance.uniform(low=0.0, high=1.0, size=n)\n        # Inverse transform sampling for truncated distribution\n        p_min = stats.norm.cdf((np.log(x_min) - mu) / sigma)\n        v = p_min + u * (1.0 - p_min)\n        return np.exp(mu + sigma * stats.norm.ppf(v))\n\n    # --- Log-PDF Functions (for computing log-likelihoods) ---\n    def logpdf_power_law(x, alpha, x_min):\n        if alpha = 1.0: return -np.inf\n        return np.log(alpha - 1.0) + (alpha - 1.0) * np.log(x_min) - alpha * np.log(x)\n\n    def logpdf_exponential(x, lam, x_min):\n        if lam = 0.0: return -np.inf\n        return np.log(lam) - lam * (x - x_min)\n\n    def logpdf_truncated_lognormal(x, mu, sigma, x_min):\n        if sigma = 0.0: return -np.inf\n        # Use a stable log-sum-exp trick for the normalization term log(S) if needed,\n        # but erfc is generally stable.\n        u_min = (np.log(x_min) - mu) / (sigma * np.sqrt(2.0))\n        # log(S) = log(0.5 * erfc(u_min))\n        log_s = np.log(0.5) + np.log(special.erfc(u_min))\n        if np.isinf(log_s): return -np.inf\n        \n        log_x = np.log(x)\n        log_p_unnormalized = -log_x - np.log(sigma) - 0.5 * np.log(2.0 * np.pi) - (log_x - mu)**2 / (2.0 * sigma**2)\n        return log_p_unnormalized - log_s\n\n    # --- Parameter Estimation Functions ---\n    def fit_power_law(x, x_min):\n        n = len(x)\n        # Clauset-Shalizi-Newman MLE\n        alpha = 1.0 + n / np.sum(np.log(x / x_min))\n        return alpha\n\n    def fit_exponential(x, x_min):\n        lam = 1.0 / (np.mean(x) - x_min)\n        return lam\n\n    def fit_truncated_lognormal(x, x_min):\n        def neg_loglik(params, data, x_min_val):\n            mu, sigma = params\n            log_liks = logpdf_truncated_lognormal(data, mu, sigma, x_min_val)\n            # Penalize invalid parameter ranges\n            if np.any(np.isinf(log_liks)):\n                return np.inf\n            return -np.sum(log_liks)\n\n        # Initial guess from non-truncated log-normal fit\n        log_x = np.log(x)\n        init_mu = np.mean(log_x)\n        init_sigma = np.std(log_x, ddof=1)\n        if init_sigma  1e-6: init_sigma = 1e-6\n\n        result = optimize.minimize(\n            neg_loglik,\n            [init_mu, init_sigma],\n            args=(x, x_min),\n            method='L-BFGS-B',\n            bounds=[(None, None), (1e-9, None)]\n        )\n        return result.x\n\n    # --- Test Suite Definition ---\n    test_cases = [\n        {'name': 'Case 1: PL-Generated', 'n': 1000, 'x_min': 1.0, 'gen': 'pl', 'params': {'alpha': 2.3}},\n        {'name': 'Case 2: LNT-Generated', 'n': 1000, 'x_min': 1.0, 'gen': 'lnt', 'params': {'mu': 0.0, 'sigma': 0.9}},\n        {'name': 'Case 3: Exp-Generated', 'n': 1000, 'x_min': 1.0, 'gen': 'exp', 'params': {'lam': 1.2}},\n        {'name': 'Case 4: Sparse PL', 'n': 30, 'x_min': 1.0, 'gen': 'pl', 'params': {'alpha': 1.8}},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        n, x_min = case['n'], case['x_min']\n        \n        # 1. Generate data\n        if case['gen'] == 'pl':\n            data = generate_power_law(n, case['params']['alpha'], x_min, rng)\n        elif case['gen'] == 'lnt':\n            data = generate_truncated_lognormal(n, case['params']['mu'], case['params']['sigma'], x_min, rng)\n        else: # exp\n            data = generate_exponential(n, case['params']['lam'], x_min, rng)\n        \n        # 2. Fit all models\n        alpha_hat = fit_power_law(data, x_min)\n        lam_hat = fit_exponential(data, x_min)\n        mu_hat, sigma_hat = fit_truncated_lognormal(data, x_min)\n\n        # 3. Compute per-sample log-likelihoods for each fitted model\n        ll_pl = logpdf_power_law(data, alpha_hat, x_min)\n        ll_lnt = logpdf_truncated_lognormal(data, mu_hat, sigma_hat, x_min)\n        ll_exp = logpdf_exponential(data, lam_hat, x_min)\n\n        case_results = []\n        \n        # 4. Vuong Test: Power-Law vs. Log-Normal\n        d_vs_lnt = ll_pl - ll_lnt\n        d_bar_lnt = np.mean(d_vs_lnt)\n        s_lnt = np.std(d_vs_lnt, ddof=1)\n        V_lnt = (np.sqrt(n) * d_bar_lnt / s_lnt) if s_lnt  1e-10 else 0.0\n        p_val_lnt = 2.0 * stats.norm.sf(np.abs(V_lnt))\n        lr_lnt = np.sum(d_vs_lnt)\n        \n        prefer_pl_vs_lnt = (p_val_lnt  ALPHA_TEST) and (lr_lnt  0)\n        case_results.append(prefer_pl_vs_lnt)\n\n        # 5. Vuong Test: Power-Law vs. Exponential\n        d_vs_exp = ll_pl - ll_exp\n        d_bar_exp = np.mean(d_vs_exp)\n        s_exp = np.std(d_vs_exp, ddof=1)\n        V_exp = (np.sqrt(n) * d_bar_exp / s_exp) if s_exp  1e-10 else 0.0\n        p_val_exp = 2.0 * stats.norm.sf(np.abs(V_exp))\n        lr_exp = np.sum(d_vs_exp)\n        \n        prefer_pl_vs_exp = (p_val_exp  ALPHA_TEST) and (lr_exp  0)\n        case_results.append(prefer_pl_vs_exp)\n        \n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}