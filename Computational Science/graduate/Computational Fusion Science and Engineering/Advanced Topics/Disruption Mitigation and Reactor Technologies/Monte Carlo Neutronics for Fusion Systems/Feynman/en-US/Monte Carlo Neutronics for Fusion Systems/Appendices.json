{
    "hands_on_practices": [
        {
            "introduction": "A credible Monte Carlo neutronics simulation begins with an accurate representation of the neutron source. In a fusion device, neutrons are generated by D-T reactions within the plasma, and their spatial distribution is determined by the plasma's density and temperature profiles. To link the simulation results to physical reality, the tally from each simulated particle history must be normalized by a weight corresponding to the total physical neutron production rate. This exercise provides foundational practice in translating the physical characteristics of a fusion plasma into the essential inputs for a quantitative Monte Carlo simulation, bridging the gap between plasma physics theory and computational setup.",
            "id": "4016055",
            "problem": "Consider an axisymmetric tokamak with a circular cross-section, major radius $R$ and minor radius $a$. The plasma is a fully ionized, quasi-neutral Deuterium–Tritium (DT) mixture with equal species fractions, so $n_{D}(r) = n_{T}(r) = n_{e}(r)/2$, where $n_{e}(r)$ is the electron number density. The DT plasma is steady-state and uniform in temperature such that the DT Maxwellian-averaged fusion reactivity $\\langle \\sigma v \\rangle$ may be taken as a constant throughout the plasma.\n\nStarting from the core definition of the fusion reaction rate density $r_{f}(r) = n_{D}(r)\\,n_{T}(r)\\,\\langle \\sigma v \\rangle$ and the toroidal volume element appropriate for a circular cross-section, derive an analytical expression for the total neutron production rate in the steady state and then compute its numerical value for the plasma and device described below. Next, for a Monte Carlo method neutronics calculation that draws source neutron positions from a probability density proportional to $r_{f}(r)$ and uses $N_{s}$ independent source histories, determine the physical normalization factor $w$ (neutrons per source history) required so that the Monte Carlo estimator for the total neutron production rate equals the physically correct value.\n\nUse the following data, which are scientifically plausible for a burning-plasma tokamak:\n- Major radius: $R = 6.2\\,\\text{m}$.\n- Minor radius: $a = 2.0\\,\\text{m}$.\n- Electron number density profile: $n_{e}(r) = n_{0}\\left[1 - \\left(\\frac{r^{2}}{a^{2}}\\right)\\right]$ for $0 \\le r \\le a$, with $n_{0} = 1.0 \\times 10^{20}\\,\\text{m}^{-3}$.\n- DT Maxwellian-averaged reactivity (assumed spatially uniform): $\\langle \\sigma v \\rangle = 1.1 \\times 10^{-22}\\,\\text{m}^{3}\\,\\text{s}^{-1}$.\n- Number of Monte Carlo source histories: $N_{s} = 5.0 \\times 10^{6}$.\n\nAssume one neutron is produced per DT fusion reaction. Express the final normalization factor $w$ in neutrons per source neutron. Round your final answer to four significant figures. In intermediate steps, keep symbols exact; only substitute numerical values when evaluating the final normalization factor $w$.",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of fusion plasma physics and computational neutronics. All necessary parameters and definitions are provided, the data are physically plausible for a burning plasma experiment, and the problem is well-posed, leading to a unique, meaningful solution.\n\nThe primary task is to determine the normalization factor $w$ for a Monte Carlo neutron transport simulation. This factor relates the number of simulated source histories, $N_{s}$, to the total physical neutron production rate, $S_{n}$. The relationship is given by $S_{n} = w N_{s}$, which means the weight $w$ represents the number of physical neutrons per second corresponding to each simulated source history. To find $w$, we must first calculate the total neutron production rate $S_{n}$.\n\nThe total neutron production rate $S_{n}$ is the integral of the fusion reaction rate density, $r_{f}(r)$, over the entire plasma volume, $V_{p}$.\n$$S_{n} = \\int_{V_{p}} r_{f}(r) \\, dV$$\nThe fusion reaction rate density is given as $r_{f}(r) = n_{D}(r) n_{T}(r) \\langle \\sigma v \\rangle$.\nThe plasma is a $50-50$ Deuterium-Tritium (DT) mixture, so the ion densities are related to the electron density $n_{e}(r)$ by $n_{D}(r) = n_{T}(r) = n_{e}(r)/2$. Substituting this into the expression for $r_{f}(r)$ yields:\n$$r_{f}(r) = \\left(\\frac{n_{e}(r)}{2}\\right) \\left(\\frac{n_{e}(r)}{2}\\right) \\langle \\sigma v \\rangle = \\frac{n_{e}(r)^{2}}{4} \\langle \\sigma v \\rangle$$\nThe electron density profile is given as $n_{e}(r) = n_{0}\\left[1 - \\left(\\frac{r^{2}}{a^{2}}\\right)\\right]$.\nSubstituting this profile, the reaction rate density becomes:\n$$r_{f}(r) = \\frac{n_{0}^{2}}{4} \\left[1 - \\frac{r^{2}}{a^{2}}\\right]^{2} \\langle \\sigma v \\rangle$$\nNext, we must establish the volume element $dV$ for a toroidal geometry. For an axisymmetric tokamak with a circular cross-section, the volume element in toroidal coordinates $(r, \\theta, \\phi)$ (minor radius, poloidal angle, toroidal angle) is $dV = (R + r\\cos\\theta) r \\, dr \\, d\\theta \\, d\\phi$. Since the reaction rate density $r_{f}(r)$ depends only on the minor radius $r$, we can integrate over the angles $\\theta$ and $\\phi$ first.\nThe volume of a thin toroidal shell of minor radius $r$ and thickness $dr$ is:\n$$dV(r) = \\int_{0}^{2\\pi} d\\phi \\int_{0}^{2\\pi} d\\theta \\, (R + r\\cos\\theta) r \\, dr$$\n$$dV(r) = 2\\pi \\, r \\, dr \\int_{0}^{2\\pi} (R + r\\cos\\theta) d\\theta$$\n$$dV(r) = 2\\pi \\, r \\, dr \\, [R\\theta + r\\sin\\theta]_{0}^{2\\pi}$$\n$$dV(r) = 2\\pi \\, r \\, dr \\, (2\\pi R) = 4\\pi^{2} R r \\, dr$$\nThis is the differential volume of a toroidal shell at minor radius $r$. The total neutron source rate $S_{n}$ can now be expressed as an integral over the minor radius $r$ from $0$ to $a$:\n$$S_{n} = \\int_{0}^{a} r_{f}(r) \\, dV(r) = \\int_{0}^{a} \\frac{n_{0}^{2}}{4} \\left[1 - \\frac{r^{2}}{a^{2}}\\right]^{2} \\langle \\sigma v \\rangle (4\\pi^{2} R r) \\, dr$$\nWe can collect the constant terms outside the integral:\n$$S_{n} = \\pi^{2} R n_{0}^{2} \\langle \\sigma v \\rangle \\int_{0}^{a} \\left[1 - \\frac{r^{2}}{a^{2}}\\right]^{2} r \\, dr$$\nTo solve the integral, we use the substitution $u = \\frac{r^{2}}{a^{2}}$. This implies $du = \\frac{2r}{a^{2}} dr$, or $r \\, dr = \\frac{a^{2}}{2} du$. The limits of integration change from $r=0$ to $u=0$ and from $r=a$ to $u=1$.\nThe integral becomes:\n$$\\int_{0}^{1} (1 - u)^{2} \\left(\\frac{a^{2}}{2}\\right) du = \\frac{a^{2}}{2} \\int_{0}^{1} (1 - 2u + u^{2}) du$$\n$$\\frac{a^{2}}{2} \\left[ u - u^{2} + \\frac{u^{3}}{3} \\right]_{0}^{1} = \\frac{a^{2}}{2} \\left( (1 - 1 + \\frac{1}{3}) - 0 \\right) = \\frac{a^{2}}{6}$$\nSubstituting this result back into the expression for $S_{n}$, we obtain the final analytical expression for the total neutron production rate:\n$$S_{n} = \\pi^{2} R n_{0}^{2} \\langle \\sigma v \\rangle \\left(\\frac{a^{2}}{6}\\right) = \\frac{\\pi^{2} R a^{2} n_{0}^{2} \\langle \\sigma v \\rangle}{6}$$\nThe Monte Carlo normalization factor $w$ is defined by the relation $S_{n} = w N_{s}$. Thus,\n$$w = \\frac{S_{n}}{N_{s}} = \\frac{\\pi^{2} R a^{2} n_{0}^{2} \\langle \\sigma v \\rangle}{6 N_{s}}$$\nNow we substitute the given numerical values:\n- $R = 6.2\\,\\text{m}$\n- $a = 2.0\\,\\text{m}$\n- $n_{0} = 1.0 \\times 10^{20}\\,\\text{m}^{-3}$\n- $\\langle \\sigma v \\rangle = 1.1 \\times 10^{-22}\\,\\text{m}^{3}\\,\\text{s}^{-1}$\n- $N_{s} = 5.0 \\times 10^{6}$\n\n$$w = \\frac{\\pi^{2} (6.2) (2.0)^{2} (1.0 \\times 10^{20})^{2} (1.1 \\times 10^{-22})}{6 (5.0 \\times 10^{6})}$$\n$$w = \\frac{\\pi^{2} (6.2) (4.0) (1.0 \\times 10^{40}) (1.1 \\times 10^{-22})}{30.0 \\times 10^{6}}$$\n$$w = \\frac{\\pi^{2} (24.8) (1.1 \\times 10^{18})}{3.0 \\times 10^{7}}$$\n$$w = \\frac{\\pi^{2} (27.28) \\times 10^{18}}{3.0 \\times 10^{7}}$$\n$$w = \\frac{27.28 \\pi^{2}}{3.0} \\times 10^{11} \\approx 9.09333... \\times \\pi^{2} \\times 10^{11}$$\nUsing $\\pi^{2} \\approx 9.8696044$:\n$$w \\approx 9.09333... \\times 9.8696044 \\times 10^{11} \\approx 89.7488... \\times 10^{11}$$\n$$w \\approx 8.97488 \\times 10^{12}$$\nRounding the result to four significant figures, we get:\n$$w \\approx 8.975 \\times 10^{12} \\text{ neutrons per source history}$$",
            "answer": "$$\n\\boxed{8.975 \\times 10^{12}}\n$$"
        },
        {
            "introduction": "Once a source neutron is initialized, its life is tracked through the system. A core computational task in this process is determining the particle's path length to the nearest geometric boundary. This \"ray-tracing\" or \"geometry tracking\" is fundamental to all particle transport codes, dictating how particles navigate the complex components of a fusion reactor. This hands-on coding problem challenges you to build a ray-tracing algorithm from first principles, deriving and implementing the analytical formulas for the intersection of a line with simple geometric primitives that are the building blocks of complex models.",
            "id": "4016015",
            "problem": "In computational fusion science and engineering, geometry tracking is a core component of Monte Carlo (MC) neutronics. A neutron free-flights along a straight path until either a collision occurs or a surface is reached. The surface reach condition must be determined by solving for the nonnegative distance along the current direction to the nearest boundary. The objective of this problem is to derive from first principles a ray-tracing algorithm that returns the shortest nonnegative distance to the nearest surface along a given direction using analytic intersection rules for planes, cylinders, and spheres, and then implement this algorithm as a complete, runnable program.\n\nStart from the fundamental geometrical description of a straight-line trajectory, which is the parametric ray equation $\\mathbf{r}(t) = \\mathbf{r}_0 + t \\,\\mathbf{\\Omega}$ for $t \\ge 0$, where $\\mathbf{r}_0 \\in \\mathbb{R}^3$ is the current neutron position and $\\mathbf{\\Omega} \\in \\mathbb{R}^3$ is the direction vector. Use the following foundational facts:\n\n- A plane can be defined by a point $\\mathbf{p}_0$ and a unit normal $\\mathbf{n}$ through the condition $\\mathbf{n} \\cdot (\\mathbf{r} - \\mathbf{p}_0) = 0$.\n- A sphere can be defined by its center $\\mathbf{c}$ and radius $R$ through the condition $\\|\\mathbf{r} - \\mathbf{c}\\|^2 = R^2$.\n- A right circular cylinder aligned with the Cartesian $z$ axis can be defined by its radius $R$ and axial bounds $z_{\\min}$ and $z_{\\max}$. Its lateral surface satisfies $x^2 + y^2 = R^2$ and its endcaps are planes $z = z_{\\min}$ and $z = z_{\\max}$, with radial condition $x^2 + y^2 \\le R^2$ on the caps.\n\nYour task is:\n\n- Derive, from the above base definitions and the ray equation, analytic intersection conditions that yield the distance $t$ to the nearest surface along $\\mathbf{\\Omega}$ for each primitive shape (plane, sphere, and finite cylinder including both lateral surface and endcaps). Do not provide, use, or assume any shortcut formulas that are not derived from these base relations.\n- Carefully address parallel or tangent configurations and the selection of the smallest nonnegative solution for $t$.\n- Implement a program that, given a fixed set of tokamak-inspired components approximated by one plane, one finite cylinder, and one sphere, and a test suite of rays, computes the minimum nonnegative intersection distance for each ray across all surfaces. If there is no intersection for $t \\ge 0$, return $+\\infty$.\n\nUse the following geometry set, which is a simplified but scientifically plausible abstraction of tokamak components:\n\n- Plane (approximating a blanket module face): defined by $\\mathbf{p}_0 = (3.0, 0.0, 0.0)$ in meters and unit normal $\\mathbf{n} = (1.0, 0.0, 0.0)$.\n- Finite right circular cylinder (approximating the central solenoid): radius $R = 1.0$ meters, axial bounds $z_{\\min} = -2.0$ meters and $z_{\\max} = 2.0$ meters, axis aligned with the Cartesian $z$ axis.\n- Sphere (approximating a diagnostic housing): center $\\mathbf{c} = (2.0, 0.0, 0.5)$ in meters and radius $R = 0.5$ meters.\n\nConstruct the program to evaluate the following test suite of rays, where each ray is specified by its origin $\\mathbf{r}_0$ and direction $\\mathbf{\\Omega}$:\n\n- Test case $1$: $\\mathbf{r}_0 = (0.0, -2.0, 0.0)$ meters, $\\mathbf{\\Omega} = (0.0, 1.0, 0.0)$.\n- Test case $2$: $\\mathbf{r}_0 = (0.0, 0.0, 5.0)$ meters, $\\mathbf{\\Omega} = (1.0, 0.0, 0.0)$.\n- Test case $3$: $\\mathbf{r}_0 = (0.0, 0.0, 5.0)$ meters, $\\mathbf{\\Omega} = (0.0, 1.0, 0.0)$.\n- Test case $4$: $\\mathbf{r}_0 = (2.0, 0.0, 0.25)$ meters, $\\mathbf{\\Omega} = (0.0, 0.0, 1.0)$.\n- Test case $5$: $\\mathbf{r}_0 = (0.5, 0.0, 3.0)$ meters, $\\mathbf{\\Omega} = (0.0, 0.0, -1.0)$.\n- Test case $6$: $\\mathbf{r}_0 = (1.0, -0.5, 0.0)$ meters, $\\mathbf{\\Omega} = (0.0, 1.0, 0.0)$.\n\nScientific realism and numerical robustness requirements:\n\n- Treat $\\mathbf{\\Omega}$ as a direction and normalize it before intersection computations.\n- Use a small numerical tolerance $\\varepsilon$ to detect parallel or tangent configurations and to avoid spurious intersections due to roundoff. If a denominator magnitude is less than $\\varepsilon$, treat the configuration as parallel with no intersection on that surface.\n- Consider only $t \\ge 0$ solutions. If multiple surfaces are intersected, return the smallest nonnegative $t$ across all surfaces. If no surface yields a valid intersection, return $+\\infty$.\n\nUnits and output specification:\n\n- Express all distances in meters and round to six decimal places.\n- Your program should produce a single line of output containing the results for the six test cases as a comma-separated list enclosed in square brackets, for example $[d_1,d_2,\\dots,d_6]$, where each $d_i$ is either a float rounded to six decimal places (in meters) or $+\\infty$ represented as the string $inf$.\n\nDesign for coverage:\n\n- The test suite includes a general case hitting a cylinder lateral surface, a case hitting only the plane, a case with no intersection, a case starting inside the sphere and exiting through the far side, a case hitting a cylinder endcap, and a near-tangent case to the cylinder lateral surface. These ensure coverage of happy path and edge conditions.\n\nYour final answer must be a complete, runnable program following the execution environment and output requirements described elsewhere.",
            "solution": "The goal is to compute, for each ray defined by $\\mathbf{r}(t) = \\mathbf{r}_0 + t \\,\\mathbf{\\Omega}$ with $t \\ge 0$, the smallest nonnegative distance $t$ to any surface in a set composed of one plane, one finite cylinder, and one sphere. This directly supports Monte Carlo (MC) neutronics tracking, where the next event distance is the minimum between the sampled collision distance and the geometry boundary distance. The derivation proceeds from the base definitions of each surface.\n\nFirst, ensure that the direction $\\mathbf{\\Omega}$ is normalized to unit length to preserve physical meaning of the parameter $t$ as a geometric distance. Let $\\widehat{\\mathbf{\\Omega}} = \\mathbf{\\Omega} / \\|\\mathbf{\\Omega}\\|$.\n\nPlane intersection. A plane is defined by the set of points $\\mathbf{r}$ satisfying $\\mathbf{n} \\cdot (\\mathbf{r} - \\mathbf{p}_0) = 0$. Substituting the ray yields\n$$\n\\mathbf{n} \\cdot (\\mathbf{r}_0 + t \\,\\widehat{\\mathbf{\\Omega}} - \\mathbf{p}_0) = 0 \\,,\n$$\nwhich rearranges to\n$$\nt \\,\\big(\\mathbf{n} \\cdot \\widehat{\\mathbf{\\Omega}}\\big) = \\mathbf{n} \\cdot (\\mathbf{p}_0 - \\mathbf{r}_0) \\,.\n$$\nIf $\\big|\\mathbf{n} \\cdot \\widehat{\\mathbf{\\Omega}}\\big| < \\varepsilon$, the ray is parallel to the plane and there is no intersection at finite $t$. Otherwise,\n$$\nt_{\\text{plane}} = \\frac{\\mathbf{n} \\cdot (\\mathbf{p}_0 - \\mathbf{r}_0)}{\\mathbf{n} \\cdot \\widehat{\\mathbf{\\Omega}}} \\,.\n$$\nWe accept the intersection if $t_{\\text{plane}} \\ge 0$.\n\nSphere intersection. A sphere is the set of points satisfying $\\|\\mathbf{r} - \\mathbf{c}\\|^2 = R^2$. Substituting the ray gives\n$$\n\\|\\mathbf{r}_0 + t \\,\\widehat{\\mathbf{\\Omega}} - \\mathbf{c}\\|^2 = R^2 \\,.\n$$\nDefine $\\mathbf{d} = \\mathbf{r}_0 - \\mathbf{c}$. Expanding the square yields the scalar quadratic equation\n$$\na \\, t^2 + b \\, t + c = 0 \\,,\n$$\nwith\n$$\na = \\widehat{\\mathbf{\\Omega}} \\cdot \\widehat{\\mathbf{\\Omega}} = 1 \\,, \\quad\nb = 2 \\,\\widehat{\\mathbf{\\Omega}} \\cdot \\mathbf{d} \\,, \\quad\nc = \\mathbf{d} \\cdot \\mathbf{d} - R^2 \\,.\n$$\nCompute the discriminant\n$$\n\\Delta = b^2 - 4 a c \\,.\n$$\nIf $\\Delta < 0$, no real intersection exists. If $\\Delta \\ge 0$, the roots are\n$$\nt_{1,2} = \\frac{-b \\pm \\sqrt{\\Delta}}{2 a} \\,.\n$$\nAmong $\\{t_1, t_2\\}$ select the smallest $t \\ge 0$. This logic covers starting outside, starting inside, and tangent cases ($\\Delta = 0$). If both roots are negative, there is no intersection for $t \\ge 0$.\n\nFinite cylinder intersection (axis-aligned with the Cartesian $z$ axis). The lateral surface satisfies $x^2 + y^2 = R^2$ and the endcaps satisfy $z = z_{\\min}$ or $z = z_{\\max}$ with $x^2 + y^2 \\le R^2$. Parameterize the ray components as\n$$\nx(t) = x_0 + t \\, \\widehat{\\Omega}_x \\,, \\quad y(t) = y_0 + t \\, \\widehat{\\Omega}_y \\,, \\quad z(t) = z_0 + t \\, \\widehat{\\Omega}_z \\,.\n$$\nLateral surface. Solve\n$$\n\\big(x_0 + t \\, \\widehat{\\Omega}_x\\big)^2 + \\big(y_0 + t \\, \\widehat{\\Omega}_y\\big)^2 = R^2 \\,,\n$$\nwhich expands to a scalar quadratic\n$$\na_{\\ell} \\, t^2 + b_{\\ell} \\, t + c_{\\ell} = 0 \\,,\n$$\nwhere\n$$\na_{\\ell} = \\widehat{\\Omega}_x^2 + \\widehat{\\Omega}_y^2 \\,, \\quad\nb_{\\ell} = 2 \\,(x_0 \\widehat{\\Omega}_x + y_0 \\widehat{\\Omega}_y) \\,, \\quad\nc_{\\ell} = x_0^2 + y_0^2 - R^2 \\,.\n$$\nIf $a_{\\ell} < \\varepsilon$, the ray is parallel to the cylinder axis and cannot intersect the lateral surface. Otherwise compute $\\Delta_{\\ell} = b_{\\ell}^2 - 4 a_{\\ell} c_{\\ell}$. If $\\Delta_{\\ell} < 0$, there is no lateral intersection. If $\\Delta_{\\ell} \\ge 0$, compute the nonnegative roots and select the smallest $t \\ge 0$ that also satisfies the axial bound $z_{\\min} \\le z(t) \\le z_{\\max}$.\n\nEndcaps. For each cap plane $z = z_{\\min}$ and $z = z_{\\max}$, solve\n$$\nt_{\\text{cap}} = \\frac{z_{\\text{cap}} - z_0}{\\widehat{\\Omega}_z} \\,,\n$$\nprovided $\\big|\\widehat{\\Omega}_z\\big| \\ge \\varepsilon$ and $t_{\\text{cap}} \\ge 0$. At $t_{\\text{cap}}$, the radial condition must be satisfied:\n$$\n\\big(x_0 + t_{\\text{cap}} \\, \\widehat{\\Omega}_x\\big)^2 + \\big(y_0 + t_{\\text{cap}} \\, \\widehat{\\Omega}_y\\big)^2 \\le R^2 \\,.\n$$\nAmong all valid lateral and cap intersections, select the smallest $t \\ge 0$.\n\nGlobal selection. For a given ray and the geometry set, compute the valid $t$ for each surface (plane, cylinder, sphere) following the rules above and return\n$$\nt_{\\min} = \\min \\{ t_{\\text{plane}}, t_{\\text{cyl}}, t_{\\text{sph}} \\}\n$$\nover those that are valid and finite. If no surface yields a valid intersection, return $+\\infty$.\n\nNumerical robustness. Use a small tolerance $\\varepsilon$ (for example, $\\varepsilon = 10^{-12}$) to detect effective parallelism and to clamp the discriminants to zero if they are within tolerance of zero but slightly negative due to roundoff. Only accept intersections with $t \\ge 0$.\n\nApplying the derived formulas to the specified test suite and geometry:\n\n- Test case $1$ from $\\mathbf{r}_0 = (0.0, -2.0, 0.0)$ with $\\mathbf{\\Omega} = (0.0, 1.0, 0.0)$ hits the cylinder lateral surface at $t = 1.000000$ meters.\n- Test case $2$ from $\\mathbf{r}_0 = (0.0, 0.0, 5.0)$ with $\\mathbf{\\Omega} = (1.0, 0.0, 0.0)$ intersects only the plane at $t = 3.000000$ meters.\n- Test case $3$ from $\\mathbf{r}_0 = (0.0, 0.0, 5.0)$ with $\\mathbf{\\Omega} = (0.0, 1.0, 0.0)$ has no intersection with any surface, yielding $+\\infty$.\n- Test case $4$ from $\\mathbf{r}_0 = (2.0, 0.0, 0.25)$ with $\\mathbf{\\Omega} = (0.0, 0.0, 1.0)$ starts inside the sphere and exits at $t = 0.750000$ meters.\n- Test case $5$ from $\\mathbf{r}_0 = (0.5, 0.0, 3.0)$ with $\\mathbf{\\Omega} = (0.0, 0.0, -1.0)$ hits the cylinder top endcap at $t = 1.000000$ meters.\n- Test case $6$ from $\\mathbf{r}_0 = (1.0, -0.5, 0.0)$ with $\\mathbf{\\Omega} = (0.0, 1.0, 0.0)$ is tangent to the cylinder lateral surface and intersects at $t = 0.500000$ meters (discriminant equals zero).\n\nThe program implements these computations exactly, normalizes $\\mathbf{\\Omega}$, uses $\\varepsilon$ to handle degeneracies, and formats the output as a single line list of distances in meters rounded to six decimal places, with $+\\infty$ printed as $inf$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nEPS = 1e-12\n\ndef normalize(v):\n    norm = np.linalg.norm(v)\n    if norm < EPS:\n        raise ValueError(\"Direction vector has near-zero magnitude.\")\n    return v / norm\n\nclass Plane:\n    def __init__(self, p0, n):\n        self.p0 = np.array(p0, dtype=float)\n        n = np.array(n, dtype=float)\n        n_norm = np.linalg.norm(n)\n        if n_norm < EPS:\n            raise ValueError(\"Plane normal has near-zero magnitude.\")\n        self.n = n / n_norm\n\n    def intersect_distance(self, r0, omega):\n        # Solve n·(r0 + t*omega - p0) = 0 => t = n·(p0 - r0) / (n·omega)\n        denom = np.dot(self.n, omega)\n        if abs(denom) < EPS:\n            return float('inf')\n        t = np.dot(self.n, (self.p0 - r0)) / denom\n        if t >= 0.0:\n            return t\n        return float('inf')\n\nclass Sphere:\n    def __init__(self, c, R):\n        self.c = np.array(c, dtype=float)\n        self.R = float(R)\n\n    def intersect_distance(self, r0, omega):\n        # Solve ||r0 + t*omega - c||^2 = R^2\n        d = r0 - self.c\n        a = np.dot(omega, omega)  # should be 1 if omega normalized\n        b = 2.0 * np.dot(omega, d)\n        c = np.dot(d, d) - self.R * self.R\n        # Discriminant\n        disc = b*b - 4.0*a*c\n        # Numerical guard\n        if disc < 0.0 and disc > -EPS:\n            disc = 0.0\n        if disc < 0.0:\n            return float('inf')\n        sqrt_disc = np.sqrt(disc)\n        t1 = (-b - sqrt_disc) / (2.0*a)\n        t2 = (-b + sqrt_disc) / (2.0*a)\n        candidates = [t for t in (t1, t2) if t >= 0.0]\n        if not candidates:\n            return float('inf')\n        return min(candidates)\n\nclass FiniteCylinderZ:\n    def __init__(self, R, zmin, zmax):\n        self.R = float(R)\n        self.zmin = float(zmin)\n        self.zmax = float(zmax)\n\n    def intersect_distance(self, r0, omega):\n        x0, y0, z0 = r0\n        vx, vy, vz = omega\n        # Lateral surface: (x0 + vx t)^2 + (y0 + vy t)^2 = R^2\n        a = vx*vx + vy*vy\n        b = 2.0 * (x0*vx + y0*vy)\n        c = x0*x0 + y0*y0 - self.R*self.R\n        t_lateral = float('inf')\n        if a >= EPS:\n            disc = b*b - 4.0*a*c\n            if disc < 0.0 and disc > -EPS:\n                disc = 0.0\n            if disc >= 0.0:\n                sqrt_disc = np.sqrt(disc)\n                t1 = (-b - sqrt_disc) / (2.0*a)\n                t2 = (-b + sqrt_disc) / (2.0*a)\n                # choose smallest nonnegative t with z within [zmin, zmax]\n                for t in sorted([t1, t2]):\n                    if t >= 0.0:\n                        zt = z0 + vz * t\n                        if self.zmin - EPS <= zt <= self.zmax + EPS:\n                            t_lateral = t\n                            break\n        # Endcaps: z = zmin and z = zmax with radial <= R\n        t_caps = []\n        if abs(vz) >= EPS:\n            for zcap in (self.zmin, self.zmax):\n                tcap = (zcap - z0) / vz\n                if tcap >= 0.0:\n                    xcap = x0 + vx * tcap\n                    ycap = y0 + vy * tcap\n                    if xcap*xcap + ycap*ycap <= self.R*self.R + EPS:\n                        t_caps.append(tcap)\n        t_cap = min(t_caps) if t_caps else float('inf')\n        return min(t_lateral, t_cap)\n\ndef compute_min_distance(r0, omega, surfaces):\n    omega_hat = normalize(omega)\n    distances = []\n    for s in surfaces:\n        distances.append(s.intersect_distance(r0, omega_hat))\n    finite_dists = [d for d in distances if np.isfinite(d)]\n    if not finite_dists:\n        return float('inf')\n    return min(finite_dists)\n\ndef solve():\n    # Define geometry surfaces (tokamak-inspired primitives)\n    plane = Plane(p0=(3.0, 0.0, 0.0), n=(1.0, 0.0, 0.0))\n    cylinder = FiniteCylinderZ(R=1.0, zmin=-2.0, zmax=2.0)\n    sphere = Sphere(c=(2.0, 0.0, 0.5), R=0.5)\n    surfaces = [plane, cylinder, sphere]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([0.0, -2.0, 0.0]), np.array([0.0, 1.0, 0.0])),  # 1: cylinder lateral\n        (np.array([0.0, 0.0, 5.0]), np.array([1.0, 0.0, 0.0])),   # 2: plane only\n        (np.array([0.0, 0.0, 5.0]), np.array([0.0, 1.0, 0.0])),   # 3: no intersections\n        (np.array([2.0, 0.0, 0.25]), np.array([0.0, 0.0, 1.0])),  # 4: inside sphere\n        (np.array([0.5, 0.0, 3.0]), np.array([0.0, 0.0, -1.0])),  # 5: cylinder cap\n        (np.array([1.0, -0.5, 0.0]), np.array([0.0, 1.0, 0.0])),  # 6: cylinder tangent\n    ]\n\n    results = []\n    for r0, omega in test_cases:\n        d = compute_min_distance(r0, omega, surfaces)\n        if np.isfinite(d):\n            results.append(f\"{d:.6f}\")\n        else:\n            results.append(\"inf\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "The final step of any simulation is interpreting the output to produce a meaningful result. A simple average of the tally scores is not enough; a statistically sound confidence interval is required to quantify the uncertainty of the estimate. This task is complicated by the fact that variance reduction techniques, which are essential for efficiency in deep penetration problems, often introduce serial correlation between particle histories, violating the assumption of independence. This practice problem demonstrates how to use the method of batch means to mitigate the effects of autocorrelation and correctly apply the Student's $t$-distribution to construct a reliable confidence interval from a finite sample of simulation data.",
            "id": "4016034",
            "problem": "A fixed-source continuous-energy Monte Carlo neutron transport simulation is performed for a deuterium–tritium fusion blanket segment to estimate the $^{6}\\mathrm{Li}(n,t)$ reaction rate per source neutron in a localized breeding zone. The transport uses variance reduction via adaptive weight windows that are updated after each contiguous block of histories, which induces temporal correlation within blocks but reduces correlation between blocks. To address autocorrelation in the raw per-history tallies, the analyst applies the batch means method: $N_{\\mathrm{hist}} = 120{,}000$ source neutron histories are partitioned into $n = 12$ contiguous, non-overlapping batches of equal length $b = 10{,}000$ histories per batch. An independent preliminary diagnostic on an earlier, longer run estimated the integrated autocorrelation time of the raw per-history reaction rate tallies to be $\\tau_{\\mathrm{int}} \\approx 35$ histories. Assume stationarity of the tally process and that $b \\gg \\tau_{\\mathrm{int}}$ is sufficient for batch means to be approximately independent and identically distributed and approximately Gaussian by a central limit theorem for Markov chains.\n\nThe $n = 12$ batch-mean reaction rate tallies (in reactions per source neutron) are:\n$0.0123$, $0.0128$, $0.0131$, $0.0119$, $0.0126$, $0.0124$, $0.0133$, $0.0127$, $0.0122$, $0.0130$, $0.0125$, $0.0129$.\n\nUsing only these batch means and first principles appropriate to Monte Carlo neutronics and statistical estimation, perform the following:\n\n1. Starting from the definition of a Monte Carlo estimator for an expectation, explain why autocorrelation in the raw per-history tallies affects uncertainty quantification and why batching can mitigate this effect under the stated conditions.\n2. Justify the use of the Student’s $t$ distribution for constructing a two-sided $95\\%$ confidence interval when the true variance is unknown and the sample size $n$ is finite.\n3. Compute the two-sided $95\\%$ confidence interval for the mean reaction rate based on the $n = 12$ batch means.\n\nRound the two interval endpoints to four significant figures. Express your final interval in reactions per source neutron. Provide only the numerical values of the interval endpoints in your final answer.",
            "solution": "The reaction rate tally of interest can be written as an expectation with respect to the stochastic transport process. Let $X$ denote the random tally contribution per source neutron history to the $^{6}\\mathrm{Li}(n,t)$ reaction rate in the region of interest. The target is the mean $\\mu = \\mathbb{E}[X]$, expressed in reactions per source neutron. A canonical Monte Carlo estimator for $\\mu$ based on $N$ histories is the sample mean,\n$$\n\\hat{\\mu}_N = \\frac{1}{N} \\sum_{i=1}^{N} X_i,\n$$\nwhere $\\{X_i\\}$ are the per-history tally contributions produced by the simulation.\n\nIn ideal independent and identically distributed sampling, the variance of $\\hat{\\mu}_N$ would be $\\mathrm{Var}(\\hat{\\mu}_N) = \\sigma^{2}/N$, where $\\sigma^{2} = \\mathrm{Var}(X)$. However, in transport simulations with adaptive variance reduction, histories are processed in a sequence where control parameters (e.g., weight windows) are updated between blocks. Within a block, the random number streams and splitting/roulette decisions can induce temporal correlation among $\\{X_i\\}$, so they are not strictly independent. Autocorrelation inflates the variance of the naive sample mean beyond $\\sigma^{2}/N$ by a factor involving the integrated autocorrelation time,\n$$\n\\tau_{\\mathrm{int}} = \\frac{1}{2} + \\sum_{k=1}^{\\infty} \\rho(k),\n$$\nwhere $\\rho(k)$ are the lag-$k$ autocorrelations of the stationary process $\\{X_i\\}$. The effective sample size $N_{\\mathrm{eff}} \\approx N / (2 \\tau_{\\mathrm{int}})$ becomes smaller than $N$, increasing the estimator uncertainty.\n\nBatch means mitigate this effect by aggregating contiguous histories into batches of length $b$. Define batch means\n$$\n\\bar{X}_j = \\frac{1}{b} \\sum_{i=(j-1)b+1}^{jb} X_i, \\quad j=1,\\dots,n,\n$$\nwith $N = nb$. Under stationarity and for batch length $b$ large compared to $\\tau_{\\mathrm{int}}$, standard central limit theorems for Markov chains imply that each $\\bar{X}_j$ is approximately Gaussian, and the dependence between batches decays so that $\\{\\bar{X}_j\\}_{j=1}^{n}$ are approximately independent and identically distributed with mean $\\mu$ and variance $\\sigma_{\\bar{X}}^{2} \\approx \\sigma^{2}_{\\mathrm{BM}}/b$ for some finite $\\sigma^{2}_{\\mathrm{BM}}$. With $\\tau_{\\mathrm{int}} \\approx 35$ histories and $b = 10{,}000$, the ratio $b/\\tau_{\\mathrm{int}} \\approx 285.7$ is large, supporting the approximation that the batch means are nearly independent and Gaussian.\n\nWhen the true variance of the batch mean population, $\\sigma_{\\bar{X}}^{2}$, is unknown and only a finite number $n$ of batch means are available, inference for the mean based on the sample standard deviation requires Student’s $t$ distribution rather than a normal distribution. Specifically, if $\\bar{X}_1,\\dots,\\bar{X}_n$ are approximately independent and Gaussian with mean $\\mu$ and variance $\\sigma_{\\bar{X}}^{2}$, then the standardized statistic\n$$\nT = \\frac{\\bar{\\bar{X}} - \\mu}{S_{\\bar{X}}/\\sqrt{n}},\n$$\nfollows a Student’s $t$ distribution with $n-1$ degrees of freedom, where\n$$\n\\bar{\\bar{X}} = \\frac{1}{n} \\sum_{j=1}^{n} \\bar{X}_j, \\quad\nS_{\\bar{X}}^{2} = \\frac{1}{n-1} \\sum_{j=1}^{n} \\left(\\bar{X}_j - \\bar{\\bar{X}}\\right)^{2}.\n$$\nThis result holds exactly when the batch means are independent and Gaussian and remains a good approximation under mild departures, such as weak residual correlation. Therefore, a two-sided confidence interval for $\\mu$ at confidence level $1-\\alpha$ is\n$$\n\\left[ \\bar{\\bar{X}} - t_{1-\\alpha/2,\\;n-1} \\frac{S_{\\bar{X}}}{\\sqrt{n}}, \\;\\; \\bar{\\bar{X}} + t_{1-\\alpha/2,\\;n-1} \\frac{S_{\\bar{X}}}{\\sqrt{n}} \\right],\n$$\nwhere $t_{1-\\alpha/2,\\;n-1}$ is the $(1-\\alpha/2)$ quantile of the Student’s $t$ distribution with $n-1$ degrees of freedom. For a $95\\%$ confidence interval, $\\alpha = 0.05$.\n\nWe now compute the interval using the provided $n=12$ batch means:\n$$\n\\{\\bar{X}_j\\} = \\{0.0123,\\, 0.0128,\\, 0.0131,\\, 0.0119,\\, 0.0126,\\, 0.0124,\\, 0.0133,\\, 0.0127,\\, 0.0122,\\, 0.0130,\\, 0.0125,\\, 0.0129\\}.\n$$\nFirst compute the sample mean:\n$$\n\\bar{\\bar{X}} = \\frac{1}{12} \\sum_{j=1}^{12} \\bar{X}_j = \\frac{0.1517}{12} = 0.012641666\\ldots\n$$\nNext compute the sample variance:\n$$\nS_{\\bar{X}}^{2} = \\frac{1}{11} \\sum_{j=1}^{12} \\left(\\bar{X}_j - \\bar{\\bar{X}}\\right)^{2} \\approx 1.64487 \\times 10^{-7},\n$$\nso the sample standard deviation is\n$$\nS_{\\bar{X}} \\approx \\sqrt{1.64487 \\times 10^{-7}} \\approx 4.05569 \\times 10^{-4}.\n$$\nThe standard error of the mean based on batch means is\n$$\n\\frac{S_{\\bar{X}}}{\\sqrt{n}} \\approx \\frac{4.05569 \\times 10^{-4}}{\\sqrt{12}} \\approx 1.17100 \\times 10^{-4}.\n$$\nFor $n-1 = 11$ degrees of freedom, the two-sided $95\\%$ quantile is $t_{0.975,\\,11} \\approx 2.201$. The margin of error is then\n$$\n\\Delta = t_{0.975,\\,11} \\cdot \\frac{S_{\\bar{X}}}{\\sqrt{n}} \\approx 2.201 \\times 1.17100 \\times 10^{-4} \\approx 2.5774 \\times 10^{-4}.\n$$\nTherefore, the $95\\%$ confidence interval endpoints are\n$$\n\\text{Lower} = \\bar{\\bar{X}} - \\Delta \\approx 0.0126416667 - 0.0002577374 \\approx 0.0123839293,\n$$\n$$\n\\text{Upper} = \\bar{\\bar{X}} + \\Delta \\approx 0.0126416667 + 0.0002577374 \\approx 0.0128994041.\n$$\nRounding each endpoint to four significant figures yields $0.01238$ and $0.01290$. These values are expressed in reactions per source neutron, consistent with the tally definition and units.",
            "answer": "$$\\boxed{\\begin{pmatrix}0.01238 & 0.01290\\end{pmatrix}}$$"
        }
    ]
}