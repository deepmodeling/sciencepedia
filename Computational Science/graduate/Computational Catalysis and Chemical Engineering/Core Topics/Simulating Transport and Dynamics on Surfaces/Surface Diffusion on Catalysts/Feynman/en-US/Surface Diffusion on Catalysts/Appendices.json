{
    "hands_on_practices": [
        {
            "introduction": "This first exercise goes back to the statistical mechanics roots of diffusion. By modeling an adatom's movement as a Continuous-Time Random Walk, you will derive the mean-square displacement from first principles. This practice is essential for building an intuition for how the macroscopic diffusion coefficient, $D$, emerges from the microscopic parameters of hop rate, $k$, and hop distance, $a$. ",
            "id": "3900863",
            "problem": "An adsorbed species performs unbiased surface diffusion on a square-lattice catalyst, represented as a Continuous-Time Random Walk (CTRW). The lattice spacing is $a$ and the process is isotropic with nearest-neighbor hops only. The total rate to leave a site is $k$, and each hop goes to one of the four nearest neighbors with equal probability. The adsorbate starts at the origin at time $t=0$.\n\nStarting from the definition of a continuous-time Markov process with exponential waiting times and independent, identically distributed steps, derive an analytical expression for the mean-square displacement $\\langle r^{2}(t)\\rangle$ as a function of $a$, $k$, and $t$. Then, using the foundational Fickian diffusion relation for two dimensions, show that the coarse-grained continuum diffusion coefficient $D$ implied by your result is consistent with $D = (a^{2} k)/4$.\n\nExpress the mean-square displacement in square meters, assuming $a$ is in meters and $t$ is in seconds. Provide a single closed-form analytic expression for $\\langle r^{2}(t)\\rangle$. No rounding is required.",
            "solution": "The problem statement is first validated against the required criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- The physical system is an adsorbed species diffusing on a square-lattice catalyst.\n- The process is modeled as an unbiased Continuous-Time Random Walk (CTRW).\n- The lattice spacing is denoted by $a$.\n- The diffusion is isotropic with hops restricted to the four nearest neighbors.\n- The total rate to leave any site is a constant, $k$.\n- The probability of hopping to any specific nearest neighbor is equal, which implies a probability of $1/4$ for each of the four possible directions.\n- The initial condition is that the adsorbate is at the origin at time $t=0$.\n- A target expression for the diffusion coefficient is provided for consistency checking: $D = (a^{2} k)/4$.\n- The foundational Fickian diffusion relation for two dimensions should be used.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is based on the standard CTRW model, a fundamental concept in statistical physics and chemical engineering for describing diffusion processes. All aspects are consistent with established scientific principles.\n- **Well-Posed:** The problem is well-posed. It provides a complete description of the stochastic process, including the geometry (square lattice), step length ($a$), and temporal dynamics (Poisson process with rate $k$). The objective, to derive the mean-square displacement (MSD) and verify a related expression for the diffusion coefficient, is clear and has a unique, derivable solution.\n- **Objective:** The problem is stated using precise, objective scientific language. Terms like \"unbiased,\" \"isotropic,\" and \"CTRW\" are standard and unambiguous in this context.\n- **Conclusion:** The problem does not exhibit any of the flaws listed in the validation criteria. It is scientifically sound, well-posed, objective, and formalizable.\n\n**Step 3: Verdict and Action**\n- The problem is deemed **valid**. A full solution will be provided.\n\n### Derivation of Mean-Square Displacement\n\nLet the position of the adsorbate at time $t$ be $\\vec{r}(t)$. The mean-square displacement (MSD) is defined as $\\langle r^{2}(t) \\rangle = \\langle |\\vec{r}(t)|^{2} \\rangle$. The process is a CTRW, where the total displacement is the sum of individual hop vectors. Let $N(t)$ be the number of hops that have occurred by time $t$. The displacement vector after $N(t)$ hops is $\\vec{r}(t) = \\sum_{i=1}^{N(t)} \\vec{s}_i$, where $\\vec{s}_i$ is the vector for the $i$-th hop.\n\nThe MSD at time $t$ is the expectation value of the squared magnitude of this displacement vector. We can compute this using iterated expectation, first averaging over the choice of steps for a fixed number of steps $n$, and then averaging over the distribution of the number of steps $N(t)$ at time $t$.\n\nLet's first calculate the MSD for a fixed number of steps, $n$.\n$$\n\\langle |\\vec{r}_{n}|^{2} \\rangle = \\left\\langle \\left( \\sum_{i=1}^{n} \\vec{s}_i \\right) \\cdot \\left( \\sum_{j=1}^{n} \\vec{s}_j \\right) \\right\\rangle = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\langle \\vec{s}_i \\cdot \\vec{s}_j \\rangle\n$$\nThis sum can be split into terms where $i=j$ and terms where $i \\neq j$.\n$$\n\\langle |\\vec{r}_{n}|^{2} \\rangle = \\sum_{i=1}^{n} \\langle |\\vec{s}_i|^{2} \\rangle + \\sum_{i \\neq j} \\langle \\vec{s}_i \\cdot \\vec{s}_j \\rangle\n$$\nThe hops are independent and identically distributed (i.i.d.). For $i \\neq j$, the vectors $\\vec{s}_i$ and $\\vec{s}_j$ are independent, so the expectation of their product is the product of their expectations: $\\langle \\vec{s}_i \\cdot \\vec{s}_j \\rangle = \\langle \\vec{s}_i \\rangle \\cdot \\langle \\vec{s}_j \\rangle$.\n\nThe walk is unbiased and isotropic on a square lattice. The possible hop vectors are $(a, 0)$, $(-a, 0)$, $(0, a)$, and $(0, -a)$. Each occurs with probability $p=1/4$. The average hop vector $\\langle \\vec{s} \\rangle$ is:\n$$\n\\langle \\vec{s} \\rangle = \\frac{1}{4} (a, 0) + \\frac{1}{4} (-a, 0) + \\frac{1}{4} (0, a) + \\frac{1}{4} (0, -a) = (0, 0)\n$$\nSince $\\langle \\vec{s} \\rangle = \\vec{0}$, all the cross terms ($i \\neq j$) vanish: $\\langle \\vec{s}_i \\cdot \\vec{s}_j \\rangle = \\vec{0} \\cdot \\vec{0} = 0$.\n\nThe MSD for $n$ steps simplifies to the sum of the diagonal terms:\n$$\n\\langle |\\vec{r}_{n}|^{2} \\rangle = \\sum_{i=1}^{n} \\langle |\\vec{s}_i|^{2} \\rangle\n$$\nFor any hop, the magnitude of the displacement is the lattice spacing $a$, so $|\\vec{s}_i|^{2} = a^{2}$. Since this is a constant value for every hop, its expectation is $\\langle |\\vec{s}_i|^{2} \\rangle = a^{2}$.\n$$\n\\langle |\\vec{r}_{n}|^{2} \\rangle = \\sum_{i=1}^{n} a^{2} = n a^{2}\n$$\nNow, we must relate the number of steps $n$ to the time $t$. The problem states that the total rate to leave a site is $k$. This describes a Poisson process for the hopping events. The waiting time between successive hops is exponentially distributed with mean $1/k$. For a time interval of duration $t$, the number of hops $N(t)$ follows a Poisson distribution with mean $\\langle N(t) \\rangle = k t$.\n\nThe MSD at time $t$ is the average of $\\langle |\\vec{r}_{N(t)}|^{2} \\rangle = N(t) a^{2}$ over the distribution of $N(t)$:\n$$\n\\langle r^{2}(t) \\rangle = \\langle N(t) a^{2} \\rangle = a^{2} \\langle N(t) \\rangle\n$$\nSubstituting the mean number of hops $\\langle N(t) \\rangle = k t$:\n$$\n\\langle r^{2}(t) \\rangle = a^{2} k t\n$$\nThis is the analytical expression for the mean-square displacement. If $a$ is in meters and $t$ is in seconds, the rate $k$ must have units of $s^{-1}$, and the resulting MSD $\\langle r^{2}(t) \\rangle$ will have units of $m^{2}$.\n\n### Consistency with Fickian Diffusion\n\nThe problem requires showing consistency with the provided diffusion coefficient using the Fickian diffusion relation. For a $d$-dimensional system, the large-time asymptotic behavior of the MSD is given by:\n$$\n\\langle r^{2}(t) \\rangle = 2d D t\n$$\nwhere $D$ is the diffusion coefficient. The problem describes diffusion on a square lattice, which is a two-dimensional ($d=2$) system. Therefore, the applicable Fickian relation is:\n$$\n\\langle r^{2}(t) \\rangle = 4 D t\n$$\nBy equating our derived expression for the MSD with the Fickian relation, we can extract the implied diffusion coefficient.\n$$\na^{2} k t = 4 D t\n$$\nFor $t > 0$, we can divide by $t$:\n$$\na^{2} k = 4 D\n$$\nSolving for $D$ gives:\n$$\nD = \\frac{a^{2} k}{4}\n$$\nThis result is identical to the expression $D = (a^{2} k)/4$ provided in the problem statement for verification. Thus, the derivation from the CTRW model is consistent with the macroscopic Fickian description of diffusion for this system. The final expression for the mean-square displacement is $\\langle r^{2}(t) \\rangle = a^{2} k t$.",
            "answer": "$$ \\boxed{a^{2} k t} $$"
        },
        {
            "introduction": "The rate of an individual diffusion hop is exponentially dependent on the activation energy barrier. But how do we find this barrier on a complex potential energy surface? This coding exercise guides you through implementing the Nudged Elastic Band (NEB) method, a cornerstone algorithm in computational catalysis, to find the minimum energy path and its saddle point between two adsorption sites. ",
            "id": "3900845",
            "problem": "You are asked to formalize and implement a discrete approximation of the minimum-energy path between two adsorption sites on a catalytic surface, following the conceptual framework of the Nudged Elastic Band (NEB) method. The sites are the Face-Centered Cubic (FCC) site and the Hexagonal Close-Packed (HCP) site on a (111) surface. The final program must compute the diffusion barrier, defined as the saddle point energy along the minimum-energy path, expressed in electronvolts. The construction must be rooted in first principles and core definitions.\n\nBegin from the following base principles and facts:\n- The minimum-energy path is a path in configuration space connecting two local minima along which the potential energy is minimized in directions orthogonal to the path. At the saddle point, the gradient of the potential energy vanishes and the Hessian has exactly one negative eigenvalue.\n- The potential energy surface for an adsorbate on a crystalline surface is a smooth function of position, and gradients of the potential energy drive relaxation of configurations via steepest descent.\n- A discrete path can be represented by a set of images connected by harmonic springs that enforce near-uniform parametrization but do not bias the path shape orthogonal to the path direction.\n\nUse the following smooth and physically plausible two-dimensional potential energy surface to represent a single-atom adsorbate diffusing between FCC and HCP sites along the crystallographic direction, with a confining curvature orthogonal to the path:\n$$\nV(x,y) \\;=\\; \\frac{16\\,E_b}{a^4}\\left[\\left(x - \\frac{a}{2}\\right)^2 - \\left(\\frac{a}{2}\\right)^2\\right]^2 \\;+\\; \\gamma\\,y^2,\n$$\nwhere $x$ and $y$ are Cartesian coordinates in angstroms, $a$ is the lattice parameter in angstroms, $E_b$ is a tunable barrier energy in electronvolts, and $\\gamma$ is a transverse curvature in electronvolts per square angstrom. The choice of prefactor guarantees that the barrier height along the line $y=0$ is $E_b$ at $x=a/2$, with minima at $x=0$ and $x=a$.\n\nDefine the endpoints for the path as the FCC site at $(x,y)=(0,0)$ and the HCP site at $(x,y)=(a,0)$, with $a>0$. The path is discretized into $N$ images including the fixed endpoints. The images are connected by harmonic springs with spring constant $k$ (in electronvolts per square angstrom). You must construct a mathematically sound discrete NEB formulation from first principles:\n- Define a discrete tangent $\\,\\mathbf{t}_i\\,$ at each interior image index $i$, based on neighboring images, such that it consistently approximates the path direction.\n- Decompose the physical force $-\\nabla V(\\mathbf{R}_i)$ at image $i$ into components parallel and perpendicular to the local tangent, and retain only the perpendicular component of the physical force.\n- Add the spring force component along the tangent to maintain near-uniform parameterization, without adding any perpendicular spring components that would bias the path.\n- Optionally, for improved identification of the saddle point, implement a climbing variant in which the highest-energy interior image ascends along the tangent and descends orthogonally to converge to the saddle.\n\nYour program must:\n- Initialize the images by linear interpolation between the endpoints.\n- Iteratively relax the interior images using the derived NEB forces until a fixed number of iterations is completed or a reasonable convergence threshold on the maximum force norm is met. Endpoints must remain fixed throughout.\n- Identify the barrier energy as the maximum potential energy along the converged discrete path excluding the endpoints; if the climbing variant is activated, use the energy of the climbing image as the barrier estimate.\n- Report the barrier energies for the specified test suite below.\n\nUnits and output specification:\n- Positions must be handled in angstroms. Energies must be in electronvolts. The final barrier energies must be reported in electronvolts.\n- The final program output must be a single line containing a comma-separated list enclosed in square brackets, where each entry is the barrier energy for one test case, expressed in electronvolts as a float rounded to six decimal places.\n\nTest suite and parameter coverage:\n- Use the potential $V(x,y)$ defined above with the specified parameters for each case. The images must include the endpoints $(0,0)$ and $(a,0)$.\n- For each case, the tuple is $(a, E_b, \\gamma, N, k, \\text{climb})$, where $a$ is in angstroms, $E_b$ is in electronvolts, $\\gamma$ is in electronvolts per square angstrom, $N$ is an integer greater than or equal to $3$, $k$ is in electronvolts per square angstrom, and $\\text{climb}$ is a boolean indicating whether the climbing variant is enabled.\n\nProvide and use the following test suite:\n- Case 1: ($a=2.5$, $E_b=0.12$, $\\gamma=1.0$, $N=9$, $k=5.0$, climb=True).\n- Case 2: ($a=2.5$, $E_b=0.12$, $\\gamma=0.5$, $N=7$, $k=0.1$, climb=True).\n- Case 3: ($a=2.5$, $E_b=0.05$, $\\gamma=1.0$, $N=5$, $k=3.0$, climb=False).\n- Case 4: ($a=2.5$, $E_b=0.20$, $\\gamma=1.5$, $N=11$, $k=10.0$, climb=True).\n- Case 5: ($a=2.5$, $E_b=0.12$, $\\gamma=2.0$, $N=3$, $k=1.0$, climb=True).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in electronvolts rounded to six decimal places, following the format:\n\"[result1,result2,result3,result4,result5]\".",
            "solution": "The problem statement has been validated and is deemed sound. It presents a well-posed, scientifically grounded problem in computational physics that is free of contradictions or ambiguities. The task is to implement the Nudged Elastic Band (NEB) method, a cornerstone algorithm for finding minimum-energy paths (MEPs) in chemical reactions and diffusion processes, for a specified two-dimensional potential energy surface (PES).\n\nWe begin by formalizing the discrete representation of the reaction path. The path is a sequence of configurations, or \"images,\" denoted by their coordinates $\\mathbf{R}_i = (x_i, y_i)$ for $i=0, 1, \\dots, N-1$. The total number of images is $N$. The endpoints, $\\mathbf{R}_0$ and $\\mathbf{R}_{N-1}$, are fixed at the initial and final states of the processâ€”in this case, the FCC site at $(0,0)$ and the HCP site at $(a,0)$, respectively. The $N-2$ intermediate images are movable.\n\nThe potential energy surface $V(\\mathbf{R})$ is given by:\n$$\nV(x,y) = \\frac{16\\,E_b}{a^4}\\left[\\left(x - \\frac{a}{2}\\right)^2 - \\left(\\frac{a}{2}\\right)^2\\right]^2 + \\gamma\\,y^2\n$$\nThe force on an image at position $\\mathbf{R}_i$ due to this potential is the negative gradient of the potential, $\\mathbf{F}_{phys,i} = -\\nabla V(\\mathbf{R}_i)$. The components of the gradient are:\n$$\n\\frac{\\partial V}{\\partial x} = \\frac{32\\,E_b}{a^4} (x^2 - ax)(2x - a) = \\frac{32\\,E_b}{a^4} x(x-a)(2x-a)\n$$\n$$\n\\frac{\\partial V}{\\partial y} = 2\\gamma y\n$$\nThe core idea of the NEB method is to construct a total force on each image that drives the chain of images towards the MEP. This force is a sum of two components: a modified physical force and a spring force. A naive approach of simply relaxing the images under the influence of $\\mathbf{F}_{phys,i}$ and a harmonic spring force $\\mathbf{F}_{spring,i} = k(\\mathbf{R}_{i+1} - 2\\mathbf{R}_i + \\mathbf{R}_{i-1})$ would cause the path to slide down into the energy minima and exhibit corner-cutting behavior.\n\nThe \"nudging\" in NEB corrects this. We want the physical force to act only perpendicular to the path, thus minimizing energy without affecting the position along the path. Conversely, we want the spring force to act only parallel to the path, ensuring even spacing of images without biasing the path's shape. This requires defining a local tangent vector $\\mathbf{t}_i$ at each image $i$. A robust choice for the tangent at an interior image $i$ is the normalized vector connecting its neighbors:\n$$\n\\mathbf{t}_i = \\frac{\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}}{\\|\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}\\|}\n$$\nThe component of the physical force perpendicular to the path is obtained by projecting out the parallel component:\n$$\n\\mathbf{F}_{phys,i}^{\\perp} = \\mathbf{F}_{phys,i} - (\\mathbf{F}_{phys,i} \\cdot \\mathbf{t}_i)\\mathbf{t}_i\n$$\nThe problem specifies a particular form for the parallel spring force component, designed to equalize the distances between adjacent images:\n$$\n\\mathbf{F}_{spring,i}^{\\parallel} = k(\\|\\mathbf{R}_{i+1} - \\mathbf{R}_i\\| - \\|\\mathbf{R}_i - \\mathbf{R}_{i-1}\\|) \\mathbf{t}_i\n$$\nThe total NEB force on a standard (non-climbing) interior image $i$ is the sum of these two projected forces:\n$$\n\\mathbf{F}_{NEB, i} = \\mathbf{F}_{phys,i}^{\\perp} + \\mathbf{F}_{spring,i}^{\\parallel}\n$$\nTo accurately locate the saddle point, the Climbing Image NEB (CI-NEB) variant is employed. The interior image with the highest potential energy, let its index be $i_{climb}$, is designated as the \"climbing\" image. This image is no longer subject to any spring forces. Furthermore, its component of the physical force parallel to the path is inverted. This drives the image \"uphill\" along the MEP towards the saddle point, while continuing to minimize its energy in perpendicular directions. The force on the climbing image is:\n$$\n\\mathbf{F}_{climb, i_{climb}} = \\mathbf{F}_{phys, i_{climb}} - 2(\\mathbf{F}_{phys, i_{climb}} \\cdot \\mathbf{t}_{i_{climb}})\\mathbf{t}_{i_{climb}} = \\mathbf{F}_{phys, i_{climb}}^{\\perp} - \\mathbf{F}_{phys, i_{climb}}^{\\parallel}\n$$\nThe algorithm proceeds as follows:\n$1$. Initialize the path by creating $N$ images via linear interpolation between the endpoints $\\mathbf{R}_0=(0,0)$ and $\\mathbf{R}_{N-1}=(a,0)$.\n$2$. Iteratively update the positions of the $N-2$ interior images. In each iteration:\n    a. Calculate the potential energy $V(\\mathbf{R}_i)$ for all images.\n    b. If the climbing variant is active, identify the interior image $i_{climb}$ with the maximum energy.\n    c. For each interior image $i \\in [1, N-2]$, calculate the tangent $\\mathbf{t}_i$ and the total force $\\mathbf{F}_i$ (either $\\mathbf{F}_{NEB, i}$ or $\\mathbf{F}_{climb, i}$).\n    d. Update the image positions using a simple steepest-descent optimization step: $\\mathbf{R}_i \\gets \\mathbf{R}_i + \\alpha \\mathbf{F}_i$, where $\\alpha$ is a small, constant learning rate.\n$3$. The loop terminates when the magnitude of the largest force on any interior image falls below a specified convergence threshold, or a maximum number of iterations is reached.\n$4$. Upon convergence, the diffusion barrier is determined. If CH-NEB was used, this is the potential energy of the climbing image, $V(\\mathbf{R}_{i_{climb}})$. Otherwise, it is the maximum potential energy among all relaxed interior images.\n\nThis procedure provides a robust and physically sound method for determining the minimum-energy path and its associated activation barrier, which is implemented in the following program.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the NEB calculations for the specified test suite\n    and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, E_b, gamma, N, k, climb)\n        (2.5, 0.12, 1.0, 9, 5.0, True),\n        (2.5, 0.12, 0.5, 7, 0.1, True),\n        (2.5, 0.05, 1.0, 5, 3.0, False),\n        (2.5, 0.20, 1.5, 11, 10.0, True),\n        (2.5, 0.12, 2.0, 3, 1.0, True),\n    ]\n\n    results = []\n    \n    # Optimization parameters\n    learning_rate = 0.01\n    num_iterations = 20000\n    force_threshold = 1e-6 # eV/Angstrom\n\n    for case in test_cases:\n        a, E_b, gamma, N, k, climb = case\n        barrier = run_neb(a, E_b, gamma, N, k, climb,\n                          learning_rate, num_iterations, force_threshold)\n        results.append(f\"{barrier:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef potential(coords, a, E_b, gamma):\n    \"\"\"\n    Calculates the potential energy V(x,y) for one or more coordinates.\n    coords is a NumPy array of shape (..., 2).\n    \"\"\"\n    x = coords[..., 0]\n    y = coords[..., 1]\n    \n    term_x = (16.0 * E_b / a**4) * ((x - a / 2.0)**2 - (a / 2.0)**2)**2\n    term_y = gamma * y**2\n    return term_x + term_y\n\ndef gradient(coords, a, E_b, gamma):\n    \"\"\"\n    Calculates the gradient of the potential energy nabla(V) at given coordinates.\n    coords is a NumPy array of shape (..., 2).\n    \"\"\"\n    x = coords[..., 0]\n    y = coords[..., 1]\n    \n    # dV/dx = (32*E_b/a**4) * x*(x-a)*(2*x-a)\n    dv_dx = (32.0 * E_b / a**4) * x * (x - a) * (2.0 * x - a)\n    dv_dy = 2.0 * gamma * y\n    \n    if coords.ndim > 1:\n        return np.stack((dv_dx, dv_dy), axis=-1)\n    else:\n        return np.array([dv_dx, dv_dy])\n\ndef compute_neb_forces(images, a, E_b, gamma, k, climb):\n    \"\"\"\n    Computes the NEB forces for all interior images.\n    \"\"\"\n    N = images.shape[0]\n    forces = np.zeros_like(images)\n    \n    # Calculate energies for all images to identify climbing image if needed\n    energies = potential(images, a, E_b, gamma)\n    \n    i_climb = -1\n    if climb and N > 2:\n        # The climbing image is the one with the highest energy (among interior images)\n        i_climb = np.argmax(energies[1:-1]) + 1\n        \n    for i in range(1, N - 1):\n        # Local tangent at image i using centered difference\n        tangent = images[i+1] - images[i-1]\n        tangent_norm = np.linalg.norm(tangent)\n        if tangent_norm > 1e-9:\n            tangent /= tangent_norm\n        else:\n            # Fallback for colocated neighbors, though unlikely in a real run.\n            tangent = np.array([1.0, 0.0])\n\n        # True force from the potential\n        F_phys = -gradient(images[i], a, E_b, gamma)\n\n        if i == i_climb:\n            # Climbing image force: invert parallel component of true force\n            F_phys_parallel_mag = np.dot(F_phys, tangent)\n            F_total = F_phys - 2.0 * F_phys_parallel_mag * tangent\n        else:\n            # Standard NEB image force\n            # Perpendicular component of the true force\n            F_phys_parallel_mag = np.dot(F_phys, tangent)\n            F_phys_perp = F_phys - F_phys_parallel_mag * tangent\n\n            # Spring force component along the tangent\n            len_next = np.linalg.norm(images[i+1] - images[i])\n            len_prev = np.linalg.norm(images[i] - images[i-1])\n            F_spring_parallel = k * (len_next - len_prev) * tangent\n            \n            F_total = F_phys_perp + F_spring_parallel\n            \n        forces[i] = F_total\n\n    return forces\n\ndef run_neb(a, E_b, gamma, N, k, climb, learning_rate, num_iterations, force_threshold):\n    \"\"\"\n    Performs the NEB calculation for a single test case.\n    \"\"\"\n    # 1. Initialize images by linear interpolation\n    images = np.zeros((N, 2))\n    images[:, 0] = np.linspace(0.0, a, N)\n\n    # 2. Optimization loop\n    for _ in range(num_iterations):\n        forces = compute_neb_forces(images, a, E_b, gamma, k, climb)\n        \n        # Check for convergence on the maximum force norm for any movable image\n        max_force_norm = 0.0\n        if N > 2:\n            max_force_norm = np.max(np.linalg.norm(forces[1:-1], axis=1))\n        \n        if max_force_norm  force_threshold:\n            break\n        \n        # 3. Update interior image positions using steepest descent\n        images[1:-1] += learning_rate * forces[1:-1]\n\n    # 4. Calculate final barrier energy\n    if N = 2:\n        return 0.0 # No barrier if there are no interior images\n        \n    final_energies = potential(images[1:-1], a, E_b, gamma)\n    barrier_energy = np.max(final_energies)\n\n    return barrier_energy\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "This final practice bridges the gap between theory and observable data by focusing on the Arrhenius relationship, $D(T) = D_0 \\exp(-E_a / k_B T)$. You will write a program to analyze synthetic diffusion data, extracting the activation energy $E_a$ and prefactor $D_0$ through linear regression. This exercise also critically explores how real-world complexities like surface anisotropy and coverage-dependent interactions can affect the interpretation of Arrhenius plots. ",
            "id": "3900868",
            "problem": "You will write a complete, runnable program that, for several synthetic data sets of the diffusion coefficient on a catalyst surface, performs a linear regression of the natural logarithm of the diffusion coefficient against reciprocal temperature to estimate the activation energy and the attempt frequency, starting from fundamental physical relations. The program must implement the following physics and algorithmic steps strictly in code, using only the provided numerical constants and the test suite specified below.\n\nFundamental base:\n- For thermally activated surface hopping, assume the diffusion coefficient $D$ follows an Arrhenius dependence on temperature $T$ with activation energy $E_{a}$ and a prefactor $D_{0}$ derived from random-walk theory. Use the two-dimensional (2D) isotropic random walk relation linking the prefactor to the attempt frequency $\\nu$ and a geometry factor.\n- The two-dimensional geometry factor is taken to be $g = 1/4$. The jump length $a$ is the mean nearest-neighbor hopping distance on the surface.\n- The Boltzmann constant in electronvolts per Kelvin is $k_{B} = 8.617333262145 \\times 10^{-5}$ $\\mathrm{eV/K}$.\n\nAlgorithmic task:\n- For each test case, construct the synthetic diffusion coefficient data $D(T)$ using the stated physical generative model and parameters.\n- Perform an ordinary least squares linear regression of the natural logarithm of the diffusion coefficient $\\ln D$ against the reciprocal temperature $1/T$.\n- From the regression, estimate the activation energy $E_{a}$ in $\\mathrm{eV}$ and the attempt frequency $\\nu$ in $\\mathrm{s^{-1}}$. You must express $E_{a}$ in $\\mathrm{eV}$ and $\\nu$ in $\\mathrm{s^{-1}}$, each rounded to six significant figures.\n\nTest suite and generative models:\n- Case A (happy path, isotropic, coverage-independent): Use $E_{a} = 0.6$ $\\mathrm{eV}$, $\\nu = 1.0 \\times 10^{12}$ $\\mathrm{s^{-1}}$, jump length $a = 2.5 \\times 10^{-10}$ $\\mathrm{m}$, two-dimensional geometry factor $g = 1/4$, and temperatures $T = [400, 450, 500, 550, 600]$ $\\mathrm{K}$. Construct $D(T)$ from the fundamental Arrhenius relation and random-walk prefactor with these parameters.\n- Case B (anisotropic diffusion, same activation barrier, direction-dependent prefactors aggregated as an unlabelled average): Use $E_{a} = 0.6$ $\\mathrm{eV}$, two directional components $(a_{x}, \\nu_{x}) = (3.0 \\times 10^{-10}$ $\\mathrm{m}$, $1.2 \\times 10^{12}$ $\\mathrm{s^{-1}})$ and $(a_{y}, \\nu_{y}) = (2.2 \\times 10^{-10}$ $\\mathrm{m}$, $0.8 \\times 10^{12}$ $\\mathrm{s^{-1}})$, geometry factor $g = 1/4$, and temperatures $T = [400, 450, 500, 550, 600]$ $\\mathrm{K}$. Construct the effective diffusion coefficient as the arithmetic mean of the two directional coefficients generated from the same fundamental base. In the regression-to-$\\nu$ conversion, use a fitting jump length $a_{\\mathrm{fit}} = 2.5 \\times 10^{-10}$ $\\mathrm{m}$ and geometry factor $g = 1/4$.\n- Case C (coverage effect producing a temperature-dependent apparent barrier): Use $E_{a,0} = 0.5$ $\\mathrm{eV}$ at zero coverage, an additive coverage contribution $\\gamma = 0.2$ $\\mathrm{eV}$ multiplied by a coverage function $\\theta(T)$, an attempt frequency $\\nu = 8.0 \\times 10^{11}$ $\\mathrm{s^{-1}}$, jump length $a = 2.6 \\times 10^{-10}$ $\\mathrm{m}$, geometry factor $g = 1/4$, and temperatures $T = [400, 450, 500, 550, 600]$ $\\mathrm{K}$. Define the coverage function as $\\theta(T) = \\left(1 + \\exp\\left(\\frac{T - 500}{30}\\right)\\right)^{-1}$. Construct $D(T)$ from the fundamental base with the barrier $E_{a}(T) = E_{a,0} + \\gamma \\,\\theta(T)$.\n- Case D (boundary case with minimal data): Use $E_{a} = 0.3$ $\\mathrm{eV}$, $\\nu = 1.0 \\times 10^{13}$ $\\mathrm{s^{-1}}$, jump length $a = 2.8 \\times 10^{-10}$ $\\mathrm{m}$, geometry factor $g = 1/4$, and temperatures $T = [500, 510]$ $\\mathrm{K}$. Construct $D(T)$ from the same fundamental base.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the pair $[E_{a}, \\nu]$ for one test case, using the units specified above. For example, the output must look like $[[E_{a,1},\\nu_{1}],[E_{a,2},\\nu_{2}],\\ldots]$ with no spaces. Each numerical entry must be a floating-point number rounded to six significant figures.\n\nScientific realism and interpretation requirement:\n- The parameters above are chosen to be physically plausible for surface diffusion. After computing the numerical estimates, the accompanying solution will discuss uncertainties arising from anisotropy and coverage effects in terms of their impact on the inferred $\\nu$ and on the linearity of $\\ln D$ versus $1/T$.",
            "solution": "The problem requires the analysis of synthetic surface diffusion data using the Arrhenius relationship to extract fundamental kinetic parameters. This analysis rests on the principles of transition state theory and random-walk models for atomic transport. The procedure involves generating synthetic data for the diffusion coefficient, $D$, as a function of temperature, $T$, under different physical assumptions, and then performing a linear regression to estimate the activation energy, $E_a$, and the attempt frequency, $\\nu$.\n\nThe theoretical foundation is the Arrhenius equation for the diffusion coefficient:\n$$D(T) = D_0 \\exp\\left(-\\frac{E_a}{k_B T}\\right)$$\nwhere $D_0$ is the pre-exponential factor, $E_a$ is the activation energy for hopping, $T$ is the absolute temperature, and $k_B$ is the Boltzmann constant, given as $k_B = 8.617333262145 \\times 10^{-5} \\, \\mathrm{eV/K}$.\n\nFor two-dimensional ($2$D) isotropic surface diffusion, the pre-exponential factor $D_0$ is related to microscopic parameters through random-walk theory:\n$$D_0 = g \\nu a^2$$\nHere, $\\nu$ is the vibrational attempt frequency of the adatom, $a$ is the jump length (mean nearest-neighbor distance), and $g$ is a geometry factor, specified as $g = 1/4$.\n\nTo extract $E_a$ and $\\nu$ from a set of $(T, D)$ data points, we linearize the Arrhenius equation by taking the natural logarithm:\n$$\\ln D(T) = \\ln(D_0) - \\frac{E_a}{k_B T}$$\nThis equation is of the linear form $y = c + mx$, where the variables are $y = \\ln D$ and $x = 1/T$. The slope, $m$, and the y-intercept, $c$, of the line are related to the physical parameters:\n$$m = -\\frac{E_a}{k_B}$$\n$$c = \\ln(D_0) = \\ln(g \\nu a^2)$$\nBy performing an ordinary least squares (OLS) linear regression on the data points $(1/T, \\ln D)$, we obtain estimates for $m$ and $c$. From these, the physical parameters are estimated as:\n$$E_a^{\\text{est}} = -m \\cdot k_B$$\n$$\\nu^{\\text{est}} = \\frac{\\exp(c)}{g a^2}$$\nThe following sections apply this procedure to each test case.\n\n**Case A: Ideal Isotropic Diffusion**\nThis case represents the ideal scenario where the diffusion process strictly follows the Arrhenius relation with constant parameters.\n- **Data Generation**: The diffusion coefficient $D(T)$ is computed for each temperature $T \\in [400, 450, 500, 550, 600] \\, \\mathrm{K}$ using the generative parameters: $E_a = 0.6 \\, \\mathrm{eV}$, $\\nu = 1.0 \\times 10^{12} \\, \\mathrm{s^{-1}}$, $a = 2.5 \\times 10^{-10} \\, \\mathrm{m}$, and $g = 1/4$.\nThe prefactor is $D_0 = (1/4) (1.0 \\times 10^{12} \\, \\mathrm{s^{-1}}) (2.5 \\times 10^{-10} \\, \\mathrm{m})^2 = 1.5625 \\times 10^{-8} \\, \\mathrm{m^2/s}$.\nThe diffusion coefficient is $D(T) = D_0 \\exp\\left(-\\frac{0.6}{k_B T}\\right)$.\n- **Regression and Parameter Extraction**: The coordinates for regression are $x_i = 1/T_i$ and $y_i = \\ln D(T_i)$. Since the data perfectly conforms to the model, the OLS regression will yield a perfect fit, and the extracted parameters $E_a^{\\text{est}}$ and $\\nu^{\\text{est}}$ will be identical to the generative parameters, within the limits of floating-point precision.\n\n**Case B: Anisotropic Diffusion**\nThis case models a surface where diffusion is anisotropic, having different characteristic jump lengths and attempt frequencies along two orthogonal directions. The provided data represents an arithmetic average of these directional diffusion coefficients.\n- **Data Generation**: The directional diffusion coefficients, $D_x(T)$ and $D_y(T)$, share the same activation energy $E_a = 0.6 \\, \\mathrm{eV}$. They are computed as:\n$D_x(T) = g \\nu_x a_x^2 \\exp(-E_a / (k_B T))$ with $(a_x, \\nu_x) = (3.0 \\times 10^{-10} \\, \\mathrm{m}, 1.2 \\times 10^{12} \\, \\mathrm{s^{-1}})$.\n$D_y(T) = g \\nu_y a_y^2 \\exp(-E_a / (k_B T))$ with $(a_y, \\nu_y) = (2.2 \\times 10^{-10} \\, \\mathrm{m}, 0.8 \\times 10^{12} \\, \\mathrm{s^{-1}})$.\nThe effective diffusion coefficient is $D(T) = \\frac{D_x(T) + D_y(T)}{2}$.\n- **Regression and Parameter Extraction**: Substituting the expressions for $D_x$ and $D_y$:\n$$D(T) = \\frac{1}{2} \\left( g \\nu_x a_x^2 + g \\nu_y a_y^2 \\right) \\exp\\left(-\\frac{E_a}{k_B T}\\right)$$\nTaking the natural logarithm:\n$$\\ln D(T) = \\ln\\left(\\frac{g}{2}(\\nu_x a_x^2 + \\nu_y a_y^2)\\right) - \\frac{E_a}{k_B T}$$\nContrary to a potential misinterpretation, because both anisotropic components share the same activation energy $E_a$, the resulting Arrhenius plot of $\\ln D$ versus $1/T$ is perfectly linear. The slope directly yields the true activation energy, $E_a = 0.6 \\, \\mathrm{eV}$. Non-linearity would only arise if the activation energies, $E_{a,x}$ and $E_{a,y}$, were different.\nThe intercept, $c$, corresponds to an effective prefactor: $c = \\ln\\left(D_{0, \\text{eff}}\\right) = \\ln\\left(\\frac{g}{2}(\\nu_x a_x^2 + \\nu_y a_y^2)\\right)$. The estimated frequency, $\\nu^{\\text{est}}$, is then extracted using the provided fitting parameter $a_{\\mathrm{fit}} = 2.5 \\times 10^{-10} \\, \\mathrm{m}$:\n$$\\nu^{\\text{est}} = \\frac{\\exp(c)}{g a_{\\mathrm{fit}}^2} = \\frac{\\frac{g}{2}(\\nu_x a_x^2 + \\nu_y a_y^2)}{g a_{\\mathrm{fit}}^2} = \\frac{\\nu_x a_x^2 + \\nu_y a_y^2}{2 a_{\\mathrm{fit}}^2}$$\nThis results in an estimated frequency that is a weighted average of the directional parameters, dependent on the assumed $a_{\\mathrm{fit}}$. This highlights the ambiguity in interpreting prefactors from averaged anisotropic data without further information.\n\n**Case C: Coverage-Dependent Activation Energy**\nThis case introduces complexity by modeling an activation energy that changes with temperature due to coverage effects.\n- **Data Generation**: The activation energy is temperature-dependent: $E_a(T) = E_{a,0} + \\gamma \\theta(T)$, where $E_{a,0} = 0.5 \\, \\mathrm{eV}$, $\\gamma = 0.2 \\, \\mathrm{eV}$, and $\\theta(T) = \\left(1 + \\exp\\left(\\frac{T - 500}{30}\\right)\\right)^{-1}$. The diffusion coefficient is:\n$$D(T) = g \\nu a^2 \\exp\\left(-\\frac{E_a(T)}{k_B T}\\right)$$\nusing $\\nu = 8.0 \\times 10^{11} \\, \\mathrm{s^{-1}}$ and $a = 2.6 \\times 10^{-10} \\, \\mathrm{m}$.\n- **Regression and Parameter Extraction**: The Arrhenius relation becomes:\n$$\\ln D(T) = \\ln(g \\nu a^2) - \\frac{E_{a,0} + \\gamma \\theta(T)}{k_B T}$$\nSince $E_a(T)$ is not constant, the plot of $\\ln D$ versus $1/T$ will not be a straight line. The OLS regression finds the best-fit line through this curved data, yielding an \"apparent\" activation energy, $E_a^{\\text{app}}$, and an \"apparent\" attempt frequency, $\\nu^{\\text{app}}$. These apparent values represent an average over the given temperature range and do not correspond to the parameters of the underlying physical process at any single temperature. The slope of the regression line, $m_{\\text{fit}}$, gives $E_a^{\\text{app}} = -m_{\\text{fit}} \\cdot k_B$. The quality of the linear fit (e.g., the $R^2$ value) will be lower than in the ideal case, indicating a deviation from simple Arrhenius behavior. This situation is common in experimental catalysis, where adsorbate-adsorbate interactions make the activation energy for diffusion dependent on surface coverage, which itself can be temperature-dependent.\n\n**Case D: Minimal Data Boundary Case**\nThis case tests the regression algorithm with the minimum number of data points required for a linear fit.\n- **Data Generation**: Data is generated for two temperatures, $T \\in [500, 510] \\, \\mathrm{K}$, using the ideal model with $E_a = 0.3 \\, \\mathrm{eV}$, $\\nu = 1.0 \\times 10^{13} \\, \\mathrm{s^{-1}}$, and $a = 2.8 \\times 10^{-10} \\, \\mathrm{m}$.\n- **Regression and Parameter Extraction**: With only two data points, the linear regression will find a line that passes exactly through both points. The fit will be perfect ($R^2=1$), and the extracted parameters $E_a^{\\text{est}}$ and $\\nu^{\\text{est}}$ will recover the generative parameters exactly, limited only by numerical precision. This serves as a validation of the core calculation logic.\n\nThe program implements these steps for each case, performs the required calculations, rounds the results to six significant figures, and presents them in the specified format. The rounding to significant figures is handled by a dedicated function that computes the appropriate number of decimal places based on the magnitude of the number.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import stats # Not needed, numpy.polyfit is sufficient for OLS.\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases for surface diffusion analysis.\n    \"\"\"\n    \n    # Define the physical constant\n    KB_EV_K = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    def round_to_sf(x, sf):\n        \"\"\"\n        Rounds a number x to a specified number of significant figures, sf.\n        \"\"\"\n        if x == 0:\n            return 0.0\n        # Handle formatting for scientific notation output\n        format_spec = f\"%.{sf-1}e\"\n        return float(format_spec % x)\n\n    def perform_regression(T_data, D_data, a_fit, g_factor):\n        \"\"\"\n        Performs linear regression on ln(D) vs 1/T and extracts Ea and nu.\n        \"\"\"\n        # Prepare variables for linear regression: y = m*x + c\n        x = 1.0 / T_data\n        y = np.log(D_data)\n\n        # Perform ordinary least squares linear regression (degree 1 polynomial fit)\n        m, c = np.polyfit(x, y, 1)  # m = slope, c = intercept\n\n        # Estimate physical parameters from regression results\n        # m = -Ea / kB  =>  Ea = -m * kB\n        Ea_est = -m * KB_EV_K\n        \n        # c = ln(D0) = ln(g * nu * a^2)\n        # exp(c) = g * nu * a^2  => nu = exp(c) / (g * a^2)\n        D0_est = np.exp(c)\n        nu_est = D0_est / (g_factor * a_fit**2)\n\n        return round_to_sf(Ea_est, 6), round_to_sf(nu_est, 6)\n\n    def solve_case_a():\n        \"\"\"Case A: Happy path, isotropic, coverage-independent.\"\"\"\n        Ea = 0.6  # eV\n        nu = 1.0e12  # s^-1\n        a = 2.5e-10  # m\n        g = 1.0 / 4.0\n        T = np.array([400, 450, 500, 550, 600])  # K\n\n        D0 = g * nu * a**2\n        D = D0 * np.exp(-Ea / (KB_EV_K * T))\n        \n        return perform_regression(T, D, a, g)\n\n    def solve_case_b():\n        \"\"\"Case B: Anisotropic diffusion, same activation barrier.\"\"\"\n        Ea = 0.6  # eV\n        g = 1.0 / 4.0\n        T = np.array([400, 450, 500, 550, 600])  # K\n\n        # Directional components\n        ax, nu_x = 3.0e-10, 1.2e12\n        ay, nu_y = 2.2e-10, 0.8e12\n        \n        D0_x = g * nu_x * ax**2\n        D0_y = g * nu_y * ay**2\n\n        Dx = D0_x * np.exp(-Ea / (KB_EV_K * T))\n        Dy = D0_y * np.exp(-Ea / (KB_EV_K * T))\n\n        # Effective D is the arithmetic mean\n        D_eff = (Dx + Dy) / 2.0\n\n        # Use a_fit for regression analysis as specified\n        a_fit = 2.5e-10  # m\n        return perform_regression(T, D_eff, a_fit, g)\n\n    def solve_case_c():\n        \"\"\"Case C: Coverage effect producing a temperature-dependent barrier.\"\"\"\n        Ea0 = 0.5  # eV\n        gamma = 0.2  # eV\n        nu = 8.0e11  # s^-1\n        a = 2.6e-10  # m\n        g = 1.0 / 4.0\n        T = np.array([400, 450, 500, 550, 600]) # K\n\n        def coverage_theta(T_val):\n            return 1.0 / (1.0 + np.exp((T_val - 500.0) / 30.0))\n\n        Ea_T = Ea0 + gamma * coverage_theta(T)\n        D0 = g * nu * a**2\n        D = D0 * np.exp(-Ea_T / (KB_EV_K * T))\n        \n        return perform_regression(T, D, a, g)\n\n    def solve_case_d():\n        \"\"\"Case D: Boundary case with minimal data.\"\"\"\n        Ea = 0.3  # eV\n        nu = 1.0e13  # s^-1\n        a = 2.8e-10  # m\n        g = 1.0 / 4.0\n        T = np.array([500, 510])  # K\n\n        D0 = g * nu * a**2\n        D = D0 * np.exp(-Ea / (KB_EV_K * T))\n\n        return perform_regression(T, D, a, g)\n\n    # Run all cases and collect results\n    results = [\n        list(solve_case_a()),\n        list(solve_case_b()),\n        list(solve_case_c()),\n        list(solve_case_d()),\n    ]\n    \n    # Format the final output string exactly as required\n    result_str = \",\".join([f\"[{ea},{nu}]\" for ea, nu in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}