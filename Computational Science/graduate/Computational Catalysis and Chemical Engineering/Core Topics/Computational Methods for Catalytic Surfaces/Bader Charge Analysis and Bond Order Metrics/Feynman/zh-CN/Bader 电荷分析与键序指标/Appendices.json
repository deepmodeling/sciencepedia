{
    "hands_on_practices": [
        {
            "introduction": "本练习将通过其数学根源，巩固您对巴德（Bader）分析的理解。通过一个简化的二维电子密度模型，您将解析地推导出定义原子盆（atomic basin）的零通量线（zero-flux line）。该实践旨在阐明电子密度梯度与空间划分之间的直接关系，并展示对称性如何决定同核体系中的电荷分布 。",
            "id": "3869067",
            "problem": "考虑分子中原子的量子理论 (Quantum Theory of Atoms in Molecules, QTAIM)，该理论通过电子密度梯度中的零通量条件来将空间划分为原子盆，即在单位法向量为 $\\hat{\\mathbf{n}}$ 的边界上，满足条件 $\\nabla n(\\mathbf{r}) \\cdot \\hat{\\mathbf{n}} = 0$。在一个用于模拟催化表面上双原子吸附物的二维玩具模型中，用两个位于 $(x,y) = (\\pm d, 0)$ 的归一化各向同性高斯峰之和来近似价电子密度：\n$$\nn(x,y) = \\frac{1}{\\pi \\sigma^{2}} \\exp\\!\\left(-\\frac{(x-d)^{2} + y^{2}}{\\sigma^{2}}\\right) + \\frac{1}{\\pi \\sigma^{2}} \\exp\\!\\left(-\\frac{(x+d)^{2} + y^{2}}{\\sigma^{2}}\\right),\n$$\n其中 $\\sigma  0$ 和 $d  0$ 是给定的实数参数。该密度具有多个极大值和它们之间的一个键临界点（一个鞍点），并且对于所有 $(x,y) \\in \\mathbb{R}^{2}$ 都是严格为正的。\n\n任务：\n- 使用 QTAIM 的零通量边界核心定义，确定将平面划分为两个 Bader 盆（对应于 $(x,y) = (\\pm d, 0)$ 处的两个极大值）的零通量线的显式方程。\n- 通过在由零通量线界定的 $x  0$ 区域上对密度进行积分，计算分配给右侧盆（与 $(x,y) = (d,0)$ 处的极大值相关联）的 Bader 电荷。假设高斯归一化如上所述，并将 $n(x,y)$ 在任何区域上的积分解释为该区域内的电子数。\n\n将最终的 Bader 电荷表示为单个实数，单位为电子。无需四舍五入。使用给定的归一化，使得每个高斯峰所代表的总电子数为 1 个电子。",
            "solution": "用户要求解答一个计算化学问题，具体是将分子中原子的量子理论 (QTAIM) 应用于一个电子密度的玩具模型。\n\n### 步骤 1：提取已知条件\n- **电子密度函数**：\n$$\nn(x,y) = \\frac{1}{\\pi \\sigma^{2}} \\exp\\left(-\\frac{(x-d)^{2} + y^{2}}{\\sigma^{2}}\\right) + \\frac{1}{\\pi \\sigma^{2}} \\exp\\left(-\\frac{(x+d)^{2} + y^{2}}{\\sigma^{2}}\\right)\n$$\n- **参数**：$d  0$ 和 $\\sigma  0$ 是实数参数。\n- **QTAIM 零通量条件**：原子盆之间的边界由条件 $\\nabla n(\\mathbf{r}) \\cdot \\hat{\\mathbf{n}} = 0$ 定义，其中 $\\hat{\\mathbf{n}}$ 是边界表面的单位法向量。\n- **密度归一化**：每个高斯峰在全空间积分后对应 1 个电子。\n- **任务 1**：找出划分平面的零通量线的显式方程。\n- **任务 2**：计算右侧盆的 Bader 电荷，该盆与 $(d, 0)$ 处的极大值相关联，并对应于由 $x  0$ 的零通量线所界定的区域。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于 QTAIM 的原理，这是理论和计算化学中一个标准且成熟的方法。使用高斯函数来模拟电子密度是一种常见且物理上合理的近似（例如，在高斯基组中）。零通量条件是该理论中原子间界面的基本定义。该问题是将这些原理应用于一个简化数学模型的有效应用。\n- **良态的**：该问题提供了一个具体、定义明确的数学函数，并要求推导其性质（零通量边界和在所得区域上的积分）。任务清晰，且存在唯一解。\n- **客观性**：该问题以精确的数学语言陈述，没有主观性或歧义。\n\n### 步骤 3：结论与行动\n该问题是有效的。其前提在科学和数学上都是合理的，任务也定义明确。我将继续进行解答。\n\n### 详细解答\n\n按照要求，问题分两部分解决：首先，确定零通量边界；其次，计算其中一个所得盆内的电荷。\n\n**第 1 部分：确定零通量线**\n\nBader 盆之间的边界是一个零通量面。在这个二维问题中，它是一条零通量线。这样一条线的条件是，电子密度的梯度 $\\nabla n(x,y)$ 必须在直线上的每一点都与该线的法向量 $\\hat{\\mathbf{n}}$ 垂直。\n\n给定的电子密度是两个分量的和：\n$n(x,y) = n_1(x,y) + n_2(x,y)$，其中\n$$\nn_1(x,y) = \\frac{1}{\\pi \\sigma^{2}} \\exp\\left(-\\frac{(x-d)^{2} + y^{2}}{\\sigma^{2}}\\right)\n$$\n$$\nn_2(x,y) = \\frac{1}{\\pi \\sigma^{2}} \\exp\\left(-\\frac{(x+d)^{2} + y^{2}}{\\sigma^{2}}\\right)\n$$\n总密度函数 $n(x,y)$ 关于 y 轴对称，即 $n(-x,y) = n(x,y)$。这种强对称性表明，与 $(\\pm d, 0)$ 处的极大值相关联的两个原子盆之间的分界线是直线 $x=0$。\n\n为了验证这一点，我们必须证明直线 $x=0$ 满足零通量条件。对于直线 $x=0$，单位法向量为 $\\hat{\\mathbf{n}} = (1, 0)$。零通量条件 $\\nabla n(x,y) \\cdot \\hat{\\mathbf{n}} = 0$ 变为：\n$$\n\\frac{\\partial n}{\\partial x} \\bigg|_{x=0} = 0\n$$\n我们计算 $n(x,y)$ 关于 $x$ 的偏导数：\n$$\n\\frac{\\partial n}{\\partial x} = \\frac{\\partial}{\\partial x} \\left[ \\frac{1}{\\pi \\sigma^{2}} \\exp\\left(-\\frac{(x-d)^{2} + y^{2}}{\\sigma^{2}}\\right) + \\frac{1}{\\pi \\sigma^{2}} \\exp\\left(-\\frac{(x+d)^{2} + y^{2}}{\\sigma^{2}}\\right) \\right]\n$$\n$$\n\\frac{\\partial n}{\\partial x} = \\frac{1}{\\pi \\sigma^{2}} \\left[ \\exp\\left(-\\frac{(x-d)^{2} + y^{2}}{\\sigma^{2}}\\right)\\left(-\\frac{2(x-d)}{\\sigma^{2}}\\right) + \\exp\\left(-\\frac{(x+d)^{2} + y^{2}}{\\sigma^{2}}\\right)\\left(-\\frac{2(x+d)}{\\sigma^{2}}\\right) \\right]\n$$\n现在，我们在 $x=0$ 处计算这个导数：\n$$\n\\frac{\\partial n}{\\partial x} \\bigg|_{x=0} = \\frac{1}{\\pi \\sigma^{2}} \\left[ \\exp\\left(-\\frac{d^{2} + y^{2}}{\\sigma^{2}}\\right)\\left(-\\frac{2(-d)}{\\sigma^{2}}\\right) + \\exp\\left(-\\frac{d^{2} + y^{2}}{\\sigma^{2}}\\right)\\left(-\\frac{2(d)}{\\sigma^{2}}\\right) \\right]\n$$\n$$\n\\frac{\\partial n}{\\partial x} \\bigg|_{x=0} = \\frac{1}{\\pi \\sigma^{2}} \\exp\\left(-\\frac{d^{2} + y^{2}}{\\sigma^{2}}\\right) \\left[ \\frac{2d}{\\sigma^{2}} - \\frac{2d}{\\sigma^{2}} \\right] = 0\n$$\n由于这个条件对所有 $y$ 值都成立，因此直线 $x=0$ 确实是划分平面的零通量线。两个 Bader 盆是半平面 $x  0$ 和 $x > 0$。\n\n**第 2 部分：计算 Bader 电荷**\n\n右侧盆是由 $x > 0$ 定义的区域。与该盆相关联的 Bader 电荷 $Q_R$ 是电子密度在该区域上的积分：\n$$\nQ_R = \\int_{0}^{\\infty} \\int_{-\\infty}^{\\infty} n(x,y) \\,dy\\,dx\n$$\n我们可以代入 $n(x,y)$ 的表达式并将积分拆分：\n$$\nQ_R = \\int_{0}^{\\infty} \\int_{-\\infty}^{\\infty} \\frac{1}{\\pi \\sigma^{2}} \\exp\\left(-\\frac{(x-d)^{2} + y^{2}}{\\sigma^{2}}\\right) \\,dy\\,dx + \\int_{0}^{\\infty} \\int_{-\\infty}^{\\infty} \\frac{1}{\\pi \\sigma^{2}} \\exp\\left(-\\frac{(x+d)^{2} + y^{2}}{\\sigma^{2}}\\right) \\,dy\\,dx\n$$\n让我们分别将这两个积分表示为 $I_1$ 和 $I_2$。\n\n首先，考虑 $I_1$：\n$$\nI_1 = \\frac{1}{\\pi \\sigma^{2}} \\int_{0}^{\\infty} \\exp\\left(-\\frac{(x-d)^{2}}{\\sigma^{2}}\\right) \\left[ \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{y^{2}}{\\sigma^{2}}\\right) \\,dy \\right] \\,dx\n$$\n内部关于 $y$ 的积分是一个标准高斯积分，其值为 $\\sqrt{\\pi \\sigma^{2}}$。\n$$\nI_1 = \\frac{1}{\\pi \\sigma^{2}} \\sqrt{\\pi \\sigma^{2}} \\int_{0}^{\\infty} \\exp\\left(-\\frac{(x-d)^{2}}{\\sigma^{2}}\\right) \\,dx = \\frac{1}{\\sqrt{\\pi \\sigma^{2}}} \\int_{0}^{\\infty} \\exp\\left(-\\frac{(x-d)^{2}}{\\sigma^{2}}\\right) \\,dx\n$$\n让我们进行变量替换：$u = \\frac{x-d}{\\sigma}$。那么 $du = \\frac{dx}{\\sigma}$，所以 $dx = \\sigma du$。积分限从 $x=0$ 变为 $u = -d/\\sigma$，从 $x \\to \\infty$ 变为 $u \\to \\infty$。\n$$\nI_1 = \\frac{1}{\\sqrt{\\pi}\\sigma} \\int_{-d/\\sigma}^{\\infty} \\exp(-u^2) (\\sigma \\,du) = \\frac{1}{\\sqrt{\\pi}} \\int_{-d/\\sigma}^{\\infty} \\exp(-u^2) \\,du\n$$\n使用误差函数的定义 $\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}}\\int_{0}^{z} \\exp(-t^2) \\,dt$，我们可以写出：\n$$\n\\int_{-d/\\sigma}^{\\infty} \\exp(-u^2) \\,du = \\int_{-d/\\sigma}^{0} \\exp(-u^2) \\,du + \\int_{0}^{\\infty} \\exp(-u^2) \\,du\n$$\n由于 $\\exp(-u^2)$ 是偶函数，$\\int_{-a}^{0} f(u) du = \\int_{0}^{a} f(u) du$。并且，$\\int_{0}^{\\infty} \\exp(-u^2) \\,du = \\frac{\\sqrt{\\pi}}{2}$。\n$$\nI_1 = \\frac{1}{\\sqrt{\\pi}} \\left[ \\int_{0}^{d/\\sigma} \\exp(-u^2) \\,du + \\frac{\\sqrt{\\pi}}{2} \\right] = \\frac{1}{\\sqrt{\\pi}} \\left[ \\frac{\\sqrt{\\pi}}{2} \\text{erf}\\left(\\frac{d}{\\sigma}\\right) + \\frac{\\sqrt{\\pi}}{2} \\right] = \\frac{1}{2} \\left(1 + \\text{erf}\\left(\\frac{d}{\\sigma}\\right)\\right)\n$$\n\n现在，考虑 $I_2$：\n$$\nI_2 = \\frac{1}{\\sqrt{\\pi \\sigma^{2}}} \\int_{0}^{\\infty} \\exp\\left(-\\frac{(x+d)^{2}}{\\sigma^{2}}\\right) \\,dx\n$$\n让我们使用一个新变量：$v = \\frac{x+d}{\\sigma}$。那么 $dv = \\frac{dx}{\\sigma}$，所以 $dx = \\sigma dv$。积分限从 $x=0$ 变为 $v = d/\\sigma$，从 $x \\to \\infty$ 变为 $v \\to \\infty$。\n$$\nI_2 = \\frac{1}{\\sqrt{\\pi}\\sigma} \\int_{d/\\sigma}^{\\infty} \\exp(-v^2) (\\sigma \\,dv) = \\frac{1}{\\sqrt{\\pi}} \\int_{d/\\sigma}^{\\infty} \\exp(-v^2) \\,dv\n$$\n这个积分可以用互补误差函数表示，$\\text{erfc}(z) = 1 - \\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}}\\int_{z}^{\\infty} \\exp(-t^2) \\,dt$。\n$$\nI_2 = \\frac{1}{\\sqrt{\\pi}} \\left[ \\frac{\\sqrt{\\pi}}{2} \\text{erfc}\\left(\\frac{d}{\\sigma}\\right) \\right] = \\frac{1}{2} \\text{erfc}\\left(\\frac{d}{\\sigma}\\right) = \\frac{1}{2} \\left(1 - \\text{erf}\\left(\\frac{d}{\\sigma}\\right)\\right)\n$$\n\n最后，总电荷 $Q_R$ 是 $I_1$ 和 $I_2$ 的和：\n$$\nQ_R = I_1 + I_2 = \\frac{1}{2} \\left(1 + \\text{erf}\\left(\\frac{d}{\\sigma}\\right)\\right) + \\frac{1}{2} \\left(1 - \\text{erf}\\left(\\frac{d}{\\sigma}\\right)\\right)\n$$\n$$\nQ_R = \\frac{1}{2} + \\frac{1}{2}\\text{erf}\\left(\\frac{d}{\\sigma}\\right) + \\frac{1}{2} - \\frac{1}{2}\\text{erf}\\left(\\frac{d}{\\sigma}\\right) = 1\n$$\n另外，也可以使用一个基于对称性的更简单的论证。问题陈述，每个归一化高斯函数在全空间上的积分为 1。因此，系统中的总电子数为 $1+1=2$。密度函数 $n(x,y)$ 关于 $x=0$ 轴是完全对称的。分界线就是对称轴 $x=0$。因此，总电荷必须在两个盆之间平均分配。右侧盆 ($x0$) 中的电荷是总电荷的一半：\n$$\nQ_R = \\frac{1}{2} Q_{\\text{total}} = \\frac{1}{2}(2) = 1\n$$\n两种方法得到相同的结果。右侧盆的 Bader 电荷为 1 个电子。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "从解析理论转向实际计算，本练习要求您实现并比较三种不同的原子电荷方案：马利肯（Mulliken）、赫希菲尔德（Hirshfeld）和巴德（Bader）。通过将这些方法应用于一个简化的甲烷模型，您将获得算法实现的实践经验，并体会每种方法的概念差异和数值敏感性。这种比较分析对于批判性地评估计算结果以及理解不同方法为何能对分子的电子结构得出不同见解至关重要 。",
            "id": "3869040",
            "problem": "考虑甲烷分子模型，该模型由五个以原子为中心、归一化的 $s$ 型高斯基函数构成。这些基函数分别位于一个碳原子核和四个呈四面体几何构型的氢原子核上。设碳原子位于原点，四个氢原子位于一个正四面体的顶点上，碳氢键长为 $1.09\\,\\mathrm{\\AA}$，其方向向量 $(1,1,1)$、$(1,-1,-1)$、$(-1,1,-1)$ 和 $(-1,-1,1)$ 已被归一化至指定的键长。每个原子轨道基函数定义为 $\\chi_{\\mu}(\\mathbf{r}) = N(\\alpha_{\\mu}) \\exp\\big(-\\alpha_{\\mu} \\lVert \\mathbf{r} - \\mathbf{R}_{\\mu} \\rVert^2\\big)$，其归一化常数 $N(\\alpha) = \\left(\\dfrac{2\\alpha}{\\pi}\\right)^{3/4}$ 以使得 $\\int \\chi_{\\mu}^2(\\mathbf{r})\\,d^3\\mathbf{r} = 1$。假设只考虑价电子：碳为 $4$ 个，每个氢为 $1$ 个，总计 $8$ 个电子。\n\n你需要实现一个程序，为每一组指定的参数集构建以下内容：\n- $5\\times 5$ 的原子轨道重叠矩阵 $S$，其元素为 $S_{\\mu\\nu} = \\int \\chi_{\\mu}(\\mathbf{r}) \\chi_{\\nu}(\\mathbf{r})\\,d^3\\mathbf{r}$，使用归一化 $s$ 型高斯函数重叠的解析公式：\n$$\nS_{\\mu\\nu} = \\left(\\frac{2\\sqrt{\\alpha_{\\mu}\\alpha_{\\nu}}}{\\alpha_{\\mu}+\\alpha_{\\nu}}\\right)^{3/2}\\exp\\left(-\\frac{\\alpha_{\\mu}\\alpha_{\\nu}}{\\alpha_{\\mu}+\\alpha_{\\nu}} \\lVert \\mathbf{R}_{\\mu}-\\mathbf{R}_{\\nu}\\rVert^2\\right).\n$$\n- 在正交化的原子轨道空间中构建一组包含四个已占据分子轨道，该组分子轨道由一个正交的 $5\\times 4$ 系数矩阵 $M$ 构成。$M$ 的第一列是全对称组合 $m_0 \\propto \\big[w_C,\\,w_H/2,\\,w_H/2,\\,w_H/2,\\,w_H/2\\big]^T$，其余三列是氢基向量的相互正交线性组合，且氢组分之和为零（因此与 $m_0$ 正交）。此处的正交化必须是相对于单位度规，而非 $S$。然后使用对称正交化返回到原子轨道基：若 $S = U\\Lambda U^T$，定义 $X = U\\Lambda^{-1/2}U^T$，则原子轨道分子轨道系数矩阵为 $C = X M$，满足 $C^T S C = I_4$。\n- 在原子轨道基下，闭壳层密度矩阵为 $P = 2 C C^T$，其在 $S$ 度规下的迹等于模型中的电子数，即 $\\operatorname{Tr}(P S) = 8$。\n\n利用这些信息，计算碳和氢的三种原子电荷：\n1. Mulliken 电荷：原子 $A$ 的 Mulliken 总原子布居数为\n$$\nN_A^{\\mathrm{M}} = \\sum_{\\mu \\in A} (P S)_{\\mu\\mu},\n$$\nMulliken 原子电荷为 $q_A^{\\mathrm{M}} = Z_A^{\\mathrm{val}} - N_A^{\\mathrm{M}}$，其中 $Z_C^{\\mathrm{val}} = 4$，$Z_H^{\\mathrm{val}} = 1$。\n2. Hirshfeld 电荷：定义模型分子电子密度\n$$\n\\rho(\\mathbf{r}) = \\sum_{\\mu\\nu} P_{\\mu\\nu} \\chi_{\\mu}(\\mathbf{r}) \\chi_{\\nu}(\\mathbf{r}),\n$$\n以及中性价电子层的前原子参考密度\n$$\n\\rho_A^0(\\mathbf{r}) = Z_A^{\\mathrm{val}}\\, g_A(\\mathbf{r}),\\quad g_A(\\mathbf{r}) = \\left(\\frac{2\\beta_A}{\\pi}\\right)^{3/2} \\exp\\left(-2\\beta_A \\lVert \\mathbf{r}-\\mathbf{R}_A\\rVert^2\\right),\n$$\n其中 $g_A$ 归一化后积分为 $1$，$\\beta_A$ 是原子 $A$ 的前原子高斯指数。Hirshfeld 权重为\n$$\nw_A(\\mathbf{r}) = \\frac{\\rho_A^0(\\mathbf{r})}{\\sum_B \\rho_B^0(\\mathbf{r})},\n$$\nHirshfeld 原子布居数为\n$$\nN_A^{\\mathrm{H}} = \\int \\rho(\\mathbf{r}) w_A(\\mathbf{r})\\, d^3\\mathbf{r},\n$$\nHirshfeld 电荷为 $q_A^{\\mathrm{H}} = Z_A^{\\mathrm{val}} - N_A^{\\mathrm{H}}$。\n3. 通过 $\\rho(\\mathbf{r})$ 梯度的零通量划分计算 Bader 电荷：原子 $A$ 的 Bader 原子盆是这样一个点集，其中 $\\rho(\\mathbf{r})$ 的最速上升轨迹终止于与原子核 $A$ 相关联的局部最大值。这些点满足在原子间表面上的零通量条件 $\\nabla \\rho(\\mathbf{r}) \\cdot \\mathbf{n}(\\mathbf{r}) = 0$，其中 $\\mathbf{n}(\\mathbf{r})$ 是表面法向量。在数值上，通过离散梯度上升更新来近似此过程\n$$\n\\mathbf{r}_{k+1} = \\mathbf{r}_k + s \\frac{\\nabla \\rho(\\mathbf{r}_k)}{\\lVert \\nabla \\rho(\\mathbf{r}_k) \\rVert},\n$$\n直到收敛到某个原子核的小距离内或达到最大步数为止；然后在每个盆地中对密度进行积分：\n$$\nN_A^{\\mathrm{B}} = \\int_{\\Omega_A} \\rho(\\mathbf{r})\\, d^3\\mathbf{r}, \\quad q_A^{\\mathrm{B}} = Z_A^{\\mathrm{val}} - N_A^{\\mathrm{B}}.\n$$\n\n为确保可复现性和普适性，请实现以下数值方案：\n- 对所有实空间积分，使用一个均匀的立方网格，覆盖每个维度上的立方体 $[-3.0,3.0]\\,\\mathrm{\\AA}$，间距为 $\\Delta x = \\Delta y = \\Delta z = 0.5\\,\\mathrm{\\AA}$。使用中点法则。体素体积为 $dV = \\Delta x\\, \\Delta y\\, \\Delta z$。\n- 对于梯度上升，使用固定步长 $s = 0.2\\,\\mathrm{\\AA}$，当与任意原子核的距离小于 $0.3\\,\\mathrm{\\AA}$、梯度范数小于 $10^{-8}$ 或达到 $60$ 步时终止，以先满足者为准。如果网格点的初始密度小于 $10^{-9}$，你可以直接将该点分配给最近的原子核以避免不必要的迭代。\n- 为减轻有限计算框的积分误差，在计算 Hirshfeld 和 Bader 布居数之前，重新缩放数值积分得到的总电子密度，使其积分电子数恰好等于 $8$。即，在网格上计算 $N_{\\mathrm{box}} = \\sum_i \\rho(\\mathbf{r}_i) dV$，并在所有后续的基于网格的划分中使用 $\\tilde{\\rho}(\\mathbf{r}_i) = \\rho(\\mathbf{r}_i)\\cdot \\left(8/N_{\\mathrm{box}}\\right)$。\n\n测试组：\n对于每个参数集，都提供了原子轨道指数 $\\alpha_C$ 和 $\\alpha_H$、用于对称组合的正交分子轨道混合权重 $w_C$ 和 $w_H$，以及前原子指数 $\\beta_C$ 和 $\\beta_H$。所有氢原子共享相同的指数。使用给定的四面体几何结构，碳在原点，氢距离碳 $1.09\\,\\mathrm{\\AA}$。\n\n- 情况 1（均衡）：$(\\alpha_C,\\alpha_H,w_C,w_H,\\beta_C,\\beta_H) = (0.8,\\,1.2,\\,0.8,\\,0.6,\\,0.7,\\,1.0)$。\n- 情况 2（氢原子过局域化基组）：$(\\alpha_C,\\alpha_H,w_C,w_H,\\beta_C,\\beta_H) = (0.6,\\,2.0,\\,0.7,\\,0.6,\\,0.7,\\,1.2)$。\n- 情况 3（弥散函数）：$(\\alpha_C,\\alpha_H,w_C,w_H,\\beta_C,\\beta_H) = (0.3,\\,0.4,\\,0.8,\\,0.4,\\,0.5,\\,0.7)$。\n\n对于每种情况，计算：\n- 碳的 Mulliken 电荷 $q_C^{\\mathrm{M}}$ 和氢的平均 Mulliken 电荷 $\\bar{q}_H^{\\mathrm{M}}$，\n- 碳的 Hirshfeld 电荷 $q_C^{\\mathrm{H}}$ 和氢的平均 Hirshfeld 电荷 $\\bar{q}_H^{\\mathrm{H}}$，\n- 碳的 Bader 电荷 $q_C^{\\mathrm{B}}$ 和氢的平均 Bader 电荷 $\\bar{q}_H^{\\mathrm{B}}$。\n\n所有电荷必须以十进制浮点数表示，单位为基本电荷 $e$（以 $e$ 为单位的无量纲数），并四舍五入到小数点后三位。你的程序应生成单行输出，其中包含所有情况的结果，形式为一个扁平的、逗号分隔的列表，并用方括号括起来，顺序如下：\n$$\n\\big[q_C^{\\mathrm{M}}(1),\\,\\bar{q}_H^{\\mathrm{M}}(1),\\,q_C^{\\mathrm{H}}(1),\\,\\bar{q}_H^{\\mathrm{H}}(1),\\,q_C^{\\mathrm{B}}(1),\\,\\bar{q}_H^{\\mathrm{B}}(1),\\,q_C^{\\mathrm{M}}(2),\\,\\bar{q}_H^{\\mathrm{M}}(2),\\,\\ldots,\\,q_C^{\\mathrm{B}}(3),\\,\\bar{q}_H^{\\mathrm{B}}(3)\\big].\n$$\n括号中指示的是情况索引。本问题不使用角度。请遵循上述定义和约束，确保数值稳定性和科学真实性，不要引入任何外部数据或文件。",
            "solution": "用户提供的问题陈述是量子化学中一个定义明确的计算练习。它要求实现算法，为一个简化的甲烷分子模型计算三种不同类型的原子电荷（Mulliken、Hirshfeld 和 Bader）。\n\n### 步骤 1：提取给定信息\n\n- **分子几何结构**：一个碳原子位于原点 $\\mathbf{R}_C = (0,0,0)$。四个氢原子距离碳原子 $d_{CH} = 1.09\\,\\mathrm{\\AA}$，沿方向 $(1,1,1)$、$(1,-1,-1)$、$(-1,1,-1)$ 和 $(-1,-1,1)$ 分布。\n- **基函数**：五个以原子为中心、归一化的 $s$ 型高斯基函数，$\\chi_{\\mu}(\\mathbf{r}) = N(\\alpha_{\\mu}) \\exp\\big(-\\alpha_{\\mu} \\lVert \\mathbf{r} - \\mathbf{R}_{\\mu} \\rVert^2\\big)$，其中 $N(\\alpha) = \\left(\\frac{2\\alpha}{\\pi}\\right)^{3/4}$。\n- **价电子**：$Z_C^{\\mathrm{val}} = 4$，$Z_H^{\\mathrm{val}} = 1$。总电子数 = $8$。\n- **重叠矩阵公式**：$S_{\\mu\\nu} = \\left(\\frac{2\\sqrt{\\alpha_{\\mu}\\alpha_{\\nu}}}{\\alpha_{\\mu}+\\alpha_{\\nu}}\\right)^{3/2}\\exp\\left(-\\frac{\\alpha_{\\mu}\\alpha_{\\nu}}{\\alpha_{\\mu}+\\alpha_{\\nu}} \\lVert \\mathbf{R}_{\\mu}-\\mathbf{R}_{\\nu}\\rVert^2\\right)$。\n- **分子轨道 (MOs)**：\n    - 在正交原子轨道 (OAO) 空间中构建一个正交的 $5\\times 4$ 系数矩阵 $M$。\n    - 第一列 $m_0$ 与 $\\big[w_C,\\,w_H/2,\\,w_H/2,\\,w_H/2,\\,w_H/2\\big]^T$ 成比例。\n    - 其他三列相互正交，由氢基函数构成，并且氢组分之和为零。\n    - 原子轨道 (AO) 基下的 MO 系数为 $C = X M$，其中 $X = S^{-1/2}$ 来自重叠矩阵 $S$ 的对称正交化。关系式 $C^T S C = I_4$ 成立。\n- **密度矩阵**：$P = 2 C C^T$。迹 $\\operatorname{Tr}(P S) = 8$。\n- **Mulliken 电荷**：$N_A^{\\mathrm{M}} = \\sum_{\\mu \\in A} (P S)_{\\mu\\mu}$，$q_A^{\\mathrm{M}} = Z_A^{\\mathrm{val}} - N_A^{\\mathrm{M}}$。\n- **Hirshfeld 电荷**：\n    - 分子密度：$\\rho(\\mathbf{r}) = \\sum_{\\mu\\nu} P_{\\mu\\nu} \\chi_{\\mu}(\\mathbf{r}) \\chi_{\\nu}(\\mathbf{r})$。\n    - 前原子密度：$\\rho_A^0(\\mathbf{r}) = Z_A^{\\mathrm{val}}\\, g_A(\\mathbf{r})$，其中 $g_A(\\mathbf{r}) = \\left(\\frac{2\\beta_A}{\\pi}\\right)^{3/2} \\exp\\left(-2\\beta_A \\lVert \\mathbf{r}-\\mathbf{R}_A\\rVert^2\\right)$。\n    - Hirshfeld 布居数：$N_A^{\\mathrm{H}} = \\int \\rho(\\mathbf{r}) \\frac{\\rho_A^0(\\mathbf{r})}{\\sum_B \\rho_B^0(\\mathbf{r})}\\, d^3\\mathbf{r}$。\n    - Hirshfeld 电荷：$q_A^{\\mathrm{H}} = Z_A^{\\mathrm{val}} - N_A^{\\mathrm{H}}$。\n- **Bader 电荷**：\n    - 原子盆 $\\Omega_A$ 由 $\\nabla \\rho(\\mathbf{r})$ 的零通量面确定。\n    - 通过梯度上升法数值求解：$\\mathbf{r}_{k+1} = \\mathbf{r}_k + s \\frac{\\nabla \\rho(\\mathbf{r}_k)}{\\lVert \\nabla \\rho(\\mathbf{r}_k) \\rVert}$。\n    - 布居数：$N_A^{\\mathrm{B}} = \\int_{\\Omega_A} \\rho(\\mathbf{r})\\, d^3\\mathbf{r}$，电荷：$q_A^{\\mathrm{B}} = Z_A^{\\mathrm{val}} - N_A^{\\mathrm{B}}$。\n- **数值方案**：\n    - 网格：每个维度上从 $[-3.0, 3.0]\\,\\mathrm{\\AA}$ 的立方体，间距 $\\Delta x = \\Delta y = \\Delta z = 0.5\\,\\mathrm{\\AA}$。\n    - 积分：中点法则，体素体积 $dV = (0.5)^3\\,\\mathrm{\\AA}^3$。\n    - 密度重归一化：在计算 Hirshfeld 和 Bader 布居数之前，将数值积分的密度 $\\int_{\\text{box}} \\rho(\\mathbf{r})\\,d^3\\mathbf{r}$ 重新缩放至等于 $8$。\n    - 梯度上升：步长 $s = 0.2\\,\\mathrm{\\AA}$。终止条件：与原子核距离小于 $0.3\\,\\mathrm{\\AA}$，梯度范数小于 $10^{-8}$，或 $60$ 步。\n    - 低密度分配：若 $\\rho(\\mathbf{r}_i)  10^{-9}$，则将网格点 $\\mathbf{r}_i$ 分配给最近的原子核。\n- **测试用例**：\n    - 情况 1：$(\\alpha_C,\\alpha_H,w_C,w_H,\\beta_C,\\beta_H) = (0.8,\\,1.2,\\,0.8,\\,0.6,\\,0.7,\\,1.0)$。\n    - 情况 2：$(\\alpha_C,\\alpha_H,w_C,w_H,\\beta_C,\\beta_H) = (0.6,\\,2.0,\\,0.7,\\,0.6,\\,0.7,\\,1.2)$。\n    - 情况 3：$(\\alpha_C,\\alpha_H,w_C,w_H,\\beta_C,\\beta_H) = (0.3,\\,0.4,\\,0.8,\\,0.4,\\,0.5,\\,0.7)$。\n- **输出格式**：一个扁平列表，包含 `[q_C^M(1), q_H^M(1), ..., q_H^B(3)]`，四舍五入至三位小数。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n- **科学基础**：该问题牢固地植根于计算量子化学的原理。高斯基函数、重叠矩阵、密度矩阵以及各种布居分析方案（Mulliken、Hirshfeld、Bader）的使用都是标准概念。提供的公式是在一个简化模型中对这些概念的正确表示。\n- **定义明确**：该问题是明确的。它提供了所有必要的参数、常数和详细的数值方案。分子轨道的构建有明确定义，包括正交性条件。计算序列是逻辑的，能够导出一个唯一的、可确定的结果集。\n- **客观性**：语言完全是定量的和形式化的，没有主观或基于意见的陈述。\n- **完整性和一致性**：问题是自洽的。提供了三个测试用例所需的所有数据。理论框架内部是一致的；例如，MO 和密度矩阵的构建正确地导出了总电子数为 8，与价电子总数相匹配。\n- **可行性**：该计算虽然计算量很大（特别是 Bader 分析），但在现代硬件上是完全可以在合理的时间内完成的。指定的模型和参数对于一个教学示例是物理上合理的。\n\n### 步骤 3：结论和行动\n\n该问题是有效的。它是一个定义明确、有科学依据且客观的计算任务。我将继续提供一个完整的解决方案。\n\n### 解决方案\n\n解决方案是通过遵循问题陈述中指定的操作序列来实现的。代码的架构设计为模块化，使用不同的函数处理计算的每个主要步骤，以保证清晰性和正确性。\n\n1.  **系统设置**：首先建立甲烷的几何结构，碳原子在原点，四个氢原子按四面体结构放置在指定的键长 $1.09\\,\\mathrm{\\AA}$ 处。\n\n2.  **矩阵构建**：\n    - 使用提供的 $s$ 型高斯重叠解析公式计算 $5 \\times 5$ 的原子轨道**重叠矩阵** $S$。\n    - 构建 $5 \\times 4$ 的**正交 MO 系数矩阵** $M$（在 OAO 基下）。它的第一列代表全对称成键轨道，由给定的权重 $w_C$ 和 $w_H$ 构成然后归一化。其余三列被构造成相互正交，位于氢基函数子空间内，并与第一个 MO 正交，满足“氢组分之和为零”的规则。\n    - 通过对角化 $S$（$S = U\\Lambda U^T$），取其特征值的负二分之一次幂（$\\Lambda^{-1/2}$），然后变换回来（$X = U\\Lambda^{-1/2}U^T$），计算出**对称正交化矩阵** $X = S^{-1/2}$。\n    - **AO 基下的 MO 系数矩阵** 于是为 $C = X M$。\n    - 最后，计算**密度矩阵** $P = 2 C C^T$，其中因子 $2$ 考虑了四个已占据轨道中的自旋配对。\n\n3.  **Mulliken 布居分析**：这是一个基于矩阵的计算。原子 $A$ 上的 Mulliken 总原子布居数是乘积矩阵 $PS$ 对角线上对应于原子 $A$ 的基函数的元素之和。电荷是价电子数 $Z_A^{\\mathrm{val}}$ 与该布居数之差。\n\n4.  **基于网格的计算 (Hirshfeld 和 Bader)**：\n    - 在立方体 $[-3.0, 3.0]^3\\,\\mathrm{\\AA}^3$ 内生成一个均匀的 3D 网格。\n    - 在每个网格点上计算分子电子密度 $\\rho(\\mathbf{r})$。设计一个辅助类 `DensityHandler`，通过预先计算高斯乘积法则中的项来高效地计算任意点上的 $\\rho(\\mathbf{r})$ 及其梯度 $\\nabla\\rho(\\mathbf{r})$。\n    - 通过数值积分计算网格体积内的总电子数。然后对密度进行均匀重新缩放，使得总积分电荷等于精确的电子数 $8$，以校正有限网格误差。此重缩放后的密度 $\\tilde{\\rho}(\\mathbf{r})$ 用于所有后续的布居分析。\n\n5.  **Hirshfeld 电荷计算**：\n    - 在网格上为每个原子计算前原子密度 $\\rho_A^0(\\mathbf{r})$。\n    - 在每个网格点上计算 Hirshfeld 权重函数 $w_A(\\mathbf{r}) = \\rho_A^0(\\mathbf{r}) / \\sum_B \\rho_B^0(\\mathbf{r})$。\n    - 通过在网格上对分子密度 $\\tilde{\\rho}(\\mathbf{r})$ 乘以权重 $w_A(\\mathbf{r})$ 进行数值积分，找到 Hirshfeld 布居数 $N_A^{\\mathrm{H}}$。然后得到电荷 $q_A^{\\mathrm{H}}$。\n\n6.  **Bader 电荷计算**：\n    - 这是计算量最大的步骤。对每个网格点，在密度场 $\\rho(\\mathbf{r})$ 上执行离散梯度上升算法。\n    - 从网格点 $\\mathbf{r}_i$ 开始的轨迹被追踪，直到它终止于原子核附近（$\\rho$ 的一个最大值），其梯度变得可以忽略不计，或达到最大步数。然后将该网格点分配给相应原子核 $A$ 的原子盆 $\\Omega_A$。\n    - 一个特殊情况处理低密度区域，通过将密度 $\\rho  10^{-9}$ 的点分配给最近的原子核，而无需运行上升算法。\n    - Bader 布居数 $N_A^{\\mathrm{B}}$ 是分配给原子盆 $\\Omega_A$ 的所有网格点上的重缩放密度 $\\tilde{\\rho}(\\mathbf{r}_i)$ 之和，再乘以体素体积 $dV$。然后计算电荷 $q_A^{\\mathrm{B}}$。\n\n最后，为每个测试用例收集计算出的碳电荷和氢的平均电荷，四舍五入到三位小数，并格式化为所需的输出字符串。由于对称性，所有四个氢原子上的电荷是相同的，因此平均值就是其中任意一个的电荷。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# --- Constants and Configuration ---\nD_CH = 1.09  # Angstrom\nZ_VAL = np.array([4.0, 1.0, 1.0, 1.0, 1.0])  # C, H1, H2, H3, H4\nNUM_ELECTRONS = 8.0\nGRID_BOUNDS = 3.0\nGRID_SPACING = 0.5\nASCENT_STEP_SIZE = 0.2\nASCENT_MAX_STEPS = 60\nASCENT_DIST_THRESH = 0.3\nASCENT_GRAD_THRESH = 1e-8\nDENSITY_CUTOFF = 1e-9\n\ndef get_methane_geometry():\n    \"\"\"Returns the 5x3 array of atomic coordinates for methane.\"\"\"\n    R = np.zeros((5, 3))\n    scale = D_CH / np.sqrt(3.0)\n    R[1, :] = scale * np.array([1.0, 1.0, 1.0])\n    R[2, :] = scale * np.array([1.0, -1.0, -1.0])\n    R[3, :] = scale * np.array([-1.0, 1.0, -1.0])\n    R[4, :] = scale * np.array([-1.0, -1.0, 1.0])\n    return R\n\ndef calculate_s_matrix(R, alphas):\n    \"\"\"Calculates the 5x5 atomic orbital overlap matrix S.\"\"\"\n    num_basis = len(alphas)\n    S = np.zeros((num_basis, num_basis))\n    for mu in range(num_basis):\n        for nu in range(mu, num_basis):\n            alpha_mu, alpha_nu = alphas[mu], alphas[nu]\n            R_mu, R_nu = R[mu], R[nu]\n            \n            dist_sq = np.sum((R_mu - R_nu)**2)\n            alpha_sum = alpha_mu + alpha_nu\n            \n            term1 = (2 * np.sqrt(alpha_mu * alpha_nu) / alpha_sum)**1.5\n            term2 = np.exp(-alpha_mu * alpha_nu * dist_sq / alpha_sum)\n            \n            s_val = term1 * term2\n            S[mu, nu] = S[nu, mu] = s_val\n    return S\n\ndef calculate_m_matrix(w_C, w_H):\n    \"\"\"Constructs the 5x4 orthonormal MO coefficient matrix M.\"\"\"\n    M = np.zeros((5, 4))\n    \n    # Column 0: Totally symmetric MO\n    v0 = np.array([w_C, w_H / 2, w_H / 2, w_H / 2, w_H / 2])\n    M[:, 0] = v0 / np.linalg.norm(v0)\n    \n    # Columns 1, 2, 3: Mutually orthonormal H-based MOs\n    c1 = np.array([1., 1., -1., -1.]) / 2.0\n    c2 = np.array([1., -1., 1., -1.]) / 2.0\n    c3 = np.array([1., -1., -1., 1.]) / 2.0\n    \n    M[1:, 1] = c1\n    M[1:, 2] = c2\n    M[1:, 3] = c3\n    \n    return M\n\nclass DensityHandler:\n    \"\"\"Calculates electron density and its gradient.\"\"\"\n    def __init__(self, P, R, alphas):\n        self.P = P\n        self.R = R\n        self.alphas = alphas\n        self.num_basis = len(alphas)\n        \n        self.norm_factors = (2 * self.alphas / np.pi)**0.75\n        self.precompute_terms()\n\n    def precompute_terms(self):\n        \"\"\"Precomputes terms for the Gaussian product rule.\"\"\"\n        self.gamma = np.add.outer(self.alphas, self.alphas)\n        \n        R_mu_w = self.alphas[:, np.newaxis] * self.R\n        self.Rp = (R_mu_w[:, np.newaxis, :] + R_mu_w[np.newaxis, :, :]) / self.gamma[..., np.newaxis]\n        \n        R_dist_sq = np.sum((self.R[:, np.newaxis, :] - self.R[np.newaxis, :, :])**2, axis=-1)\n        exp_term = np.exp(-(self.alphas[:, np.newaxis] * self.alphas) / self.gamma * R_dist_sq)\n        norm_prod = np.outer(self.norm_factors, self.norm_factors)\n        self.K = norm_prod * exp_term\n\n    def _get_gauss_prod(self, r_points):\n        r_points = np.atleast_2d(r_points) # Ensure (N,3)\n        # (N,1,1,3) - (1,M,M,3) -> (N,M,M,3)\n        r_minus_Rp = r_points[:, np.newaxis, np.newaxis, :] - self.Rp[np.newaxis, ...]\n        dist_sq = np.sum(r_minus_Rp**2, axis=-1) # (N,M,M)\n        \n        # (1,M,M) * exp(-(1,M,M) * (N,M,M)) -> (N,M,M)\n        gauss_prod_val = self.K[np.newaxis, ...] * np.exp(-self.gamma[np.newaxis, ...] * dist_sq)\n        return gauss_prod_val, r_minus_Rp\n\n    def rho(self, r_points):\n        gauss_prod_val, _ = self._get_gauss_prod(r_points)\n        # (1,M,M) * (N,M,M) -> (N,M,M)\n        density_contrib = self.P[np.newaxis, ...] * gauss_prod_val\n        return np.sum(density_contrib, axis=(1, 2))\n\n    def grad_rho(self, r_points):\n        gauss_prod_val, r_minus_Rp = self._get_gauss_prod(r_points)\n\n        # (N,M,M,1) * (1,M,M,1) * (N,M,M,3) -> (N,M,M,3)\n        grad_G = gauss_prod_val[..., np.newaxis] * (\n                   -2 * self.gamma[np.newaxis, ..., np.newaxis] * r_minus_Rp)\n        \n        # (1,M,M,1) * (N,M,M,3) -> (N,M,M,3)\n        grad_rho_contrib = self.P[np.newaxis, ..., np.newaxis] * grad_G\n        return np.sum(grad_rho_contrib, axis=(1, 2))\n\ndef calculate_charges_for_case(params):\n    \"\"\"Main function to compute all charges for a single parameter set.\"\"\"\n    alpha_C, alpha_H, w_C, w_H, beta_C, beta_H = params\n    R = get_methane_geometry()\n    alphas = np.array([alpha_C] + [alpha_H] * 4)\n    betas = np.array([beta_C] + [beta_H] * 4)\n\n    # --- Step 1: Matrix Calculations and Mulliken Charges ---\n    S = calculate_s_matrix(R, alphas)\n    M = calculate_m_matrix(w_C, w_H)\n    \n    eigvals, eigvecs = np.linalg.eigh(S)\n    S_inv_sqrt = eigvecs @ np.diag(1.0 / np.sqrt(eigvals)) @ eigvecs.T\n    \n    C = S_inv_sqrt @ M\n    P = 2 * C @ C.T\n    \n    PS = P @ S\n    q_C_M = Z_VAL[0] - PS[0, 0]\n    q_H_M_avg = Z_VAL[1] - np.mean(np.diag(PS)[1:])\n\n    # --- Step 2: Grid Setup and Density Calculation ---\n    grid_1d = np.arange(GRID_BOUNDS, -GRID_BOUNDS - GRID_SPACING/2, -GRID_SPACING)[::-1]\n    grid_points = np.stack(np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij'), axis=-1).reshape(-1, 3)\n    dV = GRID_SPACING**3\n    \n    density_calc = DensityHandler(P, R, alphas)\n    rho_on_grid = density_calc.rho(grid_points)\n    \n    total_electrons_in_box = np.sum(rho_on_grid) * dV\n    rho_tilde_on_grid = rho_on_grid * (NUM_ELECTRONS / total_electrons_in_box)\n\n    # --- Step 3: Hirshfeld Charges ---\n    pro_atom_densities = np.zeros((len(R), len(grid_points)))\n    for i in range(len(R)):\n        dist_sq = np.sum((grid_points - R[i])**2, axis=1)\n        g_A = (2 * betas[i] / np.pi)**1.5 * np.exp(-2 * betas[i] * dist_sq)\n        pro_atom_densities[i, :] = Z_VAL[i] * g_A\n        \n    pro_molecule_density = np.sum(pro_atom_densities, axis=0)\n    # Avoid division by zero in empty space\n    pro_molecule_density[pro_molecule_density  1e-12] = 1.0\n    \n    hirshfeld_weights = pro_atom_densities / pro_molecule_density[np.newaxis, :]\n    \n    N_H_all = np.sum(hirshfeld_weights * rho_tilde_on_grid, axis=1) * dV\n    q_H = Z_VAL - N_H_all\n    q_C_H = q_H[0]\n    q_H_H_avg = np.mean(q_H[1:])\n\n    # --- Step 4: Bader Charges ---\n    basin_assignments = -np.ones(len(grid_points), dtype=int)\n    \n    dist_to_nuclei = np.linalg.norm(grid_points[:, np.newaxis, :] - R[np.newaxis, :, :], axis=2)\n    nearest_nucleus = np.argmin(dist_to_nuclei, axis=1)\n    \n    for i in range(len(grid_points)):\n        if rho_on_grid[i]  DENSITY_CUTOFF:\n            basin_assignments[i] = nearest_nucleus[i]\n            continue\n            \n        r_current = grid_points[i]\n        \n        for _ in range(ASCENT_MAX_STEPS):\n            grad = density_calc.grad_rho(r_current)[0]\n            grad_norm = np.linalg.norm(grad)\n\n            if grad_norm  ASCENT_GRAD_THRESH:\n                break\n            \n            r_current = r_current + ASCENT_STEP_SIZE * grad / grad_norm\n            \n            dists = np.linalg.norm(r_current - R, axis=1)\n            if np.min(dists)  ASCENT_DIST_THRESH:\n                break\n        \n        basin_assignments[i] = np.argmin(np.linalg.norm(r_current - R, axis=1))\n\n    N_B_all = np.zeros(len(R))\n    for i in range(len(R)):\n        mask = (basin_assignments == i)\n        N_B_all[i] = np.sum(rho_tilde_on_grid[mask]) * dV\n        \n    q_B = Z_VAL - N_B_all\n    q_C_B = q_B[0]\n    q_H_B_avg = np.mean(q_B[1:])\n\n    return [q_C_M, q_H_M_avg, q_C_H, q_H_H_avg, q_C_B, q_H_B_avg]\n\ndef solve():\n    \"\"\"Main solver function to run all test cases and print results.\"\"\"\n    test_cases = [\n        # (alpha_C, alpha_H, w_C, w_H, beta_C, beta_H)\n        (0.8, 1.2, 0.8, 0.6, 0.7, 1.0),\n        (0.6, 2.0, 0.7, 0.6, 0.7, 1.2),\n        (0.3, 0.4, 0.8, 0.4, 0.5, 0.7),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        results = calculate_charges_for_case(params)\n        all_results.extend(results)\n\n    print(f\"[{','.join(f'{r:.3f}' for r in all_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "最后的这项实践将我们的视野从分子的原子电荷扩展到周期性体系中的键级分析，这是研究表面和块状材料的一项关键技能。您将使用一个表面-吸附物体系模型，探索晶体轨道哈密顿布居（Crystal Orbital Hamilton Population, COHP）这一量化键强度的有力工具。核心任务是研究积分COHP（ICOHP）相对于$k$点采样的数值收敛性，这是确保固态电子结构计算可靠性的一项基本技能 。",
            "id": "3869077",
            "problem": "给定一个模型问题，用以评估一个二维表面-吸附物体系的晶体轨道哈密顿布居 (COHP) 和积分COHP (ICOHP) 相对于布里渊区 (BZ) 采样密度的收敛性。任务是实现一个程序，对于几组指定的参数集，确定沿每个倒易晶格方向所需的最小$k$点数（即最小网格尺寸），在该网格下ICOHP根据一个预设的判据达到收敛。\n\n基本依据包括以下定义和经过充分检验的事实：\n- 在周期性体系中，一个量在布里渊区 (BZ) 上的$k$空间积分被定义为在该布里渊区区域上的平均值。对于二维晶体，第一布里渊区可以参数化为一个方形区域 $[-\\pi,\\pi]\\times[-\\pi,\\pi]$，总面积为 $A_{\\mathrm{BZ}} = (2\\pi)^2$，其中角度以弧度为单位。\n- 使用包含 $N\\times N$ 个点、间距为 $\\Delta k = \\frac{2\\pi}{N}$ 的均匀网格，在中心点 $k_x(i) = -\\pi + \\left(i + \\tfrac{1}{2}\\right)\\Delta k$，$k_y(j) = -\\pi + \\left(j + \\tfrac{1}{2}\\right)\\Delta k$（其中 $i,j \\in \\{0,\\dots,N-1\\}$）上计算的黎曼和，是布里渊区积分的一个一致近似。在 $N\\to\\infty$ 的极限下，对于均匀采样，离散平均等于连续平均。\n- 在能量 $E$ 和波矢 $\\mathbf{k}=(k_x,k_y)$ 处的COHP被建模为 $ \\mathrm{COHP}(E,\\mathbf{k}) = -S\\,g(\\mathbf{k})\\,G\\!\\left(E - E_b(\\mathbf{k}); \\sigma\\right)$，其中 $S$ 是一个正的能量标度，$g(\\mathbf{k})$ 是一个无量纲的键权重因子，$E_b(\\mathbf{k})$ 是单能带色散关系，而 $G(x;\\sigma)$ 是一个归一化的高斯函数 $G(x;\\sigma) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right)$，代表了离散能级出于物理原因的展宽。直到费米能 $E_F$ 的积分COHP (ICOHP) 是COHP的能量积分：\n$$\n\\mathrm{ICOHP}(E_F) = \\frac{1}{A_{\\mathrm{BZ}}}\\int_{\\mathrm{BZ}}\\left[\\int_{-\\infty}^{E_F} \\mathrm{COHP}(E,\\mathbf{k})\\,\\mathrm{d}E\\right]\\mathrm{d}^2\\mathbf{k}.\n$$\n所有能量必须以电子伏特 (eV) 表示。\n\n对于本问题，使用以下具体模型：\n- 能带色散为 $E_b(\\mathbf{k}) = E_0 + t\\left[\\cos(k_x) + \\cos(k_y)\\right]$。\n- 键权重因子为 $g(\\mathbf{k}) = \\cos(k_x)\\cos(k_y) + \\alpha$。\n- 展宽 $G(x;\\sigma)$ 如上文所定义，宽度为 $\\sigma$。\n- 能量积分变量是费米能 $E_F$。\n\n对于给定的 $N$，使用在 $[-\\pi,\\pi]^2$ 上的 $N\\times N$ 均匀网格上的中点黎曼和来近似 $\\mathrm{ICOHP}(E_F)$：\n$$\n\\mathrm{ICOHP}_N(E_F) \\approx \\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left[-S\\,g\\!\\left(k_x(i),k_y(j)\\right)\\,\\Phi\\!\\left(\\frac{E_F - E_b\\!\\left(k_x(i),k_y(j)\\right)}{\\sigma}\\right)\\right],\n$$\n其中 $\\Phi(z) = \\tfrac{1}{2}\\left[1+\\mathrm{erf}\\!\\left(\\tfrac{z}{\\sqrt{2}}\\right)\\right]$ 是单位方差高斯分布的累积分布函数，而 $\\mathrm{erf}(\\cdot)$ 是高斯误差函数。注意高斯函数 $G$ 是归一化的，因此能量积分会产生累积因子 $\\Phi$。\n\n收敛判据：\n- 设 $\\{N_\\ell\\}$ 是一个递增的网格尺寸序列。定义 $I_\\ell = \\mathrm{ICOHP}_{N_\\ell}(E_F)$，单位为 eV。对于用户指定的容差 $\\varepsilon$（单位为 eV），如果对于某个 $\\ell \\ge 1$ 有 $\\left|I_{\\ell} - I_{\\ell-1}\\right| \\le \\varepsilon$，则在索引 $\\ell$ 处宣告收敛。最小收敛网格尺寸即为 $N_\\ell$。如果在提供的序列中不存在这样的 $\\ell$，则报告 $-1$。\n\n$k_x$ 和 $k_y$ 的角度必须以弧度为单位。能量和容差必须以电子伏特 (eV) 为单位。\n\n所有测试用例中使用的常量：\n- $S = 2.0$ eV,\n- $\\alpha = 0.15$ (无量纲),\n- 网格序列 $\\{N_\\ell\\} = \\{\\,4,\\,6,\\,8,\\,12,\\,16,\\,24,\\,32,\\,48,\\,64,\\,96\\,\\}$。\n\n测试套件：\n- 情况1 (平滑的能带占据): $E_0 = -5.0$ eV, $t = 1.0$ eV, $E_F = -5.0$ eV, $\\sigma = 0.30$ eV, $\\varepsilon = 1\\times 10^{-3}$ eV。\n- 情况2 (能量占据中的尖锐特征): $E_0 = -5.0$ eV, $t = 1.0$ eV, $E_F = -5.0$ eV, $\\sigma = 0.020$ eV, $\\varepsilon = 1\\times 10^{-3}$ eV。\n- 情况3 (费米能级靠近能带边缘): $E_0 = -5.0$ eV, $t = 1.0$ eV, $E_F = -6.90$ eV, $\\sigma = 0.050$ eV, $\\varepsilon = 1\\times 10^{-3}$ eV。\n- 情况4 (平带边缘情况): $E_0 = -5.0$ eV, $t = 0.0$ eV, $E_F = -5.0$ eV, $\\sigma = 0.10$ eV, $\\varepsilon = 1\\times 10^{-6}$ eV。\n\n你的程序必须：\n- 实现上述模型，并为每个测试用例，计算指定序列中每个 $N$ 对应的 $\\mathrm{ICOHP}_N(E_F)$。\n- 为每个用例确定满足收敛判据的最小 $N$（如果未达到，则为 $-1$）。\n- 生成单行输出，包含四个结果，格式为逗号分隔的整数列表，并用方括号括起来，例如 $[n_1,n_2,n_3,n_4]$。\n\n所有角度都必须按弧度处理，所有能量和容差都必须以电子伏特 (eV) 为单位。测试用例的最终输出必须是如上所述的整数，并且程序不得读取任何输入。",
            "solution": "提交审议的问题陈述是有效的。它有科学依据、良定、客观且内部一致，满足一个可解科学问题的所有标准。\n\n任务是确定积分晶体轨道哈密顿布居 ($\\mathrm{ICOHP}$) 收敛到指定容差 $\\varepsilon$ 所需的最小布里渊区 (BZ) 采样密度，该密度由 $N \\times N$ 的 $k$ 点网格表示。这是计算材料科学和固态物理学中的一个标准流程，用以确保数值结果与BZ离散化无关。\n\n解决方案的步骤是，首先实现一个函数来计算给定网格尺寸 $N$ 下的 $\\mathrm{ICOHP}$，然后对一个递增的 $N$ 序列应用收敛性测试。\n\n基本量是 $\\mathrm{ICOHP}$，定义为经过布里渊区平均和能量积分的 $\\mathrm{COHP}$：\n$$\n\\mathrm{ICOHP}(E_F) = \\frac{1}{A_{\\mathrm{BZ}}}\\int_{\\mathrm{BZ}}\\left[\\int_{-\\infty}^{E_F} \\mathrm{COHP}(E,\\mathbf{k})\\,\\mathrm{d}E\\right]\\mathrm{d}^2\\mathbf{k}\n$$\n该问题为 $\\mathrm{COHP}(E, \\mathbf{k})$ 提供了一个具体模型，并简化了能量积分。高斯展宽函数 $G(x; \\sigma) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp(-\\frac{x^2}{2\\sigma^2})$ 从 $-\\infty$ 到值 $X$ 的积分是其累积分布函数 (CDF)，由 $\\Phi(X/\\sigma)$ 给出，其中 $\\Phi(z) = \\frac{1}{2}[1+\\mathrm{erf}(\\frac{z}{\\sqrt{2}})]$。应用此关系，内层的能量积分变为：\n$$\n\\int_{-\\infty}^{E_F} \\mathrm{COHP}(E,\\mathbf{k})\\,\\mathrm{d}E = -S\\,g(\\mathbf{k})\\,\\Phi\\!\\left(\\frac{E_F - E_b(\\mathbf{k})}{\\sigma}\\right)\n$$\n布里渊区积分随后通过在均匀的 $N \\times N$ 中点网格上进行黎曼和来近似。布里渊区的面积为 $A_{\\mathrm{BZ}} = (2\\pi)^2$。对于一个 $N \\times N$ 点的均匀网格，每个点的面积元为 $\\Delta k_x \\Delta k_y = (\\frac{2\\pi}{N})^2$。布里渊区平均积分变成了对网格点上的值的简单算术平均：\n$$\n\\mathrm{ICOHP}_N(E_F) \\approx \\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left[-S\\,g\\!\\left(k_x(i),k_y(j)\\right)\\,\\Phi\\!\\left(\\frac{E_F - E_b\\!\\left(k_x(i),k_y(j)\\right)}{\\sigma}\\right)\\right]\n$$\n这就是需要实现的表达式。$k$点定义为 $k_x(i) = -\\pi + (i + \\frac{1}{2})\\Delta k$ 和 $k_y(j) = -\\pi + (j + \\frac{1}{2})\\Delta k$，其中 $\\Delta k = \\frac{2\\pi}{N}$。色散模型函数 $E_b(\\mathbf{k}) = E_0 + t[\\cos(k_x) + \\cos(k_y)]$ 和键权重函数 $g(\\mathbf{k}) = \\cos(k_x)\\cos(k_y) + \\alpha$ 被代入此公式。\n\n计算算法的结构如下：\n1.  定义一个函数 `calculate_icohp`，它接受网格尺寸 $N$ 和物理参数 $(E_0, t, E_F, \\sigma, S, \\alpha)$ 作为输入。该函数将执行以下步骤：\n    a.  使用中点规则生成一维 $k$ 点的一维数组，范围从 $-\\pi$ 到 $\\pi$。\n    b.  使用网格生成函数（`numpy.meshgrid`）为整个布里渊区创建二维的 $k_x$ 和 $k_y$ 数组。\n    c.  以向量化的方式计算网格上每个点的能带色散 $E_b(\\mathbf{k})$ 和键权重因子 $g(\\mathbf{k})$。\n    d.  计算累积分布函数(CDF)的自变量，$z(\\mathbf{k}) = (E_F - E_b(\\mathbf{k}))/\\sigma$。\n    e.  使用提供的误差函数 `scipy.special.erf` 评估累积分布函数 $\\Phi(z(\\mathbf{k}))$。\n    f.  组合所有项，计算每个 $\\mathbf{k}$ 点的被加项：$-S \\cdot g(\\mathbf{k}) \\cdot \\Phi(z(\\mathbf{k}))$。\n    g.  将所有点的贡献求和，然后除以 $N^2$ 以获得 $\\mathrm{ICOHP}_N(E_F)$。\n\n2.  对于每个测试用例，遍历指定的网格尺寸序列 $\\{N_\\ell\\} = \\{4, 6, 8, \\dots, 96\\}$。\n    a.  通过计算第一个网格尺寸 $N_0 = 4$ 对应的 $\\mathrm{ICOHP}$ 来初始化循环。设其为 $I_0$。\n    b.  对于每个后续的网格尺寸 $N_\\ell$（其中 $\\ell = 1, 2, \\dots$），计算相应的 $\\mathrm{ICOHP}$ 值 $I_\\ell$。\n    c.  检查收敛判据：$|\\,I_\\ell - I_{\\ell-1}\\,| \\le \\varepsilon$。\n    d.  如果满足判据，则最小收敛网格尺寸为 $N_\\ell$。记录该值并终止当前测试用例的搜索。\n    e.  如果未满足判据，则更新前一个值，$I_{\\ell-1} \\leftarrow I_\\ell$，并继续处理下一个网格尺寸。\n    f.  如果在序列末尾仍未达到收敛，则按规定为该测试用例记录值 $-1$。\n\n3.  当跃迁参数 $t=0$ 时（情况4），出现一个特殊情况。能带是平的：$E_b(\\mathbf{k}) = E_0$。因此，CDF项 $\\Phi(\\dots)$ 在整个布里渊区上是一个常数。$\\mathrm{ICOHP}_N$ 表达式简化为 $-S \\cdot g(\\mathbf{k})$ 的布里渊区平均值乘以该常数。对于偶数 $N$ 的对称中点网格，$g(\\mathbf{k}) = \\cos(k_x)\\cos(k_y) + \\alpha$ 的布里渊区平均值恰好是 $\\alpha$，因为 $\\cos(k_x)$ 和 $\\cos(k_y)$ 的平均值为零。因此，对于情况4，$\\mathrm{ICOHP}_N$ 与 $N$ 无关。差值 $|I_\\ell - I_{\\ell-1}|$ 恒等于零，因此在第一次检查时（即 $\\ell=1$）就满足收敛，得到最小收敛网格尺寸 $N_1 = 6$。\n\n来自所有四个测试用例的结果被收集到一个列表中，并格式化为单行字符串以供输出。这个过程是确定性的，并直接实现了问题中描述的物理和数值方法。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Calculates the minimal converged k-point mesh size for ICOHP\n    based on a model 2D system for several test cases.\n    \"\"\"\n\n    def calculate_icohp(N, E0, t, EF, sigma, S, alpha):\n        \"\"\"\n        Calculates ICOHP_N(EF) using a Riemann sum over an N x N k-point grid.\n\n        Args:\n            N (int): The number of k-points along one dimension of the BZ.\n            E0 (float): Constant energy offset in eV.\n            t (float): Hopping parameter in eV.\n            EF (float): Fermi energy in eV.\n            sigma (float): Gaussian broadening width in eV.\n            S (float): Energy scale constant in eV.\n            alpha (float): Dimensionless bond-weight constant.\n\n        Returns:\n            float: The calculated ICOHP value in eV.\n        \"\"\"\n        # A flat band (t=0) with symmetric k-sampling results in a constant ICOHP\n        # that is independent of N. The average of cos(kx)cos(ky) over the grid is 0.\n        # The average of g(k) is then just alpha.\n        if t == 0.0:\n            z = (EF - E0) / sigma\n            phi = 0.5 * (1.0 + erf(z / np.sqrt(2)))\n            return -S * alpha * phi\n            \n        # Create k-point grid using the midpoint rule on [-pi, pi]\n        delta_k = 2.0 * np.pi / N\n        k_pts_1d = -np.pi + (np.arange(N) + 0.5) * delta_k\n        kx, ky = np.meshgrid(k_pts_1d, k_pts_1d)\n\n        # Calculate band dispersion for each k-point\n        # E_b(k) = E0 + t * [cos(kx) + cos(ky)]\n        E_b = E0 + t * (np.cos(kx) + np.cos(ky))\n\n        # Calculate bond-weight factor for each k-point\n        # g(k) = cos(kx)cos(ky) + alpha\n        g = np.cos(kx) * np.cos(ky) + alpha\n\n        # Calculate the argument for the cumulative distribution function (CDF)\n        z = (EF - E_b) / sigma\n\n        # Calculate the CDF of the standard normal distribution\n        # Phi(z) = 0.5 * [1 + erf(z / sqrt(2))]\n        phi = 0.5 * (1.0 + erf(z / np.sqrt(2.0)))\n\n        # Sum the contributions from all k-points\n        # The sum is divided by N^2 to get the average over the BZ.\n        icohp_sum = np.sum(-S * g * phi)\n        icohp_N = icohp_sum / (N * N)\n\n        return icohp_N\n\n    # Global constants defined in the problem\n    S = 2.0\n    alpha = 0.15\n    N_sequence = [4, 6, 8, 12, 16, 24, 32, 48, 64, 96]\n\n    # Test suite parameters: (E0, t, EF, sigma, epsilon)\n    test_cases = [\n        (-5.0, 1.0, -5.0, 0.30,  1e-3),   # Case 1: smooth band occupation\n        (-5.0, 1.0, -5.0, 0.020, 1e-3),   # Case 2: sharp features in energy occupation\n        (-5.0, 1.0, -6.90, 0.050, 1e-3),   # Case 3: Fermi level near band edge\n        (-5.0, 0.0, -5.0, 0.10,  1e-6),   # Case 4: flat band edge case\n    ]\n\n    final_results = []\n\n    for case_params in test_cases:\n        E0, t, EF, sigma, epsilon = case_params\n        converged_N = -1\n        \n        # Calculate ICOHP for the first mesh size N_0\n        prev_icohp = calculate_icohp(N_sequence[0], E0, t, EF, sigma, S, alpha)\n\n        # Iterate through the rest of the mesh sequence to check for convergence\n        for i in range(1, len(N_sequence)):\n            N_current = N_sequence[i]\n            current_icohp = calculate_icohp(N_current, E0, t, EF, sigma, S, alpha)\n            \n            # Convergence criterion: |I_l - I_{l-1}| = epsilon\n            if abs(current_icohp - prev_icohp) = epsilon:\n                converged_N = N_current\n                break  # Minimal converged N found, move to the next test case\n\n            prev_icohp = current_icohp\n\n        final_results.append(converged_N)\n\n    # Produce the single line of output in the required format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}