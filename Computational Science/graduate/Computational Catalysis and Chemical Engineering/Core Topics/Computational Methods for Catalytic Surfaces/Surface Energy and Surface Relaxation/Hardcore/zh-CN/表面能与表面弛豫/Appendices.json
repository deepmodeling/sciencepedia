{
    "hands_on_practices": [
        {
            "introduction": "计算表面能是计算催化和表面科学中的一项基本技能。本练习将指导您从热力学第一性原理出发，推导出计算对称晶格表面能的核心公式。您将通过处理一系列模拟的密度泛函理论（DFT）计算数据，学习如何量化表面弛豫效应，并采用外推法消除有限尺寸效应，从而获得收敛的表面能值 。这个实践将为您提供在真实研究中执行和分析表面能计算所必需的基础工作流程。",
            "id": "3901262",
            "problem": "您的任务是设计并实现密度泛函理论 (DFT) 中使用的标准平板方法，用以计算对称平板的表面自由能，并量化表面弛豫的影响。请从表面自由能的基本定义出发，即在固定组分下，从体相晶体中创造出表面所需的单位面积可逆功。对于在周期性边界条件下具有两个相同表面的对称平板，其超额能量完全来自于这些表面的存在。利用此定义和基本的能量衡算，推导对称平板表面自由能的表达式，该表达式应以总能量和面积表示。请勿使用任何简化公式；需从第一性原理出发推导该表达式，并以算法形式实现。\n\n接着，设计一个流程来消除平板厚度方向上的有限尺寸效应。该流程应基于一个渐近论证，即两个表面之间的相互作用会随着平板厚度的增加而衰减。实现一个将计算出的表面自由能对原子数倒数进行线性回归的方法，以此外推出无限厚度的极限值。通过分别使用未弛豫和已弛豫的平板能量，来包含原子弛豫效应，并量化由弛豫引起的表面自由能的降低值。\n\n您的程序必须为每个测试用例执行以下步骤：\n- 给定原子数 $N$ 的列表、每个原子的体相能量 $E_{\\text{bulk}}$ (单位为电子伏特, $\\text{eV}$)、未弛豫和已弛豫两种构型的平板总能量 $E_{\\text{slab}}(N)$ (单位为电子伏特, $\\text{eV}$)，以及表面积 $A$ (单位为平方埃, $\\text{\\AA}^2$)，请为未弛豫和已弛豫两组数据，计算出每个 $N$ 值对应的单位面积表面自由能。请使用具有物理依据的对称平板解释来推导并应用正确的表达式。\n- 将所有计算出的表面能从电子伏特/平方埃 ($\\text{eV}/\\text{\\AA}^2$) 转换为焦耳/平方米 ($\\text{J}/\\text{m}^2$)。使用换算关系 $1$ 电子伏特 ($\\text{eV}$) $= 1.602176634\\times 10^{-19}$ 焦耳 ($\\text{J}$) 和 $1$ 平方埃 ($\\text{\\AA}^2$) $= 10^{-20}$ 平方米 ($\\text{m}^2$)。\n- 使用线性模型对表面自由能值（针对已弛豫集合）作为 $1/N$ 的函数进行拟合，以估算无限厚度极限 $\\gamma_{\\infty}$（即 $1/N \\to 0$ 时的截距），结果以焦耳/平方米 ($\\text{J}/\\text{m}^2$) 表示。类似地，对未弛豫集合进行拟合以估算其无限厚度极限，并报告由弛豫引起的能量降低值，该值定义为正数 $\\Delta \\gamma = \\gamma_{\\infty}^{\\text{unrelaxed}} - \\gamma_{\\infty}^{\\text{relaxed}}$。\n- 为已弛豫集合确定一个布尔收敛指示符，其定义为 $\\max_{N} |\\gamma_{\\text{relaxed}}(N) - \\gamma_{\\infty}^{\\text{relaxed}}|  T$，其中 $T$ 是设为 $0.05$ 焦耳/平方米 ($\\text{J}/\\text{m}^2$) 的容差。如果不等式成立，则返回 $\\text{True}$；否则返回 $\\text{False}$。\n\n将所有最终的表面能以焦耳/平方米 ($\\text{J}/\\text{m}^2$) 为单位表示，并四舍五入到三位小数，收敛指示符表示为布尔值。不涉及角度，因此不需要角度单位。\n\n测试套件参数：\n- 案例 1 (正常路径，中等有限尺寸效应)：\n  - $A = 58.4$ $\\text{\\AA}^2$\n  - $E_{\\text{bulk}} = -3.91$ $\\text{eV}$\n  - $N \\in \\{24, 28, 32, 36, 40\\}$\n  - $E_{\\text{slab}}^{\\text{unrelaxed}}(N)$ (单位：$\\text{eV}$): $\\{-84.371, -100.028857143, -115.68225, -131.332666667, -146.981\\}$\n  - $E_{\\text{slab}}^{\\text{relaxed}}(N)$ (单位：$\\text{eV}$): $\\{-86.0687, -101.717628571, -117.364325, -133.009533333, -148.6537\\}$\n- 案例 2 (边界情况，小 $N$ 值时有强有限尺寸效应)：\n  - $A = 25.0$ $\\text{\\AA}^2$\n  - $E_{\\text{bulk}} = -7.10$ $\\text{eV}$\n  - $N \\in \\{8, 10, 12, 14\\}$\n  - $E_{\\text{slab}}^{\\text{unrelaxed}}(N)$ (单位：$\\text{eV}$): $\\{-48.55, -62.9, -77.2, -91.4714286\\}$\n  - $E_{\\text{slab}}^{\\text{relaxed}}(N)$ (单位：$\\text{eV}$): $\\{-50.425, -64.7, -78.95, -93.1857143\\}$\n- 案例 3 (边缘情况，大 $N$ 值时接近收敛)：\n  - $A = 92.0$ $\\text{\\AA}^2$\n  - $E_{\\text{bulk}} = -5.50$ $\\text{eV}$\n  - $N \\in \\{54, 60, 66, 72\\}$\n  - $E_{\\text{slab}}^{\\text{unrelaxed}}(N)$ (单位：$\\text{eV}$): $\\{-287.2368889, -320.238, -353.2389091, -386.2396667\\}$\n  - $E_{\\text{slab}}^{\\text{relaxed}}(N)$ (单位：$\\text{eV}$): $\\{-287.7925926, -320.7933333, -353.7939394, -386.7944444\\}$\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例产生一个包含三个元素的列表 $[\\gamma_{\\infty}^{\\text{relaxed}}, \\Delta \\gamma, \\text{converged}]$。例如，输出格式必须严格遵循：$\\big[[\\gamma_1, \\Delta\\gamma_1, \\text{bool}_1],[\\gamma_2, \\Delta\\gamma_2, \\text{bool}_2],[\\gamma_3, \\Delta\\gamma_3, \\text{bool}_3]\\big]$，所有 $\\gamma$ 值均以 $\\text{J}/\\text{m}^2$ 为单位，四舍五入到三位小数，布尔值以编程语言的规范布尔格式打印。",
            "solution": "该问题要求计算对称平板的表面自由能，并包含表面弛豫和有限尺寸误差的影响。整个流程基于热力学和固态物理学的基本原理，并应用于密度泛函理论 (DFT) 计算中。\n\n首先，我们必须从第一性原理出发，推导表面自由能 $\\gamma$ 的表达式。表面自由能的定义是，在恒温、恒压和恒定化学组分的条件下，创造一个新表面所需的单位面积可逆功。对于温度为 $0$ 开尔文的固态系统（这是基态 DFT 计算的标准设置），吉布斯自由能的变化简化为总内能的变化。\n\n考虑一个体相晶体。该晶体中包含 $N$ 个原子的部分的总能量可以表示为 $N \\cdot E_{\\text{bulk}}$，其中 $E_{\\text{bulk}}$ 是体相材料中每个原子的能量。现在，假设我们切割该晶体，创造一个包含 $N$ 个原子、具有两个相同表面（每个表面积为 $A$）的平板。这个新系统的总能量是平板能量 $E_{\\text{slab}}(N)$。创造这两个表面需要能量，即表面能。与体相中等量原子相比，该平板的总超额能量由下式给出：\n$$\n\\Delta E = E_{\\text{slab}}(N) - N \\cdot E_{\\text{bulk}}\n$$\n这个超额能量 $\\Delta E$ 是创造两个表面的能量代价。根据定义，该能量也等于 $2\\gamma A$，其中因子 $2$ 是因为对称平板有两个相同的表面。\n$$\n2\\gamma A = E_{\\text{slab}}(N) - N \\cdot E_{\\text{bulk}}\n$$\n求解表面自由能 $\\gamma$，我们得到计算的核心方程，它依赖于原子数（或层数）$N$：\n$$\n\\gamma(N) = \\frac{E_{\\text{slab}}(N) - N \\cdot E_{\\text{bulk}}}{2A}\n$$\n根据所提供的输入，此计算的单位将是电子伏特/平方埃 ($\\text{eV}/\\text{\\AA}^2$)。我们需要将其转换为国际单位制中的焦耳/平方米 ($\\text{J}/\\text{m}^2$)。给出的换算因子为 $1 \\text{ eV} = 1.602176634 \\times 10^{-19} \\text{ J}$ 和 $1 \\text{ \\AA} = 10^{-10} \\text{ m}$，这意味着 $1 \\text{ \\AA}^2 = 10^{-20} \\text{ m}^2$。因此，换算因子为：\n$$\n\\frac{1 \\text{ eV}}{1 \\text{ \\AA}^2} = \\frac{1.602176634 \\times 10^{-19} \\text{ J}}{10^{-20} \\text{ m}^2} = 16.02176634 \\frac{\\text{J}}{\\text{m}^2}\n$$\n在实践中，平板的 DFT 计算会受到有限尺寸效应的影响。一个有限厚度 $N$ 的平板具有两个表面，它们可以通过平板的体相部分相互作用。这种相互作用能通常随平板厚度的增加而衰减。一个常见的近似是，这种残余相互作用能，以及由此导致的计算表面能的误差，与平板厚度的倒数成正比。在表面积恒定的情况下，这等效于与原子数倒数 $1/N$ 成正比。这导出了一个渐近关系：\n$$\n\\gamma(N) \\approx \\gamma_{\\infty} + \\frac{m}{N}\n$$\n其中 $\\gamma_{\\infty}$ 是无限厚度极限 ($N \\to \\infty$) 下的真实表面能，而 $m$ 是一个与两个表面间相互作用相关的常数。为了确定 $\\gamma_{\\infty}$，我们可以计算一系列递增平板厚度 ($N_1, N_2, \\dots$) 下的 $\\gamma(N)$，并对数据点 $(\\frac{1}{N_i}, \\gamma(N_i))$ 进行线性回归。所得直线的 y 轴截距即为外推值 $\\gamma_{\\infty}$。\n\n此流程应用于两组平板能量：一组用于未弛豫平板，其中原子固定在其体相截断位置 ($E_{\\text{slab}}^{\\text{unrelaxed}}$)；另一组用于已弛豫平板，其中原子被允许移动以最小化总能量 ($E_{\\text{slab}}^{\\text{relaxed}}$)。这使得量化表面弛豫效应成为可能。未弛豫情况下的外推表面能记为 $\\gamma_{\\infty}^{\\text{unrelaxed}}$，已弛豫情况下的记为 $\\gamma_{\\infty}^{\\text{relaxed}}$。由弛豫引起的表面自由能降低量则为：\n$$\n\\Delta \\gamma = \\gamma_{\\infty}^{\\text{unrelaxed}} - \\gamma_{\\infty}^{\\text{relaxed}}\n$$\n从物理上讲，弛豫使表面原子能够找到能量更低的位置，因此我们预期 $\\Delta \\gamma  0$。\n\n最后，我们必须评估计算所得的已弛豫表面能相对于平板厚度的收敛性。如果任何有限厚度表面能与外推的无限厚度值之间的最大绝对偏差小于给定容差 $T$，则收敛指示符定义为 $\\text{True}$。\n$$\n\\text{converged} = \\left( \\max_{N} |\\gamma_{\\text{relaxed}}(N) - \\gamma_{\\infty}^{\\text{relaxed}}|  T \\right)\n$$\n对于此问题，容差被指定为 $T = 0.05 \\text{ J}/\\text{m}^2$。\n\n每个测试用例的算法如下：\n1. 对于未弛豫和已弛豫数据集，使用推导出的公式为每个给定的原子数 $N$ 计算表面能 $\\gamma(N)$。\n2. 将所有计算出的 $\\gamma(N)$ 值从 $\\text{eV}/\\text{\\AA}^2$ 转换为 $\\text{J}/\\text{m}^2$。\n3. 准备用于线性回归的数据：$x$ 值为 $1/N$，$y$ 值为相应的 $\\gamma(N)$。\n4. 对两个数据集执行线性回归，以找到截距 $\\gamma_{\\infty}^{\\text{unrelaxed}}$ 和 $\\gamma_{\\infty}^{\\text{relaxed}}$。\n5. 计算弛豫能量差 $\\Delta \\gamma = \\gamma_{\\infty}^{\\text{unrelaxed}} - \\gamma_{\\infty}^{\\text{relaxed}}$。\n6. 通过找出有限厚度已弛豫能量与外推值 $\\gamma_{\\infty}^{\\text{relaxed}}$ 之间的最大绝对差，并将其与容差 $T = 0.05 \\text{ J}/\\text{m}^2$ 进行比较，来确定收敛布尔值。\n7. 整理结果 $[\\gamma_{\\infty}^{\\text{relaxed}}, \\Delta \\gamma, \\text{converged}]$，并将能量值四舍五入到三位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the surface energy problem for the given test cases.\n    \"\"\"\n    \n    # Conversion constant from eV/Angstrom^2 to J/m^2\n    EV_PER_A2_TO_J_PER_M2 = 1.602176634e-19 / 1e-20\n    \n    # Convergence tolerance in J/m^2\n    TOLERANCE = 0.05\n\n    test_cases = [\n        {\n            \"A\": 58.4,\n            \"E_bulk\": -3.91,\n            \"N\": np.array([24, 28, 32, 36, 40]),\n            \"E_slab_unrelaxed\": np.array([-84.371, -100.028857143, -115.68225, -131.332666667, -146.981]),\n            \"E_slab_relaxed\": np.array([-86.0687, -101.717628571, -117.364325, -133.009533333, -148.6537]),\n        },\n        {\n            \"A\": 25.0,\n            \"E_bulk\": -7.10,\n            \"N\": np.array([8, 10, 12, 14]),\n            \"E_slab_unrelaxed\": np.array([-48.55, -62.9, -77.2, -91.4714286]),\n            \"E_slab_relaxed\": np.array([-50.425, -64.7, -78.95, -93.1857143]),\n        },\n        {\n            \"A\": 92.0,\n            \"E_bulk\": -5.50,\n            \"N\": np.array([54, 60, 66, 72]),\n            \"E_slab_unrelaxed\": np.array([-287.2368889, -320.238, -353.2389091, -386.2396667]),\n            \"E_slab_relaxed\": np.array([-287.7925926, -320.7933333, -353.7939394, -386.7944444]),\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N_vals = case[\"N\"]\n        E_bulk_per_atom = case[\"E_bulk\"]\n        area = case[\"A\"]\n        \n        # Calculate surface energy for unrelaxed and relaxed slabs\n        def calculate_gamma_series(E_slab_series):\n            # Formula: gamma = (E_slab(N) - N * E_bulk) / (2 * A)\n            gamma_ev_a2 = (E_slab_series - N_vals * E_bulk_per_atom) / (2 * area)\n            return gamma_ev_a2 * EV_PER_A2_TO_J_PER_M2\n\n        gamma_unrelaxed_series = calculate_gamma_series(case[\"E_slab_unrelaxed\"])\n        gamma_relaxed_series = calculate_gamma_series(case[\"E_slab_relaxed\"])\n        \n        # Prepare data for linear regression: x = 1/N\n        inv_N = 1.0 / N_vals\n        \n        # Perform linear regression to find the intercept (gamma_infinity)\n        # np.polyfit(x, y, 1) returns [slope, intercept]\n        \n        # Unrelaxed fit\n        _, gamma_inf_unrelaxed = np.polyfit(inv_N, gamma_unrelaxed_series, 1)\n        \n        # Relaxed fit\n        _, gamma_inf_relaxed = np.polyfit(inv_N, gamma_relaxed_series, 1)\n        \n        # Calculate relaxation-induced decrease in surface energy\n        delta_gamma = gamma_inf_unrelaxed - gamma_inf_relaxed\n\n        # Determine convergence indicator for the relaxed set\n        max_deviation = np.max(np.abs(gamma_relaxed_series - gamma_inf_relaxed))\n        is_converged = max_deviation  TOLERANCE\n        \n        # Append results, rounding to three decimal places\n        results.append([\n            round(gamma_inf_relaxed, 3),\n            round(delta_gamma, 3),\n            is_converged\n        ])\n\n    # Final print statement in the exact required format.\n    # str(list) automatically adds spaces after commas, matching the implied format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了如何计算总弛豫能之后，下一步是深入探究表面弛豫的物理机制。本练习将让您构建一个简化的原子模型，通过最小化体系的总能量来主动计算原子层的位移 。您将使用一个包含多体相互作用的能量泛函，该泛函能够捕捉表面原子因配位数降低而产生的键合变化，从而直观地理解为何以及如何发生表面弛豫。这个动手实践有助于将抽象的“弛豫能”概念与具体的原子尺度力学行为联系起来。",
            "id": "3901280",
            "problem": "您的任务是实现一个计算程序，用于确定一维原子平板中的表面弛豫，该程序需与计算催化和化学工程中使用的基本原理保持一致。考虑一个由 $N$ 个原子层组成的平板，这些原子层沿笛卡尔坐标系的表面法线方向 $z$ 排列。未弛豫的、体相截断的构型的位置为 $z_i^{\\mathrm{bulk}} = (i-1)a_0$，其中 $i \\in \\{1,\\dots,N\\}$，$a_0$ 是体相层间距。底层的位置 $z_1$ 固定在 $z_1 = 0$ 以表示半无限衬底，而层 $i \\geq 2$ 允许沿 $z$ 方向弛豫。\n\n您的模型必须使用一种常用的多体能量泛函，以捕捉因表面附近配位数减少而产生的表面弛豫效应。设平板的总能量 $E(\\mathbf{z})$ 为\n$$\nE(\\mathbf{z}) = \\sum_{1 \\leq i  j \\leq N} \\phi\\!\\left(r_{ij}\\right) + \\sum_{i=1}^N F\\!\\left(\\rho_i\\right),\n$$\n其中 $r_{ij} = |z_i - z_j|$ 是层间距，$\\phi(r)$ 是对相互作用原子间势，$\\rho_i$ 是第 $i$ 层的局部配位数度量（电子密度），$F(\\rho)$ 是嵌入能。假设采用以下经过充分检验的形式和定义：\n- 对势：\n$$\n\\phi(r) = \\varepsilon \\left[ \\left(\\frac{r_0}{r}\\right)^{12} - 2 \\left(\\frac{r_0}{r}\\right)^6 \\right],\n$$\n其中势阱深度为 $\\varepsilon$，特征距离为 $r_0$（$\\phi(r)$ 在 $r=r_0$ 处取最小值）。\n- 配位数度量：\n$$\n\\rho_i = \\sum_{\\substack{j=1 \\\\ j \\neq i}}^N g(r_{ij}), \\quad \\text{其中} \\quad g(r) = \\left(\\frac{r_0}{r}\\right)^6,\n$$\n该值随距离的增加而衰减。\n- 嵌入能：\n$$\nF(\\rho) = -\\alpha \\sqrt{\\rho},\n$$\n其中参数 $\\alpha$ 控制多体贡献的强度。\n\n求和中只应包含 $r_{ij} \\le r_{\\mathrm{cut}}$ 的相互作用。距离 $z_i$ 和特征长度 $r_0$ 必须以埃 (Å) 为单位表示，能量 $\\phi(r)$ 和 $F(\\rho)$ 必须以电子伏特 (eV) 为单位表示。弛豫问题由力学平衡定义，即总能量相对于自由层位置的平稳性：\n$$\n\\frac{\\partial E(\\mathbf{z})}{\\partial z_k} = 0 \\quad \\text{对于所有自由的 } k \\in \\{2,\\dots,N\\}.\n$$\n为保持物理真实性，您必须确保原子层不交叉，即对所有 $i$ 都有 $z_{i+1}  z_i$。为此，使用层间距 $d_i = z_{i+1} - z_i$（其中 $i \\in \\{1,\\dots,N-1\\}$）来参数化构型，并施加边界条件以确保 $d_i  0$。\n\n您的程序必须：\n- 使用上述定义和截断半径 $r_{\\mathrm{cut}}$ 构建总能量 $E(\\mathbf{z})$。\n- 在箱式约束下，相对于自由层间距 $d_i$ 最小化 $E(\\mathbf{z})$，以确保 $d_i$ 保持为正且在物理上合理。\n- 从 $d_i$ 重构弛豫后的位置 $z_i^\\star$，其中 $z_1=0$。\n- 报告所有 $i \\in \\{1,\\dots,N\\}$ 的各层位移 $u_i = z_i^\\star - z_i^{\\mathrm{bulk}}$，单位为埃 (Å)，四舍五入到六位小数。\n\n使用以下测试套件来证明其正确性和覆盖范围：\n- 情况 1（具有表面弛豫的一般情况）：$N=6$， $a_0=2.5$ Å， $\\varepsilon=0.2$ eV， $r_0=2.5$ Å， $\\alpha=0.1$ eV， $r_{\\mathrm{cut}}=7.5$ Å。每个 $d_i$ 的边界为 $[0.7a_0,1.3a_0]$。\n- 情况 2（无多体效应，因此弛豫可忽略不计的边缘情况）：$N=6$， $a_0=2.5$ Å， $\\varepsilon=0.2$ eV， $r_0=2.5$ Å， $\\alpha=0.0$ eV， $r_{\\mathrm{cut}}=7.5$ Å。每个 $d_i$ 的边界为 $[0.7a_0,1.3a_0]$。\n- 情况 3（较软的成键但更强的配位驱动，导致更显著的弛豫）：$N=10$， $a_0=2.5$ Å， $\\varepsilon=0.1$ eV， $r_0=2.5$ Å， $\\alpha=0.25$ eV， $r_{\\mathrm{cut}}=10.0$ Å。每个 $d_i$ 的边界为 $[0.7a_0,1.3a_0]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含 $N$ 个浮点位移（单位为埃，四舍五入到六位小数）的列表。例如，整体格式必须为\n$$\n[ [u_1^{(1)}, u_2^{(1)}, \\dots], [u_1^{(2)}, u_2^{(2)}, \\dots], [u_1^{(3)}, u_2^{(3)}, \\dots] ].\n$$\n此问题不涉及角度；无需角度单位。此问题不涉及百分比；请勿在任何地方使用百分号。",
            "solution": "目标是通过能量最小化，根据源于力学平衡的第一性原理，计算平板各层的位移。相关的基本依据是：(i) 保守系统的总势能决定平衡状态，(ii) 力学平衡对应于能量相对于自由度的梯度为零，以及 (iii) 表面弛豫是由于表面配位数的变化而产生的，我们通过一个多体泛函来捕捉这一现象。下面我们概述其推导和算法。\n\n我们考虑沿 $z$ 方向由 $i \\in \\{1,\\dots,N\\}$ 索引的原子层。未弛豫的体相截断位置为 $z_i^{\\mathrm{bulk}} = (i-1)a_0$。底层固定在 $z_1 = 0$，而所有其他层仅沿 $z$ 方向移动。为防止不符合物理规律的层交叉，我们使用层间距 $d_i = z_{i+1}-z_i$（其中 $i \\in \\{1,\\dots,N-1\\}$）进行参数化，这些间距被约束为正值（箱式约束 $d_i \\in [d_{\\min}, d_{\\max}]$ 且 $d_{\\min}  0$）。\n\n总能量的模型为\n$$\nE(\\mathbf{z}) = \\sum_{1 \\leq i  j \\leq N} \\phi(r_{ij}) + \\sum_{i=1}^N F(\\rho_i), \\quad \\text{其中} \\quad r_{ij} = |z_i-z_j|.\n$$\n我们采用以下形式：\n- 对势，\n$$\n\\phi(r) = \\varepsilon \\left[ \\left(\\frac{r_0}{r}\\right)^{12} - 2 \\left(\\frac{r_0}{r}\\right)^6 \\right],\n$$\n这是一个移位的 Lennard–Jones 型势，在 $r=r_0$ 处能量为 $-\\varepsilon$ 的最小值。\n- 配位数度量，\n$$\n\\rho_i = \\sum_{\\substack{j=1 \\\\ j \\ne i}}^N g(r_{ij}), \\quad \\text{其中} \\quad g(r) = \\left(\\frac{r_0}{r}\\right)^6,\n$$\n它编码了随距离减小的局部电子密度。\n- 嵌入能，\n$$\nF(\\rho) = -\\alpha \\sqrt{\\rho},\n$$\n它模拟了随配位数增加而增强的多体稳定性。这些函数通常用于捕捉表面成键的变化，在表面处 $\\rho_i$ 减小，嵌入作用减弱，通常导致最顶层层间距的收缩（表面弛豫）。\n\n为确保计算可行性和物理真实性，相互作用在有限的截断半径 $r_{ij} \\le r_{\\mathrm{cut}}$ 处被截断：\n$$\nE(\\mathbf{z}) = \\sum_{\\substack{1 \\le i  j \\le N \\\\ r_{ij} \\le r_{\\mathrm{cut}}}} \\phi(r_{ij}) + \\sum_{i=1}^N F\\!\\left(\\sum_{\\substack{j=1 \\\\ j \\ne i \\\\ r_{ij} \\le r_{\\mathrm{cut}}}}^N g(r_{ij})\\right).\n$$\n因为 $z_1=0$ 且 $z_{i+1} = z_i + d_i$，整个构型可通过以下方式重构\n$$\nz_1 = 0, \\quad z_2 = d_1, \\quad z_3 = d_1 + d_2, \\quad \\dots, \\quad z_N = \\sum_{k=1}^{N-1} d_k.\n$$\n力学平衡条件是平稳性方程，\n$$\n\\frac{\\partial E}{\\partial d_k} = 0 \\quad \\text{对于} \\quad k \\in \\{1,\\dots,N-1\\}.\n$$\n这等价于对自由层 $\\partial E / \\partial z_i = 0$，因为 $z_i$ 是 $d_k$ 的具有单位系数的仿射函数。原则上，可以显式计算梯度。为作说明，对特定 $z_k$ 的导数为\n$$\n\\frac{\\partial E}{\\partial z_k} = \n\\sum_{\\substack{j=1 \\\\ j \\ne k}}^N \\phi'(r_{kj}) \\cdot \\frac{\\partial r_{kj}}{\\partial z_k}\n+ \\sum_{i=1}^N F'(\\rho_i) \\cdot \\frac{\\partial \\rho_i}{\\partial z_k}.\n$$\n对于对势项，由于 $r_{kj} = |z_k-z_j|$，我们有 $\\frac{\\partial r_{kj}}{\\partial z_k} = \\mathrm{sgn}(z_k-z_j)$，以及 $\\phi'(r) = \\varepsilon \\left[ -12 \\left(\\frac{r_0}{r}\\right)^{12} \\frac{1}{r} + 12 \\left(\\frac{r_0}{r}\\right)^6 \\frac{1}{r} \\right]$。对于密度项，\n$$\n\\frac{\\partial \\rho_k}{\\partial z_k} = \\sum_{\\substack{j=1 \\\\ j \\ne k}}^N g'(r_{kj}) \\cdot \\mathrm{sgn}(z_k-z_j), \n\\quad \\text{以及} \\quad\n\\frac{\\partial \\rho_i}{\\partial z_k} = g'(r_{ik}) \\cdot \\left(-\\mathrm{sgn}(z_i-z_k)\\right) \\quad \\text{对于} \\quad i \\ne k,\n$$\n其中 $g'(r) = -6\\left(\\frac{r_0}{r}\\right)^6 \\frac{1}{r}$ 且 $F'(\\rho) = -\\frac{\\alpha}{2\\sqrt{\\rho}}$。由于多体耦合，完整的表达式在代数上是可解的，但很冗长。在实践中，稳健的拟牛顿优化方法可以使用函数求值和近似梯度来处理此问题。\n\n算法步骤：\n1. 对所有 $k \\in \\{1,\\dots,N-1\\}$，初始化 $d_k^{(0)} = a_0$，这对应于 $z_i^{\\mathrm{bulk}}$。\n2. 定义边界 $d_k \\in [\\lambda_{\\min} a_0, \\lambda_{\\max} a_0]$，其中 $\\lambda_{\\min}  0$ 且 $\\lambda_{\\max}  \\lambda_{\\min}$，以强制执行非交叉和物理位移限制。在测试套件中，我们设置为 $[0.7 a_0, 1.3 a_0]$。\n3. 构建 $E(\\mathbf{z}(\\mathbf{d}))$ 并使用有界拟牛顿算法对 $\\mathbf{d}$ 进行数值最小化。这通过在约束下满足平稳性条件来强制实现离散力学平衡。\n4. 恢复弛豫后的位置 $z_i^\\star$ 并计算位移 $u_i = z_i^\\star - z_i^{\\mathrm{bulk}}$，单位为埃。\n5. 将每个 $u_i$ 四舍五入到六位小数。\n6. 对所有测试用例重复此过程，形成最终的输出列表。\n\n测试用例覆盖范围的基本原理：\n- 情况 1 展示了具有中等强度多体效应的典型表面弛豫。当 $\\alpha  0$ 时，顶层减小层间距以补偿减少的配位数，导致表面附近的 $u_i$ 为小的负值，而在类体相内部的 $u_i$ 可忽略不计。\n- 情况 2 设置 $\\alpha = 0$，消除了多体配位效应。由于对势的最小值与 $a_0$ 匹配，系统已处于对势平衡状态。因此，位移在数值精度范围内为零，从而测试了边界行为。\n- 情况 3 通过 $\\varepsilon$ 降低对势的刚度，但通过 $\\alpha$ 增强多体驱动，这通常会放大弛豫效应。这测试了灵敏度以及弛豫效应更深地渗透到多个层中。\n\n单位严格执行为距离使用埃，能量使用电子伏特。所有报告的 $u_i$ 必须以埃为单位，并四舍五入到六位小数。程序将三个列表（每个案例一个）聚合到一个单行打印的方括号列表中，确保了普遍适用性和确定性测试，不依赖任何外部文件或输入。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef eam_energy(d, N, a0, epsilon, r0, alpha, r_cut):\n    \"\"\"\n    Compute total energy for a 1D slab with N layers parameterized by interlayer spacings d.\n    Distances in Angstroms (Å), energies in electronvolts (eV).\n    \"\"\"\n    # Reconstruct positions z from interlayer spacings d, with z1 = 0\n    z = np.zeros(N, dtype=float)\n    z[1:] = np.cumsum(d)\n\n    # Compute pair energy with cutoff\n    E_pair = 0.0\n    # Precompute all r_ij within cutoff\n    for i in range(N - 1):\n        zi = z[i]\n        for j in range(i + 1, N):\n            r = abs(z[j] - zi)\n            if r = r_cut:\n                # Lennard-Jones-like pair potential (min at r0)\n                # epsilon * [ (r0/r)^12 - 2 (r0/r)^6 ]\n                x = r0 / r\n                x6 = x ** 6\n                E_pair += epsilon * (x6 ** 2 - 2.0 * x6)\n\n    # Compute coordination rho_i and embedding energy\n    rho = np.zeros(N, dtype=float)\n    for i in range(N):\n        zi = z[i]\n        # Sum over neighbors within cutoff\n        s = 0.0\n        for j in range(N):\n            if j == i:\n                continue\n            r = abs(z[j] - zi)\n            if r = r_cut:\n                # g(r) = (r0/r)^6\n                s += (r0 / r) ** 6\n        rho[i] = s\n\n    # Embedding energy F(rho) = -alpha * sqrt(rho)\n    # Guard against tiny negative numerical values due to floating point\n    rho_clamped = np.clip(rho, 0.0, None)\n    E_embed = -alpha * np.sum(np.sqrt(rho_clamped))\n\n    return E_pair + E_embed\n\n\ndef relax_slab(N, a0, epsilon, r0, alpha, r_cut, bounds_scale=(0.7, 1.3)):\n    \"\"\"\n    Minimize the energy with respect to interlayer spacings d_i under box constraints.\n    Returns the layer-resolved displacements u_i in Angstroms (Å).\n    \"\"\"\n    # Initial guess: bulk-terminated spacings\n    d0 = np.full(N - 1, a0, dtype=float)\n\n    # Bounds to enforce non-crossing and physical ranges\n    lower = bounds_scale[0] * a0\n    upper = bounds_scale[1] * a0\n    bounds = [(lower, upper) for _ in range(N - 1)]\n\n    # Objective for optimizer\n    def objective(dvec):\n        return eam_energy(dvec, N, a0, epsilon, r0, alpha, r_cut)\n\n    # Perform bounded optimization (quasi-Newton)\n    res = minimize(\n        objective,\n        d0,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 500, 'ftol': 1e-12}\n    )\n\n    d_opt = res.x\n\n    # Reconstruct relaxed positions z_i^* from d_opt\n    z_relaxed = np.zeros(N, dtype=float)\n    z_relaxed[1:] = np.cumsum(d_opt)\n\n    # Bulk positions\n    z_bulk = np.array([i * a0 for i in range(N)], dtype=float)\n\n    # Displacements u_i = z_i^* - z_i_bulk (Å)\n    u = z_relaxed - z_bulk\n\n    # Round to 6 decimals\n    u_rounded = [float(f\"{val:.6f}\") for val in u]\n    return u_rounded\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, a0 [Å], epsilon [eV], r0 [Å], alpha [eV], r_cut [Å], bounds_scale)\n    test_cases = [\n        (6, 2.5, 0.2, 2.5, 0.1, 7.5, (0.7, 1.3)),  # Case 1: general relaxation\n        (6, 2.5, 0.2, 2.5, 0.0, 7.5, (0.7, 1.3)),  # Case 2: no many-body - negligible relaxation\n        (10, 2.5, 0.1, 2.5, 0.25, 10.0, (0.7, 1.3)),  # Case 3: softer bonding, stronger embedding\n    ]\n\n    results = []\n    for case in test_cases:\n        N, a0, epsilon, r0, alpha, r_cut, bscale = case\n        u = relax_slab(N, a0, epsilon, r0, alpha, r_cut, bounds_scale=bscale)\n        results.append(u)\n\n    # Final print statement in the exact required format: list of lists, one line.\n    # Each sublist corresponds to displacements (Å) rounded to six decimals for a given test case.\n    print(\"[\" + \",\".join(\"[\" + \",\".join(f\"{val:.6f}\" for val in case_result) + \"]\" for case_result in results) + \"]\")\n\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在计算科学中，理论计算的准确性至关重要，而密度泛函理论（DFT）的计算结果在很大程度上取决于所选择的交换相关泛函。本练习将理论计算与实际研究任务联系起来，要求您评估不同级别（如 PBE、SCAN、混合泛函）的泛函在预测表面能时的表现 。通过将计算结果与代表实验值或更高精度理论的参考数据进行基准比较，您将学习如何量化不同方法的误差，并选择最适合特定材料体系的计算方案，这是产生可靠研究成果的关键一步。",
            "id": "3901295",
            "problem": "您需要编写一个完整、可运行的程序，以量化交换相关泛函的选择对表面能的影响，并根据代表实验或更高级别理论的参考数据构建基准测试指标。程序必须实现源于物理定义的逻辑，而不是使用简化的快捷公式。\n\n我们关注的物理量是表面能 $\\,\\gamma\\,$，其定义为从块体固相中创造出表面所需的单位面积可逆功。考虑一个从块体中解理出的对称板层（slab），从而产生 $\\,s=2\\,$ 个等效表面。程序必须使用每个测试用例的以下数据，为每种交换相关泛函——Perdew–Burke–Ernzerhof (PBE)、强约束和适当范数 (Strongly Constrained and Appropriately Normed, SCAN) 以及一个包含部分精确交换的代表性杂化泛函 (HYB)——计算 $\\,\\gamma\\,$：\n- 未弛豫板层的总能量，单位为电子伏特（eV），$\\,E_{\\mathrm{slab}}^{\\mathrm{(XC)}}\\,$.\n- 每层块体的能量，单位为电子伏特（eV），$\\,E_{\\mathrm{bulk,layer}}^{\\mathrm{(XC)}}\\,$.\n- 层数 $\\,N_{\\mathrm{layers}}\\,$.\n- 模拟晶胞的表面积 $\\,A\\,$，单位为平方埃（Å²）。\n- 弛豫分数 $\\,r^{\\mathrm{(XC)}}\\,$，以小数形式表示，指由于表面弛豫导致的 $\\,\\gamma\\,$ 的分数减少量，应将其乘在未弛豫值上。\n- 参考的弛豫表面能 $\\,\\gamma_{\\mathrm{ref}}\\,$，单位为焦耳/平方米（J/m²），代表实验或更高级别理论的基准值。\n\n您的程序必须：\n1. 使用单位面积可逆功的定义，根据所提供的能量和几何量，为 $\\,s=2\\,$ 个表面计算未弛豫的表面能 $\\,\\gamma\\,$。\n2. 对每种泛函应用所提供的弛豫分数 $\\,r^{\\mathrm{(XC)}}\\,$，以获得弛豫后的 $\\,\\gamma\\,$。\n3. 对于每个测试用例，计算每种泛函的弛豫 $\\,\\gamma\\,$ 相对于所提供的 $\\,\\gamma_{\\mathrm{ref}}\\,$ 的绝对误差，最佳泛函的索引（绝对误差最小的那个；PBE 使用 $\\,0\\,$，SCAN 使用 $\\,1\\,$，HYB 使用 $\\,2\\,$），以及三种泛函的平均绝对误差。\n4. 将所有表面能和误差以焦耳/平方米（J/m²）为单位表示为浮点数，并四舍五入到三位小数。题目不涉及角度，因此不需要角度单位。\n\n您的程序必须一致地使用以下常数和单位：\n- 电子伏特到焦耳的转换：$\\,1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}\\,$.\n- 埃到米的转换：$\\,1\\,\\text{\\AA} = 1 \\times 10^{-10}\\,\\mathrm{m}\\,$, 所以 $\\,1\\,\\text{\\AA}^2 = 1 \\times 10^{-20}\\,\\mathrm{m}^2\\,$.\n- 创建的表面数量：$\\,s=2\\,$.\n\n具有科学合理参数的测试套件：\n- 案例 1 (铜 (Cu) $(111)$)：\n  - $\\,N_{\\mathrm{layers}} = 7\\,$, $\\,A = 52.4\\,\\text{\\AA}^2\\,$, $\\,\\gamma_{\\mathrm{ref}} = 1.85\\,\\mathrm{J}/\\mathrm{m}^2\\,$.\n  - PBE: $\\,E_{\\mathrm{bulk,layer}}^{\\mathrm{(PBE)}} = -3.72\\,\\mathrm{eV}\\,$, $\\,E_{\\mathrm{slab}}^{\\mathrm{(PBE)}} = -14.27\\,\\mathrm{eV}\\,$, $\\,r^{\\mathrm{(PBE)}} = 0.10\\,$.\n  - SCAN: $\\,E_{\\mathrm{bulk,layer}}^{\\mathrm{(SCAN)}} = -3.95\\,\\mathrm{eV}\\,$, $\\,E_{\\mathrm{slab}}^{\\mathrm{(SCAN)}} = -14.57\\,\\mathrm{eV}\\,$, $\\,r^{\\mathrm{(SCAN)}} = 0.08\\,$.\n  - HYB: $\\,E_{\\mathrm{bulk,layer}}^{\\mathrm{(HYB)}} = -4.10\\,\\mathrm{eV}\\,$, $\\,E_{\\mathrm{slab}}^{\\mathrm{(HYB)}} = -14.30\\,\\mathrm{eV}\\,$, $\\,r^{\\mathrm{(HYB)}} = 0.05\\,$.\n- 案例 2 (铂 (Pt) $(100)$)：\n  - $\\,N_{\\mathrm{layers}} = 9\\,$, $\\,A = 50.0\\,\\text{\\AA}^2\\,$, $\\,\\gamma_{\\mathrm{ref}} = 2.60\\,\\mathrm{J}/\\mathrm{m}^2\\,$.\n  - PBE: $\\,E_{\\mathrm{bulk,layer}}^{\\mathrm{(PBE)}} = -5.85\\,\\mathrm{eV}\\,$, $\\,E_{\\mathrm{slab}}^{\\mathrm{(PBE)}} = -37.67\\,\\mathrm{eV}\\,$, $\\,r^{\\mathrm{(PBE)}} = 0.15\\,$.\n  - SCAN: $\\,E_{\\mathrm{bulk,layer}}^{\\mathrm{(SCAN)}} = -6.10\\,\\mathrm{eV}\\,$, $\\,E_{\\mathrm{slab}}^{\\mathrm{(SCAN)}} = -38.05\\,\\mathrm{eV}\\,$, $\\,r^{\\mathrm{(SCAN)}} = 0.12\\,$.\n  - HYB: $\\,E_{\\mathrm{bulk,layer}}^{\\mathrm{(HYB)}} = -6.25\\,\\mathrm{eV}\\,$, $\\,E_{\\mathrm{slab}}^{\\mathrm{(HYB)}} = -38.13\\,\\mathrm{eV}\\,$, $\\,r^{\\mathrm{(HYB)}} = 0.08\\,$.\n- 案例 3 (二氧化钛 (TiO$_2$) $(110)$)：\n  - $\\,N_{\\mathrm{layers}} = 6\\,$, $\\,A = 65.0\\,\\text{\\AA}^2\\,$, $\\,\\gamma_{\\mathrm{ref}} = 1.25\\,\\mathrm{J}/\\mathrm{m}^2\\,$.\n  - PBE: $\\,E_{\\mathrm{bulk,layer}}^{\\mathrm{(PBE)}} = -15.20\\,\\mathrm{eV}\\,$, $\\,E_{\\mathrm{slab}}^{\\mathrm{(PBE)}} = -83.09\\,\\mathrm{eV}\\,$, $\\,r^{\\mathrm{(PBE)}} = 0.25\\,$.\n  - SCAN: $\\,E_{\\mathrm{bulk,layer}}^{\\mathrm{(SCAN)}} = -16.00\\,\\mathrm{eV}\\,$, $\\,E_{\\mathrm{slab}}^{\\mathrm{(SCAN)}} = -85.46\\,\\mathrm{eV}\\,$, $\\,r^{\\mathrm{(SCAN)}} = 0.20\\,$.\n  - HYB: $\\,E_{\\mathrm{bulk,layer}}^{\\mathrm{(HYB)}} = -16.40\\,\\mathrm{eV}\\,$, $\\,E_{\\mathrm{slab}}^{\\mathrm{(HYB)}} = -87.05\\,\\mathrm{eV}\\,$, $\\,r^{\\mathrm{(HYB)}} = 0.15\\,$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，每个元素对应一个测试用例，并且本身也是一个方括号括起来的逗号分隔列表，顺序为\n  $[\\gamma_{\\mathrm{PBE}}, \\gamma_{\\mathrm{SCAN}}, \\gamma_{\\mathrm{HYB}}, \\text{best\\_index}, \\text{best\\_abs\\_error}, \\text{MAE}]$,\n  其中所有 $\\,\\gamma\\,$ 和误差值均以 $\\,\\mathrm{J}/\\mathrm{m}^2\\,$ 为单位，并四舍五入到三位小数，而 $\\,\\text{best\\_index}\\,$ 是 $\\{0,1,2\\}$ 中的一个整数。\n例如，输出结构必须如下所示\n$[[x_{11},x_{12},x_{13},i_1,e_1,m_1],[x_{21},x_{22},x_{23},i_2,e_2,m_2],[x_{31},x_{32},x_{33},i_3,e_3,m_3]]$,\n其中每个 $\\,x_{jk}\\,$, $\\,e_j\\,$ 和 $\\,m_j\\,$ 都是以 $\\,\\mathrm{J}/\\mathrm{m}^2\\,$ 为单位并四舍五入到三位小数的浮点数。",
            "solution": "所陈述的问题在科学上是合理的、定义明确的，并且包含了解决该问题所需的所有信息。它完全属于计算材料科学的范畴，是评估不同密度泛函理论 (DFT) 交换相关 (XC) 泛函性能的一个标准且有效的练习。因此，我们可以着手进行一个有原则的解决方案。\n\n我们主要关注的物理量是表面能，用符号 $\\gamma$ 表示。它被定义为表面相对于块体的单位面积过剩吉布斯自由能。在温度 $T=0\\,\\mathrm{K}$ 时（DFT 计算通常在此温度下进行），这等同于单位面积的过剩内能。其定义由解理块状晶体以创造新表面所需的可逆功给出。对于创建了两个等效表面的对称板层模型，未弛豫的表面能 $\\gamma_{\\mathrm{unrelaxed}}$ 是使用 DFT 的总能量计算得出的。\n\n包含 $N_{\\mathrm{layers}}$ 层的板层的总能量为 $E_{\\mathrm{slab}}^{\\mathrm{(XC)}}$。为了找到由表面引起的过剩能量，我们必须减去等量原子或化学式单元在块状晶体中构型时的能量。问题提供了以每层为单位的块体能量 $E_{\\mathrm{bulk,layer}}^{\\mathrm{(XC)}}$。因此，与板层包含相同物质的量的参考块体材料的能量是 $E_{\\mathrm{bulk,eq}} = N_{\\mathrm{layers}} \\times E_{\\mathrm{bulk,layer}}^{\\mathrm{(XC)}}$。\n\n与创建板层相关的总过剩能量是板层能量与等效块体材料能量之间的差值：\n$$\n\\Delta E^{\\mathrm{(XC)}} = E_{\\mathrm{slab}}^{\\mathrm{(XC)}} - E_{\\mathrm{bulk,eq}} = E_{\\mathrm{slab}}^{\\mathrm{(XC)}} - N_{\\mathrm{layers}} \\times E_{\\mathrm{bulk,layer}}^{\\mathrm{(XC)}}\n$$\n这个过剩能量 $\\Delta E^{\\mathrm{(XC)}}$ 归因于创建了两个表面，每个表面的面积为 $A$。总的新增表面积为 $s \\times A$，问题中指定 $s=2$。因此，未弛豫的表面能是每单位创建表面积的过剩能量：\n$$\n\\gamma_{\\mathrm{unrelaxed}}^{\\mathrm{(XC)}} = \\frac{\\Delta E^{\\mathrm{(XC)}}}{sA} = \\frac{E_{\\mathrm{slab}}^{\\mathrm{(XC)}} - N_{\\mathrm{layers}} \\times E_{\\mathrm{bulk,layer}}^{\\mathrm{(XC)}}}{2A}\n$$\n使用所提供数据进行的计算得出 $\\gamma_{\\mathrm{unrelaxed}}^{\\mathrm{(XC)}}$，单位为电子伏特/平方埃 ($\\mathrm{eV}/\\text{\\AA}^2$) 。\n\n该值对应于板层中原子位置与块状晶体中原子位置相同的情况，即未弛豫或理想解理。实际上，表面附近的原子会移动（弛豫）到新的平衡位置，以最小化板层的总能量。这种结构弛豫总是会降低板层的总能量，从而降低表面能。问题通过弛豫分数 $r^{\\mathrm{(XC)}}$ 来量化此效应，该分数代表弛豫时表面能的分数减少量。因此，弛豫后的表面能 $\\gamma_{\\mathrm{relaxed}}^{\\mathrm{(XC)}}$ 计算如下：\n$$\n\\gamma_{\\mathrm{relaxed}}^{\\mathrm{(XC)}} = \\gamma_{\\mathrm{unrelaxed}}^{\\mathrm{(XC)}} \\times (1 - r^{\\mathrm{ (XC)}})\n$$\n为了将这些理论值与实验或更高级别理论的参考值 $\\gamma_{\\mathrm{ref}}$进行比较，我们必须确保单位一致。计算出的表面能必须从 $\\mathrm{eV}/\\text{\\AA}^2$ 转换为焦耳/平方米 ($\\mathrm{J}/\\mathrm{m}^2$) 。转换因子由所提供的基本常数导出：\n$$\n\\text{转换因子} = \\frac{1\\,\\mathrm{eV}}{1\\,\\text{\\AA}^2} = \\frac{1.602176634 \\times 10^{-19}\\,\\mathrm{J}}{(1 \\times 10^{-10}\\,\\mathrm{m})^2} = \\frac{1.602176634 \\times 10^{-19}\\,\\mathrm{J}}{1 \\times 10^{-20}\\,\\mathrm{m}^2} = 16.02176634\\,\\frac{\\mathrm{J}/\\mathrm{m}^2}{\\mathrm{eV}/\\text{\\AA}^2}\n$$\n对于每个测试用例和每种泛函 (XC = PBE, SCAN, HYB)，我们计算 $\\gamma_{\\mathrm{relaxed}}^{\\mathrm{(XC)}}$，单位为 $\\mathrm{J}/\\mathrm{m}^2$。然后，我们通过计算绝对误差来评估每种泛函相对于参考值 $\\gamma_{\\mathrm{ref}}$ 的性能：\n$$\n\\text{AE}^{\\mathrm{(XC)}} = |\\gamma_{\\mathrm{relaxed}}^{\\mathrm{(XC)}} - \\gamma_{\\mathrm{ref}}|\n$$\n在给定案例中表现最佳的泛函是绝对误差最小的那个。其索引报告为：PBE 为 $0$，SCAN 为 $1$，HYB 为 $2$。最小绝对误差本身也会被报告。最后，该测试用例中三种泛函的平均绝对误差 (MAE) 提供了对其集体性能的总结性指标：\n$$\n\\text{MAE} = \\frac{1}{3} \\sum_{\\mathrm{XC}} \\text{AE}^{\\mathrm{(XC)}} = \\frac{\\text{AE}^{\\mathrm{(PBE)}} + \\text{AE}^{\\mathrm{(SCAN)}} + \\text{AE}^{\\mathrm{(HYB)}}}{3}\n$$\n所有最终的能量和误差值都应四舍五入到三位小数。算法流程是遍历每个测试用例，对三种泛函中的每一种应用这些物理公式和基准测试步骤，并按规定格式化结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates and benchmarks surface energies for different XC functionals.\n    \"\"\"\n    # Define physical constants for unit conversion\n    EV_TO_JOULE = 1.602176634e-19\n    ANGSTROM_SQ_TO_METER_SQ = 1e-20\n    # Conversion factor from eV/Å² to J/m²\n    CONVERSION_FACTOR = EV_TO_JOULE / ANGSTROM_SQ_TO_METER_SQ\n    \n    # Number of surfaces created in the symmetric slab model\n    S_SURFACES = 2.0\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N_layers, A, gamma_ref, functional_data)\n    # functional_data is a list of tuples: [(E_slab, E_bulk_layer, r), ...] for PBE, SCAN, HYB\n    test_cases = [\n        # Case 1 (Copper (Cu) (111))\n        (7, 52.4, 1.85, [\n            (-14.27, -3.72, 0.10),  # PBE\n            (-14.57, -3.95, 0.08),  # SCAN\n            (-14.30, -4.10, 0.05)   # HYB\n        ]),\n        # Case 2 (Platinum (Pt) (100))\n        (9, 50.0, 2.60, [\n            (-37.67, -5.85, 0.15),  # PBE\n            (-38.05, -6.10, 0.12),  # SCAN\n            (-38.13, -6.25, 0.08)   # HYB\n        ]),\n        # Case 3 (Titanium dioxide (TiO2) (110))\n        (6, 65.0, 1.25, [\n            (-83.09, -15.20, 0.25), # PBE\n            (-85.46, -16.00, 0.20), # SCAN\n            (-87.05, -16.40, 0.15)  # HYB\n        ])\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        n_layers, area_ang2, gamma_ref_jm2, functional_data = case\n        \n        relaxed_gammas_jm2 = []\n        \n        for e_slab_ev, e_bulk_layer_ev, r_frac in functional_data:\n            # 1. Compute the unrelaxed surface energy in eV/Å²\n            # gamma_unrelaxed = (E_slab - N_layers * E_bulk_layer) / (2 * A)\n            excess_energy_ev = e_slab_ev - n_layers * e_bulk_layer_ev\n            gamma_unrelaxed_ev_ang2 = excess_energy_ev / (S_SURFACES * area_ang2)\n            \n            # 2. Apply the fractional relaxation to get relaxed gamma in eV/Å²\n            gamma_relaxed_ev_ang2 = gamma_unrelaxed_ev_ang2 * (1.0 - r_frac)\n            \n            # 3. Convert the relaxed surface energy to J/m²\n            gamma_relaxed_jm2 = gamma_relaxed_ev_ang2 * CONVERSION_FACTOR\n            relaxed_gammas_jm2.append(gamma_relaxed_jm2)\n\n        # 4. Compute benchmarking metrics\n        relaxed_gammas = np.array(relaxed_gammas_jm2)\n        \n        # Absolute errors for each functional\n        abs_errors = np.abs(relaxed_gammas - gamma_ref_jm2)\n        \n        # Index of the best functional (smallest absolute error)\n        best_index = int(np.argmin(abs_errors))\n        \n        # The best absolute error\n        best_abs_error = abs_errors[best_index]\n        \n        # Mean Absolute Error (MAE) across the three functionals\n        mae = np.mean(abs_errors)\n        \n        # 5. Format the results for the current test case\n        # Round all gamma and error values to three decimal places.\n        case_result = [\n            round(relaxed_gammas[0], 3),\n            round(relaxed_gammas[1], 3),\n            round(relaxed_gammas[2], 3),\n            best_index,\n            round(best_abs_error, 3),\n            round(mae, 3)\n        ]\n        all_results.append(case_result)\n\n    # Format the final output string as specified\n    # The format must be exactly [[...],[...],[...]] without extra spaces\n    output_str = \"[\" + \",\".join([\n        f\"[{g_pbe:.3f},{g_scan:.3f},{g_hyb:.3f},{idx},{best_err:.3f},{m:.3f}]\"\n        for g_pbe, g_scan, g_hyb, idx, best_err, m in all_results\n    ]) + \"]\"\n\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}