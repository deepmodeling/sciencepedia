{
    "hands_on_practices": [
        {
            "introduction": "To truly understand electron density difference maps, we first need to explore the quantum mechanical origins of charge redistribution. This exercise drills down to the fundamental principles of chemical bonding at a surface using a simplified but powerful tight-binding model . By constructing and diagonalizing a small Hamiltonian representing the interaction between an adsorbate's frontier orbitals and a metal state, you will directly quantify the concepts of donation and backdonation, providing a clear, quantitative link between orbital energies, their coupling, and the resulting charge flow.",
            "id": "3878885",
            "problem": "A catalyst surface with an adsorbed molecule is modeled in a minimal discrete-orbital framework to quantify donation–backdonation using electron density difference mapping. The electron density difference mapping is defined from first principles by the independent-electron approximation and Born–Oppenheimer separation, where the total electron density is obtained from occupied one-electron states. The adsorbate supplies a highest occupied molecular orbital (HOMO) and a lowest unoccupied molecular orbital (LUMO), and the surface supplies a single effective metal state (for example, a representative metal $d$-like state). The discrete-orbital electron density difference mapping is expressed as an orbital-resolved population change relative to the non-interacting fragments. Starting from the time-independent Schrödinger equation and a minimal tight-binding representation, implement a program that computes donation and backdonation amounts as orbital-resolved electron population changes, in units of electrons, for several specified parameter sets.\n\nFundamental basis and core definitions:\n- The time-independent Schrödinger equation for a one-electron state is $H|\\psi\\rangle = E|\\psi\\rangle$, where $H$ is the Hamiltonian, $E$ is the energy, and $|\\psi\\rangle$ is the wavefunction.\n- In the independent-electron approximation, the total electron density is the sum over occupied one-electron states, and orbital-resolved populations are obtained by projecting occupied states onto an orthonormal orbital basis.\n- The electron density difference mapping in a discrete orthonormal orbital basis is defined as the difference in orbital populations between the interacting (adsorbate–surface) system and the sum of isolated fragments. Denote the basis by $\\{ |\\mathrm{H}\\rangle, |\\mathrm{L}\\rangle, |\\mathrm{d}\\rangle \\}$, representing the adsorbate HOMO, adsorbate LUMO, and metal state, respectively. Let $n_{\\mathrm{H}}$, $n_{\\mathrm{L}}$, and $n_{\\mathrm{d}}$ be the orbital populations of the interacting system, and $n_{\\mathrm{H}}^{(0)}$, $n_{\\mathrm{L}}^{(0)}$, $n_{\\mathrm{d}}^{(0)}$ be those of the isolated fragments. The discrete electron density difference mapping is the vector $\\Delta \\mathbf{n} = (n_{\\mathrm{H}} - n_{\\mathrm{H}}^{(0)}, n_{\\mathrm{L}} - n_{\\mathrm{L}}^{(0)}, n_{\\mathrm{d}} - n_{\\mathrm{d}}^{(0)})$.\n- Donation is defined as the decrease of population on the adsorbate HOMO, $D = \\max(0, -\\Delta n_{\\mathrm{H}})$, in units of electrons. Backdonation is defined as the increase of population on the adsorbate LUMO, $B = \\max(0, \\Delta n_{\\mathrm{L}})$, in units of electrons.\n- The Hamiltonian of the interacting system in the orthonormal basis $\\{ |\\mathrm{H}\\rangle, |\\mathrm{L}\\rangle, |\\mathrm{d}\\rangle \\}$ is\n$$\nH = \\begin{pmatrix}\nE_{\\mathrm{H}} & 0 & V_{\\mathrm{Hd}} \\\\\n0 & E_{\\mathrm{L}} & V_{\\mathrm{Ld}} \\\\\nV_{\\mathrm{Hd}} & V_{\\mathrm{Ld}} & E_{\\mathrm{d}}\n\\end{pmatrix},\n$$\nwhere $E_{\\mathrm{H}}$, $E_{\\mathrm{L}}$, and $E_{\\mathrm{d}}$ are orbital energies and $V_{\\mathrm{Hd}}$, $V_{\\mathrm{Ld}}$ are couplings between the adsorbate orbitals and the metal state. All energies and couplings are given in electron volts (eV).\n- The adsorbate HOMO is occupied in the isolated adsorbate, $n_{\\mathrm{H}}^{(0)} = 1$, the adsorbate LUMO is unoccupied, $n_{\\mathrm{L}}^{(0)} = 0$, and the metal state is occupied, $n_{\\mathrm{d}}^{(0)} = 1$, under a spinless minimal model; total electrons in the interacting system are conserved at $N_{\\mathrm{e}} = 2$.\n- The interacting Hamiltonian is diagonalized to obtain eigenvalues $E_{k}$ and eigenvectors $\\mathbf{c}^{(k)} = (c_{\\mathrm{H}}^{(k)}, c_{\\mathrm{L}}^{(k)}, c_{\\mathrm{d}}^{(k)})$. The $N_{\\mathrm{e}}$ lowest eigenstates are occupied. Orbital populations are computed as\n$$\nn_{\\mathrm{H}} = \\sum_{k \\in \\mathrm{occ}} \\left| c_{\\mathrm{H}}^{(k)} \\right|^{2}, \\quad\nn_{\\mathrm{L}} = \\sum_{k \\in \\mathrm{occ}} \\left| c_{\\mathrm{L}}^{(k)} \\right|^{2}, \\quad\nn_{\\mathrm{d}} = \\sum_{k \\in \\mathrm{occ}} \\left| c_{\\mathrm{d}}^{(k)} \\right|^{2}.\n$$\n\nYour task:\n- Implement a complete program that, for each parameter set in the test suite below, constructs $H$, diagonalizes it, fills the $N_{\\mathrm{e}}$ lowest eigenstates, computes orbital populations and the discrete electron density difference mapping $\\Delta \\mathbf{n}$, and finally reports donation $D$ and backdonation $B$ in electrons (unit: electrons) as decimal floats.\n\nPhysical and numerical units:\n- Energies $E_{\\mathrm{H}}$, $E_{\\mathrm{L}}$, $E_{\\mathrm{d}}$, $V_{\\mathrm{Hd}}$, and $V_{\\mathrm{Ld}}$ must be treated in units of electron volts (eV).\n- The outputs $D$ and $B$ must be expressed in units of electrons, as decimal floats.\n\nTest suite:\n- Case $1$ (general interaction, nonzero donation and backdonation expected): $E_{\\mathrm{H}} = -10.0\\,\\mathrm{eV}$, $E_{\\mathrm{L}} = +2.0\\,\\mathrm{eV}$, $E_{\\mathrm{d}} = -2.0\\,\\mathrm{eV}$, $V_{\\mathrm{Hd}} = 0.5\\,\\mathrm{eV}$, $V_{\\mathrm{Ld}} = 0.4\\,\\mathrm{eV}$, $N_{\\mathrm{e}} = 2$.\n- Case $2$ (boundary, zero coupling): $E_{\\mathrm{H}} = -10.0\\,\\mathrm{eV}$, $E_{\\mathrm{L}} = +2.0\\,\\mathrm{eV}$, $E_{\\mathrm{d}} = -2.0\\,\\mathrm{eV}$, $V_{\\mathrm{Hd}} = 0.0\\,\\mathrm{eV}$, $V_{\\mathrm{Ld}} = 0.0\\,\\mathrm{eV}$, $N_{\\mathrm{e}} = 2$.\n- Case $3$ (edge, strong backdonation, $E_{\\mathrm{L}}$ near $E_{\\mathrm{d}}$): $E_{\\mathrm{H}} = -12.0\\,\\mathrm{eV}$, $E_{\\mathrm{L}} = -1.8\\,\\mathrm{eV}$, $E_{\\mathrm{d}} = -2.0\\,\\mathrm{eV}$, $V_{\\mathrm{Hd}} = 0.1\\,\\mathrm{eV}$, $V_{\\mathrm{Ld}} = 1.0\\,\\mathrm{eV}$, $N_{\\mathrm{e}} = 2$.\n- Case $4$ (edge, strong donation, $E_{\\mathrm{H}}$ near $E_{\\mathrm{d}}$): $E_{\\mathrm{H}} = -2.1\\,\\mathrm{eV}$, $E_{\\mathrm{L}} = +5.0\\,\\mathrm{eV}$, $E_{\\mathrm{d}} = -2.0\\,\\mathrm{eV}$, $V_{\\mathrm{Hd}} = 1.0\\,\\mathrm{eV}$, $V_{\\mathrm{Ld}} = 0.1\\,\\mathrm{eV}$, $N_{\\mathrm{e}} = 2$.\n\nFinal output specification:\n- Your program should produce a single line of output containing the donation–backdonation results for the four test cases as a comma-separated list of lists, each inner list being $[D,B]$, enclosed in square brackets, for example, $\\left[ [D_{1},B_{1}], [D_{2},B_{2}], [D_{3},B_{3}], [D_{4},B_{4}] \\right]$, with each $D$ and $B$ printed as decimal floats.",
            "solution": "The problem presents a valid and well-posed exercise in applying fundamental principles of quantum mechanics to a simplified model of adsorbate-surface interaction, a cornerstone concept in computational catalysis. The model, while minimal, is self-contained, scientifically grounded in the tight-binding approximation, and free of contradictions or ambiguities. It provides a quantitative framework for calculating donation and backdonation, two critical descriptors of chemical bonding at surfaces. We shall proceed with the derivation and algorithmic implementation.\n\nThe objective is to solve the time-independent Schrödinger equation for the interacting system, $H|\\psi\\rangle = E|\\psi\\rangle$, within a specific $3$-dimensional orthonormal basis $\\{ |\\mathrm{H}\\rangle, |\\mathrm{L}\\rangle, |\\mathrm{d}\\rangle \\}$. In this basis, the Hamiltonian $H$ is represented by the real symmetric matrix:\n$$\nH = \\begin{pmatrix}\nE_{\\mathrm{H}} & 0 & V_{\\mathrm{Hd}} \\\\\n0 & E_{\\mathrm{L}} & V_{\\mathrm{Ld}} \\\\\nV_{\\mathrm{Hd}} & V_{\\mathrm{Ld}} & E_{\\mathrm{d}}\n\\end{pmatrix}\n$$\nHere, $E_{\\mathrm{H}}$, $E_{\\mathrm{L}}$, and $E_{\\mathrm{d}}$ are the on-site energies of the adsorbate HOMO, LUMO, and the metal state, respectively, and $V_{\\mathrm{Hd}}$ and $V_{\\mathrm{Ld}}$ are the coupling terms between them. All parameters are provided in units of electron volts ($\\mathrm{eV}$). The assumption of a zero-valued $H_{\\mathrm{HL}}$ element, $\\langle \\mathrm{H} | H | \\mathrm{L} \\rangle = 0$, is a common simplification reflecting the negligible direct coupling between orbitals on the same fragment in this type of model.\n\nSolving the Schrödinger equation in this matrix form is equivalent to solving the eigenvalue problem $H\\mathbf{c}^{(k)} = E_k \\mathbf{c}^{(k)}$ for $k \\in \\{1, 2, 3\\}$. This yields three real eigenvalues (energies) $E_k$ and a set of three corresponding orthonormal eigenvectors $\\mathbf{c}^{(k)}$. Each eigenvector $\\mathbf{c}^{(k)} = (c_{\\mathrm{H}}^{(k)}, c_{\\mathrm{L}}^{(k)}, c_{\\mathrm{d}}^{(k)})^T$ expresses the $k$-th eigenstate of the interacting system as a linear combination of the original basis orbitals: $|\\psi_k\\rangle = c_{\\mathrm{H}}^{(k)}|\\mathrm{H}\\rangle + c_{\\mathrm{L}}^{(k)}|\\mathrm{L}\\rangle + c_{\\mathrm{d}}^{(k)}|\\mathrm{d}\\rangle$.\n\nThe total number of electrons in the system is specified as $N_{\\mathrm{e}} = 2$. According to the Aufbau principle for an independent-electron model, these electrons will occupy the eigenstates with the lowest energies. We must therefore sort the eigenvalues in ascending order, $E_1 \\leq E_2 \\leq E_3$. The two occupied states are $|\\psi_1\\rangle$ and $|\\psi_2\\rangle$.\n\nThe population of a given orbital $i \\in \\{\\mathrm{H, L, d}\\}$ in the interacting system, denoted $n_i$, is calculated by summing the squared magnitudes of its coefficients over all occupied eigenstates. As the basis $\\{ |i\\rangle \\}$ is orthonormal, the population is given by the projection of the occupied many-electron state onto the orbital subspace. In this one-electron picture, it is:\n$$\nn_i = \\sum_{k \\in \\mathrm{occ}} |\\langle i | \\psi_k \\rangle|^2 = \\sum_{k=1}^{2} |c_i^{(k)}|^2\n$$\nSpecifically, the populations for the HOMO, LUMO, and metal state are:\n$$\nn_{\\mathrm{H}} = |c_{\\mathrm{H}}^{(1)}|^2 + |c_{\\mathrm{H}}^{(2)}|^2 \\\\\nn_{\\mathrm{L}} = |c_{\\mathrm{L}}^{(1)}|^2 + |c_{\\mathrm{L}}^{(2)}|^2 \\\\\nn_{\\mathrm{d}} = |c_{\\mathrm{d}}^{(1)}|^2 + |c_{\\mathrm{d}}^{(2)}|^2\n$$\nSince the eigenvectors are normalized ($\\sum_i |c_i^{(k)}|^2 = 1$), the total number of electrons is conserved: $n_{\\mathrm{H}} + n_{\\mathrm{L}} + n_{\\mathrm{d}} = \\sum_{k=1}^{2} \\sum_{i} |c_i^{(k)}|^2 = \\sum_{k=1}^{2} 1 = 2 = N_{\\mathrm{e}}$.\n\nThe electron density difference is defined with respect to the non-interacting fragments, for which the populations are given as $n_{\\mathrm{H}}^{(0)} = 1$, $n_{\\mathrm{L}}^{(0)} = 0$, and $n_{\\mathrm{d}}^{(0)} = 1$. The population changes are $\\Delta n_{\\mathrm{H}} = n_{\\mathrm{H}} - n_{\\mathrm{H}}^{(0)}$, $\\Delta n_{\\mathrm{L}} = n_{\\mathrm{L}} - n_{\\mathrm{L}}^{(0)}$, and $\\Delta n_{\\mathrm{d}} = n_{\\mathrm{d}} - n_{\\mathrm{d}}^{(0)}$.\n\nFinally, donation ($D$) and backdonation ($B$) are quantified as:\n- Donation ($D$): The net loss of electron population from the adsorbate HOMO. It is a non-negative quantity.\n$$\nD = \\max(0, -\\Delta n_{\\mathrm{H}}) = \\max(0, n_{\\mathrm{H}}^{(0)} - n_{\\mathrm{H}}) = \\max(0, 1 - n_{\\mathrm{H}})\n$$\n- Backdonation ($B$): The net gain of electron population into the adsorbate LUMO. It is also a non-negative quantity.\n$$\nB = \\max(0, \\Delta n_{\\mathrm{L}}) = \\max(0, n_{\\mathrm{L}} - n_{\\mathrm{L}}^{(0)}) = \\max(0, n_{\\mathrm{L}})\n$$\nBoth $D$ and $B$ are expressed in units of electrons.\n\nThe algorithmic procedure is as follows:\n1. For each parameter set $(E_{\\mathrm{H}}, E_{\\mathrm{L}}, E_{\\mathrm{d}}, V_{\\mathrm{Hd}}, V_{\\mathrm{Ld}})$, construct the $3 \\times 3$ Hamiltonian matrix $H$.\n2. Numerically diagonalize $H$ to obtain its eigenvalues and eigenvectors. Standard linear algebra libraries provide robust routines for this, especially for real symmetric matrices, which yield eigenvalues sorted in ascending order.\n3. Identify the two eigenvectors corresponding to the two lowest eigenvalues.\n4. Calculate the orbital populations $n_{\\mathrm{H}}$ and $n_{\\mathrm{L}}$ by summing the squared components of these two eigenvectors.\n5. Compute donation $D$ and backdonation $B$ using their definitions.\n6. Collate the results for all test cases into the specified output format.\nThis procedure will now be implemented.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes donation and backdonation for an adsorbate-surface system\n    modeled by a 3x3 tight-binding Hamiltonian.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary of parameters in units of eV.\n    test_cases = [\n        {\n            'E_H': -10.0, 'E_L': +2.0, 'E_d': -2.0,\n            'V_Hd': 0.5, 'V_Ld': 0.4, 'N_e': 2\n        },\n        {\n            'E_H': -10.0, 'E_L': +2.0, 'E_d': -2.0,\n            'V_Hd': 0.0, 'V_Ld': 0.0, 'N_e': 2\n        },\n        {\n            'E_H': -12.0, 'E_L': -1.8, 'E_d': -2.0,\n            'V_Hd': 0.1, 'V_Ld': 1.0, 'N_e': 2\n        },\n        {\n            'E_H': -2.1, 'E_L': +5.0, 'E_d': -2.0,\n            'V_Hd': 1.0, 'V_Ld': 0.1, 'N_e': 2\n        },\n    ]\n\n    # Initial populations of the non-interacting fragments.\n    # n_H^(0) = 1, n_L^(0) = 0, n_d^(0) = 1\n    n_H_0 = 1.0\n    n_L_0 = 0.0\n\n    results = []\n    for params in test_cases:\n        # Step 1: Construct the Hamiltonian matrix H.\n        # The basis is {HOMO, LUMO, d-state}.\n        hamiltonian = np.array([\n            [params['E_H'], 0.0,           params['V_Hd']],\n            [0.0,           params['E_L'], params['V_Ld']],\n            [params['V_Hd'], params['V_Ld'], params['E_d']]\n        ])\n\n        # Step 2: Solve the eigenvalue problem H*c = E*c.\n        # np.linalg.eigh is used for Hermitian (real symmetric) matrices.\n        # It returns eigenvalues sorted in ascending order and corresponding\n        # eigenvectors as columns of a matrix.\n        eigenvalues, eigenvectors = np.linalg.eigh(hamiltonian)\n\n        # Step 3: Identify occupied states.\n        # The N_e lowest energy states are occupied. N_e = 2.\n        # These correspond to the first two columns of the eigenvector matrix.\n        occupied_eigenvectors = eigenvectors[:, :params['N_e']]\n\n        # Step 4: Calculate interacting orbital populations n_i.\n        # n_i = sum_k |c_i^(k)|^2 over occupied states k.\n        # Here, c_i^(k) is eigenvectors[i, k].\n        # Sum of squares of the first row components for the two occupied states.\n        n_H = np.sum(np.square(occupied_eigenvectors[0, :]))\n        # Sum of squares of the second row components for the two occupied states.\n        n_L = np.sum(np.square(occupied_eigenvectors[1, :]))\n        \n        # Step 5: Calculate Donation (D) and Backdonation (B).\n        # D = max(0, n_H^(0) - n_H)\n        donation = max(0.0, n_H_0 - n_H)\n        # B = max(0, n_L - n_L^(0))\n        backdonation = max(0.0, n_L - n_L_0)\n\n        results.append([donation, backdonation])\n\n    # Final print statement in the exact required format.\n    # Format: [[D1,B1],[D2,B2],[D3,B3],[D4,B4]] with no extra spaces.\n    inner_strings = [f\"[{d},{b}]\" for d, b in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the concept of charge transfer, this practice focuses on visualizing the electron density difference, $\\Delta \\rho$, in real space . You will implement a common modeling approach, constructing the $\\Delta \\rho$ field from Gaussian functions that represent regions of electron accumulation and depletion. This hands-on exercise is designed to build spatial intuition, demonstrating how the shape and symmetry of the density difference map directly reflect the geometry of the adsorption site, a critical skill for interpreting the results of real-world DFT calculations.",
            "id": "3878898",
            "problem": "A planar model system representing a square-lattice catalytic slab interacting with a single adsorbate is considered within the Born–Oppenheimer approximation, where the nuclei are fixed and electrons are described by their ground-state density field. The electron density field is defined as a nonnegative scalar field $\\rho(\\mathbf{r})$ on a two-dimensional spatial domain, interpreted as the number of electrons per unit area at position $\\mathbf{r}$. The mapping of electron density differences is obtained by solving for a redistribution field that, added to the superposition of isolated component densities, reproduces the combined system density while conserving total charge. Symmetry operations are represented as orthogonal linear transformations on the plane, such as rotations and reflections, applied to the electron density difference field.\n\nYou must implement a complete program that uses the following scientifically grounded model and definitions, and produces numerically testable outputs:\n\n- Construct a two-dimensional square computational grid covering a domain large enough to include all atoms and lobes, with $N$ points per axis and uniform spacing $dx$ in ångström (Å). Use $N = 201$ and $dx = 0.05\\,\\mathrm{\\AA}$.\n\n- Place four slab atoms forming a square lattice of lattice constant $a$, with positions $(x,y)$ given by the four corners $(+\\frac{a}{2},+\\frac{a}{2})$, $(+\\frac{a}{2},-\\frac{a}{2})$, $(-\\frac{a}{2},+\\frac{a}{2})$, and $(-\\frac{a}{2},-\\frac{a}{2})$. Use $a = 4.0\\,\\mathrm{\\AA}$.\n\n- An adsorbate atom is placed at a specified adsorption site $(x_\\mathrm{ads},y_\\mathrm{ads})$ on the same plane.\n\n- The isolated electron density contributions for the slab and adsorbate are modeled by normalized two-dimensional Gaussian fields. For an atom at position $\\mathbf{R}_i$ with a valence electron count $Q_i$ and Gaussian width parameter $\\sigma_i$, the isolated density contribution is defined as\n$$\n\\rho_i(\\mathbf{r}) \\;=\\; \\frac{Q_i}{2\\pi \\sigma_i^2}\\,\\exp\\!\\left(-\\frac{\\lVert \\mathbf{r} - \\mathbf{R}_i \\rVert^2}{2\\sigma_i^2}\\right),\n$$\nwhich integrates to $Q_i$ electrons over the plane. Use $Q_\\mathrm{slab} = 1.0$ electron per slab atom with $\\sigma_\\mathrm{slab} = 0.35\\,\\mathrm{\\AA}$, and $Q_\\mathrm{ads} = 1.0$ electron for the adsorbate with $\\sigma_\\mathrm{ads} = 0.25\\,\\mathrm{\\AA}$.\n\n- The combined system density is modeled as the superposition of isolated slab and adsorbate densities plus a polarization redistribution field that integrates to zero electrons. The redistribution field is constructed from Gaussian lobes as follows: for each slab atom $i$, define a positive lobe centered at the midpoint $\\mathbf{M}_i = \\frac{1}{2}(\\mathbf{R}_\\mathrm{ads} + \\mathbf{R}_i)$ with width $\\sigma_\\mathrm{pol}$ and amplitude $A\\,w_i$ electrons, where $A$ is the total positive lobe amplitude and $w_i$ are nonnegative weights that sum to $1$ and depend only on the adsorbate–slab distances. Define a single negative lobe centered at $\\mathbf{R}_\\mathrm{ads}$ with width $\\sigma_\\mathrm{pol}$ and amplitude $-A$ electrons. This guarantees global electron conservation. Use $A = 0.4$ electrons, $\\sigma_\\mathrm{pol} = 0.30\\,\\mathrm{\\AA}$, and distance-based weights\n$$\nw_i \\;=\\; \\frac{\\exp(-d_i / d_\\mathrm{scale})}{\\sum_j \\exp(-d_j / d_\\mathrm{scale})}, \\qquad d_i \\;=\\; \\lVert \\mathbf{R}_\\mathrm{ads} - \\mathbf{R}_i \\rVert,\n$$\nwith $d_\\mathrm{scale} = 2.0\\,\\mathrm{\\AA}$.\n\n- The electron density difference field $\\Delta \\rho(\\mathbf{r})$ is the unique redistribution field that, when added to the sum of isolated densities, reproduces the combined system density and integrates to zero electrons over the entire domain.\n\n- Implement symmetry operations on $\\Delta \\rho(\\mathbf{r})$:\n    1. Rotation by angle $\\theta$ in radians about the origin defined by the transformation $\\mathbf{r}\\mapsto \\mathbf{R}(\\theta)\\mathbf{r}$, where $\\mathbf{R}(\\theta)$ is the standard $2\\times 2$ rotation matrix.\n    2. Reflection across the $x$-axis defined by $\\mathbf{r}\\mapsto (x,-y)$.\n\n- Define the symmetry mismatch score as the ratio of the $L^2$ norm of the difference between the field and its transformed version to the $L^2$ norm of the original field,\n$$\nS \\;=\\; \\frac{\\left\\| \\Delta \\rho - \\mathcal{T}\\left[\\Delta \\rho\\right] \\right\\|_2}{\\left\\| \\Delta \\rho \\right\\|_2},\n$$\nwhere the $L^2$ norm is computed on the discrete grid with area weighting, and $\\mathcal{T}$ denotes a symmetry transformation. Treat the field as symmetric under $\\mathcal{T}$ if $S < \\varepsilon$, with $\\varepsilon = 1.0\\times 10^{-2}$.\n\n- Define the local charge transfer to the slab region as the integral of $\\Delta \\rho(\\mathbf{r})$ over the union of discs of radius $r_s$ centered at each slab atom position. Use $r_s = 0.60\\,\\mathrm{\\AA}$. Express this quantity in electrons.\n\n- Define the global neutrality check as the integral of $\\Delta \\rho(\\mathbf{r})$ over the entire domain; it should be numerically close to zero electrons.\n\nAngle units must be specified in radians for symmetry operations. All charge-transfer quantities must be expressed in electrons.\n\nTest Suite. Implement the following four test cases and compute the specified outputs:\n\n- Test Case $1$ (Hollow site): Adsorbate at $(0,0)$. Symmetry operation: rotation by $\\theta = \\pi/2$ radians. Output a boolean indicating whether the symmetry mismatch score is below the threshold.\n\n- Test Case $2$ (Bridge site): Adsorbate at $(+\\frac{a}{2},0)$. Symmetry operation: reflection across the $x$-axis. Output a boolean indicating whether the symmetry mismatch score is below the threshold.\n\n- Test Case $3$ (Top site): Adsorbate at $(+\\frac{a}{2},+\\frac{a}{2})$. Output the local charge transfer to the slab region in electrons as a float.\n\n- Test Case $4$ (Defect with broken symmetry): Move the slab atom originally at $(+\\frac{a}{2},+\\frac{a}{2})$ to $(+\\frac{a}{2},+\\frac{a}{2}+\\delta)$ with $\\delta = 0.30\\,\\mathrm{\\AA}$. Place the adsorbate at $(0,0)$. Symmetry operation: rotation by $\\theta = \\pi/2$ radians. Output two quantities: a boolean indicating whether the symmetry mismatch score is below the threshold, and a float giving the global neutrality integral (in electrons) of $\\Delta \\rho(\\mathbf{r})$ over the entire domain.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$[$result$_1$, result$_2$, result$_3$, result$_4$, result$_5]$, where result$_1$ and result$_2$ are booleans for Test Cases $1$ and $2$, result$_3$ is the float for Test Case $3$, result$_4$ is the boolean for Test Case $4$ symmetry, and result$_5$ is the float for Test Case $4$ global neutrality. The angle unit must be radians, and all charge-transfer values must be expressed in electrons.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of computational chemistry, specifically density functional theory modeling, and is mathematically well-posed with all necessary parameters and definitions provided for a deterministic computational solution. The definitions are clear, free of ambiguity, and the test cases are structured to produce verifiable numerical results.\n\n### Principle-Based Solution Design\n\nThe core task is to model and analyze the electron density difference field, $\\Delta \\rho(\\mathbf{r})$, for a model system of a catalytic slab and an adsorbate. This field represents the redistribution of electron charge due to the interaction between the slab and the adsorbate.\n\n#### 1. Computational Domain\nThe system is modeled on a two-dimensional square grid. The grid consists of $N \\times N$ points, with $N=201$. The grid spacing is uniform, $dx = 0.05\\,\\mathrm{\\AA}$. The total extent of the grid is determined by $L = \\frac{N-1}{2} dx = \\frac{200}{2} \\times 0.05 = 5.0\\,\\mathrm{\\AA}$. The grid coordinates $(x_j, y_k)$ thus span the domain $[-5.0, 5.0] \\times [-5.0, 5.0]\\,\\mathrm{\\AA}^2$. This domain is sufficiently large to contain all atomic centers and the significant portions of the electron density lobes.\n\n#### 2. Construction of the Electron Density Difference Field $\\Delta \\rho(\\mathbf{r})$\nThe problem provides a constructive definition for $\\Delta \\rho(\\mathbf{r})$ as a superposition of Gaussian charge distributions, which ensures that the total charge of this redistribution field is conserved (i.e., its integral over the entire domain is zero).\n\nFor a generic charge distribution (a \"lobe\") of total charge $Q$ centered at $\\mathbf{R}$ with width parameter $\\sigma$, its contribution to the density field is given by a normalized 2D Gaussian function:\n$$\n\\rho_{\\text{lobe}}(\\mathbf{r}) = \\frac{Q}{2\\pi \\sigma^2}\\,\\exp\\!\\left(-\\frac{\\lVert \\mathbf{r} - \\mathbf{R} \\rVert^2}{2\\sigma^2}\\right)\n$$\nThe electron density difference field $\\Delta\\rho(\\mathbf{r})$ is the sum of contributions from one negative lobe and four positive lobes:\n$$\n\\Delta \\rho(\\mathbf{r}) = \\rho_{\\text{pol}}^{-}(\\mathbf{r}) + \\sum_{i=1}^{4} \\rho_{\\text{pol}, i}^{+}(\\mathbf{r})\n$$\n- A single negative lobe is centered at the adsorbate position $\\mathbf{R}_\\mathrm{ads}$. It has a total charge of $-A$, where $A=0.4$ electrons, and a width $\\sigma_\\mathrm{pol} = 0.30\\,\\mathrm{\\AA}$.\n  $$\n  \\rho_{\\text{pol}}^{-}(\\mathbf{r}) = \\frac{-A}{2\\pi \\sigma_\\mathrm{pol}^2}\\,\\exp\\!\\left(-\\frac{\\lVert \\mathbf{r} - \\mathbf{R}_\\mathrm{ads} \\rVert^2}{2\\sigma_\\mathrm{pol}^2}\\right)\n  $$\n- Four positive lobes are associated with the four slab atoms at positions $\\mathbf{R}_i$. The $i$-th positive lobe is centered at the midpoint $\\mathbf{M}_i = \\frac{1}{2}(\\mathbf{R}_\\mathrm{ads} + \\mathbf{R}_i)$. Its width is also $\\sigma_\\mathrm{pol}$. Its charge is $A \\cdot w_i$, where the weights $w_i$ are calculated based on the distance $d_i = \\lVert \\mathbf{R}_\\mathrm{ads} - \\mathbf{R}_i \\rVert$ between the adsorbate and each slab atom:\n  $$\n  w_i = \\frac{\\exp(-d_i / d_\\mathrm{scale})}{\\sum_{j=1}^{4} \\exp(-d_j / d_\\mathrm{scale})}\n  $$\n  with $d_\\mathrm{scale} = 2.0\\,\\mathrm{\\AA}$. The weights are non-negative and sum to 1, $\\sum_i w_i = 1$. The contribution of the $i$-th positive lobe is thus:\n  $$\n  \\rho_{\\text{pol}, i}^{+}(\\mathbf{r}) = \\frac{A\\,w_i}{2\\pi \\sigma_\\mathrm{pol}^2}\\,\\exp\\!\\left(-\\frac{\\lVert \\mathbf{r} - \\mathbf{M}_i \\rVert^2}{2\\sigma_\\mathrm{pol}^2}\\right)\n  $$\nThe total charge of all positive lobes is $\\sum_i (A \\cdot w_i) = A \\sum_i w_i = A$. This perfectly cancels the charge of the negative lobe, $-A$, ensuring global charge neutrality, i.e., $\\int \\Delta\\rho(\\mathbf{r}) d^2\\mathbf{r} = 0$.\n\n#### 3. Numerical Computation of Observables\nAll quantities are computed numerically on the discrete grid.\n- **Numerical Integration**: The integral of a function $f(\\mathbf{r})$ over a region $\\Omega$ is approximated by a Riemann sum:\n  $$\n  \\int_\\Omega f(\\mathbf{r}) d^2\\mathbf{r} \\approx \\sum_{(x_j, y_k) \\in \\Omega} f(x_j, y_k) (dx)^2\n  $$\n  where $(dx)^2$ is the area element.\n\n- **Global Neutrality Check**: This is the integral of $\\Delta\\rho(\\mathbf{r})$ over the entire computational grid. Due to the construction of $\\Delta\\rho$, this value should be numerically close to zero.\n\n- **Local Charge Transfer**: This is the integral of $\\Delta\\rho(\\mathbf{r})$ over the union of four circular disks, each with radius $r_s = 0.60\\,\\mathrm{\\AA}$ centered at a slab atom position $\\mathbf{R}_i$.\n  $$\n  Q_{\\text{slab}} = \\int_{\\cup_{i} \\text{Disk}(\\mathbf{R}_i, r_s)} \\Delta\\rho(\\mathbf{r}) d^2\\mathbf{r}\n  $$\n\n- **Symmetry Analysis**: To assess the symmetry of $\\Delta\\rho(\\mathbf{r})$ under a transformation $\\mathcal{T}$, we compute the symmetry mismatch score $S$:\n  $$\n  S = \\frac{\\left\\| \\Delta \\rho - \\mathcal{T}\\left[\\Delta \\rho\\right] \\right\\|_2}{\\left\\| \\Delta \\rho \\right\\|_2}\n  $$\n  The discrete $L^2$ norm of a field $f$ on the grid is calculated as $\\left\\| f \\right\\|_2 = \\sqrt{\\sum_{j,k} |f(x_j, y_k)|^2 (dx)^2}$. The term $(dx)^2$ cancels in the ratio for $S$, so it simplifies to the ratio of vector norms of the gridded field values.\n  The transformed field $\\mathcal{T}[\\Delta \\rho]$ is evaluated at each grid point $\\mathbf{r}$ by finding the value of the original field $\\Delta\\rho$ at the pre-image point $\\mathbf{r}' = \\mathcal{T}^{-1}(\\mathbf{r})$, i.e., $\\mathcal{T}[\\Delta \\rho](\\mathbf{r}) = \\Delta\\rho(\\mathcal{T}^{-1}(\\mathbf{r}))$. Since $\\mathbf{r}'$ generally does not lie on a grid point, bilinear interpolation or a more sophisticated scheme is required. We will use `scipy.ndimage.map_coordinates` which implements spline interpolation.\n\n  - For a rotation by angle $\\theta$, the inverse transformation $\\mathcal{T}^{-1}$ is a rotation by $-\\theta$. The coordinates are transformed as:\n    $$\n    \\begin{pmatrix} x' \\\\ y' \\end{pmatrix} = \\begin{pmatrix} \\cos(-\\theta) & -\\sin(-\\theta) \\\\ \\sin(-\\theta) & \\cos(-\\theta) \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta & \\sin\\theta \\\\ -\\sin\\theta & \\cos\\theta \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix}\n    $$\n  - For a reflection across the $x$-axis, the transformation is $(x,y) \\mapsto (x,-y)$. It is its own inverse, so $\\mathcal{T} = \\mathcal{T}^{-1}$:\n    $$\n    \\begin{pmatrix} x' \\\\ y' \\end{pmatrix} = \\begin{pmatrix} x \\\\ -y \\end{pmatrix}\n    $$\n  The field is considered symmetric if $S$ is less than the threshold $\\varepsilon = 1.0 \\times 10^{-2}$.\n\n#### 4. Execution of Test Cases\nThe solution proceeds by implementing the above principles for each of the four specified test cases.\n- **Case 1 (Hollow site)**: Adsorbate at $\\mathbf{R}_{\\text{ads}} = (0,0)$. The four slab atoms are at $(\\pm_1 a/2, \\pm_2 a/2)$ with $a/2 = 2.0\\,\\mathrm{\\AA}$. The setup is symmetric under a rotation of $\\theta = \\pi/2$ about the origin. The distances $d_i$ are all equal, so the weights $w_i$ are all $1/4$. The set of positive lobe centers $\\{\\mathbf{M}_i\\}$ is mapped onto itself by the rotation. Thus, $\\Delta\\rho$ should be highly symmetric, and $S$ is expected to be very small.\n- **Case 2 (Bridge site)**: Adsorbate at $\\mathbf{R}_{\\text{ads}} = (a/2, 0) = (2.0, 0)$. The system is geometrically symmetric with respect to reflection across the $x$-axis. This symmetry will propagate to the weights $w_i$ and lobe centers $\\mathbf{M}_i$, making $\\Delta\\rho$ symmetric. $S$ is expected to be small.\n- **Case 3 (Top site)**: Adsorbate at $\\mathbf{R}_{\\text{ads}} = (a/2, a/2) = (2.0, 2.0)$, directly on top of a slab atom. The local charge transfer to the slab region, $Q_{\\text{slab}}$, is calculated by integrating $\\Delta\\rho$ over the specified disks.\n- **Case 4 (Defect)**: One slab atom is displaced from $(2.0, 2.0)$ to $(2.0, 2.3)$, breaking the four-fold rotational symmetry. The adsorbate is at the hollow site $(0,0)$. When tested for rotation by $\\theta = \\pi/2$, the mismatch score $S$ is expected to be large, i.e., $S \\geq \\varepsilon$. The global neutrality integral is also computed as a check on the model's formulation and its numerical implementation.\n\nThe final program will systematically apply these steps to each test case and format the results as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import map_coordinates\n\ndef solve():\n    \"\"\"\n    Solves the problem of analyzing a model electron density difference field\n    for various catalytic configurations.\n    \"\"\"\n\n    # --- Global Parameters ---\n    N = 201  # Grid points per axis\n    DX = 0.05  # Grid spacing in Angstrom\n    A_LATTICE = 4.0  # Lattice constant in Angstrom\n    A_AMP = 0.4  # Total positive lobe amplitude in electrons\n    SIGMA_POL = 0.30  # Polarization lobe width in Angstrom\n    D_SCALE = 2.0  # Weight decay length scale in Angstrom\n    R_S_INTEG = 0.60  # Integration radius for local charge in Angstrom\n    SYM_TOL = 1.0e-2  # Symmetry mismatch score tolerance\n\n    # --- Grid Setup ---\n    L = (N - 1) / 2 * DX\n    grid_coords_1d = np.linspace(-L, L, N)\n    XX, YY = np.meshgrid(grid_coords_1d, grid_coords_1d)\n\n    # --- Helper Functions ---\n    def gaussian_2d(centers, total_charge, sigma):\n        \"\"\"\n        Computes the sum of 2D Gaussian fields on the grid.\n        `centers` is a list of (x, y) tuples for center positions.\n        `total_charge` is a list of charges for each Gaussian.\n        \"\"\"\n        field = np.zeros((N, N))\n        norm_factor_base = 1.0 / (2 * np.pi * sigma**2)\n        for center, charge in zip(centers, total_charge):\n            r_sq = (XX - center[0])**2 + (YY - center[1])**2\n            field += (charge * norm_factor_base) * np.exp(-r_sq / (2 * sigma**2))\n        return field\n\n    def compute_delta_rho(slab_pos_list, ads_pos):\n        \"\"\"\n        Constructs the electron density difference field delta_rho.\n        \"\"\"\n        slab_pos = np.array(slab_pos_list)\n        ads_pos = np.array(ads_pos)\n\n        # Calculate distance-based weights\n        distances = np.linalg.norm(slab_pos - ads_pos, axis=1)\n        exp_d = np.exp(-distances / D_SCALE)\n        weights = exp_d / np.sum(exp_d)\n\n        # Define lobe centers and charges\n        pos_lobe_centers = 0.5 * (slab_pos + ads_pos)\n        pos_lobe_charges = A_AMP * weights\n        \n        neg_lobe_center = ads_pos\n        neg_lobe_charge = -A_AMP\n\n        # Sum up all lobes to get delta_rho\n        delta_rho_field = gaussian_2d(pos_lobe_centers.tolist(), pos_lobe_charges, SIGMA_POL)\n        delta_rho_field += gaussian_2d([neg_lobe_center.tolist()], [neg_lobe_charge], SIGMA_POL)\n\n        return delta_rho_field\n\n    def transform_field(field, rot_matrix=None, reflect_x=False):\n        \"\"\"\n        Applies a symmetry transformation to the field using interpolation.\n        `rot_matrix` is the INVERSE of the rotation matrix.\n        \"\"\"\n        # Physical coordinates of each grid point\n        initial_coords = np.vstack([XX.ravel(), YY.ravel()])\n        \n        # Apply inverse transformation to find where to sample from\n        if rot_matrix is not None:\n             transformed_coords_phys = rot_matrix @ initial_coords\n        elif reflect_x:\n            # Reflection is its own inverse\n            reflection_matrix = np.array([[1, 0], [0, -1]])\n            transformed_coords_phys = reflection_matrix @ initial_coords\n        else:\n            return field.copy()\n\n        # Convert physical coordinates to grid index coordinates for interpolation\n        # index = (physical_coord - min_coord) / dx\n        tx_phys, ty_phys = transformed_coords_phys[0], transformed_coords_phys[1]\n        \n        ix = (tx_phys + L) / DX\n        iy = (ty_phys + L) / DX\n\n        # map_coordinates expects coordinates in (row, col) i.e., (y, x) order\n        interp_coords = np.vstack([iy, ix])\n        \n        transformed_field_flat = map_coordinates(field, interp_coords, order=3, mode='constant', cval=0.0)\n        \n        return transformed_field_flat.reshape((N, N))\n\n    def compute_symmetry_score(field1, field2):\n        \"\"\"Calculates the L2 norm-based symmetry mismatch score.\"\"\"\n        norm_diff = np.linalg.norm(field1 - field2)\n        norm_orig = np.linalg.norm(field1)\n        return norm_diff / norm_orig if norm_orig > 0 else 0.0\n\n    def compute_local_charge_transfer(field, slab_pos_list):\n        \"\"\"Integrates delta_rho over disks around slab atoms.\"\"\"\n        mask = np.zeros_like(field, dtype=bool)\n        for pos in slab_pos_list:\n            dist_sq = (XX - pos[0])**2 + (YY - pos[1])**2\n            mask |= (dist_sq <= R_S_INTEG**2)\n        \n        charge = np.sum(field[mask]) * (DX**2)\n        return charge\n\n    def compute_global_neutrality(field):\n        \"\"\"Integrates delta_rho over the entire domain.\"\"\"\n        return np.sum(field) * (DX**2)\n\n    results = []\n    \n    # --- Base Slab Geometry ---\n    half_a = A_LATTICE / 2.0\n    base_slab_pos = [\n        (half_a, half_a), (half_a, -half_a),\n        (-half_a, half_a), (-half_a, -half_a)\n    ]\n\n    # --- Test Case 1: Hollow site ---\n    ads_pos_1 = (0.0, 0.0)\n    delta_rho_1 = compute_delta_rho(base_slab_pos, ads_pos_1)\n    theta_1 = np.pi / 2\n    # Inverse rotation matrix (rotation by -theta)\n    rot_mat_inv_1 = np.array([[np.cos(theta_1), np.sin(theta_1)],\n                              [-np.sin(theta_1), np.cos(theta_1)]])\n    transformed_rho_1 = transform_field(delta_rho_1, rot_matrix=rot_mat_inv_1)\n    score_1 = compute_symmetry_score(delta_rho_1, transformed_rho_1)\n    results.append(score_1 < SYM_TOL)\n\n    # --- Test Case 2: Bridge site ---\n    ads_pos_2 = (half_a, 0.0)\n    delta_rho_2 = compute_delta_rho(base_slab_pos, ads_pos_2)\n    transformed_rho_2 = transform_field(delta_rho_2, reflect_x=True)\n    score_2 = compute_symmetry_score(delta_rho_2, transformed_rho_2)\n    results.append(score_2 < SYM_TOL)\n    \n    # --- Test Case 3: Top site ---\n    ads_pos_3 = (half_a, half_a)\n    delta_rho_3 = compute_delta_rho(base_slab_pos, ads_pos_3)\n    local_charge_3 = compute_local_charge_transfer(delta_rho_3, base_slab_pos)\n    results.append(local_charge_3)\n\n    # --- Test Case 4: Defect ---\n    delta_defect = 0.30\n    defect_slab_pos = base_slab_pos.copy()\n    defect_slab_pos[0] = (half_a, half_a + delta_defect)\n    ads_pos_4 = (0.0, 0.0)\n    delta_rho_4 = compute_delta_rho(defect_slab_pos, ads_pos_4)\n    theta_4 = np.pi / 2\n    rot_mat_inv_4 = np.array([[np.cos(theta_4), np.sin(theta_4)],\n                              [-np.sin(theta_4), np.cos(theta_4)]])\n    transformed_rho_4 = transform_field(delta_rho_4, rot_matrix=rot_mat_inv_4)\n    score_4 = compute_symmetry_score(delta_rho_4, transformed_rho_4)\n    results.append(score_4 < SYM_TOL)\n    \n    neutrality_4 = compute_global_neutrality(delta_rho_4)\n    results.append(neutrality_4)\n    \n    # --- Final Output ---\n    # Convert booleans to lowercase 'true'/'false' for consistency if needed, but problem doesn't specify\n    str_results = []\n    for r in results:\n        if isinstance(r, bool):\n            str_results.append(str(r).lower())\n        else:\n            str_results.append(f\"{r:.8f}\")\n\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "An electron density difference map is not just a picture; it represents a physical change with measurable consequences. This final practice connects the charge redistribution, $\\Delta \\rho$, to its most direct physical effect: the change in the electrostatic potential . You will solve the Poisson equation using spectral methods in a periodic system, a core technique in computational materials science. This exercise illuminates how charge rearrangement modifies the local electrostatic landscape, which is fundamental to understanding and predicting catalytic reactivity.",
            "id": "3878880",
            "problem": "Consider electron density difference mapping in computational catalysis for a periodic cubic unit cell, where an adsorbate induces a redistribution of electron density on a catalytic surface. The electron density difference, denoted as $\\Delta \\rho(\\mathbf{r})$, is formally defined by the superposition principle as $\\Delta \\rho(\\mathbf{r}) = \\rho_{\\text{combined}}(\\mathbf{r}) - \\rho_{\\text{adsorbate}}(\\mathbf{r}) - \\rho_{\\text{surface}}(\\mathbf{r})$. The electrostatic potential $\\phi(\\mathbf{r})$ generated by $\\Delta \\rho(\\mathbf{r})$ in vacuum is governed by a fundamental law from classical electromagnetism: Gauss’s law for electrostatics (combined with the definition of the electrostatic field as the gradient of a scalar potential) implies the Poisson equation $\\nabla^2 \\phi(\\mathbf{r}) = -\\Delta \\rho(\\mathbf{r})/\\varepsilon_0$, where $\\varepsilon_0$ is the vacuum permittivity. In a periodic cubic cell of edge length $L$ with periodic boundary conditions, both $\\Delta \\rho(\\mathbf{r})$ and $\\phi(\\mathbf{r})$ admit Fourier series representations. The problem requires you to derive, implement, and evaluate a spectral (Fourier-domain) solution to this Poisson problem for specified test electron density differences that model charge redistribution typical of adsorption on catalytic surfaces.\n\nStarting from fundamental laws of electromagnetism (Gauss’s law and the definition of the electrostatic field) and the core definitions of Fourier series on a periodic domain, derive the computational approach to obtain $\\phi(\\mathbf{r})$ from $\\Delta \\rho(\\mathbf{r})$ in a cubic periodic cell. You must consider the physically realistic requirement that the $k=\\mathbf{0}$ Fourier component (the spatial average of $\\Delta \\rho(\\mathbf{r})$) cannot generate a finite periodic potential. In computational practice for periodic boundary conditions, this necessitates enforcing global charge neutrality by subtracting the mean of $\\Delta \\rho(\\mathbf{r})$ before solving the Poisson equation, which sets the reference potential to have zero average.\n\nImplement the following programmatic tasks in a self-contained way:\n\n1. Construct $\\Delta \\rho(\\mathbf{r})$ on a uniform three-dimensional grid of $N \\times N \\times N$ points spanning a cubic domain of edge length $L$ using a superposition of two normalized three-dimensional Gaussian lobes with equal and opposite integrated charges. Let the positive lobe be centered at $\\mathbf{r}_+$ with charge $q_+$ and the negative lobe at $\\mathbf{r}_-$ with charge $q_-$, with $q_+ + q_- \\approx 0$. Each lobe is modeled by a normalized Gaussian\n$$\nG(\\mathbf{r};\\mathbf{r}_0,\\sigma) = \\frac{1}{(2\\pi)^{3/2}\\sigma^3} \\exp\\left(-\\frac{\\|\\mathbf{r} - \\mathbf{r}_0\\|^2}{2\\sigma^2}\\right),\n$$\nso that the density is\n$$\n\\Delta \\rho(\\mathbf{r}) = q_+ \\, G(\\mathbf{r};\\mathbf{r}_+,\\sigma) + q_- \\, G(\\mathbf{r};\\mathbf{r}_-,\\sigma).\n$$\nImpose periodicity by evaluating distances with minimum-image convention under the cubic periodic boundary conditions.\n\n2. Enforce neutrality for the periodic Poisson solve by subtracting the spatial mean of $\\Delta \\rho(\\mathbf{r})$ over the cell before computing the potential.\n\n3. Solve the Poisson equation spectrally by transforming $\\Delta \\rho(\\mathbf{r})$ to reciprocal space, acting with the inverse Laplacian operator (diagonal in Fourier space), and transforming back to real space to obtain $\\phi(\\mathbf{r})$ on the grid. Handle the $\\mathbf{k}=\\mathbf{0}$ mode appropriately to avoid division by zero.\n\n4. Evaluate $\\phi(\\mathbf{r})$ at three physically relevant points for each test case: the centers of the positive and negative Gaussian lobes ($\\mathbf{r}_+$ and $\\mathbf{r}_-$), and the midpoint $\\mathbf{r}_{\\text{mid}} = (\\mathbf{r}_+ + \\mathbf{r}_-)/2$. Use nearest-grid-point sampling to approximate $\\phi(\\mathbf{r})$ at these positions. Express the potential values in volts and report the results as floating-point numbers.\n\nUse the vacuum permittivity $\\varepsilon_0 = 8.854187817 \\times 10^{-12}$ farad per meter. All positions must be within the periodic box of size $L$. All physical quantities must be treated with International System of Units (SI units): length in meters, charge in coulombs, density in coulombs per cubic meter, and potential in volts. Angles are not involved.\n\nTest Suite and required outputs:\nFor each of the following parameter sets, compute and return the three potential values in volts at the points $\\mathbf{r}_+$, $\\mathbf{r}_-$, and $\\mathbf{r}_{\\text{mid}}$.\n\n- Case 1 (neutral redistribution, moderate separation):\n  - $L = 1.0 \\times 10^{-9}$ meters,\n  - $N = 64$,\n  - $q_+ = 1.0 \\times 10^{-19}$ coulombs,\n  - $q_- = -1.0 \\times 10^{-19}$ coulombs,\n  - $\\sigma = 8.0 \\times 10^{-11}$ meters,\n  - $\\mathbf{r}_+ = (0.25L, 0.50L, 0.50L)$,\n  - $\\mathbf{r}_- = (0.75L, 0.50L, 0.50L)$.\n\n- Case 2 (near-neutral redistribution, mean-subtraction required):\n  - $L = 1.2 \\times 10^{-9}$ meters,\n  - $N = 64$,\n  - $q_+ = 1.0 \\times 10^{-19}$ coulombs,\n  - $q_- = -0.99 \\times 10^{-19}$ coulombs,\n  - $\\sigma = 6.0 \\times 10^{-11}$ meters,\n  - $\\mathbf{r}_+ = (0.40L, 0.40L, 0.40L)$,\n  - $\\mathbf{r}_- = (0.60L, 0.60L, 0.60L)$.\n\n- Case 3 (neutral redistribution, narrow lobes near boundaries to test periodicity):\n  - $L = 8.0 \\times 10^{-10}$ meters,\n  - $N = 64$,\n  - $q_+ = 0.5 \\times 10^{-19}$ coulombs,\n  - $q_- = -0.5 \\times 10^{-19}$ coulombs,\n  - $\\sigma = 2.0 \\times 10^{-11}$ meters,\n  - $\\mathbf{r}_+ = (0.10L, 0.10L, 0.70L)$,\n  - $\\mathbf{r}_- = (0.90L, 0.90L, 0.30L)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[\\phi(\\mathbf{r}_+), \\phi(\\mathbf{r}_-), \\phi(\\mathbf{r}_{\\text{mid}})]$ for Case $1$, followed by the same triplet for Case $2$, and then Case $3$. All values must be expressed in volts, with no unit symbols in the output, and represented as floating-point numbers. For example, the output format is $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\ldots]$.",
            "solution": "The problem requires the calculation of the electrostatic potential $\\phi(\\mathbf{r})$ resulting from a given electron density difference $\\Delta\\rho(\\mathbf{r})$ within a cubic periodic cell of side length $L$. This is a canonical problem in computational physics and chemistry, solvable via the Poisson equation.\n\nThe fundamental relationship between the electrostatic potential $\\phi(\\mathbf{r})$ and the charge density $\\Delta\\rho(\\mathbf{r})$ is given by the Poisson equation, which is derived from Gauss's law for electrostatics ($\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$) and the definition of the electrostatic field as the negative gradient of the potential ($\\mathbf{E} = -\\nabla \\phi$). Combining these gives:\n$$\n\\nabla^2 \\phi(\\mathbf{r}) = -\\frac{\\Delta\\rho(\\mathbf{r})}{\\varepsilon_0}\n$$\nwhere $\\nabla^2$ is the Laplacian operator and $\\varepsilon_0$ is the vacuum permittivity, given as $8.854187817 \\times 10^{-12} \\, \\text{F/m}$.\n\nThe problem is set in a periodic domain, which makes it highly amenable to a solution in Fourier space. A function $f(\\mathbf{r})$ that is periodic on a cubic box of volume $V = L^3$ can be represented by a Fourier series:\n$$\nf(\\mathbf{r}) = \\sum_{\\mathbf{k}} \\hat{f}(\\mathbf{k}) e^{i \\mathbf{k} \\cdot \\mathbf{r}}\n$$\nThe sum is over the discrete set of reciprocal lattice vectors $\\mathbf{k} = \\frac{2\\pi}{L}(n_x, n_y, n_z)$, where $n_x, n_y, n_z$ are integers. The Fourier coefficients $\\hat{f}(\\mathbf{k})$ are given by the inverse relation:\n$$\n\\hat{f}(\\mathbf{k}) = \\frac{1}{V} \\int_V f(\\mathbf{r}) e^{-i \\mathbf{k} \\cdot \\mathbf{r}} d^3\\mathbf{r}\n$$\nApplying the Fourier transform to the Laplacian operator yields a simple multiplicative factor: $\\mathcal{F}\\{\\nabla^2 f(\\mathbf{r})\\} = -\\|\\mathbf{k}\\|^2 \\hat{f}(\\mathbf{k})$, where $\\|\\mathbf{k}\\|^2 = k_x^2 + k_y^2 + k_z^2$.\n\nTransforming the entire Poisson equation into the Fourier domain gives:\n$$\n-\\|\\mathbf{k}\\|^2 \\hat{\\phi}(\\mathbf{k}) = -\\frac{\\hat{\\Delta\\rho}(\\mathbf{k})}{\\varepsilon_0}\n$$\nSolving for the Fourier coefficients of the potential $\\hat{\\phi}(\\mathbf{k})$ yields:\n$$\n\\hat{\\phi}(\\mathbf{k}) = \\frac{\\hat{\\Delta\\rho}(\\mathbf{k})}{\\varepsilon_0 \\|\\mathbf{k}\\|^2}\n$$\nThis expression is valid for all $\\mathbf{k} \\neq \\mathbf{0}$. The case $\\mathbf{k} = \\mathbf{0}$ requires special attention. For $\\mathbf{k} = \\mathbf{0}$, the denominator $\\|\\mathbf{k}\\|^2$ becomes zero. A physically meaningful, bounded potential can only exist if the numerator is also zero. The $\\mathbf{k}=\\mathbf{0}$ component of the density, $\\hat{\\Delta\\rho}(\\mathbf{k}=\\mathbf{0})$, is the spatial average of the density over the unit cell:\n$$\n\\hat{\\Delta\\rho}(\\mathbf{k}=\\mathbf{0}) = \\frac{1}{V} \\int_V \\Delta\\rho(\\mathbf{r}) d^3\\mathbf{r} = \\frac{Q_{\\text{total}}}{V}\n$$\nThis implies that the total charge $Q_{\\text{total}}$ in the periodic cell must be zero. The problem explicitly addresses cases where this might not be true (Case 2) and mandates the enforcement of neutrality by subtracting the mean density. This procedure is equivalent to adding a uniform compensating background charge. We define a neutralized density $\\Delta\\rho'(\\mathbf{r}) = \\Delta\\rho(\\mathbf{r}) - \\langle\\Delta\\rho\\rangle$, where $\\langle\\Delta\\rho\\rangle = Q_{\\text{total}}/V$. By construction, $\\hat{\\Delta\\rho'}(\\mathbf{k}=\\mathbf{0}) = 0$.\n\nFor $\\mathbf{k}=\\mathbf{0}$, the value of $\\hat{\\phi}(\\mathbf{k}=\\mathbf{0})$ represents the average potential over the cell. Since the absolute potential is defined only up to an arbitrary constant, we are free to set this average value. The standard and most convenient choice is to set the average potential to zero, which means $\\hat{\\phi}(\\mathbf{k}=\\mathbf{0}) = 0$.\n\nThe computational algorithm is as follows:\n1.  **Discretize the Domain**: Represent the cubic cell of side $L$ with a uniform $N \\times N \\times N$ grid of points. The grid spacing is $h = L/N$.\n2.  **Construct Charge Density**: The density difference $\\Delta\\rho(\\mathbf{r})$ is constructed on this grid. It is the sum of two Gaussian distributions, $q_+ G(\\mathbf{r};\\mathbf{r}_+,\\sigma)$ and $q_- G(\\mathbf{r};\\mathbf{r}_-,\\sigma)$. To respect the periodic boundary conditions, the distance $\\|\\mathbf{r} - \\mathbf{r}_0\\|$ in the Gaussian exponent is calculated using the minimum-image convention. For a given component, say $x$, the distance is $\\Delta x' = \\Delta x - L \\cdot \\text{round}(\\Delta x / L)$.\n3.  **Enforce Charge Neutrality**: Compute the mean of the discretized density, $\\langle\\Delta\\rho\\rangle = \\frac{1}{N^3} \\sum_{i,j,k} \\Delta\\rho(\\mathbf{r}_{ijk})$, and subtract it from each grid point: $\\Delta\\rho'_{ijk} = \\Delta\\rho_{ijk} - \\langle\\Delta\\rho\\rangle$.\n4.  **Forward Fourier Transform**: Compute the discrete Fourier transform of the neutralized density grid $\\Delta\\rho'$ using a Fast Fourier Transform (FFT) algorithm to obtain $\\hat{\\Delta\\rho'}(\\mathbf{k})$.\n5.  **Solve in Reciprocal Space**:\n    a. Construct the grid of reciprocal space vectors $\\mathbf{k}$. The components for a grid of size $N$ and length $L$ are given by $k_x = 2\\pi \\nu_x$, where $\\nu_x$ are the frequencies returned by standard FFT frequency functions (e.g., `numpy.fft.fftfreq`).\n    b. Calculate the squared magnitude $\\|\\mathbf{k}\\|^2$ for each point in the reciprocal grid.\n    c. Compute the Fourier coefficients of the potential: $\\hat{\\phi}(\\mathbf{k}) = \\hat{\\Delta\\rho'}(\\mathbf{k}) / (\\varepsilon_0 \\|\\mathbf{k}\\|^2)$ for all $\\mathbf{k} \\neq \\mathbf{0}$.\n    d. Set the D.C. component to zero: $\\hat{\\phi}(\\mathbf{k}=\\mathbf{0}) = 0$. This is done by setting the $[0,0,0]$ element of the array to $0$ after the division.\n6.  **Inverse Fourier Transform**: Compute the inverse FFT of the $\\hat{\\phi}(\\mathbf{k})$ grid to obtain the real-space potential $\\phi(\\mathbf{r})$ on the grid. The result of a numerical IFFT may have small, spurious imaginary parts, so we take the real part of the final result.\n7.  **Sample Potential**: Evaluate the potential at the specified points $\\mathbf{r}_+$, $\\mathbf{r}_-$, and $\\mathbf{r}_{\\text{mid}}$ by finding the nearest grid point to each target location and retrieving the corresponding potential value. The index for a coordinate $x$ is found via $i_x = \\text{round}(x \\cdot N/L) \\pmod N$.\n\nThis spectral method is computationally efficient, leveraging the $O(N^3 \\log N)$ complexity of the FFT algorithm, and is the standard approach for solving the Poisson equation in periodic simulations.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Poisson equation for electron density difference in a periodic\n    cubic cell using a spectral (Fourier) method.\n    \"\"\"\n    \n    # Constants\n    epsilon_0 = 8.854187817e-12  # Vacuum permittivity in F/m\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        {\n            \"L\": 1.0e-9, \"N\": 64, \"q_plus\": 1.0e-19, \"q_minus\": -1.0e-19,\n            \"sigma\": 8.0e-11, \"r_plus\": np.array([0.25, 0.50, 0.50]),\n            \"r_minus\": np.array([0.75, 0.50, 0.50])\n        },\n        {\n            \"L\": 1.2e-9, \"N\": 64, \"q_plus\": 1.0e-19, \"q_minus\": -0.99e-19,\n            \"sigma\": 6.0e-11, \"r_plus\": np.array([0.40, 0.40, 0.40]),\n            \"r_minus\": np.array([0.60, 0.60, 0.60])\n        },\n        {\n            \"L\": 8.0e-10, \"N\": 64, \"q_plus\": 0.5e-19, \"q_minus\": -0.5e-19,\n            \"sigma\": 2.0e-11, \"r_plus\": np.array([0.10, 0.10, 0.70]),\n            \"r_minus\": np.array([0.90, 0.90, 0.30])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        N = case[\"N\"]\n        q_plus = case[\"q_plus\"]\n        q_minus = case[\"q_minus\"]\n        sigma = case[\"sigma\"]\n        # Convert fractional coordinates to absolute coordinates\n        r_plus_abs = case[\"r_plus\"] * L\n        r_minus_abs = case[\"r_minus\"] * L\n        r_mid_abs = (r_plus_abs + r_minus_abs) / 2.0\n\n        # 1. Construct the grid and charge density\n        grid_coords = np.linspace(0, L, N, endpoint=False)\n        xx, yy, zz = np.meshgrid(grid_coords, grid_coords, grid_coords, indexing='ij')\n\n        def build_gaussian(q, r0, sigma_val):\n            # Calculate distance components with minimum image convention\n            dx = xx - r0[0]\n            dy = yy - r0[1]\n            dz = zz - r0[2]\n            \n            dx -= L * np.round(dx / L)\n            dy -= L * np.round(dy / L)\n            dz -= L * np.round(dz / L)\n            \n            dist_sq = dx**2 + dy**2 + dz**2\n            \n            norm_factor = 1.0 / ((2 * np.pi)**1.5 * sigma_val**3)\n            gaussian = norm_factor * np.exp(-dist_sq / (2 * sigma_val**2))\n            return q * gaussian\n\n        delta_rho = build_gaussian(q_plus, r_plus_abs, sigma) + \\\n                    build_gaussian(q_minus, r_minus_abs, sigma)\n\n        # 2. Enforce global charge neutrality\n        mean_rho = np.mean(delta_rho)\n        delta_rho_neutral = delta_rho - mean_rho\n\n        # 3. Solve Poisson equation in Fourier space\n        \n        # Forward FFT\n        rho_hat = np.fft.fftn(delta_rho_neutral)\n        \n        # Construct k-vectors\n        k_freq = np.fft.fftfreq(N, d=L/N)\n        kx = 2 * np.pi * k_freq\n        ky = 2 * np.pi * k_freq\n        kz = 2 * np.pi * k_freq\n        kxx, kyy, kzz = np.meshgrid(kx, ky, kz, indexing='ij')\n        \n        # Squared k-magnitude\n        k_sq = kxx**2 + kyy**2 + kzz**2\n\n        # Avoid division by zero at k=0\n        # The numerator rho_hat[0,0,0] is already zero due to mean subtraction\n        # but we must prevent the division to avoid NaN.\n        with np.errstate(divide='ignore', invalid='ignore'):\n            phi_hat = rho_hat / (epsilon_0 * k_sq)\n        \n        # Explicitly set the k=0 component to zero to enforce zero average potential\n        phi_hat[0, 0, 0] = 0.0\n        \n        # Inverse FFT to get potential in real space\n        phi_r = np.real(np.fft.ifftn(phi_hat))\n\n        # 4. Evaluate potential at specified points using nearest-grid-point sampling\n        def get_potential_at(pos_abs):\n            indices = (np.round((pos_abs / L) * N) % N).astype(int)\n            return phi_r[indices[0], indices[1], indices[2]]\n\n        phi_r_plus = get_potential_at(r_plus_abs)\n        phi_r_minus = get_potential_at(r_minus_abs)\n        phi_r_mid = get_potential_at(r_mid_abs)\n        \n        results.extend([phi_r_plus, phi_r_minus, phi_r_mid])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}