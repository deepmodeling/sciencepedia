{
    "hands_on_practices": [
        {
            "introduction": "理解电子密度差首先要将其可视化。本练习将指导您为一个模型催化剂表面构建一个 $\\Delta \\rho(\\mathbf{r})$ 图，让您直观地看到电荷如何根据吸附位点的不同而重新排布。通过分析该图的对称性，您将为这一基本概念建立起具体的、空间化的直觉。",
            "id": "3878898",
            "problem": "在 Born–Oppenheimer 近似下，我们考虑一个平面模型系统，该系统代表一个方形晶格催化板与单个吸附物相互作用。在该近似下，原子核位置固定，电子由其基态密度场描述。电子密度场被定义为一个在二维空间域上的非负标量场 $\\rho(\\mathbf{r})$，其物理解释为在位置 $\\mathbf{r}$ 处单位面积的电子数。电子密度差的映射是通过求解一个重分布场得到的。该重分布场加到孤立组分密度的叠加之上，可以再现组合系统的密度，同时保持总电荷守恒。对称操作表现为施加在电子密度差场上的平面正交线性变换，例如旋转和反射。\n\n您必须实现一个完整的程序，该程序使用以下有科学依据的模型和定义，并产生可进行数值检验的输出：\n\n- 构造一个二维方形计算网格，该网格覆盖一个足够大的域以包含所有原子和波瓣，每个轴有 $N$ 个点，均匀间距为 $dx$（单位为埃，Å）。使用 $N = 201$ 和 $dx = 0.05\\,\\mathrm{\\AA}$。\n\n- 放置四个板原子，形成晶格常数为 $a$ 的方形晶格，其位置 $(x,y)$ 由四个角点 $(+\\frac{a}{2},+\\frac{a}{2})$、$(+\\frac{a}{2},-\\frac{a}{2})$、$(-\\frac{a}{2},+\\frac{a}{2})$ 和 $(-\\frac{a}{2},-\\frac{a}{2})$ 给出。使用 $a = 4.0\\,\\mathrm{\\AA}$。\n\n- 一个吸附物原子被放置在同一平面上一个指定的吸附位点 $(x_\\mathrm{ads},y_\\mathrm{ads})$。\n\n- 板和吸附物的孤立电子密度贡献通过归一化的二维高斯场建模。对于位于位置 $\\mathbf{R}_i$、价电子数为 $Q_i$、高斯宽度参数为 $\\sigma_i$ 的原子，其孤立密度贡献定义为\n$$\n\\rho_i(\\mathbf{r}) \\;=\\; \\frac{Q_i}{2\\pi \\sigma_i^2}\\,\\exp\\!\\left(-\\frac{\\lVert \\mathbf{r} - \\mathbf{R}_i \\rVert^2}{2\\sigma_i^2}\\right),\n$$\n其在整个平面上积分为 $Q_i$ 个电子。对每个板原子使用 $Q_\\mathrm{slab} = 1.0$ 电子，$\\sigma_\\mathrm{slab} = 0.35\\,\\mathrm{\\AA}$；对吸附物使用 $Q_\\mathrm{ads} = 1.0$ 电子，$\\sigma_\\mathrm{ads} = 0.25\\,\\mathrm{\\AA}$。\n\n- 组合系统的密度被建模为孤立的板和吸附物密度的叠加，再加上一个积分为零电子的极化重分布场。该重分布场由高斯波瓣构成，具体如下：对于每个板原子 $i$，在其中点 $\\mathbf{M}_i = \\frac{1}{2}(\\mathbf{R}_\\mathrm{ads} + \\mathbf{R}_i)$ 处定义一个宽度为 $\\sigma_\\mathrm{pol}$、振幅为 $A\\,w_i$ 电子的正波瓣，其中 $A$ 是总正波瓣振幅，$w_i$ 是总和为 $1$ 的非负权重，且仅依赖于吸附物与板的距离。在 $\\mathbf{R}_\\mathrm{ads}$ 处定义一个宽度为 $\\sigma_\\mathrm{pol}$、振幅为 $-A$ 电子的单独负波瓣。这保证了全局电子守恒。使用 $A = 0.4$ 电子，$\\sigma_\\mathrm{pol} = 0.30\\,\\mathrm{\\AA}$，以及基于距离的权重\n$$\nw_i \\;=\\; \\frac{\\exp(-d_i / d_\\mathrm{scale})}{\\sum_j \\exp(-d_j / d_\\mathrm{scale})}, \\qquad d_i \\;=\\; \\lVert \\mathbf{R}_\\mathrm{ads} - \\mathbf{R}_i \\rVert,\n$$\n其中 $d_\\mathrm{scale} = 2.0\\,\\mathrm{\\AA}$。\n\n- 电子密度差场 $\\Delta \\rho(\\mathbf{r})$ 是唯一的重分布场，当它与孤立密度之和相加时，能够再现组合系统的密度，并且在整个域上的积分为零电子。\n\n- 在 $\\Delta \\rho(\\mathbf{r})$ 上实现对称操作：\n    1. 绕原点旋转角度 $\\theta$ (以弧度为单位)，由变换 $\\mathbf{r}\\mapsto \\mathbf{R}(\\theta)\\mathbf{r}$ 定义，其中 $\\mathbf{R}(\\theta)$ 是标准的 $2\\times 2$ 旋转矩阵。\n    2. 沿 $x$ 轴反射，由 $\\mathbf{r}\\mapsto (x,-y)$ 定义。\n\n- 定义对称失配分数为场与其变换后版本之差的 $L^2$ 范数与原始场的 $L^2$ 范数的比值，\n$$\nS \\;=\\; \\frac{\\left\\| \\Delta \\rho - \\mathcal{T}\\left[\\Delta \\rho\\right] \\right\\|_2}{\\left\\| \\Delta \\rho \\right\\|_2},\n$$\n其中 $L^2$ 范数在带有面积加权的离散网格上计算，$\\mathcal{T}$ 表示一个对称变换。如果 $S  \\varepsilon$（其中 $\\varepsilon = 1.0\\times 10^{-2}$），则认为该场在 $\\mathcal{T}$ 下是对称的。\n\n- 定义到板区域的局域电荷转移为 $\\Delta \\rho(\\mathbf{r})$ 在以每个板原子位置为中心、半径为 $r_s$ 的圆盘的并集上的积分。使用 $r_s = 0.60\\,\\mathrm{\\AA}$。此量以电子为单位表示。\n\n- 定义全局中性检验为 $\\Delta \\rho(\\mathbf{r})$ 在整个域上的积分；其数值应接近于零电子。\n\n对称操作的角度单位必须以弧度指定。所有电荷转移量必须以电子为单位表示。\n\n测试套件。实现以下四个测试用例并计算指定的输出：\n\n- 测试用例 1 (空心位)：吸附物位于 $(0,0)$。对称操作：旋转 $\\theta = \\pi/2$ 弧度。输出一个布尔值，指示对称失配分数是否低于阈值。\n\n- 测试用例 2 (桥接位)：吸附物位于 $(+\\frac{a}{2},0)$。对称操作：沿 $x$ 轴反射。输出一个布尔值，指示对称失配分数是否低于阈值。\n\n- 测试用例 3 (顶位)：吸附物位于 $(+\\frac{a}{2},+\\frac{a}{2})$。输出到板区域的局域电荷转移（以电子为单位，浮点数）。\n\n- 测试用例 4 (对称性破缺的缺陷)：将原位于 $(+\\frac{a}{2},+\\frac{a}{2})$ 的板原子移动到 $(+\\frac{a}{2},+\\frac{a}{2}+\\delta)$，其中 $\\delta = 0.30\\,\\mathrm{\\AA}$。将吸附物置于 $(0,0)$。对称操作：旋转 $\\theta = \\pi/2$ 弧度。输出两个量：一个布尔值，指示对称失配分数是否低于阈值；一个浮点数，给出 $\\Delta \\rho(\\mathbf{r})$ 在整个域上的全局中性积分（以电子为单位）。\n\n最终输出格式。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为\n$[$result$_1$, result$_2$, result$_3$, result$_4$, result$_5]$，其中 result$_1$ 和 result$_2$ 是测试用例 1 和 2 的布尔值，result$_3$ 是测试用例 3 的浮点数，result$_4$ 是测试用例 4 对称性的布尔值，result$_5$ 是测试用例 4 全局中性的浮点数。角度单位必须是弧度，所有电荷转移值必须以电子为单位表示。",
            "solution": "经评估，该问题是有效的。其科学基础是计算化学原理，特别是密度泛函理论建模，并且在数学上是适定的，为确定性的计算解提供了所有必需的参数和定义。这些定义清晰、无歧义，测试用例的结构能够产生可验证的数值结果。\n\n### 基于原理的解决方案设计\n\n核心任务是为一个催化板和吸附物的模型系统，对其电子密度差场 $\\Delta \\rho(\\mathbf{r})$ 进行建模和分析。该场代表了由于板和吸附物之间的相互作用而引起的电子电荷的重新分布。\n\n#### 1. 计算域\n系统在一个二维方形网格上建模。网格包含 $N \\times N$ 个点，其中 $N=201$。网格间距是均匀的，$dx = 0.05\\,\\mathrm{\\AA}$。网格的总范围由 $L = \\frac{N-1}{2} dx = \\frac{200}{2} \\times 0.05 = 5.0\\,\\mathrm{\\AA}$ 决定。因此，网格坐标 $(x_j, y_k)$ 覆盖了 $[-5.0, 5.0] \\times [-5.0, 5.0]\\,\\mathrm{\\AA}^2$ 的域。该域足够大，可以包含所有原子中心和电子密度波瓣的重要部分。\n\n#### 2. 电子密度差场 $\\Delta \\rho(\\mathbf{r})$ 的构造\n问题为 $\\Delta \\rho(\\mathbf{r})$ 提供了一个构造性定义，即作为高斯电荷分布的叠加，这确保了该重分布场的总电荷是守恒的（即其在整个域上的积分为零）。\n\n对于一个通用的电荷分布（一个“波瓣”），其总电荷为 $Q$，中心在 $\\mathbf{R}$，宽度参数为 $\\sigma$，其对密度场的贡献由一个归一化的二维高斯函数给出：\n$$\n\\rho_{\\text{lobe}}(\\mathbf{r}) = \\frac{Q}{2\\pi \\sigma^2}\\,\\exp\\!\\left(-\\frac{\\lVert \\mathbf{r} - \\mathbf{R} \\rVert^2}{2\\sigma^2}\\right)\n$$\n电子密度差场 $\\Delta\\rho(\\mathbf{r})$ 是一个负波瓣和四个正波瓣贡献的总和：\n$$\n\\Delta \\rho(\\mathbf{r}) = \\rho_{\\text{pol}}^{-}(\\mathbf{r}) + \\sum_{i=1}^{4} \\rho_{\\text{pol}, i}^{+}(\\mathbf{r})\n$$\n- 一个单独的负波瓣以吸附物位置 $\\mathbf{R}_\\mathrm{ads}$ 为中心。它有 $-A$ 的总电荷，其中 $A=0.4$ 电子，宽度为 $\\sigma_\\mathrm{pol} = 0.30\\,\\mathrm{\\AA}$。\n  $$\n  \\rho_{\\text{pol}}^{-}(\\mathbf{r}) = \\frac{-A}{2\\pi \\sigma_\\mathrm{pol}^2}\\,\\exp\\!\\left(-\\frac{\\lVert \\mathbf{r} - \\mathbf{R}_\\mathrm{ads} \\rVert^2}{2\\sigma_\\mathrm{pol}^2}\\right)\n  $$\n- 四个正波瓣与位于 $\\mathbf{R}_i$ 的四个板原子相关联。第 $i$ 个正波瓣以中点 $\\mathbf{M}_i = \\frac{1}{2}(\\mathbf{R}_\\mathrm{ads} + \\mathbf{R}_i)$ 为中心。其宽度也是 $\\sigma_\\mathrm{pol}$。其电荷为 $A \\cdot w_i$，其中权重 $w_i$ 是基于吸附物与每个板原子之间的距离 $d_i = \\lVert \\mathbf{R}_\\mathrm{ads} - \\mathbf{R}_i \\rVert$ 计算的：\n  $$\n  w_i = \\frac{\\exp(-d_i / d_\\mathrm{scale})}{\\sum_{j=1}^{4} \\exp(-d_j / d_\\mathrm{scale})}\n  $$\n  其中 $d_\\mathrm{scale} = 2.0\\,\\mathrm{\\AA}$。权重是非负的，总和为 1，即 $\\sum_i w_i = 1$。因此，第 $i$ 个正波瓣的贡献是：\n  $$\n  \\rho_{\\text{pol}, i}^{+}(\\mathbf{r}) = \\frac{A\\,w_i}{2\\pi \\sigma_\\mathrm{pol}^2}\\,\\exp\\!\\left(-\\frac{\\lVert \\mathbf{r} - \\mathbf{M}_i \\rVert^2}{2\\sigma_\\mathrm{pol}^2}\\right)\n  $$\n所有正波瓣的总电荷为 $\\sum_i (A \\cdot w_i) = A \\sum_i w_i = A$。这恰好抵消了负波瓣的电荷 $-A$，确保了全局电荷中性，即 $\\int \\Delta\\rho(\\mathbf{r}) d^2\\mathbf{r} = 0$。\n\n#### 3. 可观测量（Observables）的数值计算\n所有量都在离散网格上进行数值计算。\n- **数值积分**：函数 $f(\\mathbf{r})$ 在区域 $\\Omega$ 上的积分通过黎曼和来近似：\n  $$\n  \\int_\\Omega f(\\mathbf{r}) d^2\\mathbf{r} \\approx \\sum_{(x_j, y_k) \\in \\Omega} f(x_j, y_k) (dx)^2\n  $$\n  其中 $(dx)^2$ 是面积元。\n\n- **全局中性检验**：这是 $\\Delta\\rho(\\mathbf{r})$ 在整个计算网格上的积分。由于 $\\Delta\\rho$ 的构造方式，这个值在数值上应该接近于零。\n\n- **局域电荷转移**：这是 $\\Delta\\rho(\\mathbf{r})$ 在四个圆形圆盘的并集上的积分，每个圆盘半径为 $r_s = 0.60\\,\\mathrm{\\AA}$，以板原子位置 $\\mathbf{R}_i$ 为中心。\n  $$\n  Q_{\\text{slab}} = \\int_{\\cup_{i} \\text{Disk}(\\mathbf{R}_i, r_s)} \\Delta\\rho(\\mathbf{r}) d^2\\mathbf{r}\n  $$\n\n- **对称性分析**：为评估 $\\Delta\\rho(\\mathbf{r})$ 在变换 $\\mathcal{T}$ 下的对称性，我们计算对称失配分数 $S$：\n  $$\n  S = \\frac{\\left\\| \\Delta \\rho - \\mathcal{T}\\left[\\Delta \\rho\\right] \\right\\|_2}{\\left\\| \\Delta \\rho \\right\\|_2}\n  $$\n  网格上场 $f$ 的离散 $L^2$ 范数计算为 $\\left\\| f \\right\\|_2 = \\sqrt{\\sum_{j,k} |f(x_j, y_k)|^2 (dx)^2}$。项 $(dx)^2$ 在 $S$ 的比率中被抵消，因此它简化为网格化场值的向量范数之比。\n  变换后的场 $\\mathcal{T}[\\Delta \\rho]$ 在每个网格点 $\\mathbf{r}$ 处进行评估，方法是找到原始场 $\\Delta\\rho$ 在原像点 $\\mathbf{r}' = \\mathcal{T}^{-1}(\\mathbf{r})$ 处的值，即 $\\mathcal{T}[\\Delta \\rho](\\mathbf{r}) = \\Delta\\rho(\\mathcal{T}^{-1}(\\mathbf{r}))$。由于 $\\mathbf{r}'$ 通常不落在网格点上，需要双线性插值或更复杂的方案。我们将使用实现了样条插值的 `scipy.ndimage.map_coordinates`。\n\n  - 对于角度为 $\\theta$ 的旋转，其逆变换 $\\mathcal{T}^{-1}$ 是旋转 $-\\theta$。坐标变换如下：\n    $$\n    \\begin{pmatrix} x' \\\\ y' \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix}\n    $$\n  - 对于沿 x 轴的反射，变换为 $(x,y) \\mapsto (x,-y)$。它是自身的逆，所以 $\\mathcal{T} = \\mathcal{T}^{-1}$：\n    $$\n    \\begin{pmatrix} x' \\\\ y' \\end{pmatrix} = \\begin{pmatrix} x \\\\ -y \\end{pmatrix}\n    $$\n  如果 $S$ 小于阈值 $\\varepsilon = 1.0 \\times 10^{-2}$，则认为该场是对称的。\n\n#### 4. 执行测试用例\n解决方案通过对四个指定的测试用例中的每一个实施上述原理来进行。\n- **用例 1 (空心位)**：吸附物位于 $\\mathbf{R}_{\\text{ads}} = (0,0)$。四个板原子位于 $(\\pm_1 a/2, \\pm_2 a/2)$，其中 $a/2 = 2.0\\,\\mathrm{\\AA}$。该设置在绕原点旋转 $\\theta = \\pi/2$ 下是对称的。所有距离 $d_i$ 都相等，所以权重 $w_i$ 均为 $1/4$。正波瓣中心集合 $\\{\\mathbf{M}_i\\}$ 在旋转下映射到自身。因此，$\\Delta\\rho$ 应该具有高度对称性，并且 $S$ 预计会非常小。\n- **用例 2 (桥接位)**：吸附物位于 $\\mathbf{R}_{\\text{ads}} = (a/2, 0) = (2.0, 0)$。系统相对于沿 x 轴的反射是几何对称的。这种对称性将传播到权重 $w_i$ 和波瓣中心 $\\mathbf{M}_i$，使得 $\\Delta\\rho$ 对称。$S$ 预计会很小。\n- **用例 3 (顶位)**：吸附物位于 $\\mathbf{R}_{\\text{ads}} = (a/2, a/2) = (2.0, 2.0)$，直接位于一个板原子的正上方。到板区域的局域电荷转移 $Q_{\\text{slab}}$ 是通过在指定的圆盘上对 $\\Delta\\rho$ 进行积分来计算的。\n- **用例 4 (缺陷)**：一个板原子从 $(2.0, 2.0)$ 被位移到 $(2.0, 2.3)$，破坏了四重旋转对称性。吸附物位于空心位 $(0,0)$。当测试旋转 $\\theta = \\pi/2$ 时，失配分数 $S$ 预计会很大，即 $S \\geq \\varepsilon$。全局中性积分也作为对模型公式及其数值实现的检验进行计算。\n\n最终程序将系统地将这些步骤应用于每个测试用例，并按规定格式化结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import map_coordinates\n\ndef solve():\n    \"\"\"\n    Solves the problem of analyzing a model electron density difference field\n    for various catalytic configurations.\n    \"\"\"\n\n    # --- Global Parameters ---\n    N = 201  # Grid points per axis\n    DX = 0.05  # Grid spacing in Angstrom\n    A_LATTICE = 4.0  # Lattice constant in Angstrom\n    A_AMP = 0.4  # Total positive lobe amplitude in electrons\n    SIGMA_POL = 0.30  # Polarization lobe width in Angstrom\n    D_SCALE = 2.0  # Weight decay length scale in Angstrom\n    R_S_INTEG = 0.60  # Integration radius for local charge in Angstrom\n    SYM_TOL = 1.0e-2  # Symmetry mismatch score tolerance\n\n    # --- Grid Setup ---\n    L = (N - 1) / 2 * DX\n    grid_coords_1d = np.linspace(-L, L, N)\n    XX, YY = np.meshgrid(grid_coords_1d, grid_coords_1d)\n\n    # --- Helper Functions ---\n    def gaussian_2d(centers, total_charge, sigma):\n        \"\"\"\n        Computes the sum of 2D Gaussian fields on the grid.\n        `centers` is a list of (x, y) tuples for center positions.\n        `total_charge` is a list of charges for each Gaussian.\n        \"\"\"\n        field = np.zeros((N, N))\n        norm_factor_base = 1.0 / (2 * np.pi * sigma**2)\n        for center, charge in zip(centers, total_charge):\n            r_sq = (XX - center[0])**2 + (YY - center[1])**2\n            field += (charge * norm_factor_base) * np.exp(-r_sq / (2 * sigma**2))\n        return field\n\n    def compute_delta_rho(slab_pos_list, ads_pos):\n        \"\"\"\n        Constructs the electron density difference field delta_rho.\n        \"\"\"\n        slab_pos = np.array(slab_pos_list)\n        ads_pos = np.array(ads_pos)\n\n        # Calculate distance-based weights\n        distances = np.linalg.norm(slab_pos - ads_pos, axis=1)\n        exp_d = np.exp(-distances / D_SCALE)\n        weights = exp_d / np.sum(exp_d)\n\n        # Define lobe centers and charges\n        pos_lobe_centers = 0.5 * (slab_pos + ads_pos)\n        pos_lobe_charges = A_AMP * weights\n        \n        neg_lobe_center = ads_pos\n        neg_lobe_charge = -A_AMP\n\n        # Sum up all lobes to get delta_rho\n        delta_rho_field = gaussian_2d(pos_lobe_centers.tolist(), pos_lobe_charges, SIGMA_POL)\n        delta_rho_field += gaussian_2d([neg_lobe_center.tolist()], [neg_lobe_charge], SIGMA_POL)\n\n        return delta_rho_field\n\n    def transform_field(field, rot_matrix=None, reflect_x=False):\n        \"\"\"\n        Applies a symmetry transformation to the field using interpolation.\n        `rot_matrix` is the INVERSE of the rotation matrix.\n        \"\"\"\n        # Physical coordinates of each grid point\n        initial_coords = np.vstack([XX.ravel(), YY.ravel()])\n        \n        # Apply inverse transformation to find where to sample from\n        if rot_matrix is not None:\n             transformed_coords_phys = rot_matrix @ initial_coords\n        elif reflect_x:\n            # Reflection is its own inverse\n            reflection_matrix = np.array([[1, 0], [0, -1]])\n            transformed_coords_phys = reflection_matrix @ initial_coords\n        else:\n            return field.copy()\n\n        # Convert physical coordinates to grid index coordinates for interpolation\n        # index = (physical_coord - min_coord) / dx\n        tx_phys, ty_phys = transformed_coords_phys[0], transformed_coords_phys[1]\n        \n        ix = (tx_phys + L) / DX\n        iy = (ty_phys + L) / DX\n\n        # map_coordinates expects coordinates in (row, col) i.e., (y, x) order\n        interp_coords = np.vstack([iy, ix])\n        \n        transformed_field_flat = map_coordinates(field, interp_coords, order=3, mode='constant', cval=0.0)\n        \n        return transformed_field_flat.reshape((N, N))\n\n    def compute_symmetry_score(field1, field2):\n        \"\"\"Calculates the L2 norm-based symmetry mismatch score.\"\"\"\n        norm_diff = np.linalg.norm(field1 - field2)\n        norm_orig = np.linalg.norm(field1)\n        return norm_diff / norm_orig if norm_orig  0 else 0.0\n\n    def compute_local_charge_transfer(field, slab_pos_list):\n        \"\"\"Integrates delta_rho over disks around slab atoms.\"\"\"\n        mask = np.zeros_like(field, dtype=bool)\n        for pos in slab_pos_list:\n            dist_sq = (XX - pos[0])**2 + (YY - pos[1])**2\n            mask |= (dist_sq = R_S_INTEG**2)\n        \n        charge = np.sum(field[mask]) * (DX**2)\n        return charge\n\n    def compute_global_neutrality(field):\n        \"\"\"Integrates delta_rho over the entire domain.\"\"\"\n        return np.sum(field) * (DX**2)\n\n    results = []\n    \n    # --- Base Slab Geometry ---\n    half_a = A_LATTICE / 2.0\n    base_slab_pos = [\n        (half_a, half_a), (half_a, -half_a),\n        (-half_a, half_a), (-half_a, -half_a)\n    ]\n\n    # --- Test Case 1: Hollow site ---\n    ads_pos_1 = (0.0, 0.0)\n    delta_rho_1 = compute_delta_rho(base_slab_pos, ads_pos_1)\n    theta_1 = np.pi / 2\n    # Inverse rotation matrix (rotation by -theta)\n    rot_mat_inv_1 = np.array([[np.cos(theta_1), np.sin(theta_1)],\n                              [-np.sin(theta_1), np.cos(theta_1)]])\n    transformed_rho_1 = transform_field(delta_rho_1, rot_matrix=rot_mat_inv_1)\n    score_1 = compute_symmetry_score(delta_rho_1, transformed_rho_1)\n    results.append(score_1  SYM_TOL)\n\n    # --- Test Case 2: Bridge site ---\n    ads_pos_2 = (half_a, 0.0)\n    delta_rho_2 = compute_delta_rho(base_slab_pos, ads_pos_2)\n    transformed_rho_2 = transform_field(delta_rho_2, reflect_x=True)\n    score_2 = compute_symmetry_score(delta_rho_2, transformed_rho_2)\n    results.append(score_2  SYM_TOL)\n    \n    # --- Test Case 3: Top site ---\n    ads_pos_3 = (half_a, half_a)\n    delta_rho_3 = compute_delta_rho(base_slab_pos, ads_pos_3)\n    local_charge_3 = compute_local_charge_transfer(delta_rho_3, base_slab_pos)\n    results.append(local_charge_3)\n\n    # --- Test Case 4: Defect ---\n    delta_defect = 0.30\n    defect_slab_pos = base_slab_pos.copy()\n    defect_slab_pos[0] = (half_a, half_a + delta_defect)\n    ads_pos_4 = (0.0, 0.0)\n    delta_rho_4 = compute_delta_rho(defect_slab_pos, ads_pos_4)\n    theta_4 = np.pi / 2\n    rot_mat_inv_4 = np.array([[np.cos(theta_4), np.sin(theta_4)],\n                              [-np.sin(theta_4), np.cos(theta_4)]])\n    transformed_rho_4 = transform_field(delta_rho_4, rot_matrix=rot_mat_inv_4)\n    score_4 = compute_symmetry_score(delta_rho_4, transformed_rho_4)\n    results.append(score_4  SYM_TOL)\n    \n    neutrality_4 = compute_global_neutrality(delta_rho_4)\n    results.append(neutrality_4)\n    \n    # --- Final Output ---\n    # Convert booleans to lowercase 'true'/'false' for consistency if needed, but problem doesn't specify\n    str_results = []\n    for r in results:\n        if isinstance(r, bool):\n            str_results.append(str(r))\n        else:\n            str_results.append(f\"{r:.8f}\")\n\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在将电荷重排可视化之后，我们接着要问：其量子起源是什么？本练习使用一个简化的轨道模型，将 $\\Delta \\rho$ 图与吸附物和表面轨道之间深层的相互作用联系起来。通过求解一个简单的哈密顿量，您将能够量化化学中直观的电子“给予”和“反馈”概念。",
            "id": "3878885",
            "problem": "在一个最小离散轨道框架中，对一个吸附了分子的催化剂表面进行建模，以利用电子密度差分图来量化电子给予-反馈。电子密度差分图是基于第一性原理，通过独立电子近似和Born–Oppenheimer分离来定义的，其中总电子密度由已占据的单电子态得到。吸附物提供一个最高已占分子轨道 (HOMO) 和一个最低未占分子轨道 (LUMO)，而表面提供一个单一的有效金属态（例如，一个代表性的金属 $d$-类轨道态）。离散轨道电子密度差分图表示为相对于非相互作用片段的轨道分辨布居数变化。从不含时薛定谔方程和一个最小紧束缚表示出发，实现一个程序，为几个指定的参数集计算作为轨道分辨电子布居数变化的电子给予量和反馈量（单位：电子）。\n\n基本依据与核心定义：\n- 单电子态的不含时薛定谔方程为 $H \\lvert \\psi \\rangle = E \\lvert \\psi \\rangle$，其中 $H$ 是哈密顿量，$E$ 是能量，$\\lvert \\psi \\rangle$ 是波函数。\n- 在独立电子近似中，总电子密度是所有已占据单电子态的总和，轨道分辨布居数通过将已占据态投影到标准正交轨道基上获得。\n- 在离散标准正交轨道基中，电子密度差分图定义为相互作用（吸附物-表面）体系与孤立片段总和之间的轨道布居数差异。将基表示为 $\\{ \\lvert \\mathrm{H} \\rangle, \\lvert \\mathrm{L} \\rangle, \\lvert \\mathrm{d} \\rangle \\}$，分别代表吸附物HOMO、吸附物LUMO和金属态。设 $n_{\\mathrm{H}}$、$n_{\\mathrm{L}}$ 和 $n_{\\mathrm{d}}$ 为相互作用体系的轨道布居数，$n_{\\mathrm{H}}^{(0)}$、$n_{\\mathrm{L}}^{(0)}$ 和 $n_{\\mathrm{d}}^{(0)}$ 为孤立片段的轨道布居数。离散电子密度差分图是向量 $\\Delta \\mathbf{n} = (n_{\\mathrm{H}} - n_{\\mathrm{H}}^{(0)}, n_{\\mathrm{L}} - n_{\\mathrm{L}}^{(0)}, n_{\\mathrm{d}} - n_{\\mathrm{d}}^{(0)})$。\n- 电子给予 (Donation) 定义为吸附物HOMO上布居数的减少，即 $D = \\max(0, -\\Delta n_{\\mathrm{H}})$，单位为电子。电子反馈 (Backdonation) 定义为吸附物LUMO上布居数的增加，即 $B = \\max(0, \\Delta n_{\\mathrm{L}})$，单位为电子。\n- 在标准正交基 $\\{ \\lvert \\mathrm{H} \\rangle, \\lvert \\mathrm{L} \\rangle, \\lvert \\mathrm{d} \\rangle \\}$ 中，相互作用体系的哈密顿量为\n$$\nH = \\begin{pmatrix}\nE_{\\mathrm{H}}  0  V_{\\mathrm{Hd}} \\\\\n0  E_{\\mathrm{L}}  V_{\\mathrm{Ld}} \\\\\nV_{\\mathrm{Hd}}  V_{\\mathrm{Ld}}  E_{\\mathrm{d}}\n\\end{pmatrix},\n$$\n其中 $E_{\\mathrm{H}}$、$E_{\\mathrm{L}}$ 和 $E_{\\mathrm{d}}$ 是轨道能量，$V_{\\mathrm{Hd}}$、$V_{\\mathrm{Ld}}$ 是吸附物轨道与金属态之间的耦合项。所有能量和耦合项的单位均为电子伏特 (eV)。\n- 在无自旋最小模型下，孤立吸附物中的HOMO是占据的，$n_{\\mathrm{H}}^{(0)} = 1$，LUMO是未占据的，$n_{\\mathrm{L}}^{(0)} = 0$，金属态是占据的，$n_{\\mathrm{d}}^{(0)} = 1$；相互作用体系中的总电子数守恒，为 $N_{\\mathrm{e}} = 2$。\n- 对相互作用的哈密顿量进行对角化，得到本征值 $E_{k}$ 和本征向量 $\\mathbf{c}^{(k)} = (c_{\\mathrm{H}}^{(k)}, c_{\\mathrm{L}}^{(k)}, c_{\\mathrm{d}}^{(k)})$。能量最低的 $N_{\\mathrm{e}}$ 个本征态被占据。轨道布居数计算如下：\n$$\nn_{\\mathrm{H}} = \\sum_{k \\in \\mathrm{occ}} \\left| c_{\\mathrm{H}}^{(k)} \\right|^{2}, \\quad\nn_{\\mathrm{L}} = \\sum_{k \\in \\mathrm{occ}} \\left| c_{\\mathrm{L}}^{(k)} \\right|^{2}, \\quad\nn_{\\mathrm{d}} = \\sum_{k \\in \\mathrm{occ}} \\left| c_{\\mathrm{d}}^{(k)} \\right|^{2}.\n$$\n\n您的任务：\n- 实现一个完整的程序，对于下面测试套件中的每个参数集，构建哈密顿量 $H$，将其对角化，填充能量最低的 $N_{\\mathrm{e}}$ 个本征态，计算轨道布居数和离散电子密度差分图 $\\Delta \\mathbf{n}$，最后报告电子给予量 $D$ 和电子反馈量 $B$（单位：电子），以十进制浮点数表示。\n\n物理和数值单位：\n- 能量 $E_{\\mathrm{H}}$、$E_{\\mathrm{L}}$、$E_{\\mathrm{d}}$、$V_{\\mathrm{Hd}}$ 和 $V_{\\mathrm{Ld}}$ 必须以电子伏特 (eV) 为单位处理。\n- 输出 $D$ 和 $B$ 必须以电子为单位表示，并为十进制浮点数。\n\n测试套件：\n- 情况1（一般相互作用，预期有非零的电子给予和反馈）：$E_{\\mathrm{H}} = -10.0\\,\\mathrm{eV}$，$E_{\\mathrm{L}} = +2.0\\,\\mathrm{eV}$，$E_{\\mathrm{d}} = -2.0\\,\\mathrm{eV}$，$V_{\\mathrm{Hd}} = 0.5\\,\\mathrm{eV}$，$V_{\\mathrm{Ld}} = 0.4\\,\\mathrm{eV}$，$N_{\\mathrm{e}} = 2$。\n- 情况2（边界情况，零耦合）：$E_{\\mathrm{H}} = -10.0\\,\\mathrm{eV}$，$E_{\\mathrm{L}} = +2.0\\,\\mathrm{eV}$，$E_{\\mathrm{d}} = -2.0\\,\\mathrm{eV}$，$V_{\\mathrm{Hd}} = 0.0\\,\\mathrm{eV}$，$V_{\\mathrm{Ld}} = 0.0\\,\\mathrm{eV}$，$N_{\\mathrm{e}} = 2$。\n- 情况3（边缘情况，强电子反馈，$E_{\\mathrm{L}}$ 接近 $E_{\\mathrm{d}}$）：$E_{\\mathrm{H}} = -12.0\\,\\mathrm{eV}$，$E_{\\mathrm{L}} = -1.8\\,\\mathrm{eV}$，$E_{\\mathrm{d}} = -2.0\\,\\mathrm{eV}$，$V_{\\mathrm{Hd}} = 0.1\\,\\mathrm{eV}$，$V_{\\mathrm{Ld}} = 1.0\\,\\mathrm{eV}$，$N_{\\mathrm{e}} = 2$。\n- 情况4（边缘情况，强电子给予，$E_{\\mathrm{H}}$ 接近 $E_{\\mathrm{d}}$）：$E_{\\mathrm{H}} = -2.1\\,\\mathrm{eV}$，$E_{\\mathrm{L}} = +5.0\\,\\mathrm{eV}$，$E_{\\mathrm{d}} = -2.0\\,\\mathrm{eV}$，$V_{\\mathrm{Hd}} = 1.0\\,\\mathrm{eV}$，$V_{\\mathrm{Ld}} = 0.1\\,\\mathrm{eV}$，$N_{\\mathrm{e}} = 2$。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含四个测试用例的电子给予-反馈结果，形式为以逗号分隔的列表的列表，每个内部列表为 $[D,B]$，并用方括号括起来，例如 $\\left[ [D_{1},B_{1}], [D_{2},B_{2}], [D_{3},B_{3}], [D_{4},B_{4}] \\right]$，其中每个 $D$ 和 $B$ 都打印为十进制浮点数。",
            "solution": "该问题提出了一个有效且适定 (well-posed) 的练习，旨在将量子力学的基本原理应用于吸附物-表面相互作用的简化模型，这是计算催化中的一个基石概念。该模型虽然极简，但自成体系，科学上基于紧束缚近似，并且没有矛盾或含糊之处。它提供了一个定量框架，用于计算电子给予和反馈，这是描述表面化学键合的两个关键描述符。我们将继续进行推导和算法实现。\n\n目标是在一个特定的3维标准正交基 $\\{ \\lvert \\mathrm{H} \\rangle, \\lvert \\mathrm{L} \\rangle, \\lvert \\mathrm{d} \\rangle \\}$ 内求解不含时薛定谔方程 $H \\lvert \\psi \\rangle = E \\lvert \\psi \\rangle$。在此基中，哈密顿量 $H$ 由以下实对称矩阵表示：\n$$\nH = \\begin{pmatrix}\nE_{\\mathrm{H}}  0  V_{\\mathrm{Hd}} \\\\\n0  E_{\\mathrm{L}}  V_{\\mathrm{Ld}} \\\\\nV_{\\mathrm{Hd}}  V_{\\mathrm{Ld}}  E_{\\mathrm{d}}\n\\end{pmatrix}\n$$\n在这里，$E_{\\mathrm{H}}$、$E_{\\mathrm{L}}$ 和 $E_{\\mathrm{d}}$ 分别是吸附物HOMO、LUMO和金属态的在位能，$V_{\\mathrm{Hd}}$ 和 $V_{\\mathrm{Ld}}$ 是它们之间的耦合项。所有参数均以电子伏特 ($\\mathrm{eV}$) 为单位给出。$H_{\\mathrm{HL}}$ 元素值为零的假设，即 $\\langle \\mathrm{H} \\lvert H \\rvert \\mathrm{L} \\rangle = 0$，是此类模型中常见的简化，反映了同一片段上轨道之间可忽略不计的直接耦合。\n\n以这种矩阵形式求解薛定谔方程等价于求解本征值问题 $H\\mathbf{c}^{(k)} = E_k \\mathbf{c}^{(k)}$，其中 $k \\in \\{1, 2, 3\\}$。这将产生三个实数本征值（能量）$E_k$ 和一组三个对应的标准正交本征向量 $\\mathbf{c}^{(k)}$。每个本征向量 $\\mathbf{c}^{(k)} = (c_{\\mathrm{H}}^{(k)}, c_{\\mathrm{L}}^{(k)}, c_{\\mathrm{d}}^{(k)})^T$ 将相互作用体系的第 $k$ 个本征态表示为原始基轨道的线性组合：$\\lvert \\psi_k \\rangle = c_{\\mathrm{H}}^{(k)}\\lvert \\mathrm{H} \\rangle + c_{\\mathrm{L}}^{(k)}\\lvert \\mathrm{L} \\rangle + c_{\\mathrm{d}}^{(k)}\\lvert \\mathrm{d} \\rangle$。\n\n体系中的总电子数指定为 $N_{\\mathrm{e}} = 2$。根据独立电子模型的构造原理 (Aufbau principle)，这些电子将占据能量最低的本征态。因此，我们必须按升序对本征值进行排序，$E_1 \\leq E_2 \\leq E_3$。两个占据态是 $\\lvert \\psi_1 \\rangle$ 和 $\\lvert \\psi_2 \\rangle$。\n\n给定轨道 $i \\in \\{\\mathrm{H, L, d}\\}$ 在相互作用体系中的布居数（表示为 $n_i$）是通过将其系数的平方模对所有已占据的本征态求和来计算的。由于基 $\\{ \\lvert i \\rangle \\}$ 是标准正交的，布居数由占据的多电子态在轨道子空间上的投影给出。在这个单电子图像中，它是：\n$$\nn_i = \\sum_{k \\in \\mathrm{occ}} |\\langle i \\lvert \\psi_k \\rangle|^2 = \\sum_{k=1}^{2} |c_i^{(k)}|^2\n$$\n具体而言，HOMO、LUMO和金属态的布居数是：\n$$\nn_{\\mathrm{H}} = |c_{\\mathrm{H}}^{(1)}|^2 + |c_{\\mathrm{H}}^{(2)}|^2 \\\\\nn_{\\mathrm{L}} = |c_{\\mathrm{L}}^{(1)}|^2 + |c_{\\mathrm{L}}^{(2)}|^2 \\\\\nn_{\\mathrm{d}} = |c_{\\mathrm{d}}^{(1)}|^2 + |c_{\\mathrm{d}}^{(2)}|^2\n$$\n由于本征向量是归一化的（$\\sum_i |c_i^{(k)}|^2 = 1$），总电子数是守恒的：$n_{\\mathrm{H}} + n_{\\mathrm{L}} + n_{\\mathrm{d}} = \\sum_{k=1}^{2} \\sum_{i} |c_i^{(k)}|^2 = \\sum_{k=1}^{2} 1 = 2 = N_{\\mathrm{e}}$。\n\n电子密度差是相对于非相互作用片段定义的，其布居数给定为 $n_{\\mathrm{H}}^{(0)} = 1$，$n_{\\mathrm{L}}^{(0)} = 0$ 和 $n_{\\mathrm{d}}^{(0)} = 1$。布居数的变化为 $\\Delta n_{\\mathrm{H}} = n_{\\mathrm{H}} - n_{\\mathrm{H}}^{(0)}$，$\\Delta n_{\\mathrm{L}} = n_{\\mathrm{L}} - n_{\\mathrm{L}}^{(0)}$ 和 $\\Delta n_{\\mathrm{d}} = n_{\\mathrm{d}} - n_{\\mathrm{d}}^{(0)}$。\n\n最后，电子给予 ($D$) 和电子反馈 ($B$) 被量化为：\n- 电子给予 ($D$)：从吸附物HOMO净损失的电子布居数。它是一个非负量。\n$$\nD = \\max(0, -\\Delta n_{\\mathrm{H}}) = \\max(0, n_{\\mathrm{H}}^{(0)} - n_{\\mathrm{H}}) = \\max(0, 1 - n_{\\mathrm{H}})\n$$\n- 电子反馈 ($B$)：进入吸附物LUMO的净增加的电子布居数。它也是一个非负量。\n$$\nB = \\max(0, \\Delta n_{\\mathrm{L}}) = \\max(0, n_{\\mathrm{L}} - n_{\\mathrm{L}}^{(0)}) = \\max(0, n_{\\mathrm{L}})\n$$\n$D$ 和 $B$ 都以电子为单位表示。\n\n算法流程如下：\n1. 对于每个参数集 $(E_{\\mathrm{H}}, E_{\\mathrm{L}}, E_{\\mathrm{d}}, V_{\\mathrm{Hd}}, V_{\\mathrm{Ld}})$，构建 $3 \\times 3$ 的哈密顿矩阵 $H$。\n2. 对 $H$进行数值对角化，以获得其本征值和本征向量。标准的线性代数库为此提供了稳健的例程，特别是对于实对称矩阵，它们会产生按升序排序的本征值。\n3. 识别与两个最低本征值对应的两个本征向量。\n4. 通过对这两个本征向量的平方分量求和，计算轨道布居数 $n_{\\mathrm{H}}$ 和 $n_{\\mathrm{L}}$。\n5. 使用它们的定义计算电子给予量 $D$ 和电子反馈量 $B$。\n6. 将所有测试用例的结果整理成指定的输出格式。\n现在将实施此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes donation and backdonation for an adsorbate-surface system\n    modeled by a 3x3 tight-binding Hamiltonian.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary of parameters in units of eV.\n    test_cases = [\n        {\n            'E_H': -10.0, 'E_L': +2.0, 'E_d': -2.0,\n            'V_Hd': 0.5, 'V_Ld': 0.4, 'N_e': 2\n        },\n        {\n            'E_H': -10.0, 'E_L': +2.0, 'E_d': -2.0,\n            'V_Hd': 0.0, 'V_Ld': 0.0, 'N_e': 2\n        },\n        {\n            'E_H': -12.0, 'E_L': -1.8, 'E_d': -2.0,\n            'V_Hd': 0.1, 'V_Ld': 1.0, 'N_e': 2\n        },\n        {\n            'E_H': -2.1, 'E_L': +5.0, 'E_d': -2.0,\n            'V_Hd': 1.0, 'V_Ld': 0.1, 'N_e': 2\n        },\n    ]\n\n    # Initial populations of the non-interacting fragments.\n    # n_H^(0) = 1, n_L^(0) = 0, n_d^(0) = 1\n    n_H_0 = 1.0\n    n_L_0 = 0.0\n\n    results = []\n    for params in test_cases:\n        # Step 1: Construct the Hamiltonian matrix H.\n        # The basis is {HOMO, LUMO, d-state}.\n        hamiltonian = np.array([\n            [params['E_H'], 0.0,           params['V_Hd']],\n            [0.0,           params['E_L'], params['V_Ld']],\n            [params['V_Hd'], params['V_Ld'], params['E_d']]\n        ])\n\n        # Step 2: Solve the eigenvalue problem H*c = E*c.\n        # np.linalg.eigh is used for Hermitian (real symmetric) matrices.\n        # It returns eigenvalues sorted in ascending order and corresponding\n        # eigenvectors as columns of a matrix.\n        eigenvalues, eigenvectors = np.linalg.eigh(hamiltonian)\n\n        # Step 3: Identify occupied states.\n        # The N_e lowest energy states are occupied. N_e = 2.\n        # These correspond to the first two columns of the eigenvector matrix.\n        occupied_eigenvectors = eigenvectors[:, :params['N_e']]\n\n        # Step 4: Calculate interacting orbital populations n_i.\n        # n_i = sum_k |c_i^(k)|^2 over occupied states k.\n        # Here, c_i^(k) is eigenvectors[i, k].\n        # Sum of squares of the first row components for the two occupied states.\n        n_H = np.sum(np.square(occupied_eigenvectors[0, :]))\n        # Sum of squares of the second row components for the two occupied states.\n        n_L = np.sum(np.square(occupied_eigenvectors[1, :]))\n        \n        # Step 5: Calculate Donation (D) and Backdonation (B).\n        # D = max(0, n_H^(0) - n_H)\n        donation = max(0.0, n_H_0 - n_H)\n        # B = max(0, n_L - n_L^(0))\n        backdonation = max(0.0, n_L - n_L_0)\n\n        results.append([donation, backdonation])\n\n    # Final print statement in the exact required format.\n    # Format: [[D1,B1],[D2,B2],[D3,B3],[D4,B4]] with no extra spaces.\n    inner_strings = [f\"[{d},{b}]\" for d, b in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "由 $\\Delta \\rho$ 描述的电荷重新分布会产生一个可触摸的物理变化：系统静电势的改变。最后一个练习将通过展示如何利用泊松方程和谱方法，从电荷密度差计算出这一静电势，从而完成我们的学习之旅。您将学习一种在大型周期性模拟中使用的强大技术，将电荷重排与可观测的静电场联系起来。",
            "id": "3878880",
            "problem": "考虑在计算催化中对周期性立方晶胞内的电子密度差进行作图，其中吸附质引起催化表面电子密度的重新分布。电子密度差记为 $\\Delta \\rho(\\mathbf{r})$，根据叠加原理其形式上定义为 $\\Delta \\rho(\\mathbf{r}) = \\rho_{\\text{combined}}(\\mathbf{r}) - \\rho_{\\text{adsorbate}}(\\mathbf{r}) - \\rho_{\\text{surface}}(\\mathbf{r})$。由 $\\Delta \\rho(\\mathbf{r})$ 在真空中产生的静电势 $\\phi(\\mathbf{r})$ 受经典电磁学基本定律的支配：静电学高斯定律（结合静电场定义为标量势的梯度）可推导出泊松方程 $\\nabla^2 \\phi(\\mathbf{r}) = -\\Delta \\rho(\\mathbf{r})/\\varepsilon_0$，其中 $\\varepsilon_0$ 是真空介电常数。在一个边长为 $L$ 且具有周期性边界条件的周期性立方晶胞中，$\\Delta \\rho(\\mathbf{r})$ 和 $\\phi(\\mathbf{r})$ 均可进行傅里叶级数表示。本问题要求您针对模拟催化表面典型吸附电荷重新分布的指定测试电子密度差，推导、实现并评估此泊松问题的谱方法（傅里叶域）解。\n\n从电磁学的基本定律（高斯定律和静电场的定义）以及周期域上傅里叶级数的核心定义出发，推导在周期性立方晶胞中从 $\\Delta \\rho(\\mathbf{r})$ 获得 $\\phi(\\mathbf{r})$ 的计算方法。您必须考虑一个符合物理现实的要求，即 $k=\\mathbf{0}$ 的傅里叶分量（$\\Delta \\rho(\\mathbf{r})$ 的空间平均值）不能产生有限的周期性势。在周期性边界条件的计算实践中，这要求在求解泊松方程之前，通过减去 $\\Delta \\rho(\\mathbf{r})$ 的平均值来强制实现全局电中性，这将参考势的平均值设为零。\n\n以自包含的方式实现以下编程任务：\n\n1. 在一个跨越边长为 $L$ 的立方域的 $N \\times N \\times N$ 均匀三维网格上，通过叠加两个积分电荷大小相等、符号相反的归一化三维高斯瓣来构建 $\\Delta \\rho(\\mathbf{r})$。设正电荷瓣中心位于 $\\mathbf{r}_+$，电荷为 $q_+$；负电荷瓣中心位于 $\\mathbf{r}_-$，电荷为 $q_-$，且 $q_+ + q_- \\approx 0$。每个瓣都由一个归一化高斯函数建模：\n$$\nG(\\mathbf{r};\\mathbf{r}_0,\\sigma) = \\frac{1}{(2\\pi)^{3/2}\\sigma^3} \\exp\\left(-\\frac{\\|\\mathbf{r} - \\mathbf{r}_0\\|^2}{2\\sigma^2}\\right),\n$$\n因此密度为：\n$$\n\\Delta \\rho(\\mathbf{r}) = q_+ \\, G(\\mathbf{r};\\mathbf{r}_+,\\sigma) + q_- \\, G(\\mathbf{r};\\mathbf{r}_-,\\sigma).\n$$\n在立方周期性边界条件下，使用最小镜像约定计算距离，以施加周期性。\n\n2. 在计算电势之前，通过减去晶胞上 $\\Delta \\rho(\\mathbf{r})$ 的空间平均值，为周期性泊松求解强制实现电中性。\n\n3. 通过将 $\\Delta \\rho(\\mathbf{r})$ 变换到倒易空间，作用以拉普拉斯逆算子（在傅里叶空间中是对角的），然后变换回实空间，从而在网格上获得 $\\phi(\\mathbf{r})$，以此来用谱方法求解泊松方程。适当地处理 $\\mathbf{k}=\\mathbf{0}$ 模式以避免除以零。\n\n4. 对于每个测试用例，在三个物理上相关的点上评估 $\\phi(\\mathbf{r})$：正、负高斯瓣的中心（$\\mathbf{r}_+$ 和 $\\mathbf{r}_-$）以及中点 $\\mathbf{r}_{\\text{mid}} = (\\mathbf{r}_+ + \\mathbf{r}_-)/2$。使用最近邻网格点采样来近似这些位置的 $\\phi(\\mathbf{r})$。将电势值以伏特表示，并将结果报告为浮点数。\n\n使用真空介电常数 $\\varepsilon_0 = 8.854187817 \\times 10^{-12}$ 法拉/米。所有位置必须在尺寸为 $L$ 的周期性盒子内。所有物理量必须使用国际单位制（SI单位）：长度单位为米，电荷单位为库仑，密度单位为库仑/立方米，电势单位为伏特。不涉及角度。\n\n测试套件和要求输出：\n对于以下每个参数集，计算并返回点 $\\mathbf{r}_+$、$\\mathbf{r}_-$ 和 $\\mathbf{r}_{\\text{mid}}$ 处的三个电势值（以伏特为单位）。\n\n- 情况1（电中性重分布，中等分离）：\n  - $L = 1.0 \\times 10^{-9}$ 米，\n  - $N = 64$，\n  - $q_+ = 1.0 \\times 10^{-19}$ 库仑，\n  - $q_- = -1.0 \\times 10^{-19}$ 库仑，\n  - $\\sigma = 8.0 \\times 10^{-11}$ 米，\n  - $\\mathbf{r}_+ = (0.25L, 0.50L, 0.50L)$，\n  - $\\mathbf{r}_- = (0.75L, 0.50L, 0.50L)$。\n\n- 情况2（近电中性重分布，需要减去平均值）：\n  - $L = 1.2 \\times 10^{-9}$ 米，\n  - $N = 64$，\n  - $q_+ = 1.0 \\times 10^{-19}$ 库仑，\n  - $q_- = -0.99 \\times 10^{-19}$ 库仑，\n  - $\\sigma = 6.0 \\times 10^{-11}$ 米，\n  - $\\mathbf{r}_+ = (0.40L, 0.40L, 0.40L)$，\n  - $\\mathbf{r}_- = (0.60L, 0.60L, 0.60L)$。\n\n- 情况3（电中性重分布，靠近边界的窄瓣以测试周期性）：\n  - $L = 8.0 \\times 10^{-10}$ 米，\n  - $N = 64$，\n  - $q_+ = 0.5 \\times 10^{-19}$ 库仑，\n  - $q_- = -0.5 \\times 10^{-19}$ 库仑，\n  - $\\sigma = 2.0 \\times 10^{-11}$ 米，\n  - $\\mathbf{r}_+ = (0.10L, 0.10L, 0.70L)$，\n  - $\\mathbf{r}_- = (0.90L, 0.90L, 0.30L)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。结果按情况1的 $[\\phi(\\mathbf{r}_+), \\phi(\\mathbf{r}_-), \\phi(\\mathbf{r}_{\\text{mid}})]$，随后是情况2和情况3的相同三元组的顺序排列。所有值必须以伏特表示，输出中不含单位符号，并表示为浮点数。例如，输出格式为 $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\ldots]$。",
            "solution": "该问题要求在边长为 $L$ 的周期性立方晶胞内，计算由给定电子密度差 $\\Delta\\rho(\\mathbf{r})$ 产生的静电势 $\\phi(\\mathbf{r})$。这是计算物理和计算化学中的一个典型问题，可通过泊松方程求解。\n\n静电势 $\\phi(\\mathbf{r})$ 与电荷密度 $\\Delta\\rho(\\mathbf{r})$ 之间的基本关系由泊松方程给出，该方程源于静电学高斯定律（$\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$）和静电场是电势负梯度（$\\mathbf{E} = -\\nabla \\phi$）的定义。将两者结合可得：\n$$\n\\nabla^2 \\phi(\\mathbf{r}) = -\\frac{\\Delta\\rho(\\mathbf{r})}{\\varepsilon_0}\n$$\n其中 $\\nabla^2$ 是拉普拉斯算子，$\\varepsilon_0$ 是真空介电常数，其值为 $8.854187817 \\times 10^{-12} \\, \\text{F/m}$。\n\n该问题设定在周期性域中，这使其非常适合在傅里叶空间中求解。一个在体积为 $V = L^3$ 的立方盒子中具有周期性的函数 $f(\\mathbf{r})$ 可以用傅里叶级数表示：\n$$\nf(\\mathbf{r}) = \\sum_{\\mathbf{k}} \\hat{f}(\\mathbf{k}) e^{i \\mathbf{k} \\cdot \\mathbf{r}}\n$$\n求和遍及离散的倒格矢集合 $\\mathbf{k} = \\frac{2\\pi}{L}(n_x, n_y, n_z)$，其中 $n_x, n_y, n_z$ 为整数。傅里叶系数 $\\hat{f}(\\mathbf{k})$ 由逆关系给出：\n$$\n\\hat{f}(\\mathbf{k}) = \\frac{1}{V} \\int_V f(\\mathbf{r}) e^{-i \\mathbf{k} \\cdot \\mathbf{r}} d^3\\mathbf{r}\n$$\n对拉普拉斯算子应用傅里叶变换会得到一个简单的乘法因子：$\\mathcal{F}\\{\\nabla^2 f(\\mathbf{r})\\} = -\\|\\mathbf{k}\\|^2 \\hat{f}(\\mathbf{k})$，其中 $\\|\\mathbf{k}\\|^2 = k_x^2 + k_y^2 + k_z^2$。\n\n将整个泊松方程变换到傅里叶域可得：\n$$\n-\\|\\mathbf{k}\\|^2 \\hat{\\phi}(\\mathbf{k}) = -\\frac{\\hat{\\Delta\\rho}(\\mathbf{k})}{\\varepsilon_0}\n$$\n解出电势的傅里叶系数 $\\hat{\\phi}(\\mathbf{k})$ 可得：\n$$\n\\hat{\\phi}(\\mathbf{k}) = \\frac{\\hat{\\Delta\\rho}(\\mathbf{k})}{\\varepsilon_0 \\|\\mathbf{k}\\|^2}\n$$\n此表达式对所有 $\\mathbf{k} \\neq \\mathbf{0}$ 均有效。$\\mathbf{k} = \\mathbf{0}$ 的情况需要特别注意。当 $\\mathbf{k} = \\mathbf{0}$ 时，分母 $\\|\\mathbf{k}\\|^2$ 为零。只有当分子也为零时，才可能存在具有物理意义的有界势。密度的 $\\mathbf{k}=\\mathbf{0}$ 分量 $\\hat{\\Delta\\rho}(\\mathbf{k}=\\mathbf{0})$ 是密度在晶胞内的空间平均值：\n$$\n\\hat{\\Delta\\rho}(\\mathbf{k}=\\mathbf{0}) = \\frac{1}{V} \\int_V \\Delta\\rho(\\mathbf{r}) d^3\\mathbf{r} = \\frac{Q_{\\text{total}}}{V}\n$$\n这意味着周期性晶胞中的总电荷 $Q_{\\text{total}}$ 必须为零。问题明确指出了可能不满足此条件的情况（情况2），并强制要求通过减去平均密度来实现电中性。此过程等效于添加一个均匀的补偿背景电荷。我们定义一个中性化密度 $\\Delta\\rho'(\\mathbf{r}) = \\Delta\\rho(\\mathbf{r}) - \\langle\\Delta\\rho\\rangle$，其中 $\\langle\\Delta\\rho\\rangle = Q_{\\text{total}}/V$。根据构造，$\\hat{\\Delta\\rho'}(\\mathbf{k}=\\mathbf{0}) = 0$。\n\n对于 $\\mathbf{k}=\\mathbf{0}$，$\\hat{\\phi}(\\mathbf{k}=\\mathbf{0})$ 的值代表晶胞内的平均电势。由于绝对电势的定义只取决于一个任意常数，我们可以自由设定这个平均值。标准且最方便的选择是将平均电势设为零，即 $\\hat{\\phi}(\\mathbf{k}=\\mathbf{0}) = 0$。\n\n计算算法如下：\n1.  **离散化域**：用一个 $N \\times N \\times N$ 的均匀点网格表示边长为 $L$ 的立方晶胞。网格间距为 $h = L/N$。\n2.  **构建电荷密度**：在此网格上构建密度差 $\\Delta\\rho(\\mathbf{r})$。它是两个高斯分布 $q_+ G(\\mathbf{r};\\mathbf{r}_+,\\sigma)$ 和 $q_- G(\\mathbf{r};\\mathbf{r}_-,\\sigma)$ 的和。为了遵循周期性边界条件，高斯指数中的距离 $\\|\\mathbf{r} - \\mathbf{r}_0\\|$ 采用最小镜像约定计算。对于给定分量（例如 $x$），距离为 $\\Delta x' = \\Delta x - L \\cdot \\text{round}(\\Delta x / L)$。\n3.  **强制电荷中性**：计算离散化密度的平均值 $\\langle\\Delta\\rho\\rangle = \\frac{1}{N^3} \\sum_{i,j,k} \\Delta\\rho(\\mathbf{r}_{ijk})$，并从每个网格点中减去它：$\\Delta\\rho'_{ijk} = \\Delta\\rho_{ijk} - \\langle\\Delta\\rho\\rangle$。\n4.  **正向傅里叶变换**：使用快速傅里叶变换（FFT）算法计算中性化密度网格 $\\Delta\\rho'$ 的离散傅里叶变换，以获得 $\\hat{\\Delta\\rho'}(\\mathbf{k})$。\n5.  **在倒易空间中求解**：\n    a. 构建倒易空间矢量 $\\mathbf{k}$ 的网格。对于大小为 $N$、长度为 $L$ 的网格，其分量由 $k_x = 2\\pi \\nu_x$ 给出，其中 $\\nu_x$ 是标准FFT频率函数（例如 `numpy.fft.fftfreq`）返回的频率。\n    b. 计算倒易网格中每个点的模的平方 $\\|\\mathbf{k}\\|^2$。\n    c. 计算电势的傅里叶系数：对于所有 $\\mathbf{k} \\neq \\mathbf{0}$，$\\hat{\\phi}(\\mathbf{k}) = \\hat{\\Delta\\rho'}(\\mathbf{k}) / (\\varepsilon_0 \\|\\mathbf{k}\\|^2)$。\n    d. 将直流分量（k=0分量）设为零：$\\hat{\\phi}(\\mathbf{k}=\\mathbf{0}) = 0$。这通过在除法后将数组的 $[0,0,0]$ 元素设为 $0$ 来完成。\n6.  **逆傅里叶变换**：计算 $\\hat{\\phi}(\\mathbf{k})$ 网格的逆FFT，以获得网格上的实空间势 $\\phi(\\mathbf{r})$。数值IFFT的结果可能包含微小的伪虚部，因此我们取最终结果的实部。\n7.  **采样电势**：通过找到每个目标位置最近的网格点并检索相应的电势值，来评估指定点 $\\mathbf{r}_+$, $\\mathbf{r}_-$ 和 $\\mathbf{r}_{\\text{mid}}$ 处的电势。坐标 $x$ 的索引通过 $i_x = \\text{round}(x \\cdot N/L) \\pmod N$ 找到。\n\n这种谱方法利用了FFT算法的 $O(N^3 \\log N)$ 复杂度，计算效率高，是解决周期性模拟中泊松方程的标准方法。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Poisson equation for electron density difference in a periodic\n    cubic cell using a spectral (Fourier) method.\n    \"\"\"\n    \n    # Constants\n    epsilon_0 = 8.854187817e-12  # Vacuum permittivity in F/m\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        {\n            \"L\": 1.0e-9, \"N\": 64, \"q_plus\": 1.0e-19, \"q_minus\": -1.0e-19,\n            \"sigma\": 8.0e-11, \"r_plus\": np.array([0.25, 0.50, 0.50]),\n            \"r_minus\": np.array([0.75, 0.50, 0.50])\n        },\n        {\n            \"L\": 1.2e-9, \"N\": 64, \"q_plus\": 1.0e-19, \"q_minus\": -0.99e-19,\n            \"sigma\": 6.0e-11, \"r_plus\": np.array([0.40, 0.40, 0.40]),\n            \"r_minus\": np.array([0.60, 0.60, 0.60])\n        },\n        {\n            \"L\": 8.0e-10, \"N\": 64, \"q_plus\": 0.5e-19, \"q_minus\": -0.5e-19,\n            \"sigma\": 2.0e-11, \"r_plus\": np.array([0.10, 0.10, 0.70]),\n            \"r_minus\": np.array([0.90, 0.90, 0.30])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        N = case[\"N\"]\n        q_plus = case[\"q_plus\"]\n        q_minus = case[\"q_minus\"]\n        sigma = case[\"sigma\"]\n        # Convert fractional coordinates to absolute coordinates\n        r_plus_abs = case[\"r_plus\"] * L\n        r_minus_abs = case[\"r_minus\"] * L\n        r_mid_abs = (r_plus_abs + r_minus_abs) / 2.0\n\n        # 1. Construct the grid and charge density\n        grid_coords = np.linspace(0, L, N, endpoint=False)\n        xx, yy, zz = np.meshgrid(grid_coords, grid_coords, grid_coords, indexing='ij')\n\n        def build_gaussian(q, r0, sigma_val):\n            # Calculate distance components with minimum image convention\n            dx = xx - r0[0]\n            dy = yy - r0[1]\n            dz = zz - r0[2]\n            \n            dx -= L * np.round(dx / L)\n            dy -= L * np.round(dy / L)\n            dz -= L * np.round(dz / L)\n            \n            dist_sq = dx**2 + dy**2 + dz**2\n            \n            norm_factor = 1.0 / ((2 * np.pi)**1.5 * sigma_val**3)\n            gaussian = norm_factor * np.exp(-dist_sq / (2 * sigma_val**2))\n            return q * gaussian\n\n        delta_rho = build_gaussian(q_plus, r_plus_abs, sigma) + \\\n                    build_gaussian(q_minus, r_minus_abs, sigma)\n\n        # 2. Enforce global charge neutrality\n        mean_rho = np.mean(delta_rho)\n        delta_rho_neutral = delta_rho - mean_rho\n\n        # 3. Solve Poisson equation in Fourier space\n        \n        # Forward FFT\n        rho_hat = np.fft.fftn(delta_rho_neutral)\n        \n        # Construct k-vectors\n        k_freq = np.fft.fftfreq(N, d=L/N)\n        kx = 2 * np.pi * k_freq\n        ky = 2 * np.pi * k_freq\n        kz = 2 * np.pi * k_freq\n        kxx, kyy, kzz = np.meshgrid(kx, ky, kz, indexing='ij')\n        \n        # Squared k-magnitude\n        k_sq = kxx**2 + kyy**2 + kzz**2\n\n        # Avoid division by zero at k=0\n        # The numerator rho_hat[0,0,0] is already zero due to mean subtraction\n        # but we must prevent the division to avoid NaN.\n        k_sq[0, 0, 0] = 1.0\n        \n        # Calculate potential in Fourier space\n        phi_hat = rho_hat / (epsilon_0 * k_sq)\n        \n        # Explicitly set the k=0 component to zero to enforce zero average potential\n        phi_hat[0, 0, 0] = 0.0\n        \n        # Inverse FFT to get potential in real space\n        phi_r = np.real(np.fft.ifftn(phi_hat))\n\n        # 4. Evaluate potential at specified points using nearest-grid-point sampling\n        def get_potential_at(pos_abs):\n            indices = (np.round((pos_abs / L) * N) % N).astype(int)\n            return phi_r[indices[0], indices[1], indices[2]]\n\n        phi_r_plus = get_potential_at(r_plus_abs)\n        phi_r_minus = get_potential_at(r_minus_abs)\n        phi_r_mid = get_potential_at(r_mid_abs)\n        \n        results.extend([phi_r_plus, phi_r_minus, phi_r_mid])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}