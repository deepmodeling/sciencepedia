{
    "hands_on_practices": [
        {
            "introduction": "To truly understand electron density difference maps, it's invaluable to build one from the ground up. This first exercise guides you through constructing a $\\Delta \\rho(\\mathbf{r})$ map for a model adsorbate-surface system using a superposition of Gaussian functions . By working through scenarios for different high-symmetry adsorption sites, you will develop a strong intuition for the visual representation of charge redistribution and practice quantifying its key features, such as symmetry and local charge transfer.",
            "id": "3878898",
            "problem": "A planar model system representing a square-lattice catalytic slab interacting with a single adsorbate is considered within the Born–Oppenheimer approximation, where the nuclei are fixed and electrons are described by their ground-state density field. The electron density field is defined as a nonnegative scalar field $\\rho(\\mathbf{r})$ on a two-dimensional spatial domain, interpreted as the number of electrons per unit area at position $\\mathbf{r}$. The mapping of electron density differences is obtained by solving for a redistribution field that, added to the superposition of isolated component densities, reproduces the combined system density while conserving total charge. Symmetry operations are represented as orthogonal linear transformations on the plane, such as rotations and reflections, applied to the electron density difference field.\n\nYou must implement a complete program that uses the following scientifically grounded model and definitions, and produces numerically testable outputs:\n\n- Construct a two-dimensional square computational grid covering a domain large enough to include all atoms and lobes, with $N$ points per axis and uniform spacing $dx$ in ångström (Å). Use $N = 201$ and $dx = 0.05\\,\\mathrm{\\AA}$.\n\n- Place four slab atoms forming a square lattice of lattice constant $a$, with positions $(x,y)$ given by the four corners $(+\\frac{a}{2},+\\frac{a}{2})$, $(+\\frac{a}{2},-\\frac{a}{2})$, $(-\\frac{a}{2},+\\frac{a}{2})$, and $(-\\frac{a}{2},-\\frac{a}{2})$. Use $a = 4.0\\,\\mathrm{\\AA}$.\n\n- An adsorbate atom is placed at a specified adsorption site $(x_\\mathrm{ads},y_\\mathrm{ads})$ on the same plane.\n\n- The isolated electron density contributions for the slab and adsorbate are modeled by normalized two-dimensional Gaussian fields. For an atom at position $\\mathbf{R}_i$ with a valence electron count $Q_i$ and Gaussian width parameter $\\sigma_i$, the isolated density contribution is defined as\n$$\n\\rho_i(\\mathbf{r}) \\;=\\; \\frac{Q_i}{2\\pi \\sigma_i^2}\\,\\exp\\!\\left(-\\frac{\\lVert \\mathbf{r} - \\mathbf{R}_i \\rVert^2}{2\\sigma_i^2}\\right),\n$$\nwhich integrates to $Q_i$ electrons over the plane. Use $Q_\\mathrm{slab} = 1.0$ electron per slab atom with $\\sigma_\\mathrm{slab} = 0.35\\,\\mathrm{\\AA}$, and $Q_\\mathrm{ads} = 1.0$ electron for the adsorbate with $\\sigma_\\mathrm{ads} = 0.25\\,\\mathrm{\\AA}$.\n\n- The combined system density is modeled as the superposition of isolated slab and adsorbate densities plus a polarization redistribution field that integrates to zero electrons. The redistribution field is constructed from Gaussian lobes as follows: for each slab atom $i$, define a positive lobe centered at the midpoint $\\mathbf{M}_i = \\frac{1}{2}(\\mathbf{R}_\\mathrm{ads} + \\mathbf{R}_i)$ with width $\\sigma_\\mathrm{pol}$ and amplitude $A\\,w_i$ electrons, where $A$ is the total positive lobe amplitude and $w_i$ are nonnegative weights that sum to $1$ and depend only on the adsorbate–slab distances. Define a single negative lobe centered at $\\mathbf{R}_\\mathrm{ads}$ with width $\\sigma_\\mathrm{pol}$ and amplitude $-A$ electrons. This guarantees global electron conservation. Use $A = 0.4$ electrons, $\\sigma_\\mathrm{pol} = 0.30\\,\\mathrm{\\AA}$, and distance-based weights\n$$\nw_i \\;=\\; \\frac{\\exp(-d_i / d_\\mathrm{scale})}{\\sum_j \\exp(-d_j / d_\\mathrm{scale})}, \\qquad d_i \\;=\\; \\lVert \\mathbf{R}_\\mathrm{ads} - \\mathbf{R}_i \\rVert,\n$$\nwith $d_\\mathrm{scale} = 2.0\\,\\mathrm{\\AA}$.\n\n- The electron density difference field $\\Delta \\rho(\\mathbf{r})$ is the unique redistribution field that, when added to the sum of isolated densities, reproduces the combined system density and integrates to zero electrons over the entire domain.\n\n- Implement symmetry operations on $\\Delta \\rho(\\mathbf{r})$:\n    1. Rotation by angle $\\theta$ in radians about the origin defined by the transformation $\\mathbf{r}\\mapsto \\mathbf{R}(\\theta)\\mathbf{r}$, where $\\mathbf{R}(\\theta)$ is the standard $2\\times 2$ rotation matrix.\n    2. Reflection across the $x$-axis defined by $\\mathbf{r}\\mapsto (x,-y)$.\n\n- Define the symmetry mismatch score as the ratio of the $L^2$ norm of the difference between the field and its transformed version to the $L^2$ norm of the original field,\n$$\nS \\;=\\; \\frac{\\left\\| \\Delta \\rho - \\mathcal{T}\\left[\\Delta \\rho\\right] \\right\\|_2}{\\left\\| \\Delta \\rho \\right\\|_2},\n$$\nwhere the $L^2$ norm is computed on the discrete grid with area weighting, and $\\mathcal{T}$ denotes a symmetry transformation. Treat the field as symmetric under $\\mathcal{T}$ if $S  \\varepsilon$, with $\\varepsilon = 1.0\\times 10^{-2}$.\n\n- Define the local charge transfer to the slab region as the integral of $\\Delta \\rho(\\mathbf{r})$ over the union of discs of radius $r_s$ centered at each slab atom position. Use $r_s = 0.60\\,\\mathrm{\\AA}$. Express this quantity in electrons.\n\n- Define the global neutrality check as the integral of $\\Delta \\rho(\\mathbf{r})$ over the entire domain; it should be numerically close to zero electrons.\n\nAngle units must be specified in radians for symmetry operations. All charge-transfer quantities must be expressed in electrons.\n\nTest Suite. Implement the following four test cases and compute the specified outputs:\n\n- Test Case $1$ (Hollow site): Adsorbate at $(0,0)$. Symmetry operation: rotation by $\\theta = \\pi/2$ radians. Output a boolean indicating whether the symmetry mismatch score is below the threshold.\n\n- Test Case $2$ (Bridge site): Adsorbate at $(+\\frac{a}{2},0)$. Symmetry operation: reflection across the $x$-axis. Output a boolean indicating whether the symmetry mismatch score is below the threshold.\n\n- Test Case $3$ (Top site): Adsorbate at $(+\\frac{a}{2},+\\frac{a}{2})$. Output the local charge transfer to the slab region in electrons as a float.\n\n- Test Case $4$ (Defect with broken symmetry): Move the slab atom originally at $(+\\frac{a}{2},+\\frac{a}{2})$ to $(+\\frac{a}{2},+\\frac{a}{2}+\\delta)$ with $\\delta = 0.30\\,\\mathrm{\\AA}$. Place the adsorbate at $(0,0)$. Symmetry operation: rotation by $\\theta = \\pi/2$ radians. Output two quantities: a boolean indicating whether the symmetry mismatch score is below the threshold, and a float giving the global neutrality integral (in electrons) of $\\Delta \\rho(\\mathbf{r})$ over the entire domain.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$[$result$_1$, result$_2$, result$_3$, result$_4$, result$_5]$, where result$_1$ and result$_2$ are booleans for Test Cases $1$ and $2$, result$_3$ is the float for Test Case $3$, result$_4$ is the boolean for Test Case $4$ symmetry, and result$_5$ is the float for Test Case $4$ global neutrality. The angle unit must be radians, and all charge-transfer values must be expressed in electrons.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of computational chemistry, specifically density functional theory modeling, and is mathematically well-posed with all necessary parameters and definitions provided for a deterministic computational solution. The definitions are clear, free of ambiguity, and the test cases are structured to produce verifiable numerical results.\n\n### Principle-Based Solution Design\n\nThe core task is to model and analyze the electron density difference field, $\\Delta \\rho(\\mathbf{r})$, for a model system of a catalytic slab and an adsorbate. This field represents the redistribution of electron charge due to the interaction between the slab and the adsorbate.\n\n#### 1. Computational Domain\nThe system is modeled on a two-dimensional square grid. The grid consists of $N \\times N$ points, with $N=201$. The grid spacing is uniform, $dx = 0.05\\,\\mathrm{\\AA}$. The total extent of the grid is determined by $L = \\frac{N-1}{2} dx = \\frac{200}{2} \\times 0.05 = 5.0\\,\\mathrm{\\AA}$. The grid coordinates $(x_j, y_k)$ thus span the domain $[-5.0, 5.0] \\times [-5.0, 5.0]\\,\\mathrm{\\AA}^2$. This domain is sufficiently large to contain all atomic centers and the significant portions of the electron density lobes.\n\n#### 2. Construction of the Electron Density Difference Field $\\Delta \\rho(\\mathbf{r})$\nThe problem provides a constructive definition for $\\Delta \\rho(\\mathbf{r})$ as a superposition of Gaussian charge distributions, which ensures that the total charge of this redistribution field is conserved (i.e., its integral over the entire domain is zero).\n\nFor a generic charge distribution (a \"lobe\") of total charge $Q$ centered at $\\mathbf{R}$ with width parameter $\\sigma$, its contribution to the density field is given by a normalized 2D Gaussian function:\n$$\n\\rho_{\\text{lobe}}(\\mathbf{r}) = \\frac{Q}{2\\pi \\sigma^2}\\,\\exp\\!\\left(-\\frac{\\lVert \\mathbf{r} - \\mathbf{R} \\rVert^2}{2\\sigma^2}\\right)\n$$\nThe electron density difference field $\\Delta\\rho(\\mathbf{r})$ is the sum of contributions from one negative lobe and four positive lobes:\n$$\n\\Delta \\rho(\\mathbf{r}) = \\rho_{\\text{pol}}^{-}(\\mathbf{r}) + \\sum_{i=1}^{4} \\rho_{\\text{pol}, i}^{+}(\\mathbf{r})\n$$\n- A single negative lobe is centered at the adsorbate position $\\mathbf{R}_\\mathrm{ads}$. It has a total charge of $-A$, where $A=0.4$ electrons, and a width $\\sigma_\\mathrm{pol} = 0.30\\,\\mathrm{\\AA}$.\n  $$\n  \\rho_{\\text{pol}}^{-}(\\mathbf{r}) = \\frac{-A}{2\\pi \\sigma_\\mathrm{pol}^2}\\,\\exp\\!\\left(-\\frac{\\lVert \\mathbf{r} - \\mathbf{R}_\\mathrm{ads} \\rVert^2}{2\\sigma_\\mathrm{pol}^2}\\right)\n  $$\n- Four positive lobes are associated with the four slab atoms at positions $\\mathbf{R}_i$. The $i$-th positive lobe is centered at the midpoint $\\mathbf{M}_i = \\frac{1}{2}(\\mathbf{R}_\\mathrm{ads} + \\mathbf{R}_i)$. Its width is also $\\sigma_\\mathrm{pol}$. Its charge is $A \\cdot w_i$, where the weights $w_i$ are calculated based on the distance $d_i = \\lVert \\mathbf{R}_\\mathrm{ads} - \\mathbf{R}_i \\rVert$ between the adsorbate and each slab atom:\n  $$\n  w_i = \\frac{\\exp(-d_i / d_\\mathrm{scale})}{\\sum_{j=1}^{4} \\exp(-d_j / d_\\mathrm{scale})}\n  $$\n  with $d_\\mathrm{scale} = 2.0\\,\\mathrm{\\AA}$. The weights are non-negative and sum to 1, $\\sum_i w_i = 1$. The contribution of the $i$-th positive lobe is thus:\n  $$\n  \\rho_{\\text{pol}, i}^{+}(\\mathbf{r}) = \\frac{A\\,w_i}{2\\pi \\sigma_\\mathrm{pol}^2}\\,\\exp\\!\\left(-\\frac{\\lVert \\mathbf{r} - \\mathbf{M}_i \\rVert^2}{2\\sigma_\\mathrm{pol}^2}\\right)\n  $$\nThe total charge of all positive lobes is $\\sum_i (A \\cdot w_i) = A \\sum_i w_i = A$. This perfectly cancels the charge of the negative lobe, $-A$, ensuring global charge neutrality, i.e., $\\int \\Delta\\rho(\\mathbf{r}) d^2\\mathbf{r} = 0$.\n\n#### 3. Numerical Computation of Observables\nAll quantities are computed numerically on the discrete grid.\n- **Numerical Integration**: The integral of a function $f(\\mathbf{r})$ over a region $\\Omega$ is approximated by a Riemann sum:\n  $$\n  \\int_\\Omega f(\\mathbf{r}) d^2\\mathbf{r} \\approx \\sum_{(x_j, y_k) \\in \\Omega} f(x_j, y_k) (dx)^2\n  $$\n  where $(dx)^2$ is the area element.\n\n- **Global Neutrality Check**: This is the integral of $\\Delta\\rho(\\mathbf{r})$ over the entire computational grid. Due to the construction of $\\Delta\\rho$, this value should be numerically close to zero.\n\n- **Local Charge Transfer**: This is the integral of $\\Delta\\rho(\\mathbf{r})$ over the union of four circular disks, each with radius $r_s = 0.60\\,\\mathrm{\\AA}$ centered at a slab atom position $\\mathbf{R}_i$.\n  $$\n  Q_{\\text{slab}} = \\int_{\\cup_{i} \\text{Disk}(\\mathbf{R}_i, r_s)} \\Delta\\rho(\\mathbf{r}) d^2\\mathbf{r}\n  $$\n\n- **Symmetry Analysis**: To assess the symmetry of $\\Delta\\rho(\\mathbf{r})$ under a transformation $\\mathcal{T}$, we compute the symmetry mismatch score $S$:\n  $$\n  S = \\frac{\\left\\| \\Delta \\rho - \\mathcal{T}\\left[\\Delta \\rho\\right] \\right\\|_2}{\\left\\| \\Delta \\rho \\right\\|_2}\n  $$\n  The discrete $L^2$ norm of a field $f$ on the grid is calculated as $\\left\\| f \\right\\|_2 = \\sqrt{\\sum_{j,k} |f(x_j, y_k)|^2 (dx)^2}$. The term $(dx)^2$ cancels in the ratio for $S$, so it simplifies to the ratio of vector norms of the gridded field values.\n  The transformed field $\\mathcal{T}[\\Delta \\rho]$ is evaluated at each grid point $\\mathbf{r}$ by finding the value of the original field $\\Delta\\rho$ at the pre-image point $\\mathbf{r}' = \\mathcal{T}^{-1}(\\mathbf{r})$, i.e., $\\mathcal{T}[\\Delta \\rho](\\mathbf{r}) = \\Delta\\rho(\\mathcal{T}^{-1}(\\mathbf{r}))$. Since $\\mathbf{r}'$ generally does not lie on a grid point, bilinear interpolation or a more sophisticated scheme is required. We will use `scipy.ndimage.map_coordinates` which implements spline interpolation.\n\n  - For a rotation by angle $\\theta$, the inverse transformation $\\mathcal{T}^{-1}$ is a rotation by $-\\theta$. The coordinates are transformed as:\n    $$\n    \\begin{pmatrix} x' \\\\ y' \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix}\n    $$\n  - For a reflection across the $x$-axis, the transformation is $(x,y) \\mapsto (x,-y)$. It is its own inverse, so $\\mathcal{T} = \\mathcal{T}^{-1}$:\n    $$\n    \\begin{pmatrix} x' \\\\ y' \\end{pmatrix} = \\begin{pmatrix} x \\\\ -y \\end{pmatrix}\n    $$\n  The field is considered symmetric if $S$ is less than the threshold $\\varepsilon = 1.0 \\times 10^{-2}$.\n\n#### 4. Execution of Test Cases\nThe solution proceeds by implementing the above principles for each of the four specified test cases.\n- **Case 1 (Hollow site)**: Adsorbate at $\\mathbf{R}_{\\text{ads}} = (0,0)$. The four slab atoms are at $(\\pm_1 a/2, \\pm_2 a/2)$ with $a/2 = 2.0\\,\\mathrm{\\AA}$. The setup is symmetric under a rotation of $\\theta = \\pi/2$ about the origin. The distances $d_i$ are all equal, so the weights $w_i$ are all $1/4$. The set of positive lobe centers $\\{\\mathbf{M}_i\\}$ is mapped onto itself by the rotation. Thus, $\\Delta\\rho$ should be highly symmetric, and $S$ is expected to be very small.\n- **Case 2 (Bridge site)**: Adsorbate at $\\mathbf{R}_{\\text{ads}} = (a/2, 0) = (2.0, 0)$. The system is geometrically symmetric with respect to reflection across the $x$-axis. This symmetry will propagate to the weights $w_i$ and lobe centers $\\mathbf{M}_i$, making $\\Delta\\rho$ symmetric. $S$ is expected to be small.\n- **Case 3 (Top site)**: Adsorbate at $\\mathbf{R}_{\\text{ads}} = (a/2, a/2) = (2.0, 2.0)$, directly on top of a slab atom. The local charge transfer to the slab region, $Q_{\\text{slab}}$, is calculated by integrating $\\Delta\\rho$ over the specified disks.\n- **Case 4 (Defect)**: One slab atom is displaced from $(2.0, 2.0)$ to $(2.0, 2.3)$, breaking the four-fold rotational symmetry. The adsorbate is at the hollow site $(0,0)$. When tested for rotation by $\\theta = \\pi/2$, the mismatch score $S$ is expected to be large, i.e., $S \\geq \\varepsilon$. The global neutrality integral is also computed as a check on the model's formulation and its numerical implementation.\n\nThe final program will systematically apply these steps to each test case and format the results as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import map_coordinates\n\ndef solve():\n    \"\"\"\n    Solves the problem of analyzing a model electron density difference field\n    for various catalytic configurations.\n    \"\"\"\n\n    # --- Global Parameters ---\n    N = 201  # Grid points per axis\n    DX = 0.05  # Grid spacing in Angstrom\n    A_LATTICE = 4.0  # Lattice constant in Angstrom\n    A_AMP = 0.4  # Total positive lobe amplitude in electrons\n    SIGMA_POL = 0.30  # Polarization lobe width in Angstrom\n    D_SCALE = 2.0  # Weight decay length scale in Angstrom\n    R_S_INTEG = 0.60  # Integration radius for local charge in Angstrom\n    SYM_TOL = 1.0e-2  # Symmetry mismatch score tolerance\n\n    # --- Grid Setup ---\n    L = (N - 1) / 2 * DX\n    grid_coords_1d = np.linspace(-L, L, N)\n    XX, YY = np.meshgrid(grid_coords_1d, grid_coords_1d)\n\n    # --- Helper Functions ---\n    def gaussian_2d(centers, total_charge, sigma):\n        \"\"\"\n        Computes the sum of 2D Gaussian fields on the grid.\n        `centers` is a list of (x, y) tuples for center positions.\n        `total_charge` is a list of charges for each Gaussian.\n        \"\"\"\n        field = np.zeros((N, N))\n        norm_factor_base = 1.0 / (2 * np.pi * sigma**2)\n        for center, charge in zip(centers, total_charge):\n            r_sq = (XX - center[0])**2 + (YY - center[1])**2\n            field += (charge * norm_factor_base) * np.exp(-r_sq / (2 * sigma**2))\n        return field\n\n    def compute_delta_rho(slab_pos_list, ads_pos):\n        \"\"\"\n        Constructs the electron density difference field delta_rho.\n        \"\"\"\n        slab_pos = np.array(slab_pos_list)\n        ads_pos = np.array(ads_pos)\n\n        # Calculate distance-based weights\n        distances = np.linalg.norm(slab_pos - ads_pos, axis=1)\n        exp_d = np.exp(-distances / D_SCALE)\n        weights = exp_d / np.sum(exp_d)\n\n        # Define lobe centers and charges\n        pos_lobe_centers = 0.5 * (slab_pos + ads_pos)\n        pos_lobe_charges = A_AMP * weights\n        \n        neg_lobe_center = ads_pos\n        neg_lobe_charge = -A_AMP\n\n        # Sum up all lobes to get delta_rho\n        delta_rho_field = gaussian_2d(pos_lobe_centers.tolist(), pos_lobe_charges, SIGMA_POL)\n        delta_rho_field += gaussian_2d([neg_lobe_center.tolist()], [neg_lobe_charge], SIGMA_POL)\n\n        return delta_rho_field\n\n    def transform_field(field, rot_matrix=None, reflect_x=False):\n        \"\"\"\n        Applies a symmetry transformation to the field using interpolation.\n        `rot_matrix` is the INVERSE of the rotation matrix.\n        \"\"\"\n        # Physical coordinates of each grid point\n        initial_coords = np.vstack([XX.ravel(), YY.ravel()])\n        \n        # Apply inverse transformation to find where to sample from\n        if rot_matrix is not None:\n             transformed_coords_phys = rot_matrix @ initial_coords\n        elif reflect_x:\n            # Reflection is its own inverse\n            reflection_matrix = np.array([[1, 0], [0, -1]])\n            transformed_coords_phys = reflection_matrix @ initial_coords\n        else:\n            return field.copy()\n\n        # Convert physical coordinates to grid index coordinates for interpolation\n        # index = (physical_coord - min_coord) / dx\n        tx_phys, ty_phys = transformed_coords_phys[0], transformed_coords_phys[1]\n        \n        ix = (tx_phys + L) / DX\n        iy = (ty_phys + L) / DX\n\n        # map_coordinates expects coordinates in (row, col) i.e., (y, x) order\n        interp_coords = np.vstack([iy, ix])\n        \n        transformed_field_flat = map_coordinates(field, interp_coords, order=3, mode='constant', cval=0.0)\n        \n        return transformed_field_flat.reshape((N, N))\n\n    def compute_symmetry_score(field1, field2):\n        \"\"\"Calculates the L2 norm-based symmetry mismatch score.\"\"\"\n        norm_diff = np.linalg.norm(field1 - field2)\n        norm_orig = np.linalg.norm(field1)\n        return norm_diff / norm_orig if norm_orig > 0 else 0.0\n\n    def compute_local_charge_transfer(field, slab_pos_list):\n        \"\"\"Integrates delta_rho over disks around slab atoms.\"\"\"\n        mask = np.zeros_like(field, dtype=bool)\n        for pos in slab_pos_list:\n            dist_sq = (XX - pos[0])**2 + (YY - pos[1])**2\n            mask |= (dist_sq = R_S_INTEG**2)\n        \n        charge = np.sum(field[mask]) * (DX**2)\n        return charge\n\n    def compute_global_neutrality(field):\n        \"\"\"Integrates delta_rho over the entire domain.\"\"\"\n        return np.sum(field) * (DX**2)\n\n    results = []\n    \n    # --- Base Slab Geometry ---\n    half_a = A_LATTICE / 2.0\n    base_slab_pos = [\n        (half_a, half_a), (half_a, -half_a),\n        (-half_a, half_a), (-half_a, -half_a)\n    ]\n\n    # --- Test Case 1: Hollow site ---\n    ads_pos_1 = (0.0, 0.0)\n    delta_rho_1 = compute_delta_rho(base_slab_pos, ads_pos_1)\n    theta_1 = np.pi / 2\n    # Inverse rotation matrix (rotation by -theta)\n    rot_mat_inv_1 = np.array([[np.cos(theta_1), np.sin(theta_1)],\n                              [-np.sin(theta_1), np.cos(theta_1)]])\n    transformed_rho_1 = transform_field(delta_rho_1, rot_matrix=rot_mat_inv_1)\n    score_1 = compute_symmetry_score(delta_rho_1, transformed_rho_1)\n    results.append(score_1  SYM_TOL)\n\n    # --- Test Case 2: Bridge site ---\n    ads_pos_2 = (half_a, 0.0)\n    delta_rho_2 = compute_delta_rho(base_slab_pos, ads_pos_2)\n    transformed_rho_2 = transform_field(delta_rho_2, reflect_x=True)\n    score_2 = compute_symmetry_score(delta_rho_2, transformed_rho_2)\n    results.append(score_2  SYM_TOL)\n    \n    # --- Test Case 3: Top site ---\n    ads_pos_3 = (half_a, half_a)\n    delta_rho_3 = compute_delta_rho(base_slab_pos, ads_pos_3)\n    local_charge_3 = compute_local_charge_transfer(delta_rho_3, base_slab_pos)\n    results.append(local_charge_3)\n\n    # --- Test Case 4: Defect ---\n    delta_defect = 0.30\n    defect_slab_pos = base_slab_pos.copy()\n    defect_slab_pos[0] = (half_a, half_a + delta_defect)\n    ads_pos_4 = (0.0, 0.0)\n    delta_rho_4 = compute_delta_rho(defect_slab_pos, ads_pos_4)\n    theta_4 = np.pi / 2\n    rot_mat_inv_4 = np.array([[np.cos(theta_4), np.sin(theta_4)],\n                              [-np.sin(theta_4), np.cos(theta_4)]])\n    transformed_rho_4 = transform_field(delta_rho_4, rot_matrix=rot_mat_inv_4)\n    score_4 = compute_symmetry_score(delta_rho_4, transformed_rho_4)\n    results.append(score_4  SYM_TOL)\n    \n    neutrality_4 = compute_global_neutrality(delta_rho_4)\n    results.append(neutrality_4)\n    \n    # --- Final Output ---\n    # Convert booleans to lowercase 'true'/'false' for consistency if needed, but problem doesn't specify\n    str_results = []\n    for r in results:\n        if isinstance(r, bool):\n            str_results.append(str(r))\n        else:\n            str_results.append(f\"{r:.8f}\")\n\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A $\\Delta \\rho(\\mathbf{r})$ map provides a rich visual story of how charge rearranges upon bonding, but a deeper chemical understanding requires knowing *which orbitals* are donating and accepting electrons. This practice introduces a critical analysis technique: the decomposition of a total density difference map into contributions from a basis of localized atomic orbitals . You will implement a form of Mulliken population analysis to connect the spatial features of charge depletion and accumulation directly to the underlying atomic orbitals, turning a complex map into actionable chemical insight.",
            "id": "3878896",
            "problem": "You are given a discrete spatial grid and a set of localized atomic-like orbitals and Kohn–Sham one-electron states, as used in computational catalysis and chemical engineering. Consider the standard Kohn–Sham electron density for a system, defined on a discrete grid as $$\\rho(\\mathbf{r}_i) = \\sum_{j} f_j \\left|\\psi_j(\\mathbf{r}_i)\\right|^2$$ where $f_j$ are occupation numbers and $\\psi_j(\\mathbf{r}_i)$ are Kohn–Sham orbitals evaluated at grid point $\\mathbf{r}_i$. For an adsorbed system compared to a clean reference, the difference in electron density is defined as $$\\Delta \\rho(\\mathbf{r}_i) = \\sum_{j} \\Delta f_j \\left|\\psi_j(\\mathbf{r}_i)\\right|^2$$ where $\\Delta f_j$ are occupation changes upon adsorption. Assume each $\\psi_j$ should be normalized such that $$\\sum_i \\left|\\psi_j(\\mathbf{r}_i)\\right|^2 \\Delta V = 1$$ with uniform grid cell volume $\\Delta V$.\n\nYou will perform an orbital and band decomposition of the electron density difference mapping. Band decomposition aggregates contributions from specified groups of states. Orbital decomposition uses projections onto a set of localized atomic orbitals $\\{\\phi_\\alpha(\\mathbf{r})\\}$, with an overlap matrix $$S_{\\alpha\\beta} = \\sum_i \\phi_\\alpha(\\mathbf{r}_i)\\,\\phi_\\beta(\\mathbf{r}_i)\\,\\Delta V$$ and inner products $$b_\\alpha^{(j)} = \\sum_i \\phi_\\alpha(\\mathbf{r}_i)\\,\\psi_j(\\mathbf{r}_i)\\,\\Delta V.$$ Let the expansion coefficients $c_\\alpha^{(j)}$ approximate the projection of $\\psi_j$ onto the localized orbital basis via a stable linear algebra procedure applied to $S$ and $b^{(j)}$ that is robust even when $S$ is ill-conditioned. Use the well-tested Mulliken population analysis to obtain orbital population changes from these coefficients and the overlap matrix, and distribute each orbital’s population change over space using its squared amplitude as a weight normalized to integrate to $1$. The goal is to construct an orbital-resolved spatial mapping that integrates to the total electron change and to compare it against the full difference density.\n\nImplement a program that:\n- Normalizes each Kohn–Sham orbital $\\psi_j$ on the grid to unit norm under the discrete integral with grid cell volume $\\Delta V$.\n- Computes the full difference density $\\Delta \\rho(\\mathbf{r}_i)$.\n- Computes band-resolved difference densities for provided band groupings.\n- Computes the localized orbital overlap matrix $S$, inner products $b^{(j)}$, stable expansion coefficients $c^{(j)}$, and constructs an orbital-resolved difference density using Mulliken population analysis with weights defined by normalized $\\left|\\phi_\\alpha(\\mathbf{r}_i)\\right|^2$.\n- Computes integrated band contributions and integrated orbital contributions (both expressed in electrons), the total integrated electron change (in electrons), and the Euclidean norm of the discrepancy between the full difference density and the orbital-resolved reconstruction (expressed as a float). Also, verify charge conservation by checking that the integrated orbital-resolved density equals the total integrated electron change up to a small numerical tolerance, and return this check as a boolean.\n\nExpress all integrated charges in electrons (unit: electrons). Angles do not appear. Percentages do not appear.\n\nTest Suite:\nUse the following three parameter sets that probe a general case, a zero-change edge case, and an ill-conditioned overlap case. Each parameter set consists of the grid cell volume $\\Delta V$, localized orbitals $\\{\\phi_\\alpha(\\mathbf{r}_i)\\}$, Kohn–Sham orbitals $\\{\\psi_j(\\mathbf{r}_i)\\}$, band groupings, and occupation changes $\\{\\Delta f_j\\}$.\n\n- Case $1$ (general happy path):\n  - Grid cell volume: $\\Delta V = 1.0$.\n  - Localized orbitals:\n    - $\\phi_1(\\mathbf{r}_i) = [\\,\\;0.4,\\;0.4,\\;0.4,\\;0.4,\\;0.4\\,\\;]$,\n    - $\\phi_2(\\mathbf{r}_i) = [\\,\\;0.0,\\;1.0,\\;2.0,\\;1.0,\\;0.0\\,\\;]$.\n  - Kohn–Sham orbitals (raw, to be normalized):\n    - $\\psi_0(\\mathbf{r}_i) = [\\,\\;0.0,\\;0.5,\\;1.0,\\;0.5,\\;0.0\\,\\;]$,\n    - $\\psi_1(\\mathbf{r}_i) = [\\,\\;0.4,\\;0.4,\\;0.4,\\;0.4,\\;0.4\\,\\;]$,\n    - $\\psi_2(\\mathbf{r}_i) = [\\,\\;0.2,\\;0.6,\\;1.0,\\;0.6,\\;0.2\\,\\;]$.\n  - Band groupings: $[\\,[\\,0,1\\,],\\,[\\,2\\,]\\,]$.\n  - Occupation changes: $\\Delta f = [\\,\\;0.5,\\;-0.3,\\;0.2\\,\\;]$.\n\n- Case $2$ (zero-change edge case):\n  - Grid cell volume: $\\Delta V = 1.0$.\n  - Localized orbitals:\n    - $\\phi_1(\\mathbf{r}_i) = [\\,\\;0.5,\\;0.5,\\;0.5,\\;0.5\\,\\;]$,\n    - $\\phi_2(\\mathbf{r}_i) = [\\,\\;0.0,\\;1.0,\\;0.0,\\;0.0\\,\\;]$.\n  - Kohn–Sham orbitals (raw, to be normalized):\n    - $\\psi_0(\\mathbf{r}_i) = [\\,\\;0.5,\\;0.5,\\;0.5,\\;0.5\\,\\;]$,\n    - $\\psi_1(\\mathbf{r}_i) = [\\,\\;0.0,\\;1.0,\\;0.0,\\;0.0\\,\\;]$.\n  - Band groupings: $[\\,[\\,0\\,],\\,[\\,1\\,]\\,]$.\n  - Occupation changes: $\\Delta f = [\\,\\;0.0,\\;0.0\\,\\;]$.\n\n- Case $3$ (ill-conditioned overlap case):\n  - Grid cell volume: $\\Delta V = 1.0$.\n  - Localized orbitals:\n    - $\\phi_1(\\mathbf{r}_i) = [\\,\\;0.41,\\;0.41,\\;0.41,\\;0.41,\\;0.41,\\;0.41\\,\\;]$,\n    - $\\phi_2(\\mathbf{r}_i) = [\\,\\;0.405,\\;0.415,\\;0.402,\\;0.418,\\;0.404,\\;0.410\\,\\;]$.\n  - Kohn–Sham orbitals (raw, to be normalized):\n    - $\\psi_0(\\mathbf{r}_i) = [\\,\\;0.41,\\;0.41,\\;0.41,\\;0.41,\\;0.41,\\;0.41\\,\\;]$,\n    - $\\psi_1(\\mathbf{r}_i) = [\\,\\;0.405,\\;0.415,\\;0.402,\\;0.418,\\;0.404,\\;0.410\\,\\;]$.\n  - Band groupings: $[\\,[\\,0,1\\,]\\,]$.\n  - Occupation changes: $\\Delta f = [\\,\\;0.1,\\;-0.1\\,\\;]$.\n\nYour program should produce a single line of output containing the results for all three test cases as a comma-separated list enclosed in square brackets. Each test case’s result must be a list containing:\n- The total integrated electron change (a float, in electrons),\n- The list of integrated band contributions (each a float, in electrons),\n- The list of integrated orbital contributions (each a float, in electrons),\n- The Euclidean norm of the difference between the full difference density and the orbital-resolved reconstruction (a float),\n- The boolean charge conservation check.\n\nFor example, the output format should be of the form\n$$[\\, [\\,\\text{case1\\_total},\\,\\text{case1\\_bands},\\,\\text{case1\\_orbitals},\\,\\text{case1\\_error},\\,\\text{case1\\_bool}\\,],\\, [\\,\\text{case2\\_total},\\,\\dots\\,],\\, [\\,\\text{case3\\_total},\\,\\dots\\,]\\, ]$$\nwhere lists are written with square brackets and elements separated by commas.",
            "solution": "The problem has been analyzed and is deemed valid. It is scientifically grounded in the principles of Density Functional Theory (DFT) and computational materials science, well-posed with all necessary data and a clear objective, and formulated using precise, objective language. The problem requires the implementation of standard techniques for analyzing electron density changes, such as band and orbital decomposition, including handling potentially ill-conditioned numerical scenarios.\n\nThe solution proceeds by implementing the specified analysis steps for each test case. The core of the method is to decompose the total electron density difference, $\\Delta \\rho(\\mathbf{r}_i)$, which arises from changes in state occupations $\\Delta f_j$, into contributions from specific groups of Kohn-Sham states (bands) and from a basis of localized atomic-like orbitals $\\{\\phi_\\alpha\\}$.\n\n**Step 1: Normalization of Kohn-Sham Orbitals**\nFirst, each provided Kohn-Sham orbital, $\\psi_j^{\\text{raw}}(\\mathbf{r}_i)$, must be normalized. The normalization condition on a discrete grid with uniform cell volume $\\Delta V$ is given by:\n$$ \\sum_i \\left|\\psi_j(\\mathbf{r}_i)\\right|^2 \\Delta V = 1 $$\nThe normalization constant, $N_j$, for each raw orbital is calculated as:\n$$ N_j = \\left( \\sum_i \\left|\\psi_j^{\\text{raw}}(\\mathbf{r}_i)\\right|^2 \\Delta V \\right)^{-1/2} $$\nThe normalized orbital is then $\\psi_j(\\mathbf{r}_i) = N_j \\cdot \\psi_j^{\\text{raw}}(\\mathbf{r}_i)$. This ensures that each orbital represents a single electron state.\n\n**Step 2: Full and Band-Resolved Difference Density**\nWith the normalized orbitals, the total electron density difference, $\\Delta\\rho(\\mathbf{r}_i)$, is computed directly from its definition:\n$$ \\Delta \\rho(\\mathbf{r}_i) = \\sum_{j} \\Delta f_j \\left|\\psi_j(\\mathbf{r}_i)\\right|^2 $$\nwhere $\\Delta f_j$ are the given occupation changes. The total integrated electron change, $Q_{\\text{total}}$, is the integral of this quantity over all space, which simplifies due to the normalization of $\\psi_j$:\n$$ Q_{\\text{total}} = \\sum_i \\Delta \\rho(\\mathbf{r}_i) \\Delta V = \\sum_i \\left( \\sum_{j} \\Delta f_j \\left|\\psi_j(\\mathbf{r}_i)\\right|^2 \\right) \\Delta V = \\sum_j \\Delta f_j \\left( \\sum_i \\left|\\psi_j(\\mathbf{r}_i)\\right|^2 \\Delta V \\right) = \\sum_j \\Delta f_j $$\nThe integrated band contributions, $Q_B$, for each specified group of states (band) $B$, are calculated by summing the occupation changes for the states within that group:\n$$ Q_B = \\sum_{j \\in B} \\Delta f_j $$\n\n**Step 3: Orbital Projection and Expansion Coefficients**\nTo decompose $\\Delta\\rho$ into atomic orbital contributions, we project the Kohn-Sham orbitals $\\{\\psi_j\\}$ onto the basis of localized atomic-like orbitals $\\{\\phi_\\alpha\\}$. We seek expansion coefficients $c_\\alpha^{(j)}$ such that $\\psi_j(\\mathbf{r}_i) \\approx \\sum_\\alpha c_\\alpha^{(j)} \\phi_\\alpha(\\mathbf{r}_i)$. This approximation leads to a system of linear equations for each state $j$:\n$$ \\mathbf{b}^{(j)} = \\mathbf{S} \\mathbf{c}^{(j)} $$\nHere, $\\mathbf{S}$ is the overlap matrix of the localized orbitals, with elements:\n$$ S_{\\alpha\\beta} = \\sum_i \\phi_\\alpha(\\mathbf{r}_i)\\,\\phi_\\beta(\\mathbf{r}_i)\\,\\Delta V $$\nAnd $\\mathbf{b}^{(j)}$ is a vector of inner products between $\\psi_j$ and the basis orbitals:\n$$ b_\\alpha^{(j)} = \\sum_i \\phi_\\alpha(\\mathbf{r}_i)\\,\\psi_j(\\mathbf{r}_i)\\,\\Delta V $$\nAs specified, this linear system must be solved using a stable procedure robust to ill-conditioning of the overlap matrix $\\mathbf{S}$, which can occur if the basis orbitals $\\{\\phi_\\alpha\\}$ are nearly linearly dependent. A least-squares solver, which effectively computes $\\mathbf{c}^{(j)} = \\mathbf{S}^+ \\mathbf{b}^{(j)}$ using the pseudoinverse $\\mathbf{S}^+$, is the appropriate tool.\n\n**Step 4: Mulliken Population Analysis and Orbital-Resolved Density Reconstruction**\nThe calculated coefficients $c_\\alpha^{(j)}$ are used in a Mulliken population analysis to partition the electrons among the atomic orbitals. The contribution of orbital $\\alpha$ to the population of state $j$, $P_j(\\alpha)$, is:\n$$ P_j(\\alpha) = \\sum_\\beta c_\\alpha^{(j)} c_\\beta^{(j)} S_{\\alpha\\beta} $$\nThe total change in electron population for orbital $\\alpha$, which is the integrated orbital contribution $\\Delta P(\\alpha)$, is obtained by summing over all states, weighted by their occupation changes:\n$$ \\Delta P(\\alpha) = \\sum_j \\Delta f_j P_j(\\alpha) = \\sum_j \\Delta f_j \\left( \\sum_\\beta c_\\alpha^{(j)} c_\\beta^{(j)} S_{\\alpha\\beta} \\right) $$\nThe sum of these orbital population changes, $\\sum_\\alpha \\Delta P(\\alpha)$, should ideally equal the total electron change, $Q_{\\text{total}}$. Deviations indicate the degree to which the LCAO expansion fails to perfectly represent the Kohn-Sham orbitals. This is used for the charge conservation check.\n\nFinally, the orbital-resolved difference density, $\\Delta\\rho_{\\text{orb}}(\\mathbf{r}_i)$, is constructed by distributing each integrated orbital contribution $\\Delta P(\\alpha)$ over space according to the normalized squared amplitude of its corresponding atomic orbital:\n$$ \\Delta\\rho_{\\text{orb}}(\\mathbf{r}_i) = \\sum_\\alpha \\Delta P(\\alpha) \\frac{\\left|\\phi_\\alpha(\\mathbf{r}_i)\\right|^2}{\\sum_k \\left|\\phi_\\alpha(\\mathbf{r}_k)\\right|^2 \\Delta V} $$\n\n**Step 5: Final Quantities and Comparison**\nThe required outputs are now assembled:\n1.  **Total integrated electron change:** $Q_{\\text{total}} = \\sum_j \\Delta f_j$.\n2.  **Integrated band contributions:** A list of $Q_B = \\sum_{j \\in B} \\Delta f_j$ for each band $B$.\n3.  **Integrated orbital contributions:** A list of $\\Delta P(\\alpha)$ for each orbital $\\alpha$.\n4.  **Discrepancy norm:** The Euclidean norm of the difference between the full and reconstructed densities, $E = \\left\\| \\Delta\\rho - \\Delta\\rho_{\\text{orb}} \\right\\|_2 = \\sqrt{\\sum_i \\left( \\Delta\\rho(\\mathbf{r}_i) - \\Delta\\rho_{\\text{orb}}(\\mathbf{r}_i) \\right)^2}$.\n5.  **Charge conservation check:** A boolean value indicating whether $|Q_{\\text{total}} - \\sum_\\alpha \\Delta P(\\alpha)|$ is smaller than a numerical tolerance (e.g., $10^{-9}$).\n\nThis procedure is applied to each of the three test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... (No scipy needed, numpy.linalg.lstsq is sufficient)\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the analysis, and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"delta_V\": 1.0,\n            \"phi_orbitals\": np.array([\n                [0.4, 0.4, 0.4, 0.4, 0.4],\n                [0.0, 1.0, 2.0, 1.0, 0.0]\n            ]),\n            \"psi_orbitals_raw\": np.array([\n                [0.0, 0.5, 1.0, 0.5, 0.0],\n                [0.4, 0.4, 0.4, 0.4, 0.4],\n                [0.2, 0.6, 1.0, 0.6, 0.2]\n            ]),\n            \"band_groupings\": [[0, 1], [2]],\n            \"delta_f\": np.array([0.5, -0.3, 0.2])\n        },\n        {\n            \"delta_V\": 1.0,\n            \"phi_orbitals\": np.array([\n                [0.5, 0.5, 0.5, 0.5],\n                [0.0, 1.0, 0.0, 0.0]\n            ]),\n            \"psi_orbitals_raw\": np.array([\n                [0.5, 0.5, 0.5, 0.5],\n                [0.0, 1.0, 0.0, 0.0]\n            ]),\n            \"band_groupings\": [[0], [1]],\n            \"delta_f\": np.array([0.0, 0.0])\n        },\n        {\n            \"delta_V\": 1.0,\n            \"phi_orbitals\": np.array([\n                [0.41, 0.41, 0.41, 0.41, 0.41, 0.41],\n                [0.405, 0.415, 0.402, 0.418, 0.404, 0.410]\n            ]),\n            \"psi_orbitals_raw\": np.array([\n                [0.41, 0.41, 0.41, 0.41, 0.41, 0.41],\n                [0.405, 0.415, 0.402, 0.418, 0.404, 0.410]\n            ]),\n            \"band_groupings\": [[0, 1]],\n            \"delta_f\": np.array([0.1, -0.1])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of lists naturally includes spaces after commas.\n    # To match the rigid output format required by some platforms, which might not\n    # have spaces, we can remove them.\n    # e.g., str([[1,2], [3,4]]) - '[[1, 2], [3, 4]]'\n    # We replace ', ' with ',' and then restore for the outermost list.\n    formatted_results = str(results).replace(\" \", \"\")\n    print(formatted_results)\n\n\ndef solve_case(delta_V, phi_orbitals, psi_orbitals_raw, band_groupings, delta_f):\n    \"\"\"\n    Performs electron density difference analysis for a single case.\n    \"\"\"\n    # Step 1: Normalize Kohn-Sham orbitals\n    psi_orbitals_normalized = []\n    for psi_raw in psi_orbitals_raw:\n        norm_sq = np.sum(psi_raw**2) * delta_V\n        # Handle case where norm is zero to avoid division by zero\n        if np.isclose(norm_sq, 0.0):\n             psi_orbitals_normalized.append(psi_raw)\n        else:\n             psi_orbitals_normalized.append(psi_raw / np.sqrt(norm_sq))\n    psi_orbitals_normalized = np.array(psi_orbitals_normalized)\n\n    # Step 2: Calculate full and band-resolved difference densities and integrations\n    psi_sq = psi_orbitals_normalized**2\n    delta_rho = np.sum(delta_f[:, np.newaxis] * psi_sq, axis=0)\n    \n    total_integrated_change = np.sum(delta_f)\n    \n    integrated_band_contribs = [np.sum(delta_f[group]) for group in band_groupings]\n\n    # Step 3: Orbital projection to find expansion coefficients c\n    num_aos = phi_orbitals.shape[0]\n    num_states = psi_orbitals_normalized.shape[0]\n\n    S_matrix = (phi_orbitals @ phi_orbitals.T) * delta_V\n    b_vectors = (psi_orbitals_normalized @ phi_orbitals.T) * delta_V # Shape (num_states, num_aos)\n\n    # Solve S c = b for c. lstsq solves A x = B, where x are columns.\n    # A = S_matrix, B = b_vectors.T\n    c_coeffs = np.linalg.lstsq(S_matrix, b_vectors.T, rcond=None)[0].T # Shape (num_states, num_aos)\n\n    # Step 4: Mulliken population analysis and orbital-resolved density reconstruction\n    # P_j(alpha) = sum_beta(c_alpha,j * c_beta,j * S_alpha,beta)\n    # Vectorized: P_j_vector = c_j * (S @ c_j)\n    orbital_pop_changes = np.zeros(num_aos)\n    if num_states  0:\n        P_vectors_matrix = c_coeffs * (c_coeffs @ S_matrix)\n        orbital_pop_changes = delta_f @ P_vectors_matrix\n\n    # Reconstruct orbital-resolved density\n    phi_sq = phi_orbitals**2\n    phi_norms = np.sum(phi_sq, axis=1) * delta_V\n    \n    # Handle case where phi_norm is zero\n    phi_weights = np.zeros_like(phi_sq)\n    non_zero_norm_mask = ~np.isclose(phi_norms, 0.0)\n    phi_weights[non_zero_norm_mask] = phi_sq[non_zero_norm_mask] / phi_norms[non_zero_norm_mask, np.newaxis]\n\n    delta_rho_orb_per_ao = orbital_pop_changes[:, np.newaxis] * phi_weights\n    delta_rho_orb = np.sum(delta_rho_orb_per_ao, axis=0)\n\n    # Step 5: Final quantities and comparison\n    discrepancy_norm = np.linalg.norm(delta_rho - delta_rho_orb)\n    \n    charge_conservation_check = np.isclose(total_integrated_change, np.sum(orbital_pop_changes))\n    \n    return [\n        total_integrated_change,\n        integrated_band_contribs,\n        orbital_pop_changes.tolist(),\n        discrepancy_norm,\n        bool(charge_conservation_check)\n    ]\n\nsolve()\n```"
        },
        {
            "introduction": "The redistribution of charge described by $\\Delta \\rho(\\mathbf{r})$ has direct physical consequences, most notably the creation of an induced electrostatic potential, $\\Delta \\phi(\\mathbf{r})$. This final practice tackles the fundamental problem of calculating this potential by solving the Poisson equation, $\\nabla^2 \\Delta \\phi = -\\Delta \\rho/\\varepsilon_0$, in a periodic system . By implementing an efficient spectral solver using Fast Fourier Transforms, you will master a core technique in computational materials science and gain the ability to predict changes in key physical observables like the surface work function.",
            "id": "3878880",
            "problem": "Consider electron density difference mapping in computational catalysis for a periodic cubic unit cell, where an adsorbate induces a redistribution of electron density on a catalytic surface. The electron density difference, denoted as $\\Delta \\rho(\\mathbf{r})$, is formally defined by the superposition principle as $\\Delta \\rho(\\mathbf{r}) = \\rho_{\\text{combined}}(\\mathbf{r}) - \\rho_{\\text{adsorbate}}(\\mathbf{r}) - \\rho_{\\text{surface}}(\\mathbf{r})$. The electrostatic potential $\\phi(\\mathbf{r})$ generated by $\\Delta \\rho(\\mathbf{r})$ in vacuum is governed by a fundamental law from classical electromagnetism: Gauss’s law for electrostatics (combined with the definition of the electrostatic field as the gradient of a scalar potential) implies the Poisson equation $\\nabla^2 \\phi(\\mathbf{r}) = -\\Delta \\rho(\\mathbf{r})/\\varepsilon_0$, where $\\varepsilon_0$ is the vacuum permittivity. In a periodic cubic cell of edge length $L$ with periodic boundary conditions, both $\\Delta \\rho(\\mathbf{r})$ and $\\phi(\\mathbf{r})$ admit Fourier series representations. The problem requires you to derive, implement, and evaluate a spectral (Fourier-domain) solution to this Poisson problem for specified test electron density differences that model charge redistribution typical of adsorption on catalytic surfaces.\n\nStarting from fundamental laws of electromagnetism (Gauss’s law and the definition of the electrostatic field) and the core definitions of Fourier series on a periodic domain, derive the computational approach to obtain $\\phi(\\mathbf{r})$ from $\\Delta \\rho(\\mathbf{r})$ in a cubic periodic cell. You must consider the physically realistic requirement that the $k=\\mathbf{0}$ Fourier component (the spatial average of $\\Delta \\rho(\\mathbf{r})$) cannot generate a finite periodic potential. In computational practice for periodic boundary conditions, this necessitates enforcing global charge neutrality by subtracting the mean of $\\Delta \\rho(\\mathbf{r})$ before solving the Poisson equation, which sets the reference potential to have zero average.\n\nImplement the following programmatic tasks in a self-contained way:\n\n1. Construct $\\Delta \\rho(\\mathbf{r})$ on a uniform three-dimensional grid of $N \\times N \\times N$ points spanning a cubic domain of edge length $L$ using a superposition of two normalized three-dimensional Gaussian lobes with equal and opposite integrated charges. Let the positive lobe be centered at $\\mathbf{r}_+$ with charge $q_+$ and the negative lobe at $\\mathbf{r}_-$ with charge $q_-$, with $q_+ + q_- \\approx 0$. Each lobe is modeled by a normalized Gaussian\n$$\nG(\\mathbf{r};\\mathbf{r}_0,\\sigma) = \\frac{1}{(2\\pi)^{3/2}\\sigma^3} \\exp\\left(-\\frac{\\|\\mathbf{r} - \\mathbf{r}_0\\|^2}{2\\sigma^2}\\right),\n$$\nso that the density is\n$$\n\\Delta \\rho(\\mathbf{r}) = q_+ \\, G(\\mathbf{r};\\mathbf{r}_+,\\sigma) + q_- \\, G(\\mathbf{r};\\mathbf{r}_-,\\sigma).\n$$\nImpose periodicity by evaluating distances with minimum-image convention under the cubic periodic boundary conditions.\n\n2. Enforce neutrality for the periodic Poisson solve by subtracting the spatial mean of $\\Delta \\rho(\\mathbf{r})$ over the cell before computing the potential.\n\n3. Solve the Poisson equation spectrally by transforming $\\Delta \\rho(\\mathbf{r})$ to reciprocal space, acting with the inverse Laplacian operator (diagonal in Fourier space), and transforming back to real space to obtain $\\phi(\\mathbf{r})$ on the grid. Handle the $\\mathbf{k}=\\mathbf{0}$ mode appropriately to avoid division by zero.\n\n4. Evaluate $\\phi(\\mathbf{r})$ at three physically relevant points for each test case: the centers of the positive and negative Gaussian lobes ($\\mathbf{r}_+$ and $\\mathbf{r}_-$), and the midpoint $\\mathbf{r}_{\\text{mid}} = (\\mathbf{r}_+ + \\mathbf{r}_-)/2$. Use nearest-grid-point sampling to approximate $\\phi(\\mathbf{r})$ at these positions. Express the potential values in volts and report the results as floating-point numbers.\n\nUse the vacuum permittivity $\\varepsilon_0 = 8.854187817 \\times 10^{-12}$ farad per meter. All positions must be within the periodic box of size $L$. All physical quantities must be treated with International System of Units (SI units): length in meters, charge in coulombs, density in coulombs per cubic meter, and potential in volts. Angles are not involved.\n\nTest Suite and required outputs:\nFor each of the following parameter sets, compute and return the three potential values in volts at the points $\\mathbf{r}_+$, $\\mathbf{r}_-$, and $\\mathbf{r}_{\\text{mid}}$.\n\n- Case 1 (neutral redistribution, moderate separation):\n  - $L = 1.0 \\times 10^{-9}$ meters,\n  - $N = 64$,\n  - $q_+ = 1.0 \\times 10^{-19}$ coulombs,\n  - $q_- = -1.0 \\times 10^{-19}$ coulombs,\n  - $\\sigma = 8.0 \\times 10^{-11}$ meters,\n  - $\\mathbf{r}_+ = (0.25L, 0.50L, 0.50L)$,\n  - $\\mathbf{r}_- = (0.75L, 0.50L, 0.50L)$.\n\n- Case 2 (near-neutral redistribution, mean-subtraction required):\n  - $L = 1.2 \\times 10^{-9}$ meters,\n  - $N = 64$,\n  - $q_+ = 1.0 \\times 10^{-19}$ coulombs,\n  - $q_- = -0.99 \\times 10^{-19}$ coulombs,\n  - $\\sigma = 6.0 \\times 10^{-11}$ meters,\n  - $\\mathbf{r}_+ = (0.40L, 0.40L, 0.40L)$,\n  - $\\mathbf{r}_- = (0.60L, 0.60L, 0.60L)$.\n\n- Case 3 (neutral redistribution, narrow lobes near boundaries to test periodicity):\n  - $L = 8.0 \\times 10^{-10}$ meters,\n  - $N = 64$,\n  - $q_+ = 0.5 \\times 10^{-19}$ coulombs,\n  - $q_- = -0.5 \\times 10^{-19}$ coulombs,\n  - $\\sigma = 2.0 \\times 10^{-11}$ meters,\n  - $\\mathbf{r}_+ = (0.10L, 0.10L, 0.70L)$,\n  - $\\mathbf{r}_- = (0.90L, 0.90L, 0.30L)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[\\phi(\\mathbf{r}_+), \\phi(\\mathbf{r}_-), \\phi(\\mathbf{r}_{\\text{mid}})]$ for Case $1$, followed by the same triplet for Case $2$, and then Case $3$. All values must be expressed in volts, with no unit symbols in the output, and represented as floating-point numbers. For example, the output format is $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\ldots]$.",
            "solution": "The problem requires the calculation of the electrostatic potential $\\phi(\\mathbf{r})$ resulting from a given electron density difference $\\Delta\\rho(\\mathbf{r})$ within a cubic periodic cell of side length $L$. This is a canonical problem in computational physics and chemistry, solvable via the Poisson equation.\n\nThe fundamental relationship between the electrostatic potential $\\phi(\\mathbf{r})$ and the charge density $\\Delta\\rho(\\mathbf{r})$ is given by the Poisson equation, which is derived from Gauss's law for electrostatics ($\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$) and the definition of the electrostatic field as the negative gradient of the potential ($\\mathbf{E} = -\\nabla \\phi$). Combining these gives:\n$$\n\\nabla^2 \\phi(\\mathbf{r}) = -\\frac{\\Delta\\rho(\\mathbf{r})}{\\varepsilon_0}\n$$\nwhere $\\nabla^2$ is the Laplacian operator and $\\varepsilon_0$ is the vacuum permittivity, given as $8.854187817 \\times 10^{-12} \\, \\text{F/m}$.\n\nThe problem is set in a periodic domain, which makes it highly amenable to a solution in Fourier space. A function $f(\\mathbf{r})$ that is periodic on a cubic box of volume $V = L^3$ can be represented by a Fourier series:\n$$\nf(\\mathbf{r}) = \\sum_{\\mathbf{k}} \\hat{f}(\\mathbf{k}) e^{i \\mathbf{k} \\cdot \\mathbf{r}}\n$$\nThe sum is over the discrete set of reciprocal lattice vectors $\\mathbf{k} = \\frac{2\\pi}{L}(n_x, n_y, n_z)$, where $n_x, n_y, n_z$ are integers. The Fourier coefficients $\\hat{f}(\\mathbf{k})$ are given by the inverse relation:\n$$\n\\hat{f}(\\mathbf{k}) = \\frac{1}{V} \\int_V f(\\mathbf{r}) e^{-i \\mathbf{k} \\cdot \\mathbf{r}} d^3\\mathbf{r}\n$$\nApplying the Fourier transform to the Laplacian operator yields a simple multiplicative factor: $\\mathcal{F}\\{\\nabla^2 f(\\mathbf{r})\\} = -\\|\\mathbf{k}\\|^2 \\hat{f}(\\mathbf{k})$, where $\\|\\mathbf{k}\\|^2 = k_x^2 + k_y^2 + k_z^2$.\n\nTransforming the entire Poisson equation into the Fourier domain gives:\n$$\n-\\|\\mathbf{k}\\|^2 \\hat{\\phi}(\\mathbf{k}) = -\\frac{\\hat{\\Delta\\rho}(\\mathbf{k})}{\\varepsilon_0}\n$$\nSolving for the Fourier coefficients of the potential $\\hat{\\phi}(\\mathbf{k})$ yields:\n$$\n\\hat{\\phi}(\\mathbf{k}) = \\frac{\\hat{\\Delta\\rho}(\\mathbf{k})}{\\varepsilon_0 \\|\\mathbf{k}\\|^2}\n$$\nThis expression is valid for all $\\mathbf{k} \\neq \\mathbf{0}$. The case $\\mathbf{k} = \\mathbf{0}$ requires special attention. For $\\mathbf{k} = \\mathbf{0}$, the denominator $\\|\\mathbf{k}\\|^2$ becomes zero. A physically meaningful, bounded potential can only exist if the numerator is also zero. The $\\mathbf{k}=\\mathbf{0}$ component of the density, $\\hat{\\Delta\\rho}(\\mathbf{k}=\\mathbf{0})$, is the spatial average of the density over the unit cell:\n$$\n\\hat{\\Delta\\rho}(\\mathbf{k}=\\mathbf{0}) = \\frac{1}{V} \\int_V \\Delta\\rho(\\mathbf{r}) d^3\\mathbf{r} = \\frac{Q_{\\text{total}}}{V}\n$$\nThis implies that the total charge $Q_{\\text{total}}$ in the periodic cell must be zero. The problem explicitly addresses cases where this might not be true (Case 2) and mandates the enforcement of neutrality by subtracting the mean density. This procedure is equivalent to adding a uniform compensating background charge. We define a neutralized density $\\Delta\\rho'(\\mathbf{r}) = \\Delta\\rho(\\mathbf{r}) - \\langle\\Delta\\rho\\rangle$, where $\\langle\\Delta\\rho\\rangle = Q_{\\text{total}}/V$. By construction, $\\hat{\\Delta\\rho'}(\\mathbf{k}=\\mathbf{0}) = 0$.\n\nFor $\\mathbf{k}=\\mathbf{0}$, the value of $\\hat{\\phi}(\\mathbf{k}=\\mathbf{0})$ represents the average potential over the cell. Since the absolute potential is defined only up to an arbitrary constant, we are free to set this average value. The standard and most convenient choice is to set the average potential to zero, which means $\\hat{\\phi}(\\mathbf{k}=\\mathbf{0}) = 0$.\n\nThe computational algorithm is as follows:\n1.  **Discretize the Domain**: Represent the cubic cell of side $L$ with a uniform $N \\times N \\times N$ grid of points. The grid spacing is $h = L/N$.\n2.  **Construct Charge Density**: The density difference $\\Delta\\rho(\\mathbf{r})$ is constructed on this grid. It is the sum of two Gaussian distributions, $q_+ G(\\mathbf{r};\\mathbf{r}_+,\\sigma)$ and $q_- G(\\mathbf{r};\\mathbf{r}_-,\\sigma)$. To respect the periodic boundary conditions, the distance $\\|\\mathbf{r} - \\mathbf{r}_0\\|$ in the Gaussian exponent is calculated using the minimum-image convention. For a given component, say $x$, the distance is $\\Delta x' = \\Delta x - L \\cdot \\text{round}(\\Delta x / L)$.\n3.  **Enforce Charge Neutrality**: Compute the mean of the discretized density, $\\langle\\Delta\\rho\\rangle = \\frac{1}{N^3} \\sum_{i,j,k} \\Delta\\rho(\\mathbf{r}_{ijk})$, and subtract it from each grid point: $\\Delta\\rho'_{ijk} = \\Delta\\rho_{ijk} - \\langle\\Delta\\rho\\rangle$.\n4.  **Forward Fourier Transform**: Compute the discrete Fourier transform of the neutralized density grid $\\Delta\\rho'$ using a Fast Fourier Transform (FFT) algorithm to obtain $\\hat{\\Delta\\rho'}(\\mathbf{k})$.\n5.  **Solve in Reciprocal Space**:\n    a. Construct the grid of reciprocal space vectors $\\mathbf{k}$. The components for a grid of size $N$ and length $L$ are given by $k_x = 2\\pi \\nu_x$, where $\\nu_x$ are the frequencies returned by standard FFT frequency functions (e.g., `numpy.fft.fftfreq`).\n    b. Calculate the squared magnitude $\\|\\mathbf{k}\\|^2$ for each point in the reciprocal grid.\n    c. Compute the Fourier coefficients of the potential: $\\hat{\\phi}(\\mathbf{k}) = \\hat{\\Delta\\rho'}(\\mathbf{k}) / (\\varepsilon_0 \\|\\mathbf{k}\\|^2)$ for all $\\mathbf{k} \\neq \\mathbf{0}$.\n    d. Set the D.C. component to zero: $\\hat{\\phi}(\\mathbf{k}=\\mathbf{0}) = 0$. This is done by setting the $[0,0,0]$ element of the array to $0$ after the division.\n6.  **Inverse Fourier Transform**: Compute the inverse FFT of the $\\hat{\\phi}(\\mathbf{k})$ grid to obtain the real-space potential $\\phi(\\mathbf{r})$ on the grid. The result of a numerical IFFT may have small, spurious imaginary parts, so we take the real part of the final result.\n7.  **Sample Potential**: Evaluate the potential at the specified points $\\mathbf{r}_+$, $\\mathbf{r}_-$, and $\\mathbf{r}_{\\text{mid}}$ by finding the nearest grid point to each target location and retrieving the corresponding potential value. The index for a coordinate $x$ is found via $i_x = \\text{round}(x \\cdot N/L) \\pmod N$.\n\nThis spectral method is computationally efficient, leveraging the $O(N^3 \\log N)$ complexity of the FFT algorithm, and is the standard approach for solving the Poisson equation in periodic simulations.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Poisson equation for electron density difference in a periodic\n    cubic cell using a spectral (Fourier) method.\n    \"\"\"\n    \n    # Constants\n    epsilon_0 = 8.854187817e-12  # Vacuum permittivity in F/m\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        {\n            \"L\": 1.0e-9, \"N\": 64, \"q_plus\": 1.0e-19, \"q_minus\": -1.0e-19,\n            \"sigma\": 8.0e-11, \"r_plus\": np.array([0.25, 0.50, 0.50]),\n            \"r_minus\": np.array([0.75, 0.50, 0.50])\n        },\n        {\n            \"L\": 1.2e-9, \"N\": 64, \"q_plus\": 1.0e-19, \"q_minus\": -0.99e-19,\n            \"sigma\": 6.0e-11, \"r_plus\": np.array([0.40, 0.40, 0.40]),\n            \"r_minus\": np.array([0.60, 0.60, 0.60])\n        },\n        {\n            \"L\": 8.0e-10, \"N\": 64, \"q_plus\": 0.5e-19, \"q_minus\": -0.5e-19,\n            \"sigma\": 2.0e-11, \"r_plus\": np.array([0.10, 0.10, 0.70]),\n            \"r_minus\": np.array([0.90, 0.90, 0.30])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        N = case[\"N\"]\n        q_plus = case[\"q_plus\"]\n        q_minus = case[\"q_minus\"]\n        sigma = case[\"sigma\"]\n        # Convert fractional coordinates to absolute coordinates\n        r_plus_abs = case[\"r_plus\"] * L\n        r_minus_abs = case[\"r_minus\"] * L\n        r_mid_abs = (r_plus_abs + r_minus_abs) / 2.0\n\n        # 1. Construct the grid and charge density\n        grid_coords = np.linspace(0, L, N, endpoint=False)\n        xx, yy, zz = np.meshgrid(grid_coords, grid_coords, grid_coords, indexing='ij')\n\n        def build_gaussian(q, r0, sigma_val):\n            # Calculate distance components with minimum image convention\n            dx = xx - r0[0]\n            dy = yy - r0[1]\n            dz = zz - r0[2]\n            \n            dx -= L * np.round(dx / L)\n            dy -= L * np.round(dy / L)\n            dz -= L * np.round(dz / L)\n            \n            dist_sq = dx**2 + dy**2 + dz**2\n            \n            norm_factor = 1.0 / ((2 * np.pi)**1.5 * sigma_val**3)\n            gaussian = norm_factor * np.exp(-dist_sq / (2 * sigma_val**2))\n            return q * gaussian\n\n        delta_rho = build_gaussian(q_plus, r_plus_abs, sigma) + \\\n                    build_gaussian(q_minus, r_minus_abs, sigma)\n\n        # 2. Enforce global charge neutrality\n        mean_rho = np.mean(delta_rho)\n        delta_rho_neutral = delta_rho - mean_rho\n\n        # 3. Solve Poisson equation in Fourier space\n        \n        # Forward FFT\n        rho_hat = np.fft.fftn(delta_rho_neutral)\n        \n        # Construct k-vectors\n        k_freq = np.fft.fftfreq(N, d=L/N)\n        kx = 2 * np.pi * k_freq\n        ky = 2 * np.pi * k_freq\n        kz = 2 * np.pi * k_freq\n        kxx, kyy, kzz = np.meshgrid(kx, ky, kz, indexing='ij')\n        \n        # Squared k-magnitude\n        k_sq = kxx**2 + kyy**2 + kzz**2\n\n        # Avoid division by zero at k=0\n        # The numerator rho_hat[0,0,0] is already zero due to mean subtraction\n        # but we must prevent the division to avoid NaN.\n        k_sq[0, 0, 0] = 1.0\n        \n        # Calculate potential in Fourier space\n        phi_hat = rho_hat / (epsilon_0 * k_sq)\n        \n        # Explicitly set the k=0 component to zero to enforce zero average potential\n        phi_hat[0, 0, 0] = 0.0\n        \n        # Inverse FFT to get potential in real space\n        phi_r = np.real(np.fft.ifftn(phi_hat))\n\n        # 4. Evaluate potential at specified points using nearest-grid-point sampling\n        def get_potential_at(pos_abs):\n            indices = (np.round((pos_abs / L) * N) % N).astype(int)\n            return phi_r[indices[0], indices[1], indices[2]]\n\n        phi_r_plus = get_potential_at(r_plus_abs)\n        phi_r_minus = get_potential_at(r_minus_abs)\n        phi_r_mid = get_potential_at(r_mid_abs)\n        \n        results.extend([phi_r_plus, phi_r_minus, phi_r_mid])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}