{
    "hands_on_practices": [
        {
            "introduction": "第一个练习旨在培养您从零开始构建线性标度关系的基础技能。您将使用模拟的氧和羟基吸附的电子结构数据进行线性回归，并解释所得斜率和截距的物理意义，这模拟了计算催化研究中的一项常见任务。这项动手实践将巩固量子化学数据与宏观催化趋势之间的联系。",
            "id": "3885848",
            "problem": "您的任务是构建一个线性自由能标度关系，该关系描述了在一系列金属氧化物上，羟基在表面上的吸附吉布斯自由能 $G_{\\mathrm{ads}}(\\mathrm{OH}^*)$ 与同一表面上原子氧的吸附吉布斯自由能 $G_{\\mathrm{ads}}(\\mathrm{O}^*)$ 之间的关系。从吉布斯自由能的定义 $G = H - TS$ 和吸附自由能的热力学定义 $G_{\\mathrm{ads}}$ 出发，假设吸附吉布斯自由能可以通过电子结构计算近似为 $G_{\\mathrm{ads}} \\approx E_{\\mathrm{ads}} + \\Delta \\mathrm{ZPE} - T \\Delta S$，其中 $E_{\\mathrm{ads}}$ 是来自密度泛函理论的电子吸附能，$\\Delta \\mathrm{ZPE}$ 是零点能校正，$T$ 是绝对温度，$\\Delta S$ 是吸附时的熵变。通过将 $(a,b)$ 拟合到多个表面的数据，推导、论证并估计一个形式为 $G_{\\mathrm{ads}}(\\mathrm{OH}^*) = a \\, G_{\\mathrm{ads}}(\\mathrm{O}^*) + b$ 的线性模型，并从物理角度解释斜率 $a$ 和截距 $b$ 的含义。\n\n您的程序必须实现以下步骤：\n- 使用 $G_{\\mathrm{ads}} = E_{\\mathrm{ads}} + \\Delta \\mathrm{ZPE} - T \\Delta S$ 从提供的 $E_{\\mathrm{ads}}$ 值计算 $G_{\\mathrm{ads}}(\\mathrm{O}^*)$ 和 $G_{\\mathrm{ads}}(\\mathrm{OH}^*)$。\n- 通过最小化每个数据集中观测到的 $G_{\\mathrm{ads}}(\\mathrm{OH}^*)$ 与预测的 $a \\, G_{\\mathrm{ads}}(\\mathrm{O}^*) + b$ 之间的残差平方和来估计 $(a,b)$。\n- 报告拟合的 $a$、$b$ 和均方根误差（RMSE），其中 $\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\left(G_{\\mathrm{ads}}^{(i)}(\\mathrm{OH}^*) - \\left(a \\, G_{\\mathrm{ads}}^{(i)}(\\mathrm{O}^*) + b\\right)\\right)^2}$，$N$ 是数据点的数量。\n\n使用电子伏特作为能量单位，开尔文作为温度单位。所有输出能量应以 $\\mathrm{eV}$ 为单位，在 $T = 298\\,\\mathrm{K}$ 下计算。您的结果必须表示为浮点数。最终输出格式必须是单行，包含一个用方括号括起来的逗号分隔列表，序列为 $[a_1,b_1,\\mathrm{RMSE}_1,a_2,b_2,\\mathrm{RMSE}_2,a_3,b_3,\\mathrm{RMSE}_3]$，对应下面描述的三个测试用例。\n\n测试套件：\n- 所有用例的通用常数：\n  - 温度：$T = 298\\,\\mathrm{K}$。\n  - 零点能校正：$\\Delta \\mathrm{ZPE}(\\mathrm{O}^*) = 0.05\\,\\mathrm{eV}$，$\\Delta \\mathrm{ZPE}(\\mathrm{OH}^*) = 0.35\\,\\mathrm{eV}$。\n  - 熵变（表示为当乘以温度 $T$（单位K）时，$T \\Delta S$ 的单位是 $\\mathrm{eV}$）：$\\Delta S(\\mathrm{O}^*) = 1.0 \\times 10^{-4}\\,\\mathrm{eV}/\\mathrm{K}$ 和 $\\Delta S(\\mathrm{OH}^*) = 2.0 \\times 10^{-4}\\,\\mathrm{eV}/\\mathrm{K}$。\n\n- 用例 1（具有中等噪声的一般情况）：\n  - 原子氧的原始电子吸附能：$E_{\\mathrm{ads}}^{(i)}(\\mathrm{O}^*) = [1.25, 1.60, 1.85, 2.10, 2.35, 2.55, 2.80, 3.05]\\,\\mathrm{eV}$。\n  - 羟基的原始电子吸附能：$E_{\\mathrm{ads}}^{(i)}(\\mathrm{OH}^*) = [1.455, 1.72, 2.015, 2.15, 2.425, 2.595, 2.79, 3.085]\\,\\mathrm{eV}$。\n\n- 用例 2（自由能呈精确线性标度的边界条件）：\n  - 吉布斯自由能中的目标精确参数：$a_{\\mathrm{target}} = 1.0$ 和 $b_{\\mathrm{target}} = 0.2\\,\\mathrm{eV}$。\n  - 选择氧吸附能：$E_{\\mathrm{ads}}^{(i)}(\\mathrm{O}^*) = [1.10, 1.80, 2.50]\\,\\mathrm{eV}$。\n  - 构建羟基吸附能，使得经过热化学校正后，关系式 $G_{\\mathrm{ads}}(\\mathrm{OH}^*) = a_{\\mathrm{target}} \\, G_{\\mathrm{ads}}(\\mathrm{O}^*) + b_{\\mathrm{target}}$ 精确成立。这意味着 $E_{\\mathrm{ads}}^{(i)}(\\mathrm{OH}^*) = a_{\\mathrm{target}} \\, E_{\\mathrm{ads}}^{(i)}(\\mathrm{O}^*) + \\left(b_{\\mathrm{target}} + a_{\\mathrm{target}} \\left(\\Delta \\mathrm{ZPE}(\\mathrm{O}^*) - T \\Delta S(\\mathrm{O}^*)\\right) - \\left(\\Delta \\mathrm{ZPE}(\\mathrm{OH}^*) - T \\Delta S(\\mathrm{OH}^*)\\right)\\right)$。\n\n- 用例 3（带有一个异常值的边缘情况）：\n  - 原子氧的原始电子吸附能：$E_{\\mathrm{ads}}^{(i)}(\\mathrm{O}^*) = [1.4, 1.9, 2.4, 2.9, 3.4, 2.2]\\,\\mathrm{eV}$。\n  - 羟基的原始电子吸附能：$E_{\\mathrm{ads}}^{(i)}(\\mathrm{OH}^*) = [1.56, 1.935, 2.40, 2.795, 3.24, 1.72]\\,\\mathrm{eV}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[a_1,b_1,\\mathrm{RMSE}_1,a_2,b_2,\\mathrm{RMSE}_2,a_3,b_3,\\mathrm{RMSE}_3]$）。所有能量都必须以 $\\mathrm{eV}$ 为单位，三个 $\\mathrm{RMSE}$ 值也必须以 $\\mathrm{eV}$ 为单位。",
            "solution": "目标是论证并估计在一系列金属氧化物上 $G_{\\mathrm{ads}}(\\mathrm{OH}^*)$ 和 $G_{\\mathrm{ads}}(\\mathrm{O}^*)$ 之间的线性自由能标度关系。推导从热力学开始。吉布斯自由能定义为 $G = H - T S$，其中 $H$ 是焓，$T$ 是绝对温度，$S$ 是熵。物种在表面上的吸附自由能可以表示为吸附态和参考态之间的吉布斯自由能变化。在基于密度泛函理论的热化学中使用的谐振子和理想气体近似下，通常将吸附自由能估计为 $G_{\\mathrm{ads}} \\approx E_{\\mathrm{ads}} + \\Delta \\mathrm{ZPE} - T \\Delta S$，其中 $E_{\\mathrm{ads}}$ 是电子能量差，$\\Delta \\mathrm{ZPE}$ 是零点能校正，$\\Delta S$ 是吸附时的熵变。在环境条件下，对于凝聚相，压力-体积项可以忽略不计，使得 $pV$ 的贡献与电子伏特单位下的电子和振动项相比很小。\n\n线性自由能标度关系的出现，是因为共享相似表面键合基序的不同吸附质，其结合强度在不同材料上通常表现出相关的变化。对于 $\\mathrm{O}^*$ 和 $\\mathrm{OH}^*$，这两种物质都形成金属-氧键，并且在不同氧化物中，金属-氧键强度的变化主要控制着 $G_{\\mathrm{ads}}(\\mathrm{O}^*)$ 和 $G_{\\mathrm{ads}}(\\mathrm{OH}^*)$。在相似的表面上，由于相似的振动光谱和熵损失，以及当配位数和局部几何结构相当时变化不大的吸附质-表面重杂化，向 $\\mathrm{O}^*$ 中添加氢形成 $\\mathrm{OH}^*$ 会贡献一个近似恒定的热化学偏移。因此，线性关系 $G_{\\mathrm{ads}}(\\mathrm{OH}^*) \\approx a \\, G_{\\mathrm{ads}}(\\mathrm{O}^*) + b$ 是合理的：斜率 $a$ 捕捉了金属-氧键合自由能的变化如何传播到羟基吸附自由能，而截距 $b$ 则捕捉了相对于计算参考库的氢化增量自由能（包括相对于 $\\mathrm{O}^*$ 的 $\\mathrm{OH}^*$ 特有的零点能和熵变）。\n\n要从数据中估计 $(a,b)$，为给定的数据集定义列表 $\\{ G_{\\mathrm{ads}}^{(i)}(\\mathrm{O}^*) \\}_{i=1}^{N}$ 和 $\\{ G_{\\mathrm{ads}}^{(i)}(\\mathrm{OH}^*) \\}_{i=1}^{N}$。估计问题是最小化残差平方和：\n$$\n\\min_{a,b} \\sum_{i=1}^{N} \\left( G_{\\mathrm{ads}}^{(i)}(\\mathrm{OH}^*) - \\left(a \\, G_{\\mathrm{ads}}^{(i)}(\\mathrm{O}^*) + b\\right) \\right)^2.\n$$\n这是普通最小二乘法（OLS）。唯一的最小化解得出\n$$\na = \\frac{\\sum_{i=1}^{N} \\left( x_i - \\bar{x} \\right)\\left( y_i - \\bar{y} \\right)}{\\sum_{i=1}^{N} \\left( x_i - \\bar{x} \\right)^2}, \\quad b = \\bar{y} - a \\bar{x},\n$$\n其中 $x_i = G_{\\mathrm{ads}}^{(i)}(\\mathrm{O}^*)$，$y_i = G_{\\mathrm{ads}}^{(i)}(\\mathrm{OH}^*)$，$\\bar{x} = \\frac{1}{N}\\sum_{i=1}^{N} x_i$，以及 $\\bar{y} = \\frac{1}{N}\\sum_{i=1}^{N} y_i$。均方根误差（RMSE）量化了典型偏差：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\left( y_i - \\left(a x_i + b\\right)\\right)^2}.\n$$\n\n对于每个测试用例，计算\n$$\nG_{\\mathrm{ads}}^{(i)}(\\mathrm{O}^*) = E_{\\mathrm{ads}}^{(i)}(\\mathrm{O}^*) + \\Delta \\mathrm{ZPE}(\\mathrm{O}^*) - T \\Delta S(\\mathrm{O}^*),\n$$\n$$\nG_{\\mathrm{ads}}^{(i)}(\\mathrm{OH}^*) = E_{\\mathrm{ads}}^{(i)}(\\mathrm{OH}^*) + \\Delta \\mathrm{ZPE}(\\mathrm{OH}^*) - T \\Delta S(\\mathrm{OH}^*).\n$$\n当 $T = 298\\,\\mathrm{K}$，$\\Delta \\mathrm{ZPE}(\\mathrm{O}^*) = 0.05\\,\\mathrm{eV}$，$\\Delta \\mathrm{ZPE}(\\mathrm{OH}^*) = 0.35\\,\\mathrm{eV}$，$\\Delta S(\\mathrm{O}^*) = 1.0 \\times 10^{-4}\\,\\mathrm{eV}/\\mathrm{K}$，$\\Delta S(\\mathrm{OH}^*) = 2.0 \\times 10^{-4}\\,\\mathrm{eV}/\\mathrm{K}$ 时，校正项变为 $\\Delta \\mathrm{ZPE}(\\mathrm{O}^*) - T \\Delta S(\\mathrm{O}^*) = 0.05\\,\\mathrm{eV} - 298\\,\\mathrm{K} \\times 1.0 \\times 10^{-4}\\,\\mathrm{eV}/\\mathrm{K} = 0.0202\\,\\mathrm{eV}$ 和 $\\Delta \\mathrm{ZPE}(\\mathrm{OH}^*) - T \\Delta S(\\mathrm{OH}^*) = 0.35\\,\\mathrm{eV} - 298\\,\\mathrm{K} \\times 2.0 \\times 10^{-4}\\,\\mathrm{eV}/\\mathrm{K} = 0.2904\\,\\mathrm{eV}$。\n\n用例1使用八个点，相对于潜在的线性趋势有适度噪声；拟合应产生一个接近1的斜率 $a$，但由于氢化效应可能略小于1，以及一个捕捉近似增量氢化自由能的截距 $b$。用例2被构造成满足自由能中的精确线性关系，$a_{\\mathrm{target}} = 1.0$ 且 $b_{\\mathrm{target}} = 0.2\\,\\mathrm{eV}$；因此，拟合参数应返回与这些目标值极其接近的值，且 $\\mathrm{RMSE}$ 接近于0。用例3引入了一个扰乱拟合的异常值；OLS估计将反映该异常值的影响，通常会改变斜率和截距，并增加 $\\mathrm{RMSE}$。\n\n物理解释：\n- 斜率 $a$ 是无量纲的，衡量了 $G_{\\mathrm{ads}}(\\mathrm{O}^*)$ 的敏感性如何在不同材料上转化为 $G_{\\mathrm{ads}}(\\mathrm{OH}^*)$ 的敏感性。因为 $\\mathrm{O}^*$ 和 $\\mathrm{OH}^*$ 都共享一个金属-氧键，当局部键合环境相似时，$a$ 预计接近于1；$a$ 与1的偏差反映了氢化时重杂化和键级重新分布的差异。\n- 截距 $b$ 的单位是 $\\mathrm{eV}$，代表了将氢添加到 $\\mathrm{O}^*$ 形成 $\\mathrm{OH}^*$ 所关联的基线自由能偏移，包括振动（零点能）和熵的贡献，以及由所选参考（例如，计算氢电极（CHE）框架）提供的氢的化学势。一个正的 $b$ 值表示，在固定的 $G_{\\mathrm{ads}}(\\mathrm{O}^*)$ 下，由于氢化的热化学和振动稳定化，$\\mathrm{OH}^*$ 的结合强度大约弱了 $b$。\n\n算法设计：\n- 对于每种情况，使用所述校正计算 $G_{\\mathrm{ads}}(\\mathrm{O}^*)$ 和 $G_{\\mathrm{ads}}(\\mathrm{OH}^*)$。\n- 使用上述以均值为中心的协方差和方差公式，通过OLS拟合 $(a,b)$，并通过检查 $G_{\\mathrm{ads}}(\\mathrm{O}^*)$ 的方差是否非零来确保数值稳定性。\n- 将 $\\mathrm{RMSE}$ 计算为均方残差的平方根。\n- 将三个用例的结果汇总到一个列表中，并以指定格式打印。\n\n所有报告的能量和误差都必须以 $\\mathrm{eV}$ 为单位，在 $T = 298\\,\\mathrm{K}$ 下。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef fit_linear(x, y):\n    \"\"\"\n    Fit y ~ a*x + b via Ordinary Least Squares (OLS).\n    Returns (a, b, rmse).\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    y = np.asarray(y, dtype=float)\n    x_mean = np.mean(x)\n    y_mean = np.mean(y)\n    var_x = np.sum((x - x_mean) ** 2)\n    if var_x == 0.0:\n        # Degenerate case: all x are equal; cannot fit slope.\n        # Set slope to 0, intercept to mean(y), RMSE accordingly.\n        a = 0.0\n        b = y_mean\n        rmse = float(np.sqrt(np.mean((y - b) ** 2)))\n        return a, b, rmse\n    cov_xy = np.sum((x - x_mean) * (y - y_mean))\n    a = cov_xy / var_x\n    b = y_mean - a * x_mean\n    residuals = y - (a * x + b)\n    rmse = float(np.sqrt(np.mean(residuals ** 2)))\n    return float(a), float(b), rmse\n\ndef compute_g_ads(E_ads, zpe, T, S):\n    \"\"\"\n    Compute Gibbs free energy of adsorption:\n    G_ads = E_ads + zpe - T*S\n    Inputs:\n        E_ads: array-like of electronic adsorption energies (eV)\n        zpe: float, zero-point energy correction (eV)\n        T: float, temperature (K)\n        S: float, entropy change (eV/K)\n    Returns:\n        numpy array of G_ads in eV\n    \"\"\"\n    E_ads = np.asarray(E_ads, dtype=float)\n    return E_ads + zpe - T * S\n\ndef solve():\n    # Constants common to all cases\n    T = 298.0  # K\n    zpe_O = 0.05  # eV\n    zpe_OH = 0.35  # eV\n    S_O = 1.0e-4  # eV/K\n    S_OH = 2.0e-4  # eV/K\n\n    # Precompute corrections for clarity\n    corr_O = zpe_O - T * S_O      # should be 0.0202 eV\n    corr_OH = zpe_OH - T * S_OH   # should be 0.2904 eV\n\n    results = []\n\n    # Case 1: general case with modest noise\n    E_O_case1 = [1.25, 1.60, 1.85, 2.10, 2.35, 2.55, 2.80, 3.05]\n    E_OH_case1 = [1.455, 1.72, 2.015, 2.15, 2.425, 2.595, 2.79, 3.085]\n    G_O_case1 = compute_g_ads(E_O_case1, zpe_O, T, S_O)\n    G_OH_case1 = compute_g_ads(E_OH_case1, zpe_OH, T, S_OH)\n    a1, b1, rmse1 = fit_linear(G_O_case1, G_OH_case1)\n    results.extend([round(a1, 6), round(b1, 6), round(rmse1, 6)])\n\n    # Case 2: boundary condition with exact linear scaling in free energies\n    a_target = 1.0\n    b_target = 0.2  # eV\n    E_O_case2 = [1.10, 1.80, 2.50]\n    # Construct E_OH to enforce exact relation in G:\n    # G_OH = a_target * G_O + b_target\n    # => E_OH + corr_OH = a_target * (E_O + corr_O) + b_target\n    # => E_OH = a_target * E_O + (b_target + a_target * corr_O - corr_OH)\n    offset_case2 = (b_target + a_target * corr_O - corr_OH)\n    E_OH_case2 = [a_target * e + offset_case2 for e in E_O_case2]\n    G_O_case2 = compute_g_ads(E_O_case2, zpe_O, T, S_O)\n    G_OH_case2 = compute_g_ads(E_OH_case2, zpe_OH, T, S_OH)\n    a2, b2, rmse2 = fit_linear(G_O_case2, G_OH_case2)\n    results.extend([round(a2, 6), round(b2, 6), round(rmse2, 6)])\n\n    # Case 3: edge case with an outlier\n    E_O_case3 = [1.4, 1.9, 2.4, 2.9, 3.4, 2.2]\n    E_OH_case3 = [1.56, 1.935, 2.40, 2.795, 3.24, 1.72]  # includes an outlier at the last point\n    G_O_case3 = compute_g_ads(E_O_case3, zpe_O, T, S_O)\n    G_OH_case3 = compute_g_ads(E_OH_case3, zpe_OH, T, S_OH)\n    a3, b3, rmse3 = fit_linear(G_O_case3, G_OH_case3)\n    results.extend([round(a3, 6), round(b3, 6), round(rmse3, 6)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "尽管简单的标度关系功能强大，但通过引入多个物理描述符可以对其进行扩展以获得更高的精度。本练习要求您开发一个多元线性模型，该模型同时使用d带中心（$\\varepsilon_d$）和d带宽度（$W_d$）来预测吸附能。您将实现一个稳健的拟合程序，以处理更复杂和可能相关的真实数据，这是现代数据驱动科学中的一项关键技能。",
            "id": "3885786",
            "problem": "你的任务是在计算催化和化学工程领域的线性自由能标度关系框架内，建立并估计吸附能与电子结构描述符之间的仿射线性关系。从一个有效的物理和数学基础开始：化学吸附理论（例如，Newns–Anderson 模型）将吸附能与杂化、成键态和反键态的填充以及费米能级附近的金属态密度联系起来。在一个描述符变化在参考金属和位点周围很小，且吸附物覆盖度和表面几何结构固定的体系中，一阶多元泰勒展开和线性响应意味着吸附能的变化可以近似为描述符变化的仿射线性映射。在这些条件下，将吸附能建模为两个描述符的仿射线性函数是合适的：相对于费米能级的 $d$ 带中心，表示为 $\\varepsilon_d$（单位为 $\\mathrm{eV}$），以及 $d$ 带宽度，表示为 $W_d$（单位为 $\\mathrm{eV}$）。系数代表灵敏度，截距代表基准吸附能。\n\n你的程序必须使用普通最小二乘法来估计系数向量 $\\mathbf{m}$ 和截距 $b$，该方法通过最小化残差平方和来实现，并通过奇异值分解（SVD）进行稳定求解。为了在存在共线性或秩亏的情况下减轻数值不稳定性，请使用 Moore–Penrose 伪逆，并设置一个基于最大奇异值的 SVD 容差阈值 $r_\\mathrm{tol}$，使得小于 $r_\\mathrm{tol} \\times \\sigma_{\\max}$ 的奇异值 $\\sigma$ 被视为零。设计矩阵必须包含一列全为1的列，以便与描述符灵敏度一起估计截距 $b$。\n\n科学真实性约束：\n- 将所有吸附能视为以 $\\mathrm{eV}$ 为单位的放热值，所有描述符值也以 $\\mathrm{eV}$ 为单位。\n- 假设每个数据集中的吸附物覆盖度恒定，且只有单一类型的位点。\n- 通过将每个系数的符号和大小与吸附能对相应描述符的灵敏度联系起来，来解释其物理意义，这应与线性响应一致。\n\n实现以下三个测试数据集，每个数据集代表模型行为的一个不同方面。对于每个数据集，给定一组描述符对 $(\\varepsilon_d, W_d)$ 和测量的吸附能 $E_\\mathrm{ads}$（单位为 $\\mathrm{eV}$）：\n\n数据集 A（两个描述符都具有变异性的一般情况）：\n- $\\varepsilon_d$ 序列：$[-2.1, -1.8, -1.2, -0.9, -2.5, -1.5, -0.7, -1.0]$ $\\mathrm{eV}$。\n- $W_d$ 序列：$[2.6, 2.3, 1.8, 1.7, 2.9, 2.0, 1.6, 1.7]$ $\\mathrm{eV}$。\n- $E_\\mathrm{ads}$ 序列：$[-1.845, -1.755, -1.35, -1.27, -2.09, -1.545, -1.145, -1.245]$ $\\mathrm{eV}$。\n\n数据集 B（一个描述符方差为零的边界情况）：\n- $\\varepsilon_d$ 序列：$[-2.4, -2.0, -1.6, -1.2, -0.8]$ $\\mathrm{eV}$。\n- $W_d$ 序列：$[2.0, 2.0, 2.0, 2.0, 2.0]$ $\\mathrm{eV}$。\n- $E_\\mathrm{ads}$ 序列：$[-1.84, -1.68, -1.59, -1.41, -1.30]$ $\\mathrm{eV}$。\n\n数据集 C（描述符之间存在精确线性依赖关系的边缘情况）：\n- $\\varepsilon_d$ 序列：$[-2.0, -1.0, 0.0, 1.0]$ $\\mathrm{eV}$。\n- $W_d$ 序列：$[2.2, 2.7, 3.2, 3.7]$ $\\mathrm{eV}$。\n- $E_\\mathrm{ads}$ 序列：$[-1.75, -1.525, -1.30, -1.075]$ $\\mathrm{eV}$。\n\n使用这些数据集：\n- 为每个数据集构建增广设计矩阵，其列为 [$\\varepsilon_d$, $W_d$, 1]。\n- 使用 SVD 求解最小化残差范数平方的系数向量 $\\mathbf{c} = [m_{\\varepsilon_d}, m_{W_d}, b]^\\top$，其中奇异值的相对容差 $r_\\mathrm{tol} = 10^{-12}$，从而得到 Moore–Penrose 伪逆解。计算拟合的吸附能和决定系数 $R^2 = 1 - \\frac{\\sum_i (E_{\\mathrm{ads},i} - \\hat{E}_{\\mathrm{ads},i})^2}{\\sum_i (E_{\\mathrm{ads},i} - \\bar{E}_\\mathrm{ads})^2}$，表示为小数值。\n- 将 $m_{\\varepsilon_d}$ 和 $m_{W_d}$ 的物理意义解释为灵敏度（单位为 $\\mathrm{eV}/\\mathrm{eV}$），将 $b$ 解释为基准能量（单位为 $\\mathrm{eV}$）。程序无需打印文本解释，但你的解决方案必须解释这种诠释。\n\n要求输出：\n- 对于每个数据集，按 A、B、C 的顺序，生成列表 $[b, m_{\\varepsilon_d}, m_{W_d}, R^2]$。\n- 你的程序应生成单行输出，其中包含这三个列表组成的逗号分隔列表，并用方括号括起来，不含空格。例如，外层列表应类似于 $[[b_A, m_{\\varepsilon_d,A}, m_{W_d,A}, R^2_A],[b_B, m_{\\varepsilon_d,B}, m_{W_d,B}, R^2_B],[b_C, m_{\\varepsilon_d,C}, m_{W_d,C}, R^2_C]]$，其中每个量都是浮点数。所有能量必须以 $\\mathrm{eV}$ 为单位，所有灵敏度必须以 $\\mathrm{eV}/\\mathrm{eV}$ 为单位。",
            "solution": "目标是在线性响应的体系下，估计吸附能与两个电子描述符之间的仿射线性映射。其潜在的物理基础是化学吸附理论，在该理论中，吸附能由吸附物前线轨道与费米能级附近的金属态之间的相互作用决定。Newns–Anderson 框架将吸附能分解为来自杂化（化学键形成）和反键态占据的贡献，这两者都依赖于金属 $d$ 带的特征，例如 $d$ 带中心 $\\varepsilon_d$ 和 $d$ 带宽度 $W_d$。当描述符的变化相对于参考态足够小，并且所有其他条件（覆盖度、位点类型、几何结构）保持不变时，线性响应理论和一阶多元泰勒展开意味着吸附能的变化可以用描述符的仿射线性函数来描述。在这种表示中，系数是一阶灵敏度：$m_{\\varepsilon_d}$ 表示吸附能随 $\\varepsilon_d$ 单位变化的改变量，$m_{W_d}$ 表示随 $W_d$ 单位变化的改变量。截距 $b$ 代表描述符取参考值时的基准吸附能。\n\n算法构建：\n- 给定 $N$ 个数据点 $\\{(\\varepsilon_{d,i}, W_{d,i}, E_{\\mathrm{ads},i})\\}_{i=1}^N$，构建增广设计矩阵 $X \\in \\mathbb{R}^{N \\times 3}$，其列为 [$\\varepsilon_d$, $W_d$, 1]，以及包含 $E_{\\mathrm{ads}}$ 的响应向量 $\\mathbf{y} \\in \\mathbb{R}^N$。\n- 通过最小化残差平方和 $\\|\\mathbf{y} - X \\mathbf{c}\\|_2^2$ 来估计系数向量 $\\mathbf{c} = [m_{\\varepsilon_d}, m_{W_d}, b]^\\top$。为了在存在共线性或秩亏的情况下获得数值稳定的解，计算奇异值分解（SVD）$X = U \\Sigma V^\\top$，其中 $\\Sigma$ 是对角矩阵，其对角线元素为奇异值 $\\{\\sigma_j\\}$。构建 Moore–Penrose 伪逆 $X^+ = V \\Sigma^+ U^\\top$，其中 $\\Sigma^+$ 包含大于阈值 $r_\\mathrm{tol} \\times \\sigma_{\\max}$ 的奇异值的倒数，否则为零。解为 $\\mathbf{c} = X^+ \\mathbf{y}$。\n- 计算预测值 $\\hat{\\mathbf{y}} = X \\mathbf{c}$ 和决定系数 $R^2 = 1 - \\frac{\\sum_i (y_i - \\hat{y}_i)^2}{\\sum_i (y_i - \\bar{y})^2}$，其中 $\\bar{y}$ 是 $y_i$ 的均值。$R^2$ 衡量模型解释响应方差的程度，并表示为小数值。\n\n物理诠释：\n- 系数 $m_{\\varepsilon_d}$（单位为 $\\mathrm{eV}/\\mathrm{eV}$）量化了吸附能对 $d$ 带中心位移的敏感程度。在许多化学吸附场景中，增加 $\\varepsilon_d$（使 $d$ 带中心更接近费米能级）会增强杂化作用，并可能使吸附更具放热性；这通过 $m_{\\varepsilon_d}$ 的符号来反映。\n- 系数 $m_{W_d}$（单位为 $\\mathrm{eV}/\\mathrm{eV}$）捕捉了对 $d$ 带宽度变化的灵敏度。更宽的 $d$ 带会改变可用态的密度和杂化强度；其符号表明在所研究的体系中，增宽能带是增强还是减弱吸附。\n- 截距 $b$（单位为 $\\mathrm{eV}$）代表在所选坐标表示中，描述符为零时参考构型的基准吸附能。\n\n测试套件覆盖范围：\n- 数据集 A 用于测试一般情况，其中两个描述符都存在变异性，如果线性模型适用，会产生一个良态的设计矩阵和较高的 $R^2$。\n- 数据集 B 测试边界情况，其中一个描述符（$W_d$）是恒定的；回归仍然可以唯一地估计截距和对 $\\varepsilon_d$ 的灵敏度，而对 $W_d$ 的灵敏度则从常数列和截距捕获的相关性中推断出来。\n- 数据集 C 构建了一个边缘情况，其中存在精确的线性依赖关系 $W_d = a + c \\, \\varepsilon_d$；设计矩阵是秩亏的。基于 SVD 的伪逆返回最能拟合数据的最小范数解。只要响应存在变化，$R^2$ 仍然有意义。\n\n实现细节：\n- 使用 $r_\\mathrm{tol} = 10^{-12}$ 来确定哪些奇异值需要求逆。\n- 将每个数据集的输出组装成 $[b, m_{\\varepsilon_d}, m_{W_d}, R^2]$。\n- 生成一行包含三个内层列表的逗号分隔外层列表，用方括号括起来，不含空格，并确保所有能量单位为 $\\mathrm{eV}$，灵敏度单位为 $\\mathrm{eV}/\\mathrm{eV}$。\n\n此过程根据线性响应和稳定数值线性代数的第一性原理来估计系数，并提供与线性自由能标度关系一致的可解释物理灵敏度。",
            "answer": "```python\nimport numpy as np\n\ndef svd_pseudoinverse(X, rtol=1e-12):\n    \"\"\"\n    Compute the Moore-Penrose pseudoinverse of X using SVD with relative tolerance.\n    Singular values smaller than rtol * max_sigma are set to zero (not inverted).\n    \"\"\"\n    U, s, VT = np.linalg.svd(X, full_matrices=False)\n    max_sigma = s[0] if s.size > 0 else 0.0\n    # Invert singular values with thresholding\n    s_inv = np.array([1/si if si >= rtol * max_sigma and si > 0 else 0.0 for si in s])\n    # Construct pseudoinverse\n    X_plus = (VT.T * s_inv) @ U.T\n    return X_plus\n\ndef fit_affine_linear(eps_d, W_d, E_ads, rtol=1e-12):\n    \"\"\"\n    Fit E_ads ~ m_eps * eps_d + m_W * W_d + b using SVD-based pseudoinverse.\n    Returns (b, m_eps, m_W, R2).\n    \"\"\"\n    eps_d = np.asarray(eps_d, dtype=float)\n    W_d = np.asarray(W_d, dtype=float)\n    y = np.asarray(E_ads, dtype=float)\n\n    # Design matrix with columns [eps_d, W_d, 1] to include intercept\n    X = np.column_stack([eps_d, W_d, np.ones_like(eps_d)])\n\n    # Solve via pseudoinverse\n    X_plus = svd_pseudoinverse(X, rtol=rtol)\n    coeffs = X_plus @ y  # [m_eps, m_W, b]\n    m_eps, m_W, b = coeffs[0], coeffs[1], coeffs[2]\n\n    # Predictions and R2\n    y_pred = X @ coeffs\n    y_mean = np.mean(y)\n    ss_res = float(np.sum((y - y_pred) ** 2))\n    ss_tot = float(np.sum((y - y_mean) ** 2))\n    R2 = 1.0 - ss_res / ss_tot if ss_tot > 0 else float('nan')\n\n    return b, m_eps, m_W, R2\n\ndef format_results_no_spaces(results):\n    \"\"\"\n    Format a list of lists of floats as a single string with no spaces.\n    Each inner list is formatted with values as plain floats (Python default),\n    separated by commas and enclosed in square brackets. The outer list\n    concatenates the inner lists similarly, with no spaces anywhere.\n    \"\"\"\n    def fmt_inner(inner):\n        return \"[\" + \",\".join(f\"{x:.12g}\" if isinstance(x, float) else str(x) for x in inner) + \"]\"\n    return \"[\" + \",\".join(fmt_inner(inner) for inner in results) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Dataset A\n    eps_A = [-2.1, -1.8, -1.2, -0.9, -2.5, -1.5, -0.7, -1.0]\n    W_A   = [ 2.6,  2.3,  1.8,  1.7,  2.9,  2.0,  1.6,  1.7]\n    E_A   = [-1.845, -1.755, -1.35, -1.27, -2.09, -1.545, -1.145, -1.245]\n\n    # Dataset B\n    eps_B = [-2.4, -2.0, -1.6, -1.2, -0.8]\n    W_B   = [ 2.0,  2.0,  2.0,  2.0,  2.0]\n    E_B   = [-1.84, -1.68, -1.59, -1.41, -1.30]\n\n    # Dataset C (Wd linearly dependent on eps_d)\n    eps_C = [-2.0, -1.0, 0.0, 1.0]\n    W_C   = [ 2.2,  2.7, 3.2, 3.7]\n    E_C   = [-1.75, -1.525, -1.30, -1.075]\n\n    test_cases = [\n        (eps_A, W_A, E_A),\n        (eps_B, W_B, E_B),\n        (eps_C, W_C, E_C),\n    ]\n\n    results = []\n    for eps_d, W_d, E_ads in test_cases:\n        b, m_eps, m_W, R2 = fit_affine_linear(eps_d, W_d, E_ads, rtol=1e-12)\n        results.append([b, m_eps, m_W, R2])\n\n    # Final print statement in the exact required format: no spaces.\n    print(format_results_no_spaces(results))\n\nsolve()\n```"
        },
        {
            "introduction": "计算数据与实验数据一样，并非完美无缺，并包含内在的不确定性。这最后一个练习引入了一项关键的统计改进：使用加权最小二乘法（WLS）来构建一个更稳健的标度模型。通过根据已知的密度泛函理论（DFT）计算不确定性对数据点进行适当加权，您将学会构建不仅具有预测性而且在统计上更可靠的模型。",
            "id": "3885858",
            "problem": "考虑在计算催化中拟合描述符能量与目标自由能之间的线性自由能关系 (LFER) 的任务，其中密度泛函理论 (DFT) 的预测在不同数据点上具有异质且已知的不确定性。假设一个线性模型 $y_i = \\alpha + \\beta x_i + \\varepsilon_i$，其误差 $\\varepsilon_i$ 是独立的，并服从高斯分布 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma_i^2)$，其标准差 $\\sigma_i$ 通过DFT不确定性量化方法得到并且是已知的。目标是使用加权最小二乘法 (WLS) 估计斜率 $\\beta$ (无量纲) 和截距 $\\alpha$ (单位为电子伏特 (eV))，并量化权重对参数估计和预测不确定性的影响。采用以下内容作为基本依据：独立观测值的高斯似然、用于线性估计器的高斯-马尔可夫定理，以及通过最小化加权残差平方和推导出的、经过充分检验的WLS估计量公式。\n\n您的程序必须实现以下协议：\n- 使用权重 $w_i = 1/\\sigma_i^2$。\n- 构建设计矩阵 $X$（其行为 $[1, x_i]$）和对角权重矩阵 $W = \\mathrm{diag}(w_i)$。\n- 通过求解 $(X^\\top W X)\\hat{\\theta} = X^\\top W \\mathbf{y}$ 来计算 WLS 估计量 $\\hat{\\theta} = [\\hat{\\alpha}, \\hat{\\beta}]^\\top$，其中 $y$ 是由 $y_i$ 组成的向量。\n- 计算参数协方差矩阵 $$\\mathrm{Cov}(\\hat{\\theta}) = (X^\\top W X)^{-1},$$ 该公式在权重 $w_i=1/\\sigma_i^2$ 且误差为方差是 $\\sigma_i^2$ 的独立高斯误差的假设下成立。\n- 提取标准误 $\\mathrm{SE}(\\hat{\\alpha})$ 和 $\\mathrm{SE}(\\hat{\\beta})$，其值为 $\\mathrm{Cov}(\\hat{\\theta})$ 对角线元素的平方根。\n- 对于一个指定的描述符 $x_0$，计算预测的自由能 $\\hat{y}_0 = \\hat{\\alpha} + \\hat{\\beta} x_0$ 及其标准误 $$\\mathrm{SE}(\\hat{y}_0) = \\sqrt{[1, x_0]\\ \\mathrm{Cov}(\\hat{\\theta})\\ [1, x_0]^\\top},$$ 此标准误仅捕获由参数估计产生的不确定性。报告 $\\hat{y}_0$（单位为电子伏特 (eV)）及其标准误（单位为电子伏特 (eV)）。\n\n所有能量都必须以电子伏特 (eV) 为单位处理。报告 $\\hat{\\alpha}$ 和 $\\hat{y}_0$（单位eV）；$\\hat{\\beta}$ 是无量纲的；$\\mathrm{SE}(\\hat{\\alpha})$ 和 $\\mathrm{SE}(\\hat{y}_0)$（单位eV）；$\\mathrm{SE}(\\hat{\\beta})$ 是无量纲的。答案值为浮点数。\n\n为以下测试套件实现上述过程。每个案例提供描述符能量 $\\{x_i\\}$（单位eV）、目标自由能 $\\{y_i\\}$（单位eV）和DFT不确定性标准差 $\\{\\sigma_i\\}$（单位eV）的数组。所有案例均使用相同的预测点 $x_0 = 0.60$ eV。\n\n测试套件：\n- 案例 A（来自DFT不确定性的方差倒数权重；异质噪声）：\n  - $x = [-0.20, 0.00, 0.25, 0.50, 0.80, 1.10]$\n  - $y = [0.2 + 0.8(-0.20) + 0.01, 0.2 + 0.8(0.00) - 0.02, 0.2 + 0.8(0.25) + 0.03, 0.2 + 0.8(0.50) - 0.04, 0.2 + 0.8(0.80) + 0.02, 0.2 + 0.8(1.10) - 0.06]$\n  - $\\sigma = [0.05, 0.05, 0.08, 0.10, 0.04, 0.12]$\n- 案例 B（不确定性相等；在WLS加权下简化为普通最小二乘法 (OLS)）：\n  - $x$ 和 $y$ 与案例 A 相同\n  - $\\sigma = [0.06, 0.06, 0.06, 0.06, 0.06, 0.06]$\n- 案例 C（一个高不确定性离群值；方差倒数权重降低其影响）：\n  - $x = [-0.20, 0.00, 0.25, 0.50, 0.80, 1.10, 1.50]$\n  - $y$ 的前六个点与案例 A 的值相等，且 $y_7 = 0.2 + 0.8(1.50) + 0.50$\n  - $\\sigma = [0.05, 0.05, 0.08, 0.10, 0.04, 0.12, 0.50]$\n- 案例 D（一个极度精确的点起主导作用；说明了在极端权重下的杠杆效应）：\n  - $x$ 和 $y$ 与案例 A 相同\n  - $\\sigma = [0.10, 0.10, 0.10, 0.10, 0.001, 0.10]$\n\n对于每个案例，计算并返回列表 $[\\hat{\\beta}, \\hat{\\alpha}, \\mathrm{SE}(\\hat{\\beta}), \\mathrm{SE}(\\hat{\\alpha}), \\hat{y}_0, \\mathrm{SE}(\\hat{y}_0)]$。您的程序应生成单行输出，其中包含这些按案例划分的列表的结果，以逗号分隔，无空格，并用方括号括起来，例如：[[b1,a1,se_b1,se_a1,y1,se_y1],[b2,a2,se_b2,se_a2,y2,se_y2],[b3,a3,se_b3,se_a3,y3,se_y3],[b4,a4,se_b4,se_a4,y4,se_y4]]。",
            "solution": "该问题要求实现加权最小二乘法 (WLS) 回归，以将线性模型拟合到具有已知、异质不确定性的数据。这是在STEM（科学、技术、工程和数学）领域分析实验和计算数据的一种标准且基础的技术，尤其是在物理、化学和工程学中，这些领域中的测量或计算不确定性通常是可量化的。该问题在科学上是有效的、良定的，并为确定性解提供了所有必要信息。\n\n问题的核心在于估计线性模型 $y_i = \\alpha + \\beta x_i + \\varepsilon_i$ 的参数，其中误差 $\\varepsilon_i$ 是独立的，服从正态分布 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma_i^2)$，且标准差 $\\sigma_i$ 已知。\n\n对于一组 $n$ 个数据点，该模型的矩阵形式写为：\n$$\n\\mathbf{y} = X\\theta + \\varepsilon\n$$\n其中 $\\mathbf{y} = [y_1, y_2, \\dots, y_n]^\\top$ 是目标自由能向量，$X$ 是 $n \\times 2$ 的设计矩阵，$\\theta = [\\alpha, \\beta]^\\top$ 是待估计的参数向量，$\\varepsilon = [\\varepsilon_1, \\varepsilon_2, \\dots, \\varepsilon_n]^\\top$ 是误差向量。设计矩阵 $X$ 的第 $i$ 行是 $[1, x_i]$，分别对应于截距 $\\alpha$ 和斜率 $\\beta$。\n\n误差是异方差的，意味着它们具有非均匀的方差。误差向量 $\\varepsilon$ 的协方差矩阵是一个对角矩阵 $\\Sigma = \\mathrm{diag}(\\sigma_1^2, \\sigma_2^2, \\dots, \\sigma_n^2)$。WLS方法通过最小化加权残差平方和来解决这个问题，其中每个残差都按其方差的倒数进行加权。需要最小化的目标函数是：\n$$\nS(\\theta) = \\sum_{i=1}^{n} w_i(y_i - (\\alpha + \\beta x_i))^2 = (\\mathbf{y} - X\\theta)^\\top W (\\mathbf{y} - X\\theta)\n$$\n最优权重是方差的倒数，$w_i = 1/\\sigma_i^2$。权重矩阵 $W$ 是误差协方差矩阵的逆，即 $W = \\Sigma^{-1} = \\mathrm{diag}(1/\\sigma_1^2, 1/\\sigma_2^2, \\dots, 1/\\sigma_n^2)$。\n\n为了找到最小化 $S(\\theta)$ 的参数向量 $\\hat{\\theta}$，我们将 $S(\\theta)$ 对 $\\theta$ 求导并令其为零。这就得出了WLS正规方程组：\n$$\n(X^\\top W X) \\hat{\\theta} = X^\\top W \\mathbf{y}\n$$\n这是一个关于估计量 $\\hat{\\theta} = [\\hat{\\alpha}, \\hat{\\beta}]^\\top$ 的线性方程组。其解由下式给出：\n$$\n\\hat{\\theta} = (X^\\top W X)^{-1} X^\\top W \\mathbf{y}\n$$\n\n估计量 $\\hat{\\theta}$ 的协方差矩阵是评估估计参数不确定性的一个关键量。在指定的模型假设下，即权重是真实的逆方差，协方差矩阵由下式给出：\n$$\n\\mathrm{Cov}(\\hat{\\theta}) = (X^\\top W X)^{-1}\n$$\n这个 $2 \\times 2$ 矩阵的对角元素是截距和斜率估计量的方差：$\\mathrm{Var}(\\hat{\\alpha}) = \\mathrm{Cov}(\\hat{\\theta})_{11}$ 和 $\\mathrm{Var}(\\hat{\\beta}) = \\mathrm{Cov}(\\hat{\\theta})_{22}$。标准误是这些方差的平方根：\n$$\n\\mathrm{SE}(\\hat{\\alpha}) = \\sqrt{\\mathrm{Cov}(\\hat{\\theta})_{11}} \\quad \\text{和} \\quad \\mathrm{SE}(\\hat{\\beta}) = \\sqrt{\\mathrm{Cov}(\\hat{\\theta})_{22}}\n$$\n注意索引约定取决于 $X$ 中的列顺序；此处，第一列对应于 $\\alpha$，第二列对应于 $\\beta$。\n\n最后，我们需要对新的描述符值 $x_0$ 进行预测并量化其不确定性。预测值 $\\hat{y}_0$ 为：\n$$\n\\hat{y}_0 = \\hat{\\alpha} + \\hat{\\beta} x_0 = \\mathbf{x}_0^\\top \\hat{\\theta}\n$$\n其中 $\\mathbf{x}_0 = [1, x_0]^\\top$。此预测中的不确定性源于估计参数 $\\hat{\\theta}$ 的不确定性。预测的方差使用线性变换的不确定性传播定律计算：\n$$\n\\mathrm{Var}(\\hat{y}_0) = \\mathrm{Var}(\\mathbf{x}_0^\\top \\hat{\\theta}) = \\mathbf{x}_0^\\top \\mathrm{Cov}(\\hat{\\theta}) \\mathbf{x}_0\n$$\n预测的标准误是该方差的平方根：\n$$\n\\mathrm{SE}(\\hat{y}_0) = \\sqrt{\\mathbf{x}_0^\\top \\mathrm{Cov}(\\hat{\\theta}) \\mathbf{x}_0}\n$$\n\n实现将首先为每个测试案例定义数据。然后，对于每个案例，我们将：\n1.  构建设计矩阵 $X$ 以及向量 $\\mathbf{y}$ 和 $\\boldsymbol{\\sigma}$。\n2.  计算权重 $w_i = 1/\\sigma_i^2$。\n3.  构造矩阵 $A = X^\\top W X$ 和向量 $\\mathbf{b} = X^\\top W \\mathbf{y}$。为提高计算效率，此操作使用数组广播完成，而不是显式构造大型对角矩阵 $W$。\n4.  求解线性系统 $A\\hat{\\theta} = \\mathbf{b}$ 以获得 $\\hat{\\theta} = [\\hat{\\alpha}, \\hat{\\beta}]^\\top$。\n5.  计算协方差矩阵 $\\mathrm{Cov}(\\hat{\\theta}) = A^{-1}$。\n6.  从 $\\hat{\\theta}$ 和 $\\mathrm{Cov}(\\hat{\\theta})$ 的对角线中提取参数估计值及其标准误。\n7.  为 $x_0 = 0.60$ eV 计算预测值 $\\hat{y}_0$ 及其标准误 $\\mathrm{SE}(\\hat{y}_0)$。\n8.  按指定顺序组合六个所需值：$[\\hat{\\beta}, \\hat{\\alpha}, \\mathrm{SE}(\\hat{\\beta}), \\mathrm{SE}(\\hat{\\alpha}), \\hat{y}_0, \\mathrm{SE}(\\hat{y}_0)]$。\n所有案例的结果将被收集并格式化为单个输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Weighted Least Squares problem for the given test cases.\n    \"\"\"\n\n    def calculate_wls(x: np.ndarray, y: np.ndarray, sigma: np.ndarray, x0: float) -> list[float]:\n        \"\"\"\n        Performs Weighted Least Squares (WLS) regression.\n\n        Args:\n            x: 1D array of descriptor energies.\n            y: 1D array of target free energies.\n            sigma: 1D array of DFT uncertainty standard deviations.\n            x0: The descriptor value for which to make a prediction.\n\n        Returns:\n            A list containing [beta_hat, alpha_hat, se_beta, se_alpha, y0_hat, se_y0].\n        \"\"\"\n        # Ensure inputs are numpy arrays\n        x = np.array(x, dtype=float)\n        y = np.array(y, dtype=float)\n        sigma = np.array(sigma, dtype=float)\n\n        # 1. Construct the design matrix X\n        n = len(x)\n        # First column is for the intercept (alpha), second is for the slope (beta)\n        X = np.vstack([np.ones(n), x]).T\n\n        # 2. Calculate weights w_i = 1/sigma_i^2\n        w = 1.0 / (sigma**2)\n\n        # 3. Compute X^T W X and X^T W y efficiently\n        # X.T * w broadcasts the weights to the rows of X.T\n        # (X^T W) = X.T @ diag(w) which is equivalent to X.T * w\n        X_T_W = X.T * w\n        A = X_T_W @ X  # This is the matrix (X^T W X)\n        b = X_T_W @ y  # This is the vector (X^T W y)\n\n        # 4. Solve the normal equations (X^T W X) * theta_hat = (X^T W y)\n        # theta_hat will be [alpha_hat, beta_hat]\n        try:\n            theta_hat = np.linalg.solve(A, b)\n        except np.linalg.LinAlgError:\n            # Handle cases where the matrix is singular, returning NaNs\n            return [np.nan] * 6\n        \n        alpha_hat = theta_hat[0]\n        beta_hat = theta_hat[1]\n\n        # 5. Compute the parameter covariance matrix Cov(theta_hat) = (X^T W X)^-1\n        try:\n            cov_theta = np.linalg.inv(A)\n        except np.linalg.LinAlgError:\n            # Handle cases where the matrix is singular after passing the solve step\n            return [beta_hat, alpha_hat, np.nan, np.nan, np.nan, np.nan]\n\n\n        # 6. Extract standard errors for alpha and beta\n        # The square roots of the diagonal elements of the covariance matrix\n        se_alpha = np.sqrt(cov_theta[0, 0])\n        se_beta = np.sqrt(cov_theta[1, 1])\n\n        # 7. Predict y0_hat for a new point x0\n        x0_vec = np.array([1.0, x0])\n        y0_hat = x0_vec @ theta_hat\n\n        # 8. Compute the standard error of the prediction\n        # SE(y0_hat) = sqrt(x0_vec^T * Cov(theta_hat) * x0_vec)\n        se_y0 = np.sqrt(x0_vec.T @ cov_theta @ x0_vec)\n\n        # 9. Return results in the specified order\n        return [beta_hat, alpha_hat, se_beta, se_alpha, y0_hat, se_y0]\n\n    # Define the test cases from the problem statement.\n    x0_pred = 0.60\n\n    # Common x and y components\n    x_base = [-0.20, 0.00, 0.25, 0.50, 0.80, 1.10]\n    y_base = [\n        0.2 + 0.8 * (-0.20) + 0.01,\n        0.2 + 0.8 * (0.00) - 0.02,\n        0.2 + 0.8 * (0.25) + 0.03,\n        0.2 + 0.8 * (0.50) - 0.04,\n        0.2 + 0.8 * (0.80) + 0.02,\n        0.2 + 0.8 * (1.10) - 0.06\n    ]\n\n    test_cases = [\n        # Case A\n        {'x': x_base, 'y': y_base, 'sigma': [0.05, 0.05, 0.08, 0.10, 0.04, 0.12]},\n        # Case B\n        {'x': x_base, 'y': y_base, 'sigma': [0.06] * 6},\n        # Case C\n        {\n            'x': x_base + [1.50],\n            'y': y_base + [0.2 + 0.8 * 1.50 + 0.50],\n            'sigma': [0.05, 0.05, 0.08, 0.10, 0.04, 0.12, 0.50]\n        },\n        # Case D\n        {'x': x_base, 'y': y_base, 'sigma': [0.10, 0.10, 0.10, 0.10, 0.001, 0.10]}\n    ]\n\n    results = []\n    for case in test_cases:\n        res = calculate_wls(case['x'], case['y'], case['sigma'], x0_pred)\n        results.append(f\"[{','.join(f'{v:.10f}' for v in res)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}