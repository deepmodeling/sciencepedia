{
    "hands_on_practices": [
        {
            "introduction": "在过渡态搜索算法中，一个核心思想是在所有稳定方向上最小化能量，同时避免沿不稳定的反应坐标方向“滑落”。这需要对优化步骤的方向进行精确控制。本练习将引导你掌握一项基本的线性代数技术——梯度投影，通过它分离并利用垂直于不稳定模式的梯度分量，从而实现受控的优化。",
            "id": "3903814",
            "problem": "给你一个二维势能面，旨在模拟一个具有一个不稳定模式和一个稳定模式的简单反应坐标，这是在计算催化和化学工程中定位过渡态的标准设置。考虑势能\n$$\nE(x,y) = (x^2 - 1)^2 + y^2,\n$$\n其位置向量为 $\\mathbf{r} = (x,y)$，梯度 $\\mathbf{g}(\\mathbf{r}) = \\nabla E(\\mathbf{r})$ 由常规微积分法则定义。点 $\\mathbf{r}_\\ddagger = (0,0)$ 是一个一阶鞍点（过渡态），极小值点位于 $\\mathbf{r}_{\\text{min},\\pm} = (\\pm 1, 0)$ 附近。在类似二聚体方法 (dimer-method-like) 的平移步骤中，通常需要通过移除沿不稳定模式的力或梯度的分量来防止沿该模式的运动，从而避免在更新二聚体中心时不希望发生的滑动。设 $\\hat{n}$ 表示一个方向向量，被认为是当前迭代点不稳定模式（最低曲率方向）的当前估计，在使用前要求 $\\hat{n}$ 为单位长度。本问题中的所有值均为无量纲数。\n\n从以下基本基础开始：\n- 梯度由 $\\mathbf{g}(\\mathbf{r}) = \\nabla E(\\mathbf{r})$ 定义，对于任意向量 $\\mathbf{a}$ 和 $\\mathbf{b}$，点积为 $\\mathbf{a}\\cdot\\mathbf{b}$。\n- 使用线性代数和内积的性质，一个向量可以分解为与一个单位向量平行和正交的分量。\n- 一个单一的显式欧拉更新步可以写成 $\\mathbf{r}_{\\text{next}} = \\mathbf{r} + \\Delta \\mathbf{r}$，其中有选定的步长参数 $\\alpha$ 和选定的更新方向。\n\n你的任务：\n1. 从线性代数的第一性原理出发，推导一个方案，该方案移除 $\\mathbf{g}$ 平行于 $\\hat{n}$ 的分量，只留下与 $\\hat{n}$ 正交的分量。使用此正交分量来定义一个不沿 $\\hat{n}$ 移动的平移更新步。在使用前明确确保 $\\hat{n}$ 是归一化的。\n2. 在一个程序中实现你的方案，该程序应用单个平移步 $\\Delta \\mathbf{r} = -\\alpha \\,\\mathbf{g}_{\\perp}$，其中 $\\mathbf{g}_{\\perp}$ 表示 $\\mathbf{g}$ 与 $\\hat{n}$ 正交的分量，$\\alpha$ 是一个正常数。通过检查 $|\\Delta \\mathbf{r}\\cdot \\hat{n}| \\le \\tau$（其中 $\\tau$ 是一个很小的容差）来数值验证更新步不会改变沿 $\\hat{n}$ 的坐标。\n3. 通过证明使用非单位向量 $\\hat{n}$ 但在内部进行归一化，与使用已经归一化的 $\\hat{n}$ 得到相同的更新步，来验证 $\\hat{n}$ 的归一化是必不可少的。\n4. 通过在鞍点附近沿 $+\\hat{n}$ 和 $-\\hat{n}$ 两个方向启动最速下降动力学，构建一个简单的内禀反应坐标（IRC）验证。具体来说，形成两个初始点 $\\mathbf{r}_0^{(+)} = \\mathbf{r}_\\ddagger + \\epsilon \\,\\hat{n}$ 和 $\\mathbf{r}_0^{(-)} = \\mathbf{r}_\\ddagger - \\epsilon \\,\\hat{n}$，其中 $\\epsilon$ 很小，然后对于固定的迭代次数 $N$ 和一个小的步长 $\\eta$，迭代 $\\mathbf{r}_{k+1} = \\mathbf{r}_k - \\eta\\,\\mathbf{g}(\\mathbf{r}_k)$。报告最终距离 $d_+ = \\|\\mathbf{r}_N^{(+)} - \\mathbf{r}_{\\text{min},+}\\|_2$ 和 $d_- = \\|\\mathbf{r}_N^{(-)} - \\mathbf{r}_{\\text{min},-}\\|_2$，其中 $\\|\\cdot\\|_2$ 是欧几里得范数，以展示沿IRC分支朝向相应极小值点的流动。\n\n测试套件和参数：\n- 使用势能 $E(x,y) = (x^2 - 1)^2 + y^2$ 及其由微积分推导出的精确解析梯度。\n- 选择 $\\hat{n} = (1,0)$ 来表示靠近 $\\mathbf{r}_\\ddagger$ 的不稳定方向。\n- 使用步长参数 $\\alpha = 0.1$ 和容差 $\\tau = 10^{-12}$。\n- 对于IRC，使用 $\\epsilon = 10^{-3}$，步长 $\\eta = 0.01$，以及迭代次数 $N = 1000$。\n\n定义以下具体测试用例：\n- 用例 $A$：$\\mathbf{r} = (0.1, 0.2)$，$\\hat{n} = (1,0)$。报告一个布尔值，指示在一次投影平移步骤后是否满足 $|\\Delta \\mathbf{r}\\cdot \\hat{n}| \\le \\tau$。\n- 用例 $B$：$\\mathbf{r} = (0.1, 0.0)$，$\\hat{n} = (1,0)$。报告一个布尔值，指示投影更新方向是否在容差范围内为零向量（梯度平行于 $\\hat{n}$，因此正交分量应为零）。\n- 用例 $C$：$\\mathbf{r} = (0.1, 0.2)$，比较使用 $\\hat{n} = (1,0)$ 和使用带有内部归一化的非单位方向 $\\hat{n}_{\\text{nonunit}} = (3,0)$ 所获得的更新步；报告一个布尔值，指示两者在容差 $\\tau$ 内是否相等。\n- 用例 $D$：从 $\\mathbf{r}_\\ddagger = (0,0)$ 沿 $+\\hat{n}$，使用给定的 $\\epsilon$、$\\eta$ 和 $N$ 进行IRC。报告到 $\\mathbf{r}_{\\text{min},+} = (1,0)$ 的最终距离 $d_+$，四舍五入到 $6$ 位小数。\n- 用例 $E$：从 $\\mathbf{r}_\\ddagger = (0,0)$ 沿 $-\\hat{n}$，使用给定的 $\\epsilon$、$\\eta$ 和 $N$ 进行IRC。报告到 $\\mathbf{r}_{\\text{min},-} = (-1,0)$ 的最终距离 $d_-$，四舍五入到 $6$ 位小数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，`[result1,result2,result3,result4,result5]`）。前三个条目必须是用于用例 $A$、$B$ 和 $C$ 的布尔值，最后两个条目必须是用于 $d_+$ 和 $d_-$ 的浮点数，四舍五入到 $6$ 位小数。所有值都是无量纲的。",
            "solution": "问题陈述已经过仔细验证，并被确定为有效。它在科学上基于计算化学和势能面分析的原理，设定良好，提供了所有必要的数据和条件，并以客观、正式的语言表述。这些任务与定位和验证过渡态的标准数值技术直接相关，例如二聚体方法 (dimer method) 和内禀反应坐标 (Intrinsic Reaction Coordinate, IRC) 跟踪。因此，我们可以进行完整解答。\n\n势能面由 $E(x,y) = (x^2 - 1)^2 + y^2$ 给出。该势能的梯度，即力的负值，是 $\\mathbf{g}(\\mathbf{r}) = \\nabla E(\\mathbf{r}) = (4x(x^2 - 1), 2y)$，其中 $\\mathbf{r} = (x,y)$。点 $\\mathbf{r}_\\ddagger = (0,0)$ 是一个一阶鞍点，代表过渡态。\n\n**1. 投影梯度平移步的推导**\n\n第一个任务是推导一个平移更新方案，该方案沿给定方向 $\\hat{n}$ 的正交方向移动，其中 $\\hat{n}$ 代表估计的不稳定模式。这通过将梯度向量 $\\mathbf{g}$ 投影到与 $\\hat{n}$ 正交的子空间来实现。\n\n根据线性代数的原理，任何向量 $\\mathbf{g}$ 都可以分解为两个正交分量：一个与单位向量 $\\hat{n}$ 平行，另一个与其垂直。这表示为 $\\mathbf{g} = \\mathbf{g}_{\\|} + \\mathbf{g}_{\\perp}$。\n\n$\\mathbf{g}$ 平行于 $\\hat{n}$ 的分量，记作 $\\mathbf{g}_{\\|}$，是通过将 $\\mathbf{g}$ 投影到 $\\hat{n}$ 上找到的。此投影的公式为：\n$$\n\\mathbf{g}_{\\|} = (\\mathbf{g} \\cdot \\hat{n}) \\hat{n}\n$$\n这个公式的前提是 $\\hat{n}$ 是一个单位向量，即 $\\|\\hat{n}\\| = 1$。如果提供的是一个非单位向量 $\\mathbf{n}$，必须首先对其进行归一化：$\\hat{n} = \\frac{\\mathbf{n}}{\\|\\mathbf{n}\\|}$。\n\n$\\mathbf{g}$ 与 $\\hat{n}$ 正交的分量，记作 $\\mathbf{g}_{\\perp}$，则通过从原始向量中减去平行分量获得：\n$$\n\\mathbf{g}_{\\perp} = \\mathbf{g} - \\mathbf{g}_{\\|} = \\mathbf{g} - (\\mathbf{g} \\cdot \\hat{n}) \\hat{n}\n$$\n这个向量 $\\mathbf{g}_{\\perp}$ 包含了梯度中所有不沿方向 $\\hat{n}$ 的分量。在类似二聚体方法的平移背景下，使用基于 $-\\mathbf{g}_{\\perp}$ 的力可确保步进被限制在与估计的不稳定模式正交的空间中，从而防止系统沿反应坐标下滑。\n\n因此，使用步长参数 $\\alpha > 0$ 并沿投影梯度的反方向移动的平移更新步 $\\Delta \\mathbf{r}$ 定义为：\n$$\n\\Delta \\mathbf{r} = -\\alpha \\mathbf{g}_{\\perp} = -\\alpha \\left( \\mathbf{g} - (\\mathbf{g} \\cdot \\hat{n}) \\hat{n} \\right)\n$$\n下一个位置则通过显式欧拉步更新：$\\mathbf{r}_{\\text{next}} = \\mathbf{r} + \\Delta \\mathbf{r}$。\n\n**2. 正交性的数值验证**\n\n对于用例 A，给定 $\\mathbf{r} = (0.1, 0.2)$ 和 $\\hat{n} = (1,0)$，后者是一个单位向量。步长参数为 $\\alpha = 0.1$。首先，我们计算 $\\mathbf{r}$ 处的梯度：\n$$\n\\mathbf{g}(0.1, 0.2) = (4(0.1)((0.1)^2 - 1), 2(0.2)) = (0.4(0.01 - 1), 0.4) = (-0.396, 0.4)\n$$\n接下来，我们计算梯度与 $\\hat{n}$ 正交的分量：\n$$\n\\mathbf{g} \\cdot \\hat{n} = (-0.396, 0.4) \\cdot (1,0) = -0.396\n$$\n$$\n\\mathbf{g}_{\\perp} = \\mathbf{g} - (\\mathbf{g} \\cdot \\hat{n}) \\hat{n} = (-0.396, 0.4) - (-0.396)(1,0) = (-0.396, 0.4) - (-0.396, 0) = (0, 0.4)\n$$\n更新步则为：\n$$\n\\Delta \\mathbf{r} = -\\alpha \\mathbf{g}_{\\perp} = -0.1 \\cdot (0, 0.4) = (0, -0.04)\n$$\n为了验证此步与 $\\hat{n}$ 正交，我们计算它们的点积：\n$$\n\\Delta \\mathbf{r} \\cdot \\hat{n} = (0, -0.04) \\cdot (1,0) = 0\n$$\n由于 $|0| \\le \\tau$ 对于 $\\tau = 10^{-12}$ 成立，条件 $|\\Delta \\mathbf{r} \\cdot \\hat{n}| \\le \\tau$ 得到满足。这证实了该步骤不会沿方向 $\\hat{n}$ 移动。\n\n对于用例 B，当 $\\mathbf{r} = (0.1, 0.0)$ 且 $\\hat{n} = (1,0)$ 时，梯度为：\n$$\n\\mathbf{g}(0.1, 0.0) = (4(0.1)((0.1)^2 - 1), 2(0.0)) = (-0.396, 0)\n$$\n在这种情况下，梯度向量 $\\mathbf{g}$ 与 $\\hat{n}$ 完全平行。$\\mathbf{g}$ 在 $\\hat{n}$ 上的投影就是 $\\mathbf{g}$ 本身。因此，正交分量 $\\mathbf{g}_{\\perp} = \\mathbf{g} - \\mathbf{g}$ 必须是零向量 $\\mathbf{0} = (0,0)$。该向量的模长为 $0$，这在任何合理的数值容差范围内都可视为零。\n\n**3. 归一化的验证**\n\n对于用例 C，我们被要求比较使用 $\\hat{n} = (1,0)$ 与使用一个非单位向量 $\\mathbf{n}_{\\text{nonunit}} = (3,0)$（内部进行归一化）时，对 $\\mathbf{r} = (0.1, 0.2)$ 的更新步。\n从用例 A 中，我们已经得到使用 $\\hat{n} = (1,0)$ 的更新步为 $\\Delta \\mathbf{r} = (0, -0.04)$。\n现在，让我们使用 $\\mathbf{n}_{\\text{nonunit}} = (3,0)$。首先，我们必须对其进行归一化：\n$$\n\\|\\mathbf{n}_{\\text{nonunit}}\\| = \\sqrt{3^2 + 0^2} = 3\n$$\n$$\n\\hat{n}' = \\frac{\\mathbf{n}_{\\text{nonunit}}}{\\|\\mathbf{n}_{\\text{nonunit}}\\|} = \\frac{(3,0)}{3} = (1,0)\n$$\n得到的归一化向量 $\\hat{n}'$ 与原始单位向量 $\\hat{n}$ 相同。因此，所有后续对 $\\mathbf{g}_{\\perp}$ 和 $\\Delta \\mathbf{r}$ 的计算都将得出完全相同的结果。更新步为 $\\Delta \\mathbf{r}' = (0, -0.04)$。两个更新步之间的差异是 $\\|\\Delta \\mathbf{r} - \\Delta \\mathbf{r}'\\| = \\|(0,0)\\| = 0$，小于容差 $\\tau = 10^{-12}$。这表明归一化是投影操作中一个关键且不变的部分。\n\n**4. 内禀反应坐标（IRC）验证**\n\n最后的任务是验证 $\\hat{n} = (1,0)$ 确实代表了鞍点 $\\mathbf{r}_\\ddagger = (0,0)$ 处的不稳定模式方向。这通过从沿 $\\pm \\hat{n}$ 方向从鞍点轻微位移的点开始进行最速下降动力学，并观察它们是否弛豫到正确的反应物/产物极小值点来完成。\n\n迭代方案为 $\\mathbf{r}_{k+1} = \\mathbf{r}_k - \\eta\\,\\mathbf{g}(\\mathbf{r}_k)$，进行 $N=1000$ 步，步长为 $\\eta=0.01$。极小值点位于 $\\mathbf{r}_{\\text{min},+} = (1,0)$ 和 $\\mathbf{r}_{\\text{min},-} = (-1,0)$。\n\n对于用例 D，起始点为 $\\mathbf{r}_0^{(+)} = \\mathbf{r}_\\ddagger + \\epsilon \\,\\hat{n} = (0,0) + 10^{-3}(1,0) = (10^{-3}, 0)$。从该点开始的动力学预计将向位于 $\\mathbf{r}_{\\text{min},+}$ 的极小值点演化。在 $N$ 次迭代后，计算最终位置 $\\mathbf{r}_N^{(+)}$，并计算到极小值点的最终距离为 $d_+ = \\|\\mathbf{r}_N^{(+)} - \\mathbf{r}_{\\text{min},+}\\|_2$。\n\n对于用例 E，起始点为 $\\mathbf{r}_0^{(-)} = \\mathbf{r}_\\ddagger - \\epsilon \\,\\hat{n} = (0,0) - 10^{-3}(1,0) = (-10^{-3}, 0)$。对称地，这些动力学应向位于 $\\mathbf{r}_{\\text{min},-}$ 的极小值点演化。最终距离计算为 $d_- = \\|\\mathbf{r}_N^{(-)} - \\mathbf{r}_{\\text{min},-}\\|_2$。\n\n数值实现将表明，距离 $d_+$ 和 $d_-$ 都非常小，证实了沿 $\\pm \\hat{n}$ 的初始位移正确地引导系统沿着IRC的两个分支到达各自的势阱。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not used as per the problem constraints.\n\ndef solve():\n    \"\"\"\n    Solves the problem by performing calculations for the five test cases\n    related to potential energy surface analysis, gradient projection,\n    and Intrinsic Reaction Coordinate (IRC) validation.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    alpha = 0.1  # Step parameter for translation\n    tau = 1e-12  # Numerical tolerance\n    epsilon = 1e-3  # Displacement for IRC\n    eta = 0.01  # Step size for IRC steepest descent\n    N = 1000  # Number of iterations for IRC\n\n    # --- Potential Energy Surface and Gradient Definition ---\n    def potential_gradient(r: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculates the gradient of the potential E(x,y) = (x^2 - 1)^2 + y^2.\n        g(r) = nabla E(r)\n        \n        Args:\n            r: A numpy array [x, y] representing the position.\n\n        Returns:\n            A numpy array representing the gradient [dE/dx, dE/dy].\n        \"\"\"\n        x, y = r\n        grad_x = 4.0 * x * (x**2 - 1.0)\n        grad_y = 2.0 * y\n        return np.array([grad_x, grad_y])\n\n    # --- Case A ---\n    # Check if a projected translation step is orthogonal to the unstable mode direction.\n    r_A = np.array([0.1, 0.2])\n    n_hat_A = np.array([1.0, 0.0])  # Already a unit vector\n    g_A = potential_gradient(r_A)\n    g_perp_A = g_A - np.dot(g_A, n_hat_A) * n_hat_A\n    delta_r_A = -alpha * g_perp_A\n    dot_product_A = np.dot(delta_r_A, n_hat_A)\n    result_A = abs(dot_product_A) = tau\n\n    # --- Case B ---\n    # Check if the projected gradient is zero when the gradient is parallel to n_hat.\n    r_B = np.array([0.1, 0.0])\n    n_hat_B = np.array([1.0, 0.0])\n    g_B = potential_gradient(r_B)\n    g_perp_B = g_B - np.dot(g_B, n_hat_B) * n_hat_B\n    result_B = np.linalg.norm(g_perp_B) = tau\n\n    # --- Case C ---\n    # Validate that internal normalization of a non-unit vector yields the same update step.\n    r_C = np.array([0.1, 0.2])\n    # Step with unit vector (re-using calculation from A)\n    delta_r_C_unit = delta_r_A\n    \n    # Step with non-unit vector that requires normalization\n    n_nonunit_C = np.array([3.0, 0.0])\n    n_hat_C_normalized = n_nonunit_C / np.linalg.norm(n_nonunit_C)\n    g_C = potential_gradient(r_C)\n    g_perp_C = g_C - np.dot(g_C, n_hat_C_normalized) * n_hat_C_normalized\n    delta_r_C_nonunit = -alpha * g_perp_C\n    \n    # Compare the two update vectors\n    result_C = np.linalg.norm(delta_r_C_unit - delta_r_C_nonunit) = tau\n\n    # --- Case D ---\n    # IRC validation for the +n_hat branch.\n    r_saddle = np.array([0.0, 0.0])\n    r_min_plus = np.array([1.0, 0.0])\n    n_hat_D = np.array([1.0, 0.0])\n    \n    r_current_plus = r_saddle + epsilon * n_hat_D\n    for _ in range(N):\n        grad = potential_gradient(r_current_plus)\n        r_current_plus = r_current_plus - eta * grad\n        \n    d_plus = np.linalg.norm(r_current_plus - r_min_plus)\n    result_D = f\"{d_plus:.6f}\"\n\n    # --- Case E ---\n    # IRC validation for the -n_hat branch.\n    r_min_minus = np.array([-1.0, 0.0])\n    n_hat_E = np.array([1.0, 0.0]) # same direction vector\n    \n    r_current_minus = r_saddle - epsilon * n_hat_E\n    for _ in range(N):\n        grad = potential_gradient(r_current_minus)\n        r_current_minus = r_current_minus - eta * grad\n        \n    d_minus = np.linalg.norm(r_current_minus - r_min_minus)\n    result_E = f\"{d_minus:.6f}\"\n    \n    # --- Final Output ---\n    # Collect results and format the output string.\n    results = [\n        str(result_A).lower(),\n        str(result_B).lower(),\n        str(result_C).lower(),\n        result_D,\n        result_E\n    ]\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本的矢量操作之后，我们现在可以将这些构件组装成一套完整的过渡态定位与验证算法。本实践将指导你在一个模型势能面上，从第一性原理出发，构建寻找鞍点的 Dimer 方法，并执行内禀反应坐标（IRC）计算，以验证它连接了预期的反应物和产物。",
            "id": "3903835",
            "problem": "考虑一个由标量场 $E:\\mathbb{R}^2\\to\\mathbb{R}$ 定义的二维势能面，其表达式为 $E(x,y)=x^4-x^2+y^2$。在计算催化中，过渡态的特征是一个驻点，该点在一个方向上具有负曲率，而在所有其他方向上具有正曲率，即一个梯度为零且Hessian矩阵恰好有一个负特征值的一阶鞍点。内禀反应坐标（IRC）定义为在质量加权坐标中，从过渡态沿Hessian矩阵的不稳定特征向量方向出发的最速下降路径。\n\n您的任务是，从第一性原理出发，实现一个数值程序来：\n- 从给定的初始位置和朝向开始，使用dimer方法定位 $x=0$ 附近的过渡态。\n- 从过渡态出发，在质量加权坐标系下（假设所有坐标的质量均为单位质量），使用最速下降积分，沿两个方向执行IRC。\n- 验证所定位到的极小值点在指定的容差范围内位于 $x=\\pm 1/\\sqrt{2}$ 和 $y=0$。\n\n请使用以下基本原理，不要引入任何快捷公式：\n- 标量场 $E(x,y)$ 的梯度为 $\\nabla E(x,y)=\\left(\\frac{\\partial E}{\\partial x},\\frac{\\partial E}{\\partial y}\\right)$。\n- $E(x,y)$ 的Hessian矩阵是二阶偏导数矩阵 $$H(x,y)=\\begin{pmatrix}\\frac{\\partial^2 E}{\\partial x^2}  \\frac{\\partial^2 E}{\\partial x y}\\\\ \\frac{\\partial^2 E}{\\partial y x}  \\frac{\\partial^2 E}{\\partial y^2}\\end{pmatrix}$$。\n- 驻点满足 $\\nabla E(x,y)=\\mathbf{0}$。\n- 一阶鞍点（过渡态）的Hessian矩阵有一个负特征值和一个正特征值。\n- 最速下降法使用 $-\\nabla E$ 方向朝能量更低处移动。\n\n请按以下方式从概念上实现dimer方法，仅使用上述基本定义：维持一个中心为 $\\mathbf{R}\\in\\mathbb{R}^2$、单位朝向向量为 $\\mathbf{v}\\in\\mathbb{R}^2$、由一个微小标量 $\\delta0$ 分隔的dimer。使用梯度的计算值来估计沿 $\\mathbf{v}$ 方向的局部曲率，并将 $\\mathbf{v}$ 旋转至最小曲率方向。使用一个有效力来平移 $\\mathbf{R}$，该力旨在沿最小曲率方向爬升，同时在所有正交方向下降。迭代直至旋转驱动项和有效力的量值满足收敛判据。\n\n对于IRC，从定位到的过渡态 $\\mathbf{R}_\\text{TS}$ 开始，确定 $\\mathbf{R}_\\text{TS}$ 处Hessian矩阵的不稳定特征向量，沿该特征向量的 $\\pm$ 方向移动一个微小量 $\\epsilon0$ 以获得两个起始点，然后在质量加权坐标（单位质量）下使用固定步长的显式格式对最速下降动力学方程 $\\frac{d\\mathbf{q}}{ds}=-\\nabla E(\\mathbf{q})$ 进行积分，直到满足基于梯度范数的停止判据或达到最大步数。\n\n任何朝向指定均使用弧度。所有量均为无量纲量。对于验证，将期望的极小值点视为 $\\mathbf{q}_\\text{min}^\\pm=(\\pm 1/\\sqrt{2},0)$。\n\n您的程序必须处理以下参数集的测试套件。每个参数集是一个元组，指定了：\n- 初始dimer中心 $(x_0,y_0)$。\n- 初始dimer朝向角 $\\theta$（以弧度为单位），其中单位向量为 $\\mathbf{v}_0=(\\cos\\theta,\\sin\\theta)$。\n- Dimer间距 $\\delta$。\n- 旋转步长 $\\alpha_\\text{rot}$。\n- 平移步长 $\\alpha_\\text{trans}$。\n- Dimer最大迭代次数 $N_\\text{dimer}$。\n- Dimer收敛容差 $\\tau_\\text{dimer}$。\n- IRC初始位移大小 $\\epsilon$。\n- IRC步长 $\\alpha_\\text{irc}$。\n- IRC最大步数 $N_\\text{irc}$。\n- IRC收敛容差 $\\tau_\\text{irc}$。\n- 验证容差 $\\tau_\\text{verify}$。\n\n使用此测试套件：\n1. `((0.3,0.2), 0.5, 1e-2, 0.3, 0.05, 800, 1e-9, 1e-3, 0.08, 5000, 1e-9, 1e-3)`\n2. `((0.6,-0.4), 1.2, 1e-4, 0.5, 0.03, 1200, 1e-10, 1e-4, 0.06, 7000, 1e-10, 1e-3)`\n3. `((1.2,1.2), 2.0, 5e-3, 0.3, 0.02, 2000, 1e-9, 1e-3, 0.06, 10000, 1e-9, 1e-3)`\n\n对于每个参数集，您的程序必须：\n- 应用dimer方法定位 $\\mathbf{R}_\\text{TS}$ 和收敛时的相关朝向 $\\mathbf{v}$。\n- 计算 $\\mathbf{R}_\\text{TS}$ 处的Hessian特征值，并检查是否恰好一个为负、一个为正。\n- 使用不稳定特征向量的 $\\pm$ 方向执行双向IRC，并获得终点 $\\mathbf{q}_\\text{min}^{(+)}$ 和 $\\mathbf{q}_\\text{min}^{(-)}$。\n- 验证 $\\|\\mathbf{R}_\\text{TS}-\\mathbf{0}\\|_2\\le \\tau_\\text{verify}$，Hessian矩阵的特征值符号为一个负一个正，并且两个极小值点都满足 $\\|\\mathbf{q}_\\text{min}^{(+)}-(1/\\sqrt{2},0)\\|_2\\le \\tau_\\text{verify}$ 和 $\\|\\mathbf{q}_\\text{min}^{(-)}-(-1/\\sqrt{2},0)\\|_2\\le \\tau_\\text{verify}$。\n\n每个测试用例的结果必须是一个包含三个布尔值的列表 $[b_\\text{TS},b_\\text{eig},b_\\text{min}]$，分别表示过渡态位置、Hessian特征值符号和极小值点验证是否通过。您的程序应生成一行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，`[[True,True,True],[False,True,False],[True,True,True]]`）。",
            "solution": "该问题要求在一个给定的二维势能面 $E(x,y)$ 上，通过数值方法实现dimer方法来定位过渡态（TS），并使用内禀反应坐标（IRC）方法来描绘反应路径。该解决方案必须从第一性原理构建，利用所提供的梯度和Hessian矩阵的定义。\n\n势能面由函数 $E:\\mathbb{R}^2 \\to \\mathbb{R}$ 定义：\n$$E(x,y) = x^4 - x^2 + y^2$$\n\n为了实现所需的数值方法，我们首先推导出梯度向量 $\\nabla E$ 和Hessian矩阵 $H$ 的解析表达式。\n\n$E(x,y)$ 的梯度为：\n$$\\nabla E(x,y) = \\left( \\frac{\\partial E}{\\partial x}, \\frac{\\partial E}{\\partial y} \\right) = (4x^3 - 2x, 2y)$$\n\n$E(x,y)$ 的Hessian矩阵是二阶偏导数矩阵：\n$$H(x,y) = \\begin{pmatrix} \\frac{\\partial^2 E}{\\partial x^2}  \\frac{\\partial^2 E}{\\partial x \\partial y} \\\\ \\frac{\\partial^2 E}{\\partial y \\partial x}  \\frac{\\partial^2 E}{\\partial y^2} \\end{pmatrix} = \\begin{pmatrix} 12x^2 - 2  0 \\\\ 0  2 \\end{pmatrix}$$\n过渡态是一个一阶鞍点，其中 $\\nabla E = \\mathbf{0}$ 且Hessian矩阵恰好有一个负特征值。对于给定的势能面，点 $(0,0)$ 是一个驻点。该点的Hessian矩阵为 $H(0,0) = \\begin{pmatrix} -2  0 \\\\ 0  2 \\end{pmatrix}$，其特征值为 $-2$ 和 $2$。这证实了原点是我们所寻找的过渡态。极小值点位于 $(\\pm 1/\\sqrt{2}, 0)$，在这些点上Hessian矩阵的特征值均为正。\n\n整个过程包括三个主要阶段：\n1.  使用dimer方法定位过渡态。\n2.  通过分析过渡态的Hessian矩阵来表征它。\n3.  从过渡态追踪到相邻极小值点的内禀反应坐标（IRC）。\n\n**1. 用于过渡态搜索的Dimer方法**\n\nDimer方法是一种迭代算法，用于寻找鞍点而无需知道Hessian矩阵。它维护一个“dimer”，由一个中心点 $\\mathbf{R}$ 和两个端点 $\\mathbf{R}_1$ 和 $\\mathbf{R}_2$ 组成，这两个端点沿单位朝向向量 $\\mathbf{v}$ 分隔一个小距离 $\\delta$：\n$$\\mathbf{R}_1 = \\mathbf{R} - \\frac{\\delta}{2}\\mathbf{v} \\quad \\text{和} \\quad \\mathbf{R}_2 = \\mathbf{R} + \\frac{\\delta}{2}\\mathbf{v}$$\n\n该算法迭代执行两个主要操作：旋转dimer的朝向 $\\mathbf{v}$ 和平移其中心 $\\mathbf{R}$。\n\n**旋转：** 朝向 $\\mathbf{v}$ 被旋转以与局部最小曲率方向对齐。该方向是使用dimer端点处的力（负梯度）$\\mathbf{F}_1 = -\\nabla E(\\mathbf{R}_1)$ 和 $\\mathbf{F}_2 = -\\nabla E(\\mathbf{R}_2)$ 来估计的。驱动此旋转的旋转力 $\\mathbf{F}_R$ 是力差 $(\\mathbf{F}_1 - \\mathbf{F}_2)$ 垂直于dimer轴 $\\mathbf{v}$ 的分量：\n$$\\mathbf{F}_R = (\\mathbf{F}_1 - \\mathbf{F}_2) - [(\\mathbf{F}_1 - \\mathbf{F}_2) \\cdot \\mathbf{v}]\\mathbf{v}$$\n一个非零的 $\\mathbf{F}_R$ 表明 $\\mathbf{v}$ 未与局部Hessian矩阵的特征向量对齐。通过混入 $\\mathbf{F}_R$ 的方向并重新归一化来更新朝向向量：\n$$\\mathbf{v}_{\\text{new-unnormalized}} = \\mathbf{v} + \\alpha_{\\text{rot}} \\frac{\\mathbf{F}_R}{\\|\\mathbf{F}_R\\|_2}$$\n$$\\mathbf{v}_{\\text{new}} = \\frac{\\mathbf{v}_{\\text{new-unnormalized}}}{\\|\\mathbf{v}_{\\text{new-unnormalized}}\\|_2}$$\n如果 $\\|\\mathbf{F}_R\\|_2 = 0$，则跳过此步骤。\n\n**平移：** 中心 $\\mathbf{R}$ 向鞍点移动。这需要沿最小曲率模式（由 $\\mathbf{v}$ 近似）上坡移动，并在所有正交方向下坡移动。这通过使用一个有效力 $\\mathbf{F}_{\\text{eff}}$ 来实现。首先，计算中心处的力 $\\mathbf{F}_{\\text{cen}} = -\\nabla E(\\mathbf{R})$。然后，将其平行于 $\\mathbf{v}$ 的分量反转，同时保留垂直分量：\n$$\\mathbf{F}_{\\text{eff}} = \\mathbf{F}_{\\text{cen}} - 2 (\\mathbf{F}_{\\text{cen}} \\cdot \\mathbf{v})\\mathbf{v}$$\n然后，dimer中心沿此有效力的方向移动一个大小为 $\\alpha_{\\text{trans}}$ 的固定步长：\n$$\\mathbf{R}_{\\text{new}} = \\mathbf{R} + \\alpha_{\\text{trans}} \\frac{\\mathbf{F}_{\\text{eff}}}{\\|\\mathbf{F}_{\\text{eff}}\\|_2}$$\n如果 $\\|\\mathbf{F}_{\\text{eff}}\\|_2 = 0$，则跳过此步骤。\n\n**收敛：** 旋转和平移的迭代持续进行，直到有效力的量值 $\\|\\mathbf{F}_{\\text{eff}}\\|_2  \\tau_{\\text{dimer}}$，或达到最大迭代次数 $N_{\\text{dimer}}$。在鞍点处，真实力为零，因此 $\\mathbf{F}_{\\text{eff}}$ 也应为零。\n\n**2. 过渡态验证**\n\n一旦dimer方法收敛到点 $\\mathbf{R}_{\\text{TS}}$，我们便验证其属性。\n- **位置：** 我们通过计算 $\\|\\mathbf{R}_{\\text{TS}}\\|_2 \\le \\tau_{\\text{verify}}$ 来检查TS是否在期望的位置 $\\mathbf{0}$。\n- **曲率：** 我们计算Hessian矩阵 $H(\\mathbf{R}_{\\text{TS}})$ 及其特征值。一个有效的一阶鞍点必须恰好有一个负特征值和一个正特征值（对于2D系统）。与负特征值对应的特征向量 $\\mathbf{u}$ 定义了沿反应路径的不稳定模式。\n\n**3. 内禀反应坐标（IRC）追踪**\n\nIRC路径表示连接TS与反应物和产物（局部极小值点）的最小能量路径。它是从TS出发的最速下降路径。\n- **初始化：** 启动两个独立的IRC计算，分别对应不稳定模式的两个方向。通过沿不稳定特征向量 $\\mathbf{u}$ 将TS移动一个微小量 $\\epsilon$ 来生成起始点：\n$$\\mathbf{q}_0^{(+)} = \\mathbf{R}_{\\text{TS}} + \\epsilon \\mathbf{u} \\quad \\text{和} \\quad \\mathbf{q}_0^{(-)} = \\mathbf{R}_{\\text{TS}} - \\epsilon \\mathbf{u}$$\n- **积分：** 从每个起始点开始，执行最速下降优化。这通过积分方程 $\\frac{d\\mathbf{q}}{ds} = -\\nabla E(\\mathbf{q})$ 来追踪路径。我们使用固定步长的显式欧拉格式：\n$$\\mathbf{q}_{k+1} = \\mathbf{q}_k - \\alpha_{\\text{irc}} \\nabla E(\\mathbf{q}_k)$$\n- **终止：** 当梯度的范数 $\\|\\nabla E(\\mathbf{q})\\|_2  \\tau_{\\text{irc}}$，或达到最大步数 $N_{\\text{irc}}$ 时，每条路径的积分停止。最终点 $\\mathbf{q}_{\\text{min}}^{(+)}$ 和 $\\mathbf{q}_{\\text{min}}^{(-)}$ 即为定位到的极小值点。\n- **极小值点验证：** 将定位到的极小值点与位于 $(\\pm 1/\\sqrt{2}, 0)$ 的解析极小值点进行比较。由于特征向量 $\\mathbf{u}$ 的符号是任意的，我们必须检查两种可能的配对。如果 $(\\|\\mathbf{q}_{\\text{min}}^{(+)} - (1/\\sqrt{2}, 0)\\|_2 \\le \\tau_{\\text{verify}}\\ \\text{且}\\ \\|\\mathbf{q}_{\\text{min}}^{(-)} - (-1/\\sqrt{2}, 0)\\|_2 \\le \\tau_{\\text{verify}})$ 或 $(\\|\\mathbf{q}_{\\text{min}}^{(+)} - (-1/\\sqrt{2}, 0)\\|_2 \\le \\tau_{\\text{verify}}\\ \\text{且}\\ \\|\\mathbf{q}_{\\text{min}}^{(-)} - (1/\\sqrt{2}, 0)\\|_2 \\le \\tau_{\\text{verify}})$ 为真，则验证通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.linalg import norm, eigh\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for transition state finding and validation.\n    \"\"\"\n\n    def potential(r):\n        \"\"\"Computes the potential energy E(x,y) at a point r = (x,y).\"\"\"\n        x, y = r\n        return x**4 - x**2 + y**2\n\n    def gradient(r):\n        \"\"\"Computes the gradient of the potential energy at a point r = (x,y).\"\"\"\n        x, y = r\n        return np.array([4 * x**3 - 2 * x, 2 * y])\n\n    def hessian(r):\n        \"\"\"Computes the Hessian matrix of the potential energy at a point r = (x,y).\"\"\"\n        x, y = r\n        return np.array([[12 * x**2 - 2, 0.0], [0.0, 2.0]])\n\n    def run_dimer(r0, theta, delta, alpha_rot, alpha_trans, n_dimer, tau_dimer):\n        \"\"\"\n        Implements the dimer method to find a transition state.\n        \n        Returns the converged position R and orientation v.\n        \"\"\"\n        R = np.array(r0, dtype=float)\n        v = np.array([np.cos(theta), np.sin(theta)], dtype=float)\n\n        for _ in range(n_dimer):\n            # 1. Dimer endpoints and forces\n            R1 = R - (delta / 2.0) * v\n            R2 = R + (delta / 2.0) * v\n            F1 = -gradient(R1)\n            F2 = -gradient(R2)\n\n            # 2. Rotation\n            F_diff = F1 - F2\n            F_R = F_diff - np.dot(F_diff, v) * v\n            norm_F_R = norm(F_R)\n            \n            if norm_F_R  1e-12: # Avoid division by zero\n                v_unnormalized = v + alpha_rot * (F_R / norm_F_R)\n                v = v_unnormalized / norm(v_unnormalized)\n\n            # 3. Translation\n            F_cen = -gradient(R)\n            F_eff = F_cen - 2.0 * np.dot(F_cen, v) * v\n            norm_F_eff = norm(F_eff)\n\n            # 4. Convergence check\n            if norm_F_eff  tau_dimer:\n                break\n            \n            # 5. Update position\n            R = R + alpha_trans * (F_eff / norm_F_eff)\n            \n        return R, v\n\n    def run_irc(start_point, alpha_irc, n_irc, tau_irc):\n        \"\"\"\n        Performs a steepest descent integration for the IRC path.\n        \"\"\"\n        q = np.array(start_point, dtype=float)\n        for _ in range(n_irc):\n            grad_q = gradient(q)\n            if norm(grad_q)  tau_irc:\n                break\n            q = q - alpha_irc * grad_q\n        return q\n\n    # (x0,y0), theta, delta, alpha_rot, alpha_trans, N_dimer, tau_dimer,\n    # epsilon, alpha_irc, N_irc, tau_irc, tau_verify\n    test_cases = [\n        ((0.3, 0.2), 0.5, 1e-2, 0.3, 0.05, 800, 1e-9, 1e-3, 0.08, 5000, 1e-9, 1e-3),\n        ((0.6, -0.4), 1.2, 1e-4, 0.5, 0.03, 1200, 1e-10, 1e-4, 0.06, 7000, 1e-10, 1e-3),\n        ((1.2, 1.2), 2.0, 5e-3, 0.3, 0.02, 2000, 1e-9, 1e-3, 0.06, 10000, 1e-9, 1e-3)\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        r0, theta, delta, alpha_rot, alpha_trans, n_dimer, tau_dimer, \\\n        epsilon, alpha_irc, n_irc, tau_irc, tau_verify = case\n\n        # 1. Locate Transition State with Dimer Method\n        R_ts, v_ts = run_dimer(r0, theta, delta, alpha_rot, alpha_trans, n_dimer, tau_dimer)\n\n        # 2. Verification\n        \n        # 2.1. TS location verification\n        b_TS = norm(R_ts - np.array([0.0, 0.0])) = tau_verify\n\n        # 2.2. Hessian eigenvalue signature verification\n        H_ts = hessian(R_ts)\n        eigenvalues, eigenvectors = eigh(H_ts)\n        # Sort eigenvalues to be sure of order\n        eigenvalues = np.sort(eigenvalues)\n        b_eig = (eigenvalues[0]  0) and (eigenvalues[1] > 0)\n\n        # Extract unstable eigenvector (corresponding to the negative eigenvalue)\n        unstable_eigenvector = eigenvectors[:, np.argmin(eigenvalues)]\n\n        # 3. Perform IRC\n        q_start_p = R_ts + epsilon * unstable_eigenvector\n        q_start_n = R_ts - epsilon * unstable_eigenvector\n\n        q_min_p = run_irc(q_start_p, alpha_irc, n_irc, tau_irc)\n        q_min_n = run_irc(q_start_n, alpha_irc, n_irc, tau_irc)\n\n        # 4. Minima verification\n        min_plus_analytic = np.array([1.0/np.sqrt(2), 0.0])\n        min_minus_analytic = np.array([-1.0/np.sqrt(2), 0.0])\n\n        # Check both possible pairings due to arbitrary sign of eigenvector\n        path1_correct = (norm(q_min_p - min_plus_analytic) = tau_verify and \n                         norm(q_min_n - min_minus_analytic) = tau_verify)\n        path2_correct = (norm(q_min_p - min_minus_analytic) = tau_verify and \n                         norm(q_min_n - min_plus_analytic) = tau_verify)\n        \n        b_min = path1_correct or path2_correct\n\n        all_results.append([b_TS, b_eig, b_min])\n\n    # Final print statement in the exact required format.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "在实际的催化体系中，势能面往往非常复杂，Dimer 方法会面临一个常见的挑战——“模式混合”。当最低曲率模式与其他模式的曲率非常接近时，会引起 Dimer 旋转步骤的不稳定。本高级练习将教你如何诊断这种近简并情况，并提出相应的算法策略，以确保过渡态搜索的鲁棒性和准确性。",
            "id": "3903807",
            "problem": "考虑一个二维无量纲势能面 $V(\\mathbf{x})$，其中 $\\mathbf{x} = (x,y)$。其梯度 $\\nabla V(\\mathbf{x})$ 和 Hessian 矩阵 $\\mathbf{H}(\\mathbf{x}) = \\nabla^2 V(\\mathbf{x})$ 用于在计算催化和化学工程中定位和验证过渡态。指数为1的鞍点过渡态在驻点处的 Hessian 矩阵 $\\mathbf{H}$ 恰好有一个负特征值。Dimer 方法 (DM) 通过调整一对映象的方向以跟随最低曲率模式，但当 Hessian 矩阵的最低特征值近简并时，可能会遭受模式混合的影响。内禀反应坐标 (IRC) 是在质量加权坐标中连接过渡态与极小值点的势能面上的最陡下降路径，在此您可以将其视为在给定的无量纲坐标下对 $V(\\mathbf{x})$ 的最陡下降。\n\n从梯度和 Hessian 矩阵的基本定义以及特征值和特征向量的行为出发，设计一种诊断最低 Hessian 特征值近简并的方法，并使用由局部 Hessian 变化引起的主特征向量旋转的上界来量化模式混合的风险。然后，提出解决过渡态搜索过程中模式混合问题的算法策略，并提供一个使用简化的内禀反应坐标 (IRC) 最陡下降过程的验证步骤，以确认其指数为1的特性以及与不同极小值点的连通性。\n\n您的程序必须为每个测试用例实现以下内容：\n\n1. 势能定义。使用一个四次稳定、耦合、无量纲的多项式势\n$$\nV(x,y) = c_{x4}\\,x^4 + c_{y4}\\,y^4 - \\frac{1}{2}\\,a_{x2}\\,x^2 + \\frac{1}{2}\\,b_{y2}\\,y^2 + \\gamma\\,x\\,y,\n$$\n其对应的梯度为\n$$\n\\nabla V(x,y) = \\begin{bmatrix}\n4\\,c_{x4}\\,x^3 - a_{x2}\\,x + \\gamma\\,y\\\\\n4\\,c_{y4}\\,y^3 + b_{y2}\\,y + \\gamma\\,x\n\\end{bmatrix},\n$$\nHessian 矩阵为\n$$\n\\mathbf{H}(x,y) = \\begin{bmatrix}\n- a_{x2} + 12\\,c_{x4}\\,x^2  \\gamma\\\\\n\\gamma  b_{y2} + 12\\,c_{y4}\\,y^2\n\\end{bmatrix}.\n$$\n\n2. 近简并的诊断。设在过渡态猜测值 $\\mathbf{x}_0 = (0,0)$ 处的 Hessian 特征值按升序排序为 $\\lambda_1 \\le \\lambda_2$，其中 $\\lambda_1$ 对应的单位特征向量为 $\\mathbf{v}_1$。定义谱半径 $\\rho = \\max\\{|\\lambda_1|,|\\lambda_2|\\}$。定义绝对值间隙\n$$\n\\delta_{\\mathrm{abs}} = \\left|\\,|\\lambda_2| - |\\lambda_1|\\,\\right|.\n$$\n如果 $\\delta_{\\mathrm{abs}}/\\rho  \\tau_{\\mathrm{abs}}$，则返回布尔值近简并标志 $D$ 为真，否则为假。使用阈值 $\\tau_{\\mathrm{abs}} = 0.12$。\n\n3. 通过主角度上界评估模式混合风险。使用一个小的 Dimer 旋转半径 $r = 0.05$，估计局部 Hessian 变化\n$$\n\\mathbf{E} = \\mathbf{H}(\\mathbf{x}_0 + r\\,\\mathbf{v}_1) - \\mathbf{H}(\\mathbf{x}_0).\n$$\n设 $\\|\\mathbf{E}\\|_2$ 为谱范数（最大奇异值，对于对称矩阵 $\\mathbf{E}$ 等于最大绝对值特征值），并设特征值间隙为 $g = |\\lambda_2 - \\lambda_1|$。使用针对子空间扰动的 Davis–Kahan sin-theta 界，通过以下公式估计主旋转角 $\\theta$\n$$\n\\sin\\theta \\le \\min\\left(1,\\,\\frac{\\|\\mathbf{E}\\|_2}{\\max(g,\\varepsilon)}\\right),\n$$\n其中 $\\varepsilon = 10^{-12}$ 以避免除以零。以度为单位报告角度 $\\theta$。\n\n4. 用于解决模式混合的策略代码。根据诊断结果和由 $\\mathbf{H}(\\mathbf{x}_0)$ 的惯性指数确定的鞍点指数，输出一个整数策略代码列表：\n- $0$: 无特殊操作。\n- $1$: 对两个最低模式使用带有不变子空间追踪的双模式子空间 Dimer 方法。\n- $2$: 通过添加 $\\mu\\,\\mathbf{I}$（其中 $\\mu  0$ 为小值）来应用 Hessian 正则化，以在旋转过程中打破简并。\n- $3$: 减小 Dimer 旋转步长并使用与 $\\mathbf{H}$ 对齐的预处理度量。\n- $4$: 收敛后执行内禀反应坐标（IRC）验证。\n\n使用以下逻辑：\n- 如果 $D$ 为真且在 $\\mathbf{x}_0$ 处的 Hessian 矩阵恰好有一个负特征值（指数为1），则返回 $[1,3,4]$。\n- 如果 $D$ 为真且在 $\\mathbf{x}_0$ 处的 Hessian 矩阵有多于一个负特征值（更高指数），则返回 $[2,3,4]$。\n- 如果 $D$ 为假但 $\\theta  5$ 度，则返回 $[3]$。\n- 否则，返回 $[0]$。\n\n5. 通过简化的 IRC 过程进行过渡态验证。首先，检查在 $\\mathbf{x}_0$ 处的 Hessian 矩阵是否恰好有一个负特征值。如果没有，则验证返回假。如果有，则从两个初始位移 $\\mathbf{x}_\\pm = \\mathbf{x}_0 \\pm s\\,\\mathbf{v}_1$（$s = 0.02$）开始执行最陡下降，使用回溯线搜索，初始步长 $\\alpha_0 = 0.02$，回溯因子 $0.5$，Armijo 条件参数 $\\sigma = 10^{-8}$，最大迭代次数 $500$ 次，当 $\\|\\nabla V\\|_2  10^{-6}$ 时停止。设收敛点为 $\\mathbf{m}_+$ 和 $\\mathbf{m}_-$，并使其 Hessian 矩阵为正定（所有特征值大于 $10^{-6}$）。如果 $\\mathbf{m}_+$ 和 $\\mathbf{m}_-$ 均不相同（欧几里得距离大于 $10^{-3}$），均满足梯度范数停止准则，且均具有正定 Hessian 矩阵，则验证返回真；否则返回假。\n\n$\\theta$ 的角度单位必须以度报告。所有量均为无量纲。\n\n测试套件：\n提供三个测试用例，每个由参数 $(c_{x4}, c_{y4}, a_{x2}, b_{y2}, \\gamma)$ 定义并在 $\\mathbf{x}_0 = (0,0)$ 处进行评估：\n- 情况 A（理想路径，清晰的指数-1）：$c_{x4} = 0.25$, $c_{y4} = 0.25$, $a_{x2} = 2.0$, $b_{y2} = 2.0$, $\\gamma = 0.2$。\n- 情况 B（近简并的绝对值，指数-1）：$c_{x4} = 0.25$, $c_{y4} = 0.25$, $a_{x2} = 0.16$, $b_{y2} = 0.17$, $\\gamma = 0.0$。\n- 情况 C（近简并，更高指数）：$c_{x4} = 0.25$, $c_{y4} = 0.25$, $a_{x2} = 0.5$, $b_{y2} = -0.5$, $\\gamma = 0.0$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为一个逗号分隔的列表，并用方括号括起来，其中每个用例产生一个列表\n$$\n[\\;D,\\;\\theta_{\\mathrm{deg}},\\;\\text{strategy\\_codes},\\;\\text{ts\\_valid}\\;],\n$$\n其中 $D$ 和 $\\text{ts\\_valid}$ 为布尔值，$\\theta_{\\mathrm{deg}}$ 为以度为单位的浮点数，$\\text{strategy\\_codes}$ 为整数列表。例如，输出必须看起来像\n`[[caseA_D,caseA_theta,[...],[caseA_ts]], [caseB_D,caseB_theta,[...],caseB_ts], [caseC_D,caseC_theta,[...],caseC_ts]]`\n表示为一个单独的 Python 列表字面量字符串，例如\n`[ […], […], […] ]`。",
            "solution": "我们从势能面 $V(\\mathbf{x})$、其梯度 $\\nabla V(\\mathbf{x})$ 及其 Hessian 矩阵 $\\mathbf{H}(\\mathbf{x}) = \\nabla^2 V(\\mathbf{x})$ 的基本定义开始。指数为1的鞍点过渡态的特征是，在驻点处 Hessian 矩阵恰好有一个负特征值；这直接关系到决定上升或下降方向的局部二次型。\n\nDimer 方法 (DM) 中的模式混合发生在最低曲率模式具有几乎相等的曲率时：该算法旋转一个 Dimer 以与最小曲率方向对齐，但两个最低特征值之间的微小分离使得方向对扰动敏感。因此，我们需要一种有原则的诊断方法，比较两个最低特征值的绝对值，并量化在局部 Hessian 变化下主特征向量的敏感性。\n\n近简并的诊断：\n- 计算在过渡态猜测值 $\\mathbf{x}_0 = (0,0)$ 处的 Hessian 矩阵 $\\mathbf{H}(\\mathbf{x}_0)$ 及其特征值 $\\lambda_1 \\le \\lambda_2$。\n- 定义谱半径 $\\rho = \\max\\{|\\lambda_1|,|\\lambda_2|\\}$，它设定了曲率的局部尺度。\n- 定义绝对值间隙 $\\delta_{\\mathrm{abs}} = |\\,|\\lambda_2| - |\\lambda_1|\\,|$。最低模式的近简并可以通过相对间隙 $\\delta_{\\mathrm{abs}}/\\rho$ 很好地捕捉，因为它评估了曲率与整体尺度相比的相似程度。当 $\\delta_{\\mathrm{abs}}/\\rho  \\tau_{\\mathrm{abs}}$ 时，我们宣布近简并，阈值 $\\tau_{\\mathrm{abs}} = 0.12$。\n\n通过主角度上界评估模式混合风险：\n- 主特征向量 $\\mathbf{v}_1$ 对 Hessian 矩阵扰动的敏感性可以使用 Davis–Kahan sin-theta 定理进行界定。设局部扰动为 $\\mathbf{E} = \\mathbf{H}(\\mathbf{x}_0 + r\\,\\mathbf{v}_1) - \\mathbf{H}(\\mathbf{x}_0)$，其中 $r$ 为一个小半径，模拟 Dimer 旋转。谱范数 $\\|\\mathbf{E}\\|_2$（最大奇异值）提供了扰动的大小。\n- 对于一个 $2 \\times 2$ 的对称 Hessian 矩阵，特征值间隙 $g = |\\lambda_2 - \\lambda_1|$ 控制着主特征向量的稳定性：小间隙导致大旋转。\n- Davis–Kahan 界表明，对于小扰动，$\\sin\\theta \\le \\|\\mathbf{E}\\|_2 / g$；我们稳健地使用 $\\sin\\theta \\le \\min(1, \\|\\mathbf{E}\\|_2/\\max(g,\\varepsilon))$，其中 $\\varepsilon$ 很小以避免除以零。我们通过应用反正弦并将弧度转换为度来以度为单位报告角度 $\\theta$。这个上界量化了由局部曲率变化引起的 Dimer 主方向的最坏情况下的旋转。\n\n策略代码：\n- 当检测到近简并且鞍点指数为1时，我们建议追踪双模式不变子空间（代码1），减小旋转步长并对度量进行预处理（代码3），并进行收敛后的内禀反应坐标（IRC）验证（代码4）。\n- 当检测到近简并且 Hessian 矩阵具有更高指数（多于一个负特征值）时，我们额外建议进行 Hessian 正则化（代码2）以在旋转过程中打破简并，同时减小旋转步长和进行IRC验证（代码3和4）。\n- 如果未检测到近简并但主角度 $\\theta$ 超过5度，我们仍然建议减小旋转步长和进行预处理（代码3）。\n- 否则，无特殊操作（代码0）。\n\n通过简化的 IRC 进行过渡态验证：\n- 首先，通过计算 $\\mathbf{H}(\\mathbf{x}_0)$ 的负特征值数量来确认指数为1。如果不是指数为1，则返回假。\n- 如果是指数为1，则计算主特征向量 $\\mathbf{v}_1$ 并形成两个初始位移 $\\mathbf{x}_\\pm = \\mathbf{x}_0 \\pm s\\,\\mathbf{v}_1$。执行带有回溯线搜索的最陡下降：\n  - 初始化步长 $\\alpha_0 = 0.02$，并在每次迭代中尝试 $\\mathbf{x} \\leftarrow \\mathbf{x} - \\alpha\\,\\nabla V(\\mathbf{x})$。\n  - 使用参数 $\\sigma = 10^{-8}$ 的 Armijo 条件来接受能够充分减小 $V$ 的步长；否则，将 $\\alpha$ 乘以因子 $0.5$。\n  - 当 $\\|\\nabla V\\|_2  10^{-6}$ 或在 500 次迭代后停止。\n- 设收敛位置为 $\\mathbf{m}_+$ 和 $\\mathbf{m}_-$。如果 $\\mathbf{m}_+$ 和 $\\mathbf{m}_-$ 都具有正定的 Hessian 矩阵（所有特征值大于 $10^{-6}$），都满足梯度范数停止准则，并且是不同的（欧几里得距离大于 $10^{-3}$），则验证过渡态。这确认了指数为1的特性以及沿着反应坐标在相对两侧与两个极小值点有合理的连通性。\n\n算法实现细节：\n- 势能 $V(x,y)$、梯度和 Hessian 矩阵是从给定的多项式定义中解析计算的，确保了测试套件的数值稳定性。\n- 对称 Hessian 矩阵的特征值和特征向量通过标准对称特征值求解器计算，$\\mathbf{E}$ 的谱范数作为 $\\mathbf{E}$ 的最大绝对值特征值获得。\n- 所有量均为无量纲；角度 $\\theta$ 以度报告。\n\n测试套件覆盖范围：\n- 情况 A 提供了一个分离良好的指数为1的过渡态，其中简并和混合不太可能发生；IRC 应该能成功验证。\n- 情况 B 提供了一个指数为1的情形，其中两个最低曲率的绝对值近简并，增加了对模式混合的易感性；IRC 应该仍能成功验证。\n- 情况 C 提供了一个近简并的更高指数的鞍点（两个负特征值），其中 Dimer 方法的最小曲率方向定义不明确，IRC 验证应该会失败，从而正确识别出非过渡态情景。\n\n程序将结果聚合成一个单行的 Python 列表字面量打印出来，格式为 `[ […], […], […] ]`，其中每个内部列表包含近简并布尔值 $D$、主角度 $\\theta$（以度为单位）、策略代码列表以及指定的过渡态验证布尔值。",
            "answer": "```python\nimport numpy as np\n\ndef potential(params, x):\n    cx4 = params['c_x4']\n    cy4 = params['c_y4']\n    ax2 = params['a_x2']\n    by2 = params['b_y2']\n    gamma = params['gamma']\n    return cx4*x[0]**4 + cy4*x[1]**4 - 0.5*ax2*x[0]**2 + 0.5*by2*x[1]**2 + gamma*x[0]*x[1]\n\ndef gradient(params, x):\n    cx4 = params['c_x4']\n    cy4 = params['c_y4']\n    ax2 = params['a_x2']\n    by2 = params['b_y2']\n    gamma = params['gamma']\n    gx = 4*cx4*x[0]**3 - ax2*x[0] + gamma*x[1]\n    gy = 4*cy4*x[1]**3 + by2*x[1] + gamma*x[0]\n    return np.array([gx, gy])\n\ndef hessian(params, x):\n    cx4 = params['c_x4']\n    cy4 = params['c_y4']\n    ax2 = params['a_x2']\n    by2 = params['b_y2']\n    gamma = params['gamma']\n    hxx = -ax2 + 12*cx4*x[0]**2\n    hyy = by2 + 12*cy4*x[1]**2\n    hxy = gamma\n    H = np.array([[hxx, hxy],\n                  [hxy, hyy]], dtype=float)\n    # Symmetrize to avoid numerical asymmetry\n    return 0.5*(H + H.T)\n\ndef eig_sorted(H):\n    # For symmetric H, use eigh\n    w, V = np.linalg.eigh(H)\n    idx = np.argsort(w)\n    w = w[idx]\n    V = V[:, idx]\n    return w, V\n\ndef spectral_norm_sym(A):\n    # For symmetric A, spectral norm equals max abs eigenvalue\n    vals = np.linalg.eigvalsh(A)\n    return np.max(np.abs(vals))\n\ndef count_negative_eigs(eigs, tol=1e-12):\n    return int(np.sum(eigs  -tol))\n\ndef dimer_mixing_angle(H0, H1):\n    # Davis-Kahan bound: sin(theta) = ||E|| / gap\n    w0, V0 = eig_sorted(H0)\n    v1 = V0[:, 0]\n    gap = abs(w0[1] - w0[0])\n    E = H1 - H0\n    normE = spectral_norm_sym(E)\n    eps = 1e-12\n    sin_bound = min(1.0, normE / max(gap, eps))\n    theta_rad = np.arcsin(sin_bound)\n    theta_deg = theta_rad * (180.0/np.pi)\n    return theta_deg, v1, w0\n\ndef steepest_descent_with_backtracking(params, x0, max_iter=500, grad_tol=1e-6,\n                                       alpha0=0.02, backtrack=0.5, sigma=1e-8):\n    x = x0.copy()\n    for _ in range(max_iter):\n        g = gradient(params, x)\n        gn = np.linalg.norm(g)\n        if gn  grad_tol:\n            return x, True\n        alpha = alpha0\n        fx = potential(params, x)\n        # Armijo backtracking\n        for _ in range(20):\n            xn = x - alpha * g\n            fn = potential(params, xn)\n            if fn = fx - sigma * alpha * gn * gn:\n                x = xn\n                break\n            alpha *= backtrack\n        else:\n            # Could not find acceptable step; treat as failure\n            return x, False\n    # Max iterations reached\n    g = gradient(params, x)\n    return x, (np.linalg.norm(g)  grad_tol)\n\ndef ts_validation_irc(params, x0, v1, s=0.02):\n    # First check index-1 at x0\n    H0 = hessian(params, x0)\n    w0, _ = eig_sorted(H0)\n    if count_negative_eigs(w0) != 1:\n        return False\n    # Two displacements along v1\n    m_plus, ok_plus = steepest_descent_with_backtracking(params, x0 + s*v1)\n    m_minus, ok_minus = steepest_descent_with_backtracking(params, x0 - s*v1)\n    # Check positive definite Hessians\n    H_plus = hessian(params, m_plus)\n    H_minus = hessian(params, m_minus)\n    w_plus, _ = eig_sorted(H_plus)\n    w_minus, _ = eig_sorted(H_minus)\n    posdef_plus = np.min(w_plus)  1e-6\n    posdef_minus = np.min(w_minus)  1e-6\n    distinct = np.linalg.norm(m_plus - m_minus)  1e-3\n    return ok_plus and ok_minus and posdef_plus and posdef_minus and distinct\n\ndef evaluate_case(params, tau_abs=0.12, r=0.05):\n    x0 = np.array([0.0, 0.0])\n    H0 = hessian(params, x0)\n    w0, V0 = eig_sorted(H0)\n    rho = max(abs(w0[0]), abs(w0[1]))\n    delta_abs = abs(abs(w0[1]) - abs(w0[0]))\n    degeneracy = (delta_abs / rho)  tau_abs if rho > 0 else True\n    # Mixing angle\n    v1 = V0[:, 0]\n    H1 = hessian(params, x0 + r*v1)\n    theta_deg, v1, w0 = dimer_mixing_angle(H0, H1)\n    # Strategy codes\n    neg_count = count_negative_eigs(w0)\n    if degeneracy and neg_count == 1:\n        strategies = [1, 3, 4]\n    elif degeneracy and neg_count > 1:\n        strategies = [2, 3, 4]\n    elif (not degeneracy) and theta_deg > 5.0:\n        strategies = [3]\n    else:\n        strategies = [0]\n    # TS validation via simplified IRC\n    ts_valid = ts_validation_irc(params, x0, v1, s=0.02)\n    return [bool(degeneracy), float(theta_deg), strategies, bool(ts_valid)]\n\ndef solve():\n    test_cases = [\n        {'c_x4': 0.25, 'c_y4': 0.25, 'a_x2': 2.0,  'b_y2': 2.0,  'gamma': 0.2},   # Case A\n        {'c_x4': 0.25, 'c_y4': 0.25, 'a_x2': 0.16, 'b_y2': 0.17, 'gamma': 0.0},   # Case B\n        {'c_x4': 0.25, 'c_y4': 0.25, 'a_x2': 0.5,  'b_y2': -0.5, 'gamma': 0.0},   # Case C\n    ]\n\n    results = []\n    for params in test_cases:\n        res = evaluate_case(params, tau_abs=0.12, r=0.05)\n        results.append(res)\n    \n    final_string = str(results).replace(\" \", \"\")\n    print(final_string)\n\nsolve()\n```"
        }
    ]
}