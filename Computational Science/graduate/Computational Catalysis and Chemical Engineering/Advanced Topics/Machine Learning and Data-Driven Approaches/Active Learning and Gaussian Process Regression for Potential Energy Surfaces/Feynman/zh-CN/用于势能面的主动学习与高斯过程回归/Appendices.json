{
    "hands_on_practices": [
        {
            "introduction": "高斯过程回归的核心在于一个预测公式，它利用现有观测值来更新对新数据点函数值的认知。本练习将引导您逐步完成这一核心计算。掌握这个过程是理解高斯过程如何从数据中学习的第一步 。",
            "id": "3867315",
            "problem": "在计算催化中，对于催化剂板上吸附物的势能面进行数据驱动的探索时，假设能量作为构型的函数由一个零均值高斯过程 (GP) 建模，其协方差由一个正定核给出。已使用密度泛函理论 (DFT) 对三种构型进行了评估，得到含噪声的观测值，其模型为 $y = f + \\epsilon$，其中 $f$ 是潜函数值，$\\epsilon \\sim \\mathcal{N}(0, \\sigma_{n}^{2} I)$ 表示方差为 $\\sigma_{n}^{2}$ 的独立同分布高斯噪声。这三种训练构型的格拉姆矩阵为\n$$\nK \\;=\\; \\begin{bmatrix} 1  0.5  0.2 \\\\ 0.5  1  0.3 \\\\ 0.2  0.3  1 \\end{bmatrix},\n$$\n噪声方差为 $\\sigma_{n}^{2} = 0.01$，观测到的能量（单位为电子伏特）为\n$$\ny \\;=\\; \\begin{bmatrix} -0.1 \\\\ 0.2 \\\\ 0.0 \\end{bmatrix},\n$$\n一个测试构型与三个训练构型之间的协方差向量为\n$$\nk_{*} \\;=\\; \\begin{bmatrix} 0.4 \\\\ 0.6 \\\\ 0.1 \\end{bmatrix}.\n$$\n仅使用联合高斯变量的条件化法则和以上定义，计算在测试构型处的高斯过程后验预测均值 $\\mu_{*}$。将你的最终答案表示为预测能量（单位为电子伏特），并四舍五入到四位有效数字。",
            "solution": "该问题要求在给定一个势能面的零均值高斯过程 (GP) 模型的含噪声观测值的情况下，计算在测试构型处的后验预测均值 $\\mu_{*}$。该解法源于联合高斯随机变量的条件化法则。\n\n高斯过程回归的基本假设是，任意有限个函数值的集合，包括训练点 $f$ 和测试点 $f_{*}$ 的函数值，都服从联合高斯分布。鉴于问题指定了一个零均值高斯过程，我们有：\n$$\n\\begin{pmatrix} f \\\\ f_{*} \\end{pmatrix}\n\\sim \\mathcal{N} \\left(\n\\begin{pmatrix} \\mathbf{0} \\\\ 0 \\end{pmatrix},\n\\begin{pmatrix} K  k_{*} \\\\ k_{*}^T  k_{**} \\end{pmatrix}\n\\right)\n$$\n其中 $K$ 是训练点的协方差矩阵（格拉姆矩阵），$k_{*}$ 是测试点与训练点之间的协方差向量，$k_{**}$ 是测试点的自协方差。\n\n观测值 $y$ 是真实函数值 $f$ 的含噪声版本，其中 $y = f + \\epsilon$，噪声 $\\epsilon$ 来自一个独立同分布的高斯分布 $\\mathcal{N}(0, \\sigma_{n}^{2}I)$。这意味着观测向量 $y$ 也服从高斯分布，其协方差包含了噪声方差：\n$$\ny \\sim \\mathcal{N}(0, K + \\sigma_{n}^{2}I)\n$$\n因此，观测到的训练输出 $y$ 和测试点处的潜函数值 $f_{*}$ 的联合分布为：\n$$\n\\begin{pmatrix} y \\\\ f_{*} \\end{pmatrix}\n\\sim \\mathcal{N} \\left(\n\\begin{pmatrix} \\mathbf{0} \\\\ 0 \\end{pmatrix},\n\\begin{pmatrix} K + \\sigma_{n}^{2}I  k_{*} \\\\ k_{*}^T  k_{**} \\end{pmatrix}\n\\right)\n$$\n我们要求后验预测均值 $\\mu_{*} = \\mathbb{E}[f_{*} | y]$。使用分块多元高斯分布的条件均值的标准公式，我们得到：\n$$\n\\mu_{*} = \\mathbb{E}[f_{*}] + k_{*}^T (K + \\sigma_{n}^{2}I)^{-1} (y - \\mathbb{E}[y])\n$$\n由于该高斯过程的均值为零，所以 $\\mathbb{E}[f_{*}] = 0$ 且 $\\mathbb{E}[y] = \\mathbf{0}$。公式简化为：\n$$\n\\mu_{*} = k_{*}^T (K + \\sigma_{n}^{2}I)^{-1} y\n$$\n我们已知以下量：\n$$\nK = \\begin{bmatrix} 1  0.5  0.2 \\\\ 0.5  1  0.3 \\\\ 0.2  0.3  1 \\end{bmatrix}, \\quad \\sigma_{n}^{2} = 0.01, \\quad y = \\begin{bmatrix} -0.1 \\\\ 0.2 \\\\ 0.0 \\end{bmatrix}, \\quad k_{*} = \\begin{bmatrix} 0.4 \\\\ 0.6 \\\\ 0.1 \\end{bmatrix}\n$$\n计算分步进行。首先，我们计算矩阵 $K_y = K + \\sigma_{n}^{2}I$：\n$$\nK_y = \\begin{bmatrix} 1  0.5  0.2 \\\\ 0.5  1  0.3 \\\\ 0.2  0.3  1 \\end{bmatrix} + 0.01 \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix} = \\begin{bmatrix} 1.01  0.5  0.2 \\\\ 0.5  1.01  0.3 \\\\ 0.2  0.3  1.01 \\end{bmatrix}\n$$\n接下来，我们必须求 $K_y$ 的逆矩阵。矩阵 $A$ 的逆矩阵由 $A^{-1} = \\frac{1}{\\det(A)}\\text{adj}(A)$ 给出，其中 $\\text{adj}(A)$ 是 $A$ 的伴随矩阵。\n\n$K_y$ 的行列式是：\n$$\n\\det(K_y) = 1.01(1.01^2 - 0.3^2) - 0.5(0.5 \\cdot 1.01 - 0.3 \\cdot 0.2) + 0.2(0.5 \\cdot 0.3 - 1.01 \\cdot 0.2)\n$$\n$$\n\\det(K_y) = 1.01(1.0201 - 0.09) - 0.5(0.505 - 0.06) + 0.2(0.15 - 0.202)\n$$\n$$\n\\det(K_y) = 1.01(0.9301) - 0.5(0.445) + 0.2(-0.052)\n$$\n$$\n\\det(K_y) = 0.939401 - 0.2225 - 0.0104 = 0.706501\n$$\n伴随矩阵是代数余子式矩阵的转置。由于 $K_y$ 是对称矩阵，其代数余子式矩阵也是对称的，因此伴随矩阵等于代数余子式矩阵。代数余子式为：\n$$\nC_{11} = 1.01^2 - 0.3^2 = 0.9301\n$$\n$$\nC_{12} = -(0.5 \\cdot 1.01 - 0.3 \\cdot 0.2) = -0.445\n$$\n$$\nC_{13} = 0.5 \\cdot 0.3 - 1.01 \\cdot 0.2 = -0.052\n$$\n$$\nC_{22} = 1.01^2 - 0.2^2 = 0.9801\n$$\n$$\nC_{23} = -(1.01 \\cdot 0.3 - 0.2 \\cdot 0.5) = -0.203\n$$\n$$\nC_{33} = 1.01^2 - 0.5^2 = 0.7701\n$$\n代数余子式矩阵 $C$ 是：\n$$\nC = \\text{adj}(K_y) = \\begin{bmatrix} 0.9301  -0.445  -0.052 \\\\ -0.445  0.9801  -0.203 \\\\ -0.052  -0.203  0.7701 \\end{bmatrix}\n$$\n现在我们可以计算向量 $\\alpha = (K + \\sigma_{n}^{2}I)^{-1} y$：\n$$\n\\alpha = \\frac{1}{\\det(K_y)} \\text{adj}(K_y) y = \\frac{1}{0.706501} \\begin{bmatrix} 0.9301  -0.445  -0.052 \\\\ -0.445  0.9801  -0.203 \\\\ -0.052  -0.203  0.7701 \\end{bmatrix} \\begin{bmatrix} -0.1 \\\\ 0.2 \\\\ 0.0 \\end{bmatrix}\n$$\n$$\n\\alpha = \\frac{1}{0.706501} \\begin{bmatrix} 0.9301(-0.1) - 0.445(0.2) \\\\ -0.445(-0.1) + 0.9801(0.2) \\\\ -0.052(-0.1) - 0.203(0.2) \\end{bmatrix} = \\frac{1}{0.706501} \\begin{bmatrix} -0.09301 - 0.089 \\\\ 0.0445 + 0.19602 \\\\ 0.0052 - 0.0406 \\end{bmatrix} = \\frac{1}{0.706501} \\begin{bmatrix} -0.18201 \\\\ 0.24052 \\\\ -0.0354 \\end{bmatrix}\n$$\n最后，我们计算后验均值 $\\mu_{*} = k_{*}^T \\alpha$：\n$$\n\\mu_{*} = \\begin{bmatrix} 0.4  0.6  0.1 \\end{bmatrix} \\left( \\frac{1}{0.706501} \\begin{bmatrix} -0.18201 \\\\ 0.24052 \\\\ -0.0354 \\end{bmatrix} \\right)\n$$\n$$\n\\mu_{*} = \\frac{1}{0.706501} [0.4(-0.18201) + 0.6(0.24052) + 0.1(-0.0354)]\n$$\n$$\n\\mu_{*} = \\frac{1}{0.706501} [-0.072804 + 0.144312 - 0.00354]\n$$\n$$\n\\mu_{*} = \\frac{0.067968}{0.706501} \\approx 0.096203827\n$$\n问题要求将结果四舍五入到四位有效数字。第一位有效数字是 $9$，第四位是 $0$，其后的数字是 $3$。因此，我们向下舍入。\n$$\n\\mu_{*} \\approx 0.09620\n$$\n预测能量是 $0.09620$ eV。",
            "answer": "$$\\boxed{0.09620}$$"
        },
        {
            "introduction": "势能面通常通过分子动力学等方法进行探索，这些方法会产生高度相关的数据点。如果草率地分割这些数据用于训练和测试，可能会导致评估结果过于乐观，产生误导。本练习探讨了如何设计一个能尊重数据时间结构的“无泄漏”评估方案，这是构建稳健模型的关键技能 。",
            "id": "3867275",
            "problem": "考虑在计算催化领域，为利用从分子动力学（MD）采样构型训练的势能面（PES）的高斯过程（GP）回归，构建一个泛化评估方案。假设您有 $M=4$ 条独立的MD轨迹，每条轨迹有 $N=2000$ 个以固定时间间隔 $\\Delta t_s=0.5\\,\\mathrm{ps}$ 采样的已保存构型（“帧”）。在任何单条轨迹上，PES值的时间自相关函数凭经验能很好地被指数衰减函数 $C(\\Delta t)=\\exp\\!\\left(-\\lvert \\Delta t\\rvert/\\tau\\right)$ 拟合，其中相关时间 $\\tau=5\\,\\mathrm{ps}$。GP回归使用一个平稳核 $k(\\mathbf{x},\\mathbf{x}')$，该核函数值随构型相似性的增加而增加，因此沿着MD轨迹的强时间相关性意味着邻近帧之间存在强核相关性。\n\n您的评估目标是在训练集和测试集之间没有信息泄露的情况下，估计样本外误差（例如，均方根误差（RMSE））。假设当任何测试帧与同一轨迹上的训练帧高度相关时，就会发生泄露。这一点的量化标准是：如果任何测试帧与同一轨迹内的任何训练帧之间的最小时间间隔 $s_{\\min}$ 满足 $C(s_{\\min})\\le \\epsilon$（其中 $\\epsilon=0.1$ 是选定的“可忽略相关性”阈值），则该训练-测试划分是“无泄露”的。\n\n从自相关函数 $C(\\Delta t)$ 的定义和GP预测方差公式 $V(\\mathbf{x}_\\star\\mid \\mathcal{D})=k(\\mathbf{x}_\\star,\\mathbf{x}_\\star)-\\mathbf{k}_\\star^{\\top}\\mathbf{K}^{-1}\\mathbf{k}_\\star$ 出发，解释为什么时间上邻近的训练帧和测试帧会导致过于乐观的测试误差估计，并确定在此设置下满足 $C(s_{\\min})\\le \\epsilon$ 所需的最小间隔 $s_{\\min}$。然后，根据无泄露标准和实际的训练-测试集平衡，评估以下划分策略，并选择所有无泄露的策略：\n\nA. 随机打乱所有 $M\\times N$ 帧，并将 $80\\%$ 分配给训练集，$20\\%$ 分配给测试集。\n\nB. 按轨迹分组并执行留一轨迹交叉验证：在每一折中，将来自 $1$ 条轨迹的所有帧作为测试集，并用剩余的 $M-1$ 条轨迹进行训练。\n\nC. 在每条轨迹内部，将帧划分为长度为 $L=250$ 帧的连续“块”，随机均匀地选择大约 $20\\%$ 的块构成测试集，并在每个测试块周围强制设置一个大小为 $B=25$ 帧的“缓冲区”，该缓冲区内的帧不用于训练（即，任何测试块边界 $B$ 范围内的帧都从训练中丢弃）。\n\nD. 在所有轨迹中，将交替的帧分配给训练集和测试集（例如，奇数索引的帧用于训练，偶数索引的帧用于测试）。\n\nE. 根据PES值将帧分层到不同的能量箱中，并在忽略轨迹成员关系的情况下，将每个箱按 $80\\%$–$20\\%$ 的比例划分为训练集和测试集，以保持训练集和测试集之间能量分布的相似性。\n\n您的回答应通过基于基本原理推导 $s_{\\min}$，并解释时间相关性对GP预测不确定性的影响，来证明您选择的合理性。请选择所有正确的选项。",
            "solution": "该问题陈述经评估是有效的。它在科学上基于应用于计算化学的统计力学和机器学习原理。所描述的场景——使用高斯过程（GP）回归对分子动力学（MD）数据建模势能面（PES）以及时间序列交叉验证的相关挑战——是该领域的标准且重要的问题。该问题提法恰当，提供了所有必要的常数和一个清晰、客观的评估标准（$\\tau=5\\,\\mathrm{ps}$，$\\epsilon=0.1$ 等）。其前提和定义是内部一致且物理上现实的。\n\n问题的核心是设计一种避免信息泄露的验证方案，即模型在与训练数据高度相关的数据点上进行测试。这会导致过于乐观的误差估计，不能反映模型的真实泛化性能。我们将首先在高斯过程回归的背景下解释这一现象，然后确定最小安全时间间隔，最后根据这一标准评估每种提出的划分策略。\n\n**时间相关性对GP误差估计的影响**\n\n高斯过程模型对新输入 $\\mathbf{x}_\\star$ 的预测不仅仅是一个单一值，而是一个概率分布，由均值和方差表征。给定一个训练数据集 $\\mathcal{D}$，测试点 $\\mathbf{x}_\\star$ 的预测方差由以下公式给出：\n$$V(\\mathbf{x}_\\star\\mid \\mathcal{D}) = k(\\mathbf{x}_\\star,\\mathbf{x}_\\star) - \\mathbf{k}_\\star^{\\top}\\mathbf{K}^{-1}\\mathbf{k}_\\star$$\n这里，$k(\\mathbf{x},\\mathbf{x}')$ 是核函数，$k(\\mathbf{x}_\\star,\\mathbf{x}_\\star)$ 是测试点的先验方差，$\\mathbf{K}$ 是训练点的协方差矩阵，$\\mathbf{k}_\\star$ 是测试点与每个训练点之间协方差的向量。\n\n项 $\\mathbf{k}_\\star^{\\top}\\mathbf{K}^{-1}\\mathbf{k}_\\star$ 代表了由于训练数据提供的信息而导致的方差减少（即确定性的增加）。问题陈述指出，MD帧之间的强时间相关性意味着强的核相关性。这意味着，如果一个测试帧 $\\mathbf{x}_\\star$ 在时间上与一个训练帧 $\\mathbf{x}_i$ 非常接近，它们的构型将会很相似，因此核函数值 $k(\\mathbf{x}_\\star, \\mathbf{x}_i)$ 会很大。这个大值是向量 $\\mathbf{k}_\\star$ 的一个分量。\n\n一个大的 $\\mathbf{k}_\\star$ 表示测试点与训练数据之间的高度相似性。这通常会导致一个大的方差减少项 $\\mathbf{k}_\\star^{\\top}\\mathbf{K}^{-1}\\mathbf{k}_\\star$，从而使预测方差 $V(\\mathbf{x}_\\star\\mid \\mathcal{D})$ 变小。小的预测方差意味着模型具有高置信度。在一个校准良好的模型中，这种高置信度与低预测误差（例如，均方根误差RMSE）相关。\n\n因此，如果测试集包含与训练集中的帧在时间上很接近的帧，GP模型将仅仅通过从训练集中几乎相同的邻居进行插值，就能对它们做出高置信度、低误差的预测。由此产生的低测试误差是“过于乐观”的，因为它没有衡量模型预测真正新的、不相关构型的PES的能力。这是一个典型的信息泄露案例。\n\n**最小安全间隔（$s_{\\min}$）的推导**\n\n为防止此类泄露，问题定义了一个“无泄露”标准：任何测试帧与同一轨迹内的任何训练帧之间的最小时间间隔 $s_{\\min}$ 必须足够大，以使其时间自相关 $C(s_{\\min})$ 低于阈值 $\\epsilon$。\n给定的参数是：\n- 自相关函数：$C(\\Delta t) = \\exp(-\\lvert \\Delta t\\rvert/\\tau)$\n- 相关时间：$\\tau = 5\\,\\mathrm{ps}$\n- 相关性阈值：$\\epsilon = 0.1$\n\n我们必须找到满足 $C(s_{\\min}) \\le \\epsilon$ 的最小 $s_{\\min} \\ge 0$。我们求解边界情况：\n$$C(s_{\\min}) = \\epsilon$$\n$$\\exp(-s_{\\min}/\\tau) = \\epsilon$$\n代入给定值：\n$$\\exp(-s_{\\min}/5) = 0.1$$\n两边取自然对数：\n$$-s_{\\min}/5 = \\ln(0.1)$$\n$$-s_{\\min}/5 = -\\ln(10)$$\n$$s_{\\min} = 5\\ln(10)\\,\\mathrm{ps}$$\n使用近似值 $\\ln(10) \\approx 2.3026$，我们发现：\n$$s_{\\min} \\approx 5 \\times 2.3026\\,\\mathrm{ps} = 11.513\\,\\mathrm{ps}$$\n因此，任何有效的训练-测试划分策略都必须确保一个测试帧与*来自同一轨迹*的任何训练帧之间至少相隔 $11.513\\,\\mathrm{ps}$。采样间隔为 $\\Delta t_s = 0.5\\,\\mathrm{ps}$，这对应于 $11.513\\,\\mathrm{ps} / (0.5\\,\\mathrm{ps}/\\text{帧}) \\approx 23.026$ 帧的间隔。因此，至少需要24帧的间隔。\n\n**划分策略的评估**\n\n我们现在根据标准 $s_{\\min} \\ge 11.513\\,\\mathrm{ps}$ 评估每个策略。\n\n**A. 随机打乱所有 $M\\times N$ 帧，并将 $80\\%$ 分配给训练集，$20\\%$ 分配给测试集。**\n该策略完全忽略了数据的时间结构。通过随机打乱所有 $8000$ 帧，几乎可以肯定的是，对于任何给定测试帧（在其原始轨迹中索引为 $i$），其邻居（帧 $i-1$ 和帧 $i+1$）将被分配到训练集中。因此，训练帧和测试帧之间的最小时间间隔将是采样间隔，即 $s_{\\min}^{\\text{策略}} = \\Delta t_s = 0.5\\,\\mathrm{ps}$。\n由于 $0.5\\,\\mathrm{ps} \\ll 11.513\\,\\mathrm{ps}$，该策略导致大量信息泄露。\n**结论：不正确**\n\n**B. 按轨迹分组并执行留一轨迹交叉验证。**\n在这种方法中，训练集由来自 $M-1=3$ 条轨迹的帧组成，测试集由来自剩余 $1$ 条轨迹的所有帧组成。关键点在于，训练集和测试集由来自完全独立的MD模拟的数据组成。不存在一个在训练集、一个在测试集中的两个帧源自同一条轨迹。因此，轨迹内部分离的条件自然得到满足，因为同一轨迹内的训练-测试对集合是空的。此方法稳健地测试了模型对构型空间不同区域的泛化能力。\n**结论：正确**\n\n**C. 在每条轨迹内部，将帧划分为长度为 $L=250$ 帧的连续“块”，随机均匀地选择大约 $20\\%$ 的块构成测试集，并在每个测试块周围强制设置一个大小为 $B=25$ 帧的“缓冲区”，该缓冲区内的帧不用于训练。**\n这是一种“分块”或“带缓冲”的交叉验证策略。一个测试帧最可能接近的训练帧将是位于其测试块缓冲区之外的那个帧。测试块两侧 $B=25$ 帧的缓冲区确保了一个最小间隔。这种情况下的最小时间间隔由缓冲区的大小决定：\n$$s_{\\min}^{\\text{策略}} = B \\times \\Delta t_s = 25\\,\\text{帧} \\times 0.5\\,\\mathrm{ps}/\\text{帧} = 12.5\\,\\mathrm{ps}$$\n我们将此与我们要求的最小间隔进行比较：$12.5\\,\\mathrm{ps} > 11.513\\,\\mathrm{ps}$。该条件得到满足。在此间隔下的自相关将是 $C(12.5\\,\\mathrm{ps}) = \\exp(-12.5/5) = \\exp(-2.5) \\approx 0.082$，小于阈值 $\\epsilon = 0.1$。\n**结论：正确**\n\n**D. 在所有轨迹中，将交替的帧分配给训练集和测试集。**\n该方案例如将奇数索引的帧分配给训练集，偶数索引的帧分配给测试集。对于任何索引为 $2k$ 的测试帧，其在轨迹中的直接时间邻居，即帧 $2k-1$ 和 $2k+1$，都被分配到训练集中。最小时间间隔同样是采样间隔，$s_{\\min}^{\\text{策略}} = \\Delta t_s = 0.5\\,\\mathrm{ps}$。\n这远低于所要求的 $11.513\\,\\mathrm{ps}$，并导致严重的信息泄露。\n**结论：不正确**\n\n**E. 根据PES值将帧分层到不同的能量箱中，并在忽略轨迹成员关系的情况下，将每个箱按 $80\\%$–$20\\%$ 的比例划分为训练集和测试集。**\n尽管此策略意在保留数据集的能量分布，但它明确地“忽略轨迹成员关系”。这意味着它在全局帧池上操作，非常像策略A。在每个能量箱内，划分是随机的。由于时间上相邻的帧具有非常相似的能量，它们几乎肯定会落入同一个能量箱中。在该箱内进行随机的 $80\\%/20\\%$ 划分，极有可能将这些相邻的帧分到训练集和测试集中。因此，最小时间间隔预计为 $s_{\\min}^{\\text{策略}} = \\Delta t_s = 0.5\\,\\mathrm{ps}$。这不满足无泄露的标准。\n**结论：不正确**\n\n总之，根据所给的定义，只有策略B和C是“无泄露”的。",
            "answer": "$$\\boxed{BC}$$"
        },
        {
            "introduction": "高斯过程在主动学习中的威力源于其量化自身不确定性的能力，从而指导下一步的采样方向。然而，这些不确定性估计只有在“校准”后才有用——即一个 $0.95$ 的置信区间应该在 $0.95$ 的情况下包含真值。本编程练习提供了一种实用的统计方法来验证这些不确定性，确保我们的主动学习策略建立在坚实的基础之上 。",
            "id": "3867258",
            "problem": "在计算催化中，一个势能面的高斯过程 (GP) 代理模型为每个原子构型指数 $i$ 提供一个预测平均能量 $\\mu_i$ 和一个预测标准差 $\\sigma_i$。能量的名义双边置信水平为 $0.95$ 的区间取自标准正态参考模型。使用经验覆盖概率对 GP 预测不确定度进行校准的定义是，将名义置信水平与实现的能量落入相应名义预测区间内的长期频率进行比较。在本问题中，您将把这一概念形式化，并通过计算经验覆盖概率和进行基于覆盖指示变量的二项分布模型的统计假设检验，来测试能量的名义 $0.95$ 区间是否达到了 $0.95$ 的覆盖率。\n\n您必须编写一个完整的程序，针对几个预测值和实现能量的合成数据集（所有能量单位为电子伏特 (eV)），计算名义双边 $0.95$ 预测区间的经验覆盖概率，并在显著性水平 $\\alpha = 0.05$ 下检验观测到的覆盖率是否与真实覆盖率 $0.95$ 一致。不涉及角度。所有输出均为无量纲。\n\n您可以无需进一步论证而假设以下基本依据：对于每个输入都具有高斯预测边缘分布的 GP，能量的预测分布为均值为 $\\mu_i$、标准差为 $\\sigma_i$ 的正态分布；名义双边置信水平为 $0.95$ 的区间由标准正态分布的分位数获得；一个固定水平区间的覆盖指示变量是一个伯努利试验，且独立试验的总和服从二项分布。\n\n您的程序必须严格实现以下数据集和任务。\n\n数据集（按所述确定性地构建每个数据集，所有能量单位为电子伏特 (eV)）：\n\n- 案例 A（理想情况）：样本大小 $N = 40$。对于每个指数 $i \\in \\{0,1,\\dots,39\\}$，设置预测平均值 $\\mu_i = -0.5 + 0.05 \\times i$ 和预测标准差 $\\sigma_i = 0.1$。定义实现的能量 $y_i$：对于指数 $i \\in \\{0,1,\\dots,37\\}$，$y_i = \\mu_i$；对于指数 $i \\in \\{38,39\\}$，$y_i = \\mu_i + 3 \\times \\sigma_i$。如果使用名义 $0.95$ 区间，这将恰好产生 $38$ 个在区间内的结果。\n- 案例 B（离散不足的区间）：样本大小 $N = 40$。对于每个指数 $i \\in \\{0,1,\\dots,39\\}$，设置 $\\mu_i = -0.5 + 0.05 \\times i$ 和 $\\sigma_i = 0.1$。定义 $y_i$：对于指数 $i \\in \\{0,1,\\dots,29\\}$，$y_i = \\mu_i$；对于指数 $i \\in \\{30,31,\\dots,39\\}$，$y_i = \\mu_i + 3 \\times \\sigma_i$。如果使用名义 $0.95$ 区间，这将恰好产生 $30$ 个在区间内的结果。\n- 案例 C（略低于目标）：样本大小 $N = 40$。对于每个指数 $i \\in \\{0,1,\\dots,39\\}$，设置 $\\mu_i = -0.5 + 0.05 \\times i$ 和 $\\sigma_i = 0.1$。定义 $y_i$：对于指数 $i \\in \\{0,1,\\dots,35\\}$，$y_i = \\mu_i$；对于指数 $i \\in \\{36,37,38,39\\}$，$y_i = \\mu_i + 3 \\times \\sigma_i$。如果使用名义 $0.95$ 区间，这将恰好产生 $36$ 个在区间内的结果。\n- 案例 D（离散过度但小样本）：样本大小 $N = 20$。对于每个指数 $i \\in \\{0,1,\\dots,19\\}$，设置 $\\mu_i = -0.2 + 0.02 \\times i$ 和 $\\sigma_i = 0.1$。对于所有 $i$，定义 $y_i = \\mu_i$。如果使用名义 $0.95$ 区间，这将恰好产生 $20$ 个在区间内的结果。\n- 案例 E（极端小样本边缘情况）：样本大小 $N = 1$。对于指数 $i = 0$，设置 $\\mu_0 = 0.0$, $\\sigma_0 = 0.1$ 和 $y_0 = \\mu_0$。如果使用名义 $0.95$ 区间，这将恰好产生 $1$ 个在区间内的结果。\n\n您的程序必须为每个案例执行以下任务：\n\n- 使用标准正态参考分位数为每个指数 $i$ 构建置信水平为 $0.95$ 的名义双边预测区间。计算有多少个实现的能量 $y_i$ 位于其相应区间内，并将经验覆盖概率计算为 $N$ 个结果中在区间内结果的比例。\n- 在显著性水平 $\\alpha = 0.05$ 下，对真实覆盖率等于 $0.95$ 的原假设进行精确双边二项检验。当且仅当在水平 $\\alpha$ 下原假设未被拒绝时，判定名义 $0.95$ 区间达到了 $0.95$ 的覆盖率。\n\n最终输出格式：\n\n- 按 A、B、C、D、E 的顺序，为每个案例生成一个包含经验覆盖概率和布尔值的对。如果观测到的覆盖率在显著性水平 $\\alpha = 0.05$ 下与 $0.95$ 一致，则布尔值为 true，否则为 false。\n- 将经验覆盖概率四舍五入到 $4$ 位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个案例表示为一个双元素列表。例如，总体格式类似于 $[[c_A,b_A],[c_B,b_B],[c_C,b_C],[c_D,b_D],[c_E,b_E]]$，其中 $c_{\\cdot}$ 是浮点数，$b_{\\cdot}$ 是布尔值。输出中不要打印任何单位。\n\n每个测试案例的答案必须是如上定义的经验覆盖概率（浮点数）和假设决策（布尔值），并且所有五个案例必须按规定汇总到单行输出中。",
            "solution": "该问题是有效的。它在科学上基于模型验证的标准统计方法，特别是高斯过程模型预测不确定度的校准。该问题是适定的，为获得唯一、可验证的解提供了所有必要的数据和定义。所有术语都是客观且精确定义的。\n\n任务是评估一个高斯过程 (GP) 模型在几个合成数据集上的校准情况。对于每个数据集，我们计算名义 $0.95$ 预测区间的经验覆盖概率，并执行统计假设检验以确定观测到的覆盖率是否与名义水平一致。\n\n对于每个案例，该方法分三个主要步骤进行：\n1.  **预测区间计算**：GP 模型为新构型 $i$ 处的能量提供了一个预测分布，假设其为高斯分布：$Y_i \\sim \\mathcal{N}(\\mu_i, \\sigma_i^2)$。真实能量 $y_i$ 的名义双边 $95\\%$ 预测区间构建为 $[\\mu_i - z \\cdot \\sigma_i, \\mu_i + z \\cdot \\sigma_i]$。值 $z$ 是标准正态分布中对应于累积概率 $1 - (1 - 0.95)/2 = 0.975$ 的分位数。该值为 $z_{0.975} \\approx 1.95996$。\n\n2.  **经验覆盖概率**：对于一个包含 $N$ 个预测和实现能量的数据集，我们为每个点定义一个指示变量 $I_i$：\n$$\nI_i = \\begin{cases} 1  \\text{if } y_i \\in [\\mu_i - z \\cdot \\sigma_i, \\mu_i + z \\cdot \\sigma_i] \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n在区间内的观测数量为 $k = \\sum_{i=1}^{N} I_i$。经验覆盖概率 $P_{emp}$ 是落入其相应预测区间内的实现能量的比例：\n$$\nP_{emp} = \\frac{k}{N}\n$$\n\n3.  **假设检验**：我们检验未知的真实覆盖概率 $p$ 是否等于名义水平 $p_0 = 0.95$。框架如下：\n    - **原假设 ($H_0$)**：真实覆盖概率等于名义水平，$p = p_0 = 0.95$。\n    - **备择假设 ($H_A$)**：真实覆盖概率不等于名义水平，$p \\neq 0.95$。\n    - **检验统计量**：成功次数 $k$ 被视为来自二项随机变量 $K \\sim \\text{Binomial}(N, p)$ 的一个观测值。\n    - **显著性水平**：检验在显著性水平 $\\alpha = 0.05$ 下进行。\n    - **P值计算**：我们使用精确双边二项检验。p值是在假设 $H_0$ 为真的情况下，观测到与观测计数 $k_{obs}$ 一样极端或更极端的结果的概率。其计算方法是对所有概率小于或等于观测结果概率的结果 $j \\in \\{0, \\dots, N\\}$ 的概率求和：\n    $$\n    \\text{p-value} = \\sum_{j=0}^{N} \\mathbb{P}(K=j|H_0) \\cdot \\mathbf{1}_{\\{\\mathbb{P}(K=j|H_0) \\le \\mathbb{P}(K=k_{obs}|H_0)\\}}\n    $$\n    其中 $\\mathbb{P}(K=j|H_0) = \\binom{N}{j} p_0^j (1-p_0)^{N-j}$。\n    - **决策**：如果我们未能拒绝原假设，则认为覆盖率与名义水平 $0.95$ “一致”，这种情况发生在计算出的p值大于显著性水平 $\\alpha$ 时。也就是说，如果 $\\text{p-value} > 0.05$，则确认一致性。\n\n我们将此程序应用于指定的五个案例中的每一个。\n\n**案例 A**：$N=40$。构建了两个点位于 $z \\approx 1.96\\sigma$ 区间之外（在 $3\\sigma$ 处），从而得到 $k=38$ 个在区间内的观测值。\n- 经验覆盖率：$P_{emp} = 38/40 = 0.95$。\n- 二项检验：对于 $k=38$, $N=40$, 和 $p_0=0.95$, 期望的成功次数是 $N \\cdot p_0 = 38$。观测计数与期望计数完全匹配。p值为 $1.0$。\n- 决策：由于 $1.0 > 0.05$, 我们不拒绝 $H_0$。覆盖率是一致的。\n- 结果：$[0.9500, \\text{True}]$\n\n**案例 B**：$N=40$。十个点在区间之外，得到 $k=30$ 个在区间内的观测值。\n- 经验覆盖率：$P_{emp} = 30/40 = 0.75$。\n- 二项检验：对于 $k=30$, $N=40$, 和 $p_0=0.95$, 观测计数显著低于期望的 $38$。计算出的p值约为 $0.000015$。\n- 决策：由于 $0.000015 \\le 0.05$, 我们拒绝 $H_0$。覆盖率不一致，表明区间离散不足（过窄）。\n- 结果：$[0.7500, \\text{False}]$\n\n**案例 C**：$N=40$。四个点在区间之外，得到 $k=36$ 个在区间内的观测值。\n- 经验覆盖率：$P_{emp} = 36/40 = 0.90$。\n- 二项检验：对于 $k=36$, $N=40$, 和 $p_0=0.95$。观测计数小于期望的 $38$，但偏差可能不具有统计显著性。计算出的p值约为 $0.1285$。\n- 决策：由于 $0.1285 > 0.05$, 我们不拒绝 $H_0$。覆盖率是一致的。\n- 结果：$[0.9000, \\text{True}]$\n\n**案例 D**：$N=20$。所有点都在均值处，得到 $k=20$ 个在区间内的观测值。\n- 经验覆盖率：$P_{emp} = 20/20 = 1.0$。\n- 二项检验：对于 $k=20$, $N=20$, 和 $p_0=0.95$。期望计数为 $19$。观测到的覆盖率是完美的（$1.0$），高于名义水平。然而，在小样本量下，检测到这种偏差的统计功效较低。计算出的p值约为 $0.6415$。\n- 决策：由于 $0.6415 > 0.05$, 我们不拒绝 $H_0$。覆盖率是一致的。\n- 结果：$[1.0000, \\text{True}]$\n\n**案例 E**：$N=1$。一个点在均值处，得到 $k=1$ 个在区间内的观测值。\n- 经验覆盖率：$P_{emp} = 1/1 = 1.0$。\n- 二项检验：对于 $k=1$, $N=1$, 和 $p_0=0.95$。只有一个试验，只有两种可能的结果：$k=0$（概率 $0.05$）或 $k=1$（概率 $0.95$）。我们观测到了最可能的结果。当观测到最可能的结果时，精确二项检验的p值为 $1.0$。\n- 决策：由于 $1.0 > 0.05$, 我们不拒绝 $H_0$。覆盖率是一致的。\n- 结果：$[1.0000, \\text{True}]$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Solves the problem of validating Gaussian Process predictive intervals.\n    For each synthetic dataset, it computes the empirical coverage probability\n    and conducts a two-sided Binomial test for consistency with the nominal\n    0.95 coverage level.\n    \"\"\"\n    \n    # Define constants for the analysis\n    credibility_level = 0.95\n    p_null = 0.95\n    alpha = 0.05\n\n    # Calculate the z-score for the two-sided 95% interval\n    # It corresponds to the quantile for a cumulative probability of 1 - (1 - 0.95)/2 = 0.975\n    z_score = stats.norm.ppf(1 - (1 - credibility_level) / 2)\n\n    # Define the five datasets as described in the problem statement\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"N\": 40,\n            \"mu_func\": lambda i: -0.5 + 0.05 * i,\n            \"sigma_val\": 0.1,\n            \"y_func\": lambda mu, sigma, i: mu if i = 37 else mu + 3 * sigma\n        },\n        {\n            \"name\": \"B\",\n            \"N\": 40,\n            \"mu_func\": lambda i: -0.5 + 0.05 * i,\n            \"sigma_val\": 0.1,\n            \"y_func\": lambda mu, sigma, i: mu if i = 29 else mu + 3 * sigma\n        },\n        {\n            \"name\": \"C\",\n            \"N\": 40,\n            \"mu_func\": lambda i: -0.5 + 0.05 * i,\n            \"sigma_val\": 0.1,\n            \"y_func\": lambda mu, sigma, i: mu if i = 35 else mu + 3 * sigma\n        },\n        {\n            \"name\": \"D\",\n            \"N\": 20,\n            \"mu_func\": lambda i: -0.2 + 0.02 * i,\n            \"sigma_val\": 0.1,\n            \"y_func\": lambda mu, sigma, i: mu\n        },\n        {\n            \"name\": \"E\",\n            \"N\": 1,\n            \"mu_func\": lambda i: 0.0,\n            \"sigma_val\": 0.1,\n            \"y_func\": lambda mu, sigma, i: mu\n        },\n    ]\n\n    results = []\n\n    # Process each test case\n    for case in test_cases:\n        N = case[\"N\"]\n        \n        # Generate the synthetic data (mu, sigma, y) for the current case\n        indices = np.arange(N)\n        mu_vec = np.array([case[\"mu_func\"](i) for i in indices])\n        sigma_vec = np.full(N, case[\"sigma_val\"])\n        y_vec = np.array([case[\"y_func\"](mu_vec[i], sigma_vec[i], i) for i in indices])\n\n        # 1. Prediction Interval and Empirical Coverage Calculation\n        lower_bounds = mu_vec - z_score * sigma_vec\n        upper_bounds = mu_vec + z_score * sigma_vec\n\n        # Count how many realized energies fall within their interval\n        in_interval_count = np.sum((y_vec >= lower_bounds)  (y_vec = upper_bounds))\n        \n        # Compute the empirical coverage probability\n        empirical_coverage = in_interval_count / N\n\n        # 2. Hypothesis Testing\n        # Perform an exact two-sided Binomial test\n        # H0: true coverage probability p = p_null (0.95)\n        # HA: p != p_null\n        # The 'scipy.stats.binomtest' function handles the p-value calculation\n        test_result = stats.binomtest(k=in_interval_count, n=N, p=p_null, alternative='two-sided')\n        p_value = test_result.pvalue\n\n        # The coverage is \"consistent\" if we fail to reject the null hypothesis\n        is_consistent = p_value > alpha\n\n        # Append the result pair to the list of results\n        results.append([round(empirical_coverage, 4), is_consistent])\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists matches the required structure.\n    # The requirement for \"[c,b]\" without a space is handled by removing all spaces.\n    final_output_string = str(results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}