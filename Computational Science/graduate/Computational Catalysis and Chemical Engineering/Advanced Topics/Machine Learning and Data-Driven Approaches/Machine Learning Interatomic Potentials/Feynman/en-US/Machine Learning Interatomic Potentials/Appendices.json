{
    "hands_on_practices": [
        {
            "introduction": "Machine learning models require numerical inputs, but raw atomic coordinates are unsuitable as they change with rotation and translation. To build a robust MLIP, we must first transform the local atomic environment around each atom into a fixed-size numerical vector, or \"descriptor,\" that inherently respects these symmetries. This exercise  provides a concrete, hands-on calculation of a Behler-Parrinello radial symmetry function, a foundational descriptor type, allowing you to see exactly how a 3D atomic structure is encoded into a physically meaningful feature.",
            "id": "90953",
            "problem": "In the field of machine learning interatomic potentials, Behler-Parrinello symmetry functions are a cornerstone for creating robust and accurate models of atomic interactions. These functions describe the local chemical environment of an atom in a way that is invariant to rotation, translation, and permutation of like atoms.\n\nA common type of radial symmetry function, denoted as $G^i(\\eta, R_s)$, quantifies the radial distribution of neighboring atoms $j$ around a central atom $i$. It is defined as:\n$$\nG^i(\\eta, R_s) = \\sum_{j \\neq i} e^{-\\eta (R_{ij} - R_s)^2} f_c(R_{ij})\n$$\nHere, $R_{ij}$ is the distance between atoms $i$ and $j$. The parameter $\\eta$ controls the width of the Gaussian functions, and $R_s$ defines the radial distance at which the Gaussian is centered. The sum runs over all neighbors $j$ within a cutoff radius $R_c$. This cutoff is enforced by the cutoff function $f_c(R_{ij})$, which smoothly brings the contribution of each neighbor to zero as its distance approaches $R_c$. A frequently used form for $f_c(R_{ij})$ is the cosine cutoff function:\n$$\nf_c(R_{ij}) = \\begin{cases}\n\\frac{1}{2} \\left( \\cos\\left(\\frac{\\pi R_{ij}}{R_c}\\right) + 1 \\right) & \\text{if } R_{ij} \\le R_c \\\\\n0 & \\text{if } R_{ij} > R_c\n\\end{cases}\n$$\n\nConsider a single atom of an element arranged in an ideal simple cubic (SC) crystal lattice with a lattice constant $a$. For the atom located at the origin of this lattice, derive an analytical expression for the value of the radial symmetry function $G^i(\\eta, R_s)$. Use a cutoff radius of $R_c = \\frac{7}{4}a$. Your final expression should be in terms of the lattice constant $a$ and the symmetry function parameters $\\eta$ and $R_s$.",
            "solution": "1. The radial symmetry function is defined by  \n$$\nG^i(\\eta,R_s)=\\sum_{j\\neq i}e^{-\\eta\\bigl(R_{ij}-R_s\\bigr)^2}f_c(R_{ij})\\,,\n$$\nwith the cosine cutoff  \n$$\nf_c(R)=\\begin{cases}\n\\frac12\\bigl(\\cos(\\pi R/R_c)+1\\bigr)&R\\le R_c,\\\\\n0&R>R_c.\n\\end{cases}\n$$\n\n2. In a simple cubic lattice of constant $a$, atom $i$ at the origin has neighbors at positions $(n_x,n_y,n_z)a$, $n_x,n_y,n_z\\in\\mathbb Z\\setminus\\{0\\}$. Their distances are  \n$$\nR_{n_x,n_y,n_z}=a\\sqrt{n_x^2+n_y^2+n_z^2}\\,.\n$$\n\n3. With cutoff $R_c=\\tfrac74a$, only shells with $n_x^2+n_y^2+n_z^2\\le3$ contribute:\n- $n^2=1$: 6 atoms at $R=a$,\n- $n^2=2$: 12 atoms at $R=a\\sqrt2$,\n- $n^2=3$: 8 atoms at $R=a\\sqrt3$.\n\n4. Thus\n$$\nG^i=\\;6\\,e^{-\\eta(a-R_s)^2}f_c(a)\n\\;+\\;12\\,e^{-\\eta(a\\sqrt2-R_s)^2}f_c(a\\sqrt2)\n\\;+\\;8\\,e^{-\\eta(a\\sqrt3-R_s)^2}f_c(a\\sqrt3).\n$$\n\n5. Compute the cutoff factors, e.g.  \n$$\nf_c(a)=\\tfrac12\\bigl(\\cos(\\tfrac{\\pi a}{R_c})+1\\bigr)\n=\\tfrac12\\bigl(\\cos(\\tfrac{4\\pi}{7})+1\\bigr),\n$$\nand similarly\n$$\nf_c(a\\sqrt2)=\\tfrac12\\bigl(\\cos(\\tfrac{4\\pi\\sqrt2}{7})+1\\bigr),\\quad\nf_c(a\\sqrt3)=\\tfrac12\\bigl(\\cos(\\tfrac{4\\pi\\sqrt3}{7})+1\\bigr).\n$$\n\n6. Substituting and combining factors of $\\tfrac12$ gives  \n$$\nG^i\n=3\\,e^{-\\eta(a-R_s)^2}\\bigl(\\cos(\\tfrac{4\\pi}{7})+1\\bigr)\n+6\\,e^{-\\eta(a\\sqrt2-R_s)^2}\\bigl(\\cos(\\tfrac{4\\pi\\sqrt2}{7})+1\\bigr)\n+4\\,e^{-\\eta(a\\sqrt3-R_s)^2}\\bigl(\\cos(\\tfrac{4\\pi\\sqrt3}{7})+1\\bigr).\n$$",
            "answer": "$$\\boxed{3\\,e^{-\\eta(a-R_s)^2}\\bigl(\\cos\\!\\tfrac{4\\pi}{7}+1\\bigr)\n+6\\,e^{-\\eta(a\\sqrt2-R_s)^2}\\bigl(\\cos\\!\\tfrac{4\\pi\\sqrt2}{7}+1\\bigr)\n+4\\,e^{-\\eta(a\\sqrt3-R_s)^2}\\bigl(\\cos\\!\\tfrac{4\\pi\\sqrt3}{7}+1\\bigr)}$$"
        },
        {
            "introduction": "A cornerstone of both quantum and classical mechanics is the principle of indistinguishability: identical particles cannot be told apart, and swapping their labels must not change any physical observable, such as the total energy. MLIPs must rigorously enforce this permutation invariance to be physically valid. This practice  powerfully illustrates this concept by asking you to analyze a deliberately flawed, non-invariant model, allowing you to quantify the unphysical \"energy splitting\" that arises and appreciate why symmetry is not an optional feature but a fundamental requirement.",
            "id": "3886545",
            "problem": "You are asked to formalize and quantify the consequences of violating permutation invariance among identical atoms in Machine Learning (ML) interatomic potentials within computational catalysis and chemical engineering. The goal is to construct a scenario in which index-dependent features cause artificial energy splitting and to quantify the resulting prediction errors against a physically grounded reference. Start from a physically motivated, permutation-invariant reference energy and use it to analyze a deliberately permutation-variant surrogate model. Your program must produce a single line containing the aggregated numerical results for a test suite of configurations in dimensionless reduced units, rounded to eight decimal places.\n\nFundamental base:\n- Identical atoms are indistinguishable in classical mechanics and quantum mechanics; the total energy must be invariant under any permutation of atom labels. Formally, if there are $N$ identical atoms and a configuration is described by the set of pairwise distances $\\{r_{ij}\\}$, any permutation $\\pi$ in the symmetric group $S_N$ of indices must satisfy $E(\\{r_{ij}\\}) = E(\\{r_{\\pi(i)\\pi(j)}\\})$.\n- A standard, well-tested pairwise energy function for nonbonded interactions is the Lennard-Jones (LJ) potential. In reduced units where the characteristic energy and length scales are set to unity, the total energy for a configuration is computed as\n$$\nE_{\\text{LJ}}(\\mathbf{R}) = \\sum_{1 \\leq i < j \\leq N} 4 \\varepsilon \\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^6\\right],\n$$\nwith $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$, $\\varepsilon$ and $\\sigma$ the energy and length scales, and where the sum over unordered pairs ensures permutation invariance. Use reduced units with $\\varepsilon = 1$ and $\\sigma = 1$, so that energies and distances are dimensionless.\n\nIndex-dependent surrogate model:\n- Define per-atom descriptors that depend on local distances,\n$$\nd_i = \\sum_{\\substack{j=1 \\\\ j \\neq i}}^{N} \\exp\\left(-\\frac{r_{ij}}{\\sigma}\\right), \\quad e_i = \\sum_{\\substack{j=1 \\\\ j \\neq i}}^{N} \\frac{r_{ij}}{\\sigma}.\n$$\n- Construct a deliberately permutation-variant surrogate energy by using index-dependent weights,\n$$\nE_{\\text{bad}}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{N} \\left[a_i \\, d_i + b_i \\, e_i\\right],\n$$\nwhere $\\mathbf{a} = (a_1, \\dots, a_N)$ and $\\mathbf{b} = (b_1, \\dots, b_N)$ depend on the atom index. Under a permutation $\\pi \\in S_N$ of labels, the predicted energy becomes\n$$\nE_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{N} \\left[a_{\\pi(i)} \\, d_i + b_{\\pi(i)} \\, e_i\\right],\n$$\nwhich can differ for identical atoms if the $d_i$ and $e_i$ are not all equal.\n- For comparison, construct a permutation-invariant surrogate with shared weights,\n$$\nE_{\\text{good}}(\\mathbf{R}; a, b) = \\sum_{i=1}^{N} \\left[a \\, d_i + b \\, e_i\\right].\n$$\n\nQuantities to compute per test case:\n- Artificial energy splitting magnitude across a set of label permutations $\\mathcal{P}$,\n$$\n\\Delta_{\\text{split}} = \\max_{\\pi \\in \\mathcal{P}} E_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) - \\min_{\\pi \\in \\mathcal{P}} E_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}).\n$$\n- Maximum absolute prediction error of the index-dependent model across $\\mathcal{P}$, relative to the LJ energy,\n$$\n\\text{Err}_{\\text{bad,max}} = \\max_{\\pi \\in \\mathcal{P}} \\left|E_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) - E_{\\text{LJ}}(\\mathbf{R})\\right|.\n$$\n- Absolute prediction error of the permutation-invariant surrogate (shared weights),\n$$\n\\text{Err}_{\\text{good}} = \\left|E_{\\text{good}}(\\mathbf{R}; a, b) - E_{\\text{LJ}}(\\mathbf{R})\\right|.\n$$\n\nAngle units are irrelevant because only distances are used. All energies and distances must be expressed in dimensionless reduced units with $\\varepsilon = 1$ and $\\sigma = 1$. Round all outputs to eight decimal places.\n\nTest suite:\n- Use the following four configuration cases. Coordinates are given as Cartesian positions in $3$-dimensional space, in reduced units. Use $\\varepsilon = 1$ and $\\sigma = 1$. For each case, apply the set of permutations $\\mathcal{P}$ consisting of the identity and the reverse-index permutation. Shared weights are $a = 0.9$, $b = -0.15$.\n\nCase $1$ (non-symmetric linear triatomic, happy path):\n- $N = 3$,\n- positions: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(1.2, 0.0, 0.0\\right)$, $\\left(2.5, 0.0, 0.0\\right)$,\n- index-dependent weights: $\\mathbf{a} = (0.8, 1.4, 0.5)$, $\\mathbf{b} = (-0.3, 0.2, 0.1)$.\n\nCase $2$ (equilateral triangle, symmetry boundary condition):\n- $N = 3$,\n- side length: $L = 1.6$,\n- positions: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(L, 0.0, 0.0\\right)$, $\\left(\\frac{L}{2}, \\frac{\\sqrt{3}}{2} L, 0.0\\right)$,\n- index-dependent weights: $\\mathbf{a} = (0.8, 1.4, 0.5)$, $\\mathbf{b} = (-0.3, 0.2, 0.1)$.\n\nCase $3$ (diatomic pair, edge case):\n- $N = 2$,\n- positions: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(1.1, 0.0, 0.0\\right)$,\n- index-dependent weights: $\\mathbf{a} = (1.2, 0.7)$, $\\mathbf{b} = (-0.25, 0.05)$.\n\nCase $4$ (four atoms in a non-symmetric rectangular layout):\n- $N = 4$,\n- positions: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(1.4, 0.0, 0.0\\right)$, $\\left(0.0, 2.2, 0.0\\right)$, $\\left(2.1, 2.3, 0.0\\right)$,\n- index-dependent weights: $\\mathbf{a} = (0.7, 1.1, 0.6, 1.5)$, $\\mathbf{b} = (-0.2, 0.25, -0.05, 0.3)$.\n\nRequired final output format:\n- For each case, compute the triple $\\left[\\Delta_{\\text{split}}, \\text{Err}_{\\text{bad,max}}, \\text{Err}_{\\text{good}}\\right]$ as floats. Your program should produce a single line of output containing the list of these per-case triples, rounded to eight decimal places, as a comma-separated list of Python-style lists enclosed in square brackets, for example, $\\left[[x_1,y_1,z_1],[x_2,y_2,z_2],\\dots\\right]$.",
            "solution": "This problem quantifies the error introduced by a machine learning model that fails to respect permutation invariance—the physical principle that identical atoms are indistinguishable. The total energy of a system of $N$ identical atoms must not change when their labels are permuted. Mathematically, for any permutation $\\pi$ of the atom indices $\\{1, \\dots, N\\}$, the energy function $E$ must satisfy $E(\\{\\mathbf{r}_i\\}) = E(\\{\\mathbf{r}_{\\pi(i)}\\})$.\n\nThe solution follows these steps for each test case:\n\n1.  **Calculate Reference Energy:** A physically correct, permutation-invariant reference energy ($E_{\\text{LJ}}$) is calculated using the Lennard-Jones (LJ) potential, which serves as the \"ground truth.\" In the specified reduced units ($\\varepsilon=1$, $\\sigma=1$), this is:\n    $$E_{\\text{LJ}}(\\mathbf{R}) = \\sum_{1 \\leq i  j \\leq N} 4 \\left(r_{ij}^{-12} - r_{ij}^{-6}\\right)$$\n    where $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$ is the distance between atoms $i$ and $j$.\n\n2.  **Calculate Atomic Descriptors:** For each atom $i$, local environment descriptors $d_i$ and $e_i$ are computed from the pairwise distances:\n    $$d_i = \\sum_{j \\neq i} \\exp(-r_{ij}), \\quad e_i = \\sum_{j \\neq i} r_{ij}$$\n\n3.  **Evaluate Surrogate Models:**\n    *   **Permutation-Invariant Model ($E_{\\text{good}}$):** This model uses shared weights ($a, b$) for all atoms, ensuring the total energy is invariant to label permutations.\n        $$E_{\\text{good}}(\\mathbf{R}; a, b) = \\sum_{i=1}^{N} \\left(a \\, d_i + b \\, e_i\\right)$$\n    *   **Permutation-Variant Model ($E_{\\text{bad}}$):** This model deliberately violates invariance by using index-dependent weights ($a_i, b_i$). The energy depends on the specific assignment of labels to atoms.\n        $$E_{\\text{bad}}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{N} \\left(a_i \\, d_i + b_i \\, e_i\\right)$$\n        For a given permutation $\\pi$, the energy is calculated as:\n        $$E_{\\text{bad}}^{(\\pi)}(\\mathbf{R}; \\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{N} \\left(a_{\\pi(i)} \\, d_i + b_{\\pi(i)} \\, e_i\\right)$$\n\n4.  **Quantify Errors:** For the set of permutations $\\mathcal{P}$ (identity and reverse-index), the following metrics are computed:\n    *   **Artificial Energy Splitting ($\\Delta_{\\text{split}}$):** This is the difference between the maximum and minimum energies predicted by the \"bad\" model over the permutations in $\\mathcal{P}$. It directly measures the magnitude of the invariance violation.\n        $$\\Delta_{\\text{split}} = \\max_{\\pi \\in \\mathcal{P}} E_{\\text{bad}}^{(\\pi)} - \\min_{\\pi \\in \\mathcal{P}} E_{\\text{bad}}^{(\\pi)}$$\n    *   **Maximum Error of \"Bad\" Model ($\\text{Err}_{\\text{bad,max}}$):** This is the maximum absolute difference between any of the \"bad\" model's energy predictions and the reference LJ energy.\n        $$\\text{Err}_{\\text{bad,max}} = \\max_{\\pi \\in \\mathcal{P}} \\left|E_{\\text{bad}}^{(\\pi)} - E_{\\text{LJ}}\\right|$$\n    *   **Error of \"Good\" Model ($\\text{Err}_{\\text{good}}$):** This is the absolute difference between the \"good\" model's prediction and the reference LJ energy. It isolates the model's intrinsic representational error from the error caused by broken symmetry.\n        $$\\text{Err}_{\\text{good}} = \\left|E_{\\text{good}} - E_{\\text{LJ}}\\right|$$\n\nBy computing the triplet $[\\Delta_{\\text{split}}, \\text{Err}_{\\text{bad,max}}, \\text{Err}_{\\text{good}}]$ for each case, we systematically analyze the consequences of violating a core physical principle. In symmetric configurations (e.g., a diatomic molecule), where all atomic environments are identical, $\\Delta_{\\text{split}}$ is correctly found to be zero.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes metrics for permutation variance in ML interatomic potentials.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {   # Case 1\n            \"N\": 3,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.2, 0.0, 0.0], \n                [2.5, 0.0, 0.0]\n            ]),\n            \"a_bad\": np.array([0.8, 1.4, 0.5]),\n            \"b_bad\": np.array([-0.3, 0.2, 0.1]),\n        },\n        {   # Case 2\n            \"N\": 3,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.6, 0.0, 0.0], \n                [1.6/2, np.sqrt(3)/2 * 1.6, 0.0]\n            ]),\n            \"a_bad\": np.array([0.8, 1.4, 0.5]),\n            \"b_bad\": np.array([-0.3, 0.2, 0.1]),\n        },\n        {   # Case 3\n            \"N\": 2,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.1, 0.0, 0.0]\n            ]),\n            \"a_bad\": np.array([1.2, 0.7]),\n            \"b_bad\": np.array([-0.25, 0.05]),\n        },\n        {   # Case 4\n            \"N\": 4,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], \n                [1.4, 0.0, 0.0], \n                [0.0, 2.2, 0.0], \n                [2.1, 2.3, 0.0]\n            ]),\n            \"a_bad\": np.array([0.7, 1.1, 0.6, 1.5]),\n            \"b_bad\": np.array([-0.2, 0.25, -0.05, 0.3]),\n        },\n    ]\n\n    # Shared parameters\n    a_good = 0.9\n    b_good = -0.15\n    epsilon = 1.0\n    sigma = 1.0\n    \n    final_results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        positions = case[\"positions\"]\n        a_bad = case[\"a_bad\"]\n        b_bad = case[\"b_bad\"]\n\n        # 1. Calculate the-distance matrix\n        dist_matrix = np.zeros((N, N))\n        if N > 1:\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.linalg.norm(positions[i] - positions[j])\n                    dist_matrix[i, j] = dist\n                    dist_matrix[j, i] = dist\n\n        # 2. Calculate Lennard-Jones reference energy (E_LJ)\n        e_lj = 0.0\n        if N > 1:\n            # np.triu_indices gives upper triangle indices to sum over pairs once\n            i_upper, j_upper = np.triu_indices(N, k=1)\n            r_ij = dist_matrix[i_upper, j_upper]\n            \n            # Filter out zero distances to prevent division by zero\n            r_ij_nonzero = r_ij[r_ij > 0]\n            if r_ij_nonzero.size > 0:\n                inv_r6 = (sigma / r_ij_nonzero)**6\n                inv_r12 = inv_r6**2\n                e_lj = np.sum(4 * epsilon * (inv_r12 - inv_r6))\n\n        # 3. Calculate per-atom descriptors\n        d = np.zeros(N)\n        e = np.zeros(N)\n        if N > 1:\n            for i in range(N):\n                # Distances from atom i to all other atoms j\n                r_i_others = dist_matrix[i, np.arange(N) != i]\n                d[i] = np.sum(np.exp(-r_i_others / sigma))\n                e[i] = np.sum(r_i_others / sigma)\n\n        # 4. Calculate E_bad for identity and reverse permutations\n        # Identity permutation\n        e_bad_id = np.sum(a_bad * d + b_bad * e)\n\n        # Reverse-index permutation\n        pi_rev_indices = np.arange(N - 1, -1, -1)\n        a_bad_rev = a_bad[pi_rev_indices]\n        b_bad_rev = b_bad[pi_rev_indices]\n        e_bad_rev = np.sum(a_bad_rev * d + b_bad_rev * e)\n        \n        e_bad_energies = np.array([e_bad_id, e_bad_rev])\n\n        # 5. Calculate artificial energy splitting (Delta_split)\n        delta_split = np.max(e_bad_energies) - np.min(e_bad_energies)\n\n        # 6. Calculate maximum absolute prediction error for E_bad\n        err_bad_max = np.max(np.abs(e_bad_energies - e_lj))\n\n        # 7. Calculate error for the permutation-invariant model (E_good)\n        e_good = a_good * np.sum(d) + b_good * np.sum(e)\n        err_good = np.abs(e_good - e_lj)\n\n        final_results.append([delta_split, err_bad_max, err_good])\n\n    # Format the final output string as specified\n    result_strings = []\n    for res in final_results:\n        # Create string for each sublist, e.g., \"[val1,val2,val3]\"\n        sublist_str = f\"[{res[0]:.8f},{res[1]:.8f},{res[2]:.8f}]\"\n        result_strings.append(sublist_str)\n    \n    # Join sublist strings and wrap in the final brackets\n    final_output_str = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "An MLIP's purpose extends beyond predicting energies; it must also provide the accurate forces that drive molecular dynamics simulations. The potential energy, a scalar quantity, must be invariant to the system's orientation in space. A direct and crucial consequence of this rotational invariance is that the forces, which are vector quantities, must rotate along with the atomic coordinates—a property known as rotational equivariance. In this exercise , you will implement a numerical rotation test, a standard procedure for validating that a potential correctly translates invariant energy into equivariant forces, ensuring the model will produce physically sound trajectories.",
            "id": "3886576",
            "problem": "You are working with Machine Learning (ML) Interatomic Potentials (IAPs) for atomistic simulations in computational catalysis and chemical engineering. A physically consistent IAP must produce forces that are equivariant under three-dimensional rotations, meaning that when the atomic configuration is rotated by a rotation matrix, the forces rotate in the same way. This property follows from rotational invariance of the potential energy when it depends only on pairwise distances.\n\nStarting from the following fundamental base:\n- The potential energy of a system of $N$ atoms with positions $\\mathbf{x}_1, \\dots, \\mathbf{x}_N$ in $\\mathbb{R}^3$ is a scalar function $E(\\mathbf{X})$ where $\\mathbf{X} = [\\mathbf{x}_1, \\dots, \\mathbf{x}_N]$.\n- The force on atom $i$ is defined as $\\mathbf{F}_i(\\mathbf{X}) = -\\nabla_{\\mathbf{x}_i} E(\\mathbf{X})$.\n- If $E$ depends only on pairwise distances $r_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|$, then for any proper orthogonal matrix $R$ (a rotation), with $R^\\top R = I$ and $\\det(R) = 1$, rotational invariance holds: $E(R\\mathbf{X}) = E(\\mathbf{X})$.\n\nYou will implement a rotation-equivariance validation program using the following energy model that is invariant to rotations and translations:\n- Define the energy as a sum over pairs and radial basis functions,\n$$\nE(\\mathbf{X}) = \\sum_{1 \\le i  j \\le N} \\sum_{k=1}^{K} w_k \\,\\phi_k(r_{ij}),\n$$\nwhere $r_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|$, and each basis function is a Gaussian,\n$$\n\\phi_k(r) = \\exp\\!\\left(-\\frac{(r - \\mu_k)^2}{2\\sigma^2}\\right),\n$$\nwith fixed parameters $\\{\\mu_k\\}_{k=1}^K$, shared width $\\sigma  0$, and weights $\\{w_k\\}_{k=1}^K$.\n\nYour task:\n- Compute the forces $\\mathbf{F}_i(\\mathbf{X}) = -\\nabla_{\\mathbf{x}_i} E(\\mathbf{X})$ for the above $E(\\mathbf{X})$ using first principles and the chain rule.\n- Generate a random proper orthogonal matrix $R$ as a rotation by performing a matrix factorization (e.g., a $QR$ decomposition of a random matrix) and adjust it to ensure $\\det(R) = 1$. Use a fixed, specified integer seed per test case to make the rotation reproducible.\n- For each test case, verify the rotation equivariance by checking that the forces for the rotated configuration satisfy\n$$\n\\mathbf{F}(R\\mathbf{X}) \\approx R \\,\\mathbf{F}(\\mathbf{X}),\n$$\nwithin a specified absolute tolerance $\\tau$, by computing the maximum absolute component-wise deviation\n$$\n\\Delta = \\max_{i \\in \\{1,\\dots,N\\}} \\max_{c \\in \\{x,y,z\\}} \\left|F_{i,c}(R\\mathbf{X}) - \\left(R \\,\\mathbf{F}(\\mathbf{X})\\right)_{i,c}\\right|.\n$$\nIf $\\Delta \\le \\tau$, return the boolean $True$ for that test case; otherwise, return $False$.\n\nAll calculations are to be treated as dimensionless. Angles are not directly used and do not need specification. The final program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n\nUse the following fixed parameters:\n- Number of radial basis functions $K = 4$.\n- Centers $\\mu_1 = 0.5$, $\\mu_2 = 1.0$, $\\mu_3 = 1.5$, $\\mu_4 = 2.5$.\n- Width $\\sigma = 0.5$.\n- Weights $w_1 = 0.8$, $w_2 = -0.4$, $w_3 = 0.3$, $w_4 = 0.2$.\n- Tolerance $\\tau = 10^{-8}$.\n\nTest suite (each case specifies $N$, positions, and the seed for the random rotation generator):\n- Case $1$ (happy path): $N = 3$, positions\n$[ [0.3, -0.1, 0.25], [1.2, 0.4, -0.5], [-0.7, 0.8, 0.6] ]$, seed $12346$.\n- Case $2$ (boundary, single atom): $N = 1$, positions $[ [0.0, 0.0, 0.0] ]$, seed $12347$.\n- Case $3$ (edge, two atoms very close but distinct): $N = 2$, positions $[ [0.0, 0.0, 0.0], [0.001, 0.0, 0.0] ]$, seed $12348$.\n- Case $4$ (larger configuration): $N = 5$, positions\n$[ [0.0, 0.0, 0.0], [1.1, -0.9, 0.3], [-0.4, 0.7, -1.3], [0.8, 0.2, 1.5], [-1.2, -0.6, 0.4] ]$, seed $12349$.\n\nYour program should:\n- Implement the energy and forces as defined.\n- For each test case, generate a random proper orthogonal matrix $R$ with the given seed, compute $\\Delta$, and determine $True$ if $\\Delta \\le \\tau$ or $False$ otherwise.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[True,False,True,True]$).",
            "solution": "To verify the rotational equivariance of forces, we must first derive the analytical expression for the force $\\mathbf{F}_l$ on atom $l$, which is the negative gradient of the potential energy $E(\\mathbf{X})$ with respect to the atom's position $\\mathbf{x}_l$.\n$$\n\\mathbf{F}_l = -\\nabla_{\\mathbf{x}_l} E(\\mathbf{X})\n$$\nThe energy is a sum over unique pairs. For easier differentiation, we can write it as a sum over all ordered pairs with a factor of $1/2$:\n$$\nE(\\mathbf{X}) = \\frac{1}{2} \\sum_{i \\neq j} \\sum_{k=1}^{K} w_k \\phi_k(r_{ij}) \\quad \\text{where} \\quad \\phi_k(r) = \\exp\\left(-\\frac{(r - \\mu_k)^2}{2\\sigma^2}\\right)\n$$\nDifferentiating with respect to $\\mathbf{x}_l$ and applying the chain rule ($\\nabla_{\\mathbf{x}_l} f(r_{lj}) = \\frac{df}{dr} \\nabla_{\\mathbf{x}_l} r_{lj}$), we get:\n$$\n\\mathbf{F}_l = - \\sum_{j \\neq l} \\sum_{k=1}^{K} w_k \\frac{d\\phi_k(r_{lj})}{dr} \\nabla_{\\mathbf{x}_l} r_{lj}\n$$\nThe required derivatives are:\n$$\n\\frac{d\\phi_k}{dr} = -\\frac{r - \\mu_k}{\\sigma^2} \\phi_k(r) \\quad \\text{and} \\quad \\nabla_{\\mathbf{x}_l} r_{lj} = \\frac{\\mathbf{x}_l - \\mathbf{x}_j}{r_{lj}}\n$$\nSubstituting these into the force expression yields the final analytical formula:\n$$\n\\mathbf{F}_l(\\mathbf{X}) = \\sum_{j \\neq l} \\left( \\frac{1}{r_{lj}} \\sum_{k=1}^{K} w_k \\frac{r_{lj} - \\mu_k}{\\sigma^2} \\phi_k(r_{lj}) \\right) (\\mathbf{x}_l - \\mathbf{x}_j)\n$$\nThis shows the force on atom $l$ is a sum of pairwise contributions, each directed along the interatomic vector.\n\nThe numerical verification of rotational equivariance proceeds as follows for each test case:\n1.  **Compute Original Forces:** For a given configuration $\\mathbf{X}$, calculate the forces $\\mathbf{F}(\\mathbf{X})$ on all atoms using the derived formula.\n2.  **Generate Rotation Matrix:** Create a random $3 \\times 3$ proper rotation matrix $R$ (with $R^\\top R = I$ and $\\det(R)=1$) using the specified random seed for reproducibility. This is done via QR decomposition of a random matrix, ensuring the determinant is +1.\n3.  **Compute Rotated Forces (Method 1):** Rotate the atomic configuration to $R\\mathbf{X}$ and compute the forces for this new configuration, $\\mathbf{F}(R\\mathbf{X})$, using the force formula again.\n4.  **Compute Rotated Forces (Method 2):** Apply the rotation matrix $R$ directly to the original force vectors, yielding $R\\,\\mathbf{F}(\\mathbf{X})$.\n5.  **Compare and Verify:** Rotational equivariance requires $\\mathbf{F}(R\\mathbf{X}) = R\\,\\mathbf{F}(\\mathbf{X})$. We verify this by calculating the maximum absolute component-wise deviation, $\\Delta$, between the results of the two methods. If $\\Delta$ is within the tolerance $\\tau = 10^{-8}$, the property holds.\n\nFor the single-atom case ($N=1$), forces are zero by definition, so the condition $R\\mathbf{0} = \\mathbf{0}$ is trivially satisfied.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr\n\ndef solve():\n    \"\"\"\n    Solves the rotation-equivariance validation problem for a simple\n    machine learning interatomic potential.\n    \"\"\"\n    \n    # Define fixed parameters for the potential energy model\n    K = 4\n    MU = np.array([0.5, 1.0, 1.5, 2.5])\n    SIGMA = 0.5\n    W = np.array([0.8, -0.4, 0.3, 0.2])\n    TOLERANCE = 1e-8\n\n    def get_rotation_matrix(seed: int) -> np.ndarray:\n        \"\"\"\n        Generates a random 3x3 proper orthogonal matrix (rotation matrix).\n        \n        Args:\n            seed: An integer seed for the random number generator to ensure\n                  reproducibility.\n        \n        Returns:\n            A 3x3 numpy array representing a rotation matrix R with det(R) = 1.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        random_matrix = rng.random((3, 3))\n        \n        # Use QR decomposition. The Q matrix is orthogonal.\n        q_matrix, _ = qr(random_matrix)\n        \n        # Ensure it's a proper rotation (determinant is +1)\n        if np.linalg.det(q_matrix)  0:\n            q_matrix[:, 0] *= -1\n            \n        return q_matrix\n\n    def compute_forces(positions: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the forces on each atom based on the defined potential.\n        \n        Args:\n            positions: An (N, 3) numpy array of atomic positions.\n        \n        Returns:\n            An (N, 3) numpy array of forces on each atom.\n        \"\"\"\n        num_atoms = positions.shape[0]\n        if num_atoms = 1:\n            return np.zeros_like(positions)\n\n        forces = np.zeros((num_atoms, 3))\n        \n        for i in range(num_atoms):\n            for j in range(num_atoms):\n                if i == j:\n                    continue\n                \n                # Vector and distance from atom i to atom j\n                # Note: We compute r_ij = x_i - x_j\n                r_vec_ij = positions[i] - positions[j]\n                r_dist_ij = np.linalg.norm(r_vec_ij)\n\n                # Avoid division by zero, although problem constraints prevent r_dist_ij=0\n                if r_dist_ij  1e-12:\n                    continue\n\n                # Calculate the scalar prefactor C(r) for the force\n                # F_i = sum_j C(r_ij) * (x_i - x_j)\n                r_minus_mu = r_dist_ij - MU\n                phi_k = np.exp(- (r_minus_mu**2) / (2 * SIGMA**2))\n                \n                sum_term = W * (r_minus_mu / SIGMA**2) * phi_k\n                scalar_prefactor = np.sum(sum_term) / r_dist_ij\n                \n                # Add force contribution from atom j on atom i\n                forces[i] += scalar_prefactor * r_vec_ij\n                \n        return forces\n\n    # Test suite defined in the problem statement\n    test_cases = [\n        {\"N\": 3, \"positions\": np.array([[0.3, -0.1, 0.25], [1.2, 0.4, -0.5], [-0.7, 0.8, 0.6]]), \"seed\": 12346},\n        {\"N\": 1, \"positions\": np.array([[0.0, 0.0, 0.0]]), \"seed\": 12347},\n        {\"N\": 2, \"positions\": np.array([[0.0, 0.0, 0.0], [0.001, 0.0, 0.0]]), \"seed\": 12348},\n        {\"N\": 5, \"positions\": np.array([[0.0, 0.0, 0.0], [1.1, -0.9, 0.3], [-0.4, 0.7, -1.3], [0.8, 0.2, 1.5], [-1.2, -0.6, 0.4]]), \"seed\": 12349},\n    ]\n\n    results = []\n    for case in test_cases:\n        positions = case[\"positions\"]\n        seed = case[\"seed\"]\n\n        # 1. Compute original forces\n        forces_original = compute_forces(positions)\n        \n        # 2. Generate rotation matrix\n        R = get_rotation_matrix(seed)\n        \n        # 3. Rotate positions and compute new forces\n        # For row vectors x_i, rotated position is x_i_rot = x_i @ R.T\n        positions_rotated = positions @ R.T\n        forces_rotated_config = compute_forces(positions_rotated)\n        \n        # 4. Rotate original forces\n        # F_i_rot = F_i @ R.T\n        forces_original_rotated = forces_original @ R.T\n        \n        # 5. Compute deviation and check against tolerance\n        deviation = forces_rotated_config - forces_original_rotated\n        max_abs_deviation = np.max(np.abs(deviation)) if deviation.size > 0 else 0.0\n        \n        is_equivariant = max_abs_deviation = TOLERANCE\n        results.append(is_equivariant)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}