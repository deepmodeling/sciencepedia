{
    "hands_on_practices": [
        {
            "introduction": "This practice serves as a foundational exercise in reactor stability analysis. By calculating the eigenvalues of the system's Jacobian matrix at a given steady state, you will learn to classify these operating points and understand their direct implications for reactor behavior, such as whether a small disturbance will lead to a return to steady state, a runaway reaction, or oscillations. This exercise is essential for connecting the mathematical framework of linear stability theory to tangible operational outcomes in a chemical reactor .",
            "id": "3870179",
            "problem": "Consider a canonical two-dimensional, dimensionless model of a Continuous Stirred-Tank Reactor (CSTR) processing a single irreversible, exothermic, first-order reaction with Arrhenius kinetics and linear heat removal to a constant-temperature coolant. Let the dimensionless reactant concentration be $x$ and the dimensionless reactor temperature be $y$. Define the dimensionless parameters $D_a$ (Damköhler number based on the feed temperature), $\\beta$ (dimensionless activation temperature), $\\kappa$ (dimensionless heat removal coefficient), and $\\theta_c$ (dimensionless coolant-to-feed temperature difference scaled by the adiabatic rise). Under constant volumetric flow and perfectly mixed conditions, the dimensionless mass and energy balances are\n$$\n\\frac{dx}{ds} = 1 - x - D_a \\, r(y) \\, x,\n$$\n$$\n\\frac{dy}{ds} = -y - \\kappa \\left(y - \\theta_c\\right) + D_a \\, r(y) \\, x,\n$$\nwhere $s$ is the dimensionless time and $r(y)$ is the dimensionless Arrhenius factor referenced to the feed temperature,\n$$\nr(y) = \\exp\\!\\left(\\frac{\\beta \\, y}{1+y}\\right),\n$$\nvalid for $y  -1$.\n\nA steady state $(x^\\ast, y^\\ast)$ satisfies\n$$\n0 = 1 - x^\\ast - D_a \\, r(y^\\ast) \\, x^\\ast,\n$$\n$$\n0 = -y^\\ast - \\kappa \\left(y^\\ast - \\theta_c\\right) + D_a \\, r(y^\\ast) \\, x^\\ast.\n$$\nFor any steady state, define the Jacobian matrix $J$ of the right-hand side vector field with entries $J_{ij} = \\partial f_i / \\partial z_j$ evaluated at $(x^\\ast, y^\\ast)$, where $f_1(x,y) = 1 - x - D_a r(y) x$, $f_2(x,y) = -y - \\kappa (y - \\theta_c) + D_a r(y) x$, and $(z_1,z_2) = (x,y)$. The linear stability and type of the steady state are determined by the eigenvalues of $J$.\n\nYour tasks are:\n- Compute all steady states $(x^\\ast,y^\\ast)$ for each parameter set listed below by solving the steady-state equations for $y^\\ast$ over the physically admissible domain $y  -1$ and then obtaining $x^\\ast$ from the mass balance.\n- For each steady state found, construct $J$ and compute its eigenvalues. Classify the steady state using the following integer codes:\n    - $0$: stable node (both eigenvalues real with negative real parts).\n    - $1$: unstable node (both eigenvalues real with positive real parts).\n    - $2$: saddle (real eigenvalues with opposite signs).\n    - $3$: stable spiral (complex conjugate eigenvalues with negative real part).\n    - $4$: unstable spiral (complex conjugate eigenvalues with positive real part).\n- Explain, in your solution, the physical implications of each classification for reactor operation in terms of ignition, extinction, and oscillatory transients.\n\nUse mathematically sound numerical methods. To ensure coverage, locate steady states by scanning for sign changes of the scalar steady-state residual\n$$\nh(y) = -y - \\kappa (y - \\theta_c) + \\frac{D_a \\, r(y)}{1 + D_a \\, r(y)}\n$$\nover a finite search interval strictly within $y \\in (-1, y_{\\max})$ with $y_{\\max} = 6$, and refine each bracketed root using a robust bracketing solver. Sort steady states by increasing $y^\\ast$ before classification output.\n\nAll variables are dimensionless, so no physical units are required. Use angles in radians if any trigonometric functions arise.\n\nTest suite parameter sets:\n1. $(D_a, \\beta, \\kappa, \\theta_c) = (0.15, 12.0, 1.0, -0.20)$.\n2. $(D_a, \\beta, \\kappa, \\theta_c) = (2.50, 22.0, 0.20, -0.05)$.\n3. $(D_a, \\beta, \\kappa, \\theta_c) = (4.00, 30.0, 0.60, -0.10)$.\n4. $(D_a, \\beta, \\kappa, \\theta_c) = (6.00, 25.0, 1.50, -0.30)$.\n\nFinal output format:\nYour program should produce a single line of output containing the classification results for all provided parameter sets as a comma-separated list of lists of integers, enclosed in square brackets. Each inner list must contain the classification codes of all steady states found for that parameter set, in ascending order of $y^\\ast$. For example, a valid output with two cases could look like $[[0],[2,0,3]]$; your exact output will depend on the computed steady states and their classifications for the four specified cases.",
            "solution": "The problem is well-posed and scientifically sound, representing a canonical problem in chemical reaction engineering. It is based on the established conservation laws for mass and energy in a Continuous Stirred-Tank Reactor (CSTR) and standard stability analysis of a two-dimensional dynamical system. All necessary parameters and equations are provided.\n\nThe system dynamics are described by two coupled ordinary differential equations for the dimensionless reactant concentration, $x$, and dimensionless reactor temperature, $y$:\n$$\n\\frac{dx}{ds} = f_1(x,y) = 1 - x - D_a \\, r(y) \\, x\n$$\n$$\n\\frac{dy}{ds} = f_2(x,y) = -y - \\kappa \\left(y - \\theta_c\\right) + D_a \\, r(y) \\, x\n$$\nHere, $s$ is dimensionless time. The parameters are the Damköhler number $D_a$, the dimensionless activation temperature $\\beta$, the dimensionless heat removal coefficient $\\kappa$, and the dimensionless coolant temperature $\\theta_c$. The Arrhenius reaction rate term is given by:\n$$\nr(y) = \\exp\\!\\left(\\frac{\\beta \\, y}{1+y}\\right)\n$$\nThis form is valid for $y  -1$, which corresponds to an absolute temperature greater than $0\\,\\text{K}$.\n\nA steady state $(x^\\ast, y^\\ast)$ is a point where the time derivatives are zero. Setting $\\frac{dx}{ds} = 0$ and $\\frac{dy}{ds} = 0$ gives a system of two algebraic equations:\n$$\n1 - x^\\ast - D_a \\, r(y^\\ast) \\, x^\\ast = 0\n$$\n$$\n-y^\\ast - \\kappa \\left(y^\\ast - \\theta_c\\right) + D_a \\, r(y^\\ast) \\, x^\\ast = 0\n$$\nFrom the first equation (mass balance), we can express $x^\\ast$ in terms of $y^\\ast$:\n$$\nx^\\ast(1 + D_a \\, r(y^\\ast)) = 1 \\implies x^\\ast = \\frac{1}{1 + D_a \\, r(y^\\ast)}\n$$\nSubstituting this expression for $x^\\ast$ into the second equation (energy balance) yields a single scalar equation for $y^\\ast$:\n$$\n-y^\\ast - \\kappa \\left(y^\\ast - \\theta_c\\right) + D_a \\, r(y^\\ast) \\left(\\frac{1}{1 + D_a \\, r(y^\\ast)}\\right) = 0\n$$\nThis equation defines the residual function $h(y^\\ast)$, whose roots are the steady-state temperatures. The problem provides the definition:\n$$\nh(y) = -y - \\kappa (y - \\theta_c) + \\frac{D_a \\, r(y)}{1 + D_a \\, r(y)}\n$$\nWe find the steady-state temperatures $y^\\ast$ by solving $h(y) = 0$. The problem specifies a numerical approach: scan the interval $y \\in (-1, 6)$ for sign changes in $h(y)$ to bracket roots, and then refine them using a robust numerical solver. For each $y^\\ast$ found, the corresponding $x^\\ast$ is calculated from the mass balance.\n\nThe local stability of each steady state $(x^\\ast, y^\\ast)$ is determined by linearizing the system around that point. This involves computing the Jacobian matrix $J$ of the vector field $(f_1, f_2)$:\n$$\nJ = \\begin{pmatrix} \\frac{\\partial f_1}{\\partial x}  \\frac{\\partial f_1}{\\partial y} \\\\ \\frac{\\partial f_2}{\\partial x}  \\frac{\\partial f_2}{\\partial y} \\end{pmatrix}_{(x^\\ast, y^\\ast)}\n$$\nThe partial derivatives are:\n$$\n\\frac{\\partial f_1}{\\partial x} = -1 - D_a \\, r(y)\n$$\n$$\n\\frac{\\partial f_1}{\\partial y} = -D_a \\, x \\, r'(y)\n$$\n$$\n\\frac{\\partial f_2}{\\partial x} = D_a \\, r(y)\n$$\n$$\n\\frac{\\partial f_2}{\\partial y} = -1 - \\kappa + D_a \\, x \\, r'(y)\n$$\nwhere $r'(y)$ is the derivative of $r(y)$ with respect to $y$:\n$$\nr'(y) = \\frac{d}{dy}\\exp\\!\\left(\\frac{\\beta \\, y}{1+y}\\right) = \\exp\\!\\left(\\frac{\\beta \\, y}{1+y}\\right) \\cdot \\frac{d}{dy}\\left(\\frac{\\beta \\, y}{1+y}\\right) = r(y) \\frac{\\beta}{(1+y)^2}\n$$\nThe eigenvalues $\\lambda$ of the Jacobian matrix $J$ evaluated at a steady state determine its stability and type. The eigenvalues are the roots of the characteristic equation $\\det(J - \\lambda I) = 0$, which is $\\lambda^2 - \\text{tr}(J)\\lambda + \\det(J) = 0$. The solution is:\n$$\n\\lambda_{1,2} = \\frac{\\text{tr}(J) \\pm \\sqrt{\\text{tr}(J)^2 - 4\\det(J)}}{2}\n$$\nwhere $\\text{tr}(J) = J_{11} + J_{22}$ is the trace and $\\det(J) = J_{11}J_{22} - J_{12}J_{21}$ is the determinant of the Jacobian. The discriminant $\\Delta = \\text{tr}(J)^2 - 4\\det(J)$ determines whether the eigenvalues are real or complex.\n\nThe classification is as follows:\n- If $\\Delta \\geq 0$, the eigenvalues are real.\n    - If $\\det(J)  0$, the eigenvalues have opposite signs, yielding a **saddle** (code $2$).\n    - If $\\det(J)  0$, the eigenvalues have the same sign. If $\\text{tr}(J)  0$, both are negative, forming a **stable node** (code $0$). If $\\text{tr}(J)  0$, both are positive, forming an **unstable node** (code $1$).\n- If $\\Delta  0$, the eigenvalues are a complex conjugate pair. The real part is $\\text{tr}(J)/2$.\n    - If $\\text{tr}(J)  0$, the real part is negative, yielding a **stable spiral** (code $3$).\n    - If $\\text{tr}(J)  0$, the real part is positive, yielding an **unstable spiral** (code $4$).\n\nPhysical implications of these classifications are:\n- **Stable nodes (0) and stable spirals (3)** are physically realizable operating points. A reactor perturbed from such a state will return to it, either monotonically (node) or with damped oscillations (spiral). Low-temperature stable states correspond to low conversion ('extinguished' state), while high-temperature stable states correspond to high conversion ('ignited' state).\n- **Unstable nodes (1), unstable spirals (4), and saddles (2)** are unstable steady states. Any small perturbation will cause the reactor state to move away. A saddle point is particularly important as it typically separates the basins of attraction of two stable steady states (e.g., the ignited and extinguished states), defining the threshold for ignition.\n\nThe algorithm proceeds as follows:\n1. For each parameter set $(D_a, \\beta, \\kappa, \\theta_c)$:\n2. Define the function $h(y)$ using the given parameters.\n3. Numerically find all roots $y^\\ast$ of $h(y)=0$ in the interval $(-1, 6)$ by bracketing and refining.\n4. For each root $y^\\ast$:\n    a. Calculate the corresponding concentration $x^\\ast = 1 / (1 + D_a r(y^\\ast))$.\n    b. Evaluate all four components of the Jacobian matrix $J$ at $(x^\\ast, y^\\ast)$.\n    c. Compute the trace $\\text{tr}(J)$ and determinant $\\det(J)$.\n    d. Classify the steady state based on the signs of $\\text{tr}(J)$, $\\det(J)$, and the discriminant $\\Delta = \\text{tr}(J)^2 - 4\\det(J)$.\n5. Collect the classification codes for the current parameter set, sorted by increasing $y^\\ast$.\n6. Repeat for all parameter sets and format the final output as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for and classifies steady states of a CSTR for given parameter sets.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.15, 12.0, 1.0, -0.20),\n        (2.50, 22.0, 0.20, -0.05),\n        (4.00, 30.0, 0.60, -0.10),\n        (6.00, 25.0, 1.50, -0.30),\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        Da, beta, kappa, theta_c = params\n\n        # Define the Arrhenius rate term and its derivative\n        def r(y):\n            # The condition y  -1 is handled by the search interval\n            return np.exp(beta * y / (1.0 + y))\n\n        # Define the steady-state residual function h(y) = 0\n        def h(y):\n            ry = r(y)\n            # Heat generation term\n            gen = Da * ry / (1.0 + Da * ry)\n            # Heat removal term (rearranged)\n            rem = y + kappa * (y - theta_c)\n            return gen - rem\n\n        # --- Step 1: Find all steady state temperatures y* ---\n        roots = set()\n        y_search_domain = np.linspace(-1.0 + 1e-9, 6.0, 5001)\n        h_values = h(y_search_domain)\n\n        for i in range(len(y_search_domain) - 1):\n            # Check for a sign change, indicating a bracketed root\n            if np.sign(h_values[i]) != np.sign(h_values[i+1]):\n                try:\n                    y_star = brentq(h, y_search_domain[i], y_search_domain[i+1])\n                    # Add root to a set to avoid duplicates from adjacent intervals\n                    roots.add(y_star)\n                except (RuntimeError, ValueError):\n                    # brentq might fail if the function is not well-behaved\n                    # or if the sign change is at an asymptote.\n                    pass\n        \n        # Sort the unique roots by increasing temperature\n        sorted_y_stars = sorted(list(roots))\n\n        # --- Step 2: Classify each steady state ---\n        case_classifications = []\n        for y_star in sorted_y_stars:\n            # Calculate corresponding steady-state concentration x*\n            r_star = r(y_star)\n            x_star = 1.0 / (1.0 + Da * r_star)\n\n            # Calculate derivative of r(y) at y*\n            r_prime_star = r_star * beta / (1.0 + y_star)**2\n\n            # Construct the Jacobian matrix elements at (x*, y*)\n            J11 = -1.0 - Da * r_star\n            J12 = -Da * x_star * r_prime_star\n            J21 = Da * r_star\n            J22 = -1.0 - kappa + Da * x_star * r_prime_star\n\n            # Calculate trace, determinant, and discriminant\n            trace = J11 + J22\n            determinant = J11 * J22 - J12 * J21\n            discriminant = trace**2 - 4.0 * determinant\n\n            classification_code = -1 # Default/error code\n\n            if discriminant = 0:  # Real eigenvalues\n                if determinant  0:\n                    classification_code = 2  # Saddle\n                else: # determinant = 0\n                    if trace  0:\n                        classification_code = 0  # Stable node\n                    else: # trace = 0\n                        classification_code = 1  # Unstable node\n            else:  # Complex conjugate eigenvalues\n                if trace  0:\n                    classification_code = 3  # Stable spiral\n                else: # trace = 0\n                    classification_code = 4  # Unstable spiral\n\n            case_classifications.append(classification_code)\n\n        all_results.append(case_classifications)\n\n    # --- Final Output Formatting ---\n    # Format: [[c11,c12,...],[c21,c22,...],...] with no spaces\n    result_str = \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond simple kinetics, this practice explores how more realistic reaction mechanisms, like Langmuir-Hinshelwood (LH) kinetics, introduce rich nonlinearities into the reactor model. The non-monotonic dependence of the LH rate on temperature, coupled with thermal effects, can give rise to multiple steady states. Your task is to implement a robust numerical search to find all possible operating points, demonstrating how phenomena like ignition and extinction are fundamentally linked to the underlying kinetic and heat transport parameters .",
            "id": "3870186",
            "problem": "Consider a Continuous Stirred Tank Reactor (CSTR) processing a single gaseous reactant under isothermal feed and external cooling, where the surface reaction follows Langmuir–Hinshelwood (LH) kinetics. The reactor operates at steady feed conditions and may exhibit multiple steady states due to the coupling of reaction heat release and temperature-dependent adsorption and kinetics. Your task is to formulate the steady-state model from first principles, implement a computational algorithm to solve for all physically admissible steady states, and report how many distinct steady-state solutions exist under specified parameter regimes.\n\nFundamental base:\n- Start from the macroscopic mole balance and energy balance for a well-mixed CSTR of volume $V$ and volumetric flow rate $F$. Let $A$ be the reactant with feed concentration $C_{Af}$ and feed temperature $T_f$. Denote the reactor outlet concentration by $C_A$ and reactor temperature by $T$. The residence time is $\\tau = V/F$.\n- Assume a single-site Langmuir–Hinshelwood mechanism for the conversion of $A$ on a catalyst with vacant site requirement, giving the volumetric rate expression\n$$\nr(C_A,T) = k(T)\\,\\frac{K_A(T)\\,C_A}{\\left(1 + K_A(T)\\,C_A\\right)^2},\n$$\nwhere $k(T)$ is the temperature-dependent kinetic coefficient and $K_A(T)$ is the temperature-dependent adsorption equilibrium parameter.\n- The kinetic coefficient follows Arrhenius dependence:\n$$\nk(T) = k_0 \\exp\\left(-\\frac{E_a}{R\\,T}\\right),\n$$\nwhere $k_0$ is the pre-exponential factor, $E_a$ is the activation energy, and $R$ is the universal gas constant.\n- The adsorption parameter follows a van ’t Hoff type temperature dependence about a reference temperature $T_{\\mathrm{ref}}$:\n$$\nK_A(T) = K_{\\mathrm{ref}}\\exp\\left(-\\frac{\\Delta H_{\\mathrm{ads}}}{R}\\left(\\frac{1}{T}-\\frac{1}{T_{\\mathrm{ref}}}\\right)\\right),\n$$\nwhere $K_{\\mathrm{ref}}$ is the adsorption parameter at $T_{\\mathrm{ref}}$ and $\\Delta H_{\\mathrm{ads}}$ is the adsorption enthalpy (negative for exothermic adsorption).\n- The energy balance includes feed–product enthalpy change, reaction heat release, and heat removal to a coolant at temperature $T_c$ with overall heat transfer coefficient times area per volume $(U A / V)$. With mixture density $\\rho$ and heat capacity $C_p$, the steady-state balances are:\n$$\n0 = \\frac{C_{Af} - C_A}{\\tau} - r(C_A,T),\n$$\n$$\n0 = \\frac{T_f - T}{\\tau} + \\frac{-\\Delta H_{\\mathrm{rxn}}}{\\rho C_p}\\,r(C_A,T) - \\beta\\,(T - T_c),\n$$\nwhere $\\Delta H_{\\mathrm{rxn}}$ is the (negative) heat of reaction per mole of $A$, and $\\beta = \\frac{U A}{\\rho C_p V}$ is the volumetric heat removal coefficient.\n\nDefinitions and units to be used in this problem:\n- $C_A$ and $C_{Af}$ in $\\mathrm{mol\\,m^{-3}}$.\n- $T$, $T_f$, $T_c$, and $T_{\\mathrm{ref}}$ in $\\mathrm{K}$.\n- $r$ in $\\mathrm{mol\\,m^{-3}\\,s^{-1}}$.\n- $\\tau$ in $\\mathrm{s}$.\n- $k_0$ in $\\mathrm{mol\\,m^{-3}\\,s^{-1}}$.\n- $E_a$ and $\\Delta H_{\\mathrm{ads}}$ in $\\mathrm{J\\,mol^{-1}}$.\n- $\\Delta H_{\\mathrm{rxn}}$ in $\\mathrm{J\\,mol^{-1}}$.\n- $K_{\\mathrm{ref}}$ and $K_A(T)$ in $\\mathrm{m^{3}\\,mol^{-1}}$.\n- $\\rho$ in $\\mathrm{kg\\,m^{-3}}$, $C_p$ in $\\mathrm{J\\,kg^{-1}\\,K^{-1}}$, $\\beta$ in $\\mathrm{s^{-1}}$, and $R$ in $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$.\n\nAlgorithmic task:\n- For each given parameter set, compute all physically admissible steady states $(C_A,T)$ that solve the coupled nonlinear algebraic equations above. A physically admissible solution must satisfy $C_A \\in [0, C_{Af}]$ and $T \\in [250, 1200]\\,\\mathrm{K}$.\n- Use a robust multi-start nonlinear root-finding approach to locate distinct solutions. Distinct solutions are identified by a Euclidean tolerance of $10^{-6}$ in $C_A$ and $10^{-5}$ in $T$.\n- Report the number of distinct physically admissible steady states found for each parameter set as an integer.\n\nScientific realism requirement:\n- Parameters must be scientifically plausible for gas-phase catalysis. Fix common parameters across test cases as $C_{Af} = 2.0$ $\\mathrm{mol\\,m^{-3}}$, $T_f = 350$ $\\mathrm{K}$, $T_c = 300$ $\\mathrm{K}$, $\\Delta H_{\\mathrm{rxn}} = -120000$ $\\mathrm{J\\,mol^{-1}}$, $\\rho = 1.0$ $\\mathrm{kg\\,m^{-3}}$, $C_p = 1000.0$ $\\mathrm{J\\,kg^{-1}\\,K^{-1}}$, $R = 8.314$ $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$, $k_0 = 1.0$ $\\mathrm{mol\\,m^{-3}\\,s^{-1}}$, $K_{\\mathrm{ref}} = 2.0$ $\\mathrm{m^{3}\\,mol^{-1}}$, and $T_{\\mathrm{ref}} = 350$ $\\mathrm{K}$.\n\nTest suite:\n- Provide six parameter sets $(E_a, \\Delta H_{\\mathrm{ads}}, \\tau, U A / V)$ expressed in $\\mathrm{J\\,mol^{-1}}$, $\\mathrm{J\\,mol^{-1}}$, $\\mathrm{s}$, and $\\mathrm{W\\,m^{-3}\\,K^{-1}}$, respectively. The heat removal coefficient to be used in the energy balance is $\\beta = (U A / V)/(\\rho C_p)$:\n    1. Case 1 (baseline, moderate activation and adsorption): $E_a = 75000$, $\\Delta H_{\\mathrm{ads}} = -60000$, $\\tau = 100$, $U A / V = 50$.\n    2. Case 2 (high activation energy and strong adsorption): $E_a = 110000$, $\\Delta H_{\\mathrm{ads}} = -100000$, $\\tau = 150$, $U A / V = 30$.\n    3. Case 3 (high activation energy, weak adsorption): $E_a = 110000$, $\\Delta H_{\\mathrm{ads}} = -20000$, $\\tau = 150$, $U A / V = 30$.\n    4. Case 4 (low activation energy, strong adsorption): $E_a = 60000$, $\\Delta H_{\\mathrm{ads}} = -100000$, $\\tau = 150$, $U A / V = 30$.\n    5. Case 5 (high activation and strong adsorption, strong cooling): $E_a = 110000$, $\\Delta H_{\\mathrm{ads}} = -100000$, $\\tau = 80$, $U A / V = 150$.\n    6. Case 6 (intermediate-high activation and adsorption, long residence): $E_a = 100000$, $\\Delta H_{\\mathrm{ads}} = -80000$, $\\tau = 200$, $U A / V = 40$.\n\nAnswer specification:\n- For each of the six cases, compute the integer number of distinct physically admissible steady states.\n- There is no angle unit involved; all temperatures must be in $\\mathrm{K}$ and energies in $\\mathrm{J\\,mol^{-1}}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[n_1,n_2,n_3,n_4,n_5,n_6]$), where each $n_i$ is the integer count for case $i$ in the order listed above.",
            "solution": "The problem requires the determination of the number of distinct, physically admissible steady states for a nonisothermal Continuous Stirred Tank Reactor (CSTR) with a catalytic reaction following Langmuir-Hinshelwood (LH) kinetics. This is a classic problem in chemical reaction engineering that demonstrates the phenomenon of steady-state multiplicity. The solution involves formulating the governing nonlinear algebraic equations from first principles and then solving them numerically using a robust computational method.\n\nFirst, we establish the mathematical model of the reactor at steady state. The system is described by two coupled balance equations for the reactant mole balance and the overall energy balance.\n\nThe steady-state mole balance on reactant $A$ equates the rate of reactant consumption by reaction to the net rate of reactant flow into and out of the reactor:\n$$\n\\text{Rate of A in} - \\text{Rate of A out} - \\text{Rate of A consumed} = 0\n$$\n$$\nF C_{Af} - F C_A - V r(C_A, T) = 0\n$$\nDividing by the volumetric flow rate $F$ and using the definition of residence time, $\\tau = V/F$, we obtain the first governing equation:\n$$\nF_1(C_A, T) = \\frac{C_{Af} - C_A}{\\tau} - r(C_A, T) = 0\n$$\nwhere $C_A$ is the reactant concentration in the reactor, $C_{Af}$ is the feed concentration, and $r(C_A, T)$ is the volumetric reaction rate in units of $\\mathrm{mol\\,m^{-3}\\,s^{-1}}$.\n\nThe steady-state energy balance equates the rate of enthalpy entering the reactor to the rate of enthalpy leaving, accounting for the heat released by the exothermic reaction and the heat removed by the external cooling system:\n$$\n\\rho C_p F (T_f - T_{\\text{ref,enthalpy}}) - \\rho C_p F (T - T_{\\text{ref,enthalpy}}) + (-\\Delta H_{\\mathrm{rxn}}) V r(C_A, T) - (UA)(T - T_c) = 0\n$$\nDividing by the reactor volume $V$ and the term $\\rho C_p$, and using $\\tau=V/F$ and $\\beta = \\frac{U A}{\\rho C_p V}$, we arrive at the second governing equation:\n$$\nF_2(C_A, T) = \\frac{T_f - T}{\\tau} + \\frac{-\\Delta H_{\\mathrm{rxn}}}{\\rho C_p} r(C_A, T) - \\beta (T - T_c) = 0\n$$\nHere, $T$ is the reactor temperature, $T_f$ is the feed temperature, $T_c$ is the coolant temperature, $\\Delta H_{\\mathrm{rxn}}$ is the molar heat of reaction (negative for exothermic), $\\rho$ is the fluid density, $C_p$ is the specific heat capacity, and $\\beta$ is the volumetric heat transfer coefficient.\n\nThe reaction kinetics are described by a single-site Langmuir-Hinshelwood model, which accounts for the adsorption of reactant $A$ onto the catalyst surface:\n$$\nr(C_A, T) = k(T) \\frac{K_A(T) C_A}{(1 + K_A(T) C_A)^2}\n$$\nThe temperature dependencies of the kinetic coefficient, $k(T)$, and the adsorption equilibrium constant, $K_A(T)$, introduce strong nonlinearities. The kinetic coefficient follows the Arrhenius law, increasing exponentially with temperature:\n$$\nk(T) = k_0 \\exp\\left(-\\frac{E_a}{R T}\\right)\n$$\nwhere $E_a$ is the activation energy, $k_0$ is the pre-exponential factor, and $R$ is the universal gas constant. The adsorption parameter follows a van 't Hoff-type relation, typically decreasing with temperature for exothermic adsorption ($\\Delta H_{\\mathrm{ads}}  0$):\n$$\nK_A(T) = K_{\\mathrm{ref}} \\exp\\left(-\\frac{\\Delta H_{\\mathrm{ads}}}{R} \\left(\\frac{1}{T} - \\frac{1}{T_{\\mathrm{ref}}}\\right)\\right)\n$$\nwhere $\\Delta H_{\\mathrm{ads}}$ is the enthalpy of adsorption and $K_{\\mathrm{ref}}$ is the adsorption constant at a reference temperature $T_{\\mathrm{ref}}$.\n\nThe steady states of the reactor are the solution pairs $(C_A, T)$ that simultaneously satisfy the two nonlinear equations $F_1(C_A, T) = 0$ and $F_2(C_A, T) = 0$. Due to the complex, non-monotonic dependence of the reaction rate on temperature (a product of the increasing $k(T)$ and decreasing $K_A(T)$), multiple solutions can exist for a single set of operating parameters.\n\nTo find all possible solutions, a single-start numerical solver is insufficient as it is prone to finding only one root, which depends on the initial guess. A multi-start strategy is required. The computational algorithm proceeds as follows:\n1.  A grid of initial guesses for $(C_A, T)$ is generated, covering the entire domain of physically admissible states defined by $C_A \\in [0, C_{Af}]$ and $T \\in [250, 1200]\\,\\mathrm{K}$.\n2.  For each initial guess, a numerical root-finding algorithm (specifically, `scipy.optimize.root`) is employed to solve the system of equations $\\vec{F}(C_A, T) = [F_1, F_2]^T = \\vec{0}$.\n3.  Each result from the solver is validated. A solution is accepted only if the solver converged successfully and the resulting $(C_A, T)$ pair lies within the specified physical boundaries.\n4.  A list of unique solutions is maintained. Each newly found valid solution is compared against all previously stored unique solutions. It is considered a new, distinct solution and added to the list only if it is not within a specified Euclidean tolerance ($\\Delta C_A  10^{-6}$ and $\\Delta T  10^{-5}$) of any existing solution in the list.\n5.  After iterating through all initial guesses, the total number of entries in the unique solutions list gives the number of distinct, physically admissible steady states for the given set of parameters.\n\nThis procedure is repeated for each of the six specified test cases, which vary the parameters $E_a$, $\\Delta H_{\\mathrm{ads}}$, $\\tau$, and $UA/V$. The fixed parameters are given as $C_{Af} = 2.0\\,\\mathrm{mol\\,m^{-3}}$, $T_f = 350\\,\\mathrm{K}$, $T_c = 300\\,\\mathrm{K}$, $\\Delta H_{\\mathrm{rxn}} = -120000\\,\\mathrm{J\\,mol^{-1}}$, $\\rho = 1.0\\,\\mathrm{kg\\,m^{-3}}$, $C_p = 1000.0\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$, $R = 8.314\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$, $k_0 = 1.0\\,\\mathrm{mol\\,m^{-3}\\,s^{-1}}$, $K_{\\mathrm{ref}} = 2.0\\,\\mathrm{m^{3}\\,mol^{-1}}$, and $T_{\\mathrm{ref}} = 350\\,\\mathrm{K}$. The volumetric heat removal coefficient, $\\beta$, is calculated for each case using $\\beta = (U A / V)/(\\rho C_p)$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Solves for the number of steady states in a CSTR with Langmuir-Hinshelwood kinetics\n    for a series of test cases.\n    \"\"\"\n\n    # --- Fixed parameters as defined in the problem statement ---\n    C_Af = 2.0  # mol/m^3\n    T_f = 350.0  # K\n    T_c = 300.0  # K\n    dH_rxn = -120000.0  # J/mol\n    rho = 1.0  # kg/m^3\n    Cp = 1000.0  # J/kg/K\n    R = 8.314  # J/mol/K\n    k0 = 1.0  # mol/m^3/s\n    K_ref = 2.0  # m^3/mol\n    T_ref = 350.0  # K\n\n    # --- Algorithmic specifications ---\n    C_A_TOL = 1e-6\n    T_TOL = 1e-5\n    C_A_BOUNDS = [0.0, C_Af]\n    T_BOUNDS = [250.0, 1200.0]\n    \n    # --- Test cases ---\n    # (Ea, dH_ads, tau, UA/V)\n    test_cases = [\n        (75000, -60000, 100, 50),\n        (110000, -100000, 150, 30),\n        (110000, -20000, 150, 30),\n        (60000, -100000, 150, 30),\n        (110000, -100000, 80, 150),\n        (100000, -80000, 200, 40),\n    ]\n\n    def k_T(T, Ea):\n        \"\"\"Calculates the Arrhenius rate constant.\"\"\"\n        return k0 * np.exp(-Ea / (R * T))\n\n    def K_A_T(T, dH_ads):\n        \"\"\"Calculates the van 't Hoff adsorption constant.\"\"\"\n        return K_ref * np.exp(-dH_ads / R * (1.0 / T - 1.0 / T_ref))\n\n    def reaction_rate(C_A, T, Ea, dH_ads):\n        \"\"\"Calculates the Langmuir-Hinshelwood reaction rate.\"\"\"\n        # Pre-check for numerical stability and physical sense\n        if C_A  0 or T = 0:\n            return np.inf\n        \n        k = k_T(T, Ea)\n        K_A = K_A_T(T, dH_ads)\n        denominator = (1.0 + K_A * C_A)**2\n        \n        if denominator  1e-12:  # Avoid division by zero\n            return np.inf\n            \n        return k * K_A * C_A / denominator\n\n    def system_of_equations(x, Ea, dH_ads, tau, beta):\n        \"\"\"Defines the system of nonlinear equations F(x) = 0.\"\"\"\n        C_A, T = x\n        \n        r = reaction_rate(C_A, T, Ea, dH_ads)\n        \n        # Mole balance equation\n        f1 = (C_Af - C_A) / tau - r\n        \n        # Energy balance equation\n        f2 = (T_f - T) / tau + (-dH_rxn / (rho * Cp)) * r - beta * (T - T_c)\n        \n        return [f1, f2]\n\n    def find_steady_states(params):\n        \"\"\"Implements the multi-start root-finding algorithm.\"\"\"\n        Ea, dH_ads, tau, U_A_per_V = params\n        beta = U_A_per_V / (rho * Cp)\n        \n        found_solutions = []\n        \n        # Create a grid of initial guesses spanning the physical domain\n        n_guesses_C = 20\n        n_guesses_T = 20\n        C_A_guesses = np.linspace(C_A_BOUNDS[0] + 1e-4, C_A_BOUNDS[1] - 1e-4, n_guesses_C)\n        T_guesses = np.linspace(T_BOUNDS[0], T_BOUNDS[1], n_guesses_T)\n        \n        for C_A0 in C_A_guesses:\n            for T0 in T_guesses:\n                initial_guess = [C_A0, T0]\n                \n                # Use scipy's root finder\n                sol = root(system_of_equations, initial_guess, \n                           args=(Ea, dH_ads, tau, beta), method='hybr', tol=1e-9)\n                \n                if sol.success:\n                    C_A_sol, T_sol = sol.x\n                    \n                    # 1. Check for physical admissibility\n                    is_admissible = (C_A_BOUNDS[0] = C_A_sol = C_A_BOUNDS[1]) and \\\n                                    (T_BOUNDS[0] = T_sol = T_BOUNDS[1])\n                    \n                    if is_admissible:\n                        # 2. Check if the solution is distinct from found ones\n                        is_distinct = True\n                        for C_A_found, T_found in found_solutions:\n                            if abs(C_A_sol - C_A_found)  C_A_TOL and abs(T_sol - T_found)  T_TOL:\n                                is_distinct = False\n                                break\n                        \n                        if is_distinct:\n                            found_solutions.append([C_A_sol, T_sol])\n                            \n        return len(found_solutions)\n\n    results = []\n    for case in test_cases:\n        num_solutions = find_steady_states(case)\n        results.append(num_solutions)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This advanced practice elevates the analysis from a single bifurcation parameter to a two-parameter space, allowing us to map the very boundaries of complex behavior. You will locate a cusp bifurcation, a critical point where the region of multiple steady states emerges or vanishes. By deriving and solving the conditions for this higher-order singularity, you will gain insight into how to design reactor operating windows to either leverage or avoid hysteresis and instability .",
            "id": "3870196",
            "problem": "Consider a spatially homogeneous, exothermic, continuously stirred tank reactor governed by conservation of mass and energy at steady state. Let the dimensionless concentration be $c$ and the dimensionless temperature be $\\theta$. Adopt the Frank-Kamenetskii approximation to the Arrhenius law, so that the reaction rate is $r(c,\\theta) = c \\exp(\\beta \\theta)$, where $\\beta  0$ is a dimensionless activation parameter. The steady-state balances are given by\n$$\nf_1(c,\\theta;\\lambda_1,\\lambda_2) = (c_f - c) - \\lambda_1\\, c \\exp(\\beta \\theta) = 0,\n$$\n$$\nf_2(c,\\theta;\\lambda_1,\\lambda_2) = (\\theta_f - \\theta) + \\alpha\\, \\lambda_1\\, c \\exp(\\beta \\theta) - \\lambda_2\\, (\\theta - \\theta_c) = 0,\n$$\nwhere $c_f  0$ is the dimensionless feed concentration, $\\theta_f$ is the dimensionless feed temperature, $\\theta_c$ is the dimensionless coolant temperature, $\\alpha  0$ is the dimensionless adiabatic temperature rise per conversion, $\\lambda_1$ is the Damköhler number, and $\\lambda_2$ is the dimensionless heat removal coefficient.\n\nDefine the vector field $\\mathbf{f}(u;\\lambda) = \\begin{bmatrix} f_1 \\\\ f_2 \\end{bmatrix}$ with state $u = (c,\\theta)$ and parameters $\\lambda = (\\lambda_1,\\lambda_2)$. Its Jacobian with respect to the state is $J(u;\\lambda) = \\partial \\mathbf{f}/\\partial u$. A fold point is characterized by $J$ being singular with a one-dimensional nullspace. A cusp point is a codimension-two degeneracy where two fold curves coalesce. In terms of the steady-state vector field, the cusp point satisfies the system\n$$\n\\mathbf{f}(u;\\lambda) = \\mathbf{0}, \\quad \\det\\big(J(u;\\lambda)\\big) = 0, \\quad w^\\top \\left(D^2 \\mathbf{f}(u)[v,v]\\right) = 0,\n$$\nwhere $v$ and $w$ are unit right and left null vectors of $J$, respectively, satisfying $J v = \\mathbf{0}$, $J^\\top w = \\mathbf{0}$, and $w^\\top v  0$. Here $D^2 \\mathbf{f}(u)[v,v]$ denotes the vector of second directional derivatives of $\\mathbf{f}$ along the direction $v$.\n\nStarting from the fundamental conservation laws and constitutive relation $r(c,\\theta)$, derive a computational procedure to locate cusp points by extending continuation to two parameters $(\\lambda_1,\\lambda_2)$. Use the identities obtained from the steady-state balances to eliminate $(\\lambda_1,\\lambda_2)$ in terms of $(c,\\theta)$,\n$$\n\\lambda_1(c,\\theta) = \\frac{c_f - c}{c \\exp(\\beta \\theta)}, \\quad \\lambda_2(c,\\theta) = \\frac{\\theta_f - \\theta + \\alpha\\,(c_f - c)}{\\theta - \\theta_c},\n$$\nprovided $c \\in (0,c_f)$ and $\\theta \\ne \\theta_c$. Then enforce the fold and cusp degeneracy conditions by solving for $(c,\\theta)$ from\n$$\n\\det\\big(J(c,\\theta;\\lambda_1(c,\\theta),\\lambda_2(c,\\theta))\\big) = 0,\n$$\n$$\nw(c,\\theta)^\\top \\left(D^2 \\mathbf{f}(c,\\theta;\\lambda_1(c,\\theta),\\lambda_2(c,\\theta))[v(c,\\theta),v(c,\\theta)]\\right) = 0,\n$$\nwith $v(c,\\theta)$ and $w(c,\\theta)$ determined by the singular value decomposition of $J$ at $(c,\\theta)$.\n\nAll quantities are dimensionless. Your program must:\n- Implement the above model and conditions.\n- For each test case, compute a cusp point $(c^\\star,\\theta^\\star)$ and report the corresponding parameter pair $(\\lambda_1^\\star,\\lambda_2^\\star)$ along with $(c^\\star,\\theta^\\star)$. If no cusp point is found in the specified search domain, return the list $[\\text{nan},\\text{nan},\\text{nan},\\text{nan}]$.\n\nUse the following test suite of constant sets $(c_f,\\theta_f,\\theta_c,\\alpha,\\beta)$:\n- Test case $1$: $c_f = 1.0$, $\\theta_f = 0.2$, $\\theta_c = 0.0$, $\\alpha = 15.0$, $\\beta = 8.0$.\n- Test case $2$: $c_f = 1.0$, $\\theta_f = 0.0$, $\\theta_c = 0.0$, $\\alpha = 20.0$, $\\beta = 10.0$.\n- Test case $3$: $c_f = 1.0$, $\\theta_f = 0.1$, $\\theta_c = -0.05$, $\\alpha = 12.0$, $\\beta = 9.0$.\n- Edge case $4$: $c_f = 1.0$, $\\theta_f = 0.0$, $\\theta_c = 0.0$, $\\alpha = 3.0$, $\\beta = 2.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a list $[\\lambda_1^\\star,\\lambda_2^\\star,c^\\star,\\theta^\\star]$ for the corresponding test case, in the same order as above. For example: $[[\\lambda_{1,1},\\lambda_{2,1},c_1,\\theta_1],[\\lambda_{1,2},\\lambda_{2,2},c_2,\\theta_2],\\ldots]$.\n\nThe final numerical answers must be floats. No physical units are required because the formulation is dimensionless. Ensure scientific realism by verifying $c^\\star \\in (0,c_f)$, $\\theta^\\star \\ne \\theta_c$, $\\lambda_1^\\star  0$, and $\\lambda_2^\\star  0$; otherwise return $[\\text{nan},\\text{nan},\\text{nan},\\text{nan}]$ for that case.",
            "solution": "The user has provided a problem concerning the location of cusp bifurcation points in a model of a continuously stirred tank reactor (CSTR). The first mandatory step is a rigorous validation of the problem statement.\n\n### Problem Validation\n\nThe problem is self-contained, providing all necessary governing equations, parameter definitions, constant values for test cases, and a clear objective. The model is based on fundamental principles of mass and energy conservation in chemical reaction engineering, and the bifurcation conditions ($\\det(J)=0$, etc.) are standard definitions from dynamical systems theory. The language is precise and objective. All parameters are physically meaningful within the context of the model. The problem is scientifically grounded, well-posed, and objective. It contains no contradictions, ambiguities, or pseudo-scientific claims.\n\n**Verdict:** The problem is valid. The solution process may proceed.\n\n### Derivation of the Computational Procedure\n\nThe objective is to find the cusp point, which is a state $(c^\\star, \\theta^\\star)$ and a corresponding parameter set $(\\lambda_1^\\star, \\lambda_2^\\star)$ satisfying three conditions:\n$$\n\\mathbf{f}(u;\\lambda) = \\mathbf{0} \\quad (1)\n$$\n$$\n\\det\\big(J(u;\\lambda)\\big) = 0 \\quad (2)\n$$\n$$\nw^\\top \\left(D^2 \\mathbf{f}(u)[v,v]\\right) = 0 \\quad (3)\n$$\nThe problem proposes to eliminate parameters $\\lambda_1$ and $\\lambda_2$ using the steady-state conditions (1), and then solve the system formed by conditions (2) and (3) for the state variables $c$ and $\\theta$.\n\nThe steady-state balances are given by:\n$$\nf_1(c,\\theta;\\lambda_1,\\lambda_2) = (c_f - c) - \\lambda_1\\, c e^{\\beta \\theta} = 0\n$$\n$$\nf_2(c,\\theta;\\lambda_1,\\lambda_2) = (\\theta_f - \\theta) + \\alpha\\, \\lambda_1\\, c e^{\\beta \\theta} - \\lambda_2\\, (\\theta - \\theta_c) = 0\n$$\nFrom the first equation, we can express the reaction term as $R = \\lambda_1 c e^{\\beta \\theta} = c_f - c$. Substituting this into the second equation gives $f_2 = (\\theta_f - \\theta) + \\alpha (c_f - c) - \\lambda_2 (\\theta - \\theta_c) = 0$. These yield the expressions for $\\lambda_1(c,\\theta)$ and $\\lambda_2(c,\\theta)$ provided in the problem statement:\n$$\n\\lambda_1(c,\\theta) = \\frac{c_f - c}{c e^{\\beta \\theta}}\n$$\n$$\n\\lambda_2(c,\\theta) = \\frac{\\theta_f - \\theta + \\alpha(c_f - c)}{\\theta - \\theta_c}\n$$\n\n**1. The Fold Condition: $\\det(J) = 0$**\n\nThe Jacobian matrix $J$ of the vector field $\\mathbf{f}$ with respect to the state $u=(c,\\theta)$ is:\n$$\nJ = \\begin{bmatrix} \\frac{\\partial f_1}{\\partial c}  \\frac{\\partial f_1}{\\partial \\theta} \\\\ \\frac{\\partial f_2}{\\partial c}  \\frac{\\partial f_2}{\\partial \\theta} \\end{bmatrix} = \\begin{bmatrix} -1 - \\lambda_1 e^{\\beta \\theta}  - \\lambda_1 c \\beta e^{\\beta \\theta} \\\\ \\alpha \\lambda_1 e^{\\beta \\theta}  -1 - \\lambda_2 + \\alpha \\lambda_1 c \\beta e^{\\beta \\theta} \\end{bmatrix}\n$$\nWe substitute $\\lambda_1 e^{\\beta \\theta} = (c_f-c)/c$ and $\\lambda_1 c e^{\\beta \\theta} = c_f-c$:\n$$\nJ(c,\\theta) = \\begin{bmatrix} -1 - \\frac{c_f-c}{c}  -\\beta (c_f-c) \\\\ \\alpha \\frac{c_f-c}{c}  -1 - \\lambda_2(c,\\theta) + \\alpha \\beta (c_f-c) \\end{bmatrix} = \\begin{bmatrix} -\\frac{c_f}{c}  -\\beta (c_f-c) \\\\ \\alpha \\frac{c_f-c}{c}  -1 - \\lambda_2(c,\\theta) + \\alpha \\beta (c_f-c) \\end{bmatrix}\n$$\nThe fold condition is $\\det(J)=0$:\n$$\n\\left(-\\frac{c_f}{c}\\right) \\left(-1 - \\lambda_2 + \\alpha \\beta (c_f-c)\\right) - \\left(-\\beta (c_f-c)\\right) \\left(\\alpha \\frac{c_f-c}{c}\\right) = 0\n$$\nMultiplying by $c$ (assuming $c \\ne 0$) and simplifying:\n$$\nc_f(1 + \\lambda_2 - \\alpha \\beta (c_f-c)) + \\alpha \\beta (c_f-c)^2 = 0\n$$\n$$\nc_f + c_f\\lambda_2 - c_f \\alpha \\beta (c_f-c) + \\alpha \\beta(c_f-c)^2 = 0\n$$\n$$\nc_f + c_f\\lambda_2 - \\alpha \\beta (c_f-c) (c_f - (c_f-c)) = 0\n$$\n$$\nc_f + c_f\\lambda_2 - \\alpha \\beta c (c_f-c) = 0\n$$\nSubstituting the expression for $\\lambda_2(c,\\theta)$ gives the first equation for our system, $G_1(c,\\theta)=0$:\n$$\nG_1(c,\\theta) = c_f + c_f \\left( \\frac{\\theta_f - \\theta + \\alpha(c_f - c)}{\\theta - \\theta_c} \\right) - \\alpha \\beta c (c_f-c) = 0\n$$\n\n**2. The Cusp Condition: $w^\\top (D^2 \\mathbf{f}[v,v]) = 0$**\n\nFirst, we find the right and left null vectors, $v$ and $w$, of $J$ at a fold point. Since $\\det(J)=0$, the rows and columns are linearly dependent.\nThe right null vector $v = [v_c, v_\\theta]^\\top$ satisfies $Jv=0$. From the first row, $-\\frac{c_f}{c} v_c - \\beta(c_f-c)v_\\theta = 0$. A valid choice for $v$ is $v \\propto [c\\beta(c_f-c), -c_f]^\\top$.\nThe left null vector $w=[w_c, w_\\theta]^\\top$ satisfies $J^\\top w=0$. From the first column, $-\\frac{c_f}{c} w_c + \\alpha\\frac{c_f-c}{c}w_\\theta = 0$. A valid choice for $w$ is $w \\propto [\\alpha(c_f-c), c_f]^\\top$.\n\nNext, we compute the second directional derivative term $D^2 \\mathbf{f}[v,v]$. The components are $v^\\top H_i v$, where $H_i$ is the Hessian of $f_i(c,\\theta)$. The second partial derivatives of $f_1$ and $f_2$ w.r.t. $(c,\\theta)$ are:\n$$\n\\frac{\\partial^2 f_1}{\\partial c^2} = 0, \\quad \\frac{\\partial^2 f_1}{\\partial c \\partial \\theta} = -\\lambda_1 \\beta e^{\\beta \\theta}, \\quad \\frac{\\partial^2 f_1}{\\partial \\theta^2} = -\\lambda_1 c \\beta^2 e^{\\beta \\theta}\n$$\n$$\n\\frac{\\partial^2 f_2}{\\partial c^2} = 0, \\quad \\frac{\\partial^2 f_2}{\\partial c \\partial \\theta} = \\alpha \\lambda_1 \\beta e^{\\beta \\theta}, \\quad \\frac{\\partial^2 f_2}{\\partial \\theta^2} = \\alpha \\lambda_1 c \\beta^2 e^{\\beta \\theta}\n$$\nThe quadratic term $w^\\top(D^2 \\mathbf{f}[v,v])$ becomes:\n$$\nw_c \\left( 2 v_c v_\\theta (-\\lambda_1 \\beta e^{\\beta \\theta}) + v_\\theta^2 (-\\lambda_1 c \\beta^2 e^{\\beta \\theta}) \\right) + w_\\theta \\left( 2 v_c v_\\theta (\\alpha\\lambda_1 \\beta e^{\\beta \\theta}) + v_\\theta^2 (\\alpha\\lambda_1 c \\beta^2 e^{\\beta \\theta}) \\right) = 0\n$$\nFactoring yields:\n$$\n\\lambda_1 \\beta e^{\\beta\\theta} v_\\theta (2 v_c + c \\beta v_\\theta) (-w_c + \\alpha w_\\theta) = 0\n$$\nSince $\\lambda_1, \\beta, e^{\\beta\\theta}$ are positive and $v_\\theta = -c_f \\ne 0$, this simplifies to a product of two terms being zero:\n$$\n(2 v_c + c \\beta v_\\theta) (-w_c + \\alpha w_\\theta) = 0\n$$\nThis means either $(2 v_c + c \\beta v_\\theta) = 0$ or $(-w_c + \\alpha w_\\theta) = 0$.\nSubstituting our null vectors:\nCase (a): $2(c\\beta(c_f-c)) + c\\beta(-c_f) = 2c\\beta c_f - 2c^2\\beta - c\\beta c_f = c\\beta(c_f - 2c) = 0$. Since $c,\\beta \\ne 0$, this gives $c = c_f/2$.\nCase (b): $-\\alpha(c_f-c) + \\alpha(c_f) = -\\alpha c_f + \\alpha c + \\alpha c_f = \\alpha c = 0$. Since $\\alpha0$, this gives $c=0$, which is outside the physically valid domain $(0, c_f)$.\nThus, the cusp condition remarkably simplifies to $c^\\star = c_f/2$.\n\n**3. Analytical Solution for the Cusp Point**\n\nWith $c^\\star = c_f/2$, we can solve for $\\theta^\\star$ using the fold condition equation, $G_1(c_f/2, \\theta) = 0$:\n$$\nc_f + c_f\\lambda_2(c_f/2, \\theta) - \\alpha \\beta (c_f/2) (c_f-c_f/2) = 0\n$$\n$$\nc_f (1+\\lambda_2) - \\frac{\\alpha\\beta c_f^2}{4} = 0 \\implies 1 + \\lambda_2 = \\frac{\\alpha\\beta c_f}{4} \\implies \\lambda_2^\\star = \\frac{\\alpha\\beta c_f}{4} - 1\n$$\nFor $\\lambda_2^\\star$ to be physically meaningful (positive), we must have $\\frac{\\alpha\\beta c_f}{4}  1$, i.e., $\\alpha\\beta c_f  4$. If this inequality does not hold, no physically realistic cusp point exists.\n\nUsing the other form of the fold condition equation to solve for $\\theta^\\star$:\n$$\nc_f + c_f \\left( \\frac{\\theta_f - \\theta + \\alpha(c_f/2)}{\\theta - \\theta_c} \\right) - \\alpha \\beta (c_f/2)(c_f/2) = 0\n$$\n$$\n1 + \\frac{\\theta_f - \\theta + \\alpha c_f/2}{\\theta - \\theta_c} = \\frac{\\alpha\\beta c_f}{4}\n$$\n$$\n\\theta_f - \\theta + \\frac{\\alpha c_f}{2} = \\left(\\frac{\\alpha\\beta c_f}{4} - 1\\right)(\\theta - \\theta_c)\n$$\nSolving for $\\theta$:\n$$\n\\theta_f + \\frac{\\alpha c_f}{2} + \\theta_c\\left(\\frac{\\alpha\\beta c_f}{4} - 1\\right) = \\theta \\left(1 + \\frac{\\alpha\\beta c_f}{4} - 1\\right) = \\theta \\frac{\\alpha\\beta c_f}{4}\n$$\n$$\n\\theta^\\star = \\frac{4}{\\alpha\\beta c_f} \\left(\\theta_f + \\frac{\\alpha c_f}{2} + \\theta_c\\left(\\frac{\\alpha\\beta c_f}{4} - 1\\right)\\right) = \\frac{4\\theta_f}{\\alpha\\beta c_f} + \\frac{2}{\\beta} + \\theta_c - \\frac{4\\theta_c}{\\alpha\\beta c_f}\n$$\n$$\n\\theta^\\star = \\frac{2}{\\beta} + \\theta_c + \\frac{4(\\theta_f - \\theta_c)}{\\alpha\\beta c_f}\n$$\nFinally, we find $\\lambda_1^\\star$ from its definition using $(c^\\star, \\theta^\\star)$:\n$$\n\\lambda_1^\\star = \\frac{c_f - c_f/2}{(c_f/2) e^{\\beta \\theta^\\star}} = \\frac{1}{e^{\\beta \\theta^\\star}} = e^{-\\beta \\theta^\\star}\n$$\n\n**Final Algorithm:**\nFor a given set of parameters $(c_f, \\theta_f, \\theta_c, \\alpha, \\beta)$:\n1. Verify the existence condition: $\\alpha\\beta c_f  4$. If not met, no valid cusp exists.\n2. Calculate the state variables at the cusp:\n   $c^\\star = c_f/2$\n   $\\theta^\\star = \\frac{2}{\\beta} + \\theta_c + \\frac{4(\\theta_f - \\theta_c)}{\\alpha \\beta c_f}$\n3. Verify the non-degeneracy condition $\\theta^\\star \\ne \\theta_c$, which is required for $\\lambda_2$ to be well-defined.\n4. If the conditions in (1) and (3) are met, calculate the bifurcation parameters:\n   $\\lambda_1^\\star = e^{-\\beta \\theta^\\star}$\n   $\\lambda_2^\\star = \\frac{\\alpha \\beta c_f}{4} - 1$\n5. The result is the list $[\\lambda_1^\\star, \\lambda_2^\\star, c^\\star, \\theta^\\star]$. Otherwise, return $[\\text{nan}, \\text{nan}, \\text{nan}, \\text{nan}]$.\n\nThis analytical procedure is computationally exact and robust, and will be implemented in the final program.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the cusp bifurcation point for a CSTR model for a given set of test cases.\n\n    The solution is based on an analytical derivation of the cusp conditions,\n    which simplifies to a direct formula for the cusp state (c*, θ*) and\n    bifurcation parameters (λ1*, λ2*).\n    \"\"\"\n\n    # Test suite of constant sets (c_f, θ_f, θ_c, α, β)\n    test_cases = [\n        # Test case 1\n        (1.0, 0.2, 0.0, 15.0, 8.0),\n        # Test case 2\n        (1.0, 0.0, 0.0, 20.0, 10.0),\n        # Test case 3\n        (1.0, 0.1, -0.05, 12.0, 9.0),\n        # Edge case 4\n        (1.0, 0.0, 0.0, 3.0, 2.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        c_f, theta_f, theta_c, alpha, beta = case\n\n        # A physically meaningful cusp point exists only if α * β * c_f  4.\n        # This ensures that λ2*  0.\n        existence_product = alpha * beta * c_f\n        if existence_product = 4.0:\n            results.append([np.nan, np.nan, np.nan, np.nan])\n            continue\n\n        # Cusp condition simplifies to c* = c_f / 2\n        c_star = c_f / 2.0\n\n        # The fold condition then yields an explicit formula for θ*\n        theta_star = (2.0 / beta) + theta_c + (4.0 * (theta_f - theta_c)) / existence_product\n        \n        # Check validity constraints\n        # 1. c* must be in (0, c_f). c_star = c_f / 2 is always valid for c_f  0.\n        # 2. θ* must not be equal to θ_c for λ2 to be defined.\n        if np.isclose(theta_star, theta_c):\n            results.append([np.nan, np.nan, np.nan, np.nan])\n            continue\n\n        # Calculate parameters λ1* and λ2* at the cusp point.\n        lambda_1_star = np.exp(-beta * theta_star)\n        lambda_2_star = (existence_product / 4.0) - 1.0\n\n        # 3. λ1*  0. This is always true as it's an exponential of a real number.\n        # 4. λ2*  0. This is guaranteed by the initial check `existence_product  4`.\n\n        results.append([lambda_1_star, lambda_2_star, c_star, theta_star])\n\n    # Format the final output string\n    # Convert each inner list to a string representation\n    result_strings = []\n    for res in results:\n        # Format numbers to a reasonable precision for consistent output\n        formatted_res = [f\"{x:.12f}\" if not np.isnan(x) else 'nan' for x in res]\n        result_strings.append(f\"[{','.join(formatted_res)}]\")\n    \n    # a,b,c - [[a],[b],[c]]\n    # Join the string representations of the inner lists\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}