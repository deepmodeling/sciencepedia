{
    "hands_on_practices": [
        {
            "introduction": "A core skill in analyzing any dynamic system is the ability to locate its steady states and determine their stability. This first practice provides a foundational exercise in this process for a canonical Continuous Stirred-Tank Reactor (CSTR) model . You will implement the essential workflow of solving the steady-state equations and then using linear stability analysis—by computing the eigenvalues of the Jacobian matrix—to classify each operating point and understand its physical implications for reactor stability.",
            "id": "3870179",
            "problem": "Consider a canonical two-dimensional, dimensionless model of a Continuous Stirred-Tank Reactor (CSTR) processing a single irreversible, exothermic, first-order reaction with Arrhenius kinetics and linear heat removal to a constant-temperature coolant. Let the dimensionless reactant concentration be $x$ and the dimensionless reactor temperature be $y$. Define the dimensionless parameters $D_a$ (Damköhler number based on the feed temperature), $\\beta$ (dimensionless activation temperature), $\\kappa$ (dimensionless heat removal coefficient), and $\\theta_c$ (dimensionless coolant-to-feed temperature difference scaled by the adiabatic rise). Under constant volumetric flow and perfectly mixed conditions, the dimensionless mass and energy balances are\n$$\n\\frac{dx}{ds} = 1 - x - D_a \\, r(y) \\, x,\n$$\n$$\n\\frac{dy}{ds} = -y - \\kappa \\left(y - \\theta_c\\right) + D_a \\, r(y) \\, x,\n$$\nwhere $s$ is the dimensionless time and $r(y)$ is the dimensionless Arrhenius factor referenced to the feed temperature,\n$$\nr(y) = \\exp\\!\\left(\\frac{\\beta \\, y}{1+y}\\right),\n$$\nvalid for $y > -1$.\n\nA steady state $(x^\\ast, y^\\ast)$ satisfies\n$$\n0 = 1 - x^\\ast - D_a \\, r(y^\\ast) \\, x^\\ast,\n$$\n$$\n0 = -y^\\ast - \\kappa \\left(y^\\ast - \\theta_c\\right) + D_a \\, r(y^\\ast) \\, x^\\ast.\n$$\nFor any steady state, define the Jacobian matrix $J$ of the right-hand side vector field with entries $J_{ij} = \\partial f_i / \\partial z_j$ evaluated at $(x^\\ast, y^\\ast)$, where $f_1(x,y) = 1 - x - D_a r(y) x$, $f_2(x,y) = -y - \\kappa (y - \\theta_c) + D_a r(y) x$, and $(z_1,z_2) = (x,y)$. The linear stability and type of the steady state are determined by the eigenvalues of $J$.\n\nYour tasks are:\n- Compute all steady states $(x^\\ast,y^\\ast)$ for each parameter set listed below by solving the steady-state equations for $y^\\ast$ over the physically admissible domain $y > -1$ and then obtaining $x^\\ast$ from the mass balance.\n- For each steady state found, construct $J$ and compute its eigenvalues. Classify the steady state using the following integer codes:\n    - $0$: stable node (both eigenvalues real with negative real parts).\n    - $1$: unstable node (both eigenvalues real with positive real parts).\n    - $2$: saddle (real eigenvalues with opposite signs).\n    - $3$: stable spiral (complex conjugate eigenvalues with negative real part).\n    - $4$: unstable spiral (complex conjugate eigenvalues with positive real part).\n- Explain, in your solution, the physical implications of each classification for reactor operation in terms of ignition, extinction, and oscillatory transients.\n\nUse mathematically sound numerical methods. To ensure coverage, locate steady states by scanning for sign changes of the scalar steady-state residual\n$$\nh(y) = -y - \\kappa (y - \\theta_c) + \\frac{D_a \\, r(y)}{1 + D_a \\, r(y)}\n$$\nover a finite search interval strictly within $y \\in (-1, y_{\\max})$ with $y_{\\max} = 6$, and refine each bracketed root using a robust bracketing solver. Sort steady states by increasing $y^\\ast$ before classification output.\n\nAll variables are dimensionless, so no physical units are required. Use angles in radians if any trigonometric functions arise.\n\nTest suite parameter sets:\n1. $(D_a, \\beta, \\kappa, \\theta_c) = (0.15, 12.0, 1.0, -0.20)$.\n2. $(D_a, \\beta, \\kappa, \\theta_c) = (2.50, 22.0, 0.20, -0.05)$.\n3. $(D_a, \\beta, \\kappa, \\theta_c) = (4.00, 30.0, 0.60, -0.10)$.\n4. $(D_a, \\beta, \\kappa, \\theta_c) = (6.00, 25.0, 1.50, -0.30)$.\n\nFinal output format:\nYour program should produce a single line of output containing the classification results for all provided parameter sets as a comma-separated list of lists of integers, enclosed in square brackets. Each inner list must contain the classification codes of all steady states found for that parameter set, in ascending order of $y^\\ast$. For example, a valid output with two cases could look like $[[0],[2,0,3]]$; your exact output will depend on the computed steady states and their classifications for the four specified cases.",
            "solution": "The problem is well-posed and scientifically sound, representing a canonical problem in chemical reaction engineering. It is based on the established conservation laws for mass and energy in a Continuous Stirred-Tank Reactor (CSTR) and standard stability analysis of a two-dimensional dynamical system. All necessary parameters and equations are provided.\n\nThe system dynamics are described by two coupled ordinary differential equations for the dimensionless reactant concentration, $x$, and dimensionless reactor temperature, $y$:\n$$\n\\frac{dx}{ds} = f_1(x,y) = 1 - x - D_a \\, r(y) \\, x\n$$\n$$\n\\frac{dy}{ds} = f_2(x,y) = -y - \\kappa \\left(y - \\theta_c\\right) + D_a \\, r(y) \\, x\n$$\nHere, $s$ is dimensionless time. The parameters are the Damköhler number $D_a$, the dimensionless activation temperature $\\beta$, the dimensionless heat removal coefficient $\\kappa$, and the dimensionless coolant temperature $\\theta_c$. The Arrhenius reaction rate term is given by:\n$$\nr(y) = \\exp\\!\\left(\\frac{\\beta \\, y}{1+y}\\right)\n$$\nThis form is valid for $y > -1$, which corresponds to an absolute temperature greater than $0\\,\\text{K}$.\n\nA steady state $(x^\\ast, y^\\ast)$ is a point where the time derivatives are zero. Setting $\\frac{dx}{ds} = 0$ and $\\frac{dy}{ds} = 0$ gives a system of two algebraic equations:\n$$\n1 - x^\\ast - D_a \\, r(y^\\ast) \\, x^\\ast = 0\n$$\n$$\n-y^\\ast - \\kappa \\left(y^\\ast - \\theta_c\\right) + D_a \\, r(y^\\ast) \\, x^\\ast = 0\n$$\nFrom the first equation (mass balance), we can express $x^\\ast$ in terms of $y^\\ast$:\n$$\nx^\\ast(1 + D_a \\, r(y^\\ast)) = 1 \\implies x^\\ast = \\frac{1}{1 + D_a \\, r(y^\\ast)}\n$$\nSubstituting this expression for $x^\\ast$ into the second equation (energy balance) yields a single scalar equation for $y^\\ast$:\n$$\n-y^\\ast - \\kappa \\left(y^\\ast - \\theta_c\\right) + D_a \\, r(y^\\ast) \\left(\\frac{1}{1 + D_a \\, r(y^\\ast)}\\right) = 0\n$$\nThis equation defines the residual function $h(y^\\ast)$, whose roots are the steady-state temperatures. The problem provides the definition:\n$$\nh(y) = -y - \\kappa (y - \\theta_c) + \\frac{D_a \\, r(y)}{1 + D_a \\, r(y)}\n$$\nWe find the steady-state temperatures $y^\\ast$ by solving $h(y) = 0$. The problem specifies a numerical approach: scan the interval $y \\in (-1, 6)$ for sign changes in $h(y)$ to bracket roots, and then refine them using a robust numerical solver. For each $y^\\ast$ found, the corresponding $x^\\ast$ is calculated from the mass balance.\n\nThe local stability of each steady state $(x^\\ast, y^\\ast)$ is determined by linearizing the system around that point. This involves computing the Jacobian matrix $J$ of the vector field $(f_1, f_2)$:\n$$\nJ = \\begin{pmatrix} \\frac{\\partial f_1}{\\partial x}  \\frac{\\partial f_1}{\\partial y} \\\\ \\frac{\\partial f_2}{\\partial x}  \\frac{\\partial f_2}{\\partial y} \\end{pmatrix}_{(x^\\ast, y^\\ast)}\n$$\nThe partial derivatives are:\n$$\n\\frac{\\partial f_1}{\\partial x} = -1 - D_a \\, r(y)\n$$\n$$\n\\frac{\\partial f_1}{\\partial y} = -D_a \\, x \\, r'(y)\n$$\n$$\n\\frac{\\partial f_2}{\\partial x} = D_a \\, r(y)\n$$\n$$\n\\frac{\\partial f_2}{\\partial y} = -1 - \\kappa + D_a \\, x \\, r'(y)\n$$\nwhere $r'(y)$ is the derivative of $r(y)$ with respect to $y$:\n$$\nr'(y) = \\frac{d}{dy}\\exp\\!\\left(\\frac{\\beta \\, y}{1+y}\\right) = \\exp\\!\\left(\\frac{\\beta \\, y}{1+y}\\right) \\cdot \\frac{d}{dy}\\left(\\frac{\\beta \\, y}{1+y}\\right) = r(y) \\frac{\\beta}{(1+y)^2}\n$$\nThe eigenvalues $\\lambda$ of the Jacobian matrix $J$ evaluated at a steady state determine its stability and type. The eigenvalues are the roots of the characteristic equation $\\det(J - \\lambda I) = 0$, which is $\\lambda^2 - \\text{tr}(J)\\lambda + \\det(J) = 0$. The solution is:\n$$\n\\lambda_{1,2} = \\frac{\\text{tr}(J) \\pm \\sqrt{\\text{tr}(J)^2 - 4\\det(J)}}{2}\n$$\nwhere $\\text{tr}(J) = J_{11} + J_{22}$ is the trace and $\\det(J) = J_{11}J_{22} - J_{12}J_{21}$ is the determinant of the Jacobian. The discriminant $\\Delta = \\text{tr}(J)^2 - 4\\det(J)$ determines whether the eigenvalues are real or complex.\n\nThe classification is as follows:\n- If $\\Delta \\geq 0$, the eigenvalues are real.\n    - If $\\det(J)  0$, the eigenvalues have opposite signs, yielding a **saddle** (code $2$).\n    - If $\\det(J) > 0$, the eigenvalues have the same sign. If $\\text{tr}(J)  0$, both are negative, forming a **stable node** (code $0$). If $\\text{tr}(J)  0$, both are positive, forming an **unstable node** (code $1$).\n- If $\\Delta  0$, the eigenvalues are a complex conjugate pair. The real part is $\\text{tr}(J)/2$.\n    - If $\\text{tr}(J)  0$, the real part is negative, yielding a **stable spiral** (code $3$).\n    - If $\\text{tr}(J)  0$, the real part is positive, yielding an **unstable spiral** (code $4$).\n\nPhysical implications of these classifications are:\n- **Stable nodes (0) and stable spirals (3)** are physically realizable operating points. A reactor perturbed from such a state will return to it, either monotonically (node) or with damped oscillations (spiral). Low-temperature stable states correspond to low conversion ('extinguished' state), while high-temperature stable states correspond to high conversion ('ignited' state).\n- **Unstable nodes (1), unstable spirals (4), and saddles (2)** are unstable steady states. Any small perturbation will cause the reactor state to move away. A saddle point is particularly important as it typically separates the basins of attraction of two stable steady states (e.g., the ignited and extinguished states), defining the threshold for ignition.\n\nThe algorithm proceeds as follows:\n1. For each parameter set $(D_a, \\beta, \\kappa, \\theta_c)$:\n2. Define the function $h(y)$ using the given parameters.\n3. Numerically find all roots $y^\\ast$ of $h(y)=0$ in the interval $(-1, 6)$ by bracketing and refining.\n4. For each root $y^\\ast$:\n    a. Calculate the corresponding concentration $x^\\ast = 1 / (1 + D_a r(y^\\ast))$.\n    b. Evaluate all four components of the Jacobian matrix $J$ at $(x^\\ast, y^\\ast)$.\n    c. Compute the trace $\\text{tr}(J)$ and determinant $\\det(J)$.\n    d. Classify the steady state based on the signs of $\\text{tr}(J)$, $\\det(J)$, and the discriminant $\\Delta = \\text{tr}(J)^2 - 4\\det(J)$.\n5. Collect the classification codes for the current parameter set, sorted by increasing $y^\\ast$.\n6. Repeat for all parameter sets and format the final output as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for and classifies steady states of a CSTR for given parameter sets.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.15, 12.0, 1.0, -0.20),\n        (2.50, 22.0, 0.20, -0.05),\n        (4.00, 30.0, 0.60, -0.10),\n        (6.00, 25.0, 1.50, -0.30),\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        Da, beta, kappa, theta_c = params\n\n        # Define the Arrhenius rate term and its derivative\n        def r(y):\n            # The condition y  -1 is handled by the search interval\n            return np.exp(beta * y / (1.0 + y))\n\n        # Define the steady-state residual function h(y) = 0\n        def h(y):\n            ry = r(y)\n            # Heat generation term\n            gen = Da * ry / (1.0 + Da * ry)\n            # Heat removal term (rearranged)\n            rem = y + kappa * (y - theta_c)\n            return gen - rem\n\n        # --- Step 1: Find all steady state temperatures y* ---\n        roots = set()\n        y_search_domain = np.linspace(-1.0 + 1e-9, 6.0, 5001)\n        h_values = h(y_search_domain)\n\n        for i in range(len(y_search_domain) - 1):\n            # Check for a sign change, indicating a bracketed root\n            if np.sign(h_values[i]) != np.sign(h_values[i+1]):\n                try:\n                    y_star = brentq(h, y_search_domain[i], y_search_domain[i+1])\n                    # Add root to a set to avoid duplicates from adjacent intervals\n                    roots.add(y_star)\n                except (RuntimeError, ValueError):\n                    # brentq might fail if the function is not well-behaved\n                    # or if the sign change is at an asymptote.\n                    pass\n        \n        # Sort the unique roots by increasing temperature\n        sorted_y_stars = sorted(list(roots))\n\n        # --- Step 2: Classify each steady state ---\n        case_classifications = []\n        for y_star in sorted_y_stars:\n            # Calculate corresponding steady-state concentration x*\n            r_star = r(y_star)\n            x_star = 1.0 / (1.0 + Da * r_star)\n\n            # Calculate derivative of r(y) at y*\n            r_prime_star = r_star * beta / (1.0 + y_star)**2\n\n            # Construct the Jacobian matrix elements at (x*, y*)\n            J11 = -1.0 - Da * r_star\n            J12 = -Da * x_star * r_prime_star\n            J21 = Da * r_star\n            J22 = -1.0 - kappa + Da * x_star * r_prime_star\n\n            # Calculate trace, determinant, and discriminant\n            trace = J11 + J22\n            determinant = J11 * J22 - J12 * J21\n            discriminant = trace**2 - 4.0 * determinant\n\n            classification_code = -1 # Default/error code\n\n            if discriminant = 0:  # Real eigenvalues\n                if determinant  0:\n                    classification_code = 2  # Saddle\n                else: # determinant = 0\n                    if trace  0:\n                        classification_code = 0  # Stable node\n                    else: # trace = 0\n                        classification_code = 1  # Unstable node\n            else:  # Complex conjugate eigenvalues\n                if trace  0:\n                    classification_code = 3  # Stable spiral\n                else: # trace = 0\n                    classification_code = 4  # Unstable spiral\n\n            case_classifications.append(classification_code)\n\n        all_results.append(case_classifications)\n\n    # --- Final Output Formatting ---\n    # Format: [[c11,c12,...],[c21,c22,...],...] with no spaces\n    result_str = \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While simple Arrhenius kinetics are instructive, many real catalytic reactions follow more complex mechanisms like the Langmuir-Hinshelwood (LH) model, where the rate can be a non-monotonic function of temperature. This practice explores how such kinetics can give rise to multiple steady states, a hallmark of complex reactor behavior . Your task is to develop a robust numerical strategy to find all physically admissible steady states, demonstrating how parameter changes can lead to the appearance or disappearance of stable operating regimes.",
            "id": "3870186",
            "problem": "Consider a Continuous Stirred Tank Reactor (CSTR) processing a single gaseous reactant under isothermal feed and external cooling, where the surface reaction follows Langmuir–Hinshelwood (LH) kinetics. The reactor operates at steady feed conditions and may exhibit multiple steady states due to the coupling of reaction heat release and temperature-dependent adsorption and kinetics. Your task is to formulate the steady-state model from first principles, implement a computational algorithm to solve for all physically admissible steady states, and report how many distinct steady-state solutions exist under specified parameter regimes.\n\nFundamental base:\n- Start from the macroscopic mole balance and energy balance for a well-mixed CSTR of volume $V$ and volumetric flow rate $F$. Let $A$ be the reactant with feed concentration $C_{Af}$ and feed temperature $T_f$. Denote the reactor outlet concentration by $C_A$ and reactor temperature by $T$. The residence time is $\\tau = V/F$.\n- Assume a single-site Langmuir–Hinshelwood mechanism for the conversion of $A$ on a catalyst with vacant site requirement, giving the volumetric rate expression\n$$\nr(C_A,T) = k(T)\\,\\frac{K_A(T)\\,C_A}{\\left(1 + K_A(T)\\,C_A\\right)^2},\n$$\nwhere $k(T)$ is the temperature-dependent kinetic coefficient and $K_A(T)$ is the temperature-dependent adsorption equilibrium parameter.\n- The kinetic coefficient follows Arrhenius dependence:\n$$\nk(T) = k_0 \\exp\\left(-\\frac{E_a}{R\\,T}\\right),\n$$\nwhere $k_0$ is the pre-exponential factor, $E_a$ is the activation energy, and $R$ is the universal gas constant.\n- The adsorption parameter follows a van ’t Hoff type temperature dependence about a reference temperature $T_{\\mathrm{ref}}$:\n$$\nK_A(T) = K_{\\mathrm{ref}}\\exp\\left(-\\frac{\\Delta H_{\\mathrm{ads}}}{R}\\left(\\frac{1}{T}-\\frac{1}{T_{\\mathrm{ref}}}\\right)\\right),\n$$\nwhere $K_{\\mathrm{ref}}$ is the adsorption parameter at $T_{\\mathrm{ref}}$ and $\\Delta H_{\\mathrm{ads}}$ is the adsorption enthalpy (negative for exothermic adsorption).\n- The energy balance includes feed–product enthalpy change, reaction heat release, and heat removal to a coolant at temperature $T_c$ with overall heat transfer coefficient times area per volume $(U A / V)$. With mixture density $\\rho$ and heat capacity $C_p$, the steady-state balances are:\n$$\n0 = \\frac{C_{Af} - C_A}{\\tau} - r(C_A,T),\n$$\n$$\n0 = \\frac{T_f - T}{\\tau} + \\frac{-\\Delta H_{\\mathrm{rxn}}}{\\rho C_p}\\,r(C_A,T) - \\beta\\,(T - T_c),\n$$\nwhere $\\Delta H_{\\mathrm{rxn}}$ is the (negative) heat of reaction per mole of $A$, and $\\beta = \\frac{U A}{\\rho C_p V}$ is the volumetric heat removal coefficient.\n\nDefinitions and units to be used in this problem:\n- $C_A$ and $C_{Af}$ in $\\mathrm{mol\\,m^{-3}}$.\n- $T$, $T_f$, $T_c$, and $T_{\\mathrm{ref}}$ in $\\mathrm{K}$.\n- $r$ in $\\mathrm{mol\\,m^{-3}\\,s^{-1}}$.\n- $\\tau$ in $\\mathrm{s}$.\n- $k_0$ in $\\mathrm{mol\\,m^{-3}\\,s^{-1}}$.\n- $E_a$ and $\\Delta H_{\\mathrm{ads}}$ in $\\mathrm{J\\,mol^{-1}}$.\n- $\\Delta H_{\\mathrm{rxn}}$ in $\\mathrm{J\\,mol^{-1}}$.\n- $K_{\\mathrm{ref}}$ and $K_A(T)$ in $\\mathrm{m^{3}\\,mol^{-1}}$.\n- $\\rho$ in $\\mathrm{kg\\,m^{-3}}$, $C_p$ in $\\mathrm{J\\,kg^{-1}\\,K^{-1}}$, $\\beta$ in $\\mathrm{s^{-1}}$, and $R$ in $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$.\n\nAlgorithmic task:\n- For each given parameter set, compute all physically admissible steady states $(C_A,T)$ that solve the coupled nonlinear algebraic equations above. A physically admissible solution must satisfy $C_A \\in [0, C_{Af}]$ and $T \\in [250, 1200]$ $\\mathrm{K}$.\n- Use a robust multi-start nonlinear root-finding approach to locate distinct solutions. Distinct solutions are identified by a Euclidean tolerance of $10^{-6}$ in $C_A$ and $10^{-5}$ in $T$.\n- Report the number of distinct physically admissible steady states found for each parameter set as an integer.\n\nScientific realism requirement:\n- Parameters must be scientifically plausible for gas-phase catalysis. Fix common parameters across test cases as $C_{Af} = 2.0$ $\\mathrm{mol\\,m^{-3}}$, $T_f = 350$ $\\mathrm{K}$, $T_c = 300$ $\\mathrm{K}$, $\\Delta H_{\\mathrm{rxn}} = -120000$ $\\mathrm{J\\,mol^{-1}}$, $\\rho = 1.0$ $\\mathrm{kg\\,m^{-3}}$, $C_p = 1000.0$ $\\mathrm{J\\,kg^{-1}\\,K^{-1}}$, $R = 8.314$ $\\mathrm{J\\,mol^{-1}\\,K^{-1}}$, $k_0 = 1.0$ $\\mathrm{mol\\,m^{-3}\\,s^{-1}}$, $K_{\\mathrm{ref}} = 2.0$ $\\mathrm{m^{3}\\,mol^{-1}}$, and $T_{\\mathrm{ref}} = 350$ $\\mathrm{K}$.\n\nTest suite:\n- Provide six parameter sets $(E_a, \\Delta H_{\\mathrm{ads}}, \\tau, U A / V)$ expressed in $\\mathrm{J\\,mol^{-1}}$, $\\mathrm{J\\,mol^{-1}}$, $\\mathrm{s}$, and $\\mathrm{W\\,m^{-3}\\,K^{-1}}$, respectively. The heat removal coefficient to be used in the energy balance is $\\beta = (U A / V)/(\\rho C_p)$:\n    1. Case 1 (baseline, moderate activation and adsorption): $E_a = 75000$, $\\Delta H_{\\mathrm{ads}} = -60000$, $\\tau = 100$, $U A / V = 50$.\n    2. Case 2 (high activation energy and strong adsorption): $E_a = 110000$, $\\Delta H_{\\mathrm{ads}} = -100000$, $\\tau = 150$, $U A / V = 30$.\n    3. Case 3 (high activation energy, weak adsorption): $E_a = 110000$, $\\Delta H_{\\mathrm{ads}} = -20000$, $\\tau = 150$, $U A / V = 30$.\n    4. Case 4 (low activation energy, strong adsorption): $E_a = 60000$, $\\Delta H_{\\mathrm{ads}} = -100000$, $\\tau = 150$, $U A / V = 30$.\n    5. Case 5 (high activation and strong adsorption, strong cooling): $E_a = 110000$, $\\Delta H_{\\mathrm{ads}} = -100000$, $\\tau = 80$, $U A / V = 150$.\n    6. Case 6 (intermediate-high activation and adsorption, long residence): $E_a = 100000$, $\\Delta H_{\\mathrm{ads}} = -80000$, $\\tau = 200$, $U A / V = 40$.\n\nAnswer specification:\n- For each of the six cases, compute the integer number of distinct physically admissible steady states.\n- There is no angle unit involved; all temperatures must be in $\\mathrm{K}$ and energies in $\\mathrm{J\\,mol^{-1}}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[n_1,n_2,n_3,n_4,n_5,n_6]$), where each $n_i$ is the integer count for case $i$ in the order listed above.",
            "solution": "The problem requires the determination of the number of distinct, physically admissible steady states for a nonisothermal Continuous Stirred Tank Reactor (CSTR) with a catalytic reaction following Langmuir-Hinshelwood (LH) kinetics. This is a classic problem in chemical reaction engineering that demonstrates the phenomenon of steady-state multiplicity. The solution involves formulating the governing nonlinear algebraic equations from first principles and then solving them numerically using a robust computational method.\n\nFirst, we establish the mathematical model of the reactor at steady state. The system is described by two coupled balance equations for the reactant mole balance and the overall energy balance.\n\nThe steady-state mole balance on reactant $A$ equates the rate of reactant consumption by reaction to the net rate of reactant flow into and out of the reactor:\n$$\n\\text{Rate of A in} - \\text{Rate of A out} - \\text{Rate of A consumed} = 0\n$$\n$$\nF C_{Af} - F C_A - V r(C_A, T) = 0\n$$\nDividing by the volumetric flow rate $F$ and using the definition of residence time, $\\tau = V/F$, we obtain the first governing equation:\n$$\nF_1(C_A, T) = \\frac{C_{Af} - C_A}{\\tau} - r(C_A, T) = 0\n$$\nwhere $C_A$ is the reactant concentration in the reactor, $C_{Af}$ is the feed concentration, and $r(C_A, T)$ is the volumetric reaction rate in units of $\\mathrm{mol\\,m^{-3}\\,s^{-1}}$.\n\nThe steady-state energy balance equates the rate of enthalpy entering the reactor to the rate of enthalpy leaving, accounting for the heat released by the exothermic reaction and the heat removed by the external cooling system:\n$$\n\\rho C_p F (T_f - T_{\\text{ref,enthalpy}}) - \\rho C_p F (T - T_{\\text{ref,enthalpy}}) + (-\\Delta H_{\\mathrm{rxn}}) V r(C_A, T) - (UA)(T - T_c) = 0\n$$\nDividing by the reactor volume $V$ and the term $\\rho C_p$, and using $\\tau=V/F$ and $\\beta = \\frac{U A}{\\rho C_p V}$, we arrive at the second governing equation:\n$$\nF_2(C_A, T) = \\frac{T_f - T}{\\tau} + \\frac{-\\Delta H_{\\mathrm{rxn}}}{\\rho C_p} r(C_A, T) - \\beta (T - T_c) = 0\n$$\nHere, $T$ is the reactor temperature, $T_f$ is the feed temperature, $T_c$ is the coolant temperature, $\\Delta H_{\\mathrm{rxn}}$ is the molar heat of reaction (negative for exothermic), $\\rho$ is the fluid density, $C_p$ is the specific heat capacity, and $\\beta$ is the volumetric heat transfer coefficient.\n\nThe reaction kinetics are described by a single-site Langmuir-Hinshelwood model, which accounts for the adsorption of reactant $A$ onto the catalyst surface:\n$$\nr(C_A, T) = k(T) \\frac{K_A(T) C_A}{(1 + K_A(T) C_A)^2}\n$$\nThe temperature dependencies of the kinetic coefficient, $k(T)$, and the adsorption equilibrium constant, $K_A(T)$, introduce strong nonlinearities. The kinetic coefficient follows the Arrhenius law, increasing exponentially with temperature:\n$$\nk(T) = k_0 \\exp\\left(-\\frac{E_a}{R T}\\right)\n$$\nwhere $E_a$ is the activation energy, $k_0$ is the pre-exponential factor, and $R$ is the universal gas constant. The adsorption parameter follows a van 't Hoff-type relation, typically decreasing with temperature for exothermic adsorption ($\\Delta H_{\\mathrm{ads}}  0$):\n$$\nK_A(T) = K_{\\mathrm{ref}} \\exp\\left(-\\frac{\\Delta H_{\\mathrm{ads}}}{R} \\left(\\frac{1}{T} - \\frac{1}{T_{\\mathrm{ref}}}\\right)\\right)\n$$\nwhere $\\Delta H_{\\mathrm{ads}}$ is the enthalpy of adsorption and $K_{\\mathrm{ref}}$ is the adsorption constant at a reference temperature $T_{\\mathrm{ref}}$.\n\nThe steady states of the reactor are the solution pairs $(C_A, T)$ that simultaneously satisfy the two nonlinear equations $F_1(C_A, T) = 0$ and $F_2(C_A, T) = 0$. Due to the complex, non-monotonic dependence of the reaction rate on temperature (a product of the increasing $k(T)$ and decreasing $K_A(T)$), multiple solutions can exist for a single set of operating parameters.\n\nTo find all possible solutions, a single-start numerical solver is insufficient as it is prone to finding only one root, which depends on the initial guess. A multi-start strategy is required. The computational algorithm proceeds as follows:\n1.  A grid of initial guesses for $(C_A, T)$ is generated, covering the entire domain of physically admissible states defined by $C_A \\in [0, C_{Af}]$ and $T \\in [250, 1200]\\,\\mathrm{K}$.\n2.  For each initial guess, a numerical root-finding algorithm (specifically, `scipy.optimize.root`) is employed to solve the system of equations $\\vec{F}(C_A, T) = [F_1, F_2]^T = \\vec{0}$.\n3.  Each result from the solver is validated. A solution is accepted only if the solver converged successfully and the resulting $(C_A, T)$ pair lies within the specified physical boundaries.\n4.  A list of unique solutions is maintained. Each newly found valid solution is compared against all previously stored unique solutions. It is considered a new, distinct solution and added to the list only if it is not within a specified Euclidean tolerance ($\\Delta C_A  10^{-6}$ and $\\Delta T  10^{-5}$) of any existing solution in the list.\n5.  After iterating through all initial guesses, the total number of entries in the unique solutions list gives the number of distinct, physically admissible steady states for the given set of parameters.\n\nThis procedure is repeated for each of the six specified test cases, which vary the parameters $E_a$, $\\Delta H_{\\mathrm{ads}}$, $\\tau$, and $UA/V$. The fixed parameters are given as $C_{Af} = 2.0\\,\\mathrm{mol\\,m^{-3}}$, $T_f = 350\\,\\mathrm{K}$, $T_c = 300\\,\\mathrm{K}$, $\\Delta H_{\\mathrm{rxn}} = -120000\\,\\mathrm{J\\,mol^{-1}}$, $\\rho = 1.0\\,\\mathrm{kg\\,m^{-3}}$, $C_p = 1000.0\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$, $R = 8.314\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$, $k_0 = 1.0\\,\\mathrm{mol\\,m^{-3}\\,s^{-1}}$, $K_{\\mathrm{ref}} = 2.0\\,\\mathrm{m^{3}\\,mol^{-1}}$, and $T_{\\mathrm{ref}} = 350\\,\\mathrm{K}$. The volumetric heat removal coefficient, $\\beta$, is calculated for each case using $\\beta = (U A / V)/(\\rho C_p)$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Solves for the number of steady states in a CSTR with Langmuir-Hinshelwood kinetics\n    for a series of test cases.\n    \"\"\"\n\n    # --- Fixed parameters as defined in the problem statement ---\n    C_Af = 2.0  # mol/m^3\n    T_f = 350.0  # K\n    T_c = 300.0  # K\n    dH_rxn = -120000.0  # J/mol\n    rho = 1.0  # kg/m^3\n    Cp = 1000.0  # J/kg/K\n    R = 8.314  # J/mol/K\n    k0 = 1.0  # mol/m^3/s\n    K_ref = 2.0  # m^3/mol\n    T_ref = 350.0  # K\n\n    # --- Algorithmic specifications ---\n    C_A_TOL = 1e-6\n    T_TOL = 1e-5\n    C_A_BOUNDS = [0.0, C_Af]\n    T_BOUNDS = [250.0, 1200.0]\n    \n    # --- Test cases ---\n    # (Ea, dH_ads, tau, UA/V)\n    test_cases = [\n        (75000, -60000, 100, 50),\n        (110000, -100000, 150, 30),\n        (110000, -20000, 150, 30),\n        (60000, -100000, 150, 30),\n        (110000, -100000, 80, 150),\n        (100000, -80000, 200, 40),\n    ]\n\n    def k_T(T, Ea):\n        \"\"\"Calculates the Arrhenius rate constant.\"\"\"\n        return k0 * np.exp(-Ea / (R * T))\n\n    def K_A_T(T, dH_ads):\n        \"\"\"Calculates the van 't Hoff adsorption constant.\"\"\"\n        return K_ref * np.exp(-dH_ads / R * (1.0 / T - 1.0 / T_ref))\n\n    def reaction_rate(C_A, T, Ea, dH_ads):\n        \"\"\"Calculates the Langmuir-Hinshelwood reaction rate.\"\"\"\n        # Pre-check for numerical stability and physical sense\n        if C_A  0 or T = 0:\n            return np.inf\n        \n        k = k_T(T, Ea)\n        K_A = K_A_T(T, dH_ads)\n        denominator = (1.0 + K_A * C_A)**2\n        \n        if denominator  1e-12:  # Avoid division by zero\n            return np.inf\n            \n        return k * K_A * C_A / denominator\n\n    def system_of_equations(x, Ea, dH_ads, tau, beta):\n        \"\"\"Defines the system of nonlinear equations F(x) = 0.\"\"\"\n        C_A, T = x\n        \n        r = reaction_rate(C_A, T, Ea, dH_ads)\n        \n        # Mole balance equation\n        f1 = (C_Af - C_A) / tau - r\n        \n        # Energy balance equation\n        f2 = (T_f - T) / tau + (-dH_rxn / (rho * Cp)) * r - beta * (T - T_c)\n        \n        return [f1, f2]\n\n    def find_steady_states(params):\n        \"\"\"Implements the multi-start root-finding algorithm.\"\"\"\n        Ea, dH_ads, tau, U_A_per_V = params\n        beta = U_A_per_V / (rho * Cp)\n        \n        found_solutions = []\n        \n        # Create a grid of initial guesses spanning the physical domain\n        n_guesses_C = 20\n        n_guesses_T = 20\n        C_A_guesses = np.linspace(C_A_BOUNDS[0] + 1e-4, C_A_BOUNDS[1] - 1e-4, n_guesses_C)\n        T_guesses = np.linspace(T_BOUNDS[0], T_BOUNDS[1], n_guesses_T)\n        \n        for C_A0 in C_A_guesses:\n            for T0 in T_guesses:\n                initial_guess = [C_A0, T0]\n                \n                # Use scipy's root finder\n                sol = root(system_of_equations, initial_guess, \n                           args=(Ea, dH_ads, tau, beta), method='hybr', tol=1e-9)\n                \n                if sol.success:\n                    C_A_sol, T_sol = sol.x\n                    \n                    # 1. Check for physical admissibility\n                    is_admissible = (C_A_BOUNDS[0] = C_A_sol = C_A_BOUNDS[1]) and \\\n                                    (T_BOUNDS[0] = T_sol = T_BOUNDS[1])\n                    \n                    if is_admissible:\n                        # 2. Check if the solution is distinct from found ones\n                        is_distinct = True\n                        for C_A_found, T_found in found_solutions:\n                            if abs(C_A_sol - C_A_found)  C_A_TOL and abs(T_sol - T_found)  T_TOL:\n                                is_distinct = False\n                                break\n                        \n                        if is_distinct:\n                            found_solutions.append([C_A_sol, T_sol])\n                            \n        return len(found_solutions)\n\n    results = []\n    for case in test_cases:\n        num_solutions = find_steady_states(case)\n        results.append(num_solutions)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Bifurcation phenomena are not limited to the macroscopic reactor scale; they can also occur within the porous structure of the catalyst itself due to the interplay of reaction and diffusion. This exercise bridges scales by focusing on the internal effectiveness factor, $\\eta$, as a function of the Thiele modulus, $\\phi$ . By solving the governing boundary value problem, you will see how non-isothermal effects can lead to multiple steady-state profiles inside the catalyst, manifesting as turning points on the $\\eta(\\phi)$ curve.",
            "id": "3870198",
            "problem": "You are asked to compute, analyze, and algorithmically detect qualitative changes in the dependence of the internal effectiveness factor on the Thiele modulus in a porous catalytic slab, under isothermal and non-isothermal conditions, using only first principles of steady diffusion and heat conduction with first-order kinetics. Your program must be a complete, runnable script that carries out the computations and outputs a single line in the specified format.\n\nStarting point and definitions:\n- Consider a porous catalytic slab of half-thickness subject to symmetry at the centerline and fixed gas composition and temperature at the external surface. Let $x \\in [0,1]$ be the dimensionless coordinate measured from the slab centerline ($x = 0$) to the slab external surface ($x = 1$).\n- In the isothermal case, the steady-state molar concentration profile of reactant, non-dimensionalized as $y(x) = c_A(x)/c_{A,s}$ where $c_{A,s}$ is the surface concentration, obeys Fick’s law and a first-order reaction rate. The governing equation is the second-order ordinary differential equation\n$$\n\\frac{d^2 y}{dx^2} = \\phi^2 y,\n$$\nwith boundary conditions\n$$\n\\left.\\frac{dy}{dx}\\right|_{x=0} = 0, \\qquad y(1) = 1,\n$$\nwhere $\\phi$ is the (dimensionless) Thiele modulus defined by $\\phi^2 = \\dfrac{k L^2}{D_\\text{eff}}$, with $k$ the surface-rate constant, $L$ the slab half-thickness, and $D_\\text{eff}$ the effective diffusivity. The isothermal internal effectiveness factor is defined as the volume-average of the local reaction rate normalized by the surface reaction rate,\n$$\n\\eta_\\text{iso}(\\phi) = \\int_0^1 y(x;\\phi)\\,dx.\n$$\n- In the non-isothermal case, let the dimensionless temperature be $\\theta(x) = \\dfrac{T(x) - T_s}{\\Delta T}$, where $T_s$ is the surface temperature and $\\Delta T$ is a positive reference temperature scale. Adopt the Frank-Kamenetskii approximation to the Arrhenius factor so that the local rate scales as $y\\,\\exp(\\gamma\\,\\theta)$, where $\\gamma$ is a dimensionless activation parameter. The coupled steady mass and energy balances in dimensionless form are\n$$\n\\frac{d^2 y}{dx^2} = \\phi^2\\, y\\, e^{\\gamma\\,\\theta}, \\qquad \n\\frac{d^2 \\theta}{dx^2} = -\\beta\\,\\phi^2\\, y\\, e^{\\gamma\\,\\theta},\n$$\nwith boundary conditions\n$$\n\\left.\\frac{dy}{dx}\\right|_{x=0} = 0, \\quad \\left.\\frac{d\\theta}{dx}\\right|_{x=0} = 0, \\quad y(1) = 1, \\quad \\theta(1) = 0.\n$$\nHere $\\beta$ is a positive dimensionless heat generation parameter that aggregates reaction enthalpy, thermal conductivity, and other constants. The non-isothermal effectiveness factor is\n$$\n\\eta_\\text{noniso}(\\phi;\\beta,\\gamma) = \\int_0^1 y(x;\\phi,\\beta,\\gamma)\\, e^{\\gamma\\,\\theta(x;\\phi,\\beta,\\gamma)}\\,dx.\n$$\n\nTasks to implement in your program:\n1) Compute the analytical dependence of $\\eta_\\text{iso}(\\phi)$ on $\\phi$ for the slab, using only the governing isothermal equation above and the fundamental definition of $\\eta_\\text{iso}$ as a volume average. You must not use any pre-tabulated formulas; derive the formula symbolically in your solution, and implement the resulting closed-form expression in code. Then numerically demonstrate that $\\eta_\\text{iso}(\\phi)$ is strictly decreasing over a prescribed finite grid of $\\phi$ values.\n2) For the non-isothermal case, for fixed $\\beta$ and $\\gamma$, compute $\\eta_\\text{noniso}(\\phi;\\beta,\\gamma)$ by solving the coupled boundary value problem for each $\\phi$ in a prescribed finite grid. Use a robust and self-contained numerical boundary value problem solver. Then evaluate the function $\\eta_\\text{noniso}(\\phi)$ along the grid and algorithmically determine whether there exists at least one interior turning point, i.e., whether there exists at least one $\\phi$ inside the grid where the discrete numerical derivative of $\\eta$ with respect to $\\phi$ changes sign. In doing so, define a numerical tolerance $\\epsilon$ and ignore sign changes when the magnitude of the discrete derivative is less than $\\epsilon$ to avoid false positives from numerical noise.\n\nTest suite:\n- Use the following grid of Thiele modulus values (dimensionless): $\\{\\phi\\} = \\{\\, 0.1,\\, 0.25,\\, 0.5,\\, 0.75,\\, 1.0,\\, 1.5,\\, 2.0,\\, 2.5,\\, 3.0,\\, 3.5,\\, 4.0 \\,\\}$.\n- Case $1$ (isothermal reference): treat as $\\gamma = 0$ and compute $\\eta_\\text{iso}(\\phi)$ on the grid. Algorithmically count the number of interior turning points of $\\eta_\\text{iso}(\\phi)$ detected on this grid using the same rule as in the non-isothermal case.\n- Case $2$ (moderately non-isothermal): $\\beta = 0.10$, $\\gamma = 8.0$. Compute $\\eta_\\text{noniso}(\\phi;\\beta,\\gamma)$ on the grid and count the number of interior turning points on this grid.\n- Case $3$ (strongly non-isothermal): $\\beta = 0.30$, $\\gamma = 12.0$. Compute $\\eta_\\text{noniso}(\\phi;\\beta,\\gamma)$ on the grid and count the number of interior turning points on this grid.\n\nQuantities to compute and numerical details:\n- All computations are dimensionless, so no physical units are required in your outputs.\n- For the non-isothermal boundary value problems, you must use a mesh over $x \\in [0,1]$ with sufficient resolution to achieve convergence for all grid values of $\\phi$ in each case. Use smooth initial guesses and continuation in $\\phi$ to aid convergence.\n- Define a scalar numerical tolerance $\\epsilon$ for derivative magnitude thresholding. Use $\\epsilon = 1\\times 10^{-3}$.\n- Define a turning point as a strict interior point of the $\\phi$ grid where the discrete numerical derivative of $\\eta$ with respect to $\\phi$ changes sign across adjacent intervals, with both adjacent slopes having magnitude at least $\\epsilon$.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The result for each of the three cases must be the integer number of interior turning points detected on the given $\\phi$ grid. For example, a valid output line is of the form $[n_1,n_2,n_3]$ where $n_1$, $n_2$, and $n_3$ are integers.",
            "solution": "The objective is to analyze the dependence of the internal effectiveness factor, $\\eta$, on the Thiele modulus, $\\phi$, for a first-order reaction in a porous catalytic slab. We will first derive the analytical solution for the isothermal case and then develop a numerical solution for the non-isothermal case. Finally, we will implement an algorithm to detect turning points in the $\\eta(\\phi)$ curve, which signify qualitative changes in the reactor's behavior, for three specific test cases.\n\n### Isothermal Case Analysis\n\nIn the isothermal case, the governing dimensionless mass balance is a second-order linear ordinary differential equation (ODE):\n$$\n\\frac{d^2 y}{dx^2} = \\phi^2 y\n$$\nwith boundary conditions (BCs) dictated by symmetry at the centerline ($x=0$) and fixed surface concentration ($x=1$):\n$$\n\\left.\\frac{dy}{dx}\\right|_{x=0} = 0, \\qquad y(1) = 1\n$$\nThe characteristic equation of the ODE is $r^2 - \\phi^2 = 0$, which has roots $r = \\pm\\phi$. The general solution can be written in terms of hyperbolic functions, which is convenient for applying the symmetry BC at $x=0$:\n$$\ny(x) = C_1 \\cosh(\\phi x) + C_2 \\sinh(\\phi x)\n$$\nThe derivative is:\n$$\n\\frac{dy}{dx} = C_1 \\phi \\sinh(\\phi x) + C_2 \\phi \\cosh(\\phi x)\n$$\nApplying the first BC, $\\left.\\frac{dy}{dx}\\right|_{x=0} = 0$:\n$$\nC_1 \\phi \\sinh(0) + C_2 \\phi \\cosh(0) = C_2 \\phi = 0\n$$\nSince $\\phi$ is generally non-zero, this implies $C_2 = 0$. The solution simplifies to $y(x) = C_1 \\cosh(\\phi x)$. Applying the second BC, $y(1) = 1$:\n$$\n1 = C_1 \\cosh(\\phi) \\implies C_1 = \\frac{1}{\\cosh(\\phi)}\n$$\nThus, the dimensionless concentration profile is:\n$$\ny(x;\\phi) = \\frac{\\cosh(\\phi x)}{\\cosh(\\phi)}\n$$\nThe isothermal effectiveness factor, $\\eta_\\text{iso}(\\phi)$, is defined as the volume-averaged reaction rate normalized by the rate at surface conditions. For first-order kinetics, this is equivalent to the volume average of the dimensionless concentration:\n$$\n\\eta_\\text{iso}(\\phi) = \\int_0^1 y(x;\\phi)\\,dx = \\int_0^1 \\frac{\\cosh(\\phi x)}{\\cosh(\\phi)}\\,dx\n$$\nPerforming the integration:\n$$\n\\eta_\\text{iso}(\\phi) = \\frac{1}{\\cosh(\\phi)} \\left[ \\frac{\\sinh(\\phi x)}{\\phi} \\right]_0^1 = \\frac{1}{\\cosh(\\phi)} \\left( \\frac{\\sinh(\\phi)}{\\phi} - 0 \\right) = \\frac{\\tanh(\\phi)}{\\phi}\n$$\nThis is the analytical expression for the isothermal effectiveness factor. To determine if there are any turning points, we analyze its derivative with respect to $\\phi$ for $\\phi  0$:\n$$\n\\frac{d\\eta_\\text{iso}}{d\\phi} = \\frac{d}{d\\phi} \\left( \\frac{\\tanh(\\phi)}{\\phi} \\right) = \\frac{\\phi \\cdot \\text{sech}^2(\\phi) - \\tanh(\\phi)}{\\phi^2}\n$$\nThe sign of the derivative is determined by the numerator, $\\phi\\,\\text{sech}^2(\\phi) - \\tanh(\\phi)$. We can rewrite this as:\n$$\n\\frac{\\phi}{\\cosh^2(\\phi)} - \\frac{\\sinh(\\phi)}{\\cosh(\\phi)} = \\frac{\\phi - \\sinh(\\phi)\\cosh(\\phi)}{\\cosh^2(\\phi)} = \\frac{\\phi - \\frac{1}{2}\\sinh(2\\phi)}{\\cosh^2(\\phi)}\n$$\nThe denominator is always positive for real $\\phi$. Let's analyze the numerator, $f(\\phi) = \\phi - \\frac{1}{2}\\sinh(2\\phi)$. We note that $f(0) = 0$. Its derivative is $f'(\\phi) = 1 - \\cosh(2\\phi)$. For any $\\phi  0$, $2\\phi  0$, and thus $\\cosh(2\\phi)  1$, which implies $f'(\\phi)  0$. Since $f(0)=0$ and $f(\\phi)$ is strictly decreasing for $\\phi  0$, it follows that $f(\\phi)  0$ for all $\\phi  0$. Therefore, $\\frac{d\\eta_\\text{iso}}{d\\phi}  0$ for all $\\phi  0$. The function $\\eta_\\text{iso}(\\phi)$ is strictly monotonically decreasing, and consequently, it has no interior turning points.\n\n### Non-isothermal Case Analysis\n\nThe non-isothermal case is described by two coupled second-order ODEs:\n$$\n\\frac{d^2 y}{dx^2} = \\phi^2\\, y\\, e^{\\gamma\\,\\theta}, \\qquad \n\\frac{d^2 \\theta}{dx^2} = -\\beta\\,\\phi^2\\, y\\, e^{\\gamma\\,\\theta}\n$$\nwith BCs:\n$$\n\\left.\\frac{dy}{dx}\\right|_{x=0} = 0, \\quad \\left.\\frac{d\\theta}{dx}\\right|_{x=0} = 0, \\quad y(1) = 1, \\quad \\theta(1) = 0\n$$\nA crucial simplification arises from observing the direct relationship between the two equations:\n$$\n\\frac{d^2 \\theta}{dx^2} = -\\beta \\left( \\phi^2\\, y\\, e^{\\gamma\\,\\theta} \\right) = -\\beta \\frac{d^2 y}{dx^2}\n$$\nIntegrating this relation twice with respect to $x$ and applying the boundary conditions yields an algebraic relationship between temperature and concentration. First integration:\n$$\n\\frac{d\\theta}{dx} = -\\beta \\frac{dy}{dx} + C_1\n$$\nApplying the BCs at $x=0$, we find $0 = -\\beta \\cdot 0 + C_1 \\implies C_1=0$. Second integration:\n$$\n\\theta(x) = -\\beta y(x) + C_2\n$$\nApplying the BCs at $x=1$, we find $0 = -\\beta \\cdot 1 + C_2 \\implies C_2 = \\beta$. This gives the well-known Prater relation for a Lewis number of unity:\n$$\n\\theta(x) = \\beta (1 - y(x))\n$$\nSubstituting this into the mass balance ODE eliminates $\\theta$, reducing the system to a single non-linear BVP for $y(x)$:\n$$\n\\frac{d^2 y}{dx^2} = \\phi^2 y \\exp\\left[\\gamma \\beta (1-y)\\right]\n$$\nwith the original BCs for $y$: $\\left.\\frac{dy}{dx}\\right|_{x=0} = 0$ and $y(1) = 1$.\n\nThe non-isothermal effectiveness factor is defined as $\\eta_\\text{noniso} = \\int_0^1 y\\, e^{\\gamma\\,\\theta}\\,dx$. Using the mass balance ODE, we can rewrite the integrand:\n$$\n\\eta_\\text{noniso} = \\int_0^1 \\frac{1}{\\phi^2} \\frac{d^2y}{dx^2}\\,dx = \\frac{1}{\\phi^2} \\left[ \\frac{dy}{dx} \\right]_0^1\n$$\nApplying the BC $\\left.\\frac{dy}{dx}\\right|_{x=0}=0$, we obtain a computationally efficient expression for $\\eta_\\text{noniso}$:\n$$\n\\eta_\\text{noniso}(\\phi;\\beta,\\gamma) = \\frac{1}{\\phi^2} \\left.\\frac{dy}{dx}\\right|_{x=1}\n$$\nThis means that after solving the BVP for $y(x)$, we only need the value of its derivative at the surface to calculate $\\eta$.\n\n### Numerical Strategy\n\nThe non-linear BVP for $y(x)$ must be solved numerically. We use a shooting method or a finite-difference relaxation method, as implemented in `scipy.integrate.solve_bvp`. The solver requires a system of first-order ODEs. Let $u_1 = y$ and $u_2 = y'$. The second-order ODE becomes:\n$$\nu_1' = u_2 \\\\\nu_2' = \\phi^2 u_1 \\exp\\left[\\gamma \\beta (1-u_1)\\right]\n$$\nThe boundary conditions in this new notation are $u_2(0)=0$ and $u_1(1)=1$.\nFor robustness, especially in the strongly non-isothermal regime where multiple steady-state solutions can exist, we employ a continuation strategy. We start the computation at the smallest value in the $\\phi$ grid, using a simple initial guess (e.g., $y(x) \\approx 1$, $y'(x) \\approx 0$). The converged solution for a given $\\phi_i$ is then used as the initial guess for the next value, $\\phi_{i+1}$.\n\n### Turning Point Detection\n\nAfter computing the pairs $(\\phi_i, \\eta_i)$ for each point in the given grid, we identify turning points. A turning point corresponds to a local extremum in the $\\eta(\\phi)$ curve. We approximate the derivative of $\\eta(\\phi)$ using a first-order finite difference (slope) between adjacent grid points:\n$$\ns_i = \\frac{\\eta_{i+1} - \\eta_i}{\\phi_{i+1} - \\phi_i}\n$$\nA turning point is detected at an interior grid point $\\phi_{i+1}$ if the slope changes sign from the interval before to the interval after, i.e., $s_i \\cdot s_{i+1}  0$. To prevent false positives from numerical noise or near-zero slopes, we impose the condition that the magnitude of both slopes must be greater than or equal to a specified tolerance $\\epsilon = 1 \\times 10^{-3}$. The total number of turning points is the count of interior grid points satisfying these two conditions. This procedure is applied to all three test cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_bvp\n\ndef solve():\n    \"\"\"\n    Computes and analyzes the effectiveness factor for a catalytic slab\n    under isothermal and non-isothermal conditions, and detects turning points.\n    \"\"\"\n\n    # Global parameters from the problem statement\n    PHI_GRID = np.array([0.1, 0.25, 0.5, 0.75, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0])\n    TURNING_POINT_TOLERANCE = 1e-3\n\n    def count_turning_points(phi_values, eta_values):\n        \"\"\"\n        Algorithmically counts interior turning points in the eta vs. phi curve.\n\n        A turning point is an interior point of the grid where the discrete derivative\n        changes sign and the magnitude of both adjacent slopes exceeds a tolerance.\n        \"\"\"\n        if len(phi_values)  3:\n            return 0\n\n        # Calculate discrete derivatives (slopes) between adjacent points\n        slopes = (eta_values[1:] - eta_values[:-1]) / (phi_values[1:] - phi_values[:-1])\n\n        turning_points_count = 0\n        # Iterate through the interior points of the grid. `slopes[i]` is the slope\n        # before grid point `i+1` and `slopes[i+1]` is the slope after.\n        for i in range(len(slopes) - 1):\n            # Condition 1: The slope changes sign.\n            sign_change = np.sign(slopes[i]) != np.sign(slopes[i+1])\n            \n            # Condition 2: Both adjacent slopes are significant (not numerical noise).\n            magnitude_check = (abs(slopes[i]) = TURNING_POINT_TOLERANCE and \n                             abs(slopes[i+1]) = TURNING_POINT_TOLERANCE)\n\n            if sign_change and magnitude_check:\n                turning_points_count += 1\n        \n        return turning_points_count\n\n    def solve_isothermal_case():\n        \"\"\"\n        Computes eta for the isothermal case using the analytical solution\n        eta = tanh(phi)/phi and counts turning points.\n        \"\"\"\n        # The analytical solution is eta(phi) = tanh(phi) / phi.\n        # This function is strictly monotonically decreasing, so 0 turning points are expected.\n        # For phi - 0, eta - 1. PHI_GRID does not contain 0.\n        eta_iso = np.tanh(PHI_GRID) / PHI_GRID\n        return count_turning_points(PHI_GRID, eta_iso)\n\n    def solve_nonisothermal_case(beta, gamma):\n        \"\"\"\n        Computes eta for the non-isothermal case by numerically solving the BVP\n        for each phi value, then counts turning points.\n        \"\"\"\n        \n        def ode_system(x, u, phi, beta_val, gamma_val):\n            # System of 2 first-order ODEs from the simplified BVP\n            # u[0] = y (dimensionless concentration)\n            # u[1] = y' (derivative of y)\n            y = u[0]\n            dydx = u[1]\n            \n            # Simplified rate term using the Prater relation\n            rate_term = phi**2 * y * np.exp(gamma_val * beta_val * (1 - y))\n            \n            # dy/dx = y'\n            # dy'/dx = rate_term\n            return np.vstack((dydx, rate_term))\n\n        def boundary_conditions(ua, ub):\n            # Boundary conditions for the first-order system\n            # ua = u(x=0), ub = u(x=1)\n            # BC 1: y'(0) = 0  = ua[1] = 0\n            # BC 2: y(1) = 1   = ub[0] = 1\n            return np.array([ua[1], ub[0] - 1])\n\n        eta_noniso_values = []\n        \n        # Define the mesh for the spatial coordinate x\n        x_mesh = np.linspace(0, 1, 101)\n        \n        # Initial guess for the solution (y(x), y'(x)) for the first phi value.\n        # A good guess for small phi is y(x)=1, y'(x)=0.\n        u_guess = np.ones((2, x_mesh.size))\n        u_guess[1, :] = 0.0\n\n        # Loop through the phi grid, using continuation.\n        for phi in PHI_GRID:\n            # Create a callable for the solver with the current parameters\n            fun = lambda x, u: ode_system(x, u, phi=phi, beta_val=beta, gamma_val=gamma)\n            \n            # Solve the boundary value problem\n            # Tolerances for the solver are kept tight for accuracy.\n            sol = solve_bvp(fun, boundary_conditions, x_mesh, u_guess, tol=1e-6, max_nodes=5000)\n            \n            if not sol.success:\n                # In case of solver failure, this indicates a problem.\n                # For this specific problem, it might happen in the highly non-linear\n                # case if the continuation step is too large or the guess is poor.\n                # We return an error code for the turning point count.\n                return -1 # Indicates failure\n\n            # Calculate eta using the derived formula: eta = y'(1) / phi^2\n            # sol.y[1, -1] is the value of y' at the last mesh point (x=1).\n            eta = sol.y[1, -1] / (phi**2)\n            eta_noniso_values.append(eta)\n            \n            # Update the initial guess for the next phi value (continuation).\n            # This makes the solver more robust for subsequent, more challenging cases.\n            u_guess = sol.sol(x_mesh)\n\n        eta_noniso_values = np.array(eta_noniso_values)\n        return count_turning_points(PHI_GRID, eta_noniso_values)\n\n    # --- Main execution ---\n    results = []\n\n    # Case 1: Isothermal\n    n1 = solve_isothermal_case()\n    results.append(n1)\n    \n    # Case 2: Moderately non-isothermal\n    n2 = solve_nonisothermal_case(beta=0.10, gamma=8.0)\n    results.append(n2)\n    \n    # Case 3: Strongly non-isothermal\n    n3 = solve_nonisothermal_case(beta=0.30, gamma=12.0)\n    results.append(n3)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}