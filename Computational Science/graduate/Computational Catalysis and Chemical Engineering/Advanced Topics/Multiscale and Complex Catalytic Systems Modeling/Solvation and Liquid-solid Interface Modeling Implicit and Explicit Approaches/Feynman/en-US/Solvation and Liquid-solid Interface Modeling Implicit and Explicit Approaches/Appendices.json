{
    "hands_on_practices": [
        {
            "introduction": "The electrostatic interactions between a solute and a solvent are often the most significant contribution to the solvation energy. This practice delves into the heart of implicit solvation by tackling the Poisson equation, which governs these interactions in a continuum dielectric model. You will implement a Finite Element Method (FEM) solver from first principles to handle a solute with a distinct dielectric constant from the solvent, providing hands-on experience with a powerful numerical technique essential for modeling complex interfacial systems .",
            "id": "3899789",
            "problem": "Consider an implicit-solvent continuum electrostatics model for a solvated, charged solute at a liquid–solid interface in two spatial dimensions. The electrostatic potential field $\\phi(\\mathbf{r})$ in a domain $\\Omega \\subset \\mathbb{R}^2$ satisfies the Poisson equation derived from Maxwell’s equations, namely $-\\nabla \\cdot \\left( \\epsilon(\\mathbf{r}) \\nabla \\phi(\\mathbf{r}) \\right) = \\rho(\\mathbf{r})$ in $\\Omega$, where $\\epsilon(\\mathbf{r})$ is the spatially varying permittivity and $\\rho(\\mathbf{r})$ is the free charge density. The interface between the solute and the solvent is represented by a piecewise-constant dielectric function $\\epsilon(\\mathbf{r})$ with a sharp jump at the solute boundary. The solute is modeled as a disk of radius $a$ centered at the origin with a prescribed charge distribution $\\rho(\\mathbf{r})$. The solvent exterior is treated as a dielectric continuum. The boundary condition on the outer boundary of the simulation box is $\\phi(\\mathbf{r}) = 0$ (Dirichlet), representing a grounded boundary sufficiently far from the solute. All quantities are nondimensionalized; report results in dimensionless units.\n\nYour task is to derive, implement, and compute a linear Finite Element Method (FEM) solution of the weak form of the Poisson equation with spatially varying $\\epsilon(\\mathbf{r})$, and assess mesh refinement effects on observables. Begin from the fundamental laws of electrostatics in matter, specifically $\\nabla \\cdot \\mathbf{D} = \\rho$ with $\\mathbf{D} = \\epsilon(\\mathbf{r}) \\mathbf{E}$ and $\\mathbf{E} = -\\nabla \\phi$, and derive the weak form for piecewise-linear basis functions on a conforming triangular mesh. Do not assume any pre-derived stiffness matrix formula; derive it from the weak form and the definition of the basis functions. Use a consistent quadrature choice that preserves the order of accuracy for piecewise-linear elements with piecewise-constant coefficients. Impose the Dirichlet boundary condition strongly.\n\nDomain and material model:\n- Let the computational domain be the square $\\Omega = [-L,L] \\times [-L,L]$ with $L = 2.0$.\n- The solute region is the disk $\\{ \\mathbf{r} : \\|\\mathbf{r}\\| < a \\}$ with $a = 0.5$, having permittivity $\\epsilon_{\\text{in}} = 2.0$.\n- The solvent region is the exterior $\\{ \\mathbf{r} : \\|\\mathbf{r}\\| \\ge a \\}$ with permittivity $\\epsilon_{\\text{out}} = 80.0$.\n- The free charge density is a Gaussian with total charge $q = 1.0$ and width parameter $\\sigma = 0.1$,\n  $$\\rho(\\mathbf{r}) = \\frac{q}{2\\pi \\sigma^2} \\exp\\left( - \\frac{\\|\\mathbf{r}\\|^2}{2\\sigma^2} \\right).$$\n- The permittivity is piecewise constant:\n  $$\\epsilon(\\mathbf{r}) = \\begin{cases}\n  \\epsilon_{\\text{in}}, & \\|\\mathbf{r}\\| < a,\\\\\n  \\epsilon_{\\text{out}}, & \\|\\mathbf{r}\\| \\ge a.\n  \\end{cases}$$\n\nDiscretization and numerical requirements:\n- Use a uniform structured grid of $N \\times N$ squares on $\\Omega$ and subdivide each square into $2$ triangles to form a conforming triangular mesh with linear shape functions per element.\n- Use the standard Galerkin formulation. For an element $K$ with area $A_K$ and local linear basis $\\{N_i\\}_{i=1}^3$, the element stiffness entries are $K_{ij}^{(K)} = \\int_{K} \\epsilon(\\mathbf{r}) \\nabla N_i \\cdot \\nabla N_j \\, d\\mathbf{r}$ and the element load entries are $f_i^{(K)} = \\int_{K} \\rho(\\mathbf{r}) N_i(\\mathbf{r}) \\, d\\mathbf{r}$.\n- Approximate the spatially varying coefficients by evaluating $\\epsilon(\\mathbf{r})$ and $\\rho(\\mathbf{r})$ at the element centroid and use a consistent quadrature that yields $f_i^{(K)} \\approx \\rho(\\mathbf{r}_c) A_K / 3$ for linear $N_i$, where $\\mathbf{r}_c$ is the centroid of $K$.\n- Impose the boundary condition $\\phi = 0$ on $\\partial \\Omega$.\n\nObservables to report:\n- The electrostatic potential at the observation point $\\mathbf{r}_{\\text{obs}} = (0.3, 0.0)$, obtained by selecting the value at the nearest mesh node to $\\mathbf{r}_{\\text{obs}}$.\n- The electrostatic energy functional value\n  $$U = \\frac{1}{2} \\int_{\\Omega} \\rho(\\mathbf{r}) \\, \\phi(\\mathbf{r}) \\, d\\mathbf{r},$$\n  approximated by elementwise centroid quadrature with linear interpolation of $\\phi$ over each element.\n\nTest suite:\n- Use three mesh resolutions $N \\in \\{16, 32, 64\\}$ with all other parameters fixed as specified above. These represent, respectively, a coarse, a moderate, and a refined mesh. This test suite is designed to probe the following:\n  - $N = 16$: coarse mesh to test stability and basic correctness.\n  - $N = 32$: intermediate mesh to assess convergence trend.\n  - $N = 64$: refined mesh to assess asymptotic behavior.\n  \nAnswer specification and output format:\n- For each $N \\in \\{16, 32, 64\\}$, compute in order the potential at $\\mathbf{r}_{\\text{obs}}$ and the energy $U$. Collect these into a single flat list in the order $[\\phi_{16}, U_{16}, \\phi_{32}, U_{32}, \\phi_{64}, U_{64}]$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\phi_{16},U_{16},\\phi_{32},U_{32},\\phi_{64},U_{64}]$, with each floating-point number rounded to $6$ decimal places.",
            "solution": "The user-provided problem has been analyzed and validated.\n\n### Step 1: Extract Givens\n- **Governing Equation**: $-\\nabla \\cdot \\left( \\epsilon(\\mathbf{r}) \\nabla \\phi(\\mathbf{r}) \\right) = \\rho(\\mathbf{r})$ in a domain $\\Omega \\subset \\mathbb{R}^2$.\n- **Fundamental Relations**: $\\nabla \\cdot \\mathbf{D} = \\rho$, $\\mathbf{D} = \\epsilon(\\mathbf{r}) \\mathbf{E}$, $\\mathbf{E} = -\\nabla \\phi$.\n- **Computational Domain**: $\\Omega = [-L,L] \\times [-L,L]$ with $L = 2.0$.\n- **Boundary Condition**: Dirichlet boundary condition $\\phi(\\mathbf{r}) = 0$ on $\\partial \\Omega$.\n- **Permittivity Function**: A piecewise-constant function\n  $$\\epsilon(\\mathbf{r}) = \\begin{cases}\n  \\epsilon_{\\text{in}} = 2.0, & \\|\\mathbf{r}\\| < a = 0.5 \\text{ (solute)}\\\\\n  \\epsilon_{\\text{out}} = 80.0, & \\|\\mathbf{r}\\| \\ge a = 0.5 \\text{ (solvent)}\n  \\end{cases}$$\n- **Free Charge Density**: A Gaussian distribution centered at the origin\n  $$\\rho(\\mathbf{r}) = \\frac{q}{2\\pi \\sigma^2} \\exp\\left( - \\frac{\\|\\mathbf{r}\\|^2}{2\\sigma^2} \\right)$$\n  with total charge $q = 1.0$ and width parameter $\\sigma = 0.1$.\n- **Discretization**: Linear Finite Element Method (FEM) on a conforming triangular mesh. The mesh is formed by creating a uniform $N \\times N$ grid of squares and subdividing each square into $2$ triangles.\n- **Formulation**: Standard Galerkin method.\n- **Element Matrices Approximation**: For an element $K$ with area $A_K$ and centroid $\\mathbf{r}_c$:\n  - Element stiffness: $K_{ij}^{(K)} = \\int_{K} \\epsilon(\\mathbf{r}) \\nabla N_i \\cdot \\nabla N_j \\, d\\mathbf{r}$, approximated by evaluating $\\epsilon(\\mathbf{r})$ at $\\mathbf{r}_c$.\n  - Element load: $f_i^{(K)} = \\int_{K} \\rho(\\mathbf{r}) N_i(\\mathbf{r}) \\, d\\mathbf{r}$, approximated as $\\rho(\\mathbf{r}_c) A_K / 3$.\n- **Boundary Condition Implementation**: Strong enforcement.\n- **Observables**:\n  1. Electrostatic potential $\\phi(\\mathbf{r}_{\\text{obs}})$ at the observation point $\\mathbf{r}_{\\text{obs}} = (0.3, 0.0)$, using the value at the nearest mesh node.\n  2. Electrostatic energy $U = \\frac{1}{2} \\int_{\\Omega} \\rho(\\mathbf{r}) \\, \\phi(\\mathbf{r}) \\, d\\mathbf{r}$, approximated by elementwise centroid quadrature.\n- **Test Suite**: Mesh resolutions $N \\in \\{16, 32, 64\\}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed against the validation criteria:\n- **Scientifically Grounded**: The problem is based on the Poisson equation, a fundamental law of electrostatics, applied to a standard continuum implicit solvent model. This is a well-established and scientifically sound approach in computational chemistry and physics. All parameters and models are physically realistic.\n- **Well-Posed**: The Poisson equation on a bounded domain with Dirichlet boundary conditions is a classic example of a well-posed elliptic partial differential equation, guaranteeing a unique and stable solution.\n- **Objective**: The problem is defined with precise mathematical and physical terminology, free from any subjective or ambiguous statements.\n- **Completeness and Consistency**: All necessary data, equations, boundary conditions, and numerical procedures are explicitly and consistently defined. The specified approximations for the integrals are clear instructions for the numerical implementation.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-defined, scientifically sound task in computational physics. A complete, reasoned solution will be developed.\n\n### Principle-Based Solution\n\n**1. Derivation of the Weak Form**\n\nThe governing partial differential equation (PDE) for the electrostatic potential $\\phi(\\mathbf{r})$ is the Poisson equation with a spatially varying permittivity $\\epsilon(\\mathbf{r})$:\n$$-\\nabla \\cdot (\\epsilon(\\mathbf{r}) \\nabla \\phi(\\mathbf{r})) = \\rho(\\mathbf{r}) \\quad \\text{for } \\mathbf{r} \\in \\Omega$$\nTo derive the weak (or variational) form, we multiply the PDE by an arbitrary test function $v(\\mathbf{r})$ and integrate over the domain $\\Omega$:\n$$-\\int_{\\Omega} v \\, \\nabla \\cdot (\\epsilon \\nabla \\phi) \\, d\\mathbf{r} = \\int_{\\Omega} v \\rho \\, d\\mathbf{r}$$\nWe apply Green's first identity (a form of integration by parts) to the left-hand side:\n$$\\int_{\\Omega} \\nabla v \\cdot (\\epsilon \\nabla \\phi) \\, d\\mathbf{r} - \\int_{\\partial\\Omega} v (\\epsilon \\nabla \\phi) \\cdot \\mathbf{n} \\, dS = \\int_{\\Omega} v \\rho \\, d\\mathbf{r}$$\nwhere $\\partial\\Omega$ is the boundary of the domain and $\\mathbf{n}$ is the outward-pointing unit normal vector.\nThe problem specifies a Dirichlet boundary condition $\\phi(\\mathbf{r}) = 0$ for $\\mathbf{r} \\in \\partial\\Omega$. In the Galerkin Finite Element Method, the space of test functions is chosen such that the test functions vanish on the part of the boundary where Dirichlet conditions are specified. Thus, we choose $v=0$ on $\\partial\\Omega$, which causes the boundary integral term to vanish.\nThe resulting weak form is: Find a function $\\phi$ that satisfies the Dirichlet boundary conditions and for which\n$$ \\int_{\\Omega} \\epsilon(\\mathbf{r}) \\nabla v \\cdot \\nabla \\phi \\, d\\mathbf{r} = \\int_{\\Omega} v \\rho(\\mathbf{r}) \\, d\\mathbf{r} $$\nholds for all suitable test functions $v$ that vanish on $\\partial\\Omega$.\n\n**2. Finite Element Discretization**\n\nThe domain $\\Omega$ is discretized into a mesh of non-overlapping triangular elements. Within each element, the unknown potential field $\\phi(\\mathbf{r})$ is approximated by a linear combination of basis functions $N_j(\\mathbf{r})$:\n$$ \\phi(\\mathbf{r}) \\approx \\phi_h(\\mathbf{r}) = \\sum_{j=1}^{N_{\\text{nodes}}} \\phi_j N_j(\\mathbf{r}) $$\nwhere $N_{\\text{nodes}}$ is the total number of nodes (vertices) in the mesh, $\\phi_j$ are the unknown potential values at the nodes, and $N_j(\\mathbf{r})$ are the piecewise-linear \"hat\" basis functions. The basis function $N_j$ has a value of $1$ at node $j$ and $0$ at all other nodes.\nAccording to the Galerkin method, we use the basis functions $N_i$ as the test functions, i.e., $v = N_i$. Substituting this and the approximation $\\phi_h$ into the weak form gives a system of linear algebraic equations:\n$$ \\sum_{j=1}^{N_{\\text{nodes}}} \\left( \\int_{\\Omega} \\epsilon(\\mathbf{r}) \\nabla N_i \\cdot \\nabla N_j \\, d\\mathbf{r} \\right) \\phi_j = \\int_{\\Omega} N_i \\rho(\\mathbf{r}) \\, d\\mathbf{r} \\quad \\text{for } i = 1, \\dots, N_{\\text{nodes}} $$\nThis can be written in matrix form as $K\\Phi = F$, where:\n- $\\Phi$ is the column vector of unknown nodal potentials $[\\phi_1, \\phi_2, \\dots]^T$.\n- $K$ is the global stiffness matrix with entries $K_{ij} = \\int_{\\Omega} \\epsilon(\\mathbf{r}) \\nabla N_i \\cdot \\nabla N_j \\, d\\mathbf{r}$.\n- $F$ is the global load vector with entries $F_i = \\int_{\\Omega} N_i \\rho(\\mathbf{r}) \\, d\\mathbf{r}$.\n\n**3. Element Matrix and Vector Derivation**\n\nThe global matrix and vector are assembled from contributions from each element $K$ in the mesh.\nFor a single linear triangular element with vertices $(\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3)$, the local basis functions $N_i(\\mathbf{r})$ are linear and their gradients $\\nabla N_i$ are constant over the element. Let the coordinates of vertex $k$ be $(x_k, y_k)$. The gradient components can be calculated as:\n$$ \\nabla N_1 = \\frac{1}{2A_K} \\begin{pmatrix} y_2 - y_3 \\\\ x_3 - x_2 \\end{pmatrix}, \\quad \\nabla N_2 = \\frac{1}{2A_K} \\begin{pmatrix} y_3 - y_1 \\\\ x_1 - x_3 \\end{pmatrix}, \\quad \\nabla N_3 = \\frac{1}{2A_K} \\begin{pmatrix} y_1 - y_2 \\\\ x_2 - x_1 \\end{pmatrix} $$\nwhere $A_K$ is the area of the element. Let $\\nabla N_i = [b_i, c_i]^T$.\n\n**Element Stiffness Matrix**\nThe contribution of element $K$ to the stiffness matrix is $K_{ij}^{(K)} = \\int_{K} \\epsilon(\\mathbf{r}) \\nabla N_i \\cdot \\nabla N_j \\, d\\mathbf{r}$. As per the problem specification, we approximate $\\epsilon(\\mathbf{r})$ by its value at the element centroid, $\\epsilon_c = \\epsilon(\\mathbf{r}_c)$. Since $\\nabla N_i$ are constant on the element, we have:\n$$ K_{ij}^{(K)} \\approx \\epsilon_c (\\nabla N_i \\cdot \\nabla N_j) \\int_{K} d\\mathbf{r} = \\epsilon_c A_K (\\nabla N_i \\cdot \\nabla N_j) = \\epsilon_c A_K (b_i b_j + c_i c_j) $$\n\n**Element Load Vector**\nThe contribution of element $K$ to the load vector is $f_i^{(K)} = \\int_{K} \\rho(\\mathbf{r}) N_i(\\mathbf{r}) \\, d\\mathbf{r}$. The problem specifies using the centroid value for $\\rho$, $\\rho_c = \\rho(\\mathbf{r}_c)$, and a quadrature rule that gives:\n$$ f_i^{(K)} \\approx \\rho_c \\int_{K} N_i(\\mathbf{r}) \\, d\\mathbf{r} $$\nThe integral of a linear basis function over its triangle is known to be $\\frac{A_K}{3}$. Therefore,\n$$ f_i^{(K)} \\approx \\rho_c \\frac{A_K}{3} $$\n\n**4. Algorithmic Implementation**\n\n1.  **Mesh Generation**: For a given resolution $N$, generate a grid of $(N+1) \\times (N+1)$ nodes on the domain $\\Omega = [-2,2] \\times [-2,2]$. This creates $N^2$ square cells. Each cell is divided into two triangles, forming a total of $2N^2$ triangular elements. A mapping from 2D grid indices to 1D global node indices is established.\n2.  **Assembly**: Initialize a sparse global stiffness matrix $K$ and a dense global load vector $F$ with zeros. Iterate through each triangular element:\n    a. Identify its three global node indices and vertex coordinates.\n    b. Calculate the element's area $A_K$ and centroid $\\mathbf{r}_c$.\n    c. Evaluate $\\epsilon_c = \\epsilon(\\mathbf{r}_c)$ and $\\rho_c = \\rho(\\mathbf{r}_c)$.\n    d. Compute the $3 \\times 3$ element stiffness matrix $K^{(K)}$ and the $3 \\times 1$ element load vector $f^{(K)}$ using the derived formulas.\n    e. Add the entries of $K^{(K)}$ and $f^{(K)}$ to the corresponding locations in the global $K$ and $F$.\n3.  **Boundary Conditions**: The strong Dirichlet condition $\\phi=0$ is imposed. Identify all nodes on the boundary $\\partial\\Omega$. For each boundary node index $k$:\n    a. Modify the $k$-th row and column of $K$ to be zero, except for the diagonal entry $K_{kk}$, which is set to $1$.\n    b. Set the corresponding entry in the load vector, $F_k$, to $0$.\n4.  **Solve**: Convert the assembled sparse matrix $K$ to a format suitable for fast solving (e.g., Compressed Sparse Row). Solve the linear system $K\\Phi = F$ for the vector of nodal potentials $\\Phi$.\n5.  **Post-processing**:\n    a. **Potential**: Find the mesh node nearest to $\\mathbf{r}_{\\text{obs}} = (0.3, 0.0)$ and extract its computed potential from the solution vector $\\Phi$.\n    b. **Energy**: Approximate the energy integral $U = \\frac{1}{2} \\int_{\\Omega} \\rho(\\mathbf{r}) \\phi(\\mathbf{r}) \\, d\\mathbf{r}$ as a sum over elements. For each element $K$, the contribution is $U_K = \\frac{1}{2} \\int_K \\rho \\phi \\, d\\mathbf{r} \\approx \\frac{1}{2} \\rho(\\mathbf{r}_c) \\phi(\\mathbf{r}_c) A_K$. The potential at the centroid $\\phi(\\mathbf{r}_c)$ is interpolated from the nodal solutions: $\\phi(\\mathbf{r}_c) = \\frac{1}{3}(\\phi_1+\\phi_2+\\phi_3)$. Sum $U_K$ over all elements to find the total energy $U$.\n\nThis procedure is repeated for each specified mesh resolution $N \\in \\{16, 32, 64\\}$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve_fem_poisson(N, L, a, eps_in, eps_out, q, sigma, r_obs):\n    \"\"\"\n    Solves the 2D Poisson equation with spatially-varying permittivity using FEM.\n\n    Args:\n        N (int): Number of grid divisions along one axis.\n        L (float): Half-width of the square domain [-L, L] x [-L, L].\n        a (float): Radius of the inner solute disk.\n        eps_in (float): Permittivity inside the solute.\n        eps_out (float): Permittivity outside the solute.\n        q (float): Total charge of the Gaussian distribution.\n        sigma (float): Width of the Gaussian charge distribution.\n        r_obs (tuple): Coordinates (x, y) of the observation point.\n\n    Returns:\n        tuple: A tuple containing:\n            - potential_at_obs (float): The calculated potential at the nearest node to r_obs.\n            - U (float): The total electrostatic energy.\n    \"\"\"\n    # 1. Mesh Generation\n    n_pts_axis = N + 1\n    h = 2.0 * L / N\n    nodes = np.array([[-L + i * h, -L + j * h] for j in range(n_pts_axis) for i in range(n_pts_axis)])\n    num_nodes = n_pts_axis * n_pts_axis\n\n    triangles = []\n    for j in range(N):\n        for i in range(N):\n            p00 = j * n_pts_axis + i\n            p10 = j * n_pts_axis + (i + 1)\n            p01 = (j + 1) * n_pts_axis + i\n            p11 = (j + 1) * n_pts_axis + (i + 1)\n            triangles.append((p00, p10, p11))\n            triangles.append((p00, p11, p01))\n\n    # 2. Assembly\n    K = lil_matrix((num_nodes, num_nodes))\n    F = np.zeros(num_nodes)\n    \n    def epsilon(r):\n        return eps_in if np.linalg.norm(r) < a else eps_out\n\n    def rho(r):\n        norm_sq = r[0]**2 + r[1]**2\n        return (q / (2.0 * np.pi * sigma**2)) * np.exp(-norm_sq / (2.0 * sigma**2))\n\n    for tri_nodes_indices in triangles:\n        p1_idx, p2_idx, p3_idx = tri_nodes_indices\n        p1, p2, p3 = nodes[p1_idx], nodes[p2_idx], nodes[p3_idx]\n        \n        area = 0.5 * abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n        if area < 1e-15: continue\n\n        centroid = (p1 + p2 + p3) / 3.0\n        eps_c = epsilon(centroid)\n        rho_c = rho(centroid)\n\n        b = np.array([p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]]) / (2.0 * area)\n        c = np.array([p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]]) / (2.0 * area)\n\n        K_elem = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                K_elem[i, j] = eps_c * (b[i] * b[j] + c[i] * c[j]) * area\n        \n        F_elem = np.full(3, rho_c * area / 3.0)\n\n        indices = [p1_idx, p2_idx, p3_idx]\n        for i in range(3):\n            F[indices[i]] += F_elem[i]\n            for j in range(3):\n                K[indices[i], indices[j]] += K_elem[i, j]\n\n    # 3. Boundary Conditions (Strong Enforcement for phi=0)\n    boundary_nodes = set()\n    for j in range(n_pts_axis):\n        for i in range(n_pts_axis):\n            if i == 0 or i == N or j == 0 or j == N:\n                boundary_nodes.add(j * n_pts_axis + i)\n\n    for idx in boundary_nodes:\n        K[idx, :] = 0.0\n        K[:, idx] = 0.0\n        K[idx, idx] = 1.0\n        F[idx] = 0.0\n    \n    # 4. Solve\n    K_csr = K.tocsr()\n    phi_sol = spsolve(K_csr, F)\n\n    # 5. Post-processing\n    # Potential at r_obs\n    i_obs = int(round((r_obs[0] + L) / h))\n    j_obs = int(round((r_obs[1] + L) / h))\n    idx_obs = j_obs * n_pts_axis + i_obs\n    potential_at_obs = phi_sol[idx_obs]\n\n    # Electrostatic energy U\n    U = 0.0\n    for tri_nodes_indices in triangles:\n        p1_idx, p2_idx, p3_idx = tri_nodes_indices\n        p1, p2, p3 = nodes[p1_idx], nodes[p2_idx], nodes[p3_idx]\n        \n        area = 0.5 * abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n        if area < 1e-15: continue\n        \n        centroid = (p1 + p2 + p3) / 3.0\n        rho_c = rho(centroid)\n        \n        phi_1, phi_2, phi_3 = phi_sol[p1_idx], phi_sol[p2_idx], phi_sol[p3_idx]\n        phi_c = (phi_1 + phi_2 + phi_3) / 3.0\n        \n        U += 0.5 * rho_c * phi_c * area\n    \n    return potential_at_obs, U\n\ndef solve():\n    \"\"\"\n    Main function to run the FEM simulation for the specified test cases.\n    \"\"\"\n    # Define the problem parameters\n    L = 2.0\n    a = 0.5\n    eps_in = 2.0\n    eps_out = 80.0\n    q = 1.0\n    sigma = 0.1\n    r_obs = (0.3, 0.0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [16, 32, 64]\n\n    raw_results = []\n    for N in test_cases:\n        potential, energy = solve_fem_poisson(N, L, a, eps_in, eps_out, q, sigma, r_obs)\n        raw_results.append(potential)\n        raw_results.append(energy)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{x:.6f}\" for x in raw_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond electrostatics, the nonpolar contributions to solvation, arising from cavity formation and van der Waals interactions, play a crucial role in molecular recognition and stability. This exercise guides you through deriving and comparing two common nonpolar models: a detailed dispersion-only model built from microscopic pairwise potentials and a phenomenological model based on the Solvent-Accessible Surface Area (SASA). By applying these models to a corrugated surface, you will gain a deeper appreciation for how molecular-scale roughness is captured at different levels of theory .",
            "id": "3899810",
            "problem": "You are asked to design and implement a program that, starting from first principles appropriate to computational catalysis and chemical engineering, compares two implicit-solvent, nonpolar free-energy models at a liquid-solid interface for a corrugated solute surface. The comparison focuses on how solute roughness (corrugation amplitude and wavelength) affects the predicted nonpolar contribution. The two models are: a dispersion-only continuum integration of pairwise attractions, and a Solvent-Accessible Surface Area (SASA)-based linear surface-tension model. The continuum liquid is a semi-infinite half-space occupying all positions with $z < 0$, and the solute is represented by a rough surface patch defined by a height field $z(x,y)$ above the plane $z=0$. All lengths must be expressed in nanometers (nm), and all energies must be expressed in kilojoules per mole (kJ/mol).\n\nFundamental base and definitions to use:\n- The pairwise London dispersion potential between a solute site and a solvent site is $u(r) = -C_6 r^{-6}$, with $C_6 > 0$ and $r$ the center-to-center separation.\n- The solvent is represented implicitly as a uniform continuum with number density $\\rho$ (number of solvent sites per unit volume).\n- The solute surface carries a uniform site density $\\sigma_s$ (number of solute sites per unit area).\n- The Solvent-Accessible Surface Area (SASA)-based nonpolar free energy is modeled by $G_\\mathrm{np}^{\\mathrm{SASA}} = \\gamma A$, where $\\gamma$ is a surface-tension-like coefficient and $A$ is the surface area accessible to the solvent.\n- For the solute geometry, use a corrugation defined over a rectangular domain $[0,L_x] \\times [0,L_y]$ with height field $z(x,y) = h + A \\cos(k_x x)\\cos(k_y y)$, where $h$ is the average height (mean separation from the liquid plane), $A$ is the corrugation amplitude, and $k_x = 2\\pi/\\lambda_x$, $k_y = 2\\pi/\\lambda_y$ are the wavenumbers set by the corrugation wavelengths $\\lambda_x$ and $\\lambda_y$.\n- To retain physical realism and avoid divergence of the dispersion integral at near-contact, impose a lower cutoff distance $d_\\mathrm{cut}$, and when computing local separations $d(x,y) = z(x,y)$, replace them by $d_\\mathrm{eff}(x,y) = \\max(d(x,y), d_\\mathrm{cut})$.\n\nYour tasks:\n1. Starting from $u(r) = -C_6 r^{-6}$ and the continuum representation of the solvent half-space, derive the dispersion-only nonpolar contribution for an extended solute surface having site density $\\sigma_s$. You must integrate over the solvent half-space and then over the solute surface patch. The derivation must not assume any pre-packaged target formula; it must begin from the fundamental pair potential and proceed to a usable integral expression for numerical implementation.\n2. Starting from $G_\\mathrm{np}^{\\mathrm{SASA}} = \\gamma A$ with $A = \\int \\sqrt{1 + |\\nabla z|^2}\\,\\mathrm{d}x\\,\\mathrm{d}y$, formulate a numerical method to compute $A$ for the given $z(x,y)$.\n3. Implement both models numerically by discretizing the domain with a uniform grid of $N_x \\times N_y$ points. Use the area element $\\mathrm{d}A = \\sqrt{1 + |\\nabla z|^2}\\,\\mathrm{d}x\\,\\mathrm{d}y$, where $\\nabla z = (\\partial z/\\partial x, \\partial z/\\partial y)$.\n4. Compute, for each test case below, three outputs: the dispersion-only nonpolar energy $G_\\mathrm{np}^{\\mathrm{disp}}$ in kJ/mol, the SASA-based nonpolar energy $G_\\mathrm{np}^{\\mathrm{SASA}}$ in kJ/mol, and the ratio $r = |G_\\mathrm{np}^{\\mathrm{disp}}| / G_\\mathrm{np}^{\\mathrm{SASA}}$ as a float. Express all energies in kJ/mol rounded to six decimal places, and ratios as floats rounded to six decimal places.\n\nPhysical and numerical constants to use in all test cases:\n- Solvent number density: $\\rho = 33.3$ nm$^{-3}$.\n- Solute site density: $\\sigma_s = 38.2$ nm$^{-2}$.\n- Lennard-Jones (LJ) parameters for combining solute carbon (C) and solvent oxygen (O) using Lorentz-Berthelot mixing:\n  - Carbon: $\\epsilon_\\mathrm{C} = 0.276$ kJ/mol, $\\sigma_\\mathrm{C} = 0.340$ nm.\n  - Oxygen: $\\epsilon_\\mathrm{O} = 0.650$ kJ/mol, $\\sigma_\\mathrm{O} = 0.316$ nm.\n  - Mixed: $\\epsilon = \\sqrt{\\epsilon_\\mathrm{C} \\epsilon_\\mathrm{O}}$, $\\sigma = (\\sigma_\\mathrm{C} + \\sigma_\\mathrm{O})/2$.\n  - Attractive coefficient: $C_6 = 4 \\epsilon \\sigma^6$.\n- SASA coefficient: $\\gamma = 2.30$ kJ/mol/nm$^{2}$.\n- Lower cutoff distance: $d_\\mathrm{cut} = 0.28$ nm.\n- Domain sizes: $L_x = 5.0$ nm, $L_y = 5.0$ nm.\n- Grid resolution: $N_x = 400$, $N_y = 400$.\n\nTest suite (each case is $(h, A, \\lambda_x, \\lambda_y)$, with all lengths in nm):\n- Case $1$ (happy path): $h = 0.50$, $A = 0.05$, $\\lambda_x = 1.00$, $\\lambda_y = 1.00$.\n- Case $2$ (flat boundary condition): $h = 0.50$, $A = 0.00$, $\\lambda_x = 1.00$, $\\lambda_y = 1.00$.\n- Case $3$ (large amplitude near cutoff): $h = 0.50$, $A = 0.20$, $\\lambda_x = 1.00$, $\\lambda_y = 1.00$.\n- Case $4$ (far separation edge case): $h = 1.50$, $A = 0.05$, $\\lambda_x = 1.00$, $\\lambda_y = 1.00$.\n- Case $5$ (high-frequency roughness): $h = 0.50$, $A = 0.05$, $\\lambda_x = 0.50$, $\\lambda_y = 0.25$.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case result is a three-element list $[G_\\mathrm{np}^{\\mathrm{disp}}, G_\\mathrm{np}^{\\mathrm{SASA}}, r]$ with each float rounded to six decimal places, for the cases in the order $1$ through $5$. For example, the printed string must look like $[[x_1,y_1,z_1],[x_2,y_2,z_2],\\dots]$ with no additional text.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It provides a complete and consistent set of definitions, constants, and tasks suitable for a formal solution within the domain of computational chemical engineering. We will proceed with the derivation and numerical implementation.\n\nThe objective is to compare two nonpolar solvation free energy models at a liquid-solid interface. The models are a dispersion-only continuum integration and a Solvent-Accessible Surface Area (SASA)-based model. The comparison is performed for a solute surface with specified corrugation.\n\nFirst, we calculate the necessary physical constants from the provided parameters. The solute-solvent interaction is modeled using Lorentz-Berthelot mixing rules for Lennard-Jones parameters.\nGiven solute Carbon (C) parameters $\\epsilon_\\mathrm{C} = 0.276$ kJ/mol and $\\sigma_\\mathrm{C} = 0.340$ nm, and solvent Oxygen (O) parameters $\\epsilon_\\mathrm{O} = 0.650$ kJ/mol and $\\sigma_\\mathrm{O} = 0.316$ nm, the mixed parameters are:\n$$ \\epsilon = \\sqrt{\\epsilon_\\mathrm{C} \\epsilon_\\mathrm{O}} = \\sqrt{(0.276)(0.650)} \\approx 0.423556 \\text{ kJ/mol} $$\n$$ \\sigma = \\frac{\\sigma_\\mathrm{C} + \\sigma_\\mathrm{O}}{2} = \\frac{0.340 + 0.316}{2} = 0.328 \\text{ nm} $$\nThe attractive dispersion coefficient $C_6$ is derived from the Lennard-Jones potential, $U_{LJ}(r) = 4\\epsilon[(\\sigma/r)^{12} - (\\sigma/r)^6]$, where the attractive term is $-4\\epsilon\\sigma^6 r^{-6}$. Thus, $C_6 = 4\\epsilon\\sigma^6$.\n$$ C_6 = 4 \\epsilon \\sigma^6 = 4 (0.423556) (0.328)^6 \\approx 0.00211116 \\text{ kJ/mol} \\cdot \\text{nm}^6 $$\n\n**1. Derivation of the Dispersion-Only Energy ($G_\\mathrm{np}^{\\mathrm{disp}}$)**\n\nThis derivation proceeds in two steps: first, calculating the interaction energy of a single solute site with the entire solvent continuum, and second, integrating this site-continuum energy over the entire solute surface.\n\n**Step 1.1: Interaction of a Single Solute Site with the Solvent Half-Space**\nLet a single solute site be located at position $\\mathbf{r}_s = (x_s, y_s, z_s)$, where $z_s > 0$. The solvent is a continuum with uniform number density $\\rho$ occupying the half-space $z' < 0$. The interaction potential between the solute site and a differential volume element of the solvent $\\mathrm{d}V'$ at position $\\mathbf{r}'$ is given by the pairwise London dispersion potential, $u(r) = -C_6 r^{-6}$, where $r = |\\mathbf{r}_s - \\mathbf{r}'|$.\n\nThe total interaction energy, $U_\\text{site}$, of the solute site with the entire solvent half-space is obtained by integrating the contributions from all solvent volume elements:\n$$ U_\\text{site}(z_s) = \\int_{\\text{solvent}} \\rho \\, u(|\\mathbf{r}_s - \\mathbf{r}'|) \\, \\mathrm{d}V' = \\int_{-\\infty}^{0} \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} \\rho (-C_6) \\left((x_s-x')^2 + (y_s-y')^2 + (z_s-z')^2\\right)^{-3} \\mathrm{d}x' \\mathrm{d}y' \\mathrm{d}z' $$\nWe switch to cylindrical coordinates $(\\tilde{r}, \\theta, z')$ centered at $(x_s, y_s, z')$ for the integration over the $x'y'$ plane. Let $\\tilde{r}^2 = (x_s-x')^2 + (y_s-y')^2$. The volume element becomes $\\mathrm{d}x' \\mathrm{d}y' = \\tilde{r} \\, \\mathrm{d}\\tilde{r} \\, \\mathrm{d}\\theta$.\n$$ U_\\text{site}(z_s) = - \\rho C_6 \\int_{-\\infty}^{0} \\left( \\int_{0}^{2\\pi} \\mathrm{d}\\theta \\int_{0}^{\\infty} \\frac{\\tilde{r}}{(\\tilde{r}^2 + (z_s-z')^2)^3} \\, \\mathrm{d}\\tilde{r} \\right) \\mathrm{d}z' $$\nThe integral over $\\theta$ gives $2\\pi$. The integral over $\\tilde{r}$ is:\n$$ \\int_{0}^{\\infty} \\frac{\\tilde{r}}{(\\tilde{r}^2 + (z_s-z')^2)^3} \\, \\mathrm{d}\\tilde{r} = \\frac{1}{2} \\int_{(z_s-z')^2}^{\\infty} w^{-3} \\, \\mathrm{d}w = \\frac{1}{2} \\left[ -\\frac{1}{2} w^{-2} \\right]_{(z_s-z')^2}^{\\infty} = \\frac{1}{4(z_s-z')^4} $$\nSubstituting this back, we get:\n$$ U_\\text{site}(z_s) = - \\rho C_6 (2\\pi) \\int_{-\\infty}^{0} \\frac{1}{4(z_s-z')^4} \\, \\mathrm{d}z' = -\\frac{\\pi \\rho C_6}{2} \\int_{-\\infty}^{0} (z_s-z')^{-4} \\, \\mathrm{d}z' $$\nThe final integral with respect to $z'$ evaluates to:\n$$ \\int_{-\\infty}^{0} (z_s-z')^{-4} \\, \\mathrm{d}z' = \\left[ \\frac{1}{3} (z_s-z')^{-3} \\right]_{-\\infty}^{0} = \\frac{1}{3} z_s^{-3} $$\nThus, the interaction energy of a single solute site at height $z_s$ above the solvent plane is:\n$$ U_\\text{site}(z_s) = -\\frac{\\pi \\rho C_6}{6 z_s^3} $$\n\n**Step 1.2: Integration over the Corrugated Solute Surface**\nThe solute is a surface patch with a uniform site density $\\sigma_s$. The number of sites in a differential surface area element $\\mathrm{d}S$ is $\\sigma_s \\mathrm{d}S$. The total dispersion energy, $G_\\mathrm{np}^{\\mathrm{disp}}$, is the sum of energies of all sites on the surface. The height of the surface is given by $z(x,y) = h + A \\cos(k_x x)\\cos(k_y y)$.\n$$ G_\\mathrm{np}^{\\mathrm{disp}} = \\int_{\\text{surface}} \\sigma_s U_\\text{site}(z(x,y)) \\, \\mathrm{d}S $$\nThe surface area element $\\mathrm{d}S$ is related to the projected area element $\\mathrm{d}x \\mathrm{d}y$ by $\\mathrm{d}S = \\sqrt{1 + |\\nabla z|^2} \\, \\mathrm{d}x \\mathrm{d}y$. To avoid divergence at small separations, the local distance $z(x,y)$ is replaced by an effective distance $d_\\mathrm{eff}(x,y) = \\max(z(x,y), d_\\mathrm{cut})$.\nSubstituting the expression for $U_\\text{site}$ and $\\mathrm{d}S$, we get the integral for the total energy over the domain $[0, L_x] \\times [0, L_y]$:\n$$ G_\\mathrm{np}^{\\mathrm{disp}} = \\int_{0}^{L_y} \\int_{0}^{L_x} \\left( \\sigma_s \\left( -\\frac{\\pi \\rho C_6}{6 [\\max(z(x,y), d_\\mathrm{cut})]^3} \\right) \\right) \\sqrt{1 + |\\nabla z|^2} \\, \\mathrm{d}x \\mathrm{d}y $$\nLet's define a constant prefactor $E_0 = -\\frac{\\pi \\rho \\sigma_s C_6}{6}$. The final expression is:\n$$ G_\\mathrm{np}^{\\mathrm{disp}} = E_0 \\int_{0}^{L_y} \\int_{0}^{L_x} \\frac{\\sqrt{1 + |\\nabla z(x,y)|^2}}{[\\max(z(x,y), d_\\mathrm{cut})]^3} \\, \\mathrm{d}x \\mathrm{d}y $$\nwhere $|\\nabla z|^2 = (\\partial z/\\partial x)^2 + (\\partial z/\\partial y)^2$. For $z(x,y) = h + A \\cos(k_x x)\\cos(k_y y)$:\n$$ \\frac{\\partial z}{\\partial x} = -A k_x \\sin(k_x x)\\cos(k_y y) \\quad \\text{and} \\quad \\frac{\\partial z}{\\partial y} = -A k_y \\cos(k_x x)\\sin(k_y y) $$\nThis double integral is evaluated numerically using a discrete grid summation.\n\n**2. Formulation of the SASA-Based Energy ($G_\\mathrm{np}^{\\mathrm{SASA}}$)**\n\nThis model is simpler and defined by the formula $G_\\mathrm{np}^{\\mathrm{SASA}} = \\gamma A$, where $\\gamma$ is the surface tension coefficient and $A$ is the solvent-accessible surface area. The problem specifies that $A$ is to be calculated as the geometric area of the solute surface:\n$$ A = \\int_{0}^{L_y} \\int_{0}^{L_x} \\mathrm{d}S = \\int_{0}^{L_y} \\int_{0}^{L_x} \\sqrt{1 + |\\nabla z(x,y)|^2} \\, \\mathrm{d}x \\mathrm{d}y $$\nThis integral is also evaluated numerically over the same grid as the dispersion calculation.\n\n**3. Numerical Implementation**\n\nThe integrals for $G_\\mathrm{np}^{\\mathrm{disp}}$ and $A$ are approximated by a sum over a uniform grid of $N_x \\times N_y$ points. Let $\\Delta x = L_x / N_x$ and $\\Delta y = L_y / N_y$. The grid points are $(x_i, y_j)$ where $x_i = (i+0.5)\\Delta x$ for $i \\in [0, N_x-1]$ and $y_j = (j+0.5)\\Delta y$ for $j \\in [0, N_y-1]$.\n\nThe surface area $A$ is approximated as:\n$$ A \\approx \\sum_{j=0}^{N_y-1} \\sum_{i=0}^{N_x-1} \\sqrt{1 + |\\nabla z(x_i, y_j)|^2} \\, \\Delta x \\Delta y $$\nThe SASA-based energy is then $G_\\mathrm{np}^{\\mathrm{SASA}} = \\gamma A$.\n\nThe dispersion energy is approximated as:\n$$ G_\\mathrm{np}^{\\mathrm{disp}} \\approx E_0 \\sum_{j=0}^{N_y-1} \\sum_{i=0}^{N_x-1} \\frac{\\sqrt{1 + |\\nabla z(x_i, y_j)|^2}}{[\\max(z(x_i, y_j), d_\\mathrm{cut})]^3} \\, \\Delta x \\Delta y $$\n\nFinally, the ratio $r$ is computed as $r = |G_\\mathrm{np}^{\\mathrm{disp}}| / G_\\mathrm{np}^{\\mathrm{SASA}}$. The numerical implementation in Python will follow this procedure for each test case specified. For the special case where the amplitude $A=0$, the surface is flat, $|\\nabla z|^2 = 0$, and the integrals simplify to analytical expressions, providing a useful check. In this case, $A = L_x L_y$ and $G_\\mathrm{np}^{\\mathrm{disp}} = E_0 L_x L_y / [\\max(h, d_\\mathrm{cut})]^3$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares two nonpolar solvation free energy models\n    at a liquid-solid interface for a corrugated solute surface.\n    \"\"\"\n\n    # Physical and numerical constants\n    RHO = 33.3  # Solvent number density (nm^-3)\n    SIGMA_S = 38.2  # Solute site density (nm^-2)\n    \n    # Lennard-Jones parameters\n    EPS_C = 0.276  # kJ/mol\n    SIGMA_C = 0.340  # nm\n    EPS_O = 0.650  # kJ/mol\n    SIGMA_O = 0.316  # nm\n\n    # Lorentz-Berthelot mixing rules\n    epsilon = np.sqrt(EPS_C * EPS_O)\n    sigma = (SIGMA_C + SIGMA_O) / 2.0\n    \n    # Attractive coefficient C6\n    c6 = 4.0 * epsilon * sigma**6  # kJ/mol * nm^6\n\n    # Prefactor for dispersion energy calculation\n    E0 = - (np.pi * RHO * SIGMA_S * c6) / 6.0  # kJ/mol\n\n    # SASA model coefficient\n    GAMMA = 2.30  # kJ/mol/nm^2\n\n    # Physical cutoff distance\n    D_CUT = 0.28  # nm\n\n    # Domain size and grid resolution\n    LX, LY = 5.0, 5.0  # nm\n    NX, NY = 400, 400\n\n    # Grid spacing\n    dx = LX / NX\n    dy = LY / NY\n    da = dx * dy  # Area element\n\n    # Test suite: (h, A, lambda_x, lambda_y) in nm\n    test_cases = [\n        (0.50, 0.05, 1.00, 1.00),  # Case 1\n        (0.50, 0.00, 1.00, 1.00),  # Case 2\n        (0.50, 0.20, 1.00, 1.00),  # Case 3\n        (1.50, 0.05, 1.00, 1.00),  # Case 4\n        (0.50, 0.05, 0.50, 0.25),  # Case 5\n    ]\n\n    results = []\n    \n    # Create grid coordinates (midpoint rule for better accuracy)\n    x_vals = (np.arange(NX) + 0.5) * dx\n    y_vals = (np.arange(NY) + 0.5) * dy\n    xx, yy = np.meshgrid(x_vals, y_vals)\n\n    for h, A, lambda_x, lambda_y in test_cases:\n        \n        # Handle the flat surface (A=0) case analytically\n        if A == 0.0:\n            area = LX * LY\n            g_sasa = GAMMA * area\n            d_eff = np.maximum(h, D_CUT)\n            g_disp = E0 * area / (d_eff**3)\n            ratio = np.abs(g_disp) / g_sasa\n            results.append([round(g_disp, 6), round(g_sasa, 6), round(ratio, 6)])\n            continue\n\n        # Wavenumbers\n        kx = 2.0 * np.pi / lambda_x\n        ky = 2.0 * np.pi / lambda_y\n\n        # Surface height field z(x,y)\n        z = h + A * np.cos(kx * xx) * np.cos(ky * yy)\n        \n        # Gradients dz/dx and dz/dy\n        dz_dx = -A * kx * np.sin(kx * xx) * np.cos(ky * yy)\n        dz_dy = -A * ky * np.cos(kx * xx) * np.sin(ky * yy)\n        \n        # Surface area element factor\n        area_factor = np.sqrt(1.0 + dz_dx**2 + dz_dy**2)\n        \n        # Total surface area A\n        area = np.sum(area_factor) * da\n        \n        # SASA-based energy\n        g_sasa = GAMMA * area\n        \n        # Effective distance with cutoff\n        d_eff = np.maximum(z, D_CUT)\n        \n        # Integrand for dispersion energy\n        integrand_disp = area_factor / (d_eff**3)\n        \n        # Dispersion energy\n        g_disp = E0 * np.sum(integrand_disp) * da\n        \n        # Ratio\n        ratio = np.abs(g_disp) / g_sasa\n        \n        results.append([round(g_disp, 6), round(g_sasa, 6), round(ratio, 6)])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{d:.6f},{s:.6f},{r:.6f}]\" for d, s, r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Calculating the total free energy of a process, such as transferring an ion from vacuum to a solvent, is a central task in computational chemistry. This practice introduces Thermodynamic Integration (TI), a robust and widely used method for computing free energy differences via \"alchemical\" transformations. Through a guided numerical exercise that uses idealized potential functions, you will learn the core mechanics of setting up a TI calculation, assessing its convergence and hysteresis, and interpreting the results of a multi-step alchemical cycle .",
            "id": "3899799",
            "problem": "You are asked to compute the solvation free energy of an ion using Thermodynamic Integration (TI) with a soft-core Coulomb coupling parameter and then assess hysteresis and cycle closure in a three-step alchemical path. The scientific base must be consistent with the fundamental TI framework. The computation is framed using idealized but scientifically plausible models and constants that allow deterministic numerical integration within a single program.\n\nStart from the following bases:\n\n1. The Thermodynamic Integration (TI) definition: the free energy change along a coupling parameter path is given by the integral\n$$\n\\Delta G = \\int_{0}^{1} \\left\\langle \\frac{\\partial U(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\, d\\lambda,\n$$\nwhere $U(\\lambda)$ is the potential energy that depends on the coupling parameter $\\lambda$, and $\\langle \\cdot \\rangle_{\\lambda}$ denotes an ensemble average at fixed $\\lambda$. The backward integral for the reversed path obeys\n$$\n\\Delta G_{\\text{backward}} = -\\int_{0}^{1} \\left\\langle \\frac{\\partial U_{\\text{back}}(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\, d\\lambda,\n$$\nso that, in the absence of sampling error, the forward and backward paths add to zero.\n\n2. The Born solvation model for the Coulombic contribution of an ion of valence $z$, radius $r$, and solvent dielectric constant $\\varepsilon_{r}$ is given by the Born free energy\n$$\n\\Delta G_{\\text{Born}} = -\\frac{N_{\\mathrm{A}}}{8\\pi \\varepsilon_{0}} \\frac{(z e)^{2}}{r}\\left(1 - \\frac{1}{\\varepsilon_{r}}\\right),\n$$\nexpressed in joules per mole, where $N_{\\mathrm{A}}$ is the Avogadro number, $\\varepsilon_{0}$ is the permittivity of free space, and $e$ is the elementary charge. This will be converted to kilojoules per mole ($\\mathrm{kJ/mol}$) in your calculations. To mimic a soft-core Coulomb coupling, the ensemble-averaged derivative for the Coulomb step will be modeled as\n$$\n\\left\\langle \\frac{\\partial U_{\\text{coul}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = A \\frac{\\lambda}{\\sqrt{1 + \\alpha_{\\text{c}}(1 - \\lambda)^{2}}},\n$$\nwith $A = 2\\,\\Delta G_{\\text{Born}}$ so that in the limit $\\alpha_{\\text{c}} = 0$ the integral reproduces $\\Delta G_{\\text{Born}}$.\n\n3. The van der Waals (dispersion) step is modeled by an ensemble-averaged derivative function\n$$\n\\left\\langle \\frac{\\partial U_{\\text{vdW}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = B \\frac{3\\lambda^{2}}{1 + \\alpha_{\\text{LJ}}(1 - \\lambda)^{2}},\n$$\nwhere $B$ is a specified amplitude in $\\mathrm{kJ/mol}$ that would equal the dispersion contribution when $\\alpha_{\\text{LJ}} = 0$, and $\\alpha_{\\text{LJ}} \\ge 0$ is a Lennard-Jones style soft-core parameter.\n\n4. A restraint or cavity correction step is modeled as a constant derivative\n$$\n\\left\\langle \\frac{\\partial U_{\\text{rest}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = C,\n$$\nwith $C$ in $\\mathrm{kJ/mol}$.\n\nTo assess hysteresis, the backward path ensemble-averaged derivatives are defined as forward derivatives plus a $\\lambda$-dependent bias intended to reflect sampling error. Specifically, for step $i \\in \\{\\text{coul}, \\text{vdW}, \\text{rest}\\}$,\n$$\n\\left\\langle \\frac{\\partial U_{i,\\text{back}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = \\left\\langle \\frac{\\partial U_{i,\\text{fwd}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} + \\delta_{i}\\,\\sin(\\pi \\lambda),\n$$\nwhere $\\delta_{i}$ is a specified hysteresis amplitude in $\\mathrm{kJ/mol}$ and the integral sign is reversed for the backward free energy as per the TI base.\n\nNumerical integration across $\\lambda \\in [0,1]$ must be performed with composite Simpson’s rule on an evenly spaced grid with an odd number of points $N$ to ensure proper application of the rule,\n$$\n\\int_{0}^{1} f(\\lambda)\\,d\\lambda \\approx \\frac{h}{3}\\left[f_{0} + f_{N-1} + 4\\sum_{j=1,3,\\ldots,N-2} f_{j} + 2\\sum_{j=2,4,\\ldots,N-3} f_{j}\\right],\n$$\nwhere $h = \\frac{1}{N-1}$ and $f_{j} = f(\\lambda_{j})$.\n\nYour task:\n\n- For each test case provided below, compute the forward free energy contributions for the three steps and sum them to obtain the total forward solvation free energy,\n$$\n\\Delta G_{\\text{total,fwd}} = \\Delta G_{\\text{coul,fwd}} + \\Delta G_{\\text{vdW,fwd}} + \\Delta G_{\\text{rest,fwd}}.\n$$\n- Compute the backward contributions using the biased backward derivatives and the reversed integral definition to obtain\n$$\n\\Delta G_{\\text{total,back}} = \\Delta G_{\\text{coul,back}} + \\Delta G_{\\text{vdW,back}} + \\Delta G_{\\text{rest,back}}.\n$$\n- For each step, compute the hysteresis as\n$$\nH_{i} = \\Delta G_{i,\\text{fwd}} + \\Delta G_{i,\\text{back}},\n$$\nand report the maximum absolute step hysteresis\n$$\nH_{\\max} = \\max\\left(|H_{\\text{coul}}|, |H_{\\text{vdW}}|, |H_{\\text{rest}}|\\right).\n$$\n- Compute the cycle closure metric for the three-step path as\n$$\n\\Xi = \\Delta G_{\\text{total,fwd}} + \\Delta G_{\\text{total,back}},\n$$\nwhich would be $0$ in the ideal reversible limit without sampling error.\n\nAll free energies must be expressed in kilojoules per mole ($\\mathrm{kJ/mol}$). Use the following physical constants: Avogadro number $N_{\\mathrm{A}} = 6.02214076\\times 10^{23}\\,\\mathrm{mol^{-1}}$, vacuum permittivity $\\varepsilon_{0} = 8.8541878128\\times 10^{-12}\\,\\mathrm{F/m}$, elementary charge $e = 1.602176634\\times 10^{-19}\\,\\mathrm{C}$, and Coulomb constant $k_{\\mathrm{e}} = \\frac{1}{4\\pi \\varepsilon_{0}}$. Distances for ion radii are given in angstroms and must be converted to meters, with $1\\,\\text{\\AA} = 10^{-10}\\,\\mathrm{m}$.\n\nTest suite parameter sets:\n\n- Case $1$ (happy path):\n  - Ion valence $z = +1$, ion radius $r = 1.9\\,\\text{\\AA}$, solvent dielectric constant $\\varepsilon_{r} = 78.3$.\n  - Coulomb soft-core parameter $\\alpha_{\\text{c}} = 0.5$.\n  - Van der Waals amplitude $B = 8.0\\,\\mathrm{kJ/mol}$ and $\\alpha_{\\text{LJ}} = 0.2$.\n  - Restraint amplitude $C = 1.5\\,\\mathrm{kJ/mol}$.\n  - Hysteresis amplitudes $\\delta_{\\text{coul}} = 0.5\\,\\mathrm{kJ/mol}$, $\\delta_{\\text{vdW}} = 0.2\\,\\mathrm{kJ/mol}$, $\\delta_{\\text{rest}} = 0.05\\,\\mathrm{kJ/mol}$.\n  - Number of grid points $N = 101$.\n\n- Case $2$ (boundary case with no soft-core and no hysteresis):\n  - Ion valence $z = -1$, ion radius $r = 2.05\\,\\text{\\AA}$, solvent dielectric constant $\\varepsilon_{r} = 78.3$.\n  - Coulomb soft-core parameter $\\alpha_{\\text{c}} = 0$.\n  - Van der Waals amplitude $B = 6.0\\,\\mathrm{kJ/mol}$ and $\\alpha_{\\text{LJ}} = 0$.\n  - Restraint amplitude $C = 1.0\\,\\mathrm{kJ/mol}$.\n  - Hysteresis amplitudes $\\delta_{\\text{coul}} = 0.0\\,\\mathrm{kJ/mol}$, $\\delta_{\\text{vdW}} = 0.0\\,\\mathrm{kJ/mol}$, $\\delta_{\\text{rest}} = 0.0\\,\\mathrm{kJ/mol}$.\n  - Number of grid points $N = 101$.\n\n- Case $3$ (edge case with strong soft-core and significant hysteresis):\n  - Ion valence $z = +2$, ion radius $r = 0.72\\,\\text{\\AA}$, solvent dielectric constant $\\varepsilon_{r} = 78.3$.\n  - Coulomb soft-core parameter $\\alpha_{\\text{c}} = 3.0$.\n  - Van der Waals amplitude $B = 12.0\\,\\mathrm{kJ/mol}$ and $\\alpha_{\\text{LJ}} = 0.5$.\n  - Restraint amplitude $C = 2.0\\,\\mathrm{kJ/mol}$.\n  - Hysteresis amplitudes $\\delta_{\\text{coul}} = 3.0\\,\\mathrm{kJ/mol}$, $\\delta_{\\text{vdW}} = 1.0\\,\\mathrm{kJ/mol}$, $\\delta_{\\text{rest}} = 0.2\\,\\mathrm{kJ/mol}$.\n  - Number of grid points $N = 101$.\n\nFinal output requirement:\n\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each case contributes a list of four floats in the following order:\n  - $\\Delta G_{\\text{total,fwd}}$ in $\\mathrm{kJ/mol}$,\n  - $\\Delta G_{\\text{total,back}}$ in $\\mathrm{kJ/mol}$,\n  - $H_{\\max}$ in $\\mathrm{kJ/mol}$,\n  - $\\Xi$ in $\\mathrm{kJ/mol}$.\n- The format must be exactly\n$$\n\\left[ [g_{1,\\text{fwd}}, g_{1,\\text{back}}, h_{1,\\max}, \\xi_{1}], [g_{2,\\text{fwd}}, g_{2,\\text{back}}, h_{2,\\max}, \\xi_{2}], [g_{3,\\text{fwd}}, g_{3,\\text{back}}, h_{3,\\max}, \\xi_{3}] \\right],\n$$\nwith no additional text, where subscripts $1,2,3$ indicate the respective test cases.\n\nAll computed free energies must be expressed in $\\mathrm{kJ/mol}$ and angles in trigonometric functions are in radians.",
            "solution": "The problem statement has been critically validated and is determined to be valid. It is scientifically grounded in the principles of statistical mechanics and computational chemistry, specifically the Thermodynamic Integration (TI) framework. The problem is well-posed, with all necessary parameters, constants, and functional forms explicitly defined, ensuring that a unique and meaningful numerical solution can be obtained. The language is objective and unambiguous. The models used, while idealized, are plausible representations for the steps in an alchemical transformation, and the overall task constitutes a standard, albeit comprehensive, computational exercise in free energy calculation.\n\nThe solution proceeds by implementing the specified mathematical models and numerical methods. The core task is to compute the free energy change, $\\Delta G$, for three distinct alchemical steps (Coulombic, van der Waals, and restraint) along a forward and a backward path.\n\nFirst, we define the necessary physical constants, which must be in SI units for calculations.\n- Avogadro number: $N_{\\mathrm{A}} = 6.02214076\\times 10^{23}\\,\\mathrm{mol^{-1}}$\n- Vacuum permittivity: $\\varepsilon_{0} = 8.8541878128\\times 10^{-12}\\,\\mathrm{F/m}$\n- Elementary charge: $e = 1.602176634\\times 10^{-19}\\,\\mathrm{C}$\n- The angstrom-to-meter conversion is $1\\,\\text{\\AA} = 10^{-10}\\,\\mathrm{m}$.\n\nThe Coulombic step requires a pre-calculation of the Born free energy, $\\Delta G_{\\text{Born}}$, for an ion of valence $z$ and radius $r$ in a solvent with dielectric constant $\\varepsilon_{r}$. The formula provided is\n$$\n\\Delta G_{\\text{Born}} = -\\frac{N_{\\mathrm{A}}}{8\\pi \\varepsilon_{0}} \\frac{(z e)^{2}}{r}\\left(1 - \\frac{1}{\\varepsilon_{r}}\\right)\n$$\nThis expression yields a result in Joules per mole ($\\mathrm{J/mol}$). To conform with the problem's unit requirements, this value is converted to kilojoules per mole ($\\mathrm{kJ/mol}$) by dividing by $1000$. The parameter $A$ for the Coulombic integrand is then defined as $A = 2\\,\\Delta G_{\\text{Born}}$.\n\nThe calculation of free energy changes for each step $i \\in \\{\\text{coul}, \\text{vdW}, \\text{rest}\\}$ is based on the TI formula, which requires integrating the ensemble-averaged derivative of the potential energy with respect to the coupling parameter $\\lambda$:\n$$\n\\Delta G_{i, \\text{fwd}} = \\int_{0}^{1} \\left\\langle \\frac{\\partial U_{i,\\text{fwd}}(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\, d\\lambda\n$$\nThe problem defines the specific functional forms for these integrands:\n- Coulombic: $\\left\\langle \\frac{\\partial U_{\\text{coul}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = A \\frac{\\lambda}{\\sqrt{1 + \\alpha_{\\text{c}}(1 - \\lambda)^{2}}}$\n- Van der Waals: $\\left\\langle \\frac{\\partial U_{\\text{vdW}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = B \\frac{3\\lambda^{2}}{1 + \\alpha_{\\text{LJ}}(1 - \\lambda)^{2}}$\n- Restraint: $\\left\\langle \\frac{\\partial U_{\\text{rest}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = C$\n\nThe integrals are computed numerically using the composite Simpson's rule over a discrete grid of $\\lambda$ values from $0$ to $1$ with $N$ points. The grid spacing is $h = 1 / (N-1)$. Since $N=101$, this is a valid configuration for Simpson's rule.\n\nFor the backward path, the derivatives are biased to simulate hysteresis:\n$$\n\\left\\langle \\frac{\\partial U_{i,\\text{back}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = \\left\\langle \\frac{\\partial U_{i,\\text{fwd}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} + \\delta_{i}\\,\\sin(\\pi \\lambda)\n$$\nThe backward free energy change is then calculated, per the problem's definition, as:\n$$\n\\Delta G_{i,\\text{back}} = -\\int_{0}^{1} \\left\\langle \\frac{\\partial U_{i,\\text{back}}(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\, d\\lambda\n$$\nThe negative sign is a crucial part of the definition provided.\n\nOnce the forward and backward free energy contributions for each of the three steps are computed, the final quantities are determined:\n1.  Total forward free energy: $\\Delta G_{\\text{total,fwd}} = \\Delta G_{\\text{coul,fwd}} + \\Delta G_{\\text{vdW,fwd}} + \\Delta G_{\\text{rest,fwd}}$.\n2.  Total backward free energy: $\\Delta G_{\\text{total,back}} = \\Delta G_{\\text{coul,back}} + \\Delta G_{\\text{vdW,back}} + \\Delta G_{\\text{rest,back}}$.\n3.  Stepwise hysteresis: $H_{i} = \\Delta G_{i,\\text{fwd}} + \\Delta G_{i,\\text{back}}$.\n4.  Maximum absolute hysteresis: $H_{\\max} = \\max\\left(|H_{\\text{coul}}|, |H_{\\text{vdW}}|, |H_{\\text{rest}}|\\right)$.\n5.  Cycle closure: $\\Xi = \\Delta G_{\\text{total,fwd}} + \\Delta G_{\\text{total,back}}$.\n\nThis full procedure is applied systematically to each of the three test cases provided. The numerical integration is performed using the `simpson` function from the `scipy.integrate` library, which provides a robust and accurate implementation of the specified rule. All final energy values are in units of $\\mathrm{kJ/mol}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import simpson\n\ndef solve():\n    \"\"\"\n    Computes solvation free energy, hysteresis, and cycle closure for a \n    three-step alchemical path using Thermodynamic Integration.\n    \"\"\"\n\n    # Physical Constants\n    NA = 6.02214076e23  # Avogadro number (mol^-1)\n    EPS0 = 8.8541878128e-12  # Vacuum permittivity (F/m)\n    E = 1.602176634e-19  # Elementary charge (C)\n\n    # Test cases as defined in the problem statement\n    test_cases = [\n        {\n            \"z\": 1.0, \"r\": 1.9, \"eps_r\": 78.3,\n            \"alpha_c\": 0.5, \"B\": 8.0, \"alpha_LJ\": 0.2, \"C\": 1.5,\n            \"delta_coul\": 0.5, \"delta_vdW\": 0.2, \"delta_rest\": 0.05,\n            \"N\": 101,\n        },\n        {\n            \"z\": -1.0, \"r\": 2.05, \"eps_r\": 78.3,\n            \"alpha_c\": 0.0, \"B\": 6.0, \"alpha_LJ\": 0.0, \"C\": 1.0,\n            \"delta_coul\": 0.0, \"delta_vdW\": 0.0, \"delta_rest\": 0.0,\n            \"N\": 101,\n        },\n        {\n            \"z\": 2.0, \"r\": 0.72, \"eps_r\": 78.3,\n            \"alpha_c\": 3.0, \"B\": 12.0, \"alpha_LJ\": 0.5, \"C\": 2.0,\n            \"delta_coul\": 3.0, \"delta_vdW\": 1.0, \"delta_rest\": 0.2,\n            \"N\": 101,\n        },\n    ]\n\n    results = []\n\n    for params in test_cases:\n        # Unpack parameters for the current case\n        z, r_angstrom, eps_r = params[\"z\"], params[\"r\"], params[\"eps_r\"]\n        alpha_c, B, alpha_LJ, C = params[\"alpha_c\"], params[\"B\"], params[\"alpha_LJ\"], params[\"C\"]\n        d_c, d_v, d_r = params[\"delta_coul\"], params[\"delta_vdW\"], params[\"delta_rest\"]\n        N = params[\"N\"]\n\n        # Create the lambda grid for integration\n        lamb_grid = np.linspace(0.0, 1.0, N)\n\n        # 1. Coulombic Contribution Calculation\n        # Convert radius from Angstrom to meters\n        r_m = r_angstrom * 1e-10\n        # Calculate Born free energy in J/mol\n        # The term (e^2 / (8*pi*eps0)) is a constant prefactor\n        dg_born_J_per_mol = - (NA * E**2) / (8 * np.pi * EPS0) * (z**2 / r_m) * (1 - 1 / eps_r)\n        # Convert to kJ/mol\n        dg_born_kJ_per_mol = dg_born_J_per_mol / 1000.0\n        # Define the amplitude A for the integrand\n        A = 2.0 * dg_born_kJ_per_mol\n\n        # Define the forward and backward integrands for the Coulombic step\n        dudl_coul_fwd = A * lamb_grid / np.sqrt(1 + alpha_c * (1 - lamb_grid)**2)\n        dudl_coul_back = dudl_coul_fwd + d_c * np.sin(np.pi * lamb_grid)\n\n        # Integrate using Simpson's rule\n        dg_coul_fwd = simpson(dudl_coul_fwd, lamb_grid)\n        dg_coul_back = -simpson(dudl_coul_back, lamb_grid)\n\n        # 2. Van der Waals Contribution Calculation\n        # Define the forward and backward integrands for the vdW step\n        dudl_vdw_fwd = B * 3 * lamb_grid**2 / (1 + alpha_LJ * (1 - lamb_grid)**2)\n        dudl_vdw_back = dudl_vdw_fwd + d_v * np.sin(np.pi * lamb_grid)\n\n        # Integrate\n        dg_vdw_fwd = simpson(dudl_vdw_fwd, lamb_grid)\n        dg_vdw_back = -simpson(dudl_vdw_back, lamb_grid)\n        \n        # 3. Restraint Contribution Calculation\n        # Define the forward and backward integrands for the restraint step\n        dudl_rest_fwd = np.full_like(lamb_grid, C)\n        dudl_rest_back = dudl_rest_fwd + d_r * np.sin(np.pi * lamb_grid)\n\n        # Integrate\n        dg_rest_fwd = simpson(dudl_rest_fwd, lamb_grid)\n        dg_rest_back = -simpson(dudl_rest_back, lamb_grid)\n\n        # 4. Calculate Total Energies, Hysteresis, and Cycle Closure\n        # Total forward and backward free energies\n        dg_total_fwd = dg_coul_fwd + dg_vdw_fwd + dg_rest_fwd\n        dg_total_back = dg_coul_back + dg_vdw_back + dg_rest_back\n\n        # Step-wise hysteresis\n        h_coul = dg_coul_fwd + dg_coul_back\n        h_vdw = dg_vdw_fwd + dg_vdw_back\n        h_rest = dg_rest_fwd + dg_rest_back\n        \n        # Maximum absolute hysteresis\n        h_max = max(abs(h_coul), abs(h_vdw), abs(h_rest))\n        \n        # Cycle closure\n        xi = dg_total_fwd + dg_total_back\n        \n        # Collect results for this case\n        results.append([dg_total_fwd, dg_total_back, h_max, xi])\n\n    # Format the final output string as specified\n    case_strings = []\n    for res_list in results:\n        # Format each number to a string and join with commas\n        case_strings.append(\"[\" + \",\".join(map(str, res_list)) + \"]\")\n    \n    # Join all cases and wrap in brackets\n    final_output_string = \"[\" + \",\".join(case_strings) + \"]\"\n\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}