{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导你应用混合泛函来解决一个基本问题：计算分子的电离能。你将使用$\\Delta$SCF方法，这是一种基于总能量差的直接而强大的技术，来分别计算水分子的垂直电离能和绝热电离能。通过这个实践，你将能深刻理解电子跃遷与核弛豫在时间尺度上的差异，以及这两个不同物理过程在光谱学和反应动力学中的重要性。",
            "id": "1373531",
            "problem": "一名计算化学专业的学生正在使用密度泛函理论 (DFT) 研究水分子 ($\\text{H}_2\\text{O}$) 的电离过程。他们使用了一种杂化泛函，我们称之为“HYB-25”。该泛函通过将 25% 的精确 Hartree-Fock (HF) 交换能与 75% 的广义梯度近似 (GGA) 泛函的交换能混合，再加上全部的 GGA 相关能来计算交换相关能。\n\n该学生进行了三个独立的电子结构计算：\n1.  对中性 $\\text{H}_2\\text{O}$ 分子进行几何优化，得到平衡总电子能为 $E_{\\text{neut, eq}} = -76.4591$ 哈特里。\n2.  对 $\\text{H}_2\\text{O}^+$ 阳离子进行单点能计算。阳离子的几何结构被冻结在中性 $\\text{H}_2\\text{O}$ 分子的平衡几何结构上。得到的总电子能为 $E_{\\text{cat, neut\\_geom}} = -76.0118$ 哈特里。\n3.  对 $\\text{H}_2\\text{O}^+$ 阳离子进行完全几何优化，得到新的平衡几何结构及相应的总电子能为 $E_{\\text{cat, eq}} = -76.0253$ 哈特里。\n\n移除一个电子所需的能量是电离势 (IP)。*垂直电离势*是指电离事件发生得非常快，以至于原子核来不及重新排列（在固定几何结构下的跃迁）时的能量变化。*绝热电离势*是中性物种的基态平衡态与电离后物种的基态平衡态之间的能量差。\n\n根据该学生的结果，计算以下三个量：\na) 水的垂直电离势。\nb) 水的绝热电离势。\nc) $\\text{H}_2\\text{O}^+$ 阳离子的几何弛豫能，定义为阳离子的几何结构从中性分子的平衡结构弛豫到其自身新的平衡结构时所释放的能量。\n\n使用换算因子 1 Hartree = 27.2114 eV。将所有三个量的最终答案按 (a, b, c) 的顺序以 eV 为单位表示，并四舍五入到三位有效数字。",
            "solution": "所使用的定义如下。垂直电离势是阳离子与中性物质在中性平衡几何结构下的能量差，绝热电离势是阳离子与中性物质在它们各自的平衡几何结构下的能量差，阳离子的几何弛豫能是阳离子从中性几何结构弛豫到其自身平衡几何结构时的能量降低值。\n\n设给定的能量为 $E_{\\text{neut, eq}}$、$E_{\\text{cat, neut\\_geom}}$ 和 $E_{\\text{cat, eq}}$，单位均为哈特里。那么\n$$\n\\text{IP}_{\\text{vert}} = E_{\\text{cat, neut\\_geom}} - E_{\\text{neut, eq}},\n$$\n$$\n\\text{IP}_{\\text{adia}} = E_{\\text{cat, eq}} - E_{\\text{neut, eq}},\n$$\n$$\nE_{\\text{relax}} = E_{\\text{cat, neut\\_geom}} - E_{\\text{cat, eq}}.\n$$\n代入所提供的值 $E_{\\text{neut, eq}} = -76.4591$，$E_{\\text{cat, neut\\_geom}} = -76.0118$ 和 $E_{\\text{cat, eq}} = -76.0253$（单位：哈特里），我们得到以哈特里为单位的能量差：\n$$\n\\text{IP}_{\\text{vert}} = -76.0118 - \\left(-76.4591\\right) = 0.4473,\n$$\n$$\n\\text{IP}_{\\text{adia}} = -76.0253 - \\left(-76.4591\\right) = 0.4338,\n$$\n$$\nE_{\\text{relax}} = -76.0118 - \\left(-76.0253\\right) = 0.0135.\n$$\n为了从哈特里转换为电子伏特，使用 $1\\ \\text{Hartree} = 27.2114\\ \\text{eV}$，因此每个量以 eV 为单位的值可以通过乘以 $27.2114$ 得到：\n$$\n\\text{IP}_{\\text{vert}} = 0.4473 \\times 27.2114 = 12.17165922\\ \\text{eV},\n$$\n$$\n\\text{IP}_{\\text{adia}} = 0.4338 \\times 27.2114 = 11.80430532\\ \\text{eV},\n$$\n$$\nE_{\\text{relax}} = 0.0135 \\times 27.2114 = 0.3673539\\ \\text{eV}.\n$$\n将每个值四舍五入到三位有效数字，得到\n$$\n\\text{IP}_{\\text{vert}} \\approx 12.2\\ \\text{eV},\\quad \\text{IP}_{\\text{adia}} \\approx 11.8\\ \\text{eV},\\quad E_{\\text{relax}} \\approx 0.367\\ \\text{eV}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}12.2  11.8  0.367\\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了基本的能量差计算后，我们将深入探讨近似密度泛函理论中的一个核心问题：离域误差。该误差表现为总能量$E$关于电子数$N$的函数关系偏离了精确的逐段线性条件，呈现出伪曲率。在本编程练习中，你将通过量化分析一个典型GGA泛函和一个混合泛函的$E(N)$曲线，具体地衡量并理解混合泛函是如何显著修正这一关键误差的。",
            "id": "3883189",
            "problem": "您需要设计并实现一个程序，使用两种密度泛函：Perdew–Burke–Ernzerhof 广义梯度近似 (PBE) 和 PBE0 杂化密度泛函，来量化分子催化剂的基态总能量 $E(N)$ 作为电子数在 $N$ 和 $N+1$ 之间的分数函数时，其与分段线性的偏离程度。该问题的基本依据是 Kohn–Sham 密度泛函理论 (DFT) 中的 Perdew–Parr–Levy–Balduz (PPLB) 结果，该结果指出，精确的基态总能量 $E(N)$ 相对于电子数是分段线性的：对于分数电子数 $N+f$（其中 $f \\in [0,1]$），精确能量是线性插值\n$$\nE_{\\mathrm{lin}}(f) = (1-f)\\,E(N) + f\\,E(N+1).\n$$\n在近似泛函中，由于多电子自相互作用和离域误差，会出现与线性的偏离。在区间 $f \\in [0,1]$ 上衡量这种偏离的一种科学合理的方法是，在边界条件 $E(0)=E(N)$ 和 $E(1)=E(N+1)$ 下，估计 $E(N+f)$ 相对于 $E_{\\mathrm{lin}}(f)$ 的曲率。任何可接受的曲率模型在 $f=0$ 和 $f=1$ 处都必须为零。满足这些条件的最小基函数是 $f(1-f)$。\n\n您的任务基于 PPLB 分段线性原理和标准最小二乘估计，包括：\n\n1. 对于每种泛函（PBE 和 PBE0）和每个测试用例，在模型\n$$\nE(f) \\approx E_{\\mathrm{lin}}(f) + k\\,f(1-f)\n$$\n中使用提供的离散样本 $\\{f_i, E(f_i)\\}$（其中 $f_i \\in \\{0, 0.25, 0.5, 0.75, 1\\}$）通过最小二乘拟合来估计标量曲率参数 $k$。这个 $k$ 是一个遵循端点约束的、对偏离线性程度的定量度量。最小二乘估计应最小化观测值 $E(f_i)$ 与模型值 $E_{\\mathrm{lin}}(f_i) + k\\,f_i(1-f_i)$ 之间的残差平方和。\n\n2. 对于每种泛函和每个测试用例，计算在采样网格上与分段线性的最大绝对偏差：\n$$\n\\max_i |E(f_i) - E_{\\mathrm{lin}}(f_i)|,\n$$\n以电子伏特 (eV) 表示。\n\n3. 对于每种泛函和每个测试用例，在给定网格上使用复合梯形法则计算在 $f \\in [0,1]$ 上的积分平方偏差 (ISD)，单位为平方电子伏特 (eV$^2$)：\n$$\n\\mathrm{ISD} \\approx \\sum_{i=0}^{4} w_i\\,\\Delta f \\,\\left(E(f_i) - E_{\\mathrm{lin}}(f_i)\\right)^2,\n$$\n其中均匀间距 $\\Delta f = 0.25$，梯形权重 $w_0 = w_4 = \\tfrac{1}{2}$ 且 $w_1 = w_2 = w_3 = 1$。\n\n所有能量必须以电子伏特为单位处理，输出的曲率 $k$ 和最大绝对偏差必须以电子伏特报告，积分平方偏差以平方电子伏特报告。所有输出均需四舍五入到六位小数。\n\n使用以下测试套件。对于每个用例，分数占据数为 $f \\in \\{0, 0.25, 0.5, 0.75, 1\\}$。提供了每种泛函在这些 $f$ 值下的能量。端点 $f=0$ 和 $f=1$ 分别对应于 $E(N)$ 和 $E(N+1)$。\n\n- 用例 A:\n    - PBE 能量 (eV): $[-100.000,\\,-100.400,\\,-100.750,\\,-101.050,\\,-101.300]$\n    - PBE0 能量 (eV): $[-100.000,\\,-100.3475,\\,-100.6800,\\,-100.9975,\\,-101.300]$\n\n- 用例 B:\n    - PBE 能量 (eV): $[-220.500,\\,-220.7375,\\,-220.9000,\\,-220.9875,\\,-221.000]$\n    - PBE0 能量 (eV): $[-220.500,\\,-220.6250,\\,-220.7500,\\,-220.8750,\\,-221.000]$\n\n- 用例 C:\n    - PBE 能量 (eV): $[-350.200,\\,-350.5375,\\,-350.8500,\\,-351.1375,\\,-351.400]$\n    - PBE0 能量 (eV): $[-350.200,\\,-350.4850,\\,-350.7800,\\,-351.0850,\\,-351.400]$\n\n算法要求：\n\n- 对于每个用例和每种泛函，使用该用例中该泛函的端点计算 $E_{\\mathrm{lin}}(f_i)$：$E(N) = E(f_0)$ 和 $E(N+1) = E(f_4)$。\n- 设定残差 $r_i = E(f_i) - E_{\\mathrm{lin}}(f_i)$ 和基值 $\\phi_i = f_i(1-f_i)$。\n- 通过对模型 $r_i \\approx k\\,\\phi_i$ 进行最小二乘法来估计 $k$，最小化 $\\sum_i (r_i - k\\,\\phi_i)^2$。\n- 按规定计算最大绝对残差和梯形 ISD。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表形式的结果，并用方括号括起来。\n- 对于每个测试用例，输出一个包含六个数字的列表：`[k_PBE, k_PBE0, max_dev_PBE, max_dev_PBE0, ISD_PBE, ISD_PBE0]`。\n- 所有值必须四舍五入到六位小数，并以电子伏特（对于 $k$ 和 $\\mathrm{max\\_dev}$）和平方电子伏特（对于 $\\mathrm{ISD}$）表示。\n- 将三个用例的列表聚合成一个外部列表。例如：`[[...],[...],[...]]`。\n\n您的程序必须是自包含的，且不得读取任何输入。它必须使用上面确切的测试套件，并按指定格式生成单行输出。",
            "solution": "该问题是有效的，因为它具有科学依据、问题明确且客观。它基于密度泛函理论 (DFT) 的一个基本原则，即 Perdew–Parr–Levy–Balduz (PPLB) 条件。该条件规定，精确的基态能量 $E(N)$ 必须是电子数 $N$ 的分段线性函数。对于两个整数 $N$ 和 $N+1$ 之间的非整数电子数（由分数占据数 $f \\in [0,1]$ 表示，使得总电子数为 $N+f$），精确能量是整数端点能量的线性插值：\n$$\nE_{\\mathrm{exact}}(f) = (1-f)\\,E(N) + f\\,E(N+1)\n$$\n近似密度泛函，例如 Perdew–Burke–Ernzerhof 广义梯度近似 (PBE) 和 PBE0 杂化泛函，通常违反此条件，表现出虚假的曲率。这种偏离是泛函自相互作用误差的一种表现。该问题为给定的能量数据点提供了一种严谨且标准的方法来量化这种偏离。\n\n解决方案首先确定每个采样点的线性偏离度，然后利用这些偏离度计算三个指标：曲率参数 $k$、最大绝对偏差和积分平方偏差 (ISD)。\n\n首先，对于每组对应于分数占据数 $\\{f_i\\}$ 的能量数据 $\\{E(f_i)\\}$，我们定义理想的线性能量 $E_{\\mathrm{lin}}(f_i)$。这基于提供的端点能量，$E(N) = E(f=0)$ 和 $E(N+1) = E(f=1)$。在每个点 $f_i$ 处的线性插值为：\n$$\nE_{\\mathrm{lin}}(f_i) = (1-f_i)\\,E(N) + f_i\\,E(N+1)\n$$\n与线性的偏离，我们称之为残差 $r_i$，是计算出的能量与理想线性能量之差：\n$$\nr_i = E(f_i) - E_{\\mathrm{lin}}(f_i)\n$$\n根据定义，端点处的残差为零：对于 $f_0=0$ 和 $f_4=1$，有 $r_{i=0} = 0$ 和 $r_{i=4} = 0$。\n\n其次，我们为模型 $E(f) \\approx E_{\\mathrm{lin}}(f) + k\\,f(1-f)$ 估计曲率参数 $k$。该模型可以根据残差重写为 $r_i \\approx k\\,\\phi_i$，其中 $\\phi_i = f_i(1-f_i)$ 是一个在端点 $f=0$ 和 $f=1$ 处正确地为零的基函数。为找到最拟合数据的 $k$ 的最优值，我们使用最小二乘法。这涉及最小化观测残差与模型残差之差的平方和 $S(k)$：\n$$\nS(k) = \\sum_{i=0}^{4} (r_i - k\\,\\phi_i)^2\n$$\n为了最小化 $S(k)$，我们将其关于 $k$ 的导数设为零：\n$$\n\\frac{dS}{dk} = \\frac{d}{dk} \\sum_{i=0}^{4} (r_i^2 - 2k\\,r_i\\phi_i + k^2\\phi_i^2) = \\sum_{i=0}^{4} (-2r_i\\phi_i + 2k\\phi_i^2) = 0\n$$\n求解 $k$ 可得到过原点线性回归的标准公式：\n$$\nk \\sum_{i=0}^{4} \\phi_i^2 = \\sum_{i=0}^{4} r_i\\phi_i \\implies k = \\frac{\\sum_{i=0}^{4} r_i \\phi_i}{\\sum_{i=0}^{4} \\phi_i^2}\n$$\n求和是在提供的样本点 $i \\in \\{0, 1, 2, 3, 4\\}$ 上进行的。由于 $\\phi_0 = \\phi_4 = 0$ 且 $r_0 = r_4 = 0$，只有内部点 $i \\in \\{1, 2, 3\\}$ 对求和有贡献。负的 $k$ 表示凸能量曲线（偏离在线性插值线下方），这对于许多 GGA 泛函是典型的，而正的 $k$ 表示凹曲线。\n\n第三，我们计算与线性的最大绝对偏差。这是对泛函非线性在采样网格上引入的最大误差的直接度量。它就是残差绝对值的最大值：\n$$\n\\mathrm{max\\_dev} = \\max_i |r_i| = \\max_i |E(f_i) - E_{\\mathrm{lin}}(f_i)|\n$$\n所有能量的单位都是电子伏特 (eV)，因此该偏差的单位也是 eV。\n\n第四，我们计算积分平方偏差 (ISD)。该指标提供了在整个区间 $f \\in [0,1]$ 上偏差的全局度量。我们使用复合梯形法则在 $f_i$ 值的均匀网格上近似残差平方的积分。步长为 $\\Delta f = 0.25$。公式如下：\n$$\n\\mathrm{ISD} \\approx \\sum_{i=0}^{4} w_i\\,\\Delta f \\,(E(f_i) - E_{\\mathrm{lin}}(f_i))^2 = \\Delta f \\sum_{i=0}^{4} w_i\\,r_i^2\n$$\n其中梯形权重为 $w_0 = w_4 = \\frac{1}{2}$ 且 $w_1 = w_2 = w_3 = 1$。由于 $r_0=r_4=0$，公式简化为：\n$$\n\\mathrm{ISD} \\approx \\Delta f \\,(r_1^2 + r_2^2 + r_3^2)\n$$\n该量的单位是平方电子伏特 (eV$^2$)。\n\n这三个指标（$k$、$\\mathrm{max\\_dev}$、ISD）将使用提供的能量数据，为三个测试用例中的每一种泛函（PBE 和 PBE0）进行计算。最终的数值结果将按要求四舍五入到六位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of quantifying deviation from piecewise linearity for DFT functionals.\n    \"\"\"\n\n    test_cases = [\n        # Case A\n        (\n            np.array([-100.000, -100.400, -100.750, -101.050, -101.300]),  # PBE\n            np.array([-100.000, -100.3475, -100.6800, -100.9975, -101.300]) # PBE0\n        ),\n        # Case B\n        (\n            np.array([-220.500, -220.7375, -220.9000, -220.9875, -221.000]),  # PBE\n            np.array([-220.500, -220.6250, -220.7500, -220.8750, -221.000])  # PBE0\n        ),\n        # Case C\n        (\n            np.array([-350.200, -350.5375, -350.8500, -351.1375, -351.400]),  # PBE\n            np.array([-350.200, -350.4850, -350.7800, -351.0850, -351.400])  # PBE0\n        )\n    ]\n\n    f_values = np.array([0, 0.25, 0.5, 0.75, 1.0])\n    \n    def calculate_metrics(energies, f_vals):\n        \"\"\"\n        Calculates k, max_dev, and ISD for a single energy dataset.\n        \n        Args:\n            energies (np.ndarray): Array of total energies E(f_i).\n            f_vals (np.ndarray): Array of fractional occupations f_i.\n            \n        Returns:\n            tuple: A tuple containing (k, max_dev, isd).\n        \"\"\"\n        # 1. Calculate linear interpolation and residuals\n        e_n = energies[0]\n        e_n_plus_1 = energies[-1]\n        e_lin = (1 - f_vals) * e_n + f_vals * e_n_plus_1\n        residuals = energies - e_lin\n\n        # 2. Estimate curvature parameter k\n        phi = f_vals * (1 - f_vals)\n        # The sums for k effectively only run over the three interior points,\n        # since r_i and phi_i are zero at the endpoints.\n        # sum(phi**2) will be the same for all cases.\n        numerator_k = np.sum(residuals * phi)\n        denominator_k = np.sum(phi**2)\n        \n        # Handle the case of a perfectly linear functional to avoid 0/0.\n        if np.isclose(denominator_k, 0):\n             k = 0.0\n        else:\n             k = numerator_k / denominator_k\n\n        # 3. Compute maximum absolute deviation\n        max_dev = np.max(np.abs(residuals))\n\n        # 4. Compute Integrated Squared Deviation (ISD)\n        delta_f = 0.25\n        # Weights for composite trapezoidal rule\n        weights = np.array([0.5, 1, 1, 1, 0.5])\n        isd = delta_f * np.sum(weights * (residuals**2))\n        \n        return k, max_dev, isd\n\n    all_results = []\n    for pbe_energies, pbe0_energies in test_cases:\n        k_pbe, max_dev_pbe, isd_pbe = calculate_metrics(pbe_energies, f_values)\n        k_pbe0, max_dev_pbe0, isd_pbe0 = calculate_metrics(pbe0_energies, f_values)\n        \n        case_results = [\n            k_pbe, k_pbe0,\n            max_dev_pbe, max_dev_pbe0,\n            isd_pbe, isd_pbe0\n        ]\n        all_results.append(case_results)\n\n    # Format the output string as per requirements\n    formatted_cases = []\n    for case_result in all_results:\n        rounded_result = [f\"{x:.6f}\" for x in case_result]\n        formatted_cases.append(f\"[{','.join(rounded_result)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_cases)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这个实践将理论与催化应用紧密联系起来。泛函的选择会直接影响反应活化能$E_a$的计算精度，而根据Arrhenius方程，这种影响会以指数形式放大，从而极大地改变预测的反应速率。你将通过一个表面催化反应的案例，分别使用GGA和混合泛函计算得到的活化能垒来预测其转换频率（TOF），直观地揭示泛函选择对催化活性关键指标的决定性作用。",
            "id": "3883163",
            "problem": "您的任务是从第一性原理出发，实现计算催化中单个基元表面反应的温度依赖性反应速率常数和转换频率，并比较使用两种不同电子结构方法（Perdew–Burke–Ernzerhof (PBE) 广义梯度近似和 Heyd–Scuseria–Ernzerhof (HSE06) 混合密度泛函）评估活化能垒得到的结果。考虑基元双分子表面反应 $A^\\ast + B^\\ast \\rightarrow AB^\\ast$，其中 $A^\\ast$ 和 $B^\\ast$ 表示吸附的反应物，$AB^\\ast$ 表示吸附的产物。使用成熟的动力学理论和过渡态理论（TST）作为基本基础。具体来说，从 TST 下的温度依赖性速率常数定义和基元双分子表面反应步骤的转换频率（TOF）标准定义开始，并且不要在这些基础之外假设或使用任何简化公式。为本练习之目的，假设除电子活化能垒外的其他贡献可以忽略不计，并且电子结构报告的能垒对应于活化自由能。所有计算都必须以物理上一致的方式进行，并正确处理单位。\n\n您的程序必须为每个提供的测试用例计算：\n- 使用 Perdew–Burke–Ernzerhof (PBE) 能垒评估的反应速率常数，记为 $k_{\\mathrm{PBE}}(T)$，单位为 $\\mathrm{s}^{-1}$。\n- 使用 Heyd–Scuseria–Ernzerhof (HSE06) 能垒评估的反应速率常数，记为 $k_{\\mathrm{HSE06}}(T)$，单位为 $\\mathrm{s}^{-1}$。\n- PBE 下的转换频率，$\\mathrm{TOF}_{\\mathrm{PBE}}(T)$，单位为 $\\mathrm{s}^{-1}$，根据速率常数和分数覆盖度为基元双分子表面反应步骤定义。\n- HSE06 下的转换频率，$\\mathrm{TOF}_{\\mathrm{HSE06}}(T)$，单位为 $\\mathrm{s}^{-1}$。\n- 一个标量，用于量化使用混合密度泛函与广义梯度近似对 TOF 的影响，定义为无量纲比率 $R = \\mathrm{TOF}_{\\mathrm{HSE06}}(T) / \\mathrm{TOF}_{\\mathrm{PBE}}(T)$。如果 $\\mathrm{TOF}_{\\mathrm{PBE}}(T) = 0$ 且 $\\mathrm{TOF}_{\\mathrm{HSE06}}(T) > 0$，则设 $R = +\\infty$；如果两者均为零，则设 $R = 0$。\n\n在您的实现中使用以下具有物理意义的常数：\n- 玻尔兹曼常数 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J}\\ \\mathrm{K}^{-1}$。\n- 普朗克常数 $h = 6.62607015\\times 10^{-34}\\ \\mathrm{J}\\ \\mathrm{s}$。\n- 电子伏特到焦耳的转换 $c_{\\mathrm{eV}\\rightarrow \\mathrm{J}} = 1.602176634\\times 10^{-19}\\ \\mathrm{J}\\ \\mathrm{eV}^{-1}$。\n\n所有活化能垒均以每个分子的 $\\mathrm{eV}$ 为单位提供，温度以 $\\mathrm{K}$ 为单位，覆盖度是 0 到 1 之间的无量纲分数。速率常数和转换频率必须以 $\\mathrm{s}^{-1}$ 表示。\n\n测试套件。为以下五个测试用例实现计算，每个用例指定为温度 $T$（单位 K）、$A^\\ast$ 的覆盖度（记为 $\\theta_A$）、$B^\\ast$ 的覆盖度（记为 $\\theta_B$）、PBE 能垒 $E_{a,\\mathrm{PBE}}$（单位 eV）和 HSE06 能垒 $E_{a,\\mathrm{HSE06}}$（单位 eV）的元组：\n- 用例 1：$T = 500$，$\\theta_A = 0.5$，$\\theta_B = 0.5$， $E_{a,\\mathrm{PBE}} = 0.60$， $E_{a,\\mathrm{HSE06}} = 0.85$。\n- 用例 2：$T = 500$，$\\theta_A = 0.9$，$\\theta_B = 0.1$， $E_{a,\\mathrm{PBE}} = 0.40$， $E_{a,\\mathrm{HSE06}} = 0.55$。\n- 用例 3：$T = 300$，$\\theta_A = 0.5$，$\\theta_B = 0.0$， $E_{a,\\mathrm{PBE}} = 0.50$， $E_{a,\\mathrm{HSE06}} = 0.70$。\n- 用例 4：$T = 800$，$\\theta_A = 0.2$，$\\theta_B = 0.8$， $E_{a,\\mathrm{PBE}} = 1.00$， $E_{a,\\mathrm{HSE06}} = 1.20$。\n- 用例 5：$T = 600$，$\\theta_A = 0.3$，$\\theta_B = 0.3$， $E_{a,\\mathrm{PBE}} = 0.05$， $E_{a,\\mathrm{HSE06}} = 0.10$。\n\n您的程序必须生成一行输出，其中包含所有测试用例的汇总结果。对于每个测试用例，输出列表 `[k_PBE,k_HSE06,TOF_PBE,TOF_HSE06,R]`，其中前四个条目的单位为 $\\mathrm{s}^{-1}$，比率 $R$ 是无量纲的。将这些每个测试用例的列表聚合成一个单一的、以逗号分隔的、用方括号括起来的顶级列表，不含额外文本。例如，所需的输出格式类似于 `[[k_1,k_1',TOF_1,TOF_1',R_1],[k_2,k_2',TOF_2,TOF_2',R_2],...]`。",
            "solution": "该问题已经过评估并被认为是有效的。它在科学上基于化学动力学和计算化学的原理，问题提出得很好，有足够的信息来获得唯一解，并且表述客观。\n\n此问题的核心是应用过渡态理论（TST）来计算双分子表面反应的反应速率常数和转换频率，并比较两种不同理论水平（Perdew–Burke–Ernzerhof (PBE) 广义梯度近似和 Heyd–Scuseria–Ernzerhof (HSE06) 混合密度泛函）计算的活化能。\n\n在温度 T 下，来自 TST 的速率常数 $k(T)$ 的基本方程是 Eyring 方程：\n$$ k(T) = \\frac{k_{\\mathrm{B}} T}{h} e^{-\\Delta G^\\ddagger / (k_{\\mathrm{B}} T)} $$\n这里，$k_{\\mathrm{B}}$ 是玻尔兹曼常数（$1.380649\\times 10^{-23}\\ \\mathrm{J}\\ \\mathrm{K}^{-1}$），$h$ 是普朗克常数（$6.62607015\\times 10^{-34}\\ \\mathrm{J}\\ \\mathrm{s}$），而 $\\Delta G^\\ddagger$ 是吉布斯活化自由能。\n\n问题指定了一个关键简化：从电子结构理论（PBE 或 HSE06）计算出的活化能垒 $E_a$ 被认为等同于活化自由能 $\\Delta G^\\ddagger$。这种常见的近似忽略了零点振动能、热振动和熵对活化能垒的贡献。在此假设下，速率常数的方程变为：\n$$ k(T) = \\frac{k_{\\mathrm{B}} T}{h} \\exp\\left(-\\frac{E_a}{k_{\\mathrm{B}} T}\\right) $$\n指前因子 $\\frac{k_{\\mathrm{B}} T}{h}$ 的单位是 $(\\mathrm{J}\\ \\mathrm{K}^{-1})(\\mathrm{K})/(\\mathrm{J}\\ \\mathrm{s}) = \\mathrm{s}^{-1}$，这在此上下文中是用作一级或伪一级速率常数的正确单位。活化能 $E_a$ 以电子伏特（$\\mathrm{eV}$）给出，因此必须使用提供的转换因子 $c_{\\mathrm{eV}\\rightarrow \\mathrm{J}} = 1.602176634\\times 10^{-19}\\ \\mathrm{J}\\ \\mathrm{eV}^{-1}$ 将其转换为焦耳（$\\mathrm{J}$），以与 $k_{\\mathrm{B}}$ 保持一致。\n\n因此，PBE 和 HSE06 泛函的具体速率常数为：\n$$ k_{\\mathrm{PBE}}(T) = \\frac{k_{\\mathrm{B}} T}{h} \\exp\\left(-\\frac{E_{a,\\mathrm{PBE}} \\cdot c_{\\mathrm{eV}\\rightarrow \\mathrm{J}}}{k_{\\mathrm{B}} T}\\right) $$\n$$ k_{\\mathrm{HSE06}}(T) = \\frac{k_{\\mathrm{B}} T}{h} \\exp\\left(-\\frac{E_{a,\\mathrm{HSE06}} \\cdot c_{\\mathrm{eV}\\rightarrow \\mathrm{J}}}{k_{\\mathrm{B}} T}\\right) $$\n\n接下来，我们定义转换频率（$\\mathrm{TOF}$）。对于基元双分子表面反应 $A^\\ast + B^\\ast \\rightarrow AB^\\ast$，每个活性位点的反应速率 $r$ 由应用于表面物种的质量作用定律给出：\n$$ r = k(T) \\theta_A \\theta_B $$\n其中 $\\theta_A$ 和 $\\theta_B$ 是反应物的分数表面覆盖度。$\\mathrm{TOF}$ 定义为每个位点的此速率，因此 $\\mathrm{TOF} = r$。单位是 $\\mathrm{s}^{-1}$，因为速率常数 $k(T)$ 的单位是 $\\mathrm{s}^{-1}$ 且覆盖度是无量纲的。\n\n因此，两种泛函的转换频率为：\n$$ \\mathrm{TOF}_{\\mathrm{PBE}}(T) = k_{\\mathrm{PBE}}(T) \\cdot \\theta_A \\cdot \\theta_B $$\n$$ \\mathrm{TOF}_{\\mathrm{HSE06}}(T) = k_{\\mathrm{HSE06}}(T) \\cdot \\theta_A \\cdot \\theta_B $$\n\n最后，问题要求计算无量纲比率 $R$ 以量化泛函选择对 TOF 的影响：\n$$ R = \\frac{\\mathrm{TOF}_{\\mathrm{HSE06}}(T)}{\\mathrm{TOF}_{\\mathrm{PBE}}(T)} $$\n当 $\\theta_A > 0$ 和 $\\theta_B > 0$ 时，两个 $\\mathrm{TOF}$ 值都非零。该比率简化为速率常数的比率，因为覆盖度项相互抵消：\n$$ R = \\frac{k_{\\mathrm{HSE06}}(T)}{k_{\\mathrm{PBE}}(T)} = \\frac{ \\exp\\left(-\\frac{E_{a,\\mathrm{HSE06}} \\cdot c_{\\mathrm{eV}\\rightarrow \\mathrm{J}}}{k_{\\mathrm{B}} T}\\right) }{ \\exp\\left(-\\frac{E_{a,\\mathrm{PBE}} \\cdot c_{\\mathrm{eV}\\rightarrow \\mathrm{J}}}{k_{\\mathrm{B}} T}\\right) } = \\exp\\left(-\\frac{(E_{a,\\mathrm{HSE06}} - E_{a,\\mathrm{PBE}}) \\cdot c_{\\mathrm{eV}\\rightarrow \\mathrm{J}}}{k_{\\mathrm{B}} T}\\right) $$\n问题为 $\\mathrm{TOF}$ 可能为零的情况指定了规则。如果 $\\theta_A=0$ 或 $\\theta_B=0$，则 $\\mathrm{TOF}$ 值将为零。在这种情况下，$\\mathrm{TOF}_{\\mathrm{PBE}}$ 和 $\\mathrm{TOF}_{\\mathrm{HSE06}}$ 都将为零。给定的规则是：“如果两者均为零，则设 $R = 0$。” 这适用于 $\\theta_B = 0$ 的测试用例 3。另一条规则，“如果 $\\mathrm{TOF}_{\\mathrm{PBE}}(T) = 0$ 且 $\\mathrm{TOF}_{\\mathrm{HSE06}}(T) > 0$，则设 $R = +\\infty$”，在所提供的模型中逻辑上是不可达的。对于任何有限的温度和活化能，$k(T)$ 都是严格为正的。因此，$\\mathrm{TOF}_{\\mathrm{PBE}}=0$ 当且仅当 $\\theta_A \\theta_B=0$，这意味着 $\\mathrm{TOF}_{\\mathrm{HSE06}}$ 也必须为零。尽管如此，实现将严格遵守所提供的规则。\n\n每个测试用例的计算过程如下：\n1.  定义物理常数 $k_{\\mathrm{B}}$、$h$ 和 $c_{\\mathrm{eV}\\rightarrow \\mathrm{J}}$。\n2.  对于给定的测试用例 $(T, \\theta_A, \\theta_B, E_{a,\\mathrm{PBE}}, E_{a,\\mathrm{HSE06}})$：\n3.  计算热能项 $k_{\\mathrm{B}} T$（单位为焦耳）。\n4.  计算指前因子 $\\frac{k_{\\mathrm{B}} T}{h}$。\n5.  将活化能 $E_{a,\\mathrm{PBE}}$ 和 $E_{a,\\mathrm{HSE06}}$ 从 $\\mathrm{eV}$ 转换为 $\\mathrm{J}$。\n6.  使用 TST 方程计算 $k_{\\mathrm{PBE}}$ 和 $k_{\\mathrm{HSE06}}$。\n7.  通过将各自的速率常数乘以 $\\theta_A \\theta_B$ 来计算 $\\mathrm{TOF}_{\\mathrm{PBE}}$ 和 $\\mathrm{TOF}_{\\mathrm{HSE06}}$。\n8.  根据指定的条件逻辑计算比率 $R$。\n9.  为该测试用例整理五个结果 $[k_{\\mathrm{PBE}}, k_{\\mathrm{HSE06}}, \\mathrm{TOF}_{\\mathrm{PBE}}, \\mathrm{TOF}_{\\mathrm{HSE06}}, R]$。\n10. 将所有测试用例的结果聚合成最终指定的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes temperature-dependent reaction rate constants and turnover frequencies\n    for a surface reaction using PBE and HSE06 activation barriers.\n    \"\"\"\n    \n    # Define physical constants as specified in the problem statement.\n    K_B = 1.380649e-23  # Boltzmann constant in J/K\n    H = 6.62607015e-34    # Planck constant in J*s\n    EV_TO_J = 1.602176634e-19 # Electronvolt to Joule conversion\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (T in K, theta_A, theta_B, Ea_PBE in eV, Ea_HSE06 in eV)\n    test_cases = [\n        (500, 0.5, 0.5, 0.60, 0.85),\n        (500, 0.9, 0.1, 0.40, 0.55),\n        (300, 0.5, 0.0, 0.50, 0.70),\n        (800, 0.2, 0.8, 1.00, 1.20),\n        (600, 0.3, 0.3, 0.05, 0.10),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        T, theta_A, theta_B, Ea_pbe_ev, Ea_hse06_ev = case\n\n        # Calculate thermal energy in Joules\n        kbt_joules = K_B * T\n\n        # Calculate pre-exponential factor from TST\n        pre_exp_factor = kbt_joules / H\n\n        # Convert activation energies from eV to Joules\n        Ea_pbe_j = Ea_pbe_ev * EV_TO_J\n        Ea_hse06_j = Ea_hse06_ev * EV_TO_J\n\n        # Calculate rate constants (k_PBE and k_HSE06) in s^-1\n        k_pbe = pre_exp_factor * np.exp(-Ea_pbe_j / kbt_joules)\n        k_hse06 = pre_exp_factor * np.exp(-Ea_hse06_j / kbt_joules)\n\n        # Calculate Turnover Frequencies (TOF) in s^-1\n        tof_pbe = k_pbe * theta_A * theta_B\n        tof_hse06 = k_hse06 * theta_A * theta_B\n        \n        # Calculate the ratio R based on the specified rules\n        if tof_pbe > 0:\n            R = tof_hse06 / tof_pbe\n        elif tof_pbe == 0 and tof_hse06 > 0:\n            # This case is logically unreachable under the problem's model,\n            # but implemented for strict compliance with the prompt.\n            R = np.inf\n        else:  # This covers the case where both TOFs are zero.\n            R = 0.0\n            \n        case_results = [k_pbe, k_hse06, tof_pbe, tof_hse06, R]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists of numbers.\n    # `str()` on a list will produce the desired '[item1, item2, ...]' format.\n    result_strings = [str(res) for res in all_results]\n    # np.set_printoptions can alter the string representation, so we reformat each number\n    final_output_parts = []\n    for result_list in all_results:\n        # Manually format each list to ensure standard float representation\n        list_as_string = f\"[{','.join(f'{v:.8e}' if isinstance(v, float) and abs(v) > 0 and (abs(v)<1e-4 or abs(v)>1e4) else str(v) for v in result_list)}]\"\n        # A simpler approach that is usually sufficient:\n        list_as_string = f\"[{','.join(map(str, result_list))}]\"\n        final_output_parts.append(list_as_string)\n        \n    final_string = f\"[{','.join(final_output_parts)}]\"\n    print(final_string.replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}