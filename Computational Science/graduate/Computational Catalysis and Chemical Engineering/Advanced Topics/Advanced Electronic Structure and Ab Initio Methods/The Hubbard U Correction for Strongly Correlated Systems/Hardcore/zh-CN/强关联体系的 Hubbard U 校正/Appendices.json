{
    "hands_on_practices": [
        {
            "introduction": "任何严谨的计算研究都始于确保其数值的可靠性。在从 DFT+$U$ 计算中得出任何物理结论之前，我们必须验证结果不受计算参数（如平面波截断能和 $k$ 点网格）的影响。本练习 () 提供了一种基于物理原则的系统性方法，通过对收敛序列进行建模和分析，来评估并确认计算的收敛性，这是获得可信赖结果的基础。",
            "id": "3901882",
            "problem": "考虑一项关于过渡金属氧化物催化剂的计算研究，其中局域化的 $d$-电子需要 Hubbard $U$ 校正来正确捕捉强关联效应。电子结构采用平面波和布里渊区（BZ）的离散采样进行计算。目标是仅使用所提供的数值序列和有原则的收敛性评估，来确定计算出的 Hubbard $U$ 参数和探针物种的吸附能，是否在平面波动能截止和 $k$ 点网格密度方面都达到了数值收敛。\n\n基础和背景：\n- 在增加了 Hubbard $U$ 的 Kohn–Sham 密度泛函理论（DFT）中，总能量是相对于电子密度最小化的，并且基态能量相对于基组是变分的。增加平面波截止能量 $E_{\\mathrm{cut}}$ 会扩展基组，并减少波函数和电荷密度表示中的离散化误差。\n- BZ 积分通过有限的 $k$ 点网格进行近似。增加 $k$ 点数量可以提高周期性系统的求积精度，并减少依赖于电子结构的观测量在采样上的误差。\n- 对于足够平滑的赝势和被积函数，由基组截断和 BZ 采样引起的数值误差会随着分辨率的增加而系统地减小。一个通用且广泛使用的模型描述了性质 $P$ 作为平面波截止能量 $E_{\\mathrm{cut}}$ 和均匀网格中 $k$ 点总数 $N_{k}$ 的函数的收敛行为，该模型表现为向渐近极限的加性幂律衰减：\n$$\nP\\left(E_{\\mathrm{cut}}, N_{k}\\right) \\approx P_{\\infty} + a\\,E_{\\mathrm{cut}}^{-\\alpha} + b\\,N_{k}^{-\\beta},\n$$\n其中 $P_{\\infty}$ 是收敛（无限分辨率）值，而 $a$、$b$、$\\alpha$、$\\beta$ 是凭经验确定的正常数模型参数。这种形式体现了增加 $E_{\\mathrm{cut}}$ 和 $N_{k}$ 会以平滑、衰减的方式减少误差的原理。\n\n设计一个程序，为每个测试用例执行以下操作，同时针对 Hubbard $U$ 参数和吸附能 $E_{\\mathrm{ads}}$：\n1. 接受两个一维收敛序列：在足够密集的 $k$-mesh 保持固定的情况下，随 $E_{\\mathrm{cut}}$ 增加的 $P(E_{\\mathrm{cut}})$ 序列；以及在足够高的 $E_{\\mathrm{cut}}$ 保持固定的情况下，随 $N_{k}$ 增加的 $P(N_{k})$ 序列。能量必须以电子伏特（eV）为单位处理，$E_{\\mathrm{cut}}$ 也必须以电子伏特（eV）为单位处理。$k$ 点总数 $N_{k}$ 是无量纲的。\n2. 将每个一维序列拟合到幂律模型 $P(x) = P_{\\infty} + c\\,x^{-\\gamma}$，其中 $x \\in \\{E_{\\mathrm{cut}}, N_{k}\\}$，参数为 $\\{P_{\\infty}, c, \\gamma\\}$，并强制要求 $\\gamma > 0$。\n3. 基于变分原理和平滑求积收敛这两个原则性检查，为每个序列定义一个收敛判定：\n   - 局部解析度增量检查：最后两个计算值之间的绝对变化必须低于为该性质指定的容差 $\\tau$，即 $|P_{n} - P_{n-1}| \\le \\tau$。\n   - 渐近一致性检查：最后一个计算值与拟合出的渐近极限之间的绝对偏差必须低于相同的容差 $\\tau$，即 $|P_{n} - P_{\\infty}| \\le \\tau$。\n4. 当且仅当 $E_{\\mathrm{cut}}$ 序列和 $N_{k}$ 序列都通过上述两项检查时，才宣布该性质收敛。\n5. 为每个测试用例报告一个布尔结果，指明在给定容差下，两种性质（Hubbard $U$ 和吸附能 $E_{\\mathrm{ads}}$）是否都已收敛。\n\n使用以下测试套件，它为 $E_{\\mathrm{cut}}$（单位 eV）、$N_{k}$（无量纲总 $k$ 点数）和测量的性质值（单位 eV）提供了序列。Hubbard $U$ 的容差为 $\\tau_{U} = 0.05\\,\\text{eV}$，吸附能的容差为 $\\tau_{\\mathrm{ads}} = 0.02\\,\\text{eV}$。\n\n测试用例 A（理想情况，平滑收敛）：\n- Hubbard $U$ vs $E_{\\mathrm{cut}}$: $E_{\\mathrm{cut}} = [\\,300,\\,400,\\,500,\\,600\\,]$ eV, $U(E_{\\mathrm{cut}}) = [\\,4.35,\\,4.27,\\,4.22,\\,4.21\\,]$ eV.\n- Hubbard $U$ vs $N_{k}$: $N_{k} = [\\,27,\\,64,\\,125,\\,216\\,]$, $U(N_{k}) = [\\,4.25,\\,4.22,\\,4.21,\\,4.20\\,]$ eV.\n- 吸附能 vs $E_{\\mathrm{cut}}$: $E_{\\mathrm{cut}} = [\\,300,\\,400,\\,500,\\,600\\,]$ eV, $E_{\\mathrm{ads}}(E_{\\mathrm{cut}}) = [\\,-1.36,\\,-1.32,\\,-1.31,\\,-1.30\\,]$ eV.\n- 吸附能 vs $N_{k}$: $N_{k} = [\\,27,\\,64,\\,125,\\,216\\,]$, $E_{\\mathrm{ads}}(N_{k}) = [\\,-1.33,\\,-1.31,\\,-1.30,\\,-1.30\\,]$ eV.\n\n测试用例 B（临界收敛，伴有轻微振荡）：\n- Hubbard $U$ vs $E_{\\mathrm{cut}}$: $E_{\\mathrm{cut}} = [\\,300,\\,350,\\,400,\\,500,\\,650\\,]$ eV, $U(E_{\\mathrm{cut}}) = [\\,4.50,\\,4.45,\\,4.47,\\,4.46,\\,4.45\\,]$ eV.\n- Hubbard $U$ vs $N_{k}$: $N_{k} = [\\,27,\\,64,\\,125,\\,216,\\,343\\,]$, $U(N_{k}) = [\\,4.50,\\,4.47,\\,4.46,\\,4.45,\\,4.45\\,]$ eV.\n- 吸附能 vs $E_{\\mathrm{cut}}$: $E_{\\mathrm{cut}} = [\\,300,\\,350,\\,400,\\,500,\\,650\\,]$ eV, $E_{\\mathrm{ads}}(E_{\\mathrm{cut}}) = [\\,-0.95,\\,-0.93,\\,-0.94,\\,-0.94,\\,-0.94\\,]$ eV.\n- 吸附能 vs $N_{k}$: $N_{k} = [\\,27,\\,64,\\,125,\\,216,\\,343\\,]$, $E_{\\mathrm{ads}}(N_{k}) = [\\,-0.94,\\,-0.93,\\,-0.94,\\,-0.94,\\,-0.94\\,]$ eV.\n\n测试用例 C（在给定范围内未收敛）：\n- Hubbard $U$ vs $E_{\\mathrm{cut}}$: $E_{\\mathrm{cut}} = [\\,250,\\,300,\\,400,\\,500\\,]$ eV, $U(E_{\\mathrm{cut}}) = [\\,3.80,\\,3.60,\\,3.50,\\,3.45\\,]$ eV.\n- Hubbard $U$ vs $N_{k}$: $N_{k} = [\\,8,\\,27,\\,64,\\,125\\,]$, $U(N_{k}) = [\\,3.90,\\,3.70,\\,3.55,\\,3.50\\,]$ eV.\n- 吸附能 vs $E_{\\mathrm{cut}}$: $E_{\\mathrm{cut}} = [\\,250,\\,300,\\,400,\\,500\\,]$ eV, $E_{\\mathrm{ads}}(E_{\\mathrm{cut}}) = [\\,-1.10,\\,-1.00,\\,-0.90,\\,-0.85\\,]$ eV.\n- 吸附能 vs $N_{k}$: $N_{k} = [\\,8,\\,27,\\,64,\\,125\\,]$, $E_{\\mathrm{ads}}(N_{k}) = [\\,-1.00,\\,-0.95,\\,-0.90,\\,-0.88\\,]$ eV.\n\n最终输出规范：\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个布尔值，表示两种性质（Hubbard $U$ 和吸附能 $E_{\\mathrm{ads}}$）是否在各自的容差下都已收敛。例如，输出的形式应为 $[\\,\\mathrm{True},\\mathrm{False},\\mathrm{True}\\,]$，大小写须与示例完全一致。",
            "solution": "目标是针对 Hubbard $U$ 参数和吸附能 $E_{\\mathrm{ads}}$，设计一个关于平面波动能截止 $E_{\\mathrm{cut}}$ 和布里渊区（BZ）$k$ 点网格密度 $N_{k}$ 的有原则的收敛性评估方法。该方法必须与基本原理相联系，并提供一个明确的决策规则。\n\n原则性基础：\n1. 增加了 Hubbard $U$ 校正的 Kohn–Sham 密度泛函理论（DFT）能量是关于电子密度最小化的。Hubbard 项可以写成旋转不变的形式\n$$\nE_{U} = \\frac{U}{2}\\sum_{I,m,\\sigma}\\left(n_{Im\\sigma} - n_{Im\\sigma}^{2}\\right),\n$$\n其中 $I$ 标记原子，$m$ 标记局域轨道，$\\sigma$ 标记自旋。该项惩罚局域态的非整数占据，并校正自相互作用误差。总能量仍然是一个相对于密度和占据数进行变分最小化的泛函。因此，根据变分原理，通过提高 $E_{\\mathrm{cut}}$ 来增加基组完备性，能量必定不会增加，并且这会系统地减少基态密度和派生可观测量（包括线性响应计算的 $U$ 和 $E_{\\mathrm{ads}}$）中的离散化误差。\n2. 周期性系统的 BZ 积分通过使用 $N_{k}$ 个点的网格进行离散采样来近似。对于足够平滑的被积函数和均匀网格，由于电子态采样的改善，求积误差会随着 $N_{k}$ 的增加而减小，从而减少从电子结构计算出的可观测量中的数值积分误差。\n\n误差建模：\n为了捕捉性质 $P$（Hubbard $U$ 或 $E_{\\mathrm{ads}}$）向收敛极限的渐近趋近过程，我们采用一个通用的加性衰减模型，\n$$\nP\\left(E_{\\mathrm{cut}}, N_{k}\\right) \\approx P_{\\infty} + a\\,E_{\\mathrm{cut}}^{-\\alpha} + b\\,N_{k}^{-\\beta},\n$$\n其中 $P_{\\infty}$ 是无限分辨率极限，而正常数参数 $a$、$b$、$\\alpha$、$\\beta$ 用于拟合收敛行为。此模型与以下情况一致：\n- 基组截断误差：对于动能截止为 $E_{\\mathrm{cut}} = \\hbar^{2} k_{c}^{2}/(2m_{e})$ 的平面波，忽略 $k > k_{c}$ 的傅里叶分量所产生的误差会随着 $k_{c}$ 的增加而平滑减小，这通常可以用关于 $E_{\\mathrm{cut}}$ 的幂律衰减来捕捉。\n- BZ 采样误差：对平滑被积函数在 BZ 上进行均匀求积，其误差会随着点数 $N_{k}$ 的增加而减小，这同样通常可以用幂律凭经验地捕捉。\n\n算法设计：\n我们为每个序列构建一维拟合：\n- 对于固定的密集 $k$-mesh，将 $P(E_{\\mathrm{cut}})$ 拟合到 $P(E) = P_{\\infty}^{(E)} + c_{E}\\,E^{-\\gamma_{E}}$，其中 $\\gamma_{E} > 0$。\n- 对于固定的高 $E_{\\mathrm{cut}}$，将 $P(N_{k})$ 拟合到 $P(N) = P_{\\infty}^{(N)} + c_{N}\\,N^{-\\gamma_{N}}$，其中 $\\gamma_{N} > 0$。\n\n我们通过非线性最小二乘法估计参数 $\\{P_{\\infty}, c, \\gamma\\}$，并约束 $\\gamma > 0$。拟合得到的 $P_{\\infty}$ 提供了一个与观测到的衰减趋势一致的渐近极限，而无需假设特定的指数。\n\n收敛判定：\n对于每个序列，我们定义两项检查：\n1. 局部增量检查：\n$$\n\\Delta_{\\mathrm{last}} \\equiv \\left|P_{n} - P_{n-1}\\right| \\le \\tau,\n$$\n确保在最后一次提高分辨率时，引起的变化小于容差 $\\tau$。\n2. 渐近一致性检查：\n$$\n\\delta_{\\infty} \\equiv \\left|P_{n} - P_{\\infty}\\right| \\le \\tau,\n$$\n确保最后一个计算值与拟合的收敛极限之差在容差 $\\tau$ 之内。\n\n如果一个性质 $P$ 的 $E_{\\mathrm{cut}}$ 序列和其 $N_{k}$ 序列都通过了这两项检查，则宣布其收敛。对于 Hubbard $U$，容差为 $\\tau_{U} = 0.05\\,\\text{eV}$；对于吸附能，容差为 $\\tau_{\\mathrm{ads}} = 0.02\\,\\text{eV}$。\n\n实现细节：\n- 使用非线性最小二乘法来拟合 $P(x) = P_{\\infty} + c\\,x^{-\\gamma}$，其中 $x \\in \\{E_{\\mathrm{cut}}, N_{k}\\}$，边界为 $\\gamma \\in (0, \\Gamma_{\\max}]$（对于某个合理的 $\\Gamma_{\\max}$，例如 $\\Gamma_{\\max} = 5$），且 $P_{\\infty}$、$c$ 无约束。\n- 为了辅助数值稳定性，将 $P_{\\infty}$ 初始化为最后一个观测值，将 $c$ 初始化为第一个和最后一个值的差，将 $\\gamma$ 初始化为 $1$。\n- 为两个序列计算 $\\Delta_{\\mathrm{last}}$ 和 $\\delta_{\\infty}$，并与相应的 $\\tau$ 进行比较。\n- 如果两个性质都在各自的容差下收敛，则每个测试用例的总布尔值为真。\n\n测试套件解读：\n- 测试用例 A 显示，对于 $E_{\\mathrm{cut}}$ 和 $N_{k}$， $U$ 和 $E_{\\mathrm{ads}}$ 都呈现出平滑单调收敛。最后的增量很小（例如，对于 $U$ 随 $E_{\\mathrm{cut}}$ 的变化，$|4.21 - 4.22| = 0.01\\,\\text{eV} \\le 0.05\\,\\text{eV}$），并且拟合的渐近极限应该接近最后的值，因此预期会收敛。\n- 测试用例 B 包含轻微振荡，这通常是数值噪声或与 Pulay 相关的微小假象；然而，这些振荡在最后增量和拟合极限上都在容差范围内，因此仍应判定为收敛。\n- 测试用例 C 显示，对于 $U$ 和 $E_{\\mathrm{ads}}$，在最后几次精化中都表现出显著变化，并且拟合的渐近值相对于最后一个值的偏差仍在容差之外，因此应判定为未收敛。\n\n程序将三个测试用例的结果汇总到一行布尔值输出中，并遵循指定格式。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef power_decay_model(x, pinf, c, gamma):\n    # Model: P(x) = P_inf + c * x^{-gamma}, with gamma > 0\n    return pinf + c * np.power(x, -gamma)\n\ndef fit_power_decay(x, y):\n    # Ensure inputs are numpy arrays of float\n    x = np.asarray(x, dtype=float)\n    y = np.asarray(y, dtype=float)\n    # Initial guesses: P_inf ~ last value, c ~ (first - last), gamma ~ 1.0\n    p0 = [y[-1], (y[0] - y[-1]), 1.0]\n    # Bounds: pinf free, c free, gamma in (0, 5]\n    bounds = ([-np.inf, -np.inf, 1e-8], [np.inf, np.inf, 5.0])\n    try:\n        popt, _ = curve_fit(power_decay_model, x, y, p0=p0, bounds=bounds, maxfev=10000)\n    except RuntimeError:\n        # In case fitting fails, fall back to a simple estimate: pinf ~ last, c ~ 0, gamma ~ 1\n        popt = np.array([y[-1], 0.0, 1.0])\n    pinf, c, gamma = popt\n    return pinf, c, gamma\n\ndef sequence_converged(x, y, tol):\n    # Check last increment\n    if len(y)  2:\n        return False\n    last_inc = abs(y[-1] - y[-2])\n    # Fit asymptotic limit\n    pinf, _, _ = fit_power_decay(x, y)\n    last_to_inf = abs(y[-1] - pinf)\n    return (last_inc = tol) and (last_to_inf = tol)\n\ndef property_converged(ecuts, p_vs_ecuts, nks, p_vs_nks, tol):\n    # Convergence must hold for both sequences\n    conv_ecuts = sequence_converged(ecuts, p_vs_ecuts, tol)\n    conv_nks = sequence_converged(nks, p_vs_nks, tol)\n    return conv_ecuts and conv_nks\n\ndef solve():\n    # Tolerances\n    tau_U = 0.05   # eV\n    tau_ads = 0.02 # eV\n\n    # Test case A\n    ecuts_A = [300, 400, 500, 600]\n    nk_A = [27, 64, 125, 216]\n    U_vs_ecuts_A = [4.35, 4.27, 4.22, 4.21]\n    U_vs_nk_A = [4.25, 4.22, 4.21, 4.20]\n    Eads_vs_ecuts_A = [-1.36, -1.32, -1.31, -1.30]\n    Eads_vs_nk_A = [-1.33, -1.31, -1.30, -1.30]\n\n    # Test case B (borderline oscillations)\n    ecuts_B = [300, 350, 400, 500, 650]\n    nk_B = [27, 64, 125, 216, 343]\n    U_vs_ecuts_B = [4.50, 4.45, 4.47, 4.46, 4.45]\n    U_vs_nk_B = [4.50, 4.47, 4.46, 4.45, 4.45]\n    Eads_vs_ecuts_B = [-0.95, -0.93, -0.94, -0.94, -0.94]\n    Eads_vs_nk_B = [-0.94, -0.93, -0.94, -0.94, -0.94]\n\n    # Test case C (non-converged)\n    ecuts_C = [250, 300, 400, 500]\n    nk_C = [8, 27, 64, 125]\n    U_vs_ecuts_C = [3.80, 3.60, 3.50, 3.45]\n    U_vs_nk_C = [3.90, 3.70, 3.55, 3.50]\n    Eads_vs_ecuts_C = [-1.10, -1.00, -0.90, -0.85]\n    Eads_vs_nk_C = [-1.00, -0.95, -0.90, -0.88]\n\n    test_cases = [\n        (ecuts_A, U_vs_ecuts_A, nk_A, U_vs_nk_A, Eads_vs_ecuts_A, Eads_vs_nk_A),\n        (ecuts_B, U_vs_ecuts_B, nk_B, U_vs_nk_B, Eads_vs_ecuts_B, Eads_vs_nk_B),\n        (ecuts_C, U_vs_ecuts_C, nk_C, U_vs_nk_C, Eads_vs_ecuts_C, Eads_vs_nk_C),\n    ]\n\n    results = []\n    for (ecuts, U_e, nks, U_k, Eads_e, Eads_k) in test_cases:\n        conv_U = property_converged(ecuts, U_e, nks, U_k, tau_U)\n        conv_Eads = property_converged(ecuts, Eads_e, nks, Eads_k, tau_ads)\n        results.append(conv_U and conv_Eads)\n    \n    # Format boolean as 'True' or 'False' to match the problem description's example format\n    formatted_results = [str(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "DFT+$U$ 方法的一个核心挑战是选择一个合适的 Hubbard $U$ 参数值。一种可靠的策略是通过将一个对 $U$ 高度敏感的计算属性与可靠的实验值进行匹配来校准 $U$。本练习 () 模拟了这一关键的校准过程，以二氧化铈 ($\\text{CeO}_2$) 中氧空位的形成能为例，这是理解其催化活性的基石。",
            "id": "3901897",
            "problem": "考虑二氧化铈（$\\text{CeO}_2$），其在富氧条件下的氧空位形成能从第一性原理出发，定义为一个含单个中性氧空位的缺陷超胞的总电子能量，加上半个氧分子的参考能量，再减去完整化学计量超胞的总电子能量。在电子结构理论中，使用标准的总能量计算方法，氧空位形成能 $E_{\\mathrm{v}}(U)$ 由以下核心热力学恒等式定义\n$$\nE_{\\mathrm{v}}(U) \\equiv E_{\\mathrm{tot}}^{\\mathrm{defect}}(U) + \\tfrac{1}{2} E_{\\mathrm{tot}}^{\\mathrm{O_2}} - E_{\\mathrm{tot}}^{\\mathrm{pristine}}(U),\n$$\n其中 $E_{\\mathrm{tot}}^{\\mathrm{defect}}(U)$ 和 $E_{\\mathrm{tot}}^{\\mathrm{pristine}}(U)$ 分别是还原（含缺陷）和化学计量的 $\\text{CeO}_2$ 超胞的总电子能量，$E_{\\mathrm{tot}}^{\\mathrm{O_2}}$ 是气相氧分子的总电子能量。一种被称为带有 Hubbard $U$ 校正的密度泛函理论（DFT+$U$）的方法引入了一种修正性的在位相互作用，以处理局域化的铈 $4f$ 电子。为了进行此项计算催化和化学工程校准的练习，请将每个超胞的总能量对 Hubbard 参数 $U$ 的依赖关系近似为一阶线性模型：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{pristine}}(U) = A_{\\mathrm{p}} + B_{\\mathrm{p}}\\,U,\\quad\nE_{\\mathrm{tot}}^{\\mathrm{defect}}(U) = A_{\\mathrm{d}} + B_{\\mathrm{d}}\\,U,\\quad\nE_{\\mathrm{tot}}^{\\mathrm{O_2}} = A_{\\mathrm{O_2}},\n$$\n其物理上合理的常数（单位为电子伏特）如下：$A_{\\mathrm{p}} = -1760.0$，$B_{\\mathrm{p}} = -0.05$，$A_{\\mathrm{d}} = -1751.27$，$B_{\\mathrm{d}} = -0.20$ 以及 $A_{\\mathrm{O_2}} = -9.86$。在富氧条件下，氧的参考化学势为 $\\tfrac{1}{2} E_{\\mathrm{tot}}^{\\mathrm{O_2}}$。假设中性缺陷超胞中的有限尺寸和电荷修正是可以忽略的（即，将任何额外的修正项设置为零）。\n\n您需要编写一个完整、可运行的程序来完成以下任务：\n- 根据以上定义且仅使用这些常数，为指定集合中的每个 $U$ 计算 $E_{\\mathrm{v}}(U)$。\n- 将 $E_{\\mathrm{v}}(U)$ 与参考 $\\tfrac{1}{2}\\text{O}_2$、在近零温度下测得的 $\\text{CeO}_2$ 氧空位形成焓的实验热化学包络进行比较，此处该包络被建模为可接受区间 $[E_{\\min},E_{\\max}] = [3.0, 3.3]$ 电子伏特。使用此区间作为判断 $U$ 值是否物理合理的标准。\n- 根据以下确定性规则，选择一个“物理上合理”的 $U$ 值：\n  1. 如果一个或多个 $U$ 值产生的 $E_{\\mathrm{v}}(U)$ 位于 $[E_{\\min},E_{\\max}]$ 区间内，则选择其中最小的那个 $U$。\n  2. 如果没有 $U$ 值产生的 $E_{\\mathrm{v}}(U)$ 位于 $[E_{\\min},E_{\\max}]$ 区间内，则选择使 $E_{\\mathrm{v}}(U)$ 与区间中点 $\\tfrac{1}{2}(E_{\\min}+E_{\\max})$ 的绝对偏差最小化的 $U$。若存在多个这样的 $U$ 值（即偏差相同），则选择其中较小的那个。\n\n您的程序必须使用以下 Hubbard $U$ 值（单位为电子伏特）的测试集：$[0.0, 2.0, 3.5, 4.0, 6.0, 8.0]$。\n\n输出和单位要求：\n- 计算每个氧空位形成能（单位为电子伏特），并将每个值以电子伏特表示，四舍五入到三位小数。\n- 最终输出必须是单行文本，包含一个 Python 风格的列表。列表中应包含按测试集顺序排列的氧空位形成能，最后是所选的 $U$ 值。所有数值都需四舍五入到三位小数。例如 $[x_1,x_2,\\dots,x_n,u_{\\star}]$，其中每个 $x_i$ 是 $E_{\\mathrm{v}}(U_i)$（单位为电子伏特），$u_{\\star}$ 是所选的 $U$ 值（单位为电子伏特）。\n\n测试集和覆盖范围：\n- 包含标准情况 $U = 4.0$，以测试结果在实验区间上界附近的一致性。\n- 包含边界情况 $U = 0.0$，以测试无关联基线。\n- 包含较大的 $U$ 值 $U = 6.0$ 和 $U = 8.0$，以探究强在位相互作用并确保能处理单调趋势。\n- 包含一个小数 $U = 3.5$，以测试非整数值。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2,...,resultN]”）。所有结果都必须以电子伏特为单位，并按要求四舍五入到三位小数。",
            "solution": "该问题陈述已经过验证，被认为是科学上合理、定义明确且客观的。它为获得唯一解提供了完整且一致的定义、数据和确定性规则。其背景是计算材料科学中校准 DFT+$U$ 计算参数的一个标准流程，具体来说，是校准二氧化铈（$\\text{CeO}_2$）中铈 $4f$ 电子的在位 Hubbard 参数 $U$。所给出的物理常数和实验参考值是合理的。因此，我将继续提供完整解答。\n\n主要目标是计算作为 Hubbard 参数 $U$ 的函数的氧空位形成能 $E_{\\mathrm{v}}(U)$，然后通过与实验数据进行比较，选择一个物理上合理的 $U$ 值。\n\n氧空位形成能由以下热力学恒等式定义：\n$$\nE_{\\mathrm{v}}(U) = E_{\\mathrm{tot}}^{\\mathrm{defect}}(U) + \\tfrac{1}{2} E_{\\mathrm{tot}}^{\\mathrm{O_2}} - E_{\\mathrm{tot}}^{\\mathrm{pristine}}(U)\n$$\n该问题为完整超胞和缺陷超胞的总能量提供了线性近似模型，并为氧分子能量提供了一个常数值：\n$$\nE_{\\mathrm{tot}}^{\\mathrm{pristine}}(U) = A_{\\mathrm{p}} + B_{\\mathrm{p}}\\,U\n$$\n$$\nE_{\\mathrm{tot}}^{\\mathrm{defect}}(U) = A_{\\mathrm{d}} + B_{\\mathrm{d}}\\,U\n$$\n$$\nE_{\\mathrm{tot}}^{\\mathrm{O_2}} = A_{\\mathrm{O_2}}\n$$\n将这些模型代入 $E_{\\mathrm{v}}(U)$ 的定义中：\n$$\nE_{\\mathrm{v}}(U) = (A_{\\mathrm{d}} + B_{\\mathrm{d}}\\,U) + \\tfrac{1}{2} A_{\\mathrm{O_2}} - (A_{\\mathrm{p}} + B_{\\mathrm{p}}\\,U)\n$$\n通过对常数项和与 $U$ 相关的项进行分组，该表达式可以重排为关于 $U$ 的线性函数：\n$$\nE_{\\mathrm{v}}(U) = (A_{\\mathrm{d}} + \\tfrac{1}{2} A_{\\mathrm{O_2}} - A_{\\mathrm{p}}) + (B_{\\mathrm{d}} - B_{\\mathrm{p}})U\n$$\n我们定义两个常数，截距 $C$ 和斜率 $D$，使得 $E_{\\mathrm{v}}(U) = C + DU$。使用题目中提供的数值（单位为电子伏特）：$A_{\\mathrm{p}} = -1760.0$，$B_{\\mathrm{p}} = -0.05$，$A_{\\mathrm{d}} = -1751.27$，$B_{\\mathrm{d}} = -0.20$，$A_{\\mathrm{O_2}} = -9.86$。\n\n截距 $C$ 为：\n$$\nC = A_{\\mathrm{d}} + \\tfrac{1}{2} A_{\\mathrm{O_2}} - A_{\\mathrm{p}} = -1751.27 + \\tfrac{1}{2}(-9.86) - (-1760.0) = -1751.27 - 4.93 + 1760.0 = 3.80\n$$\n斜率 $D$ 为：\n$$\nD = B_{\\mathrm{d}} - B_{\\mathrm{p}} = -0.20 - (-0.05) = -0.15\n$$\n因此，氧空位形成能的具体线性模型为：\n$$\nE_{\\mathrm{v}}(U) = 3.80 - 0.15U\n$$\n现在我们为测试集 $U \\in \\{0.0, 2.0, 3.5, 4.0, 6.0, 8.0\\}$ 中的每个值计算 $E_{\\mathrm{v}}(U)$，所有能量单位均为电子伏特。\n\n对于 $U=0.0$：$E_{\\mathrm{v}}(0.0) = 3.80 - 0.15 \\times 0.0 = 3.800$\n对于 $U=2.0$：$E_{\\mathrm{v}}(2.0) = 3.80 - 0.15 \\times 2.0 = 3.80 - 0.30 = 3.500$\n对于 $U=3.5$：$E_{\\mathrm{v}}(3.5) = 3.80 - 0.15 \\times 3.5 = 3.80 - 0.525 = 3.275$\n对于 $U=4.0$：$E_{\\mathrm{v}}(4.0) = 3.80 - 0.15 \\times 4.0 = 3.80 - 0.60 = 3.200$\n对于 $U=6.0$：$E_{\\mathrm{v}}(6.0) = 3.80 - 0.15 \\times 6.0 = 3.80 - 0.90 = 2.900$\n对于 $U=8.0$：$E_{\\mathrm{v}}(8.0) = 3.80 - 0.15 \\times 8.0 = 3.80 - 1.20 = 2.600$\n\n下一步是通过将计算出的这些能量与实验区间 $[E_{\\min}, E_{\\max}] = [3.0, 3.3]$ 进行比较来选择“物理上合理”的 $U$。选择过程遵循一个包含两部分的规则。\n\n规则 1：如果一个或多个 $U$ 值产生的 $E_{\\mathrm{v}}(U)$ 落在 $[3.0, 3.3]$ 区间内，则选择其中最小的那个 $U$。\n我们来检查计算出的哪些能量落入此区间：\n- $E_{\\mathrm{v}}(0.0) = 3.800$ (区间外)\n- $E_{\\mathrm{v}}(2.0) = 3.500$ (区间外)\n- $E_{\\mathrm{v}}(3.5) = 3.275$ (区间内, 因为 $3.0 \\le 3.275 \\le 3.3$)\n- $E_{\\mathrm{v}}(4.0) = 3.200$ (区间内, 因为 $3.0 \\le 3.200 \\le 3.3$)\n- $E_{\\mathrm{v}}(6.0) = 2.900$ (区间外)\n- $E_{\\mathrm{v}}(8.0) = 2.600$ (区间外)\n\n$U$ 的两个值，即 $U=3.5$ 和 $U=4.0$，产生的氧空位形成能位于目标实验范围内。根据规则，我们必须选择其中最小的一个。因此，选定的值为 $u_{\\star} = 3.5$。\n\n由于根据规则 1 找到了候选值，因此无需启用规则 2。\n\n用于输出的最终列表由按顺序排列的 $E_{\\mathrm{v}}(U)$ 计算值和选定的 $u_{\\star}$ 组成，所有数值均四舍五入到三位小数。\n计算出的能量为：$3.800, 3.500, 3.275, 3.200, 2.900, 2.600$。\n选定的 Hubbard 参数是 $3.5$。\n最终输出将是该列表：$[3.800, 3.500, 3.275, 3.200, 2.900, 2.600, 3.500]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes oxygen vacancy formation energies E_v(U) for a set of Hubbard U parameters,\n    and selects a physically justified U based on comparison with an experimental range.\n    \"\"\"\n    # Define the constants from the problem statement (all in electronvolts).\n    A_p = -1760.0\n    B_p = -0.05\n    A_d = -1751.27\n    B_d = -0.20\n    A_O2 = -9.86\n\n    # Define the experimental interval for E_v and the test suite for U.\n    E_min = 3.0\n    E_max = 3.3\n    U_values = [0.0, 2.0, 3.5, 4.0, 6.0, 8.0]\n\n    # --- Step 1: Calculate E_v(U) for each U in the test suite ---\n    E_v_results = []\n    for u in U_values:\n        # The vacancy formation energy E_v(U) is derived from:\n        # E_v(U) = E_tot_defect(U) + 0.5 * E_tot_O2 - E_tot_pristine(U)\n        # Substituting the linear models:\n        # E_v(U) = (A_d + B_d*U) + 0.5 * A_O2 - (A_p + B_p*U)\n        # E_v(U) = (A_d + 0.5*A_O2 - A_p) + (B_d - B_p)*U\n        e_v = (A_d + 0.5 * A_O2 - A_p) + (B_d - B_p) * u\n        E_v_results.append(e_v)\n\n    # --- Step 2: Select the physically justified U based on the specified rules ---\n    selected_U = 0.0\n\n    # Rule 1: Check for U values yielding E_v within the experimental interval.\n    valid_U_candidates = []\n    for i, u in enumerate(U_values):\n        if E_min = E_v_results[i] = E_max:\n            valid_U_candidates.append(u)\n\n    if valid_U_candidates:\n        # If one or more U values are valid, select the smallest one.\n        selected_U = min(valid_U_candidates)\n    else:\n        # Rule 2: If no U is valid, find the U that minimizes the absolute deviation\n        # from the interval's midpoint.\n        midpoint = (E_min + E_max) / 2.0\n        \n        # Calculate deviations for all U values.\n        deviations = [abs(e_v - midpoint) for e_v in E_v_results]\n        min_deviation = min(deviations)\n        \n        # Find all U values that achieve this minimum deviation.\n        # This handles potential ties in deviation values.\n        best_U_candidates = []\n        for i, u in enumerate(U_values):\n            if np.isclose(deviations[i], min_deviation):\n                best_U_candidates.append(u)\n        \n        # Break ties by choosing the smallest U among the best candidates.\n        selected_U = min(best_U_candidates)\n\n    # --- Step 3: Format the final output ---\n    # Create the list of E_v results, rounded to three decimals.\n    formatted_E_v = [f\"{val:.3f}\" for val in E_v_results]\n    \n    # Format the selected U, rounded to three decimals.\n    formatted_selected_U = f\"{selected_U:.3f}\"\n    \n    # Combine into the final string format \"[val1,val2,...,valN,selected_u]\".\n    final_output_string = f\"[{','.join(formatted_E_v)},{formatted_selected_U}]\"\n\n    # Print the final result to standard output.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "在确定了 $U$ 值之后，理解与该选择相关的不确定性至关重要。敏感性分析是一种强有力的工具，它通过量化计算属性随 $U$ 变化的程度来实现这一目标。本练习 () 介绍了如何计算吸附能对 $U$ 的局部敏感性 ($\\partial E_{\\mathrm{ads}}/\\partial U$)，这有助于我们识别哪些化学过程对 $U$ 参数的选择最为敏感，从而为后续研究提供指导。",
            "id": "3901943",
            "problem": "要求您使用一种简化但被广泛接受的密度泛函理论加哈伯德 $U$ (DFT+$U$) 的形式理论，实现吸附能对哈伯德参数的局部敏感性分析。目标是计算几种吸附物在基准 $U_0$ 下的局部敏感性 $\\partial E_{\\mathrm{ads}}/\\partial U$，并通过将敏感性的大小与阈值进行比较，来确定哪些相互作用需要精确的 $U$ 值。\n\n基本原理：\n- 在 DFT+$U$ 的 Dudarev 简化形式中，由在位库仑相互作用引起的总能量修正项由下式给出\n$$\nE_U(U) = \\frac{U}{2}\\sum_{k} n_k(U)\\bigl(1 - n_k(U)\\bigr),\n$$\n其中 $U$ 是有效在位相互作用（单位为电子伏特），$n_k(U)$ 是局域子空间轨道（例如金属 $d$ 态）的占据数（无量纲）。这是一个经过充分检验的能量修正，它在许多实际计算中捕捉了强关联的主要效应。\n- 吸附能定义为\n$$\nE_{\\mathrm{ads}}(U) = E_{\\mathrm{sub+ads}}(U) - E_{\\mathrm{sub}}(U) - E_{\\mathrm{ads}}^{\\mathrm{gas}},\n$$\n其中 $E_{\\mathrm{ads}}^{\\mathrm{gas}}$ 在此模型中不依赖于 $U$。假设只有 DFT+$U$ 修正项依赖于 $U$，则敏感性 $\\partial E_{\\mathrm{ads}}/\\partial U$ 简化为吸附态（$\\mathrm{SA}$）和洁净衬底态（$\\mathrm{S}$）之间 DFT+$U$ 修正项敏感性的差异。\n\n在基准 $U_0$ 附近，基于局域响应（线性响应和计算催化中的一种常用近似），假定占据数随 $U$ 线性变化：\n$$\nn_k^{\\mathrm{SA}}(U) \\approx n_k^{\\mathrm{SA}}(U_0) + s_k^{\\mathrm{SA}}(U-U_0), \\quad\nn_k^{\\mathrm{S}}(U) \\approx n_k^{\\mathrm{S}}(U_0) + s_k^{\\mathrm{S}}(U-U_0),\n$$\n其中 $s_k^{\\mathrm{SA}}=\\left.\\frac{\\partial n_k^{\\mathrm{SA}}}{\\partial U}\\right|_{U_0}$ 和 $s_k^{\\mathrm{S}}=\\left.\\frac{\\partial n_k^{\\mathrm{S}}}{\\partial U}\\right|_{U_0}$ 是无量纲的局域斜率。\n\n您的任务：\n- 对于每个测试用例，计算局部敏感性\n$$\n\\left.\\frac{\\partial E_{\\mathrm{ads}}}{\\partial U}\\right|_{U_0}\n$$\n使用应用于上述定义的链式法则。此外，使用一个小的增量 $\\Delta U$，通过中心有限差分近似来验证结果：\n$$\n\\left.\\frac{\\partial E_{\\mathrm{ads}}}{\\partial U}\\right|_{U_0} \\approx \\frac{E_{\\mathrm{ads}}(U_0+\\Delta U)-E_{\\mathrm{ads}}(U_0-\\Delta U)}{2\\,\\Delta U}.\n$$\n- $U$ 的单位为 $\\mathrm{eV}$，$E_U$ 和 $E_{\\mathrm{ads}}$ 的单位为 $\\mathrm{eV}$，并将 $\\partial E_{\\mathrm{ads}}/\\partial U$ 报告为无量纲数。将所有报告的浮点数结果四舍五入到六位小数。\n- 优先级规则：如果 $\\left|\\partial E_{\\mathrm{ads}}/\\partial U\\right|\\ge \\tau$，阈值 $\\tau=0.05$（无量纲），则该相互作用需要精确的 $U$ 值；否则不需要。\n\n测试集：\n对于每个用例，您将获得 $U_0$、列表 $\\{n_k^{\\mathrm{SA}}(U_0)\\}$、$\\{s_k^{\\mathrm{SA}}\\}$、$\\{n_k^{\\mathrm{S}}(U_0)\\}$、$\\{s_k^{\\mathrm{S}}\\}$ 以及一个共同的 $\\Delta U = 0.01\\,\\mathrm{eV}$。\n- 用例1（通用情况）：$U_0=4.0\\,\\mathrm{eV}$；$n_k^{\\mathrm{SA}}(U_0)=[0.6,\\,0.4,\\,0.2]$，$s_k^{\\mathrm{SA}}=[-0.02,\\,0.01,\\,0.0]$；$n_k^{\\mathrm{S}}(U_0)=[0.5,\\,0.3,\\,0.25]$，$s_k^{\\mathrm{S}}=[-0.01,\\,0.005,\\,0.0]$。\n- 用例2（边界高占据数）：$U_0=5.0\\,\\mathrm{eV}$；$n_k^{\\mathrm{SA}}(U_0)=[0.99]$，$s_k^{\\mathrm{SA}}=[-0.001]$；$n_k^{\\mathrm{S}}(U_0)=[0.95]$，$s_k^{\\mathrm{S}}=[-0.002]$。\n- 用例3（零斜率，仅占据数差异）：$U_0=3.0\\,\\mathrm{eV}$；$n_k^{\\mathrm{SA}}(U_0)=[0.7,\\,0.3]$，$s_k^{\\mathrm{SA}}=[0.0,\\,0.0]$；$n_k^{\\mathrm{S}}(U_0)=[0.5,\\,0.5]$，$s_k^{\\mathrm{S}}=[0.0,\\,0.0]$。\n- 用例4（强响应）：$U_0=4.5\\,\\mathrm{eV}$；$n_k^{\\mathrm{SA}}(U_0)=[0.2,\\,0.8,\\,0.5]$，$s_k^{\\mathrm{SA}}=[0.03,\\,-0.03,\\,0.02]$；$n_k^{\\mathrm{S}}(U_0)=[0.1,\\,0.9,\\,0.45]$，$s_k^{\\mathrm{S}}=[0.005,\\,-0.01,\\,0.0]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，格式完全如下：\n$$\n\\big[ [d_1,d_2,\\dots],[\\tilde d_1,\\tilde d_2,\\dots],[b_1,b_2,\\dots] \\big],\n$$\n其中 $d_i$ 是解析敏感性（无量纲），$\\tilde d_i$ 是中心有限差分敏感性（无量纲），$b_i$ 是布尔值，表明是否 $\\left|d_i\\right|\\ge \\tau$。所有浮点值都必须四舍五入到六位小数。输出中不允许有空格。",
            "solution": "任务是使用解析方法和数值方法计算吸附能相对于哈伯德 $U$ 参数的敏感性 $\\partial E_{\\mathrm{ads}}/\\partial U$。\n\n吸附能 $E_{\\mathrm{ads}}(U)$ 定义为：\n$$\nE_{\\mathrm{ads}}(U) = E_{\\mathrm{sub+ads}}(U) - E_{\\mathrm{sub}}(U) - E_{\\mathrm{ads}}^{\\mathrm{gas}}\n$$\n鉴于只有哈伯德能量修正项 $E_U(U)$ 依赖于参数 $U$，吸附能的敏感性简化为衬底-吸附物（SA）系统和洁净衬底（S）系统的哈伯德修正项敏感性之差：\n$$\n\\frac{\\partial E_{\\mathrm{ads}}}{\\partial U} = \\frac{\\partial E_U^{\\mathrm{SA}}}{\\partial U} - \\frac{\\partial E_U^{\\mathrm{S}}}{\\partial U}\n$$\n我们必须首先推导导数 $\\partial E_U / \\partial U$ 的通用表达式。哈伯德能量修正项由下式给出：\n$$\nE_U(U) = \\frac{U}{2}\\sum_{k} n_k(U)\\bigl(1 - n_k(U)\\bigr)\n$$\n为了求出关于 $U$ 的导数，我们应用乘法法则和链式法则：\n$$\n\\frac{\\partial E_U}{\\partial U} = \\frac{\\partial}{\\partial U}\\left( \\frac{U}{2} \\right) \\left( \\sum_k [n_k(U) - n_k(U)^2] \\right) + \\frac{U}{2} \\frac{\\partial}{\\partial U}\\left( \\sum_k [n_k(U) - n_k(U)^2] \\right)\n$$\n$$\n\\frac{\\partial E_U}{\\partial U} = \\frac{1}{2} \\sum_k n_k(U)(1 - n_k(U)) + \\frac{U}{2} \\sum_k \\left( \\frac{\\partial n_k}{\\partial U} - 2n_k(U)\\frac{\\partial n_k}{\\partial U} \\right)\n$$\n$$\n\\frac{\\partial E_U}{\\partial U} = \\frac{1}{2} \\sum_k n_k(U)(1 - n_k(U)) + \\frac{U}{2} \\sum_k (1 - 2n_k(U)) \\frac{\\partial n_k}{\\partial U}\n$$\n为了求出在 $U=U_0$ 处的局部敏感性，我们代入 $U=U_0$，$n_k(U)=n_k(U_0)$ 和 $\\frac{\\partial n_k}{\\partial U} = s_k$：\n$$\n\\left.\\frac{\\partial E_U}{\\partial U}\\right|_{U_0} = \\frac{1}{2} \\sum_k n_k(U_0)(1 - n_k(U_0)) + \\frac{U_0}{2} \\sum_k (1 - 2n_k(U_0))s_k\n$$\n这个表达式使我们能够计算 SA 和 S 系统的解析敏感性，它们的差值即为所需的吸附能解析敏感性 $d_i$：\n$$\nd_i = \\left.\\frac{\\partial E_{\\mathrm{ads}}}{\\partial U}\\right|_{U_0} = \\left( \\left.\\frac{\\partial E_U^{\\mathrm{SA}}}{\\partial U}\\right|_{U_0} \\right) - \\left( \\left.\\frac{\\partial E_U^{\\mathrm{S}}}{\\partial U}\\right|_{U_0} \\right)\n$$\n\n对于数值验证，我们使用带有小步长 $\\Delta U$ 的中心有限差分公式：\n$$\n\\tilde{d_i} = \\left.\\frac{\\partial E_{\\mathrm{ads}}}{\\partial U}\\right|_{U_0} \\approx \\frac{E_{\\mathrm{ads}}(U_0+\\Delta U) - E_{\\mathrm{ads}}(U_0-\\Delta U)}{2\\Delta U}\n$$\n要使用此公式，我们必须首先计算在 $U_+ = U_0+\\Delta U$ 和 $U_- = U_0-\\Delta U$ 时的吸附能。吸附能的计算公式为 $E_{\\mathrm{ads}}(U) = E_U^{\\mathrm{SA}}(U) - E_U^{\\mathrm{S}}(U)$。\n在 $U_+$ 和 $U_-$ 时的轨道占据数值由给定的线性近似确定：\n对于 SA 系统：\n$$\nn_k^{\\mathrm{SA}}(U_+) = n_k^{\\mathrm{SA}}(U_0) + s_k^{\\mathrm{SA}}\\Delta U\n$$\n$$\nn_k^{\\mathrm{SA}}(U_-) = n_k^{\\mathrm{SA}}(U_0) - s_k^{\\mathrm{SA}}\\Delta U\n$$\n对于 S 系统：\n$$\nn_k^{\\mathrm{S}}(U_+) = n_k^{\\mathrm{S}}(U_0) + s_k^{\\mathrm{S}}\\Delta U\n$$\n$$\nn_k^{\\mathrm{S}}(U_-) = n_k^{\\mathrm{S}}(U_0) - s_k^{\\mathrm{S}}\\Delta U\n$$\n利用这些估算的占据数，我们计算每个系统在 $U_+$ 和 $U_-$ 时的哈伯德能量 $E_U(U)$：\n$$\nE_U^{\\mathrm{sys}}(U) = \\frac{U}{2}\\sum_{k} n_k^{\\mathrm{sys}}(U)(1 - n_k^{\\mathrm{sys}}(U))\n$$\n最后，我们计算 $E_{\\mathrm{ads}}(U_+) = E_U^{\\mathrm{SA}}(U_+) - E_U^{\\mathrm{S}}(U_+)$ 和 $E_{\\mathrm{ads}}(U_-) = E_U^{\\mathrm{SA}}(U_-) - E_U^{\\mathrm{S}}(U_-)$，并将这些值代入有限差分公式，以获得数值敏感性 $\\tilde{d_i}$。\n\n优先级判据是一个布尔检查：如果 $|d_i| \\ge \\tau$（其中 $\\tau = 0.05$），则该相互作用需要精确的 $U$ 值。每个用例 $i$ 的结果是一个布尔值 $b_i$。\n\n该实现将通过应用这些公式来处理每个测试用例，将最终的浮点数敏感性四舍五入到六位小数，并生成布尔标志。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating Hubbard U sensitivity for adsorption energy.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"U0\": 4.0,\n            \"n_sa\": [0.6, 0.4, 0.2],\n            \"s_sa\": [-0.02, 0.01, 0.0],\n            \"n_s\": [0.5, 0.3, 0.25],\n            \"s_s\": [-0.01, 0.005, 0.0],\n        },\n        {\n            \"U0\": 5.0,\n            \"n_sa\": [0.99],\n            \"s_sa\": [-0.001],\n            \"n_s\": [0.95],\n            \"s_s\": [-0.002],\n        },\n        {\n            \"U0\": 3.0,\n            \"n_sa\": [0.7, 0.3],\n            \"s_sa\": [0.0, 0.0],\n            \"n_s\": [0.5, 0.5],\n            \"s_s\": [0.0, 0.0],\n        },\n        {\n            \"U0\": 4.5,\n            \"n_sa\": [0.2, 0.8, 0.5],\n            \"s_sa\": [0.03, -0.03, 0.02],\n            \"n_s\": [0.1, 0.9, 0.45],\n            \"s_s\": [0.005, -0.01, 0.0],\n        },\n    ]\n\n    dU = 0.01\n    tau = 0.05\n\n    analytic_results = []\n    fd_results = []\n    prio_results = []\n\n    def get_analytic_deriv(U0, n_U0, s):\n        \"\"\"Calculates the analytical derivative dE_U/dU for a single system.\"\"\"\n        term1 = 0.5 * np.sum(n_U0 * (1 - n_U0))\n        term2 = (U0 / 2.0) * np.sum((1 - 2 * n_U0) * s)\n        return term1 + term2\n\n    def calculate_EU(U, U0, n_U0, s):\n        \"\"\"Calculates the Hubbard energy E_U for a single system at a given U.\"\"\"\n        n_at_U = n_U0 + s * (U - U0)\n        E_U = (U / 2.0) * np.sum(n_at_U * (1 - n_at_U))\n        return E_U\n\n    for case in test_cases:\n        U0 = case[\"U0\"]\n        n_sa_U0 = np.array(case[\"n_sa\"])\n        s_sa = np.array(case[\"s_sa\"])\n        n_s_U0 = np.array(case[\"n_s\"])\n        s_s = np.array(case[\"s_s\"])\n\n        # 1. Analytical sensitivity\n        d_sa_analytic = get_analytic_deriv(U0, n_sa_U0, s_sa)\n        d_s_analytic = get_analytic_deriv(U0, n_s_U0, s_s)\n        d_analytic = d_sa_analytic - d_s_analytic\n        analytic_results.append(d_analytic)\n\n        # 2. Finite difference sensitivity\n        U_plus = U0 + dU\n        U_minus = U0 - dU\n\n        E_U_sa_plus = calculate_EU(U_plus, U0, n_sa_U0, s_sa)\n        E_U_sa_minus = calculate_EU(U_minus, U0, n_sa_U0, s_sa)\n\n        E_U_s_plus = calculate_EU(U_plus, U0, n_s_U0, s_s)\n        E_U_s_minus = calculate_EU(U_minus, U0, n_s_U0, s_s)\n\n        E_ads_plus = E_U_sa_plus - E_U_s_plus\n        E_ads_minus = E_U_sa_minus - E_U_s_minus\n        \n        d_fd = (E_ads_plus - E_ads_minus) / (2 * dU)\n        fd_results.append(d_fd)\n\n        # 3. Prioritization\n        prio_results.append(abs(d_analytic) >= tau)\n\n    # Format the results for the final output string\n    # All floats must be rounded to six decimal places\n    d_str = \",\".join([f\"{x:.6f}\" for x in analytic_results])\n    fd_str = \",\".join([f\"{x:.6f}\" for x in fd_results])\n    # The default str() for booleans is 'True'/'False', which is acceptable\n    prio_str = \",\".join([str(x) for x in prio_results])\n\n    # Final print statement in the exact required format without spaces.\n    print(f\"[[{d_str}],[{fd_str}],[{prio_str}]]\")\n\nsolve()\n```"
        }
    ]
}