{
    "hands_on_practices": [
        {
            "introduction": "这项练习将深入探讨非绝热动力学的核心。我们将通过数值积分含时薛定谔方程，模拟电子波函数在一个预设的原子核路径上的演化。这个实践将演示当一个系统经过强耦合区域时，量子态的布居数如何随时间变化，为理解表面跳跃的机理奠定基础。",
            "id": "3892328",
            "problem": "考虑一个与计算催化和化学工程中的非绝热动力学和最少切换面跳相关的一维双态绝热模型。该模型源于一个具有恒定透热耦合的双能级透热哈密顿量，其绝热表示沿着一条经典轨迹提供了给定的绝热能量和非绝热导数耦合。从含时薛定谔方程（TDSE）出发，需要对沿给定经典核轨迹的绝热电子振幅的耦合方程进行积分，以获得演化的态布居数。\n\n使用以下物理上一致的设置。透热哈密顿量由参数 $\\alpha$ 和 $V$ 定义，形式如下\n$$\nH_{\\text{diab}}(R) = \n\\begin{pmatrix}\n\\alpha R  V \\\\\nV  -\\alpha R\n\\end{pmatrix},\n$$\n其中 $R$ 是核坐标。绝热能量 $E_{\\pm}(R)$ 和混合角 $\\theta(R)$ 定义为\n$$\nE_{\\pm}(R) = \\pm \\sqrt{(\\alpha R)^2 + V^2},\n\\quad\n\\theta(R) = \\tfrac{1}{2} \\arctan\\!\\left(\\frac{V}{\\alpha R}\\right).\n$$\n绝热态之间的非绝热导数耦合为\n$$\nd_{+-}(R) = \\frac{\\partial\\theta}{\\partial R}\n= -\\frac{V\\,\\alpha}{2\\left((\\alpha R)^2 + V^2\\right)},\n\\quad\nd_{-+}(R) = -d_{+-}(R),\n\\quad\nd_{++}(R) = d_{--}(R) = 0.\n$$\n\n假设一个具有恒定速度的经典核轨迹，\n$$\nR(t) = R_0 + v\\,t,\n$$\n其中 $t$ 是时间坐标。在绝热基 $\\{ \\lvert \\phi_+(R) \\rangle, \\lvert \\phi_-(R) \\rangle \\}$ 中，耦合电子振幅方程为\n$$\ni\\hbar\\,\\frac{d c_i}{dt} = E_i(R(t))\\,c_i - i\\hbar\\sum_{j} \\dot{R}(t)\\,d_{ij}(R(t))\\,c_j,\n\\quad i,j \\in \\{+, -\\},\n$$\n其中 $\\dot{R}(t) = v$。等价地，\n$$\n\\frac{d\\mathbf{c}}{dt} = -\\frac{i}{\\hbar}\\,\\mathrm{diag}(E_+(R(t)), E_-(R(t)))\\,\\mathbf{c}\n- v\\,\n\\begin{pmatrix}\n0  d_{+-}(R(t)) \\\\\n-d_{+-}(R(t))  0\n\\end{pmatrix}\n\\,\\mathbf{c},\n$$\n其中 $\\mathbf{c}(t) = \\begin{pmatrix} c_+(t) \\\\ c_-(t) \\end{pmatrix}$。初始条件为系统在起始坐标处制备在较低的绝热态上，即\n$$\nc_+(0) = 0, \\quad c_-(0) = 1.\n$$\n\n设 $\\hbar$ 是以电子伏特·飞秒 (eV·fs) 为单位表示的约化普朗克常数，其数值为\n$$\n\\hbar = 0.6582119514\\,\\text{eV·fs}.\n$$\n\n单位和报告要求：\n- 坐标 $R$ 的单位必须是埃 ($\\text{\\AA}$)，速度 $v$ 的单位是 $\\text{\\AA}/\\text{fs}$，时间 $t$ 的单位是飞秒 (fs)，能量 $E_{\\pm}$ 以及参数 $\\alpha$ 和 $V$ 的单位是电子伏特 (eV)。\n- 布居数 $P_i(t) = |c_i(t)|^2$ 是无量纲的，必须以浮点数形式报告。\n- 您的程序必须计算每个测试用例在最终时间 $T$ 时的最终绝热态布居数 $P_+(T)$ 和 $P_-(T)$。\n\n测试套件：\n对于每组参数，沿 $R(t) = R_0 + v\\,t$ 从 $t=0$ 积分到 $t=T$。\n\n1. 正常路径穿越：\n   - $\\alpha = 0.1$ (eV/$\\text{\\AA}$), $V = 0.05$ (eV), $R_0 = -5$ ($\\text{\\AA}$), $v = 0.1$ ($\\text{\\AA}/\\text{fs}$), $T = 100$ (fs)。\n\n2. 快速通过（预期更强的透热行为）：\n   - $\\alpha = 0.1$ (eV/$\\text{\\AA}$), $V = 0.05$ (eV), $R_0 = -5$ ($\\text{\\AA}$), $v = 1.0$ ($\\text{\\AA}/\\text{fs}$), $T = 10$ (fs)。\n\n3. 慢速通过（预期更强的绝热行为）：\n   - $\\alpha = 0.1$ (eV/$\\text{\\AA}$), $V = 0.05$ (eV), $R_0 = -5$ ($\\text{\\AA}$), $v = 0.01$ ($\\text{\\AA}/\\text{fs}$), $T = 1000$ (fs)。\n\n4. 弱耦合：\n   - $\\alpha = 0.1$ (eV/$\\text{\\AA}$), $V = 0.005$ (eV), $R_0 = -5$ ($\\text{\\AA}$), $v = 0.1$ ($\\text{\\AA}/\\text{fs}$), $T = 100$ (fs)。\n\n算法要求：\n- 按照上述方式积分耦合振幅方程，不引入任何唯象的切换规则；仅计算电子振幅沿给定经典轨迹的相干演化。\n- 确保数值稳定性，并通过在必要时对最终振幅进行重新归一化，将概率归一化保持在数值容差范围内。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的浮点数对列表，并用方括号括起来。每个浮点数对 $[P_+(T), P_-(T)]$ 对应于上述顺序的一个测试用例。例如，包含两个测试用例的输出将如下所示：$[[0.123456,0.876544],[0.234567,0.765433]]$。这里的四个测试用例的实际数值必须由您的代码计算得出。",
            "solution": "该问题要求在绝热表示下，求解一个双态模型系统的含时薛定谔方程（TDSE）。系统的演化由给定的核坐标经典轨迹控制。这是非绝热动力学领域的一个标准问题，常用于模拟电子势能面避免交叉附近的分子过程。目标是计算系统穿过强非绝热耦合区域后，两个绝热电子态的最终布居数。\n\n问题的核心在于对复数值电子振幅 $c_+(t)$ 和 $c_-(t)$ 的耦合一阶常微分方程（ODE）进行积分。这些振幅是在绝热态 $|\\phi_+(R(t))\\rangle$ 和 $|\\phi_-(R(t))\\rangle$ 基组中电子波函数的系数。控制方程直接从TDSE推导得出，如下所示：\n$$\n\\frac{d c_+}{dt} = -\\frac{i}{\\hbar} E_+(R(t)) c_+(t) - v d_{+-}(R(t)) c_-(t)\n$$\n$$\n\\frac{d c_-}{dt} = -\\frac{i}{\\hbar} E_-(R(t)) c_-(t) + v d_{+-}(R(t)) c_+(t)\n$$\n可以写成矩阵形式：\n$$\n\\frac{d\\mathbf{c}}{dt} = \\mathbf{A}(t) \\mathbf{c}(t)\n$$\n其中 $\\mathbf{c}(t) = \\begin{pmatrix} c_+(t) \\\\ c_-(t) \\end{pmatrix}$ 是状态向量，$\\mathbf{A}(t)$ 是含时演化矩阵：\n$$\n\\mathbf{A}(t) = \n\\begin{pmatrix}\n-\\frac{i}{\\hbar} E_+(R(t))  -v d_{+-}(R(t)) \\\\\nv d_{+-}(R(t))  -\\frac{i}{\\hbar} E_-(R(t))\n\\end{pmatrix}\n$$\n该矩阵中的各项取决于瞬时核坐标 $R(t) = R_0 + v t$。绝热能量 $E_{\\pm}(R)$ 和非绝热导数耦合 $d_{+-}(R)$ 定义如下：\n$$\nE_{\\pm}(R) = \\pm \\sqrt{(\\alpha R)^2 + V^2}\n$$\n$$\nd_{+-}(R) = -\\frac{V\\alpha}{2\\left((\\alpha R)^2 + V^2\\right)}\n$$\n每个测试用例都提供了参数 $\\alpha$、$V$、$R_0$ 和 $v$，以及约化普朗克常数 $\\hbar = 0.6582119514\\,\\text{eV·fs}$。问题指定了一个初始条件，即在时间 $t=0$ 时，系统完全制备在较低的绝热态上：\n$$\nc_+(0) = 0, \\quad c_-(0) = 1\n$$\n这个设置定义了一个线性、一阶、复数值常微分方程组的初值问题。可以通过数值积分获得解。为此，我们采用了一个高质量的数值ODE求解器。SciPy库中的 `scipy.integrate.solve_ivp` 函数是一个合适的选择，因为它为解决此类问题提供了稳健的自适应算法。我们将使用标准的龙格-库塔方法（例如默认的 `RK45`），并设置严格的相对和绝对误差容限（例如，分别为 $10^{-9}$ 和 $10^{-12}$），以确保获得高精度的解。\n\n每个测试用例的算法如下：\n1. 定义一个函数，用于在给定时间 $t$ 和状态 $\\mathbf{c}(t)$ 下计算导数向量 $d\\mathbf{c}/dt$。该函数使用所提供的物理参数实现矩阵 $\\mathbf{A}(t)$。\n2. 设置积分时间区间，从 $t=0$ 到最终时间 $t=T$。\n3. 提供初始状态向量 $\\mathbf{c}(0) = \\begin{pmatrix} 0+0i \\\\ 1+0i \\end{pmatrix}$。\n4. 调用数值积分器（`solve_ivp`）将状态向量从 $t=0$ 传播到 $t=T$。\n5. 从积分器的输出中，提取最终状态向量 $\\mathbf{c}(T) = \\begin{pmatrix} c_+(T) \\\\ c_-(T) \\end{pmatrix}$。\n6. 由ODE系统描述的演化是幺正的，这意味着状态向量的范数 $\\| \\mathbf{c}(t) \\|^2 = |c_+(t)|^2 + |c_-(t)|^2$ 应该在任何时候都守恒且等于1。为抵消可能导致该守恒性被微小破坏的数值误差，通过将最终状态向量 $\\mathbf{c}(T)$ 除以其范数来进行重新归一化。\n7. 最后，通过计算相应振幅的模平方来得到时间 $T$ 时绝热态的布居数：$P_+(T) = |c_+(T)|^2$ 和 $P_-(T) = |c_-(T)|^2$。\n\n对问题陈述中指定的四个参数集中的每一个重复此过程，以获得每种情况下的最终布居数 $[P_+(T), P_-(T)]$。然后按要求将结果格式化为单个字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the time-dependent Schrödinger equation for a two-level system\n    for four different test cases and prints the final populations.\n    \"\"\"\n    # Define the reduced Planck constant in eV·fs\n    HBAR = 0.6582119514\n\n    def ode_system(t, c, alpha, V, R0, v):\n        \"\"\"\n        Defines the system of coupled ODEs for the electronic amplitudes.\n        \"\"\"\n        # Calculate the nuclear coordinate R at time t\n        R = R0 + v * t\n\n        # Calculate terms for energies and derivative coupling\n        common_term_sq = (alpha * R)**2 + V**2\n        \n        if common_term_sq = 0:\n            # This case is physically avoided as V > 0\n            # and should not be reached.\n            # Handle to prevent division by zero if V=0 and R=0.\n            E_plus = 0.0\n            E_minus = 0.0\n            d_plus_minus = 0.0\n        else:\n            sqrt_term = np.sqrt(common_term_sq)\n            E_plus = sqrt_term\n            E_minus = -sqrt_term\n            # Non-adiabatic derivative coupling d_{+-}\n            d_plus_minus = -V * alpha / (2 * common_term_sq)\n\n        c_plus, c_minus = c\n        \n        # Coupled differential equations for amplitudes c+ and c-\n        dc_plus_dt = (-1j / HBAR) * E_plus * c_plus - v * d_plus_minus * c_minus\n        dc_minus_dt = (-1j / HBAR) * E_minus * c_minus + v * d_plus_minus * c_plus\n        \n        return [dc_plus_dt, dc_minus_dt]\n\n    # Define the four test cases from the problem statement\n    test_cases = [\n        # Case 1: Normal path crossing\n        {\"alpha\": 0.1, \"V\": 0.05, \"R0\": -5.0, \"v\": 0.1, \"T\": 100.0},\n        # Case 2: Fast passage (more diabatic)\n        {\"alpha\": 0.1, \"V\": 0.05, \"R0\": -5.0, \"v\": 1.0, \"T\": 10.0},\n        # Case 3: Slow passage (more adiabatic)\n        {\"alpha\": 0.1, \"V\": 0.05, \"R0\": -5.0, \"v\": 0.01, \"T\": 1000.0},\n        # Case 4: Weak coupling\n        {\"alpha\": 0.1, \"V\": 0.005, \"R0\": -5.0, \"v\": 0.1, \"T\": 100.0},\n    ]\n\n    # Initial conditions: start in the lower adiabatic state\n    c0 = [0.0 + 0.0j, 1.0 + 0.0j]\n    all_results = []\n\n    for params in test_cases:\n        T_final = params[\"T\"]\n        \n        # Solve the ODE system\n        sol = solve_ivp(\n            ode_system, \n            [0, T_final], \n            c0, \n            args=(params[\"alpha\"], params[\"V\"], params[\"R0\"], params[\"v\"]),\n            dense_output=True,\n            rtol=1e-9, \n            atol=1e-12\n        )\n        \n        # Extract the final state vector\n        c_final = sol.y[:, -1]\n        \n        # Renormalize to conserve probability, correcting for small numerical errors\n        norm = np.sqrt(np.sum(np.abs(c_final)**2))\n        if norm > 0:\n            c_final_normalized = c_final / norm\n        else:\n            c_final_normalized = c_final\n            \n        # Calculate final populations\n        pop_plus = np.abs(c_final_normalized[0])**2\n        pop_minus = np.abs(c_final_normalized[1])**2\n        \n        all_results.append([pop_plus, pop_minus])\n\n    # Print the results in the required format\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "上一项练习假设我们已经知道了势能面和耦合项，但这项实践将回答一个问题：这些量从何而来？ 我们将从一个模型的电子哈密顿量出发，这类似于我们从量子化学计算中得到的结果，然后利用 Hellmann-Feynman 定理计算出绝热能和至关重要的非绝热耦合项。这项练习连接了电子结构理论和动力学模拟所需的参数，起到了桥梁的作用。",
            "id": "3892349",
            "problem": "考虑一个一维核坐标 $R$，代表催化表面上小分子的金属-吸附物键长。在一个最小双态透热表象中，电子哈密顿量被建模为一个 $2 \\times 2$ 矩阵 $H_{\\mathrm{d}}(R)$，其中的透热势通过局域相互作用耦合。两种不同的参数化模拟了两种不同的电子结构基组选择（标记为“A”和“B”）。对于每种基组选择，定义\n$$\nH_{\\mathrm{d}}(R) = \n\\begin{bmatrix}\nA_1 + k_1 R  V_0 \\exp\\!\\left(-\\dfrac{(R - R_c)^2}{2 \\sigma^2}\\right) \\\\\nV_0 \\exp\\!\\left(-\\dfrac{(R - R_c)^2}{2 \\sigma^2}\\right)  A_2 - k_2 R\n\\end{bmatrix},\n$$\n其中 $A_1$ 和 $A_2$ 是以电子伏特 (eV) 为单位的能量偏移，$k_1$ 和 $k_2$ 是以 eV/Å 为单位的斜率，$V_0$ 是以 eV 为单位的耦合强度，$R_c$ 是以埃 (Å) 为单位的交叉点坐标，而 $\\sigma$ 是以 Å 为单位的耦合宽度。通过对角化 $H_{\\mathrm{d}}(R)$，可以得到绝热能量 $E_1(R)$ 和 $E_2(R)$ 以及绝热电子态 $\\{ \\lvert \\phi_1(R) \\rangle, \\lvert \\phi_2(R) \\rangle \\}$。\n\n绝热态 $i$ 和 $j$ 之间沿 $R$ 的非绝热导数耦合由基本关系式定义\n$$\nd_{ij}(R) = \\langle \\phi_i(R) \\vert \\nabla_R \\phi_j(R) \\rangle,\n$$\n该关系式控制着混合量子-经典动力学（如表面跳跃）中的电子跃迁。对于非简并态 $i \\neq j$，使用 Hellmann–Feynman 定理（一个经过充分检验的结果），\n$$\nd_{ij}(R) = \\frac{\\langle \\phi_i(R) \\vert \\partial H_{\\mathrm{d}}(R)/\\partial R \\vert \\phi_j(R) \\rangle}{E_j(R) - E_i(R)}.\n$$\n在本问题中，您将需要为两种不同的参数集（“基组A”和“基组B”）计算激发态能量 $E_2(R)$ 和导数耦合 $d_{12}(R)$，并定量评估基组选择在指定的 $R$ 值网格上如何影响 $d_{12}(R)$。\n\n对每个测试用例，执行以下步骤：\n1. 对于两种基组参数化，在网格上的每个 $R$ 点构建 $H_{\\mathrm{d}}(R)$。\n2. 对角化 $H_{\\mathrm{d}}(R)$ 以获得 $E_1(R)$、$E_2(R)$ 和相应的正交归一绝热本征矢量 $\\lvert \\phi_1(R) \\rangle$、$\\lvert \\phi_2(R) \\rangle$，并按 $E_1(R) \\le E_2(R)$ 排序。\n3. 计算\n$$\n\\frac{\\partial H_{\\mathrm{d}}(R)}{\\partial R} =\n\\begin{bmatrix}\nk_1  \\dfrac{\\partial V(R)}{\\partial R} \\\\\n\\dfrac{\\partial V(R)}{\\partial R}  -k_2\n\\end{bmatrix},\n\\quad \\text{其中} \\quad\nV(R) = V_0 \\exp\\!\\left(-\\dfrac{(R - R_c)^2}{2 \\sigma^2}\\right),\n$$\n和\n$$\n\\frac{\\partial V(R)}{\\partial R} = V_0 \\exp\\!\\left(-\\dfrac{(R - R_c)^2}{2 \\sigma^2}\\right)\\left(-\\frac{R - R_c}{\\sigma^2}\\right).\n$$\n4. 计算\n$$\nd_{12}(R) = \\frac{\\langle \\phi_1(R) \\vert \\partial H_{\\mathrm{d}}(R)/\\partial R \\vert \\phi_2(R) \\rangle}{E_2(R) - E_1(R)},\n$$\n对于网格上的每个 $R$。如果 $E_2(R) - E_1(R)$ 在数值上过小，则通过将分母替换为 $\\max\\!\\left(E_2(R) - E_1(R), \\varepsilon\\right)$ 来进行正则化，其中 $\\varepsilon$ 是一个小的正常数（选择 $\\varepsilon = 10^{-12}$ eV），以保持数值稳定性，同时反映在精确交叉点附近的物理发散趋势。\n5. 通过计算以下量来量化基组选择对 $d_{12}(R)$ 的影响：\n   - 网格上的最大绝对差，\n     $$\n     \\Delta_{\\max} = \\max_{R} \\left| d^{(A)}_{12}(R) - d^{(B)}_{12}(R) \\right|,\n     $$\n   - 网格上的均方根 (RMS) 差，\n     $$\n     \\Delta_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N} \\sum_{n=1}^{N} \\left( d^{(A)}_{12}(R_n) - d^{(B)}_{12}(R_n) \\right)^2 },\n     $$\n     其中 $N$ 是网格点数。\n   - 每种基组参数化在交叉点坐标处的激发态能量，\n     $$\n     E^{(A)}_2(R_c) \\quad \\text{和} \\quad E^{(B)}_2(R_c),\n     $$\n     以电子伏特 (eV) 为单位。\n\n单位：\n- 所有能量以电子伏特 (eV) 表示。\n- 所有导数耦合 $d_{12}(R)$ 及其差值以逆埃 ($\\mathrm{\\AA}^{-1}$) 表示。\n- 坐标 $R$ 以埃 ($\\mathrm{\\AA}$) 为单位。\n\n您的程序必须为每个测试用例计算包含四个浮点数结果的列表\n$$\n\\left[\\Delta_{\\max}, \\Delta_{\\mathrm{RMS}}, E^{(A)}_2(R_c), E^{(B)}_2(R_c)\\right],\n$$\n并生成一行输出，其中包含所有测试用例的结果，格式为一个逗号分隔的列表，并用方括号括起来，其中每个元素是对应一个测试用例的列表（例如，“[[...],[...],...]”）。\n\n测试套件：\n使用以下四个测试用例，每个用例由两组参数集（“A”和“B”）和一个 $R$ 的网格指定：\n- 用例1（中等耦合，避免交叉）：\n  - 基组A：$A_1 = 0.0$ eV, $A_2 = 0.20$ eV, $k_1 = 0.50$ eV/$\\mathrm{\\AA}$, $k_2 = 0.40$ eV/$\\mathrm{\\AA}$, $V_0 = 0.15$ eV, $R_c = 2.20$ $\\mathrm{\\AA}$, $\\sigma = 0.12$ $\\mathrm{\\AA}$。\n  - 基组B：$A_1 = 0.0$ eV, $A_2 = 0.22$ eV, $k_1 = 0.50$ eV/$\\mathrm{\\AA}$, $k_2 = 0.45$ eV/$\\mathrm{\\AA}$, $V_0 = 0.10$ eV, $R_c = 2.20$ $\\mathrm{\\AA}$, $\\sigma = 0.12$ $\\mathrm{\\AA}$。\n  - 网格：$R$ 从 $1.50$ $\\mathrm{\\AA}$ 到 $3.00$ $\\mathrm{\\AA}$，步长为 $0.01$ $\\mathrm{\\AA}$。\n- 用例2（近简并，小耦合宽度）：\n  - 基组A：$A_1 = -0.05$ eV, $A_2 = 0.25$ eV, $k_1 = 0.60$ eV/$\\mathrm{\\AA}$, $k_2 = 0.60$ eV/$\\mathrm{\\AA}$, $V_0 = 0.02$ eV, $R_c = 2.00$ $\\mathrm{\\AA}$, $\\sigma = 0.08$ $\\mathrm{\\AA}$。\n  - 基组B：$A_1 = -0.04$ eV, $A_2 = 0.23$ eV, $k_1 = 0.58$ eV/$\\mathrm{\\AA}$, $k_2 = 0.62$ eV/$\\mathrm{\\AA}$, $V_0 = 0.05$ eV, $R_c = 2.00$ $\\mathrm{\\AA}$, $\\sigma = 0.09$ $\\mathrm{\\AA}$。\n  - 网格：$R$ 从 $1.80$ $\\mathrm{\\AA}$ 到 $2.20$ $\\mathrm{\\AA}$，步长为 $0.001$ $\\mathrm{\\AA}$。\n- 用例3（一致性检查，相同基组）：\n  - 基组A：$A_1 = 0.10$ eV, $A_2 = 0.30$ eV, $k_1 = 0.30$ eV/$\\mathrm{\\AA}$, $k_2 = 0.30$ eV/$\\mathrm{\\AA}$, $V_0 = 0.07$ eV, $R_c = 1.80$ $\\mathrm{\\AA}$, $\\sigma = 0.15$ $\\mathrm{\\AA}$。\n  - 基组B：$A_1 = 0.10$ eV, $A_2 = 0.30$ eV, $k_1 = 0.30$ eV/$\\mathrm{\\AA}$, $k_2 = 0.30$ eV/$\\mathrm{\\AA}$, $V_0 = 0.07$ eV, $R_c = 1.80$ $\\mathrm{\\AA}$, $\\sigma = 0.15$ $\\mathrm{\\AA}$。\n  - 网格：$R$ 从 $1.00$ $\\mathrm{\\AA}$ 到 $2.60$ $\\mathrm{\\AA}$，步长为 $0.02$ $\\mathrm{\\AA}$。\n- 用例4（宽范围扫描，不同交叉位置和宽度）：\n  - 基组A：$A_1 = -0.20$ eV, $A_2 = 0.40$ eV, $k_1 = 0.80$ eV/$\\mathrm{\\AA}$, $k_2 = 0.70$ eV/$\\mathrm{\\AA}$, $V_0 = 0.12$ eV, $R_c = 3.00$ $\\mathrm{\\AA}$, $\\sigma = 0.25$ $\\mathrm{\\AA}$。\n  - 基组B：$A_1 = -0.18$ eV, $A_2 = 0.42$ eV, $k_1 = 0.78$ eV/$\\mathrm{\\AA}$, $k_2 = 0.72$ eV/$\\mathrm{\\AA}$, $V_0 = 0.08$ eV, $R_c = 3.10$ $\\mathrm{\\AA}$, $\\sigma = 0.30$ $\\mathrm{\\AA}$。\n  - 网格：$R$ 从 $0.50$ $\\mathrm{\\AA}$ 到 $5.00$ $\\mathrm{\\AA}$，步长为 $0.05$ $\\mathrm{\\AA}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例一个子列表，每个子列表按 $\\left[\\Delta_{\\max}, \\Delta_{\\mathrm{RMS}}, E^{(A)}_2(R_c), E^{(B)}_2(R_c)\\right]$ 排序。例如：\n\"[[result_case1],[result_case2],[result_case3],[result_case4]]\"。",
            "solution": "该问题要求对一个代表分子-表面相互作用的模型系统中两个电子态之间的非绝热导数耦合 $d_{12}(R)$ 进行定量分析。核心任务是评估该耦合对底层透热电子哈密顿量 $H_{\\mathrm{d}}(R)$ 参数化的敏感性，这种参数化模拟了不同电子结构基组的选择。\n\n其理论框架植根于固定核几何构型 $R$ 下电子的时间无关薛定谔方程。在透热表象中，所选择的电子态相对于 $R$ 具有平滑、缓慢变化的特性，这导致了非对角的哈密顿矩阵。所提供的模型是一个双态系统，由哈密顿量描述：\n$$\nH_{\\mathrm{d}}(R) = \n\\begin{bmatrix}\nH_{11}(R)  H_{12}(R) \\\\\nH_{21}(R)  H_{22}(R)\n\\end{bmatrix} =\n\\begin{bmatrix}\nA_1 + k_1 R  V(R) \\\\\nV(R)  A_2 - k_2 R\n\\end{bmatrix}\n$$\n其中 $H_{11}(R)$ 和 $H_{22}(R)$ 是透热势能，代表在没有相互作用时会发生交叉的两种电子构型。非对角项 $V(R) = V_0 \\exp\\left(-\\frac{(R - R_c)^2}{2 \\sigma^2}\\right)$ 是一个局域化的高斯形耦合，导致透热态之间发生相互作用。\n\n通过求解该哈密顿量在每个核构型 $R$ 下的本征值问题，可以找到绝热电子态 $\\{ \\lvert \\phi_i(R) \\rangle \\}$ 及其对应的势能面 $E_i(R)$：\n$$\nH_{\\mathrm{d}}(R) \\lvert \\phi_j(R) \\rangle = E_j(R) \\lvert \\phi_j(R) \\rangle\n$$\n这个过程称为对角化，它将描述从透热基矢转换到绝热基矢，在绝热基矢中，哈密顿量根据定义是对角的。所得到的绝热能量 $E_1(R)$ 和 $E_2(R)$（按 $E_1(R) \\le E_2(R)$ 排序）构成了在 Born-Oppenheimer 近似下核运动所遵循的势能面。\n\n然而，当绝热势能面彼此接近时，Born-Oppenheimer 近似会失效，这使得包含非绝热耦合变得必要。导数耦合 $d_{ij}(R) = \\langle \\phi_i(R) \\vert \\nabla_R \\phi_j(R) \\rangle$ 量化了绝热态之间的动能耦合强度。大的耦合值表示发生电子跃迁（即“表面跳跃”）的概率很高。对本征矢量 $\\lvert \\phi_j(R) \\rangle$ 进行直接数值微分在数值上是不稳定的，尤其是在简并点附近。Hellmann-Feynman 定理为非简并态 ($E_i \\neq E_j$) 提供了一种稳定而简洁的替代方法：\n$$\nd_{ij}(R) = \\frac{\\langle \\phi_i(R) \\vert \\partial H_{\\mathrm{d}}(R)/\\partial R \\vert \\phi_j(R) \\rangle}{E_j(R) - E_i(R)}\n$$\n该公式将本征矢量的导数与哈密顿算符导数的矩阵元联系起来，后者很容易计算。对于我们的模型，导数哈密顿量为：\n$$\n\\frac{\\partial H_{\\mathrm{d}}(R)}{\\partial R} =\n\\begin{bmatrix}\nk_1  \\frac{\\partial V(R)}{\\partial R} \\\\\n\\frac{\\partial V(R)}{\\partial R}  -k_2\n\\end{bmatrix}\n\\quad \\text{with} \\quad\n\\frac{\\partial V(R)}{\\partial R} = -V_0 \\frac{R - R_c}{\\sigma^2} \\exp\\left(-\\frac{(R - R_c)^2}{2 \\sigma^2}\\right)\n$$\n\n解决该问题的计算步骤如下：\n\n1.  **网格离散化**：根据每个测试用例的规定，在由 $N$ 个点组成的离散网格 $\\{R_n\\}$ 上对连续坐标 $R$ 进行采样。\n\n2.  **哈密顿量构建**：对于每个参数集（“A”和“B”）以及每个网格点 $R_n$，构建矩阵 $H_{\\mathrm{d}}(R_n)$ 和 $\\partial H_{\\mathrm{d}}(R_n)/\\partial R$。这可以通过在整个网格上使用矢量化数值运算来高效执行。\n\n3.  **绝热变换**：对于每个 $R_n$，对哈密顿矩阵 $H_{\\mathrm{d}}(R_n)$ 进行对角化。由于 $H_{\\mathrm{d}}(R)$ 是实对称的，这将产生实数本征值 $E_1(R_n)$、$E_2(R_n)$ 和一组实数、正交归一的本征矢量 $|\\phi_1(R_n)\\rangle$、$|\\phi_2(R_n)\\rangle$。为了计算效率，将每个网格点的一个矩阵堆叠起来，并同时进行对角化。\n\n4.  **导数耦合计算**：使用 Hellmann-Feynman 表达式计算非绝热耦合 $d_{12}(R_n)$。分子 $\\langle \\phi_1_n | \\partial H_{\\mathrm{d},n}/\\partial R | \\phi_2_n \\rangle$ 通过矩阵乘积计算。分母是能隙 $E_2(R_n) - E_1(R_n)$。为防止在交叉点或其附近因能隙过小而引起的数值发散，使用指定的正常数 $\\varepsilon = 10^{-12}$ eV，通过取 $\\max(E_2(R_n) - E_1(R_n), \\varepsilon)$ 对分母进行正则化。\n\n5.  **定量比较**：对得到的导数耦合函数 $d^{(A)}_{12}(R)$ 和 $d^{(B)}_{12}(R)$ 进行比较。在网格上计算最大绝对差 $\\Delta_{\\max}$ 和均方根 (RMS) 差 $\\Delta_{\\mathrm{RMS}}$，以量化因基组参数化变化而引入的总体差异。\n\n6.  **能量分析**：为每个基组计算在透热交叉点处的激发绝热态能量 $E_2(R_c)$。该值很重要，因为 $2V(R_c) = 2V_0$ 代表在透热交叉点的能隙 $E_2(R_c) - E_1(R_c)$，是耦合强度的关键指标。该计算是针对每个基组在其各自的 $R_c$ 处执行的。\n\n通过对每个测试用例执行此程序，我们可以系统地评估底层电子结构模型中的变化如何传播到控制反应动力学的非绝热耦合中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _calculate_quantities(params, R_grid):\n    \"\"\"\n    Computes the derivative coupling d12(R) over a grid and the\n    excited-state energy E2(Rc) for a given parameter set.\n    \"\"\"\n    epsilon = 1e-12\n    A1 = params[\"A1\"]\n    A2 = params[\"A2\"]\n    k1 = params[\"k1\"]\n    k2 = params[\"k2\"]\n    V0 = params[\"V0\"]\n    Rc = params[\"Rc\"]\n    sigma = params[\"sigma\"]\n\n    # --- Vectorized calculation over the grid ---\n    R = R_grid\n    \n    # Calculate off-diagonal term and its derivative\n    exp_arg = -(R - Rc)**2 / (2 * sigma**2)\n    exp_term = np.exp(exp_arg)\n    V_R = V0 * exp_term\n    dV_dR = V_R * (-(R - Rc) / sigma**2)\n\n    # Construct stacks of Hamiltonian and derivative Hamiltonian matrices\n    H11 = A1 + k1 * R\n    H22 = A2 - k2 * R\n    \n    # Stack of Hamiltonians, shape (N, 2, 2)\n    Hd_stack = np.zeros((R.shape[0], 2, 2))\n    Hd_stack[:, 0, 0] = H11\n    Hd_stack[:, 1, 1] = H22\n    Hd_stack[:, 0, 1] = V_R\n    Hd_stack[:, 1, 0] = V_R\n    \n    # Stack of derivative Hamiltonians\n    dHd_dR_stack = np.zeros((R.shape[0], 2, 2))\n    dHd_dR_stack[:, 0, 0] = k1\n    dHd_dR_stack[:, 1, 1] = -k2\n    dHd_dR_stack[:, 0, 1] = dV_dR\n    dHd_dR_stack[:, 1, 0] = dV_dR\n\n    # Diagonalize all matrices in the stack at once\n    eivals_stack, eivecs_stack = np.linalg.eigh(Hd_stack)\n    \n    E1 = eivals_stack[:, 0]\n    E2 = eivals_stack[:, 1]\n    phi1 = eivecs_stack[:, :, 0]\n    phi2 = eivecs_stack[:, :, 1]\n    \n    # Calculate derivative coupling using Hellmann-Feynman theorem\n    energy_gap = E2 - E1\n    denominator = np.maximum(energy_gap, epsilon)\n    \n    # Numerator via batched matrix-vector products using einsum\n    numerator = np.einsum('ni,nij,nj-n', phi1, dHd_dR_stack, phi2)\n    \n    d12_values = numerator / denominator\n\n    # --- Scalar calculation for E2 at the specific Rc for this basis ---\n    R_c_val = Rc\n    V_at_Rc = V0  # exp term is 1 at R = Rc\n    \n    H11_rc = A1 + k1 * R_c_val\n    H22_rc = A2 - k2 * R_c_val\n    \n    Hd_rc = np.array([[H11_rc, V_at_Rc], [V_at_Rc, H22_rc]])\n    eivals_rc, _ = np.linalg.eigh(Hd_rc)\n    E2_at_Rc = eivals_rc[1]\n    \n    return d12_values, E2_at_Rc\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"A\": {\"A1\": 0.0, \"A2\": 0.20, \"k1\": 0.50, \"k2\": 0.40, \"V0\": 0.15, \"Rc\": 2.20, \"sigma\": 0.12},\n            \"B\": {\"A1\": 0.0, \"A2\": 0.22, \"k1\": 0.50, \"k2\": 0.45, \"V0\": 0.10, \"Rc\": 2.20, \"sigma\": 0.12},\n            \"grid\": {\"start\": 1.50, \"stop\": 3.00, \"step\": 0.01}\n        },\n        # Case 2\n        {\n            \"A\": {\"A1\": -0.05, \"A2\": 0.25, \"k1\": 0.60, \"k2\": 0.60, \"V0\": 0.02, \"Rc\": 2.00, \"sigma\": 0.08},\n            \"B\": {\"A1\": -0.04, \"A2\": 0.23, \"k1\": 0.58, \"k2\": 0.62, \"V0\": 0.05, \"Rc\": 2.00, \"sigma\": 0.09},\n            \"grid\": {\"start\": 1.80, \"stop\": 2.20, \"step\": 0.001}\n        },\n        # Case 3\n        {\n            \"A\": {\"A1\": 0.10, \"A2\": 0.30, \"k1\": 0.30, \"k2\": 0.30, \"V0\": 0.07, \"Rc\": 1.80, \"sigma\": 0.15},\n            \"B\": {\"A1\": 0.10, \"A2\": 0.30, \"k1\": 0.30, \"k2\": 0.30, \"V0\": 0.07, \"Rc\": 1.80, \"sigma\": 0.15},\n            \"grid\": {\"start\": 1.00, \"stop\": 2.60, \"step\": 0.02}\n        },\n        # Case 4\n        {\n            \"A\": {\"A1\": -0.20, \"A2\": 0.40, \"k1\": 0.80, \"k2\": 0.70, \"V0\": 0.12, \"Rc\": 3.00, \"sigma\": 0.25},\n            \"B\": {\"A1\": -0.18, \"A2\": 0.42, \"k1\": 0.78, \"k2\": 0.72, \"V0\": 0.08, \"Rc\": 3.10, \"sigma\": 0.30},\n            \"grid\": {\"start\": 0.50, \"stop\": 5.00, \"step\": 0.05}\n        }\n    ]\n\n    results = []\n    for case_data in test_cases:\n        params_A = case_data[\"A\"]\n        params_B = case_data[\"B\"]\n        grid_params = case_data[\"grid\"]\n\n        # Generate a robust grid using linspace\n        num_points = int(round((grid_params[\"stop\"] - grid_params[\"start\"]) / grid_params[\"step\"])) + 1\n        R_grid = np.linspace(grid_params[\"start\"], grid_params[\"stop\"], num_points)\n\n        # Calculate quantities for basis-set A\n        d12_A, E2_A_at_Rc = _calculate_quantities(params_A, R_grid)\n\n        # Calculate quantities for basis-set B\n        d12_B, E2_B_at_Rc = _calculate_quantities(params_B, R_grid)\n\n        # Compute the difference metrics\n        diff_d12 = d12_A - d12_B\n        delta_max = np.max(np.abs(diff_d12))\n        delta_rms = np.sqrt(np.mean(diff_d12**2))\n\n        # Collect the results for the current case\n        case_result = [delta_max, delta_rms, E2_A_at_Rc, E2_B_at_Rc]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # Convert list of lists to string and remove spaces for compact representation.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "虽然模拟单条轨迹富有洞察力，但化学工程师通常更关心宏观量，例如反应速率和产物分支比。这最后一项实践将非绝热跃迁的微观世界与化学动力学的统计框架联系起来。通过为相互竞争的反应通道实现 Marcus 理论，我们将看到重组能（$\\lambda$）和驱动力（$\\Delta G$）等基本参数如何控制一个反应（例如质子耦合电子转移，PCET）的整体速率和最终产物选择性。",
            "id": "3892330",
            "problem": "您将实现一个程序，用于在与最少开关表面跳跃 (FSSH) 相关的非绝热弱耦合区域内，量化质子耦合电子转移 (PCET) 的跳跃概率和通道分支比如何依赖于重组能和驱动力。将环境建模为经典谐振溶剂坐标，并在 Fermi 黄金定则极限下处理跃迁。仅从基本原理出发：Fermi 黄金定则、溶剂坐标的经典高温极限以及用于事件发生的泊松过程定义。请勿引入任何额外的唯象拟合因子。\n\n您可以使用的基本原理：\n- Fermi 黄金定则，描述了透热态之间具有电子-振动耦合 $V$ 和接受态密度 $\\rho(E)$ 的非绝热跃迁速率 $k$，即 $k \\propto |V|^{2} \\rho(E)$。\n- 谐振反应坐标的经典高温极限，其重组能为 $\\lambda$，自由能驱动力为 $\\Delta G$，这会产生一个高斯分布的能隙。\n- 泊松过程关系，描述了在时间步长 $\\Delta t$ 内，从一个恒定速率 $k$ 观察到跃迁的概率：$p(\\Delta t) = 1 - \\exp(-k \\Delta t)$。\n\n精确定义您使用的所有符号。仅使用以下国际单位制 (SI) 的物理常数，并在需要时将所有能量转换为焦耳：\n- 玻尔兹曼常数 $k_{\\mathrm B} = 1.380\\,649 \\times 10^{-23}\\ \\mathrm{J/K}$。\n- 约化普朗克常数 $\\hbar = 1.054\\,571\\,817 \\times 10^{-34}\\ \\mathrm{J \\cdot s}$。\n- 电子伏特到焦耳的转换 $1\\ \\mathrm{eV} = 1.602\\,176\\,634 \\times 10^{-19}\\ \\mathrm{J}$。\n\n假设与范围：\n- 考虑从同一反应物透热态出发的两个竞争性 PCET 产物通道，标记为 $A$ 和 $B$。\n- 每个通道都由一个重组能 $\\lambda$（单位 $\\mathrm{eV}$）和一个驱动力 $\\Delta G$（单位 $\\mathrm{eV}$）来表征。\n- 在给定的测试案例中，两个通道的有效振动耦合 $V$（单位 $\\mathrm{meV}$）是相同的。\n- 溶剂是经典的，温度为 $T$（单位 $\\mathrm{K}$）。\n- 您将使用固定的时间步长 $\\Delta t$（单位 $\\mathrm{fs}$）对动力学进行离散化，并通过泊松过程近似将非绝热速率常数映射到类 FSSH 的跳跃概率。\n- 您必须将概率表示为纯小数，而不是百分比。\n\n每个测试案例的任务：\n1. 基于上述原理，推导、实现并使用一个非绝热黄金定则 PCET 速率 $k(\\lambda,\\Delta G,V,T)$，其中经典溶剂坐标作谐振处理。您必须确保量纲一致性，使 $k$ 的单位为 $\\mathrm{s}^{-1}$。\n2. 将每个通道的速率转换为每个时间步长的跳跃概率 $p(\\Delta t) = 1 - \\exp(-k \\Delta t)$，其中 $\\Delta t$ 需转换为秒。\n3. 计算通道 $A$ 的分支比 $\\mathrm{BR}_A = k_A/(k_A + k_B)$ 和通道 $B$ 的分支比 $\\mathrm{BR}_B = 1 - \\mathrm{BR}_A$。\n4. 对于每个测试案例，报告列表 $[p_A, p_B, \\mathrm{BR}_A, \\mathrm{BR}_B]$。\n\n物理单位：\n- $\\lambda$ 和 $\\Delta G$ 以 $\\mathrm{eV}$ 为单位提供，在任何计算中都必须内部转换为 $\\mathrm{J}$。\n- $V$ 以 $\\mathrm{meV}$ 为单位提供，必须先转换为 $\\mathrm{eV}$，然后再转换为 $\\mathrm{J}$。\n- $T$ 的单位是 $\\mathrm{K}$。\n- $\\Delta t$ 以 $\\mathrm{fs}$ 为单位提供，必须转换为 $\\mathrm{s}$。\n- 概率和分支比是无量纲的。将最终数值结果四舍五入到八位小数。\n\n测试套件：\n为以下五个测试案例提供结果。对于每一行，元组的含义是 $(\\lambda_A\\ \\mathrm{eV}, \\Delta G_A\\ \\mathrm{eV}, \\lambda_B\\ \\mathrm{eV}, \\Delta G_B\\ \\mathrm{eV}, V\\ \\mathrm{meV}, T\\ \\mathrm{K}, \\Delta t\\ \\mathrm{fs})$。\n- 案例 1：$(0.6, -0.2, 0.8, -0.5, 10.0, 300.0, 0.5)$\n- 案例 2：$(0.5, -0.5, 0.5, -0.1, 10.0, 300.0, 0.5)$\n- 案例 3：$(0.6, -1.2, 0.6, -0.2, 10.0, 300.0, 0.5)$\n- 案例 4：$(0.1, -0.1, 1.0, -0.5, 5.0, 300.0, 1.0)$\n- 案例 5：$(0.4, +0.2, 0.4, -0.4, 10.0, 300.0, 0.5)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表形式的结果，每个内部列表对应一个测试案例并按上述顺序排列。例如，打印的行必须如下所示：\n$[\\,[p_A^{(1)},p_B^{(1)},\\mathrm{BR}_A^{(1)},\\mathrm{BR}_B^{(1)}],\\,[p_A^{(2)},p_B^{(2)},\\mathrm{BR}_A^{(2)},\\mathrm{BR}_B^{(2)}],\\ldots\\,]$\n每个数字都四舍五入到八位小数。",
            "solution": "该问题要求实现一个程序来计算竞争性质子耦合电子转移 (PCET) 通道的非绝热跃迁概率和分支比。解决方案必须根据指定的基本原理推导得出：Fermi 黄金定则、溶剂的经典谐振模型以及泊松过程的性质。\n\n首先，我将推导两个电子态之间跃迁的非绝热速率常数 $k$ 的表达式。所提供的基础是 Fermi 黄金定则，该定则指出速率与电子耦合的平方和态密度成正比。在溶剂中电子转移的背景下，这表示为：\n$$ k = \\frac{2\\pi}{\\hbar} |V|^2 (\\text{FCWD}) $$\n其中 $k$ 是速率常数，单位为 $\\mathrm{s}^{-1}$；$\\hbar$ 是约化普朗克常数，单位为 $\\mathrm{J \\cdot s}$；$V$ 是初始和最终透热态之间的电子耦合，单位为 $\\mathrm{J}$；而 $\\text{FCWD}$ 是 Franck-Condon 加权态密度，它解释了跃迁的原子核部分，单位为 $\\mathrm{J}^{-1}$。\n\n问题指定溶剂环境应在高温极限下建模为经典谐振坐标。这是 Marcus 理论的基石。在此模型中，反应物 ($U_R$) 和产物 ($U_P$) 的势能面表示为集体溶剂坐标的函数，其形状为抛物线。跃迁是由该坐标的热涨落驱动的。该理论将 $\\text{FCWD}$ 与两个关键的热力学参数联系起来：重组能 $\\lambda$ 和自由能驱动力 $\\Delta G$。\n\n重组能 $\\lambda$ 是在不发生电子转移的情况下，使系统从反应物的平衡核构型畸变到产物的平衡核构型所需的能量成本。驱动力 $\\Delta G$ 是反应的自由能变化。\n\n对于温度为 $T$ 的经典体系，一次热涨落提供活化能 $\\Delta G^\\ddagger$ 的概率与玻尔兹曼因子 $\\exp(-\\Delta G^\\ddagger / (k_{\\mathrm B} T))$ 成正比，其中 $k_{\\mathrm B}$ 是玻尔兹曼常数。在 Marcus 理论中，电子转移过程的活化自由能由下式给出：\n$$ \\Delta G^\\ddagger = \\frac{(\\lambda + \\Delta G)^2}{4\\lambda} $$\n该表达式是通过寻找反应物和产物势能面之间的交叉点的能量得出的。\n\n经典高温极限下的 $\\text{FCWD}$ 是通过考虑由溶剂坐标的热涨落引起的两个电子态之间垂直能隙的高斯概率分布推导出来的。$\\text{FCWD}$ 的最终表达式为：\n$$ \\text{FCWD} = \\frac{1}{\\sqrt{4\\pi\\lambda k_{\\mathrm B} T}} \\exp\\left(-\\frac{\\Delta G^\\ddagger}{k_{\\mathrm B} T}\\right) = \\frac{1}{\\sqrt{4\\pi\\lambda k_{\\mathrm B} T}} \\exp\\left(-\\frac{(\\lambda + \\Delta G)^2}{4\\lambda k_{\\mathrm B} T}\\right) $$\n将此代入 Fermi 黄金定则，得到非绝热电子转移的 Marcus 速率方程：\n$$ k(\\lambda, \\Delta G, V, T) = \\frac{2\\pi}{\\hbar} |V|^2 \\frac{1}{\\sqrt{4\\pi\\lambda k_{\\mathrm B} T}} \\exp\\left(-\\frac{(\\lambda + \\Delta G)^2}{4\\lambda k_{\\mathrm B} T}\\right) $$\n简化指前因子，我们得到将要实现的形式：\n$$ k = \\frac{|V|^2}{\\hbar} \\sqrt{\\frac{\\pi}{\\lambda k_{\\mathrm B} T}} \\exp\\left(-\\frac{(\\lambda + \\Delta G)^2}{4\\lambda k_{\\mathrm B} T}\\right) $$\n对于每个测试案例，我们有两个竞争通道 $A$ 和 $B$，每个通道都有其自己的速率常数 $k_A$ 和 $k_B$，分别使用参数 $(\\lambda_A, \\Delta G_A)$ 和 $(\\lambda_B, \\Delta G_B)$ 计算，并使用相同的耦合 $V$ 和温度 $T$。所有具有能量单位的输入参数（$\\lambda, \\Delta G, V$）将被转换为焦耳，时间（$\\Delta t$）将被转换为秒，以确保量纲一致性，从而得到单位为 $\\mathrm{s}^{-1}$ 的速率 $k$。\n\n其次，问题要求将这些速率映射到离散时间步长 $\\Delta t$ 内的跳跃概率。这通过将跃迁建模为泊松过程来实现。对于一个恒定速率 $k$，在持续时间 $\\Delta t$ 内观察到至少一个事件的概率 $p$ 由下式给出：\n$$ p(\\Delta t) = 1 - \\exp(-k \\Delta t) $$\n此公式应用于每个通道以求得跳跃概率 $p_A$ 和 $p_B$。对于表面跳跃模拟中典型的较小的 $k \\Delta t$ 值，有 $p(\\Delta t) \\approx k \\Delta t$。\n\n第三，必须计算每个通道的分支比。分支比反映了反应通过特定通道进行的相对概率。它由该通道的速率与所有竞争通道的总速率之比给出。对于通道 $A$ 和 $B$：\n$$ \\mathrm{BR}_A = \\frac{k_A}{k_A + k_B} $$\n$$ \\mathrm{BR}_B = \\frac{k_B}{k_A + k_B} = 1 - \\mathrm{BR}_A $$\n\n最终算法如下：\n1.  定义所需的物理常数（$k_{\\mathrm B}$、$\\hbar$、eV 到 J 的转换因子）。\n2.  对于每个测试案例 $(\\lambda_A, \\Delta G_A, \\lambda_B, \\Delta G_B, V, T, \\Delta t)$：\n    a. 将所有输入参数转换为国际单位制基本单位（J, K, s）。\n    b. 使用通道 $A$ 的参数和 Marcus 方程计算速率 $k_A$。\n    c. 使用通道 $B$ 的参数和 Marcus 方程计算速率 $k_B$。\n    d. 计算跳跃概率 $p_A = 1 - \\exp(-k_A \\Delta t)$。\n    e. 计算跳跃概率 $p_B = 1 - \\exp(-k_B \\Delta t)$。\n    f. 计算分支比 $\\mathrm{BR}_A = k_A / (k_A + k_B)$ 和 $\\mathrm{BR}_B = k_B / (k_A + k_B)$。\n    g. 存储四个结果值 $[p_A, p_B, \\mathrm{BR}_A, \\mathrm{BR}_B]$，四舍五入到八位小数。\n3.  将所有测试案例的结果集合格式化为指定的列表的列表的字符串表示形式。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates PCET hop probabilities and branching ratios based on Marcus theory.\n    \"\"\"\n    # Physical constants in SI units\n    K_B = 1.380649e-23  # Boltzmann constant in J/K\n    H_BAR = 1.054571817e-34  # Reduced Planck constant in J*s\n    EV_TO_J = 1.602176634e-19  # Electron-volt to Joule conversion\n\n    # Test suite parameters:\n    # (lambda_A_eV, delta_G_A_eV, lambda_B_eV, delta_G_B_eV, V_meV, T_K, dt_fs)\n    test_cases = [\n        (0.6, -0.2, 0.8, -0.5, 10.0, 300.0, 0.5),\n        (0.5, -0.5, 0.5, -0.1, 10.0, 300.0, 0.5),\n        (0.6, -1.2, 0.6, -0.2, 10.0, 300.0, 0.5),\n        (0.1, -0.1, 1.0, -0.5, 5.0, 300.0, 1.0),\n        (0.4, +0.2, 0.4, -0.4, 10.0, 300.0, 0.5),\n    ]\n\n    def calculate_rate(lambda_ev, delta_g_ev, v_mev, t_k):\n        \"\"\"\n        Calculates the non-adiabatic rate constant using Marcus theory.\n        \n        Args:\n            lambda_ev (float): Reorganization energy in eV.\n            delta_g_ev (float): Driving force in eV.\n            v_mev (float): Electronic coupling in meV.\n            t_k (float): Temperature in Kelvin.\n            \n        Returns:\n            float: Rate constant k in s^-1.\n        \"\"\"\n        # Convert inputs to SI units\n        lambda_j = lambda_ev * EV_TO_J\n        delta_g_j = delta_g_ev * EV_TO_J\n        v_j = v_mev * 1e-3 * EV_TO_J\n        \n        # Avoid division by zero if lambda is zero\n        if lambda_j == 0:\n            return 0.0\n\n        # Thermal energy\n        kbt = K_B * t_k\n        \n        # Prefactor term of the Marcus equation\n        prefactor_arg = np.pi / (lambda_j * kbt)\n        prefactor = (v_j**2 / H_BAR) * np.sqrt(prefactor_arg)\n        \n        # Exponential term (activation energy)\n        # Note: (lambda + delta_G)^2 is the same as (-lambda - delta_G)^2\n        # However, the formulation in terms of activation energy is G_act = (lambda + delta_G)^2 / (4*lambda)\n        # and the exponential is exp(-G_act / kBT)\n        activation_energy_j = (lambda_j + delta_g_j)**2 / (4 * lambda_j)\n        exponent = -activation_energy_j / kbt\n        \n        rate = prefactor * np.exp(exponent)\n        return rate\n\n    def calculate_hop_prob(k, dt_fs):\n        \"\"\"\n        Calculates the FSSH-like hop probability from a rate constant.\n        \n        Args:\n            k (float): Rate constant in s^-1.\n            dt_fs (float): Time step in femtoseconds.\n            \n        Returns:\n            float: Dimensionless hop probability.\n        \"\"\"\n        dt_s = dt_fs * 1e-15  # Convert fs to s\n        prob = 1.0 - np.exp(-k * dt_s)\n        return prob\n\n    all_results = []\n    for case in test_cases:\n        lambda_a_ev, delta_g_a_ev, lambda_b_ev, delta_g_b_ev, v_mev, t_k, dt_fs = case\n\n        # Calculate rates for both channels\n        k_a = calculate_rate(lambda_a_ev, delta_g_a_ev, v_mev, t_k)\n        k_b = calculate_rate(lambda_b_ev, delta_g_b_ev, v_mev, t_k)\n        \n        # Calculate hop probabilities\n        p_a = calculate_hop_prob(k_a, dt_fs)\n        p_b = calculate_hop_prob(k_b, dt_fs)\n        \n        # Calculate branching ratios\n        total_rate = k_a + k_b\n        br_a = k_a / total_rate if total_rate > 0 else 0.0\n        br_b = k_b / total_rate if total_rate > 0 else 0.0\n        \n        case_results = [p_a, p_b, br_a, br_b]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists.\n    # Each number is formatted to 8 decimal places.\n    formatted_lists = []\n    for res_list in all_results:\n        inner_list_str = f\"[{','.join([f'{num:.8f}' for num in res_list])}]\"\n        formatted_lists.append(inner_list_str)\n    \n    final_output_str = f\"[{','.join(formatted_lists)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}