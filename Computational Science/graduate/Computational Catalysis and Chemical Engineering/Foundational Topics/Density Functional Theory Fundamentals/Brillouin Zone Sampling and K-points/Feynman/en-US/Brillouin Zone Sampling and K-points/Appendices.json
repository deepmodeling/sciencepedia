{
    "hands_on_practices": [
        {
            "introduction": "The first practical decision in any periodic electronic structure calculation is selecting the k-point grid. This choice is not arbitrary; it is fundamentally linked to the dimensions of the real-space unit cell, as larger cells in real space correspond to smaller Brillouin zones requiring less dense sampling. This exercise  guides you through deriving a protocol to determine the appropriate Monkhorst-Pack grid dimensions based on a target resolution in reciprocal space, a foundational skill for setting up well-converged calculations.",
            "id": "3870659",
            "problem": "In periodic electronic-structure modeling for catalytic materials within computational catalysis and chemical engineering, Brillouin Zone (BZ) sampling is performed on a grid of wave vectors, often using a Gamma-centered Monkhorst-Pack (MP) mesh. Consider a crystalline slab used to model a close-packed catalytic surface, described by three direct lattice vectors $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{c}$ with lengths $a$, $b$, and $c$ and interaxial angles $\\alpha$ (between $\\mathbf{b}$ and $\\mathbf{c}$), $\\beta$ (between $\\mathbf{a}$ and $\\mathbf{c}$), and $\\gamma$ (between $\\mathbf{a}$ and $\\mathbf{b}$). The reciprocal lattice vectors are defined by the standard crystallographic convention $\\mathbf{b}_1 = 2\\pi \\, \\frac{\\mathbf{b} \\times \\mathbf{c}}{V}$, $\\mathbf{b}_2 = 2\\pi \\, \\frac{\\mathbf{c} \\times \\mathbf{a}}{V}$, and $\\mathbf{b}_3 = 2\\pi \\, \\frac{\\mathbf{a} \\times \\mathbf{b}}{V}$, where $V$ is the volume of the direct lattice unit cell.\n\nStarting from these definitions and the geometry of the direct lattice, propose a logically justified protocol to choose the integer grid sizes $(N_x, N_y, N_z)$ for a Gamma-centered Monkhorst-Pack mesh to achieve a target maximum reciprocal-space resolution $\\Delta k$ along each reciprocal primitive direction. Derive a general mapping from a given target $\\Delta k$ to the integers $(N_x, N_y, N_z)$ that guarantees the spacing between adjacent sampled $\\mathbf{k}$-points along each reciprocal basis direction is less than or equal to $\\Delta k$, while preserving Gamma centering. Your protocol must enforce the smallest odd integers that satisfy the resolution target and must guarantee at least one division along each direction.\n\nThen apply your derived mapping to the following hexagonal slab geometry that is commonly used to represent a close-packed catalyst surface:\n- $a = 2.500$ $\\mathrm{\\AA}$, $b = 2.500$ $\\mathrm{\\AA}$, $c = 15.000$ $\\mathrm{\\AA}$.\n- $\\alpha = 90^\\circ$, $\\beta = 90^\\circ$, $\\gamma = 120^\\circ$.\n- Target resolution $\\Delta k = 0.200$ $\\mathrm{\\AA}^{-1}$.\nAngles are given in degrees. Express the final grid sizes $(N_x, N_y, N_z)$ as integers, using the minimal odd-integer choice consistent with your protocol. The final answer must be a single row matrix containing the three integers, with no units in the final boxed expression.",
            "solution": "The problem is first validated against the principles of scientific correctness, logical consistency, and completeness.\n\n### Problem Validation\n**Step 1: Extract Givens**\n- **Direct Lattice:** Vectors $\\mathbf{a}$, $\\mathbf{b}$, $\\mathbf{c}$ with lengths $a$, $b$, $c$ and interaxial angles $\\alpha$, $\\beta$, $\\gamma$.\n- **Reciprocal Lattice Vectors:** $\\mathbf{b}_1 = 2\\pi \\, \\frac{\\mathbf{b} \\times \\mathbf{c}}{V}$, $\\mathbf{b}_2 = 2\\pi \\, \\frac{\\mathbf{c} \\times \\mathbf{a}}{V}$, and $\\mathbf{b}_3 = 2\\pi \\, \\frac{\\mathbf{a} \\times \\mathbf{b}}{V}$, where $V = \\mathbf{a} \\cdot (\\mathbf{b} \\times \\mathbf{c})$ is the direct cell volume.\n- **Sampling Scheme:** Gamma-centered Monkhorst-Pack (MP) mesh with integer grid sizes $(N_x, N_y, N_z)$.\n- **Resolution Constraint:** The spacing between adjacent sampled $\\mathbf{k}$-points along each reciprocal basis direction must be less than or equal to a target resolution $\\Delta k$.\n- **Integer Choice Protocol:** The integers $(N_x, N_y, N_z)$ must be the smallest odd integers that satisfy the resolution target and must be at least $1$.\n- **Specific Geometry:** A hexagonal slab with $a = 2.500$ $\\mathrm{\\AA}$, $b = 2.500$ $\\mathrm{\\AA}$, $c = 15.000$ $\\mathrm{\\AA}$, $\\alpha = 90^\\circ$, $\\beta = 90^\\circ$, and $\\gamma = 120^\\circ$.\n- **Specific Target Resolution:** $\\Delta k = 0.200$ $\\mathrm{\\AA}^{-1}$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is well-defined and scientifically sound.\n- **Scientifically Grounded:** The definitions of direct and reciprocal lattices, unit cell volume, and the concept of Brillouin zone sampling with a Monkhorst-Pack mesh are fundamental principles in solid-state physics and computational materials science. The provided numerical values for the lattice are physically plausible for a surface slab model.\n- **Well-Posed:** The problem provides all necessary definitions, constraints, and data to derive a unique solution. The requirements for the grid sizes $(N_x, N_y, N_z)$ are specified unambiguously (smallest odd integers satisfying a clear inequality).\n- **Objective:** The language is precise and quantitative. There are no subjective or opinion-based statements.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. A complete, reasoned solution will be provided.\n\n### Solution\nThe solution is developed in two parts. First, a general protocol for determining the Monkhorst-Pack grid dimensions is derived. Second, this protocol is applied to the specific hexagonal slab geometry provided.\n\n**Part 1: Derivation of the General Protocol**\nA Monkhorst-Pack grid is a uniform mesh of $\\mathbf{k}$-points sampling the Brillouin zone. For a grid with $N_x$, $N_y$, and $N_z$ divisions along the reciprocal lattice vector directions $\\mathbf{b}_1$, $\\mathbf{b}_2$, and $\\mathbf{b}_3$, respectively, the set of sampled $\\mathbf{k}$-points is generated by linear combinations of fractional coordinates along these vectors.\n\nThe spacing between adjacent $\\mathbf{k}$-points along the direction of the reciprocal vector $\\mathbf{b}_1$ is the magnitude of the vector $\\frac{1}{N_x}\\mathbf{b}_1$, which is $\\frac{|\\mathbf{b}_1|}{N_x}$. Let the magnitudes of the reciprocal lattice vectors be $b_1 = |\\mathbf{b}_1|$, $b_2 = |\\mathbf{b}_2|$, and $b_3 = |\\mathbf{b}_3|$. The spacings are thus $\\frac{b_1}{N_x}$, $\\frac{b_2}{N_y}$, and $\\frac{b_3}{N_z}$.\n\nThe problem requires that this spacing be no greater than a target resolution, $\\Delta k$. This gives rise to a set of inequalities for the integer grid sizes $N_x, N_y, N_z$:\n$$\n\\frac{b_1}{N_x} \\le \\Delta k \\implies N_x \\ge \\frac{b_1}{\\Delta k}\n$$\n$$\n\\frac{b_2}{N_y} \\le \\Delta k \\implies N_y \\ge \\frac{b_2}{\\Delta k}\n$$\n$$\n\\frac{b_3}{N_z} \\le \\Delta k \\implies N_z \\ge \\frac{b_3}{\\Delta k}\n$$\nThe problem further mandates that $N_x$, $N_y$, and $N_z$ must be the smallest positive odd integers that satisfy these conditions. The condition of being a positive integer guarantees at least one division.\n\nThe protocol to determine each integer $N_i$ (for $i \\in \\{x,y,z\\}$) is as follows:\n1.  Calculate the minimum required value, $R_i = \\frac{b_i}{\\Delta k}$.\n2.  Find the smallest integer that is greater than or equal to $R_i$. This is calculated using the ceiling function, $M_i = \\lceil R_i \\rceil$.\n3.  If $M_i$ is an odd number, then $N_i = M_i$.\n4.  If $M_i$ is an even number, the next odd integer must be chosen, so $N_i = M_i + 1$.\n\nThis protocol ensures all constraints are met.\n\n**Part 2: Application to the Hexagonal Slab Geometry**\nFirst, we must calculate the magnitudes of the reciprocal lattice vectors ($b_1, b_2, b_3$) from the given direct lattice parameters: $a = 2.500$ $\\mathrm{\\AA}$, $b = 2.500$ $\\mathrm{\\AA}$, $c = 15.000$ $\\mathrm{\\AA}$, $\\alpha = 90^\\circ$, $\\beta = 90^\\circ$, and $\\gamma = 120^\\circ$.\n\nThe volume of the direct lattice unit cell, $V$, is given by the formula:\n$$\nV = abc \\sqrt{1 - \\cos^2\\alpha - \\cos^2\\beta - \\cos^2\\gamma + 2\\cos\\alpha\\cos\\beta\\cos\\gamma}\n$$\nSubstituting the given angles, $\\cos(90^\\circ) = 0$ and $\\cos(120^\\circ) = -1/2$:\n$$\nV = (2.5)(2.5)(15.0) \\sqrt{1 - 0 - 0 - \\left(-\\frac{1}{2}\\right)^2 + 2(0)(0)\\left(-\\frac{1}{2}\\right)} = 93.75 \\sqrt{1 - \\frac{1}{4}} = 93.75 \\frac{\\sqrt{3}}{2} \\text{ } \\mathrm{\\AA}^3\n$$\nFor these specific angles where $\\alpha=\\beta=90^\\circ$, the volume formula simplifies to $V = abc\\sin\\gamma$.\n\nThe magnitudes of the reciprocal lattice vectors are given by:\n$$\nb_1 = |\\mathbf{b}_1| = \\frac{2\\pi}{V} |\\mathbf{b} \\times \\mathbf{c}| = \\frac{2\\pi bc \\sin\\alpha}{V}\n$$\n$$\nb_2 = |\\mathbf{b}_2| = \\frac{2\\pi}{V} |\\mathbf{c} \\times \\mathbf{a}| = \\frac{2\\pi ca \\sin\\beta}{V}\n$$\n$$\nb_3 = |\\mathbf{b}_3| = \\frac{2\\pi}{V} |\\mathbf{a} \\times \\mathbf{b}| = \\frac{2\\pi ab \\sin\\gamma}{V}\n$$\nSubstituting $V = abc\\sin\\gamma$ and the given angles:\n$$\nb_1 = \\frac{2\\pi bc \\sin(90^\\circ)}{abc\\sin(120^\\circ)} = \\frac{2\\pi (1)}{a\\sin(120^\\circ)} = \\frac{2\\pi}{(2.5)(\\sqrt{3}/2)} = \\frac{4\\pi}{2.5\\sqrt{3}} = \\frac{8\\pi}{5\\sqrt{3}} = \\frac{8\\pi\\sqrt{3}}{15} \\text{ } \\mathrm{\\AA}^{-1}\n$$\nSince $a=b$ and $\\alpha=\\beta$, the magnitude $b_2$ is identical to $b_1$:\n$$\nb_2 = \\frac{2\\pi ca \\sin(90^\\circ)}{abc\\sin(120^\\circ)} = \\frac{2\\pi (1)}{b\\sin(120^\\circ)} = \\frac{8\\pi\\sqrt{3}}{15} \\text{ } \\mathrm{\\AA}^{-1}\n$$\nFor $b_3$:\n$$\nb_3 = \\frac{2\\pi ab \\sin(120^\\circ)}{abc\\sin(120^\\circ)} = \\frac{2\\pi}{c} = \\frac{2\\pi}{15} \\text{ } \\mathrm{\\AA}^{-1}\n$$\nNow we apply the derived protocol with the target resolution $\\Delta k = 0.200 = 1/5$ $\\mathrm{\\AA}^{-1}$.\n\nFor $N_x$:\n$$\nR_x = \\frac{b_1}{\\Delta k} = \\frac{8\\pi\\sqrt{3}/15}{1/5} = \\frac{8\\pi\\sqrt{3}}{3} \\approx 14.51\n$$\nThe smallest integer greater than or equal to $14.51$ is $M_x = \\lceil 14.51 \\rceil = 15$. Since $15$ is an odd number, we set $N_x = 15$.\n\nFor $N_y$:\n$$\nR_y = \\frac{b_2}{\\Delta k} = \\frac{8\\pi\\sqrt{3}/15}{1/5} = \\frac{8\\pi\\sqrt{3}}{3} \\approx 14.51\n$$\nThe smallest integer greater than or equal to $14.51$ is $M_y = \\lceil 14.51 \\rceil = 15$. Since $15$ is an odd number, we set $N_y = 15$.\n\nFor $N_z$:\n$$\nR_z = \\frac{b_3}{\\Delta k} = \\frac{2\\pi/15}{1/5} = \\frac{2\\pi}{3} \\approx 2.094\n$$\nThe smallest integer greater than or equal to $2.094$ is $M_z = \\lceil 2.094 \\rceil = 3$. Since $3$ is an odd number, we set $N_z = 3$.\n\nThe resulting Monkhorst-Pack grid size is $(N_x, N_y, N_z) = (15, 15, 3)$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n15 & 15 & 3\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Plotting band structures along high-symmetry lines is a standard procedure for visualizing the electronic properties of a material. However, this common practice implicitly assumes that the most important features, such as band extrema, lie on these one-dimensional paths. This hands-on exercise  challenges that assumption by demonstrating how band minima or maxima can easily reside in lower-symmetry regions of the Brillouin zone, a critical consideration for accurately predicting electronic properties like band gaps.",
            "id": "3870639",
            "problem": "Consider a two-dimensional crystalline catalyst modeled by a square Bravais lattice with real-space lattice constant $a$ and reciprocal lattice vectors of magnitude $2\\pi/a$ in each Cartesian direction. By Bloch's theorem, single-electron band energies can be expressed as functions $E_n(\\mathbf{k})$ that are periodic in wavevector $\\mathbf{k}$ over the Brillouin zone. In computational catalysis and chemical engineering, sampling the Brillouin zone along high-symmetry lines is a common practice in band structure calculations. However, optimizing $E_n(\\mathbf{k})$ only along a prescribed set of high-symmetry path lines is equivalent to minimizing a function over a strict subset of its domain, which can miss extrema located off those lines.\n\nStarting from well-tested tight-binding intuition, consider the following parametric, periodic band energy model in two dimensions:\n$$\nE(\\mathbf{k}) \\equiv E(k_x,k_y) = E_0 + 2 t_1 \\left[\\cos(k_x a) + \\cos(k_y a)\\right] + 2 t_2 \\cos(k_x a)\\cos(k_y a) - \\Delta \\cos\\big(m (k_x - k_{0x}) a\\big)\\cos\\big(m (k_y - k_{0y}) a\\big),\n$$\nwhere $E_0$, $t_1$, $t_2$, and $\\Delta$ are energy parameters expressed in electronvolts, $m$ is a positive integer controlling the sharpness and periodic replication of a valley feature, and $(k_{0x},k_{0y})$ designates the center of a valley feature in reciprocal space. Angles used inside trigonometric functions must be interpreted in radians. The first Brillouin zone domain is taken to be the square $k_x, k_y \\in [-\\pi/a, \\pi/a]$.\n\nLet the canonical high-symmetry path for the square lattice be defined by the piecewise linear sequence $\\Gamma \\rightarrow X \\rightarrow M \\rightarrow \\Gamma$ with points $\\Gamma=(0,0)$, $X=(\\pi/a,0)$, and $M=(\\pi/a,\\pi/a)$. Band path sampling selects $k$-points on these lines and minimizes $E(\\mathbf{k})$ only over that path. Uniform Brillouin zone meshes instead minimize $E(\\mathbf{k})$ over a set of $k$-points that cover the two-dimensional domain.\n\nYour tasks are:\n\n- From the definitions above and the periodicity imposed by Bloch's theorem, explain why minimizing $E(\\mathbf{k})$ along a subset (the high-symmetry path) does not guarantee finding the global minimum over the entire Brillouin zone, and why off-path minima can be missed. Use only standard set optimization arguments and the periodicity of $E(\\mathbf{k})$ to reason from first principles.\n- Design and implement a computational procedure that, for given parameters, evaluates $E(\\mathbf{k})$ at:\n  1. A dense high-symmetry path sampling with $N_{\\mathrm{path}}$ points per segment on $\\Gamma \\rightarrow X$, $X \\rightarrow M$, and $M \\rightarrow \\Gamma$.\n  2. A fine, uniform, two-dimensional mesh of size $N_{\\mathrm{fine}} \\times N_{\\mathrm{fine}}$ covering the entire first Brillouin zone $k_x, k_y \\in [-\\pi/a, \\pi/a]$.\n- For each test case, return:\n  1. The minimum energy found on the high-symmetry path, expressed in electronvolts and rounded to $6$ decimals.\n  2. The minimum energy found on the fine mesh, expressed in electronvolts and rounded to $6$ decimals.\n  3. A boolean indicating whether the fine mesh found a strictly lower energy than the path sampling (this boolean must be true if and only if the fine-mesh minimum is less than the path minimum by more than a numerical tolerance of $10^{-8}$ electronvolts).\n\nYou must use the following test suite that explores different scenarios including off-path valleys, on-path valleys, and sharp features that can be missed by coarse path sampling:\n\n- Test case $1$ (off-path, deep valley):\n  - $a = 2.8$ Å.\n  - $E_0 = 0.0$ electronvolts, $t_1 = 0.8$ electronvolts, $t_2 = 0.3$ electronvolts.\n  - $\\Delta = 2.8$ electronvolts, $m = 1$.\n  - $k_{0x} = 0.6 \\cdot \\pi/a$, $k_{0y} = 0.4 \\cdot \\pi/a$.\n  - $N_{\\mathrm{path}} = 401$, $N_{\\mathrm{fine}} = 301$.\n- Test case $2$ (off-path, shallow valley):\n  - $a = 2.8$ Å.\n  - $E_0 = 0.0$ electronvolts, $t_1 = 0.8$ electronvolts, $t_2 = 0.3$ electronvolts.\n  - $\\Delta = 0.3$ electronvolts, $m = 1$.\n  - $k_{0x} = 0.6 \\cdot \\pi/a$, $k_{0y} = 0.4 \\cdot \\pi/a$.\n  - $N_{\\mathrm{path}} = 401$, $N_{\\mathrm{fine}} = 301$.\n- Test case $3$ (on-path valley):\n  - $a = 2.8$ Å.\n  - $E_0 = 0.0$ electronvolts, $t_1 = 0.8$ electronvolts, $t_2 = 0.3$ electronvolts.\n  - $\\Delta = 2.0$ electronvolts, $m = 1$.\n  - $k_{0x} = 1.0 \\cdot \\pi/a$, $k_{0y} = 0.5 \\cdot \\pi/a$.\n  - $N_{\\mathrm{path}} = 401$, $N_{\\mathrm{fine}} = 301$.\n- Test case $4$ (off-path, very sharp valley requiring fine mesh):\n  - $a = 2.8$ Å.\n  - $E_0 = 0.0$ electronvolts, $t_1 = 0.8$ electronvolts, $t_2 = 0.3$ electronvolts.\n  - $\\Delta = 3.0$ electronvolts, $m = 9$.\n  - $k_{0x} = 0.53 \\cdot \\pi/a$, $k_{0y} = 0.37 \\cdot \\pi/a$.\n  - $N_{\\mathrm{path}} = 401$, $N_{\\mathrm{fine}} = 401$.\n\nAll trigonometric arguments must be in radians. Express all energies in electronvolts. Your program must compute the requested quantities for the above test suite and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order:\n$[$path\\_min\\_1, mesh\\_min\\_1, flag\\_1, path\\_min\\_2, mesh\\_min\\_2, flag\\_2, path\\_min\\_3, mesh\\_min\\_3, flag\\_3, path\\_min\\_4, mesh\\_min\\_4, flag\\_4$]$,\nwhere each energy is rounded to $6$ decimals and each flag is a boolean. No additional text must be printed.",
            "solution": "The problem asks for a theoretical explanation for why minimizing a band energy function $E(\\mathbf{k})$ along a high-symmetry path may not yield the global minimum, and for a computational procedure to demonstrate this. The problem is scientifically grounded, well-posed, and all provided data are consistent and sufficient for a solution.\n\n### Part 1: Theoretical Justification\n\nThe core of the issue lies in the fundamental principles of mathematical optimization. Let the domain of the function $E(\\mathbf{k})$ be the first Brillouin zone (BZ), which for the given two-dimensional square lattice is a compact set in reciprocal space. We can define this domain as $\\mathcal{B} = \\{ \\mathbf{k}=(k_x, k_y) \\in \\mathbb{R}^2 \\mid k_x \\in [-\\pi/a, \\pi/a], k_y \\in [-\\pi/a, \\pi/a] \\}$. The energy function $E(\\mathbf{k})$ is continuous on this domain. By the extreme value theorem, $E(\\mathbf{k})$ must attain a global minimum value on $\\mathcal{B}$. Let this global minimum be $E_{\\text{global}}$ and let it occur at a point $\\mathbf{k}^* \\in \\mathcal{B}$, such that $E(\\mathbf{k}^*) = E_{\\text{global}} = \\min_{\\mathbf{k} \\in \\mathcal{B}} E(\\mathbf{k})$.\n\nBy Bloch's theorem, the band energy $E(\\mathbf{k})$ is a periodic function of the wavevector $\\mathbf{k}$ with the periodicity of the reciprocal lattice. This means $E(\\mathbf{k}) = E(\\mathbf{k}+\\mathbf{G})$ for any reciprocal lattice vector $\\mathbf{G}$. For the specified square lattice, the primitive reciprocal lattice vectors are $\\mathbf{b}_1 = (2\\pi/a, 0)$ and $\\mathbf{b}_2 = (0, 2\\pi/a)$. The periodicity of $E(\\mathbf{k})$ ensures that the entire energy landscape is captured within a single primitive cell of the reciprocal lattice. The first Brillouin zone $\\mathcal{B}$ is such a primitive cell. Therefore, restricting the search for the global minimum to the domain $\\mathcal{B}$ is sufficient and complete; any minimum outside $\\mathcal{B}$ has an identical counterpart inside $\\mathcal{B}$.\n\nThe high-symmetry path, defined by the sequence $\\Gamma \\rightarrow X \\rightarrow M \\rightarrow \\Gamma$, constitutes a one-dimensional manifold within the two-dimensional Brillouin zone. Let us denote this path domain by $\\mathcal{P}$. The points on this path are $\\mathbf{k} \\in \\mathcal{P}$, where $\\mathcal{P}$ is the union of the line segments connecting $\\Gamma=(0,0)$, $X=(\\pi/a,0)$, and $M=(\\pi/a,\\pi/a)$. It is clear by construction that the path $\\mathcal{P}$ is a strict subset of the Brillouin zone $\\mathcal{B}$, i.e., $\\mathcal{P} \\subset \\mathcal{B}$.\n\nWhen one performs an optimization by sampling only along the high-symmetry path, one is seeking the minimum of $E(\\mathbf{k})$ restricted to the domain $\\mathcal{P}$. Let this path-restricted minimum be $E_{\\text{path}} = \\min_{\\mathbf{k} \\in \\mathcal{P}} E(\\mathbf{k})$.\n\nFrom the principles of set optimization, because the search domain for the path minimum, $\\mathcal{P}$, is a subset of the search domain for the global minimum, $\\mathcal{B}$, the following inequality must hold:\n$$\nE_{\\text{global}} = \\min_{\\mathbf{k} \\in \\mathcal{B}} E(\\mathbf{k}) \\le \\min_{\\mathbf{k} \\in \\mathcal{P}} E(\\mathbf{k}) = E_{\\text{path}}\n$$\nThis inequality states that the minimum over a larger set cannot be greater than the minimum over a smaller, contained set. Equality, $E_{\\text{global}} = E_{\\text{path}}$, holds if and only if the global minimizer $\\mathbf{k}^*$ happens to lie on the path $\\mathcal{P}$ (i.e., $\\mathbf{k}^* \\in \\mathcal{P}$).\n\nHowever, there is no physical or mathematical law that guarantees that the global minimum of an arbitrary periodic function $E(\\mathbf{k})$ must lie on a pre-selected set of high-symmetry lines. The locations of extrema are determined by the specific functional form of $E(\\mathbf{k})$ and its parameters ($t_1$, $t_2$, $\\Delta$, etc.). If the parameters are such that the global minimum occurs at a point of low symmetry, $\\mathbf{k}_{\\text{off-path}}^* \\notin \\mathcal{P}$, then the path-sampling method is fundamentally incapable of finding this minimum. In this scenario, the minimum found on the path, $E_{\\text{path}}$, will be strictly greater than the true global minimum, $E_{\\text{global}}$. The full Brillouin zone mesh sampling approximates the search over $\\mathcal{B}$ and thus can locate (or get close to) such off-path minima, resulting in a lower energy value.\n\nIn summary, minimizing $E(\\mathbf{k})$ along the high-symmetry path $\\mathcal{P}$ is an optimization over a restricted one-dimensional subspace of the full two-dimensional domain $\\mathcal{B}$. Unless the global minimum happens to fall on this specific subspace, the path-based search will miss it and report a higher value than the true global minimum.\n\n### Part 2: Computational Procedure Design\n\nThe computational procedure is designed to numerically demonstrate the principle described above. For each test case, we perform two independent minimizations of the given energy function $E(k_x, k_y)$ over two different discrete sets of points.\n\nThe energy function is:\n$$\nE(k_x,k_y) = E_0 + 2 t_1 \\left[\\cos(k_x a) + \\cos(k_y a)\\right] + 2 t_2 \\cos(k_x a)\\cos(k_y a) - \\Delta \\cos\\big(m (k_x - k_{0x}) a\\big)\\cos\\big(m (k_y - k_{0y}) a\\big)\n$$\n\n1.  **High-Symmetry Path Sampling**:\n    -   The path is composed of three segments: $\\Gamma \\rightarrow X$, $X \\rightarrow M$, and $M \\rightarrow \\Gamma$.\n    -   The endpoints are $\\Gamma=(0,0)$, $X=(\\pi/a,0)$, and $M=(\\pi/a,\\pi/a)$.\n    -   For each segment, we generate $N_{\\mathrm{path}}$ equidistant points.\n        -   $\\Gamma \\rightarrow X$: $\\mathbf{k}(s) = (s \\cdot \\pi/a, 0)$ for $s \\in [0,1]$. We sample $N_{\\mathrm{path}}$ points by taking uniform steps for $s$.\n        -   $X \\rightarrow M$: $\\mathbf{k}(s) = (\\pi/a, s \\cdot \\pi/a)$ for $s \\in [0,1]$. We sample $N_{\\mathrm{path}}$ points.\n        -   $M \\rightarrow \\Gamma$: $\\mathbf{k}(s) = ((1-s) \\cdot \\pi/a, (1-s) \\cdot \\pi/a)$ for $s \\in [0,1]$. We sample $N_{\\mathrm{path}}$ points.\n    -   The collection of all generated points forms the discrete set $S_{\\text{path}}$. We evaluate $E(\\mathbf{k})$ for every $\\mathbf{k} \\in S_{\\text{path}}$ and find the minimum value, $E_{\\text{path\\_min}} = \\min_{\\mathbf{k} \\in S_{\\text{path}}} E(\\mathbf{k})$.\n\n2.  **Uniform Brillouin Zone Mesh Sampling**:\n    -   The domain is the square $k_x, k_y \\in [-\\pi/a, \\pi/a]$.\n    -   We create a uniform grid of $N_{\\mathrm{fine}} \\times N_{\\mathrm{fine}}$ points covering this square. This is done by generating $N_{\\mathrm{fine}}$ equally spaced points along the $k_x$-axis and $k_y$-axis from $-\\pi/a$ to $\\pi/a$ and forming a meshgrid.\n    -   This discrete set of points, $S_{\\text{mesh}}$, serves as an approximation of the full Brillouin zone $\\mathcal{B}$.\n    -   We evaluate $E(\\mathbf{k})$ for every point $\\mathbf{k} \\in S_{\\text{mesh}}$ and find the minimum value, $E_{\\text{mesh\\_min}} = \\min_{\\mathbf{k} \\in S_{\\text{mesh}}} E(\\mathbf{k})$.\n\n3.  **Comparison**:\n    -   The two minima, $E_{\\text{path\\_min}}$ and $E_{\\text{mesh\\_min}}$, are compared.\n    -   A boolean flag is set to `True` if the mesh search finds a strictly lower energy, defined as $E_{\\text{path\\_min}} - E_{\\text{mesh\\_min}} > 10^{-8}$, where $10^{-8}$ is a numerical tolerance to guard against floating-point noise. Otherwise, the flag is `False`. The results are then rounded to $6$ decimal places as required.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Brillouin zone sampling problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"a\": 2.8, \"E0\": 0.0, \"t1\": 0.8, \"t2\": 0.3,\n            \"delta\": 2.8, \"m\": 1,\n            \"k0x_factor\": 0.6, \"k0y_factor\": 0.4,\n            \"N_path\": 401, \"N_fine\": 301\n        },\n        {\n            \"a\": 2.8, \"E0\": 0.0, \"t1\": 0.8, \"t2\": 0.3,\n            \"delta\": 0.3, \"m\": 1,\n            \"k0x_factor\": 0.6, \"k0y_factor\": 0.4,\n            \"N_path\": 401, \"N_fine\": 301\n        },\n        {\n            \"a\": 2.8, \"E0\": 0.0, \"t1\": 0.8, \"t2\": 0.3,\n            \"delta\": 2.0, \"m\": 1,\n            \"k0x_factor\": 1.0, \"k0y_factor\": 0.5,\n            \"N_path\": 401, \"N_fine\": 301\n        },\n        {\n            \"a\": 2.8, \"E0\": 0.0, \"t1\": 0.8, \"t2\": 0.3,\n            \"delta\": 3.0, \"m\": 9,\n            \"k0x_factor\": 0.53, \"k0y_factor\": 0.37,\n            \"N_path\": 401, \"N_fine\": 401\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        a = case[\"a\"]\n        E0 = case[\"E0\"]\n        t1 = case[\"t1\"]\n        t2 = case[\"t2\"]\n        delta = case[\"delta\"]\n        m = case[\"m\"]\n        N_path = case[\"N_path\"]\n        N_fine = case[\"N_fine\"]\n\n        pi_a = np.pi / a\n        k0x = case[\"k0x_factor\"] * pi_a\n        k0y = case[\"k0y_factor\"] * pi_a\n\n        def energy_func(kx, ky):\n            \"\"\"\n            Calculates the parametric band energy E(k_x, k_y).\n            \"\"\"\n            cos_kx_a = np.cos(kx * a)\n            cos_ky_a = np.cos(ky * a)\n            \n            base_energy = E0 + 2 * t1 * (cos_kx_a + cos_ky_a) + 2 * t2 * cos_kx_a * cos_ky_a\n            \n            valley_term = delta * np.cos(m * (kx - k0x) * a) * np.cos(m * (ky - k0y) * a)\n            \n            return base_energy - valley_term\n\n        # 1. High-symmetry path sampling\n        # Gamma -> X\n        kx_gx = np.linspace(0, pi_a, N_path)\n        ky_gx = np.zeros(N_path)\n        \n        # X -> M\n        kx_xm = np.full(N_path, pi_a)\n        ky_xm = np.linspace(0, pi_a, N_path)\n\n        # M -> Gamma\n        kx_mg = np.linspace(pi_a, 0, N_path)\n        ky_mg = np.linspace(pi_a, 0, N_path)\n\n        # Concatenate path segments\n        k_path_x = np.concatenate((kx_gx, kx_xm, kx_mg))\n        k_path_y = np.concatenate((ky_gx, ky_xm, ky_mg))\n\n        path_energies = energy_func(k_path_x, k_path_y)\n        path_min = np.min(path_energies)\n\n        # 2. Uniform Brillouin zone mesh sampling\n        k_coords = np.linspace(-pi_a, pi_a, N_fine)\n        kx_mesh, ky_mesh = np.meshgrid(k_coords, k_coords)\n\n        mesh_energies = energy_func(kx_mesh, ky_mesh)\n        mesh_min = np.min(mesh_energies)\n\n        # 3. Comparison\n        # Flag is True if mesh_min is strictly lower than path_min by more than the tolerance.\n        found_lower = (path_min - mesh_min) > 1e-8\n\n        # Append results for this case\n        all_results.extend([\n            round(path_min, 6),\n            round(mesh_min, 6),\n            bool(found_lower) # Ensure it's a standard Python boolean\n        ])\n    \n    # Format the final output string exactly as specified\n    result_str = \",\".join(map(str, all_results))\n    print(f\"[{result_str.replace('True', 'True').replace('False', 'False')}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Achieving numerical convergence is a balancing act between accuracy and computational resources. While converging the plane-wave cutoff $E_{\\text{cut}}$ and the k-point mesh density $N_k$ are often treated as separate steps, their contributions to total error and computational cost are coupled. This practice  models this interplay, tasking you with finding the most cost-effective combination of parameters that meets a specific accuracy target, a core strategic skill for efficient and reliable computational research.",
            "id": "3870671",
            "problem": "Consider a periodic metallic system commonly used in computational catalysis and chemical engineering, where the total energy per unit cell is computed using a plane-wave basis and Brillouin zone integration. The following well-tested base facts and definitions apply:\n\n- Under periodic boundary conditions, electronic states are described by Bloch functions, and the total energy per unit cell is a Brillouin zone integral over crystal momentum $k$. Numerical evaluation replaces the integral by a sum over $N_k$ discrete $k$-points, for example via Monkhorst-Pack grids. For metals with finite-temperature smearing, the quadrature error of the Brillouin zone sampling decreases algebraically with the number of points, and is represented as $e_k(N_k) = B N_k^{-q}$ for some positive constants $B$ and $q$ that depend on the material and smearing details.\n\n- In a plane-wave method, the basis is truncated by an energy cutoff $E_{\\text{cut}}$ (in $\\mathrm{eV}$), which limits the maximum kinetic energy of included plane waves. The incompleteness error of a smooth observable such as the total energy typically decreases with increasing $E_{\\text{cut}}$ as a power law $e_{\\text{pw}}(E_{\\text{cut}}) = A E_{\\text{cut}}^{-p}$ for positive constants $A$ and $p$, reflecting the convergence properties of Fourier expansions of smooth functions.\n\n- The total energy error is modeled as the sum of the independent contributions $e_{\\text{tot}}(E_{\\text{cut}}, N_k) = e_{\\text{pw}}(E_{\\text{cut}}) + e_k(N_k) = A E_{\\text{cut}}^{-p} + B N_k^{-q}$.\n\n- Computational cost is dominated by operations that scale with the number of plane waves and the number of $k$-points. The number of plane waves scales as $N_{\\text{pw}} \\propto E_{\\text{cut}}^{3/2}$ because the count of reciprocal lattice vectors inside a sphere of radius set by $E_{\\text{cut}}$ grows as the volume in reciprocal space. Neglecting weak logarithmic factors, a simple and widely used cost model is $C(E_{\\text{cut}}, N_k) = \\gamma N_k E_{\\text{cut}}^{s}$ where $s \\approx 3/2$ and $\\gamma$ is a proportionality constant converting operation counts into wall-clock time (in seconds).\n\nYou are to compute, for given parameters $(A, p, B, q, s, \\gamma)$, a tolerance $\\tau$ (in $\\mathrm{eV}$), and bounded discrete search ranges for $E_{\\text{cut}}$ and $N_k$, the joint parameter choice $(E_{\\text{cut}}, N_k)$ that minimizes the computational cost $C(E_{\\text{cut}}, N_k)$ while satisfying the energy error constraint $e_{\\text{tot}}(E_{\\text{cut}}, N_k) \\le \\tau$. If no pair in the bounded search space satisfies the tolerance, return the pair that minimizes $e_{\\text{tot}}(E_{\\text{cut}}, N_k)$ (i.e., the closest achievable within bounds) and mark the case as not achievable.\n\nAlgorithmic requirements:\n\n- Use the error model $e_{\\text{tot}}(E_{\\text{cut}}, N_k) = A E_{\\text{cut}}^{-p} + B N_k^{-q}$.\n\n- Use the cost model $C(E_{\\text{cut}}, N_k) = \\gamma N_k E_{\\text{cut}}^{s}$.\n\n- Search $E_{\\text{cut}}$ on an integer grid in $\\mathrm{eV}$ with step $\\Delta E_{\\text{cut}}$ between bounds $E_{\\min}$ and $E_{\\max}$ inclusive.\n\n- Search $N_k$ over integers between $N_{k,\\min}$ and $N_{k,\\max}$ inclusive.\n\n- If multiple pairs achieve the same minimal cost (to within numerical tolerance), choose the one with the smallest $N_k$, and if still tied, the smallest $E_{\\text{cut}}$.\n\nUnits and output requirements:\n\n- All energies must be treated and reported in $\\mathrm{eV}$.\n\n- Computational cost must be reported in seconds.\n\n- For each test case, output a list $[\\text{achievable}, E_{\\text{cut}}^{\\star}, N_k^{\\star}, C^{\\star}]$ where $\\text{achievable}$ is a boolean indicating whether the tolerance $\\tau$ was met, $E_{\\text{cut}}^{\\star}$ is the chosen cutoff in $\\mathrm{eV}$ (integer), $N_k^{\\star}$ is the chosen number of $k$-points (integer), and $C^{\\star}$ is the computational cost in seconds (rounded to six decimal places). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[ [\\text{True}, 500, 31, 1.733000], [\\text{False}, 900, 128, 4.321000] ]$).\n\nTest suite:\n\nUse the following four cases to exercise the algorithm:\n\n- Case $1$ (balanced, moderate tolerance):\n  - $A = 0.5$, $p = 1.5$, $B = 0.3$, $q = 1.0$, $s = 1.5$, $\\gamma = 5 \\times 10^{-6}$, $\\tau = 0.01$.\n  - $E_{\\min} = 200$, $E_{\\max} = 800$, $\\Delta E_{\\text{cut}} = 10$.\n  - $N_{k,\\min} = 6$, $N_{k,\\max} = 60$.\n\n- Case $2$ (tight tolerance, likely infeasible within bounds):\n  - $A = 0.8$, $p = 1.5$, $B = 0.5$, $q = 1.0$, $s = 1.5$, $\\gamma = 7 \\times 10^{-6}$, $\\tau = 0.001$.\n  - $E_{\\min} = 300$, $E_{\\max} = 900$, $\\Delta E_{\\text{cut}} = 10$.\n  - $N_{k,\\min} = 8$, $N_{k,\\max} = 128$.\n\n- Case $3$ (loose tolerance, basis error small relative to $k$-sampling):\n  - $A = 1.0$, $p = 1.2$, $B = 0.2$, $q = 1.0$, $s = 1.5$, $\\gamma = 4 \\times 10^{-6}$, $\\tau = 0.05$.\n  - $E_{\\min} = 200$, $E_{\\max} = 600$, $\\Delta E_{\\text{cut}} = 10$.\n  - $N_{k,\\min} = 4$, $N_{k,\\max} = 20$.\n\n- Case $4$ (dominant $k$-point error with slightly higher smoothness exponent):\n  - $A = 0.1$, $p = 1.5$, $B = 1.0$, $q = 1.2$, $s = 1.5$, $\\gamma = 6 \\times 10^{-6}$, $\\tau = 0.02$.\n  - $E_{\\min} = 300$, $E_{\\max} = 800$, $\\Delta E_{\\text{cut}} = 10$.\n  - $N_{k,\\min} = 10$, $N_{k,\\max} = 100$.\n\nYour program must implement the search and selection strategy described above for each case and produce the single-line aggregated output of four lists as specified. All numeric reporting must adhere to the units specified and $C^{\\star}$ must be rounded to six decimal places.",
            "solution": "The problem has been validated and is determined to be a well-posed, scientifically grounded, and objective optimization task within the domain of computational materials science. It is free of any invalidating flaws.\n\nThe task is to find the optimal computational parameters—the plane-wave energy cutoff, $E_{\\text{cut}}$, and the number of $k$-points, $N_k$—that minimize computational cost, $C$, while ensuring the total energy error, $e_{\\text{tot}}$, remains below a specified tolerance, $\\tau$. The problem provides physically motivated, algebraic models for both the error and the cost as functions of $E_{\\text{cut}}$ and $N_k$.\n\nThe total error is modeled as the sum of two independent contributions:\n$$ e_{\\text{tot}}(E_{\\text{cut}}, N_k) = e_{\\text{pw}}(E_{\\text{cut}}) + e_k(N_k) = A E_{\\text{cut}}^{-p} + B N_k^{-q} $$\nwhere $e_{\\text{pw}}$ is the basis set incompleteness error and $e_k$ is the Brillouin zone sampling error. The parameters $A, p, B, q$ are positive constants specific to the material system.\n\nThe computational cost is modeled as:\n$$ C(E_{\\text{cut}}, N_k) = \\gamma N_k E_{\\text{cut}}^{s} $$\nwhere $s \\approx 3/2$ and $\\gamma$ is a proportionality constant.\n\nThe search for the optimal pair $(E_{\\text{cut}}, N_k)$ is to be performed over a finite, discrete grid. $E_{\\text{cut}}$ is searched on an integer grid from $E_{\\min}$ to $E_{\\max}$ with a step of $\\Delta E_{\\text{cut}}$. $N_k$ is searched over integers from $N_{k,\\min}$ to $N_{k,\\max}$. Given that the search space is finite and not excessively large for the provided test cases, a comprehensive brute-force grid search is the most direct and robust algorithm. This approach guarantees that the true optimum within the discrete space is found, avoiding potential pitfalls of more complex optimization schemes that might be affected by the non-smooth or non-monotonic nature of the objective function when discretization effects are considered.\n\nThe algorithm proceeds as follows for each test case:\n1.  Generate all possible pairs $(E_{\\text{cut}}, N_k)$ within the specified discrete ranges.\n2.  For each pair, calculate the total error $e_{\\text{tot}}$ and the computational cost $C$.\n3.  Partition the resulting solutions into two groups:\n    a. `valid_solutions`: Pairs where the error constraint $e_{\\text{tot}} \\le \\tau$ is satisfied.\n    b. `all_solutions`: All pairs, stored with their calculated error and cost. This set is used for the fallback scenario.\n4.  Determine the final choice based on whether any valid solutions were found:\n    a. If `valid_solutions` is not empty, the tolerance is achievable. The optimal pair is found by sorting this list to find the one with the minimum cost. The problem specifies a clear tie-breaking rule: if costs are equal, the pair with the smaller $N_k$ is preferred; if that is also a tie, the smaller $E_{\\text{cut}}$ is chosen. This is implemented by sorting the valid solutions lexicographically using the tuple $(C, N_k, E_{\\text{cut}})$ as the key.\n    b. If `valid_solutions` is empty, the tolerance is not achievable. In this case, the requirement is to return the pair that minimizes the total error $e_{\\text{tot}}$. A reasonable and consistent tie-breaking scheme for this scenario, though not explicitly stated for this case, is to select from the minimum-error pairs the one with the lowest cost, followed by the lowest $N_k$, then the lowest $E_{\\text{cut}}$. This is implemented by sorting `all_solutions` lexicographically using the key $(e_{\\text{tot}}, C, N_k, E_{\\text{cut}})$.\n5.  The final result for the case, $[\\text{achievable}, E_{\\text{cut}}^{\\star}, N_k^{\\star}, C^{\\star}]$, is then constructed, with the cost $C^{\\star}$ rounded to six decimal places as required. The boolean `achievable` is set to `True` in the first scenario and `False` in the second.\nThis procedure is applied to each test case, and the results are aggregated into a single list of lists for the final output.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal (E_cut, N_k) pair for a series of test cases based on\n    minimizing computational cost under an energy error constraint.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (balanced, moderate tolerance)\n        {\n            \"params\": (0.5, 1.5, 0.3, 1.0, 1.5, 5e-6, 0.01),\n            \"E_range\": (200, 800, 10),\n            \"Nk_range\": (6, 60)\n        },\n        # Case 2 (tight tolerance, likely infeasible)\n        {\n            \"params\": (0.8, 1.5, 0.5, 1.0, 1.5, 7e-6, 0.001),\n            \"E_range\": (300, 900, 10),\n            \"Nk_range\": (8, 128)\n        },\n        # Case 3 (loose tolerance, basis error small)\n        {\n            \"params\": (1.0, 1.2, 0.2, 1.0, 1.5, 4e-6, 0.05),\n            \"E_range\": (200, 600, 10),\n            \"Nk_range\": (4, 20)\n        },\n        # Case 4 (dominant k-point error)\n        {\n            \"params\": (0.1, 1.5, 1.0, 1.2, 1.5, 6e-6, 0.02),\n            \"E_range\": (300, 800, 10),\n            \"Nk_range\": (10, 100)\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        A, p, B, q, s, gamma, tau = case[\"params\"]\n        E_min, E_max, dE = case[\"E_range\"]\n        Nk_min, Nk_max = case[\"Nk_range\"]\n\n        E_cut_values = np.arange(E_min, E_max + 1, dE)\n        Nk_values = range(Nk_min, Nk_max + 1)\n\n        valid_solutions = []\n        all_solutions = []\n\n        for E_cut in E_cut_values:\n            # Pre-calculate E_cut dependent parts\n            e_pw = A * E_cut**(-p)\n            cost_factor_E = gamma * E_cut**s\n\n            for N_k in Nk_values:\n                # Calculate total error\n                e_k = B * N_k**(-q)\n                e_tot = e_pw + e_k\n\n                # Calculate computational cost\n                cost = cost_factor_E * N_k\n\n                # Store all solutions for fallback scenario\n                all_solutions.append((e_tot, cost, N_k, E_cut))\n                \n                # Check constraint and store valid solutions\n                if e_tot <= tau:\n                    valid_solutions.append((cost, N_k, E_cut))\n\n        if valid_solutions:\n            achievable = True\n            # Sort by cost, then N_k, then E_cut\n            valid_solutions.sort()\n            C_star, Nk_star, E_cut_star = valid_solutions[0]\n        else:\n            achievable = False\n            # Sort by error, then cost, then N_k, then E_cut\n            all_solutions.sort()\n            e_min, C_star, Nk_star, E_cut_star = all_solutions[0]\n        \n        results.append([achievable, E_cut_star, Nk_star, C_star])\n\n    def format_result(res):\n        ach, E, N, C = res\n        # Format with capital True/False and 6 decimal places for cost\n        return f\"[{str(ach)}, {E}, {N}, {C:.6f}]\"\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(format_result, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}