{
    "hands_on_practices": [
        {
            "introduction": "分子动力学模拟通常只对一个更大的系统中的一小部分代表性区域进行建模。为了消除不必要的表面效应并模拟体相环境，周期性边界条件（PBC）和最小镜像约定是至关重要的技术。这项练习将引导您从第一性原理出发，推导在这些条件下计算粒子间距离的公式 ，这是构建任何MD代码的基本要素。",
            "id": "3873256",
            "problem": "在用于计算催化和化学工程的经典分子动力学中，粒子间的相互作用通常在一个周期性复制的立方模拟晶胞中计算，以模拟体相环境。考虑在周期性边界条件 (PBC) 下，一个边长为 $L$ 的立方盒子内的两个粒子，其笛卡尔坐标分别为 $\\mathbf{r}_{i} = (x_{i}, y_{i}, z_{i})$ 和 $\\mathbf{r}_{j} = (x_{j}, y_{j}, z_{j})$。该空间由立方盒子的整数平铺构成，因此粒子 $j$ 在位置 $\\mathbf{r}_{j} + L \\mathbf{n}$ (其中 $\\mathbf{n} \\in \\mathbb{Z}^{3}$) 处有无穷多个镜像。粒子 $i$ 与粒子 $j$ 的某个给定镜像之间的欧几里得分离距离由欧几里得范数定义。在实践中，采用最小镜像约定来计算对相互作用，即选择与粒子 $i$ 最近的粒子 $j$ 的镜像。\n\n请仅使用以下基本要素：\n- $\\mathbb{R}^{3}$ 中的欧几里得范数，\n- 立方晶格 $L \\mathbb{Z}^{3}$ 的周期性平铺，\n- 以及最小镜像约定的定义，即选择使欧几里得距离最小化的镜像，\n\n从第一性原理出发，推导最小镜像粒子间距 $r_{ij}$ 的一个闭合形式解析表达式。该表达式需用原始分量差 $\\Delta x = x_{j} - x_{i}$、$\\Delta y = y_{j} - y_{i}$、$\\Delta z = z_{j} - z_{i}$ 以及盒子边长 $L$ 来表示。您的最终表达式必须仅使用算术运算和（如果需要）地板函数明确写出。不要调用任何预封装的“环绕”公式；请展示该公式是如何从对整数格点平移的最小化中得出的。\n\n请提供在边长为 $L$ 的立方盒子中实现最小镜像约定的 $r_{ij}$ 的单一闭合形式解析表达式作为最终答案。无需进行数值计算。将最终答案表示为不带单位的单一解析表达式。",
            "solution": "该问题要求在周期性边界条件下，对边长为 $L$ 的立方模拟盒子中的两个粒子 $i$ 和 $j$，推导其最小镜像粒子间距 $r_{ij}$ 的一个闭合形式解析表达式。推导过程必须从第一性原理出发，即对所有周期性镜像的欧几里得距离进行最小化。\n\n设两个粒子的笛卡尔坐标为 $\\mathbf{r}_{i} = (x_{i}, y_{i}, z_{i})$ 和 $\\mathbf{r}_{j} = (x_{j}, y_{j}, z_{j})$。由于周期性边界条件，粒子 $j$ 在位置 $\\mathbf{r}_{j,\\mathbf{n}} = \\mathbf{r}_{j} + L \\mathbf{n}$ 处有无穷多个周期性镜像，其中 $\\mathbf{n} = (n_x, n_y, n_z)$ 是一个整数向量，即 $n_x, n_y, n_z \\in \\mathbb{Z}$。\n\n粒子 $i$ 与粒子 $j$ 的一个镜像 $\\mathbf{n}$ 之间的分离矢量由下式给出：\n$$ \\mathbf{d}(\\mathbf{n}) = \\mathbf{r}_{j,\\mathbf{n}} - \\mathbf{r}_{i} = (\\mathbf{r}_{j} - \\mathbf{r}_{i}) + L \\mathbf{n} $$\n设 $\\Delta\\mathbf{r} = \\mathbf{r}_{j} - \\mathbf{r}_{i} = (\\Delta x, \\Delta y, \\Delta z)$ 为原始分离矢量，其中 $\\Delta x = x_{j} - x_{i}$、$\\Delta y = y_{j} - y_{i}$ 和 $\\Delta z = z_{j} - z_{i}$。那么，与一个镜像的分离矢量为 $\\mathbf{d}(\\mathbf{n}) = \\Delta\\mathbf{r} + L \\mathbf{n}$。\n\n最小镜像约定指出，相互作用是使用可能的最短分离矢量来计算的。这对应于找到一个整数向量 $\\mathbf{n}^*$，它能使欧几里得距离的平方 $d^2(\\mathbf{n}) = ||\\mathbf{d}(\\mathbf{n})||^2$ 最小化。\n$$ d^2(\\mathbf{n}) = ||\\Delta\\mathbf{r} + L \\mathbf{n}||^2 = (\\Delta x + L n_x)^2 + (\\Delta y + L n_y)^2 + (\\Delta z + L n_z)^2 $$\n总距离平方是三个独立项的和，每个笛卡尔坐标对应一项。因此，我们可以通过分别最小化每一项来最小化总距离。我们先关注 $x$ 分量项：\n$$ f(n_x) = (\\Delta x + L n_x)^2 $$\n我们需要找到使该函数最小化的整数 $n_x \\in \\mathbb{Z}$。该表达式代表一个关于变量 $n_x$ 的抛物线。此抛物线的最小值出现在平方项内部为零时，即 $\\Delta x + L n_x = 0$，这将给出一个（通常为非整数的）值 $n_x = -\\frac{\\Delta x}{L}$。由于 $n_x$ 必须是整数，因此使 $f(n_x)$ 最小化的整数 $n_x^*$ 是最接近实值最小值 $-\\frac{\\Delta x}{L}$ 的整数。\n\n另一种更直接的方法是定义最小镜像分离矢量 $\\Delta\\mathbf{r}' = (\\Delta x', \\Delta y', \\Delta z')$。这个矢量是连接粒子 $i$ 到粒子 $j$ 的任意镜像的最短可能矢量。这样一个矢量的分量必须位于以原点为中心的中心模拟盒子内，对于边长为 $L$ 的立方盒子，该区域为 $[-\\frac{L}{2}, \\frac{L}{2}] \\times [-\\frac{L}{2}, \\frac{L}{2}] \\times [-\\frac{L}{2}, \\frac{L}{2}]$。\n最小镜像矢量 $\\Delta\\mathbf{r}'$ 通过盒子向量的整数倍平移与原始分离矢量 $\\Delta\\mathbf{r}$ 相关联：\n$$ \\Delta\\mathbf{r}' = \\Delta\\mathbf{r} - L \\mathbf{m} $$\n其中 $\\mathbf{m} = (m_x, m_y, m_z) \\in \\mathbb{Z}^3$ 是某个整数向量。我们需要找到整数 $m_x$，使得所得分量 $\\Delta x'$ 落在期望的范围内。按照惯例，我们选择区间 $[-\\frac{L}{2}, \\frac{L}{2})$。\n$$ -\\frac{L}{2} \\le \\Delta x'  \\frac{L}{2} $$\n代入 $\\Delta x'$ 的表达式：\n$$ -\\frac{L}{2} \\le \\Delta x - L m_x  \\frac{L}{2} $$\n各部分同除以 $L$：\n$$ -\\frac{1}{2} \\le \\frac{\\Delta x}{L} - m_x  \\frac{1}{2} $$\n重新整理不等式以分离出 $m_x$：\n$$ \\frac{\\Delta x}{L} - \\frac{1}{2}  m_x \\le \\frac{\\Delta x}{L} + \\frac{1}{2} $$\n对于任何实数 $u$，在区间 $(u-1, u]$ 中存在一个唯一的整数 $k$，由 $k = \\lfloor u \\rfloor$ 给出。将此应用于我们的不等式，并设 $u = \\frac{\\Delta x}{L} + \\frac{1}{2}$，我们发现唯一的整数 $m_x$ 必须是：\n$$ m_x = \\left\\lfloor \\frac{\\Delta x}{L} + \\frac{1}{2} \\right\\rfloor $$\n这个表达式有效地将值 $\\frac{\\Delta x}{L}$ 四舍五入到最接近的整数。\n\n因此，最小镜像分离矢量在 $x$ 方向上的分量是：\n$$ \\Delta x' = \\Delta x - L m_x = \\Delta x - L \\left\\lfloor \\frac{\\Delta x}{L} + \\frac{1}{2} \\right\\rfloor $$\n同样的逻辑独立地适用于 $y$ 和 $z$ 分量：\n$$ \\Delta y' = \\Delta y - L \\left\\lfloor \\frac{\\Delta y}{L} + \\frac{1}{2} \\right\\rfloor $$\n$$ \\Delta z' = \\Delta z - L \\left\\lfloor \\frac{\\Delta z}{L} + \\frac{1}{2} \\right\\rfloor $$\n最小镜像粒子间距 $r_{ij}$ 是这个最小镜像分离矢量 $\\Delta\\mathbf{r}' = (\\Delta x', \\Delta y', \\Delta z')$ 的欧几里得范数（模长）。\n$$ r_{ij} = ||\\Delta\\mathbf{r}'|| = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2} $$\n代入各分量的表达式，我们得到 $r_{ij}$ 的最终闭合形式表达式：\n$$ r_{ij} = \\sqrt{ \\left( \\Delta x - L \\left\\lfloor \\frac{\\Delta x}{L} + \\frac{1}{2} \\right\\rfloor \\right)^2 + \\left( \\Delta y - L \\left\\lfloor \\frac{\\Delta y}{L} + \\frac{1}{2} \\right\\rfloor \\right)^2 + \\left( \\Delta z - L \\left\\lfloor \\frac{\\Delta z}{L} + \\frac{1}{2} \\right\\rfloor \\right)^2 } $$\n该表达式完全由算术运算和地板函数构成，符合题目要求。",
            "answer": "$$\n\\boxed{\n\\sqrt{ \\left( \\Delta x - L \\left\\lfloor \\frac{\\Delta x}{L} + \\frac{1}{2} \\right\\rfloor \\right)^2 + \\left( \\Delta y - L \\left\\lfloor \\frac{\\Delta y}{L} + \\frac{1}{2} \\right\\rfloor \\right)^2 + \\left( \\Delta z - L \\left\\lfloor \\frac{\\Delta z}{L} + \\frac{1}{2} \\right\\rfloor \\right)^2 }\n}\n$$"
        },
        {
            "introduction": "分子动力学模拟的准确性和稳定性取决于物理作用力与数值积分参数之间的相互作用。Lennard-Jones势是模拟非键相互作用的经典模型，其在平衡点附近的性质决定了系统中的最高振动频率。这项练习  将演示如何通过分析这一频率来推导Verlet算法的最大稳定时间步长，从而将基本的物理模型与关键的模拟参数直接联系起来。",
            "id": "3873340",
            "problem": "一对质量均为 $m$ 的相同被吸附原子通过 Lennard-Jones (LJ) 对势 $u(r)=4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^{6}\\right]$ 相互作用，其中 $r$ 是原子间距，$\\epsilon > 0$ 设定能量标度，$\\sigma > 0$ 设定长度标度。在一个使用 Verlet 算法进行的分子动力学 (MD) 模拟中，最大稳定时间步长受限于系统的最高振动频率。严格地从 Newton 第二定律以及力是势能负梯度的定义出发，完成以下任务：\n\n1. 推导与 $u(r)$ 相关的标量径向力 $f(r)=-\\frac{du}{dr}$，并写出对力矢量 $\\mathbf{F}(r)=f(r)\\,\\hat{\\mathbf{r}}$，其中 $\\hat{\\mathbf{r}}$ 是沿原子间轴线的单位矢量。\n2. 通过求解 $\\frac{du}{dr}=0$ 来确定平衡间距 $r_{\\mathrm{m}}$，并计算曲率 $u''(r_{\\mathrm{m}})$。\n3. 对 $r_{\\mathrm{m}}$ 附近的相对运动进行线性化，得到一个具有折合质量 $\\mu$ 和角频率 $\\omega$ 的相对坐标的谐振子。使用通过将精确解泰勒展开至二阶得到的离散位置 Verlet 更新，对所得谐振子的递推关系进行线性稳定性分析，并以 $\\omega$ 表示最大稳定时间步长 $\\Delta t_{\\max}$。\n4. 结合以上结果，将 $\\Delta t_{\\max}$ 完全用 $m$、$\\sigma$ 和 $\\epsilon$ 表示。\n\n简要说明在第1部分中推导出的 LJ 力在 $r\\to 0$ 和 $r\\to \\infty$ 时的极限行为，以确保表达式的物理真实性，但不要将这些极限行为包含在最终的方框答案中。\n\n将最终答案表示为仅含 $m$（千克）、$\\sigma$（米）和 $\\epsilon$（焦耳）的单个闭式解析表达式。不要代入数值。不要在最终的方框答案中包含单位。",
            "solution": "解决方案按问题陈述分四个阶段进行。\n\n1. 相互作用力的推导。\nLennard-Jones (LJ) 对势由下式给出\n$$u(r) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^{6}\\right]$$\n其中 $r$ 是原子间距，$\\epsilon$ 是能量标度，$\\sigma$ 是长度标度。为便于求导，我们可以将势写为\n$$u(r) = 4\\epsilon\\left[\\sigma^{12}r^{-12} - \\sigma^{6}r^{-6}\\right]$$\n标量径向力 $f(r)$ 定义为势能的负梯度，$f(r) = -\\frac{du}{dr}$。应用此定义：\n$$f(r) = -\\frac{d}{dr}\\left(4\\epsilon\\left[\\sigma^{12}r^{-12} - \\sigma^{6}r^{-6}\\right]\\right)$$\n$$f(r) = -4\\epsilon\\left[\\sigma^{12}(-12)r^{-13} - \\sigma^{6}(-6)r^{-7}\\right]$$\n$$f(r) = -4\\epsilon\\left[-12\\sigma^{12}r^{-13} + 6\\sigma^{6}r^{-7}\\right]$$\n$$f(r) = 4\\epsilon\\left[12\\sigma^{12}r^{-13} - 6\\sigma^{6}r^{-7}\\right]$$\n这个表达式可以因式分解为一个更常见的形式：\n$$f(r) = \\frac{24\\epsilon}{r}\\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right]$$\n相应的对力矢量为 $\\mathbf{F}(r) = f(r)\\hat{\\mathbf{r}}$，其中 $\\hat{\\mathbf{r}}$ 是沿着连接两个原子的直线的单位矢量。\n\n作为对物理真实性的简要检验，我们考察其极限行为。当 $r \\to 0$ 时，排斥项 $r^{-13}$ 占主导，并且 $f(r) \\to +\\infty$，这正确地描述了强的短程排斥力。当 $r \\to \\infty$ 时，两项都趋于零，其中吸引项 $r^{-7}$ 比排斥项衰减得更慢，这意味着力在消失之前会变成弱吸引力。\n\n2. 平衡间距和曲率。\n平衡间距 $r_{\\mathrm{m}}$ 是力为零时的距离，或者等效地说，是势能处于最小值时的距离。我们通过令 $\\frac{du}{dr} = 0$ 来找到它，这等同于令 $f(r)=0$。\n$$4\\epsilon\\left[12\\sigma^{12}r_{\\mathrm{m}}^{-13} - 6\\sigma^{6}r_{\\mathrm{m}}^{-7}\\right] = 0$$\n因为 $4\\epsilon > 0$，我们必须有：\n$$12\\sigma^{12}r_{\\mathrm{m}}^{-13} = 6\\sigma^{6}r_{\\mathrm{m}}^{-7}$$\n$$2\\sigma^{6} = r_{\\mathrm{m}}^{6}$$\n$$r_{\\mathrm{m}} = 2^{1/6}\\sigma$$\n接下来，我们计算势在该平衡点的曲率 $u''(r_{\\mathrm{m}})$。该值代表了围绕平衡点小幅振荡的有效弹簧常数 $k$。\n$$u''(r) = \\frac{d^2u}{dr^2} = \\frac{d}{dr}\\left(-f(r)\\right) = \\frac{d}{dr}\\left(-4\\epsilon\\left[12\\sigma^{12}r^{-13} - 6\\sigma^{6}r^{-7}\\right]\\right)$$\n$$u''(r) = -4\\epsilon\\left[12(-13)\\sigma^{12}r^{-14} - 6(-7)\\sigma^{6}r^{-8}\\right]$$\n$$u''(r) = -4\\epsilon\\left[-156\\sigma^{12}r^{-14} + 42\\sigma^{6}r^{-8}\\right]$$\n$$u''(r) = 4\\epsilon\\left[156\\sigma^{12}r^{-14} - 42\\sigma^{6}r^{-8}\\right]$$\n现在我们在 $r=r_{\\mathrm{m}}$ 处计算这个值。使用关系式 $(\\sigma/r_{\\mathrm{m}})^6 = 1/2$ 会很方便。\n$$u''(r_{\\mathrm{m}}) = 4\\epsilon\\left[156\\frac{\\sigma^{12}}{r_{\\mathrm{m}}^{14}} - 42\\frac{\\sigma^{6}}{r_{\\mathrm{m}}^{8}}\\right] = \\frac{4\\epsilon}{r_{\\mathrm{m}}^2}\\left[156\\left(\\frac{\\sigma}{r_{\\mathrm{m}}}\\right)^{12} - 42\\left(\\frac{\\sigma}{r_{\\mathrm{m}}}\\right)^{6}\\right]$$\n代入 $(\\sigma/r_{\\mathrm{m}})^6 = 1/2$ 和 $(\\sigma/r_{\\mathrm{m}})^{12} = 1/4$：\n$$u''(r_{\\mathrm{m}}) = \\frac{4\\epsilon}{(2^{1/6}\\sigma)^2}\\left[156\\left(\\frac{1}{4}\\right) - 42\\left(\\frac{1}{2}\\right)\\right]$$\n$$u''(r_{\\mathrm{m}}) = \\frac{4\\epsilon}{2^{1/3}\\sigma^2}\\left[39 - 21\\right] = \\frac{4\\epsilon \\cdot 18}{2^{1/3}\\sigma^2} = \\frac{72\\epsilon}{2^{1/3}\\sigma^2}$$\n\n3. 谐振子近似和稳定性分析。\n对于偏离平衡位置的小位移 $x = r - r_{\\mathrm{m}}$，相对坐标的运动方程可以近似为一个简谐振子。该系统由两个质量均为 $m$ 的相同原子组成，所以折合质量为 $\\mu = \\frac{m \\cdot m}{m+m} = \\frac{m}{2}$。\n运动方程为 $\\mu \\ddot{x} = -k x$，其中弹簧常数 $k$ 是曲率 $u''(r_{\\mathrm{m}})$。这是一个简谐振子的方程，$\\ddot{x} + \\omega^2 x = 0$，其角频率 $\\omega$ 由下式给出：\n$$\\omega = \\sqrt{\\frac{k}{\\mu}} = \\sqrt{\\frac{u''(r_{\\mathrm{m}})}{m/2}} = \\sqrt{\\frac{2 u''(r_{\\mathrm{m}})}{m}}$$\n位置 Verlet 算法根据以下递推关系更新位置：\n$$x(t+\\Delta t) = 2x(t) - x(t-\\Delta t) + a(t)(\\Delta t)^2$$\n对于谐振子，加速度为 $a(t) = -\\omega^2 x(t)$。设 $x_n = x(n\\Delta t)$。递推关系变为：\n$$x_{n+1} = 2x_n - x_{n-1} - \\omega^2 (\\Delta t)^2 x_n$$\n$$x_{n+1} - (2 - (\\omega\\Delta t)^2)x_n + x_{n-1} = 0$$\n为了分析稳定性，我们寻求形式为 $x_n = \\lambda^n$ 的解。将此代入递推关系，得到放大因子 $\\lambda$ 的特征方程：\n$$\\lambda^2 - (2 - (\\omega\\Delta t)^2)\\lambda + 1 = 0$$\n为使数值解保持有界（稳定），根 $\\lambda$ 的模不得超过1，即 $|\\lambda| \\leq 1$。如果判别式为负，则此二次方程的根为共轭复数：$(2 - (\\omega\\Delta t)^2)^2 - 4  0$。\n这等价于 $|2 - (\\omega\\Delta t)^2|  2$。\n如果 $-2  2 - (\\omega\\Delta t)^2  2$，则该不等式成立。左边的不等式给出 $(\\omega\\Delta t)^2  4$，右边的不等式给出 $(\\omega\\Delta t)^2 > 0$。因此，为保证稳定性，我们需要 $0  (\\omega\\Delta t)^2  4$，这意味着 $0  \\omega\\Delta t  2$。因此，稳定性极限是 $\\omega\\Delta t = 2$。\n最大稳定时间步长是：\n$$\\Delta t_{\\max} = \\frac{2}{\\omega}$$\n\n4. 最大稳定时间步长的最终表达式。\n我们结合前面部分的结果，用基本参数 $m$、$\\sigma$ 和 $\\epsilon$ 来表示 $\\Delta t_{\\max}$。\n首先，我们将 $u''(r_{\\mathrm{m}})$ 的表达式代入 $\\omega$ 的公式中：\n$$\\omega = \\sqrt{\\frac{2}{m}\\left(\\frac{72\\epsilon}{2^{1/3}\\sigma^2}\\right)} = \\sqrt{\\frac{144\\epsilon}{m 2^{1/3}\\sigma^2}}$$\n现在，将这个 $\\omega$ 的表达式代入 $\\Delta t_{\\max}$ 的方程中：\n$$\\Delta t_{\\max} = \\frac{2}{\\omega} = 2\\left(\\sqrt{\\frac{144\\epsilon}{m 2^{1/3}\\sigma^2}}\\right)^{-1} = 2\\sqrt{\\frac{m 2^{1/3}\\sigma^2}{144\\epsilon}}$$\n$$\\Delta t_{\\max} = \\frac{2}{12}\\sqrt{\\frac{m 2^{1/3}\\sigma^2}{\\epsilon}} = \\frac{1}{6}\\sqrt{\\frac{m \\sigma^2 2^{1/3}}{\\epsilon}}$$\n这个表达式可以稍微重新整理为：\n$$\\Delta t_{\\max} = \\frac{\\sigma \\cdot (2^{1/3})^{1/2}}{6} \\sqrt{\\frac{m}{\\epsilon}} = \\frac{2^{1/6}\\sigma}{6}\\sqrt{\\frac{m}{\\epsilon}}$$\n这是基于 Lennard-Jones 二聚体振动频率的谐振子近似，得到的其 Verlet 模拟的最大稳定时间步长的最终表达式。",
            "answer": "$$\\boxed{\\frac{2^{1/6}\\sigma}{6}\\sqrt{\\frac{m}{\\epsilon}}}$$"
        },
        {
            "introduction": "微正则系综（$NVE$）模拟的长期稳定性取决于总能量的守恒，这一特性严格依赖于所选择的数值积分算法。像速度Verlet算法这样的辛积分器，其设计能够精确地保守一个“影子”哈密顿量，从而使得能量误差有界，而不是出现长期漂移。通过理论分析和编程实践相结合，这项练习  阐释了非辛积分器（如前向欧拉法）与辛积分器之间的深刻差异，突显了为何像Verlet这样的算法是分子动力学领域的基石。",
            "id": "3873271",
            "problem": "考虑一个代表了单个粒子在谐振子势中进行分子动力学（MD）微正则系综轨迹的一维哈密顿系统，其哈密顿量定义为 $H(q,p) = T(p) + V(q)$，其中 $T(p) = \\frac{p^2}{2m}$ 且 $V(q) = \\frac{k q^2}{2}$。运动方程由牛顿第二定律和哈密顿方程给出，即 $\\dot{q} = \\frac{\\partial H}{\\partial p}$ 和 $\\dot{p} = -\\frac{\\partial H}{\\partial q}$，其中 $m$ 表示质量，$k$ 为劲度系数，$q$ 为位置，$p$ 为动量。相空间辛形式由常数反对称矩阵 $J$ 表示，一个离散时间映射 $(q_n,p_n) \\mapsto (q_{n+1},p_{n+1})$ 是辛的，如果其雅可比矩阵 $M$ 满足 $M^\\top J M = J$。您需要将辛性与数值稳定性联系起来，并展示一个非辛积分器表现出长期能量漂移的反例。\n\n从牛顿定律和可分离的哈密顿结构出发，基于第一性原理推导为何一种能够精确积分动能和势能子哈密顿量的组合方法（一种在计算化学中通常称为 Velocity Verlet 方法的踢-漂移-踢方案）是辛的。将此与显式前向欧拉方法进行对比，并基于线性化更新和体积保持/辛性条件，论证为什么前向欧拉方法对于谐振子不是辛的，并因此会产生长期能量漂移。\n\n然后，实现一个程序，用如下明确指定的约化单位对谐振子进行数值积分：设置质量 $m = 1$，劲度系数 $k = 1$，角频率 $\\omega = \\sqrt{k/m} = 1$。使用初始条件 $q(0) = 1$ 和 $p(0) = 0$（等效于初始速度 $v(0) = p(0)/m = 0$）。在总约化时间 $T$ 内对运动方程进行积分，在每个时间步 $t_n = n \\Delta t$ 生成位置 $q_n$、速度 $v_n$ 和能量 $E_n = \\frac{1}{2} m v_n^2 + \\frac{1}{2} k q_n^2$ 的时间序列。\n\n实现并比较两种积分器：\n\n- Velocity Verlet 方法，它使用 $T(p)$ 和 $V(q)$ 的精确子流的踢-漂移-踢组合。\n- 显式前向欧拉方法，它通过在当前状态应用常微分方程的右端项来更新位置和速度。\n\n对于每种积分器和每个测试用例，计算 $E_n$ 相对于 $t_n$ 的最小二乘线性回归斜率。该斜率的单位是“约化能量每约化时间”，并应以浮点数形式报告。接近于零的斜率表示有界的能量误差，而正斜率表示长期漂移。\n\n使用以下测试套件，它涵盖了正常路径、中等时间步长和较大时间步长的边缘情况：\n\n- 测试用例 1：$\\Delta t = 0.01$，$T = 100$。\n- 测试用例 2：$\\Delta t = 0.05$，$T = 100$。\n- 测试用例 3：$\\Delta t = 0.20$，$T = 100$。\n\n对于每个测试用例，计算并返回一对浮点数 $[s_{\\mathrm{Euler}}, s_{\\mathrm{Verlet}}]$，其中 $s_{\\mathrm{Euler}}$ 是前向欧拉方法的回归斜率，$s_{\\mathrm{Verlet}}$ 是 Velocity Verlet 方法的回归斜率。所有量都使用 $m=1$，$k=1$ 和 $\\omega=1$ 的约化单位，斜率必须以“约化能量每约化时间”表示。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、按给定测试用例排序的逗号分隔列表。列表中的每个元素本身必须是一个逗号分隔的、用方括号括起来的列表，包含该对 $[s_{\\mathrm{Euler}}, s_{\\mathrm{Verlet}}]$。例如，输出格式必须与 $[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$ 完全一样，其中 $x_i$ 和 $y_i$ 是您的程序为测试用例 $i$ 计算出的浮点数。",
            "solution": "从可分离的哈密顿量 $H(q,p) = T(p) + V(q)$ 开始，其中 $T(p) = \\frac{p^2}{2m}$ 且 $V(q) = \\frac{k q^2}{2}$。哈密顿方程为 $\\dot{q} = \\frac{\\partial H}{\\partial p}$ 和 $\\dot{p} = -\\frac{\\partial H}{\\partial q}$。在 $m=1$ 和 $k=1$ 的约化单位中，角频率为 $\\omega = \\sqrt{k/m} = 1$，方程简化为 $\\dot{q} = p$ 和 $\\dot{p} = -q$，或等效地 $\\ddot{q} = -q$。\n\n一个映射 $(q_n,p_n) \\mapsto (q_{n+1},p_{n+1})$ 是辛的，如果其雅可比矩阵 $M$ 满足辛条件 $M^\\top J M = J$，其中对于单自由度，正则辛形式对应于矩阵\n$$\nJ = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}.\n$$\n辛映射保持相空间体积（刘维定理）和辛二形式，并且通过后向误差分析，它们可以被解释为一个修正哈密顿量 $\\tilde{H}$ 的精确流，该哈密顿量与 $H$ 的差异在于时间步长 $\\Delta t$ 的高阶项。这意味着沿着辛数值轨迹，能量误差是有界的，并且通常围绕真实的恒定能量振荡。\n\n考虑在一个时间步长 $\\Delta t$ 内动能和势能子哈密顿量的精确子流的组合。由 $T(p)$ 生成的、保持 $V(q)$ 不变的精确流通过一次漂移更新 $q$ 并保持 $p$ 不变：\n$$\n\\Phi_T^{\\Delta t}: \\quad q \\mapsto q + \\Delta t \\,\\frac{\\partial T}{\\partial p} = q + \\Delta t \\, p, \\quad p \\mapsto p.\n$$\n由 $V(q)$ 生成的、保持 $T(p)$ 不变的精确流通过一次踢更新 $p$ 并保持 $q$ 不变：\n$$\n\\Phi_V^{\\Delta t}: \\quad q \\mapsto q, \\quad p \\mapsto p - \\Delta t \\, \\frac{\\partial V}{\\partial q} = p - \\Delta t \\, k q.\n$$\n每个子流都是辛的，因为它是可分离哈密顿分量的精确哈密顿演化。Velocity Verlet 方法是对称 Strang 组合（踢-漂移-踢）：\n$$\n\\Phi_{\\mathrm{VV}}^{\\Delta t} = \\Phi_V^{\\Delta t/2} \\circ \\Phi_T^{\\Delta t} \\circ \\Phi_V^{\\Delta t/2}.\n$$\n辛映射的组合是辛的，因此 $\\Phi_{\\mathrm{VV}}^{\\Delta t}$ 是辛的。对于 $m=1$ 和 $k=1$ 的一维情况，其显式更新形式如下：\n- 半步踢：$p_{n+\\frac{1}{2}} = p_n - \\frac{\\Delta t}{2} \\, q_n$。\n- 漂移：$q_{n+1} = q_n + \\Delta t \\, p_{n+\\frac{1}{2}}$。\n- 半步踢：$p_{n+1} = p_{n+\\frac{1}{2}} - \\frac{\\Delta t}{2} \\, q_{n+1}$。\n等效地，使用速度 $v = p/m$ 和加速度 $a(q) = -q$，可以得到众所周知 Velocity Verlet 步骤：\n$$\nv_{n+\\frac{1}{2}} = v_n + \\frac{\\Delta t}{2} \\, a(q_n), \\quad q_{n+1} = q_n + \\Delta t \\, v_{n+\\frac{1}{2}}, \\quad v_{n+1} = v_{n+\\frac{1}{2}} + \\frac{\\Delta t}{2} \\, a(q_{n+1}).\n$$\n因为该方法是精确子流的对称组合，所以它保持了辛形式，并表现出与邻近修正哈密顿量 $\\tilde{H} = H + \\mathcal{O}(\\Delta t^2)$ 的精确流一致的有界能量误差。\n\n相比之下，用于谐振子的显式前向欧拉方法在当前状态应用右端项：\n$$\nq_{n+1} = q_n + \\Delta t \\, v_n, \\quad v_{n+1} = v_n + \\Delta t \\, a(q_n) = v_n - \\Delta t \\, q_n.\n$$\n将状态向量 $x_n = \\begin{pmatrix} q_n \\\\ v_n \\end{pmatrix}$ 的更新写出，前向欧拉方法产生一个线性映射 $x_{n+1} = A x_n$，其中\n$$\nA = \\begin{pmatrix}\n1  \\Delta t \\\\\n- \\Delta t  1\n\\end{pmatrix}.\n$$\n对于一维的辛映射，必须保持相空间体积，这意味着 $\\det(A) = 1$。此处，$\\det(A) = 1 + (\\Delta t)^2  1$，所以该方法不保持相空间体积，因此不是辛的。一个等效的辛性检验是 $A^\\top J A = J$，对于这个矩阵 $A$，该检验不成立。$A$ 的特征值为 $\\lambda_{\\pm} = 1 \\pm i \\Delta t$，其模长 $|\\lambda_{\\pm}| = \\sqrt{1 + (\\Delta t)^2}  1$，表明状态范数被放大，能量出现长期增长。因此，当应用于无阻尼振荡哈密顿系统时，即使对于很小的 $\\Delta t$，前向欧拉方法也会产生长期能量漂移。\n\n为了在数值上量化此行为，我们在每个离散时间计算能量，\n$$\nE_n = \\frac{1}{2} m v_n^2 + \\frac{1}{2} k q_n^2,\n$$\n在约化单位中 $m=1$ 和 $k=1$。对于每种积分器和每个测试用例，对 $E_n$ 与 $t_n = n \\Delta t$ 进行最小二乘线性回归，以获得单位为“约化能量每约化时间”的斜率 $s$。接近 0 的斜率 $s$ 表示有界的振荡能量误差，与辛积分器一致。正斜率 $s$ 表示长期能量增长，与非辛积分器一致。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef forward_euler_ho(q0, v0, dt, T):\n    \"\"\"\n    Forward Euler integration for 1D harmonic oscillator with m=1, k=1.\n    Returns arrays of times and energies.\n    \"\"\"\n    n_steps = int(np.round(T / dt))\n    q = q0\n    v = v0\n    times = np.empty(n_steps + 1, dtype=float)\n    energies = np.empty(n_steps + 1, dtype=float)\n    # initial\n    times[0] = 0.0\n    energies[0] = 0.5 * v * v + 0.5 * q * q\n    for n in range(1, n_steps + 1):\n        # Forward Euler updates\n        q_new = q + dt * v\n        v_new = v - dt * q\n        q, v = q_new, v_new\n        t = n * dt\n        times[n] = t\n        energies[n] = 0.5 * v * v + 0.5 * q * q\n    return times, energies\n\ndef velocity_verlet_ho(q0, v0, dt, T):\n    \"\"\"\n    Velocity Verlet integration for 1D harmonic oscillator with m=1, k=1.\n    Returns arrays of times and energies.\n    \"\"\"\n    n_steps = int(np.round(T / dt))\n    q = q0\n    v = v0\n    # acceleration a = -q\n    a = -q\n    times = np.empty(n_steps + 1, dtype=float)\n    energies = np.empty(n_steps + 1, dtype=float)\n    times[0] = 0.0\n    energies[0] = 0.5 * v * v + 0.5 * q * q\n    for n in range(1, n_steps + 1):\n        # half kick\n        v_half = v + 0.5 * dt * a\n        # drift\n        q_new = q + dt * v_half\n        # new acceleration\n        a_new = -q_new\n        # half kick\n        v_new = v_half + 0.5 * dt * a_new\n        # update\n        q, v, a = q_new, v_new, a_new\n        t = n * dt\n        times[n] = t\n        energies[n] = 0.5 * v * v + 0.5 * q * q\n    return times, energies\n\ndef linear_regression_slope(t, y):\n    \"\"\"\n    Compute least-squares slope of y vs t.\n    \"\"\"\n    # subtract means to improve numerical stability\n    t_mean = np.mean(t)\n    y_mean = np.mean(y)\n    dt = t - t_mean\n    dy = y - y_mean\n    denom = np.dot(dt, dt)\n    if denom == 0.0:\n        return 0.0\n    slope = float(np.dot(dt, dy) / denom)\n    return slope\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (dt, T)\n    test_cases = [\n        (0.01, 100.0),  # happy path: small time step\n        (0.05, 100.0),  # moderate time step\n        (0.20, 100.0),  # larger time step edge case\n    ]\n    # initial conditions in reduced units: m=1, k=1, omega=1\n    q0 = 1.0\n    v0 = 0.0\n\n    results = []\n    for dt, T in test_cases:\n        # Forward Euler\n        t_eu, e_eu = forward_euler_ho(q0, v0, dt, T)\n        slope_eu = linear_regression_slope(t_eu, e_eu)\n        # Velocity Verlet\n        t_vv, e_vv = velocity_verlet_ho(q0, v0, dt, T)\n        slope_vv = linear_regression_slope(t_vv, e_vv)\n        results.append([slope_eu, slope_vv])\n\n    # Final print statement in the exact required format.\n    # Print as a list of lists: [[s_eu1,s_vv1],[s_eu2,s_vv2],[s_eu3,s_vv3]]\n    # Convert floats to repr to avoid scientific notation quirks; default str is fine.\n    def fmt_pair(pair):\n        return \"[\" + \",\".join(map(str, pair)) + \"]\"\n    print(\"[\" + \",\".join(fmt_pair(r) for r in results) + \"]\")\n\nsolve()\n```"
        }
    ]
}