{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在引导您从头开始构建一个简化的自洽场 (Self-Consistent Field, SCF) 模型。通过这个实践，您将深入理解基组在Hartree-Fock计算中的基础性作用，特别是，您将量化地分析增加极化函数 (polarization functions) 如何改善对催化中心各向异性成键环境的描述，这是精确模拟催化过程的关键一步。",
            "id": "3882509",
            "problem": "您将以原子单位（能量单位为 hartree，长度单位为 bohr）实现一个最小自洽场模型，以量化一个受到各向异性配体场作用的模型催化金属位点，在从双 zeta (DZ) 基组转变为双 zeta 加极化 (DZP) 基组时，Hartree-Fock (HF) 总能量如何变化。该体系是位于原点的单个有效金属中心，具有两个电子，处于闭壳层、自旋限制的构型。各向异性环境通过一个电荷为 $q$ 的外部点配体来建模，该配体沿 $x$ 轴放置在距离原点 $R$ 的位置，它会诱导 $s$-类和 $p_x$-类价壳层特征之间的混合。您将使用一种简化但标准的平均场近似来计算 HF 基态能量，并量化当包含极化函数时所产生的能量差 $\\Delta E = E_{\\mathrm{DZP}} - E_{\\mathrm{DZ}}$。\n\n基本原理：\n- 限制性 Hartree-Fock (RHF) 能量由下式给出\n$$\nE = \\sum_{\\mu\\nu} P_{\\mu\\nu} h_{\\mu\\nu} + \\tfrac{1}{2} \\sum_{\\mu\\nu} P_{\\mu\\nu} \\left(F_{\\mu\\nu} - h_{\\mu\\nu}\\right),\n$$\n其中 $P$ 是自旋求和的密度矩阵，$h$ 是单电子哈密顿矩阵，$F$ 是 Fock 矩阵。对于具有 $N$ 个电子的闭壳层，RHF 密度矩阵为\n$$\nP = 2 \\sum_{i=1}^{N/2} \\mathbf{c}_i \\mathbf{c}_i^\\top,\n$$\n其中 $\\mathbf{c}_i$ 是正交归一基组中的已占据分子轨道系数向量。Fock 矩阵为\n$$\nF_{\\mu\\nu} = h_{\\mu\\nu} + \\sum_{\\lambda\\sigma} P_{\\lambda\\sigma} \\left[(\\mu\\nu|\\lambda\\sigma) - \\tfrac{1}{2}(\\mu\\sigma|\\lambda\\nu)\\right]。\n$$\n\n模型近似与定义：\n- 基组：\n  - DZ 基组：位于金属中心的两个正交归一的 $s$-类函数，用索引 $\\mu \\in \\{s_1, s_2\\}$ 表示，代表双 zeta 描述。\n  - DZP 基组：DZ 基组增加了三个正交归一的 $p$-类函数 $\\mu \\in \\{p_x, p_y, p_z\\}$，代表极化。\n- 单电子哈密顿量 $h$：\n  - 在位能量：$h_{s_1 s_1} = \\varepsilon_{s_1}$，$h_{s_2 s_2} = \\varepsilon_{s_2}$，$h_{pp} = \\varepsilon_p$ 对于 $p \\in \\{p_x, p_y, p_z\\}$。\n  - 金属 $s$–$s$ 相互作用：$h_{s_1 s_2} = h_{s_2 s_1} = t_{ss}$。\n  - 配体诱导的各向异性混合：只有 $h_{s_1 p_x}$ 和 $h_{s_2 p_x}$ 非零，由下式给出\n  $$\n  h_{s_1 p_x} = w_1 V(q,R), \\quad h_{s_2 p_x} = w_2 V(q,R),\n  $$\n  其中 $V(q,R) = A q \\exp(-\\kappa R)$。所有其他非对角单电子矩阵元均为零。对于 DZ 基组，不存在 $p$-类函数，因此只有 $s$ 块出现。\n- 双电子相互作用使用一种Complete Neglect of Differential Overlap (CNDO)风格的近似：\n  - 定义在位库仑参数 $U_{s_1}$、$U_{s_2}$、$U_p$ 和轨道间有效库仑相互作用\n  $$\n  \\gamma_{\\mu\\nu} = \n  \\begin{cases}\n  U_\\mu,  & \\mu=\\nu \\\\\n  \\dfrac{1}{\\dfrac{1}{U_\\mu} + \\dfrac{1}{U_\\nu}}, & \\mu \\neq \\nu\n  \\end{cases}\n  $$\n  - Fock 矩阵近似为\n  $$\n  F_{\\mu\\nu} = h_{\\mu\\nu} + \\delta_{\\mu\\nu} \\sum_{\\lambda} P_{\\lambda\\lambda}\\,\\gamma_{\\mu\\lambda} - \\tfrac{1}{2} P_{\\mu\\nu}\\,\\gamma_{\\mu\\nu},\n  $$\n  其中 $\\delta_{\\mu\\nu}$ 是克罗内克 δ。这以平均场的方式在单个位点上捕捉了库仑和交换效应。\n- 正交性：基组是正交归一的，因此重叠矩阵是单位矩阵。\n\n模型常数（原子单位）：\n- 单电子参数：$\\varepsilon_{s_1} = -0.80$, $\\varepsilon_{s_2} = -0.40$, $\\varepsilon_{p} = +0.10$, $t_{ss} = -0.25$。\n- 库仑参数：$U_{s_1} = 0.90$, $U_{s_2} = 0.70$, $U_{p} = 0.60$。\n- 配体耦合参数：$A = 0.50$, $\\kappa = 0.80$，权重 $w_1 = 0.60$, $w_2 = 1.00$。\n\n数值任务：\n- 实现一个自洽场程序，对于给定的 $(q,R)$，构建 DZ 哈密顿量并求解 RHF 方程以获得 $E_{\\mathrm{DZ}}$，然后构建 DZP 哈密顿量并求解 RHF 方程以获得 $E_{\\mathrm{DZP}}$。在这两种情况下都使用两个电子（闭壳层）。使用 Fock 矩阵的迭代对角化方法，并采用密度混合（阻尼），直到密度矩阵变化的 Frobenius 范数小于 $10^{-10}$ 或达到最大 $500$ 次迭代为止。\n- 计算并报告能量差\n$$\n\\Delta E(q,R) = E_{\\mathrm{DZP}}(q,R) - E_{\\mathrm{DZ}}(q,R),\n$$\n单位为 hartree，四舍五入到六位小数。\n\n测试集：\n- 使用以下测试用例（以原子单位计）：\n  1. $(q,R) = (-0.8, 1.5)$，\n  2. $(q,R) = (-0.8, 5.0)$，\n  3. $(q,R) = (0.0, 2.0)$，\n  4. $(q,R) = (-1.2, 1.0)$。\n这些用例涵盖了中等各向异性、弱场远配体极限、各向同性极限和强各向异性情况。\n\n程序输出规范：\n- 您的程序应生成单行输出，其中包含四个结果，以逗号分隔并用方括号括起来，例如，“[x1,x2,x3,x4]”。\n- 每个 $x_i$ 必须是浮点数，单位为 hartree，四舍五入到六位小数。不使用角度。不使用百分比。根据设计，物理单位是原子单位，无需打印，但数值以 hartree 为单位。",
            "solution": "该问题要求实现一个最小限制性 Hartree-Fock (RHF) 自洽场 (SCF) 模型，以计算模型催化位点的能量差 $\\Delta E = E_{\\mathrm{DZP}} - E_{\\mathrm{DZ}}$。该能量差量化了在外部配体场影响下，将极化函数（$p$-轨道）添加到双 zeta（$s$-轨道）基组时其所带来的能量贡献。整个模型均以原子单位定义。\n\n解决方案的开发首先基于所提供的模型近似来形式化 RHF 计算的各个组成部分，然后实现迭代 SCF 程序。\n\n**1. RHF 形式体系与模型特定矩阵**\n\n闭壳层体系的总 RHF 能量由下式给出：\n$$\nE = \\frac{1}{2} \\sum_{\\mu\\nu} P_{\\mu\\nu} (h_{\\mu\\nu} + F_{\\mu\\nu}) = \\frac{1}{2} \\mathrm{Tr}(\\mathbf{P}(\\mathbf{h} + \\mathbf{F}))\n$$\n其中 $\\mathbf{P}$ 是密度矩阵，$\\mathbf{h}$ 是单电子核心哈密顿矩阵，$\\mathbf{F}$ 是 Fock 矩阵。\n\n该体系包含 $N=2$ 个电子，因此密度矩阵由单个已占据分子轨道 (MO) $\\mathbf{c}_1$ 构建，该轨道对应于最低的轨道能量：\n$$\n\\mathbf{P} = 2 \\mathbf{c}_1 \\mathbf{c}_1^\\top\n$$\n\nFock 矩阵 $\\mathbf{F}$ 代表了在所有其他电子的平均场中的有效单电子哈密顿量，它由模型的 CNDO-风格近似定义：\n$$\nF_{\\mu\\nu} = h_{\\mu\\nu} + \\delta_{\\mu\\nu} \\sum_{\\lambda} P_{\\lambda\\lambda}\\,\\gamma_{\\mu\\lambda} - \\tfrac{1}{2} P_{\\mu\\nu}\\,\\gamma_{\\mu\\nu}\n$$\n这可以表示为矩阵形式 $\\mathbf{F} = \\mathbf{h} + \\mathbf{J} - \\mathbf{K}$，其中库仑矩阵 $\\mathbf{J}$ 和交换矩阵 $\\mathbf{K}$ 由下式给出：\n$$\nJ_{\\mu\\nu} = \\delta_{\\mu\\nu} \\sum_{\\lambda} P_{\\lambda\\lambda}\\,\\gamma_{\\mu\\lambda}, \\quad K_{\\mu\\nu} = \\tfrac{1}{2} P_{\\mu\\nu}\\,\\gamma_{\\mu\\nu}\n$$\n基组是正交归一的，这可将 RHF 方程简化为标准特征值问题 $\\mathbf{F}\\mathbf{C} = \\mathbf{C}\\boldsymbol{\\epsilon}$。\n\n**2. 矩阵构建**\n\n实现的核心是为 DZ 和 DZP 基组构建 $\\mathbf{h}$ 和 $\\gamma$ 矩阵。\n\n**基组：**\n-   **DZ (双 Zeta)：**一个二维基组 $\\{\\phi_1, \\phi_2\\} = \\{s_1, s_2\\}$。\n-   **DZP (双 Zeta + 极化)：**一个五维基组 $\\{\\phi_1, ... \\phi_5\\} = \\{s_1, s_2, p_x, p_y, p_z\\}$。\n\n**单电子哈密顿矩阵 ($\\mathbf{h}$):**\n$\\mathbf{h}$ 矩阵包含一个电子在原子核和外部配体场中的动能和势能。\n- 对于 DZ 基组，$\\mathbf{h}$ 是一个 $2 \\times 2$ 的矩阵：\n$$\n\\mathbf{h}_{\\mathrm{DZ}} = \\begin{pmatrix} \\varepsilon_{s_1} & t_{ss} \\\\ t_{ss} & \\varepsilon_{s_2} \\end{pmatrix} = \\begin{pmatrix} -0.80 & -0.25 \\\\ -0.25 & -0.40 \\end{pmatrix}\n$$\n- 对于 DZP 基组，配体势 $V(q,R) = A q \\exp(-\\kappa R)$ 诱导了 $s$ 轨道和 $p_x$ 轨道之间的耦合。$\\mathbf{h}$ 矩阵是一个 $5 \\times 5$ 的矩阵，其索引顺序为 $(s_1, s_2, p_x, p_y, p_z)$：\n$$\n\\mathbf{h}_{\\mathrm{DZP}} = \\begin{pmatrix}\n\\varepsilon_{s_1} & t_{ss} & w_1 V(q,R) & 0 & 0 \\\\\nt_{ss} & \\varepsilon_{s_2} & w_2 V(q,R) & 0 & 0 \\\\\nw_1 V(q,R) & w_2 V(q,R) & \\varepsilon_p & 0 & 0 \\\\\n0 & 0 & 0 & \\varepsilon_p & 0 \\\\\n0 & 0 & 0 & 0 & \\varepsilon_p\n\\end{pmatrix}\n$$\n使用给定的常数：$\\varepsilon_{s_1}=-0.80, \\varepsilon_{s_2}=-0.40, \\varepsilon_p=0.10, t_{ss}=-0.25, A=0.50, \\kappa=0.80, w_1=0.60, w_2=1.00$。矩阵元 $h_{s_1 p_x}$ 和 $h_{s_2 p_x}$ 取决于具体的 $(q,R)$ 情况。\n\n**双电子相互作用矩阵 ($\\boldsymbol{\\gamma}$):**\n$\\boldsymbol{\\gamma}$ 矩阵存储了有效库仑相互作用参数。\n$$\n \\gamma_{\\mu\\nu} = \n  \\begin{cases}\n  U_\\mu, & \\mu=\\nu \\\\\n  \\frac{U_\\mu U_\\nu}{U_\\mu + U_\\nu}, & \\mu \\neq \\nu\n  \\end{cases}\n$$\n在位参数为 $U_{s_1} = 0.90$，$U_{s_2} = 0.70$，$U_p = 0.60$。这个对称矩阵是为相应的基组维度（DZ 为 $2 \\times 2$，DZP 为 $5 \\times 5$）构建的。\n\n**3. 自洽场 (SCF) 算法**\n\nRHF 方程被迭代求解，直到电子密度达到自洽。对于每个基组和每个 $(q,R)$ 对，算法流程如下：\n\n1.  **初始化：**构建常数矩阵 $\\mathbf{h}$ 和 $\\boldsymbol{\\gamma}$。将密度矩阵 $\\mathbf{P}$ 初始化为零矩阵。\n2.  **迭代循环：**最多重复 $500$ 次迭代：\n    a. **构建 Fock 矩阵：**使用当前密度矩阵 $\\mathbf{P}$ 构建 Fock 矩阵 $\\mathbf{F} = \\mathbf{h} + \\mathbf{J} - \\mathbf{K}$。库仑项 $\\mathbf{J}$ 是一个对角矩阵，其元素计算为 $J_{\\mu\\mu} = (\\boldsymbol{\\gamma} \\cdot \\mathrm{diag}(\\mathbf{P}))_\\mu$，交换项为 $\\mathbf{K} = \\frac{1}{2} \\mathbf{P} \\odot \\boldsymbol{\\gamma}$（逐元素乘积）。\n    b. **求解特征值问题：**对角化 Fock 矩阵，$\\mathbf{F}\\mathbf{C} = \\mathbf{C}\\boldsymbol{\\epsilon}$，以获得 MO 能量 $\\boldsymbol{\\epsilon}$ 和 MO 系数 $\\mathbf{C}$。由于 $\\mathbf{F}$ 是一个实对称矩阵，因此使用 `scipy.linalg.eigh`。\n    c. **形成新的密度矩阵：**识别与最低特征值对应的 MO 系数向量 $\\mathbf{c}_1$。构建新的密度矩阵 $\\mathbf{P}_{\\text{new}} = 2 \\mathbf{c}_1 \\mathbf{c}_1^\\top$。\n    d. **检查收敛性：**计算新旧密度矩阵之差的 Frobenius 范数，$\\|\\mathbf{P}_{\\text{new}} - \\mathbf{P}\\|_F$。如果该范数低于 $10^{-10}$ 的阈值，则 SCF 已收敛。\n    e. **密度混合：**为改善收敛性，通过混合新旧矩阵来形成下一次迭代的密度矩阵：$\\mathbf{P} \\leftarrow (1-\\alpha)\\mathbf{P} + \\alpha\\mathbf{P}_{\\text{new}}$，其中使用阻尼因子 $\\alpha=0.5$。\n3.  **能量计算：**收敛后，使用收敛的密度矩阵 $\\mathbf{P}$ 和最终的 Fock 矩阵 $\\mathbf{F}$，通过公式 $E = \\frac{1}{2} \\mathrm{Tr}(\\mathbf{P}(\\mathbf{h} + \\mathbf{F}))$ 计算最终能量。\n\n**4. 最终计算**\n\n对于测试集中的每个 $(q,R)$ 对，SCF 程序执行两次：一次用于 DZ 基组以获得 $E_{\\mathrm{DZ}}$，一次用于 DZP 基组以获得 $E_{\\mathrm{DZP}}$。然后计算所需的能量差 $\\Delta E = E_{\\mathrm{DZP}} - E_{\\mathrm{DZ}}$，四舍五入到六位小数，并进行报告。对于 $(q,R)=(0.0, 2.0)$ 的情况，配体场 $V$ 为零，导致 $s$ 和 $p$ 轨道之间没有耦合。因此，两个基组的收敛能量应该相同，得出 $\\Delta E=0$，这可作为一个有价值的一致性检查。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to solve the specified RHF problem for a set of test cases.\n    \"\"\"\n\n    # --- Model Constants (atomic units) ---\n    # One-electron parameters\n    EPS_S1 = -0.80\n    EPS_S2 = -0.40\n    EPS_P = 0.10\n    T_SS = -0.25\n    # Coulomb parameters\n    U_S1 = 0.90\n    U_S2 = 0.70\n    U_P = 0.60\n    # Ligand coupling parameters\n    A = 0.50\n    KAPPA = 0.80\n    W1 = 0.60\n    W2 = 1.00\n\n    # --- SCF Parameters ---\n    MAX_ITER = 500\n    CONV_THRESH = 1e-10\n    DAMPING_FACTOR = 0.5\n    NUM_ELECTRONS = 2\n\n    def compute_hf_energy(q, r, basis_type):\n        \"\"\"\n        Performs the RHF-SCF calculation for a given basis and ligand parameters.\n        \"\"\"\n        if basis_type == 'DZ':\n            n_basis = 2\n            u_vals = np.array([U_S1, U_S2])\n        elif basis_type == 'DZP':\n            n_basis = 5\n            u_vals = np.array([U_S1, U_S2, U_P, U_P, U_P])\n        else:\n            raise ValueError(\"Invalid basis_type specified.\")\n\n        # --- Build Core Hamiltonian (h) ---\n        h = np.zeros((n_basis, n_basis))\n        h[0, 0] = EPS_S1\n        h[1, 1] = EPS_S2\n        h[0, 1] = h[1, 0] = T_SS\n\n        if basis_type == 'DZP':\n            h[2, 2] = h[3, 3] = h[4, 4] = EPS_P\n            # Ligand-induced mixing\n            v_qr = A * q * np.exp(-KAPPA * r)\n            h[0, 2] = h[2, 0] = W1 * v_qr  # s1-px\n            h[1, 2] = h[2, 1] = W2 * v_qr  # s2-px\n\n        # --- Build Two-Electron Interaction Matrix (gamma) ---\n        gamma = np.zeros((n_basis, n_basis))\n        for i in range(n_basis):\n            for j in range(n_basis):\n                if i == j:\n                    gamma[i, j] = u_vals[i]\n                else:\n                    gamma[i, j] = (u_vals[i] * u_vals[j]) / (u_vals[i] + u_vals[j])\n\n        # --- SCF Iteration Loop ---\n        p_matrix = np.zeros((n_basis, n_basis))\n\n        for i in range(MAX_ITER):\n            # Build Fock Matrix (F = h + G)\n            # G_mu_nu = delta_mu_nu * sum_lambda(P_lambda_lambda * gamma_mu_lambda) - 0.5 * P_mu_nu * gamma_mu_nu\n            p_diag = np.diag(p_matrix)\n            j_matrix_diag = gamma @ p_diag\n            j_matrix = np.diag(j_matrix_diag)\n            k_matrix = 0.5 * p_matrix * gamma\n            fock_matrix = h + j_matrix - k_matrix\n\n            # Solve Roothaan-Hall equations (FC = SCe, S=I)\n            eigvals, eigvecs = linalg.eigh(fock_matrix)\n\n            # Form new density matrix from the lowest energy orbital\n            c1 = eigvecs[:, 0]  # First column is the eigenvector for the lowest eigenvalue\n            p_new = NUM_ELECTRONS * np.outer(c1, c1)\n\n            # Check for convergence\n            delta_p_norm = np.linalg.norm(p_new - p_matrix)\n            if delta_p_norm < CONV_THRESH:\n                p_matrix = p_new\n                break\n\n            # Damping to aid convergence\n            p_matrix = (1 - DAMPING_FACTOR) * p_matrix + DAMPING_FACTOR * p_new\n        \n        # --- Calculate Final Total Energy ---\n        # Final Fock matrix from converged density\n        p_diag = np.diag(p_matrix)\n        j_matrix_diag = gamma @ p_diag\n        j_matrix = np.diag(j_matrix_diag)\n        k_matrix = 0.5 * p_matrix * gamma\n        final_fock_matrix = h + j_matrix - k_matrix\n        \n        energy = 0.5 * np.sum(p_matrix * (h + final_fock_matrix))\n        \n        return energy\n    \n    # --- Test Suite ---\n    test_cases = [\n        (-0.8, 1.5),\n        (-0.8, 5.0),\n        (0.0, 2.0),\n        (-1.2, 1.0),\n    ]\n\n    results = []\n    for q_val, r_val in test_cases:\n        e_dz = compute_hf_energy(q_val, r_val, 'DZ')\n        e_dzp = compute_hf_energy(q_val, r_val, 'DZP')\n        delta_e = e_dzp - e_dz\n        results.append(f\"{delta_e:.6f}\") # Format to 6 decimal places\n\n    # --- Print Final Output ---\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在Hartree-Fock理论的基础上，本练习将我们带入电子相关的领域，这在平均场近似中是被忽略的。您将应用Møller-Plesset二阶 (MP2) 微扰理论公式，计算电子相关对物理吸附体系结合能的贡献，从而深入理解如色散力这类对于弱相互作用至关重要的物理现象。",
            "id": "3882483",
            "problem": "一个催化表面上的弱键合物理吸附物在 Hartree-Fock 平均场内被建模为一个由正则分子轨道构成的闭壳层体系。需要计算由于电子相关引起的对 Hartree-Fock 结合能的二阶校正（Møller-Plesset 二阶，源于在 Hartree-Fock 参考态基础上的二阶 Rayleigh-Schrödinger 微扰理论）。Hartree-Fock 结合能校正定义为吸附物-表面复合物与分离的片段（即表面和吸附物）之间的相关能之差。正则轨道能用 $\\epsilon_p$ 表示，分子轨道基下的电子排斥积分以反对称化的双电子积分 $\\langle ij \\Vert ab \\rangle$ 的形式给出，单位为哈特里。在闭壳层 Hartree-Fock 参考态中，轨道指数 $i,j$ 表示已占据的分子轨道，$a,b$ 表示虚拟分子轨道。\n\n从以下经过充分检验的基本原理出发：\n- Hartree-Fock 方法提供了一个平均场参考态，该参考态是零阶哈密顿量的一个本征态，具有正则分子轨道和轨道能 $\\epsilon_p$。\n- 在 Hartree-Fock 参考态基础上的二阶 Rayleigh-Schrödinger 微扰理论，从双激发中得出一个相关能校正，其中能量分母是已占据和虚拟轨道能量之和的差值，耦合由参考态和双激发行列式之间的电子-电子相互作用算符的矩阵元给出。\n- 由于电子相关引起的总结合能校正计算为 $E_{\\text{corr}}^{(2)}(\\text{complex}) - E_{\\text{corr}}^{(2)}(\\text{surface}) - E_{\\text{corr}}^{(2)}(\\text{adsorbate})$。\n\n您必须：\n1. 从所提供的数据推导出计算相关能二阶校正的算法，并将其应用于每个体系。\n2. 计算 Hartree-Fock 结合能的校正，即复合物与分离片段之间的差值。\n3. 计算类色散项的相对贡献。此处类色散项定义为复合物中的那些二阶贡献，其中已占据-虚拟激发对是片段定域的，并且跨越两个片段配对，具体而言，片段标签满足 $\\text{frag}(i)=\\text{frag}(a)\\neq\\text{frag}(j)=\\text{frag}(b)$。使用幅值比 $\\frac{\\left|E_{\\text{inter}}^{(2)}(\\text{complex})\\right|}{\\left|E_{\\text{bind}}^{(2)}\\right|}$，其中 $E_{\\text{inter}}^{(2)}(\\text{complex})$ 仅为复合物中类色散贡献之和，$E_{\\text{bind}}^{(2)}$ 是上面定义的结合能校正。如果 $\\left|E_{\\text{bind}}^{(2)}\\right|=0$，按惯例将此比率定义为 $0.0$。\n\n您的程序必须以千焦/摩尔为单位生成结合能校正的结果。使用转换关系 $1$ 哈特里 $= 2625.49962$ 千焦/摩尔。将结合能校正表示为千焦/摩尔，保留六位小数；将色散贡献比率表示为小数，保留六位小数。\n\n为以下测试套件实现计算。下面的每个系统由以下内容完全指定：\n- 轨道能列表 $\\{\\epsilon_p\\}$，单位为哈特里。\n- 已占据和虚拟轨道指数的列表。\n- 非零反对称化双电子积分 $\\langle ij \\Vert ab \\rangle$ 的字典，单位为哈特里，键为元组 $(i,j,a,b)$，其中 $i<j, a<b$。\n- （仅对复合物）片段标签列表，将每个分子轨道分配给表面（标签0）或吸附物（标签1）。\n\n测试套件：\n- 用例1（标准情况）：\n  - 复合物：`energies` = `[-0.40, -0.30, 0.10, 0.20, -0.50, -0.35, 0.15, 0.25]`，`occupied_indices` = `[0, 1, 4, 5]`，`virtual_indices` = `[2, 3, 6, 7]`，`frag_labels` = `[0, 0, 0, 0, 1, 1, 1, 1]`，`integrals` = `{(0, 1, 2, 3): 0.050, (4, 5, 6, 7): 0.045, (0, 4, 2, 6): 0.012, (0, 4, 3, 7): 0.010, (1, 5, 2, 7): 0.011, (1, 5, 3, 6): 0.009, (0, 5, 2, 7): 0.008, (1, 4, 3, 6): 0.007}`。\n  - 吸附物：`energies` = `[-0.41, -0.29, 0.12, 0.21]`，`occupied_indices` = `[0, 1]`，`virtual_indices` = `[2, 3]`，`integrals` = `{(0, 1, 2, 3): 0.052}`。\n  - 表面：`energies` = `[-0.51, -0.34, 0.16, 0.27]`，`occupied_indices` = `[0, 1]`，`virtual_indices` = `[2, 3]`，`integrals` = `{(0, 1, 2, 3): 0.046}`。\n- 用例2（边界情况：没有片段间相互作用）：\n  - 复合物：`energies` = `[-0.41, -0.29, 0.12, 0.21, -0.51, -0.34, 0.16, 0.27]`，`occupied_indices` = `[0, 1, 4, 5]`，`virtual_indices` = `[2, 3, 6, 7]`，`frag_labels` = `[0, 0, 0, 0, 1, 1, 1, 1]`，`integrals` = `{(0, 1, 2, 3): 0.052, (4, 5, 6, 7): 0.046}`。\n  - 吸附物：`energies` = `[-0.41, -0.29, 0.12, 0.21]`，`occupied_indices` = `[0, 1]`，`virtual_indices` = `[2, 3]`，`integrals` = `{(0, 1, 2, 3): 0.052}`。\n  - 表面：`energies` = `[-0.51, -0.34, 0.16, 0.27]`，`occupied_indices` = `[0, 1]`，`virtual_indices` = `[2, 3]`，`integrals` = `{(0, 1, 2, 3): 0.046}`。\n- 用例3（极端情况：只有片段间相互作用）：\n  - 复合物：`energies` = `[-0.40, -0.30, 0.10, 0.20, -0.50, -0.35, 0.15, 0.25]`，`occupied_indices` = `[0, 1, 4, 5]`，`virtual_indices` = `[2, 3, 6, 7]`，`frag_labels` = `[0, 0, 0, 0, 1, 1, 1, 1]`，`integrals` = `{(0, 4, 2, 6): 0.012, (0, 4, 3, 7): 0.010, (1, 5, 2, 7): 0.011, (1, 5, 3, 6): 0.009, (0, 5, 2, 7): 0.008, (1, 4, 3, 6): 0.007}`。\n  - 吸附物：`energies` = `[-0.41, -0.29, 0.12, 0.21]`，`occupied_indices` = `[0, 1]`，`virtual_indices` = `[2, 3]`，`integrals` = `{}`。\n  - 表面：`energies` = `[-0.51, -0.34, 0.16, 0.27]`，`occupied_indices` = `[0, 1]`，`virtual_indices` = `[2, 3]`，`integrals` = `{}`。\n\n输出规范：\n- 您的程序应生成一个用方括号括起来的逗号分隔列表，格式为 `[[binding_energy1,dispersion_ratio1],[binding_energy2,dispersion_ratio2],...]`。每个子列表包含一个测试用例的两个结果，顺序与上面列出的用例相同。",
            "solution": "该问题要求计算物理吸附体系的二阶 Møller-Plesset (MP2) 结合能校正，以及类色散能项的相对贡献。整个分析基于闭壳层体系的 Hartree-Fock 参考态。\n\n首先，我们建立 MP2 相关能 $E_{\\text{corr}}^{(2)}$ 的基本公式。该能量校正源于二阶 Rayleigh-Schrödinger 微扰理论，其中未微扰体系是 Hartree-Fock 基态，微扰是涨落势（真实电子-电子排斥与平均场 Hartree-Fock 势之差）。对于闭壳层体系，MP2 能量是所有可能的从已占据分子轨道（MOs，由 $i$ 和 $j$ 索引）到虚拟 MOs（由 $a$ 和 $b$ 索引）的双激发贡献的总和。根据问题提供的反对称化双电子积分 $\\langle ij \\Vert ab \\rangle$ 和求和范围，本练习中使用的 MP2 相关能校正公式为：\n$$\nE_{\\text{corr}}^{(2)} = \\sum_{\\substack{i<j \\\\ a<b}} \\frac{|\\langle ij \\Vert ab \\rangle|^2}{\\epsilon_i + \\epsilon_j - \\epsilon_a - \\epsilon_b}\n$$\n其中求和遍历输入数据中提供的所有积分。这是标准 MP2 能量在特定模型下的一种简化计算。\n\nMP2 结合能校正 $E_{\\text{bind}}^{(2)}$ 定义为复合物的相关能与分离的片段（吸附物和表面）相关能之差：\n$$\nE_{\\text{bind}}^{(2)} = E_{\\text{corr}}^{(2)}(\\text{complex}) - \\left( E_{\\text{corr}}^{(2)}(\\text{adsorbate}) + E_{\\text{corr}}^{(2)}(\\text{surface}) \\right)\n$$\n这个量表示了由于电子相关效应，复合物相对于其分离组分获得的额外稳定性（或不稳定性）。\n\n接下来，我们计算“类色散项”的贡献。根据问题定义，这部分能量 $E_{\\text{inter}}^{(2)}(\\text{complex})$ 仅包含复合物计算中那些源于两个不同片段上同时发生的激发的项。具体来说，一个贡献被视为类色散项，当且仅当其涉及的轨道满足条件：$\\text{frag}(i)=\\text{frag}(a) \\neq \\text{frag}(j)=\\text{frag}(b)$。这意味着激发过程涉及一个电子在片段A内从占据轨道移动到虚拟轨道，同时另一个电子在片段B内发生类似过程。\n\n最后，计算类色散项对总结合能校正的幅值比率：\n$$\n\\text{Ratio} = \\frac{\\left|E_{\\text{inter}}^{(2)}(\\text{complex})\\right|}{\\left|E_{\\text{bind}}^{(2)}\\right|}\n$$\n如果 $E_{\\text{bind}}^{(2)}$ 为零，则该比率也定义为零。\n\n计算流程如下：\n1.  为复合物、吸附物和表面分别编写一个函数，使用上述简化的 MP2 公式计算各自的 $E_{\\text{corr}}^{(2)}$。\n2.  使用步骤1的结果计算 $E_{\\text{bind}}^{(2)}$。\n3.  为复合物编写一个函数，根据片段标签筛选并累加类色散项的贡献，得到 $E_{\\text{inter}}^{(2)}$。\n4.  计算最终的比率。\n5.  将 $E_{\\text{bind}}^{(2)}$ 从 hartree 转换为 kJ/mol 并按要求格式化输出。",
            "answer": "```python\nimport numpy as np\n\n# Note: The problem statement allows for numpy but not for scipy.\n# The calculation can be completed with numpy and standard Python libraries.\n\ndef solve():\n    \"\"\"\n    Solves the computational chemistry problem for the given test suite.\n    \"\"\"\n    HARTREE_TO_KJ_MOL = 2625.49962\n\n    test_cases = [\n        # Test case 1 (happy path)\n        {\n            \"complex\": {\n                \"energies\": [-0.40, -0.30, 0.10, 0.20, -0.50, -0.35, 0.15, 0.25],\n                \"occupied_indices\": [0, 1, 4, 5],\n                \"virtual_indices\": [2, 3, 6, 7],\n                \"frag_labels\": [0, 0, 0, 0, 1, 1, 1, 1],\n                \"integrals\": {\n                    (0, 1, 2, 3): 0.050,\n                    (4, 5, 6, 7): 0.045,\n                    (0, 4, 2, 6): 0.012,\n                    (0, 4, 3, 7): 0.010,\n                    (1, 5, 2, 7): 0.011,\n                    (1, 5, 3, 6): 0.009,\n                    (0, 5, 2, 7): 0.008,\n                    (1, 4, 3, 6): 0.007,\n                },\n            },\n            \"adsorbate\": {\n                \"energies\": [-0.41, -0.29, 0.12, 0.21],\n                \"occupied_indices\": [0, 1],\n                \"virtual_indices\": [2, 3],\n                \"integrals\": {(0, 1, 2, 3): 0.052},\n            },\n            \"surface\": {\n                \"energies\": [-0.51, -0.34, 0.16, 0.27],\n                \"occupied_indices\": [0, 1],\n                \"virtual_indices\": [2, 3],\n                \"integrals\": {(0, 1, 2, 3): 0.046},\n            },\n        },\n        # Test case 2 (boundary case)\n        {\n            \"complex\": {\n                \"energies\": [-0.41, -0.29, 0.12, 0.21, -0.51, -0.34, 0.16, 0.27],\n                \"occupied_indices\": [0, 1, 4, 5],\n                \"virtual_indices\": [2, 3, 6, 7],\n                \"frag_labels\": [0, 0, 0, 0, 1, 1, 1, 1],\n                \"integrals\": {(0, 1, 2, 3): 0.052, (4, 5, 6, 7): 0.046},\n            },\n            \"adsorbate\": {\n                \"energies\": [-0.41, -0.29, 0.12, 0.21],\n                \"occupied_indices\": [0, 1],\n                \"virtual_indices\": [2, 3],\n                \"integrals\": {(0, 1, 2, 3): 0.052},\n            },\n            \"surface\": {\n                \"energies\": [-0.51, -0.34, 0.16, 0.27],\n                \"occupied_indices\": [0, 1],\n                \"virtual_indices\": [2, 3],\n                \"integrals\": {(0, 1, 2, 3): 0.046},\n            },\n        },\n        # Test case 3 (edge case)\n        {\n            \"complex\": {\n                \"energies\": [-0.40, -0.30, 0.10, 0.20, -0.50, -0.35, 0.15, 0.25],\n                \"occupied_indices\": [0, 1, 4, 5],\n                \"virtual_indices\": [2, 3, 6, 7],\n                \"frag_labels\": [0, 0, 0, 0, 1, 1, 1, 1],\n                \"integrals\": {\n                    (0, 4, 2, 6): 0.012,\n                    (0, 4, 3, 7): 0.010,\n                    (1, 5, 2, 7): 0.011,\n                    (1, 5, 3, 6): 0.009,\n                    (0, 5, 2, 7): 0.008,\n                    (1, 4, 3, 6): 0.007,\n                },\n            },\n            \"adsorbate\": {\n                \"energies\": [-0.41, -0.29, 0.12, 0.21],\n                \"occupied_indices\": [0, 1],\n                \"virtual_indices\": [2, 3],\n                \"integrals\": {},\n            },\n            \"surface\": {\n                \"energies\": [-0.51, -0.34, 0.16, 0.27],\n                \"occupied_indices\": [0, 1],\n                \"virtual_indices\": [2, 3],\n                \"integrals\": {},\n            },\n        },\n    ]\n\n    def compute_mp2(energies, integrals):\n        e_corr = 0.0\n        for (i, j, a, b), value in integrals.items():\n            denominator = energies[i] + energies[j] - energies[a] - energies[b]\n            if abs(denominator) > 1e-12:\n                e_corr += (value**2) / denominator\n        return e_corr\n\n    def compute_dispersion(energies, integrals, frag_labels):\n        e_inter = 0.0\n        for (i, j, a, b), value in integrals.items():\n            # Check for the specific dispersion condition from the problem statement\n            is_dispersion_case1 = (\n                frag_labels[i] == frag_labels[a] and\n                frag_labels[j] == frag_labels[b] and\n                frag_labels[i] != frag_labels[j]\n            )\n            # The definition is symmetric, so we must check the other pairing too\n            is_dispersion_case2 = (\n                frag_labels[i] == frag_labels[b] and\n                frag_labels[j] == frag_labels[a] and\n                frag_labels[i] != frag_labels[j]\n            )\n            \n            if is_dispersion_case1 or is_dispersion_case2:\n                denominator = energies[i] + energies[j] - energies[a] - energies[b]\n                if abs(denominator) > 1e-12:\n                    e_inter += (value**2) / denominator\n        return e_inter\n\n    all_results = []\n    for case in test_cases:\n        # Calculate correlation energies for all three systems\n        e_corr_complex = compute_mp2(case[\"complex\"][\"energies\"], case[\"complex\"][\"integrals\"])\n        e_corr_adsorbate = compute_mp2(case[\"adsorbate\"][\"energies\"], case[\"adsorbate\"][\"integrals\"])\n        e_corr_surface = compute_mp2(case[\"surface\"][\"energies\"], case[\"surface\"][\"integrals\"])\n\n        # Calculate the binding energy correction\n        e_bind_hartree = e_corr_complex - e_corr_adsorbate - e_corr_surface\n        e_bind_kjmol = e_bind_hartree * HARTREE_TO_KJ_MOL\n\n        # Calculate the dispersion-like energy for the complex\n        e_inter_hartree = compute_dispersion(case[\"complex\"][\"energies\"], case[\"complex\"][\"integrals\"], case[\"complex\"][\"frag_labels\"])\n\n        # Calculate the dispersion ratio\n        if abs(e_bind_hartree)  1e-12:\n            dispersion_ratio = 0.0\n        else:\n            dispersion_ratio = abs(e_inter_hartree) / abs(e_bind_hartree)\n        \n        all_results.append([e_bind_kjmol, dispersion_ratio])\n\n    # Format the final output string to match the required format precisely\n    formatted_results = []\n    for res_pair in all_results:\n        formatted_results.append(f\"[{res_pair[0]:.6f},{res_pair[1]:.6f}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的催化体系常涉及开壳层物种，此时非限制性Hartree-Fock (UHF) 方法会受自旋污染的困扰，导致能量计算不准确。本练习将演示如何诊断并修正这一常见问题，通过构建一个自旋投影方案，您将评估该校正对一个关键催化性质——反应能垒——的显著影响。",
            "id": "3882502",
            "problem": "给定一个催化夺氢反应的非限制性Hartree-Fock (UHF) 计算数据。目标是构建一个自旋投影校正，从一个破缺对称性的UHF波函数中估算纯自旋态的能量，然后评估其对反应能垒预测的影响。你的推导和算法必须完全基于关于自旋算符和自旋本征态混合的第一性原理，以及关于Hartree-Fock理论的公认事实。\n\n出发点与物理基础：\n- UHF破缺对称性态不是总自旋算符的本征态，但它有一个期望值 $\\langle \\hat{S}^2 \\rangle$，反映了自旋本征态的混合。\n- 对于一个由自旋量子数为 $S$ 的 $\\hat{S}^2$ 本征态组成的混合物，每个纯态的 $\\hat{S}^2$ 本征值为 $S(S+1)$。\n- 对于一个由自旋为 $S_{\\mathrm{target}}$ 的目标低自旋态和一个高自旋参考态（例如，自旋为 $S_{\\mathrm{T}}$ 的三重态）组成的两组分混合物，破缺对称性的期望值和能量可以用混合权重来表示。\n\n任务：\n1. 从自旋算符的定义和一个双态混合模型出发，推导目标纯自旋态能量 $E_{\\mathrm{target}}$ 的表达式。该表达式应使用破缺对称性UHF能量 $E_{\\mathrm{BS}}$、高自旋态能量 $E_{\\mathrm{T}}$、破缺对称性自旋污染 $\\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}}$、高自旋态本征值 $\\langle \\hat{S}^2 \\rangle_{\\mathrm{T}} = S_{\\mathrm{T}}(S_{\\mathrm{T}}+1)$ 和目标自旋态本征值 $\\langle \\hat{S}^2 \\rangle_{\\mathrm{target}} = S_{\\mathrm{target}}(S_{\\mathrm{target}}+1)$ 来表示。你不能假设任何特殊的快捷公式；必须使用由 $\\hat{S}^2$ 的期望值所隐含的混合权重来推导该校正。\n2. 对每种几何构型（反应物和过渡态），应用所推导的投影方法，从给定数据中获得 $E_{\\mathrm{target}}^{\\mathrm{R}}$ 和 $E_{\\mathrm{target}}^{\\mathrm{TS}}$。\n3. 计算未校正的破缺对称性UHF能量和自旋投影能量对应的能垒：\n   - 破缺对称性能垒：$\\Delta E_{\\mathrm{BS}} = E_{\\mathrm{BS}}^{\\mathrm{TS}} - E_{\\mathrm{BS}}^{\\mathrm{R}}$。\n   - 自旋投影能垒：$\\Delta E_{\\mathrm{proj}} = E_{\\mathrm{target}}^{\\mathrm{TS}} - E_{\\mathrm{target}}^{\\mathrm{R}}$。\n4. 通过报告 $\\Delta\\Delta E = \\Delta E_{\\mathrm{proj}} - \\Delta E_{\\mathrm{BS}}$ 来评估自旋投影的影响。\n5. 将最终的能垒差 $\\Delta\\Delta E$ 以 $\\mathrm{kJ/mol}$ 为单位表示为浮点数。使用换算关系 $1\\,\\mathrm{hartree} = 2625.5\\,\\mathrm{kJ/mol}$。不涉及角度。不要使用百分比。\n\n边界处理：\n- 如果你的投影公式所需的分母在 $10^{-12}$ 的数值容差内等于零，则对该几何构型设置 $E_{\\mathrm{target}} = E_{\\mathrm{BS}}$（即不施加校正）。\n\n输入数据与测试套件：\n假设所有测试用例中的目标自旋态均为单重态，即 $S_{\\mathrm{target}} = 0$。能量以 hartree 为单位；$\\langle \\hat{S}^2 \\rangle$ 值为无量纲。\n\n提供一个程序，处理以下四个测试用例。每个测试用例是一个包含八个值的元组：\n$\\left(E_{\\mathrm{BS}}^{\\mathrm{R}}, \\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}}^{\\mathrm{R}}, E_{\\mathrm{T}}^{\\mathrm{R}}, \\langle \\hat{S}^2 \\rangle_{\\mathrm{T}}^{\\mathrm{R}}, E_{\\mathrm{BS}}^{\\mathrm{TS}}, \\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}}^{\\mathrm{TS}}, E_{\\mathrm{T}}^{\\mathrm{TS}}, \\langle \\hat{S}^2 \\rangle_{\\mathrm{T}}^{\\mathrm{TS}} \\right)$\n\n- 用例1（过渡态存在中等程度的自旋污染）：\n  $\\left(-76.432100, 0.30, -76.420000, 2.0, -76.400000, 0.60, -76.395000, 2.0\\right)$\n- 用例2（无自旋污染；投影应为零）：\n  $\\left(-76.500000, 0.00, -76.480000, 2.0, -76.450000, 0.00, -76.430000, 2.0\\right)$\n- 用例3（过渡态存在较强的自旋污染）：\n  $\\left(-152.123456, 0.10, -152.120000, 2.0, -152.000000, 1.20, -151.990000, 2.0\\right)$\n- 用例4（破缺对称性能量与三重态能量近简并；校正量极小）：\n  $\\left(-76.300000, 0.50, -76.299990, 2.0, -76.250000, 0.50, -76.249990, 2.0\\right)$\n\n输出规格：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应测试用例的 $\\Delta\\Delta E$ 值（单位为 $\\mathrm{kJ/mol}$），顺序与上面列出的用例相同。例如，输出应如下所示：\"[result1,result2,result3,result4]\"。",
            "solution": "该问题是有效的，因为它在科学上基于量子化学的原理，特别是非限制性Hartree-Fock (UHF) 理论和自旋污染的概念。该问题提法清晰，提供了通过标准自旋投影形式推导出唯一且有意义的解所需的所有数据和定义。语言客观，数值在物理上是合理的。\n\n在此，我们推导自旋投影校正，将其应用于所提供的反应物（R）和过渡态（TS）数据，并分析其对反应能垒的影响。\n\n**1. 自旋投影能量公式的推导**\n\n基本前提是，破缺对称性 (BS) UHF 波函数 $|\\Psi_{\\mathrm{BS}}\\rangle$ 虽然不是总自旋平方算符 $\\hat{S}^2$ 的本征函数，但可以被建模为两个纯自旋本征态的混合：目标低自旋态 $|\\Psi_{\\mathrm{target}}\\rangle$ 和一个高自旋污染态 $|\\Psi_{\\mathrm{T}}\\rangle$。\n\n基于此双态混合模型，BS态对任意线性算符的期望值可以表示为纯态期望值的加权平均。设混合物中目标态和污染态的权重分别为 $w_{\\mathrm{target}}$ 和 $w_{\\mathrm{T}}$，其中 $w_{\\mathrm{target}} + w_{\\mathrm{T}} = 1$。\n\n对于 $\\hat{S}^2$ 算符，BS态的期望值为：\n$$ \\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}} = w_{\\mathrm{target}} \\langle \\hat{S}^2 \\rangle_{\\mathrm{target}} + w_{\\mathrm{T}} \\langle \\hat{S}^2 \\rangle_{\\mathrm{T}} $$\n其中 $\\langle \\hat{S}^2 \\rangle_{\\mathrm{target}} = S_{\\mathrm{target}}(S_{\\mathrm{target}}+1)$ 和 $\\langle \\hat{S}^2 \\rangle_{\\mathrm{T}} = S_{\\mathrm{T}}(S_{\\mathrm{T}}+1)$ 是纯自旋态的精确本征值。\n\n将 $w_{\\mathrm{T}} = 1 - w_{\\mathrm{target}}$ 代入方程得到：\n$$ \\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}} = w_{\\mathrm{target}} \\langle \\hat{S}^2 \\rangle_{\\mathrm{target}} + (1 - w_{\\mathrm{target}}) \\langle \\hat{S}^2 \\rangle_{\\mathrm{T}} $$\n我们可以解出目标态的权重 $w_{\\mathrm{target}}$：\n$$ \\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}} - \\langle \\hat{S}^2 \\rangle_{\\mathrm{T}} = w_{\\mathrm{target}} (\\langle \\hat{S}^2 \\rangle_{\\mathrm{target}} - \\langle \\hat{S}^2 \\rangle_{\\mathrm{T}}) $$\n$$ w_{\\mathrm{target}} = \\frac{\\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}} - \\langle \\hat{S}^2 \\rangle_{\\mathrm{T}}}{\\langle \\hat{S}^2 \\rangle_{\\mathrm{target}} - \\langle \\hat{S}^2 \\rangle_{\\mathrm{T}}} = \\frac{\\langle \\hat{S}^2 \\rangle_{\\mathrm{T}} - \\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}}}{\\langle \\hat{S}^2 \\rangle_{\\mathrm{T}} - \\langle \\hat{S}^2 \\rangle_{\\mathrm{target}}} $$\n\n类似地，BS态的能量 $E_{\\mathrm{BS}}$，即哈密顿算符 $\\hat{H}$ 的期望值，可以表示为：\n$$ E_{\\mathrm{BS}} = w_{\\mathrm{target}} E_{\\mathrm{target}} + w_{\\mathrm{T}} E_{\\mathrm{T}} = w_{\\mathrm{target}} E_{\\mathrm{target}} + (1 - w_{\\mathrm{target}}) E_{\\mathrm{T}} $$\n其中 $E_{\\mathrm{target}}$ 和 $E_{\\mathrm{T}}$ 分别是纯目标态和污染态的能量。目标是求解 $E_{\\mathrm{target}}$。\n\n重排能量方程以求解 $E_{\\mathrm{target}}$：\n$$ E_{\\mathrm{BS}} - E_{\\mathrm{T}} = w_{\\mathrm{target}} (E_{\\mathrm{target}} - E_{\\mathrm{T}}) $$\n$$ E_{\\mathrm{target}} = \\frac{E_{\\mathrm{BS}} - E_{\\mathrm{T}}}{w_{\\mathrm{target}}} + E_{\\mathrm{T}} $$\n代入 $w_{\\mathrm{target}}$ 的表达式：\n$$ E_{\\mathrm{target}} = (E_{\\mathrm{BS}} - E_{\\mathrm{T}}) \\left( \\frac{\\langle \\hat{S}^2 \\rangle_{\\mathrm{T}} - \\langle \\hat{S}^2 \\rangle_{\\mathrm{target}}}{\\langle \\hat{S}^2 \\rangle_{\\mathrm{T}} - \\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}}} \\right) + E_{\\mathrm{T}} $$\n这可以重排成一个类似于线性插值的形式。假设能量 $E$ 是期望值 $\\langle \\hat{S}^2 \\rangle$ 的线性函数。给定两个点 $(\\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}}, E_{\\mathrm{BS}})$ 和 $(\\langle \\hat{S}^2 \\rangle_{\\mathrm{T}}, E_{\\mathrm{T}})$，我们外插得到在 $\\langle \\hat{S}^2 \\rangle_{\\mathrm{target}}$ 处的能量 $E_{\\mathrm{target}}$。其标准公式为：\n$$ E_{\\mathrm{target}} = E_{\\mathrm{BS}} + (E_{\\mathrm{T}} - E_{\\mathrm{BS}}) \\frac{\\langle \\hat{S}^2 \\rangle_{\\mathrm{target}} - \\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}}}{\\langle \\hat{S}^2 \\rangle_{\\mathrm{T}} - \\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}}} $$\n这是 Yamaguchi 自旋投影公式的一种常见形式。\n\n在此问题中，目标态是单重态，所以 $S_{\\mathrm{target}} = 0$ 且 $\\langle \\hat{S}^2 \\rangle_{\\mathrm{target}} = 0(0+1) = 0$。公式简化为：\n$$ E_{\\mathrm{target}} = E_{\\mathrm{BS}} + (E_{\\mathrm{T}} - E_{\\mathrm{BS}}) \\frac{0 - \\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}}}{\\langle \\hat{S}^2 \\rangle_{\\mathrm{T}} - \\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}}} $$\n$$ E_{\\mathrm{target}} = E_{\\mathrm{BS}} - \\left( \\frac{\\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}}}{\\langle \\hat{S}^2 \\rangle_{\\mathrm{T}} - \\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}}} \\right) (E_{\\mathrm{T}} - E_{\\mathrm{BS}}) $$\n这就是我们将要实现的表达式。分母是 $D = \\langle \\hat{S}^2 \\rangle_{\\mathrm{T}} - \\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}}$。如果 $|D|  10^{-12}$，我们不施加校正，即 $E_{\\mathrm{target}} = E_{\\mathrm{BS}}$。\n\n**2. 能垒和校正影响的计算**\n\n对于每种几何构型（反应物 R 和过渡态 TS），我们使用相应给定的 $E_{\\mathrm{BS}}$、$\\langle \\hat{S}^2 \\rangle_{\\mathrm{BS}}$、$E_{\\mathrm{T}}$ 和 $\\langle \\hat{S}^2 \\rangle_{\\mathrm{T}}$ 值来计算投影能量 $E_{\\mathrm{target}}$。\n\n未校正和投影后的反应能垒分别为：\n$$ \\Delta E_{\\mathrm{BS}} = E_{\\mathrm{BS}}^{\\mathrm{TS}} - E_{\\mathrm{BS}}^{\\mathrm{R}} $$\n$$ \\Delta E_{\\mathrm{proj}} = E_{\\mathrm{target}}^{\\mathrm{TS}} - E_{\\mathrm{target}}^{\\mathrm{R}} $$\n\n自旋投影对能垒的影响是这两个能垒之差：\n$$ \\Delta\\Delta E = \\Delta E_{\\mathrm{proj}} - \\Delta E_{\\mathrm{BS}} $$\n代入能垒的定义：\n$$ \\Delta\\Delta E = (E_{\\mathrm{target}}^{\\mathrm{TS}} - E_{\\mathrm{target}}^{\\mathrm{R}}) - (E_{\\mathrm{BS}}^{\\mathrm{TS}} - E_{\\mathrm{BS}}^{\\mathrm{R}}) $$\n$$ \\Delta\\Delta E = (E_{\\mathrm{target}}^{\\mathrm{TS}} - E_{\\mathrm{BS}}^{\\mathrm{TS}}) - (E_{\\mathrm{target}}^{\\mathrm{R}} - E_{\\mathrm{BS}}^{\\mathrm{R}}) $$\n这表明 $\\Delta\\Delta E$ 就是施加于过渡态和反应物的能量校正值之差。对于给定的几何构型，能量校正值为 $E_{\\mathrm{corr}} = E_{\\mathrm{target}} - E_{\\mathrm{BS}}$。因此，$\\Delta\\Delta E = E_{\\mathrm{corr}}^{\\mathrm{TS}} - E_{\\mathrm{corr}}^{\\mathrm{R}}$。\n\n最后，使用给定的换算因子将结果转换为 $\\mathrm{kJ/mol}$：$1\\,\\mathrm{hartree} = 2625.5\\,\\mathrm{kJ/mol}$。\n\n这种结构化的方法使我们能够通过将推导出的公式应用于 R 和 TS 数据，计算各自的能量校正，求出它们的差值，并转换为最终单位，从而计算出每个测试用例所需的量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spin-projection problem for the given test cases.\n    \"\"\"\n    \n    # Conversion factor from Hartree to kJ/mol.\n    HARTREE_TO_KJ_MOL = 2625.5\n    \n    # Define the four test cases as per the problem description.\n    # Each case is a tuple:\n    # (E_bs_r, s2_bs_r, E_t_r, s2_t_r, E_bs_ts, s2_bs_ts, E_t_ts, s2_t_ts)\n    test_cases = [\n        # Case 1: Moderate spin contamination at TS\n        (-76.432100, 0.30, -76.420000, 2.0, -76.400000, 0.60, -76.395000, 2.0),\n        # Case 2: No spin contamination\n        (-76.500000, 0.00, -76.480000, 2.0, -76.450000, 0.00, -76.430000, 2.0),\n        # Case 3: Stronger spin contamination at TS\n        (-152.123456, 0.10, -152.120000, 2.0, -152.000000, 1.20, -151.990000, 2.0),\n        # Case 4: Nearly degenerate BS and Triplet energies\n        (-76.300000, 0.50, -76.299990, 2.0, -76.250000, 0.50, -76.249990, 2.0),\n    ]\n\n    results = []\n\n    def calculate_projection_correction(E_bs, s2_bs, E_t, s2_t):\n        \"\"\"\n        Calculates the energy correction based on the derived spin-projection formula.\n        The correction is E_target - E_bs.\n        \n        The formula for the projected energy E_target is:\n        E_target = E_bs + (E_t - E_bs) * (s2_target - s2_bs) / (s2_t - s2_bs)\n        \n        Since s2_target = 0 (singlet), the correction (E_target - E_bs) is:\n        correction = (E_t - E_bs) * (-s2_bs) / (s2_t - s2_bs)\n        \"\"\"\n        s2_target = 0.0\n        \n        # Denominator in the projection formula\n        denominator = s2_t - s2_bs\n        \n        # Boundary handling as per the problem statement\n        if abs(denominator)  1e-12:\n            return 0.0\n        \n        # Energy difference between triplet and broken-symmetry states\n        energy_diff = E_t - E_bs\n        \n        # Calculate the correction term\n        correction = energy_diff * (s2_target - s2_bs) / denominator\n        \n        return correction\n\n    for case in test_cases:\n        E_bs_r, s2_bs_r, E_t_r, s2_t_r, E_bs_ts, s2_bs_ts, E_t_ts, s2_t_ts = case\n        \n        # Calculate the energy correction for the reactant (R)\n        E_corr_r = calculate_projection_correction(E_bs_r, s2_bs_r, E_t_r, s2_t_r)\n        \n        # Calculate the energy correction for the transition state (TS)\n        E_corr_ts = calculate_projection_correction(E_bs_ts, s2_bs_ts, E_t_ts, s2_t_ts)\n        \n        # Delta Delta E is the difference in corrections (in hartree)\n        # delta_delta_E = (E_proj_ts - E_proj_r) - (E_bs_ts - E_bs_r)\n        # delta_delta_E = (E_proj_ts - E_bs_ts) - (E_proj_r - E_bs_r)\n        # delta_delta_E = E_corr_ts - E_corr_r\n        delta_delta_E_hartree = E_corr_ts - E_corr_r\n        \n        # Convert the result to kJ/mol\n        delta_delta_E_kj_mol = delta_delta_E_hartree * HARTREE_TO_KJ_MOL\n        \n        results.append(delta_delta_E_kj_mol)\n\n    # Format the results into the required string format\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}