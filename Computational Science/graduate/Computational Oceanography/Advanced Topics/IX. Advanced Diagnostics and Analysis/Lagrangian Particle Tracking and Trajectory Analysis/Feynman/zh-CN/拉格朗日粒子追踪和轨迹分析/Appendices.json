{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在连接流体运动的拉格朗日（质点追踪）和欧拉（固定点）描述。通过在一个简单的应变流场中，使用两种方法计算一个标量场的物质导数，我们将直接验证它们的等价性，并加深对平流过程的物理直观理解。这是掌握拉格朗日分析基础的关键一步。",
            "id": "3797356",
            "problem": "考虑一个二维、不随时间变化的应变流，该流代表了海洋中一个理想化的锋区。速度场由 $\\mathbf{u}(x,y)=(ax,\\,-ay)$ 给出，其中 $a>0$ 是一个常数，单位为时间的倒数。令标量场 $\\phi(x,y)=x^2+y^2$ 表示到原点距离的平方。使用拉格朗日粒子追踪框架，并仅基于第一性原理，即流体质点的运动学关系 $\\frac{\\mathrm{d}x}{\\mathrm{d}t}=u_x$ 和 $\\frac{\\mathrm{d}y}{\\mathrm{d}t}=u_y$，以及物质导数 $\\frac{D\\phi}{Dt}$ 是 $\\phi$ 跟随流体质点变化的变化率的定义，推导出一个对任意 $(x,y)$ 均有效的 $\\frac{D\\phi}{Dt}$ 的显式表达式。然后，通过基于空间梯度和时间无关性的欧拉计算来验证相同的表达式，并在欧拉和拉格朗日框架下从应变的角度对结果进行物理解释。将您关于 $\\frac{D\\phi}{Dt}$ 的最终结果表示为包含 $a$、$x$ 和 $y$ 的闭式代数表达式。无需进行数值计算，也无需四舍五入。",
            "solution": "该问题已经过验证，被认为是可靠、适定且有科学依据的。所有必需信息均已提供，物理场景是流体动力学中的一个标准理想化模型，任务定义清晰。\n\n该问题要求在速度场 $\\mathbf{u}(x,y)=(ax, -ay)$ 中，使用拉格朗日和欧拉两种不同的方法，推导标量场 $\\phi(x,y)=x^2+y^2$ 的物质导数 $\\frac{D\\phi}{Dt}$。常数 $a$ 为正。\n\n首先，我们将从拉格朗日视角进行推导。在此框架中，我们跟踪一个单独的流体质点，并观察属性 $\\phi$ 对该特定质点随时间的变化情况。设一个流体质点在时间 $t$ 的位置由向量 $\\mathbf{r}(t) = (x(t), y(t))$ 给出。根据定义，质点的速度即为其当前位置的流体速度。这由问题陈述中给出的常微分方程组描述：\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} = u_x = ax(t)\n$$\n$$\n\\frac{\\mathrm{d}y}{\\mathrm{d}t} = u_y = -ay(t)\n$$\n沿质点轨迹计算的标量 $\\phi$ 成为一个仅与时间相关的函数，我们可以将其表示为 $\\Phi(t) = \\phi(x(t), y(t)) = (x(t))^2 + (y(t))^2$。物质导数 $\\frac{D\\phi}{Dt}$ 定义为该函数 $\\frac{\\mathrm{d}\\Phi}{\\mathrm{d}t}$ 的全时间导数。我们使用多变量函数的链式法则来计算此导数：\n$$\n\\frac{D\\phi}{Dt} = \\frac{\\mathrm{d}\\Phi}{\\mathrm{d}t} = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left[ (x(t))^2 + (y(t))^2 \\right] = 2x(t) \\frac{\\mathrm{d}x}{\\mathrm{d}t} + 2y(t) \\frac{\\mathrm{d}y}{\\mathrm{d}t}\n$$\n现在，我们将速度分量 $\\frac{\\mathrm{d}x}{\\mathrm{d}t}$ 和 $\\frac{\\mathrm{d}y}{\\mathrm{d}t}$ 的表达式代入此方程。在轨迹上的任意点 $(x,y)$，我们有：\n$$\n\\frac{D\\phi}{Dt} = 2x(ax) + 2y(-ay)\n$$\n简化此代数表达式得到结果：\n$$\n\\frac{D\\phi}{Dt} = 2ax^2 - 2ay^2 = 2a(x^2 - y^2)\n$$\n这是在拉格朗日框架中从第一性原理推导出的物质导数的表达式。它对流场中的任意点 $(x,y)$ 都有效。\n\n其次，我们使用欧拉计算来验证此结果。在欧拉框架中，我们考虑空间中固定点的变化。在速度场 $\\mathbf{u}(\\mathbf{r}, t)$ 中，标量场 $\\phi(\\mathbf{r}, t)$ 的物质导数由通用公式给出：\n$$\n\\frac{D\\phi}{Dt} = \\frac{\\partial \\phi}{\\partial t} + (\\mathbf{u} \\cdot \\nabla)\\phi = \\frac{\\partial \\phi}{\\partial t} + \\mathbf{u} \\cdot \\nabla\\phi\n$$\n项 $\\frac{\\partial \\phi}{\\partial t}$ 是在固定点的局部变化率，而项 $\\mathbf{u} \\cdot \\nabla\\phi$ 是平流变化率，表示由于具有不同 $\\phi$ 值的流体经过该点而引起的变化。\n在本问题中，标量场由 $\\phi(x,y) = x^2 + y^2$ 给出，它不显式依赖于时间 $t$。因此，局部时间导数为零：\n$$\n\\frac{\\partial \\phi}{\\partial t} = 0\n$$\n速度向量为 $\\mathbf{u} = (u_x, u_y) = (ax, -ay)$。\n标量场 $\\phi$ 的梯度为：\n$$\n\\nabla\\phi = \\left( \\frac{\\partial \\phi}{\\partial x}, \\frac{\\partial \\phi}{\\partial y} \\right) = \\left( \\frac{\\partial}{\\partial x}(x^2+y^2), \\frac{\\partial}{\\partial y}(x^2+y^2) \\right) = (2x, 2y)\n$$\n现在我们计算平流项，即速度向量与 $\\phi$ 的梯度的点积：\n$$\n\\mathbf{u} \\cdot \\nabla\\phi = (ax, -ay) \\cdot (2x, 2y) = (ax)(2x) + (-ay)(2y)\n$$\n$$\n\\mathbf{u} \\cdot \\nabla\\phi = 2ax^2 - 2ay^2\n$$\n将这些分量代回物质导数的公式中：\n$$\n\\frac{D\\phi}{Dt} = 0 + 2ax^2 - 2ay^2 = 2a(x^2 - y^2)\n$$\n此结果与通过拉格朗日方法获得的结果相同，从而验证了计算的正确性。\n\n最后，我们对结果进行物理解释。速度场 $\\mathbf{u}=(ax, -ay)$ 描述了一个纯应变流，其拉伸轴沿 $x$ 轴，压缩轴沿 $y$ 轴。原点 $(0,0)$ 是一个双曲不动点（一个鞍点）。流体质点被拉伸远离 $y$ 轴，并被压缩朝向 $x$ 轴。\n标量场 $\\phi=x^2+y^2$ 表示一个点到原点距离的平方。因此，物质导数 $\\frac{D\\phi}{Dt} = 2a(x^2 - y^2)$ 衡量了流体质点在流场中移动时，其到原点距离的平方的变化率。\n$\\frac{D\\phi}{Dt}$ 的符号取决于质点的位置：\n- 如果 $|x| > |y|$，则 $x^2 > y^2$ 且 $\\frac{D\\phi}{Dt} > 0$。这对应于包含 $x$ 轴（拉伸轴）的平面中的两个扇区。在这些区域，流场的拉伸效应占主导地位，流体质点远离原点运动。\n- 如果 $|x| < |y|$，则 $x^2 < y^2$ 且 $\\frac{D\\phi}{Dt} < 0$。这对应于包含 $y$ 轴（压缩轴）的两个扇区。在这里，流场的压缩效应占主导地位，流体质点朝向原点运动。\n- 如果 $|x| = |y|$，即在直线 $y = x$ 和 $y = -x$ 上，则 $\\frac{D\\phi}{Dt} = 0$。在这些线上的任意一点，质点的瞬时运动使其到原点的距离保持不变。拉伸的向外推动效应与压缩的向内拉动效应完美平衡。这些线分隔了质点远离原点运动的区域和朝向原点运动的区域。\n\n从拉格朗日视角看，$\\frac{D\\phi}{Dt}$ 是运动粒子所经历的 $\\phi$ 的实际变化率。从欧拉视角看，这种变化完全由平流引起（$\\frac{\\partial\\phi}{\\partial t}=0$），意味着在任意点 $(x,y)$，$\\phi$ 值的变化仅仅是因为到达该点的流体质点来自一个具有不同 $\\phi$ 值的位置。这两种视角为同一物理过程提供了相一致的描述。",
            "answer": "$$\n\\boxed{2a(x^2 - y^2)}\n$$"
        },
        {
            "introduction": "真实的拉格朗日模型必须能处理如海岸线之类的物理边界。本练习将指导您掌握必要的几何算法，用以检测粒子路径何时与边界相交，并实现物理上合理的响应，例如吸收或反射。掌握这些技术对于在海岸和海洋学应用中构建稳健的粒子追踪模拟至关重要。",
            "id": "3797328",
            "problem": "给定一个二维拉格朗日粒子模型，其中位于位置 $\\mathbf{x}^n \\in \\mathbb{R}^2$ 的粒子使用前向欧拉更新，在一个离散时间步长内以恒定速度推进。基本构成包括：运动学关系 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}(\\mathbf{x},t)$，离散时间前向欧拉映射 $\\mathbf{x}^{n+1} = \\mathbf{x}^n + \\Delta t\\,\\mathbf{v}(\\mathbf{x}^n,t^n)$，以及表示为平面上一个封闭、分段线性多边形的海岸线的几何定义。该多边形边界由 $\\mathbb{R}^2$ 中的有序顶点 $\\{\\mathbf{c}_i\\}_{i=0}^{M-1}$ 及其连接的线段 $[\\mathbf{c}_i,\\mathbf{c}_{i+1}]$（索引算术以 $M$ 为模）组成。需要在海岸线上施加的物理上合理的边界条件是：\n\n- 反射边界条件：如果粒子从 $\\mathbf{x}^n$ 到其无约束更新位置 $\\mathbf{x}^{n+1}$ 的路径在点 $\\mathbf{x}_\\star$ 与海岸线相交，则剩余位移垂直于海岸线的分量将被反向（弹性反射），而切向分量保持不变。相交后的剩余位移 $\\Delta\\mathbf{x}_\\mathrm{rem}$ 通过公式 $\\Delta\\mathbf{x}_\\mathrm{rem}' = \\Delta\\mathbf{x}_\\mathrm{rem} - 2\\left(\\Delta\\mathbf{x}_\\mathrm{rem}\\cdot \\widehat{\\mathbf{n}}\\right)\\widehat{\\mathbf{n}}$ 沿着由海岸线线段定义的局部直线进行反射，其中 $\\widehat{\\mathbf{n}}$ 是在 $\\mathbf{x}_\\star$ 点海岸线线段的任意单位法向量。\n\n- 吸收边界条件：在 $\\mathbf{x}_\\star$ 点相交后，粒子被放置在 $\\mathbf{x}_\\star$ 并标记为终止；在该时间步内不再施加任何运动。\n\n你的任务：\n\n1. 推导一个算法，用于检测从 $\\mathbf{x}^n$ 到 $\\mathbf{x}^{n+1}_\\mathrm{free} = \\mathbf{x}^n + \\Delta t\\,\\mathbf{v}(\\mathbf{x}^n,t^n)$ 的直线路径段与海岸线的最早交点，其中速度 $\\mathbf{v}$ 在该时间步内被视为恒定。设路径参数化为 $\\mathbf{p}(s) = \\mathbf{x}^n + s\\,\\Delta\\mathbf{x}$，其中 $s\\in[0,1]$，且 $\\Delta\\mathbf{x} = \\mathbf{x}^{n+1}_\\mathrm{free} - \\mathbf{x}^n$。每个海岸线线段参数化为 $\\mathbf{q}(r) = \\mathbf{a} + r\\,\\mathbf{e}$，其中 $r\\in[0,1]$，$\\mathbf{a}$ 和 $\\mathbf{b}$ 是线段端点，$\\mathbf{e} = \\mathbf{b}-\\mathbf{a}$。从平面上两条参数化直线相交的向量恒等式出发，使用基于叉积的公式求解 $s$ 和 $r$，并指定包含性测试，以稳健地判断交点是否同时位于两个线段内。提供一种数值稳健的方法（带有容差），以处理平行和近乎平行的配置，以及多个线段共享同一点的角点相交特殊情况。\n\n2. 推导并实现反射解析规则：给定参数 $s_\\star\\in(0,1]$ 处的交点，计算交点 $\\mathbf{x}_\\star = \\mathbf{p}(s_\\star)$、剩余位移 $\\Delta\\mathbf{x}_\\mathrm{rem} = (1-s_\\star)\\,\\Delta\\mathbf{x}$，以及在相交海岸线线段处的单位切向量 $\\widehat{\\mathbf{t}} = \\mathbf{e}/\\|\\mathbf{e}\\|$ 和单位法向量 $\\widehat{\\mathbf{n}} = (-\\widehat{t}_y,\\widehat{t}_x)$。将 $\\Delta\\mathbf{x}_\\mathrm{rem}$ 映射为 $\\Delta\\mathbf{x}_\\mathrm{rem}' = \\Delta\\mathbf{x}_\\mathrm{rem} - 2\\left(\\Delta\\mathbf{x}_\\mathrm{rem}\\cdot \\widehat{\\mathbf{n}}\\right)\\widehat{\\mathbf{n}}$，并将粒子位置更新为 $\\mathbf{x}^{n+1} = \\mathbf{x}_\\star + \\Delta\\mathbf{x}_\\mathrm{rem}'$。如果 $\\mathbf{x}^{n+1}$ 在同一时间步内仍然与另一线段相交（例如在凸角处），则使用剩余位移迭代执行检测-解析循环，直到不再有交点或达到预设的最大反射次数。对于吸收边界条件，在 $\\mathbf{x}_\\star$ 处终止。\n\n3. 在单个程序中实现以上算法，使用以下海岸线多边形（单位为米）：$\\mathbf{c}_0=(0,0)$、$\\mathbf{c}_1=(10,0)$、$\\mathbf{c}_2=(10,10)$、$\\mathbf{c}_3=(0,10)$，以及线段 $[\\mathbf{c}_i,\\mathbf{c}_{i+1}]$ 和 $[\\mathbf{c}_3,\\mathbf{c}_0]$。在每个时间步内使用恒定速度的前向欧拉法。为保证数值稳健性，当参数接近其区间边界时，使用一个小的容差 $\\varepsilon$ 来判断是否发生穿越，并实现一种策略以避免在恰好从边界点开始时出现无限循环（例如，在重新测试相交前，将起始点沿预定运动方向微小偏移）。\n\n4. 使用以下测试套件。对于每种情况，初始位置 $\\mathbf{x}^n=(x,y)$ 的单位是米，速度 $\\mathbf{v}=(u,v)$ 的单位是米/秒，时间步长 $\\Delta t$ 的单位是秒，边界条件为反射或吸收。对于每种情况，生成最终位置 $\\mathbf{x}^{n+1}$（单位为米）和一个终止标志，如果粒子被吸收则为 $1$，否则为 $0$。所有位置均以米为单位，并保留六位小数。\n\n- 情况 A（标准路径，穿越垂直海岸线反射）：$\\mathbf{x}^n=(9.0,5.0)$，$\\mathbf{v}=(1.0,0.0)$，$\\Delta t=2.0$，反射。\n- 情况 B（首次穿越时吸收）：$\\mathbf{x}^n=(9.0,5.0)$，$\\mathbf{v}=(1.0,0.0)$，$\\Delta t=2.0$，吸收。\n- 情况 C（一个时间步内发生角点双重反射）：$\\mathbf{x}^n=(9.5,9.5)$，$\\mathbf{v}=(1.0,1.0)$，$\\Delta t=1.0$，反射。\n- 情况 D（无穿越）：$\\mathbf{x}^n=(5.0,5.0)$，$\\mathbf{v}=(0.5,0.0)$，$\\Delta t=1.0$，反射。\n- 情况 E（在端点处发生吸收接触）：$\\mathbf{x}^n=(0.5,5.0)$，$\\mathbf{v}=(-0.5,0.0)$，$\\Delta t=1.0$，吸收。\n- 情况 F（在极小穿越前距离处发生近边界反射）：$\\mathbf{x}^n=(9.999,5.0)$，$\\mathbf{v}=(1.0,0.0)$，$\\Delta t=2.0$，反射。\n\n程序必须生成单行输出，包含所有测试用例的结果，格式为逗号分隔的列表的列表，每个内部列表的形式为 $[x^\\text{final},y^\\text{final},\\text{flag}]$，其中位置以米为单位，四舍五入到六位小数，标志为整数。例如，输出格式必须类似于 `[[x1,y1,flag1],[x2,y2,flag2],...]`，位于单行，无额外文本。",
            "solution": "问题陈述提出了一个计算物理学中定义明确的任务，具体涉及边界相互作用的拉格朗日粒子追踪。该问题具有科学依据、逻辑一致，并提供了所有必要的参数和条件。因此，该问题被认为是有效的。\n\n解决方案分三个主要阶段展开：首先，推导一种稳健的算法，用于检测粒子路径与代表海岸线的一组线段之间的交点；其次，制定处理边界条件（吸收和反射）的方法；第三，实现这些算法以解决所提供的测试用例。\n\n### 第 1 部分：交点检测算法\n\n问题的核心是确定粒子的直线轨迹是否与边界相交以及交于何处。\n\n一个粒子在时间步长 $\\Delta t$ 内的轨迹从位置 $\\mathbf{x}^n$ 开始，试图移动到一个“自由”位置 $\\mathbf{x}^{n+1}_\\text{free} = \\mathbf{x}^n + \\Delta t\\,\\mathbf{v}(\\mathbf{x}^n,t^n)$。该路径可以参数化为一个线段：\n$$\n\\mathbf{p}(s) = \\mathbf{x}^n + s\\,\\Delta\\mathbf{x} \\quad \\text{for} \\quad s \\in [0, 1]\n$$\n其中 $\\Delta\\mathbf{x} = \\mathbf{x}^{n+1}_\\text{free} - \\mathbf{x}^n$ 是该时间步的总位移向量。为使推导清晰，我们记起始点为 $\\mathbf{p}_0 = \\mathbf{x}^n$，路径方向向量为 $\\mathbf{d} = \\Delta\\mathbf{x}$。因此，$\\mathbf{p}(s) = \\mathbf{p}_0 + s\\mathbf{d}$。\n\n海岸线由线段组成，每个线段由两个顶点定义。一个从顶点 $\\mathbf{a}$ 到顶点 $\\mathbf{b}$ 的通用线段可以参数化为：\n$$\n\\mathbf{q}(r) = \\mathbf{a} + r\\,\\mathbf{e} \\quad \\text{for} \\quad r \\in [0, 1]\n$$\n其中 $\\mathbf{e} = \\mathbf{b} - \\mathbf{a}$ 是线段的方向向量。\n\n如果存在参数 $s$ 和 $r$ 使得 $\\mathbf{p}(s) = \\mathbf{q}(r)$，并且交点位于两个线段内，即 $s \\in [0,1]$ 且 $r \\in [0,1]$，则发生相交。\n交点的向量方程为：\n$$\n\\mathbf{p}_0 + s\\mathbf{d} = \\mathbf{a} + r\\mathbf{e}\n$$\n整理后得到关于未知数 $s$ 和 $r$ 的线性系统：\n$$\ns\\mathbf{d} - r\\mathbf{e} = \\mathbf{a} - \\mathbf{p}_0\n$$\n根据建议，我们使用二维叉积公式来求解此系统。向量 $\\mathbf{u}=(u_x, u_y)$ 和 $\\mathbf{v}=(v_x, v_y)$ 的二维叉积是标量 $u_x v_y - u_y v_x$，它表示三维叉积的 $z$ 分量的大小。对向量方程与 $\\mathbf{e}$ 取叉积可得：\n$$\n(s\\mathbf{d} - r\\mathbf{e}) \\times \\mathbf{e} = (\\mathbf{a} - \\mathbf{p}_0) \\times \\mathbf{e}\n$$\n$$\ns(\\mathbf{d} \\times \\mathbf{e}) - r(\\mathbf{e} \\times \\mathbf{e}) = (\\mathbf{a} - \\mathbf{p}_0) \\times \\mathbf{e}\n$$\n因为 $\\mathbf{e} \\times \\mathbf{e} = 0$，我们可以解出 $s$：\n$$\ns = \\frac{(\\mathbf{a} - \\mathbf{p}_0) \\times \\mathbf{e}}{\\mathbf{d} \\times \\mathbf{e}}\n$$\n类似地，对原始整理后的方程与 $\\mathbf{d}$ 取叉积可解出 $r$：\n$$\ns(\\mathbf{d} \\times \\mathbf{d}) - r(\\mathbf{e} \\times \\mathbf{d}) = (\\mathbf{a} - \\mathbf{p}_0) \\times \\mathbf{d}\n$$\n$$\n-r(\\mathbf{e} \\times \\mathbf{d}) = (\\mathbf{a} - \\mathbf{p}_0) \\times \\mathbf{d}\n$$\n使用恒等式 $\\mathbf{e} \\times \\mathbf{d} = -(\\mathbf{d} \\times \\mathbf{e})$，我们得到：\n$$\nr = \\frac{(\\mathbf{a} - \\mathbf{p}_0) \\times \\mathbf{d}}{\\mathbf{d} \\times \\mathbf{e}}\n$$\n分母 $D = \\mathbf{d} \\times \\mathbf{e}$ 为零当且仅当粒子路径和海岸线线段平行。为了数值稳定性，如果 $|D| < \\varepsilon_{num}$（其中 $\\varepsilon_{num}$ 是一个很小的容差），我们视其为平行。在这种情况下，排除穿越相交。\n\n如果 $D \\neq 0$，则无限长直线之间存在交点。为使此交点位于两个有限线段上，必须满足 $s \\in [0, 1]$ 和 $r \\in [0, 1]$。为了处理浮点数不精确性和边缘情况（例如，恰好在边界顶点开始或结束），使用几何容差 $\\varepsilon_{geom}$ 放宽这些检查：$s \\in [-\\varepsilon_{geom}, 1+\\varepsilon_{geom}]$ 和 $r \\in [-\\varepsilon_{geom}, 1+\\varepsilon_{geom}]$。\n\n为了防止粒子立即与其刚刚反射的边界再次相交而导致的无限循环，我们必须找到最早的*前向*交点。这通过仅考虑 $s > \\varepsilon_{s}$（其中 $\\varepsilon_{s}$ 是一个小的正容差）的交点来实现。算法遍历所有海岸线线段，为每个线段 $j$ 计算 $(s_j, r_j)$，并找出满足 $s_j \\in (\\varepsilon_{s}, 1+\\varepsilon_{geom}]$ 和 $r_j \\in [-\\varepsilon_{geom}, 1+\\varepsilon_{geom}]$ 的最小有效 $s_j$。\n\n### 第 2 部分：边界条件解析\n\n一旦找到与特定海岸线线段在参数 $s_\\star$ 处的最早有效交点，便应用边界条件。\n\n**吸收边界条件：**\n如果边界是吸收性的，粒子在该时间步的运动在首次接触点终止。最终位置是交点：\n$$\n\\mathbf{x}^{n+1} = \\mathbf{x}_\\star = \\mathbf{p}(s_\\star) = \\mathbf{x}^n + s_\\star \\Delta\\mathbf{x}\n$$\n终止标志设为 $1$。\n\n**反射边界条件：**\n此条件在单个时间步内迭代处理。\n1.  **初始步骤：** 设置当前位置 $\\mathbf{x}_{curr} = \\mathbf{x}^n$ 和剩余位移 $\\Delta\\mathbf{x}_{curr} = \\Delta\\mathbf{x}$。\n2.  **交点搜索：** 寻找从 $\\mathbf{x}_{curr}$ 开始、位移为 $\\Delta\\mathbf{x}_{curr}$ 的路径的最早交点。\n3.  **无交点：** 如果没有找到有效交点（即，没有线段产生有效的 $s \\in (\\varepsilon_{s}, 1+\\varepsilon_{geom}]$），粒子将不受阻碍地完成其行程。最终位置为 $\\mathbf{x}^{n+1} = \\mathbf{x}_{curr} + \\Delta\\mathbf{x}_{curr}$。此时间步的过程结束。\n4.  **找到交点：** 如果在参数 $s_\\star$ 处与线段 $\\mathbf{e}$ 找到交点：\n    a.  **更新位置：** 粒子移动到交点：$\\mathbf{x}_\\star = \\mathbf{x}_{curr} + s_\\star \\Delta\\mathbf{x}_{curr}$。这成为下一次迭代的新当前位置。\n    b.  **计算剩余位移：** 到达边界后剩下的位移部分是 $\\Delta\\mathbf{x}_\\mathrm{rem} = (1 - s_\\star) \\Delta\\mathbf{x}_{curr}$。\n    c.  **反射：** 对此剩余位移进行反射。线段的单位切向量是 $\\widehat{\\mathbf{t}} = \\mathbf{e}/\\|\\mathbf{e}\\|$。一个单位法向量是 $\\widehat{\\mathbf{n}} = (-\\widehat{t}_y, \\widehat{t}_x)$。反射后的位移 $\\Delta\\mathbf{x}_\\mathrm{rem}'$ 由反射定律给出：\n        $$\n        \\Delta\\mathbf{x}_\\mathrm{rem}' = \\Delta\\mathbf{x}_\\mathrm{rem} - 2(\\Delta\\mathbf{x}_\\mathrm{rem} \\cdot \\widehat{\\mathbf{n}}) \\widehat{\\mathbf{n}}\n        $$\n    d.  **迭代：** 下一个子步骤的新的剩余位移是 $\\Delta\\mathbf{x}_{curr} \\leftarrow \\Delta\\mathbf{x}_\\mathrm{rem}'$。新的起始位置是 $\\mathbf{x}_{curr} \\leftarrow \\mathbf{x}_\\star$。过程返回到第 2 步。\n5.  **终止：** 此迭代循环持续进行，直到找不到更多交点或达到预设的最大反射次数以防止病态的无限循环（例如，在数值陷阱中）。对于此问题，一个合理的最大值（例如 $10$）就足够了。最终位置是最后计算的 $\\mathbf{x}_{curr}$。终止标志为 $0$。这种迭代方法自然地处理了角点相互作用，其中粒子可能在短时间内经历多次反射。\n\n### 第 3 部分：测试套件的实现\n\n该算法使用 Python 的 `numpy` 库进行向量运算来实现。海岸线是一个由顶点 $\\mathbf{c}_0=(0,0)$、$\\mathbf{c}_1=(10,0)$、$\\mathbf{c}_2=(10,10)$ 和 $\\mathbf{c}_3=(0,10)$ 定义的正方形。线段为 $[\\mathbf{c}_0,\\mathbf{c}_1]$、$[\\mathbf{c}_1,\\mathbf{c}_2]$、$[\\mathbf{c}_2,\\mathbf{c}_3]$ 和 $[\\mathbf{c}_3,\\mathbf{c}_0]$。\n\n一个函数 `advance_particle` 封装了此逻辑。它接受初始状态和边界条件，并返回最终位置和终止标志。在其内部，一个辅助函数 `find_earliest_intersection` 计算所有线段的交点参数 $(s, r)$，并返回具有最小有效 $s$ 的交点数据。`advance_particle` 中的主循环处理迭代反射过程或单步吸收。使用小的容差（$\\varepsilon_{num} = 10^{-12}$、$\\varepsilon_{geom}=10^{-9}$、$\\varepsilon_{s}=10^{-9}$）来确保数值稳健性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases for Lagrangian particle tracking.\n    \"\"\"\n\n    # --- Define Coastline and numerical tolerances ---\n    # The coastline is a closed polygon defined by an ordered list of vertices.\n    coastline_vertices = [\n        np.array([0., 0.]),\n        np.array([10., 0.]),\n        np.array([10., 10.]),\n        np.array([0., 10.]),\n    ]\n    \n    # Coastline segments are formed by pairs of consecutive vertices.\n    # The list is closed by connecting the last vertex to the first.\n    coastline_segments = []\n    for i in range(len(coastline_vertices)):\n        p1 = coastline_vertices[i]\n        p2 = coastline_vertices[(i + 1) % len(coastline_vertices)]\n        coastline_segments.append((p1, p2))\n\n    # Numerical tolerances for floating-point comparisons\n    TOL_NUMERICAL = 1e-12  # For checking for zero in divisions (parallel lines)\n    TOL_GEOMETRIC = 1e-9   # For checking if a point is on a segment\n    TOL_S_MIN = 1e-9       # Minimum 's' to consider an intersection, avoids self-intersection on reflection\n    TOL_LENGTH = 1e-9      # Minimum displacement length to consider for further motion\n    MAX_REFLECTIONS = 10   # Safety break for reflection loop\n\n    def find_earliest_intersection(start_pos, displacement, segments):\n        \"\"\"\n        Finds the earliest valid intersection between a particle path and the coastline.\n        \n        Args:\n            start_pos (np.ndarray): Particle start position vector [x, y].\n            displacement (np.ndarray): Particle displacement vector for the time step.\n            segments (list): A list of tuples, where each tuple is (p1, p2) defining a segment.\n\n        Returns:\n            tuple or None: A tuple (s_star, segment, normal) of the earliest intersection,\n                           or None if no intersection is found.\n                           s_star: parameter of intersection along the particle path [0, 1].\n                           segment: the coastline segment vector that was hit.\n                           normal: the outward normal of the hit segment.\n        \"\"\"\n        earliest_s = float('inf')\n        best_intersection = None\n\n        p0 = start_pos\n        d = displacement\n\n        for (a, b) in segments:\n            e = b - a\n            # 2D cross product: u x v = u[0]*v[1] - u[1]*v[0]\n            d_cross_e = d[0] * e[1] - d[1] * e[0]\n\n            # If denominator is near-zero, path is parallel to segment; ignore.\n            if abs(d_cross_e)  TOL_NUMERICAL:\n                continue\n\n            a_minus_p0 = a - p0\n            s = (a_minus_p0[0] * e[1] - a_minus_p0[1] * e[0]) / d_cross_e\n            r = (a_minus_p0[0] * d[1] - a_minus_p0[1] * d[0]) / d_cross_e\n\n            # Check if intersection is valid and the earliest found so far\n            # s > TOL_S_MIN: Intersection must be forward in path\n            # s  1 + TOL_GEOMETRIC: Intersection must be within the current displacement step\n            # r bounds: Intersection must be on the coastline segment\n            if (TOL_S_MIN  s  1 + TOL_GEOMETRIC and \n                -TOL_GEOMETRIC  r  1 + TOL_GEOMETRIC):\n                if s  earliest_s:\n                    earliest_s = s\n                    \n                    # Calculate unit tangent and normal for the hit segment\n                    e_norm = np.linalg.norm(e)\n                    if e_norm  TOL_NUMERICAL: continue # Should not happen for valid polygons\n                    tangent = e / e_norm\n                    normal = np.array([-tangent[1], tangent[0]])\n\n                    best_intersection = (s, e, normal)\n\n        return best_intersection\n\n    def advance_particle(pos, vel, dt, bc_type):\n        \"\"\"\n        Advances a single particle for one time step, handling boundary conditions.\n        \"\"\"\n        initial_pos = np.array(pos)\n        velocity = np.array(vel)\n        total_displacement = velocity * dt\n\n        # --- Absorbing boundary condition ---\n        if bc_type == 'absorbing':\n            intersection = find_earliest_intersection(initial_pos, total_displacement, coastline_segments)\n            if intersection:\n                s_star, _, _ = intersection\n                final_pos = initial_pos + s_star * total_displacement\n                return final_pos, 1\n            else:\n                final_pos = initial_pos + total_displacement\n                return final_pos, 0\n\n        # --- Reflecting boundary condition ---\n        elif bc_type == 'reflecting':\n            current_pos = initial_pos\n            remaining_disp = total_displacement\n\n            for _ in range(MAX_REFLECTIONS):\n                if np.linalg.norm(remaining_disp)  TOL_LENGTH:\n                    break\n\n                intersection = find_earliest_intersection(current_pos, remaining_disp, coastline_segments)\n\n                if not intersection:\n                    # No more intersections, travel the rest of the way\n                    current_pos += remaining_disp\n                    break\n\n                s_star, _, normal = intersection\n                \n                # Move to the intersection point\n                intersection_point = current_pos + s_star * remaining_disp\n                current_pos = intersection_point\n\n                # Calculate remaining displacement vector and reflect it\n                leftover_disp = (1.0 - s_star) * remaining_disp\n                reflected_disp = leftover_disp - 2 * np.dot(leftover_disp, normal) * normal\n                \n                # Update remaining displacement for the next iteration\n                remaining_disp = reflected_disp\n            else:\n                # Loop finished due to max reflections, add any leftover displacement\n                current_pos += remaining_disp\n            \n            return current_pos, 0\n        \n        # Should not be reached\n        return initial_pos, 0\n\n    # --- Test Suite Definition ---\n    test_cases = [\n        # Case A: happy path reflect across a vertical coastline\n        {'pos': (9.0, 5.0), 'vel': (1.0, 0.0), 'dt': 2.0, 'bc_type': 'reflecting'},\n        # Case B: absorbing on first crossing\n        {'pos': (9.0, 5.0), 'vel': (1.0, 0.0), 'dt': 2.0, 'bc_type': 'absorbing'},\n        # Case C: corner double reflection within one time step\n        {'pos': (9.5, 9.5), 'vel': (1.0, 1.0), 'dt': 1.0, 'bc_type': 'reflecting'},\n        # Case D: no crossing\n        {'pos': (5.0, 5.0), 'vel': (0.5, 0.0), 'dt': 1.0, 'bc_type': 'reflecting'},\n        # Case E: absorbing contact at endpoint\n        {'pos': (0.5, 5.0), 'vel': (-0.5, 0.0), 'dt': 1.0, 'bc_type': 'absorbing'},\n        # Case F: near-boundary reflect with tiny pre-crossing distance\n        {'pos': (9.999, 5.0), 'vel': (1.0, 0.0), 'dt': 2.0, 'bc_type': 'reflecting'},\n    ]\n\n    results = []\n    for case in test_cases:\n        final_pos, flag = advance_particle(case['pos'], case['vel'], case['dt'], case['bc_type'])\n        results.append(f\"[{final_pos[0]:.6f},{final_pos[1]:.6f},{flag}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "轨迹分析的一个关键目标是超越追踪单个粒子，去理解流场的大尺度输运结构。这项高级练习将引入有限时间李雅普诺夫指数（Finite-Time Lyapunov Exponent, FTLE）这一强大工具，用以识别作为流体输运“骨架”的拉格朗日相干结构（Lagrangian Coherent Structures, LCS）。通过为一个经典的双涡流模型计算FTLE场，您将学会如何从轨迹数据中揭示这些输运屏障。",
            "id": "3797379",
            "problem": "考虑一个称为双涡流的二维、瞬态、无量纲化的流场。该速度场定义在矩形域上，其中水平坐标 $x \\in [0,2]$，垂直坐标 $y \\in [0,1]$，时间 $t \\ge 0$。速度场 $\\mathbf{v}(x,y,t) = (u(x,y,t), v(x,y,t))$ 由标量函数 $f(x,t)$ 及其空间导数 $\\frac{\\partial f}{\\partial x}$ 按如下方式构造。定义瞬态系数 $a(t)$ 和 $b(t)$ 为\n$$\na(t) = \\varepsilon \\sin(\\omega t), \\qquad b(t) = 1 - 2 \\varepsilon \\sin(\\omega t),\n$$\n以及函数\n$$\nf(x,t) = a(t) x^2 + b(t) x, \\qquad \\frac{\\partial f}{\\partial x}(x,t) = 2 a(t) x + b(t).\n$$\n速度分量为\n$$\nu(x,y,t) = -\\pi A \\sin(\\pi f(x,t)) \\cos(\\pi y), \\qquad v(x,y,t) = \\pi A \\cos(\\pi f(x,t)) \\sin(\\pi y) \\frac{\\partial f}{\\partial x}(x,t),\n$$\n其中 $A0$ 是无量纲振幅，$\\varepsilon \\ge 0$ 控制涡流的水平振荡，$\\omega  0$ 是振荡频率。该流场在计算海洋学中被广泛用作瞬态涡流和输运的最小模型。\n\n从拉格朗日视角来看，流体质点的位置 $(x(t), y(t))$ 根据以下常微分方程演化\n$$\n\\frac{dx}{dt} = u(x(t), y(t), t), \\qquad \\frac{dy}{dt} = v(x(t), y(t), t),\n$$\n初始条件为 $(x(0), y(0)) = (x_0, y_0)$。流映射 $\\Phi_{0}^{T}$ 将每个初始位置 $(x_0, y_0)$ 在有限积分时间 $T0$ 后映射到最终位置 $(x(T), y(T))$。前向有限时间李雅普诺夫指数 (FTLE) 场 $\\sigma_T(x_0, y_0)$ 由流映射梯度的最大奇异值定义。将雅可比矩阵（流映射相对于初始条件的梯度）表示为\n$$\n\\mathbf{J}(x_0, y_0) = \\nabla \\Phi_{0}^{T}(x_0, y_0) = \n\\begin{bmatrix}\n\\frac{\\partial x(T)}{\\partial x_0}  \\frac{\\partial x(T)}{\\partial y_0} \\\\\n\\frac{\\partial y(T)}{\\partial x_0}  \\frac{\\partial y(T)}{\\partial y_0}\n\\end{bmatrix}.\n$$\n右 Cauchy–Green 应变张量为\n$$\n\\mathbf{C}(x_0, y_0) = \\mathbf{J}(x_0, y_0)^\\top \\mathbf{J}(x_0, y_0),\n$$\n该张量是对称半正定的。令 $\\lambda_{\\max}(x_0, y_0)$ 表示 $\\mathbf{C}(x_0, y_0)$ 的最大特征值。前向 FTLE 为\n$$\n\\sigma_T(x_0, y_0) = \\frac{1}{|T|} \\ln\\left(\\sqrt{\\lambda_{\\max}(x_0, y_0)}\\right).\n$$\n排斥性拉格朗日相干结构 (LCS) 与前向 FTLE 场的脊线相关，这些脊线通过最大化前向时间内邻近轨迹的有限时间分离来充当输运屏障。\n\n您的任务是在一个单一的、自包含的程序中实现以下内容：\n1. 在域 $[0,2] \\times [0,1]$ 内的均匀初始条件网格 $(x_0, y_0)$ 上计算前向 FTLE 场 $\\sigma_T(x_0, y_0)$。使用质点运动方程的数值积分和雅可比矩阵 $\\mathbf{J}(x_0, y_0)$ 的有限差分近似。使用四阶 Runge–Kutta 时间步进方法积分轨迹。雅可比矩阵的列应通过流映射相对于初始条件的有限差分来近似，即通过平流 $(x_0, y_0)$、$(x_0+\\delta_0, y_0)$ 和 $(x_0, y_0+\\delta_0)$ 并形成差分，其中 $\\delta_00$ 是无量纲单位下的一个小扰动振幅。\n2. 将 FTLE 场中的排斥性 LCS 脊线识别为满足以下条件的网格点：相对于其四个轴对齐的邻居（上、下、左、右）是严格的局部最大值，并且其 FTLE 值超过 FTLE 场的预定分位数阈值。设分位数阈值为 $q \\in (0,1)$，并将截断值 $\\tau$ 定义为 FTLE 值集合的 $q$-分位数；只有满足 $\\sigma_T(x_0, y_0) \\ge \\tau$ 且严格大于其四个轴对齐邻居中每一个点的点才应被标记为脊线。\n3. 对于下面测试套件中每个指定的参数集，计算 FTLE 场及其脊线的以下摘要指标：\n   (i) 网格上的空间平均值 $\\overline{\\sigma}_T$，\n   (ii) 网格上的最大值 $\\sigma_T^{\\max}$，\n   (iii) 根据步骤2中的标准检测到的脊线点的整数计数 $N_{\\text{ridge}}$。\n4. 所有量都是无量纲的，因此应不带物理单位进行报告。为保证可复现性，将每个浮点输出四舍五入到六位小数。\n\n使用以下参数值测试套件来检验双涡流和 FTLE 计算的不同行为：\n- 案例 1（一般瞬态情况，中等积分时间）：\n  $A = 0.1$, $\\varepsilon = 0.25$, $\\omega = \\frac{2\\pi}{10}$, $T = 5.0$, 时间步长 $\\Delta t = 0.02$, 扰动 $\\delta_0 = 10^{-4}$, 网格分辨率 $N_x = 31$, $N_y = 16$, 分位数阈值 $q = 0.90$。\n- 案例 2（更强的平流振幅和更长的积分时间）：\n  $A = 0.2$, $\\varepsilon = 0.25$, $\\omega = \\frac{2\\pi}{10}$, $T = 10.0$, 时间步长 $\\Delta t = 0.02$, 扰动 $\\delta_0 = 10^{-4}$, 网格分辨率 $N_x = 25$, $N_y = 13$, 分位数阈值 $q = 0.90$。\n- 案例 3（零振荡振幅的稳态流边缘情况）：\n  $A = 0.1$, $\\varepsilon = 0.0$, $\\omega = \\frac{2\\pi}{10}$, $T = 5.0$, 时间步长 $\\Delta t = 0.02$, 扰动 $\\delta_0 = 10^{-4}$, 网格分辨率 $N_x = 31$, $N_y = 16$, 分位数阈值 $q = 0.90$。\n\n您的程序应输出单行内容，其中包含一个逗号分隔的列表，列表由每个案例的三元组构成，并用方括号括起来，每个三元组本身也用方括号括起来，且没有空格。格式必须为\n$$\n[[\\overline{\\sigma}_T^{(1)},\\sigma_T^{\\max,(1)},N_{\\text{ridge}}^{(1)}],[\\overline{\\sigma}_T^{(2)},\\sigma_T^{\\max,(2)},N_{\\text{ridge}}^{(2)}],[\\overline{\\sigma}_T^{(3)},\\sigma_T^{\\max,(3)},N_{\\text{ridge}}^{(3)}]],\n$$\n其中上标 $(1)$、$(2)$ 和 $(3)$ 表示案例索引，每个浮点值四舍五入到六位小数，而每个计数为整数。例如，输出应如下所示\n$$\n[[0.123456,0.234567,42],[0.345678,0.456789,37],[0.567890,0.678901,15]].\n$$",
            "solution": "该问题是有效的，因为它在地球物理流体动力学这一成熟领域有科学依据，特别是使用标准的双涡流模型来研究拉格朗日输运。该问题是适定的，提供了所有必要的参数、定义，以及一组清晰、客观的任务，这些任务可以导出一个唯一的、可验证的计算结果。这是一个计算科学领域的实质性问题，需要实现常微分方程的数值方法和矩阵分析。\n\n任务是为一个二维、瞬态的双涡流计算前向有限时间李雅普诺夫指数 (FTLE) 场，将此场中的脊线识别为排斥性拉格朗日相干结构 (LCS)，并报告指定参数集的若干摘要统计数据。\n\n速度场 $\\mathbf{v}(x,y,t) = (u(x,y,t), v(x,y,t))$ 定义在域 $x \\in [0,2]$ 和 $y \\in [0,1]$ 上。其分量由一个标量函数 $f(x,t)$ 及其导数确定。瞬态系数为\n$$\na(t) = \\varepsilon \\sin(\\omega t), \\qquad b(t) = 1 - 2 \\varepsilon \\sin(\\omega t),\n$$\n其中 $\\varepsilon$ 是涡流振荡振幅，$\\omega$ 是振荡频率。这些用于定义函数 $f(x,t)$ 及其空间导数 $\\frac{\\partial f}{\\partial x}(x,t)$：\n$$\nf(x,t) = a(t) x^2 + b(t) x,\n$$\n$$\n\\frac{\\partial f}{\\partial x}(x,t) = 2 a(t) x + b(t).\n$$\n然后，速度分量由以下公式给出：\n$$\nu(x,y,t) = -\\pi A \\sin(\\pi f(x,t)) \\cos(\\pi y),\n$$\n$$\nv(x,y,t) = \\pi A \\cos(\\pi f(x,t)) \\sin(\\pi y) \\frac{\\partial f}{\\partial x}(x,t),\n$$\n其中 $A$ 是无量纲速度振幅。\n\n一个流体质点的轨迹，表示为 $\\mathbf{x}(t) = (x(t), y(t))$，由以下常微分方程 (ODE) 组控制：\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}(\\mathbf{x}(t), t), \\quad \\text{with initial condition} \\quad \\mathbf{x}(0) = \\mathbf{x}_0 = (x_0, y_0).\n$$\n这个 ODE 系统的解定义了流映射 $\\Phi_{0}^{T}$，它将一个初始位置 $\\mathbf{x}_0$ 在时间间隔 $[0, T]$ 内平流到其最终位置 $\\mathbf{x}(T)$。我们使用四阶 Runge-Kutta (RK4) 方法对解进行数值近似。对于一个时间步长 $\\Delta t$，将解从时间 $t_n$ 推进到 $t_n + \\Delta t$ 的单个 RK4 步骤是：\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4),\n$$\n其中\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{v}(\\mathbf{x}_n, t_n), \\\\\n\\mathbf{k}_2 = \\mathbf{v}(\\mathbf{x}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1, t_n + \\frac{\\Delta t}{2}), \\\\\n\\mathbf{k}_3 = \\mathbf{v}(\\mathbf{x}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2, t_n + \\frac{\\Delta t}{2}), \\\\\n\\mathbf{k}_4 = \\mathbf{v}(\\mathbf{x}_n + \\Delta t\\mathbf{k}_3, t_n + \\Delta t).\n\\end{aligned}\n$$\nFTLE 场 $\\sigma_T(\\mathbf{x}_0)$ 量化了在时间间隔 $T$ 内，初始邻近质点分离的最大速率。它源自流映射的雅可比矩阵 $\\mathbf{J}(\\mathbf{x}_0) = \\nabla \\Phi_{0}^{T}(\\mathbf{x}_0)$。雅可比矩阵的列使用前向有限差分格式进行近似。这需要计算三个紧密间隔的初始位置的流映射：中心点 $\\mathbf{x}_0 = (x_0, y_0)$，一个 $x$ 方向扰动点 $(x_0+\\delta_0, y_0)$，以及一个 $y$ 方向扰动点 $(x_0, y_0+\\delta_0)$，其中 $\\delta_0$ 是一个小扰动。然后 $\\mathbf{J}$ 的列为：\n$$\n\\frac{\\partial \\Phi_{0}^{T}}{\\partial x_0} \\approx \\frac{\\Phi_{0}^{T}(x_0+\\delta_0, y_0) - \\Phi_{0}^{T}(x_0, y_0)}{\\delta_0}, \\qquad\n\\frac{\\partial \\Phi_{0}^{T}}{\\partial y_0} \\approx \\frac{\\Phi_{0}^{T}(x_0, y_0+\\delta_0) - \\Phi_{0}^{T}(x_0, y_0)}{\\delta_0}.\n$$\n根据雅可比矩阵 $\\mathbf{J}$，我们计算右 Cauchy-Green 应变张量 $\\mathbf{C}(\\mathbf{x}_0) = \\mathbf{J}(\\mathbf{x}_0)^\\top \\mathbf{J}(\\mathbf{x}_0)$。该张量是对称半正定的，其特征值表示主拉伸的平方。令 $\\lambda_{\\max}(\\mathbf{x}_0)$ 为 $\\mathbf{C}(\\mathbf{x}_0)$ 的最大特征值。FTLE 定义为：\n$$\n\\sigma_T(\\mathbf{x}_0) = \\frac{1}{|T|} \\ln\\left(\\sqrt{\\lambda_{\\max}(\\mathbf{x}_0)}\\right) = \\frac{1}{2|T|} \\ln\\left(\\lambda_{\\max}(\\mathbf{x}_0)\\right).\n$$\n对覆盖域 $[0,2] \\times [0,1]$ 的均匀初始条件网格 $(x_0, y_0)$ 上的每个点执行此计算，以生成 FTLE 场。\n\n在计算出的 FTLE 场中，使用一个两部分准则来识别排斥性 LCS 脊线。一个网格点 $(i, j)$ 被分类为脊线点，如果：\n1.  其 FTLE 值 $\\sigma_T(i, j)$ 大于或等于阈值 $\\tau$，其中 $\\tau$ 是 FTLE 场中所有值的 $q$-分位数。\n2.  $\\sigma_T(i, j)$ 相对于其四个轴对齐的邻居（上、下、左、右）是严格的局部最大值。\n\n最后，对于每个参数案例，我们从 FTLE 场中计算三个摘要指标：\n1.  空间平均值 $\\overline{\\sigma}_T$：FTLE 网格中所有值的平均值。\n2.  最大值 $\\sigma_T^{\\max}$：FTLE 网格中的最大值。\n3.  脊线计数 $N_{\\text{ridge}}$：满足脊线准则的网格点总数。\n\n整个算法通过迭代每个测试案例来进行。对于给定的案例，建立一个初始条件网格。对于每个网格点，使用 RK4 方法积分三条轨迹，以计算雅可比矩阵有限差分近似所需的最终位置。然后计算 FTLE 值。在计算完整个 FTLE 场后，对其进行后处理以计数脊线点并确定摘要统计数据。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It computes FTLE fields, identifies ridges, calculates summary statistics,\n    and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": 0.1, \"eps\": 0.25, \"omega\": 2 * np.pi / 10, \"T\": 5.0,\n            \"dt\": 0.02, \"delta0\": 1e-4, \"Nx\": 31, \"Ny\": 16, \"q\": 0.90\n        },\n        {\n            \"A\": 0.2, \"eps\": 0.25, \"omega\": 2 * np.pi / 10, \"T\": 10.0,\n            \"dt\": 0.02, \"delta0\": 1e-4, \"Nx\": 25, \"Ny\": 13, \"q\": 0.90\n        },\n        {\n            \"A\": 0.1, \"eps\": 0.0, \"omega\": 2 * np.pi / 10, \"T\": 5.0,\n            \"dt\": 0.02, \"delta0\": 1e-4, \"Nx\": 31, \"Ny\": 16, \"q\": 0.90\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        ftle_field = compute_ftle_field(**params)\n        \n        avg_sigma = np.mean(ftle_field)\n        max_sigma = np.max(ftle_field)\n        \n        tau = np.quantile(ftle_field, params['q'])\n        \n        ridge_count = 0\n        Ny, Nx = ftle_field.shape\n        # Iterate over interior points to check for local maxima\n        for j in range(1, Ny - 1):\n            for i in range(1, Nx - 1):\n                val = ftle_field[j, i]\n                if val >= tau:\n                    up = ftle_field[j + 1, i]\n                    down = ftle_field[j - 1, i]\n                    left = ftle_field[j, i - 1]\n                    right = ftle_field[j, i + 1]\n                    if val > up and val > down and val > left and val > right:\n                        ridge_count += 1\n                        \n        all_results.append(\n            f\"[{round(avg_sigma, 6):.6f},{round(max_sigma, 6):.6f},{ridge_count}]\"\n        )\n\n    print(f\"[{','.join(all_results)}]\")\n\ndef velocity(t, pos, A, eps, omega):\n    \"\"\"\n    Computes the velocity vector (u, v) for the double-gyre flow.\n    \n    Args:\n        t (float): Current time.\n        pos (np.ndarray): 2D position [x, y].\n        A (float): Advection amplitude.\n        eps (float): Gyre oscillation amplitude.\n        omega (float): Gyre oscillation frequency.\n\n    Returns:\n        np.ndarray: Velocity vector [u, v].\n    \"\"\"\n    x, y = pos[0], pos[1]\n    \n    a_t = eps * np.sin(omega * t)\n    b_t = 1 - 2 * a_t\n    \n    f_xt = a_t * x**2 + b_t * x\n    dfdx = 2 * a_t * x + b_t\n    \n    sin_pi_f = np.sin(np.pi * f_xt)\n    cos_pi_f = np.cos(np.pi * f_xt)\n    sin_pi_y = np.sin(np.pi * y)\n    cos_pi_y = np.cos(np.pi * y)\n    \n    u = -np.pi * A * sin_pi_f * cos_pi_y\n    v = np.pi * A * cos_pi_f * sin_pi_y * dfdx\n    \n    return np.array([u, v])\n\ndef rk4_step(func, t, y, dt, **kwargs):\n    \"\"\"\n    Performs a single step of the fourth-order Runge-Kutta method.\n    \"\"\"\n    k1 = func(t, y, **kwargs)\n    k2 = func(t + 0.5 * dt, y + 0.5 * dt * k1, **kwargs)\n    k3 = func(t + 0.5 * dt, y + 0.5 * dt * k2, **kwargs)\n    k4 = func(t + dt, y + dt * k3, **kwargs)\n    return y + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\ndef compute_flow_map(x0, y0, T, dt, **kwargs):\n    \"\"\"\n    Computes the flow map Phi_0^T by integrating a trajectory.\n    \"\"\"\n    pos = np.array([x0, y0])\n    num_steps = int(round(T / dt))\n    \n    for i in range(num_steps):\n        t = i * dt\n        pos = rk4_step(velocity, t, pos, dt, **kwargs)\n        \n    return pos\n\ndef compute_ftle_field(A, eps, omega, T, dt, delta0, Nx, Ny, q):\n    \"\"\"\n    Computes the FTLE field for a given set of parameters.\n    \"\"\"\n    x_grid = np.linspace(0.0, 2.0, Nx)\n    y_grid = np.linspace(0.0, 1.0, Ny)\n    \n    ftle_field = np.zeros((Ny, Nx))\n    \n    flow_map_args = {\"T\": T, \"dt\": dt, \"A\": A, \"eps\": eps, \"omega\": omega}\n\n    for j in range(Ny):\n        for i in range(Nx):\n            x0, y0 = x_grid[i], y_grid[j]\n            \n            # Advect central and perturbed points\n            pos_T = compute_flow_map(x0, y0, **flow_map_args)\n            pos_T_dx = compute_flow_map(x0 + delta0, y0, **flow_map_args)\n            pos_T_dy = compute_flow_map(x0, y0 + delta0, **flow_map_args)\n            \n            # Approximate Jacobian using finite differences\n            J = np.zeros((2, 2))\n            J[:, 0] = (pos_T_dx - pos_T) / delta0\n            J[:, 1] = (pos_T_dy - pos_T) / delta0\n            \n            # Compute Cauchy-Green tensor C = J^T * J\n            C = J.T @ J\n            \n            # Eigenvalues of the symmetric matrix C\n            lambda_max = np.max(np.linalg.eigvalsh(C))\n            \n            # FTLE calculation, handling lambda_max = 0\n            if lambda_max > 0:\n                ftle = (1 / (2 * T)) * np.log(lambda_max)\n            else:\n                ftle = 0.0\n\n            ftle_field[j, i] = ftle\n            \n    return ftle_field\n\nsolve()\n```"
        }
    ]
}