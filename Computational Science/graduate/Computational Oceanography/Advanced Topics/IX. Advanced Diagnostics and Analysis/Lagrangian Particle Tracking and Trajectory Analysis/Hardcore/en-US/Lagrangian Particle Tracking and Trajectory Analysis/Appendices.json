{
    "hands_on_practices": [
        {
            "introduction": "Before diving into complex numerical simulations, it is crucial to solidify our understanding of the fundamental link between the Eulerian velocity field and the properties experienced by a moving fluid parcel. This exercise explores the material derivative, a cornerstone concept that quantifies the rate of change following a fluid element. By calculating it in a classic straining flow from both the Lagrangian and Eulerian perspectives, you will build a strong intuition for how parcels are stretched and compressed and verify the mathematical equivalence of these two fundamental viewpoints. ",
            "id": "3797356",
            "problem": "Consider a two-dimensional, time-independent straining flow representative of an idealized frontal zone in the ocean. The velocity field is given by $\\mathbf{u}(x,y)=\\left(a x,\\,-a y\\right)$, where $a>0$ is a constant with units of inverse time. Let the scalar field $\\phi(x,y)=x^{2}+y^{2}$ denote the squared distance to the origin. Using the Lagrangian particle-tracking framework and only first principles, namely the kinematic relations $\\mathrm{d}x/\\mathrm{d}t=u_{x}$ and $\\mathrm{d}y/\\mathrm{d}t=u_{y}$ for fluid parcels, and the definition that the material derivative $D\\phi/Dt$ is the rate of change of $\\phi$ following a fluid parcel, derive an explicit expression for $D\\phi/Dt$ valid for arbitrary $(x,y)$. Then, verify the same expression by an Eulerian calculation based on spatial gradients and time independence, and interpret the result physically in terms of straining when viewed in both the Eulerian and Lagrangian frames. Express your final result for $D\\phi/Dt$ as a closed-form algebraic expression in terms of $a$, $x$, and $y$. No numerical evaluation is required, and no rounding is needed.",
            "solution": "The problem has been validated and is deemed sound, well-posed, and scientifically grounded. All required information is provided, the physical scenario is a standard idealization in fluid dynamics, and the tasks are clearly defined.\n\nThe problem asks for the derivation of the material derivative, $\\frac{D\\phi}{Dt}$, of the scalar field $\\phi(x,y)=x^{2}+y^{2}$ within the velocity field $\\mathbf{u}(x,y)=(ax, -ay)$, using two different formalisms: Lagrangian and Eulerian. The constant $a$ is positive.\n\nFirst, we will perform the derivation from a Lagrangian perspective. In this framework, we follow an individual fluid parcel and observe how the property $\\phi$ changes for that specific parcel over time. Let the position of a fluid parcel at time $t$ be given by the vector $\\mathbf{r}(t) = (x(t), y(t))$. The velocity of the parcel is, by definition, the fluid velocity at its current position. This is described by the system of ordinary differential equations given in the problem statement:\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} = u_x = ax(t)\n$$\n$$\n\\frac{\\mathrm{d}y}{\\mathrm{d}t} = u_y = -ay(t)\n$$\nThe scalar quantity $\\phi$ evaluated along the parcel's trajectory becomes a function of time only, which we can denote as $\\Phi(t) = \\phi(x(t), y(t)) = (x(t))^{2} + (y(t))^{2}$. The material derivative, $\\frac{D\\phi}{Dt}$, is defined as the total time derivative of this function, $\\frac{\\mathrm{d}\\Phi}{\\mathrm{d}t}$. We compute this derivative using the chain rule for multivariable functions:\n$$\n\\frac{D\\phi}{Dt} = \\frac{\\mathrm{d}\\Phi}{\\mathrm{d}t} = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left[ (x(t))^{2} + (y(t))^{2} \\right] = 2x(t) \\frac{\\mathrm{d}x}{\\mathrm{d}t} + 2y(t) \\frac{\\mathrm{d}y}{\\mathrm{d}t}\n$$\nNow, we substitute the expressions for the velocity components $\\frac{\\mathrm{d}x}{\\mathrm{d}t}$ and $\\frac{\\mathrm{d}y}{\\mathrm{d}t}$ into this equation. At any point $(x,y)$ on the trajectory, we have:\n$$\n\\frac{D\\phi}{Dt} = 2x(ax) + 2y(-ay)\n$$\nSimplifying this algebraic expression gives the result:\n$$\n\\frac{D\\phi}{Dt} = 2ax^{2} - 2ay^{2} = 2a(x^{2} - y^{2})\n$$\nThis is the expression for the material derivative derived from first principles in the Lagrangian frame. It is valid for any point $(x,y)$ in the flow field.\n\nSecond, we verify this result using an Eulerian calculation. In the Eulerian framework, we consider changes at fixed points in space. The material derivative of a scalar field $\\phi(\\mathbf{r}, t)$ in a velocity field $\\mathbf{u}(\\mathbf{r}, t)$ is given by the general formula:\n$$\n\\frac{D\\phi}{Dt} = \\frac{\\partial \\phi}{\\partial t} + (\\mathbf{u} \\cdot \\nabla)\\phi = \\frac{\\partial \\phi}{\\partial t} + \\mathbf{u} \\cdot \\nabla\\phi\n$$\nThe term $\\frac{\\partial \\phi}{\\partial t}$ is the local rate of change at a fixed point, and the term $\\mathbf{u} \\cdot \\nabla\\phi$ is the advective rate of change, representing the change due to the movement of fluid with different values of $\\phi$ past the point.\nIn this problem, the scalar field is given as $\\phi(x,y) = x^{2} + y^{2}$, which does not explicitly depend on time $t$. Therefore, the local time derivative is zero:\n$$\n\\frac{\\partial \\phi}{\\partial t} = 0\n$$\nThe velocity vector is $\\mathbf{u} = (u_x, u_y) = (ax, -ay)$.\nThe gradient of the scalar field $\\phi$ is:\n$$\n\\nabla\\phi = \\left( \\frac{\\partial \\phi}{\\partial x}, \\frac{\\partial \\phi}{\\partial y} \\right) = \\left( \\frac{\\partial}{\\partial x}(x^{2}+y^{2}), \\frac{\\partial}{\\partial y}(x^{2}+y^{2}) \\right) = (2x, 2y)\n$$\nNow we compute the advective term, which is the dot product of the velocity vector and the gradient of $\\phi$:\n$$\n\\mathbf{u} \\cdot \\nabla\\phi = (ax, -ay) \\cdot (2x, 2y) = (ax)(2x) + (-ay)(2y)\n$$\n$$\n\\mathbf{u} \\cdot \\nabla\\phi = 2ax^{2} - 2ay^{2}\n$$\nSubstituting these components back into the formula for the material derivative:\n$$\n\\frac{D\\phi}{Dt} = 0 + 2ax^{2} - 2ay^{2} = 2a(x^{2} - y^{2})\n$$\nThis result is identical to the one obtained via the Lagrangian method, which validates the calculation.\n\nFinally, we interpret the result physically. The velocity field $\\mathbf{u}=(ax, -ay)$ describes a pure straining flow, with an axis of extension along the $x$-axis and an axis of compression along the $y$-axis. The origin $(0,0)$ is a hyperbolic fixed point (a saddle point). Fluid parcels are stretched away from the $y$-axis and compressed toward the $x$-axis.\nThe scalar field $\\phi=x^{2}+y^{2}$ represents the squared distance of a point from the origin. The material derivative $\\frac{D\\phi}{Dt} = 2a(x^{2} - y^{2})$ thus measures the rate at which a fluid parcel's squared distance from the origin is changing as it moves through the flow.\nThe sign of $\\frac{D\\phi}{Dt}$ depends on the parcel's position:\n- If $|x| > |y|$, then $x^{2} > y^{2}$ and $\\frac{D\\phi}{Dt} > 0$. This corresponds to the two sectors of the plane containing the $x$-axis (the axis of extension). In these regions, the stretching effect of the flow dominates, and fluid parcels move away from the origin.\n- If $|x| < |y|$, then $x^{2} < y^{2}$ and $\\frac{D\\phi}{Dt} < 0$. This corresponds to the two sectors containing the $y$-axis (the axis of compression). Here, the compressive effect of the flow dominates, and fluid parcels move towards the origin.\n- If $|x| = |y|$, i.e., on the lines $y = x$ and $y = -x$, then $\\frac{D\\phi}{Dt} = 0$. At any point on these lines, a parcel is momentarily moving such that its distance to the origin is stationary. The outward-pushing effect of the extension is perfectly balanced by the inward-pulling effect of the compression. These lines separate regions where parcels are moving away from the origin from regions where they are moving towards it.\n\nFrom the Lagrangian perspective, $\\frac{D\\phi}{Dt}$ is the actual rate of change of $\\phi$ experienced by a moving particle. From the Eulerian perspective, this change is entirely due to advection ($\\frac{\\partial\\phi}{\\partial t}=0$), meaning that at any point $(x,y)$, the value of $\\phi$ changes only because the fluid parcel arriving at that point comes from a location with a different value of $\\phi$. The two perspectives provide a consistent description of the same physical process.",
            "answer": "$$\n\\boxed{2a(x^2 - y^2)}\n$$"
        },
        {
            "introduction": "In realistic applications like global oceanography, particle trajectories must be computed numerically and are often constrained to a specific geometry, such as the surface of the Earth. Standard numerical integrators like the Runge-Kutta method can introduce errors that cause particles to drift from this surface, violating physical constraints. This practice guides you through the design and implementation of a projection method, a vital technique to ensure that numerically integrated trajectories remain on a spherical surface, a fundamental skill for building robust, large-scale Lagrangian models. ",
            "id": "3797380",
            "problem": "Consider a Lagrangian particle moving on the surface of a sphere under a prescribed velocity field. The particle position is represented in Cartesian coordinates as a vector $\\mathbf{r}(t) \\in \\mathbb{R}^3$ constrained by $\\|\\mathbf{r}(t)\\| = R$, where $R$ is the constant sphere radius. The kinematics are given by the ordinary differential equation (ODE) $\\dfrac{d\\mathbf{r}}{dt} = \\mathbf{u}(\\mathbf{r}, t)$, where $\\mathbf{u}(\\mathbf{r}, t)$ is the velocity field specified in physical units. The task is to design a numerical time-stepping method that integrates the ODE and includes a projection step so that after each time update the position satisfies $\\|\\mathbf{r}\\| = R$ exactly.\n\nStarting from the fundamental definitions:\n- The trajectory satisfies $\\dfrac{d\\mathbf{r}}{dt} = \\mathbf{u}(\\mathbf{r}, t)$ and the spherical constraint $\\mathbf{r}(t) \\cdot \\mathbf{r}(t) = R^2$.\n- Differentiating the constraint with respect to time yields $2\\,\\mathbf{r}(t) \\cdot \\dfrac{d\\mathbf{r}}{dt} = 0$, implying that a physically consistent velocity on the sphere must satisfy $\\mathbf{r}(t) \\cdot \\mathbf{u}(\\mathbf{r}(t), t) = 0$.\n\nIn numerical practice, explicit time-stepping methods such as fourth-order Runge-Kutta (RK4) do not preserve holonomic constraints exactly, leading to drift in $\\|\\mathbf{r}\\|$. Your goals are:\n1. Derive from first principles a projection step that, when applied to the updated position after a time step, ensures $\\|\\mathbf{r}\\| = R$ is exactly satisfied.\n2. Implement a complete algorithm that integrates the ODE using an explicit method and applies the projection step after each update.\n3. Quantify the effectiveness of the projection by comparing the constraint drift for the method with and without the projection step, and by measuring trajectory accuracy against an analytical reference where available.\n\nUse the following velocity fields, parameters, and initial conditions as a test suite. All angles are in radians, angular velocities in radians per second, and all distances in meters. Time is in seconds.\n\nDefinitions of velocity fields:\n- Solid-body rotation about the $\\hat{\\mathbf{z}}$ axis: $\\mathbf{u}(\\mathbf{r}, t) = \\boldsymbol{\\Omega}(t) \\times \\mathbf{r}$ with $\\boldsymbol{\\Omega}(t) = \\Omega(t)\\,\\hat{\\mathbf{z}}$, where $\\hat{\\mathbf{z}} = (0, 0, 1)$ and $\\times$ denotes the cross product.\n- For constant rotation, $\\Omega(t) = \\Omega_0$.\n- For time-varying rotation, $\\Omega(t) = \\Omega_0 \\cos(\\sigma t)$, with angular frequency $\\sigma$.\n\nAnalytical references for validation:\n- For constant $\\Omega(t) = \\Omega_0$, the exact solution is a rotation by angle $\\theta(t) = \\Omega_0 t$ about the $\\hat{\\mathbf{z}}$ axis.\n- For $\\Omega(t) = \\Omega_0 \\cos(\\sigma t)$, the rotation angle is $\\theta(t) = \\int_0^t \\Omega(\\tau)\\,d\\tau = \\dfrac{\\Omega_0}{\\sigma} \\sin(\\sigma t)$.\n\nTest suite:\n- Case A (baseline, \"happy path\"): $R = 6{,}371{,}000$, $\\Omega_0 = 7.2921159 \\times 10^{-5}$, time step $\\Delta t = 600$, total time $T = 172{,}800$, initial position $\\mathbf{r}_0 = (R, 0, 0)$, constant rotation.\n- Case B (coarse time step, stability edge): $R = 6{,}371{,}000$, $\\Omega_0 = 7.2921159 \\times 10^{-5}$, time step $\\Delta t = 7{,}200$, total time $T = 86{,}400$, initial position $\\mathbf{r}_0 = (0, R, 0)$, constant rotation.\n- Case C (time-dependent rotation rate): $R = 6{,}371{,}000$, $\\Omega_0 = 7.2921159 \\times 10^{-5}$, $\\sigma = \\dfrac{2\\pi}{86{,}400}$, time step $\\Delta t = 600$, total time $T = 86{,}400$, initial position $\\mathbf{r}_0 = (R, 0, 0)$, time-varying rotation.\n\nImplementation requirements:\n- Use an explicit RK4 method to advance $\\mathbf{r}$ in time for both \"without projection\" and \"with projection\" versions.\n- Design and use a projection step based on your derivation to enforce $\\|\\mathbf{r}\\| = R$ after each full RK4 update in the \"with projection\" version.\n- For each test case, compute the following three quantitative metrics in meters:\n  1. The maximum deviation from the spherical constraint without projection: $\\max_{n} \\left|\\|\\mathbf{r}_n\\| - R\\right|$ over all time steps $n$.\n  2. The maximum deviation from the spherical constraint with projection: $\\max_{n} \\left|\\|\\mathbf{r}_n\\| - R\\right|$ over all time steps $n$.\n  3. The final great-circle arc-length error between the numerically projected solution and the analytical reference trajectory at time $T$: $s = R \\,\\arccos\\!\\left(\\dfrac{\\mathbf{r}_{\\text{num}}(T) \\cdot \\mathbf{r}_{\\text{ref}}(T)}{R^2}\\right)$, where the arccosine argument must be clamped to the interval $[-1, 1]$ to avoid numerical issues.\n\nYour program should produce a single line of output containing the nine results (three per test case, in the order listed above for Cases A, B, C) as a comma-separated list enclosed in square brackets, expressed in meters. For example, your output must be of the form $[\\text{a}_1,\\text{a}_2,\\text{a}_3,\\text{b}_1,\\text{b}_2,\\text{b}_3,\\text{c}_1,\\text{c}_2,\\text{c}_3]$, where each entry is a floating-point number in meters.",
            "solution": "The problem requires the design, implementation, and validation of a numerical method for integrating the trajectory of a Lagrangian particle on a sphere. The core of the problem lies in addressing the numerical drift from the spherical constraint that arises from explicit time-stepping schemes. The solution will be presented in three parts: first, the derivation of a projection operator to enforce the constraint; second, the description of the complete numerical algorithm; and third, the methodology for quantifying the effectiveness of the projection.\n\nA particle's position is given by the vector $\\mathbf{r}(t) \\in \\mathbb{R}^3$, which evolves according to the ordinary differential equation (ODE) $\\dfrac{d\\mathbf{r}}{dt} = \\mathbf{u}(\\mathbf{r}, t)$. The particle is constrained to the surface of a sphere of radius $R$, which imposes the holonomic constraint $\\|\\mathbf{r}(t)\\| = R$, or equivalently, $\\mathbf{r}(t) \\cdot \\mathbf{r}(t) = R^2$. A physically consistent velocity field $\\mathbf{u}$ on the sphere must be tangential to the surface at all points, satisfying the condition $\\mathbf{r} \\cdot \\mathbf{u}(\\mathbf{r}, t) = 0$. While the analytical velocity field provided, $\\mathbf{u}(\\mathbf{r}, t) = \\boldsymbol{\\Omega}(t) \\times \\mathbf{r}$, adheres to this property, numerical integration methods like the fourth-order Runge-Kutta (RK4) scheme introduce discretization errors that cause the numerical solution to drift off the sphere, violating the constraint.\n\nThe first step is to derive a method to correct this drift. Let $\\mathbf{r}_n$ be the particle's position at time $t_n$, which is assumed to lie exactly on the sphere, i.e., $\\|\\mathbf{r}_n\\| = R$. After one step of a numerical integrator (such as RK4) over a time interval $\\Delta t$, we obtain an intermediate position $\\mathbf{r}_{n+1}^*$. Due to truncation error, this new position will generally not be on the sphere, so $\\|\\mathbf{r}_{n+1}^*\\| \\neq R$. We seek a projected position, $\\mathbf{r}_{n+1}$, that satisfies the constraint $\\|\\mathbf{r}_{n+1}\\| = R$ and is a minimal correction of $\\mathbf{r}_{n+1}^*$. The most direct and geometrically intuitive correction is a radial projection. This projection maps $\\mathbf{r}_{n+1}^*$ to a point on the sphere by scaling its magnitude without changing its direction. This corresponds to finding the point on the sphere that lies on the line passing through the origin and $\\mathbf{r}_{n+1}^*$.\n\nThis can be formulated by asserting that the projected vector $\\mathbf{r}_{n+1}$ is collinear with the intermediate vector $\\mathbf{r}_{n+1}^*$. Thus, we can write $\\mathbf{r}_{n+1} = \\alpha \\mathbf{r}_{n+1}^*$ for some positive scaling factor $\\alpha$. To determine $\\alpha$, we enforce the spherical constraint on $\\mathbf{r}_{n+1}$:\n$$\n\\|\\mathbf{r}_{n+1}\\| = R\n$$\nSubstituting $\\mathbf{r}_{n+1} = \\alpha \\mathbf{r}_{n+1}^*$ yields:\n$$\n\\|\\alpha \\mathbf{r}_{n+1}^*\\| = |\\alpha| \\|\\mathbf{r}_{n+1}^*\\| = R\n$$\nSince we require a projection in the same direction (a minimal correction), we take $\\alpha > 0$. Solving for $\\alpha$ gives:\n$$\n\\alpha = \\frac{R}{\\|\\mathbf{r}_{n+1}^*\\|}\n$$\nTherefore, the projection step that renormalizes the position vector after each time update is:\n$$\n\\mathbf{r}_{n+1} = \\mathbf{r}_{n+1}^* \\left( \\frac{R}{\\|\\mathbf{r}_{n+1}^*\\|} \\right)\n$$\nThis operation ensures that the position vector satisfies the constraint to machine precision after every time step.\n\nThe second part of the task is to implement the complete algorithm. The integration is performed using the explicit fourth-order Runge-Kutta (RK4) method. Given the position $\\mathbf{r}_n$ at time $t_n$, the intermediate position $\\mathbf{r}_{n+1}^*$ at time $t_{n+1} = t_n + \\Delta t$ is calculated as:\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= \\Delta t \\cdot \\mathbf{u}(\\mathbf{r}_n, t_n) \\\\\n\\mathbf{k}_2 &= \\Delta t \\cdot \\mathbf{u}\\left(\\mathbf{r}_n + \\frac{1}{2}\\mathbf{k}_1, t_n + \\frac{1}{2}\\Delta t\\right) \\\\\n\\mathbf{k}_3 &= \\Delta t \\cdot \\mathbf{u}\\left(\\mathbf{r}_n + \\frac{1}{2}\\mathbf{k}_2, t_n + \\frac{1}{2}\\Delta t\\right) \\\\\n\\mathbf{k}_4 &= \\Delta t \\cdot \\mathbf{u}(\\mathbf{r}_n + \\mathbf{k}_3, t_n + \\Delta t) \\\\\n\\mathbf{r}_{n+1}^* &= \\mathbf{r}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{aligned}\n$$\nThe velocity function $\\mathbf{u}(\\mathbf{r}, t)$ is specified as a solid-body rotation, $\\mathbf{u}(\\mathbf{r}, t) = \\boldsymbol{\\Omega}(t) \\times \\mathbf{r}$, with $\\boldsymbol{\\Omega}(t) = \\Omega(t)\\,\\hat{\\mathbf{z}}$, where $\\hat{\\mathbf{z}} = (0, 0, 1)^T$. The function $\\Omega(t)$ is either a constant $\\Omega_0$ or time-dependent as $\\Omega(t) = \\Omega_0 \\cos(\\sigma t)$. The algorithm will be executed for a total time $T$ starting from an initial position $\\mathbf{r}_0$. Two simulations are run for each test case: one without the projection step, where $\\mathbf{r}_{n+1} = \\mathbf{r}_{n+1}^*$, and one with the projection step applied after each RK4 update.\n\nThe third part is to evaluate the method's performance using three specified metrics.\n1.  **Maximum constraint deviation without projection**: $\\max_{n} \\left|\\|\\mathbf{r}_n\\| - R\\right|$. This metric quantifies the cumulative drift from the sphere's surface when using the standard RK4 method. It is expected to be non-zero and to increase with larger time steps.\n2.  **Maximum constraint deviation with projection**: $\\max_{n} \\left|\\|\\mathbf{r}_n\\| - R\\right|$. With the projection step, this value should be close to zero, limited only by the machine's floating-point precision, demonstrating the effectiveness of the constraint enforcement.\n3.  **Final great-circle arc-length error**: This metric measures the accuracy of the projected trajectory against the known analytical solution. The error at the final time $T$ is calculated as $s = R \\,\\arccos\\!\\left(\\frac{\\mathbf{r}_{\\text{num}}(T) \\cdot \\mathbf{r}_{\\text{ref}}(T)}{R^2}\\right)$. The analytical solution $\\mathbf{r}_{\\text{ref}}(T)$ is found by rotating the initial position $\\mathbf{r}_0$ about the $\\hat{\\mathbf{z}}$-axis by an angle $\\theta(T) = \\int_0^T \\Omega(\\tau)\\,d\\tau$.\n    - For constant rotation $\\Omega(t) = \\Omega_0$, the angle is $\\theta(T) = \\Omega_0 T$.\n    - For time-varying rotation $\\Omega(t) = \\Omega_0 \\cos(\\sigma t)$, the angle is $\\theta(T) = \\frac{\\Omega_0}{\\sigma} \\sin(\\sigma T)$.\n    The argument of the $\\arccos$ function must be clamped to the interval $[-1, 1]$ to handle potential floating-point inaccuracies that might push the value slightly outside this range. This error metric assesses how well the numerical scheme (RK4 combined with projection) approximates the true dynamics on the sphere.\n\nThe implementation will simulate particle motion for the three test cases provided, calculating these nine metrics in total.",
            "answer": "```python\nimport numpy as np\nfrom scipy.constants import pi\n\ndef solve():\n    \"\"\"\n    Solves the Lagrangian particle tracking problem for three test cases.\n    \"\"\"\n\n    def u_vel(r, omega_val):\n        \"\"\"Calculates the velocity u = Omega x r, with Omega = (0, 0, omega_val).\"\"\"\n        omega_vec = np.array([0.0, 0.0, omega_val])\n        return np.cross(omega_vec, r)\n\n    def rk4_step(r_n, t_n, dt, u_func):\n        \"\"\"Performs a single RK4 step.\"\"\"\n        k1 = dt * u_func(r_n, t_n)\n        k2 = dt * u_func(r_n + 0.5 * k1, t_n + 0.5 * dt)\n        k3 = dt * u_func(r_n + 0.5 * k2, t_n + 0.5 * dt)\n        k4 = dt * u_func(r_n + k3, t_n + dt)\n        r_star = r_n + (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n        return r_star\n\n    def run_simulation(r0, R, dt, T, omega_func, do_projection):\n        \"\"\"Runs the simulation with or without projection.\"\"\"\n        num_steps = int(round(T / dt))\n        r = np.copy(r0)\n        max_radius_dev = 0.0\n\n        u_field_func = lambda r, t: u_vel(r, omega_func(t))\n\n        for i in range(num_steps):\n            t = i * dt\n            r_star = rk4_step(r, t, dt, u_field_func)\n\n            if do_projection:\n                norm_r_star = np.linalg.norm(r_star)\n                # Avoid division by zero, though unlikely here\n                if norm_r_star > 0:\n                    r = r_star * (R / norm_r_star)\n                else:\n                    r = r_star\n            else:\n                r = r_star\n\n            radius_dev = abs(np.linalg.norm(r) - R)\n            if radius_dev > max_radius_dev:\n                max_radius_dev = radius_dev\n        \n        return r, max_radius_dev\n\n    def get_analytical_solution(r0, T, omega_0, sigma=None):\n        \"\"\"Calculates the analytical solution at time T.\"\"\"\n        if sigma is None:  # Constant rotation\n            theta = omega_0 * T\n        else:  # Time-varying rotation\n            theta = (omega_0 / sigma) * np.sin(sigma * T)\n        \n        cos_theta = np.cos(theta)\n        sin_theta = np.sin(theta)\n        \n        # Rotation matrix around z-axis\n        rot_matrix = np.array([\n            [cos_theta, -sin_theta, 0.0],\n            [sin_theta,  cos_theta, 0.0],\n            [0.0,       0.0,        1.0]\n        ])\n        \n        return rot_matrix @ r0\n\n    # Define test cases from the problem statement\n    R_val = 6371000.0\n    Omega0_val = 7.2921159e-5\n    \n    test_cases = [\n        # Case A\n        {'name': 'A', 'R': R_val, 'Omega0': Omega0_val, 'sigma': None, 'dt': 600.0, 'T': 172800.0, 'r0': np.array([R_val, 0.0, 0.0])},\n        # Case B\n        {'name': 'B', 'R': R_val, 'Omega0': Omega0_val, 'sigma': None, 'dt': 7200.0, 'T': 86400.0, 'r0': np.array([0.0, R_val, 0.0])},\n        # Case C\n        {'name': 'C', 'R': R_val, 'Omega0': Omega0_val, 'sigma': (2.0 * pi) / 86400.0, 'dt': 600.0, 'T': 86400.0, 'r0': np.array([R_val, 0.0, 0.0])},\n    ]\n\n    results = []\n    for case in test_cases:\n        R = case['R']\n        Omega0 = case['Omega0']\n        sigma = case['sigma']\n        dt = case['dt']\n        T = case['T']\n        r0 = case['r0']\n\n        if sigma is None:\n            omega_function = lambda t: Omega0\n        else:\n            omega_function = lambda t: Omega0 * np.cos(sigma * t)\n\n        # 1. Run without projection\n        _, max_dev_no_proj = run_simulation(r0, R, dt, T, omega_function, do_projection=False)\n        \n        # 2. Run with projection\n        r_final_proj, max_dev_proj = run_simulation(r0, R, dt, T, omega_function, do_projection=True)\n\n        # 3. Calculate final great-circle arc-length error\n        r_ref = get_analytical_solution(r0, T, Omega0, sigma)\n        \n        # Clamp argument of arccos to avoid domain errors from floating point issues\n        dot_product_normalized = (r_final_proj @ r_ref) / (R * R)\n        clamped_arg = np.clip(dot_product_normalized, -1.0, 1.0)\n        \n        arc_error = R * np.arccos(clamped_arg)\n\n        results.extend([max_dev_no_proj, max_dev_proj, arc_error])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond tracking individual particles, Lagrangian analysis offers powerful tools to diagnose the hidden structure of the flow itself. This advanced practice introduces the concept of Finite-Time Lyapunov Exponents (FTLE), a measure of how quickly initially nearby particles separate. By computing the FTLE field for a classic time-dependent double-gyre flow, you will learn to identify its repelling Lagrangian Coherent Structures (LCS), which act as the key transport barriers that organize the entire flow pattern. ",
            "id": "3797379",
            "problem": "Consider a two-dimensional, time-dependent, non-dimensionalized flow known as the double-gyre. The velocity field is defined on the rectangular domain with horizontal coordinate $x \\in [0,2]$ and vertical coordinate $y \\in [0,1]$, and time $t \\ge 0$. The velocity field $\\mathbf{v}(x,y,t) = (u(x,y,t), v(x,y,t))$ is constructed from the scalar function $f(x,t)$ and its spatial derivative $\\partial f/\\partial x$ as follows. Define the time-dependent coefficients $a(t)$ and $b(t)$ by\n$$\na(t) = \\varepsilon \\sin(\\omega t), \\qquad b(t) = 1 - 2 \\varepsilon \\sin(\\omega t),\n$$\nand the function\n$$\nf(x,t) = a(t) x^2 + b(t) x, \\qquad \\frac{\\partial f}{\\partial x}(x,t) = 2 a(t) x + b(t).\n$$\nThe velocity components are\n$$\nu(x,y,t) = -\\pi A \\sin(\\pi f(x,t)) \\cos(\\pi y), \\qquad v(x,y,t) = \\pi A \\cos(\\pi f(x,t)) \\sin(\\pi y) \\frac{\\partial f}{\\partial x}(x,t),\n$$\nwhere $A>0$ is a non-dimensional amplitude, $\\varepsilon \\ge 0$ controls the horizontal oscillation of the gyres, and $\\omega > 0$ is the oscillation frequency. This flow is widely used in computational oceanography as a minimal model for time-dependent gyres and transport.\n\nFrom the Lagrangian perspective, the position $(x(t), y(t))$ of a fluid particle evolves according to the ordinary differential equations\n$$\n\\frac{dx}{dt} = u(x(t), y(t), t), \\qquad \\frac{dy}{dt} = v(x(t), y(t), t),\n$$\nwith initial condition $(x(0), y(0)) = (x_0, y_0)$. The flow map $\\Phi_{0}^{T}$ sends each initial position $(x_0, y_0)$ to the final position $(x(T), y(T))$ after a finite integration time $T>0$. The forward-time finite-time Lyapunov exponent (FTLE) field $\\sigma_T(x_0, y_0)$ is defined by the largest singular value of the gradient of the flow map. Denote the Jacobian matrix (the gradient of the flow map with respect to initial conditions) by\n$$\n\\mathbf{J}(x_0, y_0) = \\nabla \\Phi_{0}^{T}(x_0, y_0) = \n\\begin{bmatrix}\n\\frac{\\partial x(T)}{\\partial x_0} & \\frac{\\partial x(T)}{\\partial y_0} \\\\\n\\frac{\\partial y(T)}{\\partial x_0} & \\frac{\\partial y(T)}{\\partial y_0}\n\\end{bmatrix}.\n$$\nThe right Cauchy–Green strain tensor is\n$$\n\\mathbf{C}(x_0, y_0) = \\mathbf{J}(x_0, y_0)^\\top \\mathbf{J}(x_0, y_0),\n$$\nwhich is symmetric and positive semidefinite. Let $\\lambda_{\\max}(x_0, y_0)$ denote the largest eigenvalue of $\\mathbf{C}(x_0, y_0)$. The forward-time FTLE is\n$$\n\\sigma_T(x_0, y_0) = \\frac{1}{|T|} \\ln\\left(\\sqrt{\\lambda_{\\max}(x_0, y_0)}\\right).\n$$\nRepelling Lagrangian Coherent Structures (LCS) are associated with ridges of the forward-time FTLE field, which act as transport barriers by maximizing the finite-time separation of nearby trajectories in forward time.\n\nYour task is to implement the following in a single, self-contained program:\n1. Compute the forward-time FTLE field $\\sigma_T(x_0, y_0)$ on a uniform grid of initial conditions $(x_0, y_0)$ in the domain $[0,2] \\times [0,1]$, using numerical integration of the particle equations of motion and a finite-difference approximation to the Jacobian $\\mathbf{J}(x_0, y_0)$. Use a fourth-order Runge–Kutta time-stepping method to integrate trajectories. The Jacobian columns should be approximated by finite differences of the flow map with respect to the initial conditions, that is, by advecting $(x_0, y_0)$, $(x_0+\\delta_0, y_0)$, and $(x_0, y_0+\\delta_0)$ and forming differences, where $\\delta_0>0$ is a small perturbation amplitude in non-dimensionalized units.\n2. Identify repelling LCS ridges in the FTLE field as grid points that are strict local maxima with respect to their four axis-aligned neighbors (up, down, left, right) and whose FTLE value exceeds a prescribed quantile threshold of the FTLE field. Let the quantile threshold be $q \\in (0,1)$ and define the cutoff $\\tau$ as the $q$-quantile of the set of FTLE values; only points with $\\sigma_T(x_0, y_0) \\ge \\tau$ and strictly greater than each of their four axis-aligned neighbors should be labeled as ridges.\n3. For each specified parameter set in the test suite below, compute the following summary metrics of the FTLE field and its ridges:\n   (i) the spatial average $\\overline{\\sigma}_T$ over the grid, \n   (ii) the maximum value $\\sigma_T^{\\max}$ over the grid,\n   (iii) the integer count $N_{\\text{ridge}}$ of ridge points detected by the criterion in step $2$.\n4. All quantities are non-dimensional and should therefore be reported without physical units. For reproducibility, round each floating-point output to six decimal places.\n\nUse the following test suite of parameter values to exercise different behaviors of the double-gyre flow and the FTLE computation:\n- Case $1$ (general time-dependent case, moderate integration time):\n  $A = 0.1$, $\\varepsilon = 0.25$, $\\omega = \\frac{2\\pi}{10}$, $T = 5.0$, time step $\\Delta t = 0.02$, perturbation $\\delta_0 = 10^{-4}$, grid resolution $N_x = 31$, $N_y = 16$, quantile threshold $q = 0.90$.\n- Case $2$ (stronger advection amplitude and longer integration time):\n  $A = 0.2$, $\\varepsilon = 0.25$, $\\omega = \\frac{2\\pi}{10}$, $T = 10.0$, time step $\\Delta t = 0.02$, perturbation $\\delta_0 = 10^{-4}$, grid resolution $N_x = 25$, $N_y = 13$, quantile threshold $q = 0.90$.\n- Case $3$ (steady-flow edge case with zero oscillation amplitude):\n  $A = 0.1$, $\\varepsilon = 0.0$, $\\omega = \\frac{2\\pi}{10}$, $T = 5.0$, time step $\\Delta t = 0.02$, perturbation $\\delta_0 = 10^{-4}$, grid resolution $N_x = 31$, $N_y = 16$, quantile threshold $q = 0.90$.\n\nYour program should output a single line containing a comma-separated list of the per-case triplets, enclosed in square brackets, with each triplet itself enclosed in square brackets, and with no spaces. The format must be\n$$\n[[\\overline{\\sigma}_T^{(1)},\\sigma_T^{\\max,(1)},N_{\\text{ridge}}^{(1)}],[\\overline{\\sigma}_T^{(2)},\\sigma_T^{\\max,(2)},N_{\\text{ridge}}^{(2)}],[\\overline{\\sigma}_T^{(3)},\\sigma_T^{\\max,(3)},N_{\\text{ridge}}^{(3)}]],\n$$\nwhere superscripts $(1)$, $(2)$, and $(3)$ denote the case index, and each floating-point value is rounded to six decimal places while each count is an integer. For example, the output should look like\n$$\n[[0.123456,0.234567,42],[0.345678,0.456789,37],[0.567890,0.678901,15]].\n$$",
            "solution": "The problem is valid as it is scientifically grounded in the well-established field of geophysical fluid dynamics, specifically using the standard double-gyre model to study Lagrangian transport. The problem is well-posed, providing all necessary parameters, definitions, and a clear, objective set of tasks that lead to a unique, verifiable computational result. It is a substantive problem in computational science, requiring the implementation of numerical methods for ordinary differential equations and matrix analysis.\n\nThe task is to compute the forward-time finite-time Lyapunov exponent (FTLE) field for a two-dimensional, time-dependent double-gyre flow, identify repelling Lagrangian Coherent Structures (LCS) as ridges in this field, and report several summary statistics for specified parameter sets.\n\nThe velocity field $\\mathbf{v}(x,y,t) = (u(x,y,t), v(x,y,t))$ is defined on the domain $x \\in [0,2]$ and $y \\in [0,1]$. The components are determined by a scalar function $f(x,t)$ and its derivative. The time-dependent coefficients are\n$$\na(t) = \\varepsilon \\sin(\\omega t), \\qquad b(t) = 1 - 2 \\varepsilon \\sin(\\omega t),\n$$\nwhere $\\varepsilon$ is the gyre oscillation amplitude and $\\omega$ is the oscillation frequency. These are used to define the function $f(x,t)$ and its spatial derivative $\\frac{\\partial f}{\\partial x}(x,t)$:\n$$\nf(x,t) = a(t) x^2 + b(t) x,\n$$\n$$\n\\frac{\\partial f}{\\partial x}(x,t) = 2 a(t) x + b(t).\n$$\nThe velocity components are then given by:\n$$\nu(x,y,t) = -\\pi A \\sin(\\pi f(x,t)) \\cos(\\pi y),\n$$\n$$\nv(x,y,t) = \\pi A \\cos(\\pi f(x,t)) \\sin(\\pi y) \\frac{\\partial f}{\\partial x}(x,t),\n$$\nwhere $A$ is the non-dimensional velocity amplitude.\n\nA fluid particle's trajectory, denoted by $\\mathbf{x}(t) = (x(t), y(t))$, is governed by the system of ordinary differential equations (ODEs):\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}(\\mathbf{x}(t), t), \\quad \\text{with initial condition} \\quad \\mathbf{x}(0) = \\mathbf{x}_0 = (x_0, y_0).\n$$\nThe solution to this ODE system defines the flow map $\\Phi_{0}^{T}$, which advects an initial position $\\mathbf{x}_0$ to its final position $\\mathbf{x}(T)$ over the time interval $[0, T]$. We numerically approximate the solution using the fourth-order Runge-Kutta (RK4) method. For a time step $\\Delta t$, a single RK4 step to advance the solution from time $t_n$ to $t_n + \\Delta t$ is:\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4),\n$$\nwhere\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= \\mathbf{v}(\\mathbf{x}_n, t_n), \\\\\n\\mathbf{k}_2 &= \\mathbf{v}(\\mathbf{x}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1, t_n + \\frac{\\Delta t}{2}), \\\\\n\\mathbf{k}_3 &= \\mathbf{v}(\\mathbf{x}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2, t_n + \\frac{\\Delta t}{2}), \\\\\n\\mathbf{k}_4 &= \\mathbf{v}(\\mathbf{x}_n + \\Delta t\\mathbf{k}_3, t_n + \\Delta t).\n\\end{aligned}\n$$\nThe FTLE field, $\\sigma_T(\\mathbf{x}_0)$, quantifies the maximum rate of separation of initially nearby particles over the time interval $T$. It is derived from the Jacobian of the flow map, $\\mathbf{J}(\\mathbf{x}_0) = \\nabla \\Phi_{0}^{T}(\\mathbf{x}_0)$. The columns of the Jacobian are approximated using a forward finite-difference scheme. This requires computing the flow map for three closely spaced initial positions: the central point $\\mathbf{x}_0 = (x_0, y_0)$, an $x$-perturbed point $(x_0+\\delta_0, y_0)$, and a $y$-perturbed point $(x_0, y_0+\\delta_0)$, where $\\delta_0$ is a small perturbation. The columns of $\\mathbf{J}$ are then:\n$$\n\\frac{\\partial \\Phi_{0}^{T}}{\\partial x_0} \\approx \\frac{\\Phi_{0}^{T}(x_0+\\delta_0, y_0) - \\Phi_{0}^{T}(x_0, y_0)}{\\delta_0}, \\qquad\n\\frac{\\partial \\Phi_{0}^{T}}{\\partial y_0} \\approx \\frac{\\Phi_{0}^{T}(x_0, y_0+\\delta_0) - \\Phi_{0}^{T}(x_0, y_0)}{\\delta_0}.\n$$\nFrom the Jacobian $\\mathbf{J}$, we compute the right Cauchy-Green strain tensor, $\\mathbf{C}(\\mathbf{x}_0) = \\mathbf{J}(\\mathbf{x}_0)^\\top \\mathbf{J}(\\mathbf{x}_0)$. This tensor is symmetric and positive semidefinite, and its eigenvalues represent the squared principal stretches. Let $\\lambda_{\\max}(\\mathbf{x}_0)$ be the largest eigenvalue of $\\mathbf{C}(\\mathbf{x}_0)$. The FTLE is defined as:\n$$\n\\sigma_T(\\mathbf{x}_0) = \\frac{1}{|T|} \\ln\\left(\\sqrt{\\lambda_{\\max}(\\mathbf{x}_0)}\\right) = \\frac{1}{2|T|} \\ln\\left(\\lambda_{\\max}(\\mathbf{x}_0)\\right).\n$$\nThis computation is performed for each point on a uniform grid of initial conditions $(x_0, y_0)$ covering the domain $[0,2] \\times [0,1]$ to generate the FTLE field.\n\nRepelling LCS ridges are identified within the computed FTLE field using a two-part criterion. A grid point $(i, j)$ is classified as a ridge point if:\n1.  Its FTLE value, $\\sigma_T(i, j)$, is greater than or equal to a threshold $\\tau$, where $\\tau$ is the $q$-quantile of all values in the FTLE field.\n2.  $\\sigma_T(i, j)$ is a strict local maximum with respect to its four axis-aligned neighbors (up, down, left, right).\n\nFinally, for each parameter case, we compute three summary metrics from the FTLE field:\n1.  The spatial average $\\overline{\\sigma}_T$: The mean of all values in the FTLE grid.\n2.  The maximum value $\\sigma_T^{\\max}$: The maximum value in the FTLE grid.\n3.  The ridge count $N_{\\text{ridge}}$: The total number of grid points that satisfy the ridge criterion.\n\nThe overall algorithm proceeds by iterating through each test case. For a given case, a grid of initial conditions is established. For each grid point, three trajectories are integrated using the RK4 method to compute the final positions needed for the finite-difference approximation of the Jacobian. The FTLE value is then calculated. After the entire FTLE field is computed, it is post-processed to count the ridge points and determine the summary statistics.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It computes FTLE fields, identifies ridges, calculates summary statistics,\n    and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": 0.1, \"eps\": 0.25, \"omega\": 2 * np.pi / 10, \"T\": 5.0,\n            \"dt\": 0.02, \"delta0\": 1e-4, \"Nx\": 31, \"Ny\": 16, \"q\": 0.90\n        },\n        {\n            \"A\": 0.2, \"eps\": 0.25, \"omega\": 2 * np.pi / 10, \"T\": 10.0,\n            \"dt\": 0.02, \"delta0\": 1e-4, \"Nx\": 25, \"Ny\": 13, \"q\": 0.90\n        },\n        {\n            \"A\": 0.1, \"eps\": 0.0, \"omega\": 2 * np.pi / 10, \"T\": 5.0,\n            \"dt\": 0.02, \"delta0\": 1e-4, \"Nx\": 31, \"Ny\": 16, \"q\": 0.90\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        ftle_field = compute_ftle_field(**params)\n        \n        avg_sigma = np.mean(ftle_field)\n        max_sigma = np.max(ftle_field)\n        \n        tau = np.quantile(ftle_field, params['q'])\n        \n        ridge_count = 0\n        Ny, Nx = ftle_field.shape\n        # Iterate over interior points to check for local maxima\n        for j in range(1, Ny - 1):\n            for i in range(1, Nx - 1):\n                val = ftle_field[j, i]\n                if val >= tau:\n                    up = ftle_field[j + 1, i]\n                    down = ftle_field[j - 1, i]\n                    left = ftle_field[j, i - 1]\n                    right = ftle_field[j, i + 1]\n                    if val > up and val > down and val > left and val > right:\n                        ridge_count += 1\n                        \n        all_results.append(\n            f\"[{round(avg_sigma, 6):.6f},{round(max_sigma, 6):.6f},{ridge_count}]\"\n        )\n\n    print(f\"[{','.join(all_results)}]\")\n\ndef velocity(t, pos, A, eps, omega):\n    \"\"\"\n    Computes the velocity vector (u, v) for the double-gyre flow.\n    \n    Args:\n        t (float): Current time.\n        pos (np.ndarray): 2D position [x, y].\n        A (float): Advection amplitude.\n        eps (float): Gyre oscillation amplitude.\n        omega (float): Gyre oscillation frequency.\n\n    Returns:\n        np.ndarray: Velocity vector [u, v].\n    \"\"\"\n    x, y = pos[0], pos[1]\n    \n    a_t = eps * np.sin(omega * t)\n    b_t = 1 - 2 * a_t\n    \n    f_xt = a_t * x**2 + b_t * x\n    dfdx = 2 * a_t * x + b_t\n    \n    sin_pi_f = np.sin(np.pi * f_xt)\n    cos_pi_f = np.cos(np.pi * f_xt)\n    sin_pi_y = np.sin(np.pi * y)\n    cos_pi_y = np.cos(np.pi * y)\n    \n    u = -np.pi * A * sin_pi_f * cos_pi_y\n    v = np.pi * A * cos_pi_f * sin_pi_y * dfdx\n    \n    return np.array([u, v])\n\ndef rk4_step(func, t, y, dt, **kwargs):\n    \"\"\"\n    Performs a single step of the fourth-order Runge-Kutta method.\n    \"\"\"\n    k1 = func(t, y, **kwargs)\n    k2 = func(t + 0.5 * dt, y + 0.5 * dt * k1, **kwargs)\n    k3 = func(t + 0.5 * dt, y + 0.5 * dt * k2, **kwargs)\n    k4 = func(t + dt, y + dt * k3, **kwargs)\n    return y + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\ndef compute_flow_map(x0, y0, T, dt, **kwargs):\n    \"\"\"\n    Computes the flow map Phi_0^T by integrating a trajectory.\n    \"\"\"\n    pos = np.array([x0, y0])\n    num_steps = int(round(T / dt))\n    \n    for i in range(num_steps):\n        t = i * dt\n        pos = rk4_step(velocity, t, pos, dt, **kwargs)\n        \n    return pos\n\ndef compute_ftle_field(A, eps, omega, T, dt, delta0, Nx, Ny, q):\n    \"\"\"\n    Computes the FTLE field for a given set of parameters.\n    \"\"\"\n    x_grid = np.linspace(0.0, 2.0, Nx)\n    y_grid = np.linspace(0.0, 1.0, Ny)\n    \n    ftle_field = np.zeros((Ny, Nx))\n    \n    flow_map_args = {\"T\": T, \"dt\": dt, \"A\": A, \"eps\": eps, \"omega\": omega}\n\n    for j in range(Ny):\n        for i in range(Nx):\n            x0, y0 = x_grid[i], y_grid[j]\n            \n            # Advect central and perturbed points\n            pos_T = compute_flow_map(x0, y0, **flow_map_args)\n            pos_T_dx = compute_flow_map(x0 + delta0, y0, **flow_map_args)\n            pos_T_dy = compute_flow_map(x0, y0 + delta0, **flow_map_args)\n            \n            # Approximate Jacobian using finite differences\n            J = np.zeros((2, 2))\n            J[:, 0] = (pos_T_dx - pos_T) / delta0\n            J[:, 1] = (pos_T_dy - pos_T) / delta0\n            \n            # Compute Cauchy-Green tensor C = J^T * J\n            C = J.T @ J\n            \n            # Eigenvalues of the symmetric matrix C\n            lambda_max = np.max(np.linalg.eigvalsh(C))\n            \n            # FTLE calculation, handling lambda_max <= 0\n            if lambda_max > 0:\n                ftle = (1 / (2 * T)) * np.log(lambda_max)\n            else:\n                ftle = 0.0\n\n            ftle_field[j, i] = ftle\n            \n    return ftle_field\n\nsolve()\n```"
        }
    ]
}