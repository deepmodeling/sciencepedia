{
    "hands_on_practices": [
        {
            "introduction": "The foundation of the FTLE diagnostic lies in accurately quantifying material deformation, which is captured by the right Cauchy–Green strain tensor, $C_{t_0}^{t}$. This tensor is computed from the deformation gradient, the spatial derivative of the flow map. This first practice provides a focused exercise on this crucial step by using an analytically known flow map, allowing you to isolate and analyze the error introduced purely by the numerical finite-difference approximation of the gradient . Mastering this building block is essential for developing reliable FTLE computations.",
            "id": "3796963",
            "problem": "Consider a two-dimensional incompressible flow in the horizontal plane described by the velocity field $\\mathbf{u}(x,y,t) = \\left(0, \\sin(x)\\right)$, where the angle variable $x$ is measured in radians. Let $\\phi_{t_0}^{t}:\\mathbb{R}^2 \\to \\mathbb{R}^2$ denote the flow map that sends an initial particle position $\\mathbf{X}_0 = (x_0,y_0)$ at time $t_0$ to its position $\\mathbf{X}(t) = (x(t),y(t))$ at time $t$. The right Cauchy–Green strain tensor $C_{t_0}^{t}(\\mathbf{X}_0)$ is defined by $C_{t_0}^{t}(\\mathbf{X}_0) = \\left(\\nabla \\phi_{t_0}^{t}(\\mathbf{X}_0)\\right)^{\\top}\\nabla \\phi_{t_0}^{t}(\\mathbf{X}_0)$, where $\\nabla \\phi_{t_0}^{t}$ is the deformation gradient of the flow map with respect to the initial conditions. The computation of $C_{t_0}^{t}$ is central to Finite-Time Lyapunov Exponent (FTLE) diagnostics used for detecting Lagrangian coherent structures.\n\nStarting from the ordinary differential equation $\\frac{d\\mathbf{X}}{dt} = \\mathbf{u}(\\mathbf{X},t)$, with the above $\\mathbf{u}$ and a fixed time interval $\\Delta t = t - t_0$, derive the analytical flow map $\\phi_{t_0}^{t}$ and its deformation gradient. Then, design a numerical algorithm to approximate $\\nabla \\phi_{t_0}^{t}$ on a rectangular, uniformly gridded domain by second-order central finite differences in the initial condition space, and from it compute $C_{t_0}^{t}$. Analyze the truncation error of the numerical $C_{t_0}^{t}$ approximation as a function of particle spacing (grid spacing) by comparing to the analytical $C_{t_0}^{t}$.\n\nUse the following scientifically sound and self-consistent setup:\n\n- Let the domain of initial conditions be $\\Omega = [0,2\\pi]\\times[0,1]$, with $x_0 \\in [0,2\\pi]$ in radians and $y_0 \\in [0,1]$ in meters.\n- Use a uniform grid with $N_x$ points in $x_0$ and $N_y$ points in $y_0$, so that the particle spacings are $h_x = \\frac{2\\pi}{N_x - 1}$ and $h_y = \\frac{1}{N_y - 1}$.\n- Use the fixed time interval $\\Delta t = 1$ seconds.\n- Compute the numerical deformation gradient $\\nabla \\phi_{t_0}^{t}$ at interior grid points using second-order central differences in $x_0$ and $y_0$:\n  $\\frac{\\partial \\phi_i}{\\partial x_0}(x_0,y_0) \\approx \\frac{\\phi_i(x_0+h_x,y_0) - \\phi_i(x_0-h_x,y_0)}{2h_x}$ and\n  $\\frac{\\partial \\phi_i}{\\partial y_0}(x_0,y_0) \\approx \\frac{\\phi_i(x_0,y_0+h_y) - \\phi_i(x_0,y_0-h_y)}{2h_y}$, for $i\\in\\{1,2\\}$, where $\\phi_1$ and $\\phi_2$ are the components of the flow map.\n- At each interior grid point, form the numerical $C_{t_0}^{t}$ and compare it to the analytical $C_{t_0}^{t}$ using the Frobenius norm of their difference. Report the maximum Frobenius-norm error over all interior points, which is dimensionless.\n\nFocus on the truncation error introduced solely by the finite difference approximation of $\\nabla \\phi_{t_0}^{t}$; use the exact analytical flow map to evaluate $\\phi_{t_0}^{t}$ on grid points so that trajectory integration error does not contaminate the analysis.\n\nTest Suite:\nEvaluate the maximum Frobenius-norm error for the following cases, covering a range of particle spacings and including boundary-limited configurations:\n1. $N_x = 3$, $N_y = 65$.\n2. $N_x = 5$, $N_y = 65$.\n3. $N_x = 9$, $N_y = 65$.\n4. $N_x = 17$, $N_y = 65$.\n\nAnswer Specification:\n- For each test case, compute a single float representing the maximum Frobenius-norm error over interior grid points; the value is dimensionless.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[ \\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4 \\right]$), in the order of the test suite above.",
            "solution": "The fundamental base is the kinematics of particle advection given by $\\frac{d\\mathbf{X}}{dt} = \\mathbf{u}(\\mathbf{X},t)$ and the definition of the flow map $\\phi_{t_0}^{t}$ as the map that carries initial conditions $\\mathbf{X}_0$ at time $t_0$ to positions $\\mathbf{X}(t)$ at time $t$. The deformation gradient is $\\nabla \\phi_{t_0}^{t}(\\mathbf{X}_0) = \\frac{\\partial \\phi_{t_0}^{t}}{\\partial \\mathbf{X}_0}$, and the right Cauchy–Green strain tensor is $C_{t_0}^{t}(\\mathbf{X}_0) = \\left(\\nabla \\phi_{t_0}^{t}(\\mathbf{X}_0)\\right)^{\\top}\\nabla \\phi_{t_0}^{t}(\\mathbf{X}_0)$.\n\nStep 1: Analytical flow map for the given velocity field.\nWe are given $\\mathbf{u}(x,y,t) = \\left(0, \\sin(x)\\right)$. Because the velocity field is steady and depends only on $x$, we can write the component-wise ordinary differential equations as\n$\\frac{dx}{dt} = 0$ and $\\frac{dy}{dt} = \\sin(x)$.\nFrom $\\frac{dx}{dt} = 0$ it follows that $x(t) = x_0$ for all $t$. With $x(t) = x_0$, the $y$-equation becomes $\\frac{dy}{dt} = \\sin(x_0)$, which integrates to $y(t) = y_0 + \\Delta t \\sin(x_0)$ for the interval $\\Delta t = t - t_0$. Therefore, the flow map is\n$\\phi_{t_0}^{t}(x_0,y_0) = \\left(x_0,\\; y_0 + \\Delta t \\sin(x_0)\\right)$.\nWith $\\Delta t = 1$ seconds, this simplifies to $\\phi_{t_0}^{t}(x_0,y_0) = \\left(x_0,\\; y_0 + \\sin(x_0)\\right)$, but we retain $\\Delta t$ symbolically for generality in derivations.\n\nStep 2: Deformation gradient and analytical right Cauchy–Green tensor.\nThe deformation gradient is the Jacobian of the flow map with respect to initial conditions:\n$\\nabla \\phi_{t_0}^{t}(x_0,y_0) = \\begin{pmatrix}\n\\frac{\\partial \\phi_1}{\\partial x_0} & \\frac{\\partial \\phi_1}{\\partial y_0} \\\\\n\\frac{\\partial \\phi_2}{\\partial x_0} & \\frac{\\partial \\phi_2}{\\partial y_0}\n\\end{pmatrix} = \\begin{pmatrix}\n1 & 0 \\\\\n\\Delta t \\cos(x_0) & 1\n\\end{pmatrix}$,\nwhere $\\phi_1(x_0,y_0) = x_0$ and $\\phi_2(x_0,y_0) = y_0 + \\Delta t \\sin(x_0)$. The analytical right Cauchy–Green tensor is then\n$C_{t_0}^{t}(x_0,y_0) = \\left(\\nabla \\phi_{t_0}^{t}\\right)^{\\top}\\nabla \\phi_{t_0}^{t} = \\begin{pmatrix}\n1 + \\left(\\Delta t \\cos(x_0)\\right)^2 & \\Delta t \\cos(x_0) \\\\\n\\Delta t \\cos(x_0) & 1\n\\end{pmatrix}$.\n\nStep 3: Numerical approximation of the deformation gradient on a grid.\nWe consider a rectangular grid over $\\Omega = [0,2\\pi]\\times[0,1]$ with $N_x$ points in $x_0$ and $N_y$ points in $y_0$. The spacings are $h_x = \\frac{2\\pi}{N_x - 1}$ and $h_y = \\frac{1}{N_y - 1}$. We evaluate the flow map at all grid points using the analytical expression. Then, at interior grid points, we approximate the partial derivatives by second-order central finite differences:\n$\\frac{\\partial \\phi_i}{\\partial x_0}(x_0,y_0) \\approx \\frac{\\phi_i(x_0+h_x,y_0) - \\phi_i(x_0-h_x,y_0)}{2h_x}$ and\n$\\frac{\\partial \\phi_i}{\\partial y_0}(x_0,y_0) \\approx \\frac{\\phi_i(x_0,y_0+h_y) - \\phi_i(x_0,y_0-h_y)}{2h_y}$,\nfor $i\\in\\{1,2\\}$. These approximations are second-order accurate under smoothness assumptions on $\\phi_i$, which hold here because $\\phi_i$ are smooth functions of $x_0$ and $y_0$.\n\nStep 4: Error analysis via Taylor expansion.\nFor a smooth scalar function $f(x)$, the central difference approximation $f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}$ has truncation error $E(x;h) = \\frac{h^2}{6}f^{(3)}(\\xi)$ for some $\\xi$ in $(x-h,x+h)$ by Taylor's theorem. Applying this to $\\phi_2$ in the $x_0$-direction, we have $f(x_0) = \\phi_2(x_0,y_0) = y_0 + \\Delta t \\sin(x_0)$, so $f'(x_0) = \\Delta t \\cos(x_0)$ and $f^{(3)}(x_0) = -\\Delta t \\sin(x_0)$. The truncation error in $\\frac{\\partial \\phi_2}{\\partial x_0}$ is therefore\n$E_{x} = \\frac{h_x^2}{6}\\left(-\\Delta t \\sin(\\xi)\\right)$,\nwhich is $\\mathcal{O}(h_x^2)$ uniformly because $\\sin(\\xi)$ is bounded. For $\\phi_1$ in $x_0$, $f(x_0) = x_0$ is linear, so the central difference yields the exact derivative; similarly, the derivatives with respect to $y_0$ are constant ($\\frac{\\partial \\phi_1}{\\partial y_0} = 0$, $\\frac{\\partial \\phi_2}{\\partial y_0} = 1$), and the central differences recover them exactly. Thus the only non-zero truncation error arises in the $\\frac{\\partial \\phi_2}{\\partial x_0}$ entry, and it scales like $\\mathcal{O}(h_x^2)$.\n\nStep 5: Propagation of derivative error into $C_{t_0}^{t}$.\nLet $\\nabla \\phi = \\begin{pmatrix} 1 & 0 \\\\ \\Delta t \\cos(x_0) & 1 \\end{pmatrix}$ be the true deformation gradient, and let the numerical approximation be $\\nabla \\phi^{h} = \\begin{pmatrix} 1 & 0 \\\\ \\Delta t \\cos(x_0) + \\delta & 1 \\end{pmatrix}$, where $\\delta = \\mathcal{O}(h_x^2)$ represents the central difference truncation error in $\\frac{\\partial \\phi_2}{\\partial x_0}$. Then\n$C^{h} = \\left(\\nabla \\phi^{h}\\right)^{\\top}\\nabla \\phi^{h} = \\begin{pmatrix}\n1 + \\left(\\Delta t \\cos(x_0) + \\delta\\right)^2 & \\Delta t \\cos(x_0) + \\delta \\\\\n\\Delta t \\cos(x_0) + \\delta & 1\n\\end{pmatrix}$,\nwhile\n$C = \\begin{pmatrix}\n1 + \\left(\\Delta t \\cos(x_0)\\right)^2 & \\Delta t \\cos(x_0) \\\\\n\\Delta t \\cos(x_0) & 1\n\\end{pmatrix}$.\nThe difference is\n$C^{h} - C = \\begin{pmatrix}\n2\\Delta t \\cos(x_0)\\,\\delta + \\delta^2 & \\delta \\\\\n\\delta & 0\n\\end{pmatrix}$.\nThe Frobenius norm of this difference at a point is\n$\\|C^{h} - C\\|_{F} = \\sqrt{\\left(2\\Delta t \\cos(x_0)\\,\\delta + \\delta^2\\right)^2 + 2\\delta^2 + 0^2}$.\nFor small $\\delta$ (which is $\\mathcal{O}(h_x^2)$), the leading term is linear in $\\delta$, so $\\|C^{h} - C\\|_{F} = \\mathcal{O}(h_x^2)$. Therefore, the maximum Frobenius-norm error over the domain should scale like $h_x^2$ as particle spacing is refined.\n\nStep 6: Algorithmic implementation details.\nWe implement the grid, evaluate the analytical flow map $\\phi_{t_0}^{t}$ at grid points, compute central differences at interior grid points to form $\\nabla \\phi^{h}$, construct $C^{h}$, compute the analytical $C$, and evaluate the Frobenius-norm error at each interior point. For each test case specified by $(N_x,N_y)$, we report the maximum Frobenius-norm error over interior points. Because the analytical flow map is used to compute $\\phi$, there is no trajectory integration error; the sole error source is the finite difference truncation. As $N_x$ increases (and $h_x$ decreases), the errors should decrease approximately by a factor of $4$ for each halving of $h_x$, consistent with second-order accuracy.\n\nThe final program prints a single line containing the list of maximum errors for the four test cases, in the specified order.",
            "answer": "```python\nimport numpy as np\n\ndef compute_flow_map(X, Y, dt):\n    \"\"\"\n    Analytical flow map for u = (0, sin(x)):\n    phi(x0, y0) = (x0, y0 + dt * sin(x0))\n    \"\"\"\n    phi1 = X.copy()\n    phi2 = Y + dt * np.sin(X)\n    return phi1, phi2\n\ndef compute_numerical_C(phi1, phi2, hx, hy):\n    \"\"\"\n    Compute numerical deformation gradient via central differences at interior points,\n    then construct the right Cauchy-Green tensor C = (Dphi)^T Dphi.\n    Returns C components on interior: C11, C12, C22.\n    \"\"\"\n    # Central differences for interior points\n    # Slices for interior region\n    sl_i = slice(1, -1)\n    sl_j = slice(1, -1)\n\n    dphi1_dx = (phi1[2:, sl_j] - phi1[:-2, sl_j]) / (2.0 * hx)\n    dphi1_dy = (phi1[sl_i, 2:] - phi1[sl_i, :-2]) / (2.0 * hy)\n\n    dphi2_dx = (phi2[2:, sl_j] - phi2[:-2, sl_j]) / (2.0 * hx)\n    dphi2_dy = (phi2[sl_i, 2:] - phi2[sl_i, :-2]) / (2.0 * hy)\n\n    # Construct C = (Dphi)^T Dphi\n    # Dphi = [[a, b],[c, d]] with a=dphi1_dx, b=dphi1_dy, c=dphi2_dx, d=dphi2_dy\n    C11 = dphi1_dx**2 + dphi2_dx**2\n    C12 = dphi1_dx * dphi1_dy + dphi2_dx * dphi2_dy\n    C22 = dphi1_dy**2 + dphi2_dy**2\n    return C11, C12, C22\n\ndef compute_analytical_C(Xi, dt):\n    \"\"\"\n    Analytical C components for the given flow:\n    Dphi = [[1, 0],[dt*cos(x0), 1]]\n    C = [[1 + (dt*cos(x0))**2, dt*cos(x0)],\n         [dt*cos(x0), 1]]\n    \"\"\"\n    cosx = np.cos(Xi)\n    C11 = 1.0 + (dt * cosx)**2\n    C12 = dt * cosx\n    C22 = 1.0\n    return C11, C12, C22\n\ndef max_error_for_case(Nx, Ny, dt):\n    # Grid spacings\n    hx = 2.0 * np.pi / (Nx - 1)\n    hy = 1.0 / (Ny - 1)\n\n    # Create grid of initial conditions\n    x = np.linspace(0.0, 2.0 * np.pi, Nx)\n    y = np.linspace(0.0, 1.0, Ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Analytical flow map\n    phi1, phi2 = compute_flow_map(X, Y, dt)\n\n    # Numerical C at interior points\n    C11_num, C12_num, C22_num = compute_numerical_C(phi1, phi2, hx, hy)\n\n    # Extract interior X for analytical comparison\n    Xi = X[1:-1, 1:-1]\n\n    # Analytical C at interior points\n    C11_true, C12_true, C22_true = compute_analytical_C(Xi, dt)\n\n    # Frobenius norm of difference for symmetric 2x2 matrix:\n    # ||DeltaC||_F = sqrt((d11)^2 + 2*(d12)^2 + (d22)^2)\n    d11 = C11_num - C11_true\n    d12 = C12_num - C12_true\n    d22 = C22_num - C22_true\n    err = np.sqrt(d11**2 + 2.0 * d12**2 + d22**2)\n\n    # Maximum over interior points\n    max_err = float(np.max(err))\n    return max_err\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (Nx, Ny)\n    test_cases = [\n        (3, 65),\n        (5, 65),\n        (9, 65),\n        (17, 65),\n    ]\n    dt = 1.0  # seconds\n\n    results = []\n    for Nx, Ny in test_cases:\n        result = max_error_for_case(Nx, Ny, dt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Having established how to compute the deformation gradient, we now assemble the complete pipeline to reveal Lagrangian Coherent Structures in a dynamically interesting flow. This practice uses the celebrated double-gyre model, a canonical example of time-periodic chaotic stirring, to compute both forward- and backward-time FTLE fields . By doing so, you will visualize the repelling and attracting structures that form the transport skeleton of the flow and gain hands-on experience with the full workflow from velocity field to LCS detection.",
            "id": "3796942",
            "problem": "You are given the periodically forced double-gyre velocity field on the rectangular domain $\\left[x_{\\min},x_{\\max}\\right] \\times \\left[y_{\\min},y_{\\max}\\right] = \\left[0,2\\right] \\times \\left[0,1\\right]$, a canonical model in computational oceanography for studying stirring and mixing under time-periodic forcing. The task is to compute forward-time and backward-time Finite-Time Lyapunov Exponent (FTLE) fields for specified parameter sets and to quantify the effect of time-periodicity on the Lagrangian Coherent Structures (LCS).\n\nStart from the following fundamental base:\n- The Lagrangian trajectories satisfy $\\dfrac{d\\mathbf{x}}{dt} = \\mathbf{v}(\\mathbf{x},t)$, where $\\mathbf{x}(t) = \\left[x(t), y(t)\\right]^T$ is the particle position and $\\mathbf{v}(\\mathbf{x},t)$ is the velocity field.\n- The Lagrangian flow map $\\boldsymbol{\\phi}_{t_0}^{t_0+T}$ maps each initial condition $\\mathbf{x}_0$ at time $t_0$ to its position at time $t_0+T$ under the velocity field.\n- The right Cauchy–Green strain tensor is $\\mathbf{C} = \\left(\\nabla \\boldsymbol{\\phi}_{t_0}^{t_0+T}\\right)^T \\nabla \\boldsymbol{\\phi}_{t_0}^{t_0+T}$, where $\\nabla \\boldsymbol{\\phi}_{t_0}^{t_0+T}$ is the gradient of the flow map with respect to initial conditions.\n- The Finite-Time Lyapunov Exponent (FTLE) over time horizon $T$ at initial time $t_0$ is defined by the time-normalized logarithm of the principal stretch associated with $\\mathbf{C}$.\n\nConsider the double-gyre velocity field:\n- Let $a(t) = \\varepsilon \\sin\\left(\\omega t\\right)$, $b(t) = 1 - 2 \\varepsilon \\sin\\left(\\omega t\\right)$, and $f\\left(x,t\\right) = a(t) x^2 + b(t) x$.\n- The velocity components are $u(x,y,t) = - \\pi A \\sin\\left(\\pi f(x,t)\\right) \\cos\\left(\\pi y\\right)$ and $v(x,y,t) = \\pi A \\cos\\left(\\pi f(x,t)\\right) \\sin\\left(\\pi y\\right) \\dfrac{\\partial f}{\\partial x}$, with $\\dfrac{\\partial f}{\\partial x} = 2 a(t) x + b(t)$.\n\nYour program must:\n- Discretize the domain with a uniform tensor grid of $N_x \\times N_y$ points, with grid spacings $h_x = \\dfrac{x_{\\max}-x_{\\min}}{N_x-1}$ and $h_y = \\dfrac{y_{\\max}-y_{\\min}}{N_y-1}$.\n- Numerically integrate trajectories for all grid points using a fixed time step $\\,\\Delta t\\,$ and a fourth-order Runge–Kutta scheme for the specified time horizon $T$ starting at time $t_0$. For forward-time FTLE, integrate forward in time. For backward-time FTLE, integrate backward in time.\n- Approximate $\\nabla \\boldsymbol{\\phi}_{t_0}^{t_0+T}$ at each grid node by finite differences of the flow map using central differences in the interior and one-sided differences at the boundaries, applied component-wise to the final positions of the advected grid.\n- Form $\\mathbf{C}$ from $\\nabla \\boldsymbol{\\phi}_{t_0}^{t_0+T}$ and compute the FTLE field over the grid from $\\mathbf{C}$.\n- Compute, for requested test cases, the spatial mean FTLE and the spatial maximum FTLE of the field. Additionally, quantify time-periodicity by comparing forward-time FTLE fields started at $t_0$ and at $t_0 + \\dfrac{2\\pi}{\\omega}$ over the same time horizon $T$ by reporting the relative $\\ell_2$ difference defined as $\\dfrac{\\left\\|\\sigma_{t_0} - \\sigma_{t_0 + 2\\pi/\\omega}\\right\\|_2}{\\left\\|\\sigma_{t_0}\\right\\|_2}$, where $\\sigma_{t}$ denotes the FTLE field started at time $t$ and $\\|\\cdot\\|_2$ is the Euclidean norm over the grid.\n\nAll quantities are nondimensional. Time is measured in nondimensional units; report FTLE values in inverse time units. Express all numerical outputs as decimal floats rounded to $6$ digits after the decimal point, without attaching any unit symbols.\n\nTest suite to implement and evaluate:\n- Case $1$ (happy path): forward-time FTLE with parameters $A = 0.1$, $\\varepsilon = 0.25$, $\\omega = \\dfrac{2\\pi}{10}$, $t_0 = 0$, $T = 5$, $\\Delta t = 0.02$, $N_x = 31$, $N_y = 21$. Output two floats: the spatial mean FTLE and the spatial maximum FTLE.\n- Case $2$ (complementary backward-time): backward-time FTLE with the same parameters as Case $1$ except integrating backward over $T = 5$. Output two floats: the spatial mean FTLE and the spatial maximum FTLE.\n- Case $3$ (short-horizon edge case): forward-time FTLE with the same parameters as Case $1$ except $T = 1$. Output two floats: the spatial mean FTLE and the spatial maximum FTLE.\n- Case $4$ (time-periodicity check): compute the relative $\\ell_2$ difference between forward-time FTLE fields started at $t_0 = 0$ and at $t_0 + \\dfrac{2\\pi}{\\omega}$, using the same $A$, $\\varepsilon$, $\\omega$, $T = 5$, $\\Delta t = 0.02$, $N_x = 31$, $N_y = 21$. Output one float: the relative difference.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for Cases $1$–$4$ as a comma-separated list enclosed in square brackets in the exact order: $\\left[\\text{mean}_{1},\\text{max}_{1},\\text{mean}_{2},\\text{max}_{2},\\text{mean}_{3},\\text{max}_{3},\\text{relL2}_{4}\\right]$, with each float rounded to $6$ digits after the decimal point.",
            "solution": "The problem requires the computation of Finite-Time Lyapunov Exponent (FTLE) fields for a periodically forced double-gyre velocity field. This involves understanding the underlying principles of Lagrangian dynamics, defining the computational approach, and implementing it for a set of specified test cases.\n\n### Problem Validation\n\nThe provided problem is a standard exercise in computational fluid dynamics and the study of chaotic advection.\n\n**1. Givens Extraction:**\n- **Domain:** $\\left[x_{\\min},x_{\\max}\\right] \\times \\left[y_{\\min},y_{\\max}\\right] = \\left[0,2\\right] \\times \\left[0,1\\right]$.\n- **Velocity Field:** $u(x,y,t) = - \\pi A \\sin\\left(\\pi f(x,t)\\right) \\cos\\left(\\pi y\\right)$ and $v(x,y,t) = \\pi A \\cos\\left(\\pi f(x,t)\\right) \\sin\\left(\\pi y\\right) \\frac{\\partial f}{\\partial x}$, where $f\\left(x,t\\right) = a(t) x^2 + b(t) x$, $a(t) = \\varepsilon \\sin\\left(\\omega t\\right)$, $b(t) = 1 - 2 \\varepsilon \\sin\\left(\\omega t\\right)$, and $\\frac{\\partial f}{\\partial x} = 2 a(t) x + b(t)$.\n- **Lagrangian Dynamics:** $\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}(\\mathbf{x},t)$.\n- **Flow Map:** $\\boldsymbol{\\phi}_{t_0}^{t_0+T}$ maps initial positions at $t_0$ to final positions at $t_0+T$.\n- **Cauchy-Green Strain Tensor:** $\\mathbf{C} = \\left(\\nabla \\boldsymbol{\\phi}_{t_0}^{t_0+T}\\right)^T \\nabla \\boldsymbol{\\phi}_{t_0}^{t_0+T}$.\n- **FTLE Definition:** Time-normalized logarithm of the principal stretch from $\\mathbf{C}$.\n- **Numerical Method:** Uniform grid ($N_x \\times N_y$), 4th-order Runge-Kutta integration with time step $\\Delta t$, and finite differences for the flow map gradient.\n- **Test Cases:** Four cases are specified with parameters $A, \\varepsilon, \\omega, t_0, T, \\Delta t, N_x, N_y$, requiring computation of forward-time FTLE, backward-time FTLE, and a time-periodicity check.\n\n**2. Validation Verdict:**\nThe problem is **valid**. It is scientifically grounded, well-posed, objective, and self-contained. The double-gyre model is a canonical system for studying Lagrangian coherent structures. The definitions and required computations are standard in the field. All necessary parameters and numerical methods are specified, allowing for a unique and verifiable solution.\n\n### Principle-Based Solution Design\n\nThe solution is constructed by following the principles of Lagrangian analysis, from the governing equations to the numerical implementation.\n\n**1. Governing Equations and Properties**\nThe trajectory of a fluid particle $\\mathbf{x}(t) = [x(t), y(t)]^T$ is governed by the ordinary differential equation (ODE):\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}(\\mathbf{x},t)\n$$\nA crucial property of the given velocity field $\\mathbf{v} = [u, v]^T$ is that it is divergence-free, meaning it represents an incompressible flow. We can verify this by computing the divergence $\\nabla \\cdot \\mathbf{v} = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}$:\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left[ - \\pi A \\sin\\left(\\pi f(x,t)\\right) \\cos\\left(\\pi y\\right) \\right] = - \\pi^2 A \\cos(\\pi f) \\frac{\\partial f}{\\partial x} \\cos(\\pi y)\n$$\n$$\n\\frac{\\partial v}{\\partial y} = \\frac{\\partial}{\\partial y} \\left[ \\pi A \\cos\\left(\\pi f(x,t)\\right) \\sin\\left(\\pi y\\right) \\frac{\\partial f}{\\partial x} \\right] = \\pi^2 A \\cos(\\pi f) \\cos(\\pi y) \\frac{\\partial f}{\\partial x}\n$$\nAdding these two terms yields:\n$$\n\\nabla \\cdot \\mathbf{v} = 0\n$$\nThis incompressibility implies, by Liouville's theorem, that the flow map is area-preserving, i.e., the determinant of its gradient is unity.\n\n**2. Lagrangian Coherent Structures and FTLE**\nThe Finite-Time Lyapunov Exponent (FTLE) field is a scalar field that quantifies the maximum rate of separation of initially nearby particles over a finite time interval. Ridges of high FTLE values act as proxies for Lagrangian Coherent Structures (LCS), which are material lines that organize the flow.\n\nThe computation proceeds as follows:\n- **Flow Map $\\boldsymbol{\\phi}$**: For a set of initial conditions $\\mathbf{x}_0$ at time $t_0$, the flow map $\\boldsymbol{\\phi}_{t_0}^{t_0+T}(\\mathbf{x}_0)$ gives the final positions $\\mathbf{x}(t_0+T)$ after integrating the ODE over the time horizon $T$.\n- **Deformation Gradient $\\mathbf{F}$**: The gradient of the flow map with respect to the initial positions, $\\mathbf{F}(\\mathbf{x}_0) = \\nabla_{\\mathbf{x}_0} \\boldsymbol{\\phi}_{t_0}^{t_0+T}(\\mathbf{x}_0)$, measures how an infinitesimal neighborhood around $\\mathbf{x}_0$ is deformed by the flow.\n- **Right Cauchy-Green Strain Tensor $\\mathbf{C}$**: This symmetric, positive semi-definite tensor is defined as $\\mathbf{C} = \\mathbf{F}^T \\mathbf{F}$. Its eigenvalues, $\\lambda_i$, are the squares of the principal stretches (singular values of $\\mathbf{F}$).\n- **FTLE $\\sigma$**: The forward-time FTLE is defined as:\n$$\n\\sigma_{t_0}^{T}(\\mathbf{x}_0) = \\frac{1}{|T|} \\ln\\sqrt{\\lambda_{\\max}(\\mathbf{C})} = \\frac{1}{2|T|} \\ln(\\lambda_{\\max}(\\mathbf{C}))\n$$\nwhere $\\lambda_{\\max}(\\mathbf{C})$ is the largest eigenvalue of $\\mathbf{C}$. Because the flow is incompressible, $\\det(\\mathbf{C}) = \\lambda_{\\min}\\lambda_{\\max} = 1$, which ensures $\\lambda_{\\max} \\ge 1$ and thus $\\sigma \\ge 0$.\n\nBackward-time FTLE is computed similarly, but by analyzing the flow backward in time from $t_0$ to $t_0 - T$. This reveals attracting LCS (stable manifolds), which complement the repelling LCS (unstable manifolds) revealed by forward-time FTLE.\n\n**3. Numerical Algorithm**\nThe continuous problem is discretized for numerical solution.\n\n- **Step 1: Grid Generation**. The domain $[0, 2] \\times [0, 1]$ is discretized into a uniform grid of $N_x \\times N_y$ initial positions $\\mathbf{x}_{i,j}$.\n\n- **Step 2: Trajectory Integration**. For each point $\\mathbf{x}_{i,j}$ on the grid, we solve the ODE $\\dot{\\mathbf{x}} = \\mathbf{v}(\\mathbf{x},t)$ from $t_0$ to $t_0+T$ to find the final position $\\mathbf{x}_{i,j}(t_0+T)$. This is done using the fourth-order Runge-Kutta (RK4) scheme with a fixed time step $\\Delta t$:\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nwhere\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= \\mathbf{v}(t_n, \\mathbf{x}_n) \\\\\n\\mathbf{k}_2 &= \\mathbf{v}(t_n + \\frac{\\Delta t}{2}, \\mathbf{x}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1) \\\\\n\\mathbf{k}_3 &= \\mathbf{v}(t_n + \\frac{\\Delta t}{2}, \\mathbf{x}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2) \\\\\n\\mathbf{k}_4 &= \\mathbf{v}(t_n + \\Delta t, \\mathbf{x}_n + \\Delta t\\mathbf{k}_3)\n\\end{aligned}\n$$\nFor backward-time integration, a negative integration horizon $T < 0$ is used (e.g., integrating from $t_0=0$ to $t_f = -5$).\n\n- **Step 3: Flow Map Gradient Estimation**. The collection of final positions forms a discrete representation of the flow map. The components of its gradient, $\\frac{\\partial \\phi_x}{\\partial x}, \\frac{\\partial \\phi_x}{\\partial y}, \\frac{\\partial \\phi_y}{\\partial x}, \\frac{\\partial \\phi_y}{\\partial y}$, are computed on the grid using centered finite differences in the interior and one-sided differences at the boundaries.\n\n- **Step 4: FTLE Field Computation**. At each grid point:\n    1. Construct the deformation gradient tensor $\\mathbf{F} = \\begin{pmatrix} \\frac{\\partial \\phi_x}{\\partial x} & \\frac{\\partial \\phi_x}{\\partial y} \\\\ \\frac{\\partial \\phi_y}{\\partial x} & \\frac{\\partial \\phi_y}{\\partial y} \\end{pmatrix}$.\n    2. Compute the Cauchy-Green tensor $\\mathbf{C} = \\mathbf{F}^T \\mathbf{F}$.\n    3. Find the maximum eigenvalue $\\lambda_{\\max}$ of the $2 \\times 2$ matrix $\\mathbf{C}$. For $\\mathbf{C} = \\begin{pmatrix} c_{11} & c_{12} \\\\ c_{12} & c_{22} \\end{pmatrix}$, $\\lambda_{\\max} = \\frac{1}{2}\\left(c_{11} + c_{22} + \\sqrt{(c_{11} - c_{22})^2 + 4c_{12}^2}\\right)$.\n    4. Calculate the FTLE value using the formula $\\sigma = \\frac{1}{2|T|} \\ln(\\lambda_{\\max})$.\n\n**4. Analysis of Test Cases**\n- **Cases 1-3:** These involve direct application of the algorithm described above for different integration horizons $T$. The spatial mean and maximum of the resulting FTLE field $\\sigma_{i,j}$ are computed.\n- **Case 4 (Time-Periodicity):** The velocity field $\\mathbf{v}(\\mathbf{x}, t)$ is periodic in time with period $P = 2\\pi/\\omega$. This property implies that the flow map itself is periodic with respect to its start time, i.e., $\\boldsymbol{\\phi}_{t_0+P}^{t_0+P+T} = \\boldsymbol{\\phi}_{t_0}^{t_0+T}$. Consequently, the FTLE fields must also be periodic: $\\sigma_{t_0+P}^T = \\sigma_{t_0}^T$. This case verifies this property numerically by computing the relative $\\ell_2$ difference between the FTLE field started at $t_0 = 0$ and the one started at $t_0' = 0 + P$. The theoretical result is $0$; any non-zero value is due to numerical floating-point errors. The relative difference is computed as $\\frac{\\left\\|\\sigma_{t_0} - \\sigma_{t_0'}\\right\\|_2}{\\left\\|\\sigma_{t_0}\\right\\|_2}$, where $\\|\\cdot\\|_2$ is the standard Euclidean norm of the values on the grid.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to compute results for all test cases.\n    \"\"\"\n\n    def get_velocity(t, pos, A, eps, omega):\n        \"\"\"\n        Calculates the double-gyre velocity field for an array of particles.\n        \n        Args:\n            t (float): Current time.\n            pos (np.ndarray): Particle positions, shape (N, 2).\n            A (float): Gyre amplitude.\n            eps (float): Forcing amplitude.\n            omega (float): Forcing frequency.\n\n        Returns:\n            np.ndarray: Velocity vectors, shape (N, 2).\n        \"\"\"\n        x = pos[:, 0]\n        y = pos[:, 1]\n        \n        sin_omega_t = np.sin(omega * t)\n        a_t = eps * sin_omega_t\n        b_t = 1.0 - 2.0 * eps * sin_omega_t\n        \n        f_xt = a_t * x**2 + b_t * x\n        dfdx_t = 2.0 * a_t * x + b_t\n        \n        sin_pi_f = np.sin(np.pi * f_xt)\n        cos_pi_f = np.cos(np.pi * f_xt)\n        sin_pi_y = np.sin(np.pi * y)\n        cos_pi_y = np.cos(np.pi * y)\n        \n        u = -np.pi * A * sin_pi_f * cos_pi_y\n        v = np.pi * A * cos_pi_f * sin_pi_y * dfdx_t\n        \n        return np.stack((u, v), axis=-1)\n\n    def compute_ftle_field(A, eps, omega, t0, T, dt, Nx, Ny):\n        \"\"\"\n        Computes the FTLE field for the given parameters.\n        \n        Args:\n            A, eps, omega: Velocity field parameters.\n            t0 (float): Initial time.\n            T (float): Integration horizon (can be negative for backward FTLE).\n            dt (float): Time step for RK4 integrator.\n            Nx, Ny (int): Grid dimensions.\n            \n        Returns:\n            np.ndarray: The computed FTLE field, shape (Ny, Nx).\n        \"\"\"\n        # 1. Grid Generation\n        xmin, xmax = 0.0, 2.0\n        ymin, ymax = 0.0, 1.0\n        hx = (xmax - xmin) / (Nx - 1)\n        hy = (ymax - ymin) / (Ny - 1)\n        x_grid = np.linspace(xmin, xmax, Nx)\n        y_grid = np.linspace(ymin, ymax, Ny)\n        x0_mesh, y0_mesh = np.meshgrid(x_grid, y_grid)\n        initial_pos = np.stack((x0_mesh.ravel(), y0_mesh.ravel()), axis=-1)\n\n        # 2. Trajectory Integration (RK4)\n        current_pos = initial_pos.copy()\n        current_time = t0\n        \n        # Use negative dt for backward integration\n        time_step = dt if T > 0 else -dt\n        num_steps = int(round(abs(T / time_step)))\n\n        for _ in range(num_steps):\n            k1 = get_velocity(current_time, current_pos, A, eps, omega)\n            k2 = get_velocity(current_time + 0.5 * time_step, current_pos + 0.5 * time_step * k1, A, eps, omega)\n            k3 = get_velocity(current_time + 0.5 * time_step, current_pos + 0.5 * time_step * k2, A, eps, omega)\n            k4 = get_velocity(current_time + time_step, current_pos + time_step * k3, A, eps, omega)\n            current_pos += (time_step / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n            current_time += time_step\n            \n        final_pos_grid = current_pos.reshape(Ny, Nx, 2)\n\n        # 3. Flow Map Gradient\n        phi_x = final_pos_grid[:, :, 0]\n        phi_y = final_pos_grid[:, :, 1]\n        \n        dphix_dy, dphix_dx = np.gradient(phi_x, hy, hx)\n        dphiy_dy, dphiy_dx = np.gradient(phi_y, hy, hx)\n\n        # 4. FTLE Computation\n        # Deformation Gradient Tensor F (shape: Ny, Nx, 2, 2)\n        F = np.zeros((Ny, Nx, 2, 2))\n        F[:, :, 0, 0] = dphix_dx\n        F[:, :, 0, 1] = dphix_dy\n        F[:, :, 1, 0] = dphiy_dx\n        F[:, :, 1, 1] = dphiy_dy\n\n        # Right Cauchy-Green Strain Tensor C = F^T F\n        C = np.einsum('...ij,...ik->...jk', F, F)\n        \n        # Max eigenvalue of C\n        c11, c12, c22 = C[:, :, 0, 0], C[:, :, 0, 1], C[:, :, 1, 1]\n        trace = c11 + c22\n        # Use numerically stable formula\n        sqrt_term = np.sqrt(np.maximum(0, (c11 - c22)**2 + 4 * c12**2))\n        lambda_max = 0.5 * (trace + sqrt_term)\n\n        # FTLE formula (sigma = 1/(2*|T|) * ln(lambda_max))\n        # The flow is incompressible, so lambda_max >= 1, no need for log(0) check.\n        with np.errstate(divide='ignore', invalid='ignore'):\n            ftle_field = (1.0 / (2.0 * abs(T))) * np.log(lambda_max)\n        \n        # Replace NaNs or Infs that might arise from edge cases, though unlikely\n        ftle_field[~np.isfinite(ftle_field)] = 0.0\n\n        return ftle_field\n\n    # Common parameters for all cases\n    params = {\n        'A': 0.1,\n        'eps': 0.25,\n        'omega': (2 * np.pi) / 10,\n        't0': 0.0,\n        'T': 5.0,\n        'dt': 0.02,\n        'Nx': 31,\n        'Ny': 21\n    }\n    \n    results = []\n\n    # Case 1: Forward-time FTLE, T=5\n    p1 = params.copy()\n    ftle1 = compute_ftle_field(**p1)\n    results.append(f\"{np.mean(ftle1):.6f}\")\n    results.append(f\"{np.max(ftle1):.6f}\")\n\n    # Case 2: Backward-time FTLE, T=5\n    p2 = params.copy()\n    # To integrate backward, we use a negative integration horizon T\n    p2['T'] = -5.0\n    ftle2 = compute_ftle_field(**p2)\n    results.append(f\"{np.mean(ftle2):.6f}\")\n    results.append(f\"{np.max(ftle2):.6f}\")\n\n    # Case 3: Forward-time FTLE, T=1\n    p3 = params.copy()\n    p3['T'] = 1.0\n    ftle3 = compute_ftle_field(**p3)\n    results.append(f\"{np.mean(ftle3):.6f}\")\n    results.append(f\"{np.max(ftle3):.6f}\")\n\n    # Case 4: Time-periodicity check\n    p4 = params.copy()\n    period = (2 * np.pi) / p4['omega']\n    \n    # FTLE field starting at t0=0\n    sigma_t0 = compute_ftle_field(**p4)\n    \n    # FTLE field starting at t0=period\n    p4['t0'] = period\n    sigma_t0_plus_period = compute_ftle_field(**p4)\n    \n    norm_diff = np.linalg.norm(sigma_t0 - sigma_t0_plus_period)\n    norm_orig = np.linalg.norm(sigma_t0)\n    \n    relative_l2_diff = norm_diff / norm_orig if norm_orig > 0 else 0.0\n    results.append(f\"{relative_l2_diff:.6f}\")\n\n    # Final output formatting\n    print(f\"[{','.join(results)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "Oceanographic analysis rarely takes place on a simple Cartesian plane; it occurs on the surface of a sphere, often visualized using map projections. This practice confronts a critical real-world challenge: how do the geometric distortions of a map, such as the common Mercator projection, affect the FTLE calculation? You will derive the analytical correction that reconciles the FTLE computed in distorted map coordinates with the true physical stretching on the sphere, a crucial skill for applying LCS diagnostics to geophysical data .",
            "id": "3797011",
            "problem": "A two-dimensional horizontal ocean surface flow on the sphere is observed over a finite time interval from initial time $t_{0}$ to final time $t_{1}$, with $T = t_{1} - t_{0} \\neq 0$. Let $\\Phi_{t_{0}}^{t_{1}}$ denote the flow map that carries each initial position to its final position along a trajectory. The Finite-Time Lyapunov Exponent (FTLE) is defined for a point $x_{0}$ as $\\sigma(x_{0}, t_{0}, T) = \\frac{1}{2 |T|} \\ln \\lambda_{\\max}\\!\\left(C(x_{0}, t_{0}, T)\\right)$, where $C = F^{\\top} F$ is the right Cauchy–Green strain tensor and $F = \\nabla \\Phi_{t_{0}}^{t_{1}}(x_{0})$ is the deformation gradient of the flow map with respect to the chosen spatial coordinates. Assume all derivatives and tensors are evaluated in a coordinate system endowed with the Euclidean metric at each point.\n\nIn practice, many computational oceanography workflows first reproject positions $(\\lambda, \\phi)$, where $\\lambda$ is longitude and $\\phi$ is latitude (angles in radians), into Mercator coordinates $(x, y)$ prior to computing $F$ and $\\sigma$. The Mercator projection is conformal and locally isotropic, but has a latitude-dependent scale factor. Let the projection be written as $P : (\\lambda, \\phi) \\mapsto (x, y)$, and let $J(\\phi) = \\nabla P$ denote its local Jacobian. For the Mercator projection on a sphere of radius $R$, $x = R \\lambda$ and $y = R \\ln\\!\\big(\\tan\\!\\big(\\frac{\\pi}{4} + \\frac{\\phi}{2}\\big)\\big)$, and $J(\\phi)$ induces a local isotropic scale $s(\\phi) = \\sec(\\phi)$ in both $x$ and $y$ directions relative to true physical distances on the sphere.\n\nSuppose you have computed an FTLE field $\\sigma_{M}$ using the deformation gradient $F_{M} = \\nabla\\!\\big(P \\circ \\Phi_{t_{0}}^{t_{1}} \\circ P^{-1}\\big)$ in Mercator coordinates without accounting for the latitude-dependent scale factor. Consider a single trajectory that starts at latitude $\\phi_{0}$ and ends at latitude $\\phi_{1}$ over the time interval $T$. Using only fundamental definitions of the flow map, deformation gradient, and FTLE, and the fact that the Mercator projection is conformal with local isotropic scale $s(\\phi)$, derive the analytic expression for the corrected FTLE in true physical space on the sphere, $\\sigma_{\\text{true}}$, in terms of $\\sigma_{M}$, $\\phi_{0}$, $\\phi_{1}$, and $T$.\n\nState your final result as a single closed-form expression. Angles must be treated in radians. No numerical evaluation is required.",
            "solution": "The user wants to find the relationship between the true Finite-Time Lyapunov Exponent (FTLE) on a sphere, $\\sigma_{\\text{true}}$, and the FTLE computed in Mercator coordinates, $\\sigma_{M}$. The derivation must be based on the fundamental definitions and properties provided.\n\nLet $p_{0}$ be the initial position of a fluid parcel on the sphere at time $t_{0}$, and $p_{1}$ be its final position at time $t_{1}$. The flow map $\\Phi_{\\text{true}} \\equiv \\Phi_{t_{0}}^{t_{1}}$ maps $p_{0}$ to $p_{1}$, so $p_{1} = \\Phi_{\\text{true}}(p_{0})$. The initial and final latitudes are $\\phi_{0}$ and $\\phi_{1}$, respectively.\n\nThe core of the FTLE calculation is the deformation gradient, $F$, which describes how an infinitesimal displacement vector at the initial position is stretched and rotated by the flow. Let $d\\boldsymbol{x}_{\\text{phys},0}$ be an infinitesimal physical displacement vector on the sphere's tangent plane at $p_{0}$. After the time interval $T = t_{1} - t_{0}$, this vector becomes $d\\boldsymbol{x}_{\\text{phys},1}$ at $p_{1}$. The true deformation gradient, $F_{\\text{true}}$, relates these two vectors:\n$$d\\boldsymbol{x}_{\\text{phys},1} = F_{\\text{true}} \\, d\\boldsymbol{x}_{\\text{phys},0}$$\n\nThe problem states that calculations are performed in Mercator coordinates $(x, y)$, which are obtained by a projection $P$ from spherical coordinates $(\\lambda, \\phi)$. The problem gives that this projection is conformal and has a local isotropic scale factor $s(\\phi) = \\sec(\\phi)$. This means that the length of a physical displacement vector $d\\boldsymbol{x}_{\\text{phys}}$ at latitude $\\phi$ is related to the length of its corresponding representation $d\\boldsymbol{m}$ in Mercator coordinates by:\n$$\\|d\\boldsymbol{x}_{\\text{phys}}\\| = \\frac{1}{s(\\phi)} \\|d\\boldsymbol{m}\\| = \\cos(\\phi) \\|d\\boldsymbol{m}\\|$$\nSince the scaling is isotropic (the same in all directions), the vector relationship is a simple scalar multiplication:\n$$d\\boldsymbol{x}_{\\text{phys}} = \\cos(\\phi) \\, d\\boldsymbol{m}$$\n\nLet $d\\boldsymbol{m}_{0}$ be an infinitesimal displacement in Mercator coordinates at the initial position. The corresponding physical displacement is $d\\boldsymbol{x}_{\\text{phys},0} = \\cos(\\phi_{0}) \\, d\\boldsymbol{m}_{0}$. Let $d\\boldsymbol{m}_{1}$ be the corresponding displacement at the final position. The corresponding physical displacement is $d\\boldsymbol{x}_{\\text{phys},1} = \\cos(\\phi_{1}) \\, d\\boldsymbol{m}_{1}$.\n\nThe deformation gradient computed in Mercator coordinates, $F_{M}$, maps the initial Mercator displacement to the final one:\n$$d\\boldsymbol{m}_{1} = F_{M} \\, d\\boldsymbol{m}_{0}$$\n\nWe can now establish a relationship between $F_{\\text{true}}$ and $F_{M}$. We start with the definition of the true deformation gradient:\n$$d\\boldsymbol{x}_{\\text{phys},1} = F_{\\text{true}} \\, d\\boldsymbol{x}_{\\text{phys},0}$$\nSubstitute the expressions relating physical and Mercator displacements:\n$$\\cos(\\phi_{1}) \\, d\\boldsymbol{m}_{1} = F_{\\text{true}} \\, (\\cos(\\phi_{0}) \\, d\\boldsymbol{m}_{0})$$\nNow, substitute $d\\boldsymbol{m}_{1} = F_{M} \\, d\\boldsymbol{m}_{0}$:\n$$\\cos(\\phi_{1}) \\, (F_{M} \\, d\\boldsymbol{m}_{0}) = F_{\\text{true}} \\, \\cos(\\phi_{0}) \\, d\\boldsymbol{m}_{0}$$\nSince the scalar factors $\\cos(\\phi_{0})$ and $\\cos(\\phi_{1})$ commute with the matrices, we can write:\n$$(\\cos(\\phi_{1}) F_{M}) \\, d\\boldsymbol{m}_{0} = (\\cos(\\phi_{0}) F_{\\text{true}}) \\, d\\boldsymbol{m}_{0}$$\nThis equation must hold for any infinitesimal displacement $d\\boldsymbol{m}_{0}$, which implies the matrix relationship:\n$$\\cos(\\phi_{1}) F_{M} = \\cos(\\phi_{0}) F_{\\text{true}}$$\nSolving for $F_{\\text{true}}$, we get:\n$$F_{\\text{true}} = \\frac{\\cos(\\phi_{1})}{\\cos(\\phi_{0})} F_{M}$$\n\nThe next step is to relate the right Cauchy–Green strain tensors. The true tensor is $C_{\\text{true}} = F_{\\text{true}}^{\\top} F_{\\text{true}}$, and the Mercator-based tensor is $C_{M} = F_{M}^{\\top} F_{M}$.\n$$C_{\\text{true}} = \\left(\\frac{\\cos(\\phi_{1})}{\\cos(\\phi_{0})} F_{M}\\right)^{\\top} \\left(\\frac{\\cos(\\phi_{1})}{\\cos(\\phi_{0})} F_{M}\\right)$$\nSince the term $\\frac{\\cos(\\phi_{1})}{\\cos(\\phi_{0})}$ is a scalar, it comes out of the transpose and multiplication:\n$$C_{\\text{true}} = \\left(\\frac{\\cos(\\phi_{1})}{\\cos(\\phi_{0})}\\right)^{2} F_{M}^{\\top} F_{M} = \\left(\\frac{\\cos(\\phi_{1})}{\\cos(\\phi_{0})}\\right)^{2} C_{M}$$\n\nThe FTLE depends on the maximum eigenvalue, $\\lambda_{\\max}$, of the Cauchy-Green tensor. If a matrix $A$ is scaled by a scalar $k$ to form $B = kA$, their eigenvalues are related by $\\lambda_{i}(B) = k \\lambda_{i}(A)$. Therefore, the maximum eigenvalues are related by:\n$$\\lambda_{\\max}(C_{\\text{true}}) = \\left(\\frac{\\cos(\\phi_{1})}{\\cos(\\phi_{0})}\\right)^{2} \\lambda_{\\max}(C_{M})$$\n\nFinally, we use the definition of FTLE provided in the problem, $\\sigma = \\frac{1}{2 |T|} \\ln(\\lambda_{\\max}(C))$.\nThe true FTLE is:\n$$\\sigma_{\\text{true}} = \\frac{1}{2|T|} \\ln\\left(\\lambda_{\\max}(C_{\\text{true}})\\right)$$\nSubstituting the relationship for the eigenvalues:\n$$\\sigma_{\\text{true}} = \\frac{1}{2|T|} \\ln\\left( \\left(\\frac{\\cos(\\phi_{1})}{\\cos(\\phi_{0})}\\right)^{2} \\lambda_{\\max}(C_{M}) \\right)$$\nUsing the logarithmic property $\\ln(a \\cdot b) = \\ln(a) + \\ln(b)$:\n$$\\sigma_{\\text{true}} = \\frac{1}{2|T|} \\left[ \\ln\\left(\\left(\\frac{\\cos(\\phi_{1})}{\\cos(\\phi_{0})}\\right)^{2}\\right) + \\ln\\left(\\lambda_{\\max}(C_{M})\\right) \\right]$$\nUsing the logarithmic property $\\ln(a^{b}) = b \\ln(a)$ and distributing the $\\frac{1}{2|T|}$ term:\n$$\\sigma_{\\text{true}} = \\frac{1}{2|T|} \\left[ 2 \\ln\\left|\\frac{\\cos(\\phi_{1})}{\\cos(\\phi_{0})}\\right| \\right] + \\frac{1}{2|T|} \\ln\\left(\\lambda_{\\max}(C_{M})\\right)$$\nFor the valid domain of the Mercator projection, $\\phi \\in (-\\frac{\\pi}{2}, \\frac{\\pi}{2})$, so $\\cos(\\phi) > 0$. The absolute value is not necessary.\n$$\\sigma_{\\text{true}} = \\frac{1}{|T|} \\ln\\left(\\frac{\\cos(\\phi_{1})}{\\cos(\\phi_{0})}\\right) + \\frac{1}{2|T|} \\ln\\left(\\lambda_{\\max}(C_{M})\\right)$$\nThe second term is precisely the definition of the FTLE computed in Mercator coordinates, $\\sigma_{M}$. Thus, we arrive at the final relationship:\n$$\\sigma_{\\text{true}} = \\sigma_{M} + \\frac{1}{|T|} \\ln\\left(\\frac{\\cos(\\phi_{1})}{\\cos(\\phi_{0})}\\right)$$\nThis expression gives the corrected, true FTLE in terms of the FTLE computed from the uncorrected Mercator projection, the initial and final latitudes $\\phi_{0}$ and $\\phi_{1}$, and the integration time interval $T$.",
            "answer": "$$\\boxed{\\sigma_{M} + \\frac{1}{|T|} \\ln\\left(\\frac{\\cos(\\phi_{1})}{\\cos(\\phi_{0})}\\right)}$$"
        }
    ]
}