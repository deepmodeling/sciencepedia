{
    "hands_on_practices": [
        {
            "introduction": "物理模型的一个基本要求是尊重对称性，例如伽利略不变性，这意味着物理定律在所有惯性参考系中都应具有相同的形式。然而，纯数据驱动的机器学习模型可能无意中学习到违反此原则的动力学关系，导致在不同参考系下产生非物理的人为能量源或汇。这项实践  将指导你量化这种不一致性，通过计算一个非伽利略不变的闭合项在参考系平移下引入的伪能量输入，从而加深对构建物理上稳健的机器学习模型重要性的理解。",
            "id": "3807972",
            "problem": "考虑一个一维、周期性、不可压缩的流动，它被用作水平均勻洋流的简化模型。在无量纲单位下，动能定义为 $E(t) = \\frac{1}{2} \\int_0^L u(x,t)^2 \\, dx$，作用于长度为 $L$ 的域上，并具有周期性边界条件。从牛顿第二定律和一维空间中的不可压缩 Navier–Stokes 动量方程出发，周期性域的动能收支表明，由任何附加的彻体力或闭合项引起的动能变化率等于速度与该作用力的乘积的空间积分。在物理信息机器学习（PIML）中，学习到的闭合项可能会引入对绝对速度的显式依赖，而这种依赖不具有伽利略不变性。伽利略平移对应于 $u'(x,t) = u(x,t) + U$，其中 $U$ 是一个恒定的均匀背景速度。对于一个闭合泛函 $C(u,\\partial_x u)$，由该闭合项输入的能量定义为 $I(u; C) = \\int_0^L u(x) \\, C(u(x), \\partial_x u(x)) \\, dx$。在均匀参考系平移 $U$ 下，将伪能量输入定义为 $\\Delta I = I(u+U; C) - I(u; C)$，对于一个具有伽利略不变性的闭合项，该值应为零。在本问题中，您将为一系列可能违反伽利略不变性的学习闭合项计算 $\\Delta I$。\n\n使用以下由系数 $\\alpha$、$\\beta$ 和 $\\gamma$ 参数化的闭合项族：\n$$\nC(u,\\partial_x u) = \\alpha \\, u + \\beta \\, u^3 + \\gamma \\, \\partial_x u.\n$$\n这个选择有意地混合了可能非不变的项（$\\alpha u$ 和 $\\beta u^3$）和一个不变的梯度依赖项（$\\gamma \\, \\partial_x u$）。均匀平移只影响绝对速度，不影响空间梯度，因此 $\\partial_x (u+U) = \\partial_x u$。\n\n实现一个程序，给定域长度 $L$、网格大小 $N$、均匀平移 $U$、闭合参数 $(\\alpha, \\beta, \\gamma)$ 和一个预设的稳态速度场 $u(x)$，使用离散近似数值计算伪能量输入 $\\Delta I$：\n- 将域表示为 $N$ 个网格点，间距为 $\\Delta x = L/N$，坐标为 $x_j = j \\Delta x$（$j = 0, 1, \\dots, N-1$），并采用周期性边界条件。\n- 使用带周期性回绕的二阶中心差分来近似 $\\partial_x u$：\n$$\n(\\partial_x u)_j \\approx \\frac{u_{j+1} - u_{j-1}}{2 \\, \\Delta x},\n$$\n其中 $u_{-1} \\equiv u_{N-1}$ 且 $u_N \\equiv u_0$。\n- 通过矩形法则（等效于黎曼和）来近似空间积分：\n$$\nI(u; C) \\approx \\sum_{j=0}^{N-1} u_j \\, C(u_j, (\\partial_x u)_j) \\, \\Delta x.\n$$\n- 以无量纲单位计算 $\\Delta I$ 并将其作为浮点数。\n\n全过程使用无量纲单位；不需要物理单位。当三角函数中出现角度时，应以弧度为单位进行计算。\n\n您的程序必须运行以下所有测试用例，并按指定格式打印结果。对于每个用例，按规定定义 $u(x)$ 并计算 $\\Delta I$。\n\n测试套件：\n- 用例 $1$（通用混合闭合项，正弦场，中等平移）：\n  - $L = 2\\pi$， $N = 1024$， $U = 0.5$， $(\\alpha,\\beta,\\gamma) = (0.1, 0.02, -0.05)$，\n  - $u(x) = \\sin(x) + 0.3 \\, \\sin(2x)$。\n- 用例 $2$（应具有伽利略不变性的纯梯度闭合项）：\n  - $L = 2\\pi$， $N = 1024$， $U = 0.75$， $(\\alpha,\\beta,\\gamma) = (0, 0, -0.1)$，\n  - $u(x) = \\cos(3x)$。\n- 用例 $3$（零平移基准）：\n  - $L = 2\\pi$， $N = 1024$， $U = 0.0$， $(\\alpha,\\beta,\\gamma) = (0.2, -0.03, 0.0)$，\n  - $u(x) = \\sin(x)$。\n- 用例 $4$（恒定场，纯非不变线性闭合项，非零平移）：\n  - $L = 1.0$， $N = 256$， $U = -1.2$， $(\\alpha,\\beta,\\gamma) = (0.5, 0.0, 0.0)$，\n  - 对于所有 $x$，$u(x) = 0.2$。\n- 用例 $5$（粗网格边缘情况，混合闭合项）：\n  - $L = 2\\pi$， $N = 4$， $U = 0.3$， $(\\alpha,\\beta,\\gamma) = (0.0, 0.05, -0.02)$，\n  - $u(x) = \\sin(x)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是为用例 $i$ 计算出的 $\\Delta I$ 的浮点数值，以无量纲单位表示。",
            "solution": "该问题要求计算在一维流体动力学模型中，针对一个特定的学习闭合项族所产生的伪能量输入，记为 $\\Delta I$。当对系统应用一个均匀速度平移 $U$ 时，由于违反了伽利略不变性，会产生这种伪能量。分析将首先定义相关量，然后建立它们的近似数值方法，最后概述为指定测试用例计算 $\\Delta I$ 的算法。\n\n伪能量输入被定义为平移后速度场的闭合项能量输入与原始速度场的闭合项能量输入之差：\n$$\n\\Delta I = I(u+U; C) - I(u; C)\n$$\n其中 $u(x,t)$ 是速度场，$U$ 是一个恒定的均匀平移，$I(v; C)$ 是对于一个通用速度场 $v$ 的能量输入泛函。该泛函由在长度为 $L$ 的周期域上的积分给出：\n$$\nI(v; C) = \\int_0^L v(x) \\, C(v(x), \\partial_x v(x)) \\, dx\n$$\n闭合泛函 $C(v, \\partial_x v)$ 由一个特定的参数形式给出：\n$$\nC(v, \\partial_x v) = \\alpha \\, v + \\beta \\, v^3 + \\gamma \\, \\partial_x v\n$$\n其中 $\\alpha$、$\\beta$ 和 $\\gamma$ 是常系数。均匀平移的一个关键特性是它不影响空间梯度：$\\partial_x (u+U) = \\partial_x u$。\n\n为了数值计算 $\\Delta I$，我们必须将域以及微分和积分算子离散化。域 $[0, L]$ 由 $N$ 个网格点 $x_j = j \\Delta x$ 表示，其中 $j = 0, 1, \\dots, N-1$，网格间距为 $\\Delta x = L/N$。连续速度场 $u(x)$ 由其在这些网格点上的值 $u_j = u(x_j)$ 表示。\n\n每个网格点 $j$ 处的空间导数 $\\partial_x u$ 使用带周期性边界条件的二阶中心差分格式来近似。公式为：\n$$\n(\\partial_x u)_j \\approx \\frac{u_{j+1} - u_{j-1}}{2 \\, \\Delta x}\n$$\n周期性意味着索引按模 $N$ 处理，使得 $u_{N} \\equiv u_0$ 且 $u_{-1} \\equiv u_{N-1}$。\n\n积分 $\\int_0^L f(x) \\, dx$ 通过黎曼和（具体来说，是每个子区间上使用左端点的矩形法则）来近似：\n$$\n\\int_0^L f(x) \\, dx \\approx \\sum_{j=0}^{N-1} f(x_j) \\, \\Delta x\n$$\n\n计算 $\\Delta I$ 的步骤如下：\n\n1.  **计算 $I(u; C)$**：\n    a.  首先，生成离散速度场 $u_j = u(x_j)$，其中 $j=0, \\dots, N-1$。\n    b.  接着，使用中心差分公式计算所有 $j$ 的离散导数 $(\\partial_x u)_j$。\n    c.  在每个网格点上，计算离散闭合项：$C_j = \\alpha u_j + \\beta u_j^3 + \\gamma (\\partial_x u)_j$。\n    d.  计算离散被积函数，即乘积 $(u \\cdot C)_j = u_j C_j$。\n    e.  最后，使用黎曼和近似积分 $I(u; C)$：\n        $$\n        I(u; C) \\approx \\left( \\sum_{j=0}^{N-1} u_j C_j \\right) \\Delta x\n        $$\n\n2.  **计算 $I(u+U; C)$**：\n    a.  定义平移后的速度场为 $u'_j = u_j + U$。\n    b.  平移后场 $u+U$ 的导数 $\\partial_x(u+U)$ 与原始场的导数 $\\partial_x u$ 相同，因为 $U$ 是常数。因此，离散导数向量 $(\\partial_x u')_j$ 与上一步中计算的 $(\\partial_x u)_j$ 相同。\n    c.  在每个网格点上计算平移后场的闭合项：$C'_j = C(u'_j, (\\partial_x u)_j) = \\alpha u'_j + \\beta (u'_j)^3 + \\gamma (\\partial_x u)_j$。\n    d.  计算平移后情况的离散被积函数：$(u' \\cdot C')_j = u'_j C'_j$。\n    e.  使用黎曼和近似积分 $I(u+U; C)$：\n        $$\n        I(u+U; C) \\approx \\left( \\sum_{j=0}^{N-1} u'_j C'_j \\right) \\Delta x\n        $$\n\n3.  **计算 $\\Delta I$**：\n    最终结果是两个数值计算积分之差：\n    $$\n    \\Delta I = I_\\text{approx}(u+U; C) - I_\\text{approx}(u; C)\n    $$\n此过程应用于每个测试用例，使用其特定的参数集（$L, N, U, \\alpha, \\beta, \\gamma$）和速度场 $u(x)$。对于那些闭合项应具有伽利略不变性的测试用例（例如，当 $\\alpha=0$ 且 $\\beta=0$ 时）或当平移为零（$U=0$）时，我们预期 $\\Delta I$ 为零，或由于数值伪影而为一个在浮点精度量级上的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the spurious energy input for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: general mixed closure, sinusoidal field, moderate translation\n        {\n            \"L\": 2 * np.pi, \"N\": 1024, \"U\": 0.5,\n            \"params\": (0.1, 0.02, -0.05), # (alpha, beta, gamma)\n            \"u_func\": lambda x: np.sin(x) + 0.3 * np.sin(2 * x),\n        },\n        # Case 2: gradient-only closure that should be Galilean invariant\n        {\n            \"L\": 2 * np.pi, \"N\": 1024, \"U\": 0.75,\n            \"params\": (0.0, 0.0, -0.1),\n            \"u_func\": lambda x: np.cos(3 * x),\n        },\n        # Case 3: zero translation baseline\n        {\n            \"L\": 2 * np.pi, \"N\": 1024, \"U\": 0.0,\n            \"params\": (0.2, -0.03, 0.0),\n            \"u_func\": lambda x: np.sin(x),\n        },\n        # Case 4: constant field, purely non-invariant linear closure, nonzero translation\n        {\n            \"L\": 1.0, \"N\": 256, \"U\": -1.2,\n            \"params\": (0.5, 0.0, 0.0),\n            \"u_func\": lambda x: 0.2 * np.ones_like(x),\n        },\n        # Case 5: coarse grid edge case, mixed closure\n        {\n            \"L\": 2 * np.pi, \"N\": 4, \"U\": 0.3,\n            \"params\": (0.0, 0.05, -0.02),\n            \"u_func\": lambda x: np.sin(x),\n        },\n    ]\n\n    def compute_energy_input(v, dv_dx, dx, alpha, beta, gamma):\n        \"\"\"\n        Computes the discrete energy input I(v; C).\n        \n        Args:\n            v (np.ndarray): Discrete velocity field.\n            dv_dx (np.ndarray): Discrete spatial derivative of the velocity field.\n            dx (float): Grid spacing.\n            alpha (float): Closure parameter.\n            beta (float): Closure parameter.\n            gamma (float): Closure parameter.\n        \n        Returns:\n            float: The numerically computed energy input.\n        \"\"\"\n        # Closure term C(v, dv/dx) = alpha*v + beta*v^3 + gamma*dv/dx\n        closure_term = alpha * v + beta * v**3 + gamma * dv_dx\n        \n        # Integrand v * C(v, dv/dx)\n        integrand = v * closure_term\n        \n        # Integral via Riemann sum\n        integral = np.sum(integrand) * dx\n        return integral\n\n    results = []\n    for case in test_cases:\n        L, N, U = case[\"L\"], case[\"N\"], case[\"U\"]\n        alpha, beta, gamma = case[\"params\"]\n        u_func = case[\"u_func\"]\n\n        # 1. Set up the discrete domain and initial velocity field\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        u = u_func(x)\n\n        # 2. Compute the derivative of the original velocity field u\n        # np.roll(u, -1) provides u_{j+1}\n        # np.roll(u, 1) provides u_{j-1}\n        du_dx = (np.roll(u, -1) - np.roll(u, 1)) / (2 * dx)\n\n        # 3. Compute I(u; C) for the original field\n        I_u = compute_energy_input(u, du_dx, dx, alpha, beta, gamma)\n\n        # 4. Define the translated field u' = u + U\n        u_prime = u + U\n        # The derivative of u' is the same as u, since d(u+U)/dx = du/dx\n        du_prime_dx = du_dx\n        \n        # 5. Compute I(u+U; C) for the translated field\n        I_u_prime = compute_energy_input(u_prime, du_prime_dx, dx, alpha, beta, gamma)\n        \n        # 6. Calculate the spurious energy input ΔI\n        delta_I = I_u_prime - I_u\n        results.append(delta_I)\n    \n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在海洋模型中嵌入物理定律（如不可压缩性）是PIML的核心任务之一，这通常通过可微分的物理求解器实现。压力投影是确保流体不可压缩的关键步骤，它通过求解泊松方程来实现。这项实践  将引导你使用高效的谱方法实现一个可微分的压力求解器，并通过与有限差分法的比较来验证其梯度的正确性，这是将物理求解器作为神经网络层进行端到端训练的基础。",
            "id": "3807941",
            "problem": "实现一个可微分的谱方法泊松求解器，用于在周期性边界条件下进行压力投影，并通过将解析梯度与有限差分近似进行比较，验证一个物理启发的损失函数关于某个标量参数的梯度的正确性。\n\n您正在一个大小为 $L_x \\times L_y$、具有 $N_x \\times N_y$ 个网格点的二维周期性域上，对海洋建模中使用的不可压缩压力投影步骤进行建模。设配置速度场为 $(u, v)$，投影算子 $P$ 通过 Helmholtz–Hodge 分解在周期性边界下去除无旋分量，从而强制实现不可压缩性。具体来说，给定一个试探速度 $(u^\\ast, v^\\ast)$，计算其散度 $g = \\nabla \\cdot (u^\\ast, v^\\ast)$，求解泊松问题\n$$\n\\Delta p = g\n$$\n其中 $p$ 满足周期性边界条件和零均值约束，并返回投影后的速度\n$$\n(u, v) = (u^\\ast, v^\\ast) - \\nabla p.\n$$\n所有微分算子都将以谱方法实现：二维快速傅里叶变换 (FFT) 将场 $f(x,y)$ 映射到 $\\hat{f}(k_x, k_y)$，其中谱导数定义为 $\\widehat{\\partial_x f} = i k_x \\hat{f}$、$\\widehat{\\partial_y f} = i k_y \\hat{f}$，拉普拉斯算子满足 $\\widehat{\\Delta f} = - (k_x^2 + k_y^2) \\hat{f}$。零波数模态 $\\hat{p}(0,0)$ 必须设为零以强制实现零均值。\n\n考虑一个参数化的试探速度族\n$$\n(u^\\ast(\\alpha), v^\\ast(\\alpha)) = (u_0, v_0) + \\alpha \\, (u_b, v_b),\n$$\n其中 $(u_0, v_0)$ 和 $(u_b, v_b)$ 是固定的、光滑的、周期性的速度场，$\\alpha \\in \\mathbb{R}$ 是一个标量参数。设投影后的速度为\n$$\n(u(\\alpha), v(\\alpha)) = P\\big(u^\\ast(\\alpha), v^\\ast(\\alpha)\\big).\n$$\n定义一个物理启发的二次损失，用于衡量与目标无散场 $(u_T, v_T)$ 的偏差：\n$$\n\\mathcal{L}(\\alpha) = \\frac{1}{2} \\int_0^{L_x} \\int_0^{L_y} \\left( \\left[u(\\alpha) - u_T\\right]^2 + \\left[v(\\alpha) - v_T\\right]^2 \\right) \\, \\mathrm{d}y \\, \\mathrm{d}x.\n$$\n在离散网格上，用单元面积为 $\\Delta A = \\Delta x \\, \\Delta y$ 的黎曼和来近似该积分，其中 $\\Delta x = L_x/N_x$，$\\Delta y = L_y/N_y$。\n\n任务要求：\n1. 使用二维快速傅里叶变换 (FFT) 及其逆变换（逆快速傅里叶变换 (IFFT)），在周期性边界条件下实现上述的谱压力投影算子 $P$。\n2. 使用投影后的速度 $P\\big((u_0, v_0) + \\alpha (u_b, v_b)\\big)$，实现损失函数 $\\mathcal{L}(\\alpha)$ 作为 $\\alpha$ 的函数。\n3. 使用第一性原理推导并实现解析梯度 $\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha$。您的推导必须从 $\\mathcal{L}(\\alpha)$ 的定义和 $P$ 的线性性质出发，并且不能假设任何预封装的自动微分。利用投影是线性的，因此\n$$\nP\\big((u_0, v_0) + \\alpha (u_b, v_b)\\big) = P(u_0, v_0) + \\alpha \\, P(u_b, v_b),\n$$\n由此可得\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}\\alpha} (u(\\alpha), v(\\alpha)) = P(u_b, v_b).\n$$\n将此与应用于 $\\mathcal{L}(\\alpha)$ 的链式法则相结合，得到 $\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha$ 的一个显式表达式，该表达式用 $(u(\\alpha)-u_T, v(\\alpha)-v_T)$ 和 $P(u_b, v_b)$ 表示。\n4. 通过将其与中心有限差分近似进行比较，验证您的解析梯度的正确性：\n$$\n\\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}\\alpha} \\approx \\frac{\\mathcal{L}(\\alpha + \\varepsilon) - \\mathcal{L}(\\alpha - \\varepsilon)}{2 \\varepsilon},\n$$\n其中 $\\varepsilon$ 是一个小步长。\n5. 所有速度场必须由在 $[0,L_x] \\times [0,L_y]$ 上周期的光滑三角函数模态构成。为确保物理一致性，目标场必须设置为基底场的投影：$(u_T, v_T) = P(u_0, v_0)$。\n\n物理单位：$x$ 和 $y$ 的单位是米，$u$ 和 $v$ 的单位是米/秒，$\\mathcal{L}$ 的单位是 $\\mathrm{m}^4/\\mathrm{s}^2$，由于 $\\alpha$ 是无量纲的，$\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha$ 的单位是 $\\mathrm{m}^4/\\mathrm{s}^2$。如下文指定，以无量纲量报告最终的数值误差。\n\n提供一个程序，用于评估以下每个测试用例中解析梯度与有限差分近似之间的相对差异。对于每个用例，计算误差度量\n$$\nE = \\frac{\\left| \\left(\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha\\right)_{\\mathrm{analytic}} - \\left(\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha\\right)_{\\mathrm{FD}} \\right|}{\\max\\left(1, \\left| \\left(\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha\\right)_{\\mathrm{analytic}} \\right|\\right)}.\n$$\n\n测试套件：\n- 用例 A (通用混合基，正常路径)：$N_x = 32$, $N_y = 32$, $L_x = 10^6$ 米, $L_y = 10^6$ 米, $\\alpha = 0.3$, $\\varepsilon = 10^{-6}$。构造\n  - $u_0(x,y) = 0.08 \\, \\sin\\left(2\\pi x/L_x\\right) \\cos\\left(2\\pi y/L_y\\right)$,\n  - $v_0(x,y) = -0.05 \\, \\cos\\left(2\\pi x/L_x\\right) \\sin\\left(2\\pi y/L_y\\right)$,\n  - $(u_b, v_b)$ 作为混合场\n    $u_b(x,y) = 0.06 \\, \\sin\\left(4\\pi x/L_x\\right) \\cos\\left(2\\pi y/L_y\\right) + 0.03 \\, \\cos\\left(2\\pi x/L_x\\right) \\sin\\left(6\\pi y/L_y\\right)$,\n    $v_b(x,y) = 0.02 \\, \\cos\\left(4\\pi x/L_x\\right) \\sin\\left(2\\pi y/L_y\\right) + 0.07 \\, \\sin\\left(2\\pi x/L_x\\right) \\cos\\left(6\\pi y/L_y\\right)$。\n- 用例 B (无散基)：$N_x = 32$, $N_y = 32$, $L_x = 10^6$ 米, $L_y = 10^6$ 米, $\\alpha = -0.7$, $\\varepsilon = 10^{-6}$。通过流函数 $\\psi(x,y) = \\Psi_0 \\sin\\left(2\\pi x/L_x\\right) \\sin\\left(4\\pi y/L_y\\right)$ (其中 $\\Psi_0 = 5\\times 10^3 \\, \\mathrm{m}^2/\\mathrm{s}$) 构造 $(u_b, v_b)$，即 $u_b = \\partial_y \\psi$, $v_b = -\\partial_x \\psi$。使用与用例 A 中相同的 $(u_0,v_0)$。\n- 用例 C (纯梯度基，边界情况)：$N_x = 32$, $N_y = 32$, $L_x = 10^6$ 米, $L_y = 10^6$ 米, $\\alpha = 0.5$, $\\varepsilon = 10^{-6}$。通过势函数 $\\phi(x,y) = \\Phi_0 \\sin\\left(2\\pi x/L_x\\right) \\cos\\left(2\\pi y/L_y\\right)$ (其中 $\\Phi_0 = 5\\times 10^3 \\, \\mathrm{m}^2/\\mathrm{s}$) 构造 $(u_b, v_b)$，即 $u_b = \\partial_x \\phi$, $v_b = \\partial_y \\phi$。使用与用例 A 中相同的 $(u_0,v_0)$。\n- 用例 D (小网格分辨率，边界条件压力测试)：$N_x = 8$, $N_y = 8$, $L_x = 10^6$ 米, $L_y = 10^6$ 米, $\\alpha = 10^{-3}$, $\\varepsilon = 10^{-7}$。使用与用例 A 中相同的 $(u_0,v_0)$ 和用例 A 中的混合 $(u_b, v_b)$。\n\n对于所有用例，将目标场 $(u_T, v_T)$ 设置为投影后的基底场 $P(u_0, v_0)$。解析梯度必须从第一性原理计算，而不是通过自动微分。三角函数的角度单位为弧度。\n\n您的程序应产生单行输出，其中包含用例 A、B、C 和 D 的误差，格式为逗号分隔的列表并用方括号括起 (例如 \"[e_A,e_B,e_C,e_D]\")，其中每个 e 是代表该用例误差 E 的浮点数，无量纲，并以指定环境中默认字符串转换可用的完整机器精度打印。",
            "solution": "用户提供的问题陈述经过仔细验证，被确定为在科学上是合理的、适定的和完整的。所有必要的数据、物理原理和数学公式均已提供，并与计算流体力学和数值分析中的既定实践相符。该任务要求实现和验证一个可微分的谱方法泊松求解器，这是物理启发的机器学习在海洋建模领域中的一个标准且不简单的课题。我现在将着手提供完整的解决方案。\n\n解决方案的结构如下：\n1.  离散域和谱表示的建立。\n2.  谱压力投影算子 $P$ 的实现。\n3.  解析梯度 $\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha$ 的推导。\n4.  使用有限差分近似的验证过程描述。\n\n**1. 离散域和谱表示**\n\n我们考虑一个二维周期性域 $[0, L_x] \\times [0, L_y]$，该域被一个具有 $N_x \\times N_y$ 个点的均匀网格离散化。网格间距为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。一个物理场 $f(x,y)$ 由其在该网格上的值 $f_{j,k} = f(j\\Delta x, k\\Delta y)$ 表示。\n\n谱方法的核心是二维离散傅里叶变换 (DFT)，通过快速傅里叶变换 (FFT) 算法实现。场 $f$ 的变换记为 $\\hat{f}$。对于大小为 $N$、长度为 $L$ 的网格，对应的角波数由 $k_n = 2\\pi n / L$ 给出，其中 $n$ 是整数模态数。对于离散网格，波数计算为 $k_m = 2\\pi f_m$，其中 $f_m$ 是标准FFT库返回的频率。对于大小为 $N$、间距为 $d$ 的网格，这些频率是 $f_m = m/(N d)$，其中 $m \\in \\{-N/2, \\dots, N/2-1\\}$（或类似范围）。\n\n我们定义与我们域的维度相对应的二维波数网格 $k_x$ 和 $k_y$。设 $\\boldsymbol{k} = (k_x, k_y)$。利用这些，我们可以定义谱微分算子。偏导数的傅里叶变换由下式给出：\n$$\n\\widehat{\\frac{\\partial f}{\\partial x}}(\\boldsymbol{k}) = i k_x \\hat{f}(\\boldsymbol{k}) \\quad \\text{和} \\quad \\widehat{\\frac{\\partial f}{\\partial y}}(\\boldsymbol{k}) = i k_y \\hat{f}(\\boldsymbol{k})\n$$\n其中 $i = \\sqrt{-1}$。因此，矢量场 $(u, v)$ 的散度和标量场 $p$ 的拉普拉斯算子在傅里叶空间中表示为：\n$$\n\\widehat{\\nabla \\cdot (u,v)}(\\boldsymbol{k}) = i k_x \\hat{u}(\\boldsymbol{k}) + i k_y \\hat{v}(\\boldsymbol{k})\n$$\n$$\n\\widehat{\\Delta p}(\\boldsymbol{k}) = \\widehat{\\nabla \\cdot \\nabla p}(\\boldsymbol{k}) = (i k_x)(i k_x) \\hat{p}(\\boldsymbol{k}) + (i k_y)(i k_y) \\hat{p}(\\boldsymbol{k}) = -(k_x^2 + k_y^2)\\hat{p}(\\boldsymbol{k}) = -|\\boldsymbol{k}|^2 \\hat{p}(\\boldsymbol{k})\n$$\n\n**2. 谱压力投影算子**\n\n压力投影算子 $P$ 将一个试探速度场 $(u^\\ast, v^\\ast)$ 映射到一个无散场 $(u, v)$。这包括三个步骤，可以在傅里叶空间中高效地组合起来。\n\n首先，我们计算试探场的散度，$g = \\nabla \\cdot (u^\\ast, v^\\ast)$。在傅里叶空间中，这表示为：\n$$\n\\hat{g}(\\boldsymbol{k}) = i k_x \\hat{u}^\\ast(\\boldsymbol{k}) + i k_y \\hat{v}^\\ast(\\boldsymbol{k})\n$$\n其次，为压力场 $p$ 求解泊松问题 $\\Delta p = g$。在傅里叶空间中，这个代数方程变为：\n$$\n-|\\boldsymbol{k}|^2 \\hat{p}(\\boldsymbol{k}) = \\hat{g}(\\boldsymbol{k})\n$$\n因此，$\\hat{p}$ 的解为 $\\hat{p}(\\boldsymbol{k}) = -\\hat{g}(\\boldsymbol{k}) / |\\boldsymbol{k}|^2$。对于零波数模态 $\\boldsymbol{k}=(0,0)$，分母 $|\\boldsymbol{k}|^2$ 为零。然而，对于周期场 $(u^\\ast, v^\\ast)$，散度定理确保 $g$ 的均值为零，即 $\\hat{g}(0,0)=0$。通过对压力施加零均值约束 $\\hat{p}(0,0)=0$，该问题变得适定。因此，我们定义逆拉普拉斯算子核为：\n$$\n\\widehat{\\Delta^{-1}}(\\boldsymbol{k}) = \\begin{cases} -1/|\\boldsymbol{k}|^2  \\text{if } \\boldsymbol{k} \\neq (0,0) \\\\ 0  \\text{if } \\boldsymbol{k} = (0,0) \\end{cases}\n$$\n所以，$\\hat{p}(\\boldsymbol{k}) = \\widehat{\\Delta^{-1}}(\\boldsymbol{k}) \\hat{g}(\\boldsymbol{k})$。\n\n第三，最终的投影速度通过减去压力梯度得到，$(u, v) = (u^\\ast, v^\\ast) - \\nabla p$。在傅里叶空间中：\n$$\n\\hat{u}(\\boldsymbol{k}) = \\hat{u}^\\ast(\\boldsymbol{k}) - i k_x \\hat{p}(\\boldsymbol{k})\n$$\n$$\n\\hat{v}(\\boldsymbol{k}) = \\hat{v}^\\ast(\\boldsymbol{k}) - i k_y \\hat{p}(\\boldsymbol{k})\n$$\n代入 $\\hat{p}$ 和 $\\hat{g}$ 的表达式，我们可以在傅里叶空间中表示整个投影算子 $P$。设 $(u,v) = P(u^\\ast, v^\\ast)$，则：\n$$\n\\hat{u}(\\boldsymbol{k}) = \\hat{u}^\\ast(\\boldsymbol{k}) - i k_x \\widehat{\\Delta^{-1}}(\\boldsymbol{k}) \\left( i k_x \\hat{u}^\\ast(\\boldsymbol{k}) + i k_y \\hat{v}^\\ast(\\boldsymbol{k}) \\right) = \\left( 1 - \\frac{k_x^2}{|\\boldsymbol{k}|^2} \\right) \\hat{u}^\\ast(\\boldsymbol{k}) - \\frac{k_x k_y}{|\\boldsymbol{k}|^2} \\hat{v}^\\ast(\\boldsymbol{k})\n$$\n$$\n\\hat{v}(\\boldsymbol{k}) = \\hat{v}^\\ast(\\boldsymbol{k}) - i k_y \\widehat{\\Delta^{-1}}(\\boldsymbol{k}) \\left( i k_x \\hat{u}^\\ast(\\boldsymbol{k}) + i k_y \\hat{v}^\\ast(\\boldsymbol{k}) \\right) = -\\frac{k_x k_y}{|\\boldsymbol{k}|^2} \\hat{u}^\\ast(\\boldsymbol{k}) + \\left( 1 - \\frac{k_y^2}{|\\boldsymbol{k}|^2} \\right) \\hat{v}^\\ast(\\boldsymbol{k})\n$$\n这些表达式对 $\\boldsymbol{k} \\neq (0,0)$ 有效。对于 $\\boldsymbol{k}=(0,0)$，$\\hat{u}(0,0)=\\hat{u}^\\ast(0,0)$ 且 $\\hat{v}(0,0)=\\hat{v}^\\ast(0,0)$。实现将遵循此公式，将输入场 $(u^\\ast, v^\\ast)$ 变换到傅里叶空间，应用投影张量，然后变换回来。\n\n**3. 损失函数与解析梯度**\n\n损失函数定义为近似平方误差积分的离散和：\n$$\n\\mathcal{L}(\\alpha) = \\frac{1}{2} \\Delta A \\sum_{j,k} \\left( \\left[u_{j,k}(\\alpha) - u_{T,j,k}\\right]^2 + \\left[v_{j,k}(\\alpha) - v_{T,j,k}\\right]^2 \\right)\n$$\n其中 $\\Delta A = \\Delta x \\Delta y$ 是一个网格单元的面积。\n\n为了找到解析梯度 $\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha$，我们应用链式法则：\n$$\n\\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}\\alpha} = \\Delta A \\sum_{j,k} \\left( \\left[u_{j,k}(\\alpha) - u_{T,j,k}\\right] \\frac{\\mathrm{d}u_{j,k}}{\\mathrm{d}\\alpha} + \\left[v_{j,k}(\\alpha) - v_{T,j,k}\\right] \\frac{\\mathrm{d}v_{j,k}}{\\mathrm{d}\\alpha} \\right)\n$$\n问题陈述中指出，投影算子 $P$ 是线性的。参数化速度为 $(u^\\ast(\\alpha), v^\\ast(\\alpha)) = (u_0, v_0) + \\alpha \\, (u_b, v_b)$。应用线性算子 $P$ 得到：\n$$\n(u(\\alpha), v(\\alpha)) = P\\big( (u_0, v_0) + \\alpha(u_b, v_b) \\big) = P(u_0, v_0) + \\alpha P(u_b, v_b)\n$$\n设 $(u_p, v_p) = P(u_0, v_0)$ 且 $(u_{bp}, v_{bp}) = P(u_b, v_b)$。则 $(u(\\alpha), v(\\alpha)) = (u_p, v_p) + \\alpha(u_{bp}, v_{bp})$。关于 $\\alpha$ 的导数即为：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}\\alpha} (u(\\alpha), v(\\alpha)) = (u_{bp}, v_{bp}) = P(u_b, v_b)\n$$\n目标速度场设为 $(u_T, v_T) = P(u_0, v_0) = (u_p, v_p)$。梯度表达式中的误差项变为：\n$$\n(u(\\alpha) - u_T, v(\\alpha) - v_T) = \\left( (u_p + \\alpha u_{bp}) - u_p, (v_p + \\alpha v_{bp}) - v_p \\right) = (\\alpha u_{bp}, \\alpha v_{bp})\n$$\n将这些结果代入 $\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha$ 的表达式中：\n$$\n\\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}\\alpha} = \\Delta A \\sum_{j,k} \\left( (\\alpha u_{bp,j,k}) (u_{bp,j,k}) + (\\alpha v_{bp,j,k}) (v_{bp,j,k}) \\right)\n$$\n提出标量 $\\alpha$ 得到梯度的最终解析表达式：\n$$\n\\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}\\alpha} = \\alpha \\left( \\Delta A \\sum_{j,k} \\left( u_{bp,j,k}^2 + v_{bp,j,k}^2 \\right) \\right)\n$$\n该表达式的实现首先计算投影场 $(u_{bp}, v_{bp}) = P(u_b, v_b)$，然后计算其在网格上模方之和，再乘以 $\\Delta A$ 和 $\\alpha$。\n\n**4. 通过有限差分进行验证**\n\n为验证解析梯度实现的正确性，我们将其输出与二阶精确的中心有限差分 (FD) 近似进行比较。对于一个小步长 $\\varepsilon$，FD 梯度为：\n$$\n\\left(\\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}\\alpha}\\right)_{\\mathrm{FD}} = \\frac{\\mathcal{L}(\\alpha + \\varepsilon) - \\mathcal{L}(\\alpha - \\varepsilon)}{2 \\varepsilon}\n$$\n这需要两次计算完整的损失函数。解析梯度和 FD 梯度之间的差异由归一化误差度量 $E$ 量化：\n$$\nE = \\frac{\\left| \\left(\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha\\right)_{\\mathrm{analytic}} - \\left(\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha\\right)_{\\mathrm{FD}} \\right|}{\\max\\left(1, \\left| \\left(\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha\\right)_{\\mathrm{analytic}} \\right|\\right)}\n$$\n分母 $\\max(1, |\\cdot|)$ 通过防止在解析梯度为零或接近零时除以零来提供鲁棒性，从而从相对误差度量过渡到绝对误差度量。对于正确的实现和一个足够小的 $\\varepsilon$，这个误差 $E$ 预计会非常小，其大小受限于 FD 公式的截断误差（与 $\\varepsilon^2$ 成正比）和浮点舍入误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n\n    def create_spectral_ops(Nx, Ny, Lx, Ly):\n        \"\"\"\n        Creates wavenumber grids and the inverse Laplacian operator kernel.\n        \"\"\"\n        kx_vec = 2 * np.pi * fft.fftfreq(Nx, d=Lx / Nx)\n        ky_vec = 2 * np.pi * fft.fftfreq(Ny, d=Ly / Ny)\n        kxx, kyy = np.meshgrid(kx_vec, ky_vec)\n        ksq = kxx**2 + kyy**2\n        \n        # Regularize inverse Laplacian for the zero-wavenumber mode\n        inv_ksq = np.zeros_like(ksq)\n        non_zero_k = ksq != 0\n        inv_ksq[non_zero_k] = 1.0 / ksq[non_zero_k]\n        \n        return kxx, kyy, inv_ksq\n\n    def project(u_star, v_star, kxx, kyy, inv_ksq):\n        \"\"\"\n        Applies the spectral pressure projection operator.\n        \"\"\"\n        # Using ortho norm, no need to scale FFTs\n        u_star_hat = fft.fft2(u_star, norm='ortho')\n        v_star_hat = fft.fft2(v_star, norm='ortho')\n        \n        # Divergence in Fourier space\n        g_hat = 1j * kxx * u_star_hat + 1j * kyy * v_star_hat\n        \n        # Pressure in Fourier space (p_hat = -g_hat * inv_ksq)\n        p_hat = -g_hat * inv_ksq\n        \n        # Subtract pressure gradient in Fourier space\n        u_hat = u_star_hat - 1j * kxx * p_hat\n        v_hat = v_star_hat - 1j * kyy * p_hat\n        \n        # Transform back to physical space\n        u = fft.ifft2(u_hat, norm='ortho').real\n        v = fft.ifft2(v_hat, norm='ortho').real\n        \n        return u, v\n\n    def calculate_loss(alpha, u0, v0, ub, vb, uT, vT, Nx, Ny, Lx, Ly, kxx, kyy, inv_ksq):\n        \"\"\"\n        Computes the loss L(alpha).\n        \"\"\"\n        u_star_alpha = u0 + alpha * ub\n        v_star_alpha = v0 + alpha * vb\n        \n        u_alpha, v_alpha = project(u_star_alpha, v_star_alpha, kxx, kyy, inv_ksq)\n        \n        dA = (Lx / Nx) * (Ly / Ny)\n        loss = 0.5 * np.sum((u_alpha - uT)**2 + (v_alpha - vT)**2) * dA\n        return loss\n\n    def calculate_analytic_gradient(alpha, ub, vb, Nx, Ny, Lx, Ly, kxx, kyy, inv_ksq):\n        \"\"\"\n        Computes the analytic gradient dL/dalpha.\n        \"\"\"\n        ubp, vbp = project(ub, vb, kxx, kyy, inv_ksq)\n        \n        dA = (Lx / Nx) * (Ly / Ny)\n        integral_term = np.sum(ubp**2 + vbp**2) * dA\n        \n        grad_analytic = alpha * integral_term\n        return grad_analytic\n\n    def calculate_fd_gradient(alpha, eps, u0, v0, ub, vb, uT, vT, Nx, Ny, Lx, Ly, kxx, kyy, inv_ksq):\n        \"\"\"\n        Computes the finite-difference gradient.\n        \"\"\"\n        loss_plus = calculate_loss(alpha + eps, u0, v0, ub, vb, uT, vT, Nx, Ny, Lx, Ly, kxx, kyy, inv_ksq)\n        loss_minus = calculate_loss(alpha - eps, u0, v0, ub, vb, uT, vT, Nx, Ny, Lx, Ly, kxx, kyy, inv_ksq)\n        \n        grad_fd = (loss_plus - loss_minus) / (2 * eps)\n        return grad_fd\n\n    test_cases = [\n        # Case A\n        {'Nx': 32, 'Ny': 32, 'Lx': 1e6, 'Ly': 1e6, 'alpha': 0.3, 'eps': 1e-6, 'case_id': 'A'},\n        # Case B\n        {'Nx': 32, 'Ny': 32, 'Lx': 1e6, 'Ly': 1e6, 'alpha': -0.7, 'eps': 1e-6, 'case_id': 'B'},\n        # Case C\n        {'Nx': 32, 'Ny': 32, 'Lx': 1e6, 'Ly': 1e6, 'alpha': 0.5, 'eps': 1e-6, 'case_id': 'C'},\n        # Case D\n        {'Nx': 8, 'Ny': 8, 'Lx': 1e6, 'Ly': 1e6, 'alpha': 1e-3, 'eps': 1e-7, 'case_id': 'D'}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        Nx, Ny, Lx, Ly, alpha, eps = case['Nx'], case['Ny'], case['Lx'], case['Ly'], case['alpha'], case['eps']\n        \n        # Create grid\n        x = np.arange(Nx) * (Lx / Nx)\n        y = np.arange(Ny) * (Ly / Ny)\n        xx, yy = np.meshgrid(x, y)\n\n        # Create spectral operators\n        kxx, kyy, inv_ksq = create_spectral_ops(Nx, Ny, Lx, Ly)\n\n        # Define base velocity field (u0, v0) - common for all cases\n        u0 = 0.08 * np.sin(2 * np.pi * xx / Lx) * np.cos(2 * np.pi * yy / Ly)\n        v0 = -0.05 * np.cos(2 * np.pi * xx / Lx) * np.sin(2 * np.pi * yy / Ly)\n        \n        # Define perturbation velocity field (ub, vb) based on case\n        if case['case_id'] in ['A', 'D']:\n            ub = 0.06 * np.sin(4 * np.pi * xx / Lx) * np.cos(2 * np.pi * yy / Ly) + \\\n                 0.03 * np.cos(2 * np.pi * xx / Lx) * np.sin(6 * np.pi * yy / Ly)\n            vb = 0.02 * np.cos(4 * np.pi * xx / Lx) * np.sin(2 * np.pi * yy / Ly) + \\\n                 0.07 * np.sin(2 * np.pi * xx / Lx) * np.cos(6 * np.pi * yy / Ly)\n        elif case['case_id'] == 'B':\n            Psi0 = 5e3\n            ub = Psi0 * (4 * np.pi / Ly) * np.sin(2 * np.pi * xx / Lx) * np.cos(4 * np.pi * yy / Ly)\n            vb = -Psi0 * (2 * np.pi / Lx) * np.cos(2 * np.pi * xx / Lx) * np.sin(4 * np.pi * yy / Ly)\n        elif case['case_id'] == 'C':\n            Phi0 = 5e3\n            ub = Phi0 * (2 * np.pi / Lx) * np.cos(2 * np.pi * xx / Lx) * np.cos(2 * np.pi * yy / Ly)\n            vb = -Phi0 * (2 * np.pi / Ly) * np.sin(2 * np.pi * xx / Lx) * np.sin(2 * np.pi * yy / Ly)\n\n        # Compute target field\n        uT, vT = project(u0, v0, kxx, kyy, inv_ksq)\n        \n        # Calculate gradients\n        grad_analytic = calculate_analytic_gradient(alpha, ub, vb, Nx, Ny, Lx, Ly, kxx, kyy, inv_ksq)\n        grad_fd = calculate_fd_gradient(alpha, eps, u0, v0, ub, vb, uT, vT, Nx, Ny, Lx, Ly, kxx, kyy, inv_ksq)\n        \n        # Calculate error metric\n        error = np.abs(grad_analytic - grad_fd) / np.maximum(1.0, np.abs(grad_analytic))\n        results.append(error)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "PIML的最终目标之一是从观测数据中发现或标定未知的物理过程，例如次网格尺度的参数化方案。“孪生实验”是验证此类反演问题方法的黄金标准。这项实践  将指导你完成一个完整的孪生实验流程：首先用已知的“真实”参数生成合成数据，然后添加噪声模拟观测，最后通过最小化物理方程残差来反演并恢复模型参数，从而评估PIML方法在存在不确定性情况下的性能。",
            "id": "3807973",
            "problem": "考虑一个计算海洋学中使用的一维示踪剂输运模型，该模型通过守恒定律表示示踪剂浓度的演化。从被动示踪剂的质量守恒出发，长度为 $L$ 的周期性域上的控制方程为\n$$\n\\frac{\\partial C}{\\partial t} + u \\frac{\\partial C}{\\partial x} = \\frac{\\partial}{\\partial x}\\left( K(C_x) \\, \\frac{\\partial C}{\\partial x} \\right),\n$$\n其中 $C(x,t)$ 是示踪剂浓度（单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$），$u$ 是恒定的平流速度（单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$），$K$ 是（未知的）亚网格尺度扩散系数（单位为 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$），且 $C_x \\equiv \\frac{\\partial C}{\\partial x}$。$x \\in [0,L]$ 上的边界条件是周期性的。假设真实的亚网格尺度闭合项形式如下\n$$\nK_{\\mathrm{true}}(C_x) = k_0^{\\mathrm{(true)}} + a^{\\mathrm{(true)}} \\left( \\frac{|C_x|}{G_0} \\right),\n$$\n其中 $k_0^{\\mathrm{(true)}}$ 的单位为 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$，$a^{\\mathrm{(true)}}$ 的单位为 $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$，$G_0$ 是一个固定的梯度尺度（单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-4}$），用于对 $|C_x|$ 进行无量纲化。您将通过使用此闭合项生成合成真值来构建孪生实验，产生带噪声的观测数据，并使用物理信息机器学习（Physics-Informed Machine Learning, PIML）估计闭合参数，其中物理信息机器学习（PIML）定义为一种利用偏微分方程（PDEs）等物理定律来约束模型训练的学习范式。未知参数为 $\\theta = (k_0, a)$，PIML 估计应通过最小化在带噪声观测数据上评估的控制方程的残差平方和来获得。\n\n推导和算法设计的基本依据：\n- 一维空间中被动示踪剂的质量守恒：\n$$\n\\frac{\\partial C}{\\partial t} + \\frac{\\partial}{\\partial x}\\left( u C - K(C_x) \\frac{\\partial C}{\\partial x} \\right) = 0.\n$$\n- 恒定平流速度 $u$ 和均匀网格上的周期性边界条件。\n- 在间距为 $\\Delta x$ 和时间步长为 $\\Delta t$ 的均匀网格上，空间和时间导数的有限差分近似。\n\n您必须在一个完整的、可运行的程序中实现以下步骤：\n1. 定义计算域和初始条件。使用 $L = 1000\\,\\mathrm{m}$，$u = 0.1\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$，$N_x = 64$ 个空间点，以及 $N_t = 400$ 个时间步，时间步长 $\\Delta t = 0.5\\,\\mathrm{s}$（总同化窗口 $T = N_t \\Delta t = 200\\,\\mathrm{s}$）。使用周期性初始条件\n$$\nC(x,0) = A_1 \\sin\\left( \\frac{2\\pi x}{L} \\right) + \\frac{A_1}{2} \\sin\\left( \\frac{4\\pi x}{L} \\right),\n$$\n其中 $A_1 = 1.0\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$。将 $G_0$ 计算为 $|C_x(x,0)|$ 在整个域上的均方根（即 $G_0 = \\sqrt{\\frac{1}{L}\\int_0^L |C_x(x,0)|^2 \\, \\mathrm{d}x}$），使用与您的网格一致的离散近似。\n2. 使用真实的闭合参数 $k_0^{\\mathrm{(true)}} = 10^{-5}\\,\\mathrm{m}^2\\,\\mathrm{s}^{-1}$ 和 $a^{\\mathrm{(true)}} = 5\\times 10^{-6}\\,\\mathrm{m}^2\\,\\mathrm{s}^{-1}$，通过对控制方程进行时间步进，生成合成真值 $C^{\\mathrm{true}}(x,t)$，采用显式时间步进方法：\n$$\nC^{n+1} = C^n + \\Delta t \\left( - u \\, \\partial_x C^n + \\partial_x\\left( K_{\\mathrm{true}}(C_x^n) \\, \\partial_x C^n \\right) \\right),\n$$\n空间导数采用二阶中心差分，并施加周期性边界条件。此处 $C^n$ 表示 $C(x,t_n)$。\n3. 通过添加标准差为 $\\sigma = \\eta \\, \\mathrm{RMS}(C^{\\mathrm{true}})$ 的零均值高斯噪声，生成带噪声的观测数据 $C^{\\mathrm{obs}}(x,t)$，其中 $\\eta$ 是一个无量纲的噪声水平，$\\mathrm{RMS}(C^{\\mathrm{true}})$ 是 $C^{\\mathrm{true}}$ 在时空上的均方根。您必须对所有测试用例使用相同的随机种子以确保可复现性。\n4. 使用 PIML 方法，通过最小化在 $C^{\\mathrm{obs}}$ 上评估的控制方程的均方残差来估计参数 $\\theta = (k_0, a)$：\n$$\nJ(\\theta) = \\left\\langle \\left( \\frac{\\partial C^{\\mathrm{obs}}}{\\partial t} + u \\frac{\\partial C^{\\mathrm{obs}}}{\\partial x} - \\frac{\\partial}{\\partial x}\\left( K_\\theta(C_x^{\\mathrm{obs}}) \\, \\frac{\\partial C^{\\mathrm{obs}}}{\\partial x} \\right) \\right)^2 \\right\\rangle,\n$$\n其中 $K_\\theta(C_x) = k_0 + a \\left( \\frac{|C_x|}{G_0} \\right)$，$\\langle \\cdot \\rangle$ 表示在时空同化窗口上的平均值。对于内部时间层上的 $\\frac{\\partial C^{\\mathrm{obs}}}{\\partial t}$ 使用中心有限差分，对于空间导数使用二阶中心差分。在优化过程中约束 $k_0 \\ge 0$ 和 $a \\ge 0$。优化的初始值设定为 $k_0^{(0)} = 5\\times 10^{-6}\\,\\mathrm{m}^2\\,\\mathrm{s}^{-1}$ 和 $a^{(0)} = 7.5\\times 10^{-6}\\,\\mathrm{m}^2\\,\\mathrm{s}^{-1}$。\n5. 估计出 $\\hat{\\theta} = (\\hat{k}_0, \\hat{a})$ 后，使用相同的数值方法和初始条件，以 $K_{\\hat{\\theta}}$ 重新模拟模型，得到 $C^{\\mathrm{est}}(x,t)$，并计算时空上的归一化均方根误差 (RMSE)：\n$$\n\\mathrm{NRMSE} = \\frac{\\sqrt{\\left\\langle \\left( C^{\\mathrm{est}} - C^{\\mathrm{true}} \\right)^2 \\right\\rangle}}{\\mathrm{RMS}(C^{\\mathrm{true}})}.\n$$\n同时计算相对参数误差\n$$\ne_{k_0} = \\frac{|\\hat{k}_0 - k_0^{\\mathrm{(true)}}|}{k_0^{\\mathrm{(true)}}}, \\quad\ne_a = \\frac{|\\hat{a} - a^{\\mathrm{(true)}}|}{a^{\\mathrm{(true)}}}.\n$$\n所有报告的指标必须是无量纲的。\n测试套件：\n针对以下三种情况运行完整的孪生实验和 PIML 估计流程，这些情况测试了恢复性能的不同方面：\n- 情况 1（理想路径）：$\\eta = 0.00$。\n- 情况 2（中度噪声）：$\\eta = 0.02$。\n- 情况 3（显著噪声边缘情况）：$\\eta = 0.08$。\n最终输出规格：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例对应一个子列表，且没有空格。每个子列表必须按顺序包含三个浮点数 $[e_{k_0}, e_a, \\mathrm{NRMSE}]$，对应相应的情况。例如，输出格式必须是\n$$\n[\\,[e_{k_0}^{(1)},e_a^{(1)},\\mathrm{NRMSE}^{(1)}],[e_{k_0}^{(2)},e_a^{(2)},\\mathrm{NRMSE}^{(2)}],[e_{k_0}^{(3)},e_a^{(3)},\\mathrm{NRMSE}^{(3)}]\\,].\n$$\n所有数值结果必须以十进制浮点数形式打印。输出中不应打印任何物理单位，因为这些指标在构造上是无量纲的。",
            "solution": "问题陈述是有效的。这是一个适定的、有科学依据且计算上可行的问题，属于计算海洋学领域，特别关注使用物理信息机器学习（PIML）方法进行参数估计。其前提与流体动力学的基本原理和标准数值方法一致。所有必要的参数、方程和程序都已提供，以构建一个唯一且可验证的解。\n\n解决方案首先实现一维示踪剂输运模型的数值框架，然后执行孪生实验以测试 PIML 参数恢复算法。\n\n### 1. 模型离散化和数值方法\n\n示踪剂浓度 $C(x, t)$ 的控制平流-扩散方程在长度为 $L$ 的周期域上给出：\n$$\n\\frac{\\partial C}{\\partial t} + u \\frac{\\partial C}{\\partial x} = \\frac{\\partial}{\\partial x}\\left( K(C_x) \\, \\frac{\\partial C}{\\partial x} \\right)\n$$\n域 $x \\in [0, L]$ 被离散化为一个由 $N_x$ 个点组成的均匀网格，间距为 $\\Delta x = L/N_x$，因此 $x_i = i \\Delta x$，$i = 0, 1, \\dots, N_x-1$。时间以恒定的步长 $\\Delta t$ 进行离散化。\n\n空间导数使用二阶中心有限差分进行近似，该方法尊重域的周期性。对于网格函数 $f(x_i) = f_i$，一阶和二阶导数分别为：\n$$\n\\left(\\frac{\\partial f}{\\partial x}\\right)_i \\approx \\frac{f_{i+1} - f_{i-1}}{2 \\Delta x}\n$$\n$$\n\\left(\\frac{\\partial^2 f}{\\partial x^2}\\right)_i \\approx \\frac{f_{i+1} - 2f_i + f_{i-1}}{(\\Delta x)^2}\n$$\n涉及非线性扩散系数的项 $\\frac{\\partial}{\\partial x}\\left( K(C_x) \\frac{\\partial C}{\\partial x} \\right)$，其处理方式是首先在网格点上计算通量项 $F = K(C_x) \\frac{\\partial C}{\\partial x}$，然后对外部导数 $\\frac{\\partial F}{\\partial x}$ 应用中心差分算子。\n\n时间积分使用显式前向欧拉方法进行，与指定的时间步进公式一致：\n$$\nC_i^{n+1} = C_i^n + \\Delta t \\cdot \\mathcal{R}(C^n)_i\n$$\n其中 $\\mathcal{R}(C^n)_i$ 表示在时间层 $n$ 和空间点 $i$ 处评估的 PDE 右侧的离散形式。由于所提供的参数满足平流和扩散的 Courant-Friedrichs-Lewy (CFL) 条件，该显式格式的稳定性得到了保证。\n\n### 2. 合成数据生成\n\n孪生实验需要一个“地面真值”数据集。这是通过使用一组已知的真实参数求解控制 PDE 来生成的。\n\n**初始条件和梯度尺度 $G_0$**：\n模拟从指定的周期性初始条件开始：\n$$\nC(x,0) = A_1 \\sin\\left( \\frac{2\\pi x}{L} \\right) + \\frac{A_1}{2} \\sin\\left( \\frac{4\\pi x}{L} \\right)\n$$\n扩散率模型 $K(C_x) = k_0 + a (|C_x|/G_0)$ 需要一个特征梯度尺度 $G_0$ 进行无量纲化。这被计算为初始浓度梯度 $|C_x(x,0)|$ 在整个域上的均方根。与我们网格一致的离散近似是：\n$$\nG_0 = \\sqrt{\\frac{1}{N_x} \\sum_{i=0}^{N_x-1} \\left| \\left(\\frac{\\partial C}{\\partial x}\\right)_{i, t=0} \\right|^2}\n$$\n\n**真值模拟**：\n使用初始条件 $C(x,0)$、真实参数 $k_0^{\\mathrm{(true)}} = 10^{-5}\\,\\mathrm{m}^2\\,\\mathrm{s}^{-1}$ 和 $a^{\\mathrm{(true)}} = 5\\times 10^{-6}\\,\\mathrm{m}^2\\,\\mathrm{s}^{-1}$，以及计算出的 $G_0$，模型向前积分 $N_t$ 个时间步，以产生真实的时空场 $C^{\\mathrm{true}}(x,t)$。\n\n**带噪声的观测**：\n观测数据 $C^{\\mathrm{obs}}(x,t)$ 是通过向真实场中添加零均值高斯噪声来模拟的。噪声标准差 $\\sigma$ 与真实信号的总体幅度成正比，即 $\\sigma = \\eta \\, \\mathrm{RMS}(C^{\\mathrm{true}})$，其中 $\\eta$ 是噪声水平，$\\mathrm{RMS}(C^{\\mathrm{true}})$ 是 $C^{\\mathrm{true}}$ 在整个时空域上的均方根。固定的随机种子确保了跨测试用例的可复现性。\n\n### 3. 基于 PIML 的参数估计\n\n任务的核心是从带噪声的观测数据 $C^{\\mathrm{obs}}$ 中估计参数 $\\theta = (k_0, a)$。PIML 方法通过最小化观测数据与控制物理定律之间的差异来实现这一点。成本函数 $J(\\theta)$ 是 PDE 的均方残差：\n$$\nJ(\\theta) = \\left\\langle \\left( \\frac{\\partial C^{\\mathrm{obs}}}{\\partial t} + u \\frac{\\partial C^{\\mathrm{obs}}}{\\partial x} - \\frac{\\partial}{\\partial x}\\left( K_\\theta(C_x^{\\mathrm{obs}}) \\, \\frac{\\partial C^{\\mathrm{obs}}}{\\partial x} \\right) \\right)^2 \\right\\rangle\n$$\n通过展开扩散系数项 $K_\\theta$，方括号内的表达式在参数 $k_0$ 和 $a$ 上变为线性：\n$$\n\\text{Residual}(\\theta) = \\left(\\frac{\\partial C^{\\mathrm{obs}}}{\\partial t} + u \\frac{\\partial C^{\\mathrm{obs}}}{\\partial x}\\right) - k_0 \\left(\\frac{\\partial^2 C^{\\mathrm{obs}}}{\\partial x^2}\\right) - a \\left(\\frac{1}{G_0} \\frac{\\partial}{\\partial x}\\left(\\left|\\frac{\\partial C^{\\mathrm{obs}}}{\\partial x}\\right| \\frac{\\partial C^{\\mathrm{obs}}}{\\partial x}\\right)\\right)\n$$\n这可以被表述为一个线性最小二乘问题，$y \\approx k_0 X_1 + a X_2$。\n- 目标向量 $y$ 是由不含未知参数的项计算得出的：$y = \\frac{\\partial C^{\\mathrm{obs}}}{\\partial t} + u \\frac{\\partial C^{\\mathrm{obs}}}{\\partial x}$。\n- 特征向量（或回归系数）$X_1$ 和 $X_2$ 是乘以 $k_0$ 和 $a$ 的项：$X_1 = \\frac{\\partial^2 C^{\\mathrm{obs}}}{\\partial x^2}$ 和 $X_2 = \\frac{1}{G_0} \\frac{\\partial}{\\partial x}\\left(\\left|\\frac{\\partial C^{\\mathrm{obs}}}{\\partial x}\\right| \\frac{\\partial C^{\\mathrm{obs}}}{\\partial x}\\right)$。\n\n$C^{\\mathrm{obs}}$ 的所有导数都使用相同的有限差分格式计算。时间导数在内部时间点（$t=1, \\dots, N_t-1$）上使用中心差分计算，所有空间导数都在这个相同的内部时空网格上进行评估。\n\n优化问题是找到 $(\\hat{k}_0, \\hat{a}) = \\arg\\min_{k_0, a \\ge 0} J(k_0, a)$。这是一个非负最小二乘问题，使用 `scipy.optimize.minimize` 和 `L-BFGS-B` 方法求解，并结合了边界条件 $k_0 \\ge 0$，$a \\ge 0$ 和指定的初始猜测值。\n\n### 4. 结果评估\n\nPIML 估计的性能通过三个指标进行评估。首先，使用估计的参数 $(\\hat{k}_0, \\hat{a})$ 从原始的 $C(x,0)$ 开始进行新的正向模拟，以产生一个估计场 $C^{\\mathrm{est}}(x,t)$。然后，计算以下指标：\n1.  **$k_0$ 的相对误差**：$e_{k_0} = |\\hat{k}_0 - k_0^{\\mathrm{(true)}}| / k_0^{\\mathrm{(true)}}$\n2.  **$a$ 的相对误差**：$e_a = |\\hat{a} - a^{\\mathrm{(true)}}| / a^{\\mathrm{(true)}}$\n3.  **归一化均方根误差 (NRMSE)**：$\\mathrm{NRMSE} = \\sqrt{\\langle(C^{\\mathrm{est}} - C^{\\mathrm{true}})^2\\rangle} / \\mathrm{RMS}(C^{\\mathrm{true}})$\n\n这些无量纲指标分别量化了参数恢复的准确性和已识别模型的预测能力。对每个指定的噪声水平 $\\eta$ 执行整个流程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to run the twin experiment for PIML parameter estimation.\n    \"\"\"\n    # 1. Define computational domain, constants, and parameters\n    L = 1000.0  # Domain length [m]\n    u = 0.1     # Advection velocity [m/s]\n    Nx = 64     # Number of spatial points\n    dt = 0.5    # Time step [s]\n    Nt = 400    # Number of time steps\n    A1 = 1.0    # Initial condition amplitude [kg/m^3]\n    \n    k0_true = 1.0e-5  # True background diffusivity [m^2/s]\n    a_true = 5.0e-6   # True gradient-dependent diffusivity parameter [m^2/s]\n    \n    k0_init = 5.0e-6  # Initial guess for k0 [m^2/s]\n    a_init = 7.5e-6   # Initial guess for a [m^2/s]\n    \n    test_cases_eta = [0.00, 0.02, 0.08] # Noise levels\n    \n    SEED = 42 # Random seed for reproducibility\n\n    # Discretization parameters\n    dx = L / Nx\n    x = np.linspace(0, L, Nx, endpoint=False)\n    \n    # --- Helper functions for numerical derivatives ---\n    def ddx(f):\n        \"\"\"Computes 1st spatial derivative using centered differences.\"\"\"\n        f_plus_1 = np.roll(f, -1, axis=-1)\n        f_minus_1 = np.roll(f, 1, axis=-1)\n        return (f_plus_1 - f_minus_1) / (2 * dx)\n\n    def d2dx2(f):\n        \"\"\"Computes 2nd spatial derivative using centered differences.\"\"\"\n        f_plus_1 = np.roll(f, -1, axis=-1)\n        f_minus_1 = np.roll(f, 1, axis=-1)\n        return (f_plus_1 - 2 * f + f_minus_1) / (dx**2)\n\n    # --- Forward model simulation ---\n    def run_forward_model(C0, k0, a, G0, time_steps):\n        \"\"\"Integrates the advection-diffusion equation forward in time.\"\"\"\n        C_history = [C0.copy()]\n        C = C0.copy()\n        for _ in range(time_steps):\n            Cx = ddx(C)\n            K = k0 + a * np.abs(Cx) / G0\n            \n            advection_term = -u * ddx(C)\n            diffusion_flux = K * Cx\n            diffusion_term = ddx(diffusion_flux)\n            \n            C = C + dt * (advection_term + diffusion_term)\n            C_history.append(C.copy())\n        return np.array(C_history)\n\n    # --- Step 1: Initial condition and G0 calculation ---\n    C0 = A1 * np.sin(2 * np.pi * x / L) + (A1 / 2) * np.sin(4 * np.pi * x / L)\n    Cx0 = ddx(C0)\n    G0 = np.sqrt(np.mean(Cx0**2))\n\n    # --- Step 2: Generate synthetic truth ---\n    C_true = run_forward_model(C0, k0_true, a_true, G0, Nt)\n\n    # --- Step 3: Generate noisy observations for each test case ---\n    rms_C_true = np.sqrt(np.mean(C_true**2))\n    rng = np.random.default_rng(SEED)\n\n    results = []\n\n    for eta in test_cases_eta:\n        noise = rng.normal(0, eta * rms_C_true, size=C_true.shape)\n        C_obs = C_true + noise\n\n        # --- Step 4: Estimate parameters using PIML ---\n        # The cost function is evaluated on interior time steps (1 to Nt-1)\n        # to allow for centered time derivatives.\n        C_obs_interior = C_obs[1:-1, :]  # Shape: (Nt-1, Nx)\n        \n        # Temporal derivative\n        dCdt_obs = (C_obs[2:, :] - C_obs[:-2, :]) / (2 * dt)\n        \n        # Spatial derivatives on the interior time grid\n        dCdx_obs = ddx(C_obs_interior)\n        \n        # Formulate the linear regression problem: y = k0*X1 + a*X2\n        # y = dC/dt + u*dC/dx\n        y_target = (dCdt_obs + u * dCdx_obs).flatten()\n        \n        # X1 = d^2C/dx^2\n        X1_feature = d2dx2(C_obs_interior).flatten()\n        \n        # X2 = (1/G0) * d/dx(|dC/dx|*dC/dx)\n        flux_term_for_X2 = np.abs(dCdx_obs) * dCdx_obs\n        X2_feature = (1 / G0) * ddx(flux_term_for_X2).flatten()\n        \n        # Define the cost function for optimization (mean squared residual)\n        def cost_function(params):\n            k0, a = params\n            residual = y_target - (k0 * X1_feature + a * X2_feature)\n            return np.mean(residual**2)\n\n        # Perform constrained optimization\n        opt_result = minimize(\n            cost_function,\n            x0=[k0_init, a_init],\n            bounds=[(0, None), (0, None)],\n            method='L-BFGS-B'\n        )\n        k0_hat, a_hat = opt_result.x\n        \n        # --- Step 5: Re-simulate with estimated parameters and compute metrics ---\n        C_est = run_forward_model(C0, k0_hat, a_hat, G0, Nt)\n        \n        e_k0 = np.abs(k0_hat - k0_true) / k0_true\n        if a_true == 0:\n            e_a = np.abs(a_hat - a_true) if a_hat==0 else np.inf\n        else:\n            e_a = np.abs(a_hat - a_true) / a_true\n        \n        mse = np.mean((C_est - C_true)**2)\n        nrmse = np.sqrt(mse) / rms_C_true\n        \n        results.append([e_k0, e_a, nrmse])\n\n    # Format the final output string as specified\n    sublist_strs = [f\"[{item[0]},{item[1]},{item[2]}]\" for item in results]\n    final_output = f\"[{','.join(sublist_strs)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}