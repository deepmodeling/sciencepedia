{
    "hands_on_practices": [
        {
            "introduction": "在将机器学习应用于物理系统时，一个核心挑战是确保模型尊重基本的物理原理，而不仅仅是拟合数据。伽利略不变性，即物理定律在所有惯性参考系中形式相同，就是这样一项基本对称性。这项实践将通过一个具体案例，量化一个违反伽利略不变性的学习闭包（learned closure）如何导致虚假的、无物理意义的能量注入，从而深刻揭示将基本对称性作为强归纳偏置（inductive bias）嵌入模型的重要性，以确保其物理一致性和泛化能力 。",
            "id": "3807972",
            "problem": "考虑一个一维、周期性的不可压缩流，它被用作水平均匀洋流的简化模型。在长度为 $L$ 的域上，并采用周期性边界条件，动能（以无量纲单位表示）定义为 $E(t) = \\frac{1}{2} \\int_0^L u(x,t)^2 \\, dx$。从牛顿第二定律和一维空间中的不可压缩 Navier–Stokes 动量方程出发，周期性域的动能收支表明，由任何附加的彻体力或闭合项引起的动能变化率等于速度与该作用力之积的空间积分。在物理信息机器学习（PIML）中，学习到的闭合项可能会引入对绝对速度的显式依赖，而这种依赖不具有伽利略不变性。伽利略变换对应于 $u'(x,t) = u(x,t) + U$，其中 $U$ 是一个恒定的均匀背景速度。对于一个闭合泛函 $C(u,\\partial_x u)$，由该闭合项引入的能量输入定义为 $I(u; C) = \\int_0^L u(x) \\, C(u(x), \\partial_x u(x)) \\, dx$。在均匀参考系平移 $U$ 的作用下，将虚假能量输入定义为 $\\Delta I = I(u+U; C) - I(u; C)$，对于一个伽利略不变的闭合项，该值应为零。在本问题中，您将为一个可能违反伽利略不变性的学习闭合项族计算 $\\Delta I$。\n\n使用以下由系数 $\\alpha$、$\\beta$ 和 $\\gamma$ 参数化的闭合项族：\n$$\nC(u, \\partial_x u) = \\alpha \\, u + \\beta \\, u^3 + \\gamma \\, \\partial_x u.\n$$\n该选择特意将可能非不变的项（$\\alpha u$ 和 $\\beta u^3$）与一个不变的、依赖于梯度的项（$\\gamma \\, \\partial_x u$）混合在一起。均匀平移只影响绝对速度，不影响空间梯度，因此 $\\partial_x (u+U) = \\partial_x u$。\n\n实现一个程序，在给定域长度 $L$、网格大小 $N$、均匀平移 $U$、闭合参数 $(\\alpha, \\beta, \\gamma)$ 和一个给定的定常速度场 $u(x)$ 的条件下，使用离散近似方法数值计算虚假能量输入 $\\Delta I$：\n- 将域表示为 $N$ 个网格点，间距为 $\\Delta x = L/N$，坐标为 $x_j = j \\Delta x$，$j = 0, 1, \\dots, N-1$，并采用周期性边界条件。\n- 使用带周期性环绕的二阶中心差分来近似 $\\partial_x u$：\n$$\n(\\partial_x u)_j \\approx \\frac{u_{j+1} - u_{j-1}}{2 \\, \\Delta x},\n$$\n其中 $u_{-1} \\equiv u_{N-1}$ 且 $u_N \\equiv u_0$。\n- 通过矩形法则（等效于黎曼和）来近似空间积分：\n$$\nI(u; C) \\approx \\sum_{j=0}^{N-1} u_j \\, C(u_j, (\\partial_x u)_j) \\, \\Delta x.\n$$\n- 以无量纲单位计算 $\\Delta I$，结果为浮点数。\n\n全过程使用无量纲单位；无需物理单位。当三角函数中出现角度时，应以弧度为单位进行计算。\n\n您的程序必须运行以下所有测试用例，并按指定格式打印结果。对每个用例，按规定定义 $u(x)$ 并计算 $\\Delta I$。\n\n测试套件：\n- 用例 $1$（通用混合闭合，正弦场，中等平移）：\n  - $L = 2\\pi$，$N = 1024$，$U = 0.5$，$(\\alpha,\\beta,\\gamma) = (0.1, 0.02, -0.05)$，\n  - $u(x) = \\sin(x) + 0.3 \\, \\sin(2x)$。\n- 用例 $2$（仅梯度闭合，应具有伽利略不变性）：\n  - $L = 2\\pi$，$N = 1024$，$U = 0.75$，$(\\alpha,\\beta,\\gamma) = (0, 0, -0.1)$，\n  - $u(x) = \\cos(3x)$。\n- 用例 $3$（零平移基准）：\n  - $L = 2\\pi$，$N = 1024$，$U = 0.0$，$(\\alpha,\\beta,\\gamma) = (0.2, -0.03, 0.0)$，\n  - $u(x) = \\sin(x)$。\n- 用例 $4$（恒定场，纯非不变线性闭合，非零平移）：\n  - $L = 1.0$，$N = 256$，$U = -1.2$，$(\\alpha,\\beta,\\gamma) = (0.5, 0.0, 0.0)$，\n  - 对于所有 $x$，$u(x) = 0.2$。\n- 用例 $5$（粗网格边缘情况，混合闭合）：\n  - $L = 2\\pi$，$N = 4$，$U = 0.3$，$(\\alpha,\\beta,\\gamma) = (0.0, 0.05, -0.02)$，\n  - $u(x) = \\sin(x)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是用例 $i$ 计算出的 $\\Delta I$ 值，表示为无量纲单位的浮点数。",
            "solution": "本问题要求计算在一维流体动力学模型中，针对一个特定的学习闭合项族所产生的虚假能量输入（记为 $\\Delta I$）。当对系统施加一个均匀速度平移 $U$ 时，这种虚假能量源于对伽利略不变性的违背。分析过程将首先定义相关量，然后建立用于近似这些量的数值方法，最后概述为指定测试用例计算 $\\Delta I$ 的算法。\n\n虚假能量输入定义为，由闭合项为平移后的速度场和原始速度场引入的能量输入之差：\n$$\n\\Delta I = I(u+U; C) - I(u; C)\n$$\n其中 $u(x,t)$ 是速度场，$U$ 是一个恒定的均匀平移，$I(v; C)$ 是对于一个通用速度场 $v$ 的能量输入泛函。该泛函由在长度为 $L$ 的周期性域上的积分给出：\n$$\nI(v; C) = \\int_0^L v(x) \\, C(v(x), \\partial_x v(x)) \\, dx\n$$\n闭合泛函 $C(v, \\partial_x v)$ 由一个特定的参数化形式给出：\n$$\nC(v, \\partial_x v) = \\alpha \\, v + \\beta \\, v^3 + \\gamma \\, \\partial_x v\n$$\n其中 $\\alpha$、$\\beta$ 和 $\\gamma$ 是常数系数。均匀平移的一个关键性质是它不影响空间梯度：$\\partial_x (u+U) = \\partial_x u$。\n\n为了数值计算 $\\Delta I$，我们必须将域以及微分和积分算子离散化。域 $[0, L]$ 由 $N$ 个网格点 $x_j = j \\Delta x$ 表示（$j = 0, 1, \\dots, N-1$），其中网格间距为 $\\Delta x = L/N$。连续速度场 $u(x)$ 由其在这些网格点上的值 $u_j = u(x_j)$ 表示。\n\n在每个网格点 $j$ 上的空间导数 $\\partial_x u$ 使用带周期性边界条件的二阶中心差分格式进行近似。其公式为：\n$$\n(\\partial_x u)_j \\approx \\frac{u_{j+1} - u_{j-1}}{2 \\, \\Delta x}\n$$\n周期性意味着索引按模 $N$ 处理，因此 $u_{N} \\equiv u_0$ 且 $u_{-1} \\equiv u_{N-1}$。\n\n积分 $\\int_0^L f(x) \\, dx$ 通过黎曼和（具体地，使用每个子区间左端点的矩形法则）进行近似：\n$$\n\\int_0^L f(x) \\, dx \\approx \\sum_{j=0}^{N-1} f(x_j) \\, \\Delta x\n$$\n\n计算 $\\Delta I$ 的步骤如下：\n\n1.  **计算 $I(u; C)$**：\n    a.  首先，生成离散速度场 $u_j = u(x_j)$，$j=0, \\dots, N-1$。\n    b.  接下来，使用中心差分公式计算所有 $j$ 的离散导数 $(\\partial_x u)_j$。\n    c.  在每个网格点上，计算离散闭合项：$C_j = \\alpha u_j + \\beta u_j^3 + \\gamma (\\partial_x u)_j$。\n    d.  计算离散被积函数，即乘积 $(u \\cdot C)_j = u_j C_j$。\n    e.  最后，使用黎曼和近似积分 $I(u; C)$：\n        $$\n        I(u; C) \\approx \\left( \\sum_{j=0}^{N-1} u_j C_j \\right) \\Delta x\n        $$\n\n2.  **计算 $I(u+U; C)$**：\n    a.  将平移后的速度场定义为 $u'_j = u_j + U$。\n    b.  由于 $U$ 是常数，平移后场的导数 $\\partial_x(u+U)$ 与原始场的导数 $\\partial_x u$ 相同。因此，离散导数向量 $(\\partial_x u')_j$ 与上一步计算的 $(\\partial_x u)_j$ 完全相同。\n    c.  在每个网格点上，计算平移后场的闭合项：$C'_j = C(u'_j, (\\partial_x u)_j) = \\alpha u'_j + \\beta (u'_j)^3 + \\gamma (\\partial_x u)_j$。\n    d.  计算平移情况下的离散被积函数：$(u' \\cdot C')_j = u'_j C'_j$。\n    e.  使用黎曼和近似积分 $I(u+U; C)$：\n        $$\n        I(u+U; C) \\approx \\left( \\sum_{j=0}^{N-1} u'_j C'_j \\right) \\Delta x\n        $$\n\n3.  **计算 $\\Delta I$**：\n    最终结果是两个数值计算积分的差：\n    $$\n    \\Delta I = I_\\text{approx}(u+U; C) - I_\\text{approx}(u; C)\n    $$\n此过程将应用于每个测试用例，使用其特定的参数集（$L, N, U, \\alpha, \\beta, \\gamma$）和速度场 $u(x)$。对于闭合项应具有伽利略不变性（例如，当 $\\alpha=0$ 且 $\\beta=0$ 时）或平移为零（$U=0$）的测试用例，我们预期 $\\Delta I$ 为零，或者是一个由于数值伪影而处于浮点精度量级的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the spurious energy input for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: general mixed closure, sinusoidal field, moderate translation\n        {\n            \"L\": 2 * np.pi, \"N\": 1024, \"U\": 0.5,\n            \"params\": (0.1, 0.02, -0.05), # (alpha, beta, gamma)\n            \"u_func\": lambda x: np.sin(x) + 0.3 * np.sin(2 * x),\n        },\n        # Case 2: gradient-only closure that should be Galilean invariant\n        {\n            \"L\": 2 * np.pi, \"N\": 1024, \"U\": 0.75,\n            \"params\": (0.0, 0.0, -0.1),\n            \"u_func\": lambda x: np.cos(3 * x),\n        },\n        # Case 3: zero translation baseline\n        {\n            \"L\": 2 * np.pi, \"N\": 1024, \"U\": 0.0,\n            \"params\": (0.2, -0.03, 0.0),\n            \"u_func\": lambda x: np.sin(x),\n        },\n        # Case 4: constant field, purely non-invariant linear closure, nonzero translation\n        {\n            \"L\": 1.0, \"N\": 256, \"U\": -1.2,\n            \"params\": (0.5, 0.0, 0.0),\n            \"u_func\": lambda x: 0.2 * np.ones_like(x),\n        },\n        # Case 5: coarse grid edge case, mixed closure\n        {\n            \"L\": 2 * np.pi, \"N\": 4, \"U\": 0.3,\n            \"params\": (0.0, 0.05, -0.02),\n            \"u_func\": lambda x: np.sin(x),\n        },\n    ]\n\n    def compute_energy_input(v, dv_dx, dx, alpha, beta, gamma):\n        \"\"\"\n        Computes the discrete energy input I(v; C).\n        \n        Args:\n            v (np.ndarray): Discrete velocity field.\n            dv_dx (np.ndarray): Discrete spatial derivative of the velocity field.\n            dx (float): Grid spacing.\n            alpha (float): Closure parameter.\n            beta (float): Closure parameter.\n            gamma (float): Closure parameter.\n        \n        Returns:\n            float: The numerically computed energy input.\n        \"\"\"\n        # Closure term C(v, dv/dx) = alpha*v + beta*v^3 + gamma*dv/dx\n        closure_term = alpha * v + beta * v**3 + gamma * dv_dx\n        \n        # Integrand v * C(v, dv/dx)\n        integrand = v * closure_term\n        \n        # Integral via Riemann sum\n        integral = np.sum(integrand) * dx\n        return integral\n\n    results = []\n    for case in test_cases:\n        L, N, U = case[\"L\"], case[\"N\"], case[\"U\"]\n        alpha, beta, gamma = case[\"params\"]\n        u_func = case[\"u_func\"]\n\n        # 1. Set up the discrete domain and initial velocity field\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        u = u_func(x)\n\n        # 2. Compute the derivative of the original velocity field u\n        # np.roll(u, -1) provides u_{j+1}\n        # np.roll(u, 1) provides u_{j-1}\n        du_dx = (np.roll(u, -1) - np.roll(u, 1)) / (2 * dx)\n\n        # 3. Compute I(u; C) for the original field\n        I_u = compute_energy_input(u, du_dx, dx, alpha, beta, gamma)\n\n        # 4. Define the translated field u' = u + U\n        u_prime = u + U\n        # The derivative of u' is the same as u, since d(u+U)/dx = du/dx\n        du_prime_dx = du_dx\n        \n        # 5. Compute I(u+U; C) for the translated field\n        I_u_prime = compute_energy_input(u_prime, du_prime_dx, dx, alpha, beta, gamma)\n        \n        # 6. Calculate the spurious energy input ΔI\n        delta_I = I_u_prime - I_u\n        results.append(delta_I)\n    \n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多先进的物理信息机器学习（PIML）应用，特别是在流体动力学中，要求将整个数值求解器嵌入到基于梯度的优化循环中。这就要求求解器本身是可微分的，以便梯度可以端到端地反向传播。本练习将指导您使用谱方法，构建许多海洋模型中的核心部分——用于确保不可压缩性的压力投影步骤——并将其实现为一个完全可微分的算子 。通过推导并验证一个物理损失函数（physics-informed loss）的解析梯度，您将掌握将复杂的隐式物理约束集成到可学习模型中的关键技术。",
            "id": "3807941",
            "problem": "在周期性边界条件下，实现一个用于压力投影的可微谱泊松求解器，并通过比较解析梯度与有限差分近似，来验证一个物理启发的损失函数相对于一个标量参数的梯度的正确性。\n\n您正在一个大小为 $L_x \\times L_y$、具有 $N_x \\times N_y$ 个网格点的二维周期域上，模拟海洋模型中使用的不可压缩压力投影步骤。设同位网格上的速度场为 $(u, v)$，投影算子 $P$ 通过亥姆霍兹-霍奇分解在周期性边界下去除无旋分量，以强制实现不可压缩性。具体来说，给定一个暂定速度 $(u^\\ast, v^\\ast)$，计算其散度 $g = \\nabla \\cdot (u^\\ast, v^\\ast)$，求解泊松问题\n$$\n\\Delta p = g\n$$\n该问题具有周期性边界条件和对 $p$ 的零均值约束，然后返回投影后的速度\n$$\n(u, v) = (u^\\ast, v^\\ast) - \\nabla p.\n$$\n所有微分算子都将以谱方法实现：二维快速傅里叶变换（FFT）将场 $f(x,y)$ 映射到 $\\hat{f}(k_x, k_y)$，其中谱导数定义为 $\\widehat{\\partial_x f} = i k_x \\hat{f}$，$\\widehat{\\partial_y f} = i k_y \\hat{f}$，拉普拉斯算子满足 $\\widehat{\\Delta f} = - (k_x^2 + k_y^2) \\hat{f}$。为强制零均值，零波数模态 $\\hat{p}(0,0)$ 必须设为零。\n\n考虑一个暂定速度的参数族\n$$\n(u^\\ast(\\alpha), v^\\ast(\\alpha)) = (u_0, v_0) + \\alpha \\, (u_b, v_b),\n$$\n其中 $(u_0, v_0)$ 和 $(u_b, v_b)$ 是固定的、平滑的周期性速度场，$\\alpha \\in \\mathbb{R}$ 是一个标量参数。设投影后的速度为\n$$\n(u(\\alpha), v(\\alpha)) = P\\big(u^\\ast(\\alpha), v^\\ast(\\alpha)\\big).\n$$\n定义一个物理启发的二次损失函数，该函数测量与目标无散场 $(u_T, v_T)$ 的偏差：\n$$\n\\mathcal{L}(\\alpha) = \\frac{1}{2} \\int_0^{L_x} \\int_0^{L_y} \\left( \\left[u(\\alpha) - u_T\\right]^2 + \\left[v(\\alpha) - v_T\\right]^2 \\right) \\, \\mathrm{d}y \\, \\mathrm{d}x.\n$$\n在离散网格上，用单元面积为 $\\Delta A = \\Delta x \\, \\Delta y$ 的黎曼和来近似该积分，其中 $\\Delta x = L_x/N_x$ 且 $\\Delta y = L_y/N_y$。\n\n任务要求：\n1. 使用二维快速傅里叶变换（FFT）及其逆变换（IFFT），在周期性边界条件下实现上述的谱压力投影算子 $P$。\n2. 使用投影速度 $P\\big((u_0, v_0) + \\alpha (u_b, v_b)\\big)$，实现损失函数 $\\mathcal{L}(\\alpha)$ 作为 $\\alpha$ 的函数。\n3. 使用第一性原理推导并实现解析梯度 $\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha$。您的推导必须从 $\\mathcal{L}(\\alpha)$ 的定义和 $P$ 的线性性质出发，并且不得假定任何预封装的自动微分。利用投影是线性的，因此\n$$\nP\\big((u_0, v_0) + \\alpha (u_b, v_b)\\big) = P(u_0, v_0) + \\alpha \\, P(u_b, v_b),\n$$\n从而\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}\\alpha} (u(\\alpha), v(\\alpha)) = P(u_b, v_b).\n$$\n将此与应用于 $\\mathcal{L}(\\alpha)$ 的链式法则相结合，以获得 $\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha$ 关于 $(u(\\alpha)-u_T, v(\\alpha)-v_T)$ 和 $P(u_b, v_b)$ 的显式表达式。\n4. 通过与中心有限差分近似进行比较，验证您的解析梯度的正确性：\n$$\n\\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}\\alpha} \\approx \\frac{\\mathcal{L}(\\alpha + \\varepsilon) - \\mathcal{L}(\\alpha - \\varepsilon)}{2 \\varepsilon},\n$$\n其中 $\\varepsilon$ 是一个小步长。\n5. 所有速度场必须由在 $[0,L_x] \\times [0,L_y]$ 上周期的平滑三角函数模态构成。为确保物理一致性，目标场必须设置为基础场的投影：$(u_T, v_T) = P(u_0, v_0)$。\n\n物理单位：$x$ 和 $y$ 的单位是米， $u$ 和 $v$ 的单位是米/秒，$\\mathcal{L}$ 的单位是 $\\mathrm{m}^4/\\mathrm{s}^2$，$\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha$ 的单位是 $\\mathrm{m}^4/\\mathrm{s}^2$ 因为 $\\alpha$ 是无量纲的。如下文规定，将最终的数值误差报告为无量纲量。\n\n提供一个程序，用于评估以下每个测试案例中解析梯度与有限差分近似之间的相对差异。对于每个案例，计算误差度量\n$$\nE = \\frac{\\left| \\left(\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha\\right)_{\\mathrm{analytic}} - \\left(\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha\\right)_{\\mathrm{FD}} \\right|}{\\max\\left(1, \\left| \\left(\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha\\right)_{\\mathrm{analytic}} \\right|\\right)}.\n$$\n\n测试套件：\n- 案例 A（通用混合基，正常路径）：$N_x = 32$, $N_y = 32$, $L_x = 10^6$ 米, $L_y = 10^6$ 米, $\\alpha = 0.3$, $\\varepsilon = 10^{-6}$。构造\n  - $u_0(x,y) = 0.08 \\, \\sin\\left(2\\pi x/L_x\\right) \\cos\\left(2\\pi y/L_y\\right)$,\n  - $v_0(x,y) = -0.05 \\, \\cos\\left(2\\pi x/L_x\\right) \\sin\\left(2\\pi y/L_y\\right)$,\n  - $(u_b, v_b)$ 为混合场\n    $u_b(x,y) = 0.06 \\, \\sin\\left(4\\pi x/L_x\\right) \\cos\\left(2\\pi y/L_y\\right) + 0.03 \\, \\cos\\left(2\\pi x/L_x\\right) \\sin\\left(6\\pi y/L_y\\right)$,\n    $v_b(x,y) = 0.02 \\, \\cos\\left(4\\pi x/L_x\\right) \\sin\\left(2\\pi y/L_y\\right) + 0.07 \\, \\sin\\left(2\\pi x/L_x\\right) \\cos\\left(6\\pi y/L_y\\right)$。\n- 案例 B（无散基）：$N_x = 32$, $N_y = 32$, $L_x = 10^6$ 米, $L_y = 10^6$ 米, $\\alpha = -0.7$, $\\varepsilon = 10^{-6}$。从流函数 $\\psi(x,y) = \\Psi_0 \\sin\\left(2\\pi x/L_x\\right) \\sin\\left(4\\pi y/L_y\\right)$（其中 $\\Psi_0 = 5\\times 10^3 \\, \\mathrm{m}^2/\\mathrm{s}$）通过 $u_b = \\partial_y \\psi$, $v_b = -\\partial_x \\psi$ 构造 $(u_b, v_b)$。使用与案例 A 相同的 $(u_0,v_0)$。\n- 案例 C（纯梯度基，边缘案例）：$N_x = 32$, $N_y = 32$, $L_x = 10^6$ 米, $L_y = 10^6$ 米, $\\alpha = 0.5$, $\\varepsilon = 10^{-6}$。从势函数 $\\phi(x,y) = \\Phi_0 \\sin\\left(2\\pi x/L_x\\right) \\cos\\left(2\\pi y/L_y\\right)$（其中 $\\Phi_0 = 5\\times 10^3 \\, \\mathrm{m}^2/\\mathrm{s}$）通过 $u_b = \\partial_x \\phi$, $v_b = \\partial_y \\phi$ 构造 $(u_b, v_b)$。使用与案例 A 相同的 $(u_0,v_0)$。\n- 案例 D（小网格分辨率，边界条件压力测试）：$N_x = 8$, $N_y = 8$, $L_x = 10^6$ 米, $L_y = 10^6$ 米, $\\alpha = 10^{-3}$, $\\varepsilon = 10^{-7}$。使用案例 A 中的 $(u_0,v_0)$ 和案例 A 中的混合 $(u_b, v_b)$。\n\n对于所有案例，将目标场 $(u_T, v_T)$ 设置为投影后的基础场 $P(u_0, v_0)$。解析梯度必须从第一性原理计算，而不是通过自动微分。三角函数的角度单位是弧度。\n\n您的程序应生成单行输出，其中包含案例 A、B、C 和 D 的误差，形式为方括号括起来的逗号分隔列表（例如 `[e_A,e_B,e_C,e_D]`），其中每个 $e$ 是表示该案例误差 $E$ 的浮点数，无量纲，并使用指定环境中默认字符串转换可用的完整机器精度打印。",
            "solution": "用户提供的问题陈述经过仔细验证，被确定为科学上合理、适定且完整。所有必要的数据、物理原理和数学公式均已提供，并且与计算流体力学和数值分析中的既定实践相符。该任务要求实现和验证一个可微谱泊松求解器，这是物理启发的机器学习在海洋建模中的一个标准且不平凡的问题。我现在将着手提供一个完整的解决方案。\n\n解决方案的结构如下：\n1. 离散域和谱表示的建立。\n2. 谱压力投影算子 $P$ 的实现。\n3. 解析梯度 $\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha$ 的推导。\n4. 使用有限差分近似的验证过程描述。\n\n**1. 离散域和谱表示**\n\n我们考虑一个二维周期域 $[0, L_x] \\times [0, L_y]$，由一个具有 $N_x \\times N_y$ 个点的均匀网格离散化。网格间距为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。一个物理场 $f(x,y)$ 由其在该网格上的值 $f_{j,k} = f(j\\Delta x, k\\Delta y)$ 表示。\n\n谱方法的核心是二维离散傅里叶变换（DFT），通过快速傅里叶变换（FFT）算法实现。一个场 $f$ 的变换记为 $\\hat{f}$。对于大小为 $N$、长度为 $L$ 的网格，对应的角波数由 $k_n = 2\\pi n / L$ 给出，其中 $n$ 是整数模态数。对于离散网格，波数计算为 $k_m = 2\\pi f_m$，其中 $f_m$ 是标准 FFT 库返回的频率。对于大小为 $N$、间距为 $d$ 的网格，这些频率是 $f_m = m/(N d)$，其中 $m \\in \\{-N/2, \\dots, N/2-1\\}$（或类似范围）。\n\n我们定义与我们域的维度相对应的二维波数网格 $k_x$ 和 $k_y$。令 $\\boldsymbol{k} = (k_x, k_y)$。利用这些，我们可以定义谱微分算子。偏导数的傅里叶变换由下式给出：\n$$\n\\widehat{\\frac{\\partial f}{\\partial x}}(\\boldsymbol{k}) = i k_x \\hat{f}(\\boldsymbol{k}) \\quad \\text{和} \\quad \\widehat{\\frac{\\partial f}{\\partial y}}(\\boldsymbol{k}) = i k_y \\hat{f}(\\boldsymbol{k})\n$$\n其中 $i = \\sqrt{-1}$。因此，向量场 $(u, v)$ 的散度和标量场 $p$ 的拉普拉斯算子在傅里叶空间中表示为：\n$$\n\\widehat{\\nabla \\cdot (u,v)}(\\boldsymbol{k}) = i k_x \\hat{u}(\\boldsymbol{k}) + i k_y \\hat{v}(\\boldsymbol{k})\n$$\n$$\n\\widehat{\\Delta p}(\\boldsymbol{k}) = \\widehat{\\nabla \\cdot \\nabla p}(\\boldsymbol{k}) = (i k_x)(i k_x) \\hat{p}(\\boldsymbol{k}) + (i k_y)(i k_y) \\hat{p}(\\boldsymbol{k}) = -(k_x^2 + k_y^2)\\hat{p}(\\boldsymbol{k}) = -|\\boldsymbol{k}|^2 \\hat{p}(\\boldsymbol{k})\n$$\n\n**2. 谱压力投影算子**\n\n压力投影算子 $P$ 将暂定速度场 $(u^\\ast, v^\\ast)$ 映射到一个无散场 $(u, v)$。这包括三个步骤，可以在傅里叶空间中高效地组合。\n\n首先，我们计算暂定场的散度，$g = \\nabla \\cdot (u^\\ast, v^\\ast)$。在傅里叶空间中，这是：\n$$\n\\hat{g}(\\boldsymbol{k}) = i k_x \\hat{u}^\\ast(\\boldsymbol{k}) + i k_y \\hat{v}^\\ast(\\boldsymbol{k})\n$$\n其次，为压力场 $p$ 求解泊松问题 $\\Delta p = g$。在傅里叶空间中，这个代数方程变为：\n$$\n-|\\boldsymbol{k}|^2 \\hat{p}(\\boldsymbol{k}) = \\hat{g}(\\boldsymbol{k})\n$$\n因此，$\\hat{p}$ 的解是 $\\hat{p}(\\boldsymbol{k}) = -\\hat{g}(\\boldsymbol{k}) / |\\boldsymbol{k}|^2$。对于零波数模态 $\\boldsymbol{k}=(0,0)$，分母 $|\\boldsymbol{k}|^2$ 为零。然而，对于周期场 $(u^\\ast, v^\\ast)$，散度定理确保 $g$ 的均值为零，即 $\\hat{g}(0,0)=0$。通过对压力施加零均值约束，$\\hat{p}(0,0)=0$，问题变得适定。因此，我们定义逆拉普拉斯算子核为：\n$$\n\\widehat{\\Delta^{-1}}(\\boldsymbol{k}) = \\begin{cases} -1/|\\boldsymbol{k}|^2  \\text{if } \\boldsymbol{k} \\neq (0,0) \\\\ 0  \\text{if } \\boldsymbol{k} = (0,0) \\end{cases}\n$$\n所以，$\\hat{p}(\\boldsymbol{k}) = \\widehat{\\Delta^{-1}}(\\boldsymbol{k}) \\hat{g}(\\boldsymbol{k})$。\n\n第三，最终的投影速度通过减去压力梯度得到，$(u, v) = (u^\\ast, v^\\ast) - \\nabla p$。在傅里叶空间中：\n$$\n\\hat{u}(\\boldsymbol{k}) = \\hat{u}^\\ast(\\boldsymbol{k}) - i k_x \\hat{p}(\\boldsymbol{k})\n$$\n$$\n\\hat{v}(\\boldsymbol{k}) = \\hat{v}^\\ast(\\boldsymbol{k}) - i k_y \\hat{p}(\\boldsymbol{k})\n$$\n代入 $\\hat{p}$ 和 $\\hat{g}$ 的表达式，我们可以在傅里叶空间中表达整个投影算子 $P$。令 $(u,v) = P(u^\\ast, v^\\ast)$，则：\n$$\n\\hat{u}(\\boldsymbol{k}) = \\hat{u}^\\ast(\\boldsymbol{k}) - i k_x \\widehat{\\Delta^{-1}}(\\boldsymbol{k}) \\left( i k_x \\hat{u}^\\ast(\\boldsymbol{k}) + i k_y \\hat{v}^\\ast(\\boldsymbol{k}) \\right) = \\left( 1 - \\frac{k_x^2}{|\\boldsymbol{k}|^2} \\right) \\hat{u}^\\ast(\\boldsymbol{k}) - \\frac{k_x k_y}{|\\boldsymbol{k}|^2} \\hat{v}^\\ast(\\boldsymbol{k})\n$$\n$$\n\\hat{v}(\\boldsymbol{k}) = \\hat{v}^\\ast(\\boldsymbol{k}) - i k_y \\widehat{\\Delta^{-1}}(\\boldsymbol{k}) \\left( i k_x \\hat{u}^\\ast(\\boldsymbol{k}) + i k_y \\hat{v}^\\ast(\\boldsymbol{k}) \\right) = -\\frac{k_x k_y}{|\\boldsymbol{k}|^2} \\hat{u}^\\ast(\\boldsymbol{k}) + \\left( 1 - \\frac{k_y^2}{|\\boldsymbol{k}|^2} \\right) \\hat{v}^\\ast(\\boldsymbol{k})\n$$\n这些表达式对 $\\boldsymbol{k} \\neq (0,0)$ 有效。对于 $\\boldsymbol{k}=(0,0)$，$\\hat{u}(0,0)=\\hat{u}^\\ast(0,0)$ 且 $\\hat{v}(0,0)=\\hat{v}^\\ast(0,0)$。实现将遵循此公式，将输入场 $(u^\\ast, v^\\ast)$ 变换到傅里叶空间，应用投影张量，然后变换回来。\n\n**3. 损失函数和解析梯度**\n\n损失函数定义为近似平方误差积分的离散和：\n$$\n\\mathcal{L}(\\alpha) = \\frac{1}{2} \\Delta A \\sum_{j,k} \\left( \\left[u_{j,k}(\\alpha) - u_{T,j,k}\\right]^2 + \\left[v_{j,k}(\\alpha) - v_{T,j,k}\\right]^2 \\right)\n$$\n其中 $\\Delta A = \\Delta x \\Delta y$ 是网格单元的面积。\n\n为了找到解析梯度 $\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha$，我们应用链式法则：\n$$\n\\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}\\alpha} = \\Delta A \\sum_{j,k} \\left( \\left[u_{j,k}(\\alpha) - u_{T,j,k}\\right] \\frac{\\mathrm{d}u_{j,k}}{\\mathrm{d}\\alpha} + \\left[v_{j,k}(\\alpha) - v_{T,j,k}\\right] \\frac{\\mathrm{d}v_{j,k}}{\\mathrm{d}\\alpha} \\right)\n$$\n问题陈述指出投影算子 $P$ 是线性的。参数化速度为 $(u^\\ast(\\alpha), v^\\ast(\\alpha)) = (u_0, v_0) + \\alpha \\, (u_b, v_b)$。应用线性算子 $P$ 得到：\n$$\n(u(\\alpha), v(\\alpha)) = P\\big( (u_0, v_0) + \\alpha(u_b, v_b) \\big) = P(u_0, v_0) + \\alpha P(u_b, v_b)\n$$\n令 $(u_p, v_p) = P(u_0, v_0)$ 和 $(u_{bp}, v_{bp}) = P(u_b, v_b)$。那么 $(u(\\alpha), v(\\alpha)) = (u_p, v_p) + \\alpha(u_{bp}, v_{bp})$。关于 $\\alpha$ 的导数就是：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}\\alpha} (u(\\alpha), v(\\alpha)) = (u_{bp}, v_{bp}) = P(u_b, v_b)\n$$\n目标速度场被设置为 $(u_T, v_T) = P(u_0, v_0) = (u_p, v_p)$。梯度表达式中的误差项变为：\n$$\n(u(\\alpha) - u_T, v(\\alpha) - v_T) = \\left( (u_p + \\alpha u_{bp}) - u_p, (v_p + \\alpha v_{bp}) - v_p \\right) = (\\alpha u_{bp}, \\alpha v_{bp})\n$$\n将这些结果代回 $\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha$ 的表达式中：\n$$\n\\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}\\alpha} = \\Delta A \\sum_{j,k} \\left( (\\alpha u_{bp,j,k}) (u_{bp,j,k}) + (\\alpha v_{bp,j,k}) (v_{bp,j,k}) \\right)\n$$\n提出标量 $\\alpha$ 得到梯度的最终解析表达式：\n$$\n\\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}\\alpha} = \\alpha \\left( \\Delta A \\sum_{j,k} \\left( u_{bp,j,k}^2 + v_{bp,j,k}^2 \\right) \\right)\n$$\n该表达式的实现首先计算投影场 $(u_{bp}, v_{bp}) = P(u_b, v_b)$，然后计算其在网格上平方大小的总和，再乘以 $\\Delta A$ 和 $\\alpha$。\n\n**4. 通过有限差分进行验证**\n\n为了验证解析梯度实现的正确性，我们将其输出与二阶精度的中心有限差分（FD）近似进行比较。对于一个小步长 $\\varepsilon$，FD 梯度为：\n$$\n\\left(\\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}\\alpha}\\right)_{\\mathrm{FD}} = \\frac{\\mathcal{L}(\\alpha + \\varepsilon) - \\mathcal{L}(\\alpha - \\varepsilon)}{2 \\varepsilon}\n$$\n这需要两次计算完整的损失函数。解析梯度和 FD 梯度之间的差异由归一化误差度量 $E$ 量化：\n$$\nE = \\frac{\\left| \\left(\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha\\right)_{\\mathrm{analytic}} - \\left(\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha\\right)_{\\mathrm{FD}} \\right|}{\\max\\left(1, \\left| \\left(\\mathrm{d}\\mathcal{L}/\\mathrm{d}\\alpha\\right)_{\\mathrm{analytic}} \\right|\\right)}\n$$\n分母 $\\max(1, |\\cdot|)$ 提供了鲁棒性，通过在解析梯度为零或接近零时防止除以零，从而从相对误差度量过渡到绝对误差度量。对于正确的实现和足够小的 $\\varepsilon$，这个误差 $E$ 预计会非常小，接近于由 FD 公式的截断误差（与 $\\varepsilon^2$ 成正比）和浮点舍入误差所限制的机器精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n\n    def create_spectral_ops(Nx, Ny, Lx, Ly):\n        \"\"\"\n        Creates wavenumber grids and the inverse Laplacian operator kernel.\n        \"\"\"\n        kx_vec = 2 * np.pi * fft.fftfreq(Nx, d=Lx / Nx)\n        ky_vec = 2 * np.pi * fft.fftfreq(Ny, d=Ly / Ny)\n        kxx, kyy = np.meshgrid(kx_vec, ky_vec, indexing='ij')\n        ksq = kxx**2 + kyy**2\n        \n        # Regularize inverse Laplacian for the zero-wavenumber mode\n        inv_ksq = np.zeros_like(ksq)\n        non_zero_k = ksq != 0\n        inv_ksq[non_zero_k] = 1.0 / ksq[non_zero_k]\n        \n        return kxx, kyy, inv_ksq\n\n    def project(u_star, v_star, kxx, kyy, inv_ksq):\n        \"\"\"\n        Applies the spectral pressure projection operator.\n        \"\"\"\n        # Using ortho norm, no need to scale FFTs\n        u_star_hat = fft.fft2(u_star, norm='ortho')\n        v_star_hat = fft.fft2(v_star, norm='ortho')\n        \n        # Divergence in Fourier space\n        g_hat = 1j * kxx * u_star_hat + 1j * kyy * v_star_hat\n        \n        # Pressure in Fourier space (p_hat = -g_hat * inv_ksq)\n        p_hat = -g_hat * inv_ksq\n        \n        # Subtract pressure gradient in Fourier space\n        u_hat = u_star_hat - 1j * kxx * p_hat\n        v_hat = v_star_hat - 1j * kyy * p_hat\n        \n        # Transform back to physical space\n        u = fft.ifft2(u_hat, norm='ortho').real\n        v = fft.ifft2(v_hat, norm='ortho').real\n        \n        return u, v\n\n    def calculate_loss(alpha, u0, v0, ub, vb, uT, vT, Nx, Ny, Lx, Ly, kxx, kyy, inv_ksq):\n        \"\"\"\n        Computes the loss L(alpha).\n        \"\"\"\n        u_star_alpha = u0 + alpha * ub\n        v_star_alpha = v0 + alpha * vb\n        \n        u_alpha, v_alpha = project(u_star_alpha, v_star_alpha, kxx, kyy, inv_ksq)\n        \n        dA = (Lx / Nx) * (Ly / Ny)\n        loss = 0.5 * np.sum((u_alpha - uT)**2 + (v_alpha - vT)**2) * dA\n        return loss\n\n    def calculate_analytic_gradient(alpha, ub, vb, Nx, Ny, Lx, Ly, kxx, kyy, inv_ksq):\n        \"\"\"\n        Computes the analytic gradient dL/dalpha.\n        \"\"\"\n        ubp, vbp = project(ub, vb, kxx, kyy, inv_ksq)\n        \n        dA = (Lx / Nx) * (Ly / Ny)\n        integral_term = np.sum(ubp**2 + vbp**2) * dA\n        \n        grad_analytic = alpha * integral_term\n        return grad_analytic\n\n    def calculate_fd_gradient(alpha, eps, u0, v0, ub, vb, uT, vT, Nx, Ny, Lx, Ly, kxx, kyy, inv_ksq):\n        \"\"\"\n        Computes the finite-difference gradient.\n        \"\"\"\n        loss_plus = calculate_loss(alpha + eps, u0, v0, ub, vb, uT, vT, Nx, Ny, Lx, Ly, kxx, kyy, inv_ksq)\n        loss_minus = calculate_loss(alpha - eps, u0, v0, ub, vb, uT, vT, Nx, Ny, Lx, Ly, kxx, kyy, inv_ksq)\n        \n        grad_fd = (loss_plus - loss_minus) / (2 * eps)\n        return grad_fd\n\n    test_cases = [\n        # Case A\n        {'Nx': 32, 'Ny': 32, 'Lx': 1e6, 'Ly': 1e6, 'alpha': 0.3, 'eps': 1e-6, 'case_id': 'A'},\n        # Case B\n        {'Nx': 32, 'Ny': 32, 'Lx': 1e6, 'Ly': 1e6, 'alpha': -0.7, 'eps': 1e-6, 'case_id': 'B'},\n        # Case C\n        {'Nx': 32, 'Ny': 32, 'Lx': 1e6, 'Ly': 1e6, 'alpha': 0.5, 'eps': 1e-6, 'case_id': 'C'},\n        # Case D\n        {'Nx': 8, 'Ny': 8, 'Lx': 1e6, 'Ly': 1e6, 'alpha': 1e-3, 'eps': 1e-7, 'case_id': 'D'}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        Nx, Ny, Lx, Ly, alpha, eps = case['Nx'], case['Ny'], case['Lx'], case['Ly'], case['alpha'], case['eps']\n        \n        # Create grid\n        x = np.arange(Nx) * (Lx / Nx)\n        y = np.arange(Ny) * (Ly / Ny)\n        xx, yy = np.meshgrid(x, y, indexing='ij')\n\n        # Create spectral operators\n        kxx, kyy, inv_ksq = create_spectral_ops(Nx, Ny, Lx, Ly)\n\n        # Define base velocity field (u0, v0) - common for all cases\n        u0 = 0.08 * np.sin(2 * np.pi * xx / Lx) * np.cos(2 * np.pi * yy / Ly)\n        v0 = -0.05 * np.cos(2 * np.pi * xx / Lx) * np.sin(2 * np.pi * yy / Ly)\n        \n        # Define perturbation velocity field (ub, vb) based on case\n        if case['case_id'] in ['A', 'D']:\n            ub = 0.06 * np.sin(4 * np.pi * xx / Lx) * np.cos(2 * np.pi * yy / Ly) + \\\n                 0.03 * np.cos(2 * np.pi * xx / Lx) * np.sin(6 * np.pi * yy / Ly)\n            vb = 0.02 * np.cos(4 * np.pi * xx / Lx) * np.sin(2 * np.pi * yy / Ly) + \\\n                 0.07 * np.sin(2 * np.pi * xx / Lx) * np.cos(6 * np.pi * yy / Ly)\n        elif case['case_id'] == 'B':\n            Psi0 = 5e3\n            ub = Psi0 * (4 * np.pi / Ly) * np.sin(2 * np.pi * xx / Lx) * np.cos(4 * np.pi * yy / Ly)\n            vb = -Psi0 * (2 * np.pi / Lx) * np.cos(2 * np.pi * xx / Lx) * np.sin(4 * np.pi * yy / Ly)\n        elif case['case_id'] == 'C':\n            Phi0 = 5e3\n            ub = Phi0 * (2 * np.pi / Lx) * np.cos(2 * np.pi * xx / Lx) * np.cos(2 * np.pi * yy / Ly)\n            vb = -Phi0 * (2 * np.pi / Ly) * np.sin(2 * np.pi * xx / Lx) * np.sin(2 * np.pi * yy / Ly)\n\n        # Compute target field\n        uT, vT = project(u0, v0, kxx, kyy, inv_ksq)\n        \n        # Calculate gradients\n        grad_analytic = calculate_analytic_gradient(alpha, ub, vb, Nx, Ny, Lx, Ly, kxx, kyy, inv_ksq)\n        grad_fd = calculate_fd_gradient(alpha, eps, u0, v0, ub, vb, uT, vT, Nx, Ny, Lx, Ly, kxx, kyy, inv_ksq)\n        \n        # Calculate error metric\n        error = np.abs(grad_analytic - grad_fd) / np.maximum(1.0, np.abs(grad_analytic))\n        results.append(error)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "次网格尺度过程，如湍流混合，是海洋模型不确定性的主要来源，而学习这些过程的有效参数化是 PIML 的一个关键应用。在海洋中，混合过程具有强烈的各向异性——沿等密度面的混合远强于跨等密度面的混合。这项实践将引导您应对这一挑战，设计一个物理启发的损失函数来学习一个简化的各向同性扩散模型，并量化朴素闭包可能引入的非物理伪影（虚假的跨等密度面混合） 。这个练习将迫使您直面模型简化性与物理保真度之间的权衡，这是发展稳健参数化方案的核心议题。",
            "id": "3807990",
            "problem": "考虑一个具有笛卡尔坐标 $(x,z)$ 的二维海洋斑块和一个被动标量场 $C(x,z,t)$，该标量场代表一种物质守恒的示踪剂（例如，守恒温度或位密度）。$C$ 的湍流扩散通量 $\\mathbf{J}$ 通过菲克扩散建模，在连续介质尺度上，它由本构关系 $\\mathbf{J} = -\\mathbf{K}\\,\\nabla C$ 控制，其中 $\\mathbf{K}$ 是扩散率张量。在海洋内部，混合是强各向异性的，沿等密面的混合远大于跨等密面的混合。设等密面单位切向量和单位法向量分别用 $\\mathbf{t}$ 和 $\\mathbf{n}$ 表示，扩散率张量与这些方向对齐，表示为\n$$\n\\mathbf{K} \\;=\\; k_{\\parallel}\\,\\mathbf{t}\\mathbf{t}^{\\top} \\;+\\; k_{\\perp}\\,\\mathbf{n}\\mathbf{n}^{\\top},\n$$\n其中 $k_{\\parallel}$ 是沿等密面扩散率，$k_{\\perp}$ 是跨等密面扩散率。相比之下，一个朴素的各向同性闭合使用一个标量 $k_{\\text{iso}}$ 并设置 $\\mathbf{K}_{\\text{iso}} = k_{\\text{iso}}\\,\\mathbf{I}$，这可能会引入伪跨等密面混合。\n\n将由各向同性闭合引入的伪跨等密面扩散率定义为\n$$\nk_{\\text{spurious}} \\;=\\; k_{\\text{iso}} \\;-\\; k_{\\perp},\n$$\n其单位应为 $\\text{m}^2/\\text{s}$。符号约定是，正的 $k_{\\text{spurious}}$ 表示相对于物理各向异性模型高估了跨等密面混合，而负值表示低估。\n\n为了与物理信息机器学习（PIML）联系起来，假设我们希望通过在示踪剂场的一组单位梯度方向 $\\{\\mathbf{g}_i\\}_{i=1}^{N}$ 上最小化一个物理信息损失，来为各向同性闭合学习一个单一的标量 $k_{\\text{iso}}$。等密面方向是固定的，因此沿 $\\mathbf{t}$ 和 $\\mathbf{n}$ 的投影是相关的。考虑以下损失泛函，它平衡了沿等密面通量的保真度和一个抑制跨等密面通量的惩罚项：\n$$\n\\mathcal{L}(k_{\\text{iso}}) \\;=\\; \\sum_{i=1}^{N} \\left\\| \\left(\\mathbf{t}\\mathbf{t}^{\\top}\\right)\\left( \\mathbf{K}\\,\\nabla C_i \\;-\\; k_{\\text{iso}}\\,\\nabla C_i \\right) \\right\\|^2 \\;+\\; \\lambda \\sum_{i=1}^{N} \\left\\| \\left(\\mathbf{n}\\mathbf{n}^{\\top}\\right)\\left( k_{\\text{iso}}\\,\\nabla C_i \\right) \\right\\|^2,\n$$\n其中 $\\lambda \\ge 0$ 是一个惩罚权重，$\\nabla C_i$ 与 $\\mathbf{g}_i$ 成正比（单位向量已足够，因为只有方向投影进入损失函数）。您必须计算使 $\\mathcal{L}(k_{\\text{iso}})$ 最小化的 $k_{\\text{iso}}$ 值，然后报告相应的 $k_{\\text{spurious}}$。\n\n假设等密面单位切向量 $\\mathbf{t}$ 与 x 轴正方向成 $\\theta$ 角，因此 $\\mathbf{t} = [\\cos\\theta,\\,\\sin\\theta]^{\\top}$ 且 $\\mathbf{n} = [-\\sin\\theta,\\,\\cos\\theta]^{\\top}$，角度以度为单位。对于每个测试用例，集合 $\\{\\mathbf{g}_i\\}$ 由与 x 轴成指定角度 $\\{\\alpha_i\\}$ 的单位向量定义，即 $\\mathbf{g}_i = [\\cos\\alpha_i,\\,\\sin\\alpha_i]^{\\top}$。\n\n您的任务是：\n- 从连续介质菲克扩散关系和与等密面对齐的各向异性张量出发，推导跨等密面通量的表达式，并用 $k_{\\text{iso}}$ 和 $k_{\\perp}$ 定义 $k_{\\text{spurious}}$。\n- 使用给定的 $\\{\\mathbf{g}_i\\}$、$\\mathbf{t}$、$\\mathbf{n}$、$k_{\\parallel}$、$k_{\\perp}$ 和 $\\lambda$，为标量 $k_{\\text{iso}}$ 构建并最小化物理信息损失 $\\mathcal{L}(k_{\\text{iso}})$，除了已陈述的物理定律和定义外，不使用任何捷径。\n- 计算并报告三种闭合的 $k_{\\text{spurious}}$：\n  1. 朴素平均：$k_{\\text{iso}}^{\\text{mean}} = \\dfrac{k_{\\parallel} + k_{\\perp}}{2}$。\n  2. 朴素平行：$k_{\\text{iso}}^{\\text{parallel}} = k_{\\parallel}$。\n  3. 物理信息：对于给定的 $\\lambda$ 和 $\\{\\mathbf{g}_i\\}$，使 $\\mathcal{L}(k_{\\text{iso}})$ 最小化的 $k_{\\text{iso}}^{\\text{phys}}$。\n\n所有扩散率必须以 $\\text{m}^2/\\text{s}$ 为单位表示。角度 $\\theta$ 和 $\\alpha_i$ 必须以度为单位解释。\n\n测试套件：\n- 案例 A（常规“理想路径”各向异性）：$k_{\\parallel} = 10^{-2}\\,\\text{m}^2/\\text{s}$，$k_{\\perp} = 10^{-5}\\,\\text{m}^2/\\text{s}$，$\\theta = 30^{\\circ}$，$\\lambda = 1$，以及梯度角 $\\{\\alpha_i\\} = \\{0^{\\circ}, 30^{\\circ}, 60^{\\circ}, 90^{\\circ}, 120^{\\circ}\\}$。\n- 案例 B（边界各向同性）：$k_{\\parallel} = 10^{-5}\\,\\text{m}^2/\\text{s}$，$k_{\\perp} = 10^{-5}\\,\\text{m}^2/\\text{s}$，$\\theta = 45^{\\circ}$，$\\lambda = 0.5$，以及梯度角 $\\{\\alpha_i\\} = \\{15^{\\circ}, 45^{\\circ}, 75^{\\circ}, 105^{\\circ}\\}$。\n- 案例 C（极端各向异性）：$k_{\\parallel} = 1\\,\\text{m}^2/\\text{s}$，$k_{\\perp} = 10^{-6}\\,\\text{m}^2/\\text{s}$，$\\theta = 10^{\\circ}$，$\\lambda = 10$，以及梯度角 $\\{\\alpha_i\\} = \\{-10^{\\circ}, 10^{\\circ}, 30^{\\circ}, 50^{\\circ}\\}$。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素本身也是一个包含三个浮点数的列表，代表该测试用例的 $[k_{\\text{spurious}}^{\\text{mean}}, k_{\\text{spurious}}^{\\text{parallel}}, k_{\\text{spurious}}^{\\text{phys}}]$ 值。输出不应包含任何空格。例如，最终输出的格式应为 `[[x1,y1,z1],[x2,y2,z2],[x3,y3,z3]]`。",
            "solution": "问题陈述已经过仔细验证，并被确定为具有科学依据、良定且客观的。它在计算海洋学和物理信息机器学习领域提出了一个可形式化的问题。所有必要的参数和定义均已提供，不存在矛盾或歧义。因此，我们可以进行完整的求解。\n\n问题的核心是确定一个标量各向同性扩散率 $k_{\\text{iso}}$，使其在特定的、具有物理动机的意义上最佳地近似一个各向异性扩散过程。这是通过最小化一个损失泛函 $\\mathcal{L}(k_{\\text{iso}})$ 来实现的。我们将首先推导最优 $k_{\\text{iso}}$ 的表达式，然后用它来计算指定测试用例的伪跨等密面扩散率 $k_{\\text{spurious}}$。\n\n首先，我们确认伪跨等密面扩散率的定义。湍流通量由菲克定律给出，$\\mathbf{J} = -\\mathbf{K}\\,\\nabla C$。跨等密面通量 $J_{\\perp}$ 是该通量在垂直于等密面方向上的分量，由 $\\mathbf{J}$ 在单位法向量 $\\mathbf{n}$ 上的投影给出：\n$$\nJ_{\\perp} = \\mathbf{J} \\cdot \\mathbf{n} = (-\\mathbf{K}\\,\\nabla C) \\cdot \\mathbf{n}\n$$\n对于各向异性张量 $\\mathbf{K} = k_{\\parallel}\\,\\mathbf{t}\\mathbf{t}^{\\top} + k_{\\perp}\\,\\mathbf{n}\\mathbf{n}^{\\top}$，并利用 $\\mathbf{t}$ 和 $\\mathbf{n}$ 的标准正交性（即 $\\mathbf{t} \\cdot \\mathbf{n} = 0$ 和 $\\mathbf{n} \\cdot \\mathbf{n} = 1$），我们有：\n$$\n\\mathbf{K}\\mathbf{n} = (k_{\\parallel}\\,\\mathbf{t}\\mathbf{t}^{\\top} + k_{\\perp}\\,\\mathbf{n}\\mathbf{n}^{\\top})\\mathbf{n} = k_{\\parallel}\\mathbf{t}(\\mathbf{t}\\cdot\\mathbf{n}) + k_{\\perp}\\mathbf{n}(\\mathbf{n}\\cdot\\mathbf{n}) = k_{\\perp}\\mathbf{n}\n$$\n因此，各向异性模型的跨等密面通量为 $J_{\\perp} = -(k_{\\perp}\\mathbf{n}) \\cdot \\nabla C = -k_{\\perp}(\\mathbf{n} \\cdot \\nabla C)$。这证实了 $k_{\\perp}$ 是物理跨等密面扩散率。对于一个各向同性模型，$\\mathbf{K}_{\\text{iso}} = k_{\\text{iso}}\\mathbf{I}$，跨等密面通量为 $J_{\\perp, \\text{iso}} = (-k_{\\text{iso}}\\mathbf{I}\\,\\nabla C) \\cdot \\mathbf{n} = -k_{\\text{iso}}(\\mathbf{n} \\cdot \\nabla C)$。有效跨等密面扩散率为 $k_{\\text{iso}}$。因此，伪跨等密面扩散率被正确地定义为差值：\n$$\nk_{\\text{spurious}} = k_{\\text{iso}} - k_{\\perp}\n$$\n\n接下来，我们最小化损失泛函 $\\mathcal{L}(k_{\\text{iso}})$ 以找到物理信息闭合 $k_{\\text{iso}}^{\\text{phys}}$。损失为：\n$$\n\\mathcal{L}(k_{\\text{iso}}) = \\sum_{i=1}^{N} \\left\\| \\left(\\mathbf{t}\\mathbf{t}^{\\top}\\right)\\left( \\mathbf{K}\\,\\mathbf{g}_i - k_{\\text{iso}}\\,\\mathbf{g}_i \\right) \\right\\|^2 + \\lambda \\sum_{i=1}^{N} \\left\\| \\left(\\mathbf{n}\\mathbf{n}^{\\top}\\right)\\left( k_{\\text{iso}}\\,\\mathbf{g}_i \\right) \\right\\|^2\n$$\n其中我们用单位梯度向量 $\\mathbf{g}_i$ 代替了 $\\nabla C_i$。算子 $\\mathbf{t}\\mathbf{t}^{\\top}$ 和 $\\mathbf{n}\\mathbf{n}^{\\top}$ 是投影算子。对于任意向量 $\\mathbf{v}$，$\\|\\left(\\mathbf{t}\\mathbf{t}^{\\top}\\right)\\mathbf{v}\\|^2 = (\\mathbf{t}\\cdot\\mathbf{v})^2$ 且 $\\|\\left(\\mathbf{n}\\mathbf{n}^{\\top}\\right)\\mathbf{v}\\|^2 = (\\mathbf{n}\\cdot\\mathbf{v})^2$，因为 $\\mathbf{t}$ 和 $\\mathbf{n}$ 是单位向量。应用此属性：\n$$\n\\mathcal{L}(k_{\\text{iso}}) = \\sum_{i=1}^{N} \\left( \\mathbf{t} \\cdot (\\mathbf{K}\\mathbf{g}_i - k_{\\text{iso}}\\mathbf{g}_i) \\right)^2 + \\lambda \\sum_{i=1}^{N} \\left( \\mathbf{n} \\cdot (k_{\\text{iso}}\\mathbf{g}_i) \\right)^2\n$$\n$\\mathbf{K}\\mathbf{g}_i$ 在 $\\mathbf{t}$ 上的投影是 $\\mathbf{t} \\cdot (\\mathbf{K}\\mathbf{g}_i) = \\mathbf{t}^{\\top}\\mathbf{K}\\mathbf{g}_i$。代入 $\\mathbf{K}$ 的定义并利用标准正交性：\n$$\n\\mathbf{t}^{\\top}\\mathbf{K}\\mathbf{g}_i = \\mathbf{t}^{\\top}(k_{\\parallel}\\mathbf{t}\\mathbf{t}^{\\top} + k_{\\perp}\\mathbf{n}\\mathbf{n}^{\\top})\\mathbf{g}_i = k_{\\parallel}(\\mathbf{t}^{\\top}\\mathbf{t})(\\mathbf{t}^{\\top}\\mathbf{g}_i) + k_{\\perp}(\\mathbf{t}^{\\top}\\mathbf{n})(\\mathbf{n}^{\\top}\\mathbf{g}_i) = k_{\\parallel}(\\mathbf{t}\\cdot\\mathbf{g}_i)\n$$\n将此代回损失泛函：\n$$\n\\mathcal{L}(k_{\\text{iso}}) = \\sum_{i=1}^{N} \\left( k_{\\parallel}(\\mathbf{t}\\cdot\\mathbf{g}_i) - k_{\\text{iso}}(\\mathbf{t}\\cdot\\mathbf{g}_i) \\right)^2 + \\lambda \\sum_{i=1}^{N} k_{\\text{iso}}^2 (\\mathbf{n}\\cdot\\mathbf{g}_i)^2\n$$\n我们可以将各项因子分解出来，以揭示对 $k_{\\text{iso}}$ 的二次依赖关系：\n$$\n\\mathcal{L}(k_{\\text{iso}}) = (k_{\\parallel} - k_{\\text{iso}})^2 \\sum_{i=1}^{N} (\\mathbf{t}\\cdot\\mathbf{g}_i)^2 + \\lambda k_{\\text{iso}}^2 \\sum_{i=1}^{N} (\\mathbf{n}\\cdot\\mathbf{g}_i)^2\n$$\n为了找到最小值，我们对 $k_{\\text{iso}}$ 求导并将结果设为零：\n$$\n\\frac{d\\mathcal{L}}{dk_{\\text{iso}}} = -2(k_{\\parallel} - k_{\\text{iso}}) \\sum_{i=1}^{N} (\\mathbf{t}\\cdot\\mathbf{g}_i)^2 + 2\\lambda k_{\\text{iso}} \\sum_{i=1}^{N} (\\mathbf{n}\\cdot\\mathbf{g}_i)^2 = 0\n$$\n求解 $k_{\\text{iso}}$ 得到最优值 $k_{\\text{iso}}^{\\text{phys}}$：\n$$\nk_{\\text{iso}} \\left( \\sum_{i=1}^{N} (\\mathbf{t}\\cdot\\mathbf{g}_i)^2 + \\lambda \\sum_{i=1}^{N} (\\mathbf{n}\\cdot\\mathbf{g}_i)^2 \\right) = k_{\\parallel} \\sum_{i=1}^{N} (\\mathbf{t}\\cdot\\mathbf{g}_i)^2\n$$\n$$\nk_{\\text{iso}}^{\\text{phys}} = \\frac{k_{\\parallel} \\sum_{i=1}^{N} (\\mathbf{t}\\cdot\\mathbf{g}_i)^2}{\\sum_{i=1}^{N} (\\mathbf{t}\\cdot\\mathbf{g}_i)^2 + \\lambda \\sum_{i=1}^{N} (\\mathbf{n}\\cdot\\mathbf{g}_i)^2}\n$$\n点积使用角度定义计算：$\\mathbf{t} = [\\cos\\theta, \\sin\\theta]^{\\top}$ 和 $\\mathbf{g}_i = [\\cos\\alpha_i, \\sin\\alpha_i]^{\\top}$。它们的点积是 $\\mathbf{t}\\cdot\\mathbf{g}_i = \\cos\\theta\\cos\\alpha_i + \\sin\\theta\\sin\\alpha_i = \\cos(\\theta - \\alpha_i)$。类似地，$\\mathbf{n}\\cdot\\mathbf{g}_i = -\\sin\\theta\\cos\\alpha_i + \\cos\\theta\\sin\\alpha_i = \\sin(\\alpha_i - \\theta) = -\\sin(\\theta-\\alpha_i)$。\n因此，$(\\mathbf{t}\\cdot\\mathbf{g}_i)^2 = \\cos^2(\\theta - \\alpha_i)$ 且 $(\\mathbf{n}\\cdot\\mathbf{g}_i)^2 = \\sin^2(\\theta - \\alpha_i)$。最终表达式为：\n$$\nk_{\\text{iso}}^{\\text{phys}} = \\frac{k_{\\parallel} \\sum_{i=1}^{N} \\cos^2(\\theta - \\alpha_i)}{\\sum_{i=1}^{N} \\cos^2(\\theta - \\alpha_i) + \\lambda \\sum_{i=1}^{N} \\sin^2(\\theta - \\alpha_i)}\n$$\n\n我们现在总结三种所需闭合的 $k_{\\text{spurious}}$ 表达式：\n1.  **朴素平均 (Naive-mean)：** $k_{\\text{iso}}^{\\text{mean}} = \\frac{k_{\\parallel} + k_{\\perp}}{2}$。\n    $$\n    k_{\\text{spurious}}^{\\text{mean}} = \\frac{k_{\\parallel} + k_{\\perp}}{2} - k_{\\perp} = \\frac{k_{\\parallel} - k_{\\perp}}{2}\n    $$\n2.  **朴素平行 (Naive-parallel)：** $k_{\\text{iso}}^{\\text{parallel}} = k_{\\parallel}$。\n    $$\n    k_{\\text{spurious}}^{\\text{parallel}} = k_{\\parallel} - k_{\\perp}\n    $$\n3.  **物理信息 (Physics-informed)：** $k_{\\text{iso}}^{\\text{phys}}$ 由推导出的公式给出。\n    $$\n    k_{\\text{spurious}}^{\\text{phys}} = k_{\\text{iso}}^{\\text{phys}} - k_{\\perp}\n    $$\n将实施这些公式以求解给定的测试用例。在计算中，所有角度都必须从度转换为弧度。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the spurious diapycnal diffusivity for three different closures \n    across a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: General anisotropy\n        {\n            \"k_parallel\": 1e-2, \n            \"k_perp\": 1e-5, \n            \"theta_deg\": 30.0, \n            \"lambda_\": 1.0, \n            \"alpha_i_deg\": [0.0, 30.0, 60.0, 90.0, 120.0]\n        },\n        # Case B: Boundary isotropy\n        {\n            \"k_parallel\": 1e-5, \n            \"k_perp\": 1e-5, \n            \"theta_deg\": 45.0, \n            \"lambda_\": 0.5, \n            \"alpha_i_deg\": [15.0, 45.0, 75.0, 105.0]\n        },\n        # Case C: Extreme anisotropy\n        {\n            \"k_parallel\": 1.0, \n            \"k_perp\": 1e-6, \n            \"theta_deg\": 10.0, \n            \"lambda_\": 10.0, \n            \"alpha_i_deg\": [-10.0, 10.0, 30.0, 50.0]\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        k_parallel = case[\"k_parallel\"]\n        k_perp = case[\"k_perp\"]\n        theta_deg = case[\"theta_deg\"]\n        lambda_ = case[\"lambda_\"]\n        alpha_i_deg = np.array(case[\"alpha_i_deg\"])\n\n        # 1. Naive-mean closure\n        k_spurious_mean = (k_parallel - k_perp) / 2.0\n\n        # 2. Naive-parallel closure\n        k_spurious_parallel = k_parallel - k_perp\n\n        # 3. Physics-informed closure\n        # Convert angles to radians for trigonometric functions\n        theta_rad = np.deg2rad(theta_deg)\n        alpha_i_rad = np.deg2rad(alpha_i_deg)\n\n        # Calculate angle differences\n        angle_diffs = theta_rad - alpha_i_rad\n\n        # Calculate the sums required for the k_iso_phys formula\n        sum_cos_sq = np.sum(np.cos(angle_diffs)**2)\n        # We can use the identity sin^2(x) + cos^2(x) = 1\n        # Sum of sin^2 = N - Sum of cos^2, where N is the number of gradients\n        N = len(alpha_i_rad)\n        sum_sin_sq = N - sum_cos_sq\n        \n        # Calculate k_iso_phys\n        numerator = k_parallel * sum_cos_sq\n        denominator = sum_cos_sq + lambda_ * sum_sin_sq\n        \n        # Handle potential division by zero, although not expected from problem setup\n        if denominator == 0:\n             # This would imply all gradients are perfectly aligned with isopycnals,\n             # making the penalty term irrelevant. k_iso would be k_parallel.\n            k_iso_phys = k_parallel\n        else:\n            k_iso_phys = numerator / denominator\n\n        k_spurious_phys = k_iso_phys - k_perp\n        \n        case_results = [k_spurious_mean, k_spurious_parallel, k_spurious_phys]\n        results.append(case_results)\n\n    # Format the output string to match the exact requirement:\n    # \"[[r1,r2,r3],[r4,r5,r6]]\" with no spaces.\n    # The default str() for a list includes spaces, so they must be removed.\n    result_strings = [str(r).replace(\" \", \"\") for r in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}