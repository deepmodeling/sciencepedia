{
    "hands_on_practices": [
        {
            "introduction": "体积输运是海洋环流研究中的一个基本量，其定义为速度在特定截面上的面积分。在计算海洋学中，我们通常处理的是离散网格上的速度场数据，因此需要精确的数值积分方法来估算输运量。本练习  将指导您实践一种常用的数值方法——梯形法则，并处理真实世界模型中常见的复杂情况，如不规则网格、陆地掩码和部分单元格。",
            "id": "3787361",
            "problem": "在纬度为 $\\phi$ 的海盆上，一个直线剖面承载着一个经向速度场 $v(x,z)$，单位为 $\\mathrm{m/s}$。该速度场在二维节点网格 $\\{x_i\\}_{i=0}^{N_x-1}$ 和 $\\{z_k\\}_{k=0}^{N_z-1}$ 上采样，其中 $x$ 是以度为单位的经度，$z$ 是以米为单位的深度（垂直坐标向下为正）。穿过该剖面的连续体积输运是速度的面积分，\n$$\nT = \\int_{x_{\\min}}^{x_{\\max}} \\int_{z_{\\min}}^{z_{\\max}} v(x,z) \\,\\mathrm{d}x\\,\\mathrm{d}z,\n$$\n以 Sverdrup（斯维尔德鲁普 (Sv)）为单位表示，其中 $1$ Sverdrup 等于 $10^6$ $\\mathrm{m^3/s}$。在沿纬度圈的球面几何中，纬向线元为 $\\mathrm{d}x = R \\cos\\phi \\,\\mathrm{d}\\lambda$，其中 $R$ 是地球半径，$\\lambda$ 是以弧度为单位的经度。\n\n您将获得以下离散输入：\n- 一个以度为单位的纬度 $\\phi$。\n- 一个以度为单位的经度节点数组 $X = [x_0, x_1, \\dots, x_{N_x-1}]$。\n- 一个以米为单位的深度节点数组 $Z = [z_0, z_1, \\dots, z_{N_z-1}]$。\n- 一个经向速度数组 $V \\in \\mathbb{R}^{N_x \\times N_z}$，其中 $V[i,k] = v(x_i,z_k)$，单位为 $\\mathrm{m/s}$。\n- 一个陆海掩码数组 $M \\in \\{0,1\\}^{N_x \\times N_z}$，对于节点 $(x_i,z_k)$，海洋为 $M[i,k] = 1$，陆地为 $M[i,k] = 0$。\n- 一个部分单元格分数数组 $H \\in [0,1]^{(N_x-1) \\times (N_z-1)}$，为每个矩形单元格 $\\big([x_i,x_{i+1}] \\times [z_k,z_{k+1}]\\big)$ 定义，表示该单元格的名义面积中为湿润区域（例如，靠近地形的底部部分单元格）的比例。\n\n您的任务是通过在 $x$ 和 $z$ 上应用带有掩码和部分单元格的二维复合梯形法则，来计算穿过该剖面的总体积输运 $T$。具体来说：\n- 使用 $\\Delta x_i = R \\cos\\phi \\,\\Delta\\lambda_i$ 将经度间距转换为米，其中 $\\Delta\\lambda_i = (x_{i+1}-x_i)\\times\\pi/180$ 且 $R = 6{,}371{,}000$ $\\mathrm{m}$。\n- 计算以米为单位的垂直间距 $\\Delta z_k = z_{k+1}-z_k$。\n- 对于每个单元格 $(i,k)$，通过对四个角节点值应用掩码后的平均值来近似单元格的平均速度，即\n$$\n\\bar{v}_{i,k} = \\frac{1}{4}\\Big[V[i,k]\\,M[i,k] + V[i+1,k]\\,M[i+1,k] + V[i,k+1]\\,M[i,k+1] + V[i+1,k+1]\\,M[i+1,k+1]\\Big]。\n$$\n- 湿润单元格面积为 $A_{i,k} = \\Delta x_i \\,\\Delta z_k \\, H[i,k]$，因此单元格的输运贡献为 $A_{i,k}\\,\\bar{v}_{i,k}$。\n- 对所有单元格求和以获得 $T$（单位为 $\\mathrm{m^3/s}$），然后除以 $10^6$ 转换为 Sverdrup。\n\n角度必须按规定以度为单位处理。所有输出必须以 Sverdrup (Sv) 为单位。将每次输运结果四舍五入到 $6$ 位小数。\n\n请实现一个程序，对以下四个案例的测试套件执行这些步骤：\n\n- 案例 1（正常路径，混合间距、掩码、部分单元格）：\n  - $\\phi = 30$\n  - $X = [10.0, 10.5, 11.0, 12.0]$\n  - $Z = [0.0, 500.0, 1500.0]$\n  - $V = \\begin{bmatrix}\n  0.20  0.15  0.05\\\\\n  0.25  0.10  0.00\\\\\n  0.30  0.12  -0.02\\\\\n  0.28  0.11  -0.05\n  \\end{bmatrix}$\n  - $M = \\begin{bmatrix}\n  1  1  1\\\\\n  1  1  1\\\\\n  1  1  0\\\\\n  1  1  1\n  \\end{bmatrix}$\n  - $H = \\begin{bmatrix}\n  1.0  0.6\\\\\n  1.0  1.0\\\\\n  1.0  0.8\n  \\end{bmatrix}$\n\n- 案例 2（全陆地掩码导致零输运）：\n  - $\\phi = 45$\n  - $X = [0.0, 1.0, 2.0]$\n  - $Z = [0.0, 1000.0, 2000.0]$\n  - $V = \\begin{bmatrix}\n  0.10  0.05  -0.02\\\\\n  0.12  0.06  -0.01\\\\\n  0.11  0.04  0.00\n  \\end{bmatrix}$\n  - $M = \\begin{bmatrix}\n  0  0  0\\\\\n  0  0  0\\\\\n  0  0  0\n  \\end{bmatrix}$\n  - $H = \\begin{bmatrix}\n  1.0  1.0\\\\\n  1.0  1.0\n  \\end{bmatrix}$\n\n- 案例 3（单垂直层，恒定速度）：\n  - $\\phi = 0$\n  - $X = [100.0, 100.25, 101.0]$\n  - $Z = [0.0, 300.0]$\n  - $V = \\begin{bmatrix}\n  0.10  0.10\\\\\n  0.10  0.10\\\\\n  0.10  0.10\n  \\end{bmatrix}$\n  - $M = \\begin{bmatrix}\n  1  1\\\\\n  1  1\\\\\n  1  1\n  \\end{bmatrix}$\n  - $H = \\begin{bmatrix}\n  1.0\\\\\n  1.0\n  \\end{bmatrix}$\n\n- 案例 4（高纬度，非均匀间距，部分底部单元格）：\n  - $\\phi = 70$\n  - $X = [0.0, 2.0, 4.0, 8.0]$\n  - $Z = [0.0, 400.0, 1200.0, 2000.0]$\n  - $V = \\begin{bmatrix}\n  0.05  0.02  -0.01  -0.03\\\\\n  0.07  0.03  0.00  -0.02\\\\\n  0.08  0.04  0.01  -0.01\\\\\n  0.06  0.02  -0.02  -0.04\n  \\end{bmatrix}$\n  - $M = \\begin{bmatrix}\n  1  1  1  1\\\\\n  1  1  1  1\\\\\n  1  1  1  1\\\\\n  1  1  1  0\n  \\end{bmatrix}$\n  - $H = \\begin{bmatrix}\n  1.0  1.0  0.7\\\\\n  1.0  0.9  0.5\\\\\n  1.0  1.0  1.0\n  \\end{bmatrix}$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[t_1,t_2,t_3,t_4]$，其中每个 $t_i$ 是计算出的以 Sv 为单位的输运量，四舍五入到 $6$ 位小数。",
            "solution": "该问题是有效的。这是一个在计算物理海洋学领域中适定且具有科学依据的问题，没有任何指定的无效缺陷。任务是使用指定的数值积分方案计算穿过一个直线海洋剖面的经向体积输运。\n\n穿过一个剖面的体积输运 $T$ 的连续公式由垂直于该剖面的速度分量的面积分给出。对于沿纬向剖面的经向速度场 $v(x,z)$，公式为：\n$$\nT = \\int_{x_{\\min}}^{x_{\\max}} \\int_{z_{\\min}}^{z_{\\max}} v(x,z) \\,\\mathrm{d}A\n$$\n其中 $\\mathrm{d}A = \\mathrm{d}x\\,\\mathrm{d}z$ 是微分面积元。坐标 $x$ 代表以米为单位的纬向距离，$z$ 代表以米为单位的深度。速度 $v(x,z)$ 的单位是 $\\mathrm{m/s}$，因此输运 $T$ 的单位是 $\\mathrm{m^3/s}$。\n\n问题在离散节点集上提供了速度场和网格，需要对积分进行数值近似。区域被离散化为网格单元。总输运 $T$ 是每个单元格的输运贡献 $T_{i,k}$ 之和：\n$$\nT \\approx \\sum_{i=0}^{N_x-2} \\sum_{k=0}^{N_z-2} T_{i,k}\n$$\n其中 $i$ 是纬向网格单元的索引，$k$ 是垂直网格单元的索引。通过单个单元格 $(i,k)$ 的输运是其有效湿润面积 $A_{i,k}$ 与单元格平均速度 $\\bar{v}_{i,k}$ 的乘积：\n$$\nT_{i,k} = A_{i,k} \\cdot \\bar{v}_{i,k}\n$$\n计算过程包括确定每个单元格的 $A_{i,k}$ 和 $\\bar{v}_{i,k}$，然后将它们的乘积求和。\n\n首先，我们计算每个单元格的湿润面积 $A_{i,k}$。问题基于以度为单位的经度节点 $X = [x_0, x_1, \\dots, x_{N_x-1}]$ 和以米为单位的深度节点 $Z = [z_0, z_1, \\dots, z_{N_z-1}]$ 来定义网格。\n单元格的纬向宽度必须以米为单位计算。对于在恒定纬度 $\\phi$ 下，位于经度 $x_i$ 和 $x_{i+1}$ 之间的单元格，经度差（以弧度为单位）为 $\\Delta\\lambda_i = (x_{i+1}-x_i) \\cdot \\frac{\\pi}{180}$。沿纬度圈的弧长则为：\n$$\n\\Delta x_i = R \\cos\\phi \\Delta\\lambda_i\n$$\n其中地球半径 $R = 6,371,000 \\, \\mathrm{m}$，$\\phi$ 以度为单位给出，必须转换为弧度以用于余弦函数。\n深度 $z_k$ 和 $z_{k+1}$ 之间的单元格垂直高度就是：\n$$\n\\Delta z_k = z_{k+1} - z_k\n$$\n单元格 $(i,k)$ 的名义面积是 $\\Delta x_i \\Delta z_k$。问题引入了一个部分单元格分数数组 $H$，其中 $H[i,k]$ 是一个在 $[0,1]$ 范围内的值，表示单元格中湿润部分的比例，以适应复杂的水深地形。因此，单元格 $(i,k)$ 的湿润面积是：\n$$\nA_{i,k} = \\Delta x_i \\Delta z_k H[i,k]\n$$\n\n其次，我们确定单元格的平均速度 $\\bar{v}_{i,k}$。问题指定使用复合梯形法则，通过对单元格 $(i,k)$ 四个角点的速度值进行平均。这些角点对应于节点 $(x_i, z_k)$、$(x_{i+1}, z_k)$、$(x_i, z_{k+1})$ 和 $(x_{i+1}, z_{k+1})$。速度数据在大小为 $N_x \\times N_z$ 的数组 $V$ 中提供。同时提供了一个陆海掩码数组 $M \\in \\{0,1\\}^{N_x \\times N_z}$，其中 $M[i,k]=0$ 表示一个陆地节点，其速度应视为零。因此，单元格平均速度为：\n$$\n\\bar{v}_{i,k} = \\frac{1}{4}\\Big[V[i,k] M[i,k] + V[i+1,k] M[i+1,k] + V[i,k+1] M[i,k+1] + V[i+1,k+1] M[i+1,k+1]\\Big]\n$$\n\n计算出所有单元格的 $A_{i,k}$ 和 $\\bar{v}_{i,k}$ 后，通过对乘积 $A_{i,k} \\bar{v}_{i,k}$ 求和来计算总输运（单位为 $\\mathrm{m^3/s}$）。最后一步是将结果转换为 Sverdrup (Sv)，其中 $1 \\, \\mathrm{Sv} = 10^6 \\, \\mathrm{m^3/s}$：\n$$\nT_{\\text{Sv}} = \\frac{T}{10^6} = \\frac{1}{10^6} \\sum_{i=0}^{N_x-2} \\sum_{k=0}^{N_z-2} A_{i,k} \\bar{v}_{i,k}\n$$\n每个测试案例的最终结果四舍五入到 $6$ 位小数。\n\n这个过程可以使用向量化操作高效实现。\n1.  计算纬向间距数组 $\\Delta x$ 和垂直间距数组 $\\Delta z$。\n2.  通过 $\\Delta x$ 和 $\\Delta z$ 的外积计算单元格湿润面积矩阵 $A$，然后与部分单元格分数矩阵 $H$ 进行逐元素相乘。\n3.  通过逐元素相乘将陆地掩码应用于速度矩阵 $V$：$V' = V \\odot M$。\n4.  通过对 $V'$ 的移位版本（对应每个单元格的四个角点）求和，然后除以 $4$，来计算单元格平均速度矩阵 $\\bar{v}$。\n5.  计算单元格输运矩阵 $T_{\\text{cells}} = A \\odot \\bar{v}$。\n6.  将 $T_{\\text{cells}}$ 的所有元素求和得到总输运 $T$，然后转换为 Sverdrup 并四舍五入。\n这种基于向量的方法避免了显式循环，从而得到更简洁且计算效率更高的解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# There is no need to import from scipy for this problem.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    R_EARTH = 6_371_000.0  # Earth radius in meters\n\n    def compute_transport(phi, X, Z, V, M, H):\n        \"\"\"\n        Computes the volume transport in Sverdrups (Sv).\n\n        Args:\n            phi (float): Latitude in degrees.\n            X (np.ndarray): Longitude nodes in degrees.\n            Z (np.ndarray): Depth nodes in meters.\n            V (np.ndarray): Meridional velocity array (m/s).\n            M (np.ndarray): Land-ocean mask array (0 or 1).\n            H (np.ndarray): Partial-cell fraction array.\n\n        Returns:\n            float: Total transport in Sv, rounded to 6 decimal places.\n        \"\"\"\n        # Convert inputs to numpy arrays\n        X = np.asarray(X, dtype=float)\n        Z = np.asarray(Z, dtype=float)\n        V = np.asarray(V, dtype=float)\n        M = np.asarray(M, dtype=float)\n        H = np.asarray(H, dtype=float)\n\n        # Step 1: Calculate grid spacings\n        # Zonal spacings in meters\n        delta_lambda_rad = np.deg2rad(np.diff(X))\n        phi_rad = np.deg2rad(phi)\n        delta_x_m = R_EARTH * np.cos(phi_rad) * delta_lambda_rad\n\n        # Vertical spacings in meters\n        delta_z_m = np.diff(Z)\n\n        # Step 2: Calculate wet cell areas\n        # Nominal areas via outer product of spacings\n        # Resulting shape is (N_x-1, N_z-1)\n        nominal_areas = np.outer(delta_x_m, delta_z_m)\n        \n        # Apply partial cell fractions to get wet areas\n        wet_areas = nominal_areas * H\n\n        # Step 3: Calculate cell-averaged velocities\n        # Apply the land-ocean mask to the velocity nodes\n        masked_V = V * M\n\n        # Average velocities over the four corners of each cell\n        # Slicing creates views of the corners for all cells simultaneously\n        v_top_left = masked_V[:-1, :-1]\n        v_top_right = masked_V[1:, :-1]\n        v_bottom_left = masked_V[:-1, 1:]\n        v_bottom_right = masked_V[1:, 1:]\n        \n        v_bar = 0.25 * (v_top_left + v_top_right + v_bottom_left + v_bottom_right)\n\n        # Step 4: Compute total transport\n        # Element-wise product of wet area and average velocity for each cell\n        cell_transports = wet_areas * v_bar\n\n        # Sum transport contributions from all cells to get total in m^3/s\n        total_transport_m3s = np.sum(cell_transports)\n\n        # Convert to Sverdrups (1 Sv = 10^6 m^3/s)\n        total_transport_sv = total_transport_m3s / 1e6\n        \n        return round(total_transport_sv, 6)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"phi\": 30,\n            \"X\": [10.0, 10.5, 11.0, 12.0],\n            \"Z\": [0.0, 500.0, 1500.0],\n            \"V\": [[0.20, 0.15, 0.05], [0.25, 0.10, 0.00], [0.30, 0.12, -0.02], [0.28, 0.11, -0.05]],\n            \"M\": [[1, 1, 1], [1, 1, 1], [1, 1, 0], [1, 1, 1]],\n            \"H\": [[1.0, 0.6], [1.0, 1.0], [1.0, 0.8]]\n        },\n        {\n            \"phi\": 45,\n            \"X\": [0.0, 1.0, 2.0],\n            \"Z\": [0.0, 1000.0, 2000.0],\n            \"V\": [[0.10, 0.05, -0.02], [0.12, 0.06, -0.01], [0.11, 0.04, 0.00]],\n            \"M\": [[0, 0, 0], [0, 0, 0], [0, 0, 0]],\n            \"H\": [[1.0, 1.0], [1.0, 1.0]]\n        },\n        {\n            \"phi\": 0,\n            \"X\": [100.0, 100.25, 101.0],\n            \"Z\": [0.0, 300.0],\n            \"V\": [[0.10, 0.10], [0.10, 0.10], [0.10, 0.10]],\n            \"M\": [[1, 1], [1, 1], [1, 1]],\n            \"H\": [[1.0], [1.0]]\n        },\n        {\n            \"phi\": 70,\n            \"X\": [0.0, 2.0, 4.0, 8.0],\n            \"Z\": [0.0, 400.0, 1200.0, 2000.0],\n            \"V\": [[0.05, 0.02, -0.01, -0.03], [0.07, 0.03, 0.00, -0.02], [0.08, 0.04, 0.01, -0.01], [0.06, 0.02, -0.02, -0.04]],\n            \"M\": [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 0]],\n            \"H\": [[1.0, 1.0, 0.7], [1.0, 0.9, 0.5], [1.0, 1.0, 1.0]]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_transport(\n            case[\"phi\"], case[\"X\"], case[\"Z\"], case[\"V\"], case[\"M\"], case[\"H\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然单个截面的总输运量很有用，但经向翻转环流（Meridional Overturning Circulation, MOC）流函数 $\\Psi(\\phi, z)$ 能更全面地揭示环流的垂直结构和强度。流函数是通过对纬向积分的经向输运进行从海底到特定深度的累积垂直积分来计算的。本练习  将带您从一个三维速度场出发，通过积分计算构建二维的MOC流函数，并识别其核心强度和位置，这是评估全球热量和物质输运的关键诊断工具。",
            "id": "3787253",
            "problem": "给定一个定义在结构化经度-纬度-深度网格上的网格化经向速度场 $v(\\phi,\\lambda,z)$。目标是根据第一性原理，通过在垂直坐标 $z$ 上进行累积积分和在经度坐标 $\\lambda$ 上进行纬向积分，计算经向翻转流函数 $\\Psi(\\phi,z)$，然后确定该翻转流函数绝对值达到最大值时的纬度和深度，及其以斯维尔德鲁普（Sverdrups）为单位的数值。您必须实现一个程序，对指定的测试套件执行此计算，并以规定的格式在单行中生成所需的输出。\n\n基本原理和定义：\n- 穿过垂直剖面的体积输运定义为法向速度的面积分。对于穿过东西向剖面的经向速度 $v$，元输运为 $v\\,\\mathrm{d}x\\,\\mathrm{d}z$，其中 $\\mathrm{d}x$ 是纬向弧长，$\\mathrm{d}z$ 是层厚度。在给定纬度 $\\phi$ 和深度 $z$ 处的纬向积分经向输运是穿过整个纬向剖面的面积分。\n- 经向翻转流函数 $\\Psi(\\phi,z)$ 定义为在纬度 $\\phi$ 处，从底部到深度 $z$ 的纬向积分经向输运的累积垂直积分。该表示源于统计稳态和纬向平均意义下的质量连续性，并编码了给定深度以上的累积输运。\n- 要在球体上根据纬度 $\\phi$ 处的经度间距（以度为单位）计算 $\\mathrm{d}x$，请使用地球半径为 $R$ 的球体上的弧长关系：如果经度间距为 $\\Delta\\lambda$ (以弧度为单位)，则 $\\mathrm{d}x(\\phi)=R\\cos(\\phi_{\\mathrm{rad}})\\,\\Delta\\lambda$，其中 $\\phi_{\\mathrm{rad}}$ 是以弧度为单位的纬度。地球半径为 $R=6.371\\times 10^{6}$ 米。\n\n离散化要求：\n- 您必须在每个纬度和深度上，通过对经度网格单元求和来近似纬向积分，求和项为网格中心经向速度 $v(\\phi_i,\\lambda_j,z_k)$、纬向弧长 $\\Delta x(\\phi_i)$ 和层厚度 $\\Delta z_k$ 的乘积。\n- 在固定纬度 $\\phi_i$ 上，您必须通过对所有深度指数 $m\\ge k$（其中 $z$ 增加表示深度增加）求和来近似从底部到给定深度指数 $k$ 的累积垂直积分。\n- 如果提供了海陆掩码 $M(\\phi_i,\\lambda_j)\\in\\{0,1\\}$，则在纬向求和中仅包括 $M=1$ 的网格单元。如果某个测试用例未提供掩码，则假设所有位置的 $M(\\phi_i,\\lambda_j)=1$。\n\n计算目标：\n- 对于每个测试用例，首先计算每个 $(\\phi_i,z_k)$ 处的纬向积分输运，即对所有经度上的 $v\\,\\Delta x\\,\\Delta z$ 进行离散求和，然后计算该纬度下从底部到深度指数 $k$ 的累积垂直总和，得到 $\\Psi(\\phi_i,z_k)$。找出在所有纬度和深度上绝对值 $|\\Psi|$ 达到最大的位置 $(\\phi^\\ast,z^\\ast)$。报告 $\\phi^\\ast$（以度为单位）、$z^\\ast$（以米为单位）以及转换成斯维尔德鲁普（Sverdrups）后的带符号 $\\Psi^\\ast$ 值。一斯维尔德鲁普（Sv）等于 $10^{6}$ 立方米/秒，因此通过除以 $10^{6}$ 进行转换。\n- 最终流函数值以斯维尔德鲁普（Sv）为单位表示，并四舍五入到三位小数。纬度以度为单位，深度以米为单位，使用它们精确的网格值，无需四舍五入。\n- 平局打破规则：如果多个网格点（在数值相等范围内）共享相同的最大 $|\\Psi|$ 绝对值，则选择深度 $z$ 最小的那个；如果仍然存在平局，则选择所提供纬度数组中纬度索引最小的那个。\n\n角度单位：\n- 输入的纬度和经度网格以度为单位。在进行距离计算时，将纬度和经度间距转换为弧度。使用 $\\phi_{\\mathrm{rad}}=\\phi\\cdot\\pi/180$，$\\Delta\\lambda_{\\mathrm{rad}}=\\Delta\\lambda\\cdot\\pi/180$。\n\n测试套件：\n为以下三个测试用例实现计算。在每个用例中，速度 $v$ 以米/秒为单位指定，纬度 $\\phi$ 和经度 $\\lambda$ 以度为单位，深度 $z$ 作为层中心以米为单位，并附带相应的层厚度 $\\Delta z$（以米为单位）以及可选的海陆掩码 $M$。\n\n- 用例 A（具有非均匀垂直厚度和纬向调制的一般正常路径）：\n  - 纬度: $\\phi=\\left[-40,-20,0,20,40\\right]$ 度。\n  - 经度: $\\lambda=\\left[0,3,6,9,12\\right]$ 度，均匀间距 $\\Delta\\lambda=3$ 度。\n  - 深度中心: $z=\\left[100,600,1200,2200,3400\\right]$ 米。\n  - 层厚度: $\\Delta z=\\left[200,600,800,1000,1200\\right]$ 米。\n  - 海陆掩码: $M(\\phi_i,\\lambda_j)=1$ 对所有 $i,j$ 成立。\n  - 速度场:\n    $$v(\\phi,\\lambda,z)=0.05\\cdot\\cos\\left(\\frac{\\pi z}{4000}\\right)\\cdot\\exp\\left(-\\frac{\\phi_{\\mathrm{rad}}^{2}}{(0.6)^{2}}\\right)\\cdot\\left(1+0.3\\sin(\\lambda_{\\mathrm{rad}})\\right).$$\n\n- 用例 B（边界情况：处处为零流）：\n  - 纬度: $\\phi=\\left[-10,0,10\\right]$ 度。\n  - 经度: $\\lambda=\\left[0,10,20,30\\right]$ 度，均匀间距 $\\Delta\\lambda=10$ 度。\n  - 深度中心: $z=\\left[500,1500\\right]$ 米。\n  - 层厚度: $\\Delta z=\\left[1000,2000\\right]$ 米。\n  - 海陆掩码: $M(\\phi_i,\\lambda_j)=1$ 对所有 $i,j$ 成立。\n  - 速度场: 对所有网格点，$v(\\phi,\\lambda,z)=0$。\n\n- 用例 C（边缘情况：通过掩码实现依赖于纬度的纬向宽度的负流）：\n  - 纬度: $\\phi=\\left[30,35,40\\right]$ 度。\n  - 经度: $\\lambda=\\left[0,2,4,6,8,10\\right]$ 度，均匀间距 $\\Delta\\lambda=2$ 度。\n  - 深度中心: $z=\\left[300,1200,2600\\right]$ 米。\n  - 层厚度: $\\Delta z=\\left[600,1200,1800\\right]$ 米。\n  - 海陆掩码 $M$:\n    - 在 $\\phi=30$ 度处：所有经度的 $M=1$。\n    - 在 $\\phi=35$ 度处：经度 $\\lambda\\in\\left\\{0,2,4,6\\right\\}$ 的 $M=1$，经度 $\\lambda\\in\\left\\{8,10\\right\\}$ 的 $M=0$。\n    - 在 $\\phi=40$ 度处：经度 $\\lambda\\in\\left\\{0,2,4\\right\\}$ 的 $M=1$，经度 $\\lambda\\in\\left\\{6,8,10\\right\\}$ 的 $M=0$。\n  - 速度场：对于所有海洋网格点，$v(\\phi,\\lambda,z)=-0.02$。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是 $\\left[\\phi^\\ast,z^\\ast,\\Psi^\\ast_{\\mathrm{Sv}}\\right]$ 形式的列表，其中 $\\phi^\\ast$ 以度为单位， $z^\\ast$ 以米为单位，$\\Psi^\\ast_{\\mathrm{Sv}}$ 是以斯维尔德鲁普为单位的带符号流函数值，四舍五入到三位小数。因此，总输出必须是一个包含三个列表的列表：\n  - 示例格式: $\\left[[\\phi_1^\\ast,z_1^\\ast,\\Psi_{1,\\mathrm{Sv}}^\\ast],[\\phi_2^\\ast,z_2^\\ast,\\Psi_{2,\\mathrm{Sv}}^\\ast],[\\phi_3^\\ast,z_3^\\ast,\\Psi_{3,\\mathrm{Sv}}^\\ast]\\right]$。",
            "solution": "该问题要求根据网格化的经向速度场 $v(\\phi, \\lambda, z)$ 计算经向翻转流函数 $\\Psi(\\phi, z)$，并确定其绝对值最大值的位置和数值。该过程基于流体质量守恒原理。\n\n首先，建立理论基础。在给定纬度 $\\phi$ 和深度 $z$ 处的经向翻转流函数 $\\Psi$ 代表了穿过从海底延伸至深度 $z$ 的纬向剖面并向北移动的水体净体积。它由纬向积分的经向输运的累积垂直积分定义。\n\n穿过垂直于流动的微小面积 $dA = dx \\, dz$ 的元体积输运为 $d\\mathcal{T} = v \\, dA$，其中 $v$ 是经向速度分量。在半径为 $R$ 的球体上，纬度 $\\phi$ 处对应经度微小变化 $d\\lambda$（以弧度为单位）的纬向宽度元 $dx$ 由 $dx = R \\cos(\\phi) d\\lambda$ 给出。\n\n该问题在一个结构化网格上进行离散化，该网格具有纬度指数 $i \\in [0, N_\\phi-1]$、经度指数 $j \\in [0, N_\\lambda-1]$ 和深度指数 $k \\in [0, N_z-1]$，其中 $k=0$ 对应最浅的层，且 $z$ 随深度增加而增加。\n\n计算流程如下：\n\n1.  **网格与参数初始化**：定义所有提供的网格数据：纬度坐标 $\\phi_i$、经度坐标 $\\lambda_j$、深度层中心 $z_k$ 和层厚度 $\\Delta z_k$。地球半径取为 $R = 6.371 \\times 10^6 \\, \\text{m}$。所有以度为单位的输入角度都转换为弧度以进行几何计算，例如 $\\phi_{i, \\text{rad}} = \\phi_i \\cdot \\pi/180$。\n\n2.  **纬向输运计算**：计算每个网格层 $(i, k)$ 中的纬向积分经向输运 $T_{ik}$。此纬向积分的离散近似涉及在固定纬度和深度上，对所有经度上的每个网格单元的输运进行求和。单个单元 $(\\phi_i, \\lambda_j, z_k)$ 中的输运是速度 $v_{ijk} = v(\\phi_i, \\lambda_j, z_k)$、单元横截面积 $A_{ijk} = \\Delta x_i \\cdot \\Delta z_k$ 和海陆掩码 $M_{ij}$ 的乘积。在纬度 $\\phi_i$ 处，经度间距为 $\\Delta\\lambda$ 的网格单元的纬向弧长对于该纬度是恒定的：$\\Delta x_i = R \\cos(\\phi_{i, \\text{rad}}) \\Delta\\lambda_{\\text{rad}}$，其中 $\\Delta\\lambda_{\\text{rad}} = \\Delta\\lambda \\cdot \\pi/180$。\n\n    在 $(\\phi_i, z_k)$ 处的层的总纬向积分输运为：\n    $$ T_{ik} = \\sum_{j=0}^{N_{\\lambda}-1} v_{ijk} (\\Delta x_i) (\\Delta z_k) M_{ij} = (\\Delta z_k \\Delta x_i) \\sum_{j=0}^{N_{\\lambda}-1} v_{ijk} M_{ij} $$\n    此计算产生一个维度为 $(N_\\phi \\times N_z)$ 的二维数组 $T$。\n\n3.  **经向翻转流函数计算**：网格点 $(\\phi_i, z_k)$ 处的流函数 $\\Psi_{ik}$ 定义为从洋底到该深度层的输运累积和。根据问题的离散化规则，这是对所有深度指数 $m \\ge k$ 的求和：\n    $$ \\Psi_{ik} = \\sum_{m=k}^{N_z-1} T_{im} $$\n    此计算对每个纬度指数 $i$ 执行。一种高效的实现方法是，从最后一个元素（底部）开始，沿着深度轴对输运数组 $T_{i,:}$ 进行累积求和。这确保了最深层的流函数 $\\Psi_{i, N_z-1}$ 就是该层的输运 $T_{i, N_z-1}$，而顶层的流函数 $\\Psi_{i, 0}$ 是整个水柱上的积分 $\\sum_{m=0}^{N_z-1} T_{im}$。这将产生一个与 $T$ 维度相同的二维数组 $\\Psi$。\n\n4.  **确定最大绝对值**：主要目标是找到流函数绝对值 $|\\Psi_{ik}|$ 最大的网格点 $(\\phi^\\ast, z^\\ast)$。\n    - 首先，确定最大绝对值：$|\\Psi|_{max} = \\max_{i,k} |\\Psi_{ik}|$。\n    - 识别出一组候选索引 $\\mathcal{S} = \\{(i, k) \\mid |\\Psi_{ik}| = |\\Psi|_{max}\\}$。\n    - 对该集合应用指定的平局打破规则以确保解的唯一性：\n        a. 从 $\\mathcal{S}$ 中选择具有最小深度值 $z_{k^\\ast} = \\min \\{z_k \\mid (i,k) \\in \\mathcal{S}\\}$ 的候选子集。\n        b. 如果仍有多个候选，则选择纬度指数 $i^\\ast$ 最小的那个。\n    - 最终确定的索引为 $(i^\\ast, k^\\ast)$。\n\n5.  **输出格式化**：每个测试用例的最终报告值为纬度 $\\phi^\\ast = \\phi_{i^\\ast}$（以度为单位），深度 $z^\\ast = z_{k^\\ast}$（以米为单位），以及相应的带符号流函数值 $\\Psi^\\ast = \\Psi_{i^\\ast, k^\\ast}$，该值通过除以 $10^6$ 转换为斯维尔德鲁普（Sv）单位并四舍五入到三位小数。所有测试用例的结果按规定编译成一个单一的列表之列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the meridional overturning streamfunction and finds its maximum\n    absolute value for a series of test cases.\n    \"\"\"\n    R_EARTH = 6.371e6  # Earth radius in meters\n    SV_CONVERSION = 1e-6  # Conversion from m^3/s to Sverdrups\n\n    # Test cases defined as a list of dictionaries\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"phi\": np.array([-40, -20, 0, 20, 40]),\n            \"lambda_\": np.array([0, 3, 6, 9, 12]),\n            \"z_centers\": np.array([100, 600, 1200, 2200, 3400]),\n            \"delta_z\": np.array([200, 600, 800, 1000, 1200]),\n            \"mask\": None,\n            \"v_func\": lambda phi_rad, lam_rad, z: 0.05 * np.cos(np.pi * z / 4000) * \\\n                                                  np.exp(-phi_rad**2 / (0.6**2)) * \\\n                                                  (1 + 0.3 * np.sin(lam_rad)),\n        },\n        {\n            \"name\": \"Case B\",\n            \"phi\": np.array([-10, 0, 10]),\n            \"lambda_\": np.array([0, 10, 20, 30]),\n            \"z_centers\": np.array([500, 1500]),\n            \"delta_z\": np.array([1000, 2000]),\n            \"mask\": None,\n            \"v_func\": lambda phi_rad, lam_rad, z: 0.0,\n        },\n        {\n            \"name\": \"Case C\",\n            \"phi\": np.array([30, 35, 40]),\n            \"lambda_\": np.array([0, 2, 4, 6, 8, 10]),\n            \"z_centers\": np.array([300, 1200, 2600]),\n            \"delta_z\": np.array([600, 1200, 1800]),\n            \"mask\": np.array([\n                [1, 1, 1, 1, 1, 1],  # phi = 30\n                [1, 1, 1, 1, 0, 0],  # phi = 35\n                [1, 1, 1, 0, 0, 0],  # phi = 40\n            ], dtype=int),\n            \"v_func\": lambda phi_rad, lam_rad, z: -0.02,\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        phi = case[\"phi\"]\n        lambda_ = case[\"lambda_\"]\n        z_centers = case[\"z_centers\"]\n        delta_z = case[\"delta_z\"]\n        mask = case[\"mask\"]\n        v_func = case[\"v_func\"]\n\n        n_phi, n_lambda, n_z = len(phi), len(lambda_), len(z_centers)\n\n        # Generate grids for calculations\n        phi_grid, lambda_grid, z_grid = np.meshgrid(phi, lambda_, z_centers, indexing='ij')\n\n        # Convert angles to radians for calculations\n        phi_rad_grid = np.deg2rad(phi_grid)\n        lambda_rad_grid = np.deg2rad(lambda_grid)\n\n        # Calculate meridional velocity field\n        v = v_func(phi_rad_grid, lambda_rad_grid, z_grid)\n\n        # Handle land-sea mask\n        if mask is None:\n            mask = np.ones((n_phi, n_lambda), dtype=int)\n        \n        # Ensure mask is broadcastable to the velocity field shape\n        mask_3d = mask[:, :, np.newaxis]\n        \n        # Apply mask to velocity\n        v_masked = v * mask_3d\n\n        # Calculate zonal arc length for each latitude\n        # Assuming uniform longitude spacing\n        delta_lambda_deg = lambda_[1] - lambda_[0] if n_lambda > 1 else 0\n        delta_lambda_rad = np.deg2rad(delta_lambda_deg)\n        phi_rad_1d = np.deg2rad(phi)\n        delta_x = R_EARTH * np.cos(phi_rad_1d) * delta_lambda_rad\n\n        # Reshape for broadcasting\n        delta_x_2d = delta_x[:, np.newaxis]\n        delta_z_2d = delta_z[np.newaxis, :]\n\n        # Calculate zonally integrated transport T_ik (shape: n_phi x n_z)\n        # Sum v_masked over the longitude axis (axis 1)\n        zonal_sum_v = np.sum(v_masked, axis=1)\n        T_ik = zonal_sum_v * delta_x_2d * delta_z_2d\n        \n        # Calculate meridional overturning streamfunction Psi_ik\n        # Cumulative sum from bottom to top (along axis 1, which is depth)\n        psi = np.cumsum(T_ik[:, ::-1], axis=1)[:, ::-1]\n\n        # Find the location of the maximum absolute streamfunction value\n        abs_psi = np.abs(psi)\n        max_abs_psi = np.max(abs_psi)\n\n        # Find all indices where the max value occurs\n        candidate_indices = np.argwhere(abs_psi == max_abs_psi)\n\n        # Apply tie-breaking rule:\n        # 1. Smallest depth z\n        candidate_depth_values = z_centers[candidate_indices[:, 1]]\n        min_depth_val = np.min(candidate_depth_values)\n        depth_filtered_indices = candidate_indices[candidate_depth_values == min_depth_val]\n        \n        # 2. Smallest latitude index\n        min_lat_idx = np.min(depth_filtered_indices[:, 0])\n        \n        # Find the final winning index pair\n        final_winner = depth_filtered_indices[depth_filtered_indices[:, 0] == min_lat_idx][0]\n        i_star, k_star = final_winner[0], final_winner[1]\n\n        phi_star = phi[i_star]\n        z_star = z_centers[k_star]\n        psi_star_sv = round(psi[i_star, k_star] * SV_CONVERSION, 3)\n\n        all_results.append([phi_star, z_star, psi_star_sv])\n\n    # Format output as a string representation of a list of lists\n    result_str = \",\".join([f\"[{phi},{z},{psi}]\" for phi, z, psi in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在许多实际应用中，我们可能没有直接的速度场数据，而是拥有温度和盐度等水文观测资料。通过地转平衡和热成风关系，我们可以从这些密度相关的测量中推断出速度场。本练习  模拟了物理海洋学家的一项经典任务：利用水文站位的温盐剖面计算地转输运，并通过声学多普勒流速剖面仪（ADCP）的实测数据来标定绝对速度，从而将理论与实际观测联系起来。",
            "id": "3787298",
            "problem": "给定海峡两岸的两个水文站，每个站都有温盐剖面以及在指定深度的单层声学多普勒流速剖面仪（ADCP）参考速度。您的任务是计算从海面到目标深度积分的绝对地转输运，并将其与基于一个为ADCP速度剖面明确定义的简单形状假设的ADCP输运进行比较。您必须构建一个完整的程序，对一组测试用例执行此计算，并按规定格式打印所需输出。\n\n计算必须基于有效的基础。请使用以下基本关系和假设：\n\n- 静力平衡：$ \\dfrac{\\partial p}{\\partial z} = - \\rho g $，其中 $ \\rho $ 是密度，$ p $ 是压力，$ z $ 是深度（向下为正），$ g $ 是重力加速度。\n- 存在跨海峡压力梯度时，沿海峡方向速度 $ v $ 的地转平衡：$ f v = - \\dfrac{1}{\\rho} \\dfrac{\\partial p}{\\partial x} $，其中 $ f $ 是科里奥利参数，$ x $ 是跨海峡的水平坐标。\n- 由上述关系推导出的热成风关系：$ \\dfrac{\\partial v}{\\partial z} = - \\dfrac{g}{f \\rho_0} \\dfrac{\\partial \\rho}{\\partial x} $，其中 $ \\rho_0 $ 是一个常数参考密度。\n\n为获得密度，采用线性化状态方程：\n$$ \\rho(T,S) = \\rho_0 \\left[ 1 - \\alpha \\left( T - T_0 \\right) + \\beta \\left( S - S_0 \\right) \\right], $$\n其中 $ T $ 的单位是摄氏度，$ S $ 的单位是实用盐度单位，$ \\alpha $ 是热膨胀系数，$ \\beta $ 是盐缩系数，$ T_0 $、$ S_0 $ 是参考值。\n\n您将使用热成风方程，通过两个站位之间的横向密度差来计算垂直切变 $ \\dfrac{\\partial v}{\\partial z} $，近似地将 $ \\dfrac{\\partial \\rho}{\\partial x} $ 表示为跨越站位间距 $ L $ 的有限差分，并通过参考在 $ z_{\\text{ref}} $ 处的ADCP测量速度，对切变进行垂直积分，以获得绝对地转速度剖面 $ v(z) $。然后，将 $ v(z) $ 从 $ z=0 $ 到 $ z=z_{\\text{max}} $ 进行积分，得到单位宽度的输运，再乘以间距 $ L $ 得到体积输运。另外，使用指定的形状参数构建一个ADCP速度剖面，使其与在 $ z_{\\text{ref}} $ 处提供的参考值相匹配，用同样的方式进行积分，并计算基于ADCP的体积输运。\n\n使用的常量和单位：\n- $ g = 9.81 $ 米/秒^2。\n- $ \\rho_0 = 1025 $ 千克/米^3。\n- $ \\alpha = 2.0 \\times 10^{-4} $ /摄氏度。\n- $ \\beta = 7.7 \\times 10^{-4} $ /实用盐度单位。\n- $ T_0 = 10.0 $ 摄氏度。\n- $ S_0 = 35.0 $ 实用盐度单位。\n- 科里奥利参数 $ f = 2 \\Omega \\sin(\\phi) $，其中地球自转速率 $ \\Omega = 7.2921 \\times 10^{-5} $ /秒，纬度 $ \\phi $ 以弧度为单位。\n\n建模假设：\n- 两个水文站沿跨海峡轴线分布，相距 $ L $ 米，并定义了跨海峡密度梯度 $ \\dfrac{\\partial \\rho}{\\partial x} \\approx \\dfrac{\\rho_2(z) - \\rho_1(z)}{L} $。计算出的沿海峡方向的地转速度被视为在宽度 $ L $ 上的代表性速度，乘以 $ L $ 即可得到体积输运。\n- ADCP提供在深度 $ z_{\\text{ref}} $ 的参考绝对速度 $ v_{\\text{ref}} $，基于ADCP的速度剖面 $ v_{\\text{ADCP}}(z) $ 被参数化以与此参考值保持一致。\n\n剖面：\n- 对于每个站位 $ i \\in \\{1,2\\} $，温度剖面为\n$$ T_i(z) = T_{\\text{deep},i} + \\left( T_{\\text{surf},i} - T_{\\text{deep},i} \\right) \\exp\\left( - \\dfrac{z}{H_{T,i}} \\right), $$\n盐度剖面为\n$$ S_i(z) = S_{\\text{deep},i} - \\left( S_{\\text{deep},i} - S_{\\text{surf},i} \\right) \\exp\\left( - \\dfrac{z}{H_{S,i}} \\right), $$\n其中 $ z $ 是深度，单位为米。\n\n- 基于ADCP的沿海峡速度剖面定义为\n$$ v_{\\text{ADCP}}(z) = \\begin{cases}\nv_{\\text{ref}} \\left[ 1 + a \\dfrac{z_{\\text{ref}} - z}{z_{\\text{ref}}} \\right],  0 \\le z \\le z_{\\text{ref}}, \\\\\nv_{\\text{ref}} \\exp\\left( - \\dfrac{z - z_{\\text{ref}}}{H_v} \\right),  z_{\\text{ref}} \\le z \\le z_{\\text{max}},\n\\end{cases} $$\n这确保了 $ v_{\\text{ADCP}}(z_{\\text{ref}}) = v_{\\text{ref}} $，其中 $ a $ 是无量纲的，$ H_v $ 的单位是米。\n\n要实现的计算步骤：\n1. 创建一个从 $ 0 $ 到 $ z_{\\text{max}} $ 米的均匀深度网格 $ z $，间距 $ \\Delta z = 10 $ 米。\n2. 对于每个站位，在深度网格上计算 $ T_i(z) $ 和 $ S_i(z) $，然后使用线性化状态方程计算 $ \\rho_i(z) $。\n3. 使用热成风关系计算地转沿海峡速度的垂直切变，\n$$ \\dfrac{\\partial v}{\\partial z}(z) = - \\dfrac{g}{f \\rho_0} \\dfrac{\\rho_2(z) - \\rho_1(z)}{L}. $$\n4. 通过强制 $ v(z_{\\text{ref}}) = v_{\\text{ref}} $，对 $ \\dfrac{\\partial v}{\\partial z} $ 进行垂直积分以获得 $ v(z) $，即\n$$ v(z) = v_{\\text{ref}} + \\int_{z_{\\text{ref}}}^{z} \\dfrac{\\partial v}{\\partial z}(z') \\, dz'. $$\n5. 通过将 $ v(z) $ 从 $ 0 $ 积分到 $ z_{\\text{max}} $ 并乘以 $ L $ 来计算地转体积输运，\n$$ Q_{\\text{geo}} = L \\int_{0}^{z_{\\text{max}}} v(z) \\, dz, $$\n单位为立方米/秒。\n6. 使用提供的 $ v_{\\text{ref}} $、$ z_{\\text{ref}} $、$ a $ 和 $ H_v $ 构建 $ v_{\\text{ADCP}}(z) $，并计算基于ADCP的体积输运，\n$$ Q_{\\text{ADCP}} = L \\int_{0}^{z_{\\text{max}}} v_{\\text{ADCP}}(z) \\, dz, $$\n单位为立方米/秒。\n7. 对于每个测试用例，还要计算差异 $ \\Delta Q = Q_{\\text{geo}} - Q_{\\text{ADCP}} $ 和相对差异 $ \\delta = \\dfrac{Q_{\\text{geo}} - Q_{\\text{ADCP}}}{Q_{\\text{ADCP}}} $（小数形式）。\n\n物理单位和输出要求：\n- 所有输运 $ Q_{\\text{geo}} $ 和 $ Q_{\\text{ADCP}} $ 以立方米/秒（m$^3$/s）表示。\n- 相对差异 $ \\delta $ 以小数表示。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果是一个列表 $[Q_{\\text{geo}}, Q_{\\text{ADCP}}, \\Delta Q, \\delta]$，格式化为三位小数，并按顺序包含所有测试用例。例如：$[[1.234,0.987,0.247,0.250],[...],[...]]$。\n\n测试套件：\n所有测试用例均使用 $ z_{\\text{ref}} = 300 $ 米和 $ z_{\\text{max}} = 2000 $ 米。每个测试用例的参数如下：\n\n- 情况 $ A $（一般情况）：\n  - 纬度 $ \\phi = 60.0 $ 度。\n  - 站位间距 $ L = 20000.0 $ 米。\n  - $ v_{\\text{ref}} = 0.300 $ 米/秒。\n  - 站位 $ 1 $：$ T_{\\text{surf},1} = 10.0 $，$ T_{\\text{deep},1} = 2.0 $，$ H_{T,1} = 400.0 $；$ S_{\\text{surf},1} = 34.60 $，$ S_{\\text{deep},1} = 34.95 $，$ H_{S,1} = 700.0 $。\n  - 站位 $ 2 $：$ T_{\\text{surf},2} = 9.5 $，$ T_{\\text{deep},2} = 2.2 $，$ H_{T,2} = 350.0 $；$ S_{\\text{surf},2} = 34.70 $，$ S_{\\text{deep},2} = 35.00 $，$ H_{S,2} = 650.0 $。\n  - ADCP剖面参数：$ H_v = 800.0 $，$ a = 0.20 $。\n\n- 情况 $ B $（弱横向梯度）：\n  - 纬度 $ \\phi = 45.0 $ 度。\n  - 站位间距 $ L = 15000.0 $ 米。\n  - $ v_{\\text{ref}} = 0.050 $ 米/秒。\n  - 站位 $ 1 $：$ T_{\\text{surf},1} = 11.0 $，$ T_{\\text{deep},1} = 2.5 $，$ H_{T,1} = 500.0 $；$ S_{\\text{surf},1} = 34.70 $，$ S_{\\text{deep},1} = 34.90 $，$ H_{S,1} = 800.0 $。\n  - 站位 $ 2 $：$ T_{\\text{surf},2} = 11.0 $，$ T_{\\text{deep},2} = 2.5 $，$ H_{T,2} = 500.0 $；$ S_{\\text{surf},2} = 34.71 $，$ S_{\\text{deep},2} = 34.91 $，$ H_{S,2} = 800.0 $。\n  - ADCP剖面参数：$ H_v = 600.0 $，$ a = 0.10 $。\n\n- 情况 $ C $（小科里奥利参数）：\n  - 纬度 $ \\phi = 5.0 $ 度。\n  - 站位间距 $ L = 25000.0 $ 米。\n  - $ v_{\\text{ref}} = 0.150 $ 米/秒。\n  - 站位 $ 1 $：$ T_{\\text{surf},1} = 12.0 $，$ T_{\\text{deep},1} = 3.0 $，$ H_{T,1} = 450.0 $；$ S_{\\text{surf},1} = 34.50 $，$ S_{\\text{deep},1} = 34.85 $，$ H_{S,1} = 700.0 $。\n  - 站位 $ 2 $：$ T_{\\text{surf},2} = 11.8 $，$ T_{\\text{deep},2} = 3.1 $，$ H_{T,2} = 420.0 $；$ S_{\\text{surf},2} = 34.55 $，$ S_{\\text{deep},2} = 34.88 $，$ H_{S,2} = 720.0 $。\n  - ADCP剖面参数：$ H_v = 900.0 $，$ a = 0.15 $。\n\n您的程序必须遵守指定的执行环境，并产生所描述的确切输出格式。不允许外部输入；所有参数都在程序内部。最终打印的输出是包含三个列表的单行列表，每个测试用例一个列表，每个列表包含四个格式化为三位小数的浮点值，代表 $[Q_{\\text{geo}}, Q_{\\text{ADCP}}, \\Delta Q, \\delta]$，单位为立方米/秒（对于输运项）和小数（对于 $ \\delta $）。",
            "solution": "该问题是有效的，因为它在科学上基于物理海洋学的原理，问题陈述清晰且提供了足够的信息以获得唯一解，并以客观、正式的语言表述。所提供的参数和方程是一致且物理上合理的。\n\n这个问题的核心在于计算和比较海峡输运的两种估算值：一种是通过地转方法从水文数据推导得出，另一种是基于直接流速测量（ADCP）的简化剖面得出。\n\n基本原理是**热成风关系**，它是由地转平衡和静力平衡方程结合推导出来的。在连续层化的流体中，水平密度梯度意味着水平地转速度存在垂直切变。热成风方程如下：\n$$ \\dfrac{\\partial v}{\\partial z} = - \\dfrac{g}{f \\rho_0} \\dfrac{\\partial \\rho}{\\partial x} $$\n这里，$v$ 是沿海峡方向的速度，$z$ 是垂直坐标（向下为正），$g$ 是重力加速度，$f$ 是科里奥利参数，$\\rho_0$ 是参考密度，$\\dfrac{\\partial \\rho}{\\partial x}$ 是跨海峡的密度梯度。\n\n该方程提供了垂直切变 $\\dfrac{\\partial v}{\\partial z}$，但没有提供绝对速度 $v(z)$。为了确定绝对速度，我们必须知道某个参考层上的速度。这通常被称为对地转流进行“校平”。该问题从ADCP测量中提供了在特定深度 $z_{\\text{ref}}$ 的参考速度 $v_{\\text{ref}}$。通过从该参考深度垂直积分切变，我们可以构建绝对地转速度剖面：\n$$ v(z) = v(z_{\\text{ref}}) + \\int_{z_{\\text{ref}}}^{z} \\dfrac{\\partial v}{\\partial z'}(z') \\, dz' $$\n其中 $v(z_{\\text{ref}})$ 设置为 $v_{\\text{ref}}$。\n\n密度 $\\rho$ 是温度 $T$ 和盐度 $S$ 的函数。为此提供了一个线性化状态方程：\n$$ \\rho(T,S) = \\rho_0 \\left[ 1 - \\alpha \\left( T - T_0 \\right) + \\beta \\left( S - S_0 \\right) \\right] $$\n其中 $\\alpha$ 是热膨胀系数，$\\beta$ 是盐缩系数。\n\n计算过程如下：\n\n1.  **离散化**：建立一个从海面（$z=0$）到最大深度（$z=z_{\\text{max}}$）的均匀垂直网格 $z_j$，间距为 $\\Delta z = 10$ 米。\n\n2.  **密度剖面计算**：对于两个水文站（$i=1, 2$）中的每一个，使用提供的指数函数在每个网格点上计算温度剖面 $T_i(z_j)$ 和盐度剖面 $S_i(z_j)$。然后利用线性化状态方程计算相应的密度剖面 $\\rho_1(z_j)$ 和 $\\rho_2(z_j)$。\n\n3.  **地转切变计算**：通过两个相距为 $L$ 的站位之间的有限差分来近似连续的跨海峡密度梯度 $\\dfrac{\\partial \\rho}{\\partial x}$：$\\dfrac{\\rho_2(z_j) - \\rho_1(z_j)}{L}$。将此代入热成风方程，得到离散的垂直切变剖面 $\\left(\\dfrac{\\partial v}{\\partial z}\\right)_j$。科里奥利参数 $f$ 由给定的纬度 $\\phi$ 使用 $f = 2 \\Omega \\sin(\\phi)$ 计算得出，其中 $\\Omega$ 是地球的自转速率。\n\n4.  **绝对地转速度剖面**：对离散的切变剖面进行数值积分。我们使用累积梯形法则来计算从海面开始的切变积分。设此积分为 $I(z_j) = \\int_0^{z_j} \\frac{\\partial v}{\\partial z'} dz'$。然后构建绝对速度剖面为 $v_{\\text{geo}}(z_j) = v_{\\text{ref}} + I(z_j) - I(z_{\\text{ref}})$，这确保了 $v_{\\text{geo}}(z_{\\text{ref}}) = v_{\\text{ref}}$。深度 $z_{\\text{ref}}$ 与一个网格点对齐，简化了索引。\n\n5.  **地转输运**：通过将绝对速度剖面 $v_{\\text{geo}}(z)$ 在海峡深度上进行数值积分，并乘以海峡宽度 $L$，得到总体积输运 $Q_{\\text{geo}}$。这使用梯形法则计算：\n    $$ Q_{\\text{geo}} = L \\int_{0}^{z_{\\text{max}}} v_{\\text{geo}}(z) \\, dz \\approx L \\sum_{j} \\frac{v_{\\text{geo}}(z_j) + v_{\\text{geo}}(z_{j+1})}{2} \\Delta z $$\n\n6.  **基于ADCP的输运**：为了进行比较，计算第二个独立的输运估算值 $Q_{\\text{ADCP}}$。这使用一个预设的分段定义的速度剖面 $v_{\\text{ADCP}}(z)$，该剖面被设计为在 $z_{\\text{ref}}$ 处与参考速度 $v_{\\text{ref}}$ 相匹配。该剖面在相同的深度范围内进行数值积分，并乘以宽度 $L$ 以获得 $Q_{\\text{ADCP}}$。\n\n7.  **比较**：最后，计算绝对差异 $\\Delta Q = Q_{\\text{geo}} - Q_{\\text{ADCP}}$ 和相对差异 $\\delta = \\Delta Q / Q_{\\text{ADCP}}$，以量化两种输运估算值之间的差异。这种比较突显了即使锚定在相同的参考速度上，对速度剖面形状的不同假设（地转切变 vs. 参数化形状）如何导致不同的输运值。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid, trapezoid\n\ndef solve():\n    \"\"\"\n    Computes and compares geostrophic and ADCP-based transports for a set of test cases.\n    \"\"\"\n    # Physical and model constants\n    G = 9.81  # m/s^2\n    RHO0 = 1025.0  # kg/m^3\n    ALPHA = 2.0e-4  # 1/C\n    BETA = 7.7e-4  # 1/psu\n    T0 = 10.0  # C\n    S0 = 35.0  # psu\n    OMEGA = 7.2921e-5  # rad/s\n\n    # Shared parameters for all test cases\n    Z_REF = 300.0  # m\n    Z_MAX = 2000.0  # m\n    DZ = 10.0  # m\n    \n    # Test cases data\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"phi_deg\": 60.0,\n            \"L\": 20000.0,\n            \"v_ref\": 0.300,\n            \"station1\": {\"T_surf\": 10.0, \"T_deep\": 2.0, \"H_T\": 400.0,\n                         \"S_surf\": 34.60, \"S_deep\": 34.95, \"H_S\": 700.0},\n            \"station2\": {\"T_surf\": 9.5, \"T_deep\": 2.2, \"H_T\": 350.0,\n                         \"S_surf\": 34.70, \"S_deep\": 35.00, \"H_S\": 650.0},\n            \"adcp_params\": {\"H_v\": 800.0, \"a\": 0.20},\n        },\n        {\n            \"name\": \"B\",\n            \"phi_deg\": 45.0,\n            \"L\": 15000.0,\n            \"v_ref\": 0.050,\n            \"station1\": {\"T_surf\": 11.0, \"T_deep\": 2.5, \"H_T\": 500.0,\n                         \"S_surf\": 34.70, \"S_deep\": 34.90, \"H_S\": 800.0},\n            \"station2\": {\"T_surf\": 11.0, \"T_deep\": 2.5, \"H_T\": 500.0,\n                         \"S_surf\": 34.71, \"S_deep\": 34.91, \"H_S\": 800.0},\n            \"adcp_params\": {\"H_v\": 600.0, \"a\": 0.10},\n        },\n        {\n            \"name\": \"C\",\n            \"phi_deg\": 5.0,\n            \"L\": 25000.0,\n            \"v_ref\": 0.150,\n            \"station1\": {\"T_surf\": 12.0, \"T_deep\": 3.0, \"H_T\": 450.0,\n                         \"S_surf\": 34.50, \"S_deep\": 34.85, \"H_S\": 700.0},\n            \"station2\": {\"T_surf\": 11.8, \"T_deep\": 3.1, \"H_T\": 420.0,\n                         \"S_surf\": 34.55, \"S_deep\": 34.88, \"H_S\": 720.0},\n            \"adcp_params\": {\"H_v\": 900.0, \"a\": 0.15},\n        },\n    ]\n\n    # --- Helper functions for profile calculations ---\n    def temp_profile(z, p):\n        return p[\"T_deep\"] + (p[\"T_surf\"] - p[\"T_deep\"]) * np.exp(-z / p[\"H_T\"])\n\n    def salt_profile(z, p):\n        return p[\"S_deep\"] - (p[\"S_deep\"] - p[\"S_surf\"]) * np.exp(-z / p[\"H_S\"])\n\n    def density_profile(T, S):\n        return RHO0 * (1.0 - ALPHA * (T - T0) + BETA * (S - S0))\n\n    def adcp_vel_profile(z, v_ref, z_ref, a, H_v, z_max):\n        v = np.zeros_like(z)\n        mask_upper = z = z_ref\n        mask_lower = z > z_ref\n        \n        v[mask_upper] = v_ref * (1 + a * (z_ref - z[mask_upper]) / z_ref)\n        v[mask_lower] = v_ref * np.exp(-(z[mask_lower] - z_ref) / H_v)\n        return v\n\n    all_results = []\n    \n    # Create depth grid\n    z_grid = np.arange(0, Z_MAX + DZ, DZ)\n    ref_idx = int(Z_REF / DZ)\n\n    for case in test_cases:\n        # Extract parameters for the current case\n        phi_rad = np.deg2rad(case[\"phi_deg\"])\n        L = case[\"L\"]\n        v_ref = case[\"v_ref\"]\n        s1_params = case[\"station1\"]\n        s2_params = case[\"station2\"]\n        adcp_params = case[\"adcp_params\"]\n\n        # Calculate Coriolis parameter\n        f = 2 * OMEGA * np.sin(phi_rad)\n\n        # 1. Compute Temperature, Salinity, and Density profiles\n        T1 = temp_profile(z_grid, s1_params)\n        S1 = salt_profile(z_grid, s1_params)\n        rho1 = density_profile(T1, S1)\n\n        T2 = temp_profile(z_grid, s2_params)\n        S2 = salt_profile(z_grid, s2_params)\n        rho2 = density_profile(T2, S2)\n\n        # 2. Compute geostrophic shear\n        d_rho_dx = (rho2 - rho1) / L\n        dv_dz = -(G / (f * RHO0)) * d_rho_dx\n\n        # 3. Integrate shear to get absolute geostrophic velocity\n        # The integral of shear from z_ref to z is integral(0 to z) - integral(0 to z_ref)\n        integral_dv_dz = cumulative_trapezoid(dv_dz, z_grid, initial=0)\n        v_geo = v_ref + (integral_dv_dz - integral_dv_dz[ref_idx])\n\n        # 4. Compute geostrophic transport\n        q_geo = L * trapezoid(v_geo, z_grid)\n\n        # 5. Compute ADCP-based velocity profile and transport\n        v_adcp = adcp_vel_profile(z_grid, v_ref, Z_REF, adcp_params[\"a\"], adcp_params[\"H_v\"], Z_MAX)\n        q_adcp = L * trapezoid(v_adcp, z_grid)\n\n        # 6. Compute differences\n        delta_q = q_geo - q_adcp\n        delta_frac = delta_q / q_adcp if q_adcp != 0 else np.nan\n\n        all_results.append([q_geo, q_adcp, delta_q, delta_frac])\n\n    # Format the final output string\n    formatted_cases = []\n    for res in all_results:\n        formatted_cases.append(f\"[{','.join(f'{val:.3f}' for val in res)}]\")\n    final_output_string = f\"[{','.join(formatted_cases)}]\"\n\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}