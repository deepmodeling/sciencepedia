{
    "hands_on_practices": [
        {
            "introduction": "This first practice focuses on the fundamental definition of volume transport: the integral of velocity across a section. We'll implement a numerical integration scheme on a discrete grid, a core skill in computational oceanography. This exercise will also introduce practical considerations like handling irregular grid spacing, land boundaries, and partial bottom cells, which are essential for working with realistic ocean model output .",
            "id": "3787361",
            "problem": "A rectilinear section across a basin at latitude $\\phi$ carries a meridional velocity field $v(x,z)$ in units of $\\mathrm{m/s}$ sampled on a two-dimensional node grid $\\{x_i\\}_{i=0}^{N_x-1}$ by $\\{z_k\\}_{k=0}^{N_z-1}$, where $x$ is longitude in degrees and $z$ is depth in meters (vertical coordinate positive downward). The continuous volume transport across the section is the area integral of velocity,\n$$\nT = \\int_{x_{\\min}}^{x_{\\max}} \\int_{z_{\\min}}^{z_{\\max}} v(x,z) \\,\\mathrm{d}x\\,\\mathrm{d}z,\n$$\nexpressed in Sverdrup (Sv), where $1$ Sverdrup is $10^6$ $\\mathrm{m^3/s}$. In spherical geometry along a latitude circle, the zonal line element is $\\mathrm{d}x = R \\cos\\phi \\,\\mathrm{d}\\lambda$, where $R$ is the Earth radius and $\\lambda$ is longitude in radians.\n\nYou are given the following discrete inputs:\n- A latitude $\\phi$ in degrees.\n- A longitude node array $X = [x_0, x_1, \\dots, x_{N_x-1}]$ in degrees.\n- A depth node array $Z = [z_0, z_1, \\dots, z_{N_z-1}]$ in meters.\n- A meridional velocity array $V \\in \\mathbb{R}^{N_x \\times N_z}$ with $V[i,k] = v(x_i,z_k)$ in $\\mathrm{m/s}$.\n- A land-ocean mask array $M \\in \\{0,1\\}^{N_x \\times N_z}$ with $M[i,k] = 1$ for ocean and $M[i,k] = 0$ for land at node $(x_i,z_k)$.\n- A partial-cell fraction array $H \\in [0,1]^{(N_x-1) \\times (N_z-1)}$ defined per rectangular cell $\\big([x_i,x_{i+1}] \\times [z_k,z_{k+1}]\\big)$, representing the fraction of that cell’s nominal area that is wet (for example, bottom partial cells near topography).\n\nYour task is to compute the total volume transport $T$ across the section by applying the two-dimensional composite trapezoidal rule over $x$ and $z$ with masks and partial cells. Specifically:\n- Convert longitude spacings to meters using $\\Delta x_i = R \\cos\\phi \\,\\Delta\\lambda_i$ with $\\Delta\\lambda_i = (x_{i+1}-x_i)\\times\\pi/180$ and $R = 6{,}371{,}000$ $\\mathrm{m}$.\n- Compute vertical spacings $\\Delta z_k = z_{k+1}-z_k$ in meters.\n- For each cell $(i,k)$, approximate the cell-averaged velocity by the average of the four corner node values with mask applied, i.e.,\n$$\n\\bar{v}_{i,k} = \\frac{1}{4}\\Big[V[i,k]\\,M[i,k] + V[i+1,k]\\,M[i+1,k] + V[i,k+1]\\,M[i,k+1] + V[i+1,k+1]\\,M[i+1,k+1]\\Big].\n$$\n- The wet cell area is $A_{i,k} = \\Delta x_i \\,\\Delta z_k \\, H[i,k]$, so the cell transport contribution is $A_{i,k}\\,\\bar{v}_{i,k}$.\n- Sum over all cells to obtain $T$ in $\\mathrm{m^3/s}$, then convert to Sverdrups by dividing by $10^6$.\n\nAngles must be treated in degrees as specified. All outputs must be in Sverdrups (Sv). Round each transport to $6$ decimal places.\n\nImplement a program that performs these steps for the following test suite of four cases:\n\n- Case $1$ (happy path, mixed spacings, masks, partial cells):\n  - $\\phi = 30$\n  - $X = [10.0, 10.5, 11.0, 12.0]$\n  - $Z = [0.0, 500.0, 1500.0]$\n  - $V = \\begin{bmatrix}\n  0.20  0.15  0.05\\\\\n  0.25  0.10  0.00\\\\\n  0.30  0.12  -0.02\\\\\n  0.28  0.11  -0.05\n  \\end{bmatrix}$\n  - $M = \\begin{bmatrix}\n  1  1  1\\\\\n  1  1  1\\\\\n  1  1  0\\\\\n  1  1  1\n  \\end{bmatrix}$\n  - $H = \\begin{bmatrix}\n  1.0  0.6\\\\\n  1.0  1.0\\\\\n  1.0  0.8\n  \\end{bmatrix}$\n\n- Case $2$ (all land mask yields zero transport):\n  - $\\phi = 45$\n  - $X = [0.0, 1.0, 2.0]$\n  - $Z = [0.0, 1000.0, 2000.0]$\n  - $V = \\begin{bmatrix}\n  0.10  0.05  -0.02\\\\\n  0.12  0.06  -0.01\\\\\n  0.11  0.04  0.00\n  \\end{bmatrix}$\n  - $M = \\begin{bmatrix}\n  0  0  0\\\\\n  0  0  0\\\\\n  0  0  0\n  \\end{bmatrix}$\n  - $H = \\begin{bmatrix}\n  1.0  1.0\\\\\n  1.0  1.0\n  \\end{bmatrix}$\n\n- Case $3$ (single vertical layer, constant velocity):\n  - $\\phi = 0$\n  - $X = [100.0, 100.25, 101.0]$\n  - $Z = [0.0, 300.0]$\n  - $V = \\begin{bmatrix}\n  0.10  0.10\\\\\n  0.10  0.10\\\\\n  0.10  0.10\n  \\end{bmatrix}$\n  - $M = \\begin{bmatrix}\n  1  1\\\\\n  1  1\\\\\n  1  1\n  \\end{bmatrix}$\n  - $H = \\begin{bmatrix}\n  1.0\\\\\n  1.0\n  \\end{bmatrix}$\n\n- Case $4$ (high latitude, nonuniform spacings, partial bottom cells):\n  - $\\phi = 70$\n  - $X = [0.0, 2.0, 4.0, 8.0]$\n  - $Z = [0.0, 400.0, 1200.0, 2000.0]$\n  - $V = \\begin{bmatrix}\n  0.05  0.02  -0.01  -0.03\\\\\n  0.07  0.03  0.00  -0.02\\\\\n  0.08  0.04  0.01  -0.01\\\\\n  0.06  0.02  -0.02  -0.04\n  \\end{bmatrix}$\n  - $M = \\begin{bmatrix}\n  1  1  1  1\\\\\n  1  1  1  1\\\\\n  1  1  1  1\\\\\n  1  1  1  0\n  \\end{bmatrix}$\n  - $H = \\begin{bmatrix}\n  1.0  1.0  0.7\\\\\n  1.0  0.9  0.5\\\\\n  1.0  1.0  1.0\n  \\end{bmatrix}$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[t_1,t_2,t_3,t_4]$, where each $t_i$ is the computed transport in Sv rounded to $6$ decimal places.",
            "solution": "The problem is valid. It is a well-posed, scientifically grounded problem in computational physical oceanography that is free from any of the specified invalidating flaws. The task is to compute the meridional volume transport across a rectilinear oceanic section using a specified numerical integration scheme.\n\nThe continuous formulation for the volume transport $T$ across a section is given by the area integral of the velocity component normal to that section. For a meridional velocity field $v(x,z)$ along a zonal section, this is:\n$$\nT = \\int_{x_{\\min}}^{x_{\\max}} \\int_{z_{\\min}}^{z_{\\max}} v(x,z) \\,\\mathrm{d}A\n$$\nwhere $\\mathrm{d}A = \\mathrm{d}x\\,\\mathrm{d}z$ is the differential area element. The coordinate $x$ represents the zonal distance in meters, and $z$ represents depth in meters. The velocity $v(x,z)$ is in units of $\\mathrm{m/s}$, so the transport $T$ has units of $\\mathrm{m^3/s}$.\n\nThe problem provides the velocity field and grid on a discrete set of nodes, requiring a numerical approximation of the integral. The domain is discretized into a grid of cells. The total transport $T$ is the sum of the transport contributions from each cell, $T_{i,k}$:\n$$\nT \\approx \\sum_{i=0}^{N_x-2} \\sum_{k=0}^{N_z-2} T_{i,k}\n$$\nwhere $i$ is the index for the zonal grid cells and $k$ is the index for the vertical grid cells. The transport through a single cell $(i,k)$ is the product of its effective wet area $A_{i,k}$ and the cell-averaged velocity $\\bar{v}_{i,k}$:\n$$\nT_{i,k} = A_{i,k} \\cdot \\bar{v}_{i,k}\n$$\nThe computational procedure involves determining $A_{i,k}$ and $\\bar{v}_{i,k}$ for each cell and summing their product.\n\nFirst, we calculate the wet area of each cell, $A_{i,k}$. The problem defines a grid based on longitude nodes $X = [x_0, x_1, \\dots, x_{N_x-1}]$ in degrees and depth nodes $Z = [z_0, z_1, \\dots, z_{N_z-1}]$ in meters.\nThe zonal width of a cell must be calculated in meters. For a cell between longitudes $x_i$ and $x_{i+1}$ at a constant latitude $\\phi$, the longitude difference in radians is $\\Delta\\lambda_i = (x_{i+1}-x_i) \\cdot \\frac{\\pi}{180}$. The arc length along the latitude circle is then:\n$$\n\\Delta x_i = R \\cos\\phi \\Delta\\lambda_i\n$$\nwhere the Earth's radius is $R = 6,371,000 \\, \\mathrm{m}$ and $\\phi$ is given in degrees, which must be converted to radians for the cosine function.\nThe vertical height of the cell between depths $z_k$ and $z_{k+1}$ is simply:\n$$\n\\Delta z_k = z_{k+1} - z_k\n$$\nThe nominal area of cell $(i,k)$ is $\\Delta x_i \\Delta z_k$. The problem introduces a partial-cell fraction array $H$, where $H[i,k]$ is a value in $[0,1]$ representing the fraction of the cell that is wet, accommodating complex bathymetry. Thus, the wet area of cell $(i,k)$ is:\n$$\nA_{i,k} = \\Delta x_i \\Delta z_k H[i,k]\n$$\n\nSecond, we determine the cell-averaged velocity, $\\bar{v}_{i,k}$. The problem specifies using the composite trapezoidal rule by averaging the velocity values at the four corners of the cell $(i,k)$. These corners correspond to nodes $(x_i, z_k)$, $(x_{i+1}, z_k)$, $(x_i, z_{k+1})$, and $(x_{i+1}, z_{k+1})$. The velocity data is provided in an array $V$ of size $N_x \\times N_z$. A land-ocean mask array $M \\in \\{0,1\\}^{N_x \\times N_z}$ is also provided, where $M[i,k]=0$ indicates a land node where the velocity should be treated as zero. The cell-averaged velocity is therefore:\n$$\n\\bar{v}_{i,k} = \\frac{1}{4}\\Big[V[i,k] M[i,k] + V[i+1,k] M[i+1,k] + V[i,k+1] M[i,k+1] + V[i+1,k+1] M[i+1,k+1]\\Big]\n$$\n\nWith $A_{i,k}$ and $\\bar{v}_{i,k}$ calculated for all cells, the total transport in $\\mathrm{m^3/s}$ is computed by summing the products $A_{i,k} \\bar{v}_{i,k}$. The final step is to convert the result to Sverdrups (Sv), where $1 \\, \\mathrm{Sv} = 10^6 \\, \\mathrm{m^3/s}$:\n$$\nT_{\\text{Sv}} = \\frac{T}{10^6} = \\frac{1}{10^6} \\sum_{i=0}^{N_x-2} \\sum_{k=0}^{N_z-2} A_{i,k} \\bar{v}_{i,k}\n$$\nThe final result for each test case is rounded to $6$ decimal places.\n\nThis procedure can be implemented efficiently using vectorized operations.\n1.  Compute arrays of zonal spacings $\\Delta x$ and vertical spacings $\\Delta z$.\n2.  Compute a matrix of cell wet areas $A$ using an outer product of $\\Delta x$ and $\\Delta z$, followed by element-wise multiplication with the partial-cell fraction matrix $H$.\n3.  Apply the land mask to the velocity matrix $V$ by element-wise multiplication: $V' = V \\odot M$.\n4.  Compute the matrix of cell-averaged velocities $\\bar{v}$ by summing shifted versions of $V'$ corresponding to the four corners of each cell, then dividing by $4$.\n5.  Compute the matrix of cell transports $T_{\\text{cells}} = A \\odot \\bar{v}$.\n6.  Sum all elements of $T_{\\text{cells}}$ to get the total transport $T$, convert to Sverdrups, and round.\nThis vector-based approach avoids explicit loops, leading to a more concise and computationally efficient solution.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# There is no need to import from scipy for this problem.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    R_EARTH = 6_371_000.0  # Earth radius in meters\n\n    def compute_transport(phi, X, Z, V, M, H):\n        \"\"\"\n        Computes the volume transport in Sverdrups (Sv).\n\n        Args:\n            phi (float): Latitude in degrees.\n            X (np.ndarray): Longitude nodes in degrees.\n            Z (np.ndarray): Depth nodes in meters.\n            V (np.ndarray): Meridional velocity array (m/s).\n            M (np.ndarray): Land-ocean mask array (0 or 1).\n            H (np.ndarray): Partial-cell fraction array.\n\n        Returns:\n            float: Total transport in Sv, rounded to 6 decimal places.\n        \"\"\"\n        # Convert inputs to numpy arrays\n        X = np.asarray(X, dtype=float)\n        Z = np.asarray(Z, dtype=float)\n        V = np.asarray(V, dtype=float)\n        M = np.asarray(M, dtype=float)\n        H = np.asarray(H, dtype=float)\n\n        # Step 1: Calculate grid spacings\n        # Zonal spacings in meters\n        delta_lambda_rad = np.deg2rad(np.diff(X))\n        phi_rad = np.deg2rad(phi)\n        delta_x_m = R_EARTH * np.cos(phi_rad) * delta_lambda_rad\n\n        # Vertical spacings in meters\n        delta_z_m = np.diff(Z)\n\n        # Step 2: Calculate wet cell areas\n        # Nominal areas via outer product of spacings\n        # Resulting shape is (N_x-1, N_z-1)\n        nominal_areas = np.outer(delta_x_m, delta_z_m)\n        \n        # Apply partial cell fractions to get wet areas\n        wet_areas = nominal_areas * H\n\n        # Step 3: Calculate cell-averaged velocities\n        # Apply the land-ocean mask to the velocity nodes\n        masked_V = V * M\n\n        # Average velocities over the four corners of each cell\n        # Slicing creates views of the corners for all cells simultaneously\n        v_top_left = masked_V[:-1, :-1]\n        v_top_right = masked_V[1:, :-1]\n        v_bottom_left = masked_V[:-1, 1:]\n        v_bottom_right = masked_V[1:, 1:]\n        \n        v_bar = 0.25 * (v_top_left + v_top_right + v_bottom_left + v_bottom_right)\n\n        # Step 4: Compute total transport\n        # Element-wise product of wet area and average velocity for each cell\n        cell_transports = wet_areas * v_bar\n\n        # Sum transport contributions from all cells to get total in m^3/s\n        total_transport_m3s = np.sum(cell_transports)\n\n        # Convert to Sverdrups (1 Sv = 10^6 m^3/s)\n        total_transport_sv = total_transport_m3s / 1e6\n        \n        return round(total_transport_sv, 6)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"phi\": 30,\n            \"X\": [10.0, 10.5, 11.0, 12.0],\n            \"Z\": [0.0, 500.0, 1500.0],\n            \"V\": [[0.20, 0.15, 0.05], [0.25, 0.10, 0.00], [0.30, 0.12, -0.02], [0.28, 0.11, -0.05]],\n            \"M\": [[1, 1, 1], [1, 1, 1], [1, 1, 0], [1, 1, 1]],\n            \"H\": [[1.0, 0.6], [1.0, 1.0], [1.0, 0.8]]\n        },\n        {\n            \"phi\": 45,\n            \"X\": [0.0, 1.0, 2.0],\n            \"Z\": [0.0, 1000.0, 2000.0],\n            \"V\": [[0.10, 0.05, -0.02], [0.12, 0.06, -0.01], [0.11, 0.04, 0.00]],\n            \"M\": [[0, 0, 0], [0, 0, 0], [0, 0, 0]],\n            \"H\": [[1.0, 1.0], [1.0, 1.0]]\n        },\n        {\n            \"phi\": 0,\n            \"X\": [100.0, 100.25, 101.0],\n            \"Z\": [0.0, 300.0],\n            \"V\": [[0.10, 0.10], [0.10, 0.10], [0.10, 0.10]],\n            \"M\": [[1, 1], [1, 1], [1, 1]],\n            \"H\": [[1.0], [1.0]]\n        },\n        {\n            \"phi\": 70,\n            \"X\": [0.0, 2.0, 4.0, 8.0],\n            \"Z\": [0.0, 400.0, 1200.0, 2000.0],\n            \"V\": [[0.05, 0.02, -0.01, -0.03], [0.07, 0.03, 0.00, -0.02], [0.08, 0.04, 0.01, -0.01], [0.06, 0.02, -0.02, -0.04]],\n            \"M\": [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 0]],\n            \"H\": [[1.0, 1.0, 0.7], [1.0, 0.9, 0.5], [1.0, 1.0, 1.0]]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_transport(\n            case[\"phi\"], case[\"X\"], case[\"Z\"], case[\"V\"], case[\"M\"], case[\"H\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the concept of section transport, this practice tackles a more sophisticated diagnostic: the Meridional Overturning Circulation (MOC) streamfunction, $\\Psi$. You will learn to compute this two-dimensional field by integrating velocity data first zonally across an entire ocean basin and then cumulatively in the vertical. This exercise is key to understanding how large-scale, basin-wide circulation patterns are quantified and visualized from gridded velocity data .",
            "id": "3787253",
            "problem": "You are given a gridded meridional velocity field $v(\\phi,\\lambda,z)$ defined on structured latitude-longitude-depth grids. The goal is to compute the meridional overturning streamfunction $\\Psi(\\phi,z)$ from first principles using cumulative integrals in the vertical coordinate $z$ and a zonal integral in the longitudinal coordinate $\\lambda$, and then to identify the latitude and depth at which the absolute magnitude of the overturning streamfunction attains its maximum, along with its value expressed in Sverdrups. You must implement a program that carries out this computation for a specified test suite and produces the required outputs in a single line, in a prescribed format.\n\nFundamental base and definitions:\n- The volume transport across a vertical section is defined by the area integral of the normal velocity. For a meridional velocity $v$ through an east-west section, the elemental transport is $v\\,\\mathrm{d}x\\,\\mathrm{d}z$, where $\\mathrm{d}x$ is the zonal arc length and $\\mathrm{d}z$ is the layer thickness. The zonally integrated meridional transport at a given latitude $\\phi$ and depth level $z$ is the area integral across the zonal section.\n- The meridional overturning streamfunction $\\Psi(\\phi,z)$ is defined as the cumulative vertical integral, from the bottom to depth $z$, of the zonally integrated meridional transport at latitude $\\phi$. This representation follows from mass continuity in a statistically steady, zonally averaged sense and encodes the cumulative transport above a given depth.\n- To compute $\\mathrm{d}x$ on a sphere from degree-longitude spacing at latitude $\\phi$, use the arc-length relation on a sphere with Earth radius $R$: if the longitude spacing is $\\Delta\\lambda$ in radians, then $\\mathrm{d}x(\\phi)=R\\cos(\\phi_{\\mathrm{rad}})\\,\\Delta\\lambda$, where $\\phi_{\\mathrm{rad}}$ is the latitude in radians. The Earth radius is $R=6.371\\times 10^{6}$ meters.\n\nDiscretization requirements:\n- You must approximate the zonal integral by a sum over longitude grid cells at each latitude and depth using the product of the cell-centered meridional velocity $v(\\phi_i,\\lambda_j,z_k)$, the zonal arc length $\\Delta x(\\phi_i)$, and the layer thickness $\\Delta z_k$.\n- You must approximate the cumulative vertical integral from bottom to a given depth index $k$ by a sum over all depth indices $m\\ge k$ (with increasing $z$ indicating increasing depth), at fixed latitude $\\phi_i$.\n- If a land-sea mask $M(\\phi_i,\\lambda_j)\\in\\{0,1\\}$ is provided, include only cells with $M=1$ in the zonal summations. If no mask is provided for a test case, assume $M(\\phi_i,\\lambda_j)=1$ everywhere.\n\nTarget computation:\n- For each test case, compute the zonally integrated transport at each $(\\phi_i,z_k)$ as a discrete sum of $v\\,\\Delta x\\,\\Delta z$ across all longitudes, then compute $\\Psi(\\phi_i,z_k)$ as the cumulative vertical sum from the bottom to depth index $k$ at that latitude. Find the location $(\\phi^\\ast,z^\\ast)$ where the absolute magnitude $|\\Psi|$ attains its maximum over all latitudes and depths. Report $\\phi^\\ast$ in degrees, $z^\\ast$ in meters, and the signed $\\Psi^\\ast$ value converted to Sverdrups. One Sverdrup (Sv) is $10^{6}$ cubic meters per second, so convert by dividing by $10^{6}$.\n- Express the final streamfunction values in Sverdrups (Sv), rounded to three decimal places. Express the latitude in degrees and depth in meters, using their exact grid values without rounding.\n- Tie-breaking rule: If multiple grid points share the same maximal absolute value of $|\\Psi|$ (within numerical equality), select the one with the smallest depth $z$; if ties persist, select the smallest latitude index in the provided latitude array.\n\nAngle units:\n- Input latitude and longitude grids are in degrees. For distance calculations, convert latitudes and the longitude spacing to radians. Use $\\phi_{\\mathrm{rad}}=\\phi\\cdot\\pi/180$, $\\Delta\\lambda_{\\mathrm{rad}}=\\Delta\\lambda\\cdot\\pi/180$.\n\nTest suite:\nImplement the computation for the following three test cases. In each case, the velocity $v$ is specified in meters per second, latitudes $\\phi$ and longitudes $\\lambda$ in degrees, depths $z$ as layer centers in meters with corresponding layer thicknesses $\\Delta z$ in meters, and an optional land-sea mask $M$.\n\n- Case A (general happy path with nonuniform vertical thickness and zonal modulation):\n  - Latitudes: $\\phi=\\left[-40,-20,0,20,40\\right]$ degrees.\n  - Longitudes: $\\lambda=\\left[0,3,6,9,12\\right]$ degrees, uniform spacing $\\Delta\\lambda=3$ degrees.\n  - Depth centers: $z=\\left[100,600,1200,2200,3400\\right]$ meters.\n  - Layer thicknesses: $\\Delta z=\\left[200,600,800,1000,1200\\right]$ meters.\n  - Land-sea mask: $M(\\phi_i,\\lambda_j)=1$ for all $i,j$.\n  - Velocity field:\n    $$v(\\phi,\\lambda,z)=0.05\\cdot\\cos\\left(\\frac{\\pi z}{4000}\\right)\\cdot\\exp\\left(-\\frac{\\phi_{\\mathrm{rad}}^{2}}{(0.6)^{2}}\\right)\\cdot\\left(1+0.3\\sin(\\lambda_{\\mathrm{rad}})\\right).$$\n\n- Case B (boundary case: zero flow everywhere):\n  - Latitudes: $\\phi=\\left[-10,0,10\\right]$ degrees.\n  - Longitudes: $\\lambda=\\left[0,10,20,30\\right]$ degrees, uniform spacing $\\Delta\\lambda=10$ degrees.\n  - Depth centers: $z=\\left[500,1500\\right]$ meters.\n  - Layer thicknesses: $\\Delta z=\\left[1000,2000\\right]$ meters.\n  - Land-sea mask: $M(\\phi_i,\\lambda_j)=1$ for all $i,j$.\n  - Velocity field: $v(\\phi,\\lambda,z)=0$ for all grid points.\n\n- Case C (edge case: negative flow with latitude-dependent zonal width via masking):\n  - Latitudes: $\\phi=\\left[30,35,40\\right]$ degrees.\n  - Longitudes: $\\lambda=\\left[0,2,4,6,8,10\\right]$ degrees, uniform spacing $\\Delta\\lambda=2$ degrees.\n  - Depth centers: $z=\\left[300,1200,2600\\right]$ meters.\n  - Layer thicknesses: $\\Delta z=\\left[600,1200,1800\\right]$ meters.\n  - Land-sea mask $M$:\n    - At $\\phi=30$ degrees: $M=1$ for all longitudes.\n    - At $\\phi=35$ degrees: $M=1$ for longitudes $\\lambda\\in\\left\\{0,2,4,6\\right\\}$ and $M=0$ for $\\lambda\\in\\left\\{8,10\\right\\}$.\n    - At $\\phi=40$ degrees: $M=1$ for longitudes $\\lambda\\in\\left\\{0,2,4\\right\\}$ and $M=0$ for $\\lambda\\in\\left\\{6,8,10\\right\\}$.\n  - Velocity field: $v(\\phi,\\lambda,z)=-0.02$ for all ocean grid points.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a list of the form $[\\phi^\\ast,z^\\ast,\\Psi^\\ast_{\\mathrm{Sv}}]$ where $\\phi^\\ast$ is in degrees, $z^\\ast$ is in meters, and $\\Psi^\\ast_{\\mathrm{Sv}}$ is the signed streamfunction value in Sverdrups, rounded to three decimal places. The overall output must therefore be a list of three lists:\n  - Example format: $[[\\phi_1^\\ast,z_1^\\ast,\\Psi_{1,\\mathrm{Sv}}^\\ast],[\\phi_2^\\ast,z_2^\\ast,\\Psi_{2,\\mathrm{Sv}}^\\ast],[\\phi_3^\\ast,z_3^\\ast,\\Psi_{3,\\mathrm{Sv}}^\\ast]]$.",
            "solution": "The problem requires the computation of the meridional overturning streamfunction, $\\Psi(\\phi, z)$, from a gridded meridional velocity field, $v(\\phi, \\lambda, z)$, and the identification of the location and value of its maximum absolute magnitude. The process is grounded in the principles of mass conservation in a fluid.\n\nFirst, the theoretical foundation is established. The meridional overturning streamfunction $\\Psi$ at a given latitude $\\phi$ and depth $z$ represents the net volume of water moving northward across the zonal section extending from the sea floor to depth $z$. It is defined by a cumulative vertical integral of the zonally integrated meridional transport.\n\nThe elemental volume transport through a small area $dA = dx \\, dz$ normal to the flow is $d\\mathcal{T} = v \\, dA$, where $v$ is the meridional velocity component. The zonal width element, $dx$, on a sphere of radius $R$ at latitude $\\phi$ corresponding to a small change in longitude $d\\lambda$ (in radians) is given by $dx = R \\cos(\\phi) d\\lambda$.\n\nThe problem is discretized on a structured grid with latitude indices $i \\in [0, N_\\phi-1]$, longitude indices $j \\in [0, N_\\lambda-1]$, and depth indices $k \\in [0, N_z-1]$, where $k=0$ corresponds to the shallowest layer and $z$ increases with depth.\n\nThe computational procedure is as follows:\n\n1.  **Grid and Parameter Initialization**: All provided grid data are defined: latitude coordinates $\\phi_i$, longitude coordinates $\\lambda_j$, depth layer centers $z_k$, and layer thicknesses $\\Delta z_k$. The Earth radius is taken as $R = 6.371 \\times 10^6 \\, \\text{m}$. All input angles in degrees are converted to radians for geometric calculations, e.g., $\\phi_{i, \\text{rad}} = \\phi_i \\cdot \\pi/180$.\n\n2.  **Zonal Transport Calculation**: The zonally integrated meridional transport, $T_{ik}$, in each grid cell layer $(i, k)$ is calculated. This discrete approximation of the zonal integral involves summing the transports through each grid cell across all longitudes at a fixed latitude and depth. The transport in a single cell $(\\phi_i, \\lambda_j, z_k)$ is the product of the velocity $v_{ijk} = v(\\phi_i, \\lambda_j, z_k)$, the cell's cross-sectional area $A_{ijk} = \\Delta x_i \\cdot \\Delta z_k$, and the land-sea mask $M_{ij}$. The zonal arc length for a grid cell at latitude $\\phi_i$ with longitude spacing $\\Delta\\lambda$ is constant for that latitude: $\\Delta x_i = R \\cos(\\phi_{i, \\text{rad}}) \\Delta\\lambda_{\\text{rad}}$, where $\\Delta\\lambda_{\\text{rad}} = \\Delta\\lambda \\cdot \\pi/180$.\n\n    The total zonally integrated transport for the layer at $(\\phi_i, z_k)$ is:\n    $$ T_{ik} = \\sum_{j=0}^{N_{\\lambda}-1} v_{ijk} (\\Delta x_i) (\\Delta z_k) M_{ij} = (\\Delta z_k \\Delta x_i) \\sum_{j=0}^{N_{\\lambda}-1} v_{ijk} M_{ij} $$\n    This computation results in a 2D array $T$ with dimensions $(N_\\phi \\times N_z)$.\n\n3.  **Meridional Overturning Streamfunction Calculation**: The streamfunction $\\Psi_{ik}$ at grid point $(\\phi_i, z_k)$ is defined as the cumulative sum of transports from the ocean bottom up to that depth layer. Following the problem's discretization rule, this is a sum over all depth indices $m \\ge k$:\n    $$ \\Psi_{ik} = \\sum_{m=k}^{N_z-1} T_{im} $$\n    This calculation is performed for each latitude index $i$. An efficient way to implement this is to compute a cumulative sum on the transport array $T_{i,:}$ along the depth axis, starting from the last element (the bottom). This ensures that the streamfunction at the deepest level, $\\Psi_{i, N_z-1}$, is simply the transport in that layer, $T_{i, N_z-1}$, and the streamfunction at the top layer, $\\Psi_{i, 0}$, is the integral over the full water column, $\\sum_{m=0}^{N_z-1} T_{im}$. This yields a 2D array $\\Psi$ of the same dimensions as $T$.\n\n4.  **Identification of the Maximum Absolute Value**: The primary objective is to find the grid point $(\\phi^\\ast, z^\\ast)$ where the absolute magnitude of the streamfunction, $|\\Psi_{ik}|$, is maximized.\n    - First, the maximum absolute value is determined: $|\\Psi|_{max} = \\max_{i,k} |\\Psi_{ik}|$.\n    - A set of candidate indices $\\mathcal{S} = \\{(i, k) \\mid |\\Psi_{ik}| = |\\Psi|_{max}\\}$ is identified.\n    - The specified tie-breaking procedure is applied to this set to ensure a unique solution:\n        a. Select the subset of candidates from $\\mathcal{S}$ that have the minimum depth value, $z_{k^\\ast} = \\min \\{z_k \\mid (i,k) \\in \\mathcal{S}\\}$.\n        b. If multiple candidates remain, select the one with the minimum latitude index, $i^\\ast$.\n    - The final identified indices are $(i^\\ast, k^\\ast)$.\n\n5.  **Output Formulation**: The final reported values for each test case are the latitude $\\phi^\\ast = \\phi_{i^\\ast}$ in degrees, the depth $z^\\ast = z_{k^\\ast}$ in meters, and the corresponding signed streamfunction value $\\Psi^\\ast = \\Psi_{i^\\ast, k^\\ast}$, converted to Sverdrups (Sv) by dividing by $10^6$ and rounding to three decimal places. The results from all test cases are compiled into a single list of lists as specified.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the meridional overturning streamfunction and finds its maximum\n    absolute value for a series of test cases.\n    \"\"\"\n    R_EARTH = 6.371e6  # Earth radius in meters\n    SV_CONVERSION = 1e-6  # Conversion from m^3/s to Sverdrups\n\n    # Test cases defined as a list of dictionaries\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"phi\": np.array([-40, -20, 0, 20, 40]),\n            \"lambda_\": np.array([0, 3, 6, 9, 12]),\n            \"z_centers\": np.array([100, 600, 1200, 2200, 3400]),\n            \"delta_z\": np.array([200, 600, 800, 1000, 1200]),\n            \"mask\": None,\n            \"v_func\": lambda phi_rad, lam_rad, z: 0.05 * np.cos(np.pi * z / 4000) * \\\n                                                  np.exp(-phi_rad**2 / (0.6**2)) * \\\n                                                  (1 + 0.3 * np.sin(lam_rad)),\n        },\n        {\n            \"name\": \"Case B\",\n            \"phi\": np.array([-10, 0, 10]),\n            \"lambda_\": np.array([0, 10, 20, 30]),\n            \"z_centers\": np.array([500, 1500]),\n            \"delta_z\": np.array([1000, 2000]),\n            \"mask\": None,\n            \"v_func\": lambda phi_rad, lam_rad, z: 0.0,\n        },\n        {\n            \"name\": \"Case C\",\n            \"phi\": np.array([30, 35, 40]),\n            \"lambda_\": np.array([0, 2, 4, 6, 8, 10]),\n            \"z_centers\": np.array([300, 1200, 2600]),\n            \"delta_z\": np.array([600, 1200, 1800]),\n            \"mask\": np.array([\n                [1, 1, 1, 1, 1, 1],  # phi = 30\n                [1, 1, 1, 1, 0, 0],  # phi = 35\n                [1, 1, 1, 0, 0, 0],  # phi = 40\n            ], dtype=int),\n            \"v_func\": lambda phi_rad, lam_rad, z: -0.02,\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        phi = case[\"phi\"]\n        lambda_ = case[\"lambda_\"]\n        z_centers = case[\"z_centers\"]\n        delta_z = case[\"delta_z\"]\n        mask = case[\"mask\"]\n        v_func = case[\"v_func\"]\n\n        n_phi, n_lambda, n_z = len(phi), len(lambda_), len(z_centers)\n\n        # Generate grids for calculations\n        phi_grid, lambda_grid, z_grid = np.meshgrid(phi, lambda_, z_centers, indexing='ij')\n\n        # Convert angles to radians for calculations\n        phi_rad_grid = np.deg2rad(phi_grid)\n        lambda_rad_grid = np.deg2rad(lambda_grid)\n\n        # Calculate meridional velocity field\n        v = v_func(phi_rad_grid, lambda_rad_grid, z_grid)\n\n        # Handle land-sea mask\n        if mask is None:\n            mask = np.ones((n_phi, n_lambda), dtype=int)\n        \n        # Ensure mask is broadcastable to the velocity field shape\n        mask_3d = mask[:, :, np.newaxis]\n        \n        # Apply mask to velocity\n        v_masked = v * mask_3d\n\n        # Calculate zonal arc length for each latitude\n        # Assuming uniform longitude spacing\n        delta_lambda_deg = lambda_[1] - lambda_[0] if n_lambda  1 else 0\n        delta_lambda_rad = np.deg2rad(delta_lambda_deg)\n        phi_rad_1d = np.deg2rad(phi)\n        delta_x = R_EARTH * np.cos(phi_rad_1d) * delta_lambda_rad\n\n        # Reshape for broadcasting\n        delta_x_2d = delta_x[:, np.newaxis]\n        delta_z_2d = delta_z[np.newaxis, :]\n\n        # Calculate zonally integrated transport T_ik (shape: n_phi x n_z)\n        # Sum v_masked over the longitude axis (axis 1)\n        zonal_sum_v = np.sum(v_masked, axis=1)\n        T_ik = zonal_sum_v * delta_x_2d * delta_z_2d\n        \n        # Calculate meridional overturning streamfunction Psi_ik\n        # Cumulative sum from bottom to top (along axis 1, which is depth)\n        psi = np.cumsum(T_ik[:, ::-1], axis=1)[:, ::-1]\n\n        # Find the location of the maximum absolute streamfunction value\n        abs_psi = np.abs(psi)\n        max_abs_psi = np.max(abs_psi)\n\n        # Find all indices where the max value occurs\n        candidate_indices = np.argwhere(abs_psi == max_abs_psi)\n\n        # Apply tie-breaking rule:\n        # 1. Smallest depth z\n        candidate_depth_values = z_centers[candidate_indices[:, 1]]\n        min_depth_val = np.min(candidate_depth_values)\n        depth_filtered_indices = candidate_indices[candidate_depth_values == min_depth_val]\n        \n        # 2. Smallest latitude index\n        min_lat_idx = np.min(depth_filtered_indices[:, 0])\n        \n        # Find the final winning index pair\n        final_winner = depth_filtered_indices[depth_filtered_indices[:, 0] == min_lat_idx][0]\n        i_star, k_star = final_winner[0], final_winner[1]\n\n        phi_star = phi[i_star]\n        z_star = z_centers[k_star]\n        psi_star_sv = round(psi[i_star, k_star] * SV_CONVERSION, 3)\n\n        all_results.append([phi_star, z_star, psi_star_sv])\n\n    # Format output as a string representation of a list of lists\n    result_str = \",\".join([f\"[{phi},{z},{psi}]\" for phi, z, psi in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "In the previous exercises, the velocity field was provided. This practice explores a common real-world scenario where velocity is not directly measured everywhere but is instead inferred from more easily observed quantities like temperature and salinity. You will use the thermal wind relation—a cornerstone of geostrophic dynamics—to calculate a velocity profile from hydrographic data, \"level\" it with a single reference velocity measurement, and then compute the resulting transport . This bridges the gap between dynamical theory and observational data analysis.",
            "id": "3787298",
            "problem": "You are provided with two hydrographic stations across a strait, each with temperature–salinity profiles and a single-level Acoustic Doppler Current Profiler (ADCP) reference velocity at a specified depth. Your task is to compute the absolute geostrophic transport integrated from the surface to a target depth and compare it with an ADCP-based transport under a simple, explicitly defined shape assumption for the ADCP velocity profile. You must build a complete program that carries out this computation for a set of test cases and prints the required outputs in the prescribed format.\n\nThe computation must proceed from a valid fundamental base. Use the following foundational relations and assumptions:\n\n- Hydrostatic balance: $$ \\dfrac{\\partial p}{\\partial z} = - \\rho g $$, where $ \\rho $ is density, $ p $ is pressure, $ z $ is depth (positive downward), and $ g $ is gravitational acceleration.\n- Geostrophic balance for the along-strait velocity $ v $ in the presence of a cross-strait pressure gradient: $$ f v = - \\dfrac{1}{\\rho} \\dfrac{\\partial p}{\\partial x} $$, where $ f $ is the Coriolis parameter and $ x $ is the horizontal coordinate across the strait.\n- Thermal wind relation derived from the above: $$ \\dfrac{\\partial v}{\\partial z} = - \\dfrac{g}{f \\rho_0} \\dfrac{\\partial \\rho}{\\partial x} $$, where $ \\rho_0 $ is a constant reference density.\n\nTo obtain density, employ a linearized equation of state:\n$$ \\rho(T,S) = \\rho_0 \\left[ 1 - \\alpha \\left( T - T_0 \\right) + \\beta \\left( S - S_0 \\right) \\right], $$\nwhere $ T $ is in degrees Celsius, $ S $ is in practical salinity units, $ \\alpha $ is the thermal expansion coefficient, $ \\beta $ is the haline contraction coefficient, and $ T_0 $, $ S_0 $ are reference values.\n\nYou will use the thermal wind equation to compute the vertical shear $ \\dfrac{\\partial v}{\\partial z} $ from the lateral density difference between the two stations, approximate $ \\dfrac{\\partial \\rho}{\\partial x} $ by a finite difference across the station separation $ L $, and integrate the shear vertically to obtain an absolute geostrophic velocity profile $ v(z) $ by referencing to the ADCP-measured velocity at $ z_{\\text{ref}} $. Then, integrate $ v(z) $ from $ z=0 $ to $ z=z_{\\text{max}} $ to obtain transport per unit width, and multiply by the separation $ L $ to obtain volumetric transport. Separately, construct an ADCP velocity profile using the specified shape parameters such that it matches the provided reference value at $ z_{\\text{ref}} $, integrate it in the same way, and compute the ADCP-based volumetric transport.\n\nConstants and units to be used:\n- $ g = 9.81 $ meters per second squared.\n- $ \\rho_0 = 1025 $ kilograms per cubic meter.\n- $ \\alpha = 2.0 \\times 10^{-4} $ per degree Celsius.\n- $ \\beta = 7.7 \\times 10^{-4} $ per practical salinity unit.\n- $ T_0 = 10.0 $ degrees Celsius.\n- $ S_0 = 35.0 $ practical salinity units.\n- Coriolis parameter $ f = 2 \\Omega \\sin(\\phi) $ with Earth’s rotation rate $ \\Omega = 7.2921 \\times 10^{-5} $ per second and latitude $ \\phi $ in radians.\n\nModeling assumptions:\n- The two hydrographic stations lie along the cross-strait axis, separated by distance $ L $ meters, and define the cross-strait density gradient $\\dfrac{\\partial \\rho}{\\partial x} \\approx \\dfrac{\\rho_2(z) - \\rho_1(z)}{L}$. The computed geostrophic along-strait velocity is taken as representative across the width $ L $, yielding volumetric transport by multiplying by $ L $.\n- The ADCP provides a reference absolute velocity $ v_{\\text{ref}} $ at depth $ z_{\\text{ref}} $, and the ADCP-based velocity profile $ v_{\\text{ADCP}}(z) $ is parameterized to be consistent with this reference.\n\nProfiles:\n- For each station $ i \\in \\{1,2\\} $, the temperature profile is\n$$ T_i(z) = T_{\\text{deep},i} + \\left( T_{\\text{surf},i} - T_{\\text{deep},i} \\right) \\exp\\left( - \\dfrac{z}{H_{T,i}} \\right), $$\nand the salinity profile is\n$$ S_i(z) = S_{\\text{deep},i} - \\left( S_{\\text{deep},i} - S_{\\text{surf},i} \\right) \\exp\\left( - \\dfrac{z}{H_{S,i}} \\right), $$\nwhere $ z $ is depth in meters.\n\n- The ADCP-based along-strait velocity profile is defined by\n$$ v_{\\text{ADCP}}(z) = \\begin{cases}\nv_{\\text{ref}} \\left[ 1 + a \\dfrac{z_{\\text{ref}} - z}{z_{\\text{ref}}} \\right],  0 \\le z \\le z_{\\text{ref}}, \\\\\nv_{\\text{ref}} \\exp\\left( - \\dfrac{z - z_{\\text{ref}}}{H_v} \\right),  z_{\\text{ref}} \\le z \\le z_{\\text{max}},\n\\end{cases} $$\nwhich ensures $v_{\\text{ADCP}}(z_{\\text{ref}}) = v_{\\text{ref}}$, with $ a $ dimensionless and $ H_v $ in meters.\n\nComputational steps to implement:\n1. Create a uniform depth grid $ z $ from $ 0 $ to $ z_{\\text{max}} $ meters with spacing $ \\Delta z = 10 $ meters.\n2. For each station, compute $ T_i(z) $ and $ S_i(z) $ on the depth grid, then compute $ \\rho_i(z) $ using the linearized equation of state.\n3. Compute the vertical shear of geostrophic along-strait velocity using the thermal wind relation,\n$$ \\dfrac{\\partial v}{\\partial z}(z) = - \\dfrac{g}{f \\rho_0} \\dfrac{\\rho_2(z) - \\rho_1(z)}{L}. $$\n4. Integrate $ \\dfrac{\\partial v}{\\partial z} $ vertically to obtain $ v(z) $ by enforcing $ v(z_{\\text{ref}}) = v_{\\text{ref}} $, i.e.,\n$$ v(z) = v_{\\text{ref}} + \\int_{z_{\\text{ref}}}^{z} \\dfrac{\\partial v}{\\partial z}(z') \\, dz'. $$\n5. Compute the geostrophic volumetric transport by integrating $ v(z) $ from $ 0 $ to $ z_{\\text{max}} $ and multiplying by $ L $,\n$$ Q_{\\text{geo}} = L \\int_{0}^{z_{\\text{max}}} v(z) \\, dz, $$\nexpressed in cubic meters per second.\n6. Construct $ v_{\\text{ADCP}}(z) $ using the provided $ v_{\\text{ref}} $, $ z_{\\text{ref}} $, $ a $, and $ H_v $, and compute the ADCP-based volumetric transport,\n$$ Q_{\\text{ADCP}} = L \\int_{0}^{z_{\\text{max}}} v_{\\text{ADCP}}(z) \\, dz, $$\nexpressed in cubic meters per second.\n7. For each test case, also compute the difference $\\Delta Q = Q_{\\text{geo}} - Q_{\\text{ADCP}}$ and the fractional difference $\\delta = \\dfrac{Q_{\\text{geo}} - Q_{\\text{ADCP}}}{Q_{\\text{ADCP}}}$ as a decimal.\n\nPhysical units and output requirements:\n- Express all transports $ Q_{\\text{geo}} $ and $ Q_{\\text{ADCP}} $ in cubic meters per second ($\\mathrm{m^3/s}$).\n- Express the fractional difference $ \\delta $ as a decimal.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s result is a list $[Q_{\\text{geo}}, Q_{\\text{ADCP}}, \\Delta Q, \\delta]$ formatted to three decimal places, for all test cases in order. For example: $[[1.234,0.987,0.247,0.250],[...],[...]]$.\n\nTest suite:\nUse $ z_{\\text{ref}} = 300 $ meters and $ z_{\\text{max}} = 2000 $ meters for all test cases. For each test case, the parameters are as follows:\n\n- Case $ A $ (general case):\n  - Latitude $ \\phi = 60.0 $ degrees.\n  - Station separation $ L = 20000.0 $ meters.\n  - $ v_{\\text{ref}} = 0.300 $ meters per second.\n  - Station $ 1 $: $ T_{\\text{surf},1} = 10.0 $, $ T_{\\text{deep},1} = 2.0 $, $ H_{T,1} = 400.0 $; $ S_{\\text{surf},1} = 34.60 $, $ S_{\\text{deep},1} = 34.95 $, $ H_{S,1} = 700.0 $.\n  - Station $ 2 $: $ T_{\\text{surf},2} = 9.5 $, $ T_{\\text{deep},2} = 2.2 $, $ H_{T,2} = 350.0 $; $ S_{\\text{surf},2} = 34.70 $, $ S_{\\text{deep},2} = 35.00 $, $ H_{S,2} = 650.0 $.\n  - ADCP profile parameters: $ H_v = 800.0 $, $ a = 0.20 $.\n\n- Case $ B $ (weak lateral gradient):\n  - Latitude $ \\phi = 45.0 $ degrees.\n  - Station separation $ L = 15000.0 $ meters.\n  - $ v_{\\text{ref}} = 0.050 $ meters per second.\n  - Station $ 1 $: $ T_{\\text{surf},1} = 11.0 $, $ T_{\\text{deep},1} = 2.5 $, $ H_{T,1} = 500.0 $; $ S_{\\text{surf},1} = 34.70 $, $ S_{\\text{deep},1} = 34.90 $, $ H_{S,1} = 800.0 $.\n  - Station $ 2 $: $ T_{\\text{surf},2} = 11.0 $, $ T_{\\text{deep},2} = 2.5 $, $ H_{T,2} = 500.0 $; $ S_{\\text{surf},2} = 34.71 $, $ S_{\\text{deep},2} = 34.91 $, $ H_{S,2} = 800.0 $.\n  - ADCP profile parameters: $ H_v = 600.0 $, $ a = 0.10 $.\n\n- Case $ C $ (small Coriolis parameter):\n  - Latitude $ \\phi = 5.0 $ degrees.\n  - Station separation $ L = 25000.0 $ meters.\n  - $ v_{\\text{ref}} = 0.150 $ meters per second.\n  - Station $ 1 $: $ T_{\\text{surf},1} = 12.0 $, $ T_{\\text{deep},1} = 3.0 $, $ H_{T,1} = 450.0 $; $ S_{\\text{surf},1} = 34.50 $, $ S_{\\text{deep},1} = 34.85 $, $ H_{S,1} = 700.0 $.\n  - Station $ 2 $: $ T_{\\text{surf},2} = 11.8 $, $ T_{\\text{deep},2} = 3.1 $, $ H_{T,2} = 420.0 $; $ S_{\\text{surf},2} = 34.55 $, $ S_{\\text{deep},2} = 34.88 $, $ H_{S,2} = 720.0 $.\n  - ADCP profile parameters: $ H_v = 900.0 $, $ a = 0.15 $.\n\nYour program must adhere to the specified execution environment and produce the exact output format described. No external input is permitted; all parameters are internal to the program. The final printed output is a single line containing a list of three lists, one for each test case, each with four floating-point values formatted to three decimal places, representing $[Q_{\\text{geo}}, Q_{\\text{ADCP}}, \\Delta Q, \\delta]$, in cubic meters per second (for the transport terms) and decimal (for $ \\delta $).",
            "solution": "The problem is valid as it is scientifically grounded in the principles of physical oceanography, is well-posed with sufficient information for a unique solution, and is expressed in objective, formal language. The provided parameters and equations are consistent and physically plausible.\n\nThe core of this problem lies in calculating and comparing two estimates of ocean transport across a strait: one derived from hydrographic data via the geostrophic method, and another from a simplified profile based on a direct current measurement (ADCP).\n\nThe fundamental principle is the **thermal wind relation**, which is derived by combining the equations for geostrophic and hydrostatic balance. In a continuously stratified fluid, a horizontal density gradient implies a vertical shear in the horizontal geostrophic velocity. The thermal wind equation is given as:\n$$ \\dfrac{\\partial v}{\\partial z} = - \\dfrac{g}{f \\rho_0} \\dfrac{\\partial \\rho}{\\partial x} $$\nHere, $v$ is the along-strait velocity, $z$ is the vertical coordinate (positive downwards), $g$ is the acceleration due to gravity, $f$ is the Coriolis parameter, $\\rho_0$ is a reference density, and $\\dfrac{\\partial \\rho}{\\partial x}$ is the cross-strait density gradient.\n\nThis equation provides the vertical shear, $\\dfrac{\\partial v}{\\partial z}$, but not the absolute velocity, $v(z)$. To determine the absolute velocity, we must know the velocity at some reference level. This is often called \"leveling\" the geostrophic flow. The problem provides this reference velocity, $v_{\\text{ref}}$, at a specific depth, $z_{\\text{ref}}$, from an ADCP measurement. By integrating the shear vertically from this reference depth, we can construct the absolute geostrophic velocity profile:\n$$ v(z) = v(z_{\\text{ref}}) + \\int_{z_{\\text{ref}}}^{z} \\dfrac{\\partial v}{\\partial z'}(z') \\, dz' $$\nwhere $v(z_{\\text{ref}})$ is set to $v_{\\text{ref}}$.\n\nThe density, $\\rho$, is a function of temperature $T$ and salinity $S$. A linearized equation of state is provided for this purpose:\n$$ \\rho(T,S) = \\rho_0 \\left[ 1 - \\alpha \\left( T - T_0 \\right) + \\beta \\left( S - S_0 \\right) \\right] $$\nwhere $\\alpha$ is the thermal expansion coefficient and $\\beta$ is the haline contraction coefficient.\n\nThe computational procedure is as follows:\n\n1.  **Discretization**: A uniform vertical grid, $z_j$, is established from the surface ($z=0$) to the maximum depth ($z=z_{\\text{max}}$) with a spacing of $\\Delta z = 10$ meters.\n\n2.  **Density Profile Calculation**: For each of the two hydrographic stations ($i=1, 2$), the temperature profiles $T_i(z_j)$ and salinity profiles $S_i(z_j)$ are computed at each grid point using the provided exponential functions. These are then used to calculate the corresponding density profiles, $\\rho_1(z_j)$ and $\\rho_2(z_j)$, via the linearized equation of state.\n\n3.  **Geostrophic Shear Calculation**: The continuous cross-strait density gradient $\\dfrac{\\partial \\rho}{\\partial x}$ is approximated by a finite difference across the two stations, separated by distance $L$: $\\dfrac{\\rho_2(z_j) - \\rho_1(z_j)}{L}$. Substituting this into the thermal wind equation yields the discrete vertical shear profile, $\\left(\\dfrac{\\partial v}{\\partial z}\\right)_j$. The Coriolis parameter $f$ is calculated from the given latitude $\\phi$ using $f = 2 \\Omega \\sin(\\phi)$, where $\\Omega$ is Earth's rotation rate.\n\n4.  **Absolute Geostrophic Velocity Profile**: The discrete shear profile is numerically integrated. We use the cumulative trapezoidal rule to compute the integral of the shear from the surface down. Let this be $I(z_j) = \\int_0^{z_j} \\frac{\\partial v}{\\partial z'} dz'$. The absolute velocity profile is then constructed as $v_{\\text{geo}}(z_j) = v_{\\text{ref}} + I(z_j) - I(z_{\\text{ref}})$, which ensures that $v_{\\text{geo}}(z_{\\text{ref}}) = v_{\\text{ref}}$. The depth $z_{\\text{ref}}$ aligns with a grid point, simplifying the indexing.\n\n5.  **Geostrophic Transport**: The total volumetric transport, $Q_{\\text{geo}}$, is obtained by numerically integrating the absolute velocity profile $v_{\\text{geo}}(z)$ over the depth of the strait and multiplying by the strait's width, $L$. This is computed using the trapezoidal rule:\n    $$ Q_{\\text{geo}} = L \\int_{0}^{z_{\\text{max}}} v_{\\text{geo}}(z) \\, dz \\approx L \\sum_{j} \\frac{v_{\\text{geo}}(z_j) + v_{\\text{geo}}(z_{j+1})}{2} \\Delta z $$\n\n6.  **ADCP-Based Transport**: A second, independent estimate of transport, $Q_{\\text{ADCP}}$, is calculated for comparison. This uses a prescribed, piecewise-defined velocity profile, $v_{\\text{ADCP}}(z)$, which is designed to match the reference velocity $v_{\\text{ref}}$ at $z_{\\text{ref}}$. This profile is integrated numerically over the same depth range and multiplied by the width $L$ to obtain $Q_{\\text{ADCP}}$.\n\n7.  **Comparison**: Finally, the absolute difference $\\Delta Q = Q_{\\text{geo}} - Q_{\\text{ADCP}}$ and the fractional difference $\\delta = \\Delta Q / Q_{\\text{ADCP}}$ are computed to quantify the discrepancy between the two transport estimates. This comparison highlights how different assumptions about the velocity profile's shape (geostrophic shear vs. parameterized shape) can lead to different transport values, even when anchored to the same reference velocity.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid, trapezoid\n\ndef solve():\n    \"\"\"\n    Computes and compares geostrophic and ADCP-based transports for a set of test cases.\n    \"\"\"\n    # Physical and model constants\n    G = 9.81  # m/s^2\n    RHO0 = 1025.0  # kg/m^3\n    ALPHA = 2.0e-4  # 1/C\n    BETA = 7.7e-4  # 1/psu\n    T0 = 10.0  # C\n    S0 = 35.0  # psu\n    OMEGA = 7.2921e-5  # rad/s\n\n    # Shared parameters for all test cases\n    Z_REF = 300.0  # m\n    Z_MAX = 2000.0  # m\n    DZ = 10.0  # m\n    \n    # Test cases data\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"phi_deg\": 60.0,\n            \"L\": 20000.0,\n            \"v_ref\": 0.300,\n            \"station1\": {\"T_surf\": 10.0, \"T_deep\": 2.0, \"H_T\": 400.0,\n                         \"S_surf\": 34.60, \"S_deep\": 34.95, \"H_S\": 700.0},\n            \"station2\": {\"T_surf\": 9.5, \"T_deep\": 2.2, \"H_T\": 350.0,\n                         \"S_surf\": 34.70, \"S_deep\": 35.00, \"H_S\": 650.0},\n            \"adcp_params\": {\"H_v\": 800.0, \"a\": 0.20},\n        },\n        {\n            \"name\": \"B\",\n            \"phi_deg\": 45.0,\n            \"L\": 15000.0,\n            \"v_ref\": 0.050,\n            \"station1\": {\"T_surf\": 11.0, \"T_deep\": 2.5, \"H_T\": 500.0,\n                         \"S_surf\": 34.70, \"S_deep\": 34.90, \"H_S\": 800.0},\n            \"station2\": {\"T_surf\": 11.0, \"T_deep\": 2.5, \"H_T\": 500.0,\n                         \"S_surf\": 34.71, \"S_deep\": 34.91, \"H_S\": 800.0},\n            \"adcp_params\": {\"H_v\": 600.0, \"a\": 0.10},\n        },\n        {\n            \"name\": \"C\",\n            \"phi_deg\": 5.0,\n            \"L\": 25000.0,\n            \"v_ref\": 0.150,\n            \"station1\": {\"T_surf\": 12.0, \"T_deep\": 3.0, \"H_T\": 450.0,\n                         \"S_surf\": 34.50, \"S_deep\": 34.85, \"H_S\": 700.0},\n            \"station2\": {\"T_surf\": 11.8, \"T_deep\": 3.1, \"H_T\": 420.0,\n                         \"S_surf\": 34.55, \"S_deep\": 34.88, \"H_S\": 720.0},\n            \"adcp_params\": {\"H_v\": 900.0, \"a\": 0.15},\n        },\n    ]\n\n    # --- Helper functions for profile calculations ---\n    def temp_profile(z, p):\n        return p[\"T_deep\"] + (p[\"T_surf\"] - p[\"T_deep\"]) * np.exp(-z / p[\"H_T\"])\n\n    def salt_profile(z, p):\n        return p[\"S_deep\"] - (p[\"S_deep\"] - p[\"S_surf\"]) * np.exp(-z / p[\"H_S\"])\n\n    def density_profile(T, S):\n        return RHO0 * (1.0 - ALPHA * (T - T0) + BETA * (S - S0))\n\n    def adcp_vel_profile(z, v_ref, z_ref, a, H_v, z_max):\n        v = np.zeros_like(z)\n        mask_upper = z = z_ref\n        mask_lower = z  z_ref\n        \n        v[mask_upper] = v_ref * (1 + a * (z_ref - z[mask_upper]) / z_ref)\n        v[mask_lower] = v_ref * np.exp(-(z[mask_lower] - z_ref) / H_v)\n        return v\n\n    all_results = []\n    \n    # Create depth grid\n    z_grid = np.arange(0, Z_MAX + DZ, DZ)\n    ref_idx = int(Z_REF / DZ)\n\n    for case in test_cases:\n        # Extract parameters for the current case\n        phi_rad = np.deg2rad(case[\"phi_deg\"])\n        L = case[\"L\"]\n        v_ref = case[\"v_ref\"]\n        s1_params = case[\"station1\"]\n        s2_params = case[\"station2\"]\n        adcp_params = case[\"adcp_params\"]\n\n        # Calculate Coriolis parameter\n        f = 2 * OMEGA * np.sin(phi_rad)\n\n        # 1. Compute Temperature, Salinity, and Density profiles\n        T1 = temp_profile(z_grid, s1_params)\n        S1 = salt_profile(z_grid, s1_params)\n        rho1 = density_profile(T1, S1)\n\n        T2 = temp_profile(z_grid, s2_params)\n        S2 = salt_profile(z_grid, s2_params)\n        rho2 = density_profile(T2, S2)\n\n        # 2. Compute geostrophic shear\n        d_rho_dx = (rho2 - rho1) / L\n        dv_dz = -(G / (f * RHO0)) * d_rho_dx\n\n        # 3. Integrate shear to get absolute geostrophic velocity\n        # The integral of shear from z_ref to z is integral(0 to z) - integral(0 to z_ref)\n        integral_dv_dz = cumulative_trapezoid(dv_dz, z_grid, initial=0)\n        v_geo = v_ref + (integral_dv_dz - integral_dv_dz[ref_idx])\n\n        # 4. Compute geostrophic transport\n        q_geo = L * trapezoid(v_geo, z_grid)\n\n        # 5. Compute ADCP-based velocity profile and transport\n        v_adcp = adcp_vel_profile(z_grid, v_ref, Z_REF, adcp_params[\"a\"], adcp_params[\"H_v\"], Z_MAX)\n        q_adcp = L * trapezoid(v_adcp, z_grid)\n\n        # 6. Compute differences\n        delta_q = q_geo - q_adcp\n        delta_frac = delta_q / q_adcp if q_adcp != 0 else np.nan\n\n        all_results.append([q_geo, q_adcp, delta_q, delta_frac])\n\n    # Format the final output string\n    formatted_cases = []\n    for res in all_results:\n        formatted_cases.append(f\"[{','.join(f'{val:.3f}' for val in res)}]\")\n    final_output_string = f\"[{','.join(formatted_cases)}]\"\n\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}