{
    "hands_on_practices": [
        {
            "introduction": "第一个实践是一项基石技能：当速度场在离散网格上已知时，计算穿过海洋断面的总体积输运。本练习强调了海洋学中数值积分的实际挑战，例如处理球坐标系下的不规则网格间距，使用掩码考虑陆地边界，以及通过部分单元格表示复杂的海底地形。在着手更复杂的诊断分析之前，掌握这项技能至关重要。",
            "id": "3787361",
            "problem": "在纬度 $\\phi$ 处，一个跨越海盆的直线剖面承载着一个经向速度场 $v(x,z)$，单位为 $\\mathrm{m/s}$。该速度场在一个二维节点网格 $\\{x_i\\}_{i=0}^{N_x-1}$ × $\\{z_k\\}_{k=0}^{N_z-1}$ 上采样，其中 $x$ 是经度（单位为度），$z$ 是深度（单位为米，垂直坐标向下为正）。穿过该剖面的连续体积输运是速度的面积分，\n$$\nT = \\int_{x_{\\min}}^{x_{\\max}} \\int_{z_{\\min}}^{z_{\\max}} v(x,z) \\,\\mathrm{d}x\\,\\mathrm{d}z,\n$$\n以 Sverdrup (Sv) 为单位表示，其中 1 Sverdrup 为 $10^6$ $\\mathrm{m^3/s}$。在沿纬度圈的球面几何中，纬向线元为 $\\mathrm{d}x = R \\cos\\phi \\,\\mathrm{d}\\lambda$，其中 $R$ 是地球半径，$\\lambda$ 是经度（单位为弧度）。\n\n给定以下离散输入：\n- 纬度 $\\phi$，单位为度。\n- 经度节点数组 $X = [x_0, x_1, \\dots, x_{N_x-1}]$，单位为度。\n- 深度节点数组 $Z = [z_0, z_1, \\dots, z_{N_z-1}]$，单位为米。\n- 经向速度数组 $V \\in \\mathbb{R}^{N_x \\times N_z}$，其中 $V[i,k] = v(x_i,z_k)$，单位为 $\\mathrm{m/s}$。\n- 陆海掩码数组 $M \\in \\{0,1\\}^{N_x \\times N_z}$，在节点 $(x_i,z_k)$ 处，$M[i,k] = 1$ 表示海洋，$M[i,k] = 0$ 表示陆地。\n- 部分单元格分数数组 $H \\in [0,1]^{(N_x-1) \\times (N_z-1)}$，为每个矩形单元格 $\\big([x_i,x_{i+1}] \\times [z_k,z_{k+1}]\\big)$ 定义，表示该单元格名义面积中为湿润区域的比例（例如，地形附近的底部部分单元格）。\n\n你的任务是通过在 $x$ 和 $z$ 上应用带有掩码和部分单元格的二维复合梯形法则，计算穿过该剖面的总体积输运 $T$。具体来说：\n- 使用 $\\Delta x_i = R \\cos\\phi \\,\\Delta\\lambda_i$ 将经度间距转换为米，其中 $\\Delta\\lambda_i = (x_{i+1}-x_i)\\times\\pi/180$ 且 $R = 6{,}371{,}000$ $\\mathrm{m}$。\n- 计算垂直间距 $\\Delta z_k = z_{k+1}-z_k$，单位为米。\n- 对于每个单元格 $(i,k)$，通过应用掩码后四个角节点值的平均值来近似单元格平均速度，即：\n$$\n\\bar{v}_{i,k} = \\frac{1}{4}\\Big[V[i,k]\\,M[i,k] + V[i+1,k]\\,M[i+1,k] + V[i,k+1]\\,M[i,k+1] + V[i+1,k+1]\\,M[i+1,k+1]\\Big].\n$$\n- 湿润单元格面积为 $A_{i,k} = \\Delta x_i \\,\\Delta z_k \\, H[i,k]$，因此单元格输运贡献为 $A_{i,k}\\,\\bar{v}_{i,k}$。\n- 对所有单元格求和以获得单位为 $\\mathrm{m^3/s}$ 的 $T$，然后除以 $10^6$ 转换为 Sverdrups。\n\n角度必须按规定以度为单位处理。所有输出必须以 Sverdrups (Sv) 为单位。将每次输运结果四舍五入到小数点后 $6$ 位。\n\n实现一个程序，对以下四个测试用例执行这些步骤：\n\n- 案例 1（正常路径，混合间距、掩码、部分单元格）：\n  - $\\phi = 30$\n  - $X = [10.0, 10.5, 11.0, 12.0]$\n  - $Z = [0.0, 500.0, 1500.0]$\n  - $V = \\begin{bmatrix}\n  0.20  0.15  0.05\\\\\n  0.25  0.10  0.00\\\\\n  0.30  0.12  -0.02\\\\\n  0.28  0.11  -0.05\n  \\end{bmatrix}$\n  - $M = \\begin{bmatrix}\n  1  1  1\\\\\n  1  1  1\\\\\n  1  1  0\\\\\n  1  1  1\n  \\end{bmatrix}$\n  - $H = \\begin{bmatrix}\n  1.0  0.6\\\\\n  1.0  1.0\\\\\n  1.0  0.8\n  \\end{bmatrix}$\n\n- 案例 2（全陆地掩码产生零输运）：\n  - $\\phi = 45$\n  - $X = [0.0, 1.0, 2.0]$\n  - $Z = [0.0, 1000.0, 2000.0]$\n  - $V = \\begin{bmatrix}\n  0.10  0.05  -0.02\\\\\n  0.12  0.06  -0.01\\\\\n  0.11  0.04  0.00\n  \\end{bmatrix}$\n  - $M = \\begin{bmatrix}\n  0  0  0\\\\\n  0  0  0\\\\\n  0  0  0\n  \\end{bmatrix}$\n  - $H = \\begin{bmatrix}\n  1.0  1.0\\\\\n  1.0  1.0\n  \\end{bmatrix}$\n\n- 案例 3（单垂直层，恒定速度）：\n  - $\\phi = 0$\n  - $X = [100.0, 100.25, 101.0]$\n  - $Z = [0.0, 300.0]$\n  - $V = \\begin{bmatrix}\n  0.10  0.10\\\\\n  0.10  0.10\\\\\n  0.10  0.10\n  \\end{bmatrix}$\n  - $M = \\begin{bmatrix}\n  1  1\\\\\n  1  1\\\\\n  1  1\n  \\end{bmatrix}$\n  - $H = \\begin{bmatrix}\n  1.0\\\\\n  1.0\n  \\end{bmatrix}$\n\n- 案例 4（高纬度，非均匀间距，部分底部单元格）：\n  - $\\phi = 70$\n  - $X = [0.0, 2.0, 4.0, 8.0]$\n  - $Z = [0.0, 400.0, 1200.0, 2000.0]$\n  - $V = \\begin{bmatrix}\n  0.05  0.02  -0.01  -0.03\\\\\n  0.07  0.03  0.00  -0.02\\\\\n  0.08  0.04  0.01  -0.01\\\\\n  0.06  0.02  -0.02  -0.04\n  \\end{bmatrix}$\n  - $M = \\begin{bmatrix}\n  1  1  1  1\\\\\n  1  1  1  1\\\\\n  1  1  1  1\\\\\n  1  1  1  0\n  \\end{bmatrix}$\n  - $H = \\begin{bmatrix}\n  1.0  1.0  0.7\\\\\n  1.0  0.9  0.5\\\\\n  1.0  1.0  1.0\n  \\end{bmatrix}$\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[t_1,t_2,t_3,t_4]$，其中每个 $t_i$ 是以 Sv 为单位计算并四舍五入到小数点后 6 位的输运量。",
            "solution": "该问题是有效的。这是一个在计算物理海洋学中适定且有科学依据的问题，没有任何指定的无效缺陷。任务是使用指定的数值积分方案计算穿过一个直线海洋剖面的经向体积输运。\n\n穿过一个剖面的体积输运 $T$ 的连续公式由垂直于该剖面的速度分量的面积分给出。对于沿纬向剖面的经向速度场 $v(x,z)$，公式为：\n$$\nT = \\int_{x_{\\min}}^{x_{\\max}} \\int_{z_{\\min}}^{z_{\\max}} v(x,z) \\,\\mathrm{d}A\n$$\n其中 $\\mathrm{d}A = \\mathrm{d}x\\,\\mathrm{d}z$ 是微分面积元。坐标 $x$ 代表纬向距离（单位为米），$z$ 代表深度（单位为米）。速度 $v(x,z)$ 的单位是 $\\mathrm{m/s}$，所以输运 $T$ 的单位是 $\\mathrm{m^3/s}$。\n\n该问题在离散节点集上提供了速度场和网格，需要对积分进行数值近似。区域被离散化为单元格网格。总输运 $T$ 是每个单元格 $T_{i,k}$ 的输运贡献之和：\n$$\nT \\approx \\sum_{i=0}^{N_x-2} \\sum_{k=0}^{N_z-2} T_{i,k}\n$$\n其中 $i$ 是纬向网格单元的索引，$k$ 是垂直网格单元的索引。通过单个单元格 $(i,k)$ 的输运是其有效湿润面积 $A_{i,k}$ 和单元格平均速度 $\\bar{v}_{i,k}$ 的乘积：\n$$\nT_{i,k} = A_{i,k} \\cdot \\bar{v}_{i,k}\n$$\n计算过程涉及确定每个单元格的 $A_{i,k}$ 和 $\\bar{v}_{i,k}$，并对它们的乘积求和。\n\n首先，我们计算每个单元格的湿润面积 $A_{i,k}$。问题定义了一个基于经度节点 $X = [x_0, x_1, \\dots, x_{N_x-1}]$（单位为度）和深度节点 $Z = [z_0, z_1, \\dots, z_{N_z-1}]$（单位为米）的网格。单元格的纬向宽度必须以米为单位计算。对于在恒定纬度 $\\phi$ 下，经度在 $x_i$ 和 $x_{i+1}$ 之间的单元格，其经度差（以弧度为单位）为 $\\Delta\\lambda_i = (x_{i+1}-x_i) \\cdot \\frac{\\pi}{180}$。沿纬度圈的弧长则为：\n$$\n\\Delta x_i = R \\cos\\phi \\Delta\\lambda_i\n$$\n其中地球半径 $R = 6,371,000 \\, \\mathrm{m}$，$\\phi$ 以度为单位给出，在余弦函数中必须转换为弧度。深度在 $z_k$ 和 $z_{k+1}$ 之间的单元格的垂直高度就是：\n$$\n\\Delta z_k = z_{k+1} - z_k\n$$\n单元格 $(i,k)$ 的名义面积是 $\\Delta x_i \\Delta z_k$。问题引入了一个部分单元格分数数组 $H$，其中 $H[i,k]$ 是一个在 $[0,1]$ 范围内的值，表示单元格中为湿润区域的比例，以适应复杂的海底地形。因此，单元格 $(i,k)$ 的湿润面积为：\n$$\nA_{i,k} = \\Delta x_i \\Delta z_k H[i,k]\n$$\n\n其次，我们确定单元格平均速度 $\\bar{v}_{i,k}$。问题指定使用复合梯形法则，通过对单元格 $(i,k)$ 四个角点的速度值求平均来计算。这些角点对应于节点 $(x_i, z_k)$, $(x_{i+1}, z_k)$, $(x_i, z_{k+1})$ 和 $(x_{i+1}, z_{k+1})$。速度数据在一个大小为 $N_x \\times N_z$ 的数组 $V$ 中提供。同时提供了一个陆海掩码数组 $M \\in \\{0,1\\}^{N_x \\times N_z}$，其中 $M[i,k]=0$ 表示一个陆地节点，其速度应视为零。因此，单元格平均速度为：\n$$\n\\bar{v}_{i,k} = \\frac{1}{4}\\Big[V[i,k] M[i,k] + V[i+1,k] M[i+1,k] + V[i,k+1] M[i,k+1] + V[i+1,k+1] M[i+1,k+1]\\Big]\n$$\n\n在计算出所有单元格的 $A_{i,k}$ 和 $\\bar{v}_{i,k}$ 后，通过对乘积 $A_{i,k} \\bar{v}_{i,k}$ 求和来计算总输运（单位为 $\\mathrm{m^3/s}$）。最后一步是将结果转换为 Sverdrups (Sv)，其中 $1 \\, \\mathrm{Sv} = 10^6 \\, \\mathrm{m^3/s}$：\n$$\nT_{\\text{Sv}} = \\frac{T}{10^6} = \\frac{1}{10^6} \\sum_{i=0}^{N_x-2} \\sum_{k=0}^{N_z-2} A_{i,k} \\bar{v}_{i,k}\n$$\n每个测试用例的最终结果四舍五入到小数点后 6 位。\n\n这个过程可以使用矢量化操作高效地实现。\n1.  计算纬向间距 $\\Delta x$ 和垂直间距 $\\Delta z$ 的数组。\n2.  使用 $\\Delta x$ 和 $\\Delta z$ 的外积计算单元格湿润面积矩阵 $A$，然后与部分单元格分数矩阵 $H$ 进行逐元素相乘。\n3.  通过逐元素相乘将陆地掩码应用于速度矩阵 $V$：$V' = V \\odot M$。\n4.  通过对与每个单元格四个角点相对应的 $V'$ 的移位版本求和，然后除以 $4$，来计算单元格平均速度矩阵 $\\bar{v}$。\n5.  计算单元格输运矩阵 $T_{\\text{cells}} = A \\odot \\bar{v}$。\n6.  对 $T_{\\text{cells}}$ 的所有元素求和以获得总输运 $T$，转换为 Sverdrups，并四舍五入。\n这种基于矢量的方法避免了显式循环，从而得到一个更简洁且计算效率高的解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# There is no need to import from scipy for this problem.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    R_EARTH = 6_371_000.0  # Earth radius in meters\n\n    def compute_transport(phi, X, Z, V, M, H):\n        \"\"\"\n        Computes the volume transport in Sverdrups (Sv).\n\n        Args:\n            phi (float): Latitude in degrees.\n            X (np.ndarray): Longitude nodes in degrees.\n            Z (np.ndarray): Depth nodes in meters.\n            V (np.ndarray): Meridional velocity array (m/s).\n            M (np.ndarray): Land-ocean mask array (0 or 1).\n            H (np.ndarray): Partial-cell fraction array.\n\n        Returns:\n            float: Total transport in Sv, rounded to 6 decimal places.\n        \"\"\"\n        # Convert inputs to numpy arrays\n        X = np.asarray(X, dtype=float)\n        Z = np.asarray(Z, dtype=float)\n        V = np.asarray(V, dtype=float)\n        M = np.asarray(M, dtype=float)\n        H = np.asarray(H, dtype=float)\n\n        # Step 1: Calculate grid spacings\n        # Zonal spacings in meters\n        delta_lambda_rad = np.deg2rad(np.diff(X))\n        phi_rad = np.deg2rad(phi)\n        delta_x_m = R_EARTH * np.cos(phi_rad) * delta_lambda_rad\n\n        # Vertical spacings in meters\n        delta_z_m = np.diff(Z)\n\n        # Step 2: Calculate wet cell areas\n        # Nominal areas via outer product of spacings\n        # Resulting shape is (N_x-1, N_z-1)\n        nominal_areas = np.outer(delta_x_m, delta_z_m)\n        \n        # Apply partial cell fractions to get wet areas\n        wet_areas = nominal_areas * H\n\n        # Step 3: Calculate cell-averaged velocities\n        # Apply the land-ocean mask to the velocity nodes\n        masked_V = V * M\n\n        # Average velocities over the four corners of each cell\n        # Slicing creates views of the corners for all cells simultaneously\n        v_top_left = masked_V[:-1, :-1]\n        v_top_right = masked_V[1:, :-1]\n        v_bottom_left = masked_V[:-1, 1:]\n        v_bottom_right = masked_V[1:, 1:]\n        \n        v_bar = 0.25 * (v_top_left + v_top_right + v_bottom_left + v_bottom_right)\n\n        # Step 4: Compute total transport\n        # Element-wise product of wet area and average velocity for each cell\n        cell_transports = wet_areas * v_bar\n\n        # Sum transport contributions from all cells to get total in m^3/s\n        total_transport_m3s = np.sum(cell_transports)\n\n        # Convert to Sverdrups (1 Sv = 10^6 m^3/s)\n        total_transport_sv = total_transport_m3s / 1e6\n        \n        return round(total_transport_sv, 6)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"phi\": 30,\n            \"X\": [10.0, 10.5, 11.0, 12.0],\n            \"Z\": [0.0, 500.0, 1500.0],\n            \"V\": [[0.20, 0.15, 0.05], [0.25, 0.10, 0.00], [0.30, 0.12, -0.02], [0.28, 0.11, -0.05]],\n            \"M\": [[1, 1, 1], [1, 1, 1], [1, 1, 0], [1, 1, 1]],\n            \"H\": [[1.0, 0.6], [1.0, 1.0], [1.0, 0.8]]\n        },\n        {\n            \"phi\": 45,\n            \"X\": [0.0, 1.0, 2.0],\n            \"Z\": [0.0, 1000.0, 2000.0],\n            \"V\": [[0.10, 0.05, -0.02], [0.12, 0.06, -0.01], [0.11, 0.04, 0.00]],\n            \"M\": [[0, 0, 0], [0, 0, 0], [0, 0, 0]],\n            \"H\": [[1.0, 1.0], [1.0, 1.0]]\n        },\n        {\n            \"phi\": 0,\n            \"X\": [100.0, 100.25, 101.0],\n            \"Z\": [0.0, 300.0],\n            \"V\": [[0.10, 0.10], [0.10, 0.10], [0.10, 0.10]],\n            \"M\": [[1, 1], [1, 1], [1, 1]],\n            \"H\": [[1.0], [1.0]]\n        },\n        {\n            \"phi\": 70,\n            \"X\": [0.0, 2.0, 4.0, 8.0],\n            \"Z\": [0.0, 400.0, 1200.0, 2000.0],\n            \"V\": [[0.05, 0.02, -0.01, -0.03], [0.07, 0.03, 0.00, -0.02], [0.08, 0.04, 0.01, -0.01], [0.06, 0.02, -0.02, -0.04]],\n            \"M\": [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 0]],\n            \"H\": [[1.0, 1.0, 0.7], [1.0, 0.9, 0.5], [1.0, 1.0, 1.0]]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_transport(\n            case[\"phi\"], case[\"X\"], case[\"Z\"], case[\"V\"], case[\"M\"], case[\"H\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在输运积分概念的基础上，本练习旨在计算经向翻转环流（MOC）流函数 $\\Psi$。这个关键的诊断工具能够将大规模、全海盆的垂向环流可视化。该实践涉及对三维速度场进行纬向积分和累积的垂向积分，从而完整地描绘出 MOC 的结构与强度。",
            "id": "3787253",
            "problem": "给定一个在结构化经纬度-深度网格上定义的网格化经向速度场 $v(\\phi,\\lambda,z)$。目标是根据第一性原理，通过在垂直坐标 $z$ 上的累积积分和在经度坐标 $\\lambda$ 上的纬向积分，计算经向翻转流函数 $\\Psi(\\phi,z)$，然后确定翻转流函数绝对值达到最大值时的纬度和深度，及其以斯维尔德鲁普（Sverdrups）为单位表示的数值。您必须实现一个程序，对指定的测试套件执行此计算，并按规定格式单行输出所需结果。\n\n基本原理和定义：\n- 穿过一个垂直截面的体积输送被定义为法向速度的面积分。对于穿过东西向截面的经向速度 $v$，元输送为 $v\\,\\mathrm{d}x\\,\\mathrm{d}z$，其中 $\\mathrm{d}x$ 是纬向弧长，$\\mathrm{d}z$ 是层厚。在给定纬度 $\\phi$ 和深度 $z$ 处的纬向积分经向输送是跨越该纬向截面的面积分。\n- 经向翻转流函数 $\\Psi(\\phi,z)$ 定义为在纬度 $\\phi$ 处，对纬向积分的经向输送从底部到深度 $z$ 的累积垂直积分。此表示方法源于统计稳态、纬向平均意义上的质量连续性，并编码了在给定深度及以下的累积输送。\n- 要在球体上根据经度间距在纬度 $\\phi$ 处计算 $\\mathrm{d}x$，使用地球半径为 $R$ 的球体上的弧长关系：如果经度间距为 $\\Delta\\lambda$（弧度），则 $\\mathrm{d}x(\\phi)=R\\cos(\\phi_{\\mathrm{rad}})\\,\\Delta\\lambda$，其中 $\\phi_{\\mathrm{rad}}$ 是以弧度表示的纬度。地球半径为 $R=6.371\\times 10^{6}$ 米。\n\n离散化要求：\n- 您必须通过在每个纬度和深度上对所有经度网格单元求和来近似纬向积分，求和项为中心位于该单元的经向速度 $v(\\phi_i,\\lambda_j,z_k)$、纬向弧长 $\\Delta x(\\phi_i)$ 和层厚度 $\\Delta z_k$ 的乘积。\n- 您必须通过在固定纬度 $\\phi_i$ 上，对所有深度指数 $m\\ge k$ (其中 $z$ 增加表示深度增加) 求和来近似从底部到给定深度指数 $k$ 的累积垂直积分。\n- 如果提供了海陆掩码 $M(\\phi_i,\\lambda_j)\\in\\{0,1\\}$，则在纬向求和中仅包括 $M=1$ 的单元格。如果测试用例未提供掩码，则假定所有位置 $M(\\phi_i,\\lambda_j)=1$。\n\n目标计算：\n- 对于每个测试用例，首先计算每个 $(\\phi_i,z_k)$ 处的纬向积分输送，即在所有经度上对 $v\\,\\Delta x\\,\\Delta z$ 进行离散求和，然后计算 $\\Psi(\\phi_i,z_k)$，即在该纬度上从底部到深度指数 $k$ 的累积垂直和。找出绝对值 $|\\Psi|$ 在所有纬度和深度上达到其最大值的位置 $(\\phi^\\ast,z^\\ast)$。报告 $\\phi^\\ast$（单位为度）、$z^\\ast$（单位为米）以及转换成斯维尔德鲁普单位的有符号 $\\Psi^\\ast$ 值。一斯维尔德鲁普 (Sv) 等于 $10^{6}$ 立方米/秒，因此通过除以 $10^{6}$ 进行转换。\n- 最终的流函数值以斯维尔德鲁普 (Sv) 为单位表示，并四舍五入到三位小数。纬度以度为单位，深度以米为单位，使用其精确的网格值，无需四舍五入。\n- 平局决胜规则：如果多个网格点的 $|\\Psi|$ 绝对值相同（在数值精度范围内），则选择深度 $z$ 最小的那个；如果仍然存在平局，则选择所提供的纬度数组中纬度指数最小的那个。\n\n角度单位：\n- 输入的纬度和经度网格以度为单位。为了进行距离计算，需将纬度和经度间距转换为弧度。使用 $\\phi_{\\mathrm{rad}}=\\phi\\cdot\\pi/180$，$\\Delta\\lambda_{\\mathrm{rad}}=\\Delta\\lambda\\cdot\\pi/180$。\n\n测试套件：\n为以下三个测试用例实现计算。在每个案例中，速度 $v$ 以米/秒为单位指定，纬度 $\\phi$ 和经度 $\\lambda$ 以度为单位，深度 $z$ 为层中心（单位为米）及其对应的层厚度 $\\Delta z$（单位为米），以及一个可选的海陆掩码 $M$。\n\n- 案例 A（具有非均匀垂直厚度和纬向调制的通用成功路径）：\n  - 纬度: $\\phi=\\left[-40,-20,0,20,40\\right]$ 度。\n  - 经度: $\\lambda=\\left[0,3,6,9,12\\right]$ 度，均匀间距 $\\Delta\\lambda=3$ 度。\n  - 深度中心: $z=\\left[100,600,1200,2200,3400\\right]$ 米。\n  - 层厚度: $\\Delta z=\\left[200,600,800,1000,1200\\right]$ 米。\n  - 海陆掩码: 对所有 $i,j$，$M(\\phi_i,\\lambda_j)=1$。\n  - 速度场:\n    $$v(\\phi,\\lambda,z)=0.05\\cdot\\cos\\left(\\frac{\\pi z}{4000}\\right)\\cdot\\exp\\left(-\\frac{\\phi_{\\mathrm{rad}}^{2}}{(0.6)^{2}}\\right)\\cdot\\left(1+0.3\\sin(\\lambda_{\\mathrm{rad}})\\right).$$\n\n- 案例 B（边界情况：处处为零流）：\n  - 纬度: $\\phi=\\left[-10,0,10\\right]$ 度。\n  - 经度: $\\lambda=\\left[0,10,20,30\\right]$ 度，均匀间距 $\\Delta\\lambda=10$ 度。\n  - 深度中心: $z=\\left[500,1500\\right]$ 米。\n  - 层厚度: $\\Delta z=\\left[1000,2000\\right]$ 米。\n  - 海陆掩码: 对所有 $i,j$，$M(\\phi_i,\\lambda_j)=1$。\n  - 速度场: 对所有网格点 $v(\\phi,\\lambda,z)=0$。\n\n- 案例 C（边缘情况：通过掩码实现纬度相关的纬向宽度的负流）：\n  - 纬度: $\\phi=\\left[30,35,40\\right]$ 度。\n  - 经度: $\\lambda=\\left[0,2,4,6,8,10\\right]$ 度，均匀间距 $\\Delta\\lambda=2$ 度。\n  - 深度中心: $z=\\left[300,1200,2600\\right]$ 米。\n  - 层厚度: $\\Delta z=\\left[600,1200,1800\\right]$ 米。\n  - 海陆掩码 $M$:\n    - 在 $\\phi=30$ 度处: 对所有经度，$M=1$。\n    - 在 $\\phi=35$ 度处: 对经度 $\\lambda \\in \\{0,2,4,6\\}$，$M=1$；对 $\\lambda \\in \\{8,10\\}$，$M=0$。\n    - 在 $\\phi=40$ 度处: 对经度 $\\lambda \\in \\{0,2,4\\}$，$M=1$；对 $\\lambda \\in \\{6,8,10\\}$，$M=0$。\n  - 速度场: 对所有海洋网格点，$v(\\phi,\\lambda,z)=-0.02$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是 $\\left[\\phi^\\ast,z^\\ast,\\Psi^\\ast_{\\mathrm{Sv}}\\right]$ 形式的列表，其中 $\\phi^\\ast$ 以度为单位， $z^\\ast$ 以米为单位，$\\Psi^\\ast_{\\mathrm{Sv}}$ 是以斯维尔德鲁普为单位的有符号流函数值，四舍五入到三位小数。因此，总输出必须是包含三个列表的列表：\n  - 示例格式: $\\left[[\\phi_1^\\ast,z_1^\\ast,\\Psi_{1,\\mathrm{Sv}}^\\ast],[\\phi_2^\\ast,z_2^\\ast,\\Psi_{2,\\mathrm{Sv}}^\\ast],[\\phi_3^\\ast,z_3^\\ast,\\Psi_{3,\\mathrm{Sv}}^\\ast]\\right]$。",
            "solution": "该问题要求根据网格化的经向速度场 $v(\\phi, \\lambda, z)$ 计算经向翻转流函数 $\\Psi(\\phi, z)$，并找出其绝对值最大值的位置和数值。该过程基于流体质量守恒的原理。\n\n首先，建立理论基础。在给定纬度 $\\phi$ 和深度 $z$ 处的经向翻转流函数 $\\Psi$ 代表了穿过从海底延伸至深度 $z$ 的纬向剖面净向北输送的水体体积。它由纬向积分的经向输送的累积垂直积分定义。\n\n穿过垂直于流动的微小面积 $dA = dx \\, dz$ 的元体积输送为 $d\\mathcal{T} = v \\, dA$，其中 $v$ 是经向速度分量。在半径为 $R$ 的球体上，纬度为 $\\phi$ 处，对应于经度微小变化 $d\\lambda$（以弧度为单位）的纬向宽度元 $dx$ 由 $dx = R \\cos(\\phi) d\\lambda$ 给出。\n\n该问题在结构化网格上进行离散化，纬度指数为 $i \\in [0, N_\\phi-1]$，经度指数为 $j \\in [0, N_\\lambda-1]$，深度指数为 $k \\in [0, N_z-1]$，其中 $k=0$ 对应最浅层，且 $z$ 随深度增加而增加。\n\n计算流程如下：\n\n1.  **网格与参数初始化**：定义所有提供的网格数据：纬度坐标 $\\phi_i$、经度坐标 $\\lambda_j$、深度层中心 $z_k$ 和层厚度 $\\Delta z_k$。地球半径取为 $R = 6.371 \\times 10^6 \\, \\text{m}$。所有以度为单位的输入角度都将转换为弧度用于几何计算，例如 $\\phi_{i, \\text{rad}} = \\phi_i \\cdot \\pi/180$。\n\n2.  **纬向输送计算**：计算每个网格层 $(i, k)$ 中的纬向积分经向输送 $T_{ik}$。纬向积分的这种离散近似，是在固定的纬度和深度上，对所有经度上的每个网格单元的输送进行求和。单个单元格 $(\\phi_i, \\lambda_j, z_k)$ 中的输送是速度 $v_{ijk} = v(\\phi_i, \\lambda_j, z_k)$、单元格的横截面积 $A_{ijk} = \\Delta x_i \\cdot \\Delta z_k$ 和海陆掩码 $M_{ij}$ 的乘积。在纬度 $\\phi_i$ 处，经度间距为 $\\Delta\\lambda$ 的网格单元的纬向弧长对于该纬度是恒定的：$\\Delta x_i = R \\cos(\\phi_{i, \\text{rad}}) \\Delta\\lambda_{\\text{rad}}$，其中 $\\Delta\\lambda_{\\text{rad}} = \\Delta\\lambda \\cdot \\pi/180$。\n\n    在 $(\\phi_i, z_k)$ 层的总纬向积分输送为：\n    $$ T_{ik} = \\sum_{j=0}^{N_{\\lambda}-1} v_{ijk} (\\Delta x_i) (\\Delta z_k) M_{ij} = (\\Delta z_k \\Delta x_i) \\sum_{j=0}^{N_{\\lambda}-1} v_{ijk} M_{ij} $$\n    此计算产生一个维度为 $(N_\\phi \\times N_z)$ 的二维数组 $T$。\n\n3.  **经向翻转流函数计算**：网格点 $(\\phi_i, z_k)$ 处的流函数 $\\Psi_{ik}$ 定义为从海底到该深度层的输送的累积和。根据问题的离散化规则，这是对所有深度指数 $m \\ge k$ 的求和：\n    $$ \\Psi_{ik} = \\sum_{m=k}^{N_z-1} T_{im} $$\n    对每个纬度指数 $i$ 执行此计算。一种高效的实现方法是，从最后一个元素（底部）开始，沿着深度轴对输送数组 $T_{i,:}$ 计算累积和。这确保了最深层的流函数 $\\Psi_{i, N_z-1}$ 就是该层的输送 $T_{i, N_z-1}$，而顶层的流函数 $\\Psi_{i, 0}$ 是整个水柱上的积分 $\\sum_{m=0}^{N_z-1} T_{im}$。这将得到一个与 $T$ 维度相同的二维数组 $\\Psi$。\n\n4.  **识别最大绝对值**：主要目标是找到流函数绝对值 $|\\Psi_{ik}|$ 最大的网格点 $(\\phi^\\ast, z^\\ast)$。\n    - 首先，确定最大绝对值：$|\\Psi|_{max} = \\max_{i,k} |\\Psi_{ik}|$。\n    - 识别出一组候选索引 $\\mathcal{S} = \\{(i, k) \\mid |\\Psi_{ik}| = |\\Psi|_{max}\\}$。\n    - 对该集合应用指定的平局决胜程序以确保唯一解：\n        a. 从 $\\mathcal{S}$ 中选择具有最小深度值的候选子集，$z_{k^\\ast} = \\min \\{z_k \\mid (i,k) \\in \\mathcal{S}\\}$。\n        b. 如果仍有多个候选者，则选择具有最小纬度指数 $i^\\ast$ 的那个。\n    - 最终确定的索引为 $(i^\\ast, k^\\ast)$。\n\n5.  **输出格式化**：每个测试用例的最终报告值为：纬度 $\\phi^\\ast = \\phi_{i^\\ast}$（单位为度），深度 $z^\\ast = z_{k^\\ast}$（单位为米），以及相应的有符号流函数值 $\\Psi^\\ast = \\Psi_{i^\\ast, k^\\ast}$，该值通过除以 $10^6$ 转换为斯维尔德鲁普（Sv）单位并四舍五入到三位小数。所有测试用例的结果被编译成指定的单一列表的列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the meridional overturning streamfunction and finds its maximum\n    absolute value for a series of test cases.\n    \"\"\"\n    R_EARTH = 6.371e6  # Earth radius in meters\n    SV_CONVERSION = 1e-6  # Conversion from m^3/s to Sverdrups\n\n    # Test cases defined as a list of dictionaries\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"phi\": np.array([-40, -20, 0, 20, 40]),\n            \"lambda_\": np.array([0, 3, 6, 9, 12]),\n            \"z_centers\": np.array([100, 600, 1200, 2200, 3400]),\n            \"delta_z\": np.array([200, 600, 800, 1000, 1200]),\n            \"mask\": None,\n            \"v_func\": lambda phi_rad, lam_rad, z: 0.05 * np.cos(np.pi * z / 4000) * \\\n                                                  np.exp(-phi_rad**2 / (0.6**2)) * \\\n                                                  (1 + 0.3 * np.sin(lam_rad)),\n        },\n        {\n            \"name\": \"Case B\",\n            \"phi\": np.array([-10, 0, 10]),\n            \"lambda_\": np.array([0, 10, 20, 30]),\n            \"z_centers\": np.array([500, 1500]),\n            \"delta_z\": np.array([1000, 2000]),\n            \"mask\": None,\n            \"v_func\": lambda phi_rad, lam_rad, z: 0.0,\n        },\n        {\n            \"name\": \"Case C\",\n            \"phi\": np.array([30, 35, 40]),\n            \"lambda_\": np.array([0, 2, 4, 6, 8, 10]),\n            \"z_centers\": np.array([300, 1200, 2600]),\n            \"delta_z\": np.array([600, 1200, 1800]),\n            \"mask\": np.array([\n                [1, 1, 1, 1, 1, 1],  # phi = 30\n                [1, 1, 1, 1, 0, 0],  # phi = 35\n                [1, 1, 1, 0, 0, 0],  # phi = 40\n            ], dtype=int),\n            \"v_func\": lambda phi_rad, lam_rad, z: -0.02,\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        phi = case[\"phi\"]\n        lambda_ = case[\"lambda_\"]\n        z_centers = case[\"z_centers\"]\n        delta_z = case[\"delta_z\"]\n        mask = case[\"mask\"]\n        v_func = case[\"v_func\"]\n\n        n_phi, n_lambda, n_z = len(phi), len(lambda_), len(z_centers)\n\n        # Generate grids for calculations\n        phi_grid, lambda_grid, z_grid = np.meshgrid(phi, lambda_, z_centers, indexing='ij')\n\n        # Convert angles to radians for calculations\n        phi_rad_grid = np.deg2rad(phi_grid)\n        lambda_rad_grid = np.deg2rad(lambda_grid)\n\n        # Calculate meridional velocity field\n        v = v_func(phi_rad_grid, lambda_rad_grid, z_grid)\n\n        # Handle land-sea mask\n        if mask is None:\n            mask = np.ones((n_phi, n_lambda), dtype=int)\n        \n        # Ensure mask is broadcastable to the velocity field shape\n        mask_3d = mask[:, :, np.newaxis]\n        \n        # Apply mask to velocity\n        v_masked = v * mask_3d\n\n        # Calculate zonal arc length for each latitude\n        # Assuming uniform longitude spacing\n        delta_lambda_deg = lambda_[1] - lambda_[0] if n_lambda > 1 else 0\n        delta_lambda_rad = np.deg2rad(delta_lambda_deg)\n        phi_rad_1d = np.deg2rad(phi)\n        delta_x = R_EARTH * np.cos(phi_rad_1d) * delta_lambda_rad\n\n        # Reshape for broadcasting\n        delta_x_2d = delta_x[:, np.newaxis]\n        delta_z_2d = delta_z[np.newaxis, :]\n\n        # Calculate zonally integrated transport T_ik (shape: n_phi x n_z)\n        # Sum v_masked over the longitude axis (axis 1)\n        zonal_sum_v = np.sum(v_masked, axis=1)\n        T_ik = zonal_sum_v * delta_x_2d * delta_z_2d\n        \n        # Calculate meridional overturning streamfunction Psi_ik\n        # Cumulative sum from bottom to top (along axis 1, which is depth)\n        psi = np.cumsum(T_ik[:, ::-1], axis=1)[:, ::-1]\n\n        # Find the location of the maximum absolute streamfunction value\n        abs_psi = np.abs(psi)\n        max_abs_psi = np.max(abs_psi)\n\n        # Find all indices where the max value occurs\n        candidate_indices = np.argwhere(abs_psi == max_abs_psi)\n\n        # Apply tie-breaking rule:\n        # 1. Smallest depth z\n        candidate_depth_values = z_centers[candidate_indices[:, 1]]\n        min_depth_val = np.min(candidate_depth_values)\n        depth_filtered_indices = candidate_indices[candidate_depth_values == min_depth_val]\n        \n        # 2. Smallest latitude index\n        min_lat_idx = np.min(depth_filtered_indices[:, 0])\n        \n        # Find the final winning index pair\n        final_winner = depth_filtered_indices[depth_filtered_indices[:, 0] == min_lat_idx][0]\n        i_star, k_star = final_winner[0], final_winner[1]\n\n        phi_star = phi[i_star]\n        z_star = z_centers[k_star]\n        psi_star_sv = round(psi[i_star, k_star] * SV_CONVERSION, 3)\n\n        all_results.append([phi_star, z_star, psi_star_sv])\n\n    # Format output as a string representation of a list of lists\n    result_str = \",\".join([f\"[{phi},{z},{psi}]\" for phi, z, psi in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "本实践将视角从使用直接给定的速度场，转向从更常见的温盐（hydrographic）数据中推断速度场。您将应用热成风关系——地转和静力平衡的直接推论——从密度梯度计算速度切变。通过使用单个参考速度测量值来校准该切变剖面，您将计算出绝对地转输运，这是物理海洋学中一种经典而强大的技术。",
            "id": "3787298",
            "problem": "您将获得跨越一个海峡的两个水文站的数据，每个站都有温盐剖面和一个在指定深度的单层声学多普勒流速剖面仪 (ADCP) 参考速度。您的任务是计算从表层到目标深度积分的绝对地转输运，并将其与在一个简单的、明确定义的速度剖面形状假设下的基于ADCP的输运进行比较。您必须构建一个完整的程序，对一组测试用例执行此计算，并按规定格式打印所需的输出。\n\n计算必须从一个有效的基础出发。使用以下基本关系和假设：\n\n- 静力平衡：$ \\dfrac{\\partial p}{\\partial z} = - \\rho g $，其中 $ \\rho $ 是密度，$ p $ 是压力，$ z $ 是深度（向下为正），$ g $ 是重力加速度。\n- 存在横跨海峡的压力梯度时，沿海峡方向速度 $ v $ 的地转平衡：$ f v = - \\dfrac{1}{\\rho} \\dfrac{\\partial p}{\\partial x} $，其中 $ f $ 是科里奥利参数，$ x $ 是横跨海峡的水平坐标。\n- 从以上关系推导出的热成风关系：$ \\dfrac{\\partial v}{\\partial z} = - \\dfrac{g}{f \\rho_0} \\dfrac{\\partial \\rho}{\\partial x} $，其中 $ \\rho_0 $ 是一个恒定的参考密度。\n\n为了获得密度，采用线性化状态方程：\n$$ \\rho(T,S) = \\rho_0 \\left[ 1 - \\alpha \\left( T - T_0 \\right) + \\beta \\left( S - S_0 \\right) \\right], $$\n其中 $ T $ 的单位是摄氏度，$ S $ 的单位是实用盐度单位，$ \\alpha $ 是热膨胀系数，$ \\beta $ 是盐收缩系数，$ T_0 $、$ S_0 $ 是参考值。\n\n您将使用热成风方程，根据两个测站之间的横向密度差来计算垂直切变 $ \\dfrac{\\partial v}{\\partial z} $，通过跨越测站间距 $ L $ 的有限差分来近似 $ \\dfrac{\\partial \\rho}{\\partial x} $，并通过参考 $ z_{\\text{ref}} $ 处的ADCP测量速度，对切变进行垂直积分，以获得绝对地转速度剖面 $ v(z) $。然后，将 $ v(z) $ 从 $ z=0 $ 积分到 $ z_{\\text{max}} $ 以获得单位宽度输运，再乘以间距 $ L $ 得到体积输运。另外，使用指定的形状参数构建一个ADCP速度剖面，使其在 $ z_{\\text{ref}} $ 处与提供的参考值匹配，以相同的方式进行积分，并计算基于ADCP的体积输运。\n\n要使用的常数和单位：\n- $ g = 9.81 $ 米/秒平方。\n- $ \\rho_0 = 1025 $ 千克/立方米。\n- $ \\alpha = 2.0 \\times 10^{-4} $ 每摄氏度。\n- $ \\beta = 7.7 \\times 10^{-4} $ 每实用盐度单位。\n- $ T_0 = 10.0 $ 摄氏度。\n- $ S_0 = 35.0 $ 实用盐度单位。\n- 科里奥利参数 $ f = 2 \\Omega \\sin(\\phi) $，其中地球自转速率 $ \\Omega = 7.2921 \\times 10^{-5} $ 每秒，纬度 $ \\phi $ 以弧度为单位。\n\n建模假设：\n- 两个水文站沿横跨海峡的轴线分布，相距 $ L $ 米，并定义了横跨海峡的密度梯度 $ \\dfrac{\\partial \\rho}{\\partial x} \\approx \\dfrac{\\rho_2(z) - \\rho_1(z)}{L} $。计算出的地转沿海峡速度被视为在宽度 $ L $ 上的代表性速度，通过乘以 $ L $ 得到体积输运。\n- ADCP提供一个在深度 $ z_{\\text{ref}} $ 处的参考绝对速度 $ v_{\\text{ref}} $，并且基于ADCP的速度剖面 $ v_{\\text{ADCP}}(z) $ 被参数化以与该参考值保持一致。\n\n剖面：\n- 对于每个测站 $ i \\in \\{1,2\\} $，温度剖面为\n$$ T_i(z) = T_{\\text{deep},i} + \\left( T_{\\text{surf},i} - T_{\\text{deep},i} \\right) \\exp\\left( - \\dfrac{z}{H_{T,i}} \\right), $$\n盐度剖面为\n$$ S_i(z) = S_{\\text{deep},i} - \\left( S_{\\text{deep},i} - S_{\\text{surf},i} \\right) \\exp\\left( - \\dfrac{z}{H_{S,i}} \\right), $$\n其中 $ z $ 是深度，单位为米。\n\n- 基于ADCP的沿海峡速度剖面定义为\n$$ v_{\\text{ADCP}}(z) = \\begin{cases}\nv_{\\text{ref}} \\left[ 1 + a \\dfrac{z_{\\text{ref}} - z}{z_{\\text{ref}}} \\right],  0 \\le z \\le z_{\\text{ref}}, \\\\\nv_{\\text{ref}} \\exp\\left( - \\dfrac{z - z_{\\text{ref}}}{H_v} \\right),  z_{\\text{ref}} \\le z \\le z_{\\text{max}},\n\\end{cases} $$\n这确保了 $ v_{\\text{ADCP}}(z_{\\text{ref}}) = v_{\\text{ref}} $，其中 $ a $ 是无量纲的，$ H_v $ 的单位是米。\n\n需要实现的计算步骤：\n1. 创建一个从 $ 0 $ 到 $ z_{\\text{max}} $ 米的均匀深度网格 $ z $，间距为 $ \\Delta z = 10 $ 米。\n2. 对于每个测站，在深度网格上计算 $ T_i(z) $ 和 $ S_i(z) $，然后使用线性化状态方程计算 $ \\rho_i(z) $。\n3. 使用热成风关系计算地转沿海峡速度的垂直切变，\n$$ \\dfrac{\\partial v}{\\partial z}(z) = - \\dfrac{g}{f \\rho_0} \\dfrac{\\rho_2(z) - \\rho_1(z)}{L}. $$\n4. 通过强制 $ v(z_{\\text{ref}}) = v_{\\text{ref}} $ 来对 $ \\dfrac{\\partial v}{\\partial z} $ 进行垂直积分以获得 $ v(z) $，即\n$$ v(z) = v_{\\text{ref}} + \\int_{z_{\\text{ref}}}^{z} \\dfrac{\\partial v}{\\partial z'}(z') \\, dz'. $$\n5. 通过将 $ v(z) $ 从 $ 0 $ 积分到 $ z_{\\text{max}} $ 并乘以 $ L $ 来计算地转体积输运，\n$$ Q_{\\text{geo}} = L \\int_{0}^{z_{\\text{max}}} v(z) \\, dz, $$\n单位为立方米/秒。\n6. 使用提供的 $ v_{\\text{ref}} $、$ z_{\\text{ref}} $、$ a $ 和 $ H_v $ 构建 $ v_{\\text{ADCP}}(z) $，并计算基于ADCP的体积输运，\n$$ Q_{\\text{ADCP}} = L \\int_{0}^{z_{\\text{max}}} v_{\\text{ADCP}}(z) \\, dz, $$\n单位为立方米/秒。\n7. 对于每个测试用例，还要计算差异 $ \\Delta Q = Q_{\\text{geo}} - Q_{\\text{ADCP}} $ 和相对差异 $ \\delta = \\dfrac{Q_{\\text{geo}} - Q_{\\text{ADCP}}}{Q_{\\text{ADCP}}} $（以小数形式表示）。\n\n物理单位和输出要求：\n- 所有输运 $ Q_{\\text{geo}} $ 和 $ Q_{\\text{ADCP}} $ 以立方米/秒 (m$^3$/s) 表示。\n- 相对差异 $ \\delta $ 以小数形式表示。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果是一个列表 $[Q_{\\text{geo}}, Q_{\\text{ADCP}}, \\Delta Q, \\delta]$，所有测试用例按顺序排列，格式化为三位小数。例如：$[[1.234,0.987,0.247,0.250],[...],[...]]$。\n\n测试套件：\n所有测试用例均使用 $ z_{\\text{ref}} = 300 $ 米和 $ z_{\\text{max}} = 2000 $ 米。每个测试用例的参数如下：\n\n- 情况 $ A $ (一般情况):\n  - 纬度 $ \\phi = 60.0 $ 度。\n  - 测站间距 $ L = 20000.0 $ 米。\n  - $ v_{\\text{ref}} = 0.300 $ 米/秒。\n  - 测站 $ 1 $: $ T_{\\text{surf},1} = 10.0 $, $ T_{\\text{deep},1} = 2.0 $, $ H_{T,1} = 400.0 $; $ S_{\\text{surf},1} = 34.60 $, $ S_{\\text{deep},1} = 34.95 $, $ H_{S,1} = 700.0 $。\n  - 测站 $ 2 $: $ T_{\\text{surf},2} = 9.5 $, $ T_{\\text{deep},2} = 2.2 $, $ H_{T,2} = 350.0 $; $ S_{\\text{surf},2} = 34.70 $, $ S_{\\text{deep},2} = 35.00 $, $ H_{S,2} = 650.0 $。\n  - ADCP剖面参数: $ H_v = 800.0 $, $ a = 0.20 $。\n\n- 情况 $ B $ (弱横向梯度):\n  - 纬度 $ \\phi = 45.0 $ 度。\n  - 测站间距 $ L = 15000.0 $ 米。\n  - $ v_{\\text{ref}} = 0.050 $ 米/秒。\n  - 测站 $ 1 $: $ T_{\\text{surf},1} = 11.0 $, $ T_{\\text{deep},1} = 2.5 $, $ H_{T,1} = 500.0 $; $ S_{\\text{surf},1} = 34.70 $, $ S_{\\text{deep},1} = 34.90 $, $ H_{S,1} = 800.0 $。\n  - 测站 $ 2 $: $ T_{\\text{surf},2} = 11.0 $, $ T_{\\text{deep},2} = 2.5 $, $ H_{T,2} = 500.0 $; $ S_{\\text{surf},2} = 34.71 $, $ S_{\\text{deep},2} = 34.91 $, $ H_{S,2} = 800.0 $。\n  - ADCP剖面参数: $ H_v = 600.0 $, $ a = 0.10 $。\n\n- 情况 $ C $ (小科里奥利参数):\n  - 纬度 $ \\phi = 5.0 $ 度。\n  - 测站间距 $ L = 25000.0 $ 米。\n  - $ v_{\\text{ref}} = 0.150 $ 米/秒。\n  - 测站 $ 1 $: $ T_{\\text{surf},1} = 12.0 $, $ T_{\\text{deep},1} = 3.0 $, $ H_{T,1} = 450.0 $; $ S_{\\text{surf},1} = 34.50 $, $ S_{\\text{deep},1} = 34.85 $, $ H_{S,1} = 700.0 $。\n  - 测站 $ 2 $: $ T_{\\text{surf},2} = 11.8 $, $ T_{\\text{deep},2} = 3.1 $, $ H_{T,2} = 420.0 $; $ S_{\\text{surf},2} = 34.55 $, $ S_{\\text{deep},2} = 34.88 $, $ H_{S,2} = 720.0 $。\n  - ADCP剖面参数: $ H_v = 900.0 $, $ a = 0.15 $。\n\n您的程序必须遵守指定的执行环境，并产生所描述的精确输出格式。不允许外部输入；所有参数都在程序内部。最终打印的输出是包含一个由三个列表组成的列表的单行，每个测试用例一个列表，每个列表包含四个格式化为三位小数的浮点值，代表 $[Q_{\\text{geo}}, Q_{\\text{ADCP}}, \\Delta Q, \\delta]$，单位为立方米/秒（对于输运项）和小数（对于 $ \\delta $）。",
            "solution": "该问题是有效的，因为它在科学上基于物理海洋学原理，问题设定良好，提供了足够的信息以获得唯一解，并以客观、正式的语言表达。提供的参数和方程是一致且物理上合理的。\n\n该问题的核心在于计算和比较跨海峡海洋输运的两种估算值：一种是通过地转方法从水文数据中推导出来的，另一种是基于直接流速测量（ADCP）的简化剖面。\n\n基本原理是**热成风关系**，它是通过结合地转平衡和静力平衡方程推导出来的。在连续层化的流体中，水平密度梯度意味着水平地转速度存在垂直切变。热成风方程表示为：\n$$ \\dfrac{\\partial v}{\\partial z} = - \\dfrac{g}{f \\rho_0} \\dfrac{\\partial \\rho}{\\partial x} $$\n这里，$v$ 是沿海峡方向的速度，$z$ 是垂直坐标（向下为正），$g$ 是重力加速度，$f$ 是科里奥利参数，$\\rho_0$ 是参考密度，$\\dfrac{\\partial \\rho}{\\partial x}$ 是横跨海峡的密度梯度。\n\n这个方程提供了垂直切变 $\\dfrac{\\partial v}{\\partial z}$，但没有提供绝对速度 $v(z)$。要确定绝对速度，我们必须知道某个参考层上的速度。这通常被称为“校准”地转流。问题提供了来自ADCP测量的在特定深度 $z_{\\text{ref}}$ 处的参考速度 $v_{\\text{ref}}$。通过从该参考深度垂直积分切变，我们可以构建绝对地转速度剖面：\n$$ v(z) = v(z_{\\text{ref}}) + \\int_{z_{\\text{ref}}}^{z} \\dfrac{\\partial v}{\\partial z'}(z') \\, dz' $$\n其中 $v(z_{\\text{ref}})$ 设置为 $v_{\\text{ref}}$。\n\n密度 $\\rho$ 是温度 $T$ 和盐度 $S$ 的函数。为此提供了一个线性化状态方程：\n$$ \\rho(T,S) = \\rho_0 \\left[ 1 - \\alpha \\left( T - T_0 \\right) + \\beta \\left( S - S_0 \\right) \\right] $$\n其中 $\\alpha$ 是热膨胀系数，$\\beta$ 是盐收缩系数。\n\n计算过程如下：\n\n1.  **离散化**：建立一个从海面（$z=0$）到最大深度（$z=z_{\\text{max}}$）的均匀垂直网格 $z_j$，间距为 $\\Delta z = 10$ 米。\n\n2.  **密度剖面计算**：对于两个水文站（$i=1, 2$）中的每一个，使用提供的指数函数在每个网格点上计算温度剖面 $T_i(z_j)$ 和盐度剖面 $S_i(z_j)$。然后使用这些值通过线性化状态方程计算相应的密度剖面 $\\rho_1(z_j)$ 和 $\\rho_2(z_j)$。\n\n3.  **地转切变计算**：连续的横跨海峡密度梯度 $\\dfrac{\\partial \\rho}{\\partial x}$ 通过跨越两个测站（相距 $L$）的有限差分来近似：$\\dfrac{\\rho_2(z_j) - \\rho_1(z_j)}{L}$。将此代入热成风方程，得到离散的垂直切变剖面 $\\left(\\dfrac{\\partial v}{\\partial z}\\right)_j$。科里奥利参数 $f$ 由给定的纬度 $\\phi$ 使用 $f = 2 \\Omega \\sin(\\phi)$ 计算，其中 $\\Omega$ 是地球的自转速率。\n\n4.  **绝对地转速度剖面**：对离散的切变剖面进行数值积分。我们使用累积梯形法则来计算从海面开始的切变积分。令其为 $I(z_j) = \\int_0^{z_j} \\frac{\\partial v}{\\partial z'} dz'$。然后构建绝对速度剖面为 $v_{\\text{geo}}(z_j) = v_{\\text{ref}} + I(z_j) - I(z_{\\text{ref}})$，这确保了 $v_{\\text{geo}}(z_{\\text{ref}}) = v_{\\text{ref}}$。深度 $z_{\\text{ref}}$ 与一个网格点对齐，简化了索引。\n\n5.  **地转输运**：通过对绝对速度剖面 $v_{\\text{geo}}(z)$ 在海峡深度范围内进行数值积分，并乘以海峡宽度 $L$，得到总体积输运 $Q_{\\text{geo}}$。这使用梯形法则计算：\n    $$ Q_{\\text{geo}} = L \\int_{0}^{z_{\\text{max}}} v_{\\text{geo}}(z) \\, dz \\approx L \\sum_{j} \\frac{v_{\\text{geo}}(z_j) + v_{\\text{geo}}(z_{j+1})}{2} \\Delta z $$\n\n6.  **基于ADCP的输运**：为了比较，计算第二个独立的输运估算值 $Q_{\\text{ADCP}}$。这使用一个预设的、分段定义的速度剖面 $v_{\\text{ADCP}}(z)$，该剖面被设计为在 $z_{\\text{ref}}$ 处与参考速度 $v_{\\text{ref}}$ 匹配。该剖面在相同的深度范围内进行数值积分，并乘以宽度 $L$ 以获得 $Q_{\\text{ADCP}}$。\n\n7.  **比较**：最后，计算绝对差异 $\\Delta Q = Q_{\\text{geo}} - Q_{\\text{ADCP}}$ 和相对差异 $\\delta = \\Delta Q / Q_{\\text{ADCP}}$，以量化两种输运估算值之间的差异。这种比较突出了关于速度剖面形状的不同假设（地转切变 vs. 参数化形状）如何导致不同的输运值，即使它们都锚定到相同的参考速度。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid, trapezoid\n\ndef solve():\n    \"\"\"\n    Computes and compares geostrophic and ADCP-based transports for a set of test cases.\n    \"\"\"\n    # Physical and model constants\n    G = 9.81  # m/s^2\n    RHO0 = 1025.0  # kg/m^3\n    ALPHA = 2.0e-4  # 1/C\n    BETA = 7.7e-4  # 1/psu\n    T0 = 10.0  # C\n    S0 = 35.0  # psu\n    OMEGA = 7.2921e-5  # rad/s\n\n    # Shared parameters for all test cases\n    Z_REF = 300.0  # m\n    Z_MAX = 2000.0  # m\n    DZ = 10.0  # m\n    \n    # Test cases data\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"phi_deg\": 60.0,\n            \"L\": 20000.0,\n            \"v_ref\": 0.300,\n            \"station1\": {\"T_surf\": 10.0, \"T_deep\": 2.0, \"H_T\": 400.0,\n                         \"S_surf\": 34.60, \"S_deep\": 34.95, \"H_S\": 700.0},\n            \"station2\": {\"T_surf\": 9.5, \"T_deep\": 2.2, \"H_T\": 350.0,\n                         \"S_surf\": 34.70, \"S_deep\": 35.00, \"H_S\": 650.0},\n            \"adcp_params\": {\"H_v\": 800.0, \"a\": 0.20},\n        },\n        {\n            \"name\": \"B\",\n            \"phi_deg\": 45.0,\n            \"L\": 15000.0,\n            \"v_ref\": 0.050,\n            \"station1\": {\"T_surf\": 11.0, \"T_deep\": 2.5, \"H_T\": 500.0,\n                         \"S_surf\": 34.70, \"S_deep\": 34.90, \"H_S\": 800.0},\n            \"station2\": {\"T_surf\": 11.0, \"T_deep\": 2.5, \"H_T\": 500.0,\n                         \"S_surf\": 34.71, \"S_deep\": 34.91, \"H_S\": 800.0},\n            \"adcp_params\": {\"H_v\": 600.0, \"a\": 0.10},\n        },\n        {\n            \"name\": \"C\",\n            \"phi_deg\": 5.0,\n            \"L\": 25000.0,\n            \"v_ref\": 0.150,\n            \"station1\": {\"T_surf\": 12.0, \"T_deep\": 3.0, \"H_T\": 450.0,\n                         \"S_surf\": 34.50, \"S_deep\": 34.85, \"H_S\": 700.0},\n            \"station2\": {\"T_surf\": 11.8, \"T_deep\": 3.1, \"H_T\": 420.0,\n                         \"S_surf\": 34.55, \"S_deep\": 34.88, \"H_S\": 720.0},\n            \"adcp_params\": {\"H_v\": 900.0, \"a\": 0.15},\n        },\n    ]\n\n    # --- Helper functions for profile calculations ---\n    def temp_profile(z, p):\n        return p[\"T_deep\"] + (p[\"T_surf\"] - p[\"T_deep\"]) * np.exp(-z / p[\"H_T\"])\n\n    def salt_profile(z, p):\n        return p[\"S_deep\"] - (p[\"S_deep\"] - p[\"S_surf\"]) * np.exp(-z / p[\"H_S\"])\n\n    def density_profile(T, S):\n        return RHO0 * (1.0 - ALPHA * (T - T0) + BETA * (S - S0))\n\n    def adcp_vel_profile(z, v_ref, z_ref, a, H_v, z_max):\n        v = np.zeros_like(z)\n        mask_upper = z = z_ref\n        mask_lower = z > z_ref\n        \n        v[mask_upper] = v_ref * (1 + a * (z_ref - z[mask_upper]) / z_ref)\n        v[mask_lower] = v_ref * np.exp(-(z[mask_lower] - z_ref) / H_v)\n        return v\n\n    all_results = []\n    \n    # Create depth grid\n    z_grid = np.arange(0, Z_MAX + DZ, DZ)\n    ref_idx = int(Z_REF / DZ)\n\n    for case in test_cases:\n        # Extract parameters for the current case\n        phi_rad = np.deg2rad(case[\"phi_deg\"])\n        L = case[\"L\"]\n        v_ref = case[\"v_ref\"]\n        s1_params = case[\"station1\"]\n        s2_params = case[\"station2\"]\n        adcp_params = case[\"adcp_params\"]\n\n        # Calculate Coriolis parameter\n        f = 2 * OMEGA * np.sin(phi_rad)\n\n        # 1. Compute Temperature, Salinity, and Density profiles\n        T1 = temp_profile(z_grid, s1_params)\n        S1 = salt_profile(z_grid, s1_params)\n        rho1 = density_profile(T1, S1)\n\n        T2 = temp_profile(z_grid, s2_params)\n        S2 = salt_profile(z_grid, s2_params)\n        rho2 = density_profile(T2, S2)\n\n        # 2. Compute geostrophic shear\n        d_rho_dx = (rho2 - rho1) / L\n        dv_dz = -(G / (f * RHO0)) * d_rho_dx\n\n        # 3. Integrate shear to get absolute geostrophic velocity\n        # The integral of shear from z_ref to z is integral(0 to z) - integral(0 to z_ref)\n        integral_dv_dz = cumulative_trapezoid(dv_dz, z_grid, initial=0)\n        v_geo = v_ref + (integral_dv_dz - integral_dv_dz[ref_idx])\n\n        # 4. Compute geostrophic transport\n        q_geo = L * trapezoid(v_geo, z_grid)\n\n        # 5. Compute ADCP-based velocity profile and transport\n        v_adcp = adcp_vel_profile(z_grid, v_ref, Z_REF, adcp_params[\"a\"], adcp_params[\"H_v\"], Z_MAX)\n        q_adcp = L * trapezoid(v_adcp, z_grid)\n\n        # 6. Compute differences\n        delta_q = q_geo - q_adcp\n        delta_frac = delta_q / q_adcp if q_adcp != 0 else np.nan\n\n        all_results.append([q_geo, q_adcp, delta_q, delta_frac])\n\n    # Format the final output string\n    formatted_cases = []\n    for res in all_results:\n        formatted_cases.append(f\"[{','.join(f'{val:.3f}' for val in res)}]\")\n    final_output_string = f\"[{','.join(formatted_cases)}]\"\n\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}