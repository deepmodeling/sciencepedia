{
    "hands_on_practices": [
        {
            "introduction": "最优插值的核心在于量化地减少不确定性。本练习将深入探讨分析误差方差这一基本计算，它代表了我们最终估计的预期平方误差。通过手动解决一个简单的双观测点案例，您将具体理解先验信息（协方差）和新数据如何结合，从而得出一个更确定的后验估计。",
            "id": "3805220",
            "problem": "考虑一个表示海表温度异常的零均值、平稳高斯随机场，记为 $x(\\mathbf{x})$，其各向同性协方差函数为 $C(r) = \\sigma^{2}\\exp(-r/L)$，其中 $r$ 是水平距离，$\\sigma^{2}$ 是先验方差，$L$ 是相关长度尺度。您希望使用线性客观分析（最优插值）在分析位置 $\\mathbf{x}_0$ 处估计 $x(\\mathbf{x}_0)$，该方法是根据一组点观测构建的 $x(\\mathbf{x}_0)$ 的最佳线性无偏估计。\n\n在位置 $\\mathbf{x}_1$ 和 $\\mathbf{x}_2$ 处，分别有两个对同一异常场的独立标量观测 $y_1$ 和 $y_2$。每个观测都受到附加的、独立的、零均值的测量噪声污染，其已知方差分别为 $\\mathrm{Var}(\\epsilon_1) = r_1$ 和 $\\mathrm{Var}(\\epsilon_2) = r_2$，且测量误差之间没有互协方差。假设误差与信号 $x(\\mathbf{x})$ 不相关。\n\n给定以下科学上合理的参数：\n- 先验方差 $\\sigma^{2} = 1.2$，单位为 $(\\mathrm{^\\circ C})^2$。\n- 相关长度 $L = 60\\,\\mathrm{km}$。\n- 与分析点的距离：$r_1 = 30\\,\\mathrm{km}$ 和 $r_2 = 60\\,\\mathrm{km}$。\n- 两个观测位置之间的距离：$d_{12} = 90\\,\\mathrm{km}$。\n- 测量误差方差：$r_1 = r_2 = 0.09$，单位为 $(\\mathrm{^\\circ C})^2$。\n\n从高斯随机场与附加测量噪声的最佳线性无偏估计的定义出发，推导由最优插值在 $\\mathbf{x}_0$ 处产生的后验分析误差方差的表达式，该表达式应使用先验协方差和数据协方差表示。然后，根据上述给定的配置，对此后验方差进行数值计算。请根据所述的协方差模型和距离，清楚地标明您计算的所有中间量（例如信号-数据协方差向量和数据协方差矩阵）。\n\n将您的最终答案表示为单位为 $(\\mathrm{^\\circ C})^2$ 的单个实数，并将结果四舍五入到四位有效数字。简要地从物理上解释这个量，即同化两个观测后，分析位置的后验不确定性。",
            "solution": "该问题具有科学依据、适定、客观，并包含足够的信息以获得唯一解。注意到符号 $r_1$ 和 $r_2$ 同时用于表示距离和误差方差，存在符号歧义；然而，从物理单位和上下文中，其意图是明确的。为避免推导过程中的混淆，从分析点 $\\mathbf{x}_0$ 到观测点 $\\mathbf{x}_1$ 和 $\\mathbf{x}_2$ 的距离将分别表示为 $d_{01}$ 和 $d_{02}$。测量误差方差将按照问题陈述，用 $r_1$ 和 $r_2$ 表示。\n\n目标是求出在位置 $\\mathbf{x}_0$ 的后验分析误差方差，记为 $\\sigma_a^2$。对于作为最优插值 (OI) 基础的最佳线性无偏估计 (BLUE)，分析误差方差由以下表达式给出：\n$$\n\\sigma_a^2 = \\sigma_b^2 - \\mathbf{k}^T \\mathbf{C}_{yy}^{-1} \\mathbf{k}\n$$\n这里，$\\sigma_b^2$ 是分析位置的先验（背景）误差方差，$\\mathbf{k}$ 是分析位置的真实状态与观测值之间的协方差向量，$\\mathbf{C}_{yy}$ 是观测值的总协方差矩阵。\n\n我们现在将确定该方程的每个分量。\n\n1.  **先验方差 ($\\sigma_b^2$)**\n    分析位置 $\\mathbf{x}_0$ 处的先验方差是场本身的方差，在零距离处计算得到，因为没有其他先验信息。\n    $$\n    \\sigma_b^2 = \\mathrm{Var}(x(\\mathbf{x}_0)) = C(0) = \\sigma^2 \\exp(-0/L) = \\sigma^2\n    $$\n    给定 $\\sigma^2 = 1.2\\,(\\mathrm{^\\circ C})^2$，我们有 $\\sigma_b^2 = 1.2$。\n\n2.  **信号-数据协方差向量 ($\\mathbf{k}$)**\n    该向量包含分析点处的真实场值 $x(\\mathbf{x}_0)$ 与每个观测值 $y_1$ 和 $y_2$ 之间的协方差。$\\mathbf{k}$ 的第 $i$ 个元素是 $k_i = \\mathrm{Cov}(x(\\mathbf{x}_0), y_i)$。\n    由于 $y_i = x(\\mathbf{x}_i) + \\epsilon_i$ 且测量噪声 $\\epsilon_i$ 与信号 $x$ 不相关，这可以简化为：\n    $$\n    k_i = \\mathrm{Cov}(x(\\mathbf{x}_0), x(\\mathbf{x}_i) + \\epsilon_i) = \\mathrm{Cov}(x(\\mathbf{x}_0), x(\\mathbf{x}_i)) + \\mathrm{Cov}(x(\\mathbf{x}_0), \\epsilon_i) = C(d_{0i}) + 0\n    $$\n    其中 $d_{0i}$ 是 $\\mathbf{x}_0$ 和 $\\mathbf{x}_i$ 之间的距离。因此向量 $\\mathbf{k}$ 是：\n    $$\n    \\mathbf{k} = \\begin{pmatrix} C(d_{01}) \\\\ C(d_{02}) \\end{pmatrix} = \\begin{pmatrix} \\sigma^2 \\exp(-d_{01}/L) \\\\ \\sigma^2 \\exp(-d_{02}/L) \\end{pmatrix}\n    $$\n    使用给定值 $d_{01} = 30\\,\\mathrm{km}$，$d_{02} = 60\\,\\mathrm{km}$，$L = 60\\,\\mathrm{km}$，和 $\\sigma^2 = 1.2$：\n    $$\n    k_1 = 1.2 \\exp(-30/60) = 1.2 \\exp(-0.5)\n    $$\n    $$\n    k_2 = 1.2 \\exp(-60/60) = 1.2 \\exp(-1)\n    $$\n    数值上，$k_1 \\approx 0.727837\\,(\\mathrm{^\\circ C})^2$ 且 $k_2 \\approx 0.441455\\,(\\mathrm{^\\circ C})^2$。\n\n3.  **数据协方差矩阵 ($\\mathbf{C}_{yy}$)**\n    该矩阵表示观测向量 $\\mathbf{y} = (y_1, y_2)^T$ 的总协方差。它是信号协方差矩阵 $\\mathbf{C}_{xx}$ 和测量误差协方差矩阵 $\\mathbf{R}$ 的和：\n    $$\n    \\mathbf{C}_{yy} = \\mathbf{C}_{xx} + \\mathbf{R}\n    $$\n    信号协方差矩阵的元素是 $(\\mathbf{C}_{xx})_{ij} = \\mathrm{Cov}(x(\\mathbf{x}_i), x(\\mathbf{x}_j)) = C(d_{ij})$，其中 $d_{ij}$ 是观测点 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$ 之间的距离。\n    $$\n    \\mathbf{C}_{xx} = \\begin{pmatrix} C(0)  C(d_{12}) \\\\ C(d_{21})  C(0) \\end{pmatrix} = \\begin{pmatrix} \\sigma^2  \\sigma^2 \\exp(-d_{12}/L) \\\\ \\sigma^2 \\exp(-d_{12}/L)  \\sigma^2 \\end{pmatrix}\n    $$\n    测量误差是独立的，所以它们的协方差矩阵 $\\mathbf{R}$ 是对角矩阵：\n    $$\n    \\mathbf{R} = \\begin{pmatrix} \\mathrm{Var}(\\epsilon_1)  0 \\\\ 0  \\mathrm{Var}(\\epsilon_2) \\end{pmatrix} = \\begin{pmatrix} r_1  0 \\\\ 0  r_2 \\end{pmatrix}\n    $$\n    将这些组合起来得到：\n    $$\n    \\mathbf{C}_{yy} = \\begin{pmatrix} \\sigma^2 + r_1  \\sigma^2 \\exp(-d_{12}/L) \\\\ \\sigma^2 \\exp(-d_{12}/L)  \\sigma^2 + r_2 \\end{pmatrix}\n    $$\n    使用给定值 $d_{12} = 90\\,\\mathrm{km}$，$L=60\\,\\mathrm{km}$，$\\sigma^2=1.2$，和 $r_1 = r_2 = 0.09$：\n    - 对角元素：$\\sigma^2 + r_1 = 1.2 + 0.09 = 1.29$。\n    - 非对角元素：$\\sigma^2 \\exp(-90/60) = 1.2 \\exp(-1.5)$。\n    所以，该矩阵为：\n    $$\n    \\mathbf{C}_{yy} = \\begin{pmatrix} 1.29  1.2 \\exp(-1.5) \\\\ 1.2 \\exp(-1.5)  1.29 \\end{pmatrix}\n    $$\n    数值上，$1.2 \\exp(-1.5) \\approx 0.267756$，所以 $\\mathbf{C}_{yy} \\approx \\begin{pmatrix} 1.29  0.267756 \\\\ 0.267756  1.29 \\end{pmatrix}$。\n\n4.  **最终计算**\n    我们需要计算方差减小项，$\\Delta\\sigma^2 = \\mathbf{k}^T \\mathbf{C}_{yy}^{-1} \\mathbf{k}$。\n    首先，我们求 $2 \\times 2$ 矩阵 $\\mathbf{C}_{yy}$ 的逆。\n    行列式为 $\\det(\\mathbf{C}_{yy}) = (1.29)^2 - (1.2 \\exp(-1.5))^2 = 1.6641 - (1.44 \\exp(-3))$。\n    $\\det(\\mathbf{C}_{yy}) \\approx 1.6641 - 1.44 \\times 0.049787 = 1.6641 - 0.071693 = 1.592407$。\n    逆矩阵为：\n    $$\n    \\mathbf{C}_{yy}^{-1} = \\frac{1}{\\det(\\mathbf{C}_{yy})} \\begin{pmatrix} 1.29  -1.2 \\exp(-1.5) \\\\ -1.2 \\exp(-1.5)  1.29 \\end{pmatrix}\n    $$\n    二次型 $\\Delta\\sigma^2 = \\mathbf{k}^T \\mathbf{C}_{yy}^{-1} \\mathbf{k}$ 为：\n    $$\n    \\Delta\\sigma^2 = \\frac{1}{\\det(\\mathbf{C}_{yy})} \\left[ 1.29(k_1^2 + k_2^2) - 2 \\cdot (1.2 \\exp(-1.5)) \\cdot k_1 k_2 \\right]\n    $$\n    代入 $k_1$ 和 $k_2$ 的表达式：\n    $k_1^2 = (1.2 \\exp(-0.5))^2 = 1.44 \\exp(-1)$\n    $k_2^2 = (1.2 \\exp(-1))^2 = 1.44 \\exp(-2)$\n    $k_1 k_2 = (1.2 \\exp(-0.5)) (1.2 \\exp(-1)) = 1.44 \\exp(-1.5)$\n    $\\Delta\\sigma^2$ 的分子：\n    $1.29 \\left( 1.44 \\exp(-1) + 1.44 \\exp(-2) \\right) - 2 \\cdot (1.2 \\exp(-1.5)) \\cdot (1.44 \\exp(-1.5))$\n    $= 1.29 \\cdot 1.44 (\\exp(-1) + \\exp(-2)) - 2 \\cdot 1.2 \\cdot 1.44 \\cdot \\exp(-3)$\n    $= 1.8576 (\\exp(-1) + \\exp(-2)) - 3.456 \\exp(-3)$\n    使用数值：\n    $k_1 \\approx 0.727837$，$k_2 \\approx 0.441455$，$1.2 \\exp(-1.5) \\approx 0.267756$。\n    $k_1^2 \\approx 0.529727$，$k_2^2 \\approx 0.194883$。\n    $k_1 k_2 \\approx 0.321303$。\n    分子 $\\approx 1.29(0.529727 + 0.194883) - 2(0.267756)(0.321303)$\n    $\\approx 1.29(0.724610) - 0.172061 \\approx 0.934747 - 0.172061 = 0.762686$。\n    $\\Delta\\sigma^2 \\approx \\frac{0.762686}{1.592407} \\approx 0.479002 \\,(\\mathrm{^\\circ C})^2$。\n\n    最后，后验分析误差方差是：\n    $$\n    \\sigma_a^2 = \\sigma_b^2 - \\Delta\\sigma^2 \\approx 1.2 - 0.479002 = 0.720998 \\,(\\mathrm{^\\circ C})^2\n    $$\n    四舍五入到四位有效数字，我们得到 $\\sigma_a^2 = 0.7210 \\,(\\mathrm{^\\circ C})^2$。\n\n该结果的物理解释是，分析位置处海表温度异常的初始不确定性（由先验方差 $\\sigma_b^2 = 1.2\\,(\\mathrm{^\\circ C})^2$ 表示）通过同化两个观测值而减小了。后验方差 $\\sigma_a^2 \\approx 0.7210\\,(\\mathrm{^\\circ C})^2$ 是最优估计的期望平方误差。它量化了在并入数据信息后剩余的不确定性。该值的平方根 $\\sqrt{\\sigma_a^2} \\approx 0.849\\,\\mathrm{^\\circ C}$ 是最终分析的期望均方根误差。",
            "answer": "$$\n\\boxed{0.7210}\n$$"
        },
        {
            "introduction": "在掌握了单点的基本计算之后，我们可以进一步探究一个观测点的影响如何在空间中传播。任意点的分析增量都是“新息”（观测值与背景值之差）的加权版本，而这个权重，即影响函数，是由背景误差的协方差结构决定的。通过推导并可视化此影响函数，您将建立起关于相关长度和观测误差等参数如何决定单个观测值在最终分析场中“足迹”范围的关键直觉。",
            "id": "4070623",
            "problem": "给定一个嵌入在背景场中的地球物理场的单点标量观测，该背景场用于数值天气预报和气候模拟。任务是针对均匀且各向同性的高斯背景误差协方差，推导并实现使用最优插值（OI）进行客观分析的空间影响函数。场景如下。\n\n假设一个标量场 $x(\\mathbf{r})$ 定义在二维水平域上，其背景估计为 $x^{b}(\\mathbf{r})$，背景误差为 $e^{b}(\\mathbf{r}) = x(\\mathbf{r}) - x^{b}(\\mathbf{r})$。假设 $e^{b}(\\mathbf{r})$ 是一个零均值的二阶平稳随机场，其特征是方差 $\\sigma_{b}^{2}$ 和相关函数 $C(r; L)$，该函数仅依赖于径向距离 $r = \\|\\mathbf{r} - \\mathbf{r}'\\|$。设相关函数为高斯型的，其相关长度尺度为 $L$，即 $C(r; L)$ 随 $r$ 单调递减，并编码了空间均匀性和各向同性。在位置 $\\mathbf{r}_{o}$ 处有一个单点观测 $y$，其观测算子 $H$ 提取 $\\mathbf{r}_{o}$ 处的场真值，并带有一个独立的观测误差 $\\epsilon$，该误差是高斯的、零均值的，且方差为 $R$，因此 $y = H x + \\epsilon$。所有变量 $x$、$x^{b}$、$y$、$e^{b}$ 和 $\\epsilon$ 都假定为联合高斯分布。该域仅为水平域；不考虑垂直结构。\n\n从高斯假设下的最佳线性无偏估计（BLUE）和最优插值的定义出发，推导位于原点的单个观测的空间影响函数 $\\phi(r)$。该函数定义为乘以标量新息 $d = y - H x^{b}$ 以产生距离观测点径向距离为 $r$ 的格点上的分析增量的无量纲权重。用背景误差方差 $\\sigma_{b}^{2}$、观测误差方差 $R$、相关函数 $C(r; L)$ 和相关长度 $L$ 来表示 $\\phi(r)$。然后，编写一个程序，对一组指定的半径数值计算 $\\phi(r)$。\n\n假设高斯相关函数为 $C(r; L) = \\exp\\!\\left( -\\dfrac{r^{2}}{2 L^{2}} \\right)$。设背景误差方差 $\\sigma_{b}^{2}$ 和观测误差方差 $R$ 为恒定标量。距离必须以公里为单位处理和报告（km）。影响函数 $\\phi(r)$ 是一个无量纲数。此外，推导由条件 $\\phi(r_{e}) = \\phi(0)/e$ 定义的影响函数的 e-折叠半径 $r_{e}$，并为每个测试用例计算 $r_{e}$。用公里（km）表示 $r_{e}$。\n\n你的程序必须为每个测试用例计算影响函数 $\\phi(r)$ 在五个半径 $r \\in \\{0, L, 2L, 4L, 10L\\}$（均以公里为单位）处的值，然后计算 e-折叠半径 $r_{e}$（以公里为单位）。程序必须将所有测试用例的结果汇总成单行输出，格式为一个包含在方括号内的逗号分隔列表，其中每个测试用例的结果本身是一个包含六个浮点数的列表，顺序为 $[\\phi(0), \\phi(L), \\phi(2L), \\phi(4L), \\phi(10L), r_{e}]$。\n\n使用以下探索不同参数范围的测试套件：\n\n- 测试用例 1（一般理想情况）：$\\sigma_{b}^{2} = 4.0$，$L = 100.0$ km，$R = 1.0$。\n- 测试用例 2（大观测误差方差）：$\\sigma_{b}^{2} = 4.0$，$L = 100.0$ km，$R = 100.0$。\n- 测试用例 3（短相关长度）：$\\sigma_{b}^{2} = 4.0$，$L = 20.0$ km，$R = 1.0$。\n- 测试用例 4（零观测误差方差边界情况）：$\\sigma_{b}^{2} = 4.0$，$L = 50.0$ km，$R = 0.0$。\n\n对于所有半径，距离必须以公里（km）为单位。输出的影响值 $\\phi(r)$ 必须是无量纲浮点数。e-折叠半径 $r_{e}$ 必须以公里（km）为单位报告。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果都是一个按指定顺序排列的包含六个浮点数的列表。",
            "solution": "该问题要求在单个标量观测的背景下，推导并实现最优插值（OI）的空间影响函数。推导从最佳线性无偏估计（BLUE）的基本方程开始，该方程将分析场态 $x^a$ 定义为对背景场（或初猜场）$x^b$ 的更新。\n\n域中特定位置 $\\mathbf{r}$ 的分析更新由下式给出：\n$$\nx^a(\\mathbf{r}) = x^b(\\mathbf{r}) + \\delta x^a(\\mathbf{r})\n$$\n其中 $\\delta x^a(\\mathbf{r})$ 是分析增量。OI 的核心是将此增量计算为新息（观测值减去其背景对应值）的线性组合。对于位于 $\\mathbf{r}_o$ 的单个观测 $y$，新息为 $d = y - \\mathbf{H} x^b$。算子 $\\mathbf{H}$ 将状态场映射到观测空间。在此问题中，$\\mathbf{H}$ 只是提取 $\\mathbf{r}_o$ 处的场值，因此 $\\mathbf{H} x^b = x^b(\\mathbf{r}_o)$。那么点 $\\mathbf{r}$ 处的分析增量为：\n$$\n\\delta x^a(\\mathbf{r}) = K(\\mathbf{r}) (y - x^b(\\mathbf{r}_o))\n$$\n项 $K(\\mathbf{r})$ 是使分析误差方差最小化的最优权重或增益。在多变量情况下，增益矩阵 $\\mathbf{K}$ 的通用公式为：\n$$\n\\mathbf{K} = \\mathbf{B} \\mathbf{H}^T (\\mathbf{H} \\mathbf{B} \\mathbf{H}^T + \\mathbf{R})^{-1}\n$$\n此处，$\\mathbf{B}$ 是背景误差协方差矩阵，$\\mathbf{R}$ 是观测误差协方差矩阵。我们必须将此矩阵方程应用于我们连续场和单标量观测的特定情况。\n\n1.  项 $\\mathbf{B} \\mathbf{H}^T$ 表示分析格点上的背景误差 $e^b$ 与观测位置上的背景误差之间的协方差。对于单个分析点 $\\mathbf{r}$ 和位于 $\\mathbf{r}_o$ 的单个观测，该项变为标量协方差 $\\mathbb{E}[e^b(\\mathbf{r}) e^b(\\mathbf{r}_o)]$。问题陈述背景误差的特征是方差 $\\sigma_b^2$ 和相关函数 $C(r; L)$，其中 $r = \\|\\mathbf{r} - \\mathbf{r}_o\\|$。根据定义，协方差是方差乘以相关函数，所以：\n    $$\n    \\mathbb{E}[e^b(\\mathbf{r}) e^b(\\mathbf{r}_o)] = \\sigma_b^2 C(r; L)\n    $$\n\n2.  项 $\\mathbf{H} \\mathbf{B} \\mathbf{H}^T$ 表示观测空间中的背景误差方差。对于位于 $\\mathbf{r}_o$ 的单个观测，这是该特定点的背景误差方差：$\\mathbb{E}[e^b(\\mathbf{r}_o) e^b(\\mathbf{r}_o)]$。这即是背景误差方差 $\\sigma_b^2$，因为一个点与自身的相关函数值 $C(0; L)$ 为 1。\n    $$\n    \\mathbf{H} \\mathbf{B} \\mathbf{H}^T = \\sigma_b^2\n    $$\n\n3.  项 $\\mathbf{R}$ 是观测误差协方差矩阵。对于单个独立的观测，这只是标量观测误差方差 $R$。\n\n将这些分量代回增益公式，我们得到分析点 $\\mathbf{r}$ 的标量权重 $K(\\mathbf{r})$：\n$$\nK(\\mathbf{r}) = \\left(\\sigma_b^2 C(r; L)\\right) \\left(\\sigma_b^2 + R\\right)^{-1}\n$$\n问题将空间影响函数 $\\phi(r)$ 定义为乘以新息的无量纲权重。这正是我们推导出的增益 $K(\\mathbf{r})$。因此：\n$$\n\\phi(r) = \\frac{\\sigma_b^2 C(r; L)}{\\sigma_b^2 + R}\n$$\n问题指定了高斯相关函数：\n$$\nC(r; L) = \\exp\\left( -\\frac{r^2}{2 L^2} \\right)\n$$\n将此代入 $\\phi(r)$ 的表达式，我们得到影响函数的最终形式：\n$$\n\\phi(r) = \\frac{\\sigma_b^2}{\\sigma_b^2 + R} \\exp\\left(-\\frac{r^2}{2 L^2}\\right)\n$$\n该函数描述了单个观测的新息的影响如何从其位置开始随空间衰减。影响的大小由背景误差方差与观测空间中总误差方差（背景加观测）的比率来缩放，反映了对背景与观测的相对置信度。影响的空间结构完全由背景误差相关函数决定。\n\n接下来，我们推导由条件 $\\phi(r_e) = \\phi(0)/e$ 定义的 e-折叠半径 $r_e$。首先，我们计算 $r=0$ 时的 $\\phi(r)$：\n$$\n\\phi(0) = \\frac{\\sigma_b^2}{\\sigma_b^2 + R} \\exp(0) = \\frac{\\sigma_b^2}{\\sigma_b^2 + R}\n$$\n现在我们建立 $r_e$ 的方程：\n$$\n\\phi(r_e) = \\frac{1}{e} \\phi(0)\n$$\n$$\n\\frac{\\sigma_b^2}{\\sigma_b^2 + R} \\exp\\left(-\\frac{r_e^2}{2 L^2}\\right) = \\frac{1}{e} \\left( \\frac{\\sigma_b^2}{\\sigma_b^2 + R} \\right)\n$$\n假设 $\\sigma_b^2 > 0$，我们可以消去两边的前置因子 $\\frac{\\sigma_b^2}{\\sigma_b^2 + R}$。使用恒等式 $1/e = e^{-1}$：\n$$\n\\exp\\left(-\\frac{r_e^2}{2 L^2}\\right) = e^{-1}\n$$\n对两边取自然对数得到：\n$$\n-\\frac{r_e^2}{2 L^2} = -1\n$$\n$$\nr_e^2 = 2 L^2\n$$\n求解 $r_e$（必须为非负数）：\n$$\nr_e = \\sqrt{2} L\n$$\n这个结果表明，影响函数的 e-折叠半径与背景误差协方差函数的相关长度尺度 $L$ 成正比，比例常数为 $\\sqrt{2}$。它与误差方差 $\\sigma_b^2$ 和 $R$ 无关。\n\n有了这两个推导出的公式，我们就可以进行数值实现了。\n- 影响函数：$\\phi(r) = \\frac{\\sigma_b^2}{\\sigma_b^2 + R} \\exp\\left(-\\frac{r^2}{2 L^2}\\right)$\n- e-折叠半径：$r_e = \\sqrt{2} L$\n对于 $R=0$ 和 $\\sigma_b^2 > 0$ 的特殊情况，前置因子变为 $\\frac{\\sigma_b^2}{\\sigma_b^2} = 1$，且 $\\phi(r) = C(r; L)$。这代表了完美观测的情况，此时观测位置的分析值与观测值完全匹配。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements the spatial influence function for Objective Analysis\n    using Optimal Interpolation (OI) for a single observation.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (sigma_b^2, L, R)\n    test_cases = [\n        # Test Case 1: general happy path\n        (4.0, 100.0, 1.0),\n        # Test Case 2: large observation-error variance\n        (4.0, 100.0, 100.0),\n        # Test Case 3: short correlation length\n        (4.0, 20.0, 1.0),\n        # Test Case 4: zero observation-error variance boundary\n        (4.0, 50.0, 0.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        sigma_b_sq, L, R = case\n        \n        case_results = []\n\n        # Define the influence function phi(r) based on the derived formula\n        def influence_function(r, sigma_b_sq, L, R):\n            \"\"\"\n            Computes the spatial influence function phi(r).\n            phi(r) = (sigma_b^2 / (sigma_b^2 + R)) * exp(-r^2 / (2 * L^2))\n            \"\"\"\n            # Handle the case R=0 where sigma_b_sq > 0. The pre-factor is 1.\n            # Avoids potential issues with large numbers but is robust either way.\n            if sigma_b_sq + R == 0:\n                # This case (sigma_b_sq=0 and R=0) is not in the test suite\n                # but represents no information from background or observation.\n                # Influence would be ill-defined or zero.\n                return 0.0\n            \n            prefactor = sigma_b_sq / (sigma_b_sq + R)\n            exponent = - (r**2) / (2 * L**2)\n            return prefactor * np.exp(exponent)\n\n        # Radii at which to compute the influence function\n        radii = [0 * L, 1 * L, 2 * L, 4 * L, 10 * L]\n        \n        # Calculate phi(r) for each radius\n        for r in radii:\n            phi_val = influence_function(r, sigma_b_sq, L, R)\n            case_results.append(phi_val)\n        \n        # Calculate the e-folding radius r_e based on the derived formula\n        # r_e = sqrt(2) * L\n        r_e = np.sqrt(2) * L\n        case_results.append(r_e)\n\n        all_results.append(case_results)\n\n    # Format the final output as a string representation of a list of lists.\n    # e.g., [[val1, val2, ...], [val7, val8, ...]]\n    # Python's default list-to-string conversion adds spaces, which is fine.\n    # The prompt's example f\"[{','.join(map(str, results))}]\" correctly constructs\n    # the string representation of a list of lists.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n\n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "最后的步骤是将这些原理扩展到一个真实的制图问题中。最优插值为我们将稀疏、不规则分布的数据转换为完整的网格化场及其不确定性图提供了严谨的框架。在这个综合性练习中，您将应用之前学到的所有概念，为一个实际的海洋学场景编写代码，将来自不规则船测轨迹的海表温度数据插值到一个规则网格上，并生成相应的分析误差图。",
            "id": "3805211",
            "problem": "您将处理一个计算海洋学中的场景，涉及客观分析（Objective Analysis）和最优插值（Optimal Interpolation, OI）。在一个方形域内，沿两条船的航迹收集了一组不规则的海面温度（SST）观测数据。假设SST异常构成一个二阶平稳高斯随机场，其各向同性协方差由 $C(r)=\\sigma^2\\exp\\left(-\\dfrac{r}{L}\\right)$ 指定，其中 $r$ 是以 $\\mathrm{km}$ 为单位的欧几里得距离，$\\sigma^2$ 是以 $(^\\circ\\mathrm{C})^2$ 为单位的先验方差，而 $L$ 是以 $\\mathrm{km}$ 为单位的协方差长度尺度。测量误差是独立的、高斯的，并且空间上不相关，其已知方差为 $\\epsilon^2$，单位为 $(^\\circ\\mathrm{C})^2$。\n\n您必须实现最优插值（OI），将不规则的航迹观测SST映射到规则网格上，并计算相应的分析误差方差图。客观分析（OA）和最优插值（OI）应从第一性原理出发进行推导和实现，从高斯随机场假设和最小化均方误差的线性无偏估计器的定义开始。\n\n计算域是一个方形区域，坐标单位为 $\\mathrm{km}$：$x\\in[0,200]$ 和 $y\\in[0,200]$。用于映射的网格包含 $21\\times 21$ 个点，在 $x$ 和 $y$ 方向上的间距均为 $10\\,\\mathrm{km}$。船的航迹由以下观测位置（单位为 $\\mathrm{km}$）定义：\n- 航迹A：$(10,50)$, $(40,50)$, $(70,50)$, $(100,50)$, $(130,50)$, $(160,50)$, $(190,50)$。\n- 航迹B：$(120,20)$, $(120,60)$, $(120,100)$, $(120,140)$, $(120,180)$。\n这些共计 $12$ 个观测点。相应的观测SST值（单位为 $^\\circ\\mathrm{C}$）在您的程序中必须被视为给定的常数，这些值是通过评估一个平滑、物理上合理的真实SST异常场并为保证可复现性而添加小的、固定的测量噪声来构建的。分析误差方差映射必须仅依赖于几何结构以及协方差参数 $L$、$\\sigma^2$ 和 $\\epsilon^2$。\n\n根据高斯随机场的基本原理和最佳线性无偏估计器（BLUE）的原则，推导OI权重和分析误差方差，使其成为协方差模型和观测网络的函数。在指定的网格上实现OI映射，并计算整个网格上的分析误差方差图，单位为 $(^\\circ\\mathrm{C})^2$。\n\n您的程序必须评估以下参数集测试套件，每个参数集由 $(L,\\sigma^2,\\epsilon^2)$ 指定，其中 $L$ 的单位是 $\\mathrm{km}$，$\\sigma^2, \\epsilon^2$ 的单位是 $(^\\circ\\mathrm{C})^2$：\n1. $(50,1.0,0.04)$：一个典型的中尺度主导情况，伴有中等测量误差。\n2. $(10,1.0,0.01)$：一个小长度尺度情况，观测值具有高度局部化的影响。\n3. $(200,1.0,0.25)$：一个大长度尺度情况，伴有相对较高的测量误差。\n4. $(80,1.0,4.0)$：一个极端情况，测量误差非常高，接近先验不确定性。\n\n对于每个参数集，计算整个网格上的域平均分析误差方差，单位为 $(^\\circ\\mathrm{C})^2$。将每个域平均值报告为浮点数，并四舍五入到六位小数。\n\n此问题不涉及角度单位。所有距离必须以 $\\mathrm{km}$ 为单位，所有方差必须以 $(^\\circ\\mathrm{C})^2$ 为单位。您的程序应生成单行输出，其中包含结果，格式为方括号内由逗号分隔的列表，无空格，顺序与上面列出的参数集一致，例如：$[v_1,v_2,v_3,v_4]$，其中每个 $v_i$ 是以 $(^\\circ\\mathrm{C})^2$ 为单位的域平均分析误差方差，并四舍五入到六位小数。\n\n确保科学真实性和内部一致性。映射和分析误差必须使用从所述协方差和测量误差假设推导出的OI方程进行计算，不得使用绕过这些推导过程的简化公式。",
            "solution": "该问题要求实现最优插值（OI）来估计海面温度（SST）异常场及其相应的分析误差方差。推导必须从第一性原理出发，假设SST异常构成一个二阶平稳高斯随机场。\n\n设位置 $\\mathbf{x}$ 处的真实SST异常由随机变量 $t(\\mathbf{x})$ 表示。我们有在位置 $\\mathbf{x}_i$（$i=1, \\dots, N$）处的一组 $N=12$ 个观测值。观测向量为 $\\mathbf{d}^o$，其中每个观测值 $d^o_i$ 是真实场值与测量误差 $\\eta_i$ 的和：\n$$d^o_i = t(\\mathbf{x}_i) + \\eta_i$$\n用向量形式表示为 $\\mathbf{d}^o = \\mathbf{t}^o + \\boldsymbol{\\eta}$，其中 $\\mathbf{t}^o$ 是观测位置处真实SST异常的向量。\n\n场和误差的统计特性规定如下：\n1.  场 $t(\\mathbf{x})$ 和误差 $\\boldsymbol{\\eta}$ 是零均值高斯随机变量：$E[t(\\mathbf{x})] = 0$ 和 $E[\\boldsymbol{\\eta}] = \\mathbf{0}$。\n2.  两点 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$ 之间真实场的协方差由各向同性函数 $C(r_{ij}) = \\sigma^2\\exp\\left(-\\frac{r_{ij}}{L}\\right)$ 给出，其中 $r_{ij} = ||\\mathbf{x}_i - \\mathbf{x}_j||$ 是欧几里得距离。所有观测点对之间的这些协方差构成的矩阵是先验信号协方差矩阵 $\\mathbf{P}$。其元素为 $P_{ij} = E[t(\\mathbf{x}_i) t(\\mathbf{x}_j)] = C(r_{ij})$。\n3.  测量误差在空间上不相关，且与信号无关，具有恒定的方差 $\\epsilon^2$。因此，测量误差协方差矩阵 $\\mathbf{R}$ 是对角矩阵：$R_{ij} = E[\\eta_i \\eta_j] = \\epsilon^2 \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克（Kronecker）δ函数。\n\n目标是在网格点 $\\mathbf{x}_g$ 处找到真值 $t_g = t(\\mathbf{x}_g)$ 的一个估计值，或称分析值 $t_g^a$。我们寻求最佳线性无偏估计器（BLUE）。\n\n估计器定义为观测值的线性组合：\n$$t_g^a = \\mathbf{w}^T \\mathbf{d}^o = \\sum_{i=1}^{N} w_i d^o_i$$\n其中 $\\mathbf{w}$ 是一个待确定的权重向量。\n\n估计器必须是无偏的，即其期望值等于真实量的期望值：$E[t_g^a] = E[t_g]$。\n鉴于场和观测值均为零均值的假设，我们有 $E[t_g] = 0$ 和 $E[t_g^a] = E[\\mathbf{w}^T \\mathbf{d}^o] = \\mathbf{w}^T E[\\mathbf{d}^o] = \\mathbf{0}$。因此，对于任何权重 $\\mathbf{w}$ 的选择，无偏条件都得到满足。\n\n“最佳”估计器是使均方误差最小化的估计器，该均方误差即为分析误差方差 $\\sigma_a^2$：\n$$\\sigma_a^2 = J(\\mathbf{w}) = E[(t_g^a - t_g)^2]$$\n代入 $t_g^a$ 和 $\\mathbf{d}^o$ 的表达式：\n$$\\sigma_a^2 = E\\left[ \\left(\\mathbf{w}^T (\\mathbf{t}^o + \\boldsymbol{\\eta}) - t_g\\right)^2 \\right]$$\n展开并取期望，我们利用信号和噪声不相关的事实（$E[\\mathbf{t}^o \\boldsymbol{\\eta}^T]=\\mathbf{0}$，$E[t_g \\boldsymbol{\\eta}^T]=\\mathbf{0}$）：\n$$\\sigma_a^2 = E\\left[ \\mathbf{w}^T \\mathbf{t}^o (\\mathbf{t}^o)^T \\mathbf{w} + \\mathbf{w}^T \\boldsymbol{\\eta} \\boldsymbol{\\eta}^T \\mathbf{w} - 2\\mathbf{w}^T \\mathbf{t}^o t_g + t_g^2 \\right]$$\n$$\\sigma_a^2 = \\mathbf{w}^T E[\\mathbf{t}^o (\\mathbf{t}^o)^T] \\mathbf{w} + \\mathbf{w}^T E[\\boldsymbol{\\eta} \\boldsymbol{\\eta}^T] \\mathbf{w} - 2\\mathbf{w}^T E[\\mathbf{t}^o t_g] + E[t_g^2]$$\n\n我们根据协方差的定义来确定这些期望项：\n- $E[\\mathbf{t}^o (\\mathbf{t}^o)^T] = \\mathbf{P}$，即观测点处的 $N \\times N$ 先验信号协方差矩阵。\n- $E[\\boldsymbol{\\eta} \\boldsymbol{\\eta}^T] = \\mathbf{R}$，即 $N \\times N$ 测量误差协方差矩阵。\n- $E[t_g^2] = C(0) = \\sigma^2\\exp(0) = \\sigma^2$，即场的先验方差。\n- $E[\\mathbf{t}^o t_g]$ 是一个 $N \\times 1$ 的列向量，其第 $i$ 个元素是 $E[t(\\mathbf{x}_i) t(\\mathbf{x}_g)] = C(\\mathbf{x}_i, \\mathbf{x}_g)$。我们用 $\\mathbf{p}_g$ 表示这个向量。\n\n将这些代入 $\\sigma_a^2$ 的表达式，得到成本函数：\n$$\\sigma_a^2(\\mathbf{w}) = \\mathbf{w}^T (\\mathbf{P} + \\mathbf{R}) \\mathbf{w} - 2\\mathbf{w}^T \\mathbf{p}_g + \\sigma^2$$\n为了最小化这个关于 $\\mathbf{w}$ 的二次函数，我们计算其梯度并令其为零：\n$$\\nabla_{\\mathbf{w}} \\sigma_a^2 = 2(\\mathbf{P} + \\mathbf{R})\\mathbf{w} - 2\\mathbf{p}_g = \\mathbf{0}$$\n这就得出了最优权重的正规方程：\n$$(\\mathbf{P} + \\mathbf{R})\\mathbf{w} = \\mathbf{p}_g$$\n最优权重向量 $\\mathbf{w}$ 的解是：\n$$\\mathbf{w} = (\\mathbf{P} + \\mathbf{R})^{-1} \\mathbf{p}_g$$\n矩阵 $\\mathbf{P} + \\mathbf{R}$ 是观测协方差矩阵，只要 $\\mathbf{R}$ 的对角元素为正（即 $\\epsilon^2 > 0$），它就是可逆的，本问题中此条件成立。\n\n有了最优权重，我们就可以写出最终的OI方程。\n网格点 $\\mathbf{x}_g$ 处的分析场是：\n$$t_g^a = \\mathbf{w}^T \\mathbf{d}^o = \\mathbf{p}_g^T (\\mathbf{P} + \\mathbf{R})^{-1} \\mathbf{d}^o$$\n将最优权重 $\\mathbf{w}$ 代回成本函数，可以求得分析误差方差。通过注意到 $\\mathbf{p}_g^T = \\mathbf{w}^T (\\mathbf{P}+\\mathbf{R})$，可以得到一个更简单的形式：\n$$\\sigma_a^2 = \\sigma^2 - \\mathbf{p}_g^T \\mathbf{w} = \\sigma^2 - \\mathbf{p}_g^T (\\mathbf{P} + \\mathbf{R})^{-1} \\mathbf{p}_g$$\n这个最终方程是问题的核心。它表明，任意点 $\\mathbf{x}_g$ 的分析误差方差 $\\sigma_a^2$ 是先验方差 $\\sigma^2$ 减去一个量，这个量取决于观测相对于网格点的几何分布以及统计参数 $(L, \\sigma^2, \\epsilon^2)$。关键在于，它不依赖于 $\\mathbf{d}^o$ 中的具体观测值。\n\n为解决该问题，我们将为每个参数集实现此公式。算法如下：\n1.  定义固定的观测位置 $\\mathbf{x}_i$ 并生成网格点位置集合 $\\mathbf{x}_g$。\n2.  对于每个参数集 $(L, \\sigma^2, \\epsilon^2)$：\n    a. 构建 $N \\times N$ 观测协方差矩阵 $\\mathbf{M} = \\mathbf{P} + \\mathbf{R}$。其元素为 $M_{ij} = \\sigma^2\\exp(-||\\mathbf{x}_i - \\mathbf{x}_j||/L) + \\epsilon^2\\delta_{ij}$。\n    b. 计算逆矩阵 $\\mathbf{M}^{-1}$。每个参数集只需计算一次。\n    c. 对于 $21 \\times 21 = 441$ 个网格点中的每一个 $\\mathbf{x}_g$：\n        i. 构建 $N \\times 1$ 的网格-观测协方差向量 $\\mathbf{p}_g$，其元素为 $p_{g,i} = \\sigma^2\\exp(-||\\mathbf{x}_g - \\mathbf{x}_i||/L)$。\n        ii. 计算分析误差方差：$\\sigma_{a,g}^2 = \\sigma^2 - \\mathbf{p}_g^T \\mathbf{M}^{-1} \\mathbf{p}_g$。\n    d. 计算所有 $441$ 个 $\\sigma_{a,g}^2$ 值的算术平均值，以获得域平均分析误差方差。\n3.  按照要求格式报告所有参数集的结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef solve():\n    \"\"\"\n    Solves the Optimal Interpolation problem for the given test cases.\n    \"\"\"\n\n    # --- Define problem geometry and constants ---\n    # Observation locations in km\n    obs_locs = np.array([\n        [10., 50.], [40., 50.], [70., 50.], [100., 50.], [130., 50.], [160., 50.], [190., 50.],\n        [120., 20.], [120., 60.], [120., 100.], [120., 140.], [120., 180.]\n    ])\n    num_obs = obs_locs.shape[0]\n\n    # Grid definition in km\n    grid_dim = 21\n    grid_coords = np.linspace(0., 200., grid_dim)\n    gx, gy = np.meshgrid(grid_coords, grid_coords)\n    grid_locs = np.vstack([gx.ravel(), gy.ravel()]).T\n\n    # Test cases: (L, sigma^2, epsilon^2)\n    # L in km, sigma^2 and epsilon^2 in (degC)^2\n    test_cases = [\n        (50.0, 1.0, 0.04),\n        (10.0, 1.0, 0.01),\n        (200.0, 1.0, 0.25),\n        (80.0, 1.0, 4.0),\n    ]\n\n    # As per the problem, observed SST values are constants, though not used\n    # for error variance calculation. We define them here for completeness.\n    def true_field(x, y):\n        # A simple, physically plausible smooth field for anomalies\n        return 1.5 * np.exp(-((x - 100.)**2 + (y - 100.)**2) / (2. * 60.**2))\n\n    true_values_at_obs = np.array([true_field(x, y) for x, y in obs_locs])\n    # Reproducible noise with a small, fixed standard deviation\n    rng = np.random.RandomState(seed=123)\n    noise = rng.normal(0, np.sqrt(0.0225), size=num_obs)\n    # This d_obs vector is a constant, as required by the problem statement.\n    d_obs = true_values_at_obs + noise\n\n    def compute_mean_error_variance(L, sigma_sq, epsilon_sq, obs_locs, grid_locs):\n        \"\"\"\n        Computes the domain-mean analysis error variance for a given set of parameters.\n        \n        Args:\n            L (float): Covariance length scale in km.\n            sigma_sq (float): Prior variance in (degC)^2.\n            epsilon_sq (float): Measurement error variance in (degC)^2.\n            obs_locs (np.ndarray): Array of observation locations (N_obs, 2).\n            grid_locs (np.ndarray): Array of grid locations (N_grid, 2).\n\n        Returns:\n            float: The domain-mean analysis error variance.\n        \"\"\"\n        n_obs = obs_locs.shape[0]\n\n        # 1. Construct observation covariance matrix M = P + R\n        # P: prior signal covariance matrix between observations\n        dist_obs_obs = cdist(obs_locs, obs_locs, 'euclidean')\n        P = sigma_sq * np.exp(-dist_obs_obs / L)\n        \n        # R: measurement error covariance matrix (diagonal)\n        R = np.eye(n_obs) * epsilon_sq\n        \n        M = P + R\n        \n        # 2. Invert the matrix M\n        try:\n            M_inv = np.linalg.inv(M)\n        except np.linalg.LinAlgError:\n            # Add a small nugget for stability if matrix is singular, though\n            # epsilon_sq > 0 should prevent this.\n            M += np.eye(n_obs) * 1e-9\n            M_inv = np.linalg.inv(M)\n\n        # 3. Compute analysis error variance for each grid point\n        # p_g: grid-to-observation covariance vector\n        dist_grid_obs = cdist(grid_locs, obs_locs, 'euclidean')\n        P_go = sigma_sq * np.exp(-dist_grid_obs / L) # Shape: (n_grid, n_obs)\n        \n        # Variance reduction term: p_g^T * M^-1 * p_g for each grid point\n        # This can be vectorized efficiently.\n        # einsum 'ik,kl,lj->i' does (P_go @ M_inv @ P_go.T) and takes the diagonal.\n        # A more direct way is sum( (P_go @ M_inv) * P_go, axis=1)\n        variance_reduction = np.sum((P_go @ M_inv) * P_go, axis=1)\n        \n        # Analysis error variance map: sigma_a^2 = sigma^2 - reduction\n        analysis_error_variance_map = sigma_sq - variance_reduction\n        \n        # 4. Compute domain-mean of the analysis error variance\n        mean_error_variance = np.mean(analysis_error_variance_map)\n        \n        return mean_error_variance\n\n    results = []\n    for case in test_cases:\n        L, sigma_sq, epsilon_sq = case\n        mean_var = compute_mean_error_variance(L, sigma_sq, epsilon_sq, obs_locs, grid_locs)\n        results.append(f\"{mean_var:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}