{
    "hands_on_practices": [
        {
            "introduction": "在四维变分资料同化中，伴随模型是高效计算代价函数梯度的核心。在依赖它进行优化之前，我们必须首先确保伴随算子本身的实现是正确的。这项实践 () 引导您完成一个基本的“伴随检验”，通过数值方法验证您所构建的离散伴随算子是否真正满足其数学定义——即在给定内积下，它确实是切线性算子的共轭转置。这是调试任何变分同化系统代码的第一个关键步骤。",
            "id": "3793618",
            "problem": "在计算海洋学中，考虑伴随模型在四维变分资料同化（4D-Var）中的作用。切线性算子的数值伴随必须在选定的内积下对任何状态扰动满足离散伴随性质。设 $\\mathbb{R}^N$ 上的内积定义为 $\\langle \\mathbf{x}, \\mathbf{y} \\rangle_{\\mathbf{W}} = \\mathbf{x}^\\top \\mathbf{W} \\mathbf{y}$，其中 $\\mathbf{W} \\in \\mathbb{R}^{N \\times N}$ 是对称正定矩阵。对于线性算子 $\\mathbf{L} \\in \\mathbb{R}^{N \\times N}$，其在该内积下的离散伴随（记为 $\\mathbf{L}^\\dagger$）由 $\\langle \\mathbf{L}\\mathbf{x}, \\mathbf{y} \\rangle_{\\mathbf{W}} = \\langle \\mathbf{x}, \\mathbf{L}^\\dagger \\mathbf{y} \\rangle_{\\mathbf{W}}$ 对所有 $\\mathbf{x}, \\mathbf{y} \\in \\mathbb{R}^N$ 定义。\n\n从一个在海洋学中常用且具有物理意义的一维示踪剂输运模型开始，该模型包括平流、扩散和二次局部反应。其连续方程为\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = K \\frac{\\partial^2 u}{\\partial x^2} + \\gamma u^2,\n$$\n定义在域 $x \\in [0,1]$上，边界条件为周期性边界条件或齐次 Neumann 边界条件（两端通量为零）。设 $u$ 在具有 $N$ 个点和间距 $h$ 的均匀网格上离散化（对于周期性边界条件，$h = \\frac{1}{N}$；对于 Neumann 边界条件，$h = \\frac{1}{N-1}$）。对内部点使用二阶中心差分。对于周期性边界，使用环绕索引。对于齐次 Neumann 边界，通过镜像虚拟点对二阶导数强制施加零梯度，并在边界处将一阶导数设为零。\n\n通过以下方式定义一个单步显式 Euler 时间步映射 $F: \\mathbb{R}^N \\to \\mathbb{R}^N$：\n$$\nF(\\mathbf{u}) = \\mathbf{u} + \\Delta t \\left( -c \\mathbf{D}_x \\mathbf{u} + K \\mathbf{D}_{xx} \\mathbf{u} + \\gamma \\, \\mathbf{u} \\odot \\mathbf{u} \\right),\n$$\n其中 $\\mathbf{D}_x$ 是离散一阶导数矩阵，$\\mathbf{D}_{xx}$ 是离散二阶导数（拉普拉斯）矩阵，$\\Delta t$ 是时间步长，$c$ 是平流速度，$K$ 是扩散系数，$\\gamma$ 是反应系数，$\\odot$ 表示逐元素乘法。关于背景状态 $\\bar{\\mathbf{u}}$ 的线性化正向算子（切线性）为\n$$\n\\mathbf{L} = \\mathbf{I} + \\Delta t \\left( -c \\mathbf{D}_x + K \\mathbf{D}_{xx} + 2 \\gamma \\, \\operatorname{diag}(\\bar{\\mathbf{u}}) \\right),\n$$\n其中 $\\operatorname{diag}(\\bar{\\mathbf{u}})$ 是对角线上为 $\\bar{\\mathbf{u}}$ 各项的对角矩阵。\n\n在加权内积 $\\langle \\cdot, \\cdot \\rangle_{\\mathbf{W}}$ 下，离散伴随为\n$$\n\\mathbf{L}^\\dagger = \\mathbf{W}^{-1} \\mathbf{L}^\\top \\mathbf{W}.\n$$\n\n您的任务是实现一个完整、可运行的程序，该程序能够：\n- 根据上述规范，为均匀网格上的周期性边界条件和齐次 Neumann 边界条件构建 $\\mathbf{D}_x$ 和 $\\mathbf{D}_{xx}$。\n- 为给定的参数集 $(N, \\Delta t, c, K, \\gamma, \\text{boundary}, \\bar{\\mathbf{u}})$ 构建 $\\mathbf{L}$。\n- 构建对角矩阵 $\\mathbf{W}$：\n  - 对于均匀加权，对所有 $i$ 设置 $w_i = h$。\n  - 对于非均匀测试，设置 $w_i = h\\left(1 + 0.5 \\sin\\left(\\frac{2\\pi i}{N}\\right)\\right)$，其中 $i = 0, 1, \\ldots, N-1$，该值严格为正。\n- 通过计算标量差来验证离散伴随性质\n$$\n\\delta = \\left| \\langle \\mathbf{L}\\mathbf{x}, \\mathbf{y} \\rangle_{\\mathbf{W}} - \\langle \\mathbf{x}, \\mathbf{L}^\\dagger \\mathbf{y} \\rangle_{\\mathbf{W}} \\right|\n$$\n对于随机生成的 $\\mathbf{x}, \\mathbf{y}$，并检查是否满足 $\\delta \\le \\tau$，其中容差 $\\tau = 10^{-10}$。使用一个具有指定整数种子 $s$ 的确定性伪随机数生成器，并从标准正态分布 $\\mathcal{N}(0,1)$ 中独立抽取 $\\bar{\\mathbf{u}}, \\mathbf{x}, \\mathbf{y}$。\n\n实现以下参数集测试套件，每个测试由 $(N, \\Delta t, c, K, \\gamma, \\text{boundary}, \\text{weights}, s)$ 定义：\n- 测试 1（一般平流-扩散-反应，周期性，均匀权重）：$(N=\\!64, \\Delta t=\\!10^{-3}, c=\\!0.4, K=\\!10^{-2}, \\gamma=\\!0.5, \\text{periodic}, \\text{uniform}, s=\\!1)$。\n- 测试 2（平流主导，周期性，均匀权重）：$(N=\\!128, \\Delta t=\\!2\\times 10^{-3}, c=\\!1.0, K=\\!0.0, \\gamma=\\!0.0, \\text{periodic}, \\text{uniform}, s=\\!2)$。\n- 测试 3（扩散主导，Neumann，均匀权重）：$(N=\\!50, \\Delta t=\\!5\\times 10^{-3}, c=\\!0.0, K=\\!5\\times 10^{-2}, \\gamma=\\!0.0, \\text{neumann}, \\text{uniform}, s=\\!3)$。\n- 测试 4（非线性反应，非均匀权重，周期性）：$(N=\\!60, \\Delta t=\\!10^{-3}, c=\\!0.2, K=\\!10^{-2}, \\gamma=\\!1.0, \\text{periodic}, \\text{nonuniform}, s=\\!4)$。\n- 测试 5（小时间步长边界情况，Neumann，均匀权重）：$(N=\\!32, \\Delta t=\\!10^{-6}, c=\\!0.3, K=\\!2\\times 10^{-2}, \\gamma=\\!0.7, \\text{neumann}, \\text{uniform}, s=\\!5)$。\n- 测试 6（小网格，周期性，均匀权重）：$(N=\\!5, \\Delta t=\\!10^{-3}, c=\\!0.5, K=\\!0.0, \\gamma=\\!0.0, \\text{periodic}, \\text{uniform}, s=\\!6)$。\n\n对于每个测试用例，您的程序必须：\n- 使用指定的参数构建 $\\mathbf{D}_x$、$\\mathbf{D}_{xx}$、$\\mathbf{L}$ 和 $\\mathbf{W}$。\n- 使用给定的种子 $s$ 生成 $\\bar{\\mathbf{u}}$、$\\mathbf{x}$、$\\mathbf{y}$。\n- 计算由 $\\delta \\le \\tau$ 定义的一致性检查的布尔结果。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含所有测试用例的结果，格式为方括号内以逗号分隔的列表（例如，$[\\text{result}_1,\\text{result}_2,\\ldots,\\text{result}_6]$），其中每个条目是相应测试用例的布尔值，按上面列出的顺序排列。",
            "solution": "此问题的目标是验证从一维平流-扩散-反应方程派生出的切线性模型的离散伴随性质，这是开发 4D-Var 资料同化系统中的一项基本任务。该验证通过在指定的加权内积下数值检验离散伴随的定义关系来进行。\n\n连续物理模型是定义在域 $x \\in [0,1]$ 上的一个示踪剂输运方程：\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = K \\frac{\\partial^2 u}{\\partial x^2} + \\gamma u^2\n$$\n在这里，$u(x,t)$ 是示踪剂浓度，$c$ 是平流速度，$K$ 是扩散系数，$\\gamma$ 是二次反应系数。系统状态在一个包含 $N$ 个点的均匀网格上离散化，表示为向量 $\\mathbf{u} \\in \\mathbb{R}^N$。使用显式 Euler 方法的单个时间步定义了一个非线性正向模型 $F: \\mathbb{R}^N \\to \\mathbb{R}^N$：\n$$\nF(\\mathbf{u}) = \\mathbf{u} + \\Delta t \\left( -c \\mathbf{D}_x \\mathbf{u} + K \\mathbf{D}_{xx} \\mathbf{u} + \\gamma \\, \\mathbf{u} \\odot \\mathbf{u} \\right)\n$$\n其中 $\\mathbf{D}_x$ 和 $\\mathbf{D}_{xx}$ 分别是一阶和二阶空间导数的矩阵表示，$\\Delta t$ 是时间步长，$\\odot$ 是逐元素乘积。\n\n4D-Var 的核心涉及切线性模型，该模型描述了小扰动的演化。这是通过围绕背景轨迹状态 $\\bar{\\mathbf{u}}$ 对 $F$ 进行线性化得到的。由此产生的切线性算子 $\\mathbf{L}$ 是：\n$$\n\\mathbf{L} = \\frac{\\partial F}{\\partial \\mathbf{u}}\\bigg|_{\\bar{\\mathbf{u}}} = \\mathbf{I} + \\Delta t \\left( -c \\mathbf{D}_x + K \\mathbf{D}_{xx} + 2 \\gamma \\, \\operatorname{diag}(\\bar{\\mathbf{u}}) \\right)\n$$\n其中 $\\mathbf{I}$ 是单位矩阵，$\\operatorname{diag}(\\bar{\\mathbf{u}})$ 是一个对角线元素为 $\\bar{\\mathbf{u}}$ 中元素的对角矩阵。\n\n在 4D-Var 中，伴随模型对于高效计算代价函数的梯度至关重要。伴随算子 $\\mathbf{L}^\\dagger$ 是相对于一个内积定义的。对于此问题，使用加权内积 $\\langle \\mathbf{x}, \\mathbf{y} \\rangle_{\\mathbf{W}} = \\mathbf{x}^\\top \\mathbf{W} \\mathbf{y}$，其中 $\\mathbf{W}$ 是一个对称正定权重矩阵。伴随的定义性质是 $\\langle \\mathbf{L}\\mathbf{x}, \\mathbf{y} \\rangle_{\\mathbf{W}} = \\langle \\mathbf{x}, \\mathbf{L}^\\dagger \\mathbf{y} \\rangle_{\\mathbf{W}}$，对所有向量 $\\mathbf{x}, \\mathbf{y} \\in \\mathbb{R}^N$ 成立。根据此定义，可以数学推导出伴随的矩阵表示为 $\\mathbf{L}^\\dagger = \\mathbf{W}^{-1} \\mathbf{L}^\\top \\mathbf{W}$。\n\n实现过程首先是构建离散导数算子 $\\mathbf{D}_x$ 和 $\\mathbf{D}_{xx}$。对于周期性边界条件和 Neumann 边界条件，这些算子都是使用二阶中心差分构建的。\n- 对于 $N$ 个网格点上间距为 $h = 1/N$ 的周期性边界，索引会环绕（例如，节点 $i$ 的邻居是 $(i-1+N)\\%N$ 和 $(i+1)\\%N$）。这将产生循环矩阵。\n- 对于 $N$ 个网格点上间距为 $h = 1/(N-1)$ 的齐次 Neumann 边界，条件按如下方式施加：\n  - 对于一阶导数 $\\mathbf{D}_x$，在边界（$x=0$ 和 $x=1$）处梯度设置为零。这通过将 $\\mathbf{D}_x$ 矩阵的第一行和最后一行设置为零来实现。\n  - 对于二阶导数 $\\mathbf{D}_{xx}$，使用镜像虚拟点（例如，在左边界 $u_{-1}=u_1$）来实现零通量条件。这会修改 $\\mathbf{D}_{xx}$ 矩阵的第一行和最后一行。对于节点 $i=0$，差分格式变为 $(2u_1 - 2u_0)/h^2$；对于节点 $i=N-1$，它变为 $(2u_{N-2} - 2u_{N-1})/h^2$。\n\n接下来，构建对角权重矩阵 $\\mathbf{W}$。对于均匀加权，对角元素均为 $w_i = h$。对于指定的非均匀情况，它们是 $w_i = h(1 + 0.5 \\sin(2\\pi i/N))$。\n\n在定义了所有分量矩阵（$\\mathbf{D}_x$、$\\mathbf{D}_{xx}$、$\\mathbf{W}$）并给定一个随机背景状态 $\\bar{\\mathbf{u}}$ 后，组装切线性算子 $\\mathbf{L}$。随后，使用公式 $\\mathbf{L}^\\dagger = \\mathbf{W}^{-1} \\mathbf{L}^\\top \\mathbf{W}$ 计算其离散伴随 $\\mathbf{L}^\\dagger$。\n\n最后一步是验证，通常称为“伴随检验”。对于随机生成的扰动向量 $\\mathbf{x}$ 和 $\\mathbf{y}$，计算伴随恒等式的两边：\n- 左侧：$\\text{LHS} = \\langle \\mathbf{L}\\mathbf{x}, \\mathbf{y} \\rangle_{\\mathbf{W}} = (\\mathbf{L}\\mathbf{x})^\\top \\mathbf{W} \\mathbf{y}$\n- 右侧：$\\text{RHS} = \\langle \\mathbf{x}, \\mathbf{L}^\\dagger \\mathbf{y} \\rangle_{\\mathbf{W}} = \\mathbf{x}^\\top \\mathbf{W} (\\mathbf{L}^\\dagger \\mathbf{y})$\n通过检查绝对差 $\\delta = |\\text{LHS} - \\text{RHS}|$ 是否小于预定的数值容差 $\\tau = 10^{-10}$，来确认所实现的伴随的数值有效性。为了可复现性，使用一个设定了种子的确定性伪随机数生成器来生成向量 $\\bar{\\mathbf{u}}$、$\\mathbf{x}$ 和 $\\mathbf{y}$。程序遍历指定的测试用例，对每个用例执行此验证，并报告布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_derivative_matrices(N, h, boundary_type):\n    \"\"\"\n    Constructs discrete first and second derivative matrices for a 1D grid.\n\n    Args:\n        N (int): Number of grid points.\n        h (float): Grid spacing.\n        boundary_type (str): 'periodic' or 'neumann'.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: The Dx and Dxx matrices.\n    \"\"\"\n    Dx = np.zeros((N, N))\n    Dxx = np.zeros((N, N))\n\n    if boundary_type == 'periodic':\n        # Second-order centered differences with wrap-around indexing\n        for i in range(N):\n            im1 = (i - 1 + N) % N\n            ip1 = (i + 1) % N\n            Dx[i, ip1] = 1.0 / (2.0 * h)\n            Dx[i, im1] = -1.0 / (2.0 * h)\n            Dxx[i, ip1] = 1.0 / (h * h)\n            Dxx[i, i] = -2.0 / (h * h)\n            Dxx[i, im1] = 1.0 / (h * h)\n    elif boundary_type == 'neumann':\n        # Interior points use second-order centered differences\n        for i in range(1, N - 1):\n            Dx[i, i + 1] = 1.0 / (2.0 * h)\n            Dx[i, i - 1] = -1.0 / (2.0 * h)\n            Dxx[i, i + 1] = 1.0 / (h * h)\n            Dxx[i, i] = -2.0 / (h * h)\n            Dxx[i, i - 1] = 1.0 / (h * h)\n        \n        # Dx boundaries are zero to enforce zero gradient\n        # This is handled by initializing Dx to zeros and only filling the interior.\n\n        # Dxx boundaries use mirrored ghost points for zero flux\n        # At i = 0: (u_1 - 2u_0 + u_{-1})/h^2 with u_{-1}=u_1\n        Dxx[0, 1] = 2.0 / (h * h)\n        Dxx[0, 0] = -2.0 / (h * h)\n        # At i = N-1: (u_{N} - 2u_{N-1} + u_{N-2})/h^2 with u_{N}=u_{N-2}\n        Dxx[N - 1, N - 2] = 2.0 / (h * h)\n        Dxx[N - 1, N - 1] = -2.0 / (h * h)\n    else:\n        raise ValueError(f\"Invalid boundary type specified: {boundary_type}\")\n        \n    return Dx, Dxx\n\ndef run_adjoint_test(N, dt, c, K, gamma, boundary, weights_type, s):\n    \"\"\"\n    Runs a single adjoint test case.\n    \"\"\"\n    # Use a deterministic pseudo-random number generator with the specified seed\n    rng = np.random.default_rng(s)\n    \n    # Generate random state vectors from a standard normal distribution\n    u_bar = rng.standard_normal(N)\n    x = rng.standard_normal(N)\n    y = rng.standard_normal(N)\n    \n    # Determine grid spacing h based on boundary conditions\n    if boundary == 'periodic':\n        h = 1.0 / N\n    elif boundary == 'neumann':\n        h = 1.0 / (N - 1)\n    else:\n        raise ValueError(f\"Invalid boundary type: {boundary}\")\n\n    # Build derivative matrices\n    Dx, Dxx = build_derivative_matrices(N, h, boundary)\n    \n    # Build diagonal weighting matrix W\n    if weights_type == 'uniform':\n        w_diag = h * np.ones(N)\n    elif weights_type == 'nonuniform':\n        i = np.arange(N)\n        w_diag = h * (1.0 + 0.5 * np.sin(2.0 * np.pi * i / N))\n    else:\n        raise ValueError(f\"Invalid weights type: {weights_type}\")\n    \n    W = np.diag(w_diag)\n    \n    # Build tangent-linear operator L\n    L = np.identity(N) + dt * (-c * Dx + K * Dxx + 2.0 * gamma * np.diag(u_bar))\n    \n    # Build discrete adjoint L_dagger using the formula L_dagger = W^-1 * L^T * W\n    W_inv = np.diag(1.0 / w_diag)\n    L_dagger = W_inv @ L.T @ W\n    \n    # Compute the two sides of the adjoint property using the inner product\n    lhs = (L @ x).T @ W @ y\n    rhs = x.T @ W @ (L_dagger @ y)\n    \n    delta = np.abs(lhs - rhs)\n    tau = 1e-10\n    \n    return delta = tau\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the results.\n    \"\"\"\n    test_suite = [\n        # (N, dt, c, K, gamma, boundary, weights, s)\n        (64, 1e-3, 0.4, 1e-2, 0.5, 'periodic', 'uniform', 1),\n        (128, 2e-3, 1.0, 0.0, 0.0, 'periodic', 'uniform', 2),\n        (50, 5e-3, 0.0, 5e-2, 0.0, 'neumann', 'uniform', 3),\n        (60, 1e-3, 0.2, 1e-2, 1.0, 'periodic', 'nonuniform', 4),\n        (32, 1e-6, 0.3, 2e-2, 0.7, 'neumann', 'uniform', 5),\n        (5, 1e-3, 0.5, 0.0, 0.0, 'periodic', 'uniform', 6),\n    ]\n\n    results = [run_adjoint_test(*params) for params in test_suite]\n\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "验证了伴随算子之后，下一步是确保整个代价函数的梯度计算是准确无误的。这不仅涉及使用伴随模型计算的观测项梯度，还包括背景项的贡献。这项实践 () 聚焦于一个更为全面的“梯度检验”：将通过伴随方法推导出的解析梯度与使用中心差分法得到的数值梯度进行比较。通过检查两者在随机方向上的一致性，您可以满怀信心地确认梯度计算的正确性，这是任何优化算法能够成功收敛的前提。",
            "id": "3793675",
            "problem": "您必须在计算海洋学中为四维变分资料同化（4D-Var）的代价函数实现一个严格的梯度检验。从4D-Var代价函数的定义和一个线性的一维周期性示踪物模型开始。您将比较沿随机方向的有限差分方向导数与基于伴随的梯度，并使用明确的容差来决定是否接受。\n\n在无量纲单位下建立以下纯数学且数值上自洽的问题。考虑一个具有$n$个网格点且网格间距为 $\\Delta x = 1/n$ 的一维周期性区域。设 $\\Delta t$ 为时间步长，$K$ 为时间步数，$c$ 为恒定平流速度，$\\nu$ 为恒定扩散系数。线性正向模型通过以下方式更新示踪物状态 $x_k \\in \\mathbb{R}^n$：\n$$\nx_{k+1} = M x_k,\n$$\n其中模型矩阵 $M \\in \\mathbb{R}^{n \\times n}$ 由具有周期性边界条件的平流-扩散方程的显式欧拉离散化定义：\n$$\nM = I + \\Delta t \\left( A_{\\mathrm{adv}} + A_{\\mathrm{diff}} \\right),\n$$\n其中\n$$\nA_{\\mathrm{adv}} = -\\frac{c}{\\Delta x}\\left(I - S_{-}\\right), \\quad A_{\\mathrm{diff}} = \\frac{\\nu}{\\Delta x^2}\\left(S_{+} + S_{-} - 2I\\right).\n$$\n此处，$I$ 是 $\\mathbb{R}^{n \\times n}$ 中的单位矩阵，$S_{-}$ 是循环移位矩阵，使得 $(S_{-} x)_i = x_{i-1}$，$S_{+}$ 是循环移位矩阵，使得 $(S_{+} x)_i = x_{i+1}$，其中指数对 $n$ 取模。\n\n在每个时间 $k \\in \\{1,\\dots,K\\}$ 的观测由一个线性观测算子 $H \\in \\mathbb{R}^{m \\times n}$ 定义，它从状态中选择 $m$ 个网格点的值，以及观测向量 $y_k \\in \\mathbb{R}^m$。背景（先验）状态为 $x_b \\in \\mathbb{R}^n$。假设背景误差和观测误差的协方差矩阵为对角矩阵：$B = \\sigma_b^2 I$ 和 $R = \\sigma_r^2 I$，因此 $B^{-1} = \\sigma_b^{-2} I$ 和 $R^{-1} = \\sigma_r^{-2} I$。\n\n四维变分（4D-Var）代价函数为\n$$\nJ(x_0) = \\frac{1}{2}(x_0 - x_b)^\\top B^{-1}(x_0 - x_b)\n+ \\frac{1}{2} \\sum_{k=1}^K \\left(H x_k - y_k\\right)^\\top R^{-1} \\left(H x_k - y_k\\right),\n$$\n其中 $x_k = M^k x_0$。\n\n您的任务是通过以下步骤对 $J$ 关于 $x_0$ 进行梯度检验：\n- 从第一性原理推导并计算 $J$ 关于 $x_0$ 的基于伴随的梯度。\n- 抽取欧几里得范数 $\\|v\\|_2 = 1$ 的随机方向 $v \\in \\mathbb{R}^n$。\n- 使用中心差分公式计算有限差分方向导数：\n$$\nD_{\\mathrm{FD}}(v) = \\frac{J(x_0 + \\varepsilon v) - J(x_0 - \\varepsilon v)}{2\\varepsilon}.\n$$\n- 计算基于伴随的方向导数：\n$$\nD_{\\mathrm{ADJ}}(v) = \\nabla J(x_0)^\\top v.\n$$\n- 对每个方向，评估绝对误差 $E_{\\mathrm{abs}} = |D_{\\mathrm{FD}}(v) - D_{\\mathrm{ADJ}}(v)|$ 和相对误差\n$$\nE_{\\mathrm{rel}} = \\frac{|D_{\\mathrm{FD}}(v) - D_{\\mathrm{ADJ}}(v)|}{\\max\\left(1, |D_{\\mathrm{FD}}(v)|, |D_{\\mathrm{ADJ}}(v)|\\right)}.\n$$\n- 如果 $E_{\\mathrm{rel}} \\le \\text{tol}_{\\mathrm{rel}}$ 或 $E_{\\mathrm{abs}} \\le \\text{tol}_{\\mathrm{abs}}$，则接受该方向上的梯度检验。\n\n为了科学上的真实性，按如下方式构造 $y_k$ 和 $x_b$：\n- 生成一个具有独立标准正态分布条目的“真实”初始条件 $x_0^{\\mathrm{true}}$，用相同的 $M$ 进行传播以获得 $x_k^{\\mathrm{true}}$，并设置 $y_k = H x_k^{\\mathrm{true}} + \\sigma_r \\eta_k$，其中 $\\eta_k$ 是独立的标准正态分布。\n- 设置 $x_b = x_0^{\\mathrm{true}} + \\sigma_b \\xi$，其中 $\\xi$ 是独立的标准正态分布。\n- 在 $x_0 = x_b$ 处评估梯度检验。\n\n全程使用无量纲单位。不涉及角度。不涉及百分比。\n\n实现一个程序，对于下面列出的参数集，使用独立的随机方向执行上述梯度检验，并为每个参数集返回一个布尔值：如果该集中的所有测试方向都被接受，则为true，否则为false。最终输出必须是单行，其中包含所有参数集的结果，格式为方括号内逗号分隔的列表。\n\n测试套件（每行为一个参数集；为确保可复现性，每个参数集使用独立的随机种子）：\n- 情况 1：$n=32$，$K=6$，$\\Delta t=10^{-2}$，$c=2\\times 10^{-1}$，$\\nu=5\\times 10^{-3}$，$m=16$，$\\sigma_b=5\\times 10^{-1}$，$\\sigma_r=10^{-1}$，$\\varepsilon=10^{-6}$，$\\text{tol}_{\\mathrm{rel}}=10^{-7}$，$\\text{tol}_{\\mathrm{abs}}=10^{-10}$，方向数 $=5$。\n- 情况 2：$n=32$，$K=6$，$\\Delta t=10^{-2}$，$c=2\\times 10^{-1}$，$\\nu=5\\times 10^{-3}$，$m=16$，$\\sigma_b=5\\times 10^{-1}$，$\\sigma_r=10^{-1}$，$\\varepsilon=10^{-10}$，$\\text{tol}_{\\mathrm{rel}}=10^{-3}$，$\\text{tol}_{\\mathrm{abs}}=10^{-8}$，方向数 $=5$。\n- 情况 3：$n=32$，$K=6$，$\\Delta t=10^{-2}$，$c=2\\times 10^{-1}$，$\\nu=5\\times 10^{-3}$，$m=8$，$\\sigma_b=5\\times 10^{-1}$，$\\sigma_r=10^{2}$，$\\varepsilon=10^{-6}$，$\\text{tol}_{\\mathrm{rel}}=10^{-7}$，$\\text{tol}_{\\mathrm{abs}}=10^{-10}$，方向数 $=5$。\n- 情况 4：$n=40$，$K=10$，$\\Delta t=5\\times 10^{-3}$，$c=5\\times 10^{-1}$，$\\nu=5\\times 10^{-3}$，$m=40$，$\\sigma_b=2\\times 10^{-1}$，$\\sigma_r=5\\times 10^{-2}$，$\\varepsilon=10^{-6}$，$\\text{tol}_{\\mathrm{rel}}=10^{-7}$，$\\text{tol}_{\\mathrm{abs}}=10^{-10}$，方向数 $=5$。\n- 情况 5：$n=24$，$K=5$，$\\Delta t=10^{-2}$，$c=3\\times 10^{-1}$，$\\nu=4\\times 10^{-3}$，$m=12$，$\\sigma_b=10^{-2}$，$\\sigma_r=2\\times 10^{-1}$，$\\varepsilon=10^{-6}$，$\\text{tol}_{\\mathrm{rel}}=10^{-7}$，$\\text{tol}_{\\mathrm{abs}}=10^{-10}$，方向数 $=5$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含结果，格式为方括号内逗号分隔的列表（例如，$[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是情况 $i$ 的布尔值）。",
            "solution": "用户提供的问题经评估为 **有效**。这是一个在计算资料同化领域中适定的、有科学依据的问题，没有歧义、矛盾和事实错误。任务是为一个4D-Var资料同化系统实现一个标准的数值程序——梯度检验。我们将提供一个完整的解答。\n\n我们的目标是推导4D-Var代价函数 $J(x_0)$ 关于初始状态 $x_0$ 的解析梯度。然后，这个使用伴随方法计算的解析梯度将与有限差分近似进行比较，以验证其正确性。\n\n代价函数由下式给出：\n$$\nJ(x_0) = \\frac{1}{2}(x_0 - x_b)^\\top B^{-1}(x_0 - x_b)\n+ \\frac{1}{2} \\sum_{k=1}^K \\left(H x_k - y_k\\right)^\\top R^{-1} \\left(H x_k - y_k\\right)\n$$\n其中时间步 $k$ 的状态 $x_k$ 通过线性正向模型 $x_k = M^k x_0$ 与初始状态 $x_0$ 相关。代价函数由两项组成：一个背景项 $J_b(x_0)$，用于衡量与先验估计 $x_b$ 的距离；以及一个观测项 $J_o(x_0)$，用于衡量在一个时间窗内与观测 $y_k$ 的失配。\n\n$$\nJ_b(x_0) = \\frac{1}{2}(x_0 - x_b)^\\top B^{-1}(x_0 - x_b)\n$$\n$$\nJ_o(x_0) = \\frac{1}{2} \\sum_{k=1}^K \\left(H M^k x_0 - y_k\\right)^\\top R^{-1} \\left(H M^k x_0 - y_k\\right)\n$$\n\n梯度 $\\nabla J(x_0)$ 是这两项梯度之和：$\\nabla J(x_0) = \\nabla J_b(x_0) + \\nabla J_o(x_0)$。\n\n1.  **背景项的梯度**\n    背景项 $J_b(x_0)$ 是一个标准的二次型。其关于 $x_0$ 的梯度很容易计算：\n    $$\n    \\nabla J_b(x_0) = B^{-1}(x_0 - x_b)\n    $$\n    给定 $B = \\sigma_b^2 I$，其逆为 $B^{-1} = \\sigma_b^{-2} I$，所以此项简化为 $\\sigma_b^{-2}(x_0 - x_b)$。\n\n2.  **观测项的梯度（伴随方法）**\n    为了求 $\\nabla J_o(x_0)$，我们使用拉格朗日乘子法，该方法会产生伴随模型。我们将模型方程 $x_{k+1} = M x_k$（对于 $k=0, \\dots, K-1$）视为约束。拉格朗日函数 $\\mathcal{L}$ 是：\n    $$\n    \\mathcal{L}(\\{x_k\\}_{k=0}^K, \\{\\lambda_k\\}_{k=1}^K) = J(\\{x_k\\}) + \\sum_{k=0}^{K-1} \\lambda_{k+1}^\\top (M x_k - x_{k+1})\n    $$\n    在这里，代价函数用完整状态轨迹 $\\{x_k\\}_{k=0}^K$ 来表示。向量 $\\lambda_k$ 是拉格朗日乘子，也称为伴随变量。在最优点，拉格朗日函数对其所有变量的梯度为零。$J(x_0)$ 的梯度等价于受约束代价函数的全导数 $\\frac{dJ}{dx_0}$。我们可以在施加条件 $\\frac{\\partial \\mathcal{L}}{\\partial x_k} = 0$ (对于 $k=1, \\dots, K$) 之后，通过计算 $\\frac{\\partial \\mathcal{L}}{\\partial x_0}$ 来求得它。\n\n    取 $\\mathcal{L}$ 关于状态 $x_k$（对于 $k \\in \\{1, \\dots, K\\}$）的偏导数，得到：\n    $$\n    \\frac{\\partial \\mathcal{L}}{\\partial x_k} = \\frac{\\partial J}{\\partial x_k} + M^\\top \\lambda_{k+1} - \\lambda_k = H^\\top R^{-1} (H x_k - y_k) + M^\\top \\lambda_{k+1} - \\lambda_k\n    $$\n    将其设为零即可得到伴随方程。对于 $k=K$，项 $\\lambda_{K+1}$ 不在求和中出现，因此我们定义 $\\lambda_{K+1}=0$。关于 $x_K$ 的导数是：\n    $$\n    \\frac{\\partial \\mathcal{L}}{\\partial x_K} = H^\\top R^{-1} (H x_K - y_K) - \\lambda_K = 0 \\implies \\lambda_K = H^\\top R^{-1} (H x_K - y_K)\n    $$\n    对于 $k \\in \\{1, \\dots, K-1\\}$，我们有：\n    $$\n    \\frac{\\partial \\mathcal{L}}{\\partial x_k} = 0 \\implies \\lambda_k = M^\\top \\lambda_{k+1} + H^\\top R^{-1} (H x_k - y_k)\n    $$\n    这些方程定义了伴随变量的反向递推关系，从 $\\lambda_K$ 开始，并在时间上向后传播到 $\\lambda_1$。注意，由于 $R = \\sigma_r^2 I$，项 $H^\\top R^{-1} (H x_k - y_k)$ 简化为 $\\sigma_r^{-2} H^\\top (H x_k - y_k)$。\n\n    最后，通过对 $\\mathcal{L}$ 关于 $x_0$ 求导，可以得到代价函数关于初始状态 $x_0$ 的梯度：\n    $$\n    \\nabla J(x_0) = \\frac{d\\mathcal{L}}{dx_0} = \\frac{\\partial\\mathcal{L}}{\\partial x_0} = \\frac{\\partial J_b}{\\partial x_0} + M^\\top \\lambda_1 = B^{-1}(x_0 - x_b) + M^\\top \\lambda_1\n    $$\n\n3.  **梯度计算的算法摘要**\n    计算 $\\nabla J(x_0)$ 的步骤如下：\n    a.  **正向运行**：从 $x_0$ 开始，对 $k = 0, \\dots, K-1$ 积分正向模型 $x_{k+1} = M x_k$，并存储整个状态轨迹 $\\{x_k\\}_{k=1}^K$。\n    b.  **反向（伴随）运行**：\n        i.  在最终时间 $K$ 初始化伴随变量：$\\lambda_K = \\sigma_r^{-2} H^\\top (H x_K - y_K)$。\n        ii. 从 $k=K-1$ 向下到 $1$，在时间上反向积分伴随模型：$\\lambda_k = M^\\top \\lambda_{k+1} + \\sigma_r^{-2} H^\\top (H x_k - y_k)$。\n    c.  **梯度组装**：使用反向运行的结果计算最终梯度：$\\nabla J(x_0) = \\sigma_b^{-2}(x_0 - x_b) + M^\\top \\lambda_1$。\n\n4.  **梯度检验程序**\n    梯度检验通过将解析梯度沿随机方向 $v$ 的投影与方向导数的有限差分近似进行比较来验证解析梯度。\n    -   基于伴随的方向导数为 $D_{\\mathrm{ADJ}}(v) = \\nabla J(x_0)^\\top v$。\n    -   使用中心差分格式的有限差分近似为 $D_{\\mathrm{FD}}(v) = \\frac{J(x_0 + \\varepsilon v) - J(x_0 - \\varepsilon v)}{2\\varepsilon}$。\n    该实现将为多个随机单位向量 $v$ 计算这两个量，计算绝对误差 $E_{\\mathrm{abs}}$ 和相对误差 $E_{\\mathrm{rel}}$，如果误差在指定的容差 $\\text{tol}_{\\mathrm{abs}}$ 和 $\\text{tol}_{\\mathrm{rel}}$ 范围内，则接受该梯度。仅当所有测试的随机方向都被接受时，该参数集的总体检验才算通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the gradient check for all test cases and print the results.\n    \"\"\"\n\n    def run_gradient_check(n, K, dt, c, nu, m, sigma_b, sigma_r, epsilon, tol_rel, tol_abs, num_directions, seed):\n        \"\"\"\n        Performs a gradient check for a 4D-Var cost function for a single parameter set.\n        \"\"\"\n        # 1. Setup\n        np.random.seed(seed)\n        dx = 1.0 / n\n\n        # 2. Build matrices M, and define H operation\n        I = np.eye(n)\n        # (S- @ x)_i = x_{i-1}. Matrix equivalent is np.roll(I, 1, axis=0)\n        S_minus = np.roll(I, 1, axis=0)\n        # (S+ @ x)_i = x_{i+1}. Matrix equivalent is np.roll(I, -1, axis=0)\n        S_plus = np.roll(I, -1, axis=0)\n        \n        A_adv = -(c / dx) * (I - S_minus)\n        A_diff = (nu / dx**2) * (S_plus + S_minus - 2 * I)\n        M = I + dt * (A_adv + A_diff)\n        M_T = M.T\n        \n        obs_indices = np.linspace(0, n - 1, num=m, dtype=int)\n\n        # 3. Generate data (truth, obs, background)\n        x0_true = np.random.randn(n)\n        \n        y_obs_list = []\n        x_k_true = np.copy(x0_true)\n        for _ in range(K):\n            x_k_true = M @ x_k_true\n            obs_noise = np.random.randn(m)\n            y_k = x_k_true[obs_indices] + sigma_r * obs_noise\n            y_obs_list.append(y_k)\n            \n        bg_noise = np.random.randn(n)\n        x_b = x0_true + sigma_b * bg_noise\n        \n        # 4. Define cost and gradient functions\n        inv_sigma_b2 = 1.0 / sigma_b**2\n        inv_sigma_r2 = 1.0 / sigma_r**2\n\n        def calculate_J(x0):\n            j_b = 0.5 * inv_sigma_b2 * np.sum((x0 - x_b)**2)\n            \n            j_o = 0.0\n            x_k = np.copy(x0)\n            for k in range(K):\n                x_k = M @ x_k\n                innov = x_k[obs_indices] - y_obs_list[k]\n                j_o += 0.5 * inv_sigma_r2 * np.sum(innov**2)\n                \n            return j_b + j_o\n\n        def calculate_grad_J(x0):\n            # Forward run: store trajectory\n            x_traj = [x0]\n            x_k = np.copy(x0)\n            for _ in range(K):\n                x_k = M @ x_k\n                x_traj.append(x_k)\n\n            # Backward run: compute adjoint variable\n            # Initialize lambda_K\n            x_K = x_traj[K]\n            y_K = y_obs_list[K-1] # y_obs_list is 0-indexed for k=1..K\n            innov_K = x_K[obs_indices] - y_K\n            forcing_term_K = np.zeros(n)\n            forcing_term_K[obs_indices] = inv_sigma_r2 * innov_K\n            lambda_next = forcing_term_K # This is lambda_K\n\n            # Loop for k from K-1 down to 1\n            for k in range(K - 1, 0, -1):\n                x_k = x_traj[k]\n                y_k = y_obs_list[k-1]\n                \n                innov_k = x_k[obs_indices] - y_k\n                forcing_term_k = np.zeros(n)\n                forcing_term_k[obs_indices] = inv_sigma_r2 * innov_k\n                \n                lambda_current = M_T @ lambda_next + forcing_term_k\n                lambda_next = lambda_current\n\n            # After loop, lambda_next is lambda_1\n            lambda_1 = lambda_next\n            \n            grad_b = inv_sigma_b2 * (x0 - x_b)\n            grad_o = M_T @ lambda_1\n            \n            return grad_b + grad_o\n\n        # 5. Perform the gradient check at x0 = x_b\n        x0_eval = x_b\n        grad_adj = calculate_grad_J(x0_eval)\n        \n        for i in range(num_directions):\n            v = np.random.randn(n)\n            v /= np.linalg.norm(v)\n\n            J_plus = calculate_J(x0_eval + epsilon * v)\n            J_minus = calculate_J(x0_eval - epsilon * v)\n\n            D_fd = (J_plus - J_minus) / (2.0 * epsilon)\n            D_adj = grad_adj.T @ v\n\n            E_abs = np.abs(D_fd - D_adj)\n            denom = max(1.0, np.abs(D_fd), np.abs(D_adj))\n            E_rel = E_abs / denom\n\n            if not (E_rel = tol_rel or E_abs = tol_abs):\n                return False # Failed test for this direction\n        \n        return True # All directions passed\n\n    test_cases = [\n        # n, K, dt, c, nu, m, sigma_b, sigma_r, epsilon, tol_rel, tol_abs, num_directions\n        (32, 6, 1e-2, 2e-1, 5e-3, 16, 5e-1, 1e-1, 1e-6, 1e-7, 1e-10, 5),\n        (32, 6, 1e-2, 2e-1, 5e-3, 16, 5e-1, 1e-1, 1e-10, 1e-3, 1e-8, 5),\n        (32, 6, 1e-2, 2e-1, 5e-3, 8, 5e-1, 1e2, 1e-6, 1e-7, 1e-10, 5),\n        (40, 10, 5e-3, 5e-1, 5e-3, 40, 2e-1, 5e-2, 1e-6, 1e-7, 1e-10, 5),\n        (24, 5, 1e-2, 3e-1, 4e-3, 12, 1e-2, 2e-1, 1e-6, 1e-7, 1e-10, 5)\n    ]\n\n    results = []\n    for i, case_params in enumerate(test_cases):\n        # Use an independent random seed for each test case for reproducibility\n        result = run_gradient_check(*case_params, seed=i)\n        results.append(result)\n\n    # Format output as a lowercase boolean list: [true,false,...]\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个经过技术验证的资料同化系统，其最终分析质量仍依赖于所用统计假设的合理性，尤其是背景误差协方差$B$和观测误差协方差$R$的设定。这项实践 () 将带您从代码实现转向结果解读，学习如何使用基于新息（innovation）和分析增量（analysis increment）的卡方（$\\chi^2$）统计量来诊断同化系统。通过计算这些诊断量，我们可以评估系统是否在统计上自洽，从而判断所设定的误差协方差是偏高还是偏低，为改进同化方案提供关键依据。",
            "id": "3793697",
            "problem": "考虑一个简化的、线性化的计算海洋学设置中的四维变分资料同化（4D-Var）窗口，该窗口涵盖三个等间距的时间点 $t_{0}$、$t_{1}$ 和 $t_{2}$。在每个时间点，观测两个标量海洋量：海平面高度异常和现场温度。假设如下：\n\n- 每个时间点的观测算子均为单位矩阵，$H_{t} = I$，将模式状态直接映射到观测量。\n- 每个时间点的观测误差均为零均值高斯分布，且在各分量和时间点之间相互独立，所有时间点 $t \\in \\{t_{0}, t_{1}, t_{2}\\}$ 的观测误差协方差为 $R_{t} = \\mathrm{diag}(0.25, 1)$。\n- 三个时间点的观测新息（观测量减去模式等效值）为\n$$\nd_{t_{0}} = \\begin{pmatrix} 0.5 \\\\ 1 \\end{pmatrix}, \\quad\nd_{t_{1}} = \\begin{pmatrix} -0.5 \\\\ -2 \\end{pmatrix}, \\quad\nd_{t_{2}} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}.\n$$\n- 初始时刻的背景（先验）状态在初始条件的三维控制空间中具有零均值高斯误差，其协方差为 $B = \\mathrm{diag}(1, 4, 0.25)$。对应的初始时刻分析增量为\n$$\n\\delta x_{0} = x_{0} - x_{b} = \\begin{pmatrix} 1 \\\\ -2 \\\\ 0.5 \\end{pmatrix}.\n$$\n- 观测误差在不同时间点之间以及与背景误差之间都是独立的。\n\n从高斯误差假设和 4D-Var 代价函数分量的基本定义出发，构建窗口内基于新息和基于背景的卡方统计量，并确定它们各自的自由度。然后，将组合归一化卡方诊断量定义为\n$$\nc_{\\mathrm{tot}} = \\frac{S_{o} + S_{b}}{m + n},\n$$\n其中 $S_{o}$ 是整个窗口内基于新息的总卡方统计量，$S_{b}$ 是初始时刻基于背景的卡方统计量，$m$ 是整个窗口内独立观测分量的总数，$n$ 是背景控制向量的维度。根据给定数据计算 $c_{\\mathrm{tot}}$。将您的答案四舍五入至四位有效数字，并表示为一个无单位的纯数。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在四维变分资料同化（4D-Var）框架内具有科学依据，是适定、客观且内部一致的。所有计算所需诊断量的必要数据和定义均已提供。\n\n目标是计算组合归一化卡方诊断量 $c_{\\mathrm{tot}}$，其定义为：\n$$\nc_{\\mathrm{tot}} = \\frac{S_{o} + S_{b}}{m + n}\n$$\n其中 $S_{o}$ 是基于新息的总卡方统计量，$S_{b}$ 是基于背景的卡方统计量，$m$ 是观测总数，$n$ 是控制向量的维度。我们将计算这四个分量中的每一个。\n\n首先，我们确定自由度 $n$ 和 $m$。\n背景控制向量的维度 $n$ 对应于初始条件控制空间的大小。给定的背景误差协方差矩阵 $B$ 是一个 $3 \\times 3$ 的对角矩阵，分析增量 $\\delta x_0$ 是一个 3 维向量。因此，背景的自由度为 $n=3$。\n\n观测分量的总数 $m$ 是每个时间步的标量观测量乘以时间步数。在三个时间步（$t_{0}$、$t_{1}$、$t_{2}$）中的每一步，都观测了两个标量。因此，观测总数，也即基于新息的统计量的自由度，为 $m = 2 \\times 3 = 6$。\n\n接下来，我们构建并计算基于背景的卡方统计量 $S_{b}$。该统计量与背景（或先验）状态对 4D-Var 代价函数的贡献相关，并在分析解处进行评估。其定义为：\n$$\nS_{b} = (x_{0} - x_{b})^{T} B^{-1} (x_{0} - x_{b}) = \\delta x_{0}^{T} B^{-1} \\delta x_{0}\n$$\n给定初始时刻的分析增量：\n$$\n\\delta x_{0} = \\begin{pmatrix} 1 \\\\ -2 \\\\ 0.5 \\end{pmatrix}\n$$\n以及背景误差协方差矩阵：\n$$\nB = \\mathrm{diag}(1, 4, 0.25)\n$$\n这个对角矩阵的逆矩阵是：\n$$\nB^{-1} = \\mathrm{diag}(1^{-1}, 4^{-1}, 0.25^{-1}) = \\mathrm{diag}(1, 0.25, 4) = \\begin{pmatrix} 1  0  0 \\\\ 0  0.25  0 \\\\ 0  0  4 \\end{pmatrix}\n$$\n现在我们计算 $S_{b}$：\n$$\nS_{b} = \\begin{pmatrix} 1  -2  0.5 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  0.25  0 \\\\ 0  0  4 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ -2 \\\\ 0.5 \\end{pmatrix}\n$$\n$$\nS_{b} = 1^{2} \\times 1 + (-2)^{2} \\times 0.25 + (0.5)^{2} \\times 4\n$$\n$$\nS_{b} = 1 \\times 1 + 4 \\times 0.25 + 0.25 \\times 4 = 1 + 1 + 1 = 3\n$$\n\n接下来，我们构建并计算基于新息的总卡方统计量 $S_{o}$。该统计量量化了观测量与背景模式预报之间的失配，并由观测误差协方差加权。它是通过对每个观测时间的卡方值求和来计算的：\n$$\nS_{o} = \\sum_{t \\in \\{t_0, t_1, t_2\\}} S_{o,t} = \\sum_{t \\in \\{t_0, t_1, t_2\\}} d_{t}^{T} R_{t}^{-1} d_{t}\n$$\n所有时间步的观测误差协方差矩阵 $R_{t}$ 都是相同的：\n$$\nR_{t} = \\mathrm{diag}(0.25, 1)\n$$\n其逆矩阵为：\n$$\nR_{t}^{-1} = \\mathrm{diag}(0.25^{-1}, 1^{-1}) = \\mathrm{diag}(4, 1) = \\begin{pmatrix} 4  0 \\\\ 0  1 \\end{pmatrix}\n$$\n我们使用给定的新息向量 $d_t$ 计算每个时间步的贡献：\n\n对于 $t=t_{0}$：$d_{t_{0}} = \\begin{pmatrix} 0.5 \\\\ 1 \\end{pmatrix}$\n$$\nS_{o,t_{0}} = d_{t_{0}}^{T} R_{t_{0}}^{-1} d_{t_{0}} = (0.5)^{2} \\times 4 + 1^{2} \\times 1 = 0.25 \\times 4 + 1 = 1 + 1 = 2\n$$\n\n对于 $t=t_{1}$：$d_{t_{1}} = \\begin{pmatrix} -0.5 \\\\ -2 \\end{pmatrix}$\n$$\nS_{o,t_{1}} = d_{t_{1}}^{T} R_{t_{1}}^{-1} d_{t_{1}} = (-0.5)^{2} \\times 4 + (-2)^{2} \\times 1 = 0.25 \\times 4 + 4 = 1 + 4 = 5\n$$\n\n对于 $t=t_{2}$：$d_{t_{2}} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$\n$$\nS_{o,t_{2}} = d_{t_{2}}^{T} R_{t_{2}}^{-1} d_{t_{2}} = 0^{2} \\times 4 + 1^{2} \\times 1 = 0 + 1 = 1\n$$\n基于新息的总卡方统计量是这些值的总和：\n$$\nS_{o} = S_{o,t_{0}} + S_{o,t_{1}} + S_{o,t_{2}} = 2 + 5 + 1 = 8\n$$\n\n最后，我们计算组合归一化卡方诊断量 $c_{\\mathrm{tot}}$：\n$$\nc_{\\mathrm{tot}} = \\frac{S_{o} + S_{b}}{m + n} = \\frac{8 + 3}{6 + 3} = \\frac{11}{9}\n$$\n对该分数进行数值计算：\n$$\nc_{\\mathrm{tot}} = 1.2222...\n$$\n四舍五入到四位有效数字，我们得到 $1.222$。",
            "answer": "$$\n\\boxed{1.222}\n$$"
        }
    ]
}