{
    "hands_on_practices": [
        {
            "introduction": "表面能量平衡是热力学海冰模型的核心，而短波辐射的分配是其中的关键输入。本练习旨在通过实现一个基于比尔-朗伯定律的双流辐射模型，来模拟入射太阳辐射在海冰中的反射、吸收和透射过程。掌握这一技能是构建任何海冰模型热力学部分的基础。",
            "id": "3789166",
            "problem": "您的任务是计算入射到海洋上一个水平均匀海冰板上的短波辐射 (SWR) 的划分，将其分为三类：表面反射、冰内吸收和向海洋的透射。海冰使用一个双波段光谱模型（在两个光谱流的意义上是“双流”）处理，该模型具有不同的消光系数。您的程序必须为指定的测试套件实现此划分并生成所需的输出。\n\n物理设定如下。一个向下的短波辐射通量 $F_0$（单位为 $\\mathrm{W\\,m^{-2}}$）入射到空气-冰界面上。由于空气-冰界面的光学特性（例如，菲涅尔反射和即时的近表面效应），$F_0$ 的一部分 $R_s$（无量纲）在表面被反射。剩余部分 $(1 - R_s)$ 进入冰中。在冰内部，短波辐射被表示为两个光谱流，其分数分别为 $f_1$ 和 $f_2 = 1 - f_1$，每个光谱流在厚度为 $H$（单位为 $\\mathrm{m}$）的冰板中以消光系数 $k_1$ 和 $k_2$（单位为 $\\mathrm{m^{-1}}$）进行指数衰减。所有到达冰-海界面的辐射都被假定透射到海洋中，并在那里被吸收而没有进一步的反射。\n\n您的推导必须从适用于计算海洋学和耦合海-冰模型的物理基础原理出发，具体包括：\n- 辐射通量的能量守恒。\n- 用于均匀吸收介质中衰减的比尔-朗伯定律 (BLL)。\n\n基于这些原理，为每个测试用例计算：\n- 表面反射 $F_{\\text{surf}}$（单位为 $\\mathrm{W\\,m^{-2}}$）。\n- 冰内吸收 $F_{\\text{abs}}$（单位为 $\\mathrm{W\\,m^{-2}}$）。\n- 向海洋的透射 $F_{\\text{trans}}$（单位为 $\\mathrm{W\\,m^{-2}}$）。\n\n您的程序必须处理以下包含参数集 $(F_0, H, R_s, f_1, k_1, k_2)$ 的测试套件：\n1. 正常路径：$(F_0 = 300\\,\\mathrm{W\\,m^{-2}}, H = 1.2\\,\\mathrm{m}, R_s = 0.06, f_1 = 0.55, k_1 = 1.2\\,\\mathrm{m^{-1}}, k_2 = 4.0\\,\\mathrm{m^{-1}})$。\n2. 边界情况（零厚度）：$(F_0 = 300\\,\\mathrm{W\\,m^{-2}}, H = 0.0\\,\\mathrm{m}, R_s = 0.06, f_1 = 0.55, k_1 = 1.2\\,\\mathrm{m^{-1}}, k_2 = 4.0\\,\\mathrm{m^{-1}})$。\n3. 边缘情况（非常厚的海冰）：$(F_0 = 300\\,\\mathrm{W\\,m^{-2}}, H = 5.0\\,\\mathrm{m}, R_s = 0.06, f_1 = 0.55, k_1 = 1.2\\,\\mathrm{m^{-1}}, k_2 = 4.0\\,\\mathrm{m^{-1}})$。\n4. 边缘情况（一个不衰减的光谱流）：$(F_0 = 300\\,\\mathrm{W\\,m^{-2}}, H = 1.2\\,\\mathrm{m}, R_s = 0.06, f_1 = 0.30, k_1 = 0.0\\,\\mathrm{m^{-1}}, k_2 = 10.0\\,\\mathrm{m^{-1}})$。\n5. 边缘情况（高表面反射率）：$(F_0 = 300\\,\\mathrm{W\\,m^{-2}}, H = 1.2\\,\\mathrm{m}, R_s = 0.50, f_1 = 0.55, k_1 = 1.2\\,\\mathrm{m^{-1}}, k_2 = 4.0\\,\\mathrm{m^{-1}})$。\n\n所有输出必须以 $\\mathrm{W\\,m^{-2}}$ 为单位，表示为小数点后恰好有六位的小数浮点数。您的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的、包含在方括号内的每个测试用例的三元组列表，其中每个三元组本身是一个方括号括起来的逗号分隔列表，顺序为 $[F_{\\text{surf}}, F_{\\text{abs}}, F_{\\text{trans}}]$。例如：$[[x_1,y_1,z_1],[x_2,y_2,z_2],\\dots]$。\n\n不要读取任何输入。直接在您的程序中使用上面提供的参数。确保计算遵循指定的原理，并确保能量守恒，使得在数值公差范围内，$F_{\\text{surf}} + F_{\\text{abs}} + F_{\\text{trans}}$ 等于 $F_0$。",
            "solution": "该问题已经过验证，被认为是合理的。它具有科学依据，问题提出得当，客观，并包含了获得唯一且有意义的解所需的所有必要信息。该物理模型虽然经过简化，却是计算海洋学和海冰模拟中使用的标准表示方法。\n\n任务是计算入射短波辐射 (SWR) 到三个分量的划分：表面反射 ($F_{\\text{surf}}$)、冰内吸收 ($F_{\\text{abs}}$) 和向海洋的透射 ($F_{\\text{trans}}$)。推导将基于能量守恒原理和用于辐射衰减的比尔-朗伯定律。\n\n设 $F_0$ 为入射到空气-冰界面的向下短波辐射通量。\n\n步骤 1：表面反射\n问题陈述，入射通量的一部分 $R_s$ 在表面被反射。因此，总反射通量 $F_{\\text{surf}}$ 为：\n$$\nF_{\\text{surf}} = R_s \\cdot F_0\n$$\n这部分辐射不会进入冰板。\n\n步骤 2：进入冰的通量\n根据空气-冰界面的能量守恒，未被反射的通量必须穿透冰表面。设此通量为 $F_{\\text{in}}$。\n$$\nF_{\\text{in}} = F_0 - F_{\\text{surf}} = F_0 - R_s F_0 = (1 - R_s) F_0\n$$\n\n步骤 3：双波段光谱衰减\n问题指定了一个双波段光谱模型。进入冰的通量 $F_{\\text{in}}$ 被划分为两个光谱流。\n- 在表面 ($z=0$)，第一流中的通量为 $F_{1, \\text{in}} = f_1 \\cdot F_{\\text{in}}$。\n- 在表面 ($z=0$)，第二流中的通量为 $F_{2, \\text{in}} = f_2 \\cdot F_{\\text{in}} = (1 - f_1) F_{\\text{in}}$。\n\n每个流在穿过厚度为 $H$ 的冰层时都会衰减。比尔-朗伯定律描述了这种指数衰减。对于一个消光系数为 $k$ 的流，在深度 $z$ 处的通量 $F(z)$ 由 $F(z) = F(0) e^{-kz}$ 给出，其中 $F(0)$ 是表面的通量。\n\n到达深度 $z=H$ 处冰-海界面的每个流的通量为：\n- 对于第一流：$F_{1, \\text{trans}}(H) = F_{1, \\text{in}} \\cdot e^{-k_1 H} = f_1 (1 - R_s) F_0 e^{-k_1 H}$。\n- 对于第二流：$F_{2, \\text{trans}}(H) = F_{2, \\text{in}} \\cdot e^{-k_2 H} = (1 - f_1) (1 - R_s) F_0 e^{-k_2 H}$。\n\n步骤 4：向海洋的透射\n据陈述，所有到达冰-海界面的辐射都透射到海洋中，没有进一步的反射。因此，总透射通量 $F_{\\text{trans}}$ 是两个光谱流透射通量之和。\n$$\nF_{\\text{trans}} = F_{1, \\text{trans}}(H) + F_{2, \\text{trans}}(H)\n$$\n代入步骤 3 中的表达式：\n$$\nF_{\\text{trans}} = f_1 (1 - R_s) F_0 e^{-k_1 H} + (1 - f_1) (1 - R_s) F_0 e^{-k_2 H}\n$$\n提取公因式，我们得到透射通量的最终表达式：\n$$\nF_{\\text{trans}} = (1 - R_s) F_0 \\left[ f_1 e^{-k_1 H} + (1 - f_1) e^{-k_2 H} \\right]\n$$\n\n步骤 5：冰内吸收\n总入射通量必须守恒。它要么被反射，要么被吸收，要么被透射。\n$$\nF_0 = F_{\\text{surf}} + F_{\\text{abs}} + F_{\\text{trans}}\n$$\n我们可以通过重新排列这个守恒方程来求解吸收通量 $F_{\\text{abs}}$：\n$$\nF_{\\text{abs}} = F_0 - F_{\\text{surf}} - F_{\\text{trans}}\n$$\n这种方法通过定义确保了能量收支的闭合。\n\n或者，我们可以直接计算吸收通量，即进入冰的能量与穿过冰透射出去的能量之差：\n$$\nF_{\\text{abs}} = F_{\\text{in}} - F_{\\text{trans}}\n$$\n代入 $F_{\\text{in}}$ 和 $F_{\\text{trans}}$ 的表达式：\n$$\nF_{\\text{abs}} = (1 - R_s) F_0 - (1 - R_s) F_0 \\left[ f_1 e^{-k_1 H} + (1 - f_1) e^{-k_2 H} \\right]\n$$\n$$\nF_{\\text{abs}} = (1 - R_s) F_0 \\left( 1 - \\left[ f_1 e^{-k_1 H} + (1 - f_1) e^{-k_2 H} \\right] \\right)\n$$\n假定浮点运算精度足够，这两种计算 $F_{\\text{abs}}$ 的方法是等价的，并将产生相同的数值结果。数值实现将使用能量守恒原理以保证其稳健性。\n\n计算公式总结：\n1.  $F_{\\text{surf}} = R_s F_0$\n2.  $F_{\\text{trans}} = (1 - R_s) F_0 \\left[ f_1 e^{-k_1 H} + (1 - f_1) e^{-k_2 H} \\right]$\n3.  $F_{\\text{abs}} = F_0 - F_{\\text{surf}} - F_{\\text{trans}}$\n\n这三个公式将应用于每个提供的测试用例，以计算所需的通量划分。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the partitioning of incident Shortwave Radiation (SWR) for sea ice\n    into surface reflection, absorption within the ice, and transmission to the ocean.\n    The model is based on energy conservation and the Beer-Lambert Law for a\n    two-band spectral representation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (F0, H, Rs, f1, k1, k2)\n    # F0: Incident SWR flux (W/m^2)\n    # H: Ice thickness (m)\n    # Rs: Surface reflectance (dimensionless)\n    # f1: Fraction of penetrating SWR in the first spectral band (dimensionless)\n    # k1: Extinction coefficient for the first band (1/m)\n    # k2: Extinction coefficient for the second band (1/m)\n    test_cases = [\n        # 1. Happy path\n        (300.0, 1.2, 0.06, 0.55, 1.2, 4.0),\n        # 2. Boundary case (zero thickness)\n        (300.0, 0.0, 0.06, 0.55, 1.2, 4.0),\n        # 3. Edge case (very thick ice)\n        (300.0, 5.0, 0.06, 0.55, 1.2, 4.0),\n        # 4. Edge case (one non-attenuating stream)\n        (300.0, 1.2, 0.06, 0.30, 0.0, 10.0),\n        # 5. Edge case (high surface reflectance)\n        (300.0, 1.2, 0.50, 0.55, 1.2, 4.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        F0, H, Rs, f1, k1, k2 = case\n        f2 = 1.0 - f1\n\n        # 1. Compute surface reflection (F_surf)\n        # Fraction Rs of the incident flux F0 is reflected at the surface.\n        F_surf = Rs * F0\n\n        # 2. Compute transmission to the ocean (F_trans)\n        # The remaining flux (1 - Rs)*F0 enters the ice and is partitioned into\n        # two streams, f1 and f2, which are attenuated exponentially according\n        # to the Beer-Lambert Law.\n        F_in = (1.0 - Rs) * F0\n        \n        # Calculate transmitted flux for each stream and sum them.\n        # F_trans_1 = F_in * f1 * exp(-k1 * H)\n        # F_trans_2 = F_in * f2 * exp(-k2 * H)\n        # F_trans = F_trans_1 + F_trans_2\n        F_trans = F_in * (f1 * np.exp(-k1 * H) + f2 * np.exp(-k2 * H))\n\n        # 3. Compute absorption within the ice (F_abs)\n        # By energy conservation, the total flux must be accounted for.\n        # F0 = F_surf + F_abs + F_trans\n        F_abs = F0 - F_surf - F_trans\n\n        # Store the triplet [F_surf, F_abs, F_trans]\n        # In the edge case of H=0, F_abs can be a very small negative number\n        # due to floating point inaccuracies, so we clip it at 0.\n        if abs(F_abs)  1e-12:\n            F_abs = 0.0\n\n        results.append([F_surf, F_abs, F_trans])\n\n    # Format the final output string as specified.\n    # [[x1,y1,z1],[x2,y2,z2],...]\n    # Each number must have exactly six digits after the decimal point.\n    formatted_results = []\n    for res_triplet in results:\n        formatted_triplet = [f\"{val:.6f}\" for val in res_triplet]\n        formatted_results.append(f\"[{','.join(formatted_triplet)}]\")\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了单个物理过程的参数化后，下一步是构建一个完整的耦合系统。本练习将指导您使用高效的焓方法，创建一个简化的海冰-海洋耦合柱模型，该方法将感热和潜热统一为单个预报变量。通过验证模型在一个净能量输入为零的强迫周期后能否恢复到初始状态，您将能深刻理解模型中的能量守恒原理。",
            "id": "3789204",
            "problem": "考虑一个一维垂直柱状模型，该模型通过能量守恒和海水冰点处的瞬时相平衡，耦合了一个充分混合的海洋层和一个海冰层。该柱体由一个预设的、以一年为周期的解析地表热通量驱动。目标是设计此驱动力，使得年净能量输入为零，并通过数值时间步进验证，耦合的海洋-海冰状态在整一年后，能在指定的数值容差范围内恢复到其初始条件。\n\n假设和定义：\n- 令混合层海水温度为 $T$（单位：摄氏度），海冰厚度为 $H$（单位：米）。海水冰点为 $T_f = -1.8$ 摄氏度。\n- 将柱体相对于冰点海水的焓值定义为\n$$\nE = C_o \\left(T - T_f\\right) - L_i \\rho_i H,\n$$\n其中 $C_o$ 是单位面积的海洋混合层热容，$L_i$ 是冰的熔化潜热，$\\rho_i$ 是冰的密度。各常量为\n$$\n\\rho_w = 1025 \\ \\text{kg}\\,\\text{m}^{-3}, \\quad c_p = 3990 \\ \\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}, \\quad h = 50 \\ \\text{m},\n$$\n$$\nC_o = \\rho_w c_p h \\ \\text{J}\\,\\text{m}^{-2}\\,\\text{K}^{-1}, \\quad L_i = 3.34 \\times 10^5 \\ \\text{J}\\,\\text{kg}^{-1}, \\quad \\rho_i = 917 \\ \\text{kg}\\,\\text{m}^{-3}.\n$$\n所有通量单位为瓦特/平方米（$\\text{W m}^{-2}$），所有时间单位为秒，温度单位为摄氏度，厚度单位为米。\n\n控制定律与耦合：\n- 根据应用于该柱体的热力学第一定律，焓值 $E$ 的演化遵循\n$$\n\\frac{dE}{dt} = F(t),\n$$\n其中 $F(t)$ 是外部规定的输入柱体的净地表热通量（向下为正）。海洋-海冰的耦合通过在每个时间步将焓值映射回状态 $(T,H)$ 来实现，并遵循瞬时相平衡的约束：\n  - 如果 $E \\ge 0$，则 $H = 0$ 且 $T = T_f + E/C_o$。\n  - 如果 $E  0$，则 $T = T_f$ 且 $H = -E/(L_i \\rho_i)$。\n此映射编码了结冰和融化过程：负焓值对应于以冰层厚度形式存储的潜能，正焓值则对应于海洋中高于冰点的显热。\n\n解析驱动力周期：\n- 令 $T_{\\text{year}} = 365 \\times 86400$ 秒。\n- 使用一个由年周期谐波组成的零均值解析驱动力：\n$$\nF(t) = A \\sin\\left( \\frac{2\\pi t}{T_{\\text{year}}} \\right) + B \\sin\\left( \\frac{4\\pi t}{T_{\\text{year}}} \\right).\n$$\n根据构造， $F(t)$ 在整一年内的积分为零：\n$$\n\\int_0^{T_{\\text{year}}} F(t) \\, dt = 0.\n$$\n\n待实现的数值算法：\n- 使用显式中点法推进系统整整一年，其中完整步长为 $\\Delta t$，并在最后使用一个部分步长 $\\Delta t_{\\text{rem}}$ 以精确达到 $T_{\\text{year}}$（如果 $T_{\\text{year}}$ 不是 $\\Delta t$ 的整数倍）。\n- 在每一步中，计算焓增量 $\\Delta E = F(t_{\\text{mid}}) \\Delta t$，其中 $t_{\\text{mid}}$ 是步长的中点。更新焓值 $E \\leftarrow E + \\Delta E$，然后使用上述耦合规则将 $(E)$ 映射到 $(T,H)$。\n- 一年后，将最终状态 $(T,H)$ 与初始状态 $(T_0,H_0)$ 进行比较，如果 $|T(T_{\\text{year}}) - T_0|$ 和 $|H(T_{\\text{year}}) - H_0|$ 都严格小于其指定的容差，则宣布成功。\n\n测试套件：\n实现程序以运行以下四个测试用例，每个用例由元组 $(T_0, H_0, A, B, \\Delta t, \\text{tol}_T, \\text{tol}_H)$ 指定，单位如上定义：\n1. 案例 $1$（季节性冻融的理想路径）：$(T_0 = -1.0, H_0 = 0.0, A = 200.0, B = 50.0, \\Delta t = 3600.0, \\text{tol}_T = 1.0 \\times 10^{-4}, \\text{tol}_H = 1.0 \\times 10^{-5})$。\n2. 案例 $2$（始终有冰；小振幅）：$(T_0 = -1.8, H_0 = 1.0, A = 20.0, B = 0.0, \\Delta t = 3600.0, \\text{tol}_T = 1.0 \\times 10^{-4}, \\text{tol}_H = 1.0 \\times 10^{-5})$。\n3. 案例 $3$（粗时间步长边界情况）：$(T_0 = -1.0, H_0 = 0.0, A = 200.0, B = 50.0, \\Delta t = 604800.0, \\text{tol}_T = 1.0 \\times 10^{-4}, \\text{tol}_H = 1.0 \\times 10^{-5})$。\n4. 案例 $4$（零驱动力振幅）：$(T_0 = -1.2, H_0 = 0.2, A = 0.0, B = 0.0, \\Delta t = 86400.0, \\text{tol}_T = 1.0 \\times 10^{-4}, \\text{tol}_H = 1.0 \\times 10^{-5})$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目都是一个布尔值，表示相应测试用例的最终状态是否在容差范围内恢复到初始状态（例如 $[r_1,r_2,r_3,r_4]$）。",
            "solution": "该问题已经过验证，被确定为一个定义明确、科学上合理且自成体系的计算物理学练习。它要求对一个简化的一维耦合海洋-海冰模型进行数值积分，并验证一个与周期循环中能量守恒相关的基本性质。\n\n解决方案将首先概述物理原理，然后详细说明数值算法，最后通过实施该算法来测试指定的案例。\n\n**1. 物理和数学框架**\n\n模型的核心是海洋-冰柱的能量守恒，受热力学第一定律支配。柱体的总能量含量（由焓 $E$ 表示）随净地表热通量 $F(t)$ 而变化。这由以下常微分方程（ODE）表示：\n$$\n\\frac{dE}{dt} = F(t)\n$$\n一年内的总焓变（定义周期为 $T_{\\text{year}} = 365 \\times 86400$ 秒）是驱动力的时间积分：\n$$\n\\Delta E_{\\text{total}} = E(T_{\\text{year}}) - E(0) = \\int_0^{T_{\\text{year}}} F(t) \\, dt\n$$\n问题指定了一个由年度和半年度谐波组成的解析驱动函数：\n$$\nF(t) = A \\sin\\left( \\frac{2\\pi t}{T_{\\text{year}}} \\right) + B \\sin\\left( \\frac{4\\pi t}{T_{\\text{year}}} \\right)\n$$\n根据构造，任何频率为 $k \\cdot (2\\pi/T_{\\text{year}})$（其中 $k \\ge 1$ 为整数）的正弦函数在区间 $[0, T_{\\text{year}}]$ 上的积分恰好为零。因此，对于给定的 $F(t)$，我们有：\n$$\n\\int_0^{T_{\\text{year}}} F(t) \\, dt = 0\n$$\n这意味着，在精确的连续系统中，焓值必须在一个完整周期后恢复到其初始值，即 $E(T_{\\text{year}}) = E(0)$。因此，物理状态 $(T(T_{\\text{year}}), H(T_{\\text{year}}))$ 必须与初始状态 $(T_0, H_0)$ 完全相同。问题要求验证当系统进行数值积分时，此性质是否在指定的数值容差内成立。\n\n该模型的关键创新在于其焓公式，它将显热（与温度相关）和潜热（与相变相关）合并为单一的预报变量 $E$。其定义为：\n$$\nE = C_o (T - T_f) - L_i \\rho_i H\n$$\n其中 $T_f = -1.8 \\,^{\\circ}\\text{C}$ 是海水的冰点。项 $C_o (T - T_f)$ 代表海洋混合层相对于水处于冰点状态的显热。项 $L_i \\rho_i H$ 代表融化现有厚度为 $H$ 的冰所需的能量。负号表示这是一种能量“赤字”，必须通过表面加热来克服，海洋才能变暖。常量 $C_o$ 是单位面积的混合层热容，计算公式为 $C_o = \\rho_w c_p h$，其中 $\\rho_w = 1025 \\, \\text{kg m}^{-3}$ 是水的密度，$c_p = 3990 \\, \\text{J kg}^{-1} \\text{K}^{-1}$ 是其比热，$h = 50 \\, \\text{m}$ 是混合层深度。其他常量包括冰的熔化潜热 $L_i = 3.34 \\times 10^5 \\, \\text{J kg}^{-1}$ 和冰的密度 $\\rho_i = 917 \\, \\text{kg m}^{-3}$。\n\n海洋和海冰之间的耦合是通过从预报变量 $E$到物理状态变量 $(T, H)$ 的诊断映射来强制执行的。此映射反映了瞬时相平衡原理：\n- 如果 $E \\ge 0$：所有潜在的冰都已融化。没有冰，因此 $H = 0$。正焓表现为显热，使海洋温度升至冰点以上：$T = T_f + E/C_o$。\n- 如果 $E  0$：系统相对于冰点存在能量赤字。该赤字以潜热的形式物理存储在冰中。海水温度被锁定在冰点 $T = T_f$，而冰的厚度由焓赤字的大小决定：$H = -E / (L_i \\rho_i)$。\n\n**2. 数值算法设计**\n\n任务是对方程 $E$ 的 ODE 进行为期一年的积分。由于右侧的 $F(t)$ 不依赖于 $E$，因此积分是对 $F(t)$ 的直接求积。问题指定了显式中点法。对于一个时间步长 $\\Delta t$，焓的变化为：\n$$\n\\Delta E = F(t_{\\text{mid}}) \\Delta t\n$$\n其中 $t_{\\text{mid}} = t_{\\text{current}} + \\Delta t / 2$。焓的更新方式为 $E_{\\text{new}} = E_{\\text{current}} + \\Delta E$。\n\n积分必须覆盖精确的周期 $T_{\\text{year}}$。如果 $T_{\\text{year}}$ 不是给定时间步长 $\\Delta t$ 的整数倍，则需要一个最后的、更小的时间步长。算法流程如下：\n1.  初始化系统参数：计算 $C_o$ 和 $L_i \\rho_i$。设置 $T_{\\text{year}}$。\n2.  对于每个具有参数 $(T_0, H_0, A, B, \\Delta t, \\text{tol}_T, \\text{tol}_H)$ 的测试用例：\n    a.  使用公式 $E_0 = C_o (T_0 - T_f) - L_i \\rho_i H_0$ 从初始状态 $(T_0, H_0)$ 计算初始焓 $E_0$。\n    b.  初始化当前状态：$E = E_0$ 和 $t = 0$。\n    c.  确定完整时间步的数量：$N_{\\text{full}} = \\text{int}(T_{\\text{year}} / \\Delta t)$。\n    d.  迭代 $N_{\\text{full}}$ 次以执行完整步骤：\n        i.  计算中点时间：$t_{\\text{mid}} = t + \\Delta t/2$。\n        ii. 计算中点通量：$F_{\\text{mid}} = A \\sin(2\\pi t_{\\text{mid}}/T_{\\text{year}}) + B \\sin(4\\pi t_{\\text{mid}}/T_{\\text{year}})$。\n        iii.更新焓值：$E \\leftarrow E + F_{\\text{mid}} \\cdot \\Delta t$。\n        iv. 更新时间：$t \\leftarrow t + \\Delta t$。\n    e.  计算最终部分步长的剩余时间：$\\Delta t_{\\text{rem}} = T_{\\text{year}} - t$。\n    f.  如果 $\\Delta t_{\\text{rem}}$ 不可忽略（例如，大于一个小的浮点数 epsilon）：\n        i.  计算最终中点：$t_{\\text{mid}} = t + \\Delta t_{\\text{rem}}/2$。\n        ii. 计算通量：$F_{\\text{mid}} = A \\sin(2\\pi t_{\\text{mid}}/T_{\\text{year}}) + B \\sin(4\\pi t_{\\text{mid}}/T_{\\text{year}})$。\n        iii.执行最终更新：$E \\leftarrow E + F_{\\text{mid}} \\cdot \\Delta t_{\\text{rem}}$。\n    g.  最终焓值为 $E(T_{\\text{year}})$。使用诊断映射将其转换回最终物理状态 $(T_{\\text{final}}, H_{\\text{final}})$。\n    h.  通过将最终状态与初始状态对照给定的容差进行比较来检查是否成功：\n        $$\n        |\\, T_{\\text{final}} - T_0 \\,|  \\text{tol}_T \\quad \\text{and} \\quad |\\, H_{\\text{final}} - H_0 \\,|  \\text{tol}_H\n        $$\n    i.  记录此检查的布尔结果。\n3.  处理完所有测试用例后，按指定格式打印收集到的结果。\n\n这种结构化方法确保了数值模拟正确地实现了物理模型和验证标准。使用中点法（一种二阶精度方法）应能为给定的容差提供足够的精度，尽管案例 3 的时间步长极大，将考验此精度的极限。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the coupled ocean-sea ice model problem for a suite of test cases.\n    \"\"\"\n    # Define physical constants\n    rho_w = 1025.0  # Water density (kg m^-3)\n    c_p = 3990.0    # Specific heat of water (J kg^-1 K^-1)\n    h = 50.0        # Mixed layer depth (m)\n    L_i = 3.34e5    # Latent heat of fusion of ice (J kg^-1)\n    rho_i = 917.0     # Ice density (kg m^-3)\n    T_f = -1.8      # Seawater freezing point (°C)\n    T_year = 365.0 * 86400.0  # Duration of one year (s)\n\n    # Derived constants\n    C_o = rho_w * c_p * h  # Ocean mixed-layer heat capacity (J m^-2 K^-1)\n    L_rho_i = L_i * rho_i  # Latent heat per unit volume of ice (J m^-3)\n\n    # Test suite\n    test_cases = [\n        # (T0, H0, A, B, dt, tol_T, tol_H)\n        (-1.0, 0.0, 200.0, 50.0, 3600.0, 1.0e-4, 1.0e-5),\n        (-1.8, 1.0, 20.0, 0.0, 3600.0, 1.0e-4, 1.0e-5),\n        (-1.0, 0.0, 200.0, 50.0, 604800.0, 1.0e-4, 1.0e-5),\n        (-1.2, 0.2, 0.0, 0.0, 86400.0, 1.0e-4, 1.0e-5),\n    ]\n\n    results = []\n\n    # Helper functions\n    def forcing_flux(t, A, B):\n        \"\"\"Calculates the analytic surface heat flux F(t).\"\"\"\n        omega1 = 2.0 * np.pi / T_year\n        omega2 = 4.0 * np.pi / T_year\n        return A * np.sin(omega1 * t) + B * np.sin(omega2 * t)\n\n    def state_to_enthalpy(T, H):\n        \"\"\"Converts physical state (T, H) to enthalpy E.\"\"\"\n        return C_o * (T - T_f) - L_rho_i * H\n\n    def enthalpy_to_state(E):\n        \"\"\"Converts enthalpy E to physical state (T, H).\"\"\"\n        if E >= 0:\n            H = 0.0\n            T = T_f + E / C_o\n        else:\n            T = T_f\n            H = -E / L_rho_i\n        return T, H\n\n    for case in test_cases:\n        T0, H0, A, B, dt, tol_T, tol_H = case\n\n        # 1. Calculate initial enthalpy\n        E_current = state_to_enthalpy(T0, H0)\n        t_current = 0.0\n\n        # 2. Determine number of full and one partial time step\n        num_full_steps = int(T_year / dt)\n        dt_rem = T_year - num_full_steps * dt\n\n        # 3. Time stepping with explicit midpoint rule (full steps)\n        for _ in range(num_full_steps):\n            t_mid = t_current + dt / 2.0\n            F_mid = forcing_flux(t_mid, A, B)\n            E_current += F_mid * dt\n            t_current += dt\n\n        # 4. Final partial step to reach T_year exactly\n        if dt_rem > 1e-9:  # Check for non-negligible remainder\n            t_mid = t_current + dt_rem / 2.0\n            F_mid = forcing_flux(t_mid, A, B)\n            E_current += F_mid * dt_rem\n\n        # 5. Calculate final state from final enthalpy\n        T_final, H_final = enthalpy_to_state(E_current)\n\n        # 6. Verify if the final state is within tolerance of the initial state\n        is_success = (abs(T_final - T0)  tol_T) and (abs(H_final - H0)  tol_H)\n        results.append(str(is_success).lower())\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}