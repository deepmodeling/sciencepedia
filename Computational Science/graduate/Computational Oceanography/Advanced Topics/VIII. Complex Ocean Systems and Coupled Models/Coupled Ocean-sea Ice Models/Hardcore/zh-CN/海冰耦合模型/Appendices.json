{
    "hands_on_practices": [
        {
            "introduction": "理解太阳辐射如何与海冰相互作用是任何气候模型的基础。被吸收、反射或透射的能量决定了融化和冻结的速率。本实践将指导您基于比尔-朗伯定律（Beer-Lambert Law）实现一个标准的双流辐射模型，这是海冰热力学模型的基石。通过对入射辐射进行划分，您将为模拟海冰能量收支构建一个关键组件 。",
            "id": "3789166",
            "problem": "你的任务是计算入射到海洋上一个水平均质海冰板的短波辐射 (SWR) 如何划分为三类：表面反射、冰内吸收和向海洋的透射。海冰采用双波段光谱模型（指两个光谱流的“双流”）进行处理，每个波段具有不同的消光系数。你的程序必须为指定的测试套件实现此划分，并生成所需的输出。\n\n物理设定如下。一个向下的 SWR 通量 $F_0$ (单位为 $\\mathrm{W\\,m^{-2}}$) 入射到空气-冰界面。由于空气-冰界面的光学特性（例如 Fresnel 反射和直接的近表面效应），$F_0$ 的一部分（比例为 $R_s$，无量纲）在表面被反射。剩余的部分 $(1 - R_s)$ 进入冰中。在冰内部，SWR 被表示为两个光谱流，其比例分别为 $f_1$ 和 $f_2 = 1 - f_1$，每个光谱流在厚度为 $H$（单位为 $\\mathrm{m}$）的冰板中以消光系数 $k_1$ 和 $k_2$（单位为 $\\mathrm{m^{-1}}$）呈指数衰减。所有到达冰-海界面的辐射都被假定透射到海洋中，并在那里被吸收，不再发生反射。\n\n你的推导必须从适用于计算海洋学和海洋-海冰耦合模型的、有物理基础的原理出发，具体包括：\n- 辐射通量的能量守恒。\n- 用于描述均匀吸收介质中衰减的 Beer-Lambert 定律 (BLL)。\n\n基于这些原理，为每个测试用例计算：\n- 表面反射 $F_{\\text{surf}}$ (单位为 $\\mathrm{W\\,m^{-2}}$)。\n- 冰内吸收 $F_{\\text{abs}}$ (单位为 $\\mathrm{W\\,m^{-2}}$)。\n- 向海洋的透射 $F_{\\text{trans}}$ (单位为 $\\mathrm{W\\,m^{-2}}$)。\n\n你的程序必须处理以下包含参数集 $(F_0, H, R_s, f_1, k_1, k_2)$ 的测试套件：\n1. 正常情况：$(F_0 = 300\\,\\mathrm{W\\,m^{-2}}, H = 1.2\\,\\mathrm{m}, R_s = 0.06, f_1 = 0.55, k_1 = 1.2\\,\\mathrm{m^{-1}}, k_2 = 4.0\\,\\mathrm{m^{-1}})$。\n2. 边界情况 (零厚度)：$(F_0 = 300\\,\\mathrm{W\\,m^{-2}}, H = 0.0\\,\\mathrm{m}, R_s = 0.06, f_1 = 0.55, k_1 = 1.2\\,\\mathrm{m^{-1}}, k_2 = 4.0\\,\\mathrm{m^{-1}})$。\n3. 边缘情况 (极厚冰层)：$(F_0 = 300\\,\\mathrm{W\\,m^{-2}}, H = 5.0\\,\\mathrm{m}, R_s = 0.06, f_1 = 0.55, k_1 = 1.2\\,\\mathrm{m^{-1}}, k_2 = 4.0\\,\\mathrm{m^{-1}})$。\n4. 边缘情况 (一个无衰减流)：$(F_0 = 300\\,\\mathrm{W\\,m^{-2}}, H = 1.2\\,\\mathrm{m}, R_s = 0.06, f_1 = 0.30, k_1 = 0.0\\,\\mathrm{m^{-1}}, k_2 = 10.0\\,\\mathrm{m^{-1}})$。\n5. 边缘情况 (高表面反射率)：$(F_0 = 300\\,\\mathrm{W\\,m^{-2}}, H = 1.2\\,\\mathrm{m}, R_s = 0.50, f_1 = 0.55, k_1 = 1.2\\,\\mathrm{m^{-1}}, k_2 = 4.0\\,\\mathrm{m^{-1}})$。\n\n所有输出都必须以 $\\mathrm{W\\,m^{-2}}$ 为单位，表示为小数点后恰好有六位数字的小数浮点数。你的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的列表，列表中的每个元素是一个代表测试用例结果的三元组，并用方括号括起来。每个三元组本身也是一个用方括号括起来的逗号分隔列表，顺序为 $[F_{\\text{surf}}, F_{\\text{abs}}, F_{\\text{trans}}]$。例如：$[[x_1,y_1,z_1],[x_2,y_2,z_2],\\dots]$。\n\n不要读取任何输入。直接在你的程序中使用上面提供的参数。确保计算遵循指定的原理，并确保能量守恒，即 $F_{\\text{surf}} + F_{\\text{abs}} + F_{\\text{trans}}$ 在数值误差范围内等于 $F_0$。",
            "solution": "该问题已经过验证，被认为是合理的。它有科学依据、是适定的、客观的，并包含获得唯一且有意义解所需的所有必要信息。该物理模型尽管经过简化，却是计算海洋学和海冰模拟中使用的标准表示方法。\n\n任务是计算入射短波辐射 (SWR) 如何划分为三个分量：表面反射 ($F_{\\text{surf}}$)、冰内吸收 ($F_{\\text{abs}}$) 和向海洋的透射 ($F_{\\text{trans}}$)。推导将基于能量守恒原理和用于辐射衰减的 Beer-Lambert 定律。\n\n设 $F_0$ 为入射到空气-冰界面的向下 SWR 通量。\n\n第一步：表面反射\n问题陈述，入射通量的一部分（比例为 $R_s$）在表面被反射。因此，总反射通量 $F_{\\text{surf}}$ 为：\n$$\nF_{\\text{surf}} = R_s \\cdot F_0\n$$\n这部分辐射不会进入冰板。\n\n第二步：进入冰的通量\n根据空气-冰界面的能量守恒，未被反射的通量必须穿透冰面。设此通量为 $F_{\\text{in}}$。\n$$\nF_{\\text{in}} = F_0 - F_{\\text{surf}} = F_0 - R_s F_0 = (1 - R_s) F_0\n$$\n\n第三步：双波段光谱衰减\n问题指定了一个双波段光谱模型。进入冰的通量 $F_{\\text{in}}$ 被划分为两个光谱流。\n- 在表面（$z=0$）处，第一个流中的通量为 $F_{1, \\text{in}} = f_1 \\cdot F_{\\text{in}}$。\n- 在表面（$z=0$）处，第二个流中的通量为 $F_{2, \\text{in}} = f_2 \\cdot F_{\\text{in}} = (1 - f_1) F_{\\text{in}}$。\n\n每个流在穿过厚度为 $H$ 的冰层时都会衰减。Beer-Lambert 定律描述了这种指数衰减。对于一个消光系数为 $k$ 的流，在深度 $z$ 处的通量 $F(z)$ 由 $F(z) = F(0) e^{-kz}$ 给出，其中 $F(0)$ 是表面的通量。\n\n到达深度 $z=H$ 处冰-海界面的每个流的通量为：\n- 对于第一个流：$F_{1, \\text{trans}}(H) = F_{1, \\text{in}} \\cdot e^{-k_1 H} = f_1 (1 - R_s) F_0 e^{-k_1 H}$。\n- 对于第二个流：$F_{2, \\text{trans}}(H) = F_{2, \\text{in}} \\cdot e^{-k_2 H} = (1 - f_1) (1 - R_s) F_0 e^{-k_2 H}$。\n\n第四步：向海洋的透射\n如前所述，所有到达冰-海界面的辐射都透射到海洋中，不再发生反射。因此，总透射通量 $F_{\\text{trans}}$ 是两个光谱流的透射通量之和。\n$$\nF_{\\text{trans}} = F_{1, \\text{trans}}(H) + F_{2, \\text{trans}}(H)\n$$\n代入第三步中的表达式：\n$$\nF_{\\text{trans}} = f_1 (1 - R_s) F_0 e^{-k_1 H} + (1 - f_1) (1 - R_s) F_0 e^{-k_2 H}\n$$\n提取公因式，我们得到透射通量的最终表达式：\n$$\nF_{\\text{trans}} = (1 - R_s) F_0 \\left[ f_1 e^{-k_1 H} + (1 - f_1) e^{-k_2 H} \\right]\n$$\n\n第五步：冰内吸收\n总入射通量必须守恒。它要么被反射、吸收，要么被透射。\n$$\nF_0 = F_{\\text{surf}} + F_{\\text{abs}} + F_{\\text{trans}}\n$$\n我们可以通过整理这个守恒方程来求解吸收通量 $F_{\\text{abs}}$：\n$$\nF_{\\text{abs}} = F_0 - F_{\\text{surf}} - F_{\\text{trans}}\n$$\n这种方法根据定义确保了能量收支是闭合的。\n\n或者，我们可以直接计算吸收通量，其值为进入冰的能量与穿透冰的能量之差：\n$$\nF_{\\text{abs}} = F_{\\text{in}} - F_{\\text{trans}}\n$$\n代入 $F_{\\text{in}}$ 和 $F_{\\text{trans}}$ 的表达式：\n$$\nF_{\\text{abs}} = (1 - R_s) F_0 - (1 - R_s) F_0 \\left[ f_1 e^{-k_1 H} + (1 - f_1) e^{-k_2 H} \\right]\n$$\n$$\nF_{\\text{abs}} = (1 - R_s) F_0 \\left( 1 - \\left[ f_1 e^{-k_1 H} + (1 - f_1) e^{-k_2 H} \\right] \\right)\n$$\n两种计算 $F_{\\text{abs}}$ 的方法是等效的，在假设浮点运算精度足够的情况下，将得出相同的数值结果。数值实现将使用能量守恒原理以确保其稳健性。\n\n计算公式总结：\n1.  $F_{\\text{surf}} = R_s F_0$\n2.  $F_{\\text{trans}} = (1 - R_s) F_0 \\left[ f_1 e^{-k_1 H} + (1 - f_1) e^{-k_2 H} \\right]$\n3.  $F_{\\text{abs}} = F_0 - F_{\\text{surf}} - F_{\\text{trans}}$\n\n这三个公式将被应用于每个提供的测试用例，以计算所需的通量划分。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the partitioning of incident Shortwave Radiation (SWR) for sea ice\n    into surface reflection, absorption within the ice, and transmission to the ocean.\n    The model is based on energy conservation and the Beer-Lambert Law for a\n    two-band spectral representation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (F0, H, Rs, f1, k1, k2)\n    # F0: Incident SWR flux (W/m^2)\n    # H: Ice thickness (m)\n    # Rs: Surface reflectance (dimensionless)\n    # f1: Fraction of penetrating SWR in the first spectral band (dimensionless)\n    # k1: Extinction coefficient for the first band (1/m)\n    # k2: Extinction coefficient for the second band (1/m)\n    test_cases = [\n        # 1. Happy path\n        (300.0, 1.2, 0.06, 0.55, 1.2, 4.0),\n        # 2. Boundary case (zero thickness)\n        (300.0, 0.0, 0.06, 0.55, 1.2, 4.0),\n        # 3. Edge case (very thick ice)\n        (300.0, 5.0, 0.06, 0.55, 1.2, 4.0),\n        # 4. Edge case (one non-attenuating stream)\n        (300.0, 1.2, 0.06, 0.30, 0.0, 10.0),\n        # 5. Edge case (high surface reflectance)\n        (300.0, 1.2, 0.50, 0.55, 1.2, 4.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        F0, H, Rs, f1, k1, k2 = case\n        f2 = 1.0 - f1\n\n        # 1. Compute surface reflection (F_surf)\n        # Fraction Rs of the incident flux F0 is reflected at the surface.\n        F_surf = Rs * F0\n\n        # 2. Compute transmission to the ocean (F_trans)\n        # The remaining flux (1 - Rs)*F0 enters the ice and is partitioned into\n        # two streams, f1 and f2, which are attenuated exponentially according\n        # to the Beer-Lambert Law.\n        F_in = (1.0 - Rs) * F0\n        \n        # Calculate transmitted flux for each stream and sum them.\n        # F_trans_1 = F_in * f1 * exp(-k1 * H)\n        # F_trans_2 = F_in * f2 * exp(-k2 * H)\n        # F_trans = F_trans_1 + F_trans_2\n        F_trans = F_in * (f1 * np.exp(-k1 * H) + f2 * np.exp(-k2 * H))\n\n        # 3. Compute absorption within the ice (F_abs)\n        # By energy conservation, the total flux must be accounted for.\n        # F0 = F_surf + F_abs + F_trans\n        F_abs = F0 - F_surf - F_trans\n\n        # Store the triplet [F_surf, F_abs, F_trans]\n        # In the edge case of H=0, F_abs can be a very small negative number\n        # due to floating point inaccuracies, so we clip it at 0.\n        if abs(F_abs)  1e-12:\n            F_abs = 0.0\n\n        results.append([F_surf, F_abs, F_trans])\n\n    # Format the final output string as specified.\n    # [[x1,y1,z1],[x2,y2,z2],...]\n    # Each number must have exactly six digits after the decimal point.\n    formatted_results = []\n    for res_triplet in results:\n        formatted_triplet = [f\"{val:.6f}\" for val in res_triplet]\n        formatted_results.append(f\"[{','.join(formatted_triplet)}]\")\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "一个稳健的耦合模型必须在长时间积分中守恒能量等基本量。在一个净能量输入为零的完整强迫循环下测试模型的行为，是诊断虚假漂移和验证守恒性的有效方法。本练习介绍了用于模拟相变的焓方法 ($E$)，并要求您验证一个简化的海洋-冰柱模型的循环稳定性，确保其状态变量，如温度 $T$ 和冰厚 $H$，在循环结束后能恢复到初始值。成功完成此练习，表明您已掌握了耦合相变系统中的能量守恒原理 。",
            "id": "3789204",
            "problem": "考虑一个一维垂直柱状模型，该模型通过能量守恒和海水冰点处的瞬时相平衡，将一个混合均匀的海洋层和一个海冰层耦合起来。该柱状体由一个 prescribed 的解析地表热通量驱动，该通量以一年为周期。目标是设计一个强迫，使得年净能量输入为零，并通过数值时间步进验证，耦合的海洋-海冰状态在整整一年后，在指定的数值容差内返回到其初始条件。\n\n假设与定义：\n- 设混合层海水温度为 $T$（单位：摄氏度），海冰厚度为 $H$（单位：米）。海水冰点为 $T_f = -1.8$ 摄氏度。\n- 定义相对于处于冰点的海水的柱状体焓为\n$$\nE = C_o \\left(T - T_f\\right) - L_i \\rho_i H,\n$$\n其中 $C_o$ 是单位面积的海洋混合层热容，$L_i$ 是冰的熔化潜热，$\\rho_i$ 是冰的密度。各常量为\n$$\n\\rho_w = 1025 \\ \\text{kg m}^{-3}, \\quad c_p = 3990 \\ \\text{J kg}^{-1} \\text{K}^{-1}, \\quad h = 50 \\ \\text{m},\n$$\n$$\nC_o = \\rho_w c_p h \\ \\text{J m}^{-2} \\text{K}^{-1}, \\quad L_i = 3.34 \\times 10^5 \\ \\text{J kg}^{-1}, \\quad \\rho_i = 917 \\ \\text{kg m}^{-3}.\n$$\n所有通量的单位为瓦特每平方米（$\\text{W m}^{-2}$），所有时间的单位为秒，温度单位为摄氏度，厚度单位为米。\n\n控制定律与耦合：\n- 根据应用于该柱状体的热力学第一定律，焓 $E$ 的演化遵循\n$$\n\\frac{dE}{dt} = F(t),\n$$\n其中 $F(t)$ 是外部给定的进入柱状体的净地表热通量（向下为正）。海洋-海冰耦合通过在每个时间步将焓映射回状态 $(T,H)$ 来实现，并遵循瞬时相平衡的约束条件：\n  - 若 $E \\ge 0$，则 $H = 0$ 且 $T = T_f + E/C_o$。\n  - 若 $E  0$，则 $T = T_f$ 且 $H = -E/(L_i \\rho_i)$。\n该映射编码了冻结与融化过程：负焓对应于以海冰厚度形式储存的潜热，正焓则对应于海洋中高于冰点的显热。\n\n解析强迫周期：\n- 设 $T_{\\text{year}} = 365 \\times 86400$ 秒。\n- 使用一个由年周期谐波组成的零均值解析强迫：\n$$\nF(t) = A \\sin\\left( \\frac{2\\pi t}{T_{\\text{year}}} \\right) + B \\sin\\left( \\frac{4\\pi t}{T_{\\text{year}}} \\right).\n$$\n根据构造， $F(t)$ 在整整一年内的积分为零：\n$$\n\\int_0^{T_{\\text{year}}} F(t) \\, dt = 0.\n$$\n\n待实现的数值算法：\n- 使用显式中点格式，以均匀步长 $\\Delta t$ 对系统进行整整一年的推进。如果 $T_{\\text{year}}$ 不是 $\\Delta t$ 的整数倍，则使用一个最终的部分步长 $\\Delta t_{\\text{rem}}$ 来精确达到 $T_{\\text{year}}$。\n- 在每一步中，计算焓增量 $\\Delta E = F(t_{\\text{mid}}) \\Delta t$，其中 $t_{\\text{mid}}$ 是步长中点。更新焓 $E \\leftarrow E + \\Delta E$，然后使用上述耦合规则将 $(E)$ 映射到 $(T,H)$。\n- 一年后，将最终的 $(T,H)$ 与初始的 $(T_0,H_0)$ 进行比较，如果 $|T(T_{\\text{year}}) - T_0|$ 和 $|H(T_{\\text{year}}) - H_0|$ 都严格小于其指定的容差，则宣布成功。\n\n测试集：\n实现程序以运行以下四个测试用例，每个用例由元组 $(T_0, H_0, A, B, \\Delta t, \\text{tol}_T, \\text{tol}_H)$ 指定，单位如上文定义：\n1. 案例1（季节性冻融的正常路径）：$(T_0 = -1.0, H_0 = 0.0, A = 200.0, B = 50.0, \\Delta t = 3600.0, \\text{tol}_T = 1.0 \\times 10^{-4}, \\text{tol}_H = 1.0 \\times 10^{-5})$。\n2. 案例2（始终有冰；小振幅）：$(T_0 = -1.8, H_0 = 1.0, A = 20.0, B = 0.0, \\Delta t = 3600.0, \\text{tol}_T = 1.0 \\times 10^{-4}, \\text{tol}_H = 1.0 \\times 10^{-5})$。\n3. 案例3（粗时间步长边缘情况）：$(T_0 = -1.0, H_0 = 0.0, A = 200.0, B = 50.0, \\Delta t = 604800.0, \\text{tol}_T = 1.0 \\times 10^{-4}, \\text{tol}_H = 1.0 \\times 10^{-5})$。\n4. 案例4（零强迫振幅）：$(T_0 = -1.2, H_0 = 0.2, A = 0.0, B = 0.0, \\Delta t = 86400.0, \\text{tol}_T = 1.0 \\times 10^{-4}, \\text{tol}_H = 1.0 \\times 10^{-5})$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目都是一个布尔值，表示相应测试用例的最终状态是否在容差范围内返回到初始状态（例如，$[r_1,r_2,r_3,r_4]$）。",
            "solution": "该问题已经过验证，被确定为计算物理学中一个适定、科学合理且自洽的练习。它要求对一个简化的一维耦合海洋-海冰模型进行数值积分，并验证一个与周期循环中的能量守恒相关的基本性质。\n\n解决方案将通过首先概述物理原理，然后详细说明数值算法，最后实现它以测试指定的用例来制定。\n\n**1. 物理与数学框架**\n\n模型的核心是海洋-冰柱的能量守恒，由热力学第一定律控制。柱状体的总能量含量（由焓 $E$ 表示）随净地表热通量 $F(t)$ 的变化而改变。这由常微分方程（ODE）表示：\n$$\n\\frac{dE}{dt} = F(t)\n$$\n一年内的总焓变（定义周期为 $T_{\\text{year}} = 365 \\times 86400$ 秒），是强迫的时间积分：\n$$\n\\Delta E_{\\text{total}} = E(T_{\\text{year}}) - E(0) = \\int_0^{T_{\\text{year}}} F(t) \\, dt\n$$\n问题指定了一个由年周期和半年周期谐波组成的解析强迫函数：\n$$\nF(t) = A \\sin\\left( \\frac{2\\pi t}{T_{\\text{year}}} \\right) + B \\sin\\left( \\frac{4\\pi t}{T_{\\text{year}}} \\right)\n$$\n根据构造，任何频率为 $k \\cdot (2\\pi/T_{\\text{year}})$（其中 $k$ 为整数且 $k \\ge 1$）的正弦函数在区间 $[0, T_{\\text{year}}]$ 上的积分恰好为零。因此，对于给定的 $F(t)$，我们有：\n$$\n\\int_0^{T_{\\text{year}}} F(t) \\, dt = 0\n$$\n这意味着，在精确的连续系统中，焓在一个完整周期后必须返回其初始值，即 $E(T_{\\text{year}}) = E(0)$。因此，物理状态 $(T(T_{\\text{year}}), H(T_{\\text{year}}))$ 必须与初始状态 $(T_0, H_0)$ 完全相同。问题要求验证当系统进行数值积分时，此性质是否在指定的数值容差内成立。\n\n该模型的关键创新在于焓公式，它将显热（与温度相关）和潜热（与相变相关）组合成单一的预报变量 $E$。其定义为：\n$$\nE = C_o (T - T_f) - L_i \\rho_i H\n$$\n其中 $T_f = -1.8^{\\circ}\\mathrm{C}$ 是海水冰点。$C_o (T - T_f)$ 项代表海洋混合层相对于海水处于冰点状态的显热。$L_i \\rho_i H$ 项代表融化现有厚度为 $H$ 的冰所需的能量。负号表示这是一种能量“亏损”，必须通过地表加热来弥补，海洋才能升温。常数 $C_o$ 是单位面积混合层的热容，计算公式为 $C_o = \\rho_w c_p h$，其中 $\\rho_w = 1025 \\, \\text{kg m}^{-3}$ 是水密度，$c_p = 3990 \\, \\text{J kg}^{-1} \\text{K}^{-1}$ 是其比热容，$h = 50 \\, \\text{m}$ 是混合层深度。其他常数是冰的熔化潜热 $L_i = 3.34 \\times 10^5 \\, \\text{J kg}^{-1}$ 和冰密度 $\\rho_i = 917 \\, \\text{kg m}^{-3}$。\n\n海洋与海冰之间的耦合通过一个从预报变量 $E$ 到物理状态变量 $(T, H)$ 的诊断映射来强制执行。该映射反映了瞬时相平衡原理：\n- 若 $E \\ge 0$：所有潜在的冰都已融化。此时没有冰，所以 $H = 0$。正焓表现为显热，使海洋温度升至冰点以上：$T = T_f + E/C_o$。\n- 若 $E  0$：系统相对于冰点存在能量亏损。这种亏损以潜热的形式物理储存在冰中。海水温度被锁定在冰点 $T = T_f$，冰的厚度由焓亏损的大小决定：$H = -E / (L_i \\rho_i)$。\n\n**2. 数值算法设计**\n\n任务是积分关于 $E$ 的常微分方程，时间跨度为一年。由于右侧项 $F(t)$ 不依赖于 $E$，因此积分是 $F(t)$ 的直接求积。问题指定了显式中点格式。对于一个时间步长 $\\Delta t$，焓的变化为：\n$$\n\\Delta E = F(t_{\\text{mid}}) \\Delta t\n$$\n其中 $t_{\\text{mid}} = t_{\\text{current}} + \\Delta t / 2$。焓更新为 $E_{\\text{new}} = E_{\\text{current}} + \\Delta E$。\n\n积分必须覆盖精确的周期 $T_{\\text{year}}$。如果 $T_{\\text{year}}$ 不是给定时间步长 $\\Delta t$ 的整数倍，则需要一个最终的、更小的时间步长。算法流程如下：\n1.  初始化系统参数：计算 $C_o$ 和 $L_i \\rho_i$。设置 $T_{\\text{year}}$。\n2.  对于每个具有参数 $(T_0, H_0, A, B, \\Delta t, \\text{tol}_T, \\text{tol}_H)$ 的测试用例：\n    a.  根据初始状态 $(T_0, H_0)$ 计算初始焓 $E_0$：$E_0 = C_o (T_0 - T_f) - L_i \\rho_i H_0$。\n    b.  初始化当前状态：$E = E_0$ 和 $t = 0$。\n    c.  确定完整时间步的数量：$N_{\\text{full}} = \\text{int}(T_{\\text{year}} / \\Delta t)$。\n    d.  迭代 $N_{\\text{full}}$ 次以执行完整步长：\n        i.   计算中点时间：$t_{\\text{mid}} = t + \\Delta t/2$。\n        ii.  计算中点通量：$F_{\\text{mid}} = A \\sin(2\\pi t_{\\text{mid}}/T_{\\text{year}}) + B \\sin(4\\pi t_{\\text{mid}}/T_{\\text{year}})$。\n        iii. 更新焓：$E \\leftarrow E + F_{\\text{mid}} \\cdot \\Delta t$。\n        iv.  更新时间：$t \\leftarrow t + \\Delta t$。\n    e.  计算最后部分步长的剩余时间：$\\Delta t_{\\text{rem}} = T_{\\text{year}} - t$。\n    f.  如果 $\\Delta t_{\\text{rem}}$ 不可忽略（例如，大于一个小的浮点数 epsilon）：\n        i.   计算最后的中点：$t_{\\text{mid}} = t + \\Delta t_{\\text{rem}}/2$。\n        ii.  计算通量：$F_{\\text{mid}} = A \\sin(2\\pi t_{\\text{mid}}/T_{\\text{year}}) + B \\sin(4\\pi t_{\\text{mid}}/T_{\\text{year}})$。\n        iii. 执行最终更新：$E \\leftarrow E + F_{\\text{mid}} \\cdot \\Delta t_{\\text{rem}}$。\n    g.  此时得到最终焓 $E(T_{\\text{year}})$。使用诊断映射将其转换回最终的物理状态 $(T_{\\text{final}}, H_{\\text{final}})$。\n    h.  通过将最终状态与初始状态对照给定容差进行比较，检查是否成功：\n        $$\n        |\\, T_{\\text{final}} - T_0 \\,|  \\text{tol}_T \\quad \\text{and} \\quad |\\, H_{\\text{final}} - H_0 \\,|  \\text{tol}_H\n        $$\n    i.  记录此检查的布尔结果。\n3.  处理完所有测试用例后，按指定格式打印收集到的结果。\n\n这种结构化方法确保了数值模拟正确地实现了物理模型和验证标准。使用中点格式（一种二阶精度方法）应能为给定的容差提供足够的精度，尽管案例3的极大时间步长将测试此精度的极限。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the coupled ocean-sea ice model problem for a suite of test cases.\n    \"\"\"\n    # Define physical constants\n    rho_w = 1025.0  # Water density (kg m^-3)\n    c_p = 3990.0    # Specific heat of water (J kg^-1 K^-1)\n    h = 50.0        # Mixed layer depth (m)\n    L_i = 3.34e5    # Latent heat of fusion of ice (J kg^-1)\n    rho_i = 917.0     # Ice density (kg m^-3)\n    T_f = -1.8      # Seawater freezing point (°C)\n    T_year = 365.0 * 86400.0  # Duration of one year (s)\n\n    # Derived constants\n    C_o = rho_w * c_p * h  # Ocean mixed-layer heat capacity (J m^-2 K^-1)\n    L_rho_i = L_i * rho_i  # Latent heat per unit volume of ice (J m^-3)\n\n    # Test suite\n    test_cases = [\n        # (T0, H0, A, B, dt, tol_T, tol_H)\n        (-1.0, 0.0, 200.0, 50.0, 3600.0, 1.0e-4, 1.0e-5),\n        (-1.8, 1.0, 20.0, 0.0, 3600.0, 1.0e-4, 1.0e-5),\n        (-1.0, 0.0, 200.0, 50.0, 604800.0, 1.0e-4, 1.0e-5),\n        (-1.2, 0.2, 0.0, 0.0, 86400.0, 1.0e-4, 1.0e-5),\n    ]\n\n    results = []\n\n    # Helper functions\n    def forcing_flux(t, A, B):\n        \"\"\"Calculates the analytic surface heat flux F(t).\"\"\"\n        omega1 = 2.0 * np.pi / T_year\n        omega2 = 4.0 * np.pi / T_year\n        return A * np.sin(omega1 * t) + B * np.sin(omega2 * t)\n\n    def state_to_enthalpy(T, H):\n        \"\"\"Converts physical state (T, H) to enthalpy E.\"\"\"\n        return C_o * (T - T_f) - L_rho_i * H\n\n    def enthalpy_to_state(E):\n        \"\"\"Converts enthalpy E to physical state (T, H).\"\"\"\n        if E >= 0:\n            H = 0.0\n            T = T_f + E / C_o\n        else:\n            T = T_f\n            H = -E / L_rho_i\n        return T, H\n\n    for case in test_cases:\n        T0, H0, A, B, dt, tol_T, tol_H = case\n\n        # 1. Calculate initial enthalpy\n        E_current = state_to_enthalpy(T0, H0)\n        t_current = 0.0\n\n        # 2. Determine number of full and one partial time step\n        num_full_steps = int(T_year / dt)\n        dt_rem = T_year - num_full_steps * dt\n\n        # 3. Time stepping with explicit midpoint rule (full steps)\n        for _ in range(num_full_steps):\n            t_mid = t_current + dt / 2.0\n            F_mid = forcing_flux(t_mid, A, B)\n            E_current += F_mid * dt\n            t_current += dt\n\n        # 4. Final partial step to reach T_year exactly\n        if dt_rem > 1e-9:  # Check for non-negligible remainder\n            t_mid = t_current + dt_rem / 2.0\n            F_mid = forcing_flux(t_mid, A, B)\n            E_current += F_mid * dt_rem\n\n        # 5. Calculate final state from final enthalpy\n        T_final, H_final = enthalpy_to_state(E_current)\n\n        # 6. Verify if the final state is within tolerance of the initial state\n        is_success = (abs(T_final - T0)  tol_T) and (abs(H_final - H0)  tol_H)\n        results.append(str(is_success).lower())\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实世界的海冰是一个复杂的系统，涉及大气、雪层、冰本身以及海洋混合层之间的相互作用。建立一个包含雪深 $h_s$、冰厚 $h_i$、混合层温度 $T_{ml}$ 和盐度 $S_{ml}$ 的模型，需要仔细地组合和集成每个过程的参数化方案。在这个综合实践中，您将从第一性原理出发，构建一个更全面的一维模型。您的主要任务是推导并实现一个能量守恒的更新方案，这是开发可靠气候模型组件的一项关键技能 ()。",
            "id": "3789211",
            "problem": "要求您构建一个雪-海冰-海洋耦合系统的一维垂直柱状模型，并实现一个遵循能量守恒的显式时间步长更新。该柱状模型由一个深度为 $h_s$ 的雪层、其下覆盖的厚度为 $h_i$ 的海冰层，以及再下方的深度为 $H_{ml}$ 的海洋混合层组成。海洋混合层的特征是其温度 $T_{ml}$ 和实用盐度 $S_{ml}$。该模型由一个给定的表面热通量 $Q_s$（定义为向下进入柱体为正）、一个给定的深海热通量 $Q_b$（定义为向上进入混合层为正）和一个降雪率 $P$（降雪，定义为向下为正）驱动。所有通量和状态变化的处理都必须确保离散时间步长更新在柱体中是能量守恒的。\n\n您必须从第一性原理出发，推导并实现预报变量 $h_i$、$h_s$、$T_{ml}$ 和 $S_{ml}$ 在长度为 $\\Delta t$ 的单个时间步长内的离散更新关系。推导过程必须仅使用计算海洋学中广为接受的物理定律和核心定义，即傅里叶热传导、熔化潜热以及能量和盐量守恒。除这些基本原理外，不要假设任何特殊的公式。最终的离散更新必须强制执行以下符合物理现实的约束：\n- 海洋-冰界面处的温度为局地海水冰点温度 $T_f(S_{ml}) = \\lambda S_{ml}$，其中 $\\lambda = -0.054$ 单位为 $^{\\circ}\\mathrm{C}/\\mathrm{psu}$，$T_f$ 以摄氏度表示。\n- 只要表面温度保持在或低于融点（$T_s \\le 0^{\\circ}\\mathrm{C}$），雪-冰柱就在表面温度 $T_s$ 和界面温度 $T_f$ 之间传导热量，其净向下传导热通量等于给定的表面通量。如果由表面通量隐含的 $T_s$ 将超过 $0$ 摄氏度，则将 $T_s$ 限制在 $0$，并将多余的表面能量视为可用于首先融化雪，然后融化表层海冰的能量。\n- 与冰-海界面的湍流海洋热交换被参数化为一个线性界面通量，该通量与混合层温度和冰点温度之差成正比，系数为 $\\gamma$：$Q_{int} = \\gamma\\,(T_{ml} - T_f)$。当 $T_{ml}  T_f$ 时，此通量为向上为正（从海洋到冰）。\n- 雪-冰堆叠的有效热阻为 $R = h_s/k_s + h_i/k_i$，其中 $k_s$ 和 $k_i$ 分别是雪和冰的热导率。向下进入柱体的传导通量为 $Q_{cond} = (T_s - T_f)/R$。\n- 降雪使 $h_s$ 增加 $P\\,\\Delta t$。融化根据潜热消耗减少 $h_s$；如果在一个步长内所有雪都融化，任何剩余的多余表面能量将融化顶层的海冰。\n- 海冰厚度因界面处的潜热以及表面的任何融化而改变。\n- 混合层的热含量因 $Q_b$ 和 $Q_{int}$ 而改变，混合层盐度因冰-海界面处结冰时的盐分排出或融化时的稀释而改变，这使用了局地盐量守恒。假设在时间步长内，任何表面融水都不直接混入海洋混合层。\n\n您必须使用以下常数和单位：\n- 雪的热导率 $k_s = 0.31$，单位 $\\mathrm{W\\,m^{-1}\\,K^{-1}}$。\n- 冰的热导率 $k_i = 2.0$，单位 $\\mathrm{W\\,m^{-1}\\,K^{-1}}$。\n- 雪的密度 $\\rho_s = 330$，单位 $\\mathrm{kg\\,m^{-3}}$。\n- 冰的密度 $\\rho_i = 917$，单位 $\\mathrm{kg\\,m^{-3}}$。\n- 海水的密度 $\\rho_w = 1025$，单位 $\\mathrm{kg\\,m^{-3}}$。\n- 海水的比热容 $c_{pw} = 3974$，单位 $\\mathrm{J\\,kg^{-1}\\,K^{-1}}$。\n- 熔化潜热 $L_f = 3.34\\times10^5$，单位 $\\mathrm{J\\,kg^{-1}}$。\n- 界面热交换系数 $\\gamma = 100$，单位 $\\mathrm{W\\,m^{-2}\\,K^{-1}}$。\n- 混合层深度 $H_{ml} = 50$，单位 $\\mathrm{m}$。\n- 时间步长 $\\Delta t = 86400$，单位 $\\mathrm{s}$（一天）。\n\n您的推导必须从以下基本原理开始：\n- 傅里叶热传导定律，应用于层状堆叠，其中热阻可相加。\n- 柱体的能量守恒，将一个时间步长内的净外部能量输入等同于内部能量变化的总和（混合层显热加上雪和冰相变消耗或释放的潜热）。\n- 混合层的盐量守恒，考虑在冰-海界面结冰时的卤水排出和融化时的稀释。\n\n您的程序必须实现推导出的更新方程，以从 $h_i^n$、$h_s^n$、$T_{ml}^n$ 和 $S_{ml}^n$ 计算 $h_i^{n+1}$、$h_s^{n+1}$、$T_{ml}^{n+1}$ 和 $S_{ml}^{n+1}$。然后，对于每个测试用例，它必须计算带符号的能量残差\n$$\nR = \\Delta E_{ml} + \\Delta E_{snow,lat} + \\Delta E_{ice,lat} - (Q_s + Q_b)\\,\\Delta t,\n$$\n其中 $\\Delta E_{ml} = \\rho_w\\,c_{pw}\\,H_{ml}\\,(T_{ml}^{n+1} - T_{ml}^n)$ 的单位为 $\\mathrm{J\\,m^{-2}}$，$\\Delta E_{snow,lat} = \\rho_s\\,L_f\\,(h_s^n - h_s^{n+1})$ 的单位为 $\\mathrm{J\\,m^{-2}}$（对于净雪融化，潜热消耗为正），以及 $\\Delta E_{ice,lat} = \\rho_i\\,L_f\\,(h_i^n - h_i^{n+1})$ 的单位为 $\\mathrm{J\\,m^{-2}}$（对于净冰融化，潜热消耗为正）。一个完全能量守恒的更新将产生等于 $0$ $\\mathrm{J\\,m^{-2}}$ 的 $R$ 值（在数值舍入误差范围内）。\n\n本问题不使用角度；温度必须以摄氏度为单位，所有能量单位为 $\\mathrm{J\\,m^{-2}}$。程序必须生成一行输出，其中包含所有测试用例的 $R$ 值，格式为方括号内由逗号分隔的列表，例如，“[$r_1$,$r_2$,$r_3$]”。每个 $r_i$ 必须以 $\\mathrm{J\\,m^{-2}}$ 为单位的浮点数形式打印。\n\n使用以下包含三组参数的测试套件来检验更新方案：\n- 案例 1（冬季冷却，有雪）：$h_i^n = 1.5\\,\\mathrm{m}$，$h_s^n = 0.2\\,\\mathrm{m}$，$T_{ml}^n = -1.5^{\\circ}\\mathrm{C}$，$S_{ml}^n = 32.0\\,\\mathrm{psu}$，$Q_s = -50.0\\,\\mathrm{W\\,m^{-2}}$，$Q_b = 2.0\\,\\mathrm{W\\,m^{-2}}$，$P = 0.0\\,\\mathrm{m\\,s^{-1}}$。\n- 案例 2（夏季融化，无雪）：$h_i^n = 1.0\\,\\mathrm{m}$，$h_s^n = 0.0\\,\\mathrm{m}$，$T_{ml}^n = -1.0^{\\circ}\\mathrm{C}$，$S_{ml}^n = 30.0\\,\\mathrm{psu}$，$Q_s = 150.0\\,\\mathrm{W\\,m^{-2}}$，$Q_b = 2.0\\,\\mathrm{W\\,m^{-2}}$，$P = 0.0\\,\\mathrm{m\\,s^{-1}}$。\n- 案例 3（强冷却和少量降雪）：$h_i^n = 0.5\\,\\mathrm{m}$，$h_s^n = 0.3\\,\\mathrm{m}$，$T_{ml}^n = -1.75^{\\circ}\\mathrm{C}$，$S_{ml}^n = 34.0\\,\\mathrm{psu}$，$Q_s = -150.0\\,\\mathrm{W\\,m^{-2}}$，$Q_b = 2.0\\,\\mathrm{W\\,m^{-2}}$，$P = 1.0\\times10^{-7}\\,\\mathrm{m\\,s^{-1}}$。\n\n您的程序应生成一行输出，其中包含结果，格式为方括号内由逗号分隔的列表（例如，“[result1,result2,result3]”），其中每个元素是相应测试用例的能量残差 $R$，单位为 $\\mathrm{J\\,m^{-2}}$。",
            "solution": "该问题要求推导并实现一个雪-海冰-海洋耦合柱状模型的一维显式时间步长更新，该更新应是能量守恒的。预报变量为海冰厚度 $h_i$、雪层深度 $h_s$、混合层温度 $T_{ml}$ 和混合层盐度 $S_{ml}$。推导从热传导、能量守恒和盐量守恒的基本原理出发。所有计算都是针对单个时间步长 $\\Delta t$ 进行的，使用时间 $n$ 的状态来计算时间 $n+1$ 的状态。\n\n柱体的总能量（单位：焦耳/平方米）$E_{total}$，可以表示为海洋混合层中的显热与相对于冰点液态水参考状态下储存在雪和冰中的潜热之和。\n$$ E_{total} = \\rho_w c_{pw} H_{ml} (T_{ml} - T_f) - \\rho_i L_f h_i - \\rho_s L_f h_s $$\n能量守恒原理指出，系统总能量在一个时间步长 $\\Delta t$ 内的变化必须等于从外部来源进入系统的净能量。外部能量通量是表面热通量 $Q_s$ 和深海热通量 $Q_b$。降雪 $P$ 也代表了质量和能量的输入。由于雪已经是固态，以速率 $P$ 将其添加到柱体中，相对于液态水参考状态，相当于一个能量通量 $-\\rho_s L_f P$。因此，总能量平衡为：\n$$ \\frac{dE_{total}}{dt} = Q_s + Q_b - \\rho_s L_f P $$\n我们的显式更新方案必须将此平衡方程离散化。我们将通过考虑每个界面处的通量来推导每个状态变量的更新方程。\n\n**1. 时间步长 $n$ 时的初始计算**\n\n在时间步长开始时，根据当前状态 $(h_i^n, h_s^n, T_{ml}^n, S_{ml}^n)$ 计算几个量。\n- 冰-海界面处的冰点温度 $T_f$ 是盐度的函数：\n$$ T_f^n = \\lambda S_{ml}^n $$\n其中 $\\lambda = -0.054\\ \\mathrm{^\\circ C/psu}$。\n- 在时间步长内，雪深会因任何新增降雪而更新。这给出了可用于热力学计算的总雪量：\n$$ h_s^* = h_s^n + P \\Delta t $$\n\n**2. 表面能量平衡和传导热通量**\n\n通过雪层和冰层的热传递遵循傅里叶传导定律。复合板的有效热阻 $R^n$ 是雪层和冰层电阻之和：\n$$ R^n = \\frac{h_s^*}{k_s} + \\frac{h_i^n}{k_i} $$\n其中 $k_s$ 和 $k_i$ 分别是雪和冰的热导率。\n\n传导热通量 $Q_{cond}$ 向下为正。表面能量平衡决定了大气通量 $Q_s$ 与 $Q_{cond}$ 之间的关系。\n首先，我们确定如果整个表面通量 $Q_s$ 都通过柱体传导所需达到的表面温度 $T_{s,implied}$：\n$$ Q_s = \\frac{T_{s,implied} - T_f^n}{R^n} \\implies T_{s,implied} = T_f^n + Q_s R^n $$\n存在两种可能的情形：\n- **无融化情形 ($T_{s,implied} \\le 0\\mathrm{^\\circ C}$):** 表面保持在或低于冰点。传导通量等于表面热通量，$Q_{cond} = Q_s$。没有能量可用于表面融化。\n- **融化情形 ($T_{s,implied}  0\\mathrm{^\\circ C}$):** 表面温度不能超过融点，被限制在 $T_s = 0\\mathrm{^\\circ C}$。此时，传导通量由被限制的表面和冰-海界面之间的温度梯度决定：\n$$ Q_{cond} = \\frac{T_s - T_f^n}{R^n} = \\frac{0 - T_f^n}{R^n} = -\\frac{T_f^n}{R^n} $$\n表面热通量 $Q_s$ 中未向下传导的部分被用于融化表面的雪和/或冰。可用于表面融化的通量 $F_{melt,s}$ 为：\n$$ F_{melt,s} = Q_s - Q_{cond} $$\n在一个时间步长内可用于表面融化的总能量为 $E_{melt,s} = F_{melt,s} \\Delta t$。\n\n**3. 相变和厚度更新**\n\n雪和冰的厚度由于表面融化和底部融化/冻结而改变。\n\n**表面融化：**\n能量 $E_{melt,s}$ 首先融化可用的雪 $h_s^*$。融化所有雪所需的能量为 $E_{snow,max\\_melt} = \\rho_s L_f h_s^*$。\n- 如果 $E_{melt,s} \\le E_{snow,max\\_melt}$，则只有雪融化。因融化导致的雪深变化为 $\\Delta h_{s,melt} = -E_{melt,s} / (\\rho_s L_f)$。新的雪深为 $h_s^{n+1} = h_s^* + \\Delta h_{s,melt}$。没有表面冰融化发生，因此 $\\Delta h_{i,surf} = 0$。\n- 如果 $E_{melt,s}  E_{snow,max\\_melt}$，则所有雪都融化，因此 $h_s^{n+1} = 0$。剩余的能量 $E_{ice,surf\\_melt} = E_{melt,s} - E_{snow,max\\_melt}$ 用于从表面融化冰。因表面融化导致的冰厚变化为 $\\Delta h_{i,surf} = -E_{ice,surf\\_melt} / (\\rho_i L_f)$。\n\n**底部融化/增长：**\n在冰-海界面，热量从上方传导下来（$Q_{cond}$），并由下方的海洋提供（$Q_{int}^n$）。海洋热通量参数化为：\n$$ Q_{int}^n = \\gamma (T_{ml}^n - T_f^n) $$\n界面处可用于相变的净热通量为 $F_{basal} = Q_{cond} + Q_{int}^n$。一个正的 $F_{basal}$ 值（净向上通量）导致融化，而一个负值导致冻结。底部冰厚的变化由能量平衡给出：\n$$ \\rho_i L_f \\frac{dh_i}{dt}\\bigg|_{basal} = -F_{basal} = -(Q_{cond} + Q_{int}^n) $$\n在时间步长 $\\Delta t$ 内，变化量为：\n$$ \\Delta h_{i,basal} = -\\frac{(Q_{cond} + Q_{int}^n) \\Delta t}{\\rho_i L_f} $$\n\n**总厚度更新：**\n新的冰厚是初始厚度与两个表面变化量之和：\n$$ h_i^{n+1} = h_i^n + \\Delta h_{i,surf} + \\Delta h_{i,basal} $$\n我们强制执行物理约束 $h_i^{n+1} \\ge 0$。\n\n**4. 混合层温度和盐度更新**\n\n**温度：**\n混合层与上方的冰（$Q_{int}^n$，向上）和下方的深海（$Q_b$，向上）进行热交换。进入混合层的净热通量为 $Q_b - Q_{int}^n$。混合层温度的变化为：\n$$ \\rho_w c_{pw} H_{ml} \\frac{dT_{ml}}{dt} = Q_b - Q_{int}^n $$\n$$ T_{ml}^{n+1} = T_{ml}^n + \\frac{(Q_b - Q_{int}^n) \\Delta t}{\\rho_w c_{pw} H_{ml}} $$\n\n**盐度：**\n混合层盐度因底部冻结时的盐分排出和底部融化时的稀释而改变。我们应用盐量守恒。在时间 $n$，混合层中的总盐量为 $M_{salt}^n = S_{ml}^n \\rho_w H_{ml}$。总水质量为 $M_w^n = \\rho_w H_{ml}$。当质量为 $\\Delta m_{ice} = \\rho_i \\Delta h_{i,basal}$ 的冰在底部形成或融化时，混合层中的水质量变化为 $\\Delta m_w = -\\Delta m_{ice}$。\n- 如果是冻结（$\\Delta h_{i,basal}  0$），质量为 $\\rho_i \\Delta h_{i,basal}$ 的水被移除，其盐分被留下。新盐度增加。\n- 如果是融化（$\\Delta h_{i,basal}  0$），质量为 $-\\rho_i \\Delta h_{i,basal}$ 的淡水被加入，稀释了盐分。新盐度降低。\n两种情况都由新盐度 $S_{ml}^{n+1}$ 的同一个守恒方程描述：\n$$ S_{ml}^{n+1} = \\frac{\\text{Total Salt}}{\\text{New Total Water Mass}} = \\frac{S_{ml}^n \\rho_w H_{ml}}{\\rho_w H_{ml} - \\rho_i \\Delta h_{i,basal}} $$\n这确保了在 $H_{ml}$ 保持不变的假设下，局地盐量是守恒的。\n\n**5. 能量守恒残差**\n\n为验证该方案的能量守恒特性，我们计算问题陈述中定义的残差 $R$。该值表示系统内部能量的计算变化量（混合层的显热加上雪和冰的潜热）与总外部能量输入之间的差值。\n$$ R = \\Delta E_{ml} + \\Delta E_{snow,lat} + \\Delta E_{ice,lat} - (Q_s + Q_b)\\Delta t $$\n各分量使用初始（$n$）和最终（$n+1$）状态计算：\n- $\\Delta E_{ml} = \\rho_w c_{pw} H_{ml} (T_{ml}^{n+1} - T_{ml}^n)$\n- $\\Delta E_{snow,lat} = \\rho_s L_f (h_s^n - h_s^{n+1})$\n- $\\Delta E_{ice,lat} = \\rho_i L_f (h_i^n - h_i^{n+1})$\n\n通过一致的推导，所有内部能量交换都会相互抵消，$R$ 应该只反映模型的总能量源/汇项与简化的外部强迫项 $(Q_s+Q_b)\\Delta t$ 之间的任何不匹配。正如在推理过程中推导的那样，增加的雪质量 $P$ 代表了一个能量汇 $\\rho_s L_f P \\Delta t$，这在残差方程的外部强迫项中并未计入。因此，我们预期 $R = -\\rho_s L_f P \\Delta t$。对于 $P=0$ 的情况，残差 $R$ 在浮点精度范围内应为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    # Define physical constants and model parameters\n    constants = {\n        'k_s': 0.31,    # Thermal conductivity of snow (W m^-1 K^-1)\n        'k_i': 2.0,     # Thermal conductivity of ice (W m^-1 K^-1)\n        'rho_s': 330,   # Density of snow (kg m^-3)\n        'rho_i': 917,   # Density of ice (kg m^-3)\n        'rho_w': 1025,  # Density of seawater (kg m^-3)\n        'c_pw': 3974,   # Specific heat capacity of seawater (J kg^-1 K^-1)\n        'L_f': 3.34e5,  # Latent heat of fusion (J kg^-1)\n        'gamma': 100,   # Interfacial heat exchange coefficient (W m^-2 K^-1)\n        'H_ml': 50,     # Mixed-layer depth (m)\n        'delta_t': 86400, # Time step (s)\n        'lambda_tf': -0.054 # Freezing point salinity coefficient (°C / psu)\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (winter cooling, snow present)\n        {'h_i_n': 1.5, 'h_s_n': 0.2, 'T_ml_n': -1.5, 'S_ml_n': 32.0, 'Q_s': -50.0, 'Q_b': 2.0, 'P': 0.0},\n        # Case 2 (summer melt, no snow)\n        {'h_i_n': 1.0, 'h_s_n': 0.0, 'T_ml_n': -1.0, 'S_ml_n': 30.0, 'Q_s': 150.0, 'Q_b': 2.0, 'P': 0.0},\n        # Case 3 (strong cooling and light snowfall)\n        {'h_i_n': 0.5, 'h_s_n': 0.3, 'T_ml_n': -1.75, 'S_ml_n': 34.0, 'Q_s': -150.0, 'Q_b': 2.0, 'P': 1.0e-7}\n    ]\n\n    results = []\n    for case in test_cases:\n        residual = one_step_update(case, constants)\n        results.append(residual)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef one_step_update(case, const):\n    \"\"\"\n    Performs one explicit time step update for the coupled system.\n    _n denotes state at the beginning of the time step.\n    _np1 denotes state at the end of the time step.\n    \"\"\"\n    # Unpack case data and constants for clarity\n    h_i_n, h_s_n = case['h_i_n'], case['h_s_n']\n    T_ml_n, S_ml_n = case['T_ml_n'], case['S_ml_n']\n    Q_s, Q_b, P = case['Q_s'], case['Q_b'], case['P']\n    \n    k_s, k_i = const['k_s'], const['k_i']\n    rho_s, rho_i, rho_w = const['rho_s'], const['rho_i'], const['rho_w']\n    c_pw, L_f = const['c_pw'], const['L_f']\n    gamma, H_ml = const['gamma'], const['H_ml']\n    delta_t, lambda_tf = const['delta_t'], const['lambda_tf']\n    \n    # --- DERIVATION IMPLEMENTATION ---\n\n    # 1. Initial Calculations at Time n\n    # Snow depth after precipitation, before any melting\n    h_s_star = h_s_n + P * delta_t\n    # Seawater freezing temperature at the interface\n    T_f_n = lambda_tf * S_ml_n\n\n    # 2. Surface Energy Balance and Conductive Heat Flux\n    # Thermal resistance of the snow/ice column. Epsilon avoids division by zero.\n    R_n = h_s_star / k_s + h_i_n / k_i if (h_s_star + h_i_n) > 1e-9 else 0.0\n\n    Q_cond = 0.0\n    E_melt_s = 0.0  # Total energy available for surface melt over the time step\n\n    if R_n > 1e-9:\n        # Implied surface temperature to balance the surface heat flux Q_s\n        T_s_implied = T_f_n + Q_s * R_n\n\n        if T_s_implied = 0.0:\n            # No surface melt. Conductive flux equals surface flux.\n            Q_cond = Q_s\n        else:\n            # Surface melt occurs. Surface temperature is clamped at 0°C.\n            # Conductive flux is now determined by T_s=0 and T_f_n\n            Q_cond = (0.0 - T_f_n) / R_n\n            # Excess energy flux available for melting\n            F_melt_s = Q_s - Q_cond\n            E_melt_s = F_melt_s * delta_t\n    else: # Case of no ice/snow\n      # All Qs goes to the ocean, no conduction.\n      # This case is not in the test suite but is handled for completeness.\n      E_melt_s = Q_s * delta_t if Q_s > 0 else 0\n\n    # 3. Phase Changes and Thickness Updates\n    # Surface Melt\n    E_snow_max_melt = rho_s * L_f * h_s_star\n    delta_h_i_surf = 0.0\n\n    if E_melt_s = E_snow_max_melt:\n        # Not all snow melts (or no melt at all)\n        delta_h_s_melt = -E_melt_s / (rho_s * L_f)\n        h_s_np1 = h_s_star + delta_h_s_melt\n    else:\n        # All snow melts, and remaining energy melts ice\n        h_s_np1 = 0.0\n        E_ice_surf_melt = E_melt_s - E_snow_max_melt\n        delta_h_i_surf = -E_ice_surf_melt / (rho_i * L_f)\n    \n    # Basal Melt/Growth\n    Q_int_n = gamma * (T_ml_n - T_f_n)\n    delta_h_i_basal = -(Q_cond + Q_int_n) * delta_t / (rho_i * L_f)\n    \n    # Total Thickness Update\n    h_i_np1 = h_i_n + delta_h_i_surf + delta_h_i_basal\n    # Enforce non-negativity. If triggered, would slightly violate energy conservation\n    # as the excess melt energy is not transferred elsewhere.\n    h_i_np1 = max(0.0, h_i_np1)\n    \n    # 4. Mixed-Layer Updates\n    # Temperature\n    T_ml_np1 = T_ml_n + (Q_b - Q_int_n) * delta_t / (rho_w * c_pw * H_ml)\n    \n    # Salinity\n    denominator = rho_w * H_ml - rho_i * delta_h_i_basal\n    if denominator > 1e-9:\n        S_ml_np1 = S_ml_n * (rho_w * H_ml) / denominator\n    else:\n        # Avoid division by zero/negative in unrealistic case of massive freezing\n        S_ml_np1 = S_ml_n\n\n    # 5. Energy Conservation Residual Calculation\n    Delta_E_ml = rho_w * c_pw * H_ml * (T_ml_np1 - T_ml_n)\n    Delta_E_snow_lat = rho_s * L_f * (h_s_n - h_s_np1)\n    Delta_E_ice_lat = rho_i * L_f * (h_i_n - h_i_np1)\n    E_ext = (Q_s + Q_b) * delta_t\n    R = Delta_E_ml + Delta_E_snow_lat + Delta_E_ice_lat - E_ext\n    \n    return R\n\nsolve()\n```"
        }
    ]
}