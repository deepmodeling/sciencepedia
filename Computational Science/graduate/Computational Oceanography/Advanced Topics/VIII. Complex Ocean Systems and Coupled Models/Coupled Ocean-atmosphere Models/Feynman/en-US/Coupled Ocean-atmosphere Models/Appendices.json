{
    "hands_on_practices": [
        {
            "introduction": "The exchange of energy between the ocean and atmosphere is the engine of the climate system. This practice provides a fundamental, hands-on implementation of the surface energy balance, requiring you to compute the net heat flux from its four primary components: shortwave and longwave radiation, and sensible and latent heat . By building this calculation from first principles, you will gain a deep, quantitative understanding of how meteorological conditions directly control the heating and cooling of the ocean surface.",
            "id": "3788896",
            "problem": "You are asked to implement, from first principles, the surface energy balance of a coupled ocean-atmosphere column to compute the net surface heat flux into the ocean and the resulting Sea Surface Temperature (SST) tendency for given meteorological inputs. Use physically grounded laws and well-tested empirical relationships, as detailed below, to construct a fully specified algorithm that is numerically stable and scientifically realistic. Your program must produce results for a provided test suite and output them in a single line in a strictly specified format.\n\nAssumptions, definitions, and physical laws:\n- Let the sign convention be positive downward (into the ocean). The net surface heat flux, denoted $Q_{\\text{net}}$, is the sum of the shortwave net flux $Q_{\\text{sw,net}}$, the longwave net flux $Q_{\\text{lw,net}}$, the sensible heat flux $Q_{\\text{sen}}$, and the latent heat flux $Q_{\\text{lat}}$:\n$$\nQ_{\\text{net}} = Q_{\\text{sw,net}} + Q_{\\text{lw,net}} + Q_{\\text{sen}} + Q_{\\text{lat}}.\n$$\n- Shortwave component: Downward shortwave radiation at the sea surface is provided as $S_{\\downarrow}$ (in $\\mathrm{W\\,m^{-2}}$). Ocean albedo $\\alpha(\\theta)$ depends on the solar zenith angle $\\theta$ (angle unit required: radians). The shortwave net flux into the ocean is\n$$\nQ_{\\text{sw,net}} = \\left(1 - \\alpha(\\theta)\\right) S_{\\downarrow},\n$$\nwhere the albedo is modulated by angle as\n$$\n\\alpha(\\theta) = \\mathrm{clip}\\left(\\alpha_0 + k \\left(1 - \\cos \\theta\\right), \\alpha_{\\min}, \\alpha_{\\max}\\right),\n$$\nwith constants $\\alpha_0 = 0.06$, $k = 0.20$, $\\alpha_{\\min} = 0.02$, and $\\alpha_{\\max} = 0.50$.\n- Longwave component: Use the Stefan–Boltzmann law with atmospheric emissivity depending on cloud fraction. Let $\\sigma$ be the Stefan–Boltzmann constant, $\\sigma = 5.670374419 \\times 10^{-8}\\,\\mathrm{W\\,m^{-2}\\,K^{-4}}$. Let the near-surface air temperature be $T_a$ (in $\\mathrm{K}$), and the ocean surface temperature (SST) be $T_s$ (in $\\mathrm{K}$). The atmospheric emissivity is a linear blend of clear-sky emissivity and overcast emissivity:\n$$\n\\varepsilon_{\\text{atm}} = \\left(1 - C\\right)\\,\\varepsilon_{\\text{clear}} + C\\,\\varepsilon_{\\text{overcast}},\n$$\nwhere $C$ is the cloud fraction in $[0,1]$, $\\varepsilon_{\\text{overcast}} = 0.98$, and $\\varepsilon_{\\text{clear}}$ is diagnosed from near-surface air vapor pressure $e_a$ using a well-tested empirical relationship:\n$$\n\\varepsilon_{\\text{clear}} = \\mathrm{clip}\\left(0.74 + 0.0049\\,e_a^{(\\mathrm{hPa})},\\,0,\\,1\\right).\n$$\nHere $e_a^{(\\mathrm{hPa})}$ is $e_a$ in $\\mathrm{hPa}$, with $e_a$ obtained from specific humidity $q_a$ and surface pressure $p$ via\n$$\ne_a = \\frac{q_a\\,p}{0.622 + 0.378\\,q_a}.\n$$\nLet the ocean emissivity be $\\varepsilon_{\\text{ocean}} = 0.97$. Then\n$$\nL_{\\downarrow} = \\varepsilon_{\\text{atm}} \\,\\sigma\\, T_a^4,\\qquad\nL_{\\uparrow} = \\varepsilon_{\\text{ocean}} \\,\\sigma\\, T_s^4,\\qquad\nQ_{\\text{lw,net}} = L_{\\downarrow} - L_{\\uparrow}.\n$$\n- Sensible and latent components: Use the bulk aerodynamic formulation with constant transfer coefficients for stability-neutral conditions. Let $U$ be the wind speed at $10\\,\\mathrm{m}$ (in $\\mathrm{m\\,s^{-1}}$), $q_a$ be near-surface air specific humidity (in $\\mathrm{kg\\,kg^{-1}}$), and $T_a$ as defined above. Air density $\\rho_{\\text{air}}$ is diagnosed from the Ideal Gas Law:\n$$\n\\rho_{\\text{air}} = \\frac{p}{R_d\\, T_a},\n$$\nwith $R_d = 287\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$, and use $p = 101325\\,\\mathrm{Pa}$. For air heat capacity, use $c_{p,\\text{air}} = 1004\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$. For latent heat of vaporization, use $L_v = 2.5 \\times 10^6\\,\\mathrm{J\\,kg^{-1}}$. Let the neutral transfer coefficients be $C_h = 1.2 \\times 10^{-3}$ and $C_e = 1.2 \\times 10^{-3}$. The saturation specific humidity at the sea surface $q_s$ is obtained from saturation vapor pressure $e_s(T_s)$ computed via the Tetens formula over water:\n$$\nT_C = T_s - 273.15,\\quad\ne_s^{(\\mathrm{hPa})} = 6.112 \\,\\exp\\!\\left(\\frac{17.67\\,T_C}{T_C + 243.5}\\right),\\quad e_s = 100\\, e_s^{(\\mathrm{hPa})},\n$$\nand then\n$$\nq_s = \\frac{0.622\\,e_s}{p - 0.378\\,e_s}.\n$$\nWith $q_s$ and $q_a$,\n$$\nQ_{\\text{lat}} = -\\,\\rho_{\\text{air}}\\, L_v\\, C_e\\, U \\,\\left(q_s - q_a\\right),\\qquad\nQ_{\\text{sen}} = -\\,\\rho_{\\text{air}}\\, c_{p,\\text{air}}\\, C_h\\, U \\,\\left(T_s - T_a\\right).\n$$\nThe negative signs enforce the convention that upward turbulent fluxes (typical when $T_s > T_a$ or $q_s > q_a$) are negative downward.\n- SST tendency: Assume a slab mixed layer of depth $h$ (in $\\mathrm{m}$) with density $\\rho_w = 1025\\,\\mathrm{kg\\,m^{-3}}$ and specific heat capacity $c_{p,w} = 3990\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$. The instantaneous SST tendency is\n$$\n\\frac{d T_s}{dt} = \\frac{Q_{\\text{net}}}{\\rho_w\\, c_{p,w}\\, h},\n$$\nreported in $\\mathrm{K\\,s^{-1}}$.\n\nYour task:\n- Implement the algorithm that, for each test case, computes $Q_{\\text{net}}$ in $\\mathrm{W\\,m^{-2}}$ and the instantaneous $\\frac{d T_s}{dt}$ in $\\mathrm{K\\,s^{-1}}$ using the laws and definitions above, with the stated constants.\n- Angle inputs are in radians. All other inputs are in the units stated above. Express the net surface heat flux in $\\mathrm{W\\,m^{-2}}$ rounded to three decimal places, and the SST tendency in $\\mathrm{K\\,s^{-1}}$ rounded to six decimal places.\n\nTest suite:\nProvide results for the following four test cases, each written as an ordered tuple $(S_{\\downarrow}, C, T_a, T_s, U, q_a, \\theta, h)$:\n1. $ (650.0,\\, 0.50,\\, 298.0,\\, 299.0,\\, 7.0,\\, 0.0160,\\, 0.80,\\, 30.0) $\n2. $ (0.0,\\, 1.00,\\, 290.0,\\, 291.0,\\, 2.0,\\, 0.0100,\\, 1.30,\\, 50.0) $\n3. $ (900.0,\\, 0.10,\\, 301.0,\\, 303.0,\\, 15.0,\\, 0.0080,\\, 0.20,\\, 20.0) $\n4. $ (400.0,\\, 0.70,\\, 295.5,\\, 296.0,\\, 5.0,\\, 0.0140,\\, 1.40,\\, 5.0) $\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of pairs, where each pair is the net surface heat flux and the SST tendency for one test case. The list must be enclosed in square brackets, and each pair must be enclosed in square brackets. For example:\n\"[ [Q1,dT1], [Q2,dT2], [Q3,dT3], [Q4,dT4] ]\"\n- Each $Q_i$ must be a float in $\\mathrm{W\\,m^{-2}}$ rounded to three decimal places, and each $\\mathrm{d}T_i$ must be a float in $\\mathrm{K\\,s^{-1}}$ rounded to six decimal places.",
            "solution": "The problem requires the computation of the net surface heat flux into the ocean, $Q_{\\text{net}}$, and the resulting instantaneous Sea Surface Temperature (SST) tendency, $\\frac{d T_s}{dt}$, based on a set of provided meteorological inputs and physical formulations. The solution is derived by systematically calculating each component of the surface energy balance and then applying the first law of thermodynamics to a slab ocean mixed layer. All calculations adhere strictly to the provided equations and constants.\n\nThe net heat flux $Q_{\\text{net}}$ is the sum of four components, with the sign convention being positive for fluxes into the ocean:\n$$\nQ_{\\text{net}} = Q_{\\text{sw,net}} + Q_{\\text{lw,net}} + Q_{\\text{sen}} + Q_{\\text{lat}}\n$$\n\nThe calculation proceeds as follows for each test case, which is an ordered tuple of inputs $(S_{\\downarrow}, C, T_a, T_s, U, q_a, \\theta, h)$.\n\n_1. Net Shortwave Radiation ($Q_{\\text{sw,net}}$)_\nThe net shortwave radiation is the incoming shortwave radiation $S_{\\downarrow}$ that is not reflected by the sea surface. The fraction reflected is the albedo, $\\alpha(\\theta)$, which depends on the solar zenith angle $\\theta$.\nFirst, a raw albedo is calculated using the provided empirical formula with constants $\\alpha_0 = 0.06$ and $k = 0.20$:\n$$\n\\alpha_{\\text{raw}} = \\alpha_0 + k (1 - \\cos \\theta)\n$$\nThis value is then constrained to a physically realistic range $[\\alpha_{\\min}, \\alpha_{\\max}]$, where $\\alpha_{\\min} = 0.02$ and $\\alpha_{\\max} = 0.50$:\n$$\n\\alpha(\\theta) = \\mathrm{clip}(\\alpha_{\\text{raw}}, \\alpha_{\\min}, \\alpha_{\\max})\n$$\nThe net shortwave flux is then:\n$$\nQ_{\\text{sw,net}} = (1 - \\alpha(\\theta)) S_{\\downarrow}\n$$\n\n_2. Net Longwave Radiation ($Q_{\\text{lw,net}}$)_\nThe net longwave radiation is the difference between the downward longwave radiation from the atmosphere, $L_{\\downarrow}$, and the upward longwave radiation emitted by the ocean surface, $L_{\\uparrow}$.\n$$\nQ_{\\text{lw,net}} = L_{\\downarrow} - L_{\\uparrow}\n$$\nThe upward flux is calculated using the Stefan-Boltzmann law with a constant ocean emissivity $\\varepsilon_{\\text{ocean}} = 0.97$, SST $T_s$ in Kelvin, and the Stefan-Boltzmann constant $\\sigma = 5.670374419 \\times 10^{-8}\\,\\mathrm{W\\,m^{-2}\\,K^{-4}}$:\n$$\nL_{\\uparrow} = \\varepsilon_{\\text{ocean}} \\sigma T_s^4\n$$\nThe downward flux depends on the atmospheric emissivity, $\\varepsilon_{\\text{atm}}$, and the near-surface air temperature, $T_a$:\n$$\nL_{\\downarrow} = \\varepsilon_{\\text{atm}} \\sigma T_a^4\n$$\nThe atmospheric emissivity is a weighted average of clear-sky ($\\varepsilon_{\\text{clear}}$) and overcast ($\\varepsilon_{\\text{overcast}} = 0.98$) emissivities, with the cloud fraction $C$ as the weight:\n$$\n\\varepsilon_{\\text{atm}} = (1 - C) \\varepsilon_{\\text{clear}} + C \\varepsilon_{\\text{overcast}}\n$$\nThe clear-sky emissivity is determined empirically from the near-surface air vapor pressure, $e_a$. First, $e_a$ (in Pascals) is derived from the specific humidity $q_a$ and surface pressure $p = 101325\\,\\mathrm{Pa}$:\n$$\ne_a = \\frac{q_a p}{0.622 + 0.378 q_a}\n$$\nThis is converted to hectopascals ($e_a^{(\\mathrm{hPa})} = e_a / 100$) for use in the empirical formula, which is then clipped to the range $[0, 1]$:\n$$\n\\varepsilon_{\\text{clear}} = \\mathrm{clip}\\left(0.74 + 0.0049 e_a^{(\\mathrm{hPa})}, 0, 1\\right)\n$$\n\n_3. Turbulent Heat Fluxes ($Q_{\\text{sen}}$ and $Q_{\\text{lat}}$)_\nThese fluxes represent the transfer of heat via turbulence and are calculated using bulk aerodynamic formulas.\nThe air density, $\\rho_{\\text{air}}$, is first determined from the Ideal Gas Law, using $p = 101325\\,\\mathrm{Pa}$, $R_d = 287\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$, and the air temperature $T_a$:\n$$\n\\rho_{\\text{air}} = \\frac{p}{R_d T_a}\n$$\nThe sensible heat flux, $Q_{\\text{sen}}$, depends on the temperature difference between the sea surface and the air, the wind speed $U$, and constants for air specific heat ($c_{p,\\text{air}} = 1004\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$) and the transfer coefficient ($C_h = 1.2 \\times 10^{-3}$):\n$$\nQ_{\\text{sen}} = - \\rho_{\\text{air}} c_{p,\\text{air}} C_h U (T_s - T_a)\n$$\nThe latent heat flux, $Q_{\\text{lat}}$, is associated with evaporation and depends on the specific humidity difference between the saturated surface and the air. It requires the latent heat of vaporization ($L_v = 2.5 \\times 10^6\\,\\mathrm{J\\,kg^{-1}}$) and a transfer coefficient ($C_e = 1.2 \\times 10^{-3}$).\n$$\nQ_{\\text{lat}} = - \\rho_{\\text{air}} L_v C_e U (q_s - q_a)\n$$\nTo calculate this, the saturation specific humidity at the sea surface, $q_s$, must be found. This begins with the saturation vapor pressure $e_s$, computed from the SST $T_s$ using the Tetens formula. First, $T_s$ is converted to Celsius: $T_C = T_s - 273.15$.\n$$\ne_s^{(\\mathrm{hPa})} = 6.112 \\exp\\left(\\frac{17.67 T_C}{T_C + 243.5}\\right)\n$$\nThe result $e_s^{(\\mathrm{hPa})}$ is converted to Pascals ($e_s = 100 \\times e_s^{(\\mathrm{hPa})}$) and then used to find $q_s$:\n$$\nq_s = \\frac{0.622 e_s}{p - 0.378 e_s}\n$$\n\n_4. Sea Surface Temperature Tendency ($\\frac{d T_s}{dt}$)_\nAfter summing the four flux components to find the total net flux $Q_{\\text{net}}$, the instantaneous rate of change of the SST is computed by considering the heat capacity of the ocean's mixed layer, a slab of depth $h$. Given the density of water $\\rho_w = 1025\\,\\mathrm{kg\\,m^{-3}}$ and its specific heat capacity $c_{p,w} = 3990\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$:\n$$\n\\frac{d T_s}{dt} = \\frac{Q_{\\text{net}}}{\\rho_w c_{p,w} h}\n$$\nThe final results, $Q_{\\text{net}}$ and $\\frac{d T_s}{dt}$, are rounded to $3$ and $6$ decimal places, respectively, for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the net surface heat flux and SST tendency for a set of test cases.\n    \"\"\"\n\n    # Define physical and model constants\n    SIGMA = 5.670374419e-8  # Stefan-Boltzmann constant (W m^-2 K^-4)\n    ALPHA_0 = 0.06          # Base albedo\n    K_ALBEDO = 0.20         # Albedo zenith angle coefficient\n    ALPHA_MIN = 0.02        # Minimum albedo\n    ALPHA_MAX = 0.50        # Maximum albedo\n    EPS_OVERCAST = 0.98     # Emissivity of overcast sky\n    EPS_OCEAN = 0.97        # Emissivity of ocean surface\n    R_d = 287.0             # Gas constant for dry air (J kg^-1 K^-1)\n    P_SURF = 101325.0       # Standard surface pressure (Pa)\n    CP_AIR = 1004.0         # Specific heat of air at constant pressure (J kg^-1 K^-1)\n    L_v = 2.5e6             # Latent heat of vaporization (J kg^-1)\n    C_h = 1.2e-3            # Neutral transfer coefficient for sensible heat\n    C_e = 1.2e-3            # Neutral transfer coefficient for latent heat (evaporation)\n    RHO_W = 1025.0          # Density of seawater (kg m^-3)\n    CP_W = 3990.0           # Specific heat of seawater (J kg^-1 K^-1)\n\n    def calculate_fluxes(S_down, C, T_a, T_s, U, q_a, theta, h):\n        \"\"\"\n        Calculates all surface flux components for a single data point.\n        \n        Args:\n            S_down (float): Downward shortwave radiation (W m^-2)\n            C (float): Cloud fraction (0-1)\n            T_a (float): Air temperature (K)\n            T_s (float): Sea surface temperature (K)\n            U (float): Wind speed (m s^-1)\n            q_a (float): Specific humidity of air (kg kg^-1)\n            theta (float): Solar zenith angle (radians)\n            h (float): Mixed layer depth (m)\n            \n        Returns:\n            tuple: A tuple containing (Q_net, dT_s_dt).\n        \"\"\"\n        # 1. Net Shortwave Radiation (Q_sw_net)\n        alpha_raw = ALPHA_0 + K_ALBEDO * (1 - np.cos(theta))\n        alpha = np.clip(alpha_raw, ALPHA_MIN, ALPHA_MAX)\n        Q_sw_net = (1 - alpha) * S_down\n\n        # 2. Net Longwave Radiation (Q_lw_net)\n        # Upward longwave radiation from the ocean\n        L_up = EPS_OCEAN * SIGMA * T_s**4\n\n        # Downward longwave radiation from the atmosphere\n        # First, calculate atmospheric emissivity\n        e_a = (q_a * P_SURF) / (0.622 + 0.378 * q_a)  # Air vapor pressure in Pa\n        e_a_hPa = e_a / 100.0  # Convert to hPa for empirical formula\n        \n        eps_clear_raw = 0.74 + 0.0049 * e_a_hPa\n        eps_clear = np.clip(eps_clear_raw, 0, 1)\n        \n        eps_atm = (1 - C) * eps_clear + C * EPS_OVERCAST\n        \n        # Now calculate downward longwave radiation\n        L_down = eps_atm * SIGMA * T_a**4\n        Q_lw_net = L_down - L_up\n\n        # 3. Turbulent Heat Fluxes (Q_sen, Q_lat)\n        # First, calculate air density\n        rho_air = P_SURF / (R_d * T_a)\n\n        # Sensible heat flux\n        Q_sen = -rho_air * CP_AIR * C_h * U * (T_s - T_a)\n\n        # Latent heat flux\n        # First, calculate saturation specific humidity at the sea surface\n        T_C = T_s - 273.15  # Convert SST to Celsius\n        e_s_hPa = 6.112 * np.exp((17.67 * T_C) / (T_C + 243.5)) # Saturation vapor pressure in hPa\n        e_s = e_s_hPa * 100.0  # Convert to Pascals\n        \n        q_s = (0.622 * e_s) / (P_SURF - 0.378 * e_s) # Saturation specific humidity\n        \n        Q_lat = -rho_air * L_v * C_e * U * (q_s - q_a)\n\n        # 4. Total Net Heat Flux (Q_net)\n        Q_net = Q_sw_net + Q_lw_net + Q_sen + Q_lat\n\n        # 5. Sea Surface Temperature Tendency (dT_s/dt)\n        denominator = RHO_W * CP_W * h\n        dT_s_dt = Q_net / denominator\n        \n        return Q_net, dT_s_dt\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (650.0, 0.50, 298.0, 299.0, 7.0, 0.0160, 0.80, 30.0),\n        (0.0, 1.00, 290.0, 291.0, 2.0, 0.0100, 1.30, 50.0),\n        (900.0, 0.10, 301.0, 303.0, 15.0, 0.0080, 0.20, 20.0),\n        (400.0, 0.70, 295.5, 296.0, 5.0, 0.0140, 1.40, 5.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        Q_net, dT_s_dt = calculate_fluxes(*case)\n        results.append((Q_net, dT_s_dt))\n\n    # Final print statement in the exact required format.\n    formatted_pairs = [f\"[{q:.3f}, {dt:.6f}]\" for q, dt in results]\n    final_output = f\"[{', '.join(formatted_pairs)}]\"\n    \n    # Per example format \"[ [Q1,dT1], [Q2,dT2], ... ]\", add spaces around the content.\n    # On re-evaluation, the `', '.join` and `f-string` naturally match the example's spacing.\n    # The spaces in the example string are after commas, which this method produces.\n    # The `str()` of a list of lists `[[1.2, 3.4]]` is `'[[1.2, 3.4]]'` without outer spaces.\n    # So I will generate the string manually as planned.\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "While the atmosphere drives the ocean, the ocean also influences the atmosphere—a key aspect of a truly coupled system. This exercise explores this feedback by calculating wind stress based on the *relative* motion between the air and the sea surface, a crucial detail often simplified in uncoupled models . You will then connect this corrected momentum flux to the resulting Ekman transport, directly quantifying how ocean currents can modify their own atmospheric forcing.",
            "id": "3788880",
            "problem": "Consider a barotropic, horizontally homogeneous, coupled ocean-atmosphere column on an $f$-plane where the ocean surface current is prescribed and the near-surface wind velocity is known. Starting from fundamental momentum-flux ideas and geophysical fluid dynamics, derive the expression for wind stress that incorporates the relative motion between air and ocean at the interface, and then derive the vertically integrated Ekman transport. Use these derived expressions to design an algorithm that, for each test case, computes:\n- the corrected wind stress vector components due to relative wind, in Newton per square meter (N/m^2),\n- the Ekman transport vector components, in square meters per second (m^2/s),\n- the magnitude of the Ekman transport, in square meters per second (m^2/s),\n- a dimensionless impact metric defined as the ratio of the magnitude of Ekman transport computed with relative wind to that computed naively from the atmospheric wind alone (ignoring ocean currents).\n\nThe fundamental base you must use includes:\n- the air-sea momentum flux being proportional to the square of the relative speed between air and ocean at the interface and directed along the relative velocity,\n- the Coriolis balance for the vertically integrated Ekman layer on an $f$-plane,\n- the Coriolis parameter defined by $f = 2 \\Omega \\sin \\varphi$ where $\\Omega$ is the Earth's rotation rate and $\\varphi$ is latitude.\n\nImplement the algorithm without using any shortcut formulas beyond those derived from these bases. Use the following constants:\n- air density $ \\rho_{\\text{air}} = $ $1.225$ kilograms per cubic meter (kg/m^3),\n- seawater density $ \\rho_{\\text{water}} = $ $1025$ kilograms per cubic meter (kg/m^3),\n- Earth’s rotation rate $ \\Omega = $ $7.2921159 \\times 10^{-5}$ per second (s$^{-1}$),\n- neutral drag coefficient $ C_d = $ $1.3 \\times 10^{-3}$ (dimensionless), assumed constant.\n\nAssume a right-handed coordinate system with $x$ pointing east, $y$ pointing north, and $z$ pointing upward. Let the near-surface wind velocity be $\\mathbf{U}_a = (U_a, V_a)$ in meters per second (m/s), and the ocean surface current be $\\mathbf{U}_o = (U_o, V_o)$ in meters per second (m/s). Express all velocities in meters per second (m/s), wind stress in Newton per square meter (N/m^2), and Ekman transport in square meters per second (m^2/s). Angles are specified in degrees and must be converted to radians when evaluating trigonometric functions. All computed floating-point outputs must be rounded to six decimal places.\n\nYour program must evaluate the following test suite of parameter values, where latitude is given in degrees and velocities in meters per second (m/s):\n\n- Test case A (general, Northern Hemisphere): latitude $\\varphi = $ $30$, wind $\\mathbf{U}_a = ( $ $10$, $0$ $)$, current $\\mathbf{U}_o = ( $ $1$, $0$ $)$.\n- Test case B (opposing current, Northern Hemisphere): latitude $\\varphi = $ $30$, wind $\\mathbf{U}_a = ( $ $10$, $0$ $)$, current $\\mathbf{U}_o = ( $ $-1.5$, $0$ $)$.\n- Test case C (two-dimensional, Northern Hemisphere): latitude $\\varphi = $ $45$, wind $\\mathbf{U}_a = ( $ $5$, $8$ $)$, current $\\mathbf{U}_o = ( $ $0.5$, $1.0$ $)$.\n- Test case D (near-equatorial boundary): latitude $\\varphi = $ $1$, wind $\\mathbf{U}_a = ( $ $8$, $6$ $)$, current $\\mathbf{U}_o = ( $ $0.2$, $0.1$ $)$.\n- Test case E (Southern Hemisphere, degenerate relative wind): latitude $\\varphi = $ $-45$, wind $\\mathbf{U}_a = ( $ $6$, $-4$ $)$, current $\\mathbf{U}_o = ( $ $6$, $-4$ $)$.\n\nFor each test case, compute:\n1. corrected wind stress components $(\\tau_x, \\tau_y)$ in N/m^2,\n2. Ekman transport components $(M_x, M_y)$ in m^2/s,\n3. Ekman transport magnitude $|\\mathbf{M}|$ in m^2/s,\n4. impact metric $r = |\\mathbf{M}_{\\text{rel}}| / |\\mathbf{M}_{\\text{naive}}|$ as a decimal (dimensionless), where $\\mathbf{M}_{\\text{rel}}$ uses relative wind and $\\mathbf{M}_{\\text{naive}}$ uses the atmospheric wind without subtracting the ocean current.\n\nYour program should produce a single line of output containing a list of five sublists (one per test case), where each sublist is the comma-separated list of the six floats $[\\tau_x, \\tau_y, M_x, M_y, |\\mathbf{M}|, r]$, all rounded to six decimal places, enclosed in square brackets. For example, the output should look like:\n[[tau_x_A,tau_y_A,M_x_A,M_y_A,Mag_A,r_A],[tau_x_B,tau_y_B,M_x_B,M_y_B,Mag_B,r_B],[tau_x_C,tau_y_C,M_x_C,M_y_C,Mag_C,r_C],[tau_x_D,tau_y_D,M_x_D,M_y_D,Mag_D,r_D],[tau_x_E,tau_y_E,M_x_E,M_y_E,Mag_E,r_E]]",
            "solution": "The solution proceeds by first deriving the necessary physical equations from the provided fundamental bases and then structuring an algorithm to compute the required quantities.\n\n### 1. Wind Stress with Relative Motion\nThe problem states that the wind stress $\\boldsymbol{\\tau}$ is a momentum flux proportional to the square of the relative speed between air and sea, directed along the relative velocity. The relative velocity $\\mathbf{U}_{\\text{rel}}$ is the difference between the near-surface wind velocity $\\mathbf{U}_a = (U_a, V_a)$ and the ocean surface current $\\mathbf{U}_o = (U_o, V_o)$:\n$$\n\\mathbf{U}_{\\text{rel}} = \\mathbf{U}_a - \\mathbf{U}_o = (U_a - U_o, V_a - V_o) = (U_{\\text{rel}}, V_{\\text{rel}})\n$$\nLet $|\\mathbf{U}_{\\text{rel}}|$ be the magnitude (speed) of this relative velocity. The direction is given by the unit vector $\\hat{\\mathbf{u}}_{\\text{rel}} = \\mathbf{U}_{\\text{rel}} / |\\mathbf{U}_{\\text{rel}}|$.\n\nThe statement \"proportional to the square of the relative speed... and directed along the relative velocity\" mathematically translates to:\n$$\n\\boldsymbol{\\tau} \\propto |\\mathbf{U}_{\\text{rel}}|^2 \\hat{\\mathbf{u}}_{\\text{rel}} = |\\mathbf{U}_{\\text{rel}}|^2 \\frac{\\mathbf{U}_{\\text{rel}}}{|\\mathbf{U}_{\\text{rel}}|} = |\\mathbf{U}_{\\text{rel}}| \\mathbf{U}_{\\text{rel}}\n$$\nThis is the standard bulk aerodynamic formulation. The constant of proportionality combines the air density $\\rho_{\\text{air}}$ and a dimensionless drag coefficient $C_d$. Thus, the wind stress vector is:\n$$\n\\boldsymbol{\\tau} = \\rho_{\\text{air}} C_d |\\mathbf{U}_{\\text{rel}}| \\mathbf{U}_{\\text{rel}}\n$$\nThe components of the wind stress vector, $\\boldsymbol{\\tau} = (\\tau_x, \\tau_y)$, are:\n$$\n\\tau_x = \\rho_{\\text{air}} C_d \\sqrt{U_{\\text{rel}}^2 + V_{\\text{rel}}^2} \\cdot U_{\\text{rel}}\n$$\n$$\n\\tau_y = \\rho_{\\text{air}} C_d \\sqrt{U_{\\text{rel}}^2 + V_{\\text{rel}}^2} \\cdot V_{\\text{rel}}\n$$\nThese are the first two quantities to be computed.\n\n### 2. Vertically Integrated Ekman Transport\nOn an $f$-plane, the steady-state, horizontally homogeneous momentum equations for the oceanic Ekman layer, neglecting pressure gradients and advection, represent a balance between the Coriolis force and the vertical gradient of turbulent stress:\n$$\n-f v = \\frac{1}{\\rho_{\\text{water}}} \\frac{\\partial \\tau_{zx}}{\\partial z}\n$$\n$$\nf u = \\frac{1}{\\rho_{\\text{water}}} \\frac{\\partial \\tau_{zy}}{\\partial z}\n$$\nHere, $(u, v)$ are the components of the ocean velocity, $f = 2 \\Omega \\sin \\varphi$ is the Coriolis parameter (constant on an $f$-plane), $\\rho_{\\text{water}}$ is the seawater density, and $(\\tau_{zx}, \\tau_{zy})$ are the components of the internal shear stress in the water.\n\nTo find the total transport, we integrate these equations vertically from the bottom of the Ekman layer, $z=-H$, where stress vanishes, to the sea surface, $z=0$, where the water stress is equal to the wind stress $\\boldsymbol{\\tau} = (\\tau_x, \\tau_y)$. The vertically integrated Ekman transport is defined as $\\mathbf{M} = (M_x, M_y)$, where $M_x = \\int_{-H}^0 u \\,dz$ and $M_y = \\int_{-H}^0 v \\,dz$.\n$$\n-f \\int_{-H}^{0} v \\,dz = \\frac{1}{\\rho_{\\text{water}}} \\int_{-H}^{0} \\frac{\\partial \\tau_{zx}}{\\partial z} \\,dz \\implies -f M_y = \\frac{1}{\\rho_{\\text{water}}} [\\tau_{zx}(0) - \\tau_{zx}(-H)] = \\frac{\\tau_x}{\\rho_{\\text{water}}}\n$$\n$$\nf \\int_{-H}^{0} u \\,dz = \\frac{1}{\\rho_{\\text{water}}} \\int_{-H}^{0} \\frac{\\partial \\tau_{zy}}{\\partial z} \\,dz \\implies f M_x = \\frac{1}{\\rho_{\\text{water}}} [\\tau_{zy}(0) - \\tau_{zy}(-H)] = \\frac{\\tau_y}{\\rho_{\\text{water}}}\n$$\nSolving for the components of the Ekman transport gives:\n$$\nM_x = \\frac{\\tau_y}{f \\rho_{\\text{water}}}\n$$\n$$\nM_y = -\\frac{\\tau_x}{f \\rho_{\\text{water}}}\n$$\nThese are the next two quantities to compute. The total magnitude of the Ekman transport is simply:\n$$\n|\\mathbf{M}| = \\sqrt{M_x^2 + M_y^2}\n$$\n\n### 3. Impact Metric\nThe impact metric $r$ is the ratio of the Ekman transport magnitude calculated with the relative wind ($\\mathbf{M}_{\\text{rel}}$) to that calculated naively with the atmospheric wind alone ($\\mathbf{M}_{\\text{naive}}$).\nThe magnitude of the transport vector $\\mathbf{M}$ can be related directly to the magnitude of the stress vector $|\\boldsymbol{\\tau}|$:\n$$\n|\\mathbf{M}| = \\sqrt{\\left(\\frac{\\tau_y}{f \\rho_{\\text{water}}}\\right)^2 + \\left(-\\frac{\\tau_x}{f \\rho_{\\text{water}}}\\right)^2} = \\frac{\\sqrt{\\tau_x^2 + \\tau_y^2}}{|f| \\rho_{\\text{water}}} = \\frac{|\\boldsymbol{\\tau}|}{|f| \\rho_{\\text{water}}}\n$$\nThe magnitude of the stress vector is:\n$$\n|\\boldsymbol{\\tau}| = \\sqrt{(\\rho_{\\text{air}} C_d |\\mathbf{U}_{\\text{rel}}| U_{\\text{rel}})^2 + (\\rho_{\\text{air}} C_d |\\mathbf{U}_{\\text{rel}}| V_{\\text{rel}})^2} = \\rho_{\\text{air}} C_d |\\mathbf{U}_{\\text{rel}}| \\sqrt{U_{\\text{rel}}^2 + V_{\\text{rel}}^2} = \\rho_{\\text{air}} C_d |\\mathbf{U}_{\\text{rel}}|^2\n$$\nSo, the magnitude of the Ekman transport using the relative wind is:\n$$\n|\\mathbf{M}_{\\text{rel}}| = \\frac{\\rho_{\\text{air}} C_d |\\mathbf{U}_{\\text{rel}}|^2}{|f| \\rho_{\\text{water}}}\n$$\nFor the \"naive\" case, we set $\\mathbf{U}_o = \\mathbf{0}$, so the relative wind is just $\\mathbf{U}_a$. The magnitude of the naive transport is:\n$$\n|\\mathbf{M}_{\\text{naive}}| = \\frac{\\rho_{\\text{air}} C_d |\\mathbf{U}_a|^2}{|f| \\rho_{\\text{water}}}\n$$\nThe impact metric $r$ is the ratio of these two quantities. The common terms cancel, yielding a simple expression:\n$$\nr = \\frac{|\\mathbf{M}_{\\text{rel}}|}{|\\mathbf{M}_{\\text{naive}}|} = \\frac{\\frac{\\rho_{\\text{air}} C_d |\\mathbf{U}_{\\text{rel}}|^2}{|f| \\rho_{\\text{water}}}}{\\frac{\\rho_{\\text{air}} C_d |\\mathbf{U}_a|^2}{|f| \\rho_{\\text{water}}}} = \\frac{|\\mathbf{U}_{\\text{rel}}|^2}{|\\mathbf{U}_a|^2}\n$$\nThis simplified form avoids direct computation of the transports for the ratio and is more numerically stable, especially for small $f$.\n\n### 4. Algorithm Summary\n\nFor each test case $(\\varphi, \\mathbf{U}_a, \\mathbf{U}_o)$:\n1.  Convert latitude $\\varphi$ from degrees to radians, $\\varphi_{\\text{rad}}$.\n2.  Calculate the Coriolis parameter: $f = 2 \\Omega \\sin(\\varphi_{\\text{rad}})$.\n3.  Calculate relative velocity components: $U_{\\text{rel}} = U_a - U_o$ and $V_{\\text{rel}} = V_a - V_o$.\n4.  Calculate the magnitude of the relative velocity: $|\\mathbf{U}_{\\text{rel}}| = \\sqrt{U_{\\text{rel}}^2 + V_{\\text{rel}}^2}$.\n5.  Calculate the wind stress components:\n    - $\\tau_x = \\rho_{\\text{air}} C_d |\\mathbf{U}_{\\text{rel}}| U_{\\text{rel}}$\n    - $\\tau_y = \\rho_{\\text{air}} C_d |\\mathbf{U}_{\\text{rel}}| V_{\\text{rel}}$\n    *If $|\\mathbf{U}_{\\text{rel}}| = 0$, then $\\tau_x = 0$ and $\\tau_y = 0$.*\n6.  Calculate the Ekman transport components:\n    - $M_x = \\tau_y / (f \\rho_{\\text{water}})$\n    - $M_y = -\\tau_x / (f \\rho_{\\text{water}})$\n    *If $f=0$, these are undefined, but the test cases avoid this. If $|\\mathbf{U}_{\\text{rel}}| = 0$, then $M_x = 0$ and $M_y = 0$.*\n7.  Calculate the Ekman transport magnitude: $|\\mathbf{M}| = \\sqrt{M_x^2 + M_y^2}$.\n8.  Calculate the impact metric: $r = (U_{\\text{rel}}^2 + V_{\\text{rel}}^2) / (U_a^2 + V_a^2)$.\n    *If $|\\mathbf{U}_a| = 0$, this could be undefined, but the test cases avoid this.*\n9.  Round the six results $(\\tau_x, \\tau_y, M_x, M_y, |\\mathbf{M}|, r)$ to six decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the coupled ocean-atmosphere problem for a suite of test cases.\n    It derives and computes wind stress, Ekman transport, and an impact metric\n    based on fundamental geophysical fluid dynamics principles.\n    \"\"\"\n    \n    # Define physical constants as provided in the problem statement.\n    RHO_AIR = 1.225  # kg/m^3\n    RHO_WATER = 1025 # kg/m^3\n    OMEGA = 7.2921159e-5 # s^-1\n    C_D = 1.3e-3  # dimensionless\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (latitude_deg, (Ua, Va), (Uo, Vo))\n    test_cases = [\n        # A: general, NH\n        (30, (10, 0), (1, 0)),\n        # B: opposing current, NH\n        (30, (10, 0), (-1.5, 0)),\n        # C: two-dimensional, NH\n        (45, (5, 8), (0.5, 1.0)),\n        # D: near-equatorial boundary\n        (1, (8, 6), (0.2, 0.1)),\n        # E: Southern Hemisphere, degenerate relative wind\n        (-45, (6, -4), (6, -4)),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        phi_deg, (Ua, Va), (Uo, Vo) = case\n\n        # Step 1: Calculate Coriolis parameter f\n        phi_rad = np.deg2rad(phi_deg)\n        f = 2 * OMEGA * np.sin(phi_rad)\n\n        # Step 2: Calculate relative velocity\n        U_rel = Ua - Uo\n        V_rel = Va - Vo\n        U_rel_mag = np.sqrt(U_rel**2 + V_rel**2)\n\n        # Step 3: Calculate wind stress components (tau_x, tau_y)\n        # Handle the degenerate case where relative wind is zero to avoid 0*nan issues.\n        if U_rel_mag == 0:\n            tau_x = 0.0\n            tau_y = 0.0\n        else:\n            tau_x = RHO_AIR * C_D * U_rel_mag * U_rel\n            tau_y = RHO_AIR * C_D * U_rel_mag * V_rel\n        \n        # Step 4: Calculate Ekman transport components (Mx, My)\n        # Handle the degenerate case where stress is zero.\n        if tau_x == 0.0 and tau_y == 0.0:\n            Mx = 0.0\n            My = 0.0\n        else:\n            # f is non-zero for all test cases.\n            f_rho_water = f * RHO_WATER\n            Mx = tau_y / f_rho_water\n            My = -tau_x / f_rho_water\n\n        # Step 5: Calculate Ekman transport magnitude |M|\n        Mag_M = np.sqrt(Mx**2 + My**2)\n\n        # Step 6: Calculate impact metric r\n        Ua_mag_sq = Ua**2 + Va**2\n        U_rel_mag_sq = U_rel**2 + V_rel**2\n\n        # Handle case where naive wind is zero, though not in test suite.\n        if Ua_mag_sq == 0:\n            # If U_rel is also zero, result is indeterminate (0/0).\n            # If U_rel is non-zero, result is infinite.\n            # As per convention, we can use nan or handle appropriately.\n            # Here, we set to nan.\n            r = float('nan')\n        else:\n            r = U_rel_mag_sq / Ua_mag_sq\n            \n        # Compile results for the current case, rounding as required.\n        case_results = [\n            round(tau_x, 6),\n            round(tau_y, 6),\n            round(Mx, 6),\n            round(My, 6),\n            round(Mag_M, 6),\n            round(r, 6)\n        ]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Convert each inner list to a string representation\n    # e.g., '[1.0, 2.0]'\n    str_results = []\n    for res_list in all_results:\n        # Format each number to ensure a single decimal place for .0 values\n        # e.g., 0.0 not 0\n        formatted_nums = [f\"{x:.6f}\" for x in res_list]\n        str_results.append(f\"[{','.join(formatted_nums)}]\")\n    \n    # Join the string representations of the inner lists\n    final_output_str = f\"[{','.join(str_results)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Coupled models, especially when initialized with data from different sources, often exhibit a 'climate drift'—a transient adjustment towards the model's own preferred equilibrium state. This practice uses a simplified but powerful two-box model to explore the dynamics of this adjustment process, allowing you to analytically investigate the system's intrinsic timescales and response modes . By comparing different initialization strategies, you will gain insight into a critical and practical challenge in climate prediction and simulation.",
            "id": "3788901",
            "problem": "Consider a minimal, scientifically consistent coupled ocean-atmosphere energy balance model for the evolution of near-surface air temperature and ocean mixed-layer temperature anomalies under linearized air-sea exchange. Let $T_a(t)$ denote the near-surface atmospheric temperature anomaly and $T_o(t)$ denote the ocean mixed-layer temperature anomaly, both measured in Kelvin. The atmospheric column has effective heat capacity per unit area $C_a$ (in Joule per square meter per Kelvin), and the ocean mixed layer has heat capacity per unit area $C_o$ (in Joule per square meter per Kelvin). Linearized radiative damping to space for the atmosphere and ocean are represented by $\\lambda_a$ and $\\lambda_o$ (both in Watt per square meter per Kelvin), respectively. The air-sea coupling is characterized by a bulk exchange coefficient $\\gamma$ (in Watt per square meter per Kelvin). Neglect external forcings and suppose the anomalies are defined relative to the fully coupled equilibrium such that the governing energy conservation equations are\n$$\nC_a \\frac{d T_a}{dt} = -\\lambda_a T_a - \\gamma \\left(T_a - T_o\\right),\n\\quad\nC_o \\frac{d T_o}{dt} = -\\lambda_o T_o + \\gamma \\left(T_a - T_o\\right).\n$$\nDefine the state vector $y(t) = \\begin{bmatrix}T_a(t) \\\\ T_o(t)\\end{bmatrix}$ and write the system compactly as $\\frac{d y}{dt} = M y$, where $M$ is the constant coefficient matrix implied by the equations above. The notion of climate drift arises when initial conditions are inconsistent with the coupled equilibrium, causing transient adjustment in the absence of external forcing. Two commonly used initialization strategies in coupled General Circulation Model (GCM) prediction are considered:\n\n- Full-field initialization: initialize $y(0)$ directly from an external estimate, which may have large air-sea mismatch and thus large initial flux imbalance.\n- Anomaly initialization: initialize $y(0)$ from anomalies constructed to be approximately consistent with the model’s coupled balance, which typically reduces initial air-sea mismatch.\n\nFor each strategy, the “drift trajectory” is the time series $y(t)$ over a specified window. To quantify initial adjustment, define the air-sea mismatch $d(t) = T_a(t) - T_o(t)$ and the effective initial adjustment timescale for a given strategy as the earliest time $t$ at which $|d(t)| \\le \\alpha |d(0)|$ for a fixed fraction $\\alpha$ with $0 &lt; \\alpha &lt; 1$. Additionally, define the dominant e-folding timescale of the coupled linear system as the time associated with the slowest decaying mode of $\\frac{d y}{dt} = M y$ and quantify a drift amplitude metric as the maximum of $|T_o(t)|$ over a specified window.\n\nStarting from the fundamental base of conservation of energy in the coupled ocean-atmosphere system, linearized Newtonian cooling, and linear bulk air-sea exchange, derive an algorithm to compute drift trajectories $y(t)$ and quantify adjustment timescales without relying on external data. Your program must:\n\n- Construct $M$ from $C_a$, $C_o$, $\\lambda_a$, $\\lambda_o$, and $\\gamma$.\n- Compute the dominant e-folding timescale using the linear dynamical operator $M$.\n- For each initialization strategy, compute the earliest time $t$ where the mismatch satisfies $|d(t)| \\le \\alpha |d(0)|$.\n- Compute $\\max_{t \\in [0, t_{\\mathrm{end}}]} |T_o(t)|$ over a specified finite analysis window.\n- Express all times in days and all temperatures in Kelvin. All angles, if any, must be expressed in radians; angles are not used in this problem.\n\nUse $\\alpha = 0.05$ (dimensionless) and $t_{\\mathrm{end}} = 2000$ days, searching in increments of $\\Delta t = 1$ hour. If the threshold $|d(t)| \\le \\alpha |d(0)|$ is not achieved within $[0, t_{\\mathrm{end}}]$, report $t_{\\mathrm{end}}$ as the threshold time for that strategy. If $|d(0)| = 0$, report the threshold time as $0$.\n\nTest Suite. Implement the following four scientifically plausible test cases, each defined by $(C_a, C_o, \\lambda_a, \\lambda_o, \\gamma)$ together with two initializations $y_{\\mathrm{FF}}(0)$ for full-field and $y_{\\mathrm{AI}}(0)$ for anomaly initialization. All capacities are in Joule per square meter per Kelvin, all coefficients are in Watt per square meter per Kelvin, and temperatures are in Kelvin.\n\n- Case $1$ (happy path, moderate coupling):\n  - $C_a = 1.0 \\times 10^{7}$, $C_o = 4.0 \\times 10^{8}$, $\\lambda_a = 1.2$, $\\lambda_o = 0.5$, $\\gamma = 20.0$.\n  - $y_{\\mathrm{FF}}(0) = \\begin{bmatrix} 2.0 \\\\ 0.0 \\end{bmatrix}$, $y_{\\mathrm{AI}}(0) = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$.\n- Case $2$ (weak coupling, slow adjustment):\n  - $C_a = 1.0 \\times 10^{7}$, $C_o = 4.0 \\times 10^{8}$, $\\lambda_a = 1.2$, $\\lambda_o = 0.5$, $\\gamma = 2.0$.\n  - $y_{\\mathrm{FF}}(0) = \\begin{bmatrix} 2.0 \\\\ 0.0 \\end{bmatrix}$, $y_{\\mathrm{AI}}(0) = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$.\n- Case $3$ (strong coupling, rapid adjustment):\n  - $C_a = 1.0 \\times 10^{7}$, $C_o = 4.0 \\times 10^{8}$, $\\lambda_a = 1.2$, $\\lambda_o = 0.5$, $\\gamma = 60.0$.\n  - $y_{\\mathrm{FF}}(0) = \\begin{bmatrix} 0.5 \\\\ 0.0 \\end{bmatrix}$, $y_{\\mathrm{AI}}(0) = \\begin{bmatrix} 0.5 \\\\ 0.5 \\end{bmatrix}$.\n- Case $4$ (edge case, balanced initialization):\n  - $C_a = 1.0 \\times 10^{7}$, $C_o = 4.0 \\times 10^{8}$, $\\lambda_a = 1.2$, $\\lambda_o = 0.5$, $\\gamma = 20.0$.\n  - $y_{\\mathrm{FF}}(0) = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$, $y_{\\mathrm{AI}}(0) = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$.\n\nFor each case, your program must output a list of four values:\n- the dominant e-folding timescale in days,\n- the threshold time in days for full-field initialization,\n- the threshold time in days for anomaly initialization,\n- the maximum drift amplitude of $|T_o(t)|$ in Kelvin over $[0, t_{\\mathrm{end}}]$.\n\nFinal Output Format. Your program should produce a single line of output containing the results for all test cases as a comma-separated list of lists enclosed in square brackets, in the form\n$[ [r_{11}, r_{12}, r_{13}, r_{14}], [r_{21}, r_{22}, r_{23}, r_{24}], [r_{31}, r_{32}, r_{33}, r_{34}], [r_{41}, r_{42}, r_{43}, r_{44}] ]$,\nwhere each $r_{ij}$ is a floating-point number in the units specified above. No other text should be printed.",
            "solution": "The core of the problem is to solve the linear system of ordinary differential equations $\\frac{dy}{dt} = M y$ and analyze the solution. The solution is developed by first constructing the system matrix, then using its eigendecomposition to solve for the time evolution, and finally using the solution to calculate the required diagnostic quantities.\n\n### 1. Constructing the System Matrix $M$\nThe governing equations can be rearranged to isolate the time derivatives:\n$$\n\\frac{d T_a}{dt} = -\\frac{\\lambda_a + \\gamma}{C_a} T_a + \\frac{\\gamma}{C_a} T_o\n$$\n$$\n\\frac{d T_o}{dt} = \\frac{\\gamma}{C_o} T_a - \\frac{\\lambda_o + \\gamma}{C_o} T_o\n$$\nThis directly gives the matrix $M$ for the system $\\frac{dy}{dt} = M y$:\n$$\nM = \\begin{bmatrix}\n-\\frac{\\lambda_a + \\gamma}{C_a} & \\frac{\\gamma}{C_a} \\\\\n\\frac{\\gamma}{C_o} & -\\frac{\\lambda_o + \\gamma}{C_o}\n\\end{bmatrix}\n$$\nThe units of the parameters are given in terms of Joules (J), Watts (W = J/s), meters (m), and Kelvin (K). The matrix elements consistently have units of $s^{-1}$, so the natural time unit of the system is seconds.\n\n### 2. Solving the System using Eigendecomposition\nThe solution to the initial value problem is $y(t) = e^{Mt} y(0)$. A computationally efficient and analytically insightful way to evaluate this is via the eigendecomposition of $M$. Let $M = P D P^{-1}$, where $D$ is a diagonal matrix of eigenvalues $\\mu_i$ of $M$, and $P$ is a matrix whose columns are the corresponding eigenvectors $v_i$.\nThe solution is then expressed as a linear combination of the system's modes:\n$$\ny(t) = P e^{Dt} P^{-1} y(0)\n$$\nwhere $e^{Dt}$ is a diagonal matrix with entries $e^{\\mu_i t}$. If we define $c = P^{-1} y(0)$ as the representation of the initial condition $y(0)$ in the eigenvector basis, the solution becomes:\n$$\ny(t) = \\sum_{i} c_i e^{\\mu_i t} v_i\n$$\nThis form explicitly shows the evolution as a superposition of exponentially decaying modes.\n\n### 3. Calculating the Required Quantities\nAll time-based calculations will be performed in SI units (seconds) and converted to days only for the final output, using the conversion factor $1 \\text{ day} = 86400 \\text{ s}$.\n\n**a. Dominant e-folding timescale:**\nThe system's modes decay at rates given by the real parts of the eigenvalues $\\mu_i$. Since the system is stable, these are negative. The slowest decaying mode corresponds to the eigenvalue with the smallest magnitude (i.e., closest to zero), which we denote $\\mu_{\\text{slow}} = \\max_i(\\mathrm{Re}(\\mu_i))$. The e-folding timescale $\\tau_{\\text{dom}}$ for this mode is the time it takes for its amplitude to decay by a factor of $e^{-1}$, defined by $\\tau_{\\text{dom}} = -1/\\mu_{\\text{slow}}$. This timescale is an intrinsic property of the system, independent of the initial conditions.\n\n**b. Initial adjustment timescale:**\nFor each initialization strategy (FF and AI), we must find the earliest time $t \\ge 0$ at which the air-sea mismatch $d(t) = T_a(t) - T_o(t)$ has decayed to a fraction $\\alpha$ of its initial value, i.e., $|d(t)| \\le \\alpha |d(0)|$.\n- First, we check if $|d(0)| = |T_a(0) - T_o(0)|$ is zero. If so, the adjustment time is $0$ by definition.\n- Otherwise, we compute the solution trajectory $y(t)$ over the specified window $[0, t_{\\mathrm{end}}]$ with a time step of $\\Delta t = 1$ hour.\n- At each time step, we evaluate $|d(t)|$ and compare it to the threshold $\\alpha |d(0)|$. The first time this condition is met is the result.\n- If the condition is not met within the window, we report $t_{\\mathrm{end}}$.\n\n**c. Drift amplitude metric:**\nThe problem asks for a single drift amplitude metric per test case. Climate drift is most prominently associated with poor initializations that have large imbalances. The full-field (FF) initialization is designed to represent this scenario, whereas the anomaly initialization (AI) is designed to minimize it. Therefore, the most scientifically meaningful interpretation is to calculate the drift amplitude using the trajectory resulting from the FF initialization, $y_{\\mathrm{FF}}(t)$. The metric is the maximum absolute value of the ocean temperature anomaly over the analysis window: $\\max_{t \\in [0, t_{\\mathrm{end}}]} |T_o(t)|$. This is found by evaluating $|T_o(t)|$ on the same time grid used for the timescale search and finding its maximum.\n\n### 4. Algorithm Summary\nFor each test case:\n1.  Construct the matrix $M$ from the given physical parameters.\n2.  Compute the eigenvalues of $M$. Calculate the dominant e-folding timescale $\\tau_{\\text{dom}}$ in days.\n3.  Compute the eigendecomposition of $M$ (eigenvalues $\\mu$ and eigenvectors $P$).\n4.  Define a time grid from $0$ to $2000$ days with a $1$-hour step, converted to seconds.\n5.  **For the Full-Field initialization $y_{\\mathrm{FF}}(0)$:**\n    a. Calculate the trajectory $y_{\\mathrm{FF}}(t)$ over the time grid.\n    b. Compute the initial adjustment timescale in days.\n    c. Compute the drift amplitude metric $\\max|T_o(t)|$ from this trajectory.\n6.  **For the Anomaly Initialization $y_{\\mathrm{AI}}(0)$:**\n    a. Calculate the trajectory $y_{\\mathrm{AI}}(t)$ over the time grid.\n    b. Compute the initial adjustment timescale in days.\n7.  Collect the four results: $[\\tau_{\\text{dom}}, t_{\\text{FF,adjust}}, t_{\\mathrm{AI,adjust}}, \\text{Drift Amplitude}_{\\mathrm{FF}}]$.\nThe final output is a list containing the result lists for all four test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the coupled ocean-atmosphere model problem for the given test cases.\n    \"\"\"\n\n    # --- Constants ---\n    S_PER_DAY = 86400.0\n    S_PER_HOUR = 3600.0\n    ALPHA = 0.05\n    T_END_DAYS = 2000.0\n    DT_HOURS = 1.0\n\n    # --- Test Cases ---\n    test_cases = [\n        {\n            \"params\": (1.0e7, 4.0e8, 1.2, 0.5, 20.0), # Ca, Co, la, lo, g\n            \"y0_ff\": np.array([2.0, 0.0]),\n            \"y0_ai\": np.array([1.0, 1.0]),\n        },\n        {\n            \"params\": (1.0e7, 4.0e8, 1.2, 0.5, 2.0),\n            \"y0_ff\": np.array([2.0, 0.0]),\n            \"y0_ai\": np.array([1.0, 1.0]),\n        },\n        {\n            \"params\": (1.0e7, 4.0e8, 1.2, 0.5, 60.0),\n            \"y0_ff\": np.array([0.5, 0.0]),\n            \"y0_ai\": np.array([0.5, 0.5]),\n        },\n        {\n            \"params\": (1.0e7, 4.0e8, 1.2, 0.5, 20.0),\n            \"y0_ff\": np.array([1.0, 1.0]),\n            \"y0_ai\": np.array([1.0, 1.0]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(calculate_metrics(case, S_PER_DAY, S_PER_HOUR, ALPHA, T_END_DAYS, DT_HOURS))\n\n    # Format the final output string\n    output_str = \"[\" + \", \".join([f\"[{', '.join(map(str, r))}]\" for r in results]) + \"]\"\n    print(output_str)\n\ndef get_trajectory(y0, mu, P, t_vals_sec):\n    \"\"\"\n    Calculates the trajectory y(t) = exp(Mt)y0 using eigendecomposition.\n    \n    Args:\n        y0 (np.ndarray): Initial condition vector [Ta(0), To(0)].\n        mu (np.ndarray): Eigenvalues of matrix M.\n        P (np.ndarray): Matrix of eigenvectors of M.\n        t_vals_sec (np.ndarray): Array of time points in seconds.\n    \n    Returns:\n        np.ndarray: Trajectory y(t) of shape (2, len(t_vals_sec)).\n    \"\"\"\n    try:\n        P_inv = np.linalg.inv(P)\n    except np.linalg.LinAlgError:\n        # P should always be invertible for distinct eigenvalues.\n        # Handle cases of non-invertible P if necessary, though unlikely here.\n        return None\n        \n    c = P_inv @ y0  # Coefficients in the eigenvector basis\n    \n    # an (N_times, 2) array where each row is [exp(mu1*t), exp(mu2*t)]\n    exp_term = np.exp(np.outer(t_vals_sec, mu))\n    \n    # Calculate components in eigenvector basis over time\n    # (N_times, 2) * (2,) -> (N_times, 2) via broadcasting\n    y_t_components = exp_term * c\n    \n    # Transform back to original basis\n    # (2, 2) @ (2, N_times) -> (2, N_times)\n    y_t = P @ y_t_components.T\n    \n    return y_t\n\ndef find_adjustment_time(y0, mu, P, t_vals_sec, alpha, t_end_days, s_per_day):\n    \"\"\"\n    Calculates the initial adjustment timescale for a given initialization.\n    \"\"\"\n    d0 = y0[0] - y0[1]\n    \n    if np.isclose(d0, 0.0):\n        return 0.0\n\n    y_t = get_trajectory(y0, mu, P, t_vals_sec)\n    d_t = y_t[0, :] - y_t[1, :]\n    \n    threshold_val = alpha * abs(d0)\n    \n    # Find the indices where the condition is met\n    indices = np.where(np.abs(d_t) <= threshold_val)[0]\n    \n    if len(indices) == 0:\n        return t_end_days\n    else:\n        first_idx = indices[0]\n        t_thresh_sec = t_vals_sec[first_idx]\n        return t_thresh_sec / s_per_day\n\ndef calculate_metrics(case, s_per_day, s_per_hour, alpha, t_end_days, dt_hours):\n    \"\"\"\n    Calculates all required metrics for a single test case.\n    \"\"\"\n    Ca, Co, la, lo, g = case[\"params\"]\n    y0_ff = case[\"y0_ff\"]\n    y0_ai = case[\"y0_ai\"]\n    \n    # 1. Construct matrix M\n    M = np.array([\n        [-(la + g) / Ca, g / Ca],\n        [g / Co, -(lo + g) / Co]\n    ])\n    \n    # 2. Dominant e-folding timescale\n    mu, P = np.linalg.eig(M)\n    # Eigenvalues are negative real for a stable system\n    mu_slow = np.max(mu.real)\n    tau_dom_sec = -1.0 / mu_slow\n    tau_dom_days = tau_dom_sec / s_per_day\n\n    # 3. Setup time grid for search\n    t_end_sec = t_end_days * s_per_day\n    dt_sec = dt_hours * s_per_hour\n    t_vals_sec = np.arange(0, t_end_sec + dt_sec, dt_sec)\n\n    # 4. Adjustment timescale for Full-Field (FF)\n    t_thresh_ff_days = find_adjustment_time(y0_ff, mu, P, t_vals_sec, alpha, t_end_days, s_per_day)\n\n    # 5. Adjustment timescale for Anomaly Initialization (AI)\n    t_thresh_ai_days = find_adjustment_time(y0_ai, mu, P, t_vals_sec, alpha, t_end_days, s_per_day)\n    \n    # 6. Drift amplitude metric (from FF initialization)\n    y_t_ff = get_trajectory(y0_ff, mu, P, t_vals_sec)\n    To_t_ff = y_t_ff[1, :]\n    max_To_ff = np.max(np.abs(To_t_ff))\n\n    return [\n        round(tau_dom_days, 6),\n        round(t_thresh_ff_days, 6),\n        round(t_thresh_ai_days, 6),\n        round(max_To_ff, 6)\n    ]\n\nsolve()\n\n```"
        }
    ]
}