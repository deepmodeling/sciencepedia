{
    "hands_on_practices": [
        {
            "introduction": "在我们深入研究复杂的数值算法之前，通过一个解析练习来建立对模型敏感性的直观理解是至关重要的。这个练习将探讨一个基本问题：高程基准的微小偏移如何影响我们对海岸线位置的预测。通过在一个简化的、假设的线性海滩上推导一个简单的数学关系，您将量化这种误差的传递，从而深刻理解精确测深数据在潮间带建模中的关键作用。",
            "id": "3819214",
            "problem": "一个潮间带海滩由一个一维沿坡剖面表示，其水平坐标 $x$ 指向坡下（向海）。相对于真实垂直基准面的床面高程是线性的，$z_{b}(x) = z_{0} - s\\,x$，其中 $z_{0}$ 是一个常数，$s>0$ 是（正的）床面坡度大小。在静水浅水条件下，自由水面高程 $\\eta$ 在空间上是均匀且准稳态的。在一个垂向平均海岸模型的干湿过程中，位于 $x$ 处的计算单元被分类为湿单元，如果根据工作垂直基准面计算出的水柱厚度 $h(x)$ 满足 $h(x) \\ge h_{c}$，其中 $h_{c} \\ge 0$ 是一个固定的淹没阈值。\n\n假设模型的床面工作垂直基准面存在一个恒定的偏移量 $\\Delta z$（当床面被解释为更高时，该值为正）。因此，模型使用错误指定的床面 $z_{b}^{\\Delta}(x) = z_{b}(x) + \\Delta z$ 来计算用于分类的水柱厚度 $h^{\\Delta}(x)$。将“岸线”定义为相应的水柱厚度等于阈值的点的轨迹，即对于真实岸线有 $h(x_{\\text{true}})=h_{c}$，对于由有偏差的基准面产生的岸线有 $h^{\\Delta}(x_{\\Delta})=h_{c}$。\n\n仅从水柱厚度、床面几何形状和淹没阈值的定义出发，推导岸线位移 $\\Delta x = x_{\\Delta} - x_{\\text{true}}$ 作为 $s$ 和 $\\Delta z$ 的函数的闭式解析表达式。你的最终答案必须是一个单一的符号表达式。",
            "solution": "该问题是有效的，因为它具有科学依据、提法明确且客观。它为一个计算海岸模型中的标准问题提供了一个自洽且一致的设定。因此，我们可以进行推导。\n\n水柱厚度 $h$ 的基本定义是自由水面高程 $\\eta$ 与床面高程 $z_b$ 之差。\n$$h(x) = \\eta - z_b(x)$$\n这个定义适用于真实情况和有偏差的情况。自由水面高程 $\\eta$ 是一个固定的绝对量，床面高程是相对于它来测量的。\n\n首先，我们考虑真实情况。真实的床面高程由以下线性函数给出：\n$$z_b(x) = z_0 - s\\,x$$\n其中 $z_0$ 是一个常数高程，$s > 0$ 是恒定的床面坡度。相应的真实水柱厚度 $h(x)$ 为：\n$$h(x) = \\eta - z_b(x) = \\eta - (z_0 - s\\,x) = \\eta - z_0 + s\\,x$$\n真实岸线 $x_{\\text{true}}$ 被定义为水深等于淹没阈值 $h_c$ 的位置。因此，我们设 $h(x_{\\text{true}}) = h_c$：\n$$\\eta - z_0 + s\\,x_{\\text{true}} = h_c$$\n求解 $x_{\\text{true}}$ 得：\n$$s\\,x_{\\text{true}} = h_c - \\eta + z_0$$\n$$x_{\\text{true}} = \\frac{h_c - \\eta + z_0}{s}$$\n\n接下来，我们考虑带有偏差垂直基准面的情况。模型使用一个错误指定的床面高程 $z_b^{\\Delta}(x)$，它与真实床面高程相差一个常数偏移量 $\\Delta z$：\n$$z_b^{\\Delta}(x) = z_b(x) + \\Delta z = (z_0 - s\\,x) + \\Delta z$$\n模型计算出的水柱厚度 $h^{\\Delta}(x)$ 是不变的自由水面高程 $\\eta$ 与有偏差的床面高程 $z_b^{\\Delta}(x)$ 之差：\n$$h^{\\Delta}(x) = \\eta - z_b^{\\Delta}(x) = \\eta - (z_0 - s\\,x + \\Delta z) = \\eta - z_0 + s\\,x - \\Delta z$$\n由有偏差的基准面产生的岸线 $x_{\\Delta}$ 被定义为这个有偏差的水深等于同一个淹没阈值 $h_c$ 的位置。我们设 $h^{\\Delta}(x_{\\Delta}) = h_c$：\n$$\\eta - z_0 + s\\,x_{\\Delta} - \\Delta z = h_c$$\n求解 $x_{\\Delta}$ 得：\n$$s\\,x_{\\Delta} = h_c - \\eta + z_0 + \\Delta z$$\n$$x_{\\Delta} = \\frac{h_c - \\eta + z_0 + \\Delta z}{s}$$\n\n最后，我们需要求出岸线位移 $\\Delta x$，它被定义为有偏差的岸线位置与真实岸线位置之差：\n$$\\Delta x = x_{\\Delta} - x_{\\text{true}}$$\n代入我们为 $x_{\\Delta}$ 和 $x_{\\text{true}}$ 推导出的表达式：\n$$\\Delta x = \\left(\\frac{h_c - \\eta + z_0 + \\Delta z}{s}\\right) - \\left(\\frac{h_c - \\eta + z_0}{s}\\right)$$\n我们可以将各项合并到共同分母 $s$ 上：\n$$\\Delta x = \\frac{(h_c - \\eta + z_0 + \\Delta z) - (h_c - \\eta + z_0)}{s}$$\n分子中的项 $h_c$、$\\eta$ 和 $z_0$ 相互抵消：\n$$\\Delta x = \\frac{h_c - \\eta + z_0 + \\Delta z - h_c + \\eta - z_0}{s}$$\n$$\\Delta x = \\frac{\\Delta z}{s}$$\n这个关于岸线位移 $\\Delta x$ 的闭式表达式仅是基准面偏移量 $\\Delta z$ 和床面坡度 $s$ 的函数，正如问题陈述所要求的那样。",
            "answer": "$$\\boxed{\\frac{\\Delta z}{s}}$$"
        },
        {
            "introduction": "当我们将连续的守恒定律离散化为有限体积格式时，可能会出现非物理的结果，例如负水深 $h \\lt 0$。这个练习通过一个具体的、基于假设数据的反例，揭示了一个标准的数值更新步骤在处理近干涸单元时如何失效。您将首先计算出这种数值崩溃，然后从第一性原理出发，推导并计算一个最小通量限制器，以恰好维持水深的非负性，这是确保润湿-干燥算法稳定性的核心技术。",
            "id": "3819236",
            "problem": "考虑一维浅水方程组 (SWE)，其描述了水深 $h(x,t)$ 和流量 $q(x,t) = h(x,t) u(x,t)$，其中 $u(x,t)$ 是垂向平均流速。质量守恒定律由 $h_{t} + (q)_{x} = 0$ 给出。在一个单元宽度为 $\\Delta x$ 的均匀网格上进行有限体积离散，第 $i$ 个单元在第 $n$ 个时间层的单元平均水深 $h_{i}^{n}$ 通过单元间通量 $F_{i-1/2}^{n}$ 和 $F_{i+1/2}^{n}$ 进行显式更新，其公式如下：\n$$\nh_{i}^{n+1} = h_{i}^{n} - \\frac{\\Delta t}{\\Delta x} \\left(F_{i+1/2}^{n} - F_{i-1/2}^{n}\\right),\n$$\n其中 $F_{j+1/2}^{n}$ 是由黎曼求解器产生的对 $q(x_{j+1/2}, t^{n})$ 的近似。在用于潮间带的干湿交替算法中，通常需要一种保正机制来防止当单元接近干涸时出现 $h_{i}^{n+1}  0$ 的情况。\n\n构造一个反例，证明缺乏保正控制会导致负水深和数值爆炸，然后计算为防止计算失败所需的最小限制器干预。对一个潮间带断面使用以下科学上真实的设置：\n\n- 单元宽度 $\\Delta x = 20\\ \\mathrm{m}$，时间步长 $\\Delta t = 6\\ \\mathrm{s}$，这与特征速度为几 $\\mathrm{m}\\ \\mathrm{s}^{-1}$ 量级的 Courant–Friedrichs–Lewy (CFL) 稳定性限制条件一致。\n- 在时间层 $n$ 的单元平均水深为 $h_{i}^{n} = 0.02\\ \\mathrm{m}$（潮间带底床上的一层薄水膜）。\n- 在时间层 $n$ 的界面质量通量为 $F_{i+1/2}^{n} = 0.12\\ \\mathrm{m}^{2}\\ \\mathrm{s}^{-1}$ 和 $F_{i-1/2}^{n} = -0.08\\ \\mathrm{m}^{2}\\ \\mathrm{s}^{-1}$，分别对应于在右侧界面向右流出和在左侧界面向左流出（两个界面同时排空这个接近干涸的单元）。\n\n任务：\n\n1. 从质量守恒定律和上述有限体积更新公式出发，计算不使用任何保正限制器时的 $h_{i}^{n+1}$，并证明其为负值。\n2. 定义一个保正通量限制器，该限制器仅通过一个系数 $\\theta \\in [0,1]$ 来缩放离开单元的向外质量通量，而保持任何进入的通量不变。从第一性原理和离散更新公式出发，推导出在此步中使 $h_{i}^{n+1} = 0$ 的最小 $\\theta$（这是防止计算失败的最小干预）。\n3. 根据给定数据，计算该最小限制器系数的数值。将最终答案表示为一个纯数（无量纲）。如果选择近似，将答案四舍五入到四位有效数字。\n\n你的最终答案必须是在给定条件下防止 $h_{i}^{n+1}$ 变为负值的最小限制器系数 $\\theta$ 的单个值。",
            "solution": "该问题要求分析一个用于浅水方程组的有限体积数值格式，特别关注对干湿交替模拟至关重要的保正性质。我们已知离散质量守恒定律和一组会导致非物理负水深的参数。我们必须证明这种失效，然后推导并计算一个通量限制器修正。\n\n控制单元平均水深 $h_{i}^{n}$ 更新的有限体积公式如下：\n$$\nh_{i}^{n+1} = h_{i}^{n} - \\frac{\\Delta t}{\\Delta x} \\left(F_{i+1/2}^{n} - F_{i-1/2}^{n}\\right)\n$$\n提供的参数如下：\n- 在时间层 $n$ 的单元平均水深：$h_{i}^{n} = 0.02\\ \\mathrm{m}$\n- 单元宽度：$\\Delta x = 20\\ \\mathrm{m}$\n- 时间步长：$\\Delta t = 6\\ \\mathrm{s}$\n- 右侧单元界面 $(i+1/2)$ 的通量：$F_{i+1/2}^{n} = 0.12\\ \\mathrm{m}^{2}\\ \\mathrm{s}^{-1}$\n- 左侧单元界面 $(i-1/2)$ 的通量：$F_{i-1/2}^{n} = -0.08\\ \\mathrm{m}^{2}\\ \\mathrm{s}^{-1}$\n\n在有限体积框架中，通量的符号约定是：单元 $i$ 右侧界面 ($i+1/2$) 的正通量代表流出，而左侧界面 ($i-1/2$) 的负通量也代表流出。在本例中，$F_{i+1/2}^{n}  0$ 且 $F_{i-1/2}^{n}  0$，这意味着水正通过两个界面从单元 $i$ 中流出。\n\n**任务1：证明不使用限制器时的负水深**\n\n我们使用给定的公式和参数，不加任何修改地计算更新后的水深 $h_{i}^{n+1}$。\n$$\nh_{i}^{n+1} = h_{i}^{n} - \\frac{\\Delta t}{\\Delta x} \\left(F_{i+1/2}^{n} - F_{i-1/2}^{n}\\right)\n$$\n代入数值：\n$$\nh_{i}^{n+1} = 0.02 - \\frac{6}{20} \\left(0.12 - (-0.08)\\right)\n$$\n$$\nh_{i}^{n+1} = 0.02 - 0.3 \\left(0.12 + 0.08\\right)\n$$\n$$\nh_{i}^{n+1} = 0.02 - 0.3 \\left(0.20\\right)\n$$\n$$\nh_{i}^{n+1} = 0.02 - 0.06\n$$\n$$\nh_{i}^{n+1} = -0.04\\ \\mathrm{m}\n$$\n结果是负水深，这在物理上是无意义的，并表明数值格式失效。因此有必要进行保正修正。\n\n**任务2：推导最小通量限制器系数**\n\n引入一个保正限制器来防止水深变为负值。该限制器被定义为仅通过一个系数 $\\theta \\in [0, 1]$ 来缩放向外通量，而保持向内通量不变。\n\n让我们将净通量分解为总的流入和流出体积通量率。从单元 $i$ 流出的总体积通量率，记为 $Q_{out}$，是流经两个界面的流出量之和：\n$$\nQ_{out} = \\max(0, F_{i+1/2}^{n}) - \\min(0, F_{i-1/2}^{n})\n$$\n进入单元 $i$ 的总体积通量率，记为 $Q_{in}$，是：\n$$\nQ_{in} = \\max(0, F_{i-1/2}^{n}) - \\min(0, F_{i+1/2}^{n})\n$$\n有限体积更新方程可以用总水量 $V_i = h_i \\Delta x$ 改写为：\n$$\nV_{i}^{n+1} = V_{i}^{n} + \\Delta t (Q_{in} - Q_{out})\n$$\n除以 $\\Delta x$：\n$$\nh_{i}^{n+1} = h_{i}^{n} + \\frac{\\Delta t}{\\Delta x} (Q_{in} - Q_{out})\n$$\n限制器将总流出量 $Q_{out}$ 乘以 $\\theta$ 进行缩放：\n$$\nh_{i, \\text{limited}}^{n+1} = h_{i}^{n} + \\frac{\\Delta t}{\\Delta x} (Q_{in} - \\theta Q_{out})\n$$\n问题要求找到确保 $h_{i, \\text{limited}}^{n+1} = 0$ 的最小 $\\theta$。这代表了防止违反保正性的最小干预（即最大的 $\\theta \\leq 1$）。我们令 $h_{i, \\text{limited}}^{n+1} = 0$ 并求解 $\\theta$：\n$$\n0 = h_{i}^{n} + \\frac{\\Delta t}{\\Delta x} Q_{in} - \\theta \\frac{\\Delta t}{\\Delta x} Q_{out}\n$$\n重新整理以求解 $\\theta$：\n$$\n\\theta \\frac{\\Delta t}{\\Delta x} Q_{out} = h_{i}^{n} + \\frac{\\Delta t}{\\Delta x} Q_{in}\n$$\n假设 $Q_{out} \\neq 0$（在本问题中这是成立的，因为未修正的水深变为负值），我们得到：\n$$\n\\theta = \\frac{h_{i}^{n} + \\frac{\\Delta t}{\\Delta x} Q_{in}}{\\frac{\\Delta t}{\\Delta x} Q_{out}} = \\frac{h_{i}^{n} \\frac{\\Delta x}{\\Delta t} + Q_{in}}{Q_{out}}\n$$\n这是所需限制器系数的通用表达式。\n\n**任务3：计算 $\\theta$ 的数值**\n\n现在我们将此公式应用于给定数据。首先，我们计算 $Q_{in}$ 和 $Q_{out}$：\n$$\nF_{i+1/2}^{n} = 0.12  0 \\quad (\\text{流出})\n$$\n$$\nF_{i-1/2}^{n} = -0.08  0 \\quad (\\text{流出})\n$$\n因此，没有流入该单元的水：\n$$\nQ_{in} = \\max(0, -0.08) - \\min(0, 0.12) = 0 - 0 = 0\\ \\mathrm{m}^{2}\\ \\mathrm{s}^{-1}\n$$\n总流出量是：\n$$\nQ_{out} = \\max(0, 0.12) - \\min(0, -0.08) = 0.12 - (-0.08) = 0.20\\ \\mathrm{m}^{2}\\ \\mathrm{s}^{-1}\n$$\n当 $Q_{in} = 0$ 时，$\\theta$ 的公式简化为：\n$$\n\\theta = \\frac{h_{i}^{n} \\frac{\\Delta x}{\\Delta t}}{Q_{out}}\n$$\n这个方程有一个清晰的物理解释：允许的总流出体积 $\\theta Q_{out} \\Delta t$ 必须等于单元中初始存在的水量 $h_{i}^{n} \\Delta x$。\n\n代入数值：\n$$\n\\theta = \\frac{0.02 \\cdot \\frac{20}{6}}{0.20} = \\frac{0.02 \\cdot 20}{0.20 \\cdot 6} = \\frac{0.4}{1.2} = \\frac{4}{12}\n$$\n$$\n\\theta = \\frac{1}{3}\n$$\n为防止水深变为负值（通过将其精确地设置为零）所需的最小限制器系数是 $\\frac{1}{3}$。该值在要求的范围 $\\theta \\in [0, 1]$ 之内。",
            "answer": "$$\n\\boxed{\\frac{1}{3}}\n$$"
        },
        {
            "introduction": "数值算法中的参数选择，例如用于区分干湿单元的最小水深阈值 $h_{\\min}$，会对模型的宏观预测产生显著影响。这个实践项目要求您编写一个程序，以量化潮汐淹没范围对 $h_{\\min}$ 选择的敏感性。通过在多种假设的、但具有代表性的海底地形上模拟潮汐过程，您将学会如何设计和执行一个完整的数值实验，评估一个关键算法参数对模型整体行为的影响。",
            "id": "3819187",
            "problem": "您的任务是设计并实现一个程序，用于评估潮间带干湿算法中，淹没范围对最小有效水深选择的敏感性。其物理基础是由浅水方程 (SWE) 描述的静压自由表面流，而最小有效水深阈值用于在存在薄水层时稳定数值格式。该问题必须纯粹作为一个在已知水深地形上、根据给定的自由表面高程变化的几何量度问题来表述和求解，无需调用动量或质量守恒更新。\n\n基本基础：\n- 考虑一个水深地形，其床面高程 $z_b(x,y)$ 相对于一个垂直基准面测量，向上为正。\n- 考虑一个由正弦潮汐 $\\eta(t)=A\\sin(\\omega t)$ 给定的自由表面高程，其角频率为 $\\omega$（单位：弧度/秒），振幅为 $A$（单位：米）。\n- 瞬时水深为 $h(x,y,t)=\\eta(t)-z_b(x,y)$。\n- 标准的干湿算法将单元格分类为湿润，如果 $h(x,y,t)\\ge h_{\\min}$，其中 $h_{\\min}0$ 是最小有效水深阈值，用于避免因水层极薄而引起的数值问题。\n\n湿润面积和敏感性度量的定义：\n- 瞬时湿润面积为\n$$\nA_{\\text{wet}}(t;h_{\\min})=\\iint_{\\Omega} \\mathbf{1}\\!\\left(\\eta(t)-z_b(x,y)\\ge h_{\\min}\\right)\\,\\mathrm{d}x\\,\\mathrm{d}y,\n$$\n其中 $\\Omega$ 是水平计算域，$\\mathbf{1}(\\cdot)$ 是指示函数，当条件为真时返回1，否则返回0。\n- 在一个潮汐周期 $T=\\frac{2\\pi}{\\omega}$ 内的周期平均湿润面积为\n$$\n\\overline{A}(h_{\\min})=\\frac{1}{T}\\int_0^T A_{\\text{wet}}(t;h_{\\min})\\,\\mathrm{d}t.\n$$\n- 淹没范围对 $h_{\\min}$ 选择的敏感性由以下公式量化\n$$\n\\Delta A=\\overline{A}(h_{\\min,2})-\\overline{A}(h_{\\min,1}),\n$$\n其中两个阈值 $h_{\\min,1}$ 和 $h_{\\min,2}$ 的单位均为米。\n\n数值近似要求：\n- 使用间距为 $\\Delta x$ 和 $\\Delta y$（单位：米）的均匀直线网格对 $\\Omega$ 进行离散。通过对所有满足湿润掩码的单元格求和 $\\Delta x\\,\\Delta y$ 来近似 $A_{\\text{wet}}(t;h_{\\min})$ 的积分。\n- 通过在一个周期内进行均匀时间采样来近似周期平均值 $\\overline{A}(h_{\\min})$。在 $[0,T)$ 上使用 $N_t$ 个等间隔样本，并使用离散平均值\n$$\n\\overline{A}(h_{\\min})\\approx\\frac{1}{N_t}\\sum_{n=0}^{N_t-1} A_{\\text{wet}}(t_n;h_{\\min}),\\quad t_n=\\frac{n}{N_t}T.\n$$\n\n单位和输出规范：\n- 所有长度单位为米。时间单位为秒。角频率 $\\omega$ 单位为弧度/秒。面积必须以平方米 (m$^2$) 报告。\n- 将每个计算出的 $\\Delta A$ 以 m$^2$ 表示，并四舍五入到一位小数。\n\n测试套件：\n为以下四个测试案例实施计算。对于每个案例，构建网格，在单元格中心评估 $z_b(x,y)$，在一个周期内评估 $\\eta(t)$，并计算 $\\Delta A$。除非另有说明，角频率 $\\omega$ 必须使用弧度/秒，时间样本数 $N_t$ 必须为 $180$，周期必须为 $T=\\frac{2\\pi}{\\omega}$。\n\n- 案例1 (线性斜坡海滩):\n    - 域：$L_x=4000$ 米, $L_y=1000$ 米；网格间距 $\\Delta x=20$ 米, $\\Delta y=20$ 米。\n    - 水深地形：$z_b(x,y)=z_0+s\\,x$，其中 $z_0=-1.0$ 米，坡度 $s=0.002$ (无量纲)。\n    - 潮汐：$A=1.5$ 米, $\\omega=\\frac{2\\pi}{43200}$ 弧度/秒。\n    - 阈值：$h_{\\min,1}=0.02$ 米, $h_{\\min,2}=0.20$ 米。\n    - 时间采样：$N_t=180$。\n\n- 案例2 (带有较深斑块的阶梯状潮滩):\n    - 域：$L_x=3000$ 米, $L_y=1500$ 米；网格间距 $\\Delta x=20$ 米, $\\Delta y=20$ 米。\n    - 基础水深地形：$z_b^{\\text{base}}(x,y)=z_0+s\\,x$，其中 $z_0=-0.5$ 米，$s=0.0015$。\n    - 斑块：对于 $x\\in[600,1400]$ 米和 $y\\in[400,1100]$ 米，添加一个深度为 $d=-0.4$ 米的洼地，即在斑块内 $z_b(x,y)=z_b^{\\text{base}}(x,y)+d$，其他地方 $z_b(x,y)=z_b^{\\text{base}}(x,y)$。\n    - 潮汐：$A=1.2$ 米, $\\omega=\\frac{2\\pi}{45000}$ 弧度/秒。\n    - 阈值：$h_{\\min,1}=0.05$ 米, $h_{\\min,2}=0.30$ 米。\n    - 时间采样：$N_t=180$。\n\n- 案例3 (带有高斯沙坝的斜坡陆架):\n    - 域：$L_x=2000$ 米, $L_y=2000$ 米；网格间距 $\\Delta x=25$ 米, $\\Delta y=25$ 米。\n    - 水深地形：$z_b(x,y)=z_0+s\\,x+H\\exp\\left(-\\frac{(x-x_c)^2}{2\\sigma_x^2}-\\frac{(y-y_c)^2}{2\\sigma_y^2}\\right)$，参数为 $z_0=-0.2$ 米, $s=0.001$, $H=1.0$ 米, $x_c=1200$ 米, $y_c=1000$ 米, $\\sigma_x=300$ 米, $\\sigma_y=500$ 米。\n    - 潮汐：$A=0.8$ 米, $\\omega=\\frac{2\\pi}{43200}$ 弧度/秒。\n    - 阈值：$h_{\\min,1}=0.10$ 米, $h_{\\min,2}=0.25$ 米。\n    - 时间采样：$N_t=180$。\n\n- 案例4 (陡峭海滩上的小振幅潮汐):\n    - 域：$L_x=1000$ 米, $L_y=500$ 米；网格间距 $\\Delta x=10$ 米, $\\Delta y=10$ 米。\n    - 水深地形：$z_b(x,y)=z_0+s\\,x$，其中 $z_0=-0.1$ 米，坡度 $s=0.002$。\n    - 潮汐：$A=0.04$ 米, $\\omega=\\frac{2\\pi}{43200}$ 弧度/秒。\n    - 阈值：$h_{\\min,1}=0.05$ 米, $h_{\\min,2}=0.10$ 米。\n    - 时间采样：$N_t=180$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个案例的周期平均 $\\Delta A$ 值，格式为一个用方括号括起来的逗号分隔列表，每个值以 m$^2$ 为单位四舍五入到一位小数（例如，“[1234.5,678.9,10.0,0.0]”）。",
            "solution": "目标是计算淹没范围对干湿算法中最小有效水深阈值的敏感性，使用的是在已知水深地形上给定的静压潮汐。推导过程基于静水力学和几何量度的定义。\n\n1. 静水力学关系与水深定义。在静压近似下的浅水方程 (SWE) 将水深定义为 $h(x,y,t)=\\eta(t)-z_b(x,y)$，其中 $\\eta(t)$ 是高于一个基准面的自由表面高程，$z_b(x,y)$ 是高于同一基准面的床面高程。由于问题简化为按深度和面积度量进行分类，因此不需要动量项。\n\n2. 通过最小水深阈值进行干湿分类。用于干湿计算的数值算法会施加一个最小有效水深 $h_{\\min}0$，以避免在极浅单元格中出现病态行为。分类规则是指示函数\n$$\n\\mathbf{1}\\!\\left(h(x,y,t)\\ge h_{\\min}\\right)=\\begin{cases}\n1   \\text{if } \\eta(t)-z_b(x,y)\\ge h_{\\min},\\\\\n0   \\text{otherwise.}\n\\end{cases}\n$$\n此规则纯粹是几何的，并通过 $\\eta(t)$ 依赖于时间。\n\n3. 瞬时湿润面积积分。瞬时湿润面积是在水平域 $\\Omega$ 上的积分，\n$$\nA_{\\text{wet}}(t;h_{\\min})=\\iint_{\\Omega}\\mathbf{1}\\!\\left(\\eta(t)-z_b(x,y)\\ge h_{\\min}\\right)\\,\\mathrm{d}x\\,\\mathrm{d}y.\n$$\n该积分计算集合 $\\{(x,y)\\in\\Omega:\\eta(t)-z_b(x,y)\\ge h_{\\min}\\}$ 的面积。\n\n4. 周期平均湿润面积。为避免任意选择时间并捕捉潮汐调制，将 $A_{\\text{wet}}(t;h_{\\min})$ 在一个周期为 $T=\\frac{2\\pi}{\\omega}$ 的潮汐周期内取平均，\n$$\n\\overline{A}(h_{\\min})=\\frac{1}{T}\\int_0^T A_{\\text{wet}}(t;h_{\\min})\\,\\mathrm{d}t.\n$$\n使用给定的正弦函数 $\\eta(t)=A\\sin(\\omega t)$，唯一的时间依赖性通过标量 $\\eta(t)$ 进入。\n\n5. 敏感性度量。两个阈值 $h_{\\min,1}$ 和 $h_{\\min,2}$ 之间的周期平均湿润面积变化为\n$$\n\\Delta A=\\overline{A}(h_{\\min,2})-\\overline{A}(h_{\\min,1}).\n$$\n这量化了增加最小有效水深如何减少所考虑的淹没区域。\n\n6. 均匀网格上的离散近似。使用间距为 $\\Delta x$ 和 $\\Delta y$ 的均匀网格近似空间积分，并将水深地形置于单元格中心。在任何固定时间 $t$，离散近似为\n$$\nA_{\\text{wet}}(t;h_{\\min})\\approx \\Delta x\\,\\Delta y\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y}\\mathbf{1}\\!\\left(\\eta(t)-z_b(x_i,y_j)\\ge h_{\\min}\\right),\n$$\n其中 $(x_i,y_j)$ 是网格单元的中心，$N_x,N_y$ 是 $x$ 和 $y$ 方向上的单元格数量。周期平均值通过时间上的均匀黎曼和来近似，\n$$\n\\overline{A}(h_{\\min})\\approx \\frac{1}{N_t}\\sum_{n=0}^{N_t-1}A_{\\text{wet}}(t_n;h_{\\min}),\\quad t_n=\\frac{n}{N_t}T=\\frac{2\\pi n}{\\omega N_t}.\n$$\n\n7. 算法步骤。\n- 构建网格坐标为 $x_i=i\\,\\Delta x$（对于 $i=0,1,\\dots,N_x$）和 $y_j=j\\,\\Delta y$（对于 $j=0,1,\\dots,N_y$）。使用单元格中心，因此坐标偏移 $\\frac{1}{2}\\Delta x$ 和 $\\frac{1}{2}\\Delta y$ 以避免边界模糊。\n- 根据指定的水深地形函数，为所有单元格评估 $z_b(x_i,y_j)$：\n  - 线性斜坡：$z_b(x,y)=z_0+s\\,x$。\n  - 带斑块的阶梯状平地：$z_b^{\\text{base}}(x,y)=z_0+s\\,x$，在指定的矩形斑块内 $z_b(x,y)=z_b^{\\text{base}}(x,y)+d$；其他地方 $z_b(x,y)=z_b^{\\text{base}}(x,y)$。\n  - 高斯沙坝：$z_b(x,y)=z_0+s\\,x+H\\exp\\left(-\\frac{(x-x_c)^2}{2\\sigma_x^2}-\\frac{(y-y_c)^2}{2\\sigma_y^2}\\right)$。\n- 在 $[0,T)$ 上生成 $N_t$ 个等间隔的时间点 $t_n$，其中 $T=\\frac{2\\pi}{\\omega}$。\n- 对于每个 $t_n$，计算 $\\eta(t_n)=A\\sin(\\omega t_n)$。\n- 对于每个 $h_{\\min}$ 值，计算布尔掩码 $\\eta(t_n)-z_b\\ge h_{\\min}$，并通过计算真值的数量乘以 $\\Delta x\\,\\Delta y$ 来累积 $A_{\\text{wet}}(t_n;h_{\\min})$。\n- 对 $n$ 取平均以获得 $\\overline{A}(h_{\\min})$，然后计算两个阈值的 $\\Delta A$。\n\n8. 边界情况与数值考量。\n- 如果在所有地方 $\\eta(t)-z_b  h_{\\min}$，瞬时湿润面积为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_grid(Lx, Ly, dx, dy):\n    # Cell-centered coordinates\n    x = np.arange(dx/2, Lx, dx)\n    y = np.arange(dy/2, Ly, dy)\n    X, Y = np.meshgrid(x, y, indexing='xy')\n    return X, Y\n\ndef bathymetry_linear(X, Y, z0, s):\n    return z0 + s * X\n\ndef bathymetry_terrace_with_patch(X, Y, z0, s, x_patch, y_patch, d):\n    zb = z0 + s * X\n    # Apply depression d within rectangular patch\n    mask = (X >= x_patch[0])  (X = x_patch[1])  (Y >= y_patch[0])  (Y = y_patch[1])\n    zb = zb.copy()\n    zb[mask] = zb[mask] + d\n    return zb\n\ndef bathymetry_gaussian_bar(X, Y, z0, s, H, xc, yc, sigx, sigy):\n    gauss = np.exp(-((X - xc)**2)/(2.0*sigx**2) - ((Y - yc)**2)/(2.0*sigy**2))\n    zb = z0 + s * X + H * gauss\n    return zb\n\ndef cycle_mean_wet_area(zb, dx, dy, A, omega, Nt, hmin):\n    # One period T = 2*pi/omega; sample Nt times uniformly over [0, T)\n    T = 2.0 * np.pi / omega\n    t = np.linspace(0.0, T, Nt, endpoint=False)\n    eta = A * np.sin(omega * t)\n    cell_area = dx * dy\n    # Loop over times, compute wet area\n    areas = np.empty(Nt, dtype=np.float64)\n    for k in range(Nt):\n        # Broadcast eta[k] over grid\n        h = eta[k] - zb\n        wet_mask = h >= hmin\n        areas[k] = cell_area * np.count_nonzero(wet_mask)\n    return areas.mean()\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: linear sloping beach\n        {\n            \"domain\": {\"Lx\": 4000.0, \"Ly\": 1000.0, \"dx\": 20.0, \"dy\": 20.0},\n            \"bathymetry\": {\"type\": \"linear\", \"z0\": -1.0, \"s\": 0.002},\n            \"tide\": {\"A\": 1.5, \"omega\": 2.0 * np.pi / 43200.0},\n            \"thresholds\": {\"hmin1\": 0.02, \"hmin2\": 0.20},\n            \"Nt\": 180,\n        },\n        # Case 2: terraced tidal flat with a deeper patch\n        {\n            \"domain\": {\"Lx\": 3000.0, \"Ly\": 1500.0, \"dx\": 20.0, \"dy\": 20.0},\n            \"bathymetry\": {\n                \"type\": \"terrace_patch\",\n                \"z0\": -0.5,\n                \"s\": 0.0015,\n                \"x_patch\": (600.0, 1400.0),\n                \"y_patch\": (400.0, 1100.0),\n                \"d\": -0.4,\n            },\n            \"tide\": {\"A\": 1.2, \"omega\": 2.0 * np.pi / 45000.0},\n            \"thresholds\": {\"hmin1\": 0.05, \"hmin2\": 0.30},\n            \"Nt\": 180,\n        },\n        # Case 3: sloping shelf with a Gaussian sand bar\n        {\n            \"domain\": {\"Lx\": 2000.0, \"Ly\": 2000.0, \"dx\": 25.0, \"dy\": 25.0},\n            \"bathymetry\": {\n                \"type\": \"gaussian_bar\",\n                \"z0\": -0.2,\n                \"s\": 0.001,\n                \"H\": 1.0,\n                \"xc\": 1200.0,\n                \"yc\": 1000.0,\n                \"sigx\": 300.0,\n                \"sigy\": 500.0,\n            },\n            \"tide\": {\"A\": 0.8, \"omega\": 2.0 * np.pi / 43200.0},\n            \"thresholds\": {\"hmin1\": 0.10, \"hmin2\": 0.25},\n            \"Nt\": 180,\n        },\n        # Case 4: small-amplitude tide on a steeper beach\n        {\n            \"domain\": {\"Lx\": 1000.0, \"Ly\": 500.0, \"dx\": 10.0, \"dy\": 10.0},\n            \"bathymetry\": {\"type\": \"linear\", \"z0\": -0.1, \"s\": 0.002},\n            \"tide\": {\"A\": 0.04, \"omega\": 2.0 * np.pi / 43200.0},\n            \"thresholds\": {\"hmin1\": 0.05, \"hmin2\": 0.10},\n            \"Nt\": 180,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        Lx = case[\"domain\"][\"Lx\"]\n        Ly = case[\"domain\"][\"Ly\"]\n        dx = case[\"domain\"][\"dx\"]\n        dy = case[\"domain\"][\"dy\"]\n        X, Y = build_grid(Lx, Ly, dx, dy)\n\n        btype = case[\"bathymetry\"][\"type\"]\n        if btype == \"linear\":\n            zb = bathymetry_linear(X, Y, case[\"bathymetry\"][\"z0\"], case[\"bathymetry\"][\"s\"])\n        elif btype == \"terrace_patch\":\n            zb = bathymetry_terrace_with_patch(\n                X, Y,\n                case[\"bathymetry\"][\"z0\"],\n                case[\"bathymetry\"][\"s\"],\n                case[\"bathymetry\"][\"x_patch\"],\n                case[\"bathymetry\"][\"y_patch\"],\n                case[\"bathymetry\"][\"d\"],\n            )\n        elif btype == \"gaussian_bar\":\n            zb = bathymetry_gaussian_bar(\n                X, Y,\n                case[\"bathymetry\"][\"z0\"],\n                case[\"bathymetry\"][\"s\"],\n                case[\"bathymetry\"][\"H\"],\n                case[\"bathymetry\"][\"xc\"],\n                case[\"bathymetry\"][\"yc\"],\n                case[\"bathymetry\"][\"sigx\"],\n                case[\"bathymetry\"][\"sigy\"],\n            )\n        else:\n            raise ValueError(\"Unknown bathymetry type\")\n\n        A = case[\"tide\"][\"A\"]\n        omega = case[\"tide\"][\"omega\"]\n        Nt = case[\"Nt\"]\n        hmin1 = case[\"thresholds\"][\"hmin1\"]\n        hmin2 = case[\"thresholds\"][\"hmin2\"]\n\n        Abar1 = cycle_mean_wet_area(zb, dx, dy, A, omega, Nt, hmin1)\n        Abar2 = cycle_mean_wet_area(zb, dx, dy, A, omega, Nt, hmin2)\n        dA = Abar2 - Abar1\n\n        # Round to one decimal place\n        results.append(f\"{dA:.1f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}