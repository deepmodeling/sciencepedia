{
    "hands_on_practices": [
        {
            "introduction": "地貌动力学模型依赖于Exner方程，根据泥沙输运率的梯度来预测海床的演变。然而，模型的关键参数，如床体孔隙度（$\\lambda_p$）和泥沙通量的大小（$q_b$），通常都存在一定的不确定性。本实践练习  将指导您进行一阶敏感性分析，以定量评估这些不确定性如何传播到海床高程变化的预测中，这是解释模型结果和识别主要误差来源的一项关键技能。",
            "id": "3800689",
            "problem": "考虑一个沿水平坐标 $x$ (单位为米) 的一维海床剖面，该剖面受到推移质泥沙输运的影响。设床面高程为 $\\eta(x,t)$ (单位为米)，床面孔隙率为 $\\lambda_p$ (无量纲)，单位宽度推移质体积通量为 $q_b(x,t)$ (单位为平方米/秒)。床面演变由床内无穷小控制体积内的固体守恒定律控制。从质量守恒原理和孔隙率的定义出发，推导在有限时间 $T$ (单位为秒) 内床面高程变化 $\\Delta \\eta(x,T)$ (单位为米) 的表达式，该表达式应使用 $\\lambda_p$ 和 $q_b(x,t)$ 的空间梯度表示。假设 $q_b$ 在 $[0,T]$ 时间段内不随时间变化，且初始床面平坦，即 $\\eta(x,0)=0$。\n\n将推移质通量建模为一个由不确定的量级参数 $s$ (无量纲) 缩放的平滑基准函数：\n$$\nq_b(x) = s \\left( A \\sin(k x) + B x + C \\right),\n$$\n其中 $A$ (单位为平方米/秒) 设定正弦振幅，$k$ (单位为弧度/米) 是正弦变化的波数，所有三角函数参数必须以弧度为单位计算，$B$ (单位为平方米/秒/米) 设定线性趋势，$C$ (单位为平方米/秒) 是一个常数偏移量。将 $s$ 和 $\\lambda_p$ 视为不确定标量，其小的单标准差不确定性分别为 $\\delta s$ 和 $\\delta \\lambda_p$。\n\n对 $\\lambda_p$ 和 $s$ 进行一阶敏感性分析，以量化它们的不确定性如何影响预测的床面高程变化。具体来说：\n- 推导在基准 $(\\lambda_p, s)$ 处求值的一阶敏感度 $\\partial \\Delta \\eta / \\partial \\lambda_p$ 和 $\\partial \\Delta \\eta / \\partial s$ 的表达式。\n- 使用这些敏感度，计算由不确定性引起的床面高程变化的空间平均期望量级，定义为\n$$\nM_{\\lambda_p} = \\left\\langle \\left| \\frac{\\partial \\Delta \\eta}{\\partial \\lambda_p}(x) \\right| \\right\\rangle \\, \\delta \\lambda_p, \\quad\nM_{s} = \\left\\langle \\left| \\frac{\\partial \\Delta \\eta}{\\partial s}(x) \\right| \\right\\rangle \\, \\delta s,\n$$\n其中 $\\langle \\cdot \\rangle$ 表示在空间域 $x \\in [0,L]$ 上的平均值，$L$ 是域长度 (单位为米)。以米为单位报告 $M_{\\lambda_p}$ 和 $M_{s}$。\n\n实现一个程序，该程序：\n- 使用推导出的 $\\Delta \\eta(x,T)$ 解析公式和敏感度。\n- 使用 $N_x$ 个点对域 $[0,L]$ 进行均匀离散化，以数值方式计算空间平均值。\n- 对每个指定的测试用例，生成浮点数对 $(M_{\\lambda_p}, M_{s})$。\n\n测试套件：\n- 用例 $1$ (一般变化)：$L=1000$ (米)，$T=86400$ (秒)，$\\lambda_p=0.4$，$\\delta \\lambda_p=0.05$，$s=1.0$，$\\delta s=0.1$，$A=0.001$ (平方米/秒)，$k=0.01$ (弧度/米)，$B=1\\times 10^{-7}$ (平方米/秒/米)，$C=0.001$ (平方米/秒)，$N_x=1001$。\n- 用例 $2$ (均匀推移质，零梯度边缘)：$L=500$ (米)，$T=43200$ (秒)，$\\lambda_p=0.5$，$\\delta \\lambda_p=0.05$，$s=1.0$，$\\delta s=0.2$，$A=0.0$ (平方米/秒)，$k=0.02$ (弧度/米)，$B=0.0$ (平方米/秒/米)，$C=0.002$ (平方米/秒)，$N_x=501$。\n- 用例 $3$ (更陡的梯度)：$L=2000$ (米)，$T=172800$ (秒)，$\\lambda_p=0.35$，$\\delta \\lambda_p=0.03$，$s=0.8$，$\\delta s=0.15$，$A=0.0005$ (平方米/秒)，$k=0.02$ (弧度/米)，$B=5\\times 10^{-6}$ (平方米/秒/米)，$C=0.0$ (平方米/秒)，$N_x=2001$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含结果，结果为方括号括起来的逗号分隔列表，顺序如下\n$$\n\\left[ M_{\\lambda_p}^{(1)}, M_s^{(1)}, M_{\\lambda_p}^{(2)}, M_s^{(2)}, M_{\\lambda_p}^{(3)}, M_s^{(3)} \\right],\n$$\n其中上标表示测试用例索引。所有值都必须是米为单位的浮点数。不应打印任何附加文本。",
            "solution": "该问题被评估为有效。它在科学上基于泥沙输运的质量守恒原理，问题提法适定，目标明确，数据充分，并使用精确、客观的语言进行阐述。其基础物理模型 (Exner 方程) 和数学技术 (一阶敏感性分析) 在计算海洋学领域是标准且适用的。\n\n求解过程分几个阶段：首先，从第一性原理推导床面高程变化的控制偏微分方程。其次，针对给定的特定条件和通量模型求解该方程。第三，推导一阶敏感度的表达式。最后，建立所需的不确定性度量公式，为数值实现做好准备。\n\n**1. 床面演变控制方程的推导**\n\n海床的演变由泥沙质量守恒定律控制。考虑一个长度为 $\\Delta x$、单位宽度的床面一维控制体积。这部分床面的总体积为 $V_{total} = \\eta(x,t) \\Delta x$。床面是孔隙率为 $\\lambda_p$ 的多孔介质，孔隙率定义为空隙体积与总体积之比。因此，控制体积内固体泥沙颗粒的体积 $V_{solid}$ 为：\n$$\nV_{solid} = (1 - \\lambda_p) V_{total} = (1 - \\lambda_p) \\eta(x,t) \\Delta x\n$$\n质量守恒原理规定，该控制体积内泥沙体积的时间变化率必须等于流入其中的净泥沙通量。单位宽度的体积通量用 $q_b(x,t)$ 表示。在位置 $x$ 处流入控制体积的通量是 $q_b(x,t)$，在 $x+\\Delta x$ 处流出的通量是 $q_b(x+\\Delta x, t)$。因此，净通量为 $q_b(x,t) - q_b(x+\\Delta x, t)$。\n\n将泥沙体积的变化率与净通量相等，我们得到：\n$$\n\\frac{\\partial V_{solid}}{\\partial t} = q_b(x,t) - q_b(x+\\Delta x, t)\n$$\n假设孔隙率 $\\lambda_p$ 在空间和时间上是常数，则方程左侧变为：\n$$\n\\frac{\\partial}{\\partial t} \\left[ (1 - \\lambda_p) \\eta(x,t) \\Delta x \\right] = (1 - \\lambda_p) \\Delta x \\frac{\\partial \\eta(x,t)}{\\partial t}\n$$\n将此代入守恒方程并除以 $\\Delta x$：\n$$\n(1 - \\lambda_p) \\frac{\\partial \\eta}{\\partial t} = - \\frac{q_b(x+\\Delta x, t) - q_b(x,t)}{\\Delta x}\n$$\n取 $\\Delta x \\to 0$ 的极限，得到用于床面演变的一维 Exner 方程：\n$$\n(1 - \\lambda_p) \\frac{\\partial \\eta}{\\partial t} = - \\frac{\\partial q_b}{\\partial x}\n$$\n这可以重新整理为直接表示床面高程变化率的形式：\n$$\n\\frac{\\partial \\eta}{\\partial t} = - \\frac{1}{1 - \\lambda_p} \\frac{\\partial q_b}{\\partial x}\n$$\n\n**2. 有限时间内的床面高程变化**\n\n问题要求计算在时间范围 $T$ 内的床面高程总变化 $\\Delta \\eta(x,T) = \\eta(x,T) - \\eta(x,0)$。这可以通过将变化率从 $t=0$ 到 $t=T$ 积分得到：\n$$\n\\Delta \\eta(x,T) = \\int_0^T \\frac{\\partial \\eta}{\\partial t} \\mathrm{d}t = \\int_0^T \\left( - \\frac{1}{1 - \\lambda_p} \\frac{\\partial q_b}{\\partial x} \\right) \\mathrm{d}t\n$$\n问题指明推移质通量 $q_b$ 在区间 $[0, T]$ 内不随时间变化，因此 $q_b(x, t) = q_b(x)$。结果，$\\frac{\\partial q_b}{\\partial x}$ 项在时间上也是常数。积分简化为：\n$$\n\\Delta \\eta(x,T) = \\left( - \\frac{1}{1 - \\lambda_p} \\frac{\\partial q_b}{\\partial x} \\right) \\int_0^T \\mathrm{d}t = - \\frac{T}{1 - \\lambda_p} \\frac{\\partial q_b}{\\partial x}\n$$\n给定初始条件 $\\eta(x,0)=0$，该表达式直接给出了时间 $T$ 时的床面高程。\n\n现在，我们代入给定的推移质通量模型：\n$$\nq_b(x) = s \\left( A \\sin(k x) + B x + C \\right)\n$$\n通量的空间梯度是：\n$$\n\\frac{\\partial q_b}{\\partial x} = \\frac{d}{dx} \\left[ s \\left( A \\sin(k x) + B x + C \\right) \\right] = s \\left( A k \\cos(k x) + B \\right)\n$$\n注意，通量中的常数偏移量 $C$ 对床面高程变化没有贡献，因为它没有空间梯度。将此梯度代入 $\\Delta \\eta(x,T)$ 的方程，得到床面高程变化的最终解析表达式：\n$$\n\\Delta \\eta(x,T) = - \\frac{s T}{1 - \\lambda_p} (A k \\cos(k x) + B)\n$$\n\n**3. 一阶敏感性分析**\n\n我们现在计算 $\\Delta \\eta(x,T)$ 关于不确定参数 $\\lambda_p$ 和 $s$ 的一阶敏感度。\n\n*   **关于孔隙率 $\\lambda_p$ 的敏感度：**\n    $$\n    \\frac{\\partial \\Delta \\eta}{\\partial \\lambda_p} = \\frac{\\partial}{\\partial \\lambda_p} \\left[ - s T (A k \\cos(k x) + B) (1 - \\lambda_p)^{-1} \\right]\n    $$\n    将除 $(1 - \\lambda_p)^{-1}$ 以外的所有项都视为关于 $\\lambda_p$ 的常数因子，并应用链式法则：$\\frac{d}{d\\lambda_p}(1-\\lambda_p)^{-1} = -1(1-\\lambda_p)^{-2}(-1) = (1-\\lambda_p)^{-2}$。\n    $$\n    \\frac{\\partial \\Delta \\eta}{\\partial \\lambda_p} = - s T (A k \\cos(k x) + B) \\frac{1}{(1 - \\lambda_p)^2} = - \\frac{s T (A k \\cos(k x) + B)}{(1 - \\lambda_p)^2}\n    $$\n\n*   **关于通量量级 $s$ 的敏感度：**\n    $$\n    \\frac{\\partial \\Delta \\eta}{\\partial s} = \\frac{\\partial}{\\partial s} \\left[ - \\frac{s T}{1 - \\lambda_p} (A k \\cos(k x) + B) \\right]\n    $$\n    这里，$s$ 是微分变量，其余都是因子。\n    $$\n    \\frac{\\partial \\Delta \\eta}{\\partial s} = - \\frac{T}{1 - \\lambda_p} (A k \\cos(k x) + B)\n    $$\n\n**4. 不确定性度量和数值实现**\n\n度量 $M_{\\lambda_p}$ 和 $M_s$ 量化了由不确定性 $\\delta \\lambda_p$ 和 $\\delta s$ 引起的床面高程变化的期望量级。它们是使用敏感度的空间平均绝对值来定义的。设 $\\langle \\cdot \\rangle$ 表示在 $x \\in [0,L]$ 上的空间平均。\n\n对于 $M_{\\lambda_p}$：\n$$\nM_{\\lambda_p} = \\left\\langle \\left| \\frac{\\partial \\Delta \\eta}{\\partial \\lambda_p}(x) \\right| \\right\\rangle \\delta \\lambda_p = \\left\\langle \\left| - \\frac{s T (A k \\cos(k x) + B)}{(1 - \\lambda_p)^2} \\right| \\right\\rangle \\delta \\lambda_p\n$$\n由于 $s, T, \\delta \\lambda_p$ 和 $(1-\\lambda_p)^2$ 是正常数，它们可以从空间平均中提出来：\n$$\nM_{\\lambda_p} = \\frac{s T \\delta \\lambda_p}{(1 - \\lambda_p)^2} \\left\\langle \\left| A k \\cos(k x) + B \\right| \\right\\rangle\n$$\n\n对于 $M_s$：\n$$\nM_{s} = \\left\\langle \\left| \\frac{\\partial \\Delta \\eta}{\\partial s}(x) \\right| \\right\\rangle \\delta s = \\left\\langle \\left| - \\frac{T (A k \\cos(k x) + B)}{1 - \\lambda_p} \\right| \\right\\rangle \\delta s\n$$\n同样，提出正常数因子：\n$$\nM_{s} = \\frac{T \\delta s}{1 - \\lambda_p} \\left\\langle \\left| A k \\cos(k x) + B \\right| \\right\\rangle\n$$\n注意到两个度量都共享 $\\langle | A k \\cos(k x) + B | \\rangle$ 这一项。为了进行数值计算，我们将域 $[0,L]$ 离散化为 $N_x$ 个均匀点 $x_i$。函数 $f(x)$ 的空间平均值可以通过其在该网格上值的算术平均值来近似：\n$$\n\\langle f(x) \\rangle \\approx \\frac{1}{N_x} \\sum_{i=0}^{N_x-1} f(x_i)\n$$\n我们定义 $G(x) = A k \\cos(k x) + B$ 并计算其平均绝对值：\n$$\n\\bar{G}_{abs} = \\langle |G(x)| \\rangle \\approx \\frac{1}{N_x} \\sum_{i=0}^{N_x-1} |A k \\cos(k x_i) + B|\n$$\n然后，度量计算如下：\n$$\nM_{\\lambda_p} = \\frac{s T \\delta \\lambda_p}{(1 - \\lambda_p)^2} \\bar{G}_{abs}\n\\qquad \\text{和} \\qquad\nM_{s} = \\frac{T \\delta s}{1 - \\lambda_p} \\bar{G}_{abs}\n$$\n为每个测试用例实现这些公式，以获得最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes spatially averaged expected magnitudes of bed elevation change due to\n    uncertainties in porosity and a sediment flux scaling parameter.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general variation)\n        {'L': 1000, 'T': 86400, 'lambda_p': 0.4, 'd_lambda_p': 0.05,\n         's': 1.0, 'd_s': 0.1, 'A': 0.001, 'k': 0.01,\n         'B': 1e-7, 'C': 0.001, 'Nx': 1001},\n        # Case 2 (uniform bedload, zero gradient edge)\n        {'L': 500, 'T': 43200, 'lambda_p': 0.5, 'd_lambda_p': 0.05,\n         's': 1.0, 'd_s': 0.2, 'A': 0.0, 'k': 0.02,\n         'B': 0.0, 'C': 0.002, 'Nx': 501},\n        # Case 3 (steeper gradient)\n        {'L': 2000, 'T': 172800, 'lambda_p': 0.35, 'd_lambda_p': 0.03,\n         's': 0.8, 'd_s': 0.15, 'A': 0.0005, 'k': 0.02,\n         'B': 5e-6, 'C': 0.0, 'Nx': 2001}\n    ]\n\n    results = []\n    for params in test_cases:\n        # Extract parameters for the current case\n        L = params['L']\n        T = params['T']\n        lambda_p = params['lambda_p']\n        d_lambda_p = params['d_lambda_p']\n        s = params['s']\n        d_s = params['d_s']\n        A = params['A']\n        k = params['k']\n        B = params['B']\n        Nx = params['Nx']\n\n        # Create the uniformly discretized spatial domain\n        # x is a vector of Nx points from 0 to L\n        x = np.linspace(0, L, Nx)\n\n        # Calculate the spatial gradient term G(x) = A*k*cos(k*x) + B\n        # This term comes from differentiating the sediment flux q_b with respect to x.\n        g_x = A * k * np.cos(k * x) + B\n\n        # Compute the spatially averaged absolute value of G(x)\n        # This is the core term |G(x)|> in the sensitivity formulas.\n        g_bar_abs = np.mean(np.abs(g_x))\n\n        # Calculate the uncertainty metric M_lambda_p\n        # M_lambda_p = (s * T * d_lambda_p / (1 - lambda_p)^2) * |G(x)|>\n        m_lambda_p = (s * T * d_lambda_p / (1 - lambda_p)**2) * g_bar_abs\n\n        # Calculate the uncertainty metric M_s\n        # M_s = (T * d_s / (1 - lambda_p)) * |G(x)|>\n        m_s = (T * d_s / (1 - lambda_p)) * g_bar_abs\n\n        results.extend([m_lambda_p, m_s])\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of floats enclosed in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "含沙水流的建模涉及将流体动力学与泥沙质量守恒耦合起来，从而构成一个多物理场系统。在时间步长上耦合这些过程的数值策略——即耦合方案——对模型的准确性、稳定性和守恒性有着至关重要的影响。在此练习  中，您将实现并比较一个简单的“松耦合”方案与一个更稳健的“强耦合”方案，从而能够直接量化两者在质量守恒和动量闭合误差方面的差异，并理解其中涉及的基本权衡。",
            "id": "3800686",
            "problem": "考虑一个一维、深度平均的明渠流，其中包含悬浮泥沙。该水流由一个深度和横截面恒定的控制体表示。流体速度和泥沙浓度通过浮力和河床交换相互耦合。您将实现并比较两种数值耦合方案——松耦合与强耦合——用于模拟流速和泥沙浓度的演变，并量化泥沙质量守恒和动量闭合中的误差。\n\n基本基础和控制关系：\n\n- 从控制体深度平均水平动量的牛顿第二定律出发。在Boussinesq近似（BA）下，密度变化仅通过浮力项体现，深度平均速度 $u(t)$ 服从\n$$\n\\frac{du}{dt} = g S \\left(1 + \\frac{c}{\\rho_0}\\right) - \\frac{C_f}{H} u |u| ,\n$$\n其中 $g$ 是重力加速度，$S$ 是河床坡度（无量纲），$H$ 是水深，$\\rho_0$ 是参考水体密度，$C_f$ 是一个无量纲的河床摩擦系数，$c(t)$ 是悬浮泥沙浓度，单位为千克/立方米。\n\n- 泥沙质量守恒对水体和河床分别成立。设 $B(t)$ 表示单位面积的河床泥沙质量，单位为千克/平方米。水体积分的单位面积悬浮质量为 $H c$。交换通量包括从河床向上的侵蚀通量 $e(u)$ 和向下的沉积通量 $w_s c$，二者单位均为千克/（平方米·秒）。连续时间质量平衡方程为\n$$\n\\frac{d(H c)}{dt} = e(u) - w_s c, \\quad \\frac{dB}{dt} = -e(u) + w_s c,\n$$\n这确保了单位面积的总泥沙质量 $M_{\\mathrm{tot}}(t) = H c(t) + B(t)$ 是守恒的。\n\n- 床面剪切应力模型为\n$$\n\\tau_b(u) = \\rho_0 C_f u^2,\n$$\n侵蚀通量遵循一个阈值定律\n$$\ne(u) = M \\max\\!\\left( \\frac{\\tau_b(u) - \\tau_c}{\\tau_c}, \\, 0 \\right),\n$$\n其中 $M$ 是一个侵蚀率系数，单位为千克/（平方米·秒），$\\tau_c$ 是临界剪切应力，单位为帕斯卡，$w_s$ 是颗粒沉降速度，单位为米/秒。\n\n需要实现的数值方案：\n\n- 松耦合（顺序、显式解耦）：\n  - 使用上一时刻的浓度更新速度：\n  $$\n  u^{n+1} = u^n + \\Delta t \\left[ g S \\left(1 + \\frac{c^n}{\\rho_0}\\right) - \\frac{C_f}{H} u^n |u^n| \\right].\n  $$\n  - 使用在新更新的速度下计算的侵蚀量，但使用旧浓度计算沉积量，来更新悬浮浓度：\n  $$\n  c^{n+1} = c^n + \\frac{\\Delta t}{H} \\left[ e(u^{n+1}) - w_s c^n \\right].\n  $$\n  - 使用上一步的通量更新河床质量：\n  $$\n  B^{n+1} = B^n - \\Delta t \\left[ e(u^n) - w_s c^n \\right].\n  $$\n  该方案可能在一个时间步内引入河床和水体通量之间的不一致性。\n\n- 强耦合（同步、对状态变量全隐式）：\n  - 从以下方程组同步求解 $u^{n+1}$ 和 $c^{n+1}$：\n  $$\n  u^{n+1} = u^n + \\Delta t \\left[ g S \\left(1 + \\frac{c^{n+1}}{\\rho_0}\\right) - \\frac{C_f}{H} u^{n+1} |u^{n+1}| \\right],\n  $$\n  $$\n  H c^{n+1} = H c^n + \\Delta t \\left[ e(u^{n+1}) - w_s c^{n+1} \\right],\n  $$\n  然后在同一时间层级上一致地更新河床质量：\n  $$\n  B^{n+1} = B^n - \\Delta t \\left[ e(u^{n+1}) - w_s c^{n+1} \\right].\n  $$\n  离散的总质量 $H c^{n+1} + B^{n+1}$ 在求解器容差范围内是守恒的。\n\n需要计算的误差度量：\n\n- 在最终时间 $T$ 的泥沙质量守恒误差：\n$$\n\\varepsilon_{\\mathrm{mass}} = \\frac{\\left| \\left( H c(T) + B(T) \\right) - \\left( H c(0) + B(0) \\right) \\right|}{H c(0) + B(0)},\n$$\n该值为无量纲。\n\n- 整个模拟过程中的动量闭合残差，通过使用中点评估的步长残差的均方根（RMS）来衡量：\n$$\nr_k = \\frac{u^{k+1} - u^{k}}{\\Delta t} - \\left[ g S \\left(1 + \\frac{c^{k+1/2}}{\\rho_0}\\right) - \\frac{C_f}{H} u^{k+1/2} \\left| u^{k+1/2} \\right| \\right],\n$$\n$$\nu^{k+1/2} = \\frac{u^k + u^{k+1}}{2}, \\quad c^{k+1/2} = \\frac{c^k + c^{k+1}}{2},\n$$\n其均方根为\n$$\n\\varepsilon_{\\mathrm{mom}} = \\sqrt{ \\frac{1}{N} \\sum_{k=0}^{N-1} r_k^2 },\n$$\n单位为米/秒平方，其中 $N$ 是时间步的总数。\n\n任务：\n\n- 实现两种耦合方案，将系统从时间 $t=0$ 积分到 $t=T$，并针对几组参数集进行计算。\n- 对于每个测试用例，计算并返回四个数值：松耦合方案的泥沙质量守恒误差，强耦合方案的泥沙质量守恒误差，松耦合方案的动量闭合RMS残差，以及强耦合方案的动量闭合RMS残差。\n\n单位和数值细节：\n\n- 使用国际单位制（SI）。所有输入和输出必须使用SI单位。\n- 动量闭合RMS残差必须以米/秒平方为单位报告。\n- 质量守恒误差必须以无量纲比率报告。\n\n测试套件：\n\n为以下三个测试用例提供结果。在所有用例中，重力加速度 $g = 9.81 \\, \\mathrm{m/s^2}$，参考密度 $\\rho_0 = 1025 \\, \\mathrm{kg/m^3}$。悬浮泥沙浓度 $c$ 的单位是 $\\mathrm{kg/m^3}$，单位面积的河床质量 $B$ 的单位是 $\\mathrm{kg/m^2}$，速度 $u$ 的单位是 $\\mathrm{m/s}$。\n\n- 用例 $1$（理想情况，中等坡度，细泥）：\n  - $H = 10 \\, \\mathrm{m}$, $S = 1.0 \\times 10^{-4}$, $C_f = 3.0 \\times 10^{-3}$, $\\tau_c = 0.20 \\, \\mathrm{Pa}$, $M = 5.0 \\times 10^{-5} \\, \\mathrm{kg/(m^2 \\, s)}$, $w_s = 1.0 \\times 10^{-3} \\, \\mathrm{m/s}$,\n  - $u_0 = 0.30 \\, \\mathrm{m/s}$, $c_0 = 0.10 \\, \\mathrm{kg/m^3}$, $B_0 = 10.0 \\, \\mathrm{kg/m^2}$,\n  - $\\Delta t = 2.0 \\, \\mathrm{s}$, $T = 1800.0 \\, \\mathrm{s}$.\n\n- 用例 $2$（接近侵蚀阈值的边界条件）：\n  - $H = 10 \\, \\mathrm{m}$, $S = 1.0 \\times 10^{-4}$, $C_f = 3.0 \\times 10^{-3}$, $\\tau_c = 0.20 \\, \\mathrm{Pa}$, $M = 1.0 \\times 10^{-5} \\, \\mathrm{kg/(m^2 \\, s)}$, $w_s = 1.0 \\times 10^{-3} \\, \\mathrm{m/s}$,\n  - $u_0 = 0.25 \\, \\mathrm{m/s}$, $c_0 = 0.05 \\, \\mathrm{kg/m^3}$, $B_0 = 8.0 \\, \\mathrm{kg/m^2}$,\n  - $\\Delta t = 5.0 \\, \\mathrm{s}$, $T = 1800.0 \\, \\mathrm{s}$.\n\n- 用例 $3$（具有粗时间步和更快沉降速度的边界情况）：\n  - $H = 5 \\, \\mathrm{m}$, $S = 1.5 \\times 10^{-4}$, $C_f = 3.0 \\times 10^{-3}$, $\\tau_c = 0.20 \\, \\mathrm{Pa}$, $M = 5.0 \\times 10^{-5} \\, \\mathrm{kg/(m^2 \\, s)}$, $w_s = 2.0 \\times 10^{-3} \\, \\mathrm{m/s}$,\n  - $u_0 = 0.40 \\, \\mathrm{m/s}$, $c_0 = 0.20 \\, \\mathrm{kg/m^3}$, $B_0 = 12.0 \\, \\mathrm{kg/m^2}$,\n  - $\\Delta t = 30.0 \\, \\mathrm{s}$, $T = 3600.0 \\, \\mathrm{s}$.\n\n最终输出格式：\n\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表（例如，`[result1,result2,...]`）。该列表必须按以下顺序包含 $12$ 个浮点数：\n$$\n[\\varepsilon_{\\mathrm{mass}}^{\\mathrm{loose}}(\\text{用例 }1), \\, \\varepsilon_{\\mathrm{mass}}^{\\mathrm{strong}}(\\text{用例 }1), \\, \\varepsilon_{\\mathrm{mom}}^{\\mathrm{loose}}(\\text{用例 }1), \\, \\varepsilon_{\\mathrm{mom}}^{\\mathrm{strong}}(\\text{用例 }1), \\,\n\\varepsilon_{\\mathrm{mass}}^{\\mathrm{loose}}(\\text{用例 }2), \\, \\varepsilon_{\\mathrm{mass}}^{\\mathrm{strong}}(\\text{用例 }2), \\, \\varepsilon_{\\mathrm{mom}}^{\\mathrm{loose}}(\\text{用例 }2), \\, \\varepsilon_{\\mathrm{mom}}^{\\mathrm{strong}}(\\text{用例 }2), \\,\n\\varepsilon_{\\mathrm{mass}}^{\\mathrm{loose}}(\\text{用例 }3), \\, \\varepsilon_{\\mathrm{mass}}^{\\mathrm{strong}}(\\text{用例 }3), \\, \\varepsilon_{\\mathrm{mom}}^{\\mathrm{loose}}(\\text{用例 }3), \\, \\varepsilon_{\\mathrm{mom}}^{\\mathrm{strong}}(\\text{用例 }3)].\n$$",
            "solution": "用户要求实现并比较两种数值耦合方案——松耦合与强耦合——用于一个简化的一维泥沙输运模型。该分析涉及求解一个关于流体速度 $u(t)$ 和悬浮泥沙浓度 $c(t)$ 的耦合常微分方程组（ODEs），然后量化每种方案在泥沙质量守恒和动量闭合方面的误差。\n\n**1. 问题建构**\n\n该物理系统由一组耦合的常微分方程描述。深度平均的流体速度 $u(t)$ 由动量方程控制，该方程平衡了加速度与坡面上的重力驱动力（包括悬浮泥沙产生的浮力效应）以及河床摩擦的阻力：\n$$\n\\frac{du}{dt} = g S \\left(1 + \\frac{c}{\\rho_0}\\right) - \\frac{C_f}{H} u |u|\n$$\n悬浮泥沙浓度 $c(t)$ 由水体的质量平衡方程控制，该方程考虑了从河床的侵蚀 $e(u)$ 和向河床的沉积 $d(c) = w_s c$：\n$$\n\\frac{d(H c)}{dt} = e(u) - w_s c\n$$\n侵蚀通量 $e(u)$ 是床面剪切应力 $\\tau_b(u) = \\rho_0 C_f u^2$ 的函数，并且仅当该应力超过临界阈值 $\\tau_c$ 时才不为零：\n$$\ne(u) = M \\max\\!\\left( \\frac{\\tau_b(u) - \\tau_c}{\\tau_c}, \\, 0 \\right)\n$$\n单位面积的河床质量 $B(t)$ 根据床水界面的净通量而变化，从而确保在连续系统中总质量 $H c(t) + B(t)$ 是守恒的。\n\n**2. 数值方案与实现**\n\n任务的核心是使用两种不同的耦合策略对该系统进行时间离散化，并从 $t=0$ 时的初始状态 $(u_0, c_0, B_0)$ 以时间步长 $\\Delta t$ 步进到最终时间 $t=T$。\n\n**2.1. 松耦合方案（显式顺序）**\n\n该方案顺序更新状态变量，使用前一时间步的值来计算新状态。这种方法计算成本低，但可能引入不一致性和数值误差。\n在每个时间层级 $n$ 找到 $n+1$ 状态的步骤如下：\n1.  更新速度 $u^{n+1}$：动量方程的右侧完全在时间 $n$ 进行评估。这是一个简单的前向欧拉步。\n    $$u^{n+1} = u^n + \\Delta t \\left[ g S \\left(1 + \\frac{c^n}{\\rho_0}\\right) - \\frac{C_f}{H} u^n |u^n| \\right]$$\n2.  更新浓度 $c^{n+1}$：浓度方程使用新计算的速度 $u^{n+1}$ 来计算侵蚀项，但使用旧浓度 $c^n$ 来计算沉积项。\n    $$c^{n+1} = c^n + \\frac{\\Delta t}{H} \\left[ e(u^{n+1}) - w_s c^n \\right]$$\n3.  更新河床质量 $B^{n+1}$：根据问题描述，河床质量使用完全在旧时间步 $n$ 评估的通量进行更新。\n    $$B^{n+1} = B^n - \\Delta t \\left[ e(u^n) - w_s c^n \\right]$$\n这里的关键问题是侵蚀通量计算中的不一致性。水体根据 $e(u^{n+1})$ 增加质量，而河床根据 $e(u^n)$ 减少质量。这导致了离散质量守恒的违背。\n\n**2.2. 强耦合方案（隐式同步）**\n\n该方案同步求解新的状态变量 $u^{n+1}$ 和 $c^{n+1}$，确保耦合项在新的时间层级上相互一致。这是后向欧拉法的一种形式，对于刚性系统通常更稳定和准确，尽管计算上更密集。\n该方案需要求解以下关于 $(u^{n+1}, c^{n+1})$ 的非线性代数方程组：\n$$\nu^{n+1} - u^n - \\Delta t \\left[ g S \\left(1 + \\frac{c^{n+1}}{\\rho_0}\\right) - \\frac{C_f}{H} u^{n+1} |u^{n+1}| \\right] = 0\n$$\n$$\nH c^{n+1} - H c^n - \\Delta t \\left[ e(u^{n+1}) - w_s c^{n+1} \\right] = 0\n$$\n该系统可以简化。第二个方程可以重新整理，将 $c^{n+1}$ 表示为 $u^{n+1}$ 的显式函数：\n$$\nc^{n+1}(H + \\Delta t w_s) = H c^n + \\Delta t \\, e(u^{n+1}) \\implies c^{n+1} = \\frac{H c^n + \\Delta t \\, e(u^{n+1})}{H + \\Delta t w_s}\n$$\n将这个 $c^{n+1}$ 的表达式代入第一个方程，得到一个关于 $u^{n+1}$ 的单一非线性标量方程：\n$$\nf(u^{n+1}) = u^{n+1} - u^n - \\Delta t \\left[ g S \\left(1 + \\frac{1}{\\rho_0}\\left(\\frac{H c^n + \\Delta t \\, e(u^{n+1})}{H + \\Delta t w_s}\\right)\\right) - \\frac{C_f}{H} u^{n+1} |u^{n+1}| \\right] = 0\n$$\n这个关于 $x=u^{n+1}$ 的标量方程 $f(x)=0$ 可以使用数值求根算法高效求解。由于函数 $f(x)$ 对于 $x \\ge 0$ 是单调的，一个稳健的区间法如Brent法是合适的。我们将为此使用 `scipy.optimize.root_scalar`。一旦找到 $u^{n+1}$，就可以直接计算 $c^{n+1}$。\n然后，河床质量使用时间 $n+1$ 的通量进行一致性更新：\n$$\nB^{n+1} = B^n - \\Delta t \\left[ e(u^{n+1}) - w_s c^{n+1} \\right]\n$$\n这种构造保证了在每一步中 $(H c^{n+1} + B^{n+1}) - (H c^n + B^n) = 0$，从而在数值求解器的容差范围内保持总泥沙质量守恒。\n\n**3. 误差量化**\n\n计算两个度量来评估每种方案的性能。\n\n- **泥沙质量守恒误差 ($\\varepsilon_{\\mathrm{mass}}$)**：这个无量纲度量量化了在整个模拟过程中未能守恒总泥沙质量 $(H c + B)$ 的程度。它计算为最终和初始总质量之间的绝对差值，并用初始总质量进行归一化。对于强耦合方案，该误差预计接近机器精度。对于松耦合方案，如指定的那样，误差源于每个时间步中的不匹配 $e(u^{n+1}) - e(u^n)$。\n\n- **动量闭合残差 ($\\varepsilon_{\\mathrm{mom}}$)**：该度量衡量数值解满足原始动量常微分方程的程度。它计算为每个时间步 $k$ 的残差 $r_k$ 的均方根（RMS），其中 $r_k$ 是时间导数的有限差分近似与在时间步中点评估的驱动项之间的差异：\n  $$r_k = \\frac{u^{k+1} - u^{k}}{\\Delta t} - \\left[ g S \\left(1 + \\frac{c^{k+1/2}}{\\rho_0}\\right) - \\frac{C_f}{H} u^{k+1/2} \\left| u^{k+1/2} \\right| \\right]$$\n  其中 $u^{k+1/2}$ 和 $c^{k+1/2}$ 是在步 $k$ 和 $k+1$ 处值的算术平均值。较小的残差表明解与连续控制方程更加一致。\n\n**4. 算法流程**\n\n总体算法如下：\n1.  初始化常数 $g$ 和 $\\rho_0$。\n2.  对每个提供的测试用例：\n    a. 设置模型参数 ($H, S, C_f, \\dots$)、初始条件 ($u_0, c_0, B_0$) 和时间步进参数 ($\\Delta t, T$)。\n    b. **松耦合模拟**：\n        i.   初始化数组以存储 $u$ 和 $c$ 的历史记录。\n        ii.  从 $t=0$ 到 $T$ 迭代，在每一步应用松耦合更新规则。\n        iii. 在最后一步之后，计算 $\\varepsilon_{\\mathrm{mass}}^{\\mathrm{loose}}$ 和 $\\varepsilon_{\\mathrm{mom}}^{\\mathrm{loose}}$。\n    c. **强耦合模拟**：\n        i.   初始化数组以存储 $u$ 和 $c$ 的历史记录。\n        ii.  从 $t=0$ 到 $T$ 迭代。在每一步中，使用 `scipy.optimize.root_scalar` 求解关于 $u^{n+1}$ 的非线性方程，然后计算 $c^{n+1}$ 和 $B^{n+1}$。\n        iii. 在最后一步之后，计算 $\\varepsilon_{\\mathrm{mass}}^{\\mathrm{strong}}$ 和 $\\varepsilon_{\\mathrm{mom}}^{\\mathrm{strong}}$。\n    d. 整理当前测试用例的四个计算出的误差度量。\n3.  将所有测试用例的结果合并到一个列表中，并格式化以供最终输出。\n\n该过程将在Python中实现，利用 `numpy` 进行数值运算，并利用 `scipy.optimize` 在强耦合方案中进行求根步骤。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the sediment transport problem for three test cases using both\n    loose and strong coupling schemes and computes specified error metrics.\n    \"\"\"\n    g = 9.81  # Gravitational acceleration [m/s^2]\n    rho0 = 1025.0  # Reference water density [kg/m^3]\n\n    test_cases = [\n        # Case 1 (happy path, moderate slope, fine mud)\n        {\n            \"H\": 10.0, \"S\": 1.0e-4, \"Cf\": 3.0e-3, \"tau_c\": 0.20, \"M\": 5.0e-5, \"ws\": 1.0e-3,\n            \"u0\": 0.30, \"c0\": 0.10, \"B0\": 10.0,\n            \"dt\": 2.0, \"T\": 1800.0\n        },\n        # Case 2 (boundary condition near erosion threshold)\n        {\n            \"H\": 10.0, \"S\": 1.0e-4, \"Cf\": 3.0e-3, \"tau_c\": 0.20, \"M\": 1.0e-5, \"ws\": 1.0e-3,\n            \"u0\": 0.25, \"c0\": 0.05, \"B0\": 8.0,\n            \"dt\": 5.0, \"T\": 1800.0\n        },\n        # Case 3 (edge case with coarse time step and faster settling)\n        {\n            \"H\": 5.0, \"S\": 1.5e-4, \"Cf\": 3.0e-3, \"tau_c\": 0.20, \"M\": 5.0e-5, \"ws\": 2.0e-3,\n            \"u0\": 0.40, \"c0\": 0.20, \"B0\": 12.0,\n            \"dt\": 30.0, \"T\": 3600.0\n        }\n    ]\n\n    all_results = []\n\n    def erosion_flux(u, params):\n        \"\"\"Calculates erosion flux e(u).\"\"\"\n        tau_b = rho0 * params[\"Cf\"] * u**2\n        e = params[\"M\"] * np.maximum((tau_b - params[\"tau_c\"]) / params[\"tau_c\"], 0)\n        return e\n\n    def run_loose_coupling(params):\n        \"\"\"Simulates the system using the loose coupling scheme.\"\"\"\n        u, c, B = params[\"u0\"], params[\"c0\"], params[\"B0\"]\n        num_steps = int(params[\"T\"] / params[\"dt\"])\n        \n        u_hist = [u]\n        c_hist = [c]\n\n        for _ in range(num_steps):\n            # Store current values\n            u_n, c_n = u, c\n            \n            # Update velocity (explicit)\n            u = u_n + params[\"dt\"] * (g * params[\"S\"] * (1 + c_n / rho0) - (params[\"Cf\"] / params[\"H\"]) * u_n * np.abs(u_n))\n            \n            # Update concentration (semi-implicit)\n            e_new = erosion_flux(u, params)\n            c = c_n + (params[\"dt\"] / params[\"H\"]) * (e_new - params[\"ws\"] * c_n)\n\n            # Update bed mass (fully explicit on old fluxes)\n            e_old = erosion_flux(u_n, params)\n            B = B - params[\"dt\"] * (e_old - params[\"ws\"] * c_n)\n\n            u_hist.append(u)\n            c_hist.append(c)\n\n        return np.array(u_hist), np.array(c_hist), B\n\n    def run_strong_coupling(params):\n        \"\"\"Simulates the system using the strong coupling scheme.\"\"\"\n        u, c, B = params[\"u0\"], params[\"c0\"], params[\"B0\"]\n        num_steps = int(params[\"T\"] / params[\"dt\"])\n\n        u_hist = [u]\n        c_hist = [c]\n\n        for _ in range(num_steps):\n            u_n, c_n = u, c\n            \n            # Define the function G(u^{n+1}) = 0 to be solved\n            def G(u_next):\n                e_next = erosion_flux(u_next, params)\n                c_next_expr = (params[\"H\"] * c_n + params[\"dt\"] * e_next) / (params[\"H\"] + params[\"dt\"] * params[\"ws\"])\n                \n                term_buoyancy = g * params[\"S\"] * (1 + c_next_expr / rho0)\n                term_friction = (params[\"Cf\"] / params[\"H\"]) * u_next * np.abs(u_next)\n                \n                return u_next - u_n - params[\"dt\"] * (term_buoyancy - term_friction)\n\n            # Solve for u^{n+1}\n            # The root is bracketed by 0 and a sufficiently large velocity\n            sol = root_scalar(G, bracket=[0, 10.0], method='brentq')\n            u = sol.root\n\n            # Calculate c^{n+1}\n            e = erosion_flux(u, params)\n            c = (params[\"H\"] * c_n + params[\"dt\"] * e) / (params[\"H\"] + params[\"dt\"] * params[\"ws\"])\n\n            # Update bed mass\n            B = B - params[\"dt\"] * (e - params[\"ws\"] * c)\n            \n            u_hist.append(u)\n            c_hist.append(c)\n            \n        return np.array(u_hist), np.array(c_hist), B\n\n    def calculate_errors(u_hist, c_hist, B_final, params):\n        H, u0, c0, B0, dt = params[\"H\"], params[\"u0\"], params[\"c0\"], params[\"B0\"], params[\"dt\"]\n        \n        # Mass conservation error\n        initial_mass = H * c0 + B0\n        final_mass = H * c_hist[-1] + B_final\n        if initial_mass == 0:\n            err_mass = 0 if final_mass == 0 else np.inf\n        else:\n            err_mass = np.abs(final_mass - initial_mass) / initial_mass\n\n        # Momentum closure residual\n        N = len(u_hist) - 1\n        res_sq_sum = 0.0\n        for k in range(N):\n            u_k, u_k1 = u_hist[k], u_hist[k+1]\n            c_k, c_k1 = c_hist[k], c_hist[k+1]\n            \n            u_mid = (u_k + u_k1) / 2.0\n            c_mid = (c_k + c_k1) / 2.0\n            \n            dudt_approx = (u_k1 - u_k) / dt\n            forcing_mid = g * params[\"S\"] * (1 + c_mid / rho0) - (params[\"Cf\"] / H) * u_mid * np.abs(u_mid)\n            \n            residual_k = dudt_approx - forcing_mid\n            res_sq_sum += residual_k**2\n        \n        err_mom = np.sqrt(res_sq_sum / N)\n        \n        return err_mass, err_mom\n\n    for case_params in test_cases:\n        # Run loose coupling\n        u_hist_loose, c_hist_loose, B_final_loose = run_loose_coupling(case_params)\n        err_mass_loose, err_mom_loose = calculate_errors(u_hist_loose, c_hist_loose, B_final_loose, case_params)\n\n        # Run strong coupling\n        u_hist_strong, c_hist_strong, B_final_strong = run_strong_coupling(case_params)\n        err_mass_strong, err_mom_strong = calculate_errors(u_hist_strong, c_hist_strong, B_final_strong, case_params)\n        \n        all_results.extend([err_mass_loose, err_mass_strong, err_mom_loose, err_mom_strong])\n\n    print(f\"[{','.join(f'{x:.6e}' for x in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "水沙动力学的控制方程，即浅水方程和Exner方程，构成了一个双曲守恒律系统。要准确捕捉解中的陡峭梯度和激波，需要先进的空间离散化技术。本实践  介绍了一种现代的Godunov型有限体积法，您将通过实现一个HLL近似黎曼求解器来确定单元交界面的水动力状态，并随后计算推移质通量，从而深入了解当前最先进的地貌动力学模型的数值引擎。",
            "id": "3800731",
            "problem": "您的任务是为计算海洋学中的泥沙质量守恒（Exner）方程实现一种一维戈杜诺夫型推移质输运数值通量。从第一性原理和广为接受的闭合关系出发，设计一种算法，该算法使用近似黎曼求解器来确定水动力界面状态，从而计算有限体积法中使用的界面推移质通量。您的最终程序必须为给定的左右状态集计算界面上的 Exner 通量，并为指定的测试套件输出结果。\n\n使用的基本原理：\n- 泥沙质量守恒（Exner 方程）：河床高程 $z_b(x,t)$ 的演变遵循\n$$\n\\frac{\\partial z_b}{\\partial t} + \\frac{1}{1-\\lambda_p} \\frac{\\partial q_s}{\\partial x} = 0,\n$$\n其中 $q_s(x,t)$ 是单位宽度的推移质输运率，$\\lambda_p$ 是床沙孔隙率。\n- 浅水动力学：守恒变量为 $U = [h, h u]^\\top$，其中水深为 $h(x,t)$，垂向平均流速为 $u(x,t)$；通量函数为 $F(U) = [h u, h u^2 + \\tfrac{1}{2} g h^2]^\\top$。特征速度为 $u \\pm \\sqrt{g h}$。\n- 通过 Meyer-Peter–Müller 公式的推移质输运闭合关系：定义希尔兹参数\n$$\n\\theta^\\ast = \\frac{\\tau_b}{(\\rho_s - \\rho_w) g D},\n$$\n其中床面剪切应力建模为\n$$\n\\tau_b = \\rho_w C_f u^2,\n$$\n其中 $\\rho_w$ 是水体密度，$\\rho_s$ 是泥沙密度，$g$ 是重力加速度，$D$ 是颗粒粒径，$C_f$ 是无量纲摩阻系数。当 $\\theta^\\ast  \\theta_c$ 时，无量纲推移质输运率为\n$$\n\\Phi_b = 8\\left(\\theta^\\ast - \\theta_c\\right)^{3/2},\n$$\n推移质输运强度为\n$$\nq_b = \\Phi_b \\sqrt{(s - 1) g D^3},\\quad s = \\frac{\\rho_s}{\\rho_w}.\n$$\n如果 $\\theta^\\ast \\le \\theta_c$，则设 $q_b = 0$。\n- 坡度修正：通过一个施加于强度上的乘法因子来考虑缓和的顺流向河床坡度 $S_b$，\n$$\nq_b' = q_b \\max\\left(0, 1 - \\beta_s S_b\\right),\\quad S_b \\approx \\frac{z_{b,R} - z_{b,L}}{\\Delta x},\n$$\n并使用 $\\operatorname{sign}(u^\\ast)$ 来应用输运方向，其中 $u^\\ast$ 是从水动力黎曼求解器获得的界面流速。\n\n近似黎曼求解器策略：\n- 使用 Harten–Lax–van Leer (HLL) 近似黎曼求解器，根据由特征速度 $u \\pm \\sqrt{g h}$ 计算出的极值波速 $S_L$ 和 $S_R$，从左右状态 $(h_L,u_L)$ 和 $(h_R,u_R)$ 构建界面水动力状态 $U^\\ast$。\n- 从 $U^\\ast$ 中提取 $h^\\ast$ 和 $u^\\ast = (h u)^\\ast / h^\\ast$（并对水深趋近于零的情况采取适当的保护措施），然后如上所述评估 $q_b'$ 并构建 Exner 数值通量\n$$\n\\mathcal{F}_{\\text{Exner}} = \\frac{q_b'}{1 - \\lambda_p}.\n$$\n\n单位与输出：\n- 所有物理量必须使用国际单位制处理：水深单位为米（$\\mathrm{m}$），流速单位为米每秒（$\\mathrm{m/s}$），密度单位为千克每立方米（$\\mathrm{kg/m^3}$），重力加速度单位为米每二次方秒（$\\mathrm{m/s^2}$），颗粒粒径单位为米（$\\mathrm{m}$），单位宽度的推移质和 Exner 通量单位为平方米每秒（$\\mathrm{m^2/s}$）。\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,\\dots]$，其中每个 $r_i$ 是相应测试案例的 Exner 数值通量 $\\mathcal{F}_{\\text{Exner}}$，单位为 $\\mathrm{m^2/s}$。\n\n测试套件：\n对于每个测试案例，给定的左右水动力状态、河床状态以及材料参数为一个元组\n$$\n(h_L, u_L, h_R, u_R, z_{b,L}, z_{b,R}, D, \\lambda_p, C_f, \\beta_s, \\Delta x, g, \\rho_w, \\rho_s, \\theta_c),\n$$\n所有单位均如上文指定。使用以下五个案例：\n- 案例 1：$(3.0, 1.2, 2.5, 1.0, 0.0, 0.05, 0.0005, 0.4, 0.004, 0.5, 10.0, 9.81, 1025.0, 2650.0, 0.047)$\n- 案例 2：$(2.0, 0.2, 2.0, 0.15, 0.1, 0.099, 0.0010, 0.4, 0.004, 0.5, 10.0, 9.81, 1025.0, 2650.0, 0.047)$\n- 案例 3：$(1.0, 0.48, 1.1, 0.5, 0.0, -0.02, 0.0010, 0.35, 0.004, 0.5, 20.0, 9.81, 1025.0, 2650.0, 0.047)$\n- 案例 4：$(1.5, 1.4, 0.01, 0.0, 0.2, 0.21, 0.0007, 0.4, 0.005, 0.5, 5.0, 9.81, 1025.0, 2650.0, 0.047)$\n- 案例 5：$(2.0, 1.0, 2.5, -0.8, 0.0, 0.0, 0.0006, 0.4, 0.0045, 0.5, 10.0, 9.81, 1025.0, 2650.0, 0.047)$\n\n要求：\n- 实现 Harten–Lax–van Leer (HLL) 近似黎曼求解器以计算界面水动力状态 $U^\\ast$。\n- 使用 Meyer-Peter–Müller 闭合关系和指定的坡度修正来计算 $q_b'$ 和 Exner 数值通量 $\\mathcal{F}_{\\text{Exner}}$。\n- 对于每个测试案例，计算并返回单个浮点数 $\\mathcal{F}_{\\text{Exner}}$，单位为 $\\mathrm{m^2/s}$。\n- 您的程序应生成单行输出，其中包含一个包含五个数值通量的列表，格式需严格遵守 $[r_1,r_2,r_3,r_4,r_5]$，使用 Python $3.12$ 及指定的库。",
            "solution": "此任务旨在为泥沙质量守恒（Exner）方程实现一种戈杜诺夫型数值通量，该方法用于有限体积法中地貌动力学建模。该方法的核心是在每个单元界面求解一个局部黎曼问题，以确定控制通量的状态。该过程分为两个主要部分：首先，使用近似求解器求解水动力黎曼问题以找到界面流动状态；其次，利用该流动状态通过经验性闭合关系计算推移质泥沙输运率。\n\n河床高程 $z_b(x,t)$ 的演变由泥沙质量守恒的 Exner 方程描述：\n$$\n\\frac{\\partial z_b}{\\partial t} + \\frac{1}{1-\\lambda_p} \\frac{\\partial q_s}{\\partial x} = 0\n$$\n此处，$q_s(x,t)$ 是单位宽度的体积推移质输运率，$\\lambda_p$ 是床沙的孔隙率。在有限体积框架中，将此方程在控制体积上积分，会得到一个更新公式，该公式需要在单元界面处有数值通量 $\\mathcal{F}_{\\text{Exner}}$。该通量通过 $\\mathcal{F}_{\\text{Exner}} = q_s / (1 - \\lambda_p)$ 与泥沙输运率相关联。\n\n泥沙输运 $q_s$ 主要由上覆水流驱动，此处由一维浅水方程（SWE）建模。SWE 的守恒变量是 $U = [h, hu]^\\top$，其中 $h$ 是水深，$u$ 是垂向平均流速。这些量的通量由向量 $F(U) = [hu, hu^2 + \\tfrac{1}{2}gh^2]^\\top$ 给出，其中 $g$ 是重力加速度。该系统是双曲型的，其特征速度（特征值）为 $\\lambda = u \\pm \\sqrt{gh}$。\n\n河床与水流之间的耦合通过以下假设来处理：在水动力黎曼问题的快速时间尺度上，河床是固定的。首先求解水动力学，然后利用得到的界面流动状态来计算泥沙输运，而泥沙输运反过来在较慢的时间尺度上驱动河床演变。\n\n**步骤 1：通过 HLL 黎曼求解器获取水动力界面状态**\n\n在左状态 $(h_L, u_L)$ 和右状态 $(h_R, u_R)$ 之间的界面上，形成一个黎曼问题。我们使用 Harten–Lax–van Leer (HLL) 近似黎曼求解器来寻找界面水动力状态。HLL 求解器近似了黎曼扇内的解，该区域由最慢和最快的波速 $S_L$ 和 $S_R$ 界定。估算这些速度的一种标准方法是取左右状态特征速度的最小值和最大值：\n$$\nS_L = \\min(u_L - \\sqrt{gh_L}, u_R - \\sqrt{gh_R})\n$$\n$$\nS_R = \\max(u_L + \\sqrt{gh_L}, u_R + \\sqrt{gh_R})\n$$\nHLL 求解器假设在 $S_L  x/t  S_R$ 定义的区域内存在一个单一常数状态 $U^\\ast = [h^\\ast, (hu)^\\ast]^\\top$。界面处（$x/t=0$）的状态由 $S_L$ 和 $S_R$ 的符号决定：\n- 若 $S_L \\ge 0$，则整个波结构向右传播，界面处的状态为左状态 $U_L$。\n- 若 $S_R \\le 0$，则整个波结构向左传播，界面处的状态为右状态 $U_R$。\n- 若 $S_L  0  S_R$，则界面位于“星”区内。HLL 平均状态 $U^\\ast$ 由下式给出：\n$$\nU^\\ast = \\frac{S_R U_R - S_L U_L - (F_R - F_L)}{S_R - S_L}\n$$\n其中 $U_L = [h_L, h_L u_L]^\\top$，$U_R = [h_R, h_R u_R]^\\top$，而 $F_L, F_R$ 是相应的 SWE 通量向量。从守恒状态 $U^\\ast$ 中，我们提取界面流动的原始变量：水深 $h^\\ast$ 和流速 $u^\\ast = (hu)^\\ast / h^\\ast$。当 $h^\\ast$ 接近于零时，需要有保护措施，此时可将 $u^\\ast$ 设为零。\n\n**步骤 2：推移质输运计算**\n\n在确定界面流速 $u^\\ast$ 后，我们使用 Meyer-Peter–Müller (MPM) 经验公式计算推移质输运率。\n首先，我们计算由水流引起的床面剪切应力 $\\tau_b$，其通过二次摩阻定律建模：\n$$\n\\tau_b^\\ast = \\rho_w C_f (u^\\ast)^2\n$$\n其中 $\\rho_w$ 是水体密度，$C_f$ 是无量纲摩阻系数。\n\n接下来，我们计算希尔兹参数 $\\theta^\\ast$，它是剪切应力的无量纲度量：\n$$\n\\theta^{\\ast\\ast} = \\frac{\\tau_b^\\ast}{(\\rho_s - \\rho_w) g D}\n$$\n其中 $\\rho_s$ 是泥沙密度，$D$ 是中值粒径。\n\nMPM 公式包含一个临界希尔兹参数 $\\theta_c$，代表泥沙的起动阈值。只有当 $\\theta^{\\ast\\ast} > \\theta_c$ 时，才会发生泥沙输运。如果满足此条件，无量纲推移质输运率 $\\Phi_b$ 由下式给出：\n$$\n\\Phi_b^\\ast = 8 (\\theta^{\\ast\\ast} - \\theta_c)^{3/2}\n$$\n如果 $\\theta^{\\ast\\ast} \\le \\theta_c$，则 $\\Phi_b^\\ast = 0$。\n\n然后，通过缩放 $\\Phi_b$ 来找到推移质输运率的有量纲强度 $q_b$：\n$$\nq_b^\\ast = \\Phi_b^\\ast \\sqrt{(s-1)gD^3}\n$$\n其中 $s = \\rho_s / \\rho_w$ 是泥沙的比重。\n\n**步骤 3：坡度修正与最终 Exner 通量**\n\n局部河床坡度会影响输运率。作用在泥沙颗粒上的重力下坡分量会增强输运，而上坡分量则会阻碍输运。这一点通过一个乘法修正因子来体现。首先，使用相邻单元的河床高程 $z_{b,L}$ 和 $z_{b,R}$ 以及单元宽度 $\\Delta x$ 来近似界面处的河床坡度 $S_b$：\n$$\nS_b = \\frac{z_{b,R} - z_{b,L}}{\\Delta x}\n$$\n修正后的推移质输运强度 $q_b'$ 则为：\n$$\nq_b'^\\ast = q_b^\\ast \\max(0, 1 - \\beta_s S_b)\n$$\n其中 $\\beta_s$ 是一个经验参数。$\\max(0, \\dots)$ 项防止了泥沙在非常陡的逆坡上进行输运。\n\n最后，推移质输运是一个矢量。其方向由水流方向决定。界面处的有向泥沙输运率 $q_s^\\ast$ 为：\n$$\nq_s^\\ast = \\operatorname{sign}(u^\\ast) q_b'^\\ast\n$$\n其中，当 $u^\\ast > 0$ 时 $\\operatorname{sign}(u^\\ast)$ 为 $+1$，当 $u^\\ast  0$ 时为 $-1$，当 $u^\\ast = 0$ 时为 $0$。\n\nExner 方程的数值通量随后计算如下：\n$$\n\\mathcal{F}_{\\text{Exner}} = \\frac{q_s^\\ast}{1 - \\lambda_p}\n$$\n该值表示跨界面的泥沙体积交换率（已通过活性层体积进行归一化），并用于在有限体积格式中更新河床高程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are imported.\n\ndef solve():\n    \"\"\"\n    Computes the Godunov-type Exner numerical flux for bedload transport for a series of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (h_L, u_L, h_R, u_R, z_b_L, z_b_R, D, lambda_p, C_f, beta_s, delta_x, g, rho_w, rho_s, theta_c)\n        (3.0, 1.2, 2.5, 1.0, 0.0, 0.05, 0.0005, 0.4, 0.004, 0.5, 10.0, 9.81, 1025.0, 2650.0, 0.047),\n        (2.0, 0.2, 2.0, 0.15, 0.1, 0.099, 0.0010, 0.4, 0.004, 0.5, 10.0, 9.81, 1025.0, 2650.0, 0.047),\n        (1.0, 0.48, 1.1, 0.5, 0.0, -0.02, 0.0010, 0.35, 0.004, 0.5, 20.0, 9.81, 1025.0, 2650.0, 0.047),\n        (1.5, 1.4, 0.01, 0.0, 0.2, 0.21, 0.0007, 0.4, 0.005, 0.5, 5.0, 9.81, 1025.0, 2650.0, 0.047),\n        (2.0, 1.0, 2.5, -0.8, 0.0, 0.0, 0.0006, 0.4, 0.0045, 0.5, 10.0, 9.81, 1025.0, 2650.0, 0.047)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        h_L, u_L, h_R, u_R, z_b_L, z_b_R, D, lambda_p, C_f, beta_s, delta_x, g, rho_w, rho_s, theta_c = case\n        \n        # --- Step 1: HLL Approximate Riemann Solver ---\n        \n        # Handle dry states safely\n        h_L = max(0, h_L)\n        h_R = max(0, h_R)\n\n        c_L = np.sqrt(g * h_L)\n        c_R = np.sqrt(g * h_R)\n\n        # Estimate wave speeds (Davis, 1988)\n        S_L = min(u_L - c_L, u_R - c_R)\n        S_R = max(u_L + c_L, u_R + c_R)\n        \n        h_star, u_star = 0.0, 0.0\n\n        if S_L >= 0:\n            # Entire wave structure moves right, state at interface is Left state\n            h_star, u_star = h_L, u_L\n        elif S_R = 0:\n            # Entire wave structure moves left, state at interface is Right state\n            h_star, u_star = h_R, u_R\n        else: # S_L  0  S_R, interface is in star region\n            # Conservative states\n            U_L = np.array([h_L, h_L * u_L])\n            U_R = np.array([h_R, h_R * u_R])\n            \n            # Flux vectors\n            F_L = np.array([h_L * u_L, h_L * u_L**2 + 0.5 * g * h_L**2])\n            F_R = np.array([h_R * u_R, h_R * u_R**2 + 0.5 * g * h_R**2])\n            \n            # HLL-averaged state U*\n            if abs(S_R - S_L) > 1e-9:\n                U_star = (S_R * U_R - S_L * U_L - (F_R - F_L)) / (S_R - S_L)\n                h_star = U_star[0]\n                \n                # Safeguard for vanishing depth\n                if h_star > 1e-9:\n                    u_star = U_star[1] / h_star\n                else:\n                    h_star = 0.0\n                    u_star = 0.0 # No depth, no velocity\n            else: # States are nearly identical\n                h_star, u_star = (h_L + h_R) / 2, (u_L + u_R) / 2\n\n        # --- Step 2: Bedload Transport Calculation (Meyer-Peter-Müller) ---\n        \n        q_s_star = 0.0\n        \n        if h_star > 1e-9:\n            # Bed shear stress\n            tau_b_star = rho_w * C_f * u_star**2\n            \n            # Shields parameter\n            rho_diff_g_D = (rho_s - rho_w) * g * D\n            if rho_diff_g_D > 1e-9:\n                theta_star_star = tau_b_star / rho_diff_g_D\n            else:\n                theta_star_star = 0.0\n\n            if theta_star_star > theta_c:\n                # Dimensionless bedload transport rate\n                Phi_b_star = 8.0 * (theta_star_star - theta_c)**1.5\n                \n                # Dimensional bedload transport magnitude\n                s = rho_s / rho_w\n                q_b_star_factor = np.sqrt(max(0, s - 1.0) * g * D**3)\n                q_b_star = Phi_b_star * q_b_star_factor\n                \n                # --- Step 3: Slope Correction and Final Flux ---\n                \n                # Bed slope\n                S_b = (z_b_R - z_b_L) / delta_x\n                \n                # Corrected bedload magnitude\n                q_b_prime_star = q_b_star * max(0.0, 1.0 - beta_s * S_b)\n                \n                # Directed sediment transport rate\n                q_s_star = np.sign(u_star) * q_b_prime_star\n\n        # Exner numerical flux\n        exner_flux = q_s_star / (1.0 - lambda_p)\n        results.append(exner_flux)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}