{
    "hands_on_practices": [
        {
            "introduction": "在任何显式时间步进的数值模拟中，首要的挑战是确保其稳定性。著名的Courant-Friedrichs-Lewy (CFL) 条件为此提供了基本准则，它将时间步长、网格间距和系统中最快波速联系起来。本练习 () 将引导你推导这一关键约束，特别关注海洋中最快的行星波——海岸开尔文波 (coastal Kelvin wave)，并探讨其对大规模海洋模型计算成本的深远影响。",
            "id": "3800496",
            "problem": "考虑一个位于恒定$f$平面上的无粘、线性、旋转浅水系统，其深度$H$为均匀值，重力加速度为$g$。设海岸线为位于$y=0$处与$x$轴对齐的直线边界，其无正交流边界条件为$v(x,0,t)=0$。假设存在海面高度$\\eta(x,y,t)$以及深度平均速度$u(x,y,t)$和$v(x,y,t)$的小扰动，它们满足线性化旋转浅水方程：\n$$\nu_{t} - f v = - g \\,\\eta_{x}, \\quad v_{t} + f u = - g \\,\\eta_{y}, \\quad \\eta_{t} + H\\,(u_{x} + v_{y}) = 0,\n$$\n其中下标表示偏导数。海岸开尔文波是一种边界捕获解，它向离岸方向衰减并沿海岸传播。从以上方程出发，推导该开尔文波的非色散相速度$c$作为$g$和$H$的函数。\n\n现在考虑由线性平流偏微分方程(PDE) $\\eta_{t} + c\\,\\eta_{x} = 0$ 控制的开尔文波包的单向沿岸传播。假设$c>0$，在一个空间间距为$\\Delta x$、时间步长为$\\Delta t$的均匀网格上，使用空间上的一阶迎风有限差分和时间上的前向欧拉法对此PDE进行离散化。对所得的显式格式进行von Neumann稳定性分析，以确定$\\Delta t$关于$\\Delta x$和$c$的稳定性约束。在您的推导中，明确引入Courant–Friedrichs–Lewy (CFL)数$\\lambda$和放大因子，并得出对于所有傅里叶模态，放大因子的模长小于或等于一的条件。\n\n最后，对于一个海盆尺度模型，其配置为$H = 4000\\,\\mathrm{m}$，$g = 9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$，沿岸水平网格间距$\\Delta x = 25\\,\\mathrm{km}$，使用您的稳定性结果计算能够解析快速正压开尔文波的最大稳定显式时间步长$\\Delta t_{\\max}$。将您的数值答案四舍五入至四位有效数字，并以秒为单位表示。根据您的推导，简要解释此稳定性约束对于在同一显式模型中解析慢行星罗斯贝波的影响。",
            "solution": "用户提供了一个关于海岸开尔文波及其模拟的数值稳定性的多部分问题。该问题在科学上是合理的、适定的和客观的。这是地球物理流体动力学和计算方法中的一个标准问题。我将按要求分三部分来解决它。\n\n第一部分：开尔文波相速度的推导\n\n控制方程是在恒定$f$平面上，对于深度均匀$H$的无粘流体的线性化旋转浅水方程：\n$$u_{t} - f v = - g \\,\\eta_{x} \\quad (1)$$\n$$v_{t} + f u = - g \\,\\eta_{y} \\quad (2)$$\n$$\\eta_{t} + H\\,(u_{x} + v_{y}) = 0 \\quad (3)$$\n边界条件是在海岸$y=0$处无正交流，即$v(x,0,t)=0$。\n\n海岸开尔文波是该系统的一个特殊解，它被捕获在边界上并沿其传播。开尔文波的一个定义性特征是跨岸速度处处为零，即对于所有的$x, y, t$，都有$v(x,y,t)=0$。这恒满足$y=0$处的边界条件。当$v=0$时，方程组大大简化为：\n由(1)式：$u_{t} = -g\\eta_{x} \\quad (4)$\n由(2)式：$f u = -g\\eta_{y} \\quad (5)$\n由(3)式：$\\eta_{t} + H u_{x} = 0 \\quad (6)$\n\n方程(5)代表跨岸（$y$）方向的地转平衡。方程(4)和(6)描述了沿岸（$x$）方向的波传播。为了求出相速度，我们可以结合(4)和(6)。将(6)对$t$求导，将(4)对$x$求导：\n$$\\eta_{tt} + H u_{xt} = 0$$\n$$u_{tx} = -g \\eta_{xx}$$\n假设场足够光滑，微分的顺序无关（$u_{xt} = u_{tx}$）。将第二个方程代入第一个方程得到：\n$$\\eta_{tt} - gH \\eta_{xx} = 0$$\n这是关于海面高度$\\eta$的一维波动方程。其通解描述了以相速度$c$（由$c^2=gH$给出）在$\\pm x$方向上传播的波。因此，相速度为：\n$$c = \\sqrt{gH}$$\n由于相速度$c$不依赖于波数或频率，所以该波是非色散的。\n\n为了确认其边界捕获特性，我们考察方程(5)，$fu = -g\\eta_y$。我们寻找一个在$+x$方向传播的解，其形式为$\\eta(x,y,t) = F(y)G(x-ct)$。从波动方程可知，$u$也具有这种形式。从(4)式，$u_t = -c u'$，以及$\\eta_x = \\eta'$，其中撇号表示对自变量$x-ct$求导。因此，$-cu' = -g\\eta'$，积分得到$u = (g/c)\\eta$（假设纯波动解的积分常数为零）。将此代入(5)式：\n$$f \\left(\\frac{g}{c}\\eta\\right) = -g \\frac{\\partial \\eta}{\\partial y}$$\n$$\\frac{\\partial \\eta}{\\partial y} = -\\frac{f}{c}\\eta$$\n$\\eta$的离岸结构解为$\\eta(x,y,t) = \\eta_0(x-ct) \\exp\\left(-\\frac{f}{c}y\\right)$。为了使波被捕获在海岸（即当$y \\rightarrow \\infty$时衰减），指数必须为负。由于$c=\\sqrt{gH}$为正且$y>0$，这要求科里奥利参数$f$为正。这对应于在北半球传播时海岸在其右侧的波。\n\n第二部分：Von Neumann稳定性分析\n\n问题要求分析单向平流方程$\\eta_t + c\\,\\eta_x=0$（其中$c > 0$）的数值格式的稳定性。该格式在时间上采用前向欧拉法，在空间上采用一阶迎风格式。\n设$\\eta_j^n$表示在网格点$x_j=j\\Delta x$和时间$t_n=n\\Delta t$的数值解。\n前向欧拉时间差分为：$\\eta_t \\approx \\frac{\\eta_j^{n+1} - \\eta_j^n}{\\Delta t}$。\n由于波在$+x$方向上传播（$c>0$），“迎风”方向是$-x$方向。因此，我们对空间导数使用一阶后向差分：$\\eta_x \\approx \\frac{\\eta_j^n - \\eta_{j-1}^n}{\\Delta x}$。\n\n将这些代入PDE，得到有限差分方程：\n$$\\frac{\\eta_j^{n+1} - \\eta_j^n}{\\Delta t} + c \\frac{\\eta_j^n - \\eta_{j-1}^n}{\\Delta x} = 0$$\n我们求解$\\eta_j^{n+1}$：\n$$\\eta_j^{n+1} = \\eta_j^n - \\frac{c \\Delta t}{\\Delta x} (\\eta_j^n - \\eta_{j-1}^n)$$\n我们引入Courant–Friedrichs–Lewy (CFL)数，$\\lambda = \\frac{c \\Delta t}{\\Delta x}$。方程变为：\n$$\\eta_j^{n+1} = \\eta_j^n - \\lambda (\\eta_j^n - \\eta_{j-1}^n) = (1-\\lambda)\\eta_j^n + \\lambda \\eta_{j-1}^n$$\n对于von Neumann稳定性分析，我们考虑单个傅里叶模态作为解：\n$$\\eta_j^n = G^n e^{ik j \\Delta x}$$\n此处，$k$是波数，$G$是复放大因子。如果对于所有可能的波数，都有$|G| \\le 1$，则该格式是稳定的。\n将傅里叶模态代入差分方程：\n$$G^{n+1} e^{ik j \\Delta x} = (1-\\lambda) G^n e^{ik j \\Delta x} + \\lambda G^n e^{ik (j-1) \\Delta x}$$\n两边同除以$G^n e^{ik j \\Delta x}$：\n$$G = (1-\\lambda) + \\lambda e^{-ik \\Delta x}$$\n令无量纲波数为$\\theta = k \\Delta x$。则$e^{-ik \\Delta x} = \\cos(\\theta) - i\\sin(\\theta)$。\n$$G = (1-\\lambda) + \\lambda (\\cos(\\theta) - i\\sin(\\theta)) = (1-\\lambda + \\lambda\\cos(\\theta)) - i(\\lambda\\sin(\\theta))$$\n放大因子的模的平方为$|G|^2$：\n$$|G|^2 = (1-\\lambda + \\lambda\\cos(\\theta))^2 + (-\\lambda\\sin(\\theta))^2$$\n$$|G|^2 = (1-\\lambda)^2 + 2\\lambda(1-\\lambda)\\cos(\\theta) + \\lambda^2\\cos^2(\\theta) + \\lambda^2\\sin^2(\\theta)$$\n$$|G|^2 = (1-2\\lambda+\\lambda^2) + 2\\lambda(1-\\lambda)\\cos(\\theta) + \\lambda^2(\\cos^2(\\theta)+\\sin^2(\\theta))$$\n$$|G|^2 = 1-2\\lambda+\\lambda^2 + 2\\lambda\\cos(\\theta) - 2\\lambda^2\\cos(\\theta) + \\lambda^2$$\n$$|G|^2 = 1 - 2\\lambda(1-\\cos(\\theta)) + 2\\lambda^2(1-\\cos(\\theta))$$\n$$|G|^2 = 1 - 2\\lambda(1-\\lambda)(1-\\cos\\theta)$$\n为了保证稳定性，我们要求对于所有实数$\\theta$，都有$|G|^2 \\le 1$。这意味着：\n$$1 - 2\\lambda(1-\\lambda)(1-\\cos\\theta) \\le 1$$\n$$-2\\lambda(1-\\lambda)(1-\\cos\\theta) \\le 0$$\n由于$\\Delta t>0$和$\\Delta x>0$，并且给定$c>0$，所以CFL数$\\lambda$是正的。项$(1-\\cos\\theta)$对于任何实数$\\theta$总是非负的。因此，我们可以将不等式两边同除以非正项$-2(1-\\cos\\theta)$（对于$\\theta \\neq 2n\\pi$）并反转不等号，或者我们可以分析各个因子。为了使不等式成立，乘积$\\lambda(1-\\lambda)$必须是非负的。\n由于$\\lambda > 0$，我们必须有$1-\\lambda \\ge 0$，这意味着$\\lambda \\le 1$。\n将$\\lambda$的正性与此结果相结合，稳定性条件是：\n$$0 \\le \\lambda \\le 1$$\n将$\\lambda = \\frac{c \\Delta t}{\\Delta x}$代回：这得出了对时间步长$\\Delta t$的稳定性约束：\n$$\\Delta t \\le \\frac{\\Delta x}{c}$$\n\n第三部分：数值计算与影响\n\n首先，我们使用给定值$g = 9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$和$H = 4000\\,\\mathrm{m}$计算正压开尔文波的相速度$c$。\n$$c = \\sqrt{gH} = \\sqrt{(9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2})(4000\\,\\mathrm{m})} = \\sqrt{39240\\,\\mathrm{m}^2\\,\\mathrm{s}^{-2}} \\approx 198.0909\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$$\n接下来，我们使用第二部分中推导出的稳定性约束来确定最大稳定时间步长$\\Delta t_{\\max}$。给定的网格间距为$\\Delta x = 25\\,\\mathrm{km} = 25000\\,\\mathrm{m}$。\n$$\\Delta t_{\\max} = \\frac{\\Delta x}{c} = \\frac{25000\\,\\mathrm{m}}{198.0909\\,\\mathrm{m}\\,\\mathrm{s}^{-1}} \\approx 126.204\\,\\mathrm{s}$$\n四舍五入到四位有效数字，最大稳定时间步长为$126.2\\,\\mathrm{s}$。\n\n对解析慢行星罗斯贝波的影响：\n显式时间步进格式的稳定性由Courant–Friedrichs–Lewy (CFL)条件决定。该条件确保数值依赖区域包含物理依赖区域。约束$\\Delta t \\le \\Delta x/c$由系统中最快的传播波决定，在本例中即为速度约$200\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$的正压开尔文波。这导致一个非常小的最大允许时间步长，$\\Delta t_{\\max} \\approx 2.1\\,\\mathrm{分钟}$。\n\n然而，行星罗斯贝波是慢得多的现象。其传播速度比开尔文波的速度小几个数量级，其特征时间尺度在几周到几年之间。如果在气候学相关的时间段（例如，几十年）内模拟这些慢波的演变，若模型受$\\Delta t_{\\max}$的限制，将需要巨大的时间步数。例如，模拟一年大约需要$(365 \\times 24 \\times 3600) / 126.2 \\approx 2.5 \\times 10^5$步。这使得使用简单的显式模型来研究移动缓慢的罗斯贝波在计算上是不可行的。这个问题，即系统中包含时间尺度差异巨大的过程，被称为刚性问题，是地球物理流体计算模拟中的一个主要挑战。为克服此问题，海洋模型通常采用半隐式或全隐式时间步进方法，或采用模态分裂技术，该技术对系统中的快慢模态进行不同处理，从而允许对慢动力过程使用更大的时间步长。",
            "answer": "$$\n\\boxed{126.2}\n$$"
        },
        {
            "introduction": "模型稳定后，下一个关键问题是其准确性，这取决于网格是否足够精细以解析感兴趣的物理结构。这个动手编码练习 () 旨在量化网格分辨率与准确表示关键陷波结构之间的关系。通过这项实践，你将为模型设置建立起基于经验的准则，即确定每个变形半径内需要多少个网格点才能达到可接受的精度。",
            "id": "3800508",
            "problem": "您的任务是量化相对于变形半径 $R_d$ 的网格分辨率如何影响与行星罗斯贝波和开尔文波相关的捕获波结构的数值精度，然后以每个 $R_d$ 的点数提出最低分辨率标准。计算基础必须源自$f$平面或$\\beta$平面上的线性化旋转浅水方程，以及已知的海岸和赤道波导的捕获本征函数。\n\n使用的基本基础和定义：\n- 变形半径 $R_d$ 在$f$平面上定义为 $R_d = \\sqrt{g H} / |f|$，其中 $g$ 是重力加速度，$H$ 是层厚，$f$ 是科里奥利参数；它设定了海岸开尔文波的跨波导捕获尺度。对于$\\beta$平面上的赤道波导，经向捕获尺度为 $L_e = \\sqrt{c / \\beta}$，其中重力波速 $c = \\sqrt{g H}$ 且 $\\beta = \\partial f / \\partial y$。在本问题中，将符号 $R_d$ 视为用于海岸和赤道经向结构的捕获尺度。\n- 在平直海岸（$y \\ge 0$）上的海岸开尔文波经向结构可以通过跨岸振幅 $\\phi_K(y) = \\exp(-y / R_d)$ 来表示。\n- 赤道捕获模态的经向结构与高斯函数和Hermite函数成正比。使用以下规范形式：\n  1. 赤道开尔文波：$\\phi_{EK}(y) = \\exp\\left(-\\dfrac{y^2}{2 R_d^2}\\right)$。\n  2. 第一赤道罗斯贝模态（$n = 1$）：$\\phi_{ER1}(y) = 2 \\dfrac{y}{R_d} \\exp\\left(-\\dfrac{y^2}{2 R_d^2}\\right)$。\n\n目标：\n- 对于每个捕获结构 $\\phi(y)$，将经向坐标 $y \\in [0, L]$ 在均匀网格上离散化，网格间距为 $\\Delta y = R_d / p$，其中 $p$ 是每个 $R_d$ 的网格点数，域长度 $L = N_{R_d} R_d$，其中 $N_{R_d}$ 为整数。所有长度必须以米为单位处理。\n- 使用中心二阶有限差分算子，近似经向导数：\n  $$D_{\\Delta y} \\phi(y_i) = \\dfrac{\\phi(y_{i+1}) - \\phi(y_{i-1})}{2 \\Delta y},$$\n  在内部网格点 $y_i$（$i = 1, \\dots, N-2$）处，其中 $N$ 是网格点总数。\n- 计算解析经向导数 $\\dfrac{d \\phi}{d y}$，并评估数值导数近似的相对离散$L^2$误差：\n  $$E = \\dfrac{\\left( \\int_{0}^{L} \\left[ D_{\\Delta y} \\phi(y) - \\dfrac{d \\phi}{d y}(y) \\right]^2 \\, dy \\right)^{1/2}}{\\left( \\int_{0}^{L} \\left[ \\dfrac{d \\phi}{d y}(y) \\right]^2 \\, dy \\right)^{1/2}}.$$\n  使用内部网格点上的黎曼和来近似积分，并使用 $\\Delta y$ 作为求积权重。本问题不使用角度，因此无需指定角度单位。\n- 对于给定的容差 $\\varepsilon$（以小数形式表示），确定满足 $E \\le \\varepsilon$ 的最小整数 $p$。如果没有测试值满足容差，则返回 $-1$。\n\n测试套件：\n- 情况1：海岸开尔文波，$R_d = 50000$米，$N_{R_d} = 5$，容差 $\\varepsilon = 0.05$。\n- 情况2：赤道开尔文波，$R_d = 150000$米，$N_{R_d} = 6$，容差 $\\varepsilon = 0.02$。\n- 情况3：第一赤道罗斯贝模态，$R_d = 150000$米，$N_{R_d} = 6$，容差 $\\varepsilon = 0.03$。\n- 情况4：海岸开尔文波，$R_d = 30000$米，$N_{R_d} = 3$，容差 $\\varepsilon = 0.01$。\n- 情况5：赤道开尔文波，$R_d = 100000$米，$N_{R_d} = 2$，容差 $\\varepsilon = 0.08$。\n\n在候选集 $\\{2, 3, 4, 5, 6, 8, 10, 12, 16, 20, 24, 32, 40, 48, 64\\}$ 中搜索 $p$。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含五个测试用例的最小单位$R_d$点数值，格式为方括号内的逗号分隔列表，例如 $[p_1,p_2,p_3,p_4,p_5]$，其中每个 $p_i$ 是一个整数，如果没有任何候选值满足标准，则为 $-1$。\n\n所有长度必须以米为单位。容差 $\\varepsilon$ 必须作为小数处理。",
            "solution": "该问题被认为是有效的。它在科学上基于地球物理流体动力学和数值分析的原理，特别是关于波动方程的离散化。该问题是适定的，所有必要的函数、参数和评估标准都已明确定义，从而可以得到一个唯一且可验证的解。没有矛盾、歧义或事实不准确之处。\n\n核心任务是确定所需的最小网格分辨率（以每个变形半径的网格点数 $p$ 来量化），以便使用有限差分法准确表示海洋捕获波的经向结构。精度是通过数值计算的一阶导数与解析导数相比的相对$L^2$误差来衡量的，该误差必须低于指定的容差 $\\varepsilon$。\n\n每个测试用例的方法如下：\n1.  **定义解析结构**：问题指定了三种规范的经向结构 $\\phi(y)$ 及其解析一阶导数 $\\dfrac{d\\phi}{dy}$。\n    *   对于海岸开尔文波：\n        $$ \\phi_K(y) = \\exp(-y / R_d) $$\n        $$ \\dfrac{d\\phi_K}{dy} = -\\dfrac{1}{R_d} \\exp(-y / R_d) $$\n    *   对于赤道开尔文波：\n        $$ \\phi_{EK}(y) = \\exp\\left(-\\dfrac{y^2}{2 R_d^2}\\right) $$\n        $$ \\dfrac{d\\phi_{EK}}{dy} = -\\dfrac{y}{R_d^2} \\exp\\left(-\\dfrac{y^2}{2 R_d^2}\\right) $$\n    *   对于第一赤道罗斯贝模态（$n=1$）：\n        $$ \\phi_{ER1}(y) = 2 \\dfrac{y}{R_d} \\exp\\left(-\\dfrac{y^2}{2 R_d^2}\\right) $$\n        $$ \\dfrac{d\\phi_{ER1}}{dy} = \\dfrac{2}{R_d} \\left(1 - \\dfrac{y^2}{R_d^2}\\right) \\exp\\left(-\\dfrac{y^2}{2 R_d^2}\\right) $$\n    在这些方程中，$y$是经向坐标，$R_d$是相关的捕获尺度（变形半径）。\n\n2.  **建立数值网格**：连续域 $y \\in [0, L]$被离散化为一个均匀网格。域长度为 $L = N_{R_d} R_d$，其中 $N_{R_d}$ 是一个指定的整数乘数。网格间距为 $\\Delta y = R_d / p$，其中 $p$是每个$R_d$的点数。网格点总数为 $N = N_{R_d} p + 1$。网格点位于 $y_i = i \\cdot \\Delta y$，其中 $i = 0, 1, \\dots, N-1$。\n\n3.  **近似导数**：一阶导数在内部网格点 $y_i$（$i = 1, \\dots, N-2$）处使用二阶中心有限差分格式进行近似：\n    $$ D_{\\Delta y} \\phi(y_i) = \\dfrac{\\phi(y_{i+1}) - \\phi(y_{i-1})}{2 \\Delta y} $$\n    该公式提供了在每个内部点 $y_i$ 处 $\\dfrac{d\\phi}{dy}$ 的数值近似。\n\n4.  **计算离散误差**：计算相对$L^2$误差 $E$。$E$ 定义中的积分使用内部网格点集 $\\{y_i\\}_{i=1}^{N-2}$ 上的黎曼和进行近似。\n    $$ E = \\dfrac{\\left( \\sum_{i=1}^{N-2} \\left[ D_{\\Delta y} \\phi(y_i) - \\dfrac{d \\phi}{d y}(y_i) \\right]^2 \\Delta y \\right)^{1/2}}{\\left( \\sum_{i=1}^{N-2} \\left[ \\dfrac{d \\phi}{d y}(y_i) \\right]^2 \\Delta y \\right)^{1/2}} $$\n    求积权重 $\\Delta y$ 在分子和分母中是公共的，因此可以消去。表达式简化为向量范数的比值：\n    $$ E = \\dfrac{\\left\\| \\mathbf{D}_{\\text{num}} - \\mathbf{D}_{\\text{ana}} \\right\\|_2}{\\left\\| \\mathbf{D}_{\\text{ana}} \\right\\|_2} $$\n    其中 $\\mathbf{D}_{\\text{num}}$ 是内部点上数值导数值的向量，$\\mathbf{D}_{\\text{ana}}$ 是同一点上解析导数值的向量，$\\| \\cdot \\|_2$ 表示欧几里得范数。\n\n5.  **确定最小分辨率**：对于每个测试用例，我们遍历有序的 $p$ 候选集，即 $\\{2, 3, 4, 5, 6, 8, 10, 12, 16, 20, 24, 32, 40, 48, 64\\}$。对于每个 $p$ 值，计算误差 $E$。集合中第一个满足 $E \\le \\varepsilon$ 的 $p$ 值即为该情况下的最小所需分辨率。如果集合中没有 $p$ 值满足该标准，则该情况的结果为 $-1$。\n\n此过程系统地应用于问题陈述中提供的五个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the minimal grid resolution (points per deformation radius)\n    for accurately representing oceanic wave structures.\n    \"\"\"\n\n    # --- Analytical Wave Structures and Their Derivatives ---\n\n    def phi_coastal_kelvin(y, Rd):\n        \"\"\"Meridional structure of a Coastal Kelvin wave.\"\"\"\n        return np.exp(-y / Rd)\n\n    def d_phi_coastal_kelvin(y, Rd):\n        \"\"\"Analytical derivative of the Coastal Kelvin wave structure.\"\"\"\n        return (-1 / Rd) * np.exp(-y / Rd)\n\n    def phi_equatorial_kelvin(y, Rd):\n        \"\"\"Merididional structure of an Equatorial Kelvin wave.\"\"\"\n        return np.exp(-y**2 / (2 * Rd**2))\n\n    def d_phi_equatorial_kelvin(y, Rd):\n        \"\"\"Analytical derivative of the Equatorial Kelvin wave structure.\"\"\"\n        return (-y / Rd**2) * np.exp(-y**2 / (2 * Rd**2))\n\n    def phi_equatorial_rossby1(y, Rd):\n        \"\"\"Meridional structure of the first Equatorial Rossby mode.\"\"\"\n        return 2 * (y / Rd) * np.exp(-y**2 / (2 * Rd**2))\n\n    def d_phi_equatorial_rossby1(y, Rd):\n        \"\"\"Analytical derivative of the first Equatorial Rossby mode structure.\"\"\"\n        term1 = 2 / Rd\n        term2 = 1 - y**2 / Rd**2\n        term3 = np.exp(-y**2 / (2 * Rd**2))\n        return term1 * term2 * term3\n\n    # Dictionary to map wave types to their respective functions\n    wave_functions = {\n        'Coastal Kelvin': {'phi': phi_coastal_kelvin, 'd_phi': d_phi_coastal_kelvin},\n        'Equatorial Kelvin': {'phi': phi_equatorial_kelvin, 'd_phi': d_phi_equatorial_kelvin},\n        'First equatorial Rossby': {'phi': phi_equatorial_rossby1, 'd_phi': d_phi_equatorial_rossby1}\n    }\n\n    # --- Problem Parameters ---\n\n    # Candidate set for p (points per deformation radius)\n    p_candidates = [2, 3, 4, 5, 6, 8, 10, 12, 16, 20, 24, 32, 40, 48, 64]\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (wave_type, Rd_meters, N_Rd, epsilon_tolerance)\n        ('Coastal Kelvin', 50000.0, 5, 0.05),\n        ('Equatorial Kelvin', 150000.0, 6, 0.02),\n        ('First equatorial Rossby', 150000.0, 6, 0.03),\n        ('Coastal Kelvin', 30000.0, 3, 0.01),\n        ('Equatorial Kelvin', 100000.0, 2, 0.08)\n    ]\n\n    results = []\n    for case in test_cases:\n        wave_type, Rd, N_Rd, epsilon = case\n        \n        phi_func = wave_functions[wave_type]['phi']\n        d_phi_func = wave_functions[wave_type]['d_phi']\n        \n        minimal_p = -1\n        \n        # Iterate through the ordered candidate set to find the minimal p\n        for p in p_candidates:\n            # 1. Set up the numerical grid\n            domain_length_L = N_Rd * Rd\n            delta_y = Rd / p\n            # Total number of points is N_Rd*p intervals + 1\n            num_points_N = N_Rd * p + 1\n            \n            # The centered difference scheme requires at least 3 points\n            if num_points_N  3:\n                continue\n\n            y_grid = np.linspace(0.0, domain_length_L, num_points_N)\n            \n            # 2. Evaluate functions and derivatives on the grid\n            \n            # The calculation is performed on interior points\n            y_interior = y_grid[1:-1]\n            \n            # Analytical derivative on interior points\n            d_phi_analytical = d_phi_func(y_interior, Rd)\n            \n            # Numerical derivative using centered second-order finite difference\n            phi_on_grid = phi_func(y_grid, Rd)\n            # D(y_i) = (phi(y_{i+1}) - phi(y_{i-1})) / (2 * dy)\n            d_phi_numerical = (phi_on_grid[2:] - phi_on_grid[:-2]) / (2 * delta_y)\n\n            # 3. Compute the relative L2 error\n            \n            # The problem's error metric simplifies to the ratio of vector norms\n            # because the integration weight (delta_y) cancels out.\n            norm_of_error_vector = np.linalg.norm(d_phi_numerical - d_phi_analytical)\n            norm_of_analytical_derivative = np.linalg.norm(d_phi_analytical)\n            \n            if norm_of_analytical_derivative == 0:\n                # Handle the case where the analytical derivative is zero everywhere on the domain.\n                # The error is 0 if the numerical is also 0, otherwise it's undefined (infinite).\n                # This is not expected for the given wave functions and domains.\n                error = 0.0 if norm_of_error_vector == 0.0 else np.inf\n            else:\n                error = norm_of_error_vector / norm_of_analytical_derivative\n            \n            # 4. Check if the error meets the tolerance\n            if error = epsilon:\n                minimal_p = p\n                break  # Found the first (and thus minimal) p that satisfies the criterion\n            \n        results.append(minimal_p)\n\n    # Format and print the final output as a single-line string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "数值模型的最终目标是作为一个探索物理现象的虚拟实验室。这项高级练习 () 将理论与实践融为一体，指导你设计一个完整的数值实验。你将模拟一个罗斯贝波 (Rossby wave) 波包的传播，并使用先进的波数-频率诊断技术来测量其群速度，最后将测量结果与理论预测进行比较，从而完成从理论到模拟再到验证的整个科学闭环。",
            "id": "3800483",
            "problem": "您的任务是设计并实现一个数值实验，该实验在一个中纬度β平面上激发一个行星尺度的罗斯贝波包，并使用波数-频率诊断法测量其纬向群速度。数学和计算的出发点必须是β平面上的线性准地转位涡方程。假设斜压变形半径 $R_d$ 是有限的常数，并使用地转流函数 $\\psi(x,y,t)$ 作为波包的预报变量。所有物理量必须使用国际单位制（SI），长度单位为米，时间单位为秒。\n\n基本依据和控制方程：\n- 从准地转位涡 $q(x,y,t)$ 开始，其定义为 $q = \\nabla^2 \\psi - \\psi / R_d^2$，其中 $\\nabla^2$ 是笛卡尔坐标系中的二维拉普拉斯算子，$x$ 为纬向距离，$y$ 为经向距离。\n- 在纬度为 $\\varphi_0$ 的β平面上，$q$ 的线性演变由 $q_t + \\beta \\psi_x = 0$ 控制，其中 $\\beta = \\left. \\frac{\\partial f}{\\partial y} \\right|_{\\varphi_0}$ 是科里奥利参数 $f$ 的经向梯度；下标表示偏微分。\n- 实验必须在 $(x_0,y_0)$ 处激发一个局地化的小振幅波包，该波包在 $x$ 和 $y$ 方向上均具有高斯包络和单色载波，即，将 $\\psi(x,y,0)$ 初始化为一个实值高斯包络与一个具有指定纬向和经向波数的余弦载波的乘积。\n\n波数-频率诊断：\n- 通过在一个有限时间间隔 $t \\in [0,T]$ 内，沿着 $y=y_0$ 处的固定经向截面对 $\\psi(x,y,t)$ 进行采样，构建一个一维时空数据集 $s(x,t)$。\n- 计算 $(x,t)$ 上的二维离散傅里叶变换，以获得作为纬向波数 $k_x$ 和时间频率 $\\omega$ 函数的谱功率。\n- 识别波包载波波数周围三个相邻离散纬向波数的主导频率，并基于最大谱功率脊，通过有限差分斜率 $c_{gx} \\approx \\Delta \\omega / \\Delta k_x$ 来估算以米/秒为单位的纬向群速度 $c_{gx}$。\n\n解析预测：\n- 从上述控制方程出发，推导平面波解的频散关系，然后推导纬向群速度 $c_{gx}(k_x,k_y)$ 的解析表达式，即频率对纬向波数的相应偏导数。使用此解析 $c_{gx}$ 预测波包载波 $(k_0,l_0)$ 处的群速度。\n- 程序必须将测量的 $c_{gx}$ 与 $(k_0,l_0)$ 处的解析 $c_{gx}$ 进行比较，并返回以米/秒为单位的绝对误差。\n\n数值要求：\n- 使用长度为 $L_x$ 和 $L_y$ 的双周期矩形域，以及分别包含 $N_x$ 和 $N_y$ 个点的均匀网格。使用均匀时间步长 $\\Delta t$ 和 $N_t$ 个步长，总时间为 $T=N_t \\Delta t$。\n- 通过对所述控制方程所隐含的线性动力学进行积分，在谱空间中对 $\\psi$ 进行时间演变。您可以使用线性算子所隐含的精确谱相位演变方法，或为谱空间中的线性常微分方程使用足够精确的时间积分器。确保选择的数值参数能够解析 $(k_x,\\omega)$ 中的波包及其谱脊。\n- 对于谱诊断，在进行离散傅里叶变换之前，在 $x$ 和 $t$ 方向上应用可分离的锥化窗，以最小化谱泄漏。使用汉宁窗或等效的锥化函数。\n\n单位和输出：\n- 所有输入和输出必须使用国际单位制（SI）。最终的群速度以米/秒表示。\n- 您的程序必须生成单行输出，其中包含测试套件的绝对误差，格式为方括号括起来的逗号分隔列表，每个条目四舍五入到六位小数（例如，\"[0.123456,0.000001,0.010203]\"）。\n\n测试套件：\n实现以下三组参数集，以确保覆盖典型、边界和符号变化等场景。对于每种情况，使用高斯包络宽度 $\\sigma=1.0\\times 10^6$ 米，波包中心为 $(x_0,y_0)=(L_x/2,L_y/2)$。初始流函数的振幅使用 $A=1.0\\times 10^5$ 平方米/秒。\n\n- 情况1（典型中纬度波包）：\n    - $L_x = 1.0\\times 10^7$ 米, $L_y = 8.0\\times 10^6$ 米, $N_x=256$, $N_y=128$.\n    - $\\Delta t = 2.16\\times 10^4$ 秒, $N_t = 240$.\n    - $\\beta = 2.0\\times 10^{-11}$ /米·秒, $R_d = 2.0\\times 10^6$ 米。\n    - 载波波数: $k_0 = 2\\pi / (3.0\\times 10^6)$ 弧度/米, $l_0 = 0.0$ 弧度/米。\n\n- 情况2（具有西传载波的各向异性波包）：\n    - $L_x = 1.0\\times 10^7$ 米, $L_y = 8.0\\times 10^6$ 米, $N_x=256$, $N_y=128$.\n    - $\\Delta t = 2.16\\times 10^4$ 秒, $N_t = 240$.\n    - $\\beta = 2.0\\times 10^{-11}$ /米·秒, $R_d = 1.5\\times 10^6$ 米。\n    - 载波波数: $k_0 = -2\\pi / (4.0\\times 10^6)$ 弧度/米, $l_0 = 2\\pi / (6.0\\times 10^6)$ 弧度/米。\n\n- 情况3（近正压长波极限）：\n    - $L_x = 1.0\\times 10^7$ 米, $L_y = 8.0\\times 10^6$ 米, $N_x=256$, $N_y=128$.\n    - $\\Delta t = 2.16\\times 10^4$ 秒, $N_t = 240$.\n    - $\\beta = 2.0\\times 10^{-11}$ /米·秒, $R_d = 1.0\\times 10^9$ 米。\n    - 载波波数: $k_0 = 2\\pi / (8.0\\times 10^6)$ 弧度/米, $l_0 = 2\\pi / (8.0\\times 10^6)$ 弧度/米。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三种情况的结果，格式为方括号括起来的逗号分隔列表。每个条目是测量的纬向群速度与解析的纬向群速度之间的绝对误差（单位：米/秒），四舍五入到六位小数，并按照上面列出的情况顺序排列（即，\"[error_case1,error_case2,error_case3]\"）。",
            "solution": "该问题要求设计一个数值实验，以测量行星尺度罗斯贝波包的纬向群速度，并将其与解析预测进行比较。该过程涉及三个主要阶段：推导解析解、执行数值模拟以及分析模拟输出来测量群速度。\n\n### **1. 解析推导**\n\n控制物理过程由β平面上的线性准地转位涡（QGPV）方程描述。位涡 $q$ 通过以下方式与流函数 $\\psi(x,y,t)$ 相关联：\n$$q(x,y,t) = \\nabla^2 \\psi - \\frac{1}{R_d^2} \\psi$$\n其中 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ 是拉普拉斯算子，$R_d$ 是斜压变形半径。$q$ 的线性演变由下式给出：\n$$\\frac{\\partial q}{\\partial t} + \\beta \\frac{\\partial \\psi}{\\partial x} = 0$$\n其中 $\\beta$ 是科里奥利参数的恒定经向梯度。\n\n为了找到平面波的频散关系，我们将QGPV的定义代入演变方程：\n$$\\frac{\\partial}{\\partial t} \\left(\\nabla^2 \\psi - \\frac{1}{R_d^2} \\psi\\right) + \\beta \\frac{\\partial \\psi}{\\partial x} = 0$$\n我们寻求形式为 $\\psi(x,y,t) = \\hat{\\psi} e^{i(k_x x + k_y y - \\omega t)}$ 的平面波解，其中 $\\hat{\\psi}$ 是常数振幅，$k_x$ 和 $k_y$ 分别是纬向和经向波数，$\\omega$ 是时间频率。将此代入方程可得：\n$$-i\\omega \\left( -(k_x^2 + k_y^2) - \\frac{1}{R_d^2} \\right) \\hat{\\psi} e^{i(\\dots)} + \\beta (ik_x) \\hat{\\psi} e^{i(\\dots)} = 0$$\n除以 $i\\hat{\\psi}e^{i(\\dots)}$（假设为非平凡解）得到：\n$$\\omega \\left( k_x^2 + k_y^2 + \\frac{1}{R_d^2} \\right) + \\beta k_x = 0$$\n求解 $\\omega$ 可得到罗斯贝波的频散关系：\n$$\\omega(k_x, k_y) = - \\frac{\\beta k_x}{k_x^2 + k_y^2 + R_d^{-2}}$$\n\n纬向群速度 $c_{gx}$ 是频率对纬向波数的偏导数：\n$$c_{gx}(k_x, k_y) = \\frac{\\partial \\omega}{\\partial k_x}$$\n对 $\\omega(k_x, k_y)$ 的表达式使用商法则进行微分：\n$$c_{gx} = \\frac{(-\\beta)(k_x^2 + k_y^2 + R_d^{-2}) - (-\\beta k_x)(2k_x)}{(k_x^2 + k_y^2 + R_d^{-2})^2}$$\n简化分子，我们得到纬向群速度的解析表达式：\n$$c_{gx}(k_x, k_y) = \\frac{\\beta (k_x^2 - k_y^2 - R_d^{-2})}{(k_x^2 + k_y^2 + R_d^{-2})^2}$$\n该表达式将用于计算每个测试用例在其载波波数 $(k_0, l_0)$ 处的预测群速度。\n\n### **2. 数值模拟设计**\n\n模拟将初始波包随时间向前演变。由于谱方法在求解周期性域上的线性常系数偏微分方程时具有高精度和高效率，因此我们采用此方法。\n\n#### **2.1. 谱空间中的时间演变**\n在傅里叶（波数）空间中，控制方程是一个关于流函数傅里叶变换 $\\hat{\\psi}(k_x, k_y, t)$ 的常微分方程（ODE）。对控制偏微分方程进行变换可得：\n$$\\frac{d\\hat{\\psi}}{dt} = -i\\omega(k_x, k_y)\\hat{\\psi}$$\n其中 $\\omega(k_x, k_y)$ 是先前推导出的频率。这个线性ODE具有精确解：\n$$\\hat{\\psi}(k_x, k_y, t) = \\hat{\\psi}(k_x, k_y, 0) e^{-i\\omega(k_x, k_y) t}$$\n因此，数值算法包括：\n1.  在物理空间中定义初始条件 $\\psi(x, y, 0)$。\n2.  计算其二维快速傅里叶变换（FFT）以得到 $\\hat{\\psi}(k_x, k_y, 0)$。\n3.  对于每个期望的时间 $t$，使用上面的精确相演变公式计算 $\\hat{\\psi}(k_x, k_y, t)$。\n4.  应用二维逆FFT以获得物理空间解 $\\psi(x, y, t)$。\n\n#### **2.2. 初始条件**\n初始流函数 $\\psi(x,y,0)$ 是一个以 $(x_0, y_0)=(L_x/2, L_y/2)$ 为中心的高斯调制波包：\n$$\\psi(x,y,0) = A \\exp\\left(-\\frac{(x-x_0)^2 + (y-y_0)^2}{2\\sigma^2}\\right) \\cos(k_0 (x-x_0) + l_0(y-y_0))$$\n其中 $A$ 是振幅，$\\sigma$ 是包络宽度，$(k_0,l_0)$ 是载波波数。\n\n### **3. 波数-频率诊断**\n\n纬向群速度是通过对模拟输出进行谱分析来测量的。\n\n1.  **数据收集**：在每个时间步长记录中心纬向截面 $y=y_0$ 上的流函数，从而创建一个一维时空数据集 $s(x,t) = \\psi(x, y_0, t)$。\n2.  **加窗**：为了减轻因数据集的有限持续时间和长度而产生的谱泄漏，对 $s(x,t)$ 应用一个二维汉宁窗。该窗是可分离的，由两个一维汉宁窗（一个用于时间维度，一个用于空间维度）的外积形成。\n3.  **谱分析**：计算加窗后数据集 $s(x,t)$ 的二维FFT，得到复数谱 $S(k_x, \\omega)$。然后，功率谱为 $P(k_x, \\omega) = |S(k_x, \\omega)|^2$。\n4.  **群速度估计**：群速度是 $(k_x, \\omega)$ 平面中最大功率脊的斜率。为估计此斜率，我们首先确定最接近载波波数 $k_0$ 的离散纬向波数 $k_{d0}$。然后，我们找到在相邻离散波数 $k_{d0} - \\Delta k_x$ 和 $k_{d0} + \\Delta k_x$ 处对应最大谱功率的频率 $\\omega_{-1}$ 和 $\\omega_{+1}$，其中 $\\Delta k_x$ 是纬向波数的网格间距。数值群速度使用中心有限差分近似来估计：\n$$c_{gx, \\text{measured}} \\approx \\frac{\\omega_{+1} - \\omega_{-1}}{(k_{d0} + \\Delta k_x) - (k_{d0} - \\Delta k_x)} = \\frac{\\omega_{+1} - \\omega_{-1}}{2\\Delta k_x}$$\n\n最后，绝对误差计算为 $|c_{gx, \\text{measured}} - c_{gx, \\text{analytical}}|$。对所提供的三个测试用例中的每一个都执行此完整过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        { # Case 1\n            \"Lx\": 1.0e7, \"Ly\": 8.0e6, \"Nx\": 256, \"Ny\": 128,\n            \"dt\": 2.16e4, \"Nt\": 240,\n            \"beta\": 2.0e-11, \"Rd\": 2.0e6,\n            \"k0\": 2 * np.pi / (3.0e6), \"l0\": 0.0,\n            \"A\": 1.0e5, \"sigma\": 1.0e6\n        },\n        { # Case 2\n            \"Lx\": 1.0e7, \"Ly\": 8.0e6, \"Nx\": 256, \"Ny\": 128,\n            \"dt\": 2.16e4, \"Nt\": 240,\n            \"beta\": 2.0e-11, \"Rd\": 1.5e6,\n            \"k0\": -2 * np.pi / (4.0e6), \"l0\": 2 * np.pi / (6.0e6),\n            \"A\": 1.0e5, \"sigma\": 1.0e6\n        },\n        { # Case 3\n            \"Lx\": 1.0e7, \"Ly\": 8.0e6, \"Nx\": 256, \"Ny\": 128,\n            \"dt\": 2.16e4, \"Nt\": 240,\n            \"beta\": 2.0e-11, \"Rd\": 1.0e9,\n            \"k0\": 2 * np.pi / (8.0e6), \"l0\": 2 * np.pi / (8.0e6),\n            \"A\": 1.0e5, \"sigma\": 1.0e6\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        error = run_and_analyze_case(case_params)\n        results.append(f\"{error:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef run_and_analyze_case(params):\n    \"\"\"\n    Runs the simulation and analysis for a single test case.\n    \"\"\"\n    # Unpack parameters\n    Lx, Ly, Nx, Ny = params[\"Lx\"], params[\"Ly\"], params[\"Nx\"], params[\"Ny\"]\n    dt, Nt = params[\"dt\"], params[\"Nt\"]\n    beta, Rd = params[\"beta\"], params[\"Rd\"]\n    k0, l0 = params[\"k0\"], params[\"l0\"]\n    A, sigma = params[\"A\"], params[\"sigma\"]\n\n    x0, y0 = Lx / 2.0, Ly / 2.0\n\n    # 1. Analytical Group Velocity\n    def analytical_cgx(k_x, k_y, b, R_d):\n        k_sq = k_x**2 + k_y**2\n        R_d_inv_sq = 1.0 / R_d**2\n        denom_term = k_sq + R_d_inv_sq\n        \n        num = b * (k_x**2 - k_y**2 - R_d_inv_sq)\n        den = denom_term**2\n        return num / den\n\n    cgx_analytical = analytical_cgx(k0, l0, beta, Rd)\n\n    # 2. Numerical Simulation\n    # Spatial grids and wavenumbers\n    dx, dy = Lx / Nx, Ly / Ny\n    x = np.arange(Nx) * dx\n    y = np.arange(Ny) * dy\n    xx, yy = np.meshgrid(x, y)\n\n    kx_vec = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n    ky_vec = 2 * np.pi * np.fft.fftfreq(Ny, d=dy)\n    kx, ky = np.meshgrid(kx_vec, ky_vec)\n\n    # Initial condition\n    psi0 = A * np.exp(-((xx - x0)**2 + (yy - y0)**2) / (2 * sigma**2)) * \\\n           np.cos(k0 * (xx - x0) + l0 * (yy - y0))\n           \n    # Time evolution using exact spectral solution\n    psi0_hat = np.fft.fft2(psi0)\n    \n    # Dispersion relation omega(kx, ky)\n    K_sq = kx**2 + ky**2\n    denom_omega = K_sq + 1.0/Rd**2\n    omega = np.zeros_like(denom_omega, dtype=float)\n    mask = (denom_omega != 0)\n    omega[mask] = -beta * kx[mask] / denom_omega[mask]\n\n    # Store transect data s(x,t)\n    y_idx_center = Ny // 2\n    s_xt = np.zeros((Nt, Nx), dtype=float)\n    t_vec = np.arange(Nt) * dt\n\n    for i, t in enumerate(t_vec):\n        psi_hat_t = psi0_hat * np.exp(-1j * omega * t)\n        psi_t = np.fft.ifft2(psi_hat_t)\n        s_xt[i, :] = np.real(psi_t[y_idx_center, :])\n        \n    # 3. Wavenumber-Frequency Diagnostics\n    # Apply Hann window\n    window_t = np.hanning(Nt)\n    window_x = np.hanning(Nx)\n    window_2d = window_t[:, np.newaxis] * window_x[np.newaxis, :]\n    s_xt_windowed = s_xt * window_2d\n    \n    # 2D FFT and power spectrum\n    S_kw = np.fft.fftshift(np.fft.fft2(s_xt_windowed))\n    power_spectrum = np.abs(S_kw)**2\n    \n    # Diagnostic wavenumber and frequency axes\n    k_diag_vec = 2 * np.pi * np.fft.fftshift(np.fft.fftfreq(Nx, d=dx))\n    om_diag_vec = 2 * np.pi * np.fft.fftshift(np.fft.fftfreq(Nt, d=dt))\n    \n    # Find indices and wavenumbers for finite difference\n    idx_k0_carrier = np.argmin(np.abs(k_diag_vec - k0))\n    idx_k_minus = idx_k0_carrier - 1\n    idx_k_plus = idx_k0_carrier + 1\n    \n    # Find peak frequencies at neighboring wavenumbers\n    idx_w_minus = np.argmax(power_spectrum[:, idx_k_minus])\n    idx_w_plus = np.argmax(power_spectrum[:, idx_k_plus])\n    \n    k_minus = k_diag_vec[idx_k_minus]\n    k_plus = k_diag_vec[idx_k_plus]\n    w_minus = om_diag_vec[idx_w_minus]\n    w_plus = om_diag_vec[idx_w_plus]\n    \n    # Measured group velocity using centered difference\n    dk = k_plus - k_minus\n    dw = w_plus - w_minus\n    cgx_measured = dw / dk if dk != 0 else 0.0\n        \n    # 4. Absolute Error\n    error = np.abs(cgx_measured - cgx_analytical)\n    return error\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}