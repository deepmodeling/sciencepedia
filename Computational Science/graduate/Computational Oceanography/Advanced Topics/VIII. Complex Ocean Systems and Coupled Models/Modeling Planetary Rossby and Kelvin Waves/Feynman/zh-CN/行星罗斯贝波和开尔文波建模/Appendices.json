{
    "hands_on_practices": [
        {
            "introduction": "任何一个依赖于时间步进的数值模型，其首要前提是必须保持稳定。此练习将引导你分析一个显式时间步进格式的稳定性，这个稳定性由系统中传播速度最快的波（在这里是开尔文波）所控制。通过推导著名的科里奥利-弗里德里希斯-刘易（CFL）条件，你将掌握如何将物理波速与模型允许的最大时间步长联系起来，这是设置任何海洋环流模型时必须面对的一个基本而关键的实践问题 。",
            "id": "3800496",
            "problem": "考虑一个在恒定$f$平面上的无粘、线性、旋转浅水系统，其深度$H$为均匀值，重力加速度为$g$。设海岸线是位于$y=0$处与$x$轴对齐的直线边界，其无垂向流动的边界条件为$v(x,0,t)=0$。假设存在海面高度$\\eta(x,y,t)$和深度平均速度$u(x,y,t)$、$v(x,y,t)$的小扰动，它们满足以下线性化的旋转浅水方程：\n$$\nu_{t} - f v = - g \\,\\eta_{x}, \\quad v_{t} + f u = - g \\,\\eta_{y}, \\quad \\eta_{t} + H\\,(u_{x} + v_{y}) = 0,\n$$\n其中下标表示偏导数。海岸开尔文波是一种边界捕获解，它向离岸方向衰减并沿海岸传播。从上述方程出发，推导该开尔文波的非频散相速度$c$作为$g$和$H$的函数。\n\n现在考虑由线性平流偏微分方程(PDE) $\\eta_{t} + c\\,\\eta_{x} = 0$控制的开尔文波包的单向沿岸传播。假设$c>0$，在一个间距为$\\Delta x$、时间步长为$\\Delta t$的均匀网格上，使用一阶迎风有限差分进行空间离散，使用向前欧拉法进行时间离散。对得到的显式格式进行von Neumann稳定性分析，以确定$\\Delta t$关于$\\Delta x$和$c$的稳定性约束。在你的推导中，明确引入Courant–Friedrichs–Lewy (CFL)数$\\lambda$和放大因子，并得到放大因子对所有傅里叶模态的模长小于等于1的条件。\n\n最后，对于一个配置为$H = 4000\\,\\mathrm{m}$、$g = 9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$以及沿岸水平网格间距$\\Delta x = 25\\,\\mathrm{km}$的海盆尺度模型，使用你的稳定性结果计算能够解析快速正压开尔文波的最大稳定显式时间步长$\\Delta t_{\\max}$。将你的数值答案四舍五入到四位有效数字，并以秒为单位表示。根据你的推导，简要解释此稳定性约束对于在同一显式模型中解析慢速行星罗斯比波的影响。",
            "solution": "用户提供了一个关于海岸开尔文波及其数值模拟稳定性的多部分问题。该问题在科学上是合理的、适定的和客观的。这是地球物理流体动力学和计算方法中的一个标准问题。我将按要求分三部分解决。\n\n第1部分：开尔文波相速度的推导\n\n控制方程是在恒定$f$平面上，对于深度为$H$的均匀无粘流体的线性化旋转浅水方程：\n$$u_{t} - f v = - g \\,\\eta_{x} \\quad (1)$$\n$$v_{t} + f u = - g \\,\\eta_{y} \\quad (2)$$\n$$\\eta_{t} + H\\,(u_{x} + v_{y}) = 0 \\quad (3)$$\n边界条件是在海岸$y=0$处无垂向流动，即$v(x,0,t) = 0$。\n\n海岸开尔文波是该系统的一个特定解，它被捕获在边界处并沿其传播。开尔文波的一个决定性特征是跨岸速度处处为零，即对于所有$x, y, t$，都有$v(x,y,t) = 0$。这恒等地满足了$y=0$处的边界条件。当$v=0$时，方程组大大简化：\n由(1)得：$u_{t} = -g\\eta_{x} \\quad (4)$\n由(2)得：$f u = -g\\eta_{y} \\quad (5)$\n由(3)得：$\\eta_{t} + H u_{x} = 0 \\quad (6)$\n\n方程(5)代表了跨岸（$y$）方向的地转平衡。方程(4)和(6)描述了波在沿岸（$x$）方向的传播。为了找到相速度，我们可以结合(4)和(6)。将(6)对$t$求导，将(4)对$x$求导：\n$$\\eta_{tt} + H u_{xt} = 0$$\n$$u_{tx} = -g \\eta_{xx}$$\n假设场足够光滑，求导的顺序不影响结果($u_{xt} = u_{tx}$)。将第二个方程代入第一个方程得到：\n$$\\eta_{tt} - gH \\eta_{xx} = 0$$\n这是海面高度$\\eta$的一维波动方程。通解描述了以相速度$c$在$\\pm x$方向传播的波，其中$c^2 = gH$。因此，相速度为：\n$$c = \\sqrt{gH}$$\n由于相速度$c$不依赖于波数或频率，所以该波是非频散的。\n\n为了确认其边界捕获的性质，我们考察方程(5)，$fu = -g\\eta_y$。我们寻找一个沿$+x$方向传播的解，形式为$\\eta(x,y,t) = F(y)G(x-ct)$。从波动方程可知，$u$也具有这种形式。由(4)可知，$u_t = -c u'$, 且$\\eta_x = \\eta'$, 其中撇号表示对自变量$x-ct$求导。因此，$-cu' = -g\\eta'$, 积分得到$u = (g/c)\\eta$（假设纯波解的积分常数为零）。将此代入(5)：\n$$f \\left(\\frac{g}{c}\\eta\\right) = -g \\frac{\\partial \\eta}{\\partial y}$$\n$$\\frac{\\partial \\eta}{\\partial y} = -\\frac{f}{c}\\eta$$\n$\\eta$的离岸结构解为$\\eta(x,y,t) = \\eta_0(x-ct) \\exp\\left(-\\frac{f}{c}y\\right)$。为了使波被捕获在海岸（即当$y \\rightarrow \\infty$时衰减），指数必须为负。由于$c=\\sqrt{gH}$为正且$y>0$，这要求科里奥利参数$f$为正。这对应于在北半球，波在传播方向的右侧有海岸。\n\n第2部分：Von Neumann稳定性分析\n\n问题要求分析单向平流方程$\\eta_t + c\\,\\eta_x=0$（其中$c > 0$）的数值格式的稳定性。该格式在时间上是向前欧拉法，在空间上是一阶迎风格式。\n设$\\eta_j^n$为网格点$x_j=j\\Delta x$和时间$t_n=n\\Delta t$处的数值解。\n向前欧拉时间差分为：$\\eta_t \\approx \\frac{\\eta_j^{n+1} - \\eta_j^n}{\\Delta t}$。\n由于波沿$+x$方向传播($c>0$)，“迎风”方向是$-x$方向。因此，我们使用一阶后向差分来计算空间导数：$\\eta_x \\approx \\frac{\\eta_j^n - \\eta_{j-1}^n}{\\Delta x}$。\n\n将这些代入偏微分方程，得到有限差分方程：\n$$\\frac{\\eta_j^{n+1} - \\eta_j^n}{\\Delta t} + c \\frac{\\eta_j^n - \\eta_{j-1}^n}{\\Delta x} = 0$$\n我们解出$\\eta_j^{n+1}$：\n$$\\eta_j^{n+1} = \\eta_j^n - \\frac{c \\Delta t}{\\Delta x} (\\eta_j^n - \\eta_{j-1}^n)$$\n我们引入Courant–Friedrichs–Lewy (CFL)数，$\\lambda = \\frac{c \\Delta t}{\\Delta x}$。方程变为：\n$$\\eta_j^{n+1} = \\eta_j^n - \\lambda (\\eta_j^n - \\eta_{j-1}^n) = (1-\\lambda)\\eta_j^n + \\lambda \\eta_{j-1}^n$$\n对于von Neumann稳定性分析，我们考虑单个傅里叶模态作为解：\n$$\\eta_j^n = G^n e^{ik j \\Delta x}$$\n这里，$k$是波数，$G$是复放大因子。如果对于所有可能的波数，$|G| \\le 1$，则格式是稳定的。\n将傅里叶模态代入差分方程：\n$$G^{n+1} e^{ik j \\Delta x} = (1-\\lambda) G^n e^{ik j \\Delta x} + \\lambda G^n e^{ik (j-1) \\Delta x}$$\n两边同除以$G^n e^{ik j \\Delta x}$：\n$$G = (1-\\lambda) + \\lambda e^{-ik \\Delta x}$$\n设无量纲波数为$\\theta = k \\Delta x$。则$e^{-ik \\Delta x} = \\cos(\\theta) - i\\sin(\\theta)$。\n$$G = (1-\\lambda) + \\lambda (\\cos(\\theta) - i\\sin(\\theta)) = (1-\\lambda + \\lambda\\cos(\\theta)) - i(\\lambda\\sin(\\theta))$$\n放大因子的模的平方是$|G|^2$：\n$$|G|^2 = (1-\\lambda + \\lambda\\cos(\\theta))^2 + (-\\lambda\\sin(\\theta))^2$$\n$$|G|^2 = (1-\\lambda)^2 + 2\\lambda(1-\\lambda)\\cos(\\theta) + \\lambda^2\\cos^2(\\theta) + \\lambda^2\\sin^2(\\theta)$$\n$$|G|^2 = (1-2\\lambda+\\lambda^2) + 2\\lambda(1-\\lambda)\\cos(\\theta) + \\lambda^2(\\cos^2(\\theta)+\\sin^2(\\theta))$$\n$$|G|^2 = 1-2\\lambda+\\lambda^2 + 2\\lambda\\cos(\\theta) - 2\\lambda^2\\cos(\\theta) + \\lambda^2$$\n$$|G|^2 = 1 - 2\\lambda(1-\\lambda)(1-\\cos\\theta)$$\n为了保证稳定性，我们需要对所有实数$\\theta$有$|G|^2 \\le 1$。这意味着：\n$$1 - 2\\lambda(1-\\lambda)(1-\\cos\\theta) \\le 1$$\n$$-2\\lambda(1-\\lambda)(1-\\cos\\theta) \\le 0$$\n由于$\\Delta t>0$和$\\Delta x>0$，并且给定$c>0$，所以CFL数$\\lambda$是正的。项$(1-\\cos\\theta)$对于任何实数$\\theta$总是非负的。因此，我们可以将不等式两边除以非正项$-2(1-\\cos\\theta)$（对于$\\theta \\neq 2n\\pi$）并反转不等号，或者我们可以分析各个因子。为使不等式成立，乘积$\\lambda(1-\\lambda)$必须为非负。\n由于$\\lambda > 0$，我们必须有$1-\\lambda \\ge 0$，这意味着$\\lambda \\le 1$。\n将$\\lambda$的正性与此结果相结合，稳定性条件是：\n$$0 \\le \\lambda \\le 1$$\n代回$\\lambda = \\frac{c \\Delta t}{\\Delta x}$：\n$$0 \\le \\frac{c \\Delta t}{\\Delta x} \\le 1$$\n这得出了对时间步长$\\Delta t$的稳定性约束：\n$$\\Delta t \\le \\frac{\\Delta x}{c}$$\n\n第3部分：数值计算与影响\n\n首先，我们使用给定的值$g = 9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$和$H = 4000\\,\\mathrm{m}$计算正压开尔文波的相速度$c$。\n$$c = \\sqrt{gH} = \\sqrt{(9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2})(4000\\,\\mathrm{m})} = \\sqrt{39240\\,\\mathrm{m}^2\\,\\mathrm{s}^{-2}} \\approx 198.0909\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$$\n接下来，我们使用第2部分推导的稳定性约束来确定最大稳定时间步长$\\Delta t_{\\max}$。给定的网格间距为$\\Delta x = 25\\,\\mathrm{km} = 25000\\,\\mathrm{m}$。\n$$\\Delta t_{\\max} = \\frac{\\Delta x}{c} = \\frac{25000\\,\\mathrm{m}}{198.0909\\,\\mathrm{m}\\,\\mathrm{s}^{-1}} \\approx 126.204\\,\\mathrm{s}$$\n四舍五入到四位有效数字，最大稳定时间步长为$126.2\\,\\mathrm{s}$。\n\n对解析慢速行星罗斯比波的影响：\n显式时间步进格式的稳定性由Courant–Friedrichs–Lewy (CFL)条件决定。该条件确保数值依赖域包含物理依赖域。约束$\\Delta t \\le \\Delta x/c$是由系统中最快的传播波决定的，在本例中是速度约为$200\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$的正压开尔文波。这导致一个非常小的最大允许时间步长，$\\Delta t_{\\max} \\approx 2.1\\,\\mathrm{分钟}$。\n\n然而，行星罗斯比波是慢得多的现象。它们的传播速度比开尔文波速度小数个数量级，其特征时间尺度在几周到几年之间。为了在气候学相关的时间段（例如几十年）内模拟这些慢波的演变，如果模型受$\\Delta t_{\\max}$的限制，将需要巨大的时间步数。例如，模拟一年大约需要$(365 \\times 24 \\times 3600) / 126.2 \\approx 2.5 \\times 10^5$步。这使得使用简单的显式模型来研究移动缓慢的罗斯比波在计算上是不可行的。这个问题，即系统中包含时间尺度差异巨大的过程，被称为刚性问题，是地球物理流体计算建模中的一个主要挑战。为了克服这个问题，海洋模型通常采用半隐式或全隐式时间步进方法，或者采用模态分裂技术，对系统中的快慢模态进行不同处理，从而允许对慢动力学使用更大的时间步长。",
            "answer": "$$\n\\boxed{126.2}\n$$"
        },
        {
            "introduction": "一个稳定的模型如果网格过于粗糙以至于无法准确描绘波的形态，那么它也是没有科学价值的。此练习将探讨如何量化网格分辨率对准确再现被捕获波（如开尔文波和罗斯比波）空间结构的影响，这些波的空间尺度通常由形变半径 $R_d$ 决定。通过这个实践，你将学会如何根据给定的精度要求，确定在每个形变半径内所需的最小网格点数，这是设计可靠数值模型并正确解读其结果的关键一步 。",
            "id": "3800508",
            "problem": "您的任务是量化相对于变形半径 $R_d$ 的网格分辨率如何影响与行星罗斯比波和开尔文波相关的被困波结构的数值精度，然后以每个 $R_d$ 的点数提出一个最低分辨率标准。计算基础必须源自 $f$ 平面或 $\\beta$ 平面上的线性化旋转浅水方程，以及已知的海岸和赤道波导的被困本征函数。\n\n使用的基本基础和定义：\n- 在 $f$ 平面上，变形半径 $R_d$ 定义为 $R_d = \\sqrt{g H} / |f|$，其中 $g$ 是重力加速度， $H$ 是层深度， $f$ 是科里奥利参数；它为海岸开尔文波设定了跨波导的捕捉尺度。对于 $\\beta$ 平面上的赤道波导，经向捕捉尺度为 $L_e = \\sqrt{c / \\beta}$，其中重力波速 $c = \\sqrt{g H}$，$\\beta = \\partial f / \\partial y$。在此问题中，将符号 $R_d$ 视为用于海岸和赤道经向结构的捕捉尺度。\n- 在直海岸（$y \\ge 0$）上的海岸开尔文波经向结构可以用跨岸振幅 $\\phi_K(y) = \\exp(-y / R_d)$ 表示。\n- 赤道被困模态的经向结构与高斯函数和 Hermite 函数成正比。使用以下规范形式：\n  1. 赤道开尔文波：$\\phi_{EK}(y) = \\exp\\left(-\\dfrac{y^2}{2 R_d^2}\\right)$。\n  2. 第一个赤道罗斯比模态（$n = 1$）：$\\phi_{ER1}(y) = 2 \\dfrac{y}{R_d} \\exp\\left(-\\dfrac{y^2}{2 R_d^2}\\right)$。\n\n目标：\n- 对于每个被困结构 $\\phi(y)$，在均匀网格上离散化经向坐标 $y \\in [0, L]$，网格间距为 $\\Delta y = R_d / p$，其中 $p$ 是每个 $R_d$ 的网格点数，域长度 $L = N_{R_d} R_d$，$N_{R_d}$ 为整数。所有长度必须以米为单位处理。\n- 使用中心二阶有限差分算子，在内部网格点 $y_i$（其中 $i = 1, \\dots, N-2$，$N$ 是网格点数）处近似经向导数：\n  $$D_{\\Delta y} \\phi(y_i) = \\dfrac{\\phi(y_{i+1}) - \\phi(y_{i-1})}{2 \\Delta y},$$\n- 计算每个结构的解析经向导数 $\\dfrac{d \\phi}{d y}$，并评估数值导数近似的相对离散 $L^2$ 误差：\n  $$E = \\dfrac{\\left( \\int_{0}^{L} \\left[ D_{\\Delta y} \\phi(y) - \\dfrac{d \\phi}{d y}(y) \\right]^2 \\, dy \\right)^{1/2}}{\\left( \\int_{0}^{L} \\left[ \\dfrac{d \\phi}{d y}(y) \\right]^2 \\, dy \\right)^{1/2}}.$$\n  用内部网格点上的黎曼和来近似积分，并使用 $\\Delta y$ 作为求积权重。此问题中不使用角度，因此无需指定角度单位。\n- 对于给定的容差 $\\varepsilon$（以小数表示），确定最小整数 $p$，使得 $E \\le \\varepsilon$。如果没有测试值满足容差，则返回 $-1$。\n\n测试套件：\n- 情况 1：海岸开尔文波，$R_d = 50000$ 米，$N_{R_d} = 5$，容差 $\\varepsilon = 0.05$。\n- 情况 2：赤道开尔文波，$R_d = 150000$ 米，$N_{R_d} = 6$，容差 $\\varepsilon = 0.02$。\n- 情况 3：第一个赤道罗斯比模态，$R_d = 150000$ 米，$N_{R_d} = 6$，容差 $\\varepsilon = 0.03$。\n- 情况 4：海岸开尔文波，$R_d = 30000$ 米，$N_{R_d} = 3$，容差 $\\varepsilon = 0.01$。\n- 情况 5：赤道开尔文波，$R_d = 100000$ 米，$N_{R_d} = 2$，容差 $\\varepsilon = 0.08$。\n\n在候选集 $\\{2, 3, 4, 5, 6, 8, 10, 12, 16, 20, 24, 32, 40, 48, 64\\}$ 中搜索 $p$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例的最小“每 $R_d$ 点数”值，形式为逗号分隔的列表，并用方括号括起来，例如 $[p_1,p_2,p_3,p_4,p_5]$，其中每个 $p_i$ 是一个整数，如果没有任何候选值满足标准，则为 $-1$。\n\n所有长度必须以米为单位。容差 $\\varepsilon$ 必须作为小数处理。",
            "solution": "该问题被视为有效。它在科学上基于地球物理流体动力学和数值分析的原理，特别是关于波动方程的离散化。该问题是适定的，所有必要的函数、参数和评估标准都有明确定义，从而允许一个唯一且可验证的解。没有矛盾、歧义或事实不准确之处。\n\n核心任务是确定所需的最小网格分辨率，以每个变形半径的点数（$p$）来量化，以便使用有限差分法精确表示海洋被困波的经向结构。精度通过数值计算的一阶导数与解析导数相比的相对 $L^2$ 误差来衡量，该误差必须低于指定的容差 $\\varepsilon$。\n\n每个测试用例的方法如下：\n1.  **定义解析结构**：问题指定了三种规范的经向结构 $\\phi(y)$ 及其解析一阶导数 $\\dfrac{d\\phi}{dy}$。\n    *   对于海岸开尔文波：\n        $$ \\phi_K(y) = \\exp(-y / R_d) $$\n        $$ \\dfrac{d\\phi_K}{dy} = -\\dfrac{1}{R_d} \\exp(-y / R_d) $$\n    *   对于赤道开尔文波：\n        $$ \\phi_{EK}(y) = \\exp\\left(-\\dfrac{y^2}{2 R_d^2}\\right) $$\n        $$ \\dfrac{d\\phi_{EK}}{dy} = -\\dfrac{y}{R_d^2} \\exp\\left(-\\dfrac{y^2}{2 R_d^2}\\right) $$\n    *   对于第一个赤道罗斯比模态（$n=1$）：\n        $$ \\phi_{ER1}(y) = 2 \\dfrac{y}{R_d} \\exp\\left(-\\dfrac{y^2}{2 R_d^2}\\right) $$\n        $$ \\dfrac{d\\phi_{ER1}}{dy} = \\dfrac{2}{R_d} \\left(1 - \\dfrac{y^2}{R_d^2}\\right) \\exp\\left(-\\dfrac{y^2}{2 R_d^2}\\right) $$\n    在这些方程中，$y$ 是经向坐标，$R_d$ 是相关的捕捉尺度（变形半径）。\n\n2.  **建立数值网格**：将连续域 $y \\in [0, L]$ 离散化为均匀网格。域长度为 $L = N_{R_d} R_d$，其中 $N_{R_d}$ 是指定的整数乘数。网格间距为 $\\Delta y = R_d / p$，其中 $p$ 是每个 $R_d$ 的点数。网格点总数为 $N = N_{R_d} p + 1$。网格点位于 $y_i = i \\cdot \\Delta y$，其中 $i = 0, 1, \\dots, N-1$。\n\n3.  **近似导数**：在内部网格点 $y_i$（其中 $i = 1, \\dots, N-2$）处，使用二阶中心有限差分格式来近似一阶导数：\n    $$ D_{\\Delta y} \\phi(y_i) = \\dfrac{\\phi(y_{i+1}) - \\phi(y_{i-1})}{2 \\Delta y} $$\n    该公式为每个内部点 $y_i$ 处的 $\\dfrac{d\\phi}{dy}$ 提供了数值近似。\n\n4.  **计算离散误差**：计算相对 $L^2$ 误差 $E$。$E$ 定义中的积分通过在内部网格点集 $\\{y_i\\}_{i=1}^{N-2}$ 上使用黎曼和来近似。\n    $$ E = \\dfrac{\\left( \\sum_{i=1}^{N-2} \\left[ D_{\\Delta y} \\phi(y_i) - \\dfrac{d \\phi}{d y}(y_i) \\right]^2 \\Delta y \\right)^{1/2}}{\\left( \\sum_{i=1}^{N-2} \\left[ \\dfrac{d \\phi}{d y}(y_i) \\right]^2 \\Delta y \\right)^{1/2}} $$\n    求积权重 $\\Delta y$ 在分子和分母中是公共的，因此可以消去。表达式简化为向量范数的比率：\n    $$ E = \\dfrac{\\left\\| \\mathbf{D}_{\\text{num}} - \\mathbf{D}_{\\text{ana}} \\right\\|_2}{\\left\\| \\mathbf{D}_{\\text{ana}} \\right\\|_2} $$\n    其中 $\\mathbf{D}_{\\text{num}}$ 是内部点处数值导数值的向量，$\\mathbf{D}_{\\text{ana}}$ 是同一点处解析导数值的向量，$\\| \\cdot \\|_2$ 表示欧几里得范数。\n\n5.  **确定最小分辨率**：对于每个测试用例，我们遍历 $p$ 的有序候选集，即 $\\{2, 3, 4, 5, 6, 8, 10, 12, 16, 20, 24, 32, 40, 48, 64\\}$。对于每个 $p$ 值，计算误差 $E$。集合中第一个使 $E \\le \\varepsilon$ 的 $p$ 值即为该情况所需的最小分辨率。如果集合中没有 $p$ 值满足该标准，则该情况的结果为 $-1$。\n\n此过程系统地应用于问题陈述中提供的五个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the minimal grid resolution (points per deformation radius)\n    for accurately representing oceanic wave structures.\n    \"\"\"\n\n    # --- Analytical Wave Structures and Their Derivatives ---\n\n    def phi_coastal_kelvin(y, Rd):\n        \"\"\"Meridional structure of a Coastal Kelvin wave.\"\"\"\n        return np.exp(-y / Rd)\n\n    def d_phi_coastal_kelvin(y, Rd):\n        \"\"\"Analytical derivative of the Coastal Kelvin wave structure.\"\"\"\n        return (-1 / Rd) * np.exp(-y / Rd)\n\n    def phi_equatorial_kelvin(y, Rd):\n        \"\"\"Meridional structure of an Equatorial Kelvin wave.\"\"\"\n        return np.exp(-y**2 / (2 * Rd**2))\n\n    def d_phi_equatorial_kelvin(y, Rd):\n        \"\"\"Analytical derivative of the Equatorial Kelvin wave structure.\"\"\"\n        return (-y / Rd**2) * np.exp(-y**2 / (2 * Rd**2))\n\n    def phi_equatorial_rossby1(y, Rd):\n        \"\"\"Meridional structure of the first Equatorial Rossby mode.\"\"\"\n        return 2 * (y / Rd) * np.exp(-y**2 / (2 * Rd**2))\n\n    def d_phi_equatorial_rossby1(y, Rd):\n        \"\"\"Analytical derivative of the first Equatorial Rossby mode structure.\"\"\"\n        term1 = 2 / Rd\n        term2 = 1 - y**2 / Rd**2\n        term3 = np.exp(-y**2 / (2 * Rd**2))\n        return term1 * term2 * term3\n\n    # Dictionary to map wave types to their respective functions\n    wave_functions = {\n        'Coastal Kelvin': {'phi': phi_coastal_kelvin, 'd_phi': d_phi_coastal_kelvin},\n        'Equatorial Kelvin': {'phi': phi_equatorial_kelvin, 'd_phi': d_phi_equatorial_kelvin},\n        'First equatorial Rossby': {'phi': phi_equatorial_rossby1, 'd_phi': d_phi_equatorial_rossby1}\n    }\n\n    # --- Problem Parameters ---\n\n    # Candidate set for p (points per deformation radius)\n    p_candidates = [2, 3, 4, 5, 6, 8, 10, 12, 16, 20, 24, 32, 40, 48, 64]\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (wave_type, Rd_meters, N_Rd, epsilon_tolerance)\n        ('Coastal Kelvin', 50000.0, 5, 0.05),\n        ('Equatorial Kelvin', 150000.0, 6, 0.02),\n        ('First equatorial Rossby', 150000.0, 6, 0.03),\n        ('Coastal Kelvin', 30000.0, 3, 0.01),\n        ('Equatorial Kelvin', 100000.0, 2, 0.08)\n    ]\n\n    results = []\n    for case in test_cases:\n        wave_type, Rd, N_Rd, epsilon = case\n        \n        # In Chinese problem text, \"Rossby\" is \"罗斯比\"\n        if wave_type == 'First equatorial Rossby':\n            phi_func = wave_functions['First equatorial Rossby']['phi']\n            d_phi_func = wave_functions['First equatorial Rossby']['d_phi']\n        else:\n            phi_func = wave_functions[wave_type]['phi']\n            d_phi_func = wave_functions[wave_type]['d_phi']\n        \n        minimal_p = -1\n        \n        # Iterate through the ordered candidate set to find the minimal p\n        for p in p_candidates:\n            # 1. Set up the numerical grid\n            domain_length_L = N_Rd * Rd\n            delta_y = Rd / p\n            # Total number of points is N_Rd*p intervals + 1\n            num_points_N = N_Rd * p + 1\n            \n            # The centered difference scheme requires at least 3 points\n            if num_points_N  3:\n                continue\n\n            y_grid = np.linspace(0.0, domain_length_L, num_points_N)\n            \n            # 2. Evaluate functions and derivatives on the grid\n            \n            # The calculation is performed on interior points\n            y_interior = y_grid[1:-1]\n            \n            # Analytical derivative on interior points\n            d_phi_analytical = d_phi_func(y_interior, Rd)\n            \n            # Numerical derivative using centered second-order finite difference\n            phi_on_grid = phi_func(y_grid, Rd)\n            # D(y_i) = (phi(y_{i+1}) - phi(y_{i-1})) / (2 * dy)\n            d_phi_numerical = (phi_on_grid[2:] - phi_on_grid[:-2]) / (2 * delta_y)\n\n            # 3. Compute the relative L2 error\n            \n            # The problem's error metric simplifies to the ratio of vector norms\n            # because the integration weight (delta_y) cancels out.\n            norm_of_error_vector = np.linalg.norm(d_phi_numerical - d_phi_analytical)\n            norm_of_analytical_derivative = np.linalg.norm(d_phi_analytical)\n            \n            if norm_of_analytical_derivative == 0:\n                # Handle the case where the analytical derivative is zero everywhere on the domain.\n                # The error is 0 if the numerical is also 0, otherwise it's undefined (infinite).\n                # This is not expected for the given wave functions and domains.\n                error = 0.0 if norm_of_error_vector == 0.0 else np.inf\n            else:\n                error = norm_of_error_vector / norm_of_analytical_derivative\n            \n            # 4. Check if the error meets the tolerance\n            if error = epsilon:\n                minimal_p = p\n                break  # Found the first (and thus minimal) p that satisfies the criterion\n            \n        results.append(minimal_p)\n\n    # Format and print the final output as a single-line string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "拥有一个既稳定又足够精确的模型后，我们便可以开展有意义的科学探究了。这项综合性练习将指导你完成一个完整的计算物理学实验：从构建并启动一个罗斯比波包，到运行模拟，再到应用高阶的波数-频率谱分析技术从模拟数据中测量其群速度。最后，你将把测量结果与理论预测进行比较，这个过程完美地体现了从理论推导到数值验证再到数据分析的计算科学研究全流程 。",
            "id": "3800483",
            "problem": "您需要设计并实现一个数值实验，该实验在一个中纬度β平面上激发一个行星尺度的罗斯比波包，并使用波数-频率诊断法测量其纬向群速度。数学和计算的起点必须是β平面上的线性准地转位涡方程。假设斜压变形半径$R_d$为有限常数，并使用地转流函数$\\psi(x,y,t)$作为波包的预报变量。所有物理量必须使用国际单位制（SI）表示，长度单位为米，时间单位为秒。\n\n基本原理与控制方程：\n- 从准地转位涡$q(x,y,t)$的定义开始，$q = \\nabla^2 \\psi - \\psi / R_d^2$，其中$\\nabla^2$是在笛卡尔坐标系中的二维拉普拉斯算子，$x$为纬向距离，$y$为经向距离。\n- 在纬度为$\\varphi_0$的β平面上，$q$的线性演化由$q_t + \\beta \\psi_x = 0$控制，其中$\\beta = \\left. \\frac{\\partial f}{\\partial y} \\right|_{\\varphi_0}$是科里奥利参数$f$的经向梯度；下标表示偏微分。\n- 实验必须激发一个位于$(x_0,y_0)$中心的局部化小振幅波包，该波包具有高斯包络，并在$x$和$y$方向上都有单色载波，即，将$\\psi(x,y,0)$初始化为一个实值高斯包络乘以具有指定纬向和经向波数的余弦载波。\n\n波数-频率诊断：\n- 通过在有限时间间隔$t \\in [0,T]$内，沿着固定的经向截面$y=y_0$采样$\\psi(x,y,t)$，构建一个一维时空数据集$s(x,t)$。\n- 计算$(x,t)$上的二维离散傅里叶变换，以获得作为纬向波数$k_x$和时间频率$\\omega$的函数的谱功率。\n- 围绕波包的载波波数，识别三个相邻离散纬向波数的主导频率，并基于最大谱功率脊，使用有限差分斜率$c_{gx} \\approx \\Delta \\omega / \\Delta k_x$估算以米/秒为单位的纬向群速度$c_{gx}$。\n\n解析预测：\n- 从上述控制方程出发，推导平面波解的色散关系，然后推导纬向群速度$c_{gx}(k_x,k_y)$的解析表达式，即频率对纬向波数的相应偏导数。使用此解析$c_{gx}$来预测波包载波$(k_0,l_0)$处的群速度。\n- 程序必须将测量的$c_{gx}$与$(k_0,l_0)$处的解析$c_{gx}$进行比较，并返回以米/秒为单位的绝对误差。\n\n数值要求：\n- 使用长度为$L_x$和$L_y$的双周期矩形域，以及分别有$N_x$和$N_y$个点的均匀网格。使用均匀时间步长$\\Delta t$和$N_t$个时间步，覆盖总时间$T=N_t \\Delta t$。\n- 通过对所述控制方程所隐含的线性动力学进行积分，在谱空间中对$\\psi$进行时间演化。您可以使用线性算子所隐含的精确谱相位演化，或对谱空间中的线性常微分方程使用足够精确的时间积分器。确保选择的数值参数能够分辨波包及其在$(k_x,\\omega)$中的谱脊。\n- 对于谱诊断，在进行离散傅里叶变换之前，在$x$和$t$两个维度上应用可分离的锥形窗，以最小化谱泄漏。使用汉宁窗或等效的锥形函数。\n\n单位与输出：\n- 所有输入和输出必须使用国际单位制（SI）。最终的群速度以米/秒表示。\n- 您的程序必须生成单行输出，其中包含测试套件的绝对误差，以逗号分隔的列表形式包含在方括号内，每个条目四舍五入到六位小数（例如，\"[0.123456,0.000001,0.010203]\"）。\n\n测试套件：\n实施以下三组参数集，以确保覆盖典型、边界和符号变化的情景。对于每种情况，使用高斯包络宽度$\\sigma=1.0\\times 10^6$米和波包中心$(x_0,y_0)=(L_x/2,L_y/2)$。初始流函数的振幅使用$A=1.0\\times 10^5$平方米/秒。\n\n- 情况1（典型中纬度波包）：\n    - $L_x = 1.0\\times 10^7$ 米, $L_y = 8.0\\times 10^6$ 米, $N_x=256$, $N_y=128$。\n    - $\\Delta t = 2.16\\times 10^4$ 秒, $N_t = 240$。\n    - $\\beta = 2.0\\times 10^{-11}$ 每米每秒, $R_d = 2.0\\times 10^6$ 米。\n    - 载波波数: $k_0 = 2\\pi / (3.0\\times 10^6)$ 弧度/米, $l_0 = 0.0$ 弧度/米。\n\n- 情况2（具有西传载波的各向异性波包）：\n    - $L_x = 1.0\\times 10^7$ 米, $L_y = 8.0\\times 10^6$ 米, $N_x=256$, $N_y=128$。\n    - $\\Delta t = 2.16\\times 10^4$ 秒, $N_t = 240$。\n    - $\\beta = 2.0\\times 10^{-11}$ 每米每秒, $R_d = 1.5\\times 10^6$ 米。\n    - 载波波数: $k_0 = -2\\pi / (4.0\\times 10^6)$ 弧度/米, $l_0 = 2\\pi / (6.0\\times 10^6)$ 弧度/米。\n\n- 情况3（准正压长波极限）：\n    - $L_x = 1.0\\times 10^7$ 米, $L_y = 8.0\\times 10^6$ 米, $N_x=256$, $N_y=128$。\n    - $\\Delta t = 2.16\\times 10^4$ 秒, $N_t = 240$。\n    - $\\beta = 2.0\\times 10^{-11}$ 每米每秒, $R_d = 1.0\\times 10^9$ 米。\n    - 载波波数: $k_0 = 2\\pi / (8.0\\times 10^6)$ 弧度/米, $l_0 = 2\\pi / (8.0\\times 10^6)$ 弧度/米。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三种情况的结果，以逗号分隔的列表形式包含在方括号内，每个条目是测量得到的纬向群速度与解析的纬向群速度之间的绝对误差（单位为米/秒），四舍五入到六位小数，并按上述情况的顺序列出（即，\"[error_case1,error_case2,error_case3]\"）。",
            "solution": "该问题要求设计一个数值实验，以测量行星罗斯比波包的纬向群速度，并将其与解析预测进行比较。该过程包括三个主要阶段：推导解析解、执行数值模拟以及分析模拟输出来测量群速度。\n\n### **1. 解析推导**\n\n控制物理过程由β平面上的线性准地转位涡（QGPV）方程描述。位涡$q$与流函数$\\psi(x,y,t)$的关系如下：\n$$q(x,y,t) = \\nabla^2 \\psi - \\frac{1}{R_d^2} \\psi$$\n其中$\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$是拉普拉斯算子，$R_d$是斜压变形半径。$q$的线性演化由下式给出：\n$$\\frac{\\partial q}{\\partial t} + \\beta \\frac{\\partial \\psi}{\\partial x} = 0$$\n其中$\\beta$是科里奥利参数的恒定经向梯度。\n\n为了找到平面波的色散关系，我们将QGPV的定义代入演化方程中：\n$$\\frac{\\partial}{\\partial t} \\left(\\nabla^2 \\psi - \\frac{1}{R_d^2} \\psi\\right) + \\beta \\frac{\\partial \\psi}{\\partial x} = 0$$\n我们寻求形如$\\psi(x,y,t) = \\hat{\\psi} e^{i(k_x x + k_y y - \\omega t)}$的平面波解，其中$\\hat{\\psi}$是常数振幅，$k_x$和$k_y$分别是纬向和经向波数，$\\omega$是时间频率。将此代入方程得到：\n$$-i\\omega \\left( -(k_x^2 + k_y^2) - \\frac{1}{R_d^2} \\right) \\hat{\\psi} e^{i(\\dots)} + \\beta (ik_x) \\hat{\\psi} e^{i(\\dots)} = 0$$\n除以$i\\hat{\\psi}e^{i(\\dots)}$（假设为非平凡解）得到：\n$$\\omega \\left( k_x^2 + k_y^2 + \\frac{1}{R_d^2} \\right) + \\beta k_x = 0$$\n求解$\\omega$得到罗斯比波的色散关系：\n$$\\omega(k_x, k_y) = - \\frac{\\beta k_x}{k_x^2 + k_y^2 + R_d^{-2}}$$\n\n纬向群速度$c_{gx}$是频率对纬向波数的偏导数：\n$$c_{gx}(k_x, k_y) = \\frac{\\partial \\omega}{\\partial k_x}$$\n对$\\omega(k_x, k_y)$的表达式使用商法则进行微分：\n$$c_{gx} = \\frac{(-\\beta)(k_x^2 + k_y^2 + R_d^{-2}) - (-\\beta k_x)(2k_x)}{(k_x^2 + k_y^2 + R_d^{-2})^2}$$\n简化分子，我们得到纬向群速度的解析表达式：\n$$c_{gx}(k_x, k_y) = \\frac{\\beta (k_x^2 - k_y^2 - R_d^{-2})}{(k_x^2 + k_y^2 + R_d^{-2})^2}$$\n该表达式将用于在每个测试案例的载波波数$(k_0, l_0)$处计算预测的群速度。\n\n### **2. 数值模拟设计**\n\n模拟将初始波包随时间向前演化。采用谱方法，因为它在周期域上求解线性、常系数偏微分方程时具有高精度和高效率。\n\n#### **2.1. 谱空间中的时间演化**\n在傅里叶（波数）空间中，控制方程是关于流函数傅里叶变换$\\hat{\\psi}(k_x, k_y, t)$的常微分方程（ODE）。对控制偏微分方程进行变换得到：\n$$\\frac{d\\hat{\\psi}}{dt} = -i\\omega(k_x, k_y)\\hat{\\psi}$$\n其中$\\omega(k_x, k_y)$是先前推导出的频率。这个线性ODE的精确解是：\n$$\\hat{\\psi}(k_x, k_y, t) = \\hat{\\psi}(k_x, k_y, 0) e^{-i\\omega(k_x, k_y) t}$$\n因此，数值算法包括：\n1.  在物理空间中定义初始条件$\\psi(x, y, 0)$。\n2.  计算其二维快速傅里叶变换（FFT）以得到$\\hat{\\psi}(k_x, k_y, 0)$。\n3.  对于每个期望的时间$t$，使用上述精确相位演化公式计算$\\hat{\\psi}(k_x, k_y, t)$。\n4.  应用二维逆FFT以获得物理空间解$\\psi(x, y, t)$。\n\n#### **2.2. 初始条件**\n初始流函数$\\psi(x,y,0)$是一个以$(x_0, y_0)=(L_x/2, L_y/2)$为中心的高斯调制波包：\n$$\\psi(x,y,0) = A \\exp\\left(-\\frac{(x-x_0)^2 + (y-y_0)^2}{2\\sigma^2}\\right) \\cos(k_0 (x-x_0) + l_0(y-y_0))$$\n其中$A$是振幅，$\\sigma$是包络宽度，$(k_0,l_0)$是载波波数。\n\n### **3. 波数-频率诊断**\n\n纬向群速度是使用谱分析从模拟输出中测量得到的。\n\n1.  **数据收集**：通过在每个时间步记录沿中心纬向截面$y=y_0$的流函数，创建一个一维时空数据集$s(x,t) = \\psi(x, y_0, t)$。\n2.  **加窗**：为减轻由数据集有限持续时间和长度引起的谱泄漏，对$s(x,t)$应用一个二维汉宁窗。该窗是可分离的，由两个一维汉宁窗的外积形成，一个用于时间维度，一个用于空间维度。\n3.  **谱分析**：计算加窗数据集$s(x,t)$的二维FFT，得到复数谱$S(k_x, \\omega)$。然后功率谱为$P(k_x, \\omega) = |S(k_x, \\omega)|^2$。\n4.  **群速度估计**：群速度是$(k_x, \\omega)$平面中最大功率脊的斜率。为估计该斜率，我们确定最接近载波波数$k_0$的离散纬向波数$k_{d0}$。然后，我们找到在相邻离散波数$k_{d0} - \\Delta k_x$和$k_{d0} + \\Delta k_x$处对应最大谱功率的频率$\\omega_{-1}$和$\\omega_{+1}$，其中$\\Delta k_x$是纬向波数网格间距。数值群速度使用中心有限差分近似进行估计：\n$$c_{gx, \\text{measured}} \\approx \\frac{\\omega_{+1} - \\omega_{-1}}{(k_{d0} + \\Delta k_x) - (k_{d0} - \\Delta k_x)} = \\frac{\\omega_{+1} - \\omega_{-1}}{2\\Delta k_x}$$\n\n最后，计算绝对误差$|c_{gx, \\text{measured}} - c_{gx, \\text{analytical}}|$。对所提供的三个测试案例中的每一个都实施此完整过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        { # Case 1\n            \"Lx\": 1.0e7, \"Ly\": 8.0e6, \"Nx\": 256, \"Ny\": 128,\n            \"dt\": 2.16e4, \"Nt\": 240,\n            \"beta\": 2.0e-11, \"Rd\": 2.0e6,\n            \"k0\": 2 * np.pi / (3.0e6), \"l0\": 0.0,\n            \"A\": 1.0e5, \"sigma\": 1.0e6\n        },\n        { # Case 2\n            \"Lx\": 1.0e7, \"Ly\": 8.0e6, \"Nx\": 256, \"Ny\": 128,\n            \"dt\": 2.16e4, \"Nt\": 240,\n            \"beta\": 2.0e-11, \"Rd\": 1.5e6,\n            \"k0\": -2 * np.pi / (4.0e6), \"l0\": 2 * np.pi / (6.0e6),\n            \"A\": 1.0e5, \"sigma\": 1.0e6\n        },\n        { # Case 3\n            \"Lx\": 1.0e7, \"Ly\": 8.0e6, \"Nx\": 256, \"Ny\": 128,\n            \"dt\": 2.16e4, \"Nt\": 240,\n            \"beta\": 2.0e-11, \"Rd\": 1.0e9,\n            \"k0\": 2 * np.pi / (8.0e6), \"l0\": 2 * np.pi / (8.0e6),\n            \"A\": 1.0e5, \"sigma\": 1.0e6\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        error = run_and_analyze_case(case_params)\n        results.append(f\"{error:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef run_and_analyze_case(params):\n    \"\"\"\n    Runs the simulation and analysis for a single test case.\n    \"\"\"\n    # Unpack parameters\n    Lx, Ly, Nx, Ny = params[\"Lx\"], params[\"Ly\"], params[\"Nx\"], params[\"Ny\"]\n    dt, Nt = params[\"dt\"], params[\"Nt\"]\n    beta, Rd = params[\"beta\"], params[\"Rd\"]\n    k0, l0 = params[\"k0\"], params[\"l0\"]\n    A, sigma = params[\"A\"], params[\"sigma\"]\n\n    x0, y0 = Lx / 2.0, Ly / 2.0\n\n    # 1. Analytical Group Velocity\n    def analytical_cgx(k_x, k_y, b, R_d):\n        k_sq = k_x**2 + k_y**2\n        R_d_inv_sq = 1.0 / R_d**2\n        denom_term = k_sq + R_d_inv_sq\n        \n        num = b * (k_x**2 - k_y**2 - R_d_inv_sq)\n        den = denom_term**2\n        return num / den\n\n    cgx_analytical = analytical_cgx(k0, l0, beta, Rd)\n\n    # 2. Numerical Simulation\n    # Spatial grids and wavenumbers\n    dx, dy = Lx / Nx, Ly / Ny\n    x = np.arange(Nx) * dx\n    y = np.arange(Ny) * dy\n    xx, yy = np.meshgrid(x, y)\n\n    kx_vec = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n    ky_vec = 2 * np.pi * np.fft.fftfreq(Ny, d=dy)\n    kx, ky = np.meshgrid(kx_vec, ky_vec)\n\n    # Initial condition\n    psi0 = A * np.exp(-((xx - x0)**2 + (yy - y0)**2) / (2 * sigma**2)) * \\\n           np.cos(k0 * (xx - x0) + l0 * (yy - y0))\n           \n    # Time evolution using exact spectral solution\n    psi0_hat = np.fft.fft2(psi0)\n    \n    # Dispersion relation omega(kx, ky)\n    K_sq = kx**2 + ky**2\n    denom_omega = K_sq + 1.0/Rd**2\n    omega = np.zeros_like(denom_omega, dtype=float)\n    mask = (denom_omega != 0)\n    omega[mask] = -beta * kx[mask] / denom_omega[mask]\n\n    # Store transect data s(x,t)\n    y_idx_center = Ny // 2\n    s_xt = np.zeros((Nt, Nx), dtype=float)\n    t_vec = np.arange(Nt) * dt\n\n    for i, t in enumerate(t_vec):\n        psi_hat_t = psi0_hat * np.exp(-1j * omega * t)\n        psi_t = np.fft.ifft2(psi_hat_t)\n        s_xt[i, :] = np.real(psi_t[y_idx_center, :])\n        \n    # 3. Wavenumber-Frequency Diagnostics\n    # Apply Hann window\n    window_t = np.hanning(Nt)\n    window_x = np.hanning(Nx)\n    window_2d = window_t[:, np.newaxis] * window_x[np.newaxis, :]\n    s_xt_windowed = s_xt * window_2d\n    \n    # 2D FFT and power spectrum\n    S_kw = np.fft.fftshift(np.fft.fft2(s_xt_windowed))\n    power_spectrum = np.abs(S_kw)**2\n    \n    # Diagnostic wavenumber and frequency axes\n    k_diag_vec = 2 * np.pi * np.fft.fftshift(np.fft.fftfreq(Nx, d=dx))\n    om_diag_vec = 2 * np.pi * np.fft.fftshift(np.fft.fftfreq(Nt, d=dt))\n    \n    # Find indices and wavenumbers for finite difference\n    idx_k0_carrier = np.argmin(np.abs(k_diag_vec - k0))\n    idx_k_minus = idx_k0_carrier - 1\n    idx_k_plus = idx_k0_carrier + 1\n    \n    # Find peak frequencies at neighboring wavenumbers\n    idx_w_minus = np.argmax(power_spectrum[:, idx_k_minus])\n    idx_w_plus = np.argmax(power_spectrum[:, idx_k_plus])\n    \n    k_minus = k_diag_vec[idx_k_minus]\n    k_plus = k_diag_vec[idx_k_plus]\n    w_minus = om_diag_vec[idx_w_minus]\n    w_plus = om_diag_vec[idx_w_plus]\n    \n    # Measured group velocity using centered difference\n    dk = k_plus - k_minus\n    dw = w_plus - w_minus\n    cgx_measured = dw / dk if dk != 0 else 0.0\n        \n    # 4. Absolute Error\n    error = np.abs(cgx_measured - cgx_analytical)\n    return error\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}