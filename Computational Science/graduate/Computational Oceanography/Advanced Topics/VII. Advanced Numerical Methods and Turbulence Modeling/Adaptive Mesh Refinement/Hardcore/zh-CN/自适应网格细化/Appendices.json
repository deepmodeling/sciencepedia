{
    "hands_on_practices": [
        {
            "introduction": "在有限体积法中，确保物理量的守恒是至关重要的。当自适应网格加密（AMR）引入粗细网格界面时，由于两套网格在时间和空间分辨率上的差异，它们计算出的跨界面通量往往不一致。本练习将通过一个具体的数值案例，让您亲手计算这种通量失配，并应用修正（即“回流”），以强制实现跨尺度守恒，这是保证 AMR 模拟物理真实性的核心步骤。",
            "id": "3785227",
            "problem": "考虑一个使用自适应网格加密 (AMR) 技术的近岸海洋模型，其中对被动标量示踪剂进行二维有限体积离散化。一个宽度为 $\\Delta x_{\\mathrm{c}}$ 的粗网格单元在其东侧与一个加密区域相邻。粗网格单元中的示踪剂质量（记为 $M$）在跨单元面的平流通量作用下遵循守恒定律：$M$ 的变化量等于净流出质量通量在时间上的积分。在加密比 $r=2$ 的 AMR 中，细网格层级在一个粗网格时间步内推进两个子步，并且粗网格的东侧面被两个等长的细网格面所覆盖。假设垂直方向已被积分，所提供的通量率为在整个面的长度和深度上积分得到的总质量通量率。\n\n设粗网格时间步长为 $\\Delta t_{\\mathrm{c}} = 60$ 秒，细网格时间步长为 $\\Delta t_{\\mathrm{f}} = \\Delta t_{\\mathrm{c}}/r = 30$ 秒。假设正通量的方向是从粗网格单元通过共享的东侧界面流向细网格加密区域。在单个粗网格时间步内，粗网格层级的离散化计算得到一个恒定的东侧面质量通量率 $F_{\\mathrm{c}} = 1.00 \\times 10^{6}$ 千克/秒。在细网格层级，覆盖粗网格东侧面的两个细网格面在两个细网格子步中的质量通量率如下：\n- 在子步 $m=1$ 时，细网格通量率分别为 $F_{\\mathrm{f},1}^{(1)} = 5.8 \\times 10^{5}$ 千克/秒 和 $F_{\\mathrm{f},2}^{(1)} = 6.0 \\times 10^{5}$ 千克/秒。\n- 在子步 $m=2$ 时，细网格通量率分别为 $F_{\\mathrm{f},1}^{(2)} = 6.2 \\times 10^{5}$ 千克/秒 和 $F_{\\mathrm{f},2}^{(2)} = 5.9 \\times 10^{5}$ 千克/秒。\n\n假设在此粗网格步长期间，粗网格单元的西侧面没有通量。粗网格单元的初始示踪剂质量为 $M^{n} = 2.00 \\times 10^{8}$ 千克。\n\n从有限体积守恒原理以及通量在时间和面上的积分定义出发，推导在单个粗网格时间步内累积的粗细网格通量不匹配量，并解释如何将其作为修正量应用于粗网格单元，以确保跨粗细网格界面的守恒性。计算粗网格时间步结束时，修正后的粗网格单元示踪剂质量。将最终答案四舍五入至四位有效数字，并以千克为单位表示。",
            "solution": "该问题是有效的，因为它描述了计算流体动力学中的一个标准、适定的场景，特别是在自适应网格加密（AMR）中为确保跨粗细网格界面的质量守恒而进行的通量修正步骤。所有必要数据均已提供，所要求的计算基于有限体积法的基本原理。\n\n控制粗网格有限体积单元中示踪剂质量 $M$ 演化的核心原理是守恒定律，即在一个时间间隔内的质量变化量等于流出单元边界的总质量的负值。以离散形式表示，对于单个粗网格时间步 $\\Delta t_{\\mathrm{c}}$，时刻 $n+1$ 的质量 $M^{n+1}$ 与时刻 $n$ 的质量 $M^n$ 的关系如下：\n$$\nM^{n+1} = M^n - \\Delta M_{\\text{flux}}\n$$\n其中 $\\Delta M_{\\text{flux}}$ 是在时间步 $\\Delta t_{\\mathrm{c}}$ 内流出单元的总净质量。题目指明西侧面没有通量，因此我们只需考虑穿过东侧面的通量。\n\n在 AMR 的背景下，对于从 $t^n$ 到 $t^{n+1} = t^n + \\Delta t_{\\mathrm{c}}$ 的时间间隔内，跨越粗细网格界面的总质量通量有两种不同的计算方法。\n\n首先，粗网格根据其自身的通量估算值计算出总质量流出量 $\\Delta M_{\\mathrm{c}}$。粗网格层级的通量率 $F_{\\mathrm{c}}$ 在粗网格时间步 $\\Delta t_{\\mathrm{c}}$ 内为常数。\n$$\n\\Delta M_{\\mathrm{c}} = F_{\\mathrm{c}} \\cdot \\Delta t_{\\mathrm{c}}\n$$\n使用所提供的值：\n$$\n\\Delta M_{\\mathrm{c}} = (1.00 \\times 10^{6} \\, \\text{kg/s}) \\cdot (60 \\, \\text{s}) = 6.00 \\times 10^{7} \\, \\text{kg}\n$$\n\n其次，细网格通过以更高的空间和时间保真度解析界面，提供了更精确的质量流出量计算 $\\Delta M_{\\mathrm{f}}$。单个粗网格面的通量由两个细网格面的通量来解析，单个粗网格时间步由 $r=2$ 个时长为 $\\Delta t_{\\mathrm{f}} = \\Delta t_{\\mathrm{c}} / r$ 的细网格子步来解析。在细网格层级上计算的总质量流出量是所有细网格面和所有细网格子步上通量的总和。\n\n对于第一个细网格子步（$m=1$，时间间隔 $\\Delta t_{\\mathrm{f}}$），总质量流出量为：\n$$\n\\Delta M_{\\mathrm{f}}^{(1)} = \\left( F_{\\mathrm{f},1}^{(1)} + F_{\\mathrm{f},2}^{(1)} \\right) \\cdot \\Delta t_{\\mathrm{f}}\n$$\n对于第二个细网格子步（$m=2$，时间间隔 $\\Delta t_{\\mathrm{f}}$），总质量流出量为：\n$$\n\\Delta M_{\\mathrm{f}}^{(2)} = \\left( F_{\\mathrm{f},1}^{(2)} + F_{\\mathrm{f},2}^{(2)} \\right) \\cdot \\Delta t_{\\mathrm{f}}\n$$\n根据细网格的计算，在整个粗网格时间步 $\\Delta t_{\\mathrm{c}}$ 内跨界面的总质量流出量是这两部分之和：\n$$\n\\Delta M_{\\mathrm{f}} = \\Delta M_{\\mathrm{f}}^{(1)} + \\Delta M_{\\mathrm{f}}^{(2)} = \\left[ \\left( F_{\\mathrm{f},1}^{(1)} + F_{\\mathrm{f},2}^{(1)} \\right) + \\left( F_{\\mathrm{f},1}^{(2)} + F_{\\mathrm{f},2}^{(2)} \\right) \\right] \\cdot \\Delta t_{\\mathrm{f}}\n$$\n代入给定值：\n$F_{\\mathrm{f},1}^{(1)} = 5.8 \\times 10^{5}$ kg/s, $F_{\\mathrm{f},2}^{(1)} = 6.0 \\times 10^{5}$ kg/s\n$F_{\\mathrm{f},1}^{(2)} = 6.2 \\times 10^{5}$ kg/s, $F_{\\mathrm{f},2}^{(2)} = 5.9 \\times 10^{5}$ kg/s\n$\\Delta t_{\\mathrm{f}} = 30$ s\n\n$$\n\\Delta M_{\\mathrm{f}} = \\left[ (5.8 \\times 10^{5} + 6.0 \\times 10^{5}) + (6.2 \\times 10^{5} + 5.9 \\times 10^{5}) \\right] \\frac{\\text{kg}}{\\text{s}} \\cdot (30 \\, \\text{s})\n$$\n$$\n\\Delta M_{\\mathrm{f}} = \\left[ (1.18 \\times 10^{6}) + (1.21 \\times 10^{6}) \\right] \\frac{\\text{kg}}{\\text{s}} \\cdot (30 \\, \\text{s})\n$$\n$$\n\\Delta M_{\\mathrm{f}} = (2.39 \\times 10^{6} \\, \\text{kg/s}) \\cdot (30 \\, \\text{s}) = 7.17 \\times 10^{7} \\, \\text{kg}\n$$\n\n粗细网格通量不匹配量（我们记为 $\\delta M_{\\text{flux}}$）是细网格计算出的总质量传输量与粗网格计算出的总质量传输量之差。\n$$\n\\delta M_{\\text{flux}} = \\Delta M_{\\mathrm{f}} - \\Delta M_{\\mathrm{c}}\n$$\n$$\n\\delta M_{\\text{flux}} = 7.17 \\times 10^{7} \\, \\text{kg} - 6.00 \\times 10^{7} \\, \\text{kg} = 1.17 \\times 10^{7} \\, \\text{kg}\n$$\n这个不匹配量代表了粗网格通量计算的误差。正值意味着更精确的细网格计算出的从粗网格单元流出的质量大于粗网格自身的计算结果。\n\n为强制实现全局守恒，必须对这种不匹配进行修正。粗网格单元的质量在粗网格时间步中是使用精度较低的通量 $\\Delta M_{\\mathrm{c}}$ 更新的，因此必须对其进行调整。该修正是通过从粗网格单元的质量中减去通量不匹配量来施加的。对粗网格单元质量的改变是 $-\\delta M_{\\text{flux}}$。\n其逻辑如下：粗网格单元质量的一个临时更新值为 $M^{n+1, \\text{uncorrected}} = M^{n} - \\Delta M_{\\mathrm{c}}$。然后将修正应用于该值：\n$$\nM^{n+1, \\text{corrected}} = M^{n+1, \\text{uncorrected}} - \\delta M_{\\text{flux}} = (M^{n} - \\Delta M_{\\mathrm{c}}) - (\\Delta M_{\\mathrm{f}} - \\Delta M_{\\mathrm{c}})\n$$\n这可以简化为：\n$$\nM^{n+1, \\text{corrected}} = M^{n} - \\Delta M_{\\mathrm{f}}\n$$\n这个结果表明，通量修正过程确保了粗网格单元的质量收支与细网格上计算的更精确的通量相一致，从而维持了守恒性。\n\n现在我们可以使用初始质量 $M^n$ 和来自细网格的总通量 $\\Delta M_{\\mathrm{f}}$ 来计算粗网格单元修正后的最终质量。\n给定 $M^n = 2.00 \\times 10^{8}$ kg：\n$$\nM^{n+1, \\text{corrected}} = 2.00 \\times 10^{8} \\, \\text{kg} - 7.17 \\times 10^{7} \\, \\text{kg}\n$$\n$$\nM^{n+1, \\text{corrected}} = 2.00 \\times 10^{8} \\, \\text{kg} - 0.717 \\times 10^{8} \\, \\text{kg}\n$$\n$$\nM^{n+1, \\text{corrected}} = (2.00 - 0.717) \\times 10^{8} \\, \\text{kg} = 1.283 \\times 10^{8} \\, \\text{kg}\n$$\n该值已按要求表示为四位有效数字。",
            "answer": "$$\\boxed{1.283 \\times 10^{8}}$$"
        },
        {
            "introduction": "当我们在一个已有的粗网格上生成新的细网格时，需要一个“延长”（prolongation）算子来为细网格单元赋予初始值。一个优秀的延长算子必须同时满足准确性和守恒性：它既要保留粗网格解的特征，又要确保新生成的细网格单元上的物理总量与原粗网格单元的物理量完全相等。本练习将引导您从第一性原理出发，推导一个二维双线性延长算子，从而深刻理解如何在 AMR 中实现守恒的、高阶准确的信息下传。",
            "id": "4009052",
            "problem": "在数值天气预报 (NWP) 和气候建模中，自适应网格加密 (AMR) 需要既守恒又至少二阶精确的延拓算子，以防止标量（如示踪物质量）的虚假产生或损失。考虑一个以原点为中心的有限体积粗网格单元，其在 $x$ 和 $y$ 方向上的均匀间距分别为 $\\Delta x_c$ 和 $\\Delta y_c$。设一个无量纲守恒标量场在粗网格层级上由粗网格单元平均值 $\\bar{q}_c$ 表示。假设在粗网格单元内进行形式如下的双线性重构\n$$\np(x,y) \\equiv \\bar{q}_c + S_x\\,x + S_y\\,y + S_{xy}\\,x\\,y,\n$$\n其中 $S_x$、$S_y$ 和 $S_{xy}$ 是局部一阶导数和混合项系数的二阶精确、粗网格层级估计，而 $(x,y)$ 是从粗网格单元中心测量的局部坐标，满足 $x \\in [-\\Delta x_c/2,\\,\\Delta x_c/2]$ 和 $y \\in [-\\Delta y_c/2,\\,\\Delta y_c/2]$。细网格层级是在每个空间方向上进行2倍加密，通过在 $x=0$ 和 $y=0$ 处分割，产生四个细网格子单元：东北 (NE) 子单元，$x \\in [0,\\,\\Delta x_c/2]$，$y \\in [0,\\,\\Delta y_c/2]$；西北 (NW) 子单元，$x \\in [-\\Delta x_c/2,\\,0]$，$y \\in [0,\\,\\Delta y_c/2]$；西南 (SW) 子单元，$x \\in [-\\Delta x_c/2,\\,0]$，$y \\in [-\\Delta y_c/2,\\,0]$；以及东南 (SE) 子单元，$x \\in [0,\\,\\Delta x_c/2]$，$y \\in [-\\Delta y_c/2,\\,0]$。\n\n仅使用有限体积的单元平均值定义和守恒原理，推导将粗网格单元平均值和双线性系数映射到四个细网格单元平均值的二阶守恒延拓模板，其定义为\n$$\n\\bar{q}_{R} \\equiv \\frac{1}{A_R} \\int_{R} p(x,y)\\, \\mathrm{d}A,\n$$\n对于每个区域 $R \\in \\{\\mathrm{NE},\\mathrm{NW},\\mathrm{SW},\\mathrm{SE}\\}$，其面积为 $A_R = (\\Delta x_c/2)(\\Delta y_c/2)$，且 $\\mathrm{d}A = \\mathrm{d}x\\,\\mathrm{d}y$。你的最终答案必须是关于 $\\bar{q}_c$、$\\Delta x_c$、$\\Delta y_c$、$S_x$、$S_y$ 和 $S_{xy}$ 的 $\\bar{q}_{\\mathrm{NE}}$、$\\bar{q}_{\\mathrm{NW}}$、$\\bar{q}_{\\mathrm{SW}}$ 和 $\\bar{q}_{\\mathrm{SE}}$ 的显式解析表达式。请将您的最终答案以 $(\\bar{q}_{\\mathrm{NE}}, \\bar{q}_{\\mathrm{NW}}, \\bar{q}_{\\mathrm{SW}}, \\bar{q}_{\\mathrm{SE}})$ 的顺序表示为单行矩阵。请精确表达您的答案；无需四舍五入或单位。",
            "solution": "该问题陈述已经过验证，被认为是科学上成立、内容自洽、逻辑一致且提法适定的。任务是为一种有限体积方法推导二阶守恒延拓模板，该模板将一个粗网格单元的平均值及其重构分布映射到四个细网格单元的平均值。\n\n要使用的基本原理是守恒标量场 $q$ 的单元平均值定义。对于任何面积为 $A_R$ 的区域 $R$，其单元平均值 $\\bar{q}_R$ 定义为标量场在该区域上的积分除以该区域的面积：\n$$\n\\bar{q}_{R} \\equiv \\frac{1}{A_R} \\int_{R} q(x,y)\\, \\mathrm{d}A\n$$\n在本问题中，粗网格单元内的标量场分布由一个双线性重构多项式 $p(x,y)$ 给出：\n$$\np(x,y) = \\bar{q}_c + S_x\\,x + S_y\\,y + S_{xy}\\,x\\,y\n$$\n粗网格单元以原点为中心，其定义域为 $x \\in [-\\Delta x_c/2, \\Delta x_c/2]$ 和 $y \\in [-\\Delta y_c/2, \\Delta y_c/2]$。细网格是2倍加密的结果，产生了四个子单元（NE, NW, SW, SE），每个子单元的面积为 $A_R = (\\Delta x_c/2)(\\Delta y_c/2) = \\frac{\\Delta x_c \\Delta y_c}{4}$。\n\n我们的目标是计算 $p(x,y)$ 在这四个子单元中每一个上的平均值。我们将一个通用的子单元区域表示为 $R$。其平均值为：\n$$\n\\bar{q}_{R} = \\frac{1}{A_R} \\int_{R} (\\bar{q}_c + S_x\\,x + S_y\\,y + S_{xy}\\,x\\,y)\\, \\mathrm{d}x\\,\\mathrm{d}y\n$$\n根据积分的线性性质，我们可以分离各项：\n$$\n\\bar{q}_{R} = \\frac{1}{A_R} \\left( \\bar{q}_c \\int_{R} 1\\, \\mathrm{d}x\\,\\mathrm{d}y + S_x \\int_{R} x\\, \\mathrm{d}x\\,\\mathrm{d}y + S_y \\int_{R} y\\, \\mathrm{d}x\\,\\mathrm{d}y + S_{xy} \\int_{R} xy\\, \\mathrm{d}x\\,\\mathrm{d}y \\right)\n$$\n第一个积分 $\\int_{R} 1\\, \\mathrm{d}x\\,\\mathrm{d}y$ 就是该区域的面积 $A_R$。这可将表达式简化为：\n$$\n\\bar{q}_{R} = \\bar{q}_c + \\frac{S_x}{A_R} \\int_{R} x\\, \\mathrm{d}x\\,\\mathrm{d}y + \\frac{S_y}{A_R} \\int_{R} y\\, \\mathrm{d}x\\,\\mathrm{d}y + \\frac{S_{xy}}{A_R} \\int_{R} xy\\, \\mathrm{d}x\\,\\mathrm{d}y\n$$\n剩余的积分可以对一个面积为 $A_R = (x_2 - x_1)(y_2 - y_1)$ 的通用矩形区域 $[x_1, x_2] \\times [y_1, y_2]$ 进行计算。这个矩形的形心是 $(\\bar{x}_R, \\bar{y}_R) = (\\frac{x_1+x_2}{2}, \\frac{y_1+y_2}{2})$。\n积分为：\n$$\n\\int_{R} x\\, \\mathrm{d}A = \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} x\\, \\mathrm{d}x\\,\\mathrm{d}y = \\left[\\frac{x^2}{2}\\right]_{x_1}^{x_2} \\left[y\\right]_{y_1}^{y_2} = \\frac{x_2^2-x_1^2}{2}(y_2-y_1) = \\frac{(x_2-x_1)(x_2+x_1)}{2}(y_2-y_1) = A_R \\bar{x}_R\n$$\n$$\n\\int_{R} y\\, \\mathrm{d}A = \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} y\\, \\mathrm{d}x\\,\\mathrm{d}y = (x_2-x_1)\\frac{y_2^2-y_1^2}{2} = A_R \\bar{y}_R\n$$\n$$\n\\int_{R} xy\\, \\mathrm{d}A = \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} xy\\, \\mathrm{d}x\\,\\mathrm{d}y = \\left[\\frac{x^2}{2}\\right]_{x_1}^{x_2} \\left[\\frac{y^2}{2}\\right]_{y_1}^{y_2} = \\frac{x_2^2-x_1^2}{2} \\frac{y_2^2-y_1^2}{2} = (A_R \\bar{x}_R) \\bar{y}_R = A_R \\bar{x}_R \\bar{y}_R\n$$\n将这些结果代回到 $\\bar{q}_R$ 的表达式中，我们得到了双线性多项式在任何矩形子区域 $R$ 上的平均值的通用公式：\n$$\n\\bar{q}_R = \\bar{q}_c + S_x \\bar{x}_R + S_y \\bar{y}_R + S_{xy} \\bar{x}_R \\bar{y}_R\n$$\n这个简洁的结果表明，细网格单元的平均值是通过在细网格单元的形心处计算导数项的贡献来确定的。现在我们通过找到四个子单元各自的形心，将此公式应用于每个子单元。\n\n1.  **东北 (NE) 子单元**：$x \\in [0, \\Delta x_c/2]$，$y \\in [0, \\Delta y_c/2]$。\n    形心为 $(\\bar{x}_{\\mathrm{NE}}, \\bar{y}_{\\mathrm{NE}}) = (\\frac{0+\\Delta x_c/2}{2}, \\frac{0+\\Delta y_c/2}{2}) = (\\frac{\\Delta x_c}{4}, \\frac{\\Delta y_c}{4})$。\n    $$\n    \\bar{q}_{\\mathrm{NE}} = \\bar{q}_c + S_x \\left(\\frac{\\Delta x_c}{4}\\right) + S_y \\left(\\frac{\\Delta y_c}{4}\\right) + S_{xy} \\left(\\frac{\\Delta x_c}{4}\\right)\\left(\\frac{\\Delta y_c}{4}\\right) = \\bar{q}_c + \\frac{S_x \\Delta x_c}{4} + \\frac{S_y \\Delta y_c}{4} + \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}\n    $$\n\n2.  **西北 (NW) 子单元**：$x \\in [-\\Delta x_c/2, 0]$，$y \\in [0, \\Delta y_c/2]$。\n    形心为 $(\\bar{x}_{\\mathrm{NW}}, \\bar{y}_{\\mathrm{NW}}) = (\\frac{-\\Delta x_c/2+0}{2}, \\frac{0+\\Delta y_c/2}{2}) = (-\\frac{\\Delta x_c}{4}, \\frac{\\Delta y_c}{4})$。\n    $$\n    \\bar{q}_{\\mathrm{NW}} = \\bar{q}_c + S_x \\left(-\\frac{\\Delta x_c}{4}\\right) + S_y \\left(\\frac{\\Delta y_c}{4}\\right) + S_{xy} \\left(-\\frac{\\Delta x_c}{4}\\right)\\left(\\frac{\\Delta y_c}{4}\\right) = \\bar{q}_c - \\frac{S_x \\Delta x_c}{4} + \\frac{S_y \\Delta y_c}{4} - \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}\n    $$\n\n3.  **西南 (SW) 子单元**：$x \\in [-\\Delta x_c/2, 0]$，$y \\in [-\\Delta y_c/2, 0]$。\n    形心为 $(\\bar{x}_{\\mathrm{SW}}, \\bar{y}_{\\mathrm{SW}}) = (\\frac{-\\Delta x_c/2+0}{2}, \\frac{-\\Delta y_c/2+0}{2}) = (-\\frac{\\Delta x_c}{4}, -\\frac{\\Delta y_c}{4})$。\n    $$\n    \\bar{q}_{\\mathrm{SW}} = \\bar{q}_c + S_x \\left(-\\frac{\\Delta x_c}{4}\\right) + S_y \\left(-\\frac{\\Delta y_c}{4}\\right) + S_{xy} \\left(-\\frac{\\Delta x_c}{4}\\right)\\left(-\\frac{\\Delta y_c}{4}\\right) = \\bar{q}_c - \\frac{S_x \\Delta x_c}{4} - \\frac{S_y \\Delta y_c}{4} + \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}\n    $$\n\n4.  **东南 (SE) 子单元**：$x \\in [0, \\Delta x_c/2]$，$y \\in [-\\Delta y_c/2, 0]$。\n    形心为 $(\\bar{x}_{\\mathrm{SE}}, \\bar{y}_{\\mathrm{SE}}) = (\\frac{0+\\Delta x_c/2}{2}, \\frac{-\\Delta y_c/2+0}{2}) = (\\frac{\\Delta x_c}{4}, -\\frac{\\Delta y_c}{4})$。\n    $$\n    \\bar{q}_{\\mathrm{SE}} = \\bar{q}_c + S_x \\left(\\frac{\\Delta x_c}{4}\\right) + S_y \\left(-\\frac{\\Delta y_c}{4}\\right) + S_{xy} \\left(\\frac{\\Delta x_c}{4}\\right)\\left(-\\frac{\\Delta y_c}{4}\\right) = \\bar{q}_c + \\frac{S_x \\Delta x_c}{4} - \\frac{S_y \\Delta y_c}{4} - \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}\n    $$\n\n为验证此延拓模板的守恒性质，我们检查细网格单元平均值的平均值是否等于粗网格单元的平均值。\n$$\n\\frac{1}{4}(\\bar{q}_{\\mathrm{NE}} + \\bar{q}_{\\mathrm{NW}} + \\bar{q}_{\\mathrm{SW}} + \\bar{q}_{\\mathrm{SE}}) = \\frac{1}{4} \\left( 4\\bar{q}_c \\right)\n+ \\frac{1}{4}\\frac{S_x \\Delta x_c}{4}(1 - 1 - 1 + 1)\n+ \\frac{1}{4}\\frac{S_y \\Delta y_c}{4}(1 + 1 - 1 - 1)\n+ \\frac{1}{4}\\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}(1 - 1 + 1 - 1)\n$$\n$$\n= \\bar{q}_c + 0 + 0 + 0 = \\bar{q}_c\n$$\n由于细网格单元的值（按面积加权）之和等于粗网格单元的值，因此该过程是守恒的。推导出的表达式构成了所需的延拓模板。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\bar{q}_c + \\frac{S_x \\Delta x_c}{4} + \\frac{S_y \\Delta y_c}{4} + \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}  \\bar{q}_c - \\frac{S_x \\Delta x_c}{4} + \\frac{S_y \\Delta y_c}{4} - \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}  \\bar{q}_c - \\frac{S_x \\Delta x_c}{4} - \\frac{S_y \\Delta y_c}{4} + \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}  \\bar{q}_c + \\frac{S_x \\Delta x_c}{4} - \\frac{S_y \\Delta y_c}{4} - \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在实际的 AMR 应用中，一个常见的问题是“抖动”（thrashing）：当一个动态特征（如激波）在网格间移动时，其边缘的单元可能会在每个时间步被反复地加密和解密，造成了巨大的计算浪费。本编码练习旨在解决这一实际工程问题，要求您设计并实现一个基于“滞后”效应的加密决策方案，通过设置不同的加密和解密阈值以及一个“保持时间”，有效抑制这种不稳定行为。通过这个实践，您将掌握提升 AMR 算法效率和鲁棒性的关键控制策略。",
            "id": "3094967",
            "problem": "您的任务是设计并实现一个基于滞回的自适应网格加密决策方案，以避免在一维模拟（类似于Sod激波管）中，当移动激波穿过单元边界时发生反复的加密/粗化切换。计算目标纯粹是算法性的：不要解控制偏微分方程。相反，您需要基于一个从具有移动类间断特征的连续代理密度分布中导出的误差指标，来推导、实现和比较决策逻辑。\n\n基本和核心定义：自适应网格加密（Adaptive Mesh Refinement, AMR）在误差指标高的区域加密计算网格，在误差指标低的区域进行粗化。在Sod激波管中，移动的激波会在密度场中产生巨大的梯度。设计算域为区间 $[0,1]$。存在 $N_{\\text{cells}}$ 个均匀的粗网格单元，其单元宽度为 $\\Delta x = \\frac{1}{N_{\\text{cells}}}$，单元中心为 $x_i = \\left(i + \\frac{1}{2}\\right)\\Delta x$，其中整数 $i \\in \\{0,1,\\dots,N_{\\text{cells}}-1\\}$。定义一个带有移动跳跃的光滑代理密度场：\n$$\n\\rho(x,t) = \\rho_R + \\left(\\rho_L - \\rho_R\\right) S(x,t), \\quad S(x,t) = \\frac{1}{2}\\left(1 - \\tanh\\left(\\frac{x - x_s(t)}{w}\\right)\\right),\n$$\n其中 $x_s(t) = x_0 + v t$ 是激波位置，$w > 0$ 是平滑宽度，$\\rho_L$ 是左侧密度状态，$\\rho_R$ 是右侧密度状态。这个代理模型捕捉了类似于Sod激波管背景下的移动陡峭梯度，但保持连续以允许稳定的有限差分计算。单元误差指标由 $\\rho$ 的离散空间梯度定义：\n$$\nI_i(t) = \\frac{\\left|\\rho(x_{i+1}, t) - \\rho(x_i, t)\\right|}{\\Delta x},\n$$\n为避免边界索引问题，$I_{N_{\\text{cells}}-1}(t)$ 的值被设定为与 $I_{N_{\\text{cells}}-2}(t)$ 相等。为模拟传感器不确定性和模型离散化噪声，可以向 $I_i(t)$ 添加一个标准差为 $\\sigma$ 的零均值加性高斯噪声项；添加噪声后，任何负的指标值必须被截断为 $0$。\n\n需要实现和比较的决策方案：\n- 朴素方案（单一阈值）：给定一个阈值 $T$，定义加密标志 $R_i(t)$ 为：如果 $I_i(t) \\ge T$，则 $R_i(t) = \\text{true}$；否则 $R_i(t) = \\text{false}$。\n- 滞回方案（双阈值加保持时间）：给定一个加密阈值 $T_r$、一个粗化阈值 $T_d$（其中 $T_d  T_r$）以及一个以整数时间步为单位的保持时间 $H$，按如下方式实现 $R_i(t)$。如果 $R_i(t-1) = \\text{false}$，则仅在 $I_i(t) > T_r$ 时进行加密；若在时间 $t$ 发生加密，则设置一个保持计数器 $h_i(t) = H$。如果 $R_i(t-1) = \\text{true}$，则当 $h_i(t-1) > 0$ 时继续保持加密状态，此时无论 $I_i(t)$ 值如何，都设置 $R_i(t) = \\text{true}$ 和 $h_i(t) = h_i(t-1) - 1$。当保持计数器达到 $0$ 后，仅在 $I_i(t)  T_d$ 时进行粗化；否则保持 $R_i(t) = \\text{true}$。如果 $I_i(t)$ 不满足任何一个严格不等式（即等于阈值），则保持当前状态。这创建了一个死区和时间上的持续性，以避免抖动。\n\n性能度量和抖动定义：定义一次模拟中状态切换的总次数为\n$$\nN_{\\text{toggles}} = \\sum_{t=1}^{N_{\\text{steps}}-1} \\sum_{i=0}^{N_{\\text{cells}}-1} \\mathbf{1}\\left[R_i(t) \\ne R_i(t-1)\\right],\n$$\n其中 $N_{\\text{steps}}$ 是离散时间步的总数，$\\mathbf{1}[\\cdot]$ 是指示函数（当条件为真时值为 $1$，为假时为 $0$）。计算朴素方案的 $N_{\\text{toggles}}^{\\text{naive}}$ 和滞回方案的 $N_{\\text{toggles}}^{\\text{hyst}}$，然后对每个测试用例报告其差值 $D = N_{\\text{toggles}}^{\\text{naive}} - N_{\\text{toggles}}^{\\text{hyst}}$。\n\n从基本原理出发：该方案必须源于以下定义：由守恒律驱动的加密（大梯度意味着感兴趣的区域）、作为经过良好测试的数值近似的离散梯度定义，以及作为一种具有时间持续性的双阈值死区的滞回概念，用以抑制由小波动引起的快速切换。\n\n算法要求：\n1. 使用每个测试用例中指定的参数来计算代理密度。\n2. 在每个时间步 $t_k = k\\,\\Delta t$（其中整数 $k \\in \\{0,1,\\dots,N_{\\text{steps}}-1\\}$），计算 $\\rho(x_i, t_k)$ 和指标 $I_i(t_k)$，然后对两种方案独立应用决策逻辑。\n3. 统计整个模拟过程中每种方案的切换次数，并为每个测试用例返回差值 $D$。\n\n角度单位不适用，最终答案中无需物理单位；所有量在构造上都是无量纲的。\n\n测试套件和参数：\n提供三个测试用例以探究不同方面：\n- 用例 1（带有轻微噪声的普通移动激波）：\n  - $N_{\\text{cells}} = 64$, $N_{\\text{steps}} = 120$, $\\Delta t = 0.005$, $x_0 = 0.20$, $v = 0.25$, $w = 0.020$, $\\rho_L = 1.00$, $\\rho_R = 0.125$, $\\sigma = 0.5$, 随机种子 $s = 42$,\n  - 朴素方案阈值 $T = 14$,\n  - 滞回方案阈值和保持时间 $T_r = 16$, $T_d = 12$, $H = 3$。\n- 用例 2（接近等式且无噪声的边界条件）：\n  - $N_{\\text{cells}} = 64$, $N_{\\text{steps}} = 120$, $\\Delta t = 0.005$, $x_0 = 0.25$, $v = 0.30$, $w = 0.040$, $\\rho_L = 1.00$, $\\rho_R = 0.125$, $\\sigma = 0.0$, 随机种子 $s = 7$,\n  - 朴素方案阈值 $T = 11$,\n  - 滞回方案阈值和保持时间 $T_r = 12$, $T_d = 10$, $H = 2$。\n- 用例 3（旨在引发振荡的带强噪声的边缘情况）：\n  - $N_{\\text{cells}} = 64$, $N_{\\text{steps}} = 120$, $\\Delta t = 0.005$, $x_0 = 0.20$, $v = 0.25$, $w = 0.020$, $\\rho_L = 1.00$, $\\rho_R = 0.125$, $\\sigma = 3.0$, 随机种子 $s = 123$,\n  - 朴素方案阈值 $T = 14$,\n  - 滞回方案阈值和保持时间 $T_r = 16$, $T_d = 12$, $H = 4$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，即按顺序排列的三个用例的差值 $D$：\n$$\n[D_1, D_2, D_3]\n$$",
            "solution": "该问题要求在一维移动激波剖面的背景下，设计、实现并比较两种用于自适应网格加密（AMR）的决策方案。目标是量化基于滞回的方案相对于朴素单阈值方案在减少加密状态“切换”或“抖动”方面的改进程度。\n\n### 基于原理的设计与模型构建\n\n该问题的基础在于守恒律的数值方法和控制理论的原理。在流体动力学模拟中，像激波这样的特征在物理量（如密度、压力）上表现出巨大的梯度。为了在整个计算域内以不过高的计算成本精确解析这些特征，AMR技术会局部地加密网格。加密或粗化的决策基于一个误差指标，该指标通常是局部解梯度的一种度量。\n\n1.  **代理物理模型**：我们使用一个连续的代理密度剖面 $\\rho(x,t)$ 来模拟一个移动的类激波特征。这避免了求解双曲型偏微分方程的复杂性，同时保留了陡峭移动梯度的本质特征。该函数定义为：\n    $$\n    \\rho(x,t) = \\rho_R + \\left(\\rho_L - \\rho_R\\right) S(x,t)\n    $$\n    其中 $\\rho_L$ 和 $\\rho_R$ 分别是激波左右两侧的密度。过渡过程由一个平滑的阶跃函数控制：\n    $$\n    S(x,t) = \\frac{1}{2}\\left(1 - \\tanh\\left(\\frac{x - x_s(t)}{w}\\right)\\right)\n    $$\n    这里，$x_s(t) = x_0 + v t$ 是激波中心随时间变化的位置，以速度 $v$ 移动，$w$ 是一个控制梯度宽度或陡峭度的参数。双曲正切函数 $\\tanh$ 提供了一个平滑但急剧的过渡，模拟了在数值网格上解析的激波剖面。\n\n2.  **误差指标**：任何AMR策略的核心都是误差指标。数值分析中的一个基本原理是，局部截断误差与解的高阶导数有关。一个简单而有效的误差代理是解的一阶导数的模，或其离散近似，即梯度。我们基于密度梯度的有限差分近似，为单元 $i$ 在时间 $t$ 定义单元误差指标 $I_i(t)$：\n    $$\n    I_i(t) = \\frac{\\left|\\rho(x_{i+1}, t) - \\rho(x_i, t)\\right|}{\\Delta x}\n    $$\n    其中 $x_i$ 是单元 $i$ 的中心，$\\Delta x$ 是均匀的单元宽度。该指标在密度变化迅速的区域（即激波附近）会很大，在解平滑的区域会很小。为了模拟真实模拟中固有的测量噪声和离散化效应，我们向 $I_i(t)$ 添加了一个标准差为 $\\sigma$ 的零均值高斯噪声。\n\n3.  **AMR决策方案**：\n    -   **朴素方案**：最简单的方法是，如果一个单元的误差指标超过一个预定的单一阈值 $T$，就对其进行加密。加密标志 $R_i(t)$ 由以下方式确定：\n        $$\n        R_i(t) = \\begin{cases} \\text{true}  \\text{if } I_i(t) \\geq T \\\\ \\text{false}  \\text{if } I_i(t)  T \\end{cases}\n        $$\n        虽然简单，但如果带噪声的指标 $I_i(t)$ 在阈值 $T$ 附近波动，该方案极易出现“抖动”——即快速、反复的加密和粗化。\n\n    -   **滞回方案**：为了抑制抖动，我们采用滞回机制，这是源于控制工程的一个概念，它为系统引入了记忆。这通过两种机制实现：空间死区和时间保持。\n        -   **空间滞回（死区）**：我们使用两个阈值而不是一个：一个加密阈值 $T_r$ 和一个粗化阈值 $T_d$，且 $T_d  T_r$。只有当单元的指标*严格超过* $T_r$ 时，才将其标记为需要加密。只有当其指标*下降到* $T_d$ 以下时，才将其标记为需要粗化。对于指标 $I_i(t)$ 在“死区” $[T_d, T_r]$ 内的任何值，单元的加密状态都不会改变。这可以防止因指标在该带内的微小波动而引起的切换。\n        -   **时间滞回（保持时间）**：引入一个保持时间 $H$（整数个时间步）。一旦一个单元被加密，它将被强制保持在加密状态至少 $H$ 个时间步，无论指标的值如何。这强制实现了时间上的稳定性，防止系统因指标的短暂下降而立即撤销加密决策。\n\n4.  **算法实现与评估**：\n    模拟通过离散的时间步 $t_k = k\\,\\Delta t$ 进行。在每一步，算法执行以下操作：\n    -   计算所有单元中心 $x_i$ 的激波位置 $x_s(t_k)$ 和密度值 $\\rho(x_i, t_k)$。\n    -   计算所有单元的误差指标 $I_i(t_k)$，添加指定的噪声，并将负值截断为零。\n    -   独立地应用朴素方案和滞回方案的逻辑，以确定每个单元的加密状态 $R_i(t_k)$。对于滞回方案，这包括根据前一状态、当前指标值以及定义的阈值（$T_r, T_d, H$）来更新状态和保持计数器。\n    -   每种方案的性能通过整个模拟过程中的状态切换总次数 $N_{\\text{toggles}}$ 来衡量。如果在时间 $t_k$ 单元 $i$ 的状态发生改变，即 $R_i(t_k) \\ne R_i(t_{k-1})$，则切换次数加一。最终的度量指标 $D = N_{\\text{toggles}}^{\\text{naive}} - N_{\\text{toggles}}^{\\text{hyst}}$ 直接量化了滞回方案所带来的改进。正值的 $D$ 表示滞回成功减少了状态改变的次数。\n\n该实现将使用NumPy进行向量化以提高效率，在每个时间步同时为所有单元执行计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: General moving shock with mild noise\n        {\n            \"N_cells\": 64, \"N_steps\": 120, \"dt\": 0.005, \"x0\": 0.20, \"v\": 0.25,\n            \"w\": 0.020, \"rho_L\": 1.00, \"rho_R\": 0.125, \"sigma\": 0.5,\n            \"seed\": 42, \"T\": 14, \"Tr\": 16, \"Td\": 12, \"H\": 3\n        },\n        # Case 2: Boundary condition with near-equality and no noise\n        {\n            \"N_cells\": 64, \"N_steps\": 120, \"dt\": 0.005, \"x0\": 0.25, \"v\": 0.30,\n            \"w\": 0.040, \"rho_L\": 1.00, \"rho_R\": 0.125, \"sigma\": 0.0,\n            \"seed\": 7, \"T\": 11, \"Tr\": 12, \"Td\": 10, \"H\": 2\n        },\n        # Case 3: Edge case with strong noise to induce oscillations\n        {\n            \"N_cells\": 64, \"N_steps\": 120, \"dt\": 0.005, \"x0\": 0.20, \"v\": 0.25,\n            \"w\": 0.020, \"rho_L\": 1.00, \"rho_R\": 0.125, \"sigma\": 3.0,\n            \"seed\": 123, \"T\": 14, \"Tr\": 16, \"Td\": 12, \"H\": 4\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        diff = run_simulation_case(case)\n        results.append(diff)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_simulation_case(params):\n    \"\"\"\n    Runs the simulation for a single test case and returns the toggle difference D.\n    \"\"\"\n    # Unpack parameters\n    N_cells = params[\"N_cells\"]\n    N_steps = params[\"N_steps\"]\n    dt = params[\"dt\"]\n    x0 = params[\"x0\"]\n    v = params[\"v\"]\n    w = params[\"w\"]\n    rho_L = params[\"rho_L\"]\n    rho_R = params[\"rho_R\"]\n    sigma = params[\"sigma\"]\n    seed = params[\"seed\"]\n    T = params[\"T\"]\n    Tr = params[\"Tr\"]\n    Td = params[\"Td\"]\n    H = params[\"H\"]\n\n    # Setup grid and time\n    dx = 1.0 / N_cells\n    x_centers = (np.arange(N_cells) + 0.5) * dx\n    times = np.arange(N_steps) * dt\n\n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # State history arrays\n    R_naive_hist = np.zeros((N_steps, N_cells), dtype=bool)\n    R_hyst_hist = np.zeros((N_steps, N_cells), dtype=bool)\n    h_hyst_hist = np.zeros((N_steps, N_cells), dtype=int)\n\n    # Time-stepping loop\n    for k, t in enumerate(times):\n        # 1. Compute surrogate density and error indicator\n        x_s = x0 + v * t\n        arg = (x_centers - x_s) / w\n        S_xt = 0.5 * (1 - np.tanh(arg))\n        rho_xt = rho_R + (rho_L - rho_R) * S_xt\n        \n        # Calculate indicators I_i for i = 0 to N_cells-2\n        indicators_part = np.abs(np.diff(rho_xt)) / dx\n        \n        # Assemble N_cells indicators, setting I_{N-1} = I_{N-2}\n        indicators = np.append(indicators_part, indicators_part[-1])\n        \n        # Add noise and clip at 0\n        noise = rng.normal(loc=0.0, scale=sigma, size=N_cells)\n        indicators_noisy = np.maximum(0, indicators + noise)\n\n        # 2. Update Naive Scheme State\n        R_naive_hist[k, :] = (indicators_noisy >= T)\n\n        # 3. Update Hysteresis Scheme State\n        if k == 0:\n            R_hyst_prev = np.zeros(N_cells, dtype=bool)\n            h_hyst_prev = np.zeros(N_cells, dtype=int)\n        else:\n            R_hyst_prev = R_hyst_hist[k - 1, :]\n            h_hyst_prev = h_hyst_hist[k - 1, :]\n\n        R_hyst_curr = np.copy(R_hyst_prev)\n        h_hyst_curr = np.copy(h_hyst_prev)\n        \n        # Logic for cells that were previously NOT refined\n        was_false_mask = ~R_hyst_prev\n        to_refine_mask = was_false_mask  (indicators_noisy > Tr)\n        R_hyst_curr[to_refine_mask] = True\n        h_hyst_curr[to_refine_mask] = H\n\n        # Logic for cells that were previously refined\n        was_true_mask = R_hyst_prev\n        \n        # Decrement hold counter if it's positive\n        holding_mask = was_true_mask  (h_hyst_prev > 0)\n        h_hyst_curr[holding_mask] = h_hyst_prev[holding_mask] - 1\n        \n        # Check for derefinement if hold counter is zero\n        hold_expired_mask = was_true_mask  (h_hyst_prev == 0)\n        to_derefine_mask = hold_expired_mask  (indicators_noisy  Td)\n        R_hyst_curr[to_derefine_mask] = False\n        \n        R_hyst_hist[k, :] = R_hyst_curr\n        h_hyst_hist[k, :] = h_hyst_curr\n\n    # 4. Calculate Toggles\n    # Sum over all cells and time steps from k=1 to N_steps-1\n    toggles_naive = np.sum(R_naive_hist[1:, :] != R_naive_hist[:-1, :])\n    toggles_hyst = np.sum(R_hyst_hist[1:, :] != R_hyst_hist[:-1, :])\n\n    # 5. Return difference\n    return toggles_naive - toggles_hyst\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}