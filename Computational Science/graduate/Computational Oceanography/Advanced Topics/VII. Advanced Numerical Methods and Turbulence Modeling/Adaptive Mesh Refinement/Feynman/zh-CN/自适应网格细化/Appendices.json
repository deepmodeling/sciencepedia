{
    "hands_on_practices": [
        {
            "introduction": "自适应网格加密（AMR）的一个核心步骤是在创建新的精细网格时，如何从其父级粗糙网格中插值数据。这个被称为“延长”（prolongation）的过程不仅需要保证精度，而且对于有限体积法，还必须是守恒的，以避免虚假地产生或消除质量、动量等物理量。通过这个练习，你将推导一个标准的二阶守恒延长算子，从而具体理解在从粗到精的数据传递中如何精确地维持守恒性。",
            "id": "4009052",
            "problem": "在数值天气预报（NWP）和气候模拟中，自适应网格加密（AMR）需要延长算子既是守恒的又至少是二阶精确的，以防止示踪剂质量等标量的虚假产生或损失。考虑一个以原点为中心的有限体积粗网格单元，其在$x$和$y$方向上的均匀间距分别为$\\Delta x_c$和$\\Delta y_c$。设一个无量纲守恒标量场在粗网格层级上由粗网格单元平均值$\\bar{q}_c$表示。假设粗网格单元内存在形式为\n$$\np(x,y) \\equiv \\bar{q}_c + S_x\\,x + S_y\\,y + S_{xy}\\,x\\,y,\n$$\n的双线性重构，其中$S_x$、$S_y$和$S_{xy}$是局部一阶导数和混合项系数的二阶精确的粗网格层级估计值，而$(x,y)$是从粗网格单元中心测量的局部坐标，满足$x \\in [-\\Delta x_c/2,\\,\\Delta x_c/2]$和$y \\in [-\\Delta y_c/2,\\,\\Delta y_c/2]$。细网格层级是在每个空间方向上进行因子为2的加密，通过在$x=0$和$y=0$处分裂产生四个细子单元：东北（NE）子单元，$x \\in [0,\\,\\Delta x_c/2]$, $y \\in [0,\\,\\Delta y_c/2]$；西北（NW）子单元，$x \\in [-\\Delta x_c/2,\\,0]$, $y \\in [0,\\,\\Delta y_c/2]$；西南（SW）子单元，$x \\in [-\\Delta x_c/2,\\,0]$, $y \\in [-\\Delta y_c/2,\\,0]$；以及东南（SE）子单元，$x \\in [0,\\,\\Delta x_c/2]$, $y \\in [-\\Delta y_c/2,\\,0]$。\n\n仅使用单元平均值的有限体积定义和守恒原理，推导将粗网格单元平均值和双线性系数映射到四个细网格单元平均值的二阶守恒延长模板。这四个细网格单元平均值定义为\n$$\n\\bar{q}_{R} \\equiv \\frac{1}{A_R} \\int_{R} p(x,y)\\, \\mathrm{d}A,\n$$\n对于每个区域$R \\in \\{\\mathrm{NE},\\mathrm{NW},\\mathrm{SW},\\mathrm{SE}\\}$，其面积为$A_R = (\\Delta x_c/2)(\\Delta y_c/2)$，且$\\mathrm{d}A = \\mathrm{d}x\\,\\mathrm{d}y$。您的最终答案必须是$\\bar{q}_{\\mathrm{NE}}$、$\\bar{q}_{\\mathrm{NW}}$、$\\bar{q}_{\\mathrm{SW}}$和$\\bar{q}_{\\mathrm{SE}}$关于$\\bar{q}_c$、$\\Delta x_c$、$\\Delta y_c$、$S_x$、$S_y$和$S_{xy}$的显式解析表达式。请将您的最终答案表示为$(\\bar{q}_{\\mathrm{NE}}, \\bar{q}_{\\mathrm{NW}}, \\bar{q}_{\\mathrm{SW}}, \\bar{q}_{\\mathrm{SE}})$顺序的单行矩阵。请精确表达您的答案；无需四舍五入或单位。",
            "solution": "问题陈述已经过验证，被认为是科学上合理的、自洽的、一致的且适定的。任务是为有限体积法推导二阶守恒延长模板，该模板将粗网格单元平均值及其重构分布映射到四个细网格单元平均值。\n\n所使用的基本原理是守恒标量场$q$的单元平均值定义。对于任何面积为$A_R$的区域$R$，其单元平均值$\\bar{q}_R$定义为标量场在该区域上的积分除以该区域的面积：\n$$\n\\bar{q}_{R} \\equiv \\frac{1}{A_R} \\int_{R} q(x,y)\\, \\mathrm{d}A\n$$\n在此问题中，粗网格单元内的标量场分布由双线性重构多项式$p(x,y)$给出：\n$$\np(x,y) = \\bar{q}_c + S_x\\,x + S_y\\,y + S_{xy}\\,x\\,y\n$$\n粗网格单元以原点为中心，其域为$x \\in [-\\Delta x_c/2, \\Delta x_c/2]$和$y \\in [-\\Delta y_c/2, \\Delta y_c/2]$。细网格是因子为2的加密，产生四个子单元（NE, NW, SW, SE），每个子单元的面积为$A_R = (\\Delta x_c/2)(\\Delta y_c/2) = \\frac{\\Delta x_c \\Delta y_c}{4}$。\n\n我们的目标是计算$p(x,y)$在这四个子单元中每一个上的平均值。我们将一个通用的子单元区域表示为$R$。其平均值为：\n$$\n\\bar{q}_{R} = \\frac{1}{A_R} \\int_{R} (\\bar{q}_c + S_x\\,x + S_y\\,y + S_{xy}\\,x\\,y)\\, \\mathrm{d}x\\,\\mathrm{d}y\n$$\n根据积分的线性性质，我们可以分离各项：\n$$\n\\bar{q}_{R} = \\frac{1}{A_R} \\left( \\bar{q}_c \\int_{R} 1\\, \\mathrm{d}x\\,\\mathrm{d}y + S_x \\int_{R} x\\, \\mathrm{d}x\\,\\mathrm{d}y + S_y \\int_{R} y\\, \\mathrm{d}x\\,\\mathrm{d}y + S_{xy} \\int_{R} xy\\, \\mathrm{d}x\\,\\mathrm{d}y \\right)\n$$\n第一个积分$\\int_{R} 1\\, \\mathrm{d}x\\,\\mathrm{d}y$就是区域的面积$A_R$。这可将表达式简化为：\n$$\n\\bar{q}_{R} = \\bar{q}_c + \\frac{S_x}{A_R} \\int_{R} x\\, \\mathrm{d}x\\,\\mathrm{d}y + \\frac{S_y}{A_R} \\int_{R} y\\, \\mathrm{d}x\\,\\mathrm{d}y + \\frac{S_{xy}}{A_R} \\int_{R} xy\\, \\mathrm{d}x\\,\\mathrm{d}y\n$$\n对于一个面积为$A_R = (x_2 - x_1)(y_2 - y_1)$的通用矩形区域$[x_1, x_2] \\times [y_1, y_2]$，可以计算剩余的积分。这个矩形的质心是$(\\bar{x}_R, \\bar{y}_R) = (\\frac{x_1+x_2}{2}, \\frac{y_1+y_2}{2})$。\n积分为：\n$$\n\\int_{R} x\\, \\mathrm{d}A = \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} x\\, \\mathrm{d}x\\,\\mathrm{d}y = \\left[\\frac{x^2}{2}\\right]_{x_1}^{x_2} \\left[y\\right]_{y_1}^{y_2} = \\frac{x_2^2-x_1^2}{2}(y_2-y_1) = \\frac{(x_2-x_1)(x_2+x_1)}{2}(y_2-y_1) = A_R \\bar{x}_R\n$$\n$$\n\\int_{R} y\\, \\mathrm{d}A = \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} y\\, \\mathrm{d}x\\,\\mathrm{d}y = (x_2-x_1)\\frac{y_2^2-y_1^2}{2} = A_R \\bar{y}_R\n$$\n$$\n\\int_{R} xy\\, \\mathrm{d}A = \\int_{y_1}^{y_2} \\int_{x_1}^{x_2} xy\\, \\mathrm{d}x\\,\\mathrm{d}y = \\left[\\frac{x^2}{2}\\right]_{x_1}^{x_2} \\left[\\frac{y^2}{2}\\right]_{y_1}^{y_2} = \\frac{x_2^2-x_1^2}{2} \\frac{y_2^2-y_1^2}{2} = (A_R \\bar{x}_R) \\bar{y}_R = A_R \\bar{x}_R \\bar{y}_R\n$$\n将这些结果代回$\\bar{q}_R$的表达式，我们得到双线性多项式在任何矩形子区域$R$上的平均值的通用公式：\n$$\n\\bar{q}_R = \\bar{q}_c + S_x \\bar{x}_R + S_y \\bar{y}_R + S_{xy} \\bar{x}_R \\bar{y}_R\n$$\n这个简洁的结果表明，细网格单元平均值是通过在细单元的质心处评估导数项的贡献来确定的。现在，我们通过找到四个子单元各自的质心，将此公式应用于每个子单元。\n\n1.  **东北 (NE) 子单元**：$x \\in [0, \\Delta x_c/2]$, $y \\in [0, \\Delta y_c/2]$。\n    质心为$(\\bar{x}_{\\mathrm{NE}}, \\bar{y}_{\\mathrm{NE}}) = (\\frac{0+\\Delta x_c/2}{2}, \\frac{0+\\Delta y_c/2}{2}) = (\\frac{\\Delta x_c}{4}, \\frac{\\Delta y_c}{4})$。\n    $$\n    \\bar{q}_{\\mathrm{NE}} = \\bar{q}_c + S_x \\left(\\frac{\\Delta x_c}{4}\\right) + S_y \\left(\\frac{\\Delta y_c}{4}\\right) + S_{xy} \\left(\\frac{\\Delta x_c}{4}\\right)\\left(\\frac{\\Delta y_c}{4}\\right) = \\bar{q}_c + \\frac{S_x \\Delta x_c}{4} + \\frac{S_y \\Delta y_c}{4} + \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}\n    $$\n\n2.  **西北 (NW) 子单元**：$x \\in [-\\Delta x_c/2, 0]$, $y \\in [0, \\Delta y_c/2]$。\n    质心为$(\\bar{x}_{\\mathrm{NW}}, \\bar{y}_{\\mathrm{NW}}) = (\\frac{-\\Delta x_c/2+0}{2}, \\frac{0+\\Delta y_c/2}{2}) = (-\\frac{\\Delta x_c}{4}, \\frac{\\Delta y_c}{4})$。\n    $$\n    \\bar{q}_{\\mathrm{NW}} = \\bar{q}_c + S_x \\left(-\\frac{\\Delta x_c}{4}\\right) + S_y \\left(\\frac{\\Delta y_c}{4}\\right) + S_{xy} \\left(-\\frac{\\Delta x_c}{4}\\right)\\left(\\frac{\\Delta y_c}{4}\\right) = \\bar{q}_c - \\frac{S_x \\Delta x_c}{4} + \\frac{S_y \\Delta y_c}{4} - \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}\n    $$\n\n3.  **西南 (SW) 子单元**：$x \\in [-\\Delta x_c/2, 0]$, $y \\in [-\\Delta y_c/2, 0]$。\n    质心为$(\\bar{x}_{\\mathrm{SW}}, \\bar{y}_{\\mathrm{SW}}) = (\\frac{-\\Delta x_c/2+0}{2}, \\frac{-\\Delta y_c/2+0}{2}) = (-\\frac{\\Delta x_c}{4}, -\\frac{\\Delta y_c}{4})$。\n    $$\n    \\bar{q}_{\\mathrm{SW}} = \\bar{q}_c + S_x \\left(-\\frac{\\Delta x_c}{4}\\right) + S_y \\left(-\\frac{\\Delta y_c}{4}\\right) + S_{xy} \\left(-\\frac{\\Delta x_c}{4}\\right)\\left(-\\frac{\\Delta y_c}{4}\\right) = \\bar{q}_c - \\frac{S_x \\Delta x_c}{4} - \\frac{S_y \\Delta y_c}{4} + \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}\n    $$\n\n4.  **东南 (SE) 子单元**：$x \\in [0, \\Delta x_c/2]$, $y \\in [-\\Delta y_c/2, 0]$。\n    质心为$(\\bar{x}_{\\mathrm{SE}}, \\bar{y}_{\\mathrm{SE}}) = (\\frac{0+\\Delta x_c/2}{2}, \\frac{-\\Delta y_c/2+0}{2}) = (\\frac{\\Delta x_c}{4}, -\\frac{\\Delta y_c}{4})$。\n    $$\n    \\bar{q}_{\\mathrm{SE}} = \\bar{q}_c + S_x \\left(\\frac{\\Delta x_c}{4}\\right) + S_y \\left(-\\frac{\\Delta y_c}{4}\\right) + S_{xy} \\left(\\frac{\\Delta x_c}{4}\\right)\\left(-\\frac{\\Delta y_c}{4}\\right) = \\bar{q}_c + \\frac{S_x \\Delta x_c}{4} - \\frac{S_y \\Delta y_c}{4} - \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}\n    $$\n\n为了验证此延长模板的守恒性质，我们检查细网格单元平均值的平均值是否等于粗网格单元平均值。\n$$\n\\frac{1}{4}(\\bar{q}_{\\mathrm{NE}} + \\bar{q}_{\\mathrm{NW}} + \\bar{q}_{\\mathrm{SW}} + \\bar{q}_{\\mathrm{SE}}) = \\frac{1}{4} \\left( 4\\bar{q}_c \\right)\n+ \\frac{1}{4}\\frac{S_x \\Delta x_c}{4}(1 - 1 - 1 + 1)\n+ \\frac{1}{4}\\frac{S_y \\Delta y_c}{4}(1 + 1 - 1 - 1)\n+ \\frac{1}{4}\\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}(1 - 1 + 1 - 1)\n$$\n$$\n= \\bar{q}_c + 0 + 0 + 0 = \\bar{q}_c\n$$\n由于细网格单元值（按面积加权）的总和等于粗网格单元值，因此该过程是守恒的。推导出的表达式构成了所需的延长模板。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\bar{q}_c + \\frac{S_x \\Delta x_c}{4} + \\frac{S_y \\Delta y_c}{4} + \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}  \\bar{q}_c - \\frac{S_x \\Delta x_c}{4} + \\frac{S_y \\Delta y_c}{4} - \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}  \\bar{q}_c - \\frac{S_x \\Delta x_c}{4} - \\frac{S_y \\Delta y_c}{4} + \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}  \\bar{q}_c + \\frac{S_x \\Delta x_c}{4} - \\frac{S_y \\Delta y_c}{4} - \\frac{S_{xy} \\Delta x_c \\Delta y_c}{16}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "对于守恒律方程，AMR 的核心挑战在于，在粗-精网格界面上，粗网格计算的通量与相邻精细网格计算的通量之和通常不匹配。这种不匹配会破坏离散系统的守恒性，导致物理量的非物理解释。本练习提供了一个定量的实践，用于计算这种通量不匹配，并应用必要的修正，这有助于你巩固对守恒型 AMR 核心——通量修正算法的理解。",
            "id": "3785227",
            "problem": "考虑一个使用自适应网格加密（AMR）的近岸海洋模型中，对被动标量示踪物的二维有限体积离散化。其中，一个宽度为 $\\Delta x_{\\mathrm{c}}$ 的粗网格单元在其东侧面与一个加密区域相邻。粗网格单元中的示踪物质量（记为 $M$）在跨单元面的平流输运通量作用下遵循守恒定律：$M$ 的时间变化量等于净向外质量通量在时间上的积分。在加密比 $r=2$ 的AMR中，细网格层在一个粗网格时间步内推进两个子步，并且粗网格的东侧面被两个等长的细网格面所覆盖。假设垂直方向已被积分，所提供的通量率为已沿面长度和深度积分的总质量通量率。\n\n设粗网格时间步长为 $\\Delta t_{\\mathrm{c}} = 60$ 秒，细网格时间步长为 $\\Delta t_{\\mathrm{f}} = \\Delta t_{\\mathrm{c}}/r = 30$ 秒。假设正通量方向为从粗网格单元向外、穿过共享的东侧界面进入加密区域。在单个粗网格时间步内，粗网格层离散化产生的东侧面质量通量率为常数 $F_{\\mathrm{c}} = 1.00 \\times 10^{6}$ 千克/秒。在细网格层，覆盖粗网格东侧面的两个细网格面在两个细网格子步期间具有以下质量通量率：\n- 在子步 $m=1$ 时，细网格通量率分别为 $F_{\\mathrm{f},1}^{(1)} = 5.8 \\times 10^{5}$ 千克/秒 和 $F_{\\mathrm{f},2}^{(1)} = 6.0 \\times 10^{5}$ 千克/秒。\n- 在子步 $m=2$ 时，细网格通量率分别为 $F_{\\mathrm{f},1}^{(2)} = 6.2 \\times 10^{5}$ 千克/秒 和 $F_{\\mathrm{f},2}^{(2)} = 5.9 \\times 10^{5}$ 千克/秒。\n\n假设在此粗网格步长期间，粗网格单元的西侧面没有通量。粗网格单元的初始示踪物质量为 $M^{n} = 2.00 \\times 10^{8}$ 千克。\n\n从有限体积守恒原理以及跨面和时间的通量积分的定义出发，推导在单个粗网格时间步内累积的粗细网格通量不匹配量，并解释如何将其作为修正量应用于粗网格单元，以强制实现跨粗细网格界面的守恒。计算粗网格时间步结束时修正后的粗网格单元示踪物质量。将最终答案四舍五入至四位有效数字，并以千克为单位表示。",
            "solution": "该问题是有效的，因为它描述了计算流体动力学中的一个标准、适定的场景，特别是在自适应网格加密（AMR）中为确保跨粗细网格界面的质量守恒而进行的通量修正步骤。所有必要数据均已提供，所要求的计算基于有限体积法的基本原理。\n\n控制粗有限体积单元中示踪物质量 $M$ 演化的核心原理是守恒定律，即在一个时间间隔内的质量变化等于从单元边界流出的总质量的负值。以离散形式表示，对于单个粗网格时间步 $\\Delta t_{\\mathrm{c}}$，时刻 $n+1$ 的质量 $M^{n+1}$ 与时刻 $n$ 的质量 $M^n$ 的关系如下：\n$$\nM^{n+1} = M^n - \\Delta M_{\\text{flux}}\n$$\n其中 $\\Delta M_{\\text{flux}}$ 是在时间步 $\\Delta t_{\\mathrm{c}}$ 内离开单元的总净质量。问题指明西侧面没有通量，因此我们只需考虑穿过东侧面的通量。\n\n在AMR背景下，对于从 $t^n$ 到 $t^{n+1} = t^n + \\Delta t_{\\mathrm{c}}$ 的时间间隔内，跨越粗细网格界面的总质量输运有两种不同的计算方法。\n\n首先，粗网格根据其自身的通量估计计算出总质量流出量 $\\Delta M_{\\mathrm{c}}$。粗网格层的通量率 $F_{\\mathrm{c}}$ 在粗网格时间步 $\\Delta t_{\\mathrm{c}}$ 内为常数。\n$$\n\\Delta M_{\\mathrm{c}} = F_{\\mathrm{c}} \\cdot \\Delta t_{\\mathrm{c}}\n$$\n使用所提供的值：\n$$\n\\Delta M_{\\mathrm{c}} = (1.00 \\times 10^{6} \\, \\text{kg/s}) \\cdot (60 \\, \\text{s}) = 6.00 \\times 10^{7} \\, \\text{kg}\n$$\n\n其次，细网格通过以更高的空间和时间保真度解析界面，提供了更精确的质量流出量计算，即 $\\Delta M_{\\mathrm{f}}$。单个粗网格面的通量由两个细网格面的通量来解析，单个粗网格时间步由 $r=2$ 个时长为 $\\Delta t_{\\mathrm{f}} = \\Delta t_{\\mathrm{c}} / r$ 的细网格子步来解析。在细网格层计算出的总质量流出量是所有细网格面和所有细网格子步上通量（积分量）之和。\n\n对于第一个细网格子步（$m=1$，时间间隔 $\\Delta t_{\\mathrm{f}}$），总质量流出量为：\n$$\n\\Delta M_{\\mathrm{f}}^{(1)} = \\left( F_{\\mathrm{f},1}^{(1)} + F_{\\mathrm{f},2}^{(1)} \\right) \\cdot \\Delta t_{\\mathrm{f}}\n$$\n对于第二个细网格子步（$m=2$，时间间隔 $\\Delta t_{\\mathrm{f}}$），总质量流出量为：\n$$\n\\Delta M_{\\mathrm{f}}^{(2)} = \\left( F_{\\mathrm{f},1}^{(2)} + F_{\\mathrm{f},2}^{(2)} \\right) \\cdot \\Delta t_{\\mathrm{f}}\n$$\n根据细网格的计算，在整个粗网格时间步 $\\Delta t_{\\mathrm{c}}$ 内，跨界面的总质量流出量是这两部分之和：\n$$\n\\Delta M_{\\mathrm{f}} = \\Delta M_{\\mathrm{f}}^{(1)} + \\Delta M_{\\mathrm{f}}^{(2)} = \\left[ \\left( F_{\\mathrm{f},1}^{(1)} + F_{\\mathrm{f},2}^{(1)} \\right) + \\left( F_{\\mathrm{f},1}^{(2)} + F_{\\mathrm{f},2}^{(2)} \\right) \\right] \\cdot \\Delta t_{\\mathrm{f}}\n$$\n代入给定值：\n$F_{\\mathrm{f},1}^{(1)} = 5.8 \\times 10^{5}$ kg/s, $F_{\\mathrm{f},2}^{(1)} = 6.0 \\times 10^{5}$ kg/s\n$F_{\\mathrm{f},1}^{(2)} = 6.2 \\times 10^{5}$ kg/s, $F_{\\mathrm{f},2}^{(2)} = 5.9 \\times 10^{5}$ kg/s\n$\\Delta t_{\\mathrm{f}} = 30$ s\n\n$$\n\\Delta M_{\\mathrm{f}} = \\left[ (5.8 \\times 10^{5} + 6.0 \\times 10^{5}) + (6.2 \\times 10^{5} + 5.9 \\times 10^{5}) \\right] \\frac{\\text{kg}}{\\text{s}} \\cdot (30 \\, \\text{s})\n$$\n$$\n\\Delta M_{\\mathrm{f}} = \\left[ (1.18 \\times 10^{6}) + (1.21 \\times 10^{6}) \\right] \\frac{\\text{kg}}{\\text{s}} \\cdot (30 \\, \\text{s})\n$$\n$$\n\\Delta M_{\\mathrm{f}} = (2.39 \\times 10^{6} \\, \\text{kg/s}) \\cdot (30 \\, \\text{s}) = 7.17 \\times 10^{7} \\, \\text{kg}\n$$\n\n粗细网格通量不匹配量，我们记为 $\\delta M_{\\text{flux}}$，是细网格计算的总质量传输量与粗网格计算的总质量传输量之差。\n$$\n\\delta M_{\\text{flux}} = \\Delta M_{\\mathrm{f}} - \\Delta M_{\\mathrm{c}}\n$$\n$$\n\\delta M_{\\text{flux}} = 7.17 \\times 10^{7} \\, \\text{kg} - 6.00 \\times 10^{7} \\, \\text{kg} = 1.17 \\times 10^{7} \\, \\text{kg}\n$$\n这个不匹配量代表了粗网格通量计算中的误差。正值意味着更精确的细网格计算出的从粗网格单元流出的质量大于粗网格自身的计算结果。\n\n为强制实现全局守恒，必须修正此不匹配量。粗网格单元的质量在粗网格时间步内使用了精度较低的通量积分 $\\Delta M_{\\mathrm{c}}$ 进行更新，因此必须进行调整。该修正是通过从粗网格单元的质量中减去通量不匹配量来应用的。粗网格单元质量的变化量为 $-\\delta M_{\\text{flux}}$。\n其逻辑如下：粗网格单元质量的临时更新值为 $M^{n+1, \\text{uncorrected}} = M^{n} - \\Delta M_{\\mathrm{c}}$。然后将修正量应用于此值：\n$$\nM^{n+1, \\text{corrected}} = M^{n+1, \\text{uncorrected}} - \\delta M_{\\text{flux}} = (M^{n} - \\Delta M_{\\mathrm{c}}) - (\\Delta M_{\\mathrm{f}} - \\Delta M_{\\mathrm{c}})\n$$\n这可以简化为：\n$$\nM^{n+1, \\text{corrected}} = M^{n} - \\Delta M_{\\mathrm{f}}\n$$\n这个结果表明，通量修正程序确保了粗网格单元的质量收支与细网格上计算的更精确的通量积分相一致，从而保持了守恒性。\n\n现在我们可以使用初始质量 $M^n$ 和来自细网格的总通量积分 $\\Delta M_{\\mathrm{f}}$ 来计算粗网格单元修正后的最终质量。\n给定 $M^n = 2.00 \\times 10^{8}$ kg：\n$$\nM^{n+1, \\text{corrected}} = 2.00 \\times 10^{8} \\, \\text{kg} - 7.17 \\times 10^{7} \\, \\text{kg}\n$$\n$$\nM^{n+1, \\text{corrected}} = 2.00 \\times 10^{8} \\, \\text{kg} - 0.717 \\times 10^{8} \\, \\text{kg}\n$$\n$$\nM^{n+1, \\text{corrected}} = (2.00 - 0.717) \\times 10^{8} \\, \\text{kg} = 1.283 \\times 10^{8} \\, \\text{kg}\n$$\n该值已按要求表示为四位有效数字。",
            "answer": "$$\\boxed{1.283 \\times 10^{8}}$$"
        },
        {
            "introduction": "何时何地进行网格加密或粗化的决策是基于一个误差指标。然而，当一个特征（如移动的激波）穿过单元边界时，指标值可能会在阈值附近波动，导致所谓的“抖动”（thrashing）——即网格结构频繁且低效地来回切换。本练习将引导你从核心数值计算转向实用的算法设计，通过实现并比较一种简单的阈值方案和一种更鲁棒的基于滞后（hysteresis）的方案，你将学会如何为 AMR 的控制逻辑构建稳定性。",
            "id": "3094967",
            "problem": "您的任务是设计并实现一个基于迟滞的自适应网格加密决策方案，以避免在一维模拟中移动激波穿过单元边界时，出现反复的加密/解密切换。该模拟类似于 Sod 激波管问题。计算目标纯粹是算法性的：不要求解控制偏微分方程。相反，您需要基于一个从具有移动不连续性特征的连续代理密度分布推导出的误差指标，来推导、实现并比较决策逻辑。\n\n基本和核心定义：自适应网格加密（Adaptive Mesh Refinement, AMR）在误差指标高的区域加密计算网格，在误差指标低的区域解密网格。Sod 激波管中的移动激波会在密度场中产生巨大的梯度。设计算域为区间 $[0,1]$。设有 $N_{\\text{cells}}$ 个均匀的粗网格单元，单元宽度为 $\\Delta x = \\frac{1}{N_{\\text{cells}}}$，单元中心为 $x_i = \\left(i + \\frac{1}{2}\\right)\\Delta x$，其中整数 $i \\in \\{0,1,\\dots,N_{\\text{cells}}-1\\}$。定义一个带有移动跳跃的光滑代理密度场：\n$$\n\\rho(x,t) = \\rho_R + \\left(\\rho_L - \\rho_R\\right) S(x,t), \\quad S(x,t) = \\frac{1}{2}\\left(1 - \\tanh\\left(\\frac{x - x_s(t)}{w}\\right)\\right),\n$$\n其中 $x_s(t) = x_0 + v t$ 是激波位置，$w > 0$ 是平滑宽度，$\\rho_L$ 是左侧密度状态，$\\rho_R$ 是右侧密度状态。这个代理模型捕捉了类似于 Sod 激波管情况下的移动陡峭梯度，但保持连续性以允许稳定的有限差分计算。单元误差指标由 $\\rho$ 的离散空间梯度定义：\n$$\nI_i(t) = \\frac{\\left|\\rho(x_{i+1}, t) - \\rho(x_i, t)\\right|}{\\Delta x},\n$$\n其中 $I_{N_{\\text{cells}}-1}(t)$ 被设定为等于 $I_{N_{\\text{cells}}-2}(t)$ 以避免边界索引问题。为了模拟传感器不确定性和模型离散化噪声，可以向 $I_i(t)$ 添加一个标准差为 $\\sigma$ 的零均值加性高斯噪声项；添加噪声后，负值的指标必须被截断为 $0$。\n\n需要实现和比较的决策方案：\n- 朴素方案（单阈值）：给定一个阈值 $T$，定义加密标志 $R_i(t)$：如果 $I_i(t) \\ge T$，则 $R_i(t) = \\text{true}$；否则 $R_i(t) = \\text{false}$。\n- 迟滞方案（双阈值加保持时间）：给定一个加密阈值 $T_r$、一个解密阈值 $T_d$（其中 $T_d  T_r$）以及一个以整数时间步为单位的保持时间 $H$，按如下方式实现 $R_i(t)$。如果 $R_i(t-1) = \\text{false}$，则仅在 $I_i(t) > T_r$ 时进行加密；如果在时间 $t$ 发生加密，则设置一个保持计数器 $h_i(t) = H$。如果 $R_i(t-1) = \\text{true}$，则在 $h_i(t-1) > 0$ 的情况下继续保持加密状态，方法是设置 $R_i(t) = \\text{true}$ 并将 $h_i(t) = h_i(t-1) - 1$，无论 $I_i(t)$ 的值如何。当保持计数器达到 $0$ 后，仅在 $I_i(t)  T_d$ 时进行解密；否则保持 $R_i(t) = \\text{true}$。如果 $I_i(t)$ 不满足任一严格不等式（即等于阈值），则保持当前状态。这创建了一个死区和时间上的持续性，以避免抖动（thrashing）。\n\n性能指标和抖动定义：将模拟过程中状态切换的总次数定义为\n$$\nN_{\\text{toggles}} = \\sum_{t=1}^{N_{\\text{steps}}-1} \\sum_{i=0}^{N_{\\text{cells}}-1} \\mathbf{1}\\left[R_i(t) \\ne R_i(t-1)\\right],\n$$\n其中 $N_{\\text{steps}}$ 是离散时间步的总数，$\\mathbf{1}[\\cdot]$ 是指示函数，当条件为真时等于 $1$，为假时等于 $0$。计算朴素方案的 $N_{\\text{toggles}}^{\\text{naive}}$ 和迟滞方案的 $N_{\\text{toggles}}^{\\text{hyst}}$，然后报告每个测试用例的差值 $D = N_{\\text{toggles}}^{\\text{naive}} - N_{\\text{toggles}}^{\\text{hyst}}$。\n\n从基本原理出发：该方案必须源于以下定义：由守恒律驱动的加密（大梯度意味着感兴趣的区域）、作为经过充分检验的数值近似的离散梯度定义，以及作为具有时间持续性的双阈值死区以抑制由小波动引起的快速切换的迟滞概念。\n\n算法要求：\n1. 使用每个测试用例中指定的参数计算代理密度。\n2. 在每个时间点 $t_k = k\\,\\Delta t$（其中整数 $k \\in \\{0,1,\\dots,N_{\\text{steps}}-1\\}$），计算 $\\rho(x_i, t_k)$ 和指标 $I_i(t_k)$，然后独立地对两种方案应用决策逻辑。\n3. 对整个模拟过程中的每种方案计算状态切换次数，并返回每个测试用例的差值 $D$。\n\n角度单位不适用，最终答案中也不需要物理单位；通过构造，所有量都是无量纲的。\n\n测试套件和参数：\n提供三个测试用例以探究不同方面：\n- 测试用例 $1$（一般移动激波与轻度噪声）：\n  - $N_{\\text{cells}} = 64$, $N_{\\text{steps}} = 120$, $\\Delta t = 0.005$, $x_0 = 0.20$, $v = 0.25$, $w = 0.020$, $\\rho_L = 1.00$, $\\rho_R = 0.125$, $\\sigma = 0.5$, 随机种子 $s = 42$,\n  - 朴素阈值 $T = 14$,\n  - 迟滞阈值与保持时间 $T_r = 16$, $T_d = 12$, $H = 3$。\n- 测试用例 $2$（边界条件与接近相等情况且无噪声）：\n  - $N_{\\text{cells}} = 64$, $N_{\\text{steps}} = 120$, $\\Delta t = 0.005$, $x_0 = 0.25$, $v = 0.30$, $w = 0.040$, $\\rho_L = 1.00$, $\\rho_R = 0.125$, $\\sigma = 0.0$, 随机种子 $s = 7$,\n  - 朴素阈值 $T = 11$,\n  - 迟滞阈值与保持时间 $T_r = 12$, $T_d = 10$, $H = 2$。\n- 测试用例 $3$（强噪声以引发振荡的边缘情况）：\n  - $N_{\\text{cells}} = 64$, $N_{\\text{steps}} = 120$, $\\Delta t = 0.005$, $x_0 = 0.20$, $v = 0.25$, $w = 0.020$, $\\rho_L = 1.00$, $\\rho_R = 0.125$, $\\sigma = 3.0$, 随机种子 $s = 123$,\n  - 朴素阈值 $T = 14$,\n  - 迟滞阈值与保持时间 $T_r = 16$, $T_d = 12$, $H = 4$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表按顺序包含三个测试用例的三个差值 $D$：\n$$\n\\text{print}\\;\\;[D_1, D_2, D_3].\n$$",
            "solution": "该问题要求在一维移动激波剖面的背景下，设计、实现并比较两种用于自适应网格加密（AMR）的决策方案。其目标是量化基于迟滞的方案相比于朴素的单阈值方案，在加密状态“切换”或“抖动”方面所实现的减少程度。\n\n### 基于原理的设计与模型构建\n\n这个问题的基础在于守恒律的数值方法和控制理论的原理。在流体动力学模拟中，像激波这样的特征在物理量（如密度、压力）上表现出巨大的梯度。为了在不增加整个计算域过多计算成本的情况下精确解析这些特征，AMR 技术会进行局部网格加密。加密或解密的决策基于误差指标，该指标通常是局部解梯度的一种度量。\n\n1.  **代理物理模型**：我们使用连续的代理密度剖面 $\\rho(x,t)$ 来模拟移动的类激波特征。这避免了求解双曲型偏微分方程的复杂性，同时保留了陡峭、移动梯度的基本特征。函数定义如下：\n    $$\n    \\rho(x,t) = \\rho_R + \\left(\\rho_L - \\rho_R\\right) S(x,t)\n    $$\n    其中 $\\rho_L$ 和 $\\rho_R$ 分别是激波左右两侧的密度。过渡过程由一个平滑的阶跃函数控制：\n    $$\n    S(x,t) = \\frac{1}{2}\\left(1 - \\tanh\\left(\\frac{x - x_s(t)}{w}\\right)\\right)\n    $$\n    此处，$x_s(t) = x_0 + v t$ 是激波中心随时间变化的位置，以速度 $v$ 移动，$w$ 是一个控制梯度宽度或陡峭度的参数。双曲正切函数 $\\tanh$ 提供了一个平滑但急剧的过渡，模拟了在数值网格上解析的激波剖面。\n\n2.  **误差指标**：任何 AMR 策略的核心都是误差指标。数值分析的一个基本原理是，局部截断误差与解的高阶导数有关。一个简单而有效的误差代理是解的一阶导数的幅值，或其离散近似，即梯度。我们基于密度梯度的有限差分近似，为时间 $t$ 的单元 $i$ 定义单元误差指标 $I_i(t)$：\n    $$\n    I_i(t) = \\frac{\\left|\\rho(x_{i+1}, t) - \\rho(x_i, t)\\right|}{\\Delta x}\n    $$\n    其中 $x_i$ 是单元 $i$ 的中心，$\\Delta x$ 是均匀的单元宽度。该指标在密度变化剧烈的区域（即激波附近）会很大，而在解平滑的区域会很小。为了模拟真实模拟中固有的测量噪声和离散化效应，一个均值为零、标准差为 $\\sigma$ 的高斯噪声被加到 $I_i(t)$ 上。\n\n3.  **AMR 决策方案**：\n    -   **朴素方案**：最简单的方法是，如果一个单元的误差指标超过一个预定的单一阈值 $T$，就对其进行加密。加密标志 $R_i(t)$ 由以下方式确定：\n        $$\n        R_i(t) = \\begin{cases} \\text{true}  \\text{if } I_i(t) \\geq T \\\\ \\text{false}  \\text{if } I_i(t)  T \\end{cases}\n        $$\n        尽管简单，但如果带有噪声的指标 $I_i(t)$ 在阈值 $T$ 附近波动，该方案极易出现“抖动”——即快速、重复的加密和解密。\n\n    -   **迟滞方案**：为了对抗抖动，我们采用迟滞方法，这是控制工程中的一个概念，它为系统引入了记忆。这通过两种机制实现：空间死区和时间保持。\n        -   **空间迟滞（死区）**：我们使用两个阈值而不是一个：一个加密阈值 $T_r$ 和一个解密阈值 $T_d$，且 $T_d  T_r$。只有当一个单元的指标*严格超过* $T_r$ 时，它才被标记为需要加密。只有当其指标*降至* $T_d$ 以下时，它才被标记为需要解密。对于在“死区” $[T_d, T_r]$ 内的任何指标值 $I_i(t)$，单元的加密状态不会改变。这可以防止因指标在该带内的微小波动而引起的状态切换。\n        -   **时间迟滞（保持时间）**：引入一个保持时间 $H$（整数个时间步）。一旦一个单元被加密，无论指标值如何，它都被强制保持在加密状态至少 $H$ 个时间步。这加强了时间稳定性，防止系统因指标的瞬时下降而立即撤销加密决策。\n\n4.  **算法实现与评估**：\n    模拟通过离散的时间步 $t_k = k\\,\\Delta t$ 进行。在每一步，算法执行以下操作：\n    -   计算所有单元中心 $x_i$ 处的激波位置 $x_s(t_k)$ 和密度值 $\\rho(x_i, t_k)$。\n    -   计算所有单元的误差指标 $I_i(t_k)$，添加指定的噪声，并将负值截断为零。\n    -   独立地应用朴素方案和迟滞方案的逻辑，以确定每个单元的加密状态 $R_i(t_k)$。对于迟滞方案，这涉及基于前一状态、当前指标值和定义的阈值（$T_r, T_d, H$）来更新状态和保持计数器。\n    -   每种方案的性能通过整个模拟过程中的状态切换总数 $N_{\\text{toggles}}$ 来衡量。如果在时间 $t_k$ 单元 $i$ 的状态满足 $R_i(t_k) \\ne R_i(t_{k-1})$，则计为一次切换。最终的度量标准 $D = N_{\\text{toggles}}^{\\text{naive}} - N_{\\text{toggles}}^{\\text{hyst}}$ 直接量化了迟滞方案所带来的改进。正值的 $D$ 表示迟滞成功减少了状态改变的次数。\n\n为提高效率，实现将使用 NumPy 进行矢量化，在每个时间步同时对所有单元执行计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: General moving shock with mild noise\n        {\n            \"N_cells\": 64, \"N_steps\": 120, \"dt\": 0.005, \"x0\": 0.20, \"v\": 0.25,\n            \"w\": 0.020, \"rho_L\": 1.00, \"rho_R\": 0.125, \"sigma\": 0.5,\n            \"seed\": 42, \"T\": 14, \"Tr\": 16, \"Td\": 12, \"H\": 3\n        },\n        # Case 2: Boundary condition with near-equality and no noise\n        {\n            \"N_cells\": 64, \"N_steps\": 120, \"dt\": 0.005, \"x0\": 0.25, \"v\": 0.30,\n            \"w\": 0.040, \"rho_L\": 1.00, \"rho_R\": 0.125, \"sigma\": 0.0,\n            \"seed\": 7, \"T\": 11, \"Tr\": 12, \"Td\": 10, \"H\": 2\n        },\n        # Case 3: Edge case with strong noise to induce oscillations\n        {\n            \"N_cells\": 64, \"N_steps\": 120, \"dt\": 0.005, \"x0\": 0.20, \"v\": 0.25,\n            \"w\": 0.020, \"rho_L\": 1.00, \"rho_R\": 0.125, \"sigma\": 3.0,\n            \"seed\": 123, \"T\": 14, \"Tr\": 16, \"Td\": 12, \"H\": 4\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        diff = run_simulation_case(case)\n        results.append(diff)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_simulation_case(params):\n    \"\"\"\n    Runs the simulation for a single test case and returns the toggle difference D.\n    \"\"\"\n    # Unpack parameters\n    N_cells = params[\"N_cells\"]\n    N_steps = params[\"N_steps\"]\n    dt = params[\"dt\"]\n    x0 = params[\"x0\"]\n    v = params[\"v\"]\n    w = params[\"w\"]\n    rho_L = params[\"rho_L\"]\n    rho_R = params[\"rho_R\"]\n    sigma = params[\"sigma\"]\n    seed = params[\"seed\"]\n    T = params[\"T\"]\n    Tr = params[\"Tr\"]\n    Td = params[\"Td\"]\n    H = params[\"H\"]\n\n    # Setup grid and time\n    dx = 1.0 / N_cells\n    x_centers = (np.arange(N_cells) + 0.5) * dx\n    times = np.arange(N_steps) * dt\n\n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # State history arrays\n    R_naive_hist = np.zeros((N_steps, N_cells), dtype=bool)\n    R_hyst_hist = np.zeros((N_steps, N_cells), dtype=bool)\n    h_hyst_hist = np.zeros((N_steps, N_cells), dtype=int)\n\n    # Time-stepping loop\n    for k, t in enumerate(times):\n        # 1. Compute surrogate density and error indicator\n        x_s = x0 + v * t\n        arg = (x_centers - x_s) / w\n        S_xt = 0.5 * (1 - np.tanh(arg))\n        rho_xt = rho_R + (rho_L - rho_R) * S_xt\n        \n        # Calculate indicators I_i for i = 0 to N_cells-2\n        indicators_part = np.abs(rho_xt[1:] - rho_xt[:-1]) / dx\n        \n        # Assemble N_cells indicators, setting I_{N-1} = I_{N-2}\n        indicators = np.append(indicators_part, indicators_part[-1])\n        \n        # Add noise and clip at 0\n        noise = rng.normal(loc=0.0, scale=sigma, size=N_cells)\n        indicators_noisy = np.maximum(0, indicators + noise)\n\n        # 2. Update Naive Scheme State\n        R_naive_hist[k, :] = (indicators_noisy >= T)\n\n        # 3. Update Hysteresis Scheme State\n        if k == 0:\n            R_hyst_prev = np.zeros(N_cells, dtype=bool)\n            h_hyst_prev = np.zeros(N_cells, dtype=int)\n        else:\n            R_hyst_prev = R_hyst_hist[k - 1, :]\n            h_hyst_prev = h_hyst_hist[k - 1, :]\n\n        R_hyst_curr = np.copy(R_hyst_prev)\n        h_hyst_curr = np.copy(h_hyst_prev)\n        \n        # Logic for cells that were previously NOT refined\n        was_false_mask = ~R_hyst_prev\n        to_refine_mask = was_false_mask  (indicators_noisy > Tr)\n        R_hyst_curr[to_refine_mask] = True\n        h_hyst_curr[to_refine_mask] = H\n\n        # Logic for cells that were previously refined\n        was_true_mask = R_hyst_prev\n        \n        # Decrement hold counter if it's positive\n        holding_mask = was_true_mask  (h_hyst_prev > 0)\n        h_hyst_curr[holding_mask] = h_hyst_prev[holding_mask] - 1\n        \n        # Check for derefinement if hold counter is zero\n        hold_expired_mask = was_true_mask  (h_hyst_prev == 0)\n        to_derefine_mask = hold_expired_mask  (indicators_noisy  Td)\n        R_hyst_curr[to_derefine_mask] = False\n        \n        R_hyst_hist[k, :] = R_hyst_curr\n        h_hyst_hist[k, :] = h_hyst_curr\n\n    # 4. Calculate Toggles\n    # Sum over all cells and time steps from k=1 to N_steps-1\n    toggles_naive = np.sum(R_naive_hist[1:, :] != R_naive_hist[:-1, :])\n    toggles_hyst = np.sum(R_hyst_hist[1:, :] != R_hyst_hist[:-1, :])\n\n    # 5. Return difference\n    return toggles_naive - toggles_hyst\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}