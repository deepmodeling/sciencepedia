{
    "hands_on_practices": [
        {
            "introduction": "Before a high-quality mesh can be generated, the domain boundaries themselves must be geometrically and topologically valid. This first practice focuses on the crucial pre-processing step of verifying coastline and island polygons, using the concept of signed area to enforce correct orientation—a fundamental requirement for most meshing software . By implementing these checks based on the shoelace formula and segment intersection tests, you will build an essential tool for ensuring your input data is robust and error-free.",
            "id": "3817799",
            "problem": "In computational oceanography, unstructured grid generation for coastal domains requires that polygonal boundaries representing coastlines (outer boundaries) and internal obstacles such as islands or lakes (holes) adhere to a consistent orientation convention. Under the standard Cartesian coordinate convention used by Geographic Information System (GIS) toolchains for meshing, an outer boundary must be counterclockwise and a hole must be clockwise. This convention makes use of the sign of the polygon's signed area, where the signed area is positive when traversed counterclockwise and negative when traversed clockwise. The objective is to precisely compute signed areas from first principles and use them to verify orientation, while also checking for geometric validity (non-self-intersection) to ensure that these boundaries can be safely used by triangulation routines.\n\nStarting from the fundamental base of planar area as a line integral and the definition of a simple polygon as a closed piecewise-linear curve with non-intersecting edges, derive and implement a program that:\n\n- Computes the signed area of a polygon defined by ordered vertices $\\{(x_i,y_i)\\}_{i=0}^{n-1}$, where all coordinates are in meters, based on a discrete evaluation of a line integral over the polygon boundary. The sign of the area must encode the traversal orientation.\n- Determines orientation using the sign of the computed area, enforcing that an outer boundary has positive signed area (counterclockwise) and each hole has negative signed area (clockwise).\n- Verifies that each polygon is simple (no self-intersections) by testing all non-adjacent edge pairs for intersection.\n- Applies an area magnitude threshold $\\varepsilon$ to reject degenerate polygons with $|A| \\le \\varepsilon$ where $A$ is the signed area. Use $\\varepsilon = 10^{-6}$ square meters.\n- Expresses areas in square meters, rounded to three decimal places.\n\nYour program must evaluate the following test suite, where each test case contains one outer boundary polygon and zero or more hole polygons. All coordinates are in meters, and vertices are provided in the order they are traversed.\n\nTest Case $1$ (happy path: valid simple polygons and correct orientations):\n- Outer boundary (counterclockwise): $[(0,0),(1000,0),(1000,500),(0,500)]$\n- Holes (clockwise): one hole $[(200,100),(250,200),(300,100)]$\n\nTest Case $2$ (orientation errors: valid simple polygons but wrong orientations):\n- Outer boundary (clockwise): $[(0,500),(1000,500),(1000,0),(0,0)]$\n- Holes (counterclockwise): one hole $[(300,100),(250,200),(200,100)]$\n\nTest Case $3$ (degenerate outer boundary: collinear vertices yield zero area):\n- Outer boundary: $[(0,0),(500,0),(1000,0),(0,0)]$\n- Holes: none\n\nTest Case $4$ (self-intersecting outer boundary: bow-tie shape):\n- Outer boundary: $[(0,0),(1000,0),(200,500),(800,500)]$\n- Holes: none\n\nFor each test case, the program must produce a result consisting of:\n- The outer boundary signed area in square meters, rounded to three decimal places.\n- A list of signed areas for the holes in square meters, each rounded to three decimal places (empty list if no holes).\n- A boolean indicating whether the entire case is valid for meshing, which requires: the outer boundary to be simple with positive signed area greater than $\\varepsilon$, and every hole to be simple with negative signed area less than $-\\varepsilon$.\n\nFinal Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and must itself be a list of the form $[A_{\\text{outer}}, [A_{\\text{holes}}], \\text{valid}]$, where $A_{\\text{outer}}$ is a float, $[A_{\\text{holes}}]$ is a list of floats, and $\\text{valid}$ is a boolean. For example, the output must look like $[[\\dots],[\\dots],[\\dots],[\\dots]]$ with four elements, one per test case.",
            "solution": "The problem as stated is valid. It is scientifically grounded in the principles of vector calculus and computational geometry, well-posed with a complete and consistent set of definitions and constraints, and entirely objective. The required tasks—calculating polygon signed area and detecting self-intersections—are standard, formalizable problems within the domain of computational grid generation for ocean models. All data and criteria for validation are explicitly provided.\n\nThe solution will be developed in three principal stages: first, the derivation of the formula for the signed area of a polygon from the principles of line integrals; second, the formulation of an algorithm to detect self-intersections in a polygon; and third, the synthesis of these components into a comprehensive validation procedure for each test case.\n\n### 1. Computation of Signed Area\n\nThe signed area $A$ of a simple, closed planar region $D$ bounded by a curve $C$ can be computed using Green's Theorem, which relates a line integral around $C$ to a double integral over $D$:\n$$\n\\oint_C (L \\, dx + M \\, dy) = \\iint_D \\left(\\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y}\\right) \\, dA\n$$\nTo compute the area $A = \\iint_D dA$, we must select functions $L(x, y)$ and $M(x, y)$ such that $\\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y} = 1$. A standard choice that symmetrizes the integrand is $L = -y/2$ and $M = x/2$. Substituting these into Green's theorem yields the line integral for area:\n$$\nA = \\frac{1}{2} \\oint_C (x \\, dy - y \\, dx)\n$$\nThe problem defines a polygon by an ordered sequence of $n$ vertices $\\{(x_i, y_i)\\}_{i=0}^{n-1}$. The closed boundary $C$ is the union of line segments connecting adjacent vertices, i.e., from $(x_i, y_i)$ to $(x_{i+1}, y_{i+1})$ for $i = 0, \\dots, n-1$, where the indices are taken modulo $n$ such that $(x_n, y_n) = (x_0, y_0)$. The line integral is thus a sum of integrals over these $n$ segments:\n$$\nA = \\frac{1}{2} \\sum_{i=0}^{n-1} \\int_{(x_i, y_i)}^{(x_{i+1}, y_{i+1})} (x \\, dy - y \\, dx)\n$$\nFor a single segment from $(x_i, y_i)$ to $(x_{i+1}, y_{i+1})$, we can parameterize the path using a parameter $t \\in [0, 1]$:\n$$\n\\begin{align*}\nx(t) &= x_i + t(x_{i+1} - x_i) &\\implies dx = (x_{i+1} - x_i) \\, dt \\\\\ny(t) &= y_i + t(y_{i+1} - y_i) &\\implies dy = (y_{i+1} - y_i) \\, dt\n\\end{align*}\n$$\nSubstituting this into the integral for one segment and integrating from $t=0$ to $t=1$:\n$$\n\\int_0^1 \\left[ (x_i + t\\Delta x_i)( \\Delta y_i ) - (y_i + t\\Delta y_i)( \\Delta x_i ) \\right] \\, dt\n$$\nwhere $\\Delta x_i = x_{i+1} - x_i$ and $\\Delta y_i = y_{i+1} - y_i$. The integrand simplifies to:\n$$\n(x_i \\Delta y_i + t\\Delta x_i \\Delta y_i) - (y_i \\Delta x_i + t\\Delta y_i \\Delta x_i) = x_i \\Delta y_i - y_i \\Delta x_i = x_i(y_{i+1}-y_i) - y_i(x_{i+1}-x_i) = x_i y_{i+1} - y_i x_{i+1}\n$$\nThis expression is constant with respect to $t$. The integral is simply the constant value multiplied by the interval length, which is $1$.\n$$\n\\int_{(x_i, y_i)}^{(x_{i+1}, y_{i+1})} (x \\, dy - y \\, dx) = x_i y_{i+1} - y_i x_{i+1}\n$$\nSumming over all segments gives the final discrete formula, known as the shoelace formula or surveyor's formula:\n$$\nA = \\frac{1}{2} \\sum_{i=0}^{n-1} (x_i y_{i+1} - x_{i+1} y_i)\n$$\nThe sign of $A$ depends on the order of the vertices. By the right-hand rule convention associated with Green's Theorem, a counterclockwise (CCW) traversal yields a positive area, while a clockwise (CW) traversal yields a negative area.\n\n### 2. Detection of Self-Intersection (Simple Polygon Test)\n\nA polygon is simple if its edges do not intersect, except for adjacent edges which intersect only at their shared vertex. To verify that a polygon is simple, we must test every pair of non-adjacent edges for intersection.\n\nLet an edge be defined by two vertices. For a polygon with $n$ vertices, we have $n$ edges $e_0, e_1, \\dots, e_{n-1}$, where $e_i$ connects vertex $v_i$ to $v_{i+1}$ (indices modulo $n$). We must check each pair $(e_i, e_j)$ where $i < j$ and $e_i$ and $e_j$ are not adjacent. Two edges $e_i$ and $e_j$ are adjacent if they share a vertex, which occurs if $j = i+1$ or if $i=0$ and $j=n-1$.\n\nThe geometric test for the intersection of two line segments, say $P_1P_2$ and $P_3P_4$, is based on a series of orientation tests. The orientation of an ordered triplet of points $(P_a, P_b, P_c)$ is determined by the sign of the cross-product of the vectors $\\vec{P_aP_b}$ and $\\vec{P_bP_c}$:\n$$\n\\text{orientation}(P_a, P_b, P_c) = \\text{sign}((y_b - y_a)(x_c - x_b) - (x_b - x_a)(y_c - y_b))\n$$\nA positive sign indicates a CCW turn (left), a negative sign a CW turn (right), and a value of $0$ indicates the points are collinear.\n\nTwo non-collinear segments $P_1P_2$ and $P_3P_4$ intersect if and only if the orientations $(P_1, P_2, P_3)$ and $(P_1, P_2, P_4)$ are different, AND the orientations $(P_3, P_4, P_1)$ and $(P_3, P_4, P_2)$ are different.\n\nSpecial handling is required for collinear cases. If the orientation test reveals that three points are collinear (e.g., $(P_1, P_2, P_3)$ are collinear), we must then check if the point $P_3$ lies on the line segment $P_1P_2$. This is true if its coordinates fall within the bounding box of the segment:\n$$\nx_3 \\in [\\min(x_1, x_2), \\max(x_1, x_2)] \\quad \\text{and} \\quad y_3 \\in [\\min(y_1, y_2), \\max(y_1, y_2)]\n$$\nIf any pair of non-adjacent edges passes this intersection test, the polygon is not simple.\n\n### 3. Comprehensive Validation Logic\n\nFor each test case, we apply the derived methods to determine overall validity for meshing. The area magnitude threshold is $\\varepsilon = 10^{-6} \\text{m}^2$.\n\n1.  **Outer Boundary Polygon:**\n    a. Calculate its signed area, $A_{\\text{outer}}$, using the shoelace formula.\n    b. Check if the polygon is simple by testing all non-adjacent edge pairs for intersection.\n    c. The outer boundary is valid if and only if it is simple AND its area $A_{\\text{outer}} > \\varepsilon$.\n\n2.  **Hole Polygons (for each hole):**\n    a. Calculate its signed area, $A_{\\text{hole}}$, using the shoelace formula.\n    b. Check if the polygon is simple.\n    c. Each hole is valid if and only if it is simple AND its area $A_{\\text{hole}} < -\\varepsilon$.\n\n3.  **Overall Case Validity:**\n    A test case is valid as a whole if its outer boundary is valid AND all of its hole polygons are valid. If any single component fails its check, the entire case is deemed invalid for meshing.\n\nThe final output for each test case will be a list containing the rounded signed area of the outer boundary, a list of the rounded signed areas of all holes, and a Boolean flag indicating the overall validity of the case.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates and solves the computational geometry problem for unstructured grid generation.\n    \"\"\"\n    \n    # Area magnitude threshold for rejecting degenerate polygons.\n    EPSILON = 1e-6\n\n    def calculate_signed_area(polygon):\n        \"\"\"\n        Calculates the signed area of a polygon using the shoelace formula.\n        A counter-clockwise polygon has positive area, clockwise has negative area.\n        \n        Args:\n            polygon (list of tuples): A list of (x, y) vertex coordinates.\n        \n        Returns:\n            float: The signed area of the polygon.\n        \"\"\"\n        n = len(polygon)\n        if n < 3:\n            return 0.0\n        \n        area = 0.0\n        for i in range(n):\n            x1, y1 = polygon[i]\n            x2, y2 = polygon[(i + 1) % n]\n            area += (x1 * y2 - x2 * y1)\n        \n        return area / 2.0\n\n    def orientation(p, q, r):\n        \"\"\"\n        Finds the orientation of the ordered triplet (p, q, r).\n        \n        Returns:\n            0: Collinear points\n            1: Clockwise (right turn)\n            2: Counter-Clockwise (left turn)\n        \"\"\"\n        val = (q[1] - p[1]) * (r[0] - q[0]) - \\\n              (q[0] - p[0]) * (r[1] - q[1])\n        if abs(val) < 1e-9: # Use tolerance for floating point\n            return 0  # Collinear\n        return 1 if val > 0 else 2  # Clockwise or Counter-Clockwise\n\n    def on_segment(p, q, r):\n        \"\"\"\n        Given three collinear points p, q, r, the function checks if point q \n        lies on line segment 'pr'.\n        \"\"\"\n        return (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n                q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]))\n\n    def segments_intersect(p1, q1, p2, q2):\n        \"\"\"\n        Checks if line segment 'p1q1' and 'p2q2' intersect.\n        \"\"\"\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n\n        # General case: Segments cross each other.\n        if o1 != 0 and o2 != 0 and o3 != 0 and o4 != 0:\n            if o1 != o2 and o3 != o4:\n                return True\n        \n        # Special Cases for collinear intersections.\n        if o1 == 0 and on_segment(p1, p2, q1): return True\n        if o2 == 0 and on_segment(p1, q2, q1): return True\n        if o3 == 0 and on_segment(p2, p1, q2): return True\n        if o4 == 0 and on_segment(p2, q1, q2): return True\n\n        return False\n\n    def is_simple_polygon(polygon):\n        \"\"\"\n        Checks if a polygon is simple (does not self-intersect).\n        Tests all non-adjacent edge pairs for intersection.\n        \"\"\"\n        n = len(polygon)\n        if n < 4:\n            return True # Triangles cannot self-intersect\n\n        for i in range(n):\n            p1 = polygon[i]\n            q1 = polygon[(i + 1) % n]\n            \n            # j starts from i+2 to avoid checking adjacent segments\n            for j in range(i + 2, n):\n                # The last edge (n-1, 0) is adjacent to the first edge (0,1).\n                # This case needs to be skipped. i=0, j=n-1\n                if i == 0 and j == n - 1:\n                    continue\n                \n                p2 = polygon[j]\n                q2 = polygon[(j + 1) % n]\n                \n                if segments_intersect(p1, q1, p2, q2):\n                    return False\n        return True\n\n    test_cases = [\n        {\n            \"outer\": [(0,0),(1000,0),(1000,500),(0,500)],\n            \"holes\": [[(200,100),(250,200),(300,100)]]\n        },\n        {\n            \"outer\": [(0,500),(1000,500),(1000,0),(0,0)],\n            \"holes\": [[(300,100),(250,200),(200,100)]]\n        },\n        {\n            \"outer\": [(0,0),(500,0),(1000,0),(0,0)],\n            \"holes\": []\n        },\n        {\n            \"outer\": [(0,0),(1000,0),(200,500),(800,500)],\n            \"holes\": []\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        case_is_valid = True\n        \n        # Process outer boundary\n        outer_poly = case[\"outer\"]\n        outer_area = calculate_signed_area(outer_poly)\n        outer_is_simple = is_simple_polygon(outer_poly)\n        \n        if not (outer_is_simple and outer_area > EPSILON):\n            case_is_valid = False\n            \n        # Process holes\n        hole_areas = []\n        for hole_poly in case[\"holes\"]:\n            hole_area = calculate_signed_area(hole_poly)\n            hole_areas.append(hole_area)\n            hole_is_simple = is_simple_polygon(hole_poly)\n            if not (hole_is_simple and hole_area < -EPSILON):\n                case_is_valid = False\n\n        # Format results for output\n        rounded_outer_area = round(outer_area, 3)\n        rounded_hole_areas = [round(a, 3) for a in hole_areas]\n        \n        # Construct the string representation for the current result manually\n        hole_areas_str = '[' + ','.join(map(str, rounded_hole_areas)) + ']'\n        result_str = f\"[{rounded_outer_area},{hole_areas_str},{case_is_valid}]\"\n        results.append(result_str)\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once an initial mesh is generated, its quality can often be significantly improved through vertex smoothing, a process of repositioning interior nodes. This exercise introduces a powerful, optimization-based approach where vertex locations are adjusted to minimize a global objective function that penalizes poorly shaped elements and deviations from a desired size distribution . Mastering this technique allows you to create highly-adapted meshes that conform to complex physics, such as steep bathymetric gradients in coastal models.",
            "id": "3817793",
            "problem": "You are tasked with designing an optimization-based vertex smoothing method for a two-dimensional unstructured triangular mesh used in computational oceanography. The smoothing method must move only interior vertices to minimize a global objective that combines inverse quality measures while enforcing fixed boundary vertices. The approach should be framed from first principles and implemented as a complete, runnable program as specified in the final output format.\n\nConsider a polygonal domain $ \\Omega \\subset \\mathbb{R}^2 $ discretized by a set of vertices $\\{ \\mathbf{v}_i \\}_{i=0}^{N-1}$ with $\\mathbf{v}_i = (x_i,y_i)$ and a set of triangles $\\mathcal{T}$ expressed as index triplets $(i,j,k)$ referring to the vertices. Let $\\mathcal{B} \\subset \\{0,1,\\dots,N-1\\}$ denote the set of boundary vertices. Interior vertices are in $\\mathcal{I} = \\{0,1,\\dots,N-1\\} \\setminus \\mathcal{B}$. Let the undirected edge set be $\\mathcal{E}$ induced by $\\mathcal{T}$.\n\nThe fundamental base is the following:\n- The oriented area of a triangle with vertices $\\mathbf{v}_i, \\mathbf{v}_j, \\mathbf{v}_k$ is given by\n$$\nA(i,j,k) = \\frac{1}{2} \\left[(x_j - x_i)(y_k - y_i) - (y_j - y_i)(x_k - x_i)\\right].\n$$\n- The Euclidean length of an edge $(i,j)$ is\n$$\n\\ell(i,j) = \\|\\mathbf{v}_j - \\mathbf{v}_i\\|_2 = \\sqrt{(x_j - x_i)^2 + (y_j - y_i)^2}.\n$$\n- The mean ratio quality of a triangle $(i,j,k)$ is defined by\n$$\nq_{\\mathrm{mr}}(i,j,k) = \\frac{4\\sqrt{3}\\,|A(i,j,k)|}{\\ell(i,j)^2 + \\ell(j,k)^2 + \\ell(k,i)^2},\n$$\nwhich satisfies $0 < q_{\\mathrm{mr}} \\leq 1$ for non-degenerate triangles, with $q_{\\mathrm{mr}} = 1$ attained by equilateral triangles.\n\nIn computational oceanography, mesh resolution should adapt to spatial variability of fields such as bathymetry. Define a smooth bathymetry proxy\n$H(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$,\nwith gradient magnitude\n$$\n\\|\\nabla H(x,y)\\| = \\sqrt{\\left(2\\pi\\cos(2\\pi x)\\sin(2\\pi y)\\right)^2 + \\left(2\\pi\\sin(2\\pi x)\\cos(2\\pi y)\\right)^2}.\n$$\nFor each edge $(i,j)\\in\\mathcal{E}$ with midpoint $\\mathbf{m}_{ij} = \\frac{1}{2}(\\mathbf{v}_i + \\mathbf{v}_j)$, define a target length\n$s(i,j) = \\frac{s_0}{1 + \\beta \\|\\nabla H(\\mathbf{m}_{ij})\\|}$,\nwhere $s_0 > 0$ is a base length and $\\beta \\geq 0$ controls adaptation strength.\n\nConstruct the global objective for vertex positions $\\mathbf{x} = [x_i,y_i]_{i\\in\\mathcal{I}}$ while keeping $\\mathbf{v}_b$ fixed for $b\\in\\mathcal{B}$:\n$$\nJ(\\mathbf{x}) = \\sum_{(i,j,k)\\in\\mathcal{T}} w_{ijk} \\,\\frac{1}{\\epsilon + q_{\\mathrm{mr}}(i,j,k)} \\;+\\; \\gamma \\sum_{(i,j)\\in\\mathcal{E}} \\left(\\frac{\\ell(i,j) - s(i,j)}{s(i,j)}\\right)^2 \\;+\\; \\mu \\sum_{(i,j,k)\\in\\mathcal{T}} \\Phi\\big(A(i,j,k)\\big),\n$$\nwhere $w_{ijk} > 0$ are per-triangle weights, $\\epsilon > 0$ is a small regularization constant, $\\gamma \\geq 0$ controls the edge size conformity penalty, and $\\mu > 0$ weights a barrier term that enforces positive orientation and prevents element inversion. Use\n$$\n\\Phi(A) =\n\\begin{cases}\n-\\log(A), & A > \\delta,\\\\\n+\\infty, & A \\leq \\delta,\n\\end{cases}\n$$\nwith a small threshold $\\delta > 0$. In practice, to ensure numerical robustness in finite precision arithmetic, treat $A \\leq \\delta$ as a large penalty value.\n\nDesign an optimization-based smoothing method that minimizes $J(\\mathbf{x})$ over interior vertex positions subject to the following constraints:\n- Boundary vertices remain fixed: for all $b\\in\\mathcal{B}$, $\\mathbf{v}_b$ is constant.\n- Interior vertices are constrained to remain inside the axis-aligned bounding box of the boundary vertices, i.e., for each $(x_i,y_i)$ with $i\\in\\mathcal{I}$, enforce\n$$\nx_{\\min} \\leq x_i \\leq x_{\\max}, \\quad y_{\\min} \\leq y_i \\leq y_{\\max},\n$$\nwhere $x_{\\min} = \\min_{b\\in\\mathcal{B}} x_b$, $x_{\\max} = \\max_{b\\in\\mathcal{B}} x_b$, $y_{\\min} = \\min_{b\\in\\mathcal{B}} y_b$, and $y_{\\max} = \\max_{b\\in\\mathcal{B}} y_b$.\n\nYour program must:\n- Implement the objective $J(\\mathbf{x})$ as specified and minimize it using a suitable numerical optimization method.\n- For each test case below, output the final mean of $q_{\\mathrm{mr}}$ over all triangles after optimization,\n$$\n\\bar{q}_{\\mathrm{mr}} = \\frac{1}{|\\mathcal{T}|}\\sum_{(i,j,k)\\in\\mathcal{T}} q_{\\mathrm{mr}}(i,j,k),\n$$\nas a floating-point number.\n\nTest suite:\n- Case $1$ (happy path): Square domain with one interior vertex, uniform size objective.\n  - Vertices: $\\mathbf{v}_0=(0,0)$, $\\mathbf{v}_1=(1,0)$, $\\mathbf{v}_2=(1,1)$, $\\mathbf{v}_3=(0,1)$, $\\mathbf{v}_4=(0.5,0.5)$.\n  - Triangles: $(0,1,4)$, $(1,2,4)$, $(2,3,4)$, $(3,0,4)$.\n  - Boundary set: $\\mathcal{B}=\\{0,1,2,3\\}$.\n  - Parameters: $w_{ijk}=1$ for all triangles, $s_0=0.5$, $\\beta=0$, $\\gamma=0$, $\\mu=0.01$, $\\epsilon=10^{-8}$, $\\delta=10^{-12}$.\n- Case $2$ (near-degenerate interior placement): Same as Case $1$ but initial interior vertex $\\mathbf{v}_4=(0.9,0.1)$ to induce poor-quality triangles; same parameters as Case $1$.\n- Case $3$ (anisotropic adaptation): Square domain with two interior vertices and adaptation to bathymetry gradient.\n  - Vertices: $\\mathbf{v}_0=(0,0)$, $\\mathbf{v}_1=(1,0)$, $\\mathbf{v}_2=(1,1)$, $\\mathbf{v}_3=(0,1)$, $\\mathbf{v}_4=(0.3,0.5)$, $\\mathbf{v}_5=(0.7,0.5)$.\n  - Triangles: $(0,1,4)$, $(0,4,3)$, $(1,2,5)$, $(2,3,5)$, $(1,5,4)$, $(3,4,5)$.\n  - Boundary set: $\\mathcal{B}=\\{0,1,2,3\\}$.\n  - Parameters: $w_{ijk}=1$ for all triangles, $s_0=0.35$, $\\beta=1.0$, $\\gamma=1.0$, $\\mu=0.01$, $\\epsilon=10^{-8}$, $\\delta=10^{-12}$.\n- Case $4$ (no interior vertices): Square domain triangulated with a diagonal, no optimization is performed.\n  - Vertices: $\\mathbf{v}_0=(0,0)$, $\\mathbf{v}_1=(1,0)$, $\\mathbf{v}_2=(1,1)$, $\\mathbf{v}_3=(0,1)$.\n  - Triangles: $(0,1,2)$, $(0,2,3)$.\n  - Boundary set: $\\mathcal{B}=\\{0,1,2,3\\}$.\n  - Parameters: $w_{ijk}=1$ for all triangles, $s_0=0.5$, $\\beta=0$, $\\gamma=0$, $\\mu=0.01$, $\\epsilon=10^{-8}$, $\\delta=10^{-12}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets, for example, $[\\bar{q}_1,\\bar{q}_2,\\bar{q}_3,\\bar{q}_4]$. Each $\\bar{q}_i$ must be a floating-point number. No other text must be printed.",
            "solution": "The goal is to smooth interior vertices of an unstructured triangular mesh to improve the global mesh quality relevant for computational oceanography, while preserving boundary vertices to respect coastal boundaries. We proceed from fundamental geometric definitions and construct an objective function that is minimized over interior vertex coordinates.\n\nWe begin with the geometric primitives. For each triangle $(i,j,k)$, the oriented area $A(i,j,k)$ is defined by the cross product of its edge vectors, yielding\n$$\nA(i,j,k) = \\frac{1}{2}\\left[(x_j - x_i)(y_k - y_i) - (y_j - y_i)(x_k - x_i)\\right],\n$$\nwhich is positive for counterclockwise orientation and negative for clockwise orientation. The Euclidean length of an edge $(i,j)$ is\n$$\n\\ell(i,j) = \\sqrt{(x_j - x_i)^2 + (y_j - y_i)^2}.\n$$\nWe measure triangle quality by the mean ratio quality\n$$\nq_{\\mathrm{mr}}(i,j,k) = \\frac{4\\sqrt{3}\\,|A(i,j,k)|}{\\ell(i,j)^2 + \\ell(j,k)^2 + \\ell(k,i)^2}.\n$$\nThis measure is bounded by $0 < q_{\\mathrm{mr}} \\leq 1$, achieving $1$ for an equilateral triangle and approaching $0$ for degenerate configurations. In ocean model discretizations, poor-quality elements can introduce numerical errors and spurious diffusion. Therefore, minimizing the sum of inverse quality measures effectively penalizes poorly shaped triangles:\n$$\n\\sum_{(i,j,k)\\in\\mathcal{T}} w_{ijk}\\frac{1}{\\epsilon + q_{\\mathrm{mr}}(i,j,k)}.\n$$\nThe small constant $\\epsilon > 0$ ensures numerical stability by avoiding division by zero, while $w_{ijk} > 0$ allows selective weighting (here uniform).\n\nOceanographic meshes often adapt their resolution to spatial gradients of bathymetric features. We incorporate a smooth proxy field\n$$\nH(x,y) = \\sin(2\\pi x)\\sin(2\\pi y),\n$$\nwith gradient magnitude\n$$\n\\|\\nabla H(x,y)\\| = \\sqrt{\\left(2\\pi\\cos(2\\pi x)\\sin(2\\pi y)\\right)^2 + \\left(2\\pi\\sin(2\\pi x)\\cos(2\\pi y)\\right)^2}.\n$$\nFor each edge $(i,j)$ with midpoint $\\mathbf{m}_{ij} = \\frac{1}{2}(\\mathbf{v}_i + \\mathbf{v}_j)$, we define the target length\n$$\ns(i,j) = \\frac{s_0}{1 + \\beta \\|\\nabla H(\\mathbf{m}_{ij})\\|},\n$$\nwhich decreases with increasing gradient magnitude, reflecting finer desired resolution near steep bathymetric gradients. We include an edge size conformity penalty:\n$$\n\\gamma \\sum_{(i,j)\\in\\mathcal{E}} \\left(\\frac{\\ell(i,j) - s(i,j)}{s(i,j)}\\right)^2,\n$$\nwith $\\gamma \\geq 0$ controlling its contribution.\n\nTo prevent triangle inversion during optimization, we incorporate a barrier enforcing positive orientation. Ideally, we use\n$$\n\\Phi(A) = -\\log(A), \\quad A > 0,\n$$\nwhich tends to $+\\infty$ as $A \\to 0^+$. Numerically, we employ a threshold $\\delta > 0$ and treat $A \\leq \\delta$ as a large fixed penalty, thus:\n$$\n\\Phi(A) =\n\\begin{cases}\n-\\log(A), & A > \\delta,\\\\\n+\\infty\\ (\\text{implemented as a large constant}), & A \\leq \\delta.\n\\end{cases}\n$$\nThe barrier term is weighted by $\\mu > 0$ and added over all triangles.\n\nCombining these pieces, the global objective for interior vertex positions $\\mathbf{x}$ is\n$$\nJ(\\mathbf{x}) = \\sum_{(i,j,k)\\in\\mathcal{T}} w_{ijk}\\frac{1}{\\epsilon + q_{\\mathrm{mr}}(i,j,k)} \\;+\\; \\gamma \\sum_{(i,j)\\in\\mathcal{E}} \\left(\\frac{\\ell(i,j) - s(i,j)}{s(i,j)}\\right)^2 \\;+\\; \\mu \\sum_{(i,j,k)\\in\\mathcal{T}} \\Phi\\big(A(i,j,k)\\big).\n$$\nWe minimize $J(\\mathbf{x})$ over interior vertex coordinates while keeping boundary vertices fixed:\n$$\n\\mathbf{v}_b = \\text{constant}, \\quad \\forall b \\in \\mathcal{B}.\n$$\nWe constrain the interior vertices to remain in the axis-aligned bounding box of the boundary, with bounds\n$$\nx_{\\min} \\leq x_i \\leq x_{\\max}, \\quad y_{\\min} \\leq y_i \\leq y_{\\max}, \\quad \\forall i \\in \\mathcal{I},\n$$\nwhere $x_{\\min} = \\min_{b\\in\\mathcal{B}} x_b$, $x_{\\max} = \\max_{b\\in\\mathcal{B}} x_b$, $y_{\\min} = \\min_{b\\in\\mathcal{B}} y_b$, $y_{\\max} = \\max_{b\\in\\mathcal{B}} y_b$. This prevents drift outside the domain and is consistent with coastal boundary constraints.\n\nAlgorithmic design:\n- Construct the edge set $\\mathcal{E}$ from $\\mathcal{T}$ by collecting unique undirected pairs $(\\min(i,j),\\max(i,j))$ from all triangle sides.\n- Implement functions to compute $A(i,j,k)$, $\\ell(i,j)$, $q_{\\mathrm{mr}}(i,j,k)$, and $s(i,j)$.\n- Represent $\\mathbf{x}$ as a flattened vector of $(x_i,y_i)$ for $i\\in\\mathcal{I}$, and reconstruct the full vertex array $\\{\\mathbf{v}_i\\}$ by inserting boundary vertices unchanged.\n- Implement $J(\\mathbf{x})$, returning a large value if any $A(i,j,k) \\leq \\delta$ to avoid inverted or nearly degenerate elements.\n- Use a bound-constrained optimizer such as the Limited-memory Broyden-Fletcher-Goldfarb-Shanno with box constraints (L-BFGS-B) to minimize $J(\\mathbf{x})$ over the interior vertex positions. This method handles large-scale problems and respects variable bounds without requiring explicit constraints, suitable here because boundary vertices are excluded from the variable vector and interior bounds define a simple feasible set.\n- After optimization, compute\n$$\n\\bar{q}_{\\mathrm{mr}} = \\frac{1}{|\\mathcal{T}|}\\sum_{(i,j,k)\\in\\mathcal{T}} q_{\\mathrm{mr}}(i,j,k),\n$$\nto summarize the final mesh quality.\n\nTest suite rationale:\n- Case $1$ provides a typical scenario with one interior vertex and uniform size metric ($\\beta=0$, $\\gamma=0$), isolating the effect of shape optimization via inverse quality.\n- Case $2$ places the interior vertex near a corner, causing skinny triangles and testing the optimizer’s ability to find a better configuration within bounds.\n- Case $3$ includes two interior vertices and an anisotropic size objective ($\\beta>0$, $\\gamma>0$) driven by the bathymetry gradient, testing the combined effect of shape and size adaptation.\n- Case $4$ has no interior vertices, ensuring the implementation handles the degenerate optimization case and correctly reports the baseline quality.\n\nThe program computes the final mean quality for each case and outputs a single line containing the four floating-point results in a bracketed, comma-separated list as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef triangle_oriented_area(V, tri):\n    i, j, k = tri\n    xi, yi = V[i]\n    xj, yj = V[j]\n    xk, yk = V[k]\n    return 0.5 * ((xj - xi) * (yk - yi) - (yj - yi) * (xk - xi))\n\ndef edge_length(V, i, j):\n    diff = V[j] - V[i]\n    return np.sqrt(np.dot(diff, diff))\n\ndef mean_ratio_quality(V, T):\n    qualities = []\n    for tri in T:\n        i, j, k = tri\n        lij2 = np.sum((V[j] - V[i])**2)\n        ljk2 = np.sum((V[k] - V[j])**2)\n        lki2 = np.sum((V[i] - V[k])**2)\n        A = abs(triangle_oriented_area(V, tri))\n        denom = lij2 + ljk2 + lki2\n        if denom <= 1e-16:\n            q = 0.0\n        else:\n            q = (4.0 * np.sqrt(3.0) * A) / denom\n        qualities.append(q)\n    return np.array(qualities)\n\ndef build_edges(T):\n    edges = set()\n    for i, j, k in T:\n        for a, b in [(i, j), (j, k), (k, i)]:\n            e = (min(a, b), max(a, b))\n            edges.add(e)\n    return sorted(list(edges))\n\ndef bathymetry_grad_mag(x, y):\n    # H(x,y) = sin(2*pi*x)*sin(2*pi*y)\n    # dH/dx = 2*pi*cos(2*pi*x)*sin(2*pi*y)\n    # dH/dy = 2*pi*sin(2*pi*x)*cos(2*pi*y)\n    two_pi = 2.0 * np.pi\n    dHx = two_pi * np.cos(two_pi * x) * np.sin(two_pi * y)\n    dHy = two_pi * np.sin(two_pi * x) * np.cos(two_pi * y)\n    return np.sqrt(dHx * dHx + dHy * dHy)\n\ndef target_edge_length(V, edge, s0, beta):\n    i, j = edge\n    mid = 0.5 * (V[i] + V[j])\n    g = bathymetry_grad_mag(mid[0], mid[1])\n    return s0 / (1.0 + beta * g)\n\ndef objective_factory(V_init, T, edges, boundary_mask, params):\n    # params: dict with keys 'w_tri', 's0', 'beta', 'gamma', 'mu', 'eps', 'delta'\n    w_tri = params['w_tri']\n    s0 = params['s0']\n    beta = params['beta']\n    gamma = params['gamma']\n    mu = params['mu']\n    eps = params['eps']\n    delta = params['delta']\n\n    N = V_init.shape[0]\n    interior_idx = np.where(~boundary_mask)[0]\n    bound_idx = np.where(boundary_mask)[0]\n\n    # Bounds: box constraints within boundary bbox\n    xb = V_init[boundary_mask, 0]\n    yb = V_init[boundary_mask, 1]\n    xmin, xmax = float(np.min(xb)), float(np.max(xb))\n    ymin, ymax = float(np.min(yb)), float(np.max(yb))\n    bounds = []\n    for _ in interior_idx:\n        bounds.append((xmin, xmax))  # bound for x\n        bounds.append((ymin, ymax))  # bound for y\n\n    def pack(V_full):\n        return np.hstack([V_full[interior_idx, 0], V_full[interior_idx, 1]])\n\n    def unpack(xvec):\n        V = V_init.copy()\n        # xvec has length 2*len(interior_idx)\n        V[interior_idx, 0] = xvec[:len(interior_idx)]\n        V[interior_idx, 1] = xvec[len(interior_idx):]\n        return V\n\n    def objective(xvec):\n        V = unpack(xvec)\n\n        # Barrier: penalize non-positive areas\n        areas = np.array([triangle_oriented_area(V, tri) for tri in T])\n        if np.any(areas <= delta):\n            # Large penalty to discourage invalid configurations\n            return 1e12 + np.sum((delta - np.minimum(areas, delta))**2)\n\n        # Mean ratio inverse sum\n        q_mr = mean_ratio_quality(V, T)\n        inv_quality = np.sum(w_tri * (1.0 / (eps + q_mr)))\n\n        # Edge size conformity penalty\n        size_pen = 0.0\n        if gamma > 0.0:\n            for e in edges:\n                l = edge_length(V, e[0], e[1])\n                s = target_edge_length(V, e, s0, beta)\n                size_pen += ((l - s) / s) ** 2\n            size_pen *= gamma\n\n        # Barrier term\n        barrier = -np.sum(np.log(areas)) * mu\n\n        return inv_quality + size_pen + barrier\n\n    x0 = pack(V_init)\n    return objective, x0, bounds, interior_idx\n\ndef optimize_mesh(V_init, T, boundary_mask, params):\n    edges = build_edges(T)\n    obj, x0, bounds, interior_idx = objective_factory(V_init, T, edges, boundary_mask, params)\n    # If there are no interior vertices, skip optimization\n    if len(interior_idx) == 0:\n        V_opt = V_init.copy()\n    else:\n        res = minimize(obj, x0, method='L-BFGS-B', bounds=bounds,\n                       options={'maxiter': 300, 'ftol': 1e-12})\n        # Reconstruct optimized vertices\n        V_opt = V_init.copy()\n        V_opt[interior_idx, 0] = res.x[:len(interior_idx)]\n        V_opt[interior_idx, 1] = res.x[len(interior_idx):]\n    # Compute mean mean-ratio quality\n    q_mr = mean_ratio_quality(V_opt, T)\n    mean_q = float(np.mean(q_mr))\n    return mean_q\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = []\n\n    # Case 1\n    V1 = np.array([\n        [0.0, 0.0],\n        [1.0, 0.0],\n        [1.0, 1.0],\n        [0.0, 1.0],\n        [0.5, 0.5]\n    ], dtype=float)\n    T1 = np.array([\n        [0, 1, 4],\n        [1, 2, 4],\n        [2, 3, 4],\n        [3, 0, 4]\n    ], dtype=int)\n    B1 = np.array([True, True, True, True, False])\n    params1 = {'w_tri': np.ones(len(T1)), 's0': 0.5, 'beta': 0.0, 'gamma': 0.0, 'mu': 0.01, 'eps': 1e-8, 'delta': 1e-12}\n    test_cases.append((V1, T1, B1, params1))\n\n    # Case 2: interior near corner\n    V2 = np.array([\n        [0.0, 0.0],\n        [1.0, 0.0],\n        [1.0, 1.0],\n        [0.0, 1.0],\n        [0.9, 0.1]\n    ], dtype=float)\n    T2 = np.array([\n        [0, 1, 4],\n        [1, 2, 4],\n        [2, 3, 4],\n        [3, 0, 4]\n    ], dtype=int)\n    B2 = np.array([True, True, True, True, False])\n    params2 = {'w_tri': np.ones(len(T2)), 's0': 0.5, 'beta': 0.0, 'gamma': 0.0, 'mu': 0.01, 'eps': 1e-8, 'delta': 1e-12}\n    test_cases.append((V2, T2, B2, params2))\n\n    # Case 3: anisotropic adaptation with two interior vertices\n    V3 = np.array([\n        [0.0, 0.0],\n        [1.0, 0.0],\n        [1.0, 1.0],\n        [0.0, 1.0],\n        [0.3, 0.5],\n        [0.7, 0.5]\n    ], dtype=float)\n    T3 = np.array([\n        [0, 1, 4],\n        [0, 4, 3],\n        [1, 2, 5],\n        [2, 3, 5],\n        [1, 5, 4],\n        [3, 4, 5]\n    ], dtype=int)\n    B3 = np.array([True, True, True, True, False, False])\n    params3 = {'w_tri': np.ones(len(T3)), 's0': 0.35, 'beta': 1.0, 'gamma': 1.0, 'mu': 0.01, 'eps': 1e-8, 'delta': 1e-12}\n    test_cases.append((V3, T3, B3, params3))\n\n    # Case 4: no interior vertices\n    V4 = np.array([\n        [0.0, 0.0],\n        [1.0, 0.0],\n        [1.0, 1.0],\n        [0.0, 1.0]\n    ], dtype=float)\n    T4 = np.array([\n        [0, 1, 2],\n        [0, 2, 3]\n    ], dtype=int)\n    B4 = np.array([True, True, True, True])\n    params4 = {'w_tri': np.ones(len(T4)), 's0': 0.5, 'beta': 0.0, 'gamma': 0.0, 'mu': 0.01, 'eps': 1e-8, 'delta': 1e-12}\n    test_cases.append((V4, T4, B4, params4))\n\n    results = []\n    for V, T, B, params in test_cases:\n        result = optimize_mesh(V, T, B, params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A generated mesh is only useful if it meets the quality standards required for stable and accurate numerical simulations. This final practice bridges the gap between mesh generation and application by focusing on quantitative quality assessment . You will learn to compute critical quality metrics, such as the minimum interior angle, analyze their distribution across the mesh, and implement a formal decision logic to determine whether the mesh requires further refinement or smoothing.",
            "id": "3817836",
            "problem": "You are given planar meshes composed of triangles defined by vertex coordinates and triangle connectivity. For each mesh, you must compute angle-based quality histograms and decide whether additional refinement or smoothing is required to satisfy a minimum interior angle threshold $ \\theta_{\\min} $ expressed in degrees. Work from first principles of Euclidean geometry and graph connectivity, and formalize the decision using only definitions and well-tested facts.\n\nFundamental base and definitions:\n- A mesh consists of a set of vertices with coordinates $ \\{ \\mathbf{x}_i \\in \\mathbb{R}^2 \\}_{i=0}^{N_v-1} $ and a set of triangles $ \\{ (i,j,k) \\}_{m=0}^{N_t-1} $, where each triangle indexes three distinct vertices. For triangle $ (i,j,k) $ with points $ \\mathbf{a} = \\mathbf{x}_i $, $ \\mathbf{b} = \\mathbf{x}_j $, $ \\mathbf{c} = \\mathbf{x}_k $, define the edge vectors at a vertex by differences of position vectors. The interior angle at vertex $ \\mathbf{a} $ is computed from the dot product as\n$$\n\\theta_a = \\arccos \\left( \\frac{ (\\mathbf{b}-\\mathbf{a}) \\cdot (\\mathbf{c}-\\mathbf{a}) }{ \\| \\mathbf{b}-\\mathbf{a} \\| \\, \\| \\mathbf{c}-\\mathbf{a} \\| } \\right ),\n$$\nwith analogous formulas for $ \\theta_b $ and $ \\theta_c $. The three interior angles of a non-degenerate triangle satisfy $ \\theta_a + \\theta_b + \\theta_c = 180^\\circ $. All angles must be reported in degrees.\n- The minimum interior angle quality for triangle $ m $ is\n$$\nq_m = \\min\\{ \\theta_a, \\theta_b, \\theta_c \\} \\quad \\text{(degrees)}.\n$$\n- The edge lengths are $ \\ell_1 = \\| \\mathbf{b}-\\mathbf{a} \\| $, $ \\ell_2 = \\| \\mathbf{c}-\\mathbf{b} \\| $, and $ \\ell_3 = \\| \\mathbf{a}-\\mathbf{c} \\| $. The anisotropy ratio for a triangle is\n$$\nr_m = \\frac{ \\max\\{ \\ell_1, \\ell_2, \\ell_3 \\} }{ \\min\\{ \\ell_1, \\ell_2, \\ell_3 \\} }.\n$$\n- A triangle is numerically degenerate if its unsigned area\n$$\nA_m = \\frac{1}{2} \\left| (\\mathbf{b}-\\mathbf{a}) \\times (\\mathbf{c}-\\mathbf{a}) \\right|\n$$\nis less than a tolerance $ \\varepsilon > 0 $. For degenerate triangles, set $ q_m = 0 $ and treat the anisotropy ratio as $ +\\infty $.\n- The mesh has a set of histogram bin edges $ \\mathcal{B} = [b_0, b_1, \\dots, b_K] $ with $ b_0 = 0 $ and $ b_K \\ge 60 $. Place each $ q_m $ into a bin interval $ [b_j, b_{j+1}) $ except the last interval $ [b_{K-1}, b_K] $ which is closed on both ends, and report integer counts per bin.\n- Let $ \\mathcal{V} = \\{ m : q_m < \\theta_{\\min} \\} $ denote the index set of violating triangles. Define the violation fraction\n$$\nf = \\frac{|\\mathcal{V}|}{N_t}.\n$$\n- Define an extremeness threshold relative to the minimum angle as $ \\delta = c \\, \\theta_{\\min} $ with a constant $ c \\in (0,1) $.\n- Define triangle adjacency on the vertex-sharing graph: two triangles $ m $ and $ n $ are adjacent if they share at least one vertex index. Consider the induced subgraph on $ \\mathcal{V} $ and let $ c_{\\max} $ be the size of the largest connected component.\n\nDecision logic to recommend smoothing or refinement:\n- If there are no violations, i.e., $ |\\mathcal{V}| = 0 $, then no smoothing and no refinement are required.\n- Otherwise, compute $ f $, $ r_{\\max} = \\max_{m \\in \\mathcal{V}} r_m $, $ q_{\\min} = \\min_{m \\in \\mathcal{V}} q_m $, and $ c_{\\max} $. Recommend smoothing if and only if all the following hold simultaneously:\n  1. $ f \\le \\alpha $ (violations are limited in fraction),\n  2. $ r_{\\max} \\le R_{\\text{lim}} $ (violating elements are not excessively anisotropic),\n  3. $ q_{\\min} \\ge \\delta $ (no extremely small violating angles),\n  4. $ c_{\\max} < \\kappa $ (no large clusters of violations).\n  If any of these conditions fails, recommend refinement instead. Output booleans for smoothing and refinement so that exactly one of them is true when violations exist.\n\nAngle units and numerical handling:\n- All angles must be computed and reported in degrees. Use radians internally only if converted back to degrees for outputs and comparisons.\n- Use a robust computation by clamping the argument of $ \\arccos $ to the interval $ [-1,1] $ to avoid floating-point errors.\n\nTest suite:\nFor each test case, you are given $ (\\text{vertices}, \\text{triangles}, \\theta_{\\min}, \\mathcal{B}, R_{\\text{lim}}, \\alpha, \\kappa, \\varepsilon, c) $ with the following parameter values:\n\n- Test case $ 1 $ (happy path, no violations):\n  - $ \\text{vertices} = [(0,0),(1,0),(1,1),(0,1)] $\n  - $ \\text{triangles} = [(0,1,2),(0,2,3)] $\n  - $ \\theta_{\\min} = 30 $ (degrees)\n  - $ \\mathcal{B} = [0,10,20,30,40,50,60] $ (degrees)\n  - $ R_{\\text{lim}} = 3 $\n  - $ \\alpha = 0.2 $\n  - $ \\kappa = 2 $\n  - $ \\varepsilon = 10^{-12} $\n  - $ c = 0.5 $\n\n- Test case $ 2 $ (isolated moderate violation, smoothing expected):\n  - $ \\text{vertices} = [(0,0),(1,0),(1,1),(0,1),(0.5,0.2)] $\n  - $ \\text{triangles} = [(0,1,4),(1,2,4),(2,3,4),(3,0,4)] $\n  - $ \\theta_{\\min} = 25 $ (degrees)\n  - $ \\mathcal{B} = [0,10,20,30,40,50,60] $ (degrees)\n  - $ R_{\\text{lim}} = 3 $\n  - $ \\alpha = 0.3 $\n  - $ \\kappa = 2 $\n  - $ \\varepsilon = 10^{-12} $\n  - $ c = 0.5 $\n\n- Test case $ 3 $ (clustered violations along a line, refinement expected):\n  - $ \\text{vertices} = [(0,0),(1,0),(2,0),(3,0),(0.5,0.1),(1.5,0.1),(2.5,0.1)] $\n  - $ \\text{triangles} = [(0,1,4),(1,2,5),(2,3,6)] $\n  - $ \\theta_{\\min} = 20 $ (degrees)\n  - $ \\mathcal{B} = [0,10,20,30,40,50,60] $ (degrees)\n  - $ R_{\\text{lim}} = 3 $\n  - $ \\alpha = 0.3 $\n  - $ \\kappa = 2 $\n  - $ \\varepsilon = 10^{-12} $\n  - $ c = 0.5 $\n\n- Test case $ 4 $ (boundary condition at equilateral threshold, no action):\n  - $ \\text{vertices} = [(0,0),(1,0),(0.5,0.8660254037844386)] $\n  - $ \\text{triangles} = [(0,1,2)] $\n  - $ \\theta_{\\min} = 60 $ (degrees)\n  - $ \\mathcal{B} = [0,10,20,30,40,50,60] $ (degrees)\n  - $ R_{\\text{lim}} = 3 $\n  - $ \\alpha = 0.2 $\n  - $ \\kappa = 2 $\n  - $ \\varepsilon = 10^{-12} $\n  - $ c = 0.5 $\n\n- Test case $ 5 $ (degenerate triangle, refinement required):\n  - $ \\text{vertices} = [(0,0),(1,0),(2,0)] $\n  - $ \\text{triangles} = [(0,1,2)] $\n  - $ \\theta_{\\min} = 10 $ (degrees)\n  - $ \\mathcal{B} = [0,10,20,30,40,50,60] $ (degrees)\n  - $ R_{\\text{lim}} = 3 $\n  - $ \\alpha = 0.2 $\n  - $ \\kappa = 2 $\n  - $ \\varepsilon = 10^{-12} $\n  - $ c = 0.5 $\n\nRequired outputs per test case:\n- A list of histogram bin counts for the distribution of $ \\{ q_m \\}_{m=0}^{N_t-1} $ over $ \\mathcal{B} $.\n- A boolean indicating whether smoothing is recommended.\n- A boolean indicating whether refinement is recommended.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list with no spaces, enclosed in square brackets. Each test case result must be a list in the form $ [\\text{hist},\\text{smoothing},\\text{refinement}] $, where $ \\text{hist} $ is itself a list of integers. For example:\n$ [[ [h_{11},h_{12},\\dots],\\text{True},\\text{False} ],[ [h_{21},\\dots],\\text{False},\\text{True} ],\\dots] $,\nbut printed without spaces, such as $ [[[3,2,0,0,0,0],[...]],...] $.",
            "solution": "The problem is valid. It is a well-defined computational geometry task grounded in the principles of Euclidean geometry and graph theory, which are standard in the analysis of computational meshes. All required data, definitions, and decision logic are provided, making the problem self-contained, objective, and well-posed. A unique solution can be algorithmically determined for each test case.\n\nThe solution is implemented by following a systematic procedure for each test case. The procedure is divided into four main stages: (1) per-triangle geometric property calculation, (2) aggregation of quality metrics into a histogram, (3) identification of violating triangles and analysis of their collective properties, and (4) application of a formal decision logic to recommend a subsequent mesh adaptation action.\n\n**1. Per-Triangle Geometric Analysis**\n\nFor each triangle $m$ in the mesh, defined by vertices $\\mathbf{a} = \\mathbf{x}_i$, $\\mathbf{b} = \\mathbf{x}_j$, and $\\mathbf{c} = \\mathbf{x}_k$, we compute its fundamental geometric properties.\n\nFirst, we determine if the triangle is numerically degenerate. The area $A_m$ is computed using the 2D cross-product of the edge vectors originating from a common vertex:\n$$\nA_m = \\frac{1}{2} \\left| (\\mathbf{b}-\\mathbf{a}) \\times (\\mathbf{c}-\\mathbf{a}) \\right| = \\frac{1}{2} \\left| (x_b-x_a)(y_c-y_a) - (x_c-x_a)(y_b-y_a) \\right|\n$$\nIf $A_m$ is less than a small tolerance $\\varepsilon > 0$, the triangle is considered degenerate. For such triangles, the quality metric $q_m$ is set to $0$ and the anisotropy ratio $r_m$ is set to $+\\infty$.\n\nFor non-degenerate triangles, we compute the three interior angles. The angle $\\theta_a$ at vertex $\\mathbf{a}$ is given by the formula:\n$$\n\\theta_a = \\arccos \\left( \\frac{ (\\mathbf{b}-\\mathbf{a}) \\cdot (\\mathbf{c}-\\mathbf{a}) }{ \\| \\mathbf{b}-\\mathbf{a} \\| \\| \\mathbf{c}-\\mathbf{a} \\| } \\right )\n$$\nThe angles $\\theta_b$ and $\\theta_c$ are computed analogously. To ensure numerical stability, the argument of the $\\arccos$ function is clamped to the valid range $[-1, 1]$. The angles, computed in radians, are converted to degrees. The quality of the triangle, $q_m$, is then defined as the minimum of its three interior angles:\n$$\nq_m = \\min \\{ \\theta_a, \\theta_b, \\theta_c \\}\n$$\nWe also compute the edge lengths $\\ell_1 = \\| \\mathbf{b}-\\mathbf{a} \\|$, $\\ell_2 = \\| \\mathbf{c}-\\mathbf{b} \\|$, and $\\ell_3 = \\| \\mathbf{a}-\\mathbf{c} \\|$. The anisotropy ratio $r_m$ is the ratio of the longest edge to the shortest edge:\n$$\nr_m = \\frac{ \\max\\{ \\ell_1, \\ell_2, \\ell_3 \\} }{ \\min\\{ \\ell_1, \\ell_2, \\ell_3 \\} }\n$$\n\n**2. Mesh Quality Histogram**\n\nAfter computing the quality $q_m$ for all $N_t$ triangles in the mesh, we generate a histogram of these values. The bin edges are provided by the set $\\mathcal{B} = [b_0, b_1, \\dots, b_K]$. Each quality value $q_m$ is placed into one of the bins. The bins are defined as half-open intervals $[b_j, b_{j+1})$ for $j=0, \\dots, K-2$, and a closed interval $[b_{K-1}, b_K]$ for the last bin. The output for this stage is a list of integer counts for each bin.\n\n**3. Violation Analysis**\n\nA triangle $m$ is considered to be in violation of the quality criterion if its quality $q_m$ is less than a specified minimum angle threshold, $\\theta_{\\min}$. We define the set of violating triangles as $\\mathcal{V} = \\{ m : q_m < \\theta_{\\min} \\}$.\n\nIf $\\mathcal{V}$ is empty (i.e., $|\\mathcal{V}| = 0$), no further analysis is needed, and no mesh adaption is required.\n\nIf $\\mathcal{V}$ is non-empty, we compute four metrics that characterize the nature of the violations:\n1.  **Violation Fraction ($f$):** The fraction of triangles that are in violation, $f = \\frac{|\\mathcal{V}|}{N_t}$.\n2.  **Maximum Anisotropy ($r_{\\max}$):** The maximum anisotropy ratio among all violating triangles, $r_{\\max} = \\max_{m \\in \\mathcal{V}} r_m$.\n3.  **Minimum Quality ($q_{\\min}$):** The minimum quality value among all violating triangles, $q_{\\min} = \\min_{m \\in \\mathcal{V}} q_m$.\n4.  **Maximum Cluster Size ($c_{\\max}$):** This metric quantifies the spatial clustering of violating triangles. An adjacency graph is constructed where the nodes represent the triangles in $\\mathcal{V}$. An edge exists between two nodes if the corresponding triangles share at least one vertex. We then find the size of the largest connected component in this graph, denoted $c_{\\max}$. This is achieved by performing a graph traversal algorithm, like Breadth-First Search (BFS) or Depth-First Search (DFS), starting from each unvisited node to count the members of its component.\n\n**4. Decision Logic**\n\nThe final step is to recommend an action based on the computed metrics. The choice is between 'smoothing' (relocating vertices to improve quality) and 'refinement' (adding new vertices and triangles).\n\n- If $|\\mathcal{V}| = 0$, both smoothing and refinement are not recommended (booleans are `False`).\n- If $|\\mathcal{V}| > 0$, smoothing is recommended if and only if all of the following conditions are met simultaneously:\n    1.  The violation fraction is small: $f \\le \\alpha$.\n    2.  The violating triangles are not excessively elongated: $r_{\\max} \\le R_{\\text{lim}}$.\n    3.  The violations are not extreme: $q_{\\min} \\ge \\delta$, where $\\delta = c \\cdot \\theta_{\\min}$.\n    4.  The violating triangles do not form large clusters: $c_{\\max} < \\kappa$.\n\nIf these four conditions hold, the recommendation is smoothing (`True`) and not refinement (`False`). If any condition fails, the recommendation is refinement (`True`) and not smoothing (`False`), ensuring that exactly one action is recommended when violations exist. This logic is based on the heuristic that localized, non-severe quality issues can often be fixed by smoothing, while widespread, severe, or highly clustered issues typically require the more expensive operation of refinement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        # Case 1: Happy path, no violations\n        (\n            [(0,0),(1,0),(1,1),(0,1)], \n            [(0,1,2),(0,2,3)], \n            30, [0,10,20,30,40,50,60], 3, 0.2, 2, 1e-12, 0.5\n        ),\n        # Case 2: Isolated moderate violation, smoothing expected\n        (\n            [(0,0),(1,0),(1,1),(0,1),(0.5,0.2)], \n            [(0,1,4),(1,2,4),(2,3,4),(3,0,4)], \n            25, [0,10,20,30,40,50,60], 3, 0.3, 2, 1e-12, 0.5\n        ),\n        # Case 3: Clustered violations, refinement expected\n        (\n            [(0,0),(1,0),(2,0),(3,0),(0.5,0.1),(1.5,0.1),(2.5,0.1)], \n            [(0,1,4),(1,2,5),(2,3,6)], \n            20, [0,10,20,30,40,50,60], 3, 0.3, 2, 1e-12, 0.5\n        ),\n        # Case 4: Boundary condition at equilateral, no action\n        (\n            [(0,0),(1,0),(0.5,0.8660254037844386)], \n            [(0,1,2)], \n            60, [0,10,20,30,40,50,60], 3, 0.2, 2, 1e-12, 0.5\n        ),\n        # Case 5: Degenerate triangle, refinement required\n        (\n            [(0,0),(1,0),(2,0)], \n            [(0,1,2)], \n            10, [0,10,20,30,40,50,60], 3, 0.2, 2, 1e-12, 0.5\n        ),\n    ]\n\n    all_results = [process_case(case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    # Convert the list of results to a string and remove all spaces.\n    final_output_string = str(all_results).replace(' ', '')\n    print(final_output_string)\n\ndef process_case(case_data):\n    \"\"\"\n    Processes a single test case to determine mesh quality and recommendations.\n    \"\"\"\n    vertices_list, triangles_list, theta_min, B, R_lim, alpha, kappa, epsilon, c = case_data\n    vertices = np.array(vertices_list, dtype=float)\n    triangles = np.array(triangles_list, dtype=int)\n    \n    Nt = len(triangles)\n    qualities_q = np.zeros(Nt)\n    anisotropy_r = np.zeros(Nt)\n    \n    for m, tri_indices in enumerate(triangles):\n        p1, p2, p3 = vertices[tri_indices]\n        \n        # Check for degeneracy using area calculation\n        area = 0.5 * abs((p2[0] - p1[0]) * (p3[1] - p1[1]) - (p3[0] - p1[0]) * (p2[1] - p1[1]))\n        \n        if area < epsilon:\n            qualities_q[m] = 0.0\n            anisotropy_r[m] = np.inf\n            continue\n            \n        # Edge lengths and anisotropy\n        l1 = np.linalg.norm(p2 - p1)\n        l2 = np.linalg.norm(p3 - p2)\n        l3 = np.linalg.norm(p1 - p3)\n        lengths = [l1, l2, l3]\n        if min(lengths) < epsilon: # Avoid division by zero for near-degenerate cases\n             anisotropy_r[m] = np.inf\n        else:\n             anisotropy_r[m] = max(lengths) / min(lengths)\n\n        # Interior angles\n        angles_deg = []\n        vecs = [(p2 - p1, p3 - p1, l1, l3), \n                (p1 - p2, p3 - p2, l1, l2),\n                (p1 - p3, p2 - p3, l3, l2)]\n\n        for v1, v2, len1, len2 in vecs:\n            cos_theta = np.dot(v1, v2) / (len1 * len2)\n            cos_theta = np.clip(cos_theta, -1.0, 1.0)\n            angle_rad = np.arccos(cos_theta)\n            angles_deg.append(np.degrees(angle_rad))\n        \n        qualities_q[m] = np.min(angles_deg)\n\n    # Histogram of quality metrics\n    hist, _ = np.histogram(qualities_q, bins=B)\n    \n    # Decision logic\n    violating_indices = np.where(qualities_q < theta_min)[0]\n    num_violations = len(violating_indices)\n    \n    if num_violations == 0:\n        return [hist.tolist(), False, False]\n        \n    f = num_violations / Nt\n    \n    q_violating = qualities_q[violating_indices]\n    r_violating = anisotropy_r[violating_indices]\n    \n    q_min_viol = np.min(q_violating)\n    r_max_viol = np.max(r_violating)\n    \n    delta = c * theta_min\n    \n    # Adjacency graph and connected components\n    c_max = 0\n    if num_violations > 0:\n        violating_tri_verts = [set(triangles[i]) for i in violating_indices]\n        adj = {i: [] for i in range(num_violations)}\n        for i in range(num_violations):\n            for j in range(i + 1, num_violations):\n                if violating_tri_verts[i].intersection(violating_tri_verts[j]):\n                    adj[i].append(j)\n                    adj[j].append(i)\n        \n        visited = set()\n        for i in range(num_violations):\n            if i not in visited:\n                component_size = 0\n                q = [i]\n                visited.add(i)\n                head = 0\n                while head < len(q):\n                    u = q[head]\n                    head += 1\n                    component_size += 1\n                    for v in adj[u]:\n                        if v not in visited:\n                            visited.add(v)\n                            q.append(v)\n                c_max = max(c_max, component_size)\n\n    # Apply decision rules\n    smoothing_recommended = (f <= alpha and \n                             r_max_viol <= R_lim and \n                             q_min_viol >= delta and \n                             c_max < kappa)\n                             \n    refinement_recommended = not smoothing_recommended\n    \n    return [hist.tolist(), smoothing_recommended, refinement_recommended]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}