{
    "hands_on_practices": [
        {
            "introduction": "The latitude-longitude grid is the most intuitive framework for discretizing the Earth's surface, yet its apparent simplicity conceals significant geometric distortions that have profound implications for global models. This exercise  invites you to explore the fundamental differential geometry of this coordinate system by deriving the properties of its basis vectors. By understanding how and why grid cells change their shape and area with latitude, you will grasp the origin of the numerical challenges—most notably the \"pole problem\"—that have driven the development of more advanced global gridding strategies.",
            "id": "3810984",
            "problem": "Consider the two-dimensional unit sphere embedded in three-dimensional Euclidean space, denoted by $S^2 \\subset \\mathbb{R}^3$, but with a general constant radius $a>0$ appropriate for a spherical Earth approximation. Use the standard geographic parameterization in terms of longitude $\\lambda \\in (-\\pi,\\pi]$ and latitude $\\phi \\in \\left[-\\frac{\\pi}{2},\\frac{\\pi}{2}\\right]$, both measured in radians, given by the smooth map $\\mathbf{x} : (-\\pi,\\pi] \\times \\left[-\\frac{\\pi}{2},\\frac{\\pi}{2}\\right] \\to \\mathbb{R}^3$ defined by\n$$\n\\mathbf{x}(\\lambda,\\phi) \\;=\\; \\big(a \\cos\\phi \\cos\\lambda,\\; a \\cos\\phi \\sin\\lambda,\\; a \\sin\\phi\\big).\n$$\nIn computational oceanography and global General Circulation Model (GCM) grids, the coordinate lines of constant $\\lambda$ (meridians) and constant $\\phi$ (parallels) are used to define grid cells. Starting only from the above parameterization, the Euclidean inner product in $\\mathbb{R}^3$, and the definition of coordinate basis vectors $\\partial_{\\lambda}\\mathbf{x}$ and $\\partial_{\\phi}\\mathbf{x}$ on a parameterized surface, do the following:\n\n1. Show that the coordinate basis vectors $\\partial_{\\lambda}\\mathbf{x}$ and $\\partial_{\\phi}\\mathbf{x}$ are orthogonal at every point of $S^2$.\n2. Compute the norms $|\\partial_{\\lambda}\\mathbf{x}|$ and $|\\partial_{\\phi}\\mathbf{x}|$ as functions of $a$ and $\\phi$.\n3. Using the fundamental notion of the first fundamental form (metric induced from $\\mathbb{R}^3$) and the definition of infinitesimal lengths and areas on parameterized surfaces, derive the differential area element $\\mathrm{d}A$ in terms of $\\lambda$ and $\\phi$, and then obtain the aspect ratio $R(\\phi)$ of an infinitesimal grid cell aligned with the coordinate lines when $\\mathrm{d}\\lambda=\\mathrm{d}\\phi$, defined by\n$$\nR(\\phi) \\;=\\; \\frac{|\\partial_{\\lambda}\\mathbf{x}|}{|\\partial_{\\phi}\\mathbf{x}|}.\n$$\nExplain briefly the consequences of these results for grid cell shapes and areas at different latitudes in an equiangular latitude–longitude grid used by global ocean models.\n\nProvide, as your final answer, the closed-form analytic expressions for the triple $\\big(|\\partial_{\\lambda}\\mathbf{x}|,\\; |\\partial_{\\phi}\\mathbf{x}|,\\; R(\\phi)\\big)$. No numerical evaluation is required.",
            "solution": "The problem statement passes all validation criteria. It is scientifically sound, well-posed, objective, and contains all necessary information for a unique and meaningful solution. The problem is a standard exercise in the differential geometry of surfaces, directly applicable to the field of computational oceanography and global climate modeling.\n\nWe begin by addressing the tasks outlined in the problem. The surface is a sphere of radius $a > 0$ parameterized by longitude $\\lambda$ and latitude $\\phi$ as:\n$$\n\\mathbf{x}(\\lambda,\\phi) \\;=\\; \\big(a \\cos\\phi \\cos\\lambda,\\; a \\cos\\phi \\sin\\lambda,\\; a \\sin\\phi\\big)\n$$\n\nThe coordinate basis vectors are the partial derivatives of the position vector $\\mathbf{x}$ with respect to the parameters $\\lambda$ and $\\phi$.\n\nFirst, we compute the basis vector associated with the longitude coordinate, $\\partial_{\\lambda}\\mathbf{x}$:\n$$\n\\partial_{\\lambda}\\mathbf{x} = \\frac{\\partial \\mathbf{x}}{\\partial \\lambda} = \\frac{\\partial}{\\partial \\lambda} \\big(a \\cos\\phi \\cos\\lambda,\\; a \\cos\\phi \\sin\\lambda,\\; a \\sin\\phi\\big) = \\big(-a \\cos\\phi \\sin\\lambda,\\; a \\cos\\phi \\cos\\lambda,\\; 0\\big)\n$$\n\nNext, we compute the basis vector associated with the latitude coordinate, $\\partial_{\\phi}\\mathbf{x}$:\n$$\n\\partial_{\\phi}\\mathbf{x} = \\frac{\\partial \\mathbf{x}}{\\partial \\phi} = \\frac{\\partial}{\\partial \\phi} \\big(a \\cos\\phi \\cos\\lambda,\\; a \\cos\\phi \\sin\\lambda,\\; a \\sin\\phi\\big) = \\big(-a \\sin\\phi \\cos\\lambda,\\; -a \\sin\\phi \\sin\\lambda,\\; a \\cos\\phi\\big)\n$$\n\n**1. Show that the coordinate basis vectors are orthogonal.**\n\nTo show that $\\partial_{\\lambda}\\mathbf{x}$ and $\\partial_{\\phi}\\mathbf{x}$ are orthogonal, we compute their Euclidean inner product (dot product) in $\\mathbb{R}^3$ and show that it is zero for all $(\\lambda, \\phi)$.\n$$\n\\partial_{\\lambda}\\mathbf{x} \\cdot \\partial_{\\phi}\\mathbf{x} = \\big(-a \\cos\\phi \\sin\\lambda\\big)\\big(-a \\sin\\phi \\cos\\lambda\\big) + \\big(a \\cos\\phi \\cos\\lambda\\big)\\big(-a \\sin\\phi \\sin\\lambda\\big) + \\big(0\\big)\\big(a \\cos\\phi\\big)\n$$\n$$\n= a^2 \\cos\\phi \\sin\\phi \\sin\\lambda \\cos\\lambda - a^2 \\cos\\phi \\sin\\phi \\cos\\lambda \\sin\\lambda + 0\n$$\n$$\n= 0\n$$\nSince the inner product is zero, the vectors $\\partial_{\\lambda}\\mathbf{x}$ and $\\partial_{\\phi}\\mathbf{x}$ are orthogonal at every point on the sphere where the parameterization is defined. This means that the meridians (lines of constant $\\lambda$) and parallels (lines of constant $\\phi$) are perpendicular to each other.\n\n**2. Compute the norms $|\\partial_{\\lambda}\\mathbf{x}|$ and $|\\partial_{\\phi}\\mathbf{x}|$.**\n\nThe norm of a vector is the square root of its inner product with itself.\nFor $\\partial_{\\lambda}\\mathbf{x}$:\n$$\n|\\partial_{\\lambda}\\mathbf{x}|^2 = \\partial_{\\lambda}\\mathbf{x} \\cdot \\partial_{\\lambda}\\mathbf{x} = (-a \\cos\\phi \\sin\\lambda)^2 + (a \\cos\\phi \\cos\\lambda)^2 + 0^2\n$$\n$$\n= a^2 \\cos^2\\phi \\sin^2\\lambda + a^2 \\cos^2\\phi \\cos^2\\lambda\n$$\n$$\n= a^2 \\cos^2\\phi (\\sin^2\\lambda + \\cos^2\\lambda) = a^2 \\cos^2\\phi\n$$\nTaking the square root, we get the norm:\n$$\n|\\partial_{\\lambda}\\mathbf{x}| = \\sqrt{a^2 \\cos^2\\phi} = |a \\cos\\phi|\n$$\nSince $a > 0$ and the latitude $\\phi$ is in the range $\\left[-\\frac{\\pi}{2}, \\frac{\\pi}{2}\\right]$, $\\cos\\phi \\ge 0$. Therefore, $|a \\cos\\phi| = a \\cos\\phi$.\n$$\n|\\partial_{\\lambda}\\mathbf{x}| = a \\cos\\phi\n$$\nFor $\\partial_{\\phi}\\mathbf{x}$:\n$$\n|\\partial_{\\phi}\\mathbf{x}|^2 = \\partial_{\\phi}\\mathbf{x} \\cdot \\partial_{\\phi}\\mathbf{x} = (-a \\sin\\phi \\cos\\lambda)^2 + (-a \\sin\\phi \\sin\\lambda)^2 + (a \\cos\\phi)^2\n$$\n$$\n= a^2 \\sin^2\\phi \\cos^2\\lambda + a^2 \\sin^2\\phi \\sin^2\\lambda + a^2 \\cos^2\\phi\n$$\n$$\n= a^2 \\sin^2\\phi (\\cos^2\\lambda + \\sin^2\\lambda) + a^2 \\cos^2\\phi\n$$\n$$\n= a^2 \\sin^2\\phi + a^2 \\cos^2\\phi = a^2 (\\sin^2\\phi + \\cos^2\\phi) = a^2\n$$\nTaking the square root, we get the norm:\n$$\n|\\partial_{\\phi}\\mathbf{x}| = \\sqrt{a^2} = a\n$$\n\n**3. Derive the differential area element $\\mathrm{d}A$ and the aspect ratio $R(\\phi)$.**\n\nThe differential area element $\\mathrm{d}A$ on a parameterized surface is given in terms of the first fundamental form. The coefficients of the first fundamental form are $g_{\\lambda\\lambda} = |\\partial_{\\lambda}\\mathbf{x}|^2$, $g_{\\phi\\phi} = |\\partial_{\\phi}\\mathbf{x}|^2$, and $g_{\\lambda\\phi} = \\partial_{\\lambda}\\mathbf{x} \\cdot \\partial_{\\phi}\\mathbf{x}$. From our previous calculations, we have:\n$$\ng_{\\lambda\\lambda} = a^2 \\cos^2\\phi, \\quad g_{\\phi\\phi} = a^2, \\quad g_{\\lambda\\phi} = g_{\\phi\\lambda} = 0\n$$\nThe area element is $\\mathrm{d}A = \\sqrt{\\det(g)} \\, \\mathrm{d}\\lambda \\, \\mathrm{d}\\phi$, where $g$ is the matrix of the coefficients.\n$$\n\\det(g) = g_{\\lambda\\lambda}g_{\\phi\\phi} - g_{\\lambda\\phi}^2 = (a^2 \\cos^2\\phi)(a^2) - 0^2 = a^4 \\cos^2\\phi\n$$\n$$\n\\sqrt{\\det(g)} = \\sqrt{a^4 \\cos^2\\phi} = a^2 |\\cos\\phi| = a^2 \\cos\\phi \\quad (\\text{since } \\cos\\phi \\ge 0)\n$$\nThus, the differential area element is:\n$$\n\\mathrm{d}A = a^2 \\cos\\phi \\, \\mathrm{d}\\lambda \\, \\mathrm{d}\\phi\n$$\nThe aspect ratio $R(\\phi)$ of an infinitesimal grid cell with $\\mathrm{d}\\lambda = \\mathrm{d}\\phi$ is defined as the ratio of the physical length of the side in the $\\lambda$ direction to the physical length of the side in the $\\phi$ direction. These lengths are $\\mathrm{d}s_\\lambda = |\\partial_{\\lambda}\\mathbf{x}|\\mathrm{d}\\lambda$ and $\\mathrm{d}s_\\phi = |\\partial_{\\phi}\\mathbf{x}|\\mathrm{d}\\phi$.\nThe problem defines the aspect ratio as:\n$$\nR(\\phi) = \\frac{|\\partial_{\\lambda}\\mathbf{x}|}{|\\partial_{\\phi}\\mathbf{x}|} = \\frac{a \\cos\\phi}{a} = \\cos\\phi\n$$\n\n**Consequences for equiangular latitude-longitude grids:**\n\nIn an equiangular grid, the increments $\\Delta\\lambda$ and $\\Delta\\phi$ are constant.\nThe physical length of a grid cell in the north-south (meridional) direction is approximately $\\Delta s_\\phi = |\\partial_{\\phi}\\mathbf{x}| \\Delta\\phi = a \\Delta\\phi$. This length is constant, independent of latitude.\nThe physical length of a grid cell in the east-west (zonal) direction is approximately $\\Delta s_\\lambda = |\\partial_{\\lambda}\\mathbf{x}| \\Delta\\lambda = a \\cos\\phi \\Delta\\lambda$. This length varies with the cosine of the latitude.\nThe aspect ratio of the cells, $R(\\phi) = \\cos\\phi$, quantifies their shape. At the equator ($\\phi=0$), $R(0)=1$, and the grid cells are approximately squares (for $\\Delta\\lambda \\approx \\Delta\\phi$). As one moves towards the poles ($\\phi \\to \\pm \\frac{\\pi}{2}$), $R(\\phi) \\to 0$, and the cells become increasingly narrow and elongated in the north-south direction, converging to a point at the pole.\nThe area of a grid cell, $\\Delta A \\approx a^2 \\cos\\phi \\Delta\\lambda \\Delta\\phi$, is also latitude-dependent. It is maximal at the equator and shrinks to zero at the poles. This \"pole problem\" has severe consequences for numerical models. The convergence of meridians requires the time step in explicit numerical schemes to be drastically reduced to satisfy stability criteria (like the CFL condition) due to the vanishingly small zonal grid spacing near the poles, rendering the model computationally infeasible. This necessitates the use of special filters or alternative grid systems (e.g., cubed-sphere or icosahedral grids) in modern GCMs.\n\nThe derived triple $(|\\partial_{\\lambda}\\mathbf{x}|, |\\partial_{\\phi}\\mathbf{x}|, R(\\phi))$ is therefore $(a \\cos\\phi, a, \\cos\\phi)$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} a \\cos\\phi & a & \\cos\\phi \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "After analyzing the static grid, we now turn our attention to paths and motion on the sphere. While a straight line defines the shortest path on a flat plane, the equivalent concept on a curved surface is a geodesic—a path with zero intrinsic curvature. This practice  formalizes this crucial idea by tasking you with calculating the geodesic curvature of a parallel of latitude, thereby proving that these coordinate lines are not geodesics (with the sole exception of the equator). Mastering this distinction is vital for correctly modeling transport phenomena, wave propagation, and the trajectories of ocean drifters in a global context.",
            "id": "3810962",
            "problem": "Global ocean circulation models frequently employ latitude–longitude grids, in which computational grid lines coincide with lines of constant latitude on a spherical Earth idealized as a perfect sphere of radius $R$. In spherical geometry, a geodesic on a surface is defined as a curve whose geodesic curvature is zero everywhere along the curve. Consider the parallel (line of constant latitude) at latitude $\\phi$ (measured from the equator, positive in the Northern Hemisphere), parametrized by longitude $\\lambda$. Using only the definitions of geodesic curvature, the decomposition of a curve’s curvature into components normal to the surface and tangent to the surface, and well-tested facts about the sphere, derive an explicit symbolic expression for the signed geodesic curvature $k_{g}(\\phi)$ of the parallel and the line-integral $\\oint k_{g}\\,\\mathrm{d}s$ taken once around the parallel. Use the convention that $k_{g}(\\phi)>0$ when the curve turns left with respect to increasing $\\lambda$ in the Northern Hemisphere.\n\nAssume $R$ is given in meters so that $k_{g}(\\phi)$ carries units of inverse meters, and interpret the integral $\\oint k_{g}\\,\\mathrm{d}s$ as a dimensionless turning angle in radians. Express both results purely in terms of $R$ and $\\phi$. Angles must be in radians. Do not round; provide exact symbolic expressions. Report your final answer as a two-entry row vector $\\big(k_{g}(\\phi),\\ \\oint k_{g}\\,\\mathrm{d}s\\big)$.",
            "solution": "The user wants to solve a problem from computational oceanography requiring the derivation of the geodesic curvature of a line of constant latitude and the line integral of this curvature around the latitude line.\n\n### Step 1: Extract Givens\n- Surface: A perfect sphere of radius $R$.\n- Curve: A parallel, which is a line of constant latitude $\\phi$. Latitude is measured from the equator ($-\\pi/2 \\le \\phi \\le \\pi/2$), positive in the Northern Hemisphere.\n- Coordinate: Longitude $\\lambda$ parametrizes the curve.\n- Definition: A geodesic is a curve with zero geodesic curvature.\n- Principle: The curvature of a curve on a surface can be decomposed into normal and tangential components.\n- Convention: The signed geodesic curvature $k_g(\\phi) > 0$ when the curve turns left with respect to increasing $\\lambda$ in the Northern Hemisphere.\n- Required outputs: An explicit symbolic expression for the signed geodesic curvature $k_g(\\phi)$ and the line integral $\\oint k_g \\, ds$ taken once around the parallel.\n- Variables for expression: The results must be in terms of $R$ and $\\phi$.\n- Units: $R$ is in meters, $k_g(\\phi)$ is in inverse meters, and $\\oint k_g \\, ds$ is a dimensionless angle in radians.\n- Final format: A two-entry row vector $\\big(k_{g}(\\phi),\\ \\oint k_{g}\\,\\mathrm{d}s\\big)$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is a standard exercise in the differential geometry of surfaces, a core mathematical tool in fields like geodesy, general relativity, and, as stated, computational modeling of geophysical fluids on a sphere. All concepts (sphere, latitude, geodesic curvature, line integral) are well-established in mathematics and physics. The setup is scientifically and factually sound.\n- **Well-Posed**: The problem is clearly defined. The geometry, the curve, and the quantities to be derived are specified. The sign convention removes ambiguity. A unique, stable, and meaningful solution is expected to exist.\n- **Objective**: The language is precise and objective. There are no subjective or opinion-based statements.\n\nThe problem is free of any of the invalidating flaws. It is scientifically sound, well-posed, and objective. It is also directly relevant to the specified topic.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\n### Derivation\nThe solution proceeds by applying the fundamental principles of differential geometry to the specified curve on the spherical surface. The core strategy is to decompose the three-dimensional curvature of the parallel into two orthogonal components: one normal to the spherical surface ($\\kappa_n$, the normal curvature) and one tangential to the surface ($\\vec{\\kappa}_g$, the geodesic curvature vector). The signed geodesic curvature $k_g$ is the magnitude of $\\vec{\\kappa}_g$ with the appropriate sign.\n\nLet the sphere be centered at the origin of a Cartesian coordinate system. A point on the sphere of radius $R$ can be described by its latitude $\\phi$ and longitude $\\lambda$. The corresponding Cartesian coordinates $(x,y,z)$ are:\n$$\n\\vec{p}(\\lambda, \\phi) = (R\\cos\\phi\\cos\\lambda, R\\cos\\phi\\sin\\lambda, R\\sin\\phi)\n$$\nA parallel is a curve of constant latitude $\\phi$. We can parametrize this curve by the longitude $\\lambda$:\n$$\n\\vec{r}(\\lambda) = (R\\cos\\phi\\cos\\lambda, R\\cos\\phi\\sin\\lambda, R\\sin\\phi)\n$$\nThis curve is a circle in three-dimensional space. It lies in the horizontal plane $z = R\\sin\\phi$ and its center is at $(0, 0, R\\sin\\phi)$. The radius of this circle is $r = R\\cos\\phi$.\n\nThe curvature $\\kappa$ of a circle of radius $r$ is given by $\\kappa = 1/r$. Therefore, the curvature of the parallel is:\n$$\n\\kappa = \\frac{1}{R\\cos\\phi}\n$$\nThe curvature vector of the curve, $\\vec{\\kappa}$, is related to the acceleration vector. It can be decomposed as $\\vec{\\kappa} = \\kappa_n \\hat{n} + \\vec{\\kappa}_g$, where $\\hat{n}$ is the unit normal to the surface and $\\vec{\\kappa}_g$ is the geodesic curvature vector, which lies in the tangent plane of the surface. The magnitudes are related by the Pythagorean theorem: $\\kappa^2 = \\kappa_n^2 + k_g^2$, where $k_g = |\\vec{\\kappa}_g|$.\n\nTo find $k_g$, we first determine the normal curvature, $\\kappa_n$. According to Meusnier's theorem, $\\kappa_n = \\kappa \\cos\\alpha$, where $\\alpha$ is the angle between the principal normal of the curve, $\\vec{N}$, and the surface normal, $\\hat{n}$.\n\n$1.$ The surface normal vector $\\hat{n}$ for a sphere is simply the normalized position vector, pointing radially outward:\n$$\n\\hat{n} = \\frac{\\vec{p}}{R} = (\\cos\\phi\\cos\\lambda, \\cos\\phi\\sin\\lambda, \\sin\\phi)\n$$\n$2.$ The principal normal vector $\\vec{N}$ of the curve (the parallel) points from the curve towards the center of its osculating circle. Since the parallel is a circle in a horizontal plane, $\\vec{N}$ is a horizontal vector pointing towards the $z$-axis. At a point given by $\\lambda$, this vector is:\n$$\n\\vec{N} = (-\\cos\\lambda, -\\sin\\lambda, 0)\n$$\n$3.$ The angle $\\alpha$ between $\\hat{n}$ and $\\vec{N}$ is found from their dot product:\n$$\n\\cos\\alpha = \\hat{n} \\cdot \\vec{N} = (\\cos\\phi\\cos\\lambda)(-\\cos\\lambda) + (\\cos\\phi\\sin\\lambda)(-\\sin\\lambda) + (\\sin\\phi)(0)\n$$\n$$\n\\cos\\alpha = -\\cos\\phi\\cos^2\\lambda - \\cos\\phi\\sin^2\\lambda = -\\cos\\phi(\\cos^2\\lambda + \\sin^2\\lambda) = -\\cos\\phi\n$$\nNow, we can compute the normal curvature $\\kappa_n$:\n$$\n\\kappa_n = \\kappa \\cos\\alpha = \\left(\\frac{1}{R\\cos\\phi}\\right)(-\\cos\\phi) = -\\frac{1}{R}\n$$\nThis result is constant for any curve on a sphere, as the normal section at any point is always a great circle of curvature $1/R$.\n\nNow we find the magnitude of the geodesic curvature using $\\kappa^2 = \\kappa_n^2 + k_g^2$:\n$$\nk_g^2 = \\kappa^2 - \\kappa_n^2 = \\left(\\frac{1}{R\\cos\\phi}\\right)^2 - \\left(-\\frac{1}{R}\\right)^2 = \\frac{1}{R^2\\cos^2\\phi} - \\frac{1}{R^2}\n$$\n$$\nk_g^2 = \\frac{1 - \\cos^2\\phi}{R^2\\cos^2\\phi} = \\frac{\\sin^2\\phi}{R^2\\cos^2\\phi} = \\frac{\\tan^2\\phi}{R^2}\n$$\nTaking the square root gives the magnitude:\n$$\n|k_g| = \\left|\\frac{\\tan\\phi}{R}\\right|\n$$\nTo determine the sign of $k_g(\\phi)$, we use the given convention. In the Northern Hemisphere ($0 < \\phi < \\pi/2$), a person traveling eastward (increasing $\\lambda$) along a parallel must continuously turn left to stay on the parallel, curving towards the North Pole. The convention states that this corresponds to $k_g > 0$. For $0 < \\phi < \\pi/2$, we have $\\tan\\phi > 0$. Therefore, the signed geodesic curvature is given by:\n$$\nk_g(\\phi) = \\frac{\\tan\\phi}{R}\n$$\nThis expression correctly gives $k_g = 0$ for the equator ($\\phi=0$), which is a geodesic. It also correctly gives $k_g < 0$ for the Southern Hemisphere ($\\phi<0$), where turning left (towards the South Pole) corresponds to a negative value for $\\tan\\phi$.\n\nNext, we compute the line integral $\\oint k_g \\, ds$ once around the parallel. The integrand $k_g(\\phi)$ is constant along this path, as $\\phi$ is constant. The integral is thus the product of $k_g(\\phi)$ and the total arc length $L$ of the parallel.\nThe arc length element is $ds$. From the parametrization, $\\frac{d\\vec{r}}{d\\lambda} = (-R\\cos\\phi\\sin\\lambda, R\\cos\\phi\\cos\\lambda, 0)$, and the magnitude is $|\\frac{d\\vec{r}}{d\\lambda}| = R\\cos\\phi$. So, $ds = R\\cos\\phi \\, d\\lambda$. The total length $L$ is found by integrating $ds$ as $\\lambda$ goes from $0$ to $2\\pi$:\n$$\nL = \\int_0^{2\\pi} R\\cos\\phi \\, d\\lambda = 2\\pi R\\cos\\phi\n$$\nThis is the circumference of the circle of radius $r=R\\cos\\phi$.\nThe line integral is:\n$$\n\\oint k_g(\\phi) \\, ds = k_g(\\phi) \\cdot L = \\left(\\frac{\\tan\\phi}{R}\\right) \\cdot (2\\pi R\\cos\\phi)\n$$\nSubstituting $\\tan\\phi = \\frac{\\sin\\phi}{\\cos\\phi}$:\n$$\n\\oint k_g(\\phi) \\, ds = \\left(\\frac{\\sin\\phi}{R\\cos\\phi}\\right) \\cdot (2\\pi R\\cos\\phi) = 2\\pi\\sin\\phi\n$$\nThis dimensionless quantity is the total geodesic turning, in radians, required to traverse the parallel. This result is consistent with the Gauss-Bonnet theorem applied to the spherical cap enclosed by the parallel.\n\nThe two requested quantities are $k_g(\\phi) = \\frac{\\tan\\phi}{R}$ and $\\oint k_g \\, ds = 2\\pi\\sin\\phi$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{\\tan(\\phi)}{R} & 2\\pi\\sin(\\phi) \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "While grid-point models represent fields at discrete locations, spectral models offer a powerful alternative by using a basis of functions that naturally incorporates the sphere's geometry. This approach is built upon spherical harmonics, which serve as the spherical analogue to the sines and cosines of a Fourier series. This final hands-on practice  is a quintessential computational exercise: you will implement a numerical spherical harmonic transform to analyze and reconstruct a field, a core task in spectral modeling. This will provide direct experience with the practical consequences of spectral truncation, a fundamental concept in numerical weather and ocean prediction.",
            "id": "3810986",
            "problem": "You are given a real scalar field on the sphere, denoted by $f(\\lambda,\\phi)$, where $\\lambda \\in [0,2\\pi)$ is longitude and $\\phi \\in [-\\pi/2,\\pi/2]$ is latitude. Let $\\theta \\in [0,\\pi]$ denote the colatitude such that $\\theta = \\frac{\\pi}{2} - \\phi$. Consider the complex spherical harmonics $Y_{\\ell}^{m}(\\lambda,\\theta)$ in the physics convention, which are orthonormal under the spherical surface measure. The spherical harmonics satisfy the orthonormality relation\n$$\n\\int_{0}^{2\\pi}\\int_{0}^{\\pi} Y_{\\ell}^{m}(\\lambda,\\theta)\\,Y_{\\ell'}^{m'}(\\lambda,\\theta)^{*}\\,\\sin\\theta\\,d\\theta\\,d\\lambda \\;=\\; \\delta_{\\ell\\ell'}\\,\\delta_{mm'} ,\n$$\nwhere $^{*}$ denotes complex conjugation and $\\delta$ denotes the Kronecker delta. The surface area measure can equivalently be written as $d\\Omega = d\\lambda\\,d\\mu$ with $\\mu = \\cos\\theta \\in [-1,1]$, using the identity $d\\mu = -\\sin\\theta\\,d\\theta$.\n\nStarting from the completeness of the spherical harmonics, any sufficiently smooth field $f(\\lambda,\\phi)$ admits the expansion\n$$\nf(\\lambda,\\phi) = \\sum_{\\ell=0}^{\\infty}\\sum_{m=-\\ell}^{\\ell} a_{\\ell m}\\,Y_{\\ell}^{m}(\\lambda,\\theta),\n$$\nwith complex coefficients given by the inner products\n$$\na_{\\ell m} \\;=\\; \\int_{0}^{2\\pi}\\int_{0}^{\\pi} f(\\lambda,\\phi)\\,Y_{\\ell}^{m}(\\lambda,\\theta)^{*}\\,\\sin\\theta\\,d\\theta\\,d\\lambda \\;=\\; \\int_{0}^{2\\pi}\\int_{-1}^{1} f(\\lambda,\\phi(\\mu))\\,Y_{\\ell}^{m}(\\lambda,\\theta(\\mu))^{*}\\,d\\mu\\,d\\lambda .\n$$\n\nYour task is to design a program that:\n- Computes the truncated spherical harmonic coefficients $a_{\\ell m}$ for $0 \\le \\ell \\le L_{\\max}$ and $-\\ell \\le m \\le \\ell$ using numerical quadrature to approximate the inner products,\n- Reconstructs the truncated field\n$$\nf_{L_{\\max}}(\\lambda,\\phi) \\;=\\; \\sum_{\\ell=0}^{L_{\\max}}\\sum_{m=-\\ell}^{\\ell} a_{\\ell m}\\,Y_{\\ell}^{m}(\\lambda,\\theta),\n$$\n- Evaluates the truncation error using the relative $L_{2}$ norm\n$$\n\\varepsilon(L_{\\max}) \\;=\\; \\frac{\\left\\| f - f_{L_{\\max}} \\right\\|_{L_{2}}}{\\left\\| f \\right\\|_{L_{2}}}, \\quad \\text{where } \\left\\| g \\right\\|_{L_{2}}^{2} = \\int_{0}^{2\\pi}\\int_{-1}^{1} |g(\\lambda,\\phi(\\mu))|^{2}\\,d\\mu\\,d\\lambda .\n$$\n\nUse Gauss–Legendre quadrature with $N_{\\theta}$ points to approximate the integral over $\\mu \\in [-1,1]$ and the trapezoidal (uniform) rule with $N_{\\lambda}$ points for the integral over $\\lambda \\in [0,2\\pi)$. Angles must be in radians. Adopt the physics convention for spherical harmonics and ensure consistency with the stated orthonormality.\n\nImplement the following test suite (all angles in radians, and the outputs are dimensionless floats):\n- Test case $1$: $f(\\lambda,\\phi) = \\operatorname{Re}\\{Y_{8}^{3}(\\lambda,\\theta)\\}$ with $L_{\\max} = 8$, using $N_{\\lambda} = 256$ and $N_{\\theta} = 128$.\n- Test case $2$: $f(\\lambda,\\phi) = \\exp\\!\\left(0.25\\,\\sin\\phi\\right)\\,\\cos(7\\lambda)$ with $L_{\\max} = 12$, using $N_{\\lambda} = 256$ and $N_{\\theta} = 128$.\n- Test case $3$: $f(\\lambda,\\phi) = 1 + 0.1\\,\\sin(2\\phi)\\,\\cos(3\\lambda)$ with $L_{\\max} = 3$, using $N_{\\lambda} = 256$ and $N_{\\theta} = 128$.\n- Test case $4$: $f(\\lambda,\\phi) = 1 + 0.1\\,\\sin(2\\phi)\\,\\cos(3\\lambda)$ with $L_{\\max} = 0$, using $N_{\\lambda} = 256$ and $N_{\\theta} = 128$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_{1},r_{2},r_{3},r_{4}]$), where $r_{k}$ is the relative $L_{2}$ truncation error $\\varepsilon(L_{\\max})$ for test case $k$. All calculations must use radians. No physical units are involved; report each $r_{k}$ as a floating-point number.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the well-established theory of spherical harmonics, a fundamental tool in mathematical physics and geosciences. The problem is well-posed, providing a complete and consistent set of definitions, parameters, and objectives. All terms are mathematically precise, and the task—to implement a numerical spherical harmonic transform and evaluate its truncation error—is a standard and meaningful problem in computational science. The provided test cases are suitable for verifying the correctness of the implementation.\n\nThe solution is developed in three stages: first, outlining the theoretical framework of spherical harmonic transforms; second, detailing the numerical discretization of the continuous theory; and third, specifying the algorithm for computation.\n\nA scalar field $f(\\lambda, \\phi)$ on the surface of a sphere can be represented as an infinite series of complex spherical harmonics $Y_{\\ell}^{m}(\\lambda, \\theta)$, where $\\lambda \\in [0, 2\\pi)$ is longitude, $\\phi \\in [-\\pi/2, \\pi/2]$ is latitude, and $\\theta = \\pi/2 - \\phi \\in [0, \\pi]$ is the colatitude. This expansion is given by:\n$$\nf(\\lambda,\\phi) = \\sum_{\\ell=0}^{\\infty}\\sum_{m=-\\ell}^{\\ell} a_{\\ell m}\\,Y_{\\ell}^{m}(\\lambda,\\theta)\n$$\nThe functions $Y_{\\ell}^{m}(\\lambda, \\theta)$ form an orthonormal basis on the sphere with respect to the surface area measure $d\\Omega = \\sin\\theta\\,d\\theta\\,d\\lambda$. The orthonormality property is:\n$$\n\\int_{0}^{2\\pi}\\int_{0}^{\\pi} Y_{\\ell}^{m}(\\lambda,\\theta)\\,Y_{\\ell'}^{m'}(\\lambda,\\theta)^{*}\\,\\sin\\theta\\,d\\theta\\,d\\lambda \\;=\\; \\delta_{\\ell\\ell'}\\,\\delta_{mm'}\n$$\nwhere $^{*}$ denotes complex conjugation and $\\delta$ is the Kronecker delta. This property allows the complex coefficients $a_{\\ell m}$ to be determined via an inner product (projection):\n$$\na_{\\ell m} \\;=\\; \\langle f, Y_{\\ell}^{m} \\rangle \\;=\\; \\int_{0}^{2\\pi}\\int_{0}^{\\pi} f(\\lambda,\\phi)\\,Y_{\\ell}^{m}(\\lambda,\\theta)^{*}\\,\\sin\\theta\\,d\\theta\\,d\\lambda\n$$\nFor practical computation, the infinite series must be truncated at a maximum degree $L_{\\max}$, resulting in an approximation $f_{L_{\\max}}$:\n$$\nf_{L_{\\max}}(\\lambda,\\phi) \\;=\\; \\sum_{\\ell=0}^{L_{\\max}}\\sum_{m=-\\ell}^{\\ell} a_{\\ell m}\\,Y_{\\ell}^{m}(\\lambda,\\theta)\n$$\nThe error of this truncation is quantified by the relative $L_{2}$ norm, $\\varepsilon(L_{\\max})$, defined as the ratio of the norm of the residual to the norm of the original field:\n$$\n\\varepsilon(L_{\\max}) \\;=\\; \\frac{\\left\\| f - f_{L_{\\max}} \\right\\|_{L_{2}}}{\\left\\| f \\right\\|_{L_{2}}}\n$$\nThe squared $L_2$ norm of a function $g$ is given by the integral of its squared magnitude over the sphere:\n$$\n\\left\\| g \\right\\|_{L_{2}}^{2} = \\int_{S^2} |g|^2 \\,d\\Omega = \\int_{0}^{2\\pi}\\int_{0}^{\\pi} |g(\\lambda,\\theta)|^{2}\\,\\sin\\theta\\,d\\theta\\,d\\lambda\n$$\nThis can be written using $\\mu = \\cos\\theta \\in [-1, 1]$ and $d\\mu = -\\sin\\theta\\,d\\theta$ as:\n$$\n\\left\\| g \\right\\|_{L_{2}}^{2} = \\int_{0}^{2\\pi}\\int_{-1}^{1} |g(\\lambda,\\theta(\\mu))|^{2}\\,d\\mu\\,d\\lambda\n$$\nTo compute the coefficients and norms, we must numerically approximate these integrals. The problem specifies a product quadrature rule. The integral over longitude $\\lambda \\in [0, 2\\pi)$ is approximated using the trapezoidal rule on a uniform grid of $N_{\\lambda}$ points, $\\lambda_j = j \\frac{2\\pi}{N_\\lambda}$ for $j=0, \\dots, N_\\lambda-1$. For a periodic function, this is equivalent to a rectangular rule with weights $w_j^{\\lambda} = \\frac{2\\pi}{N_{\\lambda}}$. The integral over $\\mu \\in [-1, 1]$ is approximated using Gauss-Legendre quadrature with $N_{\\theta}$ points $\\mu_k$ and corresponding weights $w_k^{\\mu}$. The colatitude points are then $\\theta_k = \\arccos(\\mu_k)$.\n\nThe discrete approximation for the coefficient $a_{\\ell m}$ is therefore a weighted sum:\n$$\na_{\\ell m} \\approx \\sum_{k=0}^{N_{\\theta}-1} \\sum_{j=0}^{N_{\\lambda}-1} f(\\lambda_j, \\theta_k) \\, Y_{\\ell}^{m}(\\lambda_j, \\theta_k)^{*} \\, w_k^{\\mu} \\left(\\frac{2\\pi}{N_{\\lambda}}\\right)\n$$\nSimilarly, the squared $L_2$ norm of a function $g$ evaluated on the grid is:\n$$\n\\|g\\|_{L_2}^2 \\approx \\sum_{k=0}^{N_{\\theta}-1} \\sum_{j=0}^{N_{\\lambda}-1} |g(\\lambda_j, \\theta_k)|^2 \\, w_k^{\\mu} \\left(\\frac{2\\pi}{N_{\\lambda}}\\right)\n$$\n\nThe overall algorithm proceeds as follows:\n1.  **Grid and Weight Generation**: For given $N_{\\lambda}$ and $N_{\\theta}$, generate the longitude points $\\lambda_j$ and constant weight $w^{\\lambda} = 2\\pi/N_{\\lambda}$. Generate the Gauss-Legendre points $\\mu_k$ and weights $w_k^{\\mu}$, and from them the colatitude points $\\theta_k$. Construct a 2D grid of $(\\lambda_j, \\theta_k)$ points.\n2.  **Field Evaluation**: Evaluate the given function $f(\\lambda,\\phi(\\theta))$ on the 2D grid, producing a matrix of field values $f_{jk} = f(\\lambda_j, \\theta_k)$.\n3.  **Spectral Analysis (Forward Transform)**: For each degree $\\ell$ from $0$ to $L_{\\max}$ and each order $m$ from $-\\ell$ to $\\ell$, compute the coefficient $a_{\\ell m}$ using the discrete summation formula above. This involves evaluating $Y_{\\ell}^{m}(\\lambda_j, \\theta_k)^{*}$ on the grid.\n4.  **Field Reconstruction (Inverse Transform)**: Reconstruct the truncated field $f_{L_{\\max}}$ on the same grid. Initialize a grid of zeros, then for each $(\\ell, m)$ pair, add the contribution $a_{\\ell m} Y_{\\ell}^{m}(\\lambda_j, \\theta_k)$ to the grid.\n5.  **Error Calculation**: Calculate the difference between the original field grid and the reconstructed field grid, $d_{jk} = f_{jk} - (f_{L_{\\max}})_{jk}$. Compute the squared norms $\\|f - f_{L_{\\max}}\\|_{L_2}^2$ and $\\|f\\|_{L_2}^2$ using the discrete norm formula. The desired error $\\varepsilon(L_{\\max})$ is the square root of their ratio.\n\nFor Test Case $1$, $f(\\lambda, \\phi) = \\operatorname{Re}\\{Y_8^3(\\lambda, \\theta)\\} = \\frac{1}{2}(Y_8^3 - Y_8^{-3})$. Since $L_{\\max}=8$, the truncated series includes all non-zero spectral components of the exact field. Therefore, the reconstruction should be exact, and the numerical error $\\varepsilon(8)$ is expected to be close to machine precision, limited only by the accuracy of the quadrature and floating-point arithmetic. With $N_\\lambda=256$ and $N_\\theta=128$, the quadrature is highly accurate for this function.\n\nFor Test Case $4$, where $f(\\lambda,\\phi) = 1 + 0.1\\,\\sin(2\\phi)\\,\\cos(3\\lambda)$ and $L_{\\max}=0$, the reconstruction is $f_0 = a_{00}Y_0^0$. Since $Y_0^0=1/\\sqrt{4\\pi}$ is a constant, $f_0$ is the mean value of $f$ over the sphere. The integral of the term $\\sin(2\\phi)\\cos(3\\lambda)$ is zero, so the mean of $f$ is $1$. Thus, $f_0=1$. The error calculation simplifies to $\\varepsilon(0) = \\|0.1\\sin(2\\phi)\\cos(3\\lambda)\\|_{L_2} / \\|1 + 0.1\\sin(2\\phi)\\cos(3\\lambda)\\|_{L_2}$, for which an analytical value of $\\sqrt{0.16 / 60.16} \\approx 0.05157$ can be derived, serving as a validation point for the numerical implementation.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import sph_harm\n\ndef calculate_error(f, L_max, N_lambda, N_theta):\n    \"\"\"\n    Computes the relative L2 truncation error for a spherical harmonic expansion.\n\n    Args:\n        f (callable): The scalar field f(lambda, theta) to analyze.\n        L_max (int): The maximum degree of the spherical harmonic expansion.\n        N_lambda (int): The number of points for the longitude grid.\n        N_theta (int): The number of points for the colatitude grid (Gauss-Legendre nodes).\n\n    Returns:\n        float: The relative L2 truncation error epsilon(L_max).\n    \"\"\"\n    \n    # 1. Grid and Weight Generation\n    # Longitude grid (uniform trapezoidal -> rectangular for periodic)\n    lambda_pts = np.linspace(0, 2 * np.pi, N_lambda, endpoint=False)\n    lambda_w = 2 * np.pi / N_lambda\n\n    # Colatitude grid (Gauss-Legendre)\n    mu_pts, mu_w = np.polynomial.legendre.leggauss(N_theta) # mu = cos(theta) in [-1, 1]\n    theta_pts = np.arccos(mu_pts) # theta in [0, pi], sorted descending\n    # The default order from leggauss is ascending mu, so theta is descending. \n    # This is fine, we just need to be consistent.\n\n    # 2D meshgrid for vectorized calculations\n    # meshgrid creates coordinates with 'ij' indexing.\n    # lambda_grid shape: (N_theta, N_lambda)\n    # theta_grid shape: (N_theta, N_lambda)\n    lambda_grid, theta_grid = np.meshgrid(lambda_pts, theta_pts)\n\n    # 2. Field Evaluation\n    f_grid = f(lambda_grid, theta_grid)\n\n    # 3. Spectral Analysis (Forward Transform)\n    coeffs = {}\n    for l in range(L_max + 1):\n        for m in range(-l, l + 1):\n            # Evaluate Y_lm^* on the grid\n            Ylm_conj = np.conj(sph_harm(m, l, lambda_grid, theta_grid))\n            \n            # Compute the integral for the coefficient a_lm\n            # Integrand = f * Y_lm^*\n            integrand = f_grid * Ylm_conj\n            \n            # Sum over grid points with weights\n            # mu_w is (N_theta,), needs to be (N_theta, 1) for broadcasting\n            # `lambda_w` is a scalar\n            a_lm = np.sum(integrand * mu_w[:, np.newaxis] * lambda_w)\n            coeffs[(l, m)] = a_lm\n\n    # 4. Field Reconstruction (Inverse Transform)\n    f_recon_grid = np.zeros_like(f_grid, dtype=np.complex128)\n    for l in range(L_max + 1):\n        for m in range(-l, l + 1):\n            # Evaluate Y_lm on the grid\n            Ylm = sph_harm(m, l, lambda_grid, theta_grid)\n            f_recon_grid += coeffs[(l, m)] * Ylm\n    \n    # If the original function is real, the reconstruction should also be real\n    # up to numerical noise.\n    if np.isrealobj(f_grid):\n        f_recon_grid = np.real(f_recon_grid)\n\n    # 5. Error Calculation\n    # Norm is sqrt(integral of |g|^2)\n    # The squared norm is the weighted sum of |g_grid|^2\n    \n    # a. Norm of the original function f\n    norm_f_sq = np.sum(np.abs(f_grid)**2 * mu_w[:, np.newaxis] * lambda_w)\n\n    # b. Norm of the truncation error f - f_Lmax\n    diff_grid = f_grid - f_recon_grid\n    norm_err_sq = np.sum(np.abs(diff_grid)**2 * mu_w[:, np.newaxis] * lambda_w)\n\n    # Avoid division by zero if the original function is identically zero\n    if norm_f_sq == 0:\n        return np.sqrt(norm_err_sq) if norm_err_sq > 0 else 0.0\n\n    return np.sqrt(norm_err_sq / norm_f_sq)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    # Note: problem statement defines f in terms of latitude phi, but gives colatitude\n    # theta for Y_lm. We must use theta consistently.\n    # theta = pi/2 - phi  =>  phi = pi/2 - theta\n    # sin(phi) = sin(pi/2 - theta) = cos(theta)\n    # sin(2*phi) = sin(pi - 2*theta) = sin(2*theta)\n    \n    # Define test functions f(lambda, theta)\n    def f1(lam, th):\n        return np.real(sph_harm(3, 8, lam, th))\n\n    def f2(lam, th):\n        return np.exp(0.25 * np.cos(th)) * np.cos(7 * lam)\n\n    def f3(lam, th):\n        return 1.0 + 0.1 * np.sin(2 * th) * np.cos(3 * lam)\n\n    test_cases = [\n        {'func': f1, 'L_max': 8, 'N_lambda': 256, 'N_theta': 128},\n        {'func': f2, 'L_max': 12, 'N_lambda': 256, 'N_theta': 128},\n        {'func': f3, 'L_max': 3, 'N_lambda': 256, 'N_theta': 128},\n        {'func': f3, 'L_max': 0, 'N_lambda': 256, 'N_theta': 128},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = calculate_error(case['func'], case['L_max'], case['N_lambda'], case['N_theta'])\n        results.append(f\"{error:.8g}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}