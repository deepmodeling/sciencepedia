{
    "hands_on_practices": [
        {
            "introduction": "在对海洋信号进行任何数值滤波之前，我们必须确保数据采集本身是准确无误的。此练习 () 探讨了数字信号处理中最基本的要求——奈奎斯特-香农采样定理 (Nyquist-Shannon sampling theorem)，并将其应用于一个关键的海洋学现象：惯性振荡。通过完成这项实践，您将学会推导避免混叠所需的最低采样频率，这是设计任何海洋学观测方案时至关重要的第一步。",
            "id": "3803618",
            "problem": "一个位于纬度 $\\phi=45^{\\circ}$ 的海洋系泊设备记录了水平流速，用于研究惯性振荡。在没有压力梯度和摩擦力的情况下，f平面上的水平动量方程由科里奥利加速度控制，其参数为 $f=2\\Omega\\sin\\phi$，其中 $\\Omega$ 是地球的自转速率。您的任务是设计采样策略，以确保后续的数值滤波不会因惯性频带混叠到较低频率而产生问题。\n\n从线性化的动量方程和角频率的定义出发，推导出为避免惯性振荡混叠所需的采样率 $f_{s}$（单位为赫兹，$\\mathrm{s}^{-1}$）的条件，然后利用 $\\Omega=7.2921159\\times 10^{-5}\\ \\mathrm{s}^{-1}$ 计算在 $\\phi=45^{\\circ}$ 时的最小 $f_{s}$。从第一性原理出发，明确引用奈奎斯特-香农采样定理，来论证 $f_{s}$ 的选择。以赫兹（$\\mathrm{s}^{-1}$）为单位表示最终采样率，并将您的数值结果四舍五入至四位有效数字。",
            "solution": "所述问题具有科学依据，提法恰当，并包含了获得唯一且有意义解所需的所有信息。我们将首先从运动控制方程中推导出惯性振荡的频率，然后应用奈奎斯特-香农采样定理来确定所需的最小采样率。\n\n在f平面上，当不存在压力梯度和摩擦力时，水平动量方程描述了仅在局部加速度和科里奥利力之间的平衡。对于一个具有速度分量 $u$（纬向，东向为正）和 $v$（经向，北向为正）的流体质点，这些方程为：\n$$\n\\frac{du}{dt} - fv = 0 \\quad (1)\n$$\n$$\n\\frac{dv}{dt} + fu = 0 \\quad (2)\n$$\n此处，$f = 2\\Omega\\sin\\phi$ 是科里奥利参数，其中 $\\Omega$ 是地球的角自转速率，$\\phi$ 是纬度。\n\n为了找到该系统的特征频率，我们可以构建一个单一的二阶微分方程。将方程 $(1)$ 对时间 $t$ 求导，得到：\n$$\n\\frac{d^2u}{dt^2} - f\\frac{dv}{dt} = 0\n$$\n我们可以使用方程 $(2)$ 代入 $\\frac{dv}{dt}$：\n$$\n\\frac{d^2u}{dt^2} - f(-fu) = 0\n$$\n$$\n\\frac{d^2u}{dt^2} + f^2 u = 0\n$$\n这是简谐振子方程的标准形式，$\\frac{d^2x}{dt^2} + \\omega^2 x = 0$。通过直接比较，该运动的角频率，即惯性角频率，为：\n$$\n\\omega_{\\text{inertial}} = |f|\n$$\n周期性频率 $\\nu_{\\text{inertial}}$ 与角频率的关系为 $\\nu = \\frac{\\omega}{2\\pi}$。因此，惯性振荡的频率为：\n$$\n\\nu_{\\text{inertial}} = \\frac{|f|}{2\\pi}\n$$\n在指定的纬度 $\\phi=45^{\\circ}$（位于北半球），$\\sin\\phi > 0$ 因此 $f > 0$。所以 $|f| = f$。\n$$\n\\nu_{\\text{inertial}} = \\frac{f}{2\\pi}\n$$\n这代表了所描述的理想化系统中的最高频率分量。\n\n为防止混叠，我们必须引用奈奎斯特-香农采样定理。该定理指出，对于一个最大频率分量为 $\\nu_{\\text{max}}$ 的带限信号，采样频率 $f_s$ 必须严格大于该最大频率的两倍。这个最小界限 $2\\nu_{\\text{max}}$ 被称为奈奎斯特速率。避免混叠的条件是：\n$$\nf_s > 2\\nu_{\\text{max}}\n$$\n在我们的情况中，物理过程的最大频率是惯性频率，所以 $\\nu_{\\text{max}} = \\nu_{\\text{inertial}}$。因此，对采样率的条件是：\n$$\nf_s > 2\\nu_{\\text{inertial}} = 2\\left(\\frac{f}{2\\pi}\\right) = \\frac{f}{\\pi}\n$$\n问题要求的是避免混叠所需的最小采样率。这对应于系统的奈奎斯特速率：\n$$\nf_{s, \\text{min}} = 2\\nu_{\\text{inertial}} = \\frac{f}{\\pi} = \\frac{2\\Omega\\sin\\phi}{\\pi}\n$$\n我们已知以下数值：\n$\\Omega = 7.2921159 \\times 10^{-5}\\ \\mathrm{s}^{-1}$\n$\\phi = 45^{\\circ}$\n\n首先，我们计算科里奥利参数 $f$：\n$$\nf = 2 \\times (7.2921159 \\times 10^{-5}\\ \\mathrm{s}^{-1}) \\times \\sin(45^{\\circ})\n$$\n由于 $\\sin(45^{\\circ}) = \\frac{\\sqrt{2}}{2}$：\n$$\nf = 2 \\times (7.2921159 \\times 10^{-5}\\ \\mathrm{s}^{-1}) \\times \\frac{\\sqrt{2}}{2} = \\sqrt{2} \\times 7.2921159 \\times 10^{-5}\\ \\mathrm{s}^{-1}\n$$\n$$\nf \\approx 1.03126402 \\times 10^{-4}\\ \\mathrm{s}^{-1}\n$$\n现在，我们可以计算所需的最小采样率 $f_{s}$：\n$$\nf_{s, \\text{min}} = \\frac{f}{\\pi} \\approx \\frac{1.03126402 \\times 10^{-4}\\ \\mathrm{s}^{-1}}{\\pi} \\approx 3.282639 \\times 10^{-5}\\ \\mathrm{s}^{-1}\n$$\n问题要求将结果四舍五入到四位有效数字。\n$$\nf_{s, \\text{min}} \\approx 3.283 \\times 10^{-5}\\ \\mathrm{s}^{-1}\n$$\n此采样率以赫兹（$\\mathrm{s}^{-1}$）为单位。在实践中，采样率通常会设得比这个最小值稍高一些，以确保信号与奈奎斯特频率之间有明确的分隔。然而，问题要求的是理论最小值。",
            "answer": "$$\n\\boxed{3.283 \\times 10^{-5}}\n$$"
        },
        {
            "introduction": "获取正确采样的信号后，我们便可以开始应用滤波器。此练习 () 介绍了一种在地球物理模型中最简单、最直观的数值滤波器之一：1-2-1 夏皮罗滤波器 (Shapiro filter)。这项实践提供了关于简单卷积模板如何充当低通滤波器的动手理解，您将推导其振幅响应并加以实现，亲眼见证它如何选择性地衰减短波信号。",
            "id": "3803574",
            "problem": "给定一个用于海洋环流模拟的纬度-经度计算网格。考虑在该网格上沿纬向（经度）方向构建一个一维、单程的 $1$–$2$–$1$ Shapiro 滤波器，并在经度方向上使用周期性边界条件。该滤波器由一个固定的、对称的三点模板定义，应用于在等距纬向位置 $x_i$ 上采样的离散场 $f_i$，其中 $x_i = i\\Delta x$，$ \\Delta x $ 是以 $\\mathrm{km}$ 为单位的局部纬向网格间距。该模板的权重为 $\\{1,2,1\\}$，经归一化后总和为1，并作为一个卷积算子。假设我们关注的内波波包是窄带的，并且可以局部地近似为一个单色信号 $f(x) = A \\cos(k x)$，其水平波长 $\\lambda = 50\\ \\mathrm{km}$，其中 $k = 2\\pi/\\lambda$ 是波数。任何三角表达式中的角度都必须以弧度处理。\n\n从离散卷积和离散傅里叶变换 (DFT) 的基本定义出发，推导单程 $1$–$2$–$1$ Shapiro 滤波器对网格上采样的内波 $f(x)$ 的单色分量的振幅响应。利用线性时不变离散滤波器在 DFT 域中对正弦分量起乘性作用，以及对称模板意味着零相移这一事实。\n\n通过计算沿纬向方向进行单程滤波后，应用于单色分量的振幅乘子 $M(\\Delta x)$，来量化滤波器的效果。该乘子是网格间距 $\\Delta x$ 和固定波长 $\\lambda = 50\\ \\mathrm{km}$ 的函数。将振幅乘子表示为一个无单位的浮点数。\n\n在一个完整的、可运行的程序中实现你的推导，为以下以 $\\mathrm{km}$ 为单位的网格间距测试套件生成数值结果：$\\Delta x \\in \\{2.0,\\ 5.0,\\ 12.5,\\ 25.0,\\ 50.0\\}$。选择这些值是为了测试多种情况：相对于波长非常精细的间距、中等间距、四分之一波长间距、半波长间距（奈奎斯特极限）以及等于波长的间距。\n\n你的程序必须：\n- 构建沿经度方向并带有周期性边界条件的 $1$–$2$–$1$ Shapiro 滤波器算子（概念上；你必须实现一个将该算子应用于一维数组的函数）。\n- 从第一性原理出发，计算作用于波长 $\\lambda = 50\\ \\mathrm{km}$ 的单色分量上的单程滤波器的解析振幅乘子 $M(\\Delta x)$。\n- 对于测试套件中的每个 $\\Delta x$，输出 $M(\\Delta x)$ 的值。\n\n单位和格式要求：\n- $\\Delta x$ 和 $\\lambda$ 的单位是 $\\mathrm{km}$。\n- 三角函数中的所有角度都以弧度为单位。\n- 最终输出是无单位的浮点数。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果按测试套件 $\\Delta x$ 值的顺序排列，每个浮点数四舍五入到六位小数。例如，一个有效的输出格式是 $[m_1,m_2,m_3,m_4,m_5]$。",
            "solution": "该问题已经过验证，并被确定为计算海洋学中数值分析领域的一个适定、有科学依据的问题。\n\n目标是推导并计算应用于单色波的单程 $1$–$2$–$1$ Shapiro 滤波器的振幅响应，或称振幅乘子 $M$。该滤波器沿纬向方向的离散网格应用。\n\n首先，我们定义滤波操作。Shapiro 滤波器使用一个权重为 $\\{1, 2, 1\\}$ 的三点模板，这些权重必须被归一化以使其总和为1。权重之和为 $1+2+1=4$。因此，归一化后的权重为 $\\{1/4, 1/2, 1/4\\}$。设 $f_i$ 表示离散场在网格点 $i$ 处的值，其中网格点由均匀间距 $\\Delta x$ 分隔。滤波器的应用产生一个新场 $f'_i$，由离散卷积定义：\n$$ f'_i = \\frac{1}{4}f_{i-1} + \\frac{1}{2}f_{i} + \\frac{1}{4}f_{i+1} $$\n\n输入信号是一个单色波，其连续形式为 $f(x) = A \\cos(k x)$，其中 $A$ 是振幅，$k=2\\pi/\\lambda$ 是波数，$\\lambda = 50\\ \\mathrm{km}$ 是波长。在离散网格上，$x_i = i\\Delta x$，信号被采样为：\n$$ f_i = A \\cos(k x_i) = A \\cos(k i \\Delta x) $$\n\n现在我们将滤波器应用于此离散信号 $f_i$：\n$$ f'_i = A \\left[ \\frac{1}{4}\\cos(k(i-1)\\Delta x) + \\frac{1}{2}\\cos(k i \\Delta x) + \\frac{1}{4}\\cos(k(i+1)\\Delta x) \\right] $$\n\n为简化此表达式，我们使用余弦的和差三角恒等式：\n$\\cos(\\alpha \\mp \\beta) = \\cos(\\alpha)\\cos(\\beta) \\pm \\sin(\\alpha)\\sin(\\beta)$。\n设 $\\alpha = k i \\Delta x$ 且 $\\beta = k \\Delta x$。\n项 $\\cos(k(i \\pm 1)\\Delta x)$ 变为：\n$$ \\cos(k(i-1)\\Delta x) = \\cos(k i \\Delta x)\\cos(k \\Delta x) + \\sin(k i \\Delta x)\\sin(k \\Delta x) $$\n$$ \\cos(k(i+1)\\Delta x) = \\cos(k i \\Delta x)\\cos(k \\Delta x) - \\sin(k i \\Delta x)\\sin(k \\Delta x) $$\n\n将这些代入 $f'_i$ 的表达式中：\n$$ f'_i = A \\left[ \\frac{1}{4}(\\cos(k i \\Delta x)\\cos(k \\Delta x) + \\sin(k i \\Delta x)\\sin(k \\Delta x)) + \\frac{1}{2}\\cos(k i \\Delta x) + \\frac{1}{4}(\\cos(k i \\Delta x)\\cos(k \\Delta x) - \\sin(k i \\Delta x)\\sin(k \\Delta x)) \\right] $$\n\n正弦项相互抵消，得到：\n$$ f'_i = A \\left[ \\frac{1}{4}\\cos(k i \\Delta x)\\cos(k \\Delta x) + \\frac{1}{2}\\cos(k i \\Delta x) + \\frac{1}{4}\\cos(k i \\Delta x)\\cos(k \\Delta x) \\right] $$\n$$ f'_i = A \\left[ \\frac{1}{2}\\cos(k i \\Delta x)\\cos(k \\Delta x) + \\frac{1}{2}\\cos(k i \\Delta x) \\right] $$\n\n提取公因式 $\\frac{1}{2}$ 和 $\\cos(k i \\Delta x)$：\n$$ f'_i = A \\cos(k i \\Delta x) \\left[ \\frac{1}{2}(1 + \\cos(k \\Delta x)) \\right] $$\n\n由于点 $i$ 处的原始信号为 $f_i = A \\cos(k i \\Delta x)$，我们可以将滤波后的信号写为：\n$$ f'_i = M(\\Delta x) \\cdot f_i $$\n其中振幅乘子 $M(\\Delta x)$ 是：\n$$ M(\\Delta x) = \\frac{1}{2}(1 + \\cos(k \\Delta x)) $$\n\n正如问题所建议的，这个结果也可以通过分析滤波器的频率响应来推导。具有脉冲响应（权重）$h_n$ 的离散滤波器的频率响应 $H(\\hat{\\omega})$ 是其离散时间傅里叶变换 (DTFT)：\n$$ H(\\hat{\\omega}) = \\sum_{n=-\\infty}^{\\infty} h_n e^{-j \\hat{\\omega} n} $$\n其中 $\\hat{\\omega}$ 是归一化角频率。对于我们的对称滤波器，其权重为 $h_{-1}=1/4$，$h_0=1/2$，$h_1=1/4$：\n$$ H(\\hat{\\omega}) = h_{-1} e^{j \\hat{\\omega}} + h_0 e^{0} + h_1 e^{-j \\hat{\\omega}} = \\frac{1}{4}e^{j\\hat{\\omega}} + \\frac{1}{2} + \\frac{1}{4}e^{-j\\hat{\\omega}} $$\n\n使用欧拉恒等式 $e^{j\\hat{\\omega}} + e^{-j\\hat{\\omega}} = 2\\cos(\\hat{\\omega})$，我们得到：\n$$ H(\\hat{\\omega}) = \\frac{1}{2} + \\frac{1}{4}(2\\cos(\\hat{\\omega})) = \\frac{1}{2}(1 + \\cos(\\hat{\\omega})) $$\n这是一个实值函数，这证实了对称滤波器的零相移。振幅响应是 $|H(\\hat{\\omega})|$。\n对于一个以间距 $\\Delta x$ 采样的连续波 $\\cos(kx)$，离散信号是 $\\cos(k i \\Delta x) = \\cos((k\\Delta x)i)$。归一化角频率对应于物理波数和网格间距，即 $\\hat{\\omega} = k\\Delta x$。\n将此代入响应函数，得到特定波数 $k$ 的振幅乘子：\n$$ M(k, \\Delta x) = H(k\\Delta x) = \\frac{1}{2}(1 + \\cos(k\\Delta x)) $$\n这证实了我们从第一性原理推导出的结果。\n\n为了表达的简洁性和提高数值稳定性，我们可以使用半角三角恒等式 $\\cos^2(\\theta) = \\frac{1+\\cos(2\\theta)}{2}$。令 $2\\theta = k\\Delta x$，我们得到一个更紧凑的振幅乘子表达式：\n$$ M(\\Delta x) = \\cos^2\\left(\\frac{k \\Delta x}{2}\\right) $$\n\n为了最终确定用于实现的公式，我们代入 $k = 2\\pi/\\lambda$：\n$$ M(\\Delta x) = \\cos^2\\left(\\frac{(2\\pi/\\lambda) \\Delta x}{2}\\right) = \\cos^2\\left(\\frac{\\pi \\Delta x}{\\lambda}\\right) $$\n\n现在，我们将使用这个最终表达式来计算给定 $\\Delta x$ 值测试套件的振幅乘子，其中 $\\lambda = 50\\ \\mathrm{km}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the amplitude multiplier of a 1-2-1 Shapiro filter for a\n    monochromatic wave with a given wavelength, evaluated at several\n    grid spacings.\n    \"\"\"\n\n    # Define the test cases and physical constants from the problem statement.\n    # The wavelength of the internal wave packet.\n    lambda_wave = 50.0  # in km\n\n    # The test suite of grid spacings.\n    delta_x_values = [\n        2.0,   # Very fine spacing\n        5.0,   # Moderate spacing\n        12.5,  # Quarter-wavelength spacing (lambda/4)\n        25.0,  # Half-wavelength spacing (lambda/2, Nyquist limit)\n        50.0   # Wavelength spacing (lambda)\n    ] # in km\n\n    results = []\n    \n    # The derived amplitude multiplier M is given by the analytic formula:\n    # M(delta_x) = cos^2(pi * delta_x / lambda)\n    # This formula quantifies the damping effect of the filter as a function\n    # of the ratio of grid spacing to wavelength.\n\n    for dx in delta_x_values:\n        # The argument of the cosine function is pi * (delta_x / lambda).\n        # This is the fundamental non-dimensional parameter that governs the\n        # filter's response.\n        argument = np.pi * dx / lambda_wave\n        \n        # Calculate the amplitude multiplier. The result is unitless.\n        multiplier = np.cos(argument) ** 2\n        \n        results.append(multiplier)\n\n    # Format the results into the specified string format.\n    # Each float must be rounded to six decimal places.\n    # The f-string format specifier f\"{value:.6f}\" achieves this.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    \n    # The final print statement must produce only the single-line format\n    # specified in the problem: a comma-separated list enclosed in\n    # square brackets.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然简单的滤波器可用于一般平滑，但我们常常需要以外科手术般的精度去除特定的窄带信号。此练习 () 介绍了一种更强大的工具：巴特沃斯滤波器 (Butterworth filter)，它被设计用于满足明确的频域指标。这项高级练习将教您如何设计一个带阻（或“陷波”）滤波器，以从时间序列中消除不需要的频率，例如主要的潮汐成分，这是现代海洋学数据分析中的一项核心技能。",
            "id": "3803585",
            "problem": "您将获得一个均匀采样的海面高度时间序列，并被要求设计数字滤波器，通过衰减主要月球半日潮和主要太阳半日潮周围的频率内容，来移除主要的半日潮分量。主要月球半日潮的角频率为 $\\,\\omega_{M2}\\,$，主要太阳半日潮的角频率为 $\\,\\omega_{S2}\\,$，其定义为 $\\,\\omega = 2\\pi/T\\,$，其中 $\\,T\\,$ 是周期（单位为秒）。对于此问题，使用 $\\,T_{M2} = 44712\\,\\mathrm{s}\\,$ 和 $\\,T_{S2} = 43200\\,\\mathrm{s}\\,$，因此 $\\,\\omega_{M2} = 2\\pi/44712\\,$ 和 $\\,\\omega_{S2} = 2\\pi/43200\\,$，单位为弧度/秒。\n\n对于每个指定的测试用例，您必须构建两个独立的数字 Butterworth 带阻滤波器（一个中心位于 $\\,\\omega_{M2}\\,$，另一个中心位于 $\\,\\omega_{S2}\\,$），它们具有明确定义的阻带半宽度和过渡带半宽度，并确定保证阻带内至少有 $\\,40\\,\\mathrm{dB}\\,$ 衰减所需的最小滤波器阶数。假设允许 $\\,1\\,\\mathrm{dB}\\,$ 的通带波纹。请独立处理每个带阻滤波器，然后形成一个按顺序应用两个陷波的级联滤波器。\n\n从以下基本基础开始：\n- 采样定理和离散时间频率归一化：采样间隔为 $\\,\\Delta t\\,$（单位为秒），采样频率为 $\\,f_s = 1/\\Delta t\\,$（单位为周/秒），Nyquist 频率为 $\\,f_N = f_s/2\\,$，归一化数字频率为 $\\,W = f/f_N\\,$，其中 $\\,f = \\omega/(2\\pi)\\,$。\n- 低通原型的 Butterworth 幅度响应，它产生一个由阶数 $\\,n\\,$ 和截止频率表征的单调响应，以及用于创建带阻滤波器的标准频率变换。\n- 以分贝为单位的衰减和波纹的定义：$\\,A\\,\\mathrm{dB}\\,$ 的衰减对应于幅度比 $\\,10^{-A/20}\\,$，$\\,R\\,\\mathrm{dB}\\,$ 的通带波纹对应于由 $\\,10^{R/20}\\,$ 表征的幅度偏差。\n\n每个测试用例中每个带阻滤波器的设计要求：\n1. 设中心角频率为 $\\,\\omega_0 \\in \\{\\omega_{M2}, \\omega_{S2}\\}\\,$。将其转换为周/秒 $\\,f_0 = \\omega_0/(2\\pi)\\,$，并通过 $\\,f_N\\,$ 进行归一化，以获得归一化中心频率 $\\,W_0 = f_0/f_N\\,$。\n2. 给定阻带半宽度 $\\,\\delta\\omega_{\\mathrm{stop}}\\,$ 和过渡带半宽度 $\\,\\delta\\omega_{\\mathrm{trans}}\\,$, 单位均为弧度/秒。通过 $\\,\\delta f_{\\mathrm{stop}} = \\delta\\omega_{\\mathrm{stop}}/(2\\pi)\\,$ 和 $\\,\\delta f_{\\mathrm{trans}} = \\delta\\omega_{\\mathrm{trans}}/(2\\pi)\\,$ 将它们转换为周/秒。\n3. 将阻带边缘（单位为周/秒）定义为 $\\,f_{s1} = f_0 - \\delta f_{\\mathrm{stop}}\\,$ 和 $\\,f_{s2} = f_0 + \\delta f_{\\mathrm{stop}}\\,$。将在阻带外的通带边缘定义为 $\\,f_{p1} = f_0 - \\delta f_{\\mathrm{stop}} - \\delta f_{\\mathrm{trans}}\\,$ 和 $\\,f_{p2} = f_0 + \\delta f_{\\mathrm{stop}} + \\delta f_{\\mathrm{trans}}\\,$。通过 $\\,f_N\\,$ 对所有边缘频率进行归一化，得到 $\\,W_{s1}, W_{s2}, W_{p1}, W_{p2}\\,$，其中 $\\,W_{x} = f_x/f_N\\,$。\n4. 使用与这些带阻规格、给定的通带波纹 $\\,g_{\\mathrm{pass}} = 1\\,\\mathrm{dB}\\,$ 和阻带衰减 $\\,g_{\\mathrm{stop}} = 40\\,\\mathrm{dB}\\,$ 一致的 Butterworth 阶数计算方法，确定每个带阻滤波器的最小阶数 $\\,n\\,$。然后设计相应的数字 Butterworth 带阻滤波器。\n5. 级联这两个带阻滤波器（一个用于 $\\,\\omega_{M2}\\,$，另一个用于 $\\,\\omega_{S2}\\,$）。为报告总阶数，请使用为这两个组成滤波器确定的单个最小阶数之和。\n\n您的程序必须为每个测试用例计算三元组 $[n_{M2}, n_{S2}, n_{\\mathrm{total}}]$，其中 $\\,n_{M2}\\,$ 是 $\\,\\omega_{M2}\\,$ 带阻滤波器的最小阶数，$\\,n_{S2}\\,$ 是 $\\,\\omega_{S2}\\,$ 带阻滤波器的最小阶数，$\\,n_{\\mathrm{total}} = n_{M2} + n_{S2}\\,$ 是级联设计的阶数（以其组成滤波器阶数之和表示）。最终输出必须是包含所有测试用例的这些三元组列表的单行。\n\n角度单位：所有角频率和宽度的单位均为弧度/秒。不允许使用其他角度单位。\n\n使用以下测试套件，该套件涵盖了典型的海洋学采样场景和过渡锐度：\n- 测试用例 1 (理想路径)：$\\,\\Delta t = 900\\,\\mathrm{s}\\,$, $\\,\\delta\\omega_{\\mathrm{stop}} = 2\\pi \\times 1.0\\times 10^{-6}\\,\\mathrm{rad/s}\\,$, $\\,\\delta\\omega_{\\mathrm{trans}} = 2\\pi \\times 4.0\\times 10^{-7}\\,\\mathrm{rad/s}\\,$.\n- 测试用例 2 (更精细采样下的更陡峭过渡)：$\\,\\Delta t = 600\\,\\mathrm{s}\\,$, $\\,\\delta\\omega_{\\mathrm{stop}} = 2\\pi \\times 7.0\\times 10^{-7}\\,\\mathrm{rad/s}\\,$, $\\,\\delta\\omega_{\\mathrm{trans}} = 2\\pi \\times 2.0\\times 10^{-7}\\,\\mathrm{rad/s}\\,$.\n- 测试用例 3 (更粗糙采样下的更宽过渡)：$\\,\\Delta t = 3600\\,\\mathrm{s}\\,$, $\\,\\delta\\omega_{\\mathrm{stop}} = 2\\pi \\times 1.2\\times 10^{-6}\\,\\mathrm{rad/s}\\,$, $\\,\\delta\\omega_{\\mathrm{trans}} = 2\\pi \\times 6.0\\times 10^{-7}\\,\\mathrm{rad/s}\\,$.\n\n对于每个测试用例，使用提供的宽度将设计应用于 $\\,\\omega_{M2}\\,$ 和 $\\,\\omega_{S2}\\,$。如果任何中间频率边缘落在有效归一化范围 $\\,0  W  1\\,$ 之外，则将其限制在该区间内，同时保持 $\\,W_{p1}  W_{s1}  W_{s2}  W_{p2}\\,$ 的顺序。如果限制操作导致无法维持有效顺序，则该测试用例应被视为不可行；在此测试套件中，所有用例都是可行的。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是对应测试用例的列表 $[n_{M2},n_{S2},n_{\\mathrm{total}}]$，顺序与上文所列相同。例如，输出格式应类似于 $\\,[[n_{M2}^{(1)},n_{S2}^{(1)},n_{\\mathrm{total}}^{(1)}],[n_{M2}^{(2)},n_{S2}^{(2)},n_{\\mathrm{total}}^{(2)}],[n_{M2}^{(3)},n_{S2}^{(3)},n_{\\mathrm{total}}^{(3)}]]\\,$。所有数字必须是不带单位的整数。",
            "solution": "所述问题在科学和数学上是合理的、适定的，并包含得出唯一解所需的所有信息。它要求在真实的海洋学背景下，基于信号处理的经典原理设计数字滤波器。因此，提供解是合理的。\n\n核心任务是确定两个独立的 Butterworth 带阻滤波器的最小阶数，这两个滤波器旨在衰减海面高度时间序列中的主要月球（$M2$）和太阳（$S2$）半日潮分量。然后，问题要求将这些阶数相加，以求得概念上的级联滤波器的阶数。\n\n基本潮汐频率由其周期给出，$T_{M2} = 44712\\,\\mathrm{s}$ 和 $T_{S2} = 43200\\,\\mathrm{s}$。相应的角频率是 $\\omega_{M2} = 2\\pi/T_{M2}$ 和 $\\omega_{S2} = 2\\pi/T_{S2}$。以周/秒（Hz）为单位，这些频率是 $f_{M2} = 1/T_{M2}$ 和 $f_{S2} = 1/T_{S2}$。\n\n数字滤波器的设计要求所有频率都相对于 Nyquist 频率进行归一化。给定采样间隔 $\\Delta t$，采样频率为 $f_s = 1/\\Delta t$，Nyquist 频率为 $f_N = f_s/2$。模拟频率 $f$（单位 Hz）通过关系式 $W = f/f_N$ 映射到归一化数字频率 $W$。归一化频率范围是 $W \\in [0, 1]$，其中 $W=0$ 对应直流（DC），$W=1$ 对应 Nyquist 频率。\n\n带阻滤波器由一个阻带（其中频率被衰减）和多个通带（其中频率基本上不受影响）定义。我们滤波器的规格如下：\n1.  通带波纹不超过 $g_{\\mathrm{pass}} = 1\\,\\mathrm{dB}$。这意味着通带中的幅度响应不得低于 $10^{-g_{\\mathrm{pass}}/20} \\approx 0.891$。\n2.  阻带衰减至少为 $g_{\\mathrm{stop}} = 40\\,\\mathrm{dB}$。这意味着阻带中的幅度响应不得超过 $10^{-g_{\\mathrm{stop}}/20} = 0.01$。\n\n对于每个以角频率 $\\omega_0$（$\\omega_{M2}$ 或 $\\omega_{S2}$）为中心的潮汐分量，其设计流程如下：\n\n首先，我们将所有规格从角频率（rad/s）转换为周/秒（Hz）。中心频率为 $f_0 = \\omega_0 / (2\\pi)$。阻带半宽度为 $\\delta f_{\\mathrm{stop}} = \\delta\\omega_{\\mathrm{stop}} / (2\\pi)$，过渡带半宽度为 $\\delta f_{\\mathrm{trans}} = \\delta\\omega_{\\mathrm{trans}} / (2\\pi)$。\n\n其次，我们定义划分通带和阻带的关键频率：\n-   阻带边缘：$f_{s1} = f_0 - \\delta f_{\\mathrm{stop}}$ 和 $f_{s2} = f_0 + \\delta f_{\\mathrm{stop}}$。\n-   通带边缘：$f_{p1} = f_{s1} - \\delta f_{\\mathrm{trans}}$ 和 $f_{p2} = f_{s2} + \\delta f_{\\mathrm{trans}}$。\n\n第三，这些频率通过 Nyquist 频率 $f_N = 1/(2\\Delta t)$ 进行归一化：\n- 通带边缘：$W_{p1} = f_{p1}/f_N$ 和 $W_{p2} = f_{p2}/f_N$。\n- 阻带边缘：$W_{s1} = f_{s1}/f_N$ 和 $W_{s2} = f_{s2}/f_N$。\n问题要求这些归一化频率必须严格位于 $0$ 和 $1$ 之间。如果任何计算出的边缘频率落在此范围之外，必须将其限制在此范围内，例如在一个小的余量 $[\\epsilon, 1-\\epsilon]$ 内，其中 $\\epsilon>0$ 是一个小数。\n\n第四，我们确定满足这些规格的 Butterworth 滤波器的最小阶数 $n$。Butterworth 滤波器的阶数决定了其从通带到阻带过渡的陡峭程度。对于一组给定的规格（$W_p$, $W_s$, $g_{\\mathrm{pass}}$, $g_{\\mathrm{stop}}$），存在一个可以满足它们的最小整数阶数 $n$。此计算涉及将带阻规格映射到等效的低通原型滤波器，同时考虑了用于从模拟原型创建数字滤波器的标准双线性变换中固有的频率扭曲。模拟低通原型的阶数 $n$ 由下式给出：\n$$ n \\ge \\frac{\\log_{10}\\left(\\frac{10^{0.1 g_{\\mathrm{stop}}} - 1}{10^{0.1 g_{\\mathrm{pass}}} - 1}\\right)}{2\\log_{10}\\left(\\frac{\\Omega_s}{\\Omega_p}\\right)} $$\n其中 $\\Omega_s$ 和 $\\Omega_p$ 是预畸变原型的阻带和通带边缘频率。标准计算库提供了封装整个过程的函数，这些函数接受数字频率规格并返回最小整数阶数 $n$。\n\n对每个测试用例的 $M2$ 和 $S2$ 分量独立执行此过程，得出最小阶数 $n_{M2}$ 和 $n_{S2}$。应用两种滤波操作的级联滤波器的总阶数定义为单个阶数之和：$n_{\\mathrm{total}} = n_{M2} + n_{S2}$。这代表了一个其传递函数为两个独立滤波器传递函数之积的滤波器的复杂度。\n\n以下 Python 程序为提供的测试用例实现了此设计流程。它计算必要的频率参数，将其归一化，然后使用 `scipy.signal` 库中的 `buttord` 函数来查找每个分量的最小滤波器阶数。然后，结果将按规定进行汇总和格式化。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import buttord\n\ndef solve():\n    \"\"\"\n    Designs Butterworth band-stop filters for tidal constituents and computes their minimal orders.\n    \"\"\"\n    # Define physical constants for tidal constituents\n    # Period of principal lunar semi-diurnal tide (s)\n    T_M2 = 44712.0\n    # Period of principal solar semi-diurnal tide (s)\n    T_S2 = 43200.0\n\n    # Angular frequencies in rad/s\n    omega_M2 = 2 * np.pi / T_M2\n    omega_S2 = 2 * np.pi / T_S2\n    \n    # Filter specifications\n    g_pass = 1.0  # Passband ripple (dB)\n    g_stop = 40.0 # Stopband attenuation (dB)\n\n    test_cases = [\n        # (delta_t, d_omega_stop, d_omega_trans)\n        (900.0, 2 * np.pi * 1.0e-6, 2 * np.pi * 4.0e-7),\n        (600.0, 2 * np.pi * 7.0e-7, 2 * np.pi * 2.0e-7),\n        (3600.0, 2 * np.pi * 1.2e-6, 2 * np.pi * 6.0e-7),\n    ]\n\n    results = []\n\n    def calculate_order(omega_0, delta_t, d_omega_stop, d_omega_trans):\n        \"\"\"\n        Calculates the minimum Butterworth filter order for a single band-stop filter.\n\n        Args:\n            omega_0 (float): Center angular frequency of the stopband (rad/s).\n            delta_t (float): Sampling interval (s).\n            d_omega_stop (float): Stopband half-width (rad/s).\n            d_omega_trans (float): Transition half-width (rad/s).\n\n        Returns:\n            int: The minimal filter order.\n        \"\"\"\n        # Calculate sampling and Nyquist frequencies in Hz\n        f_s = 1.0 / delta_t\n        f_N = f_s / 2.0\n\n        # Convert angular frequencies (rad/s) to standard frequencies (Hz)\n        f_0 = omega_0 / (2 * np.pi)\n        df_stop = d_omega_stop / (2 * np.pi)\n        df_trans = d_omega_trans / (2 * np.pi)\n\n        # Define band-stop and passband edges in Hz\n        f_s1 = f_0 - df_stop\n        f_s2 = f_0 + df_stop\n        f_p1 = f_s1 - df_trans\n        f_p2 = f_s2 + df_trans\n\n        # Normalize frequencies by the Nyquist frequency\n        W_p1 = f_p1 / f_N\n        W_p2 = f_p2 / f_N\n        W_s1 = f_s1 / f_N\n        W_s2 = f_s2 / f_N\n        \n        # Clamp frequencies to be strictly within (0, 1) as per problem statement\n        # A small epsilon is used to avoid boundary issues.\n        epsilon = 1e-9\n        W_p1 = np.clip(W_p1, epsilon, 1.0 - epsilon)\n        W_p2 = np.clip(W_p2, epsilon, 1.0 - epsilon)\n        W_s1 = np.clip(W_s1, epsilon, 1.0 - epsilon)\n        W_s2 = np.clip(W_s2, epsilon, 1.0 - epsilon)\n\n        # Use scipy.signal.buttord to find the minimum order\n        # wp: Passband edge frequencies (normalized)\n        # ws: Stopband edge frequencies (normalized)\n        wp = [W_p1, W_p2]\n        ws = [W_s1, W_s2]\n        \n        order, _ = buttord(wp, ws, g_pass, g_stop, analog=False)\n        return int(order)\n\n    for case in test_cases:\n        delta_t, d_omega_stop, d_omega_trans = case\n\n        # Calculate minimal order for M2 tide component\n        n_M2 = calculate_order(omega_M2, delta_t, d_omega_stop, d_omega_trans)\n\n        # Calculate minimal order for S2 tide component\n        n_S2 = calculate_order(omega_S2, delta_t, d_omega_stop, d_omega_trans)\n\n        # Total order of the cascaded filter\n        n_total = n_M2 + n_S2\n\n        results.append([n_M2, n_S2, n_total])\n\n    # Format the final output string\n    # e.g., [[1, 2, 3],[4, 5, 9]] -> \"[[1, 2, 3],[4, 5, 9]]\"\n    result_str = \",\".join(map(str, results))\n    final_output = f\"[{result_str}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}