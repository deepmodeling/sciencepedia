{
    "hands_on_practices": [
        {
            "introduction": "在分析并行算法时，第一步是理解其通信开销。本练习将从最基础的二维结构化网格入手，构建一个将处理器数量和布局与总通信数据量直接联系起来的基础模型。通过推导在块状区域分解下跨越子区域边界的总数据量，你将学习如何量化通信成本，这是性能优化的核心前提。",
            "id": "3806486",
            "problem": "考虑一个大小为 $N_{x} \\times N_{y}$ 个单元的结构化、逻辑上矩形的二维（$2$-D）海洋模型网格，其中 $N_{x}$ 是纬向（$x$）方向的单元数，$N_{y}$ 是经向（$y$）方向的单元数。该网格使用标准的笛卡尔块分解方法，被分解为 $P_{x} \\times P_{y}$ 个不重叠的矩形子域，其中 $x$ 方向上有 $P_{x}$ 个分区，$y$ 方向上有 $P_{y}$ 个分区。假设 $N_{x}$ 可被 $P_{x}$ 整除，$N_{y}$ 可被 $P_{y}$ 整除，因此每个子域的内部大小为 $n_{x} = N_{x}/P_{x}, n_{y} = N_{y}/P_{y}$ 个单元。全局域的外部物理边界不需要通信，光环交换仅在分区间的接口上发生。\n\n时间步进方案采用一种有限差分模板，该模板要求在每个子域的每个面上都有一个宽度为 $w$ 个单元的固定光环。在每个时间步，每对相邻的子域通过其共享接口交换光环数据：即一个垂直于接口厚度为 $w$ 个单元、长度等于接口长度的数据条带。这种交换是对称的，因此每个分区间的接口会产生两条消息（每个方向一条），每条消息携带的数据量恰好为 $w$ 层乘以接口长度再乘以每单元状态大小。设每单元状态大小为 $b$ 字节（例如，对于 $S$ 个双精度预报标量，$b = 8S$）。角（对角线）光环交换被忽略；仅执行面相邻的交换。\n\n使用图分割中边切割的基本定义（连接分配给不同分区的顶点的边的数量）和块分解的几何结构，推导出：\n- 作为 $P_{x}$ 和 $P_{y}$ 函数的分区间面总数（边切割），以及\n- 每个时间步在所有进程间通信的总字节数的闭式表达式，其中每个传输的字节只计算一次，用 $N_{x}$、$N_{y}$、$P_{x}$、$P_{y}$、$w$ 和 $b$ 表示。\n\n将您的最终答案表示为每个时间步通信总字节数（单位：字节）的单个解析表达式。不需要进行数值计算，也不应进行任何舍入。",
            "solution": "所述问题具有科学依据、是良定的、客观的，并包含足够的信息以获得唯一的解析解。它代表了在结构化网格上进行并行计算时通信成本的标准分析。因此，将推导出一个解决方案。\n\n问题要求两个量：分区间面的总数（边切割）和每个时间步通信的总字节数。后者将是最终答案。\n\n**第1部分：分区间面总数（边切割）的推导**\n\n大小为 $N_{x} \\times N_{y}$ 个单元的全局计算网格被分解为 $P_{x} \\times P_{y}$ 个子域的逻辑网格。一个分区间面，或称接口，是两个相邻子域之间共享的边界。我们可以通过分别计算垂直和水平接口的数量来找到此类接口的总数。\n\n1.  **垂直接口：** 子域的 $P_{x} \\times P_{y}$ 排列有 $P_{x}$ 列。在任意两个相邻列之间，有一排垂直接口。共有 $P_{x}-1$ 排这样的接口。每一排都横跨所有 $P_{y}$ 行子域。因此，垂直接口的数量 $F_{v}$ 是接口列数与子域行数的乘积：\n    $$F_{v} = (P_{x}-1) P_{y}$$\n\n2.  **水平接口：** 类似地，该排列有 $P_{y}$ 行子域。这在相邻行之间产生了 $P_{y}-1$ 排水平接口。每一排都横跨所有 $P_{x}$ 列子域。因此，水平接口的数量 $F_{h}$ 是：\n    $$F_{h} = (P_{y}-1) P_{x}$$\n\n分区间面的总数 $F_{total}$，对应于分解图的边切割，是垂直和水平接口的总和：\n$$F_{total} = F_{v} + F_{h} = P_{y}(P_{x}-1) + P_{x}(P_{y}-1)$$\n这可以展开为 $P_{x}P_{y} - P_{y} + P_{x}P_{y} - P_{x}$，简化后为 $2P_{x}P_{y} - P_{x} - P_{y}$。该表达式给出了分解中内部边界的总数。\n\n**第2部分：总通信量的推导**\n\n在每个时间步，每个内部接口都需要进行一次光环交换。问题陈述交换是对称的，每个接口产生两条消息（每个方向一条），并且我们必须计算所有传输的字节。这意味着对于每个接口，我们计算在一个方向上传输的数据大小，然后乘以 $2$。\n\n单条消息的大小由接口长度（以单元计）、光环宽度 $w$（以单元计）和每单元状态大小 $b$（以字节计）决定。\n\n1.  **跨垂直接口的通信：**\n    *   单个垂直接口的长度是一个子域内经向（$y$）方向的单元数。这由 $n_{y} = N_{y}/P_{y}$ 给出。\n    *   要交换的数据是一个宽度为 $w$、长度为 $n_{y}$ 的光环区域。该光环区域中的单元数为 $w \\times n_{y}$。\n    *   跨越一个垂直接口的单条消息（单向）的大小为 $C_{v,1} = w \\cdot n_{y} \\cdot b = w \\cdot \\frac{N_{y}}{P_{y}} \\cdot b$ 字节。\n    *   有 $F_{v} = P_{y}(P_{x}-1)$ 个垂直接口。每个接口有两条消息。\n    *   跨所有垂直接口通信的总字节数 $B_{v}$ 为：\n        $$B_{v} = F_{v} \\times C_{v,1} \\times 2 = P_{y}(P_{x}-1) \\times \\left(w \\frac{N_{y}}{P_{y}} b \\right) \\times 2$$\n    *   $P_{y}$ 项被消掉，表达式简化为：\n        $$B_{v} = 2wb N_{y} (P_{x}-1)$$\n\n2.  **跨水平接口的通信：**\n    *   单个水平接口的长度是一个子域内纬向（$x$）方向的单元数，由 $n_{x} = N_{x}/P_{x}$ 给出。\n    *   相应光环区域中的单元数为 $w \\times n_{x}$。\n    *   跨越一个水平接口的单条消息的大小为 $C_{h,1} = w \\cdot n_{x} \\cdot b = w \\cdot \\frac{N_{x}}{P_{x}} \\cdot b$ 字节。\n    *   有 $F_{h} = P_{x}(P_{y}-1)$ 个水平接口。\n    *   跨所有水平接口通信的总字节数 $B_{h}$ 为：\n        $$B_{h} = F_{h} \\times C_{h,1} \\times 2 = P_{x}(P_{y}-1) \\times \\left(w \\frac{N_{x}}{P_{x}} b \\right) \\times 2$$\n    *   $P_{x}$ 项被消掉，简化为：\n        $$B_{h} = 2wb N_{x} (P_{y}-1)$$\n\n3.  **总通信量：**\n    每个时间步通信的总字节数 $B_{total}$ 是跨所有垂直和水平接口通信的字节数之和。\n    $$B_{total} = B_{v} + B_{h} = 2wb N_{y} (P_{x}-1) + 2wb N_{x} (P_{y}-1)$$\n    提出公因式 $2wb$ 得到最终的闭式表达式：\n    $$B_{total} = 2wb \\left( N_{x}(P_{y}-1) + N_{y}(P_{x}-1) \\right)$$\n该表达式表示在指定条件下每个时间步的总通信量。它取决于全局网格尺寸（$N_{x}, N_{y}$）、分区方案（$P_{x}, P_{y}$）、光环宽度（$w$）和每单元数据大小（$b$）。",
            "answer": "$$\\boxed{2wb\\left(N_{x}(P_{y}-1) + N_{y}(P_{x}-1)\\right)}$$"
        },
        {
            "introduction": "真实的海洋模型是三维的，并且通信时间不仅取决于数据量，消息的启动成本（延迟）也至关重要。本练习在前一个练习的基础上，将分析扩展到三维区域，并引入标准的延迟-带宽模型（$T = \\alpha + \\beta m$）。通过这个更真实的模型，你将能够更准确地预测并行性能，并理解延迟和带宽对不同分解策略的影响。",
            "id": "3983349",
            "problem": "考虑一个求解可压缩纳维-斯托克斯方程的三维结构化有限体积计算流体动力学(CFD)求解器，该求解器作用于一个包含 $N_{x} \\times N_{y} \\times N_{z}$ 个控制体的均匀笛卡尔网格。其并行化通过块状域分解在 $P$ 个消息传递接口 (MPI; Message Passing Interface) 进程上实现，这些进程排列成一个大小为 $P_{x} \\times P_{y} \\times P_{z}$ 的逻辑处理器网格，其中 $P = P_{x} P_{y} P_{z}$。并假设 $N_{x}$、$N_{y}$ 和 $N_{z}$ 分别能被 $P_{x}$、$P_{y}$ 和 $P_{z}$ 整除。每个进程拥有一个大小为 $n_{x} \\times n_{y} \\times n_{z}$ 个单元的子域，其中 $n_{x} = N_{x}/P_{x}$、$n_{y} = N_{y}/P_{y}$ 且 $n_{z} = N_{z}/P_{z}$。计算中使用宽度为 $w$ 的模板，这意味着必须沿三个坐标方向与面相邻的邻居交换厚度为 $w$ 的晕圈层。假设：\n- 沿子域面的每次晕圈交换都是作为单个消息执行的，该消息包含该面的 $w$ 层数据（不为边或角发送单独的消息）。\n- 每个晕圈单元交换一个包含 $q$ 个标量分量的守恒状态向量。\n- 单个消息的通信时间由标准延迟-带宽关系 $T_{\\text{msg}} = \\alpha + \\beta m$ 建模，其中 $\\alpha$ 是延迟，$\\beta$ 是逆带宽（每个标量数据项的时间），$m$ 是消息中的标量数据项数量。\n- 只计算进程间的交换；物理边界条件不产生 MPI 通信。\n\n在一个完整的晕圈交换步骤（即所有三个方向）中，对所有有向的进程间面消息使用模型 $T = \\sum_{\\text{faces}} \\left( \\alpha + \\beta m_{\\text{face}} \\right)$，推导出总晕圈交换时间 $T_{\\text{total}}$ 关于 $N_{x}$、$N_{y}$、$N_{z}$、$P_{x}$、$P_{y}$、$P_{z}$、$w$、$q$、$\\alpha$ 和 $\\beta$ 的闭式表达式。将最终结果以秒为单位表示为单个解析表达式。无需进行数值计算。",
            "solution": "我们从消息传递接口 (MPI; Message Passing Interface) 的标准延迟-带宽通信模型开始，该模型指出，发送包含 $m$ 个标量数据项的消息所需的时间为 $T_{\\text{msg}} = \\alpha + \\beta m$，其中 $\\alpha$ 是延迟，$\\beta$ 是每个标量数据项的时间。对于结构化块分解，晕圈交换在面相邻的子域之间执行，沿每个共享面在两个方向上发送 $w$ 层单元。\n\n在一次完整的所有三个坐标方向的交换过程中，整个处理器网格上的总晕圈交换时间 $T_{\\text{total}}$ 可通过对所有有向的面消息的通信时间 $T_{\\text{msg}}$ 求和得到。因此，我们必须确定：\n1. 每个方向上，有向的进程间面消息的数量。\n2. 每个此类消息的大小 $m_{\\text{face}}$，用网格和分解参数表示。\n\n首先，考虑大小为 $P_{x} \\times P_{y} \\times P_{z}$ 的处理器网格。沿 $x$ 方向，有 $P_{y} P_{z}$ 条处理器线，每条线包含 $P_{x}$ 个进程。$x$ 方向上的进程间接口数量等于这些线中的内部边界数量，即每条线有 $\\left( P_{x} - 1 \\right)$ 个。因此，$x$ 方向上无向接口的总数为 $\\left( P_{x} - 1 \\right) P_{y} P_{z}$。由于晕圈交换是双向的（每个接口在两个方向上都产生一次发送），$x$ 方向上有向消息的数量为 $2 \\left( P_{x} - 1 \\right) P_{y} P_{z}$。\n\n类似的推理也适用于 $y$ 和 $z$ 方向，分别得到 $2 \\left( P_{y} - 1 \\right) P_{x} P_{z}$ 和 $2 \\left( P_{z} - 1 \\right) P_{x} P_{y}$ 个有向消息。\n\n其次，我们确定每个方向上面消息的大小 $m_{\\text{face}}$。每个子域的尺寸为 $n_{x} \\times n_{y} \\times n_{z}$ 个单元，其中 $n_{x} = N_{x}/P_{x}$、$n_{y} = N_{y}/P_{y}$ 且 $n_{z} = N_{z}/P_{z}$。一个法向为 $x$ 方向的面的面积为 $n_{y} \\times n_{z}$ 个单元，并且厚度为 $w$ 层的 $x$ 方向数据作为一个单独的消息进行传输。因此，每个消息中此面贡献的晕圈单元数量为 $w \\, n_{y} \\, n_{z}$。由于每个单元包含 $q$ 个标量分量，消息中的标量项数量为\n$$\nm_{x} = w \\, q \\, \\frac{N_{y}}{P_{y}} \\, \\frac{N_{z}}{P_{z}}.\n$$\n根据对称性，对于一个法向为 $y$ 方向的面，\n$$\nm_{y} = w \\, q \\, \\frac{N_{x}}{P_{x}} \\, \\frac{N_{z}}{P_{z}},\n$$\n对于一个法向为 $z$ 方向的面，\n$$\nm_{z} = w \\, q \\, \\frac{N_{x}}{P_{x}} \\, \\frac{N_{y}}{P_{y}}.\n$$\n\n使用延迟-带宽模型，一个 $x$ 方向面上的单个消息的时间为 $\\alpha + \\beta m_{x}$，对于 $y$ 和 $z$ 方向的面也类似。对所有有向的进程间面消息求和，总时间为\n$$\nT_{\\text{total}} = 2 \\left( P_{x} - 1 \\right) P_{y} P_{z} \\left( \\alpha + \\beta m_{x} \\right) + 2 \\left( P_{y} - 1 \\right) P_{x} P_{z} \\left( \\alpha + \\beta m_{y} \\right) + 2 \\left( P_{z} - 1 \\right) P_{x} P_{y} \\left( \\alpha + \\beta m_{z} \\right).\n$$\n代入 $m_{x}$、$m_{y}$ 和 $m_{z}$ 的表达式，我们得到闭式解析表达式：\n$$\nT_{\\text{total}} = 2 \\left( P_{x} - 1 \\right) P_{y} P_{z} \\left( \\alpha + \\beta \\, w \\, q \\, \\frac{N_{y}}{P_{y}} \\, \\frac{N_{z}}{P_{z}} \\right) + 2 \\left( P_{y} - 1 \\right) P_{x} P_{z} \\left( \\alpha + \\beta \\, w \\, q \\, \\frac{N_{x}}{P_{x}} \\, \\frac{N_{z}}{P_{z}} \\right) + 2 \\left( P_{z} - 1 \\right) P_{x} P_{y} \\left( \\alpha + \\beta \\, w \\, q \\, \\frac{N_{x}}{P_{x}} \\, \\frac{N_{y}}{P_{y}} \\right).\n$$\n该表达式的单位是秒，前提是 $\\alpha$ 的单位是秒，$\\beta$ 的单位是秒/标量数据项。它计算了一次完整的三坐标方向晕圈交换步骤中所有有向的进程间面消息，并假设晕圈交换按面聚合，边和角不单独发送，并且只有内部接口对 MPI 通信时间有贡献。",
            "answer": "$$\\boxed{2\\left(P_{x}-1\\right)P_{y}P_{z}\\left(\\alpha+\\beta\\,w\\,q\\,\\frac{N_{y}}{P_{y}}\\frac{N_{z}}{P_{z}}\\right)+2\\left(P_{y}-1\\right)P_{x}P_{z}\\left(\\alpha+\\beta\\,w\\,q\\,\\frac{N_{x}}{P_{x}}\\frac{N_{z}}{P_{z}}\\right)+2\\left(P_{z}-1\\right)P_{x}P_{y}\\left(\\alpha+\\beta\\,w\\,q\\,\\frac{N_{x}}{P_{x}}\\frac{N_{y}}{P_{y}}\\right)}$$"
        },
        {
            "introduction": "掌握了性能模型后，我们必须确保代码能够正确执行。本练习从理论建模转向实践应用，旨在解决并行编程中最常见也最棘手的挑战之一：死锁。通过模拟非阻塞MPI操作，你将深入理解为何某些通信模式是安全的，而另一些则会导致程序完全停滞，从而学会如何设计和实现一个正确且高效的光环交换（halo exchange）方案。",
            "id": "3806415",
            "problem": "考虑一个计算海洋学中使用的被动示踪剂输运方程的三维有限体积离散化，其中计算域被分解为排列在笛卡尔网格上的子域。每个子域分配给一个独立的进程，这些进程通过消息传递接口（MPI）进行通信。为了使用依赖于最近邻居的模板（stencil）更新通量，每个进程必须与其至多 $6$ 个面相邻的邻居（在 $+\\hat{x}$, $-\\hat{x}$, $+\\hat{y}$, $-\\hat{y}$, $+\\hat{z}$, $-\\hat{z}$ 方向上）交换光环数据（halo data），光环厚度为 $1$ 个单元格。你需要从第一性原理出发，推导出一个正确且无死锁的非阻塞 MPI 操作序列，该序列能在实现 $3\\text{D}$ 光环交换的同时重叠计算与通信，并形式化描述在违反顺序时可能发生死锁的条件。\n\n你的推导必须基于以下基本考虑：\n- $3\\text{D}$ 域分解定义了一组排列成维度为 $(N_x,N_y,N_z)$ 网格的进程，其中每个进程的坐标为 $(i,j,k)$，满足 $0 \\le i  N_x$, $0 \\le j  N_y$ 且 $0 \\le k  N_z$。面相邻的邻居关系由网格邻接关系确定。\n- 非阻塞 MPI 操作（如 $\\mathrm{Irecv}$ 和 $\\mathrm{Isend}$）在不阻塞调用者的情况下发起通信。其完成需要一个匹配的对等操作，并通过 $\\mathrm{Wait}$ 或 $\\mathrm{Waitall}$ 进行检测。\n- 在海洋模型的模板计算中，不需要光环值的内部更新可以在光环消息传输过程中进行计算，从而实现通信与计算的重叠。\n- MPI 中的匹配由通信器、源或目标进程号（rank）以及消息标签（tag）决定；正确性要求双方在这些参数上达成对称一致。\n\n你的推导必须：\n- 明确定义每个进程在 $\\mathrm{Irecv}$、$\\mathrm{Isend}$ 和 $\\mathrm{Waitall}$ 方面的操作序列，并论证为何在发送前提交接收足以避免死锁，同时还能实现计算与通信的重叠。\n- 陈述在违反顺序或匹配规则（如循环等待和标签不匹配）时可能发生死锁的条件。\n- 提供邻居集合和标签的形式化描述，该描述需足以让模拟器判断一个给定的全局调度是否能完成。\n\n然后，实现一个在逻辑层面（无实际 MPI 调用）模拟这种非阻塞光环交换的模拟器。模拟器应能表示排列在大小为 $(N_x,N_y,N_z)$ 网格中的进程，其中每个进程根据选定的调度策略提交一组非阻塞操作。模拟器必须通过匹配已提交的发送和接收来推进通信；只有当一个进程提交的所有操作都匹配成功时，其 $\\mathrm{Waitall}$ 调用才能成功。如果因存在未匹配的操作而导致进程停滞，且有部分进程在等待，则系统处于死锁状态。\n\n定义以下调度策略：\n- \"recv_then_send\"：一个进程向其所有存在的面邻居提交所有 $\\mathrm{Irecv}$，然后提交所有 $\\mathrm{Isend}$，接着对内部单元格执行重叠计算，最后对所有已提交的操作调用 $\\mathrm{Waitall}$。\n- \"send_then_wait_no_recv\"：一个进程向其所有存在的面邻居提交 $\\mathrm{Isend}$，然后立即调用 $\\mathrm{Waitall}$，而从不提交任何 $\\mathrm{Irecv}$。\n- \"recv_then_send_tag_mismatch_X\"：与 \"recv_then_send\" 类似，但该进程在 $x$ 轴面上的消息使用不正确的标签（从而违反了这些面的标签匹配规则）；在 $y$ 和 $z$ 轴面上使用正确的标签。\n\n假设：\n- 消息只有在发送方和接收方就对等进程号（peer ranks）和轴标签（$x$, $y$, 或 $z$）达成一致时才能匹配。一个 $+\\hat{x}$ 或 $-\\hat{x}$ 方向映射到轴标签 $x$，对于 $y$ 和 $z$ 也是如此。\n- 一个非阻塞发送在匹配的接收被提交前不会完成；一个调用 $\\mathrm{Waitall}$ 且有未匹配操作的进程将一直等待。\n\n你的程序必须模拟以下测试套件，并为每个案例输出一个布尔值，指示全局执行是否无死锁（即所有进程都完成了它们的 $\\mathrm{Waitall}$）。测试套件如下：\n\n- 案例 1：$(N_x,N_y,N_z) = (2,2,2)$，所有进程使用 \"recv_then_send\" 策略。\n- 案例 2：$(N_x,N_y,N_z) = (2,1,1)$，所有进程使用 \"send_then_wait_no_recv\" 策略。\n- 案例 3：$(N_x,N_y,N_z) = (2,2,1)$，除位于 $(0,0,0)$ 的进程使用 \"recv_then_send_tag_mismatch_X\" 策略外，所有进程均使用 \"recv_then_send\" 策略。\n- 案例 4：$(N_x,N_y,N_z) = (1,1,1)$，所有进程使用 \"recv_then_send\" 策略。\n\n最终输出规范：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4]$），其中每个 $result_i$ 是一个布尔值，如果该案例无死锁则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n不涉及物理单位。不使用角度。不使用百分比。",
            "solution": "该问题要求从第一性原理出发，推导一个使用非阻塞消息传递接口（MPI）操作的无死锁光环交换算法，分析死锁条件，并实现一个模拟器来验证不同通信策略的行为。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n- **域：** 一个用于被动示踪剂输运方程的三维计算域。\n- **离散化：** 有限体积法。\n- **分解：** 域被分解为子域的笛卡尔网格。\n- **并行性：** 每个子域一个 MPI 进程，进程排列成大小为 $(N_x, N_y, N_z)$ 的网格。\n- **进程坐标：** 每个进程由坐标 $(i, j, k)$ 标识，其中 $0 \\le i  N_x, 0 \\le j  N_y$, 且 $0 \\le k  N_z$。\n- **通信：** 进程与至多 $6$ 个面相邻的邻居（$\\pm\\hat{x}, \\pm\\hat{y}, \\pm\\hat{z}$）通信以交换光环数据。\n- **光环厚度：** $1$ 个单元格。\n- **MPI 操作：** 非阻塞操作 $\\mathrm{Irecv}$、$\\mathrm{Isend}$，以及使用 $\\mathrm{Waitall}$ 进行完成检查。\n- **重叠：** 内部计算（不需要光环数据）可以与通信重叠。\n- **MPI 匹配规则：** 发送和接收基于通信器、源/目标进程号和消息标签进行匹配。\n- **标签约定：** $x$ 轴上的通信（在 $+\\hat{x}$ 或 $-\\hat{x}$ 方向）使用标签 $x$。$y$ 和 $z$ 轴同理。\n- **调度策略：**\n    1.  `\"recv_then_send\"`：提交所有 $\\mathrm{Irecv}$，然后提交所有 $\\mathrm{Isend}$，然后计算，然后调用 $\\mathrm{Waitall}$。\n    2.  `\"send_then_wait_no_recv\"`：提交所有 $\\mathrm{Isend}$，然后调用 $\\mathrm{Waitall}$，不提交任何 $\\mathrm{Irecv}$。\n    3.  `\"recv_then_send_tag_mismatch_X\"`：与 `\"recv_then_send\"` 类似，但对 $x$ 轴面上的发送使用不正确的标签。\n- **模拟目标：** 对于给定的测试套件，确定全局执行是否无死锁（即所有进程都完成了它们的 $\\mathrm{Waitall}$）。\n- **测试套件：**\n    1.  $(N_x, N_y, N_z) = (2, 2, 2)$, 策略: `\"recv_then_send\"`。\n    2.  $(N_x, N_y, N_z) = (2, 1, 1)$, 策略: `\"send_then_wait_no_recv\"`。\n    3.  $(N_x, N_y, N_z) = (2, 2, 1)$, 策略: 除进程 $(0, 0, 0)$ 使用 `\"recv_then_send_tag_mismatch_X\"` 外，其余均为 `\"recv_then_send\"`。\n    4.  $(N_x, N_y, N_z) = (1, 1, 1)$, 策略: `\"recv_then_send\"`。\n\n**第 2 步：使用提取的已知条件进行验证**\n问题陈述在科学上和算法上都是合理的。\n-   **科学依据：** 所描述的场景——域分解、笛卡尔网格上的有限体积/差分方法的光环交换——是高性能科学计算中的一个典型且基础的问题。它是分析偏微分方程并行数值求解器性能的标准模型。\n-   **定义明确：** 问题提供了清晰的目标（模拟和检测死锁）、明确定义的初始条件（网格大小和策略），以及精确的进程交互和通信匹配规则。这建立了一个框架，其中每个测试案例都存在唯一且有意义的结果（死锁或无死锁）。\n-   **目标：** 语言正式且无歧义。策略和匹配规则的定义足够精确，可以进行确定性模拟。\n-   **完整性：** 问题是自洽的。构建模拟器和评估测试案例所需的所有信息都已提供。将 MPI 逻辑抽象为标签和进程号是适当且充分的。\n-   **无缺陷：** 问题没有违反任何科学原理，不是隐喻性或琐碎的，并且是完全可形式化的。在 MPI 编程模型的背景下，这些约束是现实的。\n\n**第 3 步：结论与行动**\n问题是有效的。将提供完整的解决方案。\n\n### 无死锁光环交换算法的推导\n\n**1. 系统形式化**\n设进程集合为 $P = \\{ p_{i,j,k} \\mid 0 \\le i  N_x, 0 \\le j  N_y, 0 \\le k  N_z \\}$。每个进程 $p_{i,j,k}$ 有一个唯一的进程号（rank），可以通过一个映射来计算，例如，$r(i,j,k) = i + j \\cdot N_x + k \\cdot N_x \\cdot N_y$。\n\n一个进程 $p_{i,j,k}$ 最多有 $6$ 个邻居。例如，它在 $+\\hat{x}$ 方向的邻居是 $p_{i+1,j,k}$，前提是 $i+1  N_x$。与该邻居的通信发生在 $x$ 轴上。我们为每个轴分配唯一的整数标签，例如，标签 $0$ 用于 $x$ 轴，标签 $1$ 用于 $y$ 轴，标签 $2$ 用于 $z$ 轴。\n\n为了更新子域边界上的单元格值，一个进程需要来自其邻居的数据。这通过交换“光环”（halo）或“幽灵”（ghost）单元格来实现。对于厚度为 $1$ 的光环，每个进程将其边界单元格的一层发送给其邻居，并接收相应的一层到其光环区域。\n\n**2. “先接收后发送”策略**\n使用非阻塞操作 $\\mathrm{Irecv}$ 和 $\\mathrm{Isend}$ 是性能的关键。它们允许程序发起一个通信操作后继续执行其他工作（如计算），而数据传输在后台进行。$\\mathrm{Waitall}$ 操作用于确保所有已发起的通信都完成后，程序才能继续使用接收到的数据。\n\n一个稳健且被广泛采用的执行无死锁光环交换的策略是**在提交任何发送操作之前提交所有接收操作**。每个进程的序列如下：\n\n1.  **提交所有接收：** 对于每个期望接收数据的邻居进程，提交一个非阻塞接收操作：$\\mathrm{Irecv}(source\\_rank, tag, ...)$。这通知 MPI 运行时库，该进程已准备好将传入数据接收到指定的缓冲区中。\n2.  **提交所有发送：** 对于每个必须发送数据的邻居进程，提交一个非阻塞发送操作：$\\mathrm{Isend}(destination\\_rank, tag, ...)$。由于所有进程都遵循相同的算法，相应的 $\\mathrm{Irecv}$ 已经被邻居进程提交，因此 MPI 库可以立即开始数据传输。\n3.  **重叠计算：** 对本地子域的*内部*进行计算。这些计算不依赖于当前正在传输的光环数据。这一步是性能增益的来源，因为计算与通信发生了重叠。\n4.  **等待完成：** 对所有已提交的 $\\mathrm{Irecv}$ 和 $\\mathrm{Isend}$ 操作的请求句柄集合调用 $\\mathrm{Waitall}$。此调用将阻塞，直到调用进程的所有发送和接收都完成为止。\n5.  **边界计算：** 一旦 $\\mathrm{Waitall}$ 返回，光环区域就填充了新的数据。进程现在可以安全地在其子域的边界单元格上执行计算，这些计算依赖于此光环数据。\n\n该策略足以避免死锁的原因是它打破了任何潜在的资源依赖的循环等待。在更简单的阻塞通信方案（甚至在重负载下的非阻塞方案）中，死锁的一个常见原因是两个进程都试图同时向对方发送数据。如果系统缓冲区有限，两个发送操作可能都会阻塞，等待对方提交接收，但对方永远不会这样做，因为它也阻塞在自己的发送操作上。通过首先提交所有接收，每个进程都表明了其接收数据的准备状态，确保了后续的发送总能找到一个已经提交的匹配接收，从而保证通信可以进行。\n\n**3. 死锁的条件**\n当形成一个循环依赖，其中一组进程都在等待一个只能由该组内另一进程触发的事件时，就会发生死锁。在 MPI 光环交换的背景下，这主要通过两种方式发生：\n\n*   **不正确的操作顺序（循环等待）：** 考虑一个策略，其中进程先提交发送，然后在提交接收之前等待它们完成。例如，进程 $p_A$ 执行 $\\mathrm{Isend}(p_B); \\mathrm{Wait}(...)$，进程 $p_B$ 执行 $\\mathrm{Isend}(p_A); \\mathrm{Wait}(...)$。从 $p_A$ 到 $p_B$ 的 `Isend` 直到 $p_B$ 提交一个匹配的 `Irecv` 之前不会完成。然而，$p_B$ 阻塞在它自己的 `Wait` 调用中，等待它到 $p_A$ 的发送完成，永远不会到达提交接收的那一步。$p_A$ 处于对称的境地。这就造成了死锁。`\"send_then_wait_no_recv\"` 策略是这个缺陷的完美例子；由于没有任何进程提交接收，因此没有任何发送可以完成，所有进程都将无限期等待。\n\n*   **参数不匹配：** MPI 要求发送和接收操作的参数精确匹配才能配对。源进程号、目标进程号或消息标签的不匹配将导致匹配引擎忽略这些操作。例如，假设进程 $p_A$ 想与 $p_B$ 沿着 $x$ 轴（标签 $0$）通信。\n    -   $p_A$ 提交 $\\mathrm{Irecv}(source=p_B, tag=0)$。\n    -   $p_B$ 提交 $\\mathrm{Isend}(dest=p_A, tag=99)$。\n    标签不匹配。来自 $p_B$ 的发送和来自 $p_A$ 的接收虽然是针对同一对进程，但被认为是无关的通信。如果两个进程随后都调用 $\\mathrm{Waitall}$，它们将永远阻塞。$p_A$ 等待一个来自 $p_B$ 且标签为 $0$ 的消息，该消息永远不会被发送；而 $p_B$ 等待其已发送的标签为 $99$ 的消息被接收，但 $p_A$ 并不期望接收该标签的消息。这由 `\"recv_then_send_tag_mismatch_X\"` 策略模拟。\n\n**4. 模拟的形式化**\n模拟器可以通过跟踪已提交操作的状态来对该系统建模。\n-   **进程和进程号：** 创建一个 $N_x \\times N_y \\times N_z$ 的进程网格。每个进程 $(i,j,k)$ 被分配一个唯一的进程号 $r$。\n-   **操作：** 通信操作表示为包含其基本匹配信息的对象或元组：`(type, rank, peer_rank, tag)`，其中 `type` 是 `SEND` 或 `RECV`。\n-   **执行模型：**\n    1.  **操作提交：** 根据每个进程指定的策略，生成所有预期的操作（`Irecv` 和 `Isend`），并将它们放入两个全局列表：`pending_sends` 和 `pending_recvs`。策略的顺序（例如，所有 `Irecv` 在任何 `Isend` 之前提交）得到遵守。\n    2.  **匹配引擎：** 模拟器重复扫描 `pending_sends` 和 `pending_recvs` 列表。如果找到一个发送操作 `(SEND, r1, r2, tag)` 和一个接收操作 `(RECV, r2, r1, tag)`，这就构成一个匹配。将这两个匹配的操作从它们各自的列表中移除。此过程持续进行，直到在对列表的完整遍历中再也找不到匹配项为止。\n    3.  **死锁检测：** 匹配引擎终止后，系统处于稳定状态。如果 `pending_sends` 和 `pending_recvs` 列表都为空，则意味着每个提交的发送都与相应的接收匹配。因此，所有进程都可以成功完成其 `Waitall` 调用。系统是无死锁的。如果任一列表不为空，则意味着存在永远不会被匹配的未完成通信操作。提交这些操作的进程将在 `Waitall` 中无限期阻塞，系统处于死锁状态。",
            "answer": "```python\nimport numpy as np\nfrom collections import namedtuple\n\n# Define a simple structure for communication operations\nOperation = namedtuple('Operation', ['type', 'rank', 'peer', 'tag'])\n\ndef get_neighbors(coords, dims):\n    \"\"\"Finds face-adjacent neighbors for a process.\"\"\"\n    i, j, k = coords\n    Nx, Ny, Nz = dims\n    neighbors = []\n    # Directions: +x, -x, +y, -y, +z, -z\n    # Corresponding axes/tags: 0, 0, 1, 1, 2, 2\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    tags = [0, 0, 1, 1, 2, 2]\n\n    for idx, (di, dj, dk) in enumerate(directions):\n        ni, nj, nk = i + di, j + dj, k + dk\n        if 0 = ni  Nx and 0 = nj  Ny and 0 = nk  Nz:\n            neighbors.append({\n                'coords': (ni, nj, nk),\n                'tag': tags[idx]\n            })\n    return neighbors\n\ndef simulate_halo_exchange(dims, policies):\n    \"\"\"\n    Simulates the MPI halo exchange and detects deadlocks.\n\n    Args:\n        dims (tuple): Grid dimensions (Nx, Ny, Nz).\n        policies (dict): A mapping from process coordinates to policy strings.\n\n    Returns:\n        bool: True if the exchange is deadlock-free, False otherwise.\n    \"\"\"\n    Nx, Ny, Nz = dims\n    num_procs = Nx * Ny * Nz\n    if num_procs == 0:\n        return True\n\n    # Map coordinates to a unique rank and back\n    coord_to_rank = {\n        (i, j, k): i + j * Nx + k * Nx * Ny\n        for k in range(Nz) for j in range(Ny) for i in range(Nx)\n    }\n\n    # Global pools of posted operations\n    pending_recvs = []\n    pending_sends = []\n\n    # --- Step 1: Post Receives ---\n    # According to the \"recv_then_send\" logic, post all receives first.\n    for k in range(Nz):\n        for j in range(Ny):\n            for i in range(Nx):\n                coords = (i, j, k)\n                rank = coord_to_rank[coords]\n                policy = policies[coords]\n\n                if policy in [\"recv_then_send\", \"recv_then_send_tag_mismatch_X\"]:\n                    neighbors = get_neighbors(coords, dims)\n                    for neighbor in neighbors:\n                        peer_coords = neighbor['coords']\n                        peer_rank = coord_to_rank[peer_coords]\n                        tag = neighbor['tag']\n                        pending_recvs.append(Operation('RECV', rank, peer_rank, tag))\n\n    # --- Step 2: Post Sends ---\n    # Now, all processes post their sends.\n    for k in range(Nz):\n        for j in range(Ny):\n            for i in range(Nx):\n                coords = (i, j, k)\n                rank = coord_to_rank[coords]\n                policy = policies[coords]\n\n                if policy in [\"recv_then_send\", \"send_then_wait_no_recv\", \"recv_then_send_tag_mismatch_X\"]:\n                    neighbors = get_neighbors(coords, dims)\n                    for neighbor in neighbors:\n                        peer_coords = neighbor['coords']\n                        peer_rank = coord_to_rank[peer_coords]\n                        tag = neighbor['tag']\n                        \n                        # Apply tag mismatch if the policy requires it\n                        if policy == \"recv_then_send_tag_mismatch_X\" and tag == 0: # tag 0 is x-axis\n                            tag = 99 # Mismatched tag\n\n                        pending_sends.append(Operation('SEND', rank, peer_rank, tag))\n\n    # --- Step 3: Matching Engine ---\n    # Repeatedly scan and match sends and receives until no more matches can be found.\n    while True:\n        matched_in_pass = False\n        \n        # To allow removing items while iterating, we iterate over a copy of one list\n        # and search the other.\n        sends_to_remove = set()\n        recvs_to_remove = set()\n        \n        # Use indices to handle list removal properly\n        recv_indices = list(range(len(pending_recvs)))\n        recv_matched = [False] * len(pending_recvs)\n\n        for i, s_op in enumerate(pending_sends):\n            for j_idx, r_op in enumerate(pending_recvs):\n                # Check if recv is already matched in this pass\n                if recv_matched[j_idx]:\n                    continue\n                \n                # Check for a match: the sender's peer matches the receiver's rank,\n                # the receiver's peer matches the sender's rank, and tags match.\n                if (s_op.peer == r_op.rank and s_op.rank == r_op.peer and s_op.tag == r_op.tag):\n                    sends_to_remove.add(i)\n                    recvs_to_remove.add(j_idx)\n                    recv_matched[j_idx] = True\n                    matched_in_pass = True\n                    break # A send can only match one receive\n        \n        if not matched_in_pass:\n            break\n\n        # Remove matched items from the lists in reverse index order to avoid shifting issues\n        for i in sorted(list(sends_to_remove), reverse=True):\n            del pending_sends[i]\n        for j in sorted(list(recvs_to_remove), reverse=True):\n            del pending_recvs[j]\n\n    # --- Step 4: Deadlock Detection ---\n    # If any operations remain unmatched, it's a deadlock.\n    # All policies imply a Waitall, so any pending op causes a block.\n    return len(pending_sends) == 0 and len(pending_recvs) == 0\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for the specified test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: (2,2,2), all processes use \"recv_then_send\".\n        {\n            \"dims\": (2, 2, 2),\n            \"default_policy\": \"recv_then_send\",\n            \"exceptions\": {}\n        },\n        # Case 2: (2,1,1), all processes use \"send_then_wait_no_recv\".\n        {\n            \"dims\": (2, 1, 1),\n            \"default_policy\": \"send_then_wait_no_recv\",\n            \"exceptions\": {}\n        },\n        # Case 3: (2,2,1), all processes use \"recv_then_send\" except (0,0,0).\n        {\n            \"dims\": (2, 2, 1),\n            \"default_policy\": \"recv_then_send\",\n            \"exceptions\": { (0, 0, 0): \"recv_then_send_tag_mismatch_X\" }\n        },\n        # Case 4: (1,1,1), all processes use \"recv_then_send\".\n        {\n            \"dims\": (1, 1, 1),\n            \"default_policy\": \"recv_then_send\",\n            \"exceptions\": {}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        dims = case[\"dims\"]\n        Nx, Ny, Nz = dims\n        \n        # Build the policy map for the current case\n        policies = {}\n        for k in range(Nz):\n            for j in range(Ny):\n                for i in range(Nx):\n                    coords = (i, j, k)\n                    if coords in case[\"exceptions\"]:\n                        policies[coords] = case[\"exceptions\"][coords]\n                    else:\n                        policies[coords] = case[\"default_policy\"]\n\n        is_deadlock_free = simulate_halo_exchange(dims, policies)\n        results.append(is_deadlock_free)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}