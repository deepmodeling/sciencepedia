{
    "hands_on_practices": [
        {
            "introduction": "边界条件的选择从根本上决定了计算域内所能支持的物理模态。封闭边界和周期性边界是两种基本类型，它们会导致截然不同的动力学行为。通过本练习 ，你将从一维浅水方程出发，亲手推导出这两种边界条件下产生的截然不同的解——驻波（假潮）和行波，从而深刻理解边界如何塑造全局动力学。",
            "id": "3786297",
            "problem": "考虑一个一维、无摩擦、恒定深度的海洋通道，其长度为 $L$，深度均匀为 $H$，其运动由用于正压运动的线性化浅水方程控制：\n$$\n\\frac{\\partial \\eta}{\\partial t} + H \\frac{\\partial u}{\\partial x} = 0, \\quad \\frac{\\partial u}{\\partial t} + g \\frac{\\partial \\eta}{\\partial x} = 0,\n$$\n其中 $\\eta(x,t)$ 是自由表面高程， $u(x,t)$ 是深度平均速度， $g$ 是重力加速度。从这些方程出发，并且不引用任何预先推导的模态公式，完成以下任务：\n\n1. 通过分离变量法推导简正模解和色散关系，解释在不同边界条件下出现的模态的物理性质（驻波与行波）。\n\n2. 对于在 $x=0$ 和 $x=L$ 处有刚性壁的封闭海盆，施加无垂直流边界条件 $u(0,t) = 0$ 和 $u(L,t) = 0$。确定其空间结构和允许的波数。明确展示边界条件如何导致驻波（假潮）模式，并讨论 $u$ 和 $\\eta$ 之间与能量通量相关的相位关系。\n\n3. 对于周期性通道，其中 $u(x+L,t) = u(x,t)$ 和 $\\eta(x+L,t) = \\eta(x,t)$，确定允许的波数并将相应的解定性为行波。解释周期性边界条件如何允许携带能量的模态存在。\n\n最后，计算封闭海盆中的基频（最低频率）正压本征频率与相同长度 $L$ 和深度 $H$ 的周期性通道中的基频正压行波频率的无量纲比值 $R$。将最终答案表示为单个无量纲数。无需四舍五入。",
            "solution": "该问题要求在两种不同的边界条件下，对一维浅水波的简正模进行系统性推导，并最终比较它们的基频。分析将从所给的控制方程开始。\n\n一维、无摩擦、恒定深度通道的线性化浅水方程如下：\n$$\n\\frac{\\partial \\eta}{\\partial t} + H \\frac{\\partial u}{\\partial x} = 0 \\quad (1)\n$$\n$$\n\\frac{\\partial u}{\\partial t} + g \\frac{\\partial \\eta}{\\partial x} = 0 \\quad (2)\n$$\n其中 $\\eta(x,t)$ 是自由表面高程， $u(x,t)$ 是深度平均速度， $H$ 是均匀深度， $g$ 是重力加速度。\n\n**1. 简正模和色散关系的推导**\n\n为了推导简正模解，我们首先将这两个一阶偏微分方程（PDE）合并成一个二阶偏微分方程。我们将方程（1）对 $t$ 求导，将方程（2）对 $x$ 求导：\n$$\n\\frac{\\partial^2 \\eta}{\\partial t^2} + H \\frac{\\partial^2 u}{\\partial t \\partial x} = 0\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x \\partial t} + g \\frac{\\partial^2 \\eta}{\\partial x^2} = 0\n$$\n假设 $\\eta$ 和 $u$ 足够光滑，以至于可以交换求导顺序（Schwarz 定理），我们有 $\\frac{\\partial^2 u}{\\partial t \\partial x} = \\frac{\\partial^2 u}{\\partial x \\partial t}$。将第二个方程中混合偏导数的表达式代入第一个方程，得到：\n$$\n\\frac{\\partial^2 \\eta}{\\partial t^2} - gH \\frac{\\partial^2 \\eta}{\\partial x^2} = 0\n$$\n这是经典的波动方程 $\\frac{\\partial^2 \\eta}{\\partial t^2} = c^2 \\frac{\\partial^2 \\eta}{\\partial x^2}$，其中波的相速度为 $c = \\sqrt{gH}$。\n\n我们使用分离变量法寻求简正模解。令 $\\eta(x,t) = \\hat{\\eta}(x) T(t)$。将其代入波动方程得到：\n$$\n\\hat{\\eta}(x) \\frac{d^2 T}{dt^2} = c^2 T(t) \\frac{d^2 \\hat{\\eta}}{dx^2}\n$$\n两边同除以 $\\hat{\\eta}(x)T(t)$ 并重新整理，我们分离变量：\n$$\n\\frac{1}{c^2 T(t)} \\frac{d^2 T}{dt^2} = \\frac{1}{\\hat{\\eta}(x)} \\frac{d^2 \\hat{\\eta}}{dx^2}\n$$\n由于左侧仅是 $t$ 的函数，右侧仅是 $x$ 的函数，所以两者必须等于一个常数。对于振荡（类波）解，该常数必须为负。我们将其记为 $-k^2$，其中 $k$ 是波数。这得到两个常微分方程：\n$$\n\\frac{d^2 T}{dt^2} + (kc)^2 T = 0\n$$\n$$\n\\frac{d^2 \\hat{\\eta}}{dx^2} + k^2 \\hat{\\eta} = 0\n$$\n时间方程的解形式为 $T(t) \\propto \\exp(\\pm i \\omega t)$，其中角频率 $\\omega$ 与波数 $k$ 的关系为：\n$$\n\\omega^2 = (kc)^2 \\implies \\omega = \\pm ck = \\pm k\\sqrt{gH}\n$$\n这就是浅水波的色散关系。它表明频率与波数成线性比例，这意味着波是非色散的：所有波都以相同的相速度 $c = \\sqrt{gH}$ 传播，无论其波长如何。\n\n空间方程的通解形式为 $\\hat{\\eta}(x) = A \\cos(kx) + B \\sin(kx)$。 $k$ 的具体值以及常数 $A$ 和 $B$ 由边界条件确定。\n$\\eta(x,t)$ 的通解是各模态的叠加，可以表示为行波 $\\exp(i(kx \\pm \\omega t))$ 或作为这些行波叠加而成的驻波。边界条件决定了哪种形式在物理上是可实现的。\n\n**2. 封闭海盆（假潮模态）**\n\n对于长度为 $L$ 的封闭海盆，边界条件是在刚性壁处无垂直流，即 $u(0,t)=0$ 和 $u(L,t)=0$。为应用这些条件，我们必须找到与我们 $\\eta(x,t)$ 的解相对应的速度场 $u(x,t)$。假设两个场都具有谐波时间依赖性 $\\exp(-i\\omega t)$，方程（1）和（2）变为：\n$$\n-i\\omega \\hat{\\eta} + H \\frac{d\\hat{u}}{dx} = 0\n$$\n$$\n-i\\omega \\hat{u} + g \\frac{d\\hat{\\eta}}{dx} = 0 \\implies \\hat{u} = \\frac{g}{i\\omega} \\frac{d\\hat{\\eta}}{dx}\n$$\n已知 $\\hat{\\eta}(x) = A \\cos(kx) + B \\sin(kx)$，我们有 $\\frac{d\\hat{\\eta}}{dx} = -Ak \\sin(kx) + Bk \\cos(kx)$。因此，速度的空间结构为：\n$$\n\\hat{u}(x) = \\frac{gk}{i\\omega} (-A \\sin(kx) + B \\cos(kx))\n$$\n在 $x=0$ 处应用边界条件：\n$$\n\\hat{u}(0) = \\frac{gk}{i\\omega} (B) = 0 \\implies B=0\n$$\n这意味着高程的空间结构必须是纯余弦形式，$\\hat{\\eta}(x) = A \\cos(kx)$，而速度结构必须是正弦形式，$\\hat{u}(x) = - A \\frac{gk}{i\\omega} \\sin(kx)$。\n\n现在，在 $x=L$ 处应用边界条件：\n$$\n\\hat{u}(L) = - A \\frac{gk}{i\\omega} \\sin(kL) = 0\n$$\n对于非平凡解（$A \\neq 0$），我们必须有 $\\sin(kL) = 0$。这个条件将允许的波数量子化：\n$$\nkL = n\\pi, \\quad \\text{for } n=1, 2, 3, \\dots\n$$\n允许的波数为 $k_n = \\frac{n\\pi}{L}$。$n=0$ 的情况意味着 $k=0$，这导致 $\\hat{u}(x) \\equiv 0$ 和 $\\hat{\\eta}(x) = \\text{constant}$。这对应于水位的均匀升高或降低，速度为零，频率为零，这不是一个动态模态。频率最低的动态模态是 $n=1$ 的情况。\n\n简正模（假潮）的完整解是：\n$$\n\\eta_n(x,t) = A_n \\cos\\left(\\frac{n\\pi x}{L}\\right) \\cos(\\omega_n t + \\phi_n)\n$$\n$$\nu_n(x,t) = \\frac{g k_n A_n}{\\omega_n} \\sin\\left(\\frac{n\\pi x}{L}\\right) \\sin(\\omega_n t + \\phi_n) = \\frac{c A_n}{H} \\sin\\left(\\frac{n\\pi x}{L}\\right) \\sin(\\omega_n t + \\phi_n)\n$$\n其中 $\\omega_n = c k_n = \\frac{n\\pi\\sqrt{gH}}{L}$。\n\n这些解是驻波。空间模式，$\\eta$ 的 $\\cos(k_n x)$ 和 $u$ 的 $\\sin(k_n x)$，是固定的，它们的振幅随时间振荡。注意 $\\eta$ 和 $u$ 在时间上存在正交相位关系（$\\pi/2$ 的相移）。当高程最大时（在晃荡的转折点），速度为零。当速度最大时（在晃荡的中点），水面是平的（$\\eta=0$）。这表示在势能（与 $\\eta^2$ 成正比）和动能（与 $u^2$ 成正比）之间的振荡。时间平均的能量通量与 $\\langle \\eta u \\rangle$ 成正比，其值为零，因为 $\\langle \\cos(\\omega t) \\sin(\\omega t) \\rangle = 0$。没有净能量传播。\n\n**3. 周期性通道（行波）**\n\n对于周期性通道，边界条件要求解在长度 $L$ 上是周期的：$u(x+L,t) = u(x,t)$ 和 $\\eta(x+L,t) = \\eta(x,t)$。最自然的方法是使用复指数形式来表示解的空间部分，$\\hat{\\eta}(x) = A\\exp(ikx)$ 和 $\\hat{u}(x) = \\hat{U}\\exp(ikx)$，这代表了行波。\n将周期性条件应用于 $\\hat{\\eta}(x)$：\n$$\nA\\exp(ik(x+L)) = A\\exp(ikx) \\implies \\exp(ikL) = 1\n$$\n当 $kL$ 是 $2\\pi$ 的整数倍时，此条件得到满足：\n$$\nkL = 2n\\pi, \\quad \\text{for } n \\in \\mathbb{Z} \\text{ (any integer)}\n$$\n允许的波数是 $k_n = \\frac{2n\\pi}{L}$。正整数 $n$ 对应于沿 $+x$ 方向传播的波，负整数对应于沿 $-x$ 方向传播的波。$n=0$ 同样是零频率、恒定状态的模态。\n\n解是以下形式的行波：\n$$\n\\eta_n(x,t) = A_n \\exp\\left(i\\left(\\frac{2n\\pi x}{L} - \\omega_n t\\right)\\right)\n$$\n其中 $\\omega_n = c |k_n| = \\frac{2|n|\\pi\\sqrt{gH}}{L}$。与封闭海盆相反，周期性边界条件允许能够持续传播能量的模态存在。为了看到这一点，我们找到相应的速度 $u$。取沿 $+x$ 方向传播的波（$n>0$）的解的实部：\n$$\n\\eta(x,t) = A \\cos(kx - \\omega t)\n$$\n由 $\\partial u/\\partial t = -g \\partial \\eta/\\partial x = -g(-kA\\sin(kx-\\omega t))$，我们积分得到：\n$$\nu(x,t) = \\frac{gk}{\\omega} A \\cos(kx - \\omega t) = \\frac{g}{c} A \\cos(kx-\\omega t) = \\sqrt{\\frac{g}{H}} \\eta(x,t)\n$$\n这里，$u$ 和 $\\eta$ 是同相的。时间平均的能量通量与 $\\langle \\eta u \\rangle = \\sqrt{\\frac{g}{H}} \\langle \\eta^2 \\rangle$ 成正比。由于 $\\langle \\cos^2(\\cdot) \\rangle = 1/2$，时间平均通量非零，表明存在沿波传播方向的净能量输运。\n\n**频率比 R 的计算**\n\n我们需要求出封闭海盆中的基频本征频率与周期性通道中的基频本征频率之比 $R$。“基频”是最低的非零频率。\n\n-   **封闭海盆基频 ($\\omega_{closed, fund}$)**：这对应于 $n=1$ 的模态。\n    波数为 $k_{closed, fund} = \\frac{\\pi}{L}$。\n    频率为 $\\omega_{closed, fund} = c \\cdot k_{closed, fund} = \\sqrt{gH} \\frac{\\pi}{L}$。\n\n-   **周期性通道基频 ($\\omega_{periodic, fund}$)**：基频行波频率对应于波数的最小非零幅值，即 $n=\\pm 1$ 的情况。\n    波数为 $|k_{periodic, fund}| = \\frac{2\\pi}{L}$。\n    频率为 $\\omega_{periodic, fund} = c \\cdot |k_{periodic, fund}| = \\sqrt{gH} \\frac{2\\pi}{L}$。\n\n-   **比值 $R$**：\n    $$\n    R = \\frac{\\omega_{closed, fund}}{\\omega_{periodic, fund}} = \\frac{\\sqrt{gH} \\frac{\\pi}{L}}{\\sqrt{gH} \\frac{2\\pi}{L}} = \\frac{\\frac{\\pi}{L}}{\\frac{2\\pi}{L}}\n    $$\n    $$\n    R = \\frac{\\pi}{2\\pi} = \\frac{1}{2}\n    $$\n物理上的解释是，封闭海盆中的基模波长为 $\\lambda = 2L$（半个波长恰好容纳在海盆中），而周期性通道中的基模波长为 $\\lambda=L$（一个完整波长恰好容纳在区域内）。由于在相速度恒定的情况下，频率与波长成反比（$\\omega = c k = c \\frac{2\\pi}{\\lambda}$），因此封闭海盆模态的频率是周期性通道模态频率的一半。",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "在模拟广阔海洋的一部分时，一个核心挑战是如何让波浪等扰动能够无反射地离开计算区域，即实现所谓的“开放”边界。由于完美的开放边界在数值上难以实现，我们通常采用人工吸收层（或称“海绵层”）来近似。本练习  将指导你分析一种常用海绵层的性能，并推导其吸收效率，让你掌握设计和评估开放边界条件的关键技能。",
            "id": "3786386",
            "problem": "考虑一个海洋模型中的一维正压重力波，其空间坐标为 $x \\in [0,L]$，受带有瑞利阻尼的线性波动方程控制：\n$$\n\\partial_{t}^{2}\\eta(x,t) + 2\\,\\gamma(x)\\,\\partial_{t}\\eta(x,t) = c^{2}\\,\\partial_{x}^{2}\\eta(x,t),\n$$\n其中 $\\eta(x,t)$ 是自由表面高程，$c>0$ 是非色散相速度，$\\gamma(x) \\ge 0$ 是一个空间变化的阻尼率，代表用于模拟开放边界的海绵层。位于 $x=L$ 的右边界是物理上封闭的（刚性壁反射体），因此在没有阻尼的情况下，反射振幅为1。一个厚度为 $d$ 的海绵层紧邻壁面放置，占据 $x \\in [L-d,L]$ 的区域。在海绵层之外，对于 $x \\in [0,L-d)$，$\\gamma(x)=0$。\n\n假设一个角频率为 $\\omega>0$ 的入射、向右传播的波，在海绵层中受到弱阻尼，即对于所有 $x \\in [L-d,L]$，都有 $0 \\le \\gamma(x) \\ll \\omega$。在这种尺度分离下，Wentzel–Kramers–Brillouin (WKB) 近似对于缓变包络是有效的。设海绵层剖面为二次形式，\n$$\n\\gamma(x) = \\sigma_{0}\\left(\\frac{x-(L-d)}{d}\\right)^{2}, \\quad x \\in [L-d,L],\n$$\n其中常数 $\\sigma_{0} > 0$。\n\n从上述控制方程和 $x=L$ 处封闭边界的定义出发，通过适当的渐近分析推导波幅穿过海绵层时的空间衰减，并获得吸收长度尺度 $L_{a}$ 的表达式。$L_{a}$ 表征了二次海绵层，即在 $x=L$ 处的往返反射振幅近似按照以下公式减小：\n$$\nR \\approx \\exp\\!\\left(-\\frac{2d}{L_{a}}\\right).\n$$\n然后，使用推导出的 $L_{a}$，确定所需的最小海绵层厚度 $d_{\\min}$，使得在海绵层入口（$x=L-d$）处观测到的反射振幅满足 $R \\le R_{\\max}$。使用以下物理上一致的参数选择：\n- 波速 $c = 50\\,\\mathrm{m\\,s^{-1}}$，\n- 最大阻尼率 $\\sigma_{0} = 0.1\\,\\mathrm{s^{-1}}$，\n- 反射阈值 $R_{\\max} = 10^{-2}$。\n\n将 $d_{\\min}$ 的最终数值答案四舍五入到四位有效数字，并以 $\\mathrm{m}$ 为单位表示。",
            "solution": "该问题经过验证并被认为是有效的。它在科学上基于波动力学的原理，采用了计算物理学中的标准模型（带瑞利阻尼的线性波动方程、海绵层），并且是适定的，有足够的信息在指定的近似条件下推导出唯一解。\n\n分析从带瑞利阻尼的一维线性波动方程开始：\n$$\n\\partial_{t}^{2}\\eta(x,t) + 2\\,\\gamma(x)\\,\\partial_{t}\\eta(x,t) = c^{2}\\,\\partial_{x}^{2}\\eta(x,t)\n$$\n我们考虑形式为 $\\eta(x,t) = \\text{Re}[\\hat{\\eta}(x) e^{-i\\omega t}]$ 的时谐波解，其中 $\\hat{\\eta}(x)$ 是复空间振幅，$\\omega > 0$ 是角频率。将此代入控制方程，得到关于 $\\hat{\\eta}(x)$ 的常微分方程：\n$$\n(-\\omega^2 \\hat{\\eta}) + 2\\gamma(x)(-i\\omega \\hat{\\eta}) = c^2 \\frac{d^2\\hat{\\eta}}{dx^2}\n$$\n整理后得到一个类亥姆霍兹方程：\n$$\n\\frac{d^2\\hat{\\eta}}{dx^2} + \\frac{\\omega^2 + 2i\\omega\\gamma(x)}{c^2} \\hat{\\eta}(x) = 0\n$$\n这可以写成 $\\frac{d^2\\hat{\\eta}}{dx^2} + k^2(x)\\hat{\\eta}(x) = 0$ 的形式，其中 $k(x)$ 是复的且空间变化的波数：\n$$\nk^2(x) = \\frac{\\omega^2}{c^2} \\left( 1 + \\frac{2i\\gamma(x)}{\\omega} \\right)\n$$\n问题陈述阻尼是弱的，即 $\\gamma(x) \\ll \\omega$，这允许我们简化 $k(x)$。对小的 $|z|$ 使用二项式近似 $(1+z)^{1/2} \\approx 1 + \\frac{1}{2}z$，其中 $z = \\frac{2i\\gamma(x)}{\\omega}$：\n$$\nk(x) = \\frac{\\omega}{c} \\left( 1 + \\frac{2i\\gamma(x)}{\\omega} \\right)^{1/2} \\approx \\frac{\\omega}{c} \\left( 1 + \\frac{1}{2} \\frac{2i\\gamma(x)}{\\omega} \\right) = \\frac{\\omega}{c} \\left( 1 + i \\frac{\\gamma(x)}{\\omega} \\right)\n$$\n因此，复波数可以表示为 $k(x) = k_r + i k_i(x)$，其中实部为 $k_r = \\omega/c$（无阻尼介质中的波数），虚部为 $k_i(x) = \\frac{\\gamma(x)}{c}$。\n\n对于方程 $\\hat{\\eta}'' + k^2(x)\\hat{\\eta} = 0$ 的解，Wentzel–Kramers–Brillouin (WKB) 近似是由向右传播和向左传播的波叠加而成。向右传播波的空间部分具有形式 $\\hat{\\eta}_{+}(x) \\propto \\exp\\left(i \\int^x k(x') dx'\\right)$。振幅受到 $k(x)$ 虚部的调制。\n$$\ni \\int^x k(x') dx' = i \\int^x \\left(\\frac{\\omega}{c} + i\\frac{\\gamma(x')}{c}\\right) dx' = i \\frac{\\omega}{c} x - \\int^x \\frac{\\gamma(x')}{c} dx'\n$$\n波的振幅受到项 $\\exp\\left(-\\int \\frac{\\gamma(x')}{c} dx'\\right)$ 的影响。\n\n一个振幅为 $A_{in}$ 的入射波在海绵层入口（$x=L-d$）处传播到位于 $x=L$ 的刚性壁。其在壁面处的振幅被衰减：\n$$\nA_{wall} = A_{in} \\exp\\left( - \\int_{L-d}^{L} k_i(x) dx \\right) = A_{in} \\exp\\left( - \\frac{1}{c} \\int_{L-d}^{L} \\gamma(x) dx \\right)\n$$\n在 $x=L$ 的刚性壁处，波被完全反射。反射波随后从 $x=L$ 传播回 $x=L-d$，经历相同的衰减。当反射波离开海绵层时，其振幅为：\n$$\nA_{out} = A_{wall} \\exp\\left( - \\frac{1}{c} \\int_{L-d}^{L} \\gamma(x) dx \\right) = A_{in} \\exp\\left( - \\frac{2}{c} \\int_{L-d}^{L} \\gamma(x) dx \\right)\n$$\n反射系数 $R$ 是在 $x=L-d$ 处出射振幅与入射振幅的比值：\n$$\nR = \\frac{A_{out}}{A_{in}} = \\exp\\left( - \\frac{2}{c} \\int_{L-d}^{L} \\gamma(x) dx \\right)\n$$\n接下来，我们使用给定的阻尼率二次剖面 $\\gamma(x) = \\sigma_{0}\\left(\\frac{x-(L-d)}{d}\\right)^{2}$（对于 $x \\in [L-d,L]$）来计算该积分。令 $u = x - (L-d)$，则 $du = dx$。积分限在 $x=L-d$ 时变为 $u=0$，在 $x=L$ 时变为 $u=d$。\n$$\n\\int_{L-d}^{L} \\gamma(x) dx = \\int_{0}^{d} \\sigma_{0} \\left(\\frac{u}{d}\\right)^2 du = \\frac{\\sigma_0}{d^2} \\int_{0}^{d} u^2 du = \\frac{\\sigma_0}{d^2} \\left[ \\frac{u^3}{3} \\right]_0^d = \\frac{\\sigma_0 d^3}{3d^2} = \\frac{\\sigma_0 d}{3}\n$$\n将此结果代入 $R$ 的表达式中：\n$$\nR = \\exp\\left(-\\frac{2}{c} \\frac{\\sigma_0 d}{3}\\right) = \\exp\\left(-\\frac{2\\sigma_0 d}{3c}\\right)\n$$\n问题将吸收长度尺度 $L_a$ 定义为满足 $R \\approx \\exp(-2d/L_a)$。将我们推导出的 $R$ 的表达式与此定义进行比较，我们可以确定 $L_a$：\n$$\n\\frac{2d}{L_a} = \\frac{2\\sigma_0 d}{3c} \\implies L_a = \\frac{3c}{\\sigma_0}\n$$\n最后的任务是求出最小海绵层厚度 $d_{min}$，使得反射系数 $R$ 不超过指定值 $R_{max}$。对于最小厚度，我们将我们得到的 $R$ 表达式设为等于 $R_{max}$：\n$$\n\\exp\\left(-\\frac{2\\sigma_0 d_{min}}{3c}\\right) = R_{max}\n$$\n解出 $d_{min}$，我们对两边取自然对数：\n$$\n-\\frac{2\\sigma_0 d_{min}}{3c} = \\ln(R_{max})\n$$\n$$\nd_{min} = -\\frac{3c}{2\\sigma_0} \\ln(R_{max}) = \\frac{3c}{2\\sigma_0} \\ln\\left(\\frac{1}{R_{max}}\\right)\n$$\n现在，我们代入给定的物理参数：$c = 50\\,\\mathrm{m\\,s^{-1}}$，$\\sigma_0 = 0.1\\,\\mathrm{s^{-1}}$，以及 $R_{max} = 10^{-2}$。\n$$\nd_{min} = -\\frac{3 \\times 50}{2 \\times 0.1} \\ln(10^{-2})\n$$\n$$\nd_{min} = -\\frac{150}{0.2} (\\ln(1) - \\ln(10^2)) = -750 (-2 \\ln(10)) = 1500 \\ln(10)\n$$\n使用数值 $\\ln(10) \\approx 2.30258509...$，我们计算 $d_{min}$ 的数值：\n$$\nd_{min} \\approx 1500 \\times 2.30258509 = 3453.877635\\,\\mathrm{m}\n$$\n按要求将此结果四舍五入到四位有效数字，得到：\n$$\nd_{min} \\approx 3454\\,\\mathrm{m}\n$$",
            "answer": "$$\\boxed{3454}$$"
        },
        {
            "introduction": "将物理概念转化为精确的计算机代码是计算海洋学的核心。在交错网格（如Arakawa C-网格）上实施周期性边界条件，需要对变量的布局和通量计算有细致的理解，以确保守恒性和一致性。这个实践练习  将引导你通过编写代码，对比两种实现周期性边界的等效方法，从而真正掌握在复杂数值模型中处理周期性边界的细节。",
            "id": "3786271",
            "problem": "考虑一个在计算海洋学中使用的二维 Arakawa C-grid (Arakawa C-grid) 离散化。设网格在 $x$ 方向上有 $N_x$ 个内部示踪剂网格，在 $y$ 方向上有 $N_y$ 个内部示踪剂网格。物理网格尺寸在 $x$ 方向为 $d_x$ 米，在 $y$ 方向为 $d_y$ 米。示踪剂网格中心由 $(j,i)$ 索引，其中 $j \\in \\{1,\\dots,N_y\\}$ (行索引向上递增) 且 $i \\in \\{1,\\dots,N_x\\}$ (列索引向右递增)。网格中心的预报示踪剂变量为 $T$，垂直面上的纬向速度为 $u$，水平面上的经向速度为 $v$。在 Arakawa C-grid 上，$u$ 定义在位置 $(j,i+\\tfrac{1}{2})$，其中 $j \\in \\{1,\\dots,N_y\\}$ 且 $i \\in \\{0,\\dots,N_x\\}$；而 $v$ 定义在 $(j+\\tfrac{1}{2},i)$，其中 $j \\in \\{0,\\dots,N_y\\}$ 且 $i \\in \\{1,\\dots,N_x\\}$。\n\n为了高效地在边界附近进行通量计算，模型代码通常在每个数组周围维护一个单网格宽度的光环 (halo)（也称为“鬼”单元层）。对于以网格为中心的示踪剂场 $T$，带有光环的数组索引为 $(j,i)$，其中 $j \\in \\{0,\\dots,N_y+1\\}$ 且 $i \\in \\{0,\\dots,N_x+1\\}$，其中索引 $j=1,\\dots,N_y$ 和 $i=1,\\dots,N_x$ 指的是内部网格。对于纬向速度 $u$，带有光环的数组具有索引 $j \\in \\{0,\\dots,N_y+1\\}$ 和 $i \\in \\{0,\\dots,N_x+2\\}$，内部索引为 $j=1,\\dots,N_y$ 和 $i=1,\\dots,N_x+1$。对于经向速度 $v$，带有光环的数组具有索引 $j \\in \\{0,\\dots,N_y+2\\}$ 和 $i \\in \\{0,\\dots,N_x+1\\}$，内部索引为 $j=1,\\dots,N_y+1$ 和 $i=1,\\dots,N_x$。\n\n假设示踪剂遵循守恒平流方程\n$$\n\\frac{\\partial T}{\\partial t} + \\nabla \\cdot (\\mathbf{U} T) = 0,\n$$\n其中 $\\mathbf{U} = (u, v)$ 是速度矢量。在 Arakawa C-grid 上，对于内部网格 $(j,i)$，使用中心平均到面的方法，一个大小为 $\\Delta t$ 的前向欧拉时间步长为\n$$\nT^{n+1}_{j,i} = T^{n}_{j,i} - \\Delta t \\left[ \\frac{F^{x}_{j,i+\\frac{1}{2}} - F^{x}_{j,i-\\frac{1}{2}}}{d_x} + \\frac{F^{y}_{j+\\frac{1}{2},i} - F^{y}_{j-\\frac{1}{2},i}}{d_y} \\right],\n$$\n面通量为\n$$\nF^{x}_{j,i+\\frac{1}{2}} = u_{j,i+\\frac{1}{2}} \\, \\widetilde{T}_{j,i+\\frac{1}{2}}, \\quad \\widetilde{T}_{j,i+\\frac{1}{2}} = \\frac{1}{2}\\left(T_{j,i} + T_{j,i+1}\\right),\n$$\n$$\nF^{y}_{j+\\frac{1}{2},i} = v_{j+\\frac{1}{2},i} \\, \\widetilde{T}_{j+\\frac{1}{2},i}, \\quad \\widetilde{T}_{j+\\frac{1}{2},i} = \\frac{1}{2}\\left(T_{j,i} + T_{j+1,i}\\right).\n$$\n\n您必须在此交错网格上实现周期性边界条件的两种等效实现：\n\n- 一种基于光环的实现：将值从相对边界复制到光环中，以使离散场在 $x$ 和 $y$ 方向上一致地回绕。对于标量 $T$，这意味着\n$$\nT_{j,0} = T_{j,N_x}, \\quad T_{j,N_x+1} = T_{j,1}, \\quad T_{0,i} = T_{N_y,i}, \\quad T_{N_y+1,i} = T_{1,i},\n$$\n对于所有有效的内部 $i$ 和 $j$，以及一致的角点填充，例如\n$$\nT_{0,0} = T_{N_y,N_x}, \\quad T_{0,N_x+1} = T_{N_y,1}, \\quad T_{N_y+1,0} = T_{1,N_x}, \\quad T_{N_y+1,N_x+1} = T_{1,1}.\n$$\n必须将类似的等式应用于带有光环的 $u$ 和 $v$ 数组，并根据它们的交错方式使用正确的索引范围。\n\n- 一种模索引实现：使用模运算对内部索引进行面通量计算，即\n$$\ni_{-} = (i-1) \\bmod N_x, \\quad i_{+} = (i+1) \\bmod N_x, \\quad j_{-} = (j-1) \\bmod N_y, \\quad j_{+} = (j+1) \\bmod N_y,\n$$\n并且面速度索引 $i \\in \\{0,\\dots,N_x\\}$ 和 $j \\in \\{0,\\dots,N_y\\}$ 以显而易见的方式进行模回绕处理。此实现不使用光环。\n\n您的任务是编写一个完整的程序，该程序：\n- 构建 $T$、$u$ 和 $v$ 的内部数组及其带有光环的对应数组，具有一致的 Arakawa C-grid 交错和单网格光环。\n- 将网格中心的 $T$ 初始化为两个高斯异常值的和，一个靠近右上角，另一个靠近另一边界，以检验角点和边缘的处理。将 $u$ 和 $v$ 初始化为恒定值（单位为米/秒）。\n- 在两个方向上为 $T$、$u$ 和 $v$ 实现周期性光环填充，包括正确的角点值。\n- 使用基于光环的通量散度计算 $T$ 的一次前向欧拉更新，并分别使用不带光环的模索引实现计算相同的更新。\n- 计算由两种实现产生的两个更新后的示踪剂场 $T^{n+1}$ 在所有内部网格上的最大绝对差。\n- 验证布尔等式，即 $T$、$u$ 和 $v$ 的光环填充（包括侧面光环和角点光环）是完全一致的。\n\n科学基础和约束：\n- 使用上述守恒定律和离散中心面平均作为通量计算的基础。不要引入任何其他平流方案。\n- 必须在 $x$ 和 $y$ 方向上严格执行周期性，并且必须一致地设置光环角点。\n- 所有物理参数必须是现实且自洽的。\n\n单位和输出：\n- 速度 $u$ 和 $v$ 必须解释为米/秒，间距 $d_x$ 和 $d_y$ 为米，时间步长 $\\Delta t$ 为秒。\n- 最终的数值误差度量是无量纲的（示踪剂单位），计算为两次更新之间的最大绝对差。\n- 布尔值是无单位的。\n\n测试套件：\n对以下参数集运行您的程序，每个参数集表示为 $(N_x,N_y,d_x,d_y,u_0,v_0,\\Delta t)$:\n1. $(16,12,1000.0,1000.0,0.5,-0.3,300.0)$\n2. $(3,5,5000.0,7000.0,1.0,0.2,100.0)$\n3. $(1,1,10000.0,10000.0,0.0,0.0,50.0)$\n4. $(8,6,800.0,1200.0,-0.4,0.0,200.0)$\n5. $(7,7,1500.0,1500.0,0.0,0.6,100.0)$\n\n对于每个测试用例，计算并返回列表 $[\\varepsilon, b_T, b_u, b_v]$，其中 $\\varepsilon$ 是基于光环和模索引的 $T^{n+1}$ 更新在内部网格上的最大绝对差，$b_T$ 是一个布尔值，说明 $T$ 的光环等式测试（侧面和角点）是否全部满足，而 $b_u$ 和 $b_v$ 是针对 $u$ 和 $v$ 的类似布尔值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是按上述顺序排列的列表。例如，输出应如下所示\n$[ [\\varepsilon_1,b_{T,1},b_{u,1},b_{v,1}], [\\varepsilon_2,b_{T,2},b_{u,2},b_{v,2}], \\dots ]$\n其中布尔值打印为 $True$ 或 $False$，浮点数采用标准十进制表示法。",
            "solution": "问题陈述已经过严格验证，并被确定为是合理的。它具有科学依据，定义明确，并提供了一套完整且一致的定义和约束来解决所述问题。任务是实现并比较两种在交错的 Arakawa C-grid 上处理周期性边界条件的常用数值技术：一种是基于光环的交换，另一种是模索引方法。这两种方法的等价性是计算科学中的一个基本概念，验证这种等价性可以作为对正确实现的严格测试。\n\n我们将首先建立离散网格结构和索引约定。域具有 $N_x \\times N_y$ 个内部示踪剂网格。我们将使用从零开始的 Python/NumPy 数组索引。\n\n标量示踪剂场 $T$ 定义在网格中心。$T$ 的内部数组维度为 $(N_y, N_x)$。一个带有光环的数组 `T_h` 将具有维度 $(N_y+2, N_x+2)$。内部数据位于 `T_h[1:N_y+1, 1:N_x+1]`。\n\n纬向速度 $u$ 在 $x$ 方向上交错。$u$ 的内部数组维度为 $(N_y, N_x+1)$，表示示踪剂网格垂直面上的速度。带有光环的数组 `u_h` 维度为 $(N_y+2, N_x+3)$。内部数据位于 `u_h[1:N_y+1, 1:N_x+2]`。\n\n经向速度 $v$ 在 $y$ 方向上交错。$v$ 的内部数组维度为 $(N_y+1, N_x)$，表示水平面上的速度。带有光环的数组 `v_h` 维度为 $(N_y+3, N_x+2)$。内部数据位于 `v_h[1:N_y+2, 1:N_x+1]`。\n\n初始示踪剂场 $T$ 被指定为两个高斯异常值的和。对于中心坐标为 $(x_i, y_j)$ 的网格单元 $(j, i)$，其值为：\n$$\nT(x_i, y_j) = A_1 \\exp\\left(-\\frac{(x_i-x_{c1})^2}{2\\sigma_{x1}^2} - \\frac{(y_j-y_{c1})^2}{2\\sigma_{y1}^2}\\right) + A_2 \\exp\\left(-\\frac{(x_i-x_{c2})^2}{2\\sigma_{x2}^2} - \\frac{(y_j-y_{c2})^2}{2\\sigma_{y2}^2}\\right)\n$$\n我们选择参数将一个异常值放置在右上角附近，另一个放置在左边界附近，以测试周期性回绕的各个方面。具体来说，我们选择中心 $(x_{c1}, y_{c1}) = ((N_x-0.5)d_x, (N_y-0.5)d_y)$ 和 $(x_{c2}, y_{c2}) = (0, 0.5 N_y d_y)$。宽度 $\\sigma$ 设置为域大小的一部分，例如 $\\sigma_x = N_x d_x / 10$ 和 $\\sigma_y = N_y d_y / 10$。幅度 $A_1, A_2$ 设置为 $1.0$。速度 $u$ 和 $v$ 分别初始化为恒定值 $u_0$ 和 $v_0$。\n\n问题的核心是比较两种基于前向欧拉方案的等效时间步进算法：\n$$\nT^{n+1}_{j,i} = T^{n}_{j,i} - \\Delta t \\left( \\frac{F^x_{j, i+1/2} - F^x_{j, i-1/2}}{d_x} + \\frac{F^y_{j+1/2, i} - F^y_{j-1/2, i}}{d_y} \\right)\n$$\n其中通量使用中心平均计算：\n$$\nF^{x}_{j,i+1/2} = u_{j,i+1/2} \\frac{T_{j,i} + T_{j,i+1}}{2}, \\quad F^{y}_{j+1/2,i} = v_{j+1/2,i} \\frac{T_{j,i} + T_{j+1,i}}{2}\n$$\n\n**1. 基于光环的实现**\n\n此方法使用在内部域周围带有一单元光环区域的数组。在计算通量之前，这些光环单元会用来自域另一侧的数据填充，以强制实施周期性。对于任何场 $\\phi$，光环填充操作如下：\n对于像 $T$ 这样内部大小为 $(N_y, N_x)$ 且位于大小为 $(N_y+2, N_x+2)$ 的光环数组中的场：\n- 西侧光环来自东侧边界: `T_h[1:N_y+1, 0] = T_h[1:N_y+1, N_x]`\n- 东侧光环来自西侧边界: `T_h[1:N_y+1, N_x+1] = T_h[1:N_y+1, 1]`\n- 南侧光环来自北侧边界: `T_h[0, 1:N_x+1] = T_h[N_y, 1:N_x+1]`\n- 北侧光环来自南侧边界: `T_h[N_y+1, 1:N_x+1] = T_h[1, 1:N_x+1]`\n\n角点也被一致地填充。例如，`T_h[0, 0] = T_h[N_y, N_x]`。一种包括角点在内的稳健的光环填充方法是顺序执行填充，例如，先填充整个宽度的北/南光环，然后填充整个高度的东/西光环。类似的规则，根据不同的数组维度和交错方式进行调整，也适用于 `u_h` 和 `v_h`。\n\n布尔验证检查 `b_T, b_u, b_v` 是通过在光环填充操作后直接比较数组切片来执行的，以确认这些等式成立。\n\n在填充光环后，内部单元 `T_h[j, i]`（其中 `j` 在 $1..N_y$ 范围内，`i` 在 $1..N_x$ 范围内）的通量散度是使用其直接邻居计算的。例如，计算西面通量所需的示踪剂值 $T_{j,i-1}$ 就是 `T_h[j, i-1]`。如果 $i=1$，此索引指向西侧光环 `T_h[j, 0]`，该光环现在包含正确的周期性值。\n\n**2. 模索引实现**\n\n此方法仅在表示内部域的数组上操作。周期性是在计算点通过对数组索引使用模运算来处理的。\n对于索引为 `(j, i)`（其中 `j` 在 $0..N_y-1$ 范围内，`i` 在 $0..N_x-1$ 范围内）的示踪剂单元，其邻居的索引计算如下：\n- 西邻：$i_W = (i - 1 + N_x) \\pmod{N_x}$\n- 东邻：$i_E = (i + 1) \\pmod{N_x}$\n- 南邻：$j_S = (j - 1 + N_y) \\pmod{N_y}$\n- 北邻：$j_N = (j + 1) \\pmod{N_y}$\n\n然后使用这些回绕的索引计算示踪剂场的通量。对于单元 `(j, i)`，向右的通量取决于 `(j, i)` 和 `(j, i_E)` 处的 $T$。相关的速度 `u_int[j, i+1]` 从内部速度数组中获取。请注意，由于交错排列，速度数组在交错方向上大一个元素（`u` 在 $x$ 方向有 $N_x+1$ 个点，`v` 在 $y$ 方向有 $N_y+1$ 个点），因此在计算示踪剂平流时，速度索引不需要模运算。\n\n**等价性与验证**\n\n两种方法都是同一物理问题在相同边界条件下的离散实现。因此，它们必须为更新后的示踪剂场 $T^{n+1}$ 产生相同的数值结果。两种方法结果在内部域上的最大绝对差 $\\varepsilon$ 应该在机器浮点精度的数量级上（即，实际上为零）。布尔检查 $b_T, b_u, b_v$ 必须评估为真，以确认光环填充逻辑的正确性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, dx, dy, u0, v0, dt)\n        (16, 12, 1000.0, 1000.0, 0.5, -0.3, 300.0),\n        (3, 5, 5000.0, 7000.0, 1.0, 0.2, 100.0),\n        (1, 1, 10000.0, 10000.0, 0.0, 0.0, 50.0),\n        (8, 6, 800.0, 1200.0, -0.4, 0.0, 200.0),\n        (7, 7, 1500.0, 1500.0, 0.0, 0.6, 100.0),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_one_case(*params)\n        results.append(result)\n    \n    # Format the final output string\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        eps, bt, bu, bv = res\n        output_str += f\"[{eps},{bt},{bu},{bv}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    print(output_str)\n\ndef run_one_case(Nx, Ny, dx, dy, u0, v0, dt):\n    \"\"\"\n    Executes the simulation and comparison for a single parameter set.\n    \"\"\"\n    # 1. Initialize interior fields\n    T_int, u_int, v_int = initialize_fields(Nx, Ny, dx, dy, u0, v0)\n\n    # 2. Halo-based realization\n    T_result_halo, b_T, b_u, b_v = halo_based_update(\n        T_int.copy(), u_int.copy(), v_int.copy(), Nx, Ny, dx, dy, dt\n    )\n\n    # 3. Modular-index realization\n    T_result_mod = modular_index_update(\n        T_int.copy(), u_int.copy(), v_int.copy(), Nx, Ny, dx, dy, dt\n    )\n\n    # 4. Compare results\n    epsilon = np.max(np.abs(T_result_halo - T_result_mod))\n\n    return [epsilon, b_T, b_u, b_v]\n\ndef initialize_fields(Nx, Ny, dx, dy, u0, v0):\n    \"\"\"\n    Initializes T, u, and v fields.\n    \"\"\"\n    # T field at cell centers\n    T_int = np.zeros((Ny, Nx))\n    x_T = (np.arange(Nx) + 0.5) * dx\n    y_T = (np.arange(Ny) + 0.5) * dy\n    \n    Lx, Ly = Nx * dx, Ny * dy\n    sigma_x, sigma_y = Lx / 10.0, Ly / 10.0\n\n    # Gaussian 1: near top-right corner\n    xc1, yc1 = (Nx - 0.5) * dx, (Ny - 0.5) * dy\n    # Gaussian 2: near left-center boundary\n    xc2, yc2 = 0.0, 0.5 * Ly\n    \n    for j in range(Ny):\n        for i in range(Nx):\n            # First Gaussian\n            dist_sq1 = ((x_T[i] - xc1)**2 / (2 * sigma_x**2)) + \\\n                       ((y_T[j] - yc1)**2 / (2 * sigma_y**2))\n            \n            # Second Gaussian: handle periodic distance in x\n            dx_p = min(abs(x_T[i] - xc2), Lx - abs(x_T[i] - xc2))\n            dist_sq2 = (dx_p**2 / (2 * sigma_x**2)) + \\\n                       ((y_T[j] - yc2)**2 / (2 * sigma_y**2))\n\n            T_int[j, i] = np.exp(-dist_sq1) + np.exp(-dist_sq2)\n\n    # u field at vertical faces\n    u_int = np.full((Ny, Nx + 1), u0)\n    \n    # v field at horizontal faces\n    v_int = np.full((Ny + 1, Nx), v0)\n    \n    return T_int, u_int, v_int\n\ndef fill_and_verify_halos(T_h, u_h, v_h, Nx, Ny):\n    \"\"\"\n    Fills halo regions for T, u, v and verifies the fills.\n    \"\"\"\n    # --- Fill Halos for T (Ny+2, Nx+2) ---\n    T_h[0, :] = T_h[Ny, :]       # South from North\n    T_h[Ny+1, :] = T_h[1, :]     # North from South\n    T_h[:, 0] = T_h[:, Nx]       # West from East\n    T_h[:, Nx+1] = T_h[:, 1]     # East from West\n\n    # --- Verify Halos for T ---\n    b_T = all([\n        np.all(T_h[1:Ny+1, 0] == T_h[1:Ny+1, Nx]),     # West\n        np.all(T_h[1:Ny+1, Nx+1] == T_h[1:Ny+1, 1]),   # East\n        np.all(T_h[0, 1:Nx+1] == T_h[Ny, 1:Nx+1]),     # South\n        np.all(T_h[Ny+1, 1:Nx+1] == T_h[1, 1:Nx+1]),   # North\n        T_h[0, 0] == T_h[Ny, Nx],                     # SW corner\n        T_h[0, Nx+1] == T_h[Ny, 1],                   # SE corner\n        T_h[Ny+1, 0] == T_h[1, Nx],                   # NW corner\n        T_h[Ny+1, Nx+1] == T_h[1, 1],                 # NE corner\n    ])\n\n    # --- Fill halos for u (Ny+2, Nx+3) ---\n    u_h[0, :] = u_h[Ny, :]         # South from North\n    u_h[Ny+1, :] = u_h[1, :]       # North from South\n    u_h[:, 0] = u_h[:, Nx+1]       # West from East\n    u_h[:, Nx+2] = u_h[:, 1]       # East from West\n\n    # --- Verify halos for u ---\n    b_u = all([\n        np.all(u_h[1:Ny+1, 0] == u_h[1:Ny+1, Nx+1]),\n        np.all(u_h[1:Ny+1, Nx+2] == u_h[1:Ny+1, 1]),\n        np.all(u_h[0, :] == u_h[Ny, :]),\n        np.all(u_h[Ny+1, :] == u_h[1, :]),\n    ])\n\n    # --- Fill halos for v (Ny+3, Nx+2) ---\n    v_h[0, :] = v_h[Ny+1, :]       # South from North\n    v_h[Ny+2, :] = v_h[1, :]       # North from South\n    v_h[:, 0] = v_h[:, Nx]         # West from East\n    v_h[:, Nx+1] = v_h[:, 1]       # East from West\n    \n    # --- Verify halos for v ---\n    b_v = all([\n        np.all(v_h[:, 0] == v_h[:, Nx]),\n        np.all(v_h[:, Nx+1] == v_h[:, 1]),\n        np.all(v_h[0, 1:Nx+1] == v_h[Ny+1, 1:Nx+1]),\n        np.all(v_h[Ny+2, 1:Nx+1] == v_h[1, 1:Nx+1]),\n    ])\n\n    return b_T, b_u, b_v\n\n\ndef halo_based_update(T_int, u_int, v_int, Nx, Ny, dx, dy, dt):\n    \"\"\"\n    Computes one time step using halo-based boundary conditions.\n    \"\"\"\n    # Create halo-augmented arrays\n    T_h = np.zeros((Ny + 2, Nx + 2))\n    u_h = np.zeros((Ny + 2, Nx + 3))\n    v_h = np.zeros((Ny + 3, Nx + 2))\n\n    # Copy interior data\n    T_h[1:Ny+1, 1:Nx+1] = T_int\n    u_h[1:Ny+1, 1:Nx+2] = u_int\n    v_h[1:Ny+2, 1:Nx+1] = v_int\n    \n    # Fill halos and perform verification\n    b_T, b_u, b_v = fill_and_verify_halos(T_h, u_h, v_h, Nx, Ny)\n\n    # Compute update\n    T_new_h = T_h.copy()\n    for j in range(1, Ny + 1):\n        for i in range(1, Nx + 1):\n            # X-fluxes\n            Fx_east = u_h[j, i+1] * 0.5 * (T_h[j, i] + T_h[j, i+1])\n            Fx_west = u_h[j, i]   * 0.5 * (T_h[j, i] + T_h[j, i-1])\n            \n            # Y-fluxes\n            Fy_north = v_h[j+1, i] * 0.5 * (T_h[j, i] + T_h[j+1, i])\n            Fy_south = v_h[j, i]   * 0.5 * (T_h[j, i] + T_h[j-1, i])\n            \n            div_Fx = (Fx_east - Fx_west) / dx\n            div_Fy = (Fy_north - Fy_south) / dy\n            \n            T_new_h[j, i] = T_h[j, i] - dt * (div_Fx + div_Fy)\n\n    return T_new_h[1:Ny+1, 1:Nx+1], b_T, b_u, b_v\n\ndef modular_index_update(T_int, u_int, v_int, Nx, Ny, dx, dy, dt):\n    \"\"\"\n    Computes one time step using modular indexing for boundary conditions.\n    \"\"\"\n    T_new = T_int.copy()\n    # Using 0-based indexing for arrays\n    for j in range(Ny):\n        for i in range(Nx):\n            ip1 = (i + 1) % Nx\n            im1 = (i - 1 + Nx) % Nx\n            jp1 = (j + 1) % Ny\n            jm1 = (j - 1 + Ny) % Ny\n            \n            # X-fluxes\n            Fx_east = u_int[j, i+1] * 0.5 * (T_int[j, i] + T_int[j, ip1])\n            Fx_west = u_int[j, i]   * 0.5 * (T_int[j, i] + T_int[j, im1])\n\n            # Y-fluxes\n            Fy_north = v_int[j+1, i] * 0.5 * (T_int[j, i] + T_int[jp1, i])\n            Fy_south = v_int[j, i]   * 0.5 * (T_int[j, i] + T_int[jm1, i])\n            \n            div_Fx = (Fx_east - Fx_west) / dx\n            div_Fy = (Fy_north - Fy_south) / dy\n            \n            T_new[j, i] = T_int[j, i] - dt * (div_Fx + div_Fy)\n            \n    return T_new\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}