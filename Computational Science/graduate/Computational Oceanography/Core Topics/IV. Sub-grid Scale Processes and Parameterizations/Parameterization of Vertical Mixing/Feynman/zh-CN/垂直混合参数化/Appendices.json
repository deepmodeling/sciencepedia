{
    "hands_on_practices": [
        {
            "introduction": "理论知识必须通过实践来巩固。本节将指导您将垂直混合参数化的核心概念转化为实际的计算技能。第一个练习将探讨K-剖面参数化（KPP）方案中的一个基本诊断步骤：确定海洋边界层的深度（$h$）。您将通过计算体积理查森数（$Ri_b$）并将其与临界阈值进行比较，从给定的速度和密度剖面中推导出$h$的值，从而将一个关键的物理准则转化为一个有效的数值算法。",
            "id": "3807670",
            "problem": "给定海洋表层的水平流和现场密度的离散垂直剖面。利用K-剖面参数化（KPP）的概念框架，从第一性原理出发，推导出一个用于诊断边界层深度的数值方法。目标是计算整体理查森数剖面，并将首次穿越阈值的深度确定为边界层深度。您的程序必须实现完整的计算过程，并为测试套件生成指定的输出。\n\n基本原理和物理背景：\n- 假设Boussinesq近似、静力平衡和一个水平均匀的水柱。垂直坐标为深度 $z$，向下为正，海面处 $z=0$。\n- 设 $U(z)$ 和 $V(z)$ 是水平流分量，单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$；$\\rho(z)$ 是现场密度，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$。\n- 定义重力加速度为 $g = 9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$，参考密度为 $\\rho_0 = 1025\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$。\n- K-剖面参数化（KPP）使用一个整体理查森数阈值 $Ri_{b,cr}$ 来诊断边界层深度 $h$，通常取值为 $Ri_{b,cr} = 0.3$（无量纲）。Mellor–Yamada湍流闭合（MY）方案内部使用梯度理查森数，但在此问题中，需要基于浮力差异和切变从第一性原理推导整体度量。\n\n起始点定义：\n- 梯度理查森数定义为 $Ri_g = N^2/S^2$，其中浮力频率为 $N^2 = -\\dfrac{g}{\\rho_0}\\dfrac{\\partial \\rho}{\\partial z}$，切变大小为 $S^2 = \\left(\\dfrac{\\partial U}{\\partial z}\\right)^2 + \\left(\\dfrac{\\partial V}{\\partial z}\\right)^2$。\n- 对于从海面到深度 $z$ 的有限层内的整体度量，用该层上的累积有限差分替换垂直梯度，并使用浮力异常 $b(z) = g\\dfrac{\\rho(z) - \\rho_0}{\\rho_0}$，单位为 $\\mathrm{m}\\,\\mathrm{s}^{-2}$。令 $b_s = b(0)$，$U_s = U(0)$，$V_s = V(0)$。您的推导必须得出一个无量纲的整体理查森数 $Ri_b(z)$，该数依赖于这些从海面到特定深度的差值，并与K-剖面参数化框架保持一致。\n\n边界层深度诊断：\n- 从海面开始向下扫描，找到整体理查森数首次超过临界值 $Ri_{b,cr}$ 的深度。设 $z_i$ 和 $z_{i+1}$ 是满足 $Ri_b(z_i) \\le Ri_{b,cr}$ 和 $Ri_b(z_{i+1}) > Ri_{b,cr}$ 的连续深度。则边界层深度 $h$ 定义为在 $z_i$ 和 $z_{i+1}$ 之间沿 $Ri_b(z)$ 线性插值得到的穿越深度。\n- 如果对于所有可用深度，$Ri_b(z) \\le Ri_{b,cr}$ 都成立，则将 $h$ 设为最深可用深度。\n- 如果在海面以下的第一个有效深度处 $Ri_b(z) > Ri_{b,cr}$，则设 $h = 0\\,\\mathrm{m}$。\n- 为了数值稳健性，如果分母中的切变大小在某个深度处恰好为零，则对分母应用一个数值下限 $\\epsilon = 10^{-12}$ 以避免除以零，并继续计算。必须声明并一致地使用此正则化方法。\n\n单位和输出规范：\n- 诊断出的边界层深度 $h$ 以 $\\mathrm{m}$ 为单位表示，并四舍五入到三位小数。\n- 本问题不使用角度。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[h_1,h_2,h_3]$。\n\n测试套件：\n使用上述定义和 $Ri_{b,cr} = 0.3$，计算以下三种情况中每一种的边界层深度 $h$。\n\n情况A（包含密度跃层的常规“顺利路径”）：\n- 深度：$z_k = k\\,\\mathrm{m}$，其中 $k=0,1,2,\\dots,60$。\n- 流速：$U(z) = 0.5 - 0.005\\,z$ 和 $V(z) = 0.002\\,z$，单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- 密度：$\\rho(z) = 1023.5 + 0.005\\,z + \\dfrac{0.4}{1 + \\exp\\!\\left(-\\dfrac{z - 25}{3}\\right)}$，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$。\n\n情况B（中性层结，弱切变）：\n- 深度：$z_k = 2k\\,\\mathrm{m}$，其中 $k=0,1,2,\\dots,25$（即从 $0$ 到 $50\\,\\mathrm{m}$，间隔 $2\\,\\mathrm{m}$）。\n- 流速：$U(z) = 0.2 - 0.001\\,z$ 和 $V(z) = 0$，单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- 密度：$\\rho(z) = 1025.0$，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$（随深度不变）。\n\n情况C（强稳定层结，极弱切变）：\n- 深度：$z_k = 5k\\,\\mathrm{m}$，其中 $k=0,1,2,\\dots,20$（即从 $0$ 到 $100\\,\\mathrm{m}$，间隔 $5\\,\\mathrm{m}$）。\n- 流速：$U(z) = 0.1 - 0.0005\\,z$ 和 $V(z) = 0$，单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- 密度：$\\rho(z) = 1024.0 + 0.01\\,z$，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$。\n\n算法要求：\n- 基于上述基本原理，使用浮力和流速的从海面到深度的有限差分来推导 $Ri_b(z)$，不假设任何快捷公式。通过在从海面开始的第一个阈值穿越点进行分段线性插值，实现对 $h$ 的诊断。\n- 如果切变平方分母为零，则对其应用数值下限 $\\epsilon = 10^{-12}$。\n- 最终输出必须是形如 $[h_A,h_B,h_C]$ 的单行文本，其中每个条目以 $\\mathrm{m}$ 为单位，并四舍五入到三位小数。\n\n您的程序必须是一个完整的、可运行的实现，不得需要任何用户输入或外部文件。它必须计算三个值 $h_A$、$h_B$ 和 $h_C$，并以指定的输出格式精确打印它们。",
            "solution": "任务是基于K-剖面参数化（KPP）框架，推导并实现一个用于诊断海洋边界层深度 $h$ 的数值方法。这包括计算整体理查森数剖面 $Ri_b(z)$，并找到它首次超过临界值的深度。\n\n推导和步骤如下：\n\n首先，我们确立基本原理。层结剪切流的稳定性由理查森数表征，它代表了混合层结流体所需的稳定化势能与可从速度切变中获得的非稳定化动能之比。梯度理查森数由 $Ri_g = N^2 / S^2$ 给出。在一个深度 $z$ 向下为正的坐标系中，为了使稳定的密度剖面（密度 $\\rho$ 随深度 $z$ 增加）得到正的浮力频率平方，$N^2$ 必须定义为 $N^2 = \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial z}$。垂直切变的平方是 $S^2 = \\left(\\frac{\\partial U}{\\partial z}\\right)^2 + \\left(\\frac{\\partial V}{\\partial z}\\right)^2$。\n\n为了构建从海面（$z=0$）延伸到深度 $z$ 的层的整体理查森数 $Ri_b(z)$，我们将无穷小导数替换为跨越该层的有限差分。\n\n梯度 $\\frac{\\partial \\rho}{\\partial z}$ 由整体差异 $\\frac{\\rho(z) - \\rho(0)}{z-0}$ 近似。因此，整体浮力频率的平方是：\n$$ N^2_{bulk} = \\frac{g}{\\rho_0} \\frac{\\rho(z) - \\rho(0)}{z} $$\n此项的单位为 $\\mathrm{s}^{-2}$，量化了该层上的平均层结。\n\n同样，速度梯度 $\\frac{\\partial U}{\\partial z}$ 和 $\\frac{\\partial V}{\\partial z}$ 分别由 $\\frac{U(z) - U(0)}{z-0}$ 和 $\\frac{V(z) - V(0)}{z-0}$ 近似。则整体切变的平方是：\n$$ S^2_{bulk} = \\left(\\frac{U(z) - U(0)}{z}\\right)^2 + \\left(\\frac{V(z) - V(0)}{z}\\right)^2 = \\frac{(U(z) - U(0))^2 + (V(z) - V(0))^2}{z^2} $$\n此项的单位也为 $\\mathrm{s}^{-2}$，代表了该层上的平均切变。\n\n整体理查森数 $Ri_b(z)$ 是这些整体量的比值。它是一个无量纲参数，定义于 $z>0$：\n$$ Ri_b(z) = \\frac{N^2_{bulk}}{S^2_{bulk}} = \\frac{\\frac{g}{\\rho_0} \\frac{\\rho(z) - \\rho(0)}{z}}{\\frac{(U(z) - U(0))^2 + (V(z) - V(0))^2}{z^2}} $$\n通过简化表达式，我们得到要实现的公式：\n$$ Ri_b(z) = \\frac{g z (\\rho(z) - \\rho(0))}{\\rho_0 \\left[ (U(z) - U(0))^2 + (V(z) - V(0))^2 \\right]} $$\n分母代表速度差的平方，如果深度 $z$ 处的速度与海面速度相同，则分母可能为零。为确保数值稳定性，如果此分母为零，则通过添加一个小的下限值 $\\epsilon = 10^{-12}$ 对其进行正则化。\n\n在建立了 $Ri_b(z)$ 的公式后，用于诊断一组离散垂直剖面的边界层深度 $h$ 的数值步骤如下：\n1. 对于在深度网格 $z_k$（其中 $k=0, 1, \\dots, N$ 且 $z_0 = 0$）上给定的剖面 $U(z_k)$、$V(z_k)$ 和 $\\rho(z_k)$，计算每个深度 $z_k$（其中 $k > 0$）处的 $Ri_b(z_k)$ 值。\n2. 临界理查森数为 $Ri_{b,cr} = 0.3$。边界层深度 $h$ 是通过找到 $Ri_b(z)$ 超过此阈值的最浅深度来确定的。\n3. 搜索从海面下的第一个网格点 $z_1$ 开始。如果 $Ri_b(z_1) > Ri_{b,cr}$，则认为边界层无限薄，我们设 $h = 0\\,\\mathrm{m}$。\n4. 如果 $Ri_b(z_1) \\le Ri_{b,cr}$，我们向下迭代以找到第一个满足 $Ri_b(z_k) \\le Ri_{b,cr}$ 和 $Ri_b(z_{k+1}) > Ri_{b,cr}$ 的索引 $k \\ge 1$。\n5. 然后通过在深度 $z_k$ 和 $z_{k+1}$ 之间的 $Ri_b(z)$ 剖面上进行线性插值来找到边界层深度 $h$。$h$ 的值是插值得到的理查森数等于 $Ri_{b,cr}$ 时的深度：\n    $$ h = z_k + (z_{k+1} - z_k) \\frac{Ri_{b,cr} - Ri_b(z_k)}{Ri_b(z_{k+1}) - Ri_b(z_k)} $$\n6. 如果在给定域中的任何 $k$ 都未满足条件 $Ri_b(z_k) > Ri_{b,cr}$，则意味着整个水柱都在边界层内。在这种情况下，$h$ 被设为最深的可用深度 $z_N$。\n\n这个基于原理的严谨程序被应用于三个测试案例中的每一个，以确定 $h_A$、$h_B$ 和 $h_C$ 的值。最终结果按要求四舍五入到三位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve for the boundary layer depth for three test cases.\n    \"\"\"\n\n    def calculate_bld(z_vals, U_func, V_func, rho_func):\n        \"\"\"\n        Calculates the boundary layer depth (h) for a given set of profiles.\n\n        Args:\n            z_vals (np.ndarray): Array of depths (m), starting from z=0.\n            U_func (callable): Function for U-velocity profile U(z).\n            V_func (callable): Function for V-velocity profile V(z).\n            rho_func (callable): Function for density profile rho(z).\n\n        Returns:\n            float: The calculated boundary layer depth in meters.\n        \"\"\"\n        g = 9.81\n        rho0 = 1025.0\n        Ri_b_cr = 0.3\n        epsilon = 1e-12\n\n        # Generate profiles from the functions\n        U_vals = U_func(z_vals)\n        V_vals = V_func(z_vals)\n        rho_vals = rho_func(z_vals)\n\n        # Extract surface values (at z=0)\n        U_s = U_vals[0]\n        V_s = V_vals[0]\n        rho_s = rho_vals[0]\n\n        # The bulk Richardson number is not defined at z=0.\n        # We compute it for all depths z > 0.\n        z_eff = z_vals[1:]\n        if len(z_eff) == 0:\n            return 0.0\n\n        # Calculate differences relative to the surface\n        delta_U = U_vals[1:] - U_s\n        delta_V = V_vals[1:] - V_s\n        delta_rho = rho_vals[1:] - rho_s\n        \n        # Calculate bulk Richardson number profile\n        # Numerator: g * z * (rho(z) - rho_s) / rho0\n        numerators = (g * z_eff / rho0) * delta_rho\n        \n        # Denominator: (U(z) - U_s)^2 + (V(z) - V_s)^2\n        denominators = delta_U**2 + delta_V**2\n        # Apply numerical floor to avoid division by zero\n        denominators[denominators == 0] = epsilon\n        \n        Ri_b_vals = numerators / denominators\n        \n        # Check if the BLD is shallower than the first grid point\n        if Ri_b_vals[0] > Ri_b_cr:\n            return 0.0\n\n        # Find the first index where Ri_b exceeds the critical value\n        crossing_idx = -1\n        # The loop iterates up to the second to last element of Ri_b_vals\n        for i in range(len(Ri_b_vals) - 1):\n            if Ri_b_vals[i] = Ri_b_cr and Ri_b_vals[i+1] > Ri_b_cr:\n                crossing_idx = i\n                break\n        \n        # If no crossing is found, the BLD is the deepest point in the domain\n        if crossing_idx == -1:\n            # Check the last point as well\n            if Ri_b_vals[-1] = Ri_b_cr:\n                return z_eff[-1]\n            # This case should be handled by the loop, but as a fallback\n            # if only one point and it's below Ri_cr\n            if len(Ri_b_vals) == 1 and Ri_b_vals[0] = Ri_b_cr:\n                 return z_eff[0]\n            # If the last point itself was the crossing point (from a value = Ri_b_cr)\n            # This should have been caught, but as a safe guard:\n            return z_eff[-1]\n\n\n        # A crossing was found, perform linear interpolation\n        # Points for interpolation are (z, Ri_b)\n        z_i = z_eff[crossing_idx]\n        z_i_plus_1 = z_eff[crossing_idx + 1]\n        \n        Ri_b_i = Ri_b_vals[crossing_idx]\n        Ri_b_i_plus_1 = Ri_b_vals[crossing_idx + 1]\n        \n        # Linear interpolation formula to find h where Ri_b(h) = Ri_b_cr\n        h = z_i + (z_i_plus_1 - z_i) * (Ri_b_cr - Ri_b_i) / (Ri_b_i_plus_1 - Ri_b_i)\n        \n        return h\n\n    # --- Define Test Cases ---\n\n    # Case A: General case with a pycnocline\n    z_A = np.arange(0, 61, 1, dtype=float)\n    U_A = lambda z: 0.5 - 0.005 * z\n    V_A = lambda z: 0.002 * z\n    rho_A = lambda z: 1023.5 + 0.005 * z + 0.4 / (1 + np.exp(-(z - 25) / 3))\n\n    # Case B: Neutral stratification with weak shear\n    z_B = np.arange(0, 51, 2, dtype=float)\n    U_B = lambda z: 0.2 - 0.001 * z\n    V_B = lambda z: np.zeros_like(z)\n    rho_B = lambda z: np.full_like(z, 1025.0)\n\n    # Case C: Strong stable stratification with very weak shear\n    z_C = np.arange(0, 101, 5, dtype=float)\n    U_C = lambda z: 0.1 - 0.0005 * z\n    V_C = lambda z: np.zeros_like(z)\n    rho_C = lambda z: 1024.0 + 0.01 * z\n    \n    test_cases = [\n        (z_A, U_A, V_A, rho_A),\n        (z_B, U_B, V_B, rho_B),\n        (z_C, U_C, V_C, rho_C),\n    ]\n\n    results = []\n    for z_vals, U_func, V_func, rho_func in test_cases:\n        h = calculate_bld(z_vals, U_func, V_func, rho_func)\n        results.append(h)\n\n    # Format the final output as specified\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在数值模型中，离散化网格的分辨率会直接影响物理过程诊断的准确性。上一个练习中实现的简单算法在粗分辨率网格上会产生被称为“量化误差”的人为偏差。本练习旨在解决这一实际问题，要求您设计并实现一种更稳健的算法，通过使用单调插值技术来获得次网格精度的边界层深度。 通过这个练习，您将学会如何识别和修正数值伪影，这是开发可靠海洋模型的关键一步。",
            "id": "3807622",
            "problem": "考虑在 K-剖面参数化 (KPP) 中对海洋表面边界层深度的诊断，其中边界层深度 $h$ 定义为整体理查森数 $Ri_b(z)$ 超过临界值 $Ri_c$ 的最小深度 $z$。在 Boussinesq 近似下，浮力定义为 $B = -g(\\rho - \\rho_0)/\\rho_0$，其中 $g$ 为重力加速度。梯度理查森数 $Ri_g$ 定义为 $Ri_g = N^2/S^2$，其中 $N^2 = \\partial B/\\partial z$ 是浮力频率的平方，$S^2 = (\\partial U/\\partial z)^2 + (\\partial V/\\partial z)^2$ 是水平速度垂直切变大小的平方。整体理查森数 $Ri_b(z)$ 是通过对从表面 $z=0$ 到深度 $z$ 的层使用浮力差和速度差进行有限差分来构造的。在典型的 KPP 实现中，一个常用的整体理查森数表示为\n$$\nRi_b(z) = \\frac{\\left[B(z) - B(0)\\right]\\,z}{\\left[U(z)-U(0)\\right]^2 + \\left[V(z)-V(0)\\right]^2},\n$$\n它是无量纲的，而 $h$ 被诊断为满足 $Ri_b(z) \\ge Ri_c$ 的最小深度 $z$。Mellor-Yamada (MY) 湍流闭合方案支持在稳定分层条件下稳定性度量随深度单调增加的观点，而 KPP 则使用在模型网格上离散化的整体判据。\n\n当在间距为 $\\Delta z$ 的离散垂直网格上计算 $Ri_b(z)$ 时，将 $h$ 诊断为第一个满足 $Ri_b \\ge Ri_c$ 的网格深度会产生以 $\\Delta z$ 为增量的人为量化。这种网格间距敏感性可能会在粗分辨率模型中导致湍流混合估计出现偏差。\n\n从上述基本定义出发，推导 $Ri_b(z)$ 的离散公式，解释为什么粗糙的垂直间距 $\\Delta z$ 会在 $h$ 中产生量化，然后设计一个算法来减轻这种量化。该算法通过构建 $Ri_b(z)$ 的单调包络并应用保形的单调插值来定位 $Ri_c$ 的次网格穿越点。您的算法必须对由局部切变变化引起的非单调逐点 $Ri_b(z)$ 具有鲁棒性，并应以 $\\mathrm{m}$ 为单位返回 $h$。\n\n请将您的算法实现在一个完整的、可运行的程序中，该程序为下面的每个测试用例计算两个诊断量：\n- 一个朴素深度 $h_{\\text{naive}}$，定义为满足 $Ri_b(z_k) \\ge Ri_c$ 的最小网格深度 $z_k$；如果网格上不存在穿越点，则返回 $-1.0$。\n- 一个改进深度 $h_{\\text{improved}}$，通过以下方式找到：构建累积最大值包络 $\\widehat{Ri}_b(z_k) = \\max_{j \\le k} Ri_b(z_j)$ 以强制非递减行为，然后对 $\\{(z_k, \\widehat{Ri}_b(z_k))\\}$ 使用单调分段三次 Hermite 插值，以在包络首次超过 $Ri_c$ 的包围区间内定位 $\\widehat{Ri}_b(z) - Ri_c = 0$ 的次网格根；如果不存在穿越点，则返回 $-1.0$。\n\n对所有情况使用以下常量：\n- 临界整体理查森数 $Ri_c = 0.3$ (无量纲)。\n- 表面水平速度分量 $U(0) = U_0$ 和 $V(0) = V_0$，按每个案例指定。\n- 如果分母 $\\left[U(z)-U(0)\\right]^2 + \\left[V(z)-V(0)\\right]^2$ 在 $z=0$ 处为零，则设置 $Ri_b(0) = 0$，并在其他深度的分母中使用一个小的正则化项 $\\epsilon = 10^{-12}$ 以确保数值安全。\n\n对于每个测试用例，垂直网格 $\\{z_k\\}$、浮力 $B(z)$ 以及水平速度 $U(z)$ 和 $V(z)$ 指定如下。所有深度单位为 $\\mathrm{m}$，速度单位为 $\\mathrm{m/s}$，浮力单位为 $\\mathrm{m/s^2}$。对于每个案例，程序应构建数组 $z_k$、$B_k = B(z_k)$、$U_k = U(z_k)$ 和 $V_k = V(z_k)$，然后计算 $Ri_b(z_k)$ 和两个诊断量。\n\n测试套件：\n- 案例 1 (理想情况，中等分辨率): $z_k = [0,5,10,15,20,25,30,35,40,45,50]$, $U_0 = 0.5$, $V_0 = 0.0$, $U(z) = U_0 - 0.06\\sqrt{z} - 0.001z$, $V(z) = 0.0$, $B(z) = 0 + (1.2\\times 10^{-4})\\,z$.\n- 案例 2 (粗分辨率，穿越点在粗糙层级之间): $z_k = [0,20,40,60,80,100]$, $U_0 = 0.4$, $V_0 = 0.0$, $U(z) = U_0 - 0.08\\sqrt{z} - 0.0005z$, $V(z) = 0.0$, $B(z) = 0 + (3\\times 10^{-5})\\,z$.\n- 案例 3 (网格上接近边界的穿越点): $z_k = [0,10,20,30,40,50,60,70]$, $U_0 = 0.5$, $V_0 = 0.0$, $U(z) = U_0 - 0.05\\sqrt{z} - 0.0015z$, $V(z) = 0.0$, $B(z) = 0 + (7\\times 10^{-5})\\,z$.\n- 案例 4 (由于切变反转导致的非单调逐点 $Ri_b$): $z_k = [0,5,10,15,20,25,30,35,40,45,50,55]$, $U_0 = 0.6$, $V_0 = 0.0$, $U(z) = U_0 - 0.02z + 0.0002z^2$, $V(z) = 0.0$, $B(z) = 0 + (1\\times 10^{-4})\\,z$.\n- 案例 5 (剖面内无穿越点): $z_k = [0,10,20,30,40,50,60,70,80]$, $U_0 = 0.6$, $V_0 = 0.0$, $U(z) = U_0 - 0.03z$, $V(z) = 0.0$, $B(z) = 0 + (5\\times 10^{-5})\\,z$.\n\n您的程序必须：\n- 使用上述公式计算每个案例的 $Ri_b(z_k)$。\n- 计算每个案例的 $h_{\\text{naive}}$ 和 $h_{\\text{improved}}$，单位为 $\\mathrm{m}$，四舍五入到 $2$ 位小数。\n- 对于没有穿越点的情况，两个诊断量都返回 $-1.0$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素都应是两个浮点数的列表 $[h_{\\text{naive}}, h_{\\text{improved}}]$，单位为 $\\mathrm{m}$，按案例顺序排列。例如：$[[10.00,9.12],[\\dots,\\dots],\\dots]$。",
            "solution": "该问题要求设计并实现两种算法来诊断海洋表面边界层深度，记为 $h$。在 K-剖面参数化 (KPP) 框架内，该深度被定义为整体理查森数 $Ri_b(z)$ 首次超过临界值 $Ri_c$ 的最浅深度 $z$。我们的任务是实现一种“朴素的”基于网格的诊断方法，以及一种“改进的”次网格精度的诊断方法，后者可以减轻离散数值模型中固有的量化误差。\n\n### 1. 整体理查森数的离散公式\n\n所提供的整体理查森数的连续定义是：\n$$\nRi_b(z) = \\frac{\\left[B(z) - B(0)\\right]\\,z}{\\left[U(z)-U(0)\\right]^2 + \\left[V(z)-V(0)\\right]^2}\n$$\n其中 $z$ 是深度（向下为正），$B(z)$ 是浮力，$U(z), V(z)$ 是水平速度分量。这个无量纲数比较了从表面到深度 $z$ 的层上的浮力分层效应与同一层上的速度切变不稳定效应。\n\n对于数值实现，海洋属性仅在离散的网格点 $z_k$ (其中 $k=0, 1, 2, \\dots, N-1$，$z_0=0$ 是表面)上是已知的。设浮力和速度的相应值为 $B_k=B(z_k)$, $U_k=U(z_k)$, $V_k=V(z_k)$。在每个网格深度 $z_k$ 处的离散整体理查森数计算如下：\n$$\nRi_{b,k} = Ri_b(z_k) = \\frac{(B_k - B_0) z_k}{(U_k - U_0)^2 + (V_k - V_0)^2}\n$$\n在表面 $z_0=0$ 处，分子为零，使得按规定 $Ri_{b,0}=0$。对于 $k0$，分母代表与表面的速度平方差，可能非常小，导致数值不稳定性。为防止除以零或出现过大的值，在分母中加入一个小的正则化项 $\\epsilon  0$：\n$$\nRi_{b,k} = \\frac{(B_k - B_0) z_k}{(U_k - U_0)^2 + (V_k - V_0)^2 + \\epsilon} \\quad \\text{for } k  0\n$$\n对于此问题，$\\epsilon=10^{-12}$。\n\n### 2. 量化问题与朴素深度诊断\n\n确定边界层深度 $h_{\\text{naive}}$ 的朴素方法直接遵循定义的离散版本。它识别出第一个满足稳定性判据的网格点 $z_k$。\n$$\nh_{\\text{naive}} = \\min \\{z_k \\mid Ri_{b,k} \\ge Ri_c\\}\n$$\n如果对于任何 $k$ 都不满足条件 $Ri_{b,k} \\ge Ri_c$，则在给定的剖面内未检测到穿越点，深度被认为是未定义的（返回为 $-1.0$）。\n\n这种方法的主要缺陷是其对垂直网格分辨率的敏感性。诊断出的深度 $h_{\\text{naive}}$ 只能是离散值 $\\{z_k\\}$ 之一。如果 $Ri_b(z)$ 穿越 $Ri_c$ 的真实物理深度位于两个网格点之间，例如 $z_k$ 和 $z_{k+1}$，朴素算法将报告更深的值 $z_{k+1}$。在网格间距 $\\Delta z_k = z_{k+1} - z_k$ 较大的粗分辨率模型中，这可能导致对边界层深度的显著高估。这种系统性偏差，称为量化误差，可能对海洋中垂直混合和热量输送的模拟产生不利影响。\n\n### 3. 一种改进的、次网格精度的算法\n\n为了克服量化误差，我们设计了一种能够以次网格精度确定穿越深度的算法。这包括两个主要步骤：强制单调性和应用保形插值。\n\n#### a. 强制单调性\n\n在一个物理上真实的、稳定分层的海洋中，由 $Ri_b(z)$ 测量的整体稳定性预计是深度 $z$ 的一个非递减函数。然而，由于局部切变特征或数值伪影，离散网格上 $Ri_{b,k}$ 的逐点计算可能表现出非单调行为。一个非单调的剖面可能在多个深度处有 $Ri_{b,k}$ 穿越 $Ri_c$，导致边界层深度模糊不清。\n\n为确保诊断的唯一性和物理一致性，我们构造了 $Ri_b$ 剖面的一个单调包络。这个包络记为 $\\widehat{Ri}_{b,k}$，定义为逐点值的累积最大值：\n$$\n\\widehat{Ri}_{b,k} = \\max_{j \\le k} Ri_{b,j}\n$$\n此操作保证了得到的剖面 $\\{\\widehat{Ri}_{b,k}\\}$ 是关于索引 $k$ (因此也是关于深度 $z_k$) 的非递减函数。这强制了物理上的预期，即如果水柱在某个深度处足够稳定以终止边界层，那么在所有更深的深度处它至少保持同样的稳定性。使用这个包络使算法具有鲁棒性，正如要求的那样。虽然测试套件中的案例4被标记为“非单调”，但所提供的具体函数在给定域内数学上会产生一个单调的 $Ri_b(z)$ 剖面。尽管如此，该算法正确地实现了累积最大值，确保了其在一般情况下的鲁棒性。\n\n#### b. 保形插值与求根\n\n有了单调剖面 $(\\{z_k\\}, \\{\\widehat{Ri}_{b,k}\\})$，我们现在可以找到次网格深度 $h_{\\text{improved}}$。第一步是确定包围区间。我们搜索最小的索引 $k \\ge 1$ 使得 $\\widehat{Ri}_{b,k} \\ge Ri_c$。这意味着穿越发生在深度 $z_{k-1}$ 和 $z_k$ 之间，因为我们有 $\\widehat{Ri}_{b,k-1}  Ri_c \\le \\widehat{Ri}_{b,k}$。\n\n为了找到这个区间内的精确深度，我们采用单调分段三次 Hermite 插值器 (PCHIP)。该方法为每个段 $[z_k, z_{k+1}]$ 拟合一个三次多项式，同时确保整个插值函数是连续可微的，并且关键地，保持了输入数据的单调性。这可以防止像样条等其他高阶插值方案可能引入的人为振荡。\n\n令 $P(z)$ 为数据点 $(z_k, \\widehat{Ri}_{b,k})$ 的 PCHIP 插值函数。改进的边界层深度 $h_{\\text{improved}}$ 是方程的根：\n$$\nP(z) - Ri_c = 0\n$$\n由于 $P(z)$ 在包围区间 $[z_{k-1}, z_k]$ 内是单调的，因此保证存在唯一的根。我们可以使用数值求根算法（如 Brent 方法）高效地找到这个根，该方法非常适合在已知包围区间内寻找根。如果没有索引 $k$ 满足 $\\widehat{Ri}_{b,k} \\ge Ri_c$，则边界层比剖面域更深，$h_{\\text{improved}}$ 将返回为 $-1.0$。此过程产生的边界层深度与网格分辨率无关，解决了量化问题。",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes naive and improved KPP boundary layer depths for a suite of test cases.\n    \"\"\"\n\n    # Constants\n    Ri_c = 0.3\n    epsilon = 1e-12\n\n    # Test case definitions: (z_k, U0, V0, U_func, V_func, B_func)\n    test_cases = [\n        {\n            \"z_k\": np.array([0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50], dtype=float),\n            \"U0\": 0.5, \"V0\": 0.0,\n            \"U_func\": lambda z, U0: U0 - 0.06 * np.sqrt(z) - 0.001 * z,\n            \"V_func\": lambda z, V0: 0.0,\n            \"B_func\": lambda z: 1.2e-4 * z\n        },\n        {\n            \"z_k\": np.array([0, 20, 40, 60, 80, 100], dtype=float),\n            \"U0\": 0.4, \"V0\": 0.0,\n            \"U_func\": lambda z, U0: U0 - 0.08 * np.sqrt(z) - 0.0005 * z,\n            \"V_func\": lambda z, V0: 0.0,\n            \"B_func\": lambda z: 3e-5 * z\n        },\n        {\n            \"z_k\": np.array([0, 10, 20, 30, 40, 50, 60, 70], dtype=float),\n            \"U0\": 0.5, \"V0\": 0.0,\n            \"U_func\": lambda z, U0: U0 - 0.05 * np.sqrt(z) - 0.0015 * z,\n            \"V_func\": lambda z, V0: 0.0,\n            \"B_func\": lambda z: 7e-5 * z\n        },\n        {\n            \"z_k\": np.array([0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55], dtype=float),\n            \"U0\": 0.6, \"V0\": 0.0,\n            \"U_func\": lambda z, U0: U0 - 0.02 * z + 0.0002 * z**2,\n            \"V_func\": lambda z, V0: 0.0,\n            \"B_func\": lambda z: 1e-4 * z\n        },\n        {\n            \"z_k\": np.array([0, 10, 20, 30, 40, 50, 60, 70, 80], dtype=float),\n            \"U0\": 0.6, \"V0\": 0.0,\n            \"U_func\": lambda z, U0: U0 - 0.03 * z,\n            \"V_func\": lambda z, V0: 0.0,\n            \"B_func\": lambda z: 5e-5 * z\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        z = case[\"z_k\"]\n        # Generate profiles on the grid\n        U_profile = case[\"U_func\"](z, case[\"U0\"])\n        V_profile = case[\"V_func\"](z, case[\"V0\"]) * np.ones_like(z)\n        B_profile = case[\"B_func\"](z)\n\n        # Calculate Bulk Richardson number profile\n        delta_U = U_profile - case[\"U0\"]\n        delta_V = V_profile - case[\"V0\"]\n        delta_B = B_profile - B_profile[0]\n        \n        denominator = delta_U**2 + delta_V**2\n        \n        Ri_b = np.zeros_like(z)\n        # Avoid division by zero for z > 0\n        mask = z > 0\n        Ri_b[mask] = (delta_B[mask] * z[mask]) / (denominator[mask] + epsilon)\n        \n        # --- Naive Depth Calculation ---\n        naive_crossing_indices = np.where(Ri_b >= Ri_c)[0]\n        if naive_crossing_indices.size > 0:\n            h_naive = z[naive_crossing_indices[0]]\n        else:\n            h_naive = -1.0\n\n        # --- Improved Depth Calculation ---\n        # 1. Construct monotonic envelope\n        Ri_b_hat = np.maximum.accumulate(Ri_b)\n        \n        # 2. Find first crossing of the envelope\n        improved_crossing_indices = np.where(Ri_b_hat >= Ri_c)[0]\n        \n        if improved_crossing_indices.size > 0:\n            k = improved_crossing_indices[0]\n            if k == 0:\n                # Crossing at the surface, though unlikely given Ri_b(0)=0\n                h_improved = 0.0\n            else:\n                # 3. Interpolate and find root in the bracketing interval\n                z_bracket = [z[k-1], z[k]]\n                \n                # Create a callable PCHIP interpolator\n                pchip = PchipInterpolator(z, Ri_b_hat, extrapolate=False)\n                \n                # Define a function whose root is the desired depth\n                def func_to_solve(depth):\n                    return pchip(depth) - Ri_c\n                \n                try:\n                    h_improved = brentq(func_to_solve, z_bracket[0], z_bracket[1])\n                except ValueError:\n                    # This can happen if values at bracket endpoints are not of opposite sign,\n                    # e.g., if Ri_b_hat[k-1] > Ri_c due to floating point nuances.\n                    # In that case, the crossing is at or before z[k-1]\n                    # Since k is the first index, it must be exactly somewhere at k-1.\n                    # However, given the logic, brentq should not fail.\n                    h_improved = -1.0 # Should not be reached\n        else:\n            h_improved = -1.0\n            \n        results.append([h_naive, h_improved])\n\n    # Format output\n    output_str = \",\".join([f\"[{hn:.2f},{hi:.2f}]\" for hn, hi in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "KPP方案的一个显著特征是包含了非局地输运项，用以模拟由大型相干涡旋驱动的、无法通过局地梯度描述的混合过程。然而，在数值上实现这一过程时，必须严格遵守一个基本物理定律：守恒性。本练习将引导您对比两种不同的数值实现方法，阐明为何基于通量散度的守恒格式远优于朴素的源汇项方法。 这项实践将揭示数值方案的结构选择如何直接影响模型的物理真实性，确保模型不会凭空产生或消灭示踪剂。",
            "id": "3807656",
            "problem": "考虑一个一维垂直海洋柱，其深度坐标 $z$ 从表面 $z=0$ 开始向下为正，一直延伸到海底 $z=H$。假设该海洋柱被离散化为 $N$ 个有限体积单元，单元厚度为 $\\Delta z_i$（$i=1,\\dots,N$），单元界面位于深度 $z_{i-\\frac{1}{2}}$（$i=1,\\dots,N+1$），其中 $z_{\\frac{1}{2}}=0$ 且 $z_{N+\\frac{1}{2}}=H$。设预报量为位温 $\\theta$，单位为 $\\mathrm{K}$。一维示踪剂守恒定律由垂直通量形式给出：$\\partial \\theta / \\partial t = - \\partial F / \\partial z$，其中 $F$（单位为 $\\mathrm{K}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$）是 $\\theta$ 的垂直通量。\n\n在 K-Profile Parameterization (KPP) 中，非局地输运由一个非局地通量项表示，该项将规定的表面通量在厚度为 $h$ 的湍流边界层内向下重新分配。假设没有底部通量，也没有 $\\theta$ 的内部产生或消耗。设在 $z=0$ 处施加的 $\\theta$ 表面通量为一个常数 $Q_\\theta$（单位为 $\\mathrm{K}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$），方向指向海洋内部（向下）。构建一个非局地通量廓线 $F^{\\mathrm{nl}}(z)$，使得 $F^{\\mathrm{nl}}(0) = Q_\\theta$，$F^{\\mathrm{nl}}(h) = 0$，$zh$ 时 $F^{\\mathrm{nl}}(z)=0$，并且 $F^{\\mathrm{nl}}(z)$ 在 $0 \\le z \\le h$ 范围内平滑变化。使用定义在 $0 \\le \\sigma \\le 1$ 上的三次形状函数 $S(\\sigma) = 1 - 3\\sigma^2 + 2\\sigma^3$（其中 $\\sigma = z/h$）来构建 $F^{\\mathrm{nl}}(z)$：当 $0 \\le z \\le h$ 时，$F^{\\mathrm{nl}}(z) = Q_\\theta \\, S(z/h)$；当 $zh$ 时，$F^{\\mathrm{nl}}(z) = 0$。\n\n您的任务是在给定的有限体积网格上，为 $\\theta$ 的非局地输运实现两种离散表示方法：\n\n1. 一种保守的通量散度实现，它将由非局地项引起的单元趋势项计算为单元界面处非局地通量的离散散度，即对每个单元 $i$ 计算 $-(F^{\\mathrm{nl}}_{i+\\frac{1}{2}} - F^{\\mathrm{nl}}_{i-\\frac{1}{2}})/\\Delta z_i$。\n\n2. 一种简单的基于源项的实现，它分配一个与单元中心处形状函数值成正比的内部源项，即当 $z_i \\le h$ 时为 $(Q_\\theta/h) \\, S(z_i/h)$，否则为 $0$，其中 $z_i$ 是单元 $i$ 中心的深度。\n\n对于每种实现，计算由非局地项引起的 $\\theta$ 的整柱积分瞬时变化率，\n$$\n\\mathcal{R} = \\sum_{i=1}^{N} \\left( \\frac{\\partial \\theta_i}{\\partial t} \\right) \\Delta z_i,\n$$\n并将其与边界通量的期望值 $Q_\\theta - 0$（单位 $\\mathrm{K}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$）进行比较，该期望值由守恒定律在整柱上积分 $\\int_0^H \\partial \\theta / \\partial t \\, dz = F(0) - F(H)$ 得出。\n\n对于每个测试用例，您必须输出两个浮点数：\n- 保守通量散度实现的绝对守恒误差，即 $|\\mathcal{R}_{\\mathrm{cons}} - Q_\\theta|$，单位为 $\\mathrm{K}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- 简单源项实现的绝对守恒误差，即 $|\\mathcal{R}_{\\mathrm{naive}} - Q_\\theta|$，单位为 $\\mathrm{K}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\dots]$），结果按每个测试用例成对排列：首先是保守实现的误差，然后是简单实现的误差，依此类推，涵盖所有测试用例。\n\n测试套件：\n请使用以下科学上合理且自洽的参数集。对于均匀网格，所有 $i$ 均取 $\\Delta z_i = H/N$。\n\n- 测试用例 1：$H=50\\,\\mathrm{m}$，$N=50$，$h=30\\,\\mathrm{m}$，$Q_\\theta=2\\times 10^{-7}\\,\\mathrm{K}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- 测试用例 2：$H=50\\,\\mathrm{m}$，$N=10$，$h=50\\,\\mathrm{m}$，$Q_\\theta=-1\\times 10^{-7}\\,\\mathrm{K}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- 测试用例 3：$H=100\\,\\mathrm{m}$，$N=100$，$h=5\\,\\mathrm{m}$，$Q_\\theta=5\\times 10^{-8}\\,\\mathrm{K}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- 测试用例 4：非均匀网格，其中 $N=30$，单元厚度 $\\Delta z_i$ 由以下方式给出：当 $i=1,\\dots,10$ 时 $\\Delta z_i=1\\,\\mathrm{m}$，当 $i=11,\\dots,30$ 时 $\\Delta z_i=2\\,\\mathrm{m}$（因此 $H=\\sum_{i=1}^{30}\\Delta z_i=50\\,\\mathrm{m}$），$h=20\\,\\mathrm{m}$ 且 $Q_\\theta=3\\times 10^{-7}\\,\\mathrm{K}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- 测试用例 5：$H=80\\,\\mathrm{m}$，$N=80$，$h=20\\,\\mathrm{m}$，$Q_\\theta=0\\,\\mathrm{K}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n\n您的程序必须实现上述两种方法，为每个测试用例计算 $|\\mathcal{R}_{\\mathrm{cons}} - Q_\\theta|$ 和 $|\\mathcal{R}_{\\mathrm{naive}} - Q_\\theta|$（单位为 $\\mathrm{K}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$），并按指定的单行格式打印结果。",
            "solution": "该问题要求基于 K-Profile Parameterization (KPP) 实现并验证两种用于表示一维海洋柱中非局地示踪剂输运的数值方案。其核心原理是位温 $\\theta$ 的守恒。\n\n示踪剂 $\\theta$ 的连续一维守恒定律由以下公式给出：\n$$\n\\frac{\\partial \\theta}{\\partial t} = - \\frac{\\partial F}{\\partial z}\n$$\n为了求出深度为 $H$ 的海洋柱内 $\\theta$ 的总变化率，我们将此方程从表面（$z=0$）积分到底部（$z=H$）：\n$$\n\\int_0^H \\frac{\\partial \\theta}{\\partial t} dz = \\int_0^H \\left(-\\frac{\\partial F}{\\partial z}\\right) dz = -[F(z)]_0^H = F(0) - F(H)\n$$\n这一基本结果表明，一个守恒量的整柱积分变化率完全等于跨越其边界的净通量。\n\n在此问题中，通量为非局地通量 $F^{\\mathrm{nl}}(z)$。我们已知表面通量为 $F^{\\mathrm{nl}}(0) = Q_\\theta$，且没有底部通量。结合当 $zh$ 时 $F^{\\mathrm{nl}}(z)=0$ 的定义，这意味着在所有测试用例中（其中 $H \\ge h$），$F^{\\mathrm{nl}}(H) = 0$。因此，精确的整柱积分变化率必须是：\n$$\n\\int_0^H \\frac{\\partial \\theta}{\\partial t} dz = Q_\\theta - 0 = Q_\\theta\n$$\n该积分的数值对应形式是遍历所有 $N$ 个网格单元的离散求和：\n$$\n\\mathcal{R} = \\sum_{i=1}^{N} \\left( \\frac{\\partial \\theta_i}{\\partial t} \\right) \\Delta z_i\n$$\n目标是为两种提出的数值实现计算绝对守恒误差 $|\\mathcal{R} - Q_\\theta|$。\n\n**1. 保守的通量散度实现**\n\n该方法直接离散化通量散度项。单元 $i$ 的趋势项为：\n$$\n\\left( \\frac{\\partial \\theta_i}{\\partial t} \\right)_{\\mathrm{cons}} = -\\frac{F^{\\mathrm{nl}}_{i+\\frac{1}{2}} - F^{\\mathrm{nl}}_{i-\\frac{1}{2}}}{\\Delta z_i}\n$$\n其中 $F^{\\mathrm{nl}}_{i\\pm\\frac{1}{2}}$ 是在单元界面上计算的非局地通量。整柱积分变化率为：\n$$\n\\mathcal{R}_{\\mathrm{cons}} = \\sum_{i=1}^{N} \\left( -\\frac{F^{\\mathrm{nl}}_{i+\\frac{1}{2}} - F^{\\mathrm{nl}}_{i-\\frac{1}{2}}}{\\Delta z_i} \\right) \\Delta z_i = -\\sum_{i=1}^{N} (F^{\\mathrm{nl}}_{i+\\frac{1}{2}} - F^{\\mathrm{nl}}_{i-\\frac{1}{2}})\n$$\n这个和是一个伸缩级数：\n$$\n\\mathcal{R}_{\\mathrm{cons}} = - \\left[ (F^{\\mathrm{nl}}_{1+\\frac{1}{2}} - F^{\\mathrm{nl}}_{\\frac{1}{2}}) + (F^{\\mathrm{nl}}_{2+\\frac{1}{2}} - F^{\\mathrm{nl}}_{1+\\frac{1}{2}}) + \\dots + (F^{\\mathrm{nl}}_{N+\\frac{1}{2}} - F^{\\mathrm{nl}}_{N-\\frac{1}{2}}) \\right] = - (F^{\\mathrm{nl}}_{N+\\frac{1}{2}} - F^{\\mathrm{nl}}_{\\frac{1}{2}})\n$$\n$$\n\\mathcal{R}_{\\mathrm{cons}} = F^{\\mathrm{nl}}_{\\frac{1}{2}} - F^{\\mathrm{nl}}_{N+\\frac{1}{2}}\n$$\n由于界面 $\\frac{1}{2}$ 位于 $z=0$，界面 $N+\\frac{1}{2}$ 位于 $z=H$，因此 $\\mathcal{R}_{\\mathrm{cons}} = F^{\\mathrm{nl}}(0) - F^{\\mathrm{nl}}(H) = Q_\\theta - 0 = Q_\\theta$。\n该方法在构造上是“保守的”，因为无论网格分辨率或通量廓线的具体形式如何，其数值求和都能精确地再现净边界通量。数值守恒误差 $|\\mathcal{R}_{\\mathrm{cons}} - Q_\\theta|$ 应为零，仅受浮点精度的限制。\n\n**2. 简单的基于源项的实现**\n\n该方法将非局地输运建模为应用于单元中心 $z_i$ 的内部源项：\n$$\n\\left( \\frac{\\partial \\theta_i}{\\partial t} \\right)_{\\mathrm{naive}} = \\frac{Q_\\theta}{h} S(z_i/h) \\quad \\text{for } z_i \\le h, \\quad \\text{and } 0 \\text{ otherwise.}\n$$\n此公式不是直接从通量散度推导而来，其守恒性质无法保证。整柱积分变化率为：\n$$\n\\mathcal{R}_{\\mathrm{naive}} = \\sum_{i \\text{ s.t. } z_i \\le h} \\left(\\frac{Q_\\theta}{h} S(z_i/h)\\right) \\Delta z_i\n$$\n这个和是对积分 $\\int_0^h \\frac{Q_\\theta}{h} S(z/h) dz$ 的一个中点法则数值近似。我们可以通过代入 $\\sigma = z/h$（得出 $dz = h \\, d\\sigma$）来解析地计算这个积分：\n$$\n\\int_0^h \\frac{Q_\\theta}{h} S(z/h) dz = \\frac{Q_\\theta}{h} \\int_0^1 S(\\sigma) (h \\, d\\sigma) = Q_\\theta \\int_0^1 (1 - 3\\sigma^2 + 2\\sigma^3) d\\sigma\n$$\n$$\n= Q_\\theta \\left[ \\sigma - \\sigma^3 + \\frac{1}{2}\\sigma^4 \\right]_0^1 = Q_\\theta \\left( 1 - 1 + \\frac{1}{2} - 0 \\right) = \\frac{1}{2}Q_\\theta\n$$\n由于这种简单方法的底层连续公式积分为 $Q_\\theta/2$ 而非 $Q_\\theta$，随着网格分辨率的提高，数值求和 $\\mathcal{R}_{\\mathrm{naive}}$ 将收敛于 $Q_\\theta/2$。该方法未能守恒在表面添加的 $\\theta$ 总量。因此，对于任何非零的 $Q_\\theta$，其守恒误差 $|\\mathcal{R}_{\\mathrm{naive}} - Q_\\theta|$ 都将是显著的，近似于 $|(Q_\\theta/2) - Q_\\theta| = |Q_\\theta/2|$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef S_shape(sigma):\n    \"\"\"\n    Computes the cubic shape function S(sigma) for sigma in [0, 1].\n    Returns 0 for sigma outside this range. This vectorized function handles\n    scalar and numpy array inputs.\n    \n    Args:\n        sigma (float or np.ndarray): The non-dimensional depth z/h.\n        \n    Returns:\n        float or np.ndarray: The value of the shape function.\n    \"\"\"\n    sigma_arr = np.asarray(sigma)\n    res = np.zeros_like(sigma_arr, dtype=float)\n    mask = (sigma_arr >= 0)  (sigma_arr = 1)\n    s_masked = sigma_arr[mask]\n    res[mask] = 1.0 - 3.0 * s_masked**2 + 2.0 * s_masked**3\n    return res\n\ndef F_nl(z_coords, h_val, Q_theta_val):\n    \"\"\"\n    Computes the nonlocal flux F_nl(z) = Q_theta * S(z/h) for z = h.\n    The flux is zero for z > h.\n    \n    Args:\n        z_coords (float or np.ndarray): The depth coordinate(s).\n        h_val (float): The boundary layer depth.\n        Q_theta_val (float): The surface flux of potential temperature.\n        \n    Returns:\n        float or np.ndarray: The nonlocal flux at the given depth(s).\n    \"\"\"\n    z_coords_arr = np.asarray(z_coords)\n    if h_val == 0:\n        return np.where(z_coords_arr == 0, Q_theta_val, 0.0)\n    sigma = z_coords_arr / h_val\n    return Q_theta_val * S_shape(sigma)\n\ndef calculate_errors_for_case(H, N, h, Q_theta, dz_values):\n    \"\"\"\n    Calculates the conservation errors for a single test case for both\n    the conservative and naive implementations.\n    \"\"\"\n    \n    # 1. Setup the grid (cell thicknesses, face depths, and cell center depths)\n    if dz_values is None:\n        dz = np.full(N, H / N, dtype=float)\n    else:\n        dz = dz_values\n\n    face_depths = np.zeros(N + 1, dtype=float)\n    face_depths[1:] = np.cumsum(dz)\n    cell_centers = face_depths[:-1] + dz / 2.0\n\n    # 2. Conservative Flux-Divergence Implementation\n    # The column-integrated rate of change, R_cons, is the sum of tendencies\n    # times cell thickness. For a flux-divergence scheme, this sum telescopes\n    # to the net boundary flux: F(z=0) - F(z=H).\n    \n    flux_top = F_nl(face_depths[0], h, Q_theta) \n    flux_bottom = F_nl(face_depths[-1], h, Q_theta)\n    R_cons = flux_top - flux_bottom\n    error_cons = abs(R_cons - Q_theta)\n\n    # 3. Naive Source-Based Implementation\n    # The tendency is defined as a source term at cell centers. The total change\n    # is the sum of (tendency * cell thickness) over all cells.\n    \n    R_naive = 0.0\n    # The term Q_theta/h is undefined if h=0. If h=0, the boundary layer\n    # has no depth, so no interior source term exists.\n    if h > 0:\n        mask_in_bl = cell_centers = h\n        centers_in_bl = cell_centers[mask_in_bl]\n        dz_in_bl = dz[mask_in_bl]\n        \n        sigma_centers = centers_in_bl / h\n        tendencies = (Q_theta / h) * S_shape(sigma_centers)\n        \n        R_naive = np.sum(tendencies * dz_in_bl)\n\n    error_naive = abs(R_naive - Q_theta)\n    \n    return error_cons, error_naive\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases and print results in the\n    specified format.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'H': 50.0, 'N': 50, 'h': 30.0, 'Q_theta': 2e-7, 'dz_spec': None},\n        {'H': 50.0, 'N': 10, 'h': 50.0, 'Q_theta': -1e-7, 'dz_spec': None},\n        {'H': 100.0, 'N': 100, 'h': 5.0, 'Q_theta': 5e-8, 'dz_spec': None},\n        {'H': 50.0, 'N': 30, 'h': 20.0, 'Q_theta': 3e-7, \n         'dz_spec': np.concatenate([np.full(10, 1.0), np.full(20, 2.0)])},\n        {'H': 80.0, 'N': 80, 'h': 20.0, 'Q_theta': 0.0, 'dz_spec': None},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        error_cons, error_naive = calculate_errors_for_case(\n            H=case['H'],\n            N=case['N'],\n            h=case['h'],\n            Q_theta=case['Q_theta'],\n            dz_values=case['dz_spec']\n        )\n        all_results.append(error_cons)\n        all_results.append(error_naive)\n\n    # Final print statement in the exact required format.\n    # Results are formatted in scientific notation for precision and consistency.\n    print(f\"[{','.join(f'{r:.15e}' for r in all_results)}]\")\n\nsolve()\n```"
        }
    ]
}