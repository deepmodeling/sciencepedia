{
    "hands_on_practices": [
        {
            "introduction": "要理解雷迪等中性面扩散，第一步是掌握其核心几何概念：等中性面斜率。本练习将引导你从海洋状态方程和中性条件等基本物理原理出发，推导出等中性面斜率的表达式，并通过一个实际的海洋学场景进行计算。这个基础练习对于将抽象的扩散理论与可量化的物理参数联系起来至关重要 。",
            "id": "3809728",
            "problem": "考虑海洋内部的一个局部区域，其中的小尺度示踪剂混合遵循Redi中性面扩散框架进行参数化。假设海水状态方程是线性化的，使得无穷小的密度变化遵循 $d\\rho/\\rho_{0}=-\\alpha_{T}\\,d\\theta+\\beta_{S}\\,dS$，其中 $\\rho_{0}$ 是一个常数参考密度，$\\theta$ 是位温，$S$ 是实用盐度，$\\alpha_{T}$ 是热膨胀系数，$\\beta_{S}$ 是盐缩系数。中性位移由沿着它 $d\\rho=0$ 的条件定义。将中性面局部地视为一个由标量状态函数隐式给出的光滑表面，并将在 $x$ 方向上的局部中性面斜率 $s_{x}$ 定义为该表面的几何斜率 $\\partial z/\\partial x$。从上述中性条件和线性化热力学关系出发，推导用 $\\theta$ 和 $S$ 的局地空间梯度以及系数 $\\alpha_{T}$ 和 $\\beta_{S}$ 表示的 $s_{x}$ 表达式。然后，使用以下局地测量的系数和梯度：$\\alpha_{T}=2\\times 10^{-4}\\,\\text{K}^{-1}$，$\\beta_{S}=8\\times 10^{-4}\\,\\text{(g/kg)}^{-1}$，$\\partial_{z}\\theta=-0.01\\,\\text{K/m}$，$\\partial_{z}S=2\\times 10^{-5}\\,\\text{(g/kg)/m}$，$\\partial_{x}\\theta=1\\times 10^{-5}\\,\\text{K/m}$，以及 $\\partial_{x}S=-5\\times 10^{-6}\\,\\text{(g/kg)/m}$，计算 $s_{x}$ 的数值。将 $s_{x}$ 的最终值表示为一个精确分数。在你的推理中，评论计算出的斜率与海洋环流模式（OGCMs）中遇到的典型中性面斜率相比的量级。最终答案必须是一个单一的数字；$s_{x}$ 是无量纲的。",
            "solution": "该问题要求推导中性面斜率 $s_x$，然后根据提供的海洋学数据进行数值计算。\n\n首先，我们验证问题陈述。\n已知条件如下：\n1.  线性化的状态方程：$d\\rho/\\rho_{0}=-\\alpha_{T}\\,d\\theta+\\beta_{S}\\,dS$。\n2.  中性位移的定义：$d\\rho=0$。\n3.  中性面斜率的定义：$s_{x} = \\frac{\\partial z}{\\partial x}$，沿着中性面。\n4.  系数：$\\alpha_{T}=2\\times 10^{-4}\\,\\text{K}^{-1}$，$\\beta_{S}=8\\times 10^{-4}\\,\\text{(g/kg)}^{-1}$。\n5.  局地梯度：$\\partial_{z}\\theta=-0.01\\,\\text{K/m}$，$\\partial_{z}S=2\\times 10^{-5}\\,\\text{(g/kg)/m}$，$\\partial_{x}\\theta=1\\times 10^{-5}\\,\\text{K/m}$，$\\partial_{x}S=-5\\times 10^{-6}\\,\\text{(g/kg)/m}$。\n\n该问题在科学上基于物理海洋学的成熟原理，特别是次网格尺度混合的参数化。Redi 中性面扩散框架和线性化状态方程的使用是计算海洋学中的标准做法。所有必要信息都已提供，并且给定的数值对于海洋内部是物理上合理的，假设遵循海洋学的通常惯例，即垂直坐标 $z$ 向下为正（深度）。在此惯例下，正的垂直密度梯度 $\\partial_z\\rho > 0$ 表示静力稳定的水体。给定的梯度导致了稳定的层结，证实了问题设置的物理一致性。该问题是良定的、客观的，并且需要进行不平凡的推导和计算。因此，该问题被认为是有效的。\n\n我们现在进行求解。\n\n推导始于中性位移的条件 $d\\rho = 0$。使用所提供的线性化状态方程，这意味着：\n$$-\\alpha_{T}\\,d\\theta+\\beta_{S}\\,dS = 0$$\n位温 $\\theta$ 和盐度 $S$ 是空间坐标 $\\theta(x,z)$ 和 $S(x,z)$ 的函数，由于我们关心的是斜率 $s_x$，因此忽略了在 $y$ 方向上的任何变化。对于一个位移 $(dx, dz)$，全微分 $d\\theta$ 和 $dS$ 由下式给出：\n$$d\\theta = \\frac{\\partial \\theta}{\\partial x}dx + \\frac{\\partial \\theta}{\\partial z}dz$$\n$$dS = \\frac{\\partial S}{\\partial x}dx + \\frac{\\partial S}{\\partial z}dz$$\n将这些表达式代入中性位移条件，得到：\n$$-\\alpha_{T}\\left(\\frac{\\partial \\theta}{\\partial x}dx + \\frac{\\partial \\theta}{\\partial z}dz\\right) + \\beta_{S}\\left(\\frac{\\partial S}{\\partial x}dx + \\frac{\\partial S}{\\partial z}dz\\right) = 0$$\n该方程必须对于位于局部中性面内的任何位移 $(dx, dz)$ 都成立。为了求出該表面的斜率 $s_x = \\frac{\\partial z}{\\partial x}$，我们重排方程以求解比率 $\\frac{dz}{dx}$。首先，对包含 $dx$ 和 $dz$ 的项进行分组：\n$$\\left(-\\alpha_{T}\\frac{\\partial \\theta}{\\partial x} + \\beta_{S}\\frac{\\partial S}{\\partial x}\\right)dx + \\left(-\\alpha_{T}\\frac{\\partial \\theta}{\\partial z} + \\beta_{S}\\frac{\\partial S}{\\partial z}\\right)dz = 0$$\n重排以求解 $\\frac{dz}{dx}$：\n$$\\left(-\\alpha_{T}\\frac{\\partial \\theta}{\\partial z} + \\beta_{S}\\frac{\\partial S}{\\partial z}\\right)dz = -\\left(-\\alpha_{T}\\frac{\\partial \\theta}{\\partial x} + \\beta_{S}\\frac{\\partial S}{\\partial x}\\right)dx$$\n$$\\left(-\\alpha_{T}\\frac{\\partial \\theta}{\\partial z} + \\beta_{S}\\frac{\\partial S}{\\partial z}\\right)dz = \\left(\\alpha_{T}\\frac{\\partial \\theta}{\\partial x} - \\beta_{S}\\frac{\\partial S}{\\partial x}\\right)dx$$\n因此，中性面斜率 $s_x$ 为：\n$$s_x = \\frac{dz}{dx} = \\frac{\\alpha_{T}\\frac{\\partial \\theta}{\\partial x} - \\beta_{S}\\frac{\\partial S}{\\partial x}}{-\\alpha_{T}\\frac{\\partial \\theta}{\\partial z} + \\beta_{S}\\frac{\\partial S}{\\partial z}}$$\n这就是所求的用热力学系数以及位温和盐度的空间梯度表示的中性面斜率表达式。分子与水平密度梯度成正比，而分母与垂直密度梯度成正比。\n\n接下来，我们使用提供的数据计算 $s_x$ 的数值。\n我们紧凑地表示偏导数，例如，$\\partial_x \\theta = \\frac{\\partial \\theta}{\\partial x}$。\n分子：$\\mathcal{N} = \\alpha_{T}\\partial_{x}\\theta - \\beta_{S}\\partial_{x}S$\n分母：$\\mathcal{D} = -\\alpha_{T}\\partial_{z}\\theta + \\beta_{S}\\partial_{z}S$\n\n代入给定值：\n$\\alpha_{T} = 2 \\times 10^{-4}\\,\\text{K}^{-1}$\n$\\beta_{S} = 8 \\times 10^{-4}\\,\\text{(g/kg)}^{-1}$\n$\\partial_{x}\\theta = 1 \\times 10^{-5}\\,\\text{K/m}$\n$\\partial_{x}S = -5 \\times 10^{-6}\\,\\text{(g/kg)/m}$\n$\\partial_{z}\\theta = -0.01\\,\\text{K/m} = -1 \\times 10^{-2}\\,\\text{K/m}$\n$\\partial_{z}S = 2 \\times 10^{-5}\\,\\text{(g/kg)/m}$\n\n计算分子 $\\mathcal{N}$：\n$$\\mathcal{N} = (2 \\times 10^{-4}) \\times (1 \\times 10^{-5}) - (8 \\times 10^{-4}) \\times (-5 \\times 10^{-6})$$\n$$\\mathcal{N} = (2 \\times 10^{-9}) - (-40 \\times 10^{-10})$$\n$$\\mathcal{N} = (2 \\times 10^{-9}) + (4 \\times 10^{-9})$$\n$$\\mathcal{N} = 6 \\times 10^{-9}\\,\\text{m}^{-1}$$\n\n计算分母 $\\mathcal{D}$：\n$$\\mathcal{D} = -(2 \\times 10^{-4}) \\times (-1 \\times 10^{-2}) + (8 \\times 10^{-4}) \\times (2 \\times 10^{-5})$$\n$$\\mathcal{D} = (2 \\times 10^{-6}) + (16 \\times 10^{-9})$$\n$$\\mathcal{D} = (2 \\times 10^{-6}) + (0.016 \\times 10^{-6})$$\n$$\\mathcal{D} = 2.016 \\times 10^{-6}\\,\\text{m}^{-1}$$\n$\\mathcal{D}$ 的正号证实了对于一个 $z$ 坐标向下为正的坐标系，密度层结是稳定的，因为 $\\partial_z\\rho / \\rho_0 = \\mathcal{D} > 0$。\n\n现在，计算斜率 $s_x = \\frac{\\mathcal{N}}{\\mathcal{D}}$：\n$$s_x = \\frac{6 \\times 10^{-9}\\,\\text{m}^{-1}}{2.016 \\times 10^{-6}\\,\\text{m}^{-1}}$$\n为了将其表示为精确分数，我们可以将 $2.016$ 写成 $\\frac{2016}{1000}$。\n$$s_x = \\frac{6 \\times 10^{-9}}{2016 \\times 10^{-3} \\times 10^{-6}} = \\frac{6 \\times 10^{-9}}{2016 \\times 10^{-9}}$$\n$$s_x = \\frac{6}{2016}$$\n为了化简分数，我们求 6 和 2016 的最大公约数。由于 $2+0+1+6=9$，2016 能被 3 整除，也能被 2 整除。因此它能被 6 整除。\n$$2016 \\div 6 = 336$$\n所以，化简后的分数为：\n$$s_x = \\frac{1}{336}$$\n\n最后，我们评论一下这个斜率的量级。其值 $s_x = \\frac{1}{336} \\approx 0.002976$，或大约 $3 \\times 10^{-3}$。这是一个代表中性面斜率的无量纲量。这个量级的斜率意味着，在 1 公里的水平距离上，该表面的深度变化大约为 3 米。在海洋环流模式（OGCMs）的背景下，中性面斜率变化很大。在广阔、平静的洋盆内部，斜率通常非常小，量级在 $10^{-5}$ 到 $10^{-4}$ 之间。然而，在动力活跃区域，如西边界流、强锋区或中尺度涡内部，斜率可能要陡峭得多，量级可達 $10^{-3}$ 到 $10^{-2}$。因此，计算出的值 $s_x \\approx 3 \\times 10^{-3}$ 处于典型范围的较大一端，这表明问题中描述的“局部区域”并非动力平静区，而是位于一个像中尺度涡或锋面这样的特征内部或附近，这些特征会使中性面倾斜。对于这样一个区域来说，这是一个符合实际的值。",
            "answer": "$$\n\\boxed{\\frac{1}{336}}\n$$"
        },
        {
            "introduction": "知道了如何定义等中性面斜率后，下一步是探究其在海洋模型中的实际影响。由于海洋模型通常使用水平和垂直坐标（如 $z$ 坐标），沿着倾斜的等中性面进行的扩散会产生一个投影到垂直方向上的“有效”通量。这个练习要求你推导并计算由倾斜的等中性面引起的有效垂直扩散系数 $K_{zz}^{\\mathrm{eff}}$ 和垂直通量 $F_z$，这有助于理解雷迪方案如何在 $z$ 坐标模型中引入准绝热混合 。",
            "id": "3809721",
            "problem": "要求您推导并实现一种计算方法，用以在一个具有倾斜等中性面的笛卡尔 $x$-$y$-$z$ 海洋模型中，诊断由 Redi 等中性面扩散产生的有效垂直扩散率。目标是从第一性原理和核心定义出发，得出一个可用于算法的闭合形式表达式。您还必须在一个简单的解析示踪剂场上演示该方法。\n\n从以下基本基础开始：\n- 对于标量示踪剂 $C$，张量形式的 Fick 定律指出，扩散通量矢量 $\\boldsymbol{F}$ 为 $\\boldsymbol{F} = - \\boldsymbol{K} \\nabla C$，其中 $\\boldsymbol{K}$ 是一个对称、半正定的扩散张量。\n- Redi 等中性面扩散可以建模为沿等中性面的扩散，由扩散张量 $\\boldsymbol{K} = K_{\\mathrm{i}} \\boldsymbol{P}$ 表示，其中 $K_{\\mathrm{i}}$ 是一个给定的等中性面扩散率（沿等中性面方向为常数且各向同性），单位为 $\\mathrm{m^2\\,s^{-1}}$，$\\boldsymbol{P}$ 是到等中性面局部切平面的正交投影算子。如果 $\\boldsymbol{b}$ 表示等中性面的单位法向量，则 $\\boldsymbol{P} = \\boldsymbol{I} - \\boldsymbol{b}\\boldsymbol{b}^{\\top}$，其中 $\\boldsymbol{I}$ 是单位张量。\n- 假设在 $z$ 坐标模型中，等中性面的小角度坡度由坡度矢量 $\\boldsymbol{s} = (s_x, s_y)$ 描述，其定义为等中性面的水平坡度，因此曲面的单位法向量为 $\\boldsymbol{b} = \\dfrac{(-s_x, -s_y, 1)}{\\sqrt{1 + s_x^2 + s_y^2}}$。此定义与 z 坐标海洋模型中的标准中性矢量几何一致。\n\n仅使用这些定义，执行以下任务：\n1. 推导通量垂直分量 $F_z$ 关于 $K_{\\mathrm{i}}$、$s_x$、$s_y$ 以及 $\\nabla C$ 各分量的显式表达式。然后，仅从张量定义出发，推导有效垂直扩散率分量 $K_{zz}^{\\mathrm{eff}}$（即 $\\boldsymbol{K}$ 在标准基下的 $z$-$z$ 分量），该分量量化了当等中性面倾斜时，纯粹由沿等中性面扩散所产生的表观垂直扩散。\n2. 实现一个程序，在给定常数参数 $K_{\\mathrm{i}}$、$s_x$、$s_y$ 和线性示踪剂场 $C(x,y,z) = a_x x + a_y y + a_z z$（其中 $C$ 无量纲）的情况下，为每组参数计算：\n   - 有效垂直扩散率 $K_{zz}^{\\mathrm{eff}}$，单位为 $\\mathrm{m^2\\,s^{-1}}$。\n   - 对于给定的线性 $C$，根据您推导的表达式计算出的垂直扩散通量 $F_z$，单位为 $\\mathrm{m\\,s^{-1}}$。\n   除了从上述定义中可以推导出的内容外，您不能假设任何特殊情况的公式。\n3. 使用以下参数集测试套件。每个测试用例是一个元组 $\\left(K_{\\mathrm{i}}, s_x, s_y, a_x, a_y, a_z\\right)$，其中 $K_{\\mathrm{i}}$ 的单位是 $\\mathrm{m^2\\,s^{-1}}$，坡度无量纲，$a_x$、$a_y$、$a_z$ 的单位是 $\\mathrm{m^{-1}}$：\n   - 案例 1： $\\left(1000, 0.01, 0.02, 0, 0, 0.001\\right)$\n   - 案例 2： $\\left(1200, 0, 0, 0.00005, -0.00003, 0.002\\right)$\n   - 案例 3： $\\left(800, 1.0, 0.5, 0.0001, -0.0002, 0.0005\\right)$\n   - 案例 4： $\\left(500, -0.05, 0.02, 0.0002, 0.0001, 0\\right)$\n4. 您的程序必须输出单行有效的 Python 列表字面量，每个测试用例包含一个子列表。每个子列表必须按顺序包含两个浮点数 $\\left[K_{zz}^{\\mathrm{eff}}, F_z\\right]$，两者均使用指定单位，并四舍五入到 $6$ 位小数。例如，一个有效的输出格式是 $\\left[\\left[1.234000, -0.056700\\right],\\left[\\dots\\right],\\dots\\right]$。\n\n澄清与约束：\n- 该方法必须普遍适用于任何现代编程语言；但是，您必须按照最终答案中的规定提供最终的可运行程序。\n- 将示踪剂 $C$ 视为无量纲。因此，垂直通量 $F_z$ 必须以 $\\mathrm{m\\,s^{-1}}$ 为单位报告，有效垂直扩散率 $K_{zz}^{\\mathrm{eff}}$ 必须以 $\\mathrm{m^2\\,s^{-1}}$ 为单位报告。\n- 所有计算均在笛卡尔坐标系中进行，且不考虑科里奥利效应或平流效应。\n- 您的实现必须仅使用提供的测试套件，并生成所描述的精确输出格式：一个包含各案例结果的单行，其中每个结果都是一个双元素列表，由逗号分隔。不应打印任何其他文本。",
            "solution": "该问题是有效的，因为它在科学上基于计算海洋学原理，特别是 Redi 等中性面扩散理论，问题本身是适定的，提供了所有必要信息，并且表述客观。我们将进行完整的推导和解答。\n\n目标是从第一性原理推导有效垂直扩散率 $K_{zz}^{\\mathrm{eff}}$ 和垂直扩散通量 $F_z$ 的表达式，然后在一个计算模型中实现它们。\n\n我们从给定的基本定义开始：\n标量示踪剂 $C$ 的扩散通量由 Fick 定律给出：\n$$ \\boldsymbol{F} = - \\boldsymbol{K} \\nabla C $$\nRedi 等中性面扩散张量 $\\boldsymbol{K}$ 定义为：\n$$ \\boldsymbol{K} = K_{\\mathrm{i}} \\boldsymbol{P} = K_{\\mathrm{i}} (\\boldsymbol{I} - \\boldsymbol{b}\\boldsymbol{b}^{\\top}) $$\n其中 $K_{\\mathrm{i}}$ 是恒定的等中性面扩散率，$\\boldsymbol{I}$ 是单位张量，$\\boldsymbol{b}$ 是局部等中性面的单位法向量。在笛卡尔坐标系 $(x, y, z)$ 中，单位法向量 $\\boldsymbol{b}$ 根据水平等中性面坡度矢量 $\\boldsymbol{s} = (s_x, s_y)$ 定义为：\n$$ \\boldsymbol{b} = \\frac{1}{\\sqrt{1 + s_x^2 + s_y^2}} \\begin{pmatrix} -s_x \\\\ -s_y \\\\ 1 \\end{pmatrix} $$\n\n**1. 有效垂直扩散率 $K_{zz}^{\\mathrm{eff}}$ 的推导**\n\n有效垂直扩散率 $K_{zz}^{\\mathrm{eff}}$ 是完整扩散张量 $\\boldsymbol{K}$ 的 $z$-$z$ 分量，在矩阵表示法中我们将其记为 $K_{33}$。为了找到它，我们首先构建 $\\boldsymbol{K}$ 的矩阵表示。\n\n设归一化因子为 $N^2 = 1 + s_x^2 + s_y^2$。法向量的外积 $\\boldsymbol{b}\\boldsymbol{b}^{\\top}$ 为：\n$$ \\boldsymbol{b}\\boldsymbol{b}^{\\top} = \\frac{1}{N^2} \\begin{pmatrix} -s_x \\\\ -s_y \\\\ 1 \\end{pmatrix} \\begin{pmatrix} -s_x & -s_y & 1 \\end{pmatrix} = \\frac{1}{1 + s_x^2 + s_y^2} \\begin{pmatrix} s_x^2 & s_x s_y & -s_x \\\\ s_x s_y & s_y^2 & -s_y \\\\ -s_x & -s_y & 1 \\end{pmatrix} $$\n单位张量 $\\boldsymbol{I}$ 为：\n$$ \\boldsymbol{I} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} $$\n现在我们构建投影算子 $\\boldsymbol{P} = \\boldsymbol{I} - \\boldsymbol{b}\\boldsymbol{b}^{\\top}$：\n$$ \\boldsymbol{P} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} - \\frac{1}{1 + s_x^2 + s_y^2} \\begin{pmatrix} s_x^2 & s_x s_y & -s_x \\\\ s_x s_y & s_y^2 & -s_y \\\\ -s_x & -s_y & 1 \\end{pmatrix} $$\n$$ \\boldsymbol{P} = \\frac{1}{1 + s_x^2 + s_y^2} \\left[ \\begin{pmatrix} 1 + s_x^2 + s_y^2 & 0 & 0 \\\\ 0 & 1 + s_x^2 + s_y^2 & 0 \\\\ 0 & 0 & 1 + s_x^2 + s_y^2 \\end{pmatrix} - \\begin{pmatrix} s_x^2 & s_x s_y & -s_x \\\\ s_x s_y & s_y^2 & -s_y \\\\ -s_x & -s_y & 1 \\end{pmatrix} \\right] $$\n$$ \\boldsymbol{P} = \\frac{1}{1 + s_x^2 + s_y^2} \\begin{pmatrix} 1 + s_y^2 & -s_x s_y & s_x \\\\ -s_x s_y & 1 + s_x^2 & s_y \\\\ s_x & s_y & s_x^2 + s_y^2 \\end{pmatrix} $$\n完整的扩散张量 $\\boldsymbol{K}$ 是 $K_{\\mathrm{i}}\\boldsymbol{P}$：\n$$ \\boldsymbol{K} = \\frac{K_{\\mathrm{i}}}{1 + s_x^2 + s_y^2} \\begin{pmatrix} 1 + s_y^2 & -s_x s_y & s_x \\\\ -s_x s_y & 1 + s_x^2 & s_y \\\\ s_x & s_y & s_x^2 + s_y^2 \\end{pmatrix} $$\n有效垂直扩散率 $K_{zz}^{\\mathrm{eff}}$ 是通量中与示踪剂垂直梯度 $-\\frac{\\partial C}{\\partial z}$ 成正比的分量。通过检视 Fick 关系式 $F_z = -K_{zx} \\frac{\\partial C}{\\partial x} - K_{zy} \\frac{\\partial C}{\\partial y} - K_{zz} \\frac{\\partial C}{\\partial z}$，可知 $K_{zz}^{\\mathrm{eff}}$ 是张量 $\\boldsymbol{K}$ 的 $(3, 3)$ 元素，我们记作 $K_{33}$。\n$$ K_{zz}^{\\mathrm{eff}} = K_{33} = K_{\\mathrm{i}} \\frac{s_x^2 + s_y^2}{1 + s_x^2 + s_y^2} $$\n该表达式表明，只有当等中性面倾斜时（即 $s_x \\neq 0$ 或 $s_y \\neq 0$），才会由等中性面扩散产生垂直扩散。项 $s_x^2 + s_y^2$ 代表总坡度大小的平方。\n\n**2. 垂直通量 $F_z$ 的推导**\n\n扩散通量的垂直分量 $F_z$ 是矢量 $\\boldsymbol{F} = -\\boldsymbol{K} \\nabla C$ 的第三个分量。问题指定了一个线性示踪剂场 $C(x,y,z) = a_x x + a_y y + a_z z$。因此，$C$ 的梯度是一个常数矢量：\n$$ \\nabla C = \\begin{pmatrix} \\frac{\\partial C}{\\partial x} \\\\ \\frac{\\partial C}{\\partial y} \\\\ \\frac{\\partial C}{\\partial z} \\end{pmatrix} = \\begin{pmatrix} a_x \\\\ a_y \\\\ a_z \\end{pmatrix} $$\n我们通过将 $-\\boldsymbol{K}$ 与 $\\nabla C$ 相乘来计算通量矢量 $\\boldsymbol{F}$：\n$$ \\boldsymbol{F} = - \\boldsymbol{K} \\nabla C = - \\frac{K_{\\mathrm{i}}}{1 + s_x^2 + s_y^2} \\begin{pmatrix} 1 + s_y^2 & -s_x s_y & s_x \\\\ -s_x s_y & 1 + s_x^2 & s_y \\\\ s_x & s_y & s_x^2 + s_y^2 \\end{pmatrix} \\begin{pmatrix} a_x \\\\ a_y \\\\ a_z \\end{pmatrix} $$\n我们关心的是垂直分量 $F_z$，它对应于矩阵-矢量乘积的第三行：\n$$ F_z = - \\frac{K_{\\mathrm{i}}}{1 + s_x^2 + s_y^2} \\left[ (s_x)(a_x) + (s_y)(a_y) + (s_x^2 + s_y^2)(a_z) \\right] $$\n这可以更简洁地写成：\n$$ F_z = - \\frac{K_{\\mathrm{i}}}{1 + |\\boldsymbol{s}|^2} \\left( \\boldsymbol{s} \\cdot \\nabla_{h} C + |\\boldsymbol{s}|^2 \\frac{\\partial C}{\\partial z} \\right) $$\n其中 $\\boldsymbol{s}=(s_x, s_y)$，$\\nabla_h C = (a_x, a_y)$，且 $|\\boldsymbol{s}|^2 = s_x^2 + s_y^2$。这个最终表达式表明，垂直通量由两种机制产生：水平示踪剂梯度在坡度矢量上的投影（第一项），以及作用在倾斜表面上的垂直示踪剂梯度（第二项）。\n\n**3. 算法实现**\n\n推导出的公式是直接的，可以以一种直接的方式实现。对于每个由元组 $(K_{\\mathrm{i}}, s_x, s_y, a_x, a_y, a_z)$ 指定的测试用例：\n- 有效垂直扩散率计算如下：\n  $$ K_{zz}^{\\mathrm{eff}} = K_{\\mathrm{i}} \\frac{s_x^2 + s_y^2}{1 + s_x^2 + s_y^2} $$\n- 垂直扩散通量计算如下：\n  $$ F_z = - K_{\\mathrm{i}} \\frac{s_x a_x + s_y a_y + (s_x^2 + s_y^2) a_z}{1 + s_x^2 + s_y^2} $$\n程序将遍历提供的测试套件，为每个案例计算这两个值，将它们格式化为四舍五入到 $6$ 位小数的浮点数，并以列表的列表形式打印最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes the effective vertical diffusivity and vertical flux\n    arising from Redi isoneutral diffusion on sloping surfaces.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (K_i, s_x, s_y, a_x, a_y, a_z)\n    test_cases = [\n        (1000, 0.01, 0.02, 0, 0, 0.001),         # Case 1\n        (1200, 0, 0, 0.00005, -0.00003, 0.002), # Case 2\n        (800, 1.0, 0.5, 0.0001, -0.0002, 0.0005),# Case 3\n        (500, -0.05, 0.02, 0.0002, 0.0001, 0)     # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        K_i, s_x, s_y, a_x, a_y, a_z = case\n\n        # Calculate the squared magnitude of the slope and the normalization denominator\n        s_sq = s_x**2 + s_y**2\n        denominator = 1 + s_sq\n\n        # 1. Calculate the effective vertical diffusivity, K_zz_eff\n        # Formula: K_zz_eff = K_i * (s_x^2 + s_y^2) / (1 + s_x^2 + s_y^2)\n        K_zz_eff = K_i * s_sq / denominator\n\n        # 2. Calculate the vertical diffusive flux, F_z\n        # Formula: F_z = -K_i * (s_x*a_x + s_y*a_y + (s_x^2+s_y^2)*a_z) / (1 + s_x^2 + s_y^2)\n        flux_numerator = s_x * a_x + s_y * a_y + s_sq * a_z\n        F_z = -K_i * flux_numerator / denominator\n        \n        results.append([round(K_zz_eff, 6), round(F_z, 6)])\n\n    # Format the final output string exactly as required by the problem.\n    # Each value is formatted to 6 decimal places.\n    output_string = str(results).replace(\" \", \"\")\n    print(output_string)\n\n# The expected output format is very strict. The provided example is [[1.234000, -0.056700],...].\n# My original python code would produce this with f-strings.\n# Let's adjust the final output step to be more robust and match the format.\ndef solve_formatted():\n    test_cases = [\n        (1000, 0.01, 0.02, 0, 0, 0.001),\n        (1200, 0, 0, 0.00005, -0.00003, 0.002),\n        (800, 1.0, 0.5, 0.0001, -0.0002, 0.0005),\n        (500, -0.05, 0.02, 0.0002, 0.0001, 0)\n    ]\n    results = []\n    for case in test_cases:\n        K_i, s_x, s_y, a_x, a_y, a_z = case\n        s_sq = s_x**2 + s_y**2\n        denominator = 1 + s_sq\n        K_zz_eff = K_i * s_sq / denominator\n        flux_numerator = s_x * a_x + s_y * a_y + s_sq * a_z\n        F_z = -K_i * flux_numerator / denominator\n        results.append(f\"[{K_zz_eff:.6f},{F_z:.6f}]\")\n    print(f\"[{','.join(results)}]\")\n\nsolve_formatted()\n```"
        },
        {
            "introduction": "从理论到实践的最后一步是在数值模型中实现这些概念。本练习模拟了在海洋环流模型中常用的阿拉卡瓦 C-网格上计算等中性面斜率的真实过程。你将需要处理交错网格上的离散化、为保证数值稳定性而进行的操作（如分母阈值处理和斜率限制），这些都是将雷迪参数化方案从连续方程转化为稳健计算代码的关键技术 。",
            "id": "3809736",
            "problem": "您需要实现一个完整的、可运行的程序，用于在 Arakawa C-网格上为海洋示踪物计算 Redi 参数化中的等中性面斜率。目标量是斜率矢量的水平分量，即 u-面上的 $s_x$ 和 v-面上的 $s_y$，它们由网格中心的温度 $T$ 和盐度 $S$ 导出。您的算法必须是鲁棒的，并与垂直梯度和模式的交错配置保持一致。\n\n基本原理和定义：\n- Redi 等中性面扩散参数化了沿局部中性方向的小尺度混合，该方向由线性化状态方程定义。在线性近似下，局部中性梯度矢量为 $N = \\alpha \\nabla T - \\beta \\nabla S$，其中 $\\alpha$ 是热膨胀系数，$\\beta$ 是盐收缩系数。等中性面斜率分量通过 $N$ 的水平分量与垂直分量之比得到，具体为\n$$\ns_x = \\frac{\\alpha \\, \\partial_x T - \\beta \\, \\partial_x S}{\\alpha \\, \\partial_z T - \\beta \\, \\partial_z S}, \\quad\ns_y = \\frac{\\alpha \\, \\partial_y T - \\beta \\, \\partial_y S}{\\alpha \\, \\partial_z T - \\beta \\, \\partial_z S}.\n$$\n- Arakawa C-网格的交错配置将标量置于网格中心。水平斜率 $s_x$ 和 $s_y$ 必须在面中心计算，并保持垂直一致性：分子在面上求值，分母是在同一面位置通过对相邻网格中心垂直梯度进行水平平均得到的垂直中性分量。\n\n网格、离散化和算法要求：\n- 考虑一个均匀的笛卡尔网格，其间距在米为单位度量下为 $\\Delta x$、$\\Delta y$ 和 $\\Delta z$。变量 $T$ 和 $S$ 定义在网格中心，索引为 $(i,j,k)$，其中 $i = 0,\\dots,N_x-1$，$j = 0,\\dots,N_y-1$，$k = 0,\\dots,N_z-1$。\n- 使用与面位置一致的二阶中心差分计算面中心的水平梯度：\n    - 在位于 $(i+\\tfrac{1}{2}, j, k)$ 的 $u$-面上，使用\n    $$\n    \\partial_x T\\big|_{i+\\frac{1}{2},j,k} \\approx \\frac{T_{i+1,j,k} - T_{i,j,k}}{\\Delta x}, \\quad\n    \\partial_x S\\big|_{i+\\frac{1}{2},j,k} \\approx \\frac{S_{i+1,j,k} - S_{i,j,k}}{\\Delta x}.\n    $$\n    - 在位于 $(i, j+\\tfrac{1}{2}, k)$ 的 $v$-面上，使用\n    $$\n    \\partial_y T\\big|_{i,j+\\frac{1}{2},k} \\approx \\frac{T_{i,j+1,k} - T_{i,j,k}}{\\Delta y}, \\quad\n    \\partial_y S\\big|_{i,j+\\frac{1}{2},k} \\approx \\frac{S_{i,j+1,k} - S_{i,j,k}}{\\Delta y}.\n    $$\n- 使用内部的中心差分和边界上的单边差分计算网格中心的垂直梯度：\n    $$\n    \\partial_z T\\big|_{i,j,k} \\approx\n    \\begin{cases}\n    \\dfrac{T_{i,j,k+1} - T_{i,j,k-1}}{2 \\Delta z},  &\\text{for } 1 \\le k \\le N_z-2, \\\\\n    \\dfrac{T_{i,j,1} - T_{i,j,0}}{\\Delta z},  &\\text{for } k=0, \\\\\n    \\dfrac{T_{i,j,N_z-1} - T_{i,j,N_z-2}}{\\Delta z},  &\\text{for } k=N_z-1,\n    \\end{cases}\n    $$\n    对于 $\\partial_z S\\big|_{i,j,k}$ 也是如此。\n- 为了将垂直中性分母与水平交错配置一致地放置在面上，使用简单的水平平均：\n    - 在 $u$-面上，\n    $$\n    D_{x}\\big|_{i+\\frac{1}{2},j,k} = \\frac{1}{2} \\left[ \\alpha \\, \\partial_z T\\big|_{i,j,k} - \\beta \\, \\partial_z S\\big|_{i,j,k} \\;+\\; \\alpha \\, \\partial_z T\\big|_{i+1,j,k} - \\beta \\, \\partial_z S\\big|_{i+1,j,k} \\right].\n    $$\n    - 在 $v$-面上，\n    $$\n    D_{y}\\big|_{i,j+\\frac{1}{2},k} = \\frac{1}{2} \\left[ \\alpha \\, \\partial_z T\\big|_{i,j,k} - \\beta \\, \\partial_z S\\big|_{i,j,k} \\;+\\; \\alpha \\, \\partial_z T\\big|_{i,j+1,k} - \\beta \\, \\partial_z S\\big|_{i,j+1,k} \\right].\n    $$\n- 通过将面中心的分子除以相应的面中心的分母来形成原始斜率。为保证鲁棒性：\n    - 如果分母的绝对值低于一个小阈值 $\\varepsilon$，则将该面上的斜率设置为零，以避免数值爆炸。\n    - 应用斜率上限 $s_{\\max}$ 来强制执行 Redi 扩散中使用的小斜率假设：形成原始斜率后，设置 $s \\leftarrow \\operatorname{sign}(s) \\cdot \\min(|s|, s_{\\max})$。\n- 使用恒定系数 $\\alpha$ 和 $\\beta$，单位为逆摄氏度和逆实用盐度单位：$\\alpha = 0.0002$ 和 $\\beta = 0.0008$。这些值对于混合层范围具有代表性，并且足以用于算法测试。\n\n单位和输出：\n- 输入 $T$ 和 $S$ 必须分别以摄氏度和实用盐度单位（无量纲）给出。网格间距 $\\Delta x$、$\\Delta y$ 和 $\\Delta z$ 必须以米为单位。斜率 $s_x$ 和 $s_y$ 是无量纲的。\n- 您的程序必须为每个测试用例计算 $s_x$ 和 $s_y$，然后提供如下指定的聚合指标。所有报告的值必须是无单位的数值浮点数或整数。\n\n测试套件：\n实现您的程序以运行以下三个用例。在每个用例中，使用指定的常数 $\\alpha = 0.0002$、$\\beta = 0.0008$、斜率上限 $s_{\\max} = 0.01$ 以及分母阈值 $\\varepsilon = 1.0 \\times 10^{-12}$。\n- 用例 1 (一般行为良好的场):\n    - 网格：$N_x = 3$, $N_y = 3$, $N_z = 4$, $\\Delta x = 10000$, $\\Delta y = 10000$, $\\Delta z = 10$.\n    - 场：$T_{i,j,k} = 10 + 0.01 \\, i + 0.02 \\, j - 0.05 \\, k$, $S_{i,j,k} = 35 + 0.005 \\, i + 0.000 \\, j + 0.01 \\, k$.\n    - 需要报告的输出：所有 $u$-面上的最大绝对斜率，以及所有 $v$-面上的最大绝对斜率，两者均在阈值处理和上限限制后得出。\n- 用例 2 (接近中性的垂直分母):\n    - 网格：$N_x = 2$, $N_y = 2$, $N_z = 3$, $\\Delta x = 1000$, $\\Delta y = 1000$, $\\Delta z = 20$.\n    - 场：$T_{i,j,k} = 5 + 1.0 \\, i + 0.0 \\, j - 0.02 \\, k$, $S_{i,j,k} = 34 + 0.0 \\, i + 0.0 \\, j - 0.005 \\, k$.\n    - 需要报告的输出：$|D| < \\varepsilon$ 且由于分母接近零而将斜率设置为零的面总数（$u$-面和 $v$-面之和）；$u$-面上的最大绝对斜率；以及 $v$-面上的最大绝对斜率，两者均在阈值处理和上限限制后得出。\n- 用例 3 (导致上限限制的强水平梯度):\n    - 网格：$N_x = 3$, $N_y = 2$, $N_z = 3$, $\\Delta x = 500$, $\\Delta y = 500$, $\\Delta z = 20$.\n    - 场：$T_{i,j,k} = 8 + 5.0 \\, i + 0.0 \\, j - 0.02 \\, k$, $S_{i,j,k} = 35 + 0.0 \\, i + 0.0 \\, j + 0.0 \\, k$.\n    - 需要报告的输出：上限限制被激活的面总数（$u$-面和 $v$-面之和），即 $|s_{\\text{raw}}| > s_{\\max}$ 且分母满足 $|D| \\ge \\varepsilon$ 的面；$u$-面上的最大绝对斜率；以及 $v$-面上的最大绝对斜率，两者均在阈值处理和上限限制后得出。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含所有三个用例的结果，格式为方括号内以逗号分隔的列表。顺序必须是：\n$[$用例 1 的 u-面最大绝对斜率, 用例 1 的 v-面最大绝对斜率, 用例 2 的近零分母面计数, 用例 2 的 u-面最大绝对斜率, 用例 2 的 v-面最大绝对斜率, 用例 3 的上限限制面计数, 用例 3 的 u-面最大绝对斜率, 用例 3 的 v-面最大绝对斜率$]$。所有值都必须报告为纯数字（无单位）。",
            "solution": "该问题要求在 Arakawa C-网格上实现一个算法来计算等中性面斜率 $s_x$ 和 $s_y$，这是海洋模型中 Redi 参数化中尺度涡致示踪物输运的一项基本任务。所给的问题陈述在科学上是合理的、在数学上是适定的，并且包含了获得唯一可验证解所需的所有信息。\n\n核心原理是沿着等中性面（即等位密面）对亚网格尺度混合进行参数化。为了计算目的，这被近似为一个局部中性方向。使用线性化状态方程，局部中性梯度矢量 $N$ 定义为：\n$$\nN = \\alpha \\nabla T - \\beta \\nabla S\n$$\n其中 $T$ 是温度，$S$ 是盐度，$\\alpha$ 是热膨胀系数，$\\beta$ 是盐收缩系数。等中性面斜率 $s_x$ 和 $s_y$ 分别表示该中性面在 $x$-$z$ 和 $y$-$z$ 平面内的倾斜。它们被定义为 $N$ 的水平分量与其垂直分量之比：\n$$\ns_x = \\frac{N_x}{N_z} = \\frac{\\alpha \\, \\partial_x T - \\beta \\, \\partial_x S}{\\alpha \\, \\partial_z T - \\beta \\, \\partial_z S}, \\quad\ns_y = \\frac{N_y}{N_z} = \\frac{\\alpha \\, \\partial_y T - \\beta \\, \\partial_y S}{\\alpha \\, \\partial_z T - \\beta \\, \\partial_z S}\n$$\n\n所提供的算法设计遵循了 Arakawa C-网格上变量的交错配置，其中像 $T$ 和 $S$ 这样的标量位于网格中心，而速度分量（以及相关的通量或斜率）则位于网格面。这需要仔细的离散化和平均。\n\n算法流程如下：\n\n1. **计算垂直梯度**：首先在网格中心 $(i,j,k)$ 计算垂直梯度 $\\partial_z T$ 和 $\\partial_z S$。根据规范，对内部网格点 ($1 \\le k \\le N_z-2$) 使用二阶中心差分，而在顶部 ($k=0$) 和底部 ($k=N_z-1$) 边界使用一阶单边差分。这为整个水体提供了垂直结构的鲁棒估计。\n$$\n\\partial_z T\\big|_{i,j,k} \\approx\n\\begin{cases}\n\\dfrac{T_{i,j,k+1} - T_{i,j,k-1}}{2 \\Delta z},  &\\text{for } 1 \\leq k \\leq N_z-2 \\\\\n\\dfrac{T_{i,j,1} - T_{i,j,0}}{\\Delta z},  &\\text{for } k=0 \\\\\n\\dfrac{T_{i,j,N_z-1} - T_{i,j,N_z-2}}{\\Delta z},  &\\text{for } k=N_z-1\n\\end{cases}\n$$\n$\\partial_z S$ 的计算过程是相同的。\n\n2. **计算水平梯度和面中心分子**：斜率分子所需的水平梯度在网格面上计算，与 C-网格的交错配置保持一致。\n- 对于在 $u$-面 $(i+\\frac{1}{2}, j, k)$ 的斜率 $s_x$，水平梯度通过跨面的中心差分来近似：\n$$\n\\partial_x T\\big|_{i+\\frac{1}{2},j,k} \\approx \\frac{T_{i+1,j,k} - T_{i,j,k}}{\\Delta x}\n$$\n然后使用这些面中心的梯度来构建 $s_x$ 的分子，记为 $N_{x}|_{i+\\frac{1}{2},j,k}$。\n- 对于在 $v$-面 $(i, j+\\frac{1}{2}, k)$ 的 $s_y$，使用 $y$ 方向的梯度执行类似的计算。\n\n3. **计算面中心分母**：分母 $N_z = \\alpha \\, \\partial_z T - \\beta \\, \\partial_z S$ 首先使用步骤 1 中的垂直梯度在网格中心进行求值。为了将分母与分子共置于网格面上，执行一个简单的水平平均。\n- 对于在 $u$-面 $(i+\\frac{1}{2}, j, k)$，分母 $D_x$ 为：\n$$\nD_{x}\\big|_{i+\\frac{1}{2},j,k} = \\frac{1}{2} \\left[ (\\alpha \\partial_z T - \\beta \\partial_z S)\\big|_{i,j,k} + (\\alpha \\partial_z T - \\beta \\partial_z S)\\big|_{i+1,j,k} \\right]\n$$\n- 使用类似的平均来求得在 $v$-面 $(i, j+\\frac{1}{2}, k)$ 上的分母 $D_y$。这种平均方法能保持性质并维持数值稳定性。\n\n4. **应用鲁棒性约束**：应用两个关键的数值约束来确保计算出的斜率的稳定性和物理真实性。\n- **分母阈值处理**：在水体弱层化或等中性的区域，分母 $N_z$ 可能接近零，导致数值奇异点。为防止这种情况，如果面中心分母的绝对值（$|D_x|$ 或 $|D_y|$）小于预设阈值 $\\varepsilon = 10^{-12}$，则该面上的斜率设置为零。该条件物理上对应于一个垂直的等中性面，在此情况下，水平混合不能被此参数化很好地定义。\n- **斜率上限限制**：Redi 参数化假设等中性面斜率很小。为了强制执行这个“小斜率”近似，计算出的原始斜率的绝对值被限制在一个最大值 $s_{\\max} = 0.01$。如果原始斜率 $|s_{raw}| > s_{\\max}$，最终斜率将被设置为 $s = \\operatorname{sign}(s_{raw}) \\cdot s_{\\max}$。这可以防止在父海洋模型中可能导致数值不稳定性的不符合物理的巨大斜率。\n\n通过系统地应用这些计算海洋学中公认的原则，我们可以构建一个鲁棒且准确的实现。所提供的测试用例旨在验证对一般情况、近零分母情况以及触发斜率上限限制的强梯度情况的正确处理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_slopes(Nx, Ny, Nz, dx, dy, dz, T_func, S_func, alpha, beta, s_max, epsilon):\n    \"\"\"\n    Computes isoneutral slopes and related metrics for a given case.\n\n    Args:\n        Nx, Ny, Nz (int): Grid dimensions.\n        dx, dy, dz (float): Grid spacings.\n        T_func, S_func (callable): Functions to generate T and S fields.\n        alpha, beta (float): Thermal/haline coefficients.\n        s_max (float): Slope cap.\n        epsilon (float): Denominator threshold.\n\n    Returns:\n        A tuple containing:\n        (max_abs_sx, max_abs_sy, zero_denom_count, capped_count)\n    \"\"\"\n    # 1. Create grid and scalar fields using numpy broadcasting\n    i, j, k = np.ogrid[0:Nx, 0:Ny, 0:Nz]\n    T = T_func(i, j, k)\n    S = S_func(i, j, k)\n\n    # 2. Compute vertical gradients at cell centers\n    # The problem's specification for vertical gradients (centered interior, \n    # one-sided boundaries) exactly matches the behavior of np.gradient with edge_order=1.\n    d_T_dz = np.gradient(T, dz, axis=2, edge_order=1)\n    d_S_dz = np.gradient(S, dz, axis=2, edge_order=1)\n\n    # 3. Compute cell-centered vertical neutral component (denominator base)\n    Den_cell = alpha * d_T_dz - beta * d_S_dz\n\n    # --- 4. Compute slopes sx at u-faces (i+1/2, j, k) ---\n    max_abs_sx = 0.0\n    zero_denom_count_x = 0\n    capped_count_x = 0\n\n    if Nx > 1:\n        # Numerator at u-faces\n        dT_dx = (T[1:, :, :] - T[:-1, :, :]) / dx\n        dS_dx = (S[1:, :, :] - S[:-1, :, :]) / dx\n        Num_x = alpha * dT_dx - beta * dS_dx\n\n        # Denominator at u-faces (average from adjacent cells)\n        Den_x = 0.5 * (Den_cell[:-1, :, :] + Den_cell[1:, :, :])\n\n        # Apply denominator threshold\n        s_x_raw = np.zeros_like(Den_x)\n        mask_x_denom_ok = np.abs(Den_x) >= epsilon\n        np.divide(Num_x, Den_x, out=s_x_raw, where=mask_x_denom_ok)\n\n        # Apply slope capping\n        s_x = np.sign(s_x_raw) * np.minimum(np.abs(s_x_raw), s_max)\n        \n        # Collect metrics for sx\n        max_abs_sx = np.max(np.abs(s_x)) if s_x.size > 0 else 0.0\n        zero_denom_count_x = np.sum(~mask_x_denom_ok)\n        capped_count_x = np.sum((np.abs(s_x_raw) > s_max) & mask_x_denom_ok)\n\n    # --- 5. Compute slopes sy at v-faces (i, j+1/2, k) ---\n    max_abs_sy = 0.0\n    zero_denom_count_y = 0\n    capped_count_y = 0\n\n    if Ny > 1:\n        # Numerator at v-faces\n        dT_dy = (T[:, 1:, :] - T[:, :-1, :]) / dy\n        dS_dy = (S[:, 1:, :] - S[:, :-1, :]) / dy\n        Num_y = alpha * dT_dy - beta * dS_dy\n\n        # Denominator at v-faces (average from adjacent cells)\n        Den_y = 0.5 * (Den_cell[:, :-1, :] + Den_cell[:, 1:, :])\n\n        # Apply denominator threshold\n        s_y_raw = np.zeros_like(Den_y)\n        mask_y_denom_ok = np.abs(Den_y) >= epsilon\n        np.divide(Num_y, Den_y, out=s_y_raw, where=mask_y_denom_ok)\n\n        # Apply slope capping\n        s_y = np.sign(s_y_raw) * np.minimum(np.abs(s_y_raw), s_max)\n        \n        # Collect metrics for sy\n        max_abs_sy = np.max(np.abs(s_y)) if s_y.size > 0 else 0.0\n        zero_denom_count_y = np.sum(~mask_y_denom_ok)\n        capped_count_y = np.sum((np.abs(s_y_raw) > s_max) & mask_y_denom_ok)\n\n    # --- 6. Aggregate metrics ---\n    zero_denom_count = zero_denom_count_x + zero_denom_count_y\n    capped_count = capped_count_x + capped_count_y\n\n    return (max_abs_sx, max_abs_sy, zero_denom_count, capped_count)\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define constants for all cases\n    alpha = 0.0002\n    beta = 0.0008\n    s_max = 0.01\n    epsilon = 1.0e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"grid\": {\"Nx\": 3, \"Ny\": 3, \"Nz\": 4, \"dx\": 10000, \"dy\": 10000, \"dz\": 10},\n            \"fields\": {\n                \"T_func\": lambda i, j, k: 10 + 0.01 * i + 0.02 * j - 0.05 * k,\n                \"S_func\": lambda i, j, k: 35 + 0.005 * i + 0.000 * j + 0.01 * k,\n            },\n        },\n        {\n            \"name\": \"Case 2\",\n            \"grid\": {\"Nx\": 2, \"Ny\": 2, \"Nz\": 3, \"dx\": 1000, \"dy\": 1000, \"dz\": 20},\n            \"fields\": {\n                \"T_func\": lambda i, j, k: 5 + 1.0 * i + 0.0 * j - 0.02 * k,\n                \"S_func\": lambda i, j, k: 34 + 0.0 * i + 0.0 * j - 0.005 * k,\n            },\n        },\n        {\n            \"name\": \"Case 3\",\n            \"grid\": {\"Nx\": 3, \"Ny\": 2, \"Nz\": 3, \"dx\": 500, \"dy\": 500, \"dz\": 20},\n            \"fields\": {\n                \"T_func\": lambda i, j, k: 8 + 5.0 * i + 0.0 * j - 0.02 * k,\n                \"S_func\": lambda i, j, k: 35 + 0.0 * i + 0.0 * j + 0.0 * k,\n            },\n        },\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        max_sx, max_sy, zero_denom, capped = calculate_slopes(\n            **case[\"grid\"], \n            **case[\"fields\"], \n            alpha=alpha, beta=beta, s_max=s_max, epsilon=epsilon\n        )\n        if i == 0:  # Case 1\n            results.extend([max_sx, max_sy])\n        elif i == 1:  # Case 2\n            results.extend([int(zero_denom), max_sx, max_sy])\n        elif i == 2:  # Case 3\n            results.extend([int(capped), max_sx, max_sy])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}