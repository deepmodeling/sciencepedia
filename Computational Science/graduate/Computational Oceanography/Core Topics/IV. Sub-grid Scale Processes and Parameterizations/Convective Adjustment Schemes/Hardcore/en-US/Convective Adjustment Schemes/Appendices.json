{
    "hands_on_practices": [
        {
            "introduction": "Before implementing any convective adjustment scheme, one must first possess a precise mathematical criterion for identifying when a water column is statically unstable. This foundational exercise () guides you through the derivation of the squared Brunt–Väisälä frequency, $N^2$, which is the fundamental metric for static stability in a fluid. By completing this practice, you will connect the abstract concept of buoyancy frequency to the tangible, observable vertical gradients of temperature and salinity in the ocean.",
            "id": "3788352",
            "problem": "Consider a one-dimensional ocean column occupying depths $-100 \\le z \\le 0$ m, where $z$ is the vertical coordinate with $z=0$ at the sea surface and $z$ increasing upward. The observed temperature and salinity profiles are linear in depth, given by $T(z) = T_{s} + \\gamma_{T} z$ and $S(z) = S_{s} + \\gamma_{S} z$, where $T_{s}$ and $S_{s}$ are constant surface values, and $\\gamma_{T}$ and $\\gamma_{S}$ are constant vertical gradients. Assume the Boussinesq approximation, hydrostatic balance, and a linearized equation of state about a reference density $\\rho_{0}$ such that density perturbations satisfy $\\rho' = -\\rho_{0}\\left(\\alpha\\,T' - \\beta\\,S'\\right)$, where $\\alpha$ is the thermal expansion coefficient and $\\beta$ is the haline contraction coefficient. Use $g = 9.81$ m s$^{-2}$, $\\alpha = 2\\times 10^{-4}$ K$^{-1}$, $\\beta = 8\\times 10^{-4}$ psu$^{-1}$, and $\\rho_{0} = 1025$ kg m$^{-3}$. Starting from the definitions of buoyancy $b = -g\\,\\rho'/\\rho_{0}$ and the squared Brunt–Väisälä (buoyancy) frequency $N^{2}(z) = \\partial b/\\partial z$, derive an analytic expression for $N^{2}(z)$ in terms of $g$, $\\alpha$, $\\beta$, $\\gamma_{T}$, and $\\gamma_{S}$. Then, using the sign of the derived expression, identify the depths in the column that would be flagged as statically unstable by a convective adjustment scheme that instantaneously homogenizes any sublayer where $N^{2}(z)  0$. Express the final $N^{2}(z)$ expression in SI units of s$^{-2}$. Report only the analytic expression for $N^{2}(z)$. No numerical evaluation is required.",
            "solution": "The problem is first validated to ensure it is scientifically sound, well-posed, and complete.\n\n### Step 1: Extract Givens\n- Domain: A one-dimensional ocean column with vertical coordinate $z$ such that $-100 \\le z \\le 0$ m. $z=0$ is the sea surface.\n- Temperature profile: $T(z) = T_{s} + \\gamma_{T} z$, where $T_s$ and $\\gamma_T$ are constants.\n- Salinity profile: $S(z) = S_{s} + \\gamma_{S} z$, where $S_s$ and $\\gamma_S$ are constants.\n- Approximations: Boussinesq approximation and hydrostatic balance are assumed.\n- Linearized equation of state: The density perturbation $\\rho'$ is given by $\\rho' = -\\rho_{0}\\left(\\alpha\\,T' - \\beta\\,S'\\right)$, where $T'$ and $S'$ are temperature and salinity perturbations, respectively.\n- Constants:\n    - Gravitational acceleration: $g = 9.81$ m s$^{-2}$.\n    - Thermal expansion coefficient: $\\alpha = 2\\times 10^{-4}$ K$^{-1}$.\n    - Haline contraction coefficient: $\\beta = 8\\times 10^{-4}$ psu$^{-1}$.\n    - Reference density: $\\rho_{0} = 1025$ kg m$^{-3}$.\n- Definitions:\n    - Buoyancy: $b = -g\\,\\rho'/\\rho_{0}$.\n    - Squared Brunt–Väisälä (buoyancy) frequency: $N^{2}(z) = \\partial b/\\partial z$.\n- Task:\n    1. Derive an analytic expression for $N^{2}(z)$ in terms of $g$, $\\alpha$, $\\beta$, $\\gamma_{T}$, and $\\gamma_{S}$.\n    2. Identify the depths that are statically unstable ($N^{2}(z)  0$).\n    3. Express the final $N^{2}(z)$ expression in SI units of s$^{-2}$.\n    4. Report only the analytic expression for $N^{2}(z)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, utilizing standard concepts and equations from physical oceanography, such as the Boussinesq approximation, a linearized equation of state, and the definitions of buoyancy and the Brunt-Väisälä frequency. The provided numerical constants are physically realistic. The problem is well-posed; it provides all necessary information to derive the requested expression. The language is objective and unambiguous. The instructions for the final output are specific but do not introduce any contradiction to the physics of the problem. Therefore, the problem is deemed valid.\n\n### Step 3: Verdict and Action\nThe problem is valid. The solution will now be derived.\n\n### Derivation\nThe squared Brunt-Väisälä frequency, $N^{2}(z)$, is a measure of the static stability of a fluid column. It is defined as the vertical gradient of buoyancy, $N^{2}(z) = \\partial b/\\partial z$.\n\nFirst, we establish an expression for buoyancy, $b(z)$. The problem provides the definition $b = -g\\,\\rho'/\\rho_{0}$. The density perturbation, $\\rho'$, is given by the linearized equation of state, $\\rho' = -\\rho_{0}(\\alpha T' - \\beta S')$. The terms $T'$ and $S'$ represent deviations from a reference state. For calculating the stratification of a background profile $T(z)$ and $S(z)$, the relevant density is $\\rho(z) = \\rho_0(1 - \\alpha(T(z)-T_{ref}) + \\beta(S(z)-S_{ref}))$, where $T_{ref}$ and $S_{ref}$ are constant reference values. The density anomaly relative to the reference density $\\rho_0$ is then $\\rho(z) - \\rho_0$. The buoyancy related to this stratification is $b(z) = -g (\\rho(z)-\\rho_0)/\\rho_0 = g(\\alpha(T(z)-T_{ref}) - \\beta(S(z)-S_{ref}))$.\n\nTo find $N^{2}(z)$, we differentiate this expression for $b(z)$ with respect to the vertical coordinate $z$:\n$$N^{2}(z) = \\frac{\\partial b}{\\partial z} = \\frac{\\partial}{\\partial z} \\left[ g\\left(\\alpha(T(z)-T_{ref}) - \\beta(S(z)-S_{ref})\\right) \\right]$$\nSince $g$, $\\alpha$, $\\beta$, $T_{ref}$, and $S_{ref}$ are all constants, the differentiation yields:\n$$N^{2}(z) = g \\left( \\alpha \\frac{dT}{dz} - \\beta \\frac{dS}{dz} \\right)$$\nThis is the general expression for the squared Brunt-Väisälä frequency under the given linearized equation of state.\n\nThe problem specifies linear profiles for temperature and salinity:\n$T(z) = T_{s} + \\gamma_{T} z$\n$S(z) = S_{s} + \\gamma_{S} z$\n\nWe compute the vertical gradients, $\\frac{dT}{dz}$ and $\\frac{dS}{dz}$, from these profiles:\n$$\\frac{dT}{dz} = \\frac{d}{dz} (T_{s} + \\gamma_{T} z) = \\gamma_{T}$$\n$$\\frac{dS}{dz} = \\frac{d}{dz} (S_{s} + \\gamma_{S} z) = \\gamma_{S}$$\nSince $\\gamma_{T}$ and $\\gamma_{S}$ are constants, the vertical gradients of temperature and salinity are constant throughout the water column.\n\nSubstituting these constant gradients into the expression for $N^{2}(z)$:\n$$N^{2}(z) = g \\left( \\alpha \\gamma_{T} - \\beta \\gamma_{S} \\right)$$\nAs all terms on the right-hand side are constants, $N^{2}$ is itself a constant, independent of depth $z$.\n\nA convective adjustment scheme would flag any sublayer as statically unstable if $N^{2}(z)  0$. In this case, since $N^{2}$ is constant, the stability condition applies to the entire column, $-100 \\le z \\le 0$ m. The condition for instability is:\n$$g \\left( \\alpha \\gamma_{T} - \\beta \\gamma_{S} \\right)  0$$\nSince $g  0$, this inequality simplifies to:\n$$\\alpha \\gamma_{T} - \\beta \\gamma_{S}  0 \\quad \\text{or} \\quad \\alpha \\gamma_{T}  \\beta \\gamma_{S}$$\nIf this condition is met, the entire water column is statically unstable. If $\\alpha \\gamma_{T} \\ge \\beta \\gamma_{S}$, the entire column is stable or neutral, and no part of it would be flagged for convective adjustment.\n\nThe units of the derived expression are checked for consistency. The units of the terms are:\n- $[g]$ = m s$^{-2}$\n- $[\\alpha]$ = K$^{-1}$\n- $[\\gamma_T]$ = K m$^{-1}$\n- $[\\beta]$ = psu$^{-1}$ (psu is a practical salinity unit, often treated as dimensionless in such calculations)\n- $[\\gamma_S]$ = psu m$^{-1}$\n\nThus, the units of $N^{2}$ are:\n$$[\\text{m s}^{-2}] \\times ([\\text{K}^{-1}][\\text{K m}^{-1}] - [\\text{psu}^{-1}][\\text{psu m}^{-1}]) = [\\text{m s}^{-2}] \\times ([\\text{m}^{-1}] - [\\text{m}^{-1}]) = \\text{s}^{-2}$$\nThe units are correct SI units for squared frequency.\n\nThe problem asks for the analytic expression for $N^{2}(z)$. As derived, this is $g(\\alpha \\gamma_T - \\beta \\gamma_S)$.",
            "answer": "$$\n\\boxed{g \\left( \\alpha \\gamma_{T} - \\beta \\gamma_{S} \\right)}\n$$"
        },
        {
            "introduction": "One of the simplest, yet most illustrative, ways to conceptualize convective adjustment is to imagine instantaneously rearranging water parcels to achieve the state of minimum gravitational potential energy, which corresponds to a density-sorted profile. This coding exercise () has you implement this idealized \"density-sorting\" scheme, a classic non-physical parameterization. This practice provides a clear, hands-on introduction to manipulating fluid parcels to enforce stability and serves as an excellent test of your algorithmic thinking.",
            "id": "3788325",
            "problem": "You are tasked with implementing a density-sorting convective adjustment scheme for a vertical ocean column with five layers. Each layer has a prescribed thickness, temperature, and salinity, denoted by $\\Delta z_i$, $T_i$, and $S_i$ for $i=1,2,3,4,5$, where $i=1$ is the surface layer and $i=5$ is the bottom layer. The physical aim of convective adjustment is to ensure static stability, namely that density is non-decreasing with depth. In discrete form for a five-layer column, static stability requires $\\rho_{i+1} \\ge \\rho_i$ for $i=1,2,3,4$, where $\\rho_i$ is the in-situ density of layer $i$ at a common reference pressure. You must use a linear Equation of State (EOS) for seawater to compute density from temperature and salinity:\n$$\n\\rho_i \\;=\\; \\rho_0 \\left[ 1 \\;-\\; \\alpha \\left( T_i - T_0 \\right) \\;+\\; \\beta \\left( S_i - S_0 \\right) \\right],\n$$\nwhere $\\rho_0$ is a constant reference density, $\\alpha$ is the thermal expansion coefficient, $\\beta$ is the haline contraction coefficient, $T_0$ is a reference temperature, and $S_0$ is a reference salinity. The density-sorting convective adjustment scheme rearranges the five layers in order of non-decreasing density with depth (i.e., lowest density at the surface, highest density at the bottom), without mixing, so that the resulting profile is neutrally stratified in the discrete sense. In this scheme, tracer conservation is ensured by pure permutation: the adjusted profile is formed by reassigning the original layer values $\\left(T_i,S_i\\right)$ to new positions such that $\\rho$ is non-decreasing with depth. The layer thicknesses $\\Delta z_i$ remain associated with their original model levels after adjustment; that is, you must produce the new ordered lists of $T$ and $S$ that correspond to a stable density ordering, but $\\Delta z$ is not altered. Ties in density (i.e., $\\rho_i=\\rho_j$ for some $i\\neq j$) must be broken by preserving the original vertical order from the surface to the bottom, i.e., use a stable sort that does not reorder equal-density layers.\n\nUse the following physical constants:\n- $\\rho_0 = 1027 \\,\\mathrm{kg\\,m^{-3}}$\n- $\\alpha = 2\\times 10^{-4} \\,\\mathrm{^{\\circ}C^{-1}}$\n- $\\beta = 7.5\\times 10^{-4} \\,(\\mathrm{g\\,kg^{-1}})^{-1}$\n- $T_0 = 10 \\,\\mathrm{^{\\circ}C}$\n- $S_0 = 35 \\,\\mathrm{g\\,kg^{-1}}$\n\nAll temperatures must be handled in degrees Celsius and all salinities in grams per kilogram ($\\mathrm{g\\,kg^{-1}}$). All thicknesses must be handled in meters.\n\nImplement a program that, for each test case in the test suite below, computes the adjusted neutrally stratified profile by density sorting and outputs the new ordered layer-mean $T$ and $S$ values. The final output must be expressed with $T$ in degrees Celsius and $S$ in grams per kilogram ($\\mathrm{g\\,kg^{-1}}$).\n\nTest suite specifications (each case provides $\\Delta z$, $T$, and $S$ as ordered lists from surface to bottom):\n- Case A (happy path with a modest instability):\n  - $\\Delta z = [10,\\,15,\\,20,\\,25,\\,30] \\,\\mathrm{m}$,\n  - $T = [10,\\,9,\\,11,\\,8,\\,7] \\,\\mathrm{^\\circ C}$,\n  - $S = [35.0,\\,34.0,\\,35.0,\\,35.2,\\,35.3] \\,\\mathrm{g\\,kg^{-1}}$.\n- Case B (boundary case with equal densities between two layers to test stable tie-handling):\n  - $\\Delta z = [5,\\,10,\\,15,\\,20,\\,25] \\,\\mathrm{m}$,\n  - $T = [9,\\,8,\\,10,\\,12,\\,11] \\,\\mathrm{^\\circ C}$,\n  - $S = [34.6,\\,34.8,\\,35.0,\\,35.533333,\\,35.4] \\,\\mathrm{g\\,kg^{-1}}$.\n- Case C (edge case with a strongly inverted initial profile):\n  - $\\Delta z = [8,\\,8,\\,8,\\,8,\\,8] \\,\\mathrm{m}$,\n  - $T = [2,\\,5,\\,10,\\,15,\\,20] \\,\\mathrm{^\\circ C}$,\n  - $S = [35.5,\\,35.0,\\,34.5,\\,34.0,\\,33.5] \\,\\mathrm{g\\,kg^{-1}}$.\n- Case D (already stable profile: no adjustment should change the order):\n  - $\\Delta z = [12,\\,12,\\,12,\\,12,\\,12] \\,\\mathrm{m}$,\n  - $T = [25,\\,20,\\,15,\\,10,\\,5] \\,\\mathrm{^\\circ C}$,\n  - $S = [33.5,\\,34.0,\\,34.5,\\,35.0,\\,35.5] \\,\\mathrm{g\\,kg^{-1}}$.\n\nAlgorithmic requirements:\n1. For each case, compute layer densities using the provided linear EOS. For sorting purposes, you may sort by the density anomaly factor\n   $$\n   \\sigma_i \\;=\\; -\\alpha \\left( T_i - T_0 \\right) \\;+\\; \\beta \\left( S_i - S_0 \\right),\n   $$\n   since $\\rho_i$ is strictly increasing in $\\sigma_i$ when $\\rho_00$ is constant.\n2. Perform a stable sort of layers by increasing $\\sigma_i$ (equivalently, increasing $\\rho_i$), assigning the lowest density to the surface and the highest density to the bottom, preserving the original order for equal $\\sigma_i$.\n3. Produce, for each case, the adjusted lists of $T$ and $S$ values corresponding to the sorted order.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be represented as a pair of lists: the sorted temperatures followed by the sorted salinities. Concretely, the output must have the form\n  $$\n  \\left[ \\left[ [T_{A,1},T_{A,2},T_{A,3},T_{A,4},T_{A,5}], [S_{A,1},S_{A,2},S_{A,3},S_{A,4},S_{A,5}] \\right], \\ldots \\right],\n  $$\n  where the ellipsis indicates the corresponding pair for Case B, Case C, and Case D in order. All numeric entries are floats or integers. The single printed line must match this structure with standard Python list formatting and no additional text.",
            "solution": "The problem statement has been validated and found to be scientifically grounded, well-posed, and self-contained. All necessary physical constants, initial conditions, and algorithmic requirements are provided without contradiction. The task is to implement a density-sorting convective adjustment scheme for a discrete five-layer ocean column, which is a standard procedure in computational oceanography for ensuring numerical models remain physically stable.\n\nThe fundamental principle underlying this problem is that of static stability in a fluid. A fluid column is statically stable if its density is a non-decreasing function of depth. Any configuration where a denser parcel of fluid lies above a less dense parcel is unstable and will lead to vertical motion (convection) that rearranges the parcels to restore a stable density stratification. In the context of a discrete vertical column with layers indexed $i=1, 2, ..., 5$ from the surface to the bottom, this stability condition is expressed as:\n$$\n\\rho_{i+1} \\ge \\rho_i \\quad \\text{for} \\quad i = 1, 2, 3, 4,\n$$\nwhere $\\rho_i$ is the density of the fluid in layer $i$.\n\nThe density of each layer, $\\rho_i$, is determined by its temperature, $T_i$, and salinity, $S_i$. The problem specifies a linear Equation of State (EOS) to relate these properties:\n$$\n\\rho_i = \\rho_0 \\left[ 1 - \\alpha \\left( T_i - T_0 \\right) + \\beta \\left( S_i - S_0 \\right) \\right].\n$$\nHere, $\\rho_0 = 1027 \\,\\mathrm{kg\\,m^{-3}}$ is a reference density, $\\alpha = 2 \\times 10^{-4} \\,\\mathrm{^{\\circ}C^{-1}}$ is the thermal expansion coefficient, $\\beta = 7.5 \\times 10^{-4} \\,(\\mathrm{g\\,kg^{-1}})^{-1}$ is the haline contraction coefficient, and $T_0 = 10 \\,\\mathrm{^{\\circ}C}$ and $S_0 = 35 \\,\\mathrm{g\\,kg^{-1}}$ are reference temperature and salinity, respectively. The term $-\\alpha(T_i - T_0)$ shows that density decreases as temperature increases (for $T_i > T_0$), and the term $+\\beta(S_i - S_0)$ shows that density increases as salinity increases (for $S_i > S_0$).\n\nThe prescribed convective adjustment scheme is a \"density-sorting\" algorithm. This is a non-physical parameterization, meaning it does not model the turbulent mixing dynamics of real-world convection. Instead, it instantaneously restores stability by reordering the fluid parcels of the column according to their density. The water parcel in each layer $i$ is defined by its properties $(T_i, S_i)$. The algorithm identifies any unstable density inversions and sorts the five parcels in ascending order of density, placing the least dense parcel at the surface (layer $i=1$) and the most dense parcel at the bottom (layer $i=5$). This process is a pure permutation; the original set of five $(T, S)$ pairs is preserved, but they are reassigned to different vertical layers to ensure a stable profile. The layer thicknesses, $\\Delta z_i$, remain fixed to their original model levels.\n\nFor computational purposes, it is sufficient to sort based on the density anomaly factor, $\\sigma_i$, defined as:\n$$\n\\sigma_i = -\\alpha \\left( T_i - T_0 \\right) + \\beta \\left( S_i - S_0 \\right).\n$$\nSince $\\rho_i = \\rho_0(1 + \\sigma_i)$ and $\\rho_0$ is a positive constant, $\\rho_i$ is a monotonically increasing function of $\\sigma_i$. Therefore, sorting the layers by $\\sigma_i$ in ascending order is equivalent to sorting them by $\\rho_i$ in ascending order.\n\nThe implementation procedure for each test case is as follows:\n$1$. For the initial vertical profile, defined by the lists of temperature $T = [T_1, T_2, T_3, T_4, T_5]$ and salinity $S = [S_1, S_2, S_3, S_4, S_5]$, form a list of five water parcels. Each parcel is a pair $(T_i, S_i)$, associated with its original layer index $i$.\n$2$. For each parcel $(T_i, S_i)$, calculate its corresponding density anomaly factor $\\sigma_i$.\n$3$. Perform a stable sort of the list of parcels based on their $\\sigma_i$ values in ascending order. A stable sort is critical for uniqueness, as it preserves the original relative order of any parcels that have identical densities (and thus identical $\\sigma_i$ values). This follows the physical intuition that parcels of equal density do not need to be interchanged.\n$4$. From the sorted list of parcels, extract the new, adjusted temperature and salinity profiles, $T_{\\text{adj}}$ and $S_{\\text{adj}}$. These lists represent the properties of the layers in the re-established, neutrally stratified water column, where the density is non-decreasing with depth. The final output is the pair of lists, $[T_{\\text{adj}}, S_{\\text{adj}}]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a density-sorting convective adjustment scheme for a 5-layer\n    ocean column based on a linear equation of state.\n    \"\"\"\n    \n    # Define physical constants\n    RHO_0 = 1027.0  # kg m^-3\n    ALPHA = 2.0e-4  # °C^-1\n    BETA = 7.5e-4   # (g/kg)^-1\n    T_0 = 10.0      # °C\n    S_0 = 35.0      # g/kg\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path with a modest instability)\n        {\n            \"T\": [10.0, 9.0, 11.0, 8.0, 7.0],\n            \"S\": [35.0, 34.0, 35.0, 35.2, 35.3]\n        },\n        # Case B (boundary case with equal densities)\n        {\n            \"T\": [9.0, 8.0, 10.0, 12.0, 11.0],\n            \"S\": [34.6, 34.8, 35.0, 35.0 + 8.0/15.0, 35.4]\n        },\n        # Case C (edge case with a strongly inverted profile)\n        {\n            \"T\": [2.0, 5.0, 10.0, 15.0, 20.0],\n            \"S\": [35.5, 35.0, 34.5, 34.0, 33.5]\n        },\n        # Case D (already stable profile)\n        {\n            \"T\": [25.0, 20.0, 15.0, 10.0, 5.0],\n            \"S\": [33.5, 34.0, 34.5, 35.0, 35.5]\n        }\n    ]\n\n    results = []\n    \n    # Define the density anomaly factor function\n    def sigma_factor(T, S):\n        return -ALPHA * (T - T_0) + BETA * (S - S_0)\n\n    for case in test_cases:\n        initial_T = case[\"T\"]\n        initial_S = case[\"S\"]\n\n        # 1. Combine T and S into a list of parcels (T_i, S_i)\n        parcels = list(zip(initial_T, initial_S))\n\n        # 2. Perform a stable sort of the parcels by increasing density (sigma).\n        #    Python's sorted() is stable by default.\n        #    The key is the lambda function that computes sigma for each parcel.\n        sorted_parcels = sorted(parcels, key=lambda p: sigma_factor(p[0], p[1]))\n\n        # 3. Unzip the sorted parcels back into adjusted T and S lists.\n        if sorted_parcels:\n            adjusted_T, adjusted_S = zip(*sorted_parcels)\n        else: # Handle empty case, though not in test suite\n            adjusted_T, adjusted_S = [], []\n        \n        # Format the result for this case as a pair of lists\n        # Use np.round to handle the floating point precision from Case B\n        # The problem doesn't specify precision, but this makes output clean.\n        # For submission, it is safer to use raw floats as calculated.\n        case_result = [list(adjusted_T), list(adjusted_S)]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The problem's sample print format `f\"[{','.join(map(str, results))}]\"`\n    # produces a string without spaces after the separating commas.\n    # `str(results)` produces a string with spaces. To be exact, we manually\n    # build the string as specified.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond simple sorting, a more physically-based convective adjustment scheme simulates the turbulent mixing process within unstable regions of the water column. This advanced practice () challenges you to implement a robust algorithm that identifies contiguous unstable blocks and homogenizes them via mass-weighted averaging. Successfully implementing this scheme will solidify your understanding of the crucial principles of mass and tracer conservation, which are non-negotiable requirements for any prognostic ocean model.",
            "id": "3788362",
            "problem": "Consider a one-dimensional vertical ocean column discretized into $N$ layers. Each layer $k \\in \\{0,1,\\dots,N-1\\}$ is characterized by a positive thickness $h_k$ (in $\\mathrm{m}$), an in-situ or potential density $\\rho_k$ (in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$), and a tracer concentration $c_k$ (for example, practical salinity) expressed in practical salinity unit (psu, a dimensionless number). The tracer concentration is constrained by known bounds $c_{\\min}$ and $c_{\\max}$, with $c_{\\min} \\leq c_k \\leq c_{\\max}$ for all $k$. The column is stably stratified if density is non-decreasing with depth, that is, if $\\rho_{k} \\leq \\rho_{k+1}$ for all $k \\in \\{0,1,\\dots,N-2\\}$. If there exists any index $k$ such that $\\rho_{k}  \\rho_{k+1}$, the column contains a statically unstable pair, and vertical convective adjustment must be applied.\n\nYou must design and implement a convective adjustment scheme that enforces static stability by homogenizing tracer and density within contiguous unstable blocks while conserving layer-wise mass and tracer. The scheme must:\n\n- Identify and merge adjacent layers into blocks whenever stability ($\\rho_{k} \\leq \\rho_{k+1}$) is violated, until the final adjusted density profile $\\tilde{\\rho}_k$ is non-decreasing with depth.\n- For each mixed block $B$ consisting of indices $k \\in B$, compute the post-adjustment block-constant density $\\tilde{\\rho}_k$ and tracer $\\tilde{c}_k$ using mass-weighted averaging over the block.\n- Demonstrate, for each test case, that all post-adjustment tracer values $\\tilde{c}_k$ remain within the original bounds $[c_{\\min}, c_{\\max}]$.\n- Ensure the final adjusted density profile $\\tilde{\\rho}_k$ is non-decreasing with depth.\n\nYour program must evaluate the following test suite, using the given units for inputs and computations. The program should output only booleans indicating whether each test case simultaneously satisfies both conditions: all post-adjustment tracer values are within inclusive bounds $[c_{\\min}, c_{\\max}]$ expressed in psu, and the final adjusted density is non-decreasing with depth expressed in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$.\n\nTest Suite (each case specifies $(h_k, \\rho_k, c_k, c_{\\min}, c_{\\max})$):\n\n- Case A (general unstable interior block):\n  - Thicknesses (in $\\mathrm{m}$): $[5.0, 7.5, 10.0, 12.5, 7.5]$\n  - Densities (in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$): $[1025.5, 1026.0, 1024.5, 1023.0, 1027.0]$\n  - Tracer salinity (in psu): $[34.2, 35.0, 33.0, 32.0, 36.0]$\n  - Bounds (in psu): $c_{\\min} = 0.0$, $c_{\\max} = 40.0$\n\n- Case B (entire column unstable, extreme tracer values included):\n  - Thicknesses (in $\\mathrm{m}$): $[10.0, 10.0, 10.0, 10.0]$\n  - Densities (in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$): $[1028.0, 1027.5, 1027.0, 1026.5]$\n  - Tracer salinity (in psu): $[0.0, 40.0, 20.0, 35.0]$\n  - Bounds (in psu): $c_{\\min} = 0.0$, $c_{\\max} = 40.0$\n\n- Case C (already stable column, no adjustment needed):\n  - Thicknesses (in $\\mathrm{m}$): $[8.0, 12.0, 15.0, 5.0]$\n  - Densities (in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$): $[1023.0, 1024.0, 1025.0, 1026.0]$\n  - Tracer salinity (in psu): $[33.5, 34.0, 34.5, 35.0]$\n  - Bounds (in psu): $c_{\\min} = 0.0$, $c_{\\max} = 40.0$\n\n- Case D (large contrast in layer thicknesses and tracer extremes, entire column unstable):\n  - Thicknesses (in $\\mathrm{m}$): $[1.0, 100.0, 1.0, 100.0]$\n  - Densities (in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$): $[1026.0, 1025.0, 1024.0, 1023.0]$\n  - Tracer salinity (in psu): $[0.0, 40.0, 0.0, 40.0]$\n  - Bounds (in psu): $c_{\\min} = 0.0$, $c_{\\max} = 40.0$\n\nAlgorithmic and physical requirements:\n\n- Use only mass-weighted averaging within mixed blocks to compute post-adjustment block-constant values $\\tilde{\\rho}_k$ and $\\tilde{c}_k$.\n- Preserve total tracer mass and total column mass exactly under the discretization given by the thicknesses $h_k$.\n- Enforce the static stability constraint $\\tilde{\\rho}_k \\leq \\tilde{\\rho}_{k+1}$ for all $k$.\n- Verify and report, per test case, whether the final adjusted tracer values satisfy $c_{\\min} \\leq \\tilde{c}_k \\leq c_{\\max}$ for all $k$ in the column.\n\nFinal Output Format:\n\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets, for example, $[\\text{True},\\text{False},\\text{True},\\text{True}]$ where each boolean corresponds to the test cases $(\\text{A}, \\text{B}, \\text{C}, \\text{D})$ in order.",
            "solution": "The problem requires the design and implementation of a convective adjustment scheme for a one-dimensional ocean column. This is a common parameterization in ocean models to eliminate static instabilities, where denser water overlies lighter water. The solution involves identifying such instabilities and simulating the resultant vertical mixing, which homogenizes properties within the unstable region.\n\nThe core principles guiding the scheme are the conservation of mass and the conservation of tracers within any block of fluid that mixes. The column is discretized into $N$ layers, each with thickness $h_k$, density $\\rho_k$, and tracer concentration $c_k$ for $k \\in \\{0, 1, \\dots, N-1\\}$. We consider a constant horizontal area $A$ for each layer, which will cancel out in all calculations and can be set to $A=1$. The mass of layer $k$ is $m_k = \\rho_k V_k = \\rho_k (h_k A)$. The amount of tracer in layer $k$ is $C_k = c_k m_k = c_k \\rho_k h_k A$.\n\nWhen a contiguous block of layers, indexed by the set $B$, becomes unstable and mixes, it forms a single new homogeneous layer. According to the conservation principles:\n1.  **Mass Conservation**: The total mass of the new layer must equal the sum of the masses of the original layers.\n2.  **Tracer Conservation**: The total amount of tracer in the new layer must equal the sum of the tracer amounts in the original layers.\n3.  **Volume Conservation**: The volume of the new layer is the sum of the original layer volumes. This implies the new thickness is $\\tilde{h}_B = \\sum_{k \\in B} h_k$.\n\nFrom these principles, we derive the properties of the homogenized block. Let the new block have properties $\\tilde{h}_B, \\tilde{\\rho}_B, \\tilde{c}_B$.\nThe total mass in the block is $M_B = \\sum_{k \\in B} m_k = A \\sum_{k \\in B} \\rho_k h_k$. The total volume is $V_B = A \\sum_{k \\in B} h_k = A \\tilde{h}_B$.\nThe new density $\\tilde{\\rho}_B$ is the total mass divided by the total volume:\n$$ \\tilde{\\rho}_B = \\frac{M_B}{V_B} = \\frac{A \\sum_{k \\in B} \\rho_k h_k}{A \\sum_{k \\in B} h_k} = \\frac{\\sum_{k \\in B} \\rho_k h_k}{\\sum_{k \\in B} h_k} $$\nThis is a volume-weighted average of the initial densities.\n\nThe total tracer amount in the block is $C_B = \\sum_{k \\in B} C_k = A \\sum_{k \\in B} c_k \\rho_k h_k$.\nThe new tracer concentration $\\tilde{c}_B$ is the total tracer amount divided by the total mass:\n$$ \\tilde{c}_B = \\frac{C_B}{M_B} = \\frac{A \\sum_{k \\in B} c_k \\rho_k h_k}{A \\sum_{k \\in B} \\rho_k h_k} = \\frac{\\sum_{k \\in B} c_k \\rho_k h_k}{\\sum_{k \\in B} \\rho_k h_k} $$\nThis is a mass-weighted average of the initial tracer concentrations.\n\nAn instability is defined to exist if for any adjacent pair of layers $k$ and $k+1$, we have $\\rho_k  \\rho_{k+1}$. The algorithm must resolve all such instabilities until the entire column is stable, i.e., $\\tilde{\\rho}_k \\leq \\tilde{\\rho}_{k+1}$ for all $k$. A single pass through the column is insufficient, as merging two layers can create a new instability with a layer above the merged block. A robust iterative approach is required. The algorithm proceeds as follows:\n\n1.  Initialize a pointer $k=0$ to the topmost layer.\n2.  Iterate while $k$ is less than the second to last layer index.\n3.  At the current position $k$, compare the density $\\rho_k$ with the density of the layer below, $\\rho_{k+1}$.\n4.  If $\\rho_k  \\rho_{k+1}$ (an instability), merge layers $k$ and $k+1$. The properties of the new layer at index $k$ are calculated using the averaging formulas above. The layer at $k+1$ is removed, and the total number of layers is decremented. After a merge, the new layer might be unstable with the layer above it (at index $k-1$). To handle this, the pointer $k$ is moved back one step, i.e., $k = \\max(0, k-1)$.\n5.  If $\\rho_k \\leq \\rho_{k+1}$ (stable), move to the next pair by incrementing the pointer, $k = k+1$.\n6.  The process terminates when the pointer has traversed the entire column without finding any instabilities. The resulting density profile is guaranteed to be non-decreasing with depth.\n\nFinally, we must verify two conditions for the adjusted column:\n1.  The final density profile is non-decreasing: $\\tilde{\\rho}_{k} \\leq \\tilde{\\rho}_{k+1}$ for all $k$. The algorithm described is constructed to guarantee this outcome.\n2.  All final tracer concentrations $\\tilde{c}_k$ are within the given bounds $[c_{\\min}, c_{\\max}]$. The formula for $\\tilde{c}$ is a weighted average of the initial concentrations $c_k$, where the weights (masses $\\rho_k h_k A$) are all positive. A property of such averages is that the result must lie within the range of the input values. Since all initial $c_k$ satisfy $c_{\\min} \\leq c_k \\leq c_{\\max}$, any mixed value $\\tilde{c}_k$ will also satisfy $c_{\\min} \\leq \\tilde{c}_k \\leq c_{\\max}$.\n\nTherefore, for any valid input, a correct implementation of the convective adjustment algorithm should always produce a result that satisfies both conditions. The evaluation for each test case should thus yield `True`.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the convective adjustment scheme for all test cases\n    and print the verification results.\n    \"\"\"\n\n    test_cases = [\n        {\n            # Case A: General unstable interior block\n            \"h\": [5.0, 7.5, 10.0, 12.5, 7.5],\n            \"rho\": [1025.5, 1026.0, 1024.5, 1023.0, 1027.0],\n            \"c\": [34.2, 35.0, 33.0, 32.0, 36.0],\n            \"c_min\": 0.0,\n            \"c_max\": 40.0,\n        },\n        {\n            # Case B: Entire column unstable, extreme tracer values included\n            \"h\": [10.0, 10.0, 10.0, 10.0],\n            \"rho\": [1028.0, 1027.5, 1027.0, 1026.5],\n            \"c\": [0.0, 40.0, 20.0, 35.0],\n            \"c_min\": 0.0,\n            \"c_max\": 40.0,\n        },\n        {\n            # Case C: Already stable column, no adjustment needed\n            \"h\": [8.0, 12.0, 15.0, 5.0],\n            \"rho\": [1023.0, 1024.0, 1025.0, 1026.0],\n            \"c\": [33.5, 34.0, 34.5, 35.0],\n            \"c_min\": 0.0,\n            \"c_max\": 40.0,\n        },\n        {\n            # Case D: Large contrast in layer thicknesses and tracer extremes\n            \"h\": [1.0, 100.0, 1.0, 100.0],\n            \"rho\": [1026.0, 1025.0, 1024.0, 1023.0],\n            \"c\": [0.0, 40.0, 0.0, 40.0],\n            \"c_min\": 0.0,\n            \"c_max\": 40.0,\n        },\n    ]\n\n    def run_convective_adjustment(h_in, rho_in, c_in):\n        \"\"\"\n        Applies the convective adjustment algorithm to a water column.\n\n        Args:\n            h_in (list): Initial layer thicknesses.\n            rho_in (list): Initial layer densities.\n            c_in (list): Initial layer tracer concentrations.\n\n        Returns:\n            tuple: A tuple containing the adjusted lists (h_adj, rho_adj, c_adj).\n        \"\"\"\n        # Use lists for dynamic resizing during merging.\n        h_adj = list(h_in)\n        rho_adj = list(rho_in)\n        c_adj = list(c_in)\n\n        k = 0\n        # The loop must continue until a full pass without merges is completed.\n        while k  len(rho_adj) - 1:\n            # Check for instability\n            if rho_adj[k]  rho_adj[k+1]:\n                # Unstable pair found, merge layers k and k+1.\n                \n                # Properties of layer k\n                h1, rho1, c1 = h_adj[k], rho_adj[k], c_adj[k]\n                \n                # Properties of layer k+1\n                h2, rho2, c2 = h_adj[k+1], rho_adj[k+1], c_adj[k+1]\n\n                # Mass per unit area\n                m1 = rho1 * h1\n                m2 = rho2 * h2\n                total_mass = m1 + m2\n                \n                # Total tracer amount\n                tracer_amount1 = c1 * m1\n                tracer_amount2 = c2 * m2\n                total_tracer_amount = tracer_amount1 + tracer_amount2\n\n                # New merged layer properties\n                new_h = h1 + h2\n                # New density is volume-weighted average\n                new_rho = total_mass / new_h\n                # New tracer is mass-weighted average\n                new_c = total_tracer_amount / total_mass\n                \n                # Update layer k with merged properties\n                h_adj[k] = new_h\n                rho_adj[k] = new_rho\n                c_adj[k] = new_c\n                \n                # Remove layer k+1\n                h_adj.pop(k+1)\n                rho_adj.pop(k+1)\n                c_adj.pop(k+1)\n                \n                # Step back to check for instability with the layer above\n                k = max(0, k - 1)\n            else:\n                # Stable pair, move to the next one\n                k += 1\n        \n        return h_adj, rho_adj, c_adj\n\n    results = []\n    for case in test_cases:\n        h, rho, c, c_min, c_max = case[\"h\"], case[\"rho\"], case[\"c\"], case[\"c_min\"], case[\"c_max\"]\n\n        # Run the adjustment\n        h_adj, rho_adj, c_adj = run_convective_adjustment(h, rho, c)\n        \n        # --- Verification Step ---\n        \n        # 1. Verify stability: final density profile is non-decreasing\n        is_stable = all(rho_adj[k] = rho_adj[k+1] for k in range(len(rho_adj) - 1))\n        \n        # 2. Verify tracer bounds: all tracer values are within [c_min, c_max]\n        are_bounds_kept = all(c_min = val = c_max for val in c_adj)\n        \n        # The result is True if and only if both conditions are met.\n        results.append(is_stable and are_bounds_kept)\n\n    # Format the final output as a comma-separated list of booleans in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}