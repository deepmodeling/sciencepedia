{
    "hands_on_practices": [
        {
            "introduction": "Before implementing any adjustment scheme, it is essential to have a precise mathematical criterion for static stability. This exercise connects the abstract concept of stability to the vertical gradients of temperature and salinity through the Brunt–Väisälä frequency, $N^2$. By deriving the expression for $N^2$ under idealized linear conditions, you will build a fundamental understanding of how density stratification governs vertical motion in the ocean.",
            "id": "3788352",
            "problem": "Consider a one-dimensional ocean column occupying depths $-100 \\le z \\le 0$ m, where $z$ is the vertical coordinate with $z=0$ at the sea surface and $z$ increasing upward. The observed temperature and salinity profiles are linear in depth, given by $T(z) = T_{s} + \\gamma_{T} z$ and $S(z) = S_{s} + \\gamma_{S} z$, where $T_{s}$ and $S_{s}$ are constant surface values, and $\\gamma_{T}$ and $\\gamma_{S}$ are constant vertical gradients. Assume the Boussinesq approximation, hydrostatic balance, and a linearized equation of state about a reference density $\\rho_{0}$ such that density perturbations satisfy $\\rho' = -\\rho_{0}\\left(\\alpha\\,T' - \\beta\\,S'\\right)$, where $\\alpha$ is the thermal expansion coefficient and $\\beta$ is the haline contraction coefficient. Use $g = 9.81$ m s$^{-2}$, $\\alpha = 2\\times 10^{-4}$ K$^{-1}$, $\\beta = 8\\times 10^{-4}$ psu$^{-1}$, and $\\rho_{0} = 1025$ kg m$^{-3}$. Starting from the definitions of buoyancy $b = -g\\,\\rho'/\\rho_{0}$ and the squared Brunt–Väisälä (buoyancy) frequency $N^{2}(z) = \\partial b/\\partial z$, derive an analytic expression for $N^{2}(z)$ in terms of $g$, $\\alpha$, $\\beta$, $\\gamma_{T}$, and $\\gamma_{S}$. Then, using the sign of the derived expression, identify the depths in the column that would be flagged as statically unstable by a convective adjustment scheme that instantaneously homogenizes any sublayer where $N^{2}(z)  0$. Express the final $N^{2}(z)$ expression in SI units of s$^{-2}$. Report only the analytic expression for $N^{2}(z)$. No numerical evaluation is required.",
            "solution": "The problem is first validated to ensure it is scientifically sound, well-posed, and complete.\n\n### Step 1: Extract Givens\n- Domain: A one-dimensional ocean column with vertical coordinate $z$ such that $-100 \\le z \\le 0$ m. $z=0$ is the sea surface.\n- Temperature profile: $T(z) = T_{s} + \\gamma_{T} z$, where $T_s$ and $\\gamma_T$ are constants.\n- Salinity profile: $S(z) = S_{s} + \\gamma_{S} z$, where $S_s$ and $\\gamma_S$ are constants.\n- Approximations: Boussinesq approximation and hydrostatic balance are assumed.\n- Linearized equation of state: The density perturbation $\\rho'$ is given by $\\rho' = -\\rho_{0}\\left(\\alpha\\,T' - \\beta\\,S'\\right)$, where $T'$ and $S'$ are temperature and salinity perturbations, respectively.\n- Constants:\n    - Gravitational acceleration: $g = 9.81$ m s$^{-2}$.\n    - Thermal expansion coefficient: $\\alpha = 2\\times 10^{-4}$ K$^{-1}$.\n    - Haline contraction coefficient: $\\beta = 8\\times 10^{-4}$ psu$^{-1}$.\n    - Reference density: $\\rho_{0} = 1025$ kg m$^{-3}$.\n- Definitions:\n    - Buoyancy: $b = -g\\,\\rho'/\\rho_{0}$.\n    - Squared Brunt–Väisälä (buoyancy) frequency: $N^{2}(z) = \\partial b/\\partial z$.\n- Task:\n    1. Derive an analytic expression for $N^{2}(z)$ in terms of $g$, $\\alpha$, $\\beta$, $\\gamma_{T}$, and $\\gamma_{S}$.\n    2. Identify the depths that are statically unstable ($N^{2}(z)  0$).\n    3. Express the final $N^{2}(z)$ expression in SI units of s$^{-2}$.\n    4. Report only the analytic expression for $N^{2}(z)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, utilizing standard concepts and equations from physical oceanography, such as the Boussinesq approximation, a linearized equation of state, and the definitions of buoyancy and the Brunt-Väisälä frequency. The provided numerical constants are physically realistic. The problem is well-posed; it provides all necessary information to derive the requested expression. The language is objective and unambiguous. The instructions for the final output are specific but do not introduce any contradiction to the physics of the problem. Therefore, the problem is deemed valid.\n\n### Step 3: Verdict and Action\nThe problem is valid. The solution will now be derived.\n\n### Derivation\nThe squared Brunt-Väisälä frequency, $N^{2}(z)$, is a measure of the static stability of a fluid column. It is defined as the vertical gradient of buoyancy, $N^{2}(z) = \\partial b/\\partial z$.\n\nFirst, we establish an expression for buoyancy, $b(z)$. The problem provides the definition $b = -g\\,\\rho'/\\rho_{0}$. The density perturbation, $\\rho'$, is given by the linearized equation of state, $\\rho' = -\\rho_{0}(\\alpha T' - \\beta S')$. The terms $T'$ and $S'$ represent deviations from a reference state. For calculating the stratification of a background profile $T(z)$ and $S(z)$, the relevant density is $\\rho(z) = \\rho_0(1 - \\alpha(T(z)-T_{ref}) + \\beta(S(z)-S_{ref}))$, where $T_{ref}$ and $S_{ref}$ are constant reference values. The density anomaly relative to the reference density $\\rho_0$ is then $\\rho(z) - \\rho_0$. The buoyancy related to this stratification is $b(z) = -g (\\rho(z)-\\rho_0)/\\rho_0 = g(\\alpha(T(z)-T_{ref}) - \\beta(S(z)-S_{ref}))$.\n\nTo find $N^{2}(z)$, we differentiate this expression for $b(z)$ with respect to the vertical coordinate $z$:\n$$N^{2}(z) = \\frac{\\partial b}{\\partial z} = \\frac{\\partial}{\\partial z} \\left[ g\\left(\\alpha(T(z)-T_{ref}) - \\beta(S(z)-S_{ref})\\right) \\right]$$\nSince $g$, $\\alpha$, $\\beta$, $T_{ref}$, and $S_{ref}$ are all constants, the differentiation yields:\n$$N^{2}(z) = g \\left( \\alpha \\frac{dT}{dz} - \\beta \\frac{dS}{dz} \\right)$$\nThis is the general expression for the squared Brunt-Väisälä frequency under the given linearized equation of state.\n\nThe problem specifies linear profiles for temperature and salinity:\n$T(z) = T_{s} + \\gamma_{T} z$\n$S(z) = S_{s} + \\gamma_{S} z$\n\nWe compute the vertical gradients, $\\frac{dT}{dz}$ and $\\frac{dS}{dz}$, from these profiles:\n$$\\frac{dT}{dz} = \\frac{d}{dz} (T_{s} + \\gamma_{T} z) = \\gamma_{T}$$\n$$\\frac{dS}{dz} = \\frac{d}{dz} (S_{s} + \\gamma_{S} z) = \\gamma_{S}$$\nSince $\\gamma_{T}$ and $\\gamma_{S}$ are constants, the vertical gradients of temperature and salinity are constant throughout the water column.\n\nSubstituting these constant gradients into the expression for $N^{2}(z)$:\n$$N^{2}(z) = g \\left( \\alpha \\gamma_{T} - \\beta \\gamma_{S} \\right)$$\nAs all terms on the right-hand side are constants, $N^{2}$ is itself a constant, independent of depth $z$.\n\nA convective adjustment scheme would flag any sublayer as statically unstable if $N^{2}(z)  0$. In this case, since $N^{2}$ is constant, the stability condition applies to the entire column, $-100 \\le z \\le 0$ m. The condition for instability is:\n$$g \\left( \\alpha \\gamma_{T} - \\beta \\gamma_{S} \\right)  0$$\nSince $g > 0$, this inequality simplifies to:\n$$\\alpha \\gamma_{T} - \\beta \\gamma_{S}  0 \\quad \\text{or} \\quad \\alpha \\gamma_{T}  \\beta \\gamma_{S}$$\nIf this condition is met, the entire water column is statically unstable. If $\\alpha \\gamma_{T} \\ge \\beta \\gamma_{S}$, the entire column is stable or neutral, and no part of it would be flagged for convective adjustment.\n\nThe units of the derived expression are checked for consistency. The units of the terms are:\n- $[g]$ = m s$^{-2}$\n- $[\\alpha]$ = K$^{-1}$\n- $[\\gamma_T]$ = K m$^{-1}$\n- $[\\beta]$ = psu$^{-1}$ (psu is a practical salinity unit, often treated as dimensionless in such calculations)\n- $[\\gamma_S]$ = psu m$^{-1}$\n\nThus, the units of $N^{2}$ are:\n$$[\\text{m s}^{-2}] \\times ([\\text{K}^{-1}][\\text{K m}^{-1}] - [\\text{psu}^{-1}][\\text{psu m}^{-1}]) = [\\text{m s}^{-2}] \\times ([\\text{m}^{-1}] - [\\text{m}^{-1}]) = \\text{s}^{-2}$$\nThe units are correct SI units for squared frequency.\n\nThe problem asks for the analytic expression for $N^{2}(z)$. As derived, this is $g(\\alpha \\gamma_T - \\beta \\gamma_S)$.",
            "answer": "$$\n\\boxed{g \\left( \\alpha \\gamma_{T} - \\beta \\gamma_{S} \\right)}\n$$"
        },
        {
            "introduction": "Once an instability is detected, a convective adjustment scheme must restore a stable density profile while adhering to physical conservation laws. This practice guides you through implementing a common iterative mixing algorithm that homogenizes contiguous unstable layers until stability is achieved. Successfully completing this task demonstrates your ability to translate conservation principles for mass and tracers into a robust numerical code.",
            "id": "3788362",
            "problem": "Consider a one-dimensional vertical ocean column discretized into $N$ layers. Each layer $k \\in \\{0,1,\\dots,N-1\\}$ is characterized by a positive thickness $h_k$ (in $\\mathrm{m}$), an in-situ or potential density $\\rho_k$ (in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$), and a tracer concentration $c_k$ (for example, practical salinity) expressed in practical salinity unit (psu, a dimensionless number). The tracer concentration is constrained by known bounds $c_{\\min}$ and $c_{\\max}$, with $c_{\\min} \\leq c_k \\leq c_{\\max}$ for all $k$. The column is stably stratified if density is non-decreasing with depth, that is, if $\\rho_{k} \\leq \\rho_{k+1}$ for all $k \\in \\{0,1,\\dots,N-2\\}$. If there exists any index $k$ such that $\\rho_{k}  \\rho_{k+1}$, the column contains a statically unstable pair, and vertical convective adjustment must be applied.\n\nYou must design and implement a convective adjustment scheme that enforces static stability by homogenizing tracer and density within contiguous unstable blocks while conserving layer-wise mass and tracer. The scheme must:\n\n- Identify and merge adjacent layers into blocks whenever stability ($\\rho_{k} \\leq \\rho_{k+1}$) is violated, until the final adjusted density profile $\\tilde{\\rho}_k$ is non-decreasing with depth.\n- For each mixed block $B$ consisting of indices $k \\in B$, compute the post-adjustment block-constant density $\\tilde{\\rho}_k$ and tracer $\\tilde{c}_k$ using mass-weighted averaging over the block.\n- Demonstrate, for each test case, that all post-adjustment tracer values $\\tilde{c}_k$ remain within the original bounds $[c_{\\min}, c_{\\max}]$.\n- Ensure the final adjusted density profile $\\tilde{\\rho}_k$ is non-decreasing with depth.\n\nYour program must evaluate the following test suite, using the given units for inputs and computations. The program should output only booleans indicating whether each test case simultaneously satisfies both conditions: all post-adjustment tracer values are within inclusive bounds $[c_{\\min}, c_{\\max}]$ expressed in psu, and the final adjusted density is non-decreasing with depth expressed in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$.\n\nTest Suite (each case specifies $(h_k, \\rho_k, c_k, c_{\\min}, c_{\\max})$):\n\n- Case A (general unstable interior block):\n  - Thicknesses (in $\\mathrm{m}$): $[5.0, 7.5, 10.0, 12.5, 7.5]$\n  - Densities (in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$): $[1025.5, 1026.0, 1024.5, 1023.0, 1027.0]$\n  - Tracer salinity (in psu): $[34.2, 35.0, 33.0, 32.0, 36.0]$\n  - Bounds (in psu): $c_{\\min} = 0.0$, $c_{\\max} = 40.0$\n\n- Case B (entire column unstable, extreme tracer values included):\n  - Thicknesses (in $\\mathrm{m}$): $[10.0, 10.0, 10.0, 10.0]$\n  - Densities (in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$): $[1028.0, 1027.5, 1027.0, 1026.5]$\n  - Tracer salinity (in psu): $[0.0, 40.0, 20.0, 35.0]$\n  - Bounds (in psu): $c_{\\min} = 0.0$, $c_{\\max} = 40.0$\n\n- Case C (already stable column, no adjustment needed):\n  - Thicknesses (in $\\mathrm{m}$): $[8.0, 12.0, 15.0, 5.0]$\n  - Densities (in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$): $[1023.0, 1024.0, 1025.0, 1026.0]$\n  - Tracer salinity (in psu): $[33.5, 34.0, 34.5, 35.0]$\n  - Bounds (in psu): $c_{\\min} = 0.0$, $c_{\\max} = 40.0$\n\n- Case D (large contrast in layer thicknesses and tracer extremes, entire column unstable):\n  - Thicknesses (in $\\mathrm{m}$): $[1.0, 100.0, 1.0, 100.0]$\n  - Densities (in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$): $[1026.0, 1025.0, 1024.0, 1023.0]$\n  - Tracer salinity (in psu): $[0.0, 40.0, 0.0, 40.0]$\n  - Bounds (in psu): $c_{\\min} = 0.0$, $c_{\\max} = 40.0$\n\nAlgorithmic and physical requirements:\n\n- Use only mass-weighted averaging within mixed blocks to compute post-adjustment block-constant values $\\tilde{\\rho}_k$ and $\\tilde{c}_k$.\n- Preserve total tracer mass and total column mass exactly under the discretization given by the thicknesses $h_k$.\n- Enforce the static stability constraint $\\tilde{\\rho}_k \\leq \\tilde{\\rho}_{k+1}$ for all $k$.\n- Verify and report, per test case, whether the final adjusted tracer values satisfy $c_{\\min} \\leq \\tilde{c}_k \\leq c_{\\max}$ for all $k$ in the column.\n\nFinal Output Format:\n\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets, for example, $[\\text{True},\\text{False},\\text{True},\\text{True}]$ where each boolean corresponds to the test cases $(\\text{A}, \\text{B}, \\text{C}, \\text{D})$ in order.",
            "solution": "The problem requires the design and implementation of a convective adjustment scheme for a one-dimensional ocean column. This is a common parameterization in ocean models to eliminate static instabilities, where denser water overlies lighter water. The solution involves identifying such instabilities and simulating the resultant vertical mixing, which homogenizes properties within the unstable region.\n\nThe core principles guiding the scheme are the conservation of mass and the conservation of tracers within any block of fluid that mixes. The column is discretized into $N$ layers, each with thickness $h_k$, density $\\rho_k$, and tracer concentration $c_k$ for $k \\in \\{0, 1, \\dots, N-1\\}$. We consider a constant horizontal area $A$ for each layer, which will cancel out in all calculations and can be set to $A=1$. The mass of layer $k$ is $m_k = \\rho_k V_k = \\rho_k (h_k A)$. The amount of tracer in layer $k$ is $C_k = c_k m_k = c_k \\rho_k h_k A$.\n\nWhen a contiguous block of layers, indexed by the set $B$, becomes unstable and mixes, it forms a single new homogeneous layer. According to the conservation principles:\n1.  **Mass Conservation**: The total mass of the new layer must equal the sum of the masses of the original layers.\n2.  **Tracer Conservation**: The total amount of tracer in the new layer must equal the sum of the tracer amounts in the original layers.\n3.  **Volume Conservation**: The volume of the new layer is the sum of the original layer volumes. This implies the new thickness is $\\tilde{h}_B = \\sum_{k \\in B} h_k$.\n\nFrom these principles, we derive the properties of the homogenized block. Let the new block have properties $\\tilde{h}_B, \\tilde{\\rho}_B, \\tilde{c}_B$.\nThe total mass in the block is $M_B = \\sum_{k \\in B} m_k = A \\sum_{k \\in B} \\rho_k h_k$. The total volume is $V_B = A \\sum_{k \\in B} h_k = A \\tilde{h}_B$.\nThe new density $\\tilde{\\rho}_B$ is the total mass divided by the total volume:\n$$ \\tilde{\\rho}_B = \\frac{M_B}{V_B} = \\frac{A \\sum_{k \\in B} \\rho_k h_k}{A \\sum_{k \\in B} h_k} = \\frac{\\sum_{k \\in B} \\rho_k h_k}{\\sum_{k \\in B} h_k} $$\nThis is a volume-weighted average of the initial densities.\n\nThe total tracer amount in the block is $C_B = \\sum_{k \\in B} C_k = A \\sum_{k \\in B} c_k \\rho_k h_k$.\nThe new tracer concentration $\\tilde{c}_B$ is the total tracer amount divided by the total mass:\n$$ \\tilde{c}_B = \\frac{C_B}{M_B} = \\frac{A \\sum_{k \\in B} c_k \\rho_k h_k}{A \\sum_{k \\in B} \\rho_k h_k} = \\frac{\\sum_{k \\in B} c_k \\rho_k h_k}{\\sum_{k \\in B} \\rho_k h_k} $$\nThis is a mass-weighted average of the initial tracer concentrations.\n\nAn instability is defined to exist if for any adjacent pair of layers $k$ and $k+1$, we have $\\rho_k  \\rho_{k+1}$. The algorithm must resolve all such instabilities until the entire column is stable, i.e., $\\tilde{\\rho}_k \\leq \\tilde{\\rho}_{k+1}$ for all $k$. A single pass through the column is insufficient, as merging two layers can create a new instability with a layer above the merged block. A robust iterative approach is required. The algorithm proceeds as follows:\n\n1.  Initialize a pointer $k=0$ to the topmost layer.\n2.  Iterate while $k$ is less than the second to last layer index.\n3.  At the current position $k$, compare the density $\\rho_k$ with the density of the layer below, $\\rho_{k+1}$.\n4.  If $\\rho_k  \\rho_{k+1}$ (an instability), merge layers $k$ and $k+1$. The properties of the new layer at index $k$ are calculated using the averaging formulas above. The layer at $k+1$ is removed, and the total number of layers is decremented. After a merge, the new layer might be unstable with the layer above it (at index $k-1$). To handle this, the pointer $k$ is moved back one step, i.e., $k = \\max(0, k-1)$.\n5.  If $\\rho_k \\leq \\rho_{k+1}$ (stable), move to the next pair by incrementing the pointer, $k = k+1$.\n6.  The process terminates when the pointer has traversed the entire column without finding any instabilities. The resulting density profile is guaranteed to be non-decreasing with depth.\n\nFinally, we must verify two conditions for the adjusted column:\n1.  The final density profile is non-decreasing: $\\tilde{\\rho}_{k} \\leq \\tilde{\\rho}_{k+1}$ for all $k$. The algorithm described is constructed to guarantee this outcome.\n2.  All final tracer concentrations $\\tilde{c}_k$ are within the given bounds $[c_{\\min}, c_{\\max}]$. The formula for $\\tilde{c}$ is a weighted average of the initial concentrations $c_k$, where the weights (masses $\\rho_k h_k A$) are all positive. A property of such averages is that the result must lie within the range of the input values. Since all initial $c_k$ satisfy $c_{\\min} \\leq c_k \\leq c_{\\max}$, any mixed value $\\tilde{c}_k$ will also satisfy $c_{\\min} \\leq \\tilde{c}_k \\leq c_{\\max}$.\n\nTherefore, for any valid input, a correct implementation of the convective adjustment algorithm should always produce a result that satisfies both conditions. The evaluation for each test case should thus yield `True`.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the convective adjustment scheme for all test cases\n    and print the verification results.\n    \"\"\"\n\n    test_cases = [\n        {\n            # Case A: General unstable interior block\n            \"h\": [5.0, 7.5, 10.0, 12.5, 7.5],\n            \"rho\": [1025.5, 1026.0, 1024.5, 1023.0, 1027.0],\n            \"c\": [34.2, 35.0, 33.0, 32.0, 36.0],\n            \"c_min\": 0.0,\n            \"c_max\": 40.0,\n        },\n        {\n            # Case B: Entire column unstable, extreme tracer values included\n            \"h\": [10.0, 10.0, 10.0, 10.0],\n            \"rho\": [1028.0, 1027.5, 1027.0, 1026.5],\n            \"c\": [0.0, 40.0, 20.0, 35.0],\n            \"c_min\": 0.0,\n            \"c_max\": 40.0,\n        },\n        {\n            # Case C: Already stable column, no adjustment needed\n            \"h\": [8.0, 12.0, 15.0, 5.0],\n            \"rho\": [1023.0, 1024.0, 1025.0, 1026.0],\n            \"c\": [33.5, 34.0, 34.5, 35.0],\n            \"c_min\": 0.0,\n            \"c_max\": 40.0,\n        },\n        {\n            # Case D: Large contrast in layer thicknesses and tracer extremes\n            \"h\": [1.0, 100.0, 1.0, 100.0],\n            \"rho\": [1026.0, 1025.0, 1024.0, 1023.0],\n            \"c\": [0.0, 40.0, 0.0, 40.0],\n            \"c_min\": 0.0,\n            \"c_max\": 40.0,\n        },\n    ]\n\n    def run_convective_adjustment(h_in, rho_in, c_in):\n        \"\"\"\n        Applies the convective adjustment algorithm to a water column.\n\n        Args:\n            h_in (list): Initial layer thicknesses.\n            rho_in (list): Initial layer densities.\n            c_in (list): Initial layer tracer concentrations.\n\n        Returns:\n            tuple: A tuple containing the adjusted lists (h_adj, rho_adj, c_adj).\n        \"\"\"\n        # Use lists for dynamic resizing during merging.\n        h_adj = list(h_in)\n        rho_adj = list(rho_in)\n        c_adj = list(c_in)\n\n        k = 0\n        # The loop must continue until a full pass without merges is completed.\n        while k  len(rho_adj) - 1:\n            # Check for instability\n            if rho_adj[k]  rho_adj[k+1]:\n                # Unstable pair found, merge layers k and k+1.\n                \n                # Properties of layer k\n                h1, rho1, c1 = h_adj[k], rho_adj[k], c_adj[k]\n                \n                # Properties of layer k+1\n                h2, rho2, c2 = h_adj[k+1], rho_adj[k+1], c_adj[k+1]\n\n                # Mass per unit area\n                m1 = rho1 * h1\n                m2 = rho2 * h2\n                total_mass = m1 + m2\n                \n                # Total tracer amount\n                tracer_amount1 = c1 * m1\n                tracer_amount2 = c2 * m2\n                total_tracer_amount = tracer_amount1 + tracer_amount2\n\n                # New merged layer properties\n                new_h = h1 + h2\n                # New density is volume-weighted average\n                new_rho = total_mass / new_h\n                # New tracer is mass-weighted average\n                new_c = total_tracer_amount / total_mass\n                \n                # Update layer k with merged properties\n                h_adj[k] = new_h\n                rho_adj[k] = new_rho\n                c_adj[k] = new_c\n                \n                # Remove layer k+1\n                h_adj.pop(k+1)\n                rho_adj.pop(k+1)\n                c_adj.pop(k+1)\n                \n                # Step back to check for instability with the layer above\n                k = max(0, k - 1)\n            else:\n                # Stable pair, move to the next one\n                k += 1\n        \n        return h_adj, rho_adj, c_adj\n\n    results = []\n    for case in test_cases:\n        h, rho, c, c_min, c_max = case[\"h\"], case[\"rho\"], case[\"c\"], case[\"c_min\"], case[\"c_max\"]\n\n        # Run the adjustment\n        h_adj, rho_adj, c_adj = run_convective_adjustment(h, rho, c)\n        \n        # --- Verification Step ---\n        \n        # 1. Verify stability: final density profile is non-decreasing\n        is_stable = all(rho_adj[k] = rho_adj[k+1] for k in range(len(rho_adj) - 1))\n        \n        # 2. Verify tracer bounds: all tracer values are within [c_min, c_max]\n        are_bounds_kept = all(c_min = val = c_max for val in c_adj)\n        \n        # The result is True if and only if both conditions are met.\n        results.append(is_stable and are_bounds_kept)\n\n    # Format the final output as a comma-separated list of booleans in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A purely mathematical stability criterion, such as the one explored in , can be fragile when implemented in finite-precision arithmetic, potentially leading to spurious adjustments in nearly neutral conditions. This problem challenges you to think like a numerical model developer, analyzing how floating-point errors propagate through the equation of state. By deriving a state-aware tolerance, you will learn how to create a robust stability check that distinguishes genuine physical inversions from numerical artifacts.",
            "id": "3788306",
            "problem": "Consider a one-dimensional ocean column model that applies convective adjustment whenever the computed density increases upward between two adjacent levels, that is, when the finite-precision evaluation yields a negative difference $d\\hat{\\rho}_i = \\hat{\\rho}_{i+1} - \\hat{\\rho}_i  0$, where $\\hat{\\rho}_i$ denotes the numerically computed density at level $i$. Static stability requires that density is nondecreasing with depth, so a true inversion is characterized by $d\\rho_i = \\rho_{i+1} - \\rho_i  0$. Densities are computed from an equation of state (EOS) $\\rho = \\rho(T,S,p)$ that is differentiable in temperature $T$, salinity $S$, and pressure $p$, and for the purposes of stability testing you may take $\\partial \\rho/\\partial T$, $\\partial \\rho/\\partial S$, and $\\partial \\rho/\\partial p$ to be locally known from the EOS. The model uses floating-point arithmetic conforming to the Institute of Electrical and Electronics Engineers (IEEE) $754$ standard, with unit roundoff $u$ defined for round-to-nearest as the maximum relative error introduced by a single correctly rounded elementary operation.\n\nIn practice, $\\hat{\\rho}_i$ is affected by finite precision at two stages: representation of the inputs $(T_i,S_i,p_i)$ and evaluation of the EOS, and $d\\hat{\\rho}_i$ is affected again by subtraction, which becomes ill-conditioned under near cancellation when $|d\\rho_i|$ is small. It is observed that when $|d\\rho_i|$ is comparable to the absolute rounding error, spurious sign flips of $d\\hat{\\rho}_i$ can occur, triggering erroneous convective adjustments.\n\nFrom first principles of static stability and finite-precision error propagation, select the criterion that both explains the mechanism by which finite precision can cause false inversions and prescribes a robust, state-aware tolerance test that minimizes erroneous adjustments while detecting genuine inversions. Let the tolerance for the pair $(i,i+1)$ be denoted by $\\tau_i$, and assume local partial derivatives are evaluated at either level or an average.\n\nWhich option is most appropriate?\n\nA. Treat any negative computed difference $d\\hat{\\rho}_i  0$ as a true inversion and adjust, because IEEE $754$ rounding errors are symmetric and cancel in differences.\n\nB. Declare a genuine inversion only if $d\\hat{\\rho}_i  -\\tau_i$, with\n$$\n\\tau_i = u\\left(|\\hat{\\rho}_{i+1}| + |\\hat{\\rho}_i|\\right) + \\left|\\frac{\\partial \\rho}{\\partial T}\\right|\\,u\\left(|T_{i+1}| + |T_i|\\right) + \\left|\\frac{\\partial \\rho}{\\partial S}\\right|\\,u\\left(|S_{i+1}| + |S_i|\\right) + \\left|\\frac{\\partial \\rho}{\\partial p}\\right|\\,u\\left(|p_{i+1}| + |p_i|\\right),\n$$\nso that only differences exceeding a bound on absolute rounding error from EOS evaluation and subtraction are acted upon.\n\nC. Use a relative tolerance scaled by the local stratification and grid spacing, declaring an inversion if $d\\hat{\\rho}_i  -u\\,\\left|\\frac{\\partial \\rho}{\\partial z}\\right|\\,\\Delta z$, because the background gradient sets the relevant magnitude.\n\nD. Evaluate potential density referenced to the surface and adjust whenever $d\\hat{\\sigma}_{\\theta,i}  0$, since referencing removes pressure effects and eliminates numerical sensitivity to subtraction near cancellation.",
            "solution": "The user has provided a problem concerning numerical stability in a one-dimensional ocean column model. The task is to identify the most appropriate criterion for detecting a \"genuine\" static instability, distinguishing it from numerical artifacts arising from finite-precision arithmetic. This involves deriving a tolerance for the density difference test, based on first principles of error propagation.\n\n### Step 1: Extract Givens\n\n-   **Model**: A $1$-dimensional ocean column model with discrete levels, indexed by $i$.\n-   **Adjustment Trigger**: Convective adjustment is applied when the computed density difference $d\\hat{\\rho}_i = \\hat{\\rho}_{i+1} - \\hat{\\rho}_i  0$. Here, $\\hat{\\rho}_i$ is the numerically computed density at level $i$.\n-   **Physical Condition for Stability**: Static stability requires density to be non-decreasing with depth. A true inversion is when the true density difference $d\\rho_i = \\rho_{i+1} - \\rho_i  0$.\n-   **Equation of State (EOS)**: Density is a differentiable function of temperature $T$, salinity $S$, and pressure $p$, i.e., $\\rho = \\rho(T,S,p)$. The partial derivatives $\\frac{\\partial \\rho}{\\partial T}$, $\\frac{\\partial \\rho}{\\partial S}$, and $\\frac{\\partial \\rho}{\\partial p}$ are considered locally known.\n-   **Numerical Environment**: The model uses IEEE $754$ standard floating-point arithmetic. The unit roundoff is denoted by $u$.\n-   **Error Sources**:\n    1.  Representation error in the inputs $(T_i, S_i, p_i)$.\n    2.  Evaluation error in computing $\\hat{\\rho}_i$ from the EOS.\n    3.  Subtraction error in computing $d\\hat{\\rho}_i$, which is ill-conditioned when $|d\\rho_i|$ is small (catastrophic cancellation).\n-   **Problem**: Spurious sign flips in $d\\hat{\\rho}_i$ occur when its true magnitude $|d\\rho_i|$ is comparable to the absolute rounding error, triggering erroneous adjustments.\n-   **Objective**: Find a criterion, using a state-aware tolerance $\\tau_i$, that explains the error mechanism and minimizes false positives while detecting true inversions. The check will be of the form: declare inversion if $d\\hat{\\rho}_i  -\\tau_i$.\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientific Grounding**: The problem is well-grounded in the fields of computational oceanography and numerical analysis. Static stability, equations of state for seawater, and the challenges of finite-precision arithmetic (specifically IEEE $754$ standards, rounding errors, and catastrophic cancellation in subtraction) are all standard, established concepts. The scenario described is a real and common problem in geophysical fluid dynamics modeling.\n-   **Well-Posed**: The problem is well-posed. It asks for the derivation of a tolerance $\\tau_i$ based on a first-principles analysis of error propagation. This is a solvable problem in numerical analysis. The goal is clearly defined.\n-   **Objective**: The problem is stated in precise, objective, and technical language. It is free of ambiguity, subjectivity, or non-scientific claims.\n\n### Step 3: Verdict and Action\n\nThe problem statement is scientifically sound, well-posed, and objective. It is valid. I will proceed with the derivation and evaluation of the options.\n\n### Derivation of the Tolerance $\\tau_i$\n\nThe goal is to find a robust upper bound on the absolute error $|d\\hat{\\rho}_i - d\\rho_i|$, which represents the uncertainty in the computed density difference. Let this bound be the tolerance $\\tau_i$. An inversion is then declared only if $d\\hat{\\rho}_i$ is negative and its magnitude exceeds this uncertainty, i.e., $d\\hat{\\rho}_i  -\\tau_i$.\n\nLet's analyze the total error in $d\\hat{\\rho}_i$. The true difference is $d\\rho_i = \\rho_{i+1} - \\rho_i = \\rho(T_{i+1}, S_{i+1}, p_{i+1}) - \\rho(T_i, S_i, p_i)$.\nThe computed difference is $d\\hat{\\rho}_i = fl(\\hat{\\rho}_{i+1} - \\hat{\\rho}_i)$, where $\\hat{\\rho}_k$ is the computed density at level $k$.\n\nThe total error is $d\\hat{\\rho}_i - d\\rho_i$. We can analyze this by considering the errors in $\\hat{\\rho}_{i+1}$ and $\\hat{\\rho}_i$.\nLet $\\hat{\\rho}_k = \\rho_k + \\epsilon_k$, where $\\epsilon_k$ is the total error in the computed density $\\hat{\\rho}_k$.\nThe difference is $d\\hat{\\rho}_i \\approx \\hat{\\rho}_{i+1} - \\hat{\\rho}_i = (\\rho_{i+1} + \\epsilon_{i+1}) - (\\rho_i + \\epsilon_i) = d\\rho_i + (\\epsilon_{i+1} - \\epsilon_i)$.\nThe error in the difference is approximately $\\epsilon_{i+1} - \\epsilon_i$. Using the triangle inequality, the bound on the absolute error is:\n$$|d\\hat{\\rho}_i - d\\rho_i| \\le |\\epsilon_{i+1}| + |\\epsilon_i|$$\nWe have neglected the error of the final subtraction operation itself, as it is typically much smaller than the propagated error from the operands in a case of catastrophic cancellation.\n\nNow we must determine an upper bound for the error $\\epsilon_k$ in a single density computation, $|\\epsilon_k| = |\\hat{\\rho}_k - \\rho_k|$. This error has two primary sources as per the problem statement:\n1.  **Error from input representation**: The inputs $(T_k, S_k, p_k)$ are represented as floating-point numbers $(\\hat{T}_k, \\hat{S}_k, \\hat{p}_k)$. The representation error for a variable $X$ is bounded by $|\\hat{X}_k - X_k| \\le u|X_k|$. This error propagates through the EOS calculation. Using a first-order Taylor expansion for $\\rho(T,S,p)$:\n    $$|\\Delta\\rho_{k, \\text{input}}| \\le \\left|\\frac{\\partial \\rho}{\\partial T}\\right||\\hat{T}_k - T_k| + \\left|\\frac{\\partial \\rho}{\\partial S}\\right||\\hat{S}_k - S_k| + \\left|\\frac{\\partial \\rho}{\\partial p}\\right||\\hat{p}_k - p_k|$$\n    Substituting the bounds for input errors:\n    $$|\\Delta\\rho_{k, \\text{input}}| \\le u \\left( \\left|\\frac{\\partial \\rho}{\\partial T}\\right||T_k| + \\left|\\frac{\\partial \\rho}{\\partial S}\\right||S_k| + \\left|\\frac{\\partial \\rho}{\\partial p}\\right||p_k| \\right)$$\n2.  **Error from EOS evaluation**: The evaluation of the function $\\rho(\\hat{T}_k, \\hat{S}_k, \\hat{p}_k)$ itself introduces floating-point errors. A standard model for this error is a relative error proportional to the unit roundoff $u$.\n    $$|\\Delta\\rho_{k, \\text{eval}}| \\le c \\cdot u \\cdot |\\rho_k|$$\n    where $c$ is a small constant depending on the complexity of the EOS algorithm. For simplicity, we can take $c=1$.\n\nThe total error for a single density value $\\hat{\\rho}_k$ is the sum of these contributions:\n$$|\\epsilon_k| \\le |\\Delta\\rho_{k, \\text{eval}}| + |\\Delta\\rho_{k, \\text{input}}| \\le u|\\rho_k| + u \\left( \\left|\\frac{\\partial \\rho}{\\partial T}\\right||T_k| + \\left|\\frac{\\partial \\rho}{\\partial S}\\right||S_k| + \\left|\\frac{\\partial \\rho}{\\partial p}\\right||p_k| \\right)$$\n\nNow, we can establish the tolerance $\\tau_i$ as the bound on the total error of the difference:\n$$\\tau_i = |\\epsilon_{i+1}| + |\\epsilon_i|$$\nAssuming the partial derivatives are approximately constant between levels $i$ and $i+1$, as allowed by the problem statement, we can sum the error bounds for each level:\n$$\n\\begin{align*}\n\\tau_i  \\approx \\left[ u|\\rho_{i+1}| + u \\left( \\left|\\frac{\\partial \\rho}{\\partial T}\\right||T_{i+1}| + \\dots \\right) \\right] + \\left[ u|\\rho_i| + u \\left( \\left|\\frac{\\partial \\rho}{\\partial T}\\right||T_i| + \\dots \\right) \\right] \\\\\n= u(|\\rho_{i+1}| + |\\rho_i|) + u\\left|\\frac{\\partial \\rho}{\\partial T}\\right| (|T_{i+1}| + |T_i|) + u\\left|\\frac{\\partial \\rho}{\\partial S}\\right| (|S_{i+1}| + |S_i|) + u\\left|\\frac{\\partial \\rho}{\\partial p}\\right| (|p_{i+1}| + |p_i|)\n\\end{align*}\n$$\nIn this expression, the true values ($\\rho_k, T_k$, etc.) can be replaced by their computed counterparts ($\\hat{\\rho}_k, \\hat{T}_k$, etc.) because the expression is already a first-order error term, and this substitution introduces only higher-order errors. This derived expression for $\\tau_i$ matches the one given in Option B.\n\n### Option-by-Option Analysis\n\n**A. Treat any negative computed difference $d\\hat{\\rho}_i  0$ as a true inversion and adjust, because IEEE $754$ rounding errors are symmetric and cancel in differences.**\nThis statement is fundamentally incorrect. While the distribution of rounding errors has a zero mean (it is unbiased), individual errors are not zero and do not necessarily cancel in a specific computation. The phenomenon of catastrophic cancellation, which is central to this problem, is a direct consequence of the amplification of pre-existing relative errors when two nearly equal numbers are subtracted, leading to a large relative error in the result. The problem statement itself mentions \"spurious sign flips\", which contradicts the idea that errors simply cancel. This option advocates for the naive comparison that the entire problem aims to improve.\n**Verdict: Incorrect**\n\n**B. Declare a genuine inversion only if $d\\hat{\\rho}_i  -\\tau_i$, with**\n$$\n\\tau_i = u\\left(|\\hat{\\rho}_{i+1}| + |\\hat{\\rho}_i|\\right) + \\left|\\frac{\\partial \\rho}{\\partial T}\\right|\\,u\\left(|T_{i+1}| + |T_i|\\right) + \\left|\\frac{\\partial \\rho}{\\partial S}\\right|\\,u\\left(|S_{i+1}| + |S_i|\\right) + \\left|\\frac{\\partial \\rho}{\\partial p}\\right|\\,u\\left(|p_{i+1}| + |p_i|\\right),\n$$\n**so that only differences exceeding a bound on absolute rounding error from EOS evaluation and subtraction are acted upon.**\nAs derived from first principles above, this expression for $\\tau_i$ is a sound, state-aware estimate of the maximum absolute error in the computed density difference $d\\hat{\\rho}_i$. It correctly accounts for:\n-   Errors in the evaluation of the EOS itself (the $u(|\\hat{\\rho}_{i+1}| + |\\hat{\\rho}_i|)$ term).\n-   Errors propagated from the finite-precision representation of the input variables $T$, $S$, and $p$ (the remaining terms involving partial derivatives).\nThe condition $d\\hat{\\rho}_i  -\\tau_i$ correctly implements the principle of comparing a computed value against its numerical uncertainty before making a physical judgment. This criterion is robust and specific to the local state, as required.\n**Verdict: Correct**\n\n**C. Use a relative tolerance scaled by the local stratification and grid spacing, declaring an inversion if $d\\hat{\\rho}_i  -u\\,\\left|\\frac{\\partial \\rho}{\\partial z}\\right|\\,\\Delta z$.**\nThis criterion is flawed. The term $\\left|\\frac{\\partial \\rho}{\\partial z}\\right|\\Delta z$ is a first-order approximation of the true density difference, $|d\\rho_i|$. Thus, the criterion is approximately $d\\hat{\\rho}_i  -u|d\\rho_i|$. The core of the problem is that when the true stratification is near neutral ($d\\rho_i \\approx 0$), the absolute error in $d\\hat{\\rho}_i$ does *not* go to zero; it is dominated by a fixed noise floor from input and evaluation errors. This proposed tolerance, however, would approach zero as stratification weakens. This would make the test *more* sensitive to numerical noise, not less, which is the exact opposite of what is required. A robust tolerance must be based on the absolute error bounds, not a value relative to the quantity being measured, especially when that quantity can be near zero.\n**Verdict: Incorrect**\n\n**D. Evaluate potential density referenced to the surface and adjust whenever $d\\hat{\\sigma}_{\\theta,i}  0$, since referencing removes pressure effects and eliminates numerical sensitivity to subtraction near cancellation.**\nUsing potential density ($\\sigma_\\theta$) is a physically superior method for assessing static stability, as it removes the stabilizing effect of adiabatic compression. However, this option incorrectly claims that this change \"eliminates numerical sensitivity to subtraction near cancellation.\" The computation of $\\sigma_\\theta$ still relies on an equation of state with inputs $T$ and $S$, which are subject to representation errors. The EOS for $\\sigma_\\theta$ is also evaluated in finite precision. Finally, the difference $d\\hat{\\sigma}_{\\theta,i} = \\hat{\\sigma}_{\\theta,i+1} - \\hat{\\sigma}_{\\theta,i}$ must still be computed. If the water column is neutrally stable with respect to potential density ($d\\sigma_{\\theta_i} \\approx 0$), this subtraction is still subject to catastrophic cancellation. Therefore, simply switching to potential density does not remove the numerical problem. A proper solution would still require a tolerance test of the form $d\\hat{\\sigma}_{\\theta,i}  -\\tau_{\\sigma,i}$, where $\\tau_{\\sigma,i}$ is an error bound derived for the potential density difference. This option proposes a naive check and gives a false reason for its supposed effectiveness.\n**Verdict: Incorrect**",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}