{
    "hands_on_practices": [
        {
            "introduction": "在我们修正不稳定性之前，首先必须能够准确地识别它。这个练习将核心放在静态稳定性的基本度量——布伦特-维萨拉频率 ($N^2$) 上。通过这个练习，你将基于温度和盐度梯度推导出不稳定性发生的条件，从而将对流调整的整个主题建立在核心物理原理之上。",
            "id": "3788352",
            "problem": "考虑一个一维海洋水柱，其深度范围为 $-100 \\le z \\le 0$ 米，其中 $z$ 是垂直坐标，$z=0$ 处为海平面，且 $z$ 向上增加。观测到的温度和盐度剖面与深度呈线性关系，由 $T(z) = T_{s} + \\gamma_{T} z$ 和 $S(z) = S_{s} + \\gamma_{S} z$ 给出，其中 $T_{s}$ 和 $S_{s}$ 是恒定的表面值，$\\gamma_{T}$ 和 $\\gamma_{S}$ 是恒定的垂直梯度。假设 Boussinesq 近似、静力平衡以及围绕参考密度 $\\rho_{0}$ 的线性化状态方程成立，使得密度扰动满足 $\\rho' = -\\rho_{0}\\left(\\alpha\\,T' - \\beta\\,S'\\right)$，其中 $\\alpha$ 是热膨胀系数，$\\beta$ 是盐收缩系数。使用 $g = 9.81$ m s$^{-2}$，$\\alpha = 2\\times 10^{-4}$ K$^{-1}$，$\\beta = 8\\times 10^{-4}$ psu$^{-1}$ 以及 $\\rho_{0} = 1025$ kg m$^{-3}$。从浮力 $b = -g\\,\\rho'/\\rho_{0}$ 和 Brunt–Väisälä（浮力）频率的平方 $N^{2}(z) = \\partial b/\\partial z$ 的定义出发，推导出一个用 $g$、$\\alpha$、$\\beta$、$\\gamma_{T}$ 和 $\\gamma_{S}$ 表示的 $N^{2}(z)$ 的解析表达式。然后，利用所推导表达式的符号，确定水柱中哪些深度会被一个对流调整方案标记为静力不稳定，该方案会瞬时均质化任何 $N^{2}(z)  0$ 的子层。以国际单位制（SI units）中的 s$^{-2}$ 表示最终的 $N^{2}(z)$ 表达式。仅报告 $N^{2}(z)$ 的解析表达式。不需要进行数值计算。",
            "solution": "首先验证问题，以确保其科学上合理、良定且完整。\n\n### 步骤 1：提取已知条件\n- 区域：一个一维海洋水柱，其垂直坐标 $z$ 满足 $-100 \\le z \\le 0$ 米。$z=0$ 为海平面。\n- 温度剖面：$T(z) = T_{s} + \\gamma_{T} z$，其中 $T_s$ 和 $\\gamma_T$ 为常数。\n- 盐度剖面：$S(z) = S_{s} + \\gamma_{S} z$，其中 $S_s$ 和 $\\gamma_S$ 为常数。\n- 近似：假设 Boussinesq 近似和静力平衡成立。\n- 线性化状态方程：密度扰动 $\\rho'$ 由 $\\rho' = -\\rho_{0}\\left(\\alpha\\,T' - \\beta\\,S'\\right)$ 给出，其中 $T'$ 和 $S'$ 分别是温度和盐度扰动。\n- 常数：\n    - 重力加速度：$g = 9.81$ m s$^{-2}$。\n    - 热膨胀系数：$\\alpha = 2\\times 10^{-4}$ K$^{-1}$。\n    - 盐收缩系数：$\\beta = 8\\times 10^{-4}$ psu$^{-1}$。\n    - 参考密度：$\\rho_{0} = 1025$ kg m$^{-3}$。\n- 定义：\n    - 浮力：$b = -g\\,\\rho'/\\rho_{0}$。\n    - Brunt–Väisälä（浮力）频率的平方：$N^{2}(z) = \\partial b/\\partial z$。\n- 任务：\n    1. 推导一个用 $g$、$\\alpha$、$\\beta$、$\\gamma_{T}$ 和 $\\gamma_{S}$ 表示的 $N^{2}(z)$ 的解析表达式。\n    2. 确定静力不稳定（$N^{2}(z)  0$）的深度。\n    3. 以国际单位制（SI units）中的 s$^{-2}$ 表示最终的 $N^{2}(z)$ 表达式。\n    4. 仅报告 $N^{2}(z)$ 的解析表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，运用了物理海洋学中的标准概念和方程，例如 Boussinesq 近似、线性化状态方程以及浮力和 Brunt-Väisälä 频率的定义。所提供的数值常数在物理上是合理的。该问题是良定的；它提供了推导所要求表达式所需的所有必要信息。语言客观且明确。关于最终输出的说明是具体的，但并未与问题的物理原理产生任何矛盾。因此，该问题被认为是有效的。\n\n### 步骤 3：结论与行动\n问题有效。现在开始推导解。\n\n### 推导过程\nBrunt-Väisälä 频率的平方 $N^{2}(z)$ 是衡量流体柱静力稳定性的一个指标。它被定义为浮力的垂直梯度，即 $N^{2}(z) = \\partial b/\\partial z$。\n\n首先，我们建立浮力 $b(z)$ 的表达式。问题给出的定义是 $b = -g\\,\\rho'/\\rho_{0}$。密度扰动 $\\rho'$ 由线性化状态方程 $\\rho' = -\\rho_{0}(\\alpha T' - \\beta S')$ 给出。$T'$ 和 $S'$ 项代表与参考状态的偏差。为了计算背景剖面 $T(z)$ 和 $S(z)$ 的层化情况，相关密度为 $\\rho(z) = \\rho_0(1 - \\alpha(T(z)-T_{ref}) + \\beta(S(z)-S_{ref}))$，其中 $T_{ref}$ 和 $S_{ref}$ 是恒定的参考值。相对于参考密度 $\\rho_0$ 的密度异常则为 $\\rho(z) - \\rho_0$。与此层化相关的浮力为 $b(z) = -g (\\rho(z)-\\rho_0)/\\rho_0 = g(\\alpha(T(z)-T_{ref}) - \\beta(S(z)-S_{ref}))$。\n\n为了求得 $N^{2}(z)$，我们将 $b(z)$ 的表达式对垂直坐标 $z$ 求导：\n$$N^{2}(z) = \\frac{\\partial b}{\\partial z} = \\frac{\\partial}{\\partial z} \\left[ g\\left(\\alpha(T(z)-T_{ref}) - \\beta(S(z)-S_{ref})\\right) \\right]$$\n由于 $g$、$\\alpha$、$\\beta$、$T_{ref}$ 和 $S_{ref}$ 都是常数，求导得出：\n$$N^{2}(z) = g \\left( \\alpha \\frac{dT}{dz} - \\beta \\frac{dS}{dz} \\right)$$\n这是在给定线性化状态方程下，Brunt-Väisälä 频率平方的通用表达式。\n\n问题指定了线性的温度和盐度剖面：\n$T(z) = T_{s} + \\gamma_{T} z$\n$S(z) = S_{s} + \\gamma_{S} z$\n\n我们从这些剖面计算垂直梯度 $\\frac{dT}{dz}$ 和 $\\frac{dS}{dz}$：\n$$\\frac{dT}{dz} = \\frac{d}{dz} (T_{s} + \\gamma_{T} z) = \\gamma_{T}$$\n$$\\frac{dS}{dz} = \\frac{d}{dz} (S_{s} + \\gamma_{S} z) = \\gamma_{S}$$\n由于 $\\gamma_{T}$ 和 $\\gamma_{S}$ 是常数，因此整个水柱的温度和盐度垂直梯度是恒定的。\n\n将这些恒定梯度代入 $N^{2}(z)$ 的表达式中：\n$$N^{2}(z) = g \\left( \\alpha \\gamma_{T} - \\beta \\gamma_{S} \\right)$$\n由于右侧所有项均为常数，因此 $N^{2}$ 本身是一个常数，与深度 $z$ 无关。\n\n如果 $N^{2}(z)  0$，对流调整方案会将任何子层标记为静力不稳定。在这种情况下，由于 $N^{2}$ 是常数，稳定性条件适用于整个水柱，即 $-100 \\le z \\le 0$ 米。不稳定的条件是：\n$$g \\left( \\alpha \\gamma_{T} - \\beta \\gamma_{S} \\right)  0$$\n由于 $g  0$，这个不等式简化为：\n$$\\alpha \\gamma_{T} - \\beta \\gamma_{S}  0 \\quad \\text{or} \\quad \\alpha \\gamma_{T}  \\beta \\gamma_{S}$$\n如果满足此条件，则整个水柱都是静力不稳定的。如果 $\\alpha \\gamma_{T} \\ge \\beta \\gamma_{S}$，则整个水柱是稳定或中性的，没有任何部分会被标记为需要对流调整。\n\n检查推导表达式的单位以确保一致性。各项的单位是：\n- $[g]$ = m s$^{-2}$\n- $[\\alpha]$ = K$^{-1}$\n- $[\\gamma_T]$ = K m$^{-1}$\n- $[\\beta]$ = psu$^{-1}$ (psu是实用盐度单位，在此类计算中通常被视为无量纲)\n- $[\\gamma_S]$ = psu m$^{-1}$\n\n因此，$N^{2}$ 的单位是：\n$$[\\text{m s}^{-2}] \\times ([\\text{K}^{-1}][\\text{K m}^{-1}] - [\\text{psu}^{-1}][\\text{psu m}^{-1}]) = [\\text{m s}^{-2}] \\times ([\\text{m}^{-1}] - [\\text{m}^{-1}]) = \\text{s}^{-2}$$\n该单位是正确的频率平方的国际单位制单位。\n\n问题要求 $N^{2}(z)$ 的解析表达式。如上所推导，该表达式为 $g(\\alpha \\gamma_T - \\beta \\gamma_S)$。",
            "answer": "$$\n\\boxed{g \\left( \\alpha \\gamma_{T} - \\beta \\gamma_{S} \\right)}\n$$"
        },
        {
            "introduction": "恢复稳定性的最直接的概念方法之一是重新排列水团而不进行混合。本练习提供了一个动手编程任务，要求你实现一个“密度排序”方案，这种方法有助于理解理想的重力势能最小状态。同时，它还能锻炼你处理数据结构和排序算法的技能，特别是确定性地处理密度相同情况下的关键细节。",
            "id": "3788325",
            "problem": "您的任务是为一个包含五个层级的垂直海洋柱实现一个密度排序对流调整方案。每个层级都有规定的厚度、温度和盐度，对于 $i=1,2,3,4,5$ 分别表示为 $\\Delta z_i$、$T_i$ 和 $S_i$，其中 $i=1$ 是表层，$i=5$ 是底层。对流调整的物理目标是确保静力稳定性，即密度随深度非递减。对于一个五层柱的离散形式，静力稳定性要求对于 $i=1,2,3,4$ 都有 $\\rho_{i+1} \\ge \\rho_i$，其中 $\\rho_i$ 是在共同参考压力下第 $i$ 层的原位密度。您必须使用海水的线性状态方程（EOS）来根据温度和盐度计算密度：\n$$\n\\rho_i \\;=\\; \\rho_0 \\left[ 1 \\;-\\; \\alpha \\left( T_i - T_0 \\right) \\;+\\; \\beta \\left( S_i - S_0 \\right) \\right],\n$$\n其中 $\\rho_0$ 是一个常数参考密度，$\\alpha$ 是热膨胀系数，$\\beta$ 是盐收缩系数，$T_0$ 是参考温度，$S_0$ 是参考盐度。密度排序对流调整方案将五个层级按照密度随深度非递减的顺序重新排列（即密度最低的在表层，密度最高的在底层），且不进行混合，从而使得最终的剖面在离散意义上是中性层结的。在此方案中，通过纯粹的置换来确保示踪剂守恒：调整后的剖面是通过将原始层级的值 $\\left(T_i,S_i\\right)$ 重新分配到新的位置而形成的，以使得 $\\rho$ 随深度非递减。层级厚度 $\\Delta z_i$ 在调整后仍与其原始模式层级相关联；也就是说，您必须生成与稳定密度排序相对应的新 $T$ 和 $S$ 有序列表，但 $\\Delta z$ 不会改变。密度相等的情况（即对于某些 $i\\neq j$ 有 $\\rho_i=\\rho_j$）必须通过保留从表层到底层的原始垂直顺序来处理，即使用一种不会对密度相等的层级进行重新排序的稳定排序。\n\n使用以下物理常数：\n- $\\rho_0 = 1027 \\,\\mathrm{kg\\,m^{-3}}$，\n- $\\alpha = 2\\times 10^{-4} \\,\\mathrm{^\\circ C^{-1}}$，\n- $\\beta = 7.5\\times 10^{-4} \\,\\mathrm{(g\\,kg^{-1})^{-1}}$，\n- $T_0 = 10 \\,\\mathrm{^\\circ C}$，\n- $S_0 = 35 \\,\\mathrm{g\\,kg^{-1}}$。\n\n所有温度必须以摄氏度处理，所有盐度必须以克/千克 $\\left(\\mathrm{g\\,kg^{-1}}\\right)$ 处理。所有厚度必须以米处理。\n\n实现一个程序，对于下面测试套件中的每个测试用例，通过密度排序计算调整后的中性层结剖面，并输出新的有序层平均 $T$ 和 $S$ 值。最终输出必须以摄氏度表示 $T$，以克/千克 $\\left(\\mathrm{g\\,kg^{-1}}\\right)$ 表示 $S$。\n\n测试套件规格（每个用例提供从表层到底层的有序列表 $\\Delta z$、$T$ 和 $S$）：\n- 用例 A（具有中度不稳定性的正常路径）：\n  - $\\Delta z = [10,\\,15,\\,20,\\,25,\\,30] \\,\\mathrm{m}$，\n  - $T = [10,\\,9,\\,11,\\,8,\\,7] \\,\\mathrm{^\\circ C}$，\n  - $S = [35.0,\\,34.0,\\,35.0,\\,35.2,\\,35.3] \\,\\mathrm{g\\,kg^{-1}}$。\n- 用例 B（两个层级之间密度相等的边界情况，以测试稳定的平局处理）：\n  - $\\Delta z = [5,\\,10,\\,15,\\,20,\\,25] \\,\\mathrm{m}$，\n  - $T = [9,\\,8,\\,10,\\,12,\\,11] \\,\\mathrm{^\\circ C}$，\n  - $S = [34.6,\\,34.8,\\,35.0,\\,35.533333,\\,35.4] \\,\\mathrm{g\\,kg^{-1}}$。\n- 用例 C（具有强反转初始剖面的边缘情况）：\n  - $\\Delta z = [8,\\,8,\\,8,\\,8,\\,8] \\,\\mathrm{m}$，\n  - $T = [2,\\,5,\\,10,\\,15,\\,20] \\,\\mathrm{^\\circ C}$，\n  - $S = [35.5,\\,35.0,\\,34.5,\\,34.0,\\,33.5] \\,\\mathrm{g\\,kg^{-1}}$。\n- 用例 D（已经稳定的剖面：调整不应改变顺序）：\n  - $\\Delta z = [12,\\,12,\\,12,\\,12,\\,12] \\,\\mathrm{m}$，\n  - $T = [25,\\,20,\\,15,\\,10,\\,5] \\,\\mathrm{^\\circ C}$，\n  - $S = [33.5,\\,34.0,\\,34.5,\\,35.0,\\,35.5] \\,\\mathrm{g\\,kg^{-1}}$。\n\n算法要求：\n1. 对于每个用例，使用提供的线性 EOS 计算层级密度。为了排序，您可以按密度异常因子排序\n   $$\n   \\sigma_i \\;=\\; -\\alpha \\left( T_i - T_0 \\right) \\;+\\; \\beta \\left( S_i - S_0 \\right),\n   $$\n   因为当 $\\rho_00$ 为常数时，$\\rho_i$ 是 $\\sigma_i$ 的严格递增函数。\n2. 按 $\\sigma_i$ 递增（等效于 $\\rho_i$ 递增）对层级进行稳定排序，将最低密度分配给表层，最高密度分配给底层，并对 $\\sigma_i$ 相等的层级保留原始顺序。\n3. 对于每个用例，生成与排序顺序相对应的调整后的 $T$ 和 $S$ 值列表。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须表示为一对列表：排序后的温度列表后跟排序后的盐度列表。具体来说，输出必须具有以下形式\n  $$\n  \\left[ \\left[ [T_{A,1},T_{A,2},T_{A,3},T_{A,4},T_{A,5}], [S_{A,1},S_{A,2},S_{A,3},S_{A,4},S_{A,5}] \\right], \\ldots \\right],\n  $$\n  其中省略号按顺序表示用例 B、用例 C 和用例 D 的相应列表对。所有数值条目均为浮点数或整数。打印的单行必须符合此结构，使用标准的 Python 列表格式，且不含任何附加文本。",
            "solution": "问题陈述已经过验证，被认为是科学上合理的、问题定义明确且自洽的。所有必需的物理常数、初始条件和算法要求均已提供，且无矛盾之处。任务是为一个离散的五层海洋柱实现一个密度排序对流调整方案，这是计算海洋学中确保数值模型保持物理稳定性的标准程序。\n\n该问题背后的基本原理是流体中的静力稳定性。如果一个流体柱的密度是深度的非递减函数，那么它是静力稳定的。任何密度较大的流体块位于密度较小的流体块之上的配置都是不稳定的，并将导致垂直运动（对流），从而重新排列流体块以恢复稳定的密度层结。在一个从表层到底层索引为 $i=1, 2, ..., 5$ 的离散垂直柱的背景下，此稳定性条件表示为：\n$$\n\\rho_{i+1} \\ge \\rho_i \\quad \\text{for} \\quad i = 1, 2, 3, 4,\n$$\n其中 $\\rho_i$ 是第 $i$ 层中流体的密度。\n\n每个层级的密度 $\\rho_i$ 由其温度 $T_i$ 和盐度 $S_i$ 决定。问题指定了一个线性状态方程（EOS）来关联这些属性：\n$$\n\\rho_i = \\rho_0 \\left[ 1 - \\alpha \\left( T_i - T_0 \\right) + \\beta \\left( S_i - S_0 \\right) \\right].\n$$\n在此，$\\rho_0 = 1027 \\,\\mathrm{kg\\,m^{-3}}$ 是参考密度，$\\alpha = 2 \\times 10^{-4} \\,\\mathrm{^\\circ C^{-1}}$ 是热膨胀系数，$\\beta = 7.5 \\times 10^{-4} \\,\\mathrm{(g\\,kg^{-1})^{-1}}$ 是盐收缩系数，$T_0 = 10 \\,\\mathrm{^\\circ C}$ 和 $S_0 = 35 \\,\\mathrm{g\\,kg^{-1}}$ 分别是参考温度和参考盐度。项 $-\\alpha(T_i - T_0)$ 表明密度随温度升高而降低（对于 $T_i  T_0$），而项 $+\\beta(S_i - S_0)$ 表明密度随盐度升高而增加（对于 $S_i  S_0$）。\n\n所规定的对流调整方案是一种“密度排序”算法。这是一种非物理的参数化方法，意味着它不模拟现实世界对流的湍流混合动力学。相反，它通过根据密度重新排列流体柱中的流体块来瞬间恢复稳定性。每个层级 $i$ 中的水块由其属性 $(T_i, S_i)$ 定义。该算法识别任何不稳定的密度反转，并按密度升序对五个水块进行排序，将密度最小的水块放置在表层（层级 $i=1$），将密度最大的水块放置在底层（层级 $i=5$）。这个过程是一个纯粹的置换；原始的五对 $(T, S)$ 集合被保留下来，但它们被重新分配到不同的垂直层级，以确保剖面稳定。层级厚度 $\\Delta z_i$ 保持固定在其原始模式层级上。\n\n为了计算方便，根据密度异常因子 $\\sigma_i$ 进行排序就足够了，其定义为：\n$$\n\\sigma_i = -\\alpha \\left( T_i - T_0 \\right) + \\beta \\left( S_i - S_0 \\right).\n$$\n由于 $\\rho_i = \\rho_0(1 + \\sigma_i)$ 且 $\\rho_0$ 是一个正常数，$\\rho_i$ 是 $\\sigma_i$ 的单调递增函数。因此，按 $\\sigma_i$ 升序对层级进行排序等同于按 $\\rho_i$ 升序对它们进行排序。\n\n每个测试用例的实现步骤如下：\n1. 对于由温度列表 $T = [T_1, T_2, T_3, T_4, T_5]$ 和盐度列表 $S = [S_1, S_2, S_3, S_4, S_5]$ 定义的初始垂直剖面，形成一个包含五个水块的列表。每个水块是一对 $(T_i, S_i)$，并与其原始层级索引 $i$ 相关联。\n2. 对于每个水块 $(T_i, S_i)$，计算其对应的密度异常因子 $\\sigma_i$。\n3. 基于其 $\\sigma_i$ 值按升序对水块列表进行稳定排序。稳定排序对于唯一性至关重要，因为它保留了任何具有相同密度（因此具有相同 $\\sigma_i$ 值）的水块的原始相对顺序。这符合物理直觉，即密度相等的水块不需要互换。\n4. 从排序后的水块列表中，提取新的、调整后的温度和盐度剖面 $T_{\\text{adj}}$ 和 $S_{\\text{adj}}$。这些列表代表了在重建的、中性层结的水柱中各层的属性，其中密度随深度非递减。最终输出是这对列表 $[T_{\\text{adj}}, S_{\\text{adj}}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a density-sorting convective adjustment scheme for a 5-layer\n    ocean column based on a linear equation of state.\n    \"\"\"\n    \n    # Define physical constants\n    RHO_0 = 1027.0  # kg m^-3\n    ALPHA = 2.0e-4  # °C^-1\n    BETA = 7.5e-4   # (g/kg)^-1\n    T_0 = 10.0      # °C\n    S_0 = 35.0      # g/kg\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path with a modest instability)\n        {\n            \"T\": [10.0, 9.0, 11.0, 8.0, 7.0],\n            \"S\": [35.0, 34.0, 35.0, 35.2, 35.3]\n        },\n        # Case B (boundary case with equal densities)\n        {\n            \"T\": [9.0, 8.0, 10.0, 12.0, 11.0],\n            \"S\": [34.6, 34.8, 35.0, 35.0 + 8.0/15.0, 35.4]\n        },\n        # Case C (edge case with a strongly inverted profile)\n        {\n            \"T\": [2.0, 5.0, 10.0, 15.0, 20.0],\n            \"S\": [35.5, 35.0, 34.5, 34.0, 33.5]\n        },\n        # Case D (already stable profile)\n        {\n            \"T\": [25.0, 20.0, 15.0, 10.0, 5.0],\n            \"S\": [33.5, 34.0, 34.5, 35.0, 35.5]\n        }\n    ]\n\n    results = []\n    \n    # Define the density anomaly factor function\n    def sigma_factor(T, S):\n        return -ALPHA * (T - T_0) + BETA * (S - S_0)\n\n    for case in test_cases:\n        initial_T = case[\"T\"]\n        initial_S = case[\"S\"]\n\n        # 1. Combine T and S into a list of parcels (T_i, S_i)\n        parcels = list(zip(initial_T, initial_S))\n\n        # 2. Perform a stable sort of the parcels by increasing density (sigma).\n        #    Python's sorted() is stable by default.\n        #    The key is the lambda function that computes sigma for each parcel.\n        sorted_parcels = sorted(parcels, key=lambda p: sigma_factor(p[0], p[1]))\n\n        # 3. Unzip the sorted parcels back into adjusted T and S lists.\n        if sorted_parcels:\n            adjusted_T, adjusted_S = zip(*sorted_parcels)\n        else: # Handle empty case, though not in test suite\n            adjusted_T, adjusted_S = [], []\n        \n        # Format the result for this case as a pair of lists\n        # Use np.round to handle the floating point precision from Case B\n        # The problem doesn't specify precision, but this makes output clean.\n        # For submission, it is safer to use raw floats as calculated.\n        case_result = [list(adjusted_T), list(adjusted_S)]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The problem's sample print format `f\"[{','.join(map(str, results))}]\"`\n    # produces a string without spaces after the separating commas.\n    # `str(results)` produces a string with spaces. To be exact, we manually\n    # build the string as specified.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\n\nsolve()\n```"
        },
        {
            "introduction": "现在我们转向一种更真实地模拟对流过程的模型，即不稳定的流体层会发生混合。这个练习要求你实现一个迭代方案，该方案能将不稳定的流体块均质化。练习的重点是在地球物理模型中至关重要的质量和示踪剂守恒概念，以及确保整个水柱最终达到稳定的算法逻辑。",
            "id": "3788362",
            "problem": "考虑一个一维垂直海洋柱，它被离散化为 $N$ 个层。每个层 $k \\in \\{0,1,\\dots,N-1\\}$ 具有正厚度 $h_k$（单位：$\\mathrm{m}$）、原位或位密度 $\\rho_k$（单位：$\\mathrm{kg}\\,\\mathrm{m}^{-3}$）以及示踪剂浓度 $c_k$（例如，实用盐度），以实用盐度单位（psu，一个无量纲数）表示。示踪剂浓度受已知边界 $c_{\\min}$ 和 $c_{\\max}$ 的约束，对于所有 $k$ 均有 $c_{\\min} \\leq c_k \\leq c_{\\max}$。如果密度随深度非递减，即对于所有 $k \\in \\{0,1,\\dots,N-2\\}$ 都有 $\\rho_{k} \\leq \\rho_{k+1}$，则该海洋柱是稳定分层的。如果存在任何索引 $k$ 使得 $\\rho_{k}  \\rho_{k+1}$，则该海洋柱包含一个静力不稳定对，并且必须应用垂直对流调整。\n\n您必须设计并实现一个对流调整方案，通过在连续的不稳定块内均匀化示踪剂和密度来强制实现静力稳定性，同时保持每层的质量和示踪剂守恒。该方案必须：\n\n- 当稳定性（$\\rho_{k} \\leq \\rho_{k+1}$）被破坏时，识别并将相邻的层合并成块，直到最终调整后的密度剖面 $\\tilde{\\rho}_k$ 随深度非递减。\n- 对于每个由索引 $k \\in B$ 组成的混合块 $B$，使用块上的质量加权平均计算调整后的块内恒定密度 $\\tilde{\\rho}_k$ 和示踪剂 $\\tilde{c}_k$。\n- 对于每个测试用例，证明所有调整后的示踪剂值 $\\tilde{c}_k$ 保持在原始边界 $[c_{\\min}, c_{\\max}]$ 内。\n- 确保最终调整后的密度剖面 $\\tilde{\\rho}_k$ 随深度非递减。\n\n您的程序必须评估以下测试套件，并使用给定的单位进行输入和计算。程序应仅输出布尔值，以指示每个测试用例是否同时满足两个条件：所有调整后的示踪剂值都在以 psu 表示的包含性边界 $[c_{\\min}, c_{\\max}]$ 内，并且最终调整后的密度随深度非递减（以 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$ 表示）。\n\n测试套件（每个用例指定 $(h_k, \\rho_k, c_k, c_{\\min}, c_{\\max})$）：\n\n- 用例 A（一般不稳定的内部块）：\n  - 厚度（单位：$\\mathrm{m}$）：$[5.0, 7.5, 10.0, 12.5, 7.5]$\n  - 密度（单位：$\\mathrm{kg}\\,\\mathrm{m}^{-3}$）：$[1025.5, 1026.0, 1024.5, 1023.0, 1027.0]$\n  - 示踪剂盐度（单位：psu）：$[34.2, 35.0, 33.0, 32.0, 36.0]$\n  - 边界（单位：psu）：$c_{\\min} = 0.0$, $c_{\\max} = 40.0$\n\n- 用例 B（整个柱体不稳定，包含极端示踪剂值）：\n  - 厚度（单位：$\\mathrm{m}$）：$[10.0, 10.0, 10.0, 10.0]$\n  - 密度（单位：$\\mathrm{kg}\\,\\mathrm{m}^{-3}$）：$[1028.0, 1027.5, 1027.0, 1026.5]$\n  - 示踪剂盐度（单位：psu）：$[0.0, 40.0, 20.0, 35.0]$\n  - 边界（单位：psu）：$c_{\\min} = 0.0$, $c_{\\max} = 40.0$\n\n- 用例 C（已稳定的柱体，无需调整）：\n  - 厚度（单位：$\\mathrm{m}$）：$[8.0, 12.0, 15.0, 5.0]$\n  - 密度（单位：$\\mathrm{kg}\\,\\mathrm{m}^{-3}$）：$[1023.0, 1024.0, 1025.0, 1026.0]$\n  - 示踪剂盐度（单位：psu）：$[33.5, 34.0, 34.5, 35.0]$\n  - 边界（单位：psu）：$c_{\\min} = 0.0$, $c_{\\max} = 40.0$\n\n- 用例 D（层厚度和示踪剂极端值存在巨大反差，整个柱体不稳定）：\n  - 厚度（单位：$\\mathrm{m}$）：$[1.0, 100.0, 1.0, 100.0]$\n  - 密度（单位：$\\mathrm{kg}\\,\\mathrm{m}^{-3}$）：$[1026.0, 1025.0, 1024.0, 1023.0]$\n  - 示踪剂盐度（单位：psu）：$[0.0, 40.0, 0.0, 40.0]$\n  - 边界（单位：psu）：$c_{\\min} = 0.0$, $c_{\\max} = 40.0$\n\n算法和物理要求：\n\n- 在混合块内仅使用质量加权平均来计算调整后的块内恒定值 $\\tilde{\\rho}_k$ 和 $\\tilde{c}_k$。\n- 在由厚度 $h_k$ 给定的离散化下，精确保持总示踪剂质量和总柱体质量。\n- 强制执行静力稳定性约束 $\\tilde{\\rho}_k \\leq \\tilde{\\rho}_{k+1}$ 对于所有 $k$。\n- 对每个测试用例，验证并报告最终调整后的示踪剂值是否满足 $c_{\\min} \\leq \\tilde{c}_k \\leq c_{\\max}$ 对于柱体中的所有 $k$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含四个测试用例的结果，格式为方括号内用逗号分隔的列表，例如 $[\\text{True},\\text{False},\\text{True},\\text{True}]$，其中每个布尔值按顺序对应测试用例 $(\\text{A}, \\text{B}, \\text{C}, \\text{D})$。",
            "solution": "该问题要求为一维海洋柱设计并实现一个对流调整方案。这是海洋模型中一种常见的参数化方法，用于消除静力不稳定性，即密度较大的水位于密度较小的水之上。解决方案涉及识别此类不稳定性并模拟由此产生的垂直混合，该混合过程会使不稳定区域内的属性均匀化。\n\n指导该方案的核心原则是在任何发生混合的流体块内，质量守恒和示踪剂守恒。该海洋柱被离散化为 $N$ 个层，每个层 $k \\in \\{0, 1, \\dots, N-1\\}$ 具有厚度 $h_k$、密度 $\\rho_k$ 和示踪剂浓度 $c_k$。我们为每个层考虑一个恒定的水平面积 $A$，该面积将在所有计算中被抵消，可以设为 $A=1$。层 $k$ 的质量为 $m_k = \\rho_k V_k = \\rho_k (h_k A)$。层 $k$ 中的示踪剂总量为 $C_k = c_k m_k = c_k \\rho_k h_k A$。\n\n当一个由索引集 $B$ 标识的连续层块变得不稳定并混合时，它会形成一个单一的新的均匀层。根据守恒原则：\n1.  **质量守恒**：新层的总质量必须等于原始各层质量之和。\n2.  **示踪剂守恒**：新层中的示踪剂总量必须等于原始各层示踪剂总量之和。\n3.  **体积守恒**：新层的体积是原始各层体积之和。这意味着新的厚度为 $\\tilde{h}_B = \\sum_{k \\in B} h_k$。\n\n根据这些原则，我们推导出均匀化块的属性。设新块的属性为 $\\tilde{h}_B, \\tilde{\\rho}_B, \\tilde{c}_B$。\n块中的总质量为 $M_B = \\sum_{k \\in B} m_k = A \\sum_{k \\in B} \\rho_k h_k$。总体积为 $V_B = A \\sum_{k \\in B} h_k = A \\tilde{h}_B$。\n新的密度 $\\tilde{\\rho}_B$ 是总质量除以总体积：\n$$ \\tilde{\\rho}_B = \\frac{M_B}{V_B} = \\frac{A \\sum_{k \\in B} \\rho_k h_k}{A \\sum_{k \\in B} h_k} = \\frac{\\sum_{k \\in B} \\rho_k h_k}{\\sum_{k \\in B} h_k} $$\n这是初始密度的体积加权平均值。\n\n块中的示踪剂总量为 $C_B = \\sum_{k \\in B} C_k = A \\sum_{k \\in B} c_k \\rho_k h_k$。\n新的示踪剂浓度 $\\tilde{c}_B$ 是示踪剂总量除以总质量：\n$$ \\tilde{c}_B = \\frac{C_B}{M_B} = \\frac{A \\sum_{k \\in B} c_k \\rho_k h_k}{A \\sum_{k \\in B} \\rho_k h_k} = \\frac{\\sum_{k \\in B} c_k \\rho_k h_k}{\\sum_{k \\in B} \\rho_k h_k} $$\n这是初始示踪剂浓度的质量加权平均值。\n\n如果对于任何相邻的层对 $k$ 和 $k+1$，有 $\\rho_k  \\rho_{k+1}$，则定义为存在不稳定性。算法必须解决所有此类不稳定性，直到整个柱体稳定，即对于所有 $k$ 都有 $\\tilde{\\rho}_k \\leq \\tilde{\\rho}_{k+1}$。单次遍历柱体是不够的，因为合并两个层可能会与合并块上方的层产生新的不稳定性。需要一个稳健的迭代方法。算法流程如下：\n\n1.  初始化一个指针 $k=0$ 指向最顶层。\n2.  当 $k$ 小于倒数第二个层的索引时，进行迭代。\n3.  在当前位置 $k$，比较密度 $\\rho_k$ 与其下方层的密度 $\\rho_{k+1}$。\n4.  如果 $\\rho_k  \\rho_{k+1}$（不稳定），则合并层 $k$ 和 $k+1$。使用上述平均公式计算索引 $k$ 处新层的属性。移除索引为 $k+1$ 的层，总层数减一。合并后，新层可能与其上方（索引为 $k-1$）的层不稳定。为处理此情况，将指针 $k$ 回退一步，即 $k = \\max(0, k-1)$。\n5.  如果 $\\rho_k \\leq \\rho_{k+1}$（稳定），则通过增加指针移动到下一对，即 $k = k+1$。\n6.  当指针遍历整个柱体而未发现任何不稳定性时，过程终止。由此产生的密度剖面保证随深度非递减。\n\n最后，我们必须为调整后的柱体验证两个条件：\n1.  最终密度剖面是非递减的：对于所有 $k$，$\\tilde{\\rho}_{k} \\leq \\tilde{\\rho}_{k+1}$。所描述的算法旨在保证这一结果。\n2.  所有最终示踪剂浓度 $\\tilde{c}_k$ 都在给定的边界 $[c_{\\min}, c_{\\max}]$ 内。$\\tilde{c}$ 的公式是初始浓度 $c_k$ 的加权平均，其中权重（质量 $\\rho_k h_k A$）均为正。这种平均的一个特性是，结果必须位于输入值的范围内。由于所有初始 $c_k$ 都满足 $c_{\\min} \\leq c_k \\leq c_{\\max}$，因此任何混合值 $\\tilde{c}_k$ 也将满足 $c_{\\min} \\leq \\tilde{c}_k \\leq c_{\\max}$。\n\n因此，对于任何有效输入，对流调整算法的正确实现应始终产生满足这两个条件的结果。因此，每个测试用例的评估都应得出 `True`。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the convective adjustment scheme for all test cases\n    and print the verification results.\n    \"\"\"\n\n    test_cases = [\n        {\n            # Case A: General unstable interior block\n            \"h\": [5.0, 7.5, 10.0, 12.5, 7.5],\n            \"rho\": [1025.5, 1026.0, 1024.5, 1023.0, 1027.0],\n            \"c\": [34.2, 35.0, 33.0, 32.0, 36.0],\n            \"c_min\": 0.0,\n            \"c_max\": 40.0,\n        },\n        {\n            # Case B: Entire column unstable, extreme tracer values included\n            \"h\": [10.0, 10.0, 10.0, 10.0],\n            \"rho\": [1028.0, 1027.5, 1027.0, 1026.5],\n            \"c\": [0.0, 40.0, 20.0, 35.0],\n            \"c_min\": 0.0,\n            \"c_max\": 40.0,\n        },\n        {\n            # Case C: Already stable column, no adjustment needed\n            \"h\": [8.0, 12.0, 15.0, 5.0],\n            \"rho\": [1023.0, 1024.0, 1025.0, 1026.0],\n            \"c\": [33.5, 34.0, 34.5, 35.0],\n            \"c_min\": 0.0,\n            \"c_max\": 40.0,\n        },\n        {\n            # Case D: Large contrast in layer thicknesses and tracer extremes\n            \"h\": [1.0, 100.0, 1.0, 100.0],\n            \"rho\": [1026.0, 1025.0, 1024.0, 1023.0],\n            \"c\": [0.0, 40.0, 0.0, 40.0],\n            \"c_min\": 0.0,\n            \"c_max\": 40.0,\n        },\n    ]\n\n    def run_convective_adjustment(h_in, rho_in, c_in):\n        \"\"\"\n        Applies the convective adjustment algorithm to a water column.\n\n        Args:\n            h_in (list): Initial layer thicknesses.\n            rho_in (list): Initial layer densities.\n            c_in (list): Initial layer tracer concentrations.\n\n        Returns:\n            tuple: A tuple containing the adjusted lists (h_adj, rho_adj, c_adj).\n        \"\"\"\n        # Use lists for dynamic resizing during merging.\n        h_adj = list(h_in)\n        rho_adj = list(rho_in)\n        c_adj = list(c_in)\n\n        k = 0\n        # The loop must continue until a full pass without merges is completed.\n        while k  len(rho_adj) - 1:\n            # Check for instability\n            if rho_adj[k] > rho_adj[k+1]:\n                # Unstable pair found, merge layers k and k+1.\n                \n                # Properties of layer k\n                h1, rho1, c1 = h_adj[k], rho_adj[k], c_adj[k]\n                \n                # Properties of layer k+1\n                h2, rho2, c2 = h_adj[k+1], rho_adj[k+1], c_adj[k+1]\n\n                # Mass per unit area\n                m1 = rho1 * h1\n                m2 = rho2 * h2\n                total_mass = m1 + m2\n                \n                # Total tracer amount\n                tracer_amount1 = c1 * m1\n                tracer_amount2 = c2 * m2\n                total_tracer_amount = tracer_amount1 + tracer_amount2\n\n                # New merged layer properties\n                new_h = h1 + h2\n                # New density is volume-weighted average\n                new_rho = total_mass / new_h\n                # New tracer is mass-weighted average\n                new_c = total_tracer_amount / total_mass\n                \n                # Update layer k with merged properties\n                h_adj[k] = new_h\n                rho_adj[k] = new_rho\n                c_adj[k] = new_c\n                \n                # Remove layer k+1\n                h_adj.pop(k+1)\n                rho_adj.pop(k+1)\n                c_adj.pop(k+1)\n                \n                # Step back to check for instability with the layer above\n                k = max(0, k - 1)\n            else:\n                # Stable pair, move to the next one\n                k += 1\n        \n        return h_adj, rho_adj, c_adj\n\n    results = []\n    for case in test_cases:\n        h, rho, c, c_min, c_max = case[\"h\"], case[\"rho\"], case[\"c\"], case[\"c_min\"], case[\"c_max\"]\n\n        # Run the adjustment\n        h_adj, rho_adj, c_adj = run_convective_adjustment(h, rho, c)\n        \n        # --- Verification Step ---\n        \n        # 1. Verify stability: final density profile is non-decreasing\n        is_stable = all(rho_adj[k] = rho_adj[k+1] for k in range(len(rho_adj) - 1))\n        \n        # 2. Verify tracer bounds: all tracer values are within [c_min, c_max]\n        are_bounds_kept = all(c_min = val = c_max for val in c_adj)\n        \n        # The result is True if and only if both conditions are met.\n        results.append(is_stable and are_bounds_kept)\n\n    # Format the final output as a comma-separated list of booleans in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}