{
    "hands_on_practices": [
        {
            "introduction": "The first step in any realistic analysis of barotropic and baroclinic modes is to quantify the ocean's vertical stratification. This is captured by the Brunt–Väisälä (or buoyancy) frequency, $N$, where $N^2(z)$ represents the local restoring force on a vertically displaced fluid parcel. This hands-on practice  guides you through the essential computational task of deriving a smooth and physically consistent $N^2(z)$ profile from discrete measurements of temperature and salinity, a foundational skill for preparing data for vertical mode decomposition models.",
            "id": "3799111",
            "problem": "You are given discrete vertical profiles of temperature and salinity as functions of depth for an ocean column. The objective is to compute the squared buoyancy frequency $N^2(z)$ using a physically consistent seawater equation of state under a Boussinesq, hydrostatic approximation, and then prepare a smooth, nonnegative function $N^2(z)$ suitable as input to a vertical modal decomposition of barotropic and baroclinic motions. The derivation must begin from first principles, and the program must implement the algorithm accordingly.\n\nAssume the following widely used approximations:\n- The Boussinesq approximation with a constant reference density $\\rho_0$.\n- The hydrostatic balance and small-amplitude perturbations that motivate the linear stability measure $N^2$.\n- A linearized seawater equation of state: $\\rho(T,S) = \\rho_0 \\left(1 - \\alpha \\left(T - T_\\mathrm{ref}\\right) + \\beta \\left(S - S_\\mathrm{ref}\\right)\\right)$, where $\\alpha$ is the thermal expansion coefficient, $\\beta$ is the haline contraction coefficient, $T$ is potential temperature in degrees Celsius, and $S$ is Practical Salinity in dimensionless Practical Salinity Unit (PSU). The reference values $T_\\mathrm{ref}$ and $S_\\mathrm{ref}$ are constants that cancel in vertical differentiation and do not affect $N^2$.\n\nUse the following standard constants:\n- Gravitational acceleration $g = 9.81$ in units of $\\mathrm{m\\,s^{-2}}$.\n- Thermal expansion coefficient $\\alpha = 2.0 \\times 10^{-4}$ in units of $\\mathrm{K}^{-1}$.\n- Haline contraction coefficient $\\beta = 7.6 \\times 10^{-4}$ in units of $\\mathrm{(PSU)}^{-1}$.\n- Reference density $\\rho_0$ is constant (its exact numerical value cancels out in the linearized formula for $N^2$ below and is not needed numerically).\n\nLet depth $d$ be measured in meters and be positive downward, with $d = 0$ at the free surface. Let $T(d)$ and $S(d)$ be given profiles sampled on a discrete grid $\\{d_i\\}_{i=0}^{N-1}$ spanning $[0,1000]$ meters. From first principles, the squared buoyancy frequency defined with the vertical coordinate $z$ pointing upward is\n$$\nN^2(z) = -\\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial z}.\n$$\nWith the depth coordinate $d$ positive downward, the chain rule gives\n$$\n\\frac{\\partial}{\\partial z} = -\\frac{\\partial}{\\partial d},\n$$\nand using the linearized seawater equation of state, the vertical derivative of density with respect to depth is\n$$\n\\frac{\\partial \\rho}{\\partial d} = \\rho_0\\left(-\\alpha\\, \\frac{\\partial T}{\\partial d} + \\beta\\, \\frac{\\partial S}{\\partial d}\\right).\n$$\nTherefore,\n$$\nN^2(d) = \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial d} = g\\left(\\beta\\, \\frac{\\partial S}{\\partial d} - \\alpha\\, \\frac{\\partial T}{\\partial d}\\right).\n$$\n\nAlgorithmic requirements to prepare $N^2(d)$ as a function suitable for vertical mode decomposition:\n1. Compute discrete vertical gradients $\\frac{\\partial T}{\\partial d}$ and $\\frac{\\partial S}{\\partial d}$ on the given depth grid using consistent finite differences that are second order accurate in the interior and one-sided at boundaries.\n2. Compute $N^2(d)$ via the linearized formula $N^2(d) = g\\left(\\beta\\, \\frac{\\partial S}{\\partial d} - \\alpha\\, \\frac{\\partial T}{\\partial d}\\right)$ in units of $\\mathrm{s}^{-2}$.\n3. Enforce non-negativity required by Sturm–Liouville well-posedness by clipping $N^2(d)$ to a minimum floor $N^2_\\mathrm{min} = 10^{-6}$ in units of $\\mathrm{s}^{-2}$, i.e., set $N^2(d) \\leftarrow \\max\\left(N^2(d), N^2_\\mathrm{min}\\right)$.\n4. Construct a smooth, shape-preserving interpolant $\\widehat{N^2}(d)$ using a Piecewise Cubic Hermite Interpolating Polynomial (PCHIP) so that $\\widehat{N^2}(d)$ can be evaluated at arbitrary depths required by vertical modal solvers without overshoot artifacts.\n\nYour program must implement the above algorithm and evaluate the prepared function $\\widehat{N^2}(d)$ at a set of specified query depths for multiple test cases. All outputs must be expressed in $\\mathrm{s}^{-2}$, using scientific notation with at least six decimal digits. Angles are not used in this problem. The final output must be a single line containing the results aggregated for all test cases as a comma-separated list enclosed in square brackets, where each test case contributes its own comma-separated list of values also enclosed in square brackets, e.g., `[[r_{1,1},r_{1,2}],[r_{2,1},r_{2,2}]]` without spaces.\n\nTest suite (provide all $T(d)$ and $S(d)$ in physically plausible forms):\n\n- Test Case 1 (well-stratified thermocline):\n  - Depth grid: $d_i \\in [0,1000]$ meters, $N = 501$ uniformly spaced points.\n  - Temperature: $T(d) = 20 - 15\\, \\tanh\\left(\\frac{d - 200}{150}\\right)$ in degrees Celsius.\n  - Salinity: $S(d) = 34.5 + 0.5\\, \\tanh\\left(\\frac{d - 300}{200}\\right)$ in PSU.\n  - Query depths (in meters): $[0,100,250,500,1000]$.\n\n- Test Case 2 (nearly unstratified water column):\n  - Depth grid: $d_i \\in [0,1000]$ meters, $N = 501$ uniformly spaced points.\n  - Temperature: $T(d) = 10$ in degrees Celsius.\n  - Salinity: $S(d) = 35$ in PSU.\n  - Query depths (in meters): $[0,100,250,500,1000]$.\n\n- Test Case 3 (weakly unstable layers with small oscillations, requiring clipping):\n  - Depth grid: $d_i \\in [0,1000]$ meters, $N = 501$ uniformly spaced points.\n  - Temperature: $T(d) = 14 + 0.5\\, \\sin\\left(\\frac{2\\pi d}{120}\\right) - 11\\, \\frac{d}{1000}$ in degrees Celsius.\n  - Salinity: $S(d) = 34.8 + 0.2\\, \\cos\\left(\\frac{2\\pi d}{180}\\right) + 0.1\\, \\frac{d}{1000}$ in PSU.\n  - Query depths (in meters): $[0,100,250,500,1000]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s results are a comma-separated list of $\\widehat{N^2}(d)$ values (in $\\mathrm{s}^{-2}$) at the specified query depths, in scientific notation with at least six decimal digits, and without any spaces. For example, the format must be `[[v_{1,1},v_{1,2},...,v_{1,5}],[v_{2,1},...,v_{2,5}],[v_{3,1},...,v_{3,5}]]`.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of geophysical fluid dynamics, is well-posed with a clear algorithmic path to a unique solution, and is expressed in objective, formal language. We proceed with the solution.\n\nThe objective is to compute the squared buoyancy frequency, denoted $N^2$, from vertical profiles of potential temperature $T(d)$ and salinity $S(d)$, where $d$ is the depth, positive downwards. This quantity is fundamental for analyzing the stability of a stratified fluid column and for decomposing oceanic motions into their vertical barotropic and baroclinic modes. The procedure involves deriving $N^2$ from first principles and then implementing a numerical algorithm to prepare a smooth, non-negative profile suitable for use in numerical models.\n\n**Principle-Based Derivation**\n\nThe squared buoyancy frequency $N^2$ quantifies the restoring force on a fluid parcel displaced vertically in a stratified medium. In a stable stratification, a displaced parcel is less dense than its new surroundings (if displaced up) or denser (if displaced down), causing it to oscillate around its equilibrium level. $N$ represents the frequency of this oscillation.\n\nWith the vertical coordinate $z$ pointing upwards from the sea floor, $N^2(z)$ is defined as:\n$$\nN^2(z) = - \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial z}\n$$\nwhere $g$ is the acceleration due to gravity, $\\rho$ is the potential density, and $\\rho_0$ is a constant reference density, consistent with the Boussinesq approximation. This approximation assumes that density variations are small compared to the reference density, except when multiplied by $g$.\n\nThe problem uses a depth coordinate $d$ that is positive downwards, with $d=0$ at the sea surface. The relationship between the two coordinates implies $\\partial/\\partial z = -\\partial/\\partial d$. Substituting this into the definition of $N^2$ yields:\n$$\nN^2(d) = \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial d}\n$$\n\nThe potential density $\\rho$ is a function of potential temperature $T$ and salinity $S$. A linearized equation of state is provided:\n$$\n\\rho(T, S) = \\rho_0 \\left(1 - \\alpha (T - T_{\\mathrm{ref}}) + \\beta (S - S_{\\mathrm{ref}})\\right)\n$$\nHere, $\\alpha$ is the thermal expansion coefficient, $\\beta$ is the haline contraction coefficient, and $T_{\\mathrm{ref}}$ and $S_{\\mathrm{ref}}$ are constant reference values. To find the vertical density gradient, we differentiate $\\rho$ with respect to depth $d$ using the chain rule:\n$$\n\\frac{\\partial \\rho}{\\partial d} = \\frac{\\partial \\rho}{\\partial T} \\frac{\\partial T}{\\partial d} + \\frac{\\partial \\rho}{\\partial S} \\frac{\\partial S}{\\partial d}\n$$\nFrom the linearized equation of state, the partial derivatives are $\\partial \\rho / \\partial T = -\\rho_0 \\alpha$ and $\\partial \\rho / \\partial S = \\rho_0 \\beta$. Substituting these gives:\n$$\n\\frac{\\partial \\rho}{\\partial d} = \\rho_0 \\left(-\\alpha \\frac{\\partial T}{\\partial d} + \\beta \\frac{\\partial S}{\\partial d}\\right)\n$$\n\nFinally, substituting this expression for the density gradient back into the formula for $N^2(d)$:\n$$\nN^2(d) = \\frac{g}{\\rho_0} \\left[ \\rho_0 \\left(-\\alpha \\frac{\\partial T}{\\partial d} + \\beta \\frac{\\partial S}{\\partial d}\\right) \\right]\n$$\nThe reference density $\\rho_0$ cancels, leading to the final computational formula:\n$$\nN^2(d) = g \\left(\\beta \\frac{\\partial S}{\\partial d} - \\alpha \\frac{\\partial T}{\\partial d}\\right)\n$$\nThis equation shows that stability ($N^2 > 0$) is increased by salinity increasing with depth ($\\partial S/\\partial d > 0$, i.e., saltier, denser water below) and temperature decreasing with depth ($\\partial T/\\partial d  0$, i.e., colder, denser water below).\n\n**Numerical Algorithm Design**\n\nThe problem requires a four-step algorithm to transform discrete $T(d)$ and $S(d)$ profiles into a continuous, smooth, and non-negative function $\\widehat{N^2}(d)$.\n\n1.  **Discrete Gradient Computation**: Given discrete profiles $T_i = T(d_i)$ and $S_i = S(d_i)$ on a uniform grid of depths $\\{d_i\\}_{i=0}^{N-1}$ with spacing $h = d_{i+1} - d_i$, the vertical gradients $\\partial T/\\partial d$ and $\\partial S/\\partial d$ must be approximated numerically. To maintain good accuracy, a second-order finite difference scheme is specified. For interior points ($1 \\le i \\le N-2$), a central difference formula is used:\n    $$\n    f'(d_i) \\approx \\frac{f(d_{i+1}) - f(d_{i-1})}{2h}\n    $$\n    For the boundaries, second-order accurate one-sided formulas are required to avoid degrading the overall accuracy. At the surface ($i=0$):\n    $$\n    f'(d_0) \\approx \\frac{-3f(d_0) + 4f(d_1) - f(d_2)}{2h}\n    $$\n    And at the bottom ($i=N-1$):\n    $$\n    f'(d_{N-1}) \\approx \\frac{3f(d_{N-1}) - 4f(d_{N-2}) + f(d_{N-3})}{2h}\n    $$\n    These computations yield discrete arrays for $(\\partial T/\\partial d)_i$ and $(\\partial S/\\partial d)_i$.\n\n2.  **$N^2(d)$ Profile Calculation**: Using the computed gradients and the given constants $g = 9.81\\,\\mathrm{m\\,s^{-2}}$, $\\alpha = 2.0 \\times 10^{-4}\\,\\mathrm{K^{-1}}$, and $\\beta = 7.6 \\times 10^{-4}\\,\\mathrm{(PSU)^{-1}}$, the discrete squared buoyancy frequency profile $(N^2)_i$ is calculated at each grid point $d_i$ using the derived formula:\n    $$\n    (N^2)_i = g \\left(\\beta \\left(\\frac{\\partial S}{\\partial d}\\right)_i - \\alpha \\left(\\frac{\\partial T}{\\partial d}\\right)_i\\right)\n    $$\n\n3.  **Enforcement of Non-Negativity**: The vertical mode problem, which uses $N^2(d)$ as a coefficient, is typically formulated as a Sturm-Liouville eigenvalue problem. For this problem to be well-posed, the coefficient $N^2(d)$ must be non-negative everywhere. Physically, $N^2  0$ corresponds to a statically unstable water column where convection would occur, invalidating the linear stability model. To proceed with the linear analysis, these unstable regions are numerically regularized by clipping the calculated $N^2$ values to a small, positive floor value, $N^2_{\\mathrm{min}} = 10^{-6}\\,\\mathrm{s^{-2}}$.\n    $$\n    (N^2_{\\text{clipped}})_i = \\max\\left((N^2)_i, N^2_{\\mathrm{min}}\\right)\n    $$\n    This step ensures a physically and mathematically stable background state for the modal analysis.\n\n4.  **Smooth, Shape-Preserving Interpolation**: The discrete, clipped profile $(N^2_{\\text{clipped}})_i$ must be converted into a continuous function $\\widehat{N^2}(d)$ that can be evaluated at any depth. A standard cubic spline can introduce spurious oscillations (overshoots) between grid points, which might violate the non-negativity constraint. A Piecewise Cubic Hermite Interpolating Polynomial (PCHIP) is specified because it is shape-preserving. It honors the monotonicity of the provided data points, ensuring that if the discrete data is non-negative, the interpolant will also be non-negative between the points. This results in a smooth function $\\widehat{N^2}(d)$ that accurately reflects the physical stratification without introducing numerical artifacts. This function is then used to evaluate $N^2$ at the specified query depths for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Computes and prepares the squared buoyancy frequency profile N^2(d)\n    for several test cases, following the algorithm specified in the problem.\n    \"\"\"\n    # Define physical constants.\n    g = 9.81  # Gravitational acceleration in m/s^2\n    alpha = 2.0e-4  # Thermal expansion coefficient in K^-1\n    beta = 7.6e-4  # Haline contraction coefficient in (PSU)^-1\n    N2_min = 1.0e-6  # Minimum floor for N^2 in s^-2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"d_range\": (0.0, 1000.0),\n            \"N_points\": 501,\n            \"T_func\": lambda d: 20.0 - 15.0 * np.tanh((d - 200.0) / 150.0),\n            \"S_func\": lambda d: 34.5 + 0.5 * np.tanh((d - 300.0) / 200.0),\n            \"query_depths\": [0.0, 100.0, 250.0, 500.0, 1000.0],\n        },\n        {\n            \"d_range\": (0.0, 1000.0),\n            \"N_points\": 501,\n            \"T_func\": lambda d: np.full_like(d, 10.0),\n            \"S_func\": lambda d: np.full_like(d, 35.0),\n            \"query_depths\": [0.0, 100.0, 250.0, 500.0, 1000.0],\n        },\n        {\n            \"d_range\": (0.0, 1000.0),\n            \"N_points\": 501,\n            \"T_func\": lambda d: 14.0 + 0.5 * np.sin(2.0 * np.pi * d / 120.0) - 11.0 * d / 1000.0,\n            \"S_func\": lambda d: 34.8 + 0.2 * np.cos(2.0 * np.pi * d / 180.0) + 0.1 * d / 1000.0,\n            \"query_depths\": [0.0, 100.0, 250.0, 500.0, 1000.0],\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Generate the depth grid and corresponding T/S profiles.\n        d_grid = np.linspace(case[\"d_range\"][0], case[\"d_range\"][1], case[\"N_points\"])\n        T_profile = case[\"T_func\"](d_grid)\n        S_profile = case[\"S_func\"](d_grid)\n        \n        # Calculate grid spacing for finite differences.\n        h = d_grid[1] - d_grid[0]\n\n        # Step 1: Compute discrete vertical gradients using second-order accurate differences.\n        # np.gradient with edge_order=2 uses second-order central differences for the interior\n        # and second-order one-sided differences for the boundaries.\n        dT_dd = np.gradient(T_profile, h, edge_order=2)\n        dS_dd = np.gradient(S_profile, h, edge_order=2)\n\n        # Step 2: Compute N^2(d) via the linearized formula.\n        N2_profile = g * (beta * dS_dd - alpha * dT_dd)\n\n        # Step 3: Enforce non-negativity by clipping to a minimum floor.\n        N2_clipped = np.maximum(N2_profile, N2_min)\n\n        # Step 4: Construct a smooth, shape-preserving interpolant (PCHIP).\n        pchip_N2 = PchipInterpolator(d_grid, N2_clipped)\n        \n        # Evaluate the prepared function at the specified query depths.\n        query_depths = np.array(case[\"query_depths\"])\n        N2_interpolated = pchip_N2(query_depths)\n        \n        # Format results for the current case into a string list.\n        # The format must use scientific notation with at least 6 decimal digits.\n        case_results_str = [f\"{val:.7e}\" for val in N2_interpolated]\n        all_results.append(f\"[{','.join(case_results_str)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once the stratification profile $N^2(z)$ is known, the vertical structure functions $\\phi_n(z)$ for the baroclinic modes can be found by solving a Sturm-Liouville eigenvalue problem. A cornerstone of this theory is that the eigenfunctions, or modes, are orthogonal. This exercise  challenges you to derive the specific \"energy inner product,\" weighted by the stratification profile itself, that defines this orthogonality and to verify this property numerically, deepening your understanding of the mathematical structure that makes modal decomposition so powerful.",
            "id": "3785936",
            "problem": "Consider a vertically stratified, hydrostatic, Boussinesq ocean of depth $H$ with rigid-lid and flat-bottom boundary conditions. Let $z$ denote the vertical coordinate, with $z=0$ at the surface and $z=-H$ at the bottom. The background stratification is described by the Brunt–Väisälä frequency $N(z)$ measured in $\\mathrm{s}^{-1}$. Vertical mode decomposition for internal gravity waves introduces vertical structure functions $\\,\\phi_n(z)\\,$ subject to homogeneous Neumann boundary conditions $\\,\\partial_z \\phi_n(z) = 0\\,$ at $\\,z=0\\,$ and $\\,z=-H\\,$.\n\nStarting from the linearized hydrostatic Boussinesq equations and the definition of mechanical energy density for internal gravity waves, derive the bilinear energy-inner-product between two vertical modes $\\,\\phi_1(z)\\,$ and $\\,\\phi_2(z)\\,$ that arises from the horizontal kinetic energy contribution under a general stratification profile $\\,N(z)\\,$. Your derivation must begin from the governing equations and standard separation-of-variables arguments, and reach a self-adjoint bilinear form in terms of $\\,\\phi_1\\,$, $\\,\\phi_2\\,$, and $\\,N(z)\\,$ consistent with the stated boundary conditions. Do not use or quote any pre-derived inner-product formulas; the expression must be obtained from first principles.\n\nThen, implement a numerical quadrature to evaluate the inner product on a uniform vertical grid using the trapezoidal rule. The integral must be discretized over the interval $\\,[ -H, 0 ]\\,$ using a sufficiently fine grid. The final numerical value of the inner product must be returned in units of $\\mathrm{s}^2/\\mathrm{m}$ by construction. To verify orthogonality numerically, test whether the computed inner product is close to zero within a specified tolerance.\n\nUse the following test suite of parameter values and mode shapes, which are designed to probe a variety of scientifically meaningful scenarios:\n\n- Test case A (happy path, distinct baroclinic modes under constant stratification):\n    - $H = 4000\\,\\mathrm{m}$.\n    - $N(z) = 5 \\times 10^{-3}\\,\\mathrm{s}^{-1}$ (constant).\n    - $\\phi_1(z) = \\cos\\!\\left(\\dfrac{\\pi z}{H}\\right)$, $\\phi_2(z) = \\cos\\!\\left(\\dfrac{2\\pi z}{H}\\right)$.\n\n- Test case B (boundary condition edge case with a barotropic mode):\n    - $H = 4000\\,\\mathrm{m}$.\n    - $N(z) = 5 \\times 10^{-3}\\,\\mathrm{s}^{-1}$ (constant).\n    - $\\phi_1(z) = 1$ (barotropic mode), $\\phi_2(z) = \\cos\\!\\left(\\dfrac{\\pi z}{H}\\right)$.\n\n- Test case C (variable stratification, distinct baroclinic modes; orthogonality generally lost under non-constant weighting):\n    - $H = 4000\\,\\mathrm{m}$.\n    - $N(z) = N_0 + N_1 \\exp\\!\\left(\\dfrac{z}{H_s}\\right)$ with $N_0 = 2 \\times 10^{-3}\\,\\mathrm{s}^{-1}$, $N_1 = 3 \\times 10^{-3}\\,\\mathrm{s}^{-1}$, $H_s = 1000\\,\\mathrm{m}$.\n    - $\\phi_1(z) = \\cos\\!\\left(\\dfrac{\\pi z}{H}\\right)$, $\\phi_2(z) = \\cos\\!\\left(\\dfrac{2\\pi z}{H}\\right)$.\n\n- Test case D (non-orthogonal identical baroclinic modes under constant stratification):\n    - $H = 4000\\,\\mathrm{m}$.\n    - $N(z) = 5 \\times 10^{-3}\\,\\mathrm{s}^{-1}$ (constant).\n    - $\\phi_1(z) = \\cos\\!\\left(\\dfrac{\\pi z}{H}\\right)$, $\\phi_2(z) = \\cos\\!\\left(\\dfrac{\\pi z}{H}\\right)$.\n\nImplementation requirements:\n- Discretize $z$ over $\\,[ -H, 0 ]\\,$ with a uniform grid of at least $10001$ points.\n- Evaluate the trapezoidal-rule approximation to the derived inner product integral.\n- Use the tolerance $10^{-10}\\,\\mathrm{s}^2/\\mathrm{m}$ to decide numerical orthogonality: report $\\,\\mathrm{True}\\,$ if the absolute value of the inner product is strictly less than this tolerance, else $\\,\\mathrm{False}$.\n- For each test case, compute:\n    1. The inner product value as a floating-point number in $\\mathrm{s}^2/\\mathrm{m}$.\n    2. A boolean indicating whether the two modes are numerically orthogonal under the energy norm with the specified tolerance.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n  $[\\text{inner}_A,\\text{inner}_B,\\text{inner}_C,\\text{inner}_D,\\text{orth}_A,\\text{orth}_B,\\text{orth}_C,\\text{orth}_D]$,\n  where the inner products are floats in $\\mathrm{s}^2/\\mathrm{m}$ and the orthogonality indicators are booleans.",
            "solution": "The user has provided a problem in the field of computational oceanography concerning the derivation and numerical evaluation of an energy-inner-product for vertical modes of internal gravity waves.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Physical System:** A vertically stratified, hydrostatic, Boussinesq ocean of constant depth $H$.\n- **Boundaries:** Rigid lid at the surface ($z=0$) and a flat bottom ($z=-H$).\n- **Stratification:** Defined by the Brunt–Väisälä frequency $N(z)$, measured in $\\mathrm{s}^{-1}$.\n- **Vertical Modes:** Vertical structure functions $\\phi_n(z)$ associated with internal gravity waves.\n- **Boundary Conditions:** Homogeneous Neumann conditions for the modes: $\\partial_z \\phi_n(z) = 0$ at $z=0$ and $z=-H$.\n- **Task 1 (Derivation):** From first principles (linearized hydrostatic Boussinesq equations), derive the bilinear energy-inner-product between two modes, $\\phi_1(z)$ and $\\phi_2(z)$, arising from the horizontal kinetic energy contribution. The resulting expression must be a self-adjoint bilinear form involving $\\phi_1$, $\\phi_2$, and $N(z)$.\n- **Task 2 (Numerical Implementation):**\n    - Method: Evaluate the derived inner product using the trapezoidal rule on a uniform grid over $[-H, 0]$.\n    - Grid: At least $10001$ points.\n    - Units: The reported numerical value must be in $\\mathrm{s}^2/\\mathrm{m}$.\n    - Orthogonality Test: Modes are considered numerically orthogonal if the absolute value of their inner product is less than a tolerance of $10^{-10}\\,\\mathrm{s}^2/\\mathrm{m}$.\n- **Test Cases:**\n    - **A:** $H = 4000\\,\\mathrm{m}$, $N(z) = 5 \\times 10^{-3}\\,\\mathrm{s}^{-1}$, $\\phi_1(z) = \\cos(\\frac{\\pi z}{H})$, $\\phi_2(z) = \\cos(\\frac{2\\pi z}{H})$.\n    - **B:** $H = 4000\\,\\mathrm{m}$, $N(z) = 5 \\times 10^{-3}\\,\\mathrm{s}^{-1}$, $\\phi_1(z) = 1$, $\\phi_2(z) = \\cos(\\frac{\\pi z}{H})$.\n    - **C:** $H = 4000\\,\\mathrm{m}$, $N(z) = N_0 + N_1 \\exp(\\frac{z}{H_s})$ with $N_0 = 2 \\times 10^{-3}\\,\\mathrm{s}^{-1}$, $N_1 = 3 \\times 10^{-3}\\,\\mathrm{s}^{-1}$, $H_s = 1000\\,\\mathrm{m}$, $\\phi_1(z) = \\cos(\\frac{\\pi z}{H})$, $\\phi_2(z) = \\cos(\\frac{2\\pi z}{H})$.\n    - **D:** $H = 4000\\,\\mathrm{m}$, $N(z) = 5 \\times 10^{-3}\\,\\mathrm{s}^{-1}$, $\\phi_1(z) = \\cos(\\frac{\\pi z}{H})$, $\\phi_2(z) = \\cos(\\frac{\\pi z}{H})$.\n- **Final Output:** A single line containing a comma-separated list of 8 values: $[\\text{inner}_A,\\text{inner}_B,\\text{inner}_C,\\text{inner}_D,\\text{orth}_A,\\text{orth}_B,\\text{orth}_C,\\text{orth}_D]$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is scientifically grounded, well-posed, and objective. It is set within the standard framework of physical oceanography. The governing equations, boundary conditions, and concept of vertical mode decomposition are all standard. The provided test cases are physically meaningful and test different aspects of the theory (orthogonality of distinct modes, barotropic-baroclinic interaction, effect of variable stratification).\n\nA potential point of confusion is the request to derive the inner product from the \"horizontal kinetic energy contribution\" while also requiring units of $\\mathrm{s}^2/\\mathrm{m}$. A direct derivation from horizontal kinetic energy would lead to an inner product of the form $\\int_{-H}^0 \\phi_1(z) \\phi_2(z) dz$, which has units of length (m), assuming the modes $\\phi_n$ are dimensionless. However, a different standard inner product, arising from the potential energy contribution, is $\\int_{-H}^0 \\frac{1}{N(z)^2} \\frac{d\\phi_1}{dz} \\frac{d\\phi_2}{dz} dz$. This expression has units of $(\\mathrm{s}^{-1})^{-2} (\\mathrm{m}^{-1})(\\mathrm{m}^{-1}) \\mathrm{m} = \\mathrm{s}^2/\\mathrm{m}$, which matches the requirement.\n\nThe connection between the two is the principle of equipartition of energy for internal waves. For a given mode, the time-averaged, depth-integrated horizontal kinetic energy is proportional to the time-averaged, depth-integrated potential energy. Thus, the inner product associated with potential energy is also fundamentally linked to the kinetic energy, and can be legitimately considered an \"energy-inner-product\". The problem's phrasing is subtly complex but not incorrect; it is a valid test of understanding these connections.\n\nAll other aspects of the problem are specified with sufficient precision for a unique solution.\n\n**Step 3: Verdict and Action**\n\nThe problem is deemed **valid**. A full solution will be provided.\n\n### Principle-Based Solution\n\n**1. Derivation of the Vertical Mode Equation**\n\nWe begin with the linearized Boussinesq equations for a stratified, inviscid, non-rotating fluid under the hydrostatic approximation. Let $\\vec{u}_H = (u,v)$ be the horizontal velocity, $w$ be the vertical velocity, $p'$ be the pressure perturbation from hydrostatic balance, and $\\rho'$ be the density perturbation from the background state $\\bar{\\rho}(z)$. The reference density $\\rho_0$ is constant.\n\nThe governing equations are:\n1. Horizontal Momentum: $\\rho_0 \\frac{\\partial \\vec{u}_H}{\\partial t} = -\\nabla_H p'$\n2. Hydrostatic Balance: $\\frac{\\partial p'}{\\partial z} = -g \\rho'$\n3. Incompressibility: $\\nabla_H \\cdot \\vec{u}_H + \\frac{\\partial w}{\\partial z} = 0$\n4. Buoyancy Conservation: $\\frac{\\partial \\rho'}{\\partial t} + w \\frac{d\\bar{\\rho}}{dz} = 0$\n\nWe can combine these to find an equation for a single variable, $p'$. We use the definition of the Brunt-Väisälä frequency, $N^2(z) = -\\frac{g}{\\rho_0}\\frac{d\\bar{\\rho}}{dz}$.\nFrom (2) and (4):\n$\\frac{\\partial}{\\partial t}\\left(\\frac{\\partial p'}{\\partial z}\\right) = -g \\frac{\\partial \\rho'}{\\partial t} = g w \\frac{d\\bar{\\rho}}{dz} = -w \\rho_0 N^2(z)$\nThis gives an expression for $w$:\n$w = -\\frac{1}{\\rho_0 N^2(z)} \\frac{\\partial^2 p'}{\\partial t \\partial z}$\n\nFrom (1) and (3):\n$\\frac{\\partial}{\\partial t} (\\nabla_H \\cdot \\vec{u}_H) + \\frac{\\partial}{\\partial t}\\left(\\frac{\\partial w}{\\partial z}\\right) = 0$\n$\\nabla_H \\cdot \\left(\\frac{\\partial \\vec{u}_H}{\\partial t}\\right) + \\frac{\\partial^2 w}{\\partial t \\partial z} = 0$\n$\\nabla_H \\cdot \\left(-\\frac{1}{\\rho_0} \\nabla_H p'\\right) + \\frac{\\partial^2 w}{\\partial t \\partial z} = 0$\n$-\\frac{1}{\\rho_0} \\nabla_H^2 p' + \\frac{\\partial^2 w}{\\partial t \\partial z} = 0$\n\nSubstituting the expression for $w$ into this equation:\n$-\\frac{1}{\\rho_0} \\nabla_H^2 p' + \\frac{\\partial}{\\partial t \\partial z} \\left(-\\frac{1}{\\rho_0 N^2(z)} \\frac{\\partial^2 p'}{\\partial t \\partial z}\\right) = 0$\n$\\nabla_H^2 p' - \\frac{\\partial^2}{\\partial t^2} \\left[ \\frac{\\partial}{\\partial z} \\left( \\frac{1}{N^2(z)} \\frac{\\partial p'}{\\partial z} \\right) \\right] = 0$\n\nWe now seek solutions using separation of variables. Let $p'(x,y,z,t) = P(x,y,t)\\phi(z)$. Substituting this into the equation yields:\n$(\\nabla_H^2 P)\\phi(z) - \\frac{\\partial^2 P}{\\partial t^2} \\frac{d}{dz} \\left( \\frac{1}{N^2(z)} \\frac{d\\phi}{dz} \\right) = 0$\n$\\frac{\\nabla_H^2 P - \\frac{1}{c^2}\\frac{\\partial^2 P}{\\partial t^2}}{P} = 0$ and $\\frac{d}{dz}\\left(\\frac{1}{N^2(z)}\\frac{d\\phi}{dz}\\right) + \\frac{1}{c^2}\\phi(z) = 0$\nWe rearrange to separate the horizontal/temporal and vertical dependencies:\n$\\frac{1}{\\phi(z)} \\frac{d}{dz} \\left( \\frac{1}{N^2(z)} \\frac{d\\phi}{dz} \\right) = \\frac{\\nabla_H^2 P}{\\frac{\\partial^2 P}{\\partial t^2}}$\nBoth sides must equal a constant, which we define as $-1/c^2$, where $c$ is the horizontal wave speed. This gives us the standard vertical structure equation for the pressure modes $\\phi_n(z)$:\n$$ \\frac{d}{dz}\\left(\\frac{1}{N^2(z)}\\frac{d\\phi_n}{dz}\\right) + \\frac{1}{c_n^2}\\phi_n(z) = 0 $$\nThe boundary conditions of a rigid lid and bottom mean that vertical velocity $w$ must be zero at $z=0$ and $z=-H$. Since $w \\propto \\frac{d\\phi}{dz}$, this requires $\\frac{d\\phi_n}{dz}=0$ at $z=0, -H$, which are the specified homogeneous Neumann conditions.\n\n**2. Derivation of the Energy Inner Product**\nThe problem requires the derivation of an inner product related to the system's energy. The total energy density (per unit volume) is the sum of kinetic and potential energy densities: $E_{density} = KE + PE = \\frac{1}{2}\\rho_0(u^2+v^2+w^2) + \\frac{1}{2}\\rho_0 N^2 \\zeta^2$, where $\\zeta$ is the vertical displacement field ($w = \\partial_t \\zeta$).\n\nLet's examine the potential energy contribution. We relate $\\zeta$ to the pressure perturbation $p'$:\nFrom the hydrostatic equation (2), $\\rho' = -\\frac{1}{g} \\frac{\\partial p'}{\\partial z}$.\nFrom the buoyancy equation (4), $\\frac{\\partial\\rho'}{\\partial t} = -w\\frac{d\\bar{\\rho}}{dz} = -(\\partial_t \\zeta)(-\\frac{\\rho_0 N^2}{g}) = \\frac{\\rho_0 N^2}{g} \\partial_t \\zeta$.\nIntegrating with respect to time gives $\\rho' = \\frac{\\rho_0 N^2}{g} \\zeta$.\nEquating the two expressions for $\\rho'$ gives $\\zeta = \\frac{g}{\\rho_0 N^2}\\rho' = \\frac{g}{\\rho_0 N^2} \\left(-\\frac{1}{g}\\frac{\\partial p'}{\\partial z}\\right) = -\\frac{1}{\\rho_0 N^2}\\frac{\\partial p'}{\\partial z}$.\nFor a given mode $n$, where $p' \\propto \\phi_n(z)$, we have $\\zeta_n \\propto \\frac{1}{N^2(z)}\\frac{d\\phi_n}{dz}$.\n\nThe depth-integrated potential energy per unit area, $\\mathcal{E}_P$, involves an integral over depth. The inner product between two modes $\\phi_1$ and $\\phi_2$ derived from this term is:\n$$ \\langle \\phi_1, \\phi_2 \\rangle_{PE} = \\int_{-H}^0 \\frac{1}{N(z)^2} \\frac{d\\phi_1}{dz} \\frac{d\\phi_2}{dz} dz $$\nLet's check the units: $N$ is in $\\mathrm{s}^{-1}$, $z$ is in $\\mathrm{m}$. The units of the integral are $(\\mathrm{s}^{-1})^{-2} \\cdot \\mathrm{m}^{-1} \\cdot \\mathrm{m}^{-1} \\cdot \\mathrm{m} = \\mathrm{s}^2/\\mathrm{m}$. This precisely matches the problem's requirement.\n\nThe problem statement connects this inner product to the *horizontal kinetic energy*. This connection is established through the principle of energy equipartition. For a single propagating wave mode, the time-averaged kinetic energy equals the time-averaged potential energy. For low-frequency hydrostatic internal waves, the vertical kinetic energy is much smaller than the horizontal kinetic energy ($w \\ll u,v$), so $\\overline{KE_H} \\approx \\overline{PE}$. This implies that the depth integrals related to each component of energy are proportional.\n$\\overline{\\mathcal{E}_{KH}} \\propto \\overline{\\mathcal{E}_P}$, where $\\mathcal{E}_{KH} = \\int_{-H}^0 \\frac{1}{2}\\rho_0(u^2+v^2)dz$.\nTherefore, the inner product $\\langle \\phi_1, \\phi_2 \\rangle_{PE}$ is a valid representation of the modal energy and is proportional to the contribution from horizontal kinetic energy. This justifies its use as the \"energy-inner-product\" requested.\n\n**3. Numerical Implementation**\nThe derived inner product is the integral $I = \\int_{-H}^0 \\frac{1}{N(z)^2} \\frac{d\\phi_1}{dz} \\frac{d\\phi_2}{dz} dz$. This will be evaluated numerically using the trapezoidal rule on a uniform grid of $z$ values from $-H$ to $0$.\n\nThe derivatives of the provided mode shapes are:\n- For $\\phi(z) = \\cos\\left(\\frac{k\\pi z}{H}\\right)$, the derivative is $\\frac{d\\phi}{dz} = -\\frac{k\\pi}{H}\\sin\\left(\\frac{k\\pi z}{H}\\right)$.\n- For $\\phi(z) = 1$ (the barotropic mode), the derivative is $\\frac{d\\phi}{dz} = 0$.\n\nFor each test case, we construct the integrand $f(z) = \\frac{1}{N(z)^2} \\frac{d\\phi_1(z)}{dz} \\frac{d\\phi_2(z)}{dz}$ and evaluate its integral numerically. We then check if its absolute value is below the specified tolerance of $10^{-10}\\,\\mathrm{s}^2/\\mathrm{m}$.\n\n- **Case A  B:** For constant $N$, the true eigenfunctions are cosines, and their derivatives are sines. The integral $\\int_{-H}^0 \\sin(\\frac{m\\pi z}{H})\\sin(\\frac{n\\pi z}{H}) dz = \\frac{H}{2}\\delta_{mn}$. In Case A, $m=1, n=2$, so the analytical result is $0$. In Case B, one derivative is $0$, making the integrand identically zero.\n- **Case C:** With variable $N(z)$, the cosine functions are no longer the true eigenfunctions. The weighting term $1/N(z)^2$ is not constant, so their derivatives are no longer orthogonal with this new weighting. The inner product is expected to be non-zero.\n- **Case D:** The inner product is of a mode with itself, which defines its norm (squared). The integrand is $\\frac{1}{N^2}(\\frac{d\\phi_1}{dz})^2$, which is non-negative and not identically zero, so the integral will be a positive value.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the energy inner product for vertical ocean modes and tests for orthogonality.\n    \"\"\"\n    \n    def compute_inner_product(H, N_func, dphi1_dz_func, dphi2_dz_func, num_points=10001):\n        \"\"\"\n        Calculates the inner product using numerical quadrature (trapezoidal rule).\n\n        The inner product is defined as:\n        phi1, phi2 = integral from -H to 0 of [ (1/N(z)^2) * (dphi1/dz) * (dphi2/dz) ] dz\n\n        Args:\n            H (float): Total ocean depth in meters.\n            N_func (callable): Brunt-Väisälä frequency N(z) as a function of z.\n            dphi1_dz_func (callable): Derivative of the first mode shape, dphi1/dz.\n            dphi2_dz_func (callable): Derivative of the second mode shape, dphi2/dz.\n            num_points (int): Number of points for the vertical grid.\n\n        Returns:\n            float: The numerical value of the inner product in s^2/m.\n        \"\"\"\n        z = np.linspace(-H, 0, num_points)\n        \n        N_vals = N_func(z)\n        dphi1_vals = dphi1_dz_func(z)\n        dphi2_vals = dphi2_dz_func(z)\n        \n        # Avoid division by zero if N is ever zero, though not an issue in these test cases.\n        # Add a small epsilon to the denominator for robustness in a general case.\n        # Here, N is strictly positive, so it's not strictly necessary.\n        integrand = (1.0 / (N_vals**2)) * dphi1_vals * dphi2_vals\n        \n        # Use numpy's trapezoidal rule implementation\n        integral_value = np.trapz(integrand, z)\n        \n        return integral_value\n\n    H_val = 4000.0  # m\n    tolerance = 1e-10\n\n    # Define test cases\n    test_cases = {\n        'A': {\n            'H': H_val,\n            'N_func': lambda z: 5e-3,\n            'dphi1_dz_func': lambda z: -(np.pi / H_val) * np.sin(np.pi * z / H_val),\n            'dphi2_dz_func': lambda z: -(2 * np.pi / H_val) * np.sin(2 * np.pi * z / H_val),\n        },\n        'B': {\n            'H': H_val,\n            'N_func': lambda z: 5e-3,\n            'dphi1_dz_func': lambda z: 0.0 * z, # for d(1)/dz = 0, ensuring array shape matches\n            'dphi2_dz_func': lambda z: -(np.pi / H_val) * np.sin(np.pi * z / H_val),\n        },\n        'C': {\n            'H': H_val,\n            'N_func': lambda z: 2e-3 + 3e-3 * np.exp(z / 1000.0),\n            'dphi1_dz_func': lambda z: -(np.pi / H_val) * np.sin(np.pi * z / H_val),\n            'dphi2_dz_func': lambda z: -(2 * np.pi / H_val) * np.sin(2 * np.pi * z / H_val),\n        },\n        'D': {\n            'H': H_val,\n            'N_func': lambda z: 5e-3,\n            'dphi1_dz_func': lambda z: -(np.pi / H_val) * np.sin(np.pi * z / H_val),\n            'dphi2_dz_func': lambda z: -(np.pi / H_val) * np.sin(np.pi * z / H_val),\n        },\n    }\n\n    inner_products = []\n    orthogonality_flags = []\n\n    for key in ['A', 'B', 'C', 'D']:\n        case = test_cases[key]\n        ip_value = compute_inner_product(\n            case['H'],\n            case['N_func'],\n            case['dphi1_dz_func'],\n            case['dphi2_dz_func'],\n            num_points=20001 # Using more points for better accuracy\n        )\n        inner_products.append(ip_value)\n        is_orthogonal = abs(ip_value)  tolerance\n        orthogonality_flags.append(is_orthogonal)\n\n    # Combine results into the specified final list format\n    results = inner_products + orthogonality_flags\n\n    # Format the final output string, ensuring booleans are lowercase 'true'/'false'\n    result_str_list = []\n    for r in results:\n        if isinstance(r, bool):\n            result_str_list.append(str(r).lower())\n        else:\n            result_str_list.append(f\"{r:.15g}\")\n\n    print(f\"[{','.join(result_str_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate goal of modal decomposition is to analyze and interpret real-world oceanographic data. This final practice  puts theory into action by tackling a common data analysis problem: how to project an observed velocity profile onto a set of vertical modes to determine their respective amplitudes. You will implement a generalized least squares (GLS) framework to estimate these modal coefficients and, just as importantly, to quantify the uncertainty of your estimates given assumptions about measurement noise, a critical step in any rigorous scientific analysis.",
            "id": "3785951",
            "problem": "You are given a vertically resolved horizontal current profile in the ocean, represented at discrete depths, and an orthonormal set of vertical structure functions intended to approximate barotropic and baroclinic modes. The task is to design and implement a principled computational procedure to estimate the modal coefficients using least squares and to quantify the uncertainty of these estimates under specified measurement noise assumptions.\n\nStart from the following fundamental base:\n- The vertical modal decomposition of the horizontal velocity is defined as $u(z) = \\sum_{n=0}^{N-1} a_n \\,\\phi_n(z)$, where $a_n$ are modal coefficients, $\\phi_n(z)$ are vertical structure functions, and $N$ is the number of modes. The barotropic mode corresponds to $n=0$, and baroclinic modes correspond to $n \\ge 1$.\n- The measurement model is $u_i^{\\mathrm{obs}} = u(z_i) + \\varepsilon_i$, where $z_i$ are depths, $u_i^{\\mathrm{obs}}$ are observed velocities at depths $z_i$, and $\\varepsilon$ is zero-mean Gaussian noise with covariance matrix $\\mathbf{C}$.\n- The generalized least squares (GLS) estimate minimizes the quadratic form in the residuals weighted by the inverse noise covariance.\n\nDefine the vertical structure functions using a complete orthonormal basis on the interval $[-H,0]$ under the standard $L^2$ inner product. Specifically, map $z \\in [-H,0]$ to $x \\in [-1,1]$ by $x = 2(z+H)/H - 1$, and let $\\phi_n(z) = \\sqrt{(2n+1)/H}\\,P_n(x)$, where $P_n(x)$ are the Legendre polynomials of degree $n$. This choice ensures orthonormality, i.e., $\\int_{-H}^0 \\phi_n(z)\\,\\phi_m(z)\\,dz = \\delta_{nm}$.\n\nFrom first principles:\n- Express the discrete observation model as $\\mathbf{u}^{\\mathrm{obs}} = \\mathbf{\\Phi}\\,\\mathbf{a} + \\boldsymbol{\\varepsilon}$, where $\\mathbf{u}^{\\mathrm{obs}} \\in \\mathbb{R}^M$, $\\mathbf{a} \\in \\mathbb{R}^N$, and the design matrix $\\mathbf{\\Phi} \\in \\mathbb{R}^{M \\times N}$ has entries $\\Phi_{i,n} = \\phi_n(z_i)$.\n- Derive the GLS estimator $\\hat{\\mathbf{a}}$ by minimizing the weighted quadratic error and derive the estimator covariance using the Gaussian noise assumption. Do not invoke any shortcut formulas; derive the normal equations.\n\nImplement the estimator and uncertainty quantification algorithm using the steps below:\n- Construct $\\mathbf{\\Phi}$ from the given depths and $\\phi_n(z)$ definitions.\n- Form the noise covariance matrix $\\mathbf{C}$ as specified by each test case.\n- Solve the normal equations for $\\hat{\\mathbf{a}}$ using a numerically stable method, and compute the estimator covariance matrix.\n- Report the solvability condition by checking whether the normal matrix is full rank.\n- Compute the root-mean-square error (RMSE) between $\\hat{\\mathbf{a}}$ and a provided ground-truth $\\mathbf{a}^{\\mathrm{true}}$ for verification.\n\nPhysical units and output requirements:\n- Velocities $u$ and modal coefficients $a_n$ must be expressed in meters per second (m/s).\n- Depth $z$ and depth scale $H$ must be expressed in meters (m).\n- All reported RMSE and uncertainties must be expressed in meters per second (m/s), rounded to six decimal places.\n\nTest suite:\nImplement the procedure for the following four test cases. For all cases, construct the observed profile deterministically as $\\mathbf{u}^{\\mathrm{obs}} = \\mathbf{\\Phi}\\,\\mathbf{a}^{\\mathrm{true}}$ (i.e., do not add a noise realization), and only use the noise covariance to compute the GLS weights and estimator uncertainty.\n\n- Case A (general, well-sampled):\n  - $H = 4000\\,\\mathrm{m}$, $N = 4$, $M = 81$, depths $z_i$ are equally spaced from $-H$ to $0$.\n  - Noise covariance is diagonal with $\\sigma = 0.020\\,\\mathrm{m/s}$ so that $\\mathbf{C} = \\sigma^2 \\mathbf{I}$.\n  - Ground truth coefficients $\\mathbf{a}^{\\mathrm{true}} = [0.25, -0.12, 0.08, 0.00]$ in $\\mathrm{m/s}$.\n\n- Case B (boundary sampling: minimal levels):\n  - $H = 3000\\,\\mathrm{m}$, $N = 3$, $M = 3$, depths $z_i = [-H, -H/2, 0]$.\n  - Noise covariance is diagonal with $\\sigma = 0.005\\,\\mathrm{m/s}$, i.e., $\\mathbf{C} = \\sigma^2 \\mathbf{I}$.\n  - Ground truth coefficients $\\mathbf{a}^{\\mathrm{true}} = [0.20, 0.00, -0.10]$ in $\\mathrm{m/s}$.\n\n- Case C (heteroscedastic noise and nonuniform depths):\n  - $H = 5000\\,\\mathrm{m}$, $N = 5$, $M = 50$, depths $z_i$ are nonuniform: $z_i = -H\\left(1 - \\left(\\frac{i}{M-1}\\right)^2\\right)$ for $i = 0, 1, \\dots, M-1$.\n  - Noise covariance is diagonal with standard deviations $\\sigma_i = 0.010 + 0.0003\\,i$ in $\\mathrm{m/s}$, so that $C_{ii} = \\sigma_i^2$ and $C_{ij} = 0$ for $i \\ne j$.\n  - Ground truth coefficients $\\mathbf{a}^{\\mathrm{true}} = [0.10, -0.05, 0.02, 0.00, 0.01]$ in $\\mathrm{m/s}$.\n\n- Case D (correlated noise):\n  - $H = 4000\\,\\mathrm{m}$, $N = 3$, $M = 40$, depths $z_i$ are equally spaced from $-H$ to $0$.\n  - Noise covariance has correlation $C_{ij} = \\sigma^2 \\rho^{|i-j|}$ with $\\sigma = 0.020\\,\\mathrm{m/s}$ and $\\rho = 0.60$.\n  - Ground truth coefficients $\\mathbf{a}^{\\mathrm{true}} = [-0.15, 0.05, 0.02]$ in $\\mathrm{m/s}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a list of the form $[\\text{solvable}, \\text{rmse}, [\\text{unc}_0, \\dots, \\text{unc}_{N-1}]]$, where $\\text{solvable}$ is a boolean indicating whether the normal matrix has full rank, $\\text{rmse}$ is the root-mean-square error in $\\mathrm{m/s}$ rounded to six decimal places, and each $\\text{unc}_n$ is the standard deviation of $\\hat{a}_n$ in $\\mathrm{m/s}$ rounded to six decimal places. Thus, the overall output is a single nested list like $[[\\dots],[\\dots],[\\dots],[\\dots]]$.",
            "solution": "We begin from the vertical modal decomposition $u(z) = \\sum_{n=0}^{N-1} a_n \\,\\phi_n(z)$, where the $\\phi_n(z)$ are orthonormal over depth $z \\in [-H,0]$ with respect to the standard inner product, i.e., $\\int_{-H}^{0} \\phi_n(z)\\,\\phi_m(z)\\,dz = \\delta_{nm}$. In the barotropic and baroclinic mode decomposition framework, $n=0$ denotes the barotropic mode (depth-independent), and $n \\ge 1$ denotes baroclinic modes (depth-varying).\n\nObservations are taken at discrete depths $z_i$ for $i=1,\\dots,M$, obeying the measurement model $u_i^{\\mathrm{obs}} = u(z_i) + \\varepsilon_i$, with $\\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{C})$ and $\\mathbf{C} \\in \\mathbb{R}^{M \\times M}$ positive definite. In matrix form, this is\n$$\n\\mathbf{u}^{\\mathrm{obs}} = \\mathbf{\\Phi}\\,\\mathbf{a} + \\boldsymbol{\\varepsilon},\n$$\nwhere $\\mathbf{u}^{\\mathrm{obs}} \\in \\mathbb{R}^M$ collects $u_i^{\\mathrm{obs}}$, $\\mathbf{a} \\in \\mathbb{R}^N$ collects the coefficients $a_n$, and $\\mathbf{\\Phi} \\in \\mathbb{R}^{M \\times N}$ is the design matrix with entries $\\Phi_{i,n} = \\phi_n(z_i)$.\n\nGeneralized Least Squares (GLS) derives from minimizing the weighted residual norm:\n$$\nJ(\\mathbf{a}) = \\left(\\mathbf{u}^{\\mathrm{obs}} - \\mathbf{\\Phi}\\,\\mathbf{a}\\right)^{\\!\\top} \\mathbf{C}^{-1} \\left(\\mathbf{u}^{\\mathrm{obs}} - \\mathbf{\\Phi}\\,\\mathbf{a}\\right).\n$$\nTaking the gradient with respect to $\\mathbf{a}$ and setting to zero:\n$$\n\\nabla_{\\mathbf{a}} J = -2\\,\\mathbf{\\Phi}^{\\top}\\mathbf{C}^{-1} \\left(\\mathbf{u}^{\\mathrm{obs}} - \\mathbf{\\Phi}\\,\\mathbf{a}\\right) = \\mathbf{0}.\n$$\nThis yields the normal equations\n$$\n\\mathbf{A}\\,\\hat{\\mathbf{a}} = \\mathbf{b}, \\quad \\text{where} \\quad \\mathbf{A} = \\mathbf{\\Phi}^{\\top}\\mathbf{C}^{-1}\\mathbf{\\Phi}, \\quad \\mathbf{b} = \\mathbf{\\Phi}^{\\top}\\mathbf{C}^{-1}\\mathbf{u}^{\\mathrm{obs}}.\n$$\nAssuming $\\mathbf{A}$ is full rank (i.e., rank $N$), the GLS estimate is uniquely\n$$\n\\hat{\\mathbf{a}} = \\mathbf{A}^{-1}\\,\\mathbf{b}.\n$$\nUnder the Gaussian noise assumption, the estimator uncertainty is quantified by the covariance of $\\hat{\\mathbf{a}}$:\n$$\n\\mathrm{Cov}(\\hat{\\mathbf{a}}) = \\left(\\mathbf{\\Phi}^{\\top}\\mathbf{C}^{-1}\\mathbf{\\Phi}\\right)^{-1} = \\mathbf{A}^{-1}.\n$$\nThe standard deviations of the coefficients are then $\\sigma_{\\hat{a}_n} = \\sqrt{\\left[\\mathrm{diag}\\left(\\mathrm{Cov}(\\hat{\\mathbf{a}})\\right)\\right]_n}$.\n\nRegarding the vertical structure functions, we choose an orthonormal set on $[-H,0]$ using Legendre polynomials $P_n(x)$ on $[-1,1]$ mapped via $x = 2(z+H)/H - 1$. Define\n$$\n\\phi_n(z) = \\sqrt{\\frac{2n+1}{H}}\\,P_n\\!\\left(2\\frac{z+H}{H} - 1\\right).\n$$\nTo verify orthonormality, note $dz = \\frac{H}{2} dx$, and the Legendre polynomials satisfy $\\int_{-1}^{1} P_n(x)\\,P_m(x)\\,dx = \\frac{2}{2n+1}\\,\\delta_{nm}$. Therefore\n$$\n\\int_{-H}^{0} \\phi_n(z)\\,\\phi_m(z)\\,dz = \\int_{-1}^{1} \\sqrt{\\frac{2n+1}{H}}\\,P_n(x)\\;\\sqrt{\\frac{2m+1}{H}}\\,P_m(x)\\;\\frac{H}{2}\\,dx = \\delta_{nm}.\n$$\nThis construction approximates barotropic and baroclinic modes: $n=0$ yields the constant barotropic mode $\\phi_0(z) = \\sqrt{1/H}$, while $n\\ge 1$ yields vertical variations (baroclinic modes).\n\nAlgorithmic design:\n- Compute $\\mathbf{\\Phi}$ by evaluating $\\phi_n(z_i)$ at each depth $z_i$ for $n=0,\\dots,N-1$.\n- Construct $\\mathbf{C}$ according to the noise model. For diagonal (independent) noise, set $C_{ii} = \\sigma_i^2$. For correlated noise, set $C_{ij} = \\sigma^2 \\rho^{|i-j|}$.\n- To avoid explicitly inverting $\\mathbf{C}$, compute $\\mathbf{A} = \\mathbf{\\Phi}^{\\top}\\,\\mathbf{X}$ and $\\mathbf{b} = \\mathbf{\\Phi}^{\\top}\\,\\mathbf{y}$, where $\\mathbf{X}$ solves $\\mathbf{C}\\,\\mathbf{X} = \\mathbf{\\Phi}$ and $\\mathbf{y}$ solves $\\mathbf{C}\\,\\mathbf{y} = \\mathbf{u}^{\\mathrm{obs}}$. This uses linear solves for numerical stability.\n- Solve $\\mathbf{A}\\,\\hat{\\mathbf{a}} = \\mathbf{b}$ using a direct solver. If $\\mathbf{A}$ is rank-deficient, use a pseudoinverse $\\mathbf{A}^{+}$ to compute the minimum-norm solution and set $\\mathrm{Cov}(\\hat{\\mathbf{a}}) = \\mathbf{A}^{+}$ as an uncertainty proxy.\n- Check solvability by verifying whether $\\mathrm{rank}(\\mathbf{A}) = N$.\n- Compute $\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} \\left(\\hat{a}_n - a_n^{\\mathrm{true}}\\right)^2}$.\n- Report standard deviations $\\sigma_{\\hat{a}_n} = \\sqrt{\\left[\\mathrm{diag}\\left(\\mathrm{Cov}(\\hat{\\mathbf{a}})\\right)\\right]_n}$.\n\nTest suite execution details:\n- For each case (A–D), set depths and $H$ as specified, build $\\mathbf{\\Phi}$, set $\\mathbf{C}$ according to the noise model, set $\\mathbf{a}^{\\mathrm{true}}$, and compute $\\mathbf{u}^{\\mathrm{obs}} = \\mathbf{\\Phi}\\,\\mathbf{a}^{\\mathrm{true}}$ deterministically.\n- Compute $\\hat{\\mathbf{a}}$, $\\mathrm{Cov}(\\hat{\\mathbf{a}})$, solvability, $\\mathrm{RMSE}$, and uncertainties.\n- Output the results for all cases in one line as a single nested list. All RMSE and uncertainties must be rounded to six decimal places and expressed in $\\mathrm{m/s}$.\n\nThis approach tests the derivation and implementation of GLS for barotropic/baroclinic modal decomposition, the effect of orthonormal bases on the normal matrix, the impact of sampling and noise models on solvability, and rigorous uncertainty quantification through estimator covariance.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef legendre_val(n, x):\n    \"\"\"\n    Evaluate the Legendre polynomial P_n(x) using numpy.polynomial.legendre.legval.\n    \"\"\"\n    c = np.zeros(n + 1)\n    c[n] = 1.0\n    return np.polynomial.legendre.legval(x, c)\n\ndef modes_matrix(z, H, N_modes):\n    \"\"\"\n    Construct the design matrix Phi with entries Phi[i, n] = phi_n(z_i),\n    where phi_n are orthonormal vertical structure functions built from Legendre polynomials.\n    \"\"\"\n    z = np.asarray(z)\n    x = 2.0 * (z + H) / H - 1.0  # Map z in [-H,0] to x in [-1,1]\n    M = z.size\n    Phi = np.zeros((M, N_modes))\n    for n in range(N_modes):\n        Pn = legendre_val(n, x)\n        Phi[:, n] = np.sqrt((2*n + 1) / H) * Pn\n    return Phi\n\ndef left_solve(C, B):\n    \"\"\"\n    Solve C X = B for X without forming C^{-1}.\n    \"\"\"\n    return np.linalg.solve(C, B)\n\ndef gls_estimate(Phi, C, u_obs):\n    \"\"\"\n    Compute the generalized least squares estimate for a, its covariance, and solvability.\n    Returns (a_hat, cov_a, solvable_boolean).\n    \"\"\"\n    # Compute A = Phi^T C^{-1} Phi and b = Phi^T C^{-1} u_obs via linear solves\n    X = left_solve(C, Phi)\n    y = left_solve(C, u_obs)\n    A = Phi.T @ X\n    b = Phi.T @ y\n\n    # Check rank\n    rank_A = np.linalg.matrix_rank(A)\n    N = Phi.shape[1]\n    solvable = (rank_A == N)\n\n    # Solve for a_hat\n    if solvable:\n        a_hat = np.linalg.solve(A, b)\n        cov_a = np.linalg.inv(A)\n    else:\n        # Use pseudo-inverse for minimum-norm solution and uncertainty proxy\n        A_pinv = np.linalg.pinv(A)\n        a_hat = A_pinv @ b\n        cov_a = A_pinv\n\n    return a_hat, cov_a, solvable\n\ndef rmse(a_hat, a_true):\n    diff = a_hat - a_true\n    return float(np.sqrt(np.mean(diff**2)))\n\ndef build_covariance_diagonal(sigmas):\n    sigmas = np.asarray(sigmas)\n    return np.diag(sigmas**2)\n\ndef build_covariance_ar1(sigma, rho, M):\n    \"\"\"\n    Build AR(1)-like covariance: C_ij = sigma^2 * rho^{|i-j|}.\n    \"\"\"\n    idx = np.arange(M)\n    C = sigma**2 * rho**(np.abs(idx[:, None] - idx[None, :]))\n    return C\n\ndef case_A():\n    # Parameters\n    H = 4000.0  # m\n    N = 4\n    M = 81\n    z = np.linspace(-H, 0.0, M)\n    sigma = 0.020  # m/s\n    a_true = np.array([0.25, -0.12, 0.08, 0.00])  # m/s\n\n    Phi = modes_matrix(z, H, N)\n    C = build_covariance_diagonal(np.full(M, sigma))\n    u_obs = Phi @ a_true\n\n    a_hat, cov_a, solvable = gls_estimate(Phi, C, u_obs)\n    rms = rmse(a_hat, a_true)\n    uncertainties = np.sqrt(np.diag(cov_a))\n    return solvable, rms, uncertainties.tolist()\n\ndef case_B():\n    H = 3000.0  # m\n    N = 3\n    z = np.array([-H, -H/2.0, 0.0])\n    M = z.size\n    sigma = 0.005  # m/s\n    a_true = np.array([0.20, 0.00, -0.10])  # m/s\n\n    Phi = modes_matrix(z, H, N)\n    C = build_covariance_diagonal(np.full(M, sigma))\n    u_obs = Phi @ a_true\n\n    a_hat, cov_a, solvable = gls_estimate(Phi, C, u_obs)\n    rms = rmse(a_hat, a_true)\n    uncertainties = np.sqrt(np.diag(cov_a))\n    return solvable, rms, uncertainties.tolist()\n\ndef case_C():\n    H = 5000.0  # m\n    N = 5\n    M = 50\n    i = np.arange(M)\n    z = -H * (1.0 - (i / (M - 1))**2)  # nonuniform depths from -H to 0\n    sigmas = 0.010 + 0.0003 * i  # m/s\n    a_true = np.array([0.10, -0.05, 0.02, 0.00, 0.01])  # m/s\n\n    Phi = modes_matrix(z, H, N)\n    C = build_covariance_diagonal(sigmas)\n    u_obs = Phi @ a_true\n\n    a_hat, cov_a, solvable = gls_estimate(Phi, C, u_obs)\n    rms = rmse(a_hat, a_true)\n    uncertainties = np.sqrt(np.diag(cov_a))\n    return solvable, rms, uncertainties.tolist()\n\ndef case_D():\n    H = 4000.0  # m\n    N = 3\n    M = 40\n    z = np.linspace(-H, 0.0, M)\n    sigma = 0.020  # m/s\n    rho = 0.60\n    a_true = np.array([-0.15, 0.05, 0.02])  # m/s\n\n    Phi = modes_matrix(z, H, N)\n    C = build_covariance_ar1(sigma, rho, M)\n    u_obs = Phi @ a_true\n\n    a_hat, cov_a, solvable = gls_estimate(Phi, C, u_obs)\n    rms = rmse(a_hat, a_true)\n    uncertainties = np.sqrt(np.diag(cov_a))\n    return solvable, rms, uncertainties.tolist()\n\ndef round_list(lst, decimals=6):\n    return [round(x, decimals) for x in lst]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    cases = [case_A, case_B, case_C, case_D]\n\n    results = []\n    for case_func in cases:\n        solvable, rms, unc = case_func()\n        # Round RMSE and uncertainties to six decimals\n        rms_rounded = round(rms, 6)\n        unc_rounded = round_list(unc, 6)\n        results.append([solvable, rms_rounded, unc_rounded])\n\n    # Final print statement in the exact required format.\n    print(str(results))\n\nsolve()\n```"
        }
    ]
}