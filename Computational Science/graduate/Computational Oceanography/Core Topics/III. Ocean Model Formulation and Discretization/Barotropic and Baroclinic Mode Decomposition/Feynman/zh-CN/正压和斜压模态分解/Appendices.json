{
    "hands_on_practices": [
        {
            "introduction": "为了从物理上直观地理解斜压模态，最简单的方法是从一个两层海洋模型入手。这项实践将引导你推导第一斜压模态的相速度，从而具体掌握“折减重力”（reduced gravity）和“等效深度”（equivalent depth）等核心概念 。通过计算，你将能够清晰地看到，内部（斜压）波的传播速度为何远小于外部（正压）的重力波。",
            "id": "3785901",
            "problem": "考虑一个在Boussinesq近似下的无粘性、静力、水平无限延伸的双层海洋，其上层厚度为$H_1$，下层厚度为$H_2$，上层密度为$\\rho_1$，下层密度为$\\rho_2$，且$\\rho_2 > \\rho_1$。设平均自由表面由刚盖近似固定，内界面位移为$\\eta(x,y,t)$，从其平均位置向上为正。假设为长波（水平尺度远大于垂直尺度），忽略行星旋转和任何外部强迫，并考虑小振幅运动，因此线性化有效。约化重力定义为$g' = g(\\rho_2 - \\rho_1)/\\rho_0$，其中$g$为重力加速度，$\\rho_0$为Boussinesq近似下的一个代表性常数密度。\n\n从分层的线性化浅水动量和连续性方程出发，推导第一斜压模的长波相速度$c_1$关于$g'$, $H_1$和$H_2$的闭式解析表达式。然后，计算当$H_1 = 500\\,\\text{m}$，$H_2 = 3500\\,\\text{m}$，且$g' = 0.02\\,\\text{m}\\,\\text{s}^{-2}$时$c_1$的值。以米每秒为单位表示速度的最终数值答案，并将结果四舍五入到四位有效数字。你的最终答案必须是一个实数。",
            "solution": "### 第1步：提取并验证已知条件\n问题是地球物理流体动力学中的一个经典练习，使用标准的双层浅水方程和公认的近似（Boussinesq、静力、刚盖、线性化）来研究内波。其物理原理完全可靠，问题定义清晰，数据充分，存在唯一解。\n\n### 第2步：解题推导\n我们从一个双层流体的线性化、静力、Boussinesq方程开始，忽略旋转和强迫。设$\\mathbf{u}_1$和$\\mathbf{u}_2$分别为上层和下层中与深度无关的水平速度。\n\n每个分层的水平动量方程为：\n$$ (1) \\quad \\frac{\\partial \\mathbf{u}_1}{\\partial t} = -\\frac{1}{\\rho_0} \\nabla_H p_1 $$\n$$ (2) \\quad \\frac{\\partial \\mathbf{u}_2}{\\partial t} = -\\frac{1}{\\rho_0} \\nabla_H p_2 $$\n在静力近似和刚盖近似下，压力梯度可以表示为：\n$$ \\nabla_H p_1 = \\nabla_H p_b - g(\\rho_2 - \\rho_1) \\nabla_H \\eta $$\n$$ \\nabla_H p_2 = \\nabla_H p_b $$\n其中 $p_b$ 是与底部压力相关的项，$\\eta$ 是界面位移。将这些代入动量方程，并使用约化重力 $g' = g(\\rho_2 - \\rho_1)/\\rho_0$ 的定义，我们得到：\n$$ (3) \\quad \\frac{\\partial \\mathbf{u}_1}{\\partial t} = -\\frac{1}{\\rho_0}\\nabla_H p_b + g' \\nabla_H \\eta $$\n$$ (4) \\quad \\frac{\\partial \\mathbf{u}_2}{\\partial t} = -\\frac{1}{\\rho_0}\\nabla_H p_b $$\n\n对于线性化的小扰动，每个分层的连续性方程为：\n$$ (5) \\quad H_1 \\nabla_H \\cdot \\mathbf{u}_1 = \\frac{\\partial \\eta}{\\partial t} $$\n$$ (6) \\quad H_2 \\nabla_H \\cdot \\mathbf{u}_2 = -\\frac{\\partial \\eta}{\\partial t} $$\n方程(5)表明上层厚度的减小（由界面抬升$\\eta$引起）被水平流的辐散所平衡。方程(6)则表明下层厚度的增加被水平流的辐合所平衡。\n\n为了分离出斜压模，我们消去正压压力梯度项$\\nabla_H p_b$。我们将方程$(3)$减去方程$(4)$：\n$$ \\frac{\\partial}{\\partial t}(\\mathbf{u}_1 - \\mathbf{u}_2) = g' \\nabla_H \\eta $$\n这个方程将垂直速度切变与内界面的坡度联系起来，是斜压动力学的本质。\n\n现在，我们对这个切变方程取水平辐散：\n$$ (7) \\quad \\frac{\\partial}{\\partial t} \\nabla_H \\cdot (\\mathbf{u}_1 - \\mathbf{u}_2) = g' \\nabla_H^2 \\eta $$\n其中$\\nabla_H^2$是水平拉普拉斯算子。\n\n从连续性方程(5)和(6)，我们可以用$\\eta$表示速度辐散：\n$$ \\nabla_H \\cdot \\mathbf{u}_1 = \\frac{1}{H_1} \\frac{\\partial \\eta}{\\partial t} $$\n$$ \\nabla_H \\cdot \\mathbf{u}_2 = -\\frac{1}{H_2} \\frac{\\partial \\eta}{\\partial t} $$\n将这些表达式代入方程$(7)$：\n$$ \\frac{\\partial}{\\partial t} \\left( \\frac{1}{H_1} \\frac{\\partial \\eta}{\\partial t} - \\left(-\\frac{1}{H_2} \\frac{\\partial \\eta}{\\partial t}\\right) \\right) = g' \\nabla_H^2 \\eta $$\n$$ \\left(\\frac{1}{H_1} + \\frac{1}{H_2}\\right) \\frac{\\partial^2 \\eta}{\\partial t^2} = g' \\nabla_H^2 \\eta $$\n合并括号中的项：\n$$ \\left(\\frac{H_1 + H_2}{H_1 H_2}\\right) \\frac{\\partial^2 \\eta}{\\partial t^2} = g' \\nabla_H^2 \\eta $$\n将其重新排列成波动方程的标准形式$\\frac{\\partial^2 \\eta}{\\partial t^2} = c^2 \\nabla_H^2 \\eta$：\n$$ \\frac{\\partial^2 \\eta}{\\partial t^2} = g' \\frac{H_1 H_2}{H_1 + H_2} \\nabla_H^2 \\eta $$\n通过比较，第一斜压模的相速度$c_1$的平方是：\n$$ c_1^2 = g' \\frac{H_1 H_2}{H_1 + H_2} $$\n因此，相速度的解析表达式是：\n$$ c_1 = \\sqrt{g' \\frac{H_1 H_2}{H_1 + H_2}} $$\n\n### 第3步：数值计算\n现在，我们使用给定的值计算$c_1$：\n- $H_1 = 500\\,\\text{m}$\n- $H_2 = 3500\\,\\text{m}$\n- $g' = 0.02\\,\\text{m}\\,\\text{s}^{-2}$\n\n首先，我们计算第一斜压模的“等效深度”，$H_{eq} = \\frac{H_1 H_2}{H_1 + H_2}$：\n$$ H_{eq} = \\frac{(500)(3500)}{500 + 3500} = \\frac{1750000}{4000} = \\frac{1750}{4} = 437.5\\,\\text{m} $$\n接下来，我们计算$c_1^2$：\n$$ c_1^2 = g' H_{eq} = (0.02\\,\\text{m}\\,\\text{s}^{-2})(437.5\\,\\text{m}) = 8.75\\,\\text{m}^2\\,\\text{s}^{-2} $$\n最后，我们取平方根求得$c_1$：\n$$ c_1 = \\sqrt{8.75}\\,\\text{m}\\,\\text{s}^{-1} \\approx 2.95803989\\,\\text{m}\\,\\text{s}^{-1} $$\n问题要求答案四舍五入到四位有效数字。\n$$ c_1 \\approx 2.958\\,\\text{m}\\,\\text{s}^{-1} $$\n最终的数值答案是$2.958$。",
            "answer": "$$\\boxed{2.958}$$"
        },
        {
            "introduction": "真实海洋的层结是连续变化的，而非简单的两层结构。因此，从理想模型过渡到实际应用，关键一步是计算浮力频率（或称Brunt–Väisälä频率）$N^2(z)$，它是连续层结海洋中模态分析的基础 。本练习将指导你如何处理原始的温度和盐度剖面数据，通过数值计算和数据平滑，生成一个可用于求解垂直模态问题的$N^2(z)$剖面。",
            "id": "3799111",
            "problem": "给定海洋水柱中温度和盐度随深度变化的离散垂直剖面。目标是使用物理上一致的海水状态方程，在 Boussinesq 近似和静力近似下，计算浮力频率的平方 $N^2(z)$，然后准备一个光滑、非负的函数 $N^2(z)$，以用作正压和斜压运动垂直模态分解的输入。推导必须从第一性原理开始，程序必须相应地实现该算法。\n\n假设使用以下广泛应用的近似：\n- Boussinesq 近似，其中参考密度 $\\rho_0$ 为常数。\n- 促使我们使用线性稳定性度量 $N^2$ 的静力平衡和小振幅扰动。\n- 线性化海水状态方程：$\\rho(T,S) = \\rho_0 \\left(1 - \\alpha (T - T_\\mathrm{ref}) + \\beta (S - S_\\mathrm{ref})\\right)$，其中 $\\alpha$ 是热膨胀系数，$\\beta$ 是盐缩系数，$T$ 是位温（单位：摄氏度），$S$ 是实用盐度（单位：无量纲的实用盐度单位 PSU）。参考值 $T_\\mathrm{ref}$ 和 $S_\\mathrm{ref}$ 是常数，在垂直微分中会抵消，不影响 $N^2$。\n\n使用以下标准常数：\n- 重力加速度 $g = 9.81$，单位为 $\\mathrm{m\\,s^{-2}}$。\n- 热膨胀系数 $\\alpha = 2.0 \\times 10^{-4}$，单位为 $\\mathrm{K^{-1}}$。\n- 盐缩系数 $\\beta = 7.6 \\times 10^{-4}$，单位为 $(\\mathrm{PSU})^{-1}$。\n- 参考密度 $\\rho_0$ 是常数（其确切数值在下述 $N^2$ 的线性化公式中被抵消，因此在数值上不需要）。\n\n设深度 $d$ 以米为单位，向下为正，自由表面处 $d=0$。设 $T(d)$ 和 $S(d)$ 是在跨越 $[0,1000]$ 米的离散网格 $\\{d_i\\}_{i=0}^{N-1}$ 上采样的给定剖面。从第一性原理出发，当垂直坐标 $z$ 指向上的情况下，浮力频率的平方定义为\n$$\nN^2(z) = -\\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial z}.\n$$\n当深度坐标 $d$ 向下为正时，根据链式法则可得\n$$\n\\frac{\\partial}{\\partial z} = -\\frac{\\partial}{\\partial d},\n$$\n并使用线性化海水状态方程，密度对深度的垂直导数为\n$$\n\\frac{\\partial \\rho}{\\partial d} = \\rho_0\\left(-\\alpha \\frac{\\partial T}{\\partial d} + \\beta \\frac{\\partial S}{\\partial d}\\right).\n$$\n因此，\n$$\nN^2(d) = \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial d} = g\\left(\\beta \\frac{\\partial S}{\\partial d} - \\alpha \\frac{\\partial T}{\\partial d}\\right).\n$$\n\n将 $N^2(d)$ 准备为适用于垂直模态分解的函数的算法要求：\n1. 使用在内部点为二阶精度、在边界点为单侧格式的一致性有限差分，计算离散的垂直梯度 $\\frac{\\partial T}{\\partial d}$ 和 $\\frac{\\partial S}{\\partial d}$。\n2. 通过线性化公式 $N^2(d) = g\\left(\\beta \\frac{\\partial S}{\\partial d} - \\alpha \\frac{\\partial T}{\\partial d}\\right)$ 计算 $N^2(d)$，单位为 $\\mathrm{s^{-2}}$。\n3. 通过将 $N^2(d)$ 裁剪到最小下限值 $N^2_\\mathrm{min} = 10^{-6}$（单位为 $\\mathrm{s^{-2}}$）来强制执行 Sturm–Liouville 适定性所需的非负性，即，设 $N^2(d) \\leftarrow \\max\\left(N^2(d), N^2_\\mathrm{min}\\right)$。\n4. 使用分段三次埃尔米特插值多项式 (PCHIP) 构建一个光滑的保形插值函数 $\\widehat{N^2}(d)$，以便可以在垂直模态求解器所需的任意深度上对其进行求值，而不会产生过冲伪影。\n\n您的程序必须实现上述算法，并在指定的一组查询深度上对准备好的函数 $\\widehat{N^2}(d)$ 进行求值，适用于多个测试用例。所有输出必须以 $\\mathrm{s^{-2}}$ 为单位，使用至少六位小数的科学记数法表示。本问题不使用角度。最终输出必须是单行，包含所有测试用例的聚合结果，形式为逗号分隔的列表，并用方括号括起来，其中每个测试用例的结果本身也是一个逗号分隔的值列表，也用方括号括起来，例如，$[[r_{1,1},r_{1,2}],[r_{2,1},r_{2,2}]]$，不含空格。\n\n测试套件（以物理上合理的形式提供所有 $T(d)$ 和 $S(d)$）：\n\n- 测试用例 1 (分层良好的温跃层):\n  - 深度网格：$d_i \\in [0,1000]$ 米， $N = 501$ 个均匀间隔的点。\n  - 温度：$T(d) = 20 - 15 \\tanh\\left(\\frac{d - 200}{150}\\right)$，单位：摄氏度。\n  - 盐度：$S(d) = 34.5 + 0.5 \\tanh\\left(\\frac{d - 300}{200}\\right)$，单位：PSU。\n  - 查询深度（单位：米）：$[0,100,250,500,1000]$。\n\n- 测试用例 2 (近乎未分层的水柱):\n  - 深度网格：$d_i \\in [0,1000]$ 米， $N = 501$ 个均匀间隔的点。\n  - 温度：$T(d) = 10$，单位：摄氏度。\n  - 盐度：$S(d) = 35$，单位：PSU。\n  - 查询深度（单位：米）：$[0,100,250,500,1000]$。\n\n- 测试用例 3 (带有小振荡的弱不稳定层，需要裁剪):\n  - 深度网格：$d_i \\in [0,1000]$ 米， $N = 501$ 个均匀间隔的点。\n  - 温度：$T(d) = 14 + 0.5 \\sin\\left(\\frac{2\\pi d}{120}\\right) - 11 \\frac{d}{1000}$，单位：摄氏度。\n  - 盐度：$S(d) = 34.8 + 0.2 \\cos\\left(\\frac{2\\pi d}{180}\\right) + 0.1 \\frac{d}{1000}$，单位：PSU。\n  - 查询深度（单位：米）：$[0,100,250,500,1000]$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果是以科学记数法表示的、在指定查询深度处的 $\\widehat{N^2}(d)$ 值的逗号分隔列表（单位为 $\\mathrm{s^{-2}}$），至少有六位小数，并且不含任何空格。例如，格式必须是 $[[v_{1,1},v_{1,2},\\ldots,v_{1,5}],[v_{2,1},\\ldots,v_{2,5}],[v_{3,1},\\ldots,v_{3,5}]]$。",
            "solution": "该问题是有效的，因为它在科学上基于地球物理流体动力学原理，是适定的，具有通向唯一解的清晰算法路径，并以客观、正式的语言表述。我们开始求解。\n\n目标是根据位温 $T(d)$ 和盐度 $S(d)$ 的垂直剖面计算浮力频率的平方，记为 $N^2$，其中 $d$ 是深度，向下为正。这个量对于分析分层流体柱的稳定性以及将海洋运动分解为其垂直正压和斜压模态至关重要。该过程涉及从第一性原理推导 $N^2$，然后实现一个数值算法，以准备一个适用于数值模型的光滑、非负剖面。\n\n**基于原理的推导**\n\n浮力频率的平方 $N^2$ 量化了分层介质中垂直位移的流体质点所受的恢复力。在稳定分层中，位移的流体质点比其新环境的密度小（如果向上位移）或密度大（如果向下位移），导致它围绕其平衡位置振荡。$N$ 代表这种振荡的频率。\n\n当垂直坐标 $z$ 指向海床上方时，$N^2(z)$ 定义为：\n$$\nN^2(z) = - \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial z}\n$$\n其中 $g$ 是重力加速度，$\\rho$ 是位密，$\\rho_0$ 是一个恒定的参考密度，这与 Boussinesq 近似一致。该近似假设密度的变化与参考密度相比很小，除非乘以 $g$。\n\n该问题使用一个向下为正的深度坐标 $d$，其中 $d=0$ 位于海面。这两个坐标之间的关系意味着 $\\partial/\\partial z = -\\partial/\\partial d$。将此代入 $N^2$ 的定义中得到：\n$$\nN^2(d) = \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial d}\n$$\n\n位密 $\\rho$ 是位温 $T$ 和盐度 $S$ 的函数。问题提供了一个线性化的状态方程：\n$$\n\\rho(T, S) = \\rho_0 \\left(1 - \\alpha (T - T_{\\mathrm{ref}}) + \\beta (S - S_{\\mathrm{ref}})\\right)\n$$\n这里，$\\alpha$ 是热膨胀系数，$\\beta$ 是盐缩系数，$T_{\\mathrm{ref}}$ 和 $S_{\\mathrm{ref}}$ 是恒定的参考值。为了求得垂直密度梯度，我们使用链式法则对 $\\rho$ 关于深度 $d$ 进行微分：\n$$\n\\frac{\\partial \\rho}{\\partial d} = \\frac{\\partial \\rho}{\\partial T} \\frac{\\partial T}{\\partial d} + \\frac{\\partial \\rho}{\\partial S} \\frac{\\partial S}{\\partial d}\n$$\n从线性化的状态方程可知，偏导数为 $\\partial \\rho / \\partial T = -\\rho_0 \\alpha$ 和 $\\partial \\rho / \\partial S = \\rho_0 \\beta$。代入这些可得：\n$$\n\\frac{\\partial \\rho}{\\partial d} = \\rho_0 \\left(-\\alpha \\frac{\\partial T}{\\partial d} + \\beta \\frac{\\partial S}{\\partial d}\\right)\n$$\n\n最后，将这个密度梯度的表达式代回 $N^2(d)$ 的公式中：\n$$\nN^2(d) = \\frac{g}{\\rho_0} \\left[ \\rho_0 \\left(-\\alpha \\frac{\\partial T}{\\partial d} + \\beta \\frac{\\partial S}{\\partial d}\\right) \\right]\n$$\n参考密度 $\\rho_0$ 被消去，得到最终的计算公式：\n$$\nN^2(d) = g \\left(\\beta \\frac{\\partial S}{\\partial d} - \\alpha \\frac{\\partial T}{\\partial d}\\right)\n$$\n该方程表明，稳定性 ($N^2 > 0$) 会因盐度随深度增加（$\\partial S/\\partial d > 0$，即更咸、密度更大的水在下方）和温度随深度降低（$\\partial T/\\partial d  0$，即更冷、密度更大的水在下方）而增强。\n\n**数值算法设计**\n\n该问题要求一个四步算法，将离散的 $T(d)$ 和 $S(d)$ 剖面转换为一个连续、光滑且非负的函数 $\\widehat{N^2}(d)$。\n\n1.  **离散梯度计算**：给定在均匀深度网格 $\\{d_i\\}_{i=0}^{N-1}$（间距为 $h = d_{i+1} - d_i$）上的离散剖面 $T_i = T(d_i)$ 和 $S_i = S(d_i)$，必须对垂直梯度 $\\partial T/\\partial d$ 和 $\\partial S/\\partial d$ 进行数值近似。为了保持良好的精度，指定了二阶有限差分格式。对于内部点（$1 \\le i \\le N-2$），使用中心差分公式：\n    $$\n    f'(d_i) \\approx \\frac{f(d_{i+1}) - f(d_{i-1})}{2h}\n    $$\n    对于边界，需要使用二阶精度的单侧公式，以避免降低整体精度。在表面（$i=0$）：\n    $$\n    f'(d_0) \\approx \\frac{-3f(d_0) + 4f(d_1) - f(d_2)}{2h}\n    $$\n    在底部（$i=N-1$）：\n    $$\n    f'(d_{N-1}) \\approx \\frac{3f(d_{N-1}) - 4f(d_{N-2}) + f(d_{N-3})}{2h}\n    $$\n    这些计算得出了 $(\\partial T/\\partial d)_i$ 和 $(\\partial S/\\partial d)_i$ 的离散数组。\n\n2.  **$N^2(d)$ 剖面计算**：使用计算出的梯度和给定的常数 $g = 9.81\\,\\mathrm{m\\,s^{-2}}$、$\\alpha = 2.0 \\times 10^{-4}\\,\\mathrm{K^{-1}}$ 和 $\\beta = 7.6 \\times 10^{-4}\\,(\\mathrm{PSU})^{-1}$，在每个网格点 $d_i$ 上使用推导出的公式计算离散的浮力频率平方剖面 $(N^2)_i$：\n    $$\n    (N^2)_i = g \\left(\\beta \\left(\\frac{\\partial S}{\\partial d}\\right)_i - \\alpha \\left(\\frac{\\partial T}{\\partial d}\\right)_i\\right)\n    $$\n\n3.  **强制非负性**：以 $N^2(d)$ 作为系数的垂直模态问题通常被表述为 Sturm-Liouville 特征值问题。为了使该问题适定，系数 $N^2(d)$ 必须处处非负。在物理上，$N^2  0$ 对应于静态不稳定的水柱，其中会发生对流，使得线性稳定性模型失效。为了继续进行线性分析，通过将计算出的 $N^2$ 值裁剪到一个小的正下限值 $N^2_{\\mathrm{min}} = 10^{-6}\\,\\mathrm{s^{-2}}$ 来对这些不稳定区域进行数值正则化。\n    $$\n    (N^2_{\\text{clipped}})_i = \\max\\left((N^2)_i, N^2_{\\mathrm{min}}\\right)\n    $$\n    此步骤确保了模态分析具有物理和数学上稳定的背景状态。\n\n4.  **光滑、保形的插值**：离散的、经过裁剪的剖面 $(N^2_{\\text{clipped}})_i$ 必须转换为一个可以在任何深度进行求值的连续函数 $\\widehat{N^2}(d)$。标准的三次样条插值可能会在网格点之间引入虚假的振荡（过冲），这可能违反非负性约束。指定使用分段三次埃尔米特插值多项式 (PCHIP) 是因为它具有保形性。它能保持所提供数据点的单调性，确保如果离散数据是非负的，那么插值函数在点之间也同样是非负的。这会产生一个光滑的函数 $\\widehat{N^2}(d)$，它能准确反映物理分层而不会引入数值伪影。然后，该函数用于在每个测试用例的指定查询深度上评估 $N^2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Computes and prepares the squared buoyancy frequency profile N^2(d)\n    for several test cases, following the algorithm specified in the problem.\n    \"\"\"\n    # Define physical constants.\n    g = 9.81  # Gravitational acceleration in m/s^2\n    alpha = 2.0e-4  # Thermal expansion coefficient in K^-1\n    beta = 7.6e-4  # Haline contraction coefficient in (PSU)^-1\n    N2_min = 1.0e-6  # Minimum floor for N^2 in s^-2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"d_range\": (0.0, 1000.0),\n            \"N_points\": 501,\n            \"T_func\": lambda d: 20.0 - 15.0 * np.tanh((d - 200.0) / 150.0),\n            \"S_func\": lambda d: 34.5 + 0.5 * np.tanh((d - 300.0) / 200.0),\n            \"query_depths\": [0.0, 100.0, 250.0, 500.0, 1000.0],\n        },\n        {\n            \"d_range\": (0.0, 1000.0),\n            \"N_points\": 501,\n            \"T_func\": lambda d: np.full_like(d, 10.0),\n            \"S_func\": lambda d: np.full_like(d, 35.0),\n            \"query_depths\": [0.0, 100.0, 250.0, 500.0, 1000.0],\n        },\n        {\n            \"d_range\": (0.0, 1000.0),\n            \"N_points\": 501,\n            \"T_func\": lambda d: 14.0 + 0.5 * np.sin(2.0 * np.pi * d / 120.0) - 11.0 * d / 1000.0,\n            \"S_func\": lambda d: 34.8 + 0.2 * np.cos(2.0 * np.pi * d / 180.0) + 0.1 * d / 1000.0,\n            \"query_depths\": [0.0, 100.0, 250.0, 500.0, 1000.0],\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Generate the depth grid and corresponding T/S profiles.\n        d_grid = np.linspace(case[\"d_range\"][0], case[\"d_range\"][1], case[\"N_points\"])\n        T_profile = case[\"T_func\"](d_grid)\n        S_profile = case[\"S_func\"](d_grid)\n        \n        # Calculate grid spacing for finite differences.\n        h = d_grid[1] - d_grid[0]\n\n        # Step 1: Compute discrete vertical gradients using second-order accurate differences.\n        # np.gradient with edge_order=2 uses second-order central differences for the interior\n        # and second-order one-sided differences for the boundaries.\n        dT_dd = np.gradient(T_profile, h, edge_order=2)\n        dS_dd = np.gradient(S_profile, h, edge_order=2)\n\n        # Step 2: Compute N^2(d) via the linearized formula.\n        N2_profile = g * (beta * dS_dd - alpha * dT_dd)\n\n        # Step 3: Enforce non-negativity by clipping to a minimum floor.\n        N2_clipped = np.maximum(N2_profile, N2_min)\n\n        # Step 4: Construct a smooth, shape-preserving interpolant (PCHIP).\n        pchip_N2 = PchipInterpolator(d_grid, N2_clipped)\n        \n        # Evaluate the prepared function at the specified query depths.\n        query_depths = np.array(case[\"query_depths\"])\n        N2_interpolated = pchip_N2(query_depths)\n        \n        # Format results for the current case into a string list.\n        # The format must use scientific notation with at least 6 decimal digits.\n        case_results_str = [f\"{val:.7e}\" for val in N2_interpolated]\n        all_results.append(f\"[{','.join(case_results_str)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了模态理论并具备了计算层结参数的能力后，最终的目标是将这些工具应用于实际观测数据的分析中。这项实践模拟了一个完整的数据分析流程：给定一组垂直模态基函数和观测到的海流剖面，如何确定每个模态所占的比重？ 本练习将介绍如何使用广义最小二乘法（Generalized Least Squares）来稳健地估计这些模态系数，并对估计结果进行至关重要的不确定性量化。",
            "id": "3785951",
            "problem": "给定海洋中一个在离散深度上表示的垂向分辨水平流剖面，以及一组旨在近似正压和斜压模态的标准正交垂向结构函数。任务是设计并实现一个有理论依据的计算程序，以使用最小二乘法估计模态系数，并在指定的测量噪声假设下量化这些估计的不确定性。\n\n从以下基本原理开始：\n- 水平速度的垂向模态分解定义为 $u(z) = \\sum_{n=0}^{N-1} a_n \\phi_n(z)$，其中 $a_n$ 是模态系数，$\\phi_n(z)$ 是垂向结构函数，$N$ 是模态数。正压模态对应于 $n=0$，斜压模态对应于 $n \\ge 1$。\n- 测量模型为 $u_i^{\\mathrm{obs}} = u(z_i) + \\varepsilon_i$，其中 $z_i$ 是深度，$u_i^{\\mathrm{obs}}$ 是在深度 $z_i$ 观测到的速度，$\\varepsilon$ 是协方差矩阵为 $\\mathbf{C}$ 的零均值高斯噪声。\n- 广义最小二乘法（GLS）估计通过最小化由噪声协方差的逆加权的残差二次型来实现。\n\n在区间 $[-H,0]$ 上，使用标准 $L^2$ 内积定义一个完备标准正交基作为垂向结构函数。具体来说，通过 $x = 2(z+H)/H - 1$ 将 $z \\in [-H,0]$ 映射到 $x \\in [-1,1]$，并令 $\\phi_n(z) = \\sqrt{(2n+1)/H}\\,P_n(x)$，其中 $P_n(x)$ 是 $n$ 次勒让德多项式。这一选择确保了标准正交性，即 $\\int_{-H}^0 \\phi_n(z)\\phi_m(z)dz = \\delta_{nm}$。\n\n从第一性原理出发：\n- 将离散观测模型表示为 $\\mathbf{u}^{\\mathrm{obs}} = \\mathbf{\\Phi}\\mathbf{a} + \\boldsymbol{\\varepsilon}$，其中 $\\mathbf{u}^{\\mathrm{obs}} \\in \\mathbb{R}^M$，$\\mathbf{a} \\in \\mathbb{R}^N$，设计矩阵 $\\mathbf{\\Phi} \\in \\mathbb{R}^{M \\times N}$ 的元素为 $\\Phi_{i,n} = \\phi_n(z_i)$。\n- 通过最小化加权二次误差推导出 GLS 估计量 $\\hat{\\mathbf{a}}$，并利用高斯噪声假设推导出估计量的协方差。不要使用任何快捷公式；需推导出正规方程。\n\n使用以下步骤实现估计器和不确定性量化算法：\n- 根据给定的深度和 $\\phi_n(z)$ 的定义构建 $\\mathbf{\\Phi}$。\n- 根据每个测试用例的指定构建噪声协方差矩阵 $\\mathbf{C}$。\n- 使用数值稳定的方法求解正规方程以得到 $\\hat{\\mathbf{a}}$，并计算估计量协方差矩阵。\n- 通过检查正规矩阵是否满秩来报告可解性条件。\n- 计算 $\\hat{\\mathbf{a}}$ 与提供的真实值 $\\mathbf{a}^{\\mathrm{true}}$ 之间的均方根误差 (RMSE) 以进行验证。\n\n物理单位和输出要求：\n- 速度 $u$ 和模态系数 $a_n$ 必须以米/秒 (m/s) 表示。\n- 深度 $z$ 和深度尺度 $H$ 必须以米 (m) 表示。\n- 所有报告的 RMSE 和不确定度必须以米/秒 (m/s) 表示，并四舍五入到六位小数。\n\n测试套件：\n为以下四个测试用例实现该程序。对于所有用例，确定性地构建观测剖面为 $\\mathbf{u}^{\\mathrm{obs}} = \\mathbf{\\Phi}\\mathbf{a}^{\\mathrm{true}}$（即，不添加噪声实现），并仅使用噪声协方差来计算 GLS 权重和估计器不确定度。\n\n- 用例 A（常规，采样良好）：\n  - $H = 4000\\,\\mathrm{m}$，$N = 4$，$M = 81$，深度 $z_i$ 在 $-H$ 到 $0$ 之间等距分布。\n  - 噪声协方差是对角阵，$\\sigma = 0.020\\,\\mathrm{m/s}$，因此 $\\mathbf{C} = \\sigma^2 \\mathbf{I}$。\n  - 真实系数 $\\mathbf{a}^{\\mathrm{true}} = [0.25, -0.12, 0.08, 0.00]$，单位为 $\\mathrm{m/s}$。\n\n- 用例 B（边界采样：最少层数）：\n  - $H = 3000\\,\\mathrm{m}$，$N = 3$，$M = 3$，深度 $z_i = [-H, -H/2, 0]$。\n  - 噪声协方差是对角阵，$\\sigma = 0.005\\,\\mathrm{m/s}$，即 $\\mathbf{C} = \\sigma^2 \\mathbf{I}$。\n  - 真实系数 $\\mathbf{a}^{\\mathrm{true}} = [0.20, 0.00, -0.10]$，单位为 $\\mathrm{m/s}$。\n\n- 用例 C（异方差噪声和非均匀深度）：\n  - $H = 5000\\,\\mathrm{m}$，$N = 5$，$M = 50$，深度 $z_i$ 非均匀分布：$z_i = -H\\left(1 - \\left(\\frac{i}{M-1}\\right)^2\\right)$，对于 $i = 0, 1, \\dots, M-1$。\n  - 噪声协方差是对角阵，标准差为 $\\sigma_i = 0.010 + 0.0003\\,i$，单位为 $\\mathrm{m/s}$，因此 $C_{ii} = \\sigma_i^2$ 且当 $i \\ne j$ 时 $C_{ij} = 0$。\n  - 真实系数 $\\mathbf{a}^{\\mathrm{true}} = [0.10, -0.05, 0.02, 0.00, 0.01]$，单位为 $\\mathrm{m/s}$。\n\n- 用例 D（相关噪声）：\n  - $H = 4000\\,\\mathrm{m}$，$N = 3$，$M = 40$，深度 $z_i$ 在 $-H$ 到 $0$ 之间等距分布。\n  - 噪声协方差具有相关性 $C_{ij} = \\sigma^2 \\rho^{|i-j|}$，其中 $\\sigma = 0.020\\,\\mathrm{m/s}$，$\\rho = 0.60$。\n  - 真实系数 $\\mathbf{a}^{\\mathrm{true}} = [-0.15, 0.05, 0.02]$，单位为 $\\mathrm{m/s}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是 $[\\text{solvable}, \\text{rmse}, [\\text{unc}_0, \\dots, \\text{unc}_{N-1}]]$ 形式的列表，其中 $\\text{solvable}$ 是一个布尔值，表示正规矩阵是否满秩，$\\text{rmse}$ 是以 $\\mathrm{m/s}$ 为单位的均方根误差，四舍五入到六位小数，每个 $\\text{unc}_n$ 是 $\\hat{a}_n$ 的标准差，以 $\\mathrm{m/s}$ 为单位，四舍五入到六位小数。因此，总输出是一个单一的嵌套列表，如 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。",
            "solution": "我们从垂向模态分解 $u(z) = \\sum_{n=0}^{N-1} a_n \\phi_n(z)$ 开始，其中 $\\phi_n(z)$ 在深度 $z \\in [-H,0]$ 上关于标准内积是标准正交的，即 $\\int_{-H}^{0} \\phi_n(z)\\phi_m(z)dz = \\delta_{nm}$。在正压和斜压模态分解框架中，$n=0$ 表示正压模态（与深度无关），$n \\ge 1$ 表示斜压模态（随深度变化）。\n\n观测在离散深度 $z_i$（$i=1,\\dots,M$）进行，遵循测量模型 $u_i^{\\mathrm{obs}} = u(z_i) + \\varepsilon_i$，其中 $\\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{C})$ 且 $\\mathbf{C} \\in \\mathbb{R}^{M \\times M}$ 是正定矩阵。用矩阵形式表示为\n$$\n\\mathbf{u}^{\\mathrm{obs}} = \\mathbf{\\Phi}\\mathbf{a} + \\boldsymbol{\\varepsilon},\n$$\n其中 $\\mathbf{u}^{\\mathrm{obs}} \\in \\mathbb{R}^M$ 汇集了 $u_i^{\\mathrm{obs}}$，$\\mathbf{a} \\in \\mathbb{R}^N$ 汇集了系数 $a_n$，而 $\\mathbf{\\Phi} \\in \\mathbb{R}^{M \\times N}$ 是设计矩阵，其元素为 $\\Phi_{i,n} = \\phi_n(z_i)$。\n\n广义最小二乘法 (GLS) 源于最小化加权残差范数：\n$$\nJ(\\mathbf{a}) = \\left(\\mathbf{u}^{\\mathrm{obs}} - \\mathbf{\\Phi}\\mathbf{a}\\right)^{\\!\\top} \\mathbf{C}^{-1} \\left(\\mathbf{u}^{\\mathrm{obs}} - \\mathbf{\\Phi}\\mathbf{a}\\right).\n$$\n对 $\\mathbf{a}$ 求梯度并令其为零：\n$$\n\\nabla_{\\mathbf{a}} J = -2\\mathbf{\\Phi}^{\\top}\\mathbf{C}^{-1} \\left(\\mathbf{u}^{\\mathrm{obs}} - \\mathbf{\\Phi}\\mathbf{a}\\right) = \\mathbf{0}.\n$$\n这得到正规方程\n$$\n\\mathbf{A}\\hat{\\mathbf{a}} = \\mathbf{b}, \\quad \\text{其中} \\quad \\mathbf{A} = \\mathbf{\\Phi}^{\\top}\\mathbf{C}^{-1}\\mathbf{\\Phi}, \\quad \\mathbf{b} = \\mathbf{\\Phi}^{\\top}\\mathbf{C}^{-1}\\mathbf{u}^{\\mathrm{obs}}.\n$$\n假设 $\\mathbf{A}$ 是满秩的（即秩为 $N$），则 GLS 估计是唯一的\n$$\n\\hat{\\mathbf{a}} = \\mathbf{A}^{-1}\\mathbf{b}.\n$$\n在高斯噪声假设下，估计器的不确定性由 $\\hat{\\mathbf{a}}$ 的协方差量化：\n$$\n\\mathrm{Cov}(\\hat{\\mathbf{a}}) = \\left(\\mathbf{\\Phi}^{\\top}\\mathbf{C}^{-1}\\mathbf{\\Phi}\\right)^{-1} = \\mathbf{A}^{-1}.\n$$\n系数的标准差则为 $\\sigma_{\\hat{a}_n} = \\sqrt{\\left[\\mathrm{diag}\\left(\\mathrm{Cov}(\\hat{\\mathbf{a}})\\right)\\right]_n}$。\n\n关于垂向结构函数，我们选择在 $[-H,0]$ 上的一个标准正交集，使用 $[-1,1]$ 上的勒让德多项式 $P_n(x)$，通过 $x = 2(z+H)/H - 1$ 进行映射。定义\n$$\n\\phi_n(z) = \\sqrt{\\frac{2n+1}{H}}P_n\\!\\left(2\\frac{z+H}{H} - 1\\right).\n$$\n为验证其标准正交性，注意 $dz = \\frac{H}{2} dx$，且勒让德多项式满足 $\\int_{-1}^{1} P_n(x)P_m(x)dx = \\frac{2}{2n+1}\\delta_{nm}$。因此\n$$\n\\int_{-H}^{0} \\phi_n(z)\\phi_m(z)dz = \\int_{-1}^{1} \\sqrt{\\frac{2n+1}{H}}P_n(x)\\sqrt{\\frac{2m+1}{H}}P_m(x)\\frac{H}{2}dx = \\delta_{nm}.\n$$\n这种构造近似了正压和斜压模态：$n=0$ 产生常数正压模态 $\\phi_0(z) = \\sqrt{1/H}$，而 $n\\ge 1$ 产生垂向变化（斜压模态）。\n\n算法设计：\n- 对于每个深度 $z_i$ 和 $n=0,\\dots,N-1$，计算 $\\phi_n(z_i)$ 来构建 $\\mathbf{\\Phi}$。\n- 根据噪声模型构建 $\\mathbf{C}$。对于对角（独立）噪声，设置 $C_{ii} = \\sigma_i^2$。对于相关噪声，设置 $C_{ij} = \\sigma^2 \\rho^{|i-j|}$。\n- 为避免显式地对 $\\mathbf{C}$ 求逆，计算 $\\mathbf{A} = \\mathbf{\\Phi}^{\\top}\\mathbf{X}$ 和 $\\mathbf{b} = \\mathbf{\\Phi}^{\\top}\\mathbf{y}$，其中 $\\mathbf{X}$ 通过求解 $\\mathbf{C}\\mathbf{X} = \\mathbf{\\Phi}$ 得到，$\\mathbf{y}$ 通过求解 $\\mathbf{C}\\mathbf{y} = \\mathbf{u}^{\\mathrm{obs}}$ 得到。这使用线性求解以保证数值稳定性。\n- 使用直接求解器求解 $\\mathbf{A}\\hat{\\mathbf{a}} = \\mathbf{b}$。如果 $\\mathbf{A}$ 是秩亏的，使用伪逆 $\\mathbf{A}^{+}$ 计算最小范数解，并设置 $\\mathrm{Cov}(\\hat{\\mathbf{a}}) = \\mathbf{A}^{+}$ 作为不确定性的代理。\n- 通过验证 $\\mathrm{rank}(\\mathbf{A}) = N$ 来检查可解性。\n- 计算 $\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} \\left(\\hat{a}_n - a_n^{\\mathrm{true}}\\right)^2}$。\n- 报告标准差 $\\sigma_{\\hat{a}_n} = \\sqrt{\\left[\\mathrm{diag}\\left(\\mathrm{Cov}(\\hat{\\mathbf{a}})\\right)\\right]_n}$。\n\n测试套件执行细节：\n- 对每个用例（A–D），按规定设置深度和 $H$，构建 $\\mathbf{\\Phi}$，根据噪声模型设置 $\\mathbf{C}$，设置 $\\mathbf{a}^{\\mathrm{true}}$，并确定性地计算 $\\mathbf{u}^{\\mathrm{obs}} = \\mathbf{\\Phi}\\mathbf{a}^{\\mathrm{true}}$。\n- 计算 $\\hat{\\mathbf{a}}$、$\\mathrm{Cov}(\\hat{\\mathbf{a}})$、可解性、$\\mathrm{RMSE}$ 和不确定度。\n- 将所有用例的结果以单一嵌套列表的形式在一行中输出。所有 RMSE 和不确定度必须四舍五入到六位小数，并以 $\\mathrm{m/s}$ 为单位表示。\n\n这种方法测试了针对正压/斜压模态分解的 GLS 的推导和实现，标准正交基对正规矩阵的影响，采样和噪声模型对可解性的影响，以及通过估计量协方差进行的严格不确定性量化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef legendre_val(n, x):\n    \"\"\"\n    Evaluate the Legendre polynomial P_n(x) using numpy.polynomial.legendre.legval.\n    \"\"\"\n    c = np.zeros(n + 1)\n    c[n] = 1.0\n    return np.polynomial.legendre.legval(x, c)\n\ndef modes_matrix(z, H, N_modes):\n    \"\"\"\n    Construct the design matrix Phi with entries Phi[i, n] = phi_n(z_i),\n    where phi_n are orthonormal vertical structure functions built from Legendre polynomials.\n    \"\"\"\n    z = np.asarray(z)\n    x = 2.0 * (z + H) / H - 1.0  # Map z in [-H,0] to x in [-1,1]\n    M = z.size\n    Phi = np.zeros((M, N_modes))\n    for n in range(N_modes):\n        Pn = legendre_val(n, x)\n        Phi[:, n] = np.sqrt((2*n + 1) / H) * Pn\n    return Phi\n\ndef left_solve(C, B):\n    \"\"\"\n    Solve C X = B for X without forming C^{-1}.\n    \"\"\"\n    return np.linalg.solve(C, B)\n\ndef gls_estimate(Phi, C, u_obs):\n    \"\"\"\n    Compute the generalized least squares estimate for a, its covariance, and solvability.\n    Returns (a_hat, cov_a, solvable_boolean).\n    \"\"\"\n    # Compute A = Phi^T C^{-1} Phi and b = Phi^T C^{-1} u_obs via linear solves\n    X = left_solve(C, Phi)\n    y = left_solve(C, u_obs)\n    A = Phi.T @ X\n    b = Phi.T @ y\n\n    # Check rank\n    rank_A = np.linalg.matrix_rank(A)\n    N = Phi.shape[1]\n    solvable = (rank_A == N)\n\n    # Solve for a_hat\n    if solvable:\n        a_hat = np.linalg.solve(A, b)\n        cov_a = np.linalg.inv(A)\n    else:\n        # Use pseudo-inverse for minimum-norm solution and uncertainty proxy\n        A_pinv = np.linalg.pinv(A)\n        a_hat = A_pinv @ b\n        cov_a = A_pinv\n\n    return a_hat, cov_a, solvable\n\ndef rmse(a_hat, a_true):\n    diff = a_hat - a_true\n    return float(np.sqrt(np.mean(diff**2)))\n\ndef build_covariance_diagonal(sigmas):\n    sigmas = np.asarray(sigmas)\n    return np.diag(sigmas**2)\n\ndef build_covariance_ar1(sigma, rho, M):\n    \"\"\"\n    Build AR(1)-like covariance: C_ij = sigma^2 * rho^{|i-j|}.\n    \"\"\"\n    idx = np.arange(M)\n    C = sigma**2 * rho**(np.abs(idx[:, None] - idx[None, :]))\n    return C\n\ndef case_A():\n    # Parameters\n    H = 4000.0  # m\n    N = 4\n    M = 81\n    z = np.linspace(-H, 0.0, M)\n    sigma = 0.020  # m/s\n    a_true = np.array([0.25, -0.12, 0.08, 0.00])  # m/s\n\n    Phi = modes_matrix(z, H, N)\n    C = build_covariance_diagonal(np.full(M, sigma))\n    u_obs = Phi @ a_true\n\n    a_hat, cov_a, solvable = gls_estimate(Phi, C, u_obs)\n    rms = rmse(a_hat, a_true)\n    uncertainties = np.sqrt(np.diag(cov_a))\n    return solvable, rms, uncertainties.tolist()\n\ndef case_B():\n    H = 3000.0  # m\n    N = 3\n    z = np.array([-H, -H/2.0, 0.0])\n    M = z.size\n    sigma = 0.005  # m/s\n    a_true = np.array([0.20, 0.00, -0.10])  # m/s\n\n    Phi = modes_matrix(z, H, N)\n    C = build_covariance_diagonal(np.full(M, sigma))\n    u_obs = Phi @ a_true\n\n    a_hat, cov_a, solvable = gls_estimate(Phi, C, u_obs)\n    rms = rmse(a_hat, a_true)\n    uncertainties = np.sqrt(np.diag(cov_a))\n    return solvable, rms, uncertainties.tolist()\n\ndef case_C():\n    H = 5000.0  # m\n    N = 5\n    M = 50\n    i = np.arange(M)\n    z = -H * (1.0 - (i / (M - 1))**2)  # nonuniform depths from -H to 0\n    sigmas = 0.010 + 0.0003 * i  # m/s\n    a_true = np.array([0.10, -0.05, 0.02, 0.00, 0.01])  # m/s\n\n    Phi = modes_matrix(z, H, N)\n    C = build_covariance_diagonal(sigmas)\n    u_obs = Phi @ a_true\n\n    a_hat, cov_a, solvable = gls_estimate(Phi, C, u_obs)\n    rms = rmse(a_hat, a_true)\n    uncertainties = np.sqrt(np.diag(cov_a))\n    return solvable, rms, uncertainties.tolist()\n\ndef case_D():\n    H = 4000.0  # m\n    N = 3\n    M = 40\n    z = np.linspace(-H, 0.0, M)\n    sigma = 0.020  # m/s\n    rho = 0.60\n    a_true = np.array([-0.15, 0.05, 0.02])  # m/s\n\n    Phi = modes_matrix(z, H, N)\n    C = build_covariance_ar1(sigma, rho, M)\n    u_obs = Phi @ a_true\n\n    a_hat, cov_a, solvable = gls_estimate(Phi, C, u_obs)\n    rms = rmse(a_hat, a_true)\n    uncertainties = np.sqrt(np.diag(cov_a))\n    return solvable, rms, uncertainties.tolist()\n\ndef round_list(lst, decimals=6):\n    return [round(x, decimals) for x in lst]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    cases = [case_A, case_B, case_C, case_D]\n\n    results = []\n    for case_func in cases:\n        solvable, rms, unc = case_func()\n        # Round RMSE and uncertainties to six decimals\n        rms_rounded = round(rms, 6)\n        unc_rounded = round_list(unc, 6)\n        results.append([solvable, rms_rounded, unc_rounded])\n\n    # Final print statement in the exact required format.\n    print(str(results))\n\nsolve()\n```"
        }
    ]
}