{
    "hands_on_practices": [
        {
            "introduction": "为了开始我们的实践探索，我们首先使用一个简化但功能强大的双层海洋模型来检验内波的基本物理特性。这项练习剥离了复杂性，以揭示由内界面上的密度差异驱动的第一斜压模态的核心机制。通过推导这些内波的相速度 $c_1$，您将具体理解分层（以约化重力表示）如何控制斜压信号的缓慢传播，这是其与快速正压信号的关键区别。",
            "id": "3785901",
            "problem": "考虑一个在布辛涅斯克近似下的无粘性、静水的双层海洋，其水平范围无限大，上层厚度为 $H_1$，下层厚度为 $H_2$，上层密度为 $\\rho_1$，下层密度为 $\\rho_2$，其中 $\\rho_2 > \\rho_1$。设平均自由表面由刚盖近似固定，内界面位移为 $\\eta(x,y,t)$，从其平均位置向上为正。假设为长波（水平尺度远大于垂直尺度），忽略行星旋转和任何外部强迫，并考虑小振幅运动，因此线性化有效。折减重力定义为 $g' = g(\\rho_2 - \\rho_1)/\\rho_0$，其中 $g$ 是重力加速度，$\\rho_0$ 是布辛涅斯克近似下的一个代表性常数密度。\n\n从分层的线性化浅水动量和连续性方程出发，推导第一斜压模的长波相速度 $c_1$ 关于 $g'$, $H_1$ 和 $H_2$ 的闭合形式解析表达式。然后，在 $H_1 = 500\\,\\text{m}$，$H_2 = 3500\\,\\text{m}$ 和 $g' = 0.02\\,\\text{m}\\,\\text{s}^{-2}$ 的条件下计算 $c_1$ 的值。将你最终的速度数值答案以米/秒为单位表示，并将结果四舍五入到四位有效数字。你的最终答案必须是一个实数。",
            "solution": "### 求解推导\n\n我们从双层流体的线性化、静水、布辛涅斯克方程开始，忽略旋转和强迫。设 $\\mathbf{u}_1 = (u_1, v_1)$ 和 $\\mathbf{u}_2 = (u_2, v_2)$ 分别是上层和下层中与深度无关的水平速度。水平坐标为 $\\mathbf{x} = (x,y)$。\n\n每个分层的水平动量方程为：\n$$ \\frac{\\partial \\mathbf{u}_1}{\\partial t} = -\\frac{1}{\\rho_0} \\nabla_H p_1 $$\n$$ \\frac{\\partial \\mathbf{u}_2}{\\partial t} = -\\frac{1}{\\rho_0} \\nabla_H p_2 $$\n其中 $p_1$ 和 $p_2$ 分别是各层中的压力，$\\nabla_H = (\\frac{\\partial}{\\partial x}, \\frac{\\partial}{\\partial y})$ 是水平梯度算子。\n\n刚盖近似将表面高度设为零，但允许在盖处存在压力异常，我们可以将其写为驱动正压响应的底部压力异常 $p_b(x,y,t)$。在静水近似下，每层内的压力梯度可以与界面位移 $\\eta$ 相关联。水平压力梯度为：\n$$ \\nabla_H p_1 = \\nabla_H p_b - (\\rho_2 - \\rho_1)g \\nabla_H \\eta $$\n$$ \\nabla_H p_2 = \\nabla_H p_b $$\n\n将这些代入动量方程，并使用布辛涅斯克近似（$\\rho_1 \\approx \\rho_2 \\approx \\rho_0$）和折减重力 $g' = g(\\rho_2 - \\rho_1)/\\rho_0$ 的定义，我们得到：\n$$ (1) \\quad \\frac{\\partial \\mathbf{u}_1}{\\partial t} = -\\frac{1}{\\rho_0}\\nabla_H p_b + g' \\nabla_H \\eta $$\n$$ (2) \\quad \\frac{\\partial \\mathbf{u}_2}{\\partial t} = -\\frac{1}{\\rho_0}\\nabla_H p_b $$\n\n每个分层的线性化连续性方程描述了层厚的改变如何由速度的水平辐散来平衡。对于上层，厚度变化为 $-\\partial\\eta/\\partial t$，对于下层，厚度变化为 $\\partial\\eta/\\partial t$。这导致：\n$$ H_1 \\nabla_H \\cdot \\mathbf{u}_1 = \\frac{\\partial \\eta}{\\partial t} $$\n$$ H_2 \\nabla_H \\cdot \\mathbf{u}_2 = -\\frac{\\partial \\eta}{\\partial t} $$\n\n为了分离斜压模，我们消去正压压力梯度项 $\\nabla_H p_b$。我们将方程 $(2)$ 从方程 $(1)$ 中减去：\n$$ \\frac{\\partial}{\\partial t}(\\mathbf{u}_1 - \\mathbf{u}_2) = g' \\nabla_H \\eta $$\n这个方程将垂直速度切变与内界面的斜率联系起来。这是斜压动力学的本质。\n\n现在，我们对这个切变方程取水平辐散：\n$$ (5) \\quad \\frac{\\partial}{\\partial t} \\nabla_H \\cdot (\\mathbf{u}_1 - \\mathbf{u}_2) = g' \\nabla_H^2 \\eta $$\n其中 $\\nabla_H^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ 是水平拉普拉斯算子。\n\n从连续性方程，我们可以用 $\\eta$ 表示速度辐散：\n$$ \\nabla_H \\cdot \\mathbf{u}_1 = \\frac{1}{H_1} \\frac{\\partial \\eta}{\\partial t} $$\n$$ \\nabla_H \\cdot \\mathbf{u}_2 = -\\frac{1}{H_2} \\frac{\\partial \\eta}{\\partial t} $$\n将这些表达式代入方程 $(5)$：\n$$ \\frac{\\partial}{\\partial t} \\left( \\frac{1}{H_1} \\frac{\\partial \\eta}{\\partial t} - \\left(-\\frac{1}{H_2} \\frac{\\partial \\eta}{\\partial t}\\right) \\right) = g' \\nabla_H^2 \\eta $$\n$$ \\frac{\\partial}{\\partial t} \\left( \\left(\\frac{1}{H_1} + \\frac{1}{H_2}\\right) \\frac{\\partial \\eta}{\\partial t} \\right) = g' \\nabla_H^2 \\eta $$\n$$ \\left(\\frac{1}{H_1} + \\frac{1}{H_2}\\right) \\frac{\\partial^2 \\eta}{\\partial t^2} = g' \\nabla_H^2 \\eta $$\n合并括号中的项：\n$$ \\left(\\frac{H_1 + H_2}{H_1 H_2}\\right) \\frac{\\partial^2 \\eta}{\\partial t^2} = g' \\nabla_H^2 \\eta $$\n将其重新排列成标准波动方程形式 $\\frac{\\partial^2 \\eta}{\\partial t^2} = c^2 \\nabla_H^2 \\eta$：\n$$ \\frac{\\partial^2 \\eta}{\\partial t^2} = g' \\frac{H_1 H_2}{H_1 + H_2} \\nabla_H^2 \\eta $$\n通过比较，第一斜压模相速度 $c_1$ 的平方是：\n$$ c_1^2 = g' \\frac{H_1 H_2}{H_1 + H_2} $$\n因此，相速度的解析表达式为：\n$$ c_1 = \\sqrt{g' \\frac{H_1 H_2}{H_1 + H_2}} $$\n\n### 数值计算\n现在，我们使用给定的值计算 $c_1$：\n- $H_1 = 500\\,\\text{m}$\n- $H_2 = 3500\\,\\text{m}$\n- $g' = 0.02\\,\\text{m}\\,\\text{s}^{-2}$\n\n首先，我们计算通常称为第一斜压模的“等效深度”的项，$H_{eq} = \\frac{H_1 H_2}{H_1 + H_2}$：\n$$ H_{eq} = \\frac{(500)(3500)}{500 + 3500} = \\frac{1750000}{4000} = \\frac{1750}{4} = 437.5\\,\\text{m} $$\n接下来，我们计算 $c_1^2$：\n$$ c_1^2 = g' H_{eq} = (0.02\\,\\text{m}\\,\\text{s}^{-2})(437.5\\,\\text{m}) = 8.75\\,\\text{m}^2\\,\\text{s}^{-2} $$\n最后，我们取平方根求得 $c_1$：\n$$ c_1 = \\sqrt{8.75}\\,\\text{m}\\,\\text{s}^{-1} \\approx 2.95803989\\,\\text{m}\\,\\text{s}^{-1} $$\n问题要求答案四舍五入到四位有效数字。\n$$ c_1 \\approx 2.958\\,\\text{m}\\,\\text{s}^{-1} $$\n最终的数值答案是 $2.958$。",
            "answer": "$$\\boxed{2.958}$$"
        },
        {
            "introduction": "从理想化的双层模型出发，我们的下一个实践将处理真实海洋连续分层的复杂性。这个计算练习将指导您处理原始的温度和盐度剖面，以计算浮力频率的平方 $N^2(z)$，这是一个决定所有斜压模态垂直结构的基本参数。这项实践是连接观测与理论的重要桥梁，展示了进行任何高级模态分析或数值模拟所必需的关键数据准备步骤。",
            "id": "3799111",
            "problem": "给定一个海洋水柱的温度和盐度随深度变化的离散垂直剖面。目标是使用一个在Boussinesq近似和静力平衡近似下物理上自洽的海水状态方程，计算浮力频率的平方 $N^2(z)$，然后准备一个光滑、非负的函数 $N^2(z)$，以适用于正压和斜压运动的垂直模态分解的输入。推导必须从第一性原理开始，程序必须相应地实现该算法。\n\n假设采用以下广泛使用的近似：\n- 具有恒定参考密度 $\\rho_0$ 的Boussinesq近似。\n- 静力平衡和小振幅扰动，它们是线性稳定性度量 $N^2$ 的理论基础。\n- 线性化海水状态方程：$\\rho(T,S) = \\rho_0 \\left(1 - \\alpha \\left(T - T_{\\mathrm{ref}}\\right) + \\beta \\left(S - S_{\\mathrm{ref}}\\right)\\right)$，其中 $\\alpha$ 是热膨胀系数，$\\beta$ 是盐收缩系数，$T$ 是以摄氏度为单位的位温，$S$ 是以无量纲的实用盐度单位（PSU）表示的实用盐度。参考值 $T_{\\mathrm{ref}}$ 和 $S_{\\mathrm{ref}}$ 是常数，在垂直微分中会被抵消，不影响 $N^2$。\n\n使用以下标准常数：\n- 重力加速度 $g = 9.81$，单位为 $\\mathrm{m\\,s^{-2}}$。\n- 热膨胀系数 $\\alpha = 2.0 \\times 10^{-4}$，单位为 $\\mathrm{K^{-1}}$。\n- 盐收缩系数 $\\beta = 7.6 \\times 10^{-4}$，单位为 $\\mathrm{(PSU)^{-1}}$。\n- 参考密度 $\\rho_0$ 是一个常数（其确切数值在下文 $N^2$ 的线性化公式中被抵消，因此在数值计算中不需要）。\n\n设深度 $d$ 以米为单位，向下为正，在自由表面处 $d = 0$。设 $T(d)$ 和 $S(d)$ 是在跨越 $[0,1000]$ 米的离散网格 $\\{d_i\\}_{i=0}^{N-1}$ 上采样的给定剖面。从第一性原理出发，当垂直坐标 $z$ 指向上时，浮力频率的平方定义为\n$$\nN^2(z) = -\\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial z}.\n$$\n当深度坐标 $d$ 向下为正时，链式法则给出\n$$\n\\frac{\\partial}{\\partial z} = -\\frac{\\partial}{\\partial d},\n$$\n并使用线性化海水状态方程，密度对深度的垂直导数为\n$$\n\\frac{\\partial \\rho}{\\partial d} = \\rho_0\\left(-\\alpha\\, \\frac{\\partial T}{\\partial d} + \\beta\\, \\frac{\\partial S}{\\partial d}\\right).\n$$\n因此，\n$$\nN^2(d) = \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial d} = g\\left(\\beta\\, \\frac{\\partial S}{\\partial d} - \\alpha\\, \\frac{\\partial T}{\\partial d}\\right).\n$$\n\n将 $N^2(d)$ 准备成适用于垂直模态分解的函数所需的算法要求：\n1. 在给定的深度网格上，使用在内部具有二阶精度、在边界处为单边的相容有限差分法，计算离散垂直梯度 $\\frac{\\partial T}{\\partial d}$ 和 $\\frac{\\partial S}{\\partial d}$。\n2. 通过线性化公式 $N^2(d) = g\\left(\\beta\\, \\frac{\\partial S}{\\partial d} - \\alpha\\, \\frac{\\partial T}{\\partial d}\\right)$ 计算 $N^2(d)$，单位为 $\\mathrm{s^{-2}}$。\n3. 为满足 Sturm–Liouville 问题的适定性要求，通过将 $N^2(d)$ 裁剪到一个最小下限值 $N^2_{\\mathrm{min}} = 10^{-6}$（单位为 $\\mathrm{s^{-2}}$）来强制其非负性，即，设置 $N^2(d) \\leftarrow \\max\\left(N^2(d), N^2_{\\mathrm{min}}\\right)$。\n4. 使用分段三次Hermite插值多项式 (PCHIP) 构建一个光滑、保形的插值函数 $\\widehat{N^2}(d)$，以便可以在垂直模态求解器所需的任意深度上对 $\\widehat{N^2}(d)$ 进行求值，且不会产生过冲伪影。\n\n你的程序必须实现上述算法，并针对多个测试用例，在一组指定的查询深度上对准备好的函数 $\\widehat{N^2}(d)$ 进行求值。所有输出都必须以 $\\mathrm{s^{-2}}$ 为单位，使用至少包含六位小数的科学记数法表示。本问题不涉及角度。最终输出必须是单行文本，其中包含所有测试用例的汇总结果，格式为一个由方括号括起来的逗号分隔列表，每个测试用例的结果本身也是一个由方括号括起来的逗号分隔列表，例如 $[[r_{1,1},r_{1,2}],[r_{2,1},r_{2,2}]]$，不含空格。\n\n测试套件（所有 $T(d)$ 和 $S(d)$ 均以物理上合理的形式提供）：\n\n- 测试用例1（良好分层的温跃层）：\n  - 深度网格：$d_i \\in [0,1000]$ 米，$N = 501$ 个均匀间隔的点。\n  - 温度：$T(d) = 20 - 15\\, \\tanh\\left(\\dfrac{d - 200}{150}\\right)$，单位为摄氏度。\n  - 盐度：$S(d) = 34.5 + 0.5\\, \\tanh\\left(\\dfrac{d - 300}{200}\\right)$，单位为PSU。\n  - 查询深度（单位：米）：$[0,100,250,500,1000]$。\n\n- 测试用例2（近乎未分层的水柱）：\n  - 深度网格：$d_i \\in [0,1000]$ 米，$N = 501$ 个均匀间隔的点。\n  - 温度：$T(d) = 10$，单位为摄氏度。\n  - 盐度：$S(d) = 35$，单位为PSU。\n  - 查询深度（单位：米）：$[0,100,250,500,1000]$。\n\n- 测试用例3（具有微弱不稳定层和小振荡，需要裁剪）：\n  - 深度网格：$d_i \\in [0,1000]$ 米，$N = 501$ 个均匀间隔的点。\n  - 温度：$T(d) = 14 + 0.5\\, \\sin\\left(\\dfrac{2\\pi d}{120}\\right) - 11\\, \\dfrac{d}{1000}$，单位为摄氏度。\n  - 盐度：$S(d) = 34.8 + 0.2\\, \\cos\\left(\\dfrac{2\\pi d}{180}\\right) + 0.1\\, \\dfrac{d}{1000}$，单位为PSU。\n  - 查询深度（单位：米）：$[0,100,250,500,1000]$。\n\n你的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，每个测试用例的结果是对应指定查询深度下的 $\\widehat{N^2}(d)$ 值的逗号分隔列表（单位为 $\\mathrm{s^{-2}}$），采用至少六位小数的科学记数法，且不含任何空格。例如，格式必须为 $[[v_{1,1},v_{1,2},\\ldots,v_{1,5}],[v_{2,1},\\ldots,v_{2,5}],[v_{3,1},\\ldots,v_{3,5}]]$.",
            "solution": "该问题是有效的，因为它科学地基于地球物理流体动力学的原理，是适定的，有通向唯一解的清晰算法路径，并且用客观、正式的语言表述。我们开始求解。\n\n目标是从位温 $T(d)$ 和盐度 $S(d)$ 的垂直剖面计算浮力频率的平方（记为 $N^2$），其中 $d$ 是深度，向下为正。这个量对于分析分层流体柱的稳定性以及将海洋运动分解为其垂直正压和斜压模态至关重要。该过程包括从第一性原理推导 $N^2$，然后实现一个数值算法来准备一个光滑、非负的剖面，以适用于数值模型。\n\n**基于原理的推导**\n\n浮力频率的平方 $N^2$ 量化了在分层介质中垂直位移的流体包裹所受的恢复力。在稳定的分层中，一个位移的包裹会比其新环境密度更小（如果向上位移）或更大（如果向下位移），从而导致它在其平衡位置附近振荡。$N$ 代表了这种振荡的频率。\n\n当垂直坐标 $z$ 指向上方时，$N^2(z)$ 定义为：\n$$\nN^2(z) = - \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial z}\n$$\n其中 $g$ 是重力加速度，$\\rho$ 是位密度，$\\rho_0$ 是一个恒定的参考密度，与Boussinesq近似一致。该近似假设密度的变化与参考密度相比很小，除非与 $g$ 相乘。\n\n问题使用一个向下为正的深度坐标 $d$，在海面处 $d=0$。两个坐标之间的关系意味着 $\\partial/\\partial z = -\\partial/\\partial d$。将此代入 $N^2$ 的定义中可得：\n$$\nN^2(d) = \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial d}\n$$\n\n位密度 $\\rho$ 是位温 $T$ 和盐度 $S$ 的函数。提供了一个线性化的状态方程：\n$$\n\\rho(T, S) = \\rho_0 \\left(1 - \\alpha (T - T_{\\mathrm{ref}}) + \\beta (S - S_{\\mathrm{ref}})\\right)\n$$\n这里，$\\alpha$ 是热膨胀系数，$\\beta$ 是盐收缩系数，$T_{\\mathrm{ref}}$ 和 $S_{\\mathrm{ref}}$ 是恒定的参考值。为了求得垂直密度梯度，我们使用链式法则对 $\\rho$ 关于深度 $d$ 进行微分：\n$$\n\\frac{\\partial \\rho}{\\partial d} = \\frac{\\partial \\rho}{\\partial T} \\frac{\\partial T}{\\partial d} + \\frac{\\partial \\rho}{\\partial S} \\frac{\\partial S}{\\partial d}\n$$\n从线性化状态方程可知，偏导数为 $\\partial \\rho / \\partial T = -\\rho_0 \\alpha$ 和 $\\partial \\rho / \\partial S = \\rho_0 \\beta$。 将它们代入可得：\n$$\n\\frac{\\partial \\rho}{\\partial d} = \\rho_0 \\left(-\\alpha \\frac{\\partial T}{\\partial d} + \\beta \\frac{\\partial S}{\\partial d}\\right)\n$$\n\n最后，将这个密度梯度的表达式代回到 $N^2(d)$ 的公式中：\n$$\nN^2(d) = \\frac{g}{\\rho_0} \\left[ \\rho_0 \\left(-\\alpha \\frac{\\partial T}{\\partial d} + \\beta \\frac{\\partial S}{\\partial d}\\right) \\right]\n$$\n参考密度 $\\rho_0$ 被抵消，得到最终的计算公式：\n$$\nN^2(d) = g \\left(\\beta \\frac{\\partial S}{\\partial d} - \\alpha \\frac{\\partial T}{\\partial d}\\right)\n$$\n该方程表明，稳定性（$N^2 > 0$）会因盐度随深度增加（$\\partial S/\\partial d > 0$，即下方是更咸、更密的海水）和温度随深度降低（$\\partial T/\\partial d  0$，即下方是更冷、更密的海水）而增强。\n\n**数值算法设计**\n\n问题要求一个四步算法，将离散的 $T(d)$ 和 $S(d)$ 剖面转换为一个连续、光滑且非负的函数 $\\widehat{N^2}(d)$。\n\n1.  **离散梯度计算**：给定在间距为 $h = d_{i+1} - d_i$ 的均匀深度网格 $\\{d_i\\}_{i=0}^{N-1}$ 上的离散剖面 $T_i = T(d_i)$ 和 $S_i = S(d_i)$，必须对垂直梯度 $\\partial T/\\partial d$ 和 $\\partial S/\\partial d$ 进行数值近似。为保持良好精度，指定了二阶有限差分格式。对于内部点（$1 \\le i \\le N-2$），使用中心差分公式：\n    $$\n    f'(d_i) \\approx \\frac{f(d_{i+1}) - f(d_{i-1})}{2h}\n    $$\n    对于边界，需要使用二阶精度的单边公式以避免降低整体精度。在表面（$i=0$）：\n    $$\n    f'(d_0) \\approx \\frac{-3f(d_0) + 4f(d_1) - f(d_2)}{2h}\n    $$\n    在底部（$i=N-1$）：\n    $$\n    f'(d_{N-1}) \\approx \\frac{3f(d_{N-1}) - 4f(d_{N-2}) + f(d_{N-3})}{2h}\n    $$\n    这些计算产生 $(\\partial T/\\partial d)_i$ 和 $(\\partial S/\\partial d)_i$ 的离散数组。\n\n2.  **$N^2(d)$ 剖面计算**：使用计算出的梯度和给定的常数 $g = 9.81\\,\\mathrm{m\\,s^{-2}}$， $\\alpha = 2.0 \\times 10^{-4}\\,\\mathrm{K^{-1}}$，以及 $\\beta = 7.6 \\times 10^{-4}\\,\\mathrm{(PSU)^{-1}}$，通过推导出的公式在每个网格点 $d_i$ 上计算离散的浮力频率平方剖面 $(N^2)_i$：\n    $$\n    (N^2)_i = g \\left(\\beta \\left(\\frac{\\partial S}{\\partial d}\\right)_i - \\alpha \\left(\\frac{\\partial T}{\\partial d}\\right)_i\\right)\n    $$\n\n3.  **强制非负性**：使用 $N^2(d)$ 作为系数的垂直模态问题，通常被表述为 Sturm-Liouville 特征值问题。为了使该问题适定，系数 $N^2(d)$ 必须处处非负。物理上，$N^2  0$ 对应于静态不稳定的水柱，其中会发生对流，从而使线性稳定性模型失效。为了进行线性分析，通过将计算出的 $N^2$ 值裁剪到一个小的正下限值 $N^2_{\\mathrm{min}} = 10^{-6}\\,\\mathrm{s^{-2}}$，对这些不稳定区域进行数值正则化。\n    $$\n    (N^2_{\\text{clipped}})_i = \\max\\left((N^2)_i, N^2_{\\mathrm{min}}\\right)\n    $$\n    这一步确保了模态分析具有物理上和数学上稳定的背景状态。\n\n4.  **光滑、保形的插值**：离散的、经过裁剪的剖面 $(N^2_{\\text{clipped}})_i$ 必须被转换成一个可以在任何深度求值的连续函数 $\\widehat{N^2}(d)$。标准的立方样条插值可能会在网格点之间引入虚假的振荡（过冲），这可能违反非负性约束。指定使用分段三次Hermite插值多项式 (PCHIP)，因为它是保形的。它能保持所提供数据点的单调性，确保如果离散数据是非负的，插值函数在点之间也同样是非负的。这样就得到了一个光滑函数 $\\widehat{N^2}(d)$，它能准确反映物理分层，而不会引入数值伪影。然后使用此函数在每个测试用例的指定查询深度处计算 $N^2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Computes and prepares the squared buoyancy frequency profile N^2(d)\n    for several test cases, following the algorithm specified in the problem.\n    \"\"\"\n    # Define physical constants.\n    g = 9.81  # Gravitational acceleration in m/s^2\n    alpha = 2.0e-4  # Thermal expansion coefficient in K^-1\n    beta = 7.6e-4  # Haline contraction coefficient in (PSU)^-1\n    N2_min = 1.0e-6  # Minimum floor for N^2 in s^-2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"d_range\": (0.0, 1000.0),\n            \"N_points\": 501,\n            \"T_func\": lambda d: 20.0 - 15.0 * np.tanh((d - 200.0) / 150.0),\n            \"S_func\": lambda d: 34.5 + 0.5 * np.tanh((d - 300.0) / 200.0),\n            \"query_depths\": [0.0, 100.0, 250.0, 500.0, 1000.0],\n        },\n        {\n            \"d_range\": (0.0, 1000.0),\n            \"N_points\": 501,\n            \"T_func\": lambda d: np.full_like(d, 10.0),\n            \"S_func\": lambda d: np.full_like(d, 35.0),\n            \"query_depths\": [0.0, 100.0, 250.0, 500.0, 1000.0],\n        },\n        {\n            \"d_range\": (0.0, 1000.0),\n            \"N_points\": 501,\n            \"T_func\": lambda d: 14.0 + 0.5 * np.sin(2.0 * np.pi * d / 120.0) - 11.0 * d / 1000.0,\n            \"S_func\": lambda d: 34.8 + 0.2 * np.cos(2.0 * np.pi * d / 180.0) + 0.1 * d / 1000.0,\n            \"query_depths\": [0.0, 100.0, 250.0, 500.0, 1000.0],\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Generate the depth grid and corresponding T/S profiles.\n        d_grid = np.linspace(case[\"d_range\"][0], case[\"d_range\"][1], case[\"N_points\"])\n        T_profile = case[\"T_func\"](d_grid)\n        S_profile = case[\"S_func\"](d_grid)\n        \n        # Calculate grid spacing for finite differences.\n        h = d_grid[1] - d_grid[0]\n\n        # Step 1: Compute discrete vertical gradients using second-order accurate differences.\n        # np.gradient with edge_order=2 uses second-order central differences for the interior\n        # and second-order one-sided differences for the boundaries.\n        dT_dd = np.gradient(T_profile, h, edge_order=2)\n        dS_dd = np.gradient(S_profile, h, edge_order=2)\n\n        # Step 2: Compute N^2(d) via the linearized formula.\n        N2_profile = g * (beta * dS_dd - alpha * dT_dd)\n\n        # Step 3: Enforce non-negativity by clipping to a minimum floor.\n        N2_clipped = np.maximum(N2_profile, N2_min)\n\n        # Step 4: Construct a smooth, shape-preserving interpolant (PCHIP).\n        pchip_N2 = PchipInterpolator(d_grid, N2_clipped)\n        \n        # Evaluate the prepared function at the specified query depths.\n        query_depths = np.array(case[\"query_depths\"])\n        N2_interpolated = pchip_N2(query_depths)\n        \n        # Format results for the current case into a string list.\n        # The format must use scientific notation with at least 6 decimal digits.\n        case_results_str = [f\"{val:.7e}\" for val in N2_interpolated]\n        all_results.append(f\"[{','.join(case_results_str)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们的最终实践将前面的概念汇集在一起，以解决海洋学中的一个核心任务：解释观测数据。本练习演示了如何通过将测量的海流剖面投影到一组正交基函数上，将其分解为正压和斜压模态分量。您将实现一个广义最小二乘（GLS）估计，不仅学习如何确定每个模态的强度，而且还将学习如何严格量化估计中的不确定性，这是进行稳健科学分析的一项关键技能。",
            "id": "3785951",
            "problem": "给定一个在离散深度上表示的海洋垂向分辨水平流剖面，以及一组旨在近似正压和斜压模态的垂向结构函数标准正交集。任务是设计并实现一个有理论依据的计算程序，以使用最小二乘法估计模态系数，并在指定的测量噪声假设下量化这些估计的不确定性。\n\n从以下基本原理开始：\n- 水平速度的垂向模态分解定义为 $u(z) = \\sum_{n=0}^{N-1} a_n \\,\\phi_n(z)$，其中 $a_n$ 是模态系数，$\\phi_n(z)$ 是垂向结构函数，$N$ 是模态数。正压模态对应于 $n=0$，斜压模态对应于 $n \\ge 1$。\n- 测量模型为 $u_i^{\\mathrm{obs}} = u(z_i) + \\varepsilon_i$，其中 $z_i$ 是深度，$u_i^{\\mathrm{obs}}$ 是在深度 $z_i$ 处的观测速度，$\\varepsilon$ 是均值为零、协方差矩阵为 $\\mathbf{C}$ 的高斯噪声。\n- 广义最小二乘 (GLS) 估计通过最小化由逆噪声协方差加权的残差二次型得到。\n\n使用在区间 $[-H,0]$ 上关于标准 $L^2$ 内积的完备标准正交基来定义垂向结构函数。具体来说，通过 $x = 2(z+H)/H - 1$ 将 $z \\in [-H,0]$ 映射到 $x \\in [-1,1]$，并令 $\\phi_n(z) = \\sqrt{(2n+1)/H}\\,P_n(x)$，其中 $P_n(x)$ 是 $n$ 次勒让德 (Legendre) 多项式。这种选择确保了标准正交性，即 $\\int_{-H}^0 \\phi_n(z)\\,\\phi_m(z)\\,dz = \\delta_{nm}$。\n\n从第一性原理出发：\n- 将离散观测模型表示为 $\\mathbf{u}^{\\mathrm{obs}} = \\mathbf{\\Phi}\\,\\mathbf{a} + \\boldsymbol{\\varepsilon}$，其中 $\\mathbf{u}^{\\mathrm{obs}} \\in \\mathbb{R}^M$，$\\mathbf{a} \\in \\mathbb{R}^N$，设计矩阵 $\\mathbf{\\Phi} \\in \\mathbb{R}^{M \\times N}$ 的元素为 $\\Phi_{i,n} = \\phi_n(z_i)$。\n- 通过最小化加权二次误差来推导 GLS 估计量 $\\hat{\\mathbf{a}}$，并使用高斯噪声假设推导估计量协方差。不要套用任何快捷公式；需推导出正规方程。\n\n使用以下步骤实现估计器和不确定性量化算法：\n- 根据给定的深度和 $\\phi_n(z)$ 定义构造 $\\mathbf{\\Phi}$。\n- 根据每个测试案例的要求构建噪声协方差矩阵 $\\mathbf{C}$。\n- 使用数值稳定的方法求解正规方程以获得 $\\hat{\\mathbf{a}}$，并计算估计量协方差矩阵。\n- 通过检查正规矩阵是否满秩来报告可解性条件。\n- 计算 $\\hat{\\mathbf{a}}$ 与提供的真实值 $\\mathbf{a}^{\\mathrm{true}}$ 之间的均方根误差 (RMSE) 以进行验证。\n\n物理单位和输出要求：\n- 速度 $u$ 和模态系数 $a_n$ 必须以米/秒 (m/s) 为单位。\n- 深度 $z$ 和深度尺度 $H$ 必须以米 (m) 为单位。\n- 所有报告的 RMSE 和不确定性必须以米/秒 (m/s) 为单位，并四舍五入到六位小数。\n\n测试套件：\n为以下四个测试案例实现该程序。对于所有案例，确定性地构造观测剖面，即 $\\mathbf{u}^{\\mathrm{obs}} = \\mathbf{\\Phi}\\,\\mathbf{a}^{\\mathrm{true}}$（不添加噪声实现），并仅使用噪声协方差来计算 GLS 权重和估计器不确定性。\n\n- 案例 A (通用，良好采样)：\n  - $H = 4000\\,\\mathrm{m}$，$N = 4$，$M = 81$，深度 $z_i$ 在 $-H$ 到 $0$ 之间等距分布。\n  - 噪声协方差是对角的，$\\sigma = 0.020\\,\\mathrm{m/s}$，因此 $\\mathbf{C} = \\sigma^2 \\mathbf{I}$。\n  - 真实系数值 $\\mathbf{a}^{\\mathrm{true}} = [0.25, -0.12, 0.08, 0.00]$，单位为 $\\mathrm{m/s}$。\n\n- 案例 B (边界采样：最少层数)：\n  - $H = 3000\\,\\mathrm{m}$，$N = 3$，$M = 3$，深度 $z_i = [-H, -H/2, 0]$。\n  - 噪声协方差是对角的，$\\sigma = 0.005\\,\\mathrm{m/s}$，即 $\\mathbf{C} = \\sigma^2 \\mathbf{I}$。\n  - 真实系数值 $\\mathbf{a}^{\\mathrm{true}} = [0.20, 0.00, -0.10]$，单位为 $\\mathrm{m/s}$。\n\n- 案例 C (异方差噪声和非均匀深度)：\n  - $H = 5000\\,\\mathrm{m}$，$N = 5$，$M = 50$，深度 $z_i$ 是非均匀的：$z_i = -H\\left(1 - \\left(\\frac{i}{M-1}\\right)^2\\right)$，其中 $i = 0, 1, \\dots, M-1$。\n  - 噪声协方差是对角的，标准差为 $\\sigma_i = 0.010 + 0.0003\\,i$，单位为 $\\mathrm{m/s}$，因此 $C_{ii} = \\sigma_i^2$ 且当 $i \\ne j$ 时 $C_{ij} = 0$。\n  - 真实系数值 $\\mathbf{a}^{\\mathrm{true}} = [0.10, -0.05, 0.02, 0.00, 0.01]$，单位为 $\\mathrm{m/s}$。\n\n- 案例 D (相关噪声)：\n  - $H = 4000\\,\\mathrm{m}$，$N = 3$，$M = 40$，深度 $z_i$ 在 $-H$ 到 $0$ 之间等距分布。\n  - 噪声协方差具有相关性 $C_{ij} = \\sigma^2 \\rho^{|i-j|}$，其中 $\\sigma = 0.020\\,\\mathrm{m/s}$ 且 $\\rho = 0.60$。\n  - 真实系数值 $\\mathbf{a}^{\\mathrm{true}} = [-0.15, 0.05, 0.02]$，单位为 $\\mathrm{m/s}$。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果。每个测试案例的结果必须是一个形式为 $[\\text{solvable}, \\text{rmse}, [\\text{unc}_0, \\dots, \\text{unc}_{N-1}]]$ 的列表，其中 $\\text{solvable}$ 是一个布尔值，指示正规矩阵是否满秩，$\\text{rmse}$ 是以 $\\mathrm{m/s}$ 为单位的均方根误差，四舍五入到六位小数，每个 $\\text{unc}_n$ 是 $\\hat{a}_n$ 的标准差，以 $\\mathrm{m/s}$ 为单位，四舍五入到六位小数。因此，总输出是一个单一的嵌套列表，如 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。",
            "solution": "我们从垂向模态分解 $u(z) = \\sum_{n=0}^{N-1} a_n \\,\\phi_n(z)$ 开始，其中 $\\phi_n(z)$ 在深度 $z \\in [-H,0]$ 上关于标准内积是标准正交的，即 $\\int_{-H}^{0} \\phi_n(z)\\,\\phi_m(z)\\,dz = \\delta_{nm}$。在正压和斜压模态分解框架中，$n=0$ 表示正压模态（不随深度变化），$n \\ge 1$ 表示斜压模态（随深度变化）。\n\n观测在离散深度 $z_i$（其中 $i=1,\\dots,M$）进行，遵循测量模型 $u_i^{\\mathrm{obs}} = u(z_i) + \\varepsilon_i$，其中 $\\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{C})$ 且 $\\mathbf{C} \\in \\mathbb{R}^{M \\times M}$ 是正定矩阵。其矩阵形式为\n$$\n\\mathbf{u}^{\\mathrm{obs}} = \\mathbf{\\Phi}\\,\\mathbf{a} + \\boldsymbol{\\varepsilon},\n$$\n其中 $\\mathbf{u}^{\\mathrm{obs}} \\in \\mathbb{R}^M$ 汇集了 $u_i^{\\mathrm{obs}}$，$\\mathbf{a} \\in \\mathbb{R}^N$ 汇集了系数 $a_n$，$\\mathbf{\\Phi} \\in \\mathbb{R}^{M \\times N}$ 是设计矩阵，其元素为 $\\Phi_{i,n} = \\phi_n(z_i)$。\n\n广义最小二乘 (GLS) 源于最小化加权残差范数：\n$$\nJ(\\mathbf{a}) = \\left(\\mathbf{u}^{\\mathrm{obs}} - \\mathbf{\\Phi}\\,\\mathbf{a}\\right)^{\\!\\top} \\mathbf{C}^{-1} \\left(\\mathbf{u}^{\\mathrm{obs}} - \\mathbf{\\Phi}\\,\\mathbf{a}\\right).\n$$\n对 $\\mathbf{a}$ 求梯度并令其为零：\n$$\n\\nabla_{\\mathbf{a}} J = -2\\,\\mathbf{\\Phi}^{\\top}\\mathbf{C}^{-1} \\left(\\mathbf{u}^{\\mathrm{obs}} - \\mathbf{\\Phi}\\,\\mathbf{a}\\right) = \\mathbf{0}.\n$$\n这得到正规方程\n$$\n\\mathbf{A}\\,\\hat{\\mathbf{a}} = \\mathbf{b}, \\quad \\text{其中} \\quad \\mathbf{A} = \\mathbf{\\Phi}^{\\top}\\mathbf{C}^{-1}\\mathbf{\\Phi}, \\quad \\mathbf{b} = \\mathbf{\\Phi}^{\\top}\\mathbf{C}^{-1}\\mathbf{u}^{\\mathrm{obs}}.\n$$\n假设 $\\mathbf{A}$ 是满秩（即秩为 $N$），则 GLS 估计是唯一的\n$$\n\\hat{\\mathbf{a}} = \\mathbf{A}^{-1}\\,\\mathbf{b}.\n$$\n在高斯噪声假设下，估计量的不确定性通过 $\\hat{\\mathbf{a}}$ 的协方差来量化：\n$$\n\\mathrm{Cov}(\\hat{\\mathbf{a}}) = \\left(\\mathbf{\\Phi}^{\\top}\\mathbf{C}^{-1}\\mathbf{\\Phi}\\right)^{-1} = \\mathbf{A}^{-1}.\n$$\n系数的标准差则为 $\\sigma_{\\hat{a}_n} = \\sqrt{\\left[\\mathrm{diag}\\left(\\mathrm{Cov}(\\hat{\\mathbf{a}})\\right)\\right]_n}$。\n\n关于垂向结构函数，我们使用在 $[-1,1]$ 上定义的勒让德 (Legendre) 多项式 $P_n(x)$，通过 $x = 2(z+H)/H - 1$ 的映射，来选择 $[-H,0]$ 上的一个标准正交集。定义\n$$\n\\phi_n(z) = \\sqrt{\\frac{2n+1}{H}}\\,P_n\\!\\left(2\\frac{z+H}{H} - 1\\right).\n$$\n为了验证标准正交性，注意 $dz = \\frac{H}{2} dx$，且勒让德多项式满足 $\\int_{-1}^{1} P_n(x)\\,P_m(x)\\,dx = \\frac{2}{2n+1}\\,\\delta_{nm}$。因此\n$$\n\\int_{-H}^{0} \\phi_n(z)\\,\\phi_m(z)\\,dz = \\int_{-1}^{1} \\sqrt{\\frac{2n+1}{H}}\\,P_n(x)\\;\\sqrt{\\frac{2m+1}{H}}\\,P_m(x)\\;\\frac{H}{2}\\,dx = \\delta_{nm}.\n$$\n这种构造近似了正压和斜压模态：$n=0$ 产生常数正压模态 $\\phi_0(z) = \\sqrt{1/H}$，而 $n\\ge 1$ 产生垂向变化（斜压模态）。\n\n算法设计：\n- 通过在每个深度 $z_i$ 对 $n=0,\\dots,N-1$ 求值 $\\phi_n(z_i)$ 来计算 $\\mathbf{\\Phi}$。\n- 根据噪声模型构造 $\\mathbf{C}$。对于对角（独立）噪声，设 $C_{ii} = \\sigma_i^2$。对于相关噪声，设 $C_{ij} = \\sigma^2 \\rho^{|i-j|}$。\n- 为避免显式地计算 $\\mathbf{C}$ 的逆，我们计算 $\\mathbf{A} = \\mathbf{\\Phi}^{\\top}\\,\\mathbf{X}$ 和 $\\mathbf{b} = \\mathbf{\\Phi}^{\\top}\\,\\mathbf{y}$，其中 $\\mathbf{X}$ 通过求解 $\\mathbf{C}\\,\\mathbf{X} = \\mathbf{\\Phi}$ 得到，$\\mathbf{y}$ 通过求解 $\\mathbf{C}\\,\\mathbf{y} = \\mathbf{u}^{\\mathrm{obs}}$ 得到。这利用了线性求解来保证数值稳定性。\n- 使用直接求解器求解 $\\mathbf{A}\\,\\hat{\\mathbf{a}} = \\mathbf{b}$。如果 $\\mathbf{A}$ 是秩亏的，则使用伪逆 $\\mathbf{A}^{+}$ 来计算最小范数解，并将 $\\mathrm{Cov}(\\hat{\\mathbf{a}}) = \\mathbf{A}^{+}$ 作为不确定性的代理。\n- 通过验证 $\\mathrm{rank}(\\mathbf{A}) = N$ 来检查可解性。\n- 计算 $\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} \\left(\\hat{a}_n - a_n^{\\mathrm{true}}\\right)^2}$。\n- 报告标准差 $\\sigma_{\\hat{a}_n} = \\sqrt{\\left[\\mathrm{diag}\\left(\\mathrm{Cov}(\\hat{\\mathbf{a}})\\right)\\right]_n}$。\n\n测试套件执行细节：\n- 对于每个案例 (A–D)，按规定设置深度和 $H$，构建 $\\mathbf{\\Phi}$，根据噪声模型设置 $\\mathbf{C}$，设置 $\\mathbf{a}^{\\mathrm{true}}$，并确定性地计算 $\\mathbf{u}^{\\mathrm{obs}} = \\mathbf{\\Phi}\\,\\mathbf{a}^{\\mathrm{true}}$。\n- 计算 $\\hat{\\mathbf{a}}$、$\\mathrm{Cov}(\\hat{\\mathbf{a}})$、可解性、$\\mathrm{RMSE}$ 和不确定性。\n- 将所有案例的结果以单个嵌套列表的形式在单行中输出。所有 RMSE 和不确定性必须四舍五入到六位小数并以 $\\mathrm{m/s}$ 为单位。\n\n该方法测试了正压/斜压模态分解的 GLS 推导和实现、标准正交基对正规矩阵的影响、采样和噪声模型对可解性的影响，以及通过估计量协方差进行的严格不确定性量化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef legendre_val(n, x):\n    \"\"\"\n    Evaluate the Legendre polynomial P_n(x) using numpy.polynomial.legendre.legval.\n    \"\"\"\n    c = np.zeros(n + 1)\n    c[n] = 1.0\n    return np.polynomial.legendre.legval(x, c)\n\ndef modes_matrix(z, H, N_modes):\n    \"\"\"\n    Construct the design matrix Phi with entries Phi[i, n] = phi_n(z_i),\n    where phi_n are orthonormal vertical structure functions built from Legendre polynomials.\n    \"\"\"\n    z = np.asarray(z)\n    x = 2.0 * (z + H) / H - 1.0  # Map z in [-H,0] to x in [-1,1]\n    M = z.size\n    Phi = np.zeros((M, N_modes))\n    for n in range(N_modes):\n        Pn = legendre_val(n, x)\n        Phi[:, n] = np.sqrt((2*n + 1) / H) * Pn\n    return Phi\n\ndef left_solve(C, B):\n    \"\"\"\n    Solve C X = B for X without forming C^{-1}.\n    \"\"\"\n    return np.linalg.solve(C, B)\n\ndef gls_estimate(Phi, C, u_obs):\n    \"\"\"\n    Compute the generalized least squares estimate for a, its covariance, and solvability.\n    Returns (a_hat, cov_a, solvable_boolean).\n    \"\"\"\n    # Compute A = Phi^T C^{-1} Phi and b = Phi^T C^{-1} u_obs via linear solves\n    X = left_solve(C, Phi)\n    y = left_solve(C, u_obs)\n    A = Phi.T @ X\n    b = Phi.T @ y\n\n    # Check rank\n    rank_A = np.linalg.matrix_rank(A)\n    N = Phi.shape[1]\n    solvable = (rank_A == N)\n\n    # Solve for a_hat\n    if solvable:\n        a_hat = np.linalg.solve(A, b)\n        cov_a = np.linalg.inv(A)\n    else:\n        # Use pseudo-inverse for minimum-norm solution and uncertainty proxy\n        A_pinv = np.linalg.pinv(A)\n        a_hat = A_pinv @ b\n        cov_a = A_pinv\n\n    return a_hat, cov_a, solvable\n\ndef rmse(a_hat, a_true):\n    diff = a_hat - a_true\n    return float(np.sqrt(np.mean(diff**2)))\n\ndef build_covariance_diagonal(sigmas):\n    sigmas = np.asarray(sigmas)\n    return np.diag(sigmas**2)\n\ndef build_covariance_ar1(sigma, rho, M):\n    \"\"\"\n    Build AR(1)-like covariance: C_ij = sigma^2 * rho^{|i-j|}.\n    \"\"\"\n    idx = np.arange(M)\n    C = sigma**2 * rho**(np.abs(idx[:, None] - idx[None, :]))\n    return C\n\ndef case_A():\n    # Parameters\n    H = 4000.0  # m\n    N = 4\n    M = 81\n    z = np.linspace(-H, 0.0, M)\n    sigma = 0.020  # m/s\n    a_true = np.array([0.25, -0.12, 0.08, 0.00])  # m/s\n\n    Phi = modes_matrix(z, H, N)\n    C = build_covariance_diagonal(np.full(M, sigma))\n    u_obs = Phi @ a_true\n\n    a_hat, cov_a, solvable = gls_estimate(Phi, C, u_obs)\n    rms = rmse(a_hat, a_true)\n    uncertainties = np.sqrt(np.diag(cov_a))\n    return solvable, rms, uncertainties.tolist()\n\ndef case_B():\n    H = 3000.0  # m\n    N = 3\n    z = np.array([-H, -H/2.0, 0.0])\n    M = z.size\n    sigma = 0.005  # m/s\n    a_true = np.array([0.20, 0.00, -0.10])  # m/s\n\n    Phi = modes_matrix(z, H, N)\n    C = build_covariance_diagonal(np.full(M, sigma))\n    u_obs = Phi @ a_true\n\n    a_hat, cov_a, solvable = gls_estimate(Phi, C, u_obs)\n    rms = rmse(a_hat, a_true)\n    uncertainties = np.sqrt(np.diag(cov_a))\n    return solvable, rms, uncertainties.tolist()\n\ndef case_C():\n    H = 5000.0  # m\n    N = 5\n    M = 50\n    i = np.arange(M)\n    z = -H * (1.0 - (i / (M - 1))**2)  # nonuniform depths from -H to 0\n    sigmas = 0.010 + 0.0003 * i  # m/s\n    a_true = np.array([0.10, -0.05, 0.02, 0.00, 0.01])  # m/s\n\n    Phi = modes_matrix(z, H, N)\n    C = build_covariance_diagonal(sigmas)\n    u_obs = Phi @ a_true\n\n    a_hat, cov_a, solvable = gls_estimate(Phi, C, u_obs)\n    rms = rmse(a_hat, a_true)\n    uncertainties = np.sqrt(np.diag(cov_a))\n    return solvable, rms, uncertainties.tolist()\n\ndef case_D():\n    H = 4000.0  # m\n    N = 3\n    M = 40\n    z = np.linspace(-H, 0.0, M)\n    sigma = 0.020  # m/s\n    rho = 0.60\n    a_true = np.array([-0.15, 0.05, 0.02])  # m/s\n\n    Phi = modes_matrix(z, H, N)\n    C = build_covariance_ar1(sigma, rho, M)\n    u_obs = Phi @ a_true\n\n    a_hat, cov_a, solvable = gls_estimate(Phi, C, u_obs)\n    rms = rmse(a_hat, a_true)\n    uncertainties = np.sqrt(np.diag(cov_a))\n    return solvable, rms, uncertainties.tolist()\n\ndef round_list(lst, decimals=6):\n    return [round(x, decimals) for x in lst]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    cases = [case_A, case_B, case_C, case_D]\n\n    results = []\n    for case_func in cases:\n        solvable, rms, unc = case_func()\n        # Round RMSE and uncertainties to six decimals\n        rms_rounded = round(rms, 6)\n        unc_rounded = round_list(unc, 6)\n        results.append([solvable, rms_rounded, unc_rounded])\n\n    # Final print statement in the exact required format.\n    print(str(results))\n\nsolve()\n```"
        }
    ]
}