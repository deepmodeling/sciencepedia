{
    "hands_on_practices": [
        {
            "introduction": "The first step in developing any reliable numerical model is verification: ensuring the code correctly solves the equations it is intended to solve. The Method of Manufactured Solutions (MMS) provides a rigorous framework for this process. By designing a problem with a known, smooth analytical solution, we can precisely quantify our numerical scheme's error and empirically confirm that its convergence rate matches theoretical expectations. This practice () builds the foundational skill of implementing and verifying a finite-difference Poisson solver, a crucial prerequisite before tackling real-world scenarios where the true solution is unknown.",
            "id": "3804158",
            "problem": "Consider the pressure Poisson equation that arises in incompressible ocean modeling, posed as the scalar Partial Differential Equation (PDE) $\\nabla^2 u = f$ on the unit square domain $\\Omega = (0,1)\\times(0,1)$ with Dirichlet boundary condition $u|_{\\partial\\Omega} = g$. To verify a numerical solver using the Method of Manufactured Solutions (MMS), assume a smooth manufactured solution $u^\\star(x,y)$ and define the forcing $f$ by the exact Laplacian of $u^\\star$, while prescribing the boundary data $g$ as the restriction of $u^\\star$ to $\\partial\\Omega$. All quantities are dimensionless.\n\nLet the manufactured solution be\n$$\nu^\\star(x,y) = \\sin(3\\pi x)\\cos(2\\pi y) + x^3 y - e^{x+y}.\n$$\nDefine $f(x,y)$ by $f(x,y) = \\nabla^2 u^\\star(x,y)$, and define $g$ by $g(x,y) = u^\\star(x,y)$ for $(x,y)\\in \\partial\\Omega$. The goal is to numerically solve $\\nabla^2 u = f$ with $u=g$ on $\\partial\\Omega$ using a second-order centered finite-difference discretization on a rectangular grid and to quantify the discretization error and the observed order of accuracy under mesh refinement.\n\nStarting only from the following fundamental base:\n- Conservation of mass for incompressible flow implies a pressure Poisson equation in projection-type solvers, which reduces mathematically to solving $\\nabla^2 u = f$ on a domain with appropriate boundary conditions.\n- The centered second-order finite-difference approximation of second derivatives follows from Taylor expansion about a grid point and yields a discrete Laplacian assembled from directional second differences on a uniform grid.\n\nTasks to implement in a program:\n1. Discretize $\\nabla^2 u = f$ on $\\Omega$ using a uniform rectangular grid with $N_x$ points in the $x$-direction and $N_y$ points in the $y$-direction, spacings $h_x = 1/(N_x-1)$ and $h_y = 1/(N_y-1)$, and a five-point stencil that is second order in space. Enforce the Dirichlet boundary condition strongly by inserting the boundary values from $u^\\star$ and shifting the corresponding contributions into the right-hand side for the linear system at interior nodes.\n2. Solve the resulting linear system for interior grid values and reconstruct the grid function $u_h$ on all nodes by inserting boundary values from $u^\\star$.\n3. Compute the discrete interior error $e_h = u_h - u^\\star$ on the set of interior nodes only. From $e_h$, compute two norms:\n   - The discrete $L^2$-norm defined by $\\|e_h\\|_{L^2(\\Omega)} \\approx \\left(\\sum_{i=1}^{N_x-2}\\sum_{j=1}^{N_y-2} |e_{i,j}|^2 h_x h_y\\right)^{1/2}$.\n   - The discrete $L^\\infty$-norm defined by $\\|e_h\\|_{L^\\infty(\\Omega)} = \\max_{1\\le i\\le N_x-2,\\,1\\le j\\le N_y-2} |e_{i,j}|$.\n4. For a mesh refinement by a factor of $2$ in each direction, estimate the observed order of accuracy $p$ by the standard formula $p = \\log(e_{h}/e_{h/2})/\\log(2)$, where $e_h$ denotes the error norm at resolution characterized by $(h_x,h_y)$ and $e_{h/2}$ denotes the error norm at the refined resolution characterized by $(h_x/2,h_y/2)$. In the anisotropic case where $h_x\\neq h_y$ but both are refined by a factor of $2$, use the same formula with the understanding that the refinement factor is $2$ for both directions and that the error norm $e_h$ is computed on the interior nodes of the corresponding grid.\n5. Compute the relative $\\ell^2$-norm of the discrete linear system residual $\\|r\\|_2/\\|b\\|_2$ on the finest isotropic grid, where $r = A u - b$ is the interior-node residual of the assembled linear system with $A$ the discrete Laplacian and $b$ the adjusted right-hand side. This quantity is dimensionless.\n\nTest suite specification:\n- Isotropic refinement sequence: $(N_x,N_y)\\in\\{(17,17),(33,33),(65,65)\\}$. Compute the observed orders using the last two levels only, i.e., use the errors from $(33,33)$ and $(65,65)$ to produce $p_{L^2}^{\\mathrm{iso}}$ and $p_{L^\\infty}^{\\mathrm{iso}}$.\n- Anisotropic refinement pair: coarse $(N_x,N_y)=(33,49)$ and fine $(N_x,N_y)=(65,97)$. Compute $p_{L^2}^{\\mathrm{aniso}}$ and $p_{L^\\infty}^{\\mathrm{aniso}}$ between these two levels.\n- Residual on the finest isotropic grid: compute the relative residual $\\|r\\|_2/\\|b\\|_2$ at $(N_x,N_y)=(65,65)$.\n\nAll computations are dimensionless; no physical units are involved.\n\nFinal output specification:\nYour program must produce a single line containing a Python-style list with five floating-point numbers in the following order:\n$[p_{L^2}^{\\mathrm{iso}}, p_{L^\\infty}^{\\mathrm{iso}}, p_{L^2}^{\\mathrm{aniso}}, p_{L^\\infty}^{\\mathrm{aniso}}, \\|r\\|_2/\\|b\\|_2]$.\nEach value must be rounded to exactly six digits after the decimal point. The line must contain no other text.\n\nYour implementation must be entirely self-contained and runnable. No user input is permitted. All angles and quantities are dimensionless; no units are required or accepted. The correctness criteria are the numerical values of the five outputs for the specified test suite. The expected answers are real numbers and should reflect second-order convergence in both norms for this smooth manufactured solution. The final output must aggregate the results of all provided test cases into a single line as specified.",
            "solution": "The problem presented is a standard verification exercise for a numerical solver of the two-dimensional Poisson equation, $\\nabla^2 u = f$, on a unit square domain $\\Omega = (0,1)\\times(0,1)$ with specified Dirichlet boundary conditions $u|_{\\partial\\Omega} = g$. The Method of Manufactured Solutions (MMS) is employed, which is a rigorous technique for verifying the correctness and accuracy of numerical code. The problem is scientifically sound, self-contained, and well-posed. We proceed with a complete solution.\n\n### 1. Analytical Formulation\n\nThe core of the MMS is to assume an analytical form for the solution, referred to as the manufactured solution $u^\\star(x,y)$, and then derive the corresponding problem data (forcing term $f$ and boundary conditions $g$).\n\nThe given manufactured solution is:\n$$\nu^\\star(x,y) = \\sin(3\\pi x)\\cos(2\\pi y) + x^3 y - e^{x+y}\n$$\nThe forcing term $f(x,y)$ is defined as the Laplacian of $u^\\star(x,y)$:\n$$\nf(x,y) = \\nabla^2 u^\\star(x,y) = \\frac{\\partial^2 u^\\star}{\\partial x^2} + \\frac{\\partial^2 u^\\star}{\\partial y^2}\n$$\nWe compute the second partial derivatives of $u^\\star$:\nFirst, with respect to $x$:\n$$\n\\frac{\\partial u^\\star}{\\partial x} = 3\\pi \\cos(3\\pi x)\\cos(2\\pi y) + 3x^2 y - e^{x+y}\n$$\n$$\n\\frac{\\partial^2 u^\\star}{\\partial x^2} = -(3\\pi)^2 \\sin(3\\pi x)\\cos(2\\pi y) + 6xy - e^{x+y} = -9\\pi^2 \\sin(3\\pi x)\\cos(2\\pi y) + 6xy - e^{x+y}\n$$\nNext, with respect to $y$:\n$$\n\\frac{\\partial u^\\star}{\\partial y} = -2\\pi \\sin(3\\pi x)\\sin(2\\pi y) + x^3 - e^{x+y}\n$$\n$$\n\\frac{\\partial^2 u^\\star}{\\partial y^2} = -(2\\pi)^2 \\sin(3\\pi x)\\cos(2\\pi y) - e^{x+y} = -4\\pi^2 \\sin(3\\pi x)\\cos(2\\pi y) - e^{x+y}\n$$\nSumming these derivatives gives the forcing function $f(x,y)$:\n$$\nf(x,y) = (-9\\pi^2 - 4\\pi^2)\\sin(3\\pi x)\\cos(2\\pi y) + 6xy - 2e^{x+y}\n$$\n$$\nf(x,y) = -13\\pi^2\\sin(3\\pi x)\\cos(2\\pi y) + 6xy - 2e^{x+y}\n$$\nThe Dirichlet boundary data $g(x,y)$ is simply the value of $u^\\star(x,y)$ on the boundary $\\partial\\Omega$ of the unit square.\n\n### 2. Numerical Discretization\n\nThe domain $\\Omega = (0,1)\\times(0,1)$ is discretized using a uniform rectangular grid. The grid points are denoted by $(x_i, y_j)$, where $x_i = i h_x$ for $i \\in \\{0, 1, ..., N_x-1\\}$ and $y_j = j h_y$ for $j \\in \\{0, 1, ..., N_y-1\\}$. The grid spacings are $h_x = 1/(N_x-1)$ and $h_y = 1/(N_y-1)$.\n\nThe Laplacian operator $\\nabla^2 u$ at an interior grid point $(x_i, y_j)$ is approximated using a second-order centered finite-difference formula, which results in the well-known five-point stencil:\n$$\n\\nabla^2 u \\Big|_{(x_i, y_j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}\n$$\nwhere $u_{i,j}$ denotes the numerical approximation of $u(x_i, y_j)$. Equating this to the source term $f(x_i, y_j) = f_{i,j}$ gives the discrete equation at each interior node ($1 \\le i \\le N_x-2$, $1 \\le j \\le N_y-2$):\n$$\n\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2} = f_{i,j}\n$$\n\n### 3. Linear System Formulation\n\nThe set of linear algebraic equations for all $(N_x-2) \\times (N_y-2)$ interior nodes forms a large linear system of the form $A\\mathbf{u}_{int} = \\mathbf{b}$.\n\n$\\mathbf{u}_{int}$ is a vector of the unknown values $u_{i,j}$ at the interior grid points, flattened into a one-dimensional array. Using a row-major ordering, the index $k$ for an interior point $(i,j)$ is $k = (i-1)(N_y-2) + (j-1)$.\n\nThe matrix $A$ is a sparse matrix representing the discrete Laplacian operator. It has a block-tridiagonal structure. A highly effective method for constructing $A$ is through the Kronecker sum of the one-dimensional second-derivative matrices. Let $D_{xx}$ be the $(N_x-2) \\times (N_x-2)$ matrix for the second derivative in $x$, and $D_{yy}$ be the $(N_y-2) \\times (N_y-2)$ matrix for the second derivative in $y$. Then, for row-major ordering of unknowns, $A$ is given by:\n$$\nA = D_{xx} \\otimes I_y + I_x \\otimes D_{yy}\n$$\nwhere $I_x$ and $I_y$ are identity matrices of size $(N_x-2)$ and $(N_y-2)$ respectively, and $\\otimes$ denotes the Kronecker product.\n\nThe right-hand-side vector $\\mathbf{b}$ is constructed from the values of the forcing function $f_{i,j}$ at the interior nodes. For nodes adjacent to the boundary, boundary condition values must be incorporated. The discrete equations are rearranged to move all known boundary value terms to the right-hand side. For an interior node $(i,j)$, the RHS element $b_{i,j}$ is initialized to $f_{i,j}$. Then, adjustments are made:\n-   If $i=1$, subtract $\\frac{g(x_0, y_j)}{h_x^2}$ from $b_{1,j}$.\n-   If $i=N_x-2$, subtract $\\frac{g(x_{N_x-1}, y_j)}{h_x^2}$ from $b_{N_x-2,j}$.\n-   If $j=1$, subtract $\\frac{g(x_i, y_0)}{h_y^2}$ from $b_{i,1}$.\n-   If $j=N_y-2$, subtract $\\frac{g(x_i, y_{N_y-1})}{h_y^2}$ from $b_{i,N_y-2}$.\n\nOnce $A$ and $\\mathbf{b}$ are assembled, the system is solved for $\\mathbf{u}_{int}$. The full numerical solution $u_h$ is then constructed by combining the computed interior values with the known boundary values from $u^\\star$.\n\n### 4. Error Analysis and Convergence\n\nThe numerical error is the difference between the numerical solution $u_h$ and the exact manufactured solution $u^\\star$ at the grid points, $e_{i,j} = u_{h,i,j} - u^\\star(x_i, y_j)$. We quantify this error over the interior nodes using two standard norms:\n\n-   The discrete $L^2$-norm: $\\|e_h\\|_{L^2} = \\left(\\sum_{i=1}^{N_x-2}\\sum_{j=1}^{N_y-2} |e_{i,j}|^2 h_x h_y\\right)^{1/2}$\n-   The discrete $L^\\infty$-norm (maximum norm): $\\|e_h\\|_{L^\\infty} = \\max_{1\\le i\\le N_x-2,\\,1\\le j\\le N_y-2} |e_{i,j}|$\n\nTo verify the order of accuracy of the method, we perform a mesh refinement study. If the error norm behaves as $\\|e_h\\| \\approx C h^p$, where $h$ is a characteristic mesh size and $p$ is the order of accuracy, then by solving on a coarse grid (size $h$) and a fine grid (size $h/2$), we can estimate $p$:\n$$\np = \\frac{\\log(\\|e_h\\| / \\|e_{h/2}\\|)}{\\log(2)}\n$$\nFor a second-order method, we expect $p \\approx 2$.\n\nFinally, the relative $\\ell^2$-norm of the linear system residual, $\\|r\\|_2 / \\|b\\|_2$ where $r = A\\mathbf{u}_{int} - \\mathbf{b}$, is computed. This value assesses how well the numerical linear algebra solver has solved the system $A\\mathbf{u}_{int} = \\mathbf{b}$ and should be close to machine precision.\n\nThese steps are implemented for the specified isotropic and anisotropic grid refinement sequences to produce the five required output values.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to perform the Method of Manufactured Solutions verification\n    for a 2D Poisson solver.\n    \"\"\"\n\n    def u_star(x, y):\n        \"\"\"The manufactured solution u*(x,y).\"\"\"\n        return np.sin(3 * np.pi * x) * np.cos(2 * np.pi * y) + x**3 * y - np.exp(x + y)\n\n    def f_source(x, y):\n        \"\"\"The forcing term f(x,y) = laplacian(u*(x,y)).\"\"\"\n        term1 = -13 * np.pi**2 * np.sin(3 * np.pi * x) * np.cos(2 * np.pi * y)\n        term2 = 6 * x * y\n        term3 = -2 * np.exp(x + y)\n        return term1 + term2 + term3\n\n    def solve_poisson(Nx, Ny):\n        \"\"\"\n        Solves the Poisson equation on a grid of size (Nx, Ny) and returns error norms.\n        \"\"\"\n        hx = 1.0 / (Nx - 1)\n        hy = 1.0 / (Ny - 1)\n\n        x = np.linspace(0, 1, Nx)\n        y = np.linspace(0, 1, Ny)\n        X, Y = np.meshgrid(x, y, indexing='ij')\n\n        u_exact_grid = u_star(X, Y)\n        f_grid = f_source(X, Y)\n\n        Nix = Nx - 2\n        Niy = Ny - 2\n        N_int = Nix * Niy\n\n        if N_int == 0:\n            return 0.0, 0.0, None, None, None\n\n        # Assemble the discrete Laplacian matrix A using Kronecker products\n        # This corresponds to row-major (C-style) flattening of the unknowns.\n        hx2_inv = 1.0 / hx**2\n        hy2_inv = 1.0 / hy**2\n        \n        diag_x = np.full(Nix, -2.0 * hx2_inv)\n        offdiag_x = np.full(Nix - 1, 1.0 * hx2_inv)\n        Dxx = diags([offdiag_x, diag_x, offdiag_x], [-1, 0, 1], format='csc')\n\n        diag_y = np.full(Niy, -2.0 * hy2_inv)\n        offdiag_y = np.full(Niy - 1, 1.0 * hy2_inv)\n        Dyy = diags([offdiag_y, diag_y, offdiag_y], [-1, 0, 1], format='csc')\n\n        Ix = identity(Nix, format='csc')\n        Iy = identity(Niy, format='csc')\n\n        # The order of kron matters and must match the flattening of the RHS vector\n        # This is for row-major flattening: Dxx kron I + I kron Dyy\n        A = kron(Dxx, Iy) + kron(Ix, Dyy)\n\n        # Assemble the right-hand side vector b\n        b_matrix = f_grid[1:-1, 1:-1].copy()\n\n        # Adjust RHS for boundary conditions\n        b_matrix[0, :] -= u_exact_grid[0, 1:-1] * hx2_inv  # Left boundary i=0\n        b_matrix[-1, :] -= u_exact_grid[-1, 1:-1] * hx2_inv # Right boundary i=Nx-1\n        b_matrix[:, 0] -= u_exact_grid[1:-1, 0] * hy2_inv   # Bottom boundary j=0\n        b_matrix[:, -1] -= u_exact_grid[1:-1, -1] * hy2_inv # Top boundary j=Ny-1\n        \n        b = b_matrix.flatten('C')\n\n        # Solve the linear system for interior nodes\n        u_int_flat = spsolve(A, b)\n\n        # Reconstruct the full numerical solution grid\n        u_h = u_exact_grid.copy()\n        u_h[1:-1, 1:-1] = u_int_flat.reshape((Nix, Niy), order='C')\n\n        # Compute error on interior nodes\n        error_grid = u_h[1:-1, 1:-1] - u_exact_grid[1:-1, 1:-1]\n\n        # Compute L2 and Linf norms of the error\n        l2_norm = np.sqrt(np.sum(error_grid**2 * hx * hy))\n        linf_norm = np.max(np.abs(error_grid))\n        \n        return l2_norm, linf_norm, A, u_int_flat, b\n\n    # Isotropic refinement\n    err_l2_33, err_linf_33, _, _, _ = solve_poisson(33, 33)\n    err_l2_65, err_linf_65, A_65, u_sol_65, b_65 = solve_poisson(65, 65)\n\n    p_l2_iso = np.log(err_l2_33 / err_l2_65) / np.log(2)\n    p_linf_iso = np.log(err_linf_33 / err_linf_65) / np.log(2)\n    \n    # Anisotropic refinement\n    err_l2_c, err_linf_c, _, _, _ = solve_poisson(33, 49)\n    err_l2_f, err_linf_f, _, _, _ = solve_poisson(65, 97)\n\n    p_l2_aniso = np.log(err_l2_c / err_l2_f) / np.log(2)\n    p_linf_aniso = np.log(err_linf_c / err_linf_f) / np.log(2)\n    \n    # Residual calculation for the finest isotropic grid\n    residual_vector = A_65.dot(u_sol_65) - b_65\n    rel_residual = np.linalg.norm(residual_vector) / np.linalg.norm(b_65)\n\n    results = [p_l2_iso, p_linf_iso, p_l2_aniso, p_linf_aniso, rel_residual]\n    \n    # Format output as specified\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While general-purpose solvers are versatile, many problems in computational oceanography feature periodic boundary conditions that permit highly efficient, specialized solution methods. The Fast Fourier Transform (FFT) serves as a powerful tool to diagonalize the discrete Laplacian operator in any periodic direction, transforming the coupled partial differential equation into a set of independent, easily solved ordinary differential equations in Fourier space. This exercise () introduces the design of these \"fast Poisson solvers,\" demonstrating how a change of basis can lead to exceptionally fast and accurate solutions, a critical technique for idealized channel models and global simulations.",
            "id": "3804162",
            "problem": "Consider the numerical solution of the pressure Poisson equation arising in the projection method for incompressible ocean flows. Starting from the incompressibility constraint $\\nabla \\cdot \\boldsymbol{u} = 0$ and the momentum equation, one arrives at a Poisson equation for the pressure, $\\nabla^2 p = f$, where $p$ is the pressure and $f$ is a known right-hand side derived from intermediate velocity fields. In computational oceanography, it is common to impose periodic boundary conditions in directions tangential to large-scale coast-free flows and nonperiodic boundary conditions in the remaining directions. Your task is to implement Fast Fourier Transform (FFT)-based direct solvers in the periodic directions and second-order central finite differences in the nonperiodic directions to solve the pressure Poisson equation and quantify the numerical error against an exact solution.\n\nYou must write a complete program that constructs uniform grids over a rectangular domain, assembles the appropriate discrete operator, and solves the Poisson equation using:\n- FFT-based diagonalization in any periodic direction(s).\n- A tridiagonal direct solve in any nonperiodic direction using second-order centered finite differences and homogeneous Dirichlet boundary conditions.\n\nThe solver must handle two configurations:\n1. A mixed configuration with periodic boundary conditions in the $x$-direction and homogeneous Dirichlet boundary conditions in the $y$-direction.\n2. A fully periodic configuration with periodic boundary conditions in both $x$ and $y$.\n\nFor each configuration, the program must define an exact solution $p^{\\mathrm{true}}(x,y)$ and derive a consistent right-hand side $f(x,y)$ from the continuous Poisson equation $\\nabla^2 p^{\\mathrm{true}} = f$. The grids and test functions are chosen to be smooth and compatible with the specified boundary conditions. Use uniform grids with the following definitions:\n- In any periodic direction of length $L$, use $N$ points with coordinates $x_i = i L / N$ for $i = 0, 1, \\dots, N-1$.\n- In any homogeneous Dirichlet direction of length $L$, use $N^{\\mathrm{int}}$ interior points with spacing $h = L / (N^{\\mathrm{int}} + 1)$ and coordinates $y_j = j h$ for $j = 1, 2, \\dots, N^{\\mathrm{int}}$.\n\nImplement the following three test cases (this is the required test suite):\n\n- Test case $1$ (mixed: periodic in $x$, Dirichlet in $y$):\n  - Domain sizes: $L_x = 1$, $L_y = 1$.\n  - Grid sizes: $N_x = 64$ periodic points in $x$, $N_y^{\\mathrm{int}} = 64$ interior points in $y$.\n  - Exact solution: $p^{\\mathrm{true}}(x,y) = \\sin\\!\\left(2\\pi x / L_x\\right) \\sin\\!\\left(\\pi y / L_y\\right)$.\n  - Right-hand side: $f(x,y) = -\\left[\\left(2\\pi/L_x\\right)^2 + \\left(\\pi/L_y\\right)^2\\right] p^{\\mathrm{true}}(x,y)$.\n\n- Test case $2$ (fully periodic in $x$ and $y$):\n  - Domain sizes: $L_x = 1$, $L_y = 1$.\n  - Grid sizes: $N_x = 64$, $N_y = 64$ periodic points.\n  - Exact solution: $p^{\\mathrm{true}}(x,y) = \\sin\\!\\left(2\\pi x / L_x\\right) \\sin\\!\\left(2\\pi y / L_y\\right)$.\n  - Right-hand side: $f(x,y) = -\\left[\\left(2\\pi/L_x\\right)^2 + \\left(2\\pi/L_y\\right)^2\\right] p^{\\mathrm{true}}(x,y)$.\n  - Enforce that the zero Fourier mode of $p$ is set to $0$ to avoid the indeterminate mean-pressure mode; this is consistent because the specified $f$ has zero mean.\n\n- Test case $3$ (mixed: periodic in $x$, Dirichlet in $y$, edge case with zero wavenumber in $x$):\n  - Domain sizes: $L_x = 1$, $L_y = 1$.\n  - Grid sizes: $N_x = 32$ periodic points in $x$, $N_y^{\\mathrm{int}} = 50$ interior points in $y$.\n  - Exact solution: $p^{\\mathrm{true}}(x,y) = \\sin\\!\\left(\\pi y / L_y\\right)$ (independent of $x$).\n  - Right-hand side: $f(x,y) = -\\left(\\pi/L_y\\right)^2 \\sin\\!\\left(\\pi y / L_y\\right)$.\n\nAlgorithmic requirements:\n- In mixed configurations, apply the one-dimensional FFT in the periodic $x$-direction to diagonalize the discrete second derivative there, resulting in decoupled linear systems along $y$ for each Fourier mode. Solve each resulting tridiagonal system along $y$ exactly using a direct method, and reconstruct $p(x,y)$ via the inverse FFT.\n- In fully periodic configurations, apply a two-dimensional FFT to the right-hand side, perform a direct spectral inversion of the Laplacian in Fourier space for all nonzero wavenumber pairs, and set the zero wavenumber of the pressure to $0$ before transforming back.\n\nFor each test case, compute the maximum absolute error between the numerical solution and the exact solution on the grid, defined as $E_{\\infty} = \\max_{i,j} \\left| p_{ij} - p^{\\mathrm{true}}_{ij} \\right|$. There are no physical units in this problem; all quantities are dimensionless. The expected answers for the test cases are real-valued floats.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of test cases $1$, $2$, and $3$ (for example, $\\left[ r_1, r_2, r_3 \\right]$). The entries must be the computed values of $E_{\\infty}$ for each test case, in that order. No input should be read from the user, and no output other than the specified single line should be printed.",
            "solution": "The problem is validated as scientifically sound, well-posed, and complete. It presents a standard numerical task in computational physics: solving the two-dimensional Poisson equation, $\\nabla^2 p = f$, on a rectangular domain using a combination of spectral and finite difference methods, tailored to different boundary conditions.\n\nThe solution is approached by developing solvers for two distinct configurations as specified: one with mixed periodic and Dirichlet boundary conditions, and another with fully periodic boundary conditions.\n\n### Methodology for Mixed Boundary Conditions (Periodic-Dirichlet)\n\nThis configuration applies to test cases $1$ and $3$, where the domain is periodic in the $x$-direction and bounded by homogeneous Dirichlet conditions in the $y$-direction, i.e., $p(x, 0) = 0$ and $p(x, L_y) = 0$. The governing equation is\n$$\n\\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} = f(x, y)\n$$\nThe problem is discretized on a grid with points $(x_i, y_j)$, where $x_i = i L_x / N_x$ for $i=0, \\dots, N_x-1$ and $y_j = j h_y$ for $j=1, \\dots, N_y^{\\mathrm{int}}$, with cell height $h_y = L_y / (N_y^{\\mathrm{int}} + 1)$.\n\nThe strategy leverages the periodicity in the $x$-direction. For any fixed vertical level $y_j$, the pressure $p(x, y_j)$ and the right-hand side $f(x, y_j)$ can be represented by a discrete Fourier series:\n$$\np(x_i, y_j) = \\sum_{m=0}^{N_x-1} \\hat{p}(k_m, y_j) e^{i k_m x_i}\n$$\n$$\nf(x_i, y_j) = \\sum_{m=0}^{N_x-1} \\hat{f}(k_m, y_j) e^{i k_m x_i}\n$$\nwhere $\\hat{p}$ and $\\hat{f}$ are the Fourier coefficients (computed via Fast Fourier Transform, FFT), and $k_m = 2\\pi m' / L_x$ are the discrete wavenumbers, with $m'$ being an integer index managed by the FFT algorithm (typically from $-N_x/2$ to $N_x/2 - 1$). The differentiation property of the Fourier transform states that the transform of $\\partial^2 p / \\partial x^2$ is $-k_m^2 \\hat{p}$.\n\nSubstituting these series into the PDE effectively transforms the equation into Fourier space with respect to $x$. This decouples the spatial dimensions, yielding a separate one-dimensional boundary value problem in $y$ for each Fourier mode $k_m$:\n$$\n-k_m^2 \\hat{p}(k_m, y) + \\frac{d^2 \\hat{p}(k_m, y)}{d y^2} = \\hat{f}(k_m, y)\n$$\nThis ordinary differential equation is now discretized in $y$ using a second-order central finite difference scheme for the second derivative:\n$$\n\\frac{d^2 \\hat{p}}{dy^2} \\bigg|_{y_j} \\approx \\frac{\\hat{p}(k_m, y_{j+1}) - 2\\hat{p}(k_m, y_j) + \\hat{p}(k_m, y_{j-1})}{h_y^2}\n$$\nThe homogeneous Dirichlet boundary conditions $p(x,0)=p(x,L_y)=0$ imply that their Fourier transforms are also zero, $\\hat{p}(k_m, 0) = 0$ and $\\hat{p}(k_m, L_y) = 0$. This provides the boundary conditions for the discrete system.\n\nFor each wavenumber $k_m$, we obtain a system of linear equations for the vector of Fourier coefficients $\\mathbf{\\hat{p}}_m = [\\hat{p}(k_m, y_1), \\dots, \\hat{p}(k_m, y_{N_y^{\\mathrm{int}}})]^T$:\n$$\n\\frac{1}{h_y^2} \\left( \\hat{p}_{m,j-1} - 2\\hat{p}_{m,j} + \\hat{p}_{m,j+1} \\right) - k_m^2 \\hat{p}_{m,j} = \\hat{f}_{m,j}\n$$\nwhere $\\hat{p}_{m,j} \\equiv \\hat{p}(k_m, y_j)$ and the boundary terms $\\hat{p}_{m,0}$ and $\\hat{p}_{m,N_y^{\\mathrm{int}}+1}$ are zero. This constitutes a symmetric tridiagonal system of size $N_y^{\\mathrm{int}} \\times N_y^{\\mathrm{int}}$ for each mode $m$, which can be solved efficiently using a direct tridiagonal solver.\n\nThe complete algorithm is:\n1.  Compute the 1D FFT of the source term $f(x_i, y_j)$ along the $x$-axis for each $j$ to obtain $\\hat{f}(k_m, y_j)$.\n2.  For each Fourier mode $k_m$:\n    a.  Construct the tridiagonal matrix representing the operator $(-k_m^2 + \\frac{d^2}{dy^2})$.\n    b.  Solve the tridiagonal system for $\\hat{p}(k_m, y_j)$.\n3.  Combine the solutions for all modes into a 2D array $\\hat{p}(k_m, y_j)$.\n4.  Compute the 1D inverse FFT of $\\hat{p}(k_m, y_j)$ along the $k_m$ axis for each $j$ to recover the pressure field $p(x_i, y_j)$.\n\n### Methodology for Fully Periodic Boundary Conditions\n\nThis configuration applies to test case $2$, where the boundary conditions are periodic in both $x$ and $y$. The discretization uses $N_x$ points in $x$ and $N_y$ points in $y$.\n\nGiven periodicity in both directions, a 2D FFT is the natural tool to diagonalize the Laplacian operator. The pressure and source terms are represented by 2D discrete Fourier series:\n$$\np(x_i, y_j) = \\sum_{m=0}^{N_x-1} \\sum_{l=0}^{N_y-1} \\hat{p}(k_m, k_l) e^{i k_m x_i} e^{i k_l y_j}\n$$\nApplying the 2D FFT to the Poisson equation $\\nabla^2 p = f$ transforms it into a simple algebraic equation in the spectral domain:\n$$\n(-k_m^2 - k_l^2) \\hat{p}(k_m, k_l) = \\hat{f}(k_m, k_l)\n$$\nwhere $k_m$ and $k_l$ are the wavenumbers in the $x$ and $y$ directions, respectively. The solution for the Fourier coefficients of the pressure is then obtained by direct division:\n$$\n\\hat{p}(k_m, k_l) = \\frac{\\hat{f}(k_m, k_l)}{-k_m^2 - k_l^2}\n$$\nA singularity arises for the zero-wavenumber mode $(k_m, k_l) = (0,0)$, where the denominator is zero. This corresponds to the mean value of the fields. For a solution to exist, the source term must have a zero mean, i.e., $\\int f \\,dA = 0$, which implies its zero-wavenumber Fourier coefficient $\\hat{f}(0,0)$ must be zero. The problem statement guarantees this condition for the chosen test case. The corresponding pressure mode $\\hat{p}(0,0)$, representing the mean pressure, is undetermined. As is customary, we resolve this ambiguity by setting the mean pressure to zero: $\\hat{p}(0,0) = 0$.\n\nThe complete algorithm is:\n1.  Compute the 2D FFT of the source term $f(x_i, y_j)$ to get $\\hat{f}(k_m, k_l)$.\n2.  For all non-zero wavenumber pairs $(k_m, k_l)$, compute $\\hat{p}(k_m, k_l)$ by dividing $\\hat{f}(k_m, k_l)$ by the spectral representation of the Laplacian, $-(k_m^2 + k_l^2)$.\n3.  Set the zero-wavenumber mode $\\hat{p}(0,0) = 0$.\n4.  Compute the 2D inverse FFT of $\\hat{p}(k_m, k_l)$ to recover the pressure field $p(x_i, y_j)$.\n\n### Error Quantification\n\nFor each test case, the problem provides an exact analytical solution $p^{\\mathrm{true}}(x,y)$ that is consistent with the boundary conditions and from which the source term $f(x,y)$ is derived. Crucially, the chosen sine functions are eigenfunctions of both the continuous Laplacian and the discrete operators (FFT-based second derivative and central finite difference second derivative). Consequently, the numerical method should solve the discrete system exactly, and the resulting numerical solution $p_{ij}$ should match the exact solution evaluated at the grid points, $p^{\\mathrm{true}}_{ij}$, to within machine floating-point precision. The maximum absolute error, $E_{\\infty} = \\max_{i,j} |p_{ij} - p^{\\mathrm{true}}_{ij}|$, is calculated to verify this expectation. Any significant deviation from zero would indicate an error in the implementation.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve_mixed_bc(Lx, Ly, Nx, Ny_int, p_true_func, f_func):\n    \"\"\"\n    Solves the 2D Poisson equation with periodic BC in x and Dirichlet BC in y.\n    \n    Uses FFT in the x-direction and a tridiagonal solve in the y-direction.\n    \"\"\"\n    # 1. Create grids\n    hx = Lx / Nx\n    x = hx * np.arange(Nx)\n    hy = Ly / (Ny_int + 1)\n    y = hy * np.arange(1, Ny_int + 1)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Evaluate functions on the grid\n    f_grid = f_func(X, Y)\n    p_true_grid = p_true_func(X, Y)\n\n    # 3. FFT of the source term f along the periodic x-axis\n    f_hat = np.fft.fft(f_grid, axis=0)\n    \n    # 4. Get discrete wavenumbers in x\n    kx = 2 * np.pi * np.fft.fftfreq(Nx, d=hx)\n\n    # 5. Solve tridiagonal systems for each Fourier mode\n    p_hat = np.zeros_like(f_hat, dtype=np.complex128)\n    \n    # The tridiagonal matrix is constant except for the main diagonal.\n    # It has shape (Ny_int, Ny_int).\n    # A_m @ p_hat_col = f_hat_col\n    # The matrix has (1/hy^2) on the off-diagonals.\n    \n    # For scipy.linalg.solve_banded, we prepare the banded matrix `ab`\n    # ab has shape (3, Ny_int) for l=1, u=1.\n    # ab[0, :] = super-diagonal\n    # ab[1, :] = main-diagonal\n    # ab[2, :] = sub-diagonal\n    ab = np.zeros((3, Ny_int))\n    ab[0, 1:] = 1.0 / hy**2\n    ab[2, :-1] = 1.0 / hy**2\n\n    for m in range(Nx):\n        # Construct main diagonal for this wavenumber kx[m]\n        main_diag_val = -2.0 / hy**2 - kx[m]**2\n        ab[1, :] = main_diag_val\n        \n        # Right-hand side for this mode\n        b = f_hat[m, :]\n        \n        # Solve the tridiagonal system\n        p_hat[m, :] = solve_banded((1, 1), ab, b)\n        \n    # 6. Inverse FFT to get the numerical solution\n    p_numeric = np.fft.ifft(p_hat, axis=0)\n\n    # The solution should be real\n    p_numeric_real = np.real(p_numeric)\n    \n    # 7. Calculate max absolute error\n    error = np.max(np.abs(p_numeric_real - p_true_grid))\n    return error\n\ndef solve_periodic_bc(Lx, Ly, Nx, Ny, p_true_func, f_func):\n    \"\"\"\n    Solves the 2D Poisson equation with periodic BCs in x and y.\n    \n    Uses a 2D FFT-based spectral method.\n    \"\"\"\n    # 1. Create grids\n    hx = Lx / Nx\n    x = hx * np.arange(Nx)\n    hy = Ly / Ny\n    y = hy * np.arange(Ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Evaluate functions on grid\n    f_grid = f_func(X, Y)\n    p_true_grid = p_true_func(X, Y)\n\n    # 3. 2D FFT of the source term\n    f_hat = np.fft.fft2(f_grid)\n\n    # 4. Get discrete wavenumbers\n    kx_vec = 2 * np.pi * np.fft.fftfreq(Nx, d=hx)\n    ky_vec = 2 * np.pi * np.fft.fftfreq(Ny, d=hy)\n    Kx, Ky = np.meshgrid(kx_vec, ky_vec, indexing='ij')\n\n    # 5. Fourier representation of the Laplacian\n    lap_hat = -(Kx**2 + Ky**2)\n\n    # 6. Solve for p_hat in Fourier space\n    # Handle the (0,0) mode singularity by dividing only where lap_hat is non-zero.\n    p_hat = np.divide(f_hat, lap_hat, out=np.zeros_like(f_hat), where=(lap_hat != 0))\n    \n    # The problem specifies setting the zero mode of p to 0. This is implicitly\n    # handled by the `out=np.zeros_like(f_hat)` argument to np.divide, since\n    # lap_hat[0,0] is zero, so the result p_hat[0,0] remains 0.\n    # An explicit set for clarity:\n    p_hat[0, 0] = 0.0\n\n    # 7. Inverse 2D FFT to get the numerical solution\n    p_numeric = np.fft.ifft2(p_hat)\n    \n    # The solution should be real\n    p_numeric_real = np.real(p_numeric)\n\n    # 8. Calculate max absolute error\n    error = np.max(np.abs(p_numeric_real - p_true_grid))\n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    \n    results = []\n\n    # Test Case 1: Mixed BC (periodic-x, dirichlet-y)\n    Lx1, Ly1 = 1.0, 1.0\n    Nx1, Ny_int1 = 64, 64\n    k_x1 = 2 * np.pi / Lx1\n    k_y1 = np.pi / Ly1\n    p_true1 = lambda x, y: np.sin(k_x1 * x) * np.sin(k_y1 * y)\n    f1 = lambda x, y: -(k_x1**2 + k_y1**2) * p_true1(x, y)\n    error1 = solve_mixed_bc(Lx1, Ly1, Nx1, Ny_int1, p_true1, f1)\n    results.append(error1)\n\n    # Test Case 2: Fully Periodic BC\n    Lx2, Ly2 = 1.0, 1.0\n    Nx2, Ny2 = 64, 64\n    k_x2 = 2 * np.pi / Lx2\n    k_y2 = 2 * np.pi / Ly2\n    p_true2 = lambda x, y: np.sin(k_x2 * x) * np.sin(k_y2 * y)\n    f2 = lambda x, y: -(k_x2**2 + k_y2**2) * p_true2(x, y)\n    error2 = solve_periodic_bc(Lx2, Ly2, Nx2, Ny2, p_true2, f2)\n    results.append(error2)\n\n    # Test Case 3: Mixed BC, edge case (zero wavenumber in x)\n    Lx3, Ly3 = 1.0, 1.0\n    Nx3, Ny_int3 = 32, 50\n    k_y3 = np.pi / Ly3\n    p_true3 = lambda x, y: np.sin(k_y3 * y)\n    f3 = lambda x, y: -(k_y3**2) * np.sin(k_y3 * y)\n    error3 = solve_mixed_bc(Lx3, Ly3, Nx3, Ny_int3, p_true3, f3)\n    results.append(error3)\n\n    # Format the results for printing\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Realistic ocean simulations often demand computational grids so large that they exceed the memory and processing power of a single computer. The standard approach for tackling such large-scale challenges is parallel computing through domain decomposition. In this paradigm, the problem domain is partitioned into smaller subdomains, and an iterative method, such as the block-Jacobi algorithm, is employed to solve the system in parallel, with each processor managing a subdomain and exchanging boundary data with its neighbors. By implementing a simulated parallel solver (), you will explore the fundamental concepts of high-performance scientific computing, including data partitioning, halo exchanges, and the convergence properties of parallel iterative algorithms.",
            "id": "3804167",
            "problem": "You are tasked with designing and implementing a numerical solver for the pressure Poisson equation that explicitly uses domain decomposition to simulate parallelization in a serial environment. The scientific context is projection methods for incompressible oceanic flow, where the pressure arises from enforcing mass conservation. The goal is to implement a block-Jacobi method over decomposed subdomains to solve a manufactured two-dimensional Poisson problem on a structured grid, and to report root-mean-square error values for a set of test cases.\n\nStart from the fundamental base that incompressible flow satisfies the divergence-free constraint and the pressure field enforces this constraint through a Poisson equation. The relevant core definitions are:\n- The divergence-free condition for velocity at time $t$: $\\nabla \\cdot \\mathbf{u}(t) = 0$.\n- The projection step imposes this by solving a Poisson equation for pressure: $\\nabla^2 p = f$, where $f$ is derived from intermediate velocity divergence in practice; for this problem, use a manufactured solution to set $f$ consistently.\n- The Laplacian operator $\\nabla^2$ on a two-dimensional rectangle, and second-order central finite differences on a uniform structured grid.\n\nYour program must:\n- Consider a rectangular domain with lengths $L_x$ and $L_y$ and a uniform structured grid with $N_x$ points in the $x$ direction and $N_y$ points in the $y$ direction.\n- Use a manufactured exact solution $p_{\\text{exact}}(x,y) = \\sin\\!\\big(2\\pi x / L_x\\big)\\,\\sin\\!\\big(3\\pi y / L_y\\big)$. Angles must be interpreted in radians.\n- Derive the source term $f(x,y)$ consistently from $p_{\\text{exact}}$ so that $\\nabla^2 p_{\\text{exact}} = f$ holds exactly in the continuous sense, and then discretize the Poisson equation with second-order central finite differences on the interior of the grid.\n- Impose Dirichlet boundary conditions by setting the boundary values of the discrete pressure to $p_{\\text{exact}}$ on all four sides of the domain.\n- Decompose the interior grid into $B_x$ blocks in the $x$ direction and $B_y$ blocks in the $y$ direction using a contiguous partition, allowing uneven block sizes when $(N_x - 2)$ or $(N_y - 2)$ is not divisible by $B_x$ or $B_y$. Treat each block as a subdomain. You must simulate parallelization by updating each block’s interior using values from the previous global iteration, i.e., a block-Jacobi update emulating halo exchanges from neighboring blocks.\n- Perform a fixed number of iterations of the weighted Jacobi method with relaxation parameter $\\omega \\in (0,1]$, recalculating only interior points and reimposing boundary conditions each iteration.\n- Compute the root-mean-square (RMS) of the pointwise error between the numerical solution $p$ and $p_{\\text{exact}}$ over all grid nodes after the final iteration. The RMS error is dimensionless in this setup.\n\nDesign details you must adhere to:\n- Use second-order central differences to discretize the Laplacian operator.\n- Partition the interior index ranges $i \\in \\{1,\\dots,N_x-2\\}$ and $j \\in \\{1,\\dots,N_y-2\\}$ into $B_x$ and $B_y$ contiguous blocks respectively, distributing remainder points so that the first blocks receive at most one extra interior point. There is no overlap beyond the natural halo given by the stencil; neighboring values used in each block’s update must come from the previous iteration (“halo exchange”).\n- Angles in trigonometric functions must be in radians.\n\nTest suite:\nImplement the solver for the following four test cases. In each case, report the RMS error as a float.\n\n$1.$ $L_x = 1.0$, $L_y = 1.0$, $N_x = 32$, $N_y = 32$, $B_x = 2$, $B_y = 2$, $\\omega = 0.8$, iterations $= 400$.\n\n$2.$ $L_x = 1.0$, $L_y = 1.0$, $N_x = 64$, $N_y = 64$, $B_x = 4$, $B_y = 4$, $\\omega = 0.8$, iterations $= 1000$.\n\n$3.$ $L_x = 1.0$, $L_y = 1.0$, $N_x = 8$, $N_y = 8$, $B_x = 2$, $B_y = 1$, $\\omega = 0.7$, iterations $= 200$.\n\n$4.$ $L_x = 2.0$, $L_y = 1.0$, $N_x = 40$, $N_y = 30$, $B_x = 1$, $B_y = 1$, $\\omega = 0.85$, iterations $= 800$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each float rounded to $6$ decimal places. For example, if there are four results $r_1, r_2, r_3, r_4$, the output must be of the form $[r_1,r_2,r_3,r_4]$ where each $r_k$ is rounded to $6$ decimal places. No additional text should be printed.",
            "solution": "The problem is valid. It presents a well-posed and scientifically grounded task in computational fluid dynamics: solving the two-dimensional pressure Poisson equation on a rectangular domain using a manufactured solution for verification. The numerical method specified, a block-Jacobi iterative solver on a decomposed domain, is a standard technique for emulating parallel computation. All parameters and algorithmic details are provided, rendering the problem unambiguous and solvable.\n\nWe begin by establishing the mathematical and numerical framework.\n\n**1. Mathematical Formulation**\n\nThe governing equation is the Poisson equation for pressure $p(x,y)$:\n$$ \\nabla^2 p = f $$\non a rectangular domain $\\Omega = [0, L_x] \\times [0, L_y]$. The source term $f(x,y)$ is determined by the choice of a manufactured solution, ensuring consistency.\n\nThe specified manufactured solution is:\n$$ p_{\\text{exact}}(x,y) = \\sin\\left(\\frac{2\\pi x}{L_x}\\right) \\sin\\left(\\frac{3\\pi y}{L_y}\\right) $$\nTo find the corresponding source term $f$, we compute the Laplacian of $p_{\\text{exact}}$:\n$$ \\frac{\\partial^2 p_{\\text{exact}}}{\\partial x^2} = -\\left(\\frac{2\\pi}{L_x}\\right)^2 \\sin\\left(\\frac{2\\pi x}{L_x}\\right) \\sin\\left(\\frac{3\\pi y}{L_y}\\right) = -\\left(\\frac{2\\pi}{L_x}\\right)^2 p_{\\text{exact}}(x,y) $$\n$$ \\frac{\\partial^2 p_{\\text{exact}}}{\\partial y^2} = -\\left(\\frac{3\\pi}{L_y}\\right)^2 \\sin\\left(\\frac{2\\pi x}{L_x}\\right) \\sin\\left(\\frac{3\\pi y}{L_y}\\right) = -\\left(\\frac{3\\pi}{L_y}\\right)^2 p_{\\text{exact}}(x,y) $$\nThe source term is the sum of these second partial derivatives:\n$$ f(x,y) = \\nabla^2 p_{\\text{exact}} = \\left[ -\\left(\\frac{2\\pi}{L_x}\\right)^2 - \\left(\\frac{3\\pi}{L_y}\\right)^2 \\right] p_{\\text{exact}}(x,y) $$\nThe problem is subject to Dirichlet boundary conditions, where the pressure on the boundary of the domain $\\partial\\Omega$ is set to the exact solution:\n$$ p(x,y) = p_{\\text{exact}}(x,y) \\quad \\text{for } (x,y) \\in \\partial\\Omega $$\n\n**2. Numerical Discretization**\n\nWe discretize the domain using a uniform structured grid with $N_x$ points in the $x$-direction and $N_y$ points in the $y$-direction. The grid spacings are $\\Delta x = L_x / (N_x - 1)$ and $\\Delta y = L_y / (N_y - 1)$. The grid points are $(x_i, y_j) = (i\\Delta x, j\\Delta y)$ for $i \\in \\{0, 1, \\dots, N_x-1\\}$ and $j \\in \\{0, 1, \\dots, N_y-1\\}$. Let $p_{i,j}$ denote the numerical approximation of $p(x_i, y_j)$.\n\nThe Laplacian operator is discretized at interior grid points ($1 \\le i \\le N_x-2$, $1 \\le j \\le N_y-2$) using a second-order central difference scheme:\n$$ \\nabla^2 p(x_i, y_j) \\approx \\frac{p_{i+1,j} - 2p_{i,j} + p_{i-1,j}}{(\\Delta x)^2} + \\frac{p_{i,j+1} - 2p_{i,j} + p_{i,j-1}}{(\\Delta y)^2} $$\nSubstituting this into the Poisson equation gives the discrete system:\n$$ \\frac{p_{i+1,j} - 2p_{i,j} + p_{i-1,j}}{(\\Delta x)^2} + \\frac{p_{i,j+1} - 2p_{i,j} + p_{i,j-1}}{(\\Delta y)^2} = f_{i,j} $$\nwhere $f_{i,j} = f(x_i, y_j)$.\n\n**3. Weighted Jacobi Iterative Solver**\n\nTo solve for $p_{i,j}$, we rearrange the discrete equation:\n$$ p_{i,j} \\left( \\frac{2}{(\\Delta x)^2} + \\frac{2}{(\\Delta y)^2} \\right) = \\frac{p_{i+1,j} + p_{i-1,j}}{(\\Delta x)^2} + \\frac{p_{i,j+1} + p_{i,j-1}}{(\\Delta y)^2} - f_{i,j} $$\nLetting $h_x = \\Delta x$ and $h_y = \\Delta y$, the standard Jacobi update for $p_{i,j}$ at iteration $k+1$, using values from iteration $k$, is:\n$$ \\hat{p}_{i,j}^{k+1} = \\frac{h_y^2(p_{i+1,j}^k + p_{i-1,j}^k) + h_x^2(p_{i,j+1}^k + p_{i,j-1}^k) - h_x^2 h_y^2 f_{i,j}}{2(h_x^2 + h_y^2)} $$\nThe weighted Jacobi method with relaxation parameter $\\omega \\in (0, 1]$ modifies this update:\n$$ p_{i,j}^{k+1} = (1 - \\omega) p_{i,j}^k + \\omega \\hat{p}_{i,j}^{k+1} $$\nThis iterative process is performed for a fixed number of iterations.\n\n**4. Domain Decomposition and Block-Jacobi Method**\n\nThe simulation of a parallel block-Jacobi solver on a serial machine involves partitioning the interior grid points and updating them based on the global state from the previous iteration. The set of interior indices in the $x$-direction, $\\{1, \\dots, N_x-2\\}$, is divided into $B_x$ contiguous blocks. Similarly, the set of interior $y$-indices, $\\{1, \\dots, N_y-2\\}$, is divided into $B_y$ blocks. This creates a total of $B_x \\times B_y$ subdomains (blocks).\n\nFor each iteration $k+1$:\n1. A copy of the entire pressure field, $p^k$, is retained (conceptually, $p_{\\text{old}}$).\n2. For each block, the new interior values $p_{i,j}^{k+1}$ are computed using the weighted Jacobi formula. Crucially, all values on the right-hand side, including those from neighboring blocks (the \"halo\" data), are taken from $p^k$.\n3. After all blocks are updated, the new field $p^{k+1}$ becomes the current field for the next iteration.\n\nThis procedure correctly emulates a parallel update where each processing unit would work on its subdomain and exchange boundary information (\"halo exchange\") with its neighbors between iterations.\n\n**5. Error Metric**\n\nAfter the final iteration, the quality of the numerical solution $p$ is quantified by the root-mean-square (RMS) error against the exact solution $p_{\\text{exact}}$ over all $N_x \\times N_y$ grid points:\n$$ E_{\\text{RMS}} = \\sqrt{\\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} (p_{i,j} - p_{\\text{exact}, i,j})^2} $$\nSince the boundary values of $p$ are fixed to $p_{\\text{exact}}$, the error on the boundaries is zero. The sum effectively measures the error over the interior.\n\nThe algorithm proceeds as follows:\n1. Initialize grid parameters, coordinate arrays, the exact solution $p_{\\text{exact}}$, and the source term field $f$.\n2. Initialize the numerical solution field $p$ (e.g., with zeros) and enforce the Dirichlet boundary conditions using $p_{\\text{exact}}$.\n3. Determine the index partitions for the $B_x \\times B_y$ blocks.\n4. Iterate a fixed number of times. In each iteration, compute the new interior values for all blocks using the weighted Jacobi formula, based on the pressure field from the start of the iteration.\n5. After all iterations are complete, compute the final RMS error.",
            "answer": "```python\nimport numpy as np\n\ndef _get_partitions(n_points, n_blocks):\n    \"\"\"\n    Partitions a range of n_points into n_blocks.\n    Returns a list of start/end indices for each block.\n    \"\"\"\n    if n_points == 0 and n_blocks > 0:\n        return [(1,1) for _ in range(n_blocks)] # Empty blocks\n    if n_points < n_blocks:\n        # Assign one point to the first n_points blocks, rest are empty.\n        partitions = []\n        for i in range(n_points):\n            partitions.append((i + 1, i + 2))\n        for i in range(n_points, n_blocks):\n            partitions.append((n_points + 1, n_points + 1))\n        return partitions\n\n    base_size = n_points // n_blocks\n    remainder = n_points % n_blocks\n    \n    partitions = []\n    current_idx = 1\n    for i in range(n_blocks):\n        block_size = base_size + 1 if i < remainder else base_size\n        start_idx = current_idx\n        end_idx = current_idx + block_size\n        partitions.append((start_idx, end_idx))\n        current_idx = end_idx\n    return partitions\n\ndef run_solver(Lx, Ly, Nx, Ny, Bx, By, omega, iterations):\n    \"\"\"\n    Solves the 2D Poisson equation using a block-Jacobi solver.\n    \"\"\"\n    # 1. Grid and variable setup\n    dx = Lx / (Nx - 1)\n    dy = Ly / (Ny - 1)\n    dx2, dy2 = dx**2, dy**2\n\n    x = np.linspace(0, Lx, Nx)\n    y = np.linspace(0, Ly, Ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Manufactured solution and source term\n    kx = 2 * np.pi / Lx\n    ky = 3 * np.pi / Ly\n    \n    p_exact = np.sin(kx * X) * np.sin(ky * Y)\n    f = -(kx**2 + ky**2) * p_exact\n\n    # 3. Initialization\n    p = np.zeros_like(p_exact)\n    \n    # Enforce Dirichlet boundary conditions\n    p[0, :] = p_exact[0, :]\n    p[-1, :] = p_exact[-1, :]\n    p[:, 0] = p_exact[:, 0]\n    p[:, -1] = p_exact[:, -1]\n\n    # 4. Domain Decomposition\n    # Interior points are indexed from 1 to N-2\n    Mx = Nx - 2\n    My = Ny - 2\n    x_partitions = _get_partitions(Mx, Bx)\n    y_partitions = _get_partitions(My, By)\n    \n    blocks = []\n    for i_start, i_end in x_partitions:\n        for j_start, j_end in y_partitions:\n            if i_start < i_end and j_start < j_end: # Ensure block is not empty\n                blocks.append(((i_start, i_end), (j_start, j_end)))\n\n    # 5. Iterative Solver\n    # Coefficients for the update formula\n    coeff1 = dy2 / (2 * (dx2 + dy2))\n    coeff2 = dx2 / (2 * (dx2 + dy2))\n    coeff3 = (dx2 * dy2) / (2 * (dx2 + dy2))\n\n    for _ in range(iterations):\n        p_old = p.copy()\n        \n        # Simulate parallel update by iterating over blocks\n        for block in blocks:\n            (i_start, i_end), (j_start, j_end) = block\n            for i in range(i_start, i_end):\n                for j in range(j_start, j_end):\n                    # Standard Jacobi update term\n                    p_jacobi = (\n                        coeff1 * (p_old[i+1, j] + p_old[i-1, j]) +\n                        coeff2 * (p_old[i, j+1] + p_old[i, j-1]) -\n                        coeff3 * f[i, j]\n                    )\n                    \n                    # Weighted Jacobi update\n                    p[i, j] = (1 - omega) * p_old[i, j] + omega * p_jacobi\n    \n    # 6. Error Calculation\n    rms_error = np.sqrt(np.mean((p - p_exact)**2))\n    \n    return rms_error\n    \ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        (1.0, 1.0, 32, 32, 2, 2, 0.8, 400),\n        (1.0, 1.0, 64, 64, 4, 4, 0.8, 1000),\n        (1.0, 1.0, 8, 8, 2, 1, 0.7, 200),\n        (2.0, 1.0, 40, 30, 1, 1, 0.85, 800)\n    ]\n\n    results = []\n    for case in test_cases:\n        Lx, Ly, Nx, Ny, Bx, By, omega, num_iter = case\n        rms_error = run_solver(Lx, Ly, Nx, Ny, Bx, By, omega, num_iter)\n        results.append(rms_error)\n    \n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}