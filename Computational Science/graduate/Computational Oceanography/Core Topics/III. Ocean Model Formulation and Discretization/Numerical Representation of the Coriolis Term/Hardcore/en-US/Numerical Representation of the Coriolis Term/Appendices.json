{
    "hands_on_practices": [
        {
            "introduction": "Before discretizing the Coriolis term, it is crucial to understand its physical basis and geographical dependence. This exercise grounds our numerical work by deriving the Coriolis parameter, $f$, from the fundamental principles of rotating-frame dynamics. By calculating its value at different latitudes, you will quantify its significant variation, which underscores why its representation is a critical and non-trivial aspect of numerical ocean modeling .",
            "id": "3803933",
            "problem": "Consider the horizontal momentum equations for a rotating Earth, derived from Newton’s second law in a non-inertial (rotating) frame where the apparent acceleration includes the Coriolis term $2\\,\\boldsymbol{\\Omega}\\times\\boldsymbol{u}$. Here $\\boldsymbol{\\Omega}$ is the Earth’s rotation vector with magnitude $\\Omega$, and $\\boldsymbol{u}$ is the local fluid velocity. In a local east–north–up basis $\\{\\hat{\\boldsymbol{e}},\\hat{\\boldsymbol{n}},\\hat{\\boldsymbol{k}}\\}$ at latitude $\\phi$, assume the traditional approximation of geophysical fluid dynamics, in which only the component of $2\\,\\boldsymbol{\\Omega}$ parallel to $\\hat{\\boldsymbol{k}}$ acts on horizontal motion. Starting from these foundations and using geometrical decomposition of $\\boldsymbol{\\Omega}$ into the local basis, derive the standard scalar Coriolis parameter $f(\\phi)$ that multiplies the horizontal velocity in the linearized momentum equations used in ocean models. Then, using the Earth’s sidereal rotation rate $\\Omega=7.2921159\\times 10^{-5}\\,\\mathrm{s}^{-1}$, compute the values of $f$ at latitude $\\phi=30^{\\circ}\\,\\mathrm{N}$ and $\\phi=60^{\\circ}\\,\\mathrm{N}$, and quantify the fractional change\n$$\\delta_f=\\frac{|f(60^{\\circ})-f(30^{\\circ})|}{|f(30^{\\circ})|}$$\nto assess the sensitivity of numerical schemes to latitudinal variation of $f$. Interpret all angles in degrees. Express the final fractional change $\\delta_f$ as a decimal and round your final answer to four significant figures. If intermediate values of $f$ are computed, express them in $\\mathrm{s}^{-1}$, but the final reported answer must be the single number $\\delta_f$.",
            "solution": "The problem is well-posed and scientifically grounded in the principles of geophysical fluid dynamics. We shall proceed with the derivation and calculation.\n\nThe Earth's rotation is described by the angular velocity vector $\\boldsymbol{\\Omega}$, which points along the planet's axis from the South Pole to the North Pole and has a magnitude $\\Omega$. We define a local Cartesian coordinate system at a point on the Earth's surface at latitude $\\phi$. The basis vectors are $\\{\\hat{\\boldsymbol{e}}, \\hat{\\boldsymbol{n}}, \\hat{\\boldsymbol{k}}\\}$, representing the local east, north, and up (vertical) directions, respectively.\n\nThe rotation vector $\\boldsymbol{\\Omega}$ can be decomposed into this local basis. By geometrical construction, the angle between the local vertical direction $\\hat{\\boldsymbol{k}}$ and the Earth's rotation axis is $90^{\\circ} - \\phi$. Consequently, the angle between the local north direction $\\hat{\\boldsymbol{n}}$ (which lies in the horizontal plane) and the rotation axis is $\\phi$. Since $\\boldsymbol{\\Omega}$ lies in the local north-vertical plane, its decomposition is:\n$$\n\\boldsymbol{\\Omega} = (\\boldsymbol{\\Omega}\\cdot\\hat{\\boldsymbol{n}})\\hat{\\boldsymbol{n}} + (\\boldsymbol{\\Omega}\\cdot\\hat{\\boldsymbol{k}})\\hat{\\boldsymbol{k}}\n$$\nThe projections are $\\boldsymbol{\\Omega}\\cdot\\hat{\\boldsymbol{n}} = \\Omega\\cos(\\phi)$ and $\\boldsymbol{\\Omega}\\cdot\\hat{\\boldsymbol{k}} = \\Omega\\sin(\\phi)$. Thus, the rotation vector in the local basis is:\n$$\n\\boldsymbol{\\Omega} = \\Omega\\cos(\\phi)\\hat{\\boldsymbol{n}} + \\Omega\\sin(\\phi)\\hat{\\boldsymbol{k}}\n$$\nThe momentum equation in a rotating frame includes the Coriolis acceleration term, which is given by $-2\\boldsymbol{\\Omega}\\times\\boldsymbol{u}$, where $\\boldsymbol{u}$ is the fluid velocity vector in the local frame. The velocity vector is $\\boldsymbol{u} = u\\hat{\\boldsymbol{e}} + v\\hat{\\boldsymbol{n}} + w\\hat{\\boldsymbol{k}}$.\n\nThe problem specifies the use of the traditional approximation, in which only the component of $2\\boldsymbol{\\Omega}$ parallel to the local vertical $\\hat{\\boldsymbol{k}}$ is considered to act on the horizontal motion. The horizontal velocity is $\\boldsymbol{u}_h = u\\hat{\\boldsymbol{e}} + v\\hat{\\boldsymbol{n}}$. The component of $2\\boldsymbol{\\Omega}$ parallel to $\\hat{\\boldsymbol{k}}$ is $2\\boldsymbol{\\Omega}_{\\text{vert}} = 2\\Omega\\sin(\\phi)\\hat{\\boldsymbol{k}}$.\n\nThe Coriolis acceleration term in the horizontal momentum equations under this approximation is the horizontal component of $-2\\boldsymbol{\\Omega}_{\\text{vert}} \\times \\boldsymbol{u}_h$:\n$$\n\\boldsymbol{a}_{c,h} \\approx - (2\\Omega\\sin(\\phi)\\hat{\\boldsymbol{k}}) \\times (u\\hat{\\boldsymbol{e}} + v\\hat{\\boldsymbol{n}})\n$$\nWe expand the cross product using the relations for a right-handed system: $\\hat{\\boldsymbol{k}}\\times\\hat{\\boldsymbol{e}} = \\hat{\\boldsymbol{n}}$ and $\\hat{\\boldsymbol{k}}\\times\\hat{\\boldsymbol{n}} = -\\hat{\\boldsymbol{e}}$.\n$$\n\\boldsymbol{a}_{c,h} \\approx -2\\Omega\\sin(\\phi) [u(\\hat{\\boldsymbol{k}}\\times\\hat{\\boldsymbol{e}}) + v(\\hat{\\boldsymbol{k}}\\times\\hat{\\boldsymbol{n}})]\n$$\n$$\n\\boldsymbol{a}_{c,h} \\approx -2\\Omega\\sin(\\phi) [u\\hat{\\boldsymbol{n}} - v\\hat{\\boldsymbol{e}}]\n$$\n$$\n\\boldsymbol{a}_{c,h} \\approx (2\\Omega\\sin(\\phi)v)\\hat{\\boldsymbol{e}} - (2\\Omega\\sin(\\phi)u)\\hat{\\boldsymbol{n}}\n$$\nThe linearized horizontal momentum equations are typically written as:\n$$\n\\frac{du}{dt} = fv + \\dots\n$$\n$$\n\\frac{dv}{dt} = -fu + \\dots\n$$\nwhere the terms shown are the components of the Coriolis acceleration. Comparing our derived acceleration components with this standard form, we identify the Coriolis parameter $f$, also known as the planetary vorticity, as:\n$$\nf(\\phi) = 2\\Omega\\sin(\\phi)\n$$\nThis completes the derivation. Now, we compute the required values. The Earth's sidereal rotation rate is given as $\\Omega=7.2921159\\times 10^{-5}\\,\\mathrm{s}^{-1}$.\n\nAt latitude $\\phi=30^{\\circ}\\,\\mathrm{N}$:\n$$\nf(30^{\\circ}) = 2 \\times (7.2921159\\times 10^{-5}\\,\\mathrm{s}^{-1}) \\times \\sin(30^{\\circ})\n$$\nSince $\\sin(30^{\\circ}) = 1/2$,\n$$\nf(30^{\\circ}) = 2 \\times (7.2921159\\times 10^{-5}\\,\\mathrm{s}^{-1}) \\times \\frac{1}{2} = 7.2921159\\times 10^{-5}\\,\\mathrm{s}^{-1}\n$$\n\nAt latitude $\\phi=60^{\\circ}\\,\\mathrm{N}$:\n$$\nf(60^{\\circ}) = 2 \\times (7.2921159\\times 10^{-5}\\,\\mathrm{s}^{-1}) \\times \\sin(60^{\\circ})\n$$\nSince $\\sin(60^{\\circ}) = \\sqrt{3}/2$,\n$$\nf(60^{\\circ}) = 2 \\times (7.2921159\\times 10^{-5}\\,\\mathrm{s}^{-1}) \\times \\frac{\\sqrt{3}}{2} = \\sqrt{3} \\times (7.2921159\\times 10^{-5}\\,\\mathrm{s}^{-1})\n$$\n$$\nf(60^{\\circ}) \\approx 1.263053\\times 10^{-4}\\,\\mathrm{s}^{-1}\n$$\n\nNext, we calculate the fractional change $\\delta_f$:\n$$\n\\delta_f = \\frac{|f(60^{\\circ})-f(30^{\\circ})|}{|f(30^{\\circ})|}\n$$\nSubstituting the expressions for $f(\\phi)$:\n$$\n\\delta_f = \\frac{|2\\Omega\\sin(60^{\\circ})-2\\Omega\\sin(30^{\\circ})|}{|2\\Omega\\sin(30^{\\circ})|}\n$$\nSince $\\phi$ is in the Northern Hemisphere and between $0^{\\circ}$ and $90^{\\circ}$, $\\sin(\\phi)$ is positive and increasing, so we can remove the absolute value signs:\n$$\n\\delta_f = \\frac{2\\Omega(\\sin(60^{\\circ})-\\sin(30^{\\circ}))}{2\\Omega\\sin(30^{\\circ})} = \\frac{\\sin(60^{\\circ})}{\\sin(30^{\\circ})} - 1\n$$\nSubstituting the exact trigonometric values:\n$$\n\\delta_f = \\frac{\\sqrt{3}/2}{1/2} - 1 = \\sqrt{3} - 1\n$$\nTo obtain the final numerical answer, we evaluate this expression and round to four significant figures:\n$$\n\\delta_f = \\sqrt{3} - 1 \\approx 1.7320508 - 1 = 0.7320508\n$$\nRounding to four significant figures, the fifth significant digit is $5$, so we round up the fourth digit.\n$$\n\\delta_f \\approx 0.7321\n$$\nThis fractional change of over $73\\%$ indicates that the Coriolis parameter varies significantly with latitude, a critical factor for the accuracy of numerical ocean models.",
            "answer": "$$\\boxed{0.7321}$$"
        },
        {
            "introduction": "The most direct way to discretize a time derivative is often the forward Euler method, but its simplicity can be deceptive. This practice provides a rigorous analysis of this scheme applied to the core dynamics of inertial oscillations, which are governed by the Coriolis force. By deriving the method's amplification factor and phase error, you will uncover its inherent instability and non-physical energy growth, demonstrating why more sophisticated numerical treatments are essential for geophysical simulations .",
            "id": "3803906",
            "problem": "Consider a frictionless, horizontally uniform ocean parcel in a frame rotating with constant planetary vorticity, whose horizontal velocity vector is $\\mathbf{u}(t) = (u(t), v(t))$. The dynamics are governed by the linear ordinary differential equation (ODE)\n$$\n\\partial_{t}\\mathbf{u}(t) + f\\,\\hat{\\mathbf{k}}\\times\\mathbf{u}(t) = \\mathbf{0},\n$$\nwhere $f$ is the constant Coriolis parameter and $\\hat{\\mathbf{k}}$ is the up-axis unit vector. Let the time step be $\\Delta t > 0$ and define the non-dimensional step parameter $\\nu \\equiv f\\,\\Delta t$.\n\nStarting from first principles and core definitions appropriate to rotating-frame dynamics and consistent numerical time integration, perform the following:\n\n- Derive the explicit forward Euler time-stepping update for $\\mathbf{u}^{n} \\mapsto \\mathbf{u}^{n+1}$ that approximates the ODE over one time step $\\Delta t$.\n- Using a norm-based interpretation of amplification in the Euclidean sense, determine the per-step amplification factor $g(\\nu)$, defined as the ratio of the Euclidean norm of $\\mathbf{u}^{n+1}$ to that of $\\mathbf{u}^{n}$, for arbitrary $\\mathbf{u}^{n}\\neq\\mathbf{0}$.\n- Interpret the per-step action of the forward Euler update as a rotation composed with a uniform scaling in the horizontal plane. With angles measured in radians and the standard mathematical convention that positive angles correspond to counterclockwise rotation in the $(u,v)$-plane, compute the numerical per-step rotation angle and subtract the exact per-step rotation angle implied by the continuous dynamics over the same interval $\\Delta t$ to obtain the phase error $\\delta\\phi(\\nu)$, defined as the numerical rotation angle minus the exact rotation angle.\n\nExpress your final answer as a pair of closed-form analytic expressions, $(g(\\nu), \\delta\\phi(\\nu))$, in terms of $\\nu$. No numerical evaluation or rounding is required. Angles must be expressed in radians. The final pair should be given in simplest analytical form and contains no units inside the final boxed expressions.",
            "solution": "The governing linear ordinary differential equation is\n$$\n\\partial_{t}\\mathbf{u}(t) + f\\,\\hat{\\mathbf{k}}\\times\\mathbf{u}(t) = \\mathbf{0},\n$$\nwith constant $f$. Writing $\\mathbf{u} = (u, v)$ in the horizontal plane, the cross product $\\hat{\\mathbf{k}}\\times\\mathbf{u}$ equals $(-v, u)$. Therefore, the ODE in component form becomes\n$$\n\\frac{d}{dt}\\begin{pmatrix}u \\\\ v\\end{pmatrix} = -f\\,\\begin{pmatrix}-v \\\\ u\\end{pmatrix} = -f\\,\\mathbf{J}\\,\\begin{pmatrix}u \\\\ v\\end{pmatrix},\n$$\nwhere the skew-symmetric matrix $\\mathbf{J}$ is\n$$\n\\mathbf{J} \\equiv \\begin{pmatrix}0 & -1 \\\\ 1 & 0\\end{pmatrix}.\n$$\nThis $\\mathbf{J}$ satisfies $\\mathbf{J}^{2} = -\\mathbf{I}$, where $\\mathbf{I}$ is the identity matrix. The exact solution of the continuous system over a time interval $\\Delta t$ is a rigid rotation with angle $-f\\,\\Delta t$ (clockwise for $f>0$), since\n$$\n\\exp\\!\\left(-f\\,\\Delta t\\,\\mathbf{J}\\right) = \\mathbf{I}\\,\\cos(f\\,\\Delta t) - \\mathbf{J}\\,\\sin(f\\,\\Delta t),\n$$\nwhich is the rotation matrix with angle $-f\\,\\Delta t$.\n\nTo construct the forward Euler scheme, approximate the time derivative by a first-order forward difference:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^{n}}{\\Delta t} \\approx \\partial_{t}\\mathbf{u}(t^{n}).\n$$\nSubstituting the right-hand side of the ODE at time level $n$ gives\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^{n}}{\\Delta t} = -f\\,\\mathbf{J}\\,\\mathbf{u}^{n}.\n$$\nTherefore, the explicit update is\n$$\n\\mathbf{u}^{n+1} = \\left(\\mathbf{I} - f\\,\\Delta t\\,\\mathbf{J}\\right)\\mathbf{u}^{n} = \\left(\\mathbf{I} - \\nu\\,\\mathbf{J}\\right)\\mathbf{u}^{n},\n$$\nwhere $\\nu \\equiv f\\,\\Delta t$ is the non-dimensional step parameter.\n\nNext, determine the per-step amplification factor. Consider the Euclidean norm $\\|\\cdot\\|_{2}$. The amplification factor $g(\\nu)$ is defined as\n$$\ng(\\nu) \\equiv \\frac{\\|\\mathbf{u}^{n+1}\\|_{2}}{\\|\\mathbf{u}^{n}\\|_{2}} = \\frac{\\|(\\mathbf{I} - \\nu\\,\\mathbf{J})\\mathbf{u}^{n}\\|_{2}}{\\|\\mathbf{u}^{n}\\|_{2}}.\n$$\nBecause $\\mathbf{J}$ is orthogonal up to a sign ($\\mathbf{J}^{\\top}\\mathbf{J} = \\mathbf{I}$) and skew-symmetric ($\\mathbf{J}^{\\top} = -\\mathbf{J}$), we have\n$$\n(\\mathbf{I} - \\nu\\,\\mathbf{J})^{\\top}(\\mathbf{I} - \\nu\\,\\mathbf{J}) = \\mathbf{I} + \\nu^{2}\\,\\mathbf{J}^{\\top}\\mathbf{J} = \\mathbf{I} + \\nu^{2}\\,\\mathbf{I} = (1 + \\nu^{2})\\,\\mathbf{I}.\n$$\nThis shows that $(\\mathbf{I} - \\nu\\,\\mathbf{J})$ acts as a uniform scaling by the factor $\\sqrt{1 + \\nu^{2}}$ in the Euclidean norm, independent of the direction of $\\mathbf{u}^{n}$. Consequently,\n$$\ng(\\nu) = \\sqrt{1 + \\nu^{2}}.\n$$\n\nTo characterize the phase, it is convenient to represent the horizontal velocity as a complex scalar $z \\equiv u + i\\,v$, where $i$ is the imaginary unit. Under this representation, $\\mathbf{J}$ acting on $(u, v)$ corresponds to multiplication by $i$, because $\\mathbf{J}\\,(u, v)^{\\top} = (-v, u)^{\\top}$, and $i\\,(u + i\\,v) = -v + i\\,u$. The forward Euler update becomes\n$$\nz^{n+1} = z^{n} - \\nu\\,i\\,z^{n} = (1 - i\\,\\nu)\\,z^{n}.\n$$\nThus, one forward Euler step multiplies the complex state by the complex number $(1 - i\\,\\nu)$. The modulus of $(1 - i\\,\\nu)$ is $\\sqrt{1 + \\nu^{2}}$, consistent with the amplification factor derived above. The argument (principal value) is\n$$\n\\arg(1 - i\\,\\nu) = -\\arctan(\\nu),\n$$\nwith angles measured in radians and the standard counterclockwise-positive convention. Therefore, the numerical per-step rotation angle is $-\\arctan(\\nu)$.\n\nThe exact per-step rotation angle over the same interval $\\Delta t$ is $-f\\,\\Delta t = -\\nu$. By the stated definition, the phase error $\\delta\\phi(\\nu)$ is the numerical rotation angle minus the exact rotation angle:\n$$\n\\delta\\phi(\\nu) \\equiv \\left[-\\arctan(\\nu)\\right] - \\left[-\\nu\\right] = \\nu - \\arctan(\\nu).\n$$\n\nIn summary, the amplification factor and phase error as functions of $\\nu$ are\n$$\ng(\\nu) = \\sqrt{1 + \\nu^{2}}, \\qquad \\delta\\phi(\\nu) = \\nu - \\arctan(\\nu),\n$$\nwith angles in radians.",
            "answer": "$$\\boxed{\\left(\\sqrt{1 + \\nu^{2}}, \\nu - \\arctan(\\nu)\\right)}$$"
        },
        {
            "introduction": "Theoretical analysis provides indispensable insight, but the ultimate test of a numerical scheme is its performance in practice. This hands-on coding exercise challenges you to implement and compare two different discretizations of the Coriolis term: the unstable 'naive' forward Euler method and a 'structure-preserving' method designed to conserve energy. By simulating inertial motion and tracking the kinetic energy, you will gain a concrete, practical understanding of how numerical choices directly impact the physical realism and long-term stability of a model .",
            "id": "3803917",
            "problem": "Consider two-dimensional horizontal inertial motion on a constant-Coriolis-parameter plane (the f-plane approximation), with no pressure gradients and no friction. The governing momentum equations for the eastward and northward velocity components are the ordinary differential equations\n$$ \\frac{d u}{d t} = f\\, v, \\qquad \\frac{d v}{d t} = - f\\, u, $$\nwhere $u$ and $v$ are the horizontal velocity components expressed in $\\mathrm{m}\\ \\mathrm{s}^{-1}$, $t$ is time in $\\mathrm{s}$, and $f$ is the Coriolis parameter in $\\mathrm{s}^{-1}$. The continuous equations conserve the kinetic energy per unit mass,\n$$ K(t) = \\frac{1}{2}\\left(u(t)^2 + v(t)^2\\right), $$\nfor all $t$, due to the skew-symmetry of the linear Coriolis operator.\n\nYour task is to design, implement, and test a time-discrete numerical method that represents the Coriolis term in a way that exactly preserves the discrete kinetic energy $K_n = \\frac{1}{2}(u_n^2+v_n^2)$ up to floating-point machine precision at each discrete time $t_n = n\\,\\Delta t$. Starting from the above continuous equations and their structure, derive a discrete update that conserves $K_n$ by ensuring the discrete Coriolis operator remains skew-symmetric in the discrete sense. Then implement two methods:\n- A properly energy-conserving method that preserves $K_n$ to machine precision.\n- A naive explicit method that does not enforce skew-symmetry and generally fails to conserve energy over time.\n\nFor each method, numerically integrate the system for a specified number of time steps from a given initial condition $(u_0, v_0)$ and compute the maximum relative deviation of kinetic energy over the integration,\n$$ \\varepsilon = \\max_{0 \\le n \\le N} \\frac{\\left|K_n - K_0\\right|}{K_0}, $$\nwhich is a unitless scalar expressed as a decimal.\n\nUse the following test suite of parameter sets, spanning typical conditions, limiting cases, and edge scenarios. All velocities must be in $\\mathrm{m}\\ \\mathrm{s}^{-1}$, times in $\\mathrm{s}$, and the Coriolis parameter in $\\mathrm{s}^{-1}$:\n- Test A (mid-latitude, moderate time step): $f = 1.0\\times 10^{-4}\\ \\mathrm{s}^{-1}$, $\\Delta t = 900\\ \\mathrm{s}$, $N = 1000$, $u_0 = 0.5\\ \\mathrm{m}\\ \\mathrm{s}^{-1}$, $v_0 = -0.3\\ \\mathrm{m}\\ \\mathrm{s}^{-1}$.\n- Test B (equator, zero Coriolis parameter): $f = 0.0\\ \\mathrm{s}^{-1}$, $\\Delta t = 1800\\ \\mathrm{s}$, $N = 1000$, $u_0 = 1.2\\ \\mathrm{m}\\ \\mathrm{s}^{-1}$, $v_0 = -0.8\\ \\mathrm{m}\\ \\mathrm{s}^{-1}$.\n- Test C (large time step near half-turn): $f = 1.0\\times 10^{-4}\\ \\mathrm{s}^{-1}$, $\\Delta t = 28274\\ \\mathrm{s}$, $N = 10$, $u_0 = 0.7\\ \\mathrm{m}\\ \\mathrm{s}^{-1}$, $v_0 = 0.1\\ \\mathrm{m}\\ \\mathrm{s}^{-1}$.\n- Test D (Southern Hemisphere, negative Coriolis parameter): $f = -1.0\\times 10^{-4}\\ \\mathrm{s}^{-1}$, $\\Delta t = 1200\\ \\mathrm{s}$, $N = 500$, $u_0 = 0.9\\ \\mathrm{m}\\ \\mathrm{s}^{-1}$, $v_0 = 0.4\\ \\mathrm{m}\\ \\mathrm{s}^{-1}$.\n\nFor each test case, compute two floats:\n- $\\varepsilon_{\\mathrm{conserving}}$, the maximum relative energy deviation for the properly energy-conserving discretization.\n- $\\varepsilon_{\\mathrm{naive}}$, the maximum relative energy deviation for the naive explicit method.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a two-element comma-separated list of floats enclosed in square brackets. For example, the overall output must have the form\n$$ [\\,[\\varepsilon_{\\mathrm{conserving,A}},\\varepsilon_{\\mathrm{naive,A}}],\\,[\\varepsilon_{\\mathrm{conserving,B}},\\varepsilon_{\\mathrm{naive,B}}],\\,\\ldots\\,] $$\nwith no spaces. The floats must be printed in decimal or scientific notation as produced by the language's default or chosen float formatting.",
            "solution": "The problem requires the design and implementation of two numerical time-stepping schemes for the equations of inertial motion on an f-plane: one that is deliberately designed to conserve kinetic energy, and one naive scheme that is not.\n\nThe governing equations are a linear system of ordinary differential equations (ODEs):\n$$\n\\frac{d u}{d t} = f v \\\\\n\\frac{d v}{d t} = - f u\n$$\nwhere $u(t)$ and $v(t)$ are the velocity components, $t$ is time, and $f$ is the constant Coriolis parameter. This system can be written in vector form as $\\frac{d\\mathbf{u}}{dt} = \\mathbf{A}\\mathbf{u}$, where $\\mathbf{u} = \\begin{pmatrix} u \\\\ v \\end{pmatrix}$ and the Coriolis operator is represented by the matrix $\\mathbf{A} = \\begin{pmatrix} 0 & f \\\\ -f & 0 \\end{pmatrix}$.\n\nThe kinetic energy per unit mass is given by $K(t) = \\frac{1}{2}(u(t)^2 + v(t)^2) = \\frac{1}{2}\\mathbf{u}^T\\mathbf{u}$. Its time evolution is:\n$$ \\frac{dK}{dt} = u \\frac{du}{dt} + v \\frac{dv}{dt} = u(fv) + v(-fu) = fuv - fuv = 0 $$\nAlternatively, using matrix notation, $\\frac{dK}{dt} = \\frac{1}{2}\\frac{d}{dt}(\\mathbf{u}^T\\mathbf{u}) = \\mathbf{u}^T\\frac{d\\mathbf{u}}{dt} = \\mathbf{u}^T\\mathbf{A}\\mathbf{u}$. The matrix $\\mathbf{A}$ is skew-symmetric, meaning $\\mathbf{A}^T = -\\mathbf{A}$. For any vector $\\mathbf{u}$ and any skew-symmetric matrix $\\mathbf{A}$, the quadratic form $\\mathbf{u}^T\\mathbf{A}\\mathbf{u}$ is always zero. Thus, the skew-symmetry of the Coriolis operator is the fundamental reason for the conservation of kinetic energy in the continuous system. Our goal is to preserve this property in the discrete system.\n\nLet the discrete time be $t_n = n \\Delta t$, with velocity components $(u_n, v_n)$. The kinetic energy at time $t_n$ is $K_n = \\frac{1}{2}(u_n^2 + v_n^2)$.\n\n**1. A Naive Explicit Method (Forward Euler)**\n\nThe simplest explicit discretization is the Forward Euler method, where the time derivative is approximated by a forward difference and the right-hand side is evaluated at the current time step $n$.\n$$ \\frac{u_{n+1} - u_n}{\\Delta t} = f v_n $$\n$$ \\frac{v_{n+1} - v_n}{\\Delta t} = -f u_n $$\nThis yields the update rules:\n$$ u_{n+1} = u_n + f \\Delta t v_n $$\n$$ v_{n+1} = v_n - f \\Delta t u_n $$\nLet us analyze the change in discrete kinetic energy $K_{n+1} = \\frac{1}{2}(u_{n+1}^2 + v_{n+1}^2)$:\n$$ u_{n+1}^2 + v_{n+1}^2 = (u_n + f \\Delta t v_n)^2 + (v_n - f \\Delta t u_n)^2 $$\n$$ = (u_n^2 + 2 f \\Delta t u_n v_n + (f \\Delta t)^2 v_n^2) + (v_n^2 - 2 f \\Delta t u_n v_n + (f \\Delta t)^2 u_n^2) $$\n$$ = u_n^2 + v_n^2 + (f \\Delta t)^2 (u_n^2 + v_n^2) = (1 + (f \\Delta t)^2) (u_n^2 + v_n^2) $$\nThus, the kinetic energy at the next time step is related to the current one by:\n$$ K_{n+1} = K_n (1 + (f \\Delta t)^2) $$\nFor any non-zero $f$ and $\\Delta t$, the factor $(1 + (f \\Delta t)^2)$ is greater than $1$. This scheme, therefore, artificially generates energy at every step, leading to an exponential, non-physical growth of kinetic energy. It fails to preserve the skew-symmetry of the continuous operator.\n\n**2. An Energy-Conserving Method (Trapezoidal Rule)**\n\nTo construct an energy-conserving scheme, we must discretize the system in a way that preserves the skew-symmetric nature of the Coriolis operator. A standard method to achieve this for linear systems is the Trapezoidal Rule (also known as the Crank-Nicolson method), where the right-hand side is averaged over the time interval $[t_n, t_{n+1}]$.\n$$ \\frac{u_{n+1} - u_n}{\\Delta t} = f \\left(\\frac{v_n + v_{n+1}}{2}\\right) $$\n$$ \\frac{v_{n+1} - v_n}{\\Delta t} = -f \\left(\\frac{u_n + u_{n+1}}{2}\\right) $$\nTo verify energy conservation, we multiply the first equation by $(u_n + u_{n+1})$ and the second by $(v_n + v_{n+1})$ and add them:\n$$ \\frac{u_{n+1}^2 - u_n^2}{\\Delta t} + \\frac{v_{n+1}^2 - v_n^2}{\\Delta t} = f \\left(\\frac{v_n + v_{n+1}}{2}\\right)(u_n + u_{n+1}) - f \\left(\\frac{u_n + u_{n+1}}{2}\\right)(v_n + v_{n+1}) = 0 $$\nMultiplying by $\\frac{\\Delta t}{2}$ gives $\\frac{1}{2}(u_{n+1}^2 + v_{n+1}^2) - \\frac{1}{2}(u_n^2 + v_n^2) = 0$, which is $K_{n+1} - K_n = 0$. This scheme conserves kinetic energy exactly, $K_{n+1} = K_n$, up to machine floating-point precision.\n\nThis is an implicit scheme, as the unknown values $(u_{n+1}, v_{n+1})$ appear on both sides. We must solve a linear system for them. Let $\\alpha = \\frac{f \\Delta t}{2}$. The equations are:\n$$ u_{n+1} - \\alpha v_{n+1} = u_n + \\alpha v_n $$\n$$ \\alpha u_{n+1} + v_{n+1} = v_n - \\alpha u_n $$\nIn matrix form:\n$$ \\begin{pmatrix} 1 & -\\alpha \\\\ \\alpha & 1 \\end{pmatrix} \\begin{pmatrix} u_{n+1} \\\\ v_{n+1} \\end{pmatrix} = \\begin{pmatrix} 1 & \\alpha \\\\ -\\alpha & 1 \\end{pmatrix} \\begin{pmatrix} u_n \\\\ v_n \\end{pmatrix} $$\nThe inverse of the matrix on the left is $\\frac{1}{1+\\alpha^2}\\begin{pmatrix} 1 & \\alpha \\\\ -\\alpha & 1 \\end{pmatrix}$. Applying this to both sides gives the explicit update rule:\n$$ \\begin{pmatrix} u_{n+1} \\\\ v_{n+1} \\end{pmatrix} = \\frac{1}{1+\\alpha^2} \\begin{pmatrix} 1 & \\alpha \\\\ -\\alpha & 1 \\end{pmatrix} \\begin{pmatrix} 1 & \\alpha \\\\ -\\alpha & 1 \\end{pmatrix} \\begin{pmatrix} u_n \\\\ v_n \\end{pmatrix} = \\frac{1}{1+\\alpha^2} \\begin{pmatrix} 1-\\alpha^2 & 2\\alpha \\\\ -2\\alpha & 1-\\alpha^2 \\end{pmatrix} \\begin{pmatrix} u_n \\\\ v_n \\end{pmatrix} $$\nThis gives the final algorithm for the energy-conserving scheme:\n$$ u_{n+1} = \\frac{(1-\\alpha^2)u_n + 2\\alpha v_n}{1+\\alpha^2} $$\n$$ v_{n+1} = \\frac{-2\\alpha u_n + (1-\\alpha^2)v_n}{1+\\alpha^2} $$\nwith $\\alpha = f \\Delta t / 2$. This form will be used for implementation.\n\nFor the special case of $f=0$ (Test B), we have $\\alpha=0$. The naive method gives $u_{n+1}=u_n, v_{n+1}=v_n$. The conserving method also gives $u_{n+1}=u_n, v_{n+1}=v_n$. Both are exact for this case and should yield an energy deviation $\\varepsilon$ of $0$. For all other tests with $f \\ne 0$, we expect the naive scheme to produce a large $\\varepsilon_{\\mathrm{naive}}$, while the conserving scheme should yield an $\\varepsilon_{\\mathrm{conserving}}$ close to machine precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(method: str, f: float, dt: float, N: int, u0: float, v0: float) -> float:\n    \"\"\"\n    Numerically integrates the inertial motion equations and computes the maximum relative energy deviation.\n\n    Args:\n        method: The integration method to use ('naive' or 'conserving').\n        f: Coriolis parameter (s^-1).\n        dt: Time step (s).\n        N: Number of time steps.\n        u0: Initial eastward velocity (m/s).\n        v0: Initial northward velocity (m/s).\n\n    Returns:\n        The maximum relative deviation of kinetic energy over the integration.\n    \"\"\"\n    \n    k0 = 0.5 * (u0**2 + v0**2)\n    \n    # If initial kinetic energy is zero, any subsequent velocity results in infinite\n    # relative error. However, if u0=v0=0, velocity remains zero. Thus, deviation is 0.\n    if k0 == 0.0:\n        return 0.0\n\n    u_hist = np.zeros(N + 1, dtype=np.float64)\n    v_hist = np.zeros(N + 1, dtype=np.float64)\n    u_hist[0], v_hist[0] = u0, v0\n\n    if method == 'naive':\n        # Forward Euler method\n        for n in range(N):\n            u_prev, v_prev = u_hist[n], v_hist[n]\n            u_hist[n+1] = u_prev + f * dt * v_prev\n            v_hist[n+1] = v_prev - f * dt * u_prev\n    elif method == 'conserving':\n        # Trapezoidal method (Crank-Nicolson)\n        alpha = f * dt / 2.0\n        denom = 1.0 + alpha**2\n        \n        c1 = (1.0 - alpha**2) / denom\n        c2 = (2.0 * alpha) / denom\n\n        for n in range(N):\n            u_prev, v_prev = u_hist[n], v_hist[n]\n            u_hist[n+1] = c1 * u_prev + c2 * v_prev\n            v_hist[n+1] = -c2 * u_prev + c1 * v_prev\n    else:\n        raise ValueError(\"Unknown method specified.\")\n\n    k_hist = 0.5 * (u_hist**2 + v_hist**2)\n    \n    # Calculate max relative deviation, avoiding division by zero if k0 is zero (already handled)\n    rel_dev = np.abs(k_hist - k0) / k0\n    max_rel_dev = np.max(rel_dev)\n\n    return max_rel_dev\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs simulations, and prints results in the specified format.\n    \"\"\"\n    # Test cases: (f, dt, N, u0, v0)\n    test_cases = [\n        # Test A (mid-latitude, moderate time step)\n        (1.0e-4, 900.0, 1000, 0.5, -0.3),\n        # Test B (equator, zero Coriolis parameter)\n        (0.0, 1800.0, 1000, 1.2, -0.8),\n        # Test C (large time step near half-turn)\n        (1.0e-4, 28274.0, 10, 0.7, 0.1),\n        # Test D (Southern Hemisphere, negative Coriolis parameter)\n        (-1.0e-4, 1200.0, 500, 0.9, 0.4),\n    ]\n\n    results = []\n    for case in test_cases:\n        f_param, dt_param, N_param, u0_param, v0_param = case\n        \n        eps_conserving = run_simulation('conserving', f_param, dt_param, N_param, u0_param, v0_param)\n        eps_naive = run_simulation('naive', f_param, dt_param, N_param, u0_param, v0_param)\n        \n        results.append(f\"[{eps_conserving},{eps_naive}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}