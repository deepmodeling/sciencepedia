{
    "hands_on_practices": [
        {
            "introduction": "在数值计算中，减小步长 $h$ 似乎是提高精度的直观方法。然而，这只减少了截断误差，同时却放大了舍入误差的影响。本练习将通过一个物理相关的场景，推导并计算一个“最优”步长 $h^*$，在该步长下，这两种误差源达到平衡，从而使总误差最小化 。这个过程揭示了在有限精度计算中选择步长时需要进行的关键权衡。",
            "id": "3813087",
            "problem": "一条穿过中纬度区域的海洋学断面显示出由中尺度涡主导的变化。沿着一条笔直的纬向路径，将海面高度异常理想化为 $f(x) = \\sin(k x)$，其中 $k$ 是与涡旋场相关的波数。设主导涡旋波长为 $\\lambda = 100\\,\\mathrm{km}$，因此 $k = 2\\pi/\\lambda$。您希望使用基于 $x \\pm h$ 处采样的对称两点中心差分，计算在 $k x = \\pi/4$ 的点 $x$ 处的水平导数 $\\partial f/\\partial x$。假设算术运算遵循电气与电子工程师协会 (IEEE) 754 双精度模型，单位舍入误差为 $u = 2^{-53}$，并假设角度以弧度为单位度量。\n\n从泰勒级数和标准浮点舍入模型出发，通过平衡中心差分导数的截断误差和舍入误差，推导出作为步长 $h$ 函数的主阶总误差，并用此求得最优步长 $h^{*}$。然后，对于给定的 $k$ 和指定的计算点，数值计算 $h^{*}$ 的值。将您的最终数值答案四舍五入到三位有效数字，并以米为单位表示最优步长。\n\n最后，根据您的推导，简要评估在当前设置下，通过中心差分对 $f(x)$ 求导时，$1\\,\\mathrm{km}$、$5\\,\\mathrm{km}$ 和 $10\\,\\mathrm{km}$ 的实际水平网格间距是否接近最优步长 $h^{*}$，并指出在这些间距下，哪种误差源（截断误差或舍入误差）占主导地位。您的评估应是定性的；唯一的最终答案必须是您计算出的 $h^{*}$。",
            "solution": "在进行求解之前，对问题陈述的有效性进行评估。\n\n### 步骤 1：提取已知条件\n-   海面高度异常函数：$f(x) = \\sin(k x)$\n-   波数定义：$k = \\frac{2\\pi}{\\lambda}$\n-   主导涡旋波长：$\\lambda = 100\\,\\mathrm{km}$\n-   待求导数：$\\frac{\\partial f}{\\partial x}$\n-   计算点：一个点 $x$，满足 $kx = \\frac{\\pi}{4}$\n-   数值近似方法：对称两点中心差分，$\\frac{f(x+h) - f(x-h)}{2h}$\n-   步长：$h$\n-   计算算术模型：IEEE 754 双精度\n-   单位舍入误差：$u = 2^{-53}$\n-   角度单位：弧度\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n-   **科学依据：** 该问题坚实地植根于数值分析原理及其在物理海洋学中的应用。使用正弦函数模拟中尺度涡旋场是一种标准的简化方法，而有限差分格式中截断误差和舍入误差的分析是科学计算中的一个基本课题。指定波长为 $100\\,\\mathrm{km}$ 对于中纬度中尺度涡旋来说是物理上现实的。\n-   **适定性：** 该问题是适定的。它要求为一个明确定义的函数和数值方法推导最优步长，这是一个具有唯一预期解的标准问题。所有必要的参数（$f(x)$、$k$、$\\lambda$、$u$、计算点）都已提供。\n-   **客观性：** 问题陈述是客观的，使用了精确的数学和技术语言。它不含主观或基于观点的陈述。\n-   **完整性与一致性：** 该问题是自洽且内部一致的。它提供了推导最优步长 $h^*$ 并进行数值计算所需的所有信息。\n-   **现实性：** 参数和背景是现实的。双精度算术的使用、涡旋的物理尺度以及对实际网格间距的考虑都符合计算海洋学领域的实际情况。\n\n### 步骤 3：结论与行动\n该问题有效。这是一个应用于地球物理背景下的标准且定义明确的数值分析问题。将推导完整的解法。\n\n### 最优步长的推导\n\n任务是找到最优步长 $h^*$，使得在使用中心差分公式计算 $f(x)$ 导数时的总误差最小。总误差是截断误差和舍入误差的组合。\n\n**1. 截断误差**\n\n一阶导数 $f'(x)$ 的中心差分近似由下式给出：\n$$\nD_h f(x) = \\frac{f(x+h) - f(x-h)}{2h}\n$$\n为了分析截断误差，我们使用 $f(x+h)$ 和 $f(x-h)$ 在点 $x$ 附近的泰勒级数展开：\n$$\nf(x+h) = f(x) + h f'(x) + \\frac{h^2}{2!} f''(x) + \\frac{h^3}{3!} f'''(x) + \\frac{h^4}{4!} f^{(4)}(x) + O(h^5)\n$$\n$$\nf(x-h) = f(x) - h f'(x) + \\frac{h^2}{2!} f''(x) - \\frac{h^3}{3!} f'''(x) + \\frac{h^4}{4!} f^{(4)}(x) - O(h^5)\n$$\n用第一个展开式减去第二个展开式可得：\n$$\nf(x+h) - f(x-h) = 2h f'(x) + \\frac{2h^3}{3!} f'''(x) + O(h^5)\n$$\n$$\nf(x+h) - f(x-h) = 2h f'(x) + \\frac{h^3}{3} f'''(x) + O(h^5)\n$$\n重新整理以求解 $f'(x)$，我们可以看到中心差分公式与真实导数之间的关系：\n$$\nf'(x) = \\frac{f(x+h) - f(x-h)}{2h} - \\frac{h^2}{6} f'''(x) - O(h^4)\n$$\n截断误差 $E_T$ 是真实导数与其有限差分近似之间的差。该误差的主阶项为：\n$$\nE_T(h) = |D_h f(x) - f'(x)| \\approx \\frac{h^2}{6} |f'''(x)|\n$$\n\n**2. 舍入误差**\n\n在浮点运算中，函数 $f(z)$ 的计算不是精确的。我们用 $\\text{fl}(\\cdot)$ 表示其浮点表示。根据标准浮点算术模型，对于某个小的 $\\epsilon$ 且满足 $|\\epsilon| \\le u$（单位舍入误差），我们有：\n$$\n\\text{fl}(f(z)) = f(z)(1 + \\epsilon)\n$$\n计算出的中心差分 $\\hat{D}_h f(x)$ 使用了这些不精确的函数值：\n$$\n\\hat{D}_h f(x) = \\frac{\\text{fl}(f(x+h)) - \\text{fl}(f(x-h))}{2h} = \\frac{f(x+h)(1+\\epsilon_1) - f(x-h)(1+\\epsilon_2)}{2h}\n$$\n其中 $|\\epsilon_1|, |\\epsilon_2| \\le u$。此表达式中舍入误差的主要来源是当 $h$ 很小时，两个几乎相等的数 $f(x+h)$ 和 $f(x-h)$ 相减。分子中的绝对误差有界于：\n$$\n|\\left(f(x+h)(1+\\epsilon_1) - f(x-h)(1+\\epsilon_2)\\right) - \\left(f(x+h) - f(x-h)\\right)| = |f(x+h)\\epsilon_1 - f(x-h)\\epsilon_2|\n$$\n使用三角不等式，其上界为 $|f(x+h)||\\epsilon_1| + |f(x-h)||\\epsilon_2| \\le u(|f(x+h)|+|f(x-h)|)$。对于小步长 $h$，$f(x \\pm h) \\approx f(x)$，因此该误差约为 $2u|f(x)|$。导数最终计算中的舍入误差 $E_R(h)$ 是这个分子误差除以分母 $2h$：\n$$\nE_R(h) \\approx \\frac{2u|f(x)|}{2h} = \\frac{u|f(x)|}{h}\n$$\n\n**3. 总误差和最优步长**\n\n总误差 $E(h)$ 是截断误差和舍入误差的量值之和：\n$$\nE(h) \\approx E_T(h) + E_R(h) = \\frac{h^2}{6} |f'''(x)| + \\frac{u|f(x)|}{h}\n$$\n为了找到最小化此总误差的最优步长 $h^*$，我们将 $E(h)$ 对 $h$ 求导并令其结果为零：\n$$\n\\frac{dE}{dh} = \\frac{2h}{6} |f'''(x)| - \\frac{u|f(x)|}{h^2} = 0\n$$\n$$\n\\frac{h}{3} |f'''(x)| = \\frac{u|f(x)|}{h^2}\n$$\n求解 $h$，我们将其记为 $h^*$：\n$$\nh^{*3} = \\frac{3u|f(x)|}{|f'''(x)|} \\implies h^* = \\left( \\frac{3u|f(x)|}{|f'''(x)|} \\right)^{1/3}\n$$\n\n**4. 针对具体问题的数值计算**\n\n我们给定的函数是 $f(x) = \\sin(kx)$。我们需要它的三阶导数：\n- $f(x) = \\sin(kx)$\n- $f'(x) = k \\cos(kx)$\n- $f''(x) = -k^2 \\sin(kx)$\n- $f'''(x) = -k^3 \\cos(kx)$\n\n导数在点 $x$ 处计算，其中 $kx = \\frac{\\pi}{4}$。在此点：\n$$\n|f(x)| = |\\sin(kx)| = \\left|\\sin\\left(\\frac{\\pi}{4}\\right)\\right| = \\frac{\\sqrt{2}}{2}\n$$\n$$\n|f'''(x)| = |-k^3 \\cos(kx)| = k^3 \\left|\\cos\\left(\\frac{\\pi}{4}\\right)\\right| = k^3 \\frac{\\sqrt{2}}{2}\n$$\n将这些代入 $h^*$ 的表达式中：\n$$\nh^* = \\left( \\frac{3u \\left(\\frac{\\sqrt{2}}{2}\\right)}{k^3 \\left(\\frac{\\sqrt{2}}{2}\\right)} \\right)^{1/3} = \\left( \\frac{3u}{k^3} \\right)^{1/3} = \\frac{(3u)^{1/3}}{k}\n$$\n现在，我们代入给定的数值：\n- 双精度的单位舍入误差：$u = 2^{-53}$\n- 波长：$\\lambda = 100\\,\\mathrm{km} = 100 \\times 10^3\\,\\mathrm{m} = 10^5\\,\\mathrm{m}$\n- 波数：$k = \\frac{2\\pi}{\\lambda} = \\frac{2\\pi}{10^5}\\,\\mathrm{m}^{-1}$\n\n将这些值代入 $h^*$ 的公式中：\n$$\nh^* = \\frac{(3 \\times 2^{-53})^{1/3}}{\\frac{2\\pi}{10^5}} = \\frac{10^5}{2\\pi} (3 \\times 2^{-53})^{1/3}\n$$\n现在，我们计算数值：\n$$\nh^* \\approx \\frac{100000}{6.283185} \\cdot (1.44225) \\cdot (4.78216 \\times 10^{-6})\n$$\n$$\nh^* \\approx (15915.49) \\cdot (6.8988 \\times 10^{-6}) \\approx 0.110\\,\\mathrm{m}\n$$\n四舍五入到三位有效数字，最优步长为 $0.110$ 米。\n\n**5. 实际网格间距的评估**\n\n推导出的最优步长为 $h^* \\approx 0.110\\,\\mathrm{m}$。\n给出的实际网格间距为 $h_1 = 1\\,\\mathrm{km} = 1000\\,\\mathrm{m}$，$h_2 = 5\\,\\mathrm{km} = 5000\\,\\mathrm{m}$ 和 $h_3 = 10\\,\\mathrm{km} = 10000\\,\\mathrm{m}$。\n\n所有这些实际网格间距都远大于最优步长：$h_i \\gg h^*$。\n\n总误差为 $E(h) \\approx \\frac{h^2}{6} |f'''(x)| + \\frac{u|f(x)|}{h}$。第一项是截断误差 ($E_T \\propto h^2$)，第二项是舍入误差 ($E_R \\propto h^{-1}$)。最优步长 $h^*$ 是这两个误差贡献量级相当的点。\n\n- 对于 $h  h^*$，舍入误差项 ($h^{-1}$) 占主导地位。\n- 对于 $h > h^*$，截断误差项 ($h^2$) 占主导地位。\n\n由于实际的网格间距（$1\\,\\mathrm{km}$ 到 $10\\,\\mathrm{km}$）都远大于 $h^* \\approx 0.110\\,\\mathrm{m}$，因此在这些间距下计算导数的误差绝大部分由**截断误差**主导。相比之下，舍入误差可以忽略不计。这表明，在海洋模型的典型尺度上，有限差分导数精度的限制因素是泰勒级数的离散化，而不是浮点运算的精度。",
            "answer": "$$\\boxed{1.10 \\times 10^{-1}}$$"
        },
        {
            "introduction": "了解截断误差的结构，特别是其对步长 $h$ 的依赖性，使我们能够系统地提高近似的精度。理查森外推法 (Richardson extrapolation) 正是利用了这一点，它通过组合不同步长的计算结果来消除主导的误差项。在本练习中，你将应用该方法，将一个二阶精确的中心差分格式提升为四阶精度格式，并定量验证其在物理海洋学剖面数据上的有效性 。",
            "id": "3813062",
            "problem": "一个计算海洋学任务考虑了来自离散垂直剖面的水平流 $u(z)$ 的垂直切变 $u_z$。从一个足够光滑的函数 $u(z)$ 在目标深度 $z_0$ 的泰勒级数展开出发，分别使用均匀间距 $h$ 和 $h/2$ 构建 $u_z(z_0)$ 的两种不同有限差分近似。仅基于泰勒级数结构和消除主导误差项的要求，通过理查森外推法（Richardson extrapolation）组合这些近似来消除主导截断误差项。实现这种理查森外推估计，并利用泰勒级数确定外推导数近似中乘以 $h^4$ 的残余主导误差常数。\n\n您必须将此方法应用于从物理上合理的解析流剖面合成生成的离散剖面，以便可以获得精确的导数进行定量验证。对于两个振荡衰减剖面，角度必须以弧度处理。以 $\\mathrm{s}^{-1}$ 为单位报告所有切变量，作为纯十进制数，输出中不嵌入单位。\n\n对于下面列出的每个测试用例，计算：\n1. 从在 $z_0 \\pm h$ 和 $z_0 \\pm h/2$ 处采集的离散样本得到的 $u_z(z_0)$ 的理查森外推估计值。\n2. 该估计值相对于解析计算的精确 $u_z(z_0)$ 的绝对误差。\n3. 外推后泰勒级数的残余主导误差常数，表示为系数 $C$，使得对于固定的 $z_0$ 和小的 $h$，主导截断误差的行为类似于 $C h^4$。提供解析推导的常数 $C_{\\mathrm{theory}}$ 和针对所选 $h$ 的经验估计 $C_{\\mathrm{numeric}} = \\left(u_z^{\\mathrm{extrap}}(z_0) - u_z^{\\mathrm{exact}}(z_0)\\right)/h^4$。\n\n所有角度均为弧度。所有切变量必须以 $\\mathrm{s}^{-1}$ 为单位表示为十进制数。不要四舍五入；输出原始浮点数。离散采样将在距 $z_0$ 的指定偏移处直接执行，无需任何插值。\n\n测试套件：\n- 用例A（振荡衰减，中等分辨率）：$u(z) = U_0 \\exp(-z/D)\\cos(b z)$，其中 $U_0 = 0.5\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$，$D = 50\\,\\mathrm{m}$，$b = \\pi/100\\,\\mathrm{rad}\\,\\mathrm{m}^{-1}$，$z_0 = 100\\,\\mathrm{m}$，粗略间距 $h = 20\\,\\mathrm{m}$。\n- 用例B（振荡衰减，粗糙分辨率）：$u(z) = U_0 \\exp(-z/D)\\cos(b z)$，其中 $U_0 = 0.3\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$，$D = 30\\,\\mathrm{m}$，$b = \\pi/50\\,\\mathrm{rad}\\,\\mathrm{m}^{-1}$，$z_0 = 200\\,\\mathrm{m}$，粗略间距 $h = 100\\,\\mathrm{m}$。\n- 用例C（四次多项式剖面，误差边界情况）：$u(z) = \\alpha z^4 + \\beta z^3 + \\gamma$，其中 $\\alpha = 2.0\\times 10^{-12}\\,\\mathrm{s}^{-1}\\,\\mathrm{m}^{-3}$，$\\beta = -1.0\\times 10^{-9}\\,\\mathrm{s}^{-1}\\,\\mathrm{m}^{-2}$，$\\gamma = 0.1\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$，$z_0 = 50\\,\\mathrm{m}$，粗略间距 $h = 10\\,\\mathrm{m}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个包含四个十进制数 $[u_z^{\\mathrm{extrap}}, |\\mathrm{error}|, C_{\\mathrm{theory}}, C_{\\mathrm{numeric}}]$ 的子列表。例如，整体输出格式必须为 $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3]]$ 的形式，其中所有条目均为浮点数。",
            "solution": "该问题要求为水平流剖面 $u(z)$ 的垂直切变 $u_z(z_0) = \\frac{du}{dz}\\rvert_{z=z_0}$ 构建并应用一个高阶有限差分格式。指定的方法是基于两个中心差分近似的理查森外推法。我们还必须推导所得外推公式的主阶截断误差。\n\n首先，我们利用一个足够光滑的函数 $u(z)$ 在点 $z_0$ 附近的泰勒级数展开来建立中心差分近似及其误差结构。$u(z_0+h)$ 和 $u(z_0-h)$ 的展开式为：\n$$u(z_0+h) = u(z_0) + h u'(z_0) + \\frac{h^2}{2!}u''(z_0) + \\frac{h^3}{3!}u'''(z_0) + \\frac{h^4}{4!}u''''(z_0) + \\frac{h^5}{5!}u'''''(z_0) + O(h^6)$$\n$$u(z_0-h) = u(z_0) - h u'(z_0) + \\frac{h^2}{2!}u''(z_0) - \\frac{h^3}{3!}u'''(z_0) + \\frac{h^4}{4!}u''''(z_0) - \\frac{h^5}{5!}u'''''(z_0) + O(h^6)$$\n从第一个方程中减去第二个方程，可以消除偶数次幂的导数项：\n$$u(z_0+h) - u(z_0-h) = 2h u'(z_0) + \\frac{2h^3}{3!}u'''(z_0) + \\frac{2h^5}{5!}u'''''(z_0) + O(h^7)$$\n求解 $u'(z_0)$ 可得：\n$$u'(z_0) = \\frac{u(z_0+h) - u(z_0-h)}{2h} - \\frac{h^2}{6}u'''(z_0) - \\frac{h^4}{120}u'''''(z_0) - O(h^6)$$\n令 $F(h)$ 表示步长为 $h$ 的 $u'(z_0)$ 的二阶中心差分近似：\n$$F(h) = \\frac{u(z_0+h) - u(z_0-h)}{2h}$$\n真实导数 $u'(z_0)$ 可以用这个近似表示为一个误差级数：\n$$u'(z_0) = F(h) - C_1 h^2 - C_2 h^4 - O(h^6)$$\n其中误差系数为 $C_1 = \\frac{u'''(z_0)}{6}$ 和 $C_2 = \\frac{u'''''(z_0)}{120}$。\n\n问题要求构建两种这样的近似，一种使用粗略间距 $h$，记为 $F_h$，另一种使用更精细的间距 $h/2$，记为 $F_{h/2}$。它们与精确导数 $u'(z_0)$ 的关系是：\n$$F_h = u'(z_0) + C_1 h^2 + C_2 h^4 + O(h^6) \\quad (1)$$\n$$F_{h/2} = u'(z_0) + C_1 \\left(\\frac{h}{2}\\right)^2 + C_2 \\left(\\frac{h}{2}\\right)^4 + O(h^6) = u'(z_0) + \\frac{1}{4}C_1 h^2 + \\frac{1}{16}C_2 h^4 + O(h^6) \\quad (2)$$\n为了消除主导误差项 $C_1 h^2$，我们寻求 $F_h$ 和 $F_{h/2}$ 的线性组合。将方程 $(2)$ 乘以 $4$ 并减去方程 $(1)$，得到：\n$$4F_{h/2} - F_h = \\left(4u'(z_0) + C_1 h^2 + \\frac{1}{4}C_2 h^4 \\right) - \\left(u'(z_0) + C_1 h^2 + C_2 h^4 \\right) + O(h^6)$$\n$$4F_{h/2} - F_h = 3u'(z_0) - \\frac{3}{4}C_2 h^4 + O(h^6)$$\n求解 $u'(z_0)$ 得到理查森外推估计值 $u_z^{\\mathrm{extrap}}(z_0)$：\n$$u_z^{\\mathrm{extrap}}(z_0) = \\frac{4F_{h/2} - F_h}{3}$$\n这个新估计的截断误差是：\n$$u_z^{\\mathrm{extrap}}(z_0) - u'(z_0) = -\\frac{1}{4}C_2 h^4 + O(h^6)$$\n代入 $C_2 = \\frac{u'''''(z_0)}{120}$ 的表达式，我们得到主导误差项：\n$$\\text{Error} = -\\frac{1}{4} \\left(\\frac{u'''''(z_0)}{120}\\right) h^4 + O(h^6) = -\\frac{u'''''(z_0)}{480} h^4 + O(h^6)$$\n因此，解析推导出的主导误差常数为 $C_{\\mathrm{theory}} = -\\frac{u'''''(z_0)}{480}$。\n\n为了对给定的测试用例执行计算，需要执行以下步骤：\n1.  对于每个剖面 $u(z)$，确定其一阶导数 $u'(z)$ 和五阶导数 $u'''''(z)$ 的解析表达式。\n    - 对于振荡衰减剖面 $u(z) = U_0 e^{-z/D}\\cos(bz)$，可以通过考虑复函数 $w(z) = U_0 e^{(a+ib)z}$ 的实部来高效地求导，其中 $a = -1/D$。其 $n$ 阶导数为 $u^{(n)}(z) = \\text{Re}\\left(U_0(a+ib)^n e^{(a+ib)z}\\right)$。\n    - 对于多项式剖面 $u(z) = \\alpha z^4 + \\beta z^3 + \\gamma$，导数通过标准微分法求得。值得注意的是，对于此剖面，$u'''''(z) = 0$，这意味着理论误差为零。\n2.  计算精确切变 $u_z^{\\mathrm{exact}}(z_0) = u'(z_0)$。\n3.  计算两个中心差分近似：$F_h = \\frac{u(z_0+h) - u(z_0-h)}{2h}$ 和 $F_{h/2} = \\frac{u(z_0+h/2) - u(z_0-h/2)}{h}$。\n4.  计算理查森外推估计值 $u_z^{\\mathrm{extrap}} = \\frac{4F_{h/2} - F_h}{3}$。\n5.  计算估计的绝对误差：$|\\mathrm{error}| = |u_z^{\\mathrm{extrap}} - u_z^{\\mathrm{exact}}|$。\n6.  计算理论误差常数：$C_{\\mathrm{theory}} = -u'''''(z_0)/480$。\n7.  计算经验误差常数：$C_{\\mathrm{numeric}} = (u_z^{\\mathrm{extrap}} - u_z^{\\mathrm{exact}})/h^4$。对于多项式情况，由于误差恰好为零，$C_{\\mathrm{numeric}}$ 也为零。\n\n对每个测试用例执行这些步骤，以生成所需的一组四个值：$[u_z^{\\mathrm{extrap}}, |\\mathrm{error}|, C_{\\mathrm{theory}}, C_{\\mathrm{numeric}}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries outside the Python standard library are permitted.\n\ndef u_osc(z, U0, D, b):\n    \"\"\"Computes the oscillatory-decaying profile u(z).\"\"\"\n    return U0 * np.exp(-z/D) * np.cos(b*z)\n\ndef du_osc_dz(z, U0, D, b):\n    \"\"\"Computes the exact first derivative of the oscillatory profile.\"\"\"\n    a = -1.0/D\n    return U0 * np.exp(a*z) * (a * np.cos(b*z) - b * np.sin(b*z))\n\ndef d5u_osc_dz5(z, U0, D, b):\n    \"\"\"Computes the exact fifth derivative of the oscillatory profile.\"\"\"\n    a = -1.0/D\n    # (a+ib)^5 = c_re + i * c_im\n    c_re = a**5 - 10*a**3*b**2 + 5*a*b**4\n    c_im = 5*a**4*b - 10*a**2*b**3 + b**5\n    # d5u/dz5 = Re( U0 * (c_re + i*c_im) * exp(az) * (cos(bz) + i*sin(bz)) )\n    return U0 * np.exp(a*z) * (c_re * np.cos(b*z) - c_im * np.sin(b*z))\n\ndef u_poly(z, alpha, beta, gamma):\n    \"\"\"Computes the quartic polynomial profile u(z).\"\"\"\n    return alpha * z**4 + beta * z**3 + gamma\n\ndef du_poly_dz(z, alpha, beta, gamma):\n    \"\"\"Computes the exact first derivative of the polynomial profile.\"\"\"\n    return 4 * alpha * z**3 + 3 * beta * z**2\n\ndef d5u_poly_dz5(z, alpha, beta, gamma):\n    \"\"\"Computes the exact fifth derivative of the polynomial profile.\"\"\"\n    return 0.0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (oscillatory-decaying, moderate resolution)\n        {'type': 'osc', 'params': {'U0': 0.5, 'D': 50, 'b': np.pi/100}, 'z0': 100, 'h': 20},\n        # Case B (oscillatory-decaying, coarse resolution)\n        {'type': 'osc', 'params': {'U0': 0.3, 'D': 30, 'b': np.pi/50}, 'z0': 200, 'h': 100},\n        # Case C (quartic polynomial profile, error edge case)\n        {'type': 'poly', 'params': {'alpha': 2.0e-12, 'beta': -1.0e-9, 'gamma': 0.1}, 'z0': 50, 'h': 10},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        z0, h = case['z0'], case['h']\n        params = case['params']\n        \n        if case['type'] == 'osc':\n            u_func = u_osc\n            du_func = du_osc_dz\n            d5u_func = d5u_osc_dz5\n        else: # 'poly'\n            u_func = u_poly\n            du_func = du_poly_dz\n            d5u_func = d5u_poly_dz5\n\n        # 1. Compute exact shear at z0\n        uz_exact = du_func(z0, **params)\n\n        # 2. Compute two central difference approximations\n        F_h = (u_func(z0 + h, **params) - u_func(z0 - h, **params)) / (2*h)\n        h_half = h / 2.0\n        F_h_half = (u_func(z0 + h_half, **params) - u_func(z0 - h_half, **params)) / (h)\n\n        # 3. Compute Richardson-extrapolated estimate\n        uz_extrap = (4.0 * F_h_half - F_h) / 3.0\n\n        # 4. Compute absolute error\n        abs_error = np.abs(uz_extrap - uz_exact)\n        \n        # 5. Compute theoretical leading error constant\n        d5u_at_z0 = d5u_func(z0, **params)\n        C_theory = -d5u_at_z0 / 480.0\n\n        # 6. Compute empirical estimate of the error constant\n        error_val = uz_extrap - uz_exact\n        if h == 0:\n            C_numeric = 0.0 if error_val == 0.0 else np.inf\n        else:\n            C_numeric = error_val / (h**4)\n\n        results.append([uz_extrap, abs_error, C_theory, C_numeric])\n\n    # Final print statement in the exact required format.\n    # We construct the string manually to avoid spaces introduced by str(list).\n    print(\"[\" + \",\".join([f\"[{','.join(map(str, sublist))}]\" for sublist in results]) + \"]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在建立计算模型时，一个核心的实际问题是：需要多密的网格才能保证计算结果达到所需的精度？本练习将从泰勒级数的拉格朗日余项形式出发，推导严格的截断误差界。然后，你将利用这些误差界来确定满足给定误差容限 $\\varepsilon$ 所需的最小网格点数，将抽象的误差分析理论直接应用于计算网格设计的实际任务中 。",
            "id": "3813084",
            "problem": "在计算海洋学中，考虑一个一维水平断面，其中光滑标量场 $f(x)$ 表示沿距离 $x$ 的某一海水属性（例如，沿航船轨迹测量的温度或盐度）。您的目标是在间距为 $h$ 的均匀网格上近似 $f(x)$ 的空间导数，并保证导数近似的绝对误差受用户选择的容差 $\\varepsilon$ 的限制。给定 $k$ 阶导数的一致界 $M_k$，即对于目标区间内的所有 $x$，都有 $|f^{(k)}(x)| \\le M_k$。您必须使用带有拉格朗日余项形式的泰勒级数展开作为推导的基本依据。\n\n您的任务是：\n- 仅从带有拉格朗日余项的泰勒级数定义以及对 $f(x)$ 的标准光滑性假设出发，为以下每种有限差分导数近似推导其逐点截断误差的严格界：\n  1. 一阶导数 $f'(x)$ 的向前差分近似。\n  2. 一阶导数 $f'(x)$ 的中心差分近似。\n  3. 二阶导数 $f''(x)$ 的中心差分近似。\n- 从每个界推导出充分的网格加密准则，该准则表示为网格间距 $h$ 的上限，以确保在域内部各处的绝对误差小于或等于容差 $\\varepsilon$。用 $M_k$ 和 $\\varepsilon$ 表示所得约束，并明确指出每种格式适用的 $k$ 值。\n- 将间距约束转换为用均匀网格覆盖长度为 $L$ 的有限域所需的最小网格点数 $N_{\\text{points}}$。使用 $N_{\\text{segments}} = \\lceil L / h \\rceil$ 和 $N_{\\text{points}} = N_{\\text{segments}} + 1$，并强制执行每种格式在内部点上有效所需的最小点数：\n  - 对于 $f'(x)$ 的向前差分，要求至少 $2$ 个网格点。\n  - 对于 $f'(x)$ 的中心差分，要求至少 $3$ 个网格点。\n  - 对于 $f''(x)$ 的中心差分，要求至少 $3$ 个网格点。\n- 指明并正确处理 $M_k = 0$ 的特殊情况。解释其含义，并为每种格式指明在此情况下应选择的 $N_{\\text{points}}$。\n\n所有量均为纯数学量，应进行符号处理，但域长度 $L$ 是一个物理长度。域长度 $L$ 必须以米为单位解释，并以米（$\\mathrm{m}$）为单位进行数值提供。容差 $\\varepsilon$ 是导数近似绝对误差的界，以纯数形式给出，其单位由导数隐含（例如，一阶空间导数为 $\\mathrm{(属性)}/\\mathrm{m}$，二阶空间导数为 $\\mathrm{(属性)}/\\mathrm{m}^2$）。您的程序必须只输出整数（所需的网格点数），这些是无量纲的计数，因此最终输出中不需要进行单位转换。\n\n在一个完整、可运行的程序中实现您的推导算法。使用以下测试用例集，每个用例都以元组形式给出，描述了格式、域长度 $L$、误差容差 $\\varepsilon$ 和导数界 $M_k$：\n\n- A例（正常路径）：格式为中心一阶导数，$L = 10^3$ $\\mathrm{m}$，$\\varepsilon = 10^{-5}$，$M_3 = 10^{-8}$。\n- B例（高加密需求）：格式为向前一阶导数，$L = 5 \\times 10^2$ $\\mathrm{m}$，$\\varepsilon = 10^{-6}$，$M_2 = 10^{-3}$。\n- C例（中心二阶导数）：格式为中心二阶导数，$L = 2 \\times 10^3$ $\\mathrm{m}$，$\\varepsilon = 10^{-4}$，$M_4 = 10^{-6}$。\n- D例（退化界）：格式为中心一阶导数，$L = 3 \\times 10^2$ $\\mathrm{m}$，$\\varepsilon = 10^{-5}$，$M_3 = 0$。\n\n您的程序应为每个用例计算最小整数 $N_{\\text{points}}$，以确保相应的误差界在整个域上小于或等于 $\\varepsilon$。当 $M_k = 0$ 时，选择该格式所需的最小点数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[n_A,n_B,n_C,n_D]$），每个条目是按 A、B、C、D 顺序计算的相应案例的 $N_{\\text{points}}$。所有输入值都应视为正实数，但 $M_k$ 可能为零。",
            "solution": "目标是推导离散化长度为 $L$ 的一维域所需的最小网格点数 $N_{\\text{points}}$，使得有限差分近似的截断误差受给定容差 $\\varepsilon$ 的限制。该推导将基于带有拉格朗日余项形式的泰勒级数展开。我们已知函数 $f(x)$ 的 $k$ 阶导数的界 $M_k$，即 $|f^{(k)}(x)| \\le M_k$。\n\n基本工具是泰勒定理。对于一个足够光滑的函数 $f(x)$，其在点 $x_0$ 附近的展开式为：\n$$f(x) = \\sum_{n=0}^{p} \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + R_{p+1}(x)$$\n拉格朗日余项 $R_{p+1}(x)$ 的形式是：\n$$R_{p+1}(x) = \\frac{f^{(p+1)}(\\xi)}{(p+1)!}(x-x_0)^{p+1}$$\n其中 $\\xi$ 介于 $x_0$ 和 $x$ 之间。我们将使用此定理来分析三种常见有限差分格式的截断误差。\n\n**1. 一阶导数 $f'(x)$ 的向前差分近似**\n\n向前差分公式使用 $x$ 和 $x+h$ 处的值来近似一阶导数 $f'(x)$：\n$$f'(x) \\approx \\frac{f(x+h) - f(x)}{h}$$\n为了求截断误差，我们使用泰勒定理将 $f(x+h)$ 在 $x$ 附近展开至含二阶导数的项：\n$$f(x+h) = f(x) + f'(x)h + \\frac{f''(\\xi)}{2!}h^2$$\n对于某个 $\\xi \\in (x, x+h)$。重新整理此方程以解出 $f'(x)$，得到：\n$$f'(x) = \\frac{f(x+h) - f(x)}{h} - \\frac{f''(\\xi)}{2}h$$\n截断误差 $E_{\\text{FD}}$ 是真实导数与其近似值之间的差：\n$$E_{\\text{FD}} = f'(x) - \\left( \\frac{f(x+h) - f(x)}{h} \\right) = - \\frac{f''(\\xi)}{2}h$$\n因此，绝对误差可以使用给定的常数 $M_2$ 来界定：\n$$|E_{\\text{FD}}| = \\left| - \\frac{f''(\\xi)}{2}h \\right| = \\frac{|f''(\\xi)|}{2}h \\le \\frac{M_2}{2}h$$\n为确保此误差不超过容差 $\\varepsilon$，我们施加条件：\n$$\\frac{M_2}{2}h \\le \\varepsilon$$\n对于 $M_2  0$，这产生了对网格间距 $h$ 的约束：\n$$h \\le \\frac{2\\varepsilon}{M_2}$$\n\n**2. 一阶导数 $f'(x)$ 的中心差分近似**\n\n$f'(x)$ 的中心差分公式使用 $x-h$ 和 $x+h$ 处的值：\n$$f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}$$\n为分析此格式的误差，我们将 $f(x+h)$ 和 $f(x-h)$ 在 $x$ 附近展开至三阶导数项：\n$$f(x+h) = f(x) + f'(x)h + \\frac{f''(x)}{2}h^2 + \\frac{f'''(\\xi_1)}{6}h^3, \\quad \\text{for } \\xi_1 \\in (x, x+h)$$\n$$f(x-h) = f(x) - f'(x)h + \\frac{f''(x)}{2}h^2 - \\frac{f'''(\\xi_2)}{6}h^3, \\quad \\text{for } \\xi_2 \\in (x-h, x)$$\n第一个展开式减去第二个展开式，消去了 $h$ 的偶次幂项：\n$$f(x+h) - f(x-h) = 2f'(x)h + \\frac{h^3}{6}(f'''(\\xi_1) + f'''(\\xi_2))$$\n解出 $f'(x)$：\n$$f'(x) = \\frac{f(x+h) - f(x-h)}{2h} - \\frac{h^2}{12}(f'''(\\xi_1) + f'''(\\xi_2))$$\n如果 $f'''(x)$ 是连续的，根据介值定理，必然存在一点 $\\xi \\in (x-h, x+h)$ 使得 $\\frac{f'''(\\xi_1) + f'''(\\xi_2)}{2} = f'''(\\xi)$。截断误差 $E_{\\text{CD1}}$ 变为：\n$$E_{\\text{CD1}} = -\\frac{f'''(\\xi)}{6}h^2$$\n绝对误差使用 $M_3$ 界定：\n$$|E_{\\text{CD1}}| = \\frac{|f'''(\\xi)|}{6}h^2 \\le \\frac{M_3}{6}h^2$$\n我们要求 $|E_{\\text{CD1}}| \\le \\varepsilon$，对于 $M_3  0$，这导致以下约束：\n$$\\frac{M_3}{6}h^2 \\le \\varepsilon \\implies h \\le \\sqrt{\\frac{6\\varepsilon}{M_3}}$$\n\n**3. 二阶导数 $f''(x)$ 的中心差分近似**\n\n$f''(x)$ 的中心差分近似是：\n$$f''(x) \\approx \\frac{f(x+h) - 2f(x) + f(x-h)}{h^2}$$\n我们使用泰勒展开至四阶导数项：\n$$f(x+h) = f(x) + f'(x)h + \\frac{f''(x)}{2}h^2 + \\frac{f'''(x)}{6}h^3 + \\frac{f^{(4)}(\\xi_1)}{24}h^4$$\n$$f(x-h) = f(x) - f'(x)h + \\frac{f''(x)}{2}h^2 - \\frac{f'''(x)}{6}h^3 + \\frac{f^{(4)}(\\xi_2)}{24}h^4$$\n将这两个展开式相加，消去了 $h$ 的奇次幂项：\n$$f(x+h) + f(x-h) = 2f(x) + f''(x)h^2 + \\frac{h^4}{24}(f^{(4)}(\\xi_1) + f^{(4)}(\\xi_2))$$\n解出 $f''(x)$：\n$$f''(x) = \\frac{f(x+h) - 2f(x) + f(x-h)}{h^2} - \\frac{h^2}{24}(f^{(4)}(\\xi_1) + f^{(4)}(\\xi_2))$$\n对连续的 $f^{(4)}(x)$ 再次使用介值定理，存在一个 $\\xi \\in (x-h, x+h)$ 使得截断误差 $E_{\\text{CD2}}$ 为：\n$$E_{\\text{CD2}} = -\\frac{f^{(4)}(\\xi)}{12}h^2$$\n绝对误差使用 $M_4$ 界定：\n$$|E_{\\text{CD2}}| = \\frac{|f^{(4)}(\\xi)|}{12}h^2 \\le \\frac{M_4}{12}h^2$$\n我们要求 $|E_{\\text{CD2}}| \\le \\varepsilon$，对于 $M_4  0$，这给出了约束：\n$$\\frac{M_4}{12}h^2 \\le \\varepsilon \\implies h \\le \\sqrt{\\frac{12\\varepsilon}{M_4}}$$\n\n**$M_k = 0$ 的特殊情况**\n\n如果相关的导数界 $M_k$ 为零，则 $|f^{(k)}(x)| \\le 0$，这意味着对所有 $x$ 都有 $f^{(k)}(x) = 0$。这表示 $f(x)$ 是一个次数至多为 $k-1$ 的多项式。\n- 对于向前差分（$k=2$），$M_2=0$ 意味着 $f''(x)=0$，所以 $f(x)$ 是线性的。该公式是精确的。\n- 对于中心一阶导数（$k=3$），$M_3=0$ 意味着 $f'''(x)=0$，所以 $f(x)$ 是二次的。该公式是精确的。\n- 对于中心二阶导数（$k=4$），$M_4=0$ 意味着 $f^{(4)}(x)=0$，所以 $f(x)$ 是三次的。该公式是精确的。\n在所有这些情况下，对于任何网格间距 $h > 0$，截断误差恒为零。因此，对 $h$ 的约束是平凡满足的。为了获得确定的点数，我们选择定义每种格式的模板所需的最小网格点数。题目说明了这些最小值：向前差分为 $2$，中心差分格式为 $3$。\n\n**计算网格点数 $N_{\\text{points}}$**\n\n为确保满足误差条件，网格间距 $h$ 必须小于或等于我们为每种格式推导出的最大值 $h_{\\max}$。为了最小化网格点数，我们必须选择尽可能大的间距，因此我们选择 $h = h_{\\max}$。\n长度为 $L$ 的域必须由整数个段 $N_{\\text{segments}}$ 覆盖。对于选定的间距 $h$，段数必须至少为 $L/h$。由于 $N_{\\text{segments}}$ 必须是整数，我们有 $N_{\\text{segments}} = \\lceil L/h \\rceil$。一个有 $N_{\\text{segments}}$ 个段的网格有 $N_{\\text{points}} = N_{\\text{segments}} + 1$ 个点。\n代入 $h = h_{\\max}$，所需的点数为：\n$$N_{\\text{points\\_calc}} = \\left\\lceil \\frac{L}{h_{\\max}} \\right\\rceil + 1$$\n这个计算出的值必须至少是格式本身有效所需的最小点数。因此，最终的点数是：\n$$N_{\\text{points}} = \\max(\\text{min\\_points\\_for\\_scheme}, N_{\\text{points\\_calc}})$$\n如果 $M_k=0$，$h_{\\max} \\to \\infty$，导致 $N_{\\text{points\\_calc}}$ 为 $1$。$\\max$ 函数随后会正确地选择格式所需的最小点数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the minimum number of grid points for several finite difference\n    approximation scenarios based on Taylor series error bounds.\n    \"\"\"\n    \n    # Each tuple contains: (scheme_name, L, epsilon, M_k)\n    # L: domain length in meters\n    # epsilon: absolute error tolerance\n    # M_k: bound on the k-th derivative\n    test_cases = [\n        ('centered_first', 1e3, 1e-5, 1e-8),      # Case A\n        ('forward_first', 5e2, 1e-6, 1e-3),       # Case B\n        ('centered_second', 2e3, 1e-4, 1e-6),     # Case C\n        ('centered_first', 3e2, 1e-5, 0),          # Case D\n    ]\n\n    results = []\n    \n    # Scheme parameters: (minimum points, relevant derivative order k)\n    scheme_params = {\n        'forward_first': {'min_points': 2},\n        'centered_first': {'min_points': 3},\n        'centered_second': {'min_points': 3},\n    }\n\n    for scheme, L, eps, Mk in test_cases:\n        \n        min_points = scheme_params[scheme]['min_points']\n\n        # Handle the special case where the derivative bound Mk is zero.\n        # This implies the finite difference formula is exact for any h > 0.\n        # Thus, we only need the minimum number of points to define the stencil.\n        if Mk == 0:\n            results.append(min_points)\n            continue\n\n        # Calculate the maximum allowed grid spacing h_max based on the scheme.\n        if scheme == 'forward_first':\n            # h_max = 2 * epsilon / M2\n            h_max = 2.0 * eps / Mk\n        elif scheme == 'centered_first':\n            # h_max = sqrt(6 * epsilon / M3)\n            h_max = np.sqrt(6.0 * eps / Mk)\n        elif scheme == 'centered_second':\n            # h_max = sqrt(12 * epsilon / M4)\n            h_max = np.sqrt(12.0 * eps / Mk)\n        else:\n            # This case should not be reached with the given test_cases.\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n\n        # The number of segments must be an integer, and cover the whole domain L.\n        # To achieve a grid spacing of h = h_max, we need at least L/h_max segments.\n        # We use ceiling to get the smallest integer number of segments.\n        num_segments = np.ceil(L / h_max)\n        \n        # The number of points is one more than the number of segments.\n        num_points_calculated = int(num_segments) + 1\n        \n        # The final number of points must also satisfy the minimum requirement for the scheme.\n        final_num_points = max(min_points, num_points_calculated)\n        \n        results.append(final_num_points)\n\n    # Print the results in the specified format: [n_A,n_B,n_C,n_D]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}