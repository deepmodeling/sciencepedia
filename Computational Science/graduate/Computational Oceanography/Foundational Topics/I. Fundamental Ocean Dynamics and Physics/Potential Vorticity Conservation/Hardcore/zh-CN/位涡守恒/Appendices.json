{
    "hands_on_practices": [
        {
            "introduction": "该问题呈现了一个经典的实验室实验，使用旋转转盘来模拟行星的自转。通过分析流体在受控环境中对压缩的响应，我们可以直观地理解流体深度的变化如何在大尺度上产生相对涡度。这个练习可以帮助你亲身体会浅水位涡守恒 $q = (\\zeta + f)/h$ 的基本原理。",
            "id": "1780123",
            "problem": "一个大的圆柱形水箱中装有均匀、不可压缩的无粘性流体，其初始深度均匀为 $H_0$。整个系统被放置在一个转盘上，并绕其中心垂直轴以恒定的角速度 $\\Omega_0$ 旋转。经过足够长的时间后，流体达到刚体旋转状态，与水箱一起像刚体一样运动。\n\n随后，一个平坦的圆形盖子被缓慢地同轴地放入水箱中，压缩其正下方的流体柱。这个过程足够缓慢，可以认为流体保持在平衡状态。被压缩的流体柱的最终均匀深度为 $H_f = \\alpha H_0$，其中 $\\alpha$ 是一个无量纲常数，满足 $0  \\alpha  1$。压缩区域外的流体可以自由移动并调整其高度。\n\n假设动力学由f平面上的浅水方程控制，确定盖子下方压缩区域内流体的最终相对涡度 $\\zeta_f$。相对涡度定义为在旋转参考系中测量的流体速度场的旋度的垂直分量。\n\n用 $\\Omega_0$ 和 $\\alpha$ 表示你的答案。",
            "solution": "我们使用f平面上均匀、无粘性流体的浅水势涡守恒。每个流体柱的物质守恒势涡为\n$$\nq \\equiv \\frac{\\zeta + f}{h}, \\quad \\frac{Dq}{Dt} = 0,\n$$\n其中 $\\zeta$ 是旋转参考系中的相对涡度，$f$ 是恒定的科里奥利参数，$h$ 是当地流体柱的深度。\n\n初始状态：在与水箱一起达到刚体旋转后，在旋转参考系中流体是静止的，因此水平速度为零，从而初始相对涡度为\n$$\n\\zeta_{0} = 0.\n$$\n盖子下方区域的初始深度为 $H_{0}$，所以初始势涡为\n$$\nq_{0} = \\frac{\\zeta_{0} + f}{H_{0}} = \\frac{f}{H_{0}}.\n$$\n\n盖子下方的最终状态：深度被均匀压缩至\n$$\nH_{f} = \\alpha H_{0}, \\quad 0  \\alpha  1,\n$$\n最终相对涡度为 $\\zeta_{f}$。根据相同流体柱的势涡守恒，\n$$\n\\frac{\\zeta_{f} + f}{H_{f}} = \\frac{\\zeta_{0} + f}{H_{0}}.\n$$\n代入 $\\zeta_{0} = 0$ 和 $H_{f} = \\alpha H_{0}$ 得\n$$\n\\frac{\\zeta_{f} + f}{\\alpha H_{0}} = \\frac{f}{H_{0}} \\quad \\Longrightarrow \\quad \\zeta_{f} + f = \\alpha f \\quad \\Longrightarrow \\quad \\zeta_{f} = (\\alpha - 1) f.\n$$\n\n对于一个绕垂直轴以角速度 $\\Omega_{0}$ 旋转的参考系，f平面科里奥利参数为\n$$\nf = 2 \\Omega_{0}.\n$$\n因此，\n$$\n\\zeta_{f} = (\\alpha - 1)\\, 2 \\Omega_{0} = -2 \\Omega_{0} (1 - \\alpha).\n$$\n对于 $0  \\alpha  1$ 的情况，这个值是负的（相对于旋转参考系是反气旋的），这符合浅水中流体柱压缩下的势涡守恒要求。",
            "answer": "$$\\boxed{-2\\,\\Omega_{0}\\,(1-\\alpha)}$$"
        },
        {
            "introduction": "在掌握了基础知识之后，我们将位涡守恒应用于一个真实的海洋学场景：大规模洋流与海底山的相互作用。该问题阐释了在准地转近似下，位涡动力学如何能够预测复杂的流动模式，例如泰勒帽（Taylor Cap）的形成。解决这个问题将展示位涡作为分析和理解洋流与地形相互作用的强大工具。",
            "id": "1780103",
            "problem": "考虑一股大尺度、稳定的地转海洋流，其流经的区域科里奥利参数 $f$ 为常数。该海洋被模拟为密度恒定的单层流体，在远场具有均匀深度 $H$。这股海流具有均匀的上游速度 $U$ 和零上游相对涡度，它遇到了一个高度为 $h_m$、半径为 $L$ 的静止水下圆柱形海山。因此，上游位涡由 $q_0 = f/H$ 给出。\n\n在某些条件下，海流不够强，无法越过障碍物，导致在海山上方形成一团停滞的水体，这种现象被称为泰勒帽 (Taylor Cap)。当海山上方的流场中首次出现驻点（水平速度分量均为零的点）时，这种流态开始出现。\n\n假设动力学由准地转 (QG) 近似描述，由海山地形 $h_b(x,y)$ 引起的背景流函数扰动 $\\psi'$ 由泊松方程控制：\n$$ \\nabla^2\\psi' = -\\frac{f}{H} h_b(x,y) $$\n总流函数为 $\\psi(x,y) = -Uy + \\psi'$，其中背景流沿正 $x$ 方向。水平速度分量为 $u = -\\frac{\\partial\\psi}{\\partial y}$ 和 $v = \\frac{\\partial\\psi}{\\partial x}$。\n\n确定上游位涡的临界值 $q_{crit}$，该值标志着越流和滞流流态之间的边界。将您的答案表示为包含上游速度 $U$、海山高度 $h_m$ 和海山半径 $L$ 的符号表达式。",
            "solution": "总流函数为 $\\psi(x,y) = -Uy + \\psi'$，其中 $-Uy$ 代表沿正 $x$ 方向的均匀背景流。水平速度分量由 $u = -\\frac{\\partial\\psi}{\\partial y}$ 和 $v = \\frac{\\partial\\psi}{\\partial x}$ 给出。因此：\n$$\nu = -\\frac{\\partial}{\\partial y}(-Uy + \\psi') = U - \\frac{\\partial\\psi'}{\\partial y}\n$$\n$$\nv = \\frac{\\partial}{\\partial x}(-Uy + \\psi') = \\frac{\\partial\\psi'}{\\partial x}\n$$\n扰动流函数 $\\psi'$ 由给定的泊松方程控制：$\\nabla^2\\psi' = -\\frac{f}{H} h_b(x,y)$。\n对于圆柱形海山，$h_b = h_m$（常数）在 $r \\le L$ 区域内。方程变为 $\\nabla^2\\psi' = -q_0 h_m$，其中 $q_0 = f/H$ 是上游位涡。\n在海山区域内，此方程的一个简单特解是 $\\psi'_p = -\\frac{q_0 h_m}{4} r^2 = -\\frac{q_0 h_m}{4}(x^2+y^2)$。我们假设海山上方的滞流水体中的流动主要由此解描述。\n\n由该特解产生的扰动速度场为：\n$$\nu' = -\\frac{\\partial\\psi'_p}{\\partial y} = \\frac{q_0 h_m}{2} y\n$$\n$$\nv' = \\frac{\\partial\\psi'_p}{\\partial x} = -\\frac{q_0 h_m}{2} x\n$$\n因此，海山上方的总速度场为：\n$$\nu = U + u' = U + \\frac{q_0 h_m}{2} y\n$$\n$$\nv = v' = -\\frac{q_0 h_m}{2} x\n$$\n驻点（stagnation point）被定义为 $u=0$ 和 $v=0$ 的点。\n从 $v=0$ 可得 $x=0$（假设 $q_0, h_m \\neq 0$）。\n将 $x=0$ 代入 $u=0$ 的方程得到：$U + \\frac{q_0 h_m}{2} y = 0$，解得 $y = -\\frac{2U}{q_0 h_m}$。\n因此，驻点位于 $y$ 轴上的 $(0, -\\frac{2U}{q_0 h_m})$。\n\n泰勒帽形成的临界条件是该驻点首次出现在海山边界上，即 $r=L$ 的圆周上。由于驻点位于 $y$ 轴上，临界点必然是 $(0, -L)$ 或 $(0, L)$。因为 $U, q_0, h_m$ 均为正，驻点的 $y$ 坐标为负，所以临界点在 $(0, -L)$。\n将 $y = -L$ 代入驻点位置的表达式中：\n$$\n-L = -\\frac{2U}{q_0 h_m}\n$$\n解出临界上游位涡 $q_{crit}$（即此条件下的 $q_0$）：\n$$\nq_{crit} = \\frac{2U}{h_m L}\n$$\n这就是标志着泰勒帽开始形成的临界位涡值。",
            "answer": "$$\\boxed{\\frac{2U}{h_{m}L}}$$"
        },
        {
            "introduction": "最后的这个练习将理论分析与计算海洋学家的日常工作联系起来。分析数值模型的输出是一项关键技能，本练习将指导你创建一个用于诊断位涡收支的数值程序。你将通过实施有限差分方案来验证模型模拟是否正确地遵守了位涡守恒，这是模型验证和物理解释模拟结果的一项基本任务。",
            "id": "3808642",
            "problem": "给定一个二维周期性方形域和代表模型输出的随时间变化的场。任务是通过计算场中的储存项、平流项和源项，以通量形式诊断位涡收支，然后在一组测试用例上对守恒性进行数值验证。从适用于旋转分层流的基本基础开始：Ertel 位涡的定义及其在绝热无粘条件下的守恒定律，并构建可以从网格化场中评估的诊断收支。除了这些基础知识外，不要假定任何快捷公式。\n\n该域在两个方向上都是周期性的，长度分别为 $L_x$ 和 $L_y$。场在均匀网格上采样，在 $x$ 方向有 $N_x$ 个点，在 $y$ 方向有 $N_y$ 个点，因此网格间距为 $d_x = L_x/N_x$ 和 $d_y = L_y/N_y$。空间导数必须使用周期性边界条件下的二阶中心有限差分进行近似，时间导数必须使用单个时间步长 $d_t$ 上的向前差分进行近似。平流项必须以通量形式计算，即标量场与速度场的通量之散度。\n\n对于每个测试用例，你必须：\n- 根据用例定义，在时间 $t_0$ 和 $t_1 = t_0 + d_t$ 构建标量场 $q(x,y,t)$。\n- 按规定构建速度场 $\\boldsymbol{u}(x,y,t)$。\n- 使用向前差分 $(q(t_1) - q(t_0))/d_t$ 计算储存项 $T = \\partial q/\\partial t$。\n- 在时间 $t_0$ 使用中心差分和周期性边界条件计算平流项 $A = \\nabla \\cdot (\\boldsymbol{u} q)$。\n- 按用例给定计算源项 $S$。\n- 在时间 $t_0$ 形成残差 $R = T + A - S$，并报告其在区域内平均的绝对值大小。\n\n所有计算都必须使用与场一致的单位进行，最终的诊断残差必须以 $s^{-1}$ 为单位报告。三角函数内的角度必须被视为函数的无量纲参数，根据构造，这与弧度是兼容的。\n\n使用以下测试套件以确保覆盖不同情景。在所有情况下，使用 $N_x = 256$，$N_y = 256$，$L_x = 10^6$ 米，$L_y = 10^6$ 米，以及 $t_0 = 0$ 秒。\n\n- 测试用例 $1$（理想路径，波形纯平流，源项为零）：\n  - 参数：$U = 0.2$ 米/秒，$V = 0$ 米/秒，$d_t = 600$ 秒。\n  - 定义波数 $k_x = 2\\pi/L_x$，$k_y = 2\\pi/L_y$。\n  - 定义 $q(x,y,t) = \\cos(k_x x - k_x U t)\\,\\cos(k_y y)$。\n  - 定义 $\\boldsymbol{u}(x,y,t) = (U, 0)$。\n  - 定义 $S(x,y,t) = 0$。\n  - 此用例的构造使得通量形式的收支 $T + A - S$ 在数值上应很小。\n\n- 测试用例 $2$（边界条件检查，静止场，无运动，源项为零）：\n  - 参数：$U = 0$ 米/秒，$V = 0$ 米/秒，$d_t = 600$ 秒。\n  - 定义 $k_x = 2\\pi/L_x$，$k_y = 2\\pi/L_y$。\n  - 定义 $q(x,y,t) = \\cos(k_x x)\\,\\cos(k_y y)$。\n  - 定义 $\\boldsymbol{u}(x,y,t) = (0, 0)$。\n  - 定义 $S(x,y,t) = 0$。\n  - 此用例测试所有项是否在数值精度范围内消失。\n\n- 测试用例 $3$（非保守源，指数衰减，平流为零）：\n  - 参数：$U = 0$ 米/秒，$V = 0$ 米/秒，$d_t = 600$ 秒，$\\lambda = 10^{-6}$ /秒。\n  - 定义 $k_x = 2\\pi/L_x$，$k_y = 2\\pi/L_y$。\n  - 定义 $q(x,y,t) = e^{-\\lambda t}\\,\\cos(k_x x)\\,\\cos(k_y y)$。\n  - 定义 $\\boldsymbol{u}(x,y,t) = (0, 0)$。\n  - 定义 $S(x,y,t) = -\\lambda q(x,y,t)$。\n  - 此用例的构造使得源项与储存项相平衡，从而使残差很小。\n\n你的程序必须为每个测试用例计算残差 $R$ 在区域内平均的绝对值大小（单位为 $s^{-1}$），并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[r_1,r_2,r_3]$，其中 $r_1$、$r_2$ 和 $r_3$ 是分别代表测试用例 1、2 和 3 的区域平均绝对残差的十进制数。",
            "solution": "该问题要求对通量形式的标量守恒律进行数值验证，这是计算流体力学中的一项基本诊断任务，尤其是在海洋学中用于像位涡这样的收支分析。控制方程如下：\n$$\n\\frac{\\partial q}{\\partial t} + \\nabla \\cdot (\\boldsymbol{u} q) = S\n$$\n其中 $q$ 是一个标量场，$\\boldsymbol{u} = (u, v)$ 是速度场，$S$ 是一个源/汇项。问题要求我们使用指定的数值近似方法，为给定的二维周期域上的解析场计算该方程的残差 $R = \\frac{\\partial q}{\\partial t} + \\nabla \\cdot (\\boldsymbol{u} q) - S$。\n\n该域是一个边长为 $L_x$ 和 $L_y$ 的正方形，用一个 $N_x \\times N_y$ 点的均匀网格离散化。网格间距为 $d_x = L_x / N_x$ 和 $d_y = L_y / N_y$。我们定义网格坐标为 $(x_i, y_j)$，其中 $x_i = i \\cdot d_x$（对于 $i \\in \\{0, 1, \\dots, N_x-1\\}$）和 $y_j = j \\cdot d_y$（对于 $j \\in \\{0, 1, \\dots, N_y-1\\}$）。\n\n下面详细说明收支残差 $R = T + A - S$ 中各项的数值近似。\n\n1.  **储存项 ($T$)**: 时间变化率项 $T = \\partial q / \\partial t$ 使用一阶向前差分进行时间上的近似。计算在时间 $t_0$ 进行，使用时间 $t_0$ 和 $t_1 = t_0 + d_t$ 的场数据。在每个网格点 $(i,j)$，储存项为：\n    $$\n    T_{i,j} = \\frac{q(x_i, y_j, t_1) - q(x_i, y_j, t_0)}{d_t}\n    $$\n\n2.  **平流项 ($A$)**: 平流项 $A = \\nabla \\cdot (\\boldsymbol{u} q)$ 在时间 $t_0$ 进行计算。在二维中，这展开为：\n    $$\n    A = \\frac{\\partial (u q)}{\\partial x} + \\frac{\\partial (v q)}{\\partial y}\n    $$\n    空间导数使用二阶中心有限差分进行近似。对于在网格上计算为 $F_{i,j}$ 的通用场 $F(x,y)$，在点 $(i,j)$ 的偏导数为：\n    $$\n    \\left. \\frac{\\partial F}{\\partial x} \\right|_{i,j} \\approx \\frac{F_{i+1, j} - F_{i-1, j}}{2 d_x}\n    $$\n    $$\n    \\left. \\frac{\\partial F}{\\partial y} \\right|_{i,j} \\approx \\frac{F_{i, j+1} - F_{i, j-1}}{2 d_y}\n    $$\n    区域的周期性要求索引根据网格维度进行取模处理。例如，$F_{N_x, j} = F_{0, j}$ 和 $F_{-1, j} = F_{N_x-1, j}$。\n    令 $F_x = u q$ 和 $F_y = v q$ 为在时间 $t_0$ 计算的通量分量，则在网格点 $(i,j)$ 的平流项为：\n    $$\n    A_{i,j} = \\frac{(uq)_{i+1, j} - (uq)_{i-1, j}}{2 d_x} + \\frac{(vq)_{i, j+1} - (vq)_{i, j-1}}{2 d_y}\n    $$\n    右侧的所有场（$u, v, q$）都在 $t=t_0$ 时进行计算。\n\n3.  **源项 ($S$)**: 源项 $S$ 对每个测试用例由一个解析表达式给出。它在每个网格点 $(i,j)$ 和时间 $t_0$ 进行计算。\n    $$\n    S_{i,j} = S(x_i, y_j, t_0)\n    $$\n\n4.  **残差 ($R$) 和最终度量**: 残差场 $R$ 通过在每个网格点 $(i,j)$ 组合离散化的项来计算：\n    $$\n    R_{i,j} = T_{i,j} + A_{i,j} - S_{i,j}\n    $$\n    最终要求的输出是该残差的区域平均绝对值大小，它是一个单一的标量值，表示守恒律在整个网格上的平均数值不平衡。\n    $$\n    \\langle |R| \\rangle = \\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} |R_{i,j}|\n    $$\n    这个度量提供了一个稳健的衡量标准，用于评估数值方案对于给定的解析解在多大程度上保持了量 $q$ 的守恒。一个较小的值表明数值实现与其旨在求解的连续方程是一致的，非零值是由有限差分格式的截断误差引起的。\n\n实现将首先定义网格和用例参数。对于每个测试用例，在网格上所需的时间点构建场 $q$、$u$ 和 $v$。实现周期域的数值微分算子，然后应用它们来计算场 $T$、$A$ 和 $S$。最后，计算残差场 $R$，并计算和存储其区域平均绝对值。对所有三个测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the domain-mean absolute residual of a scalar conservation law\n    for a suite of test cases in computational oceanography.\n    \"\"\"\n\n    # Global parameters for all test cases\n    Nx = 256\n    Ny = 256\n    Lx = 1.0e6  # meters\n    Ly = 1.0e6  # meters\n    t0 = 0.0    # seconds\n\n    dx = Lx / Nx\n    dy = Ly / Ny\n\n    # Create grid coordinates\n    x_1d = np.arange(Nx) * dx\n    y_1d = np.arange(Ny) * dy\n    x, y = np.meshgrid(x_1d, y_1d, indexing='xy')\n\n    # Define wavenumbers\n    kx = 2.0 * np.pi / Lx\n    ky = 2.0 * np.pi / Ly\n\n    test_cases = [\n        {\n            # Case 1: Pure advection of a wave pattern\n            \"U\": 0.2, \"V\": 0.0, \"dt\": 600.0,\n            \"q_func\": lambda t, U: np.cos(kx * x - kx * U * t) * np.cos(ky * y),\n            \"S_func\": lambda q: 0.0,\n        },\n        {\n            # Case 2: Stationary field, zero velocity\n            \"U\": 0.0, \"V\": 0.0, \"dt\": 600.0,\n            \"q_func\": lambda t, U: np.cos(kx * x) * np.cos(ky * y),\n            \"S_func\": lambda q: 0.0,\n        },\n        {\n            # Case 3: Exponential decay, zero velocity\n            \"U\": 0.0, \"V\": 0.0, \"dt\": 600.0, \"lambda\": 1.0e-6,\n            \"q_func\": lambda t, U, lam: np.exp(-lam * t) * np.cos(kx * x) * np.cos(ky * y),\n            \"S_func\": lambda q, lam: -lam * q,\n        },\n    ]\n\n    results = []\n\n    # Second-order centered difference for x-derivative with periodic BC\n    def d_dx(field, dx_val):\n        return (np.roll(field, -1, axis=1) - np.roll(field, 1, axis=1)) / (2.0 * dx_val)\n\n    # Second-order centered difference for y-derivative with periodic BC\n    def d_dy(field, dy_val):\n        return (np.roll(field, -1, axis=0) - np.roll(field, 1, axis=0)) / (2.0 * dy_val)\n\n    # Process Test Case 1\n    case1 = test_cases[0]\n    dt1 = case1[\"dt\"]\n    U1, V1 = case1[\"U\"], case1[\"V\"]\n    t1 = t0 + dt1\n    \n    q0_c1 = case1[\"q_func\"](t0, U1)\n    q1_c1 = case1[\"q_func\"](t1, U1)\n    u0_c1 = np.full_like(x, U1)\n    v0_c1 = np.full_like(y, V1)\n\n    # Storage term T\n    T_c1 = (q1_c1 - q0_c1) / dt1\n\n    # Advection term A in flux form: A = d(uq)/dx + d(vq)/dy\n    flux_x_c1 = u0_c1 * q0_c1\n    flux_y_c1 = v0_c1 * q0_c1\n    A_c1 = d_dx(flux_x_c1, dx) + d_dy(flux_y_c1, dy)\n    \n    # Source term S\n    S_c1 = case1[\"S_func\"](q0_c1)\n\n    # Residual R\n    R_c1 = T_c1 + A_c1 - S_c1\n    results.append(np.mean(np.abs(R_c1)))\n\n    # Process Test Case 2\n    case2 = test_cases[1]\n    dt2 = case2[\"dt\"]\n    U2, V2 = case2[\"U\"], case2[\"V\"]\n    t2 = t0 + dt2\n    \n    q0_c2 = case2[\"q_func\"](t0, U2)\n    q1_c2 = case2[\"q_func\"](t2, U2)\n    u0_c2 = np.full_like(x, U2)\n    v0_c2 = np.full_like(y, V2)\n\n    T_c2 = (q1_c2 - q0_c2) / dt2\n    \n    flux_x_c2 = u0_c2 * q0_c2\n    flux_y_c2 = v0_c2 * q0_c2\n    A_c2 = d_dx(flux_x_c2, dx) + d_dy(flux_y_c2, dy)\n    \n    S_c2 = case2[\"S_func\"](q0_c2)\n    \n    R_c2 = T_c2 + A_c2 - S_c2\n    results.append(np.mean(np.abs(R_c2)))\n\n    # Process Test Case 3\n    case3 = test_cases[2]\n    dt3 = case3[\"dt\"]\n    U3, V3 = case3[\"U\"], case3[\"V\"]\n    lam3 = case3[\"lambda\"]\n    t3 = t0 + dt3\n    \n    q0_c3 = case3[\"q_func\"](t0, U3, lam3)\n    q1_c3 = case3[\"q_func\"](t3, U3, lam3)\n    u0_c3 = np.full_like(x, U3)\n    v0_c3 = np.full_like(y, V3)\n\n    T_c3 = (q1_c3 - q0_c3) / dt3\n    \n    flux_x_c3 = u0_c3 * q0_c3\n    flux_y_c3 = v0_c3 * q0_c3\n    A_c3 = d_dx(flux_x_c3, dx) + d_dy(flux_y_c3, dy)\n\n    S_c3 = case3[\"S_func\"](q0_c3, lam3)\n\n    R_c3 = T_c3 + A_c3 - S_c3\n    results.append(np.mean(np.abs(R_c3)))\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}