{
    "hands_on_practices": [
        {
            "introduction": "A fundamental task in computational oceanography is to transform raw sensor data into meaningful dynamical parameters. This first practice guides you through the essential process of converting profiles of temperature, salinity, and pressure, as measured by a CTD instrument, into profiles of buoyancy frequency squared ($N^2$) and the gradient Richardson number ($Ri_g$). By deriving the computational steps from first principles, including the hydrostatic approximation and a linearized equation of state, you will build a deeper understanding of the physical connections between the ocean's thermodynamic state and its dynamic stability. ",
            "id": "3812274",
            "problem": "You are given profiles from a Conductivity-Temperature-Depth (CTD) instrument: temperature $T$ in degrees Celsius, practical salinity $S$ in Practical Salinity Units (PSU), and pressure $p$ in decibars (dbar). Under the upward-positive $z$ convention, derive from first principles a computational procedure to convert these profiles to the buoyancy frequency squared $N^2$ and then to the gradient Richardson number using the vertical shear of a horizontal velocity component $u$ in meters per second. Base your derivation and algorithm on hydrostatic balance, the Boussinesq approximation, and a linearized equation of state. Do not use shortcut formulas for $N^2$ directly; instead, connect the computation to the underlying physical relations and definitions in your solution. Assume constant gravitational acceleration and a constant reference density.\n\nThe program must implement the following, in sequence, for each test case:\n- Use hydrostatic balance to convert the pressure profile $p$ to an upward-positive geometric height profile $z$ in meters, with $z=0$ at the sea surface. Treat the reference density and gravitational acceleration as constants, and use the standard decibar to pascal conversion.\n- Using a linearized equation of state, express density variations in terms of $T$ and $S$, then compute the vertical density gradient with respect to $z$ from the $T$ and $S$ profiles.\n- From the density gradient and the upward-positive $z$ convention, obtain $N^2$ at each sample location in units of $\\mathrm{s^{-2}}$.\n- Compute the vertical shear $\\partial u/\\partial z$ using the $u$ profile and then compute the gradient Richardson number $Ri_g$ at each sample location.\n- Use second-order central differences in the interior and first-order one-sided differences at the boundaries to approximate vertical derivatives of all profiles.\n\nConstants to be used:\n- Reference density $ \\rho_0 = 1027 $ kilograms per cubic meter.\n- Gravitational acceleration $ g = 9.81 $ meters per second squared.\n- Linear thermal expansion coefficient $ \\alpha = 2.0 \\times 10^{-4} $ per kelvin.\n- Linear haline contraction coefficient $ \\beta = 7.6 \\times 10^{-4} $ per PSU.\n- Pressure conversion $ 1 $ decibar $ = 10^4 $ pascal.\n\nFor each test case, the program must compute two summary metrics:\n- The arithmetic mean of interior (excluding the first and last sample) $N^2$ values, expressed in $\\mathrm{s^{-2}}$ and rounded to $6$ decimal places.\n- The minimum interior gradient Richardson number, rounded to $6$ decimal places.\n\nYour program should produce a single line of output containing the aggregated results for all test cases as a comma-separated list enclosed in square brackets. The list must contain, in order for each test case, first the mean interior $N^2$ and then the minimum interior $Ri_g$.\n\nProvide and use the following test suite:\n\n- Test Case $1$ (typical stable stratification, irregular pressure spacing):\n  - $p$ in decibars: $[0, 5, 10, 20, 50, 100, 200, 300]$.\n  - $T$ in degrees Celsius: $[20.0, 19.0, 18.2, 16.0, 12.0, 8.0, 5.0, 3.0]$.\n  - $S$ in PSU: $[34.0, 34.1, 34.2, 34.4, 34.6, 34.8, 35.0, 35.1]$.\n  - $u$ in meters per second: $[0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 0.60]$.\n\n- Test Case $2$ (near-homogeneous water column):\n  - $p$ in decibars: $[0, 10, 50, 100, 200]$.\n  - $T$ in degrees Celsius: $[10.0, 10.0, 10.0, 10.0, 10.0]$.\n  - $S$ in PSU: $[35.0, 35.0, 35.0, 35.0, 35.0]$.\n  - $u$ in meters per second: $[0.10, 0.12, 0.14, 0.16, 0.18]$.\n\n- Test Case $3$ (unstable stratification in the upper ocean):\n  - $p$ in decibars: $[0, 5, 10, 20, 40]$.\n  - $T$ in degrees Celsius: $[10.0, 10.5, 10.8, 11.0, 11.2]$.\n  - $S$ in PSU: $[35.0, 34.9, 34.8, 34.7, 34.6]$.\n  - $u$ in meters per second: $[0.30, 0.28, 0.26, 0.25, 0.24]$.\n\nAnswer in the specified units. Angles are not used. All printed results must be decimals. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[N2\\_mean\\_1, Ri\\_min\\_1, N2\\_mean\\_2, Ri\\_min\\_2, N2\\_mean\\_3, Ri\\_min\\_3]$.",
            "solution": "The user requests a computational procedure derived from first principles to calculate the buoyancy frequency squared ($N^2$) and the gradient Richardson number ($Ri_g$) from oceanographic profiles of pressure ($p$), temperature ($T$), salinity ($S$), and horizontal velocity ($u$). This derivation and the subsequent algorithm will be based on the principles of hydrostatic balance, the Boussinesq approximation, and a linearized equation of state.\n\n**1. Derivation from First Principles**\n\n**1.1. Coordinate System: Pressure to Geometric Height**\nThe problem specifies an upward-positive vertical coordinate, $z$, with $z=0$ at the sea surface. The primary vertical coordinate measured by a CTD is pressure, $p$. We must convert the pressure profile to a geometric height profile. The fundamental relationship is the hydrostatic balance equation:\n$$ dP = -\\rho g dz $$\nwhere $P$ is pressure in Pascals, $\\rho$ is the water density, and $g$ is the gravitational acceleration. The Boussinesq approximation allows us to assume density is constant, $\\rho \\approx \\rho_0$ (a reference density), for all purposes except in the buoyancy term. Applying this approximation to the hydrostatic equation simplifies it to:\n$$ dP \\approx -\\rho_0 g dz $$\nWe integrate this equation from the sea surface, where $z_s=0$ and gauge pressure $P_s=0$, to an arbitrary point $(z, P)$:\n$$ \\int_{0}^{P} dP' = \\int_{0}^{z} -\\rho_0 g dz' \\implies P = -\\rho_0 g z $$\nSolving for $z$ gives the height in meters:\n$$ z = -\\frac{P}{\\rho_0 g} $$\nThe input pressure $p$ is provided in decibars (dbar). We use the standard conversion $1 \\ \\text{dbar} = 10^4 \\ \\text{Pa}$. Therefore, for each pressure measurement $p_i$, the corresponding geometric height $z_i$ is calculated as:\n$$ z_i = -\\frac{p_i \\times 10^4}{\\rho_0 g} $$\nThe given constants are $\\rho_0 = 1027 \\ \\mathrm{kg/m^3}$ and $g = 9.81 \\ \\mathrm{m/s^2}$. The resulting $z$ values will be non-positive, correctly representing depths below the sea surface in our coordinate system.\n\n**1.2. Buoyancy Frequency Squared ($N^2$)**\nThe buoyancy (or Brunt-Väisälä) frequency, $N$, characterizes the intrinsic frequency of vertical oscillations of a fluid parcel in a stable density stratification. Its square, $N^2$, is defined as:\n$$ N^2 = -\\frac{g}{\\rho_0} \\frac{d\\rho}{dz} $$\nA positive $N^2$ indicates stable stratification, a negative $N^2$ indicates unstable (convective) stratification, and $N^2=0$ indicates neutral stratification. To compute $N^2$, we need the vertical gradient of density, $d\\rho/dz$.\n\nThe problem specifies a linearized equation of state for seawater, where density $\\rho$ is a function of temperature $T$ and salinity $S$. The density variation $d\\rho$ can be expressed as:\n$$ d\\rho = \\frac{\\partial\\rho}{\\partial T} dT + \\frac{\\partial\\rho}{\\partial S} dS $$\nThe thermal expansion coefficient, $\\alpha$, and haline contraction coefficient, $\\beta$, are defined as:\n$$ \\alpha = -\\frac{1}{\\rho_0} \\frac{\\partial\\rho}{\\partial T}, \\quad \\beta = \\frac{1}{\\rho_0} \\frac{\\partial\\rho}{\\partial S} $$\nFrom these definitions, we have $\\partial\\rho/\\partial T = -\\rho_0 \\alpha$ and $\\partial\\rho/\\partial S = \\rho_0 \\beta$.\nUsing the chain rule, we express the vertical density gradient $d\\rho/dz$ in terms of the vertical gradients of temperature and salinity:\n$$ \\frac{d\\rho}{dz} = \\frac{\\partial\\rho}{\\partial T}\\frac{dT}{dz} + \\frac{\\partial\\rho}{\\partial S}\\frac{dS}{dz} = -\\rho_0\\alpha\\frac{dT}{dz} + \\rho_0\\beta\\frac{dS}{dz} $$\nSubstituting this expression for $d\\rho/dz$ into the definition of $N^2$:\n$$ N^2 = -\\frac{g}{\\rho_0} \\left( -\\rho_0\\alpha\\frac{dT}{dz} + \\rho_0\\beta\\frac{dS}{dz} \\right) $$\n$$ N^2 = g \\left( \\alpha\\frac{dT}{dz} - \\beta\\frac{dS}{dz} \\right) $$\nThis final expression allows us to compute $N^2$ using the given coefficients ($\\alpha = 2.0 \\times 10^{-4} \\ \\mathrm{K^{-1}}$, $\\beta = 7.6 \\times 10^{-4} \\ \\mathrm{PSU^{-1}}$) and the numerically approximated vertical gradients of $T$ and $S$.\n\n**1.3. Gradient Richardson Number ($Ri_g$)**\nThe gradient Richardson number, $Ri_g$, is a dimensionless parameter that represents the ratio of the stabilizing effect of buoyancy to the destabilizing effect of velocity shear. It is a key indicator of dynamic stability and the likelihood of turbulence generation. It is defined as:\n$$ Ri_g = \\frac{N^2}{\\left(\\frac{\\partial u}{\\partial z}\\right)^2} $$\nwhere $\\partial u/\\partial z$ is the vertical shear of the horizontal velocity. A common criterion for the onset of shear instability is when $Ri_g  0.25$. To compute $Ri_g$, we will use the calculated $N^2$ profile and the numerically approximated vertical gradient of the velocity profile $u(z)$.\n\n**2. Computational Algorithm**\n\nThe overall computational procedure is as follows:\n\n**2.1. Numerical Differentiation**\nTo compute the vertical gradients $\\frac{dT}{dz}$, $\\frac{dS}{dz}$, and $\\frac{\\partial u}{\\partial z}$ from the discrete profiles, we use a finite difference scheme that accommodates the non-uniform vertical spacing of the $z$ coordinates. For a generic profile $F(z)$ with $n$ data points $F_0, F_1, ..., F_{n-1}$ at heights $z_0, z_1, ..., z_{n-1}$:\n- **Boundary (First Point, $i=0$):** A first-order forward difference is used.\n$$ \\left(\\frac{dF}{dz}\\right)_0 = \\frac{F_1 - F_0}{z_1 - z_0} $$\n- **Interior Points ($1 \\le i \\le n-2$):** A second-order central difference is used. This is more accurate and appropriate for non-uniform grids.\n$$ \\left(\\frac{dF}{dz}\\right)_i = \\frac{F_{i+1} - F_{i-1}}{z_{i+1} - z_{i-1}} $$\n- **Boundary (Last Point, $i=n-1$):** A first-order backward difference is used.\n$$ \\left(\\frac{dF}{dz}\\right)_{n-1} = \\frac{F_{n-1} - F_{n-2}}{z_{n-1} - z_{n-2}} $$\n\n**2.2. Step-by-Step Implementation**\nFor each test case:\n1.  Convert the input pressure profile $p$ (dbar) into a geometric height profile $z$ (m) using $z_i = -(p_i \\times 10^4) / (\\rho_0 g)$.\n2.  Apply the finite difference scheme described above to compute the gradient profiles $\\frac{dT}{dz}$, $\\frac{dS}{dz}$, and $\\frac{\\partial u}{\\partial z}$ from the input $T$, $S$, and $u$ profiles and the computed $z$ profile.\n3.  Calculate the buoyancy frequency squared profile $N^2(z)$ using the formula $N^2 = g(\\alpha \\frac{dT}{dz} - \\beta \\frac{dS}{dz})$.\n4.  Calculate the shear-squared profile $(\\frac{\\partial u}{\\partial z})^2$.\n5.  Calculate the gradient Richardson number profile $Ri_g(z)$ by dividing the $N^2$ profile by the shear-squared profile.\n6.  Isolate the interior points of the resulting profiles (i.e., excluding the first and last calculated values).\n7.  Compute the arithmetic mean of the interior $N^2$ values.\n8.  Compute the minimum value of the interior $Ri_g$ values.\n9.  Round both metrics to $6$ decimal places and store them.\n10. After processing all test cases, format the collected results into the specified output string.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes buoyancy frequency and Richardson number from CTD profiles.\n    \"\"\"\n\n    # --- Constants ---\n    RHO_0 = 1027.0  # Reference density in kg/m^3\n    G = 9.81        # Gravitational acceleration in m/s^2\n    ALPHA = 2.0e-4  # Thermal expansion coefficient in 1/K\n    BETA = 7.6e-4   # Haline contraction coefficient in 1/PSU\n    P_CONV = 1.0e4  # Pressure conversion from dbar to Pascal\n\n    # --- Test Cases ---\n    test_cases = [\n        {\n            \"p\": np.array([0, 5, 10, 20, 50, 100, 200, 300], dtype=float),\n            \"T\": np.array([20.0, 19.0, 18.2, 16.0, 12.0, 8.0, 5.0, 3.0], dtype=float),\n            \"S\": np.array([34.0, 34.1, 34.2, 34.4, 34.6, 34.8, 35.0, 35.1], dtype=float),\n            \"u\": np.array([0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 0.60], dtype=float),\n        },\n        {\n            \"p\": np.array([0, 10, 50, 100, 200], dtype=float),\n            \"T\": np.array([10.0, 10.0, 10.0, 10.0, 10.0], dtype=float),\n            \"S\": np.array([35.0, 35.0, 35.0, 35.0, 35.0], dtype=float),\n            \"u\": np.array([0.10, 0.12, 0.14, 0.16, 0.18], dtype=float),\n        },\n        {\n            \"p\": np.array([0, 5, 10, 20, 40], dtype=float),\n            \"T\": np.array([10.0, 10.5, 10.8, 11.0, 11.2], dtype=float),\n            \"S\": np.array([35.0, 34.9, 34.8, 34.7, 34.6], dtype=float),\n            \"u\": np.array([0.30, 0.28, 0.26, 0.25, 0.24], dtype=float),\n        },\n    ]\n\n    def compute_gradient(F, z):\n        \"\"\"\n        Computes the gradient of a profile F with respect to z using\n        a mixed finite difference scheme for a non-uniform grid.\n        \"\"\"\n        n = len(F)\n        if n  2:\n            return np.zeros(n)\n        \n        dFdz = np.zeros(n)\n        \n        # First-order forward difference at the start\n        dFdz[0] = (F[1] - F[0]) / (z[1] - z[0])\n        \n        # First-order backward difference at the end\n        dFdz[n - 1] = (F[n - 1] - F[n - 2]) / (z[n - 1] - z[n - 2])\n        \n        # Second-order central difference for interior points\n        for i in range(1, n - 1):\n            dFdz[i] = (F[i + 1] - F[i - 1]) / (z[i + 1] - z[i - 1])\n            \n        return dFdz\n\n    results = []\n    for case in test_cases:\n        p, T, S, u = case[\"p\"], case[\"T\"], case[\"S\"], case[\"u\"]\n\n        # Step 1: Convert pressure (dbar) to geometric height z (m)\n        z = - (p * P_CONV) / (RHO_0 * G)\n\n        # Step 2: Compute vertical gradients\n        dT_dz = compute_gradient(T, z)\n        dS_dz = compute_gradient(S, z)\n        du_dz = compute_gradient(u, z)\n\n        # Step 3: Compute buoyancy frequency squared (N^2)\n        # N^2 = g * (alpha * dT/dz - beta * dS/dz)\n        N2 = G * (ALPHA * dT_dz - BETA * dS_dz)\n\n        # Step 4: Compute gradient Richardson number (Ri_g)\n        shear_sq = du_dz**2\n        # Use np.divide to handle division by zero safely, resulting in np.inf\n        # which is physically meaningful for Ri_g when shear is zero.\n        Rig = np.divide(N2, shear_sq, out=np.full_like(N2, np.inf), where=shear_sq != 0)\n\n        # Step 5: Extract interior points and compute metrics\n        if len(p) > 2:\n            interior_N2 = N2[1:-1]\n            interior_Rig = Rig[1:-1]\n            \n            mean_interior_N2 = np.mean(interior_N2)\n            min_interior_Rig = np.min(interior_Rig)\n        else: # Case with 2 or fewer points has no interior\n            mean_interior_N2 = np.nan\n            min_interior_Rig = np.nan\n\n        results.append(round(mean_interior_N2, 6))\n        results.append(round(min_interior_Rig, 6))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While fine-scale profiles provide detailed information, oceanographers often need to characterize the stability of entire layers, such as the surface mixed layer. This exercise demonstrates how to transition from a gradient-based description to a bulk formulation. You will derive and compute a Bulk Richardson Number by approximating the vertical gradients of density and velocity as finite differences across a layer of a given thickness, a common technique used in parameterizing mixing in large-scale ocean models. ",
            "id": "3812313",
            "problem": "You are given objectively detected Mixed Layer Depth (MLD) values and layer-mean differences in density and horizontal velocity across the mixed layer in an oceanic column. Using the foundational definitions of stratification and shear, derive a bulk representation of the Richardson number across the mixed layer and implement a program that computes it for a set of test cases. Assume the standard sign convention that the vertical coordinate increases upward, and that the layer-mean density difference is defined as bottom minus top so that positive differences represent stable stratification. The program must use the following fundamental bases and proceed from first principles:\n1. The Brunt–Väisälä frequency, also known as the buoyancy frequency (BF), is defined for small vertical displacements under stable stratification by $$N^2 = -\\frac{g}{\\rho_0}\\frac{\\partial \\rho}{\\partial z},$$ where $g$ is gravitational acceleration, $\\rho_0$ is a constant reference density, $\\rho$ is in situ density, and $z$ is the vertical coordinate.\n2. The gradient Richardson number is defined by $$Ri_g = \\frac{N^2}{S^2},$$ where $S^2$ is the squared vertical shear magnitude of the horizontal flow, obtained from velocity components by $$S^2 = \\left(\\frac{\\partial U}{\\partial z}\\right)^2 + \\left(\\frac{\\partial V}{\\partial z}\\right)^2,$$ and the magnitude of the shear may be approximated from the vector velocity difference across a layer.\n3. In a bulk layer of thickness $h$, replace vertical gradients by layer-mean differences over $h$ to obtain a bulk layer estimate of $Ri_g$ across the mixed layer, here referred to as the Bulk Richardson number (BRN) across the mixed layer.\n\nYour task:\n- Derive, from the definitions above, a bulk expression appropriate for a layer of thickness $h$ using the given layer-mean differences $\\Delta \\rho$ (bottom minus top, in kilograms per cubic meter) and the magnitude of the horizontal velocity difference $\\Delta U$ (in meters per second).\n- Implement a program that computes the Bulk Richardson number across the mixed layer for each test case below, using the constants $g = 9.81$ m/s$^2$ and $\\rho_0 = 1025$ kg/m$^3$.\n- Handle the limiting behaviors explicitly:\n  - If the squared shear term in the denominator computed from $\\Delta U$ is zero and the numerator is positive, return $+\\infty$.\n  - If both numerator and denominator are zero, return $\\mathrm{NaN}$.\n  - If the squared shear term is zero and the numerator is negative, return $-\\infty$.\n- Express all results as dimensionless real numbers (floats). You must produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n\nPhysical units and conventions:\n- Mixed Layer Depth $h$ in meters.\n- Layer-mean density difference $\\Delta \\rho$ in kilograms per cubic meter.\n- Layer-mean horizontal velocity difference magnitude $\\Delta U$ in meters per second.\n- Gravitational acceleration $g = 9.81$ m/s$^2$.\n- Reference density $\\rho_0 = 1025$ kg/m$^3$.\n- The Bulk Richardson number is dimensionless.\n\nTest suite (each case is a tuple $(h,\\Delta \\rho,\\Delta U)$):\n- Case $1$: $(50.0, 0.5, 0.2)$, typical stable stratification and moderate shear.\n- Case $2$: $(20.0, 0.01, 0.1)$, near-neutral stratification and weak shear.\n- Case $3$: $(30.0, 0.3, 1.5)$, moderate stratification and strong shear.\n- Case $4$: $(40.0, 0.4, 0.0)$, stable stratification and vanishing shear.\n- Case $5$: $(0.0, 0.2, 0.0)$, zero thickness and vanishing shear.\n- Case $6$: $(60.0, -0.1, 0.3)$, unstable stratification and finite shear.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3\\right]$).",
            "solution": "The objective is to derive a bulk-layer representation of the gradient Richardson number, hereafter referred to as the Bulk Richardson number (BRN), and to implement a program to compute it based on provided layer-mean properties. The derivation will proceed from the fundamental definitions provided.\n\nThe gradient Richardson number, $Ri_g$, is defined as the ratio of the squared buoyancy frequency, $N^2$, to the squared vertical shear, $S^2$:\n$$\nRi_g = \\frac{N^2}{S^2}\n$$\nWe will now derive the bulk expressions for the numerator and the denominator separately.\n\n**1. Derivation of the Bulk Buoyancy Frequency Term ($N^2$)**\n\nThe buoyancy frequency (or Brunt–Väisälä frequency) squared is given by:\n$$\nN^2 = -\\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial z}\n$$\nwhere $g$ is the gravitational acceleration, $\\rho_0$ is a reference density, $\\rho$ is the in situ density, and $z$ is the vertical coordinate, defined as positive upwards.\n\nTo obtain a bulk estimate for a layer of thickness $h$, we approximate the vertical gradient $\\frac{\\partial \\rho}{\\partial z}$ using a finite difference over the layer. Let the top and bottom of the layer be at positions $z_{top}$ and $z_{bottom}$, respectively, such that the layer thickness is $h = z_{top} - z_{bottom}$. The finite difference approximation for the gradient is:\n$$\n\\frac{\\partial \\rho}{\\partial z} \\approx \\frac{\\rho(z_{top}) - \\rho(z_{bottom})}{z_{top} - z_{bottom}} = \\frac{\\rho_{top} - \\rho_{bottom}}{h}\n$$\nThe problem defines the layer-mean density difference as $\\Delta \\rho = \\rho_{bottom} - \\rho_{top}$. Substituting this into the gradient approximation, we have:\n$$\n\\rho_{top} - \\rho_{bottom} = -(\\rho_{bottom} - \\rho_{top}) = -\\Delta \\rho\n$$\nTherefore, the approximation for the density gradient becomes:\n$$\n\\frac{\\partial \\rho}{\\partial z} \\approx -\\frac{\\Delta \\rho}{h}\n$$\nSubstituting this bulk approximation into the equation for $N^2$, we obtain the bulk buoyancy frequency squared:\n$$\nN^2_{bulk} \\approx -\\frac{g}{\\rho_0} \\left( -\\frac{\\Delta \\rho}{h} \\right) = \\frac{g \\Delta \\rho}{\\rho_0 h}\n$$\nFor stable stratification, density increases with depth, so $\\rho_{bottom}  \\rho_{top}$, which implies $\\Delta \\rho  0$. This correctly results in $N^2  0$, consistent with the physics of buoyancy oscillations.\n\n**2. Derivation of the Bulk Vertical Shear Term ($S^2$)**\n\nThe squared magnitude of the vertical shear of the horizontal flow is given by:\n$$\nS^2 = \\left(\\frac{\\partial U}{\\partial z}\\right)^2 + \\left(\\frac{\\partial V}{\\partial z}\\right)^2\n$$\nwhere $U$ and $V$ are the components of the horizontal velocity vector $\\mathbf{u} = (U, V)$.\n\nApproximating the vertical gradients of the velocity components over the layer of thickness $h$:\n$$\n\\frac{\\partial U}{\\partial z} \\approx \\frac{\\Delta U_{comp}}{h} \\quad \\text{and} \\quad \\frac{\\partial V}{\\partial z} \\approx \\frac{\\Delta V_{comp}}{h}\n$$\nwhere $\\Delta U_{comp}$ and $\\Delta V_{comp}$ are the differences in the velocity components across the layer.\nSubstituting these into the expression for $S^2$ yields the bulk shear squared:\n$$\nS^2_{bulk} \\approx \\left(\\frac{\\Delta U_{comp}}{h}\\right)^2 + \\left(\\frac{\\Delta V_{comp}}{h}\\right)^2 = \\frac{(\\Delta U_{comp})^2 + (\\Delta V_{comp})^2}{h^2}\n$$\nThe term $(\\Delta U_{comp})^2 + (\\Delta V_{comp})^2$ represents the squared magnitude of the vector velocity difference across the layer, $|\\Delta \\mathbf{u}|^2$. The problem provides this quantity directly as $\\Delta U$, which is defined as the \"magnitude of the horizontal velocity difference\". Thus, we can write:\n$$\nS^2_{bulk} \\approx \\frac{(\\Delta U)^2}{h^2}\n$$\n\n**3. Formulation of the Bulk Richardson Number (BRN)**\n\nBy substituting the bulk expressions for $N^2$ and $S^2$ into the definition of the Richardson number, we derive the expression for the BRN:\n$$\nBRN = \\frac{N^2_{bulk}}{S^2_{bulk}} \\approx \\frac{\\frac{g \\Delta \\rho}{\\rho_0 h}}{\\frac{(\\Delta U)^2}{h^2}}\n$$\nSimplifying this expression, we arrive at the final formula for the Bulk Richardson number:\n$$\nBRN = \\frac{g \\Delta \\rho}{\\rho_0 h} \\cdot \\frac{h^2}{(\\Delta U)^2} = \\frac{g h \\Delta \\rho}{\\rho_0 (\\Delta U)^2}\n$$\nThis dimensionless number characterizes the ratio of stratification-induced stability to shear-induced instability for the entire layer.\n\n**4. Computational Implementation and Handling of Limiting Cases**\n\nTo implement the computation, we define the numerator of the final expression as $N_{final} = g h \\Delta \\rho$ and the denominator as $D_{final} = \\rho_0 (\\Delta U)^2$. The BRN is their ratio. The problem specifies rules for handling singular cases, which we interpret in the context of this final derived expression.\n\n- If $D_{final} = 0$ (which occurs when $\\Delta U = 0$) and $N_{final}  0$ (stable stratification, $h0$, $\\Delta\\rho0$), the expression becomes $\\frac{0}{0}$, corresponding to an infinitely stable layer. The program should return positive infinity ($+\\infty$).\n- If $D_{final} = 0$ and $N_{final}  0$ (unstable stratification, $h0$, $\\Delta\\rho0$), the expression becomes $\\frac{0}{0}$, corresponding to an infinitely unstable layer. The program should return negative infinity ($-\\infty$).\n- If both $D_{final} = 0$ ($\\Delta U = 0$) and $N_{final} = 0$ (which occurs if $h=0$ or $\\Delta \\rho = 0$), the expression is indeterminate ($0/0$). The program should return Not a Number ($\\mathrm{NaN}$). This correctly handles the physically singular case of a layer with zero thickness.\n\nThe program will apply this logic and the derived formula to each test case, using the provided constants $g = 9.81 \\, \\text{m/s}^2$ and $\\rho_0 = 1025 \\, \\text{kg/m}^3$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes the Bulk Richardson Number (BRN) for a set of oceanic test cases.\n    The validation of the problem statement has been completed, and the problem is deemed valid.\n    This function proceeds with the solution as per the problem's requirements.\n    \"\"\"\n\n    # Constants provided in the problem statement.\n    G = 9.81  # Gravitational acceleration in m/s^2\n    RHO_0 = 1025.0  # Reference density in kg/m^3\n\n    # Test suite: each tuple is (h, delta_rho, delta_U)\n    # h: Mixed Layer Depth in meters\n    # delta_rho: Layer-mean density difference (bottom - top) in kg/m^3\n    # delta_U: Magnitude of the horizontal velocity difference in m/s\n    test_cases = [\n        (50.0, 0.5, 0.2),   # Case 1: typical stable stratification and moderate shear.\n        (20.0, 0.01, 0.1),  # Case 2: near-neutral stratification and weak shear.\n        (30.0, 0.3, 1.5),   # Case 3: moderate stratification and strong shear.\n        (40.0, 0.4, 0.0),   # Case 4: stable stratification and vanishing shear.\n        (0.0, 0.2, 0.0),    # Case 5: zero thickness and vanishing shear.\n        (60.0, -0.1, 0.3),  # Case 6: unstable stratification and finite shear.\n    ]\n\n    def compute_brn(h, delta_rho, delta_u):\n        \"\"\"\n        Computes the Bulk Richardson number based on the derived formula.\n        \n        BRN = (g * h * delta_rho) / (rho_0 * delta_u^2)\n\n        Args:\n            h (float): Mixed Layer Depth (m).\n            delta_rho (float): Density difference across the layer (kg/m^3).\n            delta_u (float): Velocity difference magnitude across the layer (m/s).\n\n        Returns:\n            float: The dimensionless Bulk Richardson number, or inf, -inf, nan for special cases.\n        \"\"\"\n        # Numerator of the final derived BRN expression\n        brn_numerator = G * h * delta_rho\n        \n        # Denominator of the final derived BRN expression\n        # This corresponds to rho_0 * (shear_velocity_magnitude)^2\n        brn_denominator = RHO_0 * (delta_u ** 2)\n\n        # Handle limiting behaviors as specified in the problem statement\n        if brn_denominator == 0.0:\n            if brn_numerator > 0.0:\n                return np.inf\n            elif brn_numerator  0.0:\n                return -np.inf\n            else:  # brn_numerator is also 0.0\n                return np.nan\n        else:\n            return brn_numerator / brn_denominator\n\n    results = []\n    for h_case, drho_case, dU_case in test_cases:\n        result = compute_brn(h_case, drho_case, dU_case)\n        results.append(result)\n\n    # Format the output as a comma-separated list enclosed in square brackets.\n    # The str() function for numpy values (inf, -inf, nan) produces the required string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real ocean profiles are often complicated by turbulent mixing, which can create density inversions, or \"overturns,\" where the raw calculation of $N^2$ would be negative and unphysical for a background state. This advanced practice introduces a powerful diagnostic technique to handle such data by computationally reordering the density profile into a gravitationally stable reference state. By comparing the stratification of the observed profile to this reordered profile, you can quantify the extent of turbulent activity and its biasing effect on stratification estimates, a key skill in the study of ocean microstructure and mixing. ",
            "id": "3812291",
            "problem": "You are given vertical profiles of depth and in situ density exhibiting patches of density inversions consistent with turbulent overturns. The computational task is to reconstruct a statically stable reference profile by reordering density monotonically with increasing depth and then to quantify the bias introduced by overturns in the raw estimate of the squared buoyancy frequency. The derivation and algorithm must start from a fundamental base: hydrostatic balance $\\,\\partial p/\\partial z=-\\rho g\\,$, the Boussinesq approximation with buoyancy $\\,b(z)=-g\\left(\\rho(z)-\\rho_0\\right)/\\rho_0\\,$, and the definition of the Brunt–Väisälä (buoyancy) frequency $\\,N^2=\\partial b/\\partial z\\,$ expressed consistently with the chosen vertical coordinate. Use depth $\\,d\\,$ in meters as the vertical coordinate that is positive downward. Work in the Boussinesq limit with a constant reference density $\\,\\rho_0\\,\\,$ in kilograms per cubic meter, gravitational acceleration $\\,g\\,\\,$ in meters per second squared, and density $\\,\\rho(d)\\,$ in kilograms per cubic meter. Your algorithm must compute $\\,N^2(d)\\,$ in units of $\\,\\mathrm{s}^{-2}\\,$ for the raw (overturned) and reordered (statically stable) profiles using a numerically consistent finite-difference scheme that is second-order centered in the interior and first-order one-sided at the boundaries. Then compute, for each test case, a single scalar metric of overturn-induced bias defined as the mean fractional bias of $\\,N^2\\,$ over depths where the reordered $\\,N^2\\,$ exceeds a small threshold $\\,\\epsilon\\,$, namely\n$$\n\\text{bias}=\\frac{1}{M}\\sum_{i\\in\\mathcal{I}}\\frac{N^2_{\\text{raw}}(d_i)-N^2_{\\text{reordered}}(d_i)}{\\max\\!\\left(N^2_{\\text{reordered}}(d_i),\\,\\epsilon\\right)},\n$$\nwhere $\\,\\mathcal{I}=\\{i:\\,N^2_{\\text{reordered}}(d_i)\\epsilon\\}\\,$ and $\\,M=|\\mathcal{I}|\\,$. If $\\,M=0\\,$, set the bias to $\\,0.0\\,$. Use $\\,g=9.81\\,$, $\\,\\rho_0=1025.0\\,$, and $\\,\\epsilon=10^{-7}\\,$. Express $\\,N^2\\,$ in $\\,\\mathrm{s}^{-2}\\,$ internally; the final reported bias is dimensionless and must be a decimal.\n\nImplement the algorithm and evaluate it on the following test suite. In each case, construct $\\,\\rho(d)\\,$ deterministically using trigonometric perturbations to avoid randomness, and create a localized overturn by reversing a contiguous segment of the profile to introduce density inversions. All densities are in kilograms per cubic meter, depths are in meters, and trigonometric arguments are in radians.\n\n- Test case $\\,1\\,$ (general stable profile with a small overturn patch): $\\,d=\\{0,1,2,\\dots,100\\}\\,$; baseline $\\,\\rho_{\\mathrm{base}}(d)=1025.0+0.2\\,(d/100)\\,$; perturbation $\\,\\delta\\rho(d)=0.005\\sin\\!\\left(2\\pi d/20\\right)\\,$; raw profile $\\,\\rho(d)=\\rho_{\\mathrm{base}}(d)+\\delta\\rho(d)\\,$; introduce an overturn by reversing the segment $\\,d\\in[42,49]\\,$ (i.e., indices $\\,42:50\\,$).\n- Test case $\\,2\\,$ (nearly neutral stratification): $\\,d=\\{0,1,2,\\dots,50\\}\\,$; baseline $\\,\\rho_{\\mathrm{base}}(d)=1025.0\\,$; perturbation $\\,\\delta\\rho(d)=0.0005\\sin\\!\\left(2\\pi d/10\\right)\\,$; raw profile $\\,\\rho(d)=\\rho_{\\mathrm{base}}(d)+\\delta\\rho(d)\\,$; do not reverse any segment.\n- Test case $\\,3\\,$ (strong overturn within a thicker layer): $\\,d=\\{0,1,2,\\dots,200\\}\\,$; baseline $\\,\\rho_{\\mathrm{base}}(d)=1025.0+0.5\\,(d/200)\\,$; perturbation $\\,\\delta\\rho(d)=0.01\\sin\\!\\left(2\\pi d/30\\right)\\,$; raw profile $\\,\\rho(d)=\\rho_{\\mathrm{base}}(d)+\\delta\\rho(d)\\,$; introduce an overturn by reversing the segment $\\,d\\in[80,119]\\,$ (i.e., indices $\\,80:120\\,$).\n- Test case $\\,4\\,$ (coarse vertical resolution with layered structure and an overturn): $\\,d=\\{0,10,20,\\dots,300\\}\\,$; piecewise baseline\n$$\n\\rho_{\\mathrm{base}}(d)=\n\\begin{cases}\n1026.0,  0\\le d\\le 100,\\\\\n1026.0+0.8\\,\\frac{d-100}{100},  100d\\le 200,\\\\\n1026.8+0.1\\,\\frac{d-200}{100},  200d\\le 300,\n\\end{cases}\n$$\nperturbation $\\,\\delta\\rho(d)=0.02\\sin\\!\\left(2\\pi d/50\\right)\\,$; raw profile $\\,\\rho(d)=\\rho_{\\mathrm{base}}(d)+\\delta\\rho(d)\\,$; introduce an overturn by reversing the segment $\\,d\\in[120,160]\\,$.\n\nYour program must implement the algorithm described above and, for each test case, output the single scalar bias value as defined. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,x_3,x_4]$). The outputs must be decimals. Internally ensure that derivatives with respect to $\\,d\\,$ are computed using second-order centered differences in the interior points and first-order one-sided differences at the endpoints. All intermediate $\\,N^2\\,$ values must be computed in $\\,\\mathrm{s}^{-2}\\,$; the final reported bias is dimensionless and should be computed exactly as specified.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of physical oceanography, is mathematically and computationally well-posed, and all parameters and procedures are specified unambiguously.\n\nThe-core-task-is-to-quantify-the-bias-in-the-squared-buoyancy-frequency-($N^2$)-estimate-caused-by-density-inversions-in-a-vertical-profile-The-analysis-hinges-on-comparing-the-$N^2$-profile-calculated-from-the-raw-data-with-one-calculated-from-a-reconstructed-statically-stable-reference-profile\n\n**1. Theoretical Framework**\n\nThe foundation of this problem lies in the concept of static stability in a fluid. A fluid column is statically stable if its density increases with depth. Any deviation, where lighter fluid is found beneath denser fluid, represents a gravitational instability, often resulting from turbulent mixing or other dynamic processes.\n\nThe vertical coordinate is depth $d$, defined as positive downwards. The standard oceanographic vertical coordinate $z$ is positive upwards, so we have the relation $z = -d$. The derivative operator transforms accordingly: $\\partial/\\partial z = -\\partial/\\partial d$.\n\nThe Boussinesq approximation simplifies the equations of motion by assuming density variations are small, except where multiplied by gravity (the buoyancy term). Buoyancy $b$ is defined as:\n$$\nb(z) = -g\\frac{\\rho(z) - \\rho_0}{\\rho_0}\n$$\nwhere $g$ is the acceleration due to gravity, $\\rho(z)$ is the in situ density, and $\\rho_0$ is a constant reference density. Expressed in terms of depth $d$, this is $b(d) = -g(\\rho(d) - \\rho_0)/\\rho_0$.\n\nThe squared Brunt–Väisälä frequency, or buoyancy frequency, $N^2$, quantifies the strength of the static stability. It is defined as the vertical gradient of buoyancy:\n$$\nN^2 = \\frac{\\partial b}{\\partial z}\n$$\nSubstituting the expression for $b$ and changing the variable to depth $d$:\n$$\nN^2 = -\\frac{\\partial b}{\\partial d} = -\\frac{\\partial}{\\partial d} \\left( -g\\frac{\\rho(d) - \\rho_0}{\\rho_0} \\right) = \\frac{g}{\\rho_0} \\frac{\\partial \\rho}{\\partial d}\n$$\nFor a stable fluid column, density must increase with depth, so $\\partial \\rho / \\partial d  0$, which implies $N^2  0$. Regions with density inversions ($\\partial \\rho / \\partial d  0$) are characterized by $N^2  0$ and are statically unstable. The problem provides $g=9.81\\,\\mathrm{m/s^2}$ and $\\rho_0=1025.0\\,\\mathrm{kg/m^3}$.\n\n**2. Algorithmic Procedure**\n\nThe algorithm to solve this problem involves four main steps, which are executed for each test case.\n\n**Step 1: Profile Generation**\nFor each test case, a discrete vertical profile of `raw` density, $\\rho_{\\text{raw}}(d_i)$, is constructed at a series of depths $d_i$. This involves:\n-   Generating the depth grid $d$.\n-   Calculating a baseline density profile, $\\rho_{\\text{base}}(d)$.\n-   Calculating a perturbation, $\\delta\\rho(d)$.\n-   Summing them to get an initial profile: $\\rho(d) = \\rho_{\\text{base}}(d) + \\delta\\rho(d)$.\n-   For cases with turbulent overturns, a specified contiguous segment of the $\\rho(d)$ array is reversed to create $\\rho_{\\text{raw}}(d_i)$. This introduces a significant density inversion.\n\n**Step 2: Stable Profile Reconstruction**\nA statically stable reference profile, $\\rho_{\\text{reordered}}(d_i)$, is created from the raw profile. This is achieved by sorting the density values of $\\rho_{\\text{raw}}(d_i)$ in ascending order.\n$$\n\\rho_{\\text{reordered}} = \\text{sort}(\\rho_{\\text{raw}})\n$$\nThis procedure, analogous to the Thorpe-sort method in oceanography, reorders the water parcels to their stable positions without changing the overall distribution of water masses. The resulting profile, $\\rho_{\\textreordered}(d_i)$, is monotonically non-decreasing with depth $d_i$.\n\n**Step 3: Buoyancy Frequency ($N^2$) Calculation**\nWith the `raw` and `reordered` density profiles, we compute their respective squared buoyancy frequencies, $N^2_{\\text{raw}}$ and $N^2_{\\text{reordered}}$. This requires calculating the vertical derivative of density, $\\partial \\rho / \\partial d$. The problem specifies a finite-difference scheme:\n-   At interior grid points $i \\in [1, N-2]$, a second-order centered difference is used:\n    $$\n    \\left(\\frac{\\partial \\rho}{\\partial d}\\right)_i \\approx \\frac{\\rho_{i+1} - \\rho_{i-1}}{d_{i+1} - d_{i-1}}\n    $$\n-   At the boundaries, first-order one-sided differences are used:\n    -   Top boundary ($i=0$): $\\left(\\frac{\\partial \\rho}{\\partial d}\\right)_0 \\approx \\frac{\\rho_1 - \\rho_0}{d_1 - d_0}$ (forward difference).\n    -   Bottom boundary ($i=N-1$): $\\left(\\frac{\\partial \\rho}{\\partial d}\\right)_{N-1} \\approx \\frac{\\rho_{N-1} - \\rho_{N-2}}{d_{N-1} - d_{N-2}}$ (backward difference).\n\nThis numerical derivative is computed for both $\\rho_{\\text{raw}}$ and $\\rho_{\\text{reordered}}$. The results are then used to calculate $N^2$ for each profile:\n$$\nN^2_{\\text{raw}}(d_i) = \\frac{g}{\\rho_0} \\left(\\frac{\\partial \\rho_{\\text{raw}}}{\\partial d}\\right)_i \\quad \\text{and} \\quad N^2_{\\text{reordered}}(d_i) = \\frac{g}{\\rho_0} \\left(\\frac{\\partial \\rho_{\\text{reordered}}}{\\partial d}\\right)_i\n$$\nAll $N^2$ values are in units of $\\mathrm{s}^{-2}$.\n\n**Step 4: Overturn-Induced Bias Calculation**\nThe final step is to compute the mean fractional bias, a scalar metric that quantifies the disagreement between the `raw` and `reordered` $N^2$ estimates. The formula is:\n$$\n\\text{bias}=\\frac{1}{M}\\sum_{i\\in\\mathcal{I}}\\frac{N^2_{\\text{raw}}(d_i)-N^2_{\\text{reordered}}(d_i)}{\\max\\!\\left(N^2_{\\text{reordered}}(d_i),\\,\\epsilon\\right)}\n$$\nThe summation is performed over a specific set of indices, $\\mathcal{I} = \\{i: N^2_{\\text{reordered}}(d_i)  \\epsilon\\}$, where $\\epsilon = 10^{-7}\\,\\mathrm{s}^{-2}$ is a small positive threshold. This threshold ensures that the normalization is only done where the background stratification is physically meaningful, avoiding division by zero or small numbers. $M$ is the number of such indices, $M=|\\mathcal{I}|$. If $M=0$ (i.e., the reordered profile is essentially unstratified), the bias is defined as $0.0$. A negative bias indicates that the raw profile, on average, underestimates the true background stratification, which is the expected effect of turbulent overturns.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It generates density profiles, computes buoyancy frequencies,\n    and calculates the overturn-induced bias.\n    \"\"\"\n    g = 9.81\n    rho_0 = 1025.0\n    epsilon = 1e-7\n\n    def calculate_bias(d, rho_raw, g_const, rho_0_const, eps_const):\n        \"\"\"\n        Calculates the overturn-induced bias for a given profile.\n\n        Args:\n            d (np.ndarray): Array of depths (m).\n            rho_raw (np.ndarray): Array of raw in situ densities (kg/m^3).\n            g_const (float): Gravitational acceleration (m/s^2).\n            rho_0_const (float): Reference density (kg/m^3).\n            eps_const (float): Threshold for N^2 (s^-2).\n\n        Returns:\n            float: The calculated bias metric.\n        \"\"\"\n        # Step 2: Reconstruct stable profile\n        rho_reordered = np.sort(rho_raw)\n\n        # Step 3: Compute N^2 for both profiles\n        # np.gradient uses second-order centered difference for interior\n        # and first-order one-sided difference for boundaries by default.\n        d_rho_raw_dd = np.gradient(rho_raw, d)\n        d_rho_reordered_dd = np.gradient(rho_reordered, d)\n\n        factor = g_const / rho_0_const\n        N2_raw = factor * d_rho_raw_dd\n        N2_reordered = factor * d_rho_reordered_dd\n\n        # Step 4: Calculate the bias metric\n        indices_I = np.where(N2_reordered > eps_const)[0]\n        M = len(indices_I)\n\n        if M == 0:\n            return 0.0\n\n        N2_raw_I = N2_raw[indices_I]\n        N2_reordered_I = N2_reordered[indices_I]\n\n        numerator = N2_raw_I - N2_reordered_I\n        denominator = np.maximum(N2_reordered_I, eps_const)\n        \n        terms = numerator / denominator\n        bias = np.mean(terms)\n\n        return bias\n\n    results = []\n\n    # Test Case 1\n    d1 = np.arange(101, dtype=float)\n    rho_base1 = 1025.0 + 0.2 * (d1 / 100.0)\n    delta_rho1 = 0.005 * np.sin(2 * np.pi * d1 / 20.0)\n    rho_raw1 = rho_base1 + delta_rho1\n    rho_raw1[42:50] = rho_raw1[42:50][::-1]\n    bias1 = calculate_bias(d1, rho_raw1, g, rho_0, epsilon)\n    results.append(bias1)\n\n    # Test Case 2\n    d2 = np.arange(51, dtype=float)\n    rho_base2 = 1025.0 * np.ones_like(d2)\n    delta_rho2 = 0.0005 * np.sin(2 * np.pi * d2 / 10.0)\n    rho_raw2 = rho_base2 + delta_rho2\n    # No reversal for this case\n    bias2 = calculate_bias(d2, rho_raw2, g, rho_0, epsilon)\n    results.append(bias2)\n\n    # Test Case 3\n    d3 = np.arange(201, dtype=float)\n    rho_base3 = 1025.0 + 0.5 * (d3 / 200.0)\n    delta_rho3 = 0.01 * np.sin(2 * np.pi * d3 / 30.0)\n    rho_raw3 = rho_base3 + delta_rho3\n    rho_raw3[80:120] = rho_raw3[80:120][::-1]\n    bias3 = calculate_bias(d3, rho_raw3, g, rho_0, epsilon)\n    results.append(bias3)\n    \n    # Test Case 4\n    d4 = np.arange(0, 301, 10, dtype=float)\n    rho_base4 = np.zeros_like(d4)\n    # Piecewise definition of baseline density\n    cond1 = (d4 >= 0)  (d4 = 100)\n    cond2 = (d4 > 100)  (d4 = 200)\n    cond3 = (d4 > 200)  (d4 = 300)\n    rho_base4[cond1] = 1026.0\n    rho_base4[cond2] = 1026.0 + 0.8 * (d4[cond2] - 100.0) / 100.0\n    rho_base4[cond3] = 1026.8 + 0.1 * (d4[cond3] - 200.0) / 100.0\n    delta_rho4 = 0.02 * np.sin(2 * np.pi * d4 / 50.0)\n    rho_raw4 = rho_base4 + delta_rho4\n    # Overturn for depths 120 to 160 inclusive (indices 12 to 16)\n    rho_raw4[12:17] = rho_raw4[12:17][::-1]\n    bias4 = calculate_bias(d4, rho_raw4, g, rho_0, epsilon)\n    results.append(bias4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}