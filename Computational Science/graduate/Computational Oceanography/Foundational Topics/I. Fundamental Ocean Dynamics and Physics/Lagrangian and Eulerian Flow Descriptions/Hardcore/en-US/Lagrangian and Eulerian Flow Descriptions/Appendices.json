{
    "hands_on_practices": [
        {
            "introduction": "In oceanography, flows are rarely steady. This exercise explores the crucial distinctions between pathlines, streamlines, and streaklines that emerge in time-dependent velocity fields. By analytically deriving these three representations for a simple unsteady flow, you will solidify your conceptual understanding of what each one reveals about the fluid's motion, a foundational step before interpreting data from complex ocean models .",
            "id": "3796714",
            "problem": "Consider a two-dimensional, horizontally uniform but time-dependent ocean surface current described in the Eulerian frame by the velocity field $\\mathbf{u}(x,y,t) = \\left(U_0 + U_1 \\sin(\\omega t)\\right)\\,\\hat{\\mathbf{i}}$, where $U_0$, $U_1$, and $\\omega$ are positive constants with $U_0 > |U_1|$ to ensure that the flow direction remains downstream ($+\\hat{\\mathbf{i}}$) for all time. A passive dye is continuously emitted from a point source located at the origin $(x,y)=(0,0)$, beginning at time $t=0$. Throughout, assume an incompressible, non-divergent surface flow and neglect vertical motion.\n\nUsing only fundamental kinematics and the definitions of Lagrangian and Eulerian descriptions in fluid mechanics, complete the following:\n\n1) Starting from the definition of a pathline as the Lagrangian trajectory of an individual fluid element, which satisfies the ordinary differential equations (ODEs) $dx/dt = u(x(t),y(t),t)$ and $dy/dt = v(x(t),y(t),t)$ with initial data $x(t_0)=x_0$ and $y(t_0)=y_0$, derive the analytical expressions for the pathline $(x(t),y(t))$ of a particle that is at $(x_0,y_0)$ at time $t_0$.\n\n2) Using the definition of a streamline at a fixed time $t^{\\ast}$ as the curve tangent everywhere to the instantaneous velocity field, which satisfies $dy/dx = v(x,y,t^{\\ast})/u(x,y,t^{\\ast})$, derive the equation of the streamline that passes through a generic point $(x^{\\ast},y^{\\ast})$ at time $t^{\\ast}$.\n\n3) Using the definition of a streakline at a time $t=T$ as the locus of all fluid particles that have previously passed through the source at $(0,0)$ at some emission time $\\tau \\in [0,T]$, derive a parametric representation for the streakline at time $T$ in terms of the emission time $\\tau$. Then, using the assumption $U_0 > |U_1|$, determine which emission time $\\tau$ yields the farthest downstream point of the streakline and derive an explicit, closed-form expression for the downstream extent of the streakline at time $T$.\n\n4) Briefly but rigorously discuss the similarities and differences among the pathlines, streamlines (at a fixed time), and streaklines for this flow, emphasizing which aspects are identical and which depend on the flow’s temporal variability.\n\nFinally, provide the single closed-form expression for the downstream extent derived in part $3$ in terms of $U_0$, $U_1$, $\\omega$, and $T$. Since $U_0$ and $U_1$ are velocities in meters per second, $\\omega$ is in radians per second, and $T$ is in seconds, the downstream extent has units of meters. Express the final result symbolically in terms of $U_0$, $U_1$, $\\omega$, and $T$; do not attach units in your boxed final answer.",
            "solution": "The problem describes a two-dimensional, time-dependent, but spatially uniform ocean surface current. The Eulerian velocity field is given by $\\mathbf{u}(x,y,t) = \\left(U_0 + U_1 \\sin(\\omega t)\\right)\\,\\hat{\\mathbf{i}}$, which has components $u(x,y,t) = U_0 + U_1 \\sin(\\omega t)$ and $v(x,y,t) = 0$. The constants $U_0$, $U_1$, and $\\omega$ are positive, with the condition $U_0 > U_1$ ensuring the flow is always in the positive $\\hat{\\mathbf{i}}$ direction.\n\n1) A pathline, denoted by $(x(t), y(t))$, is the trajectory of an individual fluid particle. It is determined by integrating the velocity field with respect to time, subject to an initial condition $(x(t_0), y(t_0)) = (x_0, y_0)$. The governing ordinary differential equations are:\n$$\n\\frac{dx}{dt} = u(x(t), y(t), t) = U_0 + U_1 \\sin(\\omega t)\n$$\n$$\n\\frac{dy}{dt} = v(x(t), y(t), t) = 0\n$$\nWe integrate the equation for the $y$-component from the initial time $t_0$ to a generic time $t$:\n$$\n\\int_{y_0}^{y(t)} dy' = \\int_{t_0}^{t} 0 \\, dt' \\implies y(t) - y_0 = 0 \\implies y(t) = y_0\n$$\nThis result shows that the particle's motion is confined to the horizontal line on which it started.\nNext, we integrate the equation for the $x$-component from $t_0$ to $t$:\n$$\n\\int_{x_0}^{x(t)} dx' = \\int_{t_0}^{t} \\left( U_0 + U_1 \\sin(\\omega t') \\right) \\, dt'\n$$\n$$\nx(t) - x_0 = \\int_{t_0}^{t} U_0 \\, dt' + \\int_{t_0}^{t} U_1 \\sin(\\omega t') \\, dt'\n$$\n$$\nx(t) - x_0 = U_0 [t']_{t_0}^{t} + U_1 \\left[ -\\frac{1}{\\omega}\\cos(\\omega t') \\right]_{t_0}^{t}\n$$\n$$\nx(t) - x_0 = U_0(t - t_0) - \\frac{U_1}{\\omega} \\left( \\cos(\\omega t) - \\cos(\\omega t_0) \\right)\n$$\nThe analytical expression for the particle's x-coordinate is therefore:\n$$\nx(t) = x_0 + U_0(t - t_0) - \\frac{U_1}{\\omega}(\\cos(\\omega t) - \\cos(\\omega t_0))\n$$\nThe complete pathline is given by the pair $(x(t), y(t))$.\n\n2) A streamline is a curve that is everywhere tangent to the instantaneous velocity field at a fixed time $t^{\\ast}$. Its slope in the $(x,y)$-plane is defined by the differential equation:\n$$\n\\frac{dy}{dx} = \\frac{v(x,y,t^{\\ast})}{u(x,y,t^{\\ast})}\n$$\nAt the fixed time $t^{\\ast}$, the velocity components are $u(x,y,t^{\\ast}) = U_0 + U_1 \\sin(\\omega t^{\\ast})$ and $v(x,y,t^{\\ast}) = 0$. Substituting these into the equation gives:\n$$\n\\frac{dy}{dx} = \\frac{0}{U_0 + U_1 \\sin(\\omega t^{\\ast})}\n$$\nThe condition $U_0 > U_1$ ensures that the denominator $U_0 + U_1 \\sin(\\omega t^{\\ast})$ is always positive, as its minimum value is $U_0 - U_1 > 0$. Therefore, the slope of the streamline is always zero:\n$$\n\\frac{dy}{dx} = 0\n$$\nIntegrating this equation yields $y = C$, where $C$ is a constant. For the streamline that passes through the point $(x^{\\ast}, y^{\\ast})$, the constant must be $C = y^{\\ast}$. Thus, the equation of the streamline is:\n$$\ny = y^{\\ast}\n$$\nThis demonstrates that for this flow, the streamlines at any instant in time are a family of horizontal lines.\n\n3) A streakline at a time $T$ is the locus of positions of all fluid particles that have passed through a specific point—in this case, the source at the origin $(0,0)$—at some previous emission time $\\tau$, where $0 \\le \\tau \\le T$. To find the streakline, we consider a particle released from $(x_0, y_0) = (0,0)$ at time $t_0=\\tau$ and determine its position $(x,y)$ at the observation time $t=T$. We use the pathline equations derived in part (1) with these specific parameters.\nThe y-coordinate of any such particle at time $T$ is $y(T) = y_0 = 0$.\nThe x-coordinate is found by setting $x_0=0$, $t_0=\\tau$, and $t=T$ in the pathline equation for $x(t)$:\n$$\nx(T; \\tau) = 0 + U_0(T - \\tau) - \\frac{U_1}{\\omega}(\\cos(\\omega T) - \\cos(\\omega \\tau))\n$$\nRearranging for clarity, we get the parametric representation for the x-coordinate of the streakline at time $T$, with parameter $\\tau$:\n$$\nx_{\\text{streak}}(T; \\tau) = U_0(T - \\tau) + \\frac{U_1}{\\omega}(\\cos(\\omega \\tau) - \\cos(\\omega T))\n$$\nThe streakline itself lies on the x-axis, extending from the origin (the particle just released at $\\tau=T$) to the point corresponding to the particle released at $\\tau=0$.\nTo find the farthest downstream point, we must find the maximum value of $x_{\\text{streak}}(T; \\tau)$ for $\\tau \\in [0, T]$. We differentiate $x_{\\text{streak}}(T; \\tau)$ with respect to $\\tau$:\n$$\n\\frac{d}{d\\tau}x_{\\text{streak}}(T; \\tau) = -U_0 - U_1 \\sin(\\omega \\tau)\n$$\nTo find critical points, we would set this derivative to zero, which gives $\\sin(\\omega \\tau) = -\\frac{U_0}{U_1}$. However, the given constraint $U_0 > U_1 > 0$ implies that $-\\frac{U_0}{U_1}  -1$. The sine function cannot take this value, so there are no critical points in the interior of the domain. The maximum must therefore occur at one of the boundaries of the interval $\\tau \\in [0, T]$, i.e., at $\\tau=0$ or $\\tau=T$.\nWe can inspect the sign of the derivative. Since $-1 \\le \\sin(\\omega \\tau) \\le 1$, the term $-U_1 \\sin(\\omega \\tau)$ lies in $[-U_1, U_1]$. The derivative is thus bounded: $\\frac{d}{d\\tau}x_{\\text{streak}}(T; \\tau) \\le -U_0 + U_1$. Given $U_0 > U_1$, the quantity $-U_0 + U_1$ is negative. Therefore, $\\frac{d}{d\\tau}x_{\\text{streak}}(T; \\tau)  0$ for all values of $\\tau$.\nThis means that $x_{\\text{streak}}(T; \\tau)$ is a strictly decreasing function of $\\tau$. The maximum value must occur at the minimum value of $\\tau$, which is $\\tau=0$. Physically, this corresponds to the particle that was released first and has had the longest time to travel. The downstream extent is this maximum x-value:\n$$\nx_{\\text{max}} = x_{\\text{streak}}(T; 0) = U_0(T - 0) + \\frac{U_1}{\\omega}(\\cos(\\omega \\cdot 0) - \\cos(\\omega T))\n$$\n$$\nx_{\\text{max}} = U_0 T + \\frac{U_1}{\\omega}(1 - \\cos(\\omega T))\n$$\nThis is the required closed-form expression for the downstream extent of the streakline.\n\n4) For this particular unidirectional but unsteady flow, the relationships between pathlines, streamlines, and streaklines are as follows:\n- **Similarities**: All three curves are geometrically identical: they are horizontal straight lines. This is a direct consequence of the velocity field being unidirectional (always in the $+\\hat{\\mathbf{i}}$ direction). A streamline is a line $y = \\text{constant}$. A pathline is a segment of such a line. A streakline from a point source is also a segment of such a line.\n- **Differences**: The primary differences are conceptual and arise because the flow is unsteady ($U_1 \\neq 0$).\n  - A **streamline** is an instantaneous 'map' of the flow direction. Here, it is always a horizontal line, regardless of the time $t^{\\ast}$.\n  - A **pathline** is the integrated history of a single particle's movement. While the path is a straight line, the particle's speed along it, $u(t) = U_0 + U_1 \\sin(\\omega t)$, varies with time.\n  - A **streakline** is an instantaneous snapshot of a collection of particles with different histories. At time $T$, it shows the positions of all particles emitted from the source at times $0 \\le \\tau \\le T$. The length of the streakline, as found in part (3), depends on the time-integrated flow history and is not a simple linear function of time.\n  - If the flow were steady ($U_1=0$), the velocity would be a constant $U_0\\,\\hat{\\mathbf{i}}$. In that case, pathlines, streamlines, and streaklines would all be identical. The unsteadiness is what makes them distinct concepts, even if they share a simple geometry in this special case.",
            "answer": "$$\n\\boxed{U_0 T + \\frac{U_1}{\\omega}(1 - \\cos(\\omega T))}\n$$"
        },
        {
            "introduction": "Most realistic ocean velocity fields are too complex for analytical trajectory solutions, making numerical integration an essential tool in computational oceanography. This practice guides you through implementing the classical fourth-order Runge-Kutta (RK4) scheme, a workhorse for Lagrangian particle tracking. By applying it to a time-dependent vortex with a known exact solution, you will gain hands-on experience with error analysis, specifically calculating the local truncation error and verifying the method's order of accuracy .",
            "id": "3796715",
            "problem": "Consider a two-dimensional Lagrangian particle trajectory governed by the ordinary differential equation $\\dot{\\mathbf{X}}=\\mathbf{u}(\\mathbf{X},t)$, where $\\mathbf{X}(t)\\in\\mathbb{R}^2$ denotes the particle position and $\\mathbf{u}(\\mathbf{x},t)$ is the Eulerian velocity field. The goal is to construct a numerical integrator and analyze its local truncation error from first principles. Begin with the core definitions of Lagrangian and Eulerian flow descriptions, and the definition of a local truncation error for a one-step method. Use only the fundamental law $\\dot{\\mathbf{X}}=\\mathbf{u}(\\mathbf{X},t)$, the definition of a time step $h>0$, and Taylor-series expansions around a point $(\\mathbf{X}(t_0),t_0)$.\n\nYou must implement a classical fourth-order Runge–Kutta (RK) scheme for a single time step that advances $\\mathbf{X}(t_0)$ to an approximation of $\\mathbf{X}(t_0+h)$ using evaluations of $\\mathbf{u}$ at intermediate stage points. Then, you must compute the local truncation error for this single step as the Euclidean norm in meters of the difference between the numerical one-step update and the exact one-step solution for a specified time-dependent mesoscale velocity field.\n\nUse the following scientifically realistic, time-dependent mesoscale vortex field, defined by a time-varying angular velocity:\n- The velocity field is $\\mathbf{u}(\\mathbf{x},t)=\\Omega(t)\\,(-y,x)$ for $\\mathbf{x}=(x,y)$.\n- The angular velocity is $\\Omega(t)=\\Omega_0+\\Omega_1\\sin(\\sigma t)$.\n- All angles must be in radians.\n\nUnder this field, the exact one-step solution from $(\\mathbf{X}(t_0),t_0)$ to time $t_0+h$ is a rotation of the initial position by an angle equal to the time-integral of $\\Omega(t)$ over the interval $[t_0,t_0+h]$. You must use this property to compute the exact one-step position and thereby the local truncation error.\n\nPhysical and numerical units:\n- Positions must be in meters (m).\n- Time must be in seconds (s).\n- Express all outputs in meters (m), rounded by normal floating-point representation. Angles are in radians.\n\nTest suite:\nImplement your program to compute results for the following four test cases. Each case specifies $(\\Omega_0,\\Omega_1,\\sigma)$, the initial condition $\\mathbf{X}_0$, the initial time $t_0$, and the step $h$. For the convergence case, you must compute the ratio of local truncation errors at two step sizes.\n\n- Case $1$ (general, time-dependent vortex; \"happy path\"):\n  - $\\Omega_0=1.2\\times 10^{-5}\\ \\text{s}^{-1}$, $\\Omega_1=4.0\\times 10^{-6}\\ \\text{s}^{-1}$, $\\sigma=\\dfrac{2\\pi}{5\\times 86400}\\ \\text{rad}\\,\\text{s}^{-1}$.\n  - $\\mathbf{X}_0=(5.0\\times 10^{4},-2.5\\times 10^{4})\\ \\text{m}$.\n  - $t_0=0\\ \\text{s}$.\n  - $h=3600\\ \\text{s}$.\n  - Output the local truncation error as a float in meters.\n\n- Case $2$ (observed order via error ratio):\n  - $\\Omega_0=9.5\\times 10^{-6}\\ \\text{s}^{-1}$, $\\Omega_1=3.5\\times 10^{-6}\\ \\text{s}^{-1}$, $\\sigma=\\dfrac{2\\pi}{3\\times 86400}\\ \\text{rad}\\,\\text{s}^{-1}$.\n  - $\\mathbf{X}_0=(8.0\\times 10^{4},3.0\\times 10^{4})\\ \\text{m}$.\n  - $t_0=2\\times 86400\\ \\text{s}$.\n  - Compute the local truncation error at $h=7200\\ \\text{s}$ and at $h/2=3600\\ \\text{s}$, and output the ratio $E(h)/E(h/2)$ as a float (unitless). This ratio should be close to $2^{5}$ for a fourth-order scheme’s local truncation error behavior.\n\n- Case $3$ (boundary condition: zero initial position):\n  - $\\Omega_0=1.0\\times 10^{-5}\\ \\text{s}^{-1}$, $\\Omega_1=6.0\\times 10^{-6}\\ \\text{s}^{-1}$, $\\sigma=\\dfrac{2\\pi}{7\\times 86400}\\ \\text{rad}\\,\\text{s}^{-1}$.\n  - $\\mathbf{X}_0=(0,0)\\ \\text{m}$.\n  - $t_0=1\\times 86400\\ \\text{s}$.\n  - $h=3600\\ \\text{s}$.\n  - Output the local truncation error as a float in meters. This should be exactly $0$ in theory due to the symmetry of the flow at the origin.\n\n- Case $4$ (edge case: rapidly varying angular velocity):\n  - $\\Omega_0=1.0\\times 10^{-5}\\ \\text{s}^{-1}$, $\\Omega_1=1.0\\times 10^{-5}\\ \\text{s}^{-1}$, $\\sigma=\\dfrac{2\\pi}{0.5\\times 86400}\\ \\text{rad}\\,\\text{s}^{-1}$.\n  - $\\mathbf{X}_0=(2.0\\times 10^{4},2.0\\times 10^{4})\\ \\text{m}$.\n  - $t_0=0.25\\times 86400\\ \\text{s}$.\n  - $h=1800\\ \\text{s}$.\n  - Output the local truncation error as a float in meters.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$), where the entries correspond to cases $1$ through $4$ respectively. No other text should be printed.",
            "solution": "We begin from the Lagrangian description of motion, where a fluid parcel’s trajectory $\\mathbf{X}(t)$ satisfies $\\dot{\\mathbf{X}}(t)=\\mathbf{u}(\\mathbf{X}(t),t)$. The Eulerian velocity field $\\mathbf{u}(\\mathbf{x},t)$ gives the velocity at fixed positions and times. The numerical task is to approximate $\\mathbf{X}(t_0+h)$ from $\\mathbf{X}(t_0)$ using a one-step method, and to assess the local truncation error, defined as the difference after one step between the numerical update and the exact solution starting from the same initial data.\n\nPrinciple-based derivation of the classical fourth-order Runge–Kutta (RK) one-step method proceeds by matching the Taylor series of the exact solution of the initial value problem $\\dot{\\mathbf{X}}=\\mathbf{u}(\\mathbf{X},t)$, $\\mathbf{X}(t_0)=\\mathbf{X}_0$. Let $h>0$ be the step size and expand the exact solution:\n$$\n\\mathbf{X}(t_0+h) = \\mathbf{X}_0 + h\\,\\dot{\\mathbf{X}}_0 + \\frac{h^2}{2}\\,\\ddot{\\mathbf{X}}_0 + \\frac{h^3}{6}\\,\\mathbf{X}^{(3)}_0 + \\frac{h^4}{24}\\,\\mathbf{X}^{(4)}_0 + \\mathcal{O}(h^5),\n$$\nwhere derivatives are evaluated at $t_0$. Using $\\dot{\\mathbf{X}}=\\mathbf{u}(\\mathbf{X},t)$ and the chain rule,\n$$\n\\ddot{\\mathbf{X}} = \\frac{d}{dt}\\mathbf{u}(\\mathbf{X},t) = \\partial_t \\mathbf{u} + (\\nabla_{\\mathbf{X}}\\mathbf{u})\\,\\dot{\\mathbf{X}} = \\partial_t \\mathbf{u} + (\\nabla_{\\mathbf{X}}\\mathbf{u})\\,\\mathbf{u},\n$$\nand higher derivatives can be similarly expressed in terms of time and spatial derivatives of $\\mathbf{u}$ composed with $\\mathbf{X}(t)$.\n\nA Runge–Kutta method constructs a weighted combination of velocity evaluations at intermediate stages chosen to match the above Taylor series up to a given order. The classical fourth-order scheme uses four stages\n$$\n\\mathbf{k}_1 = \\mathbf{u}(\\mathbf{X}_0,t_0),\n\\quad\n\\mathbf{k}_2 = \\mathbf{u}\\!\\left(\\mathbf{X}_0 + \\frac{h}{2}\\mathbf{k}_1,\\, t_0 + \\frac{h}{2}\\right),\n\\quad\n\\mathbf{k}_3 = \\mathbf{u}\\!\\left(\\mathbf{X}_0 + \\frac{h}{2}\\mathbf{k}_2,\\, t_0 + \\frac{h}{2}\\right),\n\\quad\n\\mathbf{k}_4 = \\mathbf{u}\\!\\left(\\mathbf{X}_0 + h\\,\\mathbf{k}_3,\\, t_0 + h\\right),\n$$\nand updates\n$$\n\\mathbf{X}_{\\text{RK4}}(t_0+h) = \\mathbf{X}_0 + \\frac{h}{6}\\left(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4\\right).\n$$\nMatching coefficients via Taylor expansion and order conditions (which can be encoded in the Butcher tableau) ensures that the method achieves fourth-order accuracy in the sense that\n$$\n\\mathbf{X}(t_0+h) - \\mathbf{X}_{\\text{RK4}}(t_0+h) = \\mathcal{O}(h^5).\n$$\nThe local truncation error (LTE) is the norm of this difference for one step. For sufficiently smooth $\\mathbf{u}$, the LTE admits an asymptotic expansion\n$$\n\\|\\mathbf{X}(t_0+h) - \\mathbf{X}_{\\text{RK4}}(t_0+h)\\|_2 \\sim C(\\mathbf{X}_0,t_0)\\,h^5 \\quad \\text{as } h\\to 0,\n$$\nwhere $C(\\mathbf{X}_0,t_0)$ depends on derivatives of $\\mathbf{u}$ along the trajectory. Consequently, halving the step size yields the ratio\n$$\n\\frac{E(h)}{E(h/2)} \\approx \\frac{C\\,h^5}{C\\,(h/2)^5} = 2^5 = 32,\n$$\nproviding an observed-order check for the LTE scaling.\n\nExact one-step solution for the specified velocity field is obtained from its structure. With $\\mathbf{u}(\\mathbf{x},t)=\\Omega(t)\\,(-y,x)=\\Omega(t)\\,\\mathbf{J}\\,\\mathbf{x}$, where\n$$\n\\mathbf{J}=\\begin{pmatrix}0  -1 \\\\ 1  0\\end{pmatrix},\n$$\nthe system is linear with time-dependent scalar coefficient multiplying a fixed matrix. Since $\\mathbf{J}$ is constant and matrices $\\Omega(t_1)\\mathbf{J}$ and $\\Omega(t_2)\\mathbf{J}$ commute, the fundamental matrix over $[t_0,t_0+h]$ is a rotation by angle\n$$\n\\theta = \\int_{t_0}^{t_0+h} \\Omega(t)\\,dt = \\Omega_0\\,h + \\frac{\\Omega_1}{\\sigma}\\left[\\cos(\\sigma t_0) - \\cos\\!\\big(\\sigma (t_0+h)\\big)\\right].\n$$\nTherefore,\n$$\n\\mathbf{X}_{\\text{exact}}(t_0+h) = \\mathbf{R}(\\theta)\\,\\mathbf{X}_0,\n\\quad\n\\mathbf{R}(\\theta) = \\begin{pmatrix}\\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta\\end{pmatrix}.\n$$\nThe local truncation error for a single step of size $h$ is then\n$$\nE(h)=\\left\\|\\mathbf{X}_{\\text{RK4}}(t_0+h) - \\mathbf{X}_{\\text{exact}}(t_0+h)\\right\\|_2,\n$$\nexpressed in meters (m).\n\nAlgorithmic design:\n- Implement $\\Omega(t)=\\Omega_0+\\Omega_1\\sin(\\sigma t)$.\n- Implement $\\mathbf{u}(\\mathbf{x},t)=\\Omega(t)\\,(-y,x)$.\n- Implement one-step classical fourth-order Runge–Kutta using the four stages $\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3,\\mathbf{k}_4$ and the weighted combination.\n- Implement the exact one-step rotation using $\\theta$ as above and compute $\\mathbf{X}_{\\text{exact}}(t_0+h)=\\mathbf{R}(\\theta)\\,\\mathbf{X}_0$.\n- Compute the local truncation error $E(h)$ as the Euclidean norm of the difference between the RK4 update and the exact update.\n- For the convergence test, compute $E(h)$ and $E(h/2)$ and form the ratio $E(h)/E(h/2)$.\n\nScientific realism and coverage in the test suite:\n- Case $1$ uses mesoscale-consistent parameters with $\\Omega_0$ of order $10^{-5}\\ \\text{s}^{-1}$ and a moderate sinusoidal modulation with period of $5$ days ($5\\times 86400\\ \\text{s}$).\n- Case $2$ checks observed order by forming an error ratio and should yield a value close to $32$.\n- Case $3$ verifies the boundary condition at the vortex center, where motion is null and the numerical and exact updates coincide, giving $0$ error.\n- Case $4$ explores an edge case with fast modulation (period $0.5$ days), ensuring the method’s LTE behavior is computed under more rapidly varying $\\Omega(t)$.\n\nYour program must produce a single line with the results for cases $1$ through $4$ in the exact order and format specified, namely $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$, where $\\text{result1}$, $\\text{result3}$, and $\\text{result4}$ are floats in meters, and $\\text{result2}$ is a unitless float.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef omega(t, params):\n    \"\"\"Angular velocity Omega(t) = Omega0 + Omega1 * sin(sigma * t).\"\"\"\n    return params[\"Omega0\"] + params[\"Omega1\"] * np.sin(params[\"sigma\"] * t)\n\ndef velocity(x, t, params):\n    \"\"\"Velocity field u(x,t) = Omega(t) * (-y, x).\"\"\"\n    om = omega(t, params)\n    return np.array([-om * x[1], om * x[0]])\n\ndef rk4_step(x, t, h, params):\n    \"\"\"Classical fourth-order Runge–Kutta one-step update for x' = u(x,t).\"\"\"\n    k1 = velocity(x, t, params)\n    k2 = velocity(x + 0.5 * h * k1, t + 0.5 * h, params)\n    k3 = velocity(x + 0.5 * h * k2, t + 0.5 * h, params)\n    k4 = velocity(x + h * k3, t + h, params)\n    return x + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\ndef exact_step(x, t, h, params):\n    \"\"\"Exact one-step solution via rotation by theta = integral Omega(t) dt over [t, t+h].\"\"\"\n    # theta = Omega0*h + (Omega1/sigma) * [cos(sigma t) - cos(sigma (t+h))]\n    theta = params[\"Omega0\"] * h + (params[\"Omega1\"] / params[\"sigma\"]) * (\n        np.cos(params[\"sigma\"] * t) - np.cos(params[\"sigma\"] * (t + h))\n    )\n    c, s = np.cos(theta), np.sin(theta)\n    R = np.array([[c, -s], [s, c]])\n    return R @ x\n\ndef local_truncation_error(x, t, h, params):\n    \"\"\"Euclidean norm of the local truncation error for one RK4 step.\"\"\"\n    x_rk = rk4_step(x, t, h, params)\n    x_ex = exact_step(x, t, h, params)\n    return float(np.linalg.norm(x_rk - x_ex))\n\ndef solve():\n    days = 86400.0  # seconds in a day\n\n    results = []\n\n    # Case 1: general time-dependent vortex; happy path\n    params1 = {\n        \"Omega0\": 1.2e-5,\n        \"Omega1\": 4.0e-6,\n        \"sigma\": 2.0 * np.pi / (5.0 * days),\n    }\n    X01 = np.array([50e3, -25e3])\n    t01 = 0.0\n    h1 = 3600.0\n    err1 = local_truncation_error(X01, t01, h1, params1)\n    results.append(err1)\n\n    # Case 2: observed order via error ratio E(h)/E(h/2)\n    params2 = {\n        \"Omega0\": 9.5e-6,\n        \"Omega1\": 3.5e-6,\n        \"sigma\": 2.0 * np.pi / (3.0 * days),\n    }\n    X02 = np.array([80e3, 30e3])\n    t02 = 2.0 * days\n    h2_big = 7200.0\n    h2_small = h2_big / 2.0\n    err2_big = local_truncation_error(X02, t02, h2_big, params2)\n    err2_small = local_truncation_error(X02, t02, h2_small, params2)\n    ratio2 = err2_big / err2_small if err2_small != 0.0 else float(\"nan\")\n    results.append(ratio2)\n\n    # Case 3: boundary condition at origin; exact error is zero\n    params3 = {\n        \"Omega0\": 1.0e-5,\n        \"Omega1\": 6.0e-6,\n        \"sigma\": 2.0 * np.pi / (7.0 * days),\n    }\n    X03 = np.array([0.0, 0.0])\n    t03 = 1.0 * days\n    h3 = 3600.0\n    err3 = local_truncation_error(X03, t03, h3, params3)\n    results.append(err3)\n\n    # Case 4: edge case with rapidly varying angular velocity\n    params4 = {\n        \"Omega0\": 1.0e-5,\n        \"Omega1\": 1.0e-5,\n        \"sigma\": 2.0 * np.pi / (0.5 * days),\n    }\n    X04 = np.array([20e3, 20e3])\n    t04 = 0.25 * days\n    h4 = 1800.0\n    err4 = local_truncation_error(X04, t04, h4, params4)\n    results.append(err4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Simulating the transport of tracers like heat or nutrients is a central task in computational oceanography, which can be approached from either an Eulerian or Lagrangian perspective. This exercise compares two powerful numerical methods: a grid-based semi-Lagrangian scheme and a particle-based direct Lagrangian tracking scheme. By quantifying the resulting amplitude and phase errors for each method, you will learn to critically evaluate the trade-offs between different modeling strategies in terms of numerical diffusion and accuracy .",
            "id": "3796718",
            "problem": "Consider one-dimensional periodic advection on the interval $[0,2\\pi)$ with an Eulerian scalar field $\\phi(x,t)$ governed by the linear advection equation $\\partial_t \\phi + u(t)\\,\\partial_x \\phi = 0$, where the velocity field is uniform in space and time-dependent, $u(t) = c_0 + c_1 \\sin(\\omega t)$. The initial scalar field is $\\phi(x,0) = \\cos(k x)$ for an integer wavenumber $k$. The exact characteristic displacement is $s(t) = \\int_0^t u(\\tau)\\,d\\tau$, and the exact solution is $\\phi_{\\text{exact}}(x,t) = \\cos\\!\\big(k(x - s(t))\\big)$. In the Lagrangian description, particle positions satisfy $dx/dt = u(t)$, and scalar values are invariant along trajectories.\n\nYour task is to implement and compare two numerical descriptions of advection for this known velocity field:\n\n- Semi-Lagrangian advection on an Eulerian grid: At each time step from $t^n$ to $t^{n+1}$, for each grid point $x_i$, compute a departure point $x_d$ using first-order backward Euler integration of the trajectory, $x_d = x_i - \\Delta t\\,u(t^{n+1})$, with periodic wrapping to $[0,2\\pi)$. Then obtain $\\phi^{n+1}(x_i)$ by linear interpolation of $\\phi^n$ at $x_d$ on the periodic grid. Repeat for all steps until final time $T$.\n\n- Direct Lagrangian particle tracking: Initialize particles at the Eulerian grid nodes $x_i$ carrying scalar values $\\phi_i = \\phi(x_i,0)$. Integrate particle positions forward to time $T$ using the fourth-order Runge–Kutta method applied to $dx/dt = u(t)$, with periodic wrapping to $[0,2\\pi)$. Remap the particle scalar values back to the Eulerian grid at time $T$ using a first-order Cloud-in-Cell deposition: for a particle at position $x_p$, deposit its value to the two neighboring grid nodes with linear weights proportional to the fractional distance, and then divide by the accumulated weights to obtain the Eulerian scalar field.\n\nTo quantify differences in phase and amplitude of the advected wave, estimate amplitude and phase from the Eulerian grid field $\\phi(x_i,T)$ using trigonometric projection onto the mode $\\cos(k x)$ and $\\sin(k x)$:\n$$\nc_k = \\frac{2}{N}\\sum_{i=0}^{N-1} \\phi(x_i,T)\\,\\cos(k x_i),\\quad\ns_k = \\frac{2}{N}\\sum_{i=0}^{N-1} \\phi(x_i,T)\\,\\sin(k x_i),\n$$\n$$\nA = \\sqrt{c_k^2 + s_k^2},\\quad\n\\varphi = \\operatorname{atan2}\\!\\big(-s_k,\\,c_k\\big),\n$$\nwhere $N$ is the number of grid points and $x_i = i\\,\\Delta x$ with $\\Delta x = 2\\pi/N$. The exact amplitude at time $T$ is $A_{\\text{exact}} = 1$, and the exact phase is $\\varphi_{\\text{exact}} = -k\\,s(T)$ with $s(T) = c_0 T - \\frac{c_1}{\\omega}\\big(\\cos(\\omega T) - 1\\big)$. Report the signed phase difference $\\Delta\\varphi = \\varphi_{\\text{num}} - \\varphi_{\\text{exact}}$ in radians and the amplitude difference $\\Delta A = A_{\\text{num}} - A_{\\text{exact}}$ as unitless decimals. For the phase difference, wrap to the principal value in $(-\\pi,\\pi]$ by adding or subtracting integer multiples of $2\\pi$. Angles must be expressed in radians.\n\nImplement both methods and, for each test case, compute $(\\Delta\\varphi_{\\text{SL}}, \\Delta A_{\\text{SL}}, \\Delta\\varphi_{\\text{Lag}}, \\Delta A_{\\text{Lag}})$, where the subscripts denote semi-Lagrangian (SL) versus direct Lagrangian particle tracking (Lag). Use a periodic domain of length $2\\pi$ with uniform grid. All quantities are nondimensional except phase, which must be reported in radians.\n\nTest suite:\n- Case $1$: $N=128$, $k=4$, $c_0=0.5$, $c_1=0.25$, $\\omega=1.0$, $\\Delta t=0.05$, $T=1.0$.\n- Case $2$: $N=64$, $k=8$, $c_0=1.0$, $c_1=0.5$, $\\omega=2.0$, $\\Delta t=0.2$, $T=0.8$.\n- Case $3$: $N=32$, $k=4$, $c_0=0.2$, $c_1=1.2$, $\\omega=4.0$, $\\Delta t=0.15$, $T=1.5$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order across the three cases:\n$$\n[\\Delta\\varphi_{\\text{SL}}^{(1)},\\,\\Delta A_{\\text{SL}}^{(1)},\\,\\Delta\\varphi_{\\text{Lag}}^{(1)},\\,\\Delta A_{\\text{Lag}}^{(1)},\\,\\Delta\\varphi_{\\text{SL}}^{(2)},\\,\\Delta A_{\\text{SL}}^{(2)},\\,\\Delta\\varphi_{\\text{Lag}}^{(2)},\\,\\Delta A_{\\text{Lag}}^{(2)},\\,\\Delta\\varphi_{\\text{SL}}^{(3)},\\,\\Delta A_{\\text{SL}}^{(3)},\\,\\Delta\\varphi_{\\text{Lag}}^{(3)},\\,\\Delta A_{\\text{Lag}}^{(3)}].\n$$\nAll angle outputs must be in radians and all amplitude differences must be unitless decimals. No other text should be printed.",
            "solution": "The user-provided problem is rigorously validated and confirmed to be valid. It is scientifically grounded in the principles of fluid dynamics, specifically the advection of a scalar field. The problem is well-posed, with all necessary equations, parameters, and boundary conditions explicitly defined. The language is objective and the numerical tasks are clearly specified, allowing for a unique and verifiable solution.\n\nThe core of the problem is to solve the one-dimensional linear advection equation for a scalar field $\\phi(x,t)$:\n$$\n\\partial_t \\phi + u(t)\\,\\partial_x \\phi = 0\n$$\nThe equation describes how the scalar quantity $\\phi$ is transported (advected) by a velocity field. In this case, the velocity field $u(t) = c_0 + c_1 \\sin(\\omega t)$ is spatially uniform but varies in time. The domain is periodic, $[0,2\\pi)$, and the initial condition is a cosine wave, $\\phi(x,0) = \\cos(k x)$, where $k$ is an integer wavenumber.\n\nThe exact solution is found by the method of characteristics. The characteristic curves $X(t)$ are paths that fluid parcels follow, defined by the ordinary differential equation $dX/dt = u(t)$. For a parcel starting at $x_0$ at time $t=0$, its position at time $t$ is $X(t; x_0, 0) = x_0 + \\int_0^t u(\\tau) d\\tau = x_0 + s(t)$, where $s(t)$ is the characteristic displacement. The advection equation implies that $\\phi$ is constant along these characteristics, so $\\phi(X(t), t) = \\phi(x_0, 0)$. To find the solution at a fixed point $(x, t)$, we trace back to its origin $x_0 = x - s(t)$. Thus, the exact solution is $\\phi_{\\text{exact}}(x,t) = \\cos(k(x - s(t)))$. The analytical displacement is:\n$$\ns(t) = \\int_0^t (c_0 + c_1 \\sin(\\omega \\tau)) d\\tau = c_0 t - \\frac{c_1}{\\omega}[\\cos(\\omega \\tau)]_0^t = c_0 t - \\frac{c_1}{\\omega}(\\cos(\\omega t) - 1)\n$$\nThe exact solution at time $T$ is $\\phi_{\\text{exact}}(x,T) = \\cos(kx - k s(T))$. This is a wave with amplitude $A_{\\text{exact}} = 1$ and a phase shift related to $-k s(T)$. The a problem defines a phase quantity $\\varphi$ such that the numerical estimate $\\varphi_{num}$ matches the exact value $\\varphi_{exact} = -k s(T)$. We will adhere strictly to these definitions.\n\nTwo distinct numerical approaches are implemented and compared:\n\n**1. Semi-Lagrangian (SL) Advection**\nThis method operates on a fixed Eulerian grid. For each grid point $x_i$ at the new time $t^{n+1}$, we solve for the 'departure point' $x_d$ from which a fluid parcel would have originated at the old time $t^n$ to arrive at $x_i$. The trajectory equation $dx/dt = u(t)$ is integrated backward in time over one time step, $\\Delta t$. The problem specifies a first-order backward Euler scheme:\n$$\nx_d = x_i - \\Delta t\\, u(t^{n+1})\n$$\nSince the scalar field $\\phi$ is conserved along trajectories, the new value at $x_i$ is simply the value of the field at the departure point $x_d$ at the previous time step, $\\phi^{n+1}(x_i) = \\phi^n(x_d)$. Because $x_d$ will generally not fall on a grid point, its value must be interpolated from the known values of $\\phi^n$ on the grid. The problem specifies linear interpolation. This process is repeated for a number of steps $T/\\Delta t$ to reach the final time $T$. This method is unconditionally stable with respect to the time step $\\Delta t$, but the first-order trajectory calculation and linear interpolation introduce numerical errors, primarily in the form of phase lag and amplitude damping (numerical diffusion).\n\n**2. Direct Lagrangian Particle Tracking**\nThis method discretizes the fluid into a set of particles, which are advected by the flow. We initialize $N$ particles at the $N$ Eulerian grid nodes $x_i$, with each particle $p$ carrying the corresponding initial scalar value $\\phi_p = \\phi(x_i, 0)$. The particle positions are then integrated forward in time by solving the ODE $dx_p/dt = u(t)$ from $t=0$ to $t=T$. The problem specifies the highly accurate fourth-order Runge-Kutta (RK4) method for this integration, performed over discrete time steps of size $\\Delta t$:\n$$\nx_p^{n+1} = x_p^n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4), \\quad \\text{where} \\quad k_1 = u(t^n), k_2=k_3=u(t^n+\\Delta t/2), k_4=u(t^{n+1})\n$$\nThe scalar value $\\phi_p$ on each particle remains constant throughout the integration. At the final time $T$, the particles are located at positions $x_p(T)$, which are generally not aligned with the original Eulerian grid. To recover the Eulerian field $\\phi(x,T)$, the scalar values from the scattered particles must be deposited back onto the grid. The problem specifies a first-order Cloud-in-Cell (CIC) scheme. For each particle, its scalar value is distributed to the two nearest grid nodes, weighted linearly by the fractional distance to each node. The total deposited value at each grid node is then normalized by the sum of weights it received. The RK4 integration provides a very accurate particle position (and thus, accurate phase), but the CIC deposition is a first-order spatial scheme that introduces numerical diffusion, causing amplitude loss.\n\n**Analysis of Results**\nAfter obtaining the final numerical field $\\phi_{num}(x,T)$ from each method, we quantify its amplitude and phase error. We project the numerical solution onto the basis functions $\\cos(kx)$ and $\\sin(kx)$ to find the coefficients $c_k$ and $s_k$:\n$$\nc_k = \\frac{2}{N}\\sum_{i=0}^{N-1} \\phi(x_i,T)\\,\\cos(k x_i), \\quad s_k = \\frac{2}{N}\\sum_{i=0}^{N-1} \\phi(x_i,T)\\,\\sin(k x_i)\n$$\nFrom these, the numerical amplitude $A_{num}$ and phase $\\varphi_{num}$ are calculated using the specific formulae provided:\n$$\nA_{num} = \\sqrt{c_k^2 + s_k^2}, \\quad \\varphi_{num} = \\operatorname{atan2}(-s_k, c_k)\n$$\nThe errors are the differences from the exact values: $\\Delta A = A_{num} - A_{exact}$ and $\\Delta\\varphi = \\varphi_{num} - \\varphi_{exact}$. The phase difference is wrapped to the principal interval $(-\\pi, \\pi]$.\n\nThe implementation proceeds by first defining the physical and grid parameters for each test case. Then, for each case, the Semi-Lagrangian and Direct Lagrangian simulations are run independently. Finally, the results from both methods are analyzed, and the required error metrics $(\\Delta\\varphi_{\\text{SL}}, \\Delta A_{\\text{SL}}, \\Delta\\varphi_{\\text{Lag}}, \\Delta A_{\\text{Lag}})$ are computed and stored.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n\n    def wrap_to_pi(angle):\n        \"\"\"Wraps an angle in radians to the interval (-pi, pi].\"\"\"\n        return (angle + np.pi) % (2 * np.pi) - np.pi\n\n    def solve_case(N, k, c0, c1, omega, dt, T):\n        \"\"\"\n        Solves the advection problem for a single test case using both\n        Semi-Lagrangian and Direct Lagrangian methods.\n        \"\"\"\n        # --- Setup ---\n        L = 2.0 * np.pi\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        \n        # Velocity field and exact displacement function\n        u = lambda t: c0 + c1 * np.sin(omega * t)\n        s_exact_func = lambda t: c0 * t - (c1 / omega) * (np.cos(omega * t) - 1.0)\n        \n        # Initial condition\n        phi_0 = np.cos(k * x)\n        \n        # Exact amplitude and phase at final time T\n        A_exact = 1.0\n        s_T = s_exact_func(T)\n        # The problem defines phi_exact consistently with its atan2 definition\n        phi_exact = -k * s_T\n        \n        num_steps = int(round(T / dt))\n\n        # --- Method 1: Semi-Lagrangian (SL) Advection ---\n        phi_sl = phi_0.copy()\n        for n in range(num_steps):\n            t_new = (n + 1) * dt\n            v = u(t_new)\n            \n            # Calculate departure points using first-order backward Euler\n            x_d = x - v * dt\n            \n            # Apply periodic boundary conditions\n            x_d = x_d % L\n            \n            # Perform linear interpolation on the periodic grid\n            alpha = x_d / dx\n            idx_floor = np.floor(alpha).astype(int)\n            frac = alpha - idx_floor\n            \n            idx_ceil = (idx_floor + 1) % N\n            \n            phi_new = (1.0 - frac) * phi_sl[idx_floor] + frac * phi_sl[idx_ceil]\n            phi_sl = phi_new\n\n        # --- Method 2: Direct Lagrangian Particle Tracking ---\n        x_p = x.copy()\n        phi_p = phi_0.copy()\n        \n        # Integrate particle positions forward using RK4\n        for n in range(num_steps):\n            t_n = n * dt\n            k1 = u(t_n)\n            k2 = u(t_n + 0.5 * dt)\n            k3 = k2  # For ODEs of the form dx/dt = f(t)\n            k4 = u(t_n + dt)\n            x_p += (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n            \n        x_p_final = x_p % L\n        \n        # Deposit particle values back to grid using Cloud-in-Cell (CIC)\n        phi_lag_grid = np.zeros(N, dtype=np.float64)\n        weight_grid = np.zeros(N, dtype=np.float64)\n        \n        for p_idx in range(N):\n            xp = x_p_final[p_idx]\n            phip = phi_p[p_idx]\n            \n            alpha = xp / dx\n            i_low = int(alpha)\n            w_high = alpha - i_low\n            w_low = 1.0 - w_high\n            \n            i_high = (i_low + 1) % N\n            \n            phi_lag_grid[i_low] += w_low * phip\n            weight_grid[i_low] += w_low\n            \n            phi_lag_grid[i_high] += w_high * phip\n            weight_grid[i_high] += w_high\n        \n        # Normalize the grid field by accumulated weights\n        phi_lag = np.divide(phi_lag_grid, weight_grid, \n                              out=np.zeros_like(phi_lag_grid), \n                              where=weight_grid  1e-15)\n\n        # --- Analysis of Final Fields ---\n        def analyze_field(phi_final, k_wavenum, x_grid, N_grid):\n            \"\"\"Calculates amplitude and phase from a field.\"\"\"\n            cos_kx = np.cos(k_wavenum * x_grid)\n            sin_kx = np.sin(k_wavenum * x_grid)\n            \n            c_k = (2.0 / N_grid) * np.sum(phi_final * cos_kx)\n            s_k = (2.0 / N_grid) * np.sum(phi_final * sin_kx)\n            \n            A_num = np.sqrt(c_k**2 + s_k**2)\n            phi_num = np.arctan2(-s_k, c_k)\n            \n            return A_num, phi_num\n\n        A_sl, phi_num_sl = analyze_field(phi_sl, k, x, N)\n        A_lag, phi_num_lag = analyze_field(phi_lag, k, x, N)\n        \n        # --- Compute final error metrics ---\n        dA_sl = A_sl - A_exact\n        dA_lag = A_lag - A_exact\n        \n        dphi_sl = wrap_to_pi(phi_num_sl - phi_exact)\n        dphi_lag = wrap_to_pi(phi_num_lag - phi_exact)\n        \n        return dphi_sl, dA_sl, dphi_lag, dA_lag\n\n    test_cases = [\n        # (N, k, c0, c1, omega, dt, T)\n        (128, 4, 0.5, 0.25, 1.0, 0.05, 1.0),\n        (64, 8, 1.0, 0.5, 2.0, 0.2, 0.8),\n        (32, 4, 0.2, 1.2, 4.0, 0.15, 1.5),\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        result_tuple = solve_case(*case_params)\n        all_results.extend(result_tuple)\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}