{
    "hands_on_practices": [
        {
            "introduction": "元动力学通过在集合变量（CV）空间中添加偏置势来增强采样。然而，这个抽象的偏置势最终必须转化为施加在系统中每个原子上的具体作用力。这个练习将引导您完成一个基础但至关重要的推导，通过应用多元微积分中的链式法则，揭示偏置势的梯度如何转化为原子坐标上的力，从而加深您对元动力学方法力学基础的理解 ()。",
            "id": "3852294",
            "problem": "考虑一个生物分子系统中的一对原子，其索引分别为 $i$ 和 $j$，笛卡尔位置向量为 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$。在元动力学中，集体变量 (Collective Variable, CV) 是系统状态的一种低维描述符；此处，该CV为原子间距离 $s = |\\mathbf{r}_i - \\mathbf{r}_j|$。元动力学偏置势 $V_{\\mathrm{b}}(s,t)$ 是由 $M$ 个高斯山（每个高斯山在较早的时刻沉积，中心位于 $s_n$，高度为 $w_n$，宽度为 $\\sigma_n$）的总和构建而成，即：\n$$\nV_{\\mathrm{b}}(s,t) = \\sum_{n=1}^{M} w_n \\exp\\!\\left( - \\frac{(s - s_n)^{2}}{2 \\sigma_n^{2}} \\right).\n$$\n从经典力学中力的定义（对于势能 $U$，有 $\\mathbf{F} = - \\nabla_{\\mathbf{r}} U$）、CV $s$ 关于原子位置的定义以及多元微积分中的链式法则出发，推导梯度 $\\frac{\\partial s}{\\partial \\mathbf{r}_i}$，然后用它来获得作用在原子 $i$ 上的偏置力向量 $\\mathbf{F}_{i}^{(\\mathrm{b})}(t)$ 的显式表达式，该表达式用 $\\mathbf{r}_i$、$\\mathbf{r}_j$、$s$ 和高斯参数 $\\{w_n, s_n, \\sigma_n\\}_{n=1}^{M}$ 表示。只需提供符号表达式；如果进行数值计算，力应以千焦耳每摩尔每纳米 (kJ mol$^{-1}$ nm$^{-1}$) 为单位表示。最终答案必须是单一的闭式解析表达式。",
            "solution": "基本依据包括：(i) 经典力学中力的定义，即 $\\mathbf{F} = - \\nabla_{\\mathbf{r}} U$，其中 $U$ 是作为坐标函数的势能；(ii) 集体变量的定义 $s = |\\mathbf{r}_i - \\mathbf{r}_j|$；以及 (iii) 多元微积分中的微分链式法则，它通过中间变量连接导数。\n\n首先，我们推导 $\\frac{\\partial s}{\\partial \\mathbf{r}_i}$。将距离用点积表示：\n$$\ns = |\\mathbf{r}_i - \\mathbf{r}_j| = \\sqrt{ (\\mathbf{r}_i - \\mathbf{r}_j) \\cdot (\\mathbf{r}_i - \\mathbf{r}_j) }.\n$$\n定义 $\\mathbf{d} \\equiv \\mathbf{r}_i - \\mathbf{r}_j$。那么 $s = \\sqrt{\\mathbf{d} \\cdot \\mathbf{d}}$。对于 $\\mathbf{d} \\neq \\mathbf{0}$，使用链式法则和梯度性质，对 $s$ 关于 $\\mathbf{r}_i$ 求导：\n$$\n\\frac{\\partial s}{\\partial \\mathbf{r}_i} = \\frac{\\partial}{\\partial \\mathbf{r}_i} \\left( (\\mathbf{d} \\cdot \\mathbf{d})^{1/2} \\right) = \\frac{1}{2} (\\mathbf{d} \\cdot \\mathbf{d})^{-1/2} \\cdot 2 \\mathbf{d} = \\frac{\\mathbf{d}}{|\\mathbf{d}|} = \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{|\\mathbf{r}_i - \\mathbf{r}_j|}.\n$$\n注意，由于绝对值奇点，该梯度在 $\\mathbf{r}_i = \\mathbf{r}_j$（即 $s = 0$）处无定义，但在分子模拟中，原子不会占据完全相同的位置，因此通常不需要正则化。\n\n其次，我们求原子 $i$ 上的偏置力。偏置势仅依赖于 $s$，而 $s$ 又依赖于原子坐标。因此，由偏置势产生的施加在原子 $i$ 上的力由下式给出：\n$$\n\\mathbf{F}_{i}^{(\\mathrm{b})}(t) = - \\frac{\\partial V_{\\mathrm{b}}(s,t)}{\\partial \\mathbf{r}_i} = - \\frac{\\mathrm{d} V_{\\mathrm{b}}(s,t)}{\\mathrm{d} s} \\cdot \\frac{\\partial s}{\\partial \\mathbf{r}_i},\n$$\n这里我们使用了链式法则，将导数分解为关于标量参数 $s$ 的导数和 $s$ 关于 $\\mathbf{r}_i$ 的梯度的乘积。\n\n现在我们计算 $\\frac{\\mathrm{d} V_{\\mathrm{b}}(s,t)}{\\mathrm{d} s}$。对于给定的高斯山之和，\n$$\nV_{\\mathrm{b}}(s,t) = \\sum_{n=1}^{M} w_n \\exp\\!\\left( - \\frac{(s - s_n)^{2}}{2 \\sigma_n^{2}} \\right),\n$$\n关于 $s$ 的导数是各项导数的和：\n$$\n\\frac{\\mathrm{d} V_{\\mathrm{b}}(s,t)}{\\mathrm{d} s} = \\sum_{n=1}^{M} w_n \\exp\\!\\left( - \\frac{(s - s_n)^{2}}{2 \\sigma_n^{2}} \\right) \\cdot \\frac{\\mathrm{d}}{\\mathrm{d} s} \\left( - \\frac{(s - s_n)^{2}}{2 \\sigma_n^{2}} \\right).\n$$\n计算内部的导数：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d} s} \\left( - \\frac{(s - s_n)^{2}}{2 \\sigma_n^{2}} \\right) = - \\frac{1}{\\sigma_n^{2}} (s - s_n).\n$$\n因此，\n$$\n\\frac{\\mathrm{d} V_{\\mathrm{b}}(s,t)}{\\mathrm{d} s} = - \\sum_{n=1}^{M} w_n \\exp\\!\\left( - \\frac{(s - s_n)^{2}}{2 \\sigma_n^{2}} \\right) \\frac{s - s_n}{\\sigma_n^{2}}.\n$$\n将此结果与 $\\frac{\\partial s}{\\partial \\mathbf{r}_i} = \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{|\\mathbf{r}_i - \\mathbf{r}_j|}$ 结合，得到\n$$\n\\mathbf{F}_{i}^{(\\mathrm{b})}(t) = - \\left( - \\sum_{n=1}^{M} w_n \\exp\\!\\left( - \\frac{(s - s_n)^{2}}{2 \\sigma_n^{2}} \\right) \\frac{s - s_n}{\\sigma_n^{2}} \\right) \\cdot \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{|\\mathbf{r}_i - \\mathbf{r}_j|}.\n$$\n因此，作用在原子 $i$ 上的偏置力为\n$$\n\\mathbf{F}_{i}^{(\\mathrm{b})}(t) = \\left( \\sum_{n=1}^{M} w_n \\exp\\!\\left( - \\frac{(s - s_n)^{2}}{2 \\sigma_n^{2}} \\right) \\frac{s - s_n}{\\sigma_n^{2}} \\right) \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{|\\mathbf{r}_i - \\mathbf{r}_j|},\n$$\n其中 $s = |\\mathbf{r}_i - \\mathbf{r}_j|$。该表达式是一个与基本定义和链式法则一致的符号向量结果，如果进行数值计算，力将以千焦耳每摩尔每纳米 (kJ mol$^{-1}$ nm$^{-1}$) 为单位报告。",
            "answer": "$$\\boxed{\\left( \\sum_{n=1}^{M} w_n \\exp\\!\\left( - \\frac{(s - s_n)^{2}}{2 \\sigma_n^{2}} \\right) \\frac{s - s_n}{\\sigma_n^{2}} \\right) \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{|\\mathbf{r}_i - \\mathbf{r}_j|}}$$"
        },
        {
            "introduction": "在增强采样模拟中，一个常见的情景是得到一个看似完美的自由能曲线，但其结果却与后续的验证性模拟相矛盾。这个练习以一个思想实验的形式呈现了这样一个难题：从元动力学重构的自由能面上一个很深的能量阱出发，一个无偏置的模拟却显示系统迅速逃离了该状态。通过分析这一矛盾，您将学会如何诊断一个不充分的集合变量，并理解为何选择能够捕捉所有相关慢自由度的CV是至关重要的 ()。",
            "id": "2455465",
            "problem": "一名学生使用元动力学（metadynamics）来探索一个分子系统的自由能面（FES）。他们选择了一个单一的集体变量（CV）$s(\\mathbf{x})$，在元动力学运行期间添加了一个依赖于历史的偏置势 $V_{\\mathrm{bias}}(s,t)$，并在足够长的时间后根据该偏置势重构了自由能分布 $F(s)$。在重构的 $F(s)$ 中，学生在 $s=s^{\\ast}$ 处发现了一个看似很深的极小值。然后，他们从元动力学轨迹中提取了一个构象 $\\mathbf{x}^{\\ast}$，其满足 $s(\\mathbf{x}^{\\ast}) \\approx s^{\\ast}$，并在相同的温度 $T$ 和使用相同的哈密顿量（无偏置势，恒温器和积分器设置完全相同）的情况下，进行了一次无偏置的分子动力学（MD）模拟。在这次数无偏置MD模拟中，系统迅速离开了 $s^{\\ast}$ 附近，并跃迁到另一个状态，在模拟的时间尺度内没有返回。\n\n假设热力学定义为 $F(s)=-k_{\\mathrm{B}}T\\ln P(s)+C$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$P(s)$ 是CV的平衡概率密度，$C$ 是一个无关常数。同时回想一下，沿着一个真正相关的反应坐标 $q$，跃迁速率 $k$ 通常按 $k\\propto \\exp(-\\beta \\Delta F^{\\ddagger})$ 的规律缩放，其中 $\\beta=1/(k_{\\mathrm{B}}T)$，$\\Delta F^{\\ddagger}$ 是沿 $q$ 的自由能垒。\n\n根据学生对元动力学运行的观察，以下哪项是最合理的推论？\n\nA. $F(s)$ 中的深极小值必然意味着一个大的离开势垒，因此在无偏置MD中的快速逃离必定是由于数值积分误差；否则，元动力学的自由能是正确的。\n\nB. 所选的CV $s(\\mathbf{x})$ 不足以参数化慢动力学过程；$F(s)$ 中明显的深极小值是投影到 $s$ 上的伪影，而位于 $s^{\\ast}$ 处的构象沿着未被 $s$ 捕捉到的正交自由度是不稳定的。\n\nC. 这种差异是因为无偏置MD的温度 $T$ 与元动力学中使用的温度不同；因此无法对元动力学的质量做出任何推断。\n\nD. 元动力学中的高斯山太小了，所以 $s^{\\ast}$ 处的极小值实际上更深；在无偏置MD中的快速逃离是一次罕见的涨落，这支持了元动力学运行的收敛性。",
            "solution": "必须首先验证问题陈述的科学性和逻辑完整性。\n\n### 第1步：提取已知信息\n- 对一个分子系统使用单一集体变量（CV）$s(\\mathbf{x})$ 进行了一次元动力学模拟。\n- 在模拟过程中添加了一个依赖于历史的偏置势 $V_{\\mathrm{bias}}(s,t)$。\n- 根据该偏置势重构了一个自由能分布 $F(s)$。\n- 这个重构的 $F(s)$ 在 $s=s^{\\ast}$ 处有一个深的极小值。\n- 从元动力学轨迹中提取了一个构象 $\\mathbf{x}^{\\ast}$，其中 $s(\\mathbf{x}^{\\ast}) \\approx s^{\\ast}$。\n- 从 $\\mathbf{x}^{\\ast}$ 开始，在相同的条件下（温度 $T$、哈密顿量、恒温器、积分器）进行了一次无偏置的分子动力学（MD）模拟。\n- 在无偏置MD中，系统迅速离开了 $s^{\\ast}$ 附近的区域并且没有返回。\n- 自由能分布的热力学定义为 $F(s)=-k_{\\mathrm{B}}T\\ln P(s)+C$。\n- 沿相关反应坐标的跃迁速率 $k$ 的缩放关系为 $k\\propto \\exp(-\\beta \\Delta F^{\\ddagger})$，其中 $\\beta=1/(k_{\\mathrm{B}}T)$。\n\n### 第2步：使用提取的已知信息进行验证\n该问题描述了在计算研究中使用增强采样技术（如元动力学）时常见且现实的一种情况。\n\n- **科学上合理：** 所提出的概念——元动力学、集体变量、自由能面、无偏置MD和跃迁速率——在计算化学和统计力学中是标准和基础的。所描述的情景不仅是合理的，而且是应用此类方法时一个主要陷阱的教科书式例子。各项原理陈述正确。\n- **问题定义明确：** 该问题被构建为一个思想实验或对计算结果的解释。它要求在一组选项中选出最合理的推论，这需要基于所提供的信息进行推理。可以得出一个逻辑结论。\n- **客观性：** 语言是技术性和客观的。对模拟结果的描述（“深的极小值”、“迅速离开”）在分子模拟的语境下，其物理意义是清晰的。\n\n### 第3步：结论和行动\n问题陈述是有效的。它在科学上是合理的，问题定义明确，并且是客观的。它提出了一个关于解释元动力学结果的标准问题。我将继续进行全面的分析和解答。\n\n***\n\n问题的核心在于两次模拟结果之间的表面矛盾：\n1.  **元动力学：** 重构的自由能面 $F(s)$ 在 $s = s^{\\ast}$ 处显示一个深的极小值。根据关系式 $F(s) = -k_{\\mathrm{B}}T\\ln P(s) + C$，自由能的深极小值对应于一个高的平衡概率密度 $P(s^{\\ast})$。这表明对应于 $s=s^{\\ast}$ 的状态是热力学稳定的。此外，如果 $s$ 是真正的反应坐标，一个深阱将意味着有高势垒将其与其他状态分开，从而导致 $s^{\\ast}$ 处状态的寿命很长。\n2.  **无偏置MD：** 从构象 $\\mathbf{x}^{\\ast}$（其中 $s(\\mathbf{x}^{\\ast}) \\approx s^{\\ast}$）开始的模拟显示系统在动力学上是不稳定的。它“迅速离开” $s^{\\ast}$ 附近，表明该状态的寿命很短。这与从 $F(s)$ 推断出的稳定性结论相矛盾。\n\n任务是找出造成这种差异的最合理解释。\n\n### 逐项分析\n\n**A. $F(s)$ 中的深极小值必然意味着一个大的离开势垒，因此在无偏置MD中的快速逃离必定是由于数值积分误差；否则，元动力学的自由能是正确的。**\n\n这种说法是有缺陷的。自由能分布 $F(s)$ 是全维势能面在一位坐标 $s$ 上的投影。$F(s)$ 中的深极小值仅意味着*沿着坐标 $s$* 有一个大的离开势垒。它没有提供关于系统相对于与 $s$ 正交的自由度方向上运动的稳定性的任何信息。构象 $\\mathbf{x}^{\\ast}$ 可能相对于 $s$ 位于一个深阱中，但同时相对于其他未被 $s$ 捕捉到的“隐藏”坐标位于一个极大值或陡峭的下坡上。在无偏置模拟中观察到快速逃离，该模拟在全维空间中传播系统，这是动力学不稳定的强有力的物理证据。在没有任何依据的情况下将其归因于“数值积分误差”是不严谨的科学推理。无偏置MD的结果是使对 $F(s)$ 的朴素解释失效的关键数据，它不是一个错误。\n\n结论：**不正确**。\n\n**B. 所选的CV $s(\\mathbf{x})$ 不足以参数化慢动力学过程；$F(s)$ 中明显的深极小值是投影到 $s$ 上的伪影，而位于 $s^{\\ast}$ 处的构象沿着未被 $s$ 捕捉到的正交自由度是不稳定的。**\n\n这是最准确和最根本的解释。自由能 $F(s)$ 是通过对所有与给定 $s$ 值兼容的自由度 $\\mathbf{x}$ 进行积分得到的：\n$$ P(s) = \\int d\\mathbf{x} \\, \\delta(s(\\mathbf{x}) - s) P(\\mathbf{x}) \\propto \\int d\\mathbf{x} \\, \\delta(s(\\mathbf{x}) - s) e^{-\\beta U(\\mathbf{x})} $$\n较低的 $F(s)$ 值意味着具有 $s(\\mathbf{x})=s$ 的构象系综具有较高的总统计权重。然而，这个系综可能包含高能量（不稳定构象）和低能量（稳定构象）的子区域。如果元动力学模拟将系统推入一个恰好投影到 $s=s^{\\ast}$ 的高能区域，由于熵效应或对同样在 $s=s^{\\ast}$ 处采样的其他更稳定区域的平均，重构的 $F(s)$ 仍可能在此处显示一个极小值。当从这个高能区域提取一个特定构象 $\\mathbf{x}^{\\ast}$ 并用它来开始无偏置MD时，系统自然会沿着与 $s$ 正交的不稳定自由度迅速向“下坡”演化。这是选择不佳的集体变量的典型症状，该变量未能捕捉到系统中所有相关的慢运动。在一维投影中表现出的稳定性是一种伪影。\n\n结论：**正确**。\n\n**C. 这种差异是因为无偏置MD的温度 $T$ 与元动力学中使用的温度不同；因此无法对元动力学的质量做出任何推断。**\n\n问题陈述明确指出，无偏置MD是在“**相同的温度T**下”并使用“**相同的哈密顿量**”运行的。该选项引入了一个与给定信息直接矛盾的前提。因此，它不可能是正确的解释。\n\n结论：**不正确**。\n\n**D. 元动力学中的高斯山太小了，所以 $s^{\\ast}$ 处的极小值实际上更深；在无偏置MD中的快速逃离是一次罕见的涨落，这支持了元动力学运行的收敛性。**\n\n这种说法包含多个逻辑错误。首先，高斯山的大小影响收敛速率并可能引入误差，但它没有一个简单的直接关系，即小山能保证真实极小值更深。未完全填充的势阱可能看起来被人为地加深了。其次，也是更关键的一点，一次“迅速”的逃离，根据定义，不是一次“罕见的涨落”。一个稀有事件，比如越过一个高能垒，只会在长时间模拟后才被观察到。一个快速事件意味着势垒很低或不存在，表明动力学不稳定。因此，快速逃离直接反驳了系统处于一个稳定、深的极小值中的观点，从而从根本上挑战了使用该CV的元动力学运行的收敛性和效用。\n\n结论：**不正确**。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "选择一个好的反应坐标是元动力学模拟成功的关键，但我们如何定量地验证一个CV的质量呢？这个高级练习介绍了反应坐标验证的“黄金标准”：承诺子（committor）分析。您将通过一个计算实践来检验一个路径CV是否能准确描述从反应物到产物的转变过程。这个练习要求您实施一个统计检验程序 ()，通过分析过渡区域的承诺子概率分布，来评估CV是否真正捕捉到了反应的本质。",
            "id": "3852371",
            "problem": "给定任务为评估在超动力学中使用的路径集合变量 $s_{\\text{path}}$ 是否为从反应物盆地 $\\mathcal{A}$ 到产物盆地 $\\mathcal{B}$ 的生物分子转变提供了一个充分的反应坐标。该评估必须通过分析在过渡区域中固定 $s_{\\text{path}}$ 时的 committor 概率分布来完成。对于一个构型 $x$，其 committor 概率 $p_{\\mathcal{B}}$ 定义为：在底层的随机动力学或具有随机化动量的确定性动力学下，从 $x$ 开始的轨迹在到达 $\\mathcal{A}$ 之前先到达 $\\mathcal{B}$ 的概率。您必须测试在过渡区域中 $p_{\\mathcal{B}} \\approx 0.5$ 附近的局部邻域内的近似均匀性，以检查 $s_{\\text{path}}$ 是否没有伪偏差，具体过程和标准定义如下。\n\n基本定义：\n- committor 概率 $p_{\\mathcal{B}}(x)$ 是从 $x$ 开始，在到达 $\\mathcal{A}$ 之前先到达 $\\mathcal{B}$ 的首次到达概率，满足 $p_{\\mathcal{B}}(x) \\in [0,1]$。\n- 集合变量 (CV) $s_{\\text{path}}$ 是一个从构型空间 $\\Omega$ 到一个进程参数的标量映射 $s_{\\text{path}}: \\Omega \\rightarrow \\mathbb{R}$，该进程参数沿连接 $\\mathcal{A}$ 和 $\\mathcal{B}$ 的预定义路径。\n- 在对应于 $s_{\\text{path}}$ 中假定的分割面的过渡区域，一个理论上充分的反应坐标应确保 $p_{\\mathcal{B}} \\approx 0.5$ 且无系统性偏斜。我们通过在 $0.5$ 附近的一个小窗口内测试 $p_{\\mathcal{B}}$ 直方图的局部均匀性，并检查其均值与 $0.5$ 的接近程度，来将此概念操作化。\n\n算法规格：\n- 对于在过渡区域中固定 $s_{\\text{path}}$ 收集的一组 committor 样本 $\\{p_i\\}_{i=1}^n$，定义一个窗口 $[w_\\ell,w_u]$，旨在捕获 $p_{\\mathcal{B}} \\approx 0.5$ 的局部邻域。仅分析满足 $w_\\ell \\le p_i \\le w_u$ 的样本。\n- 将 $[w_\\ell,w_u]$ 分割成 $k$ 个等宽的区间（bin），并计算每个区间中的观测计数 $\\{O_j\\}_{j=1}^k$。\n- 在局部均匀性的原假设下，期望计数为 $E_j = n_w/k$，其中 $n_w$ 是窗口内的样本数。\n- 计算皮尔逊卡方统计量\n$$\n\\chi^2 = \\sum_{j=1}^k \\frac{(O_j - E_j)^2}{E_j}\n$$\n并从具有 $k-1$ 自由度的卡方分布中计算出相应的 $p$-值。如果 $p$-值大于或等于显著性水平 $\\alpha$，则不拒绝均匀性假设。\n- 计算窗口内的样本均值，\n$$\n\\bar{p} = \\frac{1}{n_w}\\sum_{i=1}^{n_w} p_i,\n$$\n并检查均值邻近性准则 $\\lvert \\bar{p} - 0.5\\rvert \\le \\varepsilon$。\n\n决策规则：\n- 当且仅当以下两个条件同时成立时，基于 $s_{\\text{path}}$ 的反应坐标才通过给定样本集的验证：卡方检验在显著性水平 $\\alpha$ 下不拒绝 $[w_\\ell,w_u]$ 内的局部均匀性，并且满足均值邻近性准则 $\\lvert \\bar{p} - 0.5\\rvert \\le \\varepsilon$。\n\n您的程序必须为以下测试套件实现上述过程。对于每个测试用例，按规定确定性地生成 $\\{p_i\\}_{i=1}^n$。使用无角度、无单位的数作为无量纲概率 $p_i \\in [0,1]$。不允许外部输入。参数如下：\n\n- 测试用例 1（理想情况，局部均匀且均值接近 0.5）：\n    - $n = 100$, $[w_\\ell,w_u] = [0.4, 0.6]$, $k = 10$, $\\alpha = 0.05$, $\\varepsilon = 0.02$。\n    - 定义区间宽度 $\\Delta = (w_u - w_\\ell)/k$ 和区间中心 $c_j = w_\\ell + (j + 0.5)\\Delta$，其中 $j \\in \\{0,\\dots,k-1\\}$。\n    - 通过将每个中心 $c_j$ 重复 $m = 10$ 次来构造 $\\{p_i\\}$，使得 $n = k \\times m$ 且每个区间包含 $m$ 个样本。\n\n- 测试用例 2（在 0.5 附近有窄峰，违反局部均匀性但均值接近 0.5）：\n    - $n = 100$, $[w_\\ell,w_u] = [0.4, 0.6]$, $k = 10$, $\\alpha = 0.05$, $\\varepsilon = 0.02$。\n    - 定义 $p_i = 0.5 + 0.01 \\cos\\!\\left(\\frac{2\\pi i}{n}\\right)$，其中 $i \\in \\{0,\\dots,n-1\\}$。\n\n- 测试用例 3（分布偏斜，均值偏离 0.5）：\n    - $n = 100$, $[w_\\ell,w_u] = [0.4, 0.6]$, $k = 10$, $\\alpha = 0.05$, $\\varepsilon = 0.02$。\n    - 定义 $p_i = w_\\ell + \\left(\\frac{i}{n-1}\\right)^2 (w_u - w_\\ell)$，其中 $i \\in \\{0,\\dots,n-1\\}$。\n\n- 测试用例 4（边界条件，样本量小，构造上局部均匀）：\n    - $n = 20$, $[w_\\ell,w_u] = [0.4, 0.6]$, $k = 5$, $\\alpha = 0.05$, $\\varepsilon = 0.02$。\n    - 定义区间宽度 $\\Delta = (w_u - w_\\ell)/k$ 和区间中心 $c_j = w_\\ell + (j + 0.5)\\Delta$，其中 $j \\in \\{0,\\dots,k-1\\}$。\n    - 通过将每个中心 $c_j$ 重复 $m = 4$ 次来构造 $\\{p_i\\}$，使得 $n = k \\times m$ 且每个区间包含 $m$ 个样本。\n\n输出格式：\n- 对于每个测试用例，输出一个布尔值，指示 $s_{\\text{path}}$ 是否根据上述决策规则通过验证。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $\\texttt{[result1,result2,result3,result4]}$，其中每个 $\\texttt{result}$ 为 $\\texttt{True}$ 或 $\\texttt{False}$。\n\n所有计算必须完全按照规定执行，不得有随机性。最终输出必须是确定性的。",
            "solution": "问题陈述已经过评估并被确定为有效。它在科学上基于计算化学生物学的原理，特别是在使用 committor 概率验证反应坐标方面。该问题定义明确，所有参数、数据生成过程和评估标准都已明确规定，确保了唯一且确定性的解。它没有矛盾、模糊之处和事实错误。\n\n核心任务是开发一个计算程序，以评估路径集合变量 $s_{\\text{path}}$ 是否可作为两个状态 $\\mathcal{A}$ 和 $\\mathcal{B}$ 之间转变的充分反应坐标。此评估的理论基础在于 committor 概率分析。committor 概率 $p_{\\mathcal{B}}(x)$ 定义为从系统状态空间中的一个构型 $x$ 开始的轨迹在到达反应物盆地 $\\mathcal{A}$ 之前先到达产物盆地 $\\mathcal{B}$ 的概率。根据定义，committor $p_{\\mathcal{B}}$ 是理想的反应坐标。$p_{\\mathcal{B}}(x) = 0$ 的值表示构型 $x$ 处于盆地 $\\mathcal{A}$ 中，$p_{\\mathcal{B}}(x) = 1$ 表示它处于盆地 $\\mathcal{B}$ 中，而 $p_{\\mathcal{B}}(x) = 0.5$ 定义了过渡态表面，这是一个完美分隔反应物与产物的分割面。\n\n一个良好但近似的集合变量 $s_{\\text{path}}$ 应与真实的 committor $p_{\\mathcal{B}}$ 单调相关。因此，在过渡区域中，$s_{\\text{path}}$ 的一个等值面应近似于 $p_{\\mathcal{B}} \\approx 0.5$ 的真实过渡态表面。该问题要求对在与假定过渡区域对应的固定 $s_{\\text{path}}$ 值处收集的一组 committor 样本 $\\{p_i\\}_{i=1}^n$ 进行两部分测试。\n\n验证程序如下：\n\n1.  **数据过滤**：从初始样本集 $\\{p_i\\}_{i=1}^n$ 中，我们只考虑落在以 $0.5$ 为中心的指定窗口 $[w_\\ell, w_u]$ 内的 $n_w$ 个样本子集。这使分析集中于过渡态的局部行为。\n\n2.  **均匀性检验**：第一个标准评估 committor 概率在此窗口内是否均匀分布。非均匀分布，例如在 $p_{\\mathcal{B}}=0.5$ 处呈尖锐峰值的分布，将表明 $s_{\\text{path}}$ 与其他同样影响 committor 的未观测自由度相关。这意味着仅凭 $s_{\\text{path}}$ 不足以描述该转变。我们采用皮尔逊卡方 ($\\chi^2$) 拟合优度检验。\n    - 将窗口 $[w_\\ell, w_u]$ 划分为 $k$ 个等宽的区间。\n    - 对每个区间 $j \\in \\{1, \\dots, k\\}$，计算观测到的样本数 $O_j$。\n    - 在均匀分布的原假设 $H_0$ 下，每个区间的期望计数为 $E_j = n_w/k$。\n    - 卡方统计量的计算公式为：\n    $$\n    \\chi^2 = \\sum_{j=1}^k \\frac{(O_j - E_j)^2}{E_j}\n    $$\n    - 将此统计量与具有 $\\nu = k-1$ 自由度的 $\\chi^2$ 分布进行比较以获得 $p$-值。小于所选显著性水平 $\\alpha$ 的 $p$-值将导致拒绝 $H_0$。验证条件为 $p\\text{-值} \\ge \\alpha$。值得注意的是，$\\chi^2$ 检验的有效性通常取决于期望计数 $E_j$ 不太小（例如，$E_j \\ge 5$）的条件。尽管这可能不适用于所有测试用例，但问题要求无论如何都要执行该检验，我们将遵从这一要求。\n\n3.  **均值邻近性检验**：第二个标准确保在所测试的表面上，committor 的平均值确实接近理想过渡态值 $0.5$。显著的偏差将表明存在系统性偏差，意味着所选的 $s_{\\text{path}}$ 值与真正的 $50/50$ 分割面不对应。\n    -   计算窗口内数据的样本均值 $\\bar{p}$：\n    $$\n    \\bar{p} = \\frac{1}{n_w}\\sum_{i=1}^{n_w} p_i\n    $$\n    -   此均值必须满足邻近性准则 $|\\bar{p} - 0.5| \\le \\varepsilon$，其中 $\\varepsilon$ 是给定的容差。\n\n4.  **决策**：当且仅当均匀性检验和均值邻近性检验都通过时，集合变量 $s_{\\text{path}}$ 才被视为通过了给定样本集的验证。\n\n这个组合程序为评估所提出的反应坐标的质量提供了一个严谨的定量框架，并将针对四个指定的测试用例进行实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef validate_rc(p_samples, wl, wu, k, alpha, epsilon):\n    \"\"\"\n    Assesses a reaction coordinate based on a set of committor samples.\n\n    This function performs a two-part test: a chi-square test for local\n    uniformity of committor probabilities and a check for mean proximity to 0.5.\n\n    Args:\n        p_samples (np.ndarray): The array of committor probability samples.\n        wl (float): The lower bound of the analysis window.\n        wu (float): The upper bound of the analysis window.\n        k (int): The number of bins for the uniformity test.\n        alpha (float): The significance level for the chi-square test.\n        epsilon (float): The tolerance for the mean proximity test.\n\n    Returns:\n        bool: True if the reaction coordinate passes validation, False otherwise.\n    \"\"\"\n    # Step 1: Filter samples to lie within the window [wl, wu].\n    p_in_window = p_samples[(p_samples >= wl) & (p_samples <= wu)]\n    n_w = len(p_in_window)\n\n    # If no samples are in the window, the tests cannot be performed.\n    # The problem specification guarantees n_w > 0 for all test cases.\n    if n_w == 0:\n        return False\n\n    # Condition 1: Chi-square test for local uniformity.\n    uniformity_passes = False\n    \n    # The chi-square test is not well-defined for k = 1. The problem uses k > 1.\n    if k > 1:\n        # Bin the data within the window. `np.histogram` handles edges appropriately\n        # for this problem, including the right aclosed last bin.\n        bin_edges = np.linspace(wl, wu, k + 1)\n        observed_counts, _ = np.histogram(p_in_window, bins=bin_edges)\n        \n        # Calculate expected counts under the null hypothesis of uniformity.\n        expected_counts = n_w / k\n\n        # The chi-square test is ill-defined if expected_counts is zero.\n        # This only happens if n_w is zero, which is handled above.\n        if expected_counts > 0:\n            chi_sq_statistic = np.sum((observed_counts - expected_counts)**2 / expected_counts)\n            \n            # Degrees of freedom for the chi-square distribution.\n            df = k - 1\n            \n            # The p-value is the probability of observing a test statistic at least\n            # as extreme as the one computed, assuming the null hypothesis is true.\n            # We use the survival function (1 - CDF) for this right-tailed test.\n            p_value = chi2.sf(chi_sq_statistic, df)\n            \n            if p_value >= alpha:\n                uniformity_passes = True\n\n    # Condition 2: Mean proximity to 0.5.\n    mean_p = np.mean(p_in_window)\n    mean_proximity_passes = np.abs(mean_p - 0.5) <= epsilon\n\n    # Final decision: both conditions must be met.\n    return uniformity_passes and mean_proximity_passes\n\ndef solve():\n    \"\"\"\n    Generates data for the four test cases as specified in the problem\n    and runs the validation procedure for each.\n    \"\"\"\n    test_cases_params = [\n        {'n': 100, 'wl': 0.4, 'wu': 0.6, 'k': 10, 'alpha': 0.05, 'epsilon': 0.02, 'id': 1},\n        {'n': 100, 'wl': 0.4, 'wu': 0.6, 'k': 10, 'alpha': 0.05, 'epsilon': 0.02, 'id': 2},\n        {'n': 100, 'wl': 0.4, 'wu': 0.6, 'k': 10, 'alpha': 0.05, 'epsilon': 0.02, 'id': 3},\n        {'n': 20, 'wl': 0.4, 'wu': 0.6, 'k': 5, 'alpha': 0.05, 'epsilon': 0.02, 'id': 4},\n    ]\n    \n    results = []\n    \n    for params in test_cases_params:\n        n, wl, wu, k = params['n'], params['wl'], params['wu'], params['k']\n        \n        p_samples = np.array([])\n        if params['id'] == 1:\n            m = 10\n            delta = (wu - wl) / k\n            centers = wl + (np.arange(k) + 0.5) * delta\n            p_samples = np.repeat(centers, m)\n        elif params['id'] == 2:\n            i_vals = np.arange(n)\n            p_samples = 0.5 + 0.01 * np.cos(2 * np.pi * i_vals / n)\n        elif params['id'] == 3:\n            i_vals = np.arange(n)\n            p_samples = wl + (i_vals / (n - 1))**2 * (wu - wl)\n        elif params['id'] == 4:\n            m = 4\n            delta = (wu - wl) / k\n            centers = wl + (np.arange(k) + 0.5) * delta\n            p_samples = np.repeat(centers, m)\n\n        result = validate_rc(p_samples, wl, wu, k, params['alpha'], params['epsilon'])\n        results.append(result)\n\n    # The final print statement must match the required format exactly.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# To be run as a self-contained script.\nsolve()\n```"
        }
    ]
}