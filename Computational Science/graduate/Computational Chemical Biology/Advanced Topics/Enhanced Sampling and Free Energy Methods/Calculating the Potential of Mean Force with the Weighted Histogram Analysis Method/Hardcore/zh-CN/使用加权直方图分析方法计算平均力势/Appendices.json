{
    "hands_on_practices": [
        {
            "introduction": "在进行昂贵的伞形采样模拟之前，明智地设计实验方案至关重要。一个关键的设计参数是偏置势的力常数 $k_i$，它决定了每个窗口中采样分布的宽度。这项练习将引导您通过推导，将力常数与采样宽度联系起来，从而为您提供一种定量的方法来选择合适的 $k_i$ 值，以确保相邻窗口之间有足够的重叠，这是成功进行 WHAM 分析的基石 。",
            "id": "3838304",
            "problem": "在使用加权直方图分析方法（WHAM）重构一维平均力势的伞形采样中，每个窗口都对反应坐标$z$施加一个谐波偏置势。考虑这样一个窗口$i$，其偏置势为$U_i(z)$，中心位于$z_i$，劲度系数为$k_i$，定义为$U_i(z) = \\frac{1}{2} k_i (z - z_i)^{2}$。假设在温度$T$下处于正则平衡，并且偏置坐标$z$根据玻尔兹曼分布进行采样。从正则系综的定义以及玻尔兹曼权重正比于$\\exp(-\\beta U_i(z))$（其中$\\beta = 1/(k_B T)$）这一事实出发，推导偏置概率密度$p_i(z)$的归一化形式，并由此获得劲度系数$k_i$与采样分布在$z_i$附近的宽度$\\sigma_i$（标准差）之间的关系。除了玻尔兹曼形式外，不要假设任何关于谐振子的特定结果。\n\n为确保在相邻伞形窗口之间能够进行准确的WHAM重构，假设我们采用以下操作性重叠准则：对于中心间距为$\\Delta = |z_{i+1} - z_i|$的两个相邻窗口$i$和$i+1$，要求在窗口$i$中，相邻窗口中心的概率密度与其自身中心的概率密度之比等于一个目标值$r \\in (0,1)$，即$r = p_i(z_{i+1})/p_i(z_i)$。使用您推导出的偏置分布，得到一个用$r$、$\\Delta$、$T$和$k_B$表示的$k_i$的显式表达式。\n\n最后，对于一个$T = 300\\,\\mathrm{K}$的生物分子系统，其相邻伞形窗口中心的间距为$\\Delta = 0.10\\,\\mathrm{nm}$，目标重叠比为$r = 0.30$，计算$k_i$的数值。将最终的劲度系数以$\\mathrm{kJ\\,mol^{-1}\\,nm^{-2}}$为单位表示。使用摩尔气体常数$R = 8.314462618 \\times 10^{-3}\\,\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$代替$k_B$，以保持能量单位为每摩尔。将您的答案四舍五入到四位有效数字。",
            "solution": "这个问题分为三个部分：第一，推导归一化的偏置概率分布$p_i(z)$以及谐波劲度系数$k_i$与分布宽度$\\sigma_i$之间的关系；第二，根据指定的重叠准则推导$k_i$的表达式；第三，对$k_i$进行数值计算。\n\n**第1部分：偏置概率分布与劲度系数-宽度关系**\n\n在一个伞形采样窗口$i$中，系统受到一个总势能的作用，该势能包括内在的平均力势(PMF) $W(z)$和施加的偏置势$U_i(z)$。根据正则系综的原理，在反应坐标值$z$处发现系统的概率密度与总能量的玻尔兹曼因子成正比：$p_i(z) \\propto \\exp(-\\beta [W(z) + U_i(z)])$，其中$\\beta = 1/(k_B T)$是逆温度。\n\n对于一个足够强的谐波偏置，采样被局限在偏置中心$z_i$附近的一个狭窄区域内。在这个区域内，一个标准且合理的近似是假设内在PMF $W(z)$近似为常数，即$W(z) \\approx W(z_i)$。这个恒定的能量偏移可以被吸收到归一化常数中。因此，概率密度主要由偏置势$U_i(z)$决定：\n$$p_i(z) \\propto \\exp(-\\beta U_i(z))$$\n给定谐波偏置势的形式$U_i(z) = \\frac{1}{2} k_i (z - z_i)^2$，未归一化的概率密度为：\n$$\\tilde{p}_i(z) = C_0 \\exp\\left(-\\frac{\\beta k_i}{2} (z - z_i)^2\\right)$$\n其中$C_0$是一个任意常数。为了得到归一化的概率密度$p_i(z)$，我们必须施加条件$\\int_{-\\infty}^{\\infty} p_i(z) dz = 1$。设归一化形式为$p_i(z) = C \\exp\\left(-\\frac{\\beta k_i}{2} (z - z_i)^2\\right)$。归一化常数$C$则由积分的倒数给出：\n$$C^{-1} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k_i}{2} (z - z_i)^2\\right) dz$$\n这是一个标准的高斯积分。使用通用公式$\\int_{-\\infty}^{\\infty} \\exp(-ax^2) dx = \\sqrt{\\pi/a}$，并令$x = z - z_i$和$a = \\beta k_i / 2$，我们得到：\n$$C^{-1} = \\sqrt{\\frac{\\pi}{\\beta k_i / 2}} = \\sqrt{\\frac{2\\pi}{\\beta k_i}}$$\n因此，归一化常数为$C = \\sqrt{\\frac{\\beta k_i}{2\\pi}}$。归一化的偏置概率密度为：\n$$p_i(z) = \\sqrt{\\frac{\\beta k_i}{2\\pi}} \\exp\\left(-\\frac{\\beta k_i}{2} (z - z_i)^2\\right)$$\n这是一个均值为$\\mu = z_i$的正态（高斯）分布。正态分布的标准形式是$f(x; \\mu, \\sigma^2) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right)$。通过将我们推导出的$p_i(z)$的指数与标准形式进行比较，我们有：\n$$\\frac{(z-z_i)^2}{2\\sigma_i^2} = \\frac{\\beta k_i (z - z_i)^2}{2}$$\n这意味着方差$\\sigma_i^2$与劲度系数$k_i$的关系为$\\frac{1}{\\sigma_i^2} = \\beta k_i$。重新整理得到劲度系数和分布宽度（标准差）$\\sigma_i$之间的关系：\n$$\\sigma_i^2 = \\frac{1}{\\beta k_i} = \\frac{k_B T}{k_i}$$\n这可以写成$k_i = \\frac{k_B T}{\\sigma_i^2}$。\n\n**第2部分：从重叠准则推导劲度系数的表达式**\n\n给定两个相邻窗口$i$和$i+1$的重叠准则为$r = p_i(z_{i+1})/p_i(z_i)$。使用我们推导出的$p_i(z)$表达式：\n窗口$i$中心$z=z_i$处的概率密度是分布的最大值：\n$$p_i(z_i) = \\sqrt{\\frac{\\beta k_i}{2\\pi}} \\exp(0) = \\sqrt{\\frac{\\beta k_i}{2\\pi}}$$\n相邻窗口中心$z=z_{i+1}$处的概率密度为：\n$$p_i(z_{i+1}) = \\sqrt{\\frac{\\beta k_i}{2\\pi}} \\exp\\left(-\\frac{\\beta k_i}{2} (z_{i+1} - z_i)^2\\right)$$\n因此，该比值为：\n$$r = \\frac{p_i(z_{i+1})}{p_i(z_i)} = \\frac{\\sqrt{\\frac{\\beta k_i}{2\\pi}} \\exp\\left(-\\frac{\\beta k_i}{2} (z_{i+1} - z_i)^2\\right)}{\\sqrt{\\frac{\\beta k_i}{2\\pi}}} = \\exp\\left(-\\frac{\\beta k_i}{2} (z_{i+1} - z_i)^2\\right)$$\n给定中心间距$\\Delta = |z_{i+1} - z_i|$，我们有$\\Delta^2 = (z_{i+1} - z_i)^2$。方程变为：\n$$r = \\exp\\left(-\\frac{\\beta k_i \\Delta^2}{2}\\right)$$\n为了求出$k_i$的表达式，我们对两边取自然对数：\n$$\\ln(r) = -\\frac{\\beta k_i \\Delta^2}{2}$$\n解出$k_i$：\n$$k_i = -\\frac{2 \\ln(r)}{\\beta \\Delta^2}$$\n代入$\\beta = 1/(k_B T)$，我们得到$k_i$的最终显式表达式：\n$$k_i = -\\frac{2 k_B T \\ln(r)}{\\Delta^2}$$\n由于$r \\in (0,1)$，$\\ln(r)$是负数，这确保了劲度系数$k_i$是一个正值。\n\n**第3部分：数值计算**\n\n我们被要求使用给定的参数计算$k_i$的数值：$T = 300\\,\\mathrm{K}$，$\\Delta = 0.10\\,\\mathrm{nm}$，以及$r = 0.30$。题目指定使用摩尔气体常数$R = 8.314462618 \\times 10^{-3}\\,\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$代替玻尔兹曼常数$k_B$。这种替换将能量单位从“每个分子”正确地转换为“每摩尔”，从而得到单位为$\\mathrm{kJ\\,mol^{-1}\\,nm^{-2}}$的劲度系数。\n公式变为：\n$$k_i = -\\frac{2 R T \\ln(r)}{\\Delta^2}$$\n代入数值：\n$$k_i = -\\frac{2 \\times (8.314462618 \\times 10^{-3}\\,\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}) \\times (300\\,\\mathrm{K}) \\times \\ln(0.30)}{(0.10\\,\\mathrm{nm})^2}$$\n首先，我们计算乘积$RT$：\n$$RT = (8.314462618 \\times 10^{-3}\\,\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}) \\times (300\\,\\mathrm{K}) \\approx 2.4943\\,\\mathrm{kJ\\,mol^{-1}}$$\n接着，计算$r$的自然对数：\n$$\\ln(0.30) \\approx -1.2040$$\n现在，我们计算$k_i$：\n$$k_i = -\\frac{2 \\times (2.4943387854\\,\\mathrm{kJ\\,mol^{-1}}) \\times (-1.2039728043)}{0.0100\\,\\mathrm{nm}^2}$$\n$$k_i = \\frac{6.00626301\\,\\mathrm{kJ\\,mol^{-1}}}{0.0100\\,\\mathrm{nm}^2} \\approx 600.6263\\,\\mathrm{kJ\\,mol^{-1}\\,nm^{-2}}$$\n按照要求将结果四舍五入到四位有效数字，得到：\n$$k_i \\approx 600.6\\,\\mathrm{kJ\\,mol^{-1}\\,nm^{-2}}$$",
            "answer": "$$\\boxed{600.6}$$"
        },
        {
            "introduction": "掌握了如何设置采样窗口后，我们来解决一个完整而真实的科学问题：计算配体-受体结合自由能。这项全面的编程练习将模拟从生成模拟数据到实施 WHAM 算法，再到最终计算标准态结合自由能的整个工作流程。您将学习如何处理沿径向坐标的 PMF 计算中一个微妙而关键的方面——雅可比（Jacobian）因子 $4\\pi r^2$，从而将抽象的 PMF 曲线与可测量的热力学量联系起来 。",
            "id": "3838259",
            "problem": "您的任务是设计一个计算方案，使用伞形采样结合加权直方图分析方法 (WHAM)，估算沿标量径向分离坐标的配体-受体结合平均力势 (PMF)。配体-受体分离是一个以纳米为单位的标量坐标 $r$。三维空间中的径向度量引入了一个雅可比因子 $4\\pi r^2$，在 PMF 中必须明确考虑该因子。最终目标是计算标准态结合自由能。\n\n请从以下基本原理开始：\n\n- 对于能量为 $U(x)$ 的坐标 $x$，正则系综 Boltzmann 分布指出，概率密度与 $\\exp(-\\beta U(x))$ 成正比，其中 $\\beta = 1/(k_\\mathrm{B} T)$，$k_\\mathrm{B}$ 是 Boltzmann 常数，$T$ 是温度。\n- 三维径向坐标 $r$（无角度偏置）的概率密度有一个度量因子 $4\\pi r^2$，因此，当 $G(r)$ 是排除了几何熵项的 PMF 时，关于标量 $r$ 的概率密度与 $4\\pi r^2 \\exp(-\\beta G(r))$ 成正比。\n- 伞形采样在窗口 $i$ 中施加一个谐波偏置：$U_i^\\mathrm{bias}(r) = \\tfrac{1}{2} k_i (r - r_i)^2$，其中力常数为 $k_i$，中心为 $r_i$。\n- 加权直方图分析方法 (WHAM) 通过强制全局分布与窗口归一化之间的自洽性，将来自多个窗口的带偏置直方图合并成一个单一的无偏置分布。\n\n您的程序必须：\n\n1.  通过从一个已知的底层 PMF $G_\\mathrm{true}(r)$ 中采样，为每个窗口构建合成的伞形采样直方图（以使问题自洽且可测试）。在所有测试用例中用于数据生成的合成 PMF 是一个 Morse 型函数\n    $$G_\\mathrm{true}(r) = D\\left(\\exp\\big(-2 a (r - r_0)\\big) - 2 \\exp\\big(-a (r - r_0)\\big)\\right),$$\n    其中 $D$ 是深度参数，单位为 $\\mathrm{kJ/mol}$；$a$ 是范围参数，单位为 $\\mathrm{nm}^{-1}$；$r_0$ 是最小值位置，单位为 $\\mathrm{nm}$。温度必须为 $T = 300$ $\\mathrm{K}$，Boltzmann 常数必须为 $k_\\mathrm{B} = 0.008314462618$ $\\mathrm{kJ/(mol\\cdot K)}$，因此 $\\beta$ 的单位是 $(\\mathrm{kJ/mol})^{-1}$。$r$ 的网格必须是均匀的，其中 $r_\\mathrm{min} = 0.05$ $\\mathrm{nm}$，$r_\\mathrm{max} = 1.50$ $\\mathrm{nm}$，箱宽 $\\Delta r = 0.01$ $\\mathrm{nm}$。\n\n2.  对于每个窗口 $i$ 和每个以 $r_j$ 为中心的箱，使用与 $4\\pi r_j^2 \\exp\\big(-\\beta\\big(G_\\mathrm{true}(r_j) + U_i^\\mathrm{bias}(r_j)\\big)\\big)$ 成正比的带偏置径向概率密度构建预期的带偏置直方图计数，并在网格上进行归一化，使得窗口 $i$ 中的总计数等于指定的每个窗口的样本量 $N_i$。\n\n3.  实现加权直方图分析方法 (WHAM)，以从窗口直方图集合及其谐波偏置中，迭代地恢复网格上的全局无偏置概率密度 $\\hat{p}(r)$。不要使用任何快捷公式。从上述原理推導更新规则：\n    -   无偏置分布必须与由偏置诱导的重加权因子和窗口归一化常数的倒数加权的窗口直方图总和保持一致。\n    -   必须更新每个窗口的归一化常数，以使全局分布能重加权回到每个窗口的带偏置系综的归一化。\n\n    迭代直到窗口自由能收敛到一个严格的容差，使得所有窗口归一化常数在两次迭代之间的最大变化小于 $10^{-10}$（以能量单位计）。\n\n4.  通过明确地引入 $4\\pi r^2$ 因子，将无偏置标量概率密度 $\\hat{p}(r)$ 转换为排除雅可比因子的 PMF $G(r)$。PMF 必须被平移，使其在体相区域（此处定义为高 $r$ 值的尾部）趋近于零。使用 $r \\in [1.30, 1.50]\\,\\mathrm{nm}$ 的体相范围，并强制 $G(r)$ 在此范围内的平均值为零。\n\n5.  通过在结合区域 $[0, r_c]$ 上对结合常数进行积分，计算标准态结合自由能 $\\Delta G_\\mathrm{bind}^\\circ$：\n    -   计算径向结合常数 $K = \\int_0^{r_c} \\exp\\big(-\\beta G(r)\\big)\\,4\\pi r^2\\,dr$，单位为 $\\mathrm{nm}^3$。\n    -   使用 $1$ $\\mathrm{M}$ 时的标准态体积 $V^\\circ = 1.66053906660\\,\\mathrm{nm}^3$ 将其转换为无量纲的标准态平衡常数：$K^\\circ = K / V^\\circ$。\n    -   报告结合自由能 $\\Delta G_\\mathrm{bind}^\\circ = -\\beta^{-1} \\ln K^\\circ$，单位为 $\\mathrm{kJ/mol}$。\n\n您的程序必须实现以上步骤，并为以下测试套件生成结果。对于每个用例，请使用指定的窗口集、底层 PMF 参数、每个窗口的计数以及结合区域截断值 $r_c$。在每个用例中，伞形采样窗口的中心 $r_i$ 按指定方式均匀间隔，且力常数 $k_i$ 相同：\n\n-   测试用例 1 (一般情况):\n    -   窗口中心: $r_i \\in \\{0.20, 0.30, 0.40, \\dots, 1.20\\}$ $\\mathrm{nm}$，步长 $0.10$ $\\mathrm{nm}$。\n    -   力常数: $k_i = 1200$ $\\mathrm{kJ/(mol\\cdot nm^2)}$。\n    -   每个窗口的计数: $N_i = 50000$。\n    -   底层 PMF 参数: $D = 10$ $\\mathrm{kJ/mol}$, $a = 15$ $\\mathrm{nm}^{-1}$, $r_0 = 0.30$ $\\mathrm{nm}$。\n    -   结合区域截断值: $r_c = 0.45$ $\\mathrm{nm}$。\n\n-   测试用例 2 (弱结合边缘情况):\n    -   窗口中心: $r_i \\in \\{0.20, 0.30, 0.40, \\dots, 1.20\\}$ $\\mathrm{nm}$，步长 $0.10$ $\\mathrm{nm}$。\n    -   力常数: $k_i = 900$ $\\mathrm{kJ/(mol\\cdot nm^2)}$。\n    -   每个窗口的计数: $N_i = 30000$。\n    -   底层 PMF 参数: $D = 4$ $\\mathrm{kJ/mol}$, $a = 12$ $\\mathrm{nm}^{-1}$, $r_0 = 0.32$ $\\mathrm{nm}$。\n    -   结合区域截断值: $r_c = 0.45$ $\\mathrm{nm}$。\n\n-   测试用例 3 (强结合，更宽覆盖范围):\n    -   窗口中心: $r_i \\in \\{0.15, 0.25, 0.35, \\dots, 1.35\\}$ $\\mathrm{nm}$，步长 $0.10$ $\\mathrm{nm}$。\n    -   力常数: $k_i = 1500$ $\\mathrm{kJ/(mol\\cdot nm^2)}$。\n    -   每个窗口的计数: $N_i = 60000$。\n    -   底层 PMF 参数: $D = 20$ $\\mathrm{kJ/mol}$, $a = 22$ $\\mathrm{nm}^{-1}$, $r_0 = 0.28$ $\\mathrm{nm}$。\n    -   结合区域截断值: $r_c = 0.40$ $\\mathrm{nm}$。\n\n此处不适用角度单位。所有能量以 $\\mathrm{kJ/mol}$ 表示，所有长度以 $\\mathrm{nm}$ 表示。您的程序必须生成单行输出，其中包含测试套件的三个结合自由能，形式为用方括号括起来的逗号分隔列表，每个值四舍五入到三位小数（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$）。",
            "solution": "目标是使用加权直方图分析方法（WHAM）从合成的伞形采样数据中计算平均力势（PMF），并随后计算标准态结合自由能。此过程涉及多个步骤：生成合成的带偏置直方图，应用 WHAM 算法恢复无偏置概率分布，将此分布转换为 PMF，最后对 PMF 进行积分以获得结合自由能。\n\n首先，我们建立理论框架。沿着一维反应坐标 $r$ 的 PMF，记为 $G(r)$，通过 Boltzmann 关系与平衡概率密度 $P(r)$ 相关联。对于三维空间中的径向坐标，体积元为 $4\\pi r^2 dr$，这在概率密度中引入了一个雅可比因子。找到系统分离距离在 $r$ 和 $r+dr$ 之间的概率 $P(r)dr$ 由下式给出：\n$$P(r) \\propto 4\\pi r^2 \\exp(-\\beta G(r))$$\n其中 $\\beta = 1/(k_\\mathrm{B} T)$，$k_\\mathrm{B}$ 是 Boltzmann 常数，$T$ 是绝对温度。此处定义的 PMF $G(r)$ 代表了排除了由 $4\\pi r^2$ 项体现的几何熵贡献后的自由能剖面。\n\n伞形采样通过在每个模拟窗口 $i$ 中添加一个偏置势（通常是谐波形式）来增强对高能区域的采样。偏置势由 $U_i^\\mathrm{bias}(r) = \\frac{1}{2} k_i (r - r_i)^2$ 给出，其中 $k_i$ 是力常数，$r_i$ 是窗口 $i$ 中势的中心。在带偏置的模拟中，观测到的概率密度 $P_i^\\mathrm{bias}(r)$ 受此势的调制：\n$$P_i^\\mathrm{bias}(r) \\propto 4\\pi r^2 \\exp(-\\beta [G(r) + U_i^\\mathrm{bias}(r)])$$\n\n加权直方图分析方法（WHAM）是一种稳健的统计技术，用于组合来自多个带偏置模拟（窗口）的数据，以计算沿反应坐标的无偏置概率分布。它通过求解一组自洽方程来确定最佳组合。设 $N_{ij}$ 是从窗口 $i$ 中在坐标箱 $j$ 观测到的样本数，$N_i = \\sum_j N_{ij}$ 是窗口 $i$ 中的总样本数。WHAM 方程将处于箱 $j$ 中的无偏置概率 $P_j$ 与特定于窗口的自由能偏移量 $f_i$ 相关联：\n$$\n\\begin{cases}\nP_j = \\left( \\sum_{k=1}^{M} N_{kj} \\right) \\left/ \\left( \\sum_{k=1}^{M} N_k \\exp(\\beta f_k) \\exp(-\\beta U_{kj}) \\right) \\right. \\\\\n\\exp(-\\beta f_i) = \\sum_{j=1}^{N_\\mathrm{bins}} P_j \\exp(-\\beta U_{ij})\n\\end{cases}\n$$\n这里，$M$ 是窗口数量，$N_\\mathrm{bins}$ 是坐标箱的数量，$U_{ij} = U_i^\\mathrm{bias}(r_j)$ 是窗口 $i$ 的偏置势在箱 $j$ 中心处的值。概率 $P_j$ 的定义取决于一个全局归一化常数，通常被归一化以使得 $\\sum_j P_j = 1$。自由能 $f_i$ 仅是相对定义的，因此通常将其中一个设为零（例如，$f_1=0$）以获得唯一解。这些方程通过迭代求解，直到 $f_i$ 的值收敛。\n\n算法流程如下：\n1.  **系统设置与数据生成**：\n    -   定义物理常数 $\\beta = 1/(k_\\mathrm{B}T)$ 和一个从 $r_\\mathrm{min}$ 到 $r_\\mathrm{max}$ 且箱宽为 $\\Delta r$ 的 $r$ 值离散网格 $r_j$。\n    -   对于每个测试用例，真实的底层 PMF $G_\\mathrm{true}(r)$ 由一个 Morse 势定义：$G_\\mathrm{true}(r) = D(e^{-2a(r-r_0)} - 2e^{-a(r-r_0)})$。\n    -   对于每个窗口 $i$，生成一个合成直方图 $N_{ij}$。箱 $j$ 中的预期计数值与带偏置的概率密度成正比：$N_{ij} \\propto N_i \\cdot 4\\pi r_j^2 \\exp(-\\beta[G_\\mathrm{true}(r_j) + U_i^\\mathrm{bias}(r_j)])$。计数值被归一化以使得 $\\sum_j N_{ij} = N_i$。\n\n2.  **WHAM 迭代**：\n    -   初始化窗口自由能，例如，对所有 $i$ 设置 $f_i = 0$。\n    -   迭代直到任何 $f_i$ 的最大变化小于一个容差（$10^{-10}$）：\n      a. 使用当前的 $f_i$ 值计算所有箱的无偏置概率 $P_j$。这需要计算每个箱 $j$ 的分母项 $D_j = \\sum_{k=1}^M N_k \\exp(\\beta f_k - \\beta U_{kj})$ 和每个箱的总计数 $C_j = \\sum_{k=1}^M N_{kj}$。然后，未归一化的概率为 $\\tilde{P}_j = C_j / D_j$。最后，进行归一化以使 $\\sum_j P_j = 1$。\n      b. 使用更新后的概率 $P_j$ 计算一组新的自由能 $f_i^\\mathrm{new}$：$f_i^\\mathrm{new} = -\\beta^{-1} \\ln\\left(\\sum_j P_j \\exp(-\\beta U_{ij})\\right)$。\n      c. 为防止数值漂移，平移新的自由能，例如，通过减去第一个自由能的值：$f_i^\\mathrm{new} \\leftarrow f_i^\\mathrm{new} - f_i^\\mathrm{new}[0]$。\n      d. 更新 $f_i \\leftarrow f_i^\\mathrm{new}$ 并检查收敛性。\n\n3.  **PMF 重建**：\n    -   一旦获得收敛的无偏置概率 $P_j$，就可以计算 PMF $G(r_j)$。从 $P_j \\propto 4\\pi r_j^2 \\exp(-\\beta G(r_j))$，我们可以写出 $G(r_j) = -\\beta^{-1} \\ln(P_j/r_j^2) + \\text{constant}$。对于 $P_j=0$ 的箱，$G(r_j)$ 是无穷大。\n    -   PMF 通过一个加性常数进行平移，使其在体相区域（定义为 $r \\in [1.30, 1.50]$ nm）的平均值为零。这将参考态设置为未结合态。\n\n4.  **结合自由能计算**：\n    -   标准态结合自由能 $\\Delta G_\\mathrm{bind}^\\circ$ 由结合常数 $K$ 确定。径向结合常数在一个定义的结合体积上积分：\n      $$K = \\int_0^{r_c} 4\\pi r^2 \\exp(-\\beta G(r)) dr$$\n      该积分通过对截至截断值 $r_c$ 的网格箱求和进行数值近似：$K \\approx \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\exp(-\\beta G(r_j)) \\Delta r$。\n    -   标准态平衡常数 $K^\\circ$ 通过除以标准态体积 $V^\\circ = 1.66053906660$ $\\mathrm{nm}^3$（等效于 1 M 标准浓度）获得：$K^\\circ = K/V^\\circ$。\n    -   最后，结合自由能计算为：\n      $$\\Delta G_\\mathrm{bind}^\\circ = -k_\\mathrm{B} T \\ln(K^\\circ) = -\\beta^{-1} \\ln(K^\\circ)$$\n\n这整个方案对所提供的三个测试用例中的每一个都进行了实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the standard-state binding free energy for three test cases using WHAM.\n    \"\"\"\n\n    # --- Global Parameters and Constants ---\n    T = 300.0  # Temperature in K\n    K_B = 0.008314462618  # Boltzmann constant in kJ/(mol*K)\n    BETA = 1.0 / (K_B * T)  # In (kJ/mol)^-1\n    V_STANDARD = 1.66053906660  # Standard state volume in nm^3 (for 1 M)\n\n    # --- Grid setup ---\n    R_MIN = 0.05  # nm\n    R_MAX = 1.50  # nm\n    DR = 0.01  # nm\n    r_grid = np.arange(R_MIN, R_MAX + DR / 2.0, DR)\n    num_bins = len(r_grid)\n\n    # --- Bulk region definition for PMF shifting ---\n    BULK_MIN = 1.30\n    BULK_MAX = 1.50\n\n    # --- WHAM convergence criterion ---\n    WHAM_TOLERANCE = 1e-10\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"window_centers\": np.arange(0.20, 1.20 + 0.05, 0.10),\n            \"k\": 1200.0,\n            \"N_i\": 50000,\n            \"D\": 10.0,\n            \"a\": 15.0,\n            \"r0\": 0.30,\n            \"rc\": 0.45,\n        },\n        # Test Case 2\n        {\n            \"window_centers\": np.arange(0.20, 1.20 + 0.05, 0.10),\n            \"k\": 900.0,\n            \"N_i\": 30000,\n            \"D\": 4.0,\n            \"a\": 12.0,\n            \"r0\": 0.32,\n            \"rc\": 0.45,\n        },\n        # Test Case 3\n        {\n            \"window_centers\": np.arange(0.15, 1.35 + 0.05, 0.10),\n            \"k\": 1500.0,\n            \"N_i\": 60000,\n            \"D\": 20.0,\n            \"a\": 22.0,\n            \"r0\": 0.28,\n            \"rc\": 0.40,\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        window_centers = case[\"window_centers\"]\n        k = case[\"k\"]\n        N_i_val = case[\"N_i\"]\n        D = case[\"D\"]\n        a = case[\"a\"]\n        r0 = case[\"r0\"]\n        rc = case[\"rc\"]\n\n        num_windows = len(window_centers)\n        \n        # --- 1. Construct Synthetic Histograms ---\n        \n        # True PMF (Morse potential)\n        g_true = D * (np.exp(-2 * a * (r_grid - r0)) - 2 * np.exp(-a * (r_grid - r0)))\n        \n        histograms = np.zeros((num_windows, num_bins))\n        biases_matrix = np.zeros((num_windows, num_bins))\n        N_i_array = np.full(num_windows, N_i_val, dtype=float)\n\n        for i in range(num_windows):\n            r_center = window_centers[i]\n            # Harmonic bias potential for window i\n            u_bias = 0.5 * k * (r_grid - r_center)**2\n            biases_matrix[i, :] = u_bias\n            \n            # Biased energy\n            biased_energy = g_true + u_bias\n            \n            # Biased probability distribution including Jacobian\n            # Prop to 4*pi*r^2 * exp(-beta * E_biased)\n            unnorm_prob = (4 * np.pi * r_grid**2) * np.exp(-BETA * biased_energy)\n            \n            # Normalize probability for this window\n            norm_factor = np.sum(unnorm_prob)\n            if norm_factor == 0:\n                norm_prob = np.zeros_like(unnorm_prob)\n            else:\n                norm_prob = unnorm_prob / norm_factor\n\n            # Generate histogram counts\n            histograms[i, :] = N_i_val * norm_prob\n            \n        # --- 3. Implement WHAM ---\n        f_i = np.zeros(num_windows)  # Initialize window free energies\n        \n        # Pre-compute terms that don't change in the loop\n        total_counts_per_bin = np.sum(histograms, axis=0) # Numerator of P_j\n        exp_minus_beta_U = np.exp(-BETA * biases_matrix) # exp(-beta*U_ij)\n        \n        for iteration in range(10000): # Max iterations to prevent infinite loop\n            f_old = f_i.copy()\n            \n            # Denominator of P_j\n            exp_beta_f = np.exp(BETA * f_i)\n            weighted_N = N_i_array * exp_beta_f\n            \n            # Sum over windows k for each bin j\n            den_P = weighted_N @ exp_minus_beta_U\n            \n            with np.errstate(divide='ignore', invalid='ignore'):\n                P_unnormalized = total_counts_per_bin / den_P\n            \n            P_unnormalized[np.isnan(P_unnormalized)] = 0.0\n\n            # Normalize probabilities\n            P_sum = np.sum(P_unnormalized)\n            if P_sum > 0:\n                P = P_unnormalized / P_sum\n            else:\n                P = P_unnormalized # all zeros\n\n            # Update free energies f_i\n            with np.errstate(divide='ignore'):\n              log_arg = P @ exp_minus_beta_U.T\n            \n            f_new = -1.0 / BETA * np.log(log_arg)\n            f_new[np.isinf(f_new)] = f_i[np.isinf(f_new)] # Keep old if log_arg is 0\n\n            # Shift to prevent drift\n            f_new -= f_new[0]\n            f_i = f_new\n\n            # Check for convergence\n            max_change = np.max(np.abs(f_i - f_old))\n            if max_change  WHAM_TOLERANCE:\n                break\n        \n        # --- 4. Convert Probability to PMF and Shift ---\n        with np.errstate(divide='ignore'):\n             # G = -k_B*T * (ln(P) - ln(4*pi*r^2*dr))\n             # The constant term ln(4*pi*dr) will be absorbed into the shifting constant\n             G = -1.0 / BETA * (np.log(P) - 2.0 * np.log(r_grid))\n\n        G[np.isneginf(G)] = np.inf # Bins with P=0 have infinite free energy\n        \n        # Shift PMF so bulk region (high r) is zero\n        bulk_mask = (r_grid >= BULK_MIN)  (r_grid = BULK_MAX)\n        G_bulk = G[bulk_mask]\n        \n        finite_G_bulk = G_bulk[np.isfinite(G_bulk)]\n        if len(finite_G_bulk) > 0:\n            shift = np.mean(finite_G_bulk)\n            G -= shift\n        \n        # --- 5. Compute Standard-State Binding Free Energy ---\n        bound_mask = r_grid = rc\n        \n        # Integrand for association constant K\n        integrand = np.exp(-BETA * G) * (4 * np.pi * r_grid**2)\n        \n        # Numerical integration (sum over bins)\n        K = np.sum(integrand[bound_mask]) * DR\n\n        # Standard-state equilibrium constant and free energy\n        if K > 0 and V_STANDARD > 0:\n            K_standard = K / V_STANDARD\n            delta_G_bind = -1.0 / BETA * np.log(K_standard)\n        else:\n            delta_G_bind = np.inf # Should not happen\n\n        results.append(round(delta_G_bind, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "并非所有反应坐标都是线性的；许多重要的生物过程，如蛋白质构象变化，都由二面角等周期性坐标描述。标准的 WHAM 方法需要针对这些情况进行特殊调整，以避免在周期性边界处产生人为的间断。这项高级练习专注于将 WHAM 算法应用于周期性坐标，您将学习如何处理环形距离计算并应用循环统计学来确保 PMF 的连续性，从而正确地表征系统的周期性特征 。",
            "id": "3838305",
            "problem": "您必须编写一个完整、可运行的程序，该程序使用从第一性原理推导并结合圆形统计学实现的加权直方图分析方法 (WHAM) 来重构周期性坐标的平均力势 (PMF)，以确保跨边界的连续性。将反应坐标视为圆上的一个角度 $z$，其定义域为 $[0,2\\pi)$，并使用弧度作为角度单位。所有能量都必须以 $k_\\mathrm{B}T$ 为单位表示，所有报告的数值答案都必须是无量纲浮点数。\n\n从统计力学和概率论的以下基本原理出发：\n- 对于一个自由能为 $F(z)$ 的状态，其玻尔兹曼分布的概率密度 $P(z)$ 正比于 $\\exp\\!\\left(-F(z)/(k_\\mathrm{B}T)\\right)$。\n- 当施加谐波伞形偏置时，每个有偏分布正比于无偏概率密度乘以偏置的玻尔兹曼因子。\n- PMF 通过 $F(z) = -k_\\mathrm{B}T \\ln P(z) + C$ 与归一化的概率密度相关联，其中 $C$ 是一个不影响物理预测的加性常数。\n\n基于这些原理推导并实现 WHAM，不使用此处给出的任何快捷公式，以将多个有偏直方图优化组合，从而在覆盖整个圆周的离散化区间集合上估算无偏的 $P(z)$。请确保：\n- 坐标 $z$ 的周期为 $2\\pi$，并且您的离散化使用 $B$ 个区间，其中心均匀分布在 $[0,2\\pi)$ 上。\n- 圆上的距离计算为 $[-\\pi,\\pi)$ 内的回卷角差。\n- 在执行任何邻域、平滑或卷积操作时，通过将区间索引模 $B$ 处理来强制实现跨边界的连续性。\n- 应用圆形统计学，通过使用集中参数为 $\\kappa$ 的 Von Mises 圆形核对估计的 $P(z)$ 进行平滑，以避免在 $z=0$ 和 $z=2\\pi$ 处产生人为的不连续性。该平滑通过循环卷积实现，并进行归一化以保持总概率不变。\n\n通过以下步骤以确定性方式（无随机性）构建合成的伞形采样直方图：\n1. 定义一个物理上合理的底层真实 PMF $F_{\\mathrm{true}}(z)$ 及相应的归一化无偏密度 $P_{\\mathrm{true}}(z)$。\n2. 对于每个中心为 $c_i$、谐波劲度系数为 $k_i$（单位为 $k_\\mathrm{B}T$/rad$^2$）且样本量为 $N_i$ 的伞形窗口，定义偏置势 $U_i(z) = \\tfrac{1}{2} k_i\\,\\Delta(z,c_i)^2$，其中 $\\Delta(z,c_i)$ 是回卷角差。\n3. 计算每个窗口的有偏概率密度，该密度正比于 $\\exp\\!\\left(-\\left[F_{\\mathrm{true}}(z) + U_i(z)\\right]/(k_\\mathrm{B}T)\\right)$，并在圆上进行归一化，然后确定性地将每个区间的直方图计数分配为 $n_i(b) = N_i$ 乘以区间 $b$ 中的归一化有偏概率质量。\n\n实现 WHAM 以从 $\\{n_i(b)\\}$ 和 $\\{U_i(z_b)\\}$ 中恢复无偏的 $P(z)$，确保在圆上进行了正确的归一化。收敛后，计算 PMF $F(z) = -k_\\mathrm{B}T \\ln P(z) + C$，并设置加性常数 $C$ 使得 $\\min_z F(z) = 0$。在转换为 $F(z)$ 之前，对 $P(z)$ 应用 Von Mises 循环平滑，以避免人为的不连续性。\n\n您的程序必须为指定的测试套件计算以下指标，并将它们作为包含 Python 风格浮点数列表的单行输出：\n- 对于前两个测试用例，计算边界连续性指标 $\\delta_F$，定义为平滑后 PMF 在第一个和最后一个区间处值的绝对差：$\\delta_F = \\left|F(z_0) - F(z_{B-1})\\right|$，以 $k_\\mathrm{B}T$ 为单位报告。\n- 对于第三个测试用例，计算旋转不变性误差 $E_{\\mathrm{rot}}$，定义为来自旋转窗口的平滑后 PMF（通过对区间进行精确的循环移位以对齐回原始坐标系）与来自未旋转窗口的平滑后 PMF 之间的最大绝对差，以 $k_\\mathrm{B}T$ 为单位报告。\n\n角度单位规范：所有角度必须以弧度为单位。能量单位规范：所有能量和输出必须以 $k_\\mathrm{B}T$ 为单位表示。\n\n离散化和合成模型：\n- 在 $[0,2\\pi)$ 上使用 $B = 420$ 个区间，区间中心为 $z_b = \\frac{2\\pi}{B} \\left(b + \\tfrac{1}{2}\\right)$，其中 $b = 0,1,\\dots,B-1$。\n- 定义真实 PMF 为 $F_{\\mathrm{true}}(z) = A \\cos(2z) - B_0 \\cos(z)$，其中 $A = 1.5$ 和 $B_0 = 0.5$，单位均为 $k_\\mathrm{B}T$。定义 $P_{\\mathrm{true}}(z) \\propto \\exp\\!\\left(-F_{\\mathrm{true}}(z)/(k_\\mathrm{B}T)\\right)$ 并在圆上进行归一化。\n- 使用集中参数为 $\\kappa = 20$ 的 Von Mises 核对 $P(z)$ 进行循环平滑，实现为在 $B$ 个区间上的循环卷积。对核进行归一化，以使平滑后的密度保持归一化。\n\n测试套件：\n1. 正常路径覆盖：\n   - 窗口数 $M = 8$，中心 $c_i$ 均匀分布：$c_i = \\frac{2\\pi i}{M}$，其中 $i = 0,1,\\dots,7$。\n   - 所有 $i$ 的劲度系数 $k_i = 20$。\n   - 所有 $i$ 的样本量 $N_i = 50{,}000$。\n2. 稀疏边界覆盖：\n   - 窗口数 $M = 3$，中心为 $c = \\left[\\tfrac{\\pi}{2}, \\pi, \\tfrac{3\\pi}{2}\\right]$。\n   - 所有 $i$ 的劲度系数 $k_i = 25$。\n   - 所有 $i$ 的样本量 $N_i = 10{,}000$。\n3. 旋转不变性：\n   - 使用与测试 1 相同的配置，但将所有中心旋转 $\\delta = \\tfrac{2\\pi}{7}$，即 $c_i^\\prime = c_i + \\delta \\pmod{2\\pi}$。\n   - 计算旋转情况下的平滑后 PMF，并通过 $s = \\delta/\\Delta z$ 个区间的精确循环移位进行对齐，其中 $\\Delta z = \\tfrac{2\\pi}{B}$，因此 $s = 60$。\n   - 报告对齐后的旋转 PMF 与测试 1 的原始 PMF 之间的最大绝对差 $E_{\\mathrm{rot}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序包含三个测试用例的结果：$\\left[\\delta_F^{(1)}, \\delta_F^{(2)}, E_{\\mathrm{rot}}^{(3)}\\right]$。",
            "solution": "用户在计算化学生物学领域提供了一个定义明确且具有科学依据的问题。任务是为周期性反应坐标实现加权直方图分析方法 (WHAM)，从第一性原理推导该方法，并将其应用于一组指定的测试用例。实现必须使用适当的统计和数值技术来正确处理坐标的圆形特性。\n\n### WHAM 方程的推导\n\nWHAM 的目标是从多个有偏模拟中获得的样本集合中，找到无偏概率分布 $P(z)$ 的最佳估计。我们将反应坐标 $z \\in [0, 2\\pi)$ 离散化为 $B$ 个区间。设 $P_j$ 为系统在无偏状态下处于区间 $j$ 的未知概率质量。根据定义，$\\sum_{j=1}^{B} P_j = 1$。\n\n我们有一组 $M$ 个模拟，或称“窗口”。对于每个模拟 $i \\in \\{1, \\dots, M\\}$，我们有一个偏置势 $U_i(z)$ 和总共 $N_i$ 个采集的样本。观测数据是直方图 $\\{n_{ij}\\}$，其中 $n_{ij}$ 是来自模拟 $i$ 且落入区间 $j$ 的样本数。在所有模拟中，区间 $j$ 的总样本数为 $n_j = \\sum_{i=1}^{M} n_{ij}$。所有能量，包括偏置势 $U_{ij} \\equiv U_i(z_j)$，都以 $k_\\mathrm{B}T$ 为单位表示。\n\n根据统计力学，有偏模拟中一个状态的概率密度是无偏概率密度与偏置势的玻尔兹曼因子的乘积。对于我们的离散化系统，在样本来自模拟 $i$ 的条件下，在区间 $j$ 观察到该样本的概率是：\n$$\nP(j|i) = \\frac{P_j \\exp(-U_{ij})}{\\sum_{k=1}^{B} P_k \\exp(-U_{ik})}\n$$\n分母是第 $i$ 次有偏模拟的配分函数。我们可以用每个窗口的无量纲自由能偏移量 $f_i$ 来表示它：\n$$\n\\exp(-f_i) = \\sum_{k=1}^{B} P_k \\exp(-U_{ik})\n$$\n这就得到了第一个核心 WHAM 方程，它将未知的概率集合 $\\{P_k\\}$ 与未知的窗口自由能集合 $\\{f_i\\}$ 联系起来：\n$$\nf_i = -\\ln \\left( \\sum_{k=1}^{B} P_k \\exp(-U_{ik}) \\right)\n\\quad \\quad \\text{(方程 1)}\n$$\n为了找到 $\\{P_j\\}$ 的最佳估计，我们最大化观察到所有直方图集合 $\\{n_{ij}\\}$ 的总对数似然。似然函数是每个模拟的多项式概率的乘积。对数似然 $\\ln \\mathcal{L}$ 由下式给出：\n$$\n\\ln \\mathcal{L}(\\{P_j\\} | \\{n_{ij}\\}) = \\sum_{i=1}^{M} \\sum_{j=1}^{B} n_{ij} \\ln P(j|i) + \\text{constant}\n$$\n代入 $P(j|i) = P_j \\exp(-U_{ij}) \\exp(f_i)$ 并使用 $f_i$ 的定义：\n$$\n\\ln \\mathcal{L} = \\sum_{i=1}^{M} \\sum_{j=1}^{B} n_{ij} (\\ln P_j - U_{ij} + f_i) = \\sum_{i,j} n_{ij} \\ln P_j - \\sum_{i,j} n_{ij} U_{ij} + \\sum_i N_i f_i\n$$\n将方程 1 代入 $f_i$：\n$$\n\\ln \\mathcal{L} = \\sum_{j=1}^{B} \\left(\\sum_{i=1}^{M} n_{ij}\\right) \\ln P_j - \\sum_{i=1}^{M} N_i \\ln \\left( \\sum_{k=1}^{B} P_k \\exp(-U_{ik}) \\right) + \\text{constant}\n$$\n我们使用拉格朗日乘数法，在归一化约束 $\\sum_j P_j = 1$ 的条件下，对每个 $P_j$ 最大化此函数。对 $P_j$ 求导并令结果为零，得到：\n$$\n\\frac{\\partial}{\\partial P_j} \\left[ \\ln \\mathcal{L} - \\lambda \\left(\\sum_k P_k - 1\\right) \\right] = \\frac{\\sum_i n_{ij}}{P_j} - \\sum_{i=1}^{M} N_i \\frac{\\exp(-U_{ij})}{\\sum_k P_k \\exp(-U_{ik})} - \\lambda = 0\n$$\n使用 $f_i$ 的定义，上式可简化为：\n$$\n\\frac{\\sum_i n_{ij}}{P_j} = \\sum_{i=1}^{M} N_i \\exp(f_i - U_{ij}) + \\lambda\n$$\n拉格朗日乘子 $\\lambda$ 可以被吸收到自由能 $f_i$ 的定义中，因为自由能的定义本身就允许一个任意的加性常数。遵循标准的 WHAM 推导，我们设 $\\lambda=0$ 并求解 $P_j$：\n$$\nP_j = \\frac{\\sum_{i=1}^{M} n_{ij}}{\\sum_{k=1}^{M} N_k \\exp(f_k - U_{kj})}\n\\quad \\quad \\text{(方程 2)}\n$$\n方程 1 和 2 构成了关于 $\\{P_j\\}$ 和 $\\{f_i\\}$ 的一组自洽方程。它们通过迭代求解：\n1. 初始化自由能 $\\{f_i\\}$，例如，对所有 $i$ 设 $f_i = 0$。\n2. 使用方程 2 计算概率分布 $\\{P_j\\}$。\n3. 归一化 $\\{P_j\\}$ 使得 $\\sum_j P_j = 1$。\n4. 使用方程 1 计算新的自由能 $\\{f_i\\}$。\n5. 通过一个加性常数平移 $\\{f_i\\}$ 向量（例如，设 $f_1=0$）以防止数值漂移。\n6. 重复步骤 2-5，直到 $\\{f_i\\}$ 的值收敛。\n\n### 周期性坐标的实现\n\n对于圆形反应坐标 $z$，需要进行特殊考虑以保证周期性和连续性。\n- **角距离**：谐波偏置势 $U_i(z) = \\frac{1}{2} k_i \\Delta(z,c_i)^2$ 中使用的距离 $\\Delta(z,c_i)$ 必须是圆上的最短弧长距离。这被计算为回卷角差，其值在 $[-\\pi, \\pi)$ 内。\n- **循环平滑**：从 WHAM 获得的原始概率分布 $P_j$ 可能含有噪声。为了获得平滑且具有物理意义的 PMF，$P_j$ 需要被平滑处理。对于周期性变量，这可以通过与一个周期性核进行循环卷积来正确实现。问题指定了使用 Von Mises 核，它是正态分布的一个圆形模拟。对于具有 $B$ 个区间的离散坐标，以区间 0 为中心的核具有形式 $K_b \\propto \\exp(\\kappa \\cos(2\\pi b/B))$，其中 $b=0,...,B-1$。概率向量 $P$ 与核向量 $K$ 的卷积可以通过使用快速傅里叶变换 (FFT) 的卷积定理来最有效地计算：$P_{\\text{smooth}} = \\text{IFFT}(\\text{FFT}(P) \\cdot \\text{FFT}(K))$。离散傅里叶变换的内在周期性可以正确处理循环边界条件。\n\n### 从概率到 PMF\n\n平均力势 (PMF) $F(z)$ 通过 $F(z) = -k_\\mathrm{B}T \\ln p(z) + C$ 与概率密度 $p(z)$ 相关。在我们的离散系统中，区间中心 $z_j$ 处的概率密度是 $p(z_j) = P_j / \\Delta z$，其中 $P_j$ 是该区间的概率质量，$\\Delta z = 2\\pi/B$ 是区间宽度。因此，\n$$\nF(z_j) = -k_\\mathrm{B}T \\ln\\left(\\frac{P_j^{\\text{smooth}}}{\\Delta z}\\right) = -k_\\mathrm{B}T \\ln P_j^{\\text{smooth}} + k_\\mathrm{B}T \\ln(\\Delta z)\n$$\n由于所有能量都以 $k_\\mathrm{B}T$ 为单位，我们设 $k_\\mathrm{B}T=1$。$\\ln(\\Delta z)$ 项是一个常数，它被吸收到任意的加性常数 $C$ 中。最终的 PMF 计算为 $F_j = -\\ln(P_j^{\\text{smooth}})$，然后通过减去其最小值进行平移，使得 $\\min_j F_j = 0$。\n\n### 合成数据和测试用例\n\n程序首先基于一个已知的真实 PMF $F_{\\mathrm{true}}(z) = 1.5 \\cos(2z) - 0.5 \\cos(z)$ 生成合成的、确定性的直方图数据。对于每个模拟窗口 $i$，计算其有偏概率分布，并用其填充直方图计数 $n_{ij} = N_i \\times P(j|i)$。然后将 WHAM 算法应用于此合成数据以恢复 PMF。计算指定的指标，即边界连续性 $\\delta_F$ 和旋转不变性误差 $E_{\\mathrm{rot}}$，以验证实现的正确性和鲁棒性，特别是其对周期性的处理能力。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft\n\ndef solve():\n    \"\"\"\n    Main function to run the WHAM analysis for the specified test cases.\n    \"\"\"\n    # Define problem constants\n    BINS = 420\n    TRUE_PMF_A = 1.5\n    TRUE_PMF_B0 = 0.5\n    VON_MISES_KAPPA = 20.0\n    KBT = 1.0  # All energies are in units of k_B*T\n\n    def wrapped_dist(z1, z2):\n        \"\"\"Computes the wrapped angular distance z1 - z2, mapping to [-pi, pi).\"\"\"\n        dist = z1 - z2\n        return (dist + np.pi) % (2 * np.pi) - np.pi\n\n    def generate_synthetic_data(num_bins, centers, stiffnesses, sample_sizes):\n        \"\"\"Generates synthetic deterministic histogram data for umbrella sampling.\"\"\"\n        z_b = (2 * np.pi / num_bins) * (np.arange(num_bins) + 0.5)\n\n        # 1. Define true PMF and corresponding probability mass distribution\n        F_true = TRUE_PMF_A * np.cos(2 * z_b) - TRUE_PMF_B0 * np.cos(z_b)\n        P_true_unnorm = np.exp(-F_true / KBT)\n        P_true_mass = P_true_unnorm / np.sum(P_true_unnorm)\n\n        num_windows = len(centers)\n        n_ij = np.zeros((num_windows, num_bins))\n        U_ij = np.zeros((num_windows, num_bins))\n\n        for i in range(num_windows):\n            # 2. Define bias potential for the window\n            U_ij[i, :] = 0.5 * stiffnesses[i] * wrapped_dist(z_b, centers[i])**2\n\n            # 3. Compute the biased probability distribution\n            P_biased_unnorm = P_true_mass * np.exp(-U_ij[i, :] / KBT)\n            P_biased_mass = P_biased_unnorm / np.sum(P_biased_unnorm)\n\n            # 4. Deterministically assign histogram counts for the window\n            n_ij[i, :] = sample_sizes[i] * P_biased_mass\n\n        return n_ij, U_ij\n\n    def solve_wham(n_ij, U_ij):\n        \"\"\"Solves the self-consistent WHAM equations.\"\"\"\n        num_windows, num_bins = n_ij.shape\n        N_i = n_ij.sum(axis=1)\n        \n        # Initial guess for window free energies\n        f_i = np.zeros(num_windows)\n        \n        max_iter = 10000\n        tolerance = 1e-12\n        \n        for _ in range(max_iter):\n            f_i_old = np.copy(f_i)\n            \n            # Equation 2: Update probability distribution P_j\n            sum_n_j = np.sum(n_ij, axis=0)\n            denominator_P = np.sum(N_i[:, np.newaxis] * np.exp((f_i[:, np.newaxis] - U_ij) / KBT), axis=0)\n            P_j = sum_n_j / denominator_P\n            P_j /= np.sum(P_j)  # Normalize probability mass\n\n            # Equation 1: Update free energies f_i\n            sum_term = np.sum(P_j[np.newaxis, :] * np.exp(-U_ij / KBT), axis=1)\n            # Add a small epsilon to prevent log(0) in case of no overlap, though unlikely here.\n            f_i = -KBT * np.log(sum_term + 1e-100)\n            \n            # Shift free energies to prevent numerical drift (f_0 = 0)\n            f_i -= f_i[0]\n            \n            # Check for convergence\n            diff = np.max(np.abs(f_i - f_i_old))\n            if diff  tolerance:\n                break\n        \n        return P_j\n\n    def smooth_and_get_pmf(P_j, num_bins, kappa):\n        \"\"\"Smooths probability distribution with a Von Mises kernel and computes the PMF.\"\"\"\n        \n        # 1. Define Von Mises kernel for circular convolution\n        b_indices = np.arange(num_bins)\n        kernel = np.exp(kappa * np.cos(2 * np.pi * b_indices / num_bins))\n        kernel /= np.sum(kernel) # Normalize kernel\n\n        # 2. Perform circular convolution using FFT\n        P_fft = fft(P_j)\n        kernel_fft = fft(kernel)\n        P_smooth_fft = P_fft * kernel_fft\n        P_smooth_j = np.real(ifft(P_smooth_fft))\n        P_smooth_j /= np.sum(P_smooth_j) # Re-normalize after FFT\n\n        # 3. Calculate PMF from smoothed probability mass\n        # The conversion from mass to density adds a constant log(delta_z)\n        # which is absorbed when shifting the minimum to zero.\n        pmf = -KBT * np.log(P_smooth_j + 1e-100) # Add epsilon to avoid log(0)\n        pmf -= np.min(pmf) # Shift PMF so that min is 0\n        \n        return pmf\n\n    def run_case(centers, stiffnesses, samples, kappa, num_bins):\n        \"\"\"Helper func to run one full WHAM calculation.\"\"\"\n        n_ij, U_ij = generate_synthetic_data(num_bins, centers, stiffnesses, samples)\n        P_j = solve_wham(n_ij, U_ij)\n        pmf = smooth_and_get_pmf(P_j, num_bins, kappa)\n        return pmf\n\n    results = []\n\n    # Test Case 1: Happy path coverage\n    M1 = 8\n    centers1 = (2 * np.pi / M1) * np.arange(M1)\n    stiffnesses1 = np.full(M1, 20.0)\n    samples1 = np.full(M1, 50000)\n    pmf_1 = run_case(centers1, stiffnesses1, samples1, VON_MISES_KAPPA, BINS)\n    delta_F_1 = np.abs(pmf_1[-1] - pmf_1[0])\n    results.append(delta_F_1)\n\n    # Test Case 2: Sparse boundary coverage\n    M2 = 3\n    centers2 = np.array([np.pi/2.0, np.pi, 3.0*np.pi/2.0])\n    stiffnesses2 = np.full(M2, 25.0)\n    samples2 = np.full(M2, 10000)\n    pmf_2 = run_case(centers2, stiffnesses2, samples2, VON_MISES_KAPPA, BINS)\n    delta_F_2 = np.abs(pmf_2[-1] - pmf_2[0])\n    results.append(delta_F_2)\n\n    # Test Case 3: Rotation invariance\n    # The original PMF is pmf_1 from test case 1.\n    delta_rot = 2 * np.pi / 7\n    centers3 = (centers1 + delta_rot) % (2 * np.pi)\n    s_shift = 60 # Shift in bins corresponding to delta_rot (420/7)\n    \n    # Run WHAM on rotated configuration\n    pmf_3_rot = run_case(centers3, stiffnesses1, samples1, VON_MISES_KAPPA, BINS)\n    \n    # Align the rotated PMF back to the original frame by a circular shift\n    # A positive rotation of centers moves features to higher indices.\n    # To align back, we need to shift the PMF data to lower indices (negative roll).\n    pmf_3_aligned = np.roll(pmf_3_rot, -s_shift)\n    \n    # Calculate the max absolute error between original and aligned-rotated PMF\n    E_rot = np.max(np.abs(pmf_3_aligned - pmf_1))\n    results.append(E_rot)\n\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}