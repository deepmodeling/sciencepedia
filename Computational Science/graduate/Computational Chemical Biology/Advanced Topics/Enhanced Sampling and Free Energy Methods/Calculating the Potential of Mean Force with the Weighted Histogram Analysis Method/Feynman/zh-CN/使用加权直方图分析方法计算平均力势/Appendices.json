{
    "hands_on_practices": [
        {
            "introduction": "在进行伞形采样模拟之前，一个关键的准备步骤是合理设置偏置势。这个练习将引导你从统计力学的基本原理出发，推导偏置势的刚度系数 $k_i$ 与采样分布宽度之间的关系。掌握这一关系对于确保相邻窗口之间有足够的重叠至关重要，这是加权直方图分析方法（WHAM）成功的先决条件。",
            "id": "3838304",
            "problem": "在使用加权直方图分析方法（WHAM）通过伞形采样重构一维平均力势时，每个窗口都对一个反应坐标 $z$ 施加谐波偏置势。考虑这样一个窗口 $i$，其偏置势为 $U_i(z)$，中心位于 $z_i$，劲度系数为 $k_i$，定义为 $U_i(z) = \\frac{1}{2} k_i (z - z_i)^{2}$。假设在温度 $T$ 下处于正则系综平衡，并且偏置坐标 $z$ 根据玻尔兹曼分布进行采样。从正则系综的定义出发，并利用玻尔兹曼权重正比于 $\\exp(-\\beta U_i(z))$（其中 $\\beta = 1/(k_B T)$）这一事实，推导偏置概率密度 $p_i(z)$ 的归一化形式，并由此获得劲度系数 $k_i$ 与采样分布在 $z_i$ 附近的宽度 $\\sigma_i$（标准差）之间的关系。除了玻尔兹曼形式外，不要假设任何关于谐振子的特定结果。\n\n为确保相邻伞形窗口之间能够进行准确的 WHAM 重构，假设我们采用以下操作性重叠准则：对于中心间距为 $\\Delta = |z_{i+1} - z_i|$ 的两个相邻窗口 $i$ 和 $i+1$，要求在窗口 $i$ 中，相邻窗口中心的概率密度与自身中心的概率密度之比等于一个目标值 $r \\in (0,1)$，即 $r = p_i(z_{i+1})/p_i(z_i)$。使用您推导出的偏置分布，获得 $k_i$ 关于 $r$、$\\Delta$、$T$ 和 $k_B$ 的显式表达式。\n\n最后，对于一个生物分子体系，在温度 $T = 300\\,\\mathrm{K}$、相邻伞形窗口中心间距 $\\Delta = 0.10\\,\\mathrm{nm}$、目标重叠比 $r = 0.30$ 的条件下，计算 $k_i$ 的数值。将最终的劲度系数以 $\\mathrm{kJ\\,mol^{-1}\\,nm^{-2}}$ 为单位表示。使用摩尔气体常数 $R = 8.314462618 \\times 10^{-3}\\,\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$ 代替 $k_B$，以保持能量单位为每摩尔。将您的答案四舍五入到四位有效数字。",
            "solution": "问题分为三个部分：第一，推导归一化的偏置概率分布 $p_i(z)$ 以及谐波劲度系数 $k_i$ 和分布宽度 $\\sigma_i$ 之间的关系；第二，根据指定的重叠准则推导 $k_i$ 的表达式；第三，对 $k_i$ 进行数值计算。\n\n**第一部分：偏置概率分布与劲度系数-宽度关系**\n\n在一个伞形采样窗口 $i$ 中，系统受到的总势能包括内在的平均力势（PMF）$W(z)$ 和施加的偏置势 $U_i(z)$。根据正则系综的原理，在反应坐标值 $z$ 处找到系统的概率密度与总能量的玻尔兹曼因子成正比：$p_i(z) \\propto \\exp(-\\beta [W(z) + U_i(z)])$，其中 $\\beta = 1/(k_B T)$ 是逆温度。\n\n对于一个足够强的谐波偏置，采样被局限在偏置中心 $z_i$ 附近的一个狭窄区域内。在这个区域内，一个标准且合理的近似是假设内在的平均力势 $W(z)$ 近似为常数，即 $W(z) \\approx W(z_i)$。这个恒定的能量偏移可以被吸收到归一化常数中。那么，概率密度主要由偏置势 $U_i(z)$ 决定：\n$$p_i(z) \\propto \\exp(-\\beta U_i(z))$$\n给定偏置势的谐波形式 $U_i(z) = \\frac{1}{2} k_i (z - z_i)^2$，未归一化的概率密度为：\n$$\\tilde{p}_i(z) = C_0 \\exp\\left(-\\frac{\\beta k_i}{2} (z - z_i)^2\\right)$$\n其中 $C_0$ 是一个任意常数。为了获得归一化的概率密度 $p_i(z)$，我们必须强制执行条件 $\\int_{-\\infty}^{\\infty} p_i(z) dz = 1$。设归一化形式为 $p_i(z) = C \\exp\\left(-\\frac{\\beta k_i}{2} (z - z_i)^2\\right)$。那么归一化常数 $C$ 由积分的倒数给出：\n$$C^{-1} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k_i}{2} (z - z_i)^2\\right) dz$$\n这是一个标准的高斯积分。使用通用公式 $\\int_{-\\infty}^{\\infty} \\exp(-ax^2) dx = \\sqrt{\\pi/a}$，并令 $x = z - z_i$ 和 $a = \\beta k_i / 2$，我们得到：\n$$C^{-1} = \\sqrt{\\frac{\\pi}{\\beta k_i / 2}} = \\sqrt{\\frac{2\\pi}{\\beta k_i}}$$\n因此，归一化常数为 $C = \\sqrt{\\frac{\\beta k_i}{2\\pi}}$。归一化的偏置概率密度为：\n$$p_i(z) = \\sqrt{\\frac{\\beta k_i}{2\\pi}} \\exp\\left(-\\frac{\\beta k_i}{2} (z - z_i)^2\\right)$$\n这是一个均值为 $\\mu = z_i$ 的正态（高斯）分布。正态分布的标准形式是 $f(x; \\mu, \\sigma^2) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right)$。通过将我们推导出的 $p_i(z)$ 的指数部分与标准形式进行比较，我们有：\n$$\\frac{(z-z_i)^2}{2\\sigma_i^2} = \\frac{\\beta k_i (z - z_i)^2}{2}$$\n这意味着方差 $\\sigma_i^2$ 与劲度系数 $k_i$ 的关系为 $\\frac{1}{\\sigma_i^2} = \\beta k_i$。整理后得到劲度系数与分布宽度（标准差）$\\sigma_i$ 之间的关系：\n$$\\sigma_i^2 = \\frac{1}{\\beta k_i} = \\frac{k_B T}{k_i}$$\n这可以写成 $k_i = \\frac{k_B T}{\\sigma_i^2}$。\n\n**第二部分：从重叠准则推导劲度系数的表达式**\n\n给定两个相邻窗口 $i$ 和 $i+1$ 的重叠准则为 $r = p_i(z_{i+1})/p_i(z_i)$。使用我们推导出的 $p_i(z)$ 表达式：\n在窗口 $i$ 的中心 $z=z_i$ 处的概率密度是分布的最大值：\n$$p_i(z_i) = \\sqrt{\\frac{\\beta k_i}{2\\pi}} \\exp(0) = \\sqrt{\\frac{\\beta k_i}{2\\pi}}$$\n在相邻窗口的中心 $z=z_{i+1}$ 处的概率密度是：\n$$p_i(z_{i+1}) = \\sqrt{\\frac{\\beta k_i}{2\\pi}} \\exp\\left(-\\frac{\\beta k_i}{2} (z_{i+1} - z_i)^2\\right)$$\n因此，比值为：\n$$r = \\frac{p_i(z_{i+1})}{p_i(z_i)} = \\frac{\\sqrt{\\frac{\\beta k_i}{2\\pi}} \\exp\\left(-\\frac{\\beta k_i}{2} (z_{i+1} - z_i)^2\\right)}{\\sqrt{\\frac{\\beta k_i}{2\\pi}}} = \\exp\\left(-\\frac{\\beta k_i}{2} (z_{i+1} - z_i)^2\\right)$$\n给定中心间距 $\\Delta = |z_{i+1} - z_i|$，我们有 $\\Delta^2 = (z_{i+1} - z_i)^2$。方程变为：\n$$r = \\exp\\left(-\\frac{\\beta k_i \\Delta^2}{2}\\right)$$\n为了求出 $k_i$ 的表达式，我们对两边取自然对数：\n$$\\ln(r) = -\\frac{\\beta k_i \\Delta^2}{2}$$\n解出 $k_i$：\n$$k_i = -\\frac{2 \\ln(r)}{\\beta \\Delta^2}$$\n代入 $\\beta = 1/(k_B T)$，我们得到 $k_i$ 的最终显式表达式：\n$$k_i = -\\frac{2 k_B T \\ln(r)}{\\Delta^2}$$\n由于 $r \\in (0,1)$，$\\ln(r)$ 为负，这确保了劲度系数 $k_i$ 是一个正量。\n\n**第三部分：数值计算**\n\n我们被要求使用给定的参数计算 $k_i$ 的数值：$T = 300\\,\\mathrm{K}$，$\\Delta = 0.10\\,\\mathrm{nm}$，以及 $r = 0.30$。题目指定使用摩尔气体常数 $R = 8.314462618 \\times 10^{-3}\\,\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$ 代替玻尔兹曼常数 $k_B$。这种替换将能量单位从每个分子正确地调整为每摩尔，从而得到单位为 $\\mathrm{kJ\\,mol^{-1}\\,nm^{-2}}$ 的劲度系数。\n公式变为：\n$$k_i = -\\frac{2 R T \\ln(r)}{\\Delta^2}$$\n代入数值：\n$$k_i = -\\frac{2 \\times (8.314462618 \\times 10^{-3}\\,\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}) \\times (300\\,\\mathrm{K}) \\times \\ln(0.30)}{(0.10\\,\\mathrm{nm})^2}$$\n首先，我们计算乘积 $RT$：\n$$RT = (8.314462618 \\times 10^{-3}\\,\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}) \\times (300\\,\\mathrm{K}) \\approx 2.4943\\,\\mathrm{kJ\\,mol^{-1}}$$\n接下来，计算 $r$ 的自然对数：\n$$\\ln(0.30) \\approx -1.2040$$\n现在，我们计算 $k_i$：\n$$k_i = -\\frac{2 \\times (2.4943387854\\,\\mathrm{kJ\\,mol^{-1}}) \\times (-1.2039728043)}{0.0100\\,\\mathrm{nm}^2}$$\n$$k_i = \\frac{6.00626301\\,\\mathrm{kJ\\,mol^{-1}}}{0.0100\\,\\mathrm{nm}^2} \\approx 600.6263\\,\\mathrm{kJ\\,mol^{-1}\\,nm^{-2}}$$\n按照要求将结果四舍五入到四位有效数字，得到：\n$$k_i \\approx 600.6\\,\\mathrm{kJ\\,mol^{-1}\\,nm^{-2}}$$",
            "answer": "$$\\boxed{600.6}$$"
        },
        {
            "introduction": "本练习提供了一个计算配体-受体结合自由能的完整工作流程，这是一个在药物发现中至关重要的应用。你将从头开始构建一个完整的加权直方图分析方法（WHAM）流程，包括处理径向坐标所需的 $4\\pi r^2$ 雅可比校正，并最终计算标准态结合自由能 $\\Delta G_\\mathrm{bind}^\\circ$。这个综合性实践将加深你对从原始模拟数据到最终物理可观测量整个过程的理解。",
            "id": "3838259",
            "problem": "您需要设计一个计算方案，以估算配体-受体结合的平均力势 (PMF)，该方案沿着一个标量径向分离坐标，使用伞形采样结合加权直方图分析方法 (WHAM)。配体-受体分离是一个以纳米为单位的标量坐标 $r$。三维空间中的径向度量引入了一个雅可比因子 $4\\pi r^2$，在 PMF 中必须明确考虑该因子。最终目标是计算标准态结合自由能。\n\n从以下基本原理出发：\n\n- 对于能量为 $U(x)$ 的坐标 $x$，其正则系综 Boltzmann 分布指出，概率密度与 $\\exp(-\\beta U(x))$ 成正比，其中 $\\beta = 1/(k_\\mathrm{B} T)$，$k_\\mathrm{B}$ 是 Boltzmann 常数，$T$ 是温度。\n- 对于三维径向坐标 $r$（无角度偏置），其概率密度有一个度量因子 $4\\pi r^2$，因此，当 $G(r)$ 是排除了几何熵项的 PMF 时，关于标量 $r$ 的概率密度与 $4\\pi r^2 \\exp(-\\beta G(r))$ 成正比。\n- 伞形采样在窗口 $i$ 中施加一个谐波偏置势：$U_i^\\mathrm{bias}(r) = \\tfrac{1}{2} k_i (r - r_i)^2$，其中力常数为 $k_i$，中心为 $r_i$。\n- 加权直方图分析方法 (WHAM) 通过强制全局分布和窗口归一化之间的自洽性，将来自多个窗口的偏置直方图组合成一个单一的无偏置分布。\n\n您的程序必须：\n\n1. 通过从一个已知的底层 PMF $G_\\mathrm{true}(r)$ 中采样，为每个窗口构建合成的伞形采样直方图（以使问题自洽且可测试）。在所有测试用例中用于生成数据的合成 PMF 是一个 Morse 型函数\n   $$G_\\mathrm{true}(r) = D\\left(\\exp\\big(-2 a (r - r_0)\\big) - 2 \\exp\\big(-a (r - r_0)\\big)\\right),$$\n   其中 $D$ 是深度参数，单位为 $\\mathrm{kJ/mol}$，$a$ 是范围参数，单位为 $\\mathrm{nm}^{-1}$，$r_0$ 是最小值位置，单位为 $\\mathrm{nm}$。温度必须为 $T = 300$ $\\mathrm{K}$，Boltzmann 常数必须为 $k_\\mathrm{B} = 0.008314462618$ $\\mathrm{kJ/(mol\\cdot K)}$，因此 $\\beta$ 的单位是 $(\\mathrm{kJ/mol})^{-1}$。$r$ 的网格必须是均匀的，其中 $r_\\mathrm{min} = 0.05$ $\\mathrm{nm}$，$r_\\mathrm{max} = 1.50$ $\\mathrm{nm}$，以及 bin 宽度 $\\Delta r = 0.01$ $\\mathrm{nm}$。\n\n2. 对于每个窗口 $i$ 和以 $r_j$ 为中心的每个 bin，使用与 $4\\pi r_j^2 \\exp\\big(-\\beta\\big(G_\\mathrm{true}(r_j) + U_i^\\mathrm{bias}(r_j)\\big)\\big)$ 成正比的偏置径向概率密度构建预期的偏置直方图计数，并在网格上进行归一化，使得窗口 $i$ 中的总计数等于指定的每个窗口的样本大小 $N_i$。\n\n3. 实现加权直方图分析方法 (WHAM)，以迭代方式从窗口直方图及其谐波偏置的集合中恢复网格上的全局无偏置概率密度 $\\hat{p}(r)$。不要使用任何快捷公式。从上述原理推导出更新规则：\n   - 无偏置分布必须与由偏置引起的重加权因子和窗口归一化因子的倒数加权的窗口直方图之和一致。\n   - 必须更新每个窗口的归一化常数，以便全局分布能够重新加权回到每个窗口的偏置系综归一化。\n\n   迭代直到窗口自由能收敛到一个严格的容差，使得两次迭代之间所有窗口归一化常数的最大变化（以能量单位计）小于 $10^{-10}$。\n\n4. 通过明确地并入 $4\\pi r^2$ 因子，将无偏置标量概率密度 $\\hat{p}(r)$ 转换为排除了雅可比项的 PMF $G(r)$。PMF 必须被平移，使其在体相区（bulk region，这里定义为高 $r$ 值的尾部）趋于零。使用 $r \\in [1.30, 1.50]$ $\\mathrm{nm}$ 的体相范围，并强制 $G(r)$ 在此范围内的平均值为零。\n\n5. 通过在结合区域 $[0, r_c]$ 上对结合常数进行积分，计算标准态结合自由能 $\\Delta G_\\mathrm{bind}^\\circ$：\n   - 计算径向结合常数 $K = \\int_0^{r_c} \\exp\\big(-\\beta G(r)\\big)\\,4\\pi r^2\\,dr$，单位为 $\\mathrm{nm}^3$。\n   - 使用 $1$ $\\mathrm{M}$ 浓度下的标准态体积 $V^\\circ = 1.66053906660$ $\\mathrm{nm}^3$ 将其转换为无量纲的标准态平衡常数：$K^\\circ = K / V^\\circ$。\n   - 报告结合自由能 $\\Delta G_\\mathrm{bind}^\\circ = -\\beta^{-1} \\ln K^\\circ$，单位为 $\\mathrm{kJ/mol}$。\n\n您的程序必须实现上述步骤，并为以下测试套件生成结果。对于每个案例，请使用指定的窗口集、底层 PMF 参数、每个窗口的计数以及结合区域截断值 $r_c$。在每个案例中，伞形窗口的中心 $r_i$ 按指定均匀分布，且力常数 $k_i$ 相同：\n\n- 测试用例 1 (一般情况)：\n  - 窗口中心：$r_i \\in \\{0.20, 0.30, 0.40, \\dots, 1.20\\}$ $\\mathrm{nm}$，步长 $0.10$ $\\mathrm{nm}$。\n  - 力常数：$k_i = 1200$ $\\mathrm{kJ/(mol\\cdot nm^2)}$。\n  - 每个窗口的计数：$N_i = 50000$。\n  - 底层 PMF 参数：$D = 10$ $\\mathrm{kJ/mol}$，$a = 15$ $\\mathrm{nm}^{-1}$，$r_0 = 0.30$ $\\mathrm{nm}$。\n  - 结合区域截断值：$r_c = 0.45$ $\\mathrm{nm}$。\n\n- 测试用例 2 (弱结合边缘情况)：\n  - 窗口中心：$r_i \\in \\{0.20, 0.30, 0.40, \\dots, 1.20\\}$ $\\mathrm{nm}$，步长 $0.10$ $\\mathrm{nm}$。\n  - 力常数：$k_i = 900$ $\\mathrm{kJ/(mol\\cdot nm^2)}$。\n  - 每个窗口的计数：$N_i = 30000$。\n  - 底层 PMF 参数：$D = 4$ $\\mathrm{kJ/mol}$，$a = 12$ $\\mathrm{nm}^{-1}$，$r_0 = 0.32$ $\\mathrm{nm}$。\n  - 结合区域截断值：$r_c = 0.45$ $\\mathrm{nm}$。\n\n- 测试用例 3 (强结合，更宽覆盖范围)：\n  - 窗口中心：$r_i \\in \\{0.15, 0.25, 0.35, \\dots, 1.35\\}$ $\\mathrm{nm}$，步长 $0.10$ $\\mathrm{nm}$。\n  - 力常数：$k_i = 1500$ $\\mathrm{kJ/(mol\\cdot nm^2)}$。\n  - 每个窗口的计数：$N_i = 60000$。\n  - 底层 PMF 参数：$D = 20$ $\\mathrm{kJ/mol}$，$a = 22$ $\\mathrm{nm}^{-1}$，$r_0 = 0.28$ $\\mathrm{nm}$。\n  - 结合区域截断值：$r_c = 0.40$ $\\mathrm{nm}$。\n\n角度单位在此不适用。所有能量以 $\\mathrm{kJ/mol}$ 表示，所有长度以 $\\mathrm{nm}$ 表示。您的程序必须生成一行输出，其中包含测试套件的三个结合自由能，形式为用方括号括起来的逗号分隔列表，每个值四舍五入到三位小数（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$）。",
            "solution": "目标是使用加权直方图分析方法 (WHAM) 从合成的伞形采样数据中计算平均力势 (PMF)，并随后计算标准态结合自由能。该过程包括几个步骤：生成合成的偏置直方图，应用 WHAM 算法恢复无偏置概率分布，将此分布转换为 PMF，最后对 PMF 进行积分以获得结合自由能。\n\n首先，我们建立理论框架。沿着一维反应坐标 $r$ 的 PMF（表示为 $G(r)$）通过 Boltzmann 关系与平衡概率密度 $P(r)$ 相关。对于三维空间中的径向坐标，体积元为 $4\\pi r^2 dr$，这在概率密度中引入了一个雅可比因子。找到系统分离距离在 $r$ 和 $r+dr$ 之间的概率 $P(r)dr$ 由以下公式给出：\n$$P(r) \\propto 4\\pi r^2 \\exp(-\\beta G(r))$$\n其中 $\\beta = 1/(k_\\mathrm{B} T)$，$k_\\mathrm{B}$ 是 Boltzmann 常数，$T$ 是绝对温度。这里定义的 PMF $G(r)$ 代表了自由能曲线，其中不包括由 $4\\pi r^2$ 项所捕捉的几何熵贡献。\n\n伞形采样通过在每个模拟窗口 $i$ 中添加一个偏置势（通常是谐波势）来增强对高能区域的采样。偏置势由 $U_i^\\mathrm{bias}(r) = \\frac{1}{2} k_i (r - r_i)^2$ 给出，其中 $k_i$ 是力常数，$r_i$ 是窗口 $i$ 的势能中心。在有偏置的模拟中，观测到的概率密度 $P_i^\\mathrm{bias}(r)$ 受此势能的调制：\n$$P_i^\\mathrm{bias}(r) \\propto 4\\pi r^2 \\exp(-\\beta [G(r) + U_i^\\mathrm{bias}(r)])$$\n\n加权直方图分析方法 (WHAM) 是一种稳健的统计技术，用于组合来自多个偏置模拟（窗口）的数据，以计算沿反应坐标的无偏置概率分布。它通过求解一组自洽方程来确定最佳组合。设 $N_{ij}$ 是从窗口 $i$ 在坐标 bin $j$ 中观测到的样本数，$N_i = \\sum_j N_{ij}$ 是窗口 $i$ 中的总样本数。WHAM 方程将处于 bin $j$ 中的无偏置概率 $P_j$ 与特定于窗口的自由能偏移量 $f_i$ 联系起来：\n$$\n\\begin{cases}\nP_j = \\left( \\sum_{k=1}^{M} N_{kj} \\right) \\left/ \\left( \\sum_{k=1}^{M} N_k \\exp(\\beta f_k) \\exp(-\\beta U_{kj}) \\right) \\right. \\\\\n\\exp(-\\beta f_i) = \\sum_{j=1}^{N_\\mathrm{bins}} P_j \\exp(-\\beta U_{ij})\n\\end{cases}\n$$\n此处，$M$ 是窗口数，$N_\\mathrm{bins}$ 是坐标 bin 的数量，$U_{ij} = U_i^\\mathrm{bias}(r_j)$ 是窗口 $i$ 的偏置势在 bin $j$ 中心处的值。概率 $P_j$ 的定义差一个全局归一化常数，通常被归一化以使 $\\sum_j P_j = 1$。自由能 $f_i$ 仅是相互定义的，因此通常将其中一个设置为零（例如 $f_1=0$）以获得唯一解。这些方程被迭代求解，直到 $f_i$ 的值收敛。\n\n算法流程如下：\n1.  **系统设置和数据生成**：\n    -   定义物理常数 $\\beta = 1/(k_\\mathrm{B}T)$ 和一个从 $r_\\mathrm{min}$ 到 $r_\\mathrm{max}$、bin 宽度为 $\\Delta r$ 的离散 $r$ 值网格 $r_j$。\n    -   对每个测试用例，真实的底层 PMF $G_\\mathrm{true}(r)$ 由一个 Morse 势定义：$G_\\mathrm{true}(r) = D(e^{-2a(r-r_0)} - 2e^{-a(r-r_0)})$。\n    -   对每个窗口 $i$，生成一个合成直方图 $N_{ij}$。bin $j$ 中的预期计数值与偏置概率密度成正比：$N_{ij} \\propto N_i \\cdot 4\\pi r_j^2 \\exp(-\\beta[G_\\mathrm{true}(r_j) + U_i^\\mathrm{bias}(r_j)])$。计数值被归一化，使得 $\\sum_j N_{ij} = N_i$。\n\n2.  **WHAM 迭代**：\n    -   初始化窗口自由能，例如，对所有 $i$ 设置 $f_i = 0$。\n    -   迭代直至任何 $f_i$ 的最大变化小于一个容差（$10^{-10}$）：\n      a. 使用当前的 $f_i$ 值计算所有 bin 的无偏置概率 $P_j$。这需要计算每个 bin $j$ 的分母项 $D_j = \\sum_{k=1}^M N_k \\exp(\\beta f_k - \\beta U_{kj})$，以及每个 bin 的总计数 $C_j = \\sum_{k=1}^M N_{kj}$。未归一化的概率则为 $\\tilde{P}_j = C_j / D_j$。最后，进行归一化使得 $\\sum_j P_j = 1$。\n      b. 使用更新后的概率 $P_j$ 计算一组新的自由能 $f_i^\\mathrm{new}$：$f_i^\\mathrm{new} = -\\beta^{-1} \\ln\\left(\\sum_j P_j \\exp(-\\beta U_{ij})\\right)$。\n      c. 为防止数值漂移，平移新的自由能，例如，通过减去第一个自由能的值：$f_i^\\mathrm{new} \\leftarrow f_i^\\mathrm{new} - f_i^\\mathrm{new}[0]$。\n      d. 更新 $f_i \\leftarrow f_i^\\mathrm{new}$ 并检查收敛性。\n\n3.  **PMF 重建**：\n    -   一旦获得收敛的无偏置概率 $P_j$，就可以计算 PMF $G(r_j)$。从 $P_j \\propto 4\\pi r_j^2 \\exp(-\\beta G(r_j))$，我们可以写出 $G(r_j) = -\\beta^{-1} \\ln(P_j/r_j^2) + \\text{constant}$。对于 $P_j=0$ 的 bin，$G(r_j)$ 是无穷大。\n    -   PMF 通过一个加性常数进行平移，使其在体相区（定义为 $r \\in [1.30, 1.50]$ nm）的平均值为零。这将参考态设置为未结合态。\n\n4.  **结合自由能计算**：\n    -   标准态结合自由能 $\\Delta G_\\mathrm{bind}^\\circ$ 是由结合常数 $K$ 决定的。径向结合常数在定义的结合体积上进行积分：\n      $$K = \\int_0^{r_c} 4\\pi r^2 \\exp(-\\beta G(r)) dr$$\n      该积分通过对截至截断值 $r_c$ 的网格 bin 求和来进行数值近似：$K \\approx \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\exp(-\\beta G(r_j)) \\Delta r$。\n    -   标准态平衡常数 $K^\\circ$ 是通过除以标准态体积 $V^\\circ = 1.66053906660$ $\\mathrm{nm}^3$（相当于 $1$ M 标准浓度）得到的：$K^\\circ = K/V^\\circ$。\n    -   最后，结合自由能计算如下：\n      $$\\Delta G_\\mathrm{bind}^\\circ = -k_\\mathrm{B} T \\ln(K^\\circ) = -\\beta^{-1} \\ln(K^\\circ)$$\n\n整个协议对所提供的三个测试用例中的每一个都进行了实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the standard-state binding free energy for three test cases using WHAM.\n    \"\"\"\n\n    # --- Global Parameters and Constants ---\n    T = 300.0  # Temperature in K\n    K_B = 0.008314462618  # Boltzmann constant in kJ/(mol*K)\n    BETA = 1.0 / (K_B * T)  # In (kJ/mol)^-1\n    V_STANDARD = 1.66053906660  # Standard state volume in nm^3 (for 1 M)\n\n    # --- Grid setup ---\n    R_MIN = 0.05  # nm\n    R_MAX = 1.50  # nm\n    DR = 0.01  # nm\n    r_grid = np.arange(R_MIN, R_MAX + DR / 2.0, DR)\n    num_bins = len(r_grid)\n\n    # --- Bulk region definition for PMF shifting ---\n    BULK_MIN = 1.30\n    BULK_MAX = 1.50\n\n    # --- WHAM convergence criterion ---\n    WHAM_TOLERANCE = 1e-10\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"window_centers\": np.arange(0.20, 1.20 + 0.05, 0.10),\n            \"k\": 1200.0,\n            \"N_i\": 50000,\n            \"D\": 10.0,\n            \"a\": 15.0,\n            \"r0\": 0.30,\n            \"rc\": 0.45,\n        },\n        # Test Case 2\n        {\n            \"window_centers\": np.arange(0.20, 1.20 + 0.05, 0.10),\n            \"k\": 900.0,\n            \"N_i\": 30000,\n            \"D\": 4.0,\n            \"a\": 12.0,\n            \"r0\": 0.32,\n            \"rc\": 0.45,\n        },\n        # Test Case 3\n        {\n            \"window_centers\": np.arange(0.15, 1.35 + 0.05, 0.10),\n            \"k\": 1500.0,\n            \"N_i\": 60000,\n            \"D\": 20.0,\n            \"a\": 22.0,\n            \"r0\": 0.28,\n            \"rc\": 0.40,\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        window_centers = case[\"window_centers\"]\n        k = case[\"k\"]\n        N_i_val = case[\"N_i\"]\n        D = case[\"D\"]\n        a = case[\"a\"]\n        r0 = case[\"r0\"]\n        rc = case[\"rc\"]\n\n        num_windows = len(window_centers)\n        \n        # --- 1. Construct Synthetic Histograms ---\n        \n        # True PMF (Morse potential)\n        g_true = D * (np.exp(-2 * a * (r_grid - r0)) - 2 * np.exp(-a * (r_grid - r0)))\n        \n        histograms = np.zeros((num_windows, num_bins))\n        biases_matrix = np.zeros((num_windows, num_bins))\n        N_i_array = np.full(num_windows, N_i_val, dtype=float)\n\n        for i in range(num_windows):\n            r_center = window_centers[i]\n            # Harmonic bias potential for window i\n            u_bias = 0.5 * k * (r_grid - r_center)**2\n            biases_matrix[i, :] = u_bias\n            \n            # Biased energy\n            biased_energy = g_true + u_bias\n            \n            # Biased probability distribution including Jacobian\n            # Prop to 4*pi*r^2 * exp(-beta * E_biased)\n            unnorm_prob = (4 * np.pi * r_grid**2) * np.exp(-BETA * biased_energy)\n            \n            # Normalize probability for this window\n            norm_factor = np.sum(unnorm_prob)\n            if norm_factor == 0:\n                # This case shouldn't happen with the given parameters\n                # but good practice to handle.\n                norm_prob = np.zeros_like(unnorm_prob)\n            else:\n                norm_prob = unnorm_prob / norm_factor\n\n            # Generate histogram counts\n            histograms[i, :] = N_i_val * norm_prob\n            \n        # --- 3. Implement WHAM ---\n        f_i = np.zeros(num_windows)  # Initialize window free energies\n        \n        # Pre-compute terms that don't change in the loop\n        total_counts_per_bin = np.sum(histograms, axis=0) # Numerator of P_j\n        exp_minus_beta_U = np.exp(-BETA * biases_matrix) # exp(-beta*U_ij)\n        \n        for iteration in range(10000): # Max iterations to prevent infinite loop\n            f_old = f_i.copy()\n            \n            # Denominator of P_j\n            exp_beta_f = np.exp(BETA * f_i)\n            weighted_N = N_i_array * exp_beta_f\n            \n            # Sum over windows k for each bin j\n            den_P = weighted_N @ exp_minus_beta_U\n            \n            with np.errstate(divide='ignore', invalid='ignore'):\n                P_unnormalized = total_counts_per_bin / den_P\n            \n            P_unnormalized[np.isnan(P_unnormalized)] = 0.0\n\n            # Normalize probabilities\n            P = P_unnormalized / np.sum(P_unnormalized)\n            \n            # Update free energies f_i\n            with np.errstate(divide='ignore'):\n              log_arg = P @ exp_minus_beta_U.T\n            \n            f_new = -1.0 / BETA * np.log(log_arg)\n            f_new[np.isinf(f_new)] = f_i[np.isinf(f_new)] # Keep old if log_arg is 0\n\n            # Shift to prevent drift\n            f_new -= f_new[0]\n            f_i = f_new\n\n            # Check for convergence\n            max_change = np.max(np.abs(f_i - f_old))\n            if max_change < WHAM_TOLERANCE:\n                break\n        \n        # --- 4. Convert Probability to PMF and Shift ---\n        with np.errstate(divide='ignore'):\n             # G = -k_B*T * (ln(P) - ln(4*pi*r^2*dr))\n             # The constant term ln(4*pi*dr) will be absorbed into the shifting constant\n             G = -1.0 / BETA * (np.log(P) - 2.0 * np.log(r_grid))\n\n        G[np.isneginf(G)] = np.inf # Bins with P=0 have infinite free energy\n        \n        # Shift PMF so bulk region (high r) is zero\n        bulk_mask = (r_grid >= BULK_MIN) & (r_grid <= BULK_MAX)\n        G_bulk = G[bulk_mask]\n        \n        finite_G_bulk = G_bulk[np.isfinite(G_bulk)]\n        if len(finite_G_bulk) > 0:\n            shift = np.mean(finite_G_bulk)\n            G -= shift\n        \n        # --- 5. Compute Standard-State Binding Free Energy ---\n        bound_mask = r_grid <= rc\n        \n        # Integrand for association constant K\n        integrand = np.exp(-BETA * G) * (4 * np.pi * r_grid**2)\n        \n        # Numerical integration (sum over bins)\n        K = np.sum(integrand[bound_mask]) * DR\n\n        # Standard-state equilibrium constant and free energy\n        if K > 0 and V_STANDARD > 0:\n            K_standard = K / V_STANDARD\n            delta_G_bind = -1.0 / BETA * np.log(K_standard)\n        else:\n            delta_G_bind = np.inf # Should not happen\n\n        results.append(round(delta_G_bind, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "反应坐标并不仅限于简单的距离；许多生物过程，如蛋白质构象变化，都涉及周期性坐标，例如二面角。本练习专注于处理这类周期性系统，你将学习如何通过使用环形统计学和恰当的数学工具来正确实现加权直方图分析方法（WHAM），以避免在周期性边界处产生人为的间断。通过这个实践，你将掌握处理更复杂分子几何的PMF计算的关键技术。",
            "id": "3838305",
            "problem": "你必须编写一个完整、可运行的程序，使用从第一性原理推导并利用循环统计学实现以强制跨边界连续性的加权直方图分析方法（WHAM），重构周期性坐标的平均力势（PMF）。将反应坐标视为圆上的角度 $z$，定义域为 $[0,2\\pi)$，并使用弧度作为角度单位。所有能量必须以 $k_\\mathrm{B}T$ 为单位表示，所有报告的数值答案必须是无量纲的浮点数。\n\n从以下统计力学和概率论的基础出发：\n- 具有自由能 $F(z)$ 的状态的玻尔兹曼分布，其概率密度 $P(z)$ 正比于 $\\exp\\!\\left(-F(z)/(k_\\mathrm{B}T)\\right)$。\n- 当施加谐波伞形偏置时，每个偏置分布正比于无偏置概率密度乘以偏置的玻尔兹曼因子。\n- PMF 通过 $F(z) = -k_\\mathrm{B}T \\ln P(z) + C$ 与归一化概率密度相关，其中 $C$ 是一个不影响物理预测的加性常数。\n\n基于这些原理推导并实现 WHAM，不使用此处给出的任何快捷公式，以最佳方式将多个偏置直方图组合成一个在覆盖整个圆周的离散化区间（bin）上的无偏置 $P(z)$ 的估计。确保：\n- 坐标 $z$ 是周期性的，周期为 $2\\pi$，并且你的离散化使用 $B$ 个区间，其中心均匀分布在 $[0,2\\pi)$ 上。\n- 圆上的距离计算为在 $[-\\pi,\\pi)$ 内的缠绕角差。\n- 在执行任何邻域、平滑或卷积操作时，通过将区间索引模 $B$ 处理来强制实现跨边界的连续性。\n- 应用循环统计学，通过使用浓度参数为 $\\kappa$ 的冯·米塞斯循环核对估计的 $P(z)$ 进行平滑，以避免在 $z=0$ 和 $z=2\\pi$ 处产生人为的不连续性。该平滑作为循环卷积实现，并进行归一化以保持总概率不变。\n\n通过以下步骤确定性地（无随机性）构建合成的伞形抽样直方图：\n1. 定义一个物理上合理的潜在真实 PMF $F_{\\mathrm{true}}(z)$ 和相应的归一化无偏置密度 $P_{\\mathrm{true}}(z)$。\n2. 对于每个中心为 $c_i$、谐波劲度系数为 $k_i$（单位为 $k_\\mathrm{B}T$/rad$^2$）和样本量为 $N_i$ 的伞形窗口，定义偏置势 $U_i(z) = \\tfrac{1}{2} k_i\\,\\Delta(z,c_i)^2$，其中 $\\Delta(z,c_i)$ 是缠绕角差。\n3. 计算每个窗口的偏置概率密度，该密度正比于 $\\exp\\!\\left(-\\left[F_{\\mathrm{true}}(z) + U_i(z)\\right]/(k_\\mathrm{B}T)\\right)$ 并在圆上进行归一化，然后确定性地将每个区间的直方图计数赋值为 $n_i(b) = N_i$ 乘以区间 $b$ 中的归一化偏置概率质量。\n\n实现 WHAM 以从 $\\{n_i(b)\\}$ 和 $\\{U_i(z_b)\\}$ 中恢复无偏置的 $P(z)$，确保在圆上进行正确的归一化。收敛后，计算 PMF $F(z) = -k_\\mathrm{B}T \\ln P(z) + C$ 并设置加性常数 $C$ 以使得 $\\min_z F(z) = 0$。在转换为 $F(z)$ 之前，对 $P(z)$ 应用冯·米塞斯循环平滑，以避免人为的不连续性。\n\n你的程序必须为指定的测试套件计算以下指标，并将它们作为包含 Python 风格浮点数列表的单行输出：\n- 对于前两个测试用例，计算边界连续性指标 $\\delta_F$，定义为第一个和最后一个区间的平滑 PMF 之间的绝对差：$\\delta_F = \\left|F(z_0) - F(z_{B-1})\\right|$，以 $k_\\mathrm{B}T$ 为单位报告。\n- 对于第三个测试用例，计算旋转不变性误差 $E_{\\mathrm{rot}}$，定义为来自旋转窗口的平滑 PMF（通过对区间进行精确的循环移位，将其对齐回原始坐标系）与来自未旋转窗口的平滑 PMF 之间的最大绝对差，以 $k_\\mathrm{B}T$ 为单位报告。\n\n角度单位规范：所有角度必须以弧度为单位。能量单位规范：所有能量和输出必须以 $k_\\mathrm{B}T$ 为单位表示。\n\n离散化和合成模型：\n- 在 $[0,2\\pi)$ 上使用 $B = 420$ 个区间，区间中心为 $z_b = \\frac{2\\pi}{B} \\left(b + \\tfrac{1}{2}\\right)$，其中 $b = 0,1,\\dots,B-1$。\n- 定义真实 PMF 为 $F_{\\mathrm{true}}(z) = A \\cos(2z) - B_0 \\cos(z)$，其中 $A = 1.5$ 且 $B_0 = 0.5$，两者单位均为 $k_\\mathrm{B}T$。定义 $P_{\\mathrm{true}}(z) \\propto \\exp\\!\\left(-F_{\\mathrm{true}}(z)/(k_\\mathrm{B}T)\\right)$ 并在圆上进行归一化。\n- 使用浓度参数为 $\\kappa = 20$ 的冯·米塞斯核对 $P(z)$ 进行循环平滑，实现为在 $B$ 个区间上的循环卷积。对核进行归一化，以使平滑后的密度保持归一化。\n\n测试套件：\n1. 理想路径覆盖：\n   - 窗口数量 $M = 8$，中心 $c_i$ 均匀分布：$c_i = \\frac{2\\pi i}{M}$，其中 $i = 0,1,\\dots,7$。\n   - 所有 $i$ 的劲度系数 $k_i = 20$。\n   - 所有 $i$ 的样本量 $N_i = 50{,}000$。\n2. 稀疏边界覆盖：\n   - 窗口数量 $M = 3$，中心为 $c = \\left[\\tfrac{\\pi}{2}, \\pi, \\tfrac{3\\pi}{2}\\right]$。\n   - 所有 $i$ 的劲度系数 $k_i = 25$。\n   - 所有 $i$ 的样本量 $N_i = 10{,}000$。\n3. 旋转不变性：\n   - 使用与测试 1 相同的配置，但将所有中心旋转 $\\delta = \\tfrac{2\\pi}{7}$，即 $c_i^\\prime = c_i + \\delta$ (mod $2\\pi$)。\n   - 计算旋转情况下的平滑 PMF，并通过对区间进行 $s = \\delta/\\Delta z$ 的精确循环移位来进行对齐，其中 $\\Delta z = \\tfrac{2\\pi}{B}$，因此 $s = 60$。\n   - 报告对齐后的旋转 PMF 与来自测试 1 的原始 PMF 之间的最大绝对差 $E_{\\mathrm{rot}}$。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序包含三个测试用例的结果：$\\left[\\delta_F^{(1)}, \\delta_F^{(2)}, E_{\\mathrm{rot}}^{(3)}\\right]$。",
            "solution": "用户提供了一个在计算化学生物学领域内定义明确且具有科学依据的问题。任务是为周期性反应坐标实现加权直方图分析方法（WHAM），从第一性原理推导该方法，并将其应用于一组指定的测试用例。实现必须使用适当的统计和数值技术正确处理坐标的循环特性。\n\n### WHAM 方程的推导\n\nWHAM 的目标是从多个偏置模拟中获得的样本集合中，找到无偏置概率分布 $P(z)$ 的最佳估计。我们将反应坐标 $z \\in [0, 2\\pi)$ 离散化为 $B$ 个区间。设 $P_j$ 为在无偏置状态下，系统处于区间 $j$ 的未知概率质量。根据定义，$\\sum_{j=1}^{B} P_j = 1$。\n\n我们有一组 $M$ 个模拟，或称“窗口”。对于每个模拟 $i \\in \\{1, \\dots, M\\}$，我们有一个偏置势 $U_i(z)$ 和总共 $N_i$ 个采集的样本。观测数据是直方图 $\\{n_{ij}\\}$，其中 $n_{ij}$ 是来自模拟 $i$ 且落入区间 $j$ 的样本数量。在所有模拟中，区间 $j$ 的总样本数为 $n_j = \\sum_{i=1}^{M} n_{ij}$。所有能量，包括偏置势 $U_{ij} \\equiv U_i(z_j)$，都以 $k_\\mathrm{B}T$ 为单位表示。\n\n根据统计力学，在偏置模拟中，一个状态的概率密度是无偏置概率密度与偏置势的玻尔兹曼因子的乘积。对于我们的离散化系统，给定样本来自模拟 $i$ 的条件下，在区间 $j$ 中观测到该样本的概率是：\n$$\nP(j|i) = \\frac{P_j \\exp(-U_{ij})}{\\sum_{k=1}^{B} P_k \\exp(-U_{ik})}\n$$\n分母是第 $i$ 次偏置模拟的配分函数。我们可以用每个窗口的无量纲自由能偏移量 $f_i$ 来表示它：\n$$\n\\exp(-f_i) = \\sum_{k=1}^{B} P_k \\exp(-U_{ik})\n$$\n这给了我们第一个核心 WHAM 方程，它将未知概率集 $\\{P_k\\}$ 与未知窗口自由能集 $\\{f_i\\}$ 联系起来：\n$$\nf_i = -\\ln \\left( \\sum_{k=1}^{B} P_k \\exp(-U_{ik}) \\right)\n\\quad \\quad \\text{(方程 1)}\n$$\n为了找到 $\\{P_j\\}$ 的最佳估计，我们最大化观测到所有直方图集合 $\\{n_{ij}\\}$ 的总对数似然。似然函数是每个模拟的多项式概率的乘积。对数似然 $\\ln \\mathcal{L}$ 由下式给出：\n$$\n\\ln \\mathcal{L}(\\{P_j\\} | \\{n_{ij}\\}) = \\sum_{i=1}^{M} \\sum_{j=1}^{B} n_{ij} \\ln P(j|i) + \\text{常数}\n$$\n代入 $P(j|i) = P_j \\exp(-U_{ij}) \\exp(f_i)$ 并使用 $f_i$ 的定义：\n$$\n\\ln \\mathcal{L} = \\sum_{i=1}^{M} \\sum_{j=1}^{B} n_{ij} (\\ln P_j - U_{ij} + f_i) = \\sum_{i,j} n_{ij} \\ln P_j - \\sum_{i,j} n_{ij} U_{ij} + \\sum_i N_i f_i\n$$\n代入方程 1 中的 $f_i$：\n$$\n\\ln \\mathcal{L} = \\sum_{j=1}^{B} \\left(\\sum_{i=1}^{M} n_{ij}\\right) \\ln P_j - \\sum_{i=1}^{M} N_i \\ln \\left( \\sum_{k=1}^{B} P_k \\exp(-U_{ik}) \\right) + \\text{常数}\n$$\n我们使用拉格朗日乘子法，在归一化约束 $\\sum_j P_j = 1$ 的条件下，对该函数关于每个 $P_j$ 进行最大化。对 $P_j$ 求导并将结果设为零，得到：\n$$\n\\frac{\\partial}{\\partial P_j} \\left[ \\ln \\mathcal{L} - \\lambda \\left(\\sum_k P_k - 1\\right) \\right] = \\frac{\\sum_i n_{ij}}{P_j} - \\sum_{i=1}^{M} N_i \\frac{\\exp(-U_{ij})}{\\sum_k P_k \\exp(-U_{ik})} - \\lambda = 0\n$$\n使用 $f_i$ 的定义，这可以简化为：\n$$\n\\frac{\\sum_i n_{ij}}{P_j} = \\sum_{i=1}^{M} N_i \\exp(f_i - U_{ij}) + \\lambda\n$$\n拉格朗日乘子 $\\lambda$ 可以被吸收到自由能 $f_i$ 的定义中，因为自由能仅在相差一个加性常数的情况下是确定的。遵循标准的 WHAM 推导，我们设 $\\lambda=0$ 并解出 $P_j$：\n$$\nP_j = \\frac{\\sum_{i=1}^{M} n_{ij}}{\\sum_{k=1}^{M} N_k \\exp(f_k - U_{kj})}\n\\quad \\quad \\text{(方程 2)}\n$$\n方程 1 和 2 构成了一组关于 $\\{P_j\\}$ 和 $\\{f_i\\}$ 的自洽方程。它们通过迭代求解：\n1.  初始化自由能 $\\{f_i\\}$，例如，对所有 $i$ 设 $f_i = 0$。\n2.  使用方程 2 计算概率分布 $\\{P_j\\}$。\n3.  归一化 $\\{P_j\\}$，使得 $\\sum_j P_j = 1$。\n4.  使用方程 1 计算新的自由能 $\\{f_i\\}$。\n5.  通过一个加性常数平移 $\\{f_i\\}$ 向量（例如，设 $f_1=0$）以防止数值漂移。\n6.  重复步骤 2-5，直到 $\\{f_i\\}$ 的值收敛。\n\n### 周期性坐标的实现\n\n对于循环反应坐标 $z$，需要特殊考虑以强制实现周期性和连续性。\n- **角距离**：谐波偏置势 $U_i(z) = \\frac{1}{2} k_i \\Delta(z,c_i)^2$ 中使用的距离 $\\Delta(z,c_i)$ 必须是圆上的最短弧长距离。这被计算为缠绕角差，其值在 $[-\\pi, \\pi)$ 内。\n- **循环平滑**：从 WHAM 获得的原始概率分布 $P_j$ 可能带有噪声。为获得平滑且具有物理意义的 PMF，$P_j$ 需要被平滑处理。对于周期性变量，这通过与周期性核进行循环卷积来正确实现。问题指定了冯·米塞斯核，它是正态分布的一个循环模拟。对于具有 $B$ 个区间的离散化坐标，中心在区间 0 的核形式为 $K_b \\propto \\exp(\\kappa \\cos(2\\pi b/B))$，其中 $b=0,...,B-1$。概率向量 $P$ 与核向量 $K$ 的卷积最有效的方法是使用快速傅里叶变换（FFT）的卷积定理：$P_{\\text{smooth}} = \\text{IFFT}(\\text{FFT}(P) \\cdot \\text{FFT}(K))$。离散傅里叶变换的内在周期性正确地处理了循环边界条件。\n\n### 从概率到 PMF\n\n平均力势（PMF）$F(z)$ 通过 $F(z) = -k_\\mathrm{B}T \\ln p(z) + C$ 与概率密度 $p(z)$ 相关。在我们的离散化系统中，区间中心 $z_j$ 处的概率密度为 $p(z_j) = P_j / \\Delta z$，其中 $P_j$ 是该区间的概率质量，$\\Delta z = 2\\pi/B$ 是区间宽度。因此，\n$$\nF(z_j) = -k_\\mathrm{B}T \\ln\\left(\\frac{P_j^{\\text{smooth}}}{\\Delta z}\\right) = -k_\\mathrm{B}T \\ln P_j^{\\text{smooth}} + k_\\mathrm{B}T \\ln(\\Delta z)\n$$\n由于所有能量都以 $k_\\mathrm{B}T$ 为单位，我们设 $k_\\mathrm{B}T=1$。项 $\\ln(\\Delta z)$ 是一个常数，被吸收到任意加性常数 $C$ 中。最终的 PMF 计算为 $F_j = -\\ln(P_j^{\\text{smooth}})$，然后通过减去其最小值进行平移，使得 $\\min_j F_j = 0$。\n\n### 合成数据与测试用例\n\n程序首先基于已知的真实 PMF $F_{\\mathrm{true}}(z) = 1.5 \\cos(2z) - 0.5 \\cos(z)$ 生成确定性的合成直方图数据。对于每个模拟窗口 $i$，计算偏置概率分布，并用其填充直方图计数 $n_{ij} = N_i \\times P(j|i)$。然后将 WHAM 算法应用于这些合成数据以恢复 PMF。计算指定的指标，即边界连续性 $\\delta_F$ 和旋转不变性误差 $E_{\\mathrm{rot}}$，以验证实现的正确性和鲁棒性，特别是其对周期性的处理。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft\n\ndef solve():\n    \"\"\"\n    Main function to run the WHAM analysis for the specified test cases.\n    \"\"\"\n    # Define problem constants\n    BINS = 420\n    TRUE_PMF_A = 1.5\n    TRUE_PMF_B0 = 0.5\n    VON_MISES_KAPPA = 20.0\n    KBT = 1.0  # All energies are in units of k_B*T\n\n    def wrapped_dist(z1, z2):\n        \"\"\"Computes the wrapped angular distance z1 - z2, mapping to [-pi, pi).\"\"\"\n        dist = z1 - z2\n        return (dist + np.pi) % (2 * np.pi) - np.pi\n\n    def generate_synthetic_data(num_bins, centers, stiffnesses, sample_sizes):\n        \"\"\"Generates synthetic deterministic histogram data for umbrella sampling.\"\"\"\n        z_b = (2 * np.pi / num_bins) * (np.arange(num_bins) + 0.5)\n\n        # 1. Define true PMF and corresponding probability mass distribution\n        F_true = TRUE_PMF_A * np.cos(2 * z_b) - TRUE_PMF_B0 * np.cos(z_b)\n        P_true_unnorm = np.exp(-F_true / KBT)\n        P_true_mass = P_true_unnorm / np.sum(P_true_unnorm)\n\n        num_windows = len(centers)\n        n_ij = np.zeros((num_windows, num_bins))\n        U_ij = np.zeros((num_windows, num_bins))\n\n        for i in range(num_windows):\n            # 2. Define bias potential for the window\n            U_ij[i, :] = 0.5 * stiffnesses[i] * wrapped_dist(z_b, centers[i])**2\n\n            # 3. Compute the biased probability distribution\n            P_biased_unnorm = P_true_mass * np.exp(-U_ij[i, :] / KBT)\n            P_biased_mass = P_biased_unnorm / np.sum(P_biased_unnorm)\n\n            # 4. Deterministically assign histogram counts for the window\n            n_ij[i, :] = sample_sizes[i] * P_biased_mass\n\n        return n_ij, U_ij\n\n    def solve_wham(n_ij, U_ij):\n        \"\"\"Solves the self-consistent WHAM equations.\"\"\"\n        num_windows, num_bins = n_ij.shape\n        N_i = n_ij.sum(axis=1)\n        \n        # Initial guess for window free energies\n        f_i = np.zeros(num_windows)\n        \n        max_iter = 10000\n        tolerance = 1e-12\n        \n        for _ in range(max_iter):\n            f_i_old = np.copy(f_i)\n            \n            # Equation 2: Update probability distribution P_j\n            sum_n_j = np.sum(n_ij, axis=0)\n            denominator_P = np.sum(N_i[:, np.newaxis] * np.exp((f_i[:, np.newaxis] - U_ij) / KBT), axis=0)\n            P_j = sum_n_j / denominator_P\n            P_j /= np.sum(P_j)  # Normalize probability mass\n\n            # Equation 1: Update free energies f_i\n            sum_term = np.sum(P_j[np.newaxis, :] * np.exp(-U_ij / KBT), axis=1)\n            # Add a small epsilon to prevent log(0) in case of no overlap, though unlikely here.\n            f_i = -KBT * np.log(sum_term + 1e-100)\n            \n            # Shift free energies to prevent numerical drift (f_0 = 0)\n            f_i -= f_i[0]\n            \n            # Check for convergence\n            diff = np.max(np.abs(f_i - f_i_old))\n            if diff < tolerance:\n                break\n        \n        return P_j\n\n    def smooth_and_get_pmf(P_j, num_bins, kappa):\n        \"\"\"Smooths probability distribution with a Von Mises kernel and computes the PMF.\"\"\"\n        \n        # 1. Define Von Mises kernel for circular convolution\n        b_indices = np.arange(num_bins)\n        kernel = np.exp(kappa * np.cos(2 * np.pi * b_indices / num_bins))\n        kernel /= np.sum(kernel) # Normalize kernel\n\n        # 2. Perform circular convolution using FFT\n        P_fft = fft(P_j)\n        kernel_fft = fft(kernel)\n        P_smooth_fft = P_fft * kernel_fft\n        P_smooth_j = np.real(ifft(P_smooth_fft))\n        P_smooth_j /= np.sum(P_smooth_j) # Re-normalize after FFT\n\n        # 3. Calculate PMF from smoothed probability mass\n        # The conversion from mass to density adds a constant log(delta_z)\n        # which is absorbed when shifting the minimum to zero.\n        pmf = -KBT * np.log(P_smooth_j + 1e-100) # Add epsilon to avoid log(0)\n        pmf -= np.min(pmf) # Shift PMF so that min is 0\n        \n        return pmf\n\n    def run_case(centers, stiffnesses, samples, kappa, num_bins):\n        \"\"\"Helper func to run one full WHAM calculation.\"\"\"\n        n_ij, U_ij = generate_synthetic_data(num_bins, centers, stiffnesses, samples)\n        P_j = solve_wham(n_ij, U_ij)\n        pmf = smooth_and_get_pmf(P_j, num_bins, kappa)\n        return pmf\n\n    results = []\n\n    # Test Case 1: Happy path coverage\n    M1 = 8\n    centers1 = (2 * np.pi / M1) * np.arange(M1)\n    stiffnesses1 = np.full(M1, 20.0)\n    samples1 = np.full(M1, 50000)\n    pmf_1 = run_case(centers1, stiffnesses1, samples1, VON_MISES_KAPPA, BINS)\n    delta_F_1 = np.abs(pmf_1[-1] - pmf_1[0])\n    results.append(delta_F_1)\n\n    # Test Case 2: Sparse boundary coverage\n    M2 = 3\n    centers2 = np.array([np.pi/2.0, np.pi, 3.0*np.pi/2.0])\n    stiffnesses2 = np.full(M2, 25.0)\n    samples2 = np.full(M2, 10000)\n    pmf_2 = run_case(centers2, stiffnesses2, samples2, VON_MISES_KAPPA, BINS)\n    delta_F_2 = np.abs(pmf_2[-1] - pmf_2[0])\n    results.append(delta_F_2)\n\n    # Test Case 3: Rotation invariance\n    # The original PMF is pmf_1 from test case 1.\n    delta_rot = 2 * np.pi / 7\n    centers3 = (centers1 + delta_rot) % (2 * np.pi)\n    s_shift = 60 # Shift in bins corresponding to delta_rot (420/7)\n    \n    # Run WHAM on rotated configuration\n    pmf_3_rot = run_case(centers3, stiffnesses1, samples1, VON_MISES_KAPPA, BINS)\n    \n    # Align the rotated PMF back to the original frame by a circular shift\n    # A positive rotation of centers moves features to higher indices.\n    # To align back, we need to shift the PMF data to lower indices (negative roll).\n    pmf_3_aligned = np.roll(pmf_3_rot, -s_shift)\n    \n    # Calculate the max absolute error between original and aligned-rotated PMF\n    E_rot = np.max(np.abs(pmf_3_aligned - pmf_1))\n    results.append(E_rot)\n\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}