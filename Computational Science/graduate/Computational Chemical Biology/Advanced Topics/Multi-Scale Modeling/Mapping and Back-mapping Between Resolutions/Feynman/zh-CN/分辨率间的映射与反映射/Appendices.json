{
    "hands_on_practices": [
        {
            "introduction": "在多尺度模拟中，反向映射（back-mapping）的核心挑战在于从低分辨率的粗粒化（CG）构象中重建出高分辨率的全原子（AA）结构。这个问题可以被形式化为一个优化问题。本练习将指导您推导一个典型的惩罚函数（penalty function）的梯度和Hessian矩阵，该函数旨在平衡粗粒化坐标的匹配度和化学结构的合理性。通过这个练习，您将掌握基于优化的反向映射方法背后的核心数学原理，并为理解和开发更复杂的算法打下坚实基础。",
            "id": "3852006",
            "problem": "在计算化学生物学中，一个从粗粒度到原子级的反向映射旨在寻找原子坐标 $x \\in \\mathbb{R}^{3N}$，使其映射后的粗粒度可观测量与目标 $y \\in \\mathbb{R}^{m}$ 相匹配，其中 $m$ 是粗粒度维度（例如，珠子位置或其他低维描述符）。令 $M:\\mathbb{R}^{3N} \\to \\mathbb{R}^{m}$ 表示一个从原子坐标到粗粒度可观测量​​的可微映射。考虑惩罚函数\n$$\n\\Phi(x) \\;=\\; \\| y - M(x) \\|^{2} \\;+\\; \\lambda \\, C(x),\n$$\n其中 $C:\\mathbb{R}^{3N} \\to \\mathbb{R}$ 是一个可微约束泛函，用于惩罚与化学上有意义的结构（例如，键长、键角或二面角与参考值的平方偏差之和）的偏离，而 $\\lambda > 0$ 是一个标量正则化权重。定义残差向量 $r(x) = y - M(x)$，雅可比矩阵 $J_{M}(x) = \\frac{\\partial M(x)}{\\partial x} \\in \\mathbb{R}^{m \\times 3N}$，并且对于每个分量 $M_{i}(x)$，令 $\\nabla M_{i}(x) \\in \\mathbb{R}^{3N}$ 和 $\\nabla^{2} M_{i}(x) \\in \\mathbb{R}^{3N \\times 3N}$ 分别为其梯度和海森矩阵。假设 $C(x)$ 是二次连续可微的，其梯度为 $\\nabla C(x)$，海森矩阵为 $\\nabla^{2} C(x)$。\n\n仅使用基本的多变量微积分（向量值函数的链式法则和乘法法则）和标准的线性代数定义（雅可比矩阵、梯度和海森矩阵），推导梯度 $\\nabla \\Phi(x)$ 和海森矩阵 $\\nabla^{2} \\Phi(x)$ 关于 $r(x)$、$J_{M}(x)$、$\\nabla^{2} M_{i}(x)$、$\\nabla C(x)$ 和 $\\nabla^{2} C(x)$ 的表达式。然后，将 Gauss–Newton 近似海森矩阵定义为 $H_{\\mathrm{GN}}(x) = 2 J_{M}(x)^{\\top} J_{M}(x) + \\lambda \\nabla^{2} C(x)$（通过在数据拟合部分忽略 $M$ 的二阶导数项得到），并分析应用 Newton 或 Gauss–Newton 步来最小化 $\\Phi(x)$ 时的数值稳定性条件。\n\n特别地，假设存在 $\\mu > 0$ 使得 $\\nabla^{2} C(x) \\succeq \\mu I$（即，在 Loewner 偏序下，约束的海森矩阵有下界 $\\mu I$），并令 $\\sigma_{\\min}(x)$ 表示 $J_{M}(x)$ 的最小奇异值。对于一个预设的曲率下限 $\\alpha > 0$，为确保 $H_{\\mathrm{GN}}(x)$ 的最小特征值至少为 $\\alpha$，确定能保证 $H_{\\mathrm{GN}}(x) \\succeq \\alpha I$ 的最小 $\\lambda$。\n\n你的最终答案必须是一个单一的复合解析表达式，包含如上推导的梯度、海森矩阵和最小 $\\lambda$，写成一个行矩阵。不需要进行数值计算。",
            "solution": "该问题要求推导惩罚函数 $\\Phi(x)$ 的梯度和海森矩阵，并分析基于海森矩阵的 Gauss-Newton 近似的优化步骤的数值稳定性条件。惩罚函数由下式给出：\n$$\n\\Phi(x) = \\| y - M(x) \\|^{2} + \\lambda \\, C(x)\n$$\n其中 $x \\in \\mathbb{R}^{3N}$ 是原子坐标，$y \\in \\mathbb{R}^{m}$ 是目标粗粒度可观测量，$M: \\mathbb{R}^{3N} \\to \\mathbb{R}^{m}$ 是一个可微映射，$C(x)$ 是一个可微约束泛函，而 $\\lambda > 0$ 是一个标量权重。我们定义残差向量 $r(x) = y - M(x)$。函数 $\\Phi(x)$可以写成：\n$$\n\\Phi(x) = r(x)^{\\top}r(x) + \\lambda \\, C(x)\n$$\n\n首先，我们推导 $\\Phi(x)$ 的梯度，记为 $\\nabla \\Phi(x) \\in \\mathbb{R}^{3N}$。梯度是偏导数的向量，$[\\nabla \\Phi(x)]_k = \\frac{\\partial \\Phi}{\\partial x_k}$。我们应用微分的求和法则：\n$$\n\\nabla \\Phi(x) = \\nabla(r(x)^{\\top}r(x)) + \\nabla(\\lambda C(x))\n$$\n第二项的梯度是直接的：\n$$\n\\nabla(\\lambda C(x)) = \\lambda \\nabla C(x)\n$$\n对于第一项，我们使用向量值函数的链式法则。令 $f(u) = u^{\\top}u$。$f$ 的梯度是 $\\nabla f(u) = 2u$。这里，$u = r(x)$。$r(x) = y - M(x)$ 关于 $x$ 的雅可比矩阵是 $J_r(x) = \\frac{\\partial r(x)}{\\partial x} = -\\frac{\\partial M(x)}{\\partial x} = -J_M(x)$。链式法则表明 $\\nabla(f(r(x))) = J_r(x)^{\\top} (\\nabla f)(r(x))$。应用此法则，我们得到：\n$$\n\\nabla(r(x)^{\\top}r(x)) = (-J_M(x))^{\\top} (2r(x)) = -2 J_M(x)^{\\top} r(x)\n$$\n结合这两个部分，$\\Phi(x)$ 的梯度是：\n$$\n\\nabla \\Phi(x) = -2 J_M(x)^{\\top} r(x) + \\lambda \\nabla C(x)\n$$\n\n其次，我们推导 $\\Phi(x)$ 的海森矩阵，记为 $\\nabla^2 \\Phi(x) \\in \\mathbb{R}^{3N \\times 3N}$。海森矩阵是二阶偏导数的矩阵，$[\\nabla^2 \\Phi(x)]_{jk} = \\frac{\\partial^2 \\Phi}{\\partial x_j \\partial x_k}$。我们对梯度分量的表达式进行微分。梯度的第 $k$ 个分量是：\n$$\n[\\nabla \\Phi(x)]_k = -2 \\sum_{i=1}^{m} [J_M(x)^{\\top}]_{ki} r_i(x) + \\lambda \\frac{\\partial C}{\\partial x_k} = -2 \\sum_{i=1}^{m} \\frac{\\partial M_i}{\\partial x_k} r_i(x) + \\lambda \\frac{\\partial C}{\\partial x_k}\n$$\n现在，我们对第一项使用乘法法则，对 $x_j$ 求导：\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x_j \\partial x_k} = \\frac{\\partial}{\\partial x_j} \\left( -2 \\sum_{i=1}^{m} \\frac{\\partial M_i}{\\partial x_k} r_i(x) + \\lambda \\frac{\\partial C}{\\partial x_k} \\right)\n$$\n$$\n= -2 \\sum_{i=1}^{m} \\left( \\frac{\\partial^2 M_i}{\\partial x_j \\partial x_k} r_i(x) + \\frac{\\partial M_i}{\\partial x_k} \\frac{\\partial r_i}{\\partial x_j} \\right) + \\lambda \\frac{\\partial^2 C}{\\partial x_j \\partial x_k}\n$$\n因为 $r_i(x) = y_i - M_i(x)$，我们有 $\\frac{\\partial r_i}{\\partial x_j} = -\\frac{\\partial M_i}{\\partial x_j}$。将此代入表达式：\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x_j \\partial x_k} = -2 \\sum_{i=1}^{m} \\left( \\frac{\\partial^2 M_i}{\\partial x_j \\partial x_k} r_i(x) - \\frac{\\partial M_i}{\\partial x_k} \\frac{\\partial M_i}{\\partial x_j} \\right) + \\lambda \\frac{\\partial^2 C}{\\partial x_j \\partial x_k}\n$$\n$$\n= 2 \\sum_{i=1}^{m} \\frac{\\partial M_i}{\\partial x_j} \\frac{\\partial M_i}{\\partial x_k} - 2 \\sum_{i=1}^{m} r_i(x) \\frac{\\partial^2 M_i}{\\partial x_j \\partial x_k} + \\lambda \\frac{\\partial^2 C}{\\partial x_j \\partial x_k}\n$$\n我们识别出这些项是矩阵的元素。第一项是 $2 J_M(x)^{\\top} J_M(x)$ 的第 $(j,k)$ 个元素。第二项是 $-2 \\sum_{i=1}^{m} r_i(x) \\nabla^2 M_i(x)$ 的第 $(j,k)$ 个元素，其中 $\\nabla^2 M_i(x)$ 是 $M(x)$ 的第 $i$ 个分量的海森矩阵。第三项是 $\\lambda \\nabla^2 C(x)$ 的第 $(j,k)$ 个元素。将这些组合成矩阵形式，得到完整的海森矩阵：\n$$\n\\nabla^2 \\Phi(x) = 2 J_M(x)^{\\top} J_M(x) - 2 \\sum_{i=1}^{m} r_i(x) \\nabla^2 M_i(x) + \\lambda \\nabla^2 C(x)\n$$\n\n第三，我们分析 Gauss-Newton 优化步的稳定性条件。Gauss-Newton 近似海森矩阵 $H_{\\mathrm{GN}}(x)$ 是通过忽略涉及 $M_i(x)$ 的二阶导数项（即含 $\\sum r_i \\nabla^2 M_i$ 的项）而形成的，当残差 $r_i(x)$ 很小或 $M(x)$ 近似线性时，这种做法是合理的。问题定义：\n$$\nH_{\\mathrm{GN}}(x) = 2 J_{M}(x)^{\\top} J_{M}(x) + \\lambda \\nabla^{2} C(x)\n$$\n对于一个稳定的下降步，$H_{\\mathrm{GN}}(x)$ 必须是正定的。问题要求一个更强的条件：找到最小的 $\\lambda > 0$，使得 $H_{\\mathrm{GN}}(x)$ 的最小特征值至少为 $\\alpha > 0$，即 $H_{\\mathrm{GN}}(x) \\succeq \\alpha I$。这确保了矩阵是良态的，并且搜索方向是一个强下降方向。\n\n令 $\\lambda_{\\min}(A)$ 表示对称矩阵 $A$ 的最小特征值。我们想找到最小的 $\\lambda > 0$ 使得 $\\lambda_{\\min}(H_{\\mathrm{GN}}(x)) \\ge \\alpha$。使用关于对称矩阵和的特征值的 Weyl 不等式，$\\lambda_{\\min}(A+B) \\ge \\lambda_{\\min}(A) + \\lambda_{\\min}(B)$，我们可以为 $H_{\\mathrm{GN}}(x)$ 的最小特征值建立一个下界：\n$$\n\\lambda_{\\min}(H_{\\mathrm{GN}}(x)) \\ge \\lambda_{\\min}(2 J_{M}(x)^{\\top} J_{M}(x)) + \\lambda_{\\min}(\\lambda \\nabla^{2} C(x))\n$$\n我们分析右侧的每一项。$J_{M}(x)^{\\top} J_{M}(x)$ 的特征值是 $J_{M}(x)$ 的奇异值的平方。因此，它的最小特征值是 $\\sigma_{\\min}(x)^2$，其中 $\\sigma_{\\min}(x)$ 是 $J_{M}(x)$ 的最小奇异值。\n$$\n\\lambda_{\\min}(2 J_{M}(x)^{\\top} J_{M}(x)) = 2 \\sigma_{\\min}(x)^2\n$$\n对于第二项，给定存在某个 $\\mu > 0$ 使得 $\\nabla^{2} C(x) \\succeq \\mu I$。这意味着 $\\lambda_{\\min}(\\nabla^{2} C(x)) \\ge \\mu$。由于 $\\lambda > 0$：\n$$\n\\lambda_{\\min}(\\lambda \\nabla^{2} C(x)) = \\lambda \\, \\lambda_{\\min}(\\nabla^{2} C(x)) \\ge \\lambda \\mu\n$$\n结合这些界限，我们得到了我们要求的一个充分条件：\n$$\n\\lambda_{\\min}(H_{\\mathrm{GN}}(x)) \\ge 2 \\sigma_{\\min}(x)^2 + \\lambda \\mu\n$$\n为了保证 $\\lambda_{\\min}(H_{\\mathrm{GN}}(x)) \\ge \\alpha$，要求这个下界至少为 $\\alpha$ 就足够了：\n$$\n2 \\sigma_{\\min}(x)^2 + \\lambda \\mu \\ge \\alpha\n$$\n解出 $\\lambda$：\n$$\n\\lambda \\mu \\ge \\alpha - 2 \\sigma_{\\min}(x)^2 \\quad \\implies \\quad \\lambda \\ge \\frac{\\alpha - 2 \\sigma_{\\min}(x)^2}{\\mu}\n$$\n这个不等式为 $\\lambda$ 提供了一个值，对于任何满足前提条件的矩阵，该值足以保证期望的曲率。它代表了最坏情况下的要求（即两个矩阵对应于最小特征值的特征向量对齐的情况）。\n问题还规定了 $\\lambda > 0$。如果右侧的 $\\frac{\\alpha - 2 \\sigma_{\\min}(x)^2}{\\mu}$ 是非正的，那么任何 $\\lambda > 0$ 都满足推导出的不等式。为了给 $\\lambda$ 的最小值（或者更精确地说，有效 $\\lambda$ 集合的下确界）提供一个单一表达式，我们必须取 0 和推导出的下界中的最大值。因此，$\\lambda$ 的下确界是：\n$$\n\\max\\left(0, \\frac{\\alpha - 2 \\sigma_{\\min}(x)^2}{\\mu}\\right)\n$$\n\n最终答案要求将三个推导出的表达式放在一个单一的行矩阵中。\n1.  梯度： $\\nabla \\Phi(x) = -2J_M(x)^\\top r(x) + \\lambda \\nabla C(x)$\n2.  海森矩阵： $\\nabla^2 \\Phi(x) = 2 J_M(x)^\\top J_M(x) - 2 \\sum_{i=1}^m r_i(x) \\nabla^2 M_i(x) + \\lambda \\nabla^2 C(x)$\n3.  最小的 $\\lambda$（下确界）： $\\max \\left( 0, \\frac{\\alpha - 2 \\sigma_{\\min}(x)^2}{\\mu} \\right)$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-2J_M(x)^\\top r(x) + \\lambda \\nabla C(x) & 2 J_M(x)^\\top J_M(x) - 2 \\sum_{i=1}^m r_i(x) \\nabla^2 M_i(x) + \\lambda \\nabla^2 C(x) & \\max \\left( 0, \\frac{\\alpha - 2 \\sigma_{\\min}(x)^2}{\\mu} \\right)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "反向映射通常是一个不适定问题（ill-posed problem），这意味着一个给定的粗粒化构象可能对应着多个不同的、但在化学上均合理的原子构象。这种简并性（degeneracy）源于从高维到低维映射过程中的信息损失，并且可以通过映射算子的零空间（null space）来精确描述。本练习将通过一个编程任务，引导您构建一个线性映射矩阵，计算其零空间，并利用该零空间生成保留粗粒化表征的原子扰动。这个实践将帮助您直观地理解反向映射解的多样性，并探索构象采样的可能性。",
            "id": "3852043",
            "problem": "给定一个三肽的粗粒化珠映射，该映射通过一个线性算子将全原子笛卡尔坐标映射到珠坐标。令 $N$ 表示原子数，$B$ 表示珠子数。全原子坐标向量为 $x \\in \\mathbb{R}^{3N}$，珠坐标向量为 $y \\in \\mathbb{R}^{3B}$。该映射是线性的，$y = M x$，其中 $M \\in \\mathbb{R}^{3B \\times 3N}$ 是由每个珠子的原子坐标的凸组合构建的，并复制到三个笛卡尔分量上。具体来说，珠 $b$ 由一组原子索引 $S_b \\subset \\{0,1,\\dots,N-1\\}$ 和非负权重 $\\{w_i\\}_{i \\in S_b}$ 定义，且满足 $\\sum_{i \\in S_b} w_i > 0$。映射矩阵 $M$ 的定义如下：对于每个珠 $b \\in \\{0,1,\\dots,B-1\\}$ 和每个原子 $i \\in S_b$，其块矩阵为\n$$\nM[3b:3b+3,\\,3i:3i+3] \\;=\\; \\left(\\frac{w_i}{\\sum_{j \\in S_b} w_j}\\right) I_3 \\,,\n$$\n其中 $I_3$ 表示 $3 \\times 3$ 的单位矩阵，其他位置为零。这实现了将珠坐标表示为指定原子位置的质量加权或权重加权平均值。一个反向映射扰动 $\\delta x \\in \\mathbb{R}^{3N}$ 保持粗粒化坐标 $y$ 不变，当且仅当 $M \\,\\delta x = 0$，即 $\\delta x$ 位于 $M$ 的零空间中。\n\n您的任务是编写一个完整、可运行的程序，该程序能够：\n- 根据给定的珠定义构建 $M$。\n- 计算 $\\mathrm{Null}(M)$ 的一个标准正交基。\n- 通过采样系数 $\\alpha$ 并形成 $\\delta x = N_{\\mathrm{basis}} \\,\\alpha$ 来生成随机的反向映射扰动，其中 $N_{\\mathrm{basis}}$ 的列构成了 $\\mathrm{Null}(M)$ 的一个标准正交基。\n- 通过报告每个测试用例在一组固定的随机扰动下的最大欧几里得范数 $\\lVert M \\,\\delta x \\rVert_2$，来数值验证这些扰动是否保持 $y$ 不变。\n\n推导的基本依据：\n- 在计算化学生物学中，粗粒化映射通常被建模为一个线性算子，通过基于物理质量或其他粗粒化权重的加权平均，将全原子坐标映射到珠坐标。这由 $y = M x$ 捕获，其中 $M$ 的构建方式如上所述。\n- 所有保持 $y$ 不变的全原子扰动的集合恰好是 $M$ 的零空间，即 $\\{\\delta x \\in \\mathbb{R}^{3N} \\mid M \\,\\delta x = 0\\}$。\n- 零空间的一个标准正交基为所有此类扰动提供了一个方便的参数化方法，通过 $\\mathbb{R}^k$ 中的系数实现，其中 $k = \\dim \\mathrm{Null}(M)$。\n\n用于标准化输出的数值协议：\n- 对系数使用固定的高斯采样：对于每个测试用例，抽取 $K$ 个独立样本 $\\alpha^{(j)} \\sim \\mathcal{N}(0, \\sigma^2 I_k)$，其中 $K = 10$ 且 $\\sigma = 0.05$，并构建 $\\delta x^{(j)} = N_{\\mathrm{basis}} \\,\\alpha^{(j)}$。\n- 对于每个测试用例，报告单个标量值\n$$\n\\max_{1 \\le j \\le K} \\; \\lVert M \\,\\delta x^{(j)} \\rVert_2 \\,.\n$$\n- 使用固定的随机种子 $s = 42$，以使结果可复现。\n- 不需要物理单位；所有量均被视为无量纲。\n\n测试套件：\n- 所有测试用例都考虑一个包含 $B = 3$ 个珠和 $N = 12$ 个原子的三肽，原子索引为 $0,1,\\dots,11$。每个用例指定了珠索引集 $(S_0,S_1,S_2)$ 和相应的未归一化权重。\n\n1. 用例 A（均匀权重，等大小分组）：\n$$\nS_0 = \\{0,1,2,3\\}, \\quad S_1 = \\{4,5,6,7\\}, \\quad S_2 = \\{8,9,10,11\\}.\n$$\n权重：\n$$\nw^{(0)} = [1,1,1,1], \\quad w^{(1)} = [1,1,1,1], \\quad w^{(2)} = [1,1,1,1].\n$$\n\n2. 用例 B（质量加权，等大小分组）。重原子的近似原子质量：\n$$\nw^{(b)} = [14.007,\\,12.011,\\,12.011,\\,15.999] \\quad \\text{for each} \\quad b \\in \\{0,1,2\\},\n$$\n索引集与用例 A 相同。\n\n3. 用例 C（均匀权重，不等大小分组）：\n$$\nS_0 = \\{0,1,2,3,4\\}, \\quad S_1 = \\{5,6,7,8\\}, \\quad S_2 = \\{9,10,11\\},\n$$\n权重为\n$$\nw^{(0)} = [1,1,1,1,1], \\quad w^{(1)} = [1,1,1,1], \\quad w^{(2)} = [1,1,1].\n$$\n\n4. 用例 D（均匀权重，边界为单原子珠）：\n$$\nS_0 = \\{0\\}, \\quad S_1 = \\{1,2,3,4,5\\}, \\quad S_2 = \\{6,7,8,9,10,11\\},\n$$\n权重为\n$$\nw^{(0)} = [1], \\quad w^{(1)} = [1,1,1,1,1], \\quad w^{(2)} = [1,1,1,1,1,1].\n$$\n\n程序要求：\n- 使用上述块-单位矩阵方案，根据提供的 $(S_b, w^{(b)})$ 定义实现 $M$ 的构建。\n- 计算 $\\mathrm{Null}(M)$ 的一个标准正交基。\n- 对于每个测试用例，采样 $K=10$ 个方差为 $\\sigma^2$ 的独立高斯系数向量，并形成 $\\delta x^{(j)}$。计算欧几里得范数 $\\lVert M \\,\\delta x^{(j)} \\rVert_2$ 并取 $K$ 个样本中的最大值作为该测试用例的报告值。\n- 使用指定的随机种子 $s = 42$ 以保证可复现性。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按四个测试用例的顺序排列结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 都是一个浮点数。\n\n注意：不涉及角度，也不需要物理单位。唯一的输出是如上定义的实值浮点数，每个测试用例一个。",
            "solution": "该问题要求我们验证一个粗粒化分子模型的反向映射程序。其核心原理是，任何不改变粗粒化表示 $y$ 的原子扰动 $\\delta x$ 都必须属于线性映射算子 $M$ 的零空间，该算子由关系 $y = M x$ 定义。我们必须通过构建此类扰动并测量它们经 $M$ 投影后的范数来验证这一点，由于数值精度的限制，该范数应接近于零。该过程包括四个主要步骤：构建矩阵 $M$，计算其零空间的基，根据该基生成随机扰动，以及量化数值误差。\n\n首先，我们构建粗粒化矩阵 $M \\in \\mathbb{R}^{3B \\times 3N}$。此处，$N=12$ 是原子数，$B=3$ 是粗粒化珠数。矩阵 $M$ 将全原子坐标向量 $x \\in \\mathbb{R}^{3N}$ 映射到珠坐标向量 $y \\in \\mathbb{R}^{3B}$。对于每个珠 $b \\in \\{0, 1, \\dots, B-1\\}$，其位置是原子集 $S_b \\subset \\{0, 1, \\dots, N-1\\}$ 中原子位置的加权平均。权重由 $\\{w_i\\}_{i \\in S_b}$ 给出。该映射被构造为一系列 $3 \\times 3$ 的块。具体来说，对于每个原子 $i \\in S_b$，将原子 $i$ 的坐标映射到珠 $b$ 的 $M$ 的块由下式给出：\n$$\nM[3b:3b+3, 3i:3i+3] = c_i I_3\n$$\n其中 $I_3$ 是 $3 \\times 3$ 单位矩阵，$c_i$ 是归一化权重：\n$$\nc_i = \\frac{w_i}{\\sum_{j \\in S_b} w_j}\n$$\n$M$ 的所有其他块都是零矩阵。此构造通过初始化一个 $3B \\times 3N$（即 $9 \\times 36$）的零矩阵，并为测试用例中提供的每个珠定义填充指定的块来实现。\n\n其次，我们确定保持粗粒化坐标不变的扰动 $\\delta x$ 的空间。如果一个扰动 $\\delta x$ 不改变珠坐标，则认为它对于反向映射是有效的，这意味着 $y$ 的变化为零：$\\delta y = M \\delta x = 0$。所有此类向量 $\\delta x$ 的集合构成了矩阵 $M$ 的零空间，记为 $\\mathrm{Null}(M)$。该空间的维数 $k$ 由秩-零度定理给出：$k = \\dim(\\mathrm{Null}(M)) = 3N - \\mathrm{rank}(M)$。对于所提供的测试用例，珠子的原子集 $S_b$ 是不相交的，这确保了 $M$ 中对应于不同珠子的行是线性无关的。因此，$M$ 的秩为 $3B = 9$。零空间的维数因此为 $k = 3 \\times 12 - 9 = 27$。我们使用标准的数值线性代数程序来计算这个 $27$ 维零空间的一个标准正交基。具体来说，我们使用奇异值分解 (SVD)，如 `scipy.linalg.null_space` 函数中所实现的，该函数返回一个矩阵 $N_{\\mathrm{basis}} \\in \\mathbb{R}^{3N \\times k}$，其列构成了 $\\mathrm{Null}(M)$ 的标准正交基向量 $\\{v_1, v_2, \\dots, v_k\\}$。\n\n第三，我们生成位于该零空间内的随机扰动。$\\mathrm{Null}(M)$ 中的任何向量都可以表示为其基向量的线性组合。一个随机扰动 $\\delta x$ 构建如下：\n$$\n\\delta x = \\sum_{j=1}^{k} \\alpha_j v_j = N_{\\mathrm{basis}} \\alpha\n$$\n其中 $\\alpha = [\\alpha_1, \\alpha_2, \\dots, \\alpha_k]^T$ 是一个系数向量。根据问题说明，这些系数独立地从均值为 $0$、方差为 $\\sigma^2$ 的高斯分布中采样，即 $\\alpha_j \\sim \\mathcal{N}(0, \\sigma^2)$。标准差指定为 $\\sigma = 0.05$。对于每个测试用例，我们生成 $K=10$ 个这样的随机系数向量 $\\alpha^{(j)}$，并构建相应的扰动 $\\delta x^{(j)}$。固定的随机种子 $s=42$ 确保了这些样本的可复现性。\n\n第四，我们进行数值验证。在精确算术中，由于 $N_{\\mathrm{basis}}$ 的每一列都在 $\\mathrm{Null}(M)$ 中，因此有 $M N_{\\mathrm{basis}} = \\boldsymbol{0}$，其中 $\\boldsymbol{0}$ 是一个零矩阵。因此，$M \\delta x = M (N_{\\mathrm{basis}} \\alpha) = (M N_{\\mathrm{basis}}) \\alpha = \\boldsymbol{0} \\alpha = 0$。然而，由于零空间计算和后续矩阵乘法中有限的浮点精度，我们预计计算结果 $M \\delta x$ 将是一个分量非常小但不为零的向量。我们通过计算每个生成的 $K=10$ 个扰动的欧几里得范数 $\\lVert M \\delta x^{(j)} \\rVert_2$ 来量化此数值误差。每个测试用例的最终报告值是这些范数的最大值，即 $\\max_{1 \\le j \\le K} \\lVert M \\delta x^{(j)} \\rVert_2$。该值可作为衡量整个过程数值稳定性和正确性的指标。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Constructs a coarse-graining matrix M, finds its null space, generates\n    random perturbations within this space, and verifies that they preserve\n    the coarse-grained representation by checking if M * delta_x is close to zero.\n    \"\"\"\n\n    # Define constants from the problem statement.\n    N_ATOMS = 12\n    N_BEADS = 3\n    K_SAMPLES = 10\n    SIGMA = 0.05\n    RANDOM_SEED = 42\n\n    # Define the test cases.\n    # Each case is a tuple: (name, bead_definitions)\n    # bead_definitions is a list of tuples: (atom_indices, weights)\n    test_cases = [\n        # 1. Case A (uniform weights, equal group sizes)\n        (\n            [\n                (list(range(0, 4)), [1.0] * 4),\n                (list(range(4, 8)), [1.0] * 4),\n                (list(range(8, 12)), [1.0] * 4)\n            ]\n        ),\n        # 2. Case B (mass-weighted, equal group sizes)\n        (\n            [\n                (list(range(0, 4)), [14.007, 12.011, 12.011, 15.999]),\n                (list(range(4, 8)), [14.007, 12.011, 12.011, 15.999]),\n                (list(range(8, 12)), [14.007, 12.011, 12.011, 15.999])\n            ]\n        ),\n        # 3. Case C (uniform weights, unequal group sizes)\n        (\n            [\n                (list(range(0, 5)), [1.0] * 5),\n                (list(range(5, 9)), [1.0] * 4),\n                (list(range(9, 12)), [1.0] * 3)\n            ]\n        ),\n        # 4. Case D (uniform weights, boundary with a single-atom bead)\n        (\n            [\n                ([0], [1.0]),\n                (list(range(1, 6)), [1.0] * 5),\n                (list(range(6, 12)), [1.0] * 6)\n            ]\n        )\n    ]\n\n    results = []\n    \n    # Set the random seed for reproducibility across all test cases.\n    np.random.seed(RANDOM_SEED)\n\n    for bead_defs in test_cases:\n        # 1. Construct the mapping matrix M\n        dim_M_rows = 3 * N_BEADS\n        dim_M_cols = 3 * N_ATOMS\n        M = np.zeros((dim_M_rows, dim_M_cols))\n        \n        for b, (atom_indices, weights) in enumerate(bead_defs):\n            sum_weights = sum(weights)\n            if sum_weights == 0:\n                # This case is disallowed by the problem statement.\n                # It would lead to division by zero.\n                raise ValueError(\"Sum of weights for a bead cannot be zero or negative.\")\n\n            for local_idx, atom_idx in enumerate(atom_indices):\n                weight = weights[local_idx]\n                normalized_weight = weight / sum_weights\n                \n                # The block M[3b:3b+3, 3i:3i+3] is a scaled identity matrix.\n                row_start = 3 * b\n                col_start = 3 * atom_idx\n                M[row_start:row_start+3, col_start:col_start+3] = normalized_weight * np.identity(3)\n\n        # 2. Compute an orthonormal basis for the null space of M.\n        # The columns of N_basis form the basis vectors.\n        N_basis = null_space(M)\n        \n        # Dimension of the null space, k.\n        k = N_basis.shape[1]\n        \n        max_norm = 0.0\n\n        for _ in range(K_SAMPLES):\n            # 3. Generate random coefficients alpha.\n            # np.random.normal's 'scale' parameter is the standard deviation sigma.\n            alpha = np.random.normal(loc=0.0, scale=SIGMA, size=k)\n            \n            # Construct the perturbation delta_x in the null space.\n            delta_x = N_basis @ alpha\n            \n            # 4. Verify by projecting delta_x back with M and computing the norm.\n            # In theory, M @ delta_x should be a zero vector.\n            y_pert = M @ delta_x\n            \n            # Compute the Euclidean norm of the resulting vector.\n            # This norm quantifies the numerical error.\n            norm = np.linalg.norm(y_pert, ord=2)\n            \n            # Keep track of the maximum norm found over K samples.\n            if norm > max_norm:\n                max_norm = norm\n                \n        results.append(max_norm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在真实的分子动力学模拟中，周期性边界条件（PBC）是处理有限尺寸效应的标准技术，但它也给粗粒化和反向映射带来了独特的挑战。当分子跨越模拟盒子边界时，简单地计算其包裹坐标（wrapped coordinates）的质心会导致物理上毫无意义的结果。本练习将引导您分析PBC如何影响粗粒化珠子（bead）的定位，并推导出一个稳健的策略来“解开”跨边界的分子。通过解决这个在实际模拟中普遍存在的问题，您将学会如何正确处理周期性系统中的坐标，确保多尺度模型的一致性和准确性。",
            "id": "3852041",
            "problem": "考虑分子动力学（MD）中周期性边界条件（PBC）下的一个粗粒化映射，该映射应用于其原子可能穿过模拟盒子边界的分子。设三斜周期性晶胞由盒子矩阵 $H \\in \\mathbb{R}^{3 \\times 3}$ 表示，其列等于三个晶格矢量。在主映象中，包裹后的原子坐标用 $r_i \\in \\mathbb{R}^3$ 表示，未包裹的坐标用 $x_i \\in \\mathbb{R}^3$ 表示，它们通过 $x_i = r_i + H n_i$ 相关联，其中 $n_i \\in \\mathbb{Z}^3$ 是整数晶格偏移。一个粗粒化（CG）珠子的位置 $R_b \\in \\mathbb{R}^3$ 被定义为其组分原子在未包裹空间中的质量加权质心（COM）：$R_b = \\left(\\sum_{i \\in b} m_i x_i\\right)\\big/\\left(\\sum_{i \\in b} m_i\\right)$，其中 $m_i$ 是原子质量。对于从珠子到原子的反向映射，使用局部内坐标（键长、键角、二面角）和一个以珠子为中心的局部坐标系来重构相对于 $R_b$ 的原子位置。\n\n从 PBC 和 COM 的核心定义出发，推导对于跨越边界的分子，使用包裹坐标 $r_i$ 代替未包裹坐标 $x_i$ 会如何影响计算出的 $R_b$，并解释为什么需要对晶格偏移 $n_i$ 进行一致的选择，以避免人为的碎裂或错误的珠子放置。使用以分数坐标 $s = H^{-1}(r)$ 表述的最小映象原理：对于任意成键对 $(j,k)$，最近映象位移为 $d_{jk} = r_k - r_j - H\\,\\mathrm{round}\\!\\left(H^{-1}(r_k - r_j)\\right)$，其中 $\\mathrm{round}(\\cdot)$ 按分量作用以产生最近的整数矢量。\n\n然后，将您的推导应用于以下正交算例，其中 $H = \\mathrm{diag}(L_x, L_y, L_z)$，$L_x = L_y = L_z = 1\\,\\mathrm{nm}$，一个由单个共价键连接的双原子珠子，其原子质量相等 $m_1 = m_2 = m$，包裹坐标为 $r_1 = (0.98, 0.50, 0.50)\\,\\mathrm{nm}$ 和 $r_2 = (0.02, 0.50, 0.50)\\,\\mathrm{nm}$。计算在 PBC 下与化学键一致的未包裹位置 $x_1$、$x_2$ 和未包裹空间中的珠子质心 $R_b$，并说明其重新包裹回主晶胞后的值。\n\n最后，选择一个选项，该选项提出了一个与您的推导一致，并能为该算例得出正确 $R_b$ 的稳健的展开和反向映射策略。\n\nA. 在广度优先遍历中，使用最近映象位移 $d_{jk} = r_k - r_j - H\\,\\mathrm{round}\\!\\left(H^{-1}(r_k - r_j)\\right)$ 沿着分子键进行基于图的展开。对于一个参考原子 $j_0$，设置 $x_{j_0} = r_{j_0}$，然后对于每个访问过的键 $(j,k)$，设置 $x_k = x_j + d_{jk}$。在未包裹空间中计算 $R_b = \\left(\\sum_i m_i x_i\\right)\\big/\\left(\\sum_i m_i\\right)$，并且为了存储，通过映射到分数坐标并减去 $\\mathrm{round}(\\cdot)$ 来重新包裹 $R_b$。对于反向映射，使用内坐标在以未包裹的 $R_b$ 为中心的珠子局部坐标系中放置原子，然后将所有位置包裹回主晶胞。对于该算例，$x_1 = (0.98, 0.50, 0.50)\\,\\mathrm{nm}$，$x_2 = (1.02, 0.50, 0.50)\\,\\mathrm{nm}$，$R_b = (1.00, 0.50, 0.50)\\,\\mathrm{nm}$，重新包裹后为 $(0.00, 0.50, 0.50)\\,\\mathrm{nm}$。\n\nB. 直接在主晶胞中从包裹坐标 $r_i$ 计算 $R_b$，无需展开，即 $R_b = \\left(\\sum_i m_i r_i\\right)\\big/\\left(\\sum_i m_i\\right)$。对于反向映射，放置原子，使得每个原子沿坐标轴 $\\alpha \\in \\{x,y,z\\}$ 都位于 $R_b$ 的 $\\pm L_\\alpha/2$ 范围内，以确保与珠子的邻近性。对于该算例，$R_b = (0.50, 0.50, 0.50)\\,\\mathrm{nm}$。\n\nC. 从包裹坐标 $r_i$ 估计 $R_b$，然后通过对每个坐标轴 $\\alpha$ 强制执行 $|x_{i,\\alpha} - R_{b,\\alpha}| \\le L_\\alpha/2$ 来迭代地展开每个原子；重复此过程直至收敛。使用从迭代调整后的 $x_i$ 计算出的最终 $R_b$。对于该算例，此过程得出 $R_b \\approx (0.50, 0.50, 0.50)\\,\\mathrm{nm}$。\n\nD. 通过最小化到原点的平方距离之和 $\\sum_i \\|r_i + H n_i\\|^2$ 来为所有原子选择整数晶格偏移 $n_i \\in \\mathbb{Z}^3$，从而展开分子；然后从得到的 $x_i$ 计算 $R_b$。对于反向映射，通过最小化原子在包裹后与 $R_b$ 的距离来放置原子。对于该算例，一种可能的选择给出 $x_1 = (-0.02, 0.50, 0.50)\\,\\mathrm{nm}$，$x_2 = (0.02, 0.50, 0.50)\\,\\mathrm{nm}$，其 $R_b = (0.00, 0.50, 0.50)\\,\\mathrm{nm}$，但这种方法可能会在支链或环状分子中扭曲键合几何结构。",
            "solution": "首先对问题陈述进行严格的验证过程。\n\n**步骤1：提取已知条件**\n- 周期性晶胞表示：三斜盒子矩阵 $H \\in \\mathbb{R}^{3 \\times 3}$，其列为晶格矢量。\n- 原子坐标：包裹坐标 $r_i \\in \\mathbb{R}^3$，未包裹坐标 $x_i \\in \\mathbb{R}^3$。\n- 坐标关系：$x_i = r_i + H n_i$，其中 $n_i \\in \\mathbb{Z}^3$ 是整数晶格偏移。\n- 粗粒化（CG）珠子位置：$R_b = \\left(\\sum_{i \\in b} m_i x_i\\right)\\big/\\left(\\sum_{i \\in b} m_i\\right)$，使用未包裹坐标 $x_i$ 定义。$m_i$ 是原子质量。\n- 反向映射：从 $R_b$ 使用内坐标和局部坐标系重构原子位置。\n- 成键对 $(j,k)$ 的最小映象位移：$d_{jk} = r_k - r_j - H\\,\\mathrm{round}\\!\\left(H^{-1}(r_k - r_j)\\right)$。$\\mathrm{round}(\\cdot)$ 函数按分量作用。\n- 分数坐标：$s = H^{-1}(r)$。\n- 算例系统规格：\n    - 盒子矩阵：正交，$H = \\mathrm{diag}(L_x, L_y, L_z)$。\n    - 盒子尺寸：$L_x = L_y = L_z = 1\\,\\mathrm{nm}$。\n    - 珠子组成：双原子，原子1和2成键。\n    - 原子质量：$m_1 = m_2 = m$。\n    - 包裹坐标：$r_1 = (0.98, 0.50, 0.50)\\,\\mathrm{nm}$ 和 $r_2 = (0.02, 0.50, 0.50)\\,\\mathrm{nm}$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题牢固地植根于分子动力学（MD）模拟的标准原理，包括周期性边界条件（PBC）、粗粒化、质心计算和最小映象约定。所提供的方程是该领域的标准定义。\n- **适定性**：该问题是适定的。它提供了执行所需推导和计算的所有必要定义和数据。目标明确：推导处理粗粒化中PBC的正确程序，并将其应用于特定示例，然后在选项中确定正确的策略。\n- **客观性**：问题陈述使用精确、技术性的语言表达，没有主观性或歧义。\n\n**缺陷清单**：\n1.  **科学/事实不健全**：无。物理和数学是标准且正确的。\n2.  **不可形式化/不相关**：无。该问题是计算化学生物学中一个形式化且相关的挑战。\n3.  **不完整/矛盾的设置**：无。信息是自洽且充分的。\n4.  **不切实际/不可行**：无。参数是原子模拟中的典型值。\n5.  **不适定/结构不良**：无。术语定义明确，问题结构清晰，有唯一的正确答案。\n6.  **琐碎/同义反复**：无。该问题解决了MD模拟分析中一个非凡且常见的问题，通常被称为“包裹团簇的质心”问题，需要仔细推理。\n7.  **超出科学可验证性**：无。推导和计算都是可验证的。\n\n**步骤3：结论与行动**\n问题陈述是 **有效的**。继续进行解答推导。\n\n**理论推导与分析**\n\n粗粒化珠子的位置 $R_b$ 被定义为其组分原子在物理上连续的、未包裹的坐标系中的质心（COM）。定义为：\n$$R_b = \\frac{\\sum_{i \\in b} m_i x_i}{\\sum_{i \\in b} m_i}$$\n其中 $x_i$ 是未包裹坐标。利用关系式 $x_i = r_i + H n_i$，我们可以用包裹坐标 $r_i$ 和整数晶格偏移 $n_i$ 来表示 $R_b$：\n$$R_b = \\frac{\\sum_{i \\in b} m_i (r_i + H n_i)}{\\sum_{i \\in b} m_i} = \\frac{\\sum_{i \\in b} m_i r_i}{\\sum_{i \\in b} m_i} + H \\left( \\frac{\\sum_{i \\in b} m_i n_i}{\\sum_{i \\in b} m_i} \\right)$$\n令 $R_b^{\\text{wrapped}} = \\left(\\sum_{i \\in b} m_i r_i\\right) / \\left(\\sum_{i \\in b} m_i\\right)$ 为从包裹坐标简单计算出的质心。方程变为：\n$$R_b = R_b^{\\text{wrapped}} + H \\cdot \\bar{n}_b$$\n其中 $\\bar{n}_b = \\left(\\sum_{i \\in b} m_i n_i\\right) / \\left(\\sum_{i \\in b} m_i\\right)$ 是整数晶格偏移矢量的质量加权平均值。\n\n如果一个分子跨越周期性边界，其组分原子将具有不同的整数偏移矢量 $n_i$。例如，对于一个跨越 $x$ 边界的双原子分子，我们可能有 $n_1 = (0,0,0)^T$ 和 $n_2 = (1,0,0)^T$。在这种情况下，$\\bar{n}_b$ 不是一个整数矢量，且 $R_b^{\\text{wrapped}}$ 不代表任何物理对象的质心。它变成了两个远距离点的无意义平均值，导致 CG 珠子被错误地放置（例如，在盒子中间，远离实际分子）。\n\n要计算正确的 $R_b$，必须首先确定一组一致的 $n_i$ 矢量，以在未包裹空间中将分子重构为单个连续的实体。这相当于使分子‘完整’。共价键结构为此提供了必要的信息。最小映象位移矢量 $d_{jk} = x_k - x_j$ 给出了两个成键原子 $j$ 和 $k$ 之间的真实矢量。所提供的公式 $d_{jk} = r_k - r_j - H\\,\\mathrm{round}\\!\\left(H^{-1}(r_k - r_j)\\right)$ 是从包裹坐标计算该矢量的标准方法。\n\n因此，一个稳健的算法是遍历分子图（例如，通过广度优先搜索）。我们可以通过选择一个参考原子 $j_0$ 并将其未包裹位置设置为其包裹位置 $x_{j_0} = r_{j_0}$ 来锚定该分子（这实际上是选择 $n_{j_0} = (0,0,0)^T$）。然后，对于已访问原子 $j$ 的每个成键邻居 $k$，其未包裹位置被确定为 $x_k = x_j + d_{jk}$。这个过程在未包裹空间中迭代地重构整个分子，确保所有键矢量都是正确的。一旦找到所有一致的 $x_i$，就可以计算出真实的质心 $R_b$。该过程确保了内部几何结构和得到的 $R_b$ 是正确的，无论分子相对于映象盒子边界的位置如何。对于反向映射，应在对整个分子进行任何最终包裹之前，围绕这个正确的、未包裹的 $R_b$ 重建原子结构。\n\n**应用于算例**\n\n- 盒子：$H = \\mathrm{diag}(1, 1, 1)\\,\\mathrm{nm}$，所以 $H^{-1} = \\mathrm{diag}(1, 1, 1)\\,\\mathrm{nm}^{-1}$。\n- 质量：$m_1 = m_2 = m$。\n- 包裹坐标：$r_1 = (0.98, 0.50, 0.50)\\,\\mathrm{nm}$，$r_2 = (0.02, 0.50, 0.50)\\,\\mathrm{nm}$。\n\n我们遵循稳健的展开程序：\n1.  选择原子1作为参考。将其未包裹位置设置为其包裹位置：\n    $$x_1 = r_1 = (0.98, 0.50, 0.50)\\,\\mathrm{nm}$$\n    这设置了 $n_1 = (0,0,0)^T$。\n\n2.  计算最小映象位移矢量 $d_{12}$，以找到原子2相对于原子1的位置。\n    $$r_2 - r_1 = (0.02 - 0.98, 0.50 - 0.50, 0.50 - 0.50)\\,\\mathrm{nm} = (-0.96, 0.00, 0.00)\\,\\mathrm{nm}$$\n    在分数坐标中，该位移是 $H^{-1}(r_2 - r_1) = (-0.96, 0.00, 0.00)$。\n    最近的整数矢量是 $\\mathrm{round}(H^{-1}(r_2 - r_1)) = (\\mathrm{round}(-0.96), \\mathrm{round}(0.00), \\mathrm{round}(0.00)) = (-1, 0, 0)^T$。\n    最小映象位移是：\n    $$d_{12} = (r_2 - r_1) - H \\cdot (-1, 0, 0)^T = (-0.96, 0.00, 0.00)\\,\\mathrm{nm} - (-1, 0, 0)\\,\\mathrm{nm} = (0.04, 0.00, 0.00)\\,\\mathrm{nm}$$\n\n3.  计算原子2的未包裹位置：\n    $$x_2 = x_1 + d_{12} = (0.98, 0.50, 0.50)\\,\\mathrm{nm} + (0.04, 0.00, 0.00)\\,\\mathrm{nm} = (1.02, 0.50, 0.50)\\,\\mathrm{nm}$$\n    一致的未包裹坐标是 $x_1 = (0.98, 0.50, 0.50)\\,\\mathrm{nm}$ 和 $x_2 = (1.02, 0.50, 0.50)\\,\\mathrm{nm}$。\n\n4.  从未包裹坐标计算珠子质心 $R_b$。由于质量相等，它就是几何平均值：\n    $$R_b = \\frac{x_1 + x_2}{2} = \\frac{(0.98, 0.50, 0.50) + (1.02, 0.50, 0.50)}{2}\\,\\mathrm{nm} = \\frac{(2.00, 1.00, 1.00)}{2}\\,\\mathrm{nm} = (1.00, 0.50, 0.50)\\,\\mathrm{nm}$$\n\n5.  将 $R_b$ 重新包裹回主晶胞 $[0, 1) \\times [0, 1) \\times [0, 1)\\,\\mathrm{nm}$ 中。我们将其映射到分数坐标 $s_b = H^{-1}R_b = (1.00, 0.50, 0.50)$，找到整数映象矢量 $n = \\mathrm{floor}(s_b) = (1, 0, 0)^T$，然后减去晶格矢量：\n    $$R_{b, \\text{wrapped}} = R_b - Hn = (1.00, 0.50, 0.50)\\,\\mathrm{nm} - (1, 0, 0)\\,\\mathrm{nm} = (0.00, 0.50, 0.50)\\,\\mathrm{nm}$$\n\n**逐项分析**\n\n**A. Perform graph-based unwrapping...**\n此选项描述了上面推导出的精确稳健的过程：基于连通性使用最小映象位移展开分子，在此未包裹空间中计算质心，然后相对于未包裹的质心处理反向映射。选项中提供的计算结果，$x_1 = (0.98, 0.50, 0.50)\\,\\mathrm{nm}$，$x_2 = (1.02, 0.50, 0.50)\\,\\mathrm{nm}$，$R_b = (1.00, 0.50, 0.50)\\,\\mathrm{nm}$，以及重新包裹后的 $R_b = (0.00, 0.50, 0.50)\\,\\mathrm{nm}$，与我们的推导完全匹配。\n**结论：正确。**\n\n**B. Compute $R_b$ directly from wrapped coordinates...**\n这提出了天真且有缺陷的方法。计算结果是 $R_b = (r_1+r_2)/2 = ((0.98, 0.5, 0.5) + (0.02, 0.5, 0.5))/2\\,\\mathrm{nm} = (0.50, 0.50, 0.50)\\,\\mathrm{nm}$。如推导所述，此方法在盒子中心产生一个物理上无意义的质心，远离聚集在 $x=0/x=1$ 边界附近的成键原子。该方法对于跨越周期性边界的分子是根本错误的。\n**结论：错误。**\n\n**C. Estimate $R_b$ from wrapped coordinates, then iteratively unwrap each atom...**\n这描述了一种迭代聚类算法。它从选项B中错误的初始质心 $R_{b, \\text{init}} = (0.50, 0.50, 0.50)\\,\\mathrm{nm}$ 开始。然后检查是否应将任何原子展开以更接近此质心。对于原子1，$|x_{1,x} - R_{b,x}| = |0.98 - 0.50| = 0.48$，小于 $L_x/2 = 0.5$。对于原子2，$|x_{2,x} - R_{b,x}| = |0.02 - 0.50| = 0.48$，也小于 $L_x/2$。由于没有原子被移动，该过程立即收敛到错误的结果 $R_b=(0.50, 0.50, 0.50)\\,\\mathrm{nm}$。该方法失败，因为它没有使用关于分子连通性的关键信息。\n**结论：错误。**\n\n**D. Choose integer lattice offsets $n_i$ ... by minimizing the sum of squared distances to the origin...**\n该策略独立地展开每个原子，使其尽可能靠近原点，而忽略了分子的连通性。对于 $r_1 = (0.98, \\dots)$，最接近原点的未包裹位置是 $x_1 = (-0.02, \\dots)$。对于 $r_2 = (0.02, \\dots)$，最接近原点的未包裹位置是 $x_2 = (0.02, \\dots)$。这得出 $x_1 = (-0.02, 0.50, 0.50)\\,\\mathrm{nm}$ 和 $x_2 = (0.02, 0.50, 0.50)\\,\\mathrm{nm}$。得到的质心是 $R_b = (x_1+x_2)/2 = (0.00, 0.50, 0.50)\\,\\mathrm{nm}$。虽然对于这个简单、对称的例子，这在数值上与正确的包裹后质心相匹配，但其基本原理是有缺陷的。正如选项本身所指出的，这种方法可能会扭曲更复杂分子的几何结构（例如，通过打断一个跨越原点的长分子），因为它不强制要求连续性。一个稳健的方法必须基于保持内部分子结构，而不是将分子移动到像原点这样的任意位置。\n**结论：错误。**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}