{
    "hands_on_practices": [
        {
            "introduction": "任何马尔可夫状态模型（MSM）的核心都是转移矩阵 $T(\\tau)$。这个实践旨在通过从头开始实现一个程序，来巩固对 $T(\\tau)$ 核心数学性质的理解。您将通过解决一个线性系统来计算平稳分布 $\\pi$，并数值验证诸如行随机性、平稳性和长期收敛性等基本属性，这些都是由佩伦-弗罗贝尼乌斯定理（Perron–Frobenius theorem）保证的 。这项练习为您处理更复杂的MSM分析任务奠定了坚实的数值基础。",
            "id": "3838051",
            "problem": "考虑一个为计算化学生物学中的构象动力学构建的有限态马尔可夫状态模型 (MSM)，其在固定的延迟时间 $\\tau$ 下，由一个大小为 $n \\times n$ 且具有非负元素的行随机转移矩阵 $T(\\tau)$ 表示。根据定义，$T(\\tau)$ 的每一行之和为 1，所有元素均为非负，并且状态概率的演化由 $p(t+\\tau) = p(t) T(\\tau)$ 给出，其中 $p(t)$ 是一个行向量。平稳分布 $\\pi$ 是一个满足 $\\pi T(\\tau) = \\pi$ 和 $\\sum_{i=1}^{n} \\pi_i = 1$ 的行向量，且 $\\pi_i \\ge 0$。对于一个不可约且非周期的链（即 $T(\\tau)$ 是本原矩阵），Perron–Frobenius 定理保证了存在一个具有严格正分量的唯一平稳分布，并且收敛\n$$\n\\lim_{k \\to \\infty} T(\\tau)^k = \\mathbf{1} \\, \\pi^\\top,\n$$\n其中 $\\mathbf{1}$ 是全为 1 的列向量。\n\n仅使用这些核心定义和事实，编写一个完整的程序，该程序对下面的每个测试用例，从 $T(\\tau)$ 计算平稳分布 $\\pi$，并验证 (i) 行归一化，(ii) 元素非负性（正性），(iii) 平稳性，以及 (iv) 对于指定的幂 $k$，$T(\\tau)^k$ 向 $\\mathbf{1}\\pi^\\top$ 的收敛性。您的程序必须从第一性原理出发实现以下步骤：\n- 通过求解线性系统 $(T(\\tau)^\\top - I)\\,x = 0$ 并结合归一化约束 $\\sum_i x_i = 1$ 来计算 $\\pi$。\n- 通过检查每一行的和与 1 的最大绝对偏差是否在容差 $\\varepsilon_{\\text{norm}}$ 之内来验证行归一化。\n- 通过检查 $T(\\tau)$ 的最小元素是否至少为 $-\\varepsilon_{\\text{pos}}$ 来验证正性。\n- 通过计算残差 $\\lVert \\pi T(\\tau) - \\pi \\rVert_{\\infty}$ 并与 $\\varepsilon_{\\text{stat}}$ 进行比较来验证平稳性。\n- 通过计算 $\\lVert T(\\tau)^k - \\mathbf{1}\\pi^\\top \\rVert_{\\infty}$ 并与特定于用例的收敛容差 $\\varepsilon_{\\text{conv}}$ 进行比较来验证收敛性。\n\n使用以下在所有用例中共享的数值容差，除非另有说明：\n- 行归一化容差 $\\varepsilon_{\\text{norm}} = 10^{-12}$。\n- 正性容差 $\\varepsilon_{\\text{pos}} = 10^{-15}$。\n- 平稳性容差 $\\varepsilon_{\\text{stat}} = 10^{-10}$。\n- 收敛容差 $\\varepsilon_{\\text{conv}}$ 在下面的每个测试用例中指定。\n\n测试套件（所有数字均为实数且无量纲）：\n1. 案例 A（一个具有强自保持性的可逆 3 态 MSM）：\n   - 矩阵\n     $$\n     T_A = \\begin{bmatrix}\n     0.86  0.10  0.04 \\\\\n     0.16666666666666666  0.7333333333333334  0.10 \\\\\n     0.10  0.15  0.75\n     \\end{bmatrix}.\n     $$\n   - 幂 $k_A = 200$。\n   - 收敛容差 $\\varepsilon_{\\text{conv},A} = 10^{-6}$。\n2. 案例 B（一个由于弱耦合导致慢混合的 2 态 MSM）：\n   - 矩阵\n     $$\n     T_B = \\begin{bmatrix}\n     0.995  0.005 \\\\\n     0.02  0.98\n     \\end{bmatrix}.\n     $$\n   - 幂 $k_B = 800$。\n   - 收敛容差 $\\varepsilon_{\\text{conv},B} = 10^{-8}$。\n3. 案例 C（一个具有两个弱耦合盆地的 4 态 MSM）：\n   - 矩阵\n     $$\n     T_C = \\begin{bmatrix}\n     0.94  0.05  0.01  0.0 \\\\\n     0.04  0.93  0.0  0.03 \\\\\n     0.005  0.0  0.985  0.01 \\\\\n     0.0  0.02  0.03  0.95\n     \\end{bmatrix}.\n     $$\n   - 幂 $k_C = 2000$。\n   - 收敛容差 $\\varepsilon_{\\text{conv},C} = 10^{-8}$。\n\n您的程序必须：\n- 对每个案例，计算 $\\pi$，然后评估四个布尔检查：行归一化、正性、平稳性和收敛性，如果各自的准则在其容差范围内得到满足，则每个检查返回 true。\n- 将三个案例的结果汇总成一个包含 12 个布尔值的扁平列表，顺序如下：\n  $[\\text{norm}_A, \\text{pos}_A, \\text{stat}_A, \\text{conv}_A, \\text{norm}_B, \\text{pos}_B, \\text{stat}_B, \\text{conv}_B, \\text{norm}_C, \\text{pos}_C, \\text{stat}_C, \\text{conv}_C]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，使用编程语言的布尔字面量 $[{\\rm true},{\\rm false},\\dots]$）。不应打印任何其他文本。",
            "solution": "该问题要求对几个由其转移矩阵 $T(\\tau)$ 表示的马尔可夫状态模型 (MSM) 的关键性质进行数值验证。验证过程包括计算平稳分布 $\\pi$，然后验证四个基本性质：行归一化、非负性、$\\pi$ 的平稳性，以及转移矩阵的高次幂向其理论极限的收敛性。整个过程需要作为一个独立的程序从第一性原理出发实现。\n\n问题的核心在于不可约且非周期马尔可夫链的行随机转移矩阵 $T$ 的性质。Perron-Frobenius 定理保证了存在一个唯一的平稳分布 $\\pi$，它是一个具有严格正分量（$\\pi_i > 0$）的行向量，并满足以下条件：\n1. 平稳性：$\\pi T = \\pi$\n2. 归一化：$\\sum_i \\pi_i = 1$\n\n该定理还保证了矩阵的幂 $T^k$ 收敛到一个由平稳分布构成的秩一矩阵：$\\lim_{k \\to \\infty} T^k = \\mathbf{1}\\pi$，其中 $\\mathbf{1}$ 是一个全为 1 的列向量。我们的任务是数值上验证这些性质。\n\n方法步骤如下：\n\n首先，我们计算平稳分布 $\\pi$。平稳性特征值方程 $\\pi T = \\pi$ 可以转置为 $T^\\top \\pi^\\top = \\pi^\\top$。令 $x = \\pi^\\top$ 为平稳分布的列向量表示。方程变为 $T^\\top x = x$，或者整理后为 $(T^\\top - I)x = 0$，其中 $I$ 是单位矩阵。这是一个齐次线性系统。对于一个不可约马尔可夫链，特征值 1 的几何重数为 1，意味着 $(T^\\top - I)$ 的零空间是一维的。因此，系统 $(T^\\top - I)x = 0$ 有无穷多解，所有解都是单个特征向量的标量倍。为了找到对应于平稳分布的唯一解，我们必须施加归一化约束 $\\sum_i x_i = \\sum_i \\pi_i = 1$。解决此问题的一个标准数值技术是增广方程组。我们可以用归一化方程替换 $(T^\\top - I)x = 0$ 中的一个线性相关方程。令 $A = T^\\top - I$。我们通过将 $A$ 的最后一行替换为全为 1 的行来构造一个新矩阵 $A'$。我们还构造一个新的右端向量 $b'$，它除了最后一个位置为 1 外，其余位置均为零。得到的线性系统 $A'x=b'$ 是非奇异的，可以唯一地求解出 $x = \\pi^\\top$。\n\n其次，我们对每个给定的转移矩阵 $T$、其对应的幂 $k$ 和一组数值容差执行四个指定的验证检查。\n\n(i) 行归一化验证：如果一个矩阵 $T$ 的每行元素之和为 1，则该矩阵是行随机的。这反映了这样一个原则：从任何给定状态出发，系统必须转移到模型中的某个其他状态，因此从一个状态转移出去的总概率为 1。我们通过计算行和与 1 的最大绝对偏差来检查这一点：$\\max_i |\\sum_j T_{ij} - 1|$。该值必须小于或等于容差 $\\varepsilon_{\\text{norm}} = 10^{-12}$。\n\n(ii) 正性验证：转移矩阵的元素 $T_{ij}$ 代表概率，因此必须是非负的。为了考虑潜在的浮点不精确性，我们通过检查矩阵中的最小元素不是显著负数来验证这一点。条件是 $\\min_{i,j} T_{ij} \\ge -\\varepsilon_{\\text{pos}}$，其中 $\\varepsilon_{\\text{pos}} = 10^{-15}$。\n\n(iii) 平稳性验证：此检查确认数值计算出的分布 $\\pi$ 对于给定的矩阵 $T$ 确实是一个平稳分布。我们计算残差向量 $\\pi T - \\pi$。一个完美的平稳分布会产生一个零向量。我们通过计算此残差的无穷范数 $\\lVert \\pi T - \\pi \\rVert_{\\infty} = \\max_i |(\\pi T)_i - \\pi_i|$ 来量化偏差，并检查它是否小于或等于平稳性容差 $\\varepsilon_{\\text{stat}} = 10^{-10}$。\n\n(iv) 收敛性验证：此测试验证长时间收敛性质。对于一个大的幂 $k$，矩阵 $T^k$ 应接近于极限矩阵 $\\mathbf{1}\\pi$。我们计算矩阵的 $k$ 次幂 $T^k$ 与理论极限矩阵之间的差异。误差通过两个矩阵元素之间的最大绝对差来衡量，即 $\\max_{i,j} |(T^k)_{ij} - (\\mathbf{1}\\pi)_{ij}|$。这是在逐元素收敛背景下对矩阵无穷范数的一种常见解释。此误差必须小于或等于特定于用例的收敛容差 $\\varepsilon_{\\textconv}$。\n\n这些步骤被系统地应用于每个测试用例，并且四个检查的布尔结果按照问题的要求汇总成一个单一列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve_case(T, k, eps_norm, eps_pos, eps_stat, eps_conv):\n    \"\"\"\n    Computes the stationary distribution of T and performs four validation checks.\n\n    Args:\n        T (np.ndarray): The n x n transition matrix.\n        k (int): The power to raise T to for the convergence check.\n        eps_norm (float): Tolerance for row normalization check.\n        eps_pos (float): Tolerance for positivity check.\n        eps_stat (float): Tolerance for stationarity check.\n        eps_conv (float): Tolerance for convergence check.\n\n    Returns:\n        tuple: A tuple of four booleans for (normalization, positivity, stationarity, convergence).\n    \"\"\"\n    n = T.shape[0]\n\n    # Step 1: Compute the stationary distribution pi\n    # We need to solve (T.T - I)x = 0 subject to sum(x) = 1.\n    # This is done by replacing the last row of (T.T - I) with a row of ones,\n    # and setting the corresponding element in the RHS vector to 1.\n    A = T.T - np.identity(n)\n    A[-1, :] = 1.0\n    b = np.zeros(n)\n    b[-1] = 1.0\n\n    try:\n        # pi_vec is a column vector, but numpy's 1-D array handles this flexibly.\n        pi_vec = np.linalg.solve(A, b)\n    except np.linalg.LinAlgError:\n        # Should not happen for a valid irreducible, aperiodic MSM\n        return (False, False, False, False)\n\n    # Step 2: Perform the four verification checks\n\n    # Check (i): Row normalization\n    row_sums = np.sum(T, axis=1)\n    norm_err = np.max(np.abs(row_sums - 1.0))\n    is_normalized = norm_err = eps_norm\n\n    # Check (ii): Entrywise nonnegativity (positivity)\n    min_val = np.min(T)\n    is_positive = min_val >= -eps_pos\n\n    # Check (iii): Stationarity\n    # pi_vec is broadcasted as a row vector in this operation\n    residual_vec = pi_vec @ T - pi_vec\n    stat_err = np.max(np.abs(residual_vec))\n    is_stationary = stat_err = eps_stat\n\n    # Check (iv): Convergence\n    T_k = np.linalg.matrix_power(T, k)\n    # limit_matrix is the outer product of a column vector of ones and the row vector pi\n    limit_matrix = np.ones((n, 1)) @ pi_vec.reshape(1, -1)\n    conv_err = np.max(np.abs(T_k - limit_matrix))\n    is_converged = conv_err = eps_conv\n\n    return (is_normalized, is_positive, is_stationary, is_converged)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Shared numerical tolerances\n    eps_norm = 1e-12\n    eps_pos = 1e-15\n    eps_stat = 1e-10\n\n    # Test suite\n    test_cases = [\n        {\n            \"T\": np.array([\n                [0.86, 0.10, 0.04],\n                [1/6, 11/15, 0.10], # Using fractions for precision\n                [0.10, 0.15, 0.75]\n            ]),\n            \"k\": 200,\n            \"eps_conv\": 1e-6\n        },\n        {\n            \"T\": np.array([\n                [0.995, 0.005],\n                [0.02, 0.98]\n            ]),\n            \"k\": 800,\n            \"eps_conv\": 1e-8\n        },\n        {\n            \"T\": np.array([\n                [0.94, 0.05, 0.01, 0.0],\n                [0.04, 0.93, 0.0, 0.03],\n                [0.005, 0.0, 0.985, 0.01],\n                [0.0, 0.02, 0.03, 0.95]\n            ]),\n            \"k\": 2000,\n            \"eps_conv\": 1e-8\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        T = case[\"T\"]\n        # The first case in the problem description used floating point approximations.\n        # Let's ensure the matrix matches the problem's floats exactly for reproducibility.\n        if T.shape[0] == 3:\n            T[1,0] = 0.16666666666666666\n            T[1,1] = 0.7333333333333334\n        \n        results = solve_case(T, case[\"k\"], eps_norm, eps_pos, eps_stat, case[\"eps_conv\"])\n        all_results.extend(results)\n\n    # Format the final output as a single-line string\n    print(f\"[{','.join(map(lambda x: str(x).lower(), all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了隐含时间尺度，查普曼-科尔莫戈罗夫（Chapman-Kolmogorov, CK）检验是验证马尔可夫假设的另一种严格方法。该检验通过比较从基础延迟时间 $\\tau$ 预测的长期动力学（即 $(T(\\tau))^k$）与在延迟时间 $k\\tau$ 直接估计的动力学，来评估模型的一致性。本实践将指导您在一个统计框架内实施CK检验，该框架利用贝叶斯可信区间来解释有限采样带来的不确定性 。成功完成此练习表明您已掌握了区分有效马尔可夫模型与因非马尔可夫效应或数据不足而存在偏差的模型的能力。",
            "id": "3838019",
            "problem": "您的任务是实现并应用查普曼-科尔莫戈罗夫检验，以评估根据合成的类分子动力学轨迹构建的马尔可夫状态模型 (MSM) 的有效性。您将从纯数学角度形式化该检验，并量化该 MSM 在统计不确定性范围内是否符合马尔可夫性质。该检验必须应用于多个延迟步长和多个合成系统，以探测有效和无效两种情景。\n\n请使用以下基本定义和事实。\n\n有限状态空间上的离散时间马尔可夫链在给定的延迟时间 $\\tau$ 处具有一个行随机转移矩阵，记为 $T(\\tau)$，其中每个元素 $T(\\tau)_{ij}$ 满足 $T(\\tau)_{ij} \\ge 0$ 且 $\\sum_{j} T(\\tau)_{ij} = 1$。对于基础延迟 $\\tau$ 的整数倍 $k$，查普曼-科尔莫戈罗夫性质表明\n$$\nT(k \\tau) = \\left(T(\\tau)\\right)^k,\n$$\n其中上标表示标准矩阵乘法。这一推论是 MSM 在更长时间尺度上有效性的基础。\n\n给定以基础延迟 $\\tau$ 的均匀离散时间步长采样的状态轨迹 $\\{x_t\\}_{t=0}^{N-1}$，定义延迟-$L$ 转移计数矩阵 $C^{(L)}$ 为\n$$\nC_{ij}^{(L)} = \\left|\\left\\{ t \\in \\{0,\\dots,N-L-1\\} : x_t = i,\\, x_{t+L} = j \\right\\}\\right|,\n$$\n行和为 $n_i^{(L)} = \\sum_{j} C_{ij}^{(L)}$。延迟-$L$ 转移矩阵的最大似然估计是行归一化的计数，\n$$\n\\hat{T}_{ij}^{(L)} = \n\\begin{cases}\n\\dfrac{C_{ij}^{(L)}}{n_i^{(L)}},  n_i^{(L)}  0, \\\\\n0,  n_i^{(L)} = 0.\n\\end{cases}\n$$\n\n假设一个狄利克雷先验，其对每一行的每个结果都具有对称的集中度参数 $\\alpha_0$，这导致第 $i$ 行的狄利克雷后验为 $\\text{Dir}(\\alpha_0 + \\mathbf{n}_i)$，其中 $\\mathbf{n}_i$ 表示行计数的向量。元素 $p_{ij}^{(L)}$ 的边际后验是一个贝塔分布，\n$$\np_{ij}^{(L)} \\sim \\text{Beta}\\left(C_{ij}^{(L)} + \\alpha_0,\\, n_i^{(L)} - C_{ij}^{(L)} + (m-1)\\alpha_0\\right),\n$$\n其中 $m$ 是状态数。$p_{ij}^{(L)}$ 的 $100\\gamma\\%$ 可信区间通过贝塔分布的 $\\gamma$ 水平中心分位数获得。\n\n查普曼-科尔莫戈罗夫检验按以下步骤对一组整数延迟乘数 $\\{k\\}$ 进行：\n1. 从 $C^{(1)}$ 估计基础延迟矩阵 $\\hat{T}^{(1)}$。\n2. 对每个 $k$，计算查普曼-科尔莫戈罗夫预测 $\\left(\\hat{T}^{(1)}\\right)^k$，并从 $C^{(k)}$ 估计经验性延迟-$k$ 矩阵 $\\hat{T}^{(k)}$。\n3. 对每个满足 $n_i^{(k)} \\ge n_{\\min}$ 的行 $i$ 和每个列 $j$，使用贝塔边际分布计算 $p_{ij}^{(k)}$ 的后验可信区间 $[L_{ij}^{(k)}, U_{ij}^{(k)}]$，并检验预测条目 $\\left(\\hat{T}^{(1)}\\right)^k_{ij}$ 是否位于此区间内。\n4. 定义延迟 $k$ 处的覆盖分数为\n$$\n\\text{cov}(k) = \\frac{\\text{被覆盖的条目数}}{\\text{被测试的条目数}},\n$$\n其中被测试的条目是那些满足 $n_i^{(k)} \\ge n_{\\min}$ 的条目。如果 $\\text{cov}(k) \\ge \\theta$，则 MSM 在延迟 $k$ 处通过检验，其中 $\\theta$ 是与所选可信水平匹配的覆盖阈值。如果 MSM 在集合中所有 $k$ 值上都通过检验，则声明其对于该测试套件是有效的。\n\n您的任务是实现一个程序，该程序能够：\n- 从指定的基准真实转移矩阵生成合成轨迹。\n- 在基础延迟下构建 MSM，对多个 $k$ 值执行查普曼-科尔莫戈罗夫预测，计算经验性延迟-$k$ 转移矩阵，在对称狄利克雷先验下构建后验可信区间，并评估覆盖率。\n\n您的程序必须处理以下参数化的测试用例套件。\n\n测试用例 A（有效 MSM，长轨迹）：\n- 状态数 $m = 4$。\n- 基准真实基础延迟转移矩阵 $T^{\\text{true}}$ 为\n$$\n\\begin{bmatrix}\n0.90  0.07  0.02  0.01 \\\\\n0.06  0.88  0.05  0.01 \\\\\n0.03  0.05  0.88  0.04 \\\\\n0.01  0.02  0.06  0.91\n\\end{bmatrix}.\n$$\n- 轨迹长度 $N = 200000$ 步。\n- 延迟乘数 $\\{k\\} = \\{2,\\,5,\\,10\\}$。\n- 对称狄利克雷先验集中度 $\\alpha_0 = 0.5$（杰弗里斯先验）。\n- 可信水平 $\\gamma = 0.95$。\n- 最小行计数阈值 $n_{\\min} = 50$。\n- 覆盖阈值 $\\theta = 0.95$。\n\n测试用例 B（有效 MSM，较短轨迹）：\n- 状态数 $m = 4$。\n- 基准真实基础延迟转移矩阵 $T^{\\text{true}}$ 与测试用例 A 相同。\n- 轨迹长度 $N = 10000$ 步。\n- 延迟乘数 $\\{k\\} = \\{2,\\,10,\\,20\\}$。\n- 对称狄利克雷先验集中度 $\\alpha_0 = 0.5$。\n- 可信水平 $\\gamma = 0.95$。\n- 最小行计数阈值 $n_{\\min} = 50$。\n- 覆盖阈值 $\\theta = 0.95$。\n\n测试用例 C（投影下的无效 MSM，非马尔可夫粗粒化）：\n- 潜在的微观态数量 $m_{\\text{micro}} = 3$，标记为 $A$、$B$、$C$。\n- 微观态上的基准真实基础延迟转移矩阵为\n$$\n\\begin{bmatrix}\n0.75  0.25  0.00 \\\\\n0.10  0.80  0.10 \\\\\n0.00  0.005  0.995\n\\end{bmatrix}.\n$$\n- 观测到的粗粒化通过 $(A \\rightarrow X)$、$(B \\rightarrow Y)$、$(C \\rightarrow X)$ 将微观态映射到两个宏观态 $X$ 和 $Y$，产生一个观测到的 $m = 2$ 状态过程，由于 $A$ 和 $C$ 不同的逃逸倾向导致 $X$ 中存在记忆效应，该过程非马尔可夫。\n- 在微观态上生成长度为 $N = 200000$ 步的轨迹，随后映射到观测到的宏观态。\n- 延迟乘数 $\\{k\\} = \\{2,\\,5,\\,10\\}$。\n- 对称狄利克雷先验集中度 $\\alpha_0 = 0.5$。\n- 可信水平 $\\gamma = 0.95$。\n- 最小行计数阈值 $n_{\\min} = 50$。\n- 覆盖阈值 $\\theta = 0.95$。\n\n实现要求：\n- 使用固定的随机种子以保证可复现性。\n- 对每个测试用例，在基础延迟为 1 时从指定的基准真实转移矩阵模拟一条轨迹，估计 $\\hat{T}^{(1)}$，计算预测的 $\\left(\\hat{T}^{(1)}\\right)^k$，计算经验性 $\\hat{T}^{(k)}$，基于 $\\text{Beta}\\left(C_{ij}^{(k)} + \\alpha_0,\\, n_i^{(k)} - C_{ij}^{(k)} + (m-1)\\alpha_0\\right)$ 在水平 $\\gamma$ 上构建后验可信区间，并为每个 $k$ 评估 $\\text{cov}(k)$。测试用例返回一个布尔值，表示对于指定集合中的所有 $k$，是否满足 $\\text{cov}(k) \\ge \\theta$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，`[resultA,resultB,resultC]`），其中每个条目是对应测试用例通过或失败结果的布尔值。",
            "solution": "该问题是有效的。它提出了一个定义明确的计算任务，该任务基于计算统计力学中马尔可夫状态模型 (MSM) 验证的标准理论。它在科学上是合理的、客观的且完整的。所有参数和程序都已明确指定。\n\n问题的核心是实现并应用查普曼-科尔莫戈罗夫 (C-K) 检验进行 MSM 验证。如果底层动力学在所选状态空间上是马尔可夫的，那么 MSM 就是一个有用的近似。C-K 性质 $T(k\\tau) = [T(\\tau)]^k$ 为此马尔可夫性提供了一个必要条件。它断言，长延迟时间 $k\\tau$ 的转移概率可以通过简单地传播短基础延迟时间 $\\tau$ 的转移概率来预测。\n\n验证过程包括将此预测与在较长延迟时间下的转移矩阵的经验估计进行比较。如果系统确实是马尔可夫的，则预测应在统计不确定性范围内与经验测量结果一致。该过程如下：\n\n1.  **合成数据生成**：对于每个测试用例，模拟一个离散时间的状态轨迹 $\\{x_t\\}_{t=0}^{N-1}$。这通过从一个随机状态（例如，状态0）开始，并从由基准真实转移矩阵 $T^{\\text{true}}$ 的第 $x_t$ 行定义的多项分布中迭代抽取下一个状态 $x_{t+1}$ 来实现。对于测试用例 C，此模拟在底层的 3 态微观态空间上执行，然后根据指定的粗粒化规则将所得轨迹映射到观测到的 2 态宏观态空间：状态 $A \\to X$，$B \\to Y$，$C \\to X$。已知这种粗粒化会在观测过程中引入非马尔可夫动力学。\n\n2.  **转移矩阵的估计**：\n    -   从生成的轨迹中，我们首先估计基础延迟转移矩阵 $\\hat{T}^{(1)}$，其中延迟为 $\\tau=1$ 个时间步。这通过首先计算转移计数矩阵 $C^{(1)}$ 来完成，其中 $C_{ij}^{(1)}$ 是观测到的一步内从状态 $i$ 到状态 $j$ 的转移次数。然后，最大似然估计 (MLE) 是行归一化的计数矩阵：$\\hat{T}_{ij}^{(1)} = C_{ij}^{(1)} / \\sum_k C_{ik}^{(1)}$。\n    -   对于测试集中的每个延迟乘数 $k$，我们计算 C-K 预测，即基础延迟 MLE 矩阵的 $k$ 次幂：$T^{\\text{pred}}(k) = (\\hat{T}^{(1)})^k$。\n    -   我们还通过直接计算轨迹中超过 $k$ 步的转移来形成 $C^{(k)}$，然后进行行归一化，从而计算延迟 $k$ 处的经验转移矩阵 $\\hat{T}^{(k)}$。\n\n3.  **通过可信区间的统计比较**：关键步骤是确定预测 $T^{\\text{pred}}(k)$ 与经验估计 $\\hat{T}^{(k)}$ 之间的差异是否具有统计显著性。我们将经验估计不视为单个点，而是视为反映有限采样不确定性的分布。\n    -   使用具有对称狄利克雷先验（由 $\\alpha_0$ 参数化）的贝叶斯框架，每个转移概率 $p_{ij}^{(k)}$ 的后验分布是贝塔分布：$p_{ij}^{(k)} \\sim \\text{Beta}(C_{ij}^{(k)} + \\alpha_0, n_i^{(k)} - C_{ij}^{(k)} + (m-1)\\alpha_0)$，其中 $n_i^{(k)} = \\sum_j C_{ij}^{(k)}$ 是在延迟 $k$ 时从状态 $i$ 开始的总转移次数，$m$ 是状态数。\n    -   对于具有足够统计数据（$n_i^{(k)} \\ge n_{\\min}$）的行 $i$ 中的每个元素 $(i,j)$，我们计算一个 $100\\gamma\\%$ 的可信区间 $[L_{ij}^{(k)}, U_{ij}^{(k)}]$。该区间由贝塔后验分布的下分位数和上分位数定义，具体为 $(\\frac{1-\\gamma}{2})$ 和 $(1 - \\frac{1-\\gamma}{2})$ 分位数。\n    -   然后我们检查预测值 $(T^{\\text{pred}}(k))_{ij}$ 是否落在此区间内：$L_{ij}^{(k)} \\le (T^{\\text{pred}}(k))_{ij} \\le U_{ij}^{(k)}$。\n\n4.  **判定形成**：\n    -   延迟 $k$ 处的覆盖分数 $\\text{cov}(k)$ 被计算为预测落在可信区间内的被测矩阵元素的比例。\n    -   如果此覆盖分数大于或等于阈值 $\\theta$，即 $\\text{cov}(k) \\ge \\theta$，则认为 MSM 在延迟 $k$ 处通过了检验。阈值 $\\theta$ 通常设置为等于可信水平 $\\gamma$，这反映了对于一个有效的模型，大约 $100\\gamma\\%$ 的预测应该位于其相应的 $100\\gamma\\%$ 可信区间内的期望。\n    -   给定测试用例的最终结果是一个布尔值：如果 MSM 对所有指定的延迟乘数 $\\{k\\}$ 都通过了测试，则为 `True`，否则为 `False`。\n\n-   **测试用例 A（有效 MSM，长轨迹）**：底层过程是马尔可夫的，长轨迹提供了良好的统计数据。我们期望 C-K 预测是准确的，并且覆盖分数会很高（接近 $\\gamma=0.95$），因此会通过测试。\n-   **测试用例 B（有效 MSM，较短轨迹）**：过程仍然是马尔可夫的，但较短的轨迹导致更大的统计不确定性。这意味着 $\\hat{T}^{(k)}$ 的可信区间会更宽，但初始估计 $\\hat{T}^{(1)}$ 的精确度也会降低，导致预测 $(\\hat{T}^{(1)})^k$ 的误差更大。测试结果取决于这些效应中哪一个占主导。通常，可信区间宽度的增加足以维持高覆盖率。我们期望这个案例会通过。\n-   **测试用例 C（无效 MSM，粗粒化）**：粗粒化在观测到的动力学中引入了记忆效应，违反了马尔可夫假设。例如，从宏观态 $X$ 到 $Y$ 的转移概率取决于系统是处于微观态 $A$ 还是 $C$。MSM 对这些微观态进行平均，无法捕捉到这一点。基于错误的马尔可夫假设的 C-K 预测将系统地偏离真实的长时程动力学。我们期望覆盖分数会显著低于阈值 $\\theta$，导致测试失败。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import beta\n\ndef solve():\n    \"\"\"\n    Main function to run the Chapman-Kolmogorov test suite.\n    \"\"\"\n    # Set a fixed random seed for reproducibility.\n    np.random.seed(42)\n\n    # Define the test cases from the problem statement.\n    T_true_A_B = np.array([\n        [0.90, 0.07, 0.02, 0.01],\n        [0.06, 0.88, 0.05, 0.01],\n        [0.03, 0.05, 0.88, 0.04],\n        [0.01, 0.02, 0.06, 0.91]\n    ])\n\n    T_true_C_micro = np.array([\n        [0.75, 0.25, 0.00],\n        [0.10, 0.80, 0.10],\n        [0.00, 0.005, 0.995]\n    ])\n\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"m\": 4,\n            \"T_true\": T_true_A_B,\n            \"N\": 200000,\n            \"lags\": [2, 5, 10],\n            \"alpha0\": 0.5,\n            \"gamma\": 0.95,\n            \"n_min\": 50,\n            \"theta\": 0.95\n        },\n        {\n            \"name\": \"B\",\n            \"m\": 4,\n            \"T_true\": T_true_A_B,\n            \"N\": 10000,\n            \"lags\": [2, 10, 20],\n            \"alpha0\": 0.5,\n            \"gamma\": 0.95,\n            \"n_min\": 50,\n            \"theta\": 0.95\n        },\n        {\n            \"name\": \"C\",\n            \"m\": 2, # Number of macrostates\n            \"m_micro\": 3,\n            \"T_true\": T_true_C_micro,\n            \"N\": 200000,\n            \"lags\": [2, 5, 10],\n            \"alpha0\": 0.5,\n            \"gamma\": 0.95,\n            \"n_min\": 50,\n            \"theta\": 0.95,\n            \"coarse_grain_map\": np.array([0, 1, 0]) # A-X(0), B-Y(1), C-X(0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        case_result = run_ck_test(case)\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The map to str.lower is required for Python's bool capitalization (True vs true)\n    print(f\"[{','.join(map(lambda x: str(x).lower(), results))}]\")\n\n\ndef generate_trajectory(T_true, N, start_state=0):\n    \"\"\"\n    Generates a trajectory from a discrete-time Markov chain.\n    \"\"\"\n    num_states = T_true.shape[0]\n    traj = np.zeros(N, dtype=int)\n    traj[0] = start_state\n    for t in range(N - 1):\n        next_state_probs = T_true[traj[t], :]\n        traj[t+1] = np.random.choice(num_states, p=next_state_probs)\n    return traj\n\n\ndef get_count_matrix(trajectory, m, lag):\n    \"\"\"\n    Computes the transition count matrix for a given lag time.\n    \"\"\"\n    C = np.zeros((m, m), dtype=int)\n    for t in range(len(trajectory) - lag):\n        i = trajectory[t]\n        j = trajectory[t+lag]\n        C[i, j] += 1\n    return C\n\n\ndef get_mle_t_matrix(C):\n    \"\"\"\n    Computes the MLE transition matrix from a count matrix.\n    \"\"\"\n    m = C.shape[0]\n    T_mle = np.zeros((m, m))\n    row_sums = C.sum(axis=1)\n    # Using np.where to avoid division by zero\n    T_mle = np.where(row_sums[:, None] > 0, C / row_sums[:, None], 0)\n    return T_mle\n\n\ndef run_ck_test(params):\n    \"\"\"\n    Runs the full Chapman-Kolmogorov test for a single parameter set.\n    \"\"\"\n    m = params[\"m\"]\n    N = params[\"N\"]\n    T_true = params[\"T_true\"]\n    lags = params[\"lags\"]\n    alpha0 = params[\"alpha0\"]\n    gamma = params[\"gamma\"]\n    n_min = params[\"n_min\"]\n    theta = params[\"theta\"]\n\n    # --- 1. Generate Trajectory ---\n    if \"coarse_grain_map\" in params:\n        micro_traj = generate_trajectory(T_true, N)\n        trajectory = params[\"coarse_grain_map\"][micro_traj]\n    else:\n        trajectory = generate_trajectory(T_true, N)\n\n    # --- 2. Estimate Base-Lag Matrix ---\n    C1 = get_count_matrix(trajectory, m, lag=1)\n    T_hat_1 = get_mle_t_matrix(C1)\n\n    case_passes = True\n    for k in lags:\n        # --- 3. C-K Prediction ---\n        T_pred_k = np.linalg.matrix_power(T_hat_1, k)\n\n        # --- 4. Empirical Lag-k Matrix ---\n        Ck = get_count_matrix(trajectory, m, lag=k)\n        \n        # --- 5. Statistical Comparison ---\n        covered_entries = 0\n        tested_entries = 0\n        \n        row_sums_k = Ck.sum(axis=1)\n        \n        for i in range(m):\n            if row_sums_k[i]  n_min:\n                continue\n            \n            for j in range(m):\n                tested_entries += 1\n                \n                # Beta posterior parameters\n                alpha_post = Ck[i, j] + alpha0\n                beta_post = row_sums_k[i] - Ck[i, j] + (m - 1) * alpha0\n                \n                # Credible interval\n                q_low = (1.0 - gamma) / 2.0\n                q_high = 1.0 - q_low\n                \n                lower_bound = beta.ppf(q_low, alpha_post, beta_post)\n                upper_bound = beta.ppf(q_high, alpha_post, beta_post)\n\n                # Check if prediction is covered\n                prediction = T_pred_k[i, j]\n                if lower_bound = prediction = upper_bound:\n                    covered_entries += 1\n        \n        # --- 6. Verdict ---\n        if tested_entries > 0:\n            coverage_fraction = covered_entries / tested_entries\n        else: # No rows met n_min, technically passes as no violations found.\n            coverage_fraction = 1.0\n\n        if coverage_fraction  theta:\n            case_passes = False\n            break # Fail fast, no need to check other lags for this case\n\n    return case_passes\n\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}