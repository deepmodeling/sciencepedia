{
    "hands_on_practices": [
        {
            "introduction": "为了真正理解RNA的动态特性，我们不能仅仅满足于单一的静态结构，而必须考虑其所有可能构象组成的整个系综。这项练习将引导你运用统计力学的基本原理，实现一个简化的McCaskill算法，这是计算RNA生物学的一个基石，用以计算配分函数和碱基配对概率。通过完成这个练习，你将亲身体验支撑现代RNA二级结构预测与分析的动态规划技术。",
            "id": "3862545",
            "problem": "要求您实现一个完整的、可运行的程序，该程序在一个简化但科学上合理的热力学模型下，使用 McCaskill 算法的原理来计算一个核糖核酸（RNA）序列的系综性质。目标是推导并计算配分函数、碱基配对概率，并在指定温度条件下提取质心结构。设定为无假结（pseudoknot-free），并通过基于二级结构约束的热力学系综来强调三级结构的影响。\n\n首先从基本的统计力学概念开始：在绝对温度 $T$（单位为开尔文）下，一个自由能为 $G$ 的微观状态的玻尔兹曼权重为 $\\exp(-\\beta G)$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。配分函数 $Z$ 是允许的RNA结构系综中所有玻尔兹曼权重的总和，而碱基配对概率 $p_{ij}$ 是通过对位置 $i$ 和 $j$ 的核苷酸配对的微观状态进行边缘化得到的。\n\n该系综定义在非交叉（无假结）的碱基对上，并带有一个最小发夹环长度约束。从生物物理学角度看，只允许经典的沃森-克里克（Watson–Crick）配对和摆动配对（wobble pairs）：鸟嘌呤-胞嘧啶（Guanine–Cytosine, GC）、腺嘌呤-尿嘧啶（Adenine–Uracil, AU）和鸟嘌呤-尿嘧啶（Guanine–Uracil, GU），其互补配对（$\\mathrm{CG}$、$\\mathrm{UA}$、$\\mathrm{UG}$）也被允许。设 $n$ 为序列长度。只有当 $j - i - 1 \\ge m$ 时，位置 $i$ 和 $j$ 之间的碱基对才被允许，其中最小发夹环长度 $m$ 是指定的。\n\n能量模型和常数：\n- 所有能量单位均为千卡/摩尔（kcal/mol）。\n- 玻尔兹曼常数：$k_{\\mathrm{B}} = 0.0019872041$ kcal/(mol·K)。\n- 碱基对形成能：$G_{\\mathrm{bp}}(\\mathrm{GC}) = -3.0$, $G_{\\mathrm{bp}}(\\mathrm{AU}) = -2.0$, $G_{\\mathrm{bp}}(\\mathrm{GU}) = -1.0$（其反向互补对 $\\mathrm{CG}$、$\\mathrm{UA}$、$\\mathrm{UG}$ 的能量值相同）。\n- 一个碱基对堆积在相邻内部碱基对上的堆积能：$G_{\\mathrm{stack}} = -0.5$。\n- 作为环长度 $\\ell$ 函数的发夹环罚分：$G_{\\mathrm{hairpin}}(\\ell) = 3.0 + 0.2\\,\\ell + 0.5 \\ln(\\ell)$，对于 $\\ell \\ge m$。\n- 最小发夹环长度：$m = 3$。\n\n建模约束：\n- 序列位置从 $1,2,\\dots,n$ 索引。\n- 允许的结构是无假结的，由可能通过堆积扩展的茎（stem）构成；发夹环闭合茎，并且必须满足最小环长度约束。\n- 这个简化的热力学模型排除了凸起环（bulges）、内环（internal loops）和多分支环（multibranch loops）。它支持由发夹环闭合并通过堆积扩展的茎，这与一个用于通过系综平均推断三级结构背景的粗粒度系综相符。\n\n使用此模型和统计力学基础，实现一个动态规划算法，该算法：\n1. 计算给定RNA序列和温度 $T$ 的整个系综的配分函数 $Z$（无量纲）。\n2. 计算所有 $1 \\le i  j \\le n$ 的碱基配对概率矩阵项 $p_{ij}$。\n3. 在碱基对距离度量下计算质心结构，定义为最小化与系综的期望碱基对距离的结构。使用决策论等价性，即质心结构在所有有效的非交叉结构 $S$ 上最大化 $\\sum_{(i,j)\\in S} (2\\,p_{ij} - 1)$，并理解 $p_{ij} \\le 0.5$ 的碱基对贡献为非正值，应从最优结构中排除。将质心结构表示为一个包含 $n$ 个整数的列表，对于配对的位置使用基于1的伙伴索引，对于未配对的位置使用-1。\n\n要求的数值和输出规格：\n- 温度以开尔文（K）给出。能量以千卡/摩尔（kcal/mol）给出。配分函数是无量纲的。\n- 报告每个配分函数 $Z$，四舍五入到六位小数。\n- 对于每个测试用例，报告所有 $i",
            "solution": "用户提供了一个计算化学生物学问题，要求实现一个动态规划算法来计算RNA序列的热力学系综性质。该模型是已建立的RNA二级结构预测框架的一个特定简化版。\n\n### 步骤1：问题验证\n\n首先，提取并分析问题的已知条件，以确保问题在科学上是合理的、良定的（well-posed）和客观的。\n\n**提取已知条件：**\n\n*   **物理模型**：RNA折叠的统计力学，对自由能为 $G$、温度为 $T$ 的结构使用玻尔兹曼权重 $w = \\exp(-G / (k_{\\mathrm{B}} T))$。\n*   **系综定义**：该系综包含所有无假结的二级结构。\n*   **结构约束**：\n    *   允许的配对：鸟嘌呤-胞嘧啶（GC）、腺嘌呤-尿嘧啶（AU）、鸟嘌呤-尿嘧啶（GU）及其互补配对（CG、UA、UG）。\n    *   最小发夹环长度 $m=3$，意味着配对 $(i, j)$ 需要满足 $j-i-1 \\ge 3$。\n*   **能量模型（kcal/mol）**：\n    *   碱基对形成：$G_{\\mathrm{bp}}(\\mathrm{GC}) = -3.0$, $G_{\\mathrm{bp}}(\\mathrm{AU}) = -2.0$, $G_{\\mathrm{bp}}(\\mathrm{GU}) = -1.0$。\n    *   相邻碱基对的堆积：$G_{\\mathrm{stack}} = -0.5$。\n    *   长度为 $\\ell$ 的发夹环：$G_{\\mathrm{hairpin}}(\\ell) = 3.0 + 0.2\\ell + 0.5 \\ln(\\ell)$。\n    *   明确排除了凸起环、内环和多分支环的能量项。\n*   **常数**：$k_{\\mathrm{B}} = 0.0019872041$ kcal/(mol·K)。\n*   **索引**：序列索引是基于1的。\n*   **计算任务**：\n    1.  计算配分函数 $Z$。\n    2.  计算碱基配对概率矩阵 $p_{ij}$。\n    3.  计算质心结构，定义为在所有有效的非交叉结构 $S$ 中使总和 $\\sum_{(i,j)\\in S} (2p_{ij} - 1)$ 最大化的结构。\n*   **输出规格**：\n    *   $Z$ 和 $p_{\\max}$ 四舍五入到六位小数。\n    *   质心结构表示为基于1的伙伴索引列表（未配对的为-1）。\n*   **测试用例**：提供了四个特定的RNA序列和温度。\n\n**验证分析：**\n\n1.  **科学依据**：该问题在应用于RNA折叠的统计力学和生物物理化学原理方面有良好的基础。配分函数、玻尔兹曼权重和动态规划（如对 McCaskill 的引用所暗示的）的使用是该领域的标准方法。能量模型是一个简化版本，但已明确说明，并且其组成部分在物理上是合理的。排除某些类型的环是入门级处理或专门模型中的常见简化。\n2.  **“排除多分支环”的模糊性**：声明“排除了凸起环、内环和多分支环”是潜在模糊性的主要来源。在像 ViennaRNA 这样的完整能量模型的背景下，这意味着这些环是被禁止的。然而，在定义*能量贡献*的背景下，它也可能意味着这些结构基元是允许的，但其自由能贡献为 $0$（即它们的形成没有惩罚或奖励）。鉴于对 McCaskill 的引用以及计算系综性质的目标，完全禁止这些结构将导致一个高度限制性和非标准的系综（例如，仅单个茎环）。一个更合理的解释，它保留了问题的非平凡性，即一个结构的自由能*仅*由指定的项（碱基配对、堆积、发夹环）确定，而其他环的形成（内环、凸起环、多分支环）的自由能成本为零。\n3.  **良定性**：即使存在模糊性，也存在一个一致且可解的解释。一个特别连贯的解读，与“简化模型”的框架相一致，是将系综定义为仅由开放（无结构）链和所有可能的单个茎环结构组成。\n4.  **完整性**：在所选的解释下，所有必要的常数、公式和约束都已提供以实现解决方案。\n5.  **客观性**：问题以客观、可形式化的术语陈述。\n\n**结论**：问题是**有效的**。关于结构系综的模糊性可以通过对“无多分支环”规则采纳严格解释来解决，从而得到一个明确定义但简化的模型。这种解释是，系综仅限于单个非结构化状态和所有可能的单个茎环结构。\n\n### 步骤2：算法设计\n\n解决方案将通过一系列动态规划步骤实现。为方便起见，我们将在内部使用基于0的索引，在最终输出时转换为基于1的索引。设 $n$ 为序列长度。\n\n**1. 单个茎环的配分函数 ($Z_{\\mathrm{bp}}$)**\n\n我们首先计算 $Z_{\\mathrm{bp}}[i,j]$，即子序列 $i...j$ 上单个茎环结构的配分函数，条件是 $i$ 和 $j$ 形成最外层碱基对。该矩阵通过迭代递增的子序列长度（`diag` = $j-i$）来计算。\n\n要形成碱基对 $(i,j)$，需满足 $j-i-1 \\ge m$。\n值 $Z_{\\mathrm{bp}}[i,j]$ 是两种情况的玻尔兹曼权重之和：\na.  碱基对 $(i, j)$ 闭合一个发夹环。其权重为 $W_{\\mathrm{hairpin}} = \\exp(-\\beta(G_{\\mathrm{bp}}(S_i, S_j) + G_{\\mathrm{hairpin}}(j-i-1)))$。\nb.  碱基对 $(i, j)$ 堆积在内部碱基对 $(i+1, j-1)$ 之上。其权重为 $W_{\\mathrm{stack}} = \\exp(-\\beta(G_{\\mathrm{bp}}(S_i, S_j) + G_{\\mathrm{stack}})) \\times Z_{\\mathrm{bp}}[i+1, j-1]$。\n\n递推关系为：$Z_{\\mathrm{bp}}[i,j] = W_{\\mathrm{hairpin}} + W_{\\mathrm{stack}}$。\n\n**2. 总配分函数 ($Z$)**\n\n根据我们的解释，总系综由非结构化状态（权重为1）和所有可能的单个茎环组成。总配分函数 $Z$ 是所有这些结构权重之和。\n$$Z = 1 + \\sum_{0 \\le i  j  n} Z_{\\mathrm{bp}}[i,j]$$\n\n**3. 碱基配对概率 ($p_{ij}$)**\n\n一个碱基对 $(k,l)$ 的概率 $p_{kl}$ 是系综中所有包含该碱基对的结构的概率之和，再除以 $Z$。在我们的简化系综中，一个碱基对 $(k,l)$ 可以作为茎环的最外层对存在，也可以作为堆积在更大茎环内的内部对存在。\n\n设 $P'_{kl}$ 为系综中所有包含碱基对 $(k,l)$ 的结构的玻尔兹曼权重之和。\n$p_{kl} = P'_{kl} / Z$。\n\n$P'_{kl}$ 本身可以用动态规划计算。\n$P'_{kl} = Z_{\\mathrm{bp}}[k,l] \\times (1 + \\text{作为内部对的贡献})$\n设 $Z_{\\mathrm{out\\_stack}}[k,l]$ 为一个因子，表示在碱基对 $(k,l)$ *之上* 形成碱基对堆叠的所有方式的权重之和。\n$Z_{\\mathrm{out\\_stack}}[k,l] = 1 + W_{S}(k-1, l+1) \\times Z_{\\mathrm{out\\_stack}}[k-1, l+1]$，其中 $W_{S}$ 是形成外部堆叠的玻尔兹曼权重。\n项 $1$ 解释了 $(k,l)$ 是最外层碱基对的情况。\n那么，$P'_{kl} = Z_{\\mathrm{bp}}[k,l] \\times Z_{\\mathrm{out\\_stack}}[k,l]$。这可以通过一个从短到长子序列长度迭代的动态规划来计算。\n\n**4. 质心结构**\n\n质心结构是使分数 $\\sum_{(i,j)\\in S} \\gamma_{ij}$ 最大化的有效非交叉结构 $S$，其中 $\\gamma_{ij} = 2p_{ij} - 1$。这是一个可以用动态规划解决的优化问题。虽然该优化可以在包含多分支环的完整二级结构空间上进行，但为了与问题的简化模型保持一致，我们这里也采用一个不允许真正多分支环（即一个环分支出两个或更多茎）的简化版动态规划。设 $C[i,j]$ 为子序列 $i...j$ 上结构的最大分数。它通过一个动态规划递推关系计算，该关系考虑了碱基 $j$ 未配对或与前面的某个碱基 $k$ 配对的情况：\n$$C[i,j] = \\max \\begin{cases} C[i, j-1]   (\\text{碱基 } j \\text{ 未配对}) \\\\ \\max_{i \\le k  j-m} (C[i, k-1] + \\gamma_{kj} + C[k+1, j-1])   (\\text{碱基 } j \\text{ 与 } k \\text{ 配对})\\end{cases}$$\n基本情况是，如果 $j-i  m+1$，则 $C[i,j]=0$。如果项 $C[i,k-1]$ 和 $C[k+1,j-1]$ 的索引定义了空或无效的子序列，则它们被设为0。\n通过对DP矩阵 $C$ 进行回溯，可以重建最优质心结构中的碱基对。\n\n这个综合计划解决了问题的所有要求。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes RNA ensemble properties (partition function, pairing probabilities,\n    and centroid structure) based on a simplified thermodynamic model.\n    \"\"\"\n    # ------------------- GIVENS AND SETUP -------------------\n    KB = 0.0019872041  # Boltzmann constant in kcal/(mol·K)\n    G_BP = {\n        'AU': -2.0, 'UA': -2.0,\n        'GC': -3.0, 'CG': -3.0,\n        'GU': -1.0, 'UG': -1.0\n    }\n    G_STACK = -0.5\n    MIN_LOOP_LEN = 3\n\n    test_cases = [\n        (\"GCAAUUGC\", 310.15),\n        (\"GGGGCCCC\", 295.00),\n        (\"ACGUACGU\", 400.00),\n        (\"AAAAAAA\", 310.15)\n    ]\n\n    # ------------------- HELPER FUNCTIONS -------------------\n    def is_valid_pair(seq, i, j):\n        \"\"\"Checks if bases at i and j can form a canonical pair.\"\"\"\n        if i  0 or i >= len(seq) or j  0 or j >= len(seq):\n            return False\n        return seq[i] + seq[j] in G_BP\n\n    def hairpin_energy(length):\n        \"\"\"Calculates hairpin loop energy.\"\"\"\n        if length  MIN_LOOP_LEN:\n            return float('inf')\n        return 3.0 + 0.2 * length + 0.5 * math.log(length)\n\n    # ------------------- MAIN PROCESSING LOOP -------------------\n    all_results = []\n    for seq, temp in test_cases:\n        n = len(seq)\n        if n == 0:\n            all_results.append([1.0, 0.0, []])\n            continue\n        \n        beta = 1.0 / (KB * temp)\n\n        # -------- 1. DP for Z_bp (Partition function of a single stem-loop) --------\n        z_bp = np.zeros((n, n))\n        for diag in range(MIN_LOOP_LEN + 1, n):\n            for i in range(n - diag):\n                j = i + diag\n                \n                if not is_valid_pair(seq, i, j):\n                    continue\n\n                g_bp_val = G_BP[seq[i] + seq[j]]\n                \n                # Hairpin contribution\n                loop_len = j - i - 1\n                g_hairpin = hairpin_energy(loop_len)\n                w_hairpin = math.exp(-beta * (g_bp_val + g_hairpin))\n                z_bp[i, j] += w_hairpin\n\n                # Stacking contribution\n                if j - i - 3 >= MIN_LOOP_LEN and is_valid_pair(seq, i + 1, j - 1):\n                    w_stack = math.exp(-beta * (g_bp_val + G_STACK))\n                    z_bp[i, j] += w_stack * z_bp[i + 1, j - 1]\n\n        # -------- 2. Total Partition Function Z --------\n        total_z = 1.0 + np.sum(z_bp)\n\n        # -------- 3. Base Pairing Probabilities p_ij --------\n        z_out_stack = np.zeros((n, n))\n        for diag in range(MIN_LOOP_LEN + 1, n):\n            for i in range(n - diag):\n                j = i + diag\n                z_out_stack[i, j] = 1.0\n                \n                if i > 0 and j  n - 1 and is_valid_pair(seq, i - 1, j + 1):\n                    g_bp_outer = G_BP[seq[i - 1] + seq[j + 1]]\n                    w_s_outer = math.exp(-beta * (g_bp_outer + G_STACK))\n                    z_out_stack[i, j] += w_s_outer * z_out_stack[i - 1, j + 1]\n\n        probs = np.zeros((n, n))\n        if total_z > 1e-12:\n            probs = (z_bp * z_out_stack) / total_z\n        \n        p_max = np.max(probs) if probs.size > 0 else 0.0\n\n        # -------- 4. Centroid Structure Calculation (Zuker-style DP) --------\n        gamma = 2.0 * probs - 1.0\n        c = np.zeros((n, n))\n        trace = {}\n\n        for l in range(1, n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                if j - i  MIN_LOOP_LEN + 1:\n                    continue\n                \n                score_unpaired = c[i, j - 1]\n                \n                max_k_score = -float('inf')\n                best_k = -1\n                for k in range(i, j - MIN_LOOP_LEN):\n                    score_k = gamma[k, j]\n                    if k > i: score_k += c[i, k - 1]\n                    if k + 1 = j - 1: score_k += c[k + 1, j - 1]\n\n                    if score_k > max_k_score:\n                        max_k_score = score_k\n                        best_k = k\n                \n                if score_unpaired >= max_k_score:\n                    c[i, j] = score_unpaired\n                    trace[(i, j)] = -1\n                else:\n                    c[i, j] = max_k_score\n                    trace[(i, j)] = best_k\n        \n        # -------- 5. Traceback for Centroid Structure --------\n        centroid_struct = [-1] * n\n        pair_list = []\n        q = [(0, n - 1)]\n        \n        while q:\n            i, j = q.pop()\n            if j - i  MIN_LOOP_LEN + 1: continue\n\n            decision = trace.get((i, j))\n            if decision is None:\n                continue\n\n            if decision == -1:\n                q.append((i, j - 1))\n            else:\n                k = decision\n                pair_list.append((k, j))\n                if k > i: q.append((i, k - 1))\n                if k + 1 = j - 1: q.append((k + 1, j - 1))\n        \n        for p1, p2 in pair_list:\n            centroid_struct[p1] = p2 + 1\n            centroid_struct[p2] = p1 + 1\n\n        all_results.append(\n            [round(total_z, 6), round(p_max, 6), centroid_struct]\n        )\n\n    # -------- 6. Final Formatting --------\n    result_strings = []\n    for z, p, c_list in all_results:\n        c_str = '[' + ','.join(map(str, c_list)) + ']'\n        result_strings.append(f\"[{z},{p},{c_str}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "RNA的三维结构及其功能在很大程度上受到与周围离子溶液的静电相互作用的影响。本练习要求你推导并应用线性化泊松-玻尔兹曼方程——生物物理化学中的一个基本模型——来估算RNA螺旋的表面静电势。这项实践将加深你对连续介质静电模型如何将盐浓度等宏观性质与螺旋对接倾向等分子层面现象联系起来的理解。",
            "id": "3862509",
            "problem": "您的任务是推导、实现并评估一个计算模型，该模型使用线性化泊松-玻尔兹曼 (LPB) 框架估算核糖核酸 (RNA) 螺旋的静电表面势，并将此表面势与螺旋-螺旋对接的倾向性联系起来。RNA 螺旋将被近似为一个浸入对称电解质溶液中的无限长、均匀带电的圆柱体。目标是使用科学上合理的近似，将基础静电学和统计力学与可测量的对接倾向性联系起来。\n\n从以下基本原理开始：\n- 静电学中的泊松方程，该方程指出静电势 $\\,\\phi(\\mathbf{r})\\,$ 满足 $\\,\\nabla \\cdot (\\epsilon \\nabla \\phi) = -\\rho(\\mathbf{r})\\,$，其中 $\\,\\epsilon\\,$ 是介质的介电常数，$\\,\\rho(\\mathbf{r})\\,$ 是电荷密度。\n- 溶液中移动离子的玻尔兹曼分布，这意味着价为 $\\,z_i\\,$ 的离子种类 $\\,i\\,$ 的局部数密度 $\\,c_i(\\mathbf{r})\\,$ 服从 $\\,c_i(\\mathbf{r}) = c_i^\\infty \\exp\\!\\left(-\\dfrac{z_i e \\phi(\\mathbf{r})}{k_B T}\\right)\\,$，其中 $\\,e\\,$ 是元电荷，$\\,k_B\\,$ 是玻尔兹曼常数，$\\,T\\,$ 是绝对温度。\n- 德拜-休克尔近似（线性化泊松-玻尔兹曼），在 $\\,\\left|\\dfrac{z_i e \\phi}{k_B T}\\right| \\ll 1\\,$ 时有效，在该近似下，移动离子电荷密度可以线性化，从而得到电解质中电势的线性化泊松-玻尔兹曼方程：在没有固定电荷的区域中为 $\\,\\nabla^2 \\phi = \\kappa^2 \\phi\\,$，其中德拜参数 $\\,\\kappa\\,$ 由电解质组成、介电常数、温度和离子强度定义。\n\n对于一个半径为 $\\,a\\,$、表面电荷密度均匀为 $\\,\\sigma\\,$ 的无限长圆柱体，使用柱坐标。在圆柱体外部（$\\,r \\ge a\\,$），没有固定电荷，因此控制方程简化为关于 $\\,\\phi(r)\\,$ 的修正贝塞尔方程。施加物理上正确的边界条件：$\\,\\phi(r)\\,$ 在无穷远处衰减，以及在圆柱体表面由 $\\,\\sigma\\,$ 决定的法向位移场连续性。由此推导出表面势 $\\,\\phi(a)\\,$ 的表达式。不要使用或引用任何预先推导出的针对圆柱体的电势公式；从所述原理推导出结果。\n\n接下来，为了将表面势与螺旋-螺旋对接倾向性联系起来，将每个 RNA 螺旋近似为有效线电荷密度为 $\\,\\lambda = 2\\pi a \\sigma\\,$ 的线电荷。对于两个平行的、相同的圆柱体，中心距为 $\\,D = 2 a + s\\,$（其中 $\\,s\\,$ 是最近的表面间隙），使用德拜-休克尔相互作用来模拟单位长度的静电相互作用能 $\\,U/L\\,$，即一个线电荷与另一个线电荷产生的屏蔽势之间的相互作用。然后使用玻尔兹曼因子定义无量纲对接倾向性 $\\,P\\,$，即 $\\,P = \\exp\\!\\left(-\\dfrac{U}{k_B T}\\right)\\,$，其中 $\\,U = (U/L)\\,L_{\\mathrm{eff}}\\,$ 且 $\\,L_{\\mathrm{eff}}\\,$ 是有效接触长度。基于所述的第一性原理和近似，解释所有建模选择。\n\n实现要求：\n- 计算摩尔浓度为 $\\,c\\,$（单位为 $\\mathrm{mol}/\\mathrm{m}^3$）的对称 $\\,z\\!:\\!z\\,$ 电解质的德拜参数 $\\,\\kappa\\,$，使用离子强度 $\\,I = z^2 c\\,$ 和关系式 $\\,\\kappa^2 = \\dfrac{2 e^2 N_A I}{\\epsilon k_B T}\\,$，其中 $\\,N_A\\,$ 是阿伏伽德罗常数，$\\,\\epsilon = \\epsilon_r \\epsilon_0\\,$，$\\,\\epsilon_r\\,$ 是相对介电常数，$\\,\\epsilon_0\\,$ 是真空介电常数。\n- 根据柱坐标几何中的 LPB 解和涉及 $\\,\\sigma\\,$ 的正确边界条件，推导并实现表面势 $\\,\\phi(a)\\,$。\n- 计算 $\\,\\lambda = 2\\pi a \\sigma\\,$、$\\,D = 2 a + s\\,$，然后通过德拜-休克尔计算 $\\,U/L\\,$，最后通过玻尔兹曼因子计算 $\\,P\\,$。\n- 以伏特 (V) 为单位表示表面势 $\\,\\phi(a)\\,$。以 $\\,\\left[0,1\\right]\\,$ 范围内的无量纲小数表示对接倾向性 $\\,P\\,$。将每个浮点数四舍五入到六位小数。\n\n待使用的常量（国际单位制）：\n- 元电荷 $\\,e = 1.602176634 \\times 10^{-19}\\,\\mathrm{C}\\,$\n- 玻尔兹曼常数 $\\,k_B = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}\\,$\n- 真空介电常数 $\\,\\epsilon_0 = 8.8541878128 \\times 10^{-12}\\,\\mathrm{F/m}\\,$\n- 阿伏伽德罗常数 $\\,N_A = 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1}\\,$\n\n您的程序必须评估以下测试套件。每个测试用例是一个元组 $(a,\\sigma,c,z,\\epsilon_r,T,s,L_{\\mathrm{eff}})$，除无量纲的价 $\\,z\\,$ 外，所有量均采用国际单位制：\n- 情况1（正常路径）：$\\,a = 1.2\\times 10^{-9}\\,$, $\\,\\sigma = -0.05\\,$, $\\,c = 100\\,$, $\\,z = 1\\,$, $\\,\\epsilon_r = 78.5\\,$, $\\,T = 298\\,$, $\\,s = 5.0\\times 10^{-10}\\,$, $\\,L_{\\mathrm{eff}} = 5.0\\times 10^{-9}\\,$。\n- 情况2（高盐边界）：$\\,a = 1.2\\times 10^{-9}\\,$, $\\,\\sigma = -0.05\\,$, $\\,c = 1000\\,$, $\\,z = 1\\,$, $\\,\\epsilon_r = 78.5\\,$, $\\,T = 298\\,$, $\\,s = 5.0\\times 10^{-10}\\,$, $\\,L_{\\mathrm{eff}} = 5.0\\times 10^{-9}\\,$。\n- 情况3（低盐边缘）：$\\,a = 1.2\\times 10^{-9}\\,$, $\\,\\sigma = -0.05\\,$, $\\,c = 10\\,$, $\\,z = 1\\,$, $\\,\\epsilon_r = 78.5\\,$, $\\,T = 298\\,$, $\\,s = 5.0\\times 10^{-10}\\,$, $\\,L_{\\mathrm{eff}} = 5.0\\times 10^{-9}\\,$。\n- 情况4（接触极限 $\\,s = 0\\,$）：$\\,a = 1.2\\times 10^{-9}\\,$, $\\,\\sigma = -0.05\\,$, $\\,c = 100\\,$, $\\,z = 1\\,$, $\\,\\epsilon_r = 78.5\\,$, $\\,T = 298\\,$, $\\,s = 0.0\\,$, $\\,L_{\\mathrm{eff}} = 5.0\\times 10^{-9}\\,$。\n- 情况5（二价电解质及更强电荷）：$\\,a = 1.0\\times 10^{-9}\\,$, $\\,\\sigma = -0.08\\,$, $\\,c = 50\\,$, $\\,z = 2\\,$, $\\,\\epsilon_r = 78.5\\,$, $\\,T = 298\\,$, $\\,s = 1.0\\times 10^{-9}\\,$, $\\,L_{\\mathrm{eff}} = 8.0\\times 10^{-9}\\,$。\n- 情况6（大间距）：$\\,a = 1.5\\times 10^{-9}\\,$, $\\,\\sigma = -0.03\\,$, $\\,c = 20\\,$, $\\,z = 1\\,$, $\\,\\epsilon_r = 78.5\\,$, $\\,T = 298\\,$, $\\,s = 5.0\\times 10^{-9}\\,$, $\\,L_{\\mathrm{eff}} = 1.0\\times 10^{-8}\\,$。\n\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个测试用例的结果本身是一个双元素列表 $[\\phi(a),P]$，每个浮点数四舍五入到六位小数。例如，输出格式为 $[[\\phi_1,P_1],[\\phi_2,P_2],\\dots]$，不含空格。",
            "solution": "该问题是有效的，因为它在科学上基于经典静电学和统计力学的原理，特别是泊松-玻尔兹曼框架。该问题表述清晰，提供了所有必要的物理常数、参数和边界条件，以推导和计算出唯一解。该模型将 RNA 螺旋近似为带电圆柱体和线电荷，是计算生物物理学中一个标准且具有启发性的简化方法。任务是从第一性原理出发，推导静电表面势和对接倾向性，然后通过计算实现这个模型。\n\n### 第一部分：表面势 $\\,\\phi(a)\\,$ 的推导\n\n该系统由一个半径为 $\\,a\\,$、表面电荷密度均匀为 $\\,\\sigma\\,$ 的无限长圆柱体组成，浸没在对称的 $\\,z\\!:\\!z\\,$ 电解质中。圆柱体外部（$\\,r \\ge a\\,$）的静电势 $\\,\\phi\\,$ 由线性化泊松-玻尔兹曼 (LPB) 方程控制。由于问题的圆柱对称性，电势 $\\,\\phi\\,$ 仅是径向坐标 $\\,r\\,$ 的函数。\n\n在柱坐标系中，$\\,\\phi(r)\\,$ 的 LPB 方程为：\n$$ \\nabla^2 \\phi(r) = \\frac{1}{r} \\frac{d}{dr}\\left(r \\frac{d\\phi}{dr}\\right) = \\kappa^2 \\phi(r) $$\n其中 $\\,\\kappa\\,$ 是德拜长度的倒数。重新整理后，得到一个标准的微分方程形式：\n$$ r^2 \\frac{d^2\\phi}{dr^2} + r \\frac{d\\phi}{dr} - (\\kappa r)^2 \\phi(r) = 0 $$\n这是零阶修正贝塞尔方程。其通解是第一类修正贝塞尔函数（$\\,I_0\\,$）和第二类修正贝塞尔函数（$\\,K_0\\,$）的线性组合：\n$$ \\phi(r) = A I_0(\\kappa r) + B K_0(\\kappa r) $$\n其中 $\\,A\\,$ 和 $\\,B\\,$ 是由边界条件决定的常数。\n\n我们应用两个边界条件：\n1.  在离带电圆柱体无穷远处，电势必须为零：当 $\\,r \\to \\infty\\,$ 时，$\\,\\phi(r) \\to 0\\,$。函数 $\\,I_0(x)\\,$ 在 $\\,x\\,$ 很大时呈指数增长，而 $\\,K_0(x)\\,$ 则衰减至零。为满足此条件，系数 $\\,A\\,$ 必须为零。因此，解简化为：\n    $$ \\phi(r) = B K_0(\\kappa r) $$\n2.  在圆柱体表面，电位移场法向分量的间断等于表面电荷密度 $\\,\\sigma\\,$。这是高斯定律在带电界面上的体现。电场为 $\\,\\mathbf{E} = -\\nabla\\phi\\,$，在此几何结构中给出 $\\,E_r = -d\\phi/dr\\,$。位移场为 $\\,\\mathbf{D} = \\epsilon\\mathbf{E}\\,$。在 $\\,r=a\\,$ 处的边界条件是 $\\,- \\left. \\epsilon \\frac{d\\phi}{dr} \\right|_{r=a} = \\sigma\\,$，其中 $\\,\\epsilon = \\epsilon_r\\epsilon_0\\,$ 是电解质溶液的介电常数。\n\n为应用此条件，我们首先计算 $\\,\\phi(r)\\,$ 的导数：\n$$ \\frac{d\\phi}{dr} = B \\frac{d}{dr}K_0(\\kappa r) $$\n使用恒等式 $\\,\\frac{d}{dx}K_0(x) = -K_1(x)\\,$ 和链式法则，我们有：\n$$ \\frac{d\\phi}{dr} = B (-\\kappa K_1(\\kappa r)) = -B\\kappa K_1(\\kappa r) $$\n现在，在 $\\,r=a\\,$ 处应用边界条件：\n$$ - \\epsilon (-B\\kappa K_1(\\kappa a)) = \\sigma $$\n$$ B \\epsilon \\kappa K_1(\\kappa a) = \\sigma $$\n解出常数 $\\,B\\,$：\n$$ B = \\frac{\\sigma}{\\epsilon \\kappa K_1(\\kappa a)} $$\n将 $\\,B\\,$ 代回 $\\,\\phi(r)\\,$ 的表达式，得到圆柱体外部的电势分布：\n$$ \\phi(r) = \\frac{\\sigma K_0(\\kappa r)}{\\epsilon \\kappa K_1(\\kappa a)} $$\n表面势 $\\,\\phi(a)\\,$ 是在 $\\,r=a\\,$ 处计算的电势：\n$$ \\phi(a) = \\frac{\\sigma K_0(\\kappa a)}{\\epsilon \\kappa K_1(\\kappa a)} $$\n这就是我们将要实现的表达式。\n\n### 第二部分：对接倾向性 $\\,P\\,$ 的推导\n\n为了模拟两个平行 RNA 螺旋之间的相互作用，我们通过将每个螺旋近似为无限长线电荷来进一步简化模型。有效线电荷密度 $\\,\\lambda\\,$ 是单位长度的总电荷，通过将表面电荷密度 $\\,\\sigma\\,$ 沿圆柱体周长积分得到：\n$$ \\lambda = (2\\pi a) \\sigma $$\n这两个中心距为 $\\,D\\,$ 的平行线电荷之间的静电相互作用由屏蔽库仑（德拜-休克尔）势控制。单个线电荷 $\\,\\lambda\\,$ 在电解质中产生的电势是带线源的 LPB 方程的解，由下式给出：\n$$ \\phi_{\\text{line}}(r) = \\frac{\\lambda}{2\\pi\\epsilon} K_0(\\kappa r) $$\n两个相同的平行螺旋之间每单位长度的相互作用能 $\\,U/L\\,$ 是将一个线电荷带入另一个线电荷的电势场中所做的功。因此，\n$$ \\frac{U}{L} = \\lambda \\cdot \\phi_{\\text{line}}(D) = \\lambda \\left( \\frac{\\lambda}{2\\pi\\epsilon} K_0(\\kappa D) \\right) = \\frac{\\lambda^2}{2\\pi\\epsilon} K_0(\\kappa D) $$\n中心距 $\\,D\\,$ 是两个相同圆柱体半径之和（$\\,2a\\,$）与表面间隙 $\\,s\\,$ 之和：$\\,D = 2a + s\\,$。\n\n在有效接触长度 $\\,L_{\\mathrm{eff}}\\,$ 上的总相互作用能 $\\,U\\,$ 为：\n$$ U = \\left( \\frac{U}{L} \\right) L_{\\mathrm{eff}} = \\frac{\\lambda^2 L_{\\mathrm{eff}}}{2\\pi\\epsilon} K_0(\\kappa D) $$\n最后，无量纲对接倾向性 $\\,P\\,$ 通过玻尔兹曼因子定义，该因子将相互作用能与热能标度 $\\,k_B T\\,$ 联系起来：\n$$ P = \\exp\\left(-\\frac{U}{k_B T}\\right) $$\n在热平衡的假设下，该因子表示系统处于对接构型的概率，相对于无限分离状态。\n\n### 第三部分：计算实现\n\n实现需要首先计算德拜参数 $\\,\\kappa\\,$。对于摩尔浓度为 $\\,c\\,$（单位为 $\\mathrm{mol}/\\mathrm{m}^3$）的对称 $\\,z\\!:\\!z\\,$ 电解质，离子强度为 $\\,I = z^2 c\\,$。则德拜参数由下式给出：\n$$ \\kappa = \\sqrt{\\frac{2 e^2 N_A I}{\\epsilon k_B T}} $$\n计算出 $\\,\\kappa\\,$ 后，我们可以使用上面推导的公式以及提供的物理常数和测试用例参数来计算 $\\,\\phi(a)\\,$ 和 $\\,P\\,$。修正贝塞尔函数 $\\,K_0(x)\\,$ 和 $\\,K_1(x)\\,$ 可在科学计算库（如 `scipy.special`）中找到。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import k0, k1\n\ndef solve():\n    \"\"\"\n    Derives, implements, and evaluates a computational model for RNA helix\n    electrostatic potential and docking propensity.\n    \"\"\"\n\n    # Physical Constants in SI units\n    E_CHARGE = 1.602176634e-19  # Elementary charge (C)\n    KB_CONST = 1.380649e-23      # Boltzmann constant (J/K)\n    EPSILON_0 = 8.8541878128e-12 # Vacuum permittivity (F/m)\n    NA_AVOGADRO = 6.02214076e23  # Avogadro's number (mol^-1)\n    PI = np.pi\n\n    test_cases = [\n        # (a, sigma, c, z, epsilon_r, T, s, L_eff)\n        (1.2e-9, -0.05, 100, 1, 78.5, 298, 5.0e-10, 5.0e-9),  # Case 1\n        (1.2e-9, -0.05, 1000, 1, 78.5, 298, 5.0e-10, 5.0e-9), # Case 2\n        (1.2e-9, -0.05, 10, 1, 78.5, 298, 5.0e-10, 5.0e-9),   # Case 3\n        (1.2e-9, -0.05, 100, 1, 78.5, 298, 0.0, 5.0e-9),      # Case 4\n        (1.0e-9, -0.08, 50, 2, 78.5, 298, 1.0e-9, 8.0e-9),   # Case 5\n        (1.5e-9, -0.03, 20, 1, 78.5, 298, 5.0e-9, 1.0e-8),   # Case 6\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a, sigma, c, z, epsilon_r, T, s, L_eff = case\n\n        # 1. Calculate intermediate parameters\n        epsilon = epsilon_r * EPSILON_0\n        kBT = KB_CONST * T\n        I = (z**2) * c  # Ionic strength in mol/m^3 for a symmetric z:z electrolyte\n\n        # 2. Calculate the Debye parameter (kappa)\n        kappa_sq = (2 * E_CHARGE**2 * NA_AVOGADRO * I) / (epsilon * kBT)\n        kappa = np.sqrt(kappa_sq)\n\n        # 3. Calculate the surface potential phi(a)\n        # phi(a) = (sigma * K0(kappa*a)) / (epsilon * kappa * K1(kappa*a))\n        kappa_a = kappa * a\n        k0_kappa_a = k0(kappa_a)\n        k1_kappa_a = k1(kappa_a)\n        \n        # Avoid division by zero if K1(kappa*a) is zero (for kappa*a -> 0), though unlikely for given parameters\n        if k1_kappa_a == 0:\n            phi_a = float('inf') if sigma != 0 else 0\n        else:\n            phi_a = (sigma * k0_kappa_a) / (epsilon * kappa * k1_kappa_a)\n\n        # 4. Calculate the docking propensity P\n        # Linear charge density\n        lambda_charge = 2 * PI * a * sigma\n        \n        # Center-to-center distance\n        D = 2 * a + s\n        \n        # Interaction energy\n        # U/L = (lambda^2 / (2*pi*epsilon)) * K0(kappa*D)\n        # U = (U/L) * L_eff\n        kappa_D = kappa * D\n        k0_kappa_D = k0(kappa_D)\n        \n        U_per_L = (lambda_charge**2 * k0_kappa_D) / (2 * PI * epsilon)\n        U = U_per_L * L_eff\n        \n        # Propensity\n        # P = exp(-U / kBT)\n        # Since lambda is squared, U is positive (repulsive).\n        # sigma is negative, so lambda is negative, but lambda^2 is positive.\n        propensity_P = np.exp(-U / kBT)\n        \n        # 5. Round results and store\n        phi_a_rounded = round(phi_a, 6)\n        propensity_P_rounded = round(propensity_P, 6)\n        \n        results.append(f\"[{phi_a_rounded},{propensity_P_rounded}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "合成生物学和纳米技术的一个主要目标是设计能够折叠成特定的、预先确定的三维形状的RNA分子。这项实践介绍了反向折叠的原理，你将利用一个粗粒度的热力学模型和优化策略，为一个目标三级拓扑结构设计序列。通过应对这一设计挑战，你将学会如何将序列信息与折叠概率联系起来，这是合理设计功能性RNA分子的关键技能。",
            "id": "3862520",
            "problem": "给定一个粗粒度热力学模型，用于设计核糖核酸（RNA）序列，以最大化其折叠成预设三级接触拓扑结构的概率。该拓扑结构被编码为序列位置上的一组二元接触，模型根据核苷酸对的类型为每个实现的接触分配一个能量，同时允许以一定代价跳过某些接触。该预测框架依赖于玻尔兹曼分布，即在绝对温度 $T$ 下，能量为 $E$ 的构象出现的概率正比于 $\\exp(-\\beta E)$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。任务是：通过一个基于可行接触实现状态的配分函数，来构建特定拓扑结构的折叠概率公式；推导一个算法来设计能最大化目标拓扑结构概率的序列；并将其实现为一个确定性程序。\n\n基本原理：\n- 热力学系综与玻尔兹曼分布：能量为 $E$ 的微观状态出现的概率 $p \\propto \\exp(-\\beta E)$。\n- 独立相互作用和可行性约束下的自由能可加性：当相互作用被允许且两两之间的冲突得到遵守时，总能量等于各项贡献之和。\n\n模型定义：\n- RNA核苷酸的字母表为 $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$，位置索引为 $i \\in \\{1,\\dots,N\\}$。\n- 目标三级拓扑结构由一个无向接触集合 $E = \\{(i,j)\\}$ 定义，其中 $1 \\le i  j \\le N$。每个接触代表一个潜在的长程三级相互作用。\n- 每个接触 $(i,j)$ 可以被实现或跳过。令 $x_{(i,j)} \\in \\{0,1\\}$ 表示实现状态，其中 $x_{(i,j)} = 1$ 表示实现，$x_{(i,j)} = 0$ 表示跳过。\n- 可行性约束：每个位置最多只能有一个实现的接触。形式上，对于任何 $x_{(i,j)} = 1$ 的接触集合 $\\{(i,j)\\}$，索引 $i$ 或 $j$ 在实现的接触中出现的次数不能超过一次。\n- 成对接触能量函数 $E_{\\mathrm{pair}}(b_i,b_j)$，单位为千卡/摩尔，其中 $b_i, b_j \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$ 是位置 $i$ 和 $j$ 上的核苷酸。允许的碱基对及其能量为：\n  - Watson–Crick：$(\\mathrm{A},\\mathrm{U})$ 和 $(\\mathrm{U},\\mathrm{A})$ 的 $E_{\\mathrm{pair}} = -2.0$，\n  - Watson–Crick：$(\\mathrm{G},\\mathrm{C})$ 和 $(\\mathrm{C},\\mathrm{G})$ 的 $E_{\\mathrm{pair}} = -3.0$，\n  - 摆动：$(\\mathrm{G},\\mathrm{U})$ 和 $(\\mathrm{U},\\mathrm{G})$ 的 $E_{\\mathrm{pair}} = -1.0$。\n  - 所有其他核苷酸对的 $E_{\\mathrm{pair}} = +4.0$，以强烈抑制非经典接触。\n- 每个接触的跳过能量惩罚 $E_{\\mathrm{skip}}$（单位为千卡/摩尔）是每个测试实例给定的标量。\n- 对于序列 $s$ 的一个构象 $x$ 的总能量为 $E(s,x) = \\sum_{(i,j) \\in E} \\left[ x_{(i,j)} \\, E_{\\mathrm{pair}}(b_i,b_j) + (1 - x_{(i,j)}) \\, E_{\\mathrm{skip}} \\right]$，单位为千卡/摩尔。\n- 配分函数 $Z(s) = \\sum_{x \\in \\mathcal{X}} \\exp\\left(-\\beta E(s,x)\\right)$ 是对所有满足“每个位置最多一个接触”约束的可行 $x$ 集合 $\\mathcal{X}$ 求和。\n- 期望的拓扑结构完全实现的概率（即对所有 $(i,j) \\in E$ 都有 $x_{(i,j)} = 1$）为 $p_{\\mathrm{topo}}(s) = \\frac{\\exp\\left(-\\beta E_{\\mathrm{all}}(s)\\right)}{Z(s)}$，其中 $E_{\\mathrm{all}}(s)$ 是所有接触都实现时的能量。如果完全实现违反了可行性（例如，两个接触共享一个位置），那么 $p_{\\mathrm{topo}}(s) = 0$。\n\n优化指令：\n- 对于每个测试实例，您必须提出一个指定长度为 $N$ 的 RNA 序列 $s$，该序列能在上述模型下最大化 $p_{\\mathrm{topo}}(s)$。这需要使用一个逻辑上合理的优化策略（例如，确定性贪婪分配后进行局部搜索）。然后，您必须通过对 $\\mathcal{X}$ 进行精确枚举来计算配分函数和设计序列的概率，从而计算出 $p_{\\mathrm{topo}}(s)$。\n- 使用 $k_{\\mathrm{B}} = 0.0019872041$，单位为千卡/摩尔/开尔文，绝对温度 $T$ 的单位为开尔文。\n- 将概率表示为无单位的十进制数。不要使用百分号。\n\n测试套件：\n- 案例1：$N = 12$, $E = \\{(1,12),(2,11),(4,9)\\}$, $T = 310$ 开尔文, $E_{\\mathrm{skip}} = 0.5$ 千卡/摩尔。\n- 案例2：$N = 4$, $E = \\{(2,3)\\}$, $T = 298$ 开尔文, $E_{\\mathrm{skip}} = 0.0$ 千卡/摩尔。\n- 案例3：$N = 12$, $E = \\{(1,12),(2,11),(4,9)\\}$, $T = 1000$ 开尔文, $E_{\\mathrm{skip}} = 0.5$ 千卡/摩尔。\n- 案例4：$N = 6$, $E = \\{(2,5),(2,6)\\}$, $T = 310$ 开尔文, $E_{\\mathrm{skip}} = 0.2$ 千卡/摩尔。\n- 案例5：$N = 8$, $E = \\{(1,8),(3,6)\\}$, $T = 310$ 开尔文, $E_{\\mathrm{skip}} = 0.2$ 千卡/摩尔。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，包含一个用方括号括起来的逗号分隔列表。每个概率值必须四舍五入到六位小数，例如 $[\\;0.123456,0.234567,0.345678\\;]$。",
            "solution": "目标是设计RNA序列，使其在一个符合基本统计力学原理的热力学系综下，完全实现特定接触拓扑结构的概率最大化。其基本原理是玻尔茲曼分布，即在绝对温度 $T$ 下，能量为 $E$ 的微观状态出现的概率正比于 $\\exp(-\\beta E)$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是玻尔茲曼常数。正则配分函数 $Z = \\sum_{\\text{microstates}} \\exp(-\\beta E)$ 用于归一化这些概率。\n\n在本问题中，微观状态由每个接触 $(i,j) \\in E$ 的二元实现变量 $x_{(i,j)} \\in \\{0,1\\}$ 定义，并受限于“每个位置最多参与一个实现的接触”这一可行性约束。能量函数对所有接触是可加的：$E(s,x) = \\sum_{(i,j) \\in E} \\left[ x_{(i,j)} E_{\\mathrm{pair}}(b_i,b_j) + (1-x_{(i,j)}) E_{\\mathrm{skip}} \\right]$，其中 $E_{\\mathrm{pair}}$ 由接触位置上的核苷酸类型决定，$E_{\\mathrm{skip}}$ 是未实现接触的惩罚。\n\n目标结果是完全实现的拓扑结构，即对所有 $(i,j) \\in E$ 都有 $x_{(i,j)} = 1$。如果该拓扑结构本身违反了可行性约束（例如，两条边共享一个位置），则不存在所有接触都实现的微观状态，拓扑结构的概率为 $p_{\\mathrm{topo}}(s) = 0$。如果拓扑结构是可行的，则完全实现构象的能量为 $E_{\\mathrm{all}}(s) = \\sum_{(i,j) \\in E} E_{\\mathrm{pair}}(b_i,b_j)$，配分函数为\n$$\nZ(s) = \\sum_{x \\in \\mathcal{X}} \\exp\\big(-\\beta E(s,x)\\big),\n$$\n其中 $\\mathcal{X}$ 表示所有满足“每个位置最多一个接触”约束的可行 $x$ 的集合。那么期望的概率为\n$$\np_{\\mathrm{topo}}(s) = \\frac{\\exp\\left(-\\beta E_{\\mathrm{all}}(s)\\right)}{Z(s)}.\n$$\n当接触不相交时，可行性约束可在各接触间分解，配分函数也随之分解：每个接触对配分函数的贡献项为，实现时是 $\\exp(-\\beta E_{\\mathrm{pair}})$，跳过时是 $\\exp(-\\beta E_{\\mathrm{skip}})$，最终得到各接触配分项的乘积。然而，为了在存在冲突时保持普适性和精确性，我们枚举所有 $2^{|E|}$ 种实现模式，并舍弃那些违反可行性的模式，通过对可行集 $\\mathcal{X}$ 求和来计算 $Z(s)$。\n\n设计策略必须提高 $p_{\\mathrm{topo}}(s)$。根据上述表达式，提高 $p_{\\mathrm{topo}}(s)$ 需要降低 $E_{\\mathrm{all}}(s)$（即形成更稳定的接触），同时相对降低 $Z(s)$ 中其他替代构象的统计权重。能量模型提供了 $E_{\\mathrm{pair}}(\\mathrm{G},\\mathrm{C}) = -3.0$、$E_{\\mathrm{pair}}(\\mathrm{A},\\mathrm{U}) = -2.0$ 和 $E_{\\mathrm{pair}}(\\mathrm{G},\\mathrm{U}) = -1.0$，而所有其他碱基对的能量都设为 $+4.0$。因此，一个合理的初始设计是，在位置约束下为每个接触分配核苷酸，以形成最稳定的经典碱基对（通常是 $\\mathrm{G}$–$\\mathrm{C}$）。对于不相交的接触，这种贪婪选择能直接最小化 $E_{\\mathrm{all}}(s)$。为了优化和验证设计，可以应用一种轻量级的局部搜索（例如，如果随机单点突变能提高 $p_{\\mathrm{topo}}(s)$，则接受该突变）。\n\n算法描述：\n- 对于每个测试案例 $(N, E, T, E_{\\mathrm{skip}})$，用一个默认核苷酸（例如 $\\mathrm{A}$）初始化长度为 $N$ 的序列 $s$。\n- 对于每个接触 $(i,j) \\in E$，从允许的集合 $\\{(\\mathrm{A},\\mathrm{U}),(\\mathrm{U},\\mathrm{A}),(\\mathrm{G},\\mathrm{C}),(\\mathrm{C},\\mathrm{G}),(\\mathrm{G},\\mathrm{U}),(\\mathrm{U},\\mathrm{G})\\}$ 中选择使 $E_{\\mathrm{pair}}(b_i,b_j)$ 最小的核苷酸对 $(b_i,b_j)$；这是一种确定性贪婪分配。\n- 使用 $k_{\\mathrm{B}} = 0.0019872041$（单位：千卡/摩尔/开尔文）计算 $\\beta = 1/(k_{\\mathrm{B}} T)$。\n- 枚舉所有实现向量 $x \\in \\{0,1\\}^{|E|}$，筛选出那些可行的（在 $x_{(i,j)}=1$ 的接触中没有共享位置），然后将玻尔茲曼权重 $\\exp(-\\beta E(s,x))$求和以得到 $Z(s)$。\n- 如果完全实现的拓扑结构违反可行性，则报告 $p_{\\mathrm{topo}}(s) = 0$。否则，计算 $E_{\\mathrmall}(s)$ 并返回 $p_{\\mathrm{topo}}(s) = \\exp(-\\beta E_{\\mathrm{all}}(s))/Z(s)$。\n\n该方法遵循了平衡概率的热力学原理，强制施加了接触不相容的物理约束，并且由于接触集规模不大，通过枚举可以得出精确的概率。贪婪分配策略基于能量模型是合理的，可作为给定接触拓扑结构的一种有原则的优化器，而对 $Z(s)$ 的精确计算确保了对所设计序列的准确评估。\n\n实现细节：\n- 程序编码了 $E_{\\mathrm{pair}}$ 的能量表。\n- 配分函数计算器通过检查没有索引出现在多个实现的接触中来枚举可行的 $x$。\n- 针对指定的测试套件计算结果：\n  - 案例1测试了一个在生理温度 $T=310$ 开尔文下具有非零跳过惩罚的通用不相交接触拓扑。\n  - 案例2测试了一个在 $T=298$ 开尔文下具有零跳过惩罰的单接触边界情况。\n  - 案例3测试了高温 $T=1000$ 开尔文以探测熵的主导作用。\n  - 案例4测试了一个因位置共享而导致完全实现不可行的情况，其概率为零。\n  - 案例5测试了另一个具有温和跳过惩罚的不相交接触拓扑。\n- 最终输出为一行，代表一个概率列表，四舍五入到六位小数，无单位和百分号。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Thermodynamic constant: Boltzmann constant in kcal/mol/K\nK_B = 0.0019872041\n\n# Pair energy table (kcal/mol)\nPAIR_ENERGY = {\n    ('A', 'U'): -2.0,\n    ('U', 'A'): -2.0,\n    ('G', 'C'): -3.0,\n    ('C', 'G'): -3.0,\n    ('G', 'U'): -1.0,\n    ('U', 'G'): -1.0,\n}\n\n# Disallowed pairs penalty (strongly unfavorable contact)\nDISALLOWED_ENERGY = 4.0\n\nNUCLEOTIDES = np.array(['A', 'C', 'G', 'U'])\n\ndef energy_pair(b1: str, b2: str) - float:\n    \"\"\"Return the pair energy for nucleotides b1-b2.\"\"\"\n    return PAIR_ENERGY.get((b1, b2), DISALLOWED_ENERGY)\n\ndef is_full_realization_feasible(edges):\n    \"\"\"Check if realizing all contacts is feasible (no shared positions).\"\"\"\n    used = set()\n    for i, j in edges:\n        if i in used or j in used:\n            return False\n        used.add(i)\n        used.add(j)\n    return True\n\ndef feasible_mask(mask: int, edges):\n    \"\"\"Check feasibility of a realization bitmask: no position used by multiple realized edges.\"\"\"\n    used = set()\n    for k, (i, j) in enumerate(edges):\n        if (mask >> k)  1:\n            if (i in used) or (j in used):\n                return False\n            used.add(i)\n            used.add(j)\n    return True\n\ndef configuration_energy(seq, edges, mask, e_skip):\n    \"\"\"Compute energy for a given realization mask.\"\"\"\n    E = 0.0\n    for k, (i, j) in enumerate(edges):\n        if (mask >> k)  1:\n            E += energy_pair(seq[i-1], seq[j-1])\n        else:\n            E += e_skip\n    return E\n\ndef partition_function(seq, edges, T, e_skip):\n    \"\"\"Compute partition function Z by exact enumeration of feasible masks.\"\"\"\n    beta = 1.0 / (K_B * T)\n    M = len(edges)\n    Z = 0.0\n    E_all = None\n    # Compute energy of fully realized topology if feasible\n    if is_full_realization_feasible(edges):\n        mask_all = (1  M) - 1\n        E_all = configuration_energy(seq, edges, mask_all, e_skip)\n    # Enumerate all masks\n    for mask in range(1  M):\n        if feasible_mask(mask, edges):\n            E = configuration_energy(seq, edges, mask, e_skip)\n            Z += np.exp(-beta * E)\n    return Z, E_all, beta\n\ndef design_initial_sequence(N, edges):\n    \"\"\"Greedy design: pick best base pair for each edge; fill others with 'A'.\"\"\"\n    seq = np.array(['A'] * N)\n    # For each edge, select the base pair with minimum energy\n    allowed_pairs = [('A', 'U'), ('U', 'A'), ('G', 'C'), ('C', 'G'), ('G', 'U'), ('U', 'G')]\n    for (i, j) in edges:\n        # Choose the best pair\n        best_pair = min(allowed_pairs, key=lambda p: energy_pair(p[0], p[1]))\n        seq[i-1] = best_pair[0]\n        seq[j-1] = best_pair[1]\n    return seq\n\ndef local_search(seq, edges, T, e_skip, steps=400, seed=42):\n    \"\"\"Simple hill-climbing: mutate random positions if probability improves.\"\"\"\n    rng = np.random.default_rng(seed)\n    # Compute current probability\n    Z, E_all, beta = partition_function(seq, edges, T, e_skip)\n    if E_all is None:\n        # Full realization infeasible; probability is zero; nothing to improve\n        return seq, 0.0\n    p_best = float(np.exp(-beta * E_all) / Z)\n    best_seq = seq.copy()\n    N = len(seq)\n    for _ in range(steps):\n        pos = int(rng.integers(0, N))\n        old = best_seq[pos]\n        # Propose a mutant different from current\n        choices = NUCLEOTIDES[NUCLEOTIDES != old]\n        new_nt = str(choices[int(rng.integers(0, len(choices)))])\n        best_seq[pos] = new_nt\n        Z_new, E_all_new, beta_new = partition_function(best_seq, edges, T, e_skip)\n        if E_all_new is None:\n            # Infeasible; reject\n            best_seq[pos] = old\n            continue\n        p_new = float(np.exp(-beta_new * E_all_new) / Z_new)\n        if p_new >= p_best:\n            p_best = p_new\n            # keep mutation\n        else:\n            # reject mutation\n            best_seq[pos] = old\n    return best_seq, p_best\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, edges, T, E_skip)\n    test_cases = [\n        (12, [(1,12),(2,11),(4,9)], 310.0, 0.5),\n        (4,  [(2,3)],                298.0, 0.0),\n        (12, [(1,12),(2,11),(4,9)],  1000.0, 0.5),\n        (6,  [(2,5),(2,6)],          310.0, 0.2),\n        (8,  [(1,8),(3,6)],          310.0, 0.2),\n    ]\n\n    results = []\n    for N, edges, T, e_skip in test_cases:\n        # Greedy initialization\n        seq0 = design_initial_sequence(N, edges)\n        # Local search refinement\n        seq_opt, p = local_search(seq0, edges, T, e_skip, steps=400, seed=123)\n        # Ensure probability computed exactly for final sequence (for consistency)\n        Z, E_all, beta = partition_function(seq_opt, edges, T, e_skip)\n        if E_all is None:\n            p_topo = 0.0\n        else:\n            p_topo = float(np.exp(-beta * E_all) / Z)\n        # Round to six decimals\n        results.append(f\"{p_topo:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}