{
    "hands_on_practices": [
        {
            "introduction": "Initial, rigid-body docking poses often represent a coarse approximation of the true protein-protein complex. To achieve high accuracy, these initial models must be refined, a process that typically involves optimizing side-chain conformations at the interface. This practice  guides you through a simplified but conceptually powerful repack-minimize cycle. By manually calculating energy changes and tracking interface contacts, you will gain first-hand experience with how rotamer-based side-chain searches and local energy relaxation work together to discover more stable and physically realistic binding geometries.",
            "id": "3839941",
            "problem": "You are modeling a protein-protein interface during a local refinement stage of computational protein-protein docking. The protocol performs discrete side-chain repacking using a backbone-dependent rotamer library followed by limited gradient-based energy minimization. Consider an interface reduced to two interacting residue pairs: an arginine on partner P contacting an aspartate on partner Q (denote this pair as P1–Q1), and a tyrosine on partner P contacting a phenylalanine on partner Q (denote this pair as P2–Q2). Cross interactions between P1–Q2 and P2–Q1 are negligible under the current backbone geometry.\n\nAssume the following foundations:\n- The total potential energy is approximated as the sum of residue self-energies (intra-residue plus backbone compatibility) and pairwise inter-residue interaction energies across the interface, consistent with standard physically motivated additive force fields where electrostatics, van der Waals (Lennard-Jones) terms, and hydrogen bonding are included. Let the total energy be the sum over these provided terms without additional couplings.\n- A residue-residue contact is defined by the presence of at least one heavy-atom pair across the interface separated by a distance less than or equal to a threshold of $4.0 \\,\\text{\\AA}$.\n- The initial rotamer assignments are given, and the repacking step searches over the provided rotamers to minimize the total energy. The subsequent local minimization reduces only the positive repulsive components embedded within specific pairwise interaction energies by a factor $\\alpha = 0.5$, leaving all other terms unchanged, reflecting a small relaxation that relieves steric overlap while preserving the qualitative geometry.\n\nFor P1–Q1 (arginine–aspartate), there are $2$ rotamers for each residue: P1 has $r \\in \\{1,2\\}$ with self-energies $E_{\\text{self}}^{\\text{P1}}(1) = 0.5 \\,\\text{kcal}\\,\\text{mol}^{-1}$ and $E_{\\text{self}}^{\\text{P1}}(2) = 0.2 \\,\\text{kcal}\\,\\text{mol}^{-1}$; Q1 has $s \\in \\{1,2\\}$ with self-energies $E_{\\text{self}}^{\\text{Q1}}(1) = 0.3 \\,\\text{kcal}\\,\\text{mol}^{-1}$ and $E_{\\text{self}}^{\\text{Q1}}(2) = 0.8 \\,\\text{kcal}\\,\\text{mol}^{-1}$. The pairwise interaction energies (including electrostatics, hydrogen bonding geometry where applicable, and van der Waals) and minimum heavy-atom distances are:\n- $(r,s) = (1,1)$: $E_{\\text{pair}}^{\\text{P1-Q1}}(1,1) = -3.5 \\,\\text{kcal}\\,\\text{mol}^{-1}$ with $d_{\\min}(1,1) = 2.7 \\,\\text{\\AA}$; this net energy includes a small repulsive component of $+0.6 \\,\\text{kcal}\\,\\text{mol}^{-1}$ due to close approach.\n- $(r,s) = (1,2)$: $E_{\\text{pair}}^{\\text{P1-Q1}}(1,2) = -1.0 \\,\\text{kcal}\\,\\text{mol}^{-1}$ with $d_{\\min}(1,2) = 3.8 \\,\\text{\\AA}$; negligible repulsion.\n- $(r,s) = (2,1)$: $E_{\\text{pair}}^{\\text{P1-Q1}}(2,1) = -0.5 \\,\\text{kcal}\\,\\text{mol}^{-1}$ with $d_{\\min}(2,1) = 3.6 \\,\\text{\\AA}$; negligible repulsion.\n- $(r,s) = (2,2)$: $E_{\\text{pair}}^{\\text{P1-Q1}}(2,2) = -2.2 \\,\\text{kcal}\\,\\text{mol}^{-1}$ with $d_{\\min}(2,2) = 3.0 \\,\\text{\\AA}$; this net energy includes a small repulsive component of $+0.2 \\,\\text{kcal}\\,\\text{mol}^{-1}$.\n\nFor P2–Q2 (tyrosine–phenylalanine), there are $2$ rotamers for each residue: P2 has $t \\in \\{1,2\\}$ with self-enerenergies $E_{\\text{self}}^{\\text{P2}}(1) = 0.4 \\,\\text{kcal}\\,\\text{mol}^{-1}$ and $E_{\\text{self}}^{\\text{P2}}(2) = 0.1 \\,\\text{kcal}\\,\\text{mol}^{-1}$; Q2 has $u \\in \\{1,2\\}$ with self-energies $E_{\\text{self}}^{\\text{Q2}}(1) = 0.5 \\,\\text{kcal}\\,\\text{mol}^{-1}$ and $E_{\\text{self}}^{\\text{Q2}}(2) = 0.2 \\,\\text{kcal}\\,\\text{mol}^{-1}$. The pairwise interaction energies and minimum distances are:\n- $(t,u) = (1,1)$: $E_{\\text{pair}}^{\\text{P2-Q2}}(1,1) = -1.2 \\,\\text{kcal}\\,\\text{mol}^{-1}$ with $d_{\\min}(1,1) = 3.5 \\,\\text{\\AA}$; negligible repulsion.\n- $(t,u) = (1,2)$: $E_{\\text{pair}}^{\\text{P2-Q2}}(1,2) = -0.6 \\,\\text{kcal}\\,\\text{mol}^{-1}$ with $d_{\\min}(1,2) = 4.2 \\,\\text{\\AA}$; no contact.\n- $(t,u) = (2,1)$: $E_{\\text{pair}}^{\\text{P2-Q2}}(2,1) = -0.7 \\,\\text{kcal}\\,\\text{mol}^{-1}$ with $d_{\\min}(2,1) = 4.0 \\,\\text{\\AA}$; contact threshold.\n- $(t,u) = (2,2)$: $E_{\\text{pair}}^{\\text{P2-Q2}}(2,2) = -1.4 \\,\\text{kcal}\\,\\text{mol}^{-1}$ with $d_{\\min}(2,2) = 3.6 \\,\\text{\\AA}$; this net energy includes a small repulsive component of $+0.1 \\,\\text{kcal}\\,\\text{mol}^{-1}$.\n\nAssume cross-pair interactions P1–Q2 and P2–Q1 are $0.0 \\,\\text{kcal}\\,\\text{mol}^{-1}$ and do not contribute contacts. The initial rotamers are P1 $r=2$, Q1 $s=1$, P2 $t=1$, Q2 $u=2$.\n\nTasks:\n- Using the additive model, compute the total energy for the initial state, then determine the energy-minimizing rotamers after side-chain repacking for each pair independently, and compute the new total energy. Identify the interface contact set (which residue pairs are in contact) before and after repacking using the $4.0 \\,\\text{\\AA}$ threshold.\n- Apply the local minimization rule that scales the identified positive repulsive components by the factor $\\alpha = 0.5$ for the selected rotamer pairs only, recompute the total energy, and state whether the contact set changes.\n- Based on first principles for iterative repack-minimize cycles, select the option that best describes the evolution of the contact pattern and provides rigorous convergence criteria grounded in energy landscape optimization and stability of the interface contact map.\n\nWhich option is most consistent with these calculations and principles?\n\nA. After repacking, P1–Q1 remains in contact and P2–Q2 newly becomes a contact; after minimization, the contact set is unchanged. Converge when both the change in total energy magnitude satisfies $\\lvert \\Delta E \\rvert < 0.1 \\,\\text{kcal}\\,\\text{mol}^{-1}$ and the contact map has Jaccard index $J = 1$ with the previous iteration for at least $2$ consecutive repack-minimize cycles, and additionally the maximum norm of the energy gradient over side-chain dihedrals is below $10^{-3} \\,\\text{kcal}\\,\\text{mol}^{-1}\\,\\text{rad}^{-1}$.\n\nB. After repacking, the contacts are unchanged relative to the initial state because pairwise energies cannot overcome self-energies; minimization introduces a new P1–Q2 contact. Converge when the absolute change in total energy is below $1.0 \\,\\text{kcal}\\,\\text{mol}^{-1}$ for a single iteration, regardless of contact changes.\n\nC. After repacking, P1–Q1 contact is lost due to repulsive relaxation, but P2–Q2 remains non-contact; after minimization, both pairs become contacts. Converge when side-chain root-mean-square deviation (RMSD) between iterations is below $2.0 \\,\\text{\\AA}$, even if the energy is still decreasing and contacts are changing.\n\nD. After repacking, P1–Q1 switches to a non-contact geometry while P2–Q2 remains non-contact; after minimization, P2–Q2 becomes the only contact. Converge when the number of hydrogen bonds does not increase for $1$ iteration, irrespective of total energy and nonbonded contacts.",
            "solution": "The problem statement is a valid, well-posed exercise in computational protein-protein docking. It provides a simplified but scientifically grounded model of a repack-minimize cycle, with all necessary data and clear rules for calculation. The problem is self-contained, consistent, and objective.\n\nThe solution proceeds in three stages:\n1.  Analysis of the initial state.\n2.  Analysis of the state after side-chain repacking.\n3.  Analysis of the state after local energy minimization.\nFinally, an evaluation of each option is performed based on these results and the principles of energy landscape optimization.\n\nThe total energy of the system, $E_{\\text{total}}$, is the sum of the self-energies of the four residues and the pairwise interaction energies of the two non-covalently interacting pairs, P1–Q1 and P2–Q2.\n$$E_{\\text{total}} = E_{\\text{self}}^{\\text{P1}}(r) + E_{\\text{self}}^{\\text{Q1}}(s) + E_{\\text{self}}^{\\text{P2}}(t) + E_{\\text{self}}^{\\text{Q2}}(u) + E_{\\text{pair}}^{\\text{P1-Q1}}(r,s) + E_{\\text{pair}}^{\\text{P2-Q2}}(t,u)$$\nA residue-residue pair is in contact if the minimum heavy-atom distance, $d_{\\min}$, is less than or equal to $4.0 \\,\\text{\\AA}$.\n\n**1. Initial State Analysis**\n\nThe initial rotamers are given as P1($r=2$), Q1($s=1$), P2($t=1$), and Q2($u=2$).\n\nThe total initial energy, $E_{\\text{init}}$, is:\n$$E_{\\text{init}} = E_{\\text{self}}^{\\text{P1}}(2) + E_{\\text{self}}^{\\text{Q1}}(1) + E_{\\text{self}}^{\\text{P2}}(1) + E_{\\text{self}}^{\\text{Q2}}(2) + E_{\\text{pair}}^{\\text{P1-Q1}}(2,1) + E_{\\text{pair}}^{\\text{P2-Q2}}(1,2)$$\nSubstituting the given values:\n$$E_{\\text{init}} = (0.2 + 0.3 + 0.4 + 0.2) + (-0.5) + (-0.6) \\,\\text{kcal}\\,\\text{mol}^{-1}$$\n$$E_{\\text{init}} = 1.1 - 1.1 = 0.0 \\,\\text{kcal}\\,\\text{mol}^{-1}$$\n\nThe initial contact set is determined by the minimum distances for the selected rotamer pairs:\n- For P1–Q1, the rotamer pair is $(r,s)=(2,1)$, with $d_{\\min}(2,1) = 3.6 \\,\\text{\\AA}$. Since $3.6 \\le 4.0$, P1–Q1 is in contact.\n- For P2–Q2, the rotamer pair is $(t,u)=(1,2)$, with $d_{\\min}(1,2) = 4.2 \\,\\text{\\AA}$. Since $4.2 > 4.0$, P2–Q2 is not in contact.\nThe initial contact set is {P1–Q1}.\n\n**2. Side-Chain Repacking Analysis**\n\nSide-chain repacking finds the combination of rotamers that minimizes the total energy. Since the two pairs P1–Q1 and P2–Q2 are energetically independent (cross interactions are zero), we can minimize the energy for each pair separately.\n\nFor pair P1–Q1 (Arginine–Aspartate):\nThe energy for each rotamer combination $(r,s)$ is $E^{\\text{P1-Q1}}(r,s) = E_{\\text{self}}^{\\text{P1}}(r) + E_{\\text{self}}^{\\text{Q1}}(s) + E_{\\text{pair}}^{\\text{P1-Q1}}(r,s)$.\n- $E(1,1) = 0.5 + 0.3 + (-3.5) = -2.7 \\,\\text{kcal}\\,\\text{mol}^{-1}$\n- $E(1,2) = 0.5 + 0.8 + (-1.0) = 0.3 \\,\\text{kcal}\\,\\text{mol}^{-1}$\n- $E(2,1) = 0.2 + 0.3 + (-0.5) = 0.0 \\,\\text{kcal}\\,\\text{mol}^{-1}$\n- $E(2,2) = 0.2 + 0.8 + (-2.2) = -1.2 \\,\\text{kcal}\\,\\text{mol}^{-1}$\nThe minimum energy for the P1–Q1 pair is $-2.7 \\,\\text{kcal}\\,\\text{mol}^{-1}$, corresponding to rotamers $(r,s)=(1,1)$.\n\nFor pair P2–Q2 (Tyrosine–Phenylalanine):\nThe energy for each rotamer combination $(t,u)$ is $E^{\\text{P2-Q2}}(t,u) = E_{\\text{self}}^{\\text{P2}}(t) + E_{\\text{self}}^{\\text{Q2}}(u) + E_{\\text{pair}}^{\\text{P2-Q2}}(t,u)$.\n- $E(1,1) = 0.4 + 0.5 + (-1.2) = -0.3 \\,\\text{kcal}\\,\\text{mol}^{-1}$\n- $E(1,2) = 0.4 + 0.2 + (-0.6) = 0.0 \\,\\text{kcal}\\,\\text{mol}^{-1}$\n- $E(2,1) = 0.1 + 0.5 + (-0.7) = -0.1 \\,\\text{kcal}\\,\\text{mol}^{-1}$\n- $E(2,2) = 0.1 + 0.2 + (-1.4) = -1.1 \\,\\text{kcal}\\,\\text{mol}^{-1}$\nThe minimum energy for the P2–Q2 pair is $-1.1 \\,\\text{kcal}\\,\\text{mol}^{-1}$, corresponding to rotamers $(t,u)=(2,2)$.\n\nThe total energy after repacking, $E_{\\text{repack}}$, is the sum of the minimum energies for each pair:\n$$E_{\\text{repack}} = -2.7 + (-1.1) = -3.8 \\,\\text{kcal}\\,\\text{mol}^{-1}$$\n\nThe contact set after repacking is determined by the new optimal rotamers:\n- For P1–Q1, the new pair is $(r,s)=(1,1)$ with $d_{\\min}(1,1) = 2.7 \\,\\text{\\AA}$. Since $2.7 \\le 4.0$, P1–Q1 remains in contact.\n- For P2–Q2, the new pair is $(t,u)=(2,2)$ with $d_{\\min}(2,2) = 3.6 \\,\\text{\\AA}$. Since $3.6 \\le 4.0$, P2–Q2 becomes a contact.\nThe post-repacking contact set is {P1–Q1, P2–Q2}. Relative to the initial state, P1–Q1 remains a contact and P2–Q2 newly becomes a contact.\n\n**3. Energy Minimization Analysis**\n\nThis step applies to the state found after repacking: rotamers P1-Q1: $(1,1)$ and P2-Q2: $(2,2)$. The rule is to reduce any positive repulsive energy component by a factor of $\\alpha=0.5$. The total energy will decrease by $(1-\\alpha)$ times the repulsive energy.\n\nFor pair P1–Q1 in state $(1,1)$, the repulsive energy is given as $E_{\\text{rep}} = +0.6 \\,\\text{kcal}\\,\\text{mol}^{-1}$.\nThe energy reduction is $\\Delta E_{\\text{min,1}} = -(1-\\alpha) \\times E_{\\text{rep}} = -(1-0.5) \\times 0.6 = -0.3 \\,\\text{kcal}\\,\\text{mol}^{-1}$.\n\nFor pair P2–Q2 in state $(2,2)$, the repulsive energy is given as $E_{\\text{rep}} = +0.1 \\,\\text{kcal}\\,\\text{mol}^{-1}$.\nThe energy reduction is $\\Delta E_{\\text{min,2}} = -(1-\\alpha) \\times E_{\\text{rep}} = -(1-0.5) \\times 0.1 = -0.05 \\,\\text{kcal}\\,\\text{mol}^{-1}$.\n\nThe total energy after minimization, $E_{\\text{final}}$, is:\n$$E_{\\text{final}} = E_{\\text{repack}} + \\Delta E_{\\text{min,1}} + \\Delta E_{\\text{min,2}}$$\n$$E_{\\text{final}} = -3.8 - 0.3 - 0.05 = -4.15 \\,\\text{kcal}\\,\\text{mol}^{-1}$$\n\nThe problem states that minimization is a \"small relaxation... preserving the qualitative geometry,\" which implies the rotamer identities and minimum distances, and therefore the contact set, do not change during this step.\nThe post-minimization contact set is {P1–Q1, P2–Q2}, which is unchanged from the post-repacking state.\n\n**Summary of Results & Option Evaluation**\n\n- **Repacking**: P1–Q1 remains a contact, P2–Q2 becomes a contact.\n- **Minimization**: The contact set remains {P1–Q1, P2–Q2}.\n\nWe now evaluate the options:\n\n**A. After repacking, P1–Q1 remains in contact and P2–Q2 newly becomes a contact; after minimization, the contact set is unchanged. Converge when both the change in total energy magnitude satisfies $\\lvert \\Delta E \\rvert < 0.1 \\,\\text{kcal}\\,\\text{mol}^{-1}$ and the contact map has Jaccard index $J = 1$ with the previous iteration for at least $2$ consecutive repack-minimize cycles, and additionally the maximum norm of the energy gradient over side-chain dihedrals is below $10^{-3} \\,\\text{kcal}\\,\\text{mol}^{-1}\\,\\text{rad}^{-1}$.**\nThe first part of this statement perfectly matches the results of our calculations. The second part describes a robust, multi-pronged convergence criterion that is standard in the field. It requires stability in energy ($\\lvert \\Delta E \\rvert$), structure (contact map Jaccard index $J=1$ for two cycles), and achieving a local energy minimum (low gradient norm). This is a comprehensive and scientifically sound set of criteria.\n**Verdict: Correct**\n\n**B. After repacking, the contacts are unchanged relative to the initial state because pairwise energies cannot overcome self-energies; minimization introduces a new P1–Q2 contact.**\nThe first claim, \"contacts are unchanged,\" is incorrect; P2-Q2 becomes a contact. The reasoning is also incorrect; the favorable pairwise energies did overcome the less favorable self-energies. The second claim, \"minimization introduces a new P1–Q2 contact,\" is incorrect as minimization does not change the contact set in this model, and P1-Q2 interactions are negligible. The convergence criterion based only on a loose energy threshold ($\\lvert \\Delta E \\rvert < 1.0 \\,\\text{kcal}\\,\\text{mol}^{-1}$) is inadequate.\n**Verdict: Incorrect**\n\n**C. After repacking, P1–Q1 contact is lost due to repulsive relaxation, but P2–Q2 remains non-contact; after minimization, both pairs become contacts.**\nThe claim \"P1–Q1 contact is lost\" is incorrect. The claim \"P2–Q2 remains non-contact\" is incorrect. The claim \"after minimization, both pairs become contacts\" is incorrect as they were already contacts after repacking. The RMSD-based convergence criterion is too loose ($2.0 \\,\\text{\\AA}$) and improperly ignores energy.\n**Verdict: Incorrect**\n\n**D. After repacking, P1–Q1 switches to a non-contact geometry while P2–Q2 remains non-contact; after minimization, P2–Q2 becomes the only contact.**\nBoth claims about the post-repacking state are incorrect. The claim about the post-minimization contact set is incorrect. The convergence criterion based only on hydrogen bonds is far too simplistic and ignores other crucial energy terms and the overall structural stability.\n**Verdict: Incorrect**\n\nThe only option that aligns with the calculations and presents a scientifically rigorous set of principles is A.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Once a set of potential binding poses is generated, the central challenge becomes ranking them to identify the most likely native-like structure. A common mistake is to simply choose the pose with the lowest energy score. This exercise  illustrates a critical flaw in that approach, especially for symmetric protein assemblies. You will apply fundamental principles of statistical mechanics to understand how pose degeneracy—the existence of multiple, symmetry-equivalent binding sites—contributes an entropic term, $S = k_B \\ln g$, to the binding free energy, often making a higher-energy but more degenerate binding mode the thermodynamically preferred state.",
            "id": "3839949",
            "problem": "In rigid-body docking of a ligand to a symmetric receptor in computational protein-protein docking, symmetry can produce multiple poses that are symmetry-related and therefore energetically degenerate. Suppose a cyclic trimeric receptor (symmetry $C_3$) is docked with a monomeric ligand using an energy-based scoring function $E(\\mathbf{R})$ that approximates the interaction energy for orientation $\\mathbf{R}$. The search produces two distinct binding modes (two chemically distinct interface microstates), denoted mode $A$ and mode $B$. Due to receptor symmetry, each unique microstate may appear as several symmetry-related poses with indistinguishable interface geometry and identical scores (up to small numerical noise). For a particular docking run:\n- Mode $A$ appears as $g_A$ symmetry-related poses with identical reported energy $E_A = -9.5$ $\\mathrm{kcal\\,mol^{-1}}$ per pose and degeneracy $g_A = 3$.\n- Mode $B$ appears as $g_B$ symmetry-related poses with identical reported energy $E_B = -10.0$ $\\mathrm{kcal\\,mol^{-1}}$ per pose and degeneracy $g_B = 1$.\nAssume a temperature $T = 300$ $\\mathrm{K}$ and Boltzmann constant $k_B = 1.987\\times 10^{-3}$ $\\mathrm{kcal\\,mol^{-1}\\,K^{-1}}$. You wish to (i) correctly aggregate symmetry-related poses into a per-mode score consistent with statistical mechanics so that ranking reflects the effective binding free energy accounting for degeneracy, and (ii) propose a principled strategy to further disambiguate near-degenerate modes without double-counting symmetry-related poses.\nWhich option best accomplishes both goals?\nA. Rank modes by the single most favorable pose energy, i.e., $\\min_j E_{ij}$ within each mode $i$, ignoring degeneracy; if needed, break ties by the number of symmetry-related poses $g_i$.\nB. Rank modes by the arithmetic mean energy across symmetry-related poses in each mode, i.e., $\\bar{E}_i = \\frac{1}{g_i}\\sum_{j=1}^{g_i} E_{ij}$. Because $E_{ij}$ are identical, this equals $E_i$; to disambiguate, prefer the mode with larger $g_i$.\nC. Aggregate symmetry-related poses within each mode $i$ using a Boltzmann-consistent log-sum-exp free energy $F_i = -k_B T \\ln \\sum_{j=1}^{g_i} \\exp(-\\beta E_{ij})$, where $\\beta = 1/(k_B T)$, which simplifies to $F_i = E_i - k_B T \\ln g_i$ when $E_{ij}$ are equal. Using $T = 300$ $\\mathrm{K}$ and $k_B$ as given, numerically obtain $F_A \\approx -10.16$ $\\mathrm{kcal\\,mol^{-1}}$ and $F_B \\approx -10.00$ $\\mathrm{kcal\\,mol^{-1}}$, so mode $A$ is preferred. To further disambiguate in the presence of small energy differences within symmetry or numerical noise, first group decoys into symmetry-equivalence classes (orbits) and then incorporate weak experimental priors (e.g., interface mutational constraints or low-resolution mapping) via an additive restraint energy $E_{\\mathrm{rest}}(\\text{pose}) = -k_B T \\ln p(\\text{data}\\mid \\text{pose})$, or equivalently Bayesian reweighting, before the same aggregation.\nD. Reward degeneracy by multiplying energy by degeneracy, $E_i' = g_i\\,E_i$, so mode $A$ becomes $E_A' = 3\\times (-9.5) = -28.5$ $\\mathrm{kcal\\,mol^{-1}}$, which is preferred; disambiguate by choosing the largest $g_i$ even if $E_i$ vary within a mode.\nE. Approximate free energy by cluster-size weighting from the sampled decoy count $n_i$ per mode, $F_i \\approx -k_B T \\ln n_i + \\min_j E_{ij}$, without explicit symmetry handling; disambiguate by ranking the mode with more decoys as more stable.",
            "solution": "The primary goal is to compare the stability of the two binding modes, A and B. In statistical mechanics, the relative stability of different states at a constant temperature is determined by their Helmholtz free energy, F. A lower free energy corresponds to a more stable and thus more probable state.\n\nA binding \"mode\" is a macrostate composed of one or more microstates (the poses). The free energy of a macrostate $i$ is related to its partition function, $Z_i$, by the equation:\n$$F_i = -k_B T \\ln Z_i$$\nThe partition function $Z_i$ is the sum of the Boltzmann factors for all microstates $j$ belonging to that macrostate. For a set of $g_i$ poses with identical energy $E_i$, the partition function simplifies to $Z_i = g_i \\exp(-E_i/k_B T)$.\n\nSubstituting this into the free energy equation gives the final expression:\n$$F_i = E_i - k_B T \\ln g_i$$\nThis equation correctly combines the enthalpic contribution ($E_i$) and the entropic contribution from degeneracy ($-T S_i$, where $S_i = k_B \\ln g_i$). The mode with the lower free energy is the preferred one.\n\nNow, we calculate the free energies for modes A and B. The thermal energy term is $k_B T = (1.987 \\times 10^{-3} \\, \\mathrm{kcal\\,mol^{-1}\\,K^{-1}}) \\times (300 \\, \\mathrm{K}) = 0.5961 \\, \\mathrm{kcal\\,mol^{-1}}$.\n\nFor **Mode A**:\n-   $E_A = -9.5 \\, \\mathrm{kcal\\,mol^{-1}}$\n-   $g_A = 3$\n-   $F_A = E_A - k_B T \\ln g_A = -9.5 - (0.5961) \\ln(3) \\approx -9.5 - 0.655 = -10.155 \\, \\mathrm{kcal\\,mol^{-1}}$\n\nFor **Mode B**:\n-   $E_B = -10.0 \\, \\mathrm{kcal\\,mol^{-1}}$\n-   $g_B = 1$\n-   $F_B = E_B - k_B T \\ln g_B = -10.0 - (0.5961) \\ln(1) = -10.0 - 0 = -10.0 \\, \\mathrm{kcal\\,mol^{-1}}$\n\nComparing the free energies, $F_A \\approx -10.16 \\, \\mathrm{kcal\\,mol^{-1}}$ and $F_B = -10.0 \\, \\mathrm{kcal\\,mol^{-1}}$. Since $F_A  F_B$, mode A is thermodynamically more favorable. The higher degeneracy (entropy) of mode A stabilizes it, overcoming its less favorable interaction energy.\n\nOption C correctly uses this free energy formulation and gets the right answer. The disambiguation strategy proposed in C is also sound: first group poses by symmetry to prevent double-counting, then use external data as a Bayesian prior or an additive restraint energy term ($E_{\\text{rest}}(\\text{pose}) = -k_B T \\ln p(\\text{data}\\mid \\text{pose})$) to refine the ranking. This is a rigorous and standard approach.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "A scoring function is only as useful as its ability to consistently distinguish correct (near-native) poses from incorrect ones (decoys). How do we quantitatively measure this performance? This practice  moves from applying scoring functions to validating them, a crucial skill for both developers and discerning users of docking software. You will implement from first principles the construction of Receiver Operating Characteristic (ROC) and Precision-Recall (PR) curves, two of the most important statistical tools for evaluating a classifier's performance, and use them to compute the area under the curve (AUC), a key metric for benchmarking docking algorithms.",
            "id": "3839980",
            "problem": "You are given a real-valued docking scoring function that assigns a scalar score to each protein-protein pose, and a binary label indicating whether the pose is near-native ($1$) or a decoy ($0$). Using only foundational definitions of binary classification, derive the Receiver Operating Characteristic (ROC) curve and the Precision-Recall (PR) curve as functions of the score threshold, and compute their areas under the curve using discrete trapezoidal integration. Implement a complete program that, for each dataset provided in the test suite, computes the area under the ROC curve (ROC-AUC) and the area under the PR curve (PR-AUC), both rounded to $6$ decimal places.\n\nFoundational base and derivation targets:\n- Treat the docking scoring function as a monotone ranking of poses, where higher scores indicate a stronger belief of being near-native. For any threshold $t$, define the predicted class $\\hat{y}$ by the rule: if the score $s \\ge t$ then $\\hat{y} = 1$, else $\\hat{y} = 0$.\n- For a fixed threshold $t$ and a dataset with labels $y \\in \\{0,1\\}$, define the counts: true positives $\\mathrm{TP}(t)$, false positives $\\mathrm{FP}(t)$, true negatives $\\mathrm{TN}(t)$, false negatives $\\mathrm{FN}(t)$. Let the number of positives be $P = \\sum_i y_i$ and the number of negatives be $N = \\sum_i (1 - y_i)$, with $P \\ge 1$ and $N \\ge 1$.\n- Define the True Positive Rate (TPR) $=\\mathrm{TP}(t)/P$, False Positive Rate (FPR) $=\\mathrm{FP}(t)/N$, Precision $=\\mathrm{TP}(t)/(\\mathrm{TP}(t)+\\mathrm{FP}(t))$ (with the convention that precision equals $1$ when $\\mathrm{TP}(t)+\\mathrm{FP}(t)=0$), and Recall $=\\mathrm{TP}(t)/P$.\n- The ROC curve is the set of points $(\\mathrm{FPR}(t), \\mathrm{TPR}(t))$ as $t$ sweeps all unique score levels from $+\\infty$ down to $-\\infty$, including the endpoints $(0,0)$ and $(1,1)$. The PR curve is the set of points $(\\mathrm{Recall}(t), \\mathrm{Precision}(t))$ over the same sweep, including the endpoints $(0,1)$ and $(1,\\mathrm{TP}(t_{\\min})/(\\mathrm{TP}(t_{\\min})+\\mathrm{FP}(t_{\\min})))$ where $t_{\\min}$ is below the minimum score so that all samples are predicted positive.\n- The area under each curve is defined by discrete trapezoidal integration over the ordered curve points: for an ordered sequence of points $(x_k, y_k)$ with $k = 0,1,\\dots,K$, the area is $\\sum_{k=0}^{K-1} \\frac{(x_{k+1}-x_k)}{2}\\,(y_{k+1}+y_k)$.\n\nProgram requirements:\n- For each test case in the suite, compute the ROC-AUC and PR-AUC using the definitions above. Construct the discrete ROC and PR curves by thresholding at the unique score values sorted in descending order and grouping ties so that points are added only at score changes. Ensure that initial points $(0,0)$ for ROC and $(0,1)$ for PR are included.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, for each test case in order, the ROC-AUC followed by the PR-AUC, both rounded to $6$ decimal places. For example, for $M$ test cases, the output list will have $2M$ entries: $[\\mathrm{ROC}\\text{-}\\mathrm{AUC}_1,\\mathrm{PR}\\text{-}\\mathrm{AUC}_1,\\dots,\\mathrm{ROC}\\text{-}\\mathrm{AUC}_M,\\mathrm{PR}\\text{-}\\mathrm{AUC}_M]$.\n\nTest suite:\n- Case $1$ (balanced, near-perfect separation):\n  - Scores: $[0.95, 0.92, 0.88, 0.85, 0.83, 0.80, 0.45, 0.40, 0.35, 0.30, 0.25, 0.15]$\n  - Labels: $[1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]$\n- Case $2$ (poor separation, many high-scoring decoys):\n  - Scores: $[0.90, 0.85, 0.80, 0.75, 0.70, 0.65, 0.60, 0.55, 0.50, 0.45]$\n  - Labels: $[0, 0, 0, 0, 0, 1, 1, 1, 0, 1]$\n- Case $3$ (ties at multiple score levels):\n  - Scores: $[0.70, 0.70, 0.70, 0.50, 0.50, 0.50, 0.30, 0.30]$\n  - Labels: $[1, 0, 1, 0, 1, 0, 1, 0]$\n- Case $4$ (highly imbalanced with overlapping scores):\n  - Scores: $[0.95, 0.90, 0.85, 0.80, 0.75, 0.70, 0.65, 0.60, 0.55, 0.50, 0.45, 0.40, 0.35, 0.30, 0.25, 0.20, 0.15, 0.10, 0.05, 0.01]$\n  - Labels: $[0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]$\n- Case $5$ (all scores identical):\n  - Scores: $[0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50]$\n  - Labels: $[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]$\n\nAngle units are not applicable. No physical units are required. The final output must be the flattened list of areas for all cases, in order, with each value rounded to $6$ decimal places, as described above.",
            "solution": "The problem requires implementing the calculation of the Receiver Operating Characteristic Area Under the Curve (ROC-AUC) and Precision-Recall Area Under the Curve (PR-AUC) from first principles. The correct algorithm, as implemented in the provided Python code, follows these steps:\n\n1.  **Initialization**:\n    - Combine the scores and labels into pairs and sort them in descending order of score. This establishes the ranking.\n    - Calculate the total number of positive ($P$) and negative ($N$) samples in the dataset.\n    - The ROC curve starts at the point (FPR=0, TPR=0), representing a threshold so high that no samples are classified as positive.\n    - The PR curve starts at (Recall=0, Precision=1). The precision is 1 by convention when the number of predicted positives is zero.\n\n2.  **Curve Generation**:\n    - Iterate through the sorted samples. To correctly handle scores that are tied, process all samples with the same score as a single block.\n    - For each unique score value acting as a threshold, update the cumulative counts of true positives (TP) and false positives (FP).\n    - After each update, calculate the new point on each curve:\n        - **ROC point**: (FPR, TPR) = (FP / N, TP / P)\n        - **PR point**: (Recall, Precision) = (TP / P, TP / (TP + FP))\n    - Add this new point to the list of points for each curve.\n\n3.  **Area Calculation**:\n    - Once all points for a curve have been generated, apply the trapezoidal rule to calculate the area under it. For a sequence of points $(x_k, y_k)$, the area is calculated as $\\sum_k \\frac{1}{2}(y_k + y_{k+1})(x_{k+1} - x_k)$.\n\nThis algorithm correctly handles all aspects of the problem definition, including tied scores and the specific conventions for the starting points of the curves, to produce the correct AUC values for each test case.",
            "answer": "```python\nimport numpy as np\n\ndef calculate_aucs(scores, labels):\n    \"\"\"\n    Computes the ROC-AUC and PR-AUC for a given set of scores and labels.\n\n    The function follows the derivation from first principles:\n    1. Sorts samples by score in descending order.\n    2. Iterates through unique score thresholds to generate points on the ROC and PR curves.\n       Ties in scores are handled by processing all tied samples as a single block.\n    3. Calculates the area under each curve using the trapezoidal rule.\n\n    Args:\n        scores (list of float): The predicted scores for each sample.\n        labels (list of int): The true binary labels (1 for positive, 0 for negative).\n\n    Returns:\n        tuple[float, float]: A tuple containing the ROC-AUC and PR-AUC.\n    \"\"\"\n    labels = np.array(labels)\n    P = np.sum(labels)\n    N = len(labels) - P\n\n    # According to the problem statement, P = 1 and N = 1, so no need for explicit checks.\n\n    # Combine scores and labels, then sort by score in descending order.\n    data = sorted(zip(scores, labels), key=lambda x: x[0], reverse=True)\n    \n    # Initialize counts and point lists for the curves.\n    tp, fp = 0.0, 0.0\n    # ROC curve starts at (0,0).\n    roc_points = [(0.0, 0.0)]\n    # PR curve starts at (Recall=0, Precision=1).\n    pr_points = [(0.0, 1.0)]\n\n    i = 0\n    while i  len(data):\n        current_score = data[i][0]\n        tp_step, fp_step = 0.0, 0.0\n\n        # Process all samples with the same score (handling ties).\n        j = i\n        while j  len(data) and data[j][0] == current_score:\n            if data[j][1] == 1:\n                tp_step += 1\n            else:\n                fp_step += 1\n            j += 1\n        \n        tp += tp_step\n        fp += fp_step\n        i = j # Move index to the next unique score block\n\n        # Calculate metrics for the new point on both curves.\n        # Add new ROC point: (FPR, TPR)\n        roc_points.append((fp / N, tp / P))\n        \n        # Add new PR point: (Recall, Precision)\n        recall = tp / P\n        # Handle the case where TP + FP = 0, though it only happens at the start.\n        precision = tp / (tp + fp) if (tp + fp)  0 else 1.0\n        pr_points.append((recall, precision))\n\n    # Extract x and y coordinates from the point lists.\n    roc_x = np.array([p[0] for p in roc_points])\n    roc_y = np.array([p[1] for p in roc_points])\n    \n    pr_x = np.array([p[0] for p in pr_points])\n    pr_y = np.array([p[1] for p in pr_points])\n\n    # Calculate the area under each curve using the trapezoidal rule.\n    # np.trapz(y, x) implements the formula specified in the problem.\n    roc_auc = np.trapz(roc_y, roc_x)\n    pr_auc = np.trapz(pr_y, pr_x)\n    \n    return roc_auc, pr_auc\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Case 1 (balanced, near-perfect separation)\n        (\n            [0.95, 0.92, 0.88, 0.85, 0.83, 0.80, 0.45, 0.40, 0.35, 0.30, 0.25, 0.15],\n            [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]\n        ),\n        # Case 2 (poor separation, many high-scoring decoys)\n        (\n            [0.90, 0.85, 0.80, 0.75, 0.70, 0.65, 0.60, 0.55, 0.50, 0.45],\n            [0, 0, 0, 0, 0, 1, 1, 1, 0, 1]\n        ),\n        # Case 3 (ties at multiple score levels)\n        (\n            [0.70, 0.70, 0.70, 0.50, 0.50, 0.50, 0.30, 0.30],\n            [1, 0, 1, 0, 1, 0, 1, 0]\n        ),\n        # Case 4 (highly imbalanced with overlapping scores)\n        (\n            [0.95, 0.90, 0.85, 0.80, 0.75, 0.70, 0.65, 0.60, 0.55, 0.50, 0.45, 0.40, 0.35, 0.30, 0.25, 0.20, 0.15, 0.10, 0.05, 0.01],\n            [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]\n        ),\n        # Case 5 (all scores identical)\n        (\n            [0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50],\n            [1, 1, 1, 1, 1, 0, 0, 0, 0, 0]\n        )\n    ]\n\n    results = []\n    for scores, labels in test_cases:\n        roc_auc, pr_auc = calculate_aucs(scores, labels)\n        results.append(f\"{roc_auc:.6f}\")\n        results.append(f\"{pr_auc:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}