{
    "hands_on_practices": [
        {
            "introduction": "To understand how kilometers of deoxyribonucleic acid (DNA) are packaged into a micrometer-scale nucleus, we begin with the most fundamental level of organization: the \"beads-on-a-string\" fiber. This exercise develops your intuition for this first level of compaction by deriving how the linear packing density of DNA depends on a key, experimentally measurable parameter, the Nucleosome Repeat Length ($NRL$). By translating a simplified geometric model into a quantitative expression, you will practice connecting molecular-scale parameters to the emergent physical properties of the chromatin fiber .",
            "id": "3853361",
            "problem": "Consider a coarse-grained \"beads-on-a-string\" model of a chromatin fiber under low ionic strength where nucleosome cores are approximated as rigid, impenetrable spheres and linker deoxyribonucleic acid (DNA) segments are modeled as straight B-form DNA. In this model, the nucleosome core particle wraps exactly $147$ base pairs (bp) of DNA and contributes a fixed geometric span along the fiber equal to its effective diameter $D$ (in nanometers). The B-form DNA rise per base pair is $r$ (in nanometers per base pair), assumed constant under the stated conditions. The nucleosome repeat length (NRL) is defined as the average number of base pairs per nucleosome, including both the $147$ bp wrapped on the core and the average linker DNA between successive cores.\n\nStarting from these definitions and geometric assumptions, derive the relationship between average linker DNA length and nucleosome repeat length. Then, using this relationship, derive an analytical expression for the linear packing density of the chromatin fiber, defined as the number of base pairs per nanometer of fiber contour length, as a function of NRL, $D$, and $r$. Express the linear packing density in base pairs per nanometer.\n\nYour final answer must be a single closed-form expression for the linear packing density as a function of NRL, $D$, and $r$ (no numerical evaluation is required). Do not include any units inside your final expression.",
            "solution": "The problem requires the derivation of an analytical expression for the linear packing density of a chromatin fiber, modeled as \"beads-on-a-string,\" as a function of the nucleosome repeat length (NRL), the effective diameter of the nucleosome core particle ($D$), and the rise per base pair of B-form deoxyribonucleic acid (DNA) ($r$).\n\nThe problem statement has been validated and found to be scientifically grounded, well-posed, and internally consistent. It is based on a standard, albeit simplified, coarse-grained model used in computational chemical biology and biophysics. All necessary parameters and definitions are provided.\n\nThe derivation is performed in two main steps. First, we establish the relationship between the given parameters. Second, we formulate the expression for the linear packing density using these relationships.\n\nLet us define the variables based on the problem statement:\n-   $\\mathrm{NRL}$ is the Nucleosome Repeat Length, the total number of base pairs per repeating unit (in bp).\n-   $N_{core}$ is the number of base pairs wrapped on the nucleosome core. It is given as a constant, $N_{core} = 147$ bp.\n-   $N_{linker}$ is the average number of base pairs in a linker DNA segment.\n-   $D$ is the effective diameter of the nucleosome core particle (in nm).\n-   $r$ is the rise per base pair for B-form DNA (in nm/bp).\n-   $\\rho$ is the linear packing density of the chromatin fiber (in bp/nm).\n\nThe first step is to relate the length of the linker DNA, in base pairs, to the NRL. By definition, the NRL is the total number of base pairs in a single repeating unit of the chromatin fiber, which consists of one nucleosome core and one linker DNA segment. Therefore, the NRL is the sum of the base pairs on the core and the base pairs in the linker.\n$$ \\mathrm{NRL} = N_{core} + N_{linker} $$\nGiven that $N_{core} = 147$ bp, we can solve for $N_{linker}$:\n$$ N_{linker} = \\mathrm{NRL} - N_{core} = \\mathrm{NRL} - 147 $$\nThis equation provides the average number of base pairs in a linker segment as a function of the NRL.\n\nThe second step is to derive the expression for the linear packing density, $\\rho$. The packing density is defined as the total number of base pairs per unit of contour length of the fiber. We can determine this ratio by considering a single repeating unit.\n$$ \\rho = \\frac{\\text{Total number of base pairs in one repeating unit}}{\\text{Contour length of one repeating unit}} $$\nThe total number of base pairs in one repeating unit is, by definition, the $\\mathrm{NRL}$.\n$$ \\text{Total base pairs} = \\mathrm{NRL} $$\nThe contour length of one repeating unit, $L_{unit}$, is the sum of the length contributed by the nucleosome core and the length of the linker DNA segment. According to the model, the nucleosome core contributes a length equal to its effective diameter, $D$. The linker DNA is modeled as a straight rod, so its length, $L_{linker}$, is the product of the number of base pairs it contains, $N_{linker}$, and the rise per base pair, $r$.\n$$ L_{linker} = N_{linker} \\times r $$\nThe total contour length of the unit is therefore:\n$$ L_{unit} = D + L_{linker} $$\nSubstituting the expression for $L_{linker}$:\n$$ L_{unit} = D + (N_{linker} \\times r) $$\nNow, we substitute our previously derived expression for $N_{linker}$ in terms of $\\mathrm{NRL}$:\n$$ L_{unit} = D + (\\mathrm{NRL} - 147)r $$\nFinally, we assemble the expression for the linear packing density, $\\rho$, by dividing the total number of base pairs by the total contour length of the repeating unit:\n$$ \\rho = \\frac{\\mathrm{NRL}}{L_{unit}} = \\frac{\\mathrm{NRL}}{D + (\\mathrm{NRL} - 147)r} $$\nThis final expression represents the linear packing density in units of base pairs per nanometer, as a function of the required variables $\\mathrm{NRL}$, $D$, and $r$.",
            "answer": "$$ \\boxed{\\frac{\\mathrm{NRL}}{D + (\\mathrm{NRL} - 147)r}} $$"
        },
        {
            "introduction": "Chromatin is a highly dynamic structure, actively organized by molecular motors that consume energy to shape the genome in three dimensions. This practice explores the mechanochemical principles governing cohesin, a motor complex crucial for extruding loops of DNA. You will apply the first law of thermodynamics to a non-equilibrium steady-state system, balancing the chemical energy from ATP hydrolysis against mechanical work and frictional dissipation to determine the physical limits on the motor's speed. This exercise provides a tangible link between molecular bioenergetics and the large-scale dynamics of chromosome organization .",
            "id": "3853306",
            "problem": "Cohesin complexes are thought to extrude chromatin loops by coupling the hydrolysis of adenosine triphosphate (ATP) to directed motion along deoxyribonucleic acid (DNA). Consider a mechanochemical cycle in which each cycle translocates the complex a contour distance $s$ along DNA while hydrolyzing $n$ ATP molecules. The free energy released per hydrolyzed ATP under physiological conditions is $|\\Delta G_{\\mathrm{ATP}}|$, and only a fraction $\\eta$ of this chemical free energy is converted into useful mechanical work on the degrees of freedom responsible for extrusion. The motion experiences a constant external opposing load $F$ (for example, arising from tension or protein obstacles) and a linear velocity-dependent dissipative force characterized by an effective friction coefficient $\\gamma$, so that the total opposing force on motion at instantaneous velocity $v$ is $F+\\gamma v$. Assume steady-state nonequilibrium operation in which the chemical power input balances the mechanical power dissipated by working against load and friction. In addition, the catalytic turnover of the mechanochemical cycle is limited by a maximum cycle frequency $k_{\\mathrm{cat}}$ under saturating ATP.\n\nStarting from the First Law of Thermodynamics for steady-state energy flow, the definition of mechanical power $P_{\\mathrm{mech}}=F_{\\mathrm{tot}}\\,v$, and the relation between cycle frequency $f$ and velocity $v=s\\,f$, derive the expression for the maximal steady-state extrusion velocity $v_{\\max}$ consistent with both the energy budget and the catalytic rate limit. Then, using the following experimentally plausible parameter values for cohesin on DNA:\n- $|\\Delta G_{\\mathrm{ATP}}|=80\\,\\mathrm{pN}\\cdot\\mathrm{nm}$,\n- $n=2$,\n- $\\eta=0.40$,\n- $s=30\\,\\mathrm{nm}$ per mechanochemical cycle,\n- $F=0.20\\,\\mathrm{pN}$,\n- $\\gamma=0.010\\,\\mathrm{pN}\\cdot\\mathrm{s}\\cdot\\mathrm{nm}^{-1}$,\n- $k_{\\mathrm{cat}}=15\\,\\mathrm{s}^{-1}$,\n\ncompute $v_{\\max}$ and express it in kilobase pairs per second (kb/s), using the contour length conversion $1\\,\\mathrm{bp}=0.34\\,\\mathrm{nm}$. Round your answer to three significant figures. No angle units are involved in this problem. The final reported value must be a single real number in kb/s.",
            "solution": "The problem statement has been validated and is deemed scientifically grounded, well-posed, objective, and internally consistent. It presents a standard biophysical model of a molecular motor, providing all necessary parameters and relationships to determine a unique solution.\n\nThe problem requires finding the maximal steady-state extrusion velocity, $v_{\\max}$. This velocity is subject to two independent physical constraints: a thermodynamic limit imposed by the energy budget (power balance) and a kinetic limit imposed by the enzyme's maximum catalytic rate. The actual maximal velocity will be the lower of the two velocities determined by these constraints.\n\nFirst, we establish the thermodynamic limit. The First Law of Thermodynamics, applied to this non-equilibrium steady-state system, dictates that the chemical power input must equal the mechanical power output.\n\nThe chemical power input, $P_{\\mathrm{in}}$, is the rate at which usable chemical free energy is supplied by ATP hydrolysis. Each mechanochemical cycle hydrolyzes $n$ ATP molecules, releasing a total free energy of $n |\\Delta G_{\\mathrm{ATP}}|$. A fraction $\\eta$ of this energy is converted into useful mechanical work. If the cycle operates at a frequency $f$, the usable power input is:\n$$ P_{\\mathrm{in}} = f \\cdot \\eta \\cdot n |\\Delta G_{\\mathrm{ATP}}| $$\n\nThe mechanical power output, $P_{\\mathrm{mech}}$, is the rate at which work is done against the total opposing force, $F_{\\mathrm{tot}}$. The total force is the sum of the constant external load $F$ and the velocity-dependent dissipative (frictional) force $\\gamma v$.\n$$ F_{\\mathrm{tot}} = F + \\gamma v $$\nThe mechanical power is defined as $P_{\\mathrm{mech}} = F_{\\mathrm{tot}} v$.\n$$ P_{\\mathrm{mech}} = (F + \\gamma v) v $$\n\nAt steady state, the power input balances the power output:\n$$ P_{\\mathrm{in}} = P_{\\mathrm{mech}} $$\n$$ f \\eta n |\\Delta G_{\\mathrm{ATP}}| = (F + \\gamma v) v $$\nWe are given the relationship between the linear velocity $v$ and the cycle frequency $f$: $v = s f$, where $s$ is the translocation distance per cycle. We can substitute $f = v/s$ into the energy balance equation:\n$$ \\left(\\frac{v}{s}\\right) \\eta n |\\Delta G_{\\mathrm{ATP}}| = (F + \\gamma v) v $$\nAssuming a non-zero extrusion velocity ($v  0$), we can divide both sides by $v$:\n$$ \\frac{\\eta n |\\Delta G_{\\mathrm{ATP}}|}{s} = F + \\gamma v $$\nThis equation defines the maximum velocity, $v_{\\mathrm{thermo}}$, that is sustainable by the energy budget. Solving for $v$ gives:\n$$ \\gamma v = \\frac{\\eta n |\\Delta G_{\\mathrm{ATP}}|}{s} - F $$\n$$ v_{\\mathrm{thermo}} = \\frac{1}{\\gamma} \\left( \\frac{\\eta n |\\Delta G_{\\mathrm{ATP}}|}{s} - F \\right) $$\n\nSecond, we establish the kinetic limit. The motor's catalytic cycle has an intrinsic maximum frequency, $k_{\\mathrm{cat}}$. This limits the cycle frequency $f$ such that $f \\le k_{\\mathrm{cat}}$. This imposes a hard limit on the velocity, $v_{\\mathrm{kin}}$, which is simply the translocation distance per cycle multiplied by the maximum cycle frequency:\n$$ v_{\\mathrm{kin}} = s \\cdot k_{\\mathrm{cat}} $$\n\nThe true maximal steady-state velocity, $v_{\\max}$, must satisfy both the thermodynamic and kinetic constraints. Therefore, it is the minimum of the two calculated velocities:\n$$ v_{\\max} = \\min(v_{\\mathrm{thermo}}, v_{\\mathrm{kin}}) = \\min\\left( \\frac{1}{\\gamma} \\left( \\frac{\\eta n |\\Delta G_{\\mathrm{ATP}}|}{s} - F \\right), s k_{\\mathrm{cat}} \\right) $$\n\nNow, we substitute the given numerical values:\n- $|\\Delta G_{\\mathrm{ATP}}| = 80\\,\\mathrm{pN}\\cdot\\mathrm{nm}$\n- $n = 2$\n- $\\eta = 0.40$\n- $s = 30\\,\\mathrm{nm}$\n- $F = 0.20\\,\\mathrm{pN}$\n- $\\gamma = 0.010\\,\\mathrm{pN}\\cdot\\mathrm{s}\\cdot\\mathrm{nm}^{-1}$\n- $k_{\\mathrm{cat}} = 15\\,\\mathrm{s}^{-1}$\n\nWe calculate $v_{\\mathrm{thermo}}$:\n$$ v_{\\mathrm{thermo}} = \\frac{1}{0.010} \\left( \\frac{0.40 \\cdot 2 \\cdot 80}{30} - 0.20 \\right) \\,\\frac{\\mathrm{nm}}{\\mathrm{s}} $$\n$$ v_{\\mathrm{thermo}} = 100 \\left( \\frac{64}{30} - 0.20 \\right) \\,\\frac{\\mathrm{nm}}{\\mathrm{s}} $$\n$$ v_{\\mathrm{thermo}} = 100 \\left( \\frac{32}{15} - \\frac{1}{5} \\right) \\,\\frac{\\mathrm{nm}}{\\mathrm{s}} = 100 \\left( \\frac{32 - 3}{15} \\right) \\,\\frac{\\mathrm{nm}}{\\mathrm{s}} $$\n$$ v_{\\mathrm{thermo}} = 100 \\left( \\frac{29}{15} \\right) \\,\\frac{\\mathrm{nm}}{\\mathrm{s}} = \\frac{2900}{15} \\,\\frac{\\mathrm{nm}}{\\mathrm{s}} = \\frac{580}{3} \\,\\frac{\\mathrm{nm}}{\\mathrm{s}} \\approx 193.33\\,\\frac{\\mathrm{nm}}{\\mathrm{s}} $$\n\nNext, we calculate $v_{\\mathrm{kin}}$:\n$$ v_{\\mathrm{kin}} = (30\\,\\mathrm{nm}) \\cdot (15\\,\\mathrm{s}^{-1}) = 450\\,\\frac{\\mathrm{nm}}{\\mathrm{s}} $$\n\nComparing the two limits:\n$$ v_{\\max} = \\min\\left( \\frac{580}{3}\\,\\frac{\\mathrm{nm}}{\\mathrm{s}}, 450\\,\\frac{\\mathrm{nm}}{\\mathrm{s}} \\right) = \\frac{580}{3}\\,\\frac{\\mathrm{nm}}{\\mathrm{s}} $$\nThe system is limited by the thermodynamic energy budget, not the catalytic turnover rate.\n\nThe final step is to convert this velocity from $\\mathrm{nm}/\\mathrm{s}$ to kilobase pairs per second (kb/s). We are given the conversion factor $1\\,\\mathrm{bp} = 0.34\\,\\mathrm{nm}$, which implies $1\\,\\mathrm{nm} = \\frac{1}{0.34}\\,\\mathrm{bp}$.\n$$ v_{\\max} = \\frac{580}{3} \\frac{\\mathrm{nm}}{\\mathrm{s}} \\times \\frac{1\\,\\mathrm{bp}}{0.34\\,\\mathrm{nm}} = \\frac{580}{3 \\cdot 0.34} \\frac{\\mathrm{bp}}{\\mathrm{s}} = \\frac{580}{1.02} \\frac{\\mathrm{bp}}{\\mathrm{s}} \\approx 568.627\\,\\frac{\\mathrm{bp}}{\\mathrm{s}} $$\nTo convert from bp/s to kb/s, we divide by $1000$:\n$$ v_{\\max} \\approx \\frac{568.627}{1000} \\frac{\\mathrm{kb}}{\\mathrm{s}} \\approx 0.568627\\,\\frac{\\mathrm{kb}}{\\mathrm{s}} $$\nRounding the result to three significant figures gives $0.569\\,\\mathrm{kb}/\\mathrm{s}$.",
            "answer": "$$\n\\boxed{0.569}\n$$"
        },
        {
            "introduction": "The placement of nucleosomes is not random; it is influenced by the underlying DNA sequence, creating a complex occupancy landscape that shapes gene accessibility. This advanced computational practice challenges you to model this landscape using the principles of statistical mechanics and the power of dynamic programming. By implementing a forward-backward algorithm for a 1D lattice gas model, you will learn to calculate the probability of nucleosome occupancy from first principles, a cornerstone of modern quantitative models of gene regulation and chromatin structure .",
            "id": "3853325",
            "problem": "You are asked to implement a physically grounded, sequence-dependent model of nucleosome occupancy along deoxyribonucleic acid (DNA) using Dynamic Programming (DP). A nucleosome is modeled as a rigid particle of fixed span $w$ base pairs that cannot overlap with other nucleosomes (hard-core exclusion on a one-dimensional lattice). The DNA is a string of characters from the set $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ with length $L$. For each feasible start position $i \\in \\{0,1,\\dots,L-w\\}$ (using zero-based indexing), a nucleosome covering bases $i,i+1,\\dots,i+w-1$ has a sequence-dependent dimensionless energy $e_i$ measured in units of thermal energy $k_\\mathrm{B} T$ (Boltzmann constant times temperature). The energy is defined by the sum\n$$\ne_i \\;=\\; \\sum_{k=0}^{w-1} \\left( \\beta_{s_{i+k}} \\;+\\; \\alpha \\cos\\!\\left(\\frac{2\\pi k}{10}\\right) \\right),\n$$\nwhere $s_j$ is the base at position $j$, $\\beta_{\\text{A}},\\beta_{\\text{C}},\\beta_{\\text{G}},\\beta_{\\text{T}}$ are base-specific contributions (dimensionless, in units of $k_\\mathrm{B} T$ per base), $\\alpha$ is the amplitude of a bending preference term capturing the approximately $10$ base-pair periodicity of DNA wrapping around the nucleosome (dimensionless), and the cosine function uses radians. A dimensionless chemical potential $\\mu$ (in units of $k_\\mathrm{B} T$) controls the average number of nucleosomes via grand-canonical weighting.\n\nUnder the grand-canonical ensemble at fixed chemical potential, each non-overlapping configuration $\\mathcal{C}$ of nucleosomes has Boltzmann weight proportional to\n$$\n\\exp\\!\\left(\\sum_{i \\in \\mathcal{C}} \\left(\\mu - e_i\\right)\\right),\n$$\nand the partition function $Z$ is the sum of these weights over all non-overlapping configurations on the lattice of length $L$.\n\nYour tasks are:\n- From the exclusion principle and the Boltzmann weighting, derive a computationally efficient DP that exactly computes the partition function and the expected probability that a given base is covered by at least one nucleosome.\n- Implement the DP to compute the expected occupancy probability at specified base positions (the probability that the base is covered by any nucleosome), for each test case below.\n- Report the occupancy probabilities as decimal numbers rounded to six decimal places. Angles in trigonometric functions must be interpreted in radians.\n\nFundamental base that must be used:\n- Hard-core exclusion for nucleosomes modeled as fixed-length particles on a one-dimensional lattice.\n- Boltzmann distribution: probabilities proportional to exponentials of negative energies (or energies shifted by chemical potential) and the definition of a partition function as the sum of weights over allowed microstates.\n- The definition of chemical potential and the use of grand-canonical ensemble to weight particle numbers.\n\nForbidden shortcuts:\n- You must not assume or quote any pre-derived occupancy formulas; start from the above principles to construct the DP recurrence and the forward-backward logic to compute expected start probabilities and then per-base coverage.\n\nScientific realism:\n- Use the energy model given above with base-specific contributions and a $10$ base-pair periodic term.\n- The cosine periodicity must be evaluated in radians, with the argument $\\frac{2\\pi k}{10}$ for integer $k$.\n\nTest Suite:\nFor each test case, you are given the DNA sequence $s$, nucleosome span $w$, base contributions $(\\beta_{\\text{A}},\\beta_{\\text{C}},\\beta_{\\text{G}},\\beta_{\\text{T}})$, amplitude $\\alpha$, chemical potential $\\mu$, and a list of one-based base positions at which you must report occupancy probabilities.\n\n- Test Case $1$ (happy path):\n    - $s =$ the string formed by the motif $\\text{\"ACGT\"}$ repeated $50$ times (length $L = 200$).\n    - $w = 147$.\n    - $(\\beta_{\\text{A}},\\beta_{\\text{C}},\\beta_{\\text{G}},\\beta_{\\text{T}}) = (-0.20, 0.10, 0.05, -0.15)$.\n    - $\\alpha = 0.10$.\n    - $\\mu = 0.00$.\n    - Positions: $[50, 100, 150]$.\n\n- Test Case $2$ (boundary, no feasible placement):\n    - $s =$ the string formed by the motif $\\text{\"GATTACA\"}$ repeated $14$ times and concatenated with $\\text{\"GA\"}$ to reach length $L = 100$.\n    - $w = 120$.\n    - $(\\beta_{\\text{A}},\\beta_{\\text{C}},\\beta_{\\text{G}},\\beta_{\\text{T}}) = (0.00, 0.00, 0.00, 0.00)$.\n    - $\\alpha = 0.00$.\n    - $\\mu = 0.50$.\n    - Positions: $[1, 50, 100]$.\n\n- Test Case $3$ (high chemical potential, near saturation with single nucleosome possible):\n    - $s =$ the string formed by the motif $\\text{\"ACGT\"}$ repeated $45$ times (length $L = 180$).\n    - $w = 147$.\n    - $(\\beta_{\\text{A}},\\beta_{\\text{C}},\\beta_{\\text{G}},\\beta_{\\text{T}}) = (0.00, 0.00, 0.00, 0.00)$.\n    - $\\alpha = 0.00$.\n    - $\\mu = 2.00$.\n    - Positions: $[20, 80, 160]$.\n\n- Test Case $4$ (small span for edge coverage patterning):\n    - $s = \\text{\"ACGTACGTACGT\"}$ (length $L = 12$).\n    - $w = 3$.\n    - $(\\beta_{\\text{A}},\\beta_{\\text{C}},\\beta_{\\text{G}},\\beta_{\\text{T}}) = (-0.30, 0.20, 0.10, -0.05)$.\n    - $\\alpha = 0.00$.\n    - $\\mu = 0.30$.\n    - Positions: $[1, 6, 12]$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a list of the requested occupancy probabilities in the same order as the given positions, rounded to six decimal places. For example: $\\text{\"[[0.123456,0.654321],[0.000000,0.000000,0.000000]]\"}$.",
            "solution": "The user wants to solve a computational chemical biology problem by modeling nucleosome occupancy on DNA.\n\n### Step 1: Problem Validation\n\nThe problem is evaluated against the specified validation criteria.\n\n#### Givens Extraction:\n- **System**: A DNA string $s$ of length $L$ from the alphabet $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$. This represents a one-dimensional lattice.\n- **Particles**: Nucleosomes, modeled as rigid rods of span $w$ base pairs.\n- **Constraint**: Hard-core exclusion, meaning nucleosomes cannot overlap.\n- **Energy Model**: The dimensionless energy $e_i$ for a nucleosome starting at 0-indexed position $i \\in \\{0, 1, \\dots, L-w\\}$ is given by:\n$$\ne_i = \\sum_{k=0}^{w-1} \\left( \\beta_{s_{i+k}} + \\alpha \\cos\\!\\left(\\frac{2\\pi k}{10}\\right) \\right)\n$$\nwhere $s_j$ is the base at position $j$, $\\beta_{b}$ are base-specific energy contributions, and $\\alpha$ is an amplitude for a periodic bending preference. The argument to the cosine function is in radians.\n- **Ensemble**: The system is in the grand-canonical ensemble with a dimensionless chemical potential $\\mu$.\n- **Statistical Weight**: A non-overlapping configuration $\\mathcal{C}$ of nucleosomes (where $\\mathcal{C}$ is the set of starting positions of the nucleosomes) has a Boltzmann weight proportional to:\n$$\n\\exp\\!\\left(\\sum_{i \\in \\mathcal{C}} \\left(\\mu - e_i\\right)\\right)\n$$\n- **Partition Function**: The partition function $Z$ is the sum of these weights over all possible non-overlapping configurations, including the empty configuration which has a weight of $1$.\n- **Task**: Derive and implement a Dynamic Programming (DP) algorithm to compute the expected occupancy probability for specified base positions.\n- **Test Cases**: Four specific test cases are provided with all necessary parameters ($s, w, \\beta, \\alpha, \\mu$) and target positions for reporting occupancy.\n\n#### Validation Verdict:\nThe problem is **valid**.\n\n- **Scientific Grounding**: The problem describes a lattice gas model (specifically, a Tonks gas on a discrete lattice), which is a standard and fundamental model in statistical physics used to study binding phenomena. The use of a grand-canonical ensemble, Boltzmann weights, and a partition function are core principles of statistical mechanics. The energy function, while a simplification, is physically motivated, capturing sequence-dependent affinity ($\\beta$ terms) and structural propensities of DNA wrapping ($\\alpha$ term with a $10$ bp periodicity). The problem is firmly rooted in established scientific principles.\n- **Well-Posedness**: For a finite lattice of length $L$, the number of configurations is finite. This guarantees that the partition function $Z$ and all derived quantities like expectation values are well-defined and unique. The problem is mathematically well-posed.\n- **Objectivity and Completeness**: The problem is stated using precise mathematical language. All parameters, constants, and boundary conditions required for a unique solution are provided for each test case.\n- **Non-triviality**: The derivation of the forward-backward algorithm from first principles and its implementation is a non-trivial task requiring a solid understanding of statistical mechanics and dynamic programming. It is not a pseudo-profound or tautological problem.\n- **Scope**: The problem is directly related to *modeling chromatin structure and dynamics* within the field of *computational chemical biology*, as specified.\n\nThe problem is sound, complete, and well-posed, justifying a full solution.\n\n### Step 2: Derivation and Solution\n\nWe will derive a dynamic programming algorithm to solve this problem, starting from fundamental principles.\n\n#### Theoretical Formulation\nThe system consists of a 1D lattice of $L$ sites, representing the DNA bases. A nucleosome starting at site $i$ occupies sites $i, i+1, \\dots, i+w-1$. Two nucleosomes starting at $i$ and $j$ cannot overlap, which implies $|i-j| \\ge w$.\n\nA configuration $\\mathcal{C}$ is a set of starting positions $\\{i_1, i_2, \\dots, i_m\\}$ satisfying the non-overlapping constraint. In the grand-canonical ensemble, the statistical weight of placing a single nucleosome at site $i$ is $W_i = \\exp(\\mu - e_i)$, where $e_i$ is the binding energy. The weight of a configuration $\\mathcal{C}$ is $\\prod_{i \\in \\mathcal{C}} W_i$. The partition function $Z$ is the sum of weights over all possible configurations, including the empty configuration which has a weight of $1$.\n\n#### Dynamic Programming for the Partition Function\nTo compute the total partition function $Z$, we use a forward dynamic programming approach. Let $Z_F(j)$ be the partition function for the prefix of the DNA of length $j$, considering all valid nucleosome placements within sites $0, \\dots, j-1$.\n\nThe state of the system at site $j-1$ can be one of two possibilities:\n1.  Site $j-1$ is unoccupied. The configurations on the prefix $0, \\dots, j-2$ are independent of site $j-1$. The sum of weights for all such configurations is simply $Z_F(j-1)$.\n2.  Site $j-1$ is the last site covered by a nucleosome. This nucleosome must have a span of $w$ and therefore must start at site $j-w$. For this to be a valid configuration, the sites $0, \\dots, j-w-1$ must form a valid sub-configuration (i.e., no nucleosome ending after site $j-w-1$). The sum of weights for this prefix is $Z_F(j-w)$. This configuration is then extended by placing a nucleosome at site $j-w$, which contributes a weight of $W_{j-w}$.\n\nCombining these two mutually exclusive cases, we obtain the recurrence relation for $Z_F(j)$:\n$$\nZ_F(j) = Z_F(j-1) + Z_F(j-w) \\cdot W_{j-w} \\quad \\text{for } j \\ge w\n$$\n\nThe base cases are:\n- $Z_F(0) = 1$ (the empty lattice has one configuration with weight $1$).\n- For $0  j  w$, no nucleosome can be fully placed. Thus, site $j-1$ must be empty relative to any nucleosome *ending* at $j-1$. The recurrence simplifies to $Z_F(j) = Z_F(j-1)$, leading to $Z_F(j) = 1$ for $0 \\le j  w$.\n\nThe total partition function for the entire lattice of length $L$ is $Z_{\\text{total}} = Z_F(L)$.\n\n#### Forward-Backward Algorithm for Marginal Probabilities\nTo find the probability that a specific site is occupied, we first need the probability, $P_{\\text{start}}(i)$, that a nucleosome starts at a given position $i$. This is a marginal probability. We can compute it using a forward-backward algorithm. We have already defined the forward quantity $Z_F(j)$. Now we define a backward quantity.\n\nLet $Z_B(j)$ be the partition function for the suffix of the DNA from site $j$ to $L-1$. A similar reasoning yields the backward recurrence:\n$$\nZ_B(j) = Z_B(j+1) + W_j \\cdot Z_B(j+w) \\quad \\text{for } j \\le L-w\n$$\nThis considers two cases for site $j$: either it is empty (contributing $Z_B(j+1)$) or it is the start of a nucleosome (contributing $W_j \\cdot Z_B(j+w)$).\n\nThe base cases are:\n- $Z_B(L) = 1$ (empty suffix has weight $1$).\n- For $j  L-w$, no nucleosome can start, so $Z_B(j) = Z_B(j+1)$, which means $Z_B(j)=1$ for $j  L-w$.\n\nThe total partition function can be computed as $Z_{\\text{total}} = Z_F(L)$ or $Z_{\\text{total}} = Z_B(0)$. These two must be equal, providing a powerful consistency check.\n\nThe unnormalized probability (total weight) of all configurations having a nucleosome starting at position $i$ is the product of the partition functions of the three independent parts of the system:\n1.  The prefix $0, \\dots, i-1$, with partition function $Z_F(i)$.\n2.  The nucleosome at $i$, with weight $W_i$.\n3.  The suffix $i+w, \\dots, L-1$, with partition function $Z_B(i+w)$.\n\nThe probability of a nucleosome starting at site $i$ is then:\n$$\nP_{\\text{start}}(i) = \\frac{Z_F(i) \\cdot W_i \\cdot Z_B(i+w)}{Z_{\\text{total}}}\n$$\n\n#### Occupancy Probability Calculation\nThe final goal is to compute the probability, $P_{\\text{occ}}(j)$, that a base at a specific position $j$ is occupied. A base at site $j$ is occupied if it is covered by any nucleosome. A nucleosome starting at site $i$ covers the interval of sites $[i, i+w-1]$. Therefore, site $j$ is occupied if a nucleosome starts at any position $i$ such that $i \\le j  i+w$, which is equivalent to $j-w+1 \\le i \\le j$.\n\nLet $E_i$ be the event that a nucleosome starts at site $i$. The event that site $j$ is occupied is $O_j = \\bigcup_{i=\\max(0,j-w+1)}^j E_i$.\nThe events $E_{i_1}$ and $E_{i_2}$ are mutually exclusive if the corresponding nucleosomes would overlap, i.e., if $|i_1 - i_2|  w$. For any two distinct starting positions $i_1, i_2$ in the range $[\\max(0, j-w+1), j]$, this condition holds. Therefore, the events are mutually exclusive, and the probability of their union is the sum of their individual probabilities.\n\n$$\nP_{\\text{occ}}(j) = \\mathbb{P}(O_j) = \\sum_{i=\\max(0, j-w+1)}^j \\mathbb{P}(E_i) = \\sum_{i=\\max(0,j-w+1)}^j P_{\\text{start}}(i)\n$$\nThis sum includes all possible (and mutually exclusive) ways site $j$ can be covered. The summation range for $i$ must also respect the constraint $i \\le L-w$.\n\n#### Algorithmic Summary and Optimizations\nThe full algorithm is as follows:\n1.  Pre-compute energies $e_i$ and weights $W_i = \\exp(\\mu - e_i)$ for all valid start positions $i \\in [0, L-w]$.\n2.  Run the forward DP to compute all $Z_F(j)$ up to $j=L$.\n3.  Run the backward DP to compute all $Z_B(j)$ down to $j=0$.\n4.  Compute start probabilities $P_{\\text{start}}(i)$ for all $i \\in [0, L-w]$.\n5.  For each requested position $j$, compute $P_{\\text{occ}}(j)$ by summing the relevant $P_{\\text{start}}(i)$ values.\n\nSpecial cases can simplify the calculation:\n- If $L  w$, no nucleosomes can be placed. $Z_{\\text{total}}=1$ and all $P_{\\text{occ}}(j)=0$.\n- If $w \\le L  2w$, at most one nucleosome can be placed. The configurations are the empty state (weight $1$) and states with one nucleosome at position $i$ (weight $W_i$). The partition function is $Z_{\\text{total}} = 1 + \\sum_{i=0}^{L-w} W_i$. The start probability is simply $P_{\\text{start}}(i) = W_i / Z_{\\text{total}}$. The full DP is not required.\nThese optimizations are useful for Test Cases 1, 2, and 3. The full DP is necessary for Test Case 4.",
            "answer": "```python\nimport numpy as np\n\ndef calculate_occupancies(s, w, betas, alpha, mu, positions):\n    \"\"\"\n    Calculates nucleosome occupancy probabilities using Dynamic Programming.\n\n    Args:\n        s (str): DNA sequence.\n        w (int): Nucleosome span.\n        betas (tuple): Base-specific contributions (A, C, G, T).\n        alpha (float): Amplitude of bending preference.\n        mu (float): Chemical potential.\n        positions (list): 1-based positions to report occupancy.\n\n    Returns:\n        list: A list of occupancy probabilities for the requested positions.\n    \"\"\"\n    L = len(s)\n    \n    # Trivial case: DNA is shorter than a nucleosome.\n    if L  w:\n        return [0.0] * len(positions)\n\n    # --- Step 1: Pre-computation of energies and weights ---\n    base_map = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    seq_indices = np.array([base_map[b] for b in s], dtype=int)\n    betas_map = np.array(betas, dtype=float)\n    \n    num_placements = L - w + 1\n    energies = np.zeros(num_placements)\n    \n    # Sequence-independent part of the energy\n    k_range = np.arange(w)\n    alpha_term_sum = alpha * np.sum(np.cos(2 * np.pi * k_range / 10.0))\n\n    # Sliding window sum for beta contributions\n    current_beta_sum = np.sum(betas_map[seq_indices[:w]])\n    energies[0] = current_beta_sum + alpha_term_sum\n    for i in range(1, num_placements):\n        current_beta_sum -= betas_map[seq_indices[i-1]]\n        current_beta_sum += betas_map[seq_indices[i+w-1]]\n        energies[i] = current_beta_sum + alpha_term_sum\n        \n    weights = np.exp(mu - energies)\n\n    # --- Step 2: Simplified calculation for L  2w (at most one nucleosome) ---\n    if L  2 * w:\n        z_total = 1.0 + np.sum(weights)\n        if z_total == 0: return [0.0] * len(positions) # Avoid division by zero\n        \n        p_start = weights / z_total\n        \n        results = []\n        for pos in positions:\n            j = pos - 1  # Convert to 0-based index\n            occ_prob = 0.0\n            start_idx = max(0, j - w + 1)\n            end_idx = min(j, num_placements - 1)\n            if start_idx = end_idx:\n                occ_prob = np.sum(p_start[start_idx : end_idx + 1])\n            results.append(occ_prob)\n        return results\n\n    # --- Step 3: Full DP for general case (L = 2w) ---\n    # Forward DP to compute prefix partition functions\n    F = np.zeros(L + 1)\n    F[0] = 1.0\n    for j in range(1, L + 1):\n        F[j] = F[j-1]\n        if j = w:\n            F[j] += F[j-w] * weights[j-w]\n            \n    z_total = F[L]\n    if z_total == 0: return [0.0] * len(positions)\n    \n    # Backward DP to compute suffix partition functions\n    # Use a larger array to simplify indexing for B[j+w]\n    B = np.zeros(L + w) \n    B[L:] = 1.0 # Suffixes of length 0 or starting beyond L have partition function 1\n    for j in range(L - 1, -1, -1):\n        B[j] = B[j+1]\n        if j  num_placements:\n            B[j] += weights[j] * B[j+w]\n            \n    # --- Step 4: Calculate start probabilities ---\n    p_start = np.zeros(num_placements)\n    for i in range(num_placements):\n        p_start[i] = (F[i] * weights[i] * B[i+w]) / z_total\n\n    # --- Step 5: Calculate occupancy probabilities ---\n    results = []\n    for pos in positions:\n        j = pos - 1  # Convert to 0-based index\n        occ_prob = 0.0\n        start_idx = max(0, j - w + 1)\n        end_idx = min(j, num_placements - 1)\n        if start_idx = end_idx:\n             occ_prob = np.sum(p_start[start_idx : end_idx + 1])\n        results.append(occ_prob)\n        \n    return results\n\ndef solve():\n    \"\"\"\n    Solves the problem for all given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"s\": \"ACGT\" * 50, \"w\": 147,\n            \"betas\": (-0.20, 0.10, 0.05, -0.15), \"alpha\": 0.10, \"mu\": 0.00,\n            \"positions\": [50, 100, 150]\n        },\n        {\n            \"s\": \"GATTACA\" * 14 + \"GA\", \"w\": 120,\n            \"betas\": (0.00, 0.00, 0.00, 0.00), \"alpha\": 0.00, \"mu\": 0.50,\n            \"positions\": [1, 50, 100]\n        },\n        {\n            \"s\": \"ACGT\" * 45, \"w\": 147,\n            \"betas\": (0.00, 0.00, 0.00, 0.00), \"alpha\": 0.00, \"mu\": 2.00,\n            \"positions\": [20, 80, 160]\n        },\n        {\n            \"s\": \"ACGTACGTACGT\", \"w\": 3,\n            \"betas\": (-0.30, 0.20, 0.10, -0.05), \"alpha\": 0.00, \"mu\": 0.30,\n            \"positions\": [1, 6, 12]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        occupancies = calculate_occupancies(\n            s=case[\"s\"], w=case[\"w\"], betas=case[\"betas\"], \n            alpha=case[\"alpha\"], mu=case[\"mu\"], positions=case[\"positions\"]\n        )\n        # Format results to six decimal places\n        formatted_probs = [f\"{p:.6f}\" for p in occupancies]\n        all_results.append(f\"[{','.join(formatted_probs)}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}