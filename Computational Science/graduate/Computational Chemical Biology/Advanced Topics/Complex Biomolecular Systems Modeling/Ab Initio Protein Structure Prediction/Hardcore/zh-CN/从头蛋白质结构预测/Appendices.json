{
    "hands_on_practices": [
        {
            "introduction": "要理解从头预测的挑战，第一步是领会构象空间的巨大规模。这个练习  使用简化的晶格模型，让你亲手计算一个短肽链可能构象的数量。通过这个计算，你将具体地理解为何蛮力搜索对于真实蛋白质是不可行的，以及模型的参数（如配位数）如何影响搜索空间的规模。",
            "id": "2369923",
            "problem": "在从头算蛋白质结构预测中，通常使用简化的晶格模型来估计构象搜索空间的大小。考虑一个长度为 $12$ 的同聚物链（一个 $12$-聚体），表示在离散晶格上。将此链模拟为一种不可逆的最近邻行走：从一个固定在原点的初始单体开始，每个后续单体占据前一个单体的最近邻位置，唯一的空间位阻约束是禁止立即回溯到刚访问过的位置。为了消除由全局平移和旋转引起的冗余，第一个键矢量（从单体 $1$ 到单体 $2$）被固定在一个参考晶格方向上。\n\n设键的数量为 $m$，对于一个 $12$-聚体，有 $m=11$。设配位数（每个晶格点的最近邻数）为 $z$。对于此处考虑的两种晶格，二维三角晶格的配位数为 $z_{\\mathrm{tri}}=6$，三维简单立方晶格的配位数为 $z_{\\mathrm{sc}}=6$。\n\n在这些假设下，确定链在每种晶格上可用的不同构象的总数，并以单个实数的形式报告两种构象空间大小的比率（三角晶格与立方晶格之比）作为最终答案。无需四舍五入，也无需单位。",
            "solution": "该链由 $12$ 个单体组成，因此行走中有 $m=11$ 个键（或步）。第一个单体固定在原点，第一个键矢量被固定在一个参考方向上，以消除由全局平移和旋转引起的简并性。因此，选择的数量从第二个键开始计算。\n\n在第一个键之后的每一步，不可逆约束允许除返回到紧邻前一个位点的方向外的所有最近邻方向。如果晶格的配位数为 $z$，那么在每一步中都有 $z-1$ 个允许的方向。\n\n由于第一个键的方向是固定的，不同构象的数量由剩下 $m-1$ 个键的选择序列决定。因此，对于配位数为 $z$ 的晶格，在这些假设下，构象的总数为\n$$\n(z-1)^{m-1}.\n$$\n对于这两种晶格：\n- 二维三角晶格：$z_{\\mathrm{tri}}=6$，得到\n$$\n\\text{triangular count}=(6-1)^{11-1}=5^{10}.\n$$\n- 三维简单立方晶格：$z_{\\mathrm{sc}}=6$，得到\n$$\n\\text{cubic count}=(6-1)^{11-1}=5^{10}.\n$$\n因此，构象空间大小的比率（三角晶格与立方晶格之比）为\n$$\n\\frac{5^{10}}{5^{10}}=1.\n$$\n这是两种晶格在第一个键方向固定的不可逆行走模型下具有相同配位数 $z=6$ 的直接结果。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "在广阔的构象空间中，我们需要一个评价标准来区分优劣，这就是能量函数的作用。这个练习  聚焦于能量函数的关键组成部分——控制肽键二面角 $\\omega$ 的扭转势。通过计算顺式和反式构象间的能量差，你将深入理解这些基本的能量项如何决定蛋白质的立体化学偏好，包括脯氨酸的独特性质。",
            "id": "3834586",
            "problem": "在计算化学生物学领域的从头蛋白质结构预测中，构象能量学源于基于玻恩-奥本海默近似和共价框架中扭转自由度的周期性的第一性原理。肽键二面角，用 $\\omega$ 表示，由于共振产生的部分双键特性，被限制在接近平面，从而导致有利的反式构型和不利的顺式构型。考虑一个肽主链的扭转势，其模型为一个截断的傅里叶级数：\n$$\nV(\\omega) \\;=\\; \\sum_{n=1}^{3} k_n \\left[\\, 1 + \\cos(n\\,\\omega - \\delta_n) \\,\\right],\n$$\n其中 $\\omega$ 以弧度为单位， $k_n$ 是以千卡/摩尔为单位的能量系数，$\\delta_n$ 是相位偏移。使用以下与非脯氨酸肽一致的物理上合理的参数：\n- $k_1 = 1.6$ (千卡/摩尔)，$\\delta_1 = 0$，\n- $k_2 = 1.2$ (千卡/摩尔)，$\\delta_2 = 0$，\n- $k_3 = 0.25$ (千卡/摩尔)，$\\delta_3 = \\pi$。\n\n定义顺式状态为 $\\omega_{\\mathrm{cis}} = 0$，反式状态为 $\\omega_{\\mathrm{trans}} = \\pi$。从 $V(\\omega)$ 作为由电子和空间相互作用引起的扭转能罚及其旋转对称性所隐含的周期性的物理意义出发，计算能量差\n$$\n\\Delta E \\;=\\; V(\\omega_{\\mathrm{cis}})\\;-\\;V(\\omega_{\\mathrm{trans}}).\n$$\n将最终能量差以千卡/摩尔表示，并将您的答案四舍五入到四位有效数字。最后，在不引入任何新的数值参数的情况下，运用相同的基于傅里叶的表示方法，从原理上解释为什么脯氨酸的特殊情况通常比其他氨基酸表现出更小的顺反式 $\\Delta E$，并说明环约束对奇数次谐波的影响。",
            "solution": "肽键的扭转势能 $V(\\omega)$ 由以下截断的傅里叶级数给出：\n$$\nV(\\omega) \\;=\\; \\sum_{n=1}^{3} k_n \\left[\\, 1 + \\cos(n\\,\\omega - \\delta_n) \\,\\right]\n$$\n非脯氨酸肽的参数提供如下：\n- $n=1$: $k_1 = 1.6 \\, \\text{kcal/mol}$，$\\delta_1 = 0$\n- $n=2$: $k_2 = 1.2 \\, \\text{kcal/mol}$，$\\delta_2 = 0$\n- $n=3$: $k_3 = 0.25 \\, \\text{kcal/mol}$，$\\delta_3 = \\pi$\n\n首先，我们通过代入这些参数来写出势能函数的显式形式。\n$$\nV(\\omega) = k_1 [1 + \\cos(1 \\cdot \\omega - \\delta_1)] + k_2 [1 + \\cos(2 \\cdot \\omega - \\delta_2)] + k_3 [1 + \\cos(3 \\cdot \\omega - \\delta_3)]\n$$\n$$\nV(\\omega) = 1.6 [1 + \\cos(\\omega - 0)] + 1.2 [1 + \\cos(2\\omega - 0)] + 0.25 [1 + \\cos(3\\omega - \\pi)]\n$$\n使用三角恒等式 $\\cos(x - \\pi) = -\\cos(x)$，第三项变为 $0.25[1 - \\cos(3\\omega)]$。完整的表达式为：\n$$\nV(\\omega) = 1.6 [1 + \\cos(\\omega)] + 1.2 [1 + \\cos(2\\omega)] + 0.25 [1 - \\cos(3\\omega)]\n$$\n问题要求计算能量差 $\\Delta E = V(\\omega_{\\mathrm{cis}}) - V(\\omega_{\\mathrm{trans}})$，其中`顺式`状态在 $\\omega_{\\mathrm{cis}} = 0$ 弧度，`反式`状态在 $\\omega_{\\mathrm{trans}} = \\pi$ 弧度。\n\n我们计算在 $\\omega_{\\mathrm{cis}} = 0$ 处的势能：\n$$\nV(\\omega_{\\mathrm{cis}}) = V(0) = 1.6 [1 + \\cos(0)] + 1.2 [1 + \\cos(0)] + 0.25 [1 - \\cos(0)]\n$$\n由于 $\\cos(0) = 1$：\n$$\nV(0) = 1.6 [1 + 1] + 1.2 [1 + 1] + 0.25 [1 - 1]\n$$\n$$\nV(0) = 1.6(2) + 1.2(2) + 0.25(0) = 3.2 + 2.4 + 0 = 5.6 \\, \\text{kcal/mol}\n$$\n接下来，我们计算在 $\\omega_{\\mathrm{trans}} = \\pi$ 处的势能：\n$$\nV(\\omega_{\\mathrm{trans}}) = V(\\pi) = 1.6 [1 + \\cos(\\pi)] + 1.2 [1 + \\cos(2\\pi)] + 0.25 [1 - \\cos(3\\pi)]\n$$\n使用数值 $\\cos(\\pi) = -1$，$\\cos(2\\pi) = 1$ 和 $\\cos(3\\pi) = -1$：\n$$\nV(\\pi) = 1.6 [1 + (-1)] + 1.2 [1 + 1] + 0.25 [1 - (-1)]\n$$\n$$\nV(\\pi) = 1.6(0) + 1.2(2) + 0.25(2) = 0 + 2.4 + 0.5 = 2.9 \\, \\text{kcal/mol}\n$$\n那么能量差 $\\Delta E$ 为：\n$$\n\\Delta E = V(0) - V(\\pi) = 5.6 - 2.9 = 2.7 \\, \\text{kcal/mol}\n$$\n问题要求答案四舍五入到四位有效数字。\n$$\n\\Delta E = 2.700 \\, \\text{kcal/mol}\n$$\n\n对于第二部分，我们必须从原理上解释为什么脯氨酸表现出更小的 $\\Delta E$。为了使用傅里叶表示法严谨地做到这一点，我们首先推导出 $\\Delta E$ 的一般表达式。\n$$\n\\Delta E = V(0) - V(\\pi) = \\sum_{n=1}^{3} k_n [1 + \\cos(0 - \\delta_n)] - \\sum_{n=1}^{3} k_n [1 + \\cos(n\\pi - \\delta_n)]\n$$\n$$\n\\Delta E = \\sum_{n=1}^{3} k_n \\left\\{ [1 + \\cos(-\\delta_n)] - [1 + \\cos(n\\pi - \\delta_n)] \\right\\}\n$$\n使用 $\\cos(-x) = \\cos(x)$ 和 $\\cos(n\\pi - x) = \\cos(n\\pi)\\cos(x) = (-1)^n \\cos(x)$：\n$$\n\\Delta E = \\sum_{n=1}^{3} k_n [\\cos(\\delta_n) - (-1)^n\\cos(\\delta_n)] = \\sum_{n=1}^{3} k_n \\cos(\\delta_n) [1 - (-1)^n]\n$$\n项 $[1 - (-1)^n]$ 对偶数 $n$ 为 $0$，对奇数 $n$ 为 $2$。这证明了理想`顺式`和`反式`状态之间的能量差完全由势能的奇数次谐波决定。对于 $n=1, 2, 3$：\n$$\n\\Delta E = 2k_1\\cos(\\delta_1) + 0 \\cdot k_2\\cos(\\delta_2) + 2k_3\\cos(\\delta_3) = 2k_1\\cos(\\delta_1) + 2k_3\\cos(\\delta_3)\n$$\n这些奇数次谐波，特别是 $n=1$ 项，代表了`顺式`和`反式`状态之间的能量不对称性。在物理上，这种不对称性主要源于相邻残基上C$_\\alpha$碳原子及其取代基之间的空间排斥。对于非脯氨酸肽，`反式`构型 ($\\omega = \\pi$) 使这种排斥最小化，而`顺式`构型 ($\\omega = 0$) 会导致严重的空间冲突，从而产生一个大的正 $\\Delta E$。给定参数中 $k_1$ 的较大数值反映了这种强烈的偏好。\n\n在脯氨酸中，侧链是环化的，并与主链氮原子键合，形成一个刚性的吡咯烷环。这种独特的结构改变了空间环境：\n1. 脯氨酸环本身的体积会引入空间冲突。在X-Pro肽键（其中X是任意氨基酸）的`反式`构象中，残基X的C$_\\alpha$与脯氨酸环的C$_\\delta$之间存在冲突。\n2. 在`顺式`构象中，冲突发生在残基X的C$_\\alpha$与脯氨酸的C$_\\alpha$之间。\n关键的是，在脯氨酰肽中，`顺式`和`反式`的空间罚分比在非脯氨酸肽中更具可比性。相对于典型的肽键，`反式`状态被去稳定化（其能量升高），而`顺式`状态相对而言没有那么不利。这减小了两种状态之间的总能量差。\n\n将这一物理推理与傅里叶模型联系起来，`顺式`和`反式`状态之间能量不对称性的减小意味着在数学上编码这种不对称性的奇数次谐波的振幅必须更小。主导的奇数项是 $n=1$ 次谐波，其振幅由 $k_1$ 控制。因此，对于脯氨酸残基，参数 $k_1$ 预计会显著小于非脯氨酸残基。根据推导出的表达式 $\\Delta E = 2k_1\\cos(\\delta_1) + 2k_3\\cos(\\delta_3)$，一个更小的 $k_1$ 直接导致一个更小的 $\\Delta E$ 值，这与实验观察到的脯氨酸的`顺反式`能隙更小是一致的。",
            "answer": "$$\\boxed{2.700}$$"
        },
        {
            "introduction": "最后的这个实践将构象空间和能量函数的概念整合到一个完整的、虽然简化的结构预测问题中。你的任务是扩展经典的疏水-极性（HP）模型以包含带电残基，并编写程序进行穷举搜索，以找到最佳序列和结构 。这项练习将让你获得实现预测算法三个核心要素（表示、能量和搜索策略）的实践经验。",
            "id": "2369976",
            "problem": "本题要求您形式化并实现二维($2$D)疏水-极性(HP)格点蛋白质模型的一个扩展，该扩展为一个包含带电残基的四字母模型，这些残基分别表示为疏水(Hydrophobic)、极性(Polar)、带负电(Negative)、带正电(Cationic) (HPNC)。目标是搜索一个短多肽序列和一个在二维方格上的自回避$2$D构象，二者共同实现最小的加性接触能，同时包含至少一个盐桥。此处，盐桥定义为带负电残基和带正电残基之间的一种非连续的最近邻格点接触。\n\n请从适用于从头算蛋白质结构预测的格点蛋白质模型的第一性原理出发。基本依据必须是以下事实，不得使用任何简化公式：\n- 蛋白质可以被抽象为格点上的自回避行走，其中每个残基占据一个格点位置，而连续的残基在格点上是相邻的。只有非连续的最近邻残基对才被视为接触相互作用。\n- 疏水效应促使疏水残基在接触时产生有利的吸引作用，这被建模为疏水-疏水接触的负接触能贡献。\n- 带电残基之间的静电相互作用促使异种电荷接触产生有利能量，而同种电荷接触产生不利能量。在一个以格点间距为单位长度的粗粒化格点模型中，可以通过对异种电荷接触施加一个恒定的负贡献、对同种电荷接触施加一个恒定的正贡献来近似这一点，且仅适用于最近邻的非连续接触。\n- 加性假设：总能量是所有非连续接触残基对的两两接触能之和。\n\n您的程序必须实现以下精确的模型和搜索协议。\n- 残基类型为一个包含$4$个字母的字母表：疏水($\\mathrm{H}$)、极性($\\mathrm{P}$)、带负电($\\mathrm{N}$)和带正电($\\mathrm{C}$)。序列是该字母表上长度为$L$的字符串。\n- 构象是$\\mathbb{Z}^2$中二维方格上长度为$L$的自回避行走，指定为格点坐标列表$\\left[(x_0,y_0),(x_1,y_1),\\dots,(x_{L-1},y_{L-1})\\right]$，具有单位步长且无重复坐标。为避免冗余对称性，固定$(x_0,y_0)=(0,0)$和$(x_1,y_1)=(1,0)$。\n- 定义构象的接触集$\\mathcal{C}$为所有满足$0 \\le i  j \\le L-1$的无序索引对$(i,j)$，使得$|i-j| \\ge 2$且$(x_i,y_i)$和$(x_j,y_j)$之间的曼哈頓距离等于$1$。\n- 定义残基类型$a$和$b$的两两接触能函数$\\varepsilon(a,b)$如下，使用每个测试用例提供的参数$e_{\\mathrm{HH}}$、$e_{\\mathrm{NC}}$和$e_{\\mathrm{like}}$。为了编码，令$\\mathrm{H}=0$, $\\mathrm{P}=1$, $\\mathrm{N}=2$, $\\mathrm{C}=3$。那么：\n  - $\\varepsilon(\\mathrm{H},\\mathrm{H})=\\varepsilon(0,0)=e_{\\mathrm{HH}}$。\n  - $\\varepsilon(\\mathrm{N},\\mathrm{C})=\\varepsilon(2,3)=\\varepsilon(\\mathrm{C},\\mathrm{N})=\\varepsilon(3,2)=e_{\\mathrm{NC}}$。\n  - $\\varepsilon(\\mathrm{N},\\mathrm{N})=\\varepsilon(2,2)=e_{\\mathrm{like}}$ 且 $\\varepsilon(\\mathrm{C},\\mathrm{C})=\\varepsilon(3,3)=e_{\\mathrm{like}}$。\n  - 所有其他残基对的$\\varepsilon(a,b)=0$。\n- 对于一个序列$\\{t_i\\}_{i=0}^{L-1}$和一个接触集为$\\mathcal{C}$的构象，总能量为\n  $$E=\\sum_{(i,j)\\in\\mathcal{C}}\\varepsilon\\left(t_i,t_j\\right).$$\n- 盐桥计数为\n  $$S=\\left|\\left\\{(i,j)\\in\\mathcal{C}\\;:\\;\\{t_i,t_j\\}=\\{\\mathrm{N},\\mathrm{C}\\}\\right\\}\\right|.$$\n- 一个解必须至少含有一个盐桥，即$S \\ge 1$。\n\n搜索目标与决胜规则：\n- 在所有长度为$L$的HPNC字母表序列和所有如上定义的有效构象中，找到使$E$在$S \\ge 1$的约束下最小的配对。\n- 如果多个配对达到相同的最小$E$，选择$S$最大的那个。\n- 如果仍然存在平局，根据编码$\\mathrm{H}=0$, $\\mathrm{P}=1$, $\\mathrm{N}=2$, $\\mathrm{C}=3$选择字典序最小的序列，从左到右比较整数列表。\n- 如果仍然存在平局，选择其展平坐标列表$\\left[x_0,y_0,x_1,y_1,\\dots,x_{L-1},y_{L-1}\\right]$为字典序最小的构象。\n\n序列编码与输出表示：\n- 将序列编码为一个包含$L$个整数的列表，这些整数在$\\{0,1,2,3\\}$中，分别对应$\\mathrm{H},\\mathrm{P},\\mathrm{N},\\mathrm{C}$。\n- 将构象编码为一个包含$L$个坐标对的列表，每个坐标对是一个包含两个整数$\\left[x_i,y_i\\right]$的列表。\n\n您的程序必须执行穷举搜索，通过以下方式保证为下面的小型测试用例找到精确的最优解：\n- 枚举所有长度为$L$的、在方格上且满足上述锚定条件的自回避行走。\n- 枚举所有长度为$L$的、基于4个字母的字母表的所有序列。\n- 为每一对序列和构象精确计算$E$和$S$，并应用目标和决胜规则。\n\n测试套件：\n- 案例A (理想情况): $L=6$, $e_{\\mathrm{HH}}=-1.0$, $e_{\\mathrm{NC}}=-2.0$, $e_{\\mathrm{like}}=+0.5$。\n- 案例B (盐桥主导): $L=7$, $e_{\\mathrm{HH}}=0.0$, $e_{\\mathrm{NC}}=-2.5$, $e_{\\mathrm{like}}=+0.5$。\n- 案例C (强同种电荷排斥): $L=6$, $e_{\\mathrm{HH}}=-0.5$, $e_{\\mathrm{NC}}=-1.0$, $e_{\\mathrm{like}}=+1.0$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个结果对应一个测试用例，顺序与上面列出的一致。\n- 每个结果必须是一个形如$[E_{\\min},S_{\\mathrm{best}},\\mathrm{seq},\\mathrm{coords}]$的列表，其中$E_{\\min}$是四舍五入到三位小数的最小能量（作为一个实数），$S_{\\mathrm{best}}$是所选解的盐桥计数（作为一个整数），$\\mathrm{seq}$是所选序列，编码为$\\{0,1,2,3\\}$中的整数列表，$\\mathrm{coords}$是所选构象，编码为指定的坐标对列表。\n- 因此，最终输出必须是包含类似$[\\mathrm{r}_\\mathrm{A},\\mathrm{r}_\\mathrm{B},\\mathrm{r}_\\mathrm{C}]$的单行文本，其中每个$\\mathrm{r}_\\mathrm{X}$都是对应案例的上述格式的列表。不要打印任何其他文本。",
            "solution": "因此，解决方案被设计为一个穷举搜索算法，该算法系统地探索所有有效的序列-构象对，对其进行评估，并根据指定标准识别出最优对。该算法按以下步骤进行：\n\n首先，我们必须生成所有可能的分子实体的整个空间。这个空间是所有唯一的有效构象集合与所有可能的长度为$L$的序列集合的笛卡尔积。\n\n构象是$2$D方格上长度为$L$的自回避行走。为生成所有此类构象，我们采用递归回溯（深度优先搜索）算法。行走的前两个残基被锚定在坐标$(x_0,y_0)=(0,0)$和$(x_1,y_1)=(1,0)$处，以消除简单的旋转和平移对称性。递归过程一次扩展一个残基，探索所有四个基本方向，确保新的格点位置未被占据。当完成长度为$L$的行走时，就将其添加到我们的有效构象列表中。\n\n序列是字母表$\\{\\mathrm{H}, \\mathrm{P}, \\mathrm{N}, \\mathrm{C}\\}$上长度为$L$的字符串，我们将其编码为整数$\\{0, 1, 2, 3\\}$。序列总数为$4^L$。这些序列被系统地生成，确保每个可能的序列都得到考虑。这可以通过遍历所有以4为基数的$L$位数字来实现。\n\n对于每个构象和序列对，我们必须计算其总能量$E$和盐桥计数$S$。此评估分两步执行。\n1. 给定一个构象，我们首先确定其接触集$\\mathcal{C}$。一个接触是一个无序的残基索引对$(i,j)$，使得这些残基在序列中不相邻（$|i-j| \\ge 2$），但在格点上占据相邻位置。邻接关系通过检查其坐标之间的曼哈顿距离是否等于$1$来确定。\n2. 利用接触集$\\mathcal{C}$和序列$\\{t_i\\}_{i=0}^{L-1}$，我们计算总能量$E$和盐桥计数$S$。总能量是两两相互作用能之和，$E = \\sum_{(i,j)\\in\\mathcal{C}}\\varepsilon(t_i, t_j)$。能量函数$\\varepsilon(a,b)$由问题参数$e_{\\mathrm{HH}}$、$e_{\\mathrm{NC}}$和$e_{\\mathrm{like}}$定义，且仅对$\\mathrm{H}-\\mathrm{H}$、$\\mathrm{N}-\\mathrm{C}$、$\\mathrm{N}-\\mathrm{N}$和$\\mathrm{C}-\\mathrm{C}$接触非零。盐桥计数$S$是$\\mathcal{C}$中残基类型为$\\{\\mathrm{N}, \\mathrm{C}\\}$的接触数量。\n\n最后，我们确定最优解。搜索必须遵循一个严格的四级决胜规则。我们的目标是：\n1. 最小化总能量$E$。\n2. 对于给定的最小$E$，最大化盐桥计数$S$。\n3. 对于给定的$E$和$S$，选择字典序最小的序列（使用整数编码）。\n4. 作为最终的决胜条件，选择其展平坐标列表为字典序最小的构象。\n\n这种分层优化通过在整个穷举搜索过程中维护一个唯一的“迄今为止最佳”解来实现。每个新的有效候选解（即$S \\ge 1$的解）都与当前最佳解进行比较。如果一个候选解对应的目标元组比当前最佳解的目标元组在字典序上更小，则该候选解被视为“更优”。由序列$\\mathbf{t}$和构象$\\mathbf{x}$组成的候选解的目标元组构造为$(E, -S, \\mathbf{t}, \\mathbf{x}_{\\text{flat}})$，其中$\\mathbf{t}$是整数编码的残基类型元组，$\\mathbf{x}_{\\text{flat}}$是展平的坐标元组。对$S$取反正确地将最大化$S$的问题转化为最小化问题，从而适应字典序比较框架。通过遍历所有序列-构象对并应用此比较，算法保证能收敛到问题陈述所定义的唯一最优解。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef generate_conformations(L):\n    \"\"\"\n    Generates all self-avoiding walks of length L on a 2D square lattice,\n    anchored at (0,0) and (1,0).\n    \"\"\"\n    if L  2:\n        return []\n\n    # Anchored start as specified\n    path = [(0, 0), (1, 0)]\n    if L == 2:\n        return [tuple(path)]\n    \n    visited = set(path)\n    conformations = []\n    \n    def extend_walk(current_path, visited_sites):\n        if len(current_path) == L:\n            conformations.append(tuple(current_path))\n            return\n            \n        last_x, last_y = current_path[-1]\n        # Possible moves: North, South, East, West\n        moves = [(last_x, last_y + 1), (last_x, last_y - 1), (last_x + 1, last_y), (last_x - 1, last_y)]\n        \n        for next_pos in moves:\n            if next_pos not in visited_sites:\n                current_path.append(next_pos)\n                visited_sites.add(next_pos)\n                extend_walk(current_path, visited_sites)\n                visited_sites.remove(next_pos) # Backtrack\n                current_path.pop()\n\n    extend_walk(path, visited)\n    return conformations\n\ndef find_contacts(conf, L):\n    \"\"\"\n    Finds all non-consecutive nearest-neighbor contacts for a given conformation.\n    \"\"\"\n    contacts = []\n    for i in range(L - 1):\n        for j in range(i + 2, L):\n            xi, yi = conf[i]\n            xj, yj = conf[j]\n            if abs(xi - xj) + abs(yi - yj) == 1:\n                contacts.append((i, j))\n    return contacts\n\ndef make_energy_matrix(e_HH, e_NC, e_like):\n    \"\"\"\n    Creates the 4x4 pairwise energy matrix.\n    Encoding: H=0, P=1, N=2, C=3\n    \"\"\"\n    energy_matrix = np.zeros((4, 4), dtype=float)\n    energy_matrix[0, 0] = e_HH\n    energy_matrix[2, 3] = e_NC\n    energy_matrix[3, 2] = e_NC\n    energy_matrix[2, 2] = e_like\n    energy_matrix[3, 3] = e_like\n    return energy_matrix\n\ndef evaluate(seq, contacts, energy_matrix):\n    \"\"\"\n    Calculates total energy E and salt bridge count S for a sequence and its contacts.\n    \"\"\"\n    E = 0.0\n    S = 0\n    N_type, C_type = 2, 3\n    \n    for i, j in contacts:\n        type1, type2 = seq[i], seq[j]\n        E += energy_matrix[type1, type2]\n        if (type1 == N_type and type2 == C_type) or (type1 == C_type and type2 == N_type):\n            S += 1\n    return E, S\n\ndef find_optimal_structure(L, e_HH, e_NC, e_like):\n    \"\"\"\n    Performs the exhaustive search for the optimal sequence and conformation.\n    \"\"\"\n    energy_matrix = make_energy_matrix(e_HH, e_NC, e_like)\n    \n    all_conformations = generate_conformations(L)\n    \n    best_result_tuple = (float('inf'),)\n    best_solution_details = None\n\n    # Pre-calculate contacts for each conformation\n    conf_contacts = {conf: find_contacts(conf, L) for conf in all_conformations}\n    \n    # Iterate through all sequences and conformations to find the optimum\n    for seq in itertools.product(range(4), repeat=L):\n        seq_tuple = tuple(seq)\n        for conf in all_conformations:\n            contacts = conf_contacts[conf]\n            E, S = evaluate(seq_tuple, contacts, energy_matrix)\n\n            if S  1:\n                continue\n\n            conf_flat_tuple = tuple(coord for pair in conf for coord in pair)\n            current_result_tuple = (E, -S, seq_tuple, conf_flat_tuple)\n\n            if best_solution_details is None or current_result_tuple  best_result_tuple:\n                best_result_tuple = current_result_tuple\n                best_solution_details = (E, S, seq_tuple, conf)\n    \n    E, S, seq, conf = best_solution_details\n    return E, S, list(seq), [list(c) for c in conf]\n\ndef format_result_list(res_list):\n    \"\"\"\n    Formats the final result list for one test case into the required string format.\n    \"\"\"\n    E, S, seq, coords = res_list\n    E_str = f\"{E:.3f}\"\n    seq_str = str(seq).replace(\" \", \"\")\n    coords_str = str(coords).replace(\" \", \"\")\n    return f\"[{E_str},{S},{seq_str},{coords_str}]\"\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (L, e_HH, e_NC, e_like)\n        (6, -1.0, -2.0, 0.5),  # Case A\n        (7, 0.0, -2.5, 0.5),  # Case B\n        (6, -0.5, -1.0, 1.0),  # Case C\n    ]\n    \n    results = []\n    for L, e_HH, e_NC, e_like in test_cases:\n        E_min, S_best, seq, coords = find_optimal_structure(L, e_HH, e_NC, e_like)\n        results.append([E_min, S_best, seq, coords])\n    \n    final_output_str_parts = [format_result_list(res) for res in results]\n    final_output = f\"[{','.join(final_output_str_parts)}]\"\n    print(final_output)\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}