{
    "hands_on_practices": [
        {
            "introduction": "Understanding the components of a molecular energy function is the first step in mastering ab initio prediction. This exercise focuses on the torsional potential of the peptide bond, represented by the dihedral angle $\\omega$, a critical degree of freedom whose planarity dictates backbone structure. By calculating the energy difference between *cis* and *trans* states using a common Fourier series model, you will gain hands-on experience with how these potentials are constructed and see how they can explain important biochemical phenomena, such as the unique behavior of proline residues. ",
            "id": "3834586",
            "problem": "In ab initio protein structure prediction within computational chemical biology, conformational energetics are derived from first principles grounded in the Born–Oppenheimer approximation and the periodicity of torsional degrees of freedom in covalent frameworks. The peptide bond dihedral angle, denoted by $\\omega$, is constrained near planarity due to partial double-bond character resulting from resonance, leading to favored trans and disfavored cis configurations. Consider a peptide backbone torsional potential modeled as a truncated Fourier series,\n$$\nV(\\omega) \\;=\\; \\sum_{n=1}^{3} k_n \\left[\\, 1 + \\cos(n\\,\\omega - \\delta_n) \\,\\right],\n$$\nwhere $\\omega$ is measured in radians, $k_n$ are energy coefficients expressed in kilocalories per mole, and $\\delta_n$ are phase offsets. Use the following physically plausible parameters consistent with a non-proline peptide:\n- $k_1 = 1.6$ (kilocalories per mole), $\\delta_1 = 0$,\n- $k_2 = 1.2$ (kilocalories per mole), $\\delta_2 = 0$,\n- $k_3 = 0.25$ (kilocalories per mole), $\\delta_3 = \\pi$.\n\nDefine the cis state by $\\omega_{\\mathrm{cis}} = 0$ and the trans state by $\\omega_{\\mathrm{trans}} = \\pi$. Starting from the physical meaning of $V(\\omega)$ as a torsional energy penalty due to electronic and steric interactions and the periodicity implied by rotational symmetry, compute the energy difference\n$$\n\\Delta E \\;=\\; V(\\omega_{\\mathrm{cis}})\\;-\\;V(\\omega_{\\mathrm{trans}}).\n$$\nExpress the final energy difference in kilocalories per mole and round your answer to four significant figures. Finally, rationalize—without introducing any new numerical parameters—why the special case of proline typically exhibits a smaller $\\Delta E$ between cis and trans than other amino acids, using the same Fourier-based representation to explain the effect of ring constraints on the odd-$n$ harmonics.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It presents a standard model for torsional potential in computational chemistry and asks for a direct calculation and a conceptual explanation based on that model. All necessary parameters are provided, and the questions are unambiguous.\n\nThe torsional potential energy $V(\\omega)$ of a peptide bond is given by the truncated Fourier series:\n$$\nV(\\omega) \\;=\\; \\sum_{n=1}^{3} k_n \\left[\\, 1 + \\cos(n\\,\\omega - \\delta_n) \\,\\right]\n$$\nThe parameters for a non-proline peptide are provided as:\n- $n=1$: $k_1 = 1.6 \\, \\text{kcal/mol}$, $\\delta_1 = 0$\n- $n=2$: $k_2 = 1.2 \\, \\text{kcal/mol}$, $\\delta_2 = 0$\n- $n=3$: $k_3 = 0.25 \\, \\text{kcal/mol}$, $\\delta_3 = \\pi$\n\nFirst, we write out the explicit form of the potential energy function by substituting these parameters.\n$$\nV(\\omega) = k_1 [1 + \\cos(1 \\cdot \\omega - \\delta_1)] + k_2 [1 + \\cos(2 \\cdot \\omega - \\delta_2)] + k_3 [1 + \\cos(3 \\cdot \\omega - \\delta_3)]\n$$\n$$\nV(\\omega) = 1.6 [1 + \\cos(\\omega - 0)] + 1.2 [1 + \\cos(2\\omega - 0)] + 0.25 [1 + \\cos(3\\omega - \\pi)]\n$$\nUsing the trigonometric identity $\\cos(x - \\pi) = -\\cos(x)$, the third term becomes $0.25[1 - \\cos(3\\omega)]$. The full expression is:\n$$\nV(\\omega) = 1.6 [1 + \\cos(\\omega)] + 1.2 [1 + \\cos(2\\omega)] + 0.25 [1 - \\cos(3\\omega)]\n$$\nThe problem requires the computation of the energy difference $\\Delta E = V(\\omega_{\\mathrm{cis}}) - V(\\omega_{\\mathrm{trans}})$, where the `cis` state is at $\\omega_{\\mathrm{cis}} = 0$ radians and the `trans` state is at $\\omega_{\\mathrm{trans}} = \\pi$ radians.\n\nWe evaluate the potential at $\\omega_{\\mathrm{cis}} = 0$:\n$$\nV(\\omega_{\\mathrm{cis}}) = V(0) = 1.6 [1 + \\cos(0)] + 1.2 [1 + \\cos(0)] + 0.25 [1 - \\cos(0)]\n$$\nSince $\\cos(0) = 1$:\n$$\nV(0) = 1.6 [1 + 1] + 1.2 [1 + 1] + 0.25 [1 - 1]\n$$\n$$\nV(0) = 1.6(2) + 1.2(2) + 0.25(0) = 3.2 + 2.4 + 0 = 5.6 \\, \\text{kcal/mol}\n$$\nNext, we evaluate the potential at $\\omega_{\\mathrm{trans}} = \\pi$:\n$$\nV(\\omega_{\\mathrm{trans}}) = V(\\pi) = 1.6 [1 + \\cos(\\pi)] + 1.2 [1 + \\cos(2\\pi)] + 0.25 [1 - \\cos(3\\pi)]\n$$\nUsing the values $\\cos(\\pi) = -1$, $\\cos(2\\pi) = 1$, and $\\cos(3\\pi) = -1$:\n$$\nV(\\pi) = 1.6 [1 + (-1)] + 1.2 [1 + 1] + 0.25 [1 - (-1)]\n$$\n$$\nV(\\pi) = 1.6(0) + 1.2(2) + 0.25(2) = 0 + 2.4 + 0.5 = 2.9 \\, \\text{kcal/mol}\n$$\nThe energy difference $\\Delta E$ is then:\n$$\n\\Delta E = V(0) - V(\\pi) = 5.6 - 2.9 = 2.7 \\, \\text{kcal/mol}\n$$\nThe problem requires the answer to be rounded to four significant figures.\n$$\n\\Delta E = 2.700 \\, \\text{kcal/mol}\n$$\n\nFor the second part, we must rationalize why proline exhibits a smaller $\\Delta E$. To do this rigorously using the Fourier representation, we first derive a general expression for $\\Delta E$.\n$$\n\\Delta E = V(0) - V(\\pi) = \\sum_{n=1}^{3} k_n [1 + \\cos(0 - \\delta_n)] - \\sum_{n=1}^{3} k_n [1 + \\cos(n\\pi - \\delta_n)]\n$$\n$$\n\\Delta E = \\sum_{n=1}^{3} k_n \\left\\{ [1 + \\cos(-\\delta_n)] - [1 + \\cos(n\\pi - \\delta_n)] \\right\\}\n$$\nUsing $\\cos(-x) = \\cos(x)$ and the angle subtraction identity, which for integer $n$ gives $\\cos(n\\pi - \\delta_n) = (-1)^n\\cos(\\delta_n)$:\n$$\n\\Delta E = \\sum_{n=1}^{3} k_n [\\cos(\\delta_n) - (-1)^n\\cos(\\delta_n)] = \\sum_{n=1}^{3} k_n \\cos(\\delta_n) [1 - (-1)^n]\n$$\nThe term $[1 - (-1)^n]$ is $0$ for even $n$ and $2$ for odd $n$. This proves that the energy difference between the perfect `cis` and `trans` states is determined exclusively by the odd-$n$ harmonics of the potential. For $n=1, 2, 3$:\n$$\n\\Delta E = 2k_1\\cos(\\delta_1) + 0 \\cdot k_2\\cos(\\delta_2) + 2k_3\\cos(\\delta_3) = 2k_1\\cos(\\delta_1) + 2k_3\\cos(\\delta_3)\n$$\nThese odd harmonics, particularly the $n=1$ term, represent the energetic asymmetry between the `cis` and `trans` states. Physically, this asymmetry arises primarily from steric repulsion between the C$_\\alpha$ carbons and their substituents on adjacent residues. For a non-proline peptide, the `trans` arrangement ($\\omega = \\pi$) minimizes this repulsion, while the `cis` arrangement ($\\omega = 0$) results in a severe steric clash, leading to a large, positive $\\Delta E$. The large value of $k_1$ in the given parameters reflects this strong preference.\n\nIn proline, the side chain is cyclized and bonded to the backbone nitrogen atom, forming a rigid pyrrolidine ring. This unique structure alters the steric landscape:\n1. The bulk of the proline ring itself introduces steric clashes. In the `trans` conformation of an X-Pro peptide bond (where X is any amino acid), there is a clash between the C$_\\alpha$ of residue X and the C$_\\delta$ of the proline ring.\n2. In the `cis` conformation, the clash is between the C$_\\alpha$ of residue X and the C$_\\alpha$ of proline.\nCritically, the steric penalties in `cis` and `trans` prolyl-peptides are of more comparable magnitude than in non-proline peptides. The `trans` state is destabilized (its energy is raised) relative to a typical peptide bond, while the `cis` state is relatively less unfavorable. This reduces the overall energy difference between the two states.\n\nConnecting this physical reasoning back to the Fourier model, a reduced energetic asymmetry between the `cis` and `trans` states implies that the amplitudes of the odd harmonics, which mathematically encode this asymmetry, must be smaller. The dominant odd term is the $n=1$ harmonic, with amplitude governed by $k_1$. Therefore, for a proline residue, the parameter $k_1$ is expected to be significantly smaller than for a non-proline residue. According to the derived expression $\\Delta E = 2k_1\\cos(\\delta_1) + 2k_3\\cos(\\delta_3)$, a smaller $k_1$ directly leads to a smaller value for $\\Delta E$, which is consistent with the experimental observation that the `cis-trans` energy gap is smaller for proline.",
            "answer": "$$\\boxed{2.700}$$"
        },
        {
            "introduction": "Lattice models provide an invaluable sandbox for understanding the complex interplay of forces that guide protein folding. This practice moves from a single energy term to a complete, albeit coarse-grained, protein model incorporating both hydrophobic and electrostatic interactions. You will develop a program to exhaustively search for an optimal structure for a short polypeptide, providing direct, hands-on experience with the computational challenges of conformational sampling and energy minimization. ",
            "id": "2369976",
            "problem": "You are asked to formalize and implement an extension of the two-dimensional (2D) Hydrophobic-Polar (HP) lattice protein model to a four-letter alphabet model that includes charged residues, denoted Hydrophobic, Polar, Negative, Cationic (HPNC). The goal is to search for a short polypeptide sequence and a self-avoiding 2D conformation on a square lattice that together achieve a minimal additive contact energy while containing at least one salt bridge. A salt bridge is defined here as a non-consecutive nearest-neighbor lattice contact between a Negative and a Cationic residue.\n\nStart from first principles that are appropriate for lattice protein models used in ab initio protein structure prediction. The fundamental base must be the following facts, without using any shortcut formulas:\n- Proteins can be abstracted as self-avoiding walks on a lattice, where each residue occupies one lattice site and consecutive residues are adjacent on the lattice. Only non-consecutive nearest-neighbor residue pairs are considered as contact interactions.\n- The hydrophobic effect motivates a favorable attraction between hydrophobic residues when they are in contact, modeled by a negative contact energy contribution for hydrophobic-hydrophobic contacts.\n- Electrostatic interactions between charged residues motivate favorable energy for opposite-charge contacts and unfavorable energy for like-charge contacts. In a coarse-grained lattice model at lattice spacing as the unit length, one can approximate this with a constant negative contribution for unlike charges and a constant positive contribution for like charges, applied only to nearest-neighbor non-consecutive contacts.\n- Additivity assumption: the total energy is the sum over pairwise contact energies across all non-consecutive contacting residue pairs.\n\nYour program must implement the following precise model and search protocol.\n- Residue types are an alphabet of size $4$: Hydrophobic ($\\mathrm{H}$), Polar ($\\mathrm{P}$), Negative ($\\mathrm{N}$), and Cationic ($\\mathrm{C}$). A sequence is a string of length $L$ over this alphabet.\n- A conformation is a self-avoiding walk of length $L$ on the 2D square lattice with coordinates in $\\mathbb{Z}^2$, specified as a list of lattice coordinates $\\left[(x_0,y_0),(x_1,y_1),\\dots,(x_{L-1},y_{L-1})\\right]$ with unit steps and no repeated coordinates. To avoid redundant symmetries, fix $(x_0,y_0)=(0,0)$ and $(x_1,y_1)=(1,0)$.\n- Define the contact set $\\mathcal{C}$ for a conformation as all unordered index pairs $(i,j)$ with $0 \\le i < j \\le L-1$, such that $|i-j| \\ge 2$ and the Manhattan distance between $(x_i,y_i)$ and $(x_j,y_j)$ equals $1$.\n- Define the pairwise contact energy function $\\varepsilon(a,b)$ for residue types $a$ and $b$ as follows, using parameters $e_{\\mathrm{HH}}$, $e_{\\mathrm{NC}}$, and $e_{\\mathrm{like}}$ supplied per test case. Let $\\mathrm{H}=0$, $\\mathrm{P}=1$, $\\mathrm{N}=2$, $\\mathrm{C}=3$ for encoding. Then:\n  - $\\varepsilon(\\mathrm{H},\\mathrm{H})=\\varepsilon(0,0)=e_{\\mathrm{HH}}$.\n  - $\\varepsilon(\\mathrm{N},\\mathrm{C})=\\varepsilon(2,3)=\\varepsilon(\\mathrm{C},\\mathrm{N})=\\varepsilon(3,2)=e_{\\mathrm{NC}}$.\n  - $\\varepsilon(\\mathrm{N},\\mathrm{N})=\\varepsilon(2,2)=e_{\\mathrm{like}}$ and $\\varepsilon(\\mathrm{C},\\mathrm{C})=\\varepsilon(3,3)=e_{\\mathrm{like}}$.\n  - All other residue pairs have $\\varepsilon(a,b)=0$.\n- For a sequence $\\{t_i\\}_{i=0}^{L-1}$ and a conformation with contact set $\\mathcal{C}$, the total energy is\n  $$E=\\sum_{(i,j)\\in\\mathcal{C}}\\varepsilon\\left(t_i,t_j\\right).$$\n- The salt bridge count is\n  $$S=\\left|\\left\\{(i,j)\\in\\mathcal{C}\\;:\\;\\{t_i,t_j\\}=\\{\\mathrm{N},\\mathrm{C}\\}\\right\\}\\right|.$$\n- A solution must have at least one salt bridge, i.e., $S \\ge 1$.\n\nSearch objective and tie-breaking:\n- Among all sequences of length $L$ over the HPNC alphabet and all valid conformations as defined above, find the pair that minimizes $E$ subject to $S \\ge 1$.\n- If multiple pairs achieve the same minimal $E$, choose the one with the largest $S$.\n- If there is still a tie, choose the lexicographically smallest sequence under the encoding $\\mathrm{H}=0$, $\\mathrm{P}=1$, $\\mathrm{N}=2$, $\\mathrm{C}=3$, comparing the integer lists from left to right.\n- If there is still a tie, choose the conformation whose flattened coordinate list $\\left[x_0,y_0,x_1,y_1,\\dots,x_{L-1},y_{L-1}\\right]$ is lexicographically smallest.\n\nSequence encoding and output representation:\n- Encode a sequence as a list of $L$ integers in $\\{0,1,2,3\\}$ corresponding to $\\mathrm{H},\\mathrm{P},\\mathrm{N},\\mathrm{C}$ respectively.\n- Encode a conformation as a list of $L$ coordinate pairs, each coordinate pair being a list of two integers $\\left[x_i,y_i\\right]$.\n\nYour program must perform an exhaustive search that is guaranteed to find the exact optimum for the small test cases below by:\n- Enumerating all self-avoiding walks of length $L$ on the square lattice with the above anchoring.\n- Enumerating all sequences of length $L$ over the alphabet of size $4$.\n- Computing $E$ and $S$ exactly for each pair and applying the objective and tie-breaking rules.\n\nTest suite:\n- Case A (happy path): $L=6$, $e_{\\mathrm{HH}}=-1.0$, $e_{\\mathrm{NC}}=-2.0$, $e_{\\mathrm{like}}=+0.5$.\n- Case B (salt-bridge-dominant): $L=7$, $e_{\\mathrm{HH}}=0.0$, $e_{\\mathrm{NC}}=-2.5$, $e_{\\mathrm{like}}=+0.5$.\n- Case C (strong like-charge repulsion): $L=6$, $e_{\\mathrm{HH}}=-0.5$, $e_{\\mathrm{NC}}=-1.0$, $e_{\\mathrm{like}}=+1.0$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result corresponds to one test case, in the same order as listed above.\n- Each result must be a list of the form $[E_{\\min},S_{\\mathrm{best}},\\mathrm{seq},\\mathrm{coords}]$ where $E_{\\min}$ is the minimal energy rounded to three decimal places (as a real number), $S_{\\mathrm{best}}$ is the salt bridge count of the selected solution (as an integer), $\\mathrm{seq}$ is the chosen sequence encoded as a list of integers in $\\{0,1,2,3\\}$, and $\\mathrm{coords}$ is the chosen conformation encoded as a list of coordinate pairs as specified.\n- The final output must therefore be a single line containing something like $[\\mathrm{r}_\\mathrm{A},\\mathrm{r}_\\mathrm{B},\\mathrm{r}_\\mathrm{C}]$, where each $\\mathrm{r}_\\mathrm{X}$ is a list in the above format for the corresponding case. Do not print any other text.",
            "solution": "The problem presented is a constrained optimization task within the framework of computational protein structure prediction. It requires the formalization and implementation of a four-letter Hydrophobic-Polar-Negative-Cationic (HPNC) lattice model. The objective is to find a polypeptide sequence and a corresponding self-avoiding conformation on a two-dimensional (2D) square lattice that, in concert, achieve the minimum possible additive contact energy, under the constraint that the structure must contain at least one salt bridge. A salt bridge is defined as a non-covalent contact between a Negative ($\\mathrm{N}$) and a Cationic ($\\mathrm{C}$) residue.\n\nThe problem is well-posed, scientifically grounded in the principles of coarse-grained protein models, and provides all necessary definitions and parameters for a unique solution to be determined. The model is an extension of the classic Hydrophobic-Polar (HP) model, incorporating electrostatic effects, which is a standard approach in the field. Given the small sequence lengths specified ($L=6$ and $L=7$), an exhaustive search of the complete conformational and sequence space is computationally feasible and is the only method guaranteed to find the true global optimum as defined by the hierarchical objective function.\n\nThe solution is therefore designed as an exhaustive search algorithm that systematically explores all valid sequence-conformation pairs, evaluates them, and identifies the optimal pair according to the specified criteria. The algorithm proceeds as follows:\n\nFirst, we must generate the entire space of possible molecular entities. This space is the Cartesian product of the set of all unique, valid conformations and the set of all possible sequences of length $L$.\n\nA conformation is a self-avoiding walk of length $L$ on a 2D square lattice. To generate all such conformations, we employ a recursive backtracking (depth-first search) algorithm. The walk is anchored with the first two residues at coordinates $(x_0,y_0)=(0,0)$ and $(x_1,y_1)=(1,0)$ to eliminate trivial rotational and translational symmetries. The recursion extends the walk one residue at a time, exploring all four cardinal directions, ensuring that the new lattice site is not already occupied. When a walk of length $L$ is completed, it is added to our list of valid conformations.\n\nA sequence is a string of length $L$ over the alphabet $\\{\\mathrm{H}, \\mathrm{P}, \\mathrm{N}, \\mathrm{C}\\}$, which we encode as integers $\\{0, 1, 2, 3\\}$. The total number of sequences is $4^L$. These are generated systematically, ensuring every possible sequence is considered. This can be achieved by iterating through all $L$-digit numbers in base $4$.\n\nFor each pair of a conformation and a sequence, we must calculate its total energy $E$ and its salt bridge count $S$. This evaluation is performed in two steps.\n1. Given a conformation, we first determine its set of contacts, $\\mathcal{C}$. A contact is an unordered pair of residue indices $(i,j)$ such that the residues are non-adjacent in the sequence ($|i-j| \\ge 2$) but occupy adjacent sites on the lattice. The adjacency is determined by checking if the Manhattan distance between their coordinates is equal to $1$.\n2. With the contact set $\\mathcal{C}$ and the sequence $\\{t_i\\}_{i=0}^{L-1}$, we calculate the total energy $E$ and salt bridge count $S$. The total energy is the sum of pairwise interaction energies, $E = \\sum_{(i,j)\\in\\mathcal{C}}\\varepsilon(t_i, t_j)$. The energy function $\\varepsilon(a,b)$ is defined by the problem parameters $e_{\\mathrm{HH}}$, $e_{\\mathrm{NC}}$, and $e_{\\mathrm{like}}$, and is non-zero only for $\\mathrm{H}-\\mathrm{H}$, $\\mathrm{N}-\\mathrm{C}$, $\\mathrm{N}-\\mathrm{N}$, and $\\mathrm{C}-\\mathrm{C}$ contacts. The salt bridge count $S$ is the number of contacts in $\\mathcal{C}$ where the residue types are $\\{\\mathrm{N}, \\mathrm{C}\\}$.\n\nFinally, we identify the optimal solution. The search must adhere to a strict, four-level tie-breaking rule. We seek to:\n1. Minimize the total energy $E$.\n2. For a given minimal $E$, maximize the salt bridge count $S$.\n3. For a given $E$ and $S$, choose the lexicographically smallest sequence (using the integer encoding).\n4. As a final tie-breaker, choose the conformation whose flattened coordinate list is lexicographically smallest.\n\nThis hierarchical optimization is implemented by maintaining a single \"best-so-far\" solution throughout the exhaustive search. Each new valid candidate solution (i.e., where $S \\ge 1$) is compared to the current best. A candidate is deemed \"better\" if its corresponding objective tuple is lexicographically smaller than that of the current best. The objective tuple for a candidate consisting of a sequence $\\mathbf{t}$ and conformation $\\mathbf{x}$ is constructed as $(E, -S, \\mathbf{t}, \\mathbf{x}_{\\text{flat}})$, where $\\mathbf{t}$ is the tuple of integer-encoded residue types and $\\mathbf{x}_{\\text{flat}}$ is the flattened tuple of coordinates. The negation of $S$ correctly transforms the maximization of $S$ into a minimization problem, fitting the lexicographical comparison framework. By iterating through all sequence-conformation pairs and applying this comparison, the algorithm is guaranteed to converge on the unique optimal solution defined by the problem statement.",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef generate_conformations(L):\n    \"\"\"\n    Generates all self-avoiding walks of length L on a 2D square lattice,\n    anchored at (0,0) and (1,0).\n    \"\"\"\n    if L < 2:\n        return []\n\n    # Anchored start as specified\n    path = [(0, 0), (1, 0)]\n    if L == 2:\n        return [tuple(path)]\n    \n    visited = set(path)\n    conformations = []\n    \n    def extend_walk(current_path, visited_sites):\n        if len(current_path) == L:\n            conformations.append(tuple(current_path))\n            return\n            \n        last_x, last_y = current_path[-1]\n        # Possible moves: North, South, East, West\n        moves = [(last_x, last_y + 1), (last_x, last_y - 1), (last_x + 1, last_y), (last_x - 1, last_y)]\n        \n        for next_pos in moves:\n            if next_pos not in visited_sites:\n                current_path.append(next_pos)\n                visited_sites.add(next_pos)\n                extend_walk(current_path, visited_sites)\n                visited_sites.remove(next_pos) # Backtrack\n                current_path.pop()\n\n    extend_walk(path, visited)\n    return conformations\n\ndef find_contacts(conf, L):\n    \"\"\"\n    Finds all non-consecutive nearest-neighbor contacts for a given conformation.\n    \"\"\"\n    contacts = []\n    for i in range(L - 1):\n        for j in range(i + 2, L):\n            xi, yi = conf[i]\n            xj, yj = conf[j]\n            if abs(xi - xj) + abs(yi - yj) == 1:\n                contacts.append((i, j))\n    return contacts\n\ndef make_energy_matrix(e_HH, e_NC, e_like):\n    \"\"\"\n    Creates the 4x4 pairwise energy matrix.\n    Encoding: H=0, P=1, N=2, C=3\n    \"\"\"\n    energy_matrix = np.zeros((4, 4), dtype=float)\n    energy_matrix[0, 0] = e_HH\n    energy_matrix[2, 3] = e_NC\n    energy_matrix[3, 2] = e_NC\n    energy_matrix[2, 2] = e_like\n    energy_matrix[3, 3] = e_like\n    return energy_matrix\n\ndef evaluate(seq, contacts, energy_matrix):\n    \"\"\"\n    Calculates total energy E and salt bridge count S for a sequence and its contacts.\n    \"\"\"\n    E = 0.0\n    S = 0\n    N_type, C_type = 2, 3\n    \n    for i, j in contacts:\n        type1, type2 = seq[i], seq[j]\n        E += energy_matrix[type1, type2]\n        if (type1 == N_type and type2 == C_type) or (type1 == C_type and type2 == N_type):\n            S += 1\n    return E, S\n\ndef find_optimal_structure(L, e_HH, e_NC, e_like):\n    \"\"\"\n    Performs the exhaustive search for the optimal sequence and conformation.\n    \"\"\"\n    energy_matrix = make_energy_matrix(e_HH, e_NC, e_like)\n    \n    all_conformations = generate_conformations(L)\n    \n    best_result_tuple = (float('inf'),)\n    best_solution_details = None\n\n    # Pre-calculate contacts for each conformation\n    conf_contacts = {conf: find_contacts(conf, L) for conf in all_conformations}\n    \n    # Iterate through all sequences and conformations to find the optimum\n    for seq in itertools.product(range(4), repeat=L):\n        seq_tuple = tuple(seq)\n        for conf in all_conformations:\n            contacts = conf_contacts[conf]\n            E, S = evaluate(seq_tuple, contacts, energy_matrix)\n\n            if S < 1:\n                continue\n\n            conf_flat_tuple = tuple(coord for pair in conf for coord in pair)\n            current_result_tuple = (E, -S, seq_tuple, conf_flat_tuple)\n\n            if best_solution_details is None or current_result_tuple < best_result_tuple:\n                best_result_tuple = current_result_tuple\n                best_solution_details = (E, S, seq_tuple, conf)\n    \n    E, S, seq, conf = best_solution_details\n    return E, S, list(seq), [list(c) for c in conf]\n\ndef format_result_list(res_list):\n    \"\"\"\n    Formats the final result list for one test case into the required string format.\n    \"\"\"\n    E, S, seq, coords = res_list\n    E_str = f\"{E:.3f}\"\n    seq_str = str(seq).replace(\" \", \"\")\n    coords_str = str(coords).replace(\" \", \"\")\n    return f\"[{E_str},{S},{seq_str},{coords_str}]\"\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (L, e_HH, e_NC, e_like)\n        (6, -1.0, -2.0, 0.5),  # Case A\n        (7, 0.0, -2.5, 0.5),  # Case B\n        (6, -0.5, -1.0, 1.0),  # Case C\n    ]\n    \n    results = []\n    for L, e_HH, e_NC, e_like in test_cases:\n        E_min, S_best, seq, coords = find_optimal_structure(L, e_HH, e_NC, e_like)\n        results.append([E_min, S_best, seq, coords])\n    \n    final_output_str_parts = [format_result_list(res) for res in results]\n    final_output = f\"[{','.join(final_output_str_parts)}]\"\n    print(final_output)\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "The sheer size of protein conformational space makes exhaustive searches impossible for all but the smallest peptides, necessitating the use of metaheuristic algorithms for tackling realistic prediction problems. This advanced practice introduces one such powerful, nature-inspired search method—Ant Colony Optimization—to find low-energy states for an off-lattice protein model. You will gain practical skills in both advanced conformational sampling and the geometric construction of molecular chains from internal coordinates. ",
            "id": "2369960",
            "problem": "You are given a coarse-grained internal-coordinate model of a polypeptide backbone in three dimensions. Consider a chain of $N$ alpha carbon atoms connected by fixed bond length $b$ and fixed bond angle $\\theta$. The internal degrees of freedom are the backbone dihedral angles $\\{\\phi_i\\}$ for $i \\in \\{3,4,\\dots,N-1\\}$, one dihedral per newly added atom beyond the third. The chain is constructed as follows. Place the first three atoms at\n$p_0 = (0,0,0)$, $p_1 = (b,0,0)$, $p_2 = (b + b\\cos\\theta, b\\sin\\theta, 0)$. For $i \\ge 3$, given $p_{i-3}, p_{i-2}, p_{i-1}$ and a dihedral angle $\\phi_i \\in [-\\pi,\\pi)$, define unit vectors $u = \\frac{p_{i-1}-p_{i-2}}{\\|p_{i-1}-p_{i-2}\\|}$ and $v = \\frac{p_{i-2}-p_{i-3}}{\\|p_{i-2}-p_{i-3}\\|}$, the normal $n = \\frac{v \\times u}{\\|v \\times u\\|}$, and $m = u \\times n$. Then place\n$$\np_i = p_{i-1} + b\\left( \\cos\\theta\\,(-u) + \\sin\\theta\\left(\\cos\\phi_i\\, m + \\sin\\phi_i\\, n\\right)\\right),\n$$\nwhere $p_i$ is the position of atom $i$.\n\nDefine the total energy in reduced units for a conformation specified by dihedrals $\\Phi = (\\phi_3,\\dots,\\phi_{N-1})$ as\n$$\nE(\\Phi) = E_{\\text{tors}}(\\Phi) + E_{\\text{nb}}(\\Phi),\n$$\nwhere the torsional term is\n$$\nE_{\\text{tors}}(\\Phi) = k_t \\sum_{i=3}^{N-1} \\left(1 + \\cos(3\\phi_i)\\right),\n$$\nand the nonbonded term is a Lennard–Jones potential between non-adjacent atoms\n$$\nE_{\\text{nb}}(\\Phi) = \\sum_{\\substack{0 \\le i < j \\le N-1 \\\\ j - i > 2}} 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right],\n$$\nwith $r_{ij} = \\|p_i - p_j\\|$. Use lengths in ångströms (Å), angles in radians, and energies in the same reduced units as $\\varepsilon$.\n\nConsider a discrete memory-based probabilistic constructive process over dihedral angles. For each dihedral index $k \\in \\{3,4,\\dots,N-1\\}$, discretize the domain $[-\\pi,\\pi)$ into $B$ equal-width bins with centers $\\{\\varphi_{k,b}\\}_{b=1}^B$. Maintain a nonnegative memory matrix (the “pheromone” memory) $T \\in \\mathbb{R}_{\\ge 0}^{(N-3)\\times B}$ with entries $T_{k,b}$, initialized uniformly to $T_{k,b} = \\tau_0$. Define a heuristic weight for each bin by\n$$\n\\eta_{k,b} = \\exp\\left(-\\frac{k_t\\left(1 + \\cos(3\\varphi_{k,b})\\right)}{T_h}\\right),\n$$\nwith temperature $T_h > 0$. For parameters $\\alpha > 0$ and $\\beta \\ge 0$, define the probability of choosing bin $b$ at dihedral index $k$ as\n$$\n\\mathbb{P}(\\text{choose } b \\mid k) = \\frac{T_{k,b}^{\\alpha}\\,\\eta_{k,b}^{\\beta}}{\\sum_{b'=1}^{B} T_{k,b'}^{\\alpha}\\,\\eta_{k,b'}^{\\beta}}.\n$$\nAn iteration consists of generating $M$ complete angle sequences $\\Phi$ by independent sampling of one bin per dihedral according to the product distribution across indices $k$, evaluating $E(\\Phi)$ for each, selecting the single lowest-energy sample in the iteration with energy $E^\\star$, then updating the memory with evaporation rate $\\rho \\in (0,1)$ and a rank-$1$ deposition at the selected bins $\\{b_k^\\star\\}$:\n$$\nT_{k,b} \\leftarrow (1-\\rho) T_{k,b} \\quad \\text{for all } k,b,\n$$\n$$\nT_{k,b_k^\\star} \\leftarrow T_{k,b_k^\\star} + Q\\exp\\left(-\\frac{E^\\star}{T_d}\\right) \\quad \\text{for all } k,\n$$\nfollowed by clamping $T_{k,b} \\leftarrow \\min\\{\\tau_{\\max}, \\max\\{\\tau_{\\min}, T_{k,b}\\}\\}$ with $\\tau_{\\min} > 0$ and $\\tau_{\\max} > \\tau_{\\min}$. Repeat for $I$ iterations, and return the lowest energy encountered across all samples and iterations.\n\nUse the following fixed physical and energetic constants for all runs:\n- Bond length $b = 3.8$ Å.\n- Bond angle $\\theta = 111.5^\\circ$ (use radians in computation; $\\theta \\approx 1.946$).\n- Lennard–Jones parameters $\\varepsilon = 0.1$ and $\\sigma = 4.0$ (in Å).\n- Torsional stiffness $k_t = 0.1$.\n- Heuristic temperature $T_h = 1.0$.\n- Deposition strength $Q = 1.0$ and deposition temperature $T_d = 1.0$.\n- Pheromone initialization $\\tau_0 = 1.0$, floor $\\tau_{\\min} = 10^{-6}$, and cap $\\tau_{\\max} = 100.0$.\n\nYour task is to implement the process above and execute it on the following test suite. For each test case, use an independent pseudorandom generator initialized with the given seed, and report the best (lowest) energy $E$ found. Express each answer as a floating-point number rounded to three decimal places.\n\nTest suite (angles in radians, lengths in Å, energies in the units of $\\varepsilon$):\n- Case A (general): $N = 8$, $M = 25$, $I = 40$, $B = 36$, $\\alpha = 1.0$, $\\beta = 2.0$, $\\rho = 0.1$, random seed $s = 1234$.\n- Case B (boundary length): $N = 4$, $M = 16$, $I = 25$, $B = 24$, $\\alpha = 1.0$, $\\beta = 1.0$, $\\rho = 0.3$, random seed $s = 202$.\n- Case C (different balance): $N = 10$, $M = 20$, $I = 30$, $B = 24$, $\\alpha = 1.5$, $\\beta = 1.0$, $\\rho = 0.2$, random seed $s = 999$.\n\nFinal output format: Your program should produce a single line of output containing the results for Cases A, B, and C as a comma-separated list enclosed in square brackets, for example, \"[x_A,x_B,x_C]\". Each $x$ must be the rounded floating-point value as specified above, with no additional text.",
            "solution": "**1. Chain Geometry Construction**\n\nThe three-dimensional coordinates of the $N$ atoms, denoted $\\{p_i\\}_{i=0}^{N-1}$, are generated sequentially. The first three atoms, $p_0$, $p_1$, and $p_2$, establish an initial reference frame in the $xy$-plane:\n$$p_0 = (0,0,0)$$\n$$p_1 = (b,0,0)$$\n$$p_2 = (b + b\\cos\\theta, b\\sin\\theta, 0)$$\nHere, $b$ is the fixed bond length and $\\theta$ is the fixed bond angle. For each subsequent atom $p_i$ ($i \\ge 3$), its position is determined by the positions of the preceding three atoms ($p_{i-3}, p_{i-2}, p_{i-1}$) and a single internal degree of freedom, the dihedral angle $\\phi_i$.\n\nThe construction of $p_i$ is based on defining a local coordinate system. Let $u$ be the unit vector along the bond $p_{i-2} \\to p_{i-1}$, and $v$ be the unit vector along the bond $p_{i-3} \\to p_{i-2}$.\n$$u = \\frac{p_{i-1}-p_{i-2}}{\\|p_{i-1}-p_{i-2}\\|}, \\quad v = \\frac{p_{i-2}-p_{i-3}}{\\|p_{i-2}-p_{i-3}\\|}$$\nA normal vector $n$ to the plane containing these two bonds is given by their cross product, $n = \\text{normalize}(v \\times u)$. A third vector, $m = u \\times n$, completes a right-handed orthonormal basis $\\{u, m, n\\}$. The position of the new atom $p_i$ is then placed relative to $p_{i-1}$ such that the new bond vector $p_i - p_{i-1}$ has length $b$, makes an angle of $\\pi-\\theta$ with vector $p_{i-1}-p_{i-2}$ (thus maintaining the bond angle $\\theta$), and its projection onto the plane perpendicular to $u$ is rotated by the dihedral angle $\\phi_i$. This is captured by the given formula:\n$$\np_i = p_{i-1} + b\\left( \\cos\\theta\\,(-u) + \\sin\\theta\\left(\\cos\\phi_i\\, m + \\sin\\phi_i\\, n\\right)\\right)\n$$\nThis geometric construction is a standard method in molecular modeling, often referred to as a Natural Extension Reference Frame (NeRF) or similar internal coordinate building algorithm.\n\n**2. Energy Function**\n\nThe potential energy of a given conformation, specified by the set of dihedrals $\\Phi$, is the sum of two terms: a torsional term and a non-bonded interaction term.\n$$E(\\Phi) = E_{\\text{tors}}(\\Phi) + E_{\\text{nb}}(\\Phi)$$\nThe torsional energy, $E_{\\text{tors}}$, accounts for the energetic barrier to rotation around the backbone bonds:\n$$E_{\\text{tors}}(\\Phi) = k_t \\sum_{i=3}^{N-1} \\left(1 + \\cos(3\\phi_i)\\right)$$\nThe term $k_t$ represents the stiffness of the torsional spring. The $3\\phi_i$ dependence models the three-fold rotational symmetry common in alkane-like chains.\n\nThe non-bonded energy, $E_{\\text{nb}}$, models the van der Waals interactions between atoms that are not close neighbors in the chain. It is calculated using the Lennard-Jones $12-6$ potential:\n$$E_{\\text{nb}}(\\Phi) = \\sum_{\\substack{0 \\le i < j \\le N-1 \\\\ j - i > 2}} 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right]$$\nHere, $r_{ij}$ is the Euclidean distance between atoms $p_i$ and $p_j$. The parameters $\\varepsilon$ and $\\sigma$ define the depth and position of the potential well, respectively. The condition $j-i > 2$ correctly excludes bonded neighbors ($1,2$ pairs like $i, i+1$) and bond-angle neighbors ($1,3$ pairs like $i, i+2$), whose interactions are implicitly handled by the fixed bond length and angle constraints.\n\n**3. Ant Colony Optimization (ACO) Algorithm**\n\nThe high-dimensional and non-convex nature of the energy landscape makes finding the global minimum a non-trivial task. The problem specifies a stochastic optimization algorithm based on the ACO metaheuristic.\n\nFirst, the continuous domain $[-\\pi, \\pi)$ for each dihedral angle is discretized into $B$ bins. The search for the optimal conformation is then transformed into a search for the best sequence of bins.\n\nThe algorithm proceeds for $I$ iterations. In each iteration, $M$ candidate solutions (ants) are constructed. Each ant builds a complete sequence of dihedral angles, $\\Phi$, by making a probabilistic choice for each dihedral $\\phi_k$ ($k=3, \\dots, N-1$). The probability of choosing bin $b$ for dihedral $k$ is a function of two components:\n-   **Pheromone trail ($\\tau$)**: A memory matrix $T$ stores the \"desirability\" of choosing each bin for each dihedral, based on past successful solutions. The entry $T_{k,b}$ corresponds to the pheromone level for bin $b$ of dihedral $k$.\n-   **Heuristic information ($\\eta$)**: This term provides *a priori* knowledge about the quality of a choice, independent of the search history. Here, it is based on the local torsional energy of a dihedral angle: $\\eta_{k,b} = \\exp\\left(-\\frac{E_{\\text{tors}}(\\varphi_{k,b})}{T_h}\\right)$. Lower energy choices have higher heuristic value.\n\nThe probability of choosing bin $b$ for the $k$-th dihedral (corresponding to matrix row $k-3$) is given by:\n$$\\mathbb{P}(\\text{choose } b \\mid k) = \\frac{T_{k-3,b}^{\\alpha}\\,\\eta_{k-3,b}^{\\beta}}{\\sum_{b'=1}^{B} T_{k-3,b'}^{\\alpha}\\,\\eta_{k-3,b'}^{\\beta}}$$\nThe parameters $\\alpha$ and $\\beta$ control the relative influence of the pheromone trail versus the heuristic information.\n\nAfter $M$ solutions are constructed and their energies evaluated, the single best solution of the iteration, with energy $E^\\star$, is used to update the pheromone matrix. The update has two phases:\n1.  **Evaporation**: All pheromone trails are uniformly decreased by a factor of $(1-\\rho)$, where $\\rho \\in (0,1)$ is the evaporation rate. This prevents premature convergence.\n$$T_{k,b} \\leftarrow (1-\\rho) T_{k,b}$$\n2.  **Deposition**: The trails corresponding to the choices made in the iteration's best solution $\\{b_k^\\star\\}$ are reinforced. The amount of deposited pheromone is inversely related to the energy $E^\\star$.\n$$T_{k-3,b_k^\\star} \\leftarrow T_{k-3,b_k^\\star} + Q\\exp\\left(-\\frac{E^\\star}{T_d}\\right)$$\nFinally, the pheromone values are clamped between $\\tau_{\\min}$ and $\\tau_{\\max}$ to ensure stability. This entire process guides the search towards promising regions of the conformational space over successive iterations. The lowest energy found across all ants and all iterations is reported as the final result.",
            "answer": "```python\nimport numpy as np\n\n# Fixed physical and energetic constants\nBOND_LENGTH = 3.8  # b in Å\nBOND_ANGLE_DEG = 111.5\nBOND_ANGLE_RAD = np.deg2rad(BOND_ANGLE_DEG)  # theta in radians\nEPSILON = 0.1      # ε\nSIGMA = 4.0        # σ in Å\nKT = 0.1           # k_t\nT_H = 1.0          # T_h (Heuristic temperature)\nQ = 1.0            # Deposition strength\nT_D = 1.0          # Deposition temperature\nTAU_0 = 1.0        # Pheromone initialization\nTAU_MIN = 1e-6     # Pheromone floor\nTAU_MAX = 100.0    # Pheromone cap\n\ndef build_chain(dihedrals, N, b, theta):\n    \"\"\"Constructs the atomic coordinates for a given chain length and dihedrals.\"\"\"\n    if N == 0:\n        return np.array([])\n    \n    positions = np.zeros((N, 3))\n    if N > 1:\n        positions[1] = np.array([b, 0.0, 0.0])\n    if N > 2:\n        positions[2] = np.array([\n            b + b * np.cos(theta),\n            b * np.sin(theta),\n            0.0\n        ])\n\n    for i in range(3, N):\n        p_im1, p_im2, p_im3 = positions[i-1], positions[i-2], positions[i-3]\n        \n        # Define local frame vectors\n        u_vec = p_im1 - p_im2\n        u = u_vec / np.linalg.norm(u_vec)\n        \n        v_vec = p_im2 - p_im3\n        v = v_vec / np.linalg.norm(v_vec)\n        \n        cross_vu = np.cross(v, u)\n        n = cross_vu / np.linalg.norm(cross_vu)\n        \n        m = np.cross(u, n)\n        \n        phi_i = dihedrals[i - 3]\n        cos_phi = np.cos(phi_i)\n        sin_phi = np.sin(phi_i)\n\n        # Construct new atom position using the provided formula\n        new_bond_vector = -np.cos(theta) * u + np.sin(theta) * (cos_phi * m + sin_phi * n)\n        positions[i] = p_im1 + b * new_bond_vector\n        \n    return positions\n\ndef calculate_energy(positions, dihedrals, N, kt, eps, sigma):\n    \"\"\"Calculates the total energy of a conformation.\"\"\"\n    \n    # 1. Torsional energy\n    if dihedrals:\n        cos3_phi = np.cos(3 * np.array(dihedrals))\n        e_tors = kt * np.sum(1 + cos3_phi)\n    else:\n        e_tors = 0.0\n\n    # 2. Non-bonded Lennard-Jones energy\n    e_nb = 0.0\n    for i in range(N):\n        for j in range(i + 3, N):  # Condition j - i > 2\n            dist_sq = np.sum((positions[i] - positions[j])**2)\n            dist = np.sqrt(dist_sq)\n            \n            if dist > 0:\n                sigma_over_r = sigma / dist\n                sigma_over_r6 = sigma_over_r**6\n                sigma_over_r12 = sigma_over_r6**2\n                e_nb += 4 * eps * (sigma_over_r12 - sigma_over_r6)\n    \n    return e_tors + e_nb\n\ndef run_simulation(N, M, I, B, alpha, beta, rho, seed):\n    \"\"\"Runs the full ACO simulation for one test case.\"\"\"\n    \n    rng = np.random.default_rng(seed)\n    num_dihedrals = N - 3\n\n    if num_dihedrals <= 0:\n        # Fixed geometry, only possible LJ energy. \n        # For N<=3, no pair satisfies j-i>2, so energy is 0.\n        return 0.0\n    \n    # Discretize dihedral space\n    bin_width = 2 * np.pi / B\n    dihedral_bins = np.linspace(-np.pi + bin_width / 2, np.pi - bin_width / 2, B)\n\n    # Initialize pheromone matrix T\n    pheromone = np.full((num_dihedrals, B), TAU_0)\n    \n    # Pre-calculate heuristic matrix eta\n    torsional_heuristic_term = KT * (1 + np.cos(3 * dihedral_bins))\n    heuristic = np.exp(-torsional_heuristic_term / T_H)\n    \n    best_energy_global = float('inf')\n\n    for iteration in range(I):\n        iteration_samples = []\n        \n        # M ants construct solutions\n        for _ in range(M):\n            chosen_dihedrals = []\n            chosen_bin_indices = []\n            \n            for k in range(num_dihedrals):\n                probs = (pheromone[k] ** alpha) * (heuristic ** beta)\n                if np.sum(probs) > 0:\n                    probs /= np.sum(probs)\n                else: # Fallback to uniform if all probabilities are zero\n                    probs = np.ones(B) / B\n\n                chosen_bin_idx = rng.choice(B, p=probs)\n                chosen_bin_indices.append(chosen_bin_idx)\n                chosen_dihedrals.append(dihedral_bins[chosen_bin_idx])\n\n            # Evaluate the constructed conformation\n            positions = build_chain(chosen_dihedrals, N, BOND_LENGTH, BOND_ANGLE_RAD)\n            energy = calculate_energy(positions, chosen_dihedrals, N, KT, EPSILON, SIGMA)\n            \n            iteration_samples.append({'dihedrals': chosen_dihedrals, 'bins': chosen_bin_indices, 'energy': energy})\n\n        # Find best ant of the iteration\n        best_sample = min(iteration_samples, key=lambda x: x['energy'])\n        e_star = best_sample['energy']\n        \n        # Update global best energy\n        if e_star < best_energy_global:\n            best_energy_global = e_star\n\n        # Update pheromone trails\n        # 1. Evaporation\n        pheromone *= (1 - rho)\n\n        # 2. Deposition\n        deposition_amount = Q * np.exp(-e_star / T_D)\n        best_bins = best_sample['bins']\n        for k in range(num_dihedrals):\n            pheromone[k, best_bins[k]] += deposition_amount\n\n        # 3. Clamping\n        np.clip(pheromone, TAU_MIN, TAU_MAX, out=pheromone)\n\n    return best_energy_global\n\ndef solve():\n    \"\"\"Main solver function to run test cases.\"\"\"\n    \n    test_cases = [\n        # Case A: (N, M, I, B, alpha, beta, rho, seed)\n        (8, 25, 40, 36, 1.0, 2.0, 0.1, 1234),\n        # Case B\n        (4, 16, 25, 24, 1.0, 1.0, 0.3, 202),\n        # Case C\n        (10, 20, 30, 24, 1.5, 1.0, 0.2, 999),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, I, B, alpha, beta, rho, seed = case\n        best_energy = run_simulation(N, M, I, B, alpha, beta, rho, seed)\n        results.append(f\"{best_energy:.3f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}