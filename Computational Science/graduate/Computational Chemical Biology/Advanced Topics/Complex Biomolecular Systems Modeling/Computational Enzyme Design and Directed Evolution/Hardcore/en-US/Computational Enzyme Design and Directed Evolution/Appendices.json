{
    "hands_on_practices": [
        {
            "introduction": "The design of a functional enzyme active site begins with a fundamental challenge: determining the optimal three-dimensional arrangement of its amino acid side chains. Given the vast number of possible conformations, or rotamers, an exhaustive search is computationally intractable. This exercise introduces the Dead-End Elimination (DEE) algorithm, a cornerstone of computational protein design that deterministically prunes the search space, allowing you to find the Global Minimum Energy Conformation (GMEC) efficiently . By implementing this algorithm, you will gain first-hand experience with the logic of conformational optimization that underpins modern protein engineering.",
            "id": "3839478",
            "problem": "You are tasked with implementing a program to select side-chain conformations (rotamers) for a buried enzymatic active site using Dead-End Elimination (DEE) and then computing the Global Minimum Energy Conformation (GMEC) under a pairwise-additive energy model. The problem should be solved from first principles, starting from a pairwise decomposable energy definition and deriving a pruning criterion that guarantees elimination of rotamers that cannot be part of any globally optimal solution. After pruning converges, you must enumerate the remaining rotamer combinations to identify the GMEC. The program must operate deterministically and produce a single line of output aggregating results for a set of test cases.\n\nFundamental base and definitions:\n- A protein side-chain conformation space is discretized into a set of rotamers per residue. Let there be $N$ residues indexed by $i\\in\\{0,1,\\dots,N-1\\}$, and for residue $i$ let there be $K_i$ rotamers indexed by $r\\in\\{0,1,\\dots,K_i-1\\}$.\n- The energy model is pairwise-additive and decomposes into self and pair terms. For an assignment $\\mathbf{r}=(r_0,r_1,\\dots,r_{N-1})$, the total energy is\n$$\nE(\\mathbf{r}) \\;=\\; \\sum_{i=0}^{N-1} E_i(r_i) \\;+\\; \\sum_{0\\le ij\\le N-1} E_{ij}(r_i,r_j),\n$$\nwhere $E_i(r)$ is the self energy of rotamer $r$ at residue $i$, and $E_{ij}(r_i,r_j)$ is the pair energy between rotamers $r_i$ and $r_j$ at residues $i$ and $j$. All energies are expressed in kilocalories per mole (kcal/mol).\n- An assignment $\\mathbf{r}^\\star$ is a Global Minimum Energy Conformation (GMEC) if it minimizes $E(\\mathbf{r})$ over the discrete rotamer space.\n- Dead-End Elimination (DEE) is a method for pruning rotamers by proving they cannot belong to any GMEC, based on lower bounds derived from the energy decomposition. You must derive a valid single-residue pruning inequality from the above pairwise model and use it to prune until no more rotamers can be eliminated. Then, exhaustively enumerate the remaining rotamer assignments to find the GMEC.\n\nProgram requirements:\n- Implement an iterative pruning algorithm based on a valid DEE criterion derived from the pairwise-additive energy model, eliminating rotamers that cannot be part of any GMEC. Continue until a fixed point is reached (no further eliminations).\n- After pruning, compute the GMEC by exact enumeration over the remaining rotamer sets.\n- For ties in energy, break deterministically by selecting the lexicographically smallest rotamer assignment $(r_0,r_1,\\dots)$ encountered during enumeration.\n- For each test case, report the total number of pruned rotamers, the GMEC energy in kilocalories per mole rounded to four decimal places, and the GMEC rotamer indices as a list of integers.\n\nTest suite:\nYou must hard-code and solve the following three test cases. In each case, $E_i(r)$ and $E_{ij}(r_i,r_j)$ are given, with $E_{ij}(r_i,r_j)=E_{ji}(r_j,r_i)$ and $E_{ii}(\\cdot,\\cdot)=0$ implicitly. All numbers below are energies in kilocalories per mole and must be used exactly as specified.\n\n- Test case $1$ (happy path with nontrivial pruning):\n  - Residues: $N=3$, rotamer counts: $(K_0,K_1,K_2)=(2,2,2)$.\n  - Self energies:\n    $$\n    E_0 = \\begin{bmatrix} -1.0  0.2 \\end{bmatrix},\\quad\n    E_1 = \\begin{bmatrix} -0.5  -0.1 \\end{bmatrix},\\quad\n    E_2 = \\begin{bmatrix} -0.3  -0.2 \\end{bmatrix}.\n    $$\n  - Pair energies between residues $(0,1)$:\n    $$\n    E_{01} =\n    \\begin{bmatrix}\n    -0.4  -0.1\\\\\n    0.6  0.2\n    \\end{bmatrix},\n    $$\n    where rows correspond to $r_0\\in\\{0,1\\}$ and columns to $r_1\\in\\{0,1\\}$.\n  - Pair energies between residues $(0,2)$:\n    $$\n    E_{02} =\n    \\begin{bmatrix}\n    -0.3  -0.1\\\\\n    0.5  0.1\n    \\end{bmatrix}.\n    $$\n  - Pair energies between residues $(1,2)$:\n    $$\n    E_{12} =\n    \\begin{bmatrix}\n    -0.2  0.0\\\\\n    0.1  0.2\n    \\end{bmatrix}.\n    $$\n  - All other pair energies are defined by symmetry.\n\n- Test case $2$ (boundary case with no pruning):\n  - Residues: $N=4$, rotamer counts: $(K_0,K_1,K_2,K_3)=(2,3,2,2)$.\n  - Self energies:\n    $$\n    E_0 = \\begin{bmatrix} 0.0  0.0 \\end{bmatrix},\\quad\n    E_1 = \\begin{bmatrix} -0.1  -0.1  -0.1 \\end{bmatrix},\\quad\n    E_2 = \\begin{bmatrix} 0.0  0.0 \\end{bmatrix},\\quad\n    E_3 = \\begin{bmatrix} 0.0  0.0 \\end{bmatrix}.\n    $$\n  - All pair energies are zero:\n    $$\n    E_{ij}(r_i,r_j)=0.0 \\quad \\text{for all } 0\\le ij\\le 3 \\text{ and all rotamer indices}.\n    $$\n\n- Test case $3$ (edge case with aggressive pruning in a buried active site):\n  - Residues: $N=3$, rotamer counts: $(K_0,K_1,K_2)=(3,3,3)$.\n  - Self energies:\n    $$\n    E_0 = \\begin{bmatrix} 0.5  -0.2  0.9 \\end{bmatrix},\\quad\n    E_1 = \\begin{bmatrix} 0.4  -0.1  0.6 \\end{bmatrix},\\quad\n    E_2 = \\begin{bmatrix} 0.3  -0.05  0.7 \\end{bmatrix}.\n    $$\n  - Pair energies between residues $(0,1)$:\n    $$\n    E_{01} =\n    \\begin{bmatrix}\n    0.6  0.6  0.6\\\\\n    -1.5  -1.5  -1.5\\\\\n    0.5  0.5  0.5\n    \\end{bmatrix},\n    $$\n    where rows correspond to $r_0\\in\\{0,1,2\\}$ and columns to $r_1\\in\\{0,1,2\\}$.\n  - Pair energies between residues $(0,2)$:\n    $$\n    E_{02} =\n    \\begin{bmatrix}\n    0.7  0.7  0.7\\\\\n    -1.2  -1.2  -1.2\\\\\n    0.4  0.4  0.4\n    \\end{bmatrix}.\n    $$\n  - Pair energies between residues $(1,2)$:\n    $$\n    E_{12} =\n    \\begin{bmatrix}\n    0.5  0.5  0.5\\\\\n    -1.3  -1.3  -1.3\\\\\n    0.6  0.6  0.6\n    \\end{bmatrix}.\n    $$\n  - All other pair energies are defined by symmetry. This case represents a buried active site with strong favorable interactions when specific rotamers align ($r=1$ across residues), and unfavorable interactions otherwise.\n\nExact output format:\n- For each test case, produce a list containing the total number of pruned rotamers (an integer), the GMEC energy in kilocalories per mole rounded to four decimal places (a float), followed by the GMEC rotamer indices for residues $0$ through $N-1$ (integers). The final program output must be a single line containing a list of these per-case lists, in the form\n$$\n\\text{[case\\_1\\_result,case\\_2\\_result,case\\_3\\_result]},\n$$\nwhere each $\\text{case\\_k\\_result}$ is itself a list as described. The program must output only this single line and nothing else.\n\nAngle units do not apply. Energies must be reported in kilocalories per mole rounded to four decimal places (use decimal form, not scientific notation or percentages).",
            "solution": "The problem requires the implementation of the Dead-End Elimination (DEE) algorithm to prune the conformational space of protein side-chains, followed by an exhaustive search to find the Global Minimum Energy Conformation (GMEC). The solution is predicated on a pairwise-additive energy model.\n\nFirst, we establish the theoretical foundation by deriving a valid pruning criterion for DEE. The total energy of a specific conformation, which is an assignment of rotamers $\\mathbf{r}=(r_0, r_1, \\dots, r_{N-1})$ to $N$ residues, is given by:\n$$\nE(\\mathbf{r}) = \\sum_{i=0}^{N-1} E_i(r_i) + \\sum_{0 \\le ij \\le N-1} E_{ij}(r_i, r_j)\n$$\nwhere $E_i(r_i)$ is the self-energy of rotamer $r_i$ at residue $i$, and $E_{ij}(r_i, r_j)$ is the pairwise interaction energy between rotamer $r_i$ at residue $i$ and rotamer $r_j$ at residue $j$.\n\nThe principle of DEE is to identify and eliminate a rotamer that can be proven to not be part of any GMEC. Let us consider a specific residue $i$ and two of its rotamers, $u$ and $v$. We want to determine a condition under which rotamer $u$ at residue $i$ (denoted $i_u$) can be eliminated because rotamer $v$ at residue $i$ ($i_v$) is always a better choice, regardless of the rotamers chosen for all other residues.\n\nLet $\\mathbf{r}_{-i} = (r_0, \\dots, r_{i-1}, r_{i+1}, \\dots, r_{N-1})$ denote a complete rotamer assignment for all residues except $i$. The total energy of a conformation including $i_u$ is $E(i_u, \\mathbf{r}_{-i})$, and one including $i_v$ is $E(i_v, \\mathbf{r}_{-i})$. Rotamer $i_u$ can be definitively eliminated if for a competing rotamer $i_v$, the following is true for all possible choices of $\\mathbf{r}_{-i}$:\n$$\nE(i_u, \\mathbf{r}_{-i})  E(i_v, \\mathbf{r}_{-i})\n$$\nThe energy difference $\\Delta E = E(i_u, \\mathbf{r}_{-i}) - E(i_v, \\mathbf{r}_{-i})$ can be computed by isolating terms dependent on residue $i$:\n$$\n\\Delta E = \\left( E_i(u) + \\sum_{j \\neq i} E_{ij}(u, r_j) \\right) - \\left( E_i(v) + \\sum_{j \\neq i} E_{ij}(v, r_j) \\right)\n$$\nThe terms not involving residue $i$ cancel out. Rearranging the expression gives:\n$$\n\\Delta E = (E_i(u) - E_i(v)) + \\sum_{j \\neq i} \\left( E_{ij}(u, r_j) - E_{ij}(v, r_j) \\right)\n$$\nFor rotamer $i_u$ to be pruned, this energy difference must be strictly positive for all possible valid assignments $\\mathbf{r}_{-i}$. Since we do not know the correct assignment for other residues, we must establish a lower bound on this difference. If the lower bound is greater than zero, the condition holds. Let $R_j$ be the set of currently active (non-pruned) rotamers for residue $j$. We can lower-bound the sum by minimizing each term independently over the choices for $r_j \\in R_j$:\n$$\n\\min_{\\mathbf{r}_{-i}} \\Delta E = (E_i(u) - E_i(v)) + \\sum_{j \\neq i} \\min_{r_j \\in R_j} \\left( E_{ij}(u, r_j) - E_{ij}(v, r_j) \\right)\n$$\nThus, the rigorous condition to prune rotamer $u$ at residue $i$ (given a better rotamer $v$ at the same residue) is:\n$$\nE_i(u) - E_i(v) + \\sum_{j \\neq i} \\min_{r_j \\in R_j} \\left( E_{ij}(u, r_j) - E_{ij}(v, r_j) \\right)  0\n$$\nThis is the single-residue DEE pruning criterion (often called the Goldstein criterion) that will be implemented. A rotamer $i_u$ is a \"dead-end\" if there exists at least one competitor $i_v$ that satisfies this inequality.\n\nThe algorithm proceeds as follows:\n1.  **Initialization**: Start with all rotamers for every residue considered 'active'. Let the set of active rotamers for residue $i$ be $R_i$. The total number of initial rotamers is $\\sum_{i=0}^{N-1} K_i$.\n2.  **Iterative Pruning**:\n    a. Begin an iterative process. In each pass, we check all active rotamers for potential pruning.\n    b. For each residue $i$, and for each pair of its active rotamers $(u, v)$ where $u \\in R_i, v \\in R_i, u \\neq v$, evaluate the DEE criterion.\n    c. If the inequality holds, rotamer $i_u$ is guaranteed to not be in the GMEC relative to rotamer $i_v$. We mark $i_u$ for pruning.\n    d. After checking all rotamers for a residue, and all residues in the system, we collect all rotamers marked for pruning in the pass.\n    e. If any rotamers were marked, we remove them from their respective active sets $R_i$, increment a counter for pruned rotamers, and begin a new pass. The pruning of rotamers in one pass tightens the bounds $\\min_{r_j \\in R_j}(\\dots)$ for subsequent passes, potentially enabling more eliminations.\n    f. If a full pass completes with no rotamers being pruned, the DEE algorithm has converged to a fixed point.\n3.  **GMEC Search**:\n    a. After DEE convergence, the remaining active rotamers form a substantially smaller search space.\n    b. We perform an exhaustive search over this reduced space. All combinations of the remaining active rotamers are generated. For each combination $\\mathbf{r} = (r_0, \\dots, r_{N-1})$ where $r_i \\in R_i$, the total energy $E(\\mathbf{r})$ is calculated.\n    c. The combination yielding the minimum energy is the GMEC. The problem specifies a deterministic tie-breaking rule: if multiple conformations have the same minimum energy, the one with the lexicographically smallest rotamer index vector $(r_0, r_1, \\dots)$ is chosen. This is naturally handled by generating and testing combinations in lexicographical order and only updating the GMEC when a strictly lower energy is found.\n4.  **Reporting**: For each test case, the final result is a list containing the total count of pruned rotamers, the GMEC energy rounded to four decimal places, and the integer indices of the GMEC rotamer assignment. The results from all test cases are then aggregated into a final list. The implementation will use `numpy` for efficient handling of energy matrices and vector operations.",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to define, solve, and print the results for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 3,\n            \"K\": (2, 2, 2),\n            \"self_energies\": [\n                np.array([-1.0, 0.2]),\n                np.array([-0.5, -0.1]),\n                np.array([-0.3, -0.2])\n            ],\n            \"pair_energies\": {\n                (0, 1): np.array([[-0.4, -0.1], [0.6, 0.2]]),\n                (0, 2): np.array([[-0.3, -0.1], [0.5, 0.1]]),\n                (1, 2): np.array([[-0.2, 0.0], [0.1, 0.2]])\n            }\n        },\n        {\n            \"N\": 4,\n            \"K\": (2, 3, 2, 2),\n            \"self_energies\": [\n                np.array([0.0, 0.0]),\n                np.array([-0.1, -0.1, -0.1]),\n                np.array([0.0, 0.0]),\n                np.array([0.0, 0.0])\n            ],\n            \"pair_energies\": {\n                (0, 1): np.zeros((2, 3)), (0, 2): np.zeros((2, 2)), (0, 3): np.zeros((2, 2)),\n                (1, 2): np.zeros((3, 2)), (1, 3): np.zeros((3, 2)),\n                (2, 3): np.zeros((2, 2))\n            }\n        },\n        {\n            \"N\": 3,\n            \"K\": (3, 3, 3),\n            \"self_energies\": [\n                np.array([0.5, -0.2, 0.9]),\n                np.array([0.4, -0.1, 0.6]),\n                np.array([0.3, -0.05, 0.7])\n            ],\n            \"pair_energies\": {\n                (0, 1): np.array([[0.6, 0.6, 0.6], [-1.5, -1.5, -1.5], [0.5, 0.5, 0.5]]),\n                (0, 2): np.array([[0.7, 0.7, 0.7], [-1.2, -1.2, -1.2], [0.4, 0.4, 0.4]]),\n                (1, 2): np.array([[0.5, 0.5, 0.5], [-1.3, -1.3, -1.3], [0.6, 0.6, 0.6]])\n            }\n        }\n    ]\n\n    all_results = []\n    for case_data in test_cases:\n        result = find_gmec_with_dee(case_data)\n        all_results.append(result)\n\n    # Format the final output string as a list of lists.\n    formatted_case_results = []\n    for case_list in all_results:\n        pruned_count, energy, gmec_indices = case_list\n        flat_list = [pruned_count, energy] + gmec_indices\n        \n        items = []\n        for item in flat_list:\n            if isinstance(item, float):\n                items.append(f\"{item:.4f}\")\n            else:\n                items.append(str(item))\n        formatted_case_results.append(f\"[{','.join(items)}]\")\n    \n    final_output_str = f\"[{','.join(formatted_case_results)}]\"\n    print(final_output_str)\n\n\ndef find_gmec_with_dee(case):\n    \"\"\"\n    Solves a single rotamer packing problem instance using DEE and exhaustive search.\n    \"\"\"\n    N = case[\"N\"]\n    K = case[\"K\"]\n    self_energies = case[\"self_energies\"]\n    pair_energies = case[\"pair_energies\"]\n    \n    initial_rotamer_count = sum(K)\n    active_rotamers = [set(range(k)) for k in K]\n\n    # --- Dead-End Elimination (DEE) ---\n    while True:\n        pruned_in_pass = False\n        rotamers_to_prune_this_pass = set()\n\n        for i in range(N):\n            # Cannot prune if only one rotamer is left.\n            if len(active_rotamers[i]) = 1:\n                continue\n\n            # Check each rotamer u for pruning.\n            for u in active_rotamers[i]:\n                # Find if there is a competitor v that prunes u.\n                for v in active_rotamers[i]:\n                    if u == v:\n                        continue\n                        \n                    # Calculate the DEE criterion: E_i(u) - E_i(v) + sum(...)  0\n                    energy_diff = self_energies[i][u] - self_energies[i][v]\n                    \n                    sum_of_mins = 0.0\n                    for j in range(N):\n                        if i == j:\n                            continue\n                        \n                        min_pair_diff = float('inf')\n                        \n                        # Indices for pair energy matrix access\n                        p_i, p_j = min(i, j), max(i, j)\n                        E_ij = pair_energies[(p_i, p_j)]\n\n                        if not active_rotamers[j]: # Should not happen in valid problem\n                            continue\n                        \n                        # Find min over r_j in active_rotamers[j]\n                        for r_j in active_rotamers[j]:\n                            if i  j: # E_ij(u, r_j) - E_ij(v, r_j)\n                                diff = E_ij[u, r_j] - E_ij[v, r_j]\n                            else: # E_ji(r_j, u) - E_ji(r_j, v)\n                                diff = E_ij[r_j, u] - E_ij[r_j, v]\n                            \n                            if diff  min_pair_diff:\n                                min_pair_diff = diff\n                        \n                        sum_of_mins += min_pair_diff\n\n                    if energy_diff + sum_of_mins  1e-9: # Use a small epsilon for float comparison stability\n                        rotamers_to_prune_this_pass.add((i, u))\n                        break # Found a v that prunes u, move to next u\n        \n        if rotamers_to_prune_this_pass:\n            pruned_in_pass = True\n            for i, u_to_prune in rotamers_to_prune_this_pass:\n                if u_to_prune in active_rotamers[i]:\n                    active_rotamers[i].remove(u_to_prune)\n        \n        if not pruned_in_pass:\n            break\n\n    final_rotamer_count = sum(len(s) for s in active_rotamers)\n    total_pruned = initial_rotamer_count - final_rotamer_count\n    \n    # --- Exhaustive GMEC Search ---\n    min_energy = float('inf')\n    gmec = None\n\n    # Generate all combinations of remaining rotamers. itertools.product ensures lexicographical order.\n    rem_rotamer_lists = [list(sorted(s)) for s in active_rotamers]\n    \n    for r_tuple in itertools.product(*rem_rotamer_lists):\n        current_energy = 0.0\n        # Add self energies\n        for i in range(N):\n            current_energy += self_energies[i][r_tuple[i]]\n        \n        # Add pair energies\n        for i in range(N):\n            for j in range(i + 1, N):\n                r_i, r_j = r_tuple[i], r_tuple[j]\n                current_energy += pair_energies[(i, j)][r_i, r_j]\n        \n        if current_energy  min_energy:\n            min_energy = current_energy\n            gmec = list(r_tuple)\n    \n    # If no combinations are possible (e.g., one residue has all rotamers pruned)\n    if gmec is None:\n        return [total_pruned, 0.0, []]\n\n    return [total_pruned, min_energy, gmec]\n\n\n# Execute the solver\nsolve()\n\n```"
        },
        {
            "introduction": "Once an enzyme structure is modeled, the next critical step is to predict its function, such as how tightly it binds its substrate. This practice guides you through the implementation of a free energy calculation, a powerful method rooted in statistical mechanics for predicting how mutations or substrate modifications affect binding affinity . By using a thermodynamic cycle and data from simulated \"alchemical\" transformations, you will not only compute the relative binding free energy but also learn to assess the calculation's reliability by quantifying its hysteresis, a crucial skill for any computational chemist.",
            "id": "3839500",
            "problem": "You are given a computational task arising in enzyme-substrate binding free energy estimation for enzyme design and directed evolution. The goal is to compute the relative binding free energy between two substrates via a thermodynamic cycle and quantify hysteresis arising from computing the free energy difference along forward versus reverse alchemical transformation paths. The scenario is abstracted to two ensembles: the enzyme-substrate complex and the aqueous solution. The computation must be based on first principles in statistical mechanics, starting from partition functions and free energies, and must not assume any shortcut formula beyond those principles. You must treat energy samples as potential energy differences between two alchemical states of the substrate, recorded in physically consistent units.\n\nDefinitions to use:\n- The canonical partition function for a state $X$ at absolute temperature $T$ is $Z_X = \\int \\exp\\left(-\\beta U_X(x)\\right)\\,dx$, where $U_X(x)$ is the potential energy and $\\beta = 1/(R T)$ with $R$ the molar gas constant.\n- The molar free energy of state $X$ is $G_X = -R T \\ln Z_X$.\n- The transformation free energy from state $A$ to state $B$ in an ensemble sampled from state $A$ follows from these definitions and must be computed without assuming any formula beyond the fundamental relationships stated.\n\nTasks:\n- Using energy difference samples and temperature, compute the transformation free energy for the enzyme-substrate complex and for aqueous solution along both the forward and reverse paths. For the forward path, samples are of $\\Delta U = U_B - U_A$ drawn from the $A$ ensemble. For the reverse path, samples are of $\\Delta U_{\\mathrm{rev}} = U_A - U_B$ drawn from the $B$ ensemble. All samples are in $\\mathrm{kJ/mol}$ and collected at the same absolute temperature $T$.\n- Use a thermodynamic cycle that transforms substrate $S_1$ into $S_2$ in both environments. The relative binding free energy $\\Delta \\Delta G_{\\mathrm{bind}}$ is the difference between the transformation free energy in the complex and that in solution. Compute one $\\Delta \\Delta G_{\\mathrm{bind}}$ from forward data and one from reverse data, both expressed in $\\mathrm{kJ/mol}$.\n- Define hysteresis as the absolute difference between the forward and reverse estimates of $\\Delta \\Delta G_{\\mathrm{bind}}$, expressed in $\\mathrm{kJ/mol}$.\n\nPhysical units and constants:\n- Use $T = 298$ $\\mathrm{K}$ and $R = 8.314462618 \\times 10^{-3}$ $\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$. Energies are in $\\mathrm{kJ/mol}$.\n\nTest suite:\nCompute results for three test cases, each providing four arrays of energy differences, all in $\\mathrm{kJ/mol}$:\n- Case $1$ (typical overlap):\n  - Complex forward samples $\\Delta U$: $\\{5.2, 4.8, 5.0, 5.4, 4.9\\}$.\n  - Complex reverse samples $\\Delta U_{\\mathrm{rev}}$: $\\{-5.1, -5.0, -4.8, -5.4, -5.2\\}$.\n  - Solution forward samples $\\Delta U$: $\\{2.1, 2.4, 2.2, 2.0, 2.3\\}$.\n  - Solution reverse samples $\\Delta U_{\\mathrm{rev}}$: $\\{-2.2, -2.1, -1.9, -2.3, -2.0\\}$.\n- Case $2$ (poor overlap to stress hysteresis):\n  - Complex forward samples $\\Delta U$: $\\{12.0, 15.0, 20.0, 14.0, 18.0\\}$.\n  - Complex reverse samples $\\Delta U_{\\mathrm{rev}}$: $\\{-7.0, -9.0, -8.0, -7.5, -8.5\\}$.\n  - Solution forward samples $\\Delta U$: $\\{10.0, 14.0, 9.0, 13.0, 11.0\\}$.\n  - Solution reverse samples $\\Delta U_{\\mathrm{rev}}$: $\\{-6.0, -7.0, -6.5, -6.8, -6.2\\}$.\n- Case $3$ (near cycle closure):\n  - Complex forward samples $\\Delta U$: $\\{3.0, 3.2, 2.8, 3.1, 2.9\\}$.\n  - Complex reverse samples $\\Delta U_{\\mathrm{rev}}$: $\\{-3.1, -3.0, -3.2, -2.9, -3.1\\}$.\n  - Solution forward samples $\\Delta U$: $\\{3.1, 2.9, 3.2, 3.0, 3.0\\}$.\n  - Solution reverse samples $\\Delta U_{\\mathrm{rev}}$: $\\{-3.0, -3.1, -2.8, -3.2, -3.0\\}$.\n\nFor each case, compute three quantities:\n- $\\Delta \\Delta G_{\\mathrm{forward}}$ in $\\mathrm{kJ/mol}$.\n- $\\Delta \\Delta G_{\\mathrm{reverse}}$ in $\\mathrm{kJ/mol}$.\n- Hysteresis $H$ in $\\mathrm{kJ/mol}$, defined as $H = \\left|\\Delta \\Delta G_{\\mathrm{forward}} - \\Delta \\Delta G_{\\mathrm{reverse}}\\right|$.\n\nAnswer specification:\n- Express all outputs in $\\mathrm{kJ/mol}$, rounded to three decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $\\left[\\Delta \\Delta G_{\\mathrm{forward}}^{(1)}, \\Delta \\Delta G_{\\mathrm{reverse}}^{(1)}, H^{(1)}, \\Delta \\Delta G_{\\mathrm{forward}}^{(2)}, \\Delta \\Delta G_{\\mathrm{reverse}}^{(2)}, H^{(2)}, \\Delta \\Delta G_{\\mathrm{forward}}^{(3)}, \\Delta \\Delta G_{\\mathrm{reverse}}^{(3)}, H^{(3)}\\right]$, where the superscript denotes the case index. No other text should be printed.",
            "solution": "The problem requires the calculation of the relative binding free energy of two substrates to an enzyme, $\\Delta \\Delta G_{\\mathrm{bind}}$, and the associated hysteresis, based on fundamental principles of statistical mechanics. The calculation uses sampled energy differences from an alchemical transformation in two distinct environments: the enzyme-substrate complex and the aqueous solution.\n\nThe solution proceeds in two stages. First, we derive the necessary formula for the transformation free energy from the provided first principles. Second, we apply this formula within a thermodynamic cycle to compute the desired quantities for the given test cases.\n\n**1. Derivation of the Transformation Free Energy Formula**\n\nThe problem provides the fundamental definitions for the molar free energy, $G_X$, and the canonical partition function, $Z_X$, for a state $X$ at absolute temperature $T$:\n$$ G_X = -R T \\ln Z_X $$\n$$ Z_X = \\int \\exp\\left(-\\beta U_X(x)\\right)\\,dx $$\nHere, $U_X(x)$ is the potential energy of a microstate $x$, $R$ is the molar gas constant, and $\\beta = 1/(R T)$.\n\nThe free energy change, $\\Delta G_{A \\to B}$, for a transformation from an initial state $A$ to a final state $B$ is the difference in their free energies:\n$$ \\Delta G_{A \\to B} = G_B - G_A = (-R T \\ln Z_B) - (-R T \\ln Z_A) = -R T \\ln \\left( \\frac{Z_B}{Z_A} \\right) $$\nThe ratio of the partition functions can be expressed as:\n$$ \\frac{Z_B}{Z_A} = \\frac{\\int \\exp(-\\beta U_B(x)) \\, dx}{\\int \\exp(-\\beta U_A(x)) \\, dx} $$\nThe problem specifies that for the forward transformation, we have samples drawn from an ensemble corresponding to state $A$. The probability density function for observing a microstate $x$ in this ensemble is given by the Boltzmann distribution:\n$$ p_A(x) = \\frac{\\exp(-\\beta U_A(x))}{Z_A} $$\nWe can rewrite the ratio $Z_B/Z_A$ by introducing $p_A(x)$ into the integral:\n$$ \\frac{Z_B}{Z_A} = \\int \\frac{\\exp(-\\beta U_B(x))}{\\exp(-\\beta U_A(x))} \\cdot \\frac{\\exp(-\\beta U_A(x))}{Z_A} \\, dx $$\nThis simplifies to:\n$$ \\frac{Z_B}{Z_A} = \\int \\exp(-\\beta (U_B(x) - U_A(x))) \\, p_A(x) \\, dx $$\nThe integral represents the ensemble average of the quantity $\\exp(-\\beta \\Delta U)$, where $\\Delta U = U_B - U_A$, over the ensemble of state $A$. This is denoted as $\\left \\exp(-\\beta \\Delta U) \\right_A$. Therefore:\n$$ \\frac{Z_B}{Z_A} = \\left \\exp(-\\beta \\Delta U) \\right_A $$\nSubstituting this back into the equation for $\\Delta G_{A \\to B}$, we obtain the Zwanzig free energy perturbation (FEP) formula:\n$$ \\Delta G_{A \\to B} = -R T \\ln \\left \\exp(-\\beta \\Delta U) \\right_A $$\nIn practice, the ensemble average is estimated from a finite number of $N$ samples of $\\Delta U_i$ collected from simulations of state $A$:\n$$ \\Delta G_{A \\to B}^{\\text{forward}} \\approx -R T \\ln \\left( \\frac{1}{N} \\sum_{i=1}^{N} \\exp(-\\beta \\Delta U_i) \\right) $$\nThis is the formula for the \"forward\" path calculation.\n\nFor the \"reverse\" path, we are given samples of $\\Delta U_{\\mathrm{rev}} = U_A - U_B$ from simulations of state $B$. By symmetric reasoning, we can calculate the free energy change for the reverse transformation, $B \\to A$:\n$$ \\Delta G_{B \\to A} = -R T \\ln \\left \\exp(-\\beta \\Delta U_{\\mathrm{rev}}) \\right_B $$\nSince free energy is a state function, $\\Delta G_{A \\to B} = -\\Delta G_{B \\to A}$. Therefore, the estimate of the forward free energy change from reverse path data is:\n$$ \\Delta G_{A \\to B}^{\\text{reverse}} = -\\Delta G_{B \\to A} \\approx R T \\ln \\left( \\frac{1}{M} \\sum_{j=1}^{M} \\exp(-\\beta \\Delta U_{\\mathrm{rev}, j}) \\right) $$\nwhere $M$ is the number of samples from the reverse path simulation.\n\n**2. Thermodynamic Cycle and Relative Binding Free Energy**\n\nWe apply these formulas to the alchemical transformation of substrate $S_1$ to $S_2$ in two environments: the enzyme-substrate complex (cplx) and the aqueous solution (sol). The relative binding free energy, $\\Delta \\Delta G_{\\mathrm{bind}}$, is given by the thermodynamic cycle:\n$$ \\Delta \\Delta G_{\\mathrm{bind}} = \\Delta G_{\\mathrm{bind}}(S_2) - \\Delta G_{\\mathrm{bind}}(S_1) = \\Delta G_{\\text{cplx}}(S_1 \\to S_2) - \\Delta G_{\\text{sol}}(S_1 \\to S_2) $$\nWe compute this quantity using both forward and reverse path data.\n\nFor the forward path:\n$$ \\Delta \\Delta G_{\\mathrm{forward}} = \\Delta G_{\\text{cplx}}^{\\text{forward}} - \\Delta G_{\\text{sol}}^{\\text{forward}} $$\nFor the reverse path:\n$$ \\Delta \\Delta G_{\\mathrm{reverse}} = \\Delta G_{\\text{cplx}}^{\\text{reverse}} - \\Delta G_{\\text{sol}}^{\\text{reverse}} $$\n\n**3. Hysteresis**\n\nHysteresis, $H$, quantifies the discrepancy between the forward and reverse calculations, which arises from finite sampling and poor overlap between the phase spaces of the two states. It is defined as the absolute difference between the two estimates:\n$$ H = \\left| \\Delta \\Delta G_{\\mathrm{forward}} - \\Delta \\Delta G_{\\mathrm{reverse}} \\right| $$\n\n**4. Computational Algorithm**\n\nThe computation for each test case proceeds as follows:\n1.  Define the physical constants $R = 8.314462618 \\times 10^{-3} \\ \\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$ and $T = 298 \\ \\mathrm{K}$. Calculate the product $RT$ and the factor $\\beta = 1/(RT)$.\n2.  For each environment (complex and solution), calculate $\\Delta G^{\\text{forward}}$ using the forward path formula and the provided $\\Delta U$ samples. This involves computing the logarithm of the mean of exponentials. To maintain numerical stability against overflow or underflow, the log-sum-exp technique is employed: $\\ln(\\sum_i e^{x_i}) = x_{\\max} + \\ln(\\sum_i e^{x_i - x_{\\max}})$.\n3.  Similarly, calculate $\\Delta G^{\\text{reverse}}$ for each environment using the reverse path formula and the provided $\\Delta U_{\\mathrm{rev}}$ samples.\n4.  Compute $\\Delta \\Delta G_{\\mathrm{forward}}$ and $\\Delta \\Delta G_{\\mathrm{reverse}}$ by subtracting the solution free energy change from the complex free energy change for each path.\n5.  Calculate the hysteresis $H$ as the absolute difference between $\\Delta \\Delta G_{\\mathrm{forward}}$ and $\\Delta \\Delta G_{\\mathrm{reverse}}$.\n6.  Round all final results to three decimal places as specified.\n\nThis procedure is applied to each of the three test cases provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes relative binding free energy and hysteresis for three test cases\n    based on statistical mechanics principles.\n    \"\"\"\n    # Physical constants\n    R = 8.314462618e-3  # Molar gas constant in kJ mol^-1 K^-1\n    T = 298.0           # Absolute temperature in K\n    RT = R * T          # Thermal energy in kJ/mol\n    BETA = 1.0 / RT     # Inverse thermal energy in (kJ/mol)^-1\n\n    # Test suite data\n    test_cases = [\n        # Case 1: Typical overlap\n        {\n            \"complex_fwd\": np.array([5.2, 4.8, 5.0, 5.4, 4.9]),\n            \"complex_rev\": np.array([-5.1, -5.0, -4.8, -5.4, -5.2]),\n            \"solution_fwd\": np.array([2.1, 2.4, 2.2, 2.0, 2.3]),\n            \"solution_rev\": np.array([-2.2, -2.1, -1.9, -2.3, -2.0]),\n        },\n        # Case 2: Poor overlap\n        {\n            \"complex_fwd\": np.array([12.0, 15.0, 20.0, 14.0, 18.0]),\n            \"complex_rev\": np.array([-7.0, -9.0, -8.0, -7.5, -8.5]),\n            \"solution_fwd\": np.array([10.0, 14.0, 9.0, 13.0, 11.0]),\n            \"solution_rev\": np.array([-6.0, -7.0, -6.5, -6.8, -6.2]),\n        },\n        # Case 3: Near cycle closure\n        {\n            \"complex_fwd\": np.array([3.0, 3.2, 2.8, 3.1, 2.9]),\n            \"complex_rev\": np.array([-3.1, -3.0, -3.2, -2.9, -3.1]),\n            \"solution_fwd\": np.array([3.1, 2.9, 3.2, 3.0, 3.0]),\n            \"solution_rev\": np.array([-3.0, -3.1, -2.8, -3.2, -3.0]),\n        },\n    ]\n\n    def calculate_delta_g(delta_u_samples, direction):\n        \"\"\"\n        Calculates the transformation free energy from energy difference samples.\n\n        Args:\n            delta_u_samples (np.ndarray): Array of energy differences in kJ/mol.\n            direction (str): 'forward' or 'reverse'.\n\n        Returns:\n            float: The calculated free energy change in kJ/mol.\n        \"\"\"\n        n = len(delta_u_samples)\n        # Arguments for the exponential function\n        args = -BETA * delta_u_samples\n\n        # Log-sum-exp trick for numerical stability\n        max_arg = np.max(args)\n        log_sum_exp = max_arg + np.log(np.sum(np.exp(args - max_arg)))\n        \n        # Log of the average of the exponentials\n        log_of_average_exp = log_sum_exp - np.log(n)\n\n        if direction == 'forward':\n            # Delta_G = -RT * ln(exp(-beta*Delta_U)_A)\n            delta_g = -RT * log_of_average_exp\n        elif direction == 'reverse':\n            # Delta_G = RT * ln(exp(-beta*Delta_U_rev)_B)\n            delta_g = RT * log_of_average_exp\n        else:\n            raise ValueError(\"Direction must be 'forward' or 'reverse'.\")\n        \n        return delta_g\n\n    results = []\n    for case in test_cases:\n        # Forward path calculations\n        delta_g_complex_fwd = calculate_delta_g(case[\"complex_fwd\"], 'forward')\n        delta_g_solution_fwd = calculate_delta_g(case[\"solution_fwd\"], 'forward')\n        delta_delta_g_fwd = delta_g_complex_fwd - delta_g_solution_fwd\n\n        # Reverse path calculations\n        delta_g_complex_rev = calculate_delta_g(case[\"complex_rev\"], 'reverse')\n        delta_g_solution_rev = calculate_delta_g(case[\"solution_rev\"], 'reverse')\n        delta_delta_g_rev = delta_g_complex_rev - delta_g_solution_rev\n        \n        # Hysteresis calculation\n        hysteresis = abs(delta_delta_g_fwd - delta_delta_g_rev)\n\n        results.extend([\n            round(delta_delta_g_fwd, 3),\n            round(delta_delta_g_rev, 3),\n            round(hysteresis, 3)\n        ])\n\n    # Format the final output as a single-line comma-separated list\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Computational designs, no matter how sophisticated, are ultimately hypotheses that must be validated and optimized through laboratory experiments like directed evolution. This final exercise bridges the gap between in silico modeling and wet-lab practice by tackling the practical challenge of designing an efficient genetic library for site-saturation mutagenesis . You will use constrained optimization to determine the ideal mixture of degenerate codon sets to achieve a desired amino acid distribution, thereby learning how to translate a computational design strategy into a tangible and effective experimental plan.",
            "id": "3839506",
            "problem": "You are designing a library for site-saturation mutagenesis in computational enzyme design and directed evolution. You are given a fixed collection of degenerate codon sets, each defined by an International Union of Pure and Applied Chemistry (IUPAC) nucleotide triplet pattern (for example, $NNK$ with $N \\in \\{A,C,G,T\\}$ and $K \\in \\{G,T\\}$). When sampling a codon from a given degenerate set, assume independent and uniform sampling over the allowed nucleotides at each position. By the Central Dogma of Molecular Biology (DNA to RNA to Protein) and the standard genetic code, each codon deterministically maps to exactly one amino acid or to a stop signal. For each codon set $j$, define a $20$-dimensional amino acid frequency vector $\\mathbf{a}_j$ (over the standard $20$ amino acids) and a stop frequency $s_j$, obtained by enumerating all concrete codons allowed by the degenerate pattern and mapping them via the genetic code under the uniform sampling assumption.\n\nYou want to mix these codon sets with nonnegative weights $\\mathbf{w} \\in \\mathbb{R}^M$ ($M$ is the number of codon sets), constrained by $\\sum_{j=1}^M w_j = 1$, to approximate a target amino acid distribution $\\mathbf{p} \\in \\mathbb{R}^{20}$ while penalizing the expected stop fraction. Let $A \\in \\mathbb{R}^{20 \\times M}$ be the matrix with columns $\\mathbf{a}_j$, and let $\\mathbf{s} \\in \\mathbb{R}^M$ collect $s_j$. The mixture-induced amino acid distribution is $A \\mathbf{w}$ and the expected stop frequency is $\\mathbf{s}^\\top \\mathbf{w}$. For a given nonnegative penalty parameter $\\lambda \\in \\mathbb{R}_{\\ge 0}$, find the optimal mixture by solving the constrained convex optimization\n$$\n\\min_{\\mathbf{w} \\in \\mathbb{R}^M} \\; \\frac{1}{2}\\lVert A\\mathbf{w} - \\mathbf{p}\\rVert_2^2 + \\lambda \\, \\mathbf{s}^\\top \\mathbf{w}\n\\quad \\text{subject to} \\quad\n\\sum_{j=1}^M w_j = 1, \\quad w_j \\ge 0 \\; \\text{for all } j.\n$$\n\nFundamental bases to use:\n- The Central Dogma of Molecular Biology (DNA codons map to amino acids or stop).\n- The standard genetic code is deterministic and well-established.\n- Probability mixture model: if codon set $j$ is chosen with probability $w_j$, then the amino acid distribution is the convex combination $A\\mathbf{w}$ and the stop probability is $\\mathbf{s}^\\top \\mathbf{w}$.\n\nCompute $\\mathbf{a}_j$ and $s_j$ exactly by enumerating all codons in each degenerate set assuming equal probability for each allowed nucleotide at each position.\n\nUse the fixed codon set collection (in this exact order for all computations and outputs): $[NNK, NNS, NDT, VHG, TGG]$. Here, $N$ denotes $\\{A,C,G,T\\}$, $K$ denotes $\\{G,T\\}$, $S$ denotes $\\{G,C\\}$, $D$ denotes $\\{A,G,T\\}$, $V$ denotes $\\{A,C,G\\}$, $H$ denotes $\\{A,C,T\\}$, and each literal nucleotide ($A,C,G,T$) denotes itself.\n\nDefine the amino acid order for all vectors (both targets and outputs) as the list of one-letter codes $[A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y]$.\n\nYour program must:\n- Construct $A$ and $\\mathbf{s}$ by exact enumeration using the standard genetic code.\n- For each test case, solve the optimization problem and report the nonnegative weights $\\mathbf{w}$.\n- Also report the expected stop fraction $\\mathbf{s}^\\top \\mathbf{w}$ and the root mean squared error (RMSE) between $A\\mathbf{w}$ and $\\mathbf{p}$, defined as $\\sqrt{\\frac{1}{20}\\sum_{i=1}^{20} ( (A\\mathbf{w})_i - p_i )^2}$.\n\nTest suite:\n- Case $1$ (general case): target uniform distribution $\\mathbf{p}^{(1)}$ with $p^{(1)}_i = \\frac{1}{20}$ for $i=1,\\dots,20$, and $\\lambda^{(1)} = 0.1$.\n- Case $2$ (hydrophobic-enriched boundary-like case): define $\\mathbf{p}^{(2)}$ by setting $p^{(2)}_{\\text{L}} = 0.35$, $p^{(2)}_{\\text{I}} = 0.25$, $p^{(2)}_{\\text{V}} = 0.15$, and distributing the remaining mass $0.25$ equally among the other $17$ amino acids; set $\\lambda^{(2)} = 0.05$.\n- Case $3$ (exactly realizable edge case): tryptophan-only target $\\mathbf{p}^{(3)}$ with $p^{(3)}_{\\text{W}} = 1.0$ and all other entries $0.0$; set $\\lambda^{(3)} = 0.0$.\n- Case $4$ (high stop penalty): uniform target again $\\mathbf{p}^{(4)}$ with $p^{(4)}_i = \\frac{1}{20}$, and $\\lambda^{(4)} = 1000.0$.\n\nAll computations are unitless. Angles are not involved. All fractional answers must be decimal numbers.\n\nFinal output format:\n- For each test case $t \\in \\{1,2,3,4\\}$, produce a list consisting of the mixture weights in the fixed codon-set order $[NNK,NNS,NDT,VHG,TGG]$, followed by the expected stop fraction and the RMSE, all rounded to exactly $6$ decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list of these per-case lists, enclosed in square brackets. For example, an output with two cases would look like $[[w_{11},w_{12},\\dots,stop_1,rmse_1],[w_{21},w_{22},\\dots,stop_2,rmse_2]]$ with no spaces anywhere.",
            "solution": "The problem presented is a constrained convex optimization task, specifically a Quadratic Program (QP), aimed at finding an optimal mixture of degenerate codon sets to approximate a target amino acid distribution in computational enzyme design. The problem is scientifically and mathematically well-posed and can be solved systematically.\n\nThe core of the problem is to solve the following minimization for the weight vector $\\mathbf{w} \\in \\mathbb{R}^M$:\n$$\n\\min_{\\mathbf{w}} \\; f(\\mathbf{w}) = \\frac{1}{2}\\lVert A\\mathbf{w} - \\mathbf{p}\\rVert_2^2 + \\lambda \\, \\mathbf{s}^\\top \\mathbf{w}\n$$\nsubject to the constraints that the weights form a probability distribution:\n$$\n\\sum_{j=1}^M w_j = 1, \\quad w_j \\ge 0 \\; \\text{for } j = 1, \\ldots, M\n$$\nHere, $M=5$ is the number of codon sets. The matrix $A \\in \\mathbb{R}^{20 \\times M}$ contains the amino acid frequency profiles for each codon set, the vector $\\mathbf{s} \\in \\mathbb{R}^M$ contains the corresponding stop codon frequencies, $\\mathbf{p} \\in \\mathbb{R}^{20}$ is the target amino acid distribution, and $\\lambda \\in \\mathbb{R}_{\\ge 0}$ is a scalar penalty parameter for the stop codon frequency.\n\nThe solution process consists of three main steps:\n1.  Construction of the amino acid frequency matrix $A$ and the stop frequency vector $\\mathbf{s}$.\n2.  Numerical solution of the constrained QP for each test case.\n3.  Calculation of the final metrics: expected stop fraction and Root Mean Squared Error (RMSE).\n\n**Step 1: Construction of Matrix $A$ and Vector $\\mathbf{s}$**\n\nThe components of $A=[\\mathbf{a}_1, \\dots, \\mathbf{a}_M]$ and $\\mathbf{s}=[s_1, \\dots, s_M]^\\top$ must be determined from first principles. This requires enumerating all possible concrete codons for each of the $M=5$ given degenerate codon sets: $[NNK, NNS, NDT, VHG, TGG]$.\n\nThe nucleotide possibilities for each IUPAC code are:\n- $N: \\{A, C, G, T\\}$ (size $4$)\n- $K: \\{G, T\\}$ (size $2$)\n- $S: \\{G, C\\}$ (size $2$)\n- $D: \\{A, G, T\\}$ (size $3$)\n- $V: \\{A, C, G\\}$ (size $3$)\n- $H: \\{A, C, T\\}$ (size $3$)\n- $A, C, G, T$: represent themselves (size $1$)\n\nFor each degenerate codon set $j$, we generate all possible three-nucleotide codons. For example, for $NNK$, the number of distinct codons is $4 \\times 4 \\times 2 = 32$. We assume each of these concrete codons is sampled with uniform probability, i.e., $1/32$.\n\nEach concrete codon is then mapped to one of the $20$ standard amino acids or a stop signal using the standard genetic code. The amino acid order for all vectors is fixed as $[A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y]$.\n\nThe $i$-th element of the column vector $\\mathbf{a}_j$, denoted $(\\mathbf{a}_j)_i$, is the frequency of the $i$-th amino acid in the mixture produced by codon set $j$. This is calculated as the number of codons in set $j$ that code for amino acid $i$, divided by the total number of codons in set $j$. Similarly, the stop frequency $s_j$ is the fraction of codons in set $j$ that are stop codons.\n\nThis enumeration is performed for all $M=5$ codon sets to populate the $20 \\times 5$ matrix $A$ and the $5$-dimensional vector $\\mathbf{s}$.\n\n**Step 2: Solving the Quadratic Program**\n\nThe objective function can be expanded into the standard QP form. Let's rewrite the objective function $f(\\mathbf{w})$:\n$$\nf(\\mathbf{w}) = \\frac{1}{2}(A\\mathbf{w} - \\mathbf{p})^\\top(A\\mathbf{w} - \\mathbf{p}) + \\lambda \\mathbf{s}^\\top \\mathbf{w} = \\frac{1}{2}\\mathbf{w}^\\top (A^\\top A) \\mathbf{w} - (\\mathbf{p}^\\top A - \\lambda \\mathbf{s}^\\top)\\mathbf{w} + \\frac{1}{2}\\mathbf{p}^\\top\\mathbf{p}\n$$\nIgnoring the constant term $\\frac{1}{2}\\mathbf{p}^\\top\\mathbf{p}$ which does not affect the minimum's location, the problem is to minimize:\n$$\n\\min_{\\mathbf{w}} \\; \\frac{1}{2}\\mathbf{w}^\\top Q \\mathbf{w} + \\mathbf{c}^\\top \\mathbf{w}\n$$\nwhere $Q = A^\\top A$ is a positive semidefinite matrix, and $\\mathbf{c} = -A^\\top \\mathbf{p} + \\lambda \\mathbf{s}$. The constraints are a linear equality, $\\mathbf{1}^\\top \\mathbf{w} = 1$, and nonnegativity bounds, $w_j \\ge 0$.\n\nThis formulation represents a convex QP, which guarantees that a global minimum exists and can be found efficiently using numerical optimization algorithms. The implementation will use the Sequential Least Squares Programming (SLSQP) method, available in the `scipy.optimize.minimize` library function. This solver requires the objective function, its gradient (Jacobian), and a specification of the constraints and bounds.\n\nThe gradient of the objective function with respect to $\\mathbf{w}$ is:\n$$\n\\nabla_{\\mathbf{w}} f(\\mathbf{w}) = A^\\top(A\\mathbf{w} - \\mathbf{p}) + \\lambda \\mathbf{s}\n$$\nProviding this analytical gradient to the solver improves its accuracy and convergence speed.\n\n**Step 3: Processing Test Cases and Calculating Metrics**\n\nFor each of the four test cases, we define the specific target distribution vector $\\mathbf{p}$ and the penalty parameter $\\lambda$. With $A$ and $\\mathbf{s}$ pre-computed, we execute the SLSQP solver to find the optimal weight vector $\\mathbf{w}_{\\text{opt}}$.\n\nOnce $\\mathbf{w}_{\\text{opt}}$ is found, the required output metrics are calculated:\n1.  The optimal weights $\\mathbf{w}_{\\text{opt}} = [w_1, \\dots, w_5]^\\top$.\n2.  The expected stop fraction: $\\mathbf{s}^\\top \\mathbf{w}_{\\text{opt}}$.\n3.  The Root Mean Squared Error (RMSE) between the resulting amino acid distribution $A\\mathbf{w}_{\\text{opt}}$ and the target $\\mathbf{p}$:\n    $$\n    \\text{RMSE} = \\sqrt{\\frac{1}{20}\\sum_{i=1}^{20} ( (A\\mathbf{w}_{\\text{opt}})_i - p_i )^2} = \\frac{1}{\\sqrt{20}}\\lVert A\\mathbf{w}_{\\text{opt}} - \\mathbf{p} \\rVert_2\n    $$\nThe final program implements this entire procedure, computing $A$ and $\\mathbf{s}$, then iterating through each test case to solve the corresponding QP and report the specified results, formatted as required.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    # Define fundamental biological and problem-specific data\n    IUPAC_CODES = {\n        'A': ['A'], 'C': ['C'], 'G': ['G'], 'T': ['T'],\n        'N': ['A', 'C', 'G', 'T'], # any\n        'K': ['G', 'T'],           # keto\n        'S': ['G', 'C'],           # strong\n        'D': ['A', 'G', 'T'],      # not C\n        'V': ['A', 'C', 'G'],      # not T\n        'H': ['A', 'C', 'T'],      # not G\n    }\n\n    GENETIC_CODE = {\n        'AAA': 'K', 'AAC': 'N', 'AAG': 'K', 'AAT': 'N',\n        'ACA': 'T', 'ACC': 'T', 'ACG': 'T', 'ACT': 'T',\n        'AGA': 'R', 'AGC': 'S', 'AGG': 'R', 'AGT': 'S',\n        'ATA': 'I', 'ATC': 'I', 'ATG': 'M', 'ATT': 'I',\n        'CAA': 'Q', 'CAC': 'H', 'CAG': 'Q', 'CAT': 'H',\n        'CCA': 'P', 'CCC': 'P', 'CCG': 'P', 'CCT': 'P',\n        'CGA': 'R', 'CGC': 'R', 'CGG': 'R', 'CGT': 'R',\n        'CTA': 'L', 'CTC': 'L', 'CTG': 'L', 'CTT': 'L',\n        'GAA': 'E', 'GAC': 'D', 'GAG': 'E', 'GAT': 'D',\n        'GCA': 'A', 'GCC': 'A', 'GCG': 'A', 'GCT': 'A',\n        'GGA': 'G', 'GGC': 'G', 'GGG': 'G', 'GGT': 'G',\n        'GTA': 'V', 'GTC': 'V', 'GTG': 'V', 'GTT': 'V',\n        'TAA': '*', 'TAC': 'Y', 'TAG': '*', 'TAT': 'Y',\n        'TCA': 'S', 'TCC': 'S', 'TCG': 'S', 'TCT': 'S',\n        'TGA': '*', 'TGC': 'C', 'TGG': 'W', 'TGT': 'C',\n        'TTA': 'L', 'TTC': 'F', 'TTG': 'L', 'TTT': 'F'\n    }\n\n    AA_ORDER = ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y']\n    CODON_SETS = ['NNK', 'NNS', 'NDT', 'VHG', 'TGG']\n    \n    NUM_AA = len(AA_ORDER)\n    NUM_SETS = len(CODON_SETS)\n    AA_MAP = {aa: i for i, aa in enumerate(AA_ORDER)}\n\n    # Step 1: Construct A and s\n    A = np.zeros((NUM_AA, NUM_SETS))\n    s = np.zeros(NUM_SETS)\n\n    for j, c_set in enumerate(CODON_SETS):\n        b1_options, b2_options, b3_options = IUPAC_CODES[c_set[0]], IUPAC_CODES[c_set[1]], IUPAC_CODES[c_set[2]]\n        total_codons = len(b1_options) * len(b2_options) * len(b3_options)\n        \n        aa_counts = {aa: 0 for aa in AA_ORDER}\n        stop_count = 0\n        \n        for b1 in b1_options:\n            for b2 in b2_options:\n                for b3 in b3_options:\n                    codon = b1 + b2 + b3\n                    translation = GENETIC_CODE.get(codon, '?')\n                    if translation == '*':\n                        stop_count += 1\n                    elif translation in AA_MAP:\n                        aa_counts[translation] += 1\n        \n        if total_codons  0:\n            for aa, i in AA_MAP.items():\n                A[i, j] = aa_counts[aa] / total_codons\n            s[j] = stop_count / total_codons\n\n    # Define test cases\n    p1 = np.full(NUM_AA, 1.0 / NUM_AA)\n    lambda1 = 0.1\n\n    p2 = np.full(NUM_AA, 0.25 / 17.0)\n    p2[AA_MAP['L']] = 0.35\n    p2[AA_MAP['I']] = 0.25\n    p2[AA_MAP['V']] = 0.15\n    lambda2 = 0.05\n\n    p3 = np.zeros(NUM_AA)\n    p3[AA_MAP['W']] = 1.0\n    lambda3 = 0.0\n\n    p4 = np.full(NUM_AA, 1.0 / NUM_AA)\n    lambda4 = 1000.0\n\n    test_cases = [ (p1, lambda1), (p2, lambda2), (p3, lambda3), (p4, lambda4) ]\n    \n    all_results = []\n\n    for p, lambda_val in test_cases:\n        # Step 2: Define optimization problem for scipy\n        def objective_func(w):\n            return 0.5 * np.sum((A @ w - p)**2) + lambda_val * (s @ w)\n\n        def jacobian_func(w):\n            return A.T @ (A @ w - p) + lambda_val * s\n        \n        constraints = ({'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0})\n        bounds = tuple([(0.0, None) for _ in range(NUM_SETS)])\n        w_init = np.full(NUM_SETS, 1.0 / NUM_SETS)\n\n        # Solve the QP\n        res = minimize(\n            objective_func,\n            w_init,\n            method='SLSQP',\n            jac=jacobian_func,\n            bounds=bounds,\n            constraints=constraints,\n            tol=1e-12\n        )\n        w_opt = res.x\n        \n        # Ensure non-negativity from floating point artifacts\n        w_opt[w_opt  0] = 0\n        w_opt = w_opt / np.sum(w_opt)\n\n        # Step 3: Calculate metrics\n        stop_frac = s @ w_opt\n        rmse = np.sqrt(np.mean((A @ w_opt - p)**2))\n        \n        case_results = list(w_opt) + [stop_frac, rmse]\n        formatted_results = [f\"{x:.6f}\" for x in case_results]\n        all_results.append(f\"[{','.join(formatted_results)}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}