{
    "hands_on_practices": [
        {
            "introduction": "To effectively apply hybrid QM/MM methods, it's crucial to understand how the total energy is partitioned and how different embedding schemes treat the interactions between the QM and MM regions. This exercise provides a foundational, hands-on opportunity to implement the core energy components—electrostatic, van der Waals, and bonded terms—for both mechanical and electrostatic embedding. By coding these terms from first principles for a simple system, you will gain a concrete understanding of their origins in the QM/MM Hamiltonian. ",
            "id": "3849241",
            "problem": "You are tasked with constructing, from first principles, a computational decomposition of hybrid Quantum Mechanics/Molecular Mechanics (QM/MM) interaction energy for a minimal solute–solvent system using two embedding schemes: mechanical embedding and electrostatic embedding. The system consists of a single Quantum Mechanics (QM) atom and two Molecular Mechanics (MM) atoms, one of which is directly bonded across the QM/MM boundary. Your program must separate the hybrid energy $E_{\\mathrm{QM/MM}}$ into electrostatic, van der Waals, and bonded terms and must explicitly demonstrate how each term arises from the underlying Hamiltonian.\n\nBegin from foundational laws and definitions that are standard in computational chemical biology:\n- The Born–Oppenheimer approximation, which separates electronic and nuclear motion, yielding a Molecular Mechanics (MM) force-field description for nuclei and an electronic Hamiltonian for electrons in the Quantum Mechanics (QM) region.\n- The classical electrostatic interaction derived from Coulomb’s law, with potential energy $E_{\\mathrm{Coul}} = k_{e}\\sum_{i<j}\\dfrac{q_{i}q_{j}}{r_{ij}}$, where $k_e$ is the Coulomb constant in compatible units.\n- The Lennard–Jones (LJ) $12$–$6$ potential for van der Waals interactions, given by $E_{\\mathrm{LJ}}(i,j) = 4\\epsilon_{ij}\\left[\\left(\\dfrac{\\sigma_{ij}}{r_{ij}}\\right)^{12}-\\left(\\dfrac{\\sigma_{ij}}{r_{ij}}\\right)^{6}\\right]$, with Lorentz–Berthelot mixing rules $\\sigma_{ij} = \\dfrac{\\sigma_{i}+\\sigma_{j}}{2}$ and $\\epsilon_{ij} = \\sqrt{\\epsilon_{i}\\epsilon_{j}}$.\n- The harmonic bonded potential $E_{\\mathrm{bond}} = \\dfrac{1}{2}k_{\\mathrm{b}}(r-r_{0})^{2}$ for a bond that crosses the QM/MM boundary, together with a link-atom capping treatment in the QM model to maintain valence at the boundary.\n\nYou must show how the interaction energy components originate from the underlying Hamiltonian:\n- For mechanical embedding, the QM Hamiltonian is evaluated in vacuum for the model system (QM region plus link atom), while cross-region interactions are accounted for by the MM force field. In the subtractive ONIOM-like mechanical scheme, the hybrid energy partitions into MM terms such that cross-region electrostatics and van der Waals arise from classical potentials, and the boundary bond correction is a difference of harmonic terms across the real and model systems.\n- For electrostatic embedding, the QM Hamiltonian includes the external field of MM point charges, leading to an additional electrostatic interaction between MM charges and the QM electron density and nuclei. In this problem, approximate the expectation of the QM–MM electrostatic interaction by an effective QM atomic charge $q_{\\mathrm{A}}^{\\mathrm{eff}}$ localized on the QM atom.\n\nScientific realism constraints:\n- Use the Coulomb constant $k_{e} = 138.935456$ in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}\\,\\mathrm{e}^{-2}$.\n- Distances must be in $\\mathrm{nm}$.\n- LJ $\\epsilon$ must be in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ and $\\sigma$ in $\\mathrm{nm}$.\n- Charges must be in units of elementary charge $\\mathrm{e}$.\n- Bond force constants $k_{\\mathrm{b}}$ must be in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$ and equilibrium bond lengths $r_{0}$ in $\\mathrm{nm}$.\n- Energies must be reported in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$.\n\nDefinitions of the quantities to compute:\n- Mechanical embedding electrostatic interaction:\n$$\nE_{\\mathrm{elec}}^{\\mathrm{mech}} = k_{e}\\,q_{\\mathrm{A}}^{\\mathrm{MM}}\\left(\\frac{q_{\\mathrm{B}}}{r_{\\mathrm{AB}}} + \\frac{q_{\\mathrm{C}}}{r_{\\mathrm{AC}}}\\right),\n$$\nwhere $q_{\\mathrm{A}}^{\\mathrm{MM}}$ is the fixed MM charge assigned to the QM atom for mechanical embedding, and $q_{\\mathrm{B}}, q_{\\mathrm{C}}$ are MM atom charges.\n- Electrostatic embedding electrostatic interaction (approximated by an effective QM point charge):\n$$\nE_{\\mathrm{elec}}^{\\mathrm{EE}} = k_{e}\\,q_{\\mathrm{A}}^{\\mathrm{eff}}\\left(\\frac{q_{\\mathrm{B}}}{r_{\\mathrm{AB}}} + \\frac{q_{\\mathrm{C}}}{r_{\\mathrm{AC}}}\\right),\n$$\nwhere $q_{\\mathrm{A}}^{\\mathrm{eff}}$ approximates the QM atom’s net effective charge including electronic polarization.\n- Van der Waals interaction (nonbonded only; exclude directly bonded neighbors):\n$$\nE_{\\mathrm{vdW}} = E_{\\mathrm{LJ}}(\\mathrm{A},\\mathrm{C}) = 4\\,\\epsilon_{\\mathrm{AC}}\\left[\\left(\\frac{\\sigma_{\\mathrm{AC}}}{r_{\\mathrm{AC}}}\\right)^{12}-\\left(\\frac{\\sigma_{\\mathrm{AC}}}{r_{\\mathrm{AC}}}\\right)^{6}\\right],\n$$\nwith $\\sigma_{\\mathrm{AC}} = \\dfrac{\\sigma_{\\mathrm{A}}+\\sigma_{\\mathrm{C}}}{2}$ and $\\epsilon_{\\mathrm{AC}} = \\sqrt{\\epsilon_{\\mathrm{A}}\\epsilon_{\\mathrm{C}}}$.\n- Bonded cross-boundary correction via the link-atom subtractive scheme:\n$$\nE_{\\mathrm{bond}} = \\frac{1}{2}k_{\\mathrm{b}}^{\\mathrm{real}}\\left(r_{\\mathrm{AB}}-r_{0}^{\\mathrm{real}}\\right)^{2} - \\frac{1}{2}k_{\\mathrm{b}}^{\\mathrm{link}}\\left(r_{\\mathrm{AL}}-r_{0}^{\\mathrm{link}}\\right)^{2}.\n$$\nFor electrostatic embedding, use the same $E_{\\mathrm{bond}}$ as in mechanical embedding.\n\nYour program must implement the above expressions and return, for each test case, a list of six floats in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ ordered as $[E_{\\mathrm{elec}}^{\\mathrm{mech}}, E_{\\mathrm{vdW}}^{\\mathrm{mech}}, E_{\\mathrm{bond}}^{\\mathrm{mech}}, E_{\\mathrm{elec}}^{\\mathrm{EE}}, E_{\\mathrm{vdW}}^{\\mathrm{EE}}, E_{\\mathrm{bond}}^{\\mathrm{EE}}]$.\n\nTest suite to use:\n- Test case $1$ (general case; nonzero electrostatics, modest van der Waals, nonzero bond correction):\n    - Charges: $q_{\\mathrm{A}}^{\\mathrm{MM}} = -0.3$, $q_{\\mathrm{A}}^{\\mathrm{eff}} = -0.5$, $q_{\\mathrm{B}} = +0.4$, $q_{\\mathrm{C}} = -0.2$.\n    - Distances: $r_{\\mathrm{AB}} = 0.16\\,\\mathrm{nm}$, $r_{\\mathrm{AC}} = 0.50\\,\\mathrm{nm}$, $r_{\\mathrm{AL}} = 0.105\\,\\mathrm{nm}$.\n    - LJ parameters: $\\sigma_{\\mathrm{A}} = 0.32\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{A}} = 0.5\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$; $\\sigma_{\\mathrm{B}} = 0.34\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{B}} = 0.8\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$; $\\sigma_{\\mathrm{C}} = 0.30\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{C}} = 0.4\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$; link atom parameters may be provided but are not used in nonbonded interactions.\n    - Bond parameters: $k_{\\mathrm{b}}^{\\mathrm{real}} = 1000\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$, $r_{0}^{\\mathrm{real}} = 0.15\\,\\mathrm{nm}$; $k_{\\mathrm{b}}^{\\mathrm{link}} = 700\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$, $r_{0}^{\\mathrm{link}} = 0.105\\,\\mathrm{nm}$.\n- Test case $2$ (edge case; zero charges, only van der Waals and bonded terms contribute):\n    - Charges: $q_{\\mathrm{A}}^{\\mathrm{MM}} = 0.0$, $q_{\\mathrm{A}}^{\\mathrm{eff}} = 0.0$, $q_{\\mathrm{B}} = 0.0$, $q_{\\mathrm{C}} = 0.0$.\n    - Distances: $r_{\\mathrm{AB}} = 0.15\\,\\mathrm{nm}$, $r_{\\mathrm{AC}} = 0.40\\,\\mathrm{nm}$, $r_{\\mathrm{AL}} = 0.108\\,\\mathrm{nm}$.\n    - LJ parameters: $\\sigma_{\\mathrm{A}} = 0.31\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{A}} = 0.45\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$; $\\sigma_{\\mathrm{B}} = 0.33\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{B}} = 0.50\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$; $\\sigma_{\\mathrm{C}} = 0.29\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{C}} = 0.35\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$.\n    - Bond parameters: $k_{\\mathrm{b}}^{\\mathrm{real}} = 900\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$, $r_{0}^{\\mathrm{real}} = 0.15\\,\\mathrm{nm}$; $k_{\\mathrm{b}}^{\\mathrm{link}} = 850\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$, $r_{0}^{\\mathrm{link}} = 0.108\\,\\mathrm{nm}$.\n- Test case $3$ (strong electrostatic interaction and stretched boundary bond):\n    - Charges: $q_{\\mathrm{A}}^{\\mathrm{MM}} = -1.0$, $q_{\\mathrm{A}}^{\\mathrm{eff}} = -0.8$, $q_{\\mathrm{B}} = +1.0$, $q_{\\mathrm{C}} = +0.5$.\n    - Distances: $r_{\\mathrm{AB}} = 0.20\\,\\mathrm{nm}$, $r_{\\mathrm{AC}} = 0.45\\,\\mathrm{nm}$, $r_{\\mathrm{AL}} = 0.110\\,\\mathrm{nm}$.\n    - LJ parameters: $\\sigma_{\\mathrm{A}} = 0.35\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{A}} = 1.2\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$; $\\sigma_{\\mathrm{B}} = 0.36\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{B}} = 1.0\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$; $\\sigma_{\\mathrm{C}} = 0.33\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{C}} = 0.9\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$.\n    - Bond parameters: $k_{\\mathrm{b}}^{\\mathrm{real}} = 1200\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$, $r_{0}^{\\mathrm{real}} = 0.145\\,\\mathrm{nm}$; $k_{\\mathrm{b}}^{\\mathrm{link}} = 800\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$, $r_{0}^{\\mathrm{link}} = 0.106\\,\\mathrm{nm}$.\n\nAlgorithmic requirements:\n- Implement the above formulas exactly.\n- Exclude van der Waals interactions for directly bonded neighbors; include only the nonbonded pair $\\mathrm{A}$–$\\mathrm{C}$.\n- Express all energies in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ and round each reported float to $6$ decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets, for example, $\\left[[x_{1},x_{2},x_{3},x_{4},x_{5},x_{6}],[\\ldots],[\\ldots]\\right]$, where each inner list corresponds to one test case ordered as $[E_{\\mathrm{elec}}^{\\mathrm{mech}}, E_{\\mathrm{vdW}}^{\\mathrm{mech}}, E_{\\mathrm{bond}}^{\\mathrm{mech}}, E_{\\mathrm{elec}}^{\\mathrm{EE}}, E_{\\mathrm{vdW}}^{\\mathrm{EE}}, E_{\\mathrm{bond}}^{\\mathrm{EE}}]$ in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$.",
            "solution": "We begin from the hybrid Quantum Mechanics/Molecular Mechanics (QM/MM) framework under the Born–Oppenheimer approximation, which separates electronic and nuclear degrees of freedom. The total Hamiltonian for a system partitioned into a Quantum Mechanics (QM) region and a Molecular Mechanics (MM) region can be expressed schematically as\n$$\n\\hat{H}_{\\mathrm{tot}} = \\hat{H}_{\\mathrm{QM}} + U_{\\mathrm{MM}} + \\hat{H}_{\\mathrm{int}},\n$$\nwhere $\\hat{H}_{\\mathrm{QM}}$ is the electronic Hamiltonian of the QM region (with clamped nuclei), $U_{\\mathrm{MM}}$ is the classical force-field potential of the MM region (including bonded and nonbonded terms), and $\\hat{H}_{\\mathrm{int}}$ represents coupling across the boundary. The energy decomposition we seek must trace directly to these terms.\n\nFor the QM region, the standard nonrelativistic electronic Hamiltonian is\n$$\n\\hat{H}_{\\mathrm{QM}} = \\hat{T}_{e} + \\hat{V}_{ee} + \\hat{V}_{eN} + V_{NN},\n$$\nwhere $\\hat{T}_{e}$ is the kinetic energy of electrons, $\\hat{V}_{ee}$ is electron–electron Coulomb repulsion, $\\hat{V}_{eN}$ is electron–nuclear attraction, and $V_{NN}$ is nuclear–nuclear Coulomb repulsion. Within the hybrid scheme, the MM region is described by a classical potential\n$$\nU_{\\mathrm{MM}} = \n\\sum_{\\mathrm{bonds}}\\frac{1}{2}k_{\\mathrm{b}}(r-r_{0})^{2}\n+\n\\sum_{\\mathrm{angles}}k_{\\theta}(\\theta-\\theta_{0})^{2}\n+\n\\sum_{\\mathrm{dihedrals}}U_{\\phi}(\\phi)\n+\n\\sum_{i<j}\\left[4\\epsilon_{ij}\\left(\\left(\\frac{\\sigma_{ij}}{r_{ij}}\\right)^{12}-\\left(\\frac{\\sigma_{ij}}{r_{ij}}\\right)^{6}\\right) + k_{e}\\frac{q_{i}q_{j}}{r_{ij}}\\right].\n$$\nFor our minimal system, angles and dihedrals are not required; only a single boundary bond and nonbonded interactions are considered. We focus on cross-region terms that contribute to $E_{\\mathrm{QM/MM}}$.\n\nIn mechanical embedding, the interaction Hamiltonian $\\hat{H}_{\\mathrm{int}}$ does not enter the Quantum Mechanics (QM) Hamiltonian; the QM calculation is performed in vacuum for the model system (the QM region with a link atom capping the boundary), while interactions with the Molecular Mechanics (MM) region are treated by the classical force field. In a subtractive ONIOM-like mechanical scheme, the energy partition is\n$$\nE_{\\mathrm{hybrid}}^{\\mathrm{mech}} = E_{\\mathrm{QM}}(\\mathrm{model}) + U_{\\mathrm{MM}}(\\mathrm{real}) - U_{\\mathrm{MM}}(\\mathrm{model}).\n$$\nThe cross-region bonded correction arises from the difference between the real boundary bond and the link-atom bond in the model system, yielding\n$$\nE_{\\mathrm{bond}} = \\frac{1}{2}k_{\\mathrm{b}}^{\\mathrm{real}}\\left(r_{\\mathrm{AB}}-r_{0}^{\\mathrm{real}}\\right)^{2} - \\frac{1}{2}k_{\\mathrm{b}}^{\\mathrm{link}}\\left(r_{\\mathrm{AL}}-r_{0}^{\\mathrm{link}}\\right)^{2}.\n$$\nNonbonded cross interactions are accounted by the MM potential, separating into electrostatics and van der Waals components. The mechanical embedding electrostatics uses fixed MM charges for both QM and MM atoms:\n$$\nE_{\\mathrm{elec}}^{\\mathrm{mech}} = k_{e}\\sum_{J\\in \\mathrm{QM}}\\sum_{K\\in \\mathrm{MM}}\\frac{q_{J}^{\\mathrm{MM}}\\,q_{K}}{r_{JK}}.\n$$\nFor our one–QM–atom setup, this reduces to\n$$\nE_{\\mathrm{elec}}^{\\mathrm{mech}} = k_{e}\\,q_{\\mathrm{A}}^{\\mathrm{MM}}\\left(\\frac{q_{\\mathrm{B}}}{r_{\\mathrm{AB}}} + \\frac{q_{\\mathrm{C}}}{r_{\\mathrm{AC}}}\\right).\n$$\nThe van der Waals interaction uses the Lennard–Jones $12$–$6$ potential with Lorentz–Berthelot mixing rules for cross pairs, and we exclude directly bonded neighbors:\n$$\nE_{\\mathrm{vdW}} = E_{\\mathrm{LJ}}(\\mathrm{A},\\mathrm{C}) = 4\\,\\epsilon_{\\mathrm{AC}}\\left[\\left(\\frac{\\sigma_{\\mathrm{AC}}}{r_{\\mathrm{AC}}}\\right)^{12}-\\left(\\frac{\\sigma_{\\mathrm{AC}}}{r_{\\mathrm{AC}}}\\right)^{6}\\right],\\quad \\sigma_{\\mathrm{AC}} = \\frac{\\sigma_{\\mathrm{A}}+\\sigma_{\\mathrm{C}}}{2},\\quad \\epsilon_{\\mathrm{AC}} = \\sqrt{\\epsilon_{\\mathrm{A}}\\epsilon_{\\mathrm{C}}}.\n$$\n\nIn electrostatic embedding, the interaction Hamiltonian adds an external potential to the QM Hamiltonian due to MM point charges. The added term is\n$$\n\\hat{V}_{\\mathrm{ext}} = \\sum_{i\\in e}\\sum_{K\\in \\mathrm{MM}} \\frac{q_{K}}{4\\pi\\epsilon_{0}} \\frac{1}{\\lvert \\mathbf{r}_{i}-\\mathbf{R}_{K}\\rvert} - \\sum_{I\\in N}\\sum_{K\\in \\mathrm{MM}} \\frac{Z_{I}q_{K}}{4\\pi\\epsilon_{0}} \\frac{1}{\\lvert \\mathbf{R}_{I}-\\mathbf{R}_{K}\\rvert},\n$$\nand its expectation over the QM electron density $\\rho_{e}(\\mathbf{r})$ and point nuclei yields the QM–MM electrostatic energy contribution\n$$\nE_{\\mathrm{elec}}^{\\mathrm{EE}} = \\int \\rho_{e}(\\mathbf{r})\\,\\phi_{\\mathrm{MM}}(\\mathbf{r})\\,\\mathrm{d}\\mathbf{r} - \\sum_{I} Z_{I}\\,\\phi_{\\mathrm{MM}}(\\mathbf{R}_{I}),\n$$\nwhere $\\phi_{\\mathrm{MM}}$ is the MM electrostatic potential. In this problem, we are instructed to approximate this expectation by an effective QM atomic charge $q_{\\mathrm{A}}^{\\mathrm{eff}}$ placed on the QM atom, leading to the computable expression\n$$\nE_{\\mathrm{elec}}^{\\mathrm{EE}} = k_{e}\\,q_{\\mathrm{A}}^{\\mathrm{eff}}\\left(\\frac{q_{\\mathrm{B}}}{r_{\\mathrm{AB}}} + \\frac{q_{\\mathrm{C}}}{r_{\\mathrm{AC}}}\\right).\n$$\nThe van der Waals and bonded terms under electrostatic embedding are treated identically to mechanical embedding within the MM description used here:\n$$\nE_{\\mathrm{vdW}}^{\\mathrm{EE}} = E_{\\mathrm{vdW}}^{\\mathrm{mech}},\\qquad E_{\\mathrm{bond}}^{\\mathrm{EE}} = E_{\\mathrm{bond}}^{\\mathrm{mech}}.\n$$\n\nUnit consistency is ensured by adopting $k_{e} = 138.935456$ in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}\\,\\mathrm{e}^{-2}$, distances in $\\mathrm{nm}$, charges in $\\mathrm{e}$, LJ $\\epsilon$ in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$, $\\sigma$ in $\\mathrm{nm}$, and bond parameters in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$ and $\\mathrm{nm}$. The computed energies therefore directly yield $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$.\n\nAlgorithmic implementation for each test case:\n1. Read $q_{\\mathrm{A}}^{\\mathrm{MM}}$, $q_{\\mathrm{A}}^{\\mathrm{eff}}$, $q_{\\mathrm{B}}$, $q_{\\mathrm{C}}$; $r_{\\mathrm{AB}}$, $r_{\\mathrm{AC}}$, $r_{\\mathrm{AL}}$; $\\sigma_{\\mathrm{A}}$, $\\epsilon_{\\mathrm{A}}$, $\\sigma_{\\mathrm{C}}$, $\\epsilon_{\\mathrm{C}}$; $k_{\\mathrm{b}}^{\\mathrm{real}}$, $r_{0}^{\\mathrm{real}}$, $k_{\\mathrm{b}}^{\\mathrm{link}}$, $r_{0}^{\\mathrm{link}}$; and $k_{e}$.\n2. Compute $E_{\\mathrm{elec}}^{\\mathrm{mech}}$ and $E_{\\mathrm{elec}}^{\\mathrm{EE}}$ using the respective formulas.\n3. Compute $\\sigma_{\\mathrm{AC}}$ and $\\epsilon_{\\mathrm{AC}}$ via Lorentz–Berthelot mixing and then $E_{\\mathrm{vdW}}$ via the Lennard–Jones $12$–$6$ expression.\n4. Compute $E_{\\mathrm{bond}}$ via the difference of harmonic terms across the boundary bond and the link bond.\n5. Report the ordered list $[E_{\\mathrm{elec}}^{\\mathrm{mech}}, E_{\\mathrm{vdW}}^{\\mathrm{mech}}, E_{\\mathrm{bond}}^{\\mathrm{mech}}, E_{\\mathrm{elec}}^{\\mathrm{EE}}, E_{\\mathrm{vdW}}^{\\mathrm{EE}}, E_{\\mathrm{bond}}^{\\mathrm{EE}}]$ per test case, rounded to $6$ decimal places.\n\nQualitative expectations for the test suite:\n- Test case $1$ should show a sizable negative electrostatic energy due to opposite signs of $q_{\\mathrm{A}}^{\\mathrm{MM}}$ and $q_{\\mathrm{B}}$, a small attractive van der Waals energy for the nonbonded pair, and a small positive bonded correction due to slight bond elongation from equilibrium. Electrostatic embedding should yield a more negative electrostatic energy than mechanical embedding because $q_{\\mathrm{A}}^{\\mathrm{eff}}$ is more negative than $q_{\\mathrm{A}}^{\\mathrm{MM}}$.\n- Test case $2$ should yield zero electrostatic energy under both embeddings, with only van der Waals and bonded contributions (the latter being zero if both bonds are exactly at equilibrium).\n- Test case $3$ should display strong attractive electrostatics and a significant positive bonded correction due to a stretched cross-boundary bond; electrostatic embedding should weaken the magnitude of attraction compared to mechanical embedding because $q_{\\mathrm{A}}^{\\mathrm{eff}}$ is less negative than $q_{\\mathrm{A}}^{\\mathrm{MM}}$.\n\nThe final program must compute these quantities in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ and produce a single line of output containing the three inner lists of six floats, rounded to $6$ decimals, enclosed in square brackets.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lj_energy(eps_i, sig_i, eps_j, sig_j, r_ij):\n    \"\"\"\n    Compute Lennard-Jones 12-6 energy using Lorentz-Berthelot mixing.\n    eps in kJ/mol, sigma in nm, r_ij in nm.\n    Returns energy in kJ/mol.\n    \"\"\"\n    # Lorentz-Berthelot mixing rules\n    sigma_ij = 0.5 * (sig_i + sig_j)\n    epsilon_ij = np.sqrt(eps_i * eps_j)\n    sr = sigma_ij / r_ij\n    sr6 = sr ** 6\n    sr12 = sr6 ** 2\n    return 4.0 * epsilon_ij * (sr12 - sr6)\n\ndef coulomb_energy(ke, qA, qB, qC, rAB, rAC):\n    \"\"\"\n    Compute electrostatic energy for one QM atom A interacting with two MM atoms B and C.\n    ke in kJ mol^-1 nm e^-2, charges in e, distances in nm.\n    Returns energy in kJ/mol.\n    \"\"\"\n    return ke * qA * (qB / rAB + qC / rAC)\n\ndef bonded_cross_energy(kb_real, rAB, r0_real, kb_link, rAL, r0_link):\n    \"\"\"\n    Compute cross-boundary bonded correction via subtractive scheme:\n    E_bond = 0.5*kb_real*(rAB - r0_real)^2 - 0.5*kb_link*(rAL - r0_link)^2\n    kb in kJ mol^-1 nm^-2, distances in nm.\n    Returns energy in kJ/mol.\n    \"\"\"\n    e_real = 0.5 * kb_real * (rAB - r0_real) ** 2\n    e_link = 0.5 * kb_link * (rAL - r0_link) ** 2\n    return e_real - e_link\n\ndef solve():\n    # Coulomb constant in kJ mol^-1 nm e^-2\n    ke = 138.935456\n\n    # Define the test cases from the problem statement.\n    # Each test case is a dictionary of parameters.\n    test_cases = [\n        {\n            # Test case 1\n            \"charges\": {\"qA_MM\": -0.3, \"qA_eff\": -0.5, \"qB\": +0.4, \"qC\": -0.2},\n            \"distances\": {\"rAB\": 0.16, \"rAC\": 0.50, \"rAL\": 0.105},\n            \"lj\": {\"sigma_A\": 0.32, \"epsilon_A\": 0.5, \"sigma_C\": 0.30, \"epsilon_C\": 0.4},\n            \"bond\": {\"kb_real\": 1000.0, \"r0_real\": 0.15, \"kb_link\": 700.0, \"r0_link\": 0.105}\n        },\n        {\n            # Test case 2\n            \"charges\": {\"qA_MM\": 0.0, \"qA_eff\": 0.0, \"qB\": 0.0, \"qC\": 0.0},\n            \"distances\": {\"rAB\": 0.15, \"rAC\": 0.40, \"rAL\": 0.108},\n            \"lj\": {\"sigma_A\": 0.31, \"epsilon_A\": 0.45, \"sigma_C\": 0.29, \"epsilon_C\": 0.35},\n            \"bond\": {\"kb_real\": 900.0, \"r0_real\": 0.15, \"kb_link\": 850.0, \"r0_link\": 0.108}\n        },\n        {\n            # Test case 3\n            \"charges\": {\"qA_MM\": -1.0, \"qA_eff\": -0.8, \"qB\": +1.0, \"qC\": +0.5},\n            \"distances\": {\"rAB\": 0.20, \"rAC\": 0.45, \"rAL\": 0.110},\n            \"lj\": {\"sigma_A\": 0.35, \"epsilon_A\": 1.2, \"sigma_C\": 0.33, \"epsilon_C\": 0.9},\n            \"bond\": {\"kb_real\": 1200.0, \"r0_real\": 0.145, \"kb_link\": 800.0, \"r0_link\": 0.106}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        qA_MM = case[\"charges\"][\"qA_MM\"]\n        qA_eff = case[\"charges\"][\"qA_eff\"]\n        qB = case[\"charges\"][\"qB\"]\n        qC = case[\"charges\"][\"qC\"]\n\n        rAB = case[\"distances\"][\"rAB\"]\n        rAC = case[\"distances\"][\"rAC\"]\n        rAL = case[\"distances\"][\"rAL\"]\n\n        sigma_A = case[\"lj\"][\"sigma_A\"]\n        epsilon_A = case[\"lj\"][\"epsilon_A\"]\n        sigma_C = case[\"lj\"][\"sigma_C\"]\n        epsilon_C = case[\"lj\"][\"epsilon_C\"]\n\n        kb_real = case[\"bond\"][\"kb_real\"]\n        r0_real = case[\"bond\"][\"r0_real\"]\n        kb_link = case[\"bond\"][\"kb_link\"]\n        r0_link = case[\"bond\"][\"r0_link\"]\n\n        # Electrostatics: mechanical embedding\n        E_elec_mech = coulomb_energy(ke, qA_MM, qB, qC, rAB, rAC)\n        # Electrostatics: electrostatic embedding (effective QM charge)\n        E_elec_EE = coulomb_energy(ke, qA_eff, qB, qC, rAB, rAC)\n\n        # Van der Waals: only nonbonded A-C\n        E_vdw = lj_energy(epsilon_A, sigma_A, epsilon_C, sigma_C, rAC)\n\n        # Bonded cross-boundary correction\n        E_bond = bonded_cross_energy(kb_real, rAB, r0_real, kb_link, rAL, r0_link)\n\n        # For this setup, vdW and bonded are identical under both embeddings\n        # Round to 6 decimals as required\n        def r6(x): return float(f\"{x:.6f}\")\n\n        case_result = [\n            r6(E_elec_mech),\n            r6(E_vdw),\n            r6(E_bond),\n            r6(E_elec_EE),\n            r6(E_vdw),\n            r6(E_bond)\n        ]\n        results.append(case_result)\n\n    # Format the final output exactly as a single line with a list of lists\n    # Each inner list contains six floats in kJ/mol\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join(f\"{x:.6f}\" for x in res) + \"]\" for res in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        },
        {
            "introduction": "A well-known artifact in electrostatic embedding is the overpolarization of the QM electron density by nearby MM point charges, which can lead to inaccurate results. This practice introduces a common solution: charge damping, which smoothly attenuates electrostatic interactions at short range. You will implement a Thole-type damping function and compute a metric to quantify the extent of overpolarization, providing practical experience in diagnosing and correcting boundary-related issues in QM/MM simulations. ",
            "id": "3849212",
            "problem": "Consider a minimal hybrid Quantum Mechanics/Molecular Mechanics (QM/MM) model of a polarizable quantum mechanical region embedded in a classical point-charge environment. The quantum mechanical (QM) region is represented by an isotropic linear response model with a permanent dipole moment vector $\\boldsymbol{\\mu}_0$ and an isotropic polarizability scalar $\\alpha$ (units in atomic units, where distances are in bohr, charges in elementary charge, dipoles in $e\\cdot\\text{bohr}$, and polarizability in $\\text{bohr}^3$). The molecular mechanics (MM) environment consists of point charges $q_i$ located at position vectors $\\mathbf{r}_i$ relative to the QM region’s reference point at the origin. Use the following fundamental base:\n\n- Coulomb’s law for the electric field due to a point charge in atomic units (where the vacuum permittivity factor is unity): the undamped electric field at the origin due to a point charge $q_i$ located at $\\mathbf{r}_i$ is $\\mathbf{E}_i^{\\text{undamped}} = q_i \\dfrac{\\mathbf{r}_i}{\\|\\mathbf{r}_i\\|^3}$, and the total undamped field is $\\mathbf{E}^{\\text{undamped}} = \\sum_i \\mathbf{E}_i^{\\text{undamped}}$.\n- Linear response of the QM dipole to the external field: the induced QM dipole is $\\boldsymbol{\\mu}_{\\text{ind}} = \\alpha \\mathbf{E}$, so the total QM dipole is $\\boldsymbol{\\mu}_{\\text{QM}} = \\boldsymbol{\\mu}_0 + \\boldsymbol{\\mu}_{\\text{ind}}$.\n- Overpolarization arises when MM point charges are in close proximity to the QM/MM boundary, producing unrealistically large $\\|\\mathbf{E}\\|$ and therefore overly large $\\|\\boldsymbol{\\mu}_{\\text{QM}}\\|$.\n\nTo treat the QM/MM boundary under electrostatic embedding, implement a distance-dependent damping that attenuates the contribution of MM charges closer than a specified boundary radius $r_b$ using a Thole-type exponential-of-cubic damping function. For each charge within the boundary radius, apply a damping factor $s(r_i)$ to its field contribution,\n$$\ns(r_i) = 1 - \\exp\\left(-a \\left(\\frac{\\|\\mathbf{r}_i\\|}{d}\\right)^3\\right),\n$$\nwhere $a$ is a dimensionless Thole parameter and $d$ is a characteristic damping length in bohr. The damped field due to charge $q_i$ is then $\\mathbf{E}_i^{\\text{damped}} = s(r_i)\\, q_i \\dfrac{\\mathbf{r}_i}{\\|\\mathbf{r}_i\\|^3}$ if $\\|\\mathbf{r}_i\\| < r_b$, and $\\mathbf{E}_i^{\\text{damped}} = \\mathbf{E}_i^{\\text{undamped}}$ otherwise. The total damped field is $\\mathbf{E}^{\\text{damped}} = \\sum_i \\mathbf{E}_i^{\\text{damped}}$.\n\nDefine the overpolarization benchmark metric for each test case as the dimensionless ratio\n$$\n\\text{OP} = \\frac{\\left\\|\\boldsymbol{\\mu}_0 + \\alpha\\, \\mathbf{E}^{\\text{undamped}}\\right\\| - \\left\\|\\boldsymbol{\\mu}_0 + \\alpha\\, \\mathbf{E}^{\\text{damped}}\\right\\|}{\\left\\|\\boldsymbol{\\mu}_0 + \\alpha\\, \\mathbf{E}^{\\text{damped}}\\right\\|}.\n$$\n\nTasks:\n- For each test case, compute $\\mathbf{E}^{\\text{undamped}}$, $\\mathbf{E}^{\\text{damped}}$, the corresponding total QM dipole magnitudes $\\left\\|\\boldsymbol{\\mu}_0 + \\alpha\\, \\mathbf{E}^{\\text{undamped}}\\right\\|$ and $\\left\\|\\boldsymbol{\\mu}_0 + \\alpha\\, \\mathbf{E}^{\\text{damped}}\\right\\|$, and then compute the overpolarization ratio $\\text{OP}$ as defined above.\n- All quantities must be treated in atomic units. The final answers are dimensionless floats (no physical units required in the output).\n- Angles do not appear in this formulation, so no angle unit is applicable.\n\nTest suite:\n1. Case A (balanced environment; moderate boundary damping):\n   - $\\boldsymbol{\\mu}_0 = (0.5, 0, 0)$\n   - $\\alpha = 10$\n   - Charges: $\\left[(+0.5, (3, 0, 0)), (-0.5, (-3, 0, 0))\\right]$\n   - $r_b = 4.0$\n   - $a = 0.4$\n   - $d = 1.5$\n2. Case B (very close charge; strong damping):\n   - $\\boldsymbol{\\mu}_0 = (0, 0, 0.2)$\n   - $\\alpha = 20$\n   - Charges: $\\left[(+1.0, (0.5, 0, 0))\\right]$\n   - $r_b = 1.0$\n   - $a = 0.6$\n   - $d = 1.0$\n3. Case C (far charges; negligible damping effect):\n   - $\\boldsymbol{\\mu}_0 = (0.1, 0.1, 0.1)$\n   - $\\alpha = 5$\n   - Charges: $\\left[(+0.2, (10, 0, 0)), (-0.2, (0, 10, 0))\\right]$\n   - $r_b = 3.0$\n   - $a = 0.5$\n   - $d = 1.0$\n4. Case D (mixed cluster near boundary; moderate damping):\n   - $\\boldsymbol{\\mu}_0 = (0.3, -0.2, 0.1)$\n   - $\\alpha = 15$\n   - Charges: $\\left[(+0.7, (1.0, 0.5, 0.0)), (-0.3, (-0.8, 0.2, 0.1)), (+0.4, (2.5, -1.0, 0.0))\\right]$\n   - $r_b = 1.5$\n   - $a = 0.35$\n   - $d = 1.2$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$), where each $\\text{result}_k$ is the overpolarization ratio for the $k$-th test case, rounded to six decimal places. The results must be floats.",
            "solution": "The problem has been meticulously validated and is determined to be valid. It is scientifically grounded in the principles of classical electrostatics and linear response theory as applied in hybrid QM/MM models, is well-posed with all necessary information provided, and is expressed in objective, formal language. There are no contradictions, ambiguities, or factual inaccuracies.\n\nThe task is to calculate a defined overpolarization metric, $\\text{OP}$, for four distinct test cases involving a polarizable quantum mechanical (QM) entity interacting with a classical molecular mechanics (MM) environment of point charges. The solution involves comparing the system's response with and without a Thole-type damping scheme at the QM/MM boundary. All calculations are performed in atomic units.\n\nThe overall procedure for each test case is as follows:\n\n1.  **Compute the Total Undamped Electric Field ($\\mathbf{E}^{\\text{undamped}}$)**\n    The MM environment is composed of $N$ point charges $q_i$ at position vectors $\\mathbf{r}_i$ for $i=1, ..., N$. The origin is the reference point for the QM region. The electric field exerted at the origin by a single point charge $q_i$ is given by Coulomb's law:\n    $$\n    \\mathbf{E}_i^{\\text{undamped}} = q_i \\frac{\\mathbf{r}_i}{\\|\\mathbf{r}_i\\|^3}\n    $$\n    The total undamped electric field, $\\mathbf{E}^{\\text{undamped}}$, is the vector sum of the fields from all point charges:\n    $$\n    \\mathbf{E}^{\\text{undamped}} = \\sum_{i=1}^{N} \\mathbf{E}_i^{\\text{undamped}}\n    $$\n    For each test case, we compute this vector sum.\n\n2.  **Compute the Total Damped Electric Field ($\\mathbf{E}^{\\text{damped}}$)**\n    To mitigate overpolarization from charges close to the QM region, a distance-dependent damping function is applied. For each charge $q_i$ located at a distance $\\|\\mathbf{r}_i\\|$ from the origin, we first check if it lies within the boundary radius $r_b$.\n    - If $\\|\\mathbf{r}_i\\| \\ge r_b$, the charge's contribution is undamped: $\\mathbf{E}_i^{\\text{damped}} = \\mathbf{E}_i^{\\text{undamped}}$.\n    - If $\\|\\mathbf{r}_i\\| < r_b$, the contribution is attenuated by a Thole-type damping factor, $s(\\|\\mathbf{r}_i\\|)$:\n      $$\n      s(\\|\\mathbf{r}_i\\|) = 1 - \\exp\\left(-a \\left(\\frac{\\|\\mathbf{r}_i\\|}{d}\\right)^3\\right)\n      $$\n      where $a$ is a dimensionless parameter and $d$ is a characteristic length. The damped field contribution is then:\n      $$\n      \\mathbf{E}_i^{\\text{damped}} = s(\\|\\mathbf{r}_i\\|) \\cdot \\mathbf{E}_i^{\\text{undamped}} = s(\\|\\mathbf{r}_i\\|) q_i \\frac{\\mathbf{r}_i}{\\|\\mathbf{r}_i\\|^3}\n      $$\n    The total damped electric field, $\\mathbf{E}^{\\text{damped}}$, is the vector sum of these (potentially) damped contributions:\n    $$\n    \\mathbf{E}^{\\text{damped}} = \\sum_{i=1}^{N} \\mathbf{E}_i^{\\text{damped}}\n    $$\n\n3.  **Compute the Total Dipole Moment Magnitudes**\n    The QM region has a permanent dipole moment $\\boldsymbol{\\mu}_0$ and an isotropic polarizability $\\alpha$. The total dipole moment, $\\boldsymbol{\\mu}_{\\text{QM}}$, is the sum of the permanent dipole and the induced dipole, $\\boldsymbol{\\mu}_{\\text{ind}} = \\alpha \\mathbf{E}$.\n    \n    The total dipole moment in the undamped scenario is:\n    $$\n    \\boldsymbol{\\mu}_{\\text{undamped}} = \\boldsymbol{\\mu}_0 + \\alpha \\mathbf{E}^{\\text{undamped}}\n    $$\n    Its magnitude, which is a scalar, is $\\|\\boldsymbol{\\mu}_{\\text{undamped}}\\|$.\n\n    The total dipole moment in the damped scenario is:\n    $$\n    \\boldsymbol{\\mu}_{\\text{damped}} = \\boldsymbol{\\mu}_0 + \\alpha \\mathbf{E}^{\\text{damped}}\n    $$\n    Its magnitude is $\\|\\boldsymbol{\\mu}_{\\text{damped}}\\|$.\n\n4.  **Compute the Overpolarization Metric ($\\text{OP}$)**\n    The overpolarization metric is defined as the fractional difference between the magnitudes of the undamped and damped total dipole moments, relative to the damped magnitude:\n    $$\n    \\text{OP} = \\frac{\\|\\boldsymbol{\\mu}_0 + \\alpha \\mathbf{E}^{\\text{undamped}}\\| - \\|\\boldsymbol{\\mu}_0 + \\alpha \\mathbf{E}^{\\text{damped}}\\|}{\\|\\boldsymbol{\\mu}_0 + \\alpha \\mathbf{E}^{\\text{damped}}\\|} = \\frac{\\|\\boldsymbol{\\mu}_{\\text{undamped}}\\| - \\|\\boldsymbol{\\mu}_{\\text{damped}}\\|}{\\|\\boldsymbol{\\mu}_{\\text{damped}}\\|}\n    $$\n    This value is computed for each test case. If $\\|\\boldsymbol{\\mu}_{\\text{damped}}\\|$ is zero, the expression is undefined; however, given the non-zero permanent dipoles and charge configurations, this physical situation does not occur in the provided test cases.\n\nThis complete procedure is implemented programmatically to solve for the $\\text{OP}$ metric for each of the four specified test cases. The implementation relies on vector algebra, correctly applying norms, scalar-vector products, and vector sums as dictated by the formulae.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the overpolarization benchmark metric for a series of QM/MM test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {'mu0': (0.5, 0, 0), 'alpha': 10.0, 'charges': [(0.5, (3, 0, 0)), (-0.5, (-3, 0, 0))], 'rb': 4.0, 'a': 0.4, 'd': 1.5},\n        # Case B\n        {'mu0': (0, 0, 0.2), 'alpha': 20.0, 'charges': [(1.0, (0.5, 0, 0))], 'rb': 1.0, 'a': 0.6, 'd': 1.0},\n        # Case C\n        {'mu0': (0.1, 0.1, 0.1), 'alpha': 5.0, 'charges': [(0.2, (10, 0, 0)), (-0.2, (0, 10, 0))], 'rb': 3.0, 'a': 0.5, 'd': 1.0},\n        # Case D\n        {'mu0': (0.3, -0.2, 0.1), 'alpha': 15.0, 'charges': [(0.7, (1.0, 0.5, 0.0)), (-0.3, (-0.8, 0.2, 0.1)), (0.4, (2.5, -1.0, 0.0))], 'rb': 1.5, 'a': 0.35, 'd': 1.2},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        mu0 = np.array(case['mu0'], dtype=float)\n        alpha = float(case['alpha'])\n        charges = [(float(q), np.array(r, dtype=float)) for q, r in case['charges']]\n        rb = float(case['rb'])\n        a = float(case['a'])\n        d = float(case['d'])\n\n        # Initialize total electric field vectors\n        E_undamped = np.zeros(3)\n        E_damped = np.zeros(3)\n\n        for q, r_vec in charges:\n            r_norm = np.linalg.norm(r_vec)\n\n            # Avoid division by zero, though not present in test data\n            if r_norm == 0:\n                continue\n\n            # Calculate undamped field contribution\n            E_i_undamped = q * r_vec / (r_norm**3)\n            E_undamped += E_i_undamped\n\n            # Calculate damped field contribution\n            if r_norm < rb:\n                s = 1 - np.exp(-a * (r_norm / d)**3)\n                E_i_damped = s * E_i_undamped\n            else:\n                E_i_damped = E_i_undamped\n            \n            E_damped += E_i_damped\n\n        # Calculate total dipole moments (undamped and damped)\n        mu_undamped = mu0 + alpha * E_undamped\n        mu_damped = mu0 + alpha * E_damped\n\n        # Calculate their magnitudes\n        mag_mu_undamped = np.linalg.norm(mu_undamped)\n        mag_mu_damped = np.linalg.norm(mu_damped)\n\n        # Calculate the overpolarization metric (OP)\n        # Check for division by zero, though unlikely in these cases\n        if mag_mu_damped == 0.0:\n            # If the damped magnitude is zero, the OP is conceptually infinite\n            # if the undamped one is non-zero, or zero if both are zero.\n            # We assume this does not happen based on the problem setup.\n            op_metric = 0.0 if mag_mu_undamped == 0.0 else float('inf')\n        else:\n            op_metric = (mag_mu_undamped - mag_mu_damped) / mag_mu_damped\n\n        results.append(round(op_metric, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The accuracy of electrostatic embedding is fundamentally limited by the quality of the MM point charges, especially those near the QM/MM boundary. This advanced exercise guides you through a powerful reparameterization protocol to derive MM charges that faithfully reproduce a target QM electrostatic potential. By implementing a constrained, regularized least-squares fitting procedure, you will engage with a real-world technique used to create high-fidelity QM/MM models. ",
            "id": "3849255",
            "problem": "You are asked to formalize and implement a mathematically principled reparameterization protocol for hybrid Quantum Mechanics/Molecular Mechanics (QM/MM) simulations in computational chemical biology that targets boundary treatment under electrostatic embedding. The goal is to fit Molecular Mechanics (MM) point charges that lie near the Quantum Mechanics (QM) region boundary so that the resulting MM electrostatic potential reproduces the QM-derived electrostatic potential on a set of grid points, while preserving the neutrality of predefined MM fragments. You must derive the fitting equations from first principles and implement them as a constrained least-squares optimization.\n\nStart from the following fundamental base:\n- The electrostatic potential of a point charge in atomic units is given by $V(\\mathbf{r}) = \\sum_{i} \\dfrac{q_{i}}{\\lVert \\mathbf{r} - \\mathbf{R}_{i} \\rVert}$, where $q_{i}$ is the charge at site $i$, $\\mathbf{R}_{i}$ is its position, and $\\mathbf{r}$ is the evaluation point in space.\n- Electrostatic embedding in hybrid Quantum Mechanics/Molecular Mechanics (QM/MM) methods models the MM environment as fixed point charges that act on the QM region. Mechanical embedding serves as a baseline scenario in which MM charges do not contribute electrostatically to the QM region.\n- Linear least-squares fitting minimizes the sum of squared residuals between model predictions and observations, subject to linear equality constraints.\n\nYour task is to:\n1. Derive from first principles a constrained linear least-squares formulation to estimate unknown MM charges $\\mathbf{q}$ from QM-derived electrostatic potentials on grid points, enforcing fragment neutrality. Use a penalty to regularize toward a reference charge vector when needed. The derivation must begin from the fundamental expression of the electrostatic potential above and lead to a solvable linear system with equality constraints that preserve fragment neutrality. No intermediate formulas should be given in the problem statement; your program must implement the full derivation in code.\n2. Implement the solver that:\n   - Constructs the linear model $A \\mathbf{q} \\approx \\mathbf{v}$ with entries $A_{j,i} = \\dfrac{1}{\\lVert \\mathbf{r}_{j} - \\mathbf{R}_{i} \\rVert}$ in atomic units (Coulomb constant equal to $1$).\n   - Accounts for any fixed MM charges by subtracting their known contributions from the QM-derived potentials to form the effective target vector.\n   - Enforces fragment neutrality through linear equality constraints of the form $C \\mathbf{q} = \\mathbf{d}$, where each row of $C$ sums charges belonging to a fragment and $\\mathbf{d}$ contains the target fragment net charges.\n   - Optionally applies quadratic regularization (Tikhonov) toward a given reference charge vector $\\mathbf{q}_{0}$ with strength $\\alpha \\ge 0$.\n   - Produces fitted MM charges in elementary charge units $e$.\n3. For the last test case, compute a scalar performance metric that contrasts electrostatic embedding and mechanical embedding by reporting the normalized residual ratio $R = \\dfrac{\\lVert \\mathbf{v} - A \\mathbf{q}_{\\mathrm{fit}} \\rVert^{2}}{\\lVert \\mathbf{v} \\rVert^{2}}$, where $\\mathbf{q}_{\\mathrm{fit}}$ is the fitted charge vector. Mechanical embedding corresponds to the baseline $\\mathbf{q} = \\mathbf{0}$, whose normalized residual is $1$ by definition.\n\nUnits and numerical reporting requirements:\n- Positions must be treated in bohr (atomic units), potentials in atomic units, and charges in elementary charge units $e$.\n- Your program must round each reported fitted charge and each scalar metric to $6$ decimal places.\n- Angles are not involved.\n- The final output must be a single line containing the results as a comma-separated list enclosed in square brackets. The elements of this list are, in order, the fitted charge vectors for Test Case $1$, Test Case $2$, Test Case $3$ (each itself printed as a list), and then the scalar metric for Test Case $4$.\n\nTest suite:\nImplement and solve the following four cases. For each case, build the QM-derived electrostatic potentials by superimposing contributions from the specified “true” unknown charges and any fixed charges, using $V(\\mathbf{r}) = \\sum_{i} \\dfrac{q_{i}}{\\lVert \\mathbf{r} - \\mathbf{R}_{i} \\rVert}$ in atomic units.\n\n- Test Case $1$ (general “happy path” with fixed-charge subtraction and two fragments):\n  - Unknown MM charge sites $\\mathbf{R}_{i}$:\n    - $\\mathbf{R}_{0} = (\\,0.0,\\,0.0,\\,0.0\\,)$,\n    - $\\mathbf{R}_{1} = (\\,2.0,\\,0.0,\\,0.0\\,)$,\n    - $\\mathbf{R}_{2} = (\\,0.0,\\,2.0,\\,0.0\\,)$.\n  - Fragments and neutrality targets:\n    - Fragment $A$: indices $[\\,0,\\,1\\,]$, target net charge $0.0$,\n    - Fragment $B$: indices $[\\,2\\,]$, target net charge $0.0$.\n  - Fixed MM charges:\n    - One fixed charge $q_{\\mathrm{fix}} = 0.1$ at position $(\\,5.0,\\,5.0,\\,0.0\\,)$.\n  - Grid points $\\mathbf{r}_{j}$:\n    - $(\\,1.0,\\,0.5,\\,0.0\\,)$,\n    - $(\\,1.0,\\,1.5,\\,0.0\\,)$,\n    - $(\\,0.5,\\,1.0,\\,0.0\\,)$,\n    - $(\\,2.5,\\,0.5,\\,0.0\\,)$,\n    - $(\\,-0.5,\\,-0.5,\\,0.0\\,)$.\n  - “True” unknown charges for generating the QM potentials:\n    - $q^{\\mathrm{true}} = [\\,0.3,\\,-0.15,\\,-0.15\\,]$.\n  - Regularization:\n    - $\\alpha = 0.0$, $\\mathbf{q}_{0} = [\\,0.0,\\,0.0,\\,0.0\\,]$.\n\n- Test Case $2$ (boundary treatment: link-atom zero-charge constraint inside a neutral fragment):\n  - Unknown MM charge sites $\\mathbf{R}_{i}$:\n    - $\\mathbf{R}_{0} = (\\,0.0,\\,0.0,\\,0.0\\,)$,\n    - $\\mathbf{R}_{1} = (\\,1.5,\\,0.0,\\,0.0\\,)$.\n  - Fragments and neutrality target:\n    - Fragment $A$: indices $[\\,0,\\,1\\,]$, target net charge $0.0$.\n  - Additional boundary constraint:\n    - Enforce $q_{0} = 0.0$ to represent a link atom carrying no MM charge.\n  - Grid points $\\mathbf{r}_{j}$:\n    - $(\\,0.75,\\,0.5,\\,0.0\\,)$,\n    - $(\\,1.2,\\,0.3,\\,0.0\\,)$,\n    - $(\\,0.3,\\,-0.4,\\,0.0\\,)$,\n    - $(\\,1.6,\\,0.5,\\,0.0\\,)$.\n  - “True” unknown charges for generating the QM potentials:\n    - $q^{\\mathrm{true}} = [\\,0.2,\\,-0.2\\,]$.\n  - Regularization:\n    - $\\alpha = 0.0$, $\\mathbf{q}_{0} = [\\,0.0,\\,0.0\\,]$.\n\n- Test Case $3$ (underdetermined system stabilized by regularization toward reference MM charges):\n  - Unknown MM charge sites $\\mathbf{R}_{i}$:\n    - $\\mathbf{R}_{0} = (\\,0.0,\\,0.0,\\,0.0\\,)$,\n    - $\\mathbf{R}_{1} = (\\,1.0,\\,0.0,\\,0.0\\,)$,\n    - $\\mathbf{R}_{2} = (\\,0.0,\\,1.0,\\,0.0\\,)$,\n    - $\\mathbf{R}_{3} = (\\,1.0,\\,1.0,\\,0.0\\,)$.\n  - Fragments and neutrality targets:\n    - Fragment $A$: indices $[\\,0,\\,1\\,]$, target net charge $0.0$,\n    - Fragment $B$: indices $[\\,2,\\,3\\,]$, target net charge $0.0$.\n  - Grid points $\\mathbf{r}_{j}$:\n    - $(\\,0.5,\\,0.2,\\,0.0\\,)$,\n    - $(\\,0.2,\\,0.7,\\,0.0\\,)$,\n    - $(\\,0.8,\\,0.8,\\,0.0\\,)$.\n  - “True” unknown charges for generating the QM potentials:\n    - $q^{\\mathrm{true}} = [\\,0.12,\\,-0.08,\\,0.03,\\,-0.07\\,]$.\n  - Regularization:\n    - $\\alpha = 0.1$, reference charges $\\mathbf{q}_{0} = [\\,0.1,\\,-0.1,\\,0.05,\\,-0.05\\,]$.\n\n- Test Case $4$ (contrast electrostatic and mechanical embedding via normalized residual reduction):\n  - Unknown MM charge sites $\\mathbf{R}_{i}$:\n    - $\\mathbf{R}_{0} = (\\,0.0,\\,0.0,\\,0.0\\,)$,\n    - $\\mathbf{R}_{1} = (\\,2.0,\\,2.0,\\,0.0\\,)$.\n  - Fragments and neutrality target:\n    - Fragment $A$: indices $[\\,0,\\,1\\,]$, target net charge $0.0$.\n  - Grid points $\\mathbf{r}_{j}$:\n    - $(\\,0.5,\\,0.5,\\,0.0\\,)$,\n    - $(\\,1.0,\\,1.0,\\,0.0\\,)$,\n    - $(\\,1.5,\\,1.5,\\,0.0\\,)$,\n    - $(\\,2.5,\\,0.5,\\,0.0\\,)$,\n    - $(\\,0.5,\\,2.5,\\,0.0\\,)$.\n  - “True” unknown charges for generating the QM potentials:\n    - $q^{\\mathrm{true}} = [\\,0.25,\\,-0.25\\,]$.\n  - Regularization:\n    - $\\alpha = 0.0$, $\\mathbf{q}_{0} = [\\,0.0,\\,0.0\\,]$.\n\nYour program must:\n- For each test case, construct the QM-derived potentials on the grid points by superposition of the “true” unknown charges and any fixed charges (if present), then subtract fixed-charge contributions when fitting to yield the effective target vector.\n- Solve the constrained least-squares problem to obtain the fitted charges.\n- For Test Case $4$, compute the normalized residual ratio $R$ defined above.\n- Print a single line: a comma-separated list enclosed in square brackets whose first three entries are the lists of fitted charges for Test Cases $1$–$3$ in $e$, each rounded to $6$ decimal places, followed by the scalar $R$ for Test Case $4$ rounded to $6$ decimal places. For example, the final line should look like $[ [\\,\\dots\\,], [\\,\\dots\\,], [\\,\\dots\\,], r ]$.",
            "solution": "The problem presented is a valid and well-posed task in computational chemical biology, specifically concerning the parameterization of point charges in a hybrid Quantum Mechanics/Molecular Mechanics (QM/MM) simulation. It requires the derivation and implementation of a constrained, regularized linear least-squares fitting procedure.\n\nThe foundation of this problem is rooted in classical electrostatics and numerical optimization. The electrostatic potential $V$ at a spatial point $\\mathbf{r}$ generated by a distribution of point charges $q_i$ located at positions $\\mathbf{R}_i$ is given by the superposition principle, which in atomic units (where the Coulomb constant $k_e = \\frac{1}{4\\pi\\epsilon_0}$ is $1$) is:\n$$\nV(\\mathbf{r}) = \\sum_{i} \\frac{q_i}{\\lVert \\mathbf{r} - \\mathbf{R}_i \\rVert}\n$$\nIn our QM/MM context, we aim to determine a set of $N$ unknown MM charges, denoted by the vector $\\mathbf{q} \\in \\mathbb{R}^N$, such that the electrostatic potential they produce matches a target potential, $\\mathbf{v} \\in \\mathbb{R}^M$, at a set of $M$ grid points $\\mathbf{r}_j$. This relationship can be expressed as a linear system:\n$$\nA \\mathbf{q} \\approx \\mathbf{v}\n$$\nHere, $A$ is an $M \\times N$ matrix where each element $A_{ji}$ represents the electrostatic potential at grid point $\\mathbf{r}_j$ due to a unit charge at site $\\mathbf{R}_i$:\n$$\nA_{ji} = \\frac{1}{\\lVert \\mathbf{r}_j - \\mathbf{R}_i \\rVert}\n$$\nThe target potential vector $\\mathbf{v}$ corresponds to the potential that the unknown charges are supposed to replicate. In a real QM/MM simulation, this would be derived from a quantum mechanical calculation on the QM region. For this problem, we simulate this by calculating the potential from a set of \"true\" charges, $\\mathbf{q}_{\\mathrm{true}}$. The total potential measured might include contributions from other, known MM charges ($q_{\\mathrm{fix}}$). Let the potential from these fixed charges at the grid points be $\\mathbf{v}_{\\mathrm{fix}}$. The total potential is $\\mathbf{v}_{\\mathrm{total}} = A \\mathbf{q}_{\\mathrm{true}} + \\mathbf{v}_{\\mathrm{fix}}$. Our goal is to fit $\\mathbf{q}$ to account for the potential generated by the unknown charges, so we must subtract the contribution from the fixed charges. The effective target potential is thus $\\mathbf{v} = \\mathbf{v}_{\\mathrm{total}} - \\mathbf{v}_{\\mathrm{fix}} = A \\mathbf{q}_{\\mathrm{true}}$.\n\nTo find the optimal charge vector $\\mathbf{q}$, we minimize the sum of squared differences between the model's prediction $A\\mathbf{q}$ and the target potential $\\mathbf{v}$. To prevent overfitting and to ensure a unique solution exists for underdetermined systems (where $M < N$), we introduce a Tikhonov regularization term. This term penalizes the squared deviation of the fitted charges $\\mathbf{q}$ from a set of reference charges $\\mathbf{q}_0$, with a strength controlled by the parameter $\\alpha \\ge 0$. The objective function to minimize is:\n$$\nS(\\mathbf{q}) = \\lVert A\\mathbf{q} - \\mathbf{v} \\rVert^2 + \\alpha \\lVert \\mathbf{q} - \\mathbf{q}_0 \\rVert^2\n$$\nThis is an unconstrained optimization problem. However, physical realism often demands constraints. A common requirement is that specific molecular fragments maintain a predefined net charge (e.g., $0$ for a neutral molecule). These are linear equality constraints that can be written in matrix form as:\n$$\nC \\mathbf{q} = \\mathbf{d}\n$$\nwhere each row of the matrix $C$ defines a constraint (e.g., by having $1$s for all charge indices belonging to a fragment), and the vector $\\mathbf{d}$ contains the target net charges.\n\nTo solve the minimization problem subject to these linear constraints, we employ the method of Lagrange multipliers. We construct the Lagrangian function $\\mathcal{L}(\\mathbf{q}, \\boldsymbol{\\lambda})$, where $\\boldsymbol{\\lambda}$ is a vector of Lagrange multipliers:\n$$\n\\mathcal{L}(\\mathbf{q}, \\boldsymbol{\\lambda}) = (A\\mathbf{q} - \\mathbf{v})^T (A\\mathbf{q} - \\mathbf{v}) + \\alpha (\\mathbf{q} - \\mathbf{q}_0)^T (\\mathbf{q} - \\mathbf{q}_0) + 2\\boldsymbol{\\lambda}^T (C\\mathbf{q} - \\mathbf{d})\n$$\nThe factor of $2$ is for algebraic convenience. The optimal solution $(\\mathbf{q}, \\boldsymbol{\\lambda})$ must be a stationary point of the Lagrangian. We find this by setting the gradients with respect to $\\mathbf{q}$ and $\\boldsymbol{\\lambda}$ to zero.\n\nThe gradient with respect to $\\mathbf{q}$ is:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\mathbf{q}} = 2 A^T(A\\mathbf{q} - \\mathbf{v}) + 2\\alpha(\\mathbf{q} - \\mathbf{q}_0) + 2C^T\\boldsymbol{\\lambda} = 0\n$$\n$$\n(A^T A + \\alpha I)\\mathbf{q} + C^T\\boldsymbol{\\lambda} = A^T\\mathbf{v} + \\alpha\\mathbf{q}_0\n$$\nwhere $I$ is the identity matrix.\n\nThe gradient with respect to $\\boldsymbol{\\lambda}$ simply recovers the constraint equations:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\boldsymbol{\\lambda}} = 2(C\\mathbf{q} - \\mathbf{d}) = 0 \\implies C\\mathbf{q} = \\mathbf{d}\n$$\nThese two resulting matrix equations form a single, larger system of linear equations, often called a Karush-Kuhn-Tucker (KKT) system. In block matrix form, it is:\n$$\n\\begin{pmatrix}\nA^T A + \\alpha I & C^T \\\\\nC & 0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{q} \\\\\n\\boldsymbol{\\lambda}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nA^T \\mathbf{v} + \\alpha \\mathbf{q}_0 \\\\\n\\mathbf{d}\n\\end{pmatrix}\n$$\nThis is a standard linear system of the form $K \\mathbf{x} = \\mathbf{b}$, where $K$ is the block KKT matrix, $\\mathbf{x}$ is the concatenation of the unknown charge vector $\\mathbf{q}$ and the Lagrange multiplier vector $\\boldsymbol{\\lambda}$, and $\\mathbf{b}$ is the known right-hand-side vector. By constructing these matrices and vectors from the problem's givens, we can solve for $\\mathbf{x}$ using standard linear algebra libraries. The first $N$ elements of the solution vector $\\mathbf{x}$ will yield the desired fitted charges $\\mathbf{q}$.\n\nFor the final test case, we evaluate the performance of this electrostatic embedding by comparing the residual error against a mechanical embedding model where all fitted charges are zero ($\\mathbf{q}=\\mathbf{0}$). The metric is the normalized residual ratio $R$:\n$$\nR = \\frac{\\lVert \\mathbf{v} - A \\mathbf{q}_{\\mathrm{fit}} \\rVert^{2}}{\\lVert \\mathbf{v} \\rVert^{2}}\n$$\nwhere $\\mathbf{q}_{\\mathrm{fit}}$ is the charge vector obtained from solving the KKT system. A value of $R$ close to $0$ indicates a near-perfect fit, while a value of $1$ corresponds to the error of the mechanical embedding model ($\\mathbf{q}=\\mathbf{0}$), indicating no improvement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define, solve, and report results for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"R_unknown\": np.array([\n                [0.0, 0.0, 0.0],\n                [2.0, 0.0, 0.0],\n                [0.0, 2.0, 0.0]\n            ]),\n            \"q_true\": np.array([0.3, -0.15, -0.15]),\n            \"grid\": np.array([\n                [1.0, 0.5, 0.0],\n                [1.0, 1.5, 0.0],\n                [0.5, 1.0, 0.0],\n                [2.5, 0.5, 0.0],\n                [-0.5, -0.5, 0.0]\n            ]),\n            \"fixed_charges\": [{\"q\": 0.1, \"R\": np.array([5.0, 5.0, 0.0])}],\n            \"fragments\": [\n                {\"indices\": [0, 1], \"charge\": 0.0},\n                {\"indices\": [2], \"charge\": 0.0}\n            ],\n            \"alpha\": 0.0,\n            \"q0\": np.array([0.0, 0.0, 0.0]),\n            \"extra_constraints\": [],\n            \"compute_metric\": False\n        },\n        # Test Case 2\n        {\n            \"R_unknown\": np.array([\n                [0.0, 0.0, 0.0],\n                [1.5, 0.0, 0.0]\n            ]),\n            \"q_true\": np.array([0.2, -0.2]),\n            \"grid\": np.array([\n                [0.75, 0.5, 0.0],\n                [1.2, 0.3, 0.0],\n                [0.3, -0.4, 0.0],\n                [1.6, 0.5, 0.0]\n            ]),\n            \"fixed_charges\": [],\n            \"fragments\": [\n                {\"indices\": [0, 1], \"charge\": 0.0}\n            ],\n            \"alpha\": 0.0,\n            \"q0\": np.array([0.0, 0.0]),\n            \"extra_constraints\": [{\"index\": 0, \"value\": 0.0}],\n            \"compute_metric\": False\n        },\n        # Test Case 3\n        {\n            \"R_unknown\": np.array([\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [0.0, 1.0, 0.0],\n                [1.0, 1.0, 0.0]\n            ]),\n            \"q_true\": np.array([0.12, -0.08, 0.03, -0.07]),\n            \"grid\": np.array([\n                [0.5, 0.2, 0.0],\n                [0.2, 0.7, 0.0],\n                [0.8, 0.8, 0.0]\n            ]),\n            \"fixed_charges\": [],\n            \"fragments\": [\n                {\"indices\": [0, 1], \"charge\": 0.0},\n                {\"indices\": [2, 3], \"charge\": 0.0}\n            ],\n            \"alpha\": 0.1,\n            \"q0\": np.array([0.1, -0.1, 0.05, -0.05]),\n            \"extra_constraints\": [],\n            \"compute_metric\": False\n        },\n        # Test Case 4\n        {\n            \"R_unknown\": np.array([\n                [0.0, 0.0, 0.0],\n                [2.0, 2.0, 0.0]\n            ]),\n            \"q_true\": np.array([0.25, -0.25]),\n            \"grid\": np.array([\n                [0.5, 0.5, 0.0],\n                [1.0, 1.0, 0.0],\n                [1.5, 1.5, 0.0],\n                [2.5, 0.5, 0.0],\n                [0.5, 2.5, 0.0]\n            ]),\n            \"fixed_charges\": [],\n            \"fragments\": [\n                {\"indices\": [0, 1], \"charge\": 0.0}\n            ],\n            \"alpha\": 0.0,\n            \"q0\": np.array([0.0, 0.0]),\n            \"extra_constraints\": [],\n            \"compute_metric\": True\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        res = solve_constrained_lsq(case)\n        results.append(res)\n    \n    # Format the final output string according to the specification\n    formatted_parts = []\n    for r in results:\n        if isinstance(r, (list, np.ndarray)):\n            # Format list of charges to 6 decimal places\n            formatted_parts.append(f\"[{','.join(f'{x:.6f}' for x in r)}]\")\n        else:\n            # Format scalar metric to 6 decimal places\n            formatted_parts.append(f\"{r:.6f}\")\n    \n    print(f\"[{','.join(formatted_parts)}]\")\n\n\ndef solve_constrained_lsq(params):\n    \"\"\"\n    Solves a single constrained least-squares problem based on the provided parameters.\n    \"\"\"\n    R_unknown = params[\"R_unknown\"]\n    q_true = params[\"q_true\"]\n    grid = params[\"grid\"]\n    fixed_charges = params[\"fixed_charges\"]\n    fragments = params[\"fragments\"]\n    alpha = params[\"alpha\"]\n    q0 = params[\"q0\"]\n    extra_constraints = params[\"extra_constraints\"]\n\n    num_charges = len(R_unknown)\n    num_grid_pts = len(grid)\n\n    # 1. Construct the 'A' matrix\n    A = np.zeros((num_grid_pts, num_charges))\n    for j in range(num_grid_pts):\n        for i in range(num_charges):\n            dist = np.linalg.norm(grid[j] - R_unknown[i])\n            if dist > 1e-9: # Avoid division by zero if a grid point coincides with a charge site\n                A[j, i] = 1.0 / dist\n            else:\n                A[j, i] = 1e9 # A large number, though this case is not in the tests\n\n    # 2. Construct the effective target potential vector 'v'\n    # The problem specifies that the QM potential is built from true and fixed charges,\n    # and then the fixed charge contribution is subtracted to get the target vector 'v'.\n    # This simplifies to v = A @ q_true.\n    v = A @ q_true\n\n    # 3. Construct the constraint matrix 'C' and vector 'd'\n    num_constraints = len(fragments) + len(extra_constraints)\n    C = np.zeros((num_constraints, num_charges))\n    d = np.zeros(num_constraints)\n    \n    constraint_idx = 0\n    # Fragment neutrality constraints\n    for frag in fragments:\n        for charge_idx in frag[\"indices\"]:\n            C[constraint_idx, charge_idx] = 1.0\n        d[constraint_idx] = frag[\"charge\"]\n        constraint_idx += 1\n    \n    # Additional constraints (e.g., link-atom charge)\n    for const in extra_constraints:\n        C[constraint_idx, const[\"index\"]] = 1.0\n        d[constraint_idx] = const[\"value\"]\n        constraint_idx += 1\n\n    # 4. Construct the KKT (Karush-Kuhn-Tucker) system\n    # Top-left block: A^T A + alpha * I\n    M_TL = A.T @ A + alpha * np.identity(num_charges)\n\n    # Top-right block: C^T\n    M_TR = C.T\n\n    # Bottom-left block: C\n    M_BL = C\n\n    # Bottom-right block: zeros\n    M_BR = np.zeros((num_constraints, num_constraints))\n    \n    # Assemble the full KKT matrix\n    K = np.block([[M_TL, M_TR], [M_BL, M_BR]])\n\n    # Assemble the right-hand-side vector\n    b_top = A.T @ v + alpha * q0\n    b_bottom = d\n    b = np.concatenate([b_top, b_bottom])\n\n    # 5. Solve the linear system\n    try:\n        solution_vec = np.linalg.solve(K, b)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudo-inverse for stability, although not expected for these test cases\n        solution_vec = np.linalg.pinv(K) @ b\n\n\n    # The fitted charges are the first 'num_charges' elements of the solution\n    q_fit = solution_vec[:num_charges]\n\n    if params[\"compute_metric\"]:\n        # 6. Compute the normalized residual ratio R for Test Case 4\n        # Note: v = A @ q_true\n        residual_vec = v - (A @ q_fit)\n        norm_sq_residual = np.dot(residual_vec, residual_vec)\n        norm_sq_v = np.dot(v, v)\n        \n        if norm_sq_v < 1e-12: # Avoid division by zero\n            return 0.0\n        \n        R = norm_sq_residual / norm_sq_v\n        return R\n    else:\n        return q_fit\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}