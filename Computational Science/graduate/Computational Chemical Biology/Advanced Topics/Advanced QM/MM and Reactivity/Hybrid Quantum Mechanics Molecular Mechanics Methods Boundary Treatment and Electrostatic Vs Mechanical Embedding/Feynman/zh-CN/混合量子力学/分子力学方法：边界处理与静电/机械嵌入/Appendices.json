{
    "hands_on_practices": [
        {
            "introduction": "为了真正掌握机械嵌入 (mechanical embedding) 和静电嵌入 (electrostatic embedding) 方案之间的差异，亲手分解其能量构成是至关重要的一步。本练习将指导您为一个简化的模型体系计算QM/MM相互作用能的基本组成部分——静电项、范德华项和成键项。通过实践这些计算，您将具体理解各个能量项是如何从相应的QM/MM哈密顿量 (Hamiltonian) 中产生的，并体会两种嵌入方案的本质区别。",
            "id": "3849241",
            "problem": "你的任务是，从第一性原理出发，为一个最小的溶质-溶剂体系构建混合量子力学/分子力学 (QM/MM) 相互作用能的计算分解，该体系使用两种嵌入方案：机械嵌入和静电嵌入。该体系由一个量子力学 (QM) 原子和两个分子力学 (MM) 原子组成，其中一个 MM 原子跨越 QM/MM 边界直接成键。你的程序必须将混合能量 $E_{\\mathrm{QM/MM}}$ 分解为静电、van der Waals 和键合项，并且必须明确展示每一项是如何从底层的哈密顿量中产生的。",
            "solution": "我们从 Born–Oppenheimer 近似下的混合量子力学/分子力学 (QM/MM) 框架开始，该近似分离了电子和原子核的自由度。对于一个被划分为量子力学 (QM) 区域和分子力学 (MM) 区域的系统，其总哈密顿量可以示意性地表示为\n$$\n\\hat{H}_{\\mathrm{tot}} = \\hat{H}_{\\mathrm{QM}} + U_{\\mathrm{MM}} + \\hat{H}_{\\mathrm{int}},\n$$\n其中 $\\hat{H}_{\\mathrm{QM}}$ 是 QM 区域的电子哈密顿量（原子核位置固定），$U_{\\mathrm{MM}}$ 是 MM 区域的经典力场势（包括键合和非键合项），而 $\\hat{H}_{\\mathrm{int}}$ 代表跨界耦合。我们所寻求的能量分解必须能直接追溯到这些项。\n\n对于 QM 区域，标准的非相对论性电子哈密顿量是\n$$\n\\hat{H}_{\\mathrm{QM}} = \\hat{T}_{e} + \\hat{V}_{ee} + \\hat{V}_{eN} + V_{NN},\n$$\n其中 $\\hat{T}_{e}$ 是电子动能，$\\hat{V}_{ee}$ 是电子-电子 Coulomb 排斥，$\\hat{V}_{eN}$ 是电子-原子核吸引，而 $V_{NN}$ 是原子核-原子核 Coulomb 排斥。在混合方案中，MM 区域由经典势描述\n$$\nU_{\\mathrm{MM}} = \n\\sum_{\\mathrm{bonds}}\\frac{1}{2}k_{\\mathrm{b}}(r-r_{0})^{2}\n+\n\\sum_{\\mathrm{angles}}k_{\\theta}(\\theta-\\theta_{0})^{2}\n+\n\\sum_{\\mathrm{dihedrals}}U_{\\phi}(\\phi)\n+\n\\sum_{i",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lj_energy(eps_i, sig_i, eps_j, sig_j, r_ij):\n    \"\"\"\n    Compute Lennard-Jones 12-6 energy using Lorentz-Berthelot mixing.\n    eps in kJ/mol, sigma in nm, r_ij in nm.\n    Returns energy in kJ/mol.\n    \"\"\"\n    # Lorentz-Berthelot mixing rules\n    sigma_ij = 0.5 * (sig_i + sig_j)\n    epsilon_ij = np.sqrt(eps_i * eps_j)\n    sr = sigma_ij / r_ij\n    sr6 = sr ** 6\n    sr12 = sr6 ** 2\n    return 4.0 * epsilon_ij * (sr12 - sr6)\n\ndef coulomb_energy(ke, qA, qB, qC, rAB, rAC):\n    \"\"\"\n    Compute electrostatic energy for one QM atom A interacting with two MM atoms B and C.\n    ke in kJ mol^-1 nm e^-2, charges in e, distances in nm.\n    Returns energy in kJ/mol.\n    \"\"\"\n    return ke * qA * (qB / rAB + qC / rAC)\n\ndef bonded_cross_energy(kb_real, rAB, r0_real, kb_link, rAL, r0_link):\n    \"\"\"\n    Compute cross-boundary bonded correction via subtractive scheme:\n    E_bond = 0.5*kb_real*(rAB - r0_real)^2 - 0.5*kb_link*(rAL - r0_link)^2\n    kb in kJ mol^-1 nm^-2, distances in nm.\n    Returns energy in kJ/mol.\n    \"\"\"\n    e_real = 0.5 * kb_real * (rAB - r0_real) ** 2\n    e_link = 0.5 * kb_link * (rAL - r0_link) ** 2\n    return e_real - e_link\n\ndef solve():\n    # Coulomb constant in kJ mol^-1 nm e^-2\n    ke = 138.935456\n\n    # Define the test cases from the problem statement.\n    # Each test case is a dictionary of parameters.\n    test_cases = [\n        {\n            # Test case 1\n            \"charges\": {\"qA_MM\": -0.3, \"qA_eff\": -0.5, \"qB\": +0.4, \"qC\": -0.2},\n            \"distances\": {\"rAB\": 0.16, \"rAC\": 0.50, \"rAL\": 0.105},\n            \"lj\": {\"sigma_A\": 0.32, \"epsilon_A\": 0.5, \"sigma_C\": 0.30, \"epsilon_C\": 0.4},\n            \"bond\": {\"kb_real\": 1000.0, \"r0_real\": 0.15, \"kb_link\": 700.0, \"r0_link\": 0.105}\n        },\n        {\n            # Test case 2\n            \"charges\": {\"qA_MM\": 0.0, \"qA_eff\": 0.0, \"qB\": 0.0, \"qC\": 0.0},\n            \"distances\": {\"rAB\": 0.15, \"rAC\": 0.40, \"rAL\": 0.108},\n            \"lj\": {\"sigma_A\": 0.31, \"epsilon_A\": 0.45, \"sigma_C\": 0.29, \"epsilon_C\": 0.35},\n            \"bond\": {\"kb_real\": 900.0, \"r0_real\": 0.15, \"kb_link\": 850.0, \"r0_link\": 0.108}\n        },\n        {\n            # Test case 3\n            \"charges\": {\"qA_MM\": -1.0, \"qA_eff\": -0.8, \"qB\": +1.0, \"qC\": +0.5},\n            \"distances\": {\"rAB\": 0.20, \"rAC\": 0.45, \"rAL\": 0.110},\n            \"lj\": {\"sigma_A\": 0.35, \"epsilon_A\": 1.2, \"sigma_C\": 0.33, \"epsilon_C\": 0.9},\n            \"bond\": {\"kb_real\": 1200.0, \"r0_real\": 0.145, \"kb_link\": 800.0, \"r0_link\": 0.106}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        qA_MM = case[\"charges\"][\"qA_MM\"]\n        qA_eff = case[\"charges\"][\"qA_eff\"]\n        qB = case[\"charges\"][\"qB\"]\n        qC = case[\"charges\"][\"qC\"]\n\n        rAB = case[\"distances\"][\"rAB\"]\n        rAC = case[\"distances\"][\"rAC\"]\n        rAL = case[\"distances\"][\"rAL\"]\n\n        sigma_A = case[\"lj\"][\"sigma_A\"]\n        epsilon_A = case[\"lj\"][\"epsilon_A\"]\n        sigma_C = case[\"lj\"][\"sigma_C\"]\n        epsilon_C = case[\"lj\"][\"epsilon_C\"]\n\n        kb_real = case[\"bond\"][\"kb_real\"]\n        r0_real = case[\"bond\"][\"r0_real\"]\n        kb_link = case[\"bond\"][\"kb_link\"]\n        r0_link = case[\"bond\"][\"r0_link\"]\n\n        # Electrostatics: mechanical embedding\n        E_elec_mech = coulomb_energy(ke, qA_MM, qB, qC, rAB, rAC)\n        # Electrostatics: electrostatic embedding (effective QM charge)\n        E_elec_EE = coulomb_energy(ke, qA_eff, qB, qC, rAB, rAC)\n\n        # Van der Waals: only nonbonded A-C\n        E_vdw = lj_energy(epsilon_A, sigma_A, epsilon_C, sigma_C, rAC)\n\n        # Bonded cross-boundary correction\n        E_bond = bonded_cross_energy(kb_real, rAB, r0_real, kb_link, rAL, r0_link)\n\n        # For this setup, vdW and bonded are identical under both embeddings\n        # Round to 6 decimals as required\n        def r6(x): return float(f\"{x:.6f}\")\n\n        case_result = [\n            r6(E_elec_mech),\n            r6(E_vdw),\n            r6(E_bond),\n            r6(E_elec_EE),\n            r6(E_vdw),\n            r6(E_bond)\n        ]\n        results.append(case_result)\n\n    # Format the final output exactly as a single line with a list of lists\n    # Each inner list contains six floats in kJ/mol\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join(f\"{x:.6f}\" for x in res) + \"]\" for res in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        },
        {
            "introduction": "静电嵌入通过允许QM和MM区域相互极化，提供了更真实的物理图像，但同时也可能引入伪影 (artifacts)。其中最典型的问题之一就是“过极化 (overpolarization)”现象，尤其当MM点电荷与QM区域边界过于接近时。本练习将提供一种动手方法，通过一个基准指标来量化这一效应，并探索一种常见的解决方案——Thole型阻尼函数 (Thole-type damping function)，以有效修正这种不真实的极化行为。",
            "id": "3849212",
            "problem": "考虑一个最小混合量子力学/分子力学 (QM/MM) 模型，其中一个可极化量子力学区域嵌入在经典点电荷环境中。量子力学 (QM) 区域由一个各向同性线性响应模型表示，具有永久偶极矩矢量 $\\boldsymbol{\\mu}_0$ 和各向同性极化率标量 $\\alpha$（单位为原子单位，其中距离单位为玻尔 (bohr)，电荷单位为基本电荷，偶极单位为 $e\\cdot\\text{bohr}$，极化率单位为 $\\text{bohr}^3$）。分子力学 (MM) 环境由点电荷 $q_i$ 组成，其相对于 QM 区域位于原点的参考点的位置矢量为 $\\mathbf{r}_i$。使用以下基本原理：\n\n- 原子单位制下点电荷产生电场的库仑定律（其中真空介电常数因子为 1）：位于 $\\mathbf{r}_i$ 的点电荷 $q_i$ 在原点产生的未阻尼电场为 $\\mathbf{E}_i^{\\text{undamped}} = q_i \\dfrac{\\mathbf{r}_i}{\\|\\mathbf{r}_i\\|^3}$，总未阻尼电场为 $\\mathbf{E}^{\\text{undamped}} = \\sum_i \\mathbf{E}_i^{\\text{undamped}}$。\n- QM 偶极对外部电场的线性响应：感生 QM 偶极为 $\\boldsymbol{\\mu}_{\\text{ind}} = \\alpha \\mathbf{E}$，因此总 QM 偶极为 $\\boldsymbol{\\mu}_{\\text{QM}} = \\boldsymbol{\\mu}_0 + \\boldsymbol{\\mu}_{\\text{ind}}$。\n- 当 MM 点电荷非常靠近 QM/MM 边界时，会产生过极化现象，导致 $\\|\\mathbf{E}\\|$ 不切实际地过大，从而使 $\\|\\boldsymbol{\\mu}_{\\text{QM}}\\|$ 也过大。\n\n为了在静电嵌入下处理 QM/MM 边界，需要实现一种距离依赖的阻尼，使用 Thole 型三次指数阻尼函数来衰减比指定边界半径 $r_b$ 更近的 MM 电荷的贡献。对于边界半径内的每个电荷，对其电场贡献应用一个阻尼因子 $s(r_i)$，\n$$\ns(r_i) = 1 - \\exp\\left(-a \\left(\\frac{\\|\\mathbf{r}_i\\|}{d}\\right)^3\\right),\n$$\n其中 $a$ 是一个无量纲 Thole 参数，$d$ 是一个以玻尔为单位的特征阻尼长度。则由电荷 $q_i$ 产生的阻尼电场为：若 $\\|\\mathbf{r}_i\\|  r_b$，则 $\\mathbf{E}_i^{\\text{damped}} = s(r_i)\\, q_i \\dfrac{\\mathbf{r}_i}{\\|\\mathbf{r}_i\\|^3}$；否则 $\\mathbf{E}_i^{\\text{damped}} = \\mathbf{E}_i^{\\text{undamped}}$。总阻尼电场为 $\\mathbf{E}^{\\text{damped}} = \\sum_i \\mathbf{E}_i^{\\text{damped}}$。\n\n将每个测试案例的过极化基准度量定义为无量纲比率\n$$\n\\text{OP} = \\frac{\\left\\|\\boldsymbol{\\mu}_0 + \\alpha\\, \\mathbf{E}^{\\text{undamped}}\\right\\| - \\left\\|\\boldsymbol{\\mu}_0 + \\alpha\\, \\mathbf{E}^{\\text{damped}}\\right\\|}{\\left\\|\\boldsymbol{\\mu}_0 + \\alpha\\, \\mathbf{E}^{\\text{damped}}\\right\\|}.\n$$\n\n任务：\n- 对于每个测试案例，计算 $\\mathbf{E}^{\\text{undamped}}$、$\\mathbf{E}^{\\text{damped}}$、相应的总 QM 偶极矩大小 $\\left\\|\\boldsymbol{\\mu}_0 + \\alpha\\, \\mathbf{E}^{\\text{undamped}}\\right\\|$ 和 $\\left\\|\\boldsymbol{\\mu}_0 + \\alpha\\, \\mathbf{E}^{\\text{damped}}\\right\\|$，然后计算如上定义的过极化比率 $\\text{OP}$。\n- 所有量都必须以原子单位处理。最终答案是无量纲浮点数（输出中不需要物理单位）。\n- 此公式中不涉及角度，因此没有适用的角度单位。\n\n测试套件：\n1. 案例 A（平衡环境；中等边界阻尼）：\n   - $\\boldsymbol{\\mu}_0 = (0.5, 0, 0)$\n   - $\\alpha = 10$\n   - 电荷: $\\left[(+0.5, (3, 0, 0)), (-0.5, (-3, 0, 0))\\right]$\n   - $r_b = 4.0$\n   - $a = 0.4$\n   - $d = 1.5$\n2. 案例 B（极近电荷；强阻尼）：\n   - $\\boldsymbol{\\mu}_0 = (0, 0, 0.2)$\n   - $\\alpha = 20$\n   - 电荷: $\\left[(+1.0, (0.5, 0, 0))\\right]$\n   - $r_b = 1.0$\n   - $a = 0.6$\n   - $d = 1.0$\n3. 案例 C（远距离电荷；阻尼效应可忽略）：\n   - $\\boldsymbol{\\mu}_0 = (0.1, 0.1, 0.1)$\n   - $\\alpha = 5$\n   - 电荷: $\\left[(+0.2, (10, 0, 0)), (-0.2, (0, 10, 0))\\right]$\n   - $r_b = 3.0$\n   - $a = 0.5$\n   - $d = 1.0$\n4. 案例 D（边界附近的混合簇；中等阻尼）：\n   - $\\boldsymbol{\\mu}_0 = (0.3, -0.2, 0.1)$\n   - $\\alpha = 15$\n   - 电荷: $\\left[(+0.7, (1.0, 0.5, 0.0)), (-0.3, (-0.8, 0.2, 0.1)), (+0.4, (2.5, -1.0, 0.0))\\right]$\n   - $r_b = 1.5$\n   - $a = 0.35$\n   - $d = 1.2$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$），其中每个 $\\text{result}_k$ 是第 $k$ 个测试案例的过极化比率，四舍五入到六位小数。结果必须是浮点数。",
            "solution": "该问题已经过仔细验证，并被确定为有效。它在科学上基于经典静电学和线性响应理论在混合 QM/MM 模型中的应用原理，问题设定良好，提供了所有必要信息，并以客观、正式的语言表述。不存在矛盾、歧义或事实不准确之处。\n\n任务是为四个不同的测试案例计算一个定义的过极化度量 $\\text{OP}$，这些案例涉及一个可极化量子力学 (QM) 实体与一个由点电荷组成的经典分子力学 (MM) 环境相互作用。解决方案涉及在 QM/MM 边界处比较有和没有 Thole 型阻尼方案时系统的响应。所有计算均以原子单位进行。\n\n每个测试案例的总体步骤如下：\n\n1.  **计算总未阻尼电场 ($\\mathbf{E}^{\\text{undamped}}$)**\n    MM 环境由 $N$ 个点电荷 $q_i$ 组成，其位置矢量为 $\\mathbf{r}_i$ ($i=1, ..., N$)。原点是 QM 区域的参考点。由单个点电荷 $q_i$ 在原点施加的电场由库仑定律给出：\n    $$\n    \\mathbf{E}_i^{\\text{undamped}} = q_i \\frac{\\mathbf{r}_i}{\\|\\mathbf{r}_i\\|^3}\n    $$\n    总未阻尼电场 $\\mathbf{E}^{\\text{undamped}}$ 是所有点电荷产生的电场的矢量和：\n    $$\n    \\mathbf{E}^{\\text{undamped}} = \\sum_{i=1}^{N} \\mathbf{E}_i^{\\text{undamped}}\n    $$\n    对于每个测试案例，我们计算这个矢量和。\n\n2.  **计算总阻尼电场 ($\\mathbf{E}^{\\text{damped}}$)**\n    为减轻靠近 QM 区域的电荷引起的过极化，应用了一个距离依赖的阻尼函数。对于距离原点为 $\\|\\mathbf{r}_i\\|$ 的每个电荷 $q_i$，我们首先检查它是否位于边界半径 $r_b$ 之内。\n    - 如果 $\\|\\mathbf{r}_i\\| \\ge r_b$，则该电荷的贡献是未阻尼的：$\\mathbf{E}_i^{\\text{damped}} = \\mathbf{E}_i^{\\text{undamped}}$。\n    - 如果 $\\|\\mathbf{r}_i\\|  r_b$，则其贡献被一个 Thole 型阻尼因子 $s(\\|\\mathbf{r}_i\\|)$ 衰减：\n      $$\n      s(\\|\\mathbf{r}_i\\|) = 1 - \\exp\\left(-a \\left(\\frac{\\|\\mathbf{r}_i\\|}{d}\\right)^3\\right)\n      $$\n      其中 $a$ 是一个无量纲参数，$d$ 是一个特征长度。那么阻尼电场的贡献为：\n      $$\n      \\mathbf{E}_i^{\\text{damped}} = s(\\|\\mathbf{r}_i\\|) \\cdot \\mathbf{E}_i^{\\text{undamped}} = s(\\|\\mathbf{r}_i\\|) q_i \\frac{\\mathbf{r}_i}{\\|\\mathbf{r}_i\\|^3}\n      $$\n    总阻尼电场 $\\mathbf{E}^{\\text{damped}}$ 是这些（可能被）阻尼的贡献的矢量和：\n    $$\n    \\mathbf{E}^{\\text{damped}} = \\sum_{i=1}^{N} \\mathbf{E}_i^{\\text{damped}}\n    $$\n\n3.  **计算总偶极矩大小**\n    QM 区域具有永久偶极矩 $\\boldsymbol{\\mu}_0$ 和各向同性极化率 $\\alpha$。总偶极矩 $\\boldsymbol{\\mu}_{\\text{QM}}$ 是永久偶极和感生偶极 $\\boldsymbol{\\mu}_{\\text{ind}} = \\alpha \\mathbf{E}$ 的和。\n    \n    在未阻尼情况下的总偶极矩为：\n    $$\n    \\boldsymbol{\\mu}_{\\text{undamped}} = \\boldsymbol{\\mu}_0 + \\alpha \\mathbf{E}^{\\text{undamped}}\n    $$\n    其大小是一个标量，为 $\\|\\boldsymbol{\\mu}_{\\text{undamped}}\\|$。\n\n    在阻尼情况下的总偶极矩为：\n    $$\n    \\boldsymbol{\\mu}_{\\text{damped}} = \\boldsymbol{\\mu}_0 + \\alpha \\mathbf{E}^{\\text{damped}}\n    $$\n    其大小为 $\\|\\boldsymbol{\\mu}_{\\text{damped}}\\|$。\n\n4.  **计算过极化度量 ($\\text{OP}$)**\n    过极化度量定义为未阻尼和阻尼总偶极矩大小之间的分数差，相对于阻尼后的大小：\n    $$\n    \\text{OP} = \\frac{\\|\\boldsymbol{\\mu}_0 + \\alpha \\mathbf{E}^{\\text{undamped}}\\| - \\|\\boldsymbol{\\mu}_0 + \\alpha \\mathbf{E}^{\\text{damped}}\\|}{\\|\\boldsymbol{\\mu}_0 + \\alpha \\mathbf{E}^{\\text{damped}}\\|} = \\frac{\\|\\boldsymbol{\\mu}_{\\text{undamped}}\\| - \\|\\boldsymbol{\\mu}_{\\text{damped}}\\|}{\\|\\boldsymbol{\\mu}_{\\text{damped}}\\|}\n    $$\n    为每个测试案例计算该值。如果 $\\|\\boldsymbol{\\mu}_{\\text{damped}}\\|$ 为零，则该表达式无定义；然而，考虑到非零的永久偶极和电荷配置，这种情况在所提供的测试案例中不会发生。\n\n这个完整的程序以编程方式实现，以求解四个指定测试案例中每一个的 $\\text{OP}$ 度量。该实现依赖于矢量代数，根据公式正确应用范数、标量-矢量积和矢量和。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the overpolarization benchmark metric for a series of QM/MM test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {'mu0': (0.5, 0, 0), 'alpha': 10.0, 'charges': [(0.5, (3, 0, 0)), (-0.5, (-3, 0, 0))], 'rb': 4.0, 'a': 0.4, 'd': 1.5},\n        # Case B\n        {'mu0': (0, 0, 0.2), 'alpha': 20.0, 'charges': [(1.0, (0.5, 0, 0))], 'rb': 1.0, 'a': 0.6, 'd': 1.0},\n        # Case C\n        {'mu0': (0.1, 0.1, 0.1), 'alpha': 5.0, 'charges': [(0.2, (10, 0, 0)), (-0.2, (0, 10, 0))], 'rb': 3.0, 'a': 0.5, 'd': 1.0},\n        # Case D\n        {'mu0': (0.3, -0.2, 0.1), 'alpha': 15.0, 'charges': [(0.7, (1.0, 0.5, 0.0)), (-0.3, (-0.8, 0.2, 0.1)), (0.4, (2.5, -1.0, 0.0))], 'rb': 1.5, 'a': 0.35, 'd': 1.2},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        mu0 = np.array(case['mu0'], dtype=float)\n        alpha = float(case['alpha'])\n        charges = [(float(q), np.array(r, dtype=float)) for q, r in case['charges']]\n        rb = float(case['rb'])\n        a = float(case['a'])\n        d = float(case['d'])\n\n        # Initialize total electric field vectors\n        E_undamped = np.zeros(3)\n        E_damped = np.zeros(3)\n\n        for q, r_vec in charges:\n            r_norm = np.linalg.norm(r_vec)\n\n            # Avoid division by zero, though not present in test data\n            if r_norm == 0:\n                continue\n\n            # Calculate undamped field contribution\n            E_i_undamped = q * r_vec / (r_norm**3)\n            E_undamped += E_i_undamped\n\n            # Calculate damped field contribution\n            if r_norm  rb:\n                s = 1 - np.exp(-a * (r_norm / d)**3)\n                E_i_damped = s * E_i_undamped\n            else:\n                E_i_damped = E_i_undamped\n            \n            E_damped += E_i_damped\n\n        # Calculate total dipole moments (undamped and damped)\n        mu_undamped = mu0 + alpha * E_undamped\n        mu_damped = mu0 + alpha * E_damped\n\n        # Calculate their magnitudes\n        mag_mu_undamped = np.linalg.norm(mu_undamped)\n        mag_mu_damped = np.linalg.norm(mu_damped)\n\n        # Calculate the overpolarization metric (OP)\n        # Check for division by zero, though unlikely in these cases\n        if mag_mu_damped == 0.0:\n            # If the damped magnitude is zero, the OP is conceptually infinite\n            # if the undamped one is non-zero, or zero if both are zero.\n            # We assume this does not happen based on the problem setup.\n            op_metric = 0.0 if mag_mu_undamped == 0.0 else float('inf')\n        else:\n            op_metric = (mag_mu_undamped - mag_mu_damped) / mag_mu_damped\n\n        results.append(round(op_metric, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "可靠的分子动力学模拟要求作用在原子上的力必须是势能的精确导数。确保解析梯度与能量面之间的一致性是一个关键的验证步骤，在处理复杂的QM/MM共价边界 (covalent boundary) 时尤其重要。本压轴练习将要求您为一个模型体系同时实现解析梯度和数值有限差分梯度，通过对比二者来验证力实现的正确性，这是连接能量模型和动态模拟的桥梁。",
            "id": "3849214",
            "problem": "您将获得一个最小的混合量子力学/分子力学 (QM/MM) 玩具模型，该模型旨在评估两种嵌入方案在共价边界处的力一致性。该系统由三个位于三维空间中的原子核组成：一个位置为 $\\mathbf{r}_A \\in \\mathbb{R}^3$ 的量子力学 (QM) 原子 $A$，一个位置为 $\\mathbf{r}_C \\in \\mathbb{R}^3$ 的 QM 原子 $C$，以及一个位置为 $\\mathbf{r}_B \\in \\mathbb{R}^3$ 的分子力学 (MM) 边界原子 $B$。QM 区域是线性可极化的，并通过连接原子构造跨越共价边界与 MM 区域相连。外部 MM 环境由位于位置 $\\{\\mathbf{R}_i\\}$ 的点电荷 $\\{q_i\\}$ 组成。\n\n所有计算均在约化的无量纲单位中进行：位置以无量纲长度单位计，能量以无量纲能量单位计，电荷以无量纲电荷单位计。无需进行物理单位换算。\n\n此模型中的总能量定义为\n$$\nE_{\\text{tot}}(\\mathbf{r}_A,\\mathbf{r}_B,\\mathbf{r}_C) \\;=\\; E_{\\text{QM,int}} \\;+\\; E_{\\text{pol}} \\;+\\; E_{\\text{link}} \\,,\n$$\n其中：\n- QM 内部谐振能量为\n$$\nE_{\\text{QM,int}} \\;=\\; \\tfrac{1}{2} \\, k_{\\text{qm}} \\, \\big\\|\\mathbf{r}_A - \\mathbf{r}_C\\big\\|^2 \\,,\n$$\n劲度系数为 $k_{\\text{qm}} > 0$。\n- 极化耦合项（静电嵌入）为\n$$\nE_{\\text{pol}} \\;=\\; - \\alpha \\, \\big(\\mathbf{r}_A - \\mathbf{r}_C\\big) \\cdot \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{center}}) \\,,\n$$\n其中 $\\alpha \\ge 0$ 是一个标量极化率，$\\mathbf{r}_{\\text{center}} = \\tfrac{1}{2}(\\mathbf{r}_A + \\mathbf{r}_C)$ 是 QM 区域的有效中心，由 MM 点电荷产生的外部电场为\n$$\n\\mathbf{E}_{\\text{ext}}(\\mathbf{r}) \\;=\\; \\sum_{i} q_i \\, \\frac{\\mathbf{r} - \\mathbf{R}_i}{\\big\\|\\mathbf{r} - \\mathbf{R}_i\\big\\|^3} \\,.\n$$\n对于机械嵌入，设置 $\\alpha = 0$（即不存在极化耦合项）。\n- 共价边界连接原子校正使用连接原子 $L$ 的几何放置，其由关系式 $\\mathbf{r}_L = \\mathbf{r}_A + \\lambda (\\mathbf{r}_A - \\mathbf{r}_B)$ 隐式定义，其中 $0  \\lambda  1$ 是一个固定标量，产生一个有效连接键长 $\\lambda \\, \\big\\|\\mathbf{r}_A - \\mathbf{r}_B\\big\\|$。连接能量被建模为一个谐振惩罚项：\n$$\nE_{\\text{link}} \\;=\\; \\tfrac{1}{2} \\, k_{\\text{link}} \\, \\Big( \\lambda \\, \\big\\|\\mathbf{r}_A - \\mathbf{r}_B\\big\\| - r_{\\text{eq}} \\Big)^2 \\,,\n$$\n劲度系数为 $k_{\\text{link}} > 0$，平衡键长为 $r_{\\text{eq}} > 0$。\n\n您的任务是编写一个程序，通过将 $E_{\\text{tot}}$ 的解析梯度与通过中心差分计算的梯度有限差分近似值进行比较，来验证力的一致性。具体来说，对于每个测试用例，请计算：\n1. 基于上述定义的解析梯度 $\\nabla_{\\mathbf{r}_A,\\mathbf{r}_B,\\mathbf{r}_C} E_{\\text{tot}}$。\n2. 使用中心差分的有限差分梯度，其中固定位移步长 $h$ 独立地应用于 $\\mathbf{r}_A$、$\\mathbf{r}_B$ 和 $\\mathbf{r}_C$ 的每个笛卡尔分量，同时保持所有其他参数固定。对每个分量 $j$ 使用标准中心差分公式 $(E(\\mathbf{x}+h\\mathbf{e}_j) - E(\\mathbf{x}-h\\mathbf{e}_j)) / (2h)$。\n3. 在所有 9 个分量（三个原子乘以三个坐标）中，解析梯度和有限差分梯度之间逐分量的最大绝对差值。\n\n对于每个测试用例，返回一个等于最大绝对差值的浮点数。输出必须是单行，包含这些用逗号分隔并用方括号括起来的数字。\n\n实现以下测试套件，该套件检验静电和机械嵌入、边界几何敏感性以及无外部场的边缘情况：\n- 测试用例 1 (静电嵌入): $k_{\\text{qm}} = 1.0$, $\\alpha = 0.5$, $k_{\\text{link}} = 2.0$, $r_{\\text{eq}} = 1.1$, $\\lambda = 0.8$, $h = 10^{-6}$; $\\mathbf{r}_A = [0.5,-0.2,0.1]$, $\\mathbf{r}_B = [1.0,0.0,-0.1]$, $\\mathbf{r}_C = [0.0,0.3,0.0]$; MM 电荷: $(q_1,\\mathbf{R}_1) = (0.3,[2.0,0.0,0.0])$, $(q_2,\\mathbf{R}_2) = (-0.2,[0.0,2.0,1.0])$.\n- 测试用例 2 (机械嵌入): 与测试用例 1 相同，除了 $\\alpha = 0.0$。\n- 测试用例 3 (静电嵌入，短边界): $k_{\\text{qm}} = 0.7$, $\\alpha = 0.4$, $k_{\\text{link}} = 3.0$, $r_{\\text{eq}} = 0.35$, $\\lambda = 0.9$, $h = 10^{-6}$; $\\mathbf{r}_A = [0.5,-0.2,0.1]$, $\\mathbf{r}_B = [0.6,-0.15,0.08]$, $\\mathbf{r}_C = [-0.1,0.25,0.05]$; MM 电荷: $(q_1,\\mathbf{R}_1) = (0.25,[1.5,-0.5,0.5])$, $(q_2,\\mathbf{R}_2) = (0.1,[-1.0,1.0,0.5])$.\n- 测试用例 4 (无外部场): $k_{\\text{qm}} = 1.2$, $\\alpha = 0.6$, $k_{\\text{link}} = 1.5$, $r_{\\text{eq}} = 0.9$, $\\lambda = 0.85$, $h = 10^{-6}$; $\\mathbf{r}_A = [0.2,0.1,-0.2]$, $\\mathbf{r}_B = [0.4,0.0,0.0]$, $\\mathbf{r}_C = [-0.1,0.2,0.1]$; MM 电荷: 无。\n\n您的程序应产生单行输出，其中包含用方括号括起来并以逗号分隔的结果（例如，$\\big[$result1,result2,result3,result4$\\big]$）。所有打印的数字必须是无量纲的约化单位，不得使用角度或百分比。",
            "solution": "该问题被认为是有效的，因为它提出了一个基于计算化学生物学标准原理的、科学上合理、适定且自洽的计算任务。该模型虽然简化，但代表了混合 QM/MM 方法。所有参数和条件都已明确定义。\n\n该任务的核心是通过有限差分验证总能量 $E_{\\text{tot}}$ 的解析推导梯度与其数值近似之间的一致性。总能量由下式给出：\n$$\nE_{\\text{tot}}(\\mathbf{r}_A,\\mathbf{r}_B,\\mathbf{r}_C) \\;=\\; E_{\\text{QM,int}} \\;+\\; E_{\\text{pol}} \\;+\\; E_{\\text{link}}\n$$\n我们必须计算 $E_{\\text{tot}}$ 相对于三个原子位置的梯度 $\\nabla_{\\mathbf{r}_A, \\mathbf{r}_B, \\mathbf{r}_C} E_{\\text{tot}}$。这是一个 9 维向量。我们将推导每一项对 $\\mathbf{r}_A$、$\\mathbf{r}_B$ 和 $\\mathbf{r}_C$ 梯度的贡献的解析表达式。\n\n**1. QM 内部能量的梯度**\nQM 内部谐振能量为 $E_{\\text{QM,int}} = \\tfrac{1}{2} \\, k_{\\text{qm}} \\, \\big\\|\\mathbf{r}_A - \\mathbf{r}_C\\big\\|^2$。\n令 $\\mathbf{d}_{AC} = \\mathbf{r}_A - \\mathbf{r}_C$。\n梯度为：\n$$\n\\nabla_{\\mathbf{r}_A} E_{\\text{QM,int}} = k_{\\text{qm}} (\\mathbf{r}_A - \\mathbf{r}_C) = k_{\\text{qm}} \\mathbf{d}_{AC}\n$$\n$$\n\\nabla_{\\mathbf{r}_C} E_{\\text{QM,int}} = k_{\\text{qm}} (\\mathbf{r}_C - \\mathbf{r}_A) = -k_{\\text{qm}} \\mathbf{d}_{AC}\n$$\n$$\n\\nabla_{\\mathbf{r}_B} E_{\\text{QM,int}} = \\mathbf{0}\n$$\n\n**2. 连接原子能量的梯度**\n连接能量为 $E_{\\text{link}} = \\tfrac{1}{2} \\, k_{\\text{link}} \\, \\Big( \\lambda \\, \\big\\|\\mathbf{r}_A - \\mathbf{r}_B\\big\\| - r_{\\text{eq}} \\Big)^2$。\n令 $\\mathbf{d}_{AB} = \\mathbf{r}_A - \\mathbf{r}_B$ 及其范数 $d_{AB} = \\big\\|\\mathbf{d}_{AB}\\big\\|$。使用链式法则 $\\nabla f(g(\\mathbf{r})) = f'(g(\\mathbf{r})) \\nabla g(\\mathbf{r})$，其中 $g = d_{AB}$ 且 $f(x) = \\tfrac{1}{2} k_{\\text{link}}(\\lambda x-r_{\\text{eq}})^2$。\n范数的导数为 $\\nabla_{\\mathbf{r}_A} d_{AB} = \\mathbf{d}_{AB} / d_{AB}$ 且 $\\nabla_{\\mathbf{r}_B} d_{AB} = -\\mathbf{d}_{AB} / d_{AB}$。\n$f(x)$ 的导数为 $f'(x) = k_{\\text{link}}(\\lambda x-r_{\\text{eq}})\\lambda$。\n梯度为：\n$$\n\\nabla_{\\mathbf{r}_A} E_{\\text{link}} = k_{\\text{link}} \\lambda (\\lambda d_{AB} - r_{\\text{eq}}) \\frac{\\mathbf{d}_{AB}}{d_{AB}} = \\lambda k_{\\text{link}} \\left(\\lambda - \\frac{r_{\\text{eq}}}{d_{AB}}\\right) \\mathbf{d}_{AB}\n$$\n$$\n\\nabla_{\\mathbf{r}_B} E_{\\text{link}} = -k_{\\text{link}} \\lambda (\\lambda d_{AB} - r_{\\text{eq}}) \\frac{\\mathbf{d}_{AB}}{d_{AB}} = -\\lambda k_{\\text{link}} \\left(\\lambda - \\frac{r_{\\text{eq}}}{d_{AB}}\\right) \\mathbf{d}_{AB}\n$$\n$$\n\\nabla_{\\mathbf{r}_C} E_{\\text{link}} = \\mathbf{0}\n$$\n这些表达式在 $d_{AB} > 0$ 时有效。\n\n**3. 极化能量的梯度**\n极化能量为 $E_{\\text{pol}} = - \\alpha \\, \\mathbf{p} \\cdot \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}})$，其中 $\\mathbf{p} = \\mathbf{r}_A - \\mathbf{r}_C$ 且 $\\mathbf{r}_{\\text{c}} = \\tfrac{1}{2}(\\mathbf{r}_A + \\mathbf{r}_C)$。如果 $\\alpha=0$，此项及其梯度为零。对于 $\\alpha > 0$，我们应用乘法法则和链式法则。\n使用恒等式 $\\nabla(\\mathbf{u} \\cdot \\mathbf{v}) = (\\nabla \\mathbf{u})^T\\mathbf{v} + (\\nabla \\mathbf{v})^T\\mathbf{u}$：\n$$\n\\nabla_{\\mathbf{r}_k} E_{\\text{pol}} = -\\alpha \\left( (\\nabla_{\\mathbf{r}_k} \\mathbf{p})^T \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) + (\\nabla_{\\mathbf{r}_k} \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}))^T \\mathbf{p} \\right)\n$$\n其中 $k \\in \\{A, B, C\\}$。\n所需的雅可比矩阵为：\n$\\nabla_{\\mathbf{r}_A} \\mathbf{p} = \\mathbf{I}$，$\\nabla_{\\mathbf{r}_C} \\mathbf{p} = -\\mathbf{I}$，$\\nabla_{\\mathbf{r}_B} \\mathbf{p} = \\mathbf{0}$。\n$\\nabla_{\\mathbf{r}_A} \\mathbf{r}_{\\text{c}} = \\tfrac{1}{2}\\mathbf{I}$，$\\nabla_{\\mathbf{r}_C} \\mathbf{r}_{\\text{c}} = \\tfrac{1}{2}\\mathbf{I}$，$\\nabla_{\\mathbf{r}_B} \\mathbf{r}_{\\text{c}} = \\mathbf{0}$。\n\n令 $\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}) = \\nabla_{\\mathbf{r}} \\mathbf{E}_{\\text{ext}}(\\mathbf{r})$ 为外部电场的雅可比矩阵。根据链式法则，$\\nabla_{\\mathbf{r}_A} \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) = \\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}}) (\\nabla_{\\mathbf{r}_A} \\mathbf{r}_{\\text{c}}) = \\tfrac{1}{2}\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}})$。\n\n对于原子 $A$：\n$$\n\\nabla_{\\mathbf{r}_A} E_{\\text{pol}} = -\\alpha \\left( \\mathbf{I}^T \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) + \\left(\\tfrac{1}{2}\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}})\\right)^T \\mathbf{p} \\right) = -\\alpha \\left( \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) + \\tfrac{1}{2}\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}})^T \\mathbf{p} \\right)\n$$\n对于原子 $C$：\n$$\n\\nabla_{\\mathbf{r}_C} E_{\\text{pol}} = -\\alpha \\left( (-\\mathbf{I})^T \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) + \\left(\\tfrac{1}{2}\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}})\\right)^T \\mathbf{p} \\right) = -\\alpha \\left( -\\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) + \\tfrac{1}{2}\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}})^T \\mathbf{p} \\right)\n$$\n对于原子 $B$，梯度为 $\\mathbf{0}$。\n\n雅可比矩阵 $\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r})$ 是 $\\mathbf{E}_{\\text{ext}}(\\mathbf{r}) = \\sum_{i} q_i \\frac{\\mathbf{r} - \\mathbf{R}_i}{\\big\\|\\mathbf{r} - \\mathbf{R}_i\\big\\|^3}$ 的梯度。它是一个对称张量（静电势的黑塞矩阵的负值），由下式给出：\n$$\n\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}) = \\sum_i q_i \\left( \\frac{\\mathbf{I}}{\\|\\mathbf{r} - \\mathbf{R}_i\\|^3} - \\frac{3 (\\mathbf{r} - \\mathbf{R}_i) \\otimes (\\mathbf{r} - \\mathbf{R}_i)}{\\|\\mathbf{r} - \\mathbf{R}_i\\|^5} \\right)\n$$\n其中 $\\otimes$ 表示外积。由于 $\\mathbf{J}_{\\mathbf{E}}$ 是对称的，所以 $\\mathbf{J}_{\\mathbf{E}}^T = \\mathbf{J}_{\\mathbf{E}}$。\n\n**总解析梯度总结**\n\n$\\nabla_{\\mathbf{r}_A} E_{\\text{tot}} = k_{\\text{qm}}\\mathbf{d}_{AC} + \\lambda k_{\\text{link}}\\left(\\lambda - \\frac{r_{\\text{eq}}}{d_{AB}}\\right)\\mathbf{d}_{AB} - \\alpha \\left( \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) + \\tfrac{1}{2}\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}})\\mathbf{p} \\right)$\n$\\nabla_{\\mathbf{r}_B} E_{\\text{tot}} = -\\lambda k_{\\text{link}}\\left(\\lambda - \\frac{r_{\\text{eq}}}{d_{AB}}\\right)\\mathbf{d}_{AB}$\n$\\nabla_{\\mathbf{r}_C} E_{\\text{tot}} = - k_{\\text{qm}}\\mathbf{d}_{AC} - \\alpha \\left( -\\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) + \\tfrac{1}{2}\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}})\\mathbf{p} \\right)$\n\n对每个测试用例，这些公式被实现并与数值有限差分计算进行比较。每个分量 $j$ 的有限差分梯度使用中心差分公式计算：\n$$\n(\\nabla E)_j = \\frac{E(\\mathbf{x}+h\\mathbf{e}_j) - E(\\mathbf{x}-h\\mathbf{e}_j)}{2h}\n$$\n其中 $\\mathbf{x}$ 是所有原子坐标的 9 维向量，$\\mathbf{e}_j$ 是沿第 $j$ 个分量的单位向量，$h$ 是一个小位移。然后确定解析梯度分量和数值梯度分量之间的最大绝对差值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates and solves the QM/MM force consistency problem.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"k_qm\": 1.0, \"alpha\": 0.5, \"k_link\": 2.0, \"r_eq\": 1.1, \"lambda_\": 0.8, \"h\": 1e-6,\n            \"rA\": np.array([0.5, -0.2, 0.1]),\n            \"rB\": np.array([1.0, 0.0, -0.1]),\n            \"rC\": np.array([0.0, 0.3, 0.0]),\n            \"mm_charges\": [(0.3, np.array([2.0, 0.0, 0.0])), (-0.2, np.array([0.0, 2.0, 1.0]))]\n        },\n        {\n            \"k_qm\": 1.0, \"alpha\": 0.0, \"k_link\": 2.0, \"r_eq\": 1.1, \"lambda_\": 0.8, \"h\": 1e-6,\n            \"rA\": np.array([0.5, -0.2, 0.1]),\n            \"rB\": np.array([1.0, 0.0, -0.1]),\n            \"rC\": np.array([0.0, 0.3, 0.0]),\n            \"mm_charges\": [(0.3, np.array([2.0, 0.0, 0.0])), (-0.2, np.array([0.0, 2.0, 1.0]))]\n        },\n        {\n            \"k_qm\": 0.7, \"alpha\": 0.4, \"k_link\": 3.0, \"r_eq\": 0.35, \"lambda_\": 0.9, \"h\": 1e-6,\n            \"rA\": np.array([0.5, -0.2, 0.1]),\n            \"rB\": np.array([0.6, -0.15, 0.08]),\n            \"rC\": np.array([-0.1, 0.25, 0.05]),\n            \"mm_charges\": [(0.25, np.array([1.5, -0.5, 0.5])), (0.1, np.array([-1.0, 1.0, 0.5]))]\n        },\n        {\n            \"k_qm\": 1.2, \"alpha\": 0.6, \"k_link\": 1.5, \"r_eq\": 0.9, \"lambda_\": 0.85, \"h\": 1e-6,\n            \"rA\": np.array([0.2, 0.1, -0.2]),\n            \"rB\": np.array([0.4, 0.0, 0.0]),\n            \"rC\": np.array([-0.1, 0.2, 0.1]),\n            \"mm_charges\": []\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        rA, rB, rC = params[\"rA\"], params[\"rB\"], params[\"rC\"]\n        \n        grad_analytic = calculate_analytic_gradient(rA, rB, rC, params)\n        grad_fd = calculate_fd_gradient(rA, rB, rC, params)\n        \n        max_diff = np.max(np.abs(grad_analytic - grad_fd))\n        results.append(max_diff)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef calculate_energy(rA, rB, rC, params):\n    \"\"\"Computes the total QM/MM energy.\"\"\"\n    k_qm = params[\"k_qm\"]\n    alpha = params[\"alpha\"]\n    k_link = params[\"k_link\"]\n    r_eq = params[\"r_eq\"]\n    lambda_ = params[\"lambda_\"]\n    mm_charges = params[\"mm_charges\"]\n\n    # E_QM,int\n    d_AC = rA - rC\n    E_qm_int = 0.5 * k_qm * np.dot(d_AC, d_AC)\n\n    # E_link\n    d_AB = rA - rB\n    norm_d_AB = np.linalg.norm(d_AB)\n    E_link = 0.5 * k_link * (lambda_ * norm_d_AB - r_eq)**2\n\n    # E_pol\n    E_pol = 0.0\n    if alpha > 0 and mm_charges:\n        r_center = 0.5 * (rA + rC)\n        E_ext = _calculate_E_ext(r_center, mm_charges)\n        E_pol = -alpha * np.dot(d_AC, E_ext)\n\n    return E_qm_int + E_link + E_pol\n\n\ndef _calculate_E_ext(r, mm_charges):\n    \"\"\"Computes the external electric field from MM charges.\"\"\"\n    E = np.zeros(3)\n    for q, R in mm_charges:\n        u = r - R\n        norm_u = np.linalg.norm(u)\n        if norm_u > 0:\n            E += q * u / (norm_u**3)\n    return E\n\n\ndef _calculate_J_E(r, mm_charges):\n    \"\"\"Computes the Jacobian of the external electric field.\"\"\"\n    J = np.zeros((3, 3))\n    I = np.identity(3)\n    for q, R in mm_charges:\n        u = r - R\n        norm_u = np.linalg.norm(u)\n        if norm_u > 0:\n            norm_u_3 = norm_u**3\n            norm_u_5 = norm_u**5\n            outer_u = np.outer(u, u)\n            J += q * (I / norm_u_3 - 3 * outer_u / norm_u_5)\n    return J\n\n\ndef calculate_analytic_gradient(rA, rB, rC, params):\n    \"\"\"Computes the analytic gradient of the total energy.\"\"\"\n    k_qm, alpha, k_link = params[\"k_qm\"], params[\"alpha\"], params[\"k_link\"]\n    r_eq, lambda_ = params[\"r_eq\"], params[\"lambda_\"]\n    mm_charges = params[\"mm_charges\"]\n\n    grad_A = np.zeros(3)\n    grad_B = np.zeros(3)\n    grad_C = np.zeros(3)\n\n    # Gradient of E_QM,int\n    d_AC = rA - rC\n    grad_A += k_qm * d_AC\n    grad_C -= k_qm * d_AC\n\n    # Gradient of E_link\n    d_AB = rA - rB\n    norm_d_AB = np.linalg.norm(d_AB)\n    if norm_d_AB > 0:\n        factor = lambda_ * k_link * (lambda_ - r_eq / norm_d_AB)\n        grad_link_A = factor * d_AB\n        grad_A += grad_link_A\n        grad_B -= grad_link_A\n\n    # Gradient of E_pol\n    if alpha > 0 and mm_charges:\n        r_center = 0.5 * (rA + rC)\n        E_ext = _calculate_E_ext(r_center, mm_charges)\n        J_E = _calculate_J_E(r_center, mm_charges)\n        \n        p = d_AC\n        J_E_dot_p = np.dot(J_E, p)\n        \n        grad_A -= alpha * (E_ext + 0.5 * J_E_dot_p)\n        grad_C -= alpha * (-E_ext + 0.5 * J_E_dot_p)\n\n    return np.concatenate((grad_A, grad_B, grad_C))\n\n\ndef calculate_fd_gradient(rA, rB, rC, params):\n    \"\"\"Computes the finite-difference gradient of the total energy.\"\"\"\n    h = params[\"h\"]\n    grad_fd = np.zeros(9)\n    coords = np.concatenate((rA, rB, rC))\n\n    for i in range(9):\n        coords_plus = coords.copy()\n        coords_minus = coords.copy()\n        \n        coords_plus[i] += h\n        coords_minus[i] -= h\n        \n        rA_p, rB_p, rC_p = coords_plus[0:3], coords_plus[3:6], coords_plus[6:9]\n        rA_m, rB_m, rC_m = coords_minus[0:3], coords_minus[3:6], coords_minus[6:9]\n        \n        E_plus = calculate_energy(rA_p, rB_p, rC_p, params)\n        E_minus = calculate_energy(rA_m, rB_m, rC_m, params)\n        \n        grad_fd[i] = (E_plus - E_minus) / (2 * h)\n        \n    return grad_fd\n\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}