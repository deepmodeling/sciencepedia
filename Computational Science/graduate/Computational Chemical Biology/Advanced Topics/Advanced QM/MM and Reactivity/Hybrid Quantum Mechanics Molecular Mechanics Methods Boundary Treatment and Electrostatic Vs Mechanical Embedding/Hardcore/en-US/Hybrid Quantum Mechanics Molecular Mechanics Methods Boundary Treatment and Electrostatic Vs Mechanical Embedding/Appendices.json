{
    "hands_on_practices": [
        {
            "introduction": "This exercise forms the cornerstone of understanding hybrid QM/MM models by breaking down the total interaction energy into its fundamental components. You will implement the energy expressions for electrostatic, van der Waals, and bonded interactions that couple the QM and MM regions. By calculating these terms for both mechanical and electrostatic embedding schemes, you will gain a practical appreciation for how these foundational models differ in their treatment of the QM-MM interface .",
            "id": "3849241",
            "problem": "You are tasked with constructing, from first principles, a computational decomposition of hybrid Quantum Mechanics/Molecular Mechanics (QM/MM) interaction energy for a minimal solute–solvent system using two embedding schemes: mechanical embedding and electrostatic embedding. The system consists of a single Quantum Mechanics (QM) atom and two Molecular Mechanics (MM) atoms, one of which is directly bonded across the QM/MM boundary. Your program must separate the hybrid energy $E_{\\mathrm{QM/MM}}$ into electrostatic, van der Waals, and bonded terms and must explicitly demonstrate how each term arises from the underlying Hamiltonian.\n\nBegin from foundational laws and definitions that are standard in computational chemical biology:\n- The Born–Oppenheimer approximation, which separates electronic and nuclear motion, yielding a Molecular Mechanics (MM) force-field description for nuclei and an electronic Hamiltonian for electrons in the Quantum Mechanics (QM) region.\n- The classical electrostatic interaction derived from Coulomb’s law, with potential energy $E_{\\mathrm{Coul}} = k_{e}\\sum_{i<j}\\dfrac{q_{i}q_{j}}{r_{ij}}$, where $k_e$ is the Coulomb constant in compatible units.\n- The Lennard–Jones (LJ) $12$–$6$ potential for van der Waals interactions, given by $E_{\\mathrm{LJ}}(i,j) = 4\\epsilon_{ij}\\left[\\left(\\dfrac{\\sigma_{ij}}{r_{ij}}\\right)^{12}-\\left(\\dfrac{\\sigma_{ij}}{r_{ij}}\\right)^{6}\\right]$, with Lorentz–Berthelot mixing rules $\\sigma_{ij} = \\dfrac{\\sigma_{i}+\\sigma_{j}}{2}$ and $\\epsilon_{ij} = \\sqrt{\\epsilon_{i}\\epsilon_{j}}$.\n- The harmonic bonded potential $E_{\\mathrm{bond}} = \\dfrac{1}{2}k_{\\mathrm{b}}(r-r_{0})^{2}$ for a bond that crosses the QM/MM boundary, together with a link-atom capping treatment in the QM model to maintain valence at the boundary.\n\nYou must show how the interaction energy components originate from the underlying Hamiltonian:\n- For mechanical embedding, the QM Hamiltonian is evaluated in vacuum for the model system (QM region plus link atom), while cross-region interactions are accounted for by the MM force field. In the subtractive ONIOM-like mechanical scheme, the hybrid energy partitions into MM terms such that cross-region electrostatics and van der Waals arise from classical potentials, and the boundary bond correction is a difference of harmonic terms across the real and model systems.\n- For electrostatic embedding, the QM Hamiltonian includes the external field of MM point charges, leading to an additional electrostatic interaction between MM charges and the QM electron density and nuclei. In this problem, approximate the expectation of the QM–MM electrostatic interaction by an effective QM atomic charge $q_{\\mathrm{A}}^{\\mathrm{eff}}$ localized on the QM atom.\n\nScientific realism constraints:\n- Use the Coulomb constant $k_{e} = 138.935456$ in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}\\,\\mathrm{e}^{-2}$.\n- Distances must be in $\\mathrm{nm}$.\n- LJ $\\epsilon$ must be in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ and $\\sigma$ in $\\mathrm{nm}$.\n- Charges must be in units of elementary charge $\\mathrm{e}$.\n- Bond force constants $k_{\\mathrm{b}}$ must be in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$ and equilibrium bond lengths $r_{0}$ in $\\mathrm{nm}$.\n- Energies must be reported in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$.\n\nDefinitions of the quantities to compute:\n- Mechanical embedding electrostatic interaction:\n$$\nE_{\\mathrm{elec}}^{\\mathrm{mech}} = k_{e}\\,q_{\\mathrm{A}}^{\\mathrm{MM}}\\left(\\frac{q_{\\mathrm{B}}}{r_{\\mathrm{AB}}} + \\frac{q_{\\mathrm{C}}}{r_{\\mathrm{AC}}}\\right),\n$$\nwhere $q_{\\mathrm{A}}^{\\mathrm{MM}}$ is the fixed MM charge assigned to the QM atom for mechanical embedding, and $q_{\\mathrm{B}}, q_{\\mathrm{C}}$ are MM atom charges.\n- Electrostatic embedding electrostatic interaction (approximated by an effective QM point charge):\n$$\nE_{\\mathrm{elec}}^{\\mathrm{EE}} = k_{e}\\,q_{\\mathrm{A}}^{\\mathrm{eff}}\\left(\\frac{q_{\\mathrm{B}}}{r_{\\mathrm{AB}}} + \\frac{q_{\\mathrm{C}}}{r_{\\mathrm{AC}}}\\right),\n$$\nwhere $q_{\\mathrm{A}}^{\\mathrm{eff}}$ approximates the QM atom’s net effective charge including electronic polarization.\n- Van der Waals interaction (nonbonded only; exclude directly bonded neighbors):\n$$\nE_{\\mathrm{vdW}} = E_{\\mathrm{LJ}}(\\mathrm{A},\\mathrm{C}) = 4\\,\\epsilon_{\\mathrm{AC}}\\left[\\left(\\frac{\\sigma_{\\mathrm{AC}}}{r_{\\mathrm{AC}}}\\right)^{12}-\\left(\\frac{\\sigma_{\\mathrm{AC}}}{r_{\\mathrm{AC}}}\\right)^{6}\\right],\n$$\nwith $\\sigma_{\\mathrm{AC}} = \\dfrac{\\sigma_{\\mathrm{A}}+\\sigma_{\\mathrm{C}}}{2}$ and $\\epsilon_{\\mathrm{AC}} = \\sqrt{\\epsilon_{\\mathrm{A}}\\epsilon_{\\mathrm{C}}}$.\n- Bonded cross-boundary correction via the link-atom subtractive scheme:\n$$\nE_{\\mathrm{bond}} = \\frac{1}{2}k_{\\mathrm{b}}^{\\mathrm{real}}\\left(r_{\\mathrm{AB}}-r_{0}^{\\mathrm{real}}\\right)^{2} - \\frac{1}{2}k_{\\mathrm{b}}^{\\mathrm{link}}\\left(r_{\\mathrm{AL}}-r_{0}^{\\mathrm{link}}\\right)^{2}.\n$$\nFor electrostatic embedding, use the same $E_{\\mathrm{bond}}$ as in mechanical embedding.\n\nYour program must implement the above expressions and return, for each test case, a list of six floats in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ ordered as $[E_{\\mathrm{elec}}^{\\mathrm{mech}}, E_{\\mathrm{vdW}}^{\\mathrm{mech}}, E_{\\mathrm{bond}}^{\\mathrm{mech}}, E_{\\mathrm{elec}}^{\\mathrm{EE}}, E_{\\mathrm{vdW}}^{\\mathrm{EE}}, E_{\\mathrm{bond}}^{\\mathrm{EE}}]$.\n\nTest suite to use:\n- Test case $1$ (general case; nonzero electrostatics, modest van der Waals, nonzero bond correction):\n    - Charges: $q_{\\mathrm{A}}^{\\mathrm{MM}} = -0.3$, $q_{\\mathrm{A}}^{\\mathrm{eff}} = -0.5$, $q_{\\mathrm{B}} = +0.4$, $q_{\\mathrm{C}} = -0.2$.\n    - Distances: $r_{\\mathrm{AB}} = 0.16\\,\\mathrm{nm}$, $r_{\\mathrm{AC}} = 0.50\\,\\mathrm{nm}$, $r_{\\mathrm{AL}} = 0.105\\,\\mathrm{nm}$.\n    - LJ parameters: $\\sigma_{\\mathrm{A}} = 0.32\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{A}} = 0.5\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$; $\\sigma_{\\mathrm{B}} = 0.34\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{B}} = 0.8\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$; $\\sigma_{\\mathrm{C}} = 0.30\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{C}} = 0.4\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$; link atom parameters may be provided but are not used in nonbonded interactions.\n    - Bond parameters: $k_{\\mathrm{b}}^{\\mathrm{real}} = 1000\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$, $r_{0}^{\\mathrm{real}} = 0.15\\,\\mathrm{nm}$; $k_{\\mathrm{b}}^{\\mathrm{link}} = 700\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$, $r_{0}^{\\mathrm{link}} = 0.105\\,\\mathrm{nm}$.\n- Test case $2$ (edge case; zero charges, only van der Waals and bonded terms contribute):\n    - Charges: $q_{\\mathrm{A}}^{\\mathrm{MM}} = 0.0$, $q_{\\mathrm{A}}^{\\mathrm{eff}} = 0.0$, $q_{\\mathrm{B}} = 0.0$, $q_{\\mathrm{C}} = 0.0$.\n    - Distances: $r_{\\mathrm{AB}} = 0.15\\,\\mathrm{nm}$, $r_{\\mathrm{AC}} = 0.40\\,\\mathrm{nm}$, $r_{\\mathrm{AL}} = 0.108\\,\\mathrm{nm}$.\n    - LJ parameters: $\\sigma_{\\mathrm{A}} = 0.31\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{A}} = 0.45\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$; $\\sigma_{\\mathrm{B}} = 0.33\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{B}} = 0.50\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$; $\\sigma_{\\mathrm{C}} = 0.29\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{C}} = 0.35\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$.\n    - Bond parameters: $k_{\\mathrm{b}}^{\\mathrm{real}} = 900\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$, $r_{0}^{\\mathrm{real}} = 0.15\\,\\mathrm{nm}$; $k_{\\mathrm{b}}^{\\mathrm{link}} = 850\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$, $r_{0}^{\\mathrm{link}} = 0.108\\,\\mathrm{nm}$.\n- Test case $3$ (strong electrostatic interaction and stretched boundary bond):\n    - Charges: $q_{\\mathrm{A}}^{\\mathrm{MM}} = -1.0$, $q_{\\mathrm{A}}^{\\mathrm{eff}} = -0.8$, $q_{\\mathrm{B}} = +1.0$, $q_{\\mathrm{C}} = +0.5$.\n    - Distances: $r_{\\mathrm{AB}} = 0.20\\,\\mathrm{nm}$, $r_{\\mathrm{AC}} = 0.45\\,\\mathrm{nm}$, $r_{\\mathrm{AL}} = 0.110\\,\\mathrm{nm}$.\n    - LJ parameters: $\\sigma_{\\mathrm{A}} = 0.35\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{A}} = 1.2\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$; $\\sigma_{\\mathrm{B}} = 0.36\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{B}} = 1.0\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$; $\\sigma_{\\mathrm{C}} = 0.33\\,\\mathrm{nm}$, $\\epsilon_{\\mathrm{C}} = 0.9\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$.\n    - Bond parameters: $k_{\\mathrm{b}}^{\\mathrm{real}} = 1200\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$, $r_{0}^{\\mathrm{real}} = 0.145\\,\\mathrm{nm}$; $k_{\\mathrm{b}}^{\\mathrm{link}} = 800\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$, $r_{0}^{\\mathrm{link}} = 0.106\\,\\mathrm{nm}$.\n\nAlgorithmic requirements:\n- Implement the above formulas exactly.\n- Exclude van der Waals interactions for directly bonded neighbors; include only the nonbonded pair $\\mathrm{A}$–$\\mathrm{C}$.\n- Express all energies in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ and round each reported float to $6$ decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets, for example, $\\left[[x_{1},x_{2},x_{3},x_{4},x_{5},x_{6}],[\\ldots],[\\ldots]\\right]$, where each inner list corresponds to one test case ordered as $[E_{\\mathrm{elec}}^{\\mathrm{mech}}, E_{\\mathrm{vdW}}^{\\mathrm{mech}}, E_{\\mathrm{bond}}^{\\mathrm{mech}}, E_{\\mathrm{elec}}^{\\mathrm{EE}}, E_{\\mathrm{vdW}}^{\\mathrm{EE}}, E_{\\mathrm{bond}}^{\\mathrm{EE}}]$ in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$.",
            "solution": "We begin from the hybrid Quantum Mechanics/Molecular Mechanics (QM/MM) framework under the Born–Oppenheimer approximation, which separates electronic and nuclear degrees of freedom. The total Hamiltonian for a system partitioned into a Quantum Mechanics (QM) region and a Molecular Mechanics (MM) region can be expressed schematically as\n$$\n\\hat{H}_{\\mathrm{tot}} = \\hat{H}_{\\mathrm{QM}} + U_{\\mathrm{MM}} + \\hat{H}_{\\mathrm{int}},\n$$\nwhere $\\hat{H}_{\\mathrm{QM}}$ is the electronic Hamiltonian of the QM region (with clamped nuclei), $U_{\\mathrm{MM}}$ is the classical force-field potential of the MM region (including bonded and nonbonded terms), and $\\hat{H}_{\\mathrm{int}}$ represents coupling across the boundary. The energy decomposition we seek must trace directly to these terms.\n\nFor the QM region, the standard nonrelativistic electronic Hamiltonian is\n$$\n\\hat{H}_{\\mathrm{QM}} = \\hat{T}_{e} + \\hat{V}_{ee} + \\hat{V}_{eN} + V_{NN},\n$$\nwhere $\\hat{T}_{e}$ is the kinetic energy of electrons, $\\hat{V}_{ee}$ is electron–electron Coulomb repulsion, $\\hat{V}_{eN}$ is electron–nuclear attraction, and $V_{NN}$ is nuclear–nuclear Coulomb repulsion. Within the hybrid scheme, the MM region is described by a classical potential\n$$\nU_{\\mathrm{MM}} = \n\\sum_{\\mathrm{bonds}}\\frac{1}{2}k_{\\mathrm{b}}(r-r_{0})^{2}\n+\n\\sum_{\\mathrm{angles}}k_{\\theta}(\\theta-\\theta_{0})^{2}\n+\n\\sum_{\\mathrm{dihedrals}}U_{\\phi}(\\phi)\n+\n\\sum_{i<j}\\left[4\\epsilon_{ij}\\left(\\left(\\frac{\\sigma_{ij}}{r_{ij}}\\right)^{12}-\\left(\\frac{\\sigma_{ij}}{r_{ij}}\\right)^{6}\\right) + k_{e}\\frac{q_{i}q_{j}}{r_{ij}}\\right].\n$$\nFor our minimal system, angles and dihedrals are not required; only a single boundary bond and nonbonded interactions are considered. We focus on cross-region terms that contribute to $E_{\\mathrm{QM/MM}}$.\n\nIn mechanical embedding, the interaction Hamiltonian $\\hat{H}_{\\mathrm{int}}$ does not enter the Quantum Mechanics (QM) Hamiltonian; the QM calculation is performed in vacuum for the model system (the QM region with a link atom capping the boundary), while interactions with the Molecular Mechanics (MM) region are treated by the classical force field. In a subtractive ONIOM-like mechanical scheme, the energy partition is\n$$\nE_{\\mathrm{hybrid}}^{\\mathrm{mech}} = E_{\\mathrm{QM}}(\\mathrm{model}) + U_{\\mathrm{MM}}(\\mathrm{real}) - U_{\\mathrm{MM}}(\\mathrm{model}).\n$$\nThe cross-region bonded correction arises from the difference between the real boundary bond and the link-atom bond in the model system, yielding\n$$\nE_{\\mathrm{bond}} = \\frac{1}{2}k_{\\mathrm{b}}^{\\mathrm{real}}\\left(r_{\\mathrm{AB}}-r_{0}^{\\mathrm{real}}\\right)^{2} - \\frac{1}{2}k_{\\mathrm{b}}^{\\mathrm{link}}\\left(r_{\\mathrm{AL}}-r_{0}^{\\mathrm{link}}\\right)^{2}.\n$$\nNonbonded cross interactions are accounted by the MM potential, separating into electrostatics and van der Waals components. The mechanical embedding electrostatics uses fixed MM charges for both QM and MM atoms:\n$$\nE_{\\mathrm{elec}}^{\\mathrm{mech}} = k_{e}\\sum_{J\\in \\mathrm{QM}}\\sum_{K\\in \\mathrm{MM}}\\frac{q_{J}^{\\mathrm{MM}}\\,q_{K}}{r_{JK}}.\n$$\nFor our one–QM–atom setup, this reduces to\n$$\nE_{\\mathrm{elec}}^{\\mathrm{mech}} = k_{e}\\,q_{\\mathrm{A}}^{\\mathrm{MM}}\\left(\\frac{q_{\\mathrm{B}}}{r_{\\mathrm{AB}}} + \\frac{q_{\\mathrm{C}}}{r_{\\mathrm{AC}}}\\right).\n$$\nThe van der Waals interaction uses the Lennard–Jones $12$–$6$ potential with Lorentz–Berthelot mixing rules for cross pairs, and we exclude directly bonded neighbors:\n$$\nE_{\\mathrm{vdW}} = E_{\\mathrm{LJ}}(\\mathrm{A},\\mathrm{C}) = 4\\,\\epsilon_{\\mathrm{AC}}\\left[\\left(\\frac{\\sigma_{\\mathrm{AC}}}{r_{\\mathrm{AC}}}\\right)^{12}-\\left(\\frac{\\sigma_{\\mathrm{AC}}}{r_{\\mathrm{AC}}}\\right)^{6}\\right],\\quad \\sigma_{\\mathrm{AC}} = \\frac{\\sigma_{\\mathrm{A}}+\\sigma_{\\mathrm{C}}}{2},\\quad \\epsilon_{\\mathrm{AC}} = \\sqrt{\\epsilon_{\\mathrm{A}}\\epsilon_{\\mathrm{C}}}.\n$$\n\nIn electrostatic embedding, the interaction Hamiltonian adds an external potential to the QM Hamiltonian due to MM point charges. The added term is\n$$\n\\hat{V}_{\\mathrm{ext}} = \\sum_{i\\in e}\\sum_{K\\in \\mathrm{MM}} \\frac{q_{K}}{4\\pi\\epsilon_{0}} \\frac{1}{\\lVert \\mathbf{r}_{i}-\\mathbf{R}_{K}\\rVert} - \\sum_{I\\in N}\\sum_{K\\in \\mathrm{MM}} \\frac{Z_{I}q_{K}}{4\\pi\\epsilon_{0}} \\frac{1}{\\lVert \\mathbf{R}_{I}-\\mathbf{R}_{K}\\rVert},\n$$\nand its expectation over the QM electron density $\\rho_{e}(\\mathbf{r})$ and point nuclei yields the QM–MM electrostatic energy contribution\n$$\nE_{\\mathrm{elec}}^{\\mathrm{EE}} = \\int \\rho_{e}(\\mathbf{r})\\,\\phi_{\\mathrm{MM}}(\\mathbf{r})\\,\\mathrm{d}\\mathbf{r} - \\sum_{I} Z_{I}\\,\\phi_{\\mathrm{MM}}(\\mathbf{R}_{I}),\n$$\nwhere $\\phi_{\\mathrm{MM}}$ is the MM electrostatic potential. In this problem, we are instructed to approximate this expectation by an effective QM atomic charge $q_{\\mathrm{A}}^{\\mathrm{eff}}$ placed on the QM atom, leading to the computable expression\n$$\nE_{\\mathrm{elec}}^{\\mathrm{EE}} = k_{e}\\,q_{\\mathrm{A}}^{\\mathrm{eff}}\\left(\\frac{q_{\\mathrm{B}}}{r_{\\mathrm{AB}}} + \\frac{q_{\\mathrm{C}}}{r_{\\mathrm{AC}}}\\right).\n$$\nThe van der Waals and bonded terms under electrostatic embedding are treated identically to mechanical embedding within the MM description used here:\n$$\nE_{\\mathrm{vdW}}^{\\mathrm{EE}} = E_{\\mathrm{vdW}}^{\\mathrm{mech}},\\qquad E_{\\mathrm{bond}}^{\\mathrm{EE}} = E_{\\mathrm{bond}}^{\\mathrm{mech}}.\n$$\n\nUnit consistency is ensured by adopting $k_{e} = 138.935456$ in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}\\,\\mathrm{e}^{-2}$, distances in $\\mathrm{nm}$, charges in $\\mathrm{e}$, LJ $\\epsilon$ in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$, $\\sigma$ in $\\mathrm{nm}$, and bond parameters in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$ and $\\mathrm{nm}$. The computed energies therefore directly yield $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$.\n\nAlgorithmic implementation for each test case:\n1. Read $q_{\\mathrm{A}}^{\\mathrm{MM}}$, $q_{\\mathrm{A}}^{\\mathrm{eff}}$, $q_{\\mathrm{B}}$, $q_{\\mathrm{C}}$; $r_{\\mathrm{AB}}$, $r_{\\mathrm{AC}}$, $r_{\\mathrm{AL}}$; $\\sigma_{\\mathrm{A}}$, $\\epsilon_{\\mathrm{A}}$, $\\sigma_{\\mathrm{C}}$, $\\epsilon_{\\mathrm{C}}$; $k_{\\mathrm{b}}^{\\mathrm{real}}$, $r_{0}^{\\mathrm{real}}$, $k_{\\mathrm{b}}^{\\mathrm{link}}$, $r_{0}^{\\mathrm{link}}$; and $k_{e}$.\n2. Compute $E_{\\mathrm{elec}}^{\\mathrm{mech}}$ and $E_{\\mathrm{elec}}^{\\mathrm{EE}}$ using the respective formulas.\n3. Compute $\\sigma_{\\mathrm{AC}}$ and $\\epsilon_{\\mathrm{AC}}$ via Lorentz–Berthelot mixing and then $E_{\\mathrm{vdW}}$ via the Lennard–Jones $12$–$6$ expression.\n4. Compute $E_{\\mathrm{bond}}$ via the difference of harmonic terms across the boundary bond and the link bond.\n5. Report the ordered list $[E_{\\mathrm{elec}}^{\\mathrm{mech}}, E_{\\mathrm{vdW}}^{\\mathrm{mech}}, E_{\\mathrm{bond}}^{\\mathrm{mech}}, E_{\\mathrm{elec}}^{\\mathrm{EE}}, E_{\\mathrm{vdW}}^{\\mathrm{EE}}, E_{\\mathrm{bond}}^{\\mathrm{EE}}]$ per test case, rounded to $6$ decimal places.\n\nQualitative expectations for the test suite:\n- Test case $1$ should show a sizable negative electrostatic energy due to opposite signs of $q_{\\mathrm{A}}^{\\mathrm{MM}}$ and $q_{\\mathrm{B}}$, a small attractive van der Waals energy for the nonbonded pair, and a small positive bonded correction due to slight bond elongation from equilibrium. Electrostatic embedding should yield a more negative electrostatic energy than mechanical embedding because $q_{\\mathrm{A}}^{\\mathrm{eff}}$ is more negative than $q_{\\mathrm{A}}^{\\mathrm{MM}}$.\n- Test case $2$ should yield zero electrostatic energy under both embeddings, with only van der Waals and bonded contributions (the latter being zero if both bonds are exactly at equilibrium).\n- Test case $3$ should display strong attractive electrostatics and a significant positive bonded correction due to a stretched cross-boundary bond; electrostatic embedding should weaken the magnitude of attraction compared to mechanical embedding because $q_{\\mathrm{A}}^{\\mathrm{eff}}$ is less negative than $q_{\\mathrm{A}}^{\\mathrm{MM}}$.\n\nThe final program must compute these quantities in $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ and produce a single line of output containing the three inner lists of six floats, rounded to $6$ decimals, enclosed in square brackets.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lj_energy(eps_i, sig_i, eps_j, sig_j, r_ij):\n    \"\"\"\n    Compute Lennard-Jones 12-6 energy using Lorentz-Berthelot mixing.\n    eps in kJ/mol, sigma in nm, r_ij in nm.\n    Returns energy in kJ/mol.\n    \"\"\"\n    # Lorentz-Berthelot mixing rules\n    sigma_ij = 0.5 * (sig_i + sig_j)\n    epsilon_ij = np.sqrt(eps_i * eps_j)\n    sr = sigma_ij / r_ij\n    sr6 = sr ** 6\n    sr12 = sr6 ** 2\n    return 4.0 * epsilon_ij * (sr12 - sr6)\n\ndef coulomb_energy(ke, qA, qB, qC, rAB, rAC):\n    \"\"\"\n    Compute electrostatic energy for one QM atom A interacting with two MM atoms B and C.\n    ke in kJ mol^-1 nm e^-2, charges in e, distances in nm.\n    Returns energy in kJ/mol.\n    \"\"\"\n    return ke * qA * (qB / rAB + qC / rAC)\n\ndef bonded_cross_energy(kb_real, rAB, r0_real, kb_link, rAL, r0_link):\n    \"\"\"\n    Compute cross-boundary bonded correction via subtractive scheme:\n    E_bond = 0.5*kb_real*(rAB - r0_real)^2 - 0.5*kb_link*(rAL - r0_link)^2\n    kb in kJ mol^-1 nm^-2, distances in nm.\n    Returns energy in kJ/mol.\n    \"\"\"\n    e_real = 0.5 * kb_real * (rAB - r0_real) ** 2\n    e_link = 0.5 * kb_link * (rAL - r0_link) ** 2\n    return e_real - e_link\n\ndef solve():\n    # Coulomb constant in kJ mol^-1 nm e^-2\n    ke = 138.935456\n\n    # Define the test cases from the problem statement.\n    # Each test case is a dictionary of parameters.\n    test_cases = [\n        {\n            # Test case 1\n            \"charges\": {\"qA_MM\": -0.3, \"qA_eff\": -0.5, \"qB\": +0.4, \"qC\": -0.2},\n            \"distances\": {\"rAB\": 0.16, \"rAC\": 0.50, \"rAL\": 0.105},\n            \"lj\": {\"sigma_A\": 0.32, \"epsilon_A\": 0.5, \"sigma_C\": 0.30, \"epsilon_C\": 0.4},\n            \"bond\": {\"kb_real\": 1000.0, \"r0_real\": 0.15, \"kb_link\": 700.0, \"r0_link\": 0.105}\n        },\n        {\n            # Test case 2\n            \"charges\": {\"qA_MM\": 0.0, \"qA_eff\": 0.0, \"qB\": 0.0, \"qC\": 0.0},\n            \"distances\": {\"rAB\": 0.15, \"rAC\": 0.40, \"rAL\": 0.108},\n            \"lj\": {\"sigma_A\": 0.31, \"epsilon_A\": 0.45, \"sigma_C\": 0.29, \"epsilon_C\": 0.35},\n            \"bond\": {\"kb_real\": 900.0, \"r0_real\": 0.15, \"kb_link\": 850.0, \"r0_link\": 0.108}\n        },\n        {\n            # Test case 3\n            \"charges\": {\"qA_MM\": -1.0, \"qA_eff\": -0.8, \"qB\": +1.0, \"qC\": +0.5},\n            \"distances\": {\"rAB\": 0.20, \"rAC\": 0.45, \"rAL\": 0.110},\n            \"lj\": {\"sigma_A\": 0.35, \"epsilon_A\": 1.2, \"sigma_C\": 0.33, \"epsilon_C\": 0.9},\n            \"bond\": {\"kb_real\": 1200.0, \"r0_real\": 0.145, \"kb_link\": 800.0, \"r0_link\": 0.106}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        qA_MM = case[\"charges\"][\"qA_MM\"]\n        qA_eff = case[\"charges\"][\"qA_eff\"]\n        qB = case[\"charges\"][\"qB\"]\n        qC = case[\"charges\"][\"qC\"]\n\n        rAB = case[\"distances\"][\"rAB\"]\n        rAC = case[\"distances\"][\"rAC\"]\n        rAL = case[\"distances\"][\"rAL\"]\n\n        sigma_A = case[\"lj\"][\"sigma_A\"]\n        epsilon_A = case[\"lj\"][\"epsilon_A\"]\n        sigma_C = case[\"lj\"][\"sigma_C\"]\n        epsilon_C = case[\"lj\"][\"epsilon_C\"]\n\n        kb_real = case[\"bond\"][\"kb_real\"]\n        r0_real = case[\"bond\"][\"r0_real\"]\n        kb_link = case[\"bond\"][\"kb_link\"]\n        r0_link = case[\"bond\"][\"r0_link\"]\n\n        # Electrostatics: mechanical embedding\n        E_elec_mech = coulomb_energy(ke, qA_MM, qB, qC, rAB, rAC)\n        # Electrostatics: electrostatic embedding (effective QM charge)\n        E_elec_EE = coulomb_energy(ke, qA_eff, qB, qC, rAB, rAC)\n\n        # Van der Waals: only nonbonded A-C\n        E_vdw = lj_energy(epsilon_A, sigma_A, epsilon_C, sigma_C, rAC)\n\n        # Bonded cross-boundary correction\n        E_bond = bonded_cross_energy(kb_real, rAB, r0_real, kb_link, rAL, r0_link)\n\n        # For this setup, vdW and bonded are identical under both embeddings\n        # Round to 6 decimals as required\n        def r6(x): return float(f\"{x:.6f}\")\n\n        case_result = [\n            r6(E_elec_mech),\n            r6(E_vdw),\n            r6(E_bond),\n            r6(E_elec_EE),\n            r6(E_vdw),\n            r6(E_bond)\n        ]\n        results.append(case_result)\n\n    # Format the final output exactly as a single line with a list of lists\n    # Each inner list contains six floats in kJ/mol\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join(f\"{x:.6f}\" for x in res) + \"]\" for res in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        },
        {
            "introduction": "A robust energy model is only useful if its corresponding forces are correctly implemented, as these are essential for molecular dynamics or geometry optimizations. This practice guides you through the essential process of verifying force consistency at a covalent QM/MM boundary, a critical validation step in computational method development. You will derive the analytical gradients for a model system and validate them against numerical finite-difference calculations, revealing the subtleties of force derivation in coupled systems, particularly for the polarization term in electrostatic embedding .",
            "id": "3849214",
            "problem": "You are given a minimal hybrid Quantum Mechanics/Molecular Mechanics (QM/MM) toy model designed to assess force-consistency at a covalent boundary for two embedding schemes. The system consists of three nuclei with positions in three-dimensional space: a Quantum Mechanics (QM) atom $A$ with position $\\mathbf{r}_A \\in \\mathbb{R}^3$, a QM atom $C$ with position $\\mathbf{r}_C \\in \\mathbb{R}^3$, and a Molecular Mechanics (MM) boundary atom $B$ with position $\\mathbf{r}_B \\in \\mathbb{R}^3$. The QM region is linearly polarizable and is connected across the covalent boundary to the MM region via a link-atom construction. An external MM environment consists of point charges $\\{q_i\\}$ located at positions $\\{\\mathbf{R}_i\\}$.\n\nAll calculations are performed in reduced, dimensionless units: positions in dimensionless length units, energies in dimensionless energy units, and charges in dimensionless charge units. No physical unit conversion is required.\n\nThe total energy in this model is defined as\n$$\nE_{\\text{tot}}(\\mathbf{r}_A,\\mathbf{r}_B,\\mathbf{r}_C) \\;=\\; E_{\\text{QM,int}} \\;+\\; E_{\\text{pol}} \\;+\\; E_{\\text{link}} \\,,\n$$\nwhere:\n- The QM internal harmonic energy is\n$$\nE_{\\text{QM,int}} \\;=\\; \\tfrac{1}{2} \\, k_{\\text{qm}} \\, \\lVert\\mathbf{r}_A - \\mathbf{r}_C\\rVert^2 \\,,\n$$\nwith stiffness $k_{\\text{qm}} > 0$.\n- The polarization coupling term (electrostatic embedding) is\n$$\nE_{\\text{pol}} \\;=\\; - \\alpha \\, \\big(\\mathbf{r}_A - \\mathbf{r}_C\\big) \\cdot \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{center}}) \\,,\n$$\nwhere $\\alpha \\ge 0$ is a scalar polarizability, $\\mathbf{r}_{\\text{center}} = \\tfrac{1}{2}(\\mathbf{r}_A + \\mathbf{r}_C)$ is the QM region’s effective center, and the external electric field due to MM point charges is\n$$\n\\mathbf{E}_{\\text{ext}}(\\mathbf{r}) \\;=\\; \\sum_{i} q_i \\, \\frac{\\mathbf{r} - \\mathbf{R}_i}{\\lVert\\mathbf{r} - \\mathbf{R}_i\\rVert^3} \\,.\n$$\nFor mechanical embedding, set $\\alpha = 0$ (i.e., there is no polarization coupling term).\n- The covalent boundary link-atom correction uses a geometric placement of a link atom $L$ defined implicitly by the relation $\\mathbf{r}_L = \\mathbf{r}_A + \\lambda (\\mathbf{r}_A - \\mathbf{r}_B)$ with a fixed scalar $0 < \\lambda < 1$, producing an effective link bond length of $\\lambda \\, \\lVert\\mathbf{r}_A - \\mathbf{r}_B\\rVert$. The link energy is modeled as a harmonic penalty:\n$$\nE_{\\text{link}} \\;=\\; \\tfrac{1}{2} \\, k_{\\text{link}} \\, \\Big( \\lambda \\, \\lVert\\mathbf{r}_A - \\mathbf{r}_B\\rVert - r_{\\text{eq}} \\Big)^2 \\,,\n$$\nwith stiffness $k_{\\text{link}} > 0$ and equilibrium bond length $r_{\\text{eq}} > 0$.\n\nYour task is to write a program that verifies force consistency by comparing analytic gradients of $E_{\\text{tot}}$ with finite-difference approximations of the gradients computed via central differences. Specifically, for each test case, compute:\n1. The analytic gradient $\\nabla_{\\mathbf{r}_A,\\mathbf{r}_B,\\mathbf{r}_C} E_{\\text{tot}}$ based on the definitions above.\n2. The finite-difference gradient using central differences with a fixed displacement step $h$ applied to each Cartesian component of $\\mathbf{r}_A$, $\\mathbf{r}_B$, and $\\mathbf{r}_C$ independently, holding all other parameters fixed. Use the standard central difference formula $(E(\\mathbf{x}+h\\mathbf{e}_j) - E(\\mathbf{x}-h\\mathbf{e}_j)) / (2h)$ for each component $j$.\n3. The maximum absolute componentwise difference between the analytic and finite-difference gradients across all $9$ components (three atoms times three coordinates).\n\nReturn, for each test case, a single floating-point number equal to the maximum absolute difference. The output must be a single line containing these numbers as a comma-separated list enclosed in square brackets.\n\nImplement the following test suite, which exercises electrostatic and mechanical embedding, as well as boundary geometry sensitivity and an edge case with no external field:\n- Test case $1$ (electrostatic embedding): $k_{\\text{qm}} = 1.0$, $\\alpha = 0.5$, $k_{\\text{link}} = 2.0$, $r_{\\text{eq}} = 1.1$, $\\lambda = 0.8$, $h = 10^{-6}$; $\\mathbf{r}_A = [0.5,-0.2,0.1]$, $\\mathbf{r}_B = [1.0,0.0,-0.1]$, $\\mathbf{r}_C = [0.0,0.3,0.0]$; MM charges: $(q_1,\\mathbf{R}_1) = (0.3,[2.0,0.0,0.0])$, $(q_2,\\mathbf{R}_2) = (-0.2,[0.0,2.0,1.0])$.\n- Test case $2$ (mechanical embedding): identical to test case $1$ except $\\alpha = 0.0$.\n- Test case $3$ (electrostatic embedding, short boundary): $k_{\\text{qm}} = 0.7$, $\\alpha = 0.4$, $k_{\\text{link}} = 3.0$, $r_{\\text{eq}} = 0.35$, $\\lambda = 0.9$, $h = 10^{-6}$; $\\mathbf{r}_A = [0.5,-0.2,0.1]$, $\\mathbf{r}_B = [0.6,-0.15,0.08]$, $\\mathbf{r}_C = [-0.1,0.25,0.05]$; MM charges: $(q_1,\\mathbf{R}_1) = (0.25,[1.5,-0.5,0.5])$, $(q_2,\\mathbf{R}_2) = (0.1,[-1.0,1.0,0.5])$.\n- Test case $4$ (no external field): $k_{\\text{qm}} = 1.2$, $\\alpha = 0.6$, $k_{\\text{link}} = 1.5$, $r_{\\text{eq}} = 0.9$, $\\lambda = 0.85$, $h = 10^{-6}$; $\\mathbf{r}_A = [0.2,0.1,-0.2]$, $\\mathbf{r}_B = [0.4,0.0,0.0]$, $\\mathbf{r}_C = [-0.1,0.2,0.1]$; MM charges: none.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\big[$result1,result2,result3,result4$\\big]$). All numbers printed must be in dimensionless reduced units, and no angles or percentages are to be used.",
            "solution": "The problem is deemed valid as it presents a scientifically sound, well-posed, and self-contained computational task based on standard principles of computational chemical biology. The model, while simplified, is representative of hybrid QM/MM methods. All parameters and conditions are explicitly defined.\n\nThe core of the task is to verify the consistency between the analytically derived gradient of the total energy $E_{\\text{tot}}$ and its numerical approximation via finite differences. The total energy is given by:\n$$\nE_{\\text{tot}}(\\mathbf{r}_A,\\mathbf{r}_B,\\mathbf{r}_C) \\;=\\; E_{\\text{QM,int}} \\;+\\; E_{\\text{pol}} \\;+\\; E_{\\text{link}}\n$$\nWe must compute the gradient of $E_{\\text{tot}}$ with respect to the positions of the three atoms, $\\nabla_{\\mathbf{r}_A, \\mathbf{r}_B, \\mathbf{r}_C} E_{\\text{tot}}$. This is a $9$-dimensional vector. We will derive the analytic expression for each term's contribution to the gradients with respect to $\\mathbf{r}_A$, $\\mathbf{r}_B$, and $\\mathbf{r}_C$.\n\n**1. Gradient of the QM Internal Energy**\nThe QM internal harmonic energy is $E_{\\text{QM,int}} = \\tfrac{1}{2} \\, k_{\\text{qm}} \\, \\lVert\\mathbf{r}_A - \\mathbf{r}_C\\rVert^2$.\nLet $\\mathbf{d}_{AC} = \\mathbf{r}_A - \\mathbf{r}_C$.\nThe gradients are:\n$$\n\\nabla_{\\mathbf{r}_A} E_{\\text{QM,int}} = k_{\\text{qm}} (\\mathbf{r}_A - \\mathbf{r}_C) = k_{\\text{qm}} \\mathbf{d}_{AC}\n$$\n$$\n\\nabla_{\\mathbf{r}_C} E_{\\text{QM,int}} = k_{\\text{qm}} (\\mathbf{r}_C - \\mathbf{r}_A) = -k_{\\text{qm}} \\mathbf{d}_{AC}\n$$\n$$\n\\nabla_{\\mathbf{r}_B} E_{\\text{QM,int}} = \\mathbf{0}\n$$\n\n**2. Gradient of the Link-Atom Energy**\nThe link energy is $E_{\\text{link}} = \\tfrac{1}{2} \\, k_{\\text{link}} \\, \\Big( \\lambda \\, \\lVert\\mathbf{r}_A - \\mathbf{r}_B\\rVert - r_{\\text{eq}} \\Big)^2$.\nLet $\\mathbf{d}_{AB} = \\mathbf{r}_A - \\mathbf{r}_B$ and its norm $d_{AB} = \\lVert\\mathbf{d}_{AB}\\rVert$. Using the chain rule, $\\nabla f(g(\\mathbf{r})) = f'(g(\\mathbf{r})) \\nabla g(\\mathbf{r})$, with $g = d_{AB}$ and $f(x) = \\tfrac{1}{2} k_{\\text{link}}(\\lambda x-r_{\\text{eq}})^2$.\nThe derivative of the norm is $\\nabla_{\\mathbf{r}_A} d_{AB} = \\mathbf{d}_{AB} / d_{AB}$ and $\\nabla_{\\mathbf{r}_B} d_{AB} = -\\mathbf{d}_{AB} / d_{AB}$.\nThe derivative of $f(x)$ is $f'(x) = k_{\\text{link}}(\\lambda x-r_{\\text{eq}})\\lambda$.\nThe gradients are:\n$$\n\\nabla_{\\mathbf{r}_A} E_{\\text{link}} = k_{\\text{link}} \\lambda (\\lambda d_{AB} - r_{\\text{eq}}) \\frac{\\mathbf{d}_{AB}}{d_{AB}} = \\lambda k_{\\text{link}} \\left(\\lambda - \\frac{r_{\\text{eq}}}{d_{AB}}\\right) \\mathbf{d}_{AB}\n$$\n$$\n\\nabla_{\\mathbf{r}_B} E_{\\text{link}} = -k_{\\text{link}} \\lambda (\\lambda d_{AB} - r_{\\text{eq}}) \\frac{\\mathbf{d}_{AB}}{d_{AB}} = -\\lambda k_{\\text{link}} \\left(\\lambda - \\frac{r_{\\text{eq}}}{d_{AB}}\\right) \\mathbf{d}_{AB}\n$$\n$$\n\\nabla_{\\mathbf{r}_C} E_{\\text{link}} = \\mathbf{0}\n$$\nThese expressions are valid for $d_{AB} > 0$.\n\n**3. Gradient of the Polarization Energy**\nThe polarization energy is $E_{\\text{pol}} = - \\alpha \\, \\mathbf{p} \\cdot \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}})$, where $\\mathbf{p} = \\mathbf{r}_A - \\mathbf{r}_C$ and $\\mathbf{r}_{\\text{c}} = \\tfrac{1}{2}(\\mathbf{r}_A + \\mathbf{r}_C)$. If $\\alpha=0$, this term and its gradients are zero. For $\\alpha > 0$, we apply the product and chain rules.\nUsing the identity $\\nabla(\\mathbf{u} \\cdot \\mathbf{v}) = (\\nabla \\mathbf{u})^T\\mathbf{v} + (\\nabla \\mathbf{v})^T\\mathbf{u}$:\n$$\n\\nabla_{\\mathbf{r}_k} E_{\\text{pol}} = -\\alpha \\left( (\\nabla_{\\mathbf{r}_k} \\mathbf{p})^T \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) + (\\nabla_{\\mathbf{r}_k} \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}))^T \\mathbf{p} \\right)\n$$\nwhere $k \\in \\{A, B, C\\}$.\nThe required Jacobians are:\n$\\nabla_{\\mathbf{r}_A} \\mathbf{p} = \\mathbf{I}$, $\\nabla_{\\mathbf{r}_C} \\mathbf{p} = -\\mathbf{I}$, $\\nabla_{\\mathbf{r}_B} \\mathbf{p} = \\mathbf{0}$.\n$\\nabla_{\\mathbf{r}_A} \\mathbf{r}_{\\text{c}} = \\tfrac{1}{2}\\mathbf{I}$, $\\nabla_{\\mathbf{r}_C} \\mathbf{r}_{\\text{c}} = \\tfrac{1}{2}\\mathbf{I}$, $\\nabla_{\\mathbf{r}_B} \\mathbf{r}_{\\text{c}} = \\mathbf{0}$.\n\nLet $\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}) = \\nabla_{\\mathbf{r}} \\mathbf{E}_{\\text{ext}}(\\mathbf{r})$ be the Jacobian of the external electric field. By the chain rule, $\\nabla_{\\mathbf{r}_A} \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) = \\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}}) (\\nabla_{\\mathbf{r}_A} \\mathbf{r}_{\\text{c}}) = \\tfrac{1}{2}\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}})$.\n\nFor atom $A$:\n$$\n\\nabla_{\\mathbf{r}_A} E_{\\text{pol}} = -\\alpha \\left( \\mathbf{I}^T \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) + \\left(\\tfrac{1}{2}\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}})\\right)^T \\mathbf{p} \\right) = -\\alpha \\left( \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) + \\tfrac{1}{2}\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}})^T \\mathbf{p} \\right)\n$$\nFor atom $C$:\n$$\n\\nabla_{\\mathbf{r}_C} E_{\\text{pol}} = -\\alpha \\left( (-\\mathbf{I})^T \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) + \\left(\\tfrac{1}{2}\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}})\\right)^T \\mathbf{p} \\right) = -\\alpha \\left( -\\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) + \\tfrac{1}{2}\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}})^T \\mathbf{p} \\right)\n$$\nFor atom $B$, the gradient is $\\mathbf{0}$.\n\nThe Jacobian $\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r})$ is the gradient of $\\mathbf{E}_{\\text{ext}}(\\mathbf{r}) = \\sum_{i} q_i \\frac{\\mathbf{r} - \\mathbf{R}_i}{\\lVert\\mathbf{r} - \\mathbf{R}_i\\rVert^3}$. It is a symmetric tensor (the negative of the Hessian of the electrostatic potential) given by:\n$$\n\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}) = \\sum_i q_i \\left( \\frac{\\mathbf{I}}{\\lVert\\mathbf{r} - \\mathbf{R}_i\\rVert^3} - \\frac{3 (\\mathbf{r} - \\mathbf{R}_i) \\otimes (\\mathbf{r} - \\mathbf{R}_i)}{\\lVert\\mathbf{r} - \\mathbf{R}_i\\rVert^5} \\right)\n$$\nwhere $\\otimes$ denotes the outer product. Since $\\mathbf{J}_{\\mathbf{E}}$ is symmetric, $\\mathbf{J}_{\\mathbf{E}}^T = \\mathbf{J}_{\\mathbf{E}}$.\n\n**Summary of Total Analytic Gradients**\n\n$\\nabla_{\\mathbf{r}_A} E_{\\text{tot}} = k_{\\text{qm}}\\mathbf{d}_{AC} + \\lambda k_{\\text{link}}\\left(\\lambda - \\frac{r_{\\text{eq}}}{d_{AB}}\\right)\\mathbf{d}_{AB} - \\alpha \\left( \\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) + \\tfrac{1}{2}\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}})\\mathbf{p} \\right)$\n$\\nabla_{\\mathbf{r}_B} E_{\\text{tot}} = -\\lambda k_{\\text{link}}\\left(\\lambda - \\frac{r_{\\text{eq}}}{d_{AB}}\\right)\\mathbf{d}_{AB}$\n$\\nabla_{\\mathbf{r}_C} E_{\\text{tot}} = - k_{\\text{qm}}\\mathbf{d}_{AC} - \\alpha \\left( -\\mathbf{E}_{\\text{ext}}(\\mathbf{r}_{\\text{c}}) + \\tfrac{1}{2}\\mathbf{J}_{\\mathbf{E}}(\\mathbf{r}_{\\text{c}})\\mathbf{p} \\right)$\n\nThese formulae are implemented and compared against a numerical finite-difference calculation for each test case. The finite-difference gradient for each component $j$ is calculated using the central difference formula:\n$$\n(\\nabla E)_j = \\frac{E(\\mathbf{x}+h\\mathbf{e}_j) - E(\\mathbf{x}-h\\mathbf{e}_j)}{2h}\n$$\nwhere $\\mathbf{x}$ is the $9$-dimensional vector of all atomic coordinates, $\\mathbf{e}_j$ is a unit vector along the $j$-th component, and $h$ is a small displacement. The maximum absolute difference between the analytic and numerical gradient components is then determined.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates and solves the QM/MM force consistency problem.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"k_qm\": 1.0, \"alpha\": 0.5, \"k_link\": 2.0, \"r_eq\": 1.1, \"lambda_\": 0.8, \"h\": 1e-6,\n            \"rA\": np.array([0.5, -0.2, 0.1]),\n            \"rB\": np.array([1.0, 0.0, -0.1]),\n            \"rC\": np.array([0.0, 0.3, 0.0]),\n            \"mm_charges\": [(0.3, np.array([2.0, 0.0, 0.0])), (-0.2, np.array([0.0, 2.0, 1.0]))]\n        },\n        {\n            \"k_qm\": 1.0, \"alpha\": 0.0, \"k_link\": 2.0, \"r_eq\": 1.1, \"lambda_\": 0.8, \"h\": 1e-6,\n            \"rA\": np.array([0.5, -0.2, 0.1]),\n            \"rB\": np.array([1.0, 0.0, -0.1]),\n            \"rC\": np.array([0.0, 0.3, 0.0]),\n            \"mm_charges\": [(0.3, np.array([2.0, 0.0, 0.0])), (-0.2, np.array([0.0, 2.0, 1.0]))]\n        },\n        {\n            \"k_qm\": 0.7, \"alpha\": 0.4, \"k_link\": 3.0, \"r_eq\": 0.35, \"lambda_\": 0.9, \"h\": 1e-6,\n            \"rA\": np.array([0.5, -0.2, 0.1]),\n            \"rB\": np.array([0.6, -0.15, 0.08]),\n            \"rC\": np.array([-0.1, 0.25, 0.05]),\n            \"mm_charges\": [(0.25, np.array([1.5, -0.5, 0.5])), (0.1, np.array([-1.0, 1.0, 0.5]))]\n        },\n        {\n            \"k_qm\": 1.2, \"alpha\": 0.6, \"k_link\": 1.5, \"r_eq\": 0.9, \"lambda_\": 0.85, \"h\": 1e-6,\n            \"rA\": np.array([0.2, 0.1, -0.2]),\n            \"rB\": np.array([0.4, 0.0, 0.0]),\n            \"rC\": np.array([-0.1, 0.2, 0.1]),\n            \"mm_charges\": []\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        rA, rB, rC = params[\"rA\"], params[\"rB\"], params[\"rC\"]\n        \n        grad_analytic = calculate_analytic_gradient(rA, rB, rC, params)\n        grad_fd = calculate_fd_gradient(rA, rB, rC, params)\n        \n        max_diff = np.max(np.abs(grad_analytic - grad_fd))\n        results.append(max_diff)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef calculate_energy(rA, rB, rC, params):\n    \"\"\"Computes the total QM/MM energy.\"\"\"\n    k_qm = params[\"k_qm\"]\n    alpha = params[\"alpha\"]\n    k_link = params[\"k_link\"]\n    r_eq = params[\"r_eq\"]\n    lambda_ = params[\"lambda_\"]\n    mm_charges = params[\"mm_charges\"]\n\n    # E_QM,int\n    d_AC = rA - rC\n    E_qm_int = 0.5 * k_qm * np.dot(d_AC, d_AC)\n\n    # E_link\n    d_AB = rA - rB\n    norm_d_AB = np.linalg.norm(d_AB)\n    E_link = 0.5 * k_link * (lambda_ * norm_d_AB - r_eq)**2\n\n    # E_pol\n    E_pol = 0.0\n    if alpha > 0 and mm_charges:\n        r_center = 0.5 * (rA + rC)\n        E_ext = _calculate_E_ext(r_center, mm_charges)\n        E_pol = -alpha * np.dot(d_AC, E_ext)\n\n    return E_qm_int + E_link + E_pol\n\n\ndef _calculate_E_ext(r, mm_charges):\n    \"\"\"Computes the external electric field from MM charges.\"\"\"\n    E = np.zeros(3)\n    for q, R in mm_charges:\n        u = r - R\n        norm_u = np.linalg.norm(u)\n        if norm_u > 0:\n            E += q * u / (norm_u**3)\n    return E\n\n\ndef _calculate_J_E(r, mm_charges):\n    \"\"\"Computes the Jacobian of the external electric field.\"\"\"\n    J = np.zeros((3, 3))\n    I = np.identity(3)\n    for q, R in mm_charges:\n        u = r - R\n        norm_u = np.linalg.norm(u)\n        if norm_u > 0:\n            norm_u_3 = norm_u**3\n            norm_u_5 = norm_u**5\n            outer_u = np.outer(u, u)\n            J += q * (I / norm_u_3 - 3 * outer_u / norm_u_5)\n    return J\n\n\ndef calculate_analytic_gradient(rA, rB, rC, params):\n    \"\"\"Computes the analytic gradient of the total energy.\"\"\"\n    k_qm, alpha, k_link = params[\"k_qm\"], params[\"alpha\"], params[\"k_link\"]\n    r_eq, lambda_ = params[\"r_eq\"], params[\"lambda_\"]\n    mm_charges = params[\"mm_charges\"]\n\n    grad_A = np.zeros(3)\n    grad_B = np.zeros(3)\n    grad_C = np.zeros(3)\n\n    # Gradient of E_QM,int\n    d_AC = rA - rC\n    grad_A += k_qm * d_AC\n    grad_C -= k_qm * d_AC\n\n    # Gradient of E_link\n    d_AB = rA - rB\n    norm_d_AB = np.linalg.norm(d_AB)\n    if norm_d_AB > 0:\n        factor = lambda_ * k_link * (lambda_ - r_eq / norm_d_AB)\n        grad_link_A = factor * d_AB\n        grad_A += grad_link_A\n        grad_B -= grad_link_A\n\n    # Gradient of E_pol\n    if alpha > 0 and mm_charges:\n        r_center = 0.5 * (rA + rC)\n        E_ext = _calculate_E_ext(r_center, mm_charges)\n        J_E = _calculate_J_E(r_center, mm_charges)\n        \n        p = d_AC\n        J_E_dot_p = np.dot(J_E, p)\n        \n        grad_A -= alpha * (E_ext + 0.5 * J_E_dot_p)\n        grad_C -= alpha * (-E_ext + 0.5 * J_E_dot_p)\n\n    return np.concatenate((grad_A, grad_B, grad_C))\n\n\ndef calculate_fd_gradient(rA, rB, rC, params):\n    \"\"\"Computes the finite-difference gradient of the total energy.\"\"\"\n    h = params[\"h\"]\n    grad_fd = np.zeros(9)\n    coords = np.concatenate((rA, rB, rC))\n\n    for i in range(9):\n        coords_plus = coords.copy()\n        coords_minus = coords.copy()\n        \n        coords_plus[i] += h\n        coords_minus[i] -= h\n        \n        rA_p, rB_p, rC_p = coords_plus[0:3], coords_plus[3:6], coords_plus[6:9]\n        rA_m, rB_m, rC_m = coords_minus[0:3], coords_minus[3:6], coords_minus[6:9]\n        \n        E_plus = calculate_energy(rA_p, rB_p, rC_p, params)\n        E_minus = calculate_energy(rA_m, rB_m, rC_m, params)\n        \n        grad_fd[i] = (E_plus - E_minus) / (2 * h)\n        \n    return grad_fd\n\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "The accuracy of electrostatic embedding hinges on the quality of the MM point charges, especially those near the QM/MM boundary where artifacts can arise. This advanced exercise introduces a sophisticated technique for charge parameterization: fitting MM charges to reproduce a quantum-derived electrostatic potential, analogous to the well-known RESP method. You will implement a constrained least-squares procedure that enforces physical constraints like fragment neutrality, providing a powerful tool for developing high-fidelity QM/MM models for specific systems .",
            "id": "3849255",
            "problem": "You are asked to formalize and implement a mathematically principled reparameterization protocol for hybrid Quantum Mechanics/Molecular Mechanics (QM/MM) simulations in computational chemical biology that targets boundary treatment under electrostatic embedding. The goal is to fit Molecular Mechanics (MM) point charges that lie near the Quantum Mechanics (QM) region boundary so that the resulting MM electrostatic potential reproduces the QM-derived electrostatic potential on a set of grid points, while preserving the neutrality of predefined MM fragments. You must derive the fitting equations from first principles and implement them as a constrained least-squares optimization.\n\nStart from the following fundamental base:\n- The electrostatic potential of a point charge in atomic units is given by $V(\\mathbf{r}) = \\sum_{i} \\dfrac{q_{i}}{\\lVert \\mathbf{r} - \\mathbf{R}_{i} \\rVert}$, where $q_{i}$ is the charge at site $i$, $\\mathbf{R}_{i}$ is its position, and $\\mathbf{r}$ is the evaluation point in space.\n- Electrostatic embedding in hybrid Quantum Mechanics/Molecular Mechanics (QM/MM) methods models the MM environment as fixed point charges that act on the QM region. Mechanical embedding serves as a baseline scenario in which MM charges do not contribute electrostatically to the QM region.\n- Linear least-squares fitting minimizes the sum of squared residuals between model predictions and observations, subject to linear equality constraints.\n\nYour task is to:\n1. Derive from first principles a constrained linear least-squares formulation to estimate unknown MM charges $\\mathbf{q}$ from QM-derived electrostatic potentials on grid points, enforcing fragment neutrality. Use a penalty to regularize toward a reference charge vector when needed. The derivation must begin from the fundamental expression of the electrostatic potential above and lead to a solvable linear system with equality constraints that preserve fragment neutrality. No intermediate formulas should be given in the problem statement; your program must implement the full derivation in code.\n2. Implement the solver that:\n   - Constructs the linear model $A \\mathbf{q} \\approx \\mathbf{v}$ with entries $A_{j,i} = \\dfrac{1}{\\lVert \\mathbf{r}_{j} - \\mathbf{R}_{i} \\rVert}$ in atomic units (Coulomb constant equal to $1$).\n   - Accounts for any fixed MM charges by subtracting their known contributions from the QM-derived potentials to form the effective target vector.\n   - Enforces fragment neutrality through linear equality constraints of the form $C \\mathbf{q} = \\mathbf{d}$, where each row of $C$ sums charges belonging to a fragment and $\\mathbf{d}$ contains the target fragment net charges.\n   - Optionally applies quadratic regularization (Tikhonov) toward a given reference charge vector $\\mathbf{q}_{0}$ with strength $\\alpha \\ge 0$.\n   - Produces fitted MM charges in elementary charge units $e$.\n3. For the last test case, compute a scalar performance metric that contrasts electrostatic embedding and mechanical embedding by reporting the normalized residual ratio $R = \\dfrac{\\lVert \\mathbf{v} - A \\mathbf{q}_{\\mathrm{fit}} \\rVert^{2}}{\\lVert \\mathbf{v} \\rVert^{2}}$, where $\\mathbf{q}_{\\mathrm{fit}}$ is the fitted charge vector. Mechanical embedding corresponds to the baseline $\\mathbf{q} = \\mathbf{0}$, whose normalized residual is $1$ by definition.\n\nUnits and numerical reporting requirements:\n- Positions must be treated in bohr (atomic units), potentials in atomic units, and charges in elementary charge units $e$.\n- Your program must round each reported fitted charge and each scalar metric to $6$ decimal places.\n- Angles are not involved.\n- The final output must be a single line containing the results as a comma-separated list enclosed in square brackets. The elements of this list are, in order, the fitted charge vectors for Test Case $1$, Test Case $2$, Test Case $3$ (each itself printed as a list), and then the scalar metric for Test Case $4$.\n\nTest suite:\nImplement and solve the following four cases. For each case, build the QM-derived electrostatic potentials by superimposing contributions from the specified “true” unknown charges and any fixed charges, using $V(\\mathbf{r}) = \\sum_{i} \\dfrac{q_{i}}{\\lVert \\mathbf{r} - \\mathbf{R}_{i} \\rVert}$ in atomic units.\n\n- Test Case $1$ (general “happy path” with fixed-charge subtraction and two fragments):\n  - Unknown MM charge sites $\\mathbf{R}_{i}$:\n    - $\\mathbf{R}_{0} = (\\,0.0,\\,0.0,\\,0.0\\,)$,\n    - $\\mathbf{R}_{1} = (\\,2.0,\\,0.0,\\,0.0\\,)$,\n    - $\\mathbf{R}_{2} = (\\,0.0,\\,2.0,\\,0.0\\,)$.\n  - Fragments and neutrality targets:\n    - Fragment $A$: indices $[\\,0,\\,1\\,]$, target net charge $0.0$,\n    - Fragment $B$: indices $[\\,2\\,]$, target net charge $0.0$.\n  - Fixed MM charges:\n    - One fixed charge $q_{\\mathrm{fix}} = 0.1$ at position $(\\,5.0,\\,5.0,\\,0.0\\,)$.\n  - Grid points $\\mathbf{r}_{j}$:\n    - $(\\,1.0,\\,0.5,\\,0.0\\,)$,\n    - $(\\,1.0,\\,1.5,\\,0.0\\,)$,\n    - $(\\,0.5,\\,1.0,\\,0.0\\,)$,\n    - $(\\,2.5,\\,0.5,\\,0.0\\,)$,\n    - $(\\,-0.5,\\,-0.5,\\,0.0\\,)$.\n  - “True” unknown charges for generating the QM potentials:\n    - $q^{\\mathrm{true}} = [\\,0.3,\\,-0.15,\\,-0.15\\,]$.\n  - Regularization:\n    - $\\alpha = 0.0$, $\\mathbf{q}_{0} = [\\,0.0,\\,0.0,\\,0.0\\,]$.\n\n- Test Case $2$ (boundary treatment: link-atom zero-charge constraint inside a neutral fragment):\n  - Unknown MM charge sites $\\mathbf{R}_{i}$:\n    - $\\mathbf{R}_{0} = (\\,0.0,\\,0.0,\\,0.0\\,)$,\n    - $\\mathbf{R}_{1} = (\\,1.5,\\,0.0,\\,0.0\\,)$.\n  - Fragments and neutrality target:\n    - Fragment $A$: indices $[\\,0,\\,1\\,]$, target net charge $0.0$.\n  - Additional boundary constraint:\n    - Enforce $q_{0} = 0.0$ to represent a link atom carrying no MM charge.\n  - Grid points $\\mathbf{r}_{j}$:\n    - $(\\,0.75,\\,0.5,\\,0.0\\,)$,\n    - $(\\,1.2,\\,0.3,\\,0.0\\,)$,\n    - $(\\,0.3,\\,-0.4,\\,0.0\\,)$,\n    - $(\\,1.6,\\,0.5,\\,0.0\\,)$.\n  - “True” unknown charges for generating the QM potentials:\n    - $q^{\\mathrm{true}} = [\\,0.2,\\,-0.2\\,]$.\n  - Regularization:\n    - $\\alpha = 0.0$, $\\mathbf{q}_{0} = [\\,0.0,\\,0.0\\,]$.\n\n- Test Case $3$ (underdetermined system stabilized by regularization toward reference MM charges):\n  - Unknown MM charge sites $\\mathbf{R}_{i}$:\n    - $\\mathbf{R}_{0} = (\\,0.0,\\,0.0,\\,0.0\\,)$,\n    - $\\mathbf{R}_{1} = (\\,1.0,\\,0.0,\\,0.0\\,)$,\n    - $\\mathbf{R}_{2} = (\\,0.0,\\,1.0,\\,0.0\\,)$,\n    - $\\mathbf{R}_{3} = (\\,1.0,\\,1.0,\\,0.0\\,)$.\n  - Fragments and neutrality targets:\n    - Fragment $A$: indices $[\\,0,\\,1\\,]$, target net charge $0.0$,\n    - Fragment $B$: indices $[\\,2,\\,3\\,]$, target net charge $0.0$.\n  - Grid points $\\mathbf{r}_{j}$:\n    - $(\\,0.5,\\,0.2,\\,0.0\\,)$,\n    - $(\\,0.2,\\,0.7,\\,0.0\\,)$,\n    - $(\\,0.8,\\,0.8,\\,0.0\\,)$.\n  - “True” unknown charges for generating the QM potentials:\n    - $q^{\\mathrm{true}} = [\\,0.12,\\,-0.08,\\,0.03,\\,-0.07\\,]$.\n  - Regularization:\n    - $\\alpha = 0.1$, reference charges $\\mathbf{q}_{0} = [\\,0.1,\\,-0.1,\\,0.05,\\,-0.05\\,]$.\n\n- Test Case $4$ (contrast electrostatic and mechanical embedding via normalized residual reduction):\n  - Unknown MM charge sites $\\mathbf{R}_{i}$:\n    - $\\mathbf{R}_{0} = (\\,0.0,\\,0.0,\\,0.0\\,)$,\n    - $\\mathbf{R}_{1} = (\\,2.0,\\,2.0,\\,0.0\\,)$.\n  - Fragments and neutrality target:\n    - Fragment $A$: indices $[\\,0,\\,1\\,]$, target net charge $0.0$.\n  - Grid points $\\mathbf{r}_{j}$:\n    - $(\\,0.5,\\,0.5,\\,0.0\\,)$,\n    - $(\\,1.0,\\,1.0,\\,0.0\\,)$,\n    - $(\\,1.5,\\,1.5,\\,0.0\\,)$,\n    - $(\\,2.5,\\,0.5,\\,0.0\\,)$,\n    - $(\\,0.5,\\,2.5,\\,0.0\\,)$.\n  - “True” unknown charges for generating the QM potentials:\n    - $q^{\\mathrm{true}} = [\\,0.25,\\,-0.25\\,]$.\n  - Regularization:\n    - $\\alpha = 0.0$, $\\mathbf{q}_{0} = [\\,0.0,\\,0.0\\,]$.\n\nYour program must:\n- For each test case, construct the QM-derived potentials on the grid points by superposition of the “true” unknown charges and any fixed charges (if present), then subtract fixed-charge contributions when fitting to yield the effective target vector.\n- Solve the constrained least-squares problem to obtain the fitted charges.\n- For Test Case $4$, compute the normalized residual ratio $R$ defined above.\n- Print a single line: a comma-separated list enclosed in square brackets whose first three entries are the lists of fitted charges for Test Cases $1$–$3$ in $e$, each rounded to $6$ decimal places, followed by the scalar $R$ for Test Case $4$ rounded to $6$ decimal places. For example, the final line should look like $[ [\\,\\dots\\,], [\\,\\dots\\,], [\\,\\dots\\,], r ]$.",
            "solution": "The problem presented is a valid and well-posed task in computational chemical biology, specifically concerning the parameterization of point charges in a hybrid Quantum Mechanics/Molecular Mechanics (QM/MM) simulation. It requires the derivation and implementation of a constrained, regularized linear least-squares fitting procedure.\n\nThe foundation of this problem is rooted in classical electrostatics and numerical optimization. The electrostatic potential $V$ at a spatial point $\\mathbf{r}$ generated by a distribution of point charges $q_i$ located at positions $\\mathbf{R}_i$ is given by the superposition principle, which in atomic units (where the Coulomb constant $k_e = \\frac{1}{4\\pi\\epsilon_0}$ is $1$) is:\n$$\nV(\\mathbf{r}) = \\sum_{i} \\frac{q_i}{\\lVert \\mathbf{r} - \\mathbf{R}_i \\rVert}\n$$\nIn our QM/MM context, we aim to determine a set of $N$ unknown MM charges, denoted by the vector $\\mathbf{q} \\in \\mathbb{R}^N$, such that the electrostatic potential they produce matches a target potential, $\\mathbf{v} \\in \\mathbb{R}^M$, at a set of $M$ grid points $\\mathbf{r}_j$. This relationship can be expressed as a linear system:\n$$\nA \\mathbf{q} \\approx \\mathbf{v}\n$$\nHere, $A$ is an $M \\times N$ matrix where each element $A_{ji}$ represents the electrostatic potential at grid point $\\mathbf{r}_j$ due to a unit charge at site $\\mathbf{R}_i$:\n$$\nA_{ji} = \\frac{1}{\\lVert \\mathbf{r}_j - \\mathbf{R}_i \\rVert}\n$$\nThe target potential vector $\\mathbf{v}$ corresponds to the potential that the unknown charges are supposed to replicate. In a real QM/MM simulation, this would be derived from a quantum mechanical calculation on the QM region. For this problem, we simulate this by calculating the potential from a set of \"true\" charges, $\\mathbf{q}_{\\mathrm{true}}$. The total potential measured might include contributions from other, known MM charges ($q_{\\mathrm{fix}}$). Let the potential from these fixed charges at the grid points be $\\mathbf{v}_{\\mathrm{fix}}$. The total potential is $\\mathbf{v}_{\\mathrm{total}} = A \\mathbf{q}_{\\mathrm{true}} + \\mathbf{v}_{\\mathrm{fix}}$. Our goal is to fit $\\mathbf{q}$ to account for the potential generated by the unknown charges, so we must subtract the contribution from the fixed charges. The effective target potential is thus $\\mathbf{v} = \\mathbf{v}_{\\mathrm{total}} - \\mathbf{v}_{\\mathrm{fix}} = A \\mathbf{q}_{\\mathrm{true}}$.\n\nTo find the optimal charge vector $\\mathbf{q}$, we minimize the sum of squared differences between the model's prediction $A\\mathbf{q}$ and the target potential $\\mathbf{v}$. To prevent overfitting and to ensure a unique solution exists for underdetermined systems (where $M < N$), we introduce a Tikhonov regularization term. This term penalizes the squared deviation of the fitted charges $\\mathbf{q}$ from a set of reference charges $\\mathbf{q}_0$, with a strength controlled by the parameter $\\alpha \\ge 0$. The objective function to minimize is:\n$$\nS(\\mathbf{q}) = \\lVert A\\mathbf{q} - \\mathbf{v} \\rVert^2 + \\alpha \\lVert \\mathbf{q} - \\mathbf{q}_0 \\rVert^2\n$$\nThis is an unconstrained optimization problem. However, physical realism often demands constraints. A common requirement is that specific molecular fragments maintain a predefined net charge (e.g., $0$ for a neutral molecule). These are linear equality constraints that can be written in matrix form as:\n$$\nC \\mathbf{q} = \\mathbf{d}\n$$\nwhere each row of the matrix $C$ defines a constraint (e.g., by having $1$s for all charge indices belonging to a fragment), and the vector $\\mathbf{d}$ contains the target net charges.\n\nTo solve the minimization problem subject to these linear constraints, we employ the method of Lagrange multipliers. We construct the Lagrangian function $\\mathcal{L}(\\mathbf{q}, \\boldsymbol{\\lambda})$, where $\\boldsymbol{\\lambda}$ is a vector of Lagrange multipliers:\n$$\n\\mathcal{L}(\\mathbf{q}, \\boldsymbol{\\lambda}) = (A\\mathbf{q} - \\mathbf{v})^T (A\\mathbf{q} - \\mathbf{v}) + \\alpha (\\mathbf{q} - \\mathbf{q}_0)^T (\\mathbf{q} - \\mathbf{q}_0) + 2\\boldsymbol{\\lambda}^T (C\\mathbf{q} - \\mathbf{d})\n$$\nThe factor of $2$ is for algebraic convenience. The optimal solution $(\\mathbf{q}, \\boldsymbol{\\lambda})$ must be a stationary point of the Lagrangian. We find this by setting the gradients with respect to $\\mathbf{q}$ and $\\boldsymbol{\\lambda}$ to zero.\n\nThe gradient with respect to $\\mathbf{q}$ is:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\mathbf{q}} = 2 A^T(A\\mathbf{q} - \\mathbf{v}) + 2\\alpha(\\mathbf{q} - \\mathbf{q}_0) + 2C^T\\boldsymbol{\\lambda} = 0\n$$\n$$\n(A^T A + \\alpha I)\\mathbf{q} + C^T\\boldsymbol{\\lambda} = A^T\\mathbf{v} + \\alpha\\mathbf{q}_0\n$$\nwhere $I$ is the identity matrix.\n\nThe gradient with respect to $\\boldsymbol{\\lambda}$ simply recovers the constraint equations:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\boldsymbol{\\lambda}} = 2(C\\mathbf{q} - \\mathbf{d}) = 0 \\implies C\\mathbf{q} = \\mathbf{d}\n$$\nThese two resulting matrix equations form a single, larger system of linear equations, often called a Karush-Kuhn-Tucker (KKT) system. In block matrix form, it is:\n$$\n\\begin{pmatrix}\nA^T A + \\alpha I & C^T \\\\\nC & 0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{q} \\\\\n\\boldsymbol{\\lambda}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nA^T \\mathbf{v} + \\alpha \\mathbf{q}_0 \\\\\n\\mathbf{d}\n\\end{pmatrix}\n$$\nThis is a standard linear system of the form $K \\mathbf{x} = \\mathbf{b}$, where $K$ is the block KKT matrix, $\\mathbf{x}$ is the concatenation of the unknown charge vector $\\mathbf{q}$ and the Lagrange multiplier vector $\\boldsymbol{\\lambda}$, and $\\mathbf{b}$ is the known right-hand-side vector. By constructing these matrices and vectors from the problem's givens, we can solve for $\\mathbf{x}$ using standard linear algebra libraries. The first $N$ elements of the solution vector $\\mathbf{x}$ will yield the desired fitted charges $\\mathbf{q}$.\n\nFor the final test case, we evaluate the performance of this electrostatic embedding by comparing the residual error against a mechanical embedding model where all fitted charges are zero ($\\mathbf{q}=\\mathbf{0}$). The metric is the normalized residual ratio $R$:\n$$\nR = \\frac{\\lVert \\mathbf{v} - A \\mathbf{q}_{\\mathrm{fit}} \\rVert^{2}}{\\lVert \\mathbf{v} \\rVert^{2}}\n$$\nwhere $\\mathbf{q}_{\\mathrm{fit}}$ is the charge vector obtained from solving the KKT system. A value of $R$ close to $0$ indicates a near-perfect fit, while a value of $1$ corresponds to the error of the mechanical embedding model ($\\mathbf{q}=\\mathbf{0}$), indicating no improvement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define, solve, and report results for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"R_unknown\": np.array([\n                [0.0, 0.0, 0.0],\n                [2.0, 0.0, 0.0],\n                [0.0, 2.0, 0.0]\n            ]),\n            \"q_true\": np.array([0.3, -0.15, -0.15]),\n            \"grid\": np.array([\n                [1.0, 0.5, 0.0],\n                [1.0, 1.5, 0.0],\n                [0.5, 1.0, 0.0],\n                [2.5, 0.5, 0.0],\n                [-0.5, -0.5, 0.0]\n            ]),\n            \"fixed_charges\": [{\"q\": 0.1, \"R\": np.array([5.0, 5.0, 0.0])}],\n            \"fragments\": [\n                {\"indices\": [0, 1], \"charge\": 0.0},\n                {\"indices\": [2], \"charge\": 0.0}\n            ],\n            \"alpha\": 0.0,\n            \"q0\": np.array([0.0, 0.0, 0.0]),\n            \"extra_constraints\": [],\n            \"compute_metric\": False\n        },\n        # Test Case 2\n        {\n            \"R_unknown\": np.array([\n                [0.0, 0.0, 0.0],\n                [1.5, 0.0, 0.0]\n            ]),\n            \"q_true\": np.array([0.2, -0.2]),\n            \"grid\": np.array([\n                [0.75, 0.5, 0.0],\n                [1.2, 0.3, 0.0],\n                [0.3, -0.4, 0.0],\n                [1.6, 0.5, 0.0]\n            ]),\n            \"fixed_charges\": [],\n            \"fragments\": [\n                {\"indices\": [0, 1], \"charge\": 0.0}\n            ],\n            \"alpha\": 0.0,\n            \"q0\": np.array([0.0, 0.0]),\n            \"extra_constraints\": [{\"index\": 0, \"value\": 0.0}],\n            \"compute_metric\": False\n        },\n        # Test Case 3\n        {\n            \"R_unknown\": np.array([\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [0.0, 1.0, 0.0],\n                [1.0, 1.0, 0.0]\n            ]),\n            \"q_true\": np.array([0.12, -0.08, 0.03, -0.07]),\n            \"grid\": np.array([\n                [0.5, 0.2, 0.0],\n                [0.2, 0.7, 0.0],\n                [0.8, 0.8, 0.0]\n            ]),\n            \"fixed_charges\": [],\n            \"fragments\": [\n                {\"indices\": [0, 1], \"charge\": 0.0},\n                {\"indices\": [2, 3], \"charge\": 0.0}\n            ],\n            \"alpha\": 0.1,\n            \"q0\": np.array([0.1, -0.1, 0.05, -0.05]),\n            \"extra_constraints\": [],\n            \"compute_metric\": False\n        },\n        # Test Case 4\n        {\n            \"R_unknown\": np.array([\n                [0.0, 0.0, 0.0],\n                [2.0, 2.0, 0.0]\n            ]),\n            \"q_true\": np.array([0.25, -0.25]),\n            \"grid\": np.array([\n                [0.5, 0.5, 0.0],\n                [1.0, 1.0, 0.0],\n                [1.5, 1.5, 0.0],\n                [2.5, 0.5, 0.0],\n                [0.5, 2.5, 0.0]\n            ]),\n            \"fixed_charges\": [],\n            \"fragments\": [\n                {\"indices\": [0, 1], \"charge\": 0.0}\n            ],\n            \"alpha\": 0.0,\n            \"q0\": np.array([0.0, 0.0]),\n            \"extra_constraints\": [],\n            \"compute_metric\": True\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        res = solve_constrained_lsq(case)\n        results.append(res)\n    \n    # Format the final output string according to the specification\n    formatted_parts = []\n    for r in results:\n        if isinstance(r, (list, np.ndarray)):\n            # Format list of charges to 6 decimal places\n            formatted_parts.append(f\"[{','.join(f'{x:.6f}' for x in r)}]\")\n        else:\n            # Format scalar metric to 6 decimal places\n            formatted_parts.append(f\"{r:.6f}\")\n    \n    print(f\"[{','.join(formatted_parts)}]\")\n\n\ndef solve_constrained_lsq(params):\n    \"\"\"\n    Solves a single constrained least-squares problem based on the provided parameters.\n    \"\"\"\n    R_unknown = params[\"R_unknown\"]\n    q_true = params[\"q_true\"]\n    grid = params[\"grid\"]\n    fixed_charges = params[\"fixed_charges\"]\n    fragments = params[\"fragments\"]\n    alpha = params[\"alpha\"]\n    q0 = params[\"q0\"]\n    extra_constraints = params[\"extra_constraints\"]\n\n    num_charges = len(R_unknown)\n    num_grid_pts = len(grid)\n\n    # 1. Construct the 'A' matrix\n    A = np.zeros((num_grid_pts, num_charges))\n    for j in range(num_grid_pts):\n        for i in range(num_charges):\n            dist = np.linalg.norm(grid[j] - R_unknown[i])\n            if dist > 1e-9: # Avoid division by zero if a grid point coincides with a charge site\n                A[j, i] = 1.0 / dist\n            else:\n                A[j, i] = 1e9 # A large number, though this case is not in the tests\n\n    # 2. Construct the effective target potential vector 'v'\n    # The problem specifies that the QM potential is built from true and fixed charges,\n    # and then the fixed charge contribution is subtracted to get the target vector 'v'.\n    # This simplifies to v = A @ q_true.\n    v = A @ q_true\n\n    # 3. Construct the constraint matrix 'C' and vector 'd'\n    num_constraints = len(fragments) + len(extra_constraints)\n    C = np.zeros((num_constraints, num_charges))\n    d = np.zeros(num_constraints)\n    \n    constraint_idx = 0\n    # Fragment neutrality constraints\n    for frag in fragments:\n        for charge_idx in frag[\"indices\"]:\n            C[constraint_idx, charge_idx] = 1.0\n        d[constraint_idx] = frag[\"charge\"]\n        constraint_idx += 1\n    \n    # Additional constraints (e.g., link-atom charge)\n    for const in extra_constraints:\n        C[constraint_idx, const[\"index\"]] = 1.0\n        d[constraint_idx] = const[\"value\"]\n        constraint_idx += 1\n\n    # 4. Construct the KKT (Karush-Kuhn-Tucker) system\n    # Top-left block: A^T A + alpha * I\n    M_TL = A.T @ A + alpha * np.identity(num_charges)\n\n    # Top-right block: C^T\n    M_TR = C.T\n\n    # Bottom-left block: C\n    M_BL = C\n\n    # Bottom-right block: zeros\n    M_BR = np.zeros((num_constraints, num_constraints))\n    \n    # Assemble the full KKT matrix\n    K = np.block([[M_TL, M_TR], [M_BL, M_BR]])\n\n    # Assemble the right-hand-side vector\n    b_top = A.T @ v + alpha * q0\n    b_bottom = d\n    b = np.concatenate([b_top, b_bottom])\n\n    # 5. Solve the linear system\n    try:\n        solution_vec = np.linalg.solve(K, b)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudo-inverse for stability, although not expected for these test cases\n        solution_vec = np.linalg.pinv(K) @ b\n\n\n    # The fitted charges are the first 'num_charges' elements of the solution\n    q_fit = solution_vec[:num_charges]\n\n    if params[\"compute_metric\"]:\n        # 6. Compute the normalized residual ratio R for Test Case 4\n        # Note: v = A @ q_true\n        residual_vec = v - (A @ q_fit)\n        norm_sq_residual = np.dot(residual_vec, residual_vec)\n        norm_sq_v = np.dot(v, v)\n        \n        if norm_sq_v  1e-12: # Avoid division by zero\n            return 0.0\n        \n        R = norm_sq_residual / norm_sq_v\n        return R\n    else:\n        return q_fit\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}