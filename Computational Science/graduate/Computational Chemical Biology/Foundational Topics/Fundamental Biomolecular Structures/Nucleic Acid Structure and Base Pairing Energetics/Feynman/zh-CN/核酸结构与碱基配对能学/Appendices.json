{
    "hands_on_practices": [
        {
            "introduction": "我们将从氢键的静电本质入手。这项练习将氢键简化为其核心的静电相互作用，通过一个简化的偶极-偶极相互作用模型来计算在鸟嘌呤-胞嘧啶（G-C）碱基对中破坏一个氢键的能量代价。通过这个练习，你将深入理解一些基本原理，例如相互作用的距离依赖性以及由相对介电常数 $\\epsilon$ 表征的溶剂环境在调节键能方面的关键作用，从而为碱基配对的稳定性建立物理直觉。",
            "id": "3857048",
            "problem": "考虑一个鸟嘌呤-胞嘧啶（guanine-cytosine）碱基对，其中三个碱基间氢键被近似为嵌入在均匀电介质连续体中的独立偶极-偶极相互作用。将每个氢键建模为两个相同点偶极子之间的相互作用，偶极矩大小为 $\\mu$，沿着供体-受体轴共线取向，中心间距为 $r$。溶剂被视为相对介电常数为 $\\epsilon$ 的线性均匀电介质，真空介电常数为 $\\varepsilon_{0}$。假设偶极-偶极相互作用是氢键稳定性的唯一贡献者，并忽略氢键之间的任何耦合。将完整的鸟嘌呤-胞嘧啶碱基对视为具有 $3$ 个此类相同的偶极-偶极相互作用；当一个氢键断裂时，只剩下 $2$ 个，且剩余偶极子的几何构型和大小保持不变。\n\n仅使用基于库仑定律（Coulomb's law）的静电学、点偶极子的定义以及连续介电屏蔽，推导在相对介电常数为 $\\epsilon$ 的介质中两个共线点偶极子的相互作用能，并用它来计算该碱基对在断裂单个氢键时总氢键稳定能的变化。将能量变化定义为\n$$\n\\Delta E(\\epsilon) \\equiv E_{\\text{broken}} - E_{\\text{intact}},\n$$\n其中 $E_{\\text{intact}}$ 和 $E_{\\text{broken}}$ 分别是具有 $3$ 个和 $2$ 个氢键时的总偶极-偶极稳定能。请用 $\\mu$、$r$、$\\varepsilon_{0}$ 和 $\\epsilon$ 表示 $\\Delta E(\\epsilon)$，给出一个单一的闭式表达式作为您的最终结果。能量以焦耳为单位表示。不要代入数值。最终答案必须是单个解析表达式。",
            "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- **系统：** 具有三个碱基间氢键的鸟嘌呤-胞嘧啶（Guanine-Cytosine）碱基对。\n- **模型：**\n    - 每个氢键近似为独立的偶极-偶极相互作用。\n    - 每个相互作用发生在两个相同的点偶极子之间。\n    - 偶极矩大小：$\\mu$。\n    - 偶极子取向：沿供体-受体轴共线。\n    - 偶极子间距（中心到中心）：$r$。\n- **环境：**\n    - 均匀电介质连续体。\n    - 介质的相对介电常数：$\\epsilon$。\n    - 真空介电常数：$\\varepsilon_{0}$。\n- **假设：**\n    - 偶极-偶极相互作用是氢键稳定性的唯一贡献者。\n    - 忽略氢键间的耦合（能量是可加的）。\n    - 当一个键断裂时，剩余偶极子的几何构型和大小保持不变。\n- **状态：**\n    - 完整状态：$3$ 个相同的偶极-偶极相互作用。总能量为 $E_{\\text{intact}}$。\n    - 断裂状态：$2$ 个相同的偶极-偶极相互作用。总能量为 $E_{\\text{broken}}$。\n- **目标：**\n    - 推导两个共线点偶极子的相互作用能。\n    - 计算总氢键稳定能的变化：$\\Delta E(\\epsilon) \\equiv E_{\\text{broken}} - E_{\\text{intact}}$。\n    - 以 $\\mu$、$r$、$\\varepsilon_{0}$ 和 $\\epsilon$ 表示结果，给出一个单一的闭式表达式。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据、提法恰当且客观。它采用了一种标准且简化的物理模型（电介质连续体中的点偶极子），这在生物物理学中常用于近似静电相互作用。诸如可加性和几何构型不变等假设都已明确说明，以使问题易于处理。所有必需的参数均已定义，目标清晰明确。该问题没有科学缺陷、矛盾和不可形式化的元素。它是计算化学生物学领域内一个有效的理论物理问题。\n\n**步骤3：结论与行动**\n该问题有效。将提供完整解答。\n\n**解题推导**\n\n推导过程分三部分进行：首先，我们确定所建模型的单个氢键的相互作用能；其次，我们计算完整状态和断裂状态的总能量；第三，我们计算指定的能量变化。\n\n**第1部分：两个共线点偶极子的相互作用能**\n\n在相对介电常数为 $\\epsilon$ 的线性均匀电介质中，点偶极子 $\\vec{\\mu}_1$ 在位置 $\\vec{x}$ 处产生的静电势 $V_1$ 由下式给出：\n$$\nV_1(\\vec{x}) = \\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\frac{\\vec{\\mu}_1 \\cdot \\vec{x}}{|\\vec{x}|^3}\n$$\n电场 $\\vec{E}_1$ 是电势的负梯度：\n$$\n\\vec{E}_1(\\vec{x}) = -\\nabla V_1(\\vec{x}) = -\\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\nabla \\left( \\frac{\\vec{\\mu}_1 \\cdot \\vec{x}}{|\\vec{x}|^3} \\right)\n$$\n使用向量恒等式 $\\nabla(\\frac{\\vec{A}\\cdot\\vec{B}}{C}) = \\frac{C(\\nabla(\\vec{A}\\cdot\\vec{B})) - (\\vec{A}\\cdot\\vec{B})\\nabla C}{C^2}$ 及相关梯度法则，偶极子的电场被确定为：\n$$\n\\vec{E}_1(\\vec{x}) = \\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\left( \\frac{3(\\vec{\\mu}_1 \\cdot \\vec{x})\\vec{x}}{|\\vec{x}|^5} - \\frac{\\vec{\\mu}_1}{|\\vec{x}|^3} \\right)\n$$\n第二个偶极子 $\\vec{\\mu}_2$ 置于该电场中位置 $\\vec{x}$ 处的相互作用能 $U$ 为：\n$$\nU = -\\vec{\\mu}_2 \\cdot \\vec{E}_1(\\vec{x}) = -\\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\left( \\frac{3(\\vec{\\mu}_1 \\cdot \\vec{x})(\\vec{\\mu}_2 \\cdot \\vec{x})}{|\\vec{x}|^5} - \\frac{\\vec{\\mu}_1 \\cdot \\vec{\\mu}_2}{|\\vec{x}|^3} \\right)\n$$\n现在我们应用问题的具体条件。设第一个偶极子 $\\vec{\\mu}_1$ 位于原点并沿 $z$ 轴方向。第二个偶极子 $\\vec{\\mu}_2$ 沿同一轴线距离为 $r$ 处。因此，我们有：\n- 第二个偶极子的位置向量：$\\vec{x} = r\\hat{k}$，其中 $\\hat{k}$ 是沿 $z$ 轴的单位向量。其大小为 $|\\vec{x}|=r$。\n- 偶极子相同且共线：$\\vec{\\mu}_1 = \\mu\\hat{k}$ 和 $\\vec{\\mu}_2 = \\mu\\hat{k}$。它们的大小为 $|\\vec{\\mu}_1| = |\\vec{\\mu}_2| = \\mu$。\n\n我们计算点积：\n- $\\vec{\\mu}_1 \\cdot \\vec{\\mu}_2 = (\\mu\\hat{k}) \\cdot (\\mu\\hat{k}) = \\mu^2$\n- $\\vec{\\mu}_1 \\cdot \\vec{x} = (\\mu\\hat{k}) \\cdot (r\\hat{k}) = \\mu r$\n- $\\vec{\\mu}_2 \\cdot \\vec{x} = (\\mu\\hat{k}) \\cdot (r\\hat{k}) = \\mu r$\n\n将这些代入一般能量表达式中：\n$$\nU = -\\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\left( \\frac{3(\\mu r)(\\mu r)}{r^5} - \\frac{\\mu^2}{r^3} \\right)\n$$\n$$\nU = -\\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\left( \\frac{3\\mu^2 r^2}{r^5} - \\frac{\\mu^2}{r^3} \\right) = -\\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\left( \\frac{3\\mu^2}{r^3} - \\frac{\\mu^2}{r^3} \\right)\n$$\n$$\nU = -\\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\left( \\frac{2\\mu^2}{r^3} \\right) = -\\frac{2\\mu^2}{4\\pi\\varepsilon_0\\epsilon r^3}\n$$\n简化后，单个氢键的稳定能 $E_{\\text{H-bond}}$ 为：\n$$\nE_{\\text{H-bond}} = -\\frac{\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3}\n$$\n这个能量是负值，表示一个稳定（吸引）的相互作用。\n\n**第2部分：完整状态和断裂状态的总能量**\n\n问题陈述说明氢键是独立的。因此，总稳定能是各个键能的总和。\n- 对于具有 $3$ 个氢键的完整鸟嘌呤-胞嘧啶对：\n$$\nE_{\\text{intact}} = 3 \\times E_{\\text{H-bond}} = 3 \\left( -\\frac{\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3} \\right) = -\\frac{3\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3}\n$$\n- 对于断裂一个键，剩下 $2$ 个氢键的状态：\n$$\nE_{\\text{broken}} = 2 \\times E_{\\text{H-bond}} = 2 \\left( -\\frac{\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3} \\right) = -\\frac{2\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3}\n$$\n\n**第3部分：稳定能的变化**\n\n问题将能量变化定义为 $\\Delta E(\\epsilon) = E_{\\text{broken}} - E_{\\text{intact}}$。\n$$\n\\Delta E(\\epsilon) = \\left( -\\frac{2\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3} \\right) - \\left( -\\frac{3\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3} \\right)\n$$\n$$\n\\Delta E(\\epsilon) = \\frac{3\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3} - \\frac{2\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3}\n$$\n$$\n\\Delta E(\\epsilon) = \\frac{(3-2)\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3} = \\frac{\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3}\n$$\n结果是正的能量变化，对应于断裂一个氢键所需的能量成本。这与物理直觉相符，因为打破一个稳定相互作用会增加系统的总能量。推导出的表达式是用指定的变量和基本常数表示的。如果所有量都用国际单位制（SI）表示，则所得能量的单位将是焦耳。",
            "answer": "$$\n\\boxed{\\frac{\\mu^{2}}{2\\pi\\varepsilon_{0}\\epsilon r^{3}}}\n$$"
        },
        {
            "introduction": "在理解了氢键的物理本质之后，我们将深入探讨确保高保真碱基配对的化学与几何逻辑。通过分析核碱基互变异构现象的影响，你将探索稀有的化学形式如何改变氢键供体-受体模式，从而导致潜在的突变性错配。这项思想实验将加深你对分子识别以及DNA遗传稳定性的结构基础的理解。",
            "id": "3857051",
            "problem": "在脱氧核糖核酸（DNA）中，碱基配对的特异性源于核碱基边缘上氢键供体和受体的分布，以及这些相互作用位点在配对几何结构中的几何相容性。考虑鸟嘌呤（guanine）和胸腺嘧啶（thymine）的经典酮式（内酰胺）形式，以及由酮-烯醇和氨基-亚氨基质子转移产生的稀有互变异构体形式。\n\n使用以下基本事实和定义作为您的出发点：\n- 氢键供体是带有一个键合质子并能形成氢键的原子；氢键受体是带有一对孤对电子并能接受氢键的原子。典型的供体-受体距离约为 $2.8$–$3.0$ Å，供体-氢-受体角度接近 $180^\\circ$ 以实现最佳键合。\n- 在经典酮式形式中，鸟嘌呤的沃森-克里克（Watson-Crick, WC）边缘呈现 $N1$ 作为氢键供体（$N1\\text{-}H$）、$O6$ 作为氢键受体，以及 $N2$（环外氨基）作为氢键供体（$N2\\text{-}H$）；鸟嘌呤的胡斯坦（Hoogsteen）边缘呈现 $N7$ 作为氢键受体和 $O6$ 作为氢键受体。\n- 在经典酮式形式中，胸腺嘧啶在其沃森-克里克边缘上呈现 $N3\\text{-}H$ 作为氢键供体，以及 $O2$ 和 $O4$ 作为氢键受体；其胡斯坦面涉及 $N3\\text{-}H$（供体）和 $O4$（受体）。\n- Hoogsteen配对通常要求一个处于顺式（syn）糖苷构象的嘌呤通过其Hoogsteen边缘与一个处于反式（anti）构象的嘧啶相互作用，其 $C1'\\text{–}C1'$ 距离约为 $8.6$ Å，相比之下 Watson-Crick 几何结构中的距离约为 $10.5$ Å。嘌呤的Hoogsteen边缘将 $N7$ 和 $O6$ 置于大沟方向。\n- 质子化状态的改变会改变供体/受体状态。例如，胞嘧啶（cytosine）的 $N3$ 位质子化会产生质子化的胞嘧啶（$C^+$），它可以作为来自 $N3\\text{-}H$ 的强氢键供体（在水溶液中，胞嘧啶 $N3$ 的酸解离常数 $pK_a \\approx 4.2$）。\n\n假设互变异构化局限于碱基，并且除了供体/受体身份的改变外，不会显著改变环的平面性或糖-碱基的几何结构。同时假设配对几何结构的位阻限制强制形成近线性的氢键，并且供体-受体匹配必须与配对界面上相互作用位点的空间顺序对齐，以避免供体-供体或受体-受体的冲突。\n\n哪个选项正确描述了在鸟嘌呤和胸腺嘧啶发生互变异构化时氢键供体和受体模式如何变化，并基于几何相容性合理解释了其对沃森-克里克配对与Hoogsteen配对的影响？\n\nA. 鸟嘌呤的 $O6$ 烯醇互变异构体将 $O6$ 转化为供体，将 $N1$ 转化为受体；这通过将鸟嘌呤的 $O6\\text{-}H$ 与胞嘧啶的 $N4\\text{-}H$ 匹配，并将鸟嘌呤的 $N7$ 与胞嘧啶的 $N3$ 匹配，从而在无需胞嘧啶质子化的情况下稳定了鸟嘌呤–胞嘧啶Hoogsteen配对。胸腺嘧啶的 $O4$ 烯醇互变异构体将 $O4$ 转化为供体，将 $N3$ 转化为受体，从而能够与鸟嘌呤形成三个类似沃森-克里克的氢键，并同时因为胸腺嘧啶获得了两个供体而增强了腺嘌呤–胸腺嘧啶Hoogsteen配对。\n\nB. 两种互变异构化都有利于与其经典搭档进行Hoogsteen配对：鸟嘌呤的 $O6\\text{-}H$ 向胞嘧啶的 $N4$ 提供氢键，鸟嘌呤的 $N7$ 从中性胞嘧啶的 $N3$ 接受氢键；胸腺嘧啶的 $O4\\text{-}H$ 向腺嘌呤的 $N7$ 提供氢键，胸腺嘧啶的 $N3$ 从腺嘌呤的 $N6\\text{-}H$ 接受氢键。\n\nC. 鸟嘌呤的 $O6$ 烯醇互变异构体通过将 $O6$ 变为一个氢键供体来补充胞嘧啶的 $N4\\text{-}H$，从而加强了与胞嘧啶的沃森-克里克配对，而胸腺嘧啶的 $O4$ 烯醇互变异构体则因 $N3$ 仍为供体而破坏了在沃森-克里克几何结构中与鸟嘌呤的错配。\n\nD. 胸腺嘧啶的 $O4$ 烯醇互变异构体可以通过将 $O4$ 转化为供体、$N3$ 转化为受体，并保留 $O2$ 作为受体，在沃森-克里克几何结构中模拟胞嘧啶，从而允许与鸟嘌呤形成一个三键网络（$N1\\text{-}H$ to $N3$，$N2\\text{-}H$ to $O2$，以及 $O6$ 从 $O4\\text{-}H$ 接受氢键）。与此同时，鸟嘌呤的 $O6$ 烯醇互变异构体将 $O6$ 转化为供体，将 $N1$ 转化为受体，这既破坏了鸟嘌呤–胞嘧啶沃森-克里克配对，也破坏了鸟嘌呤–胞嘧啶Hoogsteen配对（后者依赖于 $N7$ 和 $O6$ 处的两个受体，并且只有当胞嘧啶在 $N3$ 处质子化时才稳定，即 $C^+$），因此 $O6$ 烯醇形式不会增强与胞嘧啶的Hoogsteen相容性。\n\nE. 鸟嘌呤的 $O6$ 烯醇互变异构体改善了与腺嘌呤的Hoogsteen配对，因为 $O6\\text{-}H$ 可以向腺嘌呤的 $N7$ 提供氢键，而 $N1$ 可以从腺嘌呤的 $N6\\text{-}H$ 接受氢键；胸腺嘧啶的 $O4$ 烯醇互变异构体减少了与鸟嘌呤的沃森-克里克错配，因为 $O4$ 仍为受体，$N3$ 仍为供体。\n\n选择一个选项。",
            "solution": "问题要求找出关于 guanine 和 thymine 的互变异构化对其氢键模式以及在 Watson-Crick 和 Hoogsteen 几何结构中配对潜力的影响的正确描述。\n\n要解决这个问题，我们必须首先确定 guanine 和 thymine 的经典形式和互变异构体形式的氢键供体/受体模式。\n\n**1. Guanine (G) 及其 $O6$ 烯醇互变异构体 ($G^*$) 的分析：**\n\n*   **经典 Guanine（酮式/氨基形式）：**\n    *   如题所述，Watson-Crick (WC) 边缘呈现以下氢键位点：$N1\\text{-}H$（供体，D）、$N2\\text{-}H_2$（供体，D）和 $O6$（受体，A）。这种 D/D/A 模式与 Cytosine (C) 的 A/A/D 模式互补，Cytosine 具有 $N3$ (A)、$O2$ (A) 和 $N4\\text{-}H_2$ (D)，从而允许在 G-C WC 配对中形成三个稳定的氢键：$G(N1\\text{-}H) \\cdots (N3)C$，$G(N2\\text{-}H) \\cdots (O2)C$ 和 $G(O6) \\cdots (H\\text{-}N4)C$。\n    *   经典 guanine 的 Hoogsteen 边缘有 $N7$ (A) 和 $O6$ (A)。这种 A/A 模式可以与处于*顺式*（syn）构象的质子化 Cytosine（$C^+$）配对，后者呈现两个供体，形成一个 G-$C^+$ Hoogsteen 配对。\n\n*   **Guanine $O6$ 烯醇互变异构体 ($G^*$):**\n    *   该互变异构体由质子从 $N1$ 转移到 $O6$ 产生。\n    *   $N1\\text{-}H$ 基团变成带孤对电子的 $N1$，从供体 (D) 变为受体 (A)。\n    *   $C6=O6$ 基团变成 $C6\\text{-}O6\\text{-}H$，使 $O6$ 原子从受体 (A) 变为供体 (D)。\n    *   $N2\\text{-}H_2$ 基团仍然是供体 (D)。\n    *   因此，$G^*$ 的 WC 边缘具有 A/D/D 模式（$N1$ 是 A，$N2$ 是 D，$O6$ 是 D）。\n\n**2. Thymine (T) 及其 $O4$ 烯醇互变异构体 ($T^*$) 的分析：**\n\n*   **经典 Thymine（酮式）：**\n    *   如题所述，WC 边缘呈现 $N3\\text{-}H$ (D)、$O2$ (A) 和 $O4$ (A)。这种 A/D/A 模式与 Adenine (A) 的 D/A/D 模式互补，从而允许在 A-T WC 配对中形成两个氢键：$A(N6\\text{-}H) \\cdots (O4)T$ 和 $A(N1) \\cdots (H\\text{-}N3)T$。\n\n*   **Thymine $O4$ 烯醇互变异构体 ($T^*$):**\n    *   该互变异构体由质子从 $N3$ 转移到 $O4$ 产生。\n    *   $N3\\text{-}H$ 基团变成带孤对电子的 $N3$，从供体 (D) 变为受体 (A)。\n    *   $C4=O4$ 基团变成 $C4\\text{-}O4\\text{-}H$，使 $O4$ 原子从受体 (A) 变为供体 (D)。\n    *   $O2$ 基团仍然是受体 (A)。\n    *   因此，$T^*$ 的 WC 边缘具有 A/A/D 模式（$O2$ 是 A，$N3$ 是 A，$O4$ 是 D）。这种供体/受体模式在空间上类似于 cytosine (A/A/D) 的模式。\n\n在确定了这些模式后，我们可以评估每个选项。\n\n**逐项分析：**\n\n**A. 鸟嘌呤的 $O6$ 烯醇互变异构体将 $O6$ 转化为供体，将 $N1$ 转化为受体；这通过将鸟嘌呤的 $O6\\text{-}H$ 与胞嘧啶的 $N4\\text{-}H$ 匹配，并将鸟嘌呤的 $N7$ 与胞嘧啶的 $N3$ 匹配，从而在无需胞嘧啶质子化的情况下稳定了鸟嘌呤–胞嘧啶Hoogsteen配对。胸腺嘧啶的 $O4$ 烯醇互变异构体将 $O4$ 转化为供体，将 $N3$ 转化为受体，从而能够与鸟嘌呤形成三个类似沃森-克里克的氢键，并同时因为胸腺嘧啶获得了两个供体而增强了腺嘌呤–胸腺嘧啶Hoogsteen配对。**\n\n*   关于互变异构化的初始声明（$G^*$：$O6$ 变为 D，$N1$ 变为 A；$T^*$：$O4$ 变为 D，$N3$ 变为 A）是正确的。\n*   关于稳定 G-C Hoogsteen 配对的说法是不正确的。所提出的配对是 $G^*(O6\\text{-}H)$ 与 $C(N4\\text{-}H)$，这是一个供体-供体冲突，以及 $G^*(N7)$ 与 $C(N3)$，这是一个受体-受体冲突。这将是高度不稳定的。\n*   $T^*$ 能够与 G 形成三个 WC 键的说法是正确的。\n*   A-T Hoogsteen 配对因胸腺嘧啶获得两个供体而增强的说法是不正确的。胸腺嘧啶的 $O4$ 烯醇互变异构体（$T^*$）在其 WC 面上有一个供体（$O4\\text{-}H$）和两个受体（$N3$，$O2$），而不是“两个供体”。\n*   结论：**错误**。\n\n**B. 两种互变异构化都有利于与其经典搭档进行Hoogsteen配对：鸟嘌呤的 $O6\\text{-}H$ 向胞嘧啶的 $N4$ 提供氢键，鸟嘌呤的 $N7$ 从中性胞嘧啶的 $N3$ 接受氢键；胸腺嘧啶的 $O4\\text{-}H$ 向腺嘌呤的 $N7$ 提供氢键，胸腺嘧啶的 $N3$ 从腺嘌呤的 $N6\\text{-}H$ 接受氢键。**\n\n*   G*-C Hoogsteen 配对的描述不正确。鸟嘌呤的 $O6\\text{-}H$ 是供体，胞嘧啶的 $N4\\text{-}H_2$ 基团也是供体，导致冲突。鸟嘌呤的 $N7$ 是受体，中性胞嘧啶的 $N3$ 也是受体，导致另一个冲突。\n*   $T^*$-A Hoogsteen 配对的描述在化学上是合理的。$T^*$ 在其面上呈现一个供体（$O4\\text{-}H$）和一个受体（$N3$）。腺嘌呤的 Hoogsteen 边缘呈现一个受体（$N7$）和一个供体（$N6\\text{-}H_2$）。所提出的配对 $T^*(O4\\text{-}H)\\cdots(N7)A$ (D-A) 和 $T^*(N3)\\cdots(H\\text{-}N6)A$ (A-D)，创建了两个有效的氢键。然而，由于选项的第一部分是错误的，整个选项是无效的。\n*   结论：**错误**。\n\n**C. 鸟嘌呤的 $O6$ 烯醇互变异构体通过将 $O6$ 变为一个氢键供体来补充胞嘧啶的 $N4\\text{-}H$，从而加强了与胞嘧啶的沃森-克里克配对，而胸腺嘧啶的 $O4$ 烯醇互变异构体则因 $N3$ 仍为供体而破坏了在沃森-克里克几何结构中与鸟嘌呤的错配。**\n\n*   $G^*$ 加强与 C 的 WC 配对的说法是错误的。$G^*$ 的 $O6\\text{-}H$ 是供体，C 的 $N4\\text{-}H_2$ 也是供体。这在第三个氢键的位置上产生了供体-供体排斥，破坏了配对。\n*   $T^*$ 破坏与 G 的错配的说法是错误的。正如我们初步分析所示，$T^*$ 具有类似 C 的氢键模式，并*促成*了与 G 的一个稳定的三键错配。\n*   所给出的理由“因为 $N3$ 仍为供体”是事实错误的。在 $O4$ 烯醇互变异构体中，$N3$ 变成了受体。\n*   结论：**错误**。\n\n**D. 胸腺嘧啶的 $O4$ 烯醇互变异构体可以通过将 $O4$ 转化为供体、$N3$ 转化为受体，并保留 $O2$ 作为受体，在沃森-克里克几何结构中模拟胞嘧啶，从而允许与鸟嘌呤形成一个三键网络（$N1\\text{-}H$ to $N3$，$N2\\text{-}H$ to $O2$，以及 $O6$ 从 $O4\\text{-}H$ 接受氢键）。与此同时，鸟嘌呤的 $O6$ 烯醇互变异构体将 $O6$ 转化为供体，将 $N1$ 转化为受体，这既破坏了鸟嘌呤–胞嘧啶沃森-克里克配对，也破坏了鸟嘌呤–胞嘧啶Hoogsteen配对（后者依赖于 $N7$ 和 $O6$ 处的两个受体，并且只有当胞嘧啶在 $N3$ 处质子化时才稳定，即 $C^+$），因此 $O6$ 烯醇形式不会增强与胞嘧啶的Hoogsteen相容性。**\n\n*   第一部分（关于 $T^*$）的分析：对互变异构化的描述（$O4$：A→D；$N3$：D→A）是正确的。由此产生的类似 C 的模拟是正确的。所提出的与 G 形成的三键网络是正确的：$G(N1\\text{-}H)\\cdots(N3)T^*$ (D-A)，$G(N2\\text{-}H)\\cdots(O2)T^*$ (D-A)，以及 $G(O6)\\cdots(H\\text{-}O4)T^*$ (A-D)。这部分完全准确。\n*   第二部分（关于 $G^*$）的分析：对互变异构化的描述（$O6$：A→D；$N1$：D→A）是正确的。关于这会破坏 G-C WC 配对的结论是正确的，因为 $G^*$ 具有 A/D/D 模式，与 C 的 A/A/D 模式在两个位置上发生冲突（$N1\\cdots N3$ 是 A-A，$O6\\cdots N4$ 是 D-D）。关于经典 G-$C^+$ Hoogsteen 配对需要在 G 上有两个受体（$N7, O6$）的描述是正确的。互变异构化将此模式更改为 A/D（$N7, O6\\text{-}H$），这破坏了与 $C^+$ 上两个供体的必要互补性。最终结论，$G^*$ 互变异构体不增强与 cytosine（无论是中性 C 还是 $C^+$）的 Hoogsteen 相容性，也是正确的。\n*   结论：**正确**。\n\n**E. 鸟嘌呤的 $O6$ 烯醇互变异构体改善了与腺嘌呤的Hoogsteen配对，因为 $O6\\text{-}H$ 可以向腺嘌呤的 $N7$ 提供氢键，而 $N1$ 可以从腺嘌呤的 $N6\\text{-}H$ 接受氢键；胸腺嘧啶的 $O4$ 烯醇互变异构体减少了与鸟嘌呤的沃森-克里克错配，因为 $O4$ 仍为受体，$N3$ 仍为供体。**\n\n*   G*-A Hoogsteen 配对的理由在几何上是混乱的。它提出了使用鸟嘌呤的 $O6$ 和 $N1$ 与腺嘌呤的 $N7$ 和 $N6$ 进行配对。这些位点在任何标准配对几何结构中都不能对齐；$N1$ 在 WC 边缘，而 $O6$ 和 $N7$ 在 Hoogsteen 边缘。\n*   关于 $T^*$ 互变异构体的说法是事实错误的。它*增强*了而非减少了与 G 的 WC 错配。进一步的说法“$O4$ 仍为受体，$N3$ 仍为供体”与互变异构化过程中发生的情况正好相反。\n*   结论：**错误**。\n\n总结：只有选项 D 对两种互变异构化的后果提供了化学上和几何上都合理的分析。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "最后的练习将所有概念整合到一个强大的计算框架中，用于描绘碱基对解离的完整能量图景。你将通过实现加权直方图分析方法（Weighted Histogram Analysis Method, WHAM），从模拟数据中重建碱基对打开过程的平均力势（Potential of Mean Force, PMF）。这项高级练习将为你提供计算生物物理学中一个基石技术的实践经验，该技术用于量化DNA“呼吸”等复杂过程，揭示其自由能垒和配对态的稳定性。",
            "id": "3857041",
            "problem": "设计一个完整的程序，使用加权直方图分析方法（WHAM）沿一个集体坐标重建碱基对打开的平均力势（PMF）。重建将基于为物理上合理的无偏采样模型生成的合成伞形采样直方图进行。其物理基础是玻尔兹曼分布，其中沿打开坐标 $q$ 的无偏概率密度与 $\\exp(-\\beta F_0(q))$ 成正比，其中 $\\beta = 1/(R T)$，$R$ 是摩尔气体常数。您必须从第一性原理出发，基于玻尔兹曼分布、谐波伞形偏置以及重叠窗口间的最大似然一致性的定义来推导重建过程。程序必须为指定的测试套件生成确定性直方图，执行WHAM重建以获得无偏概率的估计，然后将该概率转换为平均力势。能量必须以千焦/摩尔（kJ/mol）报告，角度以弧度报告，距离以纳米（nm）报告。所有对数均为自然对数。在所有情况下，使用 $R = 0.008314462618$ kJ/mol/K 和 $T = 298$ K，并以 kJ/mol 表示最终能量。程序不应依赖任何随机性、用户输入或外部文件。\n\n合成数据的基本定义和生成模型如下。设沿 $q$ 的无偏概率密度是代表闭合和开放构型的两个高斯分量的混合。定义 $p_0(q) \\propto w_1 \\exp\\left(-\\frac{(q - \\mu_1)^2}{2 \\sigma_1^2}\\right) + w_2 \\exp\\left(-\\frac{(q - \\mu_2)^2}{2 \\sigma_2^2}\\right)$，其中权重 $w_1$ 和 $w_2$ 为正。在具有谐波偏置 $U_i(q) = \\frac{1}{2} k_i (q - q_i)^2$ 的伞形窗口 $i$ 中，有偏采样密度为 $p_i(q) \\propto p_0(q) \\exp(-\\beta U_i(q))$。通过在均匀间隔的网格上离散化 $q$ 并根据归一化的 $p_i(q)$ 在各区间中确定性地分配总样本数 $M_i$ 来生成合成直方图。这种确定性分配必须确保总计数恰好等于 $M_i$。从跨窗口的有偏直方图集合中，重建各区间上的无偏概率，并将其转换为平均力势 $W(q) = - \\frac{1}{\\beta} \\ln P(q) + C$，其中 $C$ 的选择应使 $W(q)$ 的最小值为零。\n\nWHAM必须通过求解一组源于以下条件的自洽方程来实现：无偏概率 $P(q)$ 必须在各自的偏置下与所有有偏直方图兼容，并满足每个窗口的归一化约束。重建必须通过迭代直至收敛来完成。重建后，使用指定区间识别对应于闭合和开放状态的两个势阱，并计算两个度量：能垒高度和势阱之间的自由能差。能垒高度定义为 $W(q^\\ddagger) - \\min\\{W(q_{\\text{closed}}^{\\ast}), W(q_{\\text{open}}^{\\ast})\\}$，其中 $q_{\\text{closed}}^{\\ast}$ 和 $q_{\\text{open}}^{\\ast}$ 分别是闭合和开放状态指定势阱区间内的局部最小值所在的区间位置，$q^\\ddagger$ 是这些最小值之间的局部最大值的位置。自由能差定义为 $W(q_{\\text{open}}^{\\ast}) - W(q_{\\text{closed}}^{\\ast})$。以千焦/摩尔（kJ/mol）报告这两个度量，在程序中四舍五入到全精度浮点数，不进行显式舍入。\n\n您的程序必须实现以下三个测试案例，这些案例共同测试了对分离坐标和角度坐标的重建，一个具有大量窗口重叠的理想情况，以及一个重叠不良的挑战性边缘案例。对于所有测试案例，使用 $\\beta = 1/(R T)$，其中 $R = 0.008314462618$ kJ/mol/K，$T = 298$ K。网格离散化是均匀的，并且在所有计算中应用相同的 $\\beta$。\n\n- 测试案例1（分离坐标，理想情况）：\n    - 坐标：$q = x$，单位为纳米。\n    - 网格：$x \\in [0.24, 0.60]$ nm，箱宽 $\\Delta x = 0.002$ nm。\n    - 无偏混合参数：$w_1 = 1.0$，$w_2 = 0.5$，$\\mu_1 = 0.30$ nm，$\\sigma_1 = 0.015$ nm，$\\mu_2 = 0.52$ nm，$\\sigma_2 = 0.020$ nm。\n    - 窗口数量：$K = 7$，窗口中心 $q_i \\in \\{0.28, 0.32, 0.36, 0.42, 0.48, 0.52, 0.56\\}$ nm，所有 $i$ 的弹簧常数 $k_i = 1500$ kJ/mol/nm$^2$，每个窗口的样本数 $M_i = 5000$。\n    - 势阱区间：闭合势阱 $x \\in [0.27, 0.36]$ nm；开放势阱 $x \\in [0.47, 0.57]$ nm。\n\n- 测试案例2（角度坐标，理想情况）：\n    - 坐标：$q = \\theta$，单位为弧度。\n    - 网格：$\\theta \\in [0.00, 0.90]$ rad，箱宽 $\\Delta \\theta = 0.01$ rad。\n    - 无偏混合参数：$w_1 = 1.0$，$w_2 = 0.25$，$\\mu_1 = 0.00$ rad，$\\sigma_1 = 0.12$ rad，$\\mu_2 = 0.60$ rad，$\\sigma_2 = 0.12$ rad。\n    - 窗口数量：$K = 5$，窗口中心 $q_i \\in \\{0.00, 0.20, 0.40, 0.60, 0.80\\}$ rad，所有 $i$ 的弹簧常数 $k_i = 60$ kJ/mol/rad$^2$，每个窗口的样本数 $M_i = 5000$。\n    - 势阱区间：闭合势阱 $\\theta \\in [0.00, 0.25]$ rad；开放势阱 $\\theta \\in [0.50, 0.80]$ rad。\n\n- 测试案例3（分离坐标，重叠不良的边缘案例）：\n    - 坐标：$q = x$，单位为纳米。\n    - 网格：$x \\in [0.24, 0.60]$ nm，箱宽 $\\Delta x = 0.002$ nm。\n    - 无偏混合参数：$w_1 = 1.0$，$w_2 = 0.5$，$\\mu_1 = 0.30$ nm，$\\sigma_1 = 0.015$ nm，$\\mu_2 = 0.52$ nm，$\\sigma_2 = 0.020$ nm。\n    - 窗口数量：$K = 3$，窗口中心 $q_i \\in \\{0.30, 0.42, 0.54\\}$ nm，所有 $i$ 的弹簧常数 $k_i = 6000$ kJ/mol/nm$^2$，每个窗口的样本数 $M_i = 2000$。\n    - 势阱区间：闭合势阱 $x \\in [0.27, 0.36]$ nm；开放势阱 $x \\in [0.47, 0.57]$ nm。\n\n算法要求：\n- 为每个测试案例在网格上构建 $p_0(q)$（最多相差一个比例常数），并与谐波偏置结合以获得每个窗口中归一化的 $p_i(q)$。\n- 确定性地分配整数直方图计数 $n_i(q)$，使得 $\\sum_{q} n_i(q) = M_i$ 恰好成立，使用一种方案，该方案为每个区间分配 $\\lfloor M_i p_i(q) \\rfloor$ 个计数，然后按残差降序分配剩余的计数，直到所有 $M_i$ 个样本都被分配完毕。\n- 从第一性原理推导并实现迭代的WHAM重建。不要使用任何预封装的WHAM函数。迭代方案必须收敛到一个自洽的 $P(q)$（在各区间上）和窗口自由能偏移，并在每个窗口中强制执行归一化约束。\n- 将重建的 $P(q)$ 转换为以 kJ/mol 为单位的 $W(q)$，并进行归一化，使得 $\\min_q W(q) = 0$。\n- 识别势阱最小值和其间的能垒，并计算能垒高度和势阱自由能差。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试案例，并且本身是一个包含能垒高度和势阱自由能差（单位为 kJ/mol）的双元素列表。例如，输出格式应严格符合 $[[b_1,\\Delta_1],[b_2,\\Delta_2],[b_3,\\Delta_3]]$ 的形式，其中 $b_i$ 是能垒高度，$\\Delta_i$ 是测试案例 $i$ 的开放状态减去闭合状态的自由能差。",
            "solution": "问题陈述已经过严格验证，被认为是科学上合理、定义明确、客观且完整的。它描述了计算生物物理学中一个标准且重要的过程：使用加权直方图分析方法（WHAM）从有偏模拟中重建平均力势（PMF）。所提供的参数和测试案例在物理上是合理的，在计算上也是可行的。因此，我们可以进行形式化的推导和求解。\n\n核心任务是从一组有偏直方图 $\\{n_i(q)\\}$（由 $K$ 个独立的模拟窗口生成）中，重建沿集体坐标 $q$ 的无偏概率分布 $P(q)$。每个窗口 $i$ 都受到一个偏置势 $U_i(q)$ 的作用。\n\n基本原理是玻尔兹曼分布。系统处于由坐标 $q$ 表征的状态的无偏概率与其平均力势 $F_0(q)$ 相关：\n$$\nP(q) \\propto \\exp(-\\beta F_0(q))\n$$\n其中 $\\beta = 1/(RT)$ 是逆温度，$R$ 是摩尔气体常数，$T$ 是绝对温度。因此，PMF 为 $F_0(q) = -\\frac{1}{\\beta} \\ln P(q) + C$，其中 $C$ 是一个任意常数。\n\n在伞形采样中，每个窗口 $i$ 中都增加一个偏置势 $U_i(q)$。产生的有偏概率分布 $p_i(q)$ 由下式给出：\n$$\np_i(q) \\propto P(q) \\exp(-\\beta U_i(q))\n$$\n在窗口 $i$ 中采样的总概率是归一化的。设 $f_i$ 是窗口 $i$ 相对于无偏系统的自由能偏移。这个偏移量充当归一化常数的对数：\n$$\n\\exp(-\\beta f_i) = \\int P(q) \\exp(-\\beta U_i(q)) dq\n$$\n对于一个区间中心为 $q_j$ 的离散化坐标网格，这变成一个求和：\n$$\n\\exp(-\\beta f_i) = \\sum_{j} P(q_j) \\exp(-\\beta U_i(q_j))\n$$\n因此，窗口 $i$ 中区间 $j$ 的归一化有偏概率为：\n$$\np_i(q_j) = \\frac{P(q_j) \\exp(-\\beta U_i(q_j))}{\\sum_k P(q_k) \\exp(-\\beta U_i(q_k))} = P(q_j) \\exp(-\\beta U_i(q_j)) \\exp(\\beta f_i)\n$$\n\nWHAM方程是通过最大化观测到直方图集合 $\\{n_i(q_j)\\}$ 的似然性推导出来的，其中 $n_i(q_j)$ 是窗口 $i$ 中区间 $j$ 的计数。窗口 $i$ 的总样本数为 $M_i = \\sum_j n_i(q_j)$。忽略常数项，观测到完整数据集的对数似然函数 $\\ln \\mathcal{L}$ 为：\n$$\n\\ln \\mathcal{L} = \\sum_{i=1}^{K} \\sum_{j} n_i(q_j) \\ln p_i(q_j)\n$$\n代入 $p_i(q_j)$ 的表达式：\n$$\n\\ln \\mathcal{L} = \\sum_{i=1}^{K} \\sum_{j} n_i(q_j) \\left( \\ln P(q_j) - \\beta U_i(q_j) + \\beta f_i \\right)\n$$\n我们希望找到一组概率 $\\{P(q_j)\\}$ 和自由能 $\\{f_i\\}$，使得在约束条件 $\\sum_j P(q_j) = 1$ 和 $f_i$ 的定义下，$\\ln \\mathcal{L}$ 最大化。这个优化问题引出一组自洽方程。通过对相应的拉格朗日量关于每个 $P(q_j)$ 求偏导并令其为零，我们得到 $P(q_j)$ 的最优估计：\n$$\nP(q_j) = \\frac{\\sum_{i=1}^{K} n_i(q_j)}{\\sum_{k=1}^{K} M_k \\exp(\\beta f_k - \\beta U_k(q_j))} \\quad \\text{(方程 1)}\n$$\n该方程提供了区间 $j$ 中无偏概率的最佳估计，作为来自所有窗口观测值的加权平均。权重取决于窗口自由能 $f_k$。\n\n自由能 $f_i$ 本身由归一化条件决定，我们重述如下：\n$$\n\\exp(-\\beta f_i) = \\sum_{j} P(q_j) \\exp(-\\beta U_i(q_j)) \\quad \\text{(方程 2)}\n$$\n这可以重新整理以求解 $f_i$：\n$$\nf_i = -\\frac{1}{\\beta} \\ln \\left( \\sum_{j} P(q_j) \\exp(-\\beta U_i(q_j)) \\right)\n$$\n\n方程1和方程2构成一个耦合的非线性系统，必须通过迭代求解 $\\{P(q_j)\\}$ 和 $\\{f_i\\}$。对所有 $f_i$ 加上一个任意常数不会改变 $P(q_j)$ 的解，因此我们在整个迭代过程中固定一个值，例如 $f_1 = 0$。\n\n迭代算法如下：\n1.  初始化自由能，例如，对于所有 $i=1, \\dots, K$，令 $f_i = 0$。\n2.  开始迭代：\n    a. 使用当前的 $\\{f_i\\}$ 集合和直方图数据 $\\{n_i(q_j)\\}$，通过方程1计算所有区间 $j$ 的无偏概率 $P(q_j)$。\n    b. 归一化得到的概率分布：$P(q_j) \\leftarrow P(q_j) / \\sum_k P(q_k)$。\n    c. 使用更新后的 $\\{P(q_j)\\}$，通过方程2计算一组新的自由能 $\\{f_i^{\\text{new}}\\}$。\n    d. 通过平移新的自由能来固定任意常数，例如，$f_i^{\\text{new}} \\leftarrow f_i^{\\text{new}} - f_1^{\\text{new}}$。\n    e. 通过比较 $\\{f_i^{\\text{new}}\\}$ 和之前的 $\\{f_i\\}$ 来检查收敛性。如果最大绝对差小于定义的容差，则解已收敛。否则，设置 $f_i \\leftarrow f_i^{\\text{new}}$ 并从步骤2a重复。\n\n在应用WHAM之前，确定性地生成合成直方图。无偏概率密度 $p_0(q)$ 定义为高斯混合。对于每个窗口 $i$，在网格上计算有偏概率密度 $p_i(q) \\propto p_0(q)\\exp(-\\beta U_i(q))$ 并进行归一化。然后，将总共 $M_i$ 个样本分配到各个区间。首先将整数计数分配为 $n_i(q_j) = \\lfloor M_i p_i(q_j) \\rfloor$。剩余的 $M_i - \\sum_j n_i(q_j)$ 个样本将根据最大的残差 $r_j = M_i p_i(q_j) - n_i(q_j)$ 逐一分配到区间中，直到总计数与 $M_i$ 匹配。\n\n一旦获得收敛的无偏概率分布 $P(q)$，PMF 就计算为 $W(q) = -\\frac{1}{\\beta} \\ln P(q)$。为防止数值错误，在取对数之前对 $P(q)$ 应用一个小的正数下限。通过减去其最小值来归一化PMF，使得 $\\min(W(q)) = 0$。\n\n最后，计算所需的度量。在指定的势阱区间内找到局部最小值 $q_{\\text{closed}}^{\\ast}$ 和 $q_{\\text{open}}^{\\ast}$。在这两个最小值之间的PMF剖面上定位局部最大值 $q^{\\ddagger}$。能垒高度为 $W(q^\\ddagger) - \\min\\{W(q_{\\text{closed}}^{\\ast}), W(q_{\\text{open}}^{\\ast})\\}$，自由能差为 $\\Delta W = W(q_{\\text{open}}^{\\ast}) - W(q_{\\text{closed}}^{\\ast})$。",
            "answer": "```python\nimport numpy as np\n\nclass WHAMAnalysis:\n    \"\"\"\n    Encapsulates the logic for a single WHAM test case, from data generation\n    to PMF reconstruction and analysis.\n    \"\"\"\n    def __init__(self, test_case_params):\n        \"\"\"\n        Initializes the analysis with parameters for a specific test case.\n        \"\"\"\n        self.params = test_case_params\n        self.R = 0.008314462618  # kJ/mol/K\n        self.T = 298.0  # K\n        self.beta = 1.0 / (self.R * self.T)\n\n        grid_params = self.params['grid']\n        self.q = np.arange(\n            grid_params['range'][0],\n            grid_params['range'][1] + grid_params['width'] / 2.0,\n            grid_params['width']\n        )\n        self.num_bins = len(self.q)\n\n    def _generate_synthetic_data(self):\n        \"\"\"\n        Generates deterministic histograms based on the problem's generative model.\n        \"\"\"\n        # 1. Unbiased probability density (unnormalized)\n        p0_params = self.params['unbiased_mixture']\n        p0 = p0_params['w1'] * np.exp(-((self.q - p0_params['mu1'])**2) / (2 * p0_params['sigma1']**2)) + \\\n             p0_params['w2'] * np.exp(-((self.q - p0_params['mu2'])**2) / (2 * p0_params['sigma2']**2))\n\n        # 2. Biased histograms for each window\n        num_windows = self.params['num_windows']\n        window_centers = self.params['window_centers']\n        spring_constants = self.params['spring_constants']\n        samples_per_window = self.params['samples_per_window']\n\n        histograms = np.zeros((num_windows, self.num_bins), dtype=int)\n        biases = np.zeros((num_windows, self.num_bins))\n\n        for i in range(num_windows):\n            # Calculate bias potential U_i(q)\n            U_i = 0.5 * spring_constants[i] * (self.q - window_centers[i])**2\n            biases[i, :] = U_i\n\n            # Calculate biased probability density p_i(q)\n            p_i = p0 * np.exp(-self.beta * U_i)\n            \n            # Normalize p_i\n            p_i_normalized = p_i / np.sum(p_i)\n\n            # Deterministic histogram generation\n            M_i = samples_per_window[i]\n            expected_counts = M_i * p_i_normalized\n            \n            base_counts = np.floor(expected_counts).astype(int)\n            histograms[i, :] = base_counts\n            \n            remainder_count = M_i - np.sum(base_counts)\n            if remainder_count > 0:\n                residuals = expected_counts - base_counts\n                top_residual_indices = np.argsort(residuals)[-remainder_count:]\n                histograms[i, top_residual_indices] += 1\n        \n        return histograms, biases, np.array(samples_per_window, dtype=float)\n\n    def _run_wham(self, histograms, biases, M_i_vec, tol=1e-12, max_iter=10000):\n        \"\"\"\n        Solves the WHAM equations iteratively.\n        \"\"\"\n        num_windows = histograms.shape[0]\n        \n        # Initialize free energies\n        f = np.zeros(num_windows)\n        \n        N_j = np.sum(histograms, axis=0) # Total counts per bin\n\n        for iteration in range(max_iter):\n            f_old = np.copy(f)\n            \n            # Equation 1: Calculate P(q_j)\n            denominator = np.zeros(self.num_bins)\n            for k in range(num_windows):\n                denominator += M_i_vec[k] * np.exp(self.beta * (f[k] - biases[k, :]))\n            \n            P = np.zeros_like(denominator)\n            # Avoid division by zero where denominator might be zero (although unlikely)\n            # If N_j is zero, P_j is zero.\n            non_zero_N_j = N_j > 0\n            safe_denominator = np.where(denominator > 0, denominator, 1.0)\n            P[non_zero_N_j] = N_j[non_zero_N_j] / safe_denominator[non_zero_N_j]\n\n            # Normalize P\n            P /= np.sum(P)\n            \n            # Equation 2: Update f_i\n            f_new = np.zeros_like(f)\n            # Add a small epsilon to P to avoid log(0)\n            P_log_safe = P + 1e-300\n            for i in range(num_windows):\n                sum_term = np.sum(P_log_safe * np.exp(-self.beta * biases[i, :]))\n                f_new[i] = - (1.0 / self.beta) * np.log(sum_term)\n\n            # Shift f to set f_1 = 0\n            f = f_new - f_new[0]\n\n            # Check for convergence\n            if np.max(np.abs(f - f_old))  tol:\n                break\n        \n        return P\n\n    def _analyze_pmf(self, P, basin_intervals):\n        \"\"\"\n        Calculates the PMF and extracts the required metrics.\n        \"\"\"\n        # Calculate PMF W(q)\n        P_safe = np.maximum(P, 1e-300) # Prevent log(0)\n        W = - (1.0 / self.beta) * np.log(P_safe)\n        \n        # Normalize PMF so min(W) = 0\n        W -= np.min(W)\n\n        # Identify basin indices\n        basin_closed_indices = np.where(\n            (self.q >= basin_intervals['closed'][0])  (self.q = basin_intervals['closed'][1])\n        )[0]\n        basin_open_indices = np.where(\n            (self.q >= basin_intervals['open'][0])  (self.q = basin_intervals['open'][1])\n        )[0]\n\n        # Find minima in basins\n        idx_closed_min_local = np.argmin(W[basin_closed_indices])\n        idx_closed_min = basin_closed_indices[idx_closed_min_local]\n        w_closed_star = W[idx_closed_min]\n\n        idx_open_min_local = np.argmin(W[basin_open_indices])\n        idx_open_min = basin_open_indices[idx_open_min_local]\n        w_open_star = W[idx_open_min]\n        \n        # Find barrier between minima\n        start_idx = min(idx_closed_min, idx_open_min) + 1\n        end_idx = max(idx_closed_min, idx_open_min)\n        \n        if start_idx >= end_idx: # No points between minima\n            w_ddagger = max(w_closed_star, w_open_star)\n        else:\n            idx_barrier_local = np.argmax(W[start_idx:end_idx])\n            idx_barrier = start_idx + idx_barrier_local\n            w_ddagger = W[idx_barrier]\n\n        # Calculate metrics\n        barrier_height = w_ddagger - min(w_closed_star, w_open_star)\n        free_energy_diff = w_open_star - w_closed_star\n        \n        return [barrier_height, free_energy_diff]\n\n    def run(self):\n        \"\"\"\n        Executes the full analysis pipeline for the test case.\n        \"\"\"\n        histograms, biases, M_i_vec = self._generate_synthetic_data()\n        P = self._run_wham(histograms, biases, M_i_vec)\n        results = self._analyze_pmf(P, self.params['basin_intervals'])\n        return results\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the analysis, and print results.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: separation coordinate, happy path\n        {\n            'grid': {'range': [0.24, 0.60], 'width': 0.002},\n            'unbiased_mixture': {'w1': 1.0, 'w2': 0.5, 'mu1': 0.30, 'sigma1': 0.015, 'mu2': 0.52, 'sigma2': 0.020},\n            'num_windows': 7,\n            'window_centers': [0.28, 0.32, 0.36, 0.42, 0.48, 0.52, 0.56],\n            'spring_constants': [1500] * 7,\n            'samples_per_window': [5000] * 7,\n            'basin_intervals': {'closed': [0.27, 0.36], 'open': [0.47, 0.57]}\n        },\n        # Test Case 2: angular coordinate, happy path\n        {\n            'grid': {'range': [0.00, 0.90], 'width': 0.01},\n            'unbiased_mixture': {'w1': 1.0, 'w2': 0.25, 'mu1': 0.00, 'sigma1': 0.12, 'mu2': 0.60, 'sigma2': 0.12},\n            'num_windows': 5,\n            'window_centers': [0.00, 0.20, 0.40, 0.60, 0.80],\n            'spring_constants': [60] * 5,\n            'samples_per_window': [5000] * 5,\n            'basin_intervals': {'closed': [0.00, 0.25], 'open': [0.50, 0.80]}\n        },\n        # Test Case 3: separation coordinate, poor overlap\n        {\n            'grid': {'range': [0.24, 0.60], 'width': 0.002},\n            'unbiased_mixture': {'w1': 1.0, 'w2': 0.5, 'mu1': 0.30, 'sigma1': 0.015, 'mu2': 0.52, 'sigma2': 0.020},\n            'num_windows': 3,\n            'window_centers': [0.30, 0.42, 0.54],\n            'spring_constants': [6000] * 3,\n            'samples_per_window': [2000] * 3,\n            'basin_intervals': {'closed': [0.27, 0.36], 'open': [0.47, 0.57]}\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        analyzer = WHAMAnalysis(params)\n        result = analyzer.run()\n        all_results.append(result)\n\n    # Format the results into the required string \"[[b_1,d_1],[b_2,d_2],[b_3,d_3]]\"\n    result_str = '[' + ','.join([f\"[{r[0]},{r[1]}]\" for r in all_results]) + ']'\n    print(result_str)\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}