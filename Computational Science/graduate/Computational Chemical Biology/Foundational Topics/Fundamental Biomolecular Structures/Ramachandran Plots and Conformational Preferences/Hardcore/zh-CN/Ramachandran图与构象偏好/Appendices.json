{
    "hands_on_practices": [
        {
            "introduction": "拉马钱德兰图中的“允许”区域并非任意划定，而是源于基本的物理原理。本实践将引导您从零开始构建一个简单的二肽模型，并使用硬球模型计算空间位阻允许的构象空间，从而揭示该图特征形状的物理起源 。这项练习有助于您从根本上理解原子层面的限制如何决定宏观的蛋白质结构。",
            "id": "3861074",
            "problem": "要求您实现一个物理上合理的硬球空间位阻过滤器，以估算在标准肽骨架模型中，丙氨酸的 $(\\phi,\\psi)$ 平面中空间位阻允许的区域所占的比例。您的程序必须使用固定的内坐标构建一个最小的类丙氨酸二肽片段，并对每个采样的骨架二面角对 $(\\phi,\\psi)$，判断其构象在硬球范德华（vdW）模型下是否因空间位阻而被允许。然后，您将在 $(\\phi,\\psi)$ 的均匀网格上估算允许的比例，并报告当所有半径统一按 $0.95$ 的因子缩放时，该比例如何变化。\n\n使用的基本和核心定义：\n- 骨架二面角由四个有序原子 $(\\mathbf{r}_0,\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3)$ 定义，等于平面 $(\\mathbf{r}_0,\\mathbf{r}_1,\\mathbf{r}_2)$ 与平面 $(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3)$ 之间的带符号夹角。符号约定源于沿化学键 $\\mathbf{r}_1\\mathbf{r}_2$ 的右手定则。该二面角通过向量和叉积计算：设 $\\mathbf{b}_1=\\mathbf{r}_1-\\mathbf{r}_0$，$\\mathbf{b}_2=\\mathbf{r}_2-\\mathbf{r}_1$，$\\mathbf{b}_3=\\mathbf{r}_3-\\mathbf{r}_2$，则平面法向量为 $\\mathbf{n}_1=\\mathbf{b}_1\\times\\mathbf{b}_2$ 和 $\\mathbf{n}_2=\\mathbf{b}_2\\times\\mathbf{b}_3$，带符号的角度 $\\omega$ 满足 $\\tan\\omega=\\dfrac{\\left(\\mathbf{n}_1\\times \\dfrac{\\mathbf{b}_2}{\\lVert \\mathbf{b}_2\\rVert}\\right)\\cdot \\mathbf{n}_2}{\\mathbf{n}_1\\cdot\\mathbf{n}_2}$。\n- 在硬球模型下，当两个非成键原子 $i$ 和 $j$ 之间的欧几里得距离 $d_{ij}$ 严格小于它们的vdW半径之和 $r_i+r_j$（或当半径按因子 $s$ 缩放时，小于 $s\\,(r_i+r_j)$）时，发生空间位阻冲突。距离以埃（Å）为单位测量。\n- 成键原子对和由两个化学键分隔的原子对（也称为 $1$–$3$ 对）不参与冲突检查。仅考虑由三个或更多化学键分隔的原子对的空间位阻排斥。\n- 任何点 $\\mathbf{x}$ 围绕通过点 $\\mathbf{p}$ 的轴线进行的刚性旋转，使用Rodrigues旋转公式实现，旋转轴为 $\\mathbf{u}$，旋转角为 $\\theta$：\n$$ \\mathbf{x}'=\\mathbf{p}+\\cos\\theta(\\mathbf{x}-\\mathbf{p})+\\sin\\theta\\,(\\mathbf{u}\\times(\\mathbf{x}-\\mathbf{p}))+(1-\\cos\\theta)\\,\\mathbf{u}\\,(\\mathbf{u}\\cdot(\\mathbf{x}-\\mathbf{p})) $$\n，其中 $\\mathbf{u}$ 是归一化的。\n\n要构建的几何结构（距离单位为埃，角度单位为度）：\n- 中心残基的骨架：将骨架原子 $\\mathrm{N}$、$\\mathrm{C_\\alpha}$ 和 $\\mathrm{C}$ 放置在肽平面内，具有固定的键长和键角：$\\lVert \\mathrm{N}-\\mathrm{C_\\alpha}\\rVert=1.458$，$\\lVert \\mathrm{C_\\alpha}-\\mathrm{C}\\rVert=1.525$，以及角度 $\\angle \\mathrm{N}\\!-\\!\\mathrm{C_\\alpha}\\!-\\!\\mathrm{C}=110.1$。初始肽平面为 $x$–$y$ 平面，$\\mathrm{N}$ 位于原点，$\\mathrm{C_\\alpha}$ 位于 $x$ 轴上。\n- 中心残基的羰基氧：$\\mathrm{O}$ 与 $\\mathrm{C}$ 成键，$\\lVert \\mathrm{C}-\\mathrm{O}\\rVert=1.229$，呈平面几何构型，角度为 $\\angle \\mathrm{C_\\alpha}\\!-\\!\\mathrm{C}\\!-\\!\\mathrm{O}=120.0$。\n- 前一个残基的羰基：$\\mathrm{C_{-1}}$ 与 $\\mathrm{N}$ 成键，$\\lVert \\mathrm{N}-\\mathrm{C_{-1}}\\rVert=1.330$，角度为 $\\angle \\mathrm{C_\\alpha}\\!-\\!\\mathrm{N}\\!-\\!\\mathrm{C_{-1}}=121.7$；将 $\\mathrm{O_{-1}}$ 与 $\\mathrm{C_{-1}}$ 成键，$\\lVert \\mathrm{C_{-1}}-\\mathrm{O_{-1}}\\rVert=1.229$，角度为 $\\angle \\mathrm{N}\\!-\\!\\mathrm{C_{-1}}\\!-\\!\\mathrm{O_{-1}}=120.0$，所有原子均在同一肽平面内（反式肽键）。\n- 下一个残基的酰胺氮：$\\mathrm{N_{+1}}$ 与 $\\mathrm{C}$ 成键，$\\lVert \\mathrm{C}-\\mathrm{N_{+1}}\\rVert=1.330$，角度为 $\\angle \\mathrm{C_\\alpha}\\!-\\!\\mathrm{C}\\!-\\!\\mathrm{N_{+1}}=116.2$，位于肽平面内（反式）。\n- 丙氨酸侧链：一个联合原子甲基 $\\mathrm{C_\\beta}$ 与 $\\mathrm{C_\\alpha}$ 成键，$\\lVert \\mathrm{C_\\alpha}-\\mathrm{C_\\beta}\\rVert=1.530$。为反映四面体偏好，初始时将 $\\mathrm{C_\\beta}$ 沿肽平面法线方向放置，即垂直于骨架平面。\n\n骨架二面角控制：\n- 中心残基的Ramachandran二面角定义为 $\\phi=\\angle(\\mathrm{C_{-1}},\\mathrm{N},\\mathrm{C_\\alpha},\\mathrm{C})$ 和 $\\psi=\\angle(\\mathrm{N},\\mathrm{C_\\alpha},\\mathrm{C},\\mathrm{N_{+1}})$，单位均为度。为设定目标 $(\\phi,\\psi)$，将上游基团 $\\{\\mathrm{C_{-1}},\\mathrm{O_{-1}}\\}$ 作为一个刚体，围绕键轴 $\\mathrm{N}$–$\\mathrm{C_\\alpha}$ 旋转以达到目标 $\\phi$ 所需的增量；并将下游基团 $\\{\\mathrm{O},\\mathrm{N_{+1}}\\}$ 作为一个刚体，围绕键轴 $\\mathrm{C_\\alpha}$–$\\mathrm{C}$ 旋转以达到目标 $\\psi$ 所需的增量。\n\n空间位阻模型半径（Bondi半径）：\n- $\\mathrm{N}$: $1.55$, $\\mathrm{C}$: $1.70$, $\\mathrm{O}$: $1.52$, 联合甲基 $\\mathrm{C_\\beta}$: $2.00$。当指定时，将所有半径乘以缩放因子 $s$。\n\n连接性排除：\n- 从冲突检查中排除任何直接成键或由两个键分隔的原子对。连接边为：$\\mathrm{N}$–$\\mathrm{C_\\alpha}$、$\\mathrm{C_\\alpha}$–$\\mathrm{C}$、$\\mathrm{C}$–$\\mathrm{O}$、$\\mathrm{N}$–$\\mathrm{C_{-1}}$、$\\mathrm{C_{-1}}$–$\\mathrm{O_{-1}}$、$\\mathrm{C}$–$\\mathrm{N_{+1}}$ 和 $\\mathrm{C_\\alpha}$–$\\mathrm{C_\\beta}$。\n\n网格和单位：\n- 在覆盖 $[-180,180]$（含边界）的均匀网格上采样 $(\\phi,\\psi)$，单位为度。距离单位为埃。角度单位必须为度。\n\n允许比例估算：\n- 允许比例的计算方法是：其构象在非成键原子对之间没有空间位阻冲突的网格点数，除以总网格点数。\n\n测试套件：\n- 每个测试用例是一个对 $(\\Delta, s)$，其中 $\\Delta$ 是网格步长（单位为度），$s$ 是vdW缩放因子。使用以下测试用例：$(60,1.0)$、$(60,0.95)$、$(20,1.0)$、$(20,0.95)$、$(10,1.0)$、$(10,0.95)$。\n- 对每个测试用例，输出允许的比例，结果为浮点数，保留六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[f1,f2,f3,f4,f5,f6]”）。每个 $f_k$ 对应于上述顺序中第 $k$ 个测试用例的允许比例。",
            "solution": "用户要求编写一个程序，用于计算一个类丙氨酸二肽片段的Ramachandran $(\\phi,\\psi)$ 构象空间中，空间位阻上允许的区域所占的比例。该问题属于计算化学生物学领域，需要基于几何构建实现一个硬球空间位阻冲突模型。\n\n### 问题验证\n\n首先，我将严格验证问题陈述。\n\n#### 第1步：提取给定信息\n\n- **模型**：一个带有联合原子甲基（$\\mathrm{C_\\beta}$）在 $\\mathrm{C_\\alpha}$ 上的丙氨酸二肽片段。使用硬球模型评估空间位阻相互作用。\n- **原子**：该模型包含八个原子中心：中心残基的 $\\mathrm{N, C_\\alpha, C, O}$，前一个残基的 $\\mathrm{C_{-1}, O_{-1}}$，后一个残基的 $\\mathrm{N_{+1}}$，以及丙氨酸侧链的 $\\mathrm{C_\\beta}$。\n- **几何参数（距离单位Å，角度单位度）**：\n    - 键长：$\\lVert \\mathrm{N}-\\mathrm{C_\\alpha}\\rVert=1.458$, $\\lVert \\mathrm{C_\\alpha}-\\mathrm{C}\\rVert=1.525$, $\\lVert \\mathrm{C}-\\mathrm{O}\\rVert=1.229$, $\\lVert \\mathrm{N}-\\mathrm{C_{-1}}\\rVert=1.330$, $\\lVert \\mathrm{C_{-1}}-\\mathrm{O_{-1}}\\rVert=1.229$, $\\lVert \\mathrm{C}-\\mathrm{N_{+1}}\\rVert=1.330$, $\\lVert \\mathrm{C_\\alpha}-\\mathrm{C_\\beta}\\rVert=1.530$。\n    - 键角：$\\angle \\mathrm{N}\\!-\\!\\mathrm{C_\\alpha}\\!-\\!\\mathrm{C}=110.1^\\circ$, $\\angle \\mathrm{C_\\alpha}\\!-\\!\\mathrm{C}\\!-\\!\\mathrm{O}=120.0^\\circ$, $\\angle \\mathrm{C_\\alpha}\\!-\\!\\mathrm{N}\\!-\\!\\mathrm{C_{-1}}=121.7^\\circ$, $\\angle \\mathrm{N}\\!-\\!\\mathrm{C_{-1}}\\!-\\!\\mathrm{O_{-1}}=120.0^\\circ$, $\\angle \\mathrm{C_\\alpha}\\!-\\!\\mathrm{C}\\!-\\!\\mathrm{N_{+1}}=116.2^\\circ$。\n- **参考几何结构构建**：\n    - 初始肽平面为 $x$–$y$ 平面。\n    - $\\mathrm{N}$ 位于原点 $(0,0,0)$。$\\mathrm{C_\\alpha}$ 位于 $x$ 轴上。\n    - 骨架 $\\mathrm{N}-\\mathrm{C_\\alpha}-\\mathrm{C}$ 位于 $x$–$y$ 平面内。\n    - 前一个基团 $(\\mathrm{C_{-1}}, \\mathrm{O_{-1}})$ 和后一个原子 $(\\mathrm{N_{+1}})$ 也被放置在该平面内，并提到了“反式”肽键特性。\n    - $\\mathrm{C_\\beta}$ 初始时沿肽平面法线方向放置。\n- **二面角和旋转**：\n    - $\\phi = \\angle(\\mathrm{C_{-1}}, \\mathrm{N}, \\mathrm{C_\\alpha}, \\mathrm{C})$, $\\psi = \\angle(\\mathrm{N}, \\mathrm{C_\\alpha}, \\mathrm{C}, \\mathrm{N_{+1}})$。\n    - 目标 $(\\phi,\\psi)$ 值通过旋转刚性基团实现：$\\{\\mathrm{C_{-1}}, \\mathrm{O_{-1}}\\}$ 围绕 $\\mathrm{N}-\\mathrm{C_\\alpha}$ 轴旋转以实现 $\\phi$；$\\{\\mathrm{O}, \\mathrm{N_{+1}}\\}$ 围绕 $\\mathrm{C_\\alpha}-\\mathrm{C}$ 轴旋转以实现 $\\psi$。\n    - 旋转使用提供的Rodrigues公式执行。\n- **空间位阻冲突模型**：\n    - 如果两个非成键原子 $i, j$ 之间的距离 $d_{ij}$ 小于 $s(r_i+r_j)$，则发生冲突，其中 $r_i, r_j$ 是vdW半径，$s$ 是缩放因子。\n    - 排除：成键（1–2对）或由两个键分隔（1–3对）的原子对不进行冲突检查。\n- **范德华半径（单位Å）**：$\\mathrm{N}: 1.55$, $\\mathrm{C}: 1.70$, $\\mathrm{O}: 1.52$, 联合甲基 $\\mathrm{C_\\beta}: 2.00$。其他原子根据其元素类型分配半径（$\\mathrm{C_\\alpha, C, C_{-1}}$ 是碳；$\\mathrm{N_{+1}}$ 是氮；$\\mathrm{O_{-1}}$ 是氧）。\n- **计算任务**：\n    - 在 $[-180, 180]$（含边界）的均匀网格上采样 $(\\phi,\\psi)$。\n    - 计算允许比例：（无冲突构象的数量）/（总网格点数）。\n- **测试用例**：六对 $(\\Delta, s)$，其中 $\\Delta$ 是网格步长（单位度），$s$ 是半径缩放因子：$(60,1.0), (60,0.95), (20,1.0), (20,0.95), (10,1.0), (10,0.95)$。\n- **输出**：包含六个浮点数的单行列表，保留六位小数，格式为 `[f1,f2,f3,f4,f5,f6]`。\n\n#### 第2步：使用提取的给定信息进行验证\n该问题具有科学依据、定义明确且客观。它是计算生物物理学中的一个标准简化练习。几何参数、物理模型（硬球）和数学定义（二面角、Rodrigues旋转）都是标准且正确的。几何构建的指令足够详细，可以创建一个明确定义的初始分子结构。虽然在其他明确的平面构建规则的背景下，“反式肽键”这一短语可能会引入轻微的歧义，但将明确的规则作为首要依据，可以得出一个一致且可形式化的过程。问题是自洽的，没有科学缺陷、矛盾或不可行的要求。\n\n#### 第3步：结论与行动\n问题是**有效的**。将根据经过验证的规范来构建解决方案。\n\n### 解决方案设计\n\n解决方案将遵循从问题陈述中推导出的清晰、分步的程序来实现。\n\n1.  **参考几何结构构建**：首先，我们根据提供的几何参数构建丙氨酸二肽片段的参考构象。除 $\\mathrm{C_\\beta}$ 原子外，所有原子最初都放置在 $x,y$ 平面内。\n    - 将 $\\mathrm{N}$ 置于原点 $\\mathbf{r}_N = (0, 0, 0)$。\n    - 将 $\\mathrm{C_\\alpha}$ 置于正 $x$ 轴上，位置为 $\\mathbf{r}_{C\\alpha} = (1.458, 0, 0)$。\n    - 将 $\\mathrm{C}$ 放置在 $x,y$ 平面内，以满足 $\\lVert \\mathbf{r}_C - \\mathbf{r}_{C\\alpha} \\rVert = 1.525$ 和 $\\angle \\mathrm{N-C_\\alpha-C} = 110.1^\\circ$。我们选择 $y$ 坐标为正的解。\n    - 其他原子（$\\mathrm{C_{-1}}, \\mathrm{O_{-1}}, \\mathrm{O}, \\mathrm{N_{+1}}$）根据它们的键长和键角，相对于核心骨架原子放置在 $x,y$ 平面内。构建旨在创建一个初始二面角 $\\phi_0$ 和 $\\psi_0$ 均为 $0^\\circ$（顺-顺式构象）的参考状态。这是一个明确定义的起点。\n    - 将 $\\mathrm{C_\\beta}$ 垂直于该平面放置，位置为 $\\mathbf{r}_{C\\beta} = \\mathbf{r}_{C\\alpha} + (0, 0, 1.530)$。\n\n2.  **二面角旋转**：为生成任意构象 $(\\phi, \\psi)$，我们从参考几何结构开始，并按规定执行刚体旋转。\n    - **$\\phi$ 旋转**：原子团 $\\{\\mathrm{C_{-1}}, \\mathrm{O_{-1}}\\}$ 围绕由向量 $\\mathbf{r}_{C\\alpha} - \\mathbf{r}_{N}$ 定义、通过点 $\\mathbf{r}_{N}$ 的轴旋转角度 $\\phi$。\n    - **$\\psi$ 旋转**：原子团 $\\{\\mathrm{O}, \\mathrm{N_{+1}}\\}$ 围绕由向量 $\\mathbf{r}_{C} - \\mathbf{r}_{C\\alpha}$ 定义、通过点 $\\mathbf{r}_{C\\alpha}$ 的轴旋转角度 $\\psi$。\n    - 旋转使用提供的Rodrigues旋转公式实现。所有角度在使用三角函数前必须从度转换为弧度。\n\n3.  **空间位阻冲突检测**：对于每个生成的构象，我们检查是否存在空间位阻冲突。\n    - **排除列表**：我们首先确定所有免于冲突检测的原子对。这些是1–2对（共价键合）和1–3对（由两个键分隔）。这可以通过在分子连接图中找到图距离为1或2的所有原子对来确定。\n    - **冲突检查**：对于所有其他原子对 $(i, j)$，我们计算欧几里得距离 $d_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$。如果 $d_{ij}  s(r_i + r_j)$，则发生冲突，其中 $r_i$ 和 $r_j$ 是各自的范德华半径，$s$ 是给定的缩放因子。\n\n4.  **网格采样与比例计算**：构象空间在 $(\\phi, \\psi)$ 值从 $-180^\\circ$ 到 $180^\\circ$（含边界）的均匀网格上采样，步长为 $\\Delta$。\n    - 对于每个测试用例 $(\\Delta, s)$，我们遍历所有网格点。\n    - 我们计算其对应构象没有任何空间位阻冲突的网格点数 $N_{allowed}$。\n    - 总网格点数为 $N_{total} = (360/\\Delta + 1)^2$。\n    - 允许比例计算为 $f = N_{allowed} / N_{total}$。\n\n5.  **实现**：该算法将使用Python中的`numpy`库实现，以进行高效的向量和矩阵运算。最终的程序结构将包含所有这些步骤，以处理指定的测试用例并按要求格式生成输出。",
            "answer": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n# No further imports, including scipy, are necessary for this problem.\n\ndef rodrigues_rotation(points, p_axis, axis_vec, angle_rad):\n    \"\"\"\n    Rotates a set of points around an axis using Rodrigues' formula.\n    \n    Args:\n        points (np.ndarray): Array of points to rotate (Nx3).\n        p_axis (np.ndarray): A point on the axis of rotation (3,).\n        axis_vec (np.ndarray): Direction vector of the axis of rotation (3,).\n        angle_rad (float): The angle of rotation in radians.\n    \n    Returns:\n        np.ndarray: The array of rotated points (Nx3).\n    \"\"\"\n    # Ensure axis vector is normalized\n    axis_vec = axis_vec / np.linalg.norm(axis_vec)\n    \n    # Use broadcasting for vector operations\n    v = points - p_axis\n    \n    cos_theta = np.cos(angle_rad)\n    sin_theta = np.sin(angle_rad)\n    \n    # Rodrigues' formula components\n    term1 = v * cos_theta\n    term2 = np.cross(axis_vec, v) * sin_theta\n    \n    # Handle dot product for multiple points in v\n    v_dot_axis = np.dot(v, axis_vec)\n    term3 = np.outer(v_dot_axis, axis_vec) * (1 - cos_theta)\n    \n    v_rot = term1 + term2 + term3\n    \n    return p_axis + v_rot\n\ndef build_reference_geometry():\n    \"\"\"\n    Constructs coordinates of the alanine fragment in a reference planar conformation\n    corresponding to phi=0, psi=0 degrees.\n    \"\"\"\n    rad = np.deg2rad\n    \n    # Geometric parameters\n    L_NCa, L_CaC, L_CO, L_NCm1, L_Cm1Om1, L_CNp1, L_CaCb = 1.458, 1.525, 1.229, 1.330, 1.229, 1.330, 1.530\n    A_NCaC, A_CaCO, A_CaNCm1, A_NCm1Om1, A_CaCNp1 = rad(110.1), rad(120.0), rad(121.7), rad(120.0), rad(116.2)\n\n    coords = {}\n    \n    # Central backbone N-Ca-C in xy-plane\n    coords['N'] = np.array([0., 0., 0.])\n    coords['Ca'] = np.array([L_NCa, 0., 0.])\n    \n    # Place C in xy-plane with y>0\n    coords['C'] = np.array([\n        L_NCa + L_CaC * np.cos(np.pi - A_NCaC),\n        L_CaC * np.sin(np.pi - A_NCaC),\n        0.\n    ])\n\n    # Place upstream group {Cm1, Om1} for phi=0\n    coords['Cm1'] = np.array([\n        L_NCm1 * np.cos(A_CaNCm1),\n        L_NCm1 * np.sin(A_CaNCm1),\n        0.\n    ])\n    v_Cm1N = coords['N'] - coords['Cm1']\n    angle_Cm1N = np.arctan2(v_Cm1N[1], v_Cm1N[0])\n    angle_Cm1Om1 = angle_Cm1N - A_NCm1Om1\n    coords['Om1'] = coords['Cm1'] + np.array([\n        L_Cm1Om1 * np.cos(angle_Cm1Om1),\n        L_Cm1Om1 * np.sin(angle_Cm1Om1),\n        0.\n    ])\n    \n    # Place downstream group {O, Np1} for psi=0\n    v_CCa = coords['Ca'] - coords['C']\n    angle_CCa = np.arctan2(v_CCa[1], v_CCa[0])\n    \n    angle_CNp1 = angle_CCa + A_CaCNp1\n    coords['Np1'] = coords['C'] + np.array([\n        L_CNp1 * np.cos(angle_CNp1),\n        L_CNp1 * np.sin(angle_CNp1),\n        0.\n    ])\n    \n    angle_CO = angle_CCa - A_CaCO\n    coords['O'] = coords['C'] + np.array([\n        L_CO * np.cos(angle_CO),\n        L_CO * np.sin(angle_CO),\n        0.\n    ])\n    \n    # Place sidechain Cb perpendicular to plane\n    coords['Cb'] = coords['Ca'] + np.array([0., 0., L_CaCb])\n\n    return coords\n    \ndef get_nonbonded_pairs_to_check(atom_names):\n    \"\"\"\n    Determines atom pairs to be checked for steric clashes by excluding 1-2 and 1-3 pairs.\n    \"\"\"\n    connectivity = {\n        'N': ['Ca', 'Cm1'], 'Ca': ['N', 'C', 'Cb'], 'C': ['Ca', 'O', 'Np1'],\n        'O': ['C'], 'Cm1': ['N', 'Om1'], 'Om1': ['Cm1'], 'Np1': ['C'], 'Cb': ['Ca']\n    }\n    \n    name_to_idx = {name: i for i, name in enumerate(atom_names)}\n    idx_to_name = {i: name for i, name in enumerate(atom_names)}\n    \n    adj = defaultdict(list)\n    for u, neighbors in connectivity.items():\n        for v in neighbors:\n            adj[name_to_idx[u]].append(name_to_idx[v])\n\n    num_atoms = len(atom_names)\n    pairs_to_check = []\n    for i in range(num_atoms):\n        for j in range(i + 1, num_atoms):\n            # Check for path of length 1 or 2\n            # dist 1\n            if j in adj[i]:\n                continue\n            # dist 2\n            is_dist_2 = False\n            for neighbor in adj[i]:\n                if j in adj[neighbor]:\n                    is_dist_2 = True\n                    break\n            if is_dist_2:\n                continue\n            \n            pairs_to_check.append((i, j))\n            \n    return pairs_to_check\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        (60, 1.0), (60, 0.95), (20, 1.0), (20, 0.95), (10, 1.0), (10, 0.95)\n    ]\n    \n    atom_names = ['N', 'Ca', 'C', 'O', 'Cm1', 'Om1', 'Np1', 'Cb']\n    radii_map = {'N': 1.55, 'Ca': 1.70, 'C': 1.70, 'O': 1.52, 'Cm1': 1.70, 'Om1': 1.52, 'Np1': 1.55, 'Cb': 2.00}\n    radii = np.array([radii_map[name] for name in atom_names])\n\n    ref_coords_dict = build_reference_geometry()\n    ref_coords = np.array([ref_coords_dict[name] for name in atom_names])\n    \n    pairs_to_check = get_nonbonded_pairs_to_check(atom_names)\n\n    results = []\n    \n    for grid_step, scale_factor in test_cases:\n        angle_range = np.arange(-180, 180 + grid_step, grid_step)\n        \n        allowed_count = 0\n        total_points = len(angle_range)**2\n\n        # Pre-calculate clash thresholds\n        radii_sums = np.zeros((len(atom_names), len(atom_names)))\n        for i, j in pairs_to_check:\n            radii_sums[i, j] = scale_factor * (radii[i] + radii[j])\n        \n        for phi in angle_range:\n            for psi in angle_range:\n                current_coords = ref_coords.copy()\n                \n                # Apply phi rotation to {Cm1, Om1}\n                phi_rad = np.deg2rad(phi)\n                axis_phi = ref_coords[1] - ref_coords[0] # Ca - N\n                p_axis_phi = ref_coords[0] # N\n                indices_phi = [4, 5] # Cm1, Om1\n                current_coords[indices_phi] = rodrigues_rotation(current_coords[indices_phi], p_axis_phi, axis_phi, phi_rad)\n                \n                # Apply psi rotation to {O, Np1}\n                psi_rad = np.deg2rad(psi)\n                axis_psi = ref_coords[2] - ref_coords[1] # C - Ca\n                p_axis_psi = ref_coords[1] # Ca\n                indices_psi = [3, 6] # O, Np1\n                current_coords[indices_psi] = rodrigues_rotation(current_coords[indices_psi], p_axis_psi, axis_psi, psi_rad)\n                \n                # Check for steric clashes\n                has_clash = False\n                for i, j in pairs_to_check:\n                    dist_sq = np.sum((current_coords[i] - current_coords[j])**2)\n                    clash_dist_sq = radii_sums[i, j]**2\n                    if dist_sq  clash_dist_sq:\n                        has_clash = True\n                        break\n                \n                if not has_clash:\n                    allowed_count += 1\n        \n        fraction = allowed_count / total_points\n        results.append(round(fraction, 6))\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然通用的拉马钱德兰图功能强大，但某些氨基酸（如甘氨酸和脯氨酸）因其独特的侧链结构而具有独特的构象特征。本练习涉及分析经验数据，为甘氨酸和脯氨酸构建独立的概率分布，然后使用 Kullback-Leibler 散度来定量衡量它们的构象景观彼此之间以及与混合群体的差异 。这项实践旨在培养统计数据分析的技能，并加深对氨基酸特异性构象偏好的理解。",
            "id": "3861112",
            "problem": "您需要实现一个程序，通过计算主链二面角的独立分箱概率分布，并利用Kullback–Leibler散度量化允许区域的偏移，来形式化分析包含甘氨酸和脯氨酸的拉马钱德兰图。计算基础必须从计算化学生物学和统计推断的基本定义出发。请使用以下定义作为基础：拉马钱德兰图将氨基酸主链扭转角 $\\phi$ 和 $\\psi$ 映射到一个二维角度空间；由于侧链约束，甘氨酸和脯氨酸具有独特的构象偏好；通过对角度观测值进行分箱来估计角度空间上的概率分布；Kullback–Leibler散度量化了用一个分布去近似另一个分布时的信息损失。所有角度必须以度为单位处理和报告；所有对数必须是自然对数；所有概率必须是无量纲的。\n\n您的任务是：\n- 使用一个方形箱宽为 $w$ 度的二维直方图，在定义域 $\\phi \\in [-180,180)$ 和 $\\psi \\in [-180,180)$ 上，为甘氨酸和脯氨酸的 $\\phi$ 和 $\\psi$ 角构建独立的经验分布。归一化每个直方图，以获得一个离散的箱概率分布。\n- 在归一化之前，通过向每个箱的计数中添加一个常数 $\\alpha  0$ 来应用狄利克雷（加性）平滑，以避免零概率箱的出现。\n- 将每种氨基酸的允许区域定义为概率至少为阈值 $\\tau$ 的箱的集合。设 $\\mathcal{R}_{\\mathrm{gly}}$ 为甘氨酸的允许区域，$\\mathcal{R}_{\\mathrm{pro}}$ 为脯氨酸的允许区域。设 $\\mathcal{U} = \\mathcal{R}_{\\mathrm{gly}} \\cup \\mathcal{R}_{\\mathrm{pro}}$ 为它们的并集。如果在给定的测试用例中 $\\mathcal{U}$ 为空，则将允许区域视为整个网格。\n- 通过汇集（即拼接）甘氨酸和脯氨酸的观测数据，应用相同的分箱和平滑处理，并进行归一化，构建一个组合的“混合”分布 $P_{\\mathrm{mix}}$。\n- 使用Kullback–Leibler散度量化允许区域的偏移。对于在同一网格上定义的任意两个分布 $P$ 和 $Q$，使用并集掩码 $\\mathcal{U}$，定义受限和重归一化的分布：\n  $$P_{\\mathcal{U}}(i) = \\frac{P(i) \\cdot \\mathbf{1}_{\\mathcal{U}}(i)}{\\sum_j P(j) \\cdot \\mathbf{1}_{\\mathcal{U}}(j)}, \\quad Q_{\\mathcal{U}}(i) = \\frac{Q(i) \\cdot \\mathbf{1}_{\\mathcal{U}}(i)}{\\sum_j Q(j) \\cdot \\mathbf{1}_{\\mathcal{U}}(j)}.$$\n  然后计算\n  $$D_{\\mathrm{KL}}(P_{\\mathcal{U}} \\,\\|\\, Q_{\\mathcal{U}}) = \\sum_{i \\in \\mathcal{U}} P_{\\mathcal{U}}(i) \\, \\ln \\left( \\frac{P_{\\mathcal{U}}(i)}{Q_{\\mathcal{U}}(i)} \\right)。$$\n  使用此方法为每个测试用例计算三个量：\n  1. $D_{\\mathrm{KL}}(P_{\\mathrm{gly},\\mathcal{U}} \\,\\|\\, P_{\\mathrm{mix},\\mathcal{U}})$，\n  2. $D_{\\mathrm{KL}}(P_{\\mathrm{pro},\\mathcal{U}} \\,\\|\\, P_{\\mathrm{mix},\\mathcal{U}})$，\n  3. $D_{\\mathrm{KL}}(P_{\\mathrm{gly},\\mathcal{U}} \\,\\|\\, P_{\\mathrm{pro},\\mathcal{U}})$。\n- 所有角度单位均为度。将最终的散度表示为浮点数，四舍五入到 $6$ 位小数。\n\n使用以下 $\\phi$ 和 $\\psi$ 角（单位为度）的数据集。每个有序对为 $(\\phi,\\psi)$，所有角度必须在 $[-180,180)$ 范围内处理，必要时使用模环绕：\n- 甘氨酸数据集 $\\mathcal{D}_{\\mathrm{gly}}$:\n  $$\n  \\{(80,20),(85,15),(90,10),(75,25),(95,5),(100,0),(70,30),(85,5),(-60,-40),(-65,-35),(-55,-45),(-70,-30),(-50,-50),(-120,130),(-125,135),(-115,125),(-130,140),(-110,120)\\}.\n  $$\n- 脯氨酸数据集 $\\mathcal{D}_{\\mathrm{pro}}$:\n  $$\n  \\{(-65,140),(-60,145),(-70,135),(-55,150),(-75,130),(-60,-35),(-65,-30),(-55,-25),(-70,-40),(-50,-20),(-120,130),(-115,125)\\}.\n  $$\n\n设计一个箱宽为 $w$ 度的离散网格，使得每轴的箱数为 $N = \\frac{360}{w}$，一个整数。箱应划分定义域 $\\phi \\in [-180,180)$ 和 $\\psi \\in [-180,180)$，区间为左闭右开。\n\n实现以下参数集 $(w,\\alpha,\\tau)$ 的测试套件：\n- 测试用例 1: $w=30$, $\\alpha=10^{-3}$, $\\tau=10^{-2}$。\n- 测试用例 2: $w=90$, $\\alpha=10^{-6}$, $\\tau=3 \\times 10^{-2}$。\n- 测试用例 3: $w=15$, $\\alpha=10^{-2}$, $\\tau=5 \\times 10^{-3}$。\n\n对于每个测试用例，计算上面列出的三个散度。您的程序应生成一行输出，其中包含所有 $9$ 个结果（每个测试用例三个，按测试用例 $1$、$2$ 和 $3$ 的顺序列出），形式为一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,\\dots,r_9]$），每个 $r_k$ 四舍五入到 $6$ 位小数。所有输出都是无量纲的浮点数。",
            "solution": "用户提供的问题是在化学生物学和统计分析领域内一个定义明确的计算任务。它要求实现一个流程，以量化甘氨酸和脯氨酸氨基酸构象偏好之间的差异，这些偏好由它们在拉马钱德兰图上的 $(\\phi, \\psi)$ 主链二面角表示。该问题被验证为合理、自洽且算法上是明确的。\n\n对于每个给定的测试用例 $(w, \\alpha, \\tau)$，解决方案按以下步骤进行：\n\n1.  **数据准备**：解析提供的甘氨酸 ($\\mathcal{D}_{\\mathrm{gly}}$) 和脯氨酸 ($\\mathcal{D}_{\\mathrm{pro}}$) 数据集。通过拼接前两个数据集创建一个第三个组合数据集 ($\\mathcal{D}_{\\mathrm{mix}}$)。所有角度均以度为单位，范围在 $[-180, 180)$ 内。\n\n2.  **网格离散化**：将连续的二维角度空间 $(\\phi, \\psi) \\in [-180, 180) \\times [-180, 180)$ 离散化为一个方形箱的网格。箱宽 $w$ 决定了每轴的箱数 $N = \\frac{360}{w}$。箱以左闭右开的区间划分定义域，这是 `numpy.histogram2d` 处理的标准约定。\n\n3.  **经验分布估计**：对于每个数据集 ($\\mathcal{D}_{\\mathrm{gly}}, \\mathcal{D}_{\\mathrm{pro}}, \\mathcal{D}_{\\mathrm{mix}}$)，计算一个二维直方图，以统计落入网格中每个箱的数据点数量。这会产生一个原始计数矩阵。\n\n4.  **狄利克雷平滑**：为防止因零概率而导致Kullback-Leibler散度未定义的问题，应用加性（狄利克雷）平滑。将一个小的正常数 $\\alpha$ 添加到每个箱的计数中。这确保了最终概率分布中的每个箱都具有非零概率。箱 $i$ 的平滑计数为 $C'_i = C_i + \\alpha$，其中 $C_i$ 是原始计数。\n\n5.  **归一化**：将平滑后的计数矩阵归一化，使其成为离散概率分布 ($P_{\\mathrm{gly}}$, $P_{\\mathrm{pro}}$, $P_{\\mathrm{mix}}$)。这是通过将每个平滑后的箱计数除以整个网格上所有平滑计数的总和来实现的。对于一个分布 $P$，箱 $i$ 的概率是 $P(i) = \\frac{C'_i}{\\sum_j C'_j}$。\n\n6.  **允许区域识别**：甘氨酸和脯氨酸的“允许”构象空间被定义为概率达到或超过给定阈值 $\\tau$ 的箱的集合。这创建了两个布尔掩码 $\\mathcal{R}_{\\mathrm{gly}}$ 和 $\\mathcal{R}_{\\mathrm{pro}}$，其中如果对应的箱是允许的，则元素为 `True`。\n\n7.  **并集掩码构建**：通过对两个允许区域掩码进行元素级的逻辑或运算，构建一个并集掩码 $\\mathcal{U} = \\mathcal{R}_{\\mathrm{gly}} \\cup \\mathcal{R}_{\\mathrm{pro}}$。这个掩码 $\\mathcal{U}$ 代表了两种氨基酸显著填充的箱的组合集合。处理一个特殊情况：如果 $\\mathcal{U}$ 为空（即没有任何箱达到任一氨基酸的阈值 $\\tau$），则将 $\\mathcal{U}$ 重新定义为包含整个网格，以确保后续的重归一化步骤是良定义的。\n\n8.  **受限和重归一化分布**：根据问题的定义，对于任何一对要比较的分布 $P$ 和 $Q$，首先将它们限制在并集掩码 $\\mathcal{U}$ 内的箱。然后，将这组受限箱内的概率重新归一化，使其总和为 $1$。这样就创建了用于计算散度的分布 $P_{\\mathcal{U}}$ 和 $Q_{\\mathcal{U}}$。形式上，对于每个箱 $i$：\n    $$P_{\\mathcal{U}}(i) = \\frac{P(i) \\cdot \\mathbf{1}_{\\mathcal{U}}(i)}{\\sum_j P(j) \\cdot \\mathbf{1}_{\\mathcal{U}}(j)}$$\n    其中 $\\mathbf{1}_{\\mathcal{U}}(i)$ 是掩码 $\\mathcal{U}$ 的指示函数。\n\n9.  **Kullback-Leibler (KL) 散度计算**：计算KL散度以量化这两个重归一化分布之间的差异。使用的公式是：\n    $$D_{\\mathrm{KL}}(P_{\\mathcal{U}} \\,\\|\\, Q_{\\mathcal{U}}) = \\sum_{i \\in \\mathcal{U}} P_{\\mathcal{U}}(i) \\, \\ln \\left( \\frac{P_{\\mathcal{U}}(i)}{Q_{\\mathcal{U}}(i)} \\right)$$\n    由于平滑处理确保了所有概率都严格为正，对数总是良定义的。总和是在对应于掩码 $\\mathcal{U}$ 的重归一化概率向量的所有元素上计算的。重复此过程，为每个测试用例获得三个指定的散度值：$D_{\\mathrm{KL}}(P_{\\mathrm{gly},\\mathcal{U}} \\,\\|\\, P_{\\mathrm{mix},\\mathcal{U}})$、$D_{\\mathrm{KL}}(P_{\\mathrm{pro},\\mathcal{U}} \\,\\|\\, P_{\\mathrm{mix},\\mathcal{U}})$ 和 $D_{\\mathrm{KL}}(P_{\\mathrm{gly},\\mathcal{U}} \\,\\|\\, P_{\\mathrm{pro},\\mathcal{U}})$。\n\n10. **最终输出格式化**：收集所有测试用例计算出的散度值，四舍五入到六位小数，并按照问题规范格式化为单个用方括号括起来的逗号分隔字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Ramachandran plot-based KL divergences for Glycine and Proline.\n    \"\"\"\n\n    # --- Data Definitions ---\n    # Glycine dataset D_gly: (phi, psi) angles in degrees.\n    D_GLY = np.array([\n        (80, 20), (85, 15), (90, 10), (75, 25), (95, 5), (100, 0), (70, 30), (85, 5),\n        (-60, -40), (-65, -35), (-55, -45), (-70, -30), (-50, -50),\n        (-120, 130), (-125, 135), (-115, 125), (-130, 140), (-110, 120)\n    ], dtype=float)\n\n    # Proline dataset D_pro: (phi, psi) angles in degrees.\n    D_PRO = np.array([\n        (-65, 140), (-60, 145), (-70, 135), (-55, 150), (-75, 130),\n        (-60, -35), (-65, -30), (-55, -25), (-70, -40), (-50, -20),\n        (-120, 130), (-115, 125)\n    ], dtype=float)\n\n    # Combined dataset D_mix by pooling Glycine and Proline observations.\n    D_MIX = np.concatenate((D_GLY, D_PRO))\n\n    # --- Helper Functions ---\n    def create_distribution(dataset, w, alpha):\n        \"\"\"\n        Constructs a smoothed, normalized 2D probability distribution from a dataset.\n\n        Args:\n            dataset (np.ndarray): Array of (phi, psi) coordinates.\n            w (float): Bin width in degrees.\n            alpha (float): Additive smoothing parameter.\n\n        Returns:\n            np.ndarray: A 2D array representing the probability distribution.\n        \"\"\"\n        num_bins = int(360 / w)\n        bins = np.linspace(-180, 180, num_bins + 1)\n        \n        if dataset.shape[0] == 0:\n            counts = np.zeros((num_bins, num_bins), dtype=float)\n        else:\n            phi, psi = dataset[:, 0], dataset[:, 1]\n            counts, _, _ = np.histogram2d(phi, psi, bins=[bins, bins], range=[[-180, 180], [-180, 180]])\n\n        smoothed_counts = counts + alpha\n        total_pseudo_counts = smoothed_counts.sum()\n        \n        if total_pseudo_counts == 0:\n            # Fallback for empty smoothed counts, though won't occur with alpha > 0\n            return np.full((num_bins, num_bins), 1.0 / (num_bins**2), dtype=float)\n        \n        return smoothed_counts / total_pseudo_counts\n\n    def calculate_kl_divergence(P, Q, U):\n        \"\"\"\n        Computes the Kullback-Leibler divergence D_KL(P_U || Q_U).\n\n        Args:\n            P (np.ndarray): The first probability distribution.\n            Q (np.ndarray): The second probability distribution.\n            U (np.ndarray): The boolean mask for the union of allowed regions.\n\n        Returns:\n            float: The calculated KL divergence.\n        \"\"\"\n        # Restrict distributions to the union mask U\n        P_restricted = P[U]\n        Q_restricted = Q[U]\n        \n        # Renormalize the restricted distributions\n        P_U = P_restricted / P_restricted.sum()\n        Q_U = Q_restricted / Q_restricted.sum()\n        \n        # Calculate KL divergence. Additive smoothing ensures P_U and Q_U are > 0.\n        return np.sum(P_U * (np.log(P_U) - np.log(Q_U)))\n\n    def process_case(w, alpha, tau):\n        \"\"\"\n        Processes a single test case and returns the three required KL divergences.\n        \n        Args:\n            w (float): Bin width.\n            alpha (float): Smoothing parameter.\n            tau (float): Probability threshold for allowed regions.\n            \n        Returns:\n            list: A list of three computed divergence values.\n        \"\"\"\n        # Step 1: Create probability distributions\n        P_gly = create_distribution(D_GLY, w, alpha)\n        P_pro = create_distribution(D_PRO, w, alpha)\n        P_mix = create_distribution(D_MIX, w, alpha)\n        \n        # Step 2: Determine allowed regions and their union\n        R_gly = P_gly >= tau\n        R_pro = P_pro >= tau\n        U = np.logical_or(R_gly, R_pro)\n        \n        if not np.any(U):\n            U = np.full(P_gly.shape, True, dtype=bool)\n\n        # Step 3: Compute the three specified KL divergences\n        d1 = calculate_kl_divergence(P_gly, P_mix, U)\n        d2 = calculate_kl_divergence(P_pro, P_mix, U)\n        d3 = calculate_kl_divergence(P_gly, P_pro, U)\n        \n        return [d1, d2, d3]\n\n    # --- Main Execution ---\n    test_cases = [\n        # (w, alpha, tau)\n        (30, 1e-3, 1e-2),\n        (90, 1e-6, 3e-2),\n        (15, 1e-2, 5e-3),\n    ]\n\n    all_results = []\n    for w, alpha, tau in test_cases:\n        results_for_case = process_case(w, alpha, tau)\n        all_results.extend(results_for_case)\n\n    # Final formatting and printing\n    formatted_results = [f\"{r:.6f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "拉马钱德兰分析的一个主要应用是验证实验确定或计算预测的蛋白质结构。这项高级实践超越了简单的几何检查，要求您基于一个复杂的、基于知识的统计模型——冯·米塞斯分布混合模型——来实现一个验证流程 。通过计算给定构象的概率密度并将其与既定阈值进行比较，您将学会将残基分类为“优势”、“允许”或“离群”区域，这是现代结构生物信息学中的一项核心任务。",
            "id": "3861147",
            "problem": "给定一个简化的、具有物理动机的、基于知识的骨架扭转角分布模型，该模型用于在 Ramachandran 图上对残基进行分类。骨架扭转角是由连续肽平面几何形状定义的二面角 $\\phi$ 和 $\\psi$。由于 $\\phi$ 和 $\\psi$ 是圆周上的角度变量，因此构象偏好是周期性的。我们通过二维环面上的独立 von Mises 分量的混合来模拟 $(\\phi,\\psi)$ 的联合分布，这反映了公认的典型区域（右手α螺旋、β折叠、多聚脯氨酸II型、左手α螺旋）。该模型由以下概率密度函数（Probability Density Function (PDF)）指定（单位为弧度）：\n$$\np(\\phi,\\psi) \\;=\\; \\sum_{j=1}^{J} w_j\\, f_{\\mathrm{VM}}(\\phi;\\mu_{\\phi,j},\\kappa_{\\phi,j})\\, f_{\\mathrm{VM}}(\\psi;\\mu_{\\psi,j},\\kappa_{\\psi,j}),\n$$\n其中 $J$ 是混合组分的数量，$w_j$ 是非负权重，满足 $\\sum_{j=1}^{J} w_j = 1$，$\\mu_{\\phi,j}$ 和 $\\mu_{\\psi,j}$ 是组分均值（单位为弧度），$\\kappa_{\\phi,j}$ 和 $\\kappa_{\\psi,j}$ 是集中参数。一维 von Mises 密度（单位为弧度）为\n$$\nf_{\\mathrm{VM}}(\\theta;\\mu,\\kappa) \\;=\\; \\frac{e^{\\kappa \\cos(\\theta-\\mu)}}{2\\pi I_0(\\kappa)},\n$$\n其中 $I_0$ 是0阶第一类修正贝塞尔函数。混合参数为：\n- $J = 4$，\n- $(w_1,w_2,w_3,w_4) = (0.55,\\,0.35,\\,0.07,\\,0.03)$，\n- 组分1（右手α螺旋）：$(\\mu_{\\phi,1},\\mu_{\\psi,1}) = (-60^\\circ,-45^\\circ)$，$(\\kappa_{\\phi,1},\\kappa_{\\psi,1}) = (25,\\,25)$，\n- 组分2（β折叠）：$(\\mu_{\\phi,2},\\mu_{\\psi,2}) = (-135^\\circ,135^\\circ)$，$(\\kappa_{\\phi,2},\\kappa_{\\psi,2}) = (35,\\,20)$，\n- 组分3（多聚脯氨酸II型）：$(\\mu_{\\phi,3},\\mu_{\\psi,3}) = (-75^\\circ,145^\\circ)$，$(\\kappa_{\\phi,3},\\kappa_{\\psi,3}) = (15,\\,15)$，\n- 组分4（左手α螺旋）：$(\\mu_{\\phi,4},\\mu_{\\psi,4}) = (60^\\circ,30^\\circ)$，$(\\kappa_{\\phi,4},\\kappa_{\\psi,4}) = (20,\\,20)$。\n在计算时，必须使用 $\\theta_{\\mathrm{rad}} = \\theta_{\\mathrm{deg}}\\times\\pi/180$ 将角度从度转换为弧度。\n\n将优选区域 $L_f$ 定义为捕获指定高概率质量 $p_f$ 的密度上水平集，即\n$$\nL_f \\;=\\; \\{(\\phi,\\psi) \\;:\\; p(\\phi,\\psi) \\;\\ge\\; \\tau_f\\}, \\quad \\text{其中 } \\iint_{L_f} p(\\phi,\\psi)\\, d\\phi\\, d\\psi \\;=\\; p_f,\n$$\n其中 $p_f = 0.98$。类似地，用 $p_a = 0.999$ 和阈值 $\\tau_a$ 定义允许区域 $L_a$，即\n$$\nL_a \\;=\\; \\{(\\phi,\\psi) \\;:\\; p(\\phi,\\psi) \\;\\ge\\; \\tau_a\\}, \\quad \\text{其中 } \\iint_{L_a} p(\\phi,\\psi)\\, d\\phi\\, d\\psi \\;=\\; p_a.\n$$\n具有角度 $(\\phi_i,\\psi_i)$ 的残基，如果 $(\\phi_i,\\psi_i)\\in L_f$ 则分类为优选，如果 $(\\phi_i,\\psi_i)\\in L_a\\setminus L_f$ 则分类为仅允许，如果 $(\\phi_i,\\psi_i)\\notin L_a$ 则分类为离群值。这些分数定义为\n$$\nF_f \\;=\\; \\frac{N_f}{N},\\quad F_{ao} \\;=\\; \\frac{N_{ao}}{N},\\quad F_o \\;=\\; \\frac{N_o}{N},\n$$\n其中 $N$ 是残基总数，$N_f$ 是优选残基数，$N_{ao}$ 是仅允许残基数，$N_o$ 是离群值数。包含性允许分数为 $F_{\\mathrm{inc}} = F_f + F_{ao}$。\n\n通过在 $[-180^\\circ,180^\\circ]\\times[-180^\\circ,180^\\circ]$ 范围内以步长 $\\Delta = 1^\\circ$ 的均匀网格对 $(\\phi,\\psi)$ 域进行离散化，将角度转换为弧度以在每个网格点上计算 $p(\\phi,\\psi)$，将网格密度按降序排序，并选择其累积黎曼和首次等于或超过 $p_f$（相应地为 $p_a$）的最小密度值，来数值近似阈值 $\\tau_f$ 和 $\\tau_a$。使用黎曼矩形面积 $A_{\\mathrm{cell}} = (\\Delta\\pi/180)^2$。\n\n最后，将计算出的分数与标准验证阈值进行比较，为每个案例报告三个布尔测试：\n- 优选分数测试：$F_f \\ge \\theta_f$，其中 $\\theta_f = 0.95$，\n- 允许分数测试（包含性）：$F_{\\mathrm{inc}} \\ge \\theta_a$，其中 $\\theta_a = 0.99$，\n- 离群值分数测试：$F_o \\le \\theta_o$，其中 $\\theta_o = 0.01$。\n\n角度应以度为单位进行解释，程序必须以四舍五入到三位小数的小数形式输出分数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，并且其本身是按 $[F_f, F_{ao}, F_o, \\text{favored\\_pass}, \\text{allowed\\_pass}, \\text{outlier\\_pass}]$ 顺序排列的包含六个条目的列表。\n\n使用以下残基角度集（以度为单位）的测试套件：\n- 测试用例1（$N=10$个残基）：\n  $[(-60,-45),\\,(-58,-47),\\,(-62,-50),\\,(-130,130),\\,(-135,135),\\,(-75,145),\\,(60,30),\\,(-120,120),\\,(0,0),\\,(-61,-44)]$.\n- 测试用例2（$N=12$个残基）：\n  $[(-179,179),\\,(179,-179),\\,(-180,180),\\,(-75,145),\\,(60,30),\\,(-60,130),\\,(-140,140),\\,(-65,-40),\\,(-135,120),\\,(62,28),\\,(170,-170),\\,(-170,170)]$.\n- 测试用例3（$N=14$个残基）：\n  $[(0,180),\\,(180,0),\\,(90,-90),\\,(-90,90),\\,(120,0),\\,(0,-120),\\,(-45,160),\\,(80,80),\\,(-80,-80),\\,(-130,130),\\,(-60,-45),\\,(-135,135),\\,(10,10),\\,(-10,-10)]$.\n\n你的任务是实现一个程序：\n- 使用上述基于网格的近似方法计算 $\\tau_f$ 和 $\\tau_a$，\n- 对每个测试用例中的每个残基进行分类，\n- 计算 $F_f$、$F_{ao}$、$F_o$ 和三个验证布尔值，分数四舍五入到三位小数，\n- 按上述确切格式输出单行结果。",
            "solution": "问题陈述已经过分析，并被确定为**有效的**。它在计算结构生物学原理，特别是蛋白质主链构象的统计分析方面，具有科学依据。该问题是良构的，提供了一套完整且一致的定义、参数和数值程序。所有术语都有客观和数学上的定义，从而可以得到唯一且可验证的解。\n\n任务是根据概率模型对由二面角 $(\\phi, \\psi)$ 定义的蛋白质残基主链构象进行分类，然后对给定的残基集进行统计验证。解决方案涉及三个主要阶段：\n1.  确定定义“优选”和“允许”构象区域的概率密度阈值。\n2.  根据这些阈值对单个残基进行分类。\n3.  计算每个类别中残基的比例，并将其与标准的质量控制基准进行比较。\n\n**1. 概率性主链构象模型**\n\n蛋白质主链的构象空间由二面角 $(\\phi, \\psi)$ 描述。问题以概率密度函数 $p(\\phi,\\psi)$ 的形式提供了一个基于知识的能量模型。该函数被构建为一个混合模型，它是一些更简单分布的和，每个分布代表一个典型的蛋白质二级结构元件。\n$$\np(\\phi,\\psi) \\;=\\; \\sum_{j=1}^{J} w_j\\, f_{\\mathrm{VM}}(\\phi;\\mu_{\\phi,j},\\kappa_{\\phi,j})\\, f_{\\mathrm{VM}}(\\psi;\\mu_{\\psi,j},\\kappa_{\\psi,j})\n$$\n这里，$J=4$ 个组分对应于右手α螺旋、β折叠、多聚脯氨酸II型螺旋和左手α螺旋。每个组分都由 $w_j$ 加权，代表其在大型蛋白质结构数据库中的丰度。角度 $\\phi$ 和 $\\psi$ 是周期性的，因此适用于每个角度的概率分布是 von Mises 分布，它是正态分布在圆周上的类似物。von Mises PDF 由以下公式给出：\n$$\nf_{\\mathrm{VM}}(\\theta;\\mu,\\kappa) \\;=\\; \\frac{e^{\\kappa \\cos(\\theta-\\mu)}}{2\\pi I_0(\\kappa)}\n$$\n参数 $\\mu$ 和 $\\kappa$ 分别代表平均角和集中度（方差的倒数）。$I_0(\\kappa)$ 是0阶第一类修正贝塞尔函数，作为归一化常数，确保分布在圆周 $[-\\pi, \\pi]$ 上的积分为1。完整的 $p(\\phi, \\psi)$ 是一个二维环面上的分布，并且因为每个组分的 $\\phi$ 和 $\\psi$ 分布是独立的，所以一个组分的联合PDF是两个一维 von Mises PDF 的乘积。所有角度参数 $(\\mu_{\\phi,j}, \\mu_{\\psi,j})$ 都以度为单位提供，并且必须使用关系式 $\\theta_{\\mathrm{rad}} = \\theta_{\\mathrm{deg}} \\times \\pi / 180$ 转换为弧度以进行计算。\n\n**2. 密度阈值的确定**\n\n问题将 Ramachandran 图的“优选”($L_f$) 和“允许”($L_a$) 区域定义为高概率密度水平集。具体来说，$L_f$ 是一个区域 $\\{(\\phi,\\psi) : p(\\phi,\\psi) \\ge \\tau_f\\}$，包含总概率质量的 $p_f = 98\\%$；而 $L_a$ 是一个区域 $\\{(\\phi,\\psi) : p(\\phi,\\psi) \\ge \\tau_a\\}$，包含 $p_a = 99.9\\%$ 的质量。此任务的核心是找到密度阈值 $\\tau_f$ 和 $\\tau_a$。\n\n这些阈值的解析解是难解的。因此，规定了数值方法。连续的 $(\\phi, \\psi)$ 空间被离散化为一个均匀网格。问题指定了一个在 $[-180^\\circ, 180^\\circ]\\times[-180^\\circ, 180^\\circ]$ 范围内，步长为 $\\Delta = 1^\\circ$ 的网格。为了正确处理域的周期性，我们使用一个 $360 \\times 360$ 点的网格，例如，在每个维度上覆盖角度 $[-180^\\circ, 179^\\circ]$。这对应于弧度单位的周期域 $[-\\pi, \\pi) \\times [-\\pi, \\pi)$。\n\n寻找阈值的算法如下：\n1.  构建一个 $360 \\times 360$ 的 $(\\phi, \\psi)$ 角度对网格（单位为弧度）。\n2.  在每个 $360^2 = 129,600$ 个网格点上计算PDF $p(\\phi, \\psi)$。\n3.  将得到的二维密度值数组展平为一维列表，并按降序排序，得到 $p_{(1)} \\ge p_{(2)} \\ge \\dots \\ge p_{(N)}$，其中 $N=129600$。\n4.  PDF在域上的积分通过黎曼和来近似：$\\iint p(\\phi,\\psi) d\\phi d\\psi \\approx \\sum_{k=1}^N p_{(k)} A_{\\mathrm{cell}}$，其中 $A_{\\mathrm{cell}} = (\\Delta \\cdot \\pi/180)^2$ 是单个网格单元的面积（单位为弧度的平方）。\n5.  $k$ 个最可能点的累积概率为 $C_k = A_{\\mathrm{cell}} \\sum_{i=1}^k p_{(i)}$。\n6.  阈值 $\\tau_f$ 是使累积概率 $C_{k_f}$ 首次达到或超过 $p_f = 0.98$ 的最小密度值 $p_{(k_f)}$。类似地，$\\tau_a$ 是使 $C_{k_a}$ 首次达到或超过 $p_a = 0.999$ 的 $p_{(k_a)}$。这些索引 $k_f$ 和 $k_a$ 可以通过在累积概率数组上使用搜索算法高效地找到。\n\n**3. 残基分类与验证**\n\n在确定了阈值 $\\tau_f$ 和 $\\tau_a$ 后，可以对测试用例中的每个残基进行分类。对于一个给定的具有角度 $(\\phi_i, \\psi_i)$ 的残基：\n1.  首先将以度为单位提供的角度转换为弧度。为稳健地处理周期性，角度被映射到区间 $[-180^\\circ, 180^\\circ)$ 或弧度单位的 $[-\\pi, \\pi)$。\n2.  使用混合模型计算概率密度 $p_i = p(\\phi_i, \\psi_i)$。\n3.  残基根据以下规则进行分类：\n    *   **优选**：如果 $p_i \\ge \\tau_f$。\n    *   **仅允许**：如果 $\\tau_a \\le p_i  \\tau_f$。\n    *   **离群值**：如果 $p_i  \\tau_a$。\n\n对于每个测试用例（一组残基），我们计算每个类别中的残基数量（$N_f, N_{ao}, N_o$）。根据这些计数和残基总数 $N$，我们计算出以下分数：\n$$\nF_f \\;=\\; \\frac{N_f}{N},\\quad F_{ao} \\;=\\; \\frac{N_{ao}}{N},\\quad F_o \\;=\\; \\frac{N_o}{N}\n$$\n这些分数代表了给定蛋白质模型的质量，将它们与标准验证阈值进行比较：\n*   优选分数测试：$F_f \\ge 0.95$。\n*   允许分数测试（包含性）：$F_{\\mathrm{inc}} = F_f + F_{ao} \\ge 0.99$。\n*   离群值分数测试：$F_o \\le 0.01$。\n\n每个测试用例的最终输出是一个列表，其中包含计算出的分数（$F_f, F_{ao}, F_o$）（四舍五入到三位小数）以及这三个测试的布尔结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import i0\n\ndef solve():\n    \"\"\"\n    Computes Ramachandran plot statistics based on a von Mises mixture model.\n    \"\"\"\n    # ------------------ MODEL PARAMETERS ------------------\n    # Conversion factor from degrees to radians\n    deg_to_rad = np.pi / 180.0\n\n    # Mixture model parameters\n    weights = np.array([0.55, 0.35, 0.07, 0.03])\n    means_deg = np.array([\n        [-60.0, -45.0],   # Component 1: right-handed alpha-helix\n        [-135.0, 135.0],  # Component 2: beta-sheet\n        [-75.0, 145.0],   # Component 3: polyproline II\n        [60.0, 30.0]      # Component 4: left-handed alpha-helix\n    ])\n    kappas = np.array([\n        [25.0, 25.0],\n        [35.0, 20.0],\n        [15.0, 15.0],\n        [20.0, 20.0]\n    ])\n    \n    # Convert mean angles to radians\n    means_rad = means_deg * deg_to_rad\n\n    # Target probability masses for regions\n    p_f = 0.98\n    p_a = 0.999\n\n    # Validation thresholds for fractions\n    theta_f = 0.95\n    theta_a = 0.99\n    theta_o = 0.01\n\n    # ------------------ HELPER FUNCTIONS ------------------\n    def f_vm(theta, mu, kappa):\n        \"\"\"Calculates the 1D von Mises PDF.\"\"\"\n        # The i0 function is vectorized.\n        norm_const = 2.0 * np.pi * i0(kappa)\n        return np.exp(kappa * np.cos(theta - mu)) / norm_const\n\n    def p_phi_psi(phi, psi, W, M, K):\n        \"\"\"Calculates the 2D mixture model PDF for scalar or array inputs.\"\"\"\n        total_p = np.zeros_like(phi, dtype=np.float64)\n        for j in range(len(W)):\n            f_phi = f_vm(phi, M[j, 0], K[j, 0])\n            f_psi = f_vm(psi, M[j, 1], K[j, 1])\n            total_p += W[j] * f_phi * f_psi\n        return total_p\n\n    def calculate_thresholds():\n        \"\"\"Numerically determines the density thresholds tau_f and tau_a.\"\"\"\n        delta_deg = 1.0\n        grid_angles_deg = np.arange(-180.0, 180.0, delta_deg)\n        phi_deg_grid, psi_deg_grid = np.meshgrid(grid_angles_deg, grid_angles_deg)\n\n        phi_rad_grid = phi_deg_grid * deg_to_rad\n        psi_rad_grid = psi_deg_grid * deg_to_rad\n\n        # Evaluate PDF on the grid\n        p_grid = p_phi_psi(phi_rad_grid, psi_rad_grid, weights, means_rad, kappas)\n\n        # Flatten and sort densities in descending order\n        p_flat_sorted = np.sort(p_grid.flatten())[::-1]\n\n        # Calculate cumulative probability using Riemann sum\n        delta_rad = delta_deg * deg_to_rad\n        A_cell = delta_rad ** 2\n        cum_prob = np.cumsum(p_flat_sorted) * A_cell\n\n        # Find indices where cumulative probability exceeds targets\n        idx_f = np.searchsorted(cum_prob, p_f)\n        idx_a = np.searchsorted(cum_prob, p_a)\n\n        # Thresholds are the density values at these indices\n        tau_f = p_flat_sorted[idx_f]\n        tau_a = p_flat_sorted[idx_a]\n        return tau_f, tau_a\n\n    # ------------------ MAIN LOGIC ------------------\n    # Calculate thresholds once\n    tau_f, tau_a = calculate_thresholds()\n    \n    # Test case data\n    test_cases_deg = [\n        [(-60, -45), (-58, -47), (-62, -50), (-130, 130), (-135, 135), (-75, 145), (60, 30), (-120, 120), (0, 0), (-61, -44)],\n        [(-179, 179), (179, -179), (-180, 180), (-75, 145), (60, 30), (-60, 130), (-140, 140), (-65, -40), (-135, 120), (62, 28), (170, -170), (-170, 170)],\n        [(0, 180), (180, 0), (90, -90), (-90, 90), (120, 0), (0, -120), (-45, 160), (80, 80), (-80, -80), (-130, 130), (-60, -45), (-135, 135), (10, 10), (-10, -10)]\n    ]\n\n    all_results = []\n    \n    for case_data_deg in test_cases_deg:\n        N = len(case_data_deg)\n        N_f, N_ao, N_o = 0, 0, 0\n\n        angles = np.array(case_data_deg, dtype=np.float64)\n        \n        # Convert all angles to radians for calculation\n        phi_rad_data = angles[:, 0] * deg_to_rad\n        psi_rad_data = angles[:, 1] * deg_to_rad\n\n        # Calculate PDF for all residues in the case\n        densities = p_phi_psi(phi_rad_data, psi_rad_data, weights, means_rad, kappas)\n\n        for p_val in densities:\n            if p_val >= tau_f:\n                N_f += 1\n            elif p_val >= tau_a:\n                N_ao += 1\n            else:\n                N_o += 1\n\n        # Calculate fractions\n        F_f = N_f / N\n        F_ao = N_ao / N\n        F_o = N_o / N\n        F_inc = F_f + F_ao\n\n        # Perform validation tests\n        favored_pass = F_f >= theta_f\n        allowed_pass = F_inc >= theta_a\n        outlier_pass = F_o = theta_o\n\n        # Assemble the result for the case as specified\n        case_result = [\n            f\"{F_f:.3f}\",\n            f\"{F_ao:.3f}\",\n            f\"{F_o:.3f}\",\n            favored_pass,\n            allowed_pass,\n            outlier_pass\n        ]\n        \n        # Format the list into a string representation for the final output\n        inner_list_str = f\"[{case_result[0]},{case_result[1]},{case_result[2]},{str(case_result[3]).lower()},{str(case_result[4]).lower()},{str(case_result[5]).lower()}]\"\n        all_results.append(inner_list_str)\n\n    # Print a single line with all results in the required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}