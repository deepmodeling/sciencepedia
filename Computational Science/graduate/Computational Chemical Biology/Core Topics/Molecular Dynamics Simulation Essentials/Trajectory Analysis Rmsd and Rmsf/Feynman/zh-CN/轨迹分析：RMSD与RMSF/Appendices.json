{
    "hands_on_practices": [
        {
            "introduction": "在计算复杂蛋白质的均方根涨落（RMSF）之前，在一个简单的、可精确求解的系统中理解其物理意义是很有启发性的。本练习将单个粒子在谐波势中的RMSF与统计力学的基本概念——即温度（$T$）和势的局部刚度（$k$）——联系起来。这有助于我们直观地理解，在分子水平上，高或低的RMSF值究竟意味着什么。",
            "id": "3868675",
            "problem": "在计算化学生物学中，均方根涨落 (RMSF) 用于量化轨迹上每个原子位置涨落的幅度，而均方根偏差 (RMSD) 则汇总了许多原子相对于参考结构的偏差。考虑一个蛋白质原子的单个笛卡尔坐标 $x$，它在一个一维谐振子势 $U(x) = \\frac{1}{2} k (x - x_{0})^{2}$（其中 $k$ 是力常数）的作用下，在平衡位置 $x_{0}$ 附近涨落。该系统处于绝对温度 $T$ 下，并与一个热库交换能量，因此它由正则系综描述。一条长的、遍历性的分子动力学轨迹提供了样本 $x(t)$，使得时间平均等于系综平均。\n\n从正则分布和 RMSF（即绕平均位置的均方涨落的平方根）的定义出发，推导一个用玻尔兹曼常数 $k_{B}$、温度 $T$ 和力常数 $k$ 表示的 RMSF 的闭式解析表达式。你的最终答案必须是一个单一的简化解析表达式。如果你进行了任何中间积分，请根据平衡统计力学的第一性原理证明每一步。用与 $x$ 相同的长度单位表示你的最终答案（无需进行数值计算）。",
            "solution": "该问题要求推导一个原子的单个笛卡尔坐标 $x$ 的均方根涨落 (RMSF) 的闭式表达式。该原子受到一维谐振子势 $U(x)$ 的作用，并与温度为 $T$ 的热库处于热平衡状态。这对应于统计力学中的正则系综。\n\n问题陈述提供了以下信息：\n- 势能：$U(x) = \\frac{1}{2} k (x - x_0)^2$，其中 $k$ 是力常数，$x_0$ 是平衡位置。\n- 该系统由绝对温度为 $T$ 的正则系综描述。\n- 玻尔兹曼常数为 $k_B$。\n- 遍历性假设意味着长轨迹的时间平均等价于系综平均。\n\nRMSF 定义为坐标绕其平均位置的均方涨落的平方根。在数学上，这表示为：\n$$\n\\text{RMSF} = \\sqrt{\\langle (x - \\langle x \\rangle)^2 \\rangle}\n$$\n其中 $\\langle \\cdot \\rangle$ 表示系综平均。\n\n在正则系综中，坐标 $x$ 的概率密度函数遵循玻尔兹曼分布：\n$$\nP(x) = \\frac{1}{Z} \\exp(-\\beta U(x))\n$$\n其中 $\\beta = \\frac{1}{k_B T}$，$Z$ 是配分函数，它作为归一化常数。配分函数由玻尔兹曼因子对所有可能的状态（位置）积分得到：\n$$\nZ = \\int_{-\\infty}^{\\infty} \\exp(-\\beta U(x)) \\, dx = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k}{2} (x - x_0)^2\\right) \\, dx\n$$\n\n推导过程分为两个主要步骤：首先，我们确定平均位置 $\\langle x \\rangle$，其次，我们计算绕该平均值的均方涨落。\n\n**步骤1：计算平均位置 $\\langle x \\rangle$**\n\n平均位置 $\\langle x \\rangle$ 是 $x$ 的期望值，计算如下：\n$$\n\\langle x \\rangle = \\int_{-\\infty}^{\\infty} x P(x) \\, dx = \\frac{\\int_{-\\infty}^{\\infty} x \\exp\\left(-\\frac{\\beta k}{2} (x - x_0)^2\\right) \\, dx}{\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k}{2} (x - x_0)^2\\right) \\, dx}\n$$\n为了计算这些积分，我们进行变量替换。令 $y = x - x_0$，这意味着 $x = y + x_0$ 且 $dx = dy$。$x$ 从 $-\\infty$ 到 $\\infty$ 的积分限对于 $y$ 保持不变。\n$$\n\\langle x \\rangle = \\frac{\\int_{-\\infty}^{\\infty} (y + x_0) \\exp\\left(-\\frac{\\beta k}{2} y^2\\right) \\, dy}{\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k}{2} y^2\\right) \\, dy}\n$$\n我们可以将分子分成两部分：\n$$\n\\langle x \\rangle = \\frac{\\int_{-\\infty}^{\\infty} y \\exp\\left(-\\frac{\\beta k}{2} y^2\\right) \\, dy + \\int_{-\\infty}^{\\infty} x_0 \\exp\\left(-\\frac{\\beta k}{2} y^2\\right) \\, dy}{\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k}{2} y^2\\right) \\, dy}\n$$\n分子中的第一个积分 $\\int_{-\\infty}^{\\infty} y \\exp(-\\frac{\\beta k}{2} y^2) \\, dy$ 的被积函数是一个奇函数（一个奇函数 $y$ 和一个偶函数 $\\exp(-\\text{const} \\cdot y^2)$ 的乘积）。奇函数在对称区间 $(-\\infty, \\infty)$ 上的积分为零。\n分子中的第二个积分是 $x_0 \\int_{-\\infty}^{\\infty} \\exp(-\\frac{\\beta k}{2} y^2) \\, dy$。\n因此，$\\langle x \\rangle$ 的表达式简化为：\n$$\n\\langle x \\rangle = \\frac{0 + x_0 \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k}{2} y^2\\right) \\, dy}{\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k}{2} y^2\\right) \\, dy} = x_0\n$$\n这证实了一个物理上直观的结果，即对于对称谐振子势，平均位置就是平衡位置 $x_0$。\n\n**步骤2：计算均方涨落 $\\langle (x - \\langle x \\rangle)^2 \\rangle$**\n\n由于 $\\langle x \\rangle = x_0$，均方涨落为 $\\langle (x - x_0)^2 \\rangle$。这是位置的方差 $\\sigma_x^2$。\n$$\n\\langle (x - x_0)^2 \\rangle = \\frac{\\int_{-\\infty}^{\\infty} (x - x_0)^2 \\exp\\left(-\\frac{\\beta k}{2} (x - x_0)^2\\right) \\, dx}{\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k}{2} (x - x_0)^2\\right) \\, dx}\n$$\n使用相同的替换 $y = x - x_0$：\n$$\n\\langle (x - x_0)^2 \\rangle = \\frac{\\int_{-\\infty}^{\\infty} y^2 \\exp\\left(-\\frac{\\beta k}{2} y^2\\right) \\, dy}{\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k}{2} y^2\\right) \\, dy}\n$$\n让我们定义常数 $\\alpha = \\frac{\\beta k}{2}$。表达式变为：\n$$\n\\langle (x - x_0)^2 \\rangle = \\frac{\\int_{-\\infty}^{\\infty} y^2 \\exp(-\\alpha y^2) \\, dy}{\\int_{-\\infty}^{\\infty} \\exp(-\\alpha y^2) \\, dy}\n$$\n这些是高斯积分的标准形式。我们将其记为 $I_2 = \\int_{-\\infty}^{\\infty} y^2 \\exp(-\\alpha y^2) \\, dy$ 和 $I_0 = \\int_{-\\infty}^{\\infty} \\exp(-\\alpha y^2) \\, dy$。\n标准高斯积分 $I_0$ 的值为：\n$$\nI_0 = \\sqrt{\\frac{\\pi}{\\alpha}}\n$$\n积分 $I_2$ 可以通过对参数 $\\alpha$ 求导从 $I_0$ 得到：\n$$\n\\frac{dI_0}{d\\alpha} = \\frac{d}{d\\alpha} \\int_{-\\infty}^{\\infty} \\exp(-\\alpha y^2) \\, dy = \\int_{-\\infty}^{\\infty} \\frac{\\partial}{\\partial\\alpha} \\exp(-\\alpha y^2) \\, dy = \\int_{-\\infty}^{\\infty} (-y^2) \\exp(-\\alpha y^2) \\, dy = -I_2\n$$\n所以，$I_2 = -\\frac{dI_0}{d\\alpha}$。对 $I_0$ 的表达式求导：\n$$\nI_2 = - \\frac{d}{d\\alpha} \\left(\\sqrt{\\pi} \\alpha^{-1/2}\\right) = - \\sqrt{\\pi} \\left(-\\frac{1}{2} \\alpha^{-3/2}\\right) = \\frac{\\sqrt{\\pi}}{2} \\alpha^{-3/2} = \\frac{1}{2\\alpha} \\sqrt{\\frac{\\pi}{\\alpha}} = \\frac{I_0}{2\\alpha}\n$$\n现在我们可以计算比值 $\\frac{I_2}{I_0}$：\n$$\n\\langle (x - x_0)^2 \\rangle = \\frac{I_2}{I_0} = \\frac{I_0 / (2\\alpha)}{I_0} = \\frac{1}{2\\alpha}\n$$\n将 $\\alpha = \\frac{\\beta k}{2}$ 的表达式代回：\n$$\n\\langle (x - x_0)^2 \\rangle = \\frac{1}{2 \\left(\\frac{\\beta k}{2}\\right)} = \\frac{1}{\\beta k}\n$$\n最后，代入 $\\beta = \\frac{1}{k_B T}$：\n$$\n\\langle (x - x_0)^2 \\rangle = \\frac{k_B T}{k}\n$$\n这个结果与能量均分定理一致，该定理指出能量中的每个二次自由度对总能量的平均贡献为 $\\frac{1}{2} k_B T$。对于势能 $U(x)$，我们有 $\\langle U(x) \\rangle = \\langle \\frac{1}{2} k (x-x_0)^2 \\rangle = \\frac{1}{2} k \\langle (x-x_0)^2 \\rangle = \\frac{1}{2} k_B T$，这直接得出 $\\langle (x-x_0)^2 \\rangle = \\frac{k_B T}{k}$。\n\n**步骤3：RMSF 的最终计算**\n\nRMSF 是均方涨落的平方根：\n$$\n\\text{RMSF} = \\sqrt{\\langle (x - x_0)^2 \\rangle} = \\sqrt{\\frac{k_B T}{k}}\n$$\n这是在温度 $T$ 下，谐振子势中涨落的坐标的 RMSF 的最终闭式解析表达式。单位是一致的，因为 $k_B T$ 的单位是能量（例如，焦耳），$k$ 的单位是能量每长度平方（例如，焦耳/米$^2$），所以该比值的单位是长度的平方，其平方根的单位是长度，符合要求。",
            "answer": "$$\n\\boxed{\\sqrt{\\frac{k_B T}{k}}}\n$$"
        },
        {
            "introduction": "从理论转向实践，本练习要求您从头编写一个计算均方根偏差（RMSD）和RMSF的程序。它突出强调了计算流程中一个常见且至关重要的错误来源：单位不一致。通过模拟纳米（nm）和埃（Å）之间的单位混淆，您将直接观察到这类错误如何导致灾难性的错误结果，并学习实施验证检查以防止此类问题的发生。",
            "id": "3868680",
            "problem": "您正在分析分子动力学轨迹，以计算一个小型合成系统的均方根偏差（RMSD）和均方根涨落（RMSF）。您的任务是设计一个程序，量化纳米和埃之间单位不一致对RMSD和RMSF的影响，并执行验证检查以检测此类不一致。计算必须基于第一性原理：欧几里得几何和对原子及帧的统计聚合。不要使用预打包的公式；相反，应直接使用向量运算和平均值从定义中实现所有计算。\n\n使用的基本原理：\n- 欧几里得向量空间：使用三维空间中的欧几里得范数，通过坐标差异计算距离。\n- 统计聚合：使用算术平均值计算原子和帧的平均值。\n- 物理单位转换：使用经过充分检验的事实：$1 \\, \\text{\\AA} = 0.1 \\, \\mathrm{nm}$。\n\n在代码中实现的定义（不引用任何目标公式）：\n- 均方根偏差（RMSD）：通过聚合原子间的平方欧几里得位移，然后取其均值的平方根，来量化轨迹帧相对于参考帧的结构偏差。\n- 均方根涨落（RMSF）：通过聚合每个原子位置与其时间平均位置的平方偏差，然后取其在所有帧中均值的平方根，来量化每个原子的涨落；对于测试用例，报告所有原子的平均RMSF作为单个标量。\n\n需要实现的验证检查：\n- 元数据一致性检查：验证所有帧的单位标签是否一致。\n- 幅度连续性检查：计算每帧的典型坐标幅度（例如，每个原子欧几里得范数的中位数），并检查连续帧之间的比率；一个大的比率表明可能存在单位不匹配。使用一个严格的启发式阈值：如果任何连续帧的比率超过 $3$ 或低于 $1/3$，则标记为不连续。\n\n单位和输出要求：\n- 所有距离均以纳米表示；使用 $1 \\, \\text{\\AA} = 0.1 \\, \\mathrm{nm}$ 将埃转换为纳米。\n- 返回浮点数，四舍五入到六位小数。\n- 最终输出必须是一行，包含一个逗号分隔的列表，该列表由每个测试用例的列表组成，并用方括号括起来。每个测试用例列表必须按以下顺序包含五个条目：[朴素RMSD（纳米），朴素平均RMSF（纳米），校正后RMSD（纳米），校正后平均RMSF（纳米），验证标志布尔值]。例如，最后一行必须看起来像 $[[$case1\\_r1$, $case1\\_r2$, $case1\\_r3$, $case1\\_r4$, $case1\\_b$],[$case2\\_r1$, $case2\\_r2$, $case2\\_r3$, $case2\\_r4$, $case2\\_b$],\\dots]$，其中每个浮点数四舍五入到六位小数，布尔值为 $True$ 或 $False$。\n\n测试套件：\n完全按照规定实现以下四个测试用例。为清晰起见，原子索引为 $0$ 到 $3$，帧从 $0$ 开始索引。\n\n- 测试用例 1（正常路径，单位一致）：\n  - 原子数：$N=4$。\n  - 帧数：$F=4$。\n  - 每帧单位：$[\\mathrm{nm}, \\mathrm{nm}, \\mathrm{nm}, \\mathrm{nm}]$。\n  - 原子 $0$ 到 $3$ 的基础坐标 $B$（纳米）：\n    - 原子 $0$：$[0.0, 0.0, 0.0]$，\n    - 原子 $1$：$[0.3, 0.0, 0.0]$，\n    - 原子 $2$：$[0.0, 0.4, 0.0]$，\n    - 原子 $3$：$[0.0, 0.0, 0.5]$。\n  - 每原子偏移向量 $O$（纳米）：\n    - 原子 $0$：$[0.01, -0.005, 0.0]$，\n    - 原子 $1$：$[0.0, 0.008, -0.004]$，\n    - 原子 $2$：$[-0.006, 0.0, 0.007]$，\n    - 原子 $3$：$[0.005, -0.003, 0.002]$。\n  - 帧 $k$ 的坐标为 $B + k\\cdot O$，其中 $k\\in\\{0,1,2,3\\}$。\n  - 参考帧索引：$0$。\n\n- 测试用例 2（帧间单位混合，一帧为埃）：\n  - 使用与测试用例 $1$ 相同的 $B$ 和 $O$ 以及帧构建方式。\n  - 每帧单位：$[\\mathrm{nm}, \\mathrm{nm}, \\mathrm{\\AA}, \\mathrm{nm}]$。\n  - 通过将帧 $2$ 的坐标在数值上记录为埃来模拟单位不匹配（即，在数据中将帧 $2$ 的纳米坐标乘以 $10$）。其他帧在数值上以纳米记录。\n  - 参考帧索引：$0$。\n\n- 测试用例 3（边界条件：无运动）：\n  - 原子数：$N=4$。\n  - 帧数：$F=3$。\n  - 每帧单位：$[\\mathrm{nm}, \\mathrm{nm}, \\mathrm{nm}]$。\n  - 所有帧都相同，且等于测试用例 $1$ 中的 $B$。\n  - 参考帧索引：$0$。\n\n- 测试用例 4（边缘情况：单个原子，单位为埃且一致）：\n  - 原子数：$N=1$。\n  - 帧数：$F=2$。\n  - 每帧单位：$[\\mathrm{\\AA}, \\mathrm{\\AA}]$。\n  - 坐标（埃）：\n    - 帧 $0$：$[1.0, 0.0, 0.0]$，\n    - 帧 $1$：$[3.0, 0.0, 0.0]$。\n  - 参考帧索引：$0$。\n\n计算和报告细节：\n- 对于每个测试用例，计算最后一帧相对于参考帧的 RMSD 和所有原子的平均 RMSF，计算两次：\n  - 朴素计算：直接使用给定的数值坐标进行计算，不进行任何单位转换。\n  - 校正后计算：首先使用提供的单位元数据将每一帧转换为纳米，然后进行计算。\n- 执行上述验证检查，并为每个测试用例报告一个布尔值，指示是否检测到不一致。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来，每个测试用例贡献一个五元素列表：$[[r_{1}, r_{2}, r_{3}, r_{4}, b_{1}], [\\dots], [\\dots], [\\dots]]$，所有距离以纳米为单位，四舍五入到六位小数，布尔值为 $True$ 或 $False$。",
            "solution": "该问题要求基于欧几里得几何和统计力学的基本原理，实现计算分子动力学轨迹的均方根偏差（RMSD）和均方根涨落（RMSF）的算法。实现还必须包括用于检测常见单位不一致的验证检查。解决方案将首先建立数学形式，然后描述验证逻辑，最后详细说明计算策略。\n\n### 数学形式与算法设计\n\n一个具有 $N$ 个原子、跨越 $F$ 个帧的分子系统的轨迹可以表示为一组位置向量 $\\{\\vec{r}_i(t)\\}$，其中 $i \\in \\{1, \\dots, N\\}$ 是原子索引，$t \\in \\{1, \\dots, F\\}$ 是帧索引。每个 $\\vec{r}_i(t)$ 是一个三维欧几里得空间中的向量，即 $\\vec{r}_i(t) \\in \\mathbb{R}^3$。\n\n#### 单位转换\n关键的第一步是确保所有帧的单位统一。问题指定了两种可能的单位：纳米（$\\mathrm{nm}$）和埃（$\\mathrm{\\AA}$）。所有最终计算必须以纳米为单位。给定的转换因子是 $1 \\, \\text{\\AA} = 0.1 \\, \\mathrm{nm}$。\n设 $C_t$ 是帧 $t$ 的坐标矩阵，而 $u_t$ 是该帧的单位标签。校正后的纳米坐标 $C'_t$ 按如下方式获得：\n$$\nC'_t = \\begin{cases}\n    C_t \\times 0.1  \\text{if } u_t = \\mathrm{\\AA} \\\\\n    C_t  \\text{if } u_t = \\mathrm{nm}\n\\end{cases}\n$$\n此转换应用于每帧的坐标数据，以生成一个“校正后”的轨迹，其中所有位置都以纳米表示。“朴素”计算将使用给定的原始数值数据，而不进行此转换。\n\n#### 均方根偏差（RMSD）\nRMSD 衡量特定帧 $t$ 的原子与参考帧 $t_{ref}$ 的原子之间的平均距离。设 $\\vec{r}_i(t)$ 和 $\\vec{r}_i(t_{ref})$ 分别是原子 $i$ 在目标帧和参考帧中的位置向量。\n原子 $i$ 在这些位置之间的平方欧几里得距离是 $||\\vec{r}_i(t) - \\vec{r}_i(t_{ref})||^2$。\n均方偏差（MSD）是这些平方距离在所有 $N$ 个原子上的平均值：\n$$\n\\text{MSD}(t) = \\frac{1}{N} \\sum_{i=1}^{N} ||\\vec{r}_i(t) - \\vec{r}_i(t_{ref})||^2\n$$\nRMSD 是 MSD 的主平方根：\n$$\n\\text{RMSD}(t) = \\sqrt{\\text{MSD}(t)} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} ||\\vec{r}_i(t) - \\vec{r}_i(t_{ref})||^2}\n$$\n问题指定计算最后一帧（$t=F$）相对于参考帧（$t_{ref}$）的 RMSD。\n\n#### 均方根涨落（RMSF）\nRMSF 衡量每个原子位置随时间相对于其平均位置的涨落。\n首先，对于每个原子 $i$，我们计算其在所有 $F$ 帧上的时间平均位置 $\\langle \\vec{r}_i \\rangle$：\n$$\n\\langle \\vec{r}_i \\rangle = \\frac{1}{F} \\sum_{t=1}^{F} \\vec{r}_i(t)\n$$\n接下来，我们计算每个原子 $i$ 的均方涨落（MSF），即其位置与其平均位置的平方偏差的时间平均值：\n$$\n\\text{MSF}_i = \\frac{1}{F} \\sum_{t=1}^{F} ||\\vec{r}_i(t) - \\langle \\vec{r}_i \\rangle||^2\n$$\n原子 $i$ 的 RMSF 是其 MSF 的平方根：\n$$\n\\text{RMSF}_i = \\sqrt{\\text{MSF}_i} = \\sqrt{\\frac{1}{F} \\sum_{t=1}^{F} ||\\vec{r}_i(t) - \\langle \\vec{r}_i \\rangle||^2}\n$$\n问题要求一个单一的标量值，代表所有原子的平均 RMSF：\n$$\n\\langle \\text{RMSF} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} \\text{RMSF}_i\n$$\n\n### 验证检查\n对朴素（未转换）的轨迹数据及其相关的单位元数据执行两项验证检查。`True` 标志表示检测到不一致。\n\n1.  **元数据一致性检查**：此检查验证为每帧提供的单位标签是否统一。如果轨迹的单位列表中存在多于一个唯一的单位标签，则检查失败。设 $U = \\{u_1, u_2, \\dots, u_F\\}$ 为单位标签集。如果 $| \\text{set}(U) | > 1$，则标记不一致。\n\n2.  **幅度连续性检查**：此检查识别连续帧之间坐标尺度的突变，这通常表明存在单位错误。\n    - 对于每帧 $t$，我们计算一个特征幅度 $M_t$。这被定义为该帧中所有原子位置向量的欧几里得范数的中位数：$M_t = \\text{median}(\\{||\\vec{r}_1(t)||, ||\\vec{r}_2(t)||, \\dots, ||\\vec{r}_N(t)||\\})$。\n    - 然后我们计算每对连续帧的幅度比：$R_t = M_{t+1} / M_t$，其中 $t \\in \\{1, \\dots, F-1\\}$。\n    - 如果任何比率 $R_t$ 超出指定的容差区间，则标记不一致。问题将其定义为 $R_t > 3$ 或 $R_t  1/3$。\n\n测试用例的最终验证标志是这两个检查结果的逻辑或。\n\n### 测试用例的实现策略\n一个主函数将处理所有四个测试用例。对于每个用例，它将：\n1.  将朴素轨迹构建为一个形状为 $(F, N, 3)$ 的数值数组，以及每帧的单位列表。测试用例 1、2 和 3 是根据基础坐标 $B$ 和偏移向量 $O$ 生成的。\n2.  通过对标记为“Å”的帧应用 $1 \\, \\text{\\AA} = 0.1 \\, \\mathrm{nm}$ 的转换因子来构建校正后的轨迹。\n3.  使用朴素轨迹计算朴素 RMSD 和朴素平均 RMSF。\n4.  使用校正后的轨迹计算校正后 RMSD 和校正后平均 RMSF。\n5.  对朴素数据执行元数据和幅度验证检查。\n6.  将五个结果——朴素 RMSD、朴素平均 RMSF、校正后 RMSD、校正后平均 RMSF 和验证标志——整理到一个列表中，确保所有浮点数都四舍五入到六位小数。\n然后，所有测试用例的结果被聚合到一个最终列表中，并以要求的格式打印出来。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the trajectory analysis problem for all test cases.\n    It computes naive and corrected RMSD and mean RMSF, and performs validation checks\n    for unit inconsistencies.\n    \"\"\"\n\n    def calculate_rmsd(coords_final, coords_ref):\n        \"\"\"Calculates RMSD between two sets of atomic coordinates.\"\"\"\n        if coords_final.shape[0] == 0:\n            return 0.0\n        diffs = coords_final - coords_ref\n        squared_dists = np.sum(diffs**2, axis=1)\n        msd = np.mean(squared_dists)\n        return np.sqrt(msd)\n\n    def calculate_mean_rmsf(trajectory):\n        \"\"\"Calculates mean RMSF across all atoms in a trajectory.\"\"\"\n        num_frames, num_atoms, _ = trajectory.shape\n        if num_atoms == 0 or num_frames = 1:\n            return 0.0\n        \n        mean_coords = np.mean(trajectory, axis=0) # Shape (num_atoms, 3)\n        # Expand dims for broadcasting: trajectory - mean_coords\n        diffs = trajectory - mean_coords[np.newaxis, :, :] # Shape (F, N, 3)\n        squared_flucts = np.sum(diffs**2, axis=2) # Shape (F, N)\n        msf_per_atom = np.mean(squared_flucts, axis=0) # Shape (N)\n        rmsf_per_atom = np.sqrt(msf_per_atom)\n        mean_rmsf = np.mean(rmsf_per_atom)\n        return mean_rmsf\n\n    def run_validation(trajectory, units):\n        \"\"\"Performs metadata and magnitude continuity checks.\"\"\"\n        # 1. Metadata consistency check\n        metadata_inconsistent = len(set(units)) > 1\n\n        # 2. Magnitude continuity check\n        magnitude_inconsistent = False\n        num_frames = trajectory.shape[0]\n        if num_frames > 1:\n            magnitudes = []\n            for frame_coords in trajectory:\n                # Euclidean norms for all atoms in the frame\n                norms = np.linalg.norm(frame_coords, axis=1)\n                magnitudes.append(np.median(norms))\n            \n            for i in range(num_frames - 1):\n                m1, m2 = magnitudes[i], magnitudes[i+1]\n                if m1 == 0:  # Avoid division by zero; if m1 is 0, ratio is inf unless m2 is also 0.\n                    if m2 > 0:\n                        magnitude_inconsistent = True\n                        break\n                    else: # 0/0 -> ratio is undefined, but not a large discontinuity\n                        continue\n\n                ratio = m2 / m1\n                if ratio > 3.0 or ratio  1/3.0:\n                    magnitude_inconsistent = True\n                    break\n        \n        return metadata_inconsistent or magnitude_inconsistent\n\n\n    # Base data for Test Cases 1, 2, 3\n    B = np.array([\n        [0.0, 0.0, 0.0],\n        [0.3, 0.0, 0.0],\n        [0.0, 0.4, 0.0],\n        [0.0, 0.0, 0.5]\n    ])\n    O = np.array([\n        [0.01, -0.005, 0.0],\n        [0.0, 0.008, -0.004],\n        [-0.006, 0.0, 0.007],\n        [0.005, -0.003, 0.002]\n    ])\n    \n    # Define test cases\n    test_cases = [\n        {\n            \"id\": 1,\n            \"N\": 4, \"F\": 4, \"ref_idx\": 0,\n            \"units\": [\"nm\", \"nm\", \"nm\", \"nm\"],\n            \"generator\": lambda: np.array([B + k * O for k in range(4)])\n        },\n        {\n            \"id\": 2,\n            \"N\": 4, \"F\": 4, \"ref_idx\": 0,\n            \"units\": [\"nm\", \"nm\", \"Å\", \"nm\"],\n            \"generator\": lambda: np.array([B + k * O for k in range(4)])\n        },\n        {\n            \"id\": 3,\n            \"N\": 4, \"F\": 3, \"ref_idx\": 0,\n            \"units\": [\"nm\", \"nm\", \"nm\"],\n            \"generator\": lambda: np.array([B, B, B])\n        },\n        {\n            \"id\": 4,\n            \"N\": 1, \"F\": 2, \"ref_idx\": 0,\n            \"units\": [\"Å\", \"Å\"],\n            \"generator\": lambda: np.array([[[1.0, 0.0, 0.0]], [[3.0, 0.0, 0.0]]])\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        F = case[\"F\"]\n        ref_idx = case[\"ref_idx\"]\n        units = case[\"units\"]\n\n        # 1. Generate naive trajectory\n        naive_trajectory = case[\"generator\"]()\n        # Special handling for case 2 unit mismatch simulation\n        if case[\"id\"] == 2:\n            naive_trajectory[2] *= 10.0\n\n        # 2. Generate corrected trajectory\n        corrected_trajectory = np.copy(naive_trajectory)\n        for i in range(F):\n            if units[i] == \"Å\":\n                corrected_trajectory[i] *= 0.1\n\n        # 3. Perform calculations\n        # Naive calculations\n        naive_rmsd = calculate_rmsd(naive_trajectory[-1], naive_trajectory[ref_idx])\n        naive_mean_rmsf = calculate_mean_rmsf(naive_trajectory)\n\n        # Corrected calculations\n        corrected_rmsd = calculate_rmsd(corrected_trajectory[-1], corrected_trajectory[ref_idx])\n        corrected_mean_rmsf = calculate_mean_rmsf(corrected_trajectory)\n\n        # 4. Perform validation\n        validation_flag = run_validation(naive_trajectory, units)\n\n        # 5. Store results\n        all_results.append([\n            f\"{naive_rmsd:.6f}\",\n            f\"{naive_mean_rmsf:.6f}\",\n            f\"{corrected_rmsd:.6f}\",\n            f\"{corrected_mean_rmsf:.6f}\",\n            str(validation_flag)\n        ])\n    \n    # Final print statement in the exact required format.\n    # e.g., [[val,val,val,val,Bool],[...]]\n    output_str = \"[\" + \",\".join([f\"[{','.join(res)}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "大多数分子动力学模拟都使用周期性边界条件（PBC），当分子穿过模拟盒子边界时，这会造成分子结构的“断裂”假象。本练习旨在解决这一高级挑战，要求您实现一个算法来“解包”轨迹，以恢复分子的物理连续性。随后，您将比较基于原始包裹坐标和正确解包坐标计算出的RMSD和RMSF值，从而深刻理解为何对于有意义的分析而言，这一步骤是绝对必要的。",
            "id": "3868658",
            "problem": "给定一个计算化学生物学中的场景，其中分子动力学轨迹在周期性边界条件下被记录。模拟系统是一个三维正交周期性盒子，记录的坐标被“包裹”到晶胞的主镜像中。您必须从第一性原理出发，解释为什么在对齐坐标并计算均方根偏差 (RMSD) 和均方根涨落 (RMSF) 之前，周期性边界条件需要进行解缠绕或镜像校正，然后实现一个稳健的解缠绕算法。最后，您必须为一个小的包裹轨迹测试套件计算 RMSD 和 RMSF，并展示解缠绕的效果。\n\n从以下基本概念开始：\n- 周期性盒子是由边长 $\\mathbf{L} = (L_x, L_y, L_z)$（单位为纳米）定义的晶格；坐标遵循模 $\\mathbf{L}$ 等价，即对于整数 $n_x, n_y, n_z$，两个位置 $\\mathbf{r}$ 和 $\\mathbf{r} + n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}$ 在周期性意义上表示同一个物理点。\n- 三维欧几里得距离定义为 $\\|\\mathbf{a} - \\mathbf{b}\\| = \\sqrt{(a_x - b_x)^2 + (a_y - b_y)^2 + (a_z - b_z)^2}$。\n- 两组点之间的最佳拟合刚性对齐（旋转和平移）是在变换是特殊正交群 $\\mathrm{SO}(3)$ 中的旋转并随后进行平移的约束下，最小化相应点之间欧几里得距离的平方和。\n- 具有 $N$ 个原子的两种构象之间的均方根偏差 (RMSD) 是在最佳对齐后，相应原子之间距离平方的平均值的平方根。\n- 一个原子在一条轨迹上的均方根涨落 (RMSF) 是该原子与其时间平均位置（在通过对齐移除全局旋转和平移后）之间距离平方的平均值的平方根。\n\n您的任务：\n1. 从上述基本概念出发，解释为什么在 RMSD 和 RMSF 计算之前若不应用解缠绕或镜像校正，周期性边界条件下的包裹坐标会导致错误的距离和对齐偏差。\n2. 提出并实现一个能够逐帧稳健地解缠绕坐标的算法，同时保持连续性和内部分子几何构型。该算法必须使用连通性（原子间的成键图）来在整个分子中传播镜像校正，并使用最小镜像约定来选择最近的周期性镜像以保证连续性。\n3. 使用通过最小化距离平方和得出的最佳刚性旋转和平移，将每个轨迹帧与第一帧对齐，并计算：\n   - 相对于参考帧 $t = 0$ 的、在所有帧 $t = 1,\\dots,T-1$ 上的平均 RMSD。\n   - 在所有帧 $t = 0,\\dots,T-1$ 的对齐坐标上计算出的、在所有原子上的平均 RMSF。\n4. 分别使用原始包裹坐标（不解缠绕）和您解缠绕后的坐标执行上述计算。报告每个测试用例的两组结果。\n\n物理单位：\n- 所有坐标和盒子长度均以纳米为单位。RMSD 和 RMSF 必须以浮点数形式报告，单位为纳米。\n\n角度单位：\n- 您用于合成振动的任何周期性调制必须在三角函数中使用弧度。\n\n测试套件：\n实现您的程序，使其使用以下三个合成轨迹的测试用例。每个测试用例定义了原子数 $N$、帧数 $T$、盒子长度 $\\mathbf{L}$、原子索引 $i$ 的初始构型 $\\mathbf{r}_i(0)$、每帧的恒定漂移 $\\mathbf{d}$，以及每帧的微小振动 $\\boldsymbol{\\epsilon}_{i}(t)$。解缠绕后的坐标定义为\n$$\n\\mathbf{r}_i(t) = \\mathbf{r}_i(0) + t\\,\\mathbf{d} + \\boldsymbol{\\epsilon}_{i}(t),\n$$\n而记录的包裹坐标为\n$$\n\\mathbf{w}_i(t) = \\mathbf{r}_i(t) \\bmod \\mathbf{L},\n$$\n其中模运算是逐分量应用的，以将位置映射到每个轴 $\\alpha \\in \\{x,y,z\\}$ 的区间 $[0,L_\\alpha)$ 内。\n\n每帧的振动定义为\n$$\n\\boldsymbol{\\epsilon}_{i}(t) = \\left(0,\\; 0.01 \\sin\\left(\\frac{2\\pi t}{T} + i\\right),\\; 0.005 \\cos\\left(\\frac{2\\pi t}{T} + \\frac{i}{2}\\right)\\right),\n$$\n所有量纲的单位为纳米和弧度。\n\n对于每个测试，以形成链的无向边列表形式提供成键连通性。\n\n- 测试用例 A (跨越x边界的常规路径漂移):\n  - $N = 3$, $T = 6$, $\\mathbf{L} = (3.0, 3.0, 3.0)$。\n  - 初始位置: $\\mathbf{r}_0(0) = (0.40, 0.40, 0.20)$, $\\mathbf{r}_1(0) = (0.52, 0.40, 0.20)$, $\\mathbf{r}_2(0) = (0.64, 0.40, 0.20)$。\n  - 每帧漂移: $\\mathbf{d} = (0.80, 0.00, 0.00)$。\n  - 连通性: 边 $(0,1)$, $(1,2)$。\n\n- 测试用例 B (伴有轻微内部振动的跨y边界漂移):\n  - $N = 5$, $T = 8$, $\\mathbf{L} = (2.5, 2.5, 2.5)$。\n  - 初始位置: $\\mathbf{r}_0(0) = (0.30, 1.80, 0.30)$, $\\mathbf{r}_1(0) = (0.30, 1.90, 0.30)$, $\\mathbf{r}_2(0) = (0.30, 2.00, 0.30)$, $\\mathbf{r}_3(0) = (0.30, 2.10, 0.30)$, $\\mathbf{r}_4(0) = (0.30, 2.20, 0.30)$。\n  - 每帧漂移: $\\mathbf{d} = (0.00, -0.60, 0.00)$。\n  - 连通性: 边 $(0,1)$, $(1,2)$, $(2,3)$, $(3,4)$。\n\n- 测试用例 C (在x方向上接近半盒子长度的跳跃以探测舍入稳健性):\n  - $N = 4$, $T = 7$, $\\mathbf{L} = (3.0, 3.0, 3.0)$。\n  - 初始位置: $\\mathbf{r}_0(0) = (0.10, 0.50, 0.10)$, $\\mathbf{r}_1(0) = (0.23, 0.50, 0.10)$, $\\mathbf{r}_2(0) = (0.36, 0.50, 0.10)$, $\\mathbf{r}_3(0) = (0.49, 0.50, 0.10)$。\n  - 每帧漂移: $\\mathbf{d} = (1.49, 0.00, 0.00)$。\n  - 连通性: 边 $(0,1)$, $(1,2)$, $(2,3)$。\n\n要求计算：\n- 对每个测试用例，计算四个单位为纳米的浮点数：\n  1. 使用包裹坐标计算的平均RMSD，与包裹后的第 $t=0$ 帧对齐。\n  2. 使用解缠绕坐标计算的平均RMSD，与解缠绕后的第 $t=0$ 帧对齐。\n  3. 使用包裹坐标在对齐后计算的平均RMSF（在原子间平均）。\n  4. 使用解缠绕坐标在对齐后计算的平均RMSF（在原子间平均）。\n\n输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的结果，格式为方括号括起来的逗号分隔列表；每个内部列表必须按照上面指定的四个浮点数的顺序排列。例如：“[[a,b,c,d],[e,f,g,h],[i,j,k,l]]”。所有值都必须是单位为纳米的浮点数。\n\n无外部输入：\n- 您的程序必须是自包含的，按规定生成测试用例，并完全按照描述打印结果行，不得包含任何额外文本。对齐必须通过在 $\\mathrm{SO}(3)$ 中的旋转和平移下最小化距离平方和来执行，解缠绕必须使用连通性和最小镜像约定来强制实现连续性和内部几何构型。",
            "solution": "所提出的问题是有效的，其科学基础根植于计算生物物理学的原理，并且问题陈述清晰，提供了足够的信息以获得唯一解。我们将进行详细的、分步的解析。\n\n这个问题的核心在于，像均方根偏差（RMSD）和均方根涨落（RMSF）这类结构比较度量的数学形式主义（其假设对象在欧几里得空间中是连续的）与模拟中周期性边界条件（PBC）的计算便利性（其将坐标“包裹”到主盒子中，从而破坏了这种连续性）之间存在脱节。\n\n### 1. 为何RMSD和RMSF计算需要解缠绕\n\n让我们从基本定义开始。RMSD和RMSF分别是结构相似性和原子迁移率的度量。两者都根本上依赖于原子位置之间的欧几里得距离 $\\|\\mathbf{a} - \\mathbf{b}\\|$。\n\n两种构象A和B（各有N个原子）之间的RMSD是在找到一个最佳刚体变换（旋转 $R \\in \\mathrm{SO}(3)$ 和平移 $\\mathbf{v}$）以最小化相应原子之间距离的平方和之后计算的。RMSD则为：\n$$\n\\text{RMSD}(A, B) = \\min_{R, \\mathbf{v}} \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\| (R\\mathbf{r}_{i,A} + \\mathbf{v}) - \\mathbf{r}_{i,B} \\|^2}\n$$\n原子 $i$ 在一条包含 $T$ 帧的轨迹上的RMSF是其均方根位移的平方根，该位移是相对于其平均位置的位移，并且是在整个轨迹已对齐到一个共同参考系以消除全局平移和旋转之后计算的：\n$$\n\\text{RMSF}_i = \\sqrt{\\frac{1}{T} \\sum_{t=0}^{T-1} \\| \\mathbf{r}'_i(t) - \\langle \\mathbf{r}'_i \\rangle \\|^2}\n$$\n其中 $\\mathbf{r}'_i(t)$ 是原子 $i$ 在第 $t$ 帧中对齐后的坐标，而 $\\langle\\mathbf{r}'_i\\rangle$ 是其时间平均位置。\n\n现在，考虑一个采用边长为 $\\mathbf{L} = (L_x, L_y, L_z)$ 的周期性盒子的分子动力学模拟。当一个原子穿过边界时，其坐标会被“包裹”回主盒子中，通常在每个轴 $\\alpha \\in \\{x, y, z\\}$ 的 $[0, L_\\alpha)$ 范围内。例如，一个从 $x=L_x - \\delta$ 移动到 $x=L_x + \\delta$（其中 $\\delta$ 很小）的原子，其记录的坐标将从 $L_x - \\delta$ 跳跃到 $\\delta$。\n\n如果不进行校正，这种包裹过程对RMSD和RMSF计算会产生两个灾难性的后果：\n\n1.  **扭曲内部分子几何**：考虑两个成键原子 $i$ 和 $j$，它们之间键长很短。如果分子漂移，使得原子 $i$ 在 $x_i \\approx 0$ 处，而原子 $j$ 已经穿过边界到达 $x_j \\approx L_x$，它们的真实距离很小。然而，根据它们的包裹坐标计算的朴素欧几里得距离 $\\|\\mathbf{w}_i - \\mathbf{w}_j\\|$ 将会很大，接近 $L_x$。这种人为因素破坏了分子的表观结构。旨在最小化这些距离平方和的对齐算法，将会面对一个看起来怪诞扭曲的结构。它将无法找到有意义的叠加，导致一个异常巨大且不正确的RMSD值，这个值反映的是盒子的大小属性，而不是真实的构象变化。\n\n2.  **破坏时间平均值**：对于RMSF，一个原子随时间变化的坐标会被平均。如果一个原子的真实轨迹是连续的但穿过了边界，其包裹坐标将表现出巨大的、瞬时的跳跃（例如，从 $L_y-\\delta$ 到 $\\delta$）。这些跳跃坐标的平均值 $\\langle \\mathbf{w}_i \\rangle$ 将不代表一个有物理意义的中心位置。相反，它将被偏向盒子的中心。因此，计算出的 $\\mathbf{w}_i(t)$ 围绕这个错误平均值的涨落 $\\|\\mathbf{w}_i(t) - \\langle \\mathbf{w}_i \\rangle\\|^2$ 将会巨大，并且主要由人为的包裹事件主导，而不是原子真实的物理振动。\n\n因此，在进行任何对齐、RMSD或RMSF分析之前，绝对有必要对轨迹进行“解缠绕”，或者至少应用镜像校正，以恢复分子在欧几里得空间中物理上连续的表示。\n\n### 2. 一种坐标解缠绕算法\n\n一个稳健的解缠绕算法必须实现两个目标：（1）保持分子结构的内部分子几何完整性，以及（2）保持分子整体运动的时间连续性。以下算法利用分子的成键连通性和最小镜像约定（MIC）来实现这一点。\n\n最小镜像约定（MIC）指出，在边长为 $\\mathbf{L}$ 的周期性盒子中，两点 $\\mathbf{a}$ 和 $\\mathbf{b}$ 之间的真实向量是连接 $\\mathbf{a}$ 和 $\\mathbf{b}$ 最近周期性镜像的那个向量。这个向量 $\\Delta\\mathbf{r}_{\\text{mic}}$ 计算如下：\n$$\n\\Delta\\mathbf{r}_{\\text{mic}}(\\mathbf{a}, \\mathbf{b}) = (\\mathbf{a} - \\mathbf{b}) - \\mathbf{L} \\odot \\text{round}\\left(\\frac{\\mathbf{a} - \\mathbf{b}}{\\mathbf{L}}\\right)\n$$\n其中 $\\odot$ 表示逐分量乘法，除法和舍入也是逐分量进行的。\n\n解缠绕逐帧进行，使用前一帧已解缠绕的坐标作为当前帧的参考。设 $\\mathbf{W}(t)$ 为包裹轨迹，$\\mathbf{R}(t)$ 为待构建的解缠绕轨迹。\n\n**算法：逐帧解缠绕**\n1.  **初始化**：第一帧无需解缠绕。对所有原子 $i=0, \\dots, N-1$，设置 $\\mathbf{R}_i(0) = \\mathbf{W}_i(0)$。\n2.  **迭代**：对后续的每一帧 $t=1, \\dots, T-1$：\n    a.  设 $\\mathbf{R}_{\\text{prev}}$ 为第 $t-1$ 帧的解缠绕坐标，$\\mathbf{W}_{\\text{curr}}$ 为第 $t$ 帧的包裹坐标。\n    b.  **种子原子的连续性**：选择一个“种子”原子（例如，原子0）。其在新帧中的解缠绕位置是通过假设其从前一帧的运动是连续的来确定的。我们计算其位移向量的最小镜像：\n        -   包裹空间中的位移：$\\Delta\\mathbf{w}_0 = \\mathbf{W}_0(t) - \\mathbf{R}_0(t-1)$。\n        -   最小镜像位移：$\\Delta\\mathbf{r}'_0 = \\Delta\\mathbf{w}_0 - \\mathbf{L} \\odot \\text{round}(\\Delta\\mathbf{w}_0 / \\mathbf{L})$。\n        -   设置种子原子新的解缠绕位置：$\\mathbf{R}_0(t) = \\mathbf{R}_0(t-1) + \\Delta\\mathbf{r}'_0$。\n    c.  **通过连通性传播**：围绕新放置的种子原子重建分子的其余部分。这通过遍历成键连通性图来完成（例如，使用从种子原子开始的广度优先搜索或深度优先搜索）。\n        -   用种子原子初始化一个遍历队列和一个已访问原子集合。\n        -   当队列不为空时，出队一个位置 $\\mathbf{R}_i(t)$ 已知的原子 $i$。\n        -   对于原子 $i$ 的每个尚未访问的成键邻居 $j$：\n            i.  计算在当前包裹帧中 $j$ 和 $i$ 之间的向量：$\\Delta\\mathbf{w}_{ji} = \\mathbf{W}_j(t) - \\mathbf{W}_i(t)$。\n            ii. 应用MIC找到正确的键向量，连接到原子 $j$ 的最近镜像：$\\Delta\\mathbf{r}'_{ji} = \\Delta\\mathbf{w}_{ji} - \\mathbf{L} \\odot \\text{round}(\\Delta\\mathbf{w}_{ji} / \\mathbf{L})$。\n            iii. 设置原子 $j$ 的解缠绕位置：$\\mathbf{R}_j(t) = \\mathbf{R}_i(t) + \\Delta\\mathbf{r}'_{ji}$。\n            iv. 将 $j$ 标记为已访问并将其加入队列。\n3.  得到的坐标序列 $\\mathbf{R}(t)$ 构成了完全解缠绕的轨迹，它代表了在无限欧几里得空间中的一条连续路径，并保留了所有内部共价几何结构。\n\n### 3. 对齐与分析流程\n\n有了一条有效的（解缠绕的）轨迹，我们就可以进行分析了。\n\n**对齐**：最佳刚体旋转是通过Kabsch算法找到的，该算法基于奇异值分解（SVD）。要将一个“活动”坐标集A对齐到一个“参考”坐标集B：\n1.  将两组坐标都平移到它们各自的质心：$A' = A - \\mathbf{c}_A$ 和 $B' = B - \\mathbf{c}_B$。\n2.  计算 $3 \\times 3$ 协方差矩阵 $H = (A')^T B'$。\n3.  对 $H$ 进行SVD分解：$H = U S V^T$。\n4.  最佳旋转矩阵是 $R = V U^T$。必须进行检查以确保 $R$ 是一个正常旋转（$\\det(R)=+1$）而不是一个反射。如果 $\\det(R)=-1$，则在重新计算 $R$ 之前，将 $V$ 中与最小奇异值对应的列的符号翻转。\n5.  然后旋转活动坐标：$A'' = A' R$。\n\n**RMSD计算**：\n- 对于每一帧 $t \\in \\{1, \\dots, T-1\\}$，坐标 $\\mathbf{X}(t)$ 被对齐到参考帧 $\\mathbf{X}(0)$。\n- 计算中心化后的坐标：$\\mathbf{X}'(t) = \\mathbf{X}(t) - \\mathbf{c}(t)$ 和 $\\mathbf{X}'(0) = \\mathbf{X}(0) - \\mathbf{c}(0)$。\n- 通过Kabsch算法找到旋转矩阵 $R_t$。\n- 该帧的RMSD为 $\\text{RMSD}(t) = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\| (\\mathbf{X}'(t)R_t)_i - \\mathbf{X}'_i(0) \\|^2}$。\n- 最终报告的值是这些值的平均值：$\\langle \\text{RMSD} \\rangle = \\frac{1}{T-1}\\sum_{t=1}^{T-1}\\text{RMSD}(t)$。\n\n**RMSF计算**：\n- 整条轨迹 $\\mathbf{X}(0), \\dots, \\mathbf{X}(T-1)$ 被对齐到单个参考帧 $\\mathbf{X}(0)$。这会产生一条对齐结构的轨迹 $\\mathbf{X}''(0), \\dots, \\mathbf{X}''(T-1)$，其中每一帧都已中心化并最佳旋转。\n- 对于每个原子 $i$，从这条对齐的轨迹计算其时间平均位置：$\\langle \\mathbf{x}''_i \\rangle = \\frac{1}{T}\\sum_{t=0}^{T-1} \\mathbf{x}''_i(t)$。\n- 原子 $i$ 的RMSF则为 $\\text{RMSF}_i = \\sqrt{\\frac{1}{T}\\sum_{t=0}^{T-1} \\| \\mathbf{x}''_i(t) - \\langle \\mathbf{x}''_i \\rangle \\|^2}$。\n- 最终报告的值是所有原子的平均RMSF：$\\langle \\text{RMSF} \\rangle = \\frac{1}{N}\\sum_{i=0}^{N-1}\\text{RMSF}_i$。\n\n该实现将为每个测试用例执行两次这些计算：一次使用原始的、包裹的坐标，一次使用我们的解缠绕算法生成的坐标。正如假设的那样，结果将显示出巨大的差异，突显了解缠绕步骤的至关重要性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 3, \"T\": 6, \"L\": np.array([3.0, 3.0, 3.0]),\n            \"r0\": np.array([\n                [0.40, 0.40, 0.20],\n                [0.52, 0.40, 0.20],\n                [0.64, 0.40, 0.20]\n            ]),\n            \"d\": np.array([0.80, 0.00, 0.00]),\n            \"connectivity\": [(0, 1), (1, 2)],\n        },\n        {\n            \"N\": 5, \"T\": 8, \"L\": np.array([2.5, 2.5, 2.5]),\n            \"r0\": np.array([\n                [0.30, 1.80, 0.30],\n                [0.30, 1.90, 0.30],\n                [0.30, 2.00, 0.30],\n                [0.30, 2.10, 0.30],\n                [0.30, 2.20, 0.30]\n            ]),\n            \"d\": np.array([0.00, -0.60, 0.00]),\n            \"connectivity\": [(0, 1), (1, 2), (2, 3), (3, 4)],\n        },\n        {\n            \"N\": 4, \"T\": 7, \"L\": np.array([3.0, 3.0, 3.0]),\n            \"r0\": np.array([\n                [0.10, 0.50, 0.10],\n                [0.23, 0.50, 0.10],\n                [0.36, 0.50, 0.10],\n                [0.49, 0.50, 0.10]\n            ]),\n            \"d\": np.array([1.49, 0.00, 0.00]),\n            \"connectivity\": [(0, 1), (1, 2), (2, 3)],\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, T, L, r0, d, conn_edges = case[\"N\"], case[\"T\"], case[\"L\"], case[\"r0\"], case[\"d\"], case[\"connectivity\"]\n\n        # 1. Generate trajectories\n        unwrapped_traj = np.zeros((T, N, 3))\n        wrapped_traj = np.zeros((T, N, 3))\n        \n        t_vals = np.arange(T)[:, np.newaxis]\n        i_vals = np.arange(N)[np.newaxis, :]\n        \n        eps_y = 0.01 * np.sin(2 * np.pi * t_vals / T + i_vals)\n        eps_z = 0.005 * np.cos(2 * np.pi * t_vals / T + i_vals / 2)\n        epsilon = np.stack([np.zeros((T, N)), eps_y, eps_z], axis=2)\n\n        unwrapped_traj = r0[np.newaxis, :, :] + t_vals[:, :, np.newaxis] * d[np.newaxis, np.newaxis, :] + epsilon\n        wrapped_traj = unwrapped_traj % L\n\n        # 2. Re-create unwrapped trajectory from wrapped one to test the algorithm\n        re_unwrapped_traj = unwrap_trajectory(wrapped_traj, L, conn_edges)\n\n        # 3. Analyze trajectories\n        mean_rmsd_w, mean_rmsf_w = analyze_trajectory(wrapped_traj)\n        mean_rmsd_u, mean_rmsf_u = analyze_trajectory(re_unwrapped_traj)\n\n        all_results.append([mean_rmsd_w, mean_rmsd_u, mean_rmsf_w, mean_rmsf_u])\n\n    # Final print statement in the exact required format.\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(inner_strings)}]\")\n\ndef kabsch_align(mobile_coords, ref_coords):\n    \"\"\"\n    Aligns mobile_coords to ref_coords using the Kabsch algorithm and returns the\n    rotated (but not translated) mobile coordinates.\n    \"\"\"\n    # Center coordinates\n    mobile_centroid = np.mean(mobile_coords, axis=0)\n    ref_centroid = np.mean(ref_coords, axis=0)\n    mobile_c = mobile_coords - mobile_centroid\n    ref_c = ref_coords - ref_centroid\n\n    # Covariance matrix\n    H = mobile_c.T @ ref_c\n\n    # SVD\n    U, S, Vt = np.linalg.svd(H)\n    V = Vt.T\n\n    # Calculate rotation matrix, checking for reflection\n    R = V @ U.T\n    if np.linalg.det(R)  0:\n        V[:, -1] *= -1\n        R = V @ U.T\n    \n    # Apply rotation\n    aligned_mobile_c = mobile_c @ R\n    \n    return aligned_mobile_c, ref_c\n\n\ndef analyze_trajectory(traj):\n    \"\"\"\n    Computes mean RMSD and mean RMSF for a given trajectory.\n    \"\"\"\n    T, N, _ = traj.shape\n    ref_frame = traj[0]\n\n    # Mean RMSD calculation (over frames t=1...T-1)\n    rmsd_values = []\n    if T > 1:\n        for t in range(1, T):\n            mobile_frame = traj[t]\n            aligned_mobile_c, ref_c = kabsch_align(mobile_frame, ref_frame)\n            \n            # Sum of squared distances\n            ssd = np.sum((aligned_mobile_c - ref_c)**2)\n            rmsd = np.sqrt(ssd / N)\n            rmsd_values.append(rmsd)\n        mean_rmsd = np.mean(rmsd_values) if rmsd_values else 0.0\n    else:\n        mean_rmsd = 0.0\n\n    # Mean RMSF calculation (over all atoms)\n    aligned_traj_c = np.zeros_like(traj)\n    _, ref_c_for_all = kabsch_align(ref_frame, ref_frame)\n    aligned_traj_c[0] = ref_c_for_all\n    \n    for t in range(1, T):\n        aligned_mobile_c, _ = kabsch_align(traj[t], ref_frame)\n        aligned_traj_c[t] = aligned_mobile_c\n        \n    avg_pos = np.mean(aligned_traj_c, axis=0)\n    sq_displacements = np.sum((aligned_traj_c - avg_pos)**2, axis=2) # Sum over x,y,z\n    msd_per_atom = np.mean(sq_displacements, axis=0) # Average over time\n    rmsf_values = np.sqrt(msd_per_atom)\n    mean_rmsf = np.mean(rmsf_values)\n\n    return mean_rmsd, mean_rmsf\n\n\ndef unwrap_trajectory(wrapped_traj, L, connectivity_edges):\n    \"\"\"\n    Unwraps a trajectory using connectivity and the minimum image convention.\n    \"\"\"\n    T, N, _ = wrapped_traj.shape\n    unwrapped_traj = np.zeros_like(wrapped_traj)\n    unwrapped_traj[0] = wrapped_traj[0]\n\n    # Build adjacency list for connectivity\n    adj = [[] for _ in range(N)]\n    for i, j in connectivity_edges:\n        adj[i].append(j)\n        adj[j].append(i)\n\n    for t in range(1, T):\n        prev_unwrapped = unwrapped_traj[t-1]\n        curr_wrapped = wrapped_traj[t]\n        curr_unwrapped = np.zeros_like(curr_wrapped)\n        \n        visited = [False] * N\n        q = deque()\n\n        # 1. Place seed atom (atom 0) based on temporal continuity\n        seed_atom = 0\n        delta = curr_wrapped[seed_atom] - prev_unwrapped[seed_atom]\n        shift = L * np.round(delta / L)\n        delta_mic = delta - shift\n        curr_unwrapped[seed_atom] = prev_unwrapped[seed_atom] + delta_mic\n        \n        visited[seed_atom] = True\n        q.append(seed_atom)\n\n        # 2. Propagate unwrapping through the molecule via BFS\n        while q:\n            i = q.popleft()\n            for j in adj[i]:\n                if not visited[j]:\n                    delta_ij = curr_wrapped[j] - curr_wrapped[i]\n                    shift_ij = L * np.round(delta_ij / L)\n                    delta_ij_mic = delta_ij - shift_ij\n                    curr_unwrapped[j] = curr_unwrapped[i] + delta_ij_mic\n                    \n                    visited[j] = True\n                    q.append(j)\n        \n        unwrapped_traj[t] = curr_unwrapped\n        \n    return unwrapped_traj\n\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}