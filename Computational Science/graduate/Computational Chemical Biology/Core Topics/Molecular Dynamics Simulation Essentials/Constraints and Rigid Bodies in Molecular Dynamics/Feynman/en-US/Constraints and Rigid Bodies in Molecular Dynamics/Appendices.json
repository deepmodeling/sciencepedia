{
    "hands_on_practices": [
        {
            "introduction": "Enforcing fixed bond lengths is a fundamental task in molecular dynamics, and the SHAKE algorithm is a classic and powerful method for achieving this. This practice provides a hands-on opportunity to implement this cornerstone algorithm by first deriving the position correction formulas from the principles of Lagrangian mechanics. By translating the derived equations into code, you will gain a deep, practical understanding of how iterative constraints are applied in simulations .",
            "id": "3840876",
            "problem": "Consider a two-atom holonomic constraint within Molecular Dynamics (MD), where a single bond-length constraint between atoms labeled $i$ and $j$ is enforced. Let the desired bond length be $L_0$ in nanometers (nm), the current positions after an unconstrained integration step be $\\mathbf{r}_i$ and $\\mathbf{r}_j$ in nanometers (nm), and the atom masses be $m_i$ and $m_j$ in daltons (Da). The holonomic constraint can be written as $g(\\mathbf{r}) = \\|\\mathbf{r}_j - \\mathbf{r}_i\\|^2 - L_0^2 = 0$. Assume a single iteration of the iterative constraint algorithm commonly known as SHAKE is applied, using a first-order linearization of the constraint about the current positions and mass-weighted corrections along the bond direction.\n\nStarting from first principles appropriate for constrained dynamics, derive the mass-weighted position corrections $\\delta \\mathbf{r}_i$ and $\\delta \\mathbf{r}_j$ along the instantaneous bond direction for a single SHAKE iteration that attempts to satisfy the linearized constraint to first order. Your derivation must begin from Newton’s Second Law and the method of Lagrange multipliers applied to holonomic constraints. Do not use any pre-given shortcut formulas; justify each step using only fundamental laws and core definitions.\n\nImplement a complete, runnable program that:\n- Computes a single SHAKE iteration position correction $(\\delta \\mathbf{r}_i, \\delta \\mathbf{r}_j)$ for each test case.\n- Uses a numerical safeguard: if $\\|\\mathbf{r}_j - \\mathbf{r}_i\\|^2 \\le \\tau$, where $\\tau$ is a small threshold, then return zero corrections. Use $\\tau = 1\\times 10^{-12}$ in square nanometers (nm$^2$).\n- Returns the corrections in nanometers (nm).\n\nYour program must evaluate the following test suite, each expressed in nanometers (nm) for positions and bond lengths, and daltons (Da) for masses:\n- Test case 1 (happy path): $\\mathbf{r}_i = (0.0, 0.0, 0.0)$, $\\mathbf{r}_j = (0.1, 0.0, 0.0)$, $L_0 = 0.12$, $m_i = 12.0$, $m_j = 1.0$.\n- Test case 2 (near-degenerate bond vector): $\\mathbf{r}_i = (0.0, 0.0, 0.0)$, $\\mathbf{r}_j = (1\\times 10^{-6}, 0.0, 0.0)$, $L_0 = 0.10$, $m_i = 16.0$, $m_j = 16.0$.\n- Test case 3 (balanced masses, off-axis bond): $\\mathbf{r}_i = (0.0, 0.0, 0.0)$, $\\mathbf{r}_j = (0.15, 0.15, 0.0)$, $L_0 = 0.21$, $m_i = 12.0$, $m_j = 12.0$.\n- Test case 4 (high mass ratio): $\\mathbf{r}_i = (0.2, -0.1, 0.05)$, $\\mathbf{r}_j = (0.25, -0.15, 0.05)$, $L_0 = 0.08$, $m_i = 200.0$, $m_j = 2.0$.\n- Test case 5 (already satisfied constraint): $\\mathbf{r}_i = (0.0, 0.0, 0.0)$, $\\mathbf{r}_j = (0.12, 0.0, 0.0)$, $L_0 = 0.12$, $m_i = 12.0$, $m_j = 1.0$.\n\nAngle units are not required for this problem. All outputs must be expressed in nanometers (nm). For each test case, output the six floating-point values corresponding to the concatenated correction vector $[\\delta r_{i,x}, \\delta r_{i,y}, \\delta r_{i,z}, \\delta r_{j,x}, \\delta r_{j,y}, \\delta r_{j,z}]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of six floats as specified (for example, \"[[...six floats...],[...six floats...],...]\").",
            "solution": "The problem is valid as it is scientifically grounded in classical mechanics, well-posed, objective, and contains a complete and consistent setup. It describes a standard procedure in computational chemical biology, the SHAKE algorithm, and requests a derivation from first principles followed by a concrete implementation.\n\n### Derivation of the SHAKE Correction\n\nWe begin from the Lagrangian formulation for a constrained mechanical system. The equations of motion for a set of particles with coordinates $\\{\\mathbf{r}_k\\}$ and masses $\\{m_k\\}$, subject to a set of holonomic constraints $\\{g_\\alpha(\\mathbf{r}) = 0\\}$, are given by the Lagrange equations of the first kind:\n$$\nm_k \\ddot{\\mathbf{r}}_k = \\mathbf{F}_k - \\sum_\\alpha \\lambda_\\alpha \\nabla_k g_\\alpha(\\mathbf{r})\n$$\nwhere $\\mathbf{F}_k$ is the unconstrained force on particle $k$ (e.g., from a potential energy function), $\\lambda_\\alpha$ is the Lagrange multiplier associated with constraint $g_\\alpha$, and $\\nabla_k$ denotes the gradient with respect to the coordinates $\\mathbf{r}_k$. The term $-\\sum_\\alpha \\lambda_\\alpha \\nabla_k g_\\alpha$ is the total constraint force $\\mathbf{F}'_k$ acting on particle $k$.\n\nIn molecular dynamics simulations using algorithms like Verlet, the position at time $t+\\Delta t$ is computed from positions at previous times. Let $\\mathbf{r}'_k$ denote the position of particle $k$ at time $t+\\Delta t$ after an unconstrained integration step. These positions, in general, do not satisfy the constraints. The SHAKE algorithm computes a correction $\\delta \\mathbf{r}_k$ for each atom such that the new, corrected positions $\\mathbf{r}^{corr}_k = \\mathbf{r}'_k + \\delta \\mathbf{r}_k$ do satisfy the constraints. The correction $\\delta \\mathbf{r}_k$ is assumed to arise from the constraint forces integrated over the time step, which has the form:\n$$\n\\delta \\mathbf{r}_k = \\frac{(\\Delta t)^2}{m_k} \\mathbf{F}'_k\n$$\nFor a single constraint $g(\\mathbf{r})=0$, the constraint force is $\\mathbf{F}'_k = -\\lambda\\nabla_k g(\\mathbf{r})$. The formulation can be simplified by absorbing the constants and $\\Delta t$ into a new multiplier, which we will continue to call $\\lambda$ for simplicity. This leads to the standard ansatz for the correction:\n$$\n\\delta \\mathbf{r}_k = \\lambda \\frac{1}{m_k} \\nabla_k g(\\mathbf{r})\n$$\nThe problem specifies a single bond-length constraint between atoms $i$ and $j$, defined as:\n$$\ng(\\mathbf{r}_i, \\mathbf{r}_j) = \\|\\mathbf{r}_j - \\mathbf{r}_i\\|^2 - L_0^2 = 0\n$$\nwhere $L_0$ is the desired bond length. We evaluate the gradients with respect to the unconstrained positions, which we denote as $\\mathbf{r}_i$ and $\\mathbf{r}_j$ to match the problem's notation. Let the vector connecting the atoms be $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$. The gradients are:\n$$\n\\nabla_i g = \\frac{\\partial}{\\partial \\mathbf{r}_i}[(\\mathbf{r}_j - \\mathbf{r}_i) \\cdot (\\mathbf{r}_j - \\mathbf{r}_i) - L_0^2] = 2(\\mathbf{r}_j - \\mathbf{r}_i) \\cdot (-I) = -2\\mathbf{r}_{ij}\n$$\n$$\n\\nabla_j g = \\frac{\\partial}{\\partial \\mathbf{r}_j}[(\\mathbf{r}_j - \\mathbf{r}_i) \\cdot (\\mathbf{r}_j - \\mathbf{r}_i) - L_0^2] = 2(\\mathbf{r}_j - \\mathbf{r}_i) \\cdot (I) = 2\\mathbf{r}_{ij}\n$$\nThe position corrections are thus:\n$$\n\\delta \\mathbf{r}_i = \\lambda \\frac{1}{m_i} \\nabla_i g = -2\\lambda \\frac{1}{m_i} \\mathbf{r}_{ij}\n$$\n$$\n\\delta \\mathbf{r}_j = \\lambda \\frac{1}{m_j} \\nabla_j g = 2\\lambda \\frac{1}{m_j} \\mathbf{r}_{ij}\n$$\nThe unknown Lagrange multiplier $\\lambda$ is determined by requiring the corrected positions, $\\mathbf{r}^{corr}_i = \\mathbf{r}_i + \\delta\\mathbf{r}_i$ and $\\mathbf{r}^{corr}_j = \\mathbf{r}_j + \\delta\\mathbf{r}_j$, to satisfy the constraint. The SHAKE algorithm linearizes this requirement. The constraint function evaluated at the corrected positions is expanded to first order around the unconstrained positions:\n$$\ng(\\mathbf{r}^{corr}) \\approx g(\\mathbf{r}) + (\\delta\\mathbf{r}_i \\cdot \\nabla_i g + \\delta\\mathbf{r}_j \\cdot \\nabla_j g) = 0\n$$\nSubstituting the expressions for the gradients and corrections:\n$$\ng(\\mathbf{r}) + \\left( (-2\\lambda \\frac{1}{m_i} \\mathbf{r}_{ij}) \\cdot (-2\\mathbf{r}_{ij}) + (2\\lambda \\frac{1}{m_j} \\mathbf{r}_{ij}) \\cdot (2\\mathbf{r}_{ij}) \\right) = 0\n$$\n$$\ng(\\mathbf{r}) + \\lambda \\left( \\frac{4}{m_i} \\|\\mathbf{r}_{ij}\\|^2 + \\frac{4}{m_j} \\|\\mathbf{r}_{ij}\\|^2 \\right) = 0\n$$\n$$\ng(\\mathbf{r}) + 4\\lambda \\|\\mathbf{r}_{ij}\\|^2 \\left( \\frac{1}{m_i} + \\frac{1}{m_j} \\right) = 0\n$$\nLet $d^2 = \\|\\mathbf{r}_{ij}\\|^2$. The constraint violation at the unconstrained positions is $g(\\mathbf{r}) = d^2 - L_0^2$. We can now solve for $\\lambda$:\n$$\n\\lambda = -\\frac{g(\\mathbf{r})}{4 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} = -\\frac{d^2 - L_0^2}{4 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} = \\frac{L_0^2 - d^2}{4 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})}\n$$\nNow, substitute this expression for $\\lambda$ back into the equations for $\\delta\\mathbf{r}_i$ and $\\delta\\mathbf{r}_j$:\nFor atom $i$:\n$$\n\\delta\\mathbf{r}_i = -2 \\left( \\frac{L_0^2 - d^2}{4 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} \\right) \\frac{1}{m_i} \\mathbf{r}_{ij} = \\frac{d^2 - L_0^2}{2 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} \\frac{1}{m_i} \\mathbf{r}_{ij}\n$$\nThe term $\\frac{1}{m_i (\\frac{1}{m_i} + \\frac{1}{m_j})} = \\frac{1}{m_i (\\frac{m_j+m_i}{m_i m_j})} = \\frac{m_j}{m_i+m_j}$. Thus:\n$$\n\\delta\\mathbf{r}_i = \\frac{d^2 - L_0^2}{2 d^2} \\left( \\frac{m_j}{m_i+m_j} \\right) \\mathbf{r}_{ij}\n$$\nFor atom $j$:\n$$\n\\delta\\mathbf{r}_j = 2 \\left( \\frac{L_0^2 - d^2}{4 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} \\right) \\frac{1}{m_j} \\mathbf{r}_{ij} = -\\frac{d^2 - L_0^2}{2 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} \\frac{1}{m_j} \\mathbf{r}_{ij}\n$$\nThe term $\\frac{1}{m_j (\\frac{1}{m_i} + \\frac{1}{m_j})} = \\frac{m_i}{m_i+m_j}$. Thus:\n$$\n\\delta\\mathbf{r}_j = -\\frac{d^2 - L_0^2}{2 d^2} \\left( \\frac{m_i}{m_i+m_j} \\right) \\mathbf{r}_{ij}\n$$\nThese are the final expressions for the position corrections. They are mass-weighted (the correction for one atom is proportional to the mass of the other) and directed along the inter-atomic vector $\\mathbf{r}_{ij}$, as required. For implementation, we can define a common scalar factor to simplify computation:\n$$\nk = \\frac{d^2 - L_0^2}{2 d^2 (m_i + m_j)}\n$$\nThen the corrections become:\n$$\n\\delta\\mathbf{r}_i = k \\cdot m_j \\cdot \\mathbf{r}_{ij}\n$$\n$$\n\\delta\\mathbf{r}_j = -k \\cdot m_i \\cdot \\mathbf{r}_{ij}\n$$\nThis form is computationally efficient. A numerical safeguard is required for cases where $d^2$ is very small, to prevent division by zero or floating-point overflow. If $d^2 \\le \\tau$ for a small threshold $\\tau$, the corrections are set to zero.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a single SHAKE iteration position correction for a two-atom system.\n    \"\"\"\n    \n    # Test suite from the problem statement.\n    # Each case: (r_i (nm), r_j (nm), L0 (nm), m_i (Da), m_j (Da))\n    test_cases = [\n        (np.array([0.0, 0.0, 0.0]), np.array([0.1, 0.0, 0.0]), 0.12, 12.0, 1.0),\n        (np.array([0.0, 0.0, 0.0]), np.array([1e-6, 0.0, 0.0]), 0.10, 16.0, 16.0),\n        (np.array([0.0, 0.0, 0.0]), np.array([0.15, 0.15, 0.0]), 0.21, 12.0, 12.0),\n        (np.array([0.2, -0.1, 0.05]), np.array([0.25, -0.15, 0.05]), 0.08, 200.0, 2.0),\n        (np.array([0.0, 0.0, 0.0]), np.array([0.12, 0.0, 0.0]), 0.12, 12.0, 1.0),\n    ]\n\n    # Numerical safeguard threshold in nm^2\n    tau = 1.0e-12\n\n    results = []\n\n    for case in test_cases:\n        r_i, r_j, L0, m_i, m_j = case\n\n        # Calculate the inter-atomic vector\n        r_ij = r_j - r_i\n\n        # Calculate the squared distance\n        d_sq = np.dot(r_ij, r_ij)\n\n        # Apply numerical safeguard\n        if d_sq <= tau:\n            delta_ri = np.array([0.0, 0.0, 0.0])\n            delta_rj = np.array([0.0, 0.0, 0.0])\n        else:\n            # Calculate the constraint violation function, g = d^2 - L0^2\n            g_val = d_sq - L0**2\n\n            # If the constraint is already satisfied, corrections are zero.\n            if np.isclose(g_val, 0.0):\n                delta_ri = np.array([0.0, 0.0, 0.0])\n                delta_rj = np.array([0.0, 0.0, 0.0])\n            else:\n                # Calculate the common scalar factor k = (d^2 - L0^2) / (2 * d^2 * (m_i + m_j))\n                total_mass = m_i + m_j\n                scalar_k = g_val / (2.0 * d_sq * total_mass)\n\n                # Calculate the mass-weighted corrections\n                delta_ri = scalar_k * m_j * r_ij\n                delta_rj = -scalar_k * m_i * r_ij\n\n        # Concatenate corrections into a single vector and convert to list for output\n        full_correction = np.concatenate((delta_ri, delta_rj)).tolist()\n        results.append(full_correction)\n\n    # Format the final output string as specified\n    # Example: [[...six floats...],[...six floats...],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While the previous exercise focused on a single constraint, real biomolecules are described by a complex network of interconnected bond and angle constraints. This exercise introduces the constraint Jacobian, a crucial mathematical object that describes the collective gradient of the entire constraint system. By constructing the Jacobian and analyzing its rank for different molecular geometries, you will learn how to diagnose the linear independence of constraints, a key factor for the stability and success of constraint-solving algorithms .",
            "id": "3840917",
            "problem": "You are given a small, four-atom molecule with atoms indexed $0,1,2,3$ and Cartesian positions $\\mathbf{r}_i \\in \\mathbb{R}^3$ for $i \\in \\{0,1,2,3\\}$. In constrained Molecular Dynamics (MD), holonomic constraints are written as scalar functions $\\phi_k(\\mathbf{q}) = 0$ of the generalized coordinates $\\mathbf{q} \\in \\mathbb{R}^{3N}$, where $N$ is the number of atoms and $\\mathbf{q} = (\\mathbf{r}_0,\\mathbf{r}_1,\\ldots,\\mathbf{r}_{N-1})$. The Jacobian of the constraints is the matrix $G(\\mathbf{q}) \\in \\mathbb{R}^{m \\times 3N}$ with entries $G_{k,\\alpha}(\\mathbf{q}) = \\frac{\\partial \\phi_k(\\mathbf{q})}{\\partial q_\\alpha}$, where $m$ is the number of constraints. Independence of constraints at a configuration $\\mathbf{q}$ is determined by the rank of $G(\\mathbf{q})$ being equal to $m$.\n\nImplement the Jacobian $G$ for the following $m = 5$ constraints on the $N=4$ atom molecule:\n- Bond length (squared) constraints: atoms $(0,1)$, $(1,2)$, and $(2,3)$ have fixed squared bond lengths. Each bond constraint is defined as $\\phi_{\\text{bond}}(\\mathbf{r}_i,\\mathbf{r}_j) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d_{ij}^2$, where $d_{ij}$ is the target bond length. Use target bond lengths $d_{01} = d_{12} = d_{23} = 1.54$ in ångströms. The output does not require units, but the internal geometry uses coordinates in ångströms.\n- Bond angle constraints: the angle at atom $1$ formed by atoms $(0,1,2)$ and the angle at atom $2$ formed by atoms $(1,2,3)$. Each angle constraint is defined via the cosine of the angle, $\\phi_{\\text{ang}}(\\mathbf{r}_i,\\mathbf{r}_j,\\mathbf{r}_k) = \\cos(\\theta_{ijk}) - \\cos(\\theta_{ijk}^{0})$, where $\\theta_{ijk}$ is the angle at vertex $j$ between vectors $\\mathbf{r}_i - \\mathbf{r}_j$ and $\\mathbf{r}_k - \\mathbf{r}_j$. Use target angles $\\theta_{012}^{0} = 1.911$ and $\\theta_{123}^{0} = 1.911$ in radians. All angles in this problem must be measured in radians.\n\nStarting from the definitions above and fundamental laws of classical mechanics (Newton’s laws) and geometry, compute the Jacobian $G(\\mathbf{q})$ for each given configuration. You must not assume any pre-derived formulas beyond basic vector calculus identities and the definition of the cosine of the angle. Independence of constraints is assessed through the numerical rank of $G(\\mathbf{q})$ (computed using Singular Value Decomposition (SVD)).\n\nYour task is to write a complete, runnable program that:\n1. Constructs the Jacobian $G(\\mathbf{q})$ for the constraints described, at each configuration in the test suite below.\n2. Computes the numerical rank of $G(\\mathbf{q})$ at each configuration using SVD.\n3. Produces a single line of output containing the ranks for all test cases as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,\\ldots,r_T]$, where each $r_t$ is an integer rank for test case $t$.\n\nUse the following test suite of configurations (coordinates in ångströms):\n- Test case $1$: $\\mathbf{r}_0 = (0.00, 0.00, 0.00)$, $\\mathbf{r}_1 = (1.50, 0.10, -0.20)$, $\\mathbf{r}_2 = (2.80, -0.30, 0.50)$, $\\mathbf{r}_3 = (4.00, 0.00, -0.40)$.\n- Test case $2$: $\\mathbf{r}_0 = (0.00, 0.00, 0.00)$, $\\mathbf{r}_1 = (1.00, 0.00, 0.00)$, $\\mathbf{r}_2 = (2.10, 0.05, 0.00)$, $\\mathbf{r}_3 = (3.20, -0.10, 0.00)$.\n- Test case $3$: $\\mathbf{r}_0 = (0.00, 0.00, 0.00)$, $\\mathbf{r}_1 = (1.00, 0.00, 0.00)$, $\\mathbf{r}_2 = (2.00, 0.00, 0.00)$, $\\mathbf{r}_3 = (3.00, 0.00, 0.00)$.\n- Test case $4$: $\\mathbf{r}_0 = (0.00, 0.00, 0.00)$, $\\mathbf{r}_1 = (1.00, 0.90, -0.30)$, $\\mathbf{r}_2 = (2.00, 2.00, 0.10)$, $\\mathbf{r}_3 = (3.00, 2.80, -0.20)$.\n- Test case $5$: $\\mathbf{r}_0 = (0.10, -0.20, 0.00)$, $\\mathbf{r}_1 = (1.20, 0.30, -0.50)$, $\\mathbf{r}_2 = (2.40, 0.10, 0.40)$, $\\mathbf{r}_3 = (3.60, -0.20, 0.10)$.\n- Test case $6$: $\\mathbf{r}_0 = (0.00, 0.00, 0.00)$, $\\mathbf{r}_1 = (1.00, 1.00, 0.00)$, $\\mathbf{r}_2 = (1.50, 2.50, 0.00)$, $\\mathbf{r}_3 = (1.80, 4.00, 0.10)$.\n\nDesign for coverage:\n- The general cases ($1$, $4$, $5$, $6$) are non-degenerate conformations expected to exhibit full rank if constraints are independent.\n- The near-collinear case ($2$) probes numerical stability for nearly dependent angle constraints.\n- The exactly collinear case ($3$) is an edge case where angle constraints can become singular, testing rank deficiency.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the ranks for the six test cases as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5,r_6]$, where each $r_i$ is an integer.",
            "solution": "The task is to compute the Jacobian matrix $G(\\mathbf{q})$ for a set of $m=5$ geometric constraints imposed on a molecule of $N=4$ atoms, and then determine its numerical rank. The generalized coordinates vector $\\mathbf{q}$ is the concatenation of the Cartesian coordinates of all atoms: $\\mathbf{q} = (\\mathbf{r}_0, \\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3) \\in \\mathbb{R}^{12}$. The Jacobian $G(\\mathbf{q})$ is an $m \\times 3N$ matrix, here $5 \\times 12$, where each row contains the gradient of one constraint function with respect to $\\mathbf{q}$.\n\nThe constraints are as follows:\n$1$. Bond $(0,1)$: $\\phi_1 = \\|\\mathbf{r}_0 - \\mathbf{r}_1\\|^2 - d_{01}^2 = 0$\n$2$. Bond $(1,2)$: $\\phi_2 = \\|\\mathbf{r}_1 - \\mathbf{r}_2\\|^2 - d_{12}^2 = 0$\n$3$. Bond $(2,3)$: $\\phi_3 = \\|\\mathbf{r}_2 - \\mathbf{r}_3\\|^2 - d_{23}^2 = 0$\n$4$. Angle $(0,1,2)$: $\\phi_4 = \\cos(\\theta_{012}) - \\cos(\\theta_{012}^{0}) = 0$\n$5$. Angle $(1,2,3)$: $\\phi_5 = \\cos(\\theta_{123}) - \\cos(\\theta_{123}^{0}) = 0$\n\nWe must derive the gradient vector for each constraint. A gradient $\\nabla_{\\mathbf{q}} \\phi_k$ forms the $k$-th row of the Jacobian matrix $G$. This gradient is a $12$-dimensional vector composed of the partial derivatives with respect to each coordinate component. We can express it more compactly as a collection of $3$-dimensional gradients with respect to each atom's position vector, $\\nabla_{\\mathbf{r}_i} \\phi_k$.\n\n**1. Jacobian of Bond Length Constraints**\nFor a generic bond constraint between atoms $i$ and $j$, $\\phi_{\\text{bond}}(\\mathbf{r}_i, \\mathbf{r}_j) = (\\mathbf{r}_i - \\mathbf{r}_j) \\cdot (\\mathbf{r}_i - \\mathbf{r}_j) - d_{ij}^2 = 0$. Let $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$. The derivatives with respect to the atomic positions are:\n$$\n\\nabla_{\\mathbf{r}_i} \\phi_{\\text{bond}} = \\frac{\\partial}{\\partial \\mathbf{r}_i} (\\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ij}) = 2\\mathbf{r}_{ij} = 2(\\mathbf{r}_i - \\mathbf{r}_j)\n$$\n$$\n\\nabla_{\\mathbf{r}_j} \\phi_{\\text{bond}} = \\frac{\\partial}{\\partial \\mathbf{r}_j} (\\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ij}) = 2\\mathbf{r}_{ij} \\cdot \\frac{\\partial \\mathbf{r}_{ij}}{\\partial \\mathbf{r}_j} = 2(\\mathbf{r}_i - \\mathbf{r}_j) \\cdot (-\\mathbf{I}) = -2(\\mathbf{r}_i - \\mathbf{r}_j)\n$$\nwhere $\\mathbf{I}$ is the $3 \\times 3$ identity matrix. For any atom $k$ not involved in the bond ($k \\neq i, j$), the gradient is zero: $\\nabla_{\\mathbf{r}_k} \\phi_{\\text{bond}} = \\mathbf{0}$.\nThe first three rows of the Jacobian $G$ are populated by these gradients for bonds $(0,1)$, $(1,2)$, and $(2,3)$ respectively. For example, for $\\phi_1$ (bond $0-1$), the gradients are $\\nabla_{\\mathbf{r}_0} \\phi_1 = 2(\\mathbf{r}_0 - \\mathbf{r}_1)$, $\\nabla_{\\mathbf{r}_1} \\phi_1 = -2(\\mathbf{r}_0 - \\mathbf{r}_1)$, and $\\nabla_{\\mathbf{r}_2} \\phi_1 = \\nabla_{\\mathbf{r}_3} \\phi_1 = \\mathbf{0}$.\n\n**2. Jacobian of Bond Angle Constraints**\nFor a generic angle constraint $\\phi_{\\text{ang}}(\\mathbf{r}_i,\\mathbf{r}_j,\\mathbf{r}_k) = \\cos(\\theta_{ijk}) - \\cos(\\theta_{ijk}^0) = 0$, we need to find the gradients of $\\cos(\\theta_{ijk})$ with respect to $\\mathbf{r}_i$, $\\mathbf{r}_j$, and $\\mathbf{r}_k$.\nLet $\\mathbf{u} = \\mathbf{r}_i - \\mathbf{r}_j$ and $\\mathbf{v} = \\mathbf{r}_k - \\mathbf{r}_j$. The cosine of the angle is given by the dot product of the normalized vectors:\n$$\n\\cos(\\theta_{ijk}) = \\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\| \\|\\mathbf{v}\\|} = \\hat{\\mathbf{u}} \\cdot \\hat{\\mathbf{v}}\n$$\nSince $\\cos(\\theta_{ijk}^0)$ is a constant, its derivative is zero. We compute the gradient of $\\cos(\\theta_{ijk})$ with respect to each atomic position vector.\n\nGradient with respect to $\\mathbf{r}_i$:\nOnly vector $\\mathbf{u}$ depends on $\\mathbf{r}_i$. Using the chain rule and the identity for the derivative of a normalized vector, $(\\nabla_{\\mathbf{x}} \\hat{\\mathbf{x}}) = \\frac{1}{\\|\\mathbf{x}\\|} (\\mathbf{I} - \\hat{\\mathbf{x}}\\hat{\\mathbf{x}}^T)$, we find:\n$$\n\\nabla_{\\mathbf{r}_i} \\cos(\\theta_{ijk}) = (\\nabla_{\\mathbf{r}_i} \\hat{\\mathbf{u}})^T \\hat{\\mathbf{v}} = \\frac{1}{\\|\\mathbf{u}\\|} (\\mathbf{I} - \\hat{\\mathbf{u}}\\hat{\\mathbf{u}}^T) \\hat{\\mathbf{v}} = \\frac{1}{\\|\\mathbf{u}\\|} (\\hat{\\mathbf{v}} - (\\hat{\\mathbf{u}} \\cdot \\hat{\\mathbf{v}})\\hat{\\mathbf{u}}) = \\frac{1}{\\|\\mathbf{u}\\|} (\\hat{\\mathbf{v}} - \\cos(\\theta_{ijk})\\hat{\\mathbf{u}})\n$$\n\nGradient with respect to $\\mathbf{r}_k$:\nBy symmetry, swapping the roles of $i$ and $k$ (and thus $\\mathbf{u}$ and $\\mathbf{v}$):\n$$\n\\nabla_{\\mathbf{r}_k} \\cos(\\theta_{ijk}) = \\frac{1}{\\|\\mathbf{v}\\|} (\\hat{\\mathbf{u}} - \\cos(\\theta_{ijk})\\hat{\\mathbf{v}})\n$$\nGradient with respect to $\\mathbf{r}_j$:\nThe angle constraint function depends only on the relative positions of the atoms. It is invariant to a uniform translation of all three atoms, $\\mathbf{r}_l \\to \\mathbf{r}_l + \\mathbf{c}$. This implies that the sum of the gradients over all involved atoms must be zero:\n$$\n\\nabla_{\\mathbf{r}_i} \\phi_{\\text{ang}} + \\nabla_{\\mathbf{r}_j} \\phi_{\\text{ang}} + \\nabla_{\\mathbf{r}_k} \\phi_{\\text{ang}} = \\mathbf{0}\n$$\nTherefore, the gradient on the central atom $j$ can be computed as:\n$$\n\\nabla_{\\mathbf{r}_j} \\cos(\\theta_{ijk}) = -(\\nabla_{\\mathbf{r}_i} \\cos(\\theta_{ijk}) + \\nabla_{\\mathbf{r}_k} \\cos(\\theta_{ijk}))\n$$\nThis relationship simplifies the calculation and ensures numerical robustness.\n\nFor any atom $l$ not involved in the angle ($l \\neq i, j, k$), the gradient is zero: $\\nabla_{\\mathbf{r}_l} \\phi_{\\text{ang}} = \\mathbf{0}$.\nThese gradients populate rows $4$ and $5$ of the Jacobian for angles $(0,1,2)$ and $(1,2,3)$.\n\nA critical special case arises when atoms $i,j,k$ are collinear. Here, $\\hat{\\mathbf{u}} = \\pm \\hat{\\mathbf{v}}$ and $\\cos(\\theta_{ijk}) = \\pm 1$. The gradient expressions become:\n$\\nabla_{\\mathbf{r}_i} = \\frac{1}{\\|\\mathbf{u}\\|}(\\pm \\hat{\\mathbf{u}} - (\\pm 1)\\hat{\\mathbf{u}}) = \\mathbf{0}$. Similarly, $\\nabla_{\\mathbf{r}_k} = \\mathbf{0}$, and thus $\\nabla_{\\mathbf{r}_j} = \\mathbf{0}$. The entire row of the Jacobian corresponding to a collinear angle constraint becomes zero, reducing the rank of the matrix.\n\n**3. Jacobian Matrix Construction and Rank Computation**\nThe full Jacobian $G$ is a $5 \\times 12$ matrix. Each row $k$ is formed by concatenating the $3D$ gradients for that constraint:\n$$\nG_k = [\\nabla_{\\mathbf{r}_0} \\phi_k, \\nabla_{\\mathbf{r}_1} \\phi_k, \\nabla_{\\mathbf{r}_2} \\phi_k, \\nabla_{\\mathbf{r}_3} \\phi_k]\n$$\nThe independence of the constraints is determined by the numerical rank of $G$. The rank is computed via Singular Value Decomposition (SVD). The number of singular values that are significantly larger than machine precision determines the rank.\n\nThe algorithm is as follows:\n1. For each test case configuration $(\\mathbf{r}_0, \\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3)$:\n2. Construct the $5 \\times 12$ Jacobian matrix $G$.\n3. For each of the $m=3$ bond constraints, calculate the $3D$ gradients and place them in the corresponding row and columns of $G$.\n4. For each of the $m=2$ angle constraints, calculate the $3D$ gradients and place them in the corresponding row and columns of $G$.\n5. Compute the numerical rank of the resulting matrix $G$.\nThe final output is a list of these ranks for all test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_jacobian_and_rank(positions):\n    \"\"\"\n    Computes the constraint Jacobian and its rank for a 4-atom molecule.\n\n    Args:\n        positions (list of np.ndarray): A list of 4 numpy arrays, where each\n                                        array is the 3D Cartesian coordinate\n                                        vector of an atom.\n\n    Returns:\n        int: The numerical rank of the 5x12 Jacobian matrix.\n    \"\"\"\n    num_atoms = 4\n    num_constraints = 5\n    \n    # The Jacobian G is an m x 3N matrix, here 5 x 12.\n    G = np.zeros((num_constraints, 3 * num_atoms))\n    \n    r = positions\n    \n    # 1. Bond (0,1) constraint: phi_1 = ||r0 - r1||^2 - d01^2\n    r01 = r[0] - r[1]\n    grad_r0_phi1 = 2 * r01\n    grad_r1_phi1 = -2 * r01\n    G[0, 0:3] = grad_r0_phi1\n    G[0, 3:6] = grad_r1_phi1\n    \n    # 2. Bond (1,2) constraint: phi_2 = ||r1 - r2||^2 - d12^2\n    r12 = r[1] - r[2]\n    grad_r1_phi2 = 2 * r12\n    grad_r2_phi2 = -2 * r12\n    G[1, 3:6] = grad_r1_phi2\n    G[1, 6:9] = grad_r2_phi2\n    \n    # 3. Bond (2,3) constraint: phi_3 = ||r2 - r3||^2 - d23^2\n    r23 = r[2] - r[3]\n    grad_r2_phi3 = 2 * r23\n    grad_r3_phi3 = -2 * r23\n    G[2, 6:9] = grad_r2_phi3\n    G[2, 9:12] = grad_r3_phi3\n\n    # 4. Angle (0,1,2) constraint: phi_4 = cos(theta_012) - cos(theta_012^0)\n    # Define vectors from central atom 1: u = r0-r1, v = r2-r1\n    u_012 = r[0] - r[1]\n    v_012 = r[2] - r[1]\n    \n    norm_u_012 = np.linalg.norm(u_012)\n    norm_v_012 = np.linalg.norm(v_012)\n    \n    # Check for collinearity/zero length vectors\n    if norm_u_012 > 1e-9 and norm_v_012 > 1e-9:\n        u_hat_012 = u_012 / norm_u_012\n        v_hat_012 = v_012 / norm_v_012\n        cos_theta_012 = np.dot(u_hat_012, v_hat_012)\n\n        grad_r0_phi4 = (1 / norm_u_012) * (v_hat_012 - cos_theta_012 * u_hat_012)\n        grad_r2_phi4 = (1 / norm_v_012) * (u_hat_012 - cos_theta_012 * v_hat_012)\n        grad_r1_phi4 = -(grad_r0_phi4 + grad_r2_phi4)\n\n        G[3, 0:3] = grad_r0_phi4\n        G[3, 3:6] = grad_r1_phi4\n        G[3, 6:9] = grad_r2_phi4\n    # If vectors are of zero length or collinear, the gradient is zero, and the row remains zero.\n\n    # 5. Angle (1,2,3) constraint: phi_5 = cos(theta_123) - cos(theta_123^0)\n    # Define vectors from central atom 2: u = r1-r2, v = r3-r2\n    u_123 = r[1] - r[2]\n    v_123 = r[3] - r[2]\n\n    norm_u_123 = np.linalg.norm(u_123)\n    norm_v_123 = np.linalg.norm(v_123)\n\n    if norm_u_123 > 1e-9 and norm_v_123 > 1e-9:\n        u_hat_123 = u_123 / norm_u_123\n        v_hat_123 = v_123 / norm_v_123\n        cos_theta_123 = np.dot(u_hat_123, v_hat_123)\n        \n        grad_r1_phi5 = (1 / norm_u_123) * (v_hat_123 - cos_theta_123 * u_hat_123)\n        grad_r3_phi5 = (1 / norm_v_123) * (u_hat_123 - cos_theta_123 * v_hat_123)\n        grad_r2_phi5 = -(grad_r1_phi5 + grad_r3_phi5)\n        \n        G[4, 3:6] = grad_r1_phi5\n        G[4, 6:9] = grad_r2_phi5\n        G[4, 9:12] = grad_r3_phi5\n\n    # Compute numerical rank using SVD\n    return np.linalg.matrix_rank(G)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        [np.array([0.00, 0.00, 0.00]), np.array([1.50, 0.10, -0.20]), \n         np.array([2.80, -0.30, 0.50]), np.array([4.00, 0.00, -0.40])],\n        # Test case 2\n        [np.array([0.00, 0.00, 0.00]), np.array([1.00, 0.00, 0.00]), \n         np.array([2.10, 0.05, 0.00]), np.array([3.20, -0.10, 0.00])],\n        # Test case 3\n        [np.array([0.00, 0.00, 0.00]), np.array([1.00, 0.00, 0.00]), \n         np.array([2.00, 0.00, 0.00]), np.array([3.00, 0.00, 0.00])],\n        # Test case 4\n        [np.array([0.00, 0.00, 0.00]), np.array([1.00, 0.90, -0.30]), \n         np.array([2.00, 2.00, 0.10]), np.array([3.00, 2.80, -0.20])],\n        # Test case 5\n        [np.array([0.10, -0.20, 0.00]), np.array([1.20, 0.30, -0.50]), \n         np.array([2.40, 0.10, 0.40]), np.array([3.60, -0.20, 0.10])],\n        # Test case 6\n        [np.array([0.00, 0.00, 0.00]), np.array([1.00, 1.00, 0.00]), \n         np.array([1.50, 2.50, 0.00]), np.array([1.80, 4.00, 0.10])],\n    ]\n\n    results = []\n    for positions in test_cases:\n        rank = compute_jacobian_and_rank(positions)\n        results.append(rank)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Beyond constraining individual degrees of freedom, we can treat entire molecules or parts of them as perfectly rigid bodies, which requires a robust way to describe their orientation and rotation. This practice delves into the use of quaternions, an elegant and computationally efficient formalism that avoids the pitfalls of other rotation representations. You will derive the rotation matrix from a given quaternion and use it to transform a vector from the molecule's internal coordinate system to the laboratory frame, solidifying your understanding of rigid-body kinematics .",
            "id": "3840920",
            "problem": "Consider a rigid triatomic fragment used in molecular dynamics (MD) simulations with holonomic constraints that maintain fixed internal distances and angles. The rigid-body orientation is represented by a unit quaternion $q = (q_{0}, q_{1}, q_{2}, q_{3})$ with scalar part $q_{0}$ and vector part $(q_{1}, q_{2}, q_{3})$. In a particular MD step, the fragment’s orientation is given by $q = \\left(\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}\\right)$. A body-fixed coordinate of a marker atom relative to the center of mass is $r_{\\text{body}} = (0.12, -0.08, 0.05)$ in nanometers.\n\nStarting from first principles appropriate to rigid-body dynamics, including the definition of a unit quaternion as a rotation operator and the requirement that rigid-body motion preserves distances, derive the $3 \\times 3$ rotation matrix $R(q)$ corresponding to the given quaternion $q$. Explain how the mapping from body-fixed to space-fixed coordinates arises from this derivation for an arbitrary vector. Then, use the derived $R(q)$ to compute the space-fixed Cartesian $\\hat{x}$-component of the marker atom’s position. Express the final $\\hat{x}$-component in nanometers, and round your answer to four significant figures. No intermediate numerical rounding is permitted prior to the final step.",
            "solution": "The problem is well-posed and scientifically sound, providing all necessary information to determine a unique solution. I will proceed with the derivation and calculation.\n\nThe rotation of a vector in three-dimensional space can be represented by a unit quaternion. A vector $\\mathbf{v} \\in \\mathbb{R}^3$ is represented as a pure quaternion $p_v = (0, v_1, v_2, v_3)$, where the scalar part is zero. A unit quaternion is given by $q = (q_0, q_1, q_2, q_3) = (q_0, \\mathbf{q})$, where $q_0$ is the scalar part and $\\mathbf{q}$ is the vector part. For a unit quaternion, the norm is unity: $q_0^2 + q_1^2 + q_2^2 + q_3^2 = 1$. The given quaternion $q = (\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2})$ satisfies this condition, as $(\\frac{1}{2})^2 + (\\frac{1}{2})^2 + (\\frac{1}{2})^2 + (\\frac{1}{2})^2 = 4 \\times \\frac{1}{4} = 1$.\n\nThe rotation of a vector $\\mathbf{v}$ to a new vector $\\mathbf{v}'$ by the quaternion $q$ is defined by the sandwich product:\n$$p_{v'} = q p_v q^{-1}$$\nFor a unit quaternion, the inverse $q^{-1}$ is equal to its conjugate $q^* = (q_0, -\\mathbf{q})$. Thus, the operation is:\n$$p_{v'} = q p_v q^*$$\nLet the body-fixed vector be $\\mathbf{r}_{\\text{body}} = (x_b, y_b, z_b)$, represented by the pure quaternion $p_b = (0, \\mathbf{r}_{\\text{body}})$. The resulting space-fixed vector $\\mathbf{r}_{\\text{space}}$ is the vector part of the pure quaternion $p_s = (0, \\mathbf{r}_{\\text{space}})$.\n\nWe first compute the product $q p_b$. The product of two quaternions $(a_0, \\mathbf{a})$ and $(b_0, \\mathbf{b})$ is given by $(a_0 b_0 - \\mathbf{a} \\cdot \\mathbf{b}, a_0 \\mathbf{b} + b_0 \\mathbf{a} + \\mathbf{a} \\times \\mathbf{b})$.\nHere, $(a_0, \\mathbf{a}) = (q_0, \\mathbf{q})$ and $(b_0, \\mathbf{b}) = (0, \\mathbf{r}_{\\text{body}})$.\n$$q p_b = (q_0 \\cdot 0 - \\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}}, q_0 \\mathbf{r}_{\\text{body}} + 0 \\cdot \\mathbf{q} + \\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) = (-\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}}, q_0 \\mathbf{r}_{\\text{body}} + \\mathbf{q} \\times \\mathbf{r}_{\\text{body}})$$\nNext, we multiply this result by $q^* = (q_0, -\\mathbf{q})$. Let the intermediate product be $(c_0, \\mathbf{c}) = q p_b$.\n$$p_s = (c_0, \\mathbf{c}) q^* = (c_0 q_0 - \\mathbf{c} \\cdot (-\\mathbf{q}), c_0(-\\mathbf{q}) + q_0 \\mathbf{c} + \\mathbf{c} \\times (-\\mathbf{q}))$$\nThe scalar part of $p_s$ must be zero, which is a key property of this transformation preserving the vector space.\nScalar part = $c_0 q_0 + \\mathbf{c} \\cdot \\mathbf{q} = (-\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}})q_0 + (q_0 \\mathbf{r}_{\\text{body}} + \\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) \\cdot \\mathbf{q} = -q_0(\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}}) + q_0(\\mathbf{r}_{\\text{body}} \\cdot \\mathbf{q}) + (\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) \\cdot \\mathbf{q}$.\nThe first two terms cancel, and the last term is a scalar triple product with two identical vectors, which is zero. So the scalar part is indeed $0$.\n\nThe vector part of $p_s$, which is $\\mathbf{r}_{\\text{space}}$, is:\n$$\\mathbf{r}_{\\text{space}} = -c_0\\mathbf{q} + q_0 \\mathbf{c} - (\\mathbf{c} \\times \\mathbf{q})$$\n$$\\mathbf{r}_{\\text{space}} = -(-\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}})\\mathbf{q} + q_0(q_0 \\mathbf{r}_{\\text{body}} + \\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) - (q_0 \\mathbf{r}_{\\text{body}} + \\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) \\times \\mathbf{q}$$\n$$\\mathbf{r}_{\\text{space}} = (\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}})\\mathbf{q} + q_0^2 \\mathbf{r}_{\\text{body}} + q_0(\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) - q_0(\\mathbf{r}_{\\text{body}} \\times \\mathbf{q}) - ((\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) \\times \\mathbf{q})$$\nUsing $\\mathbf{a} \\times \\mathbf{b} = -\\mathbf{b} \\times \\mathbf{a}$ and the vector triple product identity $\\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c}) = \\mathbf{b}(\\mathbf{a} \\cdot \\mathbf{c}) - \\mathbf{c}(\\mathbf{a} \\cdot \\mathbf{b})$:\n$$- ((\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) \\times \\mathbf{q}) = \\mathbf{q} \\times (\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) = \\mathbf{q}(\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}}) - \\mathbf{r}_{\\text{body}}(\\mathbf{q} \\cdot \\mathbf{q})$$\nSubstituting this back into the expression for $\\mathbf{r}_{\\text{space}}$:\n$$\\mathbf{r}_{\\text{space}} = (\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}})\\mathbf{q} + q_0^2 \\mathbf{r}_{\\text{body}} + 2q_0(\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) + \\mathbf{q}(\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}}) - \\mathbf{r}_{\\text{body}}\\|\\mathbf{q}\\|^2$$\n$$\\mathbf{r}_{\\text{space}} = (q_0^2 - \\|\\mathbf{q}\\|^2)\\mathbf{r}_{\\text{body}} + 2(\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}})\\mathbf{q} + 2q_0(\\mathbf{q} \\times \\mathbf{r}_{\\text{body}})$$\nThis equation defines the linear transformation $\\mathbf{r}_{\\text{space}} = R(q) \\mathbf{r}_{\\text{body}}$. The matrix $R(q)$ can be constructed from this relationship. Using $q_0^2 + \\|\\mathbf{q}\\|^2 = 1$, we can write $q_0^2 - \\|\\mathbf{q}\\|^2 = q_0^2 - (1 - q_0^2) = 2q_0^2 - 1$.\nThe components of the rotation matrix $R(q)$ are:\n$$R(q) = \\begin{pmatrix}\n1 - 2(q_2^2 + q_3^2) & 2(q_1q_2 - q_0q_3) & 2(q_1q_3 + q_0q_2) \\\\\n2(q_1q_2 + q_0q_3) & 1 - 2(q_1^2 + q_3^2) & 2(q_2q_3 - q_0q_1) \\\\\n2(q_1q_3 - q_0q_2) & 2(q_2q_3 + q_0q_1) & 1 - 2(q_1^2 + q_2^2)\n\\end{pmatrix}$$\nThis matrix $R(q)$ maps the coordinates of a vector from the body-fixed frame to the space-fixed frame.\n\nWe are given $q = (\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2})$, so $q_0=q_1=q_2=q_3=\\frac{1}{2}$. We substitute these values into the matrix formula:\n$q_i^2 = (\\frac{1}{2})^2 = \\frac{1}{4}$ for $i=0,1,2,3$.\n$q_i q_j = (\\frac{1}{2})(\\frac{1}{2}) = \\frac{1}{4}$ for any $i,j$.\n$R_{11} = 1 - 2(q_2^2 + q_3^2) = 1 - 2(\\frac{1}{4} + \\frac{1}{4}) = 1 - 2(\\frac{1}{2}) = 0$.\n$R_{12} = 2(q_1q_2 - q_0q_3) = 2(\\frac{1}{4} - \\frac{1}{4}) = 0$.\n$R_{13} = 2(q_1q_3 + q_0q_2) = 2(\\frac{1}{4} + \\frac{1}{4}) = 2(\\frac{1}{2}) = 1$.\n$R_{21} = 2(q_1q_2 + q_0q_3) = 2(\\frac{1}{4} + \\frac{1}{4}) = 2(\\frac{1}{2}) = 1$.\n$R_{22} = 1 - 2(q_1^2 + q_3^2) = 1 - 2(\\frac{1}{4} + \\frac{1}{4}) = 1 - 2(\\frac{1}{2}) = 0$.\n$R_{23} = 2(q_2q_3 - q_0q_1) = 2(\\frac{1}{4} - \\frac{1}{4}) = 0$.\n$R_{31} = 2(q_1q_3 - q_0q_2) = 2(\\frac{1}{4} - \\frac{1}{4}) = 0$.\n$R_{32} = 2(q_2q_3 + q_0q_1) = 2(\\frac{1}{4} + \\frac{1}{4}) = 2(\\frac{1}{2}) = 1$.\n$R_{33} = 1 - 2(q_1^2 + q_2^2) = 1 - 2(\\frac{1}{4} + \\frac{1}{4}) = 1 - 2(\\frac{1}{2}) = 0$.\n\nThus, the rotation matrix for the given quaternion is:\n$$R(q) = \\begin{pmatrix} 0 & 0 & 1 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix}$$\nThe body-fixed coordinate of the marker atom is given as $\\mathbf{r}_{\\text{body}} = (0.12, -0.08, 0.05)$ nanometers. To find the space-fixed coordinates $\\mathbf{r}_{\\text{space}}$, we apply the rotation matrix:\n$$\\mathbf{r}_{\\text{space}} = R(q) \\mathbf{r}_{\\text{body}} = \\begin{pmatrix} 0 & 0 & 1 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix} \\begin{pmatrix} 0.12 \\\\ -0.08 \\\\ 0.05 \\end{pmatrix}$$\nPerforming the matrix-vector multiplication:\n$$\\mathbf{r}_{\\text{space}} = \\begin{pmatrix} (0)(0.12) + (0)(-0.08) + (1)(0.05) \\\\ (1)(0.12) + (0)(-0.08) + (0)(0.05) \\\\ (0)(0.12) + (1)(-0.08) + (0)(0.05) \\end{pmatrix} = \\begin{pmatrix} 0.05 \\\\ 0.12 \\\\ -0.08 \\end{pmatrix}$$\nThe space-fixed coordinates are $(0.05, 0.12, -0.08)$ nanometers. The problem asks for the Cartesian $\\hat{x}$-component of this position, which is the first component of the vector.\nThe $\\hat{x}$-component is $0.05$ nm.\nThe final answer must be expressed to four significant figures. To represent the exact value $0.05$ with four significant figures, we write it as $0.05000$.",
            "answer": "$$\\boxed{0.05000}$$"
        }
    ]
}