{
    "hands_on_practices": [
        {
            "introduction": "我们将从一个最基本的系统开始：一个由两个质点组成的刚性体系。通过解析推导其回旋半径 $R_g$，我们可以直观地理解质量分布（而不仅仅是几何距离）如何决定一个分子复合物的有效尺寸。这个练习旨在从第一性原理出发，为理解质量加权平均这一核心概念打下坚实的物理基础。",
            "id": "3864903",
            "problem": "在大分子的计算结构分析中，围绕质心的质量加权回旋半径是一个关键的尺寸描述符，它直接与小角X射线散射 (SAXS) 中的散射可观测量相关联。考虑一个双域生物分子复合物的刚性粗粒化模型，该模型由两个质点 $m_1$ 和 $m_2$ 表示，它们在三维欧几里得空间中以固定的中心间距 $d$ 分隔。设总质量为 $M$，两个质点的位置矢量分别为 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$，质心为 $\\mathbf{r}_{\\mathrm{cm}}$。\n\n您可以仅假设以下基本定义：\n- 质心由 $\\mathbf{r}_{\\mathrm{cm}} = \\left(m_1 \\mathbf{r}_1 + m_2 \\mathbf{r}_2\\right)/M$ 给出，其中 $M = m_1 + m_2$。\n- 回旋半径的平方定义为 $R_g^2 = \\left(1/M\\right) \\sum_{i=1}^{2} m_i \\left|\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}\\right|^2$。\n\n请严格地从这些定义和几何考量出发，推导出 $R_g^2$ 作为 $m_1$、$m_2$ 和 $d$ 的函数的精确解析表达式。然后，分析 $m_1 \\gg m_2$ 的渐近极限，并在质量不均匀性如何影响刚性二聚体的 $R_g^2$ 的背景下对其进行物理解释。\n\n答案规格：\n- 以 $m_1$、$m_2$ 和 $d$ 表示的 $R_g^2$ 的单一、闭合形式的解析表达式提供您的最终结果。\n- 不要在最终表达式中代入数值，也不要包含单位。\n- 无需四舍五入。",
            "solution": "该问题被认为是有效的，因为它以经典力学原理为科学基础，是适定的（具有足够的信息以获得唯一解），并且陈述客观。我们将进行严格的推导。\n\n目标是推导一个由两个质点 $m_1$ 和 $m_2$（以固定距离 $d$ 分隔）组成的系统的回旋半径平方 $R_g^2$ 的表达式，该表达式是这三个参数的函数。我们严格地从所提供的定义开始。\n\n系统的总质量为 $M = m_1 + m_2$。\n质心矢量定义为：\n$$\n\\mathbf{r}_{\\mathrm{cm}} = \\frac{m_1 \\mathbf{r}_1 + m_2 \\mathbf{r}_2}{M}\n$$\n回旋半径的平方定义为：\n$$\nR_g^2 = \\frac{1}{M} \\sum_{i=1}^{2} m_i |\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}|^2 = \\frac{1}{M} \\left( m_1 |\\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}}|^2 + m_2 |\\mathbf{r}_2 - \\mathbf{r}_{\\mathrm{cm}}|^2 \\right)\n$$\n我们的策略是用分隔两个质点的矢量 $\\mathbf{r}_1 - \\mathbf{r}_2$ 来表示从质心到每个粒子的矢量 $\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}$。\n\n首先，我们求从质心到质量 $m_1$ 的矢量：\n$$\n\\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}} = \\mathbf{r}_1 - \\frac{m_1 \\mathbf{r}_1 + m_2 \\mathbf{r}_2}{m_1 + m_2}\n$$\n将各项通分，公分母为 $M = m_1 + m_2$：\n$$\n\\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}} = \\frac{(m_1 + m_2)\\mathbf{r}_1 - (m_1 \\mathbf{r}_1 + m_2 \\mathbf{r}_2)}{m_1 + m_2} = \\frac{m_1 \\mathbf{r}_1 + m_2 \\mathbf{r}_1 - m_1 \\mathbf{r}_1 - m_2 \\mathbf{r}_2}{M} = \\frac{m_2 (\\mathbf{r}_1 - \\mathbf{r}_2)}{M}\n$$\n类似地，对于从质心到质量 $m_2$ 的矢量：\n$$\n\\mathbf{r}_2 - \\mathbf{r}_{\\mathrm{cm}} = \\mathbf{r}_2 - \\frac{m_1 \\mathbf{r}_1 + m_2 \\mathbf{r}_2}{m_1 + m_2}\n$$\n$$\n\\mathbf{r}_2 - \\mathbf{r}_{\\mathrm{cm}} = \\frac{(m_1 + m_2)\\mathbf{r}_2 - (m_1 \\mathbf{r}_1 + m_2 \\mathbf{r}_2)}{m_1 + m_2} = \\frac{m_1 \\mathbf{r}_2 + m_2 \\mathbf{r}_2 - m_1 \\mathbf{r}_1 - m_2 \\mathbf{r}_2}{M} = \\frac{m_1 (\\mathbf{r}_2 - \\mathbf{r}_1)}{M}\n$$\n现在我们计算这些矢量的模的平方。已知两个质点之间的距离为 $d$，所以 $|\\mathbf{r}_1 - \\mathbf{r}_2| = |\\mathbf{r}_2 - \\mathbf{r}_1| = d$。\n$$\n|\\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}}|^2 = \\left| \\frac{m_2 (\\mathbf{r}_1 - \\mathbf{r}_2)}{M} \\right|^2 = \\left(\\frac{m_2}{M}\\right)^2 |\\mathbf{r}_1 - \\mathbf{r}_2|^2 = \\frac{m_2^2}{M^2} d^2\n$$\n$$\n|\\mathbf{r}_2 - \\mathbf{r}_{\\mathrm{cm}}|^2 = \\left| \\frac{m_1 (\\mathbf{r}_2 - \\mathbf{r}_1)}{M} \\right|^2 = \\left(\\frac{m_1}{M}\\right)^2 |\\mathbf{r}_2 - \\mathbf{r}_1|^2 = \\frac{m_1^2}{M^2} d^2\n$$\n将这些结果代回 $R_g^2$ 的定义中：\n$$\nR_g^2 = \\frac{1}{M} \\left( m_1 \\left[ \\frac{m_2^2}{M^2} d^2 \\right] + m_2 \\left[ \\frac{m_1^2}{M^2} d^2 \\right] \\right)\n$$\n我们可以提取公因式 $\\frac{d^2}{M^2}$：\n$$\nR_g^2 = \\frac{d^2}{M^3} \\left( m_1 m_2^2 + m_2 m_1^2 \\right)\n$$\n从括号中的项中提取公因式 $m_1 m_2$ 得到：\n$$\nR_g^2 = \\frac{d^2}{M^3} \\left( m_1 m_2 (m_2 + m_1) \\right)\n$$\n根据定义，$M = m_1 + m_2$。将此代入表达式中可得：\n$$\nR_g^2 = \\frac{m_1 m_2 (M)}{M^3} d^2 = \\frac{m_1 m_2}{M^2} d^2\n$$\n最后，用 $m_1 + m_2$ 替换 $M$，我们得到 $R_g^2$ 作为 $m_1$、$m_2$ 和 $d$ 的函数的所求表达式：\n$$\nR_g^2 = \\frac{m_1 m_2}{(m_1 + m_2)^2} d^2\n$$\n这个表达式等价于 $R_g^2 = \\frac{\\mu}{M}d^2$，其中 $\\mu = \\frac{m_1 m_2}{m_1+m_2}$ 是该双体系统的折合质量。\n\n接下来，我们分析一个质量远大于另一个质量的渐近极限，即 $m_1 \\gg m_2$。在此极限下，总质量 $M = m_1 + m_2 \\approx m_1$。\n我们可以通过从分母中提取 $m_1$ 来重写 $R_g^2$ 的表达式：\n$$\nR_g^2 = \\frac{m_1 m_2}{(m_1(1 + m_2/m_1))^2} d^2 = \\frac{m_1 m_2}{m_1^2 (1 + m_2/m_1)^2} d^2 = \\frac{m_2}{m_1} \\frac{1}{(1 + m_2/m_1)^2} d^2\n$$\n当 $m_1 \\gg m_2$ 时，比值 $\\frac{m_2}{m_1} \\to 0$。因此，项 $(1 + m_2/m_1)^2 \\to (1+0)^2 = 1$。\n因此，$R_g^2$ 的表达式趋近于：\n$$\n\\lim_{m_2/m_1 \\to 0} R_g^2 = \\frac{m_2}{m_1} d^2\n$$\n这个结果的物理解释如下。当 $m_1 \\gg m_2$ 时，系统的质心 $\\mathbf{r}_{\\mathrm{cm}}$ 位于非常靠近大质量物体 $\\mathbf{r}_1$ 的位置。在极限情况下，$\\mathbf{r}_{\\mathrm{cm}} \\to \\mathbf{r}_1$。回旋半径是所有质量到质心距离的平方的质量加权平均值。\n在此极限下：\n- 大质量 $m_1$ 对 $R_g^2$ 的贡献变得可以忽略不计，因为它到质心的距离 $|\\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}}|$ 趋近于0。\n- 小质量 $m_2$ 的贡献占主导地位。它与质心的距离约等于总的分离距离 $d$，即 $|\\mathbf{r}_2 - \\mathbf{r}_{\\mathrm{cm}}| \\approx |\\mathbf{r}_2 - \\mathbf{r}_1| = d$。\n$R_g^2$ 的定义近似变为：\n$$\nR_g^2 \\approx \\frac{1}{M} \\left( m_1 (0)^2 + m_2 (d)^2 \\right) = \\frac{m_2}{M} d^2\n$$\n由于 $M \\approx m_1$，这可以简化为 $R_g^2 \\approx \\frac{m_2}{m_1} d^2$，这证实了我们的解析极限。这表明，对于一个质量分布高度不均匀的系统，回旋半径不是简单几何范围（如 $d$）的度量，而是被质量比强烈抑制。由 $R_g$ 测量的系统有效尺寸变得远小于其物理尺寸 $d$，因为大部分质量都集中在质心处。",
            "answer": "$$\n\\boxed{\\frac{m_1 m_2}{\\left(m_1 + m_2\\right)^{2}} d^{2}}\n$$"
        },
        {
            "introduction": "在掌握了离散系统的概念之后，我们将把球状大分子近似为一个均匀密度的球体，并通过积分方法推导其回旋半径。这个练习连接了离散的原子模型和连续的粗粒化表征，这在生物物理学中是一种常见且强大的技术。它展示了如何将 $R_g$ 的基本定义应用于连续体，从而得到简洁而优美的几何关系。",
            "id": "3864882",
            "problem": "在计算化学生物学中，球状大分子通常被粗粒化为具有对称质量分布的连续体，以推导用于分子动力学（MD）分析的结构度量。考虑一个球对称的均匀质量分布，它将一个紧凑的生物分子组装体（例如，一个折叠的蛋白质或核糖核蛋白复合物）近似为一个半径为 $R$、质量密度恒为 $\\rho$ 的实心球体。其质心与几何中心重合。从回旋半径是连续分布中各部分到质心的质量加权均方距离这一基本定义出发，在球坐标系中建立并计算所需的积分，以求得回旋半径的平方作为 $R$ 的函数。\n\n约束与说明：\n- 将质量密度视为在 $0 \\leq r \\leq R$ 时 $\\rho(r)=\\rho$，在 $r>R$ 时 $\\rho(r)=0$。\n- 使用以质心为中心的球坐标系，并明确写出角向和径向的积分限以及体积元的雅可比因子。\n- 不要使用任何预先制成的表格结果；从第一性原理出发推导所需的每一个中间量。\n- 将最终答案表示为关于 $R$ 的单一闭式解析表达式。\n- 以平方米表示最终的量，但不要在方框内的答案中包含单位。",
            "solution": "该问题陈述是经典力学应用于生物物理模型的一个有效且适定的练习。它要求从第一性原理出发，使用球坐标系，推导一个均匀密度实心球体的回旋半径的平方。这个问题有科学依据、内容自洽且客观。我们将着手进行解答。\n\n对于一个连续质量分布，回旋半径的平方（记为 $R_g^2$）定义为物体各组成部分到其质心的质量加权均方距离。对于一个体积为 $V$、质量密度分布为 $\\rho(\\mathbf{r})$ 的物体，这可以用以下积分表示：\n$$R_g^2 = \\frac{1}{M} \\int_V \\|\\mathbf{r}\\|^2 dm$$\n其中 $M$ 是物体的总质量，$dm$ 是一个微分质量元，$\\mathbf{r}$ 是从质心出发的位置矢量。在本问题中，质心位于我们坐标系的原点，所以到质心的距离就是位置矢量的大小 $\\|\\mathbf{r}\\|$。\n\n微分质量元 $dm$ 可以用密度 $\\rho$ 和微分体积元 $dV$ 表示为 $dm = \\rho(\\mathbf{r}) dV$。问题指定了均匀的质量分布，因此在距离中心 $r \\leq R$ 的范围内，密度 $\\rho(\\mathbf{r})$ 是一个常数 $\\rho$，在其他地方则为 $0$。\n将 $dm = \\rho dV$ 代入 $R_g^2$ 的定义中，得到：\n$$R_g^2 = \\frac{1}{M} \\int_V \\|\\mathbf{r}\\|^2 \\rho dV$$\n由于 $\\rho$ 在整个球体体积内是常数，它可以从分子中的积分里提出来。\n$$R_g^2 = \\frac{\\rho}{M} \\int_V \\|\\mathbf{r}\\|^2 dV$$\n\n总质量 $M$ 是常数密度 $\\rho$ 在球体体积 $V$ 上的积分：\n$$M = \\int_V \\rho dV = \\rho \\int_V dV = \\rho V$$\n我们必须按规定首先通过积分推导体积 $V$。在球坐标系 $(r, \\theta, \\phi)$ 中，位置矢量的大小为 $\\|\\mathbf{r}\\| = r$，体积元为 $dV = r^2 \\sin\\theta dr d\\theta d\\phi$。项 $r^2 \\sin\\theta$ 是坐标变换的雅可比行列式。对于半径为 $R$ 的球体，积分限为 $r \\in [0, R]$，$\\theta \\in [0, \\pi]$，$\\phi \\in [0, 2\\pi]$。\n体积积分为：\n$$V = \\int_{0}^{2\\pi} \\int_{0}^{\\pi} \\int_{0}^{R} r^2 \\sin\\theta dr d\\theta d\\phi$$\n我们通过分离变量来计算这个积分：\n$$V = \\left( \\int_{0}^{2\\pi} d\\phi \\right) \\left( \\int_{0}^{\\pi} \\sin\\theta d\\theta \\right) \\left( \\int_{0}^{R} r^2 dr \\right)$$\n分别计算每个积分：\n$$\\int_{0}^{2\\pi} d\\phi = [\\phi]_{0}^{2\\pi} = 2\\pi$$\n$$\\int_{0}^{\\pi} \\sin\\theta d\\theta = [-\\cos\\theta]_{0}^{\\pi} = -(\\cos\\pi - \\cos0) = -(-1 - 1) = 2$$\n$$\\int_{0}^{R} r^2 dr = \\left[ \\frac{r^3}{3} \\right]_{0}^{R} = \\frac{R^3}{3}$$\n将这些结果相乘，得到球体的体积：\n$$V = (2\\pi)(2)\\left(\\frac{R^3}{3}\\right) = \\frac{4}{3}\\pi R^3$$\n因此，总质量为 $M = \\rho \\frac{4}{3}\\pi R^3$。\n\n现在我们可以通过代入 $M$ 来表示 $R_g^2$：\n$$R_g^2 = \\frac{\\rho}{\\rho \\frac{4}{3}\\pi R^3} \\int_V r^2 dV = \\frac{1}{\\frac{4}{3}\\pi R^3} \\int_V r^2 dV$$\n注意到密度 $\\rho$ 被消去了，这对于均匀密度物体的回旋半径来说是预料之中的。\n\n接下来，我们计算分子中的积分 $\\int_V r^2 dV$。和之前一样使用球坐标系：\n$$ \\int_V r^2 dV = \\int_{0}^{2\\pi} \\int_{0}^{\\pi} \\int_{0}^{R} (r^2) (r^2 \\sin\\theta dr d\\theta d\\phi) $$\n被积函数中包含了来自 $R_g^2$ 定义的一个额外的因子 $r^2$。\n$$ \\int_V r^2 dV = \\int_{0}^{2\\pi} \\int_{0}^{\\pi} \\int_{0}^{R} r^4 \\sin\\theta dr d\\theta d\\phi $$\n再次，我们分离积分：\n$$ \\int_V r^2 dV = \\left( \\int_{0}^{2\\pi} d\\phi \\right) \\left( \\int_{0}^{\\pi} \\sin\\theta d\\theta \\right) \\left( \\int_{0}^{R} r^4 dr \\right) $$\n角向积分与计算体积时所用的积分相同：\n$$\\int_{0}^{2\\pi} d\\phi = 2\\pi$$\n$$\\int_{0}^{\\pi} \\sin\\theta d\\theta = 2$$\n径向积分现在是：\n$$\\int_{0}^{R} r^4 dr = \\left[ \\frac{r^5}{5} \\right]_{0}^{R} = \\frac{R^5}{5}$$\n将这些结果相乘，得到分子积分的结果：\n$$\\int_V r^2 dV = (2\\pi)(2)\\left(\\frac{R^5}{5}\\right) = \\frac{4}{5}\\pi R^5$$\n\n最后，我们将这个结果和体积的表达式代回到 $R_g^2$ 的方程中：\n$$R_g^2 = \\frac{\\int_V r^2 dV}{\\int_V dV} = \\frac{\\frac{4}{5}\\pi R^5}{\\frac{4}{3}\\pi R^3}$$\n消去公因子 $4$、$\\pi$ 和 $R^3$：\n$$R_g^2 = \\frac{1/5}{1/3} \\frac{R^5}{R^3} = \\frac{3}{5} R^2$$\n因此，一个密度均匀、半径为 $R$ 的实心球体的回旋半径的平方是 $\\frac{3}{5}R^2$。其单位是长度的平方，这与最终量以平方米为单位的说明是一致的。",
            "answer": "$$\\boxed{\\frac{3}{5}R^2}$$"
        },
        {
            "introduction": "最后，我们将把理论知识应用于计算生物学家的实际工作中：分析分子动力学（MD）模拟轨迹。这项实践将要求你处理周期性边界条件（PBC）等实际挑战，并计算 $R_g$ 的时间平均值，以理解分子的柔性和构象变化。通过处理复杂的动态数据集，本练习将巩固你对回旋半径的理论理解并将其转化为实用的计算技能。",
            "id": "3864854",
            "problem": "给定在周期性边界条件 (PBC) 下的简短、合成的分子动力学 (MD) 轨迹，要求您设计并实现一个算法来计算时间平均的质量加权回转半径。该算法必须显式地处理跨帧的坐标解卷绕，以恢复原子轨迹的连续性。您的程序必须为每个轨迹按顺序计算以下内容：PBC 下的坐标解卷绕、每帧的质量加权质心、每帧的质量加权回转半径，以及在所有帧上对回转半径进行的时间平均。所有距离都必须以纳米为单位处理，最终结果必须以纳米为单位报告，并四舍五入到六位小数。输出必须是包含所有测试用例结果的单行，形式为方括号内以逗号分隔的列表。\n\n您应使用的预期科学基础是：\n- 点粒子的质量和位置的定义。\n- 一组点质量的质心的定义。\n- 三维空间中的欧几里得范数。\n- 周期性边界条件 (PBC) 的概念结构，它将沿各轴相差盒子长度整数倍的位置视为等效位置，以及最小镜像约定。\n- 坐标解卷绕的概念，它通过考虑连续帧之间的边界穿越来重构连续轨迹。\n\n您不得从任何定义回转半径的捷径公式开始或引用；相反，应从上述基础推导出算法，包括质量加权质心和位置相对于该中心的离散度。\n\n单位和表示要求：\n- 位置以纳米为单位。\n- 盒子是正交的，各轴长度以纳米为单位给出。\n- 答案必须以纳米表示，四舍五入到六位小数。\n- 本问题不使用角度。\n\n您的算法任务是：\n1. 给定一个轨迹，其中包含帧 $t$ 和原子 $i$ 的位置 $r_{t,i}$，以及盒子长度 $\\ell_x, \\ell_y, \\ell_z$，重构一个在时间上连续的解卷绕轨迹 $\\tilde{r}_{t,i}$。在连续帧之间使用最小镜像逻辑，以便考虑 PBC 后，连续帧之间的每轴位移是最近的位移。时间 $t$ 的解卷绕坐标应通过将校正后的位移加到时间 $t-1$ 的解卷绕坐标上获得。\n2. 对于每一帧 $t$，根据解卷绕后的位置和给定的原子质量计算质量加权质心。\n3. 对于每一帧 $t$，计算点围绕质心的质量加权离散度，作为标量距离度量。\n4. 计算轨迹所有帧上的时间平均标量距离。\n5. 每个轨迹报告一个浮点数，以纳米为单位，四舍五入到六位小数。\n\n用于检验实现的测试套件：\n- 测试用例 $1$（包含多个原子、非均匀质量和边界穿越的正常路径）：\n  - 原子数 $N$：$3$。\n  - 帧数 $T$：$4$。\n  - 盒子长度：$[\\ell_x,\\ell_y,\\ell_z] = [\\,10.0,\\,10.0,\\,10.0\\,]$。\n  - 原子质量（原子质量单位）：$[\\,12.0,\\,1.0,\\,16.0\\,]$。\n  - 每帧的位置（纳米），每行是 $[x,y,z]$：\n    - 第 0 帧：$[\\,9.8,\\,9.9,\\,0.1\\,]$, $[\\,0.2,\\,0.1,\\,0.2\\,]$, $[\\,0.0,\\,9.9,\\,9.8\\,]$。\n    - 第 1 帧：$[\\,0.1,\\,0.0,\\,0.2\\,]$, $[\\,0.4,\\,0.3,\\,0.3\\,]$, $[\\,9.9,\\,0.1,\\,9.9\\,]$。\n    - 第 2 帧：$[\\,0.3,\\,0.2,\\,0.3\\,]$, $[\\,9.9,\\,0.2,\\,0.4\\,]$, $[\\,9.8,\\,0.2,\\,0.0\\,]$。\n    - 第 3 帧：$[\\,0.4,\\,0.4,\\,0.5\\,]$, $[\\,9.7,\\,9.9,\\,0.6\\,]$, $[\\,9.7,\\,0.3,\\,0.2\\,]$。\n- 测试用例 $2$（单个原子的边界条件；无论如何运动，每帧的回转半径都应为零）：\n  - 原子数 $N$：$1$。\n  - 帧数 $T$：$5$。\n  - 盒子长度：$[\\ell_x,\\ell_y,\\ell_z] = [\\,10.0,\\,10.0,\\,10.0\\,]$。\n  - 原子质量（原子质量单位）：$[\\,12.0\\,]$。\n  - 每帧的位置（纳米）：\n    - 第 0 帧：$[\\,5.0,\\,5.0,\\,5.0\\,]$。\n    - 第 1 帧：$[\\,9.9,\\,0.1,\\,0.0\\,]$。\n    - 第 2 帧：$[\\,0.2,\\,0.3,\\,0.4\\,]$。\n    - 第 3 帧：$[\\,0.1,\\,9.8,\\,9.7\\,]$。\n    - 第 4 帧：$[\\,9.9,\\,9.9,\\,9.9\\,]$。\n- 测试用例 $3$（两个等质量原子在穿越边界时保持恒定间距的边缘情况）：\n  - 原子数 $N$：$2$。\n  - 帧数 $T$：$4$。\n  - 盒子长度：$[\\ell_x,\\ell_y,\\ell_z] = [\\,10.0,\\,10.0,\\,10.0\\,]$。\n  - 原子质量（原子质量单位）：$[\\,12.0,\\,12.0\\,]$。\n  - 每帧的位置（纳米），以原子 1 和原子 2 的 $[x,y,z]$ 对给出：\n    - 第 0 帧：$[\\,9.0,\\,0.0,\\,0.0\\,]$, $[\\,5.0,\\,0.0,\\,0.0\\,]$。\n    - 第 1 帧：$[\\,0.5,\\,0.0,\\,0.0\\,]$, $[\\,6.5,\\,0.0,\\,0.0\\,]$。\n    - 第 2 帧：$[\\,1.7,\\,0.0,\\,0.0\\,]$, $[\\,7.7,\\,0.0,\\,0.0\\,]$。\n    - 第 3 帧：$[\\,8.9,\\,0.0,\\,0.0\\,]$, $[\\,4.9,\\,0.0,\\,0.0\\,]$。\n\n您的程序应生成单行输出，其中包含方括号括起来的逗号分隔结果列表（例如，$[\\,r_1,\\,r_2,\\,r_3\\,]$），其中 $r_k$ 是测试用例 $k$ 的时间平均质量加权回转半径（以纳米为单位），四舍五入到六位小数。",
            "solution": "该问题是有效的，因为它在科学上基于经典力学和统计物理学的原理，问题陈述清晰且提供了所有必要信息，并以客观、正式的语言表达。我们将从第一性原理出发，推导并实现所需的算法。\n\n计算时间平均的质量加权回转半径 $R_g$ 的算法需要四个连续步骤：(1) 解卷绕原子坐标以确保轨迹连续性，(2) 计算每帧的质量加权质心，(3) 计算每帧的质量加权回转半径，以及 (4) 对每帧的 $R_g$ 值进行时间平均。\n\n设系统由 $N$ 个原子组成，其质量为 $m_i$，$i \\in \\{1, \\dots, N\\}$。轨迹在 $T$ 帧中给出，对于在帧 $t \\in \\{0, \\dots, T-1\\}$ 的每个原子 $i$，其卷绕位置向量为 $\\boldsymbol{r}_{t,i} \\in \\mathbb{R}^3$。模拟盒子是正交的，其维度向量为 $\\boldsymbol{\\ell} = (\\ell_x, \\ell_y, \\ell_z)$。\n\n**1. 坐标解卷绕**\n\n所提供的坐标 $\\boldsymbol{r}_{t,i}$ 受周期性边界条件 (PBC) 的约束。为了计算像回转半径这样的全局结构属性，我们必须首先在空间中重构一条连续的轨迹。我们将解卷绕后的坐标表示为 $\\tilde{\\boldsymbol{r}}_{t,i}$。\n\n解卷绕过程是迭代的。对于初始帧 $t=0$，我们假设卷绕坐标和解卷绕坐标是相同的：\n$$\n\\tilde{\\boldsymbol{r}}_{0,i} = \\boldsymbol{r}_{0,i} \\quad \\forall i \\in \\{1, \\dots, N\\}\n$$\n对于每个后续帧 $t > 0$，一个原子的解卷绕位置由其在前一帧的解卷绕位置 $\\tilde{\\boldsymbol{r}}_{t-1,i}$ 和在帧 $t-1$ 与 $t$ 之间发生的真实物理位移决定。该位移使用最小镜像约定来计算。\n\n表观位移向量为 $\\Delta\\boldsymbol{r}_{t,i} = \\boldsymbol{r}_{t,i} - \\boldsymbol{r}_{t-1,i}$。由于 PBC，如果穿越了边界，该向量的一个分量（例如 $\\Delta x_{t,i}$）可能不代表最短路径。最小镜像位移 $\\Delta\\tilde{\\boldsymbol{r}}_{t,i}$ 是通过校正表观位移的每个分量来找到的。对于每个轴 $k \\in \\{x, y, z\\}$：\n$$\n\\Delta\\tilde{r}_{t,i,k} = \\Delta r_{t,i,k} - \\ell_k \\cdot \\text{round}\\left( \\frac{\\Delta r_{t,i,k}}{\\ell_k} \\right)\n$$\n其中 `round` 是一个将其参数四舍五入到最近整数的函数。此操作确保校正后位移向量的每个分量都位于区间 $[-\\ell_k/2, \\ell_k/2]$ 内。\n\n然后，通过将此校正后的位移加到前一个解卷绕位置上，来计算原子 $i$ 在帧 $t$ 的解卷绕坐标：\n$$\n\\tilde{\\boldsymbol{r}}_{t,i} = \\tilde{\\boldsymbol{r}}_{t-1,i} + \\Delta\\tilde{\\boldsymbol{r}}_{t,i}\n$$\n对所有原子以及从 $t=1$ 到 $T-1$ 的所有帧重复此过程。\n\n**2. 每帧的质量加权质心**\n\n对于每一帧 $t$，我们使用解卷绕坐标 $\\tilde{\\boldsymbol{r}}_{t,i}$ 计算质量加权质心 $\\tilde{\\boldsymbol{R}}_t$。系统的总质量为 $M = \\sum_{i=1}^{N} m_i$。质心定义为：\n$$\n\\tilde{\\boldsymbol{R}}_t = \\frac{\\sum_{i=1}^{N} m_i \\tilde{\\boldsymbol{r}}_{t,i}}{\\sum_{i=1}^{N} m_i} = \\frac{1}{M} \\sum_{i=1}^{N} m_i \\tilde{\\boldsymbol{r}}_{t,i}\n$$\n\n**3. 每帧的质量加权回转半径**\n\n帧 $t$ 的回转半径 $R_{g,t}$ 是衡量原子空间范围的指标。它被定义为原子到其质心的质量加权均方根距离。回转半径的平方 $R_{g,t}^2$ 是每个原子到质心的欧几里得距离平方的质量加权平均值：\n$$\nR_{g,t}^2 = \\frac{\\sum_{i=1}^{N} m_i ||\\tilde{\\boldsymbol{r}}_{t,i} - \\tilde{\\boldsymbol{R}}_t||^2}{\\sum_{i=1}^{N} m_i} = \\frac{1}{M} \\sum_{i=1}^{N} m_i ||\\tilde{\\boldsymbol{r}}_{t,i} - \\tilde{\\boldsymbol{R}}_t||^2\n$$\n其中 $||\\cdot||$ 表示欧几里得范数。所要求的“标量距离度量”即为回转半径本身，其单位为长度：\n$$\nR_{g,t} = \\sqrt{R_{g,t}^2}\n$$\n\n**4. 时间平均回转半径**\n\n最后，时间平均回转半径 $\\langle R_g \\rangle$ 是轨迹所有 $T$ 帧上每帧 $R_{g,t}$ 值的算术平均值：\n$$\n\\langle R_g \\rangle = \\frac{1}{T} \\sum_{t=0}^{T-1} R_{g,t}\n$$\n根据问题规范，所得值以纳米为单位报告，并四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_average_rg(masses: np.ndarray, positions: np.ndarray, box_lengths: np.ndarray) -> float:\n    \"\"\"\n    Computes the time-averaged, mass-weighted radius of gyration for a trajectory.\n\n    The algorithm performs three main steps:\n    1. Unwraps the trajectory coordinates to handle periodic boundary conditions (PBC).\n    2. For each frame, calculates the mass-weighted center of mass (COM) and then the\n       mass-weighted radius of gyration (Rg).\n    3. Averages the per-frame Rg values over the entire trajectory.\n\n    Args:\n        masses: A 1D numpy array of shape (N,) containing atomic masses.\n        positions: A 3D numpy array of shape (T, N, 3) containing wrapped atomic\n                   positions for T frames and N atoms.\n        box_lengths: A 1D numpy array of shape (3,) with the box dimensions [Lx, Ly, Lz].\n\n    Returns:\n        The time-averaged radius of gyration as a float.\n    \"\"\"\n    num_frames, num_atoms, _ = positions.shape\n\n    # 1. Coordinate Unwrapping\n    unwrapped_pos = np.zeros_like(positions)\n    unwrapped_pos[0] = positions[0]\n\n    for t in range(1, num_frames):\n        delta = positions[t] - positions[t-1]\n        # Apply minimum image convention\n        correction = box_lengths * np.round(delta / box_lengths)\n        unwrapped_delta = delta - correction\n        unwrapped_pos[t] = unwrapped_pos[t-1] + unwrapped_delta\n    \n    # 2. Per-Frame Rg Calculation\n    rg_per_frame = []\n    total_mass = np.sum(masses)\n    \n    if total_mass == 0:\n        return 0.0\n\n    # Reshape masses for broadcasting: from (N,) to (N, 1)\n    masses_reshaped = masses[:, np.newaxis]\n\n    for t in range(num_frames):\n        frame_pos = unwrapped_pos[t]\n        \n        # Calculate mass-weighted center of mass for the frame\n        com = np.sum(frame_pos * masses_reshaped, axis=0) / total_mass\n        \n        # Calculate squared distances from COM\n        dist_sq = np.sum((frame_pos - com)**2, axis=1)\n        \n        # Calculate mass-weighted squared Rg\n        rg_sq = np.sum(masses * dist_sq) / total_mass\n        \n        # Rg is the square root\n        rg = np.sqrt(rg_sq)\n        rg_per_frame.append(rg)\n        \n    # 3. Time-Averaging\n    average_rg = np.mean(rg_per_frame)\n    \n    return average_rg\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the average radius of gyration for each.\n    The final output is a single-line string of comma-separated results\n    rounded to six decimal places, enclosed in square brackets.\n    \"\"\"\n    test_cases = [\n        {\n            \"masses\": np.array([12.0, 1.0, 16.0]),\n            \"positions\": np.array([\n                [[9.8, 9.9, 0.1], [0.2, 0.1, 0.2], [0.0, 9.9, 9.8]],\n                [[0.1, 0.0, 0.2], [0.4, 0.3, 0.3], [9.9, 0.1, 9.9]],\n                [[0.3, 0.2, 0.3], [9.9, 0.2, 0.4], [9.8, 0.2, 0.0]],\n                [[0.4, 0.4, 0.5], [9.7, 9.9, 0.6], [9.7, 0.3, 0.2]],\n            ]),\n            \"box_lengths\": np.array([10.0, 10.0, 10.0])\n        },\n        {\n            \"masses\": np.array([12.0]),\n            \"positions\": np.array([\n                [[5.0, 5.0, 5.0]],\n                [[9.9, 0.1, 0.0]],\n                [[0.2, 0.3, 0.4]],\n                [[0.1, 9.8, 9.7]],\n                [[9.9, 9.9, 9.9]],\n            ]),\n            \"box_lengths\": np.array([10.0, 10.0, 10.0])\n        },\n        {\n            \"masses\": np.array([12.0, 12.0]),\n            \"positions\": np.array([\n                [[9.0, 0.0, 0.0], [5.0, 0.0, 0.0]],\n                [[0.5, 0.0, 0.0], [6.5, 0.0, 0.0]],\n                [[1.7, 0.0, 0.0], [7.7, 0.0, 0.0]],\n                [[8.9, 0.0, 0.0], [4.9, 0.0, 0.0]],\n            ]),\n            \"box_lengths\": np.array([10.0, 10.0, 10.0])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_average_rg(case[\"masses\"], case[\"positions\"], case[\"box_lengths\"])\n        results.append(result)\n\n    # Format the results to exactly six decimal places and join them.\n    formatted_results = ','.join(f\"{r:.6f}\" for r in results)\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        }
    ]
}