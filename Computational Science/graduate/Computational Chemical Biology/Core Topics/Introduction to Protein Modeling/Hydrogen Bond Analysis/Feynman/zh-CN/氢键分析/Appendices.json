{
    "hands_on_practices": [
        {
            "introduction": "在计算化学领域，不同的分子动力学（MD）分析软件包在识别氢键时可能采用略有不同的几何标准。这项实践旨在揭示这些差异的重要性，通过在一个合成的轨迹上实现并比较几种常见的氢键检测算法，让您亲身体验几何阈值（如距离和角度）的选择如何影响最终的分析结果。这项练习将为您奠定坚实的基础，帮助您理解氢键分析并非一个“黑箱”操作，并掌握在周期性边界条件下进行几何计算的核心技能。",
            "id": "3849667",
            "problem": "您的任务是设计并实现一套氢键检测标准的原则性比较，这些标准受到分子动力学 (MD) 分析工具中常见选择的启发。您需要使用单条合成轨迹，并量化检测结果如何随几何阈值和算法规则而变化。场景涉及一个位于立方周期性模拟盒子中的供体-氢-受体三原子组，目标是计算每种算法在所有帧上的氢键占有率，然后比较不同算法之间的占有率。\n\n基本原理：氢键通常使用涉及重原子距离和角度约束的几何标准来检测。在周期性正交模拟单元中，必须使用最近镜像约定来计算位移。请使用以下定义和定律：\n\n- 带最近镜像位移的周期性边界条件：对于立方盒子边长为 $L$ 内的两个位置，其分量分别为 $\\mathbf{r}_1 = (x_1,y_1,z_1)$ 和 $\\mathbf{r}_2 = (x_2,y_2,z_2)$，定义分量位移为\n$$\n\\Delta_i = x_{2,i} - x_{1,i}, \\quad \\Delta_i' =\n\\begin{cases}\n\\Delta_i - L,  \\text{if } \\Delta_i  L/2,\\\\\n\\Delta_i + L,  \\text{if } \\Delta_i  -L/2,\\\\\n\\Delta_i,  \\text{otherwise.}\n\\end{cases}\n$$\n并设置最小镜像位移 $\\Delta \\mathbf{r} = (\\Delta_x',\\Delta_y',\\Delta_z')$。\n- 欧几里得距离：对于任意位移矢量 $\\Delta \\mathbf{r}$，重原子或氢原子的间距为 $r = \\|\\Delta \\mathbf{r}\\| = \\sqrt{\\Delta_x'^2 + \\Delta_y'^2 + \\Delta_z'^2}$。\n- 氢原子处的角度：对于均采用最近镜像约定计算的矢量 $\\mathbf{u} = \\mathbf{r}_\\mathrm{D} - \\mathbf{r}_\\mathrm{H}$ 和 $\\mathbf{v} = \\mathbf{r}_\\mathrm{A} - \\mathbf{r}_\\mathrm{H}$，定义供体-氢-受体角为\n$$\n\\theta = \\arccos\\!\\left(\\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\|\\,\\|\\mathbf{v}\\|}\\right) \\times \\frac{180}{\\pi},\n$$\n以度为单位表示。\n\n氢键占有率：对于一个将每帧的氢键存在与否分类为布尔值的算法，定义其在 $N_f$ 帧上的占有率为\n$$\nO = \\frac{1}{N_f}\\sum_{t=1}^{N_f} \\mathbb{I}_t,\n$$\n其中 $\\mathbb{I}_t$ 是指示函数，如果第 $t$ 帧满足氢键标准，则其值为 $1$，否则为 $0$。占有率是无量纲的，应以小数形式报告。\n\n待比较的算法：\n- 算法 A（重原子距离和角度）：如果在某一帧中，最近镜像氢-受体距离 $r_\\mathrm{HA}$ 满足 $r_\\mathrm{HA} \\le r_\\mathrm{HA}^{\\mathrm{cut}}$ 并且供体-氢-受体角 $\\theta$ 满足 $\\theta \\ge \\theta^{\\mathrm{cut}}$，则存在氢键。\n- 算法 B（仅重原子距离）：如果在某一帧中，最近镜像供体-受体距离 $r_\\mathrm{DA}$ 满足 $r_\\mathrm{DA} \\le r_\\mathrm{DA}^{\\mathrm{cut}}$，则存在氢键。\n- 算法 C（供体-氢键存在性加算法 A）：如果在某一帧中，最近镜像供体-氢距离 $r_\\mathrm{DH}$ 满足 $r_\\mathrm{DH} \\le r_\\mathrm{DH}^{\\mathrm{cut}}$，同时算法 A 的条件 $r_\\mathrm{HA} \\le r_\\mathrm{HA}^{\\mathrm{cut}}$ 和 $\\theta \\ge \\theta^{\\mathrm{cut}}$ 也得到满足，则存在氢键。\n\n轨迹规格：\n- 使用边长为 $L = 10\\,\\mathrm{\\AA}$ 的立方周期性盒子。\n- 轨迹包含 $N_f = 6$ 帧，其中供体 $\\mathbf{r}_\\mathrm{D}(t)$、氢 $\\mathbf{r}_\\mathrm{H}(t)$ 和受体 $\\mathbf{r}_\\mathrm{A}(t)$ 的位置（单位为 $\\mathrm{\\AA}$）如下：\n  - 第 1 帧：$\\mathbf{r}_\\mathrm{D} = (1,1,1)$，$\\mathbf{r}_\\mathrm{H} = (2,1,1)$，$\\mathbf{r}_\\mathrm{A} = (4,1,1)$。\n  - 第 2 帧：$\\mathbf{r}_\\mathrm{D} = (1,1,1)$，$\\mathbf{r}_\\mathrm{H} = (2,1,1)$，$\\mathbf{r}_\\mathrm{A} = (4.6,0.4,1)$。\n  - 第 3 帧：$\\mathbf{r}_\\mathrm{D} = (1,1,1)$，$\\mathbf{r}_\\mathrm{H} = (2,1,1)$，$\\mathbf{r}_\\mathrm{A} = (3.4,1,1)$。\n  - 第 4 帧：$\\mathbf{r}_\\mathrm{D} = (1,1,1)$，$\\mathbf{r}_\\mathrm{H} = (2,1,1)$，$\\mathbf{r}_\\mathrm{A} = (2.9,1,0)$。\n  - 第 5 帧：$\\mathbf{r}_\\mathrm{D} = (9.5,0.5,0.5)$，$\\mathbf{r}_\\mathrm{H} = (0.5,0.5,0.5)$，$\\mathbf{r}_\\mathrm{A} = (2.5,0.5,0.5)$。\n  - 第 6 帧：$\\mathbf{r}_\\mathrm{D} = (9.5,0.5,0.5)$，$\\mathbf{r}_\\mathrm{H} = (0.5,0.5,0.5)$，$\\mathbf{r}_\\mathrm{A} = (1.914213562,1.914213562,0.5)$。\n\n角度单位规格：所有角度必须以度为单位进行计算和比较。所有距离必须以 $\\mathrm{\\AA}$ 为单位进行计算和比较。\n\n输出量化结果：对于每组阈值参数集（测试用例），计算三种占有率 $O_A$、$O_B$ 和 $O_C$，然后将占有率之间的绝对差以列表形式报告\n$$\n\\left[\\,|O_A - O_B|,\\; |O_A - O_C|,\\; |O_B - O_C|\\,\\right].\n$$\n将每个差值四舍五入到三位小数。\n\n测试套件：\n- 用例 1（典型阈值）：$r_\\mathrm{HA}^{\\mathrm{cut}} = 2.5\\,\\mathrm{\\AA}$，$\\theta^{\\mathrm{cut}} = 150\\,\\mathrm{deg}$，$r_\\mathrm{DA}^{\\mathrm{cut}} = 3.2\\,\\mathrm{\\AA}$，$r_\\mathrm{DH}^{\\mathrm{cut}} = 1.05\\,\\mathrm{\\AA}$。\n- 用例 2（严格阈值，包含边界等式）：$r_\\mathrm{HA}^{\\mathrm{cut}} = 2.0\\,\\mathrm{\\AA}$，$\\theta^{\\mathrm{cut}} = 165\\,\\mathrm{deg}$，$r_\\mathrm{DA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$，$r_\\mathrm{DH}^{\\mathrm{cut}} = 1.0\\,\\mathrm{\\AA}$。\n- 用例 3（宽松阈值，包含角度边界）：$r_\\mathrm{HA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$，$\\theta^{\\mathrm{cut}} = 135\\,\\mathrm{deg}$，$r_\\mathrm{DA}^{\\mathrm{cut}} = 3.5\\,\\mathrm{\\AA}$，$r_\\mathrm{DH}^{\\mathrm{cut}} = 1.2\\,\\mathrm{\\AA}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含三个测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个元素本身是该用例的三个四舍五入绝对差的列表，不含空格。例如：$[[d_{11},d_{12},d_{13}],[d_{21},d_{22},d_{23}],[d_{31},d_{32},d_{33}]]$，需严格按单行格式打印，如 \"[[0.333,0.000,0.333],[...],[...]]\"。",
            "solution": "该问题是有效的。其科学基础在于计算化学生物学的原理，特别是分子动力学轨迹中氢键的几何分析。问题中的定义、数据和目标都是自洽、一致且适定的，可以得出一个唯一且可验证的解。\n\n求解过程主要分为三个阶段：\n1.  对于合成轨迹中的 $N_f = 6$ 帧中的每一帧，我们计算关键的几何参数：供体-受体距离 ($r_\\mathrm{DA}$)、氢-受体距离 ($r_\\mathrm{HA}$)、供体-氢距离 ($r_\\mathrm{DH}$) 以及供体-氢-受体角 ($\\theta$)。这些计算必须严格遵守边长为 $L = 10\\,\\mathrm{\\AA}$ 的指定周期性立方盒子的最近镜像约定。\n2.  对于提供不同截断阈值组的三个测试用例中的每一个，我们遍历每一帧预先计算好的几何参数。我们应用算法 A、B 和 C 的逻辑标准，来判断在该帧中根据每种算法是否存在氢键。\n3.  在对给定测试用例的所有帧进行分类后，我们计算每种算法的占有率 $O$，即检测到氢键的帧数所占的比例。最后，我们计算这些占有率之间所需的绝对差 $|O_A - O_B|$、 $|O_A - O_C|$ 和 $|O_B - O_C|$，并将它们四舍五入到三位小数。\n\n**步骤 1：几何参数的计算**\n\n我们根据问题陈述定义了三个辅助函数，用于计算最小镜像位移、距离和角度。\n\n在边长为 $L$ 的立方盒子中，两个位置矢量 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$ 之间的最小镜像位移 $\\Delta \\mathbf{r}'$ 是按分量计算的。对于每个分量 $i \\in \\{x, y, z\\}$：\n$$\n\\Delta_i = x_{2,i} - x_{1,i}\n$$\n$$\n\\Delta_i' =\n\\begin{cases}\n\\Delta_i - L,  \\text{if } \\Delta_i  L/2 \\\\\n\\Delta_i + L,  \\text{if } \\Delta_i  -L/2 \\\\\n\\Delta_i,  \\text{otherwise.}\n\\end{cases}\n$$\n\n距离 $r$ 是所得位移矢量的欧几里得范数，$r = \\|\\Delta \\mathbf{r}'\\|$。矢量 $\\mathbf{u} = \\mathbf{r}_\\mathrm{D} - \\mathbf{r}_\\mathrm{H}$ 和 $\\mathbf{v} = \\mathbf{r}_\\mathrm{A} - \\mathbf{r}_\\mathrm{H}$（两者均使用最近镜像约定计算）之间的角度 $\\theta$ 由 $\\theta = \\arccos(\\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\|\\|\\mathbf{v}\\|})$ 给出，并转换为度。\n\n将这些定义应用于轨迹数据（$L=10\\,\\mathrm{\\AA}$，$N_f=6$ 帧），可得到每帧的以下几何参数：\n\n| 帧 | $r_\\mathrm{DA}$ ($\\mathrm{\\AA}$) | $r_\\mathrm{HA}$ ($\\mathrm{\\AA}$) | $r_\\mathrm{DH}$ ($\\mathrm{\\AA}$) | $\\theta$ (度) |\n|---|---|---|---|---|\n| $1$ | $3.0$ | $2.0$ | $1.0$ | $180.0$ |\n| $2$ | $\\sqrt{13.32} \\approx 3.650$ | $\\sqrt{7.12} \\approx 2.668$ | $1.0$ | $166.99$ |\n| $3$ | $2.4$ | $1.4$ | $1.0$ | $180.0$ |\n| $4$ | $\\sqrt{4.61} \\approx 2.147$ | $\\sqrt{1.81} \\approx 1.345$ | $1.0$ | $132.01$ |\n| $5$ | $3.0$ | $2.0$ | $1.0$ | $180.0$ |\n| $6$ | $\\sqrt{5+2\\sqrt{2}} \\approx 2.798$ | $2.0$ | $1.0$ | $135.0$ |\n\n请注意，对于第 5 帧和第 6 帧，粒子的位置必须应用最近镜像约定。例如，在第 5 帧中，D-A 的直接位移是 $\\Delta\\mathbf{r} = (2.5-9.5, 0, 0) = (-7,0,0)$。由于 $\\Delta_x = -7  -L/2 = -5$，修正后的位移为 $\\Delta\\mathbf{r}' = (-7+10, 0, 0) = (3,0,0)$，得出 $r_\\mathrm{DA}=3.0\\,\\mathrm{\\AA}$。\n\n**步骤 2 和 3：算法的应用与差异的计算**\n\n现在，我们使用上表中的几何数据来处理每个测试用例。\n\n**测试用例 1：** ($r_\\mathrm{HA}^{\\mathrm{cut}} = 2.5\\,\\mathrm{\\AA}$，$\\theta^{\\mathrm{cut}} = 150^\\circ$，$r_\\mathrm{DA}^{\\mathrm{cut}} = 3.2\\,\\mathrm{\\AA}$，$r_\\mathrm{DH}^{\\mathrm{cut}} = 1.05\\,\\mathrm{\\AA}$)\n\n- **算法 A ($r_\\mathrm{HA} \\le 2.5$ 且 $\\theta \\ge 150^\\circ$)：** 第 1、3、5 帧满足标准。计数 = $3$。\n- **算法 B ($r_\\mathrm{DA} \\le 3.2$)：** 第 1、3、4、5、6 帧满足标准。计数 = $5$。\n- **算法 C ($r_\\mathrm{DH} \\le 1.05$ 且符合算法 A)：** 所有帧都满足 $r_\\mathrm{DH}$ 的条件（$1.0 \\le 1.05$）。因此，这等同于算法 A。第 1、3、5 帧满足标准。计数 = $3$。\n\n占有率：\n- $O_A = 3/6 = 0.5$\n- $O_B = 5/6 \\approx 0.8333$\n- $O_C = 3/6 = 0.5$\n\n差异：\n- $|O_A - O_B| = |0.5 - 5/6| = 1/3 \\approx 0.333$\n- $|O_A - O_C| = |0.5 - 0.5| = 0.0$\n- $|O_B - O_C| = |5/6 - 0.5| = 1/3 \\approx 0.333$\n结果：$[0.333, 0.000, 0.333]$\n\n**测试用例 2：** ($r_\\mathrm{HA}^{\\mathrm{cut}} = 2.0\\,\\mathrm{\\AA}$，$\\theta^{\\mathrm{cut}} = 165^\\circ$，$r_\\mathrm{DA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$，$r_\\mathrm{DH}^{\\mathrm{cut}} = 1.0\\,\\mathrm{\\AA}$)\n\n- **算法 A ($r_\\mathrm{HA} \\le 2.0$ 且 $\\theta \\ge 165^\\circ$)：** 第 1、3、5 帧满足标准。计数 = $3$。\n- **算法 B ($r_\\mathrm{DA} \\le 3.0$)：** 第 1、3、4、5、6 帧满足标准。计数 = $5$。\n- **算法 C ($r_\\mathrm{DH} \\le 1.0$ 且符合算法 A)：** 所有帧都满足 $r_\\mathrm{DH}$ 的条件（$1.0 \\le 1.0$）。这等同于算法 A。第 1、3、5 帧满足标准。计数 = $3$。\n\n占有率和差异与用例 1 相同。\n结果：$[0.333, 0.000, 0.333]$\n\n**测试用例 3：** ($r_\\mathrm{HA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$，$\\theta^{\\mathrm{cut}} = 135^\\circ$，$r_\\mathrm{DA}^{\\mathrm{cut}} = 3.5\\,\\mathrm{\\AA}$，$r_\\mathrm{DH}^{\\mathrm{cut}} = 1.2\\,\\mathrm{\\AA}$)\n\n- **算法 A ($r_\\mathrm{HA} \\le 3.0$ 且 $\\theta \\ge 135^\\circ$)：** 第 1、2、3、5、6 帧满足标准。计数 = $5$。\n- **算法 B ($r_\\mathrm{DA} \\le 3.5$)：** 第 1、3、4、5、6 帧满足标准。计数 = $5$。\n- **算法 C ($r_\\mathrm{DH} \\le 1.2$ 且符合算法 A)：** 所有帧都满足 $r_\\mathrm{DH}$ 的条件（$1.0 \\le 1.2$）。这等同于算法 A。第 1、2、3、5、6 帧满足标准。计数 = $5$。\n\n占有率：\n- $O_A = 5/6 \\approx 0.8333$\n- $O_B = 5/6 \\approx 0.8333$\n- $O_C = 5/6 \\approx 0.8333$\n\n差异：\n- $|O_A - O_B| = |5/6 - 5/6| = 0.0$\n- $|O_A - O_C| = |5/6 - 5/6| = 0.0$\n- $|O_B - O_C| = |5/6 - 5/6| = 0.0$\n结果：$[0.000, 0.000, 0.000]$\n\n根据问题规范，这些结果将被格式化为单行，作为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import sqrt, acos, degrees\n\ndef solve():\n    \"\"\"\n    Solves the hydrogen bond analysis problem by calculating occupancies\n    for three different algorithms across a synthetic trajectory and\n    reporting the differences between them for three test cases.\n    \"\"\"\n\n    # --- Data Definition ---\n\n    # Trajectory data: (r_D, r_H, r_A) for each frame\n    trajectory = [\n        # Frame 1\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([4.0, 1.0, 1.0])),\n        # Frame 2\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([4.6, 0.4, 1.0])),\n        # Frame 3\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([3.4, 1.0, 1.0])),\n        # Frame 4\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([2.9, 1.0, 0.0])),\n        # Frame 5\n        (np.array([9.5, 0.5, 0.5]), np.array([0.5, 0.5, 0.5]), np.array([2.5, 0.5, 0.5])),\n        # Frame 6\n        (np.array([9.5, 0.5, 0.5]), np.array([0.5, 0.5, 0.5]), np.array([1.914213562, 1.914213562, 0.5])),\n    ]\n    L = 10.0  # Box side length in Angstrom\n    N_f = len(trajectory)\n\n    # Test cases: (r_HA_cut, theta_cut, r_DA_cut, r_DH_cut)\n    test_cases = [\n        # Case 1 (typical)\n        (2.5, 150.0, 3.2, 1.05),\n        # Case 2 (strict)\n        (2.0, 165.0, 3.0, 1.0),\n        # Case 3 (loose)\n        (3.0, 135.0, 3.5, 1.2),\n    ]\n\n    # --- Helper Functions ---\n\n    def nearest_image_displacement(r2, r1, box_L):\n        \"\"\"Calculates the minimum image displacement vector from r1 to r2.\"\"\"\n        delta = r2 - r1\n        half_L = box_L / 2.0\n        # This explicit loop correctly implements the problem's definition\n        for i in range(len(delta)):\n            if delta[i] > half_L:\n                delta[i] -= box_L\n            elif delta[i]  -half_L:\n                delta[i] += box_L\n        return delta\n\n    # --- Main Logic ---\n\n    all_results = []\n    \n    for case in test_cases:\n        r_HA_cut, theta_cut, r_DA_cut, r_DH_cut = case\n        \n        h_bond_count_A = 0\n        h_bond_count_B = 0\n        h_bond_count_C = 0\n\n        for frame_coords in trajectory:\n            r_D, r_H, r_A = frame_coords\n\n            # Calculate geometric quantities for the frame\n            # Distances\n            dr_DA = nearest_image_displacement(r_A, r_D, L)\n            r_DA = np.linalg.norm(dr_DA)\n\n            dr_HA = nearest_image_displacement(r_A, r_H, L)\n            r_HA = np.linalg.norm(dr_HA)\n\n            dr_DH = nearest_image_displacement(r_H, r_D, L)\n            r_DH = np.linalg.norm(dr_DH)\n            \n            # Angle D-H-A\n            # Vector u from H to D\n            u = nearest_image_displacement(r_D, r_H, L)\n            # Vector v from H to A\n            v = dr_HA # This is already r_A - r_H with PBC\n            \n            norm_u = np.linalg.norm(u)\n            norm_v = r_HA\n            \n            # Prevent division by zero if atoms overlap\n            if norm_u > 1e-9 and norm_v > 1e-9:\n                dot_product = np.dot(u, v)\n                cosine_angle = dot_product / (norm_u * norm_v)\n                # Clip to handle floating point inaccuracies\n                cosine_angle = np.clip(cosine_angle, -1.0, 1.0)\n                angle = degrees(acos(cosine_angle))\n            else:\n                angle = 0.0\n\n            # Apply algorithm criteria\n            # Algorithm A\n            is_hbond_A = (r_HA = r_HA_cut) and (angle >= theta_cut)\n            if is_hbond_A:\n                h_bond_count_A += 1\n            \n            # Algorithm B\n            if r_DA = r_DA_cut:\n                h_bond_count_B += 1\n            \n            # Algorithm C\n            if (r_DH = r_DH_cut) and is_hbond_A:\n                h_bond_count_C += 1\n\n        # Calculate occupancies\n        O_A = h_bond_count_A / N_f\n        O_B = h_bond_count_B / N_f\n        O_C = h_bond_count_C / N_f\n        \n        # Calculate and round absolute differences\n        diff_AB = abs(O_A - O_B)\n        diff_AC = abs(O_A - O_C)\n        diff_BC = abs(O_B - O_C)\n        \n        all_results.append([diff_AB, diff_AC, diff_BC])\n\n    # --- Final Output Formatting ---\n    # According to the specified format \"[[d1,d2,d3],[...]]\"\n    inner_results_str = []\n    for R in all_results:\n        # Format numbers to 3 decimal places\n        formatted_diffs = [f\"{d:.3f}\" for d in R]\n        inner_results_str.append(f\"[{','.join(formatted_diffs)}]\")\n    \n    final_output = f\"[{','.join(inner_results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "真实的生物分子体系中，氢键网络远比简单的“供体-受体”对要复杂，例如，一个供体氢原子可能同时与多个受体形成“分岔氢键”。简单的二元（是/否）判断标准在这种情况下往往力不从心。这项实践将引导您设计一个更精密的检测方案，该方案不仅包含硬性的几何约束，还引入了一个连续的评分函数来量化潜在氢键的“质量”，并通过冲突解决策略来确定最可能的成键模式。通过解决这个问题 ，您将从简单的分类思维过渡到基于优化和评分的模式识别，这对于处理复杂的结构生物学问题至关重要。",
            "id": "3849664",
            "problem": "您需要从第一性原理出发，实现一个稳健的氢键计算检测方案。该方案通过定义多个相互竞争的几何约束和一种有原则的冲突解决方案，明确地处理单个氢供体上的分叉情况。工作将在三维欧几里得空间中进行，所有距离以埃（ångström）为单位，所有角度以度为单位。该方案涉及一个供体原子 $D$、其共价键合的氢原子 $H$ 以及一组候选受体原子 $A_i$，其中索引 $i \\in \\{0,1,\\dots,n-1\\}$。\n\n必须使用的基本出发点和定义：\n- 使用欧几里得范数测量距离，使用点积测量角度。距离和角度是基本的几何量，必须根据 $D$、$H$ 和 $A_i$ 在三维空间中的位置导出。\n- 氢原子处的角度，记为 $\\theta_{DHA,i}$，必须定义为向量 $H \\rightarrow D$ 和 $H \\rightarrow A_i$ 之间的夹角，这捕捉了氢键的线性偏好。\n- 氢到受体的距离，记为 $r_{HA,i}$，以及供体到受体的距离，记为 $r_{DA,i}$，都必须根据原子的位置计算得出。\n\n需要实现的氢键检测标准：\n1. 对每个受体 $A_i$ 的硬性几何可行性：\n   - 氢-受体距离 $r_{HA,i}$ 必须位于物理上合理的范围 $[r_{\\text{min}}, r_{\\text{max}}]$ 内，其中 $r_{\\text{min}} = 1.4$ 且 $r_{\\text{max}} = 2.5$（单位：埃）。\n   - 供体-受体距离 $r_{DA,i}$ 必须位于合理的范围 $[d_{\\text{min}}, d_{\\text{max}}]$ 内，其中 $d_{\\text{min}} = 2.5$ 且 $d_{\\text{max}} = 3.5$（单位：埃）。\n   - 角度 $\\theta_{DHA,i}$ 必须至少为 $\\theta_{\\text{min}} = 130$（单位：度）。\n   任何不满足这些硬性条件中任意一条的受体将不被进一步考虑。\n2. 分叉相容性：\n   - 一个氢原子最多可以同时形成两个氢键。如果同时选择了两个受体 $A_i$ 和 $A_j$，则在氢原子处，向量 $H \\rightarrow A_i$ 和 $H \\rightarrow A_j$ 之间的分离角（记为 $\\phi_{ij}$）必须至少为 $\\phi_{\\text{min}} = 12$（单位：度）。\n3. 用于冲突解决的评分：\n   - 每个几何上可行的受体 $A_i$ 必须获得一个连续分数 $S_i$。当 $r_{HA,i}$ 和 $r_{DA,i}$ 偏离典型值以及 $\\theta_{DHA,i}$ 偏离理想线性构型时，该分数会降低。分数必须基于一个指数惩罚函数，该函数由与物理合理目标值的平方偏差构建而成，且不引入不连续性。使用的目标值为 $r_0 = 1.8$（单位：埃）、$d_0 = 3.0$（单位：埃）和 $\\theta_0 = 180$（单位：度）。设定偏差尺度的标准差为 $\\sigma_r = 0.2$（单位：埃）、$\\sigma_d = 0.3$（单位：埃）和 $\\sigma_\\theta = 10$（单位：度）。此外，还需包含一个基于供体-氢共价键长 $r_{DH}$ 的惩罚项，其目标值为 $r_{DH,0} = 1.0$（单位：埃），尺度为 $\\sigma_{DH} = 0.05$（单位：埃），并采用相同的指数平方偏差原理。供体-氢共价键长必须根据 $D$ 和 $H$ 为每个案例计算一次。\n4. 冲突解决：\n   - 从几何上可行的受体集合中，选择一个大小最多为二的子集，该子集在满足任意选定对 $(i,j)$ 的分离角约束 $\\phi_{ij} \\ge \\phi_{\\text{min}}$ 的前提下，使分数总和 $\\sum S_i$ 最大化。如果没有一对受体满足分离约束，则选择分数最高的单个受体。如果分数总和出现平局，则选择其排序后的索引列表在字典序上最小的子集。\n\n您的程序必须实现以上所有内容，并将其应用于以下测试套件。每个测试用例由 $D$、$H$ 的位置以及受体位置 $A_i$ 的列表指定。所有坐标均以埃为单位。对于所有用例，使用上文指定的相同参数值和相同的角度单位（度）：\n\n测试用例 1（理想情况，两个相容的受体）：\n- $D = (0.0, 0.0, 0.0)$\n- $H = (1.0, 0.0, 0.0)$\n- $A_0 = (2.8, 0.2, 0.0)$, $A_1 = (2.6, -0.2, 0.0)$\n\n测试用例 2（三个受体，选择最佳分叉对）：\n- $D = (0.0, 0.0, 0.0)$\n- $H = (1.0, 0.0, 0.0)$\n- $A_0 = (2.8, 0.2, 0.0)$, $A_1 = (2.6, -0.2, 0.0)$, $A_2 = (2.45, 0.8, 0.0)$\n\n测试用例 3（边界角和不合格的距离）：\n- $D = (0.0, 0.0, 0.0)$\n- $H = (1.0, 0.0, 0.0)$\n- $A_0 = (2.157, 1.379, 0.0)$, $A_1 = (3.6, 0.0, 0.0)$\n\n测试用例 4（因分离角过小而冲突，选择单个最佳受体）：\n- $D = (0.0, 0.0, 0.0)$\n- $H = (1.0, 0.0, 0.0)$\n- $A_0 = (2.8, 0.2, 0.0)$, $A_1 = (2.7, 0.0, 0.0)$\n\n最终输出规范：\n- 对每个测试用例，按升序输出所选受体的索引列表，该列表为整数列表，每个用例最多包含两个元素。将所有测试用例的结果汇总到一行，形式为方括号括起来的逗号分隔列表，其中每个用例的列表也用自己的方括号括起来。例如，四个用例的输出可能看起来像 `[[0,1],[2,3],[1],[0]]`。您的程序必须严格按照此格式生成一行输出。",
            "solution": "该问题要求实现一种计算算法，用于识别单个供体-氢系统（$D-H$）与多个潜在受体原子（$A_i$）相互作用时形成的氢键，包括分叉氢键。解决方案将遵循指定的几何可行性、评分和冲突解决标准进行开发。所有数学实体均按要求使用 LaTeX 渲染。\n\n首先，我们在三维欧几里得空间中建立必要的几何形式体系。原子 $D$、$H$ 和 $A_i$ 的位置以 $\\mathbb{R}^3$ 中的向量形式给出，分别记为 $\\vec{p}_D$、$\\vec{p}_H$ 和 $\\vec{p}_{A,i}$。\n\n两个原子（例如 $P_1$ 和 $P_2$）之间的距离是连接它们的向量的欧几里得范数：\n$$ d(P_1, P_2) = \\| \\vec{p}_{P_2} - \\vec{p}_{P_1} \\| = \\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2 + (z_2-z_1)^2} $$\n\n由三个原子形成的角，例如在原子 $P_2$ 处、原子 $P_1$ 和 $P_3$ 之间的角 $\\alpha$，是通过源自 $P_2$ 的向量 $\\vec{v}_1 = \\vec{p}_{P_1} - \\vec{p}_{P_2}$ 和 $\\vec{v}_2 = \\vec{p}_{P_3} - \\vec{p}_{P_2}$ 的点积计算得出的。\n$$ \\alpha = \\arccos\\left( \\frac{\\vec{v}_1 \\cdot \\vec{v}_2}{\\|\\vec{v}_1\\| \\|\\vec{v}_2\\|} \\right) $$\n$\\arccos$ 函数的结果以弧度为单位，必须转换为度才能与给定的角度阈值进行比较：$\\alpha_{\\text{deg}} = \\alpha_{\\text{rad}} \\times \\frac{180}{\\pi}$。\n\n该算法主要分三个阶段进行：\n\n**1. 可行性分析**\n\n对于每个候选受体 $A_i$，我们评估一组硬性几何约束。一个受体必须满足以下所有条件，才能被视为形成氢键的可行候选者：\n\n*   **氢-受体距离 ($r_{HA,i}$):** 氢原子 $H$ 和受体原子 $A_i$ 之间的距离必须在指定范围内。\n    $$ r_{HA,i} = d(H, A_i) \\quad | \\quad r_{\\text{min}} \\le r_{HA,i} \\le r_{\\text{max}} $$\n    其中 $r_{\\text{min}} = 1.4$ Å 且 $r_{\\text{max}} = 2.5$ Å。\n\n*   **供体-受体距离 ($r_{DA,i}$):** 供体原子 $D$ 和受体原子 $A_i$ 之间的距离必须在其允许范围内。\n    $$ r_{DA,i} = d(D, A_i) \\quad | \\quad d_{\\text{min}} \\le r_{DA,i} \\le d_{\\text{max}} $$\n    其中 $d_{\\text{min}} = 2.5$ Å 且 $d_{\\text{max}} = 3.5$ Å。\n\n*   **氢键角 ($\\theta_{DHA,i}$):** 氢原子处的角度必须表明构型接近线性。该角度定义为从 $H$ 到 $D$ 的向量（$\\vec{HD} = \\vec{p}_D - \\vec{p}_H$）与从 $H$ 到 $A_i$ 的向量（$\\vec{HA_i} = \\vec{p}_{A,i} - \\vec{p}_H$）之间的夹角。\n    $$ \\theta_{DHA,i} = \\text{angle}(D, H, A_i) \\quad | \\quad \\theta_{DHA,i} \\ge \\theta_{\\text{min}} $$\n    其中 $\\theta_{\\text{min}} = 130$ 度。\n\n任何未能满足这三个标准中任意一个的受体 $A_i$ 都将被舍弃，不再进一步考虑。\n\n**2. 可行受体的评分**\n\n每个可行的受体 $A_i$都被赋予一个分数 $S_i$，用于量化潜在氢键的质量。分数越高，表示几何构型越理想。该分数定义为一个指数函数，其变量是与理想目标值的缩放平方偏差之和。\n\n首先，对每个测试用例计算一次供体-氢共价键长 $r_{DH} = d(D, H)$。\n\n然后，一个可行受体 $A_i$ 的分数 $S_i$ 由下式给出：\n$$ S_i = \\exp\\left( - \\left[ \\left(\\frac{r_{DH} - r_{DH,0}}{\\sigma_{DH}}\\right)^2 + \\left(\\frac{r_{HA,i} - r_0}{\\sigma_r}\\right)^2 + \\left(\\frac{r_{DA,i} - d_0}{\\sigma_d}\\right)^2 + \\left(\\frac{\\theta_{DHA,i} - \\theta_0}{\\sigma_\\theta}\\right)^2 \\right] \\right) $$\n评分函数的参数为：\n*   理想氢-受体距离：$r_0 = 1.8$ Å，尺度：$\\sigma_r = 0.2$ Å。\n*   理想供体-受体距离：$d_0 = 3.0$ Å，尺度：$\\sigma_d = 0.3$ Å。\n*   理想氢键角：$\\theta_0 = 180$ 度，尺度：$\\sigma_\\theta = 10$ 度。\n*   理想供体-氢距离：$r_{DH,0} = 1.0$ Å，尺度：$\\sigma_{DH} = 0.05$ Å。\n\n该公式产生一个介于 $0$ 和 $1$ 之间的连续分数，其中分数 $1$ 表示在所有度量上都达到了完美的理想几何构型。\n\n**3. 冲突解决与选择**\n\n最后一步是选择最佳的氢键受体集合，最多为两个（一个分叉键）。这是一个最大化问题，受空间约束和一个明确的平局决胜规则限制。\n\n总体策略是生成所有可能的有效解（受体子集），计算它们的总分，然后选择最佳的一个。\n\n*   **候选者生成：**\n    1.  **单受体候选者：** 对于每个分数为 $S_i$ 的可行受体 $A_i$，单元素集合 $\\{i\\}$ 是一个候选解。其总分为 $S_i$。\n    2.  **双受体候选者：** 对于每一对不同的可行受体 $(A_i, A_j)$（其中 $i  j$），我们必须检查其分叉相容性。这要求氢原子处的分离角 $\\phi_{ij}$ 足够大。角度 $\\phi_{ij}$ 由向量 $\\vec{HA_i}$ 和 $\\vec{HA_j}$ 构成。\n        $$ \\phi_{ij} = \\text{angle}(A_i, H, A_j) \\ge \\phi_{\\text{min}} $$\n        其中 $\\phi_{\\text{min}} = 12$ 度。如果满足此条件，则集合 $\\{i, j\\}$ 是一个有效的候选解。其总分是单个分数的总和，$S_i + S_j$。\n\n*   **最优选择：**\n    从所有有效的单受体和双受体候选者的集合中，我们必须选择总分最大的那个。\n    *   让每个候选者表示为一个元组 `(total_score, sorted_index_list)`。例如，单受体候选者为 $(S_i, [i])$，双受体候选者为 $(S_i+S_j, [i, j])$。\n    *   最优解对应于此集合中的最大元组。Python 的默认元组比较非常适合此任务：它首先比较第一个元素（`total_score`），如果出现平局，则继续比较第二个元素（`sorted_index_list`）。按字典序比较列表正确地实现了指定的平局决胜规则。\n    *   如果在第一步中没有受体被认为是可行的，则结果集为空。\n\n这一系统性流程保证了根据问题标准得出一个唯一的最优解。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for hydrogen bond detection.\n    \"\"\"\n\n    # Define physical and geometric parameters as per the problem statement.\n    params = {\n        'r_min': 1.4, 'r_max': 2.5,  # Angstrom\n        'd_min': 2.5, 'd_max': 3.5,  # Angstrom\n        'theta_min': 130.0,         # Degrees\n        'phi_min': 12.0,            # Degrees\n        'r0': 1.8, 'sigma_r': 0.2,   # Angstrom\n        'd0': 3.0, 'sigma_d': 0.3,   # Angstrom\n        'theta0': 180.0, 'sigma_theta': 10.0, # Degrees\n        'r_dh0': 1.0, 'sigma_dh': 0.05 # Angstrom\n    }\n\n    # Define test cases. Each case is a tuple (D_pos, H_pos, A_pos_list).\n    test_cases = [\n        (np.array([0.0, 0.0, 0.0]), np.array([1.0, 0.0, 0.0]), [np.array([2.8, 0.2, 0.0]), np.array([2.6, -0.2, 0.0])]),\n        (np.array([0.0, 0.0, 0.0]), np.array([1.0, 0.0, 0.0]), [np.array([2.8, 0.2, 0.0]), np.array([2.6, -0.2, 0.0]), np.array([2.45, 0.8, 0.0])]),\n        (np.array([0.0, 0.0, 0.0]), np.array([1.0, 0.0, 0.0]), [np.array([2.157, 1.379, 0.0]), np.array([3.6, 0.0, 0.0])]),\n        (np.array([0.0, 0.0, 0.0]), np.array([1.0, 0.0, 0.0]), [np.array([2.8, 0.2, 0.0]), np.array([2.7, 0.0, 0.0])]),\n    ]\n    \n    final_results = []\n    for case in test_cases:\n        D, H, A_list = case\n        result = process_case(D, H, A_list, params)\n        final_results.append(result)\n\n    # Format the output as specified: \"[[0,1],[2],[0]]\"\n    output_str = f\"[{','.join([str(r).replace(' ', '') for r in final_results])}]\"\n    print(output_str)\n\ndef get_angle(p1, p2, p3):\n    \"\"\"Calculates the angle in degrees at p2 between vectors p2-p1 and p2-p3.\"\"\"\n    v1 = p1 - p2\n    v2 = p3 - p2\n    \n    v1_norm = np.linalg.norm(v1)\n    v2_norm = np.linalg.norm(v2)\n    \n    if v1_norm == 0 or v2_norm == 0:\n        return 0.0 # Or handle as an error, though not expected here.\n\n    # Clamp dot_product / (norms) to [-1, 1] to avoid floating point errors with arccos\n    cos_theta = np.dot(v1, v2) / (v1_norm * v2_norm)\n    cos_theta_clamped = np.clip(cos_theta, -1.0, 1.0)\n    \n    angle_rad = np.arccos(cos_theta_clamped)\n    return np.degrees(angle_rad)\n\ndef process_case(D, H, A_list, params):\n    \"\"\"\n    Processes a single test case for hydrogen bond detection.\n    \"\"\"\n    \n    # --- 1. Feasibility Analysis ---\n    feasible_acceptors = []\n    for i, A_i in enumerate(A_list):\n        r_da = np.linalg.norm(A_i - D)\n        r_ha = np.linalg.norm(A_i - H)\n        theta_dha = get_angle(D, H, A_i)\n        \n        if (params['d_min'] = r_da = params['d_max'] and\n            params['r_min'] = r_ha = params['r_max'] and\n            theta_dha >= params['theta_min']):\n            \n            feasible_acceptors.append({\n                'index': i,\n                'pos': A_i,\n                'r_da': r_da,\n                'r_ha': r_ha,\n                'theta_dha': theta_dha\n            })\n\n    if not feasible_acceptors:\n        return []\n\n    # --- 2. Scoring ---\n    r_dh = np.linalg.norm(H - D)\n    r_dh_term = ((r_dh - params['r_dh0']) / params['sigma_dh'])**2\n\n    for acc in feasible_acceptors:\n        r_ha_term = ((acc['r_ha'] - params['r0']) / params['sigma_r'])**2\n        r_da_term = ((acc['r_da'] - params['d0']) / params['sigma_d'])**2\n        theta_term = ((acc['theta_dha'] - params['theta0']) / params['sigma_theta'])**2\n        \n        total_penalty = r_dh_term + r_ha_term + r_da_term + theta_term\n        acc['score'] = np.exp(-total_penalty)\n    \n    # --- 3. Conflict Resolution and Selection ---\n    candidate_solutions = []\n\n    # Add single-acceptor candidates\n    for acc in feasible_acceptors:\n        candidate_solutions.append((acc['score'], [acc['index']]))\n        \n    # Add two-acceptor candidates\n    if len(feasible_acceptors) >= 2:\n        for i in range(len(feasible_acceptors)):\n            for j in range(i + 1, len(feasible_acceptors)):\n                acc1 = feasible_acceptors[i]\n                acc2 = feasible_acceptors[j]\n                \n                # Check separation angle constraint\n                phi_ij = get_angle(acc1['pos'], H, acc2['pos'])\n                \n                if phi_ij >= params['phi_min']:\n                    total_score = acc1['score'] + acc2['score']\n                    indices = sorted([acc1['index'], acc2['index']])\n                    candidate_solutions.append((total_score, indices))\n    \n    # Find the best candidate\n    # Python's max() on a list of tuples automatically handles the required logic:\n    # it sorts by the first element (score), and on ties, by the second (lexicographical list).\n    if not candidate_solutions:\n        return []\n    \n    best_solution = max(candidate_solutions)\n    return best_solution[1]\n\n# Execute the solver.\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "识别出氢键之后，我们常常希望将其与体系的物理性质，如稳定性和动力学，联系起来。然而，这些推导出的物理量在多大程度上依赖于我们最初选择的检测标准呢？这项实践将几何定义与氢键的能量和寿命等物理模型直接关联，并要求您进行灵敏度分析，以量化这些物理预测值对几何阈值变化的稳健性。这个练习  强调了科学建模的一个批判性思维：理解并评估模型预测对其基本参数的敏感性和不确定性，从而在结构描述和物理化学之间架起一座桥梁。",
            "id": "3849643",
            "problem": "你的任务是通过执行灵敏度分析，评估一个计算氢键检测模型对于几何检测阈值变化的鲁棒性，并报告其对预测能量和寿命的影响。背景是计算化学生物学中的氢键分析，你需要从第一性原理出发进行推导。\n\n从以下在物理化学和化学生物学中被广泛接受的基本原理开始：\n- 氢键强度随着供体-氢-受体角趋于线性而增加，随着供体-受体距离的增加而减小。这种方向性可以用一个依赖于供体-氢-受体角的取向因子来表示。\n- 与氢键相关的轨道重叠随分离距离近似呈指数衰减，这为有效相互作用强度对距离的指数依赖性提供了依据。\n- 氢键的热解离可以使用 Arrhenius 或类 Eyring 表达式进行建模，其中解离速率指数依赖于一个由热能标度的活化能。\n\n基于这些原理，推导一个依赖于距离和角度的单个候选相互作用的能量模型，然后使用 Arrhenius 型速率定律推导相应的寿命模型。你的程序应实现所推导的模型，并执行下述的灵敏度分析。\n\n待使用的数据和常数（所有量必须严格按规定使用）：\n- 有 $N = 10$ 个候选相互作用，其供体-受体距离（单位为埃，Ångström）和供体-氢-受体角（单位为度）：\n  - 距离：$\\{2.70, 2.90, 3.10, 3.30, 2.80, 3.00, 3.40, 2.60, 3.20, 2.75\\}$。\n  - 角度：$\\{175, 160, 140, 130, 155, 145, 120, 178, 150, 165\\}$。\n- 物理常数和模型参数：\n  - 基础能量标度，单位为千焦/摩尔：$E_0 = 25.0$。\n  - 距离衰减参数，单位为埃的倒数：$b = 1.5$。\n  - 参考距离，单位为埃：$r_0 = 2.8$。\n  - 尝试频率，单位为秒的倒数：$\\nu_0 = 1.0 \\times 10^{12}$。\n  - 势垒缩放因子（无量纲）：$\\alpha = 0.5$。\n  - 气体常数，单位为千焦/摩尔·开尔文：$R = 0.008314$。\n  - 温度，单位为开尔文：$T = 300.0$。\n  - 用于除法的数值稳定器（无量纲）：$\\varepsilon = 1.0 \\times 10^{-12}$。\n  - 鲁棒性容差（无量纲）：$\\rho = 0.20$。\n\n检测标准：\n- 一个距离为 $r_i$（单位为埃）且角度为 $\\theta_i$（单位为度）的相互作用 $i$ 被视为一个检测到的氢键，当且仅当 $r_i \\leq r_{\\mathrm{thr}}$ 且 $\\theta_i \\geq \\theta_{\\mathrm{thr}}$，其中 $r_{\\mathrm{thr}}$ 是距离阈值（单位为埃），$\\theta_{\\mathrm{thr}}$ 是角度阈值（单位为度）。\n\n需要推导和实现的能量与寿命模型：\n- 利用轨道重叠随距离的指数衰减和氢键的方向性，为每个检测到的相互作用推导一个具有物理动机的能量模型 $E_i(r_i, \\theta_i)$（单位为千焦/摩尔）。该模型必须：\n  - 通过一个涉及 $b$ 和 $(r_i - r_0)$ 的因子，随着 $r_i$ 相对于 $r_0$ 的增加而指数衰减。\n  - 通过一个基于 $\\theta_i$ 的有界取向因子，随着 $\\theta_i$ 趋向线性而增加。\n  - 对于有利的相互作用为负值，其大小由 $E_0$ 标度。\n- 使用 Arrhenius 型解离速率定律推导一个寿命模型 $\\tau_i$（单位为秒），其中解离速率 $k_{\\mathrm{off}, i}$ 由 $k_{\\mathrm{off}, i} = \\nu_0 \\exp\\left(-\\alpha |E_i| / (R T)\\right)$ 给出，且 $\\tau_i = 1 / k_{\\mathrm{off}, i}$。\n\n聚合与灵敏度分析：\n- 对于给定的 $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}})$，令 $S$ 为满足检测标准的索引集合。定义平均能量 $\\bar{E}$（单位为千焦/摩尔）为 $S$ 中所有 $i$ 的 $E_i$ 的算术平均值，定义平均寿命 $\\bar{\\tau}$（单位为秒）为 $S$ 中所有 $i$ 的 $\\tau_i$ 的算术平均值。如果 $S$ 为空，则定义 $\\bar{E} = 0$ 和 $\\bar{\\tau} = 0$。\n- 通过关于 $r_{\\mathrm{thr}}$ 和 $\\theta_{\\mathrm{thr}}$ 的对称有限差分法执行局部灵敏度分析。对于一个扰动 $\\Delta r$（单位为埃），在 $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}})$ 处计算 $\\bar{E}_0$ 和 $\\bar{\\tau}_0$，然后在 $(r_{\\mathrm{thr}} + \\Delta r, \\theta_{\\mathrm{thr}})$ 和 $(r_{\\mathrm{thr}} - \\Delta r, \\theta_{\\mathrm{thr}})$ 处分别计算 $\\bar{E}_+$ 和 $\\bar{E}_-$。类似地，对于一个扰动 $\\Delta \\theta$（单位为度），在 $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}} + \\Delta \\theta)$ 和 $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}} - \\Delta \\theta)$ 处计算 $\\bar{E}_+$ 和 $\\bar{E}_-$。在需要时使用物理截断，以确保 $r_{\\mathrm{thr}} - \\Delta r \\geq 0$ 且 $0 \\leq \\theta_{\\mathrm{thr}} \\pm \\Delta \\theta \\leq 180$。\n- 定义无量纲的相对变化：\n  $$\\delta_E^{(r)} = \\frac{|\\bar{E}_+ - \\bar{E}_-|}{\\max(|\\bar{E}_0|, \\varepsilon)}, \\quad \\delta_E^{(\\theta)} = \\frac{|\\bar{E}_+ - \\bar{E}_-|}{\\max(|\\bar{E}_0|, \\varepsilon)},$$\n  $$\\delta_{\\tau}^{(r)} = \\frac{|\\bar{\\tau}_+ - \\bar{\\tau}_-|}{\\max(|\\bar{\\tau}_0|, \\varepsilon)}, \\quad \\delta_{\\tau}^{(\\theta)} = \\frac{|\\bar{\\tau}_+ - \\bar{\\tau}_-|}{\\max(|\\bar{\\tau}_0|, \\varepsilon)}.$$\n- 定义鲁棒性布尔值为 $\\mathrm{robust} = (\\delta_E^{(r)} \\leq \\rho) \\land (\\delta_E^{(\\theta)} \\leq \\rho) \\land (\\delta_{\\tau}^{(r)} \\leq \\rho) \\land (\\delta_{\\tau}^{(\\theta)} \\leq \\rho)$。\n\n角度单位说明：\n- 所有角度 $\\theta$ 和 $\\theta_{\\mathrm{thr}}$ 均以度为单位；在计算任何三角函数时，需将度转换为弧度。\n\n物理单位：\n- 距离单位为埃（Ångström），能量单位为千焦/摩尔，寿命单位为秒，温度单位为开尔文，速率单位为秒的倒数。\n\n测试套件：\n- 你的程序必须评估以下四个测试用例，每个用例指定为一个元组 $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}}, \\Delta r, \\Delta \\theta)$，其中角度阈值和扰动单位为度，距离阈值和扰动单位为埃（Ångström）。所有测试均使用上述常数和温度 $T = 300.0$ 开尔文。\n  1. $(3.20, 150.0, 0.10, 5.0)$。\n  2. $(2.80, 170.0, 0.05, 2.0)$。\n  3. $(4.00, 120.0, 0.20, 10.0)$。\n  4. $(2.50, 175.0, 0.10, 5.0)$。\n- 这些用例旨在探究一般情况、近边界选择性、宽松阈值以及可能不会产生任何检测的严格阈值。\n\n最终输出规格：\n- 对于每个测试用例，你的程序必须按以下顺序计算并返回一个包含七个值的列表： $[\\bar{E}, \\bar{\\tau}, \\delta_E^{(r)}, \\delta_E^{(\\theta)}, \\delta_{\\tau}^{(r)}, \\delta_{\\tau}^{(\\theta)}, \\mathrm{robust}]$，其中 $\\bar{E}$ 的单位是千焦/摩尔，$\\bar{\\tau}$ 的单位是秒，四个 $\\delta$ 量是无量纲小数，$\\mathrm{robust}$ 是一个布尔值。\n- 你的程序应生成单行输出，其中包含所有四个测试用例的结果，形式为一个由方括号括起来的逗号分隔列表，每个测试用例的七元素列表也由方括号括起来。例如，输出必须采用以下形式：$[[a_1,a_2,\\dots,a_7],[b_1,b_2,\\dots,b_7],[c_1,\\dots,c_7],[d_1,\\dots,d_7]]$，使用你的程序计算出的精确数值。",
            "solution": "问题陈述已经过验证，被认为是具有科学依据、提法得当且完整的。它提出了计算化学生物学中的一个标准任务：评估模型对其参数的灵敏度。所提供的物理原理、常数和数据是一致且符合物理实际的。任务是推导并实现一个氢键能量和寿命的模型，然后执行局部灵敏度分析。我现在将进行推导和求解。\n\n**1. 相互作用能量模型 $E_i(r_i, \\theta_i)$ 的推导**\n\n氢键的能量是其几何构型的函数，主要取决于供体-受体距离 $r_i$ 和供体-氢-受体角 $\\theta_i$。问题要求一个模型 $E_i(r_i, \\theta_i)$，该模型需包含轨道重叠和方向性的原理。\n\n*   **距离依赖性：** 相互作用的强度与分子轨道的重叠有关，而轨道重叠通常随距离呈指数衰减。问题规定，能量的大小应随着距离 $r_i$ 相对于参考距离 $r_0$ 的增加而指数减小，并由衰减参数 $b$ 控制。这可以通过一个距离依赖因子 $f_D(r_i)$ 来体现。一个符合该指令的标准形式是：\n    $$ f_D(r_i) = \\exp[-b(r_i - r_0)] $$\n    当 $r_i = r_0$ 时，该因子等于 $1$；当 $r_i > r_0$ 时，该因子衰减。\n\n*   **角度依赖性：** 氢键具有方向性，在线性几何构型（即供体-氢-受体角 $\\theta_i$ 为 $180^\\circ$）时强度最大。这可以通过一个有界取向因子 $f_A(\\theta_i)$ 来建模，该因子在 $\\theta_i = 180^\\circ$ 时最大，并随着键的弯曲而减小。一个具有物理动机且常见的函数形式是角度余弦的幂。我们将使用余弦的平方项，它在 $180^\\circ$ 时为 $1$，在 $90^\\circ$ 时为 $0$：\n    $$ f_A(\\theta_i) = \\cos^2(\\theta_{i, \\mathrm{rad}}) $$\n    其中 $\\theta_{i, \\mathrm{rad}}$ 是从度转换为弧度的角度 $\\theta_i$。这一选择确保了该因子界于 $0$ 和 $1$ 之间，并正确地体现了对线性的偏好。\n\n*   **最终能量表达式：** 将这些因子与基础能量标度 $E_0$ 结合，并注意到有利的相互作用具有负能量，我们得到完整的能量模型：\n    $$ E_i(r_i, \\theta_i) = -E_0 \\cdot f_D(r_i) \\cdot f_A(\\theta_i) = -E_0 \\exp[-b(r_i - r_0)] \\cos^2(\\theta_{i, \\mathrm{rad}}) $$\n    所有参数（$E_0 = 25.0 \\text{ kJ/mol}$，$b = 1.5 \\text{ Å}^{-1}$，$r_0 = 2.8 \\text{ Å}$）均已给出。角度 $\\theta_i$ 以度为单位提供，在计算余弦函数时必须转换为弧度。\n\n**2. 氢键寿命模型 $\\tau_i$ 的推导**\n\n氢键的解离是一个热激活过程。其动力学可以使用 Arrhenius 型速率定律进行建模。\n\n*   **解离速率 ($k_{\\mathrm{off}, i}$)：** 问题提供了离解速率常数的表达式：\n    $$ k_{\\mathrm{off}, i} = \\nu_0 \\exp\\left(-\\frac{E_a}{RT}\\right) $$\n    其中 $\\nu_0$ 是尝试频率，$R$ 是气体常数，$T$ 是温度，$E_a$ 是解离活化能。活化能被建模为氢键稳定化能量 $|E_i|$ 的一部分，由一个因子 $\\alpha$ 缩放。因此，$E_a = \\alpha |E_i|$。将此代入速率方程得到：\n    $$ k_{\\mathrm{off}, i} = \\nu_0 \\exp\\left(-\\frac{\\alpha |E_i|}{RT}\\right) $$\n    由于检测到的键的 $E_i$ 为负，所以 $|E_i| = -E_i$。\n\n*   **寿命 ($\\tau_i$)：** 键的寿命是一级速率常数的倒数。因此，$\\tau_i$ 是 $k_{\\mathrm{off}, i}$ 的倒数：\n    $$ \\tau_i = \\frac{1}{k_{\\mathrm{off}, i}} = \\frac{1}{\\nu_0} \\exp\\left(\\frac{\\alpha |E_i|}{RT}\\right) $$\n    所有参数（$\\nu_0 = 1.0 \\times 10^{12} \\text{ s}^{-1}$，$\\alpha = 0.5$，$R=0.008314 \\text{ kJ/(mol·K)}$，$T = 300.0 \\text{ K}$）均已指定。单位是一致的，得出的寿命 $\\tau_i$ 以秒为单位。\n\n**3. 灵敏度分析的算法流程**\n\n任务的核心是实现一个计算程序，为每个给定的测试用例 $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}}, \\Delta r, \\Delta \\theta)$ 执行灵敏度分析。\n\n中心计算核心是一个函数，用于计算给定阈值对 $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}})$ 的平均能量和寿命。该函数按以下步骤执行：\n1.  识别出 $N=10$ 个候选相互作用中满足检测标准 $r_i \\leq r_{\\mathrm{thr}}$ 和 $\\theta_i \\geq \\theta_{\\mathrm{thr}}$ 的子集 $S$。\n2.  如果集合 $S$ 为空，则平均能量 $\\bar{E}$ 和平均寿命 $\\bar{\\tau}$ 都定义为 $0$。\n3.  如果 $S$ 不为空，则使用上面推导的模型为 $S$ 中的每个相互作用 $i$ 计算 $E_i$ 和 $\\tau_i$。\n4.  计算算术平均值：$\\bar{E} = \\frac{1}{|S|} \\sum_{i \\in S} E_i$ 和 $\\bar{\\tau} = \\frac{1}{|S|} \\sum_{i \\in S} \\tau_i$。\n\n对于每个测试用例，完整的分析包括以下步骤：\n1.  **中心值：** 使用中心阈值 $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}})$ 计算 $\\bar{E}_0$ 和 $\\bar{\\tau}_0$。\n\n2.  **距离灵敏度：**\n    *   定义扰动后的距离阈值：$r_{thr,+} = r_{\\mathrm{thr}} + \\Delta r$ 和 $r_{thr,-} = \\max(0, r_{\\mathrm{thr}} - \\Delta r)$。\n    *   使用 $(r_{thr,+}, \\theta_{\\mathrm{thr}})$ 计算 $(\\bar{E}_{+}^{(r)}, \\bar{\\tau}_{+}^{(r)})$。\n    *   使用 $(r_{thr,-}, \\theta_{\\mathrm{thr}})$ 计算 $(\\bar{E}_{-}^{(r)}, \\bar{\\tau}_{-}^{(r)})$。\n    *   计算无量纲相对变化：\n        $$ \\delta_E^{(r)} = \\frac{|\\bar{E}_{+}^{(r)} - \\bar{E}_{-}^{(r)}|}{\\max(|\\bar{E}_0|, \\varepsilon)}, \\quad \\delta_{\\tau}^{(r)} = \\frac{|\\bar{\\tau}_{+}^{(r)} - \\bar{\\tau}_{-}^{(r)}|}{\\max(|\\bar{\\tau}_0|, \\varepsilon)} $$\n\n3.  **角度灵敏度：**\n    *   定义扰动后的角度阈值：$\\theta_{thr,+} = \\min(180, \\theta_{\\mathrm{thr}} + \\Delta \\theta)$ 和 $\\theta_{thr,-} = \\max(0, \\theta_{\\mathrm{thr}} - \\Delta \\theta)$。\n    *   使用 $(r_{\\mathrm{thr}}, \\theta_{thr,+})$ 计算 $(\\bar{E}_{+}^{(\\theta)}, \\bar{\\tau}_{+}^{(\\theta)})$。\n    *   使用 $(r_{\\mathrm{thr}}, \\theta_{thr,-})$ 计算 $(\\bar{E}_{-}^{(\\theta)}, \\bar{\\tau}_{-}^{(\\theta)})$。\n    *   计算无量纲相对变化：\n        $$ \\delta_E^{(\\theta)} = \\frac{|\\bar{E}_{+}^{(\\theta)} - \\bar{E}_{-}^{(\\theta)}|}{\\max(|\\bar{E}_0|, \\varepsilon)}, \\quad \\delta_{\\tau}^{(\\theta)} = \\frac{|\\bar{\\tau}_{+}^{(\\theta)} - \\bar{\\tau}_{-}^{(\\theta)}|}{\\max(|\\bar{\\tau}_0|, \\varepsilon)} $$\n\n4.  **鲁棒性评估：**\n    *   通过将所有四个灵敏度指标与容差 $\\rho = 0.20$ 进行比较，来确定布尔鲁棒性标志：\n        $$ \\mathrm{robust} = (\\delta_E^{(r)} \\leq \\rho) \\land (\\delta_E^{(\\theta)} \\leq \\rho) \\land (\\delta_{\\tau}^{(r)} \\leq \\rho) \\land (\\delta_{\\tau}^{(\\theta)} \\leq \\rho) $$\n\n5.  **输出组装：**\n    *   对于每个测试用例，最终结果是一个包含 7 个值的有序列表：$[\\bar{E}_0, \\bar{\\tau}_0, \\delta_E^{(r)}, \\delta_E^{(\\theta)}, \\delta_{\\tau}^{(r)}, \\delta_{\\tau}^{(\\theta)}, \\mathrm{robust}]$。实现将对所有四个测试用例执行此计算，并按指定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hydrogen bond sensitivity analysis problem.\n    \"\"\"\n\n    # --- Givens: Candidate Interactions, Constants, and Parameters ---\n\n    # Candidate interactions\n    # N = 10\n    distances_A = np.array([2.70, 2.90, 3.10, 3.30, 2.80, 3.00, 3.40, 2.60, 3.20, 2.75])\n    angles_deg = np.array([175, 160, 140, 130, 155, 145, 120, 178, 150, 165])\n\n    # Physical constants and model parameters\n    E0 = 25.0        # kJ/mol\n    b = 1.5          # 1/Å\n    r0 = 2.8         # Å\n    nu0 = 1.0e12     # 1/s\n    alpha = 0.5      # dimensionless\n    R = 0.008314     # kJ/(mol·K)\n    T = 300.0        # K\n    epsilon = 1.0e-12# dimensionless stabilizer\n    rho = 0.20       # dimensionless robustness tolerance\n\n    # Pre-calculate RT for efficiency\n    RT = R * T\n\n    # Test suite\n    test_cases = [\n        (3.20, 150.0, 0.10, 5.0),\n        (2.80, 170.0, 0.05, 2.0),\n        (4.00, 120.0, 0.20, 10.0),\n        (2.50, 175.0, 0.10, 5.0),\n    ]\n\n    # --- Core Calculation Logic ---\n\n    def calculate_means(r_thr, theta_thr):\n        \"\"\"\n        Calculates mean energy and lifetime for a given set of thresholds.\n        \"\"\"\n        detected_energies = []\n        detected_lifetimes = []\n\n        for r_i, theta_i_deg in zip(distances_A, angles_deg):\n            if r_i = r_thr and theta_i_deg >= theta_thr:\n                # Convert angle to radians for trigonometric functions\n                theta_i_rad = np.deg2rad(theta_i_deg)\n\n                # Calculate energy E_i\n                E_i = -E0 * np.exp(-b * (r_i - r0)) * (np.cos(theta_i_rad)**2)\n\n                # Calculate lifetime tau_i\n                abs_Ei = abs(E_i)\n                tau_i = (1.0 / nu0) * np.exp((alpha * abs_Ei) / RT)\n\n                detected_energies.append(E_i)\n                detected_lifetimes.append(tau_i)\n\n        if not detected_energies:  # The set of detected bonds S is empty\n            return 0.0, 0.0\n        \n        mean_E = np.mean(detected_energies)\n        mean_tau = np.mean(detected_lifetimes)\n        return mean_E, mean_tau\n\n    # --- Main Analysis Loop ---\n\n    all_results = []\n    for r_thr, theta_thr, dr, dtheta in test_cases:\n        # 1. Central values\n        E0_bar, tau0_bar = calculate_means(r_thr, theta_thr)\n\n        # 2. Sensitivity to distance threshold r_thr\n        r_thr_plus = r_thr + dr\n        r_thr_minus = max(0.0, r_thr - dr)\n        E_plus_r, tau_plus_r = calculate_means(r_thr_plus, theta_thr)\n        E_minus_r, tau_minus_r = calculate_means(r_thr_minus, theta_thr)\n\n        delta_E_r = abs(E_plus_r - E_minus_r) / max(abs(E0_bar), epsilon)\n        delta_tau_r = abs(tau_plus_r - tau_minus_r) / max(abs(tau0_bar), epsilon)\n\n        # 3. Sensitivity to angle threshold theta_thr\n        theta_thr_plus = min(180.0, theta_thr + dtheta)\n        theta_thr_minus = max(0.0, theta_thr - dtheta)\n        E_plus_theta, tau_plus_theta = calculate_means(r_thr, theta_thr_plus)\n        E_minus_theta, tau_minus_theta = calculate_means(r_thr, theta_thr_minus)\n\n        delta_E_theta = abs(E_plus_theta - E_minus_theta) / max(abs(E0_bar), epsilon)\n        delta_tau_theta = abs(tau_plus_theta - tau_minus_theta) / max(abs(tau0_bar), epsilon)\n\n        # 4. Robustness evaluation\n        is_robust = (delta_E_r = rho and\n                     delta_E_theta = rho and\n                     delta_tau_r = rho and\n                     delta_tau_theta = rho)\n\n        # 5. Assemble results for the current test case\n        result_for_case = [\n            E0_bar, tau0_bar,\n            delta_E_r, delta_E_theta,\n            delta_tau_r, delta_tau_theta,\n            is_robust\n        ]\n        all_results.append(result_for_case)\n\n    # --- Final Output Formatting ---\n    # Manually construct the string to avoid spaces introduced by str(list)\n    # and to ensure the exact format requested.\n    \n    output_parts = []\n    for res_list in all_results:\n        inner_parts = []\n        for val in res_list:\n            inner_parts.append(str(val))\n        output_parts.append('[' + ','.join(inner_parts) + ']')\n    \n    final_output_string = '[' + ','.join(output_parts) + ']'\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}