{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of hydrogen bond analysis in simulations is identifying them from atomic coordinates. However, there is no single, universally accepted definition; different analysis tools use slightly different geometric rules. This exercise provides hands-on practice with the fundamental calculations involved in H-bond detection, including handling periodic boundary conditions, and critically highlights how the choice of algorithm and its cutoff parameters can significantly alter quantitative results like bond occupancy. ",
            "id": "3849667",
            "problem": "You are tasked with designing and implementing a principled comparison of hydrogen bond detection criteria inspired by common choices in Molecular Dynamics (MD) analysis tools, using a single synthetic trajectory and quantifying how detection varies with geometric thresholds and algorithmic rules. The scenario concerns a single donor–hydrogen–acceptor triad in a cubic periodic simulation box, and the objective is to compute per-algorithm hydrogen bond occupancy across frames and then compare occupancies between algorithms.\n\nFoundational base: Hydrogen bonds are commonly detected using geometric criteria involving heavy-atom distances and angular constraints. In a periodic orthorhombic simulation cell, displacements must be computed using the nearest-image convention. Use the following definitions and laws:\n\n- Periodic boundary condition with nearest-image displacement: For two positions with components $\\mathbf{r}_1 = (x_1,y_1,z_1)$ and $\\mathbf{r}_2 = (x_2,y_2,z_2)$ inside a cubic box of side length $L$, define the component-wise displacement as\n$$\n\\Delta_i = x_{2,i} - x_{1,i}, \\quad \\Delta_i' =\n\\begin{cases}\n\\Delta_i - L,  \\text{if } \\Delta_i  L/2,\\\\\n\\Delta_i + L,  \\text{if } \\Delta_i  -L/2,\\\\\n\\Delta_i,  \\text{otherwise.}\n\\end{cases}\n$$\nand set the minimal-image displacement $\\Delta \\mathbf{r} = (\\Delta_x',\\Delta_y',\\Delta_z')$.\n- Euclidean distance: For any displacement vector $\\Delta \\mathbf{r}$, the heavy-atom or hydrogen-atom separation is $r = \\|\\Delta \\mathbf{r}\\| = \\sqrt{\\Delta_x'^2 + \\Delta_y'^2 + \\Delta_z'^2}$.\n- Angle at the hydrogen: For vectors $\\mathbf{u} = \\mathbf{r}_\\mathrm{D} - \\mathbf{r}_\\mathrm{H}$ and $\\mathbf{v} = \\mathbf{r}_\\mathrm{A} - \\mathbf{r}_\\mathrm{H}$ both taken under the nearest-image convention, define the donor–hydrogen–acceptor angle as\n$$\n\\theta = \\arccos\\!\\left(\\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\|\\,\\|\\mathbf{v}\\|}\\right) \\times \\frac{180}{\\pi},\n$$\nexpressed in degrees.\n\nHydrogen bond occupancy: For an algorithm that classifies hydrogen bonding as a boolean per frame, define occupancy over $N_f$ frames as\n$$\nO = \\frac{1}{N_f}\\sum_{t=1}^{N_f} \\mathbb{I}_t,\n$$\nwhere $\\mathbb{I}_t$ is the indicator function that equals $1$ if the hydrogen bond criterion is satisfied at frame $t$ and $0$ otherwise. Occupancy is unitless and should be reported as a decimal.\n\nAlgorithms to compare:\n- Algorithm A (heavy-atom distance and angle): A hydrogen bond exists at a frame if the nearest-image hydrogen–acceptor distance $r_\\mathrm{HA}$ satisfies $r_\\mathrm{HA} \\le r_\\mathrm{HA}^{\\mathrm{cut}}$ and the donor–hydrogen–acceptor angle satisfies $\\theta \\ge \\theta^{\\mathrm{cut}}$.\n- Algorithm B (heavy-atom distance only): A hydrogen bond exists at a frame if the nearest-image donor–acceptor distance $r_\\mathrm{DA}$ satisfies $r_\\mathrm{DA} \\le r_\\mathrm{DA}^{\\mathrm{cut}}$.\n- Algorithm C (donor–hydrogen bond presence plus Algorithm A): A hydrogen bond exists at a frame if the nearest-image donor–hydrogen distance $r_\\mathrm{DH}$ satisfies $r_\\mathrm{DH} \\le r_\\mathrm{DH}^{\\mathrm{cut}}$ and simultaneously Algorithm A’s conditions $r_\\mathrm{HA} \\le r_\\mathrm{HA}^{\\mathrm{cut}}$ and $\\theta \\ge \\theta^{\\mathrm{cut}}$ are satisfied.\n\nTrajectory specification:\n- Use a cubic periodic box with side length $L = 10\\,\\mathrm{\\AA}$.\n- The trajectory consists of $N_f = 6$ frames with donor $\\mathbf{r}_\\mathrm{D}(t)$, hydrogen $\\mathbf{r}_\\mathrm{H}(t)$, and acceptor $\\mathbf{r}_\\mathrm{A}(t)$ positions (in $\\mathrm{\\AA}$) as follows:\n  - Frame $1$: $\\mathbf{r}_\\mathrm{D} = (1,1,1)$, $\\mathbf{r}_\\mathrm{H} = (2,1,1)$, $\\mathbf{r}_\\mathrm{A} = (4,1,1)$.\n  - Frame $2$: $\\mathbf{r}_\\mathrm{D} = (1,1,1)$, $\\mathbf{r}_\\mathrm{H} = (2,1,1)$, $\\mathbf{r}_\\mathrm{A} = (4.6,0.4,1)$.\n  - Frame $3$: $\\mathbf{r}_\\mathrm{D} = (1,1,1)$, $\\mathbf{r}_\\mathrm{H} = (2,1,1)$, $\\mathbf{r}_\\mathrm{A} = (3.4,1,1)$.\n  - Frame $4$: $\\mathbf{r}_\\mathrm{D} = (1,1,1)$, $\\mathbf{r}_\\mathrm{H} = (2,1,1)$, $\\mathbf{r}_\\mathrm{A} = (2.9,1,0)$.\n  - Frame $5$: $\\mathbf{r}_\\mathrm{D} = (9.5,0.5,0.5)$, $\\mathbf{r}_\\mathrm{H} = (0.5,0.5,0.5)$, $\\mathbf{r}_\\mathrm{A} = (2.5,0.5,0.5)$.\n  - Frame $6$: $\\mathbf{r}_\\mathrm{D} = (9.5,0.5,0.5)$, $\\mathbf{r}_\\mathrm{H} = (0.5,0.5,0.5)$, $\\mathbf{r}_\\mathrm{A} = (1.914213562,1.914213562,0.5)$.\n\nAngle unit specification: All angles must be computed and compared in degrees. Distances must be computed and compared in $\\mathrm{\\AA}$.\n\nQuantification to output: For each threshold parameter set (test case), compute the three occupancies $O_A$, $O_B$, and $O_C$, and then report the absolute differences between occupancies as the list\n$$\n\\left[\\,|O_A - O_B|,\\; |O_A - O_C|,\\; |O_B - O_C|\\,\\right].\n$$\nRound each difference to three decimal places.\n\nTest suite:\n- Case $1$ (typical thresholds): $r_\\mathrm{HA}^{\\mathrm{cut}} = 2.5\\,\\mathrm{\\AA}$, $\\theta^{\\mathrm{cut}} = 150\\,\\mathrm{deg}$, $r_\\mathrm{DA}^{\\mathrm{cut}} = 3.2\\,\\mathrm{\\AA}$, $r_\\mathrm{DH}^{\\mathrm{cut}} = 1.05\\,\\mathrm{\\AA}$.\n- Case $2$ (strict thresholds, boundary equalities included): $r_\\mathrm{HA}^{\\mathrm{cut}} = 2.0\\,\\mathrm{\\AA}$, $\\theta^{\\mathrm{cut}} = 165\\,\\mathrm{deg}$, $r_\\mathrm{DA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$, $r_\\mathrm{DH}^{\\mathrm{cut}} = 1.0\\,\\mathrm{\\AA}$.\n- Case $3$ (loose thresholds, angle-boundary included): $r_\\mathrm{HA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$, $\\theta^{\\mathrm{cut}} = 135\\,\\mathrm{deg}$, $r_\\mathrm{DA}^{\\mathrm{cut}} = 3.5\\,\\mathrm{\\AA}$, $r_\\mathrm{DH}^{\\mathrm{cut}} = 1.2\\,\\mathrm{\\AA}$.\n\nFinal output format: Your program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets, where each element is itself a list of the three rounded absolute differences for that case, with no spaces. For example: $[[d_{11},d_{12},d_{13}],[d_{21},d_{22},d_{23}],[d_{31},d_{32},d_{33}]]$, printed exactly as a single line like \"[[0.333,0.000,0.333],[...],[...]]\".",
            "solution": "The problem is valid. It is scientifically grounded in the principles of computational chemical biology, specifically the geometric analysis of hydrogen bonds in molecular dynamics trajectories. The definitions, data, and objectives are self-contained, consistent, and well-posed, permitting a unique and verifiable solution.\n\nThe solution proceeds in three main stages:\n1.  For each of the $N_f = 6$ frames in the synthetic trajectory, we calculate the essential geometric parameters: the donor-acceptor distance ($r_\\mathrm{DA}$), the hydrogen-acceptor distance ($r_\\mathrm{HA}$), the donor-hydrogen distance ($r_\\mathrm{DH}$), and the donor-hydrogen-acceptor angle ($\\theta$). These calculations must strictly adhere to the nearest-image convention for the specified periodic cubic box of side length $L = 10\\,\\mathrm{\\AA}$.\n2.  For each of the three test cases, which provide different sets of cutoff thresholds, we iterate through the pre-calculated geometric parameters for each frame. We apply the logical criteria for Algorithm A, B, and C to determine if a hydrogen bond exists in that frame according to each algorithm.\n3.  After classifying all frames for a given test case, we compute the occupancy $O$ for each algorithm as the fraction of frames where a hydrogen bond was detected. Finally, we calculate the required absolute differences between these occupancies, $|O_A - O_B|$, $|O_A - O_C|$, and $|O_B - O_C|$, and round them to three decimal places.\n\n**Step 1: Calculation of Geometric Parameters**\n\nWe define three helper functions based on the problem statement for computing minimum-image displacement, distance, and angle.\n\nThe minimum-image displacement $\\Delta \\mathbf{r}'$ between two position vectors $\\mathbf{r}_1$ and $\\mathbf{r}_2$ in a cubic box of side $L$ is calculated component-wise. For each component $i \\in \\{x, y, z\\}$:\n$$\n\\Delta_i = x_{2,i} - x_{1,i}\n$$\n$$\n\\Delta_i' =\n\\begin{cases}\n\\Delta_i - L,  \\text{if } \\Delta_i  L/2 \\\\\n\\Delta_i + L,  \\text{if } \\Delta_i  -L/2 \\\\\n\\Delta_i,  \\text{otherwise.}\n\\end{cases}\n$$\n\nThe distance $r$ is the Euclidean norm of the resulting displacement vector, $r = \\|\\Delta \\mathbf{r}'\\|$. The angle $\\theta$ between vectors $\\mathbf{u} = \\mathbf{r}_\\mathrm{D} - \\mathbf{r}_\\mathrm{H}$ and $\\mathbf{v} = \\mathbf{r}_\\mathrm{A} - \\mathbf{r}_\\mathrm{H}$ (both computed using the nearest-image convention) is given by $\\theta = \\arccos(\\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\|\\|\\mathbf{v}\\|})$ and converted to degrees.\n\nApplying these definitions to the trajectory data ($L=10\\,\\mathrm{\\AA}$, $N_f=6$ frames) yields the following geometric parameters for each frame:\n\n| Frame | $r_\\mathrm{DA}$ ($\\mathrm{\\AA}$) | $r_\\mathrm{HA}$ ($\\mathrm{\\AA}$) | $r_\\mathrm{DH}$ ($\\mathrm{\\AA}$) | $\\theta$ (deg) |\n|---|---|---|---|---|\n| $1$ | $3.0$ | $2.0$ | $1.0$ | $180.0$ |\n| $2$ | $\\sqrt{13.32} \\approx 3.650$ | $\\sqrt{7.12} \\approx 2.668$ | $1.0$ | $166.99$ |\n| $3$ | $2.4$ | $1.4$ | $1.0$ | $180.0$ |\n| $4$ | $\\sqrt{4.61} \\approx 2.147$ | $\\sqrt{1.81} \\approx 1.345$ | $1.0$ | $132.01$ |\n| $5$ | $3.0$ | $2.0$ | $1.0$ | $180.0$ |\n| $6$ | $\\sqrt{5+2\\sqrt{2}} \\approx 2.798$ | $2.0$ | $1.0$ | $135.0$ |\n\nNote that for frames $5$ and $6$, the particle positions necessitate applying the nearest-image convention. For example, in Frame $5$, the direct displacement for D-A is $\\Delta\\mathbf{r} = (2.5-9.5, 0, 0) = (-7,0,0)$. Since $\\Delta_x = -7  -L/2 = -5$, the corrected displacement is $\\Delta\\mathbf{r}' = (-7+10, 0, 0) = (3,0,0)$, yielding $r_\\mathrm{DA}=3.0\\,\\mathrm{\\AA}$.\n\n**Step 2  3: Application of Algorithms and Calculation of Differences**\n\nWe now process each test case using the geometric data from the table above.\n\n**Test Case 1:** ($r_\\mathrm{HA}^{\\mathrm{cut}} = 2.5\\,\\mathrm{\\AA}$, $\\theta^{\\mathrm{cut}} = 150^\\circ$, $r_\\mathrm{DA}^{\\mathrm{cut}} = 3.2\\,\\mathrm{\\AA}$, $r_\\mathrm{DH}^{\\mathrm{cut}} = 1.05\\,\\mathrm{\\AA}$)\n\n- **Algorithm A ($r_\\mathrm{HA} \\le 2.5$ and $\\theta \\ge 150^\\circ$):** Frames $1, 3, 5$ satisfy the criteria. Count = $3$.\n- **Algorithm B ($r_\\mathrm{DA} \\le 3.2$):** Frames $1, 3, 4, 5, 6$ satisfy the criteria. Count = $5$.\n- **Algorithm C ($r_\\mathrm{DH} \\le 1.05$ and Algorithm A):** The condition on $r_\\mathrm{DH}$ is met for all frames ($1.0 \\le 1.05$). Thus, this is equivalent to Algorithm A. Frames $1, 3, 5$ satisfy the criteria. Count = $3$.\n\nOccupancies:\n- $O_A = 3/6 = 0.5$\n- $O_B = 5/6 \\approx 0.8333$\n- $O_C = 3/6 = 0.5$\n\nDifferences:\n- $|O_A - O_B| = |0.5 - 5/6| = 1/3 \\approx 0.333$\n- $|O_A - O_C| = |0.5 - 0.5| = 0.0$\n- $|O_B - O_C| = |5/6 - 0.5| = 1/3 \\approx 0.333$\nResult: $[0.333, 0.000, 0.333]$\n\n**Test Case 2:** ($r_\\mathrm{HA}^{\\mathrm{cut}} = 2.0\\,\\mathrm{\\AA}$, $\\theta^{\\mathrm{cut}} = 165^\\circ$, $r_\\mathrm{DA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$, $r_\\mathrm{DH}^{\\mathrm{cut}} = 1.0\\,\\mathrm{\\AA}$)\n\n- **Algorithm A ($r_\\mathrm{HA} \\le 2.0$ and $\\theta \\ge 165^\\circ$):** Frames $1, 3, 5$ satisfy the criteria. Count = $3$.\n- **Algorithm B ($r_\\mathrm{DA} \\le 3.0$):** Frames $1, 3, 4, 5, 6$ satisfy the criteria. Count = $5$.\n- **Algorithm C ($r_\\mathrm{DH} \\le 1.0$ and Algorithm A):** The condition on $r_\\mathrm{DH}$ is met for all frames ($1.0 \\le 1.0$). This is equivalent to Algorithm A. Frames $1, 3, 5$ satisfy the criteria. Count = $3$.\n\nOccupancies and differences are identical to Case 1.\nResult: $[0.333, 0.000, 0.333]$\n\n**Test Case 3:** ($r_\\mathrm{HA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$, $\\theta^{\\mathrm{cut}} = 135^\\circ$, $r_\\mathrm{DA}^{\\mathrm{cut}} = 3.5\\,\\mathrm{\\AA}$, $r_\\mathrm{DH}^{\\mathrm{cut}} = 1.2\\,\\mathrm{\\AA}$)\n\n- **Algorithm A ($r_\\mathrm{HA} \\le 3.0$ and $\\theta \\ge 135^\\circ$):** Frames $1, 2, 3, 5, 6$ satisfy the criteria. Count = $5$.\n- **Algorithm B ($r_\\mathrm{DA} \\le 3.5$):** Frames $1, 3, 4, 5, 6$ satisfy the criteria. Count = $5$.\n- **Algorithm C ($r_\\mathrm{DH} \\le 1.2$ and Algorithm A):** The condition on $r_\\mathrm{DH}$ is met for all frames ($1.0 \\le 1.2$). This is equivalent to Algorithm A. Frames $1, 2, 3, 5, 6$ satisfy the criteria. Count = $5$.\n\nOccupancies:\n- $O_A = 5/6 \\approx 0.8333$\n- $O_B = 5/6 \\approx 0.8333$\n- $O_C = 5/6 \\approx 0.8333$\n\nDifferences:\n- $|O_A - O_B| = |5/6 - 5/6| = 0.0$\n- $|O_A - O_C| = |5/6 - 5/6| = 0.0$\n- $|O_B - O_C| = |5/6 - 5/6| = 0.0$\nResult: $[0.000, 0.000, 0.000]$\n\nThese results will be formatted into a single line for the final output as per the problem specification.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import sqrt, acos, degrees\n\ndef solve():\n    \"\"\"\n    Solves the hydrogen bond analysis problem by calculating occupancies\n    for three different algorithms across a synthetic trajectory and\n    reporting the differences between them for three test cases.\n    \"\"\"\n\n    # --- Data Definition ---\n\n    # Trajectory data: (r_D, r_H, r_A) for each frame\n    trajectory = [\n        # Frame 1\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([4.0, 1.0, 1.0])),\n        # Frame 2\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([4.6, 0.4, 1.0])),\n        # Frame 3\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([3.4, 1.0, 1.0])),\n        # Frame 4\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([2.9, 1.0, 0.0])),\n        # Frame 5\n        (np.array([9.5, 0.5, 0.5]), np.array([0.5, 0.5, 0.5]), np.array([2.5, 0.5, 0.5])),\n        # Frame 6\n        (np.array([9.5, 0.5, 0.5]), np.array([0.5, 0.5, 0.5]), np.array([1.914213562, 1.914213562, 0.5])),\n    ]\n    L = 10.0  # Box side length in Angstrom\n    N_f = len(trajectory)\n\n    # Test cases: (r_HA_cut, theta_cut, r_DA_cut, r_DH_cut)\n    test_cases = [\n        # Case 1 (typical)\n        (2.5, 150.0, 3.2, 1.05),\n        # Case 2 (strict)\n        (2.0, 165.0, 3.0, 1.0),\n        # Case 3 (loose)\n        (3.0, 135.0, 3.5, 1.2),\n    ]\n\n    # --- Helper Functions ---\n\n    def nearest_image_displacement(r2, r1, box_L):\n        \"\"\"Calculates the minimum image displacement vector from r1 to r2.\"\"\"\n        delta = r2 - r1\n        half_L = box_L / 2.0\n        # This explicit loop correctly implements the problem's definition\n        for i in range(len(delta)):\n            if delta[i]  half_L:\n                delta[i] -= box_L\n            elif delta[i]  -half_L:\n                delta[i] += box_L\n        return delta\n\n    # --- Main Logic ---\n\n    all_results = []\n    \n    for case in test_cases:\n        r_HA_cut, theta_cut, r_DA_cut, r_DH_cut = case\n        \n        h_bond_count_A = 0\n        h_bond_count_B = 0\n        h_bond_count_C = 0\n\n        for frame_coords in trajectory:\n            r_D, r_H, r_A = frame_coords\n\n            # Calculate geometric quantities for the frame\n            # Distances\n            dr_DA = nearest_image_displacement(r_A, r_D, L)\n            r_DA = np.linalg.norm(dr_DA)\n\n            dr_HA = nearest_image_displacement(r_A, r_H, L)\n            r_HA = np.linalg.norm(dr_HA)\n\n            dr_DH = nearest_image_displacement(r_H, r_D, L)\n            r_DH = np.linalg.norm(dr_DH)\n            \n            # Angle D-H-A\n            # Vector u from H to D\n            u = nearest_image_displacement(r_D, r_H, L)\n            # Vector v from H to A\n            v = dr_HA # This is already r_A - r_H with PBC\n            \n            norm_u = np.linalg.norm(u)\n            norm_v = r_HA\n            \n            # Prevent division by zero if atoms overlap\n            if norm_u  1e-9 and norm_v  1e-9:\n                dot_product = np.dot(u, v)\n                cosine_angle = dot_product / (norm_u * norm_v)\n                # Clip to handle floating point inaccuracies\n                cosine_angle = np.clip(cosine_angle, -1.0, 1.0)\n                angle = degrees(acos(cosine_angle))\n            else:\n                angle = 0.0\n\n            # Apply algorithm criteria\n            # Algorithm A\n            is_hbond_A = (r_HA = r_HA_cut) and (angle = theta_cut)\n            if is_hbond_A:\n                h_bond_count_A += 1\n            \n            # Algorithm B\n            if r_DA = r_DA_cut:\n                h_bond_count_B += 1\n            \n            # Algorithm C\n            if (r_DH = r_DH_cut) and is_hbond_A:\n                h_bond_count_C += 1\n\n        # Calculate occupancies\n        O_A = h_bond_count_A / N_f\n        O_B = h_bond_count_B / N_f\n        O_C = h_bond_count_C / N_f\n        \n        # Calculate and round absolute differences\n        diff_AB = abs(O_A - O_B)\n        diff_AC = abs(O_A - O_C)\n        diff_BC = abs(O_B - O_C)\n        \n        all_results.append([diff_AB, diff_AC, diff_BC])\n\n    # --- Final Output Formatting ---\n    # According to the specified format \"[[d1,d2,d3],[...]]\"\n    inner_results_str = []\n    for R in all_results:\n        # Format numbers to 3 decimal places\n        formatted_diffs = [f\"{d:.3f}\" for d in R]\n        inner_results_str.append(f\"[{','.join(formatted_diffs)}]\")\n    \n    final_output = f\"[{','.join(inner_results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond a simple binary classification of hydrogen bonds allows for a more physically nuanced understanding. This practice guides you in constructing a model that links a bond's specific geometry to its energetic strength, reflecting the principle that more ideal geometries are more stable. Furthermore, you will perform a sensitivity analysis to assess how robust your conclusions are to the chosen detection thresholds, a crucial skill for developing reliable computational models. ",
            "id": "3849643",
            "problem": "You are tasked with assessing the robustness of a computational hydrogen bond detection model to changes in geometric detection thresholds by performing a sensitivity analysis and reporting the impact on predicted energies and lifetimes. The context is hydrogen bond analysis within computational chemical biology, and you are to reason from first principles.\n\nBegin from the following foundational base, which is widely accepted in physical chemistry and chemical biology:\n- Hydrogen bonding strength increases as the donor–hydrogen–acceptor angle approaches linearity and decreases as donor–acceptor distance increases. This directionality can be represented by an orientation factor that depends on the donor–hydrogen–acceptor angle.\n- Orbital overlap relevant to hydrogen bonding decreases approximately exponentially with separation distance, which motivates an exponential dependence on distance for an effective interaction strength.\n- Thermal dissociation of a hydrogen bond can be modeled using an Arrhenius or Eyring-like expression, where the dissociation rate depends exponentially on an activation energy scaled by thermal energy.\n\nFrom these principles, derive an energy model for individual candidate interactions that depends on distance and angle, and then derive a corresponding lifetime model using an Arrhenius-type rate law. Your program should implement the derived models and perform the sensitivity analysis described below.\n\nData and constants to be used (all quantities must be used exactly as specified):\n- There are $N = 10$ candidate interactions with donor–acceptor distances (in Ångström) and donor–hydrogen–acceptor angles (in degrees):\n  - Distances: $\\{2.70, 2.90, 3.10, 3.30, 2.80, 3.00, 3.40, 2.60, 3.20, 2.75\\}$.\n  - Angles: $\\{175, 160, 140, 130, 155, 145, 120, 178, 150, 165\\}$.\n- Physical constants and model parameters:\n  - Base energy scale in kilojoules per mole: $E_0 = 25.0$.\n  - Distance decay parameter in inverse Ångström: $b = 1.5$.\n  - Reference distance in Ångström: $r_0 = 2.8$.\n  - Attempt frequency in inverse seconds: $\\nu_0 = 1.0 \\times 10^{12}$.\n  - Barrier scaling factor (dimensionless): $\\alpha = 0.5$.\n  - Gas constant in kilojoules per mole per kelvin: $R = 0.008314$.\n  - Temperature in kelvin: $T = 300.0$.\n  - Numerical stabilizer for divisions (dimensionless): $\\varepsilon = 1.0 \\times 10^{-12}$.\n  - Robustness tolerance (dimensionless): $\\rho = 0.20$.\n\nDetection criterion:\n- An interaction $i$ with distance $r_i$ (in Ångström) and angle $\\theta_i$ (in degrees) is considered a detected hydrogen bond if and only if $r_i \\leq r_{\\mathrm{thr}}$ and $\\theta_i \\geq \\theta_{\\mathrm{thr}}$, where $r_{\\mathrm{thr}}$ is a distance threshold (in Ångström) and $\\theta_{\\mathrm{thr}}$ is an angle threshold (in degrees).\n\nEnergy and lifetime modeling to derive and implement:\n- Use the exponential decay of orbital overlap with distance and the directionality of hydrogen bonding to derive a physically motivated energy model $E_i(r_i, \\theta_i)$ in kilojoules per mole for each detected interaction. The model must:\n  - Decrease exponentially with increasing $r_i$ relative to $r_0$ through a factor that involves $b$ and $(r_i - r_0)$.\n  - Increase with increasing $\\theta_i$ toward linearity through a bounded orientation factor based on $\\theta_i$.\n  - Be negative for favorable interactions and have magnitude scaled by $E_0$.\n- Use an Arrhenius-type dissociation rate law to derive a lifetime model $\\tau_i$ in seconds, where the dissociation rate $k_{\\mathrm{off}, i}$ is given by $k_{\\mathrm{off}, i} = \\nu_0 \\exp\\left(-\\alpha |E_i| / (R T)\\right)$ and $\\tau_i = 1 / k_{\\mathrm{off}, i}$.\n\nAggregation and sensitivity analysis:\n- For a given $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}})$, let $S$ be the set of indices that satisfy the detection criterion. Define the mean energy $\\bar{E}$ in kilojoules per mole as the arithmetic mean of $E_i$ over $i \\in S$ and the mean lifetime $\\bar{\\tau}$ in seconds as the arithmetic mean of $\\tau_i$ over $i \\in S$. If $S$ is empty, define $\\bar{E} = 0$ and $\\bar{\\tau} = 0$.\n- Perform a local sensitivity analysis by symmetric finite differences with respect to $r_{\\mathrm{thr}}$ and $\\theta_{\\mathrm{thr}}$. For a perturbation $\\Delta r$ (in Ångström), compute $\\bar{E}_0$ and $\\bar{\\tau}_0$ at $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}})$, then compute $\\bar{E}_+$ and $\\bar{E}_-$ at $(r_{\\mathrm{thr}} + \\Delta r, \\theta_{\\mathrm{thr}})$ and $(r_{\\mathrm{thr}} - \\Delta r, \\theta_{\\mathrm{thr}})$, respectively. Analogously, for a perturbation $\\Delta \\theta$ (in degrees), compute $\\bar{E}_+$ and $\\bar{E}_-$ at $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}} + \\Delta \\theta)$ and $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}} - \\Delta \\theta)$. Use physical clipping where needed so that $r_{\\mathrm{thr}} - \\Delta r \\geq 0$ and $0 \\leq \\theta_{\\mathrm{thr}} \\pm \\Delta \\theta \\leq 180$.\n- Define the dimensionless relative changes:\n  $$\\delta_E^{(r)} = \\frac{|\\bar{E}_+ - \\bar{E}_-|}{\\max(|\\bar{E}_0|, \\varepsilon)}, \\quad \\delta_E^{(\\theta)} = \\frac{|\\bar{E}_+ - \\bar{E}_-|}{\\max(|\\bar{E}_0|, \\varepsilon)},$$\n  $$\\delta_{\\tau}^{(r)} = \\frac{|\\bar{\\tau}_+ - \\bar{\\tau}_-|}{\\max(|\\bar{\\tau}_0|, \\varepsilon)}, \\quad \\delta_{\\tau}^{(\\theta)} = \\frac{|\\bar{\\tau}_+ - \\bar{\\tau}_-|}{\\max(|\\bar{\\tau}_0|, \\varepsilon)}.$$\n- Define the robustness boolean as $\\mathrm{robust} = (\\delta_E^{(r)} \\leq \\rho) \\land (\\delta_E^{(\\theta)} \\leq \\rho) \\land (\\delta_{\\tau}^{(r)} \\leq \\rho) \\land (\\delta_{\\tau}^{(\\theta)} \\leq \\rho)$.\n\nAngle unit specification:\n- All angles $\\theta$ and $\\theta_{\\mathrm{thr}}$ are in degrees; when computing any trigonometric function, convert degrees to radians.\n\nPhysical units:\n- Distances are in Ångström, energies are in kilojoules per mole, lifetimes are in seconds, temperature is in kelvin, and rates are in inverse seconds.\n\nTest suite:\n- Your program must evaluate the following four test cases, each specified as a tuple $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}}, \\Delta r, \\Delta \\theta)$, with angle thresholds and perturbations in degrees and distance thresholds and perturbations in Ångström. All tests use the constants above and temperature $T = 300.0$ kelvin.\n  1. $(3.20, 150.0, 0.10, 5.0)$.\n  2. $(2.80, 170.0, 0.05, 2.0)$.\n  3. $(4.00, 120.0, 0.20, 10.0)$.\n  4. $(2.50, 175.0, 0.10, 5.0)$.\n- These cases probe a general case, near-boundary selectivity, loose thresholds, and tight thresholds that may yield no detections.\n\nFinal output specification:\n- For each test case, your program must compute and return a list of seven values in the following order:\n  $[\\bar{E}, \\bar{\\tau}, \\delta_E^{(r)}, \\delta_E^{(\\theta)}, \\delta_{\\tau}^{(r)}, \\delta_{\\tau}^{(\\theta)}, \\mathrm{robust}]$,\n  where $\\bar{E}$ is in kilojoules per mole and $\\bar{\\tau}$ is in seconds, and the four $\\delta$ quantities are dimensionless decimals, and $\\mathrm{robust}$ is a boolean.\n- Your program should produce a single line of output containing the results for all four test cases as a comma-separated list enclosed in square brackets, with each test case’s seven-element list enclosed in square brackets. For example, the output must have the form $[[a_1,a_2,\\dots,a_7],[b_1,b_2,\\dots,b_7],[c_1,\\dots,c_7],[d_1,\\dots,d_7]]$, using the exact numeric values your program computes.",
            "solution": "The problem statement has been validated and is deemed to be scientifically grounded, well-posed, and complete. It presents a standard task in computational chemical biology: assessing the sensitivity of a model to its parameters. The provided physical principles, constants, and data are consistent and physically realistic. The task is to derive and implement a model for hydrogen bond energy and lifetime, and then perform a local sensitivity analysis. I will now proceed with the derivation and solution.\n\nFirst, we must formalize the energy and lifetime models based on the provided first principles.\n\n**1. Derivation of the Interaction Energy Model, $E_i(r_i, \\theta_i)$**\n\nThe energy of a hydrogen bond is a function of its geometry, primarily the donor-acceptor distance, $r_i$, and the donor-hydrogen-acceptor angle, $\\theta_i$. The problem requires a model, $E_i(r_i, \\theta_i)$, that incorporates principles of orbital overlap and directionality.\n\n*   **Distance Dependence:** The strength of the interaction is related to the overlap of molecular orbitals, which typically decays exponentially with distance. The problem specifies that the energy's magnitude should decrease exponentially as the distance $r_i$ increases relative to a reference distance $r_0$, governed by a decay parameter $b$. This is captured by a distance-dependent factor, $f_D(r_i)$. A standard form for this, which adheres to the directive, is:\n    $$ f_D(r_i) = \\exp[-b(r_i - r_0)] $$\n    This factor is equal to $1$ when $r_i = r_0$ and decays for $r_i  r_0$.\n\n*   **Angular Dependence:** Hydrogen bonds are directional, with maximum strength at a linear geometry, i.e., when the donor-hydrogen-acceptor angle $\\theta_i$ is $180^\\circ$. This is modeled by a bounded orientation factor, $f_A(\\theta_i)$, that is maximal at $\\theta_i = 180^\\circ$ and decreases as the bond bends. A physically motivated and common functional form for this is a power of the cosine of the angle. We will use a squared cosine term, which is $1$ at $180^\\circ$ and $0$ at $90^\\circ$:\n    $$ f_A(\\theta_i) = \\cos^2(\\theta_{i, \\mathrm{rad}}) $$\n    where $\\theta_{i, \\mathrm{rad}}$ is the angle $\\theta_i$ converted from degrees to radians. This choice ensures the factor is bounded between $0$ and $1$ and correctly captures the preference for linearity.\n\n*   **Final Energy Expression:** Combining these factors with the base energy scale, $E_0$, and noting that a favorable interaction has negative energy, we arrive at the full energy model:\n    $$ E_i(r_i, \\theta_i) = -E_0 \\cdot f_D(r_i) \\cdot f_A(\\theta_i) = -E_0 \\exp[-b(r_i - r_0)] \\cos^2(\\theta_{i, \\mathrm{rad}}) $$\n    All parameters ($E_0 = 25.0 \\text{ kJ/mol}$, $b = 1.5 \\text{ Å}^{-1}$, $r_0 = 2.8 \\text{ Å}$) are given. The angle $\\theta_i$ is provided in degrees and must be converted to radians for the cosine function.\n\n**2. Derivation of the Hydrogen Bond Lifetime Model, $\\tau_i$**\n\nThe dissociation of a hydrogen bond is a thermally activated process. Its kinetics can be modeled using an Arrhenius-type rate law.\n\n*   **Dissociation Rate ($k_{\\mathrm{off}, i}$):** The problem provides the expression for the dissociation rate constant:\n    $$ k_{\\mathrm{off}, i} = \\nu_0 \\exp\\left(-\\frac{E_a}{RT}\\right) $$\n    where $\\nu_0$ is the attempt frequency, $R$ is the gas constant, $T$ is the temperature, and $E_a$ is the activation energy for dissociation. The activation energy is modeled as a fraction of the hydrogen bond's stabilization energy, $|E_i|$, scaled by a factor $\\alpha$. Thus, $E_a = \\alpha |E_i|$. Substituting this into the rate equation gives:\n    $$ k_{\\mathrm{off}, i} = \\nu_0 \\exp\\left(-\\frac{\\alpha |E_i|}{RT}\\right) $$\n    Since $E_i$ is negative for a detected bond, $|E_i| = -E_i$.\n\n*   **Lifetime ($\\tau_i$):** The lifetime of the bond is the inverse of a first-order rate constant. Therefore, $\\tau_i$ is the reciprocal of $k_{\\mathrm{off}, i}$:\n    $$ \\tau_i = \\frac{1}{k_{\\mathrm{off}, i}} = \\frac{1}{\\nu_0} \\exp\\left(\\frac{\\alpha |E_i|}{RT}\\right) $$\n    All parameters ($\\nu_0 = 1.0 \\times 10^{12} \\text{ s}^{-1}$, $\\alpha = 0.5$, $R=0.008314 \\text{ kJ/(mol·K)}$, $T = 300.0 \\text{ K}$) are specified. The units are consistent, yielding a lifetime $\\tau_i$ in seconds.\n\n**3. Algorithmic Procedure for Sensitivity Analysis**\n\nThe core of the task is to implement a computational procedure to perform the sensitivity analysis for each given test case $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}}, \\Delta r, \\Delta \\theta)$.\n\nThe central computational kernel is a function that calculates the mean energy and lifetime for a given pair of thresholds, $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}})$. This function proceeds as follows:\n1.  Identify the subset $S$ of the $N=10$ candidate interactions that satisfy the detection criterion: $r_i \\leq r_{\\mathrm{thr}}$ and $\\theta_i \\geq \\theta_{\\mathrm{thr}}$.\n2.  If the set $S$ is empty, the mean energy $\\bar{E}$ and mean lifetime $\\bar{\\tau}$ are both defined to be $0$.\n3.  If $S$ is not empty, calculate $E_i$ and $\\tau_i$ for each interaction $i \\in S$ using the models derived above.\n4.  Compute the arithmetic means: $\\bar{E} = \\frac{1}{|S|} \\sum_{i \\in S} E_i$ and $\\bar{\\tau} = \\frac{1}{|S|} \\sum_{i \\in S} \\tau_i$.\n\nFor each test case, the full analysis involves these steps:\n1.  **Central Values:** Compute $\\bar{E}_0$ and $\\bar{\\tau}_0$ using the central thresholds $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}})$.\n\n2.  **Distance Sensitivity:**\n    *   Define perturbed distance thresholds: $r_{thr,+} = r_{\\mathrm{thr}} + \\Delta r$ and $r_{thr,-} = \\max(0, r_{\\mathrm{thr}} - \\Delta r)$.\n    *   Compute $(\\bar{E}_{+}^{(r)}, \\bar{\\tau}_{+}^{(r)})$ using $(r_{thr,+}, \\theta_{\\mathrmthr})$.\n    *   Compute $(\\bar{E}_{-}^{(r)}, \\bar{\\tau}_{-}^{(r)})$ using $(r_{thr,-}, \\theta_{\\mathrmthr})$.\n    *   Calculate the dimensionless relative changes:\n        $$ \\delta_E^{(r)} = \\frac{|\\bar{E}_{+}^{(r)} - \\bar{E}_{-}^{(r)}|}{\\max(|\\bar{E}_0|, \\varepsilon)}, \\quad \\delta_{\\tau}^{(r)} = \\frac{|\\bar{\\tau}_{+}^{(r)} - \\bar{\\tau}_{-}^{(r)}|}{\\max(|\\bar{\\tau}_0|, \\varepsilon)} $$\n\n3.  **Angle Sensitivity:**\n    *   Define perturbed angle thresholds: $\\theta_{thr,+} = \\min(180, \\theta_{\\mathrm{thr}} + \\Delta \\theta)$ and $\\theta_{thr,-} = \\max(0, \\theta_{\\mathrm{thr}} - \\Delta \\theta)$.\n    *   Compute $(\\bar{E}_{+}^{(\\theta)}, \\bar{\\tau}_{+}^{(\\theta)})$ using $(r_{\\mathrmthr}, \\theta_{thr,+})$.\n    *   Compute $(\\bar{E}_{-}^{(\\theta)}, \\bar{\\tau}_{-}^{(\\theta)})$ using $(r_{\\mathrmthr}, \\theta_{thr,-})$.\n    *   Calculate the dimensionless relative changes:\n        $$ \\delta_E^{(\\theta)} = \\frac{|\\bar{E}_{+}^{(\\theta)} - \\bar{E}_{-}^{(\\theta)}|}{\\max(|\\bar{E}_0|, \\varepsilon)}, \\quad \\delta_{\\tau}^{(\\theta)} = \\frac{|\\bar{\\tau}_{+}^{(\\theta)} - \\bar{\\tau}_{-}^{(\\theta)}|}{\\max(|\\bar{\\tau}_0|, \\varepsilon)} $$\n\n4.  **Robustness Evaluation:**\n    *   Determine the boolean robustness flag by comparing all four sensitivity metrics against the tolerance $\\rho = 0.20$:\n        $$ \\mathrm{robust} = (\\delta_E^{(r)} \\leq \\rho) \\land (\\delta_E^{(\\theta)} \\leq \\rho) \\land (\\delta_{\\tau}^{(r)} \\leq \\rho) \\land (\\delta_{\\tau}^{(\\theta)} \\leq \\rho) $$\n\n5.  **Output Assembly:**\n    *   For each test case, the final result is an ordered list of $7$ values: $[\\bar{E}_0, \\bar{\\tau}_0, \\delta_E^{(r)}, \\delta_E^{(\\theta)}, \\delta_{\\tau}^{(r)}, \\delta_{\\tau}^{(\\theta)}, \\mathrm{robust}]$. The implementation will perform this calculation for all four test cases and format the output as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hydrogen bond sensitivity analysis problem.\n    \"\"\"\n\n    # --- Givens: Candidate Interactions, Constants, and Parameters ---\n\n    # Candidate interactions\n    # N = 10\n    distances_A = np.array([2.70, 2.90, 3.10, 3.30, 2.80, 3.00, 3.40, 2.60, 3.20, 2.75])\n    angles_deg = np.array([175, 160, 140, 130, 155, 145, 120, 178, 150, 165])\n\n    # Physical constants and model parameters\n    E0 = 25.0        # kJ/mol\n    b = 1.5          # 1/Å\n    r0 = 2.8         # Å\n    nu0 = 1.0e12     # 1/s\n    alpha = 0.5      # dimensionless\n    R = 0.008314     # kJ/(mol·K)\n    T = 300.0        # K\n    epsilon = 1.0e-12# dimensionless stabilizer\n    rho = 0.20       # dimensionless robustness tolerance\n\n    # Pre-calculate RT for efficiency\n    RT = R * T\n\n    # Test suite\n    test_cases = [\n        (3.20, 150.0, 0.10, 5.0),\n        (2.80, 170.0, 0.05, 2.0),\n        (4.00, 120.0, 0.20, 10.0),\n        (2.50, 175.0, 0.10, 5.0),\n    ]\n\n    # --- Core Calculation Logic ---\n\n    def calculate_means(r_thr, theta_thr):\n        \"\"\"\n        Calculates mean energy and lifetime for a given set of thresholds.\n        \"\"\"\n        detected_energies = []\n        detected_lifetimes = []\n\n        for r_i, theta_i_deg in zip(distances_A, angles_deg):\n            if r_i = r_thr and theta_i_deg = theta_thr:\n                # Convert angle to radians for trigonometric functions\n                theta_i_rad = np.deg2rad(theta_i_deg)\n\n                # Calculate energy E_i\n                E_i = -E0 * np.exp(-b * (r_i - r0)) * (np.cos(theta_i_rad)**2)\n\n                # Calculate lifetime tau_i\n                abs_Ei = abs(E_i)\n                tau_i = (1.0 / nu0) * np.exp((alpha * abs_Ei) / RT)\n\n                detected_energies.append(E_i)\n                detected_lifetimes.append(tau_i)\n\n        if not detected_energies:  # The set of detected bonds S is empty\n            return 0.0, 0.0\n        \n        mean_E = np.mean(detected_energies)\n        mean_tau = np.mean(detected_lifetimes)\n        return mean_E, mean_tau\n\n    # --- Main Analysis Loop ---\n\n    all_results = []\n    for r_thr, theta_thr, dr, dtheta in test_cases:\n        # 1. Central values\n        E0_bar, tau0_bar = calculate_means(r_thr, theta_thr)\n\n        # 2. Sensitivity to distance threshold r_thr\n        r_thr_plus = r_thr + dr\n        r_thr_minus = max(0.0, r_thr - dr)\n        E_plus_r, tau_plus_r = calculate_means(r_thr_plus, theta_thr)\n        E_minus_r, tau_minus_r = calculate_means(r_thr_minus, theta_thr)\n\n        delta_E_r = abs(E_plus_r - E_minus_r) / max(abs(E0_bar), epsilon)\n        delta_tau_r = abs(tau_plus_r - tau_minus_r) / max(abs(tau0_bar), epsilon)\n\n        # 3. Sensitivity to angle threshold theta_thr\n        theta_thr_plus = min(180.0, theta_thr + dtheta)\n        theta_thr_minus = max(0.0, theta_thr - dtheta)\n        E_plus_theta, tau_plus_theta = calculate_means(r_thr, theta_thr_plus)\n        E_minus_theta, tau_minus_theta = calculate_means(r_thr, theta_thr_minus)\n\n        delta_E_theta = abs(E_plus_theta - E_minus_theta) / max(abs(E0_bar), epsilon)\n        delta_tau_theta = abs(tau_plus_theta - tau_minus_theta) / max(abs(tau0_bar), epsilon)\n\n        # 4. Robustness evaluation\n        is_robust = (delta_E_r = rho and\n                     delta_E_theta = rho and\n                     delta_tau_r = rho and\n                     delta_tau_theta = rho)\n\n        # 5. Assemble results for the current test case\n        result_for_case = [\n            E0_bar, tau0_bar,\n            delta_E_r, delta_E_theta,\n            delta_tau_r, delta_tau_theta,\n            is_robust\n        ]\n        all_results.append(result_for_case)\n\n    # --- Final Output Formatting ---\n    # Manually construct the string to avoid spaces introduced by str(list)\n    # and to ensure the exact format requested.\n    \n    output_parts = []\n    for res_list in all_results:\n        inner_parts = []\n        for val in res_list:\n            inner_parts.append(str(val))\n        output_parts.append('[' + ','.join(inner_parts) + ']')\n    \n    final_output_string = '[' + ','.join(output_parts) + ']'\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Hydrogen bonds are dynamic entities, flickering in and out of existence on picosecond timescales. This exercise transitions from a static, structural view to a dynamic, kinetic one. By analyzing the time-evolution of a hydrogen bond's presence, you will derive and apply the relationship between a bond's autocorrelation function and its underlying kinetic rates of formation ($k_{\\mathrm{form}}$) and breaking ($k_{\\mathrm{break}}$), a fundamental technique for quantifying molecular dynamics. ",
            "id": "3849595",
            "problem": "A Molecular Dynamics (MD) simulation of a protein–ligand complex monitors a specific donor–acceptor hydrogen bond. Let the binary occupancy operator $h(t)$ equal $1$ when the hydrogen bond is present at time $t$ and $0$ otherwise. Assume the bond dynamics are well-described by a continuous-time two-state Markov process with states $F$ (bond formed) and $U$ (bond unformed), and constant rate constants $k_{\\mathrm{break}}$ for $F \\to U$ and $k_{\\mathrm{form}}$ for $U \\to F$. The intermittent hydrogen-bond autocorrelation function $C_{\\mathrm{int}}(t)$ is defined by the ratio of the ensemble average of $h(0) h(t)$ to the equilibrium average of $h$, so that $C_{\\mathrm{int}}(t) = \\langle h(0) h(t) \\rangle / \\langle h \\rangle$. The system is at steady state.\n\nUsing only the core definitions of the two-state kinetics and the definition of $C_{\\mathrm{int}}(t)$, first derive the relationship between $C_{\\mathrm{int}}(t)$ and the rate constants $k_{\\mathrm{break}}$ and $k_{\\mathrm{form}}$ for this two-state model. Then, an empirical fit to the simulated intermittent correlation function over the range $t \\in [0, 10]$ picoseconds yields\n$$\nC_{\\mathrm{int}}(t) = 0.57 + 0.43 \\exp\\!\\left(-\\frac{t}{0.83\\ \\mathrm{ps}}\\right).\n$$\nTreat the coefficients and the time constant in this fit as exact for the purpose of calculation. Estimate $k_{\\mathrm{break}}$ and $k_{\\mathrm{form}}$.\n\nExpress both $k_{\\mathrm{break}}$ and $k_{\\mathrm{form}}$ in $\\mathrm{ps}^{-1}$ and round each to four significant figures. The final answer must be given as a two-entry row matrix in the order $k_{\\mathrm{break}}$ and $k_{\\mathrm{form}}$.",
            "solution": "The problem requires the derivation of an expression for the intermittent hydrogen-bond autocorrelation function, $C_{\\mathrm{int}}(t)$, for a two-state Markov process, and then using an empirical fit to this function to determine the underlying kinetic rate constants $k_{\\mathrm{break}}$ and $k_{\\mathrm{form}}$.\n\nFirst, we validate the problem statement.\n\n### Step 1: Extract Givens\n-   Binary occupancy operator: $h(t) = 1$ if the bond is formed (state $F$), $h(t) = 0$ if unformed (state $U$).\n-   Kinetic model: Continuous-time two-state Markov process, $F \\rightleftharpoons U$.\n-   Rate constants: $k_{\\mathrm{break}}$ for the transition $F \\to U$, and $k_{\\mathrm{form}}$ for $U \\to F$.\n-   System condition: The system is at steady state.\n-   Definition of the intermittent autocorrelation function: $C_{\\mathrm{int}}(t) = \\frac{\\langle h(0) h(t) \\rangle}{\\langle h \\rangle}$.\n-   Empirical fit to the simulated data: $C_{\\mathrm{int}}(t) = 0.57 + 0.43 \\exp\\left(-\\frac{t}{0.83\\ \\mathrm{ps}}\\right)$.\n-   Instruction: Treat the numerical coefficients ($0.57$, $0.43$) and the time constant ($0.83\\ \\mathrm{ps}$) as exact.\n-   Objective: Estimate $k_{\\mathrm{break}}$ and $k_{\\mathrm{form}}$ in units of $\\mathrm{ps}^{-1}$, rounded to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientifically Grounded:** The problem is based on the standard and widely used two-state kinetic model for chemical processes, a cornerstone of chemical kinetics and computational biophysics. The use of autocorrelation functions to analyze time-series data from molecular simulations is a fundamental technique. The model is scientifically valid.\n-   **Well-Posed:** The problem provides a clear theoretical framework, a specific definition for the observable quantity $C_{\\mathrm{int}}(t)$, and sufficient empirical data to uniquely determine the model parameters ($k_{\\mathrm{break}}$ and $k_{\\mathrm{form}}$). The problem is well-posed.\n-   **Objective:** The problem is stated in precise, unambiguous scientific language, free of subjective elements.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically sound, well-posed, objective, and contains all necessary information. We proceed with the solution.\n\n### Derivation of the Theoretical Expression for $C_{\\mathrm{int}}(t)$\n\nThe intermittent autocorrelation function is defined as $C_{\\mathrm{int}}(t) = \\frac{\\langle h(0) h(t) \\rangle}{\\langle h \\rangle}$. Let $P_F$ be the equilibrium probability of the bond being formed (state $F$) and $P_U$ be the equilibrium probability of the bond being unformed (state $U$). By definition, $P_F + P_U = 1$.\n\nThe ensemble average $\\langle h \\rangle$ is the equilibrium probability of the bond being formed, as $h$ is $1$ for state $F$ and $0$ for state $U$.\n$$\n\\langle h \\rangle = (1) \\cdot P_F + (0) \\cdot P_U = P_F\n$$\nThe term $\\langle h(0) h(t) \\rangle$ is the joint probability of finding the bond formed at time $t=0$ and also at time $t$. Since the system is at steady state, the process is stationary. We can write this joint probability using conditional probability:\n$$\n\\langle h(0) h(t) \\rangle = P(h(t)=1, h(0)=1) = P(h(t)=1 | h(0)=1) \\cdot P(h(0)=1)\n$$\nHere, $P(h(0)=1)$ is the equilibrium probability $P_F$, and $P(h(t)=1 | h(0)=1)$ is the conditional probability that the bond is formed at time $t$, given that it was formed at time $t=0$. Let's denote this as $P_{F|F}(t)$.\n\nSubstituting these into the definition of $C_{\\mathrm{int}}(t)$:\n$$\nC_{\\mathrm{int}}(t) = \\frac{P_{F|F}(t) \\cdot P_F}{P_F} = P_{F|F}(t)\n$$\nThus, $C_{\\mathrm{int}}(t)$ is the conditional probability of the bond being formed at time $t$ given it was formed at $t=0$.\n\nNow, we must find an expression for $P_{F|F}(t)$ from the master equation of the two-state process. Let $P_F(t)$ and $P_U(t)$ be the probabilities of being in states $F$ and $U$ at time $t$. The rate equations are:\n$$\n\\frac{d P_F(t)}{dt} = k_{\\mathrm{form}} P_U(t) - k_{\\mathrm{break}} P_F(t)\n$$\nUsing the constraint $P_F(t) + P_U(t) = 1$, we can write $P_U(t) = 1 - P_F(t)$. Substituting this into the rate equation gives a first-order linear ordinary differential equation for $P_F(t)$:\n$$\n\\frac{d P_F(t)}{dt} = k_{\\mathrm{form}} (1 - P_F(t)) - k_{\\mathrm{break}} P_F(t) = k_{\\mathrm{form}} - (k_{\\mathrm{form}} + k_{\\mathrm{break}}) P_F(t)\n$$\nThe general solution to this ODE is of the form $P_F(t) = P_{F,\\text{eq}} + (P_F(0) - P_{F,\\text{eq}}) \\exp(-k_{\\text{relax}} t)$, where $P_F(0)$ is the initial probability at $t=0$, $k_{\\text{relax}} = k_{\\mathrm{form}} + k_{\\mathrm{break}}$ is the relaxation rate, and $P_{F,\\text{eq}}$ is the equilibrium probability.\n\nAt equilibrium (steady state), $\\frac{d P_F}{dt} = 0$, which gives $k_{\\mathrm{form}} P_{U,\\text{eq}} = k_{\\mathrm{break}} P_{F,\\text{eq}}$.\nUsing $P_{U,\\text{eq}} = 1 - P_{F,\\text{eq}}$, we have $k_{\\mathrm{form}}(1 - P_{F,\\text{eq}}) = k_{\\mathrm{break}} P_{F,\\text{eq}}$.\nSolving for $P_{F,\\text{eq}}$ yields:\n$$\nP_{F,\\text{eq}} = \\frac{k_{\\mathrm{form}}}{k_{\\mathrm{form}} + k_{\\mathrm{break}}}\n$$\nAnd consequently:\n$$\nP_{U,\\text{eq}} = 1 - P_{F,\\text{eq}} = \\frac{k_{\\mathrm{break}}}{k_{\\mathrm{form}} + k_{\\mathrm{break}}}\n$$\nTo find $C_{\\mathrm{int}}(t) = P_{F|F}(t)$, we solve the ODE with the initial condition that the system is in state $F$ at $t=0$, which means $P_F(0)=1$.\n$$\nC_{\\mathrm{int}}(t) = P_F(t)|_{P_F(0)=1} = P_{F,\\text{eq}} + (1 - P_{F,\\text{eq}}) \\exp \\left( -(k_{\\mathrm{form}} + k_{\\mathrm{break}})t \\right)\n$$\nSubstituting the expressions for the equilibrium probabilities:\n$$\nC_{\\mathrm{int}}(t) = P_{F,\\text{eq}} + P_{U,\\text{eq}} \\exp \\left( -(k_{\\mathrm{form}} + k_{\\mathrm{break}})t \\right)\n$$\nThis is the theoretical expression for the intermittent autocorrelation function in this model.\n\n### Estimation of Rate Constants\n\nThe derived theoretical form is:\n$$\nC_{\\mathrm{int}}(t) = \\frac{k_{\\mathrm{form}}}{k_{\\mathrm{form}} + k_{\\mathrm{break}}} + \\frac{k_{\\mathrm{break}}}{k_{\\mathrm{form}} + k_{\\mathrm{break}}} \\exp \\left( -(k_{\\mathrm{form}} + k_{\\mathrm{break}})t \\right)\n$$\nThe problem provides the empirical fit:\n$$\nC_{\\mathrm{int}}(t) = 0.57 + 0.43 \\exp\\left(-\\frac{t}{0.83\\ \\mathrm{ps}}\\right)\n$$\nBy comparing the theoretical expression with the empirical fit, we can equate the corresponding terms.\nThe constant offset term corresponds to the equilibrium probability $P_{F,\\text{eq}}$:\n$$\nP_{F,\\text{eq}} = \\frac{k_{\\mathrm{form}}}{k_{\\mathrm{form}} + k_{\\mathrm{break}}} = 0.57\n$$\nThe pre-exponential factor corresponds to the equilibrium probability $P_{U,\\text{eq}}$:\n$$\nP_{U,\\text{eq}} = \\frac{k_{\\mathrm{break}}}{k_{\\mathrm{form}} + k_{\\mathrm{break}}} = 0.43\n$$\nNote that $P_{F,\\text{eq}} + P_{U,\\text{eq}} = 0.57 + 0.43 = 1.00$, which is consistent.\n\nThe relaxation rate $k_{\\text{relax}}$ is in the exponent:\n$$\nk_{\\text{relax}} = k_{\\mathrm{form}} + k_{\\mathrm{break}} = \\frac{1}{0.83\\ \\mathrm{ps}}\n$$\nWe now have a system of equations to solve for $k_{\\mathrm{break}}$ and $k_{\\mathrm{form}}$.\nFrom the equation for $P_{U,\\text{eq}}$, we can write:\n$$\nk_{\\mathrm{break}} = P_{U,\\text{eq}} \\cdot (k_{\\mathrm{form}} + k_{\\mathrm{break}})\n$$\nSubstituting the values we have identified:\n$$\nk_{\\mathrm{break}} = (0.43) \\cdot \\left( \\frac{1}{0.83\\ \\mathrm{ps}} \\right) = \\frac{0.43}{0.83}\\ \\mathrm{ps}^{-1}\n$$\nSimilarly, from the equation for $P_{F,\\text{eq}}$:\n$$\nk_{\\mathrm{form}} = P_{F,\\text{eq}} \\cdot (k_{\\mathrm{form}} + k_{\\mathrm{break}})\n$$\nSubstituting the identified values:\n$$\nk_{\\mathrm{form}} = (0.57) \\cdot \\left( \\frac{1}{0.83\\ \\mathrm{ps}} \\right) = \\frac{0.57}{0.83}\\ \\mathrm{ps}^{-1}\n$$\n\n### Numerical Calculation\n\nNow we compute the numerical values and round them to four significant figures as requested.\n$$\nk_{\\mathrm{break}} = \\frac{0.43}{0.83} \\ \\mathrm{ps}^{-1} \\approx 0.518072289... \\ \\mathrm{ps}^{-1}\n$$\nRounding to four significant figures gives:\n$$\nk_{\\mathrm{break}} \\approx 0.5181 \\ \\mathrm{ps}^{-1}\n$$\n$$\nk_{\\mathrm{form}} = \\frac{0.57}{0.83} \\ \\mathrm{ps}^{-1} \\approx 0.686746988... \\ \\mathrm{ps}^{-1}\n$$\nRounding to four significant figures gives:\n$$\nk_{\\mathrm{form}} \\approx 0.6867 \\ \\mathrm{ps}^{-1}\n$$\nThe final answer should be a row matrix containing $k_{\\mathrm{break}}$ and $k_{\\mathrm{form}}$ in that order.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0.5181  0.6867 \\end{pmatrix}}\n$$"
        }
    ]
}