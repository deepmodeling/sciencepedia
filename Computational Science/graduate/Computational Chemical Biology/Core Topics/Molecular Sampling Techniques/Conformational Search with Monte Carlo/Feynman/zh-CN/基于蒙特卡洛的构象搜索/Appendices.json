{
    "hands_on_practices": [
        {
            "introduction": "为了将理论付诸实践，我们从蒙特卡洛（MC）模拟的核心决策步骤开始。这个练习将引导你计算一个构象变化的能量变化（$\\Delta E$），并根据 Metropolis 准则评估其在给定温度下的接受概率。通过这个基础计算，你将掌握 MC 算法中决定“接受”或“拒绝”一个新构象的关键机制。",
            "id": "3840331",
            "problem": "一个柔性配体中的单个二面角 $\\phi$ 由扭转势能模拟\n$$\nE_{\\text{dihedral}}(\\phi) \\;=\\; \\sum_{n=1}^{3} \\frac{V_n}{2}\\,\\big[1 + \\cos(n\\phi - \\gamma_n)\\big],\n$$\n其中所有角度单位均为弧度，能量单位为 $\\text{kJ}\\,\\text{mol}^{-1}$。考虑一个正则系综蒙特卡洛（MC）移动，该移动建议使用一个关于 $\\phi$ 的对称提议分布，将扭转角从初始值 $\\phi$ 更改为新值 $\\phi'$。假设此扭转项捕捉了该移动的相关能量变化（即，在此步骤中忽略与其他自由度的耦合）。\n\n该扭转的参数为：$V_1 = 2.5\\,\\text{kJ}\\,\\text{mol}^{-1}$ 且 $\\gamma_1 = 0$， $V_2 = 1.2\\,\\text{kJ}\\,\\text{mol}^{-1}$ 且 $\\gamma_2 = \\pi/3$，以及 $V_3 = 0.8\\,\\text{kJ}\\,\\text{mol}^{-1}$ 且 $\\gamma_3 = \\pi$。初始角度为 $\\phi = 2.1$，提议的角度为 $\\phi' = \\phi + \\Delta\\phi$，其中 $\\Delta\\phi = -0.7$（因此 $\\phi' = 1.4$）。温度为 $T = 300\\,\\text{K}$。\n\n从正则系综和适用于马尔可夫链蒙特卡洛（MCMC）中对称提议的细致平衡原理出发，计算能量变化 $\\Delta E = E_{\\text{dihedral}}(\\phi') - E_{\\text{dihedral}}(\\phi)$，然后评估在温度 $T$ 下此移动的接受概率。\n\n将最终答案表示为接受概率，以十进制形式表示，并四舍五入到四位有效数字。最终数字不包括单位。",
            "solution": "该问题要求计算在正则系综中蒙特卡洛移动的接受概率。对此的标准方法是 Metropolis-Hastings 算法。从具有构型 $\\phi$ 的状态移动到新构型 $\\phi'$ 的接受概率 $P_{\\text{acc}}$ 由下式给出：\n$$P_{\\text{acc}}(\\phi \\to \\phi') = \\min\\left(1, \\frac{\\pi(\\phi')}{\\pi(\\phi)} \\frac{g(\\phi|\\phi')}{g(\\phi'|\\phi)}\\right)$$\n其中 $\\pi(x)$ 是目标分布中状态 $x$ 的概率，而 $g(y|x)$ 是在给定状态 $x$ 的情况下提议状态 $y$ 的条件概率。\n\n在正则系综中，一个状态的概率与其玻尔兹曼因子成正比，$\\pi(\\phi) \\propto \\exp(-E(\\phi)/(k_B T))$，其中 $E(\\phi)$ 是该状态的能量，$k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。问题指出提议分布是对称的，这意味着 $g(\\phi|\\phi') = g(\\phi'|\\phi)$。在这些条件下，接受概率简化为 Metropolis 判据：\n$$P_{\\text{acc}}(\\phi \\to \\phi') = \\min\\left(1, \\frac{\\exp(-E(\\phi')/(k_B T))}{\\exp(-E(\\phi)/(k_B T))}\\right) = \\min\\left(1, \\exp\\left(-\\frac{E(\\phi') - E(\\phi)}{k_B T}\\right)\\right)$$\n令 $\\Delta E = E(\\phi') - E(\\phi)$ 为能量变化。接受概率为：\n$$P_{\\text{acc}} = \\min(1, \\exp(-\\Delta E / (k_B T)))$$\n由于给定的能量单位是 $\\text{kJ}\\,\\text{mol}^{-1}$，我们必须使用摩尔气体常数 $R$ 而不是玻尔兹曼常数 $k_B$。热能是 $RT$。\n\n第一步是计算能量变化 $\\Delta E = E_{\\text{dihedral}}(\\phi') - E_{\\text{dihedral}}(\\phi)$。使用所提供的势能函数：\n$$\n\\Delta E = \\sum_{n=1}^{3} \\frac{V_n}{2}\\,\\big[1 + \\cos(n\\phi' - \\gamma_n)\\big] - \\sum_{n=1}^{3} \\frac{V_n}{2}\\,\\big[1 + \\cos(n\\phi - \\gamma_n)\\big]\n$$\n括号内的常数 $1$ 在相减时被消去，得到：\n$$\n\\Delta E = \\sum_{n=1}^{3} \\frac{V_n}{2}\\,\\big[\\cos(n\\phi' - \\gamma_n) - \\cos(n\\phi - \\gamma_n)\\big]\n$$\n我们已知初始角度 $\\phi = 2.1\\,\\text{rad}$ 和提议角度 $\\phi' = 1.4\\,\\text{rad}$。我们现在为每一项 $n=1, 2, 3$ 计算对 $\\Delta E$ 的贡献。\n\n对于 $n=1$：$V_1 = 2.5\\,\\text{kJ}\\,\\text{mol}^{-1}$，$\\gamma_1 = 0$。\n$$\n\\Delta E_1 = \\frac{2.5}{2} \\big[\\cos(1 \\cdot 1.4 - 0) - \\cos(1 \\cdot 2.1 - 0)\\big] = 1.25 \\big[\\cos(1.4) - \\cos(2.1)\\big]\n$$\n使用弧度模式的计算器：\n$$\n\\cos(1.4) \\approx 0.169967 \\quad \\text{and} \\quad \\cos(2.1) \\approx -0.504846\n$$\n$$\n\\Delta E_1 \\approx 1.25 \\big[0.169967 - (-0.504846)\\big] = 1.25 \\big[0.674813\\big] \\approx 0.843516\\,\\text{kJ}\\,\\text{mol}^{-1}\n$$\n\n对于 $n=2$：$V_2 = 1.2\\,\\text{kJ}\\,\\text{mol}^{-1}$，$\\gamma_2 = \\pi/3$。\n$$\n\\Delta E_2 = \\frac{1.2}{2} \\big[\\cos(2 \\cdot 1.4 - \\pi/3) - \\cos(2 \\cdot 2.1 - \\pi/3)\\big] = 0.6 \\big[\\cos(2.8 - \\pi/3) - \\cos(4.2 - \\pi/3)\\big]\n$$\n使用 $\\pi \\approx 3.141593$：\n$$\n\\cos(2.8 - \\pi/3) \\approx \\cos(2.8 - 1.047198) = \\cos(1.752802) \\approx -0.180425\n$$\n$$\n\\cos(4.2 - \\pi/3) \\approx \\cos(4.2 - 1.047198) = \\cos(3.152802) \\approx -0.999818\n$$\n$$\n\\Delta E_2 \\approx 0.6 \\big[-0.180425 - (-0.999818)\\big] = 0.6 \\big[0.819393\\big] \\approx 0.491636\\,\\text{kJ}\\,\\text{mol}^{-1}\n$$\n\n对于 $n=3$：$V_3 = 0.8\\,\\text{kJ}\\,\\text{mol}^{-1}$，$\\gamma_3 = \\pi$。\n$$\n\\Delta E_3 = \\frac{0.8}{2} \\big[\\cos(3 \\cdot 1.4 - \\pi) - \\cos(3 \\cdot 2.1 - \\pi)\\big] = 0.4 \\big[\\cos(4.2 - \\pi) - \\cos(6.3 - \\pi)\\big]\n$$\n$$\n\\cos(4.2 - \\pi) \\approx \\cos(4.2 - 3.141593) = \\cos(1.058407) \\approx 0.490056\n$$\n$$\n\\cos(6.3 - \\pi) \\approx \\cos(6.3 - 3.141593) = \\cos(3.158407) \\approx -0.999718\n$$\n$$\n\\Delta E_3 \\approx 0.4 \\big[0.490056 - (-0.999718)\\big] = 0.4 \\big[1.489774\\big] \\approx 0.595910\\,\\text{kJ}\\,\\text{mol}^{-1}\n$$\n\n总能量变化是这些贡献的总和：\n$$\n\\Delta E = \\Delta E_1 + \\Delta E_2 + \\Delta E_3 \\approx 0.843516 + 0.491636 + 0.595910 = 1.931062\\,\\text{kJ}\\,\\text{mol}^{-1}\n$$\n由于 $\\Delta E > 0$，该移动在能量上是不利的，接受概率将小于 $1$。\n\n接下来，我们计算热能 $RT$。\n$$\nR \\approx 8.31446 \\times 10^{-3}\\,\\text{kJ}\\,\\text{mol}^{-1}\\,\\text{K}^{-1} \\quad \\text{and} \\quad T = 300\\,\\text{K}\n$$\n$$\nRT \\approx (8.31446 \\times 10^{-3}) \\cdot 300 = 2.494338\\,\\text{kJ}\\,\\text{mol}^{-1}\n$$\n现在我们计算接受概率公式中的指数：\n$$\n-\\frac{\\Delta E}{RT} \\approx -\\frac{1.931062}{2.494338} \\approx -0.774180\n$$\n最后，我们计算接受概率：\n$$\nP_{\\text{acc}} = \\exp\\left(-\\frac{\\Delta E}{RT}\\right) \\approx \\exp(-0.774180) \\approx 0.461064\n$$\n问题要求结果四舍五入到四位有效数字。\n$$\nP_{\\text{acc}} \\approx 0.4611\n$$",
            "answer": "$$\n\\boxed{0.4611}\n$$"
        },
        {
            "introduction": "在实际的分子模拟中，构象变化的提议（proposal）往往不是对称的，例如从一个包含不同数量可选构象的 rotamer 库中进行选择。为了确保对目标玻尔兹曼分布的正确采样，我们必须使用更普适的 Metropolis-Hastings 准则，它通过引入提议概率比来修正这种不对称性。这个练习将让你在一个具体的离散 rotamer 翻转场景中，应用 Metropolis-Hastings 算法计算接受概率。",
            "id": "3840278",
            "problem": "使用正则系综中的马尔可夫链蒙特卡洛算法，对蛋白质中的一个单残基侧链进行构象搜索。该侧链由一个离散的旋转异构体库表示。在任何时刻，一个提议包括从一个依赖于状态、经过空间位阻过滤的瞬时允许旋转异构体集合中，均匀地选择一个与当前旋转异构体不同的新旋转异构体。在一次移动后，瞬时允许的旋转异构体集合可能会改变，因为与环境的空间位阻冲突取决于当前的侧链朝向。\n\n考虑在温度 $T = 300\\ \\mathrm{K}$下，从当前旋转异构体 $i$ 移动到新旋转异构体 $j$ 的一个提议移动。势能是扭转项和非键项之和，因此移动带来的势能变化为 $\\Delta U = \\Delta U_{\\mathrm{tor}} + \\Delta U_{\\mathrm{nb}}$。对于这个特定的移动，扭转能变为 $\\Delta U_{\\mathrm{tor}} = +2.3\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}$，非键能变为 $\\Delta U_{\\mathrm{nb}} = -0.5\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}$。摩尔气体常数为 $R = 8.314462618\\times 10^{-3}\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{K}^{-1}$。\n\n由于空间位阻过滤，当系统处于旋转异构体 $i$ 时，有 $K_{i} = 3$ 个允许的旋转异构体（包括 $i$ 本身），提议机制从与 $i$ 不同的 $K_{i}-1$ 个备选项中均匀抽取。移动后，当系统将处于旋转异构体 $j$ 时，有 $K_{j} = 6$ 个允许的旋转异构体（包括 $j$ 本身），并且从 $j$ 出发，提议机制将从与 $j$ 不同的 $K_{j}-1$ 个备选项中均匀抽取。\n\n从正则玻尔兹曼分布和马尔可夫链的细致平衡要求出发，推导移动 $i \\to j$ 的正确接受概率，该概率需要考虑到由依赖状态的允许旋转异构体集合所引起的离散提议机制可能的不对称性。然后，根据上述数据，对此接受概率进行数值计算。将最终答案表示为一个四舍五入到四位有效数字的无量纲数。\n\n用一两句话简要说明，如果从任何状态提议时，不是在允许的备选项中进行均匀选择，而是使用依赖于状态的偏置权重，那么接受表达式应如何修改。",
            "solution": "从目标概率分布中抽样的马尔可夫链蒙特卡洛（MCMC）模拟的基础是细致平衡条件。此条件确保马尔可夫链的平稳分布是所需的目标分布。对于正则系综中的系统，目标分布是玻尔兹曼分布，其中势能为 $U(x)$ 的状态 $x$ 在温度 $T$ 下的概率 $P(x)$ 由下式给出（假设 $U(x)$ 为摩尔能量）：\n$$ P(x) \\propto \\exp\\left(-\\frac{U(x)}{RT}\\right) $$\n其中 $R$ 是摩尔气体常数。\n\n对于任意两个状态，比如 $i$ 和 $j$，细致平衡条件为：\n$$ P(i) \\cdot T(i \\to j) = P(j) \\cdot T(j \\to i) $$\n其中 $T(i \\to j)$ 是从状态 $i$ 到状态 $j$ 的总转移概率。\n\n在 Metropolis-Hastings 算法中，转移概率是提议概率 $g(i \\to j)$ 和接受概率 $A(i \\to j)$ 的乘积：\n$$ T(i \\to j) = g(i \\to j) \\cdot A(i \\to j) \\quad (\\text{for } i \\neq j) $$\n将此代入细致平衡方程，得到：\n$$ P(i) \\cdot g(i \\to j) \\cdot A(i \\to j) = P(j) \\cdot g(j \\to i) \\cdot A(j \\to i) $$\n满足此条件的接受概率的一般形式由下式给出：\n$$ A(i \\to j) = \\min\\left(1, \\frac{P(j) \\cdot g(j \\to i)}{P(i) \\cdot g(i \\to j)}\\right) $$\n\n我们必须首先确定玻尔兹曼概率的比率和提议概率的比率。玻尔兹曼概率的比率为：\n$$ \\frac{P(j)}{P(i)} = \\frac{\\exp(-U(j)/(RT))}{\\exp(-U(i)/(RT))} = \\exp\\left(-\\frac{U(j) - U(i)}{RT}\\right) = \\exp\\left(-\\frac{\\Delta U}{RT}\\right) $$\n其中 $\\Delta U = U(j) - U(i)$ 是移动 $i \\to j$ 的势能变化。\n\n提议概率 $g(i \\to j)$ 是在系统当前处于状态 $i$ 的情况下，提议移动到状态 $j$ 的概率。问题陈述，从状态 $i$ 出发，有 $K_i$ 个空间位阻允许的旋转异构体（包括 $i$ 本身）。从 $K_i - 1$ 个备选项中均匀选择一个新的旋转异构体。因此，提议移动到特定旋转异构体 $j$ 的概率是：\n$$ g(i \\to j) = \\frac{1}{K_i - 1} $$\n类似地，逆向移动（从 $j$ 到 $i$）的提议概率取决于从状态 $j$ 出发的 $K_j$ 个允许的旋转异构体。从 $j$ 的 $K_j - 1$ 个备选项中选择 $i$ 的概率是：\n$$ g(j \\to i) = \\frac{1}{K_j - 1} $$\n由于 $K_i \\neq K_j$，提议机制是不对称的。\n\n将这些表达式代入接受概率公式，得到 Metropolis-Hastings 接受准则：\n$$ A(i \\to j) = \\min\\left(1, \\exp\\left(-\\frac{\\Delta U}{RT}\\right) \\cdot \\frac{g(j \\to i)}{g(i \\to j)}\\right) $$\n$$ A(i \\to j) = \\min\\left(1, \\exp\\left(-\\frac{\\Delta U}{RT}\\right) \\cdot \\frac{1/(K_j - 1)}{1/(K_i - 1)}\\right) $$\n$$ A(i \\to j) = \\min\\left(1, \\frac{K_i - 1}{K_j - 1} \\exp\\left(-\\frac{\\Delta U}{RT}\\right)\\right) $$\n这是所要求的接受概率表达式。\n\n现在，我们使用所提供的数据对该表达式进行数值计算。\n势能变化为：\n$$ \\Delta U = \\Delta U_{\\mathrm{tor}} + \\Delta U_{\\mathrm{nb}} = +2.3\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1} + (-0.5\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}) = 1.8\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1} $$\n热能为：\n$$ RT = (8.314462618 \\times 10^{-3}\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{K}^{-1}) \\cdot (300\\ \\mathrm{K}) \\approx 2.4943388\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1} $$\n指数函数的参数是：\n$$ -\\frac{\\Delta U}{RT} = -\\frac{1.8\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}}{2.4943388\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}} \\approx -0.72164 $$\n指数项是：\n$$ \\exp\\left(-\\frac{\\Delta U}{RT}\\right) \\approx \\exp(-0.72164) \\approx 0.48596 $$\n提议概率比率为：\n$$ \\frac{K_i - 1}{K_j - 1} = \\frac{3 - 1}{6 - 1} = \\frac{2}{5} = 0.4 $$\n结合这些项，$\\min$ 函数的参数是：\n$$ \\frac{K_i - 1}{K_j - 1} \\exp\\left(-\\frac{\\Delta U}{RT}\\right) \\approx 0.4 \\times 0.48596 = 0.194384 $$\n最后，接受概率是：\n$$ A(i \\to j) = \\min(1, 0.194384) = 0.194384 $$\n四舍五入到四位有效数字，接受概率为 $0.1944$。\n\n关于对依赖于状态的偏置权重的修改：如果从任何状态的提议使用依赖于状态的偏置权重 $w_{ik}$ 而不是均匀选择，则具体的提议概率 $g(i \\to j)$ 和 $g(j \\to i)$ 将根据这些权重计算。因此，接受公式中简单的计数比率 $\\frac{K_i - 1}{K_j - 1}$ 将被更普适的提议概率比率 $\\frac{g(j \\to i)}{g(i \\to j)}$ 所取代。",
            "answer": "$$\\boxed{0.1944}$$"
        },
        {
            "introduction": "前面的练习集中于算法的单个步骤，而这项综合性实践则要求你构建一个完整的蒙特卡洛模拟流程。你将从零开始，通过 Z-matrix 构建一个肽链的初始结构，实现一个保持键合几何的协同主链运动（concerted backbone move），并执行一个完整的 MC 模拟来探索其构象空间。最后，你将通过计算螺旋有序参数来分析模拟结果，从而将算法实现与具体的科学问题——二级结构的稳定性——联系起来。",
            "id": "3840266",
            "problem": "您的任务是为粗粒化多肽实现协同主链运动，并使用蒙特卡洛构象搜索评估其对局部二级结构稳定性的影响。该模型由一系列α-碳原子（表示为 $C_\\alpha$）链组成，具有固定的键长和键角。所有旋转都以刚体变换的形式执行，以保持窗口内的键合几何构型。二级结构稳定性的评估通过一个基于距离的螺旋有序度指标来量化。\n\n基本原理和定义：\n- 链由 $N$ 个主链位点（α-碳原子 $C_\\alpha$）线性连接而成，具有固定的键长 $b$ 和固定的键角 $\\theta_0$。链的内坐标由 Z-矩阵规范给出，使用以埃（Å）为单位的键长 $b$、以弧度为单位的键角 $\\theta_0$ 以及对于 $i \\in \\{2,3,\\dots,N-1\\}$ 以弧度为单位的二面角 $\\tau_i$。初始二面角被设置为一个恒定的螺旋值 $\\tau^\\mathrm{helix}$。\n- 定义了一个局部二级结构能量函数 $E_\\mathrm{sec}$，其为特定 $C_\\alpha$ 原子对的距离与其目标α-螺旋值偏差的平方和，这些原子对是沿序列相隔 $k = 3$ 和 $k = 4$ 的原子。对于给定的链构象，令 $d_{i,i+k}$ 表示位置 $i$ 和 $i+k$ 的 $C_\\alpha$ 原子之间的欧几里得距离。能量为\n$$\nE_\\mathrm{sec} = \\sum_{i=1}^{N-4} \\left( w_3 \\left(d_{i,i+3} - d_3^\\ast\\right)^2 + w_4 \\left(d_{i,i+4} - d_4^\\ast\\right)^2 \\right),\n$$\n其中 $d_3^\\ast$ 和 $d_4^\\ast$ 是目标距离（单位为 Å），$w_3$ 和 $w_4$ 是正常数权重（无单位）。\n- 蒙特卡洛接受准则使用源自玻尔兹曼分布的 Metropolis 准则。在约化单位中，玻尔兹曼常数设为 $k_\\mathrm{B} = 1$，在温度 $T$ 下，对于一个提出的能量变化 $\\Delta E$ 的接受概率为\n$$\np_\\mathrm{acc} = \\min\\left(1, \\exp\\left(-\\frac{\\Delta E}{T}\\right)\\right),\n$$\n特殊情况是，当 $T = 0$ 时，该规则简化为确定性地接受能量下降的移动（$\\Delta E \\le 0$）并拒绝其他移动。\n\n几何和算法约束：\n- 连续 $C_\\alpha$ 原子之间的键长固定为 $b = 3.8$ Å。\n- 每个内部 $C_\\alpha$ 的键角固定为 $\\theta_0 = 1.57$ 弧度。\n- 初始二面角是统一的，并设置为 $\\tau^\\mathrm{helix} = 1.00$ 弧度。\n- 协同主链运动定义为一种窗口内的刚体旋转，如下所述。选取一个连续的索引窗口 $[s, t]$，窗口大小为 $w = t - s + 1$。将旋转轴定义为穿过窗口端点的直线，即通过 $C_\\alpha(s)$ 和 $C_\\alpha(t)$ 的轴。对严格位于窗口内部的所有 $C_\\alpha$ 原子（即索引为 $s+1, s+2, \\dots, t-1$ 的原子）围绕此轴应用一个角度为 $\\Delta$（以弧度为单位）的刚体旋转。端点 $C_\\alpha(s)$ 和 $C_\\alpha(t)$ 保持固定。由于这是刚体旋转，所有窗口内的距离和键角都得以保留，并且根据构造，到窗口端点的边界键长也得以保留。\n- 对旋转角 $\\Delta$ 使用均匀提议分布 $\\Delta \\sim \\mathcal{U}(-\\Delta_\\max, \\Delta_\\max)$。\n- 在指定数量的蒙特卡洛步数后，计算螺旋有序度分数 $H$，其定义为索引 $i \\in \\{1,2,\\dots,N-4\\}$ 中同时满足 $|d_{i,i+3} - d_3^\\ast| \\le \\delta_3$ 和 $|d_{i,i+4} - d_4^\\ast| \\le \\delta_4$ 的比例，其中 $\\delta_3$ 和 $\\delta_4$ 是正常数容差（单位为 Å）。\n\n角度单位和物理单位：\n- 所有角度（键角 $\\theta_0$、二面角 $\\tau_i$ 和旋转角 $\\Delta$）必须以弧度处理。\n- 所有距离必须以埃（Å）为单位。\n- 能量采用任意约化单位，与 $k_\\mathrm{B} = 1$ 保持一致。\n\n程序要求：\n- 使用三维空间中的 Z-矩阵放置递归，根据内坐标 $b$、$\\theta_0$ 和 $\\tau^\\mathrm{helix}$ 构建初始 $C_\\alpha$ 坐标。\n- 使用 Rodrigues 旋转公式，将窗口协同旋转运动实现为围绕由窗口端点定义的轴的刚体旋转。\n- 实现带有指定接受规则的 Metropolis 蒙特卡洛（MMC）方法，通过重复提议窗口旋转来探索构象。\n- 在指定的蒙特卡洛步数后，计算最终的螺旋分数 $H$。\n- 对能量函数使用以下固定参数：$d_3^\\ast = 5.2$ Å, $d_4^\\ast = 6.0$ Å, $w_3 = 1.0$, $w_4 = 1.0$, $\\delta_3 = 0.6$ Å, 以及 $\\delta_4 = 0.6$ Å。\n\n测试套件：\n实现程序以运行以下四个测试用例。每个测试用例指定链长 $N$、蒙特卡洛步数 $M$、温度 $T$、最大旋转幅度 $\\Delta_\\max$、窗口大小 $w$ 以及用于可复现性的随机种子 $s$。\n1. 用例 A（正常路径）：$N = 15$, $M = 2000$, $T = 0.35$, $\\Delta_\\max = 0.60$, $w = 6$, $s = 3$。\n2. 用例 B（大角度高温）：$N = 15$, $M = 2000$, $T = 1.50$, $\\Delta_\\max = 2.50$, $w = 6$, $s = 3$。\n3. 用例 C（最小窗口大小）：$N = 15$, $M = 2000$, $T = 0.35$, $\\Delta_\\max = 2.50$, $w = 3$, $s = 42$。\n4. 用例 D（零移动边界）：$N = 15$, $M = 0$, $T = 0.35$, $\\Delta_\\max = 2.50$, $w = 6$, $s = 3$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的螺旋分数，格式为方括号内用逗号分隔的列表（例如，$[h_A,h_B,h_C,h_D]$），其中每个 $h_\\cdot$ 是一个十进制数。不得打印任何其他文本。",
            "solution": "该问题要求为粗粒化多肽链实现蒙特卡洛构象搜索。此任务涉及几个不同的部分：构建初始分子几何结构、定义和计算势能函数、实现特定的构象移动（协同旋转）、运行 Metropolis 蒙特卡洛模拟，最后，使用定义的序参数分析最终构象。\n\n### 1. 使用 Z-矩阵生成初始构象\n\n$N$ 个 α-碳（$C_\\alpha$）原子的初始三维坐标是根据一组内坐标（键长、键角和二面角），使用标准的 Z-矩阵或“参考系自然延伸”（NERF）程序构建的。问题指定了固定的键长 $b = 3.8$ Å，固定的键角 $\\theta_0 = 1.57$ 弧度，以及统一的初始二面角 $\\tau^\\mathrm{helix} = 1.00$ 弧度。\n\n构建过程按顺序进行：\n1.  第一个原子 $\\mathbf{r}_0$（对于一个 $N$ 原子链，使用从 $0$ 到 $N-1$ 的 0-基索引）被放置在原点：\n    $$ \\mathbf{r}_0 = [0, 0, 0] $$\n2.  第二个原子 $\\mathbf{r}_1$ 沿 x 轴放置，与第一个原子相距 $b$：\n    $$ \\mathbf{r}_1 = [b, 0, 0] $$\n3.  第三个原子 $\\mathbf{r}_2$ 放置在 xy 平面上，与 $\\mathbf{r}_1$ 保持键长 $b$，并与原子三元组 $\\mathbf{r}_0-\\mathbf{r}_1-\\mathbf{r}_2$ 形成键角 $\\theta_0$：\n    $$ \\mathbf{r}_2 = [b - b\\cos\\theta_0, b\\sin\\theta_0, 0] $$\n4.  对于每个后续原子 $\\mathbf{r}_i$（其中 $i \\ge 3$），其位置由其三个前驱原子（$\\mathbf{r}_{i-1}, \\mathbf{r}_{i-2}, \\mathbf{r}_{i-3}$）和内坐标确定：到 $\\mathbf{r}_{i-1}$ 的键长 $b$，相对于向量 $\\mathbf{r}_{i-2}-\\mathbf{r}_{i-1}$ 的键角 $\\theta_0$，以及由原子平面 $(\\mathbf{r}_{i-3}, \\mathbf{r}_{i-2}, \\mathbf{r}_{i-1})$ 和原子平面 $(\\mathbf{r}_{i-2}, \\mathbf{r}_{i-1}, \\mathbf{r}_i)$ 定义的二面角 $\\tau_{i-1} = \\tau^\\mathrm{helix}$。使用一个稳健的基于向量的公式来放置 $\\mathbf{r}_i$：\n    令 $\\mathbf{a} = \\mathbf{r}_{i-1} - \\mathbf{r}_{i-2}$ 且 $\\mathbf{b} = \\mathbf{r}_{i-2} - \\mathbf{r}_{i-3}$。由前三个原子定义的平面的法向量为 $\\mathbf{n} = \\mathbf{a} \\times \\mathbf{b}$。在该平面内且与 $\\mathbf{a}$ 正交的向量为 $\\mathbf{p} = (\\mathbf{a} \\times \\mathbf{b}) \\times \\mathbf{a} = \\mathbf{n} \\times \\mathbf{a}$。\n    通过将这些向量归一化，我们可以构建一个标准正交基。$\\mathbf{r}_i$ 的位置则由下式给出：\n    $$ \\mathbf{r}_i = \\mathbf{r}_{i-1} + b\\left(-\\cos\\theta_0 \\frac{\\mathbf{a}}{|\\mathbf{a}|} + \\sin\\theta_0 \\cos\\tau^\\mathrm{helix} \\frac{\\mathbf{p}}{|\\mathbf{p}|} + \\sin\\theta_0 \\sin\\tau^\\mathrm{helix} \\frac{\\mathbf{n}}{|\\mathbf{n}|} \\right) $$\n\n### 2. 二级结构能量函数\n\n局部二级结构的稳定性由势能函数 $E_\\mathrm{sec}$ 量化。此函数惩罚特定原子间距离与其理想 α-螺旋值的偏差。我们关注的距离是原子 $i$ 与原子 $i+3$ 和 $i+4$ 之间的距离。该函数为：\n$$ E_\\mathrm{sec} = \\sum_{i=0}^{N-5} \\left( w_3 \\left(d_{i,i+3} - d_3^\\ast\\right)^2 + w_4 \\left(d_{i,i+4} - d_4^\\ast\\right)^2 \\right) $$\n此处，$d_{i, j} = \\|\\mathbf{r}_j - \\mathbf{r}_i\\|$ 是原子 $i$ 和 $j$ 之间的欧几里得距离。提供的参数为：$w_3 = w_4 = 1.0$, $d_3^\\ast = 5.2$ Å, and $d_4^\\ast = 6.0$ Å。求和是针对从 $0$ 到 $N-5$ 的 0-基索引，这等同于 1-基索引中的 $1$ 到 $N-4$。\n\n### 3. 协同主链旋转运动\n\n构象变化通过在多肽链的选定窗口内进行协同旋转运动来引入。这种移动旨在保持旋转片段内固定的键长和键角。\n单次移动的步骤如下：\n1.  选择一个大小为 $w$ 的连续原子窗口。从范围 $\\{0, 1, \\dots, N-w\\}$ 中均匀选择一个随机起始索引 $s$，从而定义索引窗口 $[s, s+w-1]$。\n2.  旋转轴 $\\mathbf{k}$ 定义为连接窗口端点 $\\mathbf{r}_s$ 和 $\\mathbf{r}_{s+w-1}$ 的直线上的单位向量：\n    $$ \\mathbf{k} = \\frac{\\mathbf{r}_{s+w-1} - \\mathbf{r}_s}{\\|\\mathbf{r}_{s+w-1} - \\mathbf{r}_s\\|} $$\n3.  从均匀分布 $\\mathcal{U}(-\\Delta_\\max, \\Delta_\\max)$ 中抽取一个随机旋转角 $\\Delta$。\n4.  所有严格位于窗口内的原子，即索引为 $j \\in \\{s+1, \\dots, s+w-2\\}$ 的原子，都围绕该轴进行刚性旋转。旋转使用 Rodrigues 旋转公式执行。对于每个要旋转的点 $\\mathbf{p}_j$，我们首先定义其相对于轴上一点的位置，例如 $\\mathbf{v} = \\mathbf{p}_j - \\mathbf{r}_s$。旋转后的向量 $\\mathbf{v}'$ 为：\n    $$ \\mathbf{v}' = \\mathbf{v}\\cos\\Delta + (\\mathbf{k} \\times \\mathbf{v})\\sin\\Delta + \\mathbf{k}(\\mathbf{k} \\cdot \\mathbf{v})(1-\\cos\\Delta) $$\n    那么原子的新位置是 $\\mathbf{p}_j' = \\mathbf{r}_s + \\mathbf{v}'$。\n\n### 4. Metropolis 蒙特卡洛模拟\n\n该模拟通过迭代地提议移动并根据 Metropolis 准则接受或拒绝它们来探索构象空间，这确保了系统根据玻尔兹曼分布对构象进行抽样。\n模拟进行 $M$ 步：\n1.  从初始构象 $\\mathbf{X}_0$ 及其能量 $E_0 = E_\\mathrm{sec}(\\mathbf{X}_0)$ 开始。\n2.  对于步骤 $k = 1, \\dots, M$：\n    a. 通过对当前构象 $\\mathbf{X}_\\text{current}$ 应用一次协同旋转移动，提议一个新的构象 $\\mathbf{X}_\\text{new}$。\n    b. 计算新构象的能量 $E_\\text{new} = E_\\mathrm{sec}(\\mathbf{X}_\\text{new})$。\n    c. 能量变化为 $\\Delta E = E_\\text{new} - E_\\text{current}$。\n    d. 该移动以概率 $p_\\mathrm{acc} = \\min\\left(1, \\exp\\left(-\\frac{\\Delta E}{T}\\right)\\right)$ 被接受，其中 $T$ 是温度，玻尔兹曼常数 $k_\\mathrm{B}$ 设为 $1$。为了实现这一点，生成一个均匀随机数 $u \\in [0, 1)$。如果 $u  p_\\mathrm{acc}$，则接受新构象（$\\mathbf{X}_\\text{current} \\leftarrow \\mathbf{X}_\\text{new}$，$E_\\text{current} \\leftarrow E_\\text{new}$）。否则，拒绝该移动，构象在下一步中保持不变。\n\n通过使用指定的种子 $s$ 为伪随机数生成器设定种子，确保每个测试用例的可复现性。这控制了窗口选择和旋转角度的序列。\n\n### 5. 螺旋有序度分数\n\n完成 $M$ 个蒙特卡洛步骤后，分析最终构象以量化其螺旋特征。螺旋有序度分数 $H$ 是满足 α-螺旋几何标准的片段所占的比例。如果距离 $d_{i,i+3}$ 和 $d_{i,i+4}$ 接近其理想值，则索引 $i$（从 $0$ 到 $N-5$）被认为是“螺旋的”：\n$$ |d_{i,i+3} - d_3^\\ast| \\le \\delta_3 \\quad \\text{and} \\quad |d_{i,i+4} - d_4^\\ast| \\le \\delta_4 $$\n容差给定为 $\\delta_3 = \\delta_4 = 0.6$ Å。\n总分数计算如下：\n$$ H = \\frac{\\text{Number of helical indices}}{\\text{Total number of possible indices}} = \\frac{1}{N-4} \\sum_{i=0}^{N-5} \\mathbb{I}(\\text{condition for } i \\text{ is met}) $$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。$M=0$ 步的测试用例实际上是计算初始理想螺旋构象的 $H$ 值。",
            "answer": "```python\nimport numpy as np\n\ndef build_initial_coords(N, b, theta_0, tau_helix):\n    \"\"\"\n    Builds the initial C_alpha coordinates from a Z-matrix specification.\n    Indices are 0-based.\n    \"\"\"\n    coords = np.zeros((N, 3))\n    \n    if N > 0:\n        coords[0] = np.array([0.0, 0.0, 0.0])\n    if N > 1:\n        coords[1] = np.array([b, 0.0, 0.0])\n    if N > 2:\n        # Place atom 2 (0-indexed) based on atoms 1 and 0.\n        # Bond angle at atom 1 (index 1) is theta_0 between vector 1->0 and 1->2.\n        # Vector 1->0 is [-b, 0, 0]. Vector 1->2 should have length b.\n        # v_1_0 dot v_1_2 = |v_1_0| |v_1_2| cos(theta_0)\n        # Place in xy-plane:\n        x2 = b - b * np.cos(theta_0)\n        y2 = b * np.sin(theta_0)\n        coords[2] = np.array([x2, y2, 0.0])\n\n    if N > 3:\n        for i in range(3, N):\n            r_im1, r_im2, r_im3 = coords[i-1], coords[i-2], coords[i-3]\n            \n            a_vec = r_im1 - r_im2\n            b_vec = r_im2 - r_im3\n\n            # Check for collinearity\n            a_norm = np.linalg.norm(a_vec)\n            if a_norm  1e-9: continue\n            \n            a_hat = a_vec / a_norm\n            \n            n_vec = np.cross(a_vec, b_vec)\n            n_norm = np.linalg.norm(n_vec)\n            \n            if n_norm  1e-9: # Handle case when a, b are collinear\n                # Create arbitrary normal\n                dummy = np.array([0.0,0.0,1.0]) if np.abs(a_hat[2])  0.9 else np.array([1.0,0.0,0.0])\n                n_vec = np.cross(a_hat, dummy)\n                n_norm = np.linalg.norm(n_vec)\n\n            n_hat = n_vec / n_norm\n            \n            p_vec = np.cross(n_hat, a_hat)\n            \n            # Using the formula derived from vector geometry\n            # r_i = r_{i-1} + b * ( -cos(theta_0)*a_hat + sin(theta_0)*cos(tau)*p_hat + sin(theta_0)*sin(tau)*n_hat)\n            # p_hat is already normalized as it's cross product of two unit vectors\n            \n            disp = -np.cos(theta_0) * a_hat + \\\n                    np.sin(theta_0) * np.cos(tau_helix) * p_vec + \\\n                    np.sin(theta_0) * np.sin(tau_helix) * n_hat\n            coords[i] = r_im1 + b * disp\n            \n    return coords\n\ndef calculate_energy(coords, d3_star, d4_star, w3, w4):\n    \"\"\"Calculates the secondary structure energy E_sec.\"\"\"\n    N = len(coords)\n    energy = 0.0\n    if N  5:\n        return 0.0\n        \n    for i in range(N - 4):\n        d_i_i3 = np.linalg.norm(coords[i+3] - coords[i])\n        d_i_i4 = np.linalg.norm(coords[i+4] - coords[i])\n        energy += w3 * (d_i_i3 - d3_star)**2 + w4 * (d_i_i4 - d4_star)**2\n    return energy\n\ndef apply_concerted_rotation(coords, s, t, delta):\n    \"\"\"Applies a concerted rotation to a window of the chain.\"\"\"\n    new_coords = np.copy(coords)\n    \n    r_s = coords[s]\n    r_t = coords[t]\n    \n    axis_vec = r_t - r_s\n    axis_norm = np.linalg.norm(axis_vec)\n    if axis_norm  1e-9:\n        return new_coords # No rotation if endpoints are coincident\n    \n    k = axis_vec / axis_norm\n    \n    cos_d = np.cos(delta)\n    sin_d = np.sin(delta)\n    \n    # Rodrigues' rotation formula\n    for j in range(s + 1, t):\n        p_j = coords[j]\n        v = p_j - r_s\n        \n        v_rot = v * cos_d + np.cross(k, v) * sin_d + k * np.dot(k, v) * (1 - cos_d)\n        \n        new_coords[j] = r_s + v_rot\n        \n    return new_coords\n\ndef calculate_helical_fraction(coords, d3_star, d4_star, delta3, delta4):\n    \"\"\"Calculates the final helical order fraction H.\"\"\"\n    N = len(coords)\n    if N  5:\n        return 0.0\n    \n    helical_count = 0\n    num_segments = N - 4\n    for i in range(num_segments):\n        d_i_i3 = np.linalg.norm(coords[i+3] - coords[i])\n        d_i_i4 = np.linalg.norm(coords[i+4] - coords[i])\n        \n        if abs(d_i_i3 - d3_star) = delta3 and abs(d_i_i4 - d4_star) = delta4:\n            helical_count += 1\n            \n    return helical_count / num_segments\n\ndef run_simulation(N, M, T, delta_max, w, seed):\n    \"\"\"Runs a full Monte Carlo simulation for one test case.\"\"\"\n    np.random.seed(seed)\n    \n    # Fixed parameters\n    b = 3.8\n    theta_0 = 1.57\n    tau_helix = 1.00\n    d3_star, d4_star = 5.2, 6.0\n    w3, w4 = 1.0, 1.0\n    delta3, delta4 = 0.6, 0.6\n    \n    # 1. Initial conformation\n    current_coords = build_initial_coords(N, b, theta_0, tau_helix)\n    \n    # Handle M=0 case\n    if M == 0:\n        return calculate_helical_fraction(current_coords, d3_star, d4_star, delta3, delta4)\n\n    # 2. Initial energy\n    current_energy = calculate_energy(current_coords, d3_star, d4_star, w3, w4)\n\n    # 3. MC loop\n    for _ in range(M):\n        # Propose a move\n        s = np.random.randint(0, N - w + 1)\n        t = s + w - 1\n        delta = np.random.uniform(-delta_max, delta_max)\n        \n        new_coords = apply_concerted_rotation(current_coords, s, t, delta)\n        new_energy = calculate_energy(new_coords, d3_star, d4_star, w3, w4)\n        \n        # Metropolis criterion\n        delta_E = new_energy - current_energy\n        if delta_E = 0:\n            current_coords = new_coords\n            current_energy = new_energy\n        else:\n            if T > 0:\n                prob_acc = np.exp(-delta_E / T)\n                if np.random.rand()  prob_acc:\n                    current_coords = new_coords\n                    current_energy = new_energy\n\n    # 4. Final analysis\n    final_h_fraction = calculate_helical_fraction(current_coords, d3_star, d4_star, delta3, delta4)\n    return final_h_fraction\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and format the output.\n    \"\"\"\n    test_cases = [\n        # (N, M, T, delta_max, w, seed)\n        (15, 2000, 0.35, 0.60, 6, 3),   # Case A\n        (15, 2000, 1.50, 2.50, 6, 3),   # Case B\n        (15, 2000, 0.35, 2.50, 3, 42),  # Case C\n        (15, 0, 0.35, 2.50, 6, 3),      # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, T, delta_max, w, seed = case\n        result = run_simulation(N, M, T, delta_max, w, seed)\n        results.append(result)\n\n    # Format output to match problem specification\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}