{
    "hands_on_practices": [
        {
            "introduction": "在数值求解不可压缩流时，压力与速度的耦合是一个核心挑战。在并置网格（collocated grid）上，简单的离散格式可能无法“感知”到某些非物理的压力振荡模式，例如棋盘格压力场，从而导致计算失稳。本练习通过一个具体的例子，直观地展示了MAC交错网格如何通过其独特的变量布局，自然地避免了这种压力-速度解耦问题，从而保证了求解的稳定性和准确性 。",
            "id": "4100591",
            "problem": "考虑一个通过投影法推进的不可压缩流，其中压力梯度在速度更新中强制执行无散度约束。压力仅通过其离散梯度出现。在同位网格有限差分格式中，压力 $p$ 和速度 $\\boldsymbol{u}$ 存储在单元中心，而在标记网格法（Marker-And-Cell, MAC）格式中，压力 $p$ 存储在单元中心，速度分量存储在单元面上。\n\n在一个二维、方形、周期性域上进行计算，该域由间距为 $h$ 的均匀笛卡尔网格离散化，单元中心使用整数索引 $(i,j)$。假设使用无量纲变量，因此 $p$ 是无量纲的。定义以下离散算子：\n\n1. 在同位网格格式中，单元中心 $(i,j)$ 处压力梯度的离散 $x$ 分量由中心差分近似：\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\mathrm{coll}} \\equiv \\frac{p_{i+1,j} - p_{i-1,j}}{2h}.\n$$\n\n2. 在 MAC 格式中，与垂直面 $(i+\\tfrac{1}{2},j)$ 上的 $u$ 速度同位的压力梯度 $x$ 分量由单边差分近似：\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i+\\frac{1}{2},j}^{\\mathrm{MAC}} \\equiv \\frac{p_{i+1,j} - p_{i,j}}{h}.\n$$\n\n考虑以下棋盘格压力模式：\n$$\np_{i,j} = (-1)^{i+j}, \\quad \\text{对于所有整数 } i,j,\n$$\n该模式施加于一个具有周期性边界条件的网格上。使用上述算子，计算并比较此模式产生的离散压力梯度。然后，具体确定单元 $(0,0)$ 和 $(1,0)$ 之间的面，即 $(i+\\tfrac{1}{2},j) = (\\tfrac{1}{2},0)$ 处的 MAC 离散压力梯度 $x$ 分量。\n\n请用仅含 $h$ 的单个闭式解析表达式表示您的最终答案。无需四舍五入。如果出现任何中间物理单位，假设已进行无量纲化，以使最终表达式无单位。",
            "solution": "该问题陈述被认为是有效的，因为它在计算流体动力学领域具有科学依据，特别涉及不可压缩流有限差分格式的数值分析。这是一个适定问题，提供了所有必要的定义和条件，从而可以得到一个唯一且可验证的解。问题是客观的，并使用了标准的、无歧义的术语。\n\n我们被要求使用两种不同的有限差分近似，一种用于同位网格，另一种用于标记网格法（MAC）交错网格，来计算并比较由特定压力场产生的离散压力梯度。最后，我们必须计算 MAC 格式的一个特定值。\n\n设均匀笛卡尔网格的间距为 $h$。压力场由棋盘格模式给出：\n$$\np_{i,j} = (-1)^{i+j}\n$$\n对于所有整数索引 $i$ 和 $j$。\n\n首先，我们分析同位网格格式的离散压力梯度。在单元中心 $(i,j)$ 处梯度 $x$ 分量的算子定义为：\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\mathrm{coll}} \\equiv \\frac{p_{i+1,j} - p_{i-1,j}}{2h}\n$$\n为计算此式，我们代入给定的压力场。相邻单元中心 $(i+1,j)$ 和 $(i-1,j)$ 的压力为：\n$$\np_{i+1,j} = (-1)^{(i+1)+j} = (-1)^{i+j+1} = -(-1)^{i+j}\n$$\n$$\np_{i-1,j} = (-1)^{i+j-1} = (-1)^{-1} (-1)^{i+j} = -(-1)^{i+j}\n$$\n将这些表达式代入同位网格梯度算子：\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\mathrm{coll}} = \\frac{-(-1)^{i+j} - \\left(-(-1)^{i+j}\\right)}{2h} = \\frac{-(-1)^{i+j} + (-1)^{i+j}}{2h} = \\frac{0}{2h} = 0\n$$\n这个结果对任何单元 $(i,j)$ 都成立。这显示了同位网格上中心差分算子的一个关键弱点：它对最高频率（棋盘格）模式不敏感。一个非零的压力场产生了零压力梯度，这意味着离散投影步骤将无法修正产生这种压力的速度场。这是在投影法中使用交错网格的主要动机。\n\n接下来，我们分析 MAC 格式的离散压力梯度。梯度 $x$ 分量的算子位于垂直单元面 $(i+\\frac{1}{2},j)$ 上，定义为：\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i+\\frac{1}{2},j}^{\\mathrm{MAC}} \\equiv \\frac{p_{i+1,j} - p_{i,j}}{h}\n$$\n我们将棋盘格压力场代入此算子。我们已经有 $p_{i+1,j} = -(-1)^{i+j}$，并且我们知道 $p_{i,j} = (-1)^{i+j}$。\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i+\\frac{1}{2},j}^{\\mathrm{MAC}} = \\frac{-(-1)^{i+j} - (-1)^{i+j}}{h} = \\frac{-2(-1)^{i+j}}{h}\n$$\n与同位网格格式不同，MAC 格式对棋盘格压力场产生了非零的压力梯度。梯度的大小是恒定的，即 $| \\frac{-2}{h} | = \\frac{2}{h}$，但其符号根据 $i+j$ 的奇偶性交替变化。这表明 MAC 网格布置及其相关的有限差分算子可以正确地“看到”并响应高频压力模式，这对于稳定性和准确性是一个显著的优势。\n\n最后，我们被要求确定在面 $(i+\\frac{1}{2},j) = (\\frac{1}{2},0)$ 处 MAC 离散压力梯度 $x$ 分量的特定值。这个位置对应于单元 $(0,0)$ 和单元 $(1,0)$ 之间的面。因此，我们必须对 $i=0$ 和 $j=0$ 计算该通用表达式。\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{\\frac{1}{2},0}^{\\mathrm{MAC}} = \\frac{-2(-1)^{0+0}}{h} = \\frac{-2(-1)^{0}}{h} = \\frac{-2(1)}{h} = -\\frac{2}{h}\n$$\n这是所求的特定值。",
            "answer": "$$\n\\boxed{-\\frac{2}{h}}\n$$"
        },
        {
            "introduction": "理解了MAC网格的优势之后，我们需要掌握在其上构建核心算子的方法。无论是在动量方程的粘性项中，还是在投影法核心的压力泊松方程中，拉普拉斯算子都扮演着关键角色。本练习将引导你手动推导在交错网格上面心速度的离散拉普拉斯算子（即五点模板系数），这是实现任何基于有限差分的流体求解器的基本功 。",
            "id": "4100667",
            "problem": "考虑在具有均匀网格间距 $\\Delta x$ 和 $\\Delta y$ 的二维矩形域上，在 Marker-and-Cell (MAC) 网格上离散化的不可压缩 Navier–Stokes 方程。水平速度分量 $u$ 存储在垂直单元面的中心，其位置为 $(x_{i+1/2}, y_{j}) = \\left((i+\\tfrac{1}{2})\\Delta x, j \\Delta y\\right)$。作用于 $(i+\\tfrac{1}{2}, j)$ 处 $u$ 的面心拉普拉斯算子由在该面位置求值的连续算子 $\\nabla^{2} u = \\frac{\\partial^{2} u}{\\partial x^{2}} + \\frac{\\partial^{2} u}{\\partial y^{2}}$ 定义，并将使用与面心布置一致的二阶中心差分进行近似。\n\n从二阶导数的定义和关于 $(x_{i+1/2}, y_{j})$ 的泰勒展开出发，推导使用相邻面心值 $u_{i+3/2, j}$、$u_{i+1/2, j}$、$u_{i-1/2, j}$、$u_{i+1/2, j+1}$ 和 $u_{i+1/2, j-1}$ 近似 $(i+\\tfrac{1}{2}, j)$ 处 $\\nabla^{2} u$ 的五点离散模板及其系数。将离散算子表示为以下形式\n$$\n\\left(\\nabla^{2} u\\right)_{i+1/2, j} \\approx a_{0}\\,u_{i+1/2, j} + a_{\\mathrm{E}}\\,u_{i+3/2, j} + a_{\\mathrm{W}}\\,u_{i-1/2, j} + a_{\\mathrm{N}}\\,u_{i+1/2, j+1} + a_{\\mathrm{S}}\\,u_{i+1/2, j-1},\n$$\n并用 $\\Delta x$ 和 $\\Delta y$ 表示系数 $a_{0}$、$a_{\\mathrm{E}}$、$a_{\\mathrm{W}}$、$a_{\\mathrm{N}}$ 和 $a_{\\mathrm{S}}$。\n\n答案格式：以单个 $1\\times 5$ 行矩阵的形式返回有序的系数行向量 $[a_{0}, a_{\\mathrm{E}}, a_{\\mathrm{W}}, a_{\\mathrm{N}}, a_{\\mathrm{S}}]$。最终答案必须是精确的符号表达式。最终答案中请勿包含单位。",
            "solution": "用户希望在交错的 Marker-and-Cell (MAC) 网格上找到拉普拉斯算子 $\\nabla^{2} u$ 的五点模板。水平速度分量 $u$ 位于垂直单元面的中心，索引为 $(i+\\frac{1}{2}, j)$。任务是使用二阶中心差分推导其离散近似。\n\n二维拉普拉斯算子定义为：\n$$\n\\nabla^{2} u = \\frac{\\partial^{2} u}{\\partial x^{2}} + \\frac{\\partial^{2} u}{\\partial y^{2}}\n$$\n我们需要找到该算子在点 $(x_{i+1/2}, y_{j})$ 处的离散近似。我们将使用中心差分分别近似每个二阶导数项，然后将它们相加。该近似必须使用指定的相邻面心速度值：$u_{i+3/2, j}$、$u_{i-1/2, j}$、$u_{i+1/2, j+1}$ 和 $u_{i+1/2, j-1}$。\n\n首先，我们来近似在 $(x_{i+1/2}, y_{j})$ 处的项 $\\frac{\\partial^{2} u}{\\partial x^{2}}$。我们对x方向上的相邻点 $u_{i+3/2, j} = u(x_{i+1/2}+\\Delta x, y_j)$ 和 $u_{i-1/2, j} = u(x_{i+1/2}-\\Delta x, y_j)$，围绕中心点 $(x_{i+1/2}, y_j)$ 进行泰勒级数展开。设 $u_{i+1/2,j}$ 表示 $u(x_{i+1/2}, y_j)$。\n\n向前泰勒展开为：\n$$\nu_{i+3/2, j} = u_{i+1/2, j} + \\Delta x \\left(\\frac{\\partial u}{\\partial x}\\right)_{i+1/2, j} + \\frac{(\\Delta x)^{2}}{2!} \\left(\\frac{\\partial^{2} u}{\\partial x^{2}}\\right)_{i+1/2, j} + \\frac{(\\Delta x)^{3}}{3!} \\left(\\frac{\\partial^{3} u}{\\partial x^{3}}\\right)_{i+1/2, j} + O((\\Delta x)^{4})\n$$\n向后泰勒展开为：\n$$\nu_{i-1/2, j} = u_{i+1/2, j} - \\Delta x \\left(\\frac{\\partial u}{\\partial x}\\right)_{i+1/2, j} + \\frac{(\\Delta x)^{2}}{2!} \\left(\\frac{\\partial^{2} u}{\\partial x^{2}}\\right)_{i+1/2, j} - \\frac{(\\Delta x)^{3}}{3!} \\left(\\frac{\\partial^{3} u}{\\partial x^{3}}\\right)_{i+1/2, j} + O((\\Delta x)^{4})\n$$\n将这两个展开式相加，奇数阶导数项会相互抵消：\n$$\nu_{i+3/2, j} + u_{i-1/2, j} = 2 u_{i+1/2, j} + (\\Delta x)^{2} \\left(\\frac{\\partial^{2} u}{\\partial x^{2}}\\right)_{i+1/2, j} + O((\\Delta x)^{4})\n$$\n现在，我们可以解出二阶导数 $\\frac{\\partial^{2} u}{\\partial x^{2}}$：\n$$\n\\left(\\frac{\\partial^{2} u}{\\partial x^{2}}\\right)_{i+1/2, j} = \\frac{u_{i-1/2, j} - 2 u_{i+1/2, j} + u_{i+3/2, j}}{(\\Delta x)^{2}} + O((\\Delta x)^{2})\n$$\n这是关于 $x$ 的二阶偏导数的二阶中心差分近似。\n\n接下来，我们在同一点 $(x_{i+1/2}, y_{j})$ 近似项 $\\frac{\\partial^{2} u}{\\partial y^{2}}$。y方向上的相邻点是 $u_{i+1/2, j+1} = u(x_{i+1/2}, y_j+\\Delta y)$ 和 $u_{i+1/2, j-1} = u(x_{i+1/2}, y_j-\\Delta y)$。我们对 y 变量进行泰勒级数展开：\n$$\nu_{i+1/2, j+1} = u_{i+1/2, j} + \\Delta y \\left(\\frac{\\partial u}{\\partial y}\\right)_{i+1/2, j} + \\frac{(\\Delta y)^{2}}{2!} \\left(\\frac{\\partial^{2} u}{\\partial y^{2}}\\right)_{i+1/2, j} + O((\\Delta y)^{3})\n$$\n$$\nu_{i+1/2, j-1} = u_{i+1/2, j} - \\Delta y \\left(\\frac{\\partial u}{\\partial y}\\right)_{i+1/2, j} + \\frac{(\\Delta y)^{2}}{2!} \\left(\\frac{\\partial^{2} u}{\\partial y^{2}}\\right)_{i+1/2, j} - O((\\Delta y)^{3})\n$$\n将这两个展开式相加得到：\n$$\nu_{i+1/2, j+1} + u_{i+1/2, j-1} = 2 u_{i+1/2, j} + (\\Delta y)^{2} \\left(\\frac{\\partial^{2} u}{\\partial y^{2}}\\right)_{i+1/2, j} + O((\\Delta y)^{4})\n$$\n解出二阶导数 $\\frac{\\partial^{2} u}{\\partial y^{2}}$：\n$$\n\\left(\\frac{\\partial^{2} u}{\\partial y^{2}}\\right)_{i+1/2, j} = \\frac{u_{i+1/2, j-1} - 2 u_{i+1/2, j} + u_{i+1/2, j+1}}{(\\Delta y)^{2}} + O((\\Delta y)^{2})\n$$\n这是关于 $y$ 的二阶偏导数的二阶中心差分近似。\n\n现在，我们结合这两个近似来构成离散拉普拉斯算子：\n$$\n\\left(\\nabla^{2} u\\right)_{i+1/2, j} \\approx \\frac{u_{i-1/2, j} - 2 u_{i+1/2, j} + u_{i+3/2, j}}{(\\Delta x)^{2}} + \\frac{u_{i+1/2, j-1} - 2 u_{i+1/2, j} + u_{i+1/2, j+1}}{(\\Delta y)^{2}}\n$$\n为了匹配所需的形式，我们按相应的速度分量对各项进行分组：\n$$\n\\left(\\nabla^{2} u\\right)_{i+1/2, j} \\approx \\left(-\\frac{2}{(\\Delta x)^{2}} - \\frac{2}{(\\Delta y)^{2}}\\right) u_{i+1/2, j} + \\frac{1}{(\\Delta x)^{2}} u_{i+3/2, j} + \\frac{1}{(\\Delta x)^{2}} u_{i-1/2, j} + \\frac{1}{(\\Delta y)^{2}} u_{i+1/2, j+1} + \\frac{1}{(\\Delta y)^{2}} u_{i+1/2, j-1}\n$$\n将此表达式与问题陈述中要求的形式进行比较：\n$$\n\\left(\\nabla^{2} u\\right)_{i+1/2, j} \\approx a_{0}\\,u_{i+1/2, j} + a_{\\mathrm{E}}\\,u_{i+3/2, j} + a_{\\mathrm{W}}\\,u_{i-1/2, j} + a_{\\mathrm{N}}\\,u_{i+1/2, j+1} + a_{\\mathrm{S}}\\,u_{i+1/2, j-1}\n$$\n我们可以确定系数：\n- 中心节点 $u_{i+1/2, j}$ 的系数是 $a_{0} = -\\frac{2}{(\\Delta x)^{2}} - \\frac{2}{(\\Delta y)^{2}} = -2\\left(\\frac{1}{(\\Delta x)^{2}} + \\frac{1}{(\\Delta y)^{2}}\\right)$。\n- 东侧节点 $u_{i+3/2, j}$ 的系数是 $a_{\\mathrm{E}} = \\frac{1}{(\\Delta x)^{2}}$。\n- 西侧节点 $u_{i-1/2, j}$ 的系数是 $a_{\\mathrm{W}} = \\frac{1}{(\\Delta x)^{2}}$。\n- 北侧节点 $u_{i+1/2, j+1}$ 的系数是 $a_{\\mathrm{N}} = \\frac{1}{(\\Delta y)^{2}}$。\n- 南侧节点 $u_{i+1/2, j-1}$ 的系数是 $a_{\\mathrm{S}} = \\frac{1}{(\\Delta y)^{2}}$。\n\n因此，有序的系数向量 $[a_{0}, a_{\\mathrm{E}}, a_{\\mathrm{W}}, a_{\\mathrm{N}}, a_{\\mathrm{S}}]$ 是：\n$$\n\\left[ -2\\left(\\frac{1}{(\\Delta x)^{2}} + \\frac{1}{(\\Delta y)^{2}}\\right), \\frac{1}{(\\Delta x)^{2}}, \\frac{1}{(\\Delta x)^{2}}, \\frac{1}{(\\Delta y)^{2}}, \\frac{1}{(\\Delta y)^{2}} \\right]\n$$\n这表示在交错网格上，针对 $u$ 速度分量的拉普拉斯算子的五点模板。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -2\\left(\\frac{1}{(\\Delta x)^{2}} + \\frac{1}{(\\Delta y)^{2}}\\right) & \\frac{1}{(\\Delta x)^{2}} & \\frac{1}{(\\Delta x)^{2}} & \\frac{1}{(\\Delta y)^{2}} & \\frac{1}{(\\Delta y)^{2}} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "掌握了概念基础和离散化工具后，最后的实践将所有知识点融会贯通。本练习要求你编写程序，实现一个完整的投影法步骤：计算一个临时速度场的散度，求解压力泊松方程，并最终校正速度场以满足不可压缩条件。通过这个编码实践，你将亲眼见证MAC格式与投影法如何协同工作，生成一个物理上合理的无散流场 。",
            "id": "4100607",
            "problem": "考虑一个在Marker-and-Cell (MAC)网格上通过投影法推进的二维不可压缩流，其中速度分量存储在单元面心，而压力（或压力增量势）存储在单元中心。从不可压缩牛顿流体的基本质量守恒（即 $ \\nabla \\cdot \\mathbf{u} = 0 $）和Helmholtz分解思想（即任何足够光滑的矢量场都可以分解为一个无散度部分和一个梯度场）出发。在一个间距为 $ \\Delta x $ 和 $ \\Delta y $ 的均匀矩形网格上，定义离散算子，使得作用于面心速度的离散散度产生一个体心标量，而作用于体心标量的离散梯度产生面心分量。假设两个方向上均为周期性边界条件。\n\n仅使用这些核心原理和定义，为一个体心势 $ \\phi $ 推导离散标量泊松问题。当给定一个预测速度 $ \\mathbf{u}^* $ 时，该问题在一个时间增量 $ \\Delta t $ 内对修正后的速度场强制施加离散不可压缩性。单元中心 $ (i,j) $ 处的离散散度必须通过将在 $ (i\\pm \\tfrac{1}{2},j) $ 和 $ (i,j\\pm \\tfrac{1}{2}) $ 处的面法向差分与周期性环绕相结合来计算。速度修正中使用的离散梯度必须是相邻体心势的面法向差分。所有量均以无量纲形式表示。\n\n实现一个程序，该程序：\n- 在一个具有间距 $ \\Delta x $ 和 $ \\Delta y $ 的 $ N_x \\times N_y $ 周期性网格（单元中心）上，构建面心预测速度 $ u^* $ 和 $ v^* $。\n- 构建与 $ \\mathbf{u}^* $ 的离散散度成正比并由 $ \\Delta t $ 缩放的体心右端项。\n- 使用与标准 $ 5 $ 点周期性拉普拉斯模板一致的谱方法，求解 $ \\phi $ 的离散周期性泊松方程。\n- 应用与推导出的离散算子一致的速度修正，使得修正后的速度 $ \\mathbf{u}^{n+1} $ 在机器精度允许的范围内尽可能接近离散无散度。\n- 对指定的测试用例，计算修正后速度场的离散散度的最大绝对值，或在适当时计算散度的比率。\n\n在 $ N_x \\times N_y $ 的体心网格上使用以下精确的离散定义，并采用周期性索引。所有用于面心速度 $ u $ 和 $ v $ 的数组形状均为 $ (N_x, N_y) $，其中 $ u $ 值位于位置 $ (i+\\tfrac{1}{2},j) $，$ v $ 值位于位置 $ (i,j+\\tfrac{1}{2}) $，且 $ i \\in \\{0,\\ldots,N_x-1\\} $，$ j \\in \\{0,\\ldots,N_y-1\\} $：\n- 每个单元中心的离散散度：\n$$\n(\\nabla_h \\cdot \\mathbf{u})_{i,j} \\equiv \\frac{u_{i,j} - u_{i-1,j}}{\\Delta x} + \\frac{v_{i,j} - v_{i,j-1}}{\\Delta y},\n$$\n其中索引 $ i-1 $ 和 $ j-1 $ 采用周期性环绕。\n- 根据体心标量 $ \\phi $ 在面上求值的离散梯度分量：\n$$\n(\\partial_x^h \\phi)_{i+\\frac{1}{2},j} \\equiv \\frac{\\phi_{i+1,j} - \\phi_{i,j}}{\\Delta x}, \\quad\n(\\partial_y^h \\phi)_{i,j+\\frac{1}{2}} \\equiv \\frac{\\phi_{i,j+1} - \\phi_{i,j}}{\\Delta y},\n$$\n其中索引 $ i+1 $ 和 $ j+1 $ 采用周期性环绕。\n- 单元中心的周期性离散拉普拉斯算子是标准的 $ 5 $ 点模板，并在两个方向上都采用周期性环绕。\n\n你的实现必须为周期性泊松方程使用一个谱求解器，该求解器在傅里叶空间中对角化离散拉普拉斯算子：对于波数 $ k_x \\in \\{0,\\ldots,N_x-1\\} $ 和 $ k_y \\in \\{0,\\ldots,N_y-1\\} $，离散拉普拉斯算子的特征值为\n$$\n\\lambda(k_x,k_y) = \\frac{2\\left(\\cos\\left(\\frac{2\\pi k_x}{N_x}\\right) - 1\\right)}{\\Delta x^2} + \\frac{2\\left(\\cos\\left(\\frac{2\\pi k_y}{N_y}\\right) - 1\\right)}{\\Delta y^2}.\n$$\n通过将零频模式设置为零来强制执行 $ \\phi $ 的零均值解，这与移除周期性拉普拉斯算子的零空间模式是一致的。如果右端项不是零均值，则在求解前减去其均值。\n\n测试套件。你的程序必须运行以下五个独立的测试用例，并将结果汇总到单个输出中：\n- 测试 $ 1 $ (正常路径): $ N_x = 8 $, $ N_y = 6 $, $ \\Delta x = 1.0 $, $ \\Delta y = 1.0 $, $ \\Delta t = 0.1 $。使用固定种子 $ 1 $ 生成 $ u^* $ 和 $ v^* $ 作为独立的伪随机标准正态场。求解 $ \\phi $，修正速度，并报告修正后场的最大绝对离散散度（浮点数）。\n- 测试 $ 2 $ (使用常数增量的无操作修正): $ N_x = 8 $, $ N_y = 6 $, $ \\Delta x = 1.0 $, $ \\Delta y = 1.0 $, $ \\Delta t = 0.1 $。使用种子 $ 2 $ 生成 $ u^* $ 和 $ v^* $ 作为独立的伪随机标准正态场。将 $ \\phi $ 处处设置为常数 $ 1.234 $，应用修正，并报告修正后与修正前的最大绝对离散散度之比（浮点数）。\n- 测试 $ 3 $ (精确梯度抵消): $ N_x = 16 $, $ N_y = 16 $, $ \\Delta x = 1.0 $, $ \\Delta y = 1.0 $, $ \\Delta t = 0.2 $。定义一个体心势 $ \\phi_{i,j} = \\sin\\!\\left(2\\pi \\frac{2\\, i}{N_x}\\right) + 0.5 \\cos\\!\\left(2\\pi \\frac{3\\, j}{N_y}\\right) $。将 $ u^* $ 和 $ v^* $ 设置为 $ \\Delta t $ 乘以 $ \\phi $ 在面上的相应离散梯度分量。用这个相同的 $ \\phi $ 应用修正，并报告最大绝对离散散度（浮点数）。\n- 测试 $ 4 $ (各向异性网格间距): $ N_x = 10 $, $ N_y = 12 $, $ \\Delta x = 0.5 $, $ \\Delta y = 0.8 $, $ \\Delta t = 0.05 $。使用种子 $ 3 $ 生成 $ u^* $ 和 $ v^* $ 作为独立的伪随机标准正态场。求解 $ \\phi $，进行修正，并报告最大绝对离散散度（浮点数）。\n- 测试 $ 5 $ (零时间步长边界情况): $ N_x = 12 $, $ N_y = 7 $, $ \\Delta x = 1.0 $, $ \\Delta y = 1.0 $, $ \\Delta t = 0.0 $。使用种子 $ 4 $ 生成 $ u^* $ 和 $ v^* $ 作为独立的伪随机标准正态场。不要求解 $ \\phi $；将 $ \\phi $ 设置为零并应用修正。报告修正后与修正前的最大绝对离散散度之比（浮点数）。\n\n角度单位为弧度。所有量均为无量纲。你的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，$ [r_1,r_2,r_3,r_4,r_5] $），其中每个 $ r_k $ 是一个浮点数。为保证可复现性，将每个浮点数格式化为保留小数点后六位的科学记数法。",
            "solution": "该问题要求在一个交错的Marker-and-Cell (MAC)网格上，为不可压缩流的投影法推导类压力势$\\phi$的离散泊松方程。此推导始于不可压缩流体的基本质量守恒原理 $\\nabla \\cdot \\mathbf{u} = 0$ 以及投影法的结构。\n\n投影法通常包含一个两步过程，将速度场从时间 $t^n$ 推进到 $t^{n+1} = t^n + \\Delta t$。首先，通过推进动量方程而不考虑压力梯度，计算出一个中间速度场或预测速度场 $\\mathbf{u}^*$。这个场 $\\mathbf{u}^*$ 通常不满足不可压缩性约束，即 $\\nabla \\cdot \\mathbf{u}^* \\neq 0$。\n\n第二步是投影步，它修正 $\\mathbf{u}^*$ 以产生一个新的速度场 $\\mathbf{u}^{n+1}$，该速度场是离散无散度的。此修正基于Helmholtz分解，该分解指出任何矢量场（此处为 $\\mathbf{u}^*$）都可以分解为一个无散度分量和一个标量势的梯度。投影步有效地从 $\\mathbf{u}^*$ 中减去这个梯度部分。修正公式为：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^* - \\nabla \\psi\n$$\n其中 $\\psi$ 是一个标量势。在Navier-Stokes方程的背景下，这个势与时间积分的压力有关，使得 $\\nabla \\psi$ 与 $\\Delta t \\nabla p$ 成正比。我们定义一个势 $\\phi$，使得更新写为：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^* - \\Delta t \\, \\nabla \\phi\n$$\n核心要求是修正后的速度场 $\\mathbf{u}^{n+1}$ 必须满足不可压缩性约束：\n$$\n\\nabla \\cdot \\mathbf{u}^{n+1} = 0\n$$\n将 $\\mathbf{u}^{n+1}$ 的表达式代入不可压缩条件，得到：\n$$\n\\nabla \\cdot (\\mathbf{u}^* - \\Delta t \\, \\nabla \\phi) = 0\n$$\n假设散度算子是线性的，我们可以将其分配到各项上：\n$$\n\\nabla \\cdot \\mathbf{u}^* - \\Delta t \\, (\\nabla \\cdot \\nabla \\phi) = 0\n$$\n项 $\\nabla \\cdot \\nabla \\phi$ 是拉普拉斯算子 $\\nabla^2 \\phi$ 的定义。这导出了势 $\\phi$ 的连续泊松方程：\n$$\n\\nabla^2 \\phi = \\frac{1}{\\Delta t} \\nabla \\cdot \\mathbf{u}^*\n$$\n这个方程表明，势 $\\phi$ 的拉普拉斯等于预测速度场的散度，并与之成正比。\n\n为了将此方程转换到离散MAC网格上，我们采用所提供的离散算子。该网格的单元中心由 $(i,j)$ 索引，水平速度分量 $u$ 位于面心 $(i+\\tfrac{1}{2},j)$，垂直速度分量 $v$ 位于面心 $(i,j+\\tfrac{1}{2})$。所有索引都是周期性的。\n\n离散散度算子 $\\nabla_h \\cdot$ 将面心速度场映射到体心标量场。在单元 $(i,j)$ 处，它定义为：\n$$\n(\\nabla_h \\cdot \\mathbf{u})_{i,j} = \\frac{u_{i,j} - u_{i-1,j}}{\\Delta x} + \\frac{v_{i,j} - v_{i,j-1}}{\\Delta y}\n$$\n这里，$u_{i,j}$ 表示单元 $(i,j)$ 右侧面（位置 $i+\\tfrac{1}{2},j$）上的速度，$u_{i-1,j}$ 表示单元 $(i,j)$ 左侧面（位置 $i-\\tfrac{1}{2},j$）上的速度。类似的约定适用于垂直速度 $v$。\n\n离散梯度算子 $\\nabla_h$ 将体心标量场 $\\phi$ 映射到面心矢量分量。在面 $(i+\\tfrac{1}{2},j)$ 上的水平分量和在面 $(i,j+\\tfrac{1}{2})$ 上的垂直分量为：\n$$\n(\\partial_x^h \\phi)_{i+\\frac{1}{2},j} = \\frac{\\phi_{i+1,j} - \\phi_{i,j}}{\\Delta x}\n$$\n$$\n(\\partial_y^h \\phi)_{i,j+\\frac{1}{2}} = \\frac{\\phi_{i,j+1} - \\phi_{i,j}}{\\Delta y}\n$$\n\n离散泊松方程是通过将这些离散算子代入连续方程得到的：\n$$\n\\nabla_h^2 \\phi = \\frac{1}{\\Delta t} \\nabla_h \\cdot \\mathbf{u}^*\n$$\n左侧的离散拉普拉斯算子 $\\nabla_h^2 \\phi$ 是梯度的散度，即 $(\\nabla_h \\cdot \\nabla_h \\phi)$。将离散散度算子应用于离散梯度，得到：\n$$\n(\\nabla_h^2 \\phi)_{i,j} = \\frac{(\\partial_x^h \\phi)_{i+\\frac{1}{2},j} - (\\partial_x^h \\phi)_{i-\\frac{1}{2},j}}{\\Delta x} + \\frac{(\\partial_y^h \\phi)_{i,j+\\frac{1}{2}} - (\\partial_y^h \\phi)_{i,j-\\frac{1}{2}}}{\\Delta y}\n$$\n代入梯度分量的定义：\n$$\n(\\nabla_h^2 \\phi)_{i,j} = \\frac{1}{\\Delta x} \\left( \\frac{\\phi_{i+1,j} - \\phi_{i,j}}{\\Delta x} - \\frac{\\phi_{i,j} - \\phi_{i-1,j}}{\\Delta x} \\right) + \\frac{1}{\\Delta y} \\left( \\frac{\\phi_{i,j+1} - \\phi_{i,j}}{\\Delta y} - \\frac{\\phi_{i,j} - \\phi_{i,j-1}}{\\Delta y} \\right)\n$$\n这简化为矩形网格上拉普拉斯算子的标准5点有限差分模板：\n$$\n(\\nabla_h^2 \\phi)_{i,j} = \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{\\Delta x^2} + \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{\\Delta y^2}\n$$\n问题是求解 $\\nabla_h^2 \\phi = b$，其中右端项(RHS)是 $b_{i,j} = \\frac{1}{\\Delta t} (\\nabla_h \\cdot \\mathbf{u}^*)_{i,j}$。\n\n考虑到周期性边界条件，可以使用谱方法高效地求解这个线性系统。离散傅里叶变换(DFT)可对角化离散拉普拉斯算子。对泊松方程进行二维DFT，将其从耦合的差分方程组转换为傅里葉空間中一组独立的代数方程：\n$$\n\\widehat{(\\nabla_h^2 \\phi)}(k_x,k_y) = \\hat{b}(k_x,k_y)\n$$\n离散拉普拉斯算子的傅里叶变换是其特征值 $\\lambda(k_x, k_y)$。因此，对于每个波数对 $(k_x, k_y)$，我们有：\n$$\n\\lambda(k_x,k_y) \\hat{\\phi}(k_x,k_y) = \\hat{b}(k_x,k_y)\n$$\n在 $N_x \\times N_y$ 周期性网格上，5点模板的特征值由下式给出：\n$$\n\\lambda(k_x,k_y) = \\frac{2\\left(\\cos\\left(\\frac{2\\pi k_x}{N_x}\\right) - 1\\right)}{\\Delta x^2} + \\frac{2\\left(\\cos\\left(\\frac{2\\pi k_y}{N_y}\\right) - 1\\right)}{\\Delta y^2}\n$$\n势的傅里叶系数的解是 $\\hat{\\phi}(k_x,k_y) = \\hat{b}(k_x,k_y) / \\lambda(k_x,k_y)$。对于零频模式 $(k_x, k_y) = (0,0)$，$\\lambda(0,0)=0$，这反映了拉普拉斯算子的零空间由常数函数构成，从而带来了一个复杂问题。为了使解存在，右端项必须是相容的，即其均值必须为零，即 $\\hat{b}(0,0)=0$。对于周期域上的离散散度，这个条件是解析满足的。在数值上，我们通过从右端项中减去任何由于浮点误差产生的非零均值来强制执行此条件。为了确保 $\\phi$ 的唯一解，我们强制 $\\phi$ 具有零均值，这意味着其零频傅里葉系数 $\\hat{\\phi}(0,0)$ 必须为零。\n\n求解算法如下：\n1.  计算体心右端项场 $b = \\frac{1}{\\Delta t} \\nabla_h \\cdot \\mathbf{u}^*$。\n2.  确保 $b$ 的均值为零：$b \\leftarrow b - \\text{mean}(b)$。\n3.  计算 $b$ 的二维DFT，得到 $\\hat{b}(k_x,k_y)$。\n4.  计算势的傅里叶系数：对于 $(k_x,k_y) \\neq (0,0)$，$\\hat{\\phi}(k_x,k_y) = \\hat{b}(k_x,k_y) / \\lambda(k_x,k_y)$，并设置 $\\hat{\\phi}(0,0)=0$。\n5.  计算 $\\hat{\\phi}$ 的二维逆DFT，以获得体心势场 $\\phi(i,j)$。\n\n一旦知道了 $\\phi$，最终的离散无散度速度场 $\\mathbf{u}^{n+1}$ 通过应用离散修正来计算：\n$$\nu_{i+\\frac{1}{2},j}^{n+1} = u_{i+\\frac{1}{2},j}^* - \\Delta t \\frac{\\phi_{i+1,j} - \\phi_{i,j}}{\\Delta x}\n$$\n$$\nv_{i,j+\\frac{1}{2}}^{n+1} = v_{i,j+\\frac{1}{2}}^* - \\Delta t \\frac{\\phi_{i,j+1} - \\phi_{i,j}}{\\Delta y}\n$$\n所得场的散度 $\\nabla_h \\cdot \\mathbf{u}^{n+1}$ 应在机器精度范围内为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not used, as FFT is in numpy.\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for the projection method problem.\n    \"\"\"\n\n    def discrete_divergence(u, v, dx, dy):\n        \"\"\"Computes discrete divergence of face-centered u, v -> cell-centered scalar.\"\"\"\n        # u[i,j] is on right face of cell (i,j), u[i-1, j] is on left face\n        # In numpy, u[i-1] is np.roll(u, 1, axis=0)\n        div_x = (u - np.roll(u, 1, axis=0)) / dx\n        # v[i,j] is on top face of cell (i,j), v[i, j-1] is on bottom face\n        # In numpy, v[j-1] is np.roll(v, 1, axis=1)\n        div_y = (v - np.roll(v, 1, axis=1)) / dy\n        return div_x + div_y\n\n    def discrete_gradient(phi, dx, dy):\n        \"\"\"Computes discrete gradient of cell-centered phi -> face-centered vector.\"\"\"\n        # grad_x at (i+1/2, j) is (phi[i+1,j] - phi[i,j])/dx\n        # In numpy, phi[i+1] is np.roll(phi, -1, axis=0)\n        grad_x = (np.roll(phi, -1, axis=0) - phi) / dx\n        # grad_y at (i, j+1/2) is (phi[i,j+1] - phi[i,j])/dy\n        # In numpy, phi[j+1] is np.roll(phi, -1, axis=1)\n        grad_y = (np.roll(phi, -1, axis=1) - phi) / dy\n        return grad_x, grad_y\n\n    def solve_poisson_spectral(rhs, dx, dy):\n        \"\"\"Solves the periodic Poisson equation using a spectral method.\"\"\"\n        Nx, Ny = rhs.shape\n        \n        # Create wavenumber grids corresponding to FFT output\n        kx_indices = np.arange(Nx)\n        ky_indices = np.arange(Ny)\n        Kx, Ky = np.meshgrid(kx_indices, ky_indices, indexing='ij')\n\n        # Calculate eigenvalues of the 5-point discrete Laplacian\n        lambda_k = (2 * (np.cos(2 * np.pi * Kx / Nx) - 1) / dx**2 +\n                    2 * (np.cos(2 * np.pi * Ky / Ny) - 1) / dy**2)\n\n        # Handle the nullspace: prepare inverse eigenvalues\n        # Set lambda_k(0,0) to a non-zero value to avoid division by zero error.\n        # Its effect is nullified later.\n        lambda_k[0, 0] = 1.0 # arbitrary non-zero\n        inv_lambda_k = 1.0 / lambda_k\n        inv_lambda_k[0, 0] = 0.0 # Enforce zero mean for phi\n\n        # FFT of the right-hand side\n        rhs_hat = np.fft.fft2(rhs)\n\n        # Solve for phi in Fourier space\n        phi_hat = rhs_hat * inv_lambda_k\n\n        # Inverse FFT to get phi in real space\n        phi = np.fft.ifft2(phi_hat).real\n        \n        return phi\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: happy path\n        {'Nx': 8, 'Ny': 6, 'dx': 1.0, 'dy': 1.0, 'dt': 0.1, 'seed': 1, 'mode': 'solve'},\n        # Test 2: no-op correction with constant increment\n        {'Nx': 8, 'Ny': 6, 'dx': 1.0, 'dy': 1.0, 'dt': 0.1, 'seed': 2, 'mode': 'const_phi'},\n        # Test 3: exact gradient cancellation\n        {'Nx': 16, 'Ny': 16, 'dx': 1.0, 'dy': 1.0, 'dt': 0.2, 'seed': None, 'mode': 'exact_grad'},\n        # Test 4: anisotropic grid spacings\n        {'Nx': 10, 'Ny': 12, 'dx': 0.5, 'dy': 0.8, 'dt': 0.05, 'seed': 3, 'mode': 'solve'},\n        # Test 5: zero time step edge case\n        {'Nx': 12, 'Ny': 7, 'dx': 1.0, 'dy': 1.0, 'dt': 0.0, 'seed': 4, 'mode': 'zero_dt'},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        Nx, Ny = case['Nx'], case['Ny']\n        dx, dy = case['dx'], case['dy']\n        dt = case['dt']\n        mode = case['mode']\n        \n        # --- 1. Construct tentative velocities u*, v* ---\n        if mode in ['solve', 'const_phi', 'zero_dt']:\n            rng = np.random.default_rng(case['seed'])\n            u_star = rng.standard_normal((Nx, Ny))\n            v_star = rng.standard_normal((Nx, Ny))\n        elif mode == 'exact_grad':\n            i, j = np.meshgrid(np.arange(Nx), np.arange(Ny), indexing='ij')\n            phi_exact = np.sin(2 * np.pi * 2 * i / Nx) + 0.5 * np.cos(2 * np.pi * 3 * j / Ny)\n            grad_phi_x, grad_phi_y = discrete_gradient(phi_exact, dx, dy)\n            u_star = dt * grad_phi_x\n            v_star = dt * grad_phi_y\n        \n        # --- Pre-correction divergence ---\n        div_u_star = discrete_divergence(u_star, v_star, dx, dy)\n        max_abs_div_before = np.max(np.abs(div_u_star))\n        \n        # --- 2. Solve for phi or set it ---\n        phi = None\n        if mode == 'solve':\n            # Form the RHS\n            rhs = div_u_star / dt\n            # Robustness: ensure RHS has zero mean\n            rhs -= np.mean(rhs)\n            # Solve Poisson equation\n            phi = solve_poisson_spectral(rhs, dx, dy)\n        elif mode == 'const_phi':\n            phi = np.full((Nx, Ny), 1.234)\n        elif mode == 'exact_grad':\n            # Use phi_exact for the correction\n            phi = phi_exact\n        elif mode == 'zero_dt':\n            # As per problem, set phi to zero.\n            # Note: correction is u_star - dt * grad(phi), so any phi is fine if dt=0.\n            phi = np.zeros((Nx, Ny))\n\n        # --- 3. Apply velocity correction ---\n        grad_phi_x, grad_phi_y = discrete_gradient(phi, dx, dy)\n        u_new = u_star - dt * grad_phi_x\n        v_new = v_star - dt * grad_phi_y\n\n        # --- 4. Compute final divergence and report ---\n        div_u_new = discrete_divergence(u_new, v_new, dx, dy)\n        max_abs_div_after = np.max(np.abs(div_u_new))\n        \n        if mode in ['const_phi', 'zero_dt']:\n            # Ratio of after to before\n            # Avoid division by zero if initial divergence is already zero\n            if max_abs_div_before > 1e-16:\n                result = max_abs_div_after / max_abs_div_before\n            else:\n                result = 1.0 if max_abs_div_after  1e-16 else np.inf\n            results.append(result)\n        else: # 'solve', 'exact_grad'\n            results.append(max_abs_div_after)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}