{
    "hands_on_practices": [
        {
            "introduction": "理解迭代算法的最佳方式是亲手执行一次迭代。本练习将一个完整的SIMPLE迭代分解为动量预测、压力修正和速度校正等基本步骤。通过完成这项计算，您将对预测-校正循环的工作原理以及压力与速度如何通过连续性方程耦合起来，形成具体而深刻的认识。",
            "id": "4100265",
            "problem": "考虑一个不可压缩的二维顶盖驱动方腔流，并关注在固定垂直位置沿水平方向的一维、四单元均匀控制体线。使用压力耦合方程组的半隐式方法 (SIMPLE) 对此线执行单次预测-校正迭代。假设变量是无量纲的，因此空间间距、面面积和密度均为单位1。目的是计算单个SIMPLE迭代，包括预测速度、求解压力校正方程，以及更新选定内部面上的质量通量。\n\n推导基于以下基本定律和定义：\n- 不可压缩连续性方程为 $ \\nabla \\cdot \\boldsymbol{u} = 0 $。\n- 作用于控制体的积分形式的不可压缩动量方程指出，动量的时间变化率等于表面通量和体积力之和；经过标准的有限体积空间离散化和线性化后，每个分量都会产生一个形式为 $ a_P u_P = \\sum_{N} a_N u_N + b $ 的线性代数方程，其中 $ a_P $ 是正对角系数, $ a_N $ 是相邻系数, $ b $ 是包含显式贡献（例如，来自上一次迭代的压力梯度）的组合源项。\n- 在SIMPLE算法中，预测速度 $ u^* $ 是通过使用当前压力场求解线性化的动量方程获得的。压力校正 $ p' $ 用于强制满足连续性，而更新的速度和通量则是通过应用压力校正形成的。\n\n简化为具有单元索引 $ i \\in \\{0,1,2,3\\} $ 和内部单元 $ i \\in \\{1,2\\} $ 的一维四单元线。令 $ u_i $ 表示单元 $ i $ 的单元中心水平速度。单元 $ i = 0 $ 和 $ i = 3 $ 是具有给定速度（无量纲）的边界。对于这个单次SIMPLE迭代，假设如下：\n1. 预测步（动量）：对于每个内部单元 $ i \\in \\{1,2\\} $，使用单次类雅可比更新计算预测速度 $ u_i^* $，\n   $$ u_i^* = \\frac{a_{W,i} \\, u_{i-1}^{\\text{old}} + a_{E,i} \\, u_{i+1}^{\\text{old}} + b_i}{a_{P,i}}, $$\n   其中 $ a_{P,i} > 0 $ 是对角系数， $ a_{W,i} \\ge 0 $ 和 $ a_{E,i} \\ge 0 $ 分别是西侧和东侧的相邻系数， $ b_i $ 是源项。边界值 $ u_0^* $ 和 $ u_3^* $ 等于其给定值 $ u_0^{\\text{old}} $ 和 $ u_3^{\\text{old}} $。\n2. 预测的面质量通量：对于单元 $ (0|1) $、$ (1|2) $ 和 $ (2|3) $ 之间的面，使用算术插值计算预测的质量通量，\n   $$ F_{i,i+1}^* = \\frac{u_i^* + u_{i+1}^*}{2}, $$\n   注意，在这些无量纲单位中，密度和面面积均为单位1。\n3. 连续性残差：对于内部单元 $ i \\in \\{1,2\\} $，将残差定义为净流出量，\n   $$ r_i = F_{i-1,i}^* - F_{i,i+1}^*. $$\n   连续性要求 $ r_i = 0 $；非零的 $ r_i $ 驱动压力校正。\n4. 压力校正方程：定义面系数\n   $$ d_{0.5} = \\frac{1}{a_{P,1}}, \\quad d_{1.5} = \\frac{1}{2} \\left( \\frac{1}{a_{P,1}} + \\frac{1}{a_{P,2}} \\right), \\quad d_{2.5} = \\frac{1}{a_{P,2}}, $$\n   分别对应于面 $ (0|1) $、$ (1|2) $ 和 $ (2|3) $。在边界处使用狄利克雷压力校正值 $ p_0' = 0 $ 和 $ p_3' = 0 $，为 $ p_1' $ 和 $ p_2' $ 建立线性系统：\n   $$ (d_{0.5} + d_{1.5}) \\, p_1' - d_{1.5} \\, p_2' = - r_1, $$\n   $$ - d_{1.5} \\, p_1' + (d_{1.5} + d_{2.5}) \\, p_2' = - r_2. $$\n   求解此 $ 2 \\times 2 $ 系统以获得 $ p_1' $ 和 $ p_2' $。\n5. 在选定的内部面上进行通量校正和更新：对于选定的内部面 $ (1|2) $，使用以下公式更新质量通量\n   $$ F_{1,2} = F_{1,2}^* - d_{1.5} \\left( p_2' - p_1' \\right). $$\n\n所有量均为无量纲。不需要物理单位。不涉及角度。不涉及百分比。\n\n测试套件和要求输出：\n- 对于每个测试用例，给定 $ a_{P,1} $、$ a_{P,2} $、$ a_{W,1} $、$ a_{E,1} $、$ a_{W,2} $、$ a_{E,2} $、$ b_1 $、$ b_2 $ 以及边界和内部的初始猜测值 $ u_0^{\\text{old}} $、$ u_1^{\\text{old}} $、$ u_2^{\\text{old}} $、$ u_3^{\\text{old}} $。应用上述步骤计算并返回每个测试用例的列表 $ [u_1^*, u_2^*, p_1', p_2', F_{1,2}] $，每个值四舍五入到六位小数。\n- 使用以下三个测试用例：\n  1. 案例 A (典型情况): $ a_{P,1} = 10.0 $, $ a_{P,2} = 12.0 $, $ a_{W,1} = 2.0 $, $ a_{E,1} = 3.0 $, $ a_{W,2} = 1.5 $, $ a_{E,2} = 2.5 $, $ b_1 = 1.5 $, $ b_2 = 1.0 $, $ u_0^{\\text{old}} = 0.0 $, $ u_1^{\\text{old}} = 0.2 $, $ u_2^{\\text{old}} = 0.1 $, $ u_3^{\\text{old}} = 0.0 $。\n  2. 案例 B (平衡零预测): $ a_{P,1} = 8.0 $, $ a_{P,2} = 8.0 $, $ a_{W,1} = 2.0 $, $ a_{E,1} = 2.0 $, $ a_{W,2} = 2.0 $, $ a_{E,2} = 2.0 $, $ b_1 = 0.0 $, $ b_2 = 0.0 $, $ u_0^{\\text{old}} = 0.0 $, $ u_1^{\\text{old}} = 0.0 $, $ u_2^{\\text{old}} = 0.0 $, $ u_3^{\\text{old}} = 0.0 $。\n  3. 案例 C (弱对角, 大校正): $ a_{P,1} = 1.5 $, $ a_{P,2} = 1.2 $, $ a_{W,1} = 0.5 $, $ a_{E,1} = 0.7 $, $ a_{W,2} = 0.6 $, $ a_{E,2} = 0.4 $, $ b_1 = 0.8 $, $ b_2 = 0.6 $, $ u_0^{\\text{old}} = 0.0 $, $ u_1^{\\text{old}} = 0.2 $, $ u_2^{\\text{old}} = -0.1 $, $ u_3^{\\text{old}} = 0.0 $。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，格式为逗号分隔的列表的列表，每个内部列表按 $ [u_1^*, u_2^*, p_1', p_2', F_{1,2}] $ 的顺序排列，数值四舍五入到六位小数，并包含在一对单独的方括号中。例如，一个包含两个案例的输出将如下所示：$ [[\\dots],[\\dots]] $。",
            "solution": "在进行求解之前，首先评估问题陈述的有效性。\n\n### 步骤 1：提取给定条件\n\n问题陈述为在一个简化的、一维、四单元计算网格上执行单次压力耦合方程组的半隐式方法（SIMPLE）迭代提供了详细的、分步的过程。关键要素如下：\n\n**控制原则和定义：**\n- 不可压缩连续性方程：$ \\nabla \\cdot \\boldsymbol{u} = 0 $。\n- 离散化的不可压缩动量方程形式：$ a_P u_P = \\sum_{N} a_N u_N + b $。\n- 网格：具有索引 $ i \\in \\{0,1,2,3\\} $ 的一维四单元线。内部单元为 $ i \\in \\{1,2\\} $。\n- 无量纲化：空间间距、面面积和密度均为单位一 ($1$)。\n- 边界条件：单元 $ i = 0 $ 和 $ i = 3 $ 具有给定的速度。边界上的压力校正为零：$ p_0' = 0 $ 和 $ p_3' = 0 $。\n\n**单次迭代的算法步骤：**\n1.  **预测步**：对于内部单元 $ i \\in \\{1,2\\} $，使用类雅可比更新，根据旧时刻的值 $ u^{\\text{old}} $ 计算预测速度 $ u_i^* $：\n    $$ u_i^* = \\frac{a_{W,i} \\, u_{i-1}^{\\text{old}} + a_{E,i} \\, u_{i+1}^{\\text{old}} + b_i}{a_{P,i}} $$\n    边界速度是固定的：$ u_0^* = u_0^{\\text{old}} $ 和 $ u_3^* = u_3^{\\text{old}} $。\n2.  **预测的面质量通量**：对于单元之间的面，通过算术插值计算通量 $ F^* $：\n    $$ F_{i,i+1}^* = \\frac{u_i^* + u_{i+1}^*}{2} $$\n3.  **连续性残差**：对于内部单元 $ i \\in \\{1,2\\} $，残差 $ r_i $ 是净质量流出：\n    $$ r_i = F_{i-1,i}^* - F_{i,i+1}^* $$\n4.  **压力校正方程**：面系数 $ d $ 定义为：\n    $$ d_{0.5} = \\frac{1}{a_{P,1}}, \\quad d_{1.5} = \\frac{1}{2} \\left( \\frac{1}{a_{P,1}} + \\frac{1}{a_{P,2}} \\right), \\quad d_{2.5} = \\frac{1}{a_{P,2}} $$\n    通过求解 $ 2 \\times 2 $ 线性系统找到内部单元的压力校正值 $ p_1' $ 和 $ p_2' $：\n    $$ (d_{0.5} + d_{1.5}) \\, p_1' - d_{1.5} \\, p_2' = - r_1 $$\n    $$ - d_{1.5} \\, p_1' + (d_{1.5} + d_{2.5}) \\, p_2' = - r_2 $$\n5.  **通量校正**：更新内部面 $ (1|2) $ 上的质量通量：\n    $$ F_{1,2} = F_{1,2}^* - d_{1.5} \\left( p_2' - p_1' \\right) $$\n\n**测试用例和输出要求：**\n- 提供了三个测试用例（A、B、C），每个用例都有一整套参数：$ a_{P,1}, a_{P,2}, a_{W,1}, a_{E,1}, a_{W,2}, a_{E,2}, b_1, b_2, u_0^{\\text{old}}, u_1^{\\text{old}}, u_2^{\\text{old}}, u_3^{\\text{old}} $。\n- 每个用例要求的输出是列表 $ [u_1^*, u_2^*, p_1', p_2', F_{1,2}] $，数值四舍五入到六位小数。\n\n### 步骤 2：使用提取的给定条件进行验证\n\n根据验证标准对问题进行评估。\n\n-   **科学依据**：该问题是 SIMPLE 算法的一个应用，该算法是计算流体力学（CFD）中求解不可压缩流动的基石。所提供的方程，虽然为一维情况作了简化，但正确地代表了算法的基本步骤：动量预测、质量不平衡（连续性残差）的计算、压力校正的类泊松方程的建立，以及随后的速度/通量校正。这是该领域中一个标准且有效的框架。\n-   **适定性**：问题被构造为一系列显式计算。每一步的输入是上一步的输出。关键步骤是求解压力校正的 $ 2 \\times 2 $ 线性系统。系统矩阵为 $ \\boldsymbol{A} = \\begin{pmatrix} d_{0.5} + d_{1.5}  -d_{1.5} \\\\ -d_{1.5}  d_{1.5} + d_{2.5} \\end{pmatrix} $。问题陈述 $ a_{P,i}  0 $，这意味着所有 $ d $ 系数（$d_{0.5}, d_{1.5}, d_{2.5}$）都严格为正。该矩阵的行列式为 $ \\det(\\boldsymbol{A}) = (d_{0.5} + d_{1.5})(d_{1.5} + d_{2.5}) - d_{1.5}^2 = d_{0.5}d_{1.5} + d_{0.5}d_{2.5} + d_{1.5}d_{2.5} $。由于所有 $ d $ 系数均为正，因此行列式也严格为正。因此，该矩阵总是可逆的，并且存在 $ (p_1', p_2') $ 的唯一解。问题是适定的。\n-   **客观性**：问题以精确、定量和明确的术语陈述。它完全不含主观或基于意见的内容。\n-   **完整性和一致性**：每个测试用例所需的所有数据，包括系数、初始条件和边界条件，都已提供。算法步骤清晰地描述，并且不包含内部矛盾。\n-   **其他缺陷**：问题并非微不足道，因为它需要涉及求解线性系统的多步计算。它是一个具体的计算问题，而不是一个隐喻或同义反复。所给参数对于离散化的流动问题是物理上合理的。\n\n问题陈述是一个基于已确立的CFD原则的、有效的、定义明确的计算任务。\n\n### 步骤 3：结论和行动\n\n问题是**有效的**。将通过系统地将规定的算法应用于给定的测试用例来提供解决方案。\n\n### 解决方案\n\n解决方案涉及为每个测试用例执行五个指定的步骤。下面以案例A为例演示该过程，最终的程序将计算所有三个案例的结果。\n\n**案例A详细步骤**\n\n**案例A的给定数据：**\n- 系数：$ a_{P,1} = 10.0 $, $ a_{P,2} = 12.0 $, $ a_{W,1} = 2.0 $, $ a_{E,1} = 3.0 $, $ a_{W,2} = 1.5 $, $ a_{E,2} = 2.5 $\n- 源项：$ b_1 = 1.5 $, $ b_2 = 1.0 $\n- 初始速度：$ u_0^{\\text{old}} = 0.0 $, $ u_1^{\\text{old}} = 0.2 $, $ u_2^{\\text{old}} = 0.1 $, $ u_3^{\\text{old}} = 0.0 $\n\n**1. 预测步**\n计算内部单元的预测速度 $ u_1^* $ 和 $ u_2^* $。边界速度是固定的。\n$ u_0^* = u_0^{\\text{old}} = 0.0 $\n$ u_3^* = u_3^{\\text{old}} = 0.0 $\n$$ u_1^* = \\frac{a_{W,1} \\, u_{0}^{\\text{old}} + a_{E,1} \\, u_{2}^{\\text{old}} + b_1}{a_{P,1}} = \\frac{(2.0)(0.0) + (3.0)(0.1) + 1.5}{10.0} = \\frac{0.3 + 1.5}{10.0} = 0.18 $$\n$$ u_2^* = \\frac{a_{W,2} \\, u_{1}^{\\text{old}} + a_{E,2} \\, u_{3}^{\\text{old}} + b_2}{a_{P,2}} = \\frac{(1.5)(0.2) + (2.5)(0.0) + 1.0}{12.0} = \\frac{0.3 + 1.0}{12.0} = \\frac{1.3}{12.0} \\approx 0.108333 $$\n\n**2. 预测的面质量通量**\n计算单元面上的预测质量通量 $ F^* $。\n$$ F_{0,1}^* = \\frac{u_0^* + u_1^*}{2} = \\frac{0.0 + 0.18}{2} = 0.09 $$\n$$ F_{1,2}^* = \\frac{u_1^* + u_2^*}{2} = \\frac{0.18 + 1.3/12.0}{2} \\approx \\frac{0.288333}{2} \\approx 0.144167 $$\n$$ F_{2,3}^* = \\frac{u_2^* + u_3^*}{2} = \\frac{1.3/12.0 + 0.0}{2} \\approx \\frac{0.108333}{2} \\approx 0.054167 $$\n\n**3. 连续性残差**\n找出内部单元的质量不平衡（残差） $ r_1 $ 和 $ r_2 $。\n$$ r_1 = F_{0,1}^* - F_{1,2}^* \\approx 0.09 - 0.144167 = -0.054167 $$\n$$ r_2 = F_{1,2}^* - F_{2,3}^* \\approx 0.144167 - 0.054167 = 0.09 $$\n\n**4. 压力校正方程**\n首先，计算面系数 $ d $。\n$$ d_{0.5} = \\frac{1}{a_{P,1}} = \\frac{1}{10.0} = 0.1 $$\n$$ d_{1.5} = \\frac{1}{2} \\left( \\frac{1}{a_{P,1}} + \\frac{1}{a_{P,2}} \\right) = \\frac{1}{2} \\left( \\frac{1}{10.0} + \\frac{1}{12.0} \\right) = \\frac{1}{2} \\left( \\frac{11}{60} \\right) = \\frac{11}{120} \\approx 0.091667 $$\n$$ d_{2.5} = \\frac{1}{a_{P,2}} = \\frac{1}{12.0} \\approx 0.083333 $$\n建立并求解 $ p_1' $ 和 $ p_2' $ 的 $ 2 \\times 2 $ 系统。\n该系统为 $ \\boldsymbol{A} \\boldsymbol{p'} = \\boldsymbol{b} $，其中 $ \\boldsymbol{p'} = [p_1', p_2']^T $，$ \\boldsymbol{b} = [-r_1, -r_2]^T $，矩阵为：\n$$ \\boldsymbol{A} = \\begin{pmatrix} d_{0.5} + d_{1.5}  -d_{1.5} \\\\ -d_{1.5}  d_{1.5} + d_{2.5} \\end{pmatrix} \\approx \\begin{pmatrix} 0.1 + 0.091667  -0.091667 \\\\ -0.091667  0.091667 + 0.083333 \\end{pmatrix} = \\begin{pmatrix} 0.191667  -0.091667 \\\\ -0.091667  0.175 \\end{pmatrix} $$\n右侧项为 $ \\boldsymbol{b} \\approx [0.054167, -0.09]^T $。\n求解该系统得出：\n$$ p_1' \\approx 0.048895 $$\n$$ p_2' \\approx -0.488674 $$\n\n**5. 通量校正**\n最后，更新内部面上的质量通量 $ F_{1,2} $。\n$$ F_{1,2} = F_{1,2}^* - d_{1.5} ( p_2' - p_1' ) $$\n$$ F_{1,2} \\approx 0.144167 - (0.091667) (-0.488674 - 0.048895) $$\n$$ F_{1,2} \\approx 0.144167 - (0.091667) (-0.537569) \\approx 0.144167 + 0.049277 \\approx 0.193444 $$\n\n案例A的最终结果向量，四舍五入到六位小数后为 $ [0.180000, 0.108333, 0.048895, -0.488674, 0.193444] $。提供的代码中对所有测试用例应用了相同的过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D SIMPLE algorithm problem for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (typical)\n        {\n            \"coeffs\": (10.0, 12.0, 2.0, 3.0, 1.5, 2.5),\n            \"sources\": (1.5, 1.0),\n            \"u_old\": (0.0, 0.2, 0.1, 0.0)\n        },\n        # Case B (balanced-zero predictor)\n        {\n            \"coeffs\": (8.0, 8.0, 2.0, 2.0, 2.0, 2.0),\n            \"sources\": (0.0, 0.0),\n            \"u_old\": (0.0, 0.0, 0.0, 0.0)\n        },\n        # Case C (weak diagonal, large correction)\n        {\n            \"coeffs\": (1.5, 1.2, 0.5, 0.7, 0.6, 0.4),\n            \"sources\": (0.8, 0.6),\n            \"u_old\": (0.0, 0.2, -0.1, 0.0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for the current case\n        a_P1, a_P2, a_W1, a_E1, a_W2, a_E2 = case[\"coeffs\"]\n        b1, b2 = case[\"sources\"]\n        u0_old, u1_old, u2_old, u3_old = case[\"u_old\"]\n\n        # Step 1: Predictor step\n        # Boundary velocities are fixed\n        u0_star = u0_old\n        u3_star = u3_old\n        \n        # Predicted velocities for interior cells\n        u1_star = (a_W1 * u0_old + a_E1 * u2_old + b1) / a_P1\n        u2_star = (a_W2 * u1_old + a_E2 * u3_old + b2) / a_P2\n\n        # Step 2: Predicted face mass fluxes\n        F_01_star = (u0_star + u1_star) / 2.0\n        F_12_star = (u1_star + u2_star) / 2.0\n        F_23_star = (u2_star + u3_star) / 2.0\n\n        # Step 3: Continuity residuals\n        r1 = F_01_star - F_12_star\n        r2 = F_12_star - F_23_star\n\n        # Step 4: Pressure-correction equation\n        # Define face coefficients d\n        d_05 = 1.0 / a_P1\n        d_15 = 0.5 * (1.0 / a_P1 + 1.0 / a_P2)\n        d_25 = 1.0 / a_P2\n\n        # Assemble the 2x2 linear system A * p' = b_p\n        A_p = np.array([\n            [d_05 + d_15, -d_15],\n            [-d_15, d_15 + d_25]\n        ])\n        b_p = np.array([-r1, -r2])\n\n        # Solve for pressure correction values [p1', p2']\n        p_prime = np.linalg.solve(A_p, b_p)\n        p1_prime = p_prime[0]\n        p2_prime = p_prime[1]\n\n        # Step 5: Flux correction and update\n        F_12 = F_12_star - d_15 * (p2_prime - p1_prime)\n\n        # Assemble the result vector and round to six decimal places\n        case_result = [\n            round(u1_star, 6),\n            round(u2_star, 6),\n            round(p1_prime, 6),\n            round(p2_prime, 6),\n            round(F_12, 6)\n        ]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list is desired\n    # so we convert the final list of lists to string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "求解压力修正方程是耦合算法的核心，但这带来了一个关键的数值挑战：压力泊松方程的奇异性。本练习将引导您计算验证这一问题，并实践两种标准方法来确保压力修正场的解是唯一的，这对于开发稳健的流体求解器至关重要。",
            "id": "4100333",
            "problem": "考虑在压力-速度耦合算法背景下的不可压缩流，特别是压力耦合方程组的半隐式方法 (SIMPLE) 和算子分裂的压力隐式方法 (PISO)。在这些算法中，离散压力修正方程源于对一个预测速度场强制施加质量守恒。从不可压缩连续性方程 $ \\nabla \\cdot \\mathbf{u} = 0 $ 和动量平衡出发，通过一个压力增量（压力修正）$ p' $ 对预测速度 $ \\mathbf{u}^{\\ast} $ 进行修正，以强制满足 $ \\nabla \\cdot \\mathbf{u} = 0 $。在 SIMPLE 和 PISO 中，都会构建一个形式为 $ \\nabla^2 p' = \\text{source} $ 的类泊松方程，其中压力修正的边界条件通常是齐次诺伊曼 (Neumann) 条件 ($ \\partial p'/\\partial n = 0 $)，这反映了 $ p' $ 是一个相对调整量的事实。如果没有参考压力或平均值约束，压力修正只能确定到一个任意的加法常数；因此，离散压力修正矩阵存在一个由常数向量张成的零空间。\n\n您的任务是通过计算机构造来证明，当没有施加参考压力时，离散压力修正矩阵 $ \\mathbf{A} $（一个带有齐次诺伊曼边界条件的离散拉普拉斯算子）是奇异的，并实现两种策略来消除零空间，从而生成一个唯一的、良态的线性系统：\n\n- 策略 1 (狄利克雷钉扎, Dirichlet pinning)：将一个压力修正自由度设置为零，即在单个索引 $ k $ 处强制 $ p'_k = 0 $。\n- 策略 2 (零均值强制)：通过拉格朗日乘子 (Lagrange multiplier) $ \\lambda $ 施加 $ \\sum_i p'_i = 0 $ 的约束，从而求解增广系统\n$$\n\\begin{bmatrix}\n\\mathbf{A}  \\mathbf{1} \\\\\n\\mathbf{1}^\\top  0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{p}' \\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{b} \\\\ 0\n\\end{bmatrix},\n$$\n其中 $ \\mathbf{1} $ 是全一向量，$ \\mathbf{p}' $ 是节点压力修正向量，$ \\mathbf{b} $ 是由预测速度 $ \\mathbf{u}^\\ast $ 的散度推导出的离散源项。\n\n推导的基本依据：\n- 不可压缩连续性 $ \\nabla \\cdot \\mathbf{u} = 0 $ 以及通过梯度将速度修正 $ \\delta \\mathbf{u} $ 与压力修正 $ p' $ 联系起来的压力修正关系，即 $ \\delta \\mathbf{u} \\propto -\\nabla p' $；强制施加连续性会得到一个关于 $ p' $ 的泊松方程。\n- 带有齐次诺伊曼边界条件的离散拉普拉斯算子具有一个常数零空间，这使得系统在没有额外约束的情况下是奇异的。\n\n实现一个完整的、可运行的程序，该程序：\n1. 在一维和二维情况下，在间距为 $ \\Delta x = \\Delta y = 1 $ 的均匀网格上，构建带有齐次诺伊曼边界条件的离散拉普拉斯矩阵 $ \\mathbf{A} $。对于具有 $ N $ 个点的一维网格，边界处使用 $ [-1, +1] $ 模板，内部使用 $ [+1, -2, +1] $ 模板。对于具有 $ N_x \\times N_y $ 个点的二维网格，使用一个五点模板，其中对角线元素为 $ -n_{\\text{nbr}} $，$ n_{\\text{nbr}} $ 等于有效邻居（来自 $ \\{ \\text{left}, \\text{right}, \\text{top}, \\text{bottom} \\} $）的数量，每个邻居的非对角线元素为 $ +1 $，确保行和为零，从而使常数向量位于零空间中。\n2. 通过计算奇异值来验证 $ \\mathbf{A} $ 的奇异性，并检查最小奇异值 $ \\sigma_{\\min} $ 是否满足 $ \\sigma_{\\min} \\leq \\epsilon \\, \\sigma_{\\max} $（其中 $ \\epsilon = 10^{-10} $）；如果 $ \\sigma_{\\max} = 0 $，则将 $ \\mathbf{A} $ 视为奇异矩阵。\n3. 通过修改 $ \\mathbf{A} $ 来实现策略 1，即钉扎一个自由度 $ p'_k = 0 $：将第 $ k $ 行和第 $ k $ 列设置为零，设置对角线元素 $ A_{kk} = 1 $，并设置右端项 $ b_k = 0 $。求解 $ \\mathbf{A}_{\\text{pin}} \\mathbf{p}' = \\mathbf{b}_{\\text{pin}} $ 并计算归一化残差 $ r_{\\text{pin}} = \\|\\mathbf{A}_{\\text{pin}} \\mathbf{p}' - \\mathbf{b}_{\\text{pin}}\\|_2 / \\|\\mathbf{b}_{\\text{pin}}\\|_2 $。\n4. 通过求解上述带有拉格朗日乘子的增广系统来实现策略 2，并计算增广系统的归一化残差 $ r_{\\text{mean}} = \\sqrt{\\|\\mathbf{A} \\mathbf{p}' + \\mathbf{1} \\lambda - \\mathbf{b}\\|_2^2 + (\\mathbf{1}^\\top \\mathbf{p}')^2} / \\sqrt{\\|\\mathbf{b}\\|_2^2 + 0} $。\n5. 对于每个测试用例，输出一个形式为 $ [\\text{is\\_singular}, r_{\\text{pin}}, r_{\\text{mean}}] $ 的列表，其中 $ \\text{is\\_singular} $ 是一个布尔值，$ r_{\\text{pin}} $ 和 $ r_{\\text{mean}} $ 是浮点数。\n\n使用以下测试套件：\n- 测试用例 1 (正常路径，一维)：$ N = 5 $，$ \\mathbf{b} $ 由 $ b_i = \\sin(0.3 (i+1)) + 0.1 (i+1) $ 定义，其中 $ i = 0, \\dots, 4 $，钉扎索引 $ k = 0 $。\n- 测试用例 2 (二维，中等大小)：$ N_x = 4 $，$ N_y = 3 $，$ \\mathbf{b} $ 由 $ b_{i,j} = \\sin(0.2 (i+1)) + \\cos(0.3 (j+1)) $ 定义，其中 $ i = 0, \\dots, 3 $，$ j = 0, \\dots, 2 $，按行主序展开；钉扎索引 $ k = 0 $。\n- 测试用例 3 (边缘情况，单网格)：$ N_x = 1 $，$ N_y = 1 $，$ \\mathbf{b} = [2.0] $，钉扎索引 $ k = 0 $。\n\n由于系统已通过单位网格间距进行了无量纲化，因此不需要物理单位。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的列表。每个测试用例贡献一个形式为 $ [\\text{is\\_singular}, r_{\\text{pin}}, r_{\\text{mean}}] $ 的子列表。最后一行必须是聚合了三个子列表的单个列表，例如 $ [[\\text{bool}, \\text{float}, \\text{float}], [\\text{bool}, \\text{float}, \\text{float}], [\\text{bool}, \\text{float}, \\text{float}]] $。",
            "solution": "当前问题旨在解决使用投影法（如 SIMPLE (压力耦合方程组的半隐式方法) 和 PISO (算子分裂的压力隐式方法) 算法）模拟不可压缩流体流动时的一个基本数值问题。这些方法的核心是强制施加不可压缩性约束，该约束由连续性方程 $\\nabla \\cdot \\mathbf{u} = 0$ 表示，其中 $\\mathbf{u}$ 是速度场。\n\n该过程通常包含两个阶段。首先，从动量方程计算出一个预测速度场，记为 $\\mathbf{u}^{\\ast}$，但该场通常不满足不可压缩性约束，即 $\\nabla \\cdot \\mathbf{u}^{\\ast} \\neq 0$。其次，执行一个修正步骤，将该速度场投影到无散度场的子空间上。修正后的速度 $\\mathbf{u}$ 和压力 $p$ 与其预测对应量 ($\\mathbf{u}^{\\ast}$、$p^{\\ast}$) 通过修正量 $\\delta\\mathbf{u}$ 和 $p'$ 相关联：\n$$ \\mathbf{u} = \\mathbf{u}^{\\ast} + \\delta\\mathbf{u} $$\n$$ p = p^{\\ast} + p' $$\n动量方程的简化形式将速度修正与压力修正的梯度联系起来，即 $\\delta\\mathbf{u} \\propto -\\nabla p'$。通过将此关系代入最终速度的连续性方程 $\\nabla \\cdot \\mathbf{u} = 0$，我们得到了一个关于压力修正 $p'$ 的泊松方程：\n$$ \\nabla \\cdot (\\mathbf{u}^{\\ast} - C \\nabla p') = 0 \\implies \\nabla^2 p' = \\frac{1}{C} \\nabla \\cdot \\mathbf{u}^{\\ast} $$\n其中 $C$ 是一个包含时间步长和其他离散化因子的常数。右边的项代表预测速度场的质量不平衡，并作为泊松方程的源项。\n\n当此方程在计算网格上离散化时，会产生一个形式为 $\\mathbf{A} \\mathbf{p}' = \\mathbf{b}$ 的线性方程组，其中 $\\mathbf{p}'$ 是网格点上未知的压力修正向量，$\\mathbf{b}$ 是离散化的源项 ($\\nabla \\cdot \\mathbf{u}^{\\ast}$)，而 $\\mathbf{A}$ 是离散拉普拉斯算子。一个关键方面是 $p'$ 的边界条件。在速度被指定的边界（例如，入口、固定壁面），速度修正的法向分量为零。这转化为压力修正的齐次诺伊曼边界条件：$\\frac{\\partial p'}{\\partial n} = 0$，其中 $n$ 是垂直于边界的方向。\n\n使用这些齐次诺伊曼边界条件构建的离散拉普拉斯矩阵 $\\mathbf{A}$ 具有一个特殊性质：每行元素的总和为零。这意味着 $\\mathbf{A}\\mathbf{1} = \\mathbf{0}$，其中 $\\mathbf{1}$ 是一个全一列向量。在数学上，这意味着向量 $\\mathbf{1}$ 是 $\\mathbf{A}$ 的一个特征向量，其对应的特征值为 $0$。因此，$\\mathbf{A}$ 具有非平凡的零空间，是奇异的，并且系统 $\\mathbf{A} \\mathbf{p}' = \\mathbf{b}$ 没有唯一解。如果 $\\mathbf{p}'_s$ 是一个特解，那么对于任意常数 $c$，$\\mathbf{p}'_s + c\\mathbf{1}$ 也是一个解，因为 $\\mathbf{A}(\\mathbf{p}'_s + c\\mathbf{1}) = \\mathbf{A}\\mathbf{p}'_s + c(\\mathbf{A}\\mathbf{1}) = \\mathbf{b} + \\mathbf{0} = \\mathbf{b}$。这种不确定性反映了一个物理事实，即不可压缩流中的压力只能被确定到一个任意的加法常数。为了获得唯一解，必须施加一个额外的约束。\n\n本练习通过计算来演示这种奇异性，并实现了两种标准策略来对系统进行正则化。\n\n**1. 矩阵构建与奇异性验证**\n离散拉普拉斯矩阵 $\\mathbf{A}$ 是为间距 $\\Delta x = \\Delta y = 1$ 的一维和二维均匀网格构建的。构建过程确保对于任意行 $i$，对角元素 $A_{ii}$ 是该行非对角元素的负和，即 $A_{ii} = -\\sum_{j \\neq i} A_{ij}$，这强制了行和为零的属性。\n- 对于具有 $N$ 个点的 1D 网格，内部点使用 $[+1, -2, +1]$ 模板，边界点使用导致行和为零的模板（例如 $[-1, +1]$）。\n- 对于 2D 网格，使用五点模板，其中 $A_{kk} = -n_{\\text{nbr}}$（邻居数量），且与邻居对应的非对角线元素为 $+1$。\n通过奇异值分解 (SVD) 计算其奇异值，可以数值地验证 $\\mathbf{A}$ 的奇异性。如果一个矩阵的最小奇异值 $\\sigma_{\\min}$ 为零，则该矩阵是奇异的。在有限精度算术中，我们测试 $\\sigma_{\\min}$ 与最大奇异值 $\\sigma_{\\max}$ 相比是否可以忽略不计，即对于一个小的容差 $\\epsilon = 10^{-10}$，是否有 $\\sigma_{\\min} \\leq \\epsilon \\, \\sigma_{\\max}$。如果 $\\sigma_{\\max} = 0$，则该矩阵（例如，对于 $1 \\times 1$ 网格的零矩阵）也是奇异的。\n\n**2. 正则化策略**\n\n**策略 1：狄利克雷钉扎 (Dirichlet Pinning)**\n此方法通过将单个点 $k$ 处的压力修正固定为一个参考值（通常为零）来消除不确定性：$p'_k = 0$。这等同于设置一个参考压力。在算法上，这是通过修改系统 $\\mathbf{A} \\mathbf{p}' = \\mathbf{b}$ 来实现的：\n- 将 $\\mathbf{A}$ 的第 $k$ 行替换为零（对角线上的元素为 $1$ 除外），并将 $\\mathbf{b}$ 的第 $k$ 个元素设置为 $0$。这强制了 $p'_k = 0$。\n- 为了保持对称性（如果某些求解器需要），通常也会将 $\\mathbf{A}$ 的第 $k$ 列置零（对角线元素除外）。\n得到的系统 $\\mathbf{A}_{\\text{pin}} \\mathbf{p}' = \\mathbf{b}_{\\text{pin}}$ 是非奇异的，并且可以唯一求解。解的质量通过归一化残差 $r_{\\text{pin}} = \\frac{\\|\\mathbf{A}_{\\text{pin}} \\mathbf{p}' - \\mathbf{b}_{\\text{pin}}\\|_2}{\\|\\mathbf{b}_{\\text{pin}}\\|_2}$ 来评估。\n\n**策略 2：零均值强制**\n该策略对解施加了一个全局约束，要求压力修正的平均值为零：$\\sum_i p'_i = 0$，可以写成 $\\mathbf{1}^\\top \\mathbf{p}' = 0$。这个约束从解空间中移除了常数分量。该约束通过使用拉格朗日乘子 $\\lambda$ 并入线性系统中，从而得到增广（鞍点）系统：\n$$\n\\begin{bmatrix}\n\\mathbf{A}  \\mathbf{1} \\\\\n\\mathbf{1}^\\top  0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{p}' \\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{b} \\\\ 0\n\\end{bmatrix}\n$$\n该增广矩阵是非奇异的（前提是 $\\mathbf{A}$ 的零空间仅由 $\\mathbf{1}$ 张成），求解该系统可以得到 $\\mathbf{p}'$（均值为零）和 $\\lambda$ 的唯一解。此增广系统的残差被归一化为 $r_{\\text{mean}} = \\frac{\\sqrt{\\|\\mathbf{A} \\mathbf{p}' + \\mathbf{1} \\lambda - \\mathbf{b}\\|_2^2 + (\\mathbf{1}^\\top \\mathbf{p}')^2}}{\\|\\mathbf{b}\\|_2}$。\n\n下面的实现为给定的测试用例构建了矩阵，验证了它们的奇异性，并应用两种正则化策略求解压力修正，报告了各自的归一化残差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_laplacian_1d(N):\n    \"\"\"\n    Builds the 1D discrete Laplacian matrix A with homogeneous Neumann BCs.\n    The matrix will have zero row sums.\n    \"\"\"\n    if N == 1:\n        return np.array([[0.0]])\n    \n    A = np.zeros((N, N))\n    \n    # Interior points: stencil [+1, -2, +1]\n    for i in range(1, N - 1):\n        A[i, i - 1] = 1.0\n        A[i, i] = -2.0\n        A[i, i + 1] = 1.0\n        \n    # Boundary points: stencil ensures row sum is zero\n    # i=0: -p'_0 + p'_1 = 0\n    A[0, 0] = -1.0\n    A[0, 1] = 1.0\n    # i=N-1: p'_{N-2} - p'_{N-1} = 0\n    A[N - 1, N - 2] = 1.0\n    A[N - 1, N - 1] = -1.0\n    \n    return A\n\ndef build_laplacian_2d(Nx, Ny):\n    \"\"\"\n    Builds the 2D discrete Laplacian matrix A with homogeneous Neumann BCs\n    on a Nx x Ny grid. The matrix will have zero row sums.\n    \"\"\"\n    N = Nx * Ny\n    A = np.zeros((N, N))\n\n    for j in range(Ny):\n        for i in range(Nx):\n            k = j * Nx + i  # Row-major index\n            neighbors = []\n            \n            # Left neighbor\n            if i > 0:\n                neighbors.append(k - 1)\n            # Right neighbor\n            if i  Nx - 1:\n                neighbors.append(k + 1)\n            # Bottom neighbor\n            if j > 0:\n                neighbors.append(k - Nx)\n            # Top neighbor\n            if j  Ny - 1:\n                neighbors.append(k + Nx)\n            \n            # Set off-diagonal entries\n            for neighbor_idx in neighbors:\n                A[k, neighbor_idx] = 1.0\n            \n            # Set diagonal entry\n            A[k, k] = -len(neighbors)\n            \n    return A\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and generate the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"dim\": 1, \"N\": 5, \"Nx\": 5, \"Ny\": 1, \"pin_k\": 0,\n            \"b_func\": lambda i, j: np.sin(0.3 * (i + 1)) + 0.1 * (i + 1)\n        },\n        {\n            \"dim\": 2, \"N\": 12, \"Nx\": 4, \"Ny\": 3, \"pin_k\": 0,\n            \"b_func\": lambda i, j: np.sin(0.2 * (i + 1)) + np.cos(0.3 * (j + 1))\n        },\n        {\n            \"dim\": 2, \"N\": 1, \"Nx\": 1, \"Ny\": 1, \"pin_k\": 0,\n            \"b_func\": lambda i, j: 2.0\n        }\n    ]\n    \n    epsilon = 1e-10\n    results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        Nx = case[\"Nx\"]\n        Ny = case[\"Ny\"]\n        pin_k = case[\"pin_k\"]\n\n        # 1. Build matrix A and vector b\n        if case[\"dim\"] == 1:\n            A = build_laplacian_1d(N)\n            b = np.array([case[\"b_func\"](i, 0) for i in range(N)])\n        else: # dim == 2\n            A = build_laplacian_2d(Nx, Ny)\n            b = np.array([case[\"b_func\"](i, j) for j in range(Ny) for i in range(Nx)])\n        \n        # 2. Verify singularity\n        if N > 0:\n            s = np.linalg.svd(A, compute_uv=False)\n            sigma_max = s[0] if len(s) > 0 else 0.0\n            sigma_min = s[-1] if len(s) > 0 else 0.0\n        \n            if sigma_max == 0:\n                is_singular = True\n            else:\n                is_singular = (sigma_min / sigma_max) = epsilon\n        else: # N=0 case\n             is_singular = False # Or debatable, but not in test cases\n\n        # 3. Strategy 1: Pinning\n        A_pin = A.copy()\n        b_pin = b.copy()\n        \n        A_pin[pin_k, :] = 0.0\n        A_pin[:, pin_k] = 0.0\n        A_pin[pin_k, pin_k] = 1.0\n        b_pin[pin_k] = 0.0\n        \n        p_pin = np.linalg.solve(A_pin, b_pin)\n        \n        norm_b_pin = np.linalg.norm(b_pin)\n        if norm_b_pin == 0.0:\n            r_pin = 0.0\n        else:\n            residual_vec_pin = A_pin @ p_pin - b_pin\n            r_pin = np.linalg.norm(residual_vec_pin) / norm_b_pin\n\n        # 4. Strategy 2: Zero-mean\n        if N > 0:\n            A_aug = np.zeros((N + 1, N + 1))\n            ones_vec = np.ones(N)\n            \n            A_aug[:N, :N] = A\n            A_aug[:N, N] = ones_vec\n            A_aug[N, :N] = ones_vec.T\n            \n            b_aug = np.zeros(N + 1)\n            b_aug[:N] = b\n            \n            sol_aug = np.linalg.solve(A_aug, b_aug)\n            p_mean = sol_aug[:N]\n            lambda_ = sol_aug[N]\n            \n            norm_b = np.linalg.norm(b)\n            if norm_b == 0.0:\n                 r_mean = 0.0\n            else:\n                num_term1_norm = np.linalg.norm(A @ p_mean + ones_vec * lambda_ - b)\n                num_term2 = np.dot(ones_vec.T, p_mean)\n                numerator = np.sqrt(num_term1_norm**2 + num_term2**2)\n                r_mean = numerator / norm_b\n        else:\n            r_mean = 0.0\n        \n        results.append([is_singular, r_pin, r_mean])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "算法的实用性取决于它如何处理物理边界。本练习聚焦于无滑移、不可穿透壁面，演示了压力修正步骤如何被用来精确地强制施加质量守恒（零法向通量）这一基本物理约束。掌握这一机制对于在复杂几何中获得物理上准确的模拟结果至关重要。",
            "id": "4100343",
            "problem": "考虑一个二维不可压缩牛顿流体，它通过同位网格有限体积法进行离散化，并采用一种用于压力-速度耦合的预测-校正算法，例如压力耦合方程组的半隐式方法（SIMPLE）或算子分裂的压力隐式方法（PISO）。一个中心为 $P$ 的控制体与一个平面、不可渗透、无滑移的壁面相邻，该壁面的单位外法向量为 $\\hat{n}$，单位切向量为 $\\hat{t}$。经过动量预测步后，基于预测速度场得到的壁面法向质量通量为 $\\dot{m}_f^{*}$，该值不一定为零。随后的压力校正步通过减去一个按有效系数缩放的压力校正梯度来更新控制体中心的速度。假设有以下数据：\n- 流体密度 $\\rho = 1000$ 千克/立方米 (kg/m$^{3}$)。\n- 壁面面积 $S_f = 0.08$ 平方米 (m$^{2}$)。\n- 预测的壁面法向质量通量 $\\dot{m}_f^{*} = 0.1$ 千克/秒 (kg/s)。\n- 有效面系数 $d_f = 4.0 \\times 10^{-4}$ 立方米·秒/千克 (m$^{3}$ s/kg)，该系数关联了壁面处压力校正梯度的法向分量与该壁面处法向速度的变化。\n- 有效控制体中心系数 $d_P = 5.0 \\times 10^{-4}$ 立方米·秒/千克 (m$^{3}$ s/kg)，该系数关联了 $P$ 处的压力校正梯度与 $P$ 处速度的校正量。\n\n假设压力校正场的梯度的壁面法向分量在控制体中心 $P$ 和壁面之间是均匀的，并且在壁面处压力校正梯度的壁面切向分量为零，以使校正步能保持无滑移条件。仅使用\n- 结合壁面不可渗透性的不可压缩质量守恒，以及\n- 从预测速度中减去一个适当缩放的压力校正梯度的线性化动量校正子，\n\n推导并计算由压力校正步产生的、施加于控制体中心 $P$ 处速度的壁面法向和壁面切向分量的校正值。将您的最终答案表示为一个 $1 \\times 2$ 的行矩阵 $[\\Delta u_n \\;\\; \\Delta u_t]$，单位为米/秒，并将答案四舍五入到四位有效数字。",
            "solution": "我们从不可压缩连续性方程和不可渗透壁面条件开始。不可渗透性要求壁面处的法向速度为零。在预测-校正格式中，动量预测步提供一个通常不满足离散连续性约束的临时速度。然后，校正步应用压力校正梯度来调整速度场，以强制满足连续性。对于同位网格有限体积法，动量算子的标准线性化意味着速度校正量与压力校正的梯度成正比。\n\n设 $\\mathbf{u}^{*}$ 表示预测速度，$\\mathbf{u}'$ 表示压力校正步中的校正后速度。在控制体中心 $P$ 处，线性化动量校正子具有以下形式\n$$\n\\mathbf{u}'(P) \\;=\\; \\mathbf{u}^{*}(P) \\;-\\; d_P \\,\\nabla p'(P),\n$$\n其中 $d_P$ 是一个有效的标量系数，代表了线性化动量算子矩阵对角项的逆，而 $p'$ 是压力校正。沿壁面法向和壁面切向取分量，我们得到控制体中心的速度校正量\n$$\n\\Delta u_n(P) \\;=\\; -\\, d_P \\, \\left(\\nabla p'\\right)(P)\\cdot \\hat{n},\n\\qquad\n\\Delta u_t(P) \\;=\\; -\\, d_P \\, \\left(\\nabla p'\\right)(P)\\cdot \\hat{t}.\n$$\n\n在壁面处，基于校正后速度的法向质量通量必须因不可渗透性而为零。设 $\\dot{m}_f^{*}$ 为预测的壁面法向质量通量（基于 $\\mathbf{u}^{*}$），$\\dot{m}_f'$ 为校正后的壁面法向质量通量。不可渗透壁面处的质量守恒要求\n$$\n\\dot{m}_f' \\;=\\; 0.\n$$\n压力校正会修正壁面法向速度，从而修正壁面法向质量通量。在与同样动量线性化一致的线性面插值下，由压力校正引起的壁面法向质量通量变化与面上的压力校正梯度的壁面法向分量成正比：\n$$\n\\Delta \\dot{m}_f \\;=\\; \\dot{m}_f' - \\dot{m}_f^{*} \\;=\\; -\\, \\rho \\, S_f \\, d_f \\; \\left(\\nabla p'\\right)_f \\cdot \\hat{n}.\n$$\n强制 $\\dot{m}_f' = 0$ 可得\n$$\n0 \\;=\\; \\dot{m}_f^{*} - \\rho \\, S_f \\, d_f \\; \\left(\\nabla p'\\right)_f \\cdot \\hat{n}\n\\;\\;\\Longrightarrow\\;\\;\n\\left(\\nabla p'\\right)_f \\cdot \\hat{n} \\;=\\; \\frac{\\dot{m}_f^{*}}{\\rho \\, S_f \\, d_f}.\n$$\n根据所述假设，即 $\\nabla p'$ 的壁面法向分量在 $P$ 和壁面之间是均匀的，我们取\n$$\n\\left(\\nabla p'\\right)(P)\\cdot \\hat{n} \\;=\\; \\left(\\nabla p'\\right)_f \\cdot \\hat{n} \\;=\\; \\frac{\\dot{m}_f^{*}}{\\rho \\, S_f \\, d_f}.\n$$\n因此，控制体中心的壁面法向速度校正量为\n$$\n\\Delta u_n(P) \\;=\\; -\\, d_P \\, \\frac{\\dot{m}_f^{*}}{\\rho \\, S_f \\, d_f}.\n$$\n为了在校正步中保持无滑移条件，我们强制要求压力校正梯度在壁面处没有切向分量。根据所述假设，即壁面切向分量在壁面处为零，并且考虑到在线性化下，相同的切向分量也适用于校正步中的 $P$ 点，我们有\n$$\n\\left(\\nabla p'\\right)(P)\\cdot \\hat{t} \\;=\\; 0\n\\;\\;\\Longrightarrow\\;\\;\n\\Delta u_t(P) \\;=\\; 0.\n$$\n\n现在我们使用给定的参数计算数值：\n- $\\rho = 1000$ kg/m$^{3}$，\n- $S_f = 0.08$ m$^{2}$，\n- $d_f = 4.0 \\times 10^{-4}$ m$^{3}$ s/kg，\n- $d_P = 5.0 \\times 10^{-4}$ m$^{3}$ s/kg，\n- $\\dot{m}_f^{*} = 0.1$ kg/s。\n\n首先计算压力校正梯度的壁面法向分量：\n$$\n\\left(\\nabla p'\\right)\\cdot \\hat{n} \\;=\\; \\frac{\\dot{m}_f^{*}}{\\rho \\, S_f \\, d_f}\n\\;=\\; \\frac{0.1}{1000 \\times 0.08 \\times 4.0 \\times 10^{-4}}\n\\;=\\; \\frac{0.1}{0.032}\n\\;=\\; 3.125.\n$$\n该值具有压力梯度的单位，与千克/米²秒²一致。那么，控制体中心的壁面法向速度校正量为\n$$\n\\Delta u_n(P) \\;=\\; -\\, d_P \\, \\left(\\nabla p'\\right)\\cdot \\hat{n}\n\\;=\\; -\\, \\left(5.0 \\times 10^{-4}\\right) \\times 3.125\n\\;=\\; -\\, 1.5625 \\times 10^{-3}.\n$$\n因此，以米/秒为单位，$\\Delta u_n(P) = -0.0015625$ m/s。壁面切向校正量为\n$$\n\\Delta u_t(P) \\;=\\; 0.\n$$\n四舍五入到四位有效数字，并将结果表示为以米/秒为单位的 $1 \\times 2$ 行矩阵，得到\n$$\n[\\Delta u_n \\;\\; \\Delta u_t] \\;=\\; [-0.001563 \\;\\; 0].\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}-0.001563  0\\end{pmatrix}}$$"
        }
    ]
}