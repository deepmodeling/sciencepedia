{
    "hands_on_practices": [
        {
            "introduction": "水平集方法（level-set method）的基石是使用标量场对界面进行隐式表示。本练习将引导您完成构建此表示的基本过程。通过为简单的圆形界面推导符号距离函数（signed distance function, SDF），您将对其性质及其在计算域内定义几何形状的作用有一个具体的理解。这项实践对于建立几何信息如何编码在水平集函数中的直觉至关重要。",
            "id": "4092664",
            "problem": "考虑一个在静止不可压缩复杂流体中的二维不混溶界面，在水平集方法中由一个标量函数 $\\phi(\\mathbf{x},t)$ 表示，其零水平集 $\\{\\mathbf{x}:\\phi(\\mathbf{x},t)=0\\}$ 与物质界面重合。在初始时刻 $t=0$，界面 $\\Gamma$ 是 $\\mathbb{R}^{2}$ 中以原点为中心、半径为 $R>0$ 的圆。采用水平集方法中的标准符号约定：在 $\\Gamma$ 所包围的区域内 $\\phi(\\mathbf{x},t)0$，在区域外 $\\phi(\\mathbf{x},t)>0$。\n\n从欧几里得空间中集合的符号距离定义出发，构造一个关于笛卡尔坐标 $\\mathbf{x}=(x,y)$ 和 $R$ 的 $\\phi(\\mathbf{x},0)$ 的显式解析表达式，使得 $\\phi(\\mathbf{x},0)$ 是一个符合上述符号约定的到 $\\Gamma$ 的符号距离函数。然后，通过从第一性原理直接求导，验证对于所有 $\\mathbf{x}\\neq\\mathbf{0}$，符号距离性质 $|\\nabla \\phi(\\mathbf{x},0)|=1$ 均成立，并指出任何可微性失效的点。最后，确认在 $\\Gamma$ 上计算出的外向单位法向量 $\\mathbf{n}$（即 $\\nabla \\phi/|\\nabla \\phi|$）与几何法线一致。\n\n最终答案仅提供 $\\phi(\\mathbf{x},0)$ 的显式解析表达式。无需四舍五入。最终答案中请勿包含单位。",
            "solution": "在进行求解之前，首先评估问题陈述的有效性。\n\n### 第1步：提取已知条件\n-   该系统是一个在静止不可压缩复杂流体中的二维不混溶界面。\n-   该界面由标量函数 $\\phi(\\mathbf{x},t)$ 的零水平集表示，即 $\\{\\mathbf{x} : \\phi(\\mathbf{x},t)=0\\}$。\n-   在初始时刻 $t=0$，界面 $\\Gamma$ 是 $\\mathbb{R}^{2}$ 中以原点为中心、半径为 $R>0$ 的圆。\n-   位置向量为 $\\mathbf{x}=(x,y)$。\n-   水平集函数的符号约定为：在 $\\Gamma$ 所包围的区域内 $\\phi(\\mathbf{x},t)0$，在区域外 $\\phi(\\mathbf{x},t)>0$。\n-   任务如下：\n    1.  构造一个作为到 $\\Gamma$ 的符号距离函数的 $\\phi(\\mathbf{x},0)$ 的显式解析表达式。\n    2.  通过直接求导验证，对于所有 $\\mathbf{x}\\neq\\mathbf{0}$，符号距离性质 $|\\nabla \\phi(\\mathbf{x},0)|=1$ 均成立。\n    3.  指出 $\\phi(\\mathbf{x},0)$ 可微性失效的点。\n    4.  确认在 $\\Gamma$ 上的外向单位法向量 $\\mathbf{n} = \\nabla \\phi/|\\nabla \\phi|$ 与几何法线一致。\n\n### 第2步：使用提取的已知条件进行验证\n-   **科学依据：** 该问题是水平集方法中的一个标准练习，水平集方法是计算流体动力学和材料科学中广泛使用的技术。符号距离函数、程函方程（$|\\nabla \\phi|=1$）以及梯度的几何解释等概念，在微分几何和数值分析中都是基础且公认的。其物理背景是现实的，并为该数学任务提供了有效的前提。\n-   **适定性：** 问题定义清晰且自洽。几何形状（一个圆）已指定，符号约定明确，任务清晰。所提供的信息足以推导出符号距离函数的唯一解析表达式，并执行所需的验证。\n-   **客观性：** 问题以精确、形式化的数学语言陈述，没有任何主观性或模糊性。\n\n该问题没有表现出任何诸如科学不合理、不完整、矛盾或不可行性等缺陷。在计算复杂流体和应用数学领域内，这是一个适定的、客观的且有科学依据的问题。\n\n### 第3步：结论与行动\n该问题是有效的。将提供一个完整的、有理有据的解答。\n\n### 解答推导\n求解过程首先从其定义构造符号距离函数，然后通过求导验证其性质。为清晰起见，省略了时间依赖性，并使用 $\\phi(\\mathbf{x})$ 表示 $\\phi(\\mathbf{x},0)$。\n\n**1. 构造符号距离函数 $\\phi(\\mathbf{x})$**\n\n根据定义，到界面 $\\Gamma$ 的符号距离函数 $\\phi(\\mathbf{x})$ 提供了从点 $\\mathbf{x}$ 到 $\\Gamma$ 的最短欧几里得距离，其符号由点 $\\mathbf{x}$ 是在 $\\Gamma$ 所包围区域的内部还是外部决定。\n从点 $\\mathbf{x}$ 到集合 $\\Gamma$ 的距离由 $\\text{dist}(\\mathbf{x}, \\Gamma) = \\inf_{\\mathbf{p} \\in \\Gamma} \\|\\mathbf{x} - \\mathbf{p}\\|$ 给出，其中 $\\|\\cdot\\|$ 表示欧几里得范数。\n\n在本问题中， $t=0$ 时的界面 $\\Gamma$ 是一个以原点为中心、半径为 $R$ 的圆，由满足 $\\|\\mathbf{p}\\| = R$ 的点集 $\\mathbf{p}$ 描述。对于任意点 $\\mathbf{x} \\in \\mathbb{R}^{2}$，圆上离 $\\mathbf{x}$ 最近的点 $\\mathbf{p}^*$ 位于连接原点和 $\\mathbf{x}$ 的线段上。对于 $\\mathbf{x} \\neq \\mathbf{0}$，这个最近点由 $\\mathbf{x}$ 在圆上的投影给出，即 $\\mathbf{p}^* = R \\frac{\\mathbf{x}}{\\|\\mathbf{x}\\|}$。\n\n从 $\\mathbf{x}$ 到 $\\Gamma$ 的距离则为：\n$$ \\text{dist}(\\mathbf{x}, \\Gamma) = \\|\\mathbf{x} - \\mathbf{p}^*\\| = \\left\\| \\mathbf{x} - R \\frac{\\mathbf{x}}{\\|\\mathbf{x}\\|} \\right\\| = \\left\\| \\left(1 - \\frac{R}{\\|\\mathbf{x}\\|}\\right) \\mathbf{x} \\right\\| $$\n$$ = \\left| 1 - \\frac{R}{\\|\\mathbf{x}\\|} \\right| \\|\\mathbf{x}\\| = \\left| \\frac{\\|\\mathbf{x}\\| - R}{\\|\\mathbf{x}\\|} \\right| \\|\\mathbf{x}\\| = |\\|\\mathbf{x}\\| - R| $$\n这给出了无符号距离。现在，我们应用符号约定：圆内 $\\phi(\\mathbf{x})  0$，圆外 $\\phi(\\mathbf{x}) > 0$。\n-   若 $\\mathbf{x}$ 在圆内，则 $\\|\\mathbf{x}\\|  R$，所以 $\\|\\mathbf{x}\\| - R  0$。这与要求的符号相符。\n-   若 $\\mathbf{x}$ 在圆外，则 $\\|\\mathbf{x}\\| > R$，所以 $\\|\\mathbf{x}\\| - R > 0$。这也与要求的符号相符。\n-   若 $\\mathbf{x}$ 在圆上，则 $\\|\\mathbf{x}\\| = R$，所以 $\\|\\mathbf{x}\\| - R = 0$。这正确地标识了界面。\n\n因此，符号距离函数为 $\\phi(\\mathbf{x}) = \\|\\mathbf{x}\\| - R$。在笛卡尔坐标系 $\\mathbf{x}=(x,y)$ 中，这表示为：\n$$ \\phi(x,y) = \\sqrt{x^{2} + y^{2}} - R $$\n\n**2. 符号距离性质 $|\\nabla \\phi|=1$ 的验证**\n\n我们计算 $\\phi(x,y) = (x^{2} + y^{2})^{1/2} - R$ 关于 $\\mathbf{x}=(x,y)$ 的梯度。\n关于 $x$ 的偏导数为：\n$$ \\frac{\\partial \\phi}{\\partial x} = \\frac{\\partial}{\\partial x} \\left((x^{2} + y^{2})^{1/2} - R\\right) = \\frac{1}{2}(x^{2} + y^{2})^{-1/2} (2x) = \\frac{x}{\\sqrt{x^{2} + y^{2}}} $$\n关于 $y$ 的偏导数为：\n$$ \\frac{\\partial \\phi}{\\partial y} = \\frac{\\partial}{\\partial y} \\left((x^{2} + y^{2})^{1/2} - R\\right) = \\frac{1}{2}(x^{2} + y^{2})^{-1/2} (2y) = \\frac{y}{\\sqrt{x^{2} + y^{2}}} $$\n这些表达式对于所有 $(x,y) \\neq (0,0)$，即对于所有 $\\mathbf{x} \\neq \\mathbf{0}$ 都是良定义的。\n梯度向量为 $\\nabla \\phi = \\left( \\frac{x}{\\sqrt{x^{2}+y^{2}}}, \\frac{y}{\\sqrt{x^{2}+y^{2}}} \\right) = \\frac{(x,y)}{\\sqrt{x^{2}+y^{2}}} = \\frac{\\mathbf{x}}{\\|\\mathbf{x}\\|}$。\n\n现在，我们计算梯度的模 $\\|\\nabla \\phi\\|$：\n$$ \\|\\nabla \\phi\\| = \\sqrt{\\left(\\frac{\\partial \\phi}{\\partial x}\\right)^{2} + \\left(\\frac{\\partial \\phi}{\\partial y}\\right)^{2}} = \\sqrt{\\left(\\frac{x}{\\sqrt{x^{2}+y^{2}}}\\right)^{2} + \\left(\\frac{y}{\\sqrt{x^{2}+y^{2}}}\\right)^{2}} $$\n$$ = \\sqrt{\\frac{x^{2}}{x^{2}+y^{2}} + \\frac{y^{2}}{x^{2}+y^{2}}} = \\sqrt{\\frac{x^{2}+y^{2}}{x^{2}+y^{2}}} = \\sqrt{1} = 1 $$\n这对所有 $\\mathbf{x} \\neq \\mathbf{0}$ 都成立，从而验证了符号距离性质，也称为程函方程。\n\n**3. 不可微点**\n\n函数 $\\phi(x,y) = \\sqrt{x^{2}+y^{2}} - R$ 是由欧几里得范数函数和一个常数组成的。欧几里得范数 $\\|\\mathbf{x}\\| = \\sqrt{x^{2}+y^{2}}$ 在原点 $\\mathbf{x}=\\mathbf{0}$ 处不可微。偏导数 $\\frac{\\partial \\phi}{\\partial x} = x/\\|\\mathbf{x}\\|$ 和 $\\frac{\\partial \\phi}{\\partial y} = y/\\|\\mathbf{x}\\|$ 在 $(x,y)=(0,0)$ 处未定义，因为它们的分母为零。该函数在原点有一个锥形奇点。由于给定 $R>0$，原点是圆内的一点。因此，$\\phi(\\mathbf{x},0)$ 在 $\\mathbf{x}=\\mathbf{0}$ 处不可微。\n\n**4. 法向量的确认**\n\n到界面 $\\Gamma$ 的外向单位法向量 $\\mathbf{n}$ 可以从水平集函数计算得出，即 $\\mathbf{n} = \\frac{\\nabla \\phi}{\\|\\nabla \\phi\\|}$。我们在 $\\Gamma$ 上计算此式，其中 $\\|\\mathbf{x}\\| = R$。\n在 $\\Gamma$ 上，由于 $R>0$，我们有 $\\mathbf{x} \\neq \\mathbf{0}$，所以梯度是良定义的。\n$$ \\mathbf{n}|_{\\Gamma} = \\frac{\\nabla \\phi}{\\|\\nabla \\phi\\|} \\bigg|_{\\|\\mathbf{x}\\|=R} = \\frac{\\mathbf{x}/\\|\\mathbf{x}\\|}{1} \\bigg|_{\\|\\mathbf{x}\\|=R} = \\frac{\\mathbf{x}}{R} $$\n对于以原点为中心、半径为 $R$ 的圆，在其圆周上一点 $\\mathbf{x}$ 的几何外向单位法向量，是指向从中心到 $\\mathbf{x}$ 的向量，并归一化为单位长度。这由 $\\frac{\\mathbf{x}}{\\|\\mathbf{x}\\|}$ 给出，对于圆上的点，它等于 $\\frac{\\mathbf{x}}{R}$。方向是向外的，这与符号约定（即 $\\phi$ 从圆内部的负值增加到外部的正值，且梯度指向 $\\phi$ 增大的方向）一致。因此，该计算与几何法线一致。\n\n问题的首要要求是提供 $\\phi(\\mathbf{x},0)$ 的显式解析表达式。\n根据第一部分的推导，这个表达式是 $\\sqrt{x^{2} + y^{2}} - R$。",
            "answer": "$$\n\\boxed{\\sqrt{x^{2} + y^{2}} - R}\n$$"
        },
        {
            "introduction": "一旦定义了界面，其演化就由平流方程 $\\partial_t \\phi + \\mathbf{u}\\cdot\\nabla \\phi = 0$ 控制。确保您的数值求解器能准确求解这个核心方程，是构建可靠模拟工具的首要且最关键的步骤。本实践介绍了制造解方法（Method of Manufactured Solutions, MMS），这是一种严格的代码验证技术。通过将您的数值结果与已知的精确解析解进行比较，您可以精确地量化求解器的误差，并确认其是否达到了预期的收敛阶数。",
            "id": "4092620",
            "problem": "考虑在一个周期性方形区域内，一个水平集函数的二维平流。水平集函数 $\\phi(x,y,t)$ 由一个恒定速度场 $\\mathbf{u}=(u_x,u_y)$ 输运，其过程遵循平流方程\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\mathbf{u}\\cdot\\nabla \\phi = 0,\n$$\n该区域为 $[0,1]\\times[0,1]$，具有周期性边界条件，并定义一个光滑人造解为\n$$\n\\phi(x,y,t) = \\sin\\left(2\\pi\\left(x - u_x t\\right)\\right) + \\cos\\left(2\\pi\\left(y - u_y t\\right)\\right).\n$$\n此选择与一个无散度的恒定速度场相一致，并且在周期性边界条件下对所有 $t\\ge 0$ 都满足平流方程。本问题中的所有量都是无量纲的，因此不需要物理单位。\n\n你的任务是通过人造解方法（MMS）研究，来验证针对平流方程的两种数值离散化方法的精度阶。使用大小为 $N\\times N$ 的均匀、以单元为中心的笛卡尔网格，其中 $N\\in\\{32,64,128\\}$，区域为 $[0,1]\\times[0,1]$，并采用周期性环绕索引。实现以下两种离散化方法：\n- 一阶迎风空间离散结合前向欧拉时间步进。\n- 二阶 Strang 时间分裂，其中每个分裂子步在相应的坐标方向上应用一维二阶 Lax–Wendroff 更新。\n\n对于这两种方法，选择时间步长 $\\Delta t$ 以满足 Courant–Friedrichs–Lewy (CFL) 条件，使用一个指定的 CFL 数 $c$，由下式给出\n$$\n\\Delta t = c \\cdot \\min\\left(\\frac{\\Delta x}{|u_x|}, \\frac{\\Delta y}{|u_y|}\\right),\n$$\n其中 $\\Delta x=\\Delta y=1/N$，并将除以零的操作解释为 $+\\infty$，这样速度为零的方向就不会限制时间步长。通过使用整数个均匀步长 $N_t$ 来精确地积分到指定的最终时间 $T$，使得 $N_t \\Delta t = T$（使用 $\\Delta t = T/N_t$，其中 $N_t=\\lceil T/(\\text{CFL-limited }\\Delta t)\\rceil$）。\n\n将大小为 $N\\times N$ 的网格在时间 $T$ 的离散 $\\ell^2$ 误差定义为\n$$\nE_N = \\left(\\sum_{i=1}^N \\sum_{j=1}^N \\left(\\phi_{i,j}^{\\text{num}}(T) - \\phi_{i,j}^{\\text{exact}}(T)\\right)^2 \\Delta x \\Delta y\\right)^{1/2},\n$$\n其中 $\\phi_{i,j}^{\\text{exact}}(T)$ 是在单元中心 $(x_i,y_j)$ 和时间 $T$ 处计算的人造解，而 $\\phi_{i,j}^{\\text{num}}(T)$ 是数值解。通过下式估计连续网格加密之间的观测精度阶\n$$\np = \\frac{\\log\\left(E_{N}/E_{2N}\\right)}{\\log(2)}.\n$$\n对于每个测试用例，报告每个方案在 $N=64$ 和 $N=128$ 之间计算得出的一个观测阶。\n\n实现你的程序来评估以下参数值测试套件 $(u_x,u_y,T,c)$：\n- 用例 1：$(0.7,-0.4,0.2,0.5)$\n- 用例 2：$(0.0,0.8,0.25,0.5)$\n- 用例 3：$(0.95,0.0,0.15,0.5)$\n\n你的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序如下\n$$\n\\left[p_{\\text{upwind}}^{(1)},p_{\\text{LW}}^{(1)},p_{\\text{upwind}}^{(2)},p_{\\text{LW}}^{(2)},p_{\\text{upwind}}^{(3)},p_{\\text{LW}}^{(3)}\\right],\n$$\n其中 $p_{\\text{upwind}}^{(k)}$ 和 $p_{\\text{LW}}^{(k)}$ 分别是在测试用例 $k\\in\\{1,2,3\\}$ 中，一阶迎风方案和二阶 Lax–Wendroff Strang 分裂方案的观测阶。将每个报告值表示为十进制浮点数。将每个值四舍五入到三位小数。",
            "solution": "水平集方法通过一个标量函数 $\\phi(x,y,t)$ 来表示界面，该函数的零水平集定义了界面。$\\phi$ 由给定的速度场 $\\mathbf{u}(x,y,t)$ 输运的过程由平流方程控制\n$$\n\\frac{D\\phi}{Dt} = \\frac{\\partial \\phi}{\\partial t} + \\mathbf{u}\\cdot\\nabla \\phi = 0,\n$$\n这是沿流动的物质导数定义以及水平集在没有源或汇的情况下被被动平流这一假设的直接结果。在计算复杂流体中，对 $\\phi$ 的精确平流对于捕捉移动的界面和锋面至关重要。\n\n为了验证数值精度，人造解方法（MMS）选择一个在指定边界条件下满足偏微分方程（PDE）的光滑函数。这里，我们取\n$$\n\\phi(x,y,t) = \\sin\\left(2\\pi\\left(x - u_x t\\right)\\right) + \\cos\\left(2\\pi\\left(y - u_y t\\right)\\right),\n$$\n具有恒定速度 $u_x$ 和 $u_y$。这满足平流方程，因为\n$$\n\\frac{\\partial}{\\partial t}\\sin\\left(2\\pi(x-u_x t)\\right) = -2\\pi u_x \\cos\\left(2\\pi(x-u_x t)\\right),\n$$\n且\n$$\n\\frac{\\partial}{\\partial x}\\sin\\left(2\\pi(x-u_x t)\\right) = 2\\pi \\cos\\left(2\\pi(x-u_x t)\\right),\n$$\n因此\n$$\n\\frac{\\partial}{\\partial t}\\sin\\left(2\\pi(x-u_x t)\\right) + u_x \\frac{\\partial}{\\partial x}\\sin\\left(2\\pi(x-u_x t)\\right) = 0.\n$$\n类似地，\n$$\n\\frac{\\partial}{\\partial t}\\cos\\left(2\\pi(y-u_y t)\\right) = 2\\pi u_y \\sin\\left(2\\pi(y-u_y t)\\right),\n$$\n且\n$$\n\\frac{\\partial}{\\partial y}\\cos\\left(2\\pi(y-u_y t)\\right) = -2\\pi \\sin\\left(2\\pi(y-u_y t)\\right),\n$$\n所以\n$$\n\\frac{\\partial}{\\partial t}\\cos\\left(2\\pi(y-u_y t)\\right) + u_y \\frac{\\partial}{\\partial y}\\cos\\left(2\\pi(y-u_y t)\\right) = 0.\n$$\n根据线性性质，它们的和满足该偏微分方程。在 $[0,1]\\times[0,1]$上选择周期性边界条件是兼容的，因为三角函数在边界处匹配。\n\n我们现在概述这些离散化方法及其推导过程。\n\n一阶迎风法与前向欧拉法：\n我们根据速度分量的符号，使用与特征线方向一致的单边差分来离散化空间导数。设网格是均匀的，单元中心为 $(x_i,y_j)$，其中 $i,j\\in\\{0,\\ldots,N-1\\}$，间距 $\\Delta x=\\Delta y=1/N$，并采用周期性索引。定义 $x$ 方向的一维迎风导数为\n$$\nD_x^{\\text{up}} \\phi_{i,j} = \n\\begin{cases}\n\\frac{\\phi_{i,j} - \\phi_{i-1,j}}{\\Delta x},  u_x > 0, \\\\\n\\frac{\\phi_{i+1,j} - \\phi_{i,j}}{\\Delta x},  u_x  0, \\\\\n0,  u_x = 0,\n\\end{cases}\n$$\n类似地，在 $y$ 方向上，\n$$\nD_y^{\\text{up}} \\phi_{i,j} = \n\\begin{cases}\n\\frac{\\phi_{i,j} - \\phi_{i,j-1}}{\\Delta y},  u_y > 0, \\\\\n\\frac{\\phi_{i,j+1} - \\phi_{i,j}}{\\Delta y},  u_y  0, \\\\\n0,  u_y = 0.\n\\end{cases}\n$$\n对于半离散系统\n$$\n\\frac{d\\phi_{i,j}}{dt} = -u_x D_x^{\\text{up}} \\phi_{i,j} - u_y D_y^{\\text{up}} \\phi_{i,j}\n$$\n的前向欧拉时间更新为\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^{n} - \\Delta t\\left(u_x D_x^{\\text{up}} \\phi_{i,j}^{n} + u_y D_y^{\\text{up}} \\phi_{i,j}^{n}\\right).\n$$\n在周期性边界下，该方案在空间和时间上是一阶精度的，并且对于小于或等于 $1$ 的 Courant–Friedrichs–Lewy (CFL) 数是稳定的。\n\n二阶 Strang 分裂与一维 Lax–Wendroff 法：\n针对 $x$ 方向的恒定速度 $u$ 的一维 Lax–Wendroff 方案由泰勒展开得到，\n$$\n\\phi^{n+1} = \\phi^n + \\Delta t \\frac{\\partial \\phi}{\\partial t} + \\frac{\\Delta t^2}{2} \\frac{\\partial^2 \\phi}{\\partial t^2},\n$$\n以及偏微分方程关系 $\\frac{\\partial \\phi}{\\partial t} = -u \\frac{\\partial \\phi}{\\partial x}$ 和 $\\frac{\\partial^2 \\phi}{\\partial t^2} = u^2 \\frac{\\partial^2 \\phi}{\\partial x^2}$。使用中心差分进行离散化可得\n$$\n\\phi_{i}^{n+1} = \\phi_{i}^{n} - \\frac{u \\Delta t}{2 \\Delta x}\\left(\\phi_{i+1}^{n} - \\phi_{i-1}^{n}\\right) + \\frac{u^2 \\Delta t^2}{2 \\Delta x^2}\\left(\\phi_{i+1}^{n} - 2\\phi_{i}^{n} + \\phi_{i-1}^{n}\\right),\n$$\n采用周期性索引。在具有恒定速度的二维情况下，可以通过 Strang 分裂构建一个时间上二阶精度的方案：使用一维 Lax–Wendroff 在 $x$ 方向上应用一个半步，然后使用一维 Lax–Wendroff 沿着列在 $y$ 方向上应用一个完整步，最后再在 $x$ 方向上应用另一个半步。这种分裂在时间上是二阶精度的，并且每个子步在空间上保持二阶精度。\n\n时间步长选择：\n我们使用 CFL 数 $c$ 选择 $\\Delta t$，如下所示\n$$\n\\Delta t = c \\cdot \\min\\left(\\frac{\\Delta x}{|u_x|}, \\frac{\\Delta y}{|u_y|}\\right),\n$$\n其中除以零的操作被解释为 $+\\infty$，因此速度分量为零不会限制 $\\Delta t$。为了精确达到最终时间 $T$，我们定义 $N_t = \\left\\lceil T/\\Delta t \\right\\rceil$，然后使用 $\\Delta t = T/N_t$。\n\n误差测量与观测阶：\n离散 $\\ell^2$ 误差为\n$$\nE_N = \\left(\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1}\\left(\\phi_{i,j}^{\\text{num}}(T) - \\phi_{i,j}^{\\text{exact}}(T)\\right)^2 \\Delta x \\Delta y\\right)^{1/2}.\n$$\n对于一个 $p$ 阶相容的方案，我们预期 $E_N \\sim C (\\Delta x)^p$，因此连续网格之间的观测阶为\n$$\np = \\frac{\\log\\left(E_N/E_{2N}\\right)}{\\log(2)}.\n$$\n我们在每个测试用例中，都对两种方案计算 $N=64$ 和 $N=128$ 之间的这个值。\n\n算法设计：\n- 在单元中心 $x_i=(i+0.5)\\Delta x$，$y_j=(j+0.5)\\Delta y$ 处初始化网格，并设置 $\\phi_{i,j}^{0} = \\sin(2\\pi x_i) + \\cos(2\\pi y_j)$，这是 $t=0$ 时的人造解。\n- 对于每个网格尺寸 $N\\in\\{32,64,128\\}$，计算 $\\Delta x$ 和 $\\Delta y$，使用给定的 $c$、$u_x$ 和 $u_y$ 构建时间步长 $\\Delta t$，并使用一阶迎风前向欧拉方案或二阶 Strang 分裂 Lax–Wendroff 方案积分到时间 $T$。\n- 计算在时间 $T$ 的精确解 $\\phi_{i,j}^{\\text{exact}}(T) = \\sin(2\\pi(x_i - u_x T)) + \\cos(2\\pi(y_j - u_y T))$，并计算 $E_N$。\n- 对于每个方案和每个测试用例，使用两个最精细的网格（$N=64$ 和 $N=128$）计算观测阶 $p$。\n- 将每个 $p$ 四舍五入到三位小数，并以要求的单行格式打印结果。\n\n预期行为：\n- 一阶迎风法应得出接近 $1$ 的 $p$ 值。\n- 二阶 Strang 分裂 Lax–Wendroff 方法应得出接近 $2$ 的 $p$ 值。\n由于有限时间积分、分裂误差以及空间和时间离散化的相互作用，预期会与理想值存在微小偏差。\n\n程序实现了这些步骤，并为指定的测试套件生成所要求的观测阶列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef manufactured_phi(x, y, ux, uy, t):\n    return np.sin(2.0 * np.pi * (x - ux * t)) + np.cos(2.0 * np.pi * (y - uy * t))\n\ndef upwind_step(phi, ux, uy, dx, dy, dt):\n    # Periodic rolls\n    phi_ip1 = np.roll(phi, -1, axis=0)\n    phi_im1 = np.roll(phi, 1, axis=0)\n    phi_jp1 = np.roll(phi, -1, axis=1)\n    phi_jm1 = np.roll(phi, 1, axis=1)\n\n    # Upwind derivatives in x\n    if ux > 0.0:\n        dphidx = (phi - phi_im1) / dx\n    elif ux  0.0:\n        dphidx = (phi_ip1 - phi) / dx\n    else:\n        dphidx = 0.0 * phi\n\n    # Upwind derivatives in y\n    if uy > 0.0:\n        dphidy = (phi - phi_jm1) / dy\n    elif uy  0.0:\n        dphidy = (phi_jp1 - phi) / dy\n    else:\n        dphidy = 0.0 * phi\n\n    return phi - dt * (ux * dphidx + uy * dphidy)\n\ndef lax_wendroff_1d_x(phi, ux, dx, dt):\n    # 1D LW along x for each row\n    phi_ip1 = np.roll(phi, -1, axis=0)\n    phi_im1 = np.roll(phi, 1, axis=0)\n    c1 = - (ux * dt) / (2.0 * dx)\n    c2 = (ux * ux * dt * dt) / (2.0 * dx * dx)\n    return phi + c1 * (phi_ip1 - phi_im1) + c2 * (phi_ip1 - 2.0 * phi + phi_im1)\n\ndef lax_wendroff_1d_y(phi, uy, dy, dt):\n    # 1D LW along y for each column\n    phi_jp1 = np.roll(phi, -1, axis=1)\n    phi_jm1 = np.roll(phi, 1, axis=1)\n    c1 = - (uy * dt) / (2.0 * dy)\n    c2 = (uy * uy * dt * dt) / (2.0 * dy * dy)\n    return phi + c1 * (phi_jp1 - phi_jm1) + c2 * (phi_jp1 - 2.0 * phi + phi_jm1)\n\ndef strang_lw_step(phi, ux, uy, dx, dy, dt):\n    # Strang splitting: x half-step, y full-step, x half-step\n    if abs(ux) > 0.0:\n        phi = lax_wendroff_1d_x(phi, ux, dx, 0.5 * dt)\n    if abs(uy) > 0.0:\n        phi = lax_wendroff_1d_y(phi, uy, dy, dt)\n    if abs(ux) > 0.0:\n        phi = lax_wendroff_1d_x(phi, ux, dx, 0.5 * dt)\n    return phi\n\ndef compute_error(N, ux, uy, T, cfl, scheme='upwind'):\n    # Grid\n    dx = 1.0 / N\n    dy = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    y = (np.arange(N) + 0.5) * dy\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Initial condition at t=0\n    phi = manufactured_phi(X, Y, ux, uy, 0.0)\n\n    # Compute time step from CFL\n    # Handle zero velocities: do not constrain dt\n    inv_dt_x = abs(ux) / dx if abs(ux) > 0.0 else 0.0\n    inv_dt_y = abs(uy) / dy if abs(uy) > 0.0 else 0.0\n    dt_cfl = cfl / max(inv_dt_x, inv_dt_y, 1e-16) if (inv_dt_x > 0.0 or inv_dt_y > 0.0) else T\n    # Choose integer number of steps to hit T\n    Nt = max(1, int(np.ceil(T / dt_cfl)))\n    dt = T / Nt\n\n    # Time integration\n    for _ in range(Nt):\n        if scheme == 'upwind':\n            phi = upwind_step(phi, ux, uy, dx, dy, dt)\n        elif scheme == 'lw2':\n            phi = strang_lw_step(phi, ux, uy, dx, dy, dt)\n        else:\n            raise ValueError(\"Unknown scheme\")\n\n    # Exact solution at final time\n    phi_exact = manufactured_phi(X, Y, ux, uy, T)\n    # L2 error (discrete)\n    err = np.sqrt(np.sum((phi - phi_exact) ** 2) * dx * dy)\n    return err\n\ndef observed_order(errors):\n    # errors: dict {N: E_N}, compute between N and 2N for finest available pair\n    Ns = sorted(errors.keys())\n    orders = {}\n    for i in range(len(Ns) - 1):\n        N = Ns[i]\n        N2 = Ns[i + 1]\n        if N2 == 2 * N:\n            EN = errors[N]\n            E2N = errors[N2]\n            if EN > 0 and E2N > 0:\n                p = np.log(EN / E2N) / np.log(2.0)\n            else:\n                p = float('nan')\n            orders[(N, N2)] = p\n    return orders\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (ux, uy, T, cfl)\n    test_cases = [\n        (0.7, -0.4, 0.2, 0.5),\n        (0.0, 0.8, 0.25, 0.5),\n        (0.95, 0.0, 0.15, 0.5),\n    ]\n\n    # Grid sizes\n    Ns = [32, 64, 128]\n\n    results = []\n    for ux, uy, T, cfl in test_cases:\n        # Compute errors for upwind\n        errors_upwind = {}\n        errors_lw2 = {}\n        for N in Ns:\n            e_up = compute_error(N, ux, uy, T, cfl, scheme='upwind')\n            e_lw = compute_error(N, ux, uy, T, cfl, scheme='lw2')\n            errors_upwind[N] = e_up\n            errors_lw2[N] = e_lw\n        # Observed order between 64 and 128\n        p_up = np.log(errors_upwind[64] / errors_upwind[128]) / np.log(2.0)\n        p_lw = np.log(errors_lw2[64] / errors_lw2[128]) / np.log(2.0)\n        results.append(f\"{p_up:.3f}\")\n        results.append(f\"{p_lw:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "水平集方法的一个主要应用是模拟表面张力起主导作用的多相流。在理想情况下，一个静态液滴应保持完全静止，其界面两侧的压力跳变根据杨-拉普拉斯（Young-Laplace）定律与表面张力相平衡。然而，数值离散化往往会打破这种微妙的平衡，导致非物理的“伪电流”（spurious currents）。这项高级实践要求您设计一个数值实验来研究这一关键的数值产物，从而深入了解物理模型及数值实现之间复杂的相互作用。",
            "id": "4092627",
            "problem": "考虑一个二维、不可压缩的牛顿流体，其中包含一个处于力学平衡状态的单个圆形液滴。该液滴占据一个边长为 $L$ 的方形周期性域中，以 $(x_0,y_0)$ 为中心、半径为 $R$ 的圆形内部。界面由一个水平集函数 $\\phi(x,y)$ 表示，该函数是到界面的有符号距离，液滴内部为负，外部为正。表面张力系数是常数，等于 $\\sigma$，动力粘度为 $\\mu$，密度为 $\\rho$。压力场在液滴内外是分段常数，法向应力的跳跃由毛细作用平衡。从不可压缩性、动量平衡和毛细应力平衡的连续介质定义出发，推导精确的平衡压力场，并解释在何种假设下，它简化为一个与界面曲率和表面张力成正比的压力跳跃。然后，设计并实施一个使用水平集公式的数值实验，以量化在没有任何外力作用的情况下，由离散化误差引起的伪电流（非零速度）。\n\n仅使用以下基本依据：\n- 不可压缩牛顿流体的Navier–Stokes方程：$\\rho\\,\\partial_t \\boldsymbol{u} + \\rho\\,(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} = -\\nabla p + \\mu \\nabla^2 \\boldsymbol{u} + \\boldsymbol{f}$ 和 $\\nabla\\cdot\\boldsymbol{u} = 0$。\n- 光滑界面处的毛细应力平衡：法向应力的跳跃与界面曲率和表面张力成正比。\n- 水平集方法对曲率 $\\kappa$ 和单位法向量 $\\boldsymbol{n}$ 的定义：$\\boldsymbol{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$ 和 $\\kappa = \\nabla \\cdot \\boldsymbol{n}$。\n\n科学真实性要求：\n- 在二维空间中工作，以便圆的平衡曲率为 $\\kappa = 1/R$。\n- 假设液滴是静态的，因此物理速度场在平衡时为零场，压力场为分段常数，并具有界面跳跃。\n- 使用正则化狄拉克δ函数将毛细作用力分布在一个与网格间距成比例的有限厚度上。\n\n数值实验规格：\n- 使用具有 $N \\times N$ 个点和间距 $h = L/N$ 的均匀网格对方形周期性域 $[0,L]\\times[0,L]$ 进行离散化。\n- 在网格上定义水平集场 $\\phi(x,y) = \\sqrt{(x-x_0)^2 + (y-y_0)^2} - R$。\n- 使用带周期性边界条件的中心有限差分计算单位法向量 $\\boldsymbol{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$ 和曲率 $\\kappa = \\nabla \\cdot \\boldsymbol{n}$。\n- 使用在 $|\\phi| \\le \\epsilon$ 上有支撑的正则化狄拉克δ函数 $\\delta_\\epsilon(\\phi)$，其中 $\\epsilon = \\alpha h$，$\\alpha$ 是一个正常数，例如当 $|\\phi| \\le \\epsilon$ 时，$\\delta_\\epsilon(\\phi) = \\frac{1}{2\\epsilon}\\left(1+\\cos\\left(\\pi \\phi/\\epsilon\\right)\\right)$，否则为 $0$。\n- 构建连续表面力密度 $\\boldsymbol{f}_{\\sigma} = \\sigma\\,\\kappa\\,\\delta_\\epsilon(\\phi)\\,\\boldsymbol{n}$。\n- 在 $\\boldsymbol{f}_{\\sigma}$ 的作用下，从静止状态前进一个显式时间步 $\\Delta t$，然后使用周期性快速傅里叶变换 (FFT) 执行不可压缩投影，以强制 $\\nabla\\cdot \\boldsymbol{u}^{n+1} = 0$。具体来说，计算中间速度 $\\boldsymbol{u}^* = \\boldsymbol{0} + (\\Delta t/\\rho)\\,\\boldsymbol{f}_{\\sigma}$，然后求解压力增量的泊松方程，以将 $\\boldsymbol{u}^*$ 投影到无散场上。\n- 通过计算投影后的最大速度 $\\max_{x,y}\\lVert \\boldsymbol{u}^{n+1}(x,y)\\rVert$ 来测量伪电流。\n\n物理和数值单位：\n- 压力以帕斯卡 (Pa) 表示，速度以米/秒 (m/s) 表示。\n- 任何三角函数求值均使用弧度。\n- 以科学记数法的小数形式报告伪电流的大小，单位为米/秒 (m/s)。\n\n测试套件：\n- 固定 $L = 1\\,\\mathrm{m}$，$(x_0,y_0) = (L/2,L/2)$，$R = 0.25\\,\\mathrm{m}$，$\\rho = 1000\\,\\mathrm{kg/m^3}$，$\\mu = 1\\,\\mathrm{Pa\\cdot s}$，$\\sigma = 0.072\\,\\mathrm{N/m}$，$\\Delta t = 10^{-5}\\,\\mathrm{s}$，以及 $\\alpha = 1.5$。\n- 定义四种网格分辨率 $N \\in \\{16, 32, 64, 128\\}$，以评估分辨率对伪电流的影响。\n- 包括一个 $N = 64$ 和 $\\sigma = 0$ 的边缘案例，以验证当表面张力不存在时伪电流消失。\n- 因此，参数集为：\n  - 案例 1：$N = 16$，$\\sigma = 0.072\\,\\mathrm{N/m}$。\n  - 案例 2：$N = 32$，$\\sigma = 0.072\\,\\mathrm{N/m}$。\n  - 案例 3：$N = 64$，$\\sigma = 0.072\\,\\mathrm{N/m}$。\n  - 案例 4：$N = 128$，$\\sigma = 0.072\\,\\mathrm{N/m}$。\n  - 案例 5：$N = 64$，$\\sigma = 0\\,\\mathrm{N/m}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个浮点值均以具有六位有效数字的科学记数法格式化，并按照上述五个案例的顺序排列；例如，“[a1,a2,a3,a4,a5]”。",
            "solution": "该问题陈述被评估为有效。其科学基础是连续介质力学和计算流体动力学的原理，特别是用于多相流的水平集方法。该问题是适定的、客观的、自包含的，并描述了一个用于量化伪电流的标准、非平凡的数值基准。所有必需的物理和数值参数都已提供，方法论的详细程度足以得出一个唯一且可验证的解。\n\n### 第一部分：平衡压力场的理论推导\n\n我们从不可压缩牛顿流体在力学平衡状态下的基本方程开始。在平衡时，速度场 $\\boldsymbol{u}$ 恒为零，即 $\\boldsymbol{u} = \\boldsymbol{0}$，并且所有时间导数都消失，即 $\\partial_t(\\cdot) = 0$。\n\n不可压缩的Navier-Stokes动量方程如下：\n$$\n\\rho\\,\\partial_t \\boldsymbol{u} + \\rho\\,(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} = -\\nabla p + \\mu \\nabla^2 \\boldsymbol{u} + \\boldsymbol{f}\n$$\n在平衡条件下（$\\boldsymbol{u} = \\boldsymbol{0}$），惯性项（$\\rho\\,\\partial_t \\boldsymbol{u}, \\rho\\,(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u}$）和粘性项（$\\mu \\nabla^2 \\boldsymbol{u}$）都为零。动量方程简化为压力梯度与体积力 $\\boldsymbol{f}$ 之间的平衡：\n$$\n\\boldsymbol{0} = -\\nabla p + \\boldsymbol{f}\n$$\n在这个问题中，作用在流体上的唯一力是表面张力，它被限制在液滴和周围流体之间的界面上。因此，$\\boldsymbol{f}$ 代表表面张力密度。远离界面，在体相流体中（液滴内部和外部），$\\boldsymbol{f} = \\boldsymbol{0}$。在这些区域，动量方程变为：\n$$\n\\nabla p = \\boldsymbol{0}\n$$\n这意味着压力 $p$ 在每个相内必须是空间常数。我们可以将液滴内部的压力表示为 $p_{in}$，外部的压力表示为 $p_{out}$。因此，压力场是分段常数。\n\n跨界面的压力跳跃由毛细应力平衡决定。不可压缩牛顿流体的应力张量 $\\boldsymbol{T}$ 为：\n$$\n\\boldsymbol{T} = -p\\boldsymbol{I} + \\mu(\\nabla \\boldsymbol{u} + (\\nabla \\boldsymbol{u})^T)\n$$\n其中 $\\boldsymbol{I}$ 是单位张量。在平衡时，由于 $\\boldsymbol{u}=\\boldsymbol{0}$，粘性应力分量消失，应力张量简化为各向同性压力：\n$$\n\\boldsymbol{T} = -p\\boldsymbol{I}\n$$\n界面处的应力平衡条件规定，跨界面的法向牵引力跳跃由单位面积的表面张力平衡。设 $\\boldsymbol{n}$ 是从液滴内部指向外部的单位法向量。该条件是：\n$$\n[[\\boldsymbol{T} \\cdot \\boldsymbol{n}]] = \\sigma \\kappa \\boldsymbol{n}\n$$\n其中 $[[A]] = A_{out} - A_{in}$ 表示量 $A$ 跨界面的跳跃，$\\sigma$ 是表面张力系数，$\\kappa$ 是界面的局部曲率。\n\n我们计算应力牵引力的跳跃：\n$$\n[[\\boldsymbol{T} \\cdot \\boldsymbol{n}]] = (\\boldsymbol{T}_{out} \\cdot \\boldsymbol{n}) - (\\boldsymbol{T}_{in} \\cdot \\boldsymbol{n}) = (-p_{out}\\boldsymbol{I} \\cdot \\boldsymbol{n}) - (-p_{in}\\boldsymbol{I} \\cdot \\boldsymbol{n}) = (-p_{out}\\boldsymbol{n}) - (-p_{in}\\boldsymbol{n}) = (p_{in} - p_{out})\\boldsymbol{n}\n$$\n将此代入平衡方程：\n$$\n(p_{in} - p_{out})\\boldsymbol{n} = \\sigma \\kappa \\boldsymbol{n}\n$$\n这就得到了著名的Young-Laplace方程，用于描述压力跳跃 $\\Delta p$：\n$$\n\\Delta p = p_{in} - p_{out} = \\sigma \\kappa\n$$\n对于半径为 $R$ 的二维圆形液滴的特定情况，界面上各处的曲率是恒定的，$\\kappa = 1/R$。因此，平衡压力跳跃为：\n$$\n\\Delta p = \\frac{\\sigma}{R}\n$$\n平衡压力场是分段常数，液滴内部 $p(x,y) = p_{in}$，外部 $p(x,y) = p_{out}$，满足 $p_{in} = p_{out} + \\sigma/R$。\n\n这种简化为与曲率和表面张力成正比的简单压力跳跃，取决于一个关键假设，即流体处于**力学平衡**状态（$\\boldsymbol{u}=\\boldsymbol{0}$）。如果流体在运动，粘性应力项 $\\mu(\\nabla \\boldsymbol{u} + (\\nabla \\boldsymbol{u})^T)$ 将不为零，界面处的应力平衡将包括速度梯度的贡献，从而导致更复杂的关系。\n\n### 第二部分：伪电流的数值实验\n\n在使用界面捕捉方法（如水平集方法）与连续表面力 (CSF) 模型相结合的多相流模拟中，伪电流是一个众所周知的数值伪影。从解析上看，平衡状态需要压力梯度与表面张力之间实现完美平衡，即 $\\nabla p = \\boldsymbol{f}_{\\sigma}$。在数值上，由于离散化误差，这种平衡很难完美实现。\n\nCSF模型将奇异的表面张力（仅存在于无限薄的界面上）近似为分布在界面周围窄带上的连续体积力。这是通过使用正则化的狄拉克δ函数 $\\delta_\\epsilon(\\phi)$ 实现的。用于梯度 ($\\nabla_h$)、散度 ($\\nabla_h \\cdot$) 和曲率 ($\\kappa_h$) 等几何属性计算的离散算子不能完美满足矢量微积分的恒等式。因此，离散压力梯度 $\\nabla_h p_h$ 不能精确抵消离散表面张力 $\\boldsymbol{f}_{\\sigma, h}$。这种不平衡产生了一个净残余力 $\\boldsymbol{f}_{residual} = \\boldsymbol{f}_{\\sigma, h} - \\nabla_h p_h \\neq \\boldsymbol{0}$，它驱动了被称为伪电流的非物理寄生流。\n\n该数值实验旨在量化这些电流。程序如下：\n\n1.  **初始化**：在周期性域 $[0,L]\\times[0,L]$ 上定义一个大小为 $N \\times N$ 的均匀笛卡尔网格。圆形液滴的界面由有符号距离函数 $\\phi(x,y) = \\sqrt{(x-x_0)^2 + (y-y_0)^2} - R$ 隐式定义，该函数在每个网格节点上求值。\n\n2.  **几何计算**：使用带周期性边界条件的二阶中心有限差分计算单位法向量 $\\boldsymbol{n} = \\nabla\\phi / \\lVert\\nabla\\phi\\rVert$ 和曲率 $\\kappa = \\nabla \\cdot \\boldsymbol{n}$。对分母 $\\lVert\\nabla\\phi\\rVert$ 应用一个小的正则化，以防止在远离界面（其值不需要）的地方发生除零错误。\n\n3.  **表面张力**：使用公式 $\\boldsymbol{f}_{\\sigma} = \\sigma \\kappa \\delta_\\epsilon(\\phi) \\boldsymbol{n}$ 计算CSF体积力密度 $\\boldsymbol{f}_{\\sigma}$。正则化的delta函数 $\\delta_\\epsilon(\\phi)$ 将力局域化在界面（$\\phi=0$）周围一个厚度为 $2\\epsilon$ 的区域内，其中 $\\epsilon = \\alpha h$。\n\n4.  **时间推进（预测步）**：从静止流体（$\\boldsymbol{u}^n = \\boldsymbol{0}$）开始，通过施加一个时间步 $\\Delta t$ 的表面张力，计算出中间速度场 $\\boldsymbol{u}^*$。根据问题描述，这个显式步骤是：\n    $$\n    \\boldsymbol{u}^* = \\boldsymbol{u}^n + \\frac{\\Delta t}{\\rho}\\boldsymbol{f}_{\\sigma} = \\frac{\\Delta t}{\\rho}\\boldsymbol{f}_{\\sigma}\n    $$\n    该场 $\\boldsymbol{u}^*$ 通常不满足不可压缩性约束 $\\nabla \\cdot \\boldsymbol{u}^*=0$。\n\n5.  **投影步**：使用投影法来强制不可压缩性。这涉及找到一个类压力的标量场 $\\psi$，使得最终速度 $\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^* - \\frac{\\Delta t}{\\rho}\\nabla\\psi$ 是无散的，即 $\\nabla \\cdot \\boldsymbol{u}^{n+1} = 0$。对更新方程取散度，得到一个关于 $\\psi$ 的泊松方程：\n    $$\n    \\nabla^2 \\psi = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\boldsymbol{u}^*\n    $$\n    对于周期性域，这个方程可以使用快速傅里叶变换（FFT）高效求解。该方程被转换到傅里叶空间，代数求解 $\\psi$ 的傅里叶系数，然后转换回实空间。然后计算梯度 $\\nabla\\psi$（在傅里叶空间中同样高效），并用它来校正中间速度，从而获得最终的无散速度场 $\\boldsymbol{u}^{n+1}$。\n\n6.  **测量**：通过计算速度范数的最大值 $\\max_{x,y} \\lVert\\boldsymbol{u}^{n+1}(x,y)\\rVert$ 来量化伪电流的大小，该值在整个计算域上计算。为每个测试案例报告此值。该实验研究了该大小如何随网格分辨率 $N$ 和表面张力系数 $\\sigma$ 变化。预期是，随着 $N$ 的增加（即网格被细化），伪电流将减小，并且当 $\\sigma = 0$ 时将为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spurious currents problem for a static droplet using a level-set method.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, sigma)\n        (16, 0.072),  # Case 1\n        (32, 0.072),  # Case 2\n        (64, 0.072),  # Case 3\n        (128, 0.072), # Case 4\n        (64, 0.0),    # Case 5\n    ]\n    \n    # Fixed physical and numerical parameters\n    L = 1.0          # m\n    x0, y0 = L / 2, L / 2 # m\n    R = 0.25         # m\n    rho = 1000.0     # kg/m^3\n    mu = 1.0         # Pa*s (given, but not used in the specified one-step algorithm)\n    dt = 1e-5        # s\n    alpha = 1.5      # dimensionless\n    \n    results = []\n\n    for N, sigma in test_cases:\n        # If sigma is zero, the force is zero, thus spurious currents are zero.\n        if sigma == 0:\n            results.append(f\"{0.0:.5e}\")\n            continue\n\n        # Grid setup\n        h = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        xx, yy = np.meshgrid(x, x, indexing='xy')\n\n        # Level-set function: signed distance to the circle\n        phi = np.sqrt((xx - x0)**2 + (yy - y0)**2) - R\n\n        # Helper function for periodic centered differences\n        def periodic_gradient_component(field, spacing, axis):\n            return (np.roll(field, -1, axis=axis) - np.roll(field, 1, axis=axis)) / (2 * spacing)\n\n        # Compute gradient of phi\n        grad_phi_x = periodic_gradient_component(phi, h, axis=1)\n        grad_phi_y = periodic_gradient_component(phi, h, axis=0)\n\n        # Compute norm of the gradient, with regularization to avoid division by zero\n        norm_grad_phi = np.sqrt(grad_phi_x**2 + grad_phi_y**2)\n        # The small epsilon is critical. The normal is only well-defined where grad(phi) != 0.\n        # Away from the interface, the force is zero anyway due to the delta function.\n        epsilon_denom = 1e-12 \n        norm_grad_phi[norm_grad_phi  epsilon_denom] = epsilon_denom\n\n        # Compute unit normal vector field\n        nx = grad_phi_x / norm_grad_phi\n        ny = grad_phi_y / norm_grad_phi\n\n        # Compute curvature kappa = div(n)\n        d_nx_dx = periodic_gradient_component(nx, h, axis=1)\n        d_ny_dy = periodic_gradient_component(ny, h, axis=0)\n        kappa = d_nx_dx + d_ny_dy\n\n        # Compute regularized Dirac delta function\n        epsilon_delta = alpha * h\n        delta = np.zeros_like(phi)\n        mask = np.abs(phi) = epsilon_delta\n        delta[mask] = (1 / (2 * epsilon_delta)) * (1 + np.cos(np.pi * phi[mask] / epsilon_delta))\n\n        # Compute Continuum Surface Force (CSF) density\n        fx = sigma * kappa * delta * nx\n        fy = sigma * kappa * delta * ny\n\n        # Predictor step: compute intermediate velocity u* from rest\n        u_star = (dt / rho) * fx\n        v_star = (dt / rho) * fy\n        \n        # Projection step using FFT\n        \n        # Wavenumbers for the Fourier transform\n        k_freq = np.fft.fftfreq(N, d=h) * 2 * np.pi\n        kx, ky = np.meshgrid(k_freq, k_freq, indexing='xy')\n        k_sq = kx**2 + ky**2\n\n        # FFT of intermediate velocity components\n        fft_u_star = np.fft.fft2(u_star)\n        fft_v_star = np.fft.fft2(v_star)\n\n        # FFT of divergence of u*\n        # div_u_star_hat = 1j * kx * fft_u_star + 1j * ky * fft_v_star\n        # The Poisson equation is nabla^2(psi) = (rho/dt) * div(u*).\n        # In Fourier space: -k_sq * psi_hat = (rho/dt) * div_u_star_hat\n        # So, psi_hat = - (rho/dt) * div_u_star_hat / k_sq\n        \n        # We need grad(psi) for the velocity correction. Let's compute its FFT directly.\n        # grad_psi_x_hat = 1j * kx * psi_hat\n        # grad_psi_y_hat = 1j * ky * psi_hat\n        # Combining these:\n        # grad_psi_x_hat = - (rho/dt) * (1j * kx * div_u_star_hat) / k_sq\n        #               = - (rho/dt) * (1j * kx * (1j * kx * fft_u_star + 1j * ky * fft_v_star)) / k_sq\n        #               =   (rho/dt) * (kx**2 * fft_u_star + kx * ky * fft_v_star) / k_sq\n\n        # To avoid numerical issues, handle the k_sq=0 case (DC component)\n        k_sq_reg = np.copy(k_sq)\n        k_sq_reg[0, 0] = 1.0 # The numerator should be zero here anyway\n\n        fft_grad_psi_x = (rho / dt) * (kx**2 * fft_u_star + kx * ky * fft_v_star) / k_sq_reg\n        fft_grad_psi_y = (rho / dt) * (kx * ky * fft_u_star + ky**2 * fft_v_star) / k_sq_reg\n        \n        # The DC component of the pressure gradient must be zero\n        fft_grad_psi_x[0, 0] = 0.0\n        fft_grad_psi_y[0, 0] = 0.0\n\n        # Transform pressure gradient back to real space\n        grad_psi_x = np.fft.ifft2(fft_grad_psi_x).real\n        grad_psi_y = np.fft.ifft2(fft_grad_psi_y).real\n\n        # Corrector step: compute final divergence-free velocity\n        u_final = u_star - (dt / rho) * grad_psi_x\n        v_final = v_star - (dt / rho) * grad_psi_y\n\n        # Calculate the magnitude of spurious currents\n        spurious_current_mag = np.sqrt(u_final**2 + v_final**2)\n        \n        # Find the maximum magnitude over the domain\n        max_spurious_current = np.max(spurious_current_mag)\n        \n        # Append result formatted to 6 significant figures in scientific notation\n        results.append(f\"{max_spurious_current:.5e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}