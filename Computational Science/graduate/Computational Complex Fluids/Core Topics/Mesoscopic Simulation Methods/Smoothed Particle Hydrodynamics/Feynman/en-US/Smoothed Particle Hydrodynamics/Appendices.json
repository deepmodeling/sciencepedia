{
    "hands_on_practices": [
        {
            "introduction": "The calculation of density is the cornerstone of the Smoothed Particle Hydrodynamics (SPH) method, forming the basis for computing pressure and other thermodynamic quantities. The standard SPH density estimate, $\\rho_i = \\sum_j m_j W_{ij}$, represents a discrete approximation of a continuous convolution integral. This exercise provides a hands-on numerical experiment to explore how the accuracy of this fundamental estimate is critically dependent on the particle arrangement . By comparing the density errors on a perfectly regular lattice versus a disordered, \"glass-like\" configuration, you will uncover key principles governing SPH accuracy and the importance of proper particle initialization.",
            "id": "2439536",
            "problem": "You are asked to quantitatively assess how particle disorder affects the accuracy of the Smoothed Particle Hydrodynamics (SPH) density estimate for a uniform, compressible fluid in two spatial dimensions. Consider a fluid occupying a periodic unit square domain with side length $L=1$ and area $A=L^2=1$. The fluid has constant surface density $\\rho_0=1$ expressed in dimensionless units. The domain is populated by $N$ equal-mass particles at positions $\\{\\mathbf{r}_i\\}_{i=1}^N$ with total mass $M=\\rho_0 A=1$, so each particle has mass $m=M/N=1/N$.\n\nFor any particle $i$, the SPH density estimate is defined by\n$$\n\\rho_i \\equiv \\sum_{j=1}^N m\\, W\\!\\left(\\left\\|\\mathbf{r}_i - \\mathbf{r}_j\\right\\|_\\mathrm{per},\\, h\\right),\n$$\nwhere $\\|\\cdot\\|_\\mathrm{per}$ denotes the minimum-image periodic distance on the unit torus and $W(r,h)$ is the standard cubic spline SPH kernel in two spatial dimensions with compact support $2h$ and smoothing length $h$. The smoothing length must be chosen as\n$$\nh = \\eta \\,\\Delta, \\quad \\text{with} \\quad \\Delta = \\sqrt{\\frac{A}{N}} = \\frac{1}{\\sqrt{N}},\n$$\nfor a fixed constant $\\eta=1.2$.\n\nTwo distinct particle arrangements must be considered for each specified value of $N$:\n\n- Lattice arrangement: particles placed on a regular square lattice of size $\\sqrt{N}\\times\\sqrt{N}$ within the unit square with periodic boundaries.\n- Glass-like arrangement: particles placed at the first $N$ points of the two-dimensional Halton sequence with bases $2$ and $3$, i.e., for $k=1,2,\\ldots,N$, the position is $\\mathbf{r}_k=\\big(\\phi_2(k),\\,\\phi_3(k)\\big)$ where $\\phi_b(k)$ is the radical-inverse function in base $b$.\n\nFor each arrangement and for each $N$, compute the following dimensionless error metrics comparing the SPH density estimate $\\{\\rho_i\\}$ to the exact uniform density $\\rho_0$:\n- The mean absolute relative error,\n$$\nE_1 = \\frac{1}{N}\\sum_{i=1}^N \\frac{\\left|\\rho_i-\\rho_0\\right|}{\\rho_0}.\n$$\n- The root-mean-square relative error,\n$$\nE_2 = \\frac{1}{\\sqrt{N}}\\left(\\sum_{i=1}^N \\left(\\frac{\\rho_i-\\rho_0}{\\rho_0}\\right)^2\\right)^{1/2}.\n$$\n- The maximum relative error,\n$$\nE_\\infty = \\max_{1\\le i\\le N} \\frac{\\left|\\rho_i-\\rho_0\\right|}{\\rho_0}.\n$$\n\nUse strictly dimensionless units throughout, and express all error values as decimal numbers (not as percentages). For each error metric, round the result to six decimal places.\n\nTest Suite:\nEvaluate the triplet $\\big[E_1,E_2,E_\\infty\\big]$ for the following ordered list of test cases, where each case specifies a pair $(N,\\text{arrangement})$:\n- $(N=\\;100,\\;\\text{lattice})$\n- $(N=\\;100,\\;\\text{glass})$\n- $(N=\\;256,\\;\\text{lattice})$\n- $(N=\\;256,\\;\\text{glass})$\n- $(N=\\;441,\\;\\text{lattice})$\n- $(N=\\;441,\\;\\text{glass})$\n\nAdopt the minimum-image periodic distance on the unit square torus for all pairwise separations in the kernel evaluations. For each $N$ in the lattice arrangement, assume $N$ is a perfect square so that the lattice is $\\sqrt{N}\\times\\sqrt{N}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list of lists, each inner list corresponding to one test case in the specified order and containing the three rounded error values in the order $\\big[E_1,E_2,E_\\infty\\big]$. For example:\n\"[ [e11,e12,e13],[e21,e22,e23],... ]\"\nEnsure the numerical values are rounded to six decimal places and there is no additional text beyond this single line. Use dimensionless units for all computations and outputs.",
            "solution": "The problem statement has been validated and is determined to be scientifically sound, well-posed, and complete. It constitutes a standard numerical experiment in the field of computational physics to assess the accuracy of the Smoothed Particle Hydrodynamics (SPH) method. The task is to compute density errors for two-dimensional particle distributions. A direct computational approach will be employed as follows.\n\nThe core of the SPH methodology is the representation of a continuous field $A(\\mathbf{r})$ by a summation over a set of discrete particles. For the density field $\\rho$, this is expressed as:\n$$\n\\rho(\\mathbf{r}) = \\sum_{j} m_j W\\left(\\left\\|\\mathbf{r} - \\mathbf{r}_j\\right\\|,\\, h\\right)\n$$\nwhere $m_j$ and $\\mathbf{r}_j$ are the mass and position of particle $j$, and $W$ is a smoothing kernel with characteristic width $h$, the smoothing length. The problem specifies the SPH density estimate for a particle $i$ at position $\\mathbf{r}_i$ as:\n$$\n\\rho_i = \\sum_{j=1}^N m\\, W\\!\\left(\\left\\|\\mathbf{r}_i - \\mathbf{r}_j\\right\\|_\\mathrm{per},\\, h\\right)\n$$\nThe domain is a two-dimensional unit square with periodic boundary conditions, area $A=1$, and total mass $M=1$. The fluid has a constant reference surface density $\\rho_0=1$. For $N$ particles, each thus has mass $m = M/N = 1/N$. The distance $\\|\\mathbf{r}_i - \\mathbf{r}_j\\|_\\mathrm{per}$ is the minimum-image distance on the unit torus, calculated for a displacement vector $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y)$ as $\\sqrt{(\\Delta x - \\text{round}(\\Delta x))^2 + (\\Delta y - \\text{round}(\\Delta y))^2}$.\n\nThe smoothing length $h$ is coupled to the mean particle separation $\\Delta$. For a two dimensional domain of area $A=1$ with $N$ particles, the mean separation is $\\Delta = \\sqrt{A/N} = 1/\\sqrt{N}$. The smoothing length is set to $h = \\eta \\Delta$, with the constant $\\eta = 1.2$.\n\nThe kernel $W(r, h)$ is the standard cubic spline for two dimensions, which is non-zero only for $r \\le 2h$. Its analytical form is:\n$$\nW(r,h) = \\frac{10}{7\\pi h^2} \\times \\begin{cases} 1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3  0 \\le q \\le 1 \\\\ \\frac{1}{4}(2-q)^3  1  q \\le 2 \\\\ 0  q  2 \\end{cases}\n$$\nwhere $q = r/h$ is the normalized distance.\n\nThe analysis requires two particle configurations:\n1.  **Lattice arrangement**: Particles are positioned on a uniform $\\sqrt{N} \\times \\sqrt{N}$ grid. The coordinates for a particle $(i,j)$ are taken as $(\\frac{i+0.5}{\\sqrt{N}}, \\frac{j+0.5}{\\sqrt{N}})$ for $i,j \\in \\{0, 1, \\dots, \\sqrt{N}-1\\}$. This ensures the lattice is centered within the unit domain.\n2.  **Glass-like arrangement**: Particles are placed at the first $N$ points of the two-dimensional Halton sequence with bases $2$ and $3$. The position of the $k$-th particle ($k=1, \\dots, N$) is $\\mathbf{r}_k = (\\phi_2(k), \\phi_3(k))$, where $\\phi_b(k)$ is the radical-inverse function in base $b$.\n\nFor each configuration and specified value of $N$, the SPH-estimated densities $\\{\\rho_i\\}_{i=1}^N$ are compared against the exact density $\\rho_0=1$ using three error metrics:\n-   Mean absolute relative error: $E_1 = \\frac{1}{N}\\sum_{i=1}^N |\\rho_i-1|$\n-   Root-mean-square relative error: $E_2 = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N (\\rho_i-1)^2}$\n-   Maximum relative error: $E_\\infty = \\max_{1\\le i\\le N} |\\rho_i-1|$\n\nThe computational procedure is as follows:\n1.  For each test case, specified by $(N, \\text{arrangement})$, the particle positions $\\{\\mathbf{r}_i\\}$ are generated.\n2.  A matrix of pairwise periodic distances, $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_\\mathrm{per}$, is computed for all $i,j \\in \\{1, \\dots, N\\}$. This calculation is vectorized for efficiency.\n3.  The kernel function $W(d_{ij}, h)$ is evaluated for all pairs, creating a matrix of kernel values.\n4.  The density for each particle $\\rho_i$ is computed by summing the $i$-th row of the kernel matrix and multiplying by the particle mass $m=1/N$.\n5.  The error metrics $E_1, E_2, E_\\infty$ are calculated from the vector of computed densities.\n6.  The final error values are rounded to six decimal places as required.\n\nThis entire procedure is implemented in Python using the `numpy` library to handle array operations efficiently.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SPH density error problem.\n    \"\"\"\n    \n    # Define the problem constants and test cases.\n    RHO_0 = 1.0\n    ETA = 1.2\n    \n    test_cases = [\n        (100, 'lattice'),\n        (100, 'glass'),\n        (256, 'lattice'),\n        (256, 'glass'),\n        (441, 'lattice'),\n        (441, 'glass'),\n    ]\n\n    # --- Helper functions ---\n\n    def radical_inverse(k, base):\n        \"\"\"Computes the radical inverse of k in a given base.\"\"\"\n        inv = 0.0\n        f = 1.0 / base\n        while k > 0:\n            inv += (k % base) * f\n            k //= base\n            f /= base\n        return inv\n\n    def generate_lattice(n_particles):\n        \"\"\"Generates particle positions on a regular square lattice.\"\"\"\n        n_side = int(np.sqrt(n_particles))\n        if n_side**2 != n_particles:\n            raise ValueError(\"N must be a perfect square for lattice arrangement\")\n        \n        points = np.zeros((n_particles, 2))\n        dx = 1.0 / n_side\n        \n        idx = 0\n        for i in range(n_side):\n            for j in range(n_side):\n                points[idx, 0] = (i + 0.5) * dx\n                points[idx, 1] = (j + 0.5) * dx\n                idx += 1\n        return points\n\n    def generate_glass(n_particles):\n        \"\"\"Generates particle positions from a Halton sequence.\"\"\"\n        points = np.zeros((n_particles, 2))\n        for k in range(1, n_particles + 1):\n            points[k-1, 0] = radical_inverse(k, 2)\n            points[k-1, 1] = radical_inverse(k, 3)\n        return points\n\n    def W_cubic_spline_vectorized(r, h):\n        \"\"\"Vectorized 2D cubic spline SPH kernel.\"\"\"\n        alpha_d = 10.0 / (7.0 * np.pi * h**2)\n        q = r / h\n        \n        res = np.zeros_like(q)\n        \n        # Condition: 1  q = 2\n        mask1 = (q > 1.0)  (q = 2.0)\n        q1 = q[mask1]\n        res[mask1] = alpha_d * 0.25 * (2.0 - q1)**3\n        \n        # Condition: 0 = q = 1\n        mask2 = q = 1.0\n        q2 = q[mask2]\n        res[mask2] = alpha_d * (1.0 - 1.5 * q2**2 + 0.75 * q2**3)\n        \n        return res\n\n    def compute_errors(n_particles, arrangement_type):\n        \"\"\"\n        Computes the SPH density and error metrics for a given configuration.\n        \"\"\"\n        # 1. Set parameters\n        m = 1.0 / n_particles\n        delta = 1.0 / np.sqrt(n_particles)\n        h = ETA * delta\n\n        # 2. Generate particle positions\n        if arrangement_type == 'lattice':\n            positions = generate_lattice(n_particles)\n        elif arrangement_type == 'glass':\n            positions = generate_glass(n_particles)\n        else:\n            raise ValueError(f\"Unknown arrangement type: {arrangement_type}\")\n            \n        # 3. Compute pairwise periodic distances (vectorized)\n        delta_r = positions[:, np.newaxis, :] - positions[np.newaxis, :, :]\n        delta_r -= np.round(delta_r)  # Minimum image convention for unit domain\n        distances = np.linalg.norm(delta_r, axis=2)\n\n        # 4. Evaluate kernel for all pairs\n        kernel_values = W_cubic_spline_vectorized(distances, h)\n\n        # 5. Sum contributions to get densities\n        densities = m * np.sum(kernel_values, axis=1)\n\n        # 6. Compute error metrics\n        relative_errors = (densities - RHO_0) / RHO_0\n        \n        e1 = np.mean(np.abs(relative_errors))\n        e2 = np.sqrt(np.mean(relative_errors**2))\n        e_inf = np.max(np.abs(relative_errors))\n        \n        return [round(e1, 6), round(e2, 6), round(e_inf, 6)]\n\n    # --- Main execution loop ---\n    \n    all_results = []\n    for n, arr_type in test_cases:\n        errors = compute_errors(n, arr_type)\n        all_results.append(errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once density is known, forces can be computed, and particles can be set in motion. However, the discrete nature of SPH force calculations can sometimes lead to unphysical behaviors that are not present in the underlying continuum equations. This practice delves into one of the most classic numerical challenges in SPH: the pairing, or tensile, instability, which can cause particles on a regular grid to form spurious pairings under tension . You will implement a quantitative indicator for this instability and investigate how it can be mitigated by introducing particle disorder or by using mathematically more robust smoothing kernels.",
            "id": "2439482",
            "problem": "You are asked to formalize and compute a quantitative indicator of the pairing instability in Smoothed Particle Hydrodynamics (SPH), and to demonstrate how it is suppressed by random initial particle positions. Consider a one-dimensional periodic domain of length $L$ containing $N$ identical particles of mass $m$ at positions $x_i \\in [0,L)$ for $i \\in \\{0,1,\\dots,N-1\\}$. Distances are measured using the minimum-image convention on the ring, i.e., for any pair $(i,j)$ the signed separation is $s_{ij} = x_i - x_j - L \\,\\mathrm{round}((x_i - x_j)/L)$ and the scalar interparticle distance is $r_{ij} = |s_{ij}|$.\n\nDefine the SPH density at particle $i$ by\n$$\n\\rho_i = \\sum_{j=0}^{N-1} m \\, W(r_{ij}, h),\n$$\nwhere $W(r,h)$ is a compactly supported kernel with smoothing length $h0$. Let the pressure be spatially uniform and constant with value $P_00$ (tension). The SPH pressure-gradient acceleration at particle $i$ is defined by\n$$\na_i(\\mathbf{x}) = -\\sum_{\\substack{j=0\\\\ j\\neq i}}^{N-1} m \\left(\\frac{P_0}{\\rho_i^2} + \\frac{P_0}{\\rho_j^2}\\right) \\frac{\\partial}{\\partial x_i} W(r_{ij}, h),\n$$\nwhere $\\mathbf{x} = (x_0,\\dots,x_{N-1})$ and $\\frac{\\partial}{\\partial x_i} W(r_{ij}, h) = \\frac{\\mathrm{d}W}{\\mathrm{d}r}(r_{ij}, h)\\, \\mathrm{sign}(s_{ij})$ with the convention that $\\mathrm{sign}(0)=0$.\n\nFor a given particle configuration $\\mathbf{x}$, define the Jacobian matrix $J(\\mathbf{x})$ of the acceleration field by its entries $J_{ik}(\\mathbf{x}) = \\frac{\\partial a_i}{\\partial x_k}(\\mathbf{x})$. Consider the alternating pairing mode vector $\\mathbf{u}\\in \\mathbb{R}^N$ with components $u_i = (-1)^i$. The pairing growth indicator is the Rayleigh quotient\n$$\n\\lambda(\\mathbf{x}) = \\frac{\\mathbf{u}^\\top J(\\mathbf{x}) \\,\\mathbf{u}}{\\mathbf{u}^\\top \\mathbf{u}}.\n$$\nA positive value of $\\lambda(\\mathbf{x})$ indicates an exponentially growing alternating mode (pairing instability), while a negative value indicates a restoring response (suppression of pairing). For this task, you must evaluate $\\lambda(\\mathbf{x})$ at specified configurations and kernels.\n\nUse the following one-dimensional kernels with support $r \\in [0, 2h)$:\n\n- Cubic spline (Monaghan–Lattanzio $M4$) in one dimension:\n  $$\n  W(r,h) = \\frac{\\alpha_1}{h} \\, f(q), \\quad q=\\frac{r}{h}, \\quad \\alpha_1=\\frac{2}{3},\n  $$\n  with\n  $$\n  f(q) = \n  \\begin{cases}\n  1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3,  0 \\le q  1, \\\\\n  \\frac{1}{4}(2 - q)^3,  1 \\le q  2, \\\\\n  0,  q \\ge 2,\n  \\end{cases}\n  $$\n  and\n  $$\n  \\frac{\\mathrm{d}W}{\\mathrm{d}r}(r,h) = \\frac{\\alpha_1}{h^2} \\, f'(q), \\quad\n  f'(q) =\n  \\begin{cases}\n  -3 q + \\frac{9}{4} q^2,  0 \\le q  1, \\\\\n  -\\frac{3}{4} (2 - q)^2,  1 \\le q  2, \\\\\n  0,  q \\ge 2.\n  \\end{cases}\n  $$\n\n- Wendland $C^2$ kernel in one dimension:\n  $$ \n  W(r,h) = \\frac{\\beta_1}{h} \\, g(q), \\quad q=\\frac{r}{h}, \\quad \\beta_1=\\frac{5}{8},\n  $$\n  with\n  $$\n  g(q) =\n  \\begin{cases}\n  \\left(1 - \\frac{q}{2}\\right)^4 (1 + 2q),  0 \\le q  2, \\\\\n  0,  q \\ge 2,\n  \\end{cases}\n  $$\n  and\n  $$\n  \\frac{\\mathrm{d}W}{\\mathrm{d}r}(r,h) = \\frac{\\beta_1}{h^2} \\, g'(q), \\quad\n  g'(q) = -2\\left(1 - \\frac{q}{2}\\right)^3 (1 + 2q) + 2\\left(1 - \\frac{q}{2}\\right)^4, \\quad 0 \\le q  2,\n  $$\n  and $g'(q)=0$ for $q \\ge 2$.\n\nAll quantities are non-dimensional; you must report the final outputs as real numbers without units.\n\nTest suite. Let $N = 64$, $L = 1$, $m = 1$, and $h = \\eta \\Delta$ where $\\Delta = L/N$ and $\\eta = 1.2$. Let the constant pressure be $P_0 = -1$. Consider the following three configurations for $\\mathbf{x}$:\n\n- Case A (regular lattice, cubic spline): $x_i = i \\Delta$ for $i \\in \\{0,\\dots,N-1\\}$, kernel is the cubic spline as defined above.\n\n- Case B (random jitter, cubic spline): $x_i = \\mathrm{mod}\\!\\left(i \\Delta + \\xi_i, L\\right)$ with independent $\\xi_i$ drawn uniformly from the interval $\\left[-\\alpha \\Delta, \\alpha \\Delta\\right]$ with $\\alpha = 0.25$, using a fixed pseudorandom generator seed equal to $12345$ so that results are deterministic, kernel is the cubic spline as defined above.\n\n- Case C (regular lattice, Wendland $C^2$): $x_i = i \\Delta$ for $i \\in \\{0,\\dots,N-1\\}$, kernel is the Wendland $C^2$ as defined above.\n\nYour task is to write a complete program that computes $\\lambda(\\mathbf{x})$ for each of the three cases above. Since $J(\\mathbf{x})$ is defined by derivatives of the acceleration with respect to positions, you must determine a numerically consistent way to evaluate the action of $J(\\mathbf{x})$ on the vector $\\mathbf{u}$ at each specified configuration, and from it the scalar $\\lambda(\\mathbf{x})$ as defined by the Rayleigh quotient. Use the alternating mode components $u_i = (-1)^i$ for $i \\in \\{0,\\dots,N-1\\}$. Ensure that any numerical discretization you choose respects the periodic domain and the kernel definitions above.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\lambda(\\text{Case A}), \\lambda(\\text{Case B}), \\lambda(\\text{Case C})]$. Express each result as a decimal real number. For reproducibility, if you use any pseudorandom numbers, initialize the generator with the seed value $12345$ as specified above. No physical units are required for the final answers.",
            "solution": "The problem statement is examined and found to be valid. It is a well-posed problem in computational physics, providing all necessary definitions, parameters, and a clear objective. It is free of scientific inaccuracies, contradictions, or ambiguities. The task is to analyze the pairing instability in Smoothed Particle Hydrodynamics (SPH) through a specified quantitative indicator, which is a standard procedure in the field.\n\nThe central task is the computation of the pairing growth indicator $\\lambda(\\mathbf{x})$, defined as the Rayleigh quotient:\n$$\n\\lambda(\\mathbf{x}) = \\frac{\\mathbf{u}^\\top J(\\mathbf{x}) \\,\\mathbf{u}}{\\mathbf{u}^\\top \\mathbf{u}}\n$$\nHere, $\\mathbf{x} = (x_0, \\dots, x_{N-1})$ is the vector of particle positions, $\\mathbf{u}$ is the alternating pairing mode vector with components $u_i = (-1)^i$, and $J(\\mathbf{x})$ is the Jacobian of the acceleration field, $J_{ik} = \\partial a_i / \\partial x_k$. The denominator is simply $\\mathbf{u}^\\top \\mathbf{u} = \\sum_{i=0}^{N-1} ((-1)^i)^2 = N$.\n\nA direct analytical derivation and implementation of the $N \\times N$ Jacobian matrix $J(\\mathbf{x})$ would be excessively complex and computationally inefficient. A superior and numerically standard method is to compute the action of the Jacobian on the vector $\\mathbf{u}$, i.e., the matrix-vector product $J(\\mathbf{x})\\mathbf{u}$, without explicitly forming $J(\\mathbf{x})$.\n\nThe product $(J\\mathbf{u})_i = \\sum_{k=0}^{N-1} J_{ik} u_k = \\sum_{k=0}^{N-1} \\frac{\\partial a_i}{\\partial x_k} u_k$ represents the directional derivative of the $i$-th component of the acceleration field $\\mathbf{a}(\\mathbf{x})$ in the direction of the vector $\\mathbf{u}$. This can be numerically approximated using a finite difference scheme. We employ a second-order central difference for superior accuracy:\n$$\nJ(\\mathbf{x})\\mathbf{u} \\approx \\frac{\\mathbf{a}(\\mathbf{x} + \\epsilon \\mathbf{u}) - \\mathbf{a}(\\mathbf{x} - \\epsilon \\mathbf{u})}{2\\epsilon}\n$$\nwhere $\\epsilon$ is a small scalar perturbation step. A value of $\\epsilon = 10^{-7}$ is chosen, which is small enough to ensure a good approximation of the derivative while being large enough to avoid catastrophic cancellation due to floating-point arithmetic precision limits.\n\nThe computation of $\\lambda(\\mathbf{x})$ for a given configuration $\\mathbf{x}$ thus proceeds as follows:\n$1$. Construct the perturbed position vectors $\\mathbf{x}^+ = \\mathbf{x} + \\epsilon \\mathbf{u}$ and $\\mathbf{x}^- = \\mathbf{x} - \\epsilon \\mathbf{u}$.\n$2$. Calculate the acceleration vectors $\\mathbf{a}^+ = \\mathbf{a}(\\mathbf{x}^+)$ and $\\mathbf{a}^- = \\mathbf{a}(\\mathbf{x}^-)$.\n$3$. Compute the numerical approximation of the Jacobian-vector product $\\mathbf{v} = (\\mathbf{a}^+ - \\mathbf{a}^-) / (2\\epsilon)$.\n$4$. Calculate the Rayleigh quotient as $\\lambda(\\mathbf{x}) = (\\mathbf{u}^\\top \\mathbf{v}) / N$.\n\nThe calculation of the acceleration vector $\\mathbf{a}(\\mathbf{x})$ for any position vector $\\mathbf{x}$ is the core computational step. It requires:\na. Computing the SPH density $\\rho_i$ for each particle $i$ using the formula $\\rho_i = \\sum_{j} m W(r_{ij}, h)$.\nb. Computing the SPH acceleration $a_i$ for each particle $i$ using the formula $a_i = -\\sum_{j \\neq i} m (P_0/\\rho_i^2 + P_0/\\rho_j^2) \\frac{\\partial W}{\\partial x_i}(r_{ij}, h)$.\n\nAll pairwise particle interactions are handled using the minimum-image convention for the periodic domain of length $L$. For efficiency, the calculation of densities and accelerations is vectorized using NumPy, avoiding explicit loops in Python. This involves constructing $N \\times N$ matrices of pairwise separations $s_{ij}$, distances $r_{ij}$, and kernel values.\n\nThe three test cases are designed to illustrate the nature of the pairing instability:\n- **Case A**: A regular lattice with the cubic spline kernel. This configuration is known to be numerically unstable under tension ($P_0  0$), and we expect $\\lambda  0$, indicating exponential growth of the pairing mode.\n- **Case B**: A randomly perturbed lattice with the cubic spline kernel. The introduced disorder is expected to break the coherence of the unstable mode, suppressing the instability. We expect $\\lambda$ to be significantly reduced, ideally becoming negative.\n- **Case C**: A regular lattice with the Wendland $C^2$ kernel. This kernel is designed to have superior stability properties. We expect it to prevent the instability even on a regular lattice, resulting in $\\lambda  0$.\n\nThe implementation will follow this validated numerical strategy to compute $\\lambda$ for each of the three specified cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef W_cubic(r, h):\n    \"\"\"\n    Computes the 1D cubic spline kernel value.\n    \"\"\"\n    alpha1 = 2.0 / 3.0\n    q = r / h\n    vals = np.zeros_like(q)\n    \n    mask1 = (q >= 0)  (q  1)\n    q1 = q[mask1]\n    vals[mask1] = 1.0 - 1.5 * q1**2 + 0.75 * q1**3\n    \n    mask2 = (q >= 1)  (q  2)\n    q2 = q[mask2]\n    vals[mask2] = 0.25 * (2.0 - q2)**3\n    \n    return (alpha1 / h) * vals\n\ndef dWdr_cubic(r, h):\n    \"\"\"\n    Computes the derivative of the 1D cubic spline kernel with respect to r.\n    \"\"\"\n    alpha1 = 2.0 / 3.0\n    q = r / h\n    vals = np.zeros_like(q)\n    \n    mask1 = (q >= 0)  (q  1)\n    q1 = q[mask1]\n    vals[mask1] = -3.0 * q1 + (9.0 / 4.0) * q1**2\n    \n    mask2 = (q >= 1)  (q  2)\n    q2 = q[mask2]\n    vals[mask2] = -0.75 * (2.0 - q2)**2\n    \n    return (alpha1 / h**2) * vals\n\ndef W_wendland(r, h):\n    \"\"\"\n    Computes the 1D C2 Wendland kernel value.\n    \"\"\"\n    beta1 = 5.0 / 8.0\n    q = r / h\n    vals = np.zeros_like(q)\n    mask = (q >= 0)  (q  2)\n    q_masked = q[mask]\n    vals[mask] = (1.0 - q_masked / 2.0)**4 * (1.0 + 2.0 * q_masked)\n    return (beta1 / h) * vals\n\ndef dWdr_wendland(r, h):\n    \"\"\"\n    Computes the derivative of the 1D C2 Wendland kernel with respect to r.\n    \"\"\"\n    beta1 = 5.0 / 8.0\n    q = r / h\n    vals = np.zeros_like(q)\n    mask = (q >= 0)  (q  2)\n    q_masked = q[mask]\n    term1 = 1.0 - q_masked / 2.0\n    vals[mask] = -2.0 * term1**3 * (1.0 + 2.0 * q_masked) + 2.0 * term1**4\n    return (beta1 / h**2) * vals\n\ndef calculate_acceleration(x, m, L, h, P0, kernel_W, kernel_dWdr):\n    \"\"\"\n    Calculates the SPH acceleration for a given particle configuration.\n    \"\"\"\n    N = len(x)\n    \n    x_col = x.reshape(N, 1)\n    dx_matrix = x_col - x\n    s_matrix = dx_matrix - L * np.round(dx_matrix / L)\n    r_matrix = np.abs(s_matrix)\n    \n    W_matrix = kernel_W(r_matrix, h)\n    rho = m * np.sum(W_matrix, axis=1)\n    \n    dWdr_matrix = kernel_dWdr(r_matrix, h)\n    sign_s_matrix = np.sign(s_matrix)\n    dW_dx_matrix = dWdr_matrix * sign_s_matrix\n    \n    rho_sq_inv_col = (1.0 / rho**2).reshape(N, 1)\n    pressure_term_matrix = P0 * (rho_sq_inv_col + rho_sq_inv_col.T)\n    \n    summand_matrix = m * pressure_term_matrix * dW_dx_matrix\n    np.fill_diagonal(summand_matrix, 0.0)\n    \n    acc = -np.sum(summand_matrix, axis=1)\n    return acc\n\ndef compute_lambda(x, u, m, L, h, P0, kernel_W, kernel_dWdr):\n    \"\"\"\n    Computes the pairing growth indicator lambda using finite differences.\n    \"\"\"\n    N = len(x)\n    eps = 1e-7  # Finite difference step\n    \n    x_plus = x + eps * u\n    x_minus = x - eps * u\n    \n    acc_plus = calculate_acceleration(x_plus, m, L, h, P0, kernel_W, kernel_dWdr)\n    acc_minus = calculate_acceleration(x_minus, m, L, h, P0, kernel_W, kernel_dWdr)\n    \n    # Jacobian-vector product J*u\n    v = (acc_plus - acc_minus) / (2.0 * eps)\n    \n    # Rayleigh quotient\n    lambda_val = np.dot(u, v) / N\n    return lambda_val\n\ndef solve():\n    \"\"\"\n    Main solver function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Parameter set 1),\n        # (Parameter set 2),\n        # ...\n    ]\n    \n    # Problem parameters\n    N = 64\n    L = 1.0\n    m = 1.0\n    P0 = -1.0\n    eta = 1.2\n    alpha = 0.25\n    seed = 12345\n    \n    Delta = L / N\n    h = eta * Delta\n    \n    # Alternating pairing mode vector\n    u = np.power(-1.0, np.arange(N))\n    \n    # Case A: Regular lattice, cubic spline\n    x_A = np.arange(N) * Delta\n    \n    # Case B: Random jitter, cubic spline\n    rng = np.random.default_rng(seed)\n    xi = rng.uniform(-alpha * Delta, alpha * Delta, size=N)\n    x_B = np.mod(np.arange(N) * Delta + xi, L)\n    \n    # Case C: Regular lattice, Wendland C2\n    x_C = np.arange(N) * Delta\n\n    kernels_cubic = (W_cubic, dWdr_cubic)\n    kernels_wendland = (W_wendland, dWdr_wendland)\n\n    case_definitions = [\n        (x_A, kernels_cubic),\n        (x_B, kernels_cubic),\n        (x_C, kernels_wendland),\n    ]\n\n    results = []\n    for x, (kernel_W, kernel_dWdr) in case_definitions:\n        lambda_val = compute_lambda(x, u, m, L, h, P0, kernel_W, kernel_dWdr)\n        results.append(lambda_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A stable and accurate simulation requires not only correct force calculations but also a carefully controlled temporal evolution. Most SPH codes employ explicit time integration schemes, whose stability is contingent on the time step, $\\Delta t$, being small enough to resolve the fastest-occurring physical phenomena in the system. This final practice guides you through the essential task of building an adaptive time-step controller, a core component of any modern SPH solver . You will derive and implement time-step constraints arising from wave propagation (the Courant-Friedrichs-Lewy or CFL condition), particle acceleration, and viscous diffusion, learning to identify which physical process is the limiting factor at any given moment.",
            "id": "2439517",
            "problem": "You are tasked with implementing a variable time-step controller for an explicit Smoothed Particle Hydrodynamics (SPH) time integrator using three fundamental stability and accuracy considerations: a Courant–Friedrichs–Lewy (CFL) condition, a force (acceleration) condition, and a viscous diffusion condition. Your solution must start from first principles consistent with explicit methods for hyperbolic and parabolic problems and classical kinematics, and derive the exact expressions you will implement for the time-step at each iteration. The scenario is one-dimensional with uniform smoothing length, and the program should integrate only the time variable while sampling prescribed maximum field magnitudes over time. All physical quantities must be treated in the International System of Units (SI), and time should always be computed and reported in seconds.\n\nStarting point for derivation: Use only the following base principles as your fundamental starting point.\n- Characteristic signal propagation in hyperbolic systems: the information travels at a characteristic speed, so a stable explicit step must be limited by a ratio of spatial resolution to maximum signal speed.\n- Kinematics under constant acceleration over a time step: the displacement under uniform acceleration must remain small relative to the spatial resolution to preserve accuracy.\n- Stability limit for explicit schemes applied to parabolic diffusion: the time-step must be bounded proportionally to the square of the spatial resolution and inversely to the kinematic viscosity.\n\nAssume the following modeling setup:\n- Smoothing length $h$ is constant and uniform.\n- The maximum signal speed is modeled as the sum of the speed of sound and a convective speed, so the instantaneous maximum signal speed is $s(t) = c + \\lvert v_{\\max}(t)\\rvert$, where $c$ is the (constant) speed of sound and $v_{\\max}(t)$ is the time-varying maximum particle speed magnitude.\n- The maximum acceleration magnitude $a_{\\max}(t)$ is time-dependent.\n- The kinematic viscosity $\\nu$ is constant and uniform.\n- Each time-step uses a safety coefficient $C_{\\mathrm{CFL}}$, $C_{\\mathrm{force}}$, and $C_{\\mathrm{visc}}$ for the three limits, respectively, each strictly between $0$ and $1$.\n\nDerive, from the above principles, explicit formulas for the three candidate time-steps at time $t$: a hyperbolic (CFL) bound in terms of $h$ and $s(t)$, a force-based bound in terms of $h$ and $a_{\\max}(t)$, and a viscous-diffusion bound in terms of $h$ and $\\nu$. Then implement an explicit time-advancement controller that, starting at $t=0$, repeatedly:\n- Evaluates the three candidate bounds at the current time $t$;\n- Chooses the minimum of the three as the next time increment $\\Delta t$ (breaking ties by selecting the first in the order CFL, then force, then viscous);\n- Records which bound is limiting at that step using the integer codes: $0$ for CFL, $1$ for force, and $2$ for viscous;\n- Advances time by $\\Delta t$;\n- Stops when $t$ reaches a specified final time $T_{\\mathrm{end}}$ (you must ensure $t$ does not exceed $T_{\\mathrm{end}}$; if necessary, truncate the last step to end exactly at $T_{\\mathrm{end}}$ but classify the limiter using the untruncated candidate bounds).\n\nHandle edge cases robustly: if $a_{\\max}(t)=0$ at any time, the force-based bound should be treated as $+\\infty$; if $\\nu=0$, the viscous bound should be treated as $+\\infty$. You may assume $cgt;0$ so the CFL bound is always finite. The evaluation of $v_{\\max}(t)$ and $a_{\\max}(t)$ is defined by smooth functions of time given below. Angles do not appear in this problem. There are no percentage quantities.\n\nFor testing and reproducibility, use the following test suite of three cases. In each case, the maximum velocity and acceleration are prescribed by\n- $v_{\\max}(t) = v_{0} + A_{v}\\left(1 - e^{-t/\\tau_{v}}\\right)$,\n- $a_{\\max}(t) = a_{0} + A_{a} e^{-t/\\tau_{a}}$,\nwith all parameters given below. Use seconds for time, meters for length, meters per second for velocity, meters per second squared for acceleration, and meters squared per second for kinematic viscosity. Safety coefficients are dimensionless.\n\nTest case 1 (general mixed regime):\n- $h = 0.01$ m, $c = 5.0$ m/s, $\\nu = 1.0\\times 10^{-6}$ m$^{2}$/s,\n- $C_{\\mathrm{CFL}} = 0.25$, $C_{\\mathrm{force}} = 0.25$, $C_{\\mathrm{visc}} = 0.125$,\n- $T_{\\mathrm{end}} = 0.10$ s,\n- $v_{0} = 0.0$ m/s, $A_{v} = 3.0$ m/s, $\\tau_{v} = 0.02$ s,\n- $a_{0} = 0.0$ m/s$^{2}$, $A_{a} = 4000.0$ m/s$^{2}$, $\\tau_{a} = 0.015$ s.\n\nTest case 2 (viscous-limited with zero acceleration):\n- $h = 0.01$ m, $c = 5.0$ m/s, $\\nu = 0.5$ m$^{2}$/s,\n- $C_{\\mathrm{CFL}} = 0.25$, $C_{\\mathrm{force}} = 0.25$, $C_{\\mathrm{visc}} = 0.125$,\n- $T_{\\mathrm{end}} = 0.05$ s,\n- $v_{0} = 0.0$ m/s, $A_{v} = 3.0$ m/s, $\\tau_{v} = 0.02$ s,\n- $a_{0} = 0.0$ m/s$^{2}$, $A_{a} = 0.0$ m/s$^{2}$, $\\tau_{a} = 0.01$ s.\n\nTest case 3 (CFL-limited with zero viscosity):\n- $h = 0.005$ m, $c = 30.0$ m/s, $\\nu = 0.0$ m$^{2}$/s,\n- $C_{\\mathrm{CFL}} = 0.30$, $C_{\\mathrm{force}} = 0.30$, $C_{\\mathrm{visc}} = 0.30$,\n- $T_{\\mathrm{end}} = 0.010$ s,\n- $v_{0} = 0.0$ m/s, $A_{v} = 1.5$ m/s, $\\tau_{v} = 0.01$ s,\n- $a_{0} = 0.0$ m/s$^{2}$, $A_{a} = 5000.0$ m/s$^{2}$, $\\tau_{a} = 0.005$ s.\n\nProgram requirements:\n- Implement the variable time-step controller exactly as described.\n- For each test case, generate the list of integer codes indicating which bound limited the time-step at each iteration from $t=0$ until $t=T_{\\mathrm{end}}$.\n- Your program should produce a single line of output containing the results for all three test cases as a comma-separated list of lists in Python literal form, for example, $\\left[\\left[\\dots\\right],\\left[\\dots\\right],\\left[\\dots\\right]\\right]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the three lists of limiter codes, enclosed in a single pair of square brackets and separated by commas, e.g., $\\left[\\left[\\ell_{1,1}, \\ell_{1,2}, \\dots\\right], \\left[\\ell_{2,1}, \\ell_{2,2}, \\dots\\right], \\left[\\ell_{3,1}, \\ell_{3,2}, \\dots\\right]\\right]$, where each $\\ell_{i,j}$ is an integer in $\\left\\{0,1,2\\right\\}$.",
            "solution": "The problem proposed is valid. It is scientifically grounded in the principles of numerical methods for partial differential equations, specifically for smoothed particle hydrodynamics (SPH). The problem is well-posed, objective, and provides a complete and consistent set of data and instructions for implementing a deterministic time-stepping algorithm. We shall now proceed with the derivation and solution.\n\nThe objective is to construct a variable time-step controller for an explicit SPH simulation. The time increment, $\\Delta t$, at each step is chosen as the minimum of three candidate values derived from stability and accuracy considerations: the Courant–Friedrichs–Lewy (CFL) condition, a force-based acceleration limit, and a viscous diffusion limit.\n\nLet us derive the expressions for these three time-step bounds from the provided first principles. The characteristic spatial resolution of the SPH method is given by the smoothing length, $h$.\n\n1.  **CFL (Hyperbolic) Time-Step, $\\Delta t_{\\mathrm{CFL}}$**\nThe first principle is based on the stability of explicit methods for hyperbolic systems. Information, or a physical signal, propagates at a characteristic speed. For stability, the numerical domain of dependence must contain the physical domain of dependence. In an SPH context, this means that in a single time-step $\\Delta t$, information should not propagate further than the local interaction distance, which is on the order of the smoothing length $h$. The maximum speed of signal propagation, $s(t)$, is given as the sum of the speed of sound $c$ and the magnitude of the maximum particle velocity $|v_{\\max}(t)|$.\nThe condition is expressed as:\n$$ \\Delta t \\le C_{\\mathrm{CFL}} \\frac{h}{s(t)} $$\nwhere $C_{\\mathrm{CFL}}$ is a safety coefficient, typically less than $1$. Substituting the given expression for $s(t) = c + |v_{\\max}(t)|$, we obtain the candidate time-step from the CFL condition:\n$$ \\Delta t_{\\mathrm{CFL}}(t) = C_{\\mathrm{CFL}} \\frac{h}{c + |v_{\\max}(t)|} $$\n\n2.  **Force-Based (Kinematic) Time-Step, $\\Delta t_{\\mathrm{force}}$**\nThe second principle ensures accuracy by limiting the displacement of a particle due to acceleration within a single time-step. The principle states that this displacement should be small relative to the spatial resolution $h$. The displacement of a particle under a constant acceleration $a$ over a time $\\Delta t$ is $\\frac{1}{2}a(\\Delta t)^2$. The standard SPH criterion formalizing this principle limits the time-step such that:\n$$ \\frac{1}{2} a_{\\max}(t) (\\Delta t)^2 \\le \\alpha h $$\nwhere $a_{\\max}(t)$ is the maximum magnitude of acceleration in the system and $\\alpha$ is a small dimensionless constant. Rearranging for $\\Delta t$ yields $\\Delta t \\le \\sqrt{2\\alpha h / a_{\\max}(t)}$. This is commonly written in the form:\n$$ \\Delta t \\le C_{\\mathrm{force}} \\sqrt{\\frac{h}{a_{\\max}(t)}} $$\nwhere $C_{\\mathrm{force}}$ is a user-defined safety coefficient. We will adopt this standard form as the direct implementation of the stated principle. Thus, the force-based time-step is:\n$$ \\Delta t_{\\mathrm{force}}(t) = C_{\\mathrm{force}} \\sqrt{\\frac{h}{a_{\\max}(t)}} $$\nThis expression is valid only for $a_{\\max}(t)  0$. If $a_{\\max}(t) = 0$, there is no acceleration to limit, so this condition imposes no upper bound on the time-step. In this case, we treat $\\Delta t_{\\mathrm{force}}$ as being infinitely large.\n\n3.  **Viscous Diffusion Time-Step, $\\Delta t_{\\mathrm{visc}}$**\nThe third principle comes from the stability analysis of explicit numerical schemes for parabolic diffusion equations of the form $\\partial u/\\partial t = \\nu \\nabla^2 u$, where $\\nu$ is the kinematic viscosity. For a simple forward-time, centered-space (FTCS) discretization, the stability condition is $\\Delta t \\le (\\Delta x)^2/(2\\nu)$. In SPH, the spatial resolution $\\Delta x$ is replaced by the smoothing length $h$. The generic form of this stability constraint is:\n$$ \\Delta t \\le C_{\\mathrm{visc}} \\frac{h^2}{\\nu} $$\nwhere $C_{\\mathrm{visc}}$ is a safety coefficient that accounts for the constant prefactors (like $1/2$) and other details of the specific SPH discretization of the viscous term. The problem provides this coefficient directly. Therefore, the viscous time-step is:\n$$ \\Delta t_{\\mathrm{visc}} = C_{\\mathrm{visc}} \\frac{h^2}{\\nu} $$\nNote that this time-step is constant if $\\nu$ and $h$ are constant. If $\\nu = 0$, viscosity is absent, and this constraint does not apply. We thus treat $\\Delta t_{\\mathrm{visc}}$ as being infinitely large in this case.\n\n**Time Integration Algorithm**\nThe simulation proceeds from an initial time $t=0$ to a final time $T_{\\mathrm{end}}$. At each step, starting at time $t$, the algorithm is as follows:\n1.  Evaluate the time-dependent maximum velocity and acceleration, $v_{\\max}(t)$ and $a_{\\max}(t)$, using the prescribed functions:\n    $$ v_{\\max}(t) = v_{0} + A_{v}\\left(1 - e^{-t/\\tau_{v}}\\right) $$\n    $$ a_{\\max}(t) = a_{0} + A_{a} e^{-t/\\tau_{a}} $$\n2.  Calculate the three candidate time-steps: $\\Delta t_{\\mathrm{CFL}}(t)$, $\\Delta t_{\\mathrm{force}}(t)$, and $\\Delta t_{\\mathrm{visc}}$.\n3.  Determine the limiting time-step for the current iteration:\n    $$ \\Delta t_{\\mathrm{chosen}} = \\min(\\Delta t_{\\mathrm{CFL}}, \\Delta t_{\\mathrm{force}}, \\Delta t_{\\mathrm{visc}}) $$\n4.  Identify which condition is the limiting one. We use integer codes: $0$ for CFL, $1$ for force, and $2$ for viscous. The tie-breaking rule is to select the first one in this specified order. This code is recorded for the current step.\n5.  Advance the simulation time. The time increment $\\Delta t_{\\mathrm{step}}$ is set to $\\Delta t_{\\mathrm{chosen}}$. However, to ensure the simulation ends exactly at $T_{\\mathrm{end}}$, the last step is truncated if necessary. That is, if $t + \\Delta t_{\\mathrm{chosen}} \\ge T_{\\mathrm{end}}$, the current step is the final one, and the time is advanced to $T_{\\mathrm{end}}$. Otherwise, the time is advanced by $\\Delta t_{\\mathrm{chosen}}$: $t \\leftarrow t + \\Delta t_{\\mathrm{chosen}}$. The loop continues as long as $t  T_{\\mathrm{end}}$. The limiter code for the final step is determined from the untruncated $\\Delta t_{\\mathrm{chosen}}$.\n\nThis procedure is implemented for each test case to generate a sequence of limiter codes.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a variable time-step controller for an explicit SPH simulation.\n    The controller uses CFL, force, and viscous stability criteria.\n    \"\"\"\n\n    def run_simulation(h, c, nu, C_cfl, C_force, C_visc, T_end, v0, Av, tau_v, a0, Aa, tau_a):\n        \"\"\"\n        Runs a single SPH time-stepping simulation for a given set of parameters.\n        \n        Returns a list of integer codes indicating the limiter at each step.\n        \"\"\"\n\n        # Define the time-dependent functions for maximum velocity and acceleration\n        def v_max_func(t):\n            # The problem statement defines v_max(t) which may not be a magnitude, but\n            # all test cases result in v_max(t) >= 0. The CFL condition uses |v_max(t)|.\n            if tau_v > 0:\n                return v0 + Av * (1.0 - np.exp(-t / tau_v))\n            return v0 + Av # Case for tau_v -> 0 or t -> inf\n\n        def a_max_func(t):\n            if tau_a > 0:\n                return a0 + Aa * np.exp(-t / tau_a)\n            return a0 # Case for tau_a -> 0 or t -> inf\n\n        t = 0.0\n        limiters = []\n\n        # The loop must continue as long as the current time is less than the end time.\n        while t  T_end:\n            # 1. Evaluate maximum velocity and acceleration at the current time t\n            current_v_max = v_max_func(t)\n            current_a_max = a_max_func(t)\n\n            # 2. Calculate the three candidate time steps\n            \n            # CFL (Hyperbolic) Condition\n            # s(t) = c + |v_max(t)|\n            # c > 0 is assumed, so s_t is always positive.\n            s_t = c + abs(current_v_max)\n            dt_cfl = C_cfl * h / s_t\n\n            # Force (Kinematic) Condition\n            if current_a_max > 0.0:\n                dt_force = C_force * np.sqrt(h / current_a_max)\n            else:\n                dt_force = np.inf\n\n            # Viscous Diffusion Condition\n            if nu > 0.0:\n                dt_visc = C_visc * h**2 / nu\n            else:\n                dt_visc = np.inf\n\n            # 3. Determine the limiting time step and its corresponding code\n            dt_candidates = [dt_cfl, dt_force, dt_visc]\n            \n            # np.argmin implements the required tie-breaking rule (first minimum is chosen)\n            limiter_code = int(np.argmin(dt_candidates))\n            dt_chosen = dt_candidates[limiter_code]\n            \n            # 4. Record the limiter code for the current step\n            limiters.append(limiter_code)\n\n            # 5. Advance the simulation time.\n            # Truncate the last step to ensure t does not exceed T_end.\n            if t + dt_chosen >= T_end:\n                t = T_end\n            else:\n                t += dt_chosen\n        \n        return limiters\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general mixed regime)\n        {'h': 0.01, 'c': 5.0, 'nu': 1.0e-6, 'C_cfl': 0.25, 'C_force': 0.25, 'C_visc': 0.125, 'T_end': 0.10, 'v0': 0.0, 'Av': 3.0, 'tau_v': 0.02, 'a0': 0.0, 'Aa': 4000.0, 'tau_a': 0.015},\n        # Case 2 (viscous-limited with zero acceleration)\n        {'h': 0.01, 'c': 5.0, 'nu': 0.5, 'C_cfl': 0.25, 'C_force': 0.25, 'C_visc': 0.125, 'T_end': 0.05, 'v0': 0.0, 'Av': 3.0, 'tau_v': 0.02, 'a0': 0.0, 'Aa': 0.0, 'tau_a': 0.01},\n        # Case 3 (CFL-limited with zero viscosity)\n        {'h': 0.005, 'c': 30.0, 'nu': 0.0, 'C_cfl': 0.30, 'C_force': 0.30, 'C_visc': 0.30, 'T_end': 0.010, 'v0': 0.0, 'Av': 1.5, 'tau_v': 0.01, 'a0': 0.0, 'Aa': 5000.0, 'tau_a': 0.005},\n    ]\n\n    results = []\n    for case in test_cases:\n        limiters = run_simulation(**case)\n        results.append(limiters)\n\n    # Format the output as a compact Python literal string for a list of lists.\n    # e.g., [[1,2,3],[4],[5,6]]\n    # This construction ensures no spaces are included, matching the example format style.\n    inner_lists_str = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output = f\"[{','.join(inner_lists_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}