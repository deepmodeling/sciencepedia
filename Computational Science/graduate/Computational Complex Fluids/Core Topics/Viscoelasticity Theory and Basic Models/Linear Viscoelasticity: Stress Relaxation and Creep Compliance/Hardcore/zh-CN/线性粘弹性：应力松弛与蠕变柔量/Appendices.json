{
    "hands_on_practices": [
        {
            "introduction": "在线性粘弹性理论中，应力松弛模量 $G(t)$ 和蠕变柔量 $J(t)$ 是描述材料时间依赖性行为的两个核心函数。虽然它们分别从应变和应力阶跃实验中定义，但它们并非相互独立，而是通过本构关系紧密联系。本练习将指导您通过拉普拉斯变换，从一个给定的松弛模量 $G(t)$ 解析地推导出相应的蠕变柔量 $J(t)$，这是掌握粘弹性材料基本理论和数学工具的关键一步。",
            "id": "2861612",
            "problem": "一个粘弹性固体被建模为标准线性固体 (SLS)，等效于一个弹簧与一个麦克斯韦元件并联，其松弛模量由函数 $G(t)=G_{\\infty}+\\bigl(G_{0}-G_{\\infty}\\bigr)\\exp\\!\\bigl(-t/\\tau\\bigr)$（$t \\ge 0$）给出，其中 $G_{0}G_{\\infty}0$ 和 $\\tau0$ 是常数。假设为线性粘弹性，并且在 $t  0$ 时初始场为零。仅从线性粘弹性的遗传 (Boltzmann) 叠加原理以及松弛模量 $G(t)$ 和蠕变柔量 $J(t)$ 的定义出发，推导以下阶跃响应：\n\n- 由突加的恒定单轴应力 $\\sigma(t)=\\sigma_{0}H(t)$（其中 $H(t)$ 为亥维赛德阶跃函数）产生的蠕变应变 $\\varepsilon(t)$，以及\n- 由突加的恒定单轴应变 $\\varepsilon(t)=\\varepsilon_{0}H(t)$ 产生的应力松弛 $\\sigma(t)$，\n\n两者均针对 $t0$ 的情况。将每个响应表示为 $t$、$G_{0}$、$G_{\\infty}$、$\\tau$、$\\sigma_{0}$ 和 $\\varepsilon_{0}$ 的闭式解析函数。无需进行数值计算。将您的最终答案以上述顺序表示为两个表达式，并置于同一行。最终答案中不包含单位。",
            "solution": "所述问题具有科学依据、是适定且客观的。这是线性粘弹性理论中基于既定原理和模型的标准问题。所有必要信息均已提供，问题没有矛盾或含糊之处。因此，该问题是有效的，将提供解答。\n\n线性粘弹性的基础是 Boltzmann 叠加原理，该原理指出，在给定时间的总应力（或应变）是过去所有应变（或应力）变化影响的线性叠加。对于连续的历史过程，该原理通过遗传积分来表达。假设在时间 $t  0$ 时应力和应变为零，则对于 $t \\ge 0$，应力 $\\sigma(t)$ 和应变 $\\varepsilon(t)$ 的关系如下：\n$$ \\sigma(t) = \\int_{0}^{t} G(t-t') \\frac{d\\varepsilon(t')}{dt'} dt' $$\n$$ \\varepsilon(t) = \\int_{0}^{t} J(t-t') \\frac{d\\sigma(t')}{dt'} dt' $$\n此处，$G(t)$ 是应力松弛模量，定义为对单位阶跃应变的应力响应；$J(t)$ 是蠕变柔量，定义为对单位阶跃应力的应变响应。\n\n首先，我们推导由突加的恒定单轴应变 $\\varepsilon(t) = \\varepsilon_{0}H(t)$（其中 $H(t)$ 是亥维赛德阶跃函数，$\\varepsilon_0$ 是一个常数）引起的应力松弛响应 $\\sigma(t)$。应变率由时间导数给出：\n$$ \\frac{d\\varepsilon(t)}{dt} = \\frac{d}{dt} [\\varepsilon_{0}H(t)] = \\varepsilon_{0} \\delta(t) $$\n其中 $\\delta(t)$ 是狄拉克 $\\delta$ 函数。将此代入第一个遗传积分，我们得到 $t  0$ 时的应力：\n$$ \\sigma(t) = \\int_{0}^{t} G(t-t') (\\varepsilon_{0} \\delta(t')) dt' $$\n根据狄拉克 $\\delta$ 函数的筛选性质，即 $\\int f(x)\\delta(x-a)dx = f(a)$，该积分的计算结果为：\n$$ \\sigma(t) = \\varepsilon_{0} G(t-0) = \\varepsilon_{0} G(t) $$\n这证实了对应于阶跃应变的应力响应与松弛模量本身成正比。使用给定的 $G(t) = G_{\\infty}+\\bigl(G_{0}-G_{\\infty}\\bigr)\\exp\\!\\bigl(-t/\\tau\\bigr)$ 表达式，对于 $t  0$ 的应力松弛为：\n$$ \\sigma(t) = \\varepsilon_{0} \\left[ G_{\\infty} + (G_0 - G_{\\infty})\\exp(-t/\\tau) \\right] $$\n\n其次，我们推导由突加的恒定单轴应力 $\\sigma(t) = \\sigma_{0}H(t)$ 引起的蠕变应变响应 $\\varepsilon(t)$。应力率为：\n$$ \\frac{d\\sigma(t)}{dt} = \\frac{d}{dt} [\\sigma_{0}H(t)] = \\sigma_{0} \\delta(t) $$\n将此代入第二个遗传积分，我们得到 $t  0$ 时的应变：\n$$ \\varepsilon(t) = \\int_{0}^{t} J(t-t') (\\sigma_{0} \\delta(t')) dt' = \\sigma_{0} J(t-0) = \\sigma_{0} J(t) $$\n为求得 $\\varepsilon(t)$，我们必须首先从给定的松弛模量 $G(t)$ 确定蠕变柔量 $J(t)$。$G(t)$ 和 $J(t)$ 之间的关系在拉普拉斯域中建立最为方便。令 $\\hat{f}(s) = \\mathcal{L}\\{f(t)\\}$ 表示函数 $f(t)$ 的拉普拉斯变换。在拉普拉斯域中，遗传积分变成了代数关系：\n$$ \\hat{\\sigma}(s) = s \\hat{G}(s) \\hat{\\varepsilon}(s) \\quad \\text{和} \\quad \\hat{\\varepsilon}(s) = s \\hat{J}(s) \\hat{\\sigma}(s) $$\n由此可知，它们的乘积必须为 1：\n$$ (s \\hat{G}(s)) (s \\hat{J}(s)) = 1 \\implies \\hat{J}(s) = \\frac{1}{s^2 \\hat{G}(s)} $$\n我们首先求 $G(t)$ 的拉普拉斯变换：\n$$ \\hat{G}(s) = \\mathcal{L}\\left\\{ G_{\\infty} + (G_0 - G_{\\infty})\\exp(-t/\\tau) \\right\\} = \\frac{G_{\\infty}}{s} + \\frac{G_0 - G_{\\infty}}{s + 1/\\tau} $$\n合并各项得到：\n$$ \\hat{G}(s) = \\frac{G_{\\infty}(s + 1/\\tau) + s(G_0 - G_{\\infty})}{s(s + 1/\\tau)} = \\frac{G_0 s + G_{\\infty}/\\tau}{s(s+1/\\tau)} $$\n现在我们求 $\\hat{J}(s)$：\n$$ \\hat{J}(s) = \\frac{1}{s^2 \\hat{G}(s)} = \\frac{1}{s^2} \\frac{s(s+1/\\tau)}{G_0 s + G_{\\infty}/\\tau} = \\frac{s+1/\\tau}{s(G_0 s + G_{\\infty}/\\tau)} = \\frac{1}{G_0} \\frac{s+1/\\tau}{s(s + G_{\\infty}/(G_0\\tau))} $$\n为了求拉普拉斯逆变换，我们使用部分分式分解：\n$$ \\frac{s+1/\\tau}{s(s + a)} = \\frac{A}{s} + \\frac{B}{s+a} \\quad \\text{其中} \\quad a = \\frac{G_{\\infty}}{G_0\\tau} $$\n系数为：\n$$ A = \\left. \\frac{s+1/\\tau}{s+a} \\right|_{s=0} = \\frac{1/\\tau}{a} = \\frac{1/\\tau}{G_{\\infty}/(G_0\\tau)} = \\frac{G_0}{G_{\\infty}} $$\n$$ B = \\left. \\frac{s+1/\\tau}{s} \\right|_{s=-a} = \\frac{-a+1/\\tau}{-a} = 1 - \\frac{1/\\tau}{a} = 1 - \\frac{G_0}{G_{\\infty}} = \\frac{G_{\\infty}-G_0}{G_{\\infty}} $$\n将这些系数代回 $\\hat{J}(s)$ 的表达式中：\n$$ \\hat{J}(s) = \\frac{1}{G_0} \\left[ \\frac{G_0/G_{\\infty}}{s} + \\frac{(G_{\\infty}-G_0)/G_{\\infty}}{s + G_{\\infty}/(G_0\\tau)} \\right] = \\frac{1}{G_{\\infty} s} - \\frac{G_0-G_{\\infty}}{G_0 G_{\\infty}} \\frac{1}{s + G_{\\infty}/(G_0\\tau)} $$\n进行拉普拉斯逆变换得到蠕变柔量 $J(t)$：\n$$ J(t) = \\mathcal{L}^{-1}\\{\\hat{J}(s)\\} = \\frac{1}{G_{\\infty}} - \\frac{G_0-G_{\\infty}}{G_0 G_{\\infty}} \\exp\\left(-\\frac{G_{\\infty}}{G_0\\tau} t\\right) $$\n该表达式可以重写为：\n$$ J(t) = \\frac{1}{G_{\\infty}} - \\left(\\frac{1}{G_{\\infty}} - \\frac{1}{G_0}\\right) \\exp\\left(-\\frac{G_{\\infty}}{G_0\\tau} t\\right) $$\n最后，蠕变应变为 $\\varepsilon(t) = \\sigma_0 J(t)$：\n$$ \\varepsilon(t) = \\sigma_0 \\left[ \\frac{1}{G_{\\infty}} - \\left(\\frac{1}{G_{\\infty}} - \\frac{1}{G_0}\\right) \\exp\\left(-\\frac{G_{\\infty}}{G_0\\tau} t\\right) \\right] $$\n至此，两个所需响应的推导完成。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\sigma_{0} \\left[ \\frac{1}{G_{\\infty}} - \\left(\\frac{1}{G_{\\infty}} - \\frac{1}{G_0}\\right) \\exp\\left(-\\frac{G_{\\infty}}{G_0\\tau} t\\right) \\right]  \\varepsilon_{0} \\left[ G_{\\infty} + \\left(G_0 - G_{\\infty}\\right)\\exp\\left(-\\frac{t}{\\tau}\\right) \\right]\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "虽然解析推导对于理解基本模型至关重要，但在处理复杂的加载历史或材料模型时，数值方法是不可或缺的。本练习旨在搭建从连续理论到离散计算的桥梁，您需要将玻尔兹曼叠加原理的积分形式转化为可执行的离散卷积算法。通过直接实现这一卷积过程并分析其计算成本，您将为进行更复杂的粘弹性模拟打下坚实的基础。",
            "id": "4093615",
            "problem": "考虑一个由玻尔兹曼叠加原理描述的一维、等温、小变形线性粘弹性材料。其因果本构关系由以下遗传积分给出\n$$\\tau(t) = \\int_{0}^{t} G(t-s)\\,\\mathrm{d}\\gamma(s),\\quad \\gamma(t) = \\int_{0}^{t} J(t-s)\\,\\mathrm{d}\\tau(s),$$\n其中，$\\tau(t)$ 是剪切应力（单位：帕斯卡），$\\gamma(t)$ 是剪切应变（无量纲），$G(t)$ 是应力松弛模量（单位：帕斯卡），$J(t)$ 是蠕变柔量（单位：逆帕斯卡）。假设时间是均匀离散的，对于整数 $n \\ge 0$，有 $t_n = n\\,\\Delta t$，并定义增量 $\\Delta\\gamma_m = \\gamma(t_m^{+}) - \\gamma(t_m^{-})$ 和 $\\Delta\\tau_m = \\tau(t_m^{+}) - \\tau(t_m^{-})$。本构关系的离散因果卷积形式为\n$$\\tau_n = \\sum_{m=0}^{n} G_{n-m}\\,\\Delta\\gamma_m,\\quad \\gamma_n = \\sum_{m=0}^{n} J_{n-m}\\,\\Delta\\tau_m,$$\n其中，对于整数 $k \\ge 0$，有 $G_k = G(k\\,\\Delta t)$ 和 $J_k = J(k\\,\\Delta t)$。\n\n任务1 (推导与算法设计)：仅从玻尔兹曼叠加原理和上述离散采样的定义出发，推导出一个离散卷积方案，用于计算 $n=0,\\dots,N$ 时的 $\\tau_n$ 和 $\\gamma_n$。该方案使用两个序列 $\\{G_k\\}_{k=0}^{N}$、$\\{J_k\\}_{k=0}^{N}$ 以及增量序列 $\\{\\Delta\\gamma_m\\}_{m=0}^{N}$、$\\{\\Delta\\tau_m\\}_{m=0}^{N}$。您的推导必须清楚地展示积分关系是如何导出离散求和的。\n\n任务2 (计算复杂度和内存分析)：对于两个长度为 $N+1$ 的实值序列的一般离散因果卷积，其定义为\n$$y_n = \\sum_{m=0}^{n} k_{n-m}\\,x_m,\\quad n=0,\\dots,N,$$\n分析：\n1. 直接嵌套循环方案的运算计数。按照惯例，每次标量乘法计为一次运算，每次标量加法也计为一次运算。请为计算整个输出序列 $\\{y_n\\}_{n=0}^{N}$ 所需的总乘法次数和总加法次数提供封闭形式的表达式。\n2. 基于快速傅里叶变换 (FFT) 的算法的运算计数，该算法通过补零将循环卷积转换为线性卷积。假设您将两个序列都补零至长度 $L$，其中 $L$ 是大于或等于 $(N+1)+(N+1)-1$ 的下一个2的幂次方，并且您执行两次正向复值FFT、一次逆向复值FFT和一次逐点复数乘法。使用标准估算，即长度为 $L$ 的一次复值FFT需要大约 $5\\,L\\,\\log_2 L$ 次浮点运算，而全频谱的逐点复数乘法和逐点复数加法总共需要 $2L$ 次浮点运算。请为一次卷积以及通过两次此类卷积计算 $\\tau_n$ 和 $\\gamma_n$ 所需的总浮点运算提供一个公式。\n3. 两种方法的内存需求，基于以下明确假设：所有实值数组均以双精度（每个元素 $8$ 字节）存储，所有复值数组均以双精度复数（每个元素 $16$ 字节）存储。对于直接法，假设您存储六个长度为 $N+1$ 的实数数组：$\\{G_k\\}$、$\\{J_k\\}$、$\\{\\Delta\\gamma_m\\}$、$\\{\\Delta\\tau_m\\}$、$\\{\\tau_n\\}$ 和 $\\{\\gamma_n\\}$。对于基于FFT的方法，假设除了同样的六个实数数组外，在一次卷积的峰值期间，还额外存储五个长度为 $L$ 的复数数组（两个补零输入、两个正向变换频谱和一个用于保存频谱乘积或逆变换输出的工作空间）。请为每种方法所需的总字节数提供公式。\n\n任务3 (实现与测试套件)：实现一个程序，通过离散卷积和为以下三个测试用例计算 $\\tau_n$ 和 $\\gamma_n$。该程序还必须按照任务2中的规定，为每个测试用例计算并报告总运算计数和内存需求。使用以下测试套件，它共同探究一个一般情况、一个边界情况和一个大规模情况：\n1. 正常路径情况：使用麦克斯韦材料，其模量 $E = 1.0\\times 10^6$ 帕斯卡，松弛时间 $\\tau = 2.0$ 秒，时间步长 $\\Delta t = 0.5$ 秒，以及 $N=8$。定义 $G_k = E\\,\\exp\\!\\left(-\\frac{k\\,\\Delta t}{\\tau}\\right)$ 和 $J_k = \\frac{1}{E} + \\frac{k\\,\\Delta t}{E\\,\\tau}$。使用恒定的剪切速率增量序列 $\\Delta\\gamma_m = \\dot{\\gamma}\\,\\Delta t$，其中对于所有 $m$，$\\dot{\\gamma} = 0.004$ 每秒，以及一个阶跃应力增量 $\\Delta\\tau_0 = 100$ 帕斯卡，且当 $m \\ge 1$ 时 $\\Delta\\tau_m = 0$。报告 $\\tau_N$（单位：帕斯卡）和 $\\gamma_N$（无量纲）。\n2. 边界情况：使用 $E = 2.0\\times 10^6$ 帕斯卡，$\\tau = 1.0$ 秒，$\\Delta t = 1.0$ 秒，以及 $N=0$。定义 $G_0 = E$ 和 $J_0 = \\frac{1}{E}$。使用 $\\Delta\\gamma_0 = 0.01$（无量纲）和 $\\Delta\\tau_0 = 100$ 帕斯卡。报告 $\\tau_0$（单位：帕斯卡）和 $\\gamma_0$（无量纲）。\n3. 大规模情况：使用 $E = 5.0\\times 10^5$ 帕斯卡，$\\tau = 0.2$ 秒，$\\beta = 0.5$（无量纲），$\\Delta t = 0.01$ 秒，以及 $N=1024$。定义一个拉伸指数应力松弛模量 $G_k = E\\,\\exp\\!\\left(-\\left(\\frac{k\\,\\Delta t}{\\tau}\\right)^{\\beta}\\right)$，以及一个幂律蠕变柔量 $J_k = \\frac{1}{E} + A\\,(k\\,\\Delta t)^{\\alpha}$，其中 $A = 1.0\\times 10^{-4}$ 逆帕斯卡-秒的 $-\\alpha$ 次方，$\\alpha = 0.3$（无量纲）。使用 $\\Delta\\gamma_m = \\gamma_{\\mathrm{amp}}\\sin(2\\pi f (m+1)\\Delta t)$，其中 $\\gamma_{\\mathrm{amp}} = 1.0\\times 10^{-3}$（无量纲）且 $f = 5.0$ 赫兹，以及 $\\Delta\\tau_m = \\tau_{\\mathrm{amp}}\\cos(2\\pi f (m+1)\\Delta t)$，其中 $\\tau_{\\mathrm{amp}} = 50$ 帕斯卡。报告 $\\tau_N$（单位：帕斯卡）和 $\\gamma_N$（无量纲）。\n\n对于每个测试用例，您必须按顺序计算并输出以下六个值：\n1. 最终应力 $\\tau_N$（单位：帕斯卡）。\n2. 最终应变 $\\gamma_N$（无量纲）。\n3. 计算 $\\{\\tau_n\\}$ 和 $\\{\\gamma_n\\}$ 的直接法的总运算计数（整数），通过对两次卷积的乘法和加法求和得到。\n4. 计算 $\\{\\tau_n\\}$ 和 $\\{\\gamma_n\\}$ 的快速傅里叶变换 (FFT) 法的总运算计数（整数），使用任务2中的估算和指定的补零长度 $L$。\n5. 直接法的总内存需求（整数，单位：字节），使用任务2中的存储假设。\n6. FFT法的总内存需求（整数，单位：字节），使用任务2中的存储假设。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表聚合了案例1的六个值，然后是案例2的六个值，最后是案例3的六个值。例如，输出格式必须为\n$$[\\tau_N^{(1)},\\gamma_N^{(1)},\\text{ops\\_direct}^{(1)},\\text{ops\\_fft}^{(1)},\\text{mem\\_direct}^{(1)},\\text{mem\\_fft}^{(1)},\\tau_N^{(2)},\\gamma_N^{(2)},\\text{ops\\_direct}^{(2)},\\text{ops\\_fft}^{(2)},\\text{mem\\_direct}^{(2)},\\text{mem\\_fft}^{(2)},\\tau_N^{(3)},\\gamma_N^{(3)},\\text{ops\\_direct}^{(3)},\\text{ops\\_fft}^{(3)},\\text{mem\\_direct}^{(3)},\\text{mem\\_fft}^{(3)}].$$\n所有应力单位必须是帕斯卡，应变为无量纲，并且三角函数中的角频率参数必须使用弧度，因为当 $f$ 的单位是赫兹且 $\\Delta t$ 的单位是秒时，$2\\pi f (m+1)\\Delta t$ 的单位是弧度。",
            "solution": "出发点是线性粘弹性的玻尔兹曼叠加原理，该原理表达了应力对一系列应变增量的响应，以及应变对一系列应力增量的响应。对于小变形，线性和时不变性意味着在时间 $t$ 的响应是过去增量的加权叠加：\n$$\\tau(t) = \\int_{0}^{t} G(t-s)\\,\\mathrm{d}\\gamma(s),\\quad \\gamma(t) = \\int_{0}^{t} J(t-s)\\,\\mathrm{d}\\tau(s).$$\n这里，$G(t)$ 和 $J(t)$ 分别是表征松弛和蠕变的材料函数。度量 $\\mathrm{d}\\gamma(s)$ 表示在时间 $s$ 的应变增量。如果我们假设对于整数 $n \\ge 0$ 进行均匀采样 $t_n = n\\,\\Delta t$，并定义跳跃增量 $\\Delta\\gamma_m = \\gamma(t_m^{+}) - \\gamma(t_m^{-})$，那么在分段常数增量过程上的积分就变成了加权增量的和。具体来说，对于因果核（当时间为负时为零），该积分在离散网格上变为一个黎曼-斯蒂尔杰斯和：\n$$\\tau(t_n) \\approx \\sum_{m=0}^{n} G(t_n - t_m)\\,\\Delta\\gamma_m = \\sum_{m=0}^{n} G((n-m)\\Delta t)\\,\\Delta\\gamma_m.$$\n对于整数 $k \\ge 0$，定义 $G_k = G(k\\,\\Delta t)$，因此 $G_{n-m} = G((n-m)\\Delta t)$。那么在第 $n$ 步的离散应力为\n$$\\tau_n = \\sum_{m=0}^{n} G_{n-m}\\,\\Delta\\gamma_m.$$\n根据对蠕变柔量和应力增量的相同推理，我们定义 $\\Delta\\tau_m = \\tau(t_m^{+}) - \\tau(t_m^{-})$ 和 $J_k = J(k\\,\\Delta t)$。在第 $n$ 步的离散应变为\n$$\\gamma_n = \\sum_{m=0}^{n} J_{n-m}\\,\\Delta\\tau_m.$$\n这些就是离散因果卷积。\n\n为了高效地计算这些卷积，我们考虑两种算法。直接法对每个 $n$ 求从 $m=0$ 到 $n$ 的和，这导致了内部循环长度不断增加的嵌套循环。为计算完整输出序列 $\\{y_n\\}_{n=0}^{N}$（其中 $y_n = \\sum_{m=0}^{n} k_{n-m} x_m$）所需的标量乘法总数为\n$$M_{\\text{direct}}(N) = \\sum_{n=0}^{N} (n+1) = \\frac{(N+1)(N+2)}{2}.$$\n标量加法的总数为\n$$A_{\\text{direct}}(N) = \\sum_{n=0}^{N} n = \\frac{N(N+1)}{2}.$$\n因此，一次卷积的乘法和加法总计为 $M_{\\text{direct}}(N) + A_{\\text{direct}}(N)$。对于我们的粘弹性问题，我们执行两次卷积（一次用于 $\\tau_n$，一次用于 $\\gamma_n$），所以两者的直接运算总数为\n$$\\text{ops}_{\\text{direct}}(N) = 2\\left(\\frac{(N+1)(N+2)}{2} + \\frac{N(N+1)}{2}\\right) = 2(N+1)^2.$$\n或者，如果分别报告乘法和加法，它们的总和为 $2 M_{\\text{direct}}(N) + 2 A_{\\text{direct}}(N)$。\n\n另一种方法是使用快速傅里叶变换 (FFT) 将卷积转换成频域中的逐点乘法。对于实数序列的线性（非循环）卷积，我们将两个序列都补零至长度 $L$，该长度是满足 $L \\ge (N+1)+(N+1)-1 = 2N+1$ 的2的幂次方。如果我们使用复值FFT（为了便于计数），那么一次卷积的运算计数包括两次正向复数FFT、一次逆向复数FFT和一次逐点复数乘法。对于长度为 $L$ 的复数FFT，一个标准的估算为 $5\\,L\\,\\log_2 L$ 次浮点运算，而逐点复数乘法和相关的加法（对频谱贡献求和或组合实部和虚部）总共大约需要 $2L$ 次浮点运算。因此，对于一次卷积，\n$$\\text{ops}_{\\text{fft}}^{\\text{one}}(L) \\approx 2\\cdot 5 L \\log_2 L + 1\\cdot 5 L \\log_2 L + 2L = 15 L \\log_2 L + 2L.$$\n为了通过两次这样的卷积计算 $\\tau_n$ 和 $\\gamma_n$，\n$$\\text{ops}_{\\text{fft}}(L) \\approx 2\\left(15 L \\log_2 L + 2L\\right) = 30 L \\log_2 L + 4L.$$\n这是一个实际的估算；它捕捉了主要渐近标度 $\\mathcal{O}(L \\log L)$ 并为给定的 $L$ 提供了一个定量值。\n\n关于内存，在明确的存储假设下，直接法持有六个长度为 $N+1$ 的实数数组：\n$\\{G_k\\}$、$\\{J_k\\}$、$\\{\\Delta\\gamma_m\\}$、$\\{\\Delta\\tau_m\\}$、$\\{\\tau_n\\}$ 和 $\\{\\gamma_n\\}$。\n使用双精度（每个实数 $8$ 字节），总存储量为\n$$\\text{mem}_{\\text{direct}}(N) = 6\\,(N+1)\\cdot 8\\ \\text{bytes}.$$\n对于基于FFT的方法，在一次卷积的峰值期间，我们还持有五个长度为 $L$ 的复数数组：两个补零输入、两个正向变换频谱和一个工作空间（用于存储频谱乘积或逆变换输出）。使用双精度复数（每个复数 $16$ 字节），总存储量为\n$$\\text{mem}_{\\text{fft}}(N,L) = 6\\,(N+1)\\cdot 8\\ \\text{bytes} + 5\\,L\\cdot 16\\ \\text{bytes}.$$\n这些公式明确地量化了内存需求。\n\n我们现在为每种情况定义测试套件和序列。\n\n情况1 (麦克斯韦，正常路径): 对于 $E = 1.0\\times 10^6$ 帕斯卡，$\\tau = 2.0$ 秒，$\\Delta t = 0.5$ 秒，以及 $N=8$，定义\n$$G_k = E\\,\\exp\\left(-\\frac{k\\,\\Delta t}{\\tau}\\right),\\quad J_k = \\frac{1}{E} + \\frac{k\\,\\Delta t}{E\\,\\tau}.$$\n设置 $\\Delta\\gamma_m = \\dot{\\gamma}\\,\\Delta t$，其中对于所有 $m$，$\\dot{\\gamma} = 0.004$ 每秒，因此对于所有 $m=0,\\dots,8$，$\\Delta\\gamma_m = 0.002$。设置 $\\Delta\\tau_0 = 100$ 帕斯卡，且当 $m \\ge 1$ 时 $\\Delta\\tau_m = 0$。计算 $\\tau_n = \\sum_{m=0}^{n} G_{n-m}\\,\\Delta\\gamma_m$ 和 $\\gamma_n = \\sum_{m=0}^{n} J_{n-m}\\,\\Delta\\tau_m$，然后报告 $\\tau_8$ 和 $\\gamma_8$。\n\n情况2 (边界, $N=0$): 对于 $E = 2.0\\times 10^6$ 帕斯卡，$\\tau = 1.0$ 秒，$\\Delta t = 1.0$ 秒，以及 $N=0$，定义 $G_0 = E$，$J_0 = \\frac{1}{E}$。使用 $\\Delta\\gamma_0 = 0.01$ 和 $\\Delta\\tau_0 = 100$ 帕斯卡。计算平凡和 $\\tau_0 = G_0\\,\\Delta\\gamma_0$ 和 $\\gamma_0 = J_0\\,\\Delta\\tau_0$，然后报告这些值。\n\n情况3 (大规模, 拉伸指数和幂律): 对于 $E = 5.0\\times 10^5$ 帕斯卡，$\\tau = 0.2$ 秒，$\\beta = 0.5$，$\\Delta t = 0.01$ 秒，以及 $N=1024$，定义\n$$G_k = E\\,\\exp\\left(-\\left(\\frac{k\\,\\Delta t}{\\tau}\\right)^{\\beta}\\right),\\quad J_k = \\frac{1}{E} + A\\,(k\\,\\Delta t)^{\\alpha},$$\n其中 $A = 1.0\\times 10^{-4}$ 逆帕斯卡-秒的 $-\\alpha$ 次方，$\\alpha=0.3$。使用 $\\Delta\\gamma_m = \\gamma_{\\mathrm{amp}}\\sin(2\\pi f (m+1)\\Delta t)$，其中 $\\gamma_{\\mathrm{amp}} = 1.0\\times 10^{-3}$ 且 $f=5.0$ 赫兹，以及 $\\Delta\\tau_m = \\tau_{\\mathrm{amp}}\\cos(2\\pi f (m+1)\\Delta t)$，其中 $\\tau_{\\mathrm{amp}} = 50$。计算 $n=0,\\dots,1024$ 时的 $\\tau_n$ 和 $\\gamma_n$，并报告 $\\tau_{1024}$ 和 $\\gamma_{1024}$。\n\n对于每种情况，按如下方式计算运算计数和内存使用量：\n- 直接法两次卷积的运算：$\\text{ops}_{\\text{direct}}(N) = 2\\left(M_{\\text{direct}}(N) + A_{\\text{direct}}(N)\\right)$，其中 $M_{\\text{direct}}(N) = \\frac{(N+1)(N+2)}{2}$ 且 $A_{\\text{direct}}(N) = \\frac{N(N+1)}{2}$。\n- FFT法两次卷积的运算：选择 $L$ 为满足 $L \\ge 2(N+1)-1$ 的下一个2的幂次方，然后 $\\text{ops}_{\\text{fft}}(L) = 30\\,L\\,\\log_2 L + 4L$。\n- 直接法内存：$\\text{mem}_{\\text{direct}}(N) = 6\\,(N+1)\\cdot 8$ 字节。\n- FFT法内存：$\\text{mem}_{\\text{fft}}(N,L) = 6\\,(N+1)\\cdot 8 + 5\\,L\\cdot 16$ 字节。\n\n您的程序必须根据情况定义来构造序列，计算离散卷积，确定最终值，并使用上述公式计算运算计数和内存字节数。最终输出必须是形如\n$$[\\tau_N^{(1)},\\gamma_N^{(1)},\\text{ops\\_direct}^{(1)},\\text{ops\\_fft}^{(1)},\\text{mem\\_direct}^{(1)},\\text{mem\\_fft}^{(1)},\\tau_N^{(2)},\\gamma_N^{(2)},\\text{ops\\_direct}^{(2)},\\text{ops\\_fft}^{(2)},\\text{mem\\_direct}^{(2)},\\text{mem\\_fft}^{(2)},\\tau_N^{(3)},\\gamma_N^{(3)},\\text{ops\\_direct}^{(3)},\\text{ops\\_fft}^{(3)},\\text{mem\\_direct}^{(3)},\\text{mem\\_fft}^{(3)}]$$\n的单行文本，其中应力单位为帕斯卡，应变为无量纲。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef next_power_of_two(n: int) - int:\n    \"\"\"Return the next power of two = n.\"\"\"\n    if n == 1:\n        return 1\n    return 1  (int(np.ceil(np.log2(n))))\n\ndef direct_ops_counts(N: int) - int:\n    \"\"\"\n    Total operation count (multiplications + additions) for two direct convolutions\n    over sequences of length N+1. For one convolution:\n      M = ((N+1)(N+2))/2 multiplications\n      A = (N(N+1))/2 additions\n    Total ops for one = M + A; for two = 2*(M + A).\n    \"\"\"\n    M = (N + 1) * (N + 2) // 2\n    A = N * (N + 1) // 2\n    return 2 * (M + A)\n\ndef fft_ops_counts(L: int) - int:\n    \"\"\"\n    Total operation count for two FFT-based convolutions using the estimate:\n    For one convolution: 15*L*log2(L) + 2*L\n    For two convolutions: 30*L*log2(L) + 4*L\n    \"\"\"\n    if L == 1:\n        # log2(1) = 0, so ops reduce to just the pointwise operations estimate\n        return 2 * (2 * L)\n    return int(30 * L * np.log2(L) + 4 * L)\n\ndef mem_direct_bytes(N: int) - int:\n    \"\"\"\n    Memory for direct method: six real arrays of length N+1, 8 bytes each.\n    Arrays: G, J, dgamma, dtau, tau, gamma.\n    \"\"\"\n    return 6 * (N + 1) * 8\n\ndef mem_fft_bytes(N: int, L: int) - int:\n    \"\"\"\n    Memory for FFT method: six real arrays of length N+1 (8 bytes each),\n    plus five complex arrays of length L (16 bytes each) at peak during one convolution.\n    \"\"\"\n    return 6 * (N + 1) * 8 + 5 * L * 16\n\ndef causal_convolution(kernel: np.ndarray, increments: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute causal discrete convolution y_n = sum_{m=0}^n kernel[n-m] * increments[m].\n    Implemented via full linear convolution and truncation to first N+1 terms.\n    \"\"\"\n    N = len(kernel) - 1\n    # Linear convolution; numpy.convolve returns length len(kernel)+len(increments)-1\n    y_full = np.convolve(kernel, increments)\n    return y_full[:N + 1]\n\ndef case1():\n    # Parameters\n    E = 1.0e6  # Pa\n    tau_relax = 2.0  # s\n    dt = 0.5  # s\n    N = 8\n    # Kernels\n    k = np.arange(N + 1, dtype=np.float64)\n    G = E * np.exp(- (k * dt) / tau_relax)\n    J = (1.0 / E) + (k * dt) / (E * tau_relax)\n    # Increments\n    gamma_dot = 0.004  # s^{-1}\n    dgamma = np.full(N + 1, gamma_dot * dt, dtype=np.float64)\n    dtau = np.zeros(N + 1, dtype=np.float64)\n    dtau[0] = 100.0  # Pa\n    # Convolutions\n    tau = causal_convolution(G, dgamma)\n    gamma = causal_convolution(J, dtau)\n    # Final values\n    tau_N = float(tau[-1])\n    gamma_N = float(gamma[-1])\n    # Complexity and memory\n    ops_direct = direct_ops_counts(N)\n    L = next_power_of_two(2 * (N + 1) - 1)\n    ops_fft = fft_ops_counts(L)\n    mem_direct = mem_direct_bytes(N)\n    mem_fft = mem_fft_bytes(N, L)\n    return tau_N, gamma_N, ops_direct, ops_fft, mem_direct, mem_fft\n\ndef case2():\n    # Parameters\n    E = 2.0e6  # Pa\n    dt = 1.0  # s\n    N = 0\n    # Kernels\n    G = np.array([E], dtype=np.float64)\n    J = np.array([1.0 / E], dtype=np.float64)\n    # Increments\n    dgamma = np.array([0.01], dtype=np.float64)\n    dtau = np.array([100.0], dtype=np.float64)  # Pa\n    # Convolutions\n    tau = causal_convolution(G, dgamma)\n    gamma = causal_convolution(J, dtau)\n    tau_N = float(tau[-1])\n    gamma_N = float(gamma[-1])\n    # Complexity and memory\n    ops_direct = direct_ops_counts(N)\n    L = next_power_of_two(2 * (N + 1) - 1)\n    ops_fft = fft_ops_counts(L)\n    mem_direct = mem_direct_bytes(N)\n    mem_fft = mem_fft_bytes(N, L)\n    return tau_N, gamma_N, ops_direct, ops_fft, mem_direct, mem_fft\n\ndef case3():\n    # Parameters\n    E = 5.0e5  # Pa\n    tau_relax = 0.2  # s\n    beta = 0.5  # dimensionless\n    dt = 0.01  # s\n    N = 1024\n    # Kernels\n    k = np.arange(N + 1, dtype=np.float64)\n    G = E * np.exp(- ((k * dt) / tau_relax) ** beta)\n    A = 1.0e-4  # Pa^{-1} * s^{-alpha}\n    alpha = 0.3\n    J = (1.0 / E) + A * (k * dt) ** alpha\n    # Increments\n    f = 5.0  # Hz\n    gamma_amp = 1.0e-3\n    tau_amp = 50.0  # Pa\n    # Note: use (m+1)*dt inside trig as specified\n    m = np.arange(N + 1, dtype=np.float64)\n    angles = 2.0 * np.pi * f * (m + 1) * dt\n    dgamma = gamma_amp * np.sin(angles)\n    dtau = tau_amp * np.cos(angles)\n    # Convolutions\n    tau = causal_convolution(G, dgamma)\n    gamma = causal_convolution(J, dtau)\n    tau_N = float(tau[-1])\n    gamma_N = float(gamma[-1])\n    # Complexity and memory\n    ops_direct = direct_ops_counts(N)\n    L = next_power_of_two(2 * (N + 1) - 1)\n    ops_fft = fft_ops_counts(L)\n    mem_direct = mem_direct_bytes(N)\n    mem_fft = mem_fft_bytes(N, L)\n    return tau_N, gamma_N, ops_direct, ops_fft, mem_direct, mem_fft\n\ndef solve():\n    # Define the test cases from the problem statement.\n    results = []\n    for fn in (case1, case2, case3):\n        tau_N, gamma_N, ops_direct, ops_fft, mem_direct, mem_fft = fn()\n        results.extend([\n            tau_N, gamma_N,\n            int(ops_direct), int(ops_fft),\n            int(mem_direct), int(mem_fft)\n        ])\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "直接卷积算法虽然直观，但其计算成本随时间步数的增加而呈二次方增长，这在长时间模拟中是难以接受的。本练习将介绍一种高效的计算技术，即针对普罗尼级数（Prony series）形式的松弛模量，推导并实现递归更新算法。这种方法利用了指数函数的特性，将每一步的计算成本降低到与历史步数无关的常数级别，是现代计算流体动力学和固体力学软件中实现粘弹性模型的标准技术。",
            "id": "4093678",
            "problem": "考虑一个小应变、一维线性粘弹性材料，该材料由Boltzmann叠加原理（BSP）描述，其中对应于给定应变历史的应力响应由松弛模量核与应变率的卷积给出。具体而言，令时间 $t$ 处的应力为\n$$\\sigma(t) = \\int_{0}^{t} E(t - \\xi) \\,\\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi,$$\n其中 $\\varepsilon(t)$ 是应变，$E(t)$ 是松弛模量。假设一个广义Maxwell模型（GMM），其中松弛模量是一个包含 $M$ 个Maxwell单元和一个平衡弹性贡献的Prony级数，\n$$E(t) = E_{\\infty} + \\sum_{k=1}^{M} E_k\\, e^{-t/\\tau_k},$$\n其中 $E_{\\infty}$ 是平衡模量，对于每个模式 $k$，$E_k$ 是模量，$\\tau_k$ 是松弛时间。\n\n你需要仅从第一性原理和基本定义出发，推导一个与每个Maxwell单元相关的内部状态变量的递归逐时间步更新公式，该公式能够在离散时间 $t_n = n\\,\\Delta t$ 下计算 $\\sigma(t_n)$，且每个Maxwell单元在每个时间步的计算工作量为 $\\mathcal{O}(1)$（即与过去时间步数 $n$ 无关）。推导必须从BSP出发，使用 $E(t)$ 的Prony级数表示，并假设在每个时间区间 $[t_{n-1}, t_n]$ 内应变率是分段常数，其中 $\\varepsilon(t)$ 在 $\\varepsilon^{n-1} = \\varepsilon(t_{n-1})$ 和 $\\varepsilon^{n} = \\varepsilon(t_n)$ 之间进行线性插值。定义并使用物理上对应于每个Maxwell单元所承受应力的内部变量。\n\n然后，实现两种不同的算法：\n- 一种直接卷积基准算法，该算法在分段恒定应变率的假设下，通过对所有过去区间和所有Maxwell单元的贡献求和来精确计算 $\\sigma^n = \\sigma(t_n)$。\n- 使用推导出的内部变量的递归更新算法。\n\n对于以下每个测试用例，使用两种方法计算应力时间序列 $\\{\\sigma^n\\}_{n=0}^{N-1}$，并返回所有时间步上的最大绝对差。使用无量纲的应变、单位为帕斯卡（Pa）的模量、单位为秒（s）的时间，并以浮点数形式输出单位为帕斯卡（Pa）的差值。你的程序必须生成单行输出，其中包含按指定格式排列的差值列表。\n\n测试套件：\n1. 正常路径多模式情况。参数：$E_{\\infty} = 1.0\\times 10^{5}$ Pa，模式 $\\{(E_1,\\tau_1)=(2.0\\times 10^{5}\\,\\text{Pa},\\,0.1\\,\\text{s}),\\ (E_2,\\tau_2)=(1.0\\times 10^{5}\\,\\text{Pa},\\,1.0\\,\\text{s}),\\ (E_3,\\tau_3)=(5.0\\times 10^{4}\\,\\text{Pa},\\,10.0\\,\\text{s})\\}$，时间步 $\\Delta t = 0.05$ s，应变序列 $\\{\\varepsilon^n\\}_{n=0}^{9} = [0.0,\\ 0.002,\\ 0.003,\\ 0.0045,\\ 0.0045,\\ 0.003,\\ 0.0035,\\ 0.005,\\ 0.004,\\ 0.004]$。\n2. 具有极快模式和大时间步的边界情况。参数：$E_{\\infty} = 0.0$ Pa，模式 $\\{(E_1,\\tau_1)=(1.0\\times 10^{6}\\,\\text{Pa},\\,0.001\\,\\text{s})\\}$，时间步 $\\Delta t = 0.1$ s，应变序列 $\\{\\varepsilon^n\\}_{n=0}^{4} = [0.0,\\ 0.01,\\ 0.01,\\ 0.01,\\ 0.01]$。\n3. 无Maxwell单元的边缘情况。参数：$E_{\\infty} = 2.0\\times 10^{5}$ Pa，模式 $\\{\\}$（即 $M=0$），时间步 $\\Delta t = 0.02$ s，应变序列 $\\{\\varepsilon^n\\}_{n=0}^{5} = [0.0,\\ 0.001,\\ 0.002,\\ 0.0015,\\ 0.0015,\\ 0.0005]$。\n4. 相对于慢模式的小时间步情况。参数：$E_{\\infty} = 0.0$ Pa，模式 $\\{(E_1,\\tau_1)=(5.0\\times 10^{5}\\,\\text{Pa},\\,10.0\\,\\text{s}),\\ (E_2,\\tau_2)=(3.0\\times 10^{5}\\,\\text{Pa},\\,5.0\\,\\text{s})\\}$，时间步 $\\Delta t = 0.001$ s，应变序列 $\\{\\varepsilon^n\\}_{n=0}^{19} = [0.0,\\ 1.0\\times 10^{-4},\\ 2.0\\times 10^{-4},\\ 3.0\\times 10^{-4},\\ 4.0\\times 10^{-4},\\ 5.0\\times 10^{-4},\\ 6.0\\times 10^{-4},\\ 7.0\\times 10^{-4},\\ 8.0\\times 10^{-4},\\ 9.0\\times 10^{-4},\\ 1.0\\times 10^{-3},\\ 1.1\\times 10^{-3},\\ 1.1\\times 10^{-3},\\ 1.05\\times 10^{-3},\\ 1.0\\times 10^{-3},\\ 9.0\\times 10^{-4},\\ 8.0\\times 10^{-4},\\ 7.0\\times 10^{-4},\\ 6.0\\times 10^{-4},\\ 5.0\\times 10^{-4}]$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），其中每个结果是相应测试用例的最大绝对差值（单位为帕斯卡），表示为浮点数。",
            "solution": "该问题要求从Boltzmann叠加原理（BSP）出发，为广义Maxwell模型（GMM）描述的线性粘弹性材料推导一个用于计算应力的递归更新算法。随后，必须实现此递归算法和直接卷积基准算法，并比较它们的准确性。\n\n分析始于BSP的一维应力分量 $\\sigma(t)$ 的定义积分形式，该应力由应变历史 $\\varepsilon(t)$ 产生：\n$$\n\\sigma(t) = \\int_{0}^{t} E(t - \\xi) \\,\\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi\n$$\n此处假设材料在 $t  0$ 时是静止的，即对于 $t  0$，$\\varepsilon(t)=0$ 且 $\\sigma(t)=0$。GMM的松弛模量 $E(t)$ 由Prony级数给出：\n$$\nE(t) = E_{\\infty} + \\sum_{k=1}^{M} E_k\\, e^{-t/\\tau_k}\n$$\n此处，$E_{\\infty}$ 是长期平衡模量，对应于一个与 $M$ 个Maxwell单元并联的纯弹性弹簧。每个Maxwell单元 $k$ 由一个模量 $E_k$ 和一个松弛时间 $\\tau_k$ 表征。\n\n将 $E(t)$ 的Prony级数表示代入BSP积分中，得到：\n$$\n\\sigma(t) = \\int_{0}^{t} \\left( E_{\\infty} + \\sum_{k=1}^{M} E_k\\, e^{-(t-\\xi)/\\tau_k} \\right) \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi\n$$\n根据积分的线性性质，应力可以分解为一个平衡（纯弹性）分量 $\\sigma_{\\infty}(t)$ 和来自每个Maxwell单元的瞬态（粘弹性）分量 $\\sigma_k(t)$ 的总和：\n$$\n\\sigma(t) = \\sigma_{\\infty}(t) + \\sum_{k=1}^{M} \\sigma_k(t)\n$$\n平衡分量由下式给出：\n$$\n\\sigma_{\\infty}(t) = E_{\\infty} \\int_{0}^{t} \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi = E_{\\infty} [\\varepsilon(t) - \\varepsilon(0)]\n$$\n假设初始应变为零，即 $\\varepsilon(0)=0$，则上式简化为 $\\sigma_{\\infty}(t) = E_{\\infty}\\,\\varepsilon(t)$。\n\n每个瞬态分量 $\\sigma_k(t)$ 由下式给出：\n$$\n\\sigma_k(t) = \\int_{0}^{t} E_k\\, e^{-(t-\\xi)/\\tau_k} \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi\n$$\n\n问题指定在离散时间 $t_n = n\\,\\Delta t$（其中 $n=0, 1, 2, \\dots$）进行计算。应变历史由序列 $\\{\\varepsilon^n\\}$ 定义，其中 $\\varepsilon^n = \\varepsilon(t_n)$。假设在每个区间 $[t_{i-1}, t_i]$ 内应变率是分段常数，这意味着：\n$$\n\\frac{d\\varepsilon(t)}{dt} = \\frac{\\varepsilon^i - \\varepsilon^{i-1}}{\\Delta t} = \\frac{\\Delta\\varepsilon^i}{\\Delta t} \\quad \\text{for } t \\in (t_{i-1}, t_i]\n$$\n\n首先，我们构建直接卷积算法。在时间 $t_n$ 的总应力，记为 $\\sigma^n$，是：\n$$\n\\sigma^n = E_{\\infty}\\,\\varepsilon^n + \\sum_{k=1}^{M} \\sigma_k^n\n$$\n瞬态分量 $\\sigma_k^n = \\sigma_k(t_n)$ 是通过将积分分解为对过去时间区间的求和得到的：\n$$\n\\sigma_k^n = \\sum_{i=1}^{n} \\int_{t_{i-1}}^{t_i} E_k\\, e^{-(t_n-\\xi)/\\tau_k} \\left(\\frac{\\Delta\\varepsilon^i}{\\Delta t}\\right) d\\xi\n$$\n对于每个区间 $i$，项 $\\frac{\\Delta\\varepsilon^i}{\\Delta t}$ 是常数。该积分可以解析求解：\n$$\n\\int_{t_{i-1}}^{t_i} e^{-(t_n-\\xi)/\\tau_k} d\\xi = \\left[ \\tau_k\\, e^{-(t_n-\\xi)/\\tau_k} \\right]_{\\xi=t_{i-1}}^{\\xi=t_i} = \\tau_k \\left( e^{-(t_n-t_i)/\\tau_k} - e^{-(t_n-t_{i-1})/\\tau_k} \\right)\n$$\n代入 $t_n = n\\,\\Delta t$，$t_i = i\\,\\Delta t$ 和 $t_{i-1}=(i-1)\\Delta t$：\n$$\n\\int_{t_{i-1}}^{t_i} e^{-(t_n-\\xi)/\\tau_k} d\\xi = \\tau_k \\left( e^{-(n-i)\\Delta t/\\tau_k} - e^{-(n-i+1)\\Delta t/\\tau_k} \\right)\n$$\n因此，模式 $k$ 的贡献是：\n$$\n\\sigma_k^n = \\sum_{i=1}^{n} E_k \\left(\\frac{\\Delta\\varepsilon^i}{\\Delta t}\\right) \\tau_k \\left( e^{-(n-i)\\Delta t/\\tau_k} - e^{-(n-i+1)\\Delta t/\\tau_k} \\right)\n$$\n总应力需要对所有模式 $k$ 和所有过去的时间步 $i$ 进行求和。使用此方法找到 $\\sigma^n$ 的计算工作量为 $\\mathcal{O}(n M)$，它随着每个时间步的增加而增长。\n\n接下来，我们推导所需的递归更新公式。此推导的内部变量将是 $\\sigma_k^n$，其物理意义是第 $k$ 个Maxwell单元在时间 $t_n$ 时所承受的应力。我们再次从 $\\sigma_k^n$ 的积分开始：\n$$\n\\sigma_k^n = \\int_{0}^{t_n} E_k\\, e^{-(t_n-\\xi)/\\tau_k} \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi\n$$\n我们在前一个时间步 $t_{n-1}$ 处分割积分：\n$$\n\\sigma_k^n = \\int_{0}^{t_{n-1}} E_k\\, e^{-(t_n-\\xi)/\\tau_k} \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi + \\int_{t_{n-1}}^{t_n} E_k\\, e^{-(t_n-\\xi)/\\tau_k} \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi\n$$\n让我们分析第一个积分项。我们可以提出一个因子 $e^{-\\Delta t/\\tau_k}$：\n$$\n\\int_{0}^{t_{n-1}} E_k\\, e^{-(t_n-t_{n-1})/\\tau_k} e^{-(t_{n-1}-\\xi)/\\tau_k} \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi = e^{-\\Delta t/\\tau_k} \\int_{0}^{t_{n-1}} E_k\\, e^{-(t_{n-1}-\\xi)/\\tau_k} \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi\n$$\n右侧的积分根据定义是单元 $k$ 在时间 $t_{n-1}$ 的应力，即 $\\sigma_k^{n-1}$。因此，第一项就是 $\\sigma_k^{n-1} e^{-\\Delta t/\\tau_k}$。\n\n现在，考虑第二个积分，它代表在最近的时间步 $[t_{n-1}, t_n]$ 内产生的应力。在此区间内，应变率是恒定的：$\\frac{d\\varepsilon}{d\\xi} = \\frac{\\Delta\\varepsilon^n}{\\Delta t}$。\n$$\n\\int_{t_{n-1}}^{t_n} E_k\\, e^{-(t_n-\\xi)/\\tau_k} \\left(\\frac{\\Delta\\varepsilon^n}{\\Delta t}\\right) d\\xi = E_k \\left(\\frac{\\Delta\\varepsilon^n}{\\Delta t}\\right) \\int_{t_{n-1}}^{t_n} e^{-(t_n-\\xi)/\\tau_k} d\\xi\n$$\n该积分计算结果为：\n$$\n\\left[ \\tau_k\\, e^{-(t_n-\\xi)/\\tau_k} \\right]_{\\xi=t_{n-1}}^{\\xi=t_n} = \\tau_k \\left( e^{0} - e^{-\\Delta t/\\tau_k} \\right) = \\tau_k \\left( 1 - e^{-\\Delta t/\\tau_k} \\right)\n$$\n结合这些结果，我们得到了 $\\sigma_k^n$ 的递归更新公式：\n$$\n\\sigma_k^n = \\sigma_k^{n-1} e^{-\\Delta t/\\tau_k} + E_k \\tau_k \\left( \\frac{\\varepsilon^n - \\varepsilon^{n-1}}{\\Delta t} \\right) \\left( 1 - e^{-\\Delta t/\\tau_k} \\right)\n$$\n这个更新规则允许仅基于前一时间步的值 $\\sigma_k^{n-1}$ 和当前步长的应变增量来计算 $\\sigma_k^n$。初始条件是对于所有 $k$，$\\sigma_k^0 = 0$，因为材料初始是静止的。\n\n在时间 $t_n$ 的总应力则组合为：\n$$\n\\sigma^n = E_{\\infty}\\,\\varepsilon^n + \\sum_{k=1}^{M} \\sigma_k^n\n$$\n现在，找到 $\\sigma^n$ 的计算工作量是每个时间步 $\\mathcal{O}(M)$，这与过去步数 $n$ 无关。这满足了每个Maxwell单元 $\\mathcal{O}(1)$ 更新的要求。\n\n该实现将包括两个函数。\n1.  **直接卷积：** 此函数在每个步骤 $n$ 计算 $\\sigma^n$，通过显式地对从 $i=1$到 $n$ 的所有过去应变率增量以及所有 $M$ 个模式的贡献进行求和。计算到第 $N$ 步的历史记录的总计算复杂度为 $\\mathcal{O}(N^2 M)$。\n2.  **递归更新：** 此函数维护一个内部应力变量数组 $\\{\\sigma_k^{n-1}\\}$。在每个步骤 $n$，它使用推导出的递归公式将这些变量更新为 $\\{\\sigma_k^{n}\\}$，并将它们求和以找到总应力。计算到第 $N$ 步的历史记录的总计算复杂度为 $\\mathcal{O}(N M)$。\n\n在分段恒定应变率的假设下，两种方法在解析上是等效的。因此，它们计算出的应力历史之间的差异应仅归因于浮点表示和算术误差，因此应接近于零。整个时间序列上的最大绝对差为此等效性提供了定量度量。",
            "answer": "```python\nimport numpy as np\n\ndef compute_stress_direct(e_inf, modes, dt, eps):\n    \"\"\"\n    Computes stress using the direct convolution method.\n    This method has O(N^2 * M) complexity.\n    \"\"\"\n    n_steps = len(eps)\n    sigma = np.zeros(n_steps, dtype=np.float64)\n\n    if n_steps == 0:\n        return sigma\n\n    # Stress at t=0\n    sigma[0] = e_inf * eps[0]\n\n    for n in range(1, n_steps):\n        # Elastic contribution\n        sigma_n = e_inf * eps[n]\n        \n        # Viscoelastic contribution from all past steps\n        for i in range(1, n + 1):\n            d_eps = eps[i] - eps[i-1]\n            if np.abs(d_eps)  1e-15:  # Avoid division by zero and unnecessary computation\n                continue\n            \n            strain_rate = d_eps / dt\n            \n            for E_k, tau_k in modes:\n                # Analytical integral of the exponential kernel over interval [t_{i-1}, t_i]\n                # for its contribution to stress at t_n\n                term1 = np.exp(-(n - i) * dt / tau_k)\n                term2 = np.exp(-(n - i + 1) * dt / tau_k)\n                integral_val = tau_k * (term1 - term2)\n                sigma_n += E_k * strain_rate * integral_val\n        \n        sigma[n] = sigma_n\n        \n    return sigma\n\ndef compute_stress_recursive(e_inf, modes, dt, eps):\n    \"\"\"\n    Computes stress using the recursive update algorithm.\n    This method has O(N * M) complexity.\n    \"\"\"\n    n_steps = len(eps)\n    sigma = np.zeros(n_steps, dtype=np.float64)\n    \n    if n_steps == 0:\n        return sigma\n\n    num_modes = len(modes)\n    sigma_k = np.zeros(num_modes, dtype=np.float64) # Internal variables (stress per mode)\n\n    # Pre-calculate factors for efficiency\n    exp_factors = np.array([np.exp(-dt / tau_k) for _, tau_k in modes], dtype=np.float64)\n    \n    # Stress at t=0\n    sigma[0] = e_inf * eps[0] + np.sum(sigma_k) # sigma_k is zero here\n\n    for n in range(1, n_steps):\n        d_eps = eps[n] - eps[n-1]\n        \n        # Viscoelastic contribution (update internal variables)\n        for k in range(num_modes):\n            E_k, tau_k = modes[k]\n            \n            # Stress increment from strain change in [t_{n-1}, t_n]\n            # This is E_k * (d_eps/dt) * integral(exp(-(t_n-xi)/tau_k), xi=t_{n-1}..t_n)\n            increment = 0.0\n            if np.abs(d_eps) > 1e-15:\n                strain_rate = d_eps / dt\n                factor = E_k * tau_k * (1.0 - exp_factors[k])\n                increment = factor * strain_rate\n\n            # Recursive update\n            sigma_k[k] = sigma_k[k] * exp_factors[k] + increment\n\n        # Total stress is elastic part + sum of mode stresses\n        sigma[n] = e_inf * eps[n] + np.sum(sigma_k)\n        \n    return sigma\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute differences.\n    \"\"\"\n    test_cases = [\n        # Case 1: Happy-path multi-mode case\n        {\n            \"e_inf\": 1.0e5,\n            \"modes\": [(2.0e5, 0.1), (1.0e5, 1.0), (5.0e4, 10.0)],\n            \"dt\": 0.05,\n            \"eps\": np.array([0.0, 0.002, 0.003, 0.0045, 0.0045, 0.003, 0.0035, 0.005, 0.004, 0.004], dtype=np.float64)\n        },\n        # Case 2: Boundary case with a very fast mode and large time step\n        {\n            \"e_inf\": 0.0,\n            \"modes\": [(1.0e6, 0.001)],\n            \"dt\": 0.1,\n            \"eps\": np.array([0.0, 0.01, 0.01, 0.01, 0.01], dtype=np.float64)\n        },\n        # Case 3: Edge case with no Maxwell elements\n        {\n            \"e_inf\": 2.0e5,\n            \"modes\": [],\n            \"dt\": 0.02,\n            \"eps\": np.array([0.0, 0.001, 0.002, 0.0015, 0.0015, 0.0005], dtype=np.float64)\n        },\n        # Case 4: Small time step relative to slow modes\n        {\n            \"e_inf\": 0.0,\n            \"modes\": [(5.0e5, 10.0), (3.0e5, 5.0)],\n            \"dt\": 0.001,\n            \"eps\": np.array([0.0, 1e-4, 2e-4, 3e-4, 4e-4, 5e-4, 6e-4, 7e-4, 8e-4, 9e-4, 1e-3, 1.1e-3, 1.1e-3, 1.05e-3, 1.0e-3, 9e-4, 8e-4, 7e-4, 6e-4, 5e-4], dtype=np.float64)\n        }\n    ]\n\n    max_differences = []\n\n    for case in test_cases:\n        e_inf = case[\"e_inf\"]\n        modes = case[\"modes\"]\n        dt = case[\"dt\"]\n        eps = case[\"eps\"]\n\n        sigma_direct = compute_stress_direct(e_inf, modes, dt, eps)\n        sigma_recursive = compute_stress_recursive(e_inf, modes, dt, eps)\n        \n        diff = np.max(np.abs(sigma_direct - sigma_recursive))\n        max_differences.append(diff)\n\n    print(f\"[{','.join(f'{d:.12f}' for d in max_differences)}]\")\n    \nsolve()\n\n```"
        }
    ]
}