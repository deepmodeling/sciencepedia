{
    "hands_on_practices": [
        {
            "introduction": "This first practice is a foundational exercise in the theory of linear viscoelasticity. It challenges you to derive the creep compliance $J(t)$ from the stress relaxation modulus $G(t)$ for the Standard Linear Solid model . Mastering this analytical connection using the Boltzmann superposition principle and Laplace transforms is crucial for understanding the dual ways a material's time-dependent response can be characterized.",
            "id": "2861612",
            "problem": "A viscoelastic solid is modeled as a Standard Linear Solid (SLS), equivalently a spring in parallel with a Maxwell element, with relaxation modulus specified by the function $G(t)=G_{\\infty}+\\bigl(G_{0}-G_{\\infty}\\bigr)\\exp\\!\\bigl(-t/\\tau\\bigr)$ for $t \\ge 0$, where $G_{0}>G_{\\infty}>0$ and $\\tau>0$ are constants. Assume linear viscoelasticity and zero initial fields for $t<0$. Starting only from the hereditary (Boltzmann) superposition principle for linear viscoelasticity and the definitions of the relaxation modulus $G(t)$ and the creep compliance $J(t)$, derive the step responses:\n\n- the creep strain $\\gamma(t)$ produced by a suddenly applied constant shear stress $\\tau(t)=\\tau_{0}H(t)$, with $H(t)$ the Heaviside step, and\n- the stress relaxation $\\tau(t)$ produced by a suddenly applied constant shear strain $\\gamma(t)=\\gamma_{0}H(t)$,\n\nboth for $t>0$. Express each response as a closed-form analytic function of $t$, $G_{0}$, $G_{\\infty}$, $\\tau$, $\\tau_{0}$, and $\\gamma_{0}$. No numerical evaluation is required. Provide your final answer as two expressions in a single row, in the order listed above. Do not include units in your final answer.",
            "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It is a standard problem in the theory of linear viscoelasticity based on established principles and models. All necessary information is provided, and the problem is free of contradictions or ambiguities. Therefore, the problem is valid, and a solution will be provided.\n\nThe foundation of linear viscoelasticity is the Boltzmann superposition principle, which states that the total stress (or strain) at a given time is a linear summation of the effects of all past changes in strain (or stress). For a continuous history, this principle is expressed through hereditary integrals. Assuming zero stress and strain for time $t < 0$, the stress $\\tau(t)$ and strain $\\gamma(t)$ for $t \\ge 0$ are related by:\n$$ \\tau(t) = \\int_{0}^{t} G(t-t') \\frac{d\\gamma(t')}{dt'} dt' $$\n$$ \\gamma(t) = \\int_{0}^{t} J(t-t') \\frac{d\\tau(t')}{dt'} dt' $$\nHere, $G(t)$ is the stress relaxation modulus, defined as the stress response to a unit step strain, and $J(t)$ is the creep compliance, defined as the strain response to a unit step stress.\n\nFirst, we derive the stress relaxation response, $\\tau(t)$, to a suddenly applied constant shear strain $\\gamma(t) = \\gamma_{0}H(t)$, where $H(t)$ is the Heaviside step function and $\\gamma_0$ is a constant. The rate of strain is given by the time derivative:\n$$ \\frac{d\\gamma(t)}{dt} = \\frac{d}{dt} [\\gamma_{0}H(t)] = \\gamma_{0} \\delta(t) $$\nwhere $\\delta(t)$ is the Dirac delta function. Substituting this into the first hereditary integral, we obtain the stress for $t > 0$:\n$$ \\tau(t) = \\int_{0}^{t} G(t-t') (\\gamma_{0} \\delta(t')) dt' $$\nBy the sifting property of the Dirac delta function, which states $\\int f(x)\\delta(x-a)dx = f(a)$, the integral evaluates to:\n$$ \\tau(t) = \\gamma_{0} G(t-0) = \\gamma_{0} G(t) $$\nThis confirms that the stress response to a step strain is proportional to the relaxation modulus itself. Using the given expression for $G(t) = G_{\\infty}+\\bigl(G_{0}-G_{\\infty}\\bigr)\\exp\\!\\bigl(-t/\\tau\\bigr)$, the stress relaxation for $t > 0$ is:\n$$ \\tau(t) = \\gamma_{0} \\left[ G_{\\infty} + (G_0 - G_{\\infty})\\exp(-t/\\tau) \\right] $$\n\nSecond, we derive the creep strain response, $\\gamma(t)$, to a suddenly applied constant shear stress $\\tau(t) = \\tau_{0}H(t)$. The rate of stress is:\n$$ \\frac{d\\tau(t)}{dt} = \\frac{d}{dt} [\\tau_{0}H(t)] = \\tau_{0} \\delta(t) $$\nSubstituting this into the second hereditary integral, we obtain the strain for $t > 0$:\n$$ \\gamma(t) = \\int_{0}^{t} J(t-t') (\\tau_{0} \\delta(t')) dt' = \\tau_{0} J(t-0) = \\tau_{0} J(t) $$\nTo find $\\gamma(t)$, we must first determine the creep compliance $J(t)$ from the given relaxation modulus $G(t)$. The relationship between $G(t)$ and $J(t)$ is most conveniently established in the Laplace domain. Let $\\hat{f}(s) = \\mathcal{L}\\{f(t)\\}$ denote the Laplace transform of a function $f(t)$. The hereditary integrals in the Laplace domain become algebraic relations:\n$$ \\hat{\\tau}(s) = s \\hat{G}(s) \\hat{\\gamma}(s) \\quad \\text{and} \\quad \\hat{\\gamma}(s) = s \\hat{J}(s) \\hat{\\tau}(s) $$\nFrom these, it follows that their product must be unity:\n$$ (s \\hat{G}(s)) (s \\hat{J}(s)) = 1 \\implies \\hat{J}(s) = \\frac{1}{s^2 \\hat{G}(s)} $$\nWe begin by finding the Laplace transform of $G(t)$:\n$$ \\hat{G}(s) = \\mathcal{L}\\left\\{ G_{\\infty} + (G_0 - G_{\\infty})\\exp(-t/\\tau) \\right\\} = \\frac{G_{\\infty}}{s} + \\frac{G_0 - G_{\\infty}}{s + 1/\\tau} $$\nCombining the terms gives:\n$$ \\hat{G}(s) = \\frac{G_{\\infty}(s + 1/\\tau) + s(G_0 - G_{\\infty})}{s(s + 1/\\tau)} = \\frac{G_0 s + G_{\\infty}/\\tau}{s(s+1/\\tau)} $$\nNow we find $\\hat{J}(s)$:\n$$ \\hat{J}(s) = \\frac{1}{s^2 \\hat{G}(s)} = \\frac{1}{s^2} \\frac{s(s+1/\\tau)}{G_0 s + G_{\\infty}/\\tau} = \\frac{s+1/\\tau}{s(G_0 s + G_{\\infty}/\\tau)} = \\frac{1}{G_0} \\frac{s+1/\\tau}{s(s + G_{\\infty}/(G_0\\tau))} $$\nTo find the inverse Laplace transform, we use partial fraction decomposition:\n$$ \\frac{s+1/\\tau}{s(s + a)} = \\frac{A}{s} + \\frac{B}{s+a} \\quad \\text{where} \\quad a = \\frac{G_{\\infty}}{G_0\\tau} $$\nThe coefficients are:\n$$ A = \\left. \\frac{s+1/\\tau}{s+a} \\right|_{s=0} = \\frac{1/\\tau}{a} = \\frac{1/\\tau}{G_{\\infty}/(G_0\\tau)} = \\frac{G_0}{G_{\\infty}} $$\n$$ B = \\left. \\frac{s+1/\\tau}{s} \\right|_{s=-a} = \\frac{-a+1/\\tau}{-a} = 1 - \\frac{1/\\tau}{a} = 1 - \\frac{G_0}{G_{\\infty}} = \\frac{G_{\\infty}-G_0}{G_{\\infty}} $$\nSubstituting these back into the expression for $\\hat{J}(s)$:\n$$ \\hat{J}(s) = \\frac{1}{G_0} \\left[ \\frac{G_0/G_{\\infty}}{s} + \\frac{(G_{\\infty}-G_0)/G_{\\infty}}{s + G_{\\infty}/(G_0\\tau)} \\right] = \\frac{1}{G_{\\infty} s} - \\frac{G_0-G_{\\infty}}{G_0 G_{\\infty}} \\frac{1}{s + G_{\\infty}/(G_0\\tau)} $$\nTaking the inverse Laplace transform gives the creep compliance $J(t)$:\n$$ J(t) = \\mathcal{L}^{-1}\\{\\hat{J}(s)\\} = \\frac{1}{G_{\\infty}} - \\frac{G_0-G_{\\infty}}{G_0 G_{\\infty}} \\exp\\left(-\\frac{G_{\\infty}}{G_0\\tau} t\\right) $$\nThis expression can be rewritten as:\n$$ J(t) = \\frac{1}{G_{\\infty}} - \\left(\\frac{1}{G_{\\infty}} - \\frac{1}{G_0}\\right) \\exp\\left(-\\frac{G_{\\infty}}{G_0\\tau} t\\right) $$\nFinally, the creep strain is $\\gamma(t) = \\tau_0 J(t)$:\n$$ \\gamma(t) = \\tau_0 \\left[ \\frac{1}{G_{\\infty}} - \\left(\\frac{1}{G_{\\infty}} - \\frac{1}{G_0}\\right) \\exp\\left(-\\frac{G_{\\infty}}{G_0\\tau} t\\right) \\right] $$\nThis completes the derivation of both required responses.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\tau_{0} \\left[ \\frac{1}{G_{\\infty}} - \\left(\\frac{1}{G_{\\infty}} - \\frac{1}{G_0}\\right) \\exp\\left(-\\frac{G_{\\infty}}{G_0\\tau} t\\right) \\right] & \\gamma_{0} \\left[ G_{\\infty} + \\left(G_0 - G_{\\infty}\\right)\\exp\\left(-\\frac{t}{\\tau}\\right) \\right]\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Moving from continuous theory to discrete computation, this practice tackles the direct numerical implementation of the Boltzmann superposition principle. You will discretize the hereditary integrals into convolution sums and analyze the computational cost of this direct, history-dependent approach . This exercise is fundamental to computational rheology, as it highlights the practical challenges of memory and processing scaling that motivate more efficient algorithms.",
            "id": "4093615",
            "problem": "Consider a one-dimensional, isothermal, small-deformation linear viscoelastic material described by the Boltzmann superposition principle. The causal constitutive relations are given by the hereditary integrals\n$$\\tau(t) = \\int_{0}^{t} G(t-s)\\,\\mathrm{d}\\gamma(s),\\quad \\gamma(t) = \\int_{0}^{t} J(t-s)\\,\\mathrm{d}\\tau(s),$$\nwhere $\\tau(t)$ is the shear stress in pascals, $\\gamma(t)$ is the shear strain (dimensionless), $G(t)$ is the stress relaxation modulus in pascals, and $J(t)$ is the creep compliance in reciprocal pascals. Assume uniform time discretization with $t_n = n\\,\\Delta t$ for integer $n \\ge 0$, and define increments $\\Delta\\gamma_m = \\gamma(t_m^{+}) - \\gamma(t_m^{-})$ and $\\Delta\\tau_m = \\tau(t_m^{+}) - \\tau(t_m^{-})$. The discrete causal convolution forms of the constitutive relations are\n$$\\tau_n = \\sum_{m=0}^{n} G_{n-m}\\,\\Delta\\gamma_m,\\quad \\gamma_n = \\sum_{m=0}^{n} J_{n-m}\\,\\Delta\\tau_m,$$\nwhere $G_k = G(k\\,\\Delta t)$ and $J_k = J(k\\,\\Delta t)$ for integer $k \\ge 0$.\n\nTask 1 (derivation and algorithmic design): Starting only from the Boltzmann superposition principle and the definition of the discrete sampling described above, derive the discrete convolution scheme that computes $\\tau_n$ and $\\gamma_n$ for $n=0,\\dots,N$ using the two sequences $\\{G_k\\}_{k=0}^{N}$, $\\{J_k\\}_{k=0}^{N}$ and the increment sequences $\\{\\Delta\\gamma_m\\}_{m=0}^{N}$, $\\{\\Delta\\tau_m\\}_{m=0}^{N}$. Your derivation must clearly show how the integral relations lead to the discrete summations.\n\nTask 2 (computational complexity and memory analysis): For a general discrete causal convolution of two real-valued sequences of length $N+1$ defined by\n$$y_n = \\sum_{m=0}^{n} k_{n-m}\\,x_m,\\quad n=0,\\dots,N,$$\nanalyze:\n1. The operation count of the direct nested-loop scheme. Use the convention that each scalar multiplication counts as one operation and each scalar addition counts as one operation. Provide closed-form expressions for the total number of multiplications and additions required to compute the entire output sequence $\\{y_n\\}_{n=0}^{N}$.\n2. The operation count of an algorithm based on the Fast Fourier Transform (FFT) using zero-padding to obtain linear convolution via circular convolution. Assume that you zero-pad both sequences to a length $L$ that is the next power of two greater than or equal to $(N+1)+(N+1)-1$, and that you perform two forward complex-valued FFTs, one inverse complex-valued FFT, and a pointwise complex multiplication. Use the standard estimate that one complex-valued FFT of length $L$ requires approximately $5\\,L\\,\\log_2 L$ floating-point operations, and that the pointwise complex multiplication and the pointwise complex addition together total $2L$ floating-point operations for the full spectrum. Provide a formula for the total floating-point operations for one convolution and for computing both $\\tau_n$ and $\\gamma_n$ by two such convolutions.\n3. The memory requirement for both methods under the following explicit assumptions: all real-valued arrays are stored in double precision ($8$ bytes per element) and all complex-valued arrays are stored in double precision complex ($16$ bytes per element). For the direct method, assume you store six real arrays of length $N+1$: $\\{G_k\\}$, $\\{J_k\\}$, $\\{\\Delta\\gamma_m\\}$, $\\{\\Delta\\tau_m\\}$, $\\{\\tau_n\\}$, and $\\{\\gamma_n\\}$. For the FFT-based method, assume the same six real arrays plus, at peak during one convolution, five complex arrays of length $L$ (two zero-padded inputs, two forward-transformed spectra, and one workspace that holds either the spectral product or the inverse-transformed output). Provide formulas for the total bytes required in each method.\n\nTask 3 (implementation and test suite): Implement a program that computes $\\tau_n$ and $\\gamma_n$ via the discrete convolution sums for the following three test cases. The program must also compute and report the total operation counts and memory requirements as specified in Task 2 for each test case. Use the following test suite, which jointly probes a general case, a boundary case, and a large case:\n1. Happy-path case: Use a Maxwell material with modulus $E = 1.0\\times 10^6$ pascals and relaxation time $\\tau = 2.0$ seconds, time step $\\Delta t = 0.5$ seconds, and $N=8$. Define $G_k = E\\,\\exp\\!\\left(-\\frac{k\\,\\Delta t}{\\tau}\\right)$ and $J_k = \\frac{1}{E} + \\frac{k\\,\\Delta t}{E\\,\\tau}$. Use a constant shear-rate increment sequence $\\Delta\\gamma_m = \\dot{\\gamma}\\,\\Delta t$ with $\\dot{\\gamma} = 0.004$ per second for all $m$, and a step stress increment $\\Delta\\tau_0 = 100$ pascals and $\\Delta\\tau_m = 0$ for $m \\ge 1$. Report $\\tau_N$ in pascals and $\\gamma_N$ as a dimensionless quantity.\n2. Boundary case: Use $E = 2.0\\times 10^6$ pascals, $\\tau = 1.0$ second, $\\Delta t = 1.0$ second, and $N=0$. Define $G_0 = E$ and $J_0 = \\frac{1}{E}$. Use $\\Delta\\gamma_0 = 0.01$ (dimensionless) and $\\Delta\\tau_0 = 100$ pascals. Report $\\tau_0$ in pascals and $\\gamma_0$ as a dimensionless quantity.\n3. Large case: Use $E = 5.0\\times 10^5$ pascals, $\\tau = 0.2$ seconds, $\\beta = 0.5$ (dimensionless), $\\Delta t = 0.01$ seconds, and $N=1024$. Define a stretched-exponential stress relaxation modulus $G_k = E\\,\\exp\\!\\left(-\\left(\\frac{k\\,\\Delta t}{\\tau}\\right)^{\\beta}\\right)$, and a power-law creep compliance $J_k = \\frac{1}{E} + A\\,(k\\,\\Delta t)^{\\alpha}$ with $A = 1.0\\times 10^{-4}$ reciprocal pascal seconds to the power $-\\alpha$ and $\\alpha = 0.3$ (dimensionless). Use $\\Delta\\gamma_m = \\gamma_{\\mathrm{amp}}\\sin(2\\pi f (m+1)\\Delta t)$ with $\\gamma_{\\mathrm{amp}} = 1.0\\times 10^{-3}$ (dimensionless) and $f = 5.0$ hertz, and $\\Delta\\tau_m = \\tau_{\\mathrm{amp}}\\cos(2\\pi f (m+1)\\Delta t)$ with $\\tau_{\\mathrm{amp}} = 50$ pascals. Report $\\tau_N$ in pascals and $\\gamma_N$ as a dimensionless quantity.\n\nFor each test case, you must compute and output the following six values, in order:\n1. The final stress $\\tau_N$ in pascals.\n2. The final strain $\\gamma_N$ (dimensionless).\n3. The total operation count (integer) for the direct method for computing both $\\{\\tau_n\\}$ and $\\{\\gamma_n\\}$, obtained by summing the multiplications and additions across both convolutions.\n4. The total operation count (integer) for the Fast Fourier Transform (FFT)-based method for computing both $\\{\\tau_n\\}$ and $\\{\\gamma_n\\}$, using the estimate in Task 2 and the zero-padding length $L$ as specified.\n5. The total memory requirement (integer number of bytes) for the direct method, using the storage assumptions in Task 2.\n6. The total memory requirement (integer number of bytes) for the FFT-based method, using the storage assumptions in Task 2.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, aggregating the six values for case 1, followed by the six values for case 2, followed by the six values for case 3. For example, the output format must be\n$$[\\tau_N^{(1)},\\gamma_N^{(1)},\\text{ops\\_direct}^{(1)},\\text{ops\\_fft}^{(1)},\\text{mem\\_direct}^{(1)},\\text{mem\\_fft}^{(1)},\\tau_N^{(2)},\\gamma_N^{(2)},\\text{ops\\_direct}^{(2)},\\text{ops\\_fft}^{(2)},\\text{mem\\_direct}^{(2)},\\text{mem\\_fft}^{(2)},\\tau_N^{(3)},\\gamma_N^{(3)},\\text{ops\\_direct}^{(3)},\\text{ops\\_fft}^{(3)},\\text{mem\\_direct}^{(3)},\\text{mem\\_fft}^{(3)}].$$\nAll stresses must be in pascals, strains dimensionless, and angular frequency arguments in the trigonometric functions must use radians because $2\\pi f (m+1)\\Delta t$ is in radians when $f$ is in hertz and $\\Delta t$ in seconds.",
            "solution": "The starting point is the Boltzmann superposition principle for linear viscoelasticity, which expresses the stress response to a history of strain increments and the strain response to a history of stress increments. For small deformations, linearity and time invariance imply that the response at time $t$ is a weighted superposition of past increments:\n$$\\tau(t) = \\int_{0}^{t} G(t-s)\\,\\mathrm{d}\\gamma(s),\\quad \\gamma(t) = \\int_{0}^{t} J(t-s)\\,\\mathrm{d}\\tau(s).$$\nHere, $G(t)$ and $J(t)$ are material functions characterizing relaxation and creep, respectively. The measure $\\mathrm{d}\\gamma(s)$ represents the increment of strain at time $s$. If we assume uniform sampling $t_n = n\\,\\Delta t$ for integer $n \\ge 0$ and define the jump increments $\\Delta\\gamma_m = \\gamma(t_m^{+}) - \\gamma(t_m^{-})$, then the integral over the piecewise constant increment process becomes a sum over weighted increments. Specifically, for causal kernels (zero for negative times), the integral becomes a Riemannâ€“Stieltjes sum over the discretized grid:\n$$\\tau(t_n) \\approx \\sum_{m=0}^{n} G(t_n - t_m)\\,\\Delta\\gamma_m = \\sum_{m=0}^{n} G((n-m)\\Delta t)\\,\\Delta\\gamma_m.$$\nDefine $G_k = G(k\\,\\Delta t)$ for integer $k \\ge 0$, so that $G_{n-m} = G((n-m)\\Delta t)$. Then the discrete stress at step $n$ is\n$$\\tau_n = \\sum_{m=0}^{n} G_{n-m}\\,\\Delta\\gamma_m.$$\nBy the same reasoning for creep compliance and stress increments, we define $\\Delta\\tau_m = \\tau(t_m^{+}) - \\tau(t_m^{-})$ and $J_k = J(k\\,\\Delta t)$. The discrete strain at step $n$ is\n$$\\gamma_n = \\sum_{m=0}^{n} J_{n-m}\\,\\Delta\\tau_m.$$\nThese are discrete causal convolutions.\n\nTo compute these efficiently, we consider two algorithmic approaches. The direct method evaluates, for each $n$, the sum over $m=0$ to $n$, leading to nested loops with increasing inner loop length. The total number of scalar multiplications needed to compute the full output sequence $\\{y_n\\}_{n=0}^{N}$ for $y_n = \\sum_{m=0}^{n} k_{n-m} x_m$ is\n$$M_{\\text{direct}}(N) = \\sum_{n=0}^{N} (n+1) = \\frac{(N+1)(N+2)}{2}.$$\nThe total number of scalar additions is\n$$A_{\\text{direct}}(N) = \\sum_{n=0}^{N} n = \\frac{N(N+1)}{2}.$$\nThus, the total for both multiplications and additions is $M_{\\text{direct}}(N) + A_{\\text{direct}}(N)$ for one convolution. For our viscoelastic problem, we perform two convolutions (one for $\\tau_n$ and one for $\\gamma_n$), so the total direct operations across both is\n$$\\text{ops}_{\\text{direct}}(N) = 2\\left(\\frac{(N+1)(N+2)}{2} + \\frac{N(N+1)}{2}\\right) = 2(N+1)^2.$$\nAlternatively, if reporting multiplications and additions separately, they sum to $2 M_{\\text{direct}}(N) + 2 A_{\\text{direct}}(N)$.\n\nAn alternative is to use the Fast Fourier Transform (FFT) to convert convolution into pointwise multiplication in the frequency domain. For linear (non-circular) convolution of real sequences, we zero-pad both sequences to a length $L$ that is a power of two satisfying $L \\ge (N+1)+(N+1)-1 = 2N+1$. If we use complex-valued FFTs (for simplicity of counting), then the operation count for one convolution comprises two forward complex FFTs, one inverse complex FFT, and the pointwise complex multiplication. A standard estimate for a complex FFT of length $L$ is $5\\,L\\,\\log_2 L$ floating-point operations, while the pointwise complex multiplication and the associated addition (summing spectral contributions or combining real and imaginary parts) together cost approximately $2L$ floating-point operations. Therefore, for one convolution,\n$$\\text{ops}_{\\text{fft}}^{\\text{one}}(L) \\approx 2\\cdot 5 L \\log_2 L + 1\\cdot 5 L \\log_2 L + 2L = 15 L \\log_2 L + 2L.$$\nFor computing both $\\tau_n$ and $\\gamma_n$ with two such convolutions,\n$$\\text{ops}_{\\text{fft}}(L) \\approx 2\\left(15 L \\log_2 L + 2L\\right) = 30 L \\log_2 L + 4L.$$\nThis is a practical estimate; it captures the dominant asymptotic scaling $\\mathcal{O}(L \\log L)$ and provides a quantitative value for given $L$.\n\nRegarding memory, under the explicit storage assumptions, the direct method holds six real arrays of length $N+1$:\n$\\{G_k\\}$, $\\{J_k\\}$, $\\{\\Delta\\gamma_m\\}$, $\\{\\Delta\\tau_m\\}$, $\\{\\tau_n\\}$, and $\\{\\gamma_n\\}$.\nWith double precision ($8$ bytes per real number), the total storage is\n$$\\text{mem}_{\\text{direct}}(N) = 6\\,(N+1)\\cdot 8\\ \\text{bytes}.$$\nFor the FFT-based method, at peak during one convolution we also hold five complex arrays of length $L$: two zero-padded inputs, two forward-transformed spectra, and one workspace (to store either the spectral product or the inverse-transformed output). With double precision complex numbers ($16$ bytes per complex number), the total storage is\n$$\\text{mem}_{\\text{fft}}(N,L) = 6\\,(N+1)\\cdot 8\\ \\text{bytes} + 5\\,L\\cdot 16\\ \\text{bytes}.$$\nThese formulas quantify memory demands explicitly.\n\nWe now define the test suite and the sequences in each case.\n\nCase 1 (Maxwell, happy path): With $E = 1.0\\times 10^6$ pascals, $\\tau = 2.0$ seconds, $\\Delta t = 0.5$ seconds, and $N=8$, define\n$$G_k = E\\,\\exp\\left(-\\frac{k\\,\\Delta t}{\\tau}\\right),\\quad J_k = \\frac{1}{E} + \\frac{k\\,\\Delta t}{E\\,\\tau}.$$\nSet $\\Delta\\gamma_m = \\dot{\\gamma}\\,\\Delta t$ with $\\dot{\\gamma} = 0.004$ per second for all $m$, so $\\Delta\\gamma_m = 0.002$ for all $m=0,\\dots,8$. Set $\\Delta\\tau_0 = 100$ pascals and $\\Delta\\tau_m = 0$ for $m \\ge 1$. Compute $\\tau_n = \\sum_{m=0}^{n} G_{n-m}\\,\\Delta\\gamma_m$ and $\\gamma_n = \\sum_{m=0}^{n} J_{n-m}\\,\\Delta\\tau_m$, then report $\\tau_8$ and $\\gamma_8$.\n\nCase 2 (boundary, $N=0$): With $E = 2.0\\times 10^6$ pascals, $\\tau = 1.0$ second, $\\Delta t = 1.0$ second, and $N=0$, define $G_0 = E$, $J_0 = \\frac{1}{E}$. Use $\\Delta\\gamma_0 = 0.01$ and $\\Delta\\tau_0 = 100$ pascals. Compute the trivial sums $\\tau_0 = G_0\\,\\Delta\\gamma_0$ and $\\gamma_0 = J_0\\,\\Delta\\tau_0$, then report these values.\n\nCase 3 (large, stretched exponential and power-law): With $E = 5.0\\times 10^5$ pascals, $\\tau = 0.2$ seconds, $\\beta = 0.5$, $\\Delta t = 0.01$ seconds, and $N=1024$, define\n$$G_k = E\\,\\exp\\left(-\\left(\\frac{k\\,\\Delta t}{\\tau}\\right)^{\\beta}\\right),\\quad J_k = \\frac{1}{E} + A\\,(k\\,\\Delta t)^{\\alpha},$$\nwith $A = 1.0\\times 10^{-4}$ reciprocal pascals seconds to the power $-\\alpha$ and $\\alpha=0.3$. Use $\\Delta\\gamma_m = \\gamma_{\\mathrm{amp}}\\sin(2\\pi f (m+1)\\Delta t)$ with $\\gamma_{\\mathrm{amp}} = 1.0\\times 10^{-3}$ and $f=5.0$ hertz, and $\\Delta\\tau_m = \\tau_{\\mathrm{amp}}\\cos(2\\pi f (m+1)\\Delta t)$ with $\\tau_{\\mathrm{amp}} = 50$. Compute $\\tau_n$ and $\\gamma_n$ for $n=0,\\dots,1024$, and report $\\tau_{1024}$ and $\\gamma_{1024}$.\n\nFor each case, compute the operation counts and memory usage as follows:\n- Direct method operations for both convolutions: $\\text{ops}_{\\text{direct}}(N) = 2\\left(M_{\\text{direct}}(N) + A_{\\text{direct}}(N)\\right)$ with $M_{\\text{direct}}(N) = \\frac{(N+1)(N+2)}{2}$ and $A_{\\text{direct}}(N) = \\frac{N(N+1)}{2}$.\n- FFT method operations for both convolutions: choose $L$ as the next power of two satisfying $L \\ge 2(N+1)-1$, then $\\text{ops}_{\\text{fft}}(L) = 30\\,L\\,\\log_2 L + 4L$.\n- Direct method memory: $\\text{mem}_{\\text{direct}}(N) = 6\\,(N+1)\\cdot 8$ bytes.\n- FFT method memory: $\\text{mem}_{\\text{fft}}(N,L) = 6\\,(N+1)\\cdot 8 + 5\\,L\\cdot 16$ bytes.\n\nYour program must construct the sequences according to the case definitions, compute the discrete convolutions, determine the final values, and compute the operation counts and memory bytes using the formulas above. The final output must be a single line of the form\n$$[\\tau_N^{(1)},\\gamma_N^{(1)},\\text{ops\\_direct}^{(1)},\\text{ops\\_fft}^{(1)},\\text{mem\\_direct}^{(1)},\\text{mem\\_fft}^{(1)},\\tau_N^{(2)},\\gamma_N^{(2)},\\text{ops\\_direct}^{(2)},\\text{ops\\_fft}^{(2)},\\text{mem\\_direct}^{(2)},\\text{mem\\_fft}^{(2)},\\tau_N^{(3)},\\gamma_N^{(3)},\\text{ops\\_direct}^{(3)},\\text{ops\\_fft}^{(3)},\\text{mem\\_direct}^{(3)},\\text{mem\\_fft}^{(3)}],$$\nwhere stresses are in pascals and strains are dimensionless.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef next_power_of_two(n: int) -> int:\n    \"\"\"Return the next power of two >= n.\"\"\"\n    if n <= 1:\n        return 1\n    return 1 << (int(np.ceil(np.log2(n))))\n\ndef direct_ops_counts(N: int) -> int:\n    \"\"\"\n    Total operation count (multiplications + additions) for two direct convolutions\n    over sequences of length N+1. For one convolution:\n      M = ((N+1)(N+2))/2 multiplications\n      A = (N(N+1))/2 additions\n    Total ops for one = M + A; for two = 2*(M + A).\n    \"\"\"\n    M = (N + 1) * (N + 2) // 2\n    A = N * (N + 1) // 2\n    return 2 * (M + A)\n\ndef fft_ops_counts(L: int) -> int:\n    \"\"\"\n    Total operation count for two FFT-based convolutions using the estimate:\n    For one convolution: 15*L*log2(L) + 2*L\n    For two convolutions: 30*L*log2(L) + 4*L\n    \"\"\"\n    if L <= 1:\n        # log2(1) = 0, so ops reduce to just the pointwise operations estimate\n        return 2 * (2 * L)\n    return int(30 * L * np.log2(L) + 4 * L)\n\ndef mem_direct_bytes(N: int) -> int:\n    \"\"\"\n    Memory for direct method: six real arrays of length N+1, 8 bytes each.\n    Arrays: G, J, dgamma, dtau, tau, gamma.\n    \"\"\"\n    return 6 * (N + 1) * 8\n\ndef mem_fft_bytes(N: int, L: int) -> int:\n    \"\"\"\n    Memory for FFT method: six real arrays of length N+1 (8 bytes each),\n    plus five complex arrays of length L (16 bytes each) at peak during one convolution.\n    \"\"\"\n    return 6 * (N + 1) * 8 + 5 * L * 16\n\ndef causal_convolution(kernel: np.ndarray, increments: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute causal discrete convolution y_n = sum_{m=0}^n kernel[n-m] * increments[m].\n    Implemented via full linear convolution and truncation to first N+1 terms.\n    \"\"\"\n    N = len(kernel) - 1\n    # Linear convolution; numpy.convolve returns length len(kernel)+len(increments)-1\n    y_full = np.convolve(kernel, increments)\n    return y_full[:N + 1]\n\ndef case1():\n    # Parameters\n    E = 1.0e6  # Pa\n    tau_relax = 2.0  # s\n    dt = 0.5  # s\n    N = 8\n    # Kernels\n    k = np.arange(N + 1, dtype=np.float64)\n    G = E * np.exp(- (k * dt) / tau_relax)\n    J = (1.0 / E) + (k * dt) / (E * tau_relax)\n    # Increments\n    gamma_dot = 0.004  # s^{-1}\n    dgamma = np.full(N + 1, gamma_dot * dt, dtype=np.float64)\n    dtau = np.zeros(N + 1, dtype=np.float64)\n    dtau[0] = 100.0  # Pa\n    # Convolutions\n    tau = causal_convolution(G, dgamma)\n    gamma = causal_convolution(J, dtau)\n    # Final values\n    tau_N = float(tau[-1])\n    gamma_N = float(gamma[-1])\n    # Complexity and memory\n    ops_direct = direct_ops_counts(N)\n    L = next_power_of_two(2 * (N + 1) - 1)\n    ops_fft = fft_ops_counts(L)\n    mem_direct = mem_direct_bytes(N)\n    mem_fft = mem_fft_bytes(N, L)\n    return tau_N, gamma_N, ops_direct, ops_fft, mem_direct, mem_fft\n\ndef case2():\n    # Parameters\n    E = 2.0e6  # Pa\n    dt = 1.0  # s\n    N = 0\n    # Kernels\n    G = np.array([E], dtype=np.float64)\n    J = np.array([1.0 / E], dtype=np.float64)\n    # Increments\n    dgamma = np.array([0.01], dtype=np.float64)\n    dtau = np.array([100.0], dtype=np.float64)  # Pa\n    # Convolutions\n    tau = causal_convolution(G, dgamma)\n    gamma = causal_convolution(J, dtau)\n    tau_N = float(tau[-1])\n    gamma_N = float(gamma[-1])\n    # Complexity and memory\n    ops_direct = direct_ops_counts(N)\n    L = next_power_of_two(2 * (N + 1) - 1)\n    ops_fft = fft_ops_counts(L)\n    mem_direct = mem_direct_bytes(N)\n    mem_fft = mem_fft_bytes(N, L)\n    return tau_N, gamma_N, ops_direct, ops_fft, mem_direct, mem_fft\n\ndef case3():\n    # Parameters\n    E = 5.0e5  # Pa\n    tau_relax = 0.2  # s\n    beta = 0.5  # dimensionless\n    dt = 0.01  # s\n    N = 1024\n    # Kernels\n    k = np.arange(N + 1, dtype=np.float64)\n    G = E * np.exp(- ((k * dt) / tau_relax) ** beta)\n    A = 1.0e-4  # Pa^{-1} * s^{-alpha}\n    alpha = 0.3\n    J = (1.0 / E) + A * (k * dt) ** alpha\n    # Increments\n    f = 5.0  # Hz\n    gamma_amp = 1.0e-3\n    tau_amp = 50.0  # Pa\n    # Note: use (m+1)*dt inside trig as specified\n    m = np.arange(N + 1, dtype=np.float64)\n    angles = 2.0 * np.pi * f * (m + 1) * dt\n    dgamma = gamma_amp * np.sin(angles)\n    dtau = tau_amp * np.cos(angles)\n    # Convolutions\n    tau = causal_convolution(G, dgamma)\n    gamma = causal_convolution(J, dtau)\n    tau_N = float(tau[-1])\n    gamma_N = float(gamma[-1])\n    # Complexity and memory\n    ops_direct = direct_ops_counts(N)\n    L = next_power_of_two(2 * (N + 1) - 1)\n    ops_fft = fft_ops_counts(L)\n    mem_direct = mem_direct_bytes(N)\n    mem_fft = mem_fft_bytes(N, L)\n    return tau_N, gamma_N, ops_direct, ops_fft, mem_direct, mem_fft\n\ndef solve():\n    # Define the test cases from the problem statement.\n    results = []\n    for fn in (case1, case2, case3):\n        tau_N, gamma_N, ops_direct, ops_fft, mem_direct, mem_fft = fn()\n        results.extend([\n            tau_N, gamma_N,\n            int(ops_direct), int(ops_fft),\n            int(mem_direct), int(mem_fft)\n        ])\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The direct convolution method becomes prohibitively expensive for long simulations, as its computational cost grows with each time step. This final practice introduces a powerful technique to overcome this limitation for materials represented by a Prony series, a common choice in simulations . By deriving and implementing a recursive update scheme, you will transform the computationally intensive history integral into an efficient algorithm with constant cost per time step, a cornerstone of modern viscoelastic modeling.",
            "id": "4093678",
            "problem": "Consider a small-strain, one-dimensional linear viscoelastic material described by the Boltzmann Superposition Principle (BSP), where the stress response to a prescribed strain history is given by the convolution of a relaxation modulus kernel with the strain rate. Specifically, let the stress at time $t$ be\n$$\\sigma(t) = \\int_{0}^{t} E(t - \\xi) \\,\\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi,$$\nwhere $\\varepsilon(t)$ is the strain and $E(t)$ is the relaxation modulus. Assume a Generalized Maxwell Model (GMM) where the relaxation modulus is a Prony-series of $M$ Maxwell elements plus an equilibrium elastic contribution,\n$$E(t) = E_{\\infty} + \\sum_{k=1}^{M} E_k\\, e^{-t/\\tau_k},$$\nwith $E_{\\infty}$ the equilibrium modulus, and for each mode $k$, $E_k$ the modulus and $\\tau_k$ the relaxation time.\n\nYou are to derive, from first principles and fundamental definitions only, a recursive per-time-step update for internal state variables associated with each Maxwell element that enables computing $\\sigma(t_n)$ at discrete times $t_n = n\\,\\Delta t$ with $\\mathcal{O}(1)$ work per time step per Maxwell element (i.e., independent of the number of past time steps $n$). The derivation must start from the BSP, use the Prony representation for $E(t)$, and assume that the strain rate is piecewise constant over each time interval $[t_{n-1}, t_n]$, with $\\varepsilon(t)$ linearly interpolated between $\\varepsilon^{n-1} = \\varepsilon(t_{n-1})$ and $\\varepsilon^{n} = \\varepsilon(t_n)$. Define and use internal variables that correspond physically to the stress carried by each Maxwell element.\n\nThen, implement two distinct algorithms:\n- A direct convolution baseline that evaluates $\\sigma^n = \\sigma(t_n)$ exactly under the piecewise-constant strain-rate assumption by summing the contribution of all past intervals and all Maxwell elements.\n- The recursive update algorithm using the derived internal variables.\n\nFor each of the following test cases, compute the stress time series $\\{\\sigma^n\\}_{n=0}^{N-1}$ using both methods and return the maximum absolute difference over all time steps. Use strains as dimensionless quantities, moduli in Pascals (Pa), times in seconds (s), and output differences in Pascals (Pa) as floating-point numbers. Your program must produce a single line containing the list of differences in the specified format.\n\nTest suite:\n1. Happy-path multi-mode case. Parameters: $E_{\\infty} = 1.0\\times 10^{5}$ Pa, modes $\\{(E_1,\\tau_1)=(2.0\\times 10^{5}\\,\\text{Pa},\\,0.1\\,\\text{s}),\\ (E_2,\\tau_2)=(1.0\\times 10^{5}\\,\\text{Pa},\\,1.0\\,\\text{s}),\\ (E_3,\\tau_3)=(5.0\\times 10^{4}\\,\\text{Pa},\\,10.0\\,\\text{s})\\}$, time step $\\Delta t = 0.05$ s, strain sequence $\\{\\varepsilon^n\\}_{n=0}^{9} = [0.0,\\ 0.002,\\ 0.003,\\ 0.0045,\\ 0.0045,\\ 0.003,\\ 0.0035,\\ 0.005,\\ 0.004,\\ 0.004]$.\n2. Boundary case with a very fast mode and large time step. Parameters: $E_{\\infty} = 0.0$ Pa, modes $\\{(E_1,\\tau_1)=(1.0\\times 10^{6}\\,\\text{Pa},\\,0.001\\,\\text{s})\\}$, time step $\\Delta t = 0.1$ s, strain sequence $\\{\\varepsilon^n\\}_{n=0}^{4} = [0.0,\\ 0.01,\\ 0.01,\\ 0.01,\\ 0.01]$.\n3. Edge case with no Maxwell elements. Parameters: $E_{\\infty} = 2.0\\times 10^{5}$ Pa, modes $\\{\\}$ (i.e., $M=0$), time step $\\Delta t = 0.02$ s, strain sequence $\\{\\varepsilon^n\\}_{n=0}^{5} = [0.0,\\ 0.001,\\ 0.002,\\ 0.0015,\\ 0.0015,\\ 0.0005]$.\n4. Small time step relative to slow modes. Parameters: $E_{\\infty} = 0.0$ Pa, modes $\\{(E_1,\\tau_1)=(5.0\\times 10^{5}\\,\\text{Pa},\\,10.0\\,\\text{s}),\\ (E_2,\\tau_2)=(3.0\\times 10^{5}\\,\\text{Pa},\\,5.0\\,\\text{s})\\}$, time step $\\Delta t = 0.001$ s, strain sequence $\\{\\varepsilon^n\\}_{n=0}^{19} = [0.0,\\ 1.0\\times 10^{-4},\\ 2.0\\times 10^{-4},\\ 3.0\\times 10^{-4},\\ 4.0\\times 10^{-4},\\ 5.0\\times 10^{-4},\\ 6.0\\times 10^{-4},\\ 7.0\\times 10^{-4},\\ 8.0\\times 10^{-4},\\ 9.0\\times 10^{-4},\\ 1.0\\times 10^{-3},\\ 1.1\\times 10^{-3},\\ 1.1\\times 10^{-3},\\ 1.05\\times 10^{-3},\\ 1.0\\times 10^{-3},\\ 9.0\\times 10^{-4},\\ 8.0\\times 10^{-4},\\ 7.0\\times 10^{-4},\\ 6.0\\times 10^{-4},\\ 5.0\\times 10^{-4}]$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is the maximum absolute difference in Pascals for the corresponding test case, expressed as a floating-point number.",
            "solution": "The problem requires the derivation of a recursive update algorithm for computing the stress in a linear viscoelastic material described by a Generalized Maxwell Model (GMM), starting from the Boltzmann Superposition Principle (BSP). Subsequently, this recursive algorithm and a direct convolution baseline must be implemented and compared for accuracy.\n\nThe analysis begins with the defining integral form of the BSP for a one-dimensional stress component $\\sigma(t)$ resulting from a strain history $\\varepsilon(t)$:\n$$\n\\sigma(t) = \\int_{0}^{t} E(t - \\xi) \\,\\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi\n$$\nwhere it is assumed that the material is quiescent for $t < 0$, i.e., $\\varepsilon(t)=0$ and $\\sigma(t)=0$ for $t<0$. The relaxation modulus, $E(t)$, for a GMM is given by a Prony series:\n$$\nE(t) = E_{\\infty} + \\sum_{k=1}^{M} E_k\\, e^{-t/\\tau_k}\n$$\nHere, $E_{\\infty}$ is the long-time equilibrium modulus, corresponding to a purely elastic spring in parallel with $M$ Maxwell elements. Each Maxwell element $k$ is characterized by a modulus $E_k$ and a relaxation time $\\tau_k$.\n\nSubstituting the Prony series representation of $E(t)$ into the BSP integral yields:\n$$\n\\sigma(t) = \\int_{0}^{t} \\left( E_{\\infty} + \\sum_{k=1}^{M} E_k\\, e^{-(t-\\xi)/\\tau_k} \\right) \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi\n$$\nBy the linearity of the integral, the stress can be decomposed into an equilibrium (purely elastic) component, $\\sigma_{\\infty}(t)$, and a sum of transient (viscoelastic) components, $\\sigma_k(t)$, from each Maxwell element:\n$$\n\\sigma(t) = \\sigma_{\\infty}(t) + \\sum_{k=1}^{M} \\sigma_k(t)\n$$\nThe equilibrium component is given by:\n$$\n\\sigma_{\\infty}(t) = E_{\\infty} \\int_{0}^{t} \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi = E_{\\infty} [\\varepsilon(t) - \\varepsilon(0)]\n$$\nAssuming zero initial strain, $\\varepsilon(0)=0$, this simplifies to $\\sigma_{\\infty}(t) = E_{\\infty}\\,\\varepsilon(t)$.\n\nEach transient component $\\sigma_k(t)$ is given by:\n$$\n\\sigma_k(t) = \\int_{0}^{t} E_k\\, e^{-(t-\\xi)/\\tau_k} \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi\n$$\n\nThe problem specifies a discrete time evaluation at $t_n = n\\,\\Delta t$ for $n=0, 1, 2, \\dots$. The strain history is defined by the sequence $\\{\\varepsilon^n\\}$, where $\\varepsilon^n = \\varepsilon(t_n)$. The strain rate is assumed to be piecewise constant over each interval $[t_{i-1}, t_i]$, which implies:\n$$\n\\frac{d\\varepsilon(t)}{dt} = \\frac{\\varepsilon^i - \\varepsilon^{i-1}}{\\Delta t} = \\frac{\\Delta\\varepsilon^i}{\\Delta t} \\quad \\text{for } t \\in (t_{i-1}, t_i]\n$$\n\nFirst, we formulate the direct convolution algorithm. The total stress at time $t_n$, denoted $\\sigma^n$, is:\n$$\n\\sigma^n = E_{\\infty}\\,\\varepsilon^n + \\sum_{k=1}^{M} \\sigma_k^n\n$$\nThe transient component $\\sigma_k^n = \\sigma_k(t_n)$ is found by breaking the integral into a sum over past time intervals:\n$$\n\\sigma_k^n = \\sum_{i=1}^{n} \\int_{t_{i-1}}^{t_i} E_k\\, e^{-(t_n-\\xi)/\\tau_k} \\left(\\frac{\\Delta\\varepsilon^i}{\\Delta t}\\right) d\\xi\n$$\nFor each interval $i$, the term $\\frac{\\Delta\\varepsilon^i}{\\Delta t}$ is constant. The integral can be solved analytically:\n$$\n\\int_{t_{i-1}}^{t_i} e^{-(t_n-\\xi)/\\tau_k} d\\xi = \\left[ \\tau_k\\, e^{-(t_n-\\xi)/\\tau_k} \\right]_{\\xi=t_{i-1}}^{\\xi=t_i} = \\tau_k \\left( e^{-(t_n-t_i)/\\tau_k} - e^{-(t_n-t_{i-1})/\\tau_k} \\right)\n$$\nSubstituting $t_n = n\\,\\Delta t$, $t_i = i\\,\\Delta t$, and $t_{i-1}=(i-1)\\Delta t$:\n$$\n\\int_{t_{i-1}}^{t_i} e^{-(t_n-\\xi)/\\tau_k} d\\xi = \\tau_k \\left( e^{-(n-i)\\Delta t/\\tau_k} - e^{-(n-i+1)\\Delta t/\\tau_k} \\right)\n$$\nThus, the contribution from mode $k$ is:\n$$\n\\sigma_k^n = \\sum_{i=1}^{n} E_k \\left(\\frac{\\Delta\\varepsilon^i}{\\Delta t}\\right) \\tau_k \\left( e^{-(n-i)\\Delta t/\\tau_k} - e^{-(n-i+1)\\Delta t/\\tau_k} \\right)\n$$\nThe total stress requires summing this over all modes $k$ and all past time steps $i$. The computational work to find $\\sigma^n$ using this method is $\\mathcal{O}(n M)$, which grows with each time step.\n\nNext, we derive the required recursive update formula. The internal variable for this derivation will be $\\sigma_k^n$, which has the physical meaning of the stress carried by the $k$-th Maxwell element at time $t_n$. We start again with the integral for $\\sigma_k^n$:\n$$\n\\sigma_k^n = \\int_{0}^{t_n} E_k\\, e^{-(t_n-\\xi)/\\tau_k} \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi\n$$\nWe split the integral at the previous time step, $t_{n-1}$:\n$$\n\\sigma_k^n = \\int_{0}^{t_{n-1}} E_k\\, e^{-(t_n-\\xi)/\\tau_k} \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi + \\int_{t_{n-1}}^{t_n} E_k\\, e^{-(t_n-\\xi)/\\tau_k} \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi\n$$\nLet's analyze the first integral term. We can factor out a term $e^{-\\Delta t/\\tau_k}$:\n$$\n\\int_{0}^{t_{n-1}} E_k\\, e^{-(t_n-t_{n-1})/\\tau_k} e^{-(t_{n-1}-\\xi)/\\tau_k} \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi = e^{-\\Delta t/\\tau_k} \\int_{0}^{t_{n-1}} E_k\\, e^{-(t_{n-1}-\\xi)/\\tau_k} \\frac{d\\varepsilon(\\xi)}{d\\xi}\\, d\\xi\n$$\nThe integral on the right is, by definition, the stress on element $k$ at time $t_{n-1}$, which is $\\sigma_k^{n-1}$. Thus, the first term is simply $\\sigma_k^{n-1} e^{-\\Delta t/\\tau_k}$.\n\nNow, for the second integral, which represents the stress generated during the most recent time step $[t_{n-1}, t_n]$. Within this interval, the strain rate is constant: $\\frac{d\\varepsilon}{d\\xi} = \\frac{\\Delta\\varepsilon^n}{\\Delta t}$.\n$$\n\\int_{t_{n-1}}^{t_n} E_k\\, e^{-(t_n-\\xi)/\\tau_k} \\left(\\frac{\\Delta\\varepsilon^n}{\\Delta t}\\right) d\\xi = E_k \\left(\\frac{\\Delta\\varepsilon^n}{\\Delta t}\\right) \\int_{t_{n-1}}^{t_n} e^{-(t_n-\\xi)/\\tau_k} d\\xi\n$$\nThe integral evaluates to:\n$$\n\\left[ \\tau_k\\, e^{-(t_n-\\xi)/\\tau_k} \\right]_{\\xi=t_{n-1}}^{\\xi=t_n} = \\tau_k \\left( e^{0} - e^{-\\Delta t/\\tau_k} \\right) = \\tau_k \\left( 1 - e^{-\\Delta t/\\tau_k} \\right)\n$$\nCombining these results, we obtain the recursive update formula for $\\sigma_k^n$:\n$$\n\\sigma_k^n = \\sigma_k^{n-1} e^{-\\Delta t/\\tau_k} + E_k \\tau_k \\left( \\frac{\\varepsilon^n - \\varepsilon^{n-1}}{\\Delta t} \\right) \\left( 1 - e^{-\\Delta t/\\tau_k} \\right)\n$$\nThis update rule allows the computation of $\\sigma_k^n$ based only on its value at the previous time step, $\\sigma_k^{n-1}$, and the strain increment over the current step. The initial condition is $\\sigma_k^0 = 0$ for all $k$, as the material is initially quiescent.\n\nThe total stress at time $t_n$ is then assembled as:\n$$\n\\sigma^n = E_{\\infty}\\,\\varepsilon^n + \\sum_{k=1}^{M} \\sigma_k^n\n$$\nThe computational work to find $\\sigma^n$ is now $\\mathcal{O}(M)$ for each time step, which is independent of the number of past steps $n$. This fulfills the requirement of an $\\mathcal{O}(1)$ update per Maxwell element.\n\nThe implementation will consist of two functions.\n1.  **Direct Convolution:** This function computes $\\sigma^n$ at each step $n$ by explicitly summing the contributions of all past strain rate increments from $i=1$ to $n$, for all $M$ modes. This has a total computational complexity of $\\mathcal{O}(N^2 M)$ to compute the history up to step $N$.\n2.  **Recursive Update:** This function maintains an array of the internal stress variables $\\{\\sigma_k^{n-1}\\}$. At each step $n$, it updates these variables to $\\{\\sigma_k^{n}\\}$ using the derived recursive formula and sums them to find the total stress. This has a total complexity of $\\mathcal{O}(N M)$ to compute the history up to step $N$.\n\nBoth methods are analytically equivalent under the assumption of piecewise-constant strain rate. Therefore, the difference between their computed stress histories should be attributable only to floating-point representation and arithmetic errors, and thus should be close to zero. The maximum absolute difference across the time series provides a quantitative measure of this equivalence.",
            "answer": "```python\nimport numpy as np\n\ndef compute_stress_direct(e_inf, modes, dt, eps):\n    \"\"\"\n    Computes stress using the direct convolution method.\n    This method has O(N^2 * M) complexity.\n    \"\"\"\n    n_steps = len(eps)\n    sigma = np.zeros(n_steps, dtype=np.float64)\n\n    if n_steps == 0:\n        return sigma\n\n    # Stress at t=0\n    sigma[0] = e_inf * eps[0]\n\n    for n in range(1, n_steps):\n        # Elastic contribution\n        sigma_n = e_inf * eps[n]\n        \n        # Viscoelastic contribution from all past steps\n        for i in range(1, n + 1):\n            d_eps = eps[i] - eps[i-1]\n            if np.abs(d_eps) < 1e-15:  # Avoid division by zero and unnecessary computation\n                continue\n            \n            strain_rate = d_eps / dt\n            \n            for E_k, tau_k in modes:\n                # Analytical integral of the exponential kernel over interval [t_{i-1}, t_i]\n                # for its contribution to stress at t_n\n                term1 = np.exp(-(n - i) * dt / tau_k)\n                term2 = np.exp(-(n - i + 1) * dt / tau_k)\n                integral_val = tau_k * (term1 - term2)\n                sigma_n += E_k * strain_rate * integral_val\n        \n        sigma[n] = sigma_n\n        \n    return sigma\n\ndef compute_stress_recursive(e_inf, modes, dt, eps):\n    \"\"\"\n    Computes stress using the recursive update algorithm.\n    This method has O(N * M) complexity.\n    \"\"\"\n    n_steps = len(eps)\n    sigma = np.zeros(n_steps, dtype=np.float64)\n    \n    if n_steps == 0:\n        return sigma\n\n    num_modes = len(modes)\n    sigma_k = np.zeros(num_modes, dtype=np.float64) # Internal variables (stress per mode)\n\n    # Pre-calculate factors for efficiency\n    exp_factors = np.array([np.exp(-dt / tau_k) for _, tau_k in modes], dtype=np.float64)\n    \n    # Stress at t=0\n    sigma[0] = e_inf * eps[0] + np.sum(sigma_k) # sigma_k is zero here\n\n    for n in range(1, n_steps):\n        d_eps = eps[n] - eps[n-1]\n        \n        # Viscoelastic contribution (update internal variables)\n        for k in range(num_modes):\n            E_k, tau_k = modes[k]\n            \n            # Stress increment from strain change in [t_{n-1}, t_n]\n            # This is E_k * (d_eps/dt) * integral(exp(-(t_n-xi)/tau_k), xi=t_{n-1}..t_n)\n            increment = 0.0\n            if np.abs(d_eps) > 1e-15:\n                strain_rate = d_eps / dt\n                factor = E_k * tau_k * (1.0 - exp_factors[k])\n                increment = factor * strain_rate\n\n            # Recursive update\n            sigma_k[k] = sigma_k[k] * exp_factors[k] + increment\n\n        # Total stress is elastic part + sum of mode stresses\n        sigma[n] = e_inf * eps[n] + np.sum(sigma_k)\n        \n    return sigma\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute differences.\n    \"\"\"\n    test_cases = [\n        # Case 1: Happy-path multi-mode case\n        {\n            \"e_inf\": 1.0e5,\n            \"modes\": [(2.0e5, 0.1), (1.0e5, 1.0), (5.0e4, 10.0)],\n            \"dt\": 0.05,\n            \"eps\": np.array([0.0, 0.002, 0.003, 0.0045, 0.0045, 0.003, 0.0035, 0.005, 0.004, 0.004], dtype=np.float64)\n        },\n        # Case 2: Boundary case with a very fast mode and large time step\n        {\n            \"e_inf\": 0.0,\n            \"modes\": [(1.0e6, 0.001)],\n            \"dt\": 0.1,\n            \"eps\": np.array([0.0, 0.01, 0.01, 0.01, 0.01], dtype=np.float64)\n        },\n        # Case 3: Edge case with no Maxwell elements\n        {\n            \"e_inf\": 2.0e5,\n            \"modes\": [],\n            \"dt\": 0.02,\n            \"eps\": np.array([0.0, 0.001, 0.002, 0.0015, 0.0015, 0.0005], dtype=np.float64)\n        },\n        # Case 4: Small time step relative to slow modes\n        {\n            \"e_inf\": 0.0,\n            \"modes\": [(5.0e5, 10.0), (3.0e5, 5.0)],\n            \"dt\": 0.001,\n            \"eps\": np.array([0.0, 1e-4, 2e-4, 3e-4, 4e-4, 5e-4, 6e-4, 7e-4, 8e-4, 9e-4, 1e-3, 1.1e-3, 1.1e-3, 1.05e-3, 1.0e-3, 9e-4, 8e-4, 7e-4, 6e-4, 5e-4], dtype=np.float64)\n        }\n    ]\n\n    max_differences = []\n\n    for case in test_cases:\n        e_inf = case[\"e_inf\"]\n        modes = case[\"modes\"]\n        dt = case[\"dt\"]\n        eps = case[\"eps\"]\n\n        sigma_direct = compute_stress_direct(e_inf, modes, dt, eps)\n        sigma_recursive = compute_stress_recursive(e_inf, modes, dt, eps)\n        \n        diff = np.max(np.abs(sigma_direct - sigma_recursive))\n        max_differences.append(diff)\n\n    print(f\"[{','.join(f'{d:.12f}' for d in max_differences)}]\")\n    \nsolve()\n\n```"
        }
    ]
}