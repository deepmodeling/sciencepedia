{
    "hands_on_practices": [
        {
            "introduction": "在深入研究真实聚合物链的复杂性之前，我们必须首先掌握理想链模型。这个练习是理解聚合物统计力学的基础，它将演示在没有排除体积效应的情况下，键矢量之间的不相关性如何导致了特征性的随机游走标度关系 $\\langle R^2 \\rangle \\sim N$。这个结果是所有后续模型的关键参考基准。",
            "id": "4101369",
            "problem": "在θ溶剂中的聚合物可以被建模为一个理想自由连接链，它由 $N$ 个统计独立的键矢量 $\\{\\mathbf{b}_{i}\\}_{i=1}^{N}$ 组成，每个键矢量长度固定为 $b$ 且各向同性取向。端到端矢量为 $\\mathbf{R}=\\sum_{i=1}^{N}\\mathbf{b}_{i}$。假设键矢量是独立同分布的，其均值 $\\langle \\mathbf{b}_{i} \\rangle=\\mathbf{0}$，并且其分布在空间中是各向同性的。\n\n仅从这些假设和系综平均的基本性质出发，计算精确的系综平均均方端到端距离 $\\langle R^{2} \\rangle$，并将其表示为 $N$ 和 $b$ 的函数。然后，论证在这种理想链极限下，键矢量的独立性和各向同性是如何决定 $\\langle R^{2} \\rangle$ 相对于 $N$ 和 $b$ 的标度关系的，并与带有排除体积的真实链（自回避行走）进行对比。\n\n将你的最终答案表示为关于 $N$ 和 $b$ 的单个闭合形式符号表达式。在最终的方框答案中不要包含单位。",
            "solution": "该问题陈述在科学上是合理的，提法恰当，并包含了推导唯一解所需的所有信息。它描述了自由连接链模型——这是聚合物统计力学的一个基石，并要求推导一个基本结果。因此，将提供一个解答。\n\n我们主要关心的量是均方端到端距离 $\\langle R^{2} \\rangle$。端到端矢量 $\\mathbf{R}$ 定义为所有单个键矢量 $\\{\\mathbf{b}_{i}\\}_{i=1}^{N}$ 的和：\n$$\n\\mathbf{R} = \\sum_{i=1}^{N} \\mathbf{b}_{i}\n$$\n端到端距离的平方 $R^{2}$ 是矢量 $\\mathbf{R}$ 与自身的标量积：\n$$\nR^{2} = \\mathbf{R} \\cdot \\mathbf{R} = \\left(\\sum_{i=1}^{N} \\mathbf{b}_{i}\\right) \\cdot \\left(\\sum_{j=1}^{N} \\mathbf{b}_{j}\\right)\n$$\n展开这个乘积得到一个双重求和：\n$$\nR^{2} = \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j}\n$$\n我们需要计算这个量的系综平均 $\\langle R^{2} \\rangle$。系综平均算符 $\\langle \\cdot \\rangle$ 是线性的。因此，我们可以将算符移到求和号内部：\n$$\n\\langle R^{2} \\rangle = \\left\\langle \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\right\\rangle = \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle\n$$\n为了计算这个双重求和，将指数相等（$i=j$）的项与指数不相等（$i \\neq j$）的项分开是很有帮助的：\n$$\n\\langle R^{2} \\rangle = \\sum_{i=1}^{N} \\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{i} \\rangle + \\sum_{i=1}^{N} \\sum_{j \\neq i}^{N} \\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle\n$$\n让我们分别分析这两个和。\n\n对于第一个和，项 $\\mathbf{b}_{i} \\cdot \\mathbf{b}_{i}$ 是第 $i$ 个键矢量模的平方，即 $|\\mathbf{b}_{i}|^{2}$。问题陈述指明每个键的长度固定为 $b$。因此，对于任何键 $i$，有 $|\\mathbf{b}_{i}| = b$，这意味着 $|\\mathbf{b}_{i}|^{2} = b^{2}$。由于 $b^{2}$ 是一个常数，它的系综平均就是它本身：\n$$\n\\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{i} \\rangle = \\langle |\\mathbf{b}_{i}|^{2} \\rangle = \\langle b^{2} \\rangle = b^{2}\n$$\n第一个和包含 $N$ 个这样的相同项，变为：\n$$\n\\sum_{i=1}^{N} \\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{i} \\rangle = \\sum_{i=1}^{N} b^{2} = N b^{2}\n$$\n\n对于第二个和，我们考虑 $i \\neq j$ 的项。问题陈述指出键矢量是统计独立的。对于两个独立的随机变量（在此情况下是矢量 $\\mathbf{b}_{i}$ 和 $\\mathbf{b}_{j}$），它们乘积的期望等于它们各自期望的乘积。虽然点积不是简单的标量乘积，但我们可以利用独立性。对于 $i \\neq j$ 的情况，矢量 $\\mathbf{b}_{i}$ 和 $\\mathbf{b}_{j}$ 是不相关的。从统计独立性导出的一个关键性质是，乘积的平均值等于平均值的乘积。因此：\n$$\n\\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle = \\langle \\mathbf{b}_{i} \\rangle \\cdot \\langle \\mathbf{b}_{j} \\rangle \\quad \\text{for } i \\neq j\n$$\n问题中给出任何键矢量的均值为零，即对所有 $i$ 都有 $\\langle \\mathbf{b}_{i} \\rangle = \\mathbf{0}$。这是所述的键的各向同性取向的直接结果；空间中没有优选方向。将此代入交叉项的表达式中，得到：\n$$\n\\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle = \\mathbf{0} \\cdot \\mathbf{0} = 0\n$$\n由于第二个和中所有 $i \\neq j$ 的项都为零，整个和消失：\n$$\n\\sum_{i=1}^{N} \\sum_{j \\neq i}^{N} \\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle = 0\n$$\n结合这两个和的结果，我们得到均方端到端距离的精确表达式：\n$$\n\\langle R^{2} \\rangle = N b^{2} + 0 = N b^{2}\n$$\n\n关于 $\\langle R^{2} \\rangle$ 相对于 $N$ 和 $b$ 的标度关系的论证就蕴含在这个推导中。与链段数 $N$ 的线性标度关系 $\\langle R^{2} \\rangle \\propto N$ 是随机行走过程的一个标志。它直接源于键矢量的统计独立性，这使得所有 $i \\neq j$ 的取向交叉相关项 $\\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle$ 都消失了。各向同性假设保证了 $\\langle\\mathbf{b}_{i}\\rangle = \\mathbf{0}$，这对于这种抵消至关重要。与 $b^{2}$ 的标度关系仅仅反映了这种随机行走的基本步长是 $b$。\n\n相比之下，真实聚合物链不能被建模为简单的随机行走。理想链模型中不存在的主要物理约束是排除体积效应：链的两个部分不能占据空间中的同一位置。这一约束在沿链轮廓相距很远但在空间上可能很近的链段之间引入了长程相关。链的轨迹变成了自回避行走（SAW），而不是简单的随机行走。因此，$\\mathbf{b}_{i}$ 和 $\\mathbf{b}_{j}$ 的统计独立性假设不再成立，即使对于大的 $|i-j|$，$\\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle \\neq 0$。这些相关性平均而言是正的（链倾向于溶胀以避免自身），导致比理想链更伸展的构象。对于 $d=3$ 维空间中的自回避行走，Flory 理论和更精密的重整化群计算预测了不同的标度定律：\n$$\n\\langle R^{2} \\rangle \\sim N^{2\\nu}\n$$\n其中 $\\nu$ 是 Flory 指数。对于 $d=3$，$\\nu \\approx 0.588$，这显著大于理想链的指数 $\\nu = 1/2$（因为 $\\langle R^{2} \\rangle = N b^{2} = N^{2(1/2)} b^{2}$）。这表明，在良溶剂中，真实链会溶胀到比同样长度 $N$ 的理想链大得多的尺寸。理想链模型对应于θ溶剂的特殊情况，在这种情况下，单体-溶剂间的吸引作用恰好平衡了排斥性的排除体积效应，导致链的行为有效地等同于随机行走。",
            "answer": "$$\n\\boxed{N b^{2}}\n$$"
        },
        {
            "introduction": "建立了理想链的基准后，我们现在引入排除体积效应，这是真实聚合物链的核心特征。本练习将运用经典的 Flory 理论，通过构建一个平衡链的熵弹性与单体间排斥相互作用的平均场自由能，来推导决定真实聚合物尺寸的著名 Flory 指数。这是一个展现物理洞察力如何将复杂问题简化的绝佳范例。",
            "id": "4101378",
            "problem": "考虑一个长聚合物链，在$d$维空间中，其在良溶剂中的模型为自回避行走。该聚合物链有$N$个长度为$a$的Kuhn链段，以及一个正的双体排除体积参数$v$，满足$v = c_{v}\\,a^{d}$，其中$c_{v}$是一个量级为1的无量纲常数。在Flory的平均场方法中，一个端到端距离为$R$的构象的亥姆霍兹自由能（以$k_{B}T$为单位）被估算为一个熵弹性项和一个平均场相互作用项之和。使用以下基本假设，这些假设在真实聚合物链理论中是标准且经过充分检验的：\n- 高斯链的熵弹性贡献为 $F_{\\mathrm{el}}/(k_{B}T) \\sim c_{1}\\,R^{2}/(a^{2}N)$，其中$c_{1}$是一个量级为1的常数。\n- 在第二维里系数近似的水平上，排斥性双体相互作用的贡献为 $F_{\\mathrm{int}}/(k_{B}T) \\sim c_{2}\\,v\\,N^{2}/R^{d}$，其中$c_{2}$是一个量级为1的常数。\n\n基于这些要素，完成以下任务：\n1. 对总自由能关于$R$求最小值，以获得均方端到端距离$\\langle R^{2} \\rangle$作为$N$、$a$、$d$和$v$的函数的标度形式，并保留对$c_{1}$和$c_{2}$的依赖关系。\n2. 通过$\\langle R^{2} \\rangle \\sim a^{2}N^{2\\nu_{F}}$定义Flory指数$\\nu_{F}$，并导出由下式定义的无量纲振幅$C_{F}(d,c_{1},c_{2},c_{v})$：\n$$\n\\langle R^{2} \\rangle \\equiv C_{F}(d,c_{1},c_{2},c_{v})\\,a^{2}\\,N^{2\\nu_{F}}.\n$$\n3. 专用于三维情况，即$d=3$，并取$c_{1}=1$、$c_{2}=1$和$c_{v}=1$。计算所得的无量纲前因子$C_{F}(3,1,1,1)$的精确表达式。你的最终答案必须是这个单一值。不要四舍五入。\n4. 用文字简要评论这个前因子和指数相对于重整化群(RG)结果的局限性。\n\n你的最终答案必须是一个单一的精确实数。最终答案中不需要单位，因为它是无量纲的。最终答案中不要提供任何不等式或方程。",
            "solution": "首先对问题陈述进行验证。\n\n**第一步：提取已知条件**\n- 聚合物模型：良溶剂中的自回避行走。\n- 空间维度：$d$。\n- 链段数量：$N$。\n- 链段长度：$a$。\n- 双体排除体积参数：$v  0$。\n- 排除体积关系：$v = c_{v}\\,a^{d}$，其中$c_{v}$是量级为1的无量纲常数。\n- 熵弹性自由能：$F_{\\mathrm{el}}/(k_{B}T) \\sim c_{1}\\,R^{2}/(a^{2}N)$，其中$c_{1}$是量级为1的常数。\n- 平均场相互作用自由能：$F_{\\mathrm{int}}/(k_{B}T) \\sim c_{2}\\,v\\,N^{2}/R^{d}$，其中$c_{2}$是量级为1的常数。\n- 总自由能：$F = F_{\\mathrm{el}} + F_{\\mathrm{int}}$。\n- Flory指数$\\nu_{F}$的定义：$\\langle R^{2} \\rangle \\sim a^{2}N^{2\\nu_{F}}$。\n- 无量纲振幅的定义：$\\langle R^{2} \\rangle \\equiv C_{F}(d,c_{1},c_{2},c_{v})\\,a^{2}\\,N^{2\\nu_{F}}$。\n\n**第二步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题是理论聚合物物理学中一个经典且基础的练习，基于成熟的Flory平均场理论。所有概念和方程在该领域都是标准的。\n- **良态问题：** 问题结构清晰，包含一系列任务，基于所给假设可以导出一个唯一解。\n- **客观性：** 语言正式且精确，没有任何主观或模糊的术语。\n- **完整性和一致性：** 提供了所有必要信息。通过保留常数$c_{1}$和$c_{2}$的指令，澄清了比例符号`~`的用法，实际上在计算中将这些关系视为等式。已知条件是相互一致的。\n- **其他缺陷：** 该问题没有其他列出的缺陷，如不切实际、病态或过于简单。\n\n**第三步：结论与行动**\n问题有效。将提供解答。\n\n一个端到端距离为$R$的聚合物构象的总亥姆霍兹自由能$F$（以$k_{B}T$为单位）是熵弹性项和相互作用项之和。记$f(R) = F/(k_{B}T)$，我们有：\n$$\nf(R) = \\frac{F_{\\mathrm{el}}}{k_{B}T} + \\frac{F_{\\mathrm{int}}}{k_{B}T} = c_{1}\\frac{R^{2}}{a^{2}N} + c_{2}\\frac{v N^{2}}{R^{d}}\n$$\n其中，使用等号是合理的，因为题目指示保留常数$c_{1}$和$c_{2}$。\n\n**1. 自由能的最小化**\n为了找到平衡态的端到端距离（我们记为$R_{F}$），我们将自由能$f(R)$对$R$求最小值。这通过求$f(R)$对$R$的导数并令其为零来实现。\n$$\n\\frac{df}{dR} = \\frac{d}{dR} \\left( c_{1}R^{2}(a^{2}N)^{-1} + c_{2}vN^{2}R^{-d} \\right) = 2c_{1}R(a^{2}N)^{-1} - dc_{2}vN^{2}R^{-d-1}\n$$\n令导数为零以求最小值：\n$$\n\\frac{2c_{1}R_{F}}{a^{2}N} - \\frac{dc_{2}vN^{2}}{R_{F}^{d+1}} = 0\n$$\n$$\n\\frac{2c_{1}R_{F}}{a^{2}N} = \\frac{dc_{2}vN^{2}}{R_{F}^{d+1}}\n$$\n我们求解$R_{F}$：\n$$\nR_{F}^{d+2} = \\frac{dc_{2}vN^{2}a^{2}N}{2c_{1}} = \\left( \\frac{dc_{2}v}{2c_{1}} \\right) a^{2}N^{3}\n$$\n为确认这是一个最小值，我们检查二阶导数：\n$$\n\\frac{d^{2}f}{dR^{2}} = \\frac{2c_{1}}{a^{2}N} + d(d+1)c_{2}vN^{2}R^{-d-2}\n$$\n由于所有参数（$c_{1}$, $c_{2}$, $v$, $N$, $a$, $d$）均为正，对于所有$R>0$，$\\frac{d^{2}f}{dR^{2}} > 0$，这证实了$R_{F}$对应于自由能的一个最小值。\n\n在此平均场近似中，均方端到端距离$\\langle R^{2} \\rangle$被等同于$R_{F}^{2}$。\n$$\n\\langle R^{2} \\rangle = R_{F}^{2} = \\left[ \\left( \\frac{dc_{2}v}{2c_{1}} \\right) a^{2}N^{3} \\right]^{\\frac{2}{d+2}} = \\left( \\frac{dc_{2}v}{2c_{1}} \\right)^{\\frac{2}{d+2}} a^{\\frac{4}{d+2}} N^{\\frac{6}{d+2}}\n$$\n这就是$\\langle R^{2} \\rangle$的标度形式。\n\n**2. Flory指数与振幅**\n我们已知定义$\\langle R^{2} \\rangle \\sim a^{2}N^{2\\nu_{F}}$。将其与我们推导出的关于$N$的标度关系$\\langle R^{2} \\rangle \\propto N^{\\frac{6}{d+2}}$进行比较，我们确定：\n$$\n2\\nu_{F} = \\frac{6}{d+2} \\implies \\nu_{F} = \\frac{3}{d+2}\n$$\n这就是著名的Flory指数。\n\n为求无量纲振幅$C_{F}$，我们使用定义$\\langle R^{2} \\rangle \\equiv C_{F}(d,c_{1},c_{2},c_{v})\\,a^{2}\\,N^{2\\nu_{F}}$。我们首先将$v = c_{v}a^{d}$代入我们得到的$\\langle R^{2} \\rangle$表达式中：\n$$\n\\langle R^{2} \\rangle = \\left( \\frac{dc_{2}(c_{v}a^{d})}{2c_{1}} \\right)^{\\frac{2}{d+2}} a^{\\frac{4}{d+2}} N^{\\frac{6}{d+2}}\n$$\n$$\n\\langle R^{2} \\rangle = \\left( \\frac{dc_{2}c_{v}}{2c_{1}} \\right)^{\\frac{2}{d+2}} (a^{d})^{\\frac{2}{d+2}} a^{\\frac{4}{d+2}} N^{\\frac{6}{d+2}}\n$$\n$$\n\\langle R^{2} \\rangle = \\left( \\frac{dc_{2}c_{v}}{2c_{1}} \\right)^{\\frac{2}{d+2}} a^{\\frac{2d}{d+2}} a^{\\frac{4}{d+2}} N^{\\frac{6}{d+2}}\n$$\n$$\n\\langle R^{2} \\rangle = \\left( \\frac{dc_{2}c_{v}}{2c_{1}} \\right)^{\\frac{2}{d+2}} a^{\\frac{2d+4}{d+2}} N^{\\frac{6}{d+2}} = \\left( \\frac{dc_{2}c_{v}}{2c_{1}} \\right)^{\\frac{2}{d+2}} a^{2} N^{\\frac{6}{d+2}}\n$$\n将此结果与定义$\\langle R^{2} \\rangle \\equiv C_{F}\\,a^{2}\\,N^{2\\nu_{F}}$进行比较，并注意到$2\\nu_{F} = 6/(d+2)$，我们可以直接确定振幅$C_{F}$：\n$$\nC_{F}(d,c_{1},c_{2},c_{v}) = \\left( \\frac{dc_{2}c_{v}}{2c_{1}} \\right)^{\\frac{2}{d+2}}\n$$\n\n**3. $C_{F}$的具体值**\n我们专用于三维情况（$d=3$），并将量级为1的常数设为单位1：$c_{1}=1$，$c_{2}=1$，且$c_{v}=1$。\n$$\nC_{F}(3,1,1,1) = \\left( \\frac{(3)(1)(1)}{2(1)} \\right)^{\\frac{2}{3+2}} = \\left( \\frac{3}{2} \\right)^{\\frac{2}{5}}\n$$\n这就是所要求的精确值。\n\n**4. 关于局限性的评论**\nFlory理论提供了一个强大而简单的物理论证。然而，它是一种平均场理论，与重整化群(RG)和高精度计算机模拟等更严谨的方法相比，存在已知的局限性。\n- **指数$\\nu_{F}$**：对于$d=3$，Flory指数为$\\nu_{F} = 3/(3+2) = 3/5 = 0.6$。这与从RG和模拟中得到的公认最佳值$\\nu \\approx 0.588$非常接近。虽然是一个极好的近似，但Flory指数对于$d=3$并不精确。这种差异的产生是因为对相互作用的平均场处理和对链熵的高斯近似并非完全自洽，并且忽略了细微的空间关联。\n- **前因子$C_{F}$**：前因子$C_{F}$的数值高度依赖于非普适的、量级为1的常数$c_{1}$、$c_{2}$和$c_{v}$。这些常数吸收了所有未被标度变量$N$和$v$捕捉到的聚合物和溶剂的微观细节。RG理论确立了虽然像$\\nu$这样的指数是普适的（不依赖于微观细节），但振幅通常不是。因此，计算出的$C_{F}(3,1,1,1)$的值应被视为一个依赖于模型的估计值，而不是一个基本的物理常数。RG可以预测振幅的普适比率，但不能预测其绝对值。",
            "answer": "$$\\boxed{\\left(\\frac{3}{2}\\right)^{\\frac{2}{5}}}$$"
        },
        {
            "introduction": "理论模型固然强大，但通过计算机构建和观察模型能带来更深刻的直观理解。这个计算练习要求你编写一个算法来生成和计数格点上的所有自回避行走路径。这项动手编程任务将让你具体地理解聚合物构象数量的组合爆炸，并使你能够通过数值方法探索其连通常数等基本性质。",
            "id": "4101356",
            "problem": "在整数方格点阵 $\\mathbb{Z}^2$ 上的自回避行走（SAW）是一种不重复访问任何格点的最近邻路径。在计算复杂流体中，良溶剂中的真实聚合物链可以通过SAW进行建模，以捕捉排除体积效应。考虑从原点 $(0,0)$ 开始，长度为 $N$ 步的SAW集合，其中每一步在四个基本方向之一上移动一个单位。设 $c_N$ 表示长度为 $N$ 的此类SAW的总数。\n\n仅从自回避行走的定义（即路径访问过的位点各不相同）以及路径段拼接计数满足次可乘性这一经过充分检验的事实（即 $c_{M+N} \\le c_M c_N$，因为任意拼接不一定能保持自回避性）出发，构建一个算法来枚举方形点阵上长度为 $N$ 且 $N \\le 6$ 的所有SAW。\n\n您的任务是：\n- 从第一性原理出发，推导出一个枚举策略，该策略通过探索最近邻步骤的完整搜索树，并强制执行自回避性，系统地生成所有长度为 $N$ 的SAW，并用它来计算 $N \\in \\{0,1,2,3,4,5,6\\}$ 时的 $c_N$。\n- 使用枚举出的计数来表征增长模式，方法是为每个 $N \\ge 1$ 计算比率 $r_N = c_N / c_{N-1}$ 和根估计量 $g_N = c_N^{1/N}$，这些都是连接常数 $\\mu$ 的经典有限-$N$估计量。\n- 对测试对 $(M,N) \\in \\{(1,1),(2,2),(3,3)\\}$ 验证次可乘性不等式 $c_{M+N} \\le c_M c_N$，为每次检查返回一个布尔值。\n\n由于 $c_N$、$r_N$ 和 $g_N$ 是无量纲量，因此不涉及物理单位。角度不属于此计算的一部分。所有输出必须是数值且可量化的。\n\n测试套件：\n- 枚举情况：$N \\in \\{0,1,2,3,4,5,6\\}$。\n- 次可乘性检查：$(M,N) \\in \\{(1,1),(2,2),(3,3)\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内无空格，顺序如下：\n  1. 七个整数 $c_0,c_1,c_2,c_3,c_4,c_5,c_6$。\n  2. 六个浮点数 $r_1,r_2,r_3,r_4,r_5,r_6$，每个都四舍五入到六位小数。\n  3. 六个浮点数 $g_1,g_2,g_3,g_4,g_5,g_6$，每个都四舍五入到六位小数。\n  4. 对应于 $(M,N)=(1,1),(2,2),(3,3)$ 的三个次可乘性检查的布尔值，按此顺序排列。\n\n为清晰起见，所需输出将因此包含 $22$ 个条目，后跟 $3$ 个布尔值，全部在一个扁平列表中。例如，输出必须具有确切的形式 $[c_0,c_1,\\dots,c_6,r_1,\\dots,r_6,g_1,\\dots,g_6,b_{11},b_{22},b_{33}]$，其中 $b_{11},b_{22},b_{33}$ 是三个不等式检查的布尔值。",
            "solution": "问题陈述已经过验证，被认为是**有效的**。它在科学上基于已建立的自回避行走理论，该理论是聚合物统计力学模型的基石。问题定义明确，具有清晰、客观的定义和可计算的唯一解。所有必要条件都已提供，且无矛盾之处。\n\n解决方案按要求分为三部分：行走计数的枚举、其增长模式的分析以及一个基本数学性质的验证。\n\n### 第一部分：自回避行走的枚举 ($c_N$)\n\n在方形点阵 $\\mathbb{Z}^2$ 上长度为 $N$ 的自回避行走（SAW）是一个由不同顶点组成的序列 $(p_0, p_1, \\dots, p_N)$，其中 $p_0 = (0,0)$，并且每个后续顶点 $p_{i+1}$ 都是其前驱 $p_i$ 的最近邻点。此类行走的数量表示为 $c_N$。\n\n为了从第一性原理计算 $c_N$，我们开发了一种基于递归回溯的系统枚举策略。该算法探索从原点开始的所有可能的最近邻路径树，并剪除任何试图重访某一位点的分支。\n\n该算法可以被形式化为一个递归函数，我们称之为 `CountWalks(current_pos, visited_sites, steps_remaining)`。\n- **状态表示**：搜索在任何一点的状态由三个元素定义：\n    1. `current_pos`：行走终点的当前坐标 $(x,y)$。\n    2. `visited_sites`：一个集合数据结构，包含到目前为止访问过的所有唯一顶点，包括起点。使用集合可以高效地（平均 $O(1)$ 时间）检查自回避约束。\n    3. `steps_remaining`：为达到总长度 $N$ 还需行走的步数。\n\n- **递归逻辑**：\n    - **基准情形**：如果 `steps_remaining` 为 $0$，表示已构建一个长度为 $N$ 的有效SAW。函数返回 $1$ 以计算这条成功的路径。\n    - **递归步骤**：如果 `steps_remaining` 大于 $0$，函数会遍历 `current_pos` 的四个基本方向的邻居。对于每个潜在的 `next_pos`：\n        1. 检查 `next_pos` 是否已在 `visited_sites` 集合中。\n        2. 如果不在，说明到目前为止路径是有效的。算法接着会：\n            a. 将 `next_pos` 添加到 `visited_sites` 中。\n            b. 进行递归调用：`CountWalks(next_pos, visited_sites, steps_remaining - 1)`。\n            c. 将此递归调用返回的整数加到当前层的运行总数中。\n            d. **回溯**，通过从 `visited_sites` 中移除 `next_pos`。这是允许搜索从 `current_pos` 探索其他分支的关键步骤。\n    - 函数返回从所有有效递归分支累积的总计数。\n\n- **初始调用**：要计算 $c_N$，对函数的初始调用是 `CountWalks(current_pos=(0,0), visited_sites={(0,0)}, steps_remaining=N)`。根据定义，$N=0$ 的计数是 $c_0=1$，代表一个停留在原点的零步长行走。\n\n对 $N \\in \\{0, 1, 2, 3, 4, 5, 6\\}$ 执行此算法，得到以下计数：\n- $c_0 = 1$\n- $c_1 = 4$\n- $c_2 = 12$\n- $c_3 = 36$\n- $c_4 = 100$\n- $c_5 = 284$\n- $c_6 = 780$\n\n### 第二部分：增长模式表征 ($r_N$ 和 $g_N$)\n\n在枚举了精确计数 $c_N$ 之后，我们使用两种标准的有限-$N$估计量来分析连接常数 $\\mu$ 的增长模式。\n1.  连续项的比率，$r_N = c_N / c_{N-1}$。\n2.  根估计量，$g_N = c_N^{1/N}$。\n\n已知对于大的 $N$，$r_N$ 和 $g_N$ 都会收敛到 $\\mu$。对于 $N \\in \\{1, 2, 3, 4, 5, 6\\}$ 的计算如下：\n\n- **比率 $r_N$**：\n  - $r_1 = c_1 / c_0 = 4 / 1 = 4.0$\n  - $r_2 = c_2 / c_1 = 12 / 4 = 3.0$\n  - $r_3 = c_3 / c_2 = 36 / 12 = 3.0$\n  - $r_4 = c_4 / c_3 = 100 / 36 \\approx 2.777778$\n  - $r_5 = c_5 / c_4 = 284 / 100 = 2.84$\n  - $r_6 = c_6 / c_5 = 780 / 284 \\approx 2.746479$\n\n- **根估计量 $g_N$**：\n  - $g_1 = c_1^{1/1} = 4^{1} = 4.0$\n  - $g_2 = c_2^{1/2} = 12^{1/2} \\approx 3.464102$\n  - $g_3 = c_3^{1/3} = 36^{1/3} \\approx 3.301927$\n  - $g_4 = c_4^{1/4} = 100^{1/4} \\approx 3.162278$\n  - $g_5 = c_5^{1/5} = 284^{1/5} \\approx 3.097014$\n  - $g_6 = c_6^{1/6} = 780^{1/6} \\approx 3.033621$\n\n### 第三部分：次可乘性验证\n\n问题要求验证指定对的次可乘性不等式 $c_{M+N} \\le c_M c_N$。这个性质的产生是因为拼接两个SAW并不能保证结果行走是自回避的，这意味着组合行走的数量 $c_{M+N}$ 必须小于或等于构成它的行走数量的乘积 $c_M c_N$。\n\n我们对测试对 $(M,N) \\in \\{(1,1), (2,2), (3,3)\\}$ 进行检验。\n\n- **情况 $(M,N) = (1,1)$**：\n  - 我们检查是否 $c_{1+1} \\le c_1 \\times c_1$。\n  - 这可转化为 $c_2 \\le c_1^2$。\n  - 代入数值：$12 \\le 4^2 \\implies 12 \\le 16$。这是正确的。\n\n- **情况 $(M,N) = (2,2)$**：\n  - 我们检查是否 $c_{2+2} \\le c_2 \\times c_2$。\n  - 这可转化为 $c_4 \\le c_2^2$。\n  - 代入数值：$100 \\le 12^2 \\implies 100 \\le 144$。这是正确的。\n\n- **情况 $(M,N) = (3,3)$**：\n  - 我们检查是否 $c_{3+3} \\le c_3 \\times c_3$。\n  - 这可转化为 $c_6 \\le c_3^2$。\n  - 代入数值：$780 \\le 36^2 \\implies 780 \\le 1296$。这是正确的。\n\n所有三个检查都证实了给定对的次可乘性。最终程序将系统地计算这些值和布尔值，并按指定格式进行格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes properties of self-avoiding walks (SAWs) on a 2D square lattice.\n    - Enumerates the number of SAWs c_N for lengths N = 0 to 6.\n    - Calculates growth estimators r_N and g_N.\n    - Verifies the submultiplicativity property for specific cases.\n    \"\"\"\n\n    # Memoization cache for the recursive counter to optimize, though for N=6\n    # it is not strictly necessary but good practice.\n    # A simple depth-first search counter is sufficient and clear.\n    \n    def _count_recursive(pos, visited_sites, steps_left):\n        \"\"\"\n        Recursively counts SAWs from a given state using backtracking.\n        \n        Args:\n            pos (tuple): The current (x, y) position of the walk.\n            visited_sites (set): A set of (x, y) tuples of visited sites.\n            steps_left (int): The number of steps remaining in the walk.\n\n        Returns:\n            int: The number of valid SAWs from the current state.\n        \"\"\"\n        # Base case: if no steps are left, we have found one complete walk.\n        if steps_left == 0:\n            return 1\n        \n        count = 0\n        x, y = pos\n        \n        # Explore the four cardinal directions.\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            next_pos = (x + dx, y + dy)\n            \n            # If the next position has not been visited, explore from there.\n            if next_pos not in visited_sites:\n                # 1. Add the new site to the visited set for the recursive call.\n                visited_sites.add(next_pos)\n                \n                # 2. Recurse with decremented steps.\n                count += _count_recursive(next_pos, visited_sites, steps_left - 1)\n                \n                # 3. Backtrack: remove the site to allow other paths to be explored.\n                visited_sites.remove(next_pos)\n                \n        return count\n\n    def get_cn(n):\n        \"\"\"\n        Computes the number of SAWs of length n, c_n.\n        \n        Args:\n            n (int): The length of the walk.\n\n        Returns:\n            int: The total number of SAWs of length n.\n        \"\"\"\n        # By definition, there is one SAW of length 0 (the origin point).\n        if n == 0:\n            return 1\n            \n        # For n > 0, start the recursive count from the origin.\n        start_pos = (0, 0)\n        visited_sites = {start_pos}\n        return _count_recursive(start_pos, visited_sites, n)\n\n    # 1. Enumerate c_N for N in {0, ..., 6}\n    # These are the number of self-avoiding walks of length N.\n    cn_values = [get_cn(n) for n in range(7)]\n\n    # 2. Compute ratios r_N = c_N / c_{N-1}\n    # This is a finite-N estimator for the connective constant.\n    rn_values = []\n    for i in range(1, 7):\n        val = cn_values[i] / cn_values[i-1]\n        rn_values.append(round(val, 6))\n\n    # 3. Compute root estimators g_N = c_N^(1/N)\n    # This is another finite-N estimator for the connective constant.\n    gn_values = []\n    for i in range(1, 7):\n        val = cn_values[i] ** (1/i)\n        gn_values.append(round(val, 6))\n\n    # 4. Verify submultiplicativity property: c_{M+N} = c_M * c_N\n    bool_values = []\n    for m in [1, 2, 3]:\n        # The problem asks for pairs (M,N) = (1,1), (2,2), (3,3)\n        is_valid = cn_values[m + m] = cn_values[m] * cn_values[m]\n        bool_values.append(is_valid)\n\n    # Combine all results into a single list in the specified order.\n    all_results = cn_values + rn_values + gn_values + bool_values\n    \n    # Format the final output string as a comma-separated list in brackets.\n    # The map(str, ...) correctly converts integers, floats, and booleans.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}