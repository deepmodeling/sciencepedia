{
    "hands_on_practices": [
        {
            "introduction": "在聚合物物理学中，理想链模型是一个最基础的出发点。该模型将聚合物想象成一系列随机取向的键，忽略了链段在空间中不能相互重叠的物理限制，因此其构象统计等同于一个随机行走过程。通过本练习 ，你将推导理想链尺寸的关键标度关系 $\\langle R^2 \\rangle \\sim N$，这是理解排除体积效应如何改变聚合物行为的必要基准。",
            "id": "4101369",
            "problem": "处于θ溶剂中的聚合物可以被建模为一个理想自由连接链，它由$N$个统计独立的键矢量$\\{\\mathbf{b}_{i}\\}_{i=1}^{N}$组成，每个键矢量长度固定为$b$且取向各向同性。端到端矢量为$\\mathbf{R}=\\sum_{i=1}^{N}\\mathbf{b}_{i}$。假设键矢量是独立同分布的，其均值$\\langle \\mathbf{b}_{i} \\rangle=\\mathbf{0}$，且其分布在空间中是各向同性的。\n\n仅从这些假设和系综平均的基本性质出发，计算精确的系综平均均方端到端距离$\\langle R^{2} \\rangle$，并将其表示为$N$和$b$的函数。然后，论证键矢量的独立性和各向同性如何决定了在这种理想链极限下标度关系$\\langle R^{2} \\rangle$与$N$和$b$的依赖关系，并与具有排除体积（自回避行走）的真实链进行对比。\n\n用一个包含$N$和$b$的单一边界封闭形式符号表达式来表示你的最终答案。在最终的方框答案中不要包含单位。",
            "solution": "问题陈述科学合理、提法明确，并包含了推导唯一解所需的所有信息。它描述了自由连接链模型，这是聚合物统计力学的基石，并要求推导一个基本结果。因此，将提供一个解答。\n\n我们主要关心的量是均方端到端距离$\\langle R^{2} \\rangle$。端到端矢量$\\mathbf{R}$定义为单个键矢量$\\{\\mathbf{b}_{i}\\}_{i=1}^{N}$的总和：\n$$\n\\mathbf{R} = \\sum_{i=1}^{N} \\mathbf{b}_{i}\n$$\n端到端距离的平方$R^{2}$是矢量$\\mathbf{R}$与自身的标量积：\n$$\nR^{2} = \\mathbf{R} \\cdot \\mathbf{R} = \\left(\\sum_{i=1}^{N} \\mathbf{b}_{i}\\right) \\cdot \\left(\\sum_{j=1}^{N} \\mathbf{b}_{j}\\right)\n$$\n展开此乘积得到一个双重求和：\n$$\nR^{2} = \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j}\n$$\n我们需要计算这个量的系综平均$\\langle R^{2} \\rangle$。系综平均算符$\\langle \\cdot \\rangle$是线性的。因此，我们可以将算符移到求和符号内部：\n$$\n\\langle R^{2} \\rangle = \\left\\langle \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\right\\rangle = \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle\n$$\n为了计算这个双重求和，将索引相等（$i=j$）的项与索引不相等（$i \\neq j$）的项分开是很有启发性的：\n$$\n\\langle R^{2} \\rangle = \\sum_{i=1}^{N} \\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{i} \\rangle + \\sum_{i=1}^{N} \\sum_{j \\neq i}^{N} \\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle\n$$\n让我们分别分析这两个和。\n\n对于第一个和，项$\\mathbf{b}_{i} \\cdot \\mathbf{b}_{i}$是第$i$个键矢量的模的平方，$|\\mathbf{b}_{i}|^{2}$。问题陈述指明每个键的长度固定为$b$。因此，对任意键$i$，有$|\\mathbf{b}_{i}| = b$，这意味着$|\\mathbf{b}_{i}|^{2} = b^{2}$。由于$b^{2}$是一个常数，其系综平均就是它本身：\n$$\n\\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{i} \\rangle = \\langle |\\mathbf{b}_{i}|^{2} \\rangle = \\langle b^{2} \\rangle = b^{2}\n$$\n第一个和包含$N$个这样的相同项，变为：\n$$\n\\sum_{i=1}^{N} \\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{i} \\rangle = \\sum_{i=1}^{N} b^{2} = N b^{2}\n$$\n\n对于第二个和，我们考虑$i \\neq j$的项。问题陈述键矢量是统计独立的。对于两个独立的随机变量（在此情况下为矢量$\\mathbf{b}_{i}$和$\\mathbf{b}_{j}$），其乘积的期望等于其各自期望的乘积。虽然点积不是简单的标量乘积，但我们可以利用独立性。对于$i \\neq j$，矢量$\\mathbf{b}_{i}$和$\\mathbf{b}_{j}$是不相关的。由统计独立性导出的一个关键性质是，乘积的平均值等于平均值的乘积。因此：\n$$\n\\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle = \\langle \\mathbf{b}_{i} \\rangle \\cdot \\langle \\mathbf{b}_{j} \\rangle \\quad \\text{for } i \\neq j\n$$\n问题给出任意键矢量的平均值为零，即对所有$i$都有$\\langle \\mathbf{b}_{i} \\rangle = \\mathbf{0}$。这是所述的键的各向同性取向的直接结果；空间中没有优选方向。将此代入交叉项的表达式中得到：\n$$\n\\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle = \\mathbf{0} \\cdot \\mathbf{0} = 0\n$$\n由于第二个和中所有$i \\neq j$的项都为零，整个和消失：\n$$\n\\sum_{i=1}^{N} \\sum_{j \\neq i}^{N} \\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle = 0\n$$\n结合两个和的结果，我们得到均方端到端距离的精确表达式：\n$$\n\\langle R^{2} \\rangle = N b^{2} + 0 = N b^{2}\n$$\n\n$\\langle R^{2} \\rangle$相对于$N$和$b$的标度关系的合理解释已内含在此推导中。与链段数呈线性标度关系，即$\\langle R^{2} \\rangle \\propto N$，是随机行走过程的一个标志。它直接源于键矢量的统计独立性，这导致所有$i \\neq j$的取向交叉相关$\\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle$都为零。各向同性假设保证了$\\langle\\mathbf{b}_{i}\\rangle = \\mathbf{0}$，这对上述抵消至关重要。与$b^{2}$的标度关系仅仅反映了这个随机行走的基本步长是$b$。\n\n相比之下，真实聚合物链不能被建模为简单的随机行走。理想链模型中没有考虑到的主要物理约束是排除体积效应：链的两个部分不能占据空间中的同一位置。这个约束引入了沿链轮廓相距很远但在空间上可能很近的链段之间的长程相关性。链的轨迹变成了自回避行走（SAW），而不是简单的随机行走。因此，对$\\mathbf{b}_{i}$和$\\mathbf{b}_{j}$的统计独立性假设不再成立，即使对于大的$|i-j|$，$\\langle \\mathbf{b}_{i} \\cdot \\mathbf{b}_{j} \\rangle \\neq 0$。这些相关性平均而言是正的（链倾向于溶胀以避免自身），导致比理想链更伸展的构象。对于$d=3$维中的自回避行走，Flory理论和更精密的重整化群计算预测了一个不同的标度律：\n$$\n\\langle R^{2} \\rangle \\sim N^{2\\nu}\n$$\n其中$\\nu$是Flory指数。对于$d=3$，$\\nu \\approx 0.588$，这显著大于理想链指数$\\nu = 1/2$（因为$\\langle R^{2} \\rangle = N b^{2} = N^{2(1/2)} b^{2}$）。这表明，在良溶剂中的真实链会溶胀到比相同长度$N$的理想链大得多的尺寸。理想链模型对应于θ溶剂的特殊情况，在这种情况下，吸引性的单体-溶剂相互作用恰好平衡了排斥性的排除体积效应，导致链的行为有效地如同随机行走。",
            "answer": "$$\n\\boxed{N b^{2}}\n$$"
        },
        {
            "introduction": "真实聚合物链段占据体积，不能相互穿越，这种“排除体积效应”使其行为偏离理想链模型。Flory 理论提供了一个简洁而深刻的平均场方法来描述这种效应，它通过平衡促使链卷曲的熵弹性和导致链溶胀的排斥相互作用来实现。在此实践中 ，你将运用 Flory 理论推导真实聚合物尺寸的标度指数（即 Flory 指数 $\\nu$），从而定量理解聚合物在良溶剂中的溶胀行为。",
            "id": "4101378",
            "problem": "考虑一个长聚合物，在空间维度为 $d$ 的良溶剂中，其模型为自回避行走。该聚合物有 $N$ 个长度为 $a$ 的 Kuhn 链段，以及一个正的双体排除体积参数 $v$，其中 $v = c_{v}\\,a^{d}$，$c_{v}$ 是一个数量级为1的无量纲常数。在 Flory 的平均场方法中，对于一个末端距为 $R$ 的构象，其 Helmholtz 自由能（以 $k_{B}T$ 为单位）被估算为熵弹性项和平均场相互作用项之和。使用以下基本假设，这些假设在真实聚合物链理论中是标准且经过充分检验的：\n- 高斯链的熵弹性贡献为 $F_{\\mathrm{el}}/(k_{B}T) \\sim c_{1}\\,R^{2}/(a^{2}N)$，其中 $c_{1}$ 是一个数量级为1的常数。\n- 在第二维里系数近似水平上的排斥性双体相互作用贡献为 $F_{\\mathrm{int}}/(k_{B}T) \\sim c_{2}\\,v\\,N^{2}/R^{d}$，其中 $c_{2}$ 是一个数量级为1的常数。\n\n从这些要素出发，完成以下任务：\n1. 对总自由能相对于 $R$进行最小化，以获得均方末端距 $\\langle R^{2} \\rangle$ 作为 $N$、$a$、$d$ 和 $v$ 的函数的标度形式，并保留对 $c_{1}$ 和 $c_{2}$ 的依赖关系。\n2. 通过 $\\langle R^{2} \\rangle \\sim a^{2}N^{2\\nu_{F}}$ 定义 Flory 指数 $\\nu_{F}$，并提取由下式定义的无量纲振幅 $C_{F}(d,c_{1},c_{2},c_{v})$：\n$$\n\\langle R^{2} \\rangle \\equiv C_{F}(d,c_{1},c_{2},c_{v})\\,a^{2}\\,N^{2\\nu_{F}}.\n$$\n3. 将问题具体化到三维空间，即 $d=3$，并取 $c_{1}=1$、$c_{2}=1$ 和 $c_{v}=1$。计算得到的无量纲前因子 $C_{F}(3,1,1,1)$ 的精确表达式。你的最终答案必须是这个单一值。不要四舍五入。\n4. 简要地用文字评论这个前因子和指数相对于重整化群（RG）结果的局限性。\n\n你的最终答案必须是一个单一的精确实数。最终答案不需要单位，因为它是无量纲的。不要提供任何不等式或方程式作为你的最终答案。",
            "solution": "首先对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 聚合物模型：良溶剂中的自回避行走。\n- 空间维度：$d$。\n- 链段数量：$N$。\n- 链段长度：$a$。\n- 双体排除体积参数：$v  0$。\n- 排除体积关系：$v = c_{v}\\,a^{d}$，其中 $c_{v}$ 是一个数量级为1的无量纲常数。\n- 熵弹性自由能：$F_{\\mathrm{el}}/(k_{B}T) \\sim c_{1}\\,R^{2}/(a^{2}N)$，其中 $c_{1}$ 是一个数量级为1的常数。\n- 平均场相互作用自由能：$F_{\\mathrm{int}}/(k_{B}T) \\sim c_{2}\\,v\\,N^{2}/R^{d}$，其中 $c_{2}$ 是一个数量级为1的常数。\n- 总自由能：$F = F_{\\mathrm{el}} + F_{\\mathrm{int}}$。\n- Flory 指数 $\\nu_{F}$ 的定义：$\\langle R^{2} \\rangle \\sim a^{2}N^{2\\nu_{F}}$。\n- 无量纲振幅的定义：$\\langle R^{2} \\rangle \\equiv C_{F}(d,c_{1},c_{2},c_{v})\\,a^{2}\\,N^{2\\nu_{F}}$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题是理论聚合物物理学中的一个经典基础练习，基于公认的 Flory 平均场理论。所有概念和方程在该领域都是标准的。\n- **适定性：** 问题结构清晰，包含一系列任务，这些任务基于所给假设导出一个唯一解。\n- **客观性：** 语言正式且精确，没有任何主观或模糊的术语。\n- **完整性与一致性：** 提供了所有必要信息。通过保留常数 $c_{1}$ 和 $c_{2}$ 的指令，澄清了比例关系 `~` 的用法，实际上是为了计算目的而将这些关系视为等式。已知条件相互一致。\n- **其他缺陷：** 该问题没有其他列出的缺陷，如不切实际、不适定或过于简单。\n\n**步骤3：结论与行动**\n问题有效。将提供解答。\n\n一个末端距为 $R$ 的聚合物构象的总 Helmholtz 自由能 $F$（以 $k_{B}T$ 为单位）是熵弹性项和相互作用项之和。记 $f(R) = F/(k_{B}T)$，我们有：\n$$\nf(R) = \\frac{F_{\\mathrm{el}}}{k_{B}T} + \\frac{F_{\\mathrm{int}}}{k_{B}T} = c_{1}\\frac{R^{2}}{a^{2}N} + c_{2}\\frac{v N^{2}}{R^{d}}\n$$\n其中，使用等号是合理的，因为指令要求保留常数 $c_{1}$ 和 $c_{2}$。\n\n**1. 自由能的最小化**\n为了找到平衡末端距（我们记为 $R_{F}$），我们将自由能 $f(R)$ 对 $R$ 进行最小化。这通过求 $f(R)$ 对 $R$ 的导数并将其设为零来实现。\n$$\n\\frac{df}{dR} = \\frac{d}{dR} \\left( c_{1}R^{2}(a^{2}N)^{-1} + c_{2}vN^{2}R^{-d} \\right) = 2c_{1}R(a^{2}N)^{-1} - dc_{2}vN^{2}R^{-d-1}\n$$\n将导数设为零以找到最小值：\n$$\n\\frac{2c_{1}R_{F}}{a^{2}N} - \\frac{dc_{2}vN^{2}}{R_{F}^{d+1}} = 0\n$$\n$$\n\\frac{2c_{1}R_{F}}{a^{2}N} = \\frac{dc_{2}vN^{2}}{R_{F}^{d+1}}\n$$\n我们求解 $R_{F}$：\n$$\nR_{F}^{d+2} = \\frac{dc_{2}vN^{2}a^{2}N}{2c_{1}} = \\left( \\frac{dc_{2}v}{2c_{1}} \\right) a^{2}N^{3}\n$$\n为确认这是一个最小值，我们检查二阶导数：\n$$\n\\frac{d^{2}f}{dR^{2}} = \\frac{2c_{1}}{a^{2}N} + d(d+1)c_{2}vN^{2}R^{-d-2}\n$$\n由于所有参数（$c_{1}$、$c_{2}$、$v$、$N$、$a$、$d$）都是正的，对于所有 $R0$，$\\frac{d^{2}f}{dR^{2}}  0$ 成立，这证实了 $R_{F}$ 对应于自由能的最小值。\n\n在这个平均场近似中，均方末端距 $\\langle R^{2} \\rangle$ 等同于 $R_{F}^{2}$。\n$$\n\\langle R^{2} \\rangle = R_{F}^{2} = \\left[ \\left( \\frac{dc_{2}v}{2c_{1}} \\right) a^{2}N^{3} \\right]^{\\frac{2}{d+2}} = \\left( \\frac{dc_{2}v}{2c_{1}} \\right)^{\\frac{2}{d+2}} a^{\\frac{4}{d+2}} N^{\\frac{6}{d+2}}\n$$\n这就是 $\\langle R^{2} \\rangle$ 的标度形式。\n\n**2. Flory 指数与振幅**\n给定定义 $\\langle R^{2} \\rangle \\sim a^{2}N^{2\\nu_{F}}$。将其与我们推导出的关于 $N$ 的标度关系 $\\langle R^{2} \\rangle \\propto N^{\\frac{6}{d+2}}$ 进行比较，我们确定：\n$$\n2\\nu_{F} = \\frac{6}{d+2} \\implies \\nu_{F} = \\frac{3}{d+2}\n$$\n这就是著名的 Flory 指数。\n\n为了求无量纲振幅 $C_{F}$，我们使用定义 $\\langle R^{2} \\rangle \\equiv C_{F}(d,c_{1},c_{2},c_{v})\\,a^{2}\\,N^{2\\nu_{F}}$。我们首先将 $v = c_{v}a^{d}$ 代入 $\\langle R^{2} \\rangle$ 的表达式中：\n$$\n\\langle R^{2} \\rangle = \\left( \\frac{dc_{2}(c_{v}a^{d})}{2c_{1}} \\right)^{\\frac{2}{d+2}} a^{\\frac{4}{d+2}} N^{\\frac{6}{d+2}}\n$$\n$$\n\\langle R^{2} \\rangle = \\left( \\frac{dc_{2}c_{v}}{2c_{1}} \\right)^{\\frac{2}{d+2}} (a^{d})^{\\frac{2}{d+2}} a^{\\frac{4}{d+2}} N^{\\frac{6}{d+2}}\n$$\n$$\n\\langle R^{2} \\rangle = \\left( \\frac{dc_{2}c_{v}}{2c_{1}} \\right)^{\\frac{2}{d+2}} a^{\\frac{2d}{d+2}} a^{\\frac{4}{d+2}} N^{\\frac{6}{d+2}}\n$$\n$$\n\\langle R^{2} \\rangle = \\left( \\frac{dc_{2}c_{v}}{2c_{1}} \\right)^{\\frac{2}{d+2}} a^{\\frac{2d+4}{d+2}} N^{\\frac{6}{d+2}} = \\left( \\frac{dc_{2}c_{v}}{2c_{1}} \\right)^{\\frac{2}{d+2}} a^{2} N^{\\frac{6}{d+2}}\n$$\n将此结果与定义式 $\\langle R^{2} \\rangle \\equiv C_{F}\\,a^{2}\\,N^{2\\nu_{F}}$ 进行比较，并注意到 $2\\nu_{F} = 6/(d+2)$，我们可以直接确定振幅 $C_{F}$：\n$$\nC_{F}(d,c_{1},c_{2},c_{v}) = \\left( \\frac{dc_{2}c_{v}}{2c_{1}} \\right)^{\\frac{2}{d+2}}\n$$\n\n**3. $C_{F}$ 的具体值**\n我们具体化到三维空间（$d=3$），并将数量级为1的常数设为1：$c_{1}=1$、$c_{2}=1$ 和 $c_{v}=1$。\n$$\nC_{F}(3,1,1,1) = \\left( \\frac{(3)(1)(1)}{2(1)} \\right)^{\\frac{2}{3+2}} = \\left( \\frac{3}{2} \\right)^{\\frac{2}{5}}\n$$\n这就是所要求的精确值。\n\n**4. 关于局限性的评论**\nFlory 理论提供了一个强大而简单的物理解释。然而，它是一种平均场理论，与重整化群（RG）和高精度计算机模拟等更严谨的方法相比，存在已知的局限性。\n- **指数 $\\nu_{F}$**：对于 $d=3$，Flory 指数为 $\\nu_{F} = 3/(3+2) = 3/5 = 0.6$。这与 RG 和模拟得出的最精确值 $\\nu \\approx 0.588$ 非常接近。虽然 Flory 指数是一个极好的近似，但对于 $d=3$ 而言它并不精确。这种差异的产生是因为相互作用的平均场处理和链熵的高斯近似并非完全自洽，并且忽略了细微的空间关联。\n- **前因子 $C_{F}$**：前因子 $C_{F}$ 的数值高度依赖于非普适的、数量级为1的常数 $c_{1}$、$c_{2}$ 和 $c_{v}$。这些常数吸收了所有未被标度变量 $N$ 和 $v$ 捕捉到的聚合物和溶剂的微观细节。RG 理论确立了虽然像 $\\nu$ 这样的指数是普适的（不依赖于微观细节），但振幅通常不是。因此，计算出的 $C_{F}(3,1,1,1)$ 的值应被视为一个依赖于模型的估计值，而不是一个基本的物理常数。RG 可以预测振幅的普适比率，但不能预测其绝对值。",
            "answer": "$$\\boxed{\\left(\\frac{3}{2}\\right)^{\\frac{2}{5}}}$$"
        },
        {
            "introduction": "理论分析之外，计算机模拟是研究聚合物构象的强大工具，而自回避行走（SAW）是模拟带有排除体积效应聚合物链的经典格点模型。这项动手编程练习  要求你通过算法精确地枚举出二维方格子上所有可能的短程自回避行走路径。这个过程不仅能让你直观地感受构象数量随链长的指数增长，还能让你亲手计算并验证描述这一增长的核心参数——连接常数。",
            "id": "4101356",
            "problem": "在整数方格点阵 $\\mathbb{Z}^2$ 上的自回避行走（SAW）是一种不重复访问任何格点的最近邻路径。在计算复杂流体学中，良溶剂中的真实聚合物链可以通过自回避行走来建模，以捕捉排除体积效应。考虑从原点 $(0,0)$ 开始，长度为 $N$ 步的自回避行走集合，其中每一步在四个基本方向之一上移动一个单位。令 $c_N$ 表示长度为 $N$ 的此类自回避行走的总数。\n\n仅从自回避行走的“访问位点互不相同”的基本定义出发，并利用路径段拼接计数时经过充分检验的次可乘性（即 $c_{M+N} \\le c_M c_N$，因为任意拼接不一定能保持自回避性），构建一个算法来枚举方形晶格上所有长度为 $N$（$N \\le 6$）的自回避行走。\n\n您的任务是：\n- 从第一性原理出发，推导出一个枚举策略，通过探索最近邻步骤的完整搜索树并强制执行自回避约束，系统地生成所有长度为 $N$ 的自回避行走，并用它来计算 $N \\in \\{0,1,2,3,4,5,6\\}$ 时的 $c_N$。\n- 使用枚举出的计数值，通过计算每个 $N \\ge 1$ 的比率 $r_N = c_N / c_{N-1}$ 和根估计量 $g_N = c_N^{1/N}$ 来刻画其增长模式。这两个量是连接常数 $\\mu$ 的经典有限-$N$ 估计量。\n- 对测试对 $(M,N) \\in \\{(1,1),(2,2),(3,3)\\}$ 验证次可乘性不等式 $c_{M+N} \\le c_M c_N$，每次检查返回一个布尔值。\n\n$c_N$、$r_N$ 和 $g_N$ 均为无量纲量，因此不涉及物理单位。角度不参与此计算。所有输出必须是数值型且可量化的。\n\n测试套件：\n- 枚举案例：$N \\in \\{0,1,2,3,4,5,6\\}$。\n- 次可乘性检查：$(M,N) \\in \\{(1,1),(2,2),(3,3)\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，不含空格，结果按以下顺序排列：\n  1. 七个整数 $c_0,c_1,c_2,c_3,c_4,c_5,c_6$。\n  2. 六个浮点数 $r_1,r_2,r_3,r_4,r_5,r_6$，每个都四舍五入到六位小数。\n  3. 六个浮点数 $g_1,g_2,g_3,g_4,g_5,g_6$，每个都四舍五入到六位小数。\n  4. 对应于 $(M,N)=(1,1),(2,2),(3,3)$ 的次可乘性检查的三个布尔值，按此顺序排列。\n\n为清晰起见，所需输出将因此包含22个条目，后跟3个布尔值，全部置于一个扁平列表中。例如，输出必须具有确切的形式 $[c_0,c_1,\\dots,c_6,r_1,\\dots,r_6,g_1,\\dots,g_6,b_{11},b_{22},b_{33}]$，其中 $b_{11},b_{22},b_{33}$ 是三个不等式检查的布尔值。",
            "solution": "问题陈述已经过验证，被认为是**有效的**。它在科学上基于已建立的自回避行走理论，该理论是聚合物统计力学模型的基石。问题定义良好，具有清晰、客观的定义和一个可计算的、唯一的解。所有必要条件都已提供，且没有矛盾之处。\n\n按照要求，该解决方案分三部分展开：行走计数的枚举、其增长模式的分析以及一个基本数学性质的验证。\n\n### 第1部分：自回避行走的枚举 ($c_N$)\n\n在方形晶格 $\\mathbb{Z}^2$ 上，长度为 $N$ 的自回避行走（SAW）是一个由不同顶点组成的序列 $(p_0, p_1, \\dots, p_N)$，其中 $p_0 = (0,0)$，每个后续顶点 $p_{i+1}$ 都是其前驱 $p_i$ 的最近邻。此类行走的数量用 $c_N$ 表示。\n\n为了从第一性原理计算 $c_N$，我们开发了一种基于递归回溯的系统枚举策略。该算法从原点开始，探索所有可能的最近邻路径组成的树，并剪掉任何试图重访某一位点的分支。\n\n该算法可以被表述为一个递归函数，我们称之为 `CountWalks(current_pos, visited_sites, steps_remaining)`。\n- **状态表示**：搜索过程中的任何一点的状态都由三个元素定义：\n    1. `current_pos`：行走终点的当前坐标 $(x,y)$。\n    2. `visited_sites`：一个集合数据结构，包含迄今为止访问过的所有唯一顶点，包括起点。使用集合可以高效地（平均 $O(1)$ 时间）检查自回避约束。\n    3. `steps_remaining`：为达到总长度 $N$ 还需行走的步数。\n\n- **递归逻辑**：\n    - **基本情况**：如果 `steps_remaining` 为 $0$，表示已构建一条长度为 $N$ 的有效自回避行走。函数返回 $1$ 来对这条成功的路径进行计数。\n    - **递归步骤**：如果 `steps_remaining` 大于 $0$，函数会遍历 `current_pos` 的四个基本方向上的邻居。对于每个可能的 `next_pos`：\n        1. 检查 `next_pos` 是否已存在于 `visited_sites` 集合中。\n        2. 如果不存在，说明到目前为止路径是有效的。算法接着会：\n            a. 将 `next_pos` 添加到 `visited_sites`。\n            b. 进行递归调用：`CountWalks(next_pos, visited_sites, steps_remaining - 1)`。\n            c. 将此递归调用返回的整数加到当前层的运行总数中。\n            d. 通过从 `visited_sites` 中移除 `next_pos` 来进行**回溯**。这是允许搜索从 `current_pos` 探索其他分支的关键步骤。\n    - 函数返回所有有效递归分支累加的总计数。\n\n- **初始调用**：为计算 $c_N$，对函数的初始调用是 `CountWalks(current_pos=(0,0), visited_sites={(0,0)}, steps_remaining=N)`。根据定义，$N=0$ 的计数为 $c_0=1$，表示一个停留在原点的零步长行走。\n\n对 $N \\in \\{0, 1, 2, 3, 4, 5, 6\\}$ 执行此算法，得到以下计数值：\n- $c_0 = 1$\n- $c_1 = 4$\n- $c_2 = 12$\n- $c_3 = 36$\n- $c_4 = 100$\n- $c_5 = 284$\n- $c_6 = 780$\n\n### 第2部分：增长模式的刻画 ($r_N$ 和 $g_N$)\n\n在枚举出精确的计数值 $c_N$ 后，我们使用两种标准的有限-$N$ 估计量来分析其增长模式，以估计连接常数 $\\mu$。\n1.  连续项的比率，$r_N = c_N / c_{N-1}$。\n2.  根估计量，$g_N = c_N^{1/N}$。\n\n已知对于大的 $N$，$r_N$ 和 $g_N$ 都会收敛到 $\\mu$。对于 $N \\in \\{1, 2, 3, 4, 5, 6\\}$ 的计算如下：\n\n- **比率 $r_N$**：\n  - $r_1 = c_1 / c_0 = 4 / 1 = 4.0$\n  - $r_2 = c_2 / c_1 = 12 / 4 = 3.0$\n  - $r_3 = c_3 / c_2 = 36 / 12 = 3.0$\n  - $r_4 = c_4 / c_3 = 100 / 36 \\approx 2.777778$\n  - $r_5 = c_5 / c_4 = 284 / 100 = 2.84$\n  - $r_6 = c_6 / c_5 = 780 / 284 \\approx 2.746479$\n\n- **根估计量 $g_N$**：\n  - $g_1 = c_1^{1/1} = 4^{1} = 4.0$\n  - $g_2 = c_2^{1/2} = 12^{1/2} \\approx 3.464102$\n  - $g_3 = c_3^{1/3} = 36^{1/3} \\approx 3.301927$\n  - $g_4 = c_4^{1/4} = 100^{1/4} \\approx 3.162278$\n  - $g_5 = c_5^{1/5} = 284^{1/5} \\approx 3.097014$\n  - $g_6 = c_6^{1/6} = 780^{1/6} \\approx 3.033621$\n\n### 第3部分：次可乘性验证\n\n问题要求对指定的数对验证次可乘性不等式 $c_{M+N} \\le c_M c_N$。此性质的产生是因为拼接两个自回避行走并不能保证结果行走仍然是自回避的，这意味着组合行走的数量 $c_{M+N}$ 必须小于或等于组成它的行走数量的乘积 $c_M c_N$。\n\n我们对测试对 $(M,N) \\in \\{(1,1), (2,2), (3,3)\\}$ 进行检验。\n\n- **情况 $(M,N) = (1,1)$**：\n  - 我们检查是否 $c_{1+1} \\le c_1 \\times c_1$。\n  - 这等价于 $c_2 \\le c_1^2$。\n  - 代入数值：$12 \\le 4^2 \\implies 12 \\le 16$。此式成立。\n\n- **情况 $(M,N) = (2,2)$**：\n  - 我们检查是否 $c_{2+2} \\le c_2 \\times c_2$。\n  - 这等价于 $c_4 \\le c_2^2$。\n  - 代入数值：$100 \\le 12^2 \\implies 100 \\le 144$。此式成立。\n\n- **情况 $(M,N) = (3,3)$**：\n  - 我们检查是否 $c_{3+3} \\le c_3 \\times c_3$。\n  - 这等价于 $c_6 \\le c_3^2$。\n  - 代入数值：$780 \\le 36^2 \\implies 780 \\le 1296$。此式成立。\n\n所有三次检查都证实了给定数对的次可乘性。最终程序将系统地计算这些值和布尔值，并按规定格式化它们。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes properties of self-avoiding walks (SAWs) on a 2D square lattice.\n    - Enumerates the number of SAWs c_N for lengths N = 0 to 6.\n    - Calculates growth estimators r_N and g_N.\n    - Verifies the submultiplicativity property for specific cases.\n    \"\"\"\n\n    # Memoization cache for the recursive counter to optimize, though for N=6\n    # it is not strictly necessary but good practice.\n    # A simple depth-first search counter is sufficient and clear.\n    \n    def _count_recursive(pos, visited_sites, steps_left):\n        \"\"\"\n        Recursively counts SAWs from a given state using backtracking.\n        \n        Args:\n            pos (tuple): The current (x, y) position of the walk.\n            visited_sites (set): A set of (x, y) tuples of visited sites.\n            steps_left (int): The number of steps remaining in the walk.\n\n        Returns:\n            int: The number of valid SAWs from the current state.\n        \"\"\"\n        # Base case: if no steps are left, we have found one complete walk.\n        if steps_left == 0:\n            return 1\n        \n        count = 0\n        x, y = pos\n        \n        # Explore the four cardinal directions.\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            next_pos = (x + dx, y + dy)\n            \n            # If the next position has not been visited, explore from there.\n            if next_pos not in visited_sites:\n                # 1. Add the new site to the visited set for the recursive call.\n                visited_sites.add(next_pos)\n                \n                # 2. Recurse with decremented steps.\n                count += _count_recursive(next_pos, visited_sites, steps_left - 1)\n                \n                # 3. Backtrack: remove the site to allow other paths to be explored.\n                visited_sites.remove(next_pos)\n                \n        return count\n\n    def get_cn(n):\n        \"\"\"\n        Computes the number of SAWs of length n, c_n.\n        \n        Args:\n            n (int): The length of the walk.\n\n        Returns:\n            int: The total number of SAWs of length n.\n        \"\"\"\n        # By definition, there is one SAW of length 0 (the origin point).\n        if n == 0:\n            return 1\n            \n        # For n > 0, start the recursive count from the origin.\n        start_pos = (0, 0)\n        visited_sites = {start_pos}\n        return _count_recursive(start_pos, visited_sites, n)\n\n    # 1. Enumerate c_N for N in {0, ..., 6}\n    # These are the number of self-avoiding walks of length N.\n    cn_values = [get_cn(n) for n in range(7)]\n\n    # 2. Compute ratios r_N = c_N / c_{N-1}\n    # This is a finite-N estimator for the connective constant.\n    rn_values = []\n    for i in range(1, 7):\n        val = cn_values[i] / cn_values[i-1]\n        rn_values.append(round(val, 6))\n\n    # 3. Compute root estimators g_N = c_N^(1/N)\n    # This is another finite-N estimator for the connective constant.\n    gn_values = []\n    for i in range(1, 7):\n        val = cn_values[i] ** (1/i)\n        gn_values.append(round(val, 6))\n\n    # 4. Verify submultiplicativity property: c_{M+N} = c_M * c_N\n    bool_values = []\n    for m in [1, 2, 3]:\n        # The problem asks for pairs (M,N) = (1,1), (2,2), (3,3)\n        is_valid = cn_values[m + m] = cn_values[m] * cn_values[m]\n        bool_values.append(is_valid)\n\n    # Combine all results into a single list in the specified order.\n    all_results = cn_values + rn_values + gn_values + bool_values\n    \n    # Format the final output string as a comma-separated list in brackets.\n    # The map(str, ...) correctly converts integers, floats, and booleans.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}