{
    "hands_on_practices": [
        {
            "introduction": "在离散元方法 (DEM) 模拟中，最耗费计算成本的步骤是有效地找到所有可能接触的粒子对。为了解决这个问题，一个常见的技术是“单元列表法” (cell list method)，它将计算域划分为网格。这个练习  探讨了决定此方法搜索范围的核心几何原理，特别是网格尺寸 $l$ 与最大粒子半径 $R_{\\max}$ 之间的关系。理解这一原理对于设计正确且高效的DEM算法至关重要。",
            "id": "4095057",
            "problem": "一个在三维空间中对颗粒介质进行的离散元方法 (DEM) 模拟，将计算域划分为一个由边长为 $l$ 的立方体单元组成的均匀笛卡尔网格。该材料由 $N = 10^{6}$ 个球形颗粒组成，其半径 $\\{r_{i}\\}$ 对所有 $i$ 满足 $0  r_{i} \\le R_{\\max}$。两个颗粒 $i$ 和 $j$ 只有在其中心之间的欧几里得距离小于或等于 $r_{i} + r_{j}$ 时，才可能发生力学接触。接触检测是通过检查与每个颗粒所在单元相关联的一组有限的网格单元来执行的。\n\n假设网格单元尺寸满足 $l \\ge 2 R_{\\max}$，并且区域很大，要么是周期性的，要么是充分延伸的，以至于边界效应不会改变局部邻域拓扑。仅使用由接触条件和均匀网格划分所隐含的基本几何考量，确定每个颗粒必须检查的最小不同网格单元数（包括颗粒自身的单元），以保证每个可能接触的颗粒对都被考虑到。请用一个精确整数表示你的最终答案。无需四舍五入，且该计数没有物理单位。",
            "solution": "首先对问题进行验证，以确保其具有科学依据、是适定的并且是客观的。\n\n### 步骤 1：提取已知条件\n- 模拟在三维空间中进行。\n- 计算域被一个由立方体单元组成的均匀笛卡尔网格划分。\n- 每个立方体单元的边长为 $l$。\n- 系统包含 $N = 10^{6}$ 个球形颗粒。\n- 任何颗粒 $i$ 的半径，记为 $r_i$，其范围由 $0  r_i \\le R_{\\max}$ 限定。\n- 两个半径分别为 $r_i$ 和 $r_j$、中心位置分别为 $\\mathbf{p}_i$ 和 $\\mathbf{p}_j$ 的颗粒 $i$ 和 $j$，只有当其中心之间的欧几里得距离满足 $|\\mathbf{p}_i - \\mathbf{p}_j| \\le r_i + r_j$ 时，才可能接触。\n- 网格单元尺寸受限于 $l \\ge 2 R_{\\max}$。\n- 边界效应可以忽略不计。\n- 任务是找出为保证所有潜在接触都被识别，每个颗粒必须检查的最小不同网格单元数。此计数包括颗粒自身的单元。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题描述了单元列表法，这是计算物理学中用于离散元方法 (DEM) 和分子动力学 (MD) 模拟中高效邻居查找的标准基本算法。几何设置和接触条件都是标准的。该问题是合理的。\n- **适定性**：该问题是明确定义的。它要求在清晰的几何约束 ($l \\ge 2 R_{\\max}$) 下的最小数量。这些约束足以确定一个唯一的整数解。\n- **客观性**：该问题使用计算科学中常见的精确、形式化语言陈述。没有歧义或主观性。\n\n所有其他验证标准均已满足。该问题不违反任何科学原理，是可形式化的，不缺少信息，不包含矛盾，并且不是平凡的。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。将推导解答过程。\n\n### 解答推导\n\n我们考虑一个半径为 $r_i$、中心位于位置 $\\mathbf{p}_i$ 的颗粒 $i$。根据问题陈述，该颗粒位于一个特定的立方体网格单元中，我们可以将其指定为“宿主”单元 $C_0$。我们需要确定必须检查的最小周围单元集合，以便找到所有可能与颗粒 $i$ 接触的其他颗粒 $j$。\n\n颗粒 $i$ 和颗粒 $j$ (半径为 $r_j$，中心在 $\\mathbf{p}_j$) 之间可能发生接触的条件是，它们中心之间的距离不超过其半径之和：\n$$\n|\\mathbf{p}_i - \\mathbf{p}_j| \\le r_i + r_j\n$$\n任何颗粒 $k$ 的半径都受限于 $0  r_k \\le R_{\\max}$。因此，两个接触颗粒中心之间的最大可能距离是：\n$$\nr_i + r_j \\le R_{\\max} + R_{\\max} = 2R_{\\max}\n$$\n这意味着，为了保证找到颗粒 $i$ 的所有潜在接触，我们必须在以 $\\mathbf{p}_i$ 为中心、半径为 $2R_{\\max}$ 的球体内搜索其他颗粒的中心 $\\mathbf{p}_j$。\n\n该过程必须对颗粒 $i$ 在其宿主单元 $C_0$ 内的任何可能位置都有效。为了建立一个坐标系，我们将宿主单元 $C_0$ 定义为立方体区域 $[0, l) \\times [0, l) \\times [0, l)$。颗粒 $i$ 的中心位置是 $\\mathbf{p}_i = (x_i, y_i, z_i)$，其中 $0 \\le x_i  l$， $0 \\le y_i  l$ 且 $0 \\le z_i  l$。\n\n搜索必须覆盖所有可能包含接触伙伴的单元。我们可以通过考虑两个方面来确定最小必要的搜索体积：\n1.  哪些邻近单元*必须*包含在搜索范围内？\n2.  哪些单元可以明确地从搜索中*排除*？\n\n**1. 必须包含的单元：**\n如果 $C_0$ 中的颗粒有可能与某个邻近单元中的颗粒接触，那么就必须检查该邻近单元。考虑一个与 $C_0$ 相邻的单元，它们共享一个面、一条边或一个角。对于任何这样的邻近单元，都存在一个与 $C_0$ 共享的边界。可以将颗粒 $i$ 的中心放置在 $C_0$ 一侧无限接近此边界的位置，并将颗粒 $j$ 的中心放置在邻近单元一侧无限接近的位置。\n\n例如，考虑角相邻单元 $C_{(-1,-1,-1)}$，它占据区域 $[-l, 0) \\times [-l, 0) \\times [-l, 0)$。我们可以将颗粒 $i$ 放置在 $\\mathbf{p}_i = (\\epsilon, \\epsilon, \\epsilon)$，将颗粒 $j$ 放置在 $\\mathbf{p}_j = (-\\epsilon, -\\epsilon, -\\epsilon)$，其中 $\\epsilon$ 是一个任意小的正值。两个颗粒都在各自的单元内。它们中心之间的距离是 $|\\mathbf{p}_i - \\mathbf{p}_j| = \\sqrt{(2\\epsilon)^2 + (2\\epsilon)^2 + (2\\epsilon)^2} = 2\\epsilon\\sqrt{3}$。这个距离可以变得比任何给定的正接触距离 $r_i + r_j$ 都小（因为 $r_k > 0$）。因此，接触是可能的，必须检查单元 $C_{(-1,-1,-1)}$。\n\n此逻辑适用于任何与 $C_0$ 拓扑相邻的单元。在三维笛卡尔网格中，一个单元有 $26$ 个这样的邻居：$6$ 个共享面，$12$ 个共享边，$8$ 个共享角。包括宿主单元 $C_0$ 本身，这构成了一个 $3 \\times 3 \\times 3$ 的单元区块。该区块中的总单元数是 $3^3 = 27$。\n\n**2. 可以排除的单元：**\n现在我们必须证明，不需要检查这个 $3 \\times 3 \\times 3$ 区块之外的任何单元。这就是条件 $l \\ge 2R_{\\max}$ 的关键之处。\n考虑一个不属于这个 $3 \\times 3 \\times 3$ 区块的单元 $C_k$。这意味着相对于 $C_0$ 的单元索引向量 $\\mathbf{k} = (k_x, k_y, k_z)$ 至少有一个分量的绝对值为 $2$ 或更大。不失一般性，我们来分析 $\\mathbf{k} = (2, 0, 0)$ 的情况。\n单元 $C_0$ 是 $[0, l) \\times [0, l) \\times [0, l)$。\n单元 $C_{(2,0,0)}$ 是 $[2l, 3l) \\times [0, l) \\times [0, l)$。\n\n设颗粒 $i$ 在 $C_0$ 中，所以其 x 坐标为 $x_i \\in [0, l)$。\n设颗粒 $j$ 在 $C_{(2,0,0)}$ 中，所以其 x 坐标为 $x_j \\in [2l, 3l)$。\n\n这些颗粒在 x 维度上的距离是 $x_j - x_i$。当 $x_j$ 取下确界且 $x_i$ 取上确界时，该间隔达到其可能的最小值：\n$$\n\\min(x_j - x_i) = \\inf(x_j) - \\sup(x_i) = 2l - l = l\n$$\n由于实际坐标为 $x_j \\ge 2l$ 和 $x_i  l$，所以间隔严格满足 $x_j - x_i > l$。\n中心之间的总欧几里得距离为 $|\\mathbf{p}_i - \\mathbf{p}_j| = \\sqrt{(x_j - x_i)^2 + (y_j - y_i)^2 + (z_j - z_i)^2}$。由于 $(x_j - x_i)^2 > l^2$，总距离必须满足：\n$$\n|\\mathbf{p}_i - \\mathbf{p}_j| > l\n$$\n我们已知条件 $l \\ge 2R_{\\max}$。因此，颗粒之间的距离为：\n$$\n|\\mathbf{p}_i - \\mathbf{p}_j| > l \\ge 2R_{\\max}\n$$\n接触的条件是 $|\\mathbf{p}_i - \\mathbf{p}_j| \\le r_i + r_j$。$r_i+r_j$ 的最大值是 $2R_{\\max}$。\n我们已经证明 $|\\mathbf{p}_i - \\mathbf{p}_j| > 2R_{\\max}$，这意味着 $|\\mathbf{p}_i - \\mathbf{p}_j| > r_i + r_j$。接触是不可能的。\n\n此论证适用于这个 $3 \\times 3 \\times 3$ 局部区块之外的任何单元。因此，我们可以明确地将所有这些单元从搜索中排除。\n\n为保证找到所有潜在接触而必须检查的最小单元数，是以颗粒宿主单元为中心的 $3 \\times 3 \\times 3$ 区块中的单元总数。这个数字是 $3 \\times 3 \\times 3 = 27$。",
            "answer": "$$\n\\boxed{27}\n$$"
        },
        {
            "introduction": "在识别出潜在的接触后，下一步是计算它们之间的相互作用力，其中摩擦力对模拟颗粒材料的真实行为至关重要。这个练习  聚焦于一个常用的切向力模型，该模型将一个弹性弹簧与库仑摩擦定律相结合，通过一个称为“返回映射”的预测-校正算法来处理。通过实现这一算法，你将亲手实践处理接触力学中具有路径依赖性的非线性摩擦问题，这是DEM模拟的核心挑战之一。",
            "id": "4095033",
            "problem": "您正在离散元法 (Discrete Element Method, DEM) 中对单个切向接触进行建模。此接触遵循牛顿定律和库仑摩擦定律。切向接触力被建模为一个线性弹性弹簧，其位移由切向平面上的滑移速度积分得到，并受库仑摩擦极限的限制。请从时间积分通过速度累积位移以及摩擦力受库仑极限约束这两个基本关系出发，推导并实现切向弹性弹簧位移和产生的切向力的更新算法。具体而言，对于一个给定的接触，已知法向力 $F_n \\ge 0$ (压为正)、摩擦系数 $\\mu \\ge 0$、切向刚度 $k_t > 0$、时间步长 $\\Delta t > 0$、局部切向平面中的切向滑移速度矢量 $\\boldsymbol{v}_t$ 以及同一平面中先前的切向弹簧位移矢量 $\\boldsymbol{\\xi}^{old}$，计算更新后的切向弹簧位移 $\\boldsymbol{\\xi}^{new}$ 和切向接触力 $\\boldsymbol{F}_t$，并强制施加库仑极限。\n\n使用的基本原理：\n- 牛顿第二定律和运动学：速度积分得到位移，因此弹性弹簧位移的演化遵循 $\\dfrac{d\\boldsymbol{\\xi}}{dt} = \\boldsymbol{v}_t$。\n- 线性弹性切向力：$\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}$。\n- 库仑摩擦：$\\lVert \\boldsymbol{F}_t \\rVert \\le \\mu F_n$，并且在滑动条件下，$\\boldsymbol{F}_t$ 的方向与切向平面内的滑移趋势相反。\n\n您的程序必须：\n1. 使用 $\\boldsymbol{\\xi}^{trial} = \\boldsymbol{\\xi}^{old} + \\boldsymbol{v}_t \\Delta t$ 对切向弹簧位移执行显式时间积分的试探更新。\n2. 计算相应的试探切向力 $\\boldsymbol{F}_t^{trial} = -k_t \\boldsymbol{\\xi}^{trial}$。\n3. 在必要时通过投影回容许集来强制施加库仑摩擦极限：\n   - 如果 $F_n \\le 0$，则接触点非承载，设置 $\\boldsymbol{\\xi}^{new} = \\boldsymbol{0}$ 和 $\\boldsymbol{F}_t = \\boldsymbol{0}$。\n   - 否则，如果 $\\lVert \\boldsymbol{F}_t^{trial} \\rVert \\le \\mu F_n$，则设置 $\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial}$ 和 $\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial}$ (粘滞)。\n   - 否则 (滑动)，通过设置 $\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial} \\dfrac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}$ 和 $\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}^{new}$，将试探状态重新缩放至库仑面上。这确保了 $\\lVert \\boldsymbol{F}_t \\rVert = \\mu F_n$，且 $\\boldsymbol{F}_t$ 与切向平面中的试探方向对齐。\n\n所有矢量均为局部切向平面中的二维矢量。使用国际单位制：$\\boldsymbol{\\xi}^{new}$ 以 $\\mathrm{m}$ 表示，$\\boldsymbol{F}_t$ 以 $\\mathrm{N}$ 表示。不需要角度。数值输出应表示为原始的十进制浮点数。\n\n测试套件：\n提供以下六个测试用例，每个用例由 $(F_n, \\mu, k_t, \\Delta t, \\boldsymbol{v}_t, \\boldsymbol{\\xi}^{old})$ 指定，并附有给定单位：\n- 用例 $1$ (粘滞，小增量)：$F_n = 100\\,\\mathrm{N}$, $\\mu = 0.5$, $k_t = 10^4\\,\\mathrm{N/m}$, $\\Delta t = 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [0.01, 0]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 $2$ (滑动，大增量)：$F_n = 100\\,\\mathrm{N}$, $\\mu = 0.5$, $k_t = 10^4\\,\\mathrm{N/m}$, $\\Delta t = 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [10, 0]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 $3$ (边界，恰好在极限上)：$F_n = 100\\,\\mathrm{N}$, $\\mu = 0.5$, $k_t = 10^4\\,\\mathrm{N/m}$, $\\Delta t = 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [5, 0]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 $4$ (无接触)：$F_n = 0\\,\\mathrm{N}$, $\\mu = 0.5$, $k_t = 10^4\\,\\mathrm{N/m}$, $\\Delta t = 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [100, -100]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [0, 0]\\,\\mathrm{m}$。\n- 用例 $5$ (粘滞，斜向更新)：$F_n = 10\\,\\mathrm{N}$, $\\mu = 0.3$, $k_t = 2 \\times 10^4\\,\\mathrm{N/m}$, $\\Delta t = 2 \\times 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [0.003, -0.004]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [10^{-4}, 0]\\,\\mathrm{m}$。\n- 用例 $6$ (返回映射，弹簧有预加载)：$F_n = 5\\,\\mathrm{N}$, $\\mu = 0.2$, $k_t = 10^4\\,\\mathrm{N/m}$, $\\Delta t = 10^{-3}\\,\\mathrm{s}$, $\\boldsymbol{v}_t = [0, 0]\\,\\mathrm{m/s}$, $\\boldsymbol{\\xi}^{old} = [10^{-2}, 10^{-2}]\\,\\mathrm{m}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个元素都是对应测试用例的结果列表 $[\\xi_x, \\xi_y, F_{t,x}, F_{t,y}]$，采用国际单位制 (例如, $[[\\dots],[\\dots],\\dots]$)。每个数值条目必须是十进制浮点数。",
            "solution": "该问题要求推导并实现一种数值算法，用于更新单个摩擦接触点的切向力和弹簧位移，这是离散元法 (DEM) 中的一种常见模型。该模型基于线性切向弹簧和库仑摩擦定律。问题本身是适定的、科学上合理的，并提供了构建唯一解所需的所有信息。\n\n接触点的物理状态由局部二维切向平面中的切向弹簧位移矢量 $\\boldsymbol{\\xi}$ 描述。切向力 $\\boldsymbol{F}_t$ 假定与此位移成线性比例关系：\n$$\n\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}\n$$\n其中 $k_t > 0$ 是切向刚度。\n\n弹簧位移的演化由接触表面之间的相对切向速度 (滑移速度) $\\boldsymbol{v}_t$ 决定。弹性位移的变化率等于滑移速度：\n$$\n\\frac{d\\boldsymbol{\\xi}}{dt} = \\boldsymbol{v}_t\n$$\n\n切向力的大小受库仑摩擦准则的限制。切向力必须位于一个容许集内，该容许集是切向平面中的一个圆盘，定义为：\n$$\n\\lVert \\boldsymbol{F}_t \\rVert \\le \\mu F_n\n$$\n其中 $F_n \\ge 0$ 是法向压力，$\\mu \\ge 0$ 是静摩擦系数。当力的大小达到极限 $\\lVert \\boldsymbol{F}_t \\rVert = \\mu F_n$ 时，接触点处于宏观滑动状态，此时切向力矢量必须与滑移速度的方向相反。\n\n待实现的算法是一种预测-校正类型的显式时间步进格式，在计算塑性力学和接触力学中通常被称为“返回映射”算法。给定一个时间步长 $\\Delta t > 0$ 开始时的状态 (由 $\\boldsymbol{\\xi}^{old}$ 表示)，目标是计算该步长结束时的状态 $\\boldsymbol{\\xi}^{new}$ 和 $\\boldsymbol{F}_t$。\n\n**第 1 步：试探 (预测) 步**\n首先，我们使用前向欧拉格式对 $\\boldsymbol{\\xi}$ 的演化方程进行离散化。这会产生一个试探位移 $\\boldsymbol{\\xi}^{trial}$，它假设在整个时间步长 $\\Delta t$ 内行为是纯弹性的：\n$$\n\\boldsymbol{\\xi}^{trial} = \\boldsymbol{\\xi}^{old} + \\boldsymbol{v}_t \\Delta t\n$$\n根据此试探位移，计算出相应的试探切向力 $\\boldsymbol{F}_t^{trial}$：\n$$\n\\boldsymbol{F}_t^{trial} = -k_t \\boldsymbol{\\xi}^{trial}\n$$\n\n**第 2 步：约束强制 (校正) 步**\n接下来，根据库仑摩擦约束检查试探状态。存在三种可能的结果：\n\n**情况 A：无接触**\n如果法向力 $F_n \\le 0$，则接触不活跃或处于受拉状态。在针对颗粒材料的 DEM 中，通常不支持拉力，并且弹簧中任何现存的切向“记忆”都会丢失。因此，切向位移和力被重置为零。\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{0} \\quad \\text{和} \\quad \\boldsymbol{F}_t = \\boldsymbol{0}\n$$\n\n**情况 B：粘滞条件**\n如果接触是活跃的 ($F_n > 0$) 并且试探力的大小在容许的摩擦圆盘内，则纯弹性假设成立。这就是“粘滞”条件。\n$$\n\\text{如果 } \\lVert \\boldsymbol{F}_t^{trial} \\rVert \\le \\mu F_n, \\text{ 则接触点处于粘滞状态。}\n$$\n在这种情况下，试探值被接受为新状态的最终值：\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial}\n$$\n$$\n\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial}\n$$\n\n**情况 C：滑动条件**\n如果接触是活跃的 ($F_n > 0$) 并且试探力的大小超过了摩擦极限，则弹性假设无效。接触点必须滑动，并且切向力必须位于摩擦圆盘的边界上 (即“摩擦圆”)。\n$$\n\\text{如果 } \\lVert \\boldsymbol{F}_t^{trial} \\rVert > \\mu F_n, \\text{ 则接触点滑动。}\n$$\n校正后的力 $\\boldsymbol{F}_t$ 的大小必须恰好为 $\\mu F_n$，并且其方向必须与试探力 $\\boldsymbol{F}_t^{trial}$ 的方向相同。这可以通过将试探力矢量径向缩放回摩擦圆来实现。缩放因子是最大容许力大小与试探力大小之比。\n$$\n\\boldsymbol{F}_t = \\boldsymbol{F}_t^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}\n$$\n这个新力的范数为 $\\lVert \\boldsymbol{F}_t \\rVert = \\left\\lVert \\boldsymbol{F}_t^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert} \\right\\rVert = \\lVert \\boldsymbol{F}_t^{trial} \\rVert \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert} = \\mu F_n$，符合要求。\n由于力和位移通过常数 $-k_t$ 线性相关，因此最终位移 $\\boldsymbol{\\xi}^{new}$ 可通过将相同的缩放因子应用于试探位移 $\\boldsymbol{\\xi}^{trial}$ 得到：\n$$\n\\boldsymbol{\\xi}^{new} = \\boldsymbol{\\xi}^{trial} \\frac{\\mu F_n}{\\lVert \\boldsymbol{F}_t^{trial} \\rVert}\n$$\n然后，最终的力可以一致地计算为 $\\boldsymbol{F}_t = -k_t \\boldsymbol{\\xi}^{new}$。\n\n这种预测-校正算法在显式 DEM 时间步进框架内，稳健而高效地强制实施了非光滑、非线性的库仑摩擦定律。我们现在将为给定的测试用例实现此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DEM tangential contact problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (stick, small increment)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [0.01, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 2 (slide, large increment)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [10.0, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 3 (boundary, exactly at limit)\n        {'Fn': 100.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [5.0, 0.0], 'xi_old': [0.0, 0.0]},\n        # Case 4 (no contact)\n        {'Fn': 0.0, 'mu': 0.5, 'kt': 1e4, 'dt': 1e-3, 'vt': [100.0, -100.0], 'xi_old': [0.0, 0.0]},\n        # Case 5 (stick with oblique update)\n        {'Fn': 10.0, 'mu': 0.3, 'kt': 2e4, 'dt': 2e-3, 'vt': [0.003, -0.004], 'xi_old': [1e-4, 0.0]},\n        # Case 6 (return mapping with preloaded spring)\n        {'Fn': 5.0, 'mu': 0.2, 'kt': 1e4, 'dt': 1e-3, 'vt': [0.0, 0.0], 'xi_old': [1e-2, 1e-2]},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = update_tangential_contact(\n            case['Fn'], case['mu'], case['kt'], case['dt'],\n            np.array(case['vt']), np.array(case['xi_old'])\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required\n    inner_parts = [f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]\n    final_string = f\"[{','.join(inner_parts)}]\"\n    print(final_string)\n\ndef update_tangential_contact(Fn, mu, kt, dt, vt, xi_old):\n    \"\"\"\n    Computes the updated tangential spring displacement and contact force.\n\n    Args:\n        Fn (float): Normal force (N).\n        mu (float): Friction coefficient.\n        kt (float): Tangential stiffness (N/m).\n        dt (float): Time step (s).\n        vt (np.ndarray): Tangential slip velocity vector (m/s).\n        xi_old (np.ndarray): Previous tangential spring displacement vector (m).\n\n    Returns:\n        list: A list containing [xi_new_x, xi_new_y, Ft_x, Ft_y].\n    \"\"\"\n    # Case: No contact\n    if Fn = 0:\n        xi_new = np.zeros(2)\n        Ft = np.zeros(2)\n        return xi_new.tolist() + Ft.tolist()\n\n    # Step 1: Trial update (predictor)\n    xi_trial = xi_old + vt * dt\n\n    # Step 2: Compute trial force\n    Ft_trial = -kt * xi_trial\n\n    # Compute magnitude of trial force\n    norm_Ft_trial = np.linalg.norm(Ft_trial)\n\n    # Compute friction limit\n    friction_limit = mu * Fn\n\n    # Step 3: Enforce Coulomb friction limit (corrector)\n    # Case: Stick condition\n    if norm_Ft_trial = friction_limit:\n        xi_new = xi_trial\n        Ft = Ft_trial\n    # Case: Slip condition\n    else:\n        # The return mapping requires division by the norm of the trial force.\n        # This is safe because if norm_Ft_trial were 0, the 'if' condition\n        # (0 = friction_limit) would have been true (since mu*Fn >= 0).\n        scaling_factor = friction_limit / norm_Ft_trial\n        xi_new = xi_trial * scaling_factor\n        # The final force can be calculated either by scaling Ft_trial or\n        # by using the new displacement. The latter is more robust to\n        # potential floating point inconsistencies.\n        Ft = -kt * xi_new\n\n    # Return the result as a list of floats\n    return xi_new.tolist() + Ft.tolist()\n\nsolve()\n```"
        },
        {
            "introduction": "当作用在颗粒上的所有力和力矩都计算出来后，我们必须对每个时间步内的平动和转动进行积分。精确地表示和更新三维旋转是其中的一个关键挑战，而四元数提供了一种避免“万向节死锁”等问题的稳健方法。这个练习  将引导你实现基于角速度的四元数方向更新，这包括了运动学方程的时间积分以及为保持单位范数所必需的归一化步骤。这是模拟三维空间中任何非球形或旋转颗粒动力学的基础技能。",
            "id": "4095032",
            "problem": "考虑在计算复杂流体中使用离散元法 (DEM) 对刚性球形颗粒进行的旋转更新。颗粒的朝向由单位四元数 $\\mathbf{q}(t) = [q_0(t), q_1(t), q_2(t), q_3(t)]^\\top$ 表示，其中 $q_0$ 是标量部分，$[q_1, q_2, q_3]$ 是矢量部分。角速度 $\\boldsymbol{\\omega}(t) = [\\omega_x(t), \\omega_y(t), \\omega_z(t)]^\\top$ 在颗粒（物体）坐标系中表示，单位为弧度/秒。在时长为 $\\Delta t$（单位为秒）的单个时间步长内，假设 $\\boldsymbol{\\omega}(t)$ 是恒定的。仅从基础刚体运动学和单位四元数的性质出发，推导四元数变化率，实现一阶显式（前向欧拉）朝向更新，并应用重新归一化来强制执行单位范数约束。\n\n具体来说，您的程序必须针对每个提供的测试用例，使用一阶显式时间积分器和随后的重新归一化，根据给定的当前四元数 $\\mathbf{q}(t)$ 和角速度 $\\boldsymbol{\\omega}(t)$ 计算更新后的四元数 $\\mathbf{q}(t+\\Delta t)$。使用 Hamilton 四元数约定和标量优先布局。四元数重新归一化步骤必须除以更新后四元数的欧几里得范数，以确保 $\\|\\mathbf{q}(t+\\Delta t)\\|_2 = 1$。\n\n物理单位：报告并使用 $\\boldsymbol{\\omega}$（单位为弧度/秒）和 $\\Delta t$（单位为秒）。四元数是无量纲的。\n\n角度单位：弧度。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，列表中的每个条目是一个测试用例的更新后四元数，表示为 $[q_0, q_1, q_2, q_3]$ 顺序的四个浮点数的列表；例如，包含两个测试用例的输出应如下所示：$[[q_{0,1}, q_{1,1}, q_{2,1}, q_{3,1}],[q_{0,2}, q_{1,2}, q_{2,2}, q_{3,2}]]$。\n\n测试套件（请使用这些精确的参数值）：\n- 案例 $1$（零角速度，单位四元数）：$\\mathbf{q}(t) = [1.0, 0.0, 0.0, 0.0]$，$\\boldsymbol{\\omega}(t) = [0.0, 0.0, 0.0]$，$\\Delta t = 10^{-3}$。\n- 案例 $2$（仅归一化检查，轻微非单位四元数）：$\\mathbf{q}(t) = [0.999, 0.001, 0.0, 0.0]$，$\\boldsymbol{\\omega}(t) = [0.0, 0.0, 0.0]$，$\\Delta t = 10^{-3}$。\n- 案例 $3$（绕 z 轴的非零角速度）：$\\mathbf{q}(t) = [1.0, 0.0, 0.0, 0.0]$，$\\boldsymbol{\\omega}(t) = [0.0, 0.0, \\pi]$，$\\Delta t = 10^{-3}$。\n- 案例 $4$（绕 y 轴的大角速度，非平凡的初始朝向）：$\\mathbf{q}(t) = [0.7071067811865476, 0.7071067811865476, 0.0, 0.0]$，$\\boldsymbol{\\omega}(t) = [0.0, 50\\pi, 0.0]$，$\\Delta t = 2 \\times 10^{-3}$。\n- 案例 $5$（零时间步长边界情况）：$\\mathbf{q}(t) = [0.9238795325112867, 0.0, 0.3826834323650898, 0.0]$，$\\boldsymbol{\\omega}(t) = [10.0, -20.0, 5.0]$，$\\Delta t = 0.0$。\n- 案例 $6$（高模角速度矢量）：$\\mathbf{q}(t) = [0.5, 0.5, 0.5, 0.5]$，$\\boldsymbol{\\omega}(t) = [1000.0, -500.0, 250.0]$，$\\Delta t = 10^{-3}$。\n\n您的程序必须实现与物体坐标系角速度的刚体运动学一致的、数学上正确的一阶显式四元数更新，然后进行重新归一化。最终输出格式必须是单行，包含如上所述的所有六个测试用例的更新后四元数。",
            "solution": "该问题要求推导并实现一个一阶显式数值积分方案，用于在给定刚体在物体坐标系中的角速度的情况下，更新由单位四元数表示的刚体朝向。该过程包括三个主要步骤：从运动学推导四元数变化率，应用前向欧拉时间步，以及对结果进行重新归一化以强制执行单位范数约束。\n\n设颗粒在时间 $t$ 的朝向由单位四元数 $\\mathbf{q}(t) = [q_0(t), q_1(t), q_2(t), q_3(t)]^\\top$ 描述，其中 $q_0$ 是标量部分，$\\mathbf{q}_v = [q_1, q_2, q_3]^\\top$ 是矢量部分。我们采用 Hamilton 约定和标量优先布局。颗粒的角速度在其自身的物体固定参考坐标系中表示，由矢量 $\\boldsymbol{\\omega}(t) = [\\omega_x(t), \\omega_y(t), \\omega_z(t)]^\\top$ 给出。\n\n首先，我们建立四元数的时间导数 $\\dot{\\mathbf{q}}(t) = d\\mathbf{q}/dt$ 与角速度 $\\boldsymbol{\\omega}$ 之间的基本运动学关系。该关系由下式给出：\n$$\n\\dot{\\mathbf{q}}(t) = \\frac{1}{2} \\mathbf{q}(t) \\otimes \\boldsymbol{\\omega}_q(t)\n$$\n其中 $\\otimes$ 表示四元数乘法，而 $\\boldsymbol{\\omega}_q(t)$ 是由角速度矢量构成的“纯”四元数，即 $\\boldsymbol{\\omega}_q(t) = [0, \\omega_x(t), \\omega_y(t), \\omega_z(t)]^\\top$。\n\n根据 Hamilton 四元数乘法规则，对于 $\\mathbf{a} = [a_0, \\mathbf{a}_v]$ 和 $\\mathbf{b} = [b_0, \\mathbf{b}_v]$，其乘积 $\\mathbf{c} = \\mathbf{a} \\otimes \\mathbf{b}$ 为：\n$$\nc_0 = a_0 b_0 - \\mathbf{a}_v \\cdot \\mathbf{b}_v\n$$\n$$\n\\mathbf{c}_v = a_0 \\mathbf{b}_v + b_0 \\mathbf{a}_v + \\mathbf{a}_v \\times \\mathbf{b}_v\n$$\n将此应用于我们的运动学方程，其中 $\\mathbf{a} = \\mathbf{q} = [q_0, \\mathbf{q}_v]$ 且 $\\mathbf{b} = \\boldsymbol{\\omega}_q = [0, \\boldsymbol{\\omega}]$，我们得到乘积 $\\mathbf{q} \\otimes \\boldsymbol{\\omega}_q$ 的分量：\n标量部分：$q_0(0) - \\mathbf{q}_v \\cdot \\boldsymbol{\\omega} = - (q_1\\omega_x + q_2\\omega_y + q_3\\omega_z)$。\n矢量部分：$q_0\\boldsymbol{\\omega} + (0)\\mathbf{q}_v + \\mathbf{q}_v \\times \\boldsymbol{\\omega}$。\n\n叉积 $\\mathbf{q}_v \\times \\boldsymbol{\\omega}$ 的分量为：\n$$\n\\mathbf{q}_v \\times \\boldsymbol{\\omega} = \\begin{bmatrix} q_2\\omega_z - q_3\\omega_y \\\\ q_3\\omega_x - q_1\\omega_z \\\\ q_1\\omega_y - q_2\\omega_x \\end{bmatrix}\n$$\n结合这些项，$\\dot{\\mathbf{q}} = \\frac{1}{2} \\mathbf{q} \\otimes \\boldsymbol{\\omega}_q$ 的四个分量是：\n$$\n\\begin{aligned}\n\\dot{q}_0 = \\frac{1}{2}(-q_1\\omega_x - q_2\\omega_y - q_3\\omega_z) \\\\\n\\dot{q}_1 = \\frac{1}{2}(q_0\\omega_x + q_2\\omega_z - q_3\\omega_y) \\\\\n\\dot{q}_2 = \\frac{1}{2}(q_0\\omega_y + q_3\\omega_x - q_1\\omega_z) \\\\\n\\dot{q}_3 = \\frac{1}{2}(q_0\\omega_z + q_1\\omega_y - q_2\\omega_x)\n\\end{aligned}\n$$\n这个线性常微分方程组可以用矩阵形式表示为 $\\dot{\\mathbf{q}} = \\mathbf{\\Omega}(\\boldsymbol{\\omega})\\mathbf{q}$，其中 $\\mathbf{\\Omega}(\\boldsymbol{\\omega})$ 是一个依赖于 $\\boldsymbol{\\omega}$ 的斜对称矩阵：\n$$\n\\dot{\\mathbf{q}}(t) = \\frac{1}{2} \\begin{bmatrix} 0   -\\omega_x   -\\omega_y   -\\omega_z \\\\ \\omega_x   0   \\omega_z   -\\omega_y \\\\ \\omega_y   -\\omega_z   0   \\omega_x \\\\ \\omega_z   \\omega_y   -\\omega_x   0 \\end{bmatrix} \\begin{bmatrix} q_0(t) \\\\ q_1(t) \\\\ q_2(t) \\\\ q_3(t) \\end{bmatrix}\n$$\n\n接下来，我们应用一阶显式（前向欧拉）方法，在一个小的时间步长 $\\Delta t$ 上对该方程进行积分。导数 $\\dot{\\mathbf{q}}(t)$ 近似为 $\\frac{\\mathbf{q}(t+\\Delta t) - \\mathbf{q}(t)}{\\Delta t}$。假设 $\\boldsymbol{\\omega}$ 在该区间内是恒定的，这给出了更新规则：\n$$\n\\mathbf{q}_{\\text{unnormalized}}(t+\\Delta t) = \\mathbf{q}(t) + \\Delta t \\cdot \\dot{\\mathbf{q}}(t)\n$$\n这个方案计算简单，但具有 $O(\\Delta t^2)$ 阶的局部截断误差，并且关键的是，它通常不保留四元数的单位范数性质，即 $\\|\\mathbf{q}_{\\text{unnormalized}}(t+\\Delta t)\\|_2 \\neq 1$。这种数值误差会随时间累积，导致偏离有效旋转空间。\n\n为了对抗这种漂移，重新归一化步骤是强制性的。在计算出未归一化的四元数 $\\mathbf{q}_{\\text{unnormalized}}$ 后，我们通过将其除以其欧几里得范数，将其投影回 $\\mathbb{R}^4$ 中的单位超球面上：\n$$\n\\mathbf{q}(t+\\Delta t) = \\frac{\\mathbf{q}_{\\text{unnormalized}}(t+\\Delta t)}{\\|\\mathbf{q}_{\\text{unnormalized}}(t+\\Delta t)\\|_2}\n$$\n其中范数为 $\\|\\mathbf{q}'\\|_2 = \\sqrt{q'_0{}^2 + q'_1{}^2 + q'_2{}^2 + q'_3{}^2}$。\n\n因此，单个时间步长的完整算法如下：\n1.  给定 $\\mathbf{q}(t)$、$\\boldsymbol{\\omega}(t)$ 和 $\\Delta t$。\n2.  使用上面推导的分量公式计算四元数时间导数 $\\dot{\\mathbf{q}}(t)$。\n3.  执行前向欧拉步骤以找到未归一化的下一个状态：$\\mathbf{q}' = \\mathbf{q}(t) + \\Delta t \\cdot \\dot{\\mathbf{q}}(t)$。\n4.  计算结果的欧几里得范数：$N = \\|\\mathbf{q}'\\|_2$。\n5.  通过归一化获得下一个时间步的最终有效四元数：$\\mathbf{q}(t+\\Delta t) = \\mathbf{q}' / N$。如果 $N=0$，则朝向未定义；然而，对于非零的初始四元数和有限的时间步长，$N$ 将为非零。\n对每个提供的测试用例都实施此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef update_quaternion_orientation(q: np.ndarray, omega: np.ndarray, dt: float) -> np.ndarray:\n    \"\"\"\n    Updates a quaternion orientation using a first-order explicit (forward Euler)\n    integrator for a given body-frame angular velocity.\n\n    Args:\n        q (np.ndarray): The current orientation quaternion [q0, q1, q2, q3] (scalar-first).\n        omega (np.ndarray): The angular velocity in the body frame [wx, wy, wz] in rad/s.\n        dt (float): The time step duration in seconds.\n\n    Returns:\n        np.ndarray: The updated and renormalized quaternion.\n    \"\"\"\n    # Ensure inputs are numpy arrays for vectorized operations\n    q = np.asarray(q, dtype=float)\n    omega = np.asarray(omega, dtype=float)\n\n    # Extract components for clarity\n    q0, q1, q2, q3 = q[0], q[1], q[2], q[3]\n    wx, wy, wz = omega[0], omega[1], omega[2]\n\n    # Calculate the time derivative of the quaternion based on kinematic equations\n    # for body-frame angular velocity and Hamilton, scalar-first convention.\n    # q_dot = 0.5 * q * omega_q\n    q_dot = np.array([\n        0.5 * (-q1*wx - q2*wy - q3*wz),\n        0.5 * ( q0*wx + q2*wz - q3*wy),\n        0.5 * ( q0*wy - q1*wz + q3*wx),\n        0.5 * ( q0*wz + q1*wy - q2*wx)\n    ])\n\n    # Apply the forward Euler integration step\n    q_unnormalized = q + q_dot * dt\n\n    # Renormalize the quaternion to enforce the unit-norm constraint\n    norm = np.linalg.norm(q_unnormalized)\n\n    # Avoid division by zero, though unlikely for valid inputs.\n    # If the norm is very close to zero, it signals a catastrophic numerical error,\n    # and we should recover by resetting to a known valid state (e.g., identity).\n    if norm  1e-15:\n        # For the specific test case 2, an initial non-unit quaternion with zero omega\n        # will result in a non-zero norm, and the code proceeds to normalize it correctly.\n        # This block is for true numerical underflow.\n        initial_norm = np.linalg.norm(q)\n        if initial_norm  1e-15:\n            return np.array([1.0, 0.0, 0.0, 0.0]) # return identity if input was also zero\n        return q / initial_norm # otherwise, revert update by returning normalized original q\n\n    q_normalized = q_unnormalized / norm\n    \n    return q_normalized\n\ndef solve():\n    \"\"\"\n    Runs the quaternion update for a suite of test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: zero angular velocity, identity quaternion\n        ([1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0], 1e-3),\n        # Case 2: renormalization-only check, slightly non-unit quaternion\n        ([0.999, 0.001, 0.0, 0.0], [0.0, 0.0, 0.0], 1e-3),\n        # Case 3: nonzero angular velocity about z-axis\n        ([1.0, 0.0, 0.0, 0.0], [0.0, 0.0, np.pi], 1e-3),\n        # Case 4: large angular velocity, nontrivial initial orientation\n        ([0.7071067811865476, 0.7071067811865476, 0.0, 0.0], [0.0, 50*np.pi, 0.0], 2e-3),\n        # Case 5: zero time step boundary case\n        ([0.9238795325112867, 0.0, 0.3826834323650898, 0.0], [10.0, -20.0, 5.0], 0.0),\n        # Case 6: high-magnitude angular velocity vector\n        ([0.5, 0.5, 0.5, 0.5], [1000.0, -500.0, 250.0], 1e-3),\n    ]\n\n    results = []\n    for q_initial, omega, dt in test_cases:\n        q_final = update_quaternion_orientation(q_initial, omega, dt)\n        results.append(q_final.tolist())\n\n    # Format the final output string to match the required format:\n    # [[q0,q1,q2,q3],[...],...] with no spaces.\n    results_str = str(results).replace(\" \", \"\")\n    print(results_str)\n\nsolve()\n```"
        }
    ]
}