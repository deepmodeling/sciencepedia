{
    "hands_on_practices": [
        {
            "introduction": "在实施自适应网格加密（AMR）之前，理解其计算成本至关重要。这项练习将指导您完成一项基本估算，即需要多少加密的网格单元来解析一个尖锐界面。此分析基于一个核心原则：所需单元的数量与待加密区域的总面积成正比，与单个单元的面积成反比，这有助于您预测内存需求和计算负载。",
            "id": "4078652",
            "problem": "在一个具有清晰材料界面的复杂流体的二维块结构自适应网格加密（Adaptive Mesh Refinement (AMR)）模拟中，考虑一个总弧长为 $L$ 的光滑界面曲线。该曲线嵌入在一个计算域中，在加密级别 $\\ell$ 下，一个半宽为 $w$（在物理空间中测量）的加密带对称地维持在界面周围。AMR使用方形块：在级别 $\\ell$，每个块是边长为 $s_{\\ell}$（物理单位）的正方形，其与级别 $0$ 的块边长 $s_0$ 的关系为 $s_{\\ell} = s_{0} \\, r^{-\\ell}$，其中 $r > 1$ 是加密比（即，每个加密级别将线性尺度缩小一个因子 $r$）。假设如下：\n- 界面曲线是光滑的，其各处的最小曲率半径远大于 $w$，因此界面周围半宽为 $w$ 的管状邻域不会自重叠。\n- 加密带很窄，即 $w \\ll L$，并且在主导阶上，边界和末端效应可以忽略不计。\n- 在估计数量时，块的放置方式使得重叠和填充效率低下的影响在主导阶上可以忽略不计。\n\n从基本的几何测量考量和块面积随加密级别的缩放关系出发，推导覆盖该加密带所需的级别 $\\ell$ 块数量的主导阶估计。将最终答案表示为关于 $L$、$w$、$r$、$\\ell$ 和 $s_0$ 的单个闭式解析表达式。不需要进行数值计算，也不需要四舍五入。最终答案必须是单个表达式。",
            "solution": "问题陈述已经过验证，被认为是具有科学依据、适定、客观且内部一致的。它提出了计算方法分析中的一个标准问题，特别是关于应用于界面现象的自适应网格加密（AMR）技术所需计算资源的估算。所有给定的数据和假设都足以并且适合用于推导所要求的主导阶估计。\n\n任务是推导覆盖材料界面周围指定加密带所需的级别 $\\ell$ 块（表示为 $N_{\\ell}$）数量的主导阶估计。该方法将基于基本几何原理，具体而言，通过将待加密区域的总面积与指定加密级别下单个计算块的面积相关联。\n\n首先，我们定义加密带的面积 $A_{band}$。问题陈述指出，一个半宽为 $w$ 的加密带对称地维持在一个总弧长为 $L$ 的界面曲线周围。这在曲线周围形成了一个管状邻域。因此，该带的总宽度为 $2w$。问题提供了几个关键的简化假设：界面曲线是光滑的，其最小曲率半径远大于 $w$，并且 $w \\ll L$。这些假设使我们能够通过忽略曲率效应来近似计算该带的面积。在主导阶近似下，这个窄管状邻域的面积是曲线弧长与带的总宽度的乘积。这等效于将曲线“展开”成一条长度为 $L$ 的直线，并计算其周围宽度为 $2w$ 的矩形面积。\n因此，加密带的面积由下式给出：\n$$\nA_{band} = L \\times (2w) = 2Lw\n$$\n\n接下来，我们确定在加密级别 $\\ell$ 下单个计算块的面积，我们将其表示为 $A_{block, \\ell}$。问题指明 AMR 使用方形块。级别 $\\ell$ 的块的边长，表示为 $s_{\\ell}$，通过以下缩放定律与级别 $0$ 的块的边长 $s_0$ 和加密比 $r$ 相关联：\n$$\ns_{\\ell} = s_{0} \\, r^{-\\ell}\n$$\n由于块是方形的，单个级别 $\\ell$ 块的面积是其边长的平方：\n$$\nA_{block, \\ell} = s_{\\ell}^2 = (s_{0} \\, r^{-\\ell})^2 = s_{0}^2 \\, r^{-2\\ell}\n$$\n\n最后，我们可以估计覆盖整个加密带所需的级别 $\\ell$ 块的数量 $N_{\\ell}$。问题陈述指出，在主导阶上可以忽略重叠和填充效率低下的问题。这个关键的简化意味着可以通过将带的总面积除以单个块的面积来估计块的总数。\n$$\nN_{\\ell} \\approx \\frac{A_{band}}{A_{block, \\ell}}\n$$\n代入我们推导出的 $A_{band}$ 和 $A_{block, \\ell}$ 的表达式：\n$$\nN_{\\ell} = \\frac{2Lw}{s_{0}^2 \\, r^{-2\\ell}}\n$$\n通过简化表达式，我们将分母中带有负指数的项移到分子中：\n$$\nN_{\\ell} = 2Lw s_{0}^{-2} r^{2\\ell}\n$$\n这可以更清晰地写成分数形式：\n$$\nN_{\\ell} = \\frac{2Lw r^{2\\ell}}{s_{0}^2}\n$$\n该表达式提供了级别 $\\ell$ 块数量的主导阶估计。根据问题陈述的要求，它是一个关于给定参数 $L$、$w$、$r$、$\\ell$ 和 $s_0$ 的闭式解析表达式。",
            "answer": "$$\n\\boxed{\\frac{2Lw r^{2\\ell}}{s_{0}^2}}\n$$"
        },
        {
            "introduction": "AMR 的一个主要挑战是确保物理量在粗细网格边界上是守恒的。这项练习将通过一个具体的计算任务，向您展示“通量修正”（refluxing）过程。这一过程的核心思想是，离开粗网格的总通量必须精确等于进入相邻细网格的总通量，从而消除界面处的人为误差并维持系统的全局守恒性。",
            "id": "4078654",
            "problem": "考虑在二维有限体积离散化中，具有恒定密度的被动标量的对流-扩散。设计算网格采用自适应网格加密（AMR），空间和时间上的加密比均为 $r=2$。一个粗控制体的东侧面与一个加密区域的西边界重合，该加密区域由 $2$ 个在垂直方向上堆叠的细网格单元组成。粗网格时间步长为 $\\Delta t_{\\mathrm{c}}$，细网格层级以两个大小为 $\\Delta t_{\\mathrm{f}}=\\Delta t_{\\mathrm{c}}/2$ 的子步长进行推进。\n\n在任何控制体中，一个时间步长内标量量的有限体积更新由守恒的积分形式给出：其变化量等于通过控制体边界的时间积分净向外通量的负值，加上任何时间积分的源项。此处没有源项。在粗细网格界面处，守恒要求在 $\\Delta t_{\\mathrm{c}}$ 时间内通过粗网格面的时间积分通量，等于在两个细网格子步长时间内通过其分割出的细网格面的时间积分通量之和。\n\n对于粗网格单元的东侧面，定义从粗网格单元指向加密区域的方向为正方向。在第一个细网格子步长（$k=1$）期间，从粗网格单元进入下部细网格面段的时间积分通量为 $\\Phi_{1}^{(1)}=0.030$ mol，进入上部细网格面段的为 $\\Phi_{2}^{(1)}=0.028$ mol。在第二个细网格子步长（$k=2$）期间，相应的时间积分通量为 $\\Phi_{1}^{(2)}=0.031$ mol 和 $\\Phi_{2}^{(2)}=0.029$ mol。粗网格求解器对 $\\Delta t_{\\mathrm{c}}$ 时间内粗网格东侧面时间积分通量的预测值为 $\\Phi_{\\mathrm{E}}^{\\mathrm{pred}}=0.110$ mol。\n\n从积分守恒定律和通量在不相交时空划分上的可加性出发，确定在 $\\Delta t_{\\mathrm{c}}$ 时间内唯一的、能在粗细网格界面上强制守恒的校正后粗网格东侧面时间积分通量 $\\Phi_{\\mathrm{E}}^{\\mathrm{corr}}$。然后，使用相同的守恒原理，解释为什么用 $\\Phi_{\\mathrm{E}}^{\\mathrm{corr}}$ 替换 $\\Phi_{\\mathrm{E}}^{\\mathrm{pred}}$ 可以消除该界面上的人为增益或损失。\n\n以 mol 为单位表示 $\\Phi_{\\mathrm{E}}^{\\mathrm{corr}}$ 的最终值。不要对答案进行四舍五入。",
            "solution": "该问题是有效的。这是一个计算流体动力学领域中适定的、有科学依据的问题，专门探讨了在自适应网格加密（AMR）中强制执行守恒律的方法。所有必要的数据均已提供，且术语是该领域的标准术语。\n\n在时间间隔 $[t_1, t_2]$ 内，控制体 $V$ 中守恒标量 $\\psi$ 的更新所遵循的基本原理是守恒定律的积分形式。在没有源或汇的情况下，该定律指出，体积内标量总量的变化等于通过其边界 $\\partial V$ 流入体积的标量净量。在数学上，这表示为：\n$$ \\int_V \\psi(t_2) dV - \\int_V \\psi(t_1) dV = - \\int_{t_1}^{t_2} \\oint_{\\partial V} (\\mathbf{F} \\cdot \\mathbf{n}) dA dt $$\n其中 $\\mathbf{F}$ 是标量 $\\psi$ 的通量矢量，$\\mathbf{n}$ 是边界面元 $dA$ 上指向外部的单位法向量。等式右边代表时间积分净向外通量的负值。\n\n在有限体积法中，此原理应用于离散的控制体（单元）。对于 AMR，确保不同网格分辨率之间的界面上的守恒是至关重要的。该问题描述了这样一个界面，其中一个粗网格单元的东侧面与一个细网格单元区域相邻。粗网格面在空间上被分割成 $2$ 个细网格面，粗网格时间步长 $\\Delta t_{\\mathrm{c}}$ 在时间上被分割成 $2$ 个细网格时间步长 $\\Delta t_{\\mathrm{f}}$。\n\n设 $\\Phi_{\\mathrm{E,c}}$ 表示在粗网格时间步长 $\\Delta t_{\\mathrm{c}}$ 内通过粗网格东侧面的总时间积分通量。设 $\\Phi_{j}^{(k)}$ 为在第 $k$ 个细网格时间子步长（其中 $k \\in \\{1, 2\\}$）内通过第 $j$ 个细网格面段（其中 $j \\in \\{1, 2\\}$ 分别代表下部和上部面段）的时间积分通量。守恒的核心要求是，通过粗网格面的标量总量必须与在所有子时间步长内通过其组成的细网格面部分的量之和完全相同。通量在时空表面的不相交划分上是可加的。因此，我们可以写出：\n$$ \\Phi_{\\mathrm{E,c}} = \\sum_{k=1}^{2} \\sum_{j=1}^{2} \\Phi_{j}^{(k)} $$\n校正后的粗网格东侧面通量 $\\Phi_{\\mathrm{E}}^{\\mathrm{corr}}$ 正是这个为强制守恒所需的量。由细网格求解器计算出的值被视为跨界面通量的确定性度量。\n\n问题给出了细网格面时间积分通量的值：\n- 在第一个细网格子步长（$k=1$）期间：$\\Phi_{1}^{(1)} = 0.030$ mol 和 $\\Phi_{2}^{(1)} = 0.028$ mol。\n- 在第二个细网格子步长（$k=2$）期间：$\\Phi_{1}^{(2)} = 0.031$ mol 和 $\\Phi_{2}^{(2)} = 0.029$ mol。\n\n使用守恒原理，我们将这些通量相加，以找到校正后的粗网格面通量：\n$$ \\Phi_{\\mathrm{E}}^{\\mathrm{corr}} = \\Phi_{1}^{(1)} + \\Phi_{2}^{(1)} + \\Phi_{1}^{(2)} + \\Phi_{2}^{(2)} $$\n代入给定值：\n$$ \\Phi_{\\mathrm{E}}^{\\mathrm{corr}} = 0.030 + 0.028 + 0.031 + 0.029 $$\n$$ \\Phi_{\\mathrm{E}}^{\\mathrm{corr}} = (0.030 + 0.028) + (0.031 + 0.029) $$\n$$ \\Phi_{\\mathrm{E}}^{\\mathrm{corr}} = 0.058 + 0.060 $$\n$$ \\Phi_{\\mathrm{E}}^{\\mathrm{corr}} = 0.118 \\text{ mol} $$\n\n现在，我们来解释为什么这种校正能够强制守恒。在典型的 AMR 预测-校正算法中，粗网格和细网格是独立推进的。粗网格求解器使用预测通量 $\\Phi_{\\mathrm{E}}^{\\mathrm{pred}} = 0.110$ mol 来更新与界面相邻的粗网格单元。根据这个预测值，有 $0.110$ mol 的标量通过其东侧面离开粗网格单元。\n同时，细网格求解器计算通过其西边界进入细网格区域的通量。进入细网格区域的总量是我们计算出的总和，即 $\\sum_{k,j} \\Phi_{j}^{(k)} = 0.118$ mol。\n这里存在一个差异：离开粗网格单元的量（$0.110$ mol）不等于进入细网格单元的量（$0.118$ mol）。这种不匹配，$\\delta \\Phi = 0.118 - 0.110 = 0.008$ mol，代表了在界面上标量的人为产生（净增益），这违反了全局守恒定律。\n\n为了纠正这个问题，对粗网格解进行校正。粗网格单元守恒方程中使用的通量 $\\Phi_{\\mathrm{E}}$ 被替换为校正后的通量 $\\Phi_{\\mathrm{E}}^{\\mathrm{corr}}$，该通量被定义为等于细网格通量之和。\n因此，我们将离开粗网格单元的通量设置为 $\\Phi_{\\mathrm{E}}^{\\mathrm{corr}} = 0.118$ mol。\n进入细网格单元的通量为 $\\sum_{k,j} \\Phi_{j}^{(k)} = 0.118$ mol。\n通过使用 $\\Phi_{\\mathrm{E}}^{\\mathrm{corr}}$，通过东侧面离开粗控制体的标量量，与通过西侧面进入相邻细控制体的标量量完全相等。这样，穿过界面的标量总量的净变化为零：\n$$ \\Delta Q_{\\text{total, interface}} = (\\text{flux into fine cells}) - (\\text{flux out of coarse cell}) = \\left(\\sum_{k,j} \\Phi_{j}^{(k)}\\right) - \\Phi_{\\mathrm{E}}^{\\mathrm{corr}} = 0.118 - 0.118 = 0 $$\n这个过程通常被称为“通量修正”（refluxing），它确保了在粗细网格界面上不会引入人为的源或汇，并且计算格式保持完全守恒。",
            "answer": "$$\n\\boxed{0.118}\n$$"
        },
        {
            "introduction": "这项综合性练习是本章的高潮，它将指导您亲手构建一个完整的 AMR 反馈循环。您将实现一个能够动态调整网格以同时解析界面和边界层的核心算法。这个过程完美地诠释了“估计-标记-自适应”的完整周期：利用后验误差估计来识别需要关注的区域，然后迭代地加密和粗化网格，直至达到全局精度目标。",
            "id": "4078680",
            "problem": "考虑一个一维耦合系统的自适应网格加密（AMR）循环，该系统代表了计算复杂流体中的界面层和边界层。空间域为 $[0,1]$，耦合场由无量纲相场变量 $\\phi(x)$ 和无量纲速度 $u(x)$ 定义，它们分别被选择用于捕捉位于中心附近的界面和左边界附近的边界层。这些函数是\n$$\n\\phi(x) = \\tanh\\left(\\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}\\right), \\quad u(x) = 1 - \\exp\\left(-\\frac{x}{\\delta}\\right),\n$$\n其中 $x_0 = 0.5$ 是界面位置，$\\epsilon > 0$ 是界面厚度参数，$\\delta > 0$ 是边界层厚度参数。网格由 $[0,1]$ 的一个剖分组成，该剖分由长度为 $h_i$ 的单元（闭区间）构成。\n\n从基本定义出发，即基于残差的能量范数估计器通过聚合空间二阶导数的贡献作为扩散主导过程中 $H^1$ 型范数曲率驱动误差的代理，使用以下建模选择作为局部误差指示器。对于中点为 $x_i$、尺寸为 $h_i$ 的单元 $i$，定义\n$$\n\\eta_{\\phi,i}^2 = \\alpha \\, h_i^2 \\, \\left|\\phi''(x_i)\\right|^2, \\quad \\eta_{u,i}^2 = \\beta \\, h_i^2 \\, \\left|u''(x_i)\\right|^2,\n$$\n以及组合局部指示器\n$$\n\\eta_i = \\sqrt{\\eta_{\\phi,i}^2 + \\eta_{u,i}^2}.\n$$\n取 $\\alpha = 1$ 和 $\\beta = 1$。\n\n定义全局能量估计器范数\n$$\n\\mathcal{E} = \\left(\\sum_{i} \\eta_i^2\\right)^{1/2}.\n$$\n\nAMR循环按如下方式进行，仅使用网格上的确定性局部操作：\n- 使用上述公式计算所有单元的 $\\eta_i$。\n- 使用参数为 $\\theta \\in (0,1)$ 的Dörfler标记法标记需要加密的单元：将 $\\eta_i^2$ 按降序排序，并选择一个最小子集 $\\mathcal{M}_\\mathrm{ref}$，使得\n$$\n\\sum_{i \\in \\mathcal{M}_\\mathrm{ref}} \\eta_i^2 \\ge \\theta \\sum_j \\eta_j^2.\n$$\n- 使用阈值 $\\kappa \\in (0,1)$ 标记需要粗化的单元：定义算术平均值 $\\overline{\\eta} = \\frac{1}{N}\\sum_i \\eta_i$，如果 $\\eta_i < \\kappa \\, \\overline{\\eta}$ 且该单元的加密等级大于0，则标记单元 $i$ 进行粗化。\n- 将 $\\mathcal{M}_\\mathrm{ref}$ 中的所有单元通过二等分成两个等长的单元来进行加密。\n- 通过合并具有相同加密等级的连续标记单元对来进行粗化；合并操作将这对单元替换为一个覆盖两个区间并集的、下一级更粗等级的单个单元。\n- 通过施加比率约束 $r > 1$ 来再平衡网格以维持相邻单元尺寸的规律性：如果两个相邻单元的尺寸为 $h_\\mathrm{large}$ 和 $h_\\mathrm{small}$，且满足 $h_\\mathrm{large}/h_\\mathrm{small} > r$，则二等分较大的单元。在相邻单元上迭代应用此再平衡操作，直到整个网格满足约束或不再发生变化。\n\n当全局能量估计器范数 $\\mathcal{E}$ 小于或等于目标容差 $\\mathrm{tol} > 0$，或达到最大迭代次数 $\\mathrm{max\\_iters}$ 时，终止循环。对于每个测试用例，程序必须输出达到 $\\mathcal{E} \\le \\mathrm{tol}$ 所需的AMR迭代次数（整数），如果在迭代限制内未满足容差，则输出整数 $-1$。\n\n所有量均为无量纲。\n\n测试套件：\n提供以下参数集，其中每个测试用例是一个元组 $(\\epsilon,\\delta,\\theta,\\kappa,r,N_0,\\mathrm{tol},\\mathrm{max\\_iters})$，初始网格在 $[0,1]$ 上有 $N_0$ 个均匀单元。\n- 用例 A（具有中等边界层的普通尖锐界面）：$(\\epsilon,\\delta,\\theta,\\kappa,r,N_0,\\mathrm{tol},\\mathrm{max\\_iters}) = (0.02, 0.05, 0.5, 0.3, 3.0, 16, 0.01, 20)$。\n- 用例 B（非常尖锐的界面）：$(\\epsilon,\\delta,\\theta,\\kappa,r,N_0,\\mathrm{tol},\\mathrm{max\\_iters}) = (0.005, 0.05, 0.4, 0.25, 4.0, 8, 0.005, 50)$。\n- 用例 C（弥散的界面和边界层）：$(\\epsilon,\\delta,\\theta,\\kappa,r,N_0,\\mathrm{tol},\\mathrm{max\\_iters}) = (0.05, 0.2, 0.6, 0.5, 2.5, 12, 0.02, 15)$。\n- 用例 D（严格容差限制用例）：$(\\epsilon,\\delta,\\theta,\\kappa,r,N_0,\\mathrm{tol},\\mathrm{max\\_iters}) = (0.01, 0.01, 0.7, 0.2, 3.0, 6, 0.001, 10)$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result1,result2,result3,result4]$），顺序与上述测试套件相同。每个 $result$ 必须是指定的整数。",
            "solution": "该问题要求为一维耦合系统实现自适应网格加密（AMR）模拟。解决方法涉及创建一个确定性算法，该算法基于后验误差指示器迭代地调整网格，直到达到全局误差容差或达到最大迭代次数。\n\n解决方案按以下步骤构建：\n1.  推导给定场的二阶导数的解析表达式，这些表达式是误差指示器的基础。\n2.  建立一个数据结构来表示计算网格。\n3.  详细说明AMR循环，包括误差估计、标记、网格自适应（加密/粗化）和再平衡。\n\n**1. 解析误差指示器函数**\n\n误差指示器基于相场变量 $\\phi(x)$ 和速度场 $u(x)$ 的空间二阶导数。\n\n对于相场变量 $\\phi(x) = \\tanh\\left(\\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}\\right)$，令 $z(x) = \\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}$。使用链式法则求其关于 $x$ 的一阶导数：\n$$\n\\phi'(x) = \\frac{d}{dx}\\tanh(z) = \\text{sech}^2(z) \\cdot \\frac{dz}{dx} = \\frac{1}{\\sqrt{2}\\,\\epsilon} \\text{sech}^2\\left(\\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}\\right)\n$$\n再次对 $\\phi'(x)$ 求导得到二阶导数：\n$$\n\\phi''(x) = \\frac{1}{\\sqrt{2}\\,\\epsilon} \\cdot \\frac{d}{dx}\\text{sech}^2(z) = \\frac{1}{\\sqrt{2}\\,\\epsilon} \\left[ -2 \\text{sech}(z)\\tanh(z)\\text{sech}(z) \\cdot \\frac{dz}{dx} \\right] \\\\\n= \\frac{1}{\\sqrt{2}\\,\\epsilon} \\left[ -2 \\text{sech}^2(z)\\tanh(z) \\cdot \\frac{1}{\\sqrt{2}\\,\\epsilon} \\right] \\\\\n= -\\frac{1}{\\epsilon^2} \\text{sech}^2\\left(\\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}\\right) \\tanh\\left(\\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}\\right)\n$$\n\n对于速度场 $u(x) = 1 - \\exp\\left(-\\frac{x}{\\delta}\\right)$，其导数更为直接：\n一阶导数为：\n$$\nu'(x) = -\\left(-\\frac{1}{\\delta}\\right)\\exp\\left(-\\frac{x}{\\delta}\\right) = \\frac{1}{\\delta}\\exp\\left(-\\frac{x}{\\delta}\\right)\n$$\n二阶导数为：\n$$\nu''(x) = \\frac{1}{\\delta}\\left(-\\frac{1}{\\delta}\\right)\\exp\\left(-\\frac{x}{\\delta}\\right) = -\\frac{1}{\\delta^2}\\exp\\left(-\\frac{x}{\\delta}\\right)\n$$\n\n这些关于 $\\phi''(x)$ 和 $u''(x)$ 的解析表达式在每个网格单元 $i$ 的中点 $x_i$ 处进行计算，以求得局部误差指示器。\n\n**2. 网格数据结构**\n\n一维网格是定义域 $[0,1]$ 的一个剖分，表示为一个按空间坐标排序的单元列表。每个单元是一个数据结构，存储三个关键属性：其起始坐标、结束坐标和加密等级。由 $N_0$ 个均匀单元组成的初始网格被定义为等级 $0$。当一个单元被二等分（加密）时，其两个子单元的等级比其父单元高一级。当两个单元被合并（粗化）时，得到的单个单元的等级比其父单元低一级。\n\n**3. AMR算法**\n\nAMR过程以循环方式执行，每次循环构成一次迭代。设迭代计数器为 $k$，从 $k=0$ 的初始网格开始。该循环最多执行 $\\mathrm{max\\_iters}$ 次迭代。\n\n**3.1. 初始状态 ($k = 0$)**\n算法开始时生成一个由 $N_0$ 个单元组成的初始均匀网格，每个单元的尺寸为 $h = 1/N_0$，加密等级为 $0$。\n\n**3.2. 迭代循环 ($k = 0, 1, \\dots, \\mathrm{max\\_iters}$)**\n在每次迭代中，执行以下操作序列。\n\n**步骤A：误差估计与终止检查**\n对于当前网格，评估误差。对于每个尺寸为 $h_i$、中点为 $x_i$ 的单元 $i$：\n使用指定的权重因子 $\\alpha=1$ 和 $\\beta=1$ 计算局部误差指示器的平方：\n$$\n\\eta_{\\phi,i}^2 = h_i^2 \\, \\left|\\phi''(x_i)\\right|^2, \\quad \\eta_{u,i}^2 = h_i^2 \\, \\left|u''(x_i)\\right|^2\n$$\n组合的局部指示器平方为 $\\eta_i^2 = \\eta_{\\phi,i}^2 + \\eta_{u,i}^2$。\n全局能量估计器范数是这些指示器平方和的平方根：\n$$\n\\mathcal{E} = \\left(\\sum_{i} \\eta_i^2\\right)^{1/2}\n$$\n算法首先检查终止条件。如果 $\\mathcal{E} \\le \\mathrm{tol}$，则解已收敛，并返回已执行的迭代次数 $k$。如果 $k$ 已达到 $\\mathrm{max\\_iters}$ 但容差未满足，则循环终止，并返回一个失败代码。\n\n**步骤B：单元标记**\n如果未满足终止条件，则标记单元进行自适应：\n- **加密标记（Dörfler策略）**：标记一个最小的单元集 $\\mathcal{M}_\\mathrm{ref}$ 进行加密。这是通过将单元按其指示器平方 $\\eta_i^2$ 降序排序，并从列表顶部选择单元，直到它们的累积贡献达到总误差平方 $\\sum_j \\eta_j^2$ 的至少 $\\theta$ 分数。\n$$ \\sum_{i \\in \\mathcal{M}_\\mathrm{ref}} \\eta_i^2 \\ge \\theta \\sum_j \\eta_j^2 $$\n- **粗化标记**：如果一个单元 $i$ 的误差指示器 $\\eta_i$ 相对于所有指示器的算术平均值 $\\overline{\\eta} = \\frac{1}{N}\\sum_j \\eta_j$ 较小，则标记该单元进行粗化。确切条件是 $\\eta_i < \\kappa \\, \\overline{\\eta}$，并附加约束条件，即该单元的加密等级必须大于 $0$，因为基础网格（等级 $0$）不能再粗化。\n\n**步骤C：网格自适应（加密和粗化）**\n根据标记从旧网格构建一个新网格。对排序后的单元进行一次从左到右的遍历，以确保确定性的结果：\n1.  对于每个可能的连续单元对 $(i, i+1)$，检查它们是否都被标记为粗化且处于相同的加密等级。如果是，则将它们合并成一个新的单元，该单元跨越它们的组合区间，加密等级减一。\n2.  如果一个单元 $i$ 不属于被粗化的对，则检查它是否在标记为加密的单元集 $\\mathcal{M}_\\mathrm{ref}$ 中。如果在此集合中，则将该单元二等分为两个大小相等的新子单元。它们的加密等级加一。\n3.  既未被粗化也未被加密的单元被无修改地复制到新网格中。\n这种单次遍历策略优先考虑对任何给定单元的粗化，因为对一对单元的粗化检查在对单个单元的加密检查之前执行。\n\n**步骤D：网格再平衡**\n在主要的自适应步骤之后，对网格进行再平衡，以强制实施相邻单元尺寸的几何约束。这是一个迭代过程：\n1.  启动一个循环，只要在一次遍历中发生了再平衡操作，该循环就继续。\n2.  在每次遍历中，检查所有相邻的单元对。如果它们的尺寸比 $h_\\mathrm{large}/h_\\mathrm{small}$ 超过参数 $r$，则将较大的单元标记为二等分。\n3.  如果在遍历期间有任何单元被标记，则构建一个新网格，其中所有被标记的单元都被二等分。这个新网格成为再平衡循环下一次遍历的输入。\n4.  如果一次完整的遍历完成而没有任何单元被标记为加密，则认为网格已再平衡，再平衡循环终止。\n\n**3.3. 最终结果**\n再平衡步骤后，当前AMR迭代 $k$ 完成。算法进入下一次迭代 $k+1$。如果循环执行到 $k = \\mathrm{max\\_iters}$ 且最终误差检查失败，则结果为 $-1$，表示未能收敛。",
            "answer": "```python\nimport numpy as np\nfrom collections import namedtuple\n\n# Define an element data structure for the mesh\nElement = namedtuple('Element', ['start', 'end', 'level'])\n\n# Analytical second derivatives\ndef phi_double_prime(x, x0, epsilon):\n    \"\"\"Computes the second derivative of the phi(x) field.\"\"\"\n    z = (x - x0) / (np.sqrt(2) * epsilon)\n    # Use np.tanh and np.cosh for numerical stability and vectorization\n    tanh_z = np.tanh(z)\n    cosh_z = np.cosh(z)\n    # sech^2(z) = 1/cosh^2(z)\n    sech_z_sq = 1.0 / (cosh_z**2)\n    return -(1.0 / epsilon**2) * sech_z_sq * tanh_z\n\ndef u_double_prime(x, delta):\n    \"\"\"Computes the second derivative of the u(x) field.\"\"\"\n    return -(1.0 / delta**2) * np.exp(-x / delta)\n\ndef run_amr_case(epsilon, delta, theta, kappa, r, N0, tol, max_iters):\n    \"\"\"\n    Executes the full AMR loop for a single test case.\n    \"\"\"\n    # 1. Initialization\n    x_bounds = np.linspace(0.0, 1.0, N0 + 1)\n    mesh = [Element(start=x_bounds[i], end=x_bounds[i+1], level=0) for i in range(N0)]\n    x0 = 0.5\n    alpha = 1.0\n    beta = 1.0\n\n    # 2. Iteration Loop\n    for k in range(max_iters + 1):\n        # Step A: Error Estimation and Termination Check\n        num_elements = len(mesh)\n        indicators = np.zeros(num_elements)\n        squared_indicators = np.zeros(num_elements)\n\n        for i, elem in enumerate(mesh):\n            h_i = elem.end - elem.start\n            x_i = (elem.start + elem.end) / 2.0\n            \n            p_dd = phi_double_prime(x_i, x0, epsilon)\n            u_dd = u_double_prime(x_i, delta)\n            \n            eta_phi_sq = alpha * h_i**2 * p_dd**2\n            eta_u_sq = beta * h_i**2 * u_dd**2\n            \n            eta_i_sq = eta_phi_sq + eta_u_sq\n            squared_indicators[i] = eta_i_sq\n            indicators[i] = np.sqrt(eta_i_sq)\n\n        global_error_sq = np.sum(squared_indicators)\n        global_error = np.sqrt(global_error_sq)\n\n        if global_error <= tol:\n            return k\n\n        if k == max_iters:\n            break\n\n        # Step B: Element Marking\n        # Refinement (Dörfler marking)\n        ref_marked_indices = set()\n        target_error_sum_sq = theta * global_error_sq\n        sorted_indices = np.argsort(squared_indicators)[::-1]\n        \n        current_sum_sq = 0.0\n        for idx in sorted_indices:\n            current_sum_sq += squared_indicators[idx]\n            ref_marked_indices.add(idx)\n            if current_sum_sq >= target_error_sum_sq:\n                break\n\n        # Coarsening\n        coarsen_marked_indices = set()\n        if num_elements > 0:\n            mean_eta = np.mean(indicators)\n            coarsen_threshold = kappa * mean_eta\n            for i, eta_i in enumerate(indicators):\n                if eta_i < coarsen_threshold and mesh[i].level > 0:\n                    coarsen_marked_indices.add(i)\n\n        # Step C: Mesh Adaptation (Refine and Coarsen)\n        new_mesh = []\n        i = 0\n        while i < num_elements:\n            can_coarsen_pair = False\n            if i < num_elements - 1:\n                elem1 = mesh[i]\n                elem2 = mesh[i+1]\n                if i in coarsen_marked_indices and (i+1) in coarsen_marked_indices and elem1.level == elem2.level:\n                    can_coarsen_pair = True\n\n            if can_coarsen_pair:\n                elem1, elem2 = mesh[i], mesh[i+1]\n                new_mesh.append(Element(start=elem1.start, end=elem2.end, level=elem1.level - 1))\n                i += 2\n            elif i in ref_marked_indices:\n                elem = mesh[i]\n                mid = (elem.start + elem.end) / 2.0\n                new_mesh.append(Element(start=elem.start, end=mid, level=elem.level + 1))\n                new_mesh.append(Element(start=mid, end=elem.end, level=elem.level + 1))\n                i += 1\n            else:\n                new_mesh.append(mesh[i])\n                i += 1\n        mesh = new_mesh\n\n        # Step D: Mesh Rebalancing\n        while True:\n            rebalance_refine_indices = set()\n            for i in range(len(mesh) - 1):\n                h1 = mesh[i].end - mesh[i].start\n                h2 = mesh[i+1].end - mesh[i+1].start\n                if h2 > 1e-12 and h1 / h2 > r:\n                    rebalance_refine_indices.add(i)\n                if h1 > 1e-12 and h2 / h1 > r:\n                    rebalance_refine_indices.add(i+1)\n            \n            if not rebalance_refine_indices:\n                break\n                \n            rebalanced_mesh = []\n            for i, elem in enumerate(mesh):\n                if i in rebalance_refine_indices:\n                    mid = (elem.start + elem.end) / 2.0\n                    rebalanced_mesh.append(Element(start=elem.start, end=mid, level=elem.level + 1))\n                    rebalanced_mesh.append(Element(start=mid, end=elem.end, level=elem.level + 1))\n                else:\n                    rebalanced_mesh.append(elem)\n            mesh = rebalanced_mesh\n\n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (epsilon, delta, theta, kappa, r, N0, tol, max_iters)\n        (0.02, 0.05, 0.5, 0.3, 3.0, 16, 0.01, 20),      # Case A\n        (0.005, 0.05, 0.4, 0.25, 4.0, 8, 0.005, 50),     # Case B\n        (0.05, 0.2, 0.6, 0.5, 2.5, 12, 0.02, 15),      # Case C\n        (0.01, 0.01, 0.7, 0.2, 3.0, 6, 0.001, 10),      # Case D\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_amr_case(*params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}