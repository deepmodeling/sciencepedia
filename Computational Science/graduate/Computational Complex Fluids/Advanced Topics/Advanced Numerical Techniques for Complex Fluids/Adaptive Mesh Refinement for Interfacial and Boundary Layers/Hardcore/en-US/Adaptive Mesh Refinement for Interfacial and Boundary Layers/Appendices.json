{
    "hands_on_practices": [
        {
            "introduction": "Before launching computationally intensive simulations, it is crucial to estimate the required resources. This practice provides a foundational exercise in Adaptive Mesh Refinement (AMR) cost analysis, demonstrating how to derive a leading-order estimate for the number of refined grid blocks needed to resolve a sharp interface. By connecting the physical geometry of the interface to the parameters of the AMR hierarchy, you will develop a scaling law that is essential for predicting memory usage and computational load as resolution increases .",
            "id": "4078652",
            "problem": "In a $2$-dimensional block-structured adaptive mesh refinement (Adaptive Mesh Refinement (AMR)) simulation of a complex fluid with a sharp material interface, consider a smooth interfacial curve of total arc length $L$ embedded in a domain where a refinement band of half-width $w$ (measured in physical space) is maintained symmetrically around the interface at refinement level $\\ell$. The AMR uses square blocks: at level $\\ell$, each block is a square of side length $s_{\\ell}$ in physical units, related to a level-$0$ block side length $s_{0}$ by $s_{\\ell} = s_{0} \\, r^{-\\ell}$, where $r > 1$ is the refinement ratio (i.e., each refinement level reduces the linear scale by a factor of $r$). Assume the following:\n- The interfacial curve is smooth with minimum radius of curvature everywhere much larger than $w$, so that the tubular neighborhood of half-width $w$ around the interface does not self-overlap.\n- The band is thin in the sense $w \\ll L$, and boundary and end effects are negligible at leading order when estimating counts.\n- Blocks are placed so that overlap and packing inefficiencies can be neglected at leading order when estimating counts.\n\nStarting from basic geometric measure considerations and the scaling of block areas with refinement level, derive a leading-order estimate for the number of level-$\\ell$ blocks required to cover the refinement band. Express your final answer as a single closed-form analytic expression in terms of $L$, $w$, $r$, $\\ell$, and $s_{0}$. No numerical evaluation is required, and no rounding is needed. The final answer must be a single expression.",
            "solution": "The problem statement has been validated and is deemed to be scientifically grounded, well-posed, objective, and internally consistent. It presents a standard problem in the analysis of computational methods, specifically concerning the estimation of computational resources for adaptive mesh refinement (AMR) techniques applied to interfacial phenomena. All provided data and assumptions are sufficient and appropriate for deriving a leading-order estimate as requested.\n\nThe task is to derive a leading-order estimate for the number of level-$\\ell$ blocks, denoted as $N_{\\ell}$, required to cover a specified refinement band around a material interface. The approach will be based on fundamental geometric principles, specifically by relating the total area of the region to be refined to the area of a single computational block at the specified refinement level.\n\nFirst, let us define the area of the refinement band, $A_{band}$. The problem states that a refinement band of half-width $w$ is maintained symmetrically around an interfacial curve of total arc length $L$. This forms a tubular neighborhood around the curve. The total width of the band is therefore $2w$. The problem provides several crucial simplifying assumptions: the interfacial curve is smooth, its minimum radius of curvature is much larger than $w$, and $w \\ll L$. These assumptions allow us to approximate the area of the band by neglecting curvature effects. To a leading-order approximation, the area of this thin tubular neighborhood is the product of the curve's arc length and the band's total width. This is equivalent to \"unrolling\" the curve into a straight line of length $L$ and calculating the area of the surrounding rectangle of width $2w$.\nTherefore, the area of the refinement band is given by:\n$$\nA_{band} = L \\times (2w) = 2Lw\n$$\n\nNext, we determine the area of a single computational block at refinement level $\\ell$, which we denote as $A_{block, \\ell}$. The problem specifies that the AMR utilizes square blocks. The side length of a block at level $\\ell$, denoted $s_{\\ell}$, is related to the side length of a level-$0$ block, $s_{0}$, and the refinement ratio, $r$, by the scaling law:\n$$\ns_{\\ell} = s_{0} \\, r^{-\\ell}\n$$\nSince the blocks are square, the area of a single level-$\\ell$ block is the square of its side length:\n$$\nA_{block, \\ell} = s_{\\ell}^2 = (s_{0} \\, r^{-\\ell})^2 = s_{0}^2 \\, r^{-2\\ell}\n$$\n\nFinally, we can estimate the number of level-$\\ell$ blocks, $N_{\\ell}$, required to cover the entire refinement band. The problem states that overlap and packing inefficiencies can be neglected at the leading order. This key simplification implies that the total number of blocks can be estimated by dividing the total area of the band by the area of a single block.\n$$\nN_{\\ell} \\approx \\frac{A_{band}}{A_{block, \\ell}}\n$$\nSubstituting the expressions for $A_{band}$ and $A_{block, \\ell}$ that we derived:\n$$\nN_{\\ell} = \\frac{2Lw}{s_{0}^2 \\, r^{-2\\ell}}\n$$\nBy simplifying the expression, we move the term with the negative exponent from the denominator to the numerator:\n$$\nN_{\\ell} = 2Lw s_{0}^{-2} r^{2\\ell}\n$$\nThis can be written more clearly as a fraction:\n$$\nN_{\\ell} = \\frac{2Lw r^{2\\ell}}{s_{0}^2}\n$$\nThis expression provides the leading-order estimate for the number of level-$\\ell$ blocks. It is a closed-form analytic expression in terms of the given parameters $L$, $w$, $r$, $\\ell$, and $s_{0}$, as required by the problem statement.",
            "answer": "$$\n\\boxed{\\frac{2Lw r^{2\\ell}}{s_{0}^2}}\n$$"
        },
        {
            "introduction": "Adaptive Mesh Refinement is not just about increasing resolution, but about strategically applying it to control numerical errors. This exercise tackles one of the most common artifacts in multiphase flow simulations: non-physical spurious currents generated at numerically represented interfaces. You will first derive a scaling law that relates the magnitude of these currents to physical and numerical parameters, and then use this insight to design an algorithm that automatically selects the refinement level needed to suppress this error below a given tolerance .",
            "id": "4078610",
            "problem": "Consider a quiescent, incompressible two-phase fluid containing a single circular or spherical droplet of radius $R$ in the absence of gravity. The governing equations for a Newtonian fluid are the incompressible Navier–Stokes equations, which, in the steady limit and for low Reynolds number, reduce to the Stokes balance $-\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f}_{\\sigma} = \\mathbf{0}$ with $\\nabla \\cdot \\mathbf{u} = 0$, where $\\mu$ is the dynamic viscosity, $\\mathbf{u}$ is the velocity field, $p$ is the pressure field, and $\\mathbf{f}_{\\sigma}$ is the volumetric capillary force. For a static droplet, the exact physical solution is $\\mathbf{u} = \\mathbf{0}$, and the pressure jump across the interface obeys the Laplace law. In numerical methods that approximate surface tension through a volumetric force (such as the Continuum Surface Force formulation), errors in the discretized curvature produce a residual capillary imbalance that drives nonzero velocities known as spurious currents localized in an interfacial numerical boundary layer. Adaptive Mesh Refinement (AMR) can reduce these currents by decreasing the local grid size near the interface.\n\nStarting from the Stokes balance and the Laplace law, and modeling the curvature discretization error at the interface as having order $p$ with grid size $\\Delta x$ and characteristic geometric scale $R$, derive a scaling expression for the peak spurious velocity $u_{\\max}$ in terms of $\\sigma$, $\\mu$, $R$, $\\Delta x$, and $p$, up to an order-one calibration constant. Use this scaling to design an algorithm that selects the minimum AMR refinement level $\\ell$ required to ensure $u_{\\max} \\le \\varepsilon_{u}$, where $\\varepsilon_{u}$ is a prescribed tolerance on the velocity magnitude. Assume a refinement ratio $r > 1$ between successive AMR levels, so the local interfacial grid size after $\\ell$ levels is $\\Delta x_{\\ell} = \\Delta x_{0} / r^{\\ell}$, with $\\Delta x_{0}$ the base grid spacing. The calibration constant for the velocity scaling, denoted $C_{u}$, is treated as given for each test case and encapsulates geometry and scheme-dependent factors.\n\nYour program must:\n- Implement the derived scaling using $u_{\\max}(\\ell)$ expressed through $\\Delta x_{\\ell}$, and compute the smallest integer $\\ell \\ge 0$ satisfying $u_{\\max}(\\ell) \\le \\varepsilon_{u}$.\n- If the required $\\ell$ exceeds a specified maximum allowed level $\\ell_{\\max}$, return the integer $-1$ for that case.\n- If $r \\le 1$ or $p \\le 0$ are provided, treat the case as invalid and return the integer $-1$.\n- All physical quantities must be handled with units consistent with the International System of Units: surface tension in $\\mathrm{N/m}$, viscosity in $\\mathrm{Pa\\cdot s}$, lengths in $\\mathrm{m}$, and velocities in $\\mathrm{m/s}$. The output itself is a unitless integer refinement level.\n\nUse the following test suite, each test case specified as the tuple $(\\sigma,\\mu,R,\\Delta x_{0},r,p,C_{u},\\varepsilon_{u},\\ell_{\\max})$ with values and units:\n- Test $1$ (happy path, moderate viscosity, second-order curvature, refinement ratio two): $(\\sigma = 0.072\\,\\mathrm{N/m},\\ \\mu = 0.001\\,\\mathrm{Pa\\cdot s},\\ R = 0.001\\,\\mathrm{m},\\ \\Delta x_{0} = 0.0002\\,\\mathrm{m},\\ r = 2,\\ p = 2,\\ C_{u} = 1.0\\times 10^{-4},\\ \\varepsilon_{u} = 1.0\\times 10^{-6}\\,\\mathrm{m/s},\\ \\ell_{\\max} = 6)$.\n- Test $2$ (edge case, high viscosity already below tolerance): $(\\sigma = 0.072\\,\\mathrm{N/m},\\ \\mu = 0.1\\,\\mathrm{Pa\\cdot s},\\ R = 0.001\\,\\mathrm{m},\\ \\Delta x_{0} = 0.0002\\,\\mathrm{m},\\ r = 2,\\ p = 2,\\ C_{u} = 1.0\\times 10^{-4},\\ \\varepsilon_{u} = 5.0\\times 10^{-6}\\,\\mathrm{m/s},\\ \\ell_{\\max} = 6)$.\n- Test $3$ (failure case due to low viscosity and limited allowed levels): $(\\sigma = 0.072\\,\\mathrm{N/m},\\ \\mu = 5.0\\times 10^{-4}\\,\\mathrm{Pa\\cdot s},\\ R = 0.001\\,\\mathrm{m},\\ \\Delta x_{0} = 0.0002\\,\\mathrm{m},\\ r = 2,\\ p = 2,\\ C_{u} = 1.0\\times 10^{-4},\\ \\varepsilon_{u} = 1.0\\times 10^{-6}\\,\\mathrm{m/s},\\ \\ell_{\\max} = 4)$.\n- Test $4$ (different refinement ratio and first-order curvature error): $(\\sigma = 0.02\\,\\mathrm{N/m},\\ \\mu = 0.005\\,\\mathrm{Pa\\cdot s},\\ R = 0.002\\,\\mathrm{m},\\ \\Delta x_{0} = 0.0003\\,\\mathrm{m},\\ r = 3,\\ p = 1,\\ C_{u} = 5.0\\times 10^{-5},\\ \\varepsilon_{u} = 2.0\\times 10^{-7}\\,\\mathrm{m/s},\\ \\ell_{\\max} = 6)$.\n\nYour program should produce a single line of output containing the integer refinement levels for the four test cases, as a comma-separated list enclosed in square brackets with no spaces, for example $[l_{1},l_{2},l_{3},l_{4}]$. If a case is invalid or cannot meet the tolerance within the allowed refinement levels, use the integer $-1$ in its position. No other output is permitted.",
            "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It describes a canonical problem in computational multiphase flow—the generation of non-physical spurious currents at a numerically represented fluid interface—and asks for a quantitative analysis to control these currents using Adaptive Mesh Refinement (AMR). All necessary physical parameters, numerical scheme characteristics, and constraints are provided. The problem is therefore deemed valid and a solution can be constructed.\n\nThe task is to first derive a scaling law for the maximum spurious velocity, $u_{\\max}$, and then use this law to determine the minimum AMR level, $\\ell$, required to keep this velocity below a specified tolerance, $\\varepsilon_{u}$.\n\n### Part 1: Derivation of the Spurious Velocity Scaling Law\n\nWe begin with the governing equations for a quiescent, incompressible Newtonian fluid at steady state and low Reynolds number, given by the Stokes balance:\n$$-\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f}_{\\sigma} = \\mathbf{0}$$\nsubject to the incompressibility constraint $\\nabla \\cdot \\mathbf{u} = 0$. Here, $p$ is the pressure, $\\mathbf{u}$ is the velocity, $\\mu$ is the dynamic viscosity, and $\\mathbf{f}_{\\sigma}$ is the volumetric surface tension force.\n\nIn an exact continuum description of a static spherical or circular droplet of radius $R$, the velocity field is identically zero, $\\mathbf{u} = \\mathbf{0}$. The Stokes equation reduces to a hydrostatic balance, $-\\nabla p + \\mathbf{f}_{\\sigma} = \\mathbf{0}$, where $\\mathbf{f}_{\\sigma}$ is a singular force concentrated exactly at the interface. This balance results in the Laplace law for the pressure jump across the interface, $\\Delta p = \\sigma \\kappa$, where $\\sigma$ is the surface tension and $\\kappa$ is the interface curvature ($\\kappa = (d-1)/R$ for a $d$-dimensional sphere/circle).\n\nIn numerical simulations using a Continuum Surface Force (CSF) approach, the singular surface force is approximated by a regularized volumetric force, $\\mathbf{f}_{\\sigma} \\approx \\sigma \\kappa_h \\mathbf{n}_h \\delta_h$, where $\\kappa_h$ and $\\mathbf{n}_h$ are the numerically computed curvature and interface normal, and $\\delta_h$ is a discrete delta function that spreads the force over a region of thickness proportional to the grid spacing, $\\Delta x$. Discretization errors, primarily in the calculation of curvature $\\kappa_h$, create a localized residual force that is not perfectly balanced by the discrete pressure gradient. This residual force drives the non-physical spurious currents, $\\mathbf{u}$.\n\nThe problem states that the error in the curvature calculation is of order $p$, i.e., the error magnitude scales as $(\\Delta x)^p$. We can model this error by considering the relevant physical scales. The curvature $\\kappa$ has units of inverse length, with characteristic scale $R$. A dimensionless measure of the grid resolution is $\\Delta x/R$. The error in curvature is commonly scaled as a dimensionless error term multiplied by a dimensional factor. A physically consistent model for the total unbalanced force, $F_{err}$, acting on the droplet interface due to this curvature error is to balance it against the total viscous drag force, $F_{visc}$, it generates.\n\n1.  **Unbalanced Capillary Force ($F_{err}$)**: The error in the capillary force is driven by the error in the curvature. The total force is proportional to surface tension $\\sigma$, a characteristic length (the droplet radius $R$), and a dimensionless error term. The problem states the curvature discretization error is of order $p$. Thus, the dimensionless numerical error can be modeled as $(\\Delta x/R)^p$.\n    $$F_{err} \\propto \\sigma \\cdot R \\cdot \\left( \\frac{\\Delta x}{R} \\right)^p$$\n\n2.  **Viscous Drag Force ($F_{visc}$)**: The spurious flow field $\\mathbf{u}$ is driven by $F_{err}$. This flow, in turn, creates a viscous drag force on the droplet. For low Reynolds number flow around a sphere, the Stokes drag is proportional to the viscosity $\\mu$, the characteristic velocity $u_{\\max}$, and the radius $R$.\n    $$F_{visc} \\propto \\mu u_{\\max} R$$\n\n3.  **Force Balance**: At steady state, these two forces must balance each other.\n    $$F_{visc} \\approx F_{err}$$\n    $$\\mu u_{\\max} R \\propto \\sigma R \\left( \\frac{\\Delta x}{R} \\right)^p$$\n\n4.  **Scaling for $u_{\\max}$**: Solving for $u_{\\max}$ yields the scaling law:\n    $$u_{\\max} \\propto \\frac{\\sigma}{\\mu} \\left( \\frac{\\Delta x}{R} \\right)^p$$\nIntroducing the provided order-one calibration constant $C_u$ to account for scheme-specific and geometric factors, we obtain the final scaling expression:\n$$u_{\\max} = C_u \\frac{\\sigma}{\\mu} \\left( \\frac{\\Delta x}{R} \\right)^p$$\nThis expression correctly captures the expected physical dependencies: $u_{\\max}$ increases with surface tension $\\sigma$ (the driving force) and decreases with viscosity $\\mu$ (the dissipative force), droplet radius $R$, and the order of accuracy $p$.\n\n### Part 2: Algorithm for AMR Level Selection\n\nThe goal is to find the minimum integer AMR level $\\ell \\ge 0$ such that the spurious velocity is controlled, $u_{\\max}(\\ell) \\le \\varepsilon_{u}$, given a maximum level $\\ell_{\\max}$.\n\nThe grid size at refinement level $\\ell$ is given by $\\Delta x_{\\ell} = \\Delta x_0 / r^{\\ell}$, where $\\Delta x_0$ is the base grid spacing and $r > 1$ is the refinement ratio. Substituting $\\Delta x_{\\ell}$ into our scaling law:\n$$u_{\\max}(\\ell) = C_u \\frac{\\sigma}{\\mu} \\left( \\frac{\\Delta x_0 / r^{\\ell}}{R} \\right)^p = C_u \\frac{\\sigma}{\\mu} \\left( \\frac{\\Delta x_0}{R} \\right)^p r^{-p\\ell}$$\nLet's define the spurious velocity at the base level ($\\ell=0$) as:\n$$u_{\\max}(0) = C_u \\frac{\\sigma}{\\mu} \\left( \\frac{\\Delta x_0}{R} \\right)^p$$\nThen, the velocity at level $\\ell$ is simply $u_{\\max}(\\ell) = u_{\\max}(0) r^{-p\\ell}$.\n\nThe algorithm proceeds as follows:\n\n1.  **Validate Inputs**: Check if the refinement ratio $r > 1$ and the convergence order $p > 0$. If not, the refinement process is ill-defined or non-convergent, so the case is invalid. Return $-1$.\n\n2.  **Check Base Level**: Calculate $u_{\\max}(0)$. If $u_{\\max}(0) \\le \\varepsilon_{u}$, no refinement is necessary. The required level is $\\ell=0$.\n\n3.  **Solve for $\\ell$**: If $u_{\\max}(0) > \\varepsilon_{u}$, we must find the smallest integer $\\ell \\ge 1$ that satisfies the tolerance.\n    $$u_{\\max}(0) r^{-p\\ell} \\le \\varepsilon_u$$\n    Rearranging the inequality:\n    $$r^{-p\\ell} \\le \\frac{\\varepsilon_u}{u_{\\max}(0)}$$\n    Taking the natural logarithm of both sides. Since $r > 1$, $\\log r > 0$.\n    $$-p\\ell \\log r \\le \\log\\left(\\frac{\\varepsilon_u}{u_{\\max}(0)}\\right)$$\n    Multiplying by $-1$ reverses the inequality:\n    $$p\\ell \\log r \\ge -\\log\\left(\\frac{\\varepsilon_u}{u_{\\max}(0)}\\right) = \\log\\left(\\frac{u_{\\max}(0)}{\\varepsilon_u}\\right)$$\n    Isolating $\\ell$:\n    $$\\ell \\ge \\frac{\\log\\left(u_{\\max}(0) / \\varepsilon_u\\right)}{p \\log r}$$\n    Since $\\ell$ must be an integer, the minimum required level is the ceiling of this expression:\n    $$\\ell = \\left\\lceil \\frac{\\log\\left(u_{\\max}(0) / \\varepsilon_u\\right)}{p \\log r} \\right\\rceil$$\n\n4.  **Check Maximum Level**: Compare the calculated $\\ell$ with the maximum allowed level, $\\ell_{\\max}$. If $\\ell > \\ell_{\\max}$, the velocity tolerance cannot be achieved within the allowed number of refinements. Return $-1$.\n\n5.  **Return Result**: If the calculated $\\ell$ is valid and does not exceed $\\ell_{\\max}$, it is the required minimum refinement level. Return this integer value.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the minimum AMR refinement level to control spurious currents\n    based on a derived scaling law.\n    \"\"\"\n\n    # Test suite: (sigma, mu, R, dx0, r, p, Cu, eps_u, l_max)\n    test_cases = [\n        # Test 1: (happy path, moderate viscosity, second-order curvature, refinement ratio two)\n        (0.072, 0.001, 0.001, 0.0002, 2, 2, 1.0e-4, 1.0e-6, 6),\n        # Test 2: (edge case, high viscosity already below tolerance)\n        (0.072, 0.1, 0.001, 0.0002, 2, 2, 1.0e-4, 5.0e-6, 6),\n        # Test 3: (failure case due to low viscosity and limited allowed levels)\n        (0.072, 5.0e-4, 0.001, 0.0002, 2, 2, 1.0e-4, 1.0e-6, 4),\n        # Test 4: (different refinement ratio and first-order curvature error)\n        (0.02, 0.005, 0.002, 0.0003, 3, 1, 5.0e-5, 2.0e-7, 6),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_refinement_level(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_refinement_level(sigma, mu, R, dx0, r, p, Cu, eps_u, l_max):\n    \"\"\"\n    Computes the smallest integer AMR level l >= 0 for a single test case.\n\n    Args:\n        sigma (float): Surface tension (N/m).\n        mu (float): Dynamic viscosity (Pa.s).\n        R (float): Droplet radius (m).\n        dx0 (float): Base grid spacing (m).\n        r (float): Refinement ratio between AMR levels.\n        p (int): Order of curvature discretization error.\n        Cu (float): Calibration constant for velocity scaling.\n        eps_u (float): Prescribed tolerance on velocity magnitude (m/s).\n        l_max (int): Maximum allowed refinement level.\n\n    Returns:\n        int: The minimum required refinement level l. Returns -1 if the case\n             is invalid or the tolerance cannot be met.\n    \"\"\"\n    # Step 1: Validate Inputs\n    # If r <= 1, refinement is ineffective or divergent.\n    # If p <= 0, the scheme is non-convergent, refinement does not reduce error.\n    if r <= 1 or p <= 0:\n        return -1\n\n    # Step 2: Calculate spurious velocity at base level (l=0)\n    # u_max = C_u * (sigma / mu) * (dx / R)^p\n    try:\n        u_max_0 = Cu * (sigma / mu) * ((dx0 / R) ** p)\n    except (ZeroDivisionError, ValueError):\n        # Handle potential numerical issues with parameters, although not in test cases\n        return -1\n\n    # Step 3: Check if refinement is needed\n    if u_max_0 <= eps_u:\n        return 0\n\n    # Step 4: Solve for the required refinement level l\n    # l >= log(u_max(0) / eps_u) / (p * log(r))\n    # This must be true for the refinement to be effective. If the ratio u_max_0 / eps_u\n    # is <= 1, it means u_max_0 <= eps_u, which is already handled above. So no need for\n    # extra checks here. The argument to log will be > 1.\n    numerator = np.log(u_max_0 / eps_u)\n    denominator = p * np.log(r)\n    \n    # The denominator could be zero if r=1 or p=0, but this is already checked.\n    if denominator == 0:\n        return -1 # Should not happen due to prior checks\n\n    # Calculate the minimum floating-point l and take the ceiling\n    l_required = np.ceil(numerator / denominator)\n    l_required_int = int(l_required)\n\n    # Step 5: Check against the maximum allowed level\n    if l_required_int > l_max:\n        return -1\n    else:\n        return l_required_int\n\nsolve()\n```"
        },
        {
            "introduction": "Having explored cost estimation and a targeted application, we now turn to the heart of the adaptive process itself: the dynamic refinement-coarsening loop. This comprehensive practice guides you through the implementation of a complete one-dimensional AMR engine, from computing local error indicators to marking elements for adaptation and rebalancing the mesh for stability. By simulating this entire workflow, you will gain an integrated, procedural understanding of how an adaptive mesh autonomously evolves to concentrate computational effort where it is most needed .",
            "id": "4078680",
            "problem": "Consider an Adaptive Mesh Refinement (AMR) loop for a one-dimensional coupled system representative of interfacial and boundary layers in computational complex fluids. The spatial domain is $[0,1]$ and the coupled fields are defined by the dimensionless phase-field variable $\\phi(x)$ and the dimensionless velocity $u(x)$, chosen to capture an interface located near the center and a boundary layer near the left boundary, respectively. The functions are\n$$\n\\phi(x) = \\tanh\\left(\\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}\\right), \\quad u(x) = 1 - \\exp\\left(-\\frac{x}{\\delta}\\right),\n$$\nwhere $x_0 = 0.5$ is the interface location, $\\epsilon > 0$ is the interfacial thickness parameter, and $\\delta > 0$ is the boundary layer thickness parameter. The mesh consists of a partition of $[0,1]$ into elements (closed intervals) with lengths $h_i$.\n\nStarting from the fundamental definition that a residual-based energy norm estimator aggregates contributions from second spatial derivatives as a proxy for curvature-driven errors in $H^1$-type norms for diffusion-dominated processes, use the following modeling choices for local error indicators. For element $i$ with midpoint $x_i$ and size $h_i$, define\n$$\n\\eta_{\\phi,i}^2 = \\alpha \\, h_i^2 \\, \\left|\\phi''(x_i)\\right|^2, \\quad \\eta_{u,i}^2 = \\beta \\, h_i^2 \\, \\left|u''(x_i)\\right|^2,\n$$\nand the combined local indicator\n$$\n\\eta_i = \\sqrt{\\eta_{\\phi,i}^2 + \\eta_{u,i}^2}.\n$$\nTake $\\alpha = 1$ and $\\beta = 1$.\n\nDefine the global energy estimator norm\n$$\n\\mathcal{E} = \\left(\\sum_{i} \\eta_i^2\\right)^{1/2}.\n$$\n\nThe AMR loop proceeds as follows, using only deterministic, local operations on the mesh:\n- Compute $\\eta_i$ for all elements using the formulas above.\n- Mark elements for refinement using Dörfler marking with parameter $\\theta \\in (0,1)$: sort $\\eta_i^2$ in descending order and select a minimal subset $\\mathcal{M}_\\mathrm{ref}$ such that\n$$\n\\sum_{i \\in \\mathcal{M}_\\mathrm{ref}} \\eta_i^2 \\ge \\theta \\sum_j \\eta_j^2.\n$$\n- Mark elements for coarsening using a threshold $\\kappa \\in (0,1)$: define the arithmetic mean $\\overline{\\eta} = \\frac{1}{N}\\sum_i \\eta_i$ and mark an element $i$ for coarsening if $\\eta_i < \\kappa \\, \\overline{\\eta}$ and the element has refinement level greater than $0$.\n- Refine all elements in $\\mathcal{M}_\\mathrm{ref}$ by bisecting them into two elements of equal length.\n- Coarsen by merging consecutive pairs of marked elements that share the same refinement level; merging replaces the pair with a single element of the next coarser level spanning the union of the two intervals.\n- Rebalance the mesh to maintain neighbor size regularity by imposing a ratio constraint $r > 1$: if two adjacent elements have sizes $h_\\mathrm{large}$ and $h_\\mathrm{small}$ with $h_\\mathrm{large}/h_\\mathrm{small} > r$, bisect the larger element. Apply this rebalancing iteratively over neighbors until the constraint is satisfied across the mesh or no changes occur.\n\nTerminate the loop when the global energy estimator norm $\\mathcal{E}$ is less than or equal to a target tolerance $\\mathrm{tol} > 0$, or when a maximum number of iterations $\\mathrm{max\\_iters}$ is reached. The program must output, for each test case, the integer number of AMR iterations required to achieve $\\mathcal{E} \\le \\mathrm{tol}$, or the integer $-1$ if the tolerance is not met within the iteration limit.\n\nAll quantities are dimensionless.\n\nTest Suite:\nProvide the following parameter sets, where each test case is a tuple $(\\epsilon,\\delta,\\theta,\\kappa,r,N_0,\\mathrm{tol},\\mathrm{max\\_iters})$, with initial mesh having $N_0$ uniform elements over $[0,1]$.\n- Case A (general coupled sharp interface with moderate boundary layer): $(\\epsilon,\\delta,\\theta,\\kappa,r,N_0,\\mathrm{tol},\\mathrm{max\\_iters}) = (0.02, 0.05, 0.5, 0.3, 3.0, 16, 0.01, 20)$.\n- Case B (very sharp interface): $(\\epsilon,\\delta,\\theta,\\kappa,r,N_0,\\mathrm{tol},\\mathrm{max\\_iters}) = (0.005, 0.05, 0.4, 0.25, 4.0, 8, 0.005, 50)$.\n- Case C (diffuse interface and boundary layer): $(\\epsilon,\\delta,\\theta,\\kappa,r,N_0,\\mathrm{tol},\\mathrm{max\\_iters}) = (0.05, 0.2, 0.6, 0.5, 2.5, 12, 0.02, 15)$.\n- Case D (tight tolerance limit case): $(\\epsilon,\\delta,\\theta,\\kappa,r,N_0,\\mathrm{tol},\\mathrm{max\\_iters}) = (0.01, 0.01, 0.7, 0.2, 3.0, 6, 0.001, 10)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3,result4]$), in the same order as the test suite above. Each $result$ must be an integer as specified.",
            "solution": "The problem requires the implementation of an Adaptive Mesh Refinement (AMR) simulation for a one-dimensional coupled system. The solution methodology involves creating a deterministic algorithm that iteratively adapts a mesh based on a posteriori error indicators until a global error tolerance is achieved or a maximum number of iterations is exhausted.\n\nThe solution is constructed in the following steps:\n1.  Derivation of the analytical expressions for the second derivatives of the given fields, which serve as the basis for the error indicators.\n2.  Establishment of a data structure to represent the computational mesh.\n3.  Detailed specification of the AMR loop, including error estimation, marking, mesh adaptation (refinement/coarsening), and rebalancing.\n\n**1. Analytical Error Indicator Functions**\n\nThe error indicators are based on the second spatial derivatives of the phase-field variable $\\phi(x)$ and the velocity field $u(x)$.\n\nFor the phase-field variable $\\phi(x) = \\tanh\\left(\\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}\\right)$, let $z(x) = \\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}$. The first derivative with respect to $x$ is found using the chain rule:\n$$\n\\phi'(x) = \\frac{d}{dx}\\tanh(z) = \\text{sech}^2(z) \\cdot \\frac{dz}{dx} = \\frac{1}{\\sqrt{2}\\,\\epsilon} \\text{sech}^2\\left(\\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}\\right)\n$$\nThe second derivative is obtained by differentiating $\\phi'(x)$ again:\n$$\n\\phi''(x) = \\frac{1}{\\sqrt{2}\\,\\epsilon} \\cdot \\frac{d}{dx}\\text{sech}^2(z) = \\frac{1}{\\sqrt{2}\\,\\epsilon} \\left[ -2 \\text{sech}(z)\\tanh(z)\\text{sech}(z) \\cdot \\frac{dz}{dx} \\right] \\\\\n= \\frac{1}{\\sqrt{2}\\,\\epsilon} \\left[ -2 \\text{sech}^2(z)\\tanh(z) \\cdot \\frac{1}{\\sqrt{2}\\,\\epsilon} \\right] \\\\\n= -\\frac{1}{\\epsilon^2} \\text{sech}^2\\left(\\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}\\right) \\tanh\\left(\\frac{x - x_0}{\\sqrt{2}\\,\\epsilon}\\right)\n$$\n\nFor the velocity field $u(x) = 1 - \\exp\\left(-\\frac{x}{\\delta}\\right)$, the derivatives are more direct:\nThe first derivative is:\n$$\nu'(x) = -\\left(-\\frac{1}{\\delta}\\right)\\exp\\left(-\\frac{x}{\\delta}\\right) = \\frac{1}{\\delta}\\exp\\left(-\\frac{x}{\\delta}\\right)\n$$\nThe second derivative is:\n$$\nu''(x) = \\frac{1}{\\delta}\\left(-\\frac{1}{\\delta}\\right)\\exp\\left(-\\frac{x}{\\delta}\\right) = -\\frac{1}{\\delta^2}\\exp\\left(-\\frac{x}{\\delta}\\right)\n$$\n\nThese analytical expressions for $\\phi''(x)$ and $u''(x)$ are evaluated at the midpoint $x_i$ of each mesh element $i$ to compute the local error indicators.\n\n**2. Mesh Data Structure**\n\nThe one-dimensional mesh, which is a partition of the domain $[0,1]$, is represented as a list of elements, sorted by their spatial coordinates. Each element is a data structure storing three key properties: its start coordinate, its end coordinate, and its refinement level. The initial mesh of $N_0$ uniform elements is defined to be at level $0$. When an element is bisected (refined), its two children are assigned a level one greater than their parent. When two elements are merged (coarsened), the resulting single element is assigned a level one less than its parent elements.\n\n**3. AMR Algorithm**\n\nThe AMR process is executed as a loop, where each pass constitutes one iteration. Let the iteration counter be $k$, starting at $k=0$ with the initial mesh. The loop executes for a maximum of $\\mathrm{max\\_iters}$ iterations.\n\n**3.1. Initial State ($k = 0$)**\nThe algorithm begins by generating an initial uniform mesh consisting of $N_0$ elements, each of size $h = 1/N_0$ and refinement level $0$.\n\n**3.2. Iterative Loop ($k = 0, 1, \\dots, \\mathrm{max\\_iters}$)**\nWithin each iteration, the following sequence of operations is performed.\n\n**Step A: Error Estimation and Termination Check**\nFor the current mesh, the error is evaluated. For each element $i$ with size $h_i$ and midpoint $x_i$:\nThe squared local error indicators are computed using the specified weighting factors $\\alpha=1$ and $\\beta=1$:\n$$\n\\eta_{\\phi,i}^2 = h_i^2 \\, \\left|\\phi''(x_i)\\right|^2, \\quad \\eta_{u,i}^2 = h_i^2 \\, \\left|u''(x_i)\\right|^2\n$$\nThe combined squared local indicator is $\\eta_i^2 = \\eta_{\\phi,i}^2 + \\eta_{u,i}^2$.\nThe global energy estimator norm is the square root of the sum of these squared indicators:\n$$\n\\mathcal{E} = \\left(\\sum_{i} \\eta_i^2\\right)^{1/2}\n$$\nThe algorithm first checks for termination. If $\\mathcal{E} \\le \\mathrm{tol}$, the solution has converged, and the number of iterations performed, $k$, is returned. If $k$ has reached $\\mathrm{max\\_iters}$ and the tolerance is not met, the loop terminates, and a failure code is returned.\n\n**Step B: Element Marking**\nIf the termination conditions are not met, elements are marked for adaptation:\n- **Refinement Marking (Dörfler Strategy)**: A minimal set of elements $\\mathcal{M}_\\mathrm{ref}$ is marked for refinement. This is achieved by sorting the elements by their squared indicators $\\eta_i^2$ in descending order and selecting elements from the top of the list until their cumulative contribution to the total squared error, $\\sum_j \\eta_j^2$, is at least the fraction $\\theta$.\n$$ \\sum_{i \\in \\mathcal{M}_\\mathrm{ref}} \\eta_i^2 \\ge \\theta \\sum_j \\eta_j^2 $$\n- **Coarsening Marking**: An element $i$ is marked for coarsening if its error indicator $\\eta_i$ is small relative to the arithmetic mean of all indicators, $\\overline{\\eta} = \\frac{1}{N}\\sum_j \\eta_j$. The precise condition is $\\eta_i < \\kappa \\, \\overline{\\eta}$, with the additional constraint that the element's refinement level must be greater than $0$, as the base mesh (level $0$) cannot be coarsened further.\n\n**Step C: Mesh Adaptation (Refinement and Coarsening)**\nA new mesh is constructed from the old one based on the marking. A single left-to-right pass over the sorted elements ensures a deterministic outcome:\n1.  For each potential consecutive pair of elements $(i, i+1)$, a check is made to see if both are marked for coarsening and reside at the same refinement level. If so, they are merged into a single new element, spanning their combined interval, with a refinement level decremented by one.\n2.  If an element $i$ is not part of a coarsened pair, it is checked against the set of elements marked for refinement, $\\mathcal{M}_\\mathrm{ref}$. If it is in this set, the element is bisected into two new child elements of equal size. Their refinement level is incremented by one.\n3.  An element that is neither coarsened nor refined is copied to the new mesh without modification.\nThis single-pass strategy prioritizes coarsening over refinement for any given element, as the coarsening check on a pair is performed before the refinement check on an individual element.\n\n**Step D: Mesh Rebalancing**\nAfter the primary adaptation step, the mesh is rebalanced to enforce a geometric constraint on neighbor element sizes. This is an iterative process:\n1.  A loop is initiated that continues as long as a rebalancing operation occurs in a pass.\n2.  In each pass, all adjacent element pairs are examined. If the ratio of their sizes, $h_\\mathrm{large}/h_\\mathrm{small}$, exceeds the parameter $r$, the larger element is marked for bisection.\n3.  If any elements are marked during the pass, a new mesh is constructed where all marked elements are bisected. This new mesh becomes the input for the next pass of the rebalancing loop.\n4.  If a full pass completes with no elements marked for refinement, the mesh is considered rebalanced, and the rebalancing loop terminates.\n\n**3.3. Final Result**\nAfter the rebalancing step, the current AMR iteration $k$ is complete. The algorithm proceeds to the next iteration, $k+1$. If the loop completes up to $k = \\mathrm{max\\_iters}$ and the final error check fails, the result is $-1$, indicating failure to converge.",
            "answer": "```python\nimport numpy as np\nfrom collections import namedtuple\n\n# Define an element data structure for the mesh\nElement = namedtuple('Element', ['start', 'end', 'level'])\n\n# Analytical second derivatives\ndef phi_double_prime(x, x0, epsilon):\n    \"\"\"Computes the second derivative of the phi(x) field.\"\"\"\n    z = (x - x0) / (np.sqrt(2) * epsilon)\n    # Use np.tanh and np.cosh for numerical stability and vectorization\n    tanh_z = np.tanh(z)\n    cosh_z = np.cosh(z)\n    # sech^2(z) = 1/cosh^2(z)\n    sech_z_sq = 1.0 / (cosh_z**2)\n    return -(1.0 / epsilon**2) * sech_z_sq * tanh_z\n\ndef u_double_prime(x, delta):\n    \"\"\"Computes the second derivative of the u(x) field.\"\"\"\n    return -(1.0 / delta**2) * np.exp(-x / delta)\n\ndef run_amr_case(epsilon, delta, theta, kappa, r, N0, tol, max_iters):\n    \"\"\"\n    Executes the full AMR loop for a single test case.\n    \"\"\"\n    # 1. Initialization\n    x_bounds = np.linspace(0.0, 1.0, N0 + 1)\n    mesh = [Element(start=x_bounds[i], end=x_bounds[i+1], level=0) for i in range(N0)]\n    x0 = 0.5\n    alpha = 1.0\n    beta = 1.0\n\n    # 2. Iteration Loop\n    for k in range(max_iters + 1):\n        # Step A: Error Estimation and Termination Check\n        num_elements = len(mesh)\n        indicators = np.zeros(num_elements)\n        squared_indicators = np.zeros(num_elements)\n\n        for i, elem in enumerate(mesh):\n            h_i = elem.end - elem.start\n            x_i = (elem.start + elem.end) / 2.0\n            \n            p_dd = phi_double_prime(x_i, x0, epsilon)\n            u_dd = u_double_prime(x_i, delta)\n            \n            eta_phi_sq = alpha * h_i**2 * p_dd**2\n            eta_u_sq = beta * h_i**2 * u_dd**2\n            \n            eta_i_sq = eta_phi_sq + eta_u_sq\n            squared_indicators[i] = eta_i_sq\n            indicators[i] = np.sqrt(eta_i_sq)\n\n        global_error_sq = np.sum(squared_indicators)\n        global_error = np.sqrt(global_error_sq)\n\n        if global_error <= tol:\n            return k\n\n        if k == max_iters:\n            break\n\n        # Step B: Element Marking\n        # Refinement (Dörfler marking)\n        ref_marked_indices = set()\n        target_error_sum_sq = theta * global_error_sq\n        sorted_indices = np.argsort(squared_indicators)[::-1]\n        \n        current_sum_sq = 0.0\n        for idx in sorted_indices:\n            current_sum_sq += squared_indicators[idx]\n            ref_marked_indices.add(idx)\n            if current_sum_sq >= target_error_sum_sq:\n                break\n\n        # Coarsening\n        coarsen_marked_indices = set()\n        if num_elements > 0:\n            mean_eta = np.mean(indicators)\n            coarsen_threshold = kappa * mean_eta\n            for i, eta_i in enumerate(indicators):\n                if eta_i < coarsen_threshold and mesh[i].level > 0:\n                    coarsen_marked_indices.add(i)\n\n        # Step C: Mesh Adaptation (Refine and Coarsen)\n        new_mesh = []\n        i = 0\n        while i < num_elements:\n            can_coarsen_pair = False\n            if i < num_elements - 1:\n                elem1 = mesh[i]\n                elem2 = mesh[i+1]\n                if i in coarsen_marked_indices and (i+1) in coarsen_marked_indices and elem1.level == elem2.level:\n                    can_coarsen_pair = True\n\n            if can_coarsen_pair:\n                elem1, elem2 = mesh[i], mesh[i+1]\n                new_mesh.append(Element(start=elem1.start, end=elem2.end, level=elem1.level - 1))\n                i += 2\n            elif i in ref_marked_indices:\n                elem = mesh[i]\n                mid = (elem.start + elem.end) / 2.0\n                new_mesh.append(Element(start=elem.start, end=mid, level=elem.level + 1))\n                new_mesh.append(Element(start=mid, end=elem.end, level=elem.level + 1))\n                i += 1\n            else:\n                new_mesh.append(mesh[i])\n                i += 1\n        mesh = new_mesh\n\n        # Step D: Mesh Rebalancing\n        while True:\n            rebalance_refine_indices = set()\n            for i in range(len(mesh) - 1):\n                h1 = mesh[i].end - mesh[i].start\n                h2 = mesh[i+1].end - mesh[i+1].start\n                if h2 > 1e-12 and h1 / h2 > r:\n                    rebalance_refine_indices.add(i)\n                if h1 > 1e-12 and h2 / h1 > r:\n                    rebalance_refine_indices.add(i+1)\n            \n            if not rebalance_refine_indices:\n                break\n                \n            rebalanced_mesh = []\n            for i, elem in enumerate(mesh):\n                if i in rebalance_refine_indices:\n                    mid = (elem.start + elem.end) / 2.0\n                    rebalanced_mesh.append(Element(start=elem.start, end=mid, level=elem.level + 1))\n                    rebalanced_mesh.append(Element(start=mid, end=elem.end, level=elem.level + 1))\n                else:\n                    rebalanced_mesh.append(elem)\n            mesh = rebalanced_mesh\n\n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (epsilon, delta, theta, kappa, r, N0, tol, max_iters)\n        (0.02, 0.05, 0.5, 0.3, 3.0, 16, 0.01, 20),      # Case A\n        (0.005, 0.05, 0.4, 0.25, 4.0, 8, 0.005, 50),     # Case B\n        (0.05, 0.2, 0.6, 0.5, 2.5, 12, 0.02, 15),      # Case C\n        (0.01, 0.01, 0.7, 0.2, 3.0, 6, 0.001, 10),      # Case D\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_amr_case(*params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}