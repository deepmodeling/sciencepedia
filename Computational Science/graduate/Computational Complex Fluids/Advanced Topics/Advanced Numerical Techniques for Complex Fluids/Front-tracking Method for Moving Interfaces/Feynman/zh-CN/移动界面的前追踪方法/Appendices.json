{
    "hands_on_practices": [
        {
            "introduction": "界面追踪方法的核心在于拉格朗日界面与欧拉网格之间的相互作用。本练习将聚焦于这一相互作用的核心机制：如何将定义在界面上的力（例如表面张力）通过离散的狄拉克函数分布或“散开”到周围的网格节点上。掌握这个计算是模拟界面动力学的一个基本构建模块，它让你亲身体验从界面到流体的力传递过程。",
            "id": "4088769",
            "problem": "考虑一个在两相流三维界面追踪离散化中的单个三角形界面单元。该界面由拉格朗日单元表示，这些单元通过一个正则化的离散delta函数将表面张力密度分布到下方的欧拉网格上。界面上单位面积的表面张力由 $\\sigma \\kappa \\mathbf{n}$ 给出，其中 $\\sigma$ 是表面张力系数，$\\kappa$ 是平均曲率，$\\mathbf{n}$ 是单位法向量。在界面追踪方法中，由于单个形心位于位置 $\\mathbf{x}_e$、面积为 $A_e$ 的单元，在位于位置 $\\mathbf{x}_i$ 的网格节点上的欧拉力密度被建模为\n$$\n\\mathbf{f}(\\mathbf{x}_i) \\approx \\sigma \\kappa \\mathbf{n} \\, A_e \\, \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e).\n$$\n假设一个间距为 $h$ 的均匀笛卡尔网格，并使用浸入边界(IB)方法中推广的标准可分离正则化离散delta函数，\n$$\n\\delta_h(\\mathbf{r}) = \\frac{1}{h^3} \\, \\phi\\!\\left(\\frac{r_x}{h}\\right) \\, \\phi\\!\\left(\\frac{r_y}{h}\\right) \\, \\phi\\!\\left(\\frac{r_z}{h}\\right),\n$$\n其中 $\\mathbf{r} = (r_x,r_y,r_z)$，$\\phi$ 是由下式定义的四点一维核函数\n$$\n\\phi(r) =\n\\begin{cases}\n\\frac{1}{8}\\left(3 - 2|r| + \\sqrt{1 + 4|r| - 4 r^2}\\right), & |r| \\leq 1, \\\\\n\\frac{1}{8}\\left(5 - 2|r| - \\sqrt{-7 + 12|r| - 4 r^2}\\right), & 1  |r| \\leq 2, \\\\\n0,  |r|  2.\n\\end{cases}\n$$\n给定：\n- 表面张力系数 $\\sigma = 0.072$ $\\mathrm{N\\,m^{-1}}$，\n- 平均曲率 $\\kappa = 4.0 \\times 10^{3}$ $\\mathrm{m^{-1}}$，\n- 界面单位法向量 $\\mathbf{n} = \\frac{1}{\\sqrt{3}}(1,1,1)$，\n- 三角形单元面积 $A_e = 2.5 \\times 10^{-8}$ $\\mathrm{m^2}$，\n- 网格间距 $h = 1.0 \\times 10^{-3}$ $\\mathrm{m}$，\n- 单元形心 $\\mathbf{x}_e = (1.5 \\times 10^{-3},\\, 2.25 \\times 10^{-3},\\, 0.75 \\times 10^{-3})$ $\\mathrm{m}$，\n- 目标网格节点位置 $\\mathbf{x}_i = (2.0 \\times 10^{-3},\\, 2.0 \\times 10^{-3},\\, 1.0 \\times 10^{-3})$ $\\mathrm{m}$。\n\n使用形心积分近似和上述离散delta函数 $\\delta_h$，计算指定网格节点上离散表面张力密度的大小 $\\|\\mathbf{f}(\\mathbf{x}_i)\\|$。将您的最终数值答案四舍五入到四位有效数字。以 $\\mathrm{N\\,m^{-3}}$ 为单位表示您的最终答案。此外，从给定的物理定义和 $\\delta_h$ 的形式出发，根据第一性原理验证 $\\mathbf{f}$ 的量纲一致性。",
            "solution": "该问题要求计算在界面追踪模拟中特定网格节点上离散表面张力密度的大小。它还要求验证量纲一致性。\n\n### 步骤 1：提取给定条件\n- 网格节点 $\\mathbf{x}_i$ 处的欧拉力密度：$\\mathbf{f}(\\mathbf{x}_i) \\approx \\sigma \\kappa \\mathbf{n} \\, A_e \\, \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e)$\n- 表面张力系数：$\\sigma = 0.072 \\, \\mathrm{N\\,m^{-1}}$\n- 平均曲率：$\\kappa = 4.0 \\times 10^{3} \\, \\mathrm{m^{-1}}$\n- 界面单位法向量：$\\mathbf{n} = \\frac{1}{\\sqrt{3}}(1,1,1)$\n- 三角形单元面积：$A_e = 2.5 \\times 10^{-8} \\, \\mathrm{m^2}$\n- 网格间距：$h = 1.0 \\times 10^{-3} \\, \\mathrm{m}$\n- 单元形心位置：$\\mathbf{x}_e = (1.5 \\times 10^{-3},\\, 2.25 \\times 10^{-3},\\, 0.75 \\times 10^{-3}) \\, \\mathrm{m}$\n- 目标网格节点位置：$\\mathbf{x}_i = (2.0 \\times 10^{-3},\\, 2.0 \\times 10^{-3},\\, 1.0 \\times 10^{-3}) \\, \\mathrm{m}$\n- 正则化离散delta函数：$\\delta_h(\\mathbf{r}) = \\frac{1}{h^3} \\, \\phi\\!\\left(\\frac{r_x}{h}\\right) \\, \\phi\\!\\left(\\frac{r_y}{h}\\right) \\, \\phi\\!\\left(\\frac{r_z}{h}\\right)$\n- 一维核函数：$\\phi(r) =\n\\begin{cases}\n\\frac{1}{8}\\left(3 - 2|r| + \\sqrt{1 + 4|r| - 4 r^2}\\right),  |r| \\leq 1, \\\\\n\\frac{1}{8}\\left(5 - 2|r| - \\sqrt{-7 + 12|r| - 4 r^2}\\right),  1  |r| \\leq 2, \\\\\n0,  |r|  2.\n\\end{cases}$\n\n### 步骤 2：使用提取的给定条件进行验证\n该问题具有科学依据，是适定的，并且是客观的。\n- **科学依据：** 该公式是界面追踪和浸入边界方法背景下表面张力的标准表示，这些方法在计算流体动力学中广泛用于多相流。力密度和离散delta函数的方程直接取自已有的文献（例如，Peskin, 2002）。\n- **适定性：** 所有必要的参数和函数形式都已提供。该问题要求基于这些输入进行特定的数值计算，这会导向一个唯一的解。\n- **客观性：** 问题陈述是定量的，没有主观或含糊的语言。\n\n该问题没有表现出验证标准中列出的任何缺陷。所提供的数据是自洽的，并且对于微流体模拟是现实的。\n\n### 步骤 3：结论与行动\n该问题是有效的。将提供一个完整的解。\n\n### 量纲一致性验证\n问题要求验证力密度 $\\mathbf{f}(\\mathbf{x}_i)$ 的量纲一致性。令 $[X]$ 表示物理量 $X$ 以质量($M$)、长度($L$)和时间($T$)表示的量纲。\n表面张力系数 $\\sigma$ 是单位长度上的力，所以 $[\\sigma] = \\frac{[力]}{[长度]} = \\frac{MLT^{-2}}{L} = MT^{-2}$。\n平均曲率 $\\kappa$ 是长度的倒数，所以 $[\\kappa] = L^{-1}$。\n面积 $A_e$ 的量纲是长度的平方，$[A_e] = L^2$。\n单位法向量 $\\mathbf{n}$ 是无量纲的。\n单元施加的总力是 $\\mathbf{F}_e = \\sigma \\kappa A_e \\mathbf{n}$。其大小的量纲是：\n$$\n[\\|\\mathbf{F}_e\\|] = [\\sigma] [\\kappa] [A_e] = (MT^{-2}) (L^{-1}) (L^2) = MLT^{-2}\n$$\n这正是力的量纲，符合预期。\n\n现在考虑离散delta函数 $\\delta_h(\\mathbf{r})$。核函数 $\\phi$ 的自变量 $r/h$ 是长度之比，因此是无量纲的。因此，函数 $\\phi$ 本身也是无量纲的。网格间距 $h$ 的量纲是长度，$[h] = L$。delta函数定义为：\n$$\n\\delta_h(\\mathbf{r}) = \\frac{1}{h^3} \\, \\phi\\!\\left(\\frac{r_x}{h}\\right) \\, \\phi\\!\\left(\\frac{r_y}{h}\\right) \\, \\phi\\!\\left(\\frac{r_z}{h}\\right)\n$$\n其量纲为：\n$$\n[\\delta_h] = \\frac{1}{[h^3]} [\\phi] [\\phi] [\\phi] = \\frac{1}{L^3} \\cdot 1 \\cdot 1 \\cdot 1 = L^{-3}\n$$\n这对应于体积的倒数，这是一个三维delta函数的正确量纲。\n\n最后，力密度 $\\mathbf{f}(\\mathbf{x}_i) = \\mathbf{F}_e \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e)$。其量纲为：\n$$\n[\\|\\mathbf{f}(\\mathbf{x}_i)\\|] = [\\|\\mathbf{F}_e\\|] [\\delta_h] = (MLT^{-2}) (L^{-3}) = ML^{-2}T^{-2}\n$$\n力密度（单位体积的力）的量纲是 $\\frac{[力]}{[体积]} = \\frac{MLT^{-2}}{L^3} = ML^{-2}T^{-2}$。量纲是一致的。\n\n### 解题计算\n力密度由 $\\mathbf{f}(\\mathbf{x}_i) = \\sigma \\kappa A_e \\mathbf{n} \\, \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e)$ 给出。我们需要计算其大小 $\\|\\mathbf{f}(\\mathbf{x}_i)\\|$。由于 $\\mathbf{n}$ 是单位矢量，$\\|\\mathbf{n}\\| = 1$。其大小为：\n$$\n\\|\\mathbf{f}(\\mathbf{x}_i)\\| = |\\sigma \\kappa A_e| \\cdot \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e) \\cdot \\|\\mathbf{n}\\| = \\sigma \\kappa A_e \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e)\n$$\n（假设 $\\sigma, \\kappa, A_e \\ge 0$ 且 $\\delta_h \\ge 0$，对于给定的核函数这是成立的）。\n\n首先，我们计算位移矢量 $\\mathbf{r} = \\mathbf{x}_i - \\mathbf{x}_e$：\n$$\n\\mathbf{r} = \\begin{pmatrix} 2.0 \\times 10^{-3} \\\\ 2.0 \\times 10^{-3} \\\\ 1.0 \\times 10^{-3} \\end{pmatrix} \\mathrm{m} - \\begin{pmatrix} 1.5 \\times 10^{-3} \\\\ 2.25 \\times 10^{-3} \\\\ 0.75 \\times 10^{-3} \\end{pmatrix} \\mathrm{m} = \\begin{pmatrix} 0.5 \\times 10^{-3} \\\\ -0.25 \\times 10^{-3} \\\\ 0.25 \\times 10^{-3} \\end{pmatrix} \\mathrm{m}\n$$\n接下来，我们使用 $h = 1.0 \\times 10^{-3} \\, \\mathrm{m}$ 计算核函数 $\\phi$ 的归一化位移分量：\n$$\n\\frac{r_x}{h} = \\frac{0.5 \\times 10^{-3}}{1.0 \\times 10^{-3}} = 0.5\n$$\n$$\n\\frac{r_y}{h} = \\frac{-0.25 \\times 10^{-3}}{1.0 \\times 10^{-3}} = -0.25\n$$\n$$\n\\frac{r_z}{h} = \\frac{0.25 \\times 10^{-3}}{1.0 \\times 10^{-3}} = 0.25\n$$\n现在我们对每个值计算核函数 $\\phi$。所有绝对值都小于或等于 $1$，所以我们使用 $\\phi(r)$ 定义的第一种情况。\n\n对于 $r=0.5$：\n$$\n\\phi(0.5) = \\frac{1}{8}\\left(3 - 2|0.5| + \\sqrt{1 + 4|0.5| - 4(0.5)^2}\\right) = \\frac{1}{8}\\left(3 - 1 + \\sqrt{1 + 2 - 1}\\right) = \\frac{1}{8}(2 + \\sqrt{2})\n$$\n对于 $r=-0.25$：\n$$\n\\phi(-0.25) = \\frac{1}{8}\\left(3 - 2|-0.25| + \\sqrt{1 + 4|-0.25| - 4(-0.25)^2}\\right) = \\frac{1}{8}\\left(3 - 0.5 + \\sqrt{1 + 1 - 0.25}\\right)\n$$\n$$\n\\phi(-0.25) = \\frac{1}{8}\\left(2.5 + \\sqrt{1.75}\\right) = \\frac{1}{8}\\left(\\frac{5}{2} + \\sqrt{\\frac{7}{4}}\\right) = \\frac{1}{8}\\left(\\frac{5}{2} + \\frac{\\sqrt{7}}{2}\\right) = \\frac{1}{16}(5 + \\sqrt{7})\n$$\n因为 $\\phi(r)$ 取决于 $|r|$，所以 $\\phi(0.25) = \\phi(-0.25)$。\n\n现在，我们计算离散delta函数 $\\delta_h(\\mathbf{r})$ 的值：\n$$\n\\delta_h(\\mathbf{r}) = \\frac{1}{h^3} \\phi\\left(\\frac{r_x}{h}\\right) \\phi\\left(\\frac{r_y}{h}\\right) \\phi\\left(\\frac{r_z}{h}\\right)\n$$\n$$\n\\delta_h(\\mathbf{r}) = \\frac{1}{(1.0 \\times 10^{-3})^3} \\left[ \\frac{1}{8}(2 + \\sqrt{2}) \\right] \\left[ \\frac{1}{16}(5 + \\sqrt{7}) \\right] \\left[ \\frac{1}{16}(5 + \\sqrt{7}) \\right]\n$$\n$$\n\\delta_h(\\mathbf{r}) = \\frac{10^9}{8 \\cdot 16 \\cdot 16} (2 + \\sqrt{2}) (5 + \\sqrt{7})^2 = \\frac{10^9}{2048} (2 + \\sqrt{2}) (25 + 10\\sqrt{7} + 7) = \\frac{10^9}{2048} (2 + \\sqrt{2}) (32 + 10\\sqrt{7})\n$$\n数值计算各分量：\n$\\phi(0.5) = \\frac{1}{8}(2 + \\sqrt{2}) \\approx \\frac{1}{8}(3.41421356) \\approx 0.42677670$\n$\\phi(\\pm 0.25) = \\frac{1}{16}(5 + \\sqrt{7}) \\approx \\frac{1}{16}(7.64575131) \\approx 0.47785946$\n$$\n\\delta_h(\\mathbf{r}) \\approx \\frac{1}{(1.0 \\times 10^{-3})^3} (0.42677670) (0.47785946)^2 \\approx 10^9 \\cdot (0.42677670) \\cdot (0.22834954) \\approx 9.745150 \\times 10^7 \\, \\mathrm{m^{-3}}\n$$\n接下来，我们计算力大小的标量部分，$F_e = \\sigma \\kappa A_e$：\n$$\nF_e = (0.072 \\, \\mathrm{N\\,m^{-1}}) \\cdot (4.0 \\times 10^3 \\, \\mathrm{m^{-1}}) \\cdot (2.5 \\times 10^{-8} \\, \\mathrm{m^2})\n$$\n$$\nF_e = 0.072 \\cdot (4.0 \\times 2.5) \\cdot (10^3 \\times 10^{-8}) \\, \\mathrm{N} = 0.072 \\cdot 10.0 \\cdot 10^{-5} \\, \\mathrm{N} = 0.72 \\cdot 10^{-5} \\, \\mathrm{N} = 7.2 \\times 10^{-6} \\, \\mathrm{N}\n$$\n最后，我们计算力密度的大小：\n$$\n\\|\\mathbf{f}(\\mathbf{x}_i)\\| = F_e \\cdot \\delta_h(\\mathbf{r})\n$$\n$$\n\\|\\mathbf{f}(\\mathbf{x}_i)\\| \\approx (7.2 \\times 10^{-6} \\, \\mathrm{N}) \\cdot (9.745150 \\times 10^7 \\, \\mathrm{m^{-3}})\n$$\n$$\n\\|\\mathbf{f}(\\mathbf{x}_i)\\| \\approx 7.2 \\cdot 9.745150 \\times 10^1 \\, \\mathrm{N\\,m^{-3}} \\approx 701.6508 \\, \\mathrm{N\\,m^{-3}}\n$$\n将最终答案四舍五入到四位有效数字，我们得到 $701.7 \\, \\mathrm{N\\,m^{-3}}$。",
            "answer": "$$\n\\boxed{701.7}\n$$"
        },
        {
            "introduction": "在学习了如何散开界面力之后，理解如何管理拉格朗日界面本身变得至关重要。本实践关注由一组有序标记点定义的界面的几何表示。你将实现一个算法，用于稳健地计算界面所包围的面积，这是在模拟中验证物理守恒律（如质量或体积守恒）的关键步骤。",
            "id": "4088841",
            "problem": "给定一个有序的拉格朗日标记点集合，这些标记点代表了计算流体动力学 (CFD) 中界面追踪方法 (FTM) 下的一个二维物质界面。这些标记点是平面上的点，坐标单位为米。任务是根据这些有序的标记点重建一个闭合的多边形界面，并鲁棒地计算其包围的面积，以便在计算复杂流体的模拟中用于守恒性检查。\n\n推导必须从基本原理出发，始于关于闭合曲线上的线积分及其与面积关系的经过充分检验的数学事实。重建的多边形必须满足以下要求：必须是闭合的；必须没有由近重合标记点引起的伪零长度边；并且所得的面积计算在平移、标记点的循环重编号以及方向改变下必须是数值鲁棒的。您必须确保构造和面积评估与标记点坐标的整体平移无关，并且即使输入顺序反转，该方法的行为也应保持一致。\n\n实现要求：\n- 给定一个有序的标记点列表 $\\{(x_i,y_i)\\}_{i=0}^{N-1}$，坐标单位为 $\\mathrm{m}$，通过连接连续的标记点并将最后一个标记点连接回第一个标记点来重建一个闭合的多边形。如果输入不是显式闭合的，则通过在末尾附加第一个标记点来强制闭合。如果输入已经包含一个在阈值距离 $\\epsilon$（定义如下）内的闭合标记点，则通过使最后一个标记点等于第一个标记点来强制精确闭合。\n- 移除连续的近重合标记点以避免零长度边。如果两个连续标记点 $(x_i,y_i)$ 和 $(x_{i+1},y_{i+1})$ 之间的欧几里得距离小于阈值 $\\epsilon$（单位为 $\\mathrm{m}$），则认为它们是近重合的。使用 $\\epsilon = 10^{-9}\\,\\mathrm{m}$。\n- 如果去重后剩下的非重合标记点少于 $3$ 个，则定义面积为 $0\\,\\mathrm{m}^2$。\n- 使用从基本原理推导出的、在浮点运算下稳定的鲁棒方法，计算重建多边形的包围面积，单位为 $\\mathrm{m}^2$。面积结果必须为非负，并且必须与多边形的方向（顺时针或逆时针）无关。\n\n角度使用说明：\n- 如果使用任何角度为测试套件生成标记点，角度必须以弧度为单位。\n\n您的程序必须实现此重建和面积计算，并将其应用于以下标记点集的测试套件。所有坐标均以 $\\mathrm{m}$ 为单位提供：\n\n- 测试用例 $1$ (带有近重复点和非闭合输入的正常路径)：一个边长为 $2\\,\\mathrm{m}$ 的正方形，顶点位于 $(0\\,\\mathrm{m},0\\,\\mathrm{m})$、$(2\\,\\mathrm{m},0\\,\\mathrm{m})$、$(2\\,\\mathrm{m},2\\,\\mathrm{m})$、$(0\\,\\mathrm{m},2\\,\\mathrm{m})$。输入标记点按顺序排列为\n  $(0\\,\\mathrm{m},0\\,\\mathrm{m})$、$(2\\,\\mathrm{m},0\\,\\mathrm{m})$、$(2\\,\\mathrm{m},(2+10^{-12})\\,\\mathrm{m})$、$(2\\,\\mathrm{m},2\\,\\mathrm{m})$、$(0\\,\\mathrm{m},2\\,\\mathrm{m})$。\n- 测试用例 $2$ (平移不变性检查)：一个外接圆半径为 $1\\,\\mathrm{m}$ 的正六边形，中心位于 $(1000\\,\\mathrm{m},1000\\,\\mathrm{m})$，标记点按逆时针方向排列，角度分别为 $0$、$\\frac{2\\pi}{6}$、$\\frac{4\\pi}{6}$、$\\frac{6\\pi}{6}$、$\\frac{8\\pi}{6}$、$\\frac{10\\pi}{6}$ 弧度。\n- 测试用例 $3$ (退化边界条件)：沿 $x$ 轴共线的标记点，按顺序排列为 $(-1\\,\\mathrm{m},0\\,\\mathrm{m})$、$(0\\,\\mathrm{m},0\\,\\mathrm{m})$、$(1\\,\\mathrm{m},0\\,\\mathrm{m})$、$(2\\,\\mathrm{m},0\\,\\mathrm{m})$。\n- 测试用例 $4$ (方向反转)：一个按顺时针排序的三角形，标记点为 $(0\\,\\mathrm{m},0\\,\\mathrm{m})$、$(0\\,\\mathrm{m},2\\,\\mathrm{m})$、$(2\\,\\mathrm{m},0\\,\\mathrm{m})$。\n- 测试用例 $5$ (椭圆上非均匀间隔的标记点)：一个中心位于 $(-0.3\\,\\mathrm{m},0.5\\,\\mathrm{m})$ 的椭圆，半轴为 $a=1.1\\,\\mathrm{m}$ 和 $b=0.7\\,\\mathrm{m}$，在角度（弧度） $t \\in \\{0, 0.2\\pi, 0.33\\pi, 0.5\\pi, 0.7\\pi, 1.17\\pi, 1.5\\pi, 1.83\\pi\\}$ 处采样，生成标记点 $(x,y) = (-0.3 + a\\cos t,\\; 0.5 + b\\sin t)$，单位为米。\n\n输出要求：\n- 以 $\\mathrm{m}^2$ 为单位表示每个计算出的面积。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 $1$ 到 $5$ 的顺序排列结果（例如，“$[a_1,a_2,a_3,a_4,a_5]$”），其中每个 $a_i$ 是您的方法计算出的以 $\\mathrm{m}^2$ 为单位的浮点数。\n\n设计约束：\n- 推导和算法设计必须从闭合曲线上的线积分和面积性质的基本基础开始，而不是在本问题陈述中直接给出目标公式。\n- 在整个过程中确保科学真实性和数值合理性。",
            "solution": "该问题要求从一个有序的拉格朗日标记点集合中重建一个闭合的多边形界面，并计算其包围的面积。该方法必须鲁棒，从基本原理推导得出，并满足特定的数值处理要求，例如处理近重合点以及确保在平移和方向改变下的不变性。\n\n面积计算方法的推导始于矢量微积分的一个基本定理——格林定理 (Green's Theorem)。对于一个二维矢量场 $\\vec{F}(x, y) = (L(x, y), M(x, y))$ 和一个单连通区域 $D$，其边界曲线 $C$ 是分段光滑、简单、闭合且逆时针定向的，格林定理表述如下：\n$$\n\\oint_C (L \\, dx + M \\, dy) = \\iint_D \\left( \\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y} \\right) dA\n$$\n区域 $D$ 的面积由积分 $A = \\iint_D dA$ 给出。要使用线积分计算此面积，我们必须选择一个矢量场 $\\vec{F}$，使得右侧的被积函数为 1，即 $\\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y} = 1$。对于 $\\vec{F}$ 有多种有效选择，但一个因其对称性而特别有用的选择是 $\\vec{F} = (-\\frac{1}{2}y, \\frac{1}{2}x)$。对于该场，$L = -\\frac{1}{2}y$ 且 $M = \\frac{1}{2}x$，得到：\n$$\n\\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y} = \\frac{\\partial}{\\partial x}\\left(\\frac{1}{2}x\\right) - \\frac{\\partial}{\\partial y}\\left(-\\frac{1}{2}y\\right) = \\frac{1}{2} - \\left(-\\frac{1}{2}\\right) = 1\n$$\n将此代入格林定理，可得到面积的线积分表达式：\n$$\nA = \\oint_C \\frac{1}{2}(x \\, dy - y \\, dx)\n$$\n为了将此应用于多边形，我们将积分离散化。一个多边形由一个有序的顶点集合 $\\{(x_i, y_i)\\}_{i=0}^{N-1}$ 定义。边界 $C$ 是连接顶点 $(x_i, y_i)$ 到 $(x_{i+1}, y_{i+1})$ 的线段 $C_i$ 的并集，其中索引是循环的，即 $(x_N, y_N) = (x_0, y_0)$。总线积分是每条线段上积分的总和：\n$$\nA = \\sum_{i=0}^{N-1} \\int_{C_i} \\frac{1}{2}(x \\, dy - y \\, dx)\n$$\n对于单条线段 $C_i$，我们可以使用参数 $t \\in [0, 1]$ 来参数化从 $(x_i, y_i)$ 到 $(x_{i+1}, y_{i+1})$ 的路径：$x(t) = x_i + t(x_{i+1} - x_i)$ 和 $y(t) = y_i + t(y_{i+1} - y_i)$。那么 $dx = (x_{i+1} - x_i)dt$ 且 $dy = (y_{i+1} - y_i)dt$。线段 $C_i$ 上的积分变为：\n$$\n\\int_0^1 \\frac{1}{2} \\left[ (x_i + t(x_{i+1}-x_i))(y_{i+1}-y_i) - (y_i + t(y_{i+1}-y_i))(x_{i+1}-x_i) \\right] dt\n$$\n展开积分内的项可简化为：\n$$\n\\int_0^1 \\frac{1}{2} (x_i y_{i+1} - x_i y_i - y_i x_{i+1} + y_i x_i) dt = \\frac{1}{2}(x_i y_{i+1} - y_i x_{i+1}) \\int_0^1 dt = \\frac{1}{2}(x_i y_{i+1} - y_i x_{i+1})\n$$\n将所有线段（从 $i=0$ 到 $N-1$）的积分求和，得到总面积：\n$$\nA = \\frac{1}{2} \\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i)\n$$\n这就是著名的鞋带公式（或测量员公式）。该公式得出一个有向面积：对于逆时针顶点排序为正，对于顺时针排序为负。由于问题要求一个与方向无关的非负面积，我们取其绝对值：\n$$\nA = \\left| \\frac{1}{2} \\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i) \\right|\n$$\n该公式对平移具有内在的鲁棒性。将所有顶点平移一个向量 $(a, b)$，得到新坐标 $(x'_i, y'_i) = (x_i+a, y_i+b)$。项 $(x'_i y'_{i+1} - x'_{i+1} y'_i)$ 的计算结果为 $(x_i y_{i+1} - x_{i+1} y_i) + a(y_{i+1} - y_i) - b(x_{i+1} - x_i)$。当对闭合环路求和时，涉及 $a$ 和 $b$ 的项形成和为零的伸缩级数（例如，$\\sum (y_{i+1}-y_i) = y_1-y_0 + y_2-y_1 + \\dots + y_0-y_{N-1} = 0$），从而证明了平移不变性。\n\n算法实现遵循以下步骤：\n1.  **过滤连续的近重合标记点**：处理原始标记点列表以创建一个干净的列表。保留第一个标记点。仅当后续标记点 $(x_k, y_k)$ 与*最后一个已添加标记点*的欧几里得距离超过阈值 $\\epsilon = 10^{-9}\\,\\mathrm{m}$ 时，才将其添加。这可以防止可能导致数值问题的零长度或近零长度边。\n2.  **处理退化几何形状**：如果过滤过程后标记点数量少于 $3$ 个，则无法形成非退化多边形。在这种情况下，面积定义为 $0\\,\\mathrm{m}^2$。\n3.  **建立唯一顶点列表**：鞋带公式隐式地假设多边形由一个有序的唯一顶点列表闭合而成。如果输入的标记点列表代表一个闭合环路，其中最后一个标记点与第一个标记点近乎重复（即它们的距离小于 $\\epsilon$），则从待处理的顶点列表中移除这个多余的最后一个标记点。此步骤通过处理必要的、唯一的几何顶点，正确地解释了问题中“强制精确闭合”的要求。\n4.  **计算面积**：将鞋带公式应用于最终包含 $N$ 个唯一顶点的列表。这可以使用矢量化操作高效实现。计算总和 $\\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i)$，其中索引对 $N$ 取模。最终面积是该总和绝对值的一半。\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_area_calculation():\n    \"\"\"\n    Solves the problem of computing the area of a polygon defined by Lagrangian markers.\n    \"\"\"\n    epsilon = 1.0e-9\n\n    def compute_polygon_area(raw_markers):\n        \"\"\"\n        Reconstructs a polygon from markers and computes its area.\n\n        Args:\n            raw_markers (list of tuples): An ordered list of (x, y) coordinates for the markers.\n\n        Returns:\n            float: The computed non-negative area of the polygon.\n        \"\"\"\n        # A valid polygon requires at least 3 vertices. An empty or small\n        # list of markers results in zero area.\n        if len(raw_markers)  3:\n            return 0.0\n\n        # Convert to a NumPy array for efficient vectorized operations.\n        raw_markers_np = np.array(raw_markers, dtype=np.float64)\n\n        # Step 1: Filter consecutive near-coincident markers\n        # to prevent zero-length or numerically unstable edges.\n        processed_markers = [raw_markers_np[0]]\n        for i in range(1, len(raw_markers_np)):\n            distance = np.linalg.norm(raw_markers_np[i] - processed_markers[-1])\n            if distance >= epsilon:\n                processed_markers.append(raw_markers_np[i])\n\n        # Step 2: Handle degenerate case (fewer than 3 unique vertices)\n        if len(processed_markers)  3:\n            return 0.0\n\n        vertices = np.array(processed_markers)\n\n        # Step 3: Establish a unique vertex list for the Shoelace formula.\n        # If the last marker is a near-duplicate of the first, the polygon is\n        # explicitly closed. We remove the redundant last point because the\n        # formula implicitly connects the last vertex back to the first.\n        if np.linalg.norm(vertices[0] - vertices[-1])  epsilon:\n            vertices = vertices[:-1]\n\n        # Check for degeneracy again after possibly removing the closing point.\n        if len(vertices)  3:\n            return 0.0\n\n        # Step 4: Compute the area using the Shoelace formula.\n        # A = 0.5 * |(x0*y1 + x1*y2 + ...) - (y0*x1 + y1*x2 + ...)|\n        # This is implemented efficiently using NumPy's array operations\n        # and np.roll for circular shifting of array elements.\n        x = vertices[:, 0]\n        y = vertices[:, 1]\n        \n        # The sum of x_i * y_{i+1} minus y_i * x_{i+1}\n        area_sum = np.sum(x * np.roll(y, -1) - np.roll(x, -1) * y)\n\n        # The area is half the absolute value of the sum.\n        area = 0.5 * np.abs(area_sum)\n        \n        return area\n\n    # Test Case 1: Square with a near-duplicate point\n    case1_markers = [\n        (0.0, 0.0), (2.0, 0.0), (2.0, 2.0 + 1e-12), (2.0, 2.0), (0.0, 2.0)\n    ]\n\n    # Test Case 2: Translated regular hexagon\n    center2 = np.array([1000.0, 1000.0])\n    radius2 = 1.0\n    angles2 = np.arange(6) * (np.pi / 3.0) # Equivalent to 2*pi/6\n    case2_markers = [\n        (center2[0] + radius2 * np.cos(t), center2[1] + radius2 * np.sin(t)) for t in angles2\n    ]\n    \n    # Test Case 3: Collinear markers (degenerate polygon)\n    case3_markers = [\n        (-1.0, 0.0), (0.0, 0.0), (1.0, 0.0), (2.0, 0.0)\n    ]\n\n    # Test Case 4: Clockwise oriented triangle\n    case4_markers = [\n        (0.0, 0.0), (0.0, 2.0), (2.0, 0.0)\n    ]\n\n    # Test Case 5: Polygon approximation of an ellipse\n    center5 = np.array([-0.3, 0.5])\n    a5, b5 = 1.1, 0.7\n    angles5 = [0, 0.2*np.pi, 0.33*np.pi, 0.5*np.pi, 0.7*np.pi, 1.17*np.pi, 1.5*np.pi, 1.83*np.pi]\n    case5_markers = [\n        (center5[0] + a5 * np.cos(t), center5[1] + b5 * np.sin(t)) for t in angles5\n    ]\n    \n    test_cases = [\n        case1_markers,\n        case2_markers,\n        case3_markers,\n        case4_markers,\n        case5_markers,\n    ]\n\n    results = []\n    for case in test_cases:\n        area = compute_polygon_area(case)\n        results.append(area)\n    \n    return f\"[{','.join(map(str, results))}]\"\n\n# The following line is commented out as it is not part of the solution text but was used to generate the answer.\n# print(solve_area_calculation())\n```",
            "answer": "[4.0,2.598076211353316,0.0,2.0,2.378731336496924]"
        },
        {
            "introduction": "在练习了力散布和界面几何的核心机制后，最后的这个练习将通过一个标准的验证测试将所有知识点整合起来。你将模拟一个静态液滴，并测量由表面张力离散化时的数值不准确性所产生的“伪电流”——一种非物理性的流动。这个实践展示了如何评估界面追踪方法实现的质量，并理解数值参数对模拟精度的影响。",
            "id": "4088839",
            "problem": "考虑一个边长 $L = 1$ 的二维周期性方形区域，其中充满了一种动力粘度为 $\\mu$ 的单一牛顿流体。一个表面张力系数为 $\\sigma$ 的圆形液滴被嵌入其中，中心位于 $(0.5,0.5)$，半径为 $R$。在连续介质理论中，静止的液滴构型是一个精确的平衡状态：界面力与压力跳跃相平衡，且速度场恒为零。在一种界面追踪数值方法中，界面力通过一个具有有限光滑宽度 $\\,\\delta_h\\,$ 的正则化 delta 函数被散布到欧拉网格上。在实践中，经过散布后，离散化的力仍然存在一个非零的无散分量，从而产生所谓的伪电流。评估伪电流抑制效果的一种严谨方法是执行静态液滴测试：计算系统对离散界面力的稳态不可压缩斯托克斯响应，并报告随着网格加密的最大速度幅值。\n\n从周期性边界条件下的稳态不可压缩斯托克斯方程出发，\n$$\n-\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} = \\mathbf{0}, \\qquad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n设计并实现一个程序，该程序能：\n\n- 将界面表示为位于以 $(0.5,0.5)$ 为中心、半径为 $R$ 的圆上的 $M$ 个等间距拉格朗日标记点构成的闭合参数曲线。\n- 在每个标记点处，使用曲率 $\\,\\kappa = 1/R\\,$ 和单位外法向量 $\\mathbf{n}$ 来构建单位长度上的连续界面表面张力 $\\,\\sigma \\kappa \\mathbf{n}\\,$。\n- 通过用 $M$ 个标记点的黎曼和来近似线积分，将界面力散布到欧拉网格上，其中每个标记点的贡献为\n$$\n\\Delta \\mathbf{F}(\\mathbf{x}) = \\sigma \\kappa \\mathbf{n} \\,\\Delta s\\, \\delta_{\\delta_h}(\\mathbf{x} - \\mathbf{X}_i),\n$$\n其中 $\\,\\Delta s = 2\\pi R/M\\,$，且正则化的二维 delta 函数选择为各向同性高斯函数\n$$\n\\delta_{\\delta_h}(\\mathbf{r}) = \\frac{1}{\\pi \\delta_h^2}\\,\\exp\\!\\left(-\\frac{\\lVert \\mathbf{r}\\rVert^2}{\\delta_h^2}\\right).\n$$\n距离 $\\,\\mathbf{r} = \\mathbf{x} - \\mathbf{X}_i\\,$ 必须在单位环面上使用最小镜像周期性包裹方法计算，以使每个分量都映射到区间 $[-0.5,0.5]$ 内。\n\n- 在傅里叶空间中，在一个均匀的 $N \\times N$ 网格上，使用与不可压缩约束一致的无散投影求解稳态斯托克斯问题，并返回速度场 $\\,\\mathbf{u}(\\mathbf{x})\\,$。精确的连续介质平衡将产生零速度场 $\\,\\mathbf{u}(\\mathbf{x}) = \\mathbf{0}\\,$；任何非零场都是由离散化和正则化引起的伪电流。\n- 报告每个测试案例的最大速度幅值 $\\,\\max_{\\mathbf{x}} \\lVert \\mathbf{u}(\\mathbf{x}) \\rVert\\,$。\n\n所有量均为无量纲。角度必须以弧度为单位。离散傅里叶变换应使用快速傅里叶变换（FFT）实现。程序必须通过将散布的力投影到其无散分量上，并在傅里叶空间中对拉普拉斯算子求逆来产生稳态斯托克斯响应，同时要一致地处理零波数模式以避免奇异点。\n\n测试套件。使用以下参数值集来测试该方法的不同方面：\n\n- 案例 1：$N = 32$, $\\delta_h/h = 0.5$, $R = 0.25$, $\\mu = 1.0$, $\\sigma = 1.0$, $M = 128$。\n- 案例 2：$N = 64$, $\\delta_h/h = 1.0$, $R = 0.25$, $\\mu = 1.0$, $\\sigma = 1.0$, $M = 256$。\n- 案例 3：$N = 64$, $\\delta_h/h = 2.0$, $R = 0.25$, $\\mu = 1.0$, $\\sigma = 1.0$, $M = 256$。\n- 案例 4：$N = 128$, $\\delta_h/h = 2.0$, $R = 0.25$, $\\mu = 1.0$, $\\sigma = 1.0$, $M = 512$。\n- 案例 5：$N = 64$, $\\delta_h/h = 4.0$, $R = 0.25$, $\\mu = 1.0$, $\\sigma = 1.0$, $M = 256$。\n\n此处 $\\,h = L/N\\,$ 且 $\\,\\delta_h = (\\delta_h/h)\\,h\\,$。程序应计算每个案例的最大速度幅值。您的程序应产生单行输出，其中包含一个用方括号括起来的、逗号分隔的浮点数列表，这些浮点数采用科学记数法，精确到 $8$ 位有效数字，并按上述案例的顺序排列（例如 $[a_1,a_2,a_3,a_4,a_5]$）。答案是无量纲浮点数。",
            "solution": "用户提供的问题是计算流体动力学领域中一个适定且科学上合理的任务，具体涉及多相流的数值模拟。该问题要求实现静态液滴测试，这是一个标准基准测试，用于量化在界面追踪和其他移动界面欧拉方法中，因表面张力离散化而产生的非物理“伪电流”的大小。问题提供了一套完整的物理和数值参数，并指定了使用傅里叶谱方法进行求解，该方法适用于周期性区域。问题陈述被验证为完整、一致，并基于已确立的科学原理。\n\n解决方案的步骤是，在一个二维周期性区域上，为稳态不可压缩斯托克斯方程实现一个傅里叶谱求解器，其强迫项源自圆形界面上表面张力的正则化模型。\n\n### 基于原理的数值方法设计\n\n问题的核心是找到稳态速度场 $\\mathbf{u}(\\mathbf{x})$，该速度场在力场 $\\mathbf{f}(\\mathbf{x})$ 的作用下，满足动力粘度为 $\\mu$ 的流体的不可压缩斯托克斯方程：\n$$\n-\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} = \\mathbf{0}\n$$\n$$\n\\nabla \\cdot \\mathbf{u} = 0\n$$\n其中 $p$ 是压力。区域是一个边长为 $L=1$ 的周期性方形区域。\n\n#### 1. 斯托克斯方程的傅里叶谱解法\n对于周期性区域上的问题，傅里叶谱方法非常有效。我们将所有场（速度 $\\mathbf{u}$、压力 $p$ 和力 $\\mathbf{f}$）用其傅里叶级数表示。微分算子在傅里叶空间中转化为代数运算。设 $\\hat{\\phi}(\\mathbf{k})$ 表示场 $\\phi(\\mathbf{x})$ 的傅里叶变换，其中 $\\mathbf{k}=(k_x, k_y)$ 是波矢。算子的变换关系为：$\\nabla \\rightarrow i\\mathbf{k}$，$\\nabla \\cdot \\rightarrow i\\mathbf{k} \\cdot$ 以及 $\\nabla^2 \\rightarrow -\\|\\mathbf{k}\\|^2 = -k^2$。\n\n对斯托克斯方程进行傅里叶变换，得到关于每个波矢 $\\mathbf{k}$ 的代数方程组：\n$$\n-i\\mathbf{k} \\hat{p}(\\mathbf{k}) + \\mu (-k^2) \\hat{\\mathbf{u}}(\\mathbf{k}) + \\hat{\\mathbf{f}}(\\mathbf{k}) = \\mathbf{0}\n$$\n$$\ni\\mathbf{k} \\cdot \\hat{\\mathbf{u}}(\\mathbf{k}) = 0\n$$\n\n第二个方程是傅里叶空间中的不可压缩约束，它表明速度场的傅里叶模式 $\\hat{\\mathbf{u}}(\\mathbf{k})$ 必须与其对应的波矢 $\\mathbf{k}$ 正交。这意味着 $\\hat{\\mathbf{u}}(\\mathbf{k})$ 是一个无散（散度为零）的矢量场。\n\n我们可以通过对动量方程应用一个无散投影算子 $\\mathcal{P}_{\\mathbf{k}}(\\mathbf{v}) = \\mathbf{v} - (\\mathbf{v} \\cdot \\mathbf{k}/k^2)\\mathbf{k}$ 来消去压力项。该算子将一个矢量投影到与 $\\mathbf{k}$ 垂直的子空间上。\n- 压力梯度项 $-i\\mathbf{k} \\hat{p}$ 与 $\\mathbf{k}$ 平行，因此其投影为零：$\\mathcal{P}_{\\mathbf{k}}(-i\\mathbf{k} \\hat{p}) = \\mathbf{0}$。\n- 速度场 $\\hat{\\mathbf{u}}$ 已经是无散的，因此它在投影下保持不变：$\\mathcal{P}_{\\mathbf{k}}(\\hat{\\mathbf{u}}) = \\hat{\\mathbf{u}}$。\n\n对动量方程应用投影得到：\n$$\n-\\mu k^2 \\hat{\\mathbf{u}}(\\mathbf{k}) + \\mathcal{P}_{\\mathbf{k}}(\\hat{\\mathbf{f}}(\\mathbf{k})) = \\mathbf{0}\n$$\n对于 $\\mathbf{k} \\neq \\mathbf{0}$ 求解 $\\hat{\\mathbf{u}}(\\mathbf{k})$ 得到：\n$$\n\\hat{\\mathbf{u}}(\\mathbf{k}) = \\frac{1}{\\mu k^2} \\mathcal{P}_{\\mathbf{k}}(\\hat{\\mathbf{f}}(\\mathbf{k})) = \\frac{1}{\\mu k^2} \\left( \\hat{\\mathbf{f}}(\\mathbf{k}) - \\frac{\\hat{\\mathbf{f}}(\\mathbf{k}) \\cdot \\mathbf{k}}{k^2} \\mathbf{k} \\right)\n$$\n对于零波数模式 $\\mathbf{k} = \\mathbf{0}$（对应于场的空间平均值），动量方程简化为 $\\hat{\\mathbf{f}}(\\mathbf{0}) = \\mathbf{0}$。这个条件表明区域上的净力必须为零，对于一个闭合界面，由于对称性，该条件是满足的。该方程没有提供关于平均速度 $\\hat{\\mathbf{u}}(\\mathbf{0})$ 的信息。对于静态测试，我们假设系统平均处于静止状态，因此我们设置 $\\hat{\\mathbf{u}}(\\mathbf{0}) = \\mathbf{0}$。\n\n#### 2. 界面力的计算与散布\n力 $\\mathbf{f}$ 源于作用在半径为 $R$ 的圆形界面上的表面张力 $\\sigma$。连续介质表面张力是一个线源，由 $\\mathbf{F}_s = \\sigma \\kappa \\mathbf{n}$ 给出，其中 $\\kappa = 1/R$ 是曲率，$\\mathbf{n}$ 是外法向量。\n\n在数值上，这个连续力被离散化并散布到 $N \\times N$ 的欧拉网格上。界面由 $M$ 个拉格朗日标记点 $\\mathbf{X}_i$ ($i=0, \\dots, M-1$) 表示，它们之间的弧长为 $\\Delta s = 2\\pi R / M$。每个标记点贡献一个力，该力通过一个正则化的二维 delta 函数 $\\delta_{\\delta_h}$ 分布到附近的网格点上。问题指定了使用各向同性高斯函数：\n$$\n\\delta_{\\delta_h}(\\mathbf{r}) = \\frac{1}{\\pi \\delta_h^2}\\,\\exp\\left(-\\frac{\\lVert \\mathbf{r}\\rVert^2}{\\delta_h^2}\\right)\n$$\n任何网格点 $\\mathbf{x}$ 处的力密度是所有标记点贡献的总和：\n$$\n\\mathbf{f}(\\mathbf{x}) = \\sum_{i=0}^{M-1} (\\sigma \\kappa \\mathbf{n}_i \\Delta s) \\, \\delta_{\\delta_h}(\\mathbf{x} - \\mathbf{X}_i)\n$$\n代入 $\\kappa=1/R$ 和 $\\Delta s = 2\\pi R / M$，括号中的项变为 $(2\\pi\\sigma/M)\\mathbf{n}_i$。距离矢量 $\\mathbf{r} = \\mathbf{x} - \\mathbf{X}_i$ 是使用边长为 $L=1$ 的周期性区域上的最小镜像约定计算的，以确保每个分量都位于 $[-0.5, 0.5]$ 内。\n\n#### 3. 算法总结\n完整的算法如下：\n1.  **初始化**：定义大小为 $N \\times N$、网格间距为 $h=L/N=1/N$ 的欧拉网格。定义圆形界面上的 $M$ 个拉格朗日标记点。\n2.  **力的散布**：对于每个网格点 $\\mathbf{x}_{jk}$，使用高斯 delta 函数和周期性距离，通过对所有 $M$ 个标记点的贡献求和来计算总力 $\\mathbf{f}(\\mathbf{x}_{jk})$。这将产生两个 $N \\times N$ 的数组，分别用于力的分量 $f_x$ 和 $f_y$。\n3.  **正向 FFT**：计算 $f_x$ 和 $f_y$ 的离散傅里叶变换，以获得 $\\hat{f}_x(\\mathbf{k})$ 和 $\\hat{f}_y(\\mathbf{k})$。\n4.  **傅里叶空间求解**：对于离散傅里叶网格中的每个波矢 $\\mathbf{k}$： a. 如果 $\\mathbf{k}=\\mathbf{0}$，则设置 $\\hat{u}_x(\\mathbf{0})=0$ 和 $\\hat{u}_y(\\mathbf{0})=0$。 b. 如果 $\\mathbf{k}\\neq\\mathbf{0}$，则使用涉及 $\\hat{\\mathbf{f}}(\\mathbf{k})$ 的无散投影的推导表达式计算 $\\hat{\\mathbf{u}}(\\mathbf{k})$。\n5.  **逆向 FFT**：计算 $\\hat{u}_x(\\mathbf{k})$ 和 $\\hat{u}_y(\\mathbf{k})$ 的离散傅里叶逆变换，以获得实空间中的速度分量 $u_x(\\mathbf{x})$ 和 $u_y(\\mathbf{x})$。\n6.  **结果**：在每个网格点计算速度幅值 $\\lVert \\mathbf{u}(\\mathbf{x}) \\rVert = \\sqrt{u_x^2(\\mathbf{x}) + u_y^2(\\mathbf{x})}$，并找到整个区域上的最大值。该值即为伪电流的幅值。\n\n对测试套件中提供的每组参数重复此过程。得到的最大速度幅值量化了数值误差，预计该误差会随着网格加密（增加 $N$）而减小，并对平滑参数 $\\delta_h$ 的选择非常敏感。\n```python\nimport numpy as np\n\ndef calculate_max_velocity(N, delta_h_over_h, R, mu, sigma, M):\n    \"\"\"\n    Computes the maximum spurious velocity for a static drop test using a \n    Fourier-spectral method for the Stokes equations.\n\n    Args:\n        N (int): Number of grid points in each dimension (N x N grid).\n        delta_h_over_h (float): Ratio of the smoothing width to the grid spacing.\n        R (float): Radius of the circular drop.\n        mu (float): Dynamic viscosity of the fluid.\n        sigma (float): Surface tension coefficient.\n        M (int): Number of Lagrangian markers on the interface.\n\n    Returns:\n        float: The maximum magnitude of the velocity field (spurious current).\n    \"\"\"\n    # 1. Grid and physical parameters setup\n    L = 1.0\n    h = L / N\n    delta_h = delta_h_over_h * h\n    \n    # Eulerian grid coordinates\n    grid_coords_1d = np.arange(N) * h\n    xx, yy = np.meshgrid(grid_coords_1d, grid_coords_1d, indexing='ij')\n\n    # 2. Interface representation\n    theta = np.linspace(0, 2 * np.pi, M, endpoint=False)\n    # Marker positions\n    Xi_x = 0.5 + R * np.cos(theta)\n    Xi_y = 0.5 + R * np.sin(theta)\n    # Outward normal vectors\n    ni_x = np.cos(theta)\n    ni_y = np.sin(theta)\n    \n    # 3. Force spreading\n    fx = np.zeros((N, N), dtype=float)\n    fy = np.zeros((N, N), dtype=float)\n    \n    # Pre-calculate constant factor for force spreading.\n    # The term sigma * kappa * ds for a marker is sigma * (1/R) * (2*pi*R/M) = 2*pi*sigma/M.\n    # The prefactor for the Gaussian delta function is 1/(pi*delta_h^2).\n    # The combined prefactor is (2*pi*sigma/M) * (1/(pi*delta_h^2)) = 2*sigma / (M*delta_h^2).\n    force_prefactor = 2 * sigma / (M * delta_h**2)\n    \n    for i in range(M):\n        # Compute wrapped distance from marker i to all grid points\n        dx = xx - Xi_x[i]\n        dy = yy - Xi_y[i]\n        \n        # Apply minimum image convention for periodic domain of L=1\n        dx -= np.round(dx)\n        dy -= np.round(dy)\n        \n        r_sq = dx**2 + dy**2\n        \n        # Evaluate the Gaussian delta function kernel\n        kernel = np.exp(-r_sq / delta_h**2)\n        \n        # Add the force contribution from marker i to the grid force field\n        fx += force_prefactor * ni_x[i] * kernel\n        fy += force_prefactor * ni_y[i] * kernel\n\n    # 4. Solve Stokes equations in Fourier space\n    # Take the 2D Fast Fourier Transform of the force field components\n    f_hat_x = np.fft.fft2(fx)\n    f_hat_y = np.fft.fft2(fy)\n    \n    # Create the grid of angular wavenumbers\n    k_freq = np.fft.fftfreq(N, d=h)\n    k_angular = 2 * np.pi * k_freq\n    kx, ky = np.meshgrid(k_angular, k_angular, indexing='ij')\n\n    k_sq = kx**2 + ky**2\n    \n    # To avoid division by zero at k=0, we compute the inverse of k^2 only where k is non-zero.\n    # The k=0 mode must be handled separately.\n    k_sq_inv = np.zeros_like(k_sq)\n    non_zero_k_mask = k_sq != 0\n    k_sq_inv[non_zero_k_mask] = 1.0 / k_sq[non_zero_k_mask]\n    \n    # Project the force field onto its solenoidal (divergence-free) part.\n    # This is done by subtracting the irrotational (curl-free) part: f_hat - (f_hat . k)k/k^2\n    f_hat_dot_k = f_hat_x * kx + f_hat_y * ky\n    \n    f_sol_x = f_hat_x - (f_hat_dot_k * kx * k_sq_inv)\n    f_sol_y = f_hat_y - (f_hat_dot_k * ky * k_sq_inv)\n    \n    # Solve for velocity in Fourier space: u_hat = f_sol / (mu * k^2)\n    u_hat_x = (1 / mu) * f_sol_x * k_sq_inv\n    u_hat_y = (1 / mu) * f_sol_y * k_sq_inv\n    # For k=0, k_sq_inv is 0, so u_hat(0,0) is correctly set to 0, satisfying the zero mean velocity condition.\n    \n    # Transform velocity back to real space using inverse FFT\n    ux = np.fft.ifft2(u_hat_x).real\n    uy = np.fft.ifft2(u_hat_y).real\n    \n    # 5. Compute the maximum velocity magnitude\n    vel_mag = np.sqrt(ux**2 + uy**2)\n    max_vel = np.max(vel_mag)\n    \n    return max_vel\n\ndef solve_spurious_current():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, delta_h/h, R, mu, sigma, M)\n        (32, 0.5, 0.25, 1.0, 1.0, 128),\n        (64, 1.0, 0.25, 1.0, 1.0, 256),\n        (64, 2.0, 0.25, 1.0, 1.0, 256),\n        (128, 2.0, 0.25, 1.0, 1.0, 512),\n        (64, 4.0, 0.25, 1.0, 1.0, 256),\n    ]\n\n    results = []\n    for params in test_cases:\n        max_v = calculate_max_velocity(*params)\n        results.append(f\"{max_v:.8e}\")\n\n    return f\"[{','.join(results)}]\"\n\n# The following line is commented out as it is not part of the solution text but was used to generate the answer.\n# print(solve_spurious_current())\n```",
            "answer": "[1.37895475e-04,1.86820565e-04,4.40742118e-05,1.10427306e-05,2.78465922e-06]"
        }
    ]
}