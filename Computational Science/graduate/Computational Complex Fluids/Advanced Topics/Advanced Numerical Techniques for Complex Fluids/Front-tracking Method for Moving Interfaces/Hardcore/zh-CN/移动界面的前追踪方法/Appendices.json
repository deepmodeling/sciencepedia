{
    "hands_on_practices": [
        {
            "introduction": "在任何锋面追踪模拟中，首要任务是精确地表示移动的界面。这不仅涉及存储标记点的位置，还要求能够计算其几何属性（如面积或体积），这对于验证质量守恒等基本物理原理至关重要。本练习  旨在通过从拉格朗日标记点稳健地计算多边形面积，来实践这一基本技能，这是二维模拟中的一项基础任务。",
            "id": "4088841",
            "problem": "给定一组有序的拉格朗日标记点，它们在用于计算流体动力学 (CFD) 的前端追踪法 (FTM) 中表示一个二维物质界面。这些标记点是平面上的一些点，其坐标单位为米。任务是利用这些有序的标记点重建一个闭合的多边形界面，并稳健地计算其围成的面积，以便在计算复杂流体的模拟中用于守恒性检查。\n\n推导必须从基本原理出发，始于关于闭合曲线上的曲线积分以及面积与此类积分关系的成熟数学事实。重建的多边形必须满足以下要求：它必须是闭合的，必须没有由近重合标记点引起的虚假零长度边，并且最终的面积计算在平移、标记点的循环重编号和朝向改变的情况下必须保持数值稳健。您必须确保构造和面积评估与标记点坐标的整体平移无关，并且即使输入顺序颠倒，该方法也能表现出一致的行为。\n\n实现要求：\n- 给定一个有序的标记点列表 $\\{(x_i,y_i)\\}_{i=0}^{N-1}$，坐标单位为 $\\mathrm{m}$，通过连接连续的标记点并将最后一个标记点连接回第一个标记点来重建一个闭合多边形。如果输入不是显式闭合的，则通过将第一个标记点附加到末尾来强制闭合。如果输入已经包含一个与起始点距离在阈值 $\\epsilon$（定义如下）之内的闭合标记点，则通过使最后一个标记点等于第一个标记点来强制精确闭合。\n- 移除连续的近重合标记点以避免零长度边。如果两个连续的标记点 $(x_i,y_i)$ 和 $(x_{i+1},y_{i+1})$ 之间的欧几里得距离小于阈值 $\\epsilon$（单位为 $\\mathrm{m}$），则认为它们是近重合的。使用 $\\epsilon = 10^{-9}\\,\\mathrm{m}$。\n- 如果去重后剩余的非重合标记点少于 $3$ 个，则将面积定义为 $0\\,\\mathrm{m}^2$。\n- 使用一种从第一性原理推导出的、在浮点数运算下稳定的稳健方法，计算重建多边形所围成的面积，单位为 $\\mathrm{m}^2$。面积结果必须为非负，并且必须与多边形的朝向（顺时针或逆时针）无关。\n\n角度使用说明：\n- 如果在测试套件中使用了任何角度来生成标记点，则角度必须以弧度为单位。\n\n您的程序必须实现这种重建和面积计算，并将其应用于以下标记点集的测试套件。所有坐标均以 $\\mathrm{m}$ 为单位提供：\n\n- 测试用例 $1$（包含近重复点和非闭合输入的正常路径）：一个边长为 $2\\,\\mathrm{m}$ 的正方形，顶点位于 $(0\\,\\mathrm{m},0\\,\\mathrm{m})$、$(2\\,\\mathrm{m},0\\,\\mathrm{m})$、$(2\\,\\mathrm{m},2\\,\\mathrm{m})$、$(0\\,\\mathrm{m},2\\,\\mathrm{m})$。输入的标记点顺序为 $(0\\,\\mathrm{m},0\\,\\mathrm{m})$、$(2\\,\\mathrm{m},0\\,\\mathrm{m})$、$(2\\,\\mathrm{m},(2+10^{-12})\\,\\mathrm{m})$、$(2\\,\\mathrm{m},2\\,\\mathrm{m})$、$(0\\,\\mathrm{m},2\\,\\mathrm{m})$。\n- 测试用例 $2$（平移不变性检查）：一个外接圆半径为 $1\\,\\mathrm{m}$ 的正六边形，中心位于 $(1000\\,\\mathrm{m},1000\\,\\mathrm{m})$，标记点按逆时针方向排列，角度分别为 $0$、$\\frac{2\\pi}{6}$、$\\frac{4\\pi}{6}$、$\\frac{6\\pi}{6}$、$\\frac{8\\pi}{6}$、$\\frac{10\\pi}{6}$ 弧度。\n- 测试用例 $3$（退化边界条件）：沿 $x$ 轴排列的共线标记点，顺序为 $(-1\\,\\mathrm{m},0\\,\\mathrm{m})$、$(0\\,\\mathrm{m},0\\,\\mathrm{m})$、$(1\\,\\mathrm{m},0\\,\\mathrm{m})$、$(2\\,\\mathrm{m},0\\,\\mathrm{m})$。\n- 测试用例 $4$（朝向反转）：一个按顺时针排序的三角形，标记点为 $(0\\,\\mathrm{m},0\\,\\mathrm{m})$、$(0\\,\\mathrm{m},2\\,\\mathrm{m})$、$(2\\,\\mathrm{m},0\\,\\mathrm{m})$。\n- 测试用例 $5$（椭圆上的非均匀间隔标记点）：一个中心位于 $(-0.3\\,\\mathrm{m},0.5\\,\\mathrm{m})$ 的椭圆，半轴长分别为 $a=1.1\\,\\mathrm{m}$ 和 $b=0.7\\,\\mathrm{m}$，在角度（单位为弧度） $t \\in \\{0, 0.2\\pi, 0.33\\pi, 0.5\\pi, 0.7\\pi, 1.17\\pi, 1.5\\pi, 1.83\\pi\\}$ 处采样，生成标记点 $(x,y) = (-0.3 + a\\cos t,\\; 0.5 + b\\sin t)$，单位为米。\n\n输出要求：\n- 以 $\\mathrm{m}^2$ 为单位表示每个计算出的面积。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 $1$ 到 $5$ 的顺序排列结果（例如，“$[a_1,a_2,a_3,a_4,a_5]$”），其中每个 $a_i$ 是您的方法计算出的以 $\\mathrm{m}^2$ 为单位的浮点数。\n\n设计约束：\n- 推导和算法设计必须从闭合曲线上的曲线积分和面积性质的基本基础出发，而不能在本问题陈述中直接给出目标公式。\n- 在整个过程中确保科学真实性和数值合理性。",
            "solution": "该问题要求从一组有序的拉格朗日标记点重建一个闭合的多边形界面，并计算其围成的面积。该方法必须是稳健的，从第一性原理推导得出，并满足特定的数值卫生要求，例如处理近重合点以及确保在平移和朝向改变下的不变性。\n\n面积计算方法的推导始于矢量微积分的一个基本定理——格林公式 (Green's Theorem)。对于一个二维矢量场 $\\vec{F}(x, y) = (L(x, y), M(x, y))$ 和一个单连通区域 $D$，其边界曲线 $C$ 是分段光滑、简单、闭合且逆时针定向的，格林公式表述为：\n$$\n\\oint_C (L \\, dx + M \\, dy) = \\iint_D \\left( \\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y} \\right) dA\n$$\n区域 $D$ 的面积由积分 $A = \\iint_D dA$ 给出。为了使用曲线积分计算此面积，我们必须选择一个矢量场 $\\vec{F}$，使得右侧的被积函数为 1，即 $\\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y} = 1$。对于 $\\vec{F}$ 有几种有效的选择，但由于其对称性，一个特别有用的选择是 $\\vec{F} = (-\\frac{1}{2}y, \\frac{1}{2}x)$。对于这个场，$L = -\\frac{1}{2}y$ 且 $M = \\frac{1}{2}x$，得到：\n$$\n\\frac{\\partial M}{\\partial x} - \\frac{\\partial L}{\\partial y} = \\frac{\\partial}{\\partial x}\\left(\\frac{1}{2}x\\right) - \\frac{\\partial}{\\partial y}\\left(-\\frac{1}{2}y\\right) = \\frac{1}{2} - \\left(-\\frac{1}{2}\\right) = 1\n$$\n将此代入格林公式，得到面积的曲线积分形式：\n$$\nA = \\oint_C \\frac{1}{2}(x \\, dy - y \\, dx)\n$$\n为了将此应用于多边形，我们将积分离散化。一个多边形由一组有序的顶点 $\\{(x_i, y_i)\\}_{i=0}^{N-1}$ 定义。边界 $C$ 是连接顶点 $(x_i, y_i)$ 和 $(x_{i+1}, y_{i+1})$ 的线段 $C_i$ 的并集，其中索引是循环的，即 $(x_N, y_N) = (x_0, y_0)$。总曲线积分是每条线段上积分的总和：\n$$\nA = \\sum_{i=0}^{N-1} \\int_{C_i} \\frac{1}{2}(x \\, dy - y \\, dx)\n$$\n对于单条线段 $C_i$，我们可以使用参数 $t \\in [0, 1]$ 来参数化从 $(x_i, y_i)$ 到 $(x_{i+1}, y_{i+1})$ 的路径：$x(t) = x_i + t(x_{i+1} - x_i)$ 和 $y(t) = y_i + t(y_{i+1} - y_i)$。那么 $dx = (x_{i+1} - x_i)dt$ 和 $dy = (y_{i+1} - y_i)dt$。线段 $C_i$ 上的积分变为：\n$$\n\\int_0^1 \\frac{1}{2} \\left[ (x_i + t(x_{i+1}-x_i))(y_{i+1}-y_i) - (y_i + t(y_{i+1}-y_i))(x_{i+1}-x_i) \\right] dt\n$$\n展开积分内的项可简化为：\n$$\n\\int_0^1 \\frac{1}{2} (x_i y_{i+1} - x_i y_i - y_i x_{i+1} + y_i x_i) dt = \\frac{1}{2}(x_i y_{i+1} - y_i x_{i+1}) \\int_0^1 dt = \\frac{1}{2}(x_i y_{i+1} - y_i x_{i+1})\n$$\n对所有从 $i=0$ 到 $N-1$ 的线段求和，得到总面积：\n$$\nA = \\frac{1}{2} \\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i)\n$$\n这就是著名的鞋带公式（或测量员公式）。该公式产生一个有向面积：对于逆时针顶点排序为正，对于顺时针排序为负。由于问题要求一个与朝向无关的非负面积，我们取其绝对值：\n$$\nA = \\left| \\frac{1}{2} \\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i) \\right|\n$$\n该公式天生对平移具有稳健性。将所有顶点平移一个向量 $(a, b)$，得到新坐标 $(x'_i, y'_i) = (x_i+a, y_i+b)$。项 $(x'_i y'_{i+1} - x'_{i+1} y'_i)$ 计算结果为 $(x_i y_{i+1} - x_{i+1} y_i) + a(y_{i+1} - y_i) - b(x_{i+1} - x_i)$。当在闭合回路上求和时，涉及 $a$ 和 $b$ 的项形成和为零的伸缩级数（例如，$\\sum (y_{i+1}-y_i) = y_1-y_0 + y_2-y_1 + \\dots + y_0-y_{N-1} = 0$），从而证明了平移不变性。\n\n算法实现遵循以下步骤：\n1.  **过滤连续的近重合标记点**：处理原始标记点列表以创建一个干净的列表。保留第一个标记点。后续的标记点 $(x_k, y_k)$ 仅当其与*最后一个已添加标记点*的欧几里得距离超过阈值 $\\epsilon = 10^{-9}\\,\\mathrm{m}$ 时才被添加。这可以防止可能导致数值问题的零长度或近零长度边。\n2.  **处理退化几何形状**：如果过滤过程后剩余的标记点少于 $3$ 个，则无法形成非退化的多边形。在这种情况下，面积定义为 $0\\,\\mathrm{m}^2$。\n3.  **建立唯一顶点列表**：鞋带公式隐含地假设一个由有序唯一顶点构成的闭合多边形。如果输入的标记点列表表示一个闭合回路，其中最后一个标记点是第一个标记点的近重复点（即它们的距离小于 $\\epsilon$），则从待处理的顶点列表中移除这个冗余的最后一个标记点。此步骤通过处理本质的、唯一的几何顶点，正确地解释了问题中“强制精确闭合”的要求。\n4.  **计算面积**：将鞋带公式应用于最终的 $N$ 个唯一顶点列表。这可以使用向量化操作高效实现。计算总和 $\\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i)$，其中索引对 $N$ 取模。最终面积是该总和绝对值的一半。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing the area of a polygon defined by Lagrangian markers.\n    \"\"\"\n    epsilon = 1.0e-9\n\n    def compute_polygon_area(raw_markers):\n        \"\"\"\n        Reconstructs a polygon from markers and computes its area.\n\n        Args:\n            raw_markers (list of tuples): An ordered list of (x, y) coordinates for the markers.\n\n        Returns:\n            float: The computed non-negative area of the polygon.\n        \"\"\"\n        # A valid polygon requires at least 3 vertices. An empty or small\n        # list of markers results in zero area.\n        if len(raw_markers)  3:\n            return 0.0\n\n        # Convert to a NumPy array for efficient vectorized operations.\n        raw_markers_np = np.array(raw_markers, dtype=np.float64)\n\n        # Step 1: Filter consecutive near-coincident markers\n        # to prevent zero-length or numerically unstable edges.\n        processed_markers = [raw_markers_np[0]]\n        for i in range(1, len(raw_markers_np)):\n            distance = np.linalg.norm(raw_markers_np[i] - processed_markers[-1])\n            if distance = epsilon:\n                processed_markers.append(raw_markers_np[i])\n\n        # Step 2: Handle degenerate case (fewer than 3 unique vertices)\n        if len(processed_markers)  3:\n            return 0.0\n\n        vertices = np.array(processed_markers)\n\n        # Step 3: Establish a unique vertex list for the Shoelace formula.\n        # If the last marker is a near-duplicate of the first, the polygon is\n        # explicitly closed. We remove the redundant last point because the\n        # formula implicitly connects the last vertex back to the first.\n        if np.linalg.norm(vertices[0] - vertices[-1])  epsilon:\n            vertices = vertices[:-1]\n\n        # Check for degeneracy again after possibly removing the closing point.\n        if len(vertices)  3:\n            return 0.0\n\n        # Step 4: Compute the area using the Shoelace formula.\n        # A = 0.5 * |(x0*y1 + x1*y2 + ...) - (y0*x1 + y1*x2 + ...)|\n        # This is implemented efficiently using NumPy's array operations\n        # and np.roll for circular shifting of array elements.\n        x = vertices[:, 0]\n        y = vertices[:, 1]\n        \n        # The sum of x_i * y_{i+1} minus y_i * x_{i+1}\n        area_sum = np.sum(x * np.roll(y, -1) - np.roll(x, -1) * y)\n\n        # The area is half the absolute value of the sum.\n        area = 0.5 * np.abs(area_sum)\n        \n        return area\n\n    # Test Case 1: Square with a near-duplicate point\n    case1_markers = [\n        (0.0, 0.0), (2.0, 0.0), (2.0, 2.0 + 1e-12), (2.0, 2.0), (0.0, 2.0)\n    ]\n\n    # Test Case 2: Translated regular hexagon\n    center2 = np.array([1000.0, 1000.0])\n    radius2 = 1.0\n    angles2 = np.arange(6) * (np.pi / 3.0) # Equivalent to 2*pi/6\n    case2_markers = [\n        (center2[0] + radius2 * np.cos(t), center2[1] + radius2 * np.sin(t)) for t in angles2\n    ]\n    \n    # Test Case 3: Collinear markers (degenerate polygon)\n    case3_markers = [\n        (-1.0, 0.0), (0.0, 0.0), (1.0, 0.0), (2.0, 0.0)\n    ]\n\n    # Test Case 4: Clockwise oriented triangle\n    case4_markers = [\n        (0.0, 0.0), (0.0, 2.0), (2.0, 0.0)\n    ]\n\n    # Test Case 5: Polygon approximation of an ellipse\n    center5 = np.array([-0.3, 0.5])\n    a5, b5 = 1.1, 0.7\n    angles5 = [0, 0.2*np.pi, 0.33*np.pi, 0.5*np.pi, 0.7*np.pi, 1.17*np.pi, 1.5*np.pi, 1.83*np.pi]\n    case5_markers = [\n        (center5[0] + a5 * np.cos(t), center5[1] + b5 * np.sin(t)) for t in angles5\n    ]\n    \n    test_cases = [\n        case1_markers,\n        case2_markers,\n        case3_markers,\n        case4_markers,\n        case5_markers,\n    ]\n\n    results = []\n    for case in test_cases:\n        area = compute_polygon_area(case)\n        results.append(area)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "锋面追踪方法的核心在于其混合的拉格朗日-欧拉框架。此耦合的一个关键方面是将力（例如表面张力）从拉格朗日界面传递到固定的欧拉流体网格。本练习  提供了一个具体的计算任务，要求学生利用离散 $\\delta$ 函数，将单个界面单元产生的力“散布”到附近的网格节点上，从而清晰地揭示了界面与流体相互作用的基本机制。",
            "id": "4088769",
            "problem": "考虑一个在两相流的三维锋面追踪离散化中的单个三角形界面元。该界面由拉格朗日元表示，这些拉格朗日元通过一个正则化的离散delta函数，将表面张力力密度分布到下方的欧拉网格上。界面上单位面积的表面张力由 $\\sigma \\kappa \\mathbf{n}$ 给出，其中 $\\sigma$ 是表面张力系数，$\\kappa$ 是平均曲率，$\\mathbf{n}$ 是单位法向量。在锋面追踪方法中，位于位置 $\\mathbf{x}_i$ 的网格节点上，由形心位于位置 $\\mathbf{x}_e$、面积为 $A_e$ 的单个界面元产生的欧拉力密度可由以下公式建模：\n$$\n\\mathbf{f}(\\mathbf{x}_i) \\approx \\sigma \\kappa \\mathbf{n} \\, A_e \\, \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e).\n$$\n假设一个间距为 $h$ 的均匀笛卡尔网格，并使用在浸入边界（IB）方法中普及的标准可分离正则化离散delta函数，\n$$\n\\delta_h(\\mathbf{r}) = \\frac{1}{h^3} \\, \\phi\\!\\left(\\frac{r_x}{h}\\right) \\, \\phi\\!\\left(\\frac{r_y}{h}\\right) \\, \\phi\\!\\left(\\frac{r_z}{h}\\right),\n$$\n其中 $\\mathbf{r} = (r_x,r_y,r_z)$，$\\phi$ 是由下式定义的四点一维核函数：\n$$\n\\phi(r) =\n\\begin{cases}\n\\frac{1}{8}\\left(3 - 2|r| + \\sqrt{1 + 4|r| - 4 r^2}\\right),  |r| \\leq 1, \\\\\n\\frac{1}{8}\\left(5 - 2|r| - \\sqrt{-7 + 12|r| - 4 r^2}\\right),  1   |r| \\leq 2, \\\\\n0,  |r|  2.\n\\end{cases}\n$$\n给定：\n- 表面张力系数 $\\sigma = 0.072$ $\\mathrm{N\\,m^{-1}}$，\n- 平均曲率 $\\kappa = 4.0 \\times 10^{3}$ $\\mathrm{m^{-1}}$，\n- 界面单位法向量 $\\mathbf{n} = \\frac{1}{\\sqrt{3}}(1,1,1)$，\n- 三角形元面积 $A_e = 2.5 \\times 10^{-8}$ $\\mathrm{m^2}$，\n- 网格间距 $h = 1.0 \\times 10^{-3}$ $\\mathrm{m}$，\n- 界面元形心 $\\mathbf{x}_e = (1.5 \\times 10^{-3},\\, 2.25 \\times 10^{-3},\\, 0.75 \\times 10^{-3})$ $\\mathrm{m}$，\n- 目标网格节点位置 $\\mathbf{x}_i = (2.0 \\times 10^{-3},\\, 2.0 \\times 10^{-3},\\, 1.0 \\times 10^{-3})$ $\\mathrm{m}$。\n\n使用形心求积近似和上述离散delta函数 $\\delta_h$，计算指定网格节点上的离散表面张力力密度的大小 $\\|\\mathbf{f}(\\mathbf{x}_i)\\|$。将最终数值答案四舍五入到四位有效数字。以 $\\mathrm{N\\,m^{-3}}$ 为单位表示最终答案。此外，从给定的物理定义和 $\\delta_h$ 的形式出发，验证 $\\mathbf{f}$ 的量纲一致性。",
            "solution": "该问题要求计算在锋面追踪模拟中特定网格节点上的离散表面张力力密度的大小，并要求验证量纲一致性。\n\n### 步骤 1：提取已知条件\n- 网格节点 $\\mathbf{x}_i$ 处的欧拉力密度：$\\mathbf{f}(\\mathbf{x}_i) \\approx \\sigma \\kappa \\mathbf{n} \\, A_e \\, \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e)$\n- 表面张力系数：$\\sigma = 0.072 \\, \\mathrm{N\\,m^{-1}}$\n- 平均曲率：$\\kappa = 4.0 \\times 10^{3} \\, \\mathrm{m^{-1}}$\n- 界面单位法向量：$\\mathbf{n} = \\frac{1}{\\sqrt{3}}(1,1,1)$\n- 三角形元面积：$A_e = 2.5 \\times 10^{-8} \\, \\mathrm{m^2}$\n- 网格间距：$h = 1.0 \\times 10^{-3} \\, \\mathrm{m}$\n- 界面元形心位置：$\\mathbf{x}_e = (1.5 \\times 10^{-3},\\, 2.25 \\times 10^{-3},\\, 0.75 \\times 10^{-3}) \\, \\mathrm{m}$\n- 目标网格节点位置：$\\mathbf{x}_i = (2.0 \\times 10^{-3},\\, 2.0 \\times 10^{-3},\\, 1.0 \\times 10^{-3}) \\, \\mathrm{m}$\n- 正则化离散delta函数：$\\delta_h(\\mathbf{r}) = \\frac{1}{h^3} \\, \\phi\\!\\left(\\frac{r_x}{h}\\right) \\, \\phi\\!\\left(\\frac{r_y}{h}\\right) \\, \\phi\\!\\left(\\frac{r_z}{h}\\right)$\n- 一维核函数：$\\phi(r) =\n\\begin{cases}\n\\frac{1}{8}\\left(3 - 2|r| + \\sqrt{1 + 4|r| - 4 r^2}\\right),  |r| \\leq 1, \\\\\n\\frac{1}{8}\\left(5 - 2|r| - \\sqrt{-7 + 12|r| - 4 r^2}\\right),  1   |r| \\leq 2, \\\\\n0,  |r|  2.\n\\end{cases}$\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据、适定且客观。\n- **科学依据：** 该公式是锋面追踪和浸入边界方法背景下表面张力的标准表示，这些方法在计算流体力学中广泛用于多相流。力密度和离散delta函数的方程直接取自已有文献（例如，Peskin, 2002）。\n- **适定性：** 提供了所有必要的参数和函数形式。问题要求基于这些输入进行特定的数值计算，这会导出一个唯一解。\n- **客观性：** 问题陈述是定量的，没有主观或模糊的语言。\n\n该问题没有表现出验证标准中列出的任何缺陷。所提供的数据对于微流体模拟是自洽且现实的。\n\n### 步骤 3：结论与行动\n该问题是有效的。将提供完整的解答。\n\n### 量纲一致性验证\n问题要求验证力密度 $\\mathbf{f}(\\mathbf{x}_i)$ 的量纲一致性。令 $[X]$ 表示物理量 $X$ 以质量（$M$）、长度（$L$）和时间（$T$）表示的量纲。\n表面张力系数 $\\sigma$ 是单位长度上的力，所以 $[\\sigma] = \\frac{[\\text{力}]}{[\\text{长度}]} = \\frac{MLT^{-2}}{L} = MT^{-2}$。\n平均曲率 $\\kappa$ 是长度的倒数，所以 $[\\kappa] = L^{-1}$。\n面积 $A_e$ 的量纲是长度的平方，$[A_e] = L^2$。\n单位法向量 $\\mathbf{n}$ 是无量纲的。\n该单元施加的总力为 $\\mathbf{F}_e = \\sigma \\kappa A_e \\mathbf{n}$。其大小的量纲是：\n$$\n[\\|\\mathbf{F}_e\\|] = [\\sigma] [\\kappa] [A_e] = (MT^{-2}) (L^{-1}) (L^2) = MLT^{-2}\n$$\n这正是力的量纲，符合预期。\n\n现在考虑离散delta函数 $\\delta_h(\\mathbf{r})$。核函数 $\\phi$ 的自变量 $r/h$ 是长度之比，因此是无量纲的。函数 $\\phi$ 本身因此也是无量纲的。网格间距 $h$ 的量纲是长度，$[h] = L$。该delta函数的定义为：\n$$\n\\delta_h(\\mathbf{r}) = \\frac{1}{h^3} \\, \\phi\\!\\left(\\frac{r_x}{h}\\right) \\, \\phi\\!\\left(\\frac{r_y}{h}\\right) \\, \\phi\\!\\left(\\frac{r_z}{h}\\right)\n$$\n其量纲是：\n$$\n[\\delta_h] = \\frac{1}{[h^3]} [\\phi] [\\phi] [\\phi] = \\frac{1}{L^3} \\cdot 1 \\cdot 1 \\cdot 1 = L^{-3}\n$$\n这对应于体积的倒数，是三维delta函数的正确量纲。\n\n最后，力密度 $\\mathbf{f}(\\mathbf{x}_i) = \\mathbf{F}_e \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e)$。其量纲是：\n$$\n[\\|\\mathbf{f}(\\mathbf{x}_i)\\|] = [\\|\\mathbf{F}_e\\|] [\\delta_h] = (MLT^{-2}) (L^{-3}) = ML^{-2}T^{-2}\n$$\n力密度（单位体积的力）的量纲是 $\\frac{[\\text{力}]}{[\\text{体积}]} = \\frac{MLT^{-2}}{L^3} = ML^{-2}T^{-2}$。量纲是一致的。\n\n### 求解计算\n力密度由 $\\mathbf{f}(\\mathbf{x}_i) = \\sigma \\kappa A_e \\mathbf{n} \\, \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e)$ 给出。我们需要计算其大小 $\\|\\mathbf{f}(\\mathbf{x}_i)\\|$。由于 $\\mathbf{n}$ 是单位向量，$\\|\\mathbf{n}\\| = 1$。其大小为：\n$$\n\\|\\mathbf{f}(\\mathbf{x}_i)\\| = |\\sigma \\kappa A_e| \\cdot \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e) \\cdot \\|\\mathbf{n}\\| = \\sigma \\kappa A_e \\delta_h(\\mathbf{x}_i - \\mathbf{x}_e)\n$$\n（假设 $\\sigma, \\kappa, A_e \\ge 0$ 且 $\\delta_h \\ge 0$，对于给定的核函数这是成立的）。\n\n首先，我们计算位移向量 $\\mathbf{r} = \\mathbf{x}_i - \\mathbf{x}_e$：\n$$\n\\mathbf{r} = \\begin{pmatrix} 2.0 \\times 10^{-3} \\\\ 2.0 \\times 10^{-3} \\\\ 1.0 \\times 10^{-3} \\end{pmatrix} \\mathrm{m} - \\begin{pmatrix} 1.5 \\times 10^{-3} \\\\ 2.25 \\times 10^{-3} \\\\ 0.75 \\times 10^{-3} \\end{pmatrix} \\mathrm{m} = \\begin{pmatrix} 0.5 \\times 10^{-3} \\\\ -0.25 \\times 10^{-3} \\\\ 0.25 \\times 10^{-3} \\end{pmatrix} \\mathrm{m}\n$$\n接下来，我们使用 $h = 1.0 \\times 10^{-3} \\, \\mathrm{m}$，为核函数 $\\phi$ 计算归一化位移分量：\n$$\n\\frac{r_x}{h} = \\frac{0.5 \\times 10^{-3}}{1.0 \\times 10^{-3}} = 0.5\n$$\n$$\n\\frac{r_y}{h} = \\frac{-0.25 \\times 10^{-3}}{1.0 \\times 10^{-3}} = -0.25\n$$\n$$\n\\frac{r_z}{h} = \\frac{0.25 \\times 10^{-3}}{1.0 \\times 10^{-3}} = 0.25\n$$\n现在我们对每个值计算核函数 $\\phi$。所有绝对值都小于或等于1，因此我们使用 $\\phi(r)$ 定义的第一种情况。\n\n对于 $r=0.5$：\n$$\n\\phi(0.5) = \\frac{1}{8}\\left(3 - 2|0.5| + \\sqrt{1 + 4|0.5| - 4(0.5)^2}\\right) = \\frac{1}{8}\\left(3 - 1 + \\sqrt{1 + 2 - 1}\\right) = \\frac{1}{8}(2 + \\sqrt{2})\n$$\n对于 $r=-0.25$：\n$$\n\\phi(-0.25) = \\frac{1}{8}\\left(3 - 2|-0.25| + \\sqrt{1 + 4|-0.25| - 4(-0.25)^2}\\right) = \\frac{1}{8}\\left(3 - 0.5 + \\sqrt{1 + 1 - 0.25}\\right)\n$$\n$$\n\\phi(-0.25) = \\frac{1}{8}\\left(2.5 + \\sqrt{1.75}\\right) = \\frac{1}{8}\\left(\\frac{5}{2} + \\sqrt{\\frac{7}{4}}\\right) = \\frac{1}{8}\\left(\\frac{5}{2} + \\frac{\\sqrt{7}}{2}\\right) = \\frac{1}{16}(5 + \\sqrt{7})\n$$\n由于 $\\phi(r)$ 取决于 $|r|$，所以 $\\phi(0.25) = \\phi(-0.25)$。\n\n现在，我们计算离散delta函数 $\\delta_h(\\mathbf{r})$ 的值：\n$$\n\\delta_h(\\mathbf{r}) = \\frac{1}{h^3} \\phi\\left(\\frac{r_x}{h}\\right) \\phi\\left(\\frac{r_y}{h}\\right) \\phi\\left(\\frac{r_z}{h}\\right)\n$$\n$$\n\\delta_h(\\mathbf{r}) = \\frac{1}{(1.0 \\times 10^{-3})^3} \\left[ \\frac{1}{8}(2 + \\sqrt{2}) \\right] \\left[ \\frac{1}{16}(5 + \\sqrt{7}) \\right] \\left[ \\frac{1}{16}(5 + \\sqrt{7}) \\right]\n$$\n$$\n\\delta_h(\\mathbf{r}) = \\frac{10^9}{8 \\cdot 16 \\cdot 16} (2 + \\sqrt{2}) (5 + \\sqrt{7})^2 = \\frac{10^9}{2048} (2 + \\sqrt{2}) (25 + 10\\sqrt{7} + 7) = \\frac{10^9}{2048} (2 + \\sqrt{2}) (32 + 10\\sqrt{7})\n$$\n对各分量进行数值计算：\n$\\phi(0.5) = \\frac{1}{8}(2 + \\sqrt{2}) \\approx \\frac{1}{8}(3.41421356) \\approx 0.42677670$\n$\\phi(\\pm 0.25) = \\frac{1}{16}(5 + \\sqrt{7}) \\approx \\frac{1}{16}(7.64575131) \\approx 0.47785946$\n$$\n\\delta_h(\\mathbf{r}) \\approx \\frac{1}{(1.0 \\times 10^{-3})^3} (0.42677670) (0.47785946)^2 \\approx 10^9 \\cdot (0.42677670) \\cdot (0.22834954) \\approx 9.745150 \\times 10^7 \\, \\mathrm{m^{-3}}\n$$\n接下来，我们计算力大小的标量部分，$F_e = \\sigma \\kappa A_e$：\n$$\nF_e = (0.072 \\, \\mathrm{N\\,m^{-1}}) \\cdot (4.0 \\times 10^3 \\, \\mathrm{m^{-1}}) \\cdot (2.5 \\times 10^{-8} \\, \\mathrm{m^2})\n$$\n$$\nF_e = 0.072 \\cdot (4.0 \\times 2.5) \\cdot (10^3 \\times 10^{-8}) \\, \\mathrm{N} = 0.072 \\cdot 10.0 \\cdot 10^{-5} \\, \\mathrm{N} = 0.72 \\cdot 10^{-5} \\, \\mathrm{N} = 7.2 \\times 10^{-6} \\, \\mathrm{N}\n$$\n最后，我们计算力密度的大小：\n$$\n\\|\\mathbf{f}(\\mathbf{x}_i)\\| = F_e \\cdot \\delta_h(\\mathbf{r})\n$$\n$$\n\\|\\mathbf{f}(\\mathbf{x}_i)\\| \\approx (7.2 \\times 10^{-6} \\, \\mathrm{N}) \\cdot (9.745150 \\times 10^7 \\, \\mathrm{m^{-3}})\n$$\n$$\n\\|\\mathbf{f}(\\mathbf{x}_i)\\| \\approx 7.2 \\cdot 9.745150 \\times 10^1 \\, \\mathrm{N\\,m^{-3}} \\approx 701.6508 \\, \\mathrm{N\\,m^{-3}}\n$$\n将最终答案四舍五入到四位有效数字，我们得到 $701.7 \\, \\mathrm{N\\,m^{-3}}$。",
            "answer": "$$\n\\boxed{701.7}\n$$"
        },
        {
            "introduction": "实现数值方法仅是成功的一半，对其进行验证同等重要。对于多相流问题，“静态液滴测试”是评估表面张力实现质量的标准基准。本练习  将指导你设置此测试，以量化由数值不精确性产生的非物理流动——即“伪电流”，并理解离散化选择（如网格分辨率和光滑核宽度）如何影响其大小。",
            "id": "4088839",
            "problem": "考虑一个边长为 $L = 1$ 的二维周期性方形区域，其中充满了一种动力粘度为 $\\mu$ 的单一牛顿 (Newtonian) 流体。一个表面张力系数为 $\\sigma$ 的单个圆形液滴被嵌入其中，中心位于 $(0.5,0.5)$，半径为 $R$。在连续介质中，静止状态下的静态液滴构型是一个精确的平衡：界面力平衡了压力跳跃，并且速度场恒等于零。在前端追踪 (front-tracking) 数值方法中，界面力通过一个具有有限光滑宽度 $\\,\\delta_h\\,$ 的正则化 delta 函数被散布到一个欧拉 (Eulerian) 网格上。在实践中，离散化的力在散布后仍会残留一个非零的螺线管分量，从而产生所谓的虚假电流 (spurious currents)。评估虚假电流抑制效果的一种严谨方法是执行静态液滴测试：计算系统对离散化界面力的稳态不可压缩斯托克斯 (Stokes) 响应，并报告随着网格细化所得的最大速度幅值。\n\n从周期性边界条件下的稳态不可压缩斯托克斯 (Stokes) 方程出发，\n$$\n-\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} = \\mathbf{0}, \\qquad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n设计并实现一个程序，该程序：\n\n- 将界面表示为位于以 $(0.5,0.5)$ 为中心、半径为 $R$ 的圆上的 $M$ 个等距分布的拉格朗日 (Lagrangian) 标记点的封闭参数化曲线。\n- 使用每个标记点处的曲率 $\\,\\kappa = 1/R\\,$ 和向外的单位法向量 $\\mathbf{n}$ 来构建单位长度上的连续界面表面张力 $\\,\\sigma \\kappa \\mathbf{n}\\,$.\n- 通过使用 $M$ 个标记点的黎曼 (Riemann) 和来近似线积分，从而将界面力散布到欧拉 (Eulerian) 网格上，其中每个标记点的贡献为\n$$\n\\Delta \\mathbf{F}(\\mathbf{x}) = \\sigma \\kappa \\mathbf{n} \\,\\Delta s\\, \\delta_{\\delta_h}(\\mathbf{x} - \\mathbf{X}_i),\n$$\n其中 $\\,\\Delta s = 2\\pi R/M\\,$，并且正则化的二维 delta 函数被选为各向同性的高斯 (Gaussian) 函数\n$$\n\\delta_{\\delta_h}(\\mathbf{r}) = \\frac{1}{\\pi \\delta_h^2}\\,\\exp\\!\\left(-\\frac{\\lVert \\mathbf{r}\\rVert^2}{\\delta_h^2}\\right).\n$$\n距离 $\\,\\mathbf{r} = \\mathbf{x} - \\mathbf{X}_i\\,$ 必须在单位环面上使用最小镜像周期性包裹来计算，以使每个分量都被映射到区间 $[-0.5,0.5]$ 内。\n\n- 在傅里叶 (Fourier) 空间中，在一个均匀的 $N \\times N$ 网格上，使用与不可压缩性约束一致的螺线管投影来求解稳态斯托克斯 (Stokes) 问题，并返回速度场 $\\,\\mathbf{u}(\\mathbf{x})\\,$. 精确的连续介质平衡将产生零场 $\\,\\mathbf{u}(\\mathbf{x}) = \\mathbf{0}\\,$；任何非零场都是由离散化和正则化引起的虚假电流。\n- 报告每个测试用例的最大速度幅值 $\\,\\max_{\\mathbf{x}} \\lVert \\mathbf{u}(\\mathbf{x}) \\rVert\\,$.\n\n所有物理量均为无量纲。角度必须以弧度为单位。离散傅里叶变换 (discrete Fourier transform) 应使用快速傅里叶变换 (FFT) 实现。程序必须通过将散布力投影到其无散度分量上，并在傅里叶 (Fourier) 空间中对拉普拉斯算子 (Laplacian) 求逆，从而得出稳态斯托克斯 (Stokes) 响应，同时要一致地处理零波数模式以避免奇点。\n\n测试套件。使用以下参数值集来检验该方法的不同方面：\n\n- 情况 1：$N = 32$, $\\delta_h/h = 0.5$, $R = 0.25$, $\\mu = 1.0$, $\\sigma = 1.0$, $M = 128$。\n- 情况 2：$N = 64$, $\\delta_h/h = 1.0$, $R = 0.25$, $\\mu = 1.0$, $\\sigma = 1.0$, $M = 256$。\n- 情况 3：$N = 64$, $\\delta_h/h = 2.0$, $R = 0.25$, $\\mu = 1.0$, $\\sigma = 1.0$, $M = 256$。\n- 情况 4：$N = 128$, $\\delta_h/h = 2.0$, $R = 0.25$, $\\mu = 1.0$, $\\sigma = 1.0$, $M = 512$。\n- 情况 5：$N = 64$, $\\delta_h/h = 4.0$, $R = 0.25$, $\\mu = 1.0$, $\\sigma = 1.0$, $M = 256$。\n\n此处 $\\,h = L/N\\,$ 且 $\\,\\delta_h = (\\delta_h/h)\\,h\\,$. 程序应计算每个情况下的最大速度幅值。你的程序应生成单行输出，其中包含结果，结果为逗号分隔的浮点数列表，使用科学记数法表示，精确到 $8$ 位有效数字，并用方括号括起来，顺序与上述情况一致（例如 $[a_1,a_2,a_3,a_4,a_5]$）。答案是无量纲浮点数。",
            "solution": "用户提供的问题是计算流体力学领域一个适定且科学合理的问题，具体涉及多相流的数值模拟。它要求实现一个静态液滴测试，这是一个标准基准测试，用于量化在前端追踪 (front-tracking) 和其他用于移动界面的欧拉 (Eulerian) 方法中，因表面张力离散化而产生的非物理“虚假电流 (spurious currents)”的大小。该问题提供了一套完整的物理和数值参数，并指定了使用傅里叶 (Fourier) 谱方法进行求解，这对于周期性区域是合适的。问题陈述被验证为完整、一致，并基于已确立的科学原理。\n\n### 基于原理的数值方法设计\n\n问题的核心是找到满足不可压缩斯托克斯 (Stokes) 方程的稳态速度场 $\\mathbf{u}(\\mathbf{x})$，该流体动力粘度为 $\\mu$，并受到力场 $\\mathbf{f}(\\mathbf{x})$ 的作用：\n$$\n-\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} = \\mathbf{0}\n$$\n$$\n\\nabla \\cdot \\mathbf{u} = 0\n$$\n其中 $p$ 是压力。区域是一个边长为 $L=1$ 的周期性方形区域。\n\n#### 1. 斯托克斯 (Stokes) 方程的傅里叶谱解\n对于周期性区域上的问题，傅里叶 (Fourier) 谱方法非常有效。我们用它们的傅里叶 (Fourier) 级数来表示所有场（速度 $\\mathbf{u}$、压力 $p$ 和力 $\\mathbf{f}$）。微分算子在傅里叶 (Fourier) 空间中转变为代数运算。令 $\\hat{\\phi}(\\mathbf{k})$ 表示场 $\\phi(\\mathbf{x})$ 的傅里叶变换，其中 $\\mathbf{k}=(k_x, k_y)$ 是波矢。算子变换如下：$\\nabla \\rightarrow i\\mathbf{k}$，$\\nabla \\cdot \\rightarrow i\\mathbf{k} \\cdot$，以及 $\\nabla^2 \\rightarrow -\\|\\mathbf{k}\\|^2 = -k^2$。\n\n对斯托克斯 (Stokes) 方程应用傅里叶变换，得到关于每个波矢 $\\mathbf{k}$ 的代数方程组：\n$$\n-i\\mathbf{k} \\hat{p}(\\mathbf{k}) + \\mu (-k^2) \\hat{\\mathbf{u}}(\\mathbf{k}) + \\hat{\\mathbf{f}}(\\mathbf{k}) = \\mathbf{0}\n$$\n$$\ni\\mathbf{k} \\cdot \\hat{\\mathbf{u}}(\\mathbf{k}) = 0\n$$\n\n第二个方程是傅里叶 (Fourier) 空间中的不可压缩性约束，它表明速度场的傅里叶模式 $\\hat{\\mathbf{u}}(\\mathbf{k})$ 必须与其对应的波矢 $\\mathbf{k}$ 正交。这意味着 $\\hat{\\mathbf{u}}(\\mathbf{k})$ 是一个螺线管（无散度）矢量场。\n\n我们可以通过对动量方程应用螺线管投影算子 $\\mathcal{P}_{\\mathbf{k}}(\\mathbf{v}) = \\mathbf{v} - (\\mathbf{v} \\cdot \\mathbf{k}/k^2)\\mathbf{k}$ 来消去压力项。该算子将一个向量投影到与 $\\mathbf{k}$ 垂直的子空间上。\n- 压力梯度项 $-i\\mathbf{k} \\hat{p}$ 与 $\\mathbf{k}$ 平行，因此其投影为零：$\\mathcal{P}_{\\mathbf{k}}(-i\\mathbf{k} \\hat{p}) = \\mathbf{0}$。\n- 速度场 $\\hat{\\mathbf{u}}$ 已经是螺线管场，因此它在投影下保持不变：$\\mathcal{P}_{\\mathbf{k}}(\\hat{\\mathbf{u}}) = \\hat{\\mathbf{u}}$。\n\n将该投影应用于动量方程，得到：\n$$\n-\\mu k^2 \\hat{\\mathbf{u}}(\\mathbf{k}) + \\mathcal{P}_{\\mathbf{k}}(\\hat{\\mathbf{f}}(\\mathbf{k})) = \\mathbf{0}\n$$\n对 $\\mathbf{k} \\neq \\mathbf{0}$ 求解 $\\hat{\\mathbf{u}}(\\mathbf{k})$，得到：\n$$\n\\hat{\\mathbf{u}}(\\mathbf{k}) = \\frac{1}{\\mu k^2} \\mathcal{P}_{\\mathbf{k}}(\\hat{\\mathbf{f}}(\\mathbf{k})) = \\frac{1}{\\mu k^2} \\left( \\hat{\\mathbf{f}}(\\mathbf{k}) - \\frac{\\hat{\\mathbf{f}}(\\mathbf{k}) \\cdot \\mathbf{k}}{k^2} \\mathbf{k} \\right)\n$$\n对于零波数模式 $\\mathbf{k} = \\mathbf{0}$（对应于场的空间平均值），动量方程简化为 $\\hat{\\mathbf{f}}(\\mathbf{0}) = \\mathbf{0}$。这个条件表明作用在区域上的净力必须为零，对于闭合界面，由于对称性，该条件是满足的。该方程没有提供关于平均速度 $\\hat{\\mathbf{u}}(\\mathbf{0})$ 的信息。对于静态测试，我们假设系统平均处于静止状态，因此我们设置 $\\hat{\\mathbf{u}}(\\mathbf{0}) = \\mathbf{0}$。\n\n#### 2. 界面力计算与散布\n力 $\\mathbf{f}$ 源于作用在半径为 $R$ 的圆形界面上的表面张力 $\\sigma$。连续介质表面张力是一个线源，由 $\\mathbf{F}_s = \\sigma \\kappa \\mathbf{n}$ 给出，其中 $\\kappa = 1/R$ 是曲率，$\\mathbf{n}$ 是向外的法向量。\n\n在数值上，这个连续力被离散化并散布到 $N \\times N$ 的欧拉 (Eulerian) 网格上。界面由 $M$ 个拉格朗日 (Lagrangian) 标记点 $\\mathbf{X}_i$（$i=0, \\dots, M-1$）表示，它们之间的弧长为 $\\Delta s = 2\\pi R / M$。每个标记点贡献一个力，该力使用正则化的二维 delta 函数 $\\delta_{\\delta_h}$ 分布到附近的网格点。问题指定了一个各向同性的高斯 (Gaussian) 函数：\n$$\n\\delta_{\\delta_h}(\\mathbf{r}) = \\frac{1}{\\pi \\delta_h^2}\\,\\exp\\left(-\\frac{\\lVert \\mathbf{r}\\rVert^2}{\\delta_h^2}\\right)\n$$\n任意网格点 $\\mathbf{x}$ 处的力密度是所有标记点贡献的总和：\n$$\n\\mathbf{f}(\\mathbf{x}) = \\sum_{i=0}^{M-1} (\\sigma \\kappa \\mathbf{n}_i \\Delta s) \\, \\delta_{\\delta_h}(\\mathbf{x} - \\mathbf{X}_i)\n$$\n代入 $\\kappa=1/R$ 和 $\\Delta s = 2\\pi R / M$，括号中的项变为 $(2\\pi\\sigma/M)\\mathbf{n}_i$。距离向量 $\\mathbf{r} = \\mathbf{x} - \\mathbf{X}_i$ 使用边长为 $L=1$ 的周期性区域上的最小镜像约定进行计算，确保每个分量都位于 $[-0.5, 0.5]$ 内。\n\n#### 3. 算法总结\n完整的算法如下：\n1.  **初始化**：定义大小为 $N \\times N$、网格间距为 $h=L/N=1/N$ 的欧拉 (Eulerian) 网格。在圆形界面上定义 $M$ 个拉格朗日 (Lagrangian) 标记点。\n2.  **力散布**：对于每个网格点 $\\mathbf{x}_{jk}$，通过使用高斯 (Gaussian) delta 函数和周期性距离，对所有 $M$ 个标记点的贡献求和，从而计算总力 $\\mathbf{f}(\\mathbf{x}_{jk})$。这将为力的分量 $f_x$ 和 $f_y$ 生成两个 $N \\times N$ 的数组。\n3.  **正向 FFT**：计算 $f_x$ 和 $f_y$ 的离散傅里叶变换，以获得 $\\hat{f}_x(\\mathbf{k})$ 和 $\\hat{f}_y(\\mathbf{k})$。\n4.  **傅里叶空间求解**：对于离散傅里叶 (Fourier) 网格中的每个波矢 $\\mathbf{k}$： a. 如果 $\\mathbf{k}=\\mathbf{0}$，则设置 $\\hat{u}_x(\\mathbf{0})=0$ 和 $\\hat{u}_y(\\mathbf{0})=0$。 b. 如果 $\\mathbf{k}\\neq\\mathbf{0}$，则使用涉及 $\\hat{\\mathbf{f}}(\\mathbf{k})$ 螺线管投影的推导表达式计算 $\\hat{\\mathbf{u}}(\\mathbf{k})$。\n5.  **逆向 FFT**：计算 $\\hat{u}_x(\\mathbf{k})$ 和 $\\hat{u}_y(\\mathbf{k})$ 的逆离散傅里叶变换，以获得实空间中的速度分量 $u_x(\\mathbf{x})$ 和 $u_y(\\mathbf{x})$。\n6.  **结果**：计算每个网格点上的速度幅值 $\\lVert \\mathbf{u}(\\mathbf{x}) \\rVert = \\sqrt{u_x^2(\\mathbf{x}) + u_y^2(\\mathbf{x})}$，并找出整个区域上的最大值。该值即为虚假电流的幅值。\n\n对测试套件中提供的每组参数重复此过程。由此产生的最大速度幅值量化了数值误差，该误差预计会随着网格细化（$N$ 增加）而减小，并对光滑参数 $\\delta_h$ 的选择非常敏感。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_max_velocity(N, delta_h_over_h, R, mu, sigma, M):\n    \"\"\"\n    Computes the maximum spurious velocity for a static drop test using a \n    Fourier-spectral method for the Stokes equations.\n\n    Args:\n        N (int): Number of grid points in each dimension (N x N grid).\n        delta_h_over_h (float): Ratio of the smoothing width to the grid spacing.\n        R (float): Radius of the circular drop.\n        mu (float): Dynamic viscosity of the fluid.\n        sigma (float): Surface tension coefficient.\n        M (int): Number of Lagrangian markers on the interface.\n\n    Returns:\n        float: The maximum magnitude of the velocity field (spurious current).\n    \"\"\"\n    # 1. Grid and physical parameters setup\n    L = 1.0\n    h = L / N\n    delta_h = delta_h_over_h * h\n    \n    # Eulerian grid coordinates\n    grid_coords_1d = np.arange(N) * h\n    xx, yy = np.meshgrid(grid_coords_1d, grid_coords_1d, indexing='ij')\n\n    # 2. Interface representation\n    theta = np.linspace(0, 2 * np.pi, M, endpoint=False)\n    # Marker positions\n    Xi_x = 0.5 + R * np.cos(theta)\n    Xi_y = 0.5 + R * np.sin(theta)\n    # Outward normal vectors\n    ni_x = np.cos(theta)\n    ni_y = np.sin(theta)\n    \n    # 3. Force spreading\n    fx = np.zeros((N, N), dtype=float)\n    fy = np.zeros((N, N), dtype=float)\n    \n    # Pre-calculate constant factor for force spreading.\n    # The term sigma * kappa * ds for a marker is sigma * (1/R) * (2*pi*R/M) = 2*pi*sigma/M.\n    # The prefactor for the Gaussian delta function is 1/(pi*delta_h^2).\n    # The combined prefactor is (2*pi*sigma/M) * (1/(pi*delta_h^2)) = 2*sigma / (M*delta_h^2).\n    force_prefactor = 2 * sigma / (M * delta_h**2)\n    \n    for i in range(M):\n        # Compute wrapped distance from marker i to all grid points\n        dx = xx - Xi_x[i]\n        dy = yy - Xi_y[i]\n        \n        # Apply minimum image convention for periodic domain of L=1\n        dx -= np.round(dx)\n        dy -= np.round(dy)\n        \n        r_sq = dx**2 + dy**2\n        \n        # Evaluate the Gaussian delta function kernel\n        kernel = np.exp(-r_sq / delta_h**2)\n        \n        # Add the force contribution from marker i to the grid force field\n        fx += force_prefactor * ni_x[i] * kernel\n        fy += force_prefactor * ni_y[i] * kernel\n\n    # 4. Solve Stokes equations in Fourier space\n    # Take the 2D Fast Fourier Transform of the force field components\n    f_hat_x = np.fft.fft2(fx)\n    f_hat_y = np.fft.fft2(fy)\n    \n    # Create the grid of angular wavenumbers\n    k_freq = np.fft.fftfreq(N, d=h)\n    k_angular = 2 * np.pi * k_freq\n    kx, ky = np.meshgrid(k_angular, k_angular, indexing='ij')\n\n    k_sq = kx**2 + ky**2\n    \n    # To avoid division by zero at k=0, we compute the inverse of k^2 only where k is non-zero.\n    # The k=0 mode must be handled separately.\n    k_sq_inv = np.zeros_like(k_sq)\n    non_zero_k_mask = k_sq != 0\n    k_sq_inv[non_zero_k_mask] = 1.0 / k_sq[non_zero_k_mask]\n    \n    # Project the force field onto its solenoidal (divergence-free) part.\n    # This is done by subtracting the irrotational (curl-free) part: f_hat - (f_hat . k)k/k^2\n    f_hat_dot_k = f_hat_x * kx + f_hat_y * ky\n    \n    f_sol_x = f_hat_x - (f_hat_dot_k * kx * k_sq_inv)\n    f_sol_y = f_hat_y - (f_hat_dot_k * ky * k_sq_inv)\n    \n    # Solve for velocity in Fourier space: u_hat = f_sol / (mu * k^2)\n    u_hat_x = (1 / mu) * f_sol_x * k_sq_inv\n    u_hat_y = (1 / mu) * f_sol_y * k_sq_inv\n    # For k=0, k_sq_inv is 0, so u_hat(0,0) is correctly set to 0, satisfying the zero mean velocity condition.\n    \n    # Transform velocity back to real space using inverse FFT\n    ux = np.fft.ifft2(u_hat_x).real\n    uy = np.fft.ifft2(u_hat_y).real\n    \n    # 5. Compute the maximum velocity magnitude\n    vel_mag = np.sqrt(ux**2 + uy**2)\n    max_vel = np.max(vel_mag)\n    \n    return max_vel\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, delta_h/h, R, mu, sigma, M)\n        (32, 0.5, 0.25, 1.0, 1.0, 128),\n        (64, 1.0, 0.25, 1.0, 1.0, 256),\n        (64, 2.0, 0.25, 1.0, 1.0, 256),\n        (128, 2.0, 0.25, 1.0, 1.0, 512),\n        (64, 4.0, 0.25, 1.0, 1.0, 256),\n    ]\n\n    results = []\n    for params in test_cases:\n        max_v = calculate_max_velocity(*params)\n        results.append(f\"{max_v:.8e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}