{
    "hands_on_practices": [
        {
            "introduction": "This foundational exercise connects the governing equations of viscoelastic fluid dynamics to the physical phenomena they describe. By performing a dimensional analysis, you will derive the key dimensionless parameters that control the flow behavior, including the Reynolds number $Re$, the Weissenberg number $Wi$, and the Elasticity number $El$. This practice is essential for building the intuition to determine whether a flow is dominated by inertia, viscosity, or elasticity, which is the first step in predicting the onset of elastic turbulence .",
            "id": "4084941",
            "problem": "A dilute polymer solution flowing in a microchannel is modeled as an incompressible viscoelastic fluid. Assume the momentum balance is given by the conservation of linear momentum with a viscous stress and an additional polymeric extra-stress, and that the polymeric extra-stress obeys a single-mode linear elastic constitutive law with a finite relaxation time. The characteristic scales are a length $L$, a velocity $U$, and a total dynamic viscosity $\\eta$ for the solution. Let the fluid density be $\\rho$ and the polymer relaxation time be $\\lambda$. The flow is steady and the geometry is such that curvature or weak extensional regions can arise, although the analysis here focuses only on the intrinsic dimensionless groups produced by nondimensionalization.\n\nStarting from the balance of linear momentum for an incompressible fluid and a linear viscoelastic constitutive relation with relaxation time, use nondimensionalization with the scales $L$ and $U$ to identify the dimensionless numbers that compare inertia to viscous stress, elastic relaxation to flow time, and elastic effects to inertia. Then, using the following physically consistent parameters for a microchannel flow:\n- Mean velocity $U = 5.0 \\times 10^{-2}\\ \\text{m}\\,\\text{s}^{-1}$,\n- Characteristic length $L = 1.0 \\times 10^{-4}\\ \\text{m}$,\n- Total dynamic viscosity $\\eta = 1.0 \\times 10^{-1}\\ \\text{Pa}\\,\\text{s}$,\n- Density $\\rho = 1.0 \\times 10^{3}\\ \\text{kg}\\,\\text{m}^{-3}$,\n- Polymer relaxation time $\\lambda = 5.0 \\times 10^{-1}\\ \\text{s}$,\n\ncompute the Reynolds number, the Weissenberg number, and the Elasticity number that follow from the nondimensionalization. Round each dimensionless number to three significant figures. Based on the magnitudes of these dimensionless numbers alone, provide a scientifically reasoned classification in the solution as to whether the flow can exhibit elastic turbulence in a suitable geometry, noting any necessary conditions. Express your final numerical answer as a row matrix containing, in order, the Reynolds number, the Weissenberg number, and the Elasticity number. Do not include any units in the final boxed answer.",
            "solution": "The problem as stated is scientifically grounded, well-posed, and objective. All necessary parameters are provided, and they are physically consistent for a microfluidic experiment involving a polymer solution. The task involves standard dimensional analysis of the governing equations of viscoelastic fluid dynamics and the interpretation of the resulting dimensionless numbers, which is a fundamental exercise in the field. Therefore, the problem is valid, and a solution can be constructed.\n\nThe analysis begins with the conservation of linear momentum for a steady, incompressible fluid flow:\n$$\n\\rho (\\mathbf{u} \\cdot \\nabla \\mathbf{u}) = -\\nabla p + \\nabla \\cdot \\boldsymbol{\\tau}\n$$\nHere, $\\rho$ is the fluid density, $\\mathbf{u}$ is the velocity field, $p$ is the pressure, and $\\boldsymbol{\\tau}$ is the extra-stress tensor. For a viscoelastic fluid, this stress tensor comprises both viscous and elastic contributions. The problem provides a total dynamic viscosity $\\eta$, which we will use to characterize the viscous stresses.\n\nWe nondimensionalize the governing equation using the characteristic scales provided: length $L$, velocity $U$, density $\\rho$, viscosity $\\eta$, and polymer relaxation time $\\lambda$. We define dimensionless variables (denoted by a prime) as follows:\n$$\n\\mathbf{u}' = \\frac{\\mathbf{u}}{U}, \\quad \\nabla' = L \\nabla, \\quad p' = \\frac{p}{\\rho U^2}, \\quad \\boldsymbol{\\tau}' = \\frac{\\boldsymbol{\\tau} L}{\\eta U}\n$$\nSubstituting these into the momentum equation and scaling the terms provides insight into the relevant dimensionless groups.\n\nThe inertial term on the left-hand side scales as:\n$$\n|\\rho (\\mathbf{u} \\cdot \\nabla \\mathbf{u})| \\sim \\frac{\\rho U^2}{L}\n$$\nThe viscous stress contribution to the divergence term on the right-hand side scales as:\n$$\n|\\nabla \\cdot \\boldsymbol{\\tau}_{visc}| \\sim \\frac{\\eta U}{L^2}\n$$\nThe first dimensionless number, which compares inertia to viscous stress, is the Reynolds number, $Re$. It is the ratio of the magnitudes of the inertial term to the viscous term:\n$$\nRe = \\frac{\\text{Inertial forces}}{\\text{Viscous forces}} \\sim \\frac{\\rho U^2 / L}{\\eta U / L^2} = \\frac{\\rho U L}{\\eta}\n$$\n\nThe second dimensionless number compares the material's relaxation time, $\\lambda$, to the characteristic time scale of the flow process. The flow time scale is the time it takes for a fluid element to travel the characteristic length $L$ at velocity $U$, which is $t_{flow} = L/U$. The ratio is the Weissenberg number, $Wi$:\n$$\nWi = \\frac{\\text{Relaxation time}}{\\text{Flow time}} = \\frac{\\lambda}{L/U} = \\frac{\\lambda U}{L}\n$$\nThe Weissenberg number quantifies the degree of elastic response in the flow. For $Wi \\gg 1$, the fluid behaves elastically as the deformation rate is much faster than the fluid's ability to relax stress.\n\nThe third dimensionless number compares elastic effects to inertia. This is conventionally given by the Elasticity number, $El$, which is defined as the ratio of the Weissenberg number to the Reynolds number:\n$$\nEl = \\frac{Wi}{Re} = \\frac{\\lambda U / L}{\\rho U L / \\eta} = \\frac{\\lambda \\eta}{\\rho L^2}\n$$\nThis number is independent of the flow velocity $U$ and represents a ratio of material and geometric properties. It compares the viscoelastic time scale of the fluid ($\\lambda$) to the time scale for viscous diffusion of momentum ($\\rho L^2 / \\eta$). A large $El$ indicates that elastic effects are significant compared to inertial effects.\n\nNext, we compute the values of these dimensionless numbers using the provided parameters:\n-   $U = 5.0 \\times 10^{-2}\\ \\text{m}\\,\\text{s}^{-1}$\n-   $L = 1.0 \\times 10^{-4}\\ \\text{m}$\n-   $\\eta = 1.0 \\times 10^{-1}\\ \\text{Pa}\\,\\text{s}$\n-   $\\rho = 1.0 \\times 10^{3}\\ \\text{kg}\\,\\text{m}^{-3}$\n-   $\\lambda = 5.0 \\times 10^{-1}\\ \\text{s}$\n\nThe Reynolds number is:\n$$\nRe = \\frac{\\rho U L}{\\eta} = \\frac{(1.0 \\times 10^{3}) \\times (5.0 \\times 10^{-2}) \\times (1.0 \\times 10^{-4})}{1.0 \\times 10^{-1}} = \\frac{5.0 \\times 10^{-3}}{1.0 \\times 10^{-1}} = 5.0 \\times 10^{-2}\n$$\nRounding to three significant figures, $Re = 5.00 \\times 10^{-2}$.\n\nThe Weissenberg number is:\n$$\nWi = \\frac{\\lambda U}{L} = \\frac{(5.0 \\times 10^{-1}) \\times (5.0 \\times 10^{-2})}{1.0 \\times 10^{-4}} = \\frac{2.5 \\times 10^{-2}}{1.0 \\times 10^{-4}} = 2.5 \\times 10^{2}\n$$\nRounding to three significant figures, $Wi = 2.50 \\times 10^{2}$.\n\nThe Elasticity number is:\n$$\nEl = \\frac{Wi}{Re} = \\frac{2.50 \\times 10^{2}}{5.00 \\times 10^{-2}} = 5.0 \\times 10^{3}\n$$\nAlternatively, using its definition:\n$$\nEl = \\frac{\\lambda \\eta}{\\rho L^2} = \\frac{(5.0 \\times 10^{-1}) \\times (1.0 \\times 10^{-1})}{(1.0 \\times 10^{3}) \\times (1.0 \\times 10^{-4})^2} = \\frac{5.0 \\times 10^{-2}}{1.0 \\times 10^{-5}} = 5.0 \\times 10^{3}\n$$\nRounding to three significant figures, $El = 5.00 \\times 10^{3}$.\n\nFinally, we classify the flow regime based on these values. The phenomenon of elastic turbulence is a chaotic flow state that arises in viscoelastic fluids due to purely elastic instabilities, in the absence of significant inertia. The conditions for its occurrence are:\n1.  A very low Reynolds number, typically $Re \\ll 1$. Our calculated value is $Re = 0.05$, which indicates the flow is in the creeping regime where inertial effects are negligible. Classical, inertia-driven turbulence is not possible.\n2.  A high Weissenberg number, typically $Wi \\gg 1$. Our value is $Wi = 250$, indicating that elastic stresses are extremely large compared to viscous stresses. The polymers are stretched significantly by the flow, storing substantial elastic energy.\n3.  A flow geometry with curved streamlines. The problem statement explicitly allows for this possibility. A purely elastic instability, driven by tension in stretched polymers along curved streamlines, can trigger chaotic dynamics under these conditions.\n\nThe calculated dimensionless numbers, $Re \\ll 1$ and $Wi \\gg 1$, are the defining characteristics of the elastic turbulence regime. The very large elasticity number, $El = 5000$, further underscores the overwhelming dominance of elastic effects over inertial ones. Therefore, given a suitable geometry with curvature, the flow is predicted to be in the elastic turbulence regime.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 5.00 \\times 10^{-2} & 2.50 \\times 10^{2} & 5.00 \\times 10^{3} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Robust numerical simulation of elastic turbulence requires methods that respect the physical constraints of the underlying polymer models. This computational practice addresses the critical challenge of maintaining the positive-definiteness of the polymer conformation tensor, a property often violated by simple numerical schemes in strong, chaotic flows. By implementing and contrasting a naive integrator with a positivity-preserving operator-splitting scheme, you will gain hands-on experience with the techniques necessary for stable and accurate viscoelastic simulations .",
            "id": "4084943",
            "problem": "Consider a spatially homogeneous dilute polymer solution modeled by a conformation tensor $C(t) \\in \\mathbb{R}^{2 \\times 2}$, which represents the second moment of the polymer end-to-end vector and must remain Symmetric Positive Definite (SPD) at all times. In dimensionless form, the Oldroyd-B homogeneous constitutive evolution driven by a prescribed time-dependent velocity gradient is characterized by a linear relaxation of $C$ towards the identity tensor $I$ at rate $1/Wi$, together with affine deformation by the velocity gradient $G(t) \\in \\mathbb{R}^{2 \\times 2}$. The fundamental base for this problem is that $C$ is a covariance-like tensor and must satisfy $v^{\\top} C v > 0$ for every nonzero vector $v$, and that the continuous-time affine deformation $C(t) = M(t) C(0) M(t)^{\\top}$ with $M(t)$ generated by $G(t)$ preserves positive definiteness when $C(0)$ is SPD. Additionally, a relaxation step that updates $C$ towards $I$ via convex combination preserves SPD.\n\nYour task is to design and implement a computational verification of the positivity of $C(t)$ under numerical time integration, and to assess convergence of a positivity-preserving scheme. All quantities in this problem are dimensionless; if angles appear inside trigonometric functions, they must be in radians.\n\nPrescribe the velocity gradient at discrete time $t_k$ as\n$$\nG_k = \\begin{pmatrix}\n0 & \\gamma_k \\\\\n-\\gamma_k & s_k\n\\end{pmatrix},\n$$\nwhere\n$$\n\\gamma_k = \\omega \\sin(2\\pi \\phi_k), \\quad s_k = s_0 + \\epsilon \\sin(2\\pi \\psi_k),\n$$\nand $(\\phi_k)$ and $(\\psi_k)$ are sequences generated by the logistic map\n$$\nx_{k+1} = r x_k (1 - x_k),\n$$\nwith $r = 4$ and given seeds $\\phi_0 \\in (0,1)$, $\\psi_0 \\in (0,1)$. This deterministic chaotic source mimics fluctuating stretching typical of elastic turbulence and chaotic polymer stretching.\n\nImplement two numerical time-stepping schemes for the evolution of $C$ over $N$ steps with step size $\\Delta t$:\n1. A naive explicit scheme:\n$$\nC_{k+1}^{\\mathrm{E}} = C_k^{\\mathrm{E}} + \\Delta t \\left( G_k C_k^{\\mathrm{E}} + C_k^{\\mathrm{E}} G_k^{\\top} - \\frac{1}{Wi}\\left( C_k^{\\mathrm{E}} - I \\right) \\right).\n$$\n2. A positivity-preserving operator-splitting scheme based on affine deformation and relaxation:\n$$\nM_k = \\exp\\left(G_k \\Delta t\\right), \\qquad \\alpha = \\exp\\left(-\\frac{\\Delta t}{Wi}\\right),\n$$\n$$\n\\widetilde{C}_{k+1} = M_k \\left( (1 - \\alpha) I + \\alpha \\widetilde{C}_k \\right) M_k^{\\top}.\n$$\nIt is known from the foundational properties that the exact affine deformation update $C \\mapsto M C M^{\\top}$ with $M$ invertible preserves SPD, and that convex relaxation $C \\mapsto (1-\\alpha) I + \\alpha C$ with $\\alpha \\in (0,1)$ preserves SPD. Therefore, their composition preserves SPD when implemented exactly.\n\nVerification tasks:\n- For the explicit scheme, perform eigenvalue checks at each step: compute the smallest eigenvalue $\\lambda_{\\min}(C_k^{\\mathrm{E}})$ using an eigenvalue decomposition for symmetric matrices, and declare a violation if any $\\lambda_{\\min}(C_k^{\\mathrm{E}}) \\leq \\tau$, with tolerance $\\tau = 10^{-12}$ to account for floating-point round-off. If a violation is detected, apply the corrective strategy of eigenvalue clipping for continuation (replace any nonpositive eigenvalue by $\\tau$ and reconstruct $C$), but record that the violation occurred.\n- For the operator-splitting scheme, similarly track $\\lambda_{\\min}(\\widetilde{C}_k)$ and verify that no violations occur with the exact matrix exponential update.\n\nConvergence assessment:\n- For the operator-splitting scheme, compute the final conformation tensor at time $T$ with step size $\\Delta t$ and with step size $\\Delta t/2$ (both starting from the same initial tensor), and report the Frobenius norm of the difference between the two final tensors,\n$$\n\\| \\widetilde{C}^{\\Delta t}(T) - \\widetilde{C}^{\\Delta t/2}(T) \\|_F,\n$$\nwhich should decrease as $\\Delta t$ decreases for a first-order splitting scheme.\n\nImplementation details:\n- Use the given chaotic velocity gradient defined by $(\\phi_k)$ and $(\\psi_k)$ sequences and parameters.\n- Work entirely in $2 \\times 2$ tensor space.\n- Symmetrize numerically computed tensors after each update via $C \\leftarrow \\frac{1}{2}(C + C^{\\top})$ to mitigate asymmetry from floating-point arithmetic.\n- Angles inside $\\sin(\\cdot)$ are measured in radians.\n\nTest suite:\nRun the verification and convergence assessment for the following four parameter sets. In each case, $N$ is the nearest integer to $T/\\Delta t$ and the simulation time is $N \\Delta t$.\n\nCase A (happy path):\n- $Wi = 1.0$, $\\Delta t = 0.01$, $T = 1.0$, $s_0 = 0.5$, $\\epsilon = 0.5$, $\\omega = 2.0$, $\\phi_0 = 0.314159$, $\\psi_0 = 0.271828$, $C(0) = I$.\n\nCase B (large time step, strong stretching, potential explicit violation):\n- $Wi = 2.0$, $\\Delta t = 0.2$, $T = 2.0$, $s_0 = 0.5$, $\\epsilon = 2.0$, $\\omega = 8.0$, $\\phi_0 = 0.123456$, $\\psi_0 = 0.654321$, $C(0) = I$.\n\nCase C (high Weissenberg number, moderate step size):\n- $Wi = 10.0$, $\\Delta t = 0.05$, $T = 1.5$, $s_0 = 0.0$, $\\epsilon = 1.5$, $\\omega = 5.0$, $\\phi_0 = 0.435$, $\\psi_0 = 0.781$, $C(0) = I$.\n\nCase D (near-singular initial condition):\n- $Wi = 1.0$, $\\Delta t = 0.1$, $T = 1.0$, $s_0 = -0.3$, $\\epsilon = 1.0$, $\\omega = 3.0$, $\\phi_0 = 0.9$, $\\psi_0 = 0.4$, $C(0) = \\mathrm{diag}(10^{-8}, 1.0)$.\n\nRequired outputs:\nFor each case, compute and return:\n- A boolean indicating whether the explicit scheme maintained strict positivity (no eigenvalue violations against the tolerance) throughout the simulation.\n- A boolean indicating whether the operator-splitting scheme maintained strict positivity throughout the simulation.\n- A float equal to the Frobenius norm $\\| \\widetilde{C}^{\\Delta t}(T) - \\widetilde{C}^{\\Delta t/2}(T) \\|_F$ for the operator-splitting scheme.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,\\dots]$), ordered case-by-case as\n$$\n[\\text{A}_{\\mathrm{explicit}}, \\text{A}_{\\mathrm{split}}, \\text{A}_{\\mathrm{conv}}, \\text{B}_{\\mathrm{explicit}}, \\text{B}_{\\mathrm{split}}, \\text{B}_{\\mathrm{conv}}, \\text{C}_{\\mathrm{explicit}}, \\text{C}_{\\mathrm{split}}, \\text{C}_{\\mathrm{conv}}, \\text{D}_{\\mathrm{explicit}}, \\text{D}_{\\mathrm{split}}, \\text{D}_{\\mathrm{conv}}].\n$$\nAll boolean entries are either the keywords True or False, and all floats are in dimensionless units.",
            "solution": "The problem requires the implementation and validation of numerical schemes for the time evolution of a $2 \\times 2$ symmetric positive definite (SPD) conformation tensor, $C(t)$, in a dilute polymer solution. The governing dynamics are described by the Oldroyd-B model under a spatially homogeneous, time-dependent velocity gradient $G(t)$. The core tasks are to compare a naive explicit scheme against a positivity-preserving operator-splitting scheme and to assess the convergence of the latter.\n\nFirst, the physical model for the evolution of the conformation tensor $C(t)$ is given by the ordinary differential equation:\n$$\n\\frac{dC}{dt} = G(t)C(t) + C(t)G(t)^{\\top} - \\frac{1}{Wi}(C(t) - I)\n$$\nwhere $Wi$ is the Weissenberg number, $I$ is the identity tensor, and $G(t)$ is the velocity gradient. The tensor $C(t)$ must remain SPD for all time $t \\geq 0$ if $C(0)$ is SPD. This physical constraint is challenging to maintain with standard numerical integrators.\n\nThe velocity gradient at discrete time steps $t_k = k \\Delta t$ is prescribed as a stochastically driven rotational and extensional flow:\n$$\nG_k = \\begin{pmatrix} 0 & \\gamma_k \\\\ -\\gamma_k & s_k \\end{pmatrix}\n$$\nThe components $\\gamma_k$ and $s_k$ are generated using deterministic chaos to mimic turbulent fluctuations.\n$$\n\\gamma_k = \\omega \\sin(2\\pi \\phi_k), \\quad s_k = s_0 + \\epsilon \\sin(2\\pi \\psi_k)\n$$\nThe sequences $(\\phi_k)$ and $(\\psi_k)$ are derived from the logistic map, $x_{k+1} = r x_k (1 - x_k)$ with $r=4$, which for seeds $\\phi_0, \\psi_0 \\in (0,1)$ generates chaotic sequences within the interval $(0,1)$. This provides a non-trivial, fluctuating driving force for the system. An auxiliary function is designed to generate these sequences for a given number of steps.\n\nTwo numerical schemes are implemented and compared.\n\n1.  **Naive Explicit Scheme (Forward Euler)**:\n    This scheme discretizes the governing ODE using a first-order forward difference:\n    $$\n    C_{k+1}^{\\mathrm{E}} = C_k^{\\mathrm{E}} + \\Delta t \\left( G_k C_k^{\\mathrm{E}} + C_k^{\\mathrm{E}} G_k^{\\top} - \\frac{1}{Wi}\\left( C_k^{\\mathrm{E}} - I \\right) \\right)\n    $$\n    This method is simple to implement but is not guaranteed to preserve the SPD property of $C$, especially for large time steps $\\Delta t$ or strong flows (large norms of $G_k$). To verify its performance, we compute the eigenvalues of the resulting tensor $C_{k+1}^{\\mathrm{E}}$ at each step. A violation of positivity is declared if the smallest eigenvalue, $\\lambda_{\\min}(C_{k+1}^{\\mathrm{E}})$, falls below a small positive tolerance $\\tau = 10^{-12}$ (to account for floating-point precision). If a violation occurs, the boolean flag for positivity is set to `False`. For the simulation to continue, a corrective clipping procedure is applied: the tensor is diagonalized, any non-positive eigenvalue is replaced by $\\tau$, and the tensor is reconstructed. This allows the simulation to complete while recording that the scheme failed to preserve positivity.\n\n2.  **Positivity-Preserving Operator-Splitting Scheme**:\n    This scheme is based on splitting the governing ODE into two sub-problems, each of which can be solved exactly and preserves the SPD property.\n    (a) Relaxation: $\\frac{dC}{dt} = - \\frac{1}{Wi}(C - I)$\n    (b) Deformation: $\\frac{dC}{dt} = G(t)C(t) + C(t)G(t)^{\\top}$\n    The exact solution to (a) over a time step $\\Delta t$ is $C(\\Delta t) = (1 - \\alpha)I + \\alpha C(0)$, where $\\alpha = \\exp(-\\Delta t/Wi)$. This is a convex combination of two SPD tensors ($I$ and $C(0)$) and is therefore SPD.\n    The exact solution to (b) over $\\Delta t$ (assuming $G$ is constant, $G_k$) is $C(\\Delta t) = M_k C(0) M_k^{\\top}$, where $M_k = \\exp\\left(G_k \\Delta t\\right)$ is the matrix exponential. This congruence transformation by an invertible matrix $M_k$ preserves the SPD property.\n    \n    The splitting scheme composes these exact solutions:\n    $$\n    \\widetilde{C}_{k+1} = M_k \\left( (1 - \\alpha) I + \\alpha \\widetilde{C}_k \\right) M_k^{\\top}\n    $$\n    This corresponds to a first-order Lie-Trotter splitting (relaxation followed by deformation). By construction, this scheme mathematically guarantees that if $\\widetilde{C}_k$ is SPD, then $\\widetilde{C}_{k+1}$ will also be SPD. The implementation uses `scipy.linalg.expm` to compute the matrix exponential. As with the explicit scheme, the smallest eigenvalue is monitored at each step to numerically verify this property.\n\nA crucial implementation detail for both schemes is the enforcement of symmetry. After each update step, the tensor $C$ is symmetrized via the operation $C \\leftarrow \\frac{1}{2}(C + C^{\\top})$ to mitigate the accumulation of numerical floating-point errors that can break symmetry.\n\n**Convergence Assessment**:\nThe temporal convergence of the operator-splitting scheme is assessed. This is a first-order scheme, so the error should be proportional to $\\Delta t$. To verify this, for each test case, we run two simulations up to a \"target\" time $T$.\n-   A coarse simulation with time step $\\Delta t_1 = \\Delta t$ for $N_1 = \\text{round}(T/\\Delta t)$ steps, yielding a final tensor $\\widetilde{C}^{\\Delta t}(T_{eff})$.\n-   A fine simulation with time step $\\Delta t_2 = \\Delta t_1/2$ for $N_2 = 2 N_1$ steps, yielding $\\widetilde{C}^{\\Delta t/2}(T_{eff})$.\nBoth simulations run for the same total effective duration $T_{eff} = N_1 \\Delta t_1$. The difference between the final tensors is quantified using the Frobenius norm:\n$$\n\\text{Error} = \\| \\widetilde{C}^{\\Delta t}(T_{eff}) - \\widetilde{C}^{\\Delta t/2}(T_{eff}) \\|_F\n$$\nThis error metric is computed for each parameter case.\n\nThe overall algorithm is structured to iterate through each of the four test cases. For each case, it runs the explicit simulation, the coarse splitting simulation, and the fine splitting simulation. It then collects the three required outputs: the positivity-maintained boolean for the explicit scheme, the positivity-maintained boolean for the splitting scheme, and the Frobenius norm for convergence assessment. These results are aggregated into a single list for the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Main function to run the verification and convergence assessment for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Happy path\n        {'name': 'A', 'Wi': 1.0, 'dt': 0.01, 'T': 1.0, 's0': 0.5, 'eps': 0.5, 'omega': 2.0, \n         'phi0': 0.314159, 'psi0': 0.271828, 'C0': np.identity(2)},\n        # Case B: Large time step, strong stretching\n        {'name': 'B', 'Wi': 2.0, 'dt': 0.2, 'T': 2.0, 's0': 0.5, 'eps': 2.0, 'omega': 8.0, \n         'phi0': 0.123456, 'psi0': 0.654321, 'C0': np.identity(2)},\n        # Case C: High Weissenberg number\n        {'name': 'C', 'Wi': 10.0, 'dt': 0.05, 'T': 1.5, 's0': 0.0, 'eps': 1.5, 'omega': 5.0, \n         'phi0': 0.435, 'psi0': 0.781, 'C0': np.identity(2)},\n        # Case D: Near-singular initial condition\n        {'name': 'D', 'Wi': 1.0, 'dt': 0.1, 'T': 1.0, 's0': -0.3, 'eps': 1.0, 'omega': 3.0, \n         'phi0': 0.9, 'psi0': 0.4, 'C0': np.diag([1e-8, 1.0])}\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = run_case(case)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef logistic_map_sequence(seed, num_steps):\n    \"\"\"Generates a sequence of values from the logistic map x_k+1 = 4*x_k*(1-x_k).\"\"\"\n    seq = np.zeros(num_steps)\n    x = seed\n    for i in range(num_steps):\n        seq[i] = x\n        x = 4.0 * x * (1.0 - x)\n    return seq\n\ndef run_case(params):\n    \"\"\"\n    Runs both schemes for a given parameter set and computes the required outputs.\n    \"\"\"\n    Wi, dt, T = params['Wi'], params['dt'], params['T']\n    s0, eps, omega = params['s0'], params['eps'], params['omega']\n    phi0, psi0, C0 = params['phi0'], params['psi0'], params['C0']\n    \n    n_steps = int(round(T / dt))\n    tau = 1e-12\n    I = np.identity(2)\n\n    # Run Explicit Scheme\n    explicit_positivity_maintained = run_explicit_scheme(n_steps, dt, Wi, s0, eps, omega, phi0, psi0, C0, I, tau)\n    \n    # Run Operator-Splitting Scheme for positivity check and convergence\n    C_coarse, split_positivity_maintained = run_split_scheme(n_steps, dt, Wi, s0, eps, omega, phi0, psi0, C0, I, tau)\n    \n    n_steps_fine = 2 * n_steps\n    dt_fine = dt / 2.0\n    C_fine, _ = run_split_scheme(n_steps_fine, dt_fine, Wi, s0, eps, omega, phi0, psi0, C0, I, tau)\n    \n    # Convergence Assessment\n    conv_norm = np.linalg.norm(C_coarse - C_fine, 'fro')\n\n    return explicit_positivity_maintained, split_positivity_maintained, conv_norm\n\ndef run_explicit_scheme(n_steps, dt, Wi, s0, eps, omega, phi0, psi0, C0, I, tau):\n    \"\"\"Simulates the conformation tensor evolution using the explicit Euler scheme.\"\"\"\n    C = np.copy(C0)\n    positivity_maintained = True\n    \n    phi_seq = logistic_map_sequence(phi0, n_steps)\n    psi_seq = logistic_map_sequence(psi0, n_steps)\n\n    for k in range(n_steps):\n        gamma_k = omega * np.sin(2 * np.pi * phi_seq[k])\n        s_k = s0 + eps * np.sin(2 * np.pi * psi_seq[k])\n        Gk = np.array([[0.0, gamma_k], [-gamma_k, s_k]])\n        \n        dCdt = Gk @ C + C @ Gk.T - (1.0 / Wi) * (C - I)\n        C += dt * dCdt\n        \n        C = 0.5 * (C + C.T)  # Symmetrize\n        \n        evals, evecs = np.linalg.eigh(C)\n        if np.min(evals) <= tau:\n            positivity_maintained = False\n            # Apply eigenvalue clipping for continuation\n            evals[evals <= tau] = tau\n            C = evecs @ np.diag(evals) @ evecs.T\n            C = 0.5 * (C + C.T) # Re-symmetrize after reconstruction\n\n    return positivity_maintained\n\ndef run_split_scheme(n_steps, dt, Wi, s0, eps, omega, phi0, psi0, C0, I, tau):\n    \"\"\"Simulates the conformation tensor evolution using the operator-splitting scheme.\"\"\"\n    C = np.copy(C0)\n    positivity_maintained = True\n    \n    phi_seq = logistic_map_sequence(phi0, n_steps)\n    psi_seq = logistic_map_sequence(psi0, n_steps)\n    \n    alpha = np.exp(-dt / Wi)\n\n    for k in range(n_steps):\n        gamma_k = omega * np.sin(2 * np.pi * phi_seq[k])\n        s_k = s0 + eps * np.sin(2 * np.pi * psi_seq[k])\n        Gk = np.array([[0.0, gamma_k], [-gamma_k, s_k]])\n        \n        # Relaxation step\n        C_relaxed = (1.0 - alpha) * I + alpha * C\n        \n        # Deformation step\n        Mk = expm(Gk * dt)\n        C = Mk @ C_relaxed @ Mk.T\n        \n        C = 0.5 * (C + C.T)  # Symmetrize\n        \n        evals = np.linalg.eigh(C)[0]\n        if np.min(evals) <= tau:\n            positivity_maintained = False\n            # No clipping required, just record the violation\n            \n    return C, positivity_maintained\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "To understand the consequences of elastic turbulence, we must quantify its chaotic nature and its effect on polymer molecules. This data analysis exercise introduces the finite-time Lyapunov exponent (FTLE) as a key diagnostic for chaotic mixing. You will simulate Lagrangian tracer trajectories in a synthetic turbulent flow, compute the resulting distribution of FTLEs, and use this statistical information to predict the extent of polymer stretching, bridging the gap between flow kinematics and material response .",
            "id": "4085018",
            "problem": "Consider a smooth, two-dimensional, time-dependent linear flow used as a synthetic model of elastic turbulence at the scale of Lagrangian tracers. A pair of nearby Lagrangian tracers with positions $\\mathbf{x}(t)$ and $\\mathbf{x}(t) + \\delta \\mathbf{x}(t)$ evolves under the velocity gradient tensor $\\mathbf{A}(t)$ according to the linearized separation dynamics $\\mathrm{d}\\delta \\mathbf{x}/\\mathrm{d}t = \\mathbf{A}(t)\\,\\delta \\mathbf{x}$. The finite-time Lyapunov exponent (FTLE) over a time window of length $T$ is defined from first principles by\n$$\n\\Lambda_T \\equiv \\frac{1}{T}\\,\\ln\\left(\\frac{\\|\\delta \\mathbf{x}(T)\\|}{\\|\\delta \\mathbf{x}(0)\\|}\\right),\n$$\nwhich quantifies the mean exponential rate of separation growth.\n\nFor a Hookean dumbbell polymer model with relaxation time $\\tau$ in a smooth flow, the end-to-end vector $\\mathbf{R}(t)$ satisfies, in the absence of thermal noise and finite extensibility, the linear equation $\\mathrm{d}\\mathbf{R}/\\mathrm{d}t = \\nabla \\mathbf{u}(\\mathbf{x}(t),t)\\,\\mathbf{R} - \\mathbf{R}/\\tau$, where $\\nabla \\mathbf{u}$ is the velocity gradient evaluated along the tracer path. In a strongly mixing flow where the polymer orientation tends to align with the most stretched direction, the polymer extension magnitude obeys the approximation\n$$\n\\|\\mathbf{R}(T)\\| \\approx \\|\\mathbf{R}(0)\\|\\,\\exp\\!\\left(\\int_0^T \\sigma_{\\max}(t)\\,\\mathrm{d}t - \\frac{T}{\\tau}\\right),\n$$\nwhere $\\sigma_{\\max}(t)$ is the largest instantaneous stretching rate felt by the polymer, which coincides with the instantaneous growth rate of $\\|\\delta \\mathbf{x}(t)\\|$ for infinitesimal separations. Consequently, using the definition of the finite-time Lyapunov exponent, the polymer extension factor over the window of length $T$ along a trajectory is approximately\n$$\n\\frac{\\|\\mathbf{R}(T)\\|}{\\|\\mathbf{R}(0)\\|} \\approx \\exp\\!\\left[\\left(\\Lambda_T - \\frac{1}{\\tau}\\right) T\\right].\n$$\nIn this problem, you will compute the distribution of $\\Lambda_T$ from an ensemble of Lagrangian tracer pairs in a prescribed time-dependent linear flow, and then connect that distribution to the statistics of polymer extension via the above relation.\n\nFlow model. For each pair index $k \\in \\{0,1,\\dots,K-1\\}$ with $K=12$, define a time-dependent $2\\times 2$ velocity-gradient tensor $\\mathbf{A}_k(t)$ as\n$$\n\\mathbf{A}_k(t) = \\mathbf{R}\\!\\left(\\theta_k(t)\\right)\\,\\begin{bmatrix} \\sigma_k(t) & 0 \\\\ 0 & -\\sigma_k(t) \\end{bmatrix}\\,\\mathbf{R}\\!\\left(-\\theta_k(t)\\right) + r_0\\,\\mathbf{J},\n$$\nwhere $\\mathbf{R}(\\theta) = \\begin{bmatrix} \\cos\\theta & -\\sin\\theta\\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix}$ is the planar rotation matrix, $\\mathbf{J}=\\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix}$, and\n$$\n\\sigma_k(t) = s_{\\mathrm{mean}} + s_{\\mathrm{amp}}\\,\\sin(\\omega\\,t + \\phi_k), \\qquad \\theta_k(t) = \\theta_0 + \\eta\\,\\sin(\\omega_2\\,t + \\psi_k).\n$$\nUse the fixed parameters $s_{\\mathrm{mean}}=0.7\\,\\text{s}^{-1}$, $s_{\\mathrm{amp}}=0.3\\,\\text{s}^{-1}$, $\\omega=1.7\\,\\text{rad/s}$, $\\theta_0=0.25\\,\\text{rad}$, $\\eta=0.33\\,\\text{rad}$, $\\omega_2=2.3\\,\\text{rad/s}$, and $r_0=0.2\\,\\text{s}^{-1}$. Angles are in radians, time is in seconds, and rates are in $\\text{s}^{-1}$. For each $k$, set the phases as $\\phi_k = 0.3\\,k$ and $\\psi_k = 0.7\\,k$.\n\nTrajectory ensemble. For each $k$, define the base initial position $\\mathbf{x}_k(0) = [\\cos(0.5\\,k),\\,\\sin(0.5\\,k)]^\\top$ and the initial separation vector $\\delta \\mathbf{x}_k(0) = d_0\\,[\\cos \\alpha_k,\\, \\sin \\alpha_k]^\\top$ with $d_0=10^{-6}$ and $\\alpha_k = 0.2 + 0.4\\,k$. Evolve each base tracer and its nearby partner under the same flow $\\mathbf{A}_k(t)$ for a duration $T=10.0\\,\\text{s}$ using a time step $\\Delta t = 0.01\\,\\text{s}$ and the exact one-step linear propagator $\\exp\\!\\left(\\mathbf{A}_k(t_n)\\,\\Delta t\\right)$ at times $t_n = n\\,\\Delta t$ for $n=0,1,\\dots, N-1$ with $N = T/\\Delta t$. The evolution rule is $\\mathbf{x}_{n+1} = \\exp\\!\\left(\\mathbf{A}_k(t_n)\\,\\Delta t\\right)\\,\\mathbf{x}_n$ and $\\delta \\mathbf{x}_{n+1} = \\exp\\!\\left(\\mathbf{A}_k(t_n)\\,\\Delta t\\right)\\,\\delta \\mathbf{x}_n$.\n\nDiagnostics. For each pair $k$, compute the finite-time Lyapunov exponent\n$$\n\\Lambda_T^{(k)} = \\frac{1}{T}\\,\\ln\\left(\\frac{\\|\\delta \\mathbf{x}_k(T)\\|}{\\|\\delta \\mathbf{x}_k(0)\\|}\\right).\n$$\nFor a Hookean dumbbell polymer with relaxation time $\\tau$, the corresponding polymer extension factor along each path is approximated by $\\exp\\!\\left[\\left(\\Lambda_T^{(k)} - \\tau^{-1}\\right) T\\right]$, ignoring thermal noise and finite extensibility.\n\nTasks. Your program must:\n- Generate the ensemble of $K=12$ pairs as specified.\n- Compute the set $\\{\\Lambda_T^{(k)}\\}_{k=0}^{K-1}$.\n- For each test case listed below (the test suite), compute:\n  1. The sample mean $\\overline{\\Lambda}_T = \\frac{1}{K}\\sum_{k=0}^{K-1} \\Lambda_T^{(k)}$ in $\\text{s}^{-1}$.\n  2. The fraction $f$ (expressed as a decimal number) of pairs for which $\\Lambda_T^{(k)} > 1/\\tau$.\n  3. The sample mean polymer extension factor $\\overline{E} = \\frac{1}{K}\\sum_{k=0}^{K-1} \\exp\\!\\left[\\left(\\Lambda_T^{(k)} - \\tau^{-1}\\right) T\\right]$ (dimensionless).\n\nAll trigonometric functions use angles in radians. Express all time-related rates in $\\text{s}^{-1}$, and report the extension factor as a dimensionless float.\n\nTest suite. Use the following relaxation times:\n- Case A (happy path, above threshold): $\\tau = 2.0\\,\\text{s}$.\n- Case B (near threshold): $\\tau = 1.5\\,\\text{s}$.\n- Case C (below threshold): $\\tau = 0.8\\,\\text{s}$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one sublist per test case in the order [Case A, Case B, Case C]. Each sublist must contain three floats in the order $[\\overline{\\Lambda}_T, f, \\overline{E}]$, each rounded to six digits after the decimal point. For example: \"[[0.123456,0.500000,1.234568],[...],[...]]\".",
            "solution": "The problem is valid. It is a well-posed computational problem in the field of computational complex fluids, grounded in the established principles of Lagrangian dynamics and polymer physics. All parameters, equations, and initial conditions are clearly specified, allowing for a unique and verifiable solution.\n\nThe primary objective is to compute the finite-time Lyapunov exponents (FTLEs) for an ensemble of trajectories in a specified time-dependent linear flow, and then use these statistics to analyze the stretching of Hookean dumbbells.\n\nThe solution proceeds in several steps:\n1.  Define the time-dependent velocity gradient tensor $\\mathbf{A}_k(t)$ for each of the $K=12$ trajectories.\n2.  For each trajectory $k$, numerically integrate the evolution of an infinitesimal separation vector $\\delta \\mathbf{x}_k(t)$ over a time interval $T=10.0\\,\\text{s}$.\n3.  Calculate the FTLE, $\\Lambda_T^{(k)}$, for each trajectory from the growth of the separation vector.\n4.  Using the computed set of FTLEs, $\\{\\Lambda_T^{(k)}\\}_{k=0}^{K-1}$, calculate the required statistical diagnostics for three different polymer relaxation times $\\tau$.\n\n**1. Velocity-Gradient Tensor**\n\nFor each trajectory index $k \\in \\{0, 1, \\dots, 11\\}$, the $2 \\times 2$ velocity-gradient tensor $\\mathbf{A}_k(t)$ is given by:\n$$\n\\mathbf{A}_k(t) = \\mathbf{R}\\!\\left(\\theta_k(t)\\right)\\,\\begin{bmatrix} \\sigma_k(t) & 0\\\\ 0 & -\\sigma_k(t)\\end{bmatrix}\\,\\mathbf{R}\\!\\left(-\\theta_k(t)\\right) + r_0\\,\\mathbf{J}\n$$\nwhere $\\mathbf{R}(\\theta) = \\begin{bmatrix} \\cos\\theta & -\\sin\\theta\\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix}$ is a rotation matrix and $\\mathbf{J}=\\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix}$ is the generator of rotations. The time-dependent strain rate $\\sigma_k(t)$ and strain orientation $\\theta_k(t)$ are:\n$$\n\\sigma_k(t) = s_{\\mathrm{mean}} + s_{\\mathrm{amp}}\\,\\sin(\\omega\\,t + \\phi_k)\n$$\n$$\n\\theta_k(t) = \\theta_0 + \\eta\\,\\sin(\\omega_2\\,t + \\psi_k)\n$$\nThe parameters are fixed: $s_{\\mathrm{mean}}=0.7\\,\\text{s}^{-1}$, $s_{\\mathrm{amp}}=0.3\\,\\text{s}^{-1}$, $\\omega=1.7\\,\\text{rad/s}$, $\\theta_0=0.25\\,\\text{rad}$, $\\eta=0.33\\,\\text{rad}$, $\\omega_2=2.3\\,\\text{rad/s}$, and $r_0=0.2\\,\\text{s}^{-1}$. The phases are trajectory-dependent: $\\phi_k = 0.3\\,k$ and $\\psi_k = 0.7\\,k$.\n\nPerforming the matrix multiplication for the first term yields the explicit form of $\\mathbf{A}_k(t)$:\n$$\n\\mathbf{A}_k(t) = \\begin{bmatrix} \\sigma_k(t) \\cos(2\\theta_k(t)) & \\sigma_k(t) \\sin(2\\theta_k(t)) - r_0 \\\\ \\sigma_k(t) \\sin(2\\theta_k(t)) + r_0 & -\\sigma_k(t) \\cos(2\\theta_k(t)) \\end{bmatrix}\n$$\nThis form is computationally efficient.\n\n**2. Numerical Integration of the Separation Vector**\n\nThe evolution of the separation vector is governed by the linear ordinary differential equation $\\mathrm{d}\\delta \\mathbf{x}/\\mathrm{d}t = \\mathbf{A}_k(t)\\,\\delta \\mathbf{x}$. We solve this numerically from $t=0$ to $T=10.0\\,\\text{s}$ using a time step $\\Delta t = 0.01\\,\\text{s}$. The total number of steps is $N = T/\\Delta t = 1000$.\n\nThe problem specifies the update rule for each step from time $t_n=n\\Delta t$ to $t_{n+1}$:\n$$\n\\delta \\mathbf{x}_{n+1} = \\exp\\!\\left(\\mathbf{A}_k(t_n)\\,\\Delta t\\right)\\,\\delta \\mathbf{x}_n\n$$\nThis corresponds to a first-order numerical scheme where $\\mathbf{A}_k(t)$ is assumed constant over each small interval $[t_n, t_{n+1}]$. The matrix exponential, $\\exp(\\mathbf{M})$, is a standard matrix function.\n\nFor each trajectory $k$, the initial separation vector is $\\delta \\mathbf{x}_k(0) = d_0\\,[\\cos \\alpha_k,\\, \\sin \\alpha_k]^\\top$, with initial magnitude $d_0=10^{-6}$ and orientation angle $\\alpha_k = 0.2 + 0.4\\,k$. We initialize $\\delta \\mathbf{x}_k$ at $t=0$ and iteratively apply the update rule for $n=0, 1, \\dots, N-1$ to find the final separation vector $\\delta \\mathbf{x}_k(T)$.\n\n**3. FTLE Calculation**\n\nThe FTLE for each trajectory is defined as:\n$$\n\\Lambda_T^{(k)} = \\frac{1}{T}\\,\\ln\\left(\\frac{\\|\\delta \\mathbf{x}_k(T)\\|}{\\|\\delta \\mathbf{x}_k(0)\\|}\\right)\n$$\nAfter the numerical integration, we compute the Euclidean norm $\\|\\delta \\mathbf{x}_k(T)\\|$ of the final separation vector. Since $\\|\\delta \\mathbf{x}_k(0)\\| = d_0$, we calculate $\\Lambda_T^{(k)}$ for each $k$ and store the results.\n\n**4. Statistical Analysis**\n\nWith the ensemble of FTLEs, $\\{\\Lambda_T^{(k)}\\}_{k=0}^{11}$, we proceed to calculate the diagnostics for each of the three test cases, which are defined by different polymer relaxation times: Case A ($\\tau = 2.0\\,\\text{s}$), Case B ($\\tau = 1.5\\,\\text{s}$), and Case C ($\\tau = 0.8\\,\\text{s}$).\n\nFor each test case, we compute:\n\na. The sample mean FTLE, $\\overline{\\Lambda}_T$:\n$$\n\\overline{\\Lambda}_T = \\frac{1}{K}\\sum_{k=0}^{K-1} \\Lambda_T^{(k)}\n$$\nNote that this quantity is independent of $\\tau$ and will be the same for all three cases.\n\nb. The fraction $f$ of trajectories exhibiting polymer stretching. This occurs when the stretching rate exceeds the relaxation rate, i.e., $\\Lambda_T^{(k)} > 1/\\tau$. We count the number of trajectories satisfying this condition and divide by the total number of trajectories, $K$.\n\nc. The sample mean polymer extension factor, $\\overline{E}$. The extension factor for a single trajectory is approximated by $E_k = \\exp\\!\\left[\\left(\\Lambda_T^{(k)} - \\tau^{-1}\\right) T\\right]$. The mean is:\n$$\n\\overline{E} = \\frac{1}{K}\\sum_{k=0}^{K-1} E_k = \\frac{1}{K}\\sum_{k=0}^{K-1} \\exp\\!\\left[\\left(\\Lambda_T^{(k)} - \\frac{1}{\\tau}\\right) T\\right]\n$$\n\nThe final results are compiled into a list of lists, with each sublist containing the triplet $[\\overline{\\Lambda}_T, f, \\overline{E}]$ for the corresponding test case, with each value rounded to six decimal places.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes FTLE statistics for a synthetic flow model and relates them to polymer extension.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    K = 12\n    s_mean = 0.7\n    s_amp = 0.3\n    omega = 1.7\n    theta_0 = 0.25\n    eta = 0.33\n    omega_2 = 2.3\n    r_0 = 0.2\n    d_0 = 1e-6\n    T = 10.0\n    dt = 0.01\n    N = int(T / dt)\n\n    # Test cases for polymer relaxation time tau\n    test_taus = [2.0, 1.5, 0.8]\n\n    # Trajectory-specific phase and angle parameters\n    ks = np.arange(K)\n    phis = 0.3 * ks\n    psis = 0.7 * ks\n    alphas = 0.2 + 0.4 * ks\n\n    ftle_values = []\n\n    # Iterate over the ensemble of K trajectories\n    for k in range(K):\n        # Set the initial separation vector for trajectory k\n        delta_x = d_0 * np.array([np.cos(alphas[k]), np.sin(alphas[k])])\n\n        # Perform time-stepping integration\n        for n in range(N):\n            t_n = n * dt\n            \n            # Calculate time-dependent components sigma(t) and theta(t)\n            sigma_t = s_mean + s_amp * np.sin(omega * t_n + phis[k])\n            theta_t = theta_0 + eta * np.sin(omega_2 * t_n + psis[k])\n            \n            # Construct the velocity-gradient tensor A_k(t)\n            cos_2theta = np.cos(2 * theta_t)\n            sin_2theta = np.sin(2 * theta_t)\n            \n            A_matrix = np.array([\n                [sigma_t * cos_2theta,        sigma_t * sin_2theta - r_0],\n                [sigma_t * sin_2theta + r_0, -sigma_t * cos_2theta]\n            ])\n            \n            # Compute the one-step propagator and update the separation vector\n            propagator = expm(A_matrix * dt)\n            delta_x = propagator @ delta_x\n            \n        # Compute the FTLE for trajectory k\n        final_norm = np.linalg.norm(delta_x)\n        ftle_k = (1.0 / T) * np.log(final_norm / d_0)\n        ftle_values.append(ftle_k)\n\n    ftle_values = np.array(ftle_values)\n    \n    # Calculate the sample mean FTLE (constant across all test cases)\n    mean_ftle = np.mean(ftle_values)\n\n    all_case_results = []\n\n    # Process each test case\n    for tau in test_taus:\n        # Define the coil-stretch transition threshold\n        threshold = 1.0 / tau\n        \n        # 1. Fraction f of pairs where FTLE > 1/tau\n        count_above_threshold = np.sum(ftle_values > threshold)\n        fraction_f = count_above_threshold / K\n        \n        # 2. Mean polymer extension factor E\n        extension_factors = np.exp((ftle_values - threshold) * T)\n        mean_extension_E = np.mean(extension_factors)\n        \n        # Store the triplet of results for this case\n        case_results = [mean_ftle, fraction_f, mean_extension_E]\n        all_case_results.append(case_results)\n\n    # Format the final output string as specified\n    outer_list_str = []\n    for res_list in all_case_results:\n        # Format each number to 6 decimal places\n        inner_list_str = [f\"{x:.6f}\" for x in res_list]\n        outer_list_str.append(f\"[{','.join(inner_list_str)}]\")\n    \n    final_output_str = f\"[{','.join(outer_list_str)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}