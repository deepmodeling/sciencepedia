{
    "hands_on_practices": [
        {
            "introduction": "发现本构律的最终目标是利用它来预测材料行为。第一个实践提供了一项基础练习：从一个给定的超弹性应变能函数出发，你将计算出相应的应力张量。这项任务旨在强化非线性连续介质力学的基本原理，并巩固抽象的能量势函数与物理上可测量的量之间的联系 。",
            "id": "3748670",
            "problem": "一项数据驱动的多尺度分析汇集了中尺度的应力-应变观测数据，以确定一种可压缩材料的各向同性超弹性应变能密度。该密度是右 Cauchy–Green 变形张量主不变量的函数。设变形梯度为\n$$\nF = \\begin{pmatrix}\n1.2  0.1  0.0 \\\\\n0.0  0.9  0.2 \\\\\n0.0  0.0  1.1\n\\end{pmatrix},\n$$\n并设通过不变量形式发现的应变能密度为\n$$\n\\psi(I_1,I_2,I_3) = \\frac{a_1}{2}\\,(I_1 - 3) + \\frac{a_2}{2}\\,(I_2 - 3) + \\frac{\\kappa}{2}\\,(\\ln J)^2,\\quad J=\\sqrt{I_3},\n$$\n其中系数为 $a_1 = 40$ 兆帕 (MPa)，$a_2 = 10$ 兆帕 (MPa)，以及 $\\kappa = 200$ 兆帕 (MPa)。此处，$C = F^{\\top}F$，主不变量定义为 $I_1 = \\mathrm{tr}(C)$, $I_2 = \\tfrac{1}{2}\\big((\\mathrm{tr}(C))^2 - \\mathrm{tr}(C^2)\\big)$，以及 $I_3 = \\det(C)$。\n\n仅根据这些定义和标准的连续介质力学原理，计算给定 $F$ 的主不变量 $I_1$、$I_2$ 和 $I_3$，然后求出与给定 $\\psi(I_1,I_2,I_3)$ 相一致的第二 Piola–Kirchhoff 应力张量 $S$ 的 $(1,1)$ 分量。将 $S_{11}$ 的最终数值结果以 MPa 为单位表示，并将答案四舍五入到四位有效数字。",
            "solution": "### 解答\n\n解答过程分四个阶段进行：\n1.  计算右 Cauchy-Green 变形张量 $C$。\n2.  计算主不变量 $I_1$、 $I_2$ 和 $I_3$。\n3.  推导第二 Piola-Kirchhoff 应力张量 $S$ 的表达式。\n4.  计算分量 $S_{11}$。\n\n**1. 右 Cauchy-Green 张量 $C$**\n\n右 Cauchy-Green 变形张量 $C$ 定义为 $C = F^{\\top}F$。给定变形梯度 $F$ 及其转置 $F^\\top$：\n$$F = \\begin{pmatrix} 1.2   0.1  0.0 \\\\ 0.0  0.9  0.2 \\\\ 0.0  0.0  1.1 \\end{pmatrix} \\implies F^{\\top} = \\begin{pmatrix} 1.2  0.0  0.0 \\\\ 0.1  0.9  0.0 \\\\ 0.0  0.2  1.1 \\end{pmatrix}$$\n矩阵乘积 $C = F^{\\top}F$ 为：\n$$C = \\begin{pmatrix} 1.2  0.0  0.0 \\\\ 0.1  0.9  0.0 \\\\ 0.0  0.2  1.1 \\end{pmatrix} \\begin{pmatrix} 1.2   0.1  0.0 \\\\ 0.0  0.9  0.2 \\\\ 0.0  0.0  1.1 \\end{pmatrix} = \\begin{pmatrix} 1.44  0.12  0.0 \\\\ 0.12  0.82  0.18 \\\\ 0.0  0.18  1.25 \\end{pmatrix}$$\n\n**2. 主不变量 $I_1, I_2, I_3$**\n\n-   第一个不变量 $I_1$ 是 $C$ 的迹。\n    $$I_1 = \\mathrm{tr}(C) = 1.44 + 0.82 + 1.25 = 3.51$$\n\n-   第三个不变量 $I_3$ 是 $C$ 的行列式。这可以更方便地计算为 $(\\det F)^2$。由于 $F$ 是上三角矩阵，其行列式是其对角元素的乘积。\n    $$\\det(F) = 1.2 \\times 0.9 \\times 1.1 = 1.188$$\n    $$I_3 = \\det(C) = (\\det F)^2 = (1.188)^2 = 1.411344$$\n\n-   第二个不变量 $I_2$ 可以通过公式 $I_2 = \\frac{1}{2}\\big((\\mathrm{tr}(C))^2 - \\mathrm{tr}(C^2)\\big)$ 计算，或者使用主子式计算：$I_2 = C_{11}C_{22} + C_{22}C_{33} + C_{33}C_{11} - (C_{12}^2 + C_{23}^2 + C_{31}^2)$。\n    $$I_2 = (1.44)(0.82) + (0.82)(1.25) + (1.25)(1.44) - \\left( (0.12)^2 + (0.18)^2 + (0.0)^2 \\right)$$\n    $$I_2 = 1.1808 + 1.025 + 1.8 - (0.0144 + 0.0324 + 0)$$\n    $$I_2 = 4.0058 - 0.0468 = 3.959$$\n\n计算出的不变量为：$I_1 = 3.51$，$I_2 = 3.959$，以及 $I_3 = 1.411344$。\n\n**3. 第二 Piola-Kirchhoff 应力张量 $S$**\n\n第二 Piola-Kirchhoff 应力张量 $S$ 通过 $S = 2 \\frac{\\partial \\psi}{\\partial C}$ 与应变能密度函数 $\\psi$ 相关。我们使用链式法则：\n$$S = 2 \\left( \\frac{\\partial \\psi}{\\partial I_1} \\frac{\\partial I_1}{\\partial C} + \\frac{\\partial \\psi}{\\partial I_2} \\frac{\\partial I_2}{\\partial C} + \\frac{\\partial \\psi}{\\partial I_3} \\frac{\\partial I_3}{\\partial C} \\right)$$\n首先，我们求 $\\psi$ 相对于不变量的偏导数。含 $J$ 的项用 $I_3$ 重写：\n$$\\frac{\\kappa}{2}(\\ln J)^2 = \\frac{\\kappa}{2}(\\ln \\sqrt{I_3})^2 = \\frac{\\kappa}{2} \\left( \\frac{1}{2}\\ln I_3 \\right)^2 = \\frac{\\kappa}{8}(\\ln I_3)^2$$\n导数为：\n$$\\frac{\\partial \\psi}{\\partial I_1} = \\frac{a_1}{2}, \\quad \\frac{\\partial \\psi}{\\partial I_2} = \\frac{a_2}{2}, \\quad \\frac{\\partial \\psi}{\\partial I_3} = \\frac{\\kappa}{8} \\cdot 2 (\\ln I_3) \\cdot \\frac{1}{I_3} = \\frac{\\kappa}{4} \\frac{\\ln I_3}{I_3}$$\n不变量相对于 $C$ 的导数是张量微积分中的标准结果：\n$$\\frac{\\partial I_1}{\\partial C} = I, \\quad \\frac{\\partial I_2}{\\partial C} = I_1 I - C, \\quad \\frac{\\partial I_3}{\\partial C} = I_3 C^{-1}$$\n其中 $I$ 是二阶单位张量。将这些代入 $S$ 的表达式中：\n$$S = 2 \\left[ \\left(\\frac{a_1}{2}\\right) I + \\left(\\frac{a_2}{2}\\right) (I_1 I - C) + \\left(\\frac{\\kappa}{4} \\frac{\\ln I_3}{I_3}\\right) (I_3 C^{-1}) \\right]$$\n$$S = a_1 I + a_2 (I_1 I - C) + \\frac{\\kappa}{2} (\\ln I_3) C^{-1}$$\n\n**4. $S_{11}$ 的计算**\n\n我们需要张量 $S$ 的 $(1,1)$ 分量：\n$$S_{11} = a_1 I_{11} + a_2 (I_1 I_{11} - C_{11}) + \\frac{\\kappa}{2} (\\ln I_3) (C^{-1})_{11}$$\n当 $I_{11} = 1$ 时：\n$$S_{11} = a_1 + a_2(I_1 - C_{11}) + \\frac{\\kappa}{2} (\\ln I_3) (C^{-1})_{11}$$\n分量 $(C^{-1})_{11}$ 是 $C$ 的伴随矩阵的 $(1,1)$ 元素除以 $\\det(C)=I_3$：\n$$(C^{-1})_{11} = \\frac{1}{I_3} (C_{22}C_{33} - C_{23}C_{32}) = \\frac{(0.82)(1.25) - (0.18)^2}{1.411344}$$\n$$(C^{-1})_{11} = \\frac{1.025 - 0.0324}{1.411344} = \\frac{0.9926}{1.411344} \\approx 0.703344$$\n现在，代入数值：\n-   $a_1 = 40.0$ MPa\n-   $a_2 = 10.0$ MPa\n-   $\\kappa = 200.0$ MPa\n-   $I_1 = 3.51$\n-   $C_{11} = 1.44$\n-   $I_3 = 1.411344$\n$$S_{11} = 40 + 10(3.51 - 1.44) + \\frac{200}{2} \\ln(1.411344) \\left( \\frac{0.9926}{1.411344} \\right)$$\n$$S_{11} = 40 + 10(2.07) + 100 \\ln(1.411344) (0.703344\\dots)$$\n$$S_{11} = 40 + 20.7 + 100 (0.344558\\dots) (0.703344\\dots)$$\n$$S_{11} = 60.7 + 24.23235\\dots$$\n$$S_{11} = 84.93235\\dots~\\text{MPa}$$\n将最终结果四舍五入到四位有效数字，得到：\n$$S_{11} \\approx 84.93~\\text{MPa}$$",
            "answer": "$$\\boxed{84.93}$$"
        },
        {
            "introduction": "一个强大的模型只有在可靠时才有用。本练习从应用模型转向严格评估其有效性，这是任何数据驱动工作流程中至关重要的一步。你将实践如何检查模型是否满足基本物理约束（如热力学稳定性），并通过判断新数据点是否位于训练数据域之外来量化外推风险 。掌握这些验证技术对于开发稳健且值得信赖的科学模型至关重要。",
            "id": "3748583",
            "problem": "给定一个由数据驱动的小应变、平面应力本构设定，其中一个学习得到的线性映射通过一个作用于 Voigt 表达的矩阵，将对称应变张量关联到对称应力张量。令 Voigt 应变向量为 $\\mathbf{e} = (e_{xx}, e_{yy}, e_{xy})^\\top \\in \\mathbb{R}^3$，并令学习得到的刚度矩阵为 $\\mathbf{C} \\in \\mathbb{R}^{3 \\times 3}$。学习得到的应力为 $\\mathbf{s} = \\mathbf{C} \\,\\mathbf{e}$。假设所有量都已无量纲化，因此每个值都是无量纲的。\n\n基本原理和约束：\n- 在小应变线弹性理论下，应变能密度 $W(\\mathbf{e})$ 的存在要求应力可以从一个势函数导出，即 $\\mathbf{s} = \\frac{\\partial W}{\\partial \\mathbf{e}}$，这意味着刚度矩阵必须是对称的，即 $\\mathbf{C} = \\mathbf{C}^\\top$。对于二次能量 $W(\\mathbf{e}) = \\frac{1}{2} \\,\\mathbf{e}^\\top \\mathbf{C}_s \\,\\mathbf{e}$，其中 $\\mathbf{C}_s = \\frac{1}{2}(\\mathbf{C}+\\mathbf{C}^\\top)$ 是对称部分，材料稳定性要求 $\\mathbf{C}_s$ 是正定的（所有特征值都严格为正）。\n- 能量非负性与沿射线的单调性：对于任意非零应变方向 $\\mathbf{e}$ 和标量加载参数 $\\lambda \\ge 0$，沿射线 $\\mathbf{e}(\\lambda) = \\lambda \\mathbf{e}$ 的能量必须满足 $\\frac{\\mathrm{d}}{\\mathrm{d}\\lambda} W(\\mathbf{e}(\\lambda)) = \\mathbf{s}(\\lambda) \\cdot \\mathbf{e} = \\lambda \\,\\mathbf{e}^\\top \\mathbf{C}_s \\,\\mathbf{e} \\ge 0$，如果 $\\mathbf{C}_s$ 是正定的，则此条件得到保证；当 $\\mathbf{e}^\\top \\mathbf{C}_s \\,\\mathbf{e}  0$ 时，发生违背。\n- 数据驱动的外推风险评估：给定一个训练应变集合 $\\mathcal{E}=\\{\\mathbf{e}_i\\}_{i=1}^N$，如果一个测试应变 $\\mathbf{e}^\\star$ 位于凸包 $\\mathrm{conv}(\\mathcal{E})$ 之外，则称其存在外推风险，即不存在非负权重 $\\{w_i\\}$（其和为1）使得 $\\sum_i w_i \\mathbf{e}_i = \\mathbf{e}^\\star$。\n\n您的任务是编写一个程序，对于一个固定的训练集 $\\mathcal{E}$ 和一组包含学习得到的刚度矩阵 $\\mathbf{C}$ 及相应测试应变 $\\mathbf{e}^\\star$ 的测试套件，评估外推风险并量化对物理约束的违背情况。\n\n训练集（所有测试用例通用），以 $\\mathbb{R}^3$ 中四个点的形式给出：\n- $\\mathbf{e}_1 = (0, 0, 0)$，\n- $\\mathbf{e}_2 = (0.02, 0, 0)$，\n- $\\mathbf{e}_3 = (0, 0.02, 0)$，\n- $\\mathbf{e}_4 = (0.01, 0.01, 0.005)$。\n\n测试套件包含四个用例。对于每个用例 $k \\in \\{1,2,3,4\\}$，给定一个学习得到的刚度矩阵 $\\mathbf{C}^{(k)}$ 和一个测试应变 $\\mathbf{e}^{\\star (k)}$：\n1. 用例1（对称正定，预计为外推）：\n   - $\\mathbf{C}^{(1)} = \\begin{pmatrix} 1000  300  0 \\\\ 300  800  0 \\\\ 0  0  200 \\end{pmatrix}$，\n   - $\\mathbf{e}^{\\star (1)} = (0.03, 0.01, -0.002)$。\n2. 用例2（轻度不对称，近乎稳定，预计在凸包内）：\n   - $\\mathbf{C}^{(2)} = \\begin{pmatrix} 900  250  10 \\\\ 260  750  -5 \\\\ 5  -20  150 \\end{pmatrix}$，\n   - $\\mathbf{e}^{\\star (2)} = (0.01, 0.01, 0)$。\n3. 用例3（对称，半正定，处于稳定性边界）：\n   - $\\mathbf{C}^{(3)} = \\begin{pmatrix} 500  0  0 \\\\ 0  0  0 \\\\ 0  0  100 \\end{pmatrix}$，\n   - $\\mathbf{e}^{\\star (3)} = (0.02, 0.02, 0)$。\n4. 用例4（对称不定，能量在某些方向上可以为负）：\n   - $\\mathbf{C}^{(4)} = \\begin{pmatrix} 100  -300  0 \\\\ -300  100  0 \\\\ 0  0  50 \\end{pmatrix}$，\n   - $\\mathbf{e}^{\\star (4)} = (0.015, 0.015, 0)$。\n\n对于每个测试用例 $k$，计算以下五个量：\n- $Q_1^{(k)}$: 一个布尔值，指示 $\\mathbf{e}^{\\star (k)}$ 是否位于训练集 $\\mathcal{E}$ 的凸包之外（True 表示在外；False 表示在内）。\n- $Q_2^{(k)}$: 能量非负性违背的量级，定义为 $Q_2^{(k)} = \\max\\{0, -W(\\mathbf{e}^{\\star (k)})\\}$，其中 $W(\\mathbf{e}) = \\frac{1}{2}\\,\\mathbf{e}^\\top \\mathbf{C}_s^{(k)} \\,\\mathbf{e}$ 且 $\\mathbf{C}_s^{(k)} = \\frac{1}{2}(\\mathbf{C}^{(k)} + \\mathbf{C}^{(k)\\top})$ 是对称部分。\n- $Q_3^{(k)}$: 学习得到的刚度的不对称性范数，定义为 $Q_3^{(k)} = \\|\\mathbf{C}^{(k)} - \\mathbf{C}^{(k)\\top}\\|_F$，其中 $\\|\\cdot\\|_F$ 表示 Frobenius 范数。\n- $Q_4^{(k)}$: 一个布尔值，指示 $\\mathbf{C}_s^{(k)}$ 正定性的违背情况，即如果 $\\mathbf{C}_s^{(k)}$ 的任何特征值小于或等于容差 $\\varepsilon = 10^{-12}$，则为 True，否则为 False。\n- $Q_5^{(k)}$: 一个布尔值，指示沿射线单调性的违背情况，即如果 $\\mathbf{e}^{\\star (k)\\top} \\mathbf{C}_s^{(k)} \\mathbf{e}^{\\star (k)}  -\\varepsilon$，则为 True，否则为 False，使用相同的 $\\varepsilon$。\n\n所有涉及能量或正定性的计算都必须使用对称部分 $\\mathbf{C}_s^{(k)}$ 进行。将所有值视为无量纲。在进行正定性和单调性检查时，使用数值容差 $\\varepsilon = 10^{-12}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[Q_1^{(1)}, Q_2^{(1)}, Q_3^{(1)}, Q_4^{(1)}, Q_5^{(1)}, Q_1^{(2)}, Q_2^{(2)}, Q_3^{(2)}, Q_4^{(2)}, Q_5^{(2)}, Q_1^{(3)}, Q_2^{(3)}, Q_3^{(3)}, Q_4^{(3)}, Q_5^{(3)}, Q_1^{(4)}, Q_2^{(4)}, Q_3^{(4)}, Q_4^{(4)}, Q_5^{(4)}]$。\n\n请根据上述基本原理设计算法，不要调用任何预打包的凸包例程；为评估凸包包含关系，您可以通过求解一个可行性问题来确定是否存在和为1的非负权重，从而将测试应变表示为训练应变的凸组合。所有输出必须是所定义的无量纲浮点数或布尔值，并且最后一行必须与指定格式完全匹配。",
            "solution": "问题陈述已经过仔细审查，并被认为是有效的。它在科学上基于线弹性和连续介质力学原理，问题定义清晰（well-posed），提供了所有必要的数据和定义，并且其表述是客观的。这些任务是明确定义的数学计算，并有唯一的解。\n\n解决方案通过实现算法来为四个测试用例中的每一个计算五个不同的量。这些量用于评估一个数据驱动的本构模型对物理原理的遵守情况及其外推行为。下面将对每个量所依据的原理和相应的计算方法进行详细说明。\n\n首先，我们定义所有测试用例的通用数据。训练应变向量集为 $\\mathcal{E} = \\{\\mathbf{e}_1, \\mathbf{e}_2, \\mathbf{e}_3, \\mathbf{e}_4\\}$，其中：\n$$\n\\mathbf{e}_1 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad\n\\mathbf{e}_2 = \\begin{pmatrix} 0.02 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad\n\\mathbf{e}_3 = \\begin{pmatrix} 0 \\\\ 0.02 \\\\ 0 \\end{pmatrix}, \\quad\n\\mathbf{e}_4 = \\begin{pmatrix} 0.01 \\\\ 0.01 \\\\ 0.005 \\end{pmatrix}\n$$\n涉及近零值检查的数值容差给定为 $\\varepsilon = 10^{-12}$。对于每个测试用例 $k$，我们给定一个学习得到的刚度矩阵 $\\mathbf{C}^{(k)}$ 和一个测试应变 $\\mathbf{e}^{\\star (k)}$。\n\n分析的核心依赖于刚度矩阵的对称部分 $\\mathbf{C}_s$，它控制着应变能。对于任意给定的学习矩阵 $\\mathbf{C}$，其对称部分的计算方法如下：\n$$\n\\mathbf{C}_s = \\frac{1}{2}\\left(\\mathbf{C} + \\mathbf{C}^\\top\\right)\n$$\n\n这五个量的计算方法如下：\n\n$Q_1^{(k)}$: 外推风险\n这个量是一个布尔值，指示测试应变 $\\mathbf{e}^{\\star (k)}$ 是否位于训练集 $\\mathrm{conv}(\\mathcal{E})$ 的凸包之外。根据凸包的定义，一个点 $\\mathbf{e}^\\star$ 位于 $\\mathrm{conv}(\\mathcal{E})$ 内部或边界上的充要条件是，它可以表示为 $\\mathcal{E}$ 中各点的凸组合。也就是说，必须存在一组非负权重 $\\{w_i\\}_{i=1}^4$ 满足：\n$$\n\\sum_{i=1}^4 w_i \\mathbf{e}_i = \\mathbf{e}^{\\star (k)} \\quad \\text{和} \\quad \\sum_{i=1}^4 w_i = 1, \\quad w_i \\ge 0\n$$\n这构成了一个线性规划可行性问题。设权重为未知向量 $\\mathbf{w} = (w_1, w_2, w_3, w_4)^\\top$。这些条件可以写成矩阵形式 $\\mathbf{A}_{\\text{eq}} \\mathbf{w} = \\mathbf{b}_{\\text{eq}}$，其中：\n$$\n\\mathbf{A}_{\\text{eq}} = \\begin{pmatrix} |  |  |  | \\\\ \\mathbf{e}_1  \\mathbf{e}_2  \\mathbf{e}_3  \\mathbf{e}_4 \\\\ |  |  |  | \\\\ 1  1  1  1 \\end{pmatrix} \\in \\mathbb{R}^{4 \\times 4}, \\quad\n\\mathbf{b}_{\\text{eq}} = \\begin{pmatrix} | \\\\ \\mathbf{e}^{\\star (k)} \\\\ | \\\\ 1 \\end{pmatrix} \\in \\mathbb{R}^{4}\n$$\n问题在于找到一个向量 $\\mathbf{w}$，它满足这个方程组以及非负性约束 $\\mathbf{w} \\ge \\mathbf{0}$。我们可以使用线性规划求解器（例如 `scipy.optimize.linprog`）来解决此问题，目标函数可以任意设置（例如，最小化 $0$）。如果求解器找到一个可行解，则 $\\mathbf{e}^{\\star (k)}$ 在凸包内，$Q_1^{(k)}$ 为 `False`。如果不存在这样的解，则 $\\mathbf{e}^{\\star (k)}$ 在凸包外，$Q_1^{(k)}$ 为 `True`。\n\n$Q_2^{(k)}$: 能量非负性违背\n与线弹性材料相关的应变能密度 $W$ 是应变的二次函数，通过刚度矩阵的对称部分定义： $W(\\mathbf{e}) = \\frac{1}{2} \\mathbf{e}^\\top \\mathbf{C}_s \\mathbf{e}$。材料物理学的一个基本要求是应变能必须非负，即 $W(\\mathbf{e}) \\ge 0$。如果对于给定的应变，计算出的能量为负，则发生了违背。对于测试应变 $\\mathbf{e}^{\\star (k)}$，此违背的量级被量化为：\n$$\nQ_2^{(k)} = \\max\\{0, -W(\\mathbf{e}^{\\star (k)})\\} = \\max\\left\\{0, -\\frac{1}{2} (\\mathbf{e}^{\\star (k)})^\\top \\mathbf{C}_s^{(k)} \\mathbf{e}^{\\star (k)}\\right\\}\n$$\n这是一个涉及矩阵-向量乘法的直接计算。\n\n$Q_3^{(k)}$: 不对称性范数\n从数学上讲，能够导出应力（$\\mathbf{s} = \\partial W / \\partial \\mathbf{e}$）的应变能势函数 $W(\\mathbf{e})$ 的存在，要求刚度矩阵是对称的。这被称为麦克斯韦关系（Maxwell relation）。从数据中学习得到的刚度矩阵 $\\mathbf{C}^{(k)}$ 可能不是完全对称的。与对称性的偏差是衡量物理不一致性的一种度量。我们使用矩阵与其转置之差的 Frobenius 范数来量化这种偏差：\n$$\nQ_3^{(k)} = \\|\\mathbf{C}^{(k)} - (\\mathbf{C}^{(k)})^\\top\\|_F = \\sqrt{\\sum_{i=1}^3 \\sum_{j=1}^3 (C_{ij}^{(k)} - C_{ji}^{(k)})^2}\n$$\n这可以使用标准的线性代数库函数来计算。\n\n$Q_4^{(k)}$: 正定性违背\n为了保证材料稳定性，对于任何非零应变 $\\mathbf{e}$，应变能密度 $W(\\mathbf{e})$ 必须严格为正。这个条件成立的充要条件是对称刚度矩阵 $\\mathbf{C}_s$ 是正定的。一个矩阵是正定的，如果其所有特征值都严格为正。如果 $\\mathbf{C}_s^{(k)}$ 至少有一个特征值为零或负，则发生违背。在计算上，我们检查最小特征值 $\\lambda_{\\min}(\\mathbf{C}_s^{(k)})$ 是否小于或等于一个很小的容差 $\\varepsilon = 10^{-12}$：\n$$\nQ_4^{(k)} = \\begin{cases} \\text{True}  \\text{if } \\lambda_{\\min}(\\mathbf{C}_s^{(k)}) \\le \\varepsilon \\\\ \\text{False}  \\text{otherwise} \\end{cases}\n$$\n由于 $\\mathbf{C}_s^{(k)}$ 是对称的，其特征值都是实数，并且可以高效地计算。\n\n$Q_5^{(k)}$: 沿射线单调性违背\n这是一个与单点能量非负性相关但又不同的检查。它检验能量沿着从原点出发、方向为测试应变 $\\mathbf{e}^{\\star (k)}$ 的射线上的行为。沿这条射线的能量是 $W(\\lambda \\mathbf{e}^{\\star (k)}) = \\frac{1}{2} \\lambda^2 ((\\mathbf{e}^{\\star (k)})^\\top \\mathbf{C}_s^{(k)} \\mathbf{e}^{\\star (k)})$。为了使能量随着加载参数 $\\lambda \\ge 0$ 非递减，二次型 $(\\mathbf{e}^{\\star (k)})^\\top \\mathbf{C}_s^{(k)} \\mathbf{e}^{\\star (k)}$ 必须为非负。如果这个量为负，则发生违背。我们使用一个容差 $\\varepsilon$ 进行此检查：\n$$\nQ_5^{(k)} = \\begin{cases} \\text{True}  \\text{if } (\\mathbf{e}^{\\star (k)})^\\top \\mathbf{C}_s^{(k)} \\mathbf{e}^{\\star (k)}  -\\varepsilon \\\\ \\text{False}  \\text{otherwise} \\end{cases}\n$$\n此检查直接评估由 $\\mathbf{e}^{\\star (k)}$ 定义的特定方向是否是能量减少的方向，这是不稳定的一个标志。\n\n现在将通过对四个测试用例中的每一个应用这五个计算步骤来继续实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the data-driven constitutive model validation problem.\n    \"\"\"\n\n    # Define the training set of strain vectors.\n    e_train = [\n        np.array([0., 0., 0.]),\n        np.array([0.02, 0., 0.]),\n        np.array([0., 0.02, 0.]),\n        np.array([0.01, 0.01, 0.005])\n    ]\n\n    # Define the four test cases.\n    test_cases = [\n        {\n            \"C\": np.array([\n                [1000., 300., 0.],\n                [300., 800., 0.],\n                [0., 0., 200.]\n            ]),\n            \"e_star\": np.array([0.03, 0.01, -0.002])\n        },\n        {\n            \"C\": np.array([\n                [900., 250., 10.],\n                [260., 750., -5.],\n                [5., -20., 150.]\n            ]),\n            \"e_star\": np.array([0.01, 0.01, 0.])\n        },\n        {\n            \"C\": np.array([\n                [500., 0., 0.],\n                [0., 0., 0.],\n                [0., 0., 100.]\n            ]),\n            \"e_star\": np.array([0.02, 0.02, 0.])\n        },\n        {\n            \"C\": np.array([\n                [100., -300., 0.],\n                [-300., 100., 0.],\n                [0., 0., 50.]\n            ]),\n            \"e_star\": np.array([0.015, 0.015, 0.])\n        }\n    ]\n\n    # Set numerical tolerance.\n    TOLERANCE = 1e-12\n\n    # Prepare for convex hull checks (A_eq is common to all cases).\n    # A_eq is a 4x4 matrix from the convex combination equations.\n    # The first 3 rows are the training strain vectors as columns.\n    # The last row is [1, 1, 1, 1] for the sum-to-one constraint on weights.\n    A_eq = np.vstack([np.array(e_train).T, np.ones(len(e_train))])\n\n    results = []\n    for case in test_cases:\n        C = case[\"C\"]\n        e_star = case[\"e_star\"]\n\n        # --- Q1: Extrapolation Risk (Convex Hull Check) ---\n        # b_eq is a vector of length 4.\n        # The first 3 elements are the test strain vector.\n        # The last element is 1 for the sum-to-one constraint.\n        b_eq = np.hstack([e_star, 1.0])\n        # We seek weights w >= 0 such that A_eq @ w = b_eq.\n        # Objective function c is irrelevant for a feasibility problem.\n        c = np.zeros(len(e_train))\n        # Use scipy's linear programming solver. Non-negativity of weights is handled by bounds.\n        # method='highs' is a robust simplex and interior-point method.\n        lp_res = linprog(c=c, A_eq=A_eq, b_eq=b_eq, bounds=(0, None), method='highs')\n        \n        # A successful solve means weights were found, so e_star is IN the hull.\n        # The question asks for True if OUTSIDE the hull.\n        q1 = not lp_res.success\n\n        # --- Symmetric part of the stiffness matrix ---\n        C_s = 0.5 * (C + C.T)\n\n        # --- Q2: Energy Nonnegativity Violation ---\n        # W(e) = 0.5 * e.T @ C_s @ e\n        W_e_star = 0.5 * e_star.T @ C_s @ e_star\n        q2 = np.maximum(0.0, -W_e_star)\n\n        # --- Q3: Asymmetry Norm ---\n        # Frobenius norm of (C - C.T)\n        q3 = np.linalg.norm(C - C.T, 'fro')\n\n        # --- Q4: Positive Definiteness Violation ---\n        # Eigenvalues of the symmetric matrix C_s.\n        # np.linalg.eigvalsh is efficient and numerically stable for Hermitian matrices.\n        eigenvalues = np.linalg.eigvalsh(C_s)\n        # Violation if any eigenvalue is = tolerance.\n        q4 = np.any(eigenvalues = TOLERANCE)\n\n        # --- Q5: Ray-wise Monotonicity Violation ---\n        # Check if e_star.T @ C_s @ e_star is negative.\n        quadratic_form = e_star.T @ C_s @ e_star\n        q5 = quadratic_form  -TOLERANCE\n        \n        results.extend([q1, q2, q3, q4, q5])\n\n    # Format the output as a single string.\n    # Booleans are automatically converted to 'True'/'False'.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "数据驱动建模的前沿是创建能够无缝集成到更大型计算流程中并进行“端到端”训练的模型。这项高级实践将指导你为一个具有历史依赖性的材料模型构建一个可微计算层。通过计算应力更新关于模型参数的雅可比矩阵，你将为基于梯度的优化方法铺平道路，这项技术有力地将经典模拟与现代深度学习框架联系起来 。",
            "id": "3748599",
            "problem": "您的任务是为小应变 von Mises（也称为 $J_2$）塑性构建一个可微返回映射层，该模型具有各向同性弹性和可微的各向同性硬化律。该层必须强制执行屈服一致性条件，并计算应力更新相对于一组标量硬化参数的雅可比矩阵，以便在有限元 (FE) 模拟中用于端到端训练。\n\n设置为三维小应变运动学。令总应变张量表示为 $\\boldsymbol{\\varepsilon} \\in \\mathbb{R}^{3 \\times 3}$（对称），柯西应力张量表示为 $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{3 \\times 3}$（对称），累积等效塑性应变表示为 $\\alpha \\in \\mathbb{R}_{\\ge 0}$。弹性本构律是各向同性的，由胡克定律给出：\n$$\n\\boldsymbol{\\sigma} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon} - \\boldsymbol{\\varepsilon}^{p}) \\, \\mathbf{I} + 2 \\mu \\, (\\boldsymbol{\\varepsilon} - \\boldsymbol{\\varepsilon}^{p}),\n$$\n其中 $\\boldsymbol{\\varepsilon}^{p}$ 是塑性应变张量，$\\lambda$ 和 $\\mu$ 是拉梅参数，$\\mathbf{I}$ 是单位张量。杨氏模量 $E$ 和泊松比 $\\nu$ 通过 $\\mu = \\dfrac{E}{2(1+\\nu)}$ 和 $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$ 与拉梅参数相关。\n\n定义偏应力 $\\mathbf{s} = \\boldsymbol{\\sigma} - \\dfrac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma}) \\, \\mathbf{I}$ 和 von Mises 等效应力为\n$$\n\\sigma_{\\mathrm{eq}} = \\sqrt{\\dfrac{3}{2}} \\, \\lVert \\mathbf{s} \\rVert_F,\n$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示弗罗贝尼乌斯范数。如果屈服函数\n$$\n\\Phi(\\boldsymbol{\\sigma}, \\alpha; \\boldsymbol{\\pi}) := \\sigma_{\\mathrm{eq}} - \\sigma_y(\\alpha; \\boldsymbol{\\pi})\n$$\n超过零，则发生塑性屈服，其中 $\\sigma_y(\\alpha; \\boldsymbol{\\pi})$ 是由参数向量 $\\boldsymbol{\\pi} = [\\sigma_0, a_1, a_2, a_3]^\\top$ 参数化的可微各向同性硬化律。该硬化律定义为\n$$\n\\sigma_y(\\alpha; \\boldsymbol{\\pi}) = \\sigma_0 + a_1 \\alpha + a_2 \\tanh(a_3 \\alpha),\n$$\n其中 $\\sigma_0$ 是初始屈服应力（单位：兆帕，缩写为 MPa），$a_1$ 和 $a_2$ 的单位是 MPa，而 $a_3$ 是无量纲的。变量 $\\alpha$ 是无量纲的。\n\n对于给定的增量，弹性预测器会产生试探应力 $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$ 及其偏量部分 $\\mathbf{s}^{\\mathrm{tr}}$，其等效应力为 $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} = \\sqrt{\\dfrac{3}{2}} \\lVert \\mathbf{s}^{\\mathrm{tr}} \\rVert_F$。如果 $\\Phi(\\boldsymbol{\\sigma}^{\\mathrm{tr}}, \\alpha_n; \\boldsymbol{\\pi}) \\le 0$（其中 $\\alpha_n$ 是先前累积的塑性应变），则该步骤是弹性的，且 $\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{tr}}$，$\\alpha_{n+1} = \\alpha_n$，$\\boldsymbol{\\sigma}_{n+1}$ 相对于 $\\boldsymbol{\\pi}$ 的雅可比矩阵为零。\n\n如果 $\\Phi(\\boldsymbol{\\sigma}^{\\mathrm{tr}}, \\alpha_n; \\boldsymbol{\\pi})  0$，则需要进行塑性修正。使用基于塑性乘子 $\\Delta \\gamma \\ge 0$ 的标准径向返回映射，单位流动方向为\n$$\n\\mathbf{n} = \\dfrac{\\mathbf{s}^{\\mathrm{tr}}}{\\lVert \\mathbf{s}^{\\mathrm{tr}} \\rVert_F},\n$$\n更新方程为\n$$\n\\mathbf{s}_{n+1} = \\mathbf{s}^{\\mathrm{tr}} - 2 \\mu \\, \\Delta \\gamma \\, \\mathbf{n}, \\quad \\alpha_{n+1} = \\alpha_n + \\sqrt{\\dfrac{2}{3}} \\, \\Delta \\gamma,\n$$\n同时保持静水压力不变，即 $\\mathrm{tr}(\\boldsymbol{\\sigma}_{n+1}) = \\mathrm{tr}(\\boldsymbol{\\sigma}^{\\mathrm{tr}})$。通过求解以下标量非线性方程来强制执行一致性条件\n$$\ng(\\Delta \\gamma; \\alpha_n, \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}, \\mu, \\boldsymbol{\\pi}) := \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 2 \\mu \\, \\Delta \\gamma - \\sigma_y\\!\\left(\\alpha_n + \\sqrt{\\dfrac{2}{3}} \\, \\Delta \\gamma; \\boldsymbol{\\pi}\\right) = 0.\n$$\n在物理合理的参数下，函数 $g$ 在 $\\Delta \\gamma$ 上是单调的，可以用牛顿法求解。当收敛到 $\\Delta \\gamma^\\star$ 时，更新后的应力为\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - 2 \\mu \\, \\Delta \\gamma^\\star \\, \\mathbf{n}.\n$$\n\n使用隐函数定理计算 $\\boldsymbol{\\sigma}_{n+1}$ 相对于 $\\boldsymbol{\\pi}$ 的雅可比矩阵。设 $k = \\sqrt{\\dfrac{2}{3}}$，并记 $\\alpha^\\star = \\alpha_n + k \\Delta \\gamma^\\star$。导数 $\\dfrac{\\partial \\sigma_y}{\\partial \\alpha}$ 为\n$$\n\\dfrac{\\partial \\sigma_y}{\\partial \\alpha}(\\alpha^\\star; \\boldsymbol{\\pi}) = a_1 + a_2 a_3 \\, \\mathrm{sech}^2(a_3 \\alpha^\\star),\n$$\n且关于参数的偏导数为\n$$\n\\dfrac{\\partial \\sigma_y}{\\partial \\sigma_0} = 1, \\quad\n\\dfrac{\\partial \\sigma_y}{\\partial a_1} = \\alpha^\\star, \\quad\n\\dfrac{\\partial \\sigma_y}{\\partial a_2} = \\tanh(a_3 \\alpha^\\star), \\quad\n\\dfrac{\\partial \\sigma_y}{\\partial a_3} = a_2 \\alpha^\\star \\, \\mathrm{sech}^2(a_3 \\alpha^\\star).\n$$\n对 $g(\\Delta \\gamma^\\star, \\boldsymbol{\\pi}) = 0$ 进行隐式微分，对于每个参数 $\\pi_i \\in \\{\\sigma_0, a_1, a_2, a_3\\}$，可得\n$$\n\\dfrac{\\partial \\Delta \\gamma^\\star}{\\partial \\pi_i} =\n- \\dfrac{\\dfrac{\\partial g}{\\partial \\pi_i}}{\\dfrac{\\partial g}{\\partial \\Delta \\gamma}}\n=\n- \\dfrac{- \\dfrac{\\partial \\sigma_y}{\\partial \\pi_i}(\\alpha^\\star; \\boldsymbol{\\pi})}{-2 \\mu - k \\, \\dfrac{\\partial \\sigma_y}{\\partial \\alpha}(\\alpha^\\star; \\boldsymbol{\\pi})}\n=\n\\dfrac{\\dfrac{\\partial \\sigma_y}{\\partial \\pi_i}(\\alpha^\\star; \\boldsymbol{\\pi})}{2 \\mu + k \\, \\dfrac{\\partial \\sigma_y}{\\partial \\alpha}(\\alpha^\\star; \\boldsymbol{\\pi})}.\n$$\n因此，应力张量关于参数的雅可比矩阵为\n$$\n\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\pi_i}\n=\n- 2 \\mu \\, \\mathbf{n} \\, \\dfrac{\\partial \\Delta \\gamma^\\star}{\\partial \\pi_i},\n$$\n其中，在对 $\\boldsymbol{\\pi}$ 微分时，$\\mathbf{n}$ 保持不变，因为 $\\mathbf{n}$ 仅取决于弹性预测器。在弹性步中，雅可比矩阵恒为零。\n\n实现要求：\n- 应力单位使用兆帕 (MPa)。任何报告的应力、屈服残差或雅可比范数都必须以 MPa 为单位。累积塑性应变 $\\alpha$ 和 $\\Delta \\gamma$ 是无量纲的。此问题不涉及角度。\n- 构建一个程序，该程序对于给定的材料参数集、先前的塑性应变 $\\alpha_n$ 和总应变张量 $\\boldsymbol{\\varepsilon}$，执行以下操作：\n  1. 弹性预测以确定 $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$ 和 $\\mathbf{s}^{\\mathrm{tr}}$。\n  2. 屈服检查，如果需要，使用牛顿法求解 $\\Delta \\gamma^\\star$ 以强制执行 $g(\\Delta \\gamma^\\star) = 0$。\n  3. 更新 $\\boldsymbol{\\sigma}_{n+1}$ 并计算雅可比张量 $\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\pi_i}$，其中 $i \\in \\{1,2,3,4\\}$。\n  4. 以 MPa 为单位计算屈服一致性残差的大小 $|g(\\Delta \\gamma^\\star)|$（对于弹性情况，使用 $0$）。\n  5. 以 MPa 为单位计算每个雅可比张量 $\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\pi_i}$ 在 $3 \\times 3$ 应力张量上的弗罗贝尼乌斯范数。\n\n测试套件：\n使用以下四个测试用例来检验算法的不同方面。在所有情况下，除非另有说明，均取 $E = 210000$ MPa，$\\nu = 0.3$，$\\boldsymbol{\\varepsilon}^{p}_n = \\mathbf{0}$，且 $\\alpha_n = 0$。每个应变张量 $\\boldsymbol{\\varepsilon}$ 都必须是对称的。\n\n- 用例 1（塑性，正常路径）：$\\boldsymbol{\\varepsilon}$ 具有纯剪切，其中 $\\varepsilon_{12} = \\varepsilon_{21} = 0.01$，所有其他分量为零；参数 $\\boldsymbol{\\pi} = [\\sigma_0, a_1, a_2, a_3] = [400, 1000, 50, 10]$。\n- 用例 2（接近屈服边界）：$\\boldsymbol{\\varepsilon}$ 具有纯剪切，其中 $\\varepsilon_{12} = \\varepsilon_{21} = 0.00143$，所有其他分量为零；参数 $\\boldsymbol{\\pi} = [400, 1000, 50, 10]$。\n- 用例 3（静水，边界情况）：$\\boldsymbol{\\varepsilon}$ 是静水的，其中 $\\varepsilon_{11} = \\varepsilon_{22} = \\varepsilon_{33} = 0.001$，所有非对角分量为零；参数 $\\boldsymbol{\\pi} = [400, 1000, 50, 10]$。\n- 用例 4（零应变，边界情况）：$\\boldsymbol{\\varepsilon}$ 为零；参数 $\\boldsymbol{\\pi} = [400, 1000, 50, 10]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，程序必须按顺序输出以下值：\n- 屈服残差大小（单位 MPa，浮点数），\n- $\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\sigma_0}$ 的弗罗贝尼乌斯范数（单位 MPa，浮点数），\n- $\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial a_1}$ 的弗罗贝尼乌斯范数（单位 MPa，浮点数），\n- $\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial a_2}$ 的弗罗贝尼乌斯范数（单位 MPa，浮点数），\n- $\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial a_3}$ 的弗罗贝尼乌斯范数（单位 MPa，浮点数），\n- 弹性标志（布尔值），如果步骤是弹性的则为 true，如果是塑性的则为 false。\n\n因此，最终的单行输出必须是一个包含四个用例的 24 个条目的扁平化列表，例如：\n$[\\text{res}_1,\\text{J}_{\\sigma_0,1},\\text{J}_{a_1,1},\\text{J}_{a_2,1},\\text{J}_{a_3,1},\\text{elastic}_1,\\text{res}_2,\\ldots,\\text{elastic}_4]$。",
            "solution": "该问题被评估为有效。它在科学上基于连续介质力学和计算塑性力学的原理，是适定、客观的，并为实现提供了完整且一致的定义、方程和数据。该任务涉及为带有各向同性硬化的标准 von Mises 塑性模型创建一个计算层，并计算其对硬化参数的敏感度，这是现代力学中一个标准且重要的过程，尤其是在材料科学的机器学习应用中。\n\n对于给定的应变增量，确定应力状态 $\\boldsymbol{\\sigma}_{n+1}$ 及其关于硬化参数 $\\boldsymbol{\\pi}$ 的雅可比矩阵的步骤详述如下。\n\n首先，我们定义材料常数和关键参数。给定杨氏模量 $E$ 和泊松比 $\\nu$。由此，可计算出拉梅参数，即剪切模量 $\\mu$ 和第一拉梅参数 $\\lambda$：\n$$\n\\mu = \\dfrac{E}{2(1+\\nu)}, \\quad \\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}\n$$\n该问题一致使用下标 $n+1$ 表示当前状态，下标 $n$ 表示先前状态的约定。所有测试用例都从原始材料状态开始，即 $\\boldsymbol{\\varepsilon}^{p}_n = \\mathbf{0}$ 且累积塑性应变 $\\alpha_n = 0$。塑性应变增量通过常数因子 $k = \\sqrt{2/3}$ 与塑性乘子增量 $\\Delta\\gamma$ 相关联。\n\n对于每个测试用例，该算法按四个主要步骤进行。\n\n步骤 1：弹性预测器\n假设整个应变增量是弹性的，计算弹性试探状态。给定总应变张量 $\\boldsymbol{\\varepsilon}_{n+1}$（在问题中表示为 $\\boldsymbol{\\varepsilon}$）和上一步的塑性应变 $\\boldsymbol{\\varepsilon}^{p}_n$，使用胡克定律计算试探应力 $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$：\n$$\n\\boldsymbol{\\sigma}^{\\mathrm{tr}} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}_{n+1} - \\boldsymbol{\\varepsilon}^{p}_n) \\, \\mathbf{I} + 2 \\mu \\, (\\boldsymbol{\\varepsilon}_{n+1} - \\boldsymbol{\\varepsilon}^{p}_n)\n$$\n由于 $\\boldsymbol{\\varepsilon}^{p}_n = \\mathbf{0}$，这可简化为 $\\boldsymbol{\\sigma}^{\\mathrm{tr}} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}_{n+1}) \\, \\mathbf{I} + 2 \\mu \\, \\boldsymbol{\\varepsilon}_{n+1}$。\n然后计算试探应力的偏量部分 $\\mathbf{s}^{\\mathrm{tr}}$ 和 von Mises 等效试探应力 $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}$：\n$$\n\\mathbf{s}^{\\mathrm{tr}} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - \\dfrac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma}^{\\mathrm{tr}}) \\, \\mathbf{I}\n$$\n$$\n\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} = \\sqrt{\\dfrac{3}{2}} \\, \\lVert \\mathbf{s}^{\\mathrm{tr}} \\rVert_F\n$$\n\n步骤 2：屈服准则检查\n使用试探状态检查屈服条件。屈服应力 $\\sigma_y$ 是通过使用指定的硬化律在先前的累积塑性应变 $\\alpha_n$ 处评估的，该硬化律由 $\\boldsymbol{\\pi} = [\\sigma_0, a_1, a_2, a_3]^\\top$ 参数化：\n$$\n\\sigma_y(\\alpha_n; \\boldsymbol{\\pi}) = \\sigma_0 + a_1 \\alpha_n + a_2 \\tanh(a_3 \\alpha_n)\n$$\n评估屈服函数 $\\Phi$：\n$$\n\\Phi^{\\mathrm{tr}} = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - \\sigma_y(\\alpha_n; \\boldsymbol{\\pi})\n$$\n如果 $\\Phi^{\\mathrm{tr}} \\le 0$，则该步骤是弹性的。如果 $\\Phi^{\\mathrm{tr}}  0$，则发生塑性变形，需要进行修正步骤。\n\n步骤 3：状态更新\n如果步骤是弹性的 ($\\Phi^{\\mathrm{tr}} \\le 0$)：\n更新后的应力 $\\boldsymbol{\\sigma}_{n+1}$ 是试探应力 $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$。内状态变量保持不变：$\\boldsymbol{\\varepsilon}^{p}_{n+1} = \\boldsymbol{\\varepsilon}^{p}_n$ 且 $\\alpha_{n+1} = \\alpha_n$。应力关于硬化参数的雅可比矩阵全为零。根据问题规范，屈服一致性残差报告为 $0$。\n\n如果步骤是塑性的 ($\\Phi^{\\mathrm{tr}}  0$)：\n执行一个称为返回映射的塑性修正步骤。步骤结束时必须满足一致性条件，这导致一个关于塑性乘子增量 $\\Delta \\gamma$ 的标量非线性方程：\n$$\ng(\\Delta \\gamma) := \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 2 \\mu \\, \\Delta \\gamma - \\sigma_y\\!\\left(\\alpha_n + \\sqrt{\\dfrac{2}{3}} \\, \\Delta \\gamma; \\boldsymbol{\\pi}\\right) = 0\n$$\n使用牛顿法求解此方程以得到 $\\Delta \\gamma^\\star \\ge 0$。$\\Delta\\gamma$ 的迭代更新为：\n$$\n\\Delta \\gamma_{j+1} = \\Delta \\gamma_j - \\dfrac{g(\\Delta \\gamma_j)}{g'(\\Delta \\gamma_j)}\n$$\n其中导数 $g'(\\Delta \\gamma)$ 为：\n$$\ng'(\\Delta \\gamma) = -2 \\mu - \\sqrt{\\dfrac{2}{3}} \\dfrac{\\partial \\sigma_y}{\\partial \\alpha}\\left(\\alpha_n + \\sqrt{\\dfrac{2}{3}}\\Delta\\gamma; \\boldsymbol{\\pi}\\right)\n$$\n其中 $\\dfrac{\\partial \\sigma_y}{\\partial \\alpha} = a_1 + a_2 a_3 \\, \\mathrm{sech}^2(a_3 \\alpha)$。\n找到解 $\\Delta \\gamma^\\star$ 后，更新状态变量。流动方向为 $\\mathbf{n} = \\mathbf{s}^{\\mathrm{tr}} / \\lVert \\mathbf{s}^{\\mathrm{tr}} \\rVert_F$。更新后的应力为：\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - 2 \\mu \\, \\Delta \\gamma^\\star \\, \\mathbf{n}\n$$\n累积塑性应变更新为 $\\alpha_{n+1} = \\alpha_n + \\sqrt{2/3} \\, \\Delta \\gamma^\\star$。计算屈服一致性残差的大小 $|g(\\Delta \\gamma^\\star)|$。\n\n步骤 4：雅可比矩阵计算\n对于塑性步，通过对更新方程进行微分来计算更新后应力 $\\boldsymbol{\\sigma}_{n+1}$ 关于每个硬化参数 $\\pi_i \\in \\{\\sigma_0, a_1, a_2, a_3\\}$ 的雅可比矩阵。这依赖于塑性乘子的敏感度 $\\frac{\\partial \\Delta \\gamma^\\star}{\\partial \\pi_i}$，该敏感度通过将隐函数定理应用于一致性方程 $g(\\Delta \\gamma^\\star, \\boldsymbol{\\pi})=0$ 来找到：\n$$\n\\dfrac{\\partial \\Delta \\gamma^\\star}{\\partial \\pi_i} = - \\dfrac{\\partial g / \\partial \\pi_i}{\\partial g / \\partial \\Delta \\gamma} = \\dfrac{\\dfrac{\\partial \\sigma_y}{\\partial \\pi_i}(\\alpha_{n+1}; \\boldsymbol{\\pi})}{2 \\mu + \\sqrt{\\frac{2}{3}} \\, \\dfrac{\\partial \\sigma_y}{\\partial \\alpha}(\\alpha_{n+1}; \\boldsymbol{\\pi})}\n$$\n其中 $\\alpha_{n+1} = \\alpha_n + \\sqrt{2/3}\\Delta\\gamma^\\star$。偏导数 $\\partial \\sigma_y / \\partial \\pi_i$ 在 $\\alpha_{n+1}$ 处进行评估：\n$$\n\\dfrac{\\partial \\sigma_y}{\\partial \\sigma_0} = 1, \\quad\n\\dfrac{\\partial \\sigma_y}{\\partial a_1} = \\alpha_{n+1}, \\quad\n\\dfrac{\\partial \\sigma_y}{\\partial a_2} = \\tanh(a_3 \\alpha_{n+1}), \\quad\n\\dfrac{\\partial \\sigma_y}{\\partial a_3} = a_2 \\alpha_{n+1} \\, \\mathrm{sech}^2(a_3 \\alpha_{n+1})\n$$\n然后应力张量的雅可比矩阵为：\n$$\n\\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\pi_i} = \\dfrac{\\partial}{\\partial \\pi_i} \\left( \\boldsymbol{\\sigma}^{\\mathrm{tr}} - 2 \\mu \\, \\Delta \\gamma^\\star \\, \\mathbf{n} \\right) = - 2 \\mu \\, \\mathbf{n} \\, \\dfrac{\\partial \\Delta \\gamma^\\star}{\\partial \\pi_i}\n$$\n需要该雅可比张量的弗罗贝尼乌斯范数。由于 $\\mathbf{n}$ 是关于弗罗贝尼乌斯范数的单位张量 ($\\lVert \\mathbf{n} \\rVert_F = 1$)，范数简化为：\n$$\n\\left\\lVert \\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\pi_i} \\right\\rVert_F = \\left| -2 \\mu \\, \\dfrac{\\partial \\Delta \\gamma^\\star}{\\partial \\pi_i} \\right| \\lVert \\mathbf{n} \\rVert_F = 2 \\mu \\left| \\dfrac{\\partial \\Delta \\gamma^\\star}{\\partial \\pi_i} \\right|\n$$\n对于弹性步，所有雅可比范数均为 $0$。\n对四个测试用例中的每一个都执行计算，并将结果按规定汇总到单个列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a differentiable return-mapping layer for J2 plasticity\n    and computes stress Jacobians with respect to hardening parameters.\n    \"\"\"\n\n    # --- Test Case Definitions ---\n    # Common parameters for all cases\n    E = 210000.0  # MPa\n    nu = 0.3\n    pi_common = np.array([400.0, 1000.0, 50.0, 10.0]) # [sigma0, a1, a2, a3]\n    alpha_n_common = 0.0\n\n    # Strain tensors for each case\n    eps_1 = np.array([[0.0, 0.01, 0.0], [0.01, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    eps_2 = np.array([[0.0, 0.00143, 0.0], [0.00143, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    eps_3 = np.array([[0.001, 0.0, 0.0], [0.0, 0.001, 0.0], [0.0, 0.0, 0.001]])\n    eps_4 = np.zeros((3, 3))\n    \n    test_cases = [\n        {'eps': eps_1, 'pi': pi_common, 'alpha_n': alpha_n_common}, # Case 1\n        {'eps': eps_2, 'pi': pi_common, 'alpha_n': alpha_n_common}, # Case 2\n        {'eps': eps_3, 'pi': pi_common, 'alpha_n': alpha_n_common}, # Case 3\n        {'eps': eps_4, 'pi': pi_common, 'alpha_n': alpha_n_common}, # Case 4\n    ]\n\n    # --- Helper Functions ---\n    def hardening_law(alpha, pi_vec):\n        \"\"\"Computes the yield stress sigma_y.\"\"\"\n        sigma0, a1, a2, a3 = pi_vec\n        return sigma0 + a1 * alpha + a2 * np.tanh(a3 * alpha)\n\n    def hardening_law_deriv_alpha(alpha, pi_vec):\n        \"\"\"Computes d(sigma_y)/d(alpha).\"\"\"\n        _, a1, a2, a3 = pi_vec\n        # sech(x) = 1/cosh(x)\n        sech_val = 1.0 / np.cosh(a3 * alpha)\n        return a1 + a2 * a3 * sech_val**2\n\n    # --- Main Logic ---\n    results = []\n    \n    # Material constants\n    mu = E / (2.0 * (1.0 + nu))\n    lmbda = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    k = np.sqrt(2.0 / 3.0)\n    I = np.identity(3)\n\n    for case in test_cases:\n        eps = case['eps']\n        pi_vec = case['pi']\n        alpha_n = case['alpha_n']\n        \n        # 1. Elastic predictor\n        tr_eps = np.trace(eps)\n        sigma_tr = lmbda * tr_eps * I + 2.0 * mu * eps\n        \n        s_tr = sigma_tr - (1.0 / 3.0) * np.trace(sigma_tr) * I\n        s_tr_norm = np.linalg.norm(s_tr, 'fro')\n        \n        # Avoid division by zero if s_tr is zero\n        if s_tr_norm  1e-12:\n            sigma_eq_tr = 0.0\n        else:\n            sigma_eq_tr = np.sqrt(3.0 / 2.0) * s_tr_norm\n\n        # 2. Yield check\n        sigma_y_n = hardening_law(alpha_n, pi_vec)\n        phi_tr = sigma_eq_tr - sigma_y_n\n\n        if phi_tr = 0:\n            # Elastic step\n            is_elastic = True\n            residual = 0.0\n            jac_norms = [0.0, 0.0, 0.0, 0.0]\n        else:\n            # Plastic step\n            is_elastic = False\n\n            # 3. Plastic corrector (Newton's method for delta_gamma)\n            delta_gamma = 0.0 # Initial guess\n            \n            # Residual function and its derivative\n            def g(dg):\n                alpha_eval = alpha_n + k * dg\n                return sigma_eq_tr - 2.0 * mu * dg - hardening_law(alpha_eval, pi_vec)\n            \n            def g_prime(dg):\n                alpha_eval = alpha_n + k * dg\n                return -2.0 * mu - k * hardening_law_deriv_alpha(alpha_eval, pi_vec)\n            \n            for _ in range(10): # Newton iterations\n                dg_update = g(delta_gamma) / g_prime(delta_gamma)\n                delta_gamma -= dg_update\n                if np.abs(g(delta_gamma))  1e-9:\n                    break\n            \n            delta_gamma_star = delta_gamma\n            residual = np.abs(g(delta_gamma_star))\n\n            alpha_star = alpha_n + k * delta_gamma_star\n\n            # 4. Jacobian computation\n            # Denominator for d(delta_gamma)/d(pi)\n            denom = 2.0 * mu + k * hardening_law_deriv_alpha(alpha_star, pi_vec)\n\n            # Numerators for d(sigma_y)/d(pi)\n            d_sigma_y_d_s0 = 1.0\n            d_sigma_y_d_a1 = alpha_star\n            d_sigma_y_d_a2 = np.tanh(pi_vec[3] * alpha_star)\n            sech_val_star = 1.0 / np.cosh(pi_vec[3] * alpha_star)\n            d_sigma_y_d_a3 = pi_vec[2] * alpha_star * sech_val_star**2\n            \n            d_sigma_y_d_pi = np.array([d_sigma_y_d_s0, d_sigma_y_d_a1, d_sigma_y_d_a2, d_sigma_y_d_a3])\n\n            # d(delta_gamma)/d(pi)\n            d_delta_gamma_d_pi = d_sigma_y_d_pi / denom\n\n            # Frobenius norm of d(sigma)/d(pi)\n            jac_norms = 2.0 * mu * np.abs(d_delta_gamma_d_pi)\n        \n        # Append results for this case\n        results.extend([residual, *jac_norms, is_elastic])\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}