{
    "hands_on_practices": [
        {
            "introduction": "我们的动手实践始于浸入边界法核心的一个基本计算：将流体速度场插值到结构点上。这个练习  展示了离散delta函数如何充当欧拉和拉格朗日表征之间的桥梁。通过解决这个问题，您不仅将练习插值公式的计算，还将发现所选核函数的一个优雅特性，它极大地简化了计算，从而突显了底层数学理论的重要性。",
            "id": "4108003",
            "problem": "考虑用于流固耦合的浸入边界(IB)法，其中插值算子通过一个平滑离散狄拉克函数将欧拉速度场映射到拉格朗日点速度。在周期性域 $\\Omega = [0,1] \\times [0,1]$ 上使用无量纲单位，网格为均匀笛卡尔网格，网格间距 $h = 0.1$，因此网格节点位于 $(x_i, y_j) = (i h, j h)$，其中 $i, j$ 为整数。设欧拉速度场由解析式 $\\mathbf{u}(x,y) = (2x - y,\\, -x + 3y)$ 定义。\n\nIB插值算子 $J$ 通过以下公式将 $\\mathbf{u}$ 映射到拉格朗日点 $\\mathbf{X}_q$ 上的拉格朗日速度 $\\mathbf{U}(\\mathbf{X}_q)$：\n$$\n\\mathbf{U}(\\mathbf{X}_q) = \\sum_{i} \\sum_{j} \\mathbf{u}(x_i, y_j)\\, \\delta_h(\\mathbf{X}_q - (x_i, y_j))\\, h^2,\n$$\n其中离散狄拉克函数 $\\delta_h$ 由张量积定义为\n$$\n\\delta_h(\\mathbf{r}) = \\frac{1}{h^2}\\, \\phi_4\\!\\left(\\frac{r_x}{h}\\right)\\, \\phi_4\\!\\left(\\frac{r_y}{h}\\right), \\quad \\mathbf{r} = (r_x, r_y),\n$$\n而 $\\phi_4(r)$ 是由下式给出的四点核函数：\n$$\n\\phi_4(r) = \\begin{cases}\n\\frac{1}{8}\\left(3 - 2|r| + \\sqrt{1 + 4|r| - 4 r^2}\\right),  &\\text{若 } |r| \\le 1, \\\\\n\\frac{1}{8}\\left(5 - 2|r| - \\sqrt{-7 + 12|r| - 4 r^2}\\right),  &\\text{若 } 1  |r| \\le 2, \\\\\n0,  \\text{若 } |r|  2.\n\\end{cases}\n$$\n\n使用上述四点核函数，计算位于 $\\mathbf{X}_1 = (0.3, 0.5)$、$\\mathbf{X}_2 = (0.6, 0.5)$ 和 $\\mathbf{X}_3 = (0.9, 0.5)$ 这三个拉格朗日点上的 $J \\mathbf{u}$。你的最终答案必须以单行矩阵的形式，按 $(U_{1x}, U_{1y}, U_{2x}, U_{2y}, U_{3x}, U_{3y})$ 的顺序列出插值速度分量。无需四舍五入，并以无量纲单位报告结果。",
            "solution": "该问题要求计算在三个指定的拉格朗日点 $\\mathbf{X}_1$、$\\mathbf{X}_2$ 和 $\\mathbf{X}_3$ 上的插值速度，记为 $J\\mathbf{u}$。插值是在浸入边界(IB)法框架下，从欧拉网格到拉格朗日点进行的。\n\n拉格朗日点 $\\mathbf{X}_q$ 上的速度由插值算子 $J$ 给出：\n$$\n\\mathbf{U}(\\mathbf{X}_q) = \\sum_{i} \\sum_{j} \\mathbf{u}(x_i, y_j)\\, \\delta_h(\\mathbf{X}_q - (x_i, y_j))\\, h^2\n$$\n其中 $\\mathbf{u}(x_i, y_j)$ 是网格节点 $(x_i, y_j) = (ih, jh)$ 处的欧拉速度，$h=0.1$ 是网格间距，$\\delta_h$ 是离散狄拉克函数。离散狄拉克函数定义为一维核函数 $\\phi_4$ 的张量积：\n$$\n\\delta_h(\\mathbf{r}) = \\frac{1}{h^2}\\, \\phi_4\\!\\left(\\frac{r_x}{h}\\right)\\, \\phi_4\\!\\left(\\frac{r_y}{h}\\right)\n$$\n将此定义代入插值公式，我们得到：\n$$\n\\mathbf{U}(\\mathbf{X}_q) = \\sum_{i} \\sum_{j} \\mathbf{u}(x_i, y_j)\\, \\left(\\frac{1}{h^2}\\, \\phi_4\\!\\left(\\frac{X_{qx} - x_i}{h}\\right)\\, \\phi_4\\!\\left(\\frac{X_{qy} - y_j}{h}\\right)\\right)\\, h^2\n$$\n$h^2$ 项相互抵消，得到插值速度的简化表达式：\n$$\n\\mathbf{U}(\\mathbf{X}_q) = \\sum_{i,j} \\mathbf{u}(ih, jh) \\phi_4\\left(\\frac{X_{qx}}{h} - i\\right) \\phi_4\\left(\\frac{X_{qy}}{h} - j\\right)\n$$\n直接计算将涉及对所有使得核函数乘积非零的网格点 $(ih, jh)$ 的贡献进行求和。核函数 $\\phi_4(r)$ 的支集为 $|r| \\le 2$，这意味着我们只需要对满足 $|\\frac{X_{qx}}{h} - i| \\le 2$ 和 $|\\frac{X_{qy}}{h} - j| \\le 2$ 的网格索引 $i$ 和 $j$ 进行求和。\n\n然而，所提供的特定四点核函数 $\\phi_4(r)$ 是由 C. S. Peskin 开发的标准核函数，其构造满足特定的矩条件，以确保一定的精度阶。该核函数的关键性质是：\n1.  单位分解（零阶矩）：对于任意 $r \\in \\mathbb{R}$，$\\sum_{k \\in \\mathbb{Z}} \\phi_4(r - k) = 1$。\n2.  一阶矩条件：对于任意 $r \\in \\mathbb{R}$，$\\sum_{k \\in \\mathbb{Z}} (k - r) \\phi_4(r - k) = 0$。\n\n这一维核函数的性质可以推广到二维张量积权重函数 $W(\\mathbf{X}_q, \\mathbf{x}_{ij}) = \\phi_4(\\frac{X_{qx}}{h} - i) \\phi_4(\\frac{X_{qy}}{h} - j)$。\n权重之和为：\n$$\n\\sum_{i,j} W(\\mathbf{X}_q, \\mathbf{x}_{ij}) = \\left(\\sum_i \\phi_4\\left(\\frac{X_{qx}}{h} - i\\right)\\right) \\left(\\sum_j \\phi_4\\left(\\frac{X_{qy}}{h} - j\\right)\\right) = 1 \\cdot 1 = 1\n$$\n该插值格式的一阶矩为：\n$$\n\\sum_{i,j} (\\mathbf{x}_{ij} - \\mathbf{X}_q) W(\\mathbf{X}_q, \\mathbf{x}_{ij}) = \\mathbf{0}\n$$\n这是因为，以x分量为例，我们有：\n$$\n\\sum_{i,j} (ih - X_{qx}) W = h \\sum_i \\left(i - \\frac{X_{qx}}{h}\\right) \\phi_4\\left(\\frac{X_{qx}}{h} - i\\right) \\sum_j \\phi_4\\left(\\frac{X_{qy}}{h} - j\\right)\n$$\n由于一阶矩条件，第一个和为零，而第二个和为一。对于y分量，也有类似的论证。\n\n给定的欧拉速度场是 $\\mathbf{u}(x,y) = (2x - y, -x + 3y)$。这是关于空间坐标 $(x,y)$ 的一个线性函数。任何线性向量场都可以围绕一个点 $\\mathbf{X}_q$ 表示为 $\\mathbf{u}(\\mathbf{x}) = \\mathbf{u}(\\mathbf{X}_q) + \\mathbf{A}(\\mathbf{x} - \\mathbf{X}_q)$，其中 $\\mathbf{A}$ 是一个导数常数矩阵。\n\n当我们将插值算子应用于这个线性场时，我们得到：\n$$\n\\mathbf{U}(\\mathbf{X}_q) = \\sum_{i,j} \\mathbf{u}(\\mathbf{x}_{ij}) W(\\mathbf{X}_q, \\mathbf{x}_{ij}) = \\sum_{i,j} \\left[ \\mathbf{u}(\\mathbf{X}_q) + \\mathbf{A}(\\mathbf{x}_{ij} - \\mathbf{X}_q) \\right] W(\\mathbf{X}_q, \\mathbf{x}_{ij})\n$$\n分配求和：\n$$\n\\mathbf{U}(\\mathbf{X}_q) = \\mathbf{u}(\\mathbf{X}_q) \\left( \\sum_{i,j} W(\\mathbf{X}_q, \\mathbf{x}_{ij}) \\right) + \\mathbf{A} \\left( \\sum_{i,j} (\\mathbf{x}_{ij} - \\mathbf{X}_q) W(\\mathbf{X}_q, \\mathbf{x}_{ij}) \\right)\n$$\n使用矩的性质：\n$$\n\\mathbf{U}(\\mathbf{X}_q) = \\mathbf{u}(\\mathbf{X}_q) \\cdot (1) + \\mathbf{A} \\cdot (\\mathbf{0}) = \\mathbf{u}(\\mathbf{X}_q)\n$$\n这表明，对于一个线性速度场，使用 $\\phi_4$ 核函数的插值能够精确地再现拉格朗日点上的解析速度场。因此，计算密集的求和是不必要的。我们可以通过在每个点 $\\mathbf{X}_q$ 直接计算解析函数 $\\mathbf{u}(x,y)$ 的值来求得所需的速度。\n\n欧拉速度场为 $\\mathbf{u}(x,y) = (u_x, u_y) = (2x - y, -x + 3y)$。\n\n1.  对于拉格朗日点 $\\mathbf{X}_1 = (0.3, 0.5)$：\n    $U_{1x} = 2(0.3) - 0.5 = 0.6 - 0.5 = 0.1$\n    $U_{1y} = -0.3 + 3(0.5) = -0.3 + 1.5 = 1.2$\n\n2.  对于拉格朗日点 $\\mathbf{X}_2 = (0.6, 0.5)$：\n    $U_{2x} = 2(0.6) - 0.5 = 1.2 - 0.5 = 0.7$\n    $U_{2y} = -0.6 + 3(0.5) = -0.6 + 1.5 = 0.9$\n\n3.  对于拉格朗日点 $\\mathbf{X}_3 = (0.9, 0.5)$：\n    $U_{3x} = 2(0.9) - 0.5 = 1.8 - 0.5 = 1.3$\n    $U_{3y} = -0.9 + 3(0.5) = -0.9 + 1.5 = 0.6$\n\n得到的速度分量为 $(U_{1x}, U_{1y}, U_{2x}, U_{2y}, U_{3x}, U_{3y})$。汇总计算出的值为：\n$(0.1, 1.2, 0.7, 0.9, 1.3, 0.6)$。\n这些值在最终答案中以行矩阵的形式呈现。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0.1  1.2  0.7  0.9  1.3  0.6 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在探索了插值算子之后，我们现在转向任何IB实现都必须经过的一个关键验证步骤：确认插值和散布算子的伴随性质。该性质确保了在离散层面上，流体与结构之间交换的功率是守恒的，这是物理真实模拟的一个至关重要的特性。在这个编程练习  中，您将实施一个数值测试，以验证散布算子确实是插值算子的伴随算子，从而为您的基础代码的正确性提供信心。",
            "id": "4107994",
            "problem": "考虑在二维周期性域上用于流固耦合（FSI）的浸入边界法（IBM）。设计算域为方形区域 $[0,1) \\times [0,1)$，其上有一个大小为 $N \\times N$ 的均匀笛卡尔欧拉网格，网格间距为 $h = 1/N$，网格点位于坐标 $(i h, j h)$ 处，其中整数 $i, j \\in \\{0, 1, \\dots, N-1\\}$。设存在一个拉格朗日结构，由 $N_L$ 个点离散化，其位置为 $\\{ \\mathbf{X}_q \\}_{q=0}^{N_L-1} \\subset [0,1)^2$，并具有相关的拉格朗日力 $\\{ \\mathbf{F}_q \\}_{q=0}^{N_L-1} \\in \\mathbb{R}^2$。定义沿结构为常数的拉格朗日弧长间距 $\\Delta s$。\n\n欧拉速度场是一个网格函数 $\\{ \\mathbf{u}_{i,j} \\in \\mathbb{R}^2 \\}_{i,j=0}^{N-1}$。欧拉到拉格朗日插值算子 $J$ 和拉格朗日到欧拉散播算子 $S$ 使用标准的四点离散狄拉克函数（也称为四点 Peskin 核函数）来定义。具体来说，对于 $r \\in \\mathbb{R}$，定义一维核函数 $\\phi(r)$ 为\n$$\n\\phi(r) = \n\\begin{cases}\n\\frac{1}{8}\\Big(3 - 2|r| + \\sqrt{1 + 4|r| - 4 r^2}\\Big),  0 \\le |r|  1, \\\\\n\\frac{1}{8}\\Big(5 - 2|r| - \\sqrt{-7 + 12|r| - 4 r^2}\\Big),  1 \\le |r|  2, \\\\\n0,  |r| \\ge 2,\n\\end{cases}\n$$\n以及二维离散狄拉克函数\n$$\n\\delta_h(\\mathbf{x}) = \\frac{1}{h^2} \\, \\phi\\!\\left(\\frac{x}{h}\\right) \\, \\phi\\!\\left(\\frac{y}{h}\\right),\n$$\n其中 $\\mathbf{x} = (x,y)$ 是在环面 $[0,1)$ 上每个坐标的最小周期位移。\n\n散播算子 $S$ 通过以下方式将拉格朗日力 $\\{\\mathbf{F}_q\\}$ 映射到欧拉力场 $\\{\\mathbf{f}_{i,j}\\}$：\n$$\n\\mathbf{f}_{i,j} = \\sum_{q=0}^{N_L-1} \\mathbf{F}_q \\, \\delta_h\\!\\big((i h, j h) - \\mathbf{X}_q\\big) \\, \\Delta s,\n$$\n而插值算子 $J$ 通过以下方式将欧拉速度 $\\{\\mathbf{u}_{i,j}\\}$ 映射到拉格朗日速度 $\\{\\mathbf{U}_q\\}$：\n$$\n\\mathbf{U}_q = \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\mathbf{u}_{i,j} \\, \\delta_h\\!\\big((i h, j h) - \\mathbf{X}_q\\big) \\, h^2.\n$$\n\n定义欧拉内积\n$$\n\\langle \\mathbf{u}, \\mathbf{v} \\rangle_E = \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\mathbf{u}_{i,j} \\cdot \\mathbf{v}_{i,j} \\, h^2,\n$$\n和拉格朗日内积\n$$\n\\langle \\mathbf{U}, \\mathbf{F} \\rangle_L = \\sum_{q=0}^{N_L-1} \\mathbf{U}_q \\cdot \\mathbf{F}_q \\, \\Delta s.\n$$\n\n从这些核心定义出发，设计并实现一个数值程序，通过计算随机测试场下的两个标量 $\\langle \\mathbf{u}, S \\mathbf{F} \\rangle_E$ 和 $\\langle J \\mathbf{u}, \\mathbf{F} \\rangle_L$ 来验证其伴随性，然后报告其相对误差\n$$\n\\varepsilon_\\mathrm{rel} = \\frac{\\big|\\langle \\mathbf{u}, S \\mathbf{F} \\rangle_E - \\langle J \\mathbf{u}, \\mathbf{F} \\rangle_L\\big|}{\\max\\big(\\big|\\langle \\mathbf{u}, S \\mathbf{F} \\rangle_E\\big|, \\big|\\langle J \\mathbf{u}, \\mathbf{F} \\rangle_L\\big|, \\epsilon\\big)},\n$$\n其中 $\\epsilon$ 是一个小的正常数，以避免除以零。\n\n使用以下测试套件。在所有情况下，拉格朗日结构都是一个半径为 $R = 0.25$、中心为 $\\mathbf{c}$ 的圆，由 $N_L$ 个点均匀离散，具有相等的弧长间距 $\\Delta s = 2 \\pi R / N_L$，其位置为\n$$\n\\mathbf{X}_q = \\mathbf{c} + R \\big(\\cos(2\\pi q / N_L), \\sin(2\\pi q / N_L)\\big) \\quad \\text{mod } 1.\n$$\n为保证可复现性，使用指定的种子从标准正态分布中生成随机的欧拉速度 $\\mathbf{u}_{i,j}$ 和拉格朗日力 $\\mathbf{F}_q$。\n\n测试用例：\n- 用例 1：$N = 16$， $N_L = 16$， $\\mathbf{c} = (0.5, 0.5)$， 种子 $= 1234$。\n- 用例 2：$N = 32$， $N_L = 32$， $\\mathbf{c} = (0.8, 0.2)$， 种子 $= 5678$。\n- 用例 3：$N = 64$， $N_L = 64$， $\\mathbf{c} = (0.1, 0.9)$， 种子 $= 42$。\n- 用例 4：$N = 64$， $N_L = 32$， $\\mathbf{c} = (0.5, 0.5)$， 种子 $= 2468$。\n- 用例 5：$N = 128$， $N_L = 128$， $\\mathbf{c} = (0.5, 0.5)$， 种子 $= 31415$。\n\n实现细节与说明：\n- 在一个坐标上，差值 $\\Delta$ 的最小周期位移应在单位环面上计算为 $((\\Delta + 0.5) \\bmod 1) - 0.5$，以强制实现周期性。\n- 所有向量点积均为 $\\mathbb{R}^2$ 中的标准欧几里得点积。\n- 在相对误差公式中使用 $\\epsilon = 10^{-16}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目对应于相应测试用例的相对误差 $\\varepsilon_\\mathrm{rel}$，并以小数点后六位的科学记数法报告（例如，$[1.234567\\text{e-}08,9.876543\\text{e-}12,\\dots]$）。",
            "solution": "该问题要求对拉格朗日到欧拉散播算子 $S$ 与欧拉到拉格朗日插值算子 $J$ 之间的伴随关系进行数值验证。这种关系是浸入边界法（IBM）的基石，因为它确保了结构对流体所做的功率等于结构从流体吸收的功率，从而在离散层面上实现了能量守恒。该伴随性质的形式化表述为 $\\langle \\mathbf{u}, S \\mathbf{F} \\rangle_E = \\langle J \\mathbf{u}, \\mathbf{F} \\rangle_L$，其中 $\\langle \\cdot, \\cdot \\rangle_E$ 和 $\\langle \\cdot, \\cdot \\rangle_L$ 分别是欧拉内积和拉格朗日内积。我们的任务是为一系列测试用例计算两个标量值 $\\langle \\mathbf{u}, S \\mathbf{F} \\rangle_E$ 和 $\\langle J \\mathbf{u}, \\mathbf{F} \\rangle_L$，并报告它们之间的相对误差 $\\varepsilon_\\mathrm{rel}$。一个与机器精度同量级的微小误差将作为对数值实现正确性的有力验证。\n\n该解决方案是围绕所提供的精确数学定义来设计的。其核心组件是四点 Peskin 核函数，即一个离散狄拉克函数 $\\delta_h(\\mathbf{x})$。该核函数用于调节非周期性的拉格朗日结构与周期性的欧拉网格之间的相互作用。它被定义为一维核函数的乘积，即 $\\delta_h(x,y) = \\frac{1}{h^2} \\phi(x/h) \\phi(y/h)$，并具有 $4h \\times 4h$ 的有限支集。这种有限支集在计算上至关重要，因为它意味着每个拉格朗日点仅与其周围一个小的、固定大小（$4 \\times 4$）的相邻欧拉网格点模板相互作用。必须特别注意域 $[0,1)^2$ 的周期性，这要求所有位移都必须计算为环面上的最小距离。问题中为单坐标位移 $\\Delta$ 指定了公式 $((\\Delta + 0.5) \\pmod 1) - 0.5$，该公式被直接实现。\n\n每个测试用例的总体算法如下：\n\n$1$. **初始化**：给定参数 $N$、$N_L$、圆心 $\\mathbf{c}$ 和一个随机种子，我们首先计算欧拉网格间距 $h = 1/N$ 和拉格朗日弧长间距 $\\Delta s = 2 \\pi R / N_L$，其中半径 $R=0.25$。\n$2$. **场的生成**：使用提供的种子，我们生成一个随机的欧拉速度场 $\\{\\mathbf{u}_{i,j}\\}$ 和一个随机的拉格朗日力场 $\\{\\mathbf{F}_q\\}$。拉格朗日标记点的位置 $\\{\\mathbf{X}_q\\}$ 被确定性地放置在一个圆上，其坐标通过模 1 运算映射到域 $[0,1)^2$ 中。\n$3$. **计算 $\\langle \\mathbf{u}, S \\mathbf{F} \\rangle_E$**：该项分两步计算。首先，我们计算欧拉力密度场 $\\mathbf{f} = S\\mathbf{F}$。这是“散播”步骤，我们遍历每个拉格朗日点 $q$。对于每个点，力 $\\mathbf{F}_q$ 被分配到其附近的 $4 \\times 4$ 欧拉网格点 $(i,j)$ 模板上。对每个网格点 $\\mathbf{f}_{i,j}$ 的贡献由 $\\delta_h((ih, jh) - \\mathbf{X}_q) \\Delta s$ 加权。一旦完整的场 $\\mathbf{f}$ 被构建完成，我们计算欧拉内积 $\\langle \\mathbf{u}, \\mathbf{f} \\rangle_E = \\sum_{i,j} (\\mathbf{u}_{i,j} \\cdot \\mathbf{f}_{i,j}) h^2$。\n$4$. **计算 $\\langle J \\mathbf{u}, \\mathbf{F} \\rangle_L$**：该项也分两步计算。首先，我们计算拉格朗日速度场 $\\mathbf{U} = J\\mathbf{u}$。这是“插值”步骤。我们遍历每个拉格朗日点 $q$。对于每个点，我们通过对同一 $4 \\times 4$ 网格点模板上的欧拉速度 $\\mathbf{u}_{i,j}$ 的加权贡献求和来计算其速度 $\\mathbf{U}_q$。权重因子为 $\\delta_h((ih, jh) - \\mathbf{X}_q) h^2$。一旦完整的场 $\\mathbf{U}$ 被构建完成，我们计算拉格朗日内积 $\\langle \\mathbf{U}, \\mathbf{F} \\rangle_L = \\sum_q (\\mathbf{U}_q \\cdot \\mathbf{F}_q) \\Delta s$。\n$5$. **误差计算**：计算出两个标量后，我们根据问题中的定义计算相对误差 $\\varepsilon_\\mathrm{rel}$，使用一个小的常数 $\\epsilon = 10^{-16}$ 来防止除以零。\n\n该过程若在实现时注意浮点运算和索引，便能稳健地测试伴随性质。两个最终的标量是通过以两种不同顺序执行大规模求和来计算的。它们之间的偏差既是理论性质的绝佳度量，也是实现保真度的绝佳度量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the adjointness test for the Immersed Boundary Method.\n    \"\"\"\n    test_cases = [\n        # (N, N_L, center, seed)\n        (16, 16, (0.5, 0.5), 1234),\n        (32, 32, (0.8, 0.2), 5678),\n        (64, 64, (0.1, 0.9), 42),\n        (64, 32, (0.5, 0.5), 2468),\n        (128, 128, (0.5, 0.5), 31415),\n    ]\n\n    epsilon = 1e-16\n    R = 0.25\n    results = []\n\n    def phi(r):\n        \"\"\"Computes the one-dimensional four-point Peskin kernel.\"\"\"\n        r_abs = np.abs(r)\n        val = np.zeros_like(r_abs, dtype=float)\n        \n        mask1 = r_abs  1\n        r1 = r_abs[mask1]\n        arg_sqrt1 = 1 + 4 * r1 - 4 * r1**2\n        arg_sqrt1[arg_sqrt1  0] = 0\n        val[mask1] = (1.0/8.0) * (3.0 - 2.0*r1 + np.sqrt(arg_sqrt1))\n        \n        mask2 = (r_abs = 1)  (r_abs  2)\n        r2 = r_abs[mask2]\n        arg_sqrt2 = -7.0 + 12.0*r2 - 4.0*r2**2\n        arg_sqrt2[arg_sqrt2  0] = 0\n        val[mask2] = (1.0/8.0) * (5.0 - 2.0*r2 - np.sqrt(arg_sqrt2))\n        \n        return val\n\n    def periodic_diff(v1, v2):\n        \"\"\"Computes the minimal periodic displacement vector from v2 to v1.\"\"\"\n        diff = v1 - v2\n        return (diff + 0.5) % 1.0 - 0.5\n\n    for N, N_L, c, seed in test_cases:\n        c = np.array(c)\n        h = 1.0 / N\n        delta_s = 2.0 * np.pi * R / N_L\n\n        rng = np.random.default_rng(seed)\n        u_field = rng.standard_normal(size=(N, N, 2))\n        F_lagrangian = rng.standard_normal(size=(N_L, 2))\n\n        angles = 2.0 * np.pi * np.arange(N_L) / N_L\n        X_lagrangian = c[None, :] + R * np.vstack([np.cos(angles), np.sin(angles)]).T\n        X_lagrangian %= 1.0\n\n        # Term 1: u, S F_E\n        f_eulerian = np.zeros((N, N, 2))\n        for q in range(N_L):\n            r_norm = X_lagrangian[q] / h\n            ix_base = int(np.floor(r_norm[0]))\n            iy_base = int(np.floor(r_norm[1]))\n            for i_off in range(-1, 3):\n                for j_off in range(-1, 3):\n                    i = (ix_base + i_off) % N\n                    j = (iy_base + j_off) % N\n                    grid_pt = np.array([i * h, j * h])\n                    r_vec = periodic_diff(grid_pt, X_lagrangian[q])\n                    phi_x = phi(np.array([r_vec[0]/h]))[0]\n                    phi_y = phi(np.array([r_vec[1]/h]))[0]\n                    delta_h_val = (1/h**2) * phi_x * phi_y\n                    f_eulerian[i, j, :] += F_lagrangian[q, :] * delta_h_val * delta_s\n        \n        inner_product_E = np.sum(u_field * f_eulerian) * h**2\n\n        # Term 2: J u, F_L\n        U_lagrangian = np.zeros((N_L, 2))\n        for q in range(N_L):\n            r_norm = X_lagrangian[q] / h\n            ix_base = int(np.floor(r_norm[0]))\n            iy_base = int(np.floor(r_norm[1]))\n            for i_off in range(-1, 3):\n                for j_off in range(-1, 3):\n                    i = (ix_base + i_off) % N\n                    j = (iy_base + j_off) % N\n                    grid_pt = np.array([i * h, j * h])\n                    r_vec = periodic_diff(grid_pt, X_lagrangian[q])\n                    phi_x = phi(np.array([r_vec[0]/h]))[0]\n                    phi_y = phi(np.array([r_vec[1]/h]))[0]\n                    delta_h_val = (1/h**2) * phi_x * phi_y\n                    U_lagrangian[q, :] += u_field[i, j, :] * delta_h_val * h**2\n        \n        inner_product_L = np.sum(U_lagrangian * F_lagrangian) * delta_s\n\n        # Relative Error\n        numerator = np.abs(inner_product_E - inner_product_L)\n        denominator = max(np.abs(inner_product_E), np.abs(inner_product_L), epsilon)\n        relative_error = numerator / denominator if denominator  0 else 0.0\n        results.append(relative_error)\n\n    print(f\"[{','.join(f'{err:.6e}' for err in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在我们已经验证过的算子基础上，我们最后的实践将它们集成到一个完整（尽管简化）的动态模拟中。这个高级问题  要求您将一个浸入式弹簧与使用谱方法求解的斯托克斯流耦合，并使用隐式后向欧拉格式在时间上推进系统。通过追踪系统的势能，您将通过数值方式证明该方法的无条件稳定性——这是稳健隐式格式的一个标志，并获得关于流体求解器、流固耦合和时间积分器之间相互作用的实践经验。",
            "id": "4108037",
            "problem": "考虑一个边长为 $L$ 的方形周期性域中的二维不可压缩斯托克斯流，其黏度为均匀的 $\\mu$。一个位于位置 $\\mathbf{X}(t) \\in \\mathbb{R}^2$ 的拉格朗日结构点通过一个刚度为 $k  0$ 的线性胡克弹簧被束缚在一个固定的锚点 $\\mathbf{X}_0 \\in \\mathbb{R}^2$ 上，因此拉格朗日力为 $\\mathbf{F}(\\mathbf{X}) = -k \\left( \\mathbf{X} - \\mathbf{X}_0 \\right)$。该结构通过沉浸边界法（Immersed Boundary (IB) method）与流体耦合，在每个空间方向上使用宽度参数为 $\\sigma  0$ 的正则化delta函数 $\\delta_\\varepsilon$。在稳态斯托克斯状态下的流体方程和IB耦合方程如下\n$$\n\\mu \\Delta \\mathbf{u} - \\nabla p + \\mathbf{f} = \\mathbf{0}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n$$\n\\mathbf{f}(\\mathbf{x}) = \\mathbf{F}(\\mathbf{X}) \\, \\delta_\\varepsilon(\\mathbf{x} - \\mathbf{X}), \\quad \\mathbf{U}(\\mathbf{X}) = \\int_{\\Omega} \\mathbf{u}(\\mathbf{x}) \\, \\delta_\\varepsilon(\\mathbf{x} - \\mathbf{X}) \\, \\mathrm{d}\\mathbf{x},\n$$\n其中 $\\mathbf{u}$ 是欧拉流体速度，$p$ 是压力，$\\mathbf{f}$ 是由结构产生的欧拉力密度，$\\mathbf{U}(\\mathbf{X})$ 是在拉格朗日点上的插值流体速度。\n\n您的任务是为稳态斯托克斯状态下的拉格朗日点实现一个后向欧拉时间步进更新，并通过计算离散能量变化来验证其无条件稳定性。所有量均为无量纲。后向欧拉更新由以下公式隐式定义\n$$\n\\mathbf{X}^{n+1} = \\mathbf{X}^n + \\Delta t \\, \\mathbf{U}\\!\\left(\\mathbf{X}^{n+1}\\right),\n$$\n其中 $\\Delta t  0$ 是时间步长，$\\mathbf{U}(\\cdot)$ 由带有IB耦合的斯托克斯解确定。正则化delta函数 $\\delta_\\varepsilon$ 必须采用宽度为 $\\sigma$ 的可分离高斯函数，即在一维情况下为\n$$\n\\phi_\\sigma(x) = \\frac{1}{\\sqrt{\\pi}\\,\\sigma} \\exp\\!\\left( - \\frac{x^2}{\\sigma^2} \\right),\n$$\n在二维情况下为 $\\delta_\\varepsilon(\\mathbf{x}) = \\phi_\\sigma(x) \\, \\phi_\\sigma(y)$，并作周期性处理。\n\n您必须：\n- 在一个 $N_x \\times N_y$ 的均匀网格上离散化周期域，网格间距为 $h = L/N_x = L/N_y$，并通过将 $\\mathbf{f}$ 的傅里叶变换投影到无散度模态上并对拉普拉斯算子求逆，以谱方法求解稳态斯托克斯方程。对 $\\mathbf{k}\\neq \\mathbf{0}$ 使用 $k$ 空间投影 $\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^\\top}{\\|\\mathbf{k}\\|^2}$，并将 $\\mathbf{u}$ 的零模态设为零。\n- 使用可分离高斯核实现IB散布和插值，确保离散权重被归一化，使得 $\\sum_{i,j} w_{i,j} h^2 = 1$，并且插值近似于 $\\int \\mathbf{u} \\, \\delta_\\varepsilon \\, \\mathrm{d}\\mathbf{x}$。\n- 对于单个拉格朗日点，当结构位于网格点且高斯函数中心在该点上时，数值计算由 $\\mathbf{U} = m \\, \\mathbf{F}$ 定义的自迁移率标量 $m(\\sigma,\\mu,L)$。使用此值来评估线性弹簧束缚的后向欧拉更新。\n- 对每个测试案例，计算离散能量 $E^n = \\frac{1}{2} k \\left\\|\\mathbf{X}^n - \\mathbf{X}_0\\right\\|^2$ 和能量变化 $\\Delta E = E^{n+1} - E^n$；报告 $\\Delta E$。\n\n使用以下测试套件，它改变时间步长 $\\Delta t$、刚度 $k$ 和核宽度 $\\sigma$ 来探测无条件稳定性以及由正则化核引入的阻尼。在所有情况下，取 $L = 1$，将锚点置于域中心 $\\mathbf{X}_0 = (L/2, L/2)$，并初始化 $\\mathbf{X}^n = \\mathbf{X}_0 + \\mathbf{d}$。\n\n- 测试案例1（正常路径）：$N_x = N_y = 64$, $\\mu = 1$, $k = 100$, $\\Delta t = 10$, $\\sigma = 1.5 h$, $\\mathbf{d} = (0.1, -0.05)$。\n- 测试案例2（极大时间步长和刚度）：$N_x = N_y = 64$, $\\mu = 1$, $k = 10^5$, $\\Delta t = 1000$, $\\sigma = 1.5 h$, $\\mathbf{d} = (0.2, 0.2)$。\n- 测试案例3（窄核）：$N_x = N_y = 64$, $\\mu = 1$, $k = 1000$, $\\Delta t = 1$, $\\sigma = 0.5 h$, $\\mathbf{d} = (0.05, -0.02)$。\n- 测试案例4（宽核）：$N_x = N_y = 64$, $\\mu = 1$, $k = 100$, $\\Delta t = 1$, $\\sigma = 3 h$, $\\mathbf{d} = (0.02, 0.01)$。\n- 测试案例5（零初始位移的边界情况）：$N_x = N_y = 64$, $\\mu = 1$, $k = 100$, $\\Delta t = 10$, $\\sigma = 1.5 h$, $\\mathbf{d} = (0, 0)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是相应测试案例的 $\\Delta E$ 的浮点值。所有量都是无量纲的，且不涉及角度。",
            "solution": "用户提供的问题经评估为 **有效**。该问题在科学上基于计算流体动力学的原理，特别是针对斯托克斯流的沉浸边界法（IB）。该问题是适定的，所有必要的参数和方程都已定义，从而导出一个唯一且可计算的解。语言客观，设置一致。\n\n求解过程主要分为四个阶段：\n1.  **谱方法斯托克斯求解器**：在周期域上的稳态不可压缩斯托克斯方程使用傅里叶谱方法进行有效求解。\n2.  **沉浸边界耦合**：流体与拉格朗日结构之间的相互作用通过一个正则化的高斯delta函数来处理，该函数为适应域而被适当地周期化。\n3.  **迁移率计算**：计算一个关键参数，即标量迁移率 $m$。在迁移率张量为对角且各向同性的近似下，该常数关联了结构施加的力与其所经历的速度。这种近似因设置的对称性而合理。\n4.  **后向欧拉时间步**：拉格朗日点的位置使用隐式后向欧拉格式进行更新，该格式已知是无条件稳定的。计算系统势能的变化以验证此属性。\n\n### 1. 理论公式\n\n流体-结构系统由以下方程描述：\n-   **斯托克斯流**：$\\mu \\Delta \\mathbf{u} - \\nabla p + \\mathbf{f} = \\mathbf{0}$，其中 $\\nabla \\cdot \\mathbf{u} = 0$，$\\mu$ 是黏度，$\\mathbf{u}$ 是流体速度，$p$ 是压力，$\\mathbf{f}$ 是来自结构的力密度。\n-   **拉格朗日力**：一个线性弹簧将点 $\\mathbf{X}$ 连接到锚点 $\\mathbf{X}_0$：$\\mathbf{F} = -k(\\mathbf{X} - \\mathbf{X}_0)$。\n-   **IB耦合**：力通过delta函数 $\\delta_\\varepsilon$ 散布到流体中：$\\mathbf{f}(\\mathbf{x}) = \\mathbf{F} \\delta_\\varepsilon(\\mathbf{x} - \\mathbf{X})$。流体速度被插值回该点：$\\mathbf{U}(\\mathbf{X}) = \\int \\mathbf{u}(\\mathbf{x}) \\delta_\\varepsilon(\\mathbf{x} - \\mathbf{X}) d\\mathbf{x}$。\n-   **拉格朗日点运动**：该点随插值的流体速度移动：$d\\mathbf{X}/dt = \\mathbf{U}(\\mathbf{X})$。\n\n时间演化使用后向欧拉步长进行离散化：\n$$\n\\frac{\\mathbf{X}^{n+1} - \\mathbf{X}^n}{\\Delta t} = \\mathbf{U}(\\mathbf{X}^{n+1})\n$$\n该问题是线性的，因此速度 $\\mathbf{U}$ 与力 $\\mathbf{F}$ 成线性比例。这种关系由一个迁移率算子 $\\mathcal{M}$ 定义：$\\mathbf{U} = \\mathcal{M}[\\mathbf{F}]$。由于周期域的对称性和各向同性的核，该算子可以近似为一个标量迁移率 $m$，使得 $\\mathbf{U} \\approx m \\mathbf{F}$。在步骤 $n+1$ 时的力是 $\\mathbf{F}^{n+1} = -k(\\mathbf{X}^{n+1} - \\mathbf{X}_0)$。将这些代入后向欧拉方程得到：\n$$\n\\mathbf{X}^{n+1} - \\mathbf{X}^n = \\Delta t \\, m \\left( -k(\\mathbf{X}^{n+1} - \\mathbf{X}_0) \\right)\n$$\n整理得到 $\\mathbf{X}^{n+1}$ 的直接更新公式：\n$$\n\\mathbf{X}^{n+1} (1 + k m \\Delta t) = \\mathbf{X}^n + k m \\Delta t \\mathbf{X}_0\n$$\n$$\n\\mathbf{X}^{n+1} = \\frac{1}{1 + k m \\Delta t} \\mathbf{X}^n + \\frac{k m \\Delta t}{1 + k m \\Delta t} \\mathbf{X}_0\n$$\n这个更新是无条件稳定的，因为对于 $k, m, \\Delta t  0$，$\\mathbf{X}^n - \\mathbf{X}_0$ 的前置因子总是小于1。弹簧的势能为 $E = \\frac{1}{2} k \\|\\mathbf{X} - \\mathbf{X}_0\\|^2$。能量的变化 $\\Delta E = E^{n+1} - E^{n}$ 必须为负（如果已处于平衡状态则为零），表示能量耗散到流体中。\n\n### 2. 数值实现\n\n**谱方法斯托克斯求解器：**\n我们在一个 $N \\times N$ 的网格上离散化域 $\\Omega = [0, L] \\times [0, L]$，网格间距为 $h = L/N$。在傅里叶空间中，斯托克斯方程变为代数方程。速度的傅里叶变换 $\\hat{\\mathbf{u}}$ 可由力密度的傅里叶变换 $\\hat{\\mathbf{f}}$ 求得：\n$$\n\\hat{\\mathbf{u}}(\\mathbf{k}) = \\frac{1}{\\mu \\|\\mathbf{k}\\|^2} \\mathbf{P}(\\mathbf{k}) \\hat{\\mathbf{f}}(\\mathbf{k}), \\quad \\text{for } \\mathbf{k} \\neq \\mathbf{0}\n$$\n其中 $\\mathbf{k}=(k_x, k_y)$ 是波矢量，$\\|\\mathbf{k}\\|^2 = k_x^2 + k_y^2$，$\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\mathbf{k}\\mathbf{k}^\\top / \\|\\mathbf{k}\\|^2$ 是强制执行无散度条件 $\\nabla \\cdot \\mathbf{u}=0$ 的投影算子。零波数模态 $\\hat{\\mathbf{u}}(\\mathbf{0})$ 设为零。\n\n**正则化Delta函数：**\n高斯核 $\\delta_\\varepsilon(\\mathbf{x}) = \\phi_\\sigma(x)\\phi_\\sigma(y)$，其中 $\\phi_\\sigma(z) = (\\sqrt{\\pi}\\sigma)^{-1} \\exp(-z^2/\\sigma^2)$，必须在域上周期化。这通过对其周期性镜像求和来实现：$\\phi_{p,\\sigma}(z) = \\sum_{l=-\\infty}^{\\infty} \\phi_\\sigma(z - lL)$。在实践中，由于高斯函数的快速衰减，对少数几个镜像（例如 $l \\in \\{-1, 0, 1\\}$）求和就足够了。\n\n计算用于散布和插值的离散权重 $w_{ij} = \\delta_\\varepsilon(\\mathbf{x}_{ij}-\\mathbf{X})$。为确保施加到流体的总力等于拉格朗日力（$\\sum_{i,j} \\mathbf{f}_{ij} h^2 = \\mathbf{F}$），我们通过将原始权重除以其离散和乘以 $h^2$ 来强制执行离散归一化 $\\sum_{i,j} w_{ij} h^2 = 1$。\n\n**迁移率计算 ($m$)：**\n对于每一组唯一的参数 $(\\sigma, \\mu, L, N)$，数值计算一次标量迁移率 $m$。\n1.  在以网格为中心的拉格朗日点 $\\mathbf{X}_c$ 施加一个测试力 $\\mathbf{F}_{\\text{test}} = (1, 0)$。\n2.  将力散布到网格节点：$\\mathbf{f}_{ij} = \\mathbf{F}_{\\text{test}} \\cdot w_{ij}$，其中 $w_{ij}$ 是对应于 $\\mathbf{X}_c$ 的归一化权重。\n3.  将力场 $\\mathbf{f}$ 变换到傅里叶空间（$\\hat{\\mathbf{f}}$）。\n4.  在傅里叶空间中求解速度场（$\\hat{\\mathbf{u}}$）的斯托克斯方程。\n5.  将速度场变换回实空间（$\\mathbf{u}$）。\n6.  将速度插值回拉格朗日点：$\\mathbf{U} = \\sum_{i,j} \\mathbf{u}_{ij} w_{ij} h^2$。\n7.  迁移率计算为 $m = U_x / F_{\\text{test},x}$。由于对称性，$U_y$ 应可忽略不计。\n\n**主算法：**\n对于每个测试案例：\n1.  确定参数 $N, \\mu, k, \\Delta t, \\sigma$ 和初始位移 $\\mathbf{d}$。\n2.  根据给定的 $\\sigma$ 和 $\\mu$ 检索或计算迁移率 $m$。\n3.  设置锚点 $\\mathbf{X}_0=(L/2, L/2)$ 和初始位置 $\\mathbf{X}^n = \\mathbf{X}_0 + \\mathbf{d}$。\n4.  计算初始能量 $E^n = \\frac{1}{2} k \\|\\mathbf{d}\\|^2$。\n5.  如果 $\\mathbf{d}=\\mathbf{0}$，系统处于平衡状态，所以 $\\Delta E = 0$。\n6.  否则，使用显式后向欧拉更新公式计算新位置 $\\mathbf{X}^{n+1}$。\n7.  计算最终能量 $E^{n+1} = \\frac{1}{2} k \\|\\mathbf{X}^{n+1} - \\mathbf{X}_0\\|^2$。\n8.  最终结果是能量变化 $\\Delta E = E^{n+1} - E^n$。\n对所有测试案例重复此过程。结果证实，在所有情况下 $\\Delta E \\le 0$，表明了该数值方案的耗散性和稳定性。.",
            "answer": "```python\nimport numpy as np\n\ndef periodic_gaussian_1d(x, sigma, L, num_periods=2):\n    \"\"\"\n    Computes a 1D periodic Gaussian by summing over neighboring periods.\n    The sum is over l from -num_periods to +num_periods.\n    \"\"\"\n    val = np.zeros_like(x, dtype=float)\n    for l in range(-num_periods, num_periods + 1):\n        val += np.exp(-((x - l * L)**2) / sigma**2)\n    return val / (np.sqrt(np.pi) * sigma)\n\ndef get_delta_weights(X_lagrangian, grid_1d, sigma, L, h):\n    \"\"\"\n    Computes the normalized discrete delta function weights on the grid.\n    \n    Args:\n        X_lagrangian (np.ndarray): Lagrangian point position (x, y).\n        grid_1d (np.ndarray): 1D array for Eulerian grid coordinates.\n        sigma (float): Width of the Gaussian kernel.\n        L (float): Domain side length.\n        h (float): Grid spacing.\n        \n    Returns:\n        np.ndarray: 2D array of normalized weights.\n    \"\"\"\n    # Create 2D meshgrids for distances dx and dy\n    # Use 'ij' indexing to match (row, col) with (x, y)\n    dx = grid_1d[:, np.newaxis] - X_lagrangian[0]\n    dy = grid_1d[np.newaxis, :] - X_lagrangian[1]\n    \n    # Compute 1D periodic Gaussians along each axis\n    phi_x = periodic_gaussian_1d(dx, sigma, L)\n    phi_y = periodic_gaussian_1d(dy, sigma, L)\n    \n    # Raw 2D weights are the separable product\n    weights_raw = phi_x * phi_y\n    \n    # Normalize to ensure the discrete integral (sum * h^2) is exactly 1\n    normalization_factor = np.sum(weights_raw) * h**2\n    if normalization_factor  1e-12: # Avoid division by zero if kernel is too narrow\n        return np.zeros_like(weights_raw)\n    weights = weights_raw / normalization_factor\n    \n    return weights\n\ndef calculate_mobility(N, L, mu, sigma):\n    \"\"\"\n    Calculates the scalar mobility 'm' for a single point in a periodic\n    Stokes flow using a spectral method.\n    \"\"\"\n    h = L / N\n    grid_1d = np.arange(N) * h\n    \n    # Per problem spec, place structure at a grid point for mobility calculation.\n    # For even N, (L/2, L/2) is a grid point, e.g., grid_1d[N//2].\n    X_center = np.array([L/2, L/2])\n\n    # Get discrete delta weights for a point centered on the grid\n    weights = get_delta_weights(X_center, grid_1d, sigma, L, h)\n    \n    # Apply a unit test force along x-axis\n    F_test = np.array([1.0, 0.0])\n    \n    # 1. Spread force to the grid (force density field)\n    force_grid_x = F_test[0] * weights\n    force_grid_y = F_test[1] * weights # This is an array of zeros\n\n    # 2. FFT of the force field\n    f_hat_x = np.fft.fft2(force_grid_x)\n    f_hat_y = np.fft.fft2(force_grid_y)\n    \n    # 3. Solve for velocity in Fourier space\n    # Set up wavenumbers\n    k_freq = np.fft.fftfreq(N, h)\n    kx_1d = 2 * np.pi * k_freq\n    ky_1d = 2 * np.pi * k_freq\n    kx, ky = np.meshgrid(kx_1d, ky_1d, indexing='ij')\n    \n    ksq = kx**2 + ky**2\n    \n    u_hat_x = np.zeros_like(f_hat_x)\n    u_hat_y = np.zeros_like(f_hat_y)\n    \n    # Find non-zero wavenumbers to avoid division by zero at k=0\n    nonzero_k = ksq  1e-12\n    \n    # Project force onto divergence-free space\n    k_dot_f_hat = kx[nonzero_k] * f_hat_x[nonzero_k] + ky[nonzero_k] * f_hat_y[nonzero_k]\n    \n    P_f_hat_x = f_hat_x[nonzero_k] - kx[nonzero_k] * k_dot_f_hat / ksq[nonzero_k]\n    P_f_hat_y = f_hat_y[nonzero_k] - ky[nonzero_k] * k_dot_f_hat / ksq[nonzero_k]\n\n    # Invert Laplacian (Stokeslet in Fourier space)\n    u_hat_x[nonzero_k] = P_f_hat_x / (mu * ksq[nonzero_k])\n    u_hat_y[nonzero_k] = P_f_hat_y / (mu * ksq[nonzero_k])\n    \n    # 4. IFFT to get real-space velocity field\n    u_x = np.real(np.fft.ifft2(u_hat_x))\n    u_y = np.real(np.fft.ifft2(u_hat_y))\n    \n    # 5. Interpolate velocity at the point using the same weights\n    U_x = np.sum(u_x * weights) * h**2\n    # U_y = np.sum(u_y * weights) * h**2 # Should be near zero by symmetry\n\n    # Mobility m = U_x / F_test_x\n    return U_x\n\ndef solve():\n    test_cases = [\n        {'Nx': 64, 'Ny': 64, 'mu': 1, 'k': 100,    'dt': 10,  'sigma_h': 1.5, 'd': (0.1, -0.05)},\n        {'Nx': 64, 'Ny': 64, 'mu': 1, 'k': 1e5,    'dt': 1000,'sigma_h': 1.5, 'd': (0.2, 0.2)},\n        {'Nx': 64, 'Ny': 64, 'mu': 1, 'k': 1000,   'dt': 1,   'sigma_h': 0.5, 'd': (0.05, -0.02)},\n        {'Nx': 64, 'Ny': 64, 'mu': 1, 'k': 100,    'dt': 1,   'sigma_h': 3.0, 'd': (0.02, 0.01)},\n        {'Nx': 64, 'Ny': 64, 'mu': 1, 'k': 100,    'dt': 10,  'sigma_h': 1.5, 'd': (0.0, 0.0)},\n    ]\n\n    L = 1.0\n    results = []\n    mobility_cache = {}\n\n    for case in test_cases:\n        N = case['Nx']\n        mu = case['mu']\n        h = L / N\n        sigma = case['sigma_h'] * h\n\n        # Use caching for mobility calculation as it only depends on N, mu, sigma\n        cache_key = (N, mu, sigma)\n        if cache_key in mobility_cache:\n            m = mobility_cache[cache_key]\n        else:\n            m = calculate_mobility(N, L, mu, sigma)\n            mobility_cache[cache_key] = m\n            \n        k = case['k']\n        dt = case['dt']\n        d = np.array(case['d'])\n        X0 = np.array([L/2, L/2])\n        \n        # Initial state\n        Xn = X0 + d\n        En = 0.5 * k * np.sum(d**2)\n        \n        # Handle equilibrium case\n        if np.allclose(d, 0):\n            results.append(0.0)\n            continue\n            \n        # Backward Euler Update for X^{n+1}\n        # X^{n+1} = (X^n + k*m*dt*X0) / (1 + k*m*dt)\n        gamma = k * m * dt\n        X_np1 = (Xn + gamma * X0) / (1.0 + gamma)\n\n        # Final energy and energy change\n        d_np1 = X_np1 - X0\n        E_np1 = 0.5 * k * np.sum(d_np1**2)\n        delta_E = E_np1 - En\n        results.append(delta_E)\n\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}