{
    "hands_on_practices": [
        {
            "introduction": "有限体积法的核心在于计算和平衡穿过控制体边界的通量。本练习将让你实践这一核心计算，针对一个控制体表面同时计算对流和扩散通量，这是许多输运方程中的常见情况。通过这个练习，你将巩固对迎风格式（用于对流）和中心差分（用于扩散）等基本离散化方案的实际应用理解。",
            "id": "4087700",
            "problem": "考虑一个被动标量场 $\\phi$，它代表在密度恒为 $\\rho$ 的稳态、不可压缩复杂流体中输运的胶束质量分数（无量纲）。两个相邻的有限体积共享一个平面 $f$，其面积为 $A_f$，相对于左侧单元 $L$ 的外法向单位矢量为 $\\boldsymbol{n}_f$。面面积矢量为 $\\boldsymbol{S}_f = A_f \\boldsymbol{n}_f$。左侧和右侧单元的中心分别位于位置 $\\boldsymbol{x}_L$ 和 $\\boldsymbol{x}_R$，面心速度为 $\\boldsymbol{u}_f$。材料扩散系数为 $D$（菲克扩散），因此守恒形式 $\\nabla \\cdot (\\Gamma \\nabla \\phi)$ 中的扩散输运系数为 $\\Gamma = \\rho D$。\n\n您已获知：\n- $\\rho = 1050\\,\\mathrm{kg\\,m^{-3}}$，\n- $\\boldsymbol{u}_f = (0.6,\\,0.2,\\,0.1)\\,\\mathrm{m\\,s^{-1}}$，\n- $A_f = 0.010\\,\\mathrm{m^2}$，\n- $\\boldsymbol{n}_f = \\frac{1}{\\sqrt{11}}(3,\\,1,\\,1)$，\n- $\\boldsymbol{x}_L = (0.010,\\,0.020,\\,0.000)\\,\\mathrm{m}$，\n- $\\boldsymbol{x}_R = (0.022,\\,0.025,\\,0.003)\\,\\mathrm{m}$，\n- $\\phi_L = 0.24$，$\\phi_R = 0.18$，\n- $D = 2.0 \\times 10^{-9}\\,\\mathrm{m^2\\,s^{-1}}$。\n\n从左侧控制体积上 $\\phi$ 的积分守恒定律和扩散通量的本构关系（菲克定律）出发，推导离开单元 $L$、穿过面 $f$ 的面上对流-扩散通量，将其表示为对流贡献和扩散贡献之和。采用有限体积法（FVM）中标准的以下建模和离散化假设：\n- 对流面值 $\\phi_f$ 是基于穿过面的质量流率的符号，通过一阶迎风格式获得的。\n- 面法向扩散通量使用两点近似，该近似基于 $\\boldsymbol{x}_L$ 和 $\\boldsymbol{x}_R$ 之间 $\\phi$ 的线性变化以及单元中心间矢量在面法线上的投影。\n- 忽略此投影之外的任何非正交修正。\n\n将来自面 $f$ 的左侧单元残差贡献定义为离开单元 $L$、穿过面 $f$ 的净向外通量。计算这个单一的数值。将最终数值答案四舍五入到四位有效数字，并以 $\\mathrm{kg\\,s^{-1}}$ 为单位表示。",
            "solution": "首先根据指定标准对问题进行验证。\n逐字提取已知条件：\n- 密度：$\\rho = 1050\\,\\mathrm{kg\\,m^{-3}}$\n- 面心速度：$\\boldsymbol{u}_f = (0.6,\\,0.2,\\,0.1)\\,\\mathrm{m\\,s^{-1}}$\n- 面面积：$A_f = 0.010\\,\\mathrm{m^2}$\n- 面外法向单位矢量（从单元 $L$）：$\\boldsymbol{n}_f = \\frac{1}{\\sqrt{11}}(3,\\,1,\\,1)$\n- 左单元中心位置：$\\boldsymbol{x}_L = (0.010,\\,0.020,\\,0.000)\\,\\mathrm{m}$\n- 右单元中心位置：$\\boldsymbol{x}_R = (0.022,\\,0.025,\\,0.003)\\,\\mathrm{m}$\n- 左右单元标量值：$\\phi_L = 0.24$, $\\phi_R = 0.18$\n- 材料扩散系数：$D = 2.0 \\times 10^{-9}\\,\\mathrm{m^2\\,s^{-1}}$\n- 扩散输运系数：$\\Gamma = \\rho D$\n- 对流通量离散化：一阶迎风格式。\n- 扩散通量离散化：使用单元中心间矢量在面法线上的投影的两点近似。\n\n验证：\n该问题具有科学依据，描述了使用计算流体动力学基石之一的有限体积法来处理一个标准的输运现象（对流-扩散）。所有术语都已定义，物理原理（菲克定律，质量守恒）也都是标准的。该问题是适定的，因为所有必要的数据和离散格式都已提供，可以计算出唯一的数值答案。语言客观而精确。未发现违反验证标准的情况。该问题被视为有效。\n\n在控制体积 $V$ 上，被动标量 $\\phi$ 的稳态积分守恒定律由下式给出：\n$$ \\oint_{\\partial V} (\\rho \\phi \\boldsymbol{u} - \\Gamma \\nabla\\phi) \\cdot d\\boldsymbol{S} = 0 $$\n积分内的项是总通量矢量，$\\boldsymbol{F} = \\rho \\phi \\boldsymbol{u} - \\Gamma \\nabla\\phi$。问题要求的是面 $f$ 对左侧单元 $L$ 的“残差贡献”，其定义为离开单元 $L$、穿过面 $f$ 的净向外通量。我们将此量记为 $F_f$，它是通量矢量在面面积 $A_f$ 上的面积分。使用标准的有限体积近似，该积分可近似为：\n$$ F_f \\approx \\boldsymbol{F}_f \\cdot \\boldsymbol{S}_f = (\\rho \\phi \\boldsymbol{u})_f \\cdot \\boldsymbol{S}_f - (\\Gamma \\nabla\\phi)_f \\cdot \\boldsymbol{S}_f $$\n其中 $\\boldsymbol{S}_f = A_f \\boldsymbol{n}_f$ 是面面积矢量，下标 $f$ 表示在面中心处取值。我们可以将其分为对流贡献 $F_{f, \\text{adv}}$ 和扩散贡献 $F_{f, \\text{diff}}$。注意，扩散通量矢量为 $\\boldsymbol{j}_d = -\\Gamma \\nabla\\phi$，因此对向外通量的扩散贡献为 $(-\\Gamma\\nabla\\phi)_f \\cdot \\boldsymbol{S}_f$。\n$$ F_f = F_{f, \\text{adv}} + F_{f, \\text{diff}} $$\n其中\n$$ F_{f, \\text{adv}} = (\\rho \\boldsymbol{u})_f \\cdot \\boldsymbol{S}_f \\phi_f $$\n$$ F_{f, \\text{diff}} = -(\\Gamma \\nabla\\phi)_f \\cdot \\boldsymbol{S}_f $$\n\n首先，我们计算对流通量 $F_{f, \\text{adv}}$。这需要穿过面的质量流率 $\\dot{m}_f$ 和标量的面值 $\\phi_f$。\n质量流率为 $\\dot{m}_f = \\rho \\boldsymbol{u}_f \\cdot \\boldsymbol{S}_f = \\rho A_f (\\boldsymbol{u}_f \\cdot \\boldsymbol{n}_f)$。我们来计算点积 $\\boldsymbol{u}_f \\cdot \\boldsymbol{n}_f$：\n$$ \\boldsymbol{u}_f \\cdot \\boldsymbol{n}_f = (0.6, 0.2, 0.1) \\cdot \\frac{1}{\\sqrt{11}}(3, 1, 1) = \\frac{1}{\\sqrt{11}}(0.6 \\times 3 + 0.2 \\times 1 + 0.1 \\times 1) = \\frac{1}{\\sqrt{11}}(1.8 + 0.2 + 0.1) = \\frac{2.1}{\\sqrt{11}} \\,\\mathrm{m\\,s^{-1}} $$\n现在，我们计算 $\\dot{m}_f$：\n$$ \\dot{m}_f = \\rho A_f (\\boldsymbol{u}_f \\cdot \\boldsymbol{n}_f) = (1050\\,\\mathrm{kg\\,m^{-3}}) \\times (0.010\\,\\mathrm{m^2}) \\times \\left(\\frac{2.1}{\\sqrt{11}}\\,\\mathrm{m\\,s^{-1}}\\right) = \\frac{10.5 \\times 2.1}{\\sqrt{11}} = \\frac{22.05}{\\sqrt{11}}\\,\\mathrm{kg\\,s^{-1}} $$\n由于 $\\dot{m}_f > 0$，质量流从单元 $L$ 向外。一阶迎风格式规定，面上的对流标量值 $\\phi_f$ 取自上游单元，即单元 $L$。\n$$ \\phi_f = \\phi_L = 0.24 $$\n那么对流通量为：\n$$ F_{f, \\text{adv}} = \\dot{m}_f \\phi_f = \\left(\\frac{22.05}{\\sqrt{11}}\\right) \\times 0.24 = \\frac{5.292}{\\sqrt{11}}\\,\\mathrm{kg\\,s^{-1}} $$\n\n接下来，我们计算扩散通量 $F_{f, \\text{diff}} = -(\\Gamma \\nabla\\phi)_f \\cdot \\boldsymbol{S}_f = -\\Gamma A_f ((\\nabla\\phi)_f \\cdot \\boldsymbol{n}_f)$。问题指定使用两点格式以及连接单元中心的矢量在面法线上的投影来近似面法向梯度 $(\\nabla\\phi)_f \\cdot \\boldsymbol{n}_f$。\n连接单元中心的矢量为 $\\boldsymbol{d}_{LR} = \\boldsymbol{x}_R - \\boldsymbol{x}_L$：\n$$ \\boldsymbol{d}_{LR} = (0.022 - 0.010, 0.025 - 0.020, 0.003 - 0.000) = (0.012, 0.005, 0.003)\\,\\mathrm{m} $$\n用于梯度近似的有效距离是 $\\boldsymbol{d}_{LR}$ 在 $\\boldsymbol{n}_f$ 上的投影，我们记为 $d_n$：\n$$ d_n = \\boldsymbol{d}_{LR} \\cdot \\boldsymbol{n}_f = (0.012, 0.005, 0.003) \\cdot \\frac{1}{\\sqrt{11}}(3, 1, 1) = \\frac{1}{\\sqrt{11}}(0.012 \\times 3 + 0.005 \\times 1 + 0.003 \\times 1) = \\frac{0.036 + 0.005 + 0.003}{\\sqrt{11}} = \\frac{0.044}{\\sqrt{11}}\\,\\mathrm{m} $$\n面法向梯度近似为：\n$$ (\\nabla\\phi)_f \\cdot \\boldsymbol{n}_f \\approx \\frac{\\phi_R - \\phi_L}{d_n} = \\frac{0.18 - 0.24}{0.044/\\sqrt{11}} = \\frac{-0.06\\sqrt{11}}{0.044}\\,\\mathrm{m^{-1}} $$\n扩散输运系数为 $\\Gamma = \\rho D$：\n$$ \\Gamma = (1050\\,\\mathrm{kg\\,m^{-3}}) \\times (2.0 \\times 10^{-9}\\,\\mathrm{m^2\\,s^{-1}}) = 2100 \\times 10^{-9} = 2.1 \\times 10^{-6}\\,\\mathrm{kg\\,m^{-1}\\,s^{-1}} $$\n现在计算扩散通量：\n$$ F_{f, \\text{diff}} = -\\Gamma A_f \\left(\\frac{\\phi_R - \\phi_L}{d_n}\\right) = -(2.1 \\times 10^{-6}\\,\\mathrm{kg\\,m^{-1}\\,s^{-1}}) \\times (0.010\\,\\mathrm{m^2}) \\times \\left(\\frac{-0.06\\sqrt{11}}{0.044}\\,\\mathrm{m^{-1}}\\right) $$\n$$ F_{f, \\text{diff}} = (2.1 \\times 10^{-8}) \\times \\frac{0.06\\sqrt{11}}{0.044}\\,\\mathrm{kg\\,s^{-1}} = \\frac{0.126\\sqrt{11}}{0.044} \\times 10^{-8}\\,\\mathrm{kg\\,s^{-1}} $$\n\n从单元 $L$ 穿过面 $f$ 的总净向外通量是对流通量和扩散通量之和：\n$$ F_f = F_{f, \\text{adv}} + F_{f, \\text{diff}} = \\frac{5.292}{\\sqrt{11}} + \\frac{0.126\\sqrt{11}}{0.044} \\times 10^{-8}\\,\\mathrm{kg\\,s^{-1}} $$\n现在，我们对此表达式进行数值计算：\n$$ \\sqrt{11} \\approx 3.31662479 $$\n$$ F_{f, \\text{adv}} \\approx \\frac{5.292}{3.31662479} \\approx 1.59554709\\,\\mathrm{kg\\,s^{-1}} $$\n$$ F_{f, \\text{diff}} \\approx \\frac{0.126 \\times 3.31662479}{0.044} \\times 10^{-8} \\approx \\frac{0.4178947}{0.044} \\times 10^{-8} \\approx 9.497607 \\times 10^{-8}\\,\\mathrm{kg\\,s^{-1}} $$\n$$ F_f \\approx 1.59554709 + 0.00000009497607 = 1.595547185\\,\\mathrm{kg\\,s^{-1}} $$\n问题要求将最终答案四舍五入到四位有效数字。\n$$ F_f \\approx 1.596\\,\\mathrm{kg\\,s^{-1}} $$",
            "answer": "$$ \\boxed{1.596} $$"
        },
        {
            "introduction": "掌握了单个表面上的通量计算后，下一步是将其组装成一个完整的模拟。本练习将指导你使用一阶迎风格式，实现一个完整的一维对流求解器。通过模拟一个阶跃函数的运动，你将直接观察并量化该基本方法的关键人工效应——“数值耗散”，并了解它是如何模糊尖锐特征的。",
            "id": "2394306",
            "problem": "考虑一维空间中的线性平流方程，\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\n$$\n在一个长度为 $L$ 的周期性区域上，即 $x \\in [0,L)$，使用周期性边界条件。平流速度 $a$ 是一个正常数。从积分守恒律和均匀网格上的有限体积平均的定义出发，推导一个一阶、显式、守恒的有限体积法，该方法需与 $a>0$ 时信息传播的物理特性相一致。\n\n你将通过模拟一个方块阶跃函数的平流来研究数值扩散，并量化界面随时间的模糊程度。使用一个包含 $N$ 个网格单元的均匀网格，空间步长为 $\\Delta x = L/N$，网格中心为 $x_i = (i+\\tfrac{1}{2})\\Delta x$，其中 $i=0,1,\\dots,N-1$。设初始条件为方块函数\n$$\nu(x,0) = \\begin{cases}\n1,  x \\in [x_L, x_R),\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中 $x_L = 0.2\\,L$ 且 $x_R = 0.7\\,L$。使用一阶有限体积格式和显式时间步长 $\\Delta t$ 来演化解，时间步长 $\\Delta t$ 的选择应满足一个给定的 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = a\\,\\Delta t/\\Delta x$。在给定的模拟中，所有时间步均使用相同的常数 $\\nu$。让模拟运行到一个给定的最终时间 $T$；使用整数个时间步 $n = \\text{round}(T/\\Delta t)$，使得模拟时间为 $t_n = n\\,\\Delta t$。\n\n将在时间 $t_n$ 时下降界面的“模糊宽度”定义为：网格中心廓线向下穿过水平 $\\theta_{\\text{hi}} = 0.9$ 的点，到其后向下穿过水平 $\\theta_{\\text{lo}} = 0.1$ 的点之间的最小空间距离（沿周期性区域测量）。使用相邻网格中心的网格中心值进行线性插值来计算这些穿越点。在存在多个下降界面（由于周期性）的情况下，计算每个下降界面周围的模糊宽度，并报告最小宽度。宽度以与 $L$ 相同的无量纲长度单位表示。\n\n在单个程序中实现模拟和宽度测量。对于下面的每个测试用例，输出在时间 $t_n$ 测得的模糊宽度，四舍五入到 $8$ 位小数。\n\n使用以下测试套件，参数为 $(N,\\ \\nu,\\ T,\\ a,\\ L)$:\n- 用例 1: $(200,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 2: $(200,\\ 0.9,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 3: $(200,\\ 0.2,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 4: $(50,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 5: $(200,\\ 1.0,\\ 0.2,\\ 1.0,\\ 1.0)$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。例如，它应该看起来像\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5],\n$$\n其中每个 $\\text{result}_k$ 是用例 $k$ 的模糊宽度，四舍五入到 $8$ 位小数。不允许有其他输出。",
            "solution": "我们从平流方程的积分守恒形式开始，\n$$\n\\partial_t u(x,t) + \\partial_x f(u) = 0,\\quad f(u) = a u,\\quad a>0.\n$$\n设 $\\mathcal{C}_i = [x_{i-\\tfrac{1}{2}}, x_{i+\\tfrac{1}{2}}]$ 是一个宽度均匀的控制体，$\\Delta x = x_{i+\\tfrac{1}{2}} - x_{i-\\tfrac{1}{2}}$，网格中心为 $x_i = (i+\\tfrac{1}{2})\\Delta x$，索引具有周期性。定义网格平均值\n$$\n\\bar{u}_i(t) = \\frac{1}{\\Delta x}\\int_{\\mathcal{C}_i} u(x,t)\\,dx.\n$$\n将守恒律在 $\\mathcal{C}_i$ 上积分可得\n$$\n\\frac{d}{dt}\\left( \\int_{\\mathcal{C}_i} u(x,t)\\,dx \\right) + \\left[ f(u(x_{i+\\tfrac{1}{2}},t)) - f(u(x_{i-\\tfrac{1}{2}},t)) \\right] = 0,\n$$\n或等价地，\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x}\\left( f_{i+\\tfrac{1}{2}} - f_{i-\\tfrac{1}{2}} \\right),\n$$\n其中 $f_{i\\pm \\tfrac{1}{2}}$ 是通过网格面的通量。使用时间步长 $\\Delta t$ 的一阶显式时间离散得到\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left( \\hat{f}_{i+\\tfrac{1}{2}}^n - \\hat{f}_{i-\\tfrac{1}{2}}^n \\right),\n$$\n其中数值通量 $\\hat{f}_{i+\\tfrac{1}{2}}^n$ 与物理特性一致。对于 $a>0$ 的线性平流，信息从左向右传播，每个界面上的精确黎曼解仅依赖于左侧状态。因此，Godunov 迎风数值通量为\n$$\n\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n\\quad\\text{for }a>0.\n$$\n引入 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = a\\,\\Delta t/\\Delta x$，更新简化为一阶迎风格式\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\nu\\left(\\bar{u}_i^n - \\bar{u}_{i-1}^n\\right),\\quad a>0,\n$$\n其中 $i$ 的索引具有周期性。\n\n为了将此离散方法与连续过程联系起来并揭示数值扩散，我们进行修正方程分析。记 $\\bar{u}_i^n \\approx u(x_i,t^n)$，其中 $t^n = n\\Delta t$。在时间上进行泰勒展开可得\n$$\n\\bar{u}_i^{n+1} - \\bar{u}_i^n = \\Delta t\\,u_t(x_i,t^n) + \\mathcal{O}(\\Delta t^2).\n$$\n对后向差分进行空间上的泰勒展开可得\n$$\n\\bar{u}_i^n - \\bar{u}_{i-1}^n = \\Delta x\\,u_x(x_i,t^n) - \\frac{\\Delta x^2}{2}u_{xx}(x_i,t^n) + \\frac{\\Delta x^3}{6}u_{xxx}(x_i,t^n) + \\mathcal{O}(\\Delta x^4).\n$$\n代入格式中可得\n$$\n\\Delta t\\,u_t = -\\nu\\left[ \\Delta x\\,u_x - \\frac{\\Delta x^2}{2}u_{xx} + \\frac{\\Delta x^3}{6}u_{xxx} + \\cdots \\right] + \\mathcal{O}(\\Delta t^2).\n$$\n两边除以 $\\Delta t$ 并回顾 $\\nu = a\\Delta t/\\Delta x$，\n$$\nu_t + a\\,u_x = \\frac{a\\,\\Delta x}{2}(1 - \\nu)\\,u_{xx} - \\frac{a\\,\\Delta x^2}{6}\\left(1 - 3\\nu + 2\\nu^2\\right)u_{xxx} + \\cdots.\n$$\n主导修正项是一个扩散项，其有效（人工）扩散系数为\n$$\nD_{\\text{num}} = \\frac{a\\,\\Delta x}{2}(1 - \\nu).\n$$\n因此，对于 $0\\nu1$，一阶迎风法会引入数值扩散，该扩散会将间断模糊化，模糊宽度随 $\\sqrt{D_{\\text{num}}\\,t}$ 增长，而当 $\\nu=1$ 时，主导扩散项消失，该方法退化为网格上的纯粹平移算子。\n\n为了量化阶跃的模糊程度，我们定义 10–90 厚度。考虑一个下降界面，其中 $u$ 从接近 $1$ 的值下降到接近 $0$ 的值。设 $\\theta_{\\text{hi}} = 0.9$ 和 $\\theta_{\\text{lo}} = 0.1$。在分段常数的网格中心廓线 $\\{\\bar{u}_i^n\\}$ 上，我们通过在相邻网格中心之间进行线性插值来确定 $u=\\theta$ 的近似位置。具体来说，对于下降前沿上的一对相邻索引 $(i,i+1)$，其中 $\\bar{u}_i^n \\ge \\theta > \\bar{u}_{i+1}^n$，\n$$\nx(\\theta) \\approx x_i + \\Delta x \\frac{\\bar{u}_i^n - \\theta}{\\bar{u}_i^n - \\bar{u}_{i+1}^n}.\n$$\n我们收集整个区域（考虑周期性）所有向下的 $\\theta_{\\text{hi}}$ 穿越点和所有向下的 $\\theta_{\\text{lo}}$ 穿越点，然后对于每个 $\\theta_{\\text{hi}}$ 穿越点，我们确定沿周期坐标到其后的 $\\theta_{\\text{lo}}$ 穿越点的距离。这样的最小距离，记为 $w_{10\\text{–}90}$，就是测得的模糊宽度。该宽度以与 $L$ 相同的长度单位报告。\n\n算法设计：\n- 空间离散：均匀网格，周期性边界条件，一阶迎风通量 $\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n$（对于 $a>0$）。\n- 时间步进：前向欧拉法，使用固定的 $\\Delta t$ 满足给定的 $\\nu = a\\,\\Delta t/\\Delta x$；推进 $n=\\text{round}(T/\\Delta t)$ 步。\n- 初始化：在 $[0.2L, 0.7L)$ 上 $u(x,0)=1$，在 $[0,L)$ 的其他位置为 $0$，在网格中心进行采样。\n- 宽度测量：使用网格中心值的线性插值计算 $w_{10\\text{–}90}$，并取下降界面上 $\\theta_{\\text{hi}}$ 和 $\\theta_{\\text{lo}}$ 穿越点之间的最小下游距离；使用周期性展开来处理 $x=0$ 附近的界面。\n\n基于 $D_{\\text{num}}$ 的定性预期：对于固定的 $a$、$L$ 和 $T$，更精细的网格（更小的 $\\Delta x$）会减小 $D_{\\text{num}}$，从而减少模糊；更大的 $\\nu$（更接近 1）也会减小 $D_{\\text{num}}$，产生更窄的界面；在 $\\nu=1$ 时，主导扩散项消失，界面基本上被限制在网格尺度的厚度。程序精确地实现了该格式和测量方法，并对每个指定的测试用例 $(N,\\nu,T,a,L)$，输出模糊宽度 $w_{10\\text{–}90}(t_n)$，四舍五入到 8 位小数，并按要求将结果聚合为单行列表。",
            "answer": "```python\nimport numpy as np\n\ndef upwind_fvm_step(u, nu):\n    \"\"\"\n    First-order upwind finite volume update for a > 0:\n    u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n), with periodic indexing.\n    \"\"\"\n    return u - nu * (u - np.roll(u, 1))\n\ndef initialize_block(N, L, xL_frac=0.2, xR_frac=0.7):\n    \"\"\"\n    Initialize u(x,0) = 1 on [x_L, x_R) and 0 elsewhere on [0,L), sampled at cell centers.\n    x_L = xL_frac * L, x_R = xR_frac * L.\n    \"\"\"\n    dx = L / N\n    x = (np.arange(N) + 0.5) * dx\n    xL = xL_frac * L\n    xR = xR_frac * L\n    u0 = np.where((x >= xL)  (x  xR), 1.0, 0.0)\n    return x, u0\n\ndef interpolate_crossing_pos(x_i, x_ip1, u_i, u_ip1, theta, L):\n    \"\"\"\n    Linear interpolation between (x_i, u_i) and (x_ip1, u_ip1) to find x where u=theta.\n    The positions x_i and x_ip1 are assumed to be neighbors on a uniform periodic grid.\n    Returns position wrapped into [0, L).\n    \"\"\"\n    # Handle periodic wrap for positions if necessary (assume uniform spacing)\n    # For uniform grid, x_ip1 - x_i = dx and we do not need special position handling for periodicity;\n    # after computing the position, wrap into [0, L).\n    denom = (u_i - u_ip1)\n    if denom == 0.0:\n        return None\n    frac = (u_i - theta) / denom\n    # x along the straight line between centers\n    xi = x_i + (x_ip1 - x_i) * frac\n    # Wrap into [0, L)\n    xi_wrapped = xi % L\n    return xi_wrapped\n\ndef measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1):\n    \"\"\"\n    Measure the 10-90 smearing width on descending interfaces using linear interpolation\n    between neighboring cell centers. Returns the minimal width among all descending interfaces.\n    \"\"\"\n    N = len(u)\n    dx = L / N\n    # Build arrays of theta_hi and theta_lo crossing positions for descending fronts\n    hi_positions = []\n    lo_positions = []\n    for i in range(N):\n        ip1 = (i + 1) % N\n        u_i = u[i]\n        u_ip1 = u[ip1]\n        # Descending segment if u_i > u_ip1 (strict to avoid degenerate flat segments)\n        if u_i > u_ip1:\n            # theta_hi crossing: u_i >= theta_hi > u_ip1\n            if (u_i >= theta_hi) and (u_ip1  theta_hi):\n                xi = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_hi, L)\n                if xi is not None:\n                    hi_positions.append(xi)\n            # theta_lo crossing: u_i >= theta_lo > u_ip1\n            if (u_i >= theta_lo) and (u_ip1  theta_lo):\n                xl = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_lo, L)\n                if xl is not None:\n                    lo_positions.append(xl)\n\n    # Sort positions\n    hi_positions = np.sort(np.array(hi_positions, dtype=float)) if len(hi_positions) > 0 else np.array([], dtype=float)\n    lo_positions = np.sort(np.array(lo_positions, dtype=float)) if len(lo_positions) > 0 else np.array([], dtype=float)\n\n    if hi_positions.size == 0 or lo_positions.size == 0:\n        # No descending interfaces detected; width undefined. Return 0.0 as fallback.\n        return 0.0\n\n    # For each hi crossing, find the next downstream lo crossing (with periodicity)\n    widths = []\n    for h in hi_positions:\n        # Compute downstream distances to all lo positions with periodic wrap\n        dists = []\n        for l in lo_positions:\n            d = l - h\n            if d  0:\n                d += L\n            dists.append(d)\n        if len(dists) > 0:\n            widths.append(min(dists))\n    if len(widths) == 0:\n        return 0.0\n    return float(min(widths))\n\ndef simulate_and_measure(N, nu, T, a, L):\n    \"\"\"\n    Run the first-order upwind FVM for linear advection with given parameters and\n    measure the 10-90 smearing width at time ~ T.\n    \"\"\"\n    dx = L / N\n    dt = nu * dx / a\n    # Number of steps to approximate T with fixed dt\n    nsteps = int(np.round(T / dt)) if dt > 0 else 0\n    # Initialize\n    x, u = initialize_block(N, L, xL_frac=0.2, xR_frac=0.7)\n    # Time-stepping\n    for _ in range(nsteps):\n        u = upwind_fvm_step(u, nu)\n    # Measure width\n    width = measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1)\n    return width\n\ndef solve():\n    # Define the test cases: (N, nu, T, a, L)\n    test_cases = [\n        (200, 0.5, 0.2, 1.0, 1.0),  # Case 1\n        (200, 0.9, 0.2, 1.0, 1.0),  # Case 2\n        (200, 0.2, 0.2, 1.0, 1.0),  # Case 3\n        (50,  0.5, 0.2, 1.0, 1.0),  # Case 4\n        (200, 1.0, 0.2, 1.0, 1.0),  # Case 5\n    ]\n\n    results = []\n    for N, nu, T, a, L in test_cases:\n        width = simulate_and_measure(N, nu, T, a, L)\n        # Round to 8 decimal places as required\n        results.append(width)\n\n    # Final print statement in the exact required format with rounding\n    print(\"[\" + \",\".join(f\"{w:.8f}\" for w in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "上一个练习揭示了一阶格式会引入显著的数值耗散。一个自然的想法是采用更高阶的方法来提高精度。本练习要求你将一阶格式与一个无限制器的二阶线性重构格式进行比较，从而揭示一个关键的权衡：虽然二阶格式对光滑解更精确，但它会在不连续处引入伪振荡，有时甚至导致更差的整体结果。",
            "id": "2394314",
            "problem": "你需要比较线性平流方程的两种守恒型有限体积离散格式，并量化在何种情况下，由于在间断附近的伪振荡，二阶线性重构的性能会比一阶方法差。\n\n考虑线性平流方程\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\n$$\n该方程定义在周期性域 $[0,1)$ 上，具有恒定的平流速度 $a>0$。给定一个划分为 $N$ 个单元的均匀剖分，其交界面为 $x_{i\\pm \\frac{1}{2}}$，且 $x_{i+\\frac{1}{2}}-x_{i-\\frac{1}{2}}=\\Delta x$，单元中心为 $x_i = \\frac{1}{2}\\left(x_{i-\\frac{1}{2}}+x_{i+\\frac{1}{2}}\\right)$。设单元平均值为\n$$\nu_i^n \\equiv \\frac{1}{\\Delta x}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t^n)\\,dx.\n$$\n守恒更新格式为\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right),\n$$\n其中，对于 $a>0$，迎风数值通量为 $F_{i+\\frac{1}{2}}^n = a\\,u_{i+\\frac{1}{2}}^{-,n}$，$u_{i+\\frac{1}{2}}^{-,n}$ 是根据单元 $i$ 的数据在 $x_{i+\\frac{1}{2}}$ 处重构的左侧迹。假设索引是周期性的，因此 $u_{i+N}^n = u_i^n$ 且 $u_{i-N}^n = u_i^n$。\n\n你必须实现并比较：\n- 一阶重构（分片常数），定义为 $u_{i+\\frac{1}{2}}^{-,n} = u_i^n$。\n- 不带任何限制器的二阶线性重构，其斜率定义为 $s_i^n = \\frac{1}{2}\\left(u_{i+1}^n - u_{i-1}^n\\right)$，且 $u_{i+\\frac{1}{2}}^{-,n} = u_i^n + \\frac{1}{2}s_i^n$。\n\n使用固定的 Courant-Friedrichs-Lewy (CFL) 数 $\\nu \\in (0,1)$ 通过以下公式设置时间步长：\n$$\n\\Delta t = \\nu \\frac{\\Delta x}{a}.\n$$\n如果最终时间 $T$ 不是 $\\Delta t$ 的精确倍数，则最后一步采用一个缩小的 $\\Delta t$，以使总积分时间恰好等于 $T$。\n\n对于下面的每个测试用例，用每种方法计算在时间 $T$ 时的数值解，然后计算在时间 $T$ 时的单元平均精确解，其由下式给出：\n$$\nu(x,T) = u_0\\big((x - a T) \\bmod 1\\big),\n$$\n及其单元平均值：\n$$\n\\bar{u}_i^{\\text{exact}}(T) = \\frac{1}{\\Delta x}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(y,T)\\,dy.\n$$\n使用单元平均值的离散 $L^1$ 范数来量化误差：\n$$\nE_1 = \\Delta x \\sum_{i=0}^{N-1} \\left| u_i(T) - \\bar{u}_i^{\\text{exact}}(T) \\right|.\n$$\n\n所有情况均使用 $a = 1$ 和 $\\nu = 0.9$。所有情况的域均为 $[0,1)$，带有周期性边界条件。测试套件的初始条件 $u_0(x)$、单元数 $N$ 和最终时间 $T$ 如下：\n\n- 测试用例 1（不连续方帽，非对齐）：$N=200$，$T=0.25$，以及\n  $$\n  u_0(x) = \\begin{cases}\n  1,  x \\in [0.2, 0.4),\\\\\n  0,  \\text{其他情况,}\n  \\end{cases}\n  $$\n  在 $[0,1)$ 上周期性解释。\n\n- 测试用例 2（光滑波）：$N=80$，$T=0.5$，以及\n  $$\n  u_0(x) = \\sin(2\\pi x).\n  $$\n\n- 测试用例 3（与网格间距相关的窄方帽）：$N=80$，$T=0.3$，以及\n  $$\n  u_0(x) = \\begin{cases}\n  1,  x \\in [x_0, x_0 + 3\\Delta x),\\\\\n  0,  \\text{其他情况,}\n  \\end{cases}\n  $$\n  其中 $x_0 = 0.33$ 且 $\\Delta x = 1/N$；将 $[x_0, x_0+3\\Delta x)$ 按模 1 解释。\n\n对于每个测试用例，计算一阶方法的 $E_1^{(1)}$ 和不带任何限制器的二阶线性重构的 $E_1^{(2)}$。对于每个测试用例，如果 $E_1^{(2)} > E_1^{(1)}$ 则返回整数 $1$，否则返回整数 $0$。\n\n你的程序应生成单行输出，其中包含按顺序排列的三个测试用例的整数，格式为逗号分隔的列表，并用方括号括起来（例如，$[1,0,1]$）。不应产生额外的输出。",
            "solution": "该问题要求对一维线性平流方程 $\\partial_t u + a\\,\\partial_x u = 0$ 的两种有限体积法离散格式进行比较分析。比较的基础是，对于光滑初始剖面和不连续初始剖面，计算数值解与精确解之间的离散 $L^1$ 误差范数。该分析旨在说明守恒律数值方法中的一个基本权衡：高阶格式在光滑解上的准确性，与其在没有斜率限制器时在间断附近产生伪振荡的倾向。\n\n首先，我们建立离散框架。空间域 $[0,1)$ 被划分为 $N$ 个均匀单元，每个单元宽度为 $\\Delta x = 1/N$。单元 $i$ 覆盖区间 $[x_{i-1/2}, x_{i+1/2}]$，其中 $x_{i+1/2} = (i+1)\\Delta x$ (对于 $i=-1, \\dots, N-1$)。单元中心为 $x_i = (i+1/2)\\Delta x$。函数 $f(x)$ 在单元 $i$ 上的单元平均值记为 $f_i = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} f(x) \\, dx$。\n\n有限体积法通过以下守恒公式将时间 $t^n$ 的单元平均值 $u_i^n$ 演化到 $t^{n+1}=t^n+\\Delta t$：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2}^n - F_{i-1/2}^n \\right)\n$$\n这里，$F_{i+1/2}^n$ 是在交界面 $x_{i+1/2}$ 处的数值通量。对于速度为 $a>0$ 的线性平流方程，通量是纯迎风的，这意味着它仅依赖于交界面左侧的状态。这给出 $F_{i+1/2}^n = a \\cdot u_{i+1/2}^{-,n}$，其中 $u_{i+1/2}^{-,n}$ 是根据单元 $i$ 中的数据在交界面 $x_{i+1/2}$ 左侧重构的解值。时间步长 $\\Delta t$ 由固定的 CFL 数 $\\nu = a \\Delta t / \\Delta x$ 决定，因此 $\\Delta t = \\nu \\Delta x / a$。问题指定 $a=1$ 和 $\\nu=0.9$。更新方程简化为：\n$$\nu_i^{n+1} = u_i^n - \\nu \\left( u_{i+1/2}^{-,n} - u_{i-1/2}^{-,n} \\right)\n$$\n施加周期性边界条件，因此索引按模 $N$ 处理。\n\n我们研究两种用于 $u_{i+1/2}^{-,n}$ 的重构方法：\n\n1.  **一阶迎风法**：该方法在每个单元内使用分片常数重构，$u(x) = u_i^n$ 对于 $x \\in [x_{i-1/2}, x_{i+1/2}]$。交界面 $x_{i+1/2}$ 左侧的值就是单元 $i$ 的单元平均值：\n    $$\n    u_{i+1/2}^{-,n} = u_i^n\n    $$\n    将此代入更新公式，得到经典的一阶迎风格式：\n    $$\n    u_i^{n+1} = u_i^n - \\nu \\left( u_i^n - u_{i-1}^n \\right)\n    $$\n    已知该格式在 $\\nu \\in [0,1]$ 时是总变差递减（TVD）的，这可以防止新振荡的产生。然而，其精度只有一阶，导致显著的数值耗散，会使尖锐特征变得模糊。\n\n2.  **二阶线性重构（无限制器）**：该方法在每个单元内使用分片线性重构，$u(x) = u_i^n + s_i^n(x - x_i)$。问题中根据给定的斜率公式定义了交界面上的重构，我们将其解释为无量纲斜率。重构值为 $u_{i+1/2}^{-,n} = u_i^n + \\frac{1}{2}s_i^n$，其中 $s_i^n = \\frac{1}{2}(u_{i+1}^n - u_{i-1}^n)$。将它们结合起来得到：\n    $$\n    u_{i+1/2}^{-,n} = u_i^n + \\frac{1}{4}\\left( u_{i+1}^n - u_{i-1}^n \\right)\n    $$\n    对于光滑解，该重构在空间上以二阶精度逼近点值 $u(x_{i+1/2})$。更新公式变为：\n    $$\n    u_i^{n+1} = u_i^n - \\nu \\left[ \\left( u_i^n + \\frac{1}{4}(u_{i+1}^n - u_{i-1}^n) \\right) - \\left( u_{i-1}^n + \\frac{1}{4}(u_i^n - u_{i-2}^n) \\right) \\right]\n    $$\n    $$\n    u_i^{n+1} = u_i^n - \\nu \\left( \\frac{3}{4}u_i^n - \\frac{5}{4}u_{i-1}^n + \\frac{1}{4}u_{i+1}^n + \\frac{1}{4}u_{i-2}^n \\right)\n    $$\n    这是一个涉及单元 $i-2, i-1, i, i+1$ 的四点模板的线性格式。虽然它在光滑解上达到二阶精度，但它不是 TVD 的，并且已知是色散的，会在间断附近产生伪振荡（吉布斯现象）。本练习的目的是量化这些振荡何时会导致比耗散性的一阶格式更大的误差。\n\n为了进行分析，我们首先通过在每个单元上积分初始条件 $u_0(x)$ 来计算初始单元平均值 $u_i^0$。\n- 对于方帽函数 $u_0(x) = 1$（在区间 $[b_1, b_2)$ 上）和 $0$（其他情况），单元平均值为 $u_i^0 = \\frac{1}{\\Delta x} \\text{length}([x_{i-1/2}, x_{i+1/2}] \\cap [b_1, b_2))$。\n- 对于光滑函数 $u_0(x) = \\sin(2\\pi x)$，积分可以解析计算：\n  $$\n  u_i^0 = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} \\sin(2\\pi x) dx = \\frac{\\cos(2\\pi i\\Delta x) - \\cos(2\\pi(i+1)\\Delta x)}{2\\pi\\Delta x} = \\frac{\\sin(\\pi\\Delta x)}{\\pi\\Delta x}\\sin(2\\pi x_i)\n  $$\n\n平流方程的精确解为 $u(x,T) = u_0((x-aT)\\pmod 1)$。最终时间 $T$ 的精确单元平均值是通过在每个单元上积分此精确解来计算的：\n$$\n\\bar{u}_i^{\\text{exact}}(T) = \\frac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} u_0((x-aT)\\pmod 1) \\,dx\n$$\n此计算类似于求初始单元平均值，但初始剖面平移了 $aT$。\n\n时间积分使用固定的时间步长 $\\Delta t = \\nu \\Delta x / a$ 进行 $N_{\\text{steps}} = \\lfloor T/\\Delta t \\rfloor$ 个完整步长。如果存在剩余时间 $\\Delta t_{\\text{final}} = T - N_{\\text{steps}}\\Delta t > 0$，则采取一个更小的时间步长，以精确达到时间 $T$。\n\n最后，使用离散 $L^1$ 范数对每种方法的误差进行量化：\n$$\nE_1 = \\Delta x \\sum_{i=0}^{N-1} \\left| u_i(T) - \\bar{u}_i^{\\text{exact}}(T) \\right|\n$$\n对于每个测试用例，我们计算一阶方法的误差 $E_1^{(1)}$ 和二阶方法的误差 $E_1^{(2)}$。然后我们判断是否 $E_1^{(2)} > E_1^{(1)}$。\n\n- **测试用例 1 (不连续方帽)**：初始条件是不连续的。二阶方法将在方帽的边缘产生显著的上冲和下冲。一阶方法将使边缘模糊。预计二阶格式产生的大且不衰减的振荡将导致比耗散但无振荡的一阶格式更大的 $L^1$ 误差。因此，我们预期 $E_1^{(2)} > E_1^{(1)}$。\n- **测试用例 2 (光滑波)**：初始条件是 $C^\\infty$ 的。对于此类解，二阶方法的优越精度将清晰可见。它将以比高度耗散的一阶方法小得多的误差来逼近正弦波。我们预期 $E_1^{(2)}  E_1^{(1)}$。\n- **测试用例 3 (窄方帽)**：这是另一个不连续的情况，由于特征的宽度仅为几个网格单元（$3\\Delta x$），因此更具挑战性。这突显了无限制线性重构的缺陷，因为用于计算斜率的模板跨越了特征的很大一部分。我们再次预期会出现大振荡，且 $E_1^{(2)} > E_1^{(1)}$。\n\n实现将通过创建一个可配置为任一方法的通用有限体积求解器来完成。该求解器将应用于每个测试用例，计算误差，并按要求进行比较。",
            "answer": "```python\nimport numpy as np\n\ndef get_box_averages(N, box_start, box_end):\n    \"\"\"\n    Computes cell averages for a function that is 1 on [box_start, box_end)\n    and 0 otherwise, on a periodic domain [0,1).\n    \"\"\"\n    dx = 1.0 / N\n    cell_starts = np.arange(N) * dx\n    cell_ends = (np.arange(N) + 1) * dx\n    u_avg = np.zeros(N)\n\n    # Handle multiple integer wrappings of the interval\n    num_wraps = np.floor(box_end) - np.floor(box_start)\n    s_mod = box_start % 1.0\n    e_mod = box_end % 1.0\n\n    if num_wraps == 0: # Interval does not cross an integer\n        s, e = s_mod, e_mod\n        if e = s: # e.g. [0.2, 0.1) or [0.2, 0.2)\n            return u_avg\n        overlap = np.maximum(0, np.minimum(cell_ends, e) - np.maximum(cell_starts, s))\n        u_avg += overlap\n    else: # Interval crosses at least one integer\n        # Part from start to 1.0\n        overlap1 = np.maximum(0, np.minimum(cell_ends, 1.0) - np.maximum(cell_starts, s_mod))\n        u_avg += overlap1\n        # Part from 0.0 to end\n        overlap2 = np.maximum(0, np.minimum(cell_ends, e_mod) - np.maximum(cell_starts, 0.0))\n        u_avg += overlap2\n        # Full wraps\n        if num_wraps > 1:\n            u_avg += (num_wraps - 1) * dx\n\n    return u_avg / dx\n\ndef run_fvm(u_initial, N, T, a, nu_fixed, method):\n    \"\"\"\n    Solves the linear advection equation using the finite volume method.\n    \"\"\"\n    u = u_initial.copy()\n    dx = 1.0 / N\n    \n    dt_fixed = nu_fixed * dx / a\n    if dt_fixed = 0:\n        return u\n        \n    num_steps = int(T / dt_fixed) if T > 0 else 0\n    t = 0.0\n\n    # Perform full time steps\n    for _ in range(num_steps):\n        nu = nu_fixed\n        if method == 'first':\n            # First-order upwind\n            u = u - nu * (u - np.roll(u, 1))\n        elif method == 'second':\n            # Second-order unlimited linear reconstruction\n            u_p1 = np.roll(u, -1)\n            u_m1 = np.roll(u, 1)\n            s = 0.5 * (u_p1 - u_m1)\n            u_interface = u + 0.5 * s\n            flux_diff = u_interface - np.roll(u_interface, 1)\n            u = u - nu * flux_diff\n        t += dt_fixed\n    \n    # Perform final, smaller time step if needed\n    dt_final = T - t\n    if dt_final > 1e-12:\n        nu_final = a * dt_final / dx\n        if method == 'first':\n            u = u - nu_final * (u - np.roll(u, 1))\n        elif method == 'second':\n            u_p1 = np.roll(u, -1)\n            u_m1 = np.roll(u, 1)\n            s = 0.5 * (u_p1 - u_m1)\n            u_interface = u + 0.5 * s\n            flux_diff = u_interface - np.roll(u_interface, 1)\n            u = u - nu_final * flux_diff\n            \n    return u\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # (N, T, initial_condition_type, params)\n        (200, 0.25, 'top-hat', {'start': 0.2, 'end': 0.4}),\n        (80, 0.5, 'sine-wave', {}),\n        (80, 0.3, 'narrow-top-hat', {'x0': 0.33}),\n    ]\n\n    a = 1.0\n    nu_fixed = 0.9\n    results = []\n\n    for N, T, u0_type, params in test_cases:\n        dx = 1.0 / N\n        x_centers = (np.arange(N) + 0.5) * dx\n\n        # --- Initial Conditions ---\n        if u0_type == 'top-hat':\n            start, end = params['start'], params['end']\n            u_initial = get_box_averages(N, start, end)\n        elif u0_type == 'sine-wave':\n            # Use analytical formula for cell-averaged sine\n            factor = np.sinc(dx) # np.sinc(x) = sin(pi*x)/(pi*x)\n            u_initial = factor * np.sin(2 * np.pi * x_centers)\n        elif u0_type == 'narrow-top-hat':\n            x0 = params['x0']\n            start = x0\n            end = x0 + 3 * dx\n            u_initial = get_box_averages(N, start, end)\n\n        # --- Run Simulations ---\n        u_final_1st = run_fvm(u_initial, N, T, a, nu_fixed, 'first')\n        u_final_2nd = run_fvm(u_initial, N, T, a, nu_fixed, 'second')\n        \n        # --- Exact Solution ---\n        shift = (a * T) % 1.0\n        if u0_type == 'top-hat':\n            start, end = params['start'], params['end']\n            u_exact = get_box_averages(N, start + shift, end + shift)\n        elif u0_type == 'sine-wave':\n            # u(x,T) = sin(2*pi*(x-aT))\n            # For T=0.5, a=1, this is sin(2*pi*x - pi) = -sin(2*pi*x)\n            factor = np.sinc(dx)\n            u_exact = factor * np.sin(2 * np.pi * (x_centers - shift))\n        elif u0_type == 'narrow-top-hat':\n            x0 = params['x0']\n            start = x0\n            end = x0 + 3 * dx\n            u_exact = get_box_averages(N, start + shift, end + shift)\n\n        # --- Compute Errors and Compare ---\n        e1_1st = dx * np.sum(np.abs(u_final_1st - u_exact))\n        e1_2nd = dx * np.sum(np.abs(u_final_2nd - u_exact))\n        \n        results.append(1 if e1_2nd > e1_1st else 0)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}