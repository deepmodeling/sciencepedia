{
    "hands_on_practices": [
        {
            "introduction": "The radial distribution function is not merely a geometric descriptor; it is fundamentally linked to a system's thermodynamic properties. This exercise explores one of the most important connections in liquid-state theory: the relationship between pressure and structure. By working through the case of a hard-sphere fluid, you will derive how the macroscopic compressibility factor $Z$ is directly determined by the value of the RDF at the point of particle contact, $g(\\sigma^{+})$ . This practice solidifies the link between microscopic correlations and macroscopic equations of state, demonstrating the power of statistical mechanics to predict physical properties from first principles.",
            "id": "4081099",
            "problem": "Consider a three-dimensional (3D) monodisperse hard-sphere fluid of number density $\\rho$ and hard-core diameter $\\sigma$. The packing fraction is defined as $\\eta = \\frac{\\pi}{6}\\,\\rho\\,\\sigma^{3}$. The radial distribution function (RDF), denoted $g(r)$, is the probability density of finding a particle at distance $r$ from a reference particle relative to an ideal gas at the same density. The hard-sphere pair potential is $u(r)=\\infty$ for $r\\sigma$ and $u(r)=0$ for $r\\ge\\sigma$. The compressibility factor $Z$ is defined as $Z=\\frac{\\beta p}{\\rho}$ where $p$ is the pressure and $\\beta=1/(k_{B}T)$ with $k_{B}$ the Boltzmann constant and $T$ the absolute temperature.\n\nStarting from the virial expression for the pressure of a spherically symmetric pairwise-additive fluid and the properties of the hard-sphere potential, derive a relation connecting the compressibility factor $Z$ and the contact value $g(\\sigma^{+})$ of the radial distribution function, where $\\sigma^{+}$ denotes the limit $r\\to\\sigma$ from above. Then, using the Carnahan–Starling (CS) equation of state, given by\n$$\nZ_{\\mathrm{CS}}(\\eta)=\\frac{1+\\eta+\\eta^{2}-\\eta^{3}}{(1-\\eta)^{3}},\n$$\nobtain a closed-form analytic expression for $g(\\sigma^{+})$ as a function of $\\eta$. Finally, evaluate $g(\\sigma^{+})$ at packing fraction $\\eta=0.37$. Round your numerical answer to four significant figures. State the final answer as a dimensionless number (no units).",
            "solution": "The problem requires us to first derive a relationship between the compressibility factor $Z$ and the contact value of the radial distribution function $g(\\sigma^{+})$ for a hard-sphere fluid. Then, using the provided Carnahan–Starling equation of state, we must find an explicit expression for $g(\\sigma^{+})$ in terms of the packing fraction $\\eta$, and finally calculate its value for $\\eta=0.37$.\n\nThe derivation begins with the virial equation for the pressure $p$ of a fluid with a spherically symmetric, pairwise-additive potential $u(r)$:\n$$\nZ = \\frac{\\beta p}{\\rho} = 1 - \\frac{\\rho}{6k_{B}T} \\int_{0}^{\\infty} r \\frac{du(r)}{dr} g(r) 4\\pi r^2 dr\n$$\nwhere $\\rho$ is the number density, $\\beta = 1/(k_{B}T)$, $k_{B}$ is the Boltzmann constant, $T$ is the temperature, and $g(r)$ is the radial distribution function. This can be rewritten as:\n$$\nZ = 1 - \\frac{2\\pi\\rho}{3k_{B}T} \\int_{0}^{\\infty} r^3 g(r) \\frac{du(r)}{dr} dr\n$$\nFor a hard-sphere fluid, the pair potential $u(r)$ is given by:\n$$\nu(r) = \\begin{cases} \\infty  \\text{for } r  \\sigma \\\\ 0  \\text{for } r \\ge \\sigma \\end{cases}\n$$\nwhere $\\sigma$ is the hard-sphere diameter. The radial distribution function $g(r)$ must be zero for $r  \\sigma$ due to the infinite potential energy cost of particle overlap. The relationship between $g(r)$ and $u(r)$ is mediated by the cavity function, $y(r)$, which is a continuous function. The relation is $g(r) = y(r)\\exp(-\\beta u(r))$.\nFor $r  \\sigma$, $u(r) = \\infty$, so $\\exp(-\\beta u(r)) = 0$, which ensures $g(r) = 0$.\nFor $r \\ge \\sigma$, $u(r) = 0$, so $\\exp(-\\beta u(r)) = 1$, and thus $g(r) = y(r)$.\nSince $y(r)$ is continuous, the contact value of the RDF, $g(\\sigma^{+})$, is equal to $y(\\sigma)$.\n\nThe derivative $\\frac{du(r)}{dr}$ is non-zero only at the discontinuity $r=\\sigma$, behaving like a Dirac delta function. To handle this singularity rigorously, we can use the identity:\n$$\n\\frac{du(r)}{dr} \\exp(-\\beta u(r)) = -k_{B}T \\frac{d}{dr}\\left[\\exp(-\\beta u(r))\\right]\n$$\nSubstituting $g(r) = y(r)\\exp(-\\beta u(r))$ into the virial equation:\n$$\nZ = 1 - \\frac{2\\pi\\rho}{3k_{B}T} \\int_{0}^{\\infty} r^3 y(r) \\exp(-\\beta u(r)) \\frac{du(r)}{dr} dr\n$$\nUsing the identity above, this becomes:\n$$\nZ = 1 - \\frac{2\\pi\\rho}{3k_{B}T} \\int_{0}^{\\infty} r^3 y(r) \\left(-k_{B}T \\frac{d}{dr}\\left[\\exp(-\\beta u(r))\\right]\\right) dr\n$$\n$$\nZ = 1 + \\frac{2\\pi\\rho}{3} \\int_{0}^{\\infty} r^3 y(r) \\frac{d}{dr}\\left[\\exp(-\\beta u(r))\\right] dr\n$$\nThe function $\\exp(-\\beta u(r))$ for hard spheres is the Heaviside step function $H(r-\\sigma)$. Its derivative is the Dirac delta function, $\\delta(r-\\sigma)$.\n$$\n\\frac{d}{dr}\\left[\\exp(-\\beta u(r))\\right] = \\frac{d}{dr}H(r-\\sigma) = \\delta(r-\\sigma)\n$$\nSubstituting this into the expression for $Z$:\n$$\nZ = 1 + \\frac{2\\pi\\rho}{3} \\int_{0}^{\\infty} r^3 y(r) \\delta(r-\\sigma) dr\n$$\nUsing the sifting property of the Dirac delta function, the integral evaluates to:\n$$\n\\int_{0}^{\\infty} r^3 y(r) \\delta(r-\\sigma) dr = \\sigma^3 y(\\sigma)\n$$\nAs established earlier, $y(\\sigma) = g(\\sigma^{+})$. Therefore:\n$$\nZ = 1 + \\frac{2\\pi\\rho}{3} \\sigma^3 g(\\sigma^{+})\n$$\nThe packing fraction $\\eta$ is defined as $\\eta = \\frac{\\pi}{6}\\rho\\sigma^3$. We can express $\\rho\\sigma^3$ in terms of $\\eta$: $\\rho\\sigma^3 = \\frac{6\\eta}{\\pi}$. Substituting this into the equation for $Z$:\n$$\nZ = 1 + \\frac{2\\pi}{3} \\left(\\frac{6\\eta}{\\pi}\\right) g(\\sigma^{+}) = 1 + 4\\eta g(\\sigma^{+})\n$$\nThis is the desired relation connecting the compressibility factor and the contact value of the RDF for a hard-sphere fluid.\n\nNext, we use the Carnahan–Starling (CS) equation of state:\n$$\nZ_{\\mathrm{CS}}(\\eta) = \\frac{1+\\eta+\\eta^{2}-\\eta^{3}}{(1-\\eta)^{3}}\n$$\nBy equating the two expressions for $Z$, we can solve for $g(\\sigma^{+})$:\n$$\n1 + 4\\eta g(\\sigma^{+}) = \\frac{1+\\eta+\\eta^{2}-\\eta^{3}}{(1-\\eta)^{3}}\n$$\n$$\n4\\eta g(\\sigma^{+}) = \\frac{1+\\eta+\\eta^{2}-\\eta^{3}}{(1-\\eta)^{3}} - 1\n$$\nTo combine the terms on the right-hand side, we find a common denominator:\n$$\n4\\eta g(\\sigma^{+}) = \\frac{1+\\eta+\\eta^{2}-\\eta^{3} - (1-\\eta)^3}{(1-\\eta)^{3}}\n$$\nWe expand the term $(1-\\eta)^3 = 1 - 3\\eta + 3\\eta^2 - \\eta^3$. Substituting this into the numerator:\n$$\n\\text{Numerator} = (1+\\eta+\\eta^{2}-\\eta^{3}) - (1 - 3\\eta + 3\\eta^2 - \\eta^3) = 1+\\eta+\\eta^{2}-\\eta^{3} - 1 + 3\\eta - 3\\eta^2 + \\eta^3 = 4\\eta - 2\\eta^2\n$$\nSo the equation becomes:\n$$\n4\\eta g(\\sigma^{+}) = \\frac{4\\eta - 2\\eta^2}{(1-\\eta)^3}\n$$\nFor a fluid with non-zero density ($\\eta \\neq 0$), we can divide by $4\\eta$:\n$$\ng(\\sigma^{+}) = \\frac{4\\eta - 2\\eta^2}{4\\eta(1-\\eta)^3} = \\frac{2\\eta(2-\\eta)}{4\\eta(1-\\eta)^3} = \\frac{2-\\eta}{2(1-\\eta)^3}\n$$\nThis can be written as:\n$$\ng(\\sigma^{+}) = \\frac{1-\\frac{\\eta}{2}}{(1-\\eta)^3}\n$$\nThis is the closed-form analytic expression for $g(\\sigma^{+})$ as a function of $\\eta$.\n\nFinally, we evaluate this expression for the given packing fraction $\\eta=0.37$:\n$$\ng(\\sigma^{+}) = \\frac{1-\\frac{0.37}{2}}{(1-0.37)^3} = \\frac{1-0.185}{(0.63)^3} = \\frac{0.815}{0.250047}\n$$\n$$\ng(\\sigma^{+}) \\approx 3.25936412\n$$\nRounding this result to four significant figures gives $3.259$.",
            "answer": "$$ \\boxed{3.259} $$"
        },
        {
            "introduction": "While theoretical derivations provide a clean picture of the RDF, calculating it from finite simulation data involves important practical choices that affect the result's quality and interpretation. This coding exercise moves from theory to implementation, focusing on the nuanced art of binning and data smoothing . You will implement data-driven methods like the Freedman-Diaconis and Scott's rules for selecting an optimal bin width, striking a balance between resolving structural features and managing statistical noise. This practice is essential for developing a robust computational toolkit and a critical eye for analyzing simulation data.",
            "id": "4081106",
            "problem": "You are asked to design and implement a program that computes the radial distribution function (RDF) for a three-dimensional complex fluid sampled by point particles under periodic boundary conditions. The focus is on principled bin width selection, resolution control, and Gaussian smoothing. The RDF is a static property defined from the pair statistics of the configuration. Your program must follow a principled construction starting from core definitions and well-tested statistical rules, and it must produce a single, testable line of output that aggregates results across a fixed test suite.\n\nBegin from the following foundations. Consider a cubic periodic box of edge length $L$ containing $N$ point particles at number density $\\rho = N / V$, where $V = L^3$. Define the radial distribution function $g(r)$ for a statistically homogeneous and isotropic system as the ratio of the local pair density at separation $r$ to the ideal-gas reference density. In practice, $g(r)$ is constructed by accumulating pair separations into spherical shells of radius $r$ and thickness $\\Delta r$ and then normalizing by the shell volume and the number of available pairs. Use the minimum-image convention for distances in a periodic box, and restrict the analysis to separations $r$ strictly less than $r_{\\max} = L/2$.\n\nYou must construct $g(r)$ from unordered pairs (each pair counted exactly once) and normalize it so that for a spatially uniform ideal gas, the expected value is $g(r) = 1$ for $0  r  r_{\\max}$, up to finite-sample fluctuations. After constructing the unsmoothed $g(r)$ on a uniform binning, optionally apply Gaussian kernel smoothing with a specified standard deviation measured in the same physical length unit as $r$.\n\nYour program must implement scientifically grounded bin width selection without shortcut formulas in the problem statement. Specifically:\n- One case requires selecting $\\Delta r$ according to the Freedman–Diaconis rule, using the empirical distribution of pairwise separations strictly less than $r_{\\max}$.\n- One case requires selecting $\\Delta r$ according to Scott’s rule, using the empirical standard deviation of the pairwise separations strictly less than $r_{\\max}$.\n- One case uses a fixed target $\\Delta r$ provided in physical units; convert this to an integer number of bins $M$ on $[0, r_{\\max}]$ by $M = \\lfloor r_{\\max} / \\Delta r_{\\mathrm{target}} \\rfloor$, and then use a uniform bin width $\\Delta r = r_{\\max} / M$ so that the bins exactly partition the interval.\n\nSmoothing is performed by convolving $g(r)$ with a Gaussian whose standard deviation is given as a multiplicative factor times the effective $\\Delta r$ selected by the binning method. Let $\\sigma_{\\mathrm{smooth}} = \\alpha \\Delta r$, where $\\alpha$ is the provided smoothing factor; if $\\alpha = 0$, no smoothing is applied. Because the implementation is discrete, the Gaussian smoothing must be implemented with the standard deviation measured in bin units, i.e., $\\sigma_{\\mathrm{bins}} = \\sigma_{\\mathrm{smooth}} / \\Delta r = \\alpha$.\n\nDefine the following quantitative diagnostics to assess resolution and smoothing:\n- The number of bins $M$ on $[0, r_{\\max}]$, which serves as a resolution measure.\n- The mean absolute deviation of the smoothed RDF from the ideal-gas value $1$, defined by\n$$ D = \\frac{1}{M} \\sum_{i=1}^{M} \\left| g(r_i) - 1 \\right|, $$\nwhere $r_i$ is the center of bin $i$ and $g(r_i)$ is the smoothed RDF value at that center.\n- The coordination number error up to a cutoff $r_c$, defined by\n$$ E = n(r_c) - \\rho \\frac{4\\pi}{3} r_c^3, \\quad \\text{where} \\quad n(r_c) = 4\\pi \\rho \\int_{0}^{r_c} g(r)\\, r^2 \\, dr, $$\nand the integral is evaluated by the midpoint Riemann sum over the uniform bins: $n(r_c) \\approx 4\\pi \\rho \\sum_{i: r_i \\le r_c} g(r_i)\\, r_i^2 \\, \\Delta r.$\n\nImplementation details to enforce scientific realism:\n- Generate synthetic configurations by placing $N$ particles uniformly and independently in the cube $[0, L)^3$ using a specified random seed. Use the minimum-image convention to compute unordered pairwise distances $r$ by wrapping displacement components to the interval $[-L/2, L/2]$ and then taking the Euclidean norm.\n- Accumulate only distances strictly less than $r_{\\max} = L/2$.\n- Construct $g(r)$ from the histogram counts $n_i$ over bins $[0, r_{\\max}]$ with centers $r_i$ and uniform width $\\Delta r$ via a normalization consistent with unordered pairs that yields $g(r) = 1$ in expectation for a uniform ideal gas. Use spherical shell volume $V_{\\mathrm{shell},i} = 4\\pi r_i^2 \\Delta r$ for bin $i$.\n\nUnits and output formatting:\n- All lengths must be handled in nanometers (nm). Report the bin width $\\Delta r$ in $\\mathrm{nm}$.\n- The mean absolute deviation $D$ and the coordination number error $E$ are dimensionless.\n- Your program should produce a single line of output containing the results as a comma-separated list of three sublists, each sublist corresponding to a test case and containing $[\\Delta r, M, D, E]$ in that order. For example, a valid output format is \"[[dr1,M1,D1,E1],[dr2,M2,D2,E2],[dr3,M3,D3,E3]]\" with numeric values substituted. The line must contain only this single list, with no additional text.\n\nTest suite specification (all lengths in $\\mathrm{nm}$):\n- Case A (happy path): $N = 64$, $L = 10$, random seed $42$, binning method \"Freedman–Diaconis\", smoothing factor $\\alpha = 1.0$, cutoff $r_c = L/4$.\n- Case B (fine resolution, no smoothing): $N = 16$, $L = 10$, random seed $777$, fixed target bin width $\\Delta r_{\\mathrm{target}} = 0.05$, smoothing factor $\\alpha = 0.0$, cutoff $r_c = L/4$.\n- Case C (alternative rule with heavier smoothing): $N = 64$, $L = 10$, random seed $2024$, binning method \"Scott\", smoothing factor $\\alpha = 2.0$, cutoff $r_c = L/3$.\n\nYour program must implement the above pipeline for each case, adhere to the specified units, and print a single line in the exact format described that aggregates the results from the three cases in the order A, B, C.",
            "solution": "The problem requires the design and implementation of a program to compute the radial distribution function, $g(r)$, for a three-dimensional system of $N$ point particles within a cubic box of side length $L$ under periodic boundary conditions. The calculation must adhere to specific methodologies for binning, smoothing, and evaluation. The analysis proceeds from first principles.\n\nFirst, we define the system and the fundamental quantities. The system consists of $N$ particles in a volume $V = L^3$, corresponding to a number density $\\rho = N/V$. The radial distribution function $g(r)$ quantifies the probability of finding a pair of particles at a separation $r$, relative to the probability for an ideal gas at the same density. For a statistically homogeneous and isotropic system, $g(r)$ is defined such that $\\rho g(r)$ is the local number density at a distance $r$ from an arbitrary central particle.\n\nThe calculation of pairwise separations $r_{ij} = |\\vec{r}_j - \\vec{r}_i|$ must account for the periodic boundary conditions. This is accomplished using the minimum-image convention. For a displacement vector $\\Delta\\vec{r} = (\\Delta x, \\Delta y, \\Delta z)$, each component is wrapped to the interval $[-L/2, L/2]$. For example, the x-component of the minimum-image displacement is $\\Delta x' = \\Delta x - L \\cdot \\text{round}(\\Delta x / L)$. The squared distance is then $r_{ij}^2 = (\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2$. The analysis is restricted to separations $r  r_{\\max} = L/2$ to avoid ambiguities and self-interactions across the periodic boundary.\n\nThe core of the task is to construct a discrete approximation of $g(r)$ by binning the pairwise distances. The interval $[0, r_{\\max})$ is partitioned into $M$ uniform bins of width $\\Delta r = r_{\\max} / M$. The center of the $i$-th bin (for $i=0, 1, \\dots, M-1$) is $r_i = (i+0.5)\\Delta r$. A histogram is constructed by counting the number of unordered particle pairs, $n_i$, whose separation falls within the $i$-th bin.\n\nThe normalization of $g(r_i)$ is critical and must be consistent with its definition, such that for a uniform ideal gas, the expectation value is $\\langle g(r_i) \\rangle = 1$. The total number of unique pairs in the system is $N(N-1)/2$. For an ideal gas (spatially uncorrelated particles), the expected number of pairs in the $i$-th spherical shell is the total number of pairs multiplied by the ratio of the shell volume to the total volume:\n$$\n\\langle n_i \\rangle_{\\text{ideal}} = \\frac{N(N-1)}{2} \\frac{V_{\\mathrm{shell},i}}{V}\n$$\nThe volume of the spherical shell corresponding to the $i$-th bin is approximated as $V_{\\mathrm{shell},i} \\approx 4\\pi r_i^2 \\Delta r$, which is accurate for small $\\Delta r$. The radial distribution function is then the ratio of the observed count $n_i$ to this ideal gas expectation:\n$$\ng(r_i) = \\frac{n_i}{\\langle n_i \\rangle_{\\text{ideal}}} = \\frac{n_i}{\\frac{N(N-1)}{2V} (4\\pi r_i^2 \\Delta r)} = \\frac{2 V n_i}{4\\pi N(N-1) r_i^2 \\Delta r}\n$$\nThis normalization correctly yields $g(r_i) = 1$ when the observed counts $n_i$ match the ideal gas expectation. For bins where $r_i$ is close to zero, this expression is numerically sensitive, but since the bin centers $r_i$ are always positive ($r_0 = \\Delta r / 2$), the denominator is well-defined.\n\nThe problem specifies three methods for determining the bin width $\\Delta r$:\n1.  **Freedman–Diaconis rule:** The bin width is derived from the interquartile range (IQR) of the distribution of all pairwise distances $d$ (where $d  r_{\\max}$) and the number of such distances, $n_{\\text{pairs}}$. The formula is $\\Delta r_{\\text{rule}} = 2 \\cdot \\text{IQR} \\cdot n_{\\text{pairs}}^{-1/3}$.\n2.  **Scott's rule:** This rule uses the standard deviation, $\\sigma_d$, of the same pairwise distance data: $\\Delta r_{\\text{rule}} = 3.5 \\cdot \\sigma_d \\cdot n_{\\text{pairs}}^{-1/3}$.\nFor both rules, the number of bins is then set to $M = \\lfloor r_{\\max} / \\Delta r_{\\text{rule}} \\rfloor$, and the final effective bin width is recalculated as $\\Delta r = r_{\\max} / M$ to ensure the bins perfectly tile the interval $[0, r_{\\max}]$.\n3.  **Fixed target bin width:** A target width $\\Delta r_{\\mathrm{target}}$ is given. The number of bins is $M = \\lfloor r_{\\max} / \\Delta r_{\\mathrm{target}} \\rfloor$, and the effective width is again $\\Delta r = r_{\\max} / M$.\n\nAfter computing the raw $g(r)$, Gaussian smoothing may be applied. This is a convolution of the discrete $g(r_i)$ array with a Gaussian kernel. The standard deviation of the kernel is given as $\\sigma_{\\mathrm{smooth}} = \\alpha \\Delta r$, where $\\alpha$ is a specified smoothing factor. For a discrete convolution, this is equivalent to a standard deviation of $\\sigma_{\\mathrm{bins}} = \\alpha$ in units of the bin index. No smoothing is applied if $\\alpha=0$.\n\nFinally, we compute three diagnostic quantities:\n1.  The number of bins, $M$.\n2.  The mean absolute deviation from the ideal-gas value of $1$: $D = \\frac{1}{M} \\sum_{i=0}^{M-1} | g(r_i) - 1 |$.\n3.  The coordination number error, $E$, up to a cutoff $r_c$. The coordination number $n(r_c)$ is the expected number of particles within a radius $r_c$ of a central particle. It is calculated by integrating $\\rho g(r)$:\n    $$\n    n(r_c) = 4\\pi \\rho \\int_{0}^{r_c} g(r) r^2 dr\n    $$\n    This integral is approximated using a midpoint Riemann sum over the bins:\n    $$\n    n(r_c) \\approx 4\\pi \\rho \\sum_{i: r_i \\le r_c} g(r_i) r_i^2 \\Delta r\n    $$\n    The error $E$ is the deviation of this computed value from the ideal-gas coordination number, which is simply the number of particles in a sphere of radius $r_c$:\n    $$\n    E = n(r_c) - \\rho \\frac{4\\pi}{3} r_c^3\n    $$\n\nThe overall algorithm for each test case is as follows:\n1.  Generate $N$ particle positions $\\vec{r}_k$ for $k=1, \\dots, N$ uniformly in the cube $[0, L)^3$ using the specified random seed.\n2.  Compute all unique unordered pairwise distances $r_{ij}$ for $ji$, applying the minimum-image convention, and retaining only those with $r_{ij}  r_{\\max}$.\n3.  Determine the number of bins $M$ and the effective bin width $\\Delta r$ based on the specified binning method.\n4.  Construct a histogram of the distances to obtain the counts $n_i$ for each bin.\n5.  Normalize the counts to obtain the raw $g(r_i)$.\n6.  Apply Gaussian smoothing if $\\alpha  0$ to get the final $g(r_i)$.\n7.  Compute the diagnostics $M$, $D$, and $E$.\n8.  Collect the results $[\\Delta r, M, D, E]$ for output.\nThis procedure provides a scientifically rigorous and numerically verifiable method for computing and analyzing the radial distribution function.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import gaussian_filter1d\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A: N=64, L=10, seed=42, Freedman-Diaconis, alpha=1.0, rc=L/4\n        {'N': 64, 'L': 10.0, 'seed': 42, 'binning_method': 'Freedman-Diaconis', \n         'bin_params': {}, 'smoothing_alpha': 1.0, 'rc': 10.0 / 4.0},\n        # Case B: N=16, L=10, seed=777, fixed target dr=0.05, alpha=0.0, rc=L/4\n        {'N': 16, 'L': 10.0, 'seed': 777, 'binning_method': 'fixed_target', \n         'bin_params': {'delta_r_target': 0.05}, 'smoothing_alpha': 0.0, 'rc': 10.0 / 4.0},\n        # Case C: N=64, L=10, seed=2024, Scott, alpha=2.0, rc=L/3\n        {'N': 64, 'L': 10.0, 'seed': 2024, 'binning_method': 'Scott', \n         'bin_params': {}, 'smoothing_alpha': 2.0, 'rc': 10.0 / 3.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_rdf_diagnostics(\n            N=case['N'],\n            L=case['L'],\n            seed=case['seed'],\n            binning_method=case['binning_method'],\n            bin_params=case['bin_params'],\n            smoothing_alpha=case['smoothing_alpha'],\n            rc=case['rc']\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required, removing all spaces.\n    print(str(results).replace(\" \", \"\"))\n\ndef compute_rdf_diagnostics(N, L, seed, binning_method, bin_params, smoothing_alpha, rc):\n    \"\"\"\n    Computes the RDF and its diagnostics for a single case.\n    \"\"\"\n    # 1. Generate particle positions\n    rng = np.random.default_rng(seed)\n    positions = rng.uniform(0, L, size=(N, 3))\n\n    # 2. Calculate pairwise distances with minimum image convention\n    r_max = L / 2.0\n    distances = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            delta = positions[j] - positions[i]\n            # Apply minimum image convention\n            delta = delta - L * np.round(delta / L)\n            dist = np.linalg.norm(delta)\n            if dist  r_max:\n                distances.append(dist)\n    distances = np.array(distances)\n    \n    n_pairs = len(distances)\n    if n_pairs == 0: # Handle edge case of no pairs in range\n      if binning_method == 'fixed_target':\n        M = int(np.floor(r_max / bin_params['delta_r_target']))\n      else:\n        M = 100 # Default if no data to estimate from\n      delta_r = r_max / M\n      return [delta_r, M, 1.0, - (N/L**3) * (4.0/3.0) * np.pi * rc**3]\n\n    # 3. Determine bin width (delta_r) and number of bins (M)\n    if binning_method == 'Freedman-Diaconis':\n        q1, q3 = np.percentile(distances, [25, 75])\n        iqr = q3 - q1\n        # Avoid division by zero if all distances are the same\n        if iqr == 0:\n            iqr = np.std(distances)\n        if iqr == 0: # still zero?\n            delta_r_rule = r_max / 100.0 # fallback\n        else:\n            delta_r_rule = 2.0 * iqr * (n_pairs ** (-1.0/3.0))\n        \n        M = int(np.floor(r_max / delta_r_rule)) if delta_r_rule > 0 else 100\n        if M == 0: M = 1\n        delta_r = r_max / M\n\n    elif binning_method == 'Scott':\n        std_dev = np.std(distances)\n        if std_dev == 0:\n            delta_r_rule = r_max / 100.0\n        else:\n            delta_r_rule = 3.5 * std_dev * (n_pairs ** (-1.0/3.0))\n        \n        M = int(np.floor(r_max / delta_r_rule)) if delta_r_rule > 0 else 100\n        if M == 0: M = 1\n        delta_r = r_max / M\n\n    elif binning_method == 'fixed_target':\n        delta_r_target = bin_params['delta_r_target']\n        M = int(np.floor(r_max / delta_r_target))\n        if M == 0: M = 1\n        delta_r = r_max / M\n        \n    else:\n        raise ValueError(f\"Unknown binning method: {binning_method}\")\n\n    # 4. Construct histogram and calculate g(r)\n    counts, bin_edges = np.histogram(distances, bins=M, range=(0, r_max))\n    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2.0\n\n    V = L**3\n    rho = N / V\n    # Normalization factor for each bin\n    # Ideal gas count = (Total pairs below rmax) * (Shell Volume / Total Volume below rmax)\n    # this simplifies to Total pairs * (Shell Volume / Total Box Volume)\n    # Total pairs = N*(N-1)/2\n    shell_volumes = 4.0 * np.pi * bin_centers**2 * delta_r\n    ideal_gas_counts = (N * (N - 1) / 2.0) * shell_volumes / V\n    \n    # Calculate g(r) with protection against division by zero\n    g_r = np.zeros_like(ideal_gas_counts)\n    nonzero_mask = ideal_gas_counts > 0\n    g_r[nonzero_mask] = counts[nonzero_mask] / ideal_gas_counts[nonzero_mask]\n    \n    # 5. Apply Gaussian smoothing\n    if smoothing_alpha > 0:\n        g_r_smoothed = gaussian_filter1d(g_r, sigma=smoothing_alpha, mode='nearest')\n    else:\n        g_r_smoothed = g_r\n\n    # 6. Compute diagnostics\n    # Mean absolute deviation D\n    D = np.mean(np.abs(g_r_smoothed - 1.0))\n    \n    # Coordination number error E\n    indices_to_sum = np.where(bin_centers = rc)[0]\n    integral_sum = np.sum(g_r_smoothed[indices_to_sum] * bin_centers[indices_to_sum]**2)\n    n_rc_computed = 4.0 * np.pi * rho * delta_r * integral_sum\n    n_rc_ideal = rho * (4.0/3.0) * np.pi * rc**3\n    E = n_rc_computed - n_rc_ideal\n    \n    return [delta_r, M, D, E]\n\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "Most complex fluids are mixtures, where the structural organization is best described not by a single RDF, but by a set of partial radial distribution functions, $g_{\\alpha\\beta}(r)$. This exercise extends the fundamental RDF calculation to multicomponent systems, a necessary step for studying solutions, alloys, and biomolecular systems. You will implement an algorithm to compute these partial RDFs, paying close attention to the distinct normalization required for pairs of same-species particles (homogeneous) versus different-species particles (heterogeneous) . This practice equips you with the skills to dissect the specific pairwise interactions that govern the structure of complex mixtures.",
            "id": "4081089",
            "problem": "Consider a three-dimensional, periodic, cubic simulation box of side length $L$ containing $N$ point particles at positions $\\{\\mathbf{r}_i\\}_{i=1}^N$, each labeled by a species index $s_i \\in \\{\\alpha_1,\\alpha_2,\\dots,\\alpha_K\\}$. The static structure at equilibrium is quantified by the radial distribution function (RDF), which for a multicomponent mixture is defined through the partial radial distribution functions $g_{\\alpha\\beta}(r)$, where $\\alpha$ and $\\beta$ denote species labels. The radial distribution function (RDF) is the ratio of the pair density at separation $r$ to its ideal (uncorrelated) reference at the same number densities. Your task is to derive a computational estimator for the total RDF $g(r)$ and all partial RDFs $g_{\\alpha\\beta}(r)$ from first principles, and implement it as a program that processes a prescribed test suite.\n\nUse the following fundamental bases and laws:\n- The system is in a three-dimensional homogeneous and isotropic state at equilibrium in a cubic box of volume $V = L^3$, with periodic boundary conditions applied via the minimum-image convention. The minimum-image displacement between particles $i$ and $j$ is $\\Delta\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i - L \\,\\mathrm{round}\\left((\\mathbf{r}_j - \\mathbf{r}_i)/L\\right)$.\n- The number density of species $\\alpha$ is $\\rho_\\alpha = N_\\alpha/V$, where $N_\\alpha$ is the count of particles of species $\\alpha$, and the total number density is $\\rho = N/V$.\n- The ideal-gas reference for pair counts in a spherical shell of inner radius $r$ and thickness $\\Delta r$ is proportional to the shell volume $V_{\\mathrm{shell}}(r;\\Delta r) = \\frac{4\\pi}{3}\\left((r+\\Delta r)^3 - r^3\\right)$ times the appropriate number density. For unordered pair counting (each distinct pair counted once), the expected counts in the ideal mixture are proportional to $N_\\alpha \\rho_\\beta V_{\\mathrm{shell}}(r;\\Delta r)$ for $\\alpha \\neq \\beta$, and to $\\frac{1}{2}N_\\alpha \\rho_\\alpha V_{\\mathrm{shell}}(r;\\Delta r)$ for $\\alpha = \\beta$. For the total over all pairs, the expected counts scale as $\\frac{1}{2} N \\rho V_{\\mathrm{shell}}(r;\\Delta r)$.\n\nStarting strictly from these bases, derive an algorithm to:\n1. Compute the Euclidean distance $d_{ij} = \\|\\Delta\\mathbf{r}_{ij}\\|$ for all unordered pairs $(i,j)$ with $ij$, subject to periodic boundary conditions, and bin these distances into spherical shells of uniform width $\\Delta r$ from $r=0$ up to a maximum radius $r_{\\max}$ such that $r_{\\max} \\le L/2$.\n2. For each bin $k$ with inner edge $r_k = k\\,\\Delta r$, compute the shell volume $V_{\\mathrm{shell}}(r_k;\\Delta r)$.\n3. Accumulate unordered pair counts per bin for:\n   - The total counts over all pairs.\n   - The partial counts per species pair $(\\alpha,\\beta)$, with pairs reported in lexicographic order of the provided species label list and with the convention that unordered pairs are associated to the sorted pair $(\\min(\\alpha,\\beta),\\max(\\alpha,\\beta))$.\n4. Normalize the binned counts to obtain dimensionless estimates of $g(r)$ and $g_{\\alpha\\beta}(r)$ by dividing by the corresponding ideal counts derived above.\n5. Report the bin centers $c_k = r_k + \\Delta r/2$, the total $g(r_k)$, and all partial $g_{\\alpha\\beta}(r_k)$ for each bin $k$.\n\nAll distances are to be computed and reported in the same length unit as the provided positions, and all radial distribution function values are dimensionless. Angles do not appear in this calculation. The final program must not rely on any external randomness or input; it must execute deterministically.\n\nImplement your solution for the following test suite. Each test case supplies $(L,\\ \\text{positions},\\ \\text{species labels in list order},\\ \\Delta r,\\ r_{\\max})$. The positions are given as lists of Cartesian coordinates, and the species labels are strings. Ensure $r_{\\max} \\le L/2$.\n\n- Test Case $1$ (binary mixture, general case):\n  - $L = 10.0$\n  - Positions: species $\\mathrm{A}$ at $[1.0,1.0,1.0]$, $[1.0,3.0,1.0]$, $[4.0,4.0,4.0]$; species $\\mathrm{B}$ at $[8.0,1.0,1.0]$, $[5.0,4.0,4.5]$, $[1.0,8.0,1.0]$\n  - Species label order: $[\\mathrm{A},\\mathrm{B}]$\n  - $\\Delta r = 0.5$, $r_{\\max} = 5.0$\n\n- Test Case $2$ (single-component, consistency boundary):\n  - $L = 12.0$\n  - Positions: species $\\mathrm{C}$ at $[1.0,1.0,1.0]$, $[11.0,1.0,1.0]$, $[6.0,6.0,6.0]$, $[1.0,11.0,11.0]$\n  - Species label order: $[\\mathrm{C}]$\n  - $\\Delta r = 1.0$, $r_{\\max} = 6.0$\n\n- Test Case $3$ (highly asymmetric binary mixture):\n  - $L = 10.0$\n  - Positions: species $\\mathrm{A}$ at $[2.0,2.0,2.0]$; species $\\mathrm{B}$ at $[2.5,2.0,2.0]$, $[7.0,7.0,7.0]$, $[7.5,7.0,7.0]$, $[7.0,7.5,7.0]$, $[7.0,7.0,7.5]$, $[9.0,9.0,9.0]$, $[9.5,9.0,9.0]$\n  - Species label order: $[\\mathrm{A},\\mathrm{B}]$\n  - $\\Delta r = 0.4$, $r_{\\max} = 4.0$\n\n- Test Case $4$ (periodic boundary edge case):\n  - $L = 8.0$\n  - Positions: species $\\mathrm{A}$ at $[0.5,0.5,0.5]$, $[4.0,4.0,4.0]$; species $\\mathrm{B}$ at $[7.5,7.5,7.5]$, $[4.0,0.5,7.5]$\n  - Species label order: $[\\mathrm{A},\\mathrm{B}]$\n  - $\\Delta r = 0.5$, $r_{\\max} = 4.0$\n\n- Test Case $5$ (three-component mixture):\n  - $L = 9.0$\n  - Positions: species $\\mathrm{A}$ at $[1.0,1.0,1.0]$, $[3.0,1.0,1.0]$; species $\\mathrm{B}$ at $[5.0,5.0,5.0]$, $[5.5,5.0,5.5]$; species $\\mathrm{C}$ at $[8.0,8.0,8.0]$\n  - Species label order: $[\\mathrm{A},\\mathrm{B},\\mathrm{C}]$\n  - $\\Delta r = 0.6$, $r_{\\max} = 4.0$\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The top-level list must contain one element per test case in the same order as listed above. Each test case’s element must itself be a list structured as:\n- The list of bin centers $[c_0,c_1,\\dots,c_{M-1}]$ where $M = \\lfloor r_{\\max}/\\Delta r \\rfloor$,\n- The list of total $g(r)$ values $[g(c_0),g(c_1),\\dots,g(c_{M-1})]$,\n- Followed by one list per unique species pair in the provided species label order, enumerated lexicographically with repetition, i.e., for $[\\mathrm{A},\\mathrm{B}]$ include $g_{\\mathrm{AA}}(r)$, $g_{\\mathrm{AB}}(r)$, $g_{\\mathrm{BB}}(r)$; for $[\\mathrm{A},\\mathrm{B},\\mathrm{C}]$ include $g_{\\mathrm{AA}}(r)$, $g_{\\mathrm{AB}}(r)$, $g_{\\mathrm{AC}}(r)$, $g_{\\mathrm{BB}}(r)$, $g_{\\mathrm{BC}}(r)$, $g_{\\mathrm{CC}}(r)$, and so on.\n\nYour implementation must strictly apply the minimum-image convention for periodic boundary conditions, use unordered pair counting, and normalize by the ideal-gas counts corresponding to the unordered-pair expectation. The final outputs must be real numbers (floats), and no additional text may be printed.",
            "solution": "The problem requires the derivation and implementation of a computational estimator for the total radial distribution function (RDF), $g(r)$, and all partial RDFs, $g_{\\alpha\\beta}(r)$, for a multi-component system of particles in a periodic cubic box. The derivation will be based strictly on the principles and definitions provided.\n\n**1. System and Discretization**\n\nThe system consists of $N$ particles in a cubic box of side length $L$ and volume $V=L^3$. The particles are located at positions $\\{\\mathbf{r}_i\\}_{i=1}^N$ and are categorized by species labels $\\{s_i\\}_{i=1}^N$. Let there be $K$ unique species, denoted by an ordered list of labels $(\\alpha_1, \\alpha_2, \\dots, \\alpha_K)$. The number of particles of species $\\alpha$ is $N_\\alpha$, with $\\sum_{\\alpha} N_\\alpha = N$. The number density of species $\\alpha$ is $\\rho_\\alpha = N_\\alpha/V$, and the total number density is $\\rho = N/V$.\n\nThe RDF, $g(r)$, is a continuous function of the radial distance $r$. To compute it from discrete particle positions, we discretize the radial distance into a series of bins. We define $M = \\lfloor r_{\\max}/\\Delta r \\rfloor$ bins, where $\\Delta r$ is the bin width and $r_{\\max}$ is the maximum radius of interest, satisfying $r_{\\max} \\le L/2$. The $k$-th bin (for $k=0, 1, \\dots, M-1$) corresponds to the radial interval $[r_k, r_{k+1})$, where $r_k = k\\,\\Delta r$. This bin represents a spherical shell.\n\nThe volume of this shell is given by:\n$$\nV_{\\mathrm{shell},k} = \\frac{4\\pi}{3}\\left(r_{k+1}^3 - r_k^3\\right) = \\frac{4\\pi}{3}\\left((k+1)^3\\Delta r^3 - k^3\\Delta r^3\\right) = \\frac{4\\pi\\Delta r^3}{3}\\left(3k^2 + 3k + 1\\right)\n$$\nThe RDF values will be reported at the center of each bin, $c_k = r_k + \\Delta r/2 = (k+0.5)\\Delta r$.\n\n**2. Pair Distance Calculation and Histogramming**\n\nThe core of the calculation involves determining the number of particle pairs separated by a distance falling within each radial bin. We consider all unordered pairs of particles $(i, j)$ with $i  j$ to avoid double counting.\n\nFor each pair, the displacement vector is $\\mathbf{d}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$. To account for the periodic boundary conditions (PBC), we use the minimum image convention (MIC). The minimum image displacement vector $\\Delta\\mathbf{r}_{ij}$ is given by:\n$$\n\\Delta\\mathbf{r}_{ij} = \\mathbf{d}_{ij} - L \\cdot \\mathrm{round}\\left(\\frac{\\mathbf{d}_{ij}}{L}\\right)\n$$\nwhere the `round` function is applied component-wise. The distance between the pair is the magnitude of this vector:\n$$\nd_{ij} = \\|\\Delta\\mathbf{r}_{ij}\\|\n$$\nIf this distance $d_{ij}$ is less than $r_{\\max}$, it is assigned to a bin $k = \\lfloor d_{ij}/\\Delta r \\rfloor$.\n\nWe accumulate these counts in histograms. Let $H_{\\text{total}}(k)$ be the total count of pairs in bin $k$. Similarly, let $H_{\\alpha\\beta}(k)$ be the count of pairs in bin $k$ where one particle is of species $\\alpha$ and the other is of species $\\beta$. Following the problem's convention for unordered pairs, the species pair is identified by $(\\min(s_i, s_j), \\max(s_j, s_i))$ to ensure canonical counting.\n\n**3. Normalization and RDF Estimation**\n\nThe RDF is defined as the ratio of the measured pair density to the expected pair density in an ideal gas (a completely uncorrelated system) at the same overall particle densities. The provided normalization factors are based on unordered pair counting.\n\n**Total RDF, $g(r)$**\n\nThe measured number of pairs in bin $k$ is $H_{\\text{total}}(k)$. The expected number of pairs in an ideal gas within the same shell volume $V_{\\mathrm{shell},k}$ is given as being proportional to $\\frac{1}{2} N \\rho V_{\\mathrm{shell},k}$. This serves as our normalization factor.\n$$\nN_{\\text{ideal, total}}(k) = \\frac{1}{2} N \\rho V_{\\mathrm{shell},k} = \\frac{N^2}{2V} V_{\\mathrm{shell},k}\n$$\nThe estimator for the total RDF at the bin center $c_k$ is the ratio of the observed count to the ideal count:\n$$\ng(c_k) = \\frac{H_{\\text{total}}(k)}{N_{\\text{ideal, total}}(k)}\n$$\n\n**Partial RDFs, $g_{\\alpha\\beta}(r)$**\n\nThe same principle applies to partial RDFs, but with species-specific densities and counts.\n\nFor **homogeneous pairs** (e.g., species $\\alpha$ with species $\\alpha$), the observed count is $H_{\\alpha\\alpha}(k)$. The ideal count for unordered pairs is specified as:\n$$\nN_{\\text{ideal}, \\alpha\\alpha}(k) = \\frac{1}{2} N_\\alpha \\rho_\\alpha V_{\\mathrm{shell},k} = \\frac{N_\\alpha^2}{2V} V_{\\mathrm{shell},k}\n$$\nThe estimator for the homogeneous partial RDF is:\n$$\ng_{\\alpha\\alpha}(c_k) = \\frac{H_{\\alpha\\alpha}(k)}{N_{\\text{ideal}, \\alpha\\alpha}(k)}\n$$\nIf $N_\\alpha  2$, the count $H_{\\alpha\\alpha}(k)$ will always be $0$, and the normalization factor is also zero or ill-defined. In this case, we define $g_{\\alpha\\alpha}(c_k) = 0$.\n\nFor **heterogeneous pairs** (species $\\alpha$ with species $\\beta$, where $\\alpha \\neq \\beta$), the observed count is $H_{\\alpha\\beta}(k)$. The ideal count is given by:\n$$\nN_{\\text{ideal}, \\alpha\\beta}(k) = N_\\alpha \\rho_\\beta V_{\\mathrm{shell},k} = \\frac{N_\\alpha N_\\beta}{V} V_{\\mathrm{shell},k}\n$$\nThe estimator for the heterogeneous partial RDF is:\n$$\ng_{\\alpha\\beta}(c_k) = \\frac{H_{\\alpha\\beta}(k)}{N_{\\text{ideal}, \\alpha\\beta}(k)}\n$$\nIf $N_\\alpha=0$ or $N_\\beta=0$, the observed count and the ideal count are both zero, so we define $g_{\\alpha\\beta}(c_k)=0$.\n\n**4. Algorithmic Implementation Outline**\n\nThe algorithm for each test case proceeds as follows:\n1.  Parse the input parameters: $L$, particle positions and species, $\\Delta r$, and $r_{\\max}$. Consolidate positions into a single array and species into a corresponding integer-indexed array for computational efficiency.\n2.  Calculate system-wide properties: $V=L^3$, total particle count $N$, species counts $N_\\alpha$, and densities $\\rho$ and $\\rho_\\alpha$.\n3.  Initialize histogram arrays for total and partial counts to zero. The number of bins is $M = \\lfloor r_{\\max}/\\Delta r \\rfloor$.\n4.  Iterate through all unique pairs of particles $(i,j)$ where $i  j$.\n    a. Compute the distance $d_{ij}$ using the minimum image convention.\n    b. If $d_{ij}  r_{\\max}$, find the bin index $k = \\lfloor d_{ij}/\\Delta r \\rfloor$.\n    c. Increment the total count `H_total[k]`.\n    d. Identify the species indices $(s_i, s_j)$ of the pair, determine the canonical pair index $(\\min(s_i, s_j), \\max(s_i, s_j))$, and increment the corresponding partial count `H_partial[min(s_i,s_j)][max(s_i,s_j)][k]`.\n5.  Initialize result arrays for $g(c_k)$ and all $g_{\\alpha\\beta}(c_k)$ to zero.\n6.  Iterate from bin $k=0$ to $M-1$:\n    a. Calculate the shell volume $V_{\\mathrm{shell},k}$.\n    b. Calculate all normalization factors ($N_{\\text{ideal, total}}$, $N_{\\text{ideal}, \\alpha\\alpha}$, $N_{\\text{ideal}, \\alpha\\beta}$).\n    c. If a normalization factor is non-zero, compute the corresponding RDF value by dividing the histogram count by the factor. Otherwise, the RDF value remains $0$.\n7.  Collect the list of bin centers and all computed RDF arrays. Format these into the nested list structure specified in the problem statement, ensuring the prescribed order for partial RDFs.\n\nThis procedure constitutes a complete and deterministic algorithm for computing the required RDFs from first principles as laid out in the problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used.\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It processes each test case, calculates the RDFs, and prints the final result.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 10.0,\n            \"positions\": {\n                \"A\": [[1.0, 1.0, 1.0], [1.0, 3.0, 1.0], [4.0, 4.0, 4.0]],\n                \"B\": [[8.0, 1.0, 1.0], [5.0, 4.0, 4.5], [1.0, 8.0, 1.0]]\n            },\n            \"species_order\": [\"A\", \"B\"],\n            \"dr\": 0.5,\n            \"r_max\": 5.0\n        },\n        {\n            \"L\": 12.0,\n            \"positions\": {\n                \"C\": [[1.0, 1.0, 1.0], [11.0, 1.0, 1.0], [6.0, 6.0, 6.0], [1.0, 11.0, 11.0]]\n            },\n            \"species_order\": [\"C\"],\n            \"dr\": 1.0,\n            \"r_max\": 6.0\n        },\n        {\n            \"L\": 10.0,\n            \"positions\": {\n                \"A\": [[2.0, 2.0, 2.0]],\n                \"B\": [[2.5, 2.0, 2.0], [7.0, 7.0, 7.0], [7.5, 7.0, 7.0], [7.0, 7.5, 7.0], [7.0, 7.0, 7.5], [9.0, 9.0, 9.0], [9.5, 9.0, 9.0]]\n            },\n            \"species_order\": [\"A\", \"B\"],\n            \"dr\": 0.4,\n            \"r_max\": 4.0\n        },\n        {\n            \"L\": 8.0,\n            \"positions\": {\n                \"A\": [[0.5, 0.5, 0.5], [4.0, 4.0, 4.0]],\n                \"B\": [[7.5, 7.5, 7.5], [4.0, 0.5, 7.5]]\n            },\n            \"species_order\": [\"A\", \"B\"],\n            \"dr\": 0.5,\n            \"r_max\": 4.0\n        },\n        {\n            \"L\": 9.0,\n            \"positions\": {\n                \"A\": [[1.0, 1.0, 1.0], [3.0, 1.0, 1.0]],\n                \"B\": [[5.0, 5.0, 5.0], [5.5, 5.0, 5.5]],\n                \"C\": [[8.0, 8.0, 8.0]]\n            },\n            \"species_order\": [\"A\", \"B\", \"C\"],\n            \"dr\": 0.6,\n            \"r_max\": 4.0\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = calculate_rdf(\n            case[\"L\"],\n            case[\"positions\"],\n            case[\"species_order\"],\n            case[\"dr\"],\n            case[\"r_max\"]\n        )\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    def format_list(item):\n        if isinstance(item, list):\n            return f\"[{','.join(format_list(sub_item) for sub_item in item)}]\"\n        elif isinstance(item, np.ndarray):\n            return format_list(item.tolist())\n        else:\n            return repr(item)\n\n    # The problem asks for float numbers, repr() is a safe choice to not lose precision\n    # and match the typical expectation of scientific computations.\n    # A simple str() would also work but might use scientific notation. repr() is more explicit.\n    final_output_str = format_list(all_results)\n    print(final_output_str)\n\ndef calculate_rdf(L, positions_dict, species_order, dr, r_max):\n    \"\"\"\n    Calculates total and partial RDFs for a given particle configuration.\n    \"\"\"\n    # 1. Prepare data structures\n    V = L**3\n    species_map = {name: i for i, name in enumerate(species_order)}\n    num_species = len(species_order)\n\n    all_pos = []\n    all_species_indices = []\n    species_counts = np.zeros(num_species, dtype=int)\n\n    for species_name, pos_list in positions_dict.items():\n        idx = species_map[species_name]\n        all_pos.extend(pos_list)\n        all_species_indices.extend([idx] * len(pos_list))\n        species_counts[idx] = len(pos_list)\n\n    all_pos = np.array(all_pos, dtype=float)\n    all_species_indices = np.array(all_species_indices, dtype=int)\n    N = len(all_pos)\n    \n    if N == 0: # Handle empty system case\n        num_bins = int(np.floor(r_max / dr))\n        bin_centers = (np.arange(num_bins) + 0.5) * dr\n        g_total = np.zeros(num_bins)\n        num_partial_rdfs = num_species * (num_species + 1) // 2\n        results = [bin_centers.tolist(), g_total.tolist()]\n        for _ in range(num_partial_rdfs):\n            results.append(np.zeros(num_bins).tolist())\n        return results\n\n    rho = N / V\n    species_rhos = species_counts / V\n\n    # 2. Setup bins and histograms\n    num_bins = int(np.floor(r_max / dr))\n    bin_centers = (np.arange(num_bins) + 0.5) * dr\n    \n    # Histograms\n    total_counts = np.zeros(num_bins, dtype=int)\n    partial_counts = np.zeros((num_species, num_species, num_bins), dtype=int)\n\n    # 3. Pair distance calculation and binning\n    for i in range(N):\n        for j in range(i + 1, N):\n            rij = all_pos[j] - all_pos[i]\n            rij -= L * np.round(rij / L) # Minimum image convention\n            dist = np.linalg.norm(rij)\n\n            if dist  r_max:\n                bin_idx = int(np.floor(dist / dr))\n                if bin_idx  num_bins:\n                    total_counts[bin_idx] += 1\n                    \n                    s_i, s_j = all_species_indices[i], all_species_indices[j]\n                    # Canonical species pair indexing\n                    idx1, idx2 = min(s_i, s_j), max(s_i, s_j)\n                    partial_counts[idx1, idx2, bin_idx] += 1\n\n    # 4. Normalization\n    g_total = np.zeros(num_bins, dtype=float)\n    g_partials = { (i,j): np.zeros(num_bins, dtype=float) for i in range(num_species) for j in range(i,num_species) }\n\n    for k in range(num_bins):\n        r_in = k * dr\n        r_out = (k + 1) * dr\n        shell_volume = (4.0 / 3.0) * np.pi * (r_out**3 - r_in**3)\n\n        # Total RDF\n        if N >= 2:\n            norm_total = 0.5 * N * rho * shell_volume\n            if norm_total > 0:\n                g_total[k] = total_counts[k] / norm_total\n        \n        # Partial RDFs\n        for i in range(num_species):\n            for j in range(i, num_species):\n                count = partial_counts[i, j, k]\n                if i == j: # Homogeneous\n                    if species_counts[i] >= 2:\n                        norm_partial = 0.5 * species_counts[i] * species_rhos[i] * shell_volume\n                        if norm_partial > 0:\n                           g_partials[(i,j)][k] = count / norm_partial\n                else: # Heterogeneous\n                    if species_counts[i] > 0 and species_counts[j] > 0:\n                        norm_partial = species_counts[i] * species_rhos[j] * shell_volume\n                        if norm_partial > 0:\n                            g_partials[(i,j)][k] = count / norm_partial\n    \n    # 5. Assemble results in specified order\n    final_results_list = [bin_centers.tolist(), g_total.tolist()]\n    for i in range(num_species):\n        for j in range(i, num_species):\n            final_results_list.append(g_partials[(i,j)].tolist())\n            \n    return final_results_list\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}