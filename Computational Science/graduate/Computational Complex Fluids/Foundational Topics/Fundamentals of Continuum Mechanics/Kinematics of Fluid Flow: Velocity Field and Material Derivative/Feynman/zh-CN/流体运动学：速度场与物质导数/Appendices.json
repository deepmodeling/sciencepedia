{
    "hands_on_practices": [
        {
            "introduction": "我们的第一个练习旨在探究物质导数的物理核心。我们将通过一个简单的一维流动来区分固定观察者所见的局部变化率（$\\frac{\\partial\\phi}{\\partial t}$）和运动中流体质点所经历的总变化率（$\\frac{D\\phi}{Dt}$）。这项练习  旨在揭示物质导数的基本属性——伽利略不变性，表明它代表了一个独立于观察者惯性参考系的客观物理实在。",
            "id": "3376245",
            "problem": "考虑计算流体动力学 (CFD) 语境下的一维均匀流。设空间坐标为 $x$（单位：米），时间为 $t$（单位：秒）。流速场是恒定的，$u(x,t)=U_{0}$，其中 $U_{0}$ 是一个单位为米/秒的常数。定义一个标量场 $\\phi(x,t)=x-U_{0}t$，其单位与 $x$ 相同。\n\n从物质导数的运动学定义（即流体质点所经历的场的时间变化率）出发，并利用流体质点轨迹满足 $dx/dt=u(x,t)$ 这一条件，仅使用链式法则和轨迹的定义，推导物质导数 $D\\phi/Dt$ 关于 $\\phi$ 的偏导数和速度 $u$ 的显式表达式。\n\n然后，为给定的 $\\phi$ 和 $u$ 计算 $D\\phi/Dt$，并通过考虑 $\\phi$ 在满足 $dx/dt=U_{0}$ 的轨迹 $x(t)$ 上的值来物理解释结果。\n\n为了说明参考系的依赖性，考虑一个伽利略变换，变换到一个相对于实验室参考系以恒定速度 $V$ 运动的惯性参考系，定义为 $x'=x-Vt$ 和 $t'=t$。在变换后的坐标系中，写出 $\\phi'(x',t')=\\phi(x'+Vt',t')$ 和速度 $u'(x',t')=u(x'+Vt',t')-V$。在带撇的坐标系中使用相同的运动学定义，判断物质导数 $D\\phi'/Dt'$ 是否等于 $D\\phi/Dt$，以及 $\\phi$ 的时间偏导数是否等于 $\\phi'$ 的时间偏导数。\n\n最后，报告此流动和场的物质导数的数值。最终答案以米/秒为单位表示。无需四舍五入。",
            "solution": "物质导数在运动学上定义为随流体运动的质点所经历的标量场的时间变化率。如果一个流体质点的位置 $x(t)$ 满足轨迹方程 $dx/dt=u(x,t)$，那么 $\\phi$ 沿该轨迹的物质导数为\n$$\n\\frac{D\\phi}{Dt}=\\frac{d}{dt}\\,\\phi\\big(x(t),t\\big).\n$$\n对复合函数 $\\phi(x(t),t)$ 应用多元链式法则，我们得到\n$$\n\\frac{d}{dt}\\,\\phi\\big(x(t),t\\big)=\\frac{\\partial \\phi}{\\partial t}\\big(x(t),t\\big)+\\frac{dx}{dt}\\,\\frac{\\partial \\phi}{\\partial x}\\big(x(t),t\\big).\n$$\n使用运动学关系 $\\frac{dx}{dt}=u(x(t),t)$，我们得到标准表达式\n$$\n\\frac{D\\phi}{Dt}=\\frac{\\partial \\phi}{\\partial t}+u\\,\\frac{\\partial \\phi}{\\partial x}.\n$$\n对于一维场 $\\phi(x,t)=x-U_{0}t$ 和均匀速度 $u(x,t)=U_{0}$，计算其偏导数：\n$$\n\\frac{\\partial \\phi}{\\partial t}=-U_{0},\\qquad \\frac{\\partial \\phi}{\\partial x}=1.\n$$\n因此，\n$$\n\\frac{D\\phi}{Dt}=\\left(-U_{0}\\right)+U_{0}\\cdot 1=0.\n$$\n沿轨迹的直接物理检验可以证实这一点。流体质点的轨迹 $x(t)$ 满足 $dx/dt=U_{0}$，因此 $x(t)=x_{0}+U_{0}t$，其中 $x_{0}$ 是由初始条件设定的某个常数。沿此轨迹计算 $\\phi$ 的值可得\n$$\n\\phi\\big(x(t),t\\big)=\\big(x_{0}+U_{0}t\\big)-U_{0}t=x_{0},\n$$\n该值不随时间变化，所以 $d\\phi/dt=0$，因此 $D\\phi/Dt=0$。\n\n现在考虑伽利略变换，变换到一个相对于实验室参考系以恒速 $V$ 运动的带撇参考系：\n$$\nx'=x-Vt,\\qquad t'=t.\n$$\n带撇参考系中的标量场通过代入得到：\n$$\n\\phi'(x',t')=\\phi(x'+Vt',t')=\\big(x'+Vt'\\big)-U_{0}t'=x'-(U_{0}-V)t'.\n$$\n带撇参考系中的速度为\n$$\nu'(x',t')=u(x'+Vt',t')-V=U_{0}-V.\n$$\n计算带撇参考系中的偏导数：\n$$\n\\frac{\\partial \\phi'}{\\partial t'}=-(U_{0}-V),\\qquad \\frac{\\partial \\phi'}{\\partial x'}=1.\n$$\n则带撇参考系中的物质导数为\n$$\n\\frac{D\\phi'}{Dt'}=\\frac{\\partial \\phi'}{\\partial t'}+u'\\,\\frac{\\partial \\phi'}{\\partial x'}=-(U_{0}-V)+(U_{0}-V)\\cdot 1=0,\n$$\n这表明物质导数在此伽利略变换下是不变的。相比之下，时间偏导数则不是不变量：在实验室参考系中为 $\\frac{\\partial \\phi}{\\partial t}=-U_{0}$，而在运动参考系中为 $\\frac{\\partial \\phi'}{\\partial t'}=-(U_{0}-V)$，除非 $V=0$，否则二者不同。\n\n因此，对于给定的场和流动，物质导数在任何地方和任何惯性参考系中都恒等于零。其单位是米/秒，因为它是一个单位为米的量的时间变化率。\n\n所要求的最终值为\n$$\n\\frac{D\\phi}{Dt}=0.\n$$",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "在理解了物质导数的物理定义后，这项练习将在二维背景下探究其组成部分。通过分析一个刚体旋转流，你将计算物质导数，并从几何角度解释为何平流项会消失。这项练习  突显了流场方向与标量场梯度之间的关键关系，为平流项 $\\mathbf{v} \\cdot \\nabla\\phi$ 提供了清晰的视觉理解。",
            "id": "4091900",
            "problem": "考虑一个在计算流体动力学 (CFD) 中代表刚体旋转的二维流。设平面上的速度场为 $\\mathbf{v}(\\mathbf{x},t)=\\left(y,-x\\right)$，其中 $\\mathbf{x}=(x,y)$，并设一个无量纲标量场为 $\\phi(\\mathbf{x},t)=x^{2}+y^{2}+t$。物质导数定义为流体质点随流运动时所经历的标量场的时间变化率。仅从由 $\\mathrm{d}\\mathbf{X}/\\mathrm{d}t=\\mathbf{v}(\\mathbf{X}(t),t)$ 决定的流体质点轨迹 $\\mathbf{X}(t)$ 的定义，以及物质导数作为沿该轨迹的全导数 $\\mathrm{d}\\phi(\\mathbf{X}(t),t)/\\mathrm{d}t$ 的定义出发，推导出一个用 $x$、$y$ 和 $t$ 表示的 $D\\phi/Dt$ 的显式表达式，并对其求值。然后，从几何角度结合旋转来解释该结果，说明对于此特定的 $\\phi$ 和 $\\mathbf{v}$，为何存在或不存在任何对流贡献。将 $\\phi$ 视为无量纲；不需要单位。将 $D\\phi/Dt$ 的最终值以单个精确数或闭式表达式的形式给出。无需四舍五入。",
            "solution": "该问题要求对给定的二维速度场 $\\mathbf{v}(\\mathbf{x}, t) = (y, -x)$ 和标量场 $\\phi(\\mathbf{x}, t) = x^2 + y^2 + t$，推导并求值物质导数 $\\frac{D\\phi}{Dt}$。位置矢量为 $\\mathbf{x}=(x,y)$。推导过程必须从流体质点轨迹的基本定义以及物质导数作为沿此轨迹的全导数的定义出发。\n\n流体质点的轨迹，用矢量函数 $\\mathbf{X}(t) = (X(t), Y(t))$ 表示，是由速度场决定的。在任意时刻 $t$，质点的速度等于流体在质点位置 $\\mathbf{X}(t)$ 处速度。此关系由以下常微分方程表示：\n$$\n\\frac{\\mathrm{d}\\mathbf{X}}{\\mathrm{d}t} = \\mathbf{v}(\\mathbf{X}(t), t)\n$$\n标量场 $\\phi$ 的物质导数，记为 $\\frac{D\\phi}{Dt}$，定义为随流体质点移动的观察者所经历的 $\\phi$ 的时间变化率。在数学上，这是复合函数 $\\phi(\\mathbf{X}(t), t)$ 关于时间 $t$ 的全导数：\n$$\n\\frac{D\\phi}{Dt} = \\frac{\\mathrm{d}}{\\mathrm{d}t}\\phi(\\mathbf{X}(t), t)\n$$\n为了求得此全导数，我们应用多元链式法则。函数 $\\phi$ 显式地依赖于时间 $t$，并且也通过质点坐标 $X(t)$ 和 $Y(t)$ 隐式地依赖于时间 $t$，而 $X(t)$ 和 $Y(t)$ 本身也是 $t$ 的函数。链式法则得出：\n$$\n\\frac{D\\phi}{Dt} = \\frac{\\partial\\phi}{\\partial X}\\frac{\\mathrm{d}X}{\\mathrm{d}t} + \\frac{\\partial\\phi}{\\partial Y}\\frac{\\mathrm{d}Y}{\\mathrm{d}t} + \\frac{\\partial\\phi}{\\partial t}\\frac{\\mathrm{d}t}{\\mathrm{d}t}\n$$\n根据质点轨迹的定义，其速度分量由在质点位置处求值的流体速度场 $\\mathbf{v} = (u,v)$ 的分量给出：\n$$\n\\frac{\\mathrm{d}X}{\\mathrm{d}t} = u(X(t), Y(t), t) \\quad \\text{和} \\quad \\frac{\\mathrm{d}Y}{\\mathrm{d}t} = v(X(t), Y(t), t)\n$$\n将这些表达式代入链式法则方程，并注意到 $\\frac{\\mathrm{d}t}{\\mathrm{d}t} = 1$，我们得到用场变量表示的物质导数表达式：\n$$\n\\frac{D\\phi}{Dt} = \\frac{\\partial\\phi}{\\partial t} + u\\frac{\\partial\\phi}{\\partial X} + v\\frac{\\partial\\phi}{\\partial Y}\n$$\n这个表达式通常在欧拉参考系中书写，使用空间坐标 $(x,y)$ 而非拉格朗日质点坐标 $(X,Y)$。用矢量表示法，即为：\n$$\n\\frac{D\\phi}{Dt} = \\frac{\\partial\\phi}{\\partial t} + \\mathbf{v} \\cdot \\nabla\\phi\n$$\n这是按要求推导出的物质导数的通用表达式。它由两部分组成：局部变化率 $\\frac{\\partial\\phi}{\\partial t}$，即在空间固定点上观察到的变化；以及对流变化率 $\\mathbf{v} \\cdot \\nabla\\phi$，即由于质点运动到 $\\phi$ 值不同的区域所引起的变化。\n\n我们现在对问题中给出的特定场计算此表达式的值：\n- 速度场：$\\mathbf{v}(x,y) = (y, -x)$，因此分量为 $u=y$ 和 $v=-x$。\n- 标量场：$\\phi(x,y,t) = x^2 + y^2 + t$。\n\n首先，我们计算 $\\phi$ 的局部变化率：\n$$\n\\frac{\\partial\\phi}{\\partial t} = \\frac{\\partial}{\\partial t}(x^2 + y^2 + t) = 1\n$$\n接着，我们计算 $\\phi$ 的梯度 $\\nabla\\phi$：\n$$\n\\nabla\\phi = \\left(\\frac{\\partial\\phi}{\\partial x}, \\frac{\\partial\\phi}{\\partial y}\\right) = \\left(\\frac{\\partial}{\\partial x}(x^2 + y^2 + t), \\frac{\\partial}{\\partial y}(x^2 + y^2 + t)\\right) = (2x, 2y)\n$$\n现在，我们计算对流项 $\\mathbf{v} \\cdot \\nabla\\phi$：\n$$\n\\mathbf{v} \\cdot \\nabla\\phi = (u, v) \\cdot \\left(\\frac{\\partial\\phi}{\\partial x}, \\frac{\\partial\\phi}{\\partial y}\\right) = (y, -x) \\cdot (2x, 2y) = y(2x) + (-x)(2y) = 2xy - 2xy = 0\n$$\n最后，我们将局部项和对流项相加，求得物质导数：\n$$\n\\frac{D\\phi}{Dt} = \\frac{\\partial\\phi}{\\partial t} + \\mathbf{v} \\cdot \\nabla\\phi = 1 + 0 = 1\n$$\n物质导数的值为 $1$。\n\n对于几何解释，我们必须说明为什么对流贡献 $\\mathbf{v} \\cdot \\nabla\\phi$ 为零。对流项为零意味着在流场中的每一点，速度矢量 $\\mathbf{v}$ 都与梯度矢量 $\\nabla\\phi$ 正交。\n\n让我们分析这些矢量场的几何性质。\n在任意固定时刻 $t_0$，标量场为 $\\phi(x,y,t_0) = x^2 + y^2 + t_0$。其空间变化由 $f(x,y) = x^2 + y^2$ 给出。此函数的等值集，即 $f(x,y)$ 为常数的集合，是方程为 $x^2 + y^2 = C$（其中 $C$ 为某个常数）的以原点为中心的圆。\n$\\phi$ 的梯度 $\\nabla\\phi = (2x, 2y)$ 是一个始终从原点径向向外的矢量。梯度矢量始终垂直于函数的等值集。\n\n速度场 $\\mathbf{v} = (y, -x)$ 描述了围绕原点的刚体旋转。我们可以验证，在任意点 $\\mathbf{r}=(x,y)$ 的速度矢量与经过该点的圆相切。位置矢量 $\\mathbf{r}=(x,y)$ 是径向的。位置矢量和速度矢量的点积为：\n$$\n\\mathbf{r} \\cdot \\mathbf{v} = (x,y) \\cdot (y, -x) = xy - yx = 0\n$$\n由于它们的点积为零，速度矢量 $\\mathbf{v}$ 始终与位置矢量 $\\mathbf{r}$ 正交。\n我们已经确定 $\\nabla\\phi$ 与 $\\mathbf{r}$ 平行，而 $\\mathbf{v}$ 与 $\\mathbf{r}$ 正交。由此直接得出 $\\mathbf{v}$ 与 $\\nabla\\phi$ 正交。\n\n这种正交性具有明确的物理意义。跟随速度矢量 $\\mathbf{v}$ 运动的流体质点，其运动轨迹与 $\\phi$ 的空间部分的等值集相切。在本例中，质点沿圆形轨迹运动，在任何给定的圆上，$x^2+y^2$ 的值是恒定的。因为质点的运动不会将其输运到 $x^2+y^2$ 值不同的位置，所以不存在由对流引起的 $\\phi$ 的变化。质点所经历的 $\\phi$ 的变化，仅仅是因为 $\\phi$ 本身在随时间显式地变化。\n\n因此，质点观察到的总变化 $\\frac{D\\phi}{Dt}$ 完全由局部变化率 $\\frac{\\partial\\phi}{\\partial t} = 1$ 引起。对流贡献为零，因为流动方向完全沿着标量场空间分量的等值面。",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "前面的练习侧重于物质导数的解析理解。这最后一项练习则将理论与计算实践联系起来，专注于其平流项 $(\\mathbf{v}\\cdot\\nabla)\\phi$ 的数值近似，这是计算流体动力学（CFD）的基石。在这个编程练习  中，你将实现并比较不同的数值格式，以观察它们对解的精度的影响，例如数值扩散和色散，从而亲身体验模拟流体流动时的实际挑战。",
            "id": "4091866",
            "problem": "考虑一维周期性区域中标量场的纯平流问题。速度场 $\\,\\mathbf{v}(\\mathbf{x},t)\\,$ 中标量场 $\\,\\phi(\\mathbf{x},t)\\,$ 的物质导数定义为 $\\,\\dfrac{D\\phi}{Dt}=\\dfrac{\\partial\\phi}{\\partial t}+(\\mathbf{v}\\cdot\\nabla)\\phi\\,$。对于恒定速度场 $\\,\\mathbf{v}(\\mathbf{x},t)=u\\,\\hat{\\mathbf{e}}_x\\,$，在长度为 $\\,L=1\\,$ 的周期性区域上，平流方程简化为 $\\,\\dfrac{\\partial\\phi}{\\partial t}+u\\,\\dfrac{\\partial\\phi}{\\partial x}=0\\,$。\n\n您的任务是实现一个程序，使用线方法将 $\\,\\phi(x,t)\\,$ 从 $\\,t=0\\,$ 在数值上推进到 $\\,t=T\\,$，并采用三阶显式强稳定保持龙格-库塔方法（SSP-RK3），同时使用三种不同的空间格式来近似对流项 $\\,(\\mathbf{v}\\cdot\\nabla)\\phi=u\\,\\dfrac{\\partial\\phi}{\\partial x}\\,$：\n- 一阶迎风（供体单元）格式，\n- 二阶中心差分格式，\n- 带单调中心（MC）限制器的高分辨率守恒律单调上游中心格式（MUSCL）。\n\n所有格式都必须在周期性边界条件下实现。除离散化本身外，不要使用任何人工平滑或滤波。\n\n初始条件：对于给定的界面位置 $\\,x_0\\in(0,1)\\,$ 和陡峭度参数 $\\,\\varepsilon>0\\,$，设置\n$$\n\\phi(x,0)=\\frac{1}{2}\\left(1+\\tanh\\left(\\frac{x-x_0}{\\varepsilon}\\right)\\right).\n$$\n在时刻 $\\,T\\,$ 的精确解是平移\n$$\n\\phi_{\\text{exact}}(x,T)=\\frac{1}{2}\\left(1+\\tanh\\left(\\frac{(x-uT)\\bmod L - x_0}{\\varepsilon}\\right)\\right).\n$$\n本问题中所有量均为无量纲；无需物理单位。\n\n时间步进：使用由 Courant–Friedrichs–Lewy 数 $\\,\\text{CFL}\\,$ 通过 $\\,\\Delta t=\\text{CFL}\\,\\dfrac{\\Delta x}{|u|}\\,$ 定义的均匀时间步长，其中 $\\,\\Delta x=L/N\\,$ 且 $\\,N\\,$ 是网格点数。积分直到 $\\,t=T\\,$，如有必要，可调整最后一步的步长，以确保最终时间恰好为 $\\,T\\,$。\n\n对于每种格式，在达到 $\\,t=T\\,$ 后，使用以下指标量化其对陡峭梯度平流的影响：\n- 相对于精确解的离散 $\\,L^1\\,$ 误差，\n$$\nE=\\Delta x\\sum_{i=0}^{N-1}\\left|\\phi_i(T)-\\phi_{\\text{exact}}(x_i,T)\\right|,\n$$\n- 相对于物理合理范围 $\\,\\phi\\in[0,1]\\,$ 的最大越界（过冲），\n$$\nO=\\max\\left(\\max_i\\left(\\phi_i(T)-1\\right),\\ \\max_i\\left(0-\\phi_i(T)\\right),\\ 0\\right).\n$$\n\n测试组：为以下参数集运行您的程序，所有测试均使用 $\\,L=1\\,$、$\\,u=1\\,$ 和 $\\,x_0=0.35$，\n1. $\\,N=128\\,$, $\\,\\text{CFL}=0.4\\,$, $\\,T=0.25\\,$, $\\,\\varepsilon=0.01\\,$,\n2. $\\,N=64\\,$, $\\,\\text{CFL}=0.6\\,$, $\\,T=0.5\\,$, $\\,\\varepsilon=0.005\\,$,\n3. $\\,N=256\\,$, $\\,\\text{CFL}=0.7\\,$, $\\,T=1.0\\,$, $\\,\\varepsilon=0.02\\,$.\n\n输出规范：您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是按以下顺序排列的六个浮点数列表\n$$\n\\left[E_{\\text{upwind}},E_{\\text{central}},E_{\\text{high}},O_{\\text{upwind}},O_{\\text{central}},O_{\\text{high}}\\right],\n$$\n其中“high”表示高分辨率 MUSCL–MC 格式。因此，最终输出必须是以下形式的单行\n$$\n\\big[\\,[E_{\\text{up}},E_{\\text{cen}},E_{\\text{hi}},O_{\\text{up}},O_{\\text{cen}},O_{\\text{hi}}],\\ [\\cdots],\\ [\\cdots]\\big],\n$$\n打印的列表中不含空格。",
            "solution": "该问题要求在一维周期性域（长度 $L=1$）上数值求解线性平流方程 $\\dfrac{\\partial\\phi}{\\partial t}+u\\,\\dfrac{\\partial\\phi}{\\partial x}=0$。解将使用线方法从 $t=0$ 推进到最终时间 $t=T$。该方法涉及将空间导数离散化，从而将偏微分方程（PDE）转换为常微分方程（ODE）组，然后使用数值时间积分器求解。\n\n在网格点 $x_i$ 处，平流方程的半离散形式由下式给出：\n$$\n\\frac{d\\phi_i}{dt} = -u \\left(\\frac{\\partial\\phi}{\\partial x}\\right)_i \\equiv \\mathcal{L}(\\phi)_i\n$$\n其中 $(\\partial\\phi/\\partial x)_i$ 表示在网格点 $i$ 处空间导数的数值近似，而 $\\mathcal{L}$ 是空间离散算子。网格由 $N$ 个点 $x_i = i \\Delta x$（$i=0, 1, \\dots, N-1$）组成，均匀网格间距为 $\\Delta x = L/N$。\n\n问题指定了三种不同的格式来近似空间导数项 $u\\,\\partial\\phi/\\partial x$：\n\n1.  **一阶迎风格式**：此格式根据平流速度 $u$ 的符号选择。由于问题指定 $u=1 > 0$，信息从左向右传播。“供体单元”是左侧的单元（$i-1$）。导数使用后向差分近似：\n    $$\n    u \\left(\\frac{\\partial\\phi}{\\partial x}\\right)_i \\approx u \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}\n    $$\n    众所周知，这种格式耗散性很强，会抹平陡峭的梯度。\n\n2.  **二阶中心差分格式**：此格式使用围绕点 $x_i$ 的对称模板，并提供导数的二阶精确近似：\n    $$\n    u \\left(\\frac{\\partial\\phi}{\\partial x}\\right)_i \\approx u \\frac{\\phi_{i+1} - \\phi_{i-1}}{2\\Delta x}\n    $$\n    虽然对于光滑解更精确，但这种格式是色散的，并且会在陡峭梯度附近引入非物理振荡（吉布斯现象），从而违反初始数据的界限。\n\n3.  **带 MC 限制器的高分辨率 MUSCL 格式**：守恒律单调上游中心格式（MUSCL）方法通过使用通量限制器，在光滑区域实现更高阶的精度，同时防止在间断处产生振荡。这是一种受有限体积法启发的方法。半离散方程以守恒形式写出：\n    $$\n    \\frac{d\\phi_i}{dt} = -\\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x}\n    $$\n    其中 $F_{i+1/2}$ 是单元 $i$ 和 $i+1$ 之间界面上的数值通量。对于线性平流，物理通量为 $F(\\phi) = u\\phi$。对于 $u > 0$，数值通量由界面左侧的重构状态 $\\phi_{i,R}$ 确定：\n    $$\n    F_{i+1/2} = u \\phi_{i,R}\n    $$\n    状态 $\\phi_{i,R}$ 通过假设单元 $i$ 内为线性分布 $\\phi(x) = \\phi_i + s_i(x-x_i)$，并在右侧单元边界 $x_{i+1/2} = x_i + \\Delta x / 2$ 处求值来重构。斜率 $s_i$ 受到限制以防止振荡。一种更方便的公式使用单元内的变化量 $\\Delta\\phi_i$：\n    $$\n    \\phi_{i,R} = \\phi_i + \\frac{1}{2}\\Delta\\phi_i\n    $$\n    单调中心（MC）限制器将此变化定义为：\n    $$\n    \\Delta\\phi_i = \\text{minmod}\\left(2(\\phi_i - \\phi_{i-1}), \\frac{\\phi_{i+1} - \\phi_{i-1}}{2}, 2(\\phi_{i+1} - \\phi_i)\\right)\n    $$\n    多参数 minmod 函数定义为：\n    $$\n    \\text{minmod}(a_1, a_2, \\dots, a_k) = \n    \\begin{cases} \n    \\min(a_1, a_2, \\dots, a_k)  & \\text{if } a_j > 0 \\text{ for all } j \\\\\n    \\max(a_1, a_2, \\dots, a_k)  & \\text{if } a_j < 0 \\text{ for all } j \\\\\n    0  & \\text{otherwise}\n    \\end{cases}\n    $$\n    因此，MUSCL 格式的空间算子为：\n    $$\n    \\mathcal{L}(\\phi)_i = -\\frac{u}{\\Delta x}\\left[ \\left(\\phi_i + \\frac{1}{2}\\Delta\\phi_i\\right) - \\left(\\phi_{i-1} + \\frac{1}{2}\\Delta\\phi_{i-1}\\right) \\right]\n    $$\n    对于所有格式，都强制执行周期性边界条件，这意味着索引对 $N$ 取模。例如，$\\phi_{-1} \\equiv \\phi_{N-1}$ 且 $\\phi_N \\equiv \\phi_0$。\n\n对于时间积分，问题指定了三阶、三级、显式强稳定保持龙格-库塔（SSP-RK3）方法。给定 ODE 系统 $\\frac{d\\phi}{dt} = \\mathcal{L}(\\phi)$，从时间 $t_n$ 到 $t_{n+1}=t_n+\\Delta t$ 的更新过程如下：\n\\begin{align*}\n\\phi^{(1)} &= \\phi^n + \\Delta t \\, \\mathcal{L}(\\phi^n) \\\\\n\\phi^{(2)} &= \\frac{3}{4}\\phi^n + \\frac{1}{4}\\phi^{(1)} + \\frac{1}{4}\\Delta t \\, \\mathcal{L}(\\phi^{(1)}) \\\\\n\\phi^{n+1} &= \\frac{1}{3}\\phi^n + \\frac{2}{3}\\phi^{(2)} + \\frac{2}{3}\\Delta t \\, \\mathcal{L}(\\phi^{(2)})\n\\end{align*}\n此过程在每个时间步长上独立地应用于三种空间格式中的每一种。时间步长 $\\Delta t$ 由 Courant–Friedrichs–Lewy（CFL）条件确定，$\\Delta t = \\text{CFL} \\frac{\\Delta x}{|u|}$。为确保积分恰好在 $t=T$ 停止，如有必要，将调整最后的时间步长。\n\n初始条件是一个以 $x_0$ 为中心的光滑阶跃函数：\n$$\n\\phi(x,0)=\\frac{1}{2}\\left(1+\\tanh\\left(\\frac{x-x_0}{\\varepsilon}\\right)\\right)\n$$\n对于在长度为 $L$ 的域上具有恒定速度 $u$ 和周期性边界条件的线性平流方程，精确解是初始分布的简单平移：\n$$\n\\phi_{\\text{exact}}(x,T)=\\phi((x-uT)\\bmod L, 0) = \\frac{1}{2}\\left(1+\\tanh\\left(\\frac{(x-uT)\\bmod L - x_0}{\\varepsilon}\\right)\\right).\n$$\n程序将对每个测试用例进行平流模拟，应用所有三种空间格式。在达到最终时间 $T$ 后，它将为每种格式计算两个指标：离散 $L^1$ 误差 $E$，以及最大越界（过冲/下冲）$O$。\n$$\nE=\\Delta x\\sum_{i=0}^{N-1}\\left|\\phi_i(T)-\\phi_{\\text{exact}}(x_i,T)\\right|\n$$\n$$\nO=\\max\\left(\\max_i\\left(\\phi_i(T)-1\\right),\\ \\max_i\\left(0-\\phi_i(T)\\right),\\ 0\\right)\n$$\n然后，将所有测试用例的结果收集并按规定格式化为单行输出。使用 `numpy` 进行向量化操作，特别是使用 `numpy.roll` 处理周期性边界，是实现高效程序的关键。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the simulation for all test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 128, 'CFL': 0.4, 'T': 0.25, 'epsilon': 0.01, 'L': 1.0, 'u': 1.0, 'x0': 0.35},\n        {'N': 64, 'CFL': 0.6, 'T': 0.5, 'epsilon': 0.005, 'L': 1.0, 'u': 1.0, 'x0': 0.35},\n        {'N': 256, 'CFL': 0.7, 'T': 1.0, 'epsilon': 0.02, 'L': 1.0, 'u': 1.0, 'x0': 0.35},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(**params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # repr() gives a string representation, and .replace(' ', '') removes spaces.\n    print(repr(results).replace(\" \", \"\"))\n\ndef vectorized_minmod(args):\n    \"\"\"\n    Vectorized minmod function for multiple arguments.\n    args: A list/tuple of numpy arrays.\n    \"\"\"\n    arr = np.array(args)\n    s = np.sign(arr)\n    all_pos = np.all(s >= 0, axis=0)\n    all_neg = np.all(s = 0, axis=0)\n    \n    result = np.zeros_like(arr[0])\n    \n    # Where all are positive, take the minimum\n    if np.any(all_pos):\n        result[all_pos] = np.min(arr[:, all_pos], axis=0)\n    \n    # Where all are negative, take the maximum\n    if np.any(all_neg):\n        result[all_neg] = np.max(arr[:, all_neg], axis=0)\n        \n    return result\n\ndef rhs_upwind(phi, u, dx):\n    \"\"\"Computes the RHS for the first-order upwind scheme.\"\"\"\n    phi_im1 = np.roll(phi, 1)\n    # Assumes u > 0\n    return -u * (phi - phi_im1) / dx\n\ndef rhs_central(phi, u, dx):\n    \"\"\"Computes the RHS for the second-order central difference scheme.\"\"\"\n    phi_im1 = np.roll(phi, 1)\n    phi_ip1 = np.roll(phi, -1)\n    return -u * (phi_ip1 - phi_im1) / (2 * dx)\n\ndef rhs_muscl_mc(phi, u, dx):\n    \"\"\"Computes the RHS for the MUSCL scheme with MC limiter.\"\"\"\n    phi_im1 = np.roll(phi, 1)\n    phi_ip1 = np.roll(phi, -1)\n    \n    # Calculate limited differences delta_phi_i\n    # delta_phi_i = minmod(2*(phi_i - phi_{i-1}), (phi_{i+1} - phi_{i-1})/2, 2*(phi_{i+1} - phi_i))\n    dphi_L = phi - phi_im1\n    dphi_R = phi_ip1 - phi\n    dphi_C = (phi_ip1 - phi_im1) / 2.0\n    \n    delta_phi = vectorized_minmod([2*dphi_L, dphi_C, 2*dphi_R])\n    delta_phi_im1 = np.roll(delta_phi, 1)\n    \n    # Reconstructed values at interfaces (u > 0)\n    # F_{i-1/2} = u * (phi_{i-1} + 0.5 * delta_phi_{i-1})\n    # F_{i+1/2} = u * (phi_i + 0.5 * delta_phi_i)\n    flux_im1_2 = u * (phi_im1 + 0.5 * delta_phi_im1)\n    flux_ip1_2 = u * (phi + 0.5 * delta_phi)\n\n    return -(flux_ip1_2 - flux_im1_2) / dx\n\n\ndef run_simulation(N, CFL, T, epsilon, L, u, x0):\n    \"\"\"\n    Runs a single simulation case for all three schemes.\n    \"\"\"\n    dx = L / N\n    x = np.linspace(0, L, N, endpoint=False)\n    \n    # Initial condition\n    phi0 = 0.5 * (1 + np.tanh((x - x0) / epsilon))\n    \n    # Initialize solutions for each scheme\n    phi_upwind = phi0.copy()\n    phi_central = phi0.copy()\n    phi_muscl = phi0.copy()\n    \n    t = 0.0\n    dt_cfl = CFL * dx / abs(u)\n\n    while t  T:\n        dt = dt_cfl\n        if t + dt > T:\n            dt = T - t\n        \n        # --- SSP-RK3 for Upwind Scheme ---\n        L_n_upwind = rhs_upwind(phi_upwind, u, dx)\n        phi1_upwind = phi_upwind + dt * L_n_upwind\n        \n        L_1_upwind = rhs_upwind(phi1_upwind, u, dx)\n        phi2_upwind = 0.75 * phi_upwind + 0.25 * phi1_upwind + 0.25 * dt * L_1_upwind\n        \n        L_2_upwind = rhs_upwind(phi2_upwind, u, dx)\n        phi_upwind = (1/3) * phi_upwind + (2/3) * phi2_upwind + (2/3) * dt * L_2_upwind\n\n        # --- SSP-RK3 for Central Scheme ---\n        L_n_central = rhs_central(phi_central, u, dx)\n        phi1_central = phi_central + dt * L_n_central\n        \n        L_1_central = rhs_central(phi1_central, u, dx)\n        phi2_central = 0.75 * phi_central + 0.25 * phi1_central + 0.25 * dt * L_1_central\n        \n        L_2_central = rhs_central(phi2_central, u, dx)\n        phi_central = (1/3) * phi_central + (2/3) * phi2_central + (2/3) * dt * L_2_central\n        \n        # --- SSP-RK3 for MUSCL Scheme ---\n        L_n_muscl = rhs_muscl_mc(phi_muscl, u, dx)\n        phi1_muscl = phi_muscl + dt * L_n_muscl\n        \n        L_1_muscl = rhs_muscl_mc(phi1_muscl, u, dx)\n        phi2_muscl = 0.75 * phi_muscl + 0.25 * phi1_muscl + 0.25 * dt * L_1_muscl\n        \n        L_2_muscl = rhs_muscl_mc(phi2_muscl, u, dx)\n        phi_muscl = (1/3) * phi_muscl + (2/3) * phi2_muscl + (2/3) * dt * L_2_muscl\n\n        t += dt\n\n    # Exact solution\n    x_shifted = (x - u * T) % L\n    phi_exact = 0.5 * (1 + np.tanh((x_shifted - x0) / epsilon))\n\n    # Calculate metrics\n    def calculate_metrics(phi_num):\n        # L1 Error\n        error_L1 = dx * np.sum(np.abs(phi_num - phi_exact))\n        # Overshoot\n        overshoot = np.max(phi_num - 1.0)\n        undershoot = np.max(0.0 - phi_num)\n        bound_violation = np.max([overshoot, undershoot, 0.0])\n        return error_L1, bound_violation\n    \n    E_upwind, O_upwind = calculate_metrics(phi_upwind)\n    E_central, O_central = calculate_metrics(phi_central)\n    E_muscl, O_muscl = calculate_metrics(phi_muscl)\n    \n    return [E_upwind, E_central, E_muscl, O_upwind, O_central, O_muscl]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}