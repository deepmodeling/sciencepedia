{
    "hands_on_practices": [
        {
            "introduction": "This practice focuses on a crucial preparatory step in any radiation simulation: determining the local radiative properties of the participating medium. You will implement a procedure to calculate the single-scattering albedo, $\\omega_\\nu$, from the local temperature and species concentrations found in a combustion field. This exercise bridges the gap between fundamental species data and the spatially varying property fields required as input for a Photon Monte Carlo solver .",
            "id": "4049622",
            "problem": "Consider a monochromatic photon transport at frequency $\\nu$ within a Computational Fluid Dynamics (CFD) combustion domain, modeled using Photon Monte Carlo (PMC). At each spatial location $\\mathbf{x}$, the thermochemical state is represented by the temperature $T(\\mathbf{x})$ in kelvins and species mass fractions $Y_i(\\mathbf{x})$ for $i \\in \\{\\mathrm{CO_2}, \\mathrm{H_2O}, \\mathrm{N_2}, \\mathrm{soot}\\}$, with $\\sum_i Y_i(\\mathbf{x}) = 1$ and $Y_i(\\mathbf{x}) \\ge 0$. The objective is to compute the spatially varying single-scattering albedo $\\omega_\\nu(\\mathbf{x})$, defined as the fraction of the local extinction attributable to scattering, using measured surrogate closures for absorption and scattering.\n\nAssume the following scientifically plausible surrogate models for the monochromatic absorption and scattering coefficients per unit mass fraction for each species:\n- For absorption, for $i \\in \\{\\mathrm{CO_2}, \\mathrm{H_2O}, \\mathrm{N_2}, \\mathrm{soot}\\}$,\n$$\n\\kappa_{\\nu,i}(T) = a_i \\left(\\frac{T}{1000}\\right)^{p_i} \\quad \\text{with units } \\mathrm{m}^{-1} \\text{ per unit mass fraction}.\n$$\nUse constants\n$$\na_{\\mathrm{CO_2}}=0.5,\\; p_{\\mathrm{CO_2}}=1.2;\\quad\na_{\\mathrm{H_2O}}=0.7,\\; p_{\\mathrm{H_2O}}=1.1;\\quad\na_{\\mathrm{N_2}}=0.02,\\; p_{\\mathrm{N_2}}=1.0;\\quad\na_{\\mathrm{soot}}=1.5,\\; p_{\\mathrm{soot}}=0.9.\n$$\n- For scattering,\n$$\n\\sigma_{s,\\nu,\\mathrm{CO_2}}(T)=0,\\quad\n\\sigma_{s,\\nu,\\mathrm{H_2O}}(T)=0,\\quad\n\\sigma_{s,\\nu,\\mathrm{N_2}}(T)=b_{\\mathrm{N_2}}\\left(\\frac{1000}{T}\\right),\\quad\n\\sigma_{s,\\nu,\\mathrm{soot}}(T)=b_{\\mathrm{soot}}\\left(\\frac{T}{1500}\\right),\n$$\nwith constants $b_{\\mathrm{N_2}}=0.003$ and $b_{\\mathrm{soot}}=2.5$, in $\\mathrm{m}^{-1}$ per unit mass fraction.\n\nGiven a mixture with state $(T,Y)$ at a point, define the mixture absorption and scattering coefficients as mass-fraction-weighted sums:\n$$\n\\kappa_\\nu(T,Y) = \\sum_{i} Y_i \\,\\kappa_{\\nu,i}(T), \\qquad\n\\sigma_{s,\\nu}(T,Y) = \\sum_{i} Y_i \\,\\sigma_{s,\\nu,i}(T).\n$$\nDefine the extinction coefficient by\n$$\n\\beta_\\nu(T,Y) = \\kappa_\\nu(T,Y) + \\sigma_{s,\\nu}(T,Y).\n$$\nDefine the single-scattering albedo $\\omega_\\nu(T,Y)$ as the dimensionless ratio of scattering contribution to the total extinction. For numerical stability, use the convention\n$$\n\\omega_\\nu(T,Y) =\n\\begin{cases}\n0, & \\text{if } \\beta_\\nu(T,Y) < \\varepsilon,\\\\\n\\dfrac{\\sigma_{s,\\nu}(T,Y)}{\\beta_\\nu(T,Y)}, & \\text{otherwise},\n\\end{cases}\n$$\nwith $\\varepsilon = 10^{-12}\\ \\mathrm{m}^{-1}$.\n\nImplement a program that, for each test case below, computes $\\omega_\\nu$ using the above definitions. Before computing, enforce the constraints $Y_i \\ge 0$ and $\\sum_i Y_i = 1$ by clamping any negative $Y_i$ to $0$ and renormalizing the vector $Y$ by its sum (if the sum is strictly positive); if the sum is zero after clamping, set $\\omega_\\nu=0$ by convention.\n\nPhysical and numerical units:\n- Temperature $T$ must be in kelvins.\n- $\\kappa_\\nu$ and $\\sigma_{s,\\nu}$ are in $\\mathrm{m}^{-1}$.\n- $\\omega_\\nu$ is dimensionless and must be reported as decimal numbers rounded to six digits after the decimal point.\n\nTest suite (each case is a single spatial location):\n1. $T=1800$, $Y_{\\mathrm{CO_2}}=0.12$, $Y_{\\mathrm{H_2O}}=0.18$, $Y_{\\mathrm{N_2}}=0.70$, $Y_{\\mathrm{soot}}=0.00$.\n2. $T=2000$, $Y_{\\mathrm{CO_2}}=0.10$, $Y_{\\mathrm{H_2O}}=0.15$, $Y_{\\mathrm{N_2}}=0.73$, $Y_{\\mathrm{soot}}=0.02$.\n3. $T=300$, $Y_{\\mathrm{CO_2}}=0.00$, $Y_{\\mathrm{H_2O}}=0.00$, $Y_{\\mathrm{N_2}}=0.999$, $Y_{\\mathrm{soot}}=0.001$.\n4. $T=800$, $Y_{\\mathrm{CO_2}}=0.05$, $Y_{\\mathrm{H_2O}}=0.10$, $Y_{\\mathrm{N_2}}=0.84$, $Y_{\\mathrm{soot}}=0.01$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite above, for example \"[result1,result2,result3,result4]\". Each result must be $\\omega_\\nu$ for the corresponding case, rounded to six digits after the decimal point, with no units.",
            "solution": "The problem requires the calculation of the monochromatic single-scattering albedo, denoted as $\\omega_\\nu$, at specific spatial locations within a combustion environment. The calculation is based on provided surrogate models for the absorption and scattering properties of the constituent gas and soot species. The thermochemical state at each location is defined by the temperature $T$ and the mass fractions $Y_i$ of the species $i \\in \\{\\mathrm{CO_2}, \\mathrm{H_2O}, \\mathrm{N_2}, \\mathrm{soot}\\}$.\n\nThe single-scattering albedo $\\omega_\\nu$ is a dimensionless quantity representing the fraction of total extinction that is due to scattering. It is defined as:\n$$\n\\omega_\\nu = \\frac{\\sigma_{s,\\nu}}{\\beta_\\nu}\n$$\nwhere $\\sigma_{s,\\nu}$ is the mixture scattering coefficient and $\\beta_\\nu$ is the mixture extinction coefficient. The extinction coefficient is the sum of the mixture absorption coefficient $\\kappa_\\nu$ and the mixture scattering coefficient $\\sigma_{s,\\nu}$:\n$$\n\\beta_\\nu(T,Y) = \\kappa_\\nu(T,Y) + \\sigma_{s,\\nu}(T,Y)\n$$\nThe problem provides a numerical stability condition: if $\\beta_\\nu < \\varepsilon$ where $\\varepsilon = 10^{-12}\\ \\mathrm{m}^{-1}$, the albedo $\\omega_\\nu$ is taken to be $0$.\n\nThe mixture coefficients are determined by mass-fraction-weighted sums of the individual species' coefficients:\n$$\n\\kappa_\\nu(T,Y) = \\sum_{i} Y_i \\,\\kappa_{\\nu,i}(T)\n$$\n$$\n\\sigma_{s,\\nu}(T,Y) = \\sum_{i} Y_i \\,\\sigma_{s,\\nu,i}(T)\n$$\nBefore these calculations, the vector of mass fractions $Y$ must be sanitized. Any negative component $Y_i$ is clamped to $0$, and if the sum of the components is positive, the vector is normalized to ensure its components sum to $1$. If the sum of the clamped mass fractions is zero, $\\omega_\\nu$ is set to $0$ by convention.\n\nThe species-specific coefficients are given by surrogate models dependent on temperature $T$.\n\nThe absorption coefficient for species $i$ is modeled as:\n$$\n\\kappa_{\\nu,i}(T) = a_i \\left(\\frac{T}{1000}\\right)^{p_i} \\quad [\\mathrm{m}^{-1} \\text{ per unit mass fraction}]\n$$\nwith constants $(a_i, p_i)$ provided for $\\mathrm{CO_2}$, $\\mathrm{H_2O}$, $\\mathrm{N_2}$, and soot. Specifically:\n- $i=\\mathrm{CO_2}$: $a_{\\mathrm{CO_2}}=0.5$, $p_{\\mathrm{CO_2}}=1.2$\n- $i=\\mathrm{H_2O}$: $a_{\\mathrm{H_2O}}=0.7$, $p_{\\mathrm{H_2O}}=1.1$\n- $i=\\mathrm{N_2}$: $a_{\\mathrm{N_2}}=0.02$, $p_{\\mathrm{N_2}}=1.0$\n- $i=\\mathrm{soot}$: $a_{\\mathrm{soot}}=1.5$, $p_{\\mathrm{soot}}=0.9$\n\nThe scattering coefficients for each species are:\n$$\n\\sigma_{s,\\nu,\\mathrm{CO_2}}(T)=0 \\quad [\\mathrm{m}^{-1} \\text{ per unit mass fraction}]\n$$\n$$\n\\sigma_{s,\\nu,\\mathrm{H_2O}}(T)=0 \\quad [\\mathrm{m}^{-1} \\text{ per unit mass fraction}]\n$$\n$$\n\\sigma_{s,\\nu,\\mathrm{N_2}}(T)=b_{\\mathrm{N_2}}\\left(\\frac{1000}{T}\\right) \\quad [\\mathrm{m}^{-1} \\text{ per unit mass fraction}], \\text{ with } b_{\\mathrm{N_2}}=0.003\n$$\n$$\n\\sigma_{s,\\nu,\\mathrm{soot}}(T)=b_{\\mathrm{soot}}\\left(\\frac{T}{1500}\\right) \\quad [\\mathrm{m}^{-1} \\text{ per unit mass fraction}], \\text{ with } b_{\\mathrm{soot}}=2.5\n$$\n\nThe solution is implemented by first defining a function that takes a given state $(T, Y)$ and computes $\\omega_\\nu$. This function follows these steps:\n1.  Receive the temperature $T$ in kelvins and a list or tuple of mass fractions $Y = (Y_{\\mathrm{CO_2}}, Y_{\\mathrm{H_2O}}, Y_{\\mathrm{N_2}}, Y_{\\mathrm{soot}})$.\n2.  Apply the specified pre-processing to the mass fractions $Y$: clamp negative values to $0$ and re-normalize the vector to sum to $1$ if its sum is positive. Handle the zero-sum case as specified.\n3.  Calculate the four species-specific absorption coefficients $\\kappa_{\\nu,i}(T)$ using the temperature $T$ and the provided formulas and constants.\n4.  Calculate the four species-specific scattering coefficients $\\sigma_{s,\\nu,i}(T)$. Note that for $\\mathrm{CO_2}$ and $\\mathrm{H_2O}$, these are $0$.\n5.  Compute the mixture absorption coefficient $\\kappa_\\nu$ by taking the dot product of the normalized mass fraction vector and the vector of species absorption coefficients.\n6.  Compute the mixture scattering coefficient $\\sigma_{s,\\nu}$ similarly.\n7.  Calculate the total extinction coefficient $\\beta_\\nu = \\kappa_\\nu + \\sigma_{s,\\nu}$.\n8.  Apply the stability check: if $\\beta_\\nu < 10^{-12}$, set $\\omega_\\nu=0$. Otherwise, compute $\\omega_\\nu = \\sigma_{s,\\nu} / \\beta_\\nu$.\n9.  Return the calculated value of $\\omega_\\nu$.\n\nThis procedure is applied to each test case specified in the problem statement. The resulting values of $\\omega_\\nu$ are then rounded to six decimal places and formatted into the required output string.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It calculates the single-scattering albedo for each case and prints the results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (T, (Y_CO2, Y_H2O, Y_N2, Y_soot))\n    test_cases = [\n        (1800, (0.12, 0.18, 0.70, 0.00)),\n        (2000, (0.10, 0.15, 0.73, 0.02)),\n        (300, (0.00, 0.00, 0.999, 0.001)),\n        (800, (0.05, 0.10, 0.84, 0.01)),\n    ]\n\n    # Constants for the surrogate models\n    # Species order: CO2, H2O, N2, soot\n    species = ['CO2', 'H2O', 'N2', 'soot']\n    \n    # Absorption coefficients constants\n    a = np.array([0.5, 0.7, 0.02, 1.5])  # a_i\n    p = np.array([1.2, 1.1, 1.0, 0.9])  # p_i\n\n    # Scattering coefficients constants\n    b_N2 = 0.003\n    b_soot = 2.5\n    \n    # Numerical stability threshold\n    epsilon = 1e-12\n\n    results = []\n    for T, Y in test_cases:\n        omega = calculate_omega(T, Y, species, a, p, b_N2, b_soot, epsilon)\n        results.append(f\"{omega:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_omega(T, Y, species, a, p, b_N2, b_soot, epsilon):\n    \"\"\"\n    Computes the single-scattering albedo for a given thermochemical state.\n\n    Args:\n        T (float): Temperature in Kelvin.\n        Y (tuple): Tuple of mass fractions for (CO2, H2O, N2, soot).\n        species (list): List of species names.\n        a (np.ndarray): Array of absorption constants a_i.\n        p (np.ndarray): Array of absorption constants p_i.\n        b_N2 (float): Scattering constant for N2.\n        b_soot (float): Scattering constant for soot.\n        epsilon (float): Threshold for numerical stability.\n\n    Returns:\n        float: The calculated single-scattering albedo, omega_nu.\n    \"\"\"\n    \n    Y_arr = np.array(Y, dtype=float)\n\n    # Step 1: Pre-process mass fractions\n    Y_clamped = np.maximum(Y_arr, 0.0)\n    Y_sum = np.sum(Y_clamped)\n    \n    if Y_sum <= 0.0:\n        return 0.0\n        \n    Y_norm = Y_clamped / Y_sum\n\n    # Step 2: Calculate species-specific absorption coefficients\n    kappa_i = a * (T / 1000.0)**p\n\n    # Step 3: Calculate species-specific scattering coefficients\n    sigma_i = np.zeros_like(Y_arr)\n    idx_N2 = species.index('N2')\n    idx_soot = species.index('soot')\n    \n    if T > 0: # Avoid division by zero if T=0\n        sigma_i[idx_N2] = b_N2 * (1000.0 / T)\n\n    sigma_i[idx_soot] = b_soot * (T / 1500.0)\n\n    # Step 4: Compute mixture coefficients\n    kappa_mix = np.dot(Y_norm, kappa_i)\n    sigma_mix = np.dot(Y_norm, sigma_i)\n\n    # Step 5: Compute extinction coefficient and albedo\n    beta_mix = kappa_mix + sigma_mix\n    \n    if beta_mix < epsilon:\n        omega = 0.0\n    else:\n        omega = sigma_mix / beta_mix\n        \n    return omega\n\nsolve()\n```"
        },
        {
            "introduction": "Efficiently simulating a photon's path through a spatially non-uniform medium is a core challenge in Monte Carlo modeling. This exercise introduces the powerful delta-tracking (or null-collision) method, which simplifies path sampling by treating the medium as homogeneous with a majorant extinction coefficient, $\\beta^*$. By implementing this algorithm, you will gain hands-on experience with a foundational technique that makes Photon Monte Carlo simulations of complex, realistic environments computationally tractable .",
            "id": "4049528",
            "problem": "Consider a one-dimensional slab of thickness $L$ with spatially varying extinction coefficient $\\beta(x)$ (units $\\mathrm{m}^{-1}$). A photon is launched at position $x=0$ and travels in the $+x$ direction through the slab. The boundary at $x=L$ is vacuum, so if the photon reaches $x=L$ without being absorbed, it escapes. Absorption is the only real interaction; scattering and emission are neglected. The objective is to construct and apply a delta-tracking (null-collision) algorithm to sample free paths and interaction events when $\\beta(x)$ varies spatially.\n\nDelta-tracking uses a constant majorant $\\beta^*$ (units $\\mathrm{m}^{-1}$), chosen such that $\\beta(x) \\le \\beta^*$ for all $x \\in [0,L]$. Proposed free-path lengths $s$ are sampled from the exponential distribution with rate $\\beta^*$, that is, with probability density function $f(s) = \\beta^* \\exp(-\\beta^* s)$ for $s \\ge 0$. Upon advancing to the proposed interaction location, the event is accepted as a real absorption with probability $\\beta(x)/\\beta^*$, and otherwise treated as a null-collision with no physical effect. The process repeats until the photon escapes or is absorbed.\n\nStarting from first principles of the Radiative Transfer Equation (RTE) and the definition of the inhomogeneous Poisson process for extinction, derive a principled algorithmic rationale for the delta-tracking acceptance-rejection procedure described above, ensuring that the distribution of real interaction locations is consistent with the true spatial rate $\\beta(x)$. Then implement the algorithm and estimate the slab transmittance, defined as the probability that a launched photon escapes at $x=L$ without ever experiencing a real absorption. Use $N$ independent photon histories for each test case and a fixed random number generator seed to ensure reproducibility. Express transmittance as a dimensionless number. Also compute the mean number of null-collisions per launched photon as a dimensionless quantity.\n\nThe analytic reference for the transmittance is given by the inhomogeneous Beerâ€“Lambert law, which states that the transmittance equals $\\exp\\!\\left( - \\int_0^L \\beta(x) \\, dx \\right)$. You must compare your Monte Carlo estimate against this analytic value by reporting the absolute error (dimensionless). For numerical reproducibility, use $N = 100000$ photon histories and a fixed seed $12345$ for the random number generator.\n\nImplement your program to handle the following test suite, each specified in meters for $L$ and in inverse meters for $\\beta(x)$ and $\\beta^*$:\n\n- Test case $1$: $L=0.5\\,\\mathrm{m}$, $\\beta(x)=1.0\\,\\mathrm{m}^{-1}$ for all $x$, $\\beta^*=1.0\\,\\mathrm{m}^{-1}$.\n- Test case $2$: $L=1.0\\,\\mathrm{m}$, $\\beta(x)=0.5 + 0.5 x\\,\\mathrm{m}^{-1}$, $\\beta^*=1.0\\,\\mathrm{m}^{-1}$.\n- Test case $3$: $L=0.8\\,\\mathrm{m}$, $\\beta(x)=\\begin{cases} 0\\,\\mathrm{m}^{-1}, & 0 \\le x < 0.3\\,\\mathrm{m}, \\\\ 3.0\\,\\mathrm{m}^{-1}, & 0.3\\,\\mathrm{m} \\le x < 0.5\\,\\mathrm{m}, \\\\ 0.2\\,\\mathrm{m}^{-1}, & 0.5\\,\\mathrm{m} \\le x \\le 0.8\\,\\mathrm{m}, \\end{cases}$ with $\\beta^*=3.0\\,\\mathrm{m}^{-1}$.\n- Test case $4$: $L=1.0\\,\\mathrm{m}$, $\\beta(x)=0.8 + 0.3 \\sin\\!\\left( 2\\pi x / L \\right)\\,\\mathrm{m}^{-1}$, $\\beta^*=1.1\\,\\mathrm{m}^{-1}$.\n\nFor each test case, compute:\n- The Monte Carlo estimate of the transmittance (dimensionless).\n- The absolute error between the Monte Carlo estimate and the analytic transmittance $\\exp\\!\\left( - \\int_0^L \\beta(x) \\, dx \\right)$ (dimensionless).\n- The mean number of null-collisions per launched photon (dimensionless).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[T_1,\\mathrm{err}_1,\\bar{n}_{\\mathrm{null},1},T_2,\\mathrm{err}_2,\\bar{n}_{\\mathrm{null},2},T_3,\\mathrm{err}_3,\\bar{n}_{\\mathrm{null},3},T_4,\\mathrm{err}_4,\\bar{n}_{\\mathrm{null},4}]$, where $T_i$ denotes the Monte Carlo transmittance estimate, $\\mathrm{err}_i$ denotes the absolute error relative to the analytic value, and $\\bar{n}_{\\mathrm{null},i}$ denotes the mean number of null-collisions per launched photon for test case $i$.",
            "solution": "The problem requires the derivation and implementation of a delta-tracking (null-collision) Monte Carlo algorithm to simulate photon transport in a one-dimensional slab with a spatially varying absorption coefficient. The goal is to estimate the slab's transmittance and the mean number of null-collisions, and compare the transmittance with the analytical solution.\n\n### Part 1: Principled Derivation of the Delta-Tracking Algorithm\n\n#### 1.1. Physical and Mathematical Foundation: The Radiative Transfer Equation (RTE)\n\nThe fundamental equation governing the transport of radiation through a medium is the Radiative Transfer Equation (RTE). For a one-dimensional, non-emitting, non-scattering (purely absorbing) medium, the change in radiation intensity $I$ along a path in the $+x$ direction is described by:\n$$\n\\frac{dI(x)}{dx} = -\\beta(x) I(x)\n$$\nwhere $\\beta(x)$ is the spatially dependent absorption coefficient in units of $\\mathrm{m}^{-1}$. The term $\\beta(x)$ represents the probability per unit path length of a photon being absorbed at position $x$.\n\n#### 1.2. Probabilistic Interpretation and the Standard Monte Carlo Approach\n\nIntegrating the RTE from $x=0$ to a position $x=s$ yields the solution:\n$$\nI(s) = I(0) \\exp\\left(-\\int_0^s \\beta(x') \\, dx'\\right)\n$$\nThe term $\\exp\\left(-\\int_0^s \\beta(x') \\, dx'\\right)$ is the probability that a photon starting at $x=0$ will travel at least a distance $s$ without being absorbed. This is the survival probability. The integral $\\tau(s) = \\int_0^s \\beta(x') \\, dx'$ is the optical thickness of the path.\n\nThe probability density function (PDF) for the location of the *first* interaction, $p(s)$, can be found by considering the probability of surviving to $s$ and then interacting in the infinitesimal interval $[s, s+ds]$. This is given by:\n$$\np(s) = \\beta(s) \\exp\\left(-\\int_0^s \\beta(x') \\, dx'\\right)\n$$\nTo simulate photon transport directly, one must sample a free path length $s$ from this PDF. This is typically achieved using the inverse transform sampling method. The cumulative distribution function (CDF) is:\n$$\nF(s) = \\int_0^s p(x') \\, dx' = 1 - \\exp\\left(-\\int_0^s \\beta(x') \\, dx'\\right)\n$$\nTo sample $s$, we set $F(s) = U$, where $U$ is a uniform random number in $[0, 1)$, and solve for $s$:\n$$\n\\int_0^s \\beta(x') \\, dx' = -\\ln(1-U)\n$$\nSolving this integral equation for $s$ can be computationally expensive or analytically intractable if $\\beta(x)$ is a complex function, making direct simulation inefficient.\n\n#### 1.3. The Delta-Tracking (Null-Collision) Method\n\nThe delta-tracking method reformulates the problem to avoid the direct inversion of the CDF. It introduces a fictitious \"null-collision\" process. A constant majorant extinction coefficient, $\\beta^*$, is chosen such that $\\beta(x) \\le \\beta^*$ for all $x$ in the domain of interest.\n\nThe physical system is conceptually modified by adding and subtracting a \"null\" coefficient, $\\beta_{\\text{null}}(x) = \\beta^* - \\beta(x)$, to the RTE. The total interaction coefficient becomes $\\beta(x) + \\beta_{\\text{null}}(x) = \\beta^*$, which is constant. The modified RTE can be interpreted as:\n$$\n\\frac{dI(x)}{dx} = -\\beta^* I(x) + (\\beta^* - \\beta(x)) I(x)\n$$\nThis describes a transport process where photons interact with the medium with a constant total probability per unit length $\\beta^*$. An interaction event can either be a \"real\" absorption (with rate $\\beta(x)$) or a \"null\" collision (with rate $\\beta^* - \\beta(x)$), which does not affect the photon's state (it is equivalent to perfect forward scattering).\n\nUnder this new formulation, the medium is homogeneous with a constant extinction coefficient $\\beta^*$. The PDF for the free path length $s$ to the *next tentative interaction* is now a simple exponential distribution:\n$$\nf(s) = \\beta^* \\exp(-\\beta^* s)\n$$\nA path length $s$ can be easily sampled from this distribution using inverse transform sampling:\n$$\ns = -\\frac{1}{\\beta^*} \\ln(U)\n$$\nwhere $U$ is a uniform random number in $(0, 1)$.\n\n#### 1.4. The Acceptance-Rejection Step\n\nAfter advancing a photon by a distance $s$ to a new position $x$, we must determine whether the tentative interaction is a real absorption or a null collision. The principle of this step is rooted in the theory of thinning Poisson processes. An inhomogeneous Poisson process with rate $\\lambda(t)$ can be simulated by generating events from a homogeneous Poisson process with a majorant rate $\\lambda^* \\ge \\lambda(t)$ and accepting each event with probability $\\lambda(t)/\\lambda^*$.\n\nIn our context, the path length $x$ is the process variable, the real interaction rate is $\\beta(x)$, and the majorant rate is $\\beta^*$. At the interaction site $x$, the conditional probability that the event is a real absorption is the ratio of the real absorption rate to the total interaction rate:\n$$\nP(\\text{real} | \\text{interaction at } x) = \\frac{\\beta(x)}{\\beta^*}\n$$\nThis leads to the following acceptance-rejection procedure:\n1.  Sample a tentative path length $s = -\\ln(U_1)/\\beta^*$.\n2.  Advance the photon to the proposed interaction site $x' = x_{\\text{old}} + s$.\n3.  If the photon escapes the medium ($x' \\ge L$), the history is terminated.\n4.  If the interaction occurs within the medium ($x' < L$), generate a second uniform random number $U_2$.\n5.  If $U_2 < \\beta(x')/\\beta^*$, the interaction is accepted as a **real absorption**. The photon's history is terminated.\n6.  If $U_2 \\ge \\beta(x')/\\beta^*$, the interaction is a **null collision**. The photon's state is unchanged, and its simulation continues from position $x'$, repeating from step 1.\n\nThis algorithm correctly simulates the original physical process because the effective rate of real interactions at any point $x$ is the rate of tentative interactions ($\\beta^*$) multiplied by the probability of acceptance ($\\beta(x)/\\beta^*$), which equals $\\beta(x)$, the true physical rate.\n\n### Part 2: Algorithmic Implementation\n\nThe Monte Carlo simulation is implemented by tracing a large number $N$ of individual photon histories according to the delta-tracking algorithm.\n\n1.  **Initialization**: For each test case defined by $L$, $\\beta(x)$, and $\\beta^*$, we initialize counters for transmitted photons and total null-collisions to zero.\n2.  **Photon Loop**: For each of the $N$ photons:\n    a.  Initialize the photon's position $x=0.0$ and its state as 'alive'.\n    b.  Initialize a counter for null collisions for this specific photon.\n    c.  **Tracking Loop**: While the photon is alive:\n        i.   Sample a tentative free path length $s$ from the exponential distribution with rate $\\beta^*$.\n        ii.  Calculate the new proposed position $x' = x + s$.\n        iii. If $x' \\ge L$, the photon escapes. Increment the transmitted photon counter, update the total null-collision count, and terminate this photon's history.\n        iv. If $x' < L$, move the photon to this new position $x = x'$.\n        v.  Perform the acceptance-rejection test: Generate a random number $U$ and compare it to the ratio $\\beta(x)/\\beta^*$.\n        vi. If the collision is real (absorption), terminate this photon's history after updating the total null-collision count.\n        vii. If the collision is null, increment the null-collision counter for this photon and continue the tracking loop from its current position $x$.\n3.  **Result Calculation**: After all $N$ histories are completed:\n    a.  The Monte Carlo transmittance estimate is $T_{\\text{MC}} = (\\text{number of transmitted photons}) / N$.\n    b.  The mean number of null-collisions is $\\bar{n}_{\\text{null}} = (\\text{total null-collisions}) / N$.\n    c.  The analytic transmittance is calculated as $T_{\\text{analytic}} = \\exp\\left(-\\int_0^L \\beta(x) \\, dx\\right)$. The integral (optical thickness) is computed numerically using `scipy.integrate.quad`.\n    d.  The absolute error is computed as $\\mathrm{err} = |T_{\\text{MC}} - T_{\\text{analytic}}|$.\n4.  **Output**: The calculated values $(T_{\\text{MC}}, \\mathrm{err}, \\bar{n}_{\\text{null}})$ for all test cases are collected and formatted into a single output line as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Implements a delta-tracking Monte Carlo simulation for 1D photon transport,\n    computes transmittance, error, and mean null-collisions for specified test cases.\n    \"\"\"\n    # Global simulation parameters\n    N_PHOTONS = 100000\n    SEED = 12345\n    rng = np.random.default_rng(SEED)\n\n    # Test case definitions\n    def beta_1(x):\n        return 1.0\n\n    def beta_2(x):\n        return 0.5 + 0.5 * x\n\n    def beta_3(x):\n        if 0.3 <= x < 0.5:\n            return 3.0\n        elif 0.5 <= x <= 0.8:\n            return 0.2\n        else:\n            return 0.0\n    \n    # For case 4, L=1.0 is used in the sin term as specified in the problem\n    def beta_4(x):\n        return 0.8 + 0.3 * np.sin(2.0 * np.pi * x / 1.0)\n    \n    test_cases = [\n        {'L': 0.5, 'beta_func': beta_1, 'beta_star': 1.0},\n        {'L': 1.0, 'beta_func': beta_2, 'beta_star': 1.0},\n        {'L': 0.8, 'beta_func': beta_3, 'beta_star': 3.0},\n        {'L': 1.0, 'beta_func': beta_4, 'beta_star': 1.1},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        L = case['L']\n        beta_func = case['beta_func']\n        beta_star = case['beta_star']\n\n        # Monte Carlo Simulation\n        transmitted_count = 0\n        total_null_collisions = 0\n\n        for _ in range(N_PHOTONS):\n            x = 0.0\n            photon_alive = True\n            num_null_this_photon = 0\n\n            while photon_alive:\n                # Sample distance to next tentative collision from the homogeneous medium\n                s = -np.log(rng.random()) / beta_star\n                \n                # New proposed position\n                x_new = x + s\n\n                if x_new >= L:\n                    # Photon escapes the slab (is transmitted)\n                    transmitted_count += 1\n                    photon_alive = False\n                else:\n                    # An interaction occurs within the slab\n                    x = x_new\n                    \n                    # Acceptance-rejection to determine if it is a real or null collision\n                    prob_real = beta_func(x) / beta_star\n                    if rng.random() < prob_real:\n                        # Real collision (absorption)\n                        photon_alive = False\n                    else:\n                        # Null collision\n                        num_null_this_photon += 1\n            \n            # Add this photon's null collision count to the total\n            total_null_collisions += num_null_this_photon\n\n        # Calculate Monte Carlo results statistics\n        T_mc = transmitted_count / N_PHOTONS\n        mean_null_collisions = total_null_collisions / N_PHOTONS\n\n        # Calculate analytic transmittance for error comparison\n        # The integral of beta(x) is the optical thickness\n        optical_thickness, _ = quad(beta_func, 0, L)\n        T_analytic = np.exp(-optical_thickness)\n\n        # Calculate absolute error\n        error = abs(T_mc - T_analytic)\n\n        # Store results for this case\n        all_results.extend([T_mc, error, mean_null_collisions])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A robust numerical simulation must not only produce results but also demonstrably respect fundamental physical laws. This practice guides you through a classic verification test: confirming that your Monte Carlo simulation upholds the principle of detailed balance in a system at local thermodynamic equilibrium (LTE). By simulating a periodic, isothermal domain and tallying emission and absorption events, you will verify that the net radiative source in each cell is statistically zero, building confidence in the physical accuracy of your implementation .",
            "id": "4049551",
            "problem": "Consider a one-dimensional periodic slab representing a homogeneous combustion gas volume in local thermodynamic equilibrium (LTE). The slab has length $L$ in meters, is discretized into $N$ equal cells of width $\\Delta x=L/N$, and has a spatially piecewise-constant absorption coefficient $\\kappa(x)$ in inverse meters. Under LTE, the Radiative Transfer Equation (RTE) for spectral intensity $I$ along a path coordinate $s$ is $\\mathrm{d}I/\\mathrm{d}s = -\\kappa I + j$, where the emission coefficient $j$ satisfies $j=\\kappa B$ with $B$ the Planck function at the local temperature $T$ (assumed uniform across the slab). Radiative equilibrium requires that the rate of emission equals the rate of absorption in each cell, so that the net radiative source is zero per cell.\n\nThe Monte Carlo photon packet method is to be used to verify energy conservation, reciprocity, and detailed balance. Each photon packet carries unit energy, is emitted isotropically along the slab axis with equal probability of traveling in the $+x$ or $-x$ direction, and has its emission position uniformly distributed within the chosen source cell. The emission cell index is sampled from the discrete distribution proportional to $\\kappa_i V_i$, where $\\kappa_i$ is the absorption coefficient of cell $i$ and $V_i$ is the cell volume (in this one-dimensional slab, $V_i \\propto \\Delta x$, so $\\kappa_i V_i \\propto \\kappa_i$). The packet free-flight optical depth $\\tau$ to absorption is sampled from the exponential distribution $p(\\tau)=e^{-\\tau}$, with $\\tau=-\\ln(u)$ for $u \\sim \\mathcal{U}(0,1)$. As the packet propagates, the remaining optical depth is reduced by $\\kappa(x)\\,\\mathrm{d}x$ traversed within each cell, and the absorption event occurs within the cell where the remaining optical depth is exhausted. Periodic boundary conditions are enforced, so that a packet exiting at $x=L$ re-enters at $x=0$, and a packet exiting at $x=0$ re-enters at $x=L$.\n\nStarting from the fundamental base of the LTE RTE $\\mathrm{d}I/\\mathrm{d}s = -\\kappa I + \\kappa B$ and the isotropic blackbody solution $I=B$ in a spatially periodic, uniform-temperature medium, it follows that the expected absorption per cell equals the expected emission per cell, namely $\\langle A_i \\rangle = \\langle E_i \\rangle = \\kappa_i \\, 4 \\pi B \\, V_i$ (up to a constant factor that is absorbed by the photon packet unit energy normalization). Reciprocity implies that, in the absence of anisotropic scattering, reversing the direction of travel of any path leaves the distribution of absorption events invariant. Energy conservation requires that the total number of absorbed packets equals the total number of emitted packets.\n\nYour task is to implement a complete, reproducible Monte Carlo program that:\n- Emits photon packets from cells with probability proportional to $\\kappa_i$.\n- Samples isotropic directions in $\\pm x$ with equal probability and uniformly distributed emission positions within the source cell.\n- Samples an absorption optical depth $\\tau$ from $p(\\tau)=e^{-\\tau}$ and propagates the packet across cells, enforcing periodic boundaries, until absorption occurs.\n- Tallies per-cell emission counts $E_i$ and absorption counts $A_i$.\n- Verifies detailed balance locally by checking that the maximum per-cell relative difference $\\max_i |\\left(A_i - E_i \\right)|/\\max\\left(E_i, 1 \\right)$ does not exceed a tolerance $\\epsilon$.\n- Verifies global energy conservation by checking $|\\sum_i A_i - \\sum_i E_i|=0$.\n\nAngles, if any are referenced, must be interpreted in radians, although the algorithm only requires discrete direction sampling in $\\pm x$ without explicit angle values.\n\nUse the following test suite with specified parameters and physical units, and produce results as booleans indicating whether both local detailed balance and global energy conservation pass for each case:\n- Test case $1$ (happy path, uniform medium): $N=10$, $L=1$ meter, $\\kappa_i=2.0$ meter$^{-1}$ for all $i$, $T=1500$ Kelvin, number of packets $N_p=50000$, tolerance $\\epsilon=0.03$, random seed $123$.\n- Test case $2$ (optically thick boundary condition): $N=10$, $L=1$ meter, $\\kappa_i=100.0$ meter$^{-1}$ for all $i$, $T=1500$ Kelvin, number of packets $N_p=50000$, tolerance $\\epsilon=0.03$, random seed $456$.\n- Test case $3$ (heterogeneous medium reciprocity check): $N=10$, $L=1$ meter, $\\kappa_i=0.5$ meter$^{-1}$ for cells $i=0,1,2,3,4$, $\\kappa_i=2.0$ meter$^{-1}$ for cells $i=5,6,7,8,9$, $T=1500$ Kelvin, number of packets $N_p=50000$, tolerance $\\epsilon=0.03$, random seed $789$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result1},\\text{result2},\\text{result3}]$), where each result is a boolean indicating the combined pass for local detailed balance and global energy conservation in the corresponding test case.",
            "solution": "The problem statement is assessed to be valid. It presents a well-posed, scientifically grounded problem in the field of computational radiative transfer. All necessary parameters, physical principles, and numerical procedures are clearly and correctly defined. The task is to implement a standard Photon Monte Carlo (PMC) simulation for a one-dimensional, periodic, isothermal, participating medium to verify the principles of global energy conservation and local detailed balance, which are fundamental consequences of radiative equilibrium in such a system.\n\nThe core of the solution is a PMC algorithm that simulates the life cycle of a large number of energy packets (photons). The simulation domain is a slab of length $L$ discretized into $N$ uniform cells of width $\\Delta x = L/N$. Each cell $i$ is characterized by a constant absorption coefficient $\\kappa_i$.\n\nThe simulation proceeds by tracing $N_p$ individual photon packets from emission to absorption. For each packet, the following steps are executed:\n\n1.  **Emission:** The emission process is modeled based on the principles of Local Thermodynamic Equilibrium (LTE).\n    -   **Source Cell Selection:** The probability of a packet being emitted from cell $i$ is proportional to the total emission from that cell. In LTE, the spectral emission coefficient is $j = \\kappa B$, where $B$ is the Planck function. For a uniform temperature $T$, $B$ is constant throughout the slab. The total emission from cell $i$ is proportional to $\\kappa_i V_i$, where $V_i$ is the cell volume. In this one-dimensional problem, $V_i$ is proportional to the cell width $\\Delta x$, which is constant. Therefore, the probability of emission from cell $i$, $P(i)$, is given by:\n        $$\n        P(i) = \\frac{\\kappa_i}{\\sum_{j=0}^{N-1} \\kappa_j}\n        $$\n        A source cell, with index $i_{\\text{emit}}$, is sampled from this discrete probability distribution. The emission counter for this cell, $E_{i_{\\text{emit}}}$, is then incremented.\n    -   **Position and Direction:** The emission position $x_{\\text{emit}}$ is sampled from a uniform distribution within the boundaries of the source cell, $[i_{\\text{emit}}\\Delta x, (i_{\\text{emit}}+1)\\Delta x]$. The direction of travel is isotropic along the one-dimensional axis, meaning the packet has an equal probability of traveling in the $+x$ or $-x$ direction. A direction variable, $d \\in \\{-1, 1\\}$, is sampled accordingly.\n\n2.  **Absorption Path Sampling:** The optical distance, or optical depth $\\tau$, that a packet travels before being absorbed is a random variable. In a participating medium, the probability of a packet being absorbed after traversing an optical depth $\\tau$ follows an exponential distribution, $p(\\tau) = e^{-\\tau}$. This is sampled efficiently using the inverse transform method. A random number $u$ is drawn from a uniform distribution $\\mathcal{U}(0,1)$, and the optical depth to absorption is calculated as:\n    $$\n    \\tau_{\\text{abs}} = -\\ln(u)\n    $$\n    This sampled $\\tau_{\\text{abs}}$ represents the total optical path length the packet must travel before it is absorbed.\n\n3.  **Propagation and Absorption:** The packet is traced cell-by-cell from its emission point until its accumulated optical path equals $\\tau_{\\text{abs}}$.\n    -   Let the packet's current state be defined by its position $x_{\\text{pos}}$, its current cell index $i_{\\text{cell}}$, and the remaining optical depth to travel, $\\tau_{\\text{rem}}$ (initialized to $\\tau_{\\text{abs}}$).\n    -   In each step of the propagation, the physical distance to the next cell boundary in the direction of travel, $\\Delta s$, is calculated.\n    -   The optical thickness of this path segment is $\\tau_{\\text{path}} = \\kappa_{i_{\\text{cell}}} \\Delta s$.\n    -   This segment's optical thickness is compared to the remaining optical depth:\n        -   If $\\tau_{\\text{rem}} \\le \\tau_{\\text{path}}$, the packet is absorbed within the current cell $i_{\\text{cell}}$. The absorption counter for this cell, $A_{i_{\\text{cell}}}$, is incremented, and the packet's simulation ends.\n        -   If $\\tau_{\\text{rem}} > \\tau_{\\text{path}}$, the packet traverses the path segment and reaches the cell boundary. The remaining optical depth is reduced by $\\tau_{\\text{path}}$: $\\tau_{\\text{rem}} \\leftarrow \\tau_{\\text{rem}} - \\tau_{\\text{path}}$. The packet's state ($x_{\\text{pos}}$, $i_{\\text{cell}}$) is updated to reflect its new position at the boundary of the next cell. The periodic boundary conditions are enforced: a packet exiting at $x=L$ re-enters at $x=0$, and a packet exiting at $x=0$ re-enters at $x=L$. The process repeats until the packet is absorbed.\n\n4.  **Verification:** After all $N_p$ packets have been simulated, the tallied emission counts $E_i$ and absorption counts $A_i$ are analyzed.\n    -   **Global Energy Conservation:** By construction, every emitted packet is traced until it is absorbed. Therefore, the total number of absorptions must equal the total number of emissions: $\\sum_i A_i = \\sum_i E_i = N_p$. The check $|\\sum_i A_i - \\sum_i E_i| = 0$ serves as a basic sanity check on the algorithm's bookkeeping.\n    -   **Local Detailed Balance:** The principle of detailed balance in radiative equilibrium implies that, on average, the rate of absorption in each cell equals its rate of emission. In the Monte Carlo simulation, this means the expected count of absorptions $\\langle A_i \\rangle$ should equal the expected count of emissions $\\langle E_i \\rangle$. We verify that the statistical fluctuations are within a given tolerance $\\epsilon$ by computing the maximum per-cell relative difference:\n        $$\n        \\max_{i} \\left( \\frac{|A_i - E_i|}{\\max(E_i, 1)} \\right) \\le \\epsilon\n        $$\n        The use of $\\max(E_i, 1)$ in the denominator prevents division by zero in the unlikely event that a cell has zero emissions. A test case passes if and only if both the global and local checks are satisfied.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, L, kappa, N_p, epsilon, seed):\n    \"\"\"\n    Runs a 1D Photon Monte Carlo simulation for a periodic, isothermal slab.\n\n    Args:\n        N (int): Number of cells.\n        L (float): Length of the slab (m).\n        kappa (np.ndarray): Array of absorption coefficients for each cell (m^-1).\n        N_p (int): Number of photon packets to simulate.\n        epsilon (float): Tolerance for local detailed balance check.\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        bool: True if both global energy conservation and local detailed balance pass.\n    \"\"\"\n    np.random.seed(seed)\n\n    # 1. Setup\n    dx = L / N\n    E = np.zeros(N, dtype=np.int64)\n    A = np.zeros(N, dtype=np.int64)\n\n    # Pre-calculate emission probabilities and cell indices\n    kappa_sum = np.sum(kappa)\n    if kappa_sum == 0:\n        # If all kappa are zero, no emission can occur.\n        # This case is trivial and passes by definition.\n        return True\n    emission_probs = kappa / kappa_sum\n    cell_indices = np.arange(N)\n\n    # 2. Main Monte Carlo loop over all photon packets\n    for _ in range(N_p):\n        # 2a. Emission\n        # Select emission cell based on probabilities proportional to kappa\n        i_emit = np.random.choice(cell_indices, p=emission_probs)\n        E[i_emit] += 1\n\n        # Select random position within the cell\n        pos = (i_emit + np.random.rand()) * dx\n\n        # Select random direction (-1 for -x, +1 for +x)\n        direction = 1 if np.random.rand() < 0.5 else -1\n\n        # Sample optical depth to absorption from P(tau) = exp(-tau)\n        tau_remaining = -np.log(np.random.rand())\n\n        # 2b. Propagation until absorption\n        current_cell_idx = i_emit\n        current_pos = pos\n\n        while True:\n            kappa_current = kappa[current_cell_idx]\n\n            # Calculate distance to the next cell boundary along the direction of travel\n            if direction == 1:\n                dist_to_boundary = (current_cell_idx + 1) * dx - current_pos\n            else:  # direction == -1\n                dist_to_boundary = current_pos - current_cell_idx * dx\n            \n            # Clamp small negative distances that can arise from floating point issues\n            if dist_to_boundary < 0:\n                dist_to_boundary = 0.0\n            \n            # Calculate optical thickness to the boundary\n            tau_to_boundary = kappa_current * dist_to_boundary\n\n            if tau_remaining <= tau_to_boundary:\n                # Absorption occurs in the current cell\n                A[current_cell_idx] += 1\n                break  # End this packet's life\n            else:\n                # Packet traverses the cell and crosses the boundary\n                tau_remaining -= tau_to_boundary\n\n                # Update position and cell index, applying periodic boundaries\n                if direction == 1:\n                    pos_at_boundary = (current_cell_idx + 1) * dx\n                    current_cell_idx = (current_cell_idx + 1) % N\n                    # If we cross x=L, the new position is x=0\n                    current_pos = pos_at_boundary if pos_at_boundary < L else 0.0\n                else:  # direction == -1\n                    pos_at_boundary = current_cell_idx * dx\n                    current_cell_idx = (current_cell_idx - 1 + N) % N\n                    # If we cross x=0, the new position is x=L\n                    current_pos = pos_at_boundary if pos_at_boundary > 0.0 else L\n\n    # 3. Verification\n    # 3a. Global energy conservation (should always hold by construction)\n    global_pass = (np.sum(A) == np.sum(E))\n\n    # 3b. Local detailed balance\n    # Use np.maximum to avoid division by zero for cells with no emissions\n    rel_diff = np.abs(A - E) / np.maximum(E.astype(float), 1.0)\n    max_rel_diff = np.max(rel_diff)\n    local_pass = max_rel_diff <= epsilon\n\n    return global_pass and local_pass\n\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test cases specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        # (N, L, kappa_def, N_p, epsilon, seed)\n        (10, 1.0, {\"type\": \"uniform\", \"val\": 2.0}, 50000, 0.03, 123),\n        (10, 1.0, {\"type\": \"uniform\", \"val\": 100.0}, 50000, 0.03, 456),\n        (10, 1.0, {\"type\": \"heterogeneous\", \"vals\": [0.5] * 5 + [2.0] * 5}, 50000, 0.03, 789),\n    ]\n\n    results = []\n    for N, L, kappa_def, N_p, epsilon, seed in test_cases:\n        if kappa_def[\"type\"] == \"uniform\":\n            kappa = np.full(N, kappa_def[\"val\"], dtype=float)\n        else: # \"heterogeneous\"\n            kappa = np.array(kappa_def[\"vals\"], dtype=float)\n        \n        # Run simulation and store the boolean result\n        result = run_simulation(N, L, kappa, N_p, epsilon, seed)\n        results.append(result)\n\n    # Format the final output as a single-line string\n    # Python's str(True) is \"True\", which is not what might be expected for some contexts,\n    # but for this problem it's fine. If lowercase were needed, map(str.lower, results) would be used.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}