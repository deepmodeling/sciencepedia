{
    "hands_on_practices": [
        {
            "introduction": "在模拟光子输运之前，我们必须首先确定介质的辐射特性。在燃烧学中，这些特性取决于局部的温度和物质组分。本练习旨在将计算流体动力学（CFD）模拟得到的理化状态数据，转化为诸如吸收系数（$\\kappa_\\nu$）、散射系数（$\\sigma_{s,\\nu}$）和单次散射反照率（$\\omega_\\nu$）等关键辐射物性。掌握这一步骤对于将流体动力学与辐射模型耦合至关重要，它确保了模拟能准确反映真实的物理环境 。",
            "id": "4049622",
            "problem": "考虑在一个使用光子蒙特卡洛（Photon Monte Carlo, PMC）方法建模的计算流体动力学（Computational Fluid Dynamics, CFD）燃烧域内，频率为 $\\nu$ 的单色光子输运。在每个空间位置 $\\mathbf{x}$，热化学状态由温度 $T(\\mathbf{x})$（单位：开尔文）和物种质量分数 $Y_i(\\mathbf{x})$ 表示，其中 $i \\in \\{\\mathrm{CO_2}, \\mathrm{H_2O}, \\mathrm{N_2}, \\mathrm{soot}\\}$，且满足 $\\sum_i Y_i(\\mathbf{x}) = 1$ 和 $Y_i(\\mathbf{x}) \\ge 0$。目标是使用已测定的吸收和散射替代闭合模型，计算随空间变化的单次散射反照率 $\\omega_\\nu(\\mathbf{x})$，其定义为局部消光中可归因于散射的部分。\n\n假设对每种物质单位质量分数的单色吸收和散射系数，采用以下科学上合理的替代模型：\n- 对于吸收，对于 $i \\in \\{\\mathrm{CO_2}, \\mathrm{H_2O}, \\mathrm{N_2}, \\mathrm{soot}\\}$，\n$$\n\\kappa_{\\nu,i}(T) = a_i \\left(\\frac{T}{1000}\\right)^{p_i} \\quad \\text{单位为 } \\mathrm{m}^{-1} \\text{ 每单位质量分数}。\n$$\n使用常数\n$$\na_{\\mathrm{CO_2}}=0.5,\\; p_{\\mathrm{CO_2}}=1.2;\\quad\na_{\\mathrm{H_2O}}=0.7,\\; p_{\\mathrm{H_2O}}=1.1;\\quad\na_{\\mathrm{N_2}}=0.02,\\; p_{\\mathrm{N_2}}=1.0;\\quad\na_{\\mathrm{soot}}=1.5,\\; p_{\\mathrm{soot}}=0.9.\n$$\n- 对于散射，\n$$\n\\sigma_{s,\\nu,\\mathrm{CO_2}}(T)=0,\\quad\n\\sigma_{s,\\nu,\\mathrm{H_2O}}(T)=0,\\quad\n\\sigma_{s,\\nu,\\mathrm{N_2}}(T)=b_{\\mathrm{N_2}}\\left(\\frac{1000}{T}\\right),\\quad\n\\sigma_{s,\\nu,\\mathrm{soot}}(T)=b_{\\mathrm{soot}}\\left(\\frac{T}{1500}\\right),\n$$\n常数 $b_{\\mathrm{N_2}}=0.003$ 和 $b_{\\mathrm{soot}}=2.5$，单位为 $\\mathrm{m}^{-1}$ 每单位质量分数。\n\n对于某一点上状态为 $(T,Y)$ 的混合物，将混合物吸收和散射系数定义为质量分数加权和：\n$$\n\\kappa_\\nu(T,Y) = \\sum_{i} Y_i \\,\\kappa_{\\nu,i}(T), \\qquad\n\\sigma_{s,\\nu}(T,Y) = \\sum_{i} Y_i \\,\\sigma_{s,\\nu,i}(T).\n$$\n消光系数定义为\n$$\n\\beta_\\nu(T,Y) = \\kappa_\\nu(T,Y) + \\sigma_{s,\\nu}(T,Y).\n$$\n将单次散射反照率 $\\omega_\\nu(T,Y)$ 定义为散射对总消光的贡献所占的无量纲比率。为保证数值稳定性，使用以下约定\n$$\n\\omega_\\nu(T,Y) =\n\\begin{cases}\n0,  \\text{若 } \\beta_\\nu(T,Y)  \\varepsilon,\\\\\n\\dfrac{\\sigma_{s,\\nu}(T,Y)}{\\beta_\\nu(T,Y)},  \\text{其他情况},\n\\end{cases}\n$$\n其中 $\\varepsilon = 10^{-12}\\ \\mathrm{m}^{-1}$。\n\n实现一个程序，对以下每个测试用例，使用上述定义计算 $\\omega_\\nu$。在计算之前，通过将任何负的 $Y_i$ 截断为 $0$ 并用其和（如果和为严格正数）对向量 $Y$ 进行归一化，来强制执行约束条件 $Y_i \\ge 0$ 和 $\\sum_i Y_i = 1$；如果截断后的和为零，则按约定将 $\\omega_\\nu$ 设为 $0$。\n\n物理和数值单位：\n- 温度 $T$ 的单位必须是开尔文。\n- $\\kappa_\\nu$ 和 $\\sigma_{s,\\nu}$ 的单位是 $\\mathrm{m}^{-1}$。\n- $\\omega_\\nu$ 是无量纲的，必须以小数点后保留六位的小数形式报告。\n\n测试套件（每个用例是一个空间位置）：\n1. $T=1800$, $Y_{\\mathrm{CO_2}}=0.12$, $Y_{\\mathrm{H_2O}}=0.18$, $Y_{\\mathrm{N_2}}=0.70$, $Y_{\\mathrm{soot}}=0.00$。\n2. $T=2000$, $Y_{\\mathrm{CO_2}}=0.10$, $Y_{\\mathrm{H_2O}}=0.15$, $Y_{\\mathrm{N_2}}=0.73$, $Y_{\\mathrm{soot}}=0.02$。\n3. $T=300$, $Y_{\\mathrm{CO_2}}=0.00$, $Y_{\\mathrm{H_2O}}=0.00$, $Y_{\\mathrm{N_2}}=0.999$, $Y_{\\mathrm{soot}}=0.001$。\n4. $T=800$, $Y_{\\mathrm{CO_2}}=0.05$, $Y_{\\mathrm{H_2O}}=0.10$, $Y_{\\mathrm{N_2}}=0.84$, $Y_{\\mathrm{soot}}=0.01$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述测试套件的顺序排列，例如“[result1,result2,result3,result4]”。每个结果必须是对应案例的 $\\omega_\\nu$ 值，四舍五入到小数点后六位，不带单位。",
            "solution": "该问题要求在燃烧环境中的特定空间位置计算单色单次散射反照率，记为 $\\omega_\\nu$。该计算基于所提供的气体和烟尘组分的吸收和散射特性的替代模型。每个位置的热化学状态由温度 $T$ 和物种 $i \\in \\{\\mathrm{CO_2}, \\mathrm{H_2O}, \\mathrm{N_2}, \\mathrm{soot}\\}$ 的质量分数 $Y_i$ 定义。\n\n单次散射反照率 $\\omega_\\nu$ 是一个无量纲量，表示总消光中由散射引起的部分。其定义为：\n$$\n\\omega_\\nu = \\frac{\\sigma_{s,\\nu}}{\\beta_\\nu}\n$$\n其中 $\\sigma_{s,\\nu}$ 是混合物散射系数，$\\beta_\\nu$ 是混合物消光系数。消光系数是混合物吸收系数 $\\kappa_\\nu$ 和混合物散射系数 $\\sigma_{s,\\nu}$ 的和：\n$$\n\\beta_\\nu(T,Y) = \\kappa_\\nu(T,Y) + \\sigma_{s,\\nu}(T,Y)\n$$\n问题提供了一个数值稳定性条件：如果 $\\beta_\\nu  \\varepsilon$，其中 $\\varepsilon = 10^{-12}\\ \\mathrm{m}^{-1}$，则反照率 $\\omega_\\nu$ 取为 $0$。\n\n混合物系数由单个物种系数的质量分数加权和确定：\n$$\n\\kappa_\\nu(T,Y) = \\sum_{i} Y_i \\,\\kappa_{\\nu,i}(T)\n$$\n$$\n\\sigma_{s,\\nu}(T,Y) = \\sum_{i} Y_i \\,\\sigma_{s,\\nu,i}(T)\n$$\n在进行这些计算之前，必须对质量分数向量 $Y$ 进行清理。任何负分量 $Y_i$ 都被截断为 $0$，如果各分量之和为正，则对该向量进行归一化，以确保其分量之和为 $1$。如果截断后的质量分数之和为零，则按约定将 $\\omega_\\nu$ 设为 $0$。\n\n特定物种的系数由依赖于温度 $T$ 的替代模型给出。\n\n物种 $i$ 的吸收系数建模为：\n$$\n\\kappa_{\\nu,i}(T) = a_i \\left(\\frac{T}{1000}\\right)^{p_i} \\quad [\\text{单位：}\\mathrm{m}^{-1} \\text{ 每单位质量分数}]\n$$\n常数 $(a_i, p_i)$ 对 $\\mathrm{CO_2}$、$\\mathrm{H_2O}$、$\\mathrm{N_2}$ 和烟尘提供如下：\n- $i=\\mathrm{CO_2}$: $a_{\\mathrm{CO_2}}=0.5$, $p_{\\mathrm{CO_2}}=1.2$\n- $i=\\mathrm{H_2O}$: $a_{\\mathrm{H_2O}}=0.7$, $p_{\\mathrm{H_2O}}=1.1$\n- $i=\\mathrm{N_2}$: $a_{\\mathrm{N_2}}=0.02$, $p_{\\mathrm{N_2}}=1.0$\n- $i=\\mathrm{soot}$: $a_{\\mathrm{soot}}=1.5$, $p_{\\mathrm{soot}}=0.9$\n\n每种物质的散射系数为：\n$$\n\\sigma_{s,\\nu,\\mathrm{CO_2}}(T)=0 \\quad [\\text{单位：}\\mathrm{m}^{-1} \\text{ 每单位质量分数}]\n$$\n$$\n\\sigma_{s,\\nu,\\mathrm{H_2O}}(T)=0 \\quad [\\text{单位：}\\mathrm{m}^{-1} \\text{ 每单位质量分数}]\n$$\n$$\n\\sigma_{s,\\nu,\\mathrm{N_2}}(T)=b_{\\mathrm{N_2}}\\left(\\frac{1000}{T}\\right) \\quad [\\text{单位：}\\mathrm{m}^{-1} \\text{ 每单位质量分数}], \\text{ 其中 } b_{\\mathrm{N_2}}=0.003\n$$\n$$\n\\sigma_{s,\\nu,\\mathrm{soot}}(T)=b_{\\mathrm{soot}}\\left(\\frac{T}{1500}\\right) \\quad [\\text{单位：}\\mathrm{m}^{-1} \\text{ 每单位质量分数}], \\text{ 其中 } b_{\\mathrm{soot}}=2.5\n$$\n\n解决方案的实现首先是定义一个函数，该函数接收给定的状态 $(T, Y)$ 并计算 $\\omega_\\nu$。该函数遵循以下步骤：\n1.  接收温度 T（单位：开尔文）和一个质量分数列表或元组 Y = (Y_CO2, Y_H2O, Y_N2, Y_soot)。\n2.  对质量分数 Y 应用指定的预处理：将负值截断为 0，并在其和为正的情况下重新归一化向量使其和为 1。按规定处理和为零的情况。\n3.  使用温度 T 以及提供的公式和常数，计算四个特定物种的吸收系数 $\\kappa_{\\nu,i}(T)$。\n4.  计算四个特定物种的散射系数 $\\sigma_{s,\\nu,i}(T)$。注意对于 $\\mathrm{CO_2}$ 和 $\\mathrm{H_2O}$，这些值为 $0$。\n5.  通过计算归一化质量分数向量与物种吸收系数向量的点积，来计算混合物吸收系数 $\\kappa_\\nu$。\n6.  类似地计算混合物散射系数 $\\sigma_{s,\\nu}$。\n7.  计算总消光系数 $\\beta_\\nu = \\kappa_\\nu + \\sigma_{s,\\nu}$。\n8.  应用稳定性检查：如果 $\\beta_\\nu  10^{-12}$，则设置 $\\omega_\\nu=0$。否则，计算 $\\omega_\\nu = \\sigma_{s,\\nu} / \\beta_\\nu$。\n9.  返回计算出的 $\\omega_\\nu$ 值。\n\n将此过程应用于问题描述中指定的每个测试用例。然后将得到的 $\\omega_\\nu$ 值四舍五入到小数点后六位，并格式化为所需的输出字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It calculates the single-scattering albedo for each case and prints the results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (T, (Y_CO2, Y_H2O, Y_N2, Y_soot))\n    test_cases = [\n        (1800, (0.12, 0.18, 0.70, 0.00)),\n        (2000, (0.10, 0.15, 0.73, 0.02)),\n        (300, (0.00, 0.00, 0.999, 0.001)),\n        (800, (0.05, 0.10, 0.84, 0.01)),\n    ]\n\n    # Constants for the surrogate models\n    # Species order: CO2, H2O, N2, soot\n    species = ['CO2', 'H2O', 'N2', 'soot']\n    \n    # Absorption coefficients constants\n    a = np.array([0.5, 0.7, 0.02, 1.5])  # a_i\n    p = np.array([1.2, 1.1, 1.0, 0.9])  # p_i\n\n    # Scattering coefficients constants\n    b_N2 = 0.003\n    b_soot = 2.5\n    \n    # Numerical stability threshold\n    epsilon = 1e-12\n\n    results = []\n    for T, Y in test_cases:\n        omega = calculate_omega(T, Y, species, a, p, b_N2, b_soot, epsilon)\n        results.append(f\"{omega:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_omega(T, Y, species, a, p, b_N2, b_soot, epsilon):\n    \"\"\"\n    Computes the single-scattering albedo for a given thermochemical state.\n\n    Args:\n        T (float): Temperature in Kelvin.\n        Y (tuple): Tuple of mass fractions for (CO2, H2O, N2, soot).\n        species (list): List of species names.\n        a (np.ndarray): Array of absorption constants a_i.\n        p (np.ndarray): Array of absorption constants p_i.\n        b_N2 (float): Scattering constant for N2.\n        b_soot (float): Scattering constant for soot.\n        epsilon (float): Threshold for numerical stability.\n\n    Returns:\n        float: The calculated single-scattering albedo, omega_nu.\n    \"\"\"\n    \n    Y_arr = np.array(Y, dtype=float)\n\n    # Step 1: Pre-process mass fractions\n    Y_clamped = np.maximum(Y_arr, 0.0)\n    Y_sum = np.sum(Y_clamped)\n    \n    if Y_sum == 0.0:\n        return 0.0\n        \n    Y_norm = Y_clamped / Y_sum\n\n    # Step 2: Calculate species-specific absorption coefficients\n    kappa_i = a * (T / 1000.0)**p\n\n    # Step 3: Calculate species-specific scattering coefficients\n    sigma_i = np.zeros_like(Y_arr)\n    idx_N2 = species.index('N2')\n    idx_soot = species.index('soot')\n    \n    if T > 0: # Avoid division by zero if T=0\n        sigma_i[idx_N2] = b_N2 * (1000.0 / T)\n\n    sigma_i[idx_soot] = b_soot * (T / 1500.0)\n\n    # Step 4: Compute mixture coefficients\n    kappa_mix = np.dot(Y_norm, kappa_i)\n    sigma_mix = np.dot(Y_norm, sigma_i)\n\n    # Step 5: Compute extinction coefficient and albedo\n    beta_mix = kappa_mix + sigma_mix\n    \n    if beta_mix  epsilon:\n        omega = 0.0\n    else:\n        omega = sigma_mix / beta_mix\n        \n    return omega\n\nsolve()\n```"
        },
        {
            "introduction": "一旦辐射物性已知，下一步便是模拟光子的“旅程”。在燃烧等常见场景中，介质在空间上往往是不均匀的，如何在这样的介质中对光子的自由程进行抽样是一个核心挑战。本实践将介绍“delta-tracking”（或称“空碰撞”）方法，这是一种通过引入虚构的“空”事件来简化非均匀介质中路径长度抽样的优雅而强大的算法。通过实现该算法，您将学会一种计算效率高且在工业级蒙特卡洛程序中广泛应用的技术 。",
            "id": "4049528",
            "problem": "考虑一个厚度为 $L$ 的一维平板，其消光系数 $ \\beta(x) $（单位为 $ \\mathrm{m}^{-1} $）随空间变化。一个光子从位置 $ x = 0 $ 处发射，并沿着 $ +x $ 方向穿过该平板。$ x = L $ 处的边界是真空，因此如果光子到达 $ x = L $ 而未被吸收，它就会逃逸。吸收是唯一的真实相互作用；散射和发射被忽略。目标是当 $ \\beta(x) $ 随空间变化时，构建并应用 delta-tracking（空碰撞）算法来抽样自由程和相互作用事件。\n\nDelta-tracking 使用一个常数优函数 $ \\beta^* $（单位为 $ \\mathrm{m}^{-1} $），其选择需满足对于所有 $ x \\in [0,L] $ 都有 $ \\beta(x) \\le \\beta^* $。提议的自由程长度 $ s $ 从速率为 $ \\beta^* $ 的指数分布中抽样，即其概率密度函数为 $ f(s) = \\beta^* \\exp(-\\beta^* s) $（$ s \\ge 0 $）。在前进到提议的相互作用位置后，该事件以 $ \\beta(x)/\\beta^* $ 的概率被接受为真实吸收，否则被视为空碰撞，没有物理效应。此过程重复进行，直到光子逃逸或被吸收。\n\n从辐射传输方程（RTE）的第一性原理和非均匀泊松过程对消光的定义出发，为上述 delta-tracking 接受-拒绝程序推导出有原则的算法原理，确保真实相互作用位置的分布与真实空间速率 $ \\beta(x) $ 一致。然后实现该算法并估计平板的透射率，透射率定义为发射的光子在从未经历真实吸收的情况下于 $ x = L $ 处逃逸的概率。对每个测试用例使用 $ N $ 个独立的光子历史，并使用固定的随机数生成器种子以确保可复现性。将透射率表示为无量纲数。同时，计算每个发射光子的平均空碰撞次数，也表示为无量纲量。\n\n透射率的解析参考由非均匀 Beer–Lambert 定律给出，该定律指出透射率等于 $ \\exp\\!\\left( - \\int_0^L \\beta(x) \\, dx \\right) $。您必须通过报告绝对误差（无量纲）来将您的蒙特卡洛估计值与此解析值进行比较。为了数值可复现性，使用 $ N = 100000 $ 个光子历史和固定的随机数生成器种子 $ 12345 $。\n\n实现您的程序以处理以下测试套件，其中 $ L $ 的单位为米，$ \\beta(x) $ 和 $ \\beta^* $ 的单位为米分之一：\n\n- 测试用例 1：$ L = 0.5\\,\\mathrm{m} $，对于所有 $ x $，$ \\beta(x) = 1.0\\,\\mathrm{m}^{-1} $，$ \\beta^* = 1.0\\,\\mathrm{m}^{-1} $。\n- 测试用例 2：$ L = 1.0\\,\\mathrm{m} $，$ \\beta(x) = 0.5 + 0.5 x\\,\\mathrm{m}^{-1} $，$ \\beta^* = 1.0\\,\\mathrm{m}^{-1} $。\n- 测试用例 3：$ L = 0.8\\,\\mathrm{m} $，$ \\beta(x) = \\begin{cases} 0\\,\\mathrm{m}^{-1},  0 \\le x  0.3\\,\\mathrm{m}, \\\\ 3.0\\,\\mathrm{m}^{-1},  0.3\\,\\mathrm{m} \\le x  0.5\\,\\mathrm{m}, \\\\ 0.2\\,\\mathrm{m}^{-1},  0.5\\,\\mathrm{m} \\le x \\le 0.8\\,\\mathrm{m}, \\end{cases} $，$ \\beta^* = 3.0\\,\\mathrm{m}^{-1} $。\n- 测试用例 4：$ L = 1.0\\,\\mathrm{m} $，$ \\beta(x) = 0.8 + 0.3 \\sin\\!\\left( 2\\pi x / L \\right)\\,\\mathrm{m}^{-1} $，$ \\beta^* = 1.1\\,\\mathrm{m}^{-1} $。\n\n对于每个测试用例，计算：\n- 透射率的蒙特卡洛估计值（无量纲）。\n- 蒙特卡洛估计值与解析透射率 $ \\exp\\!\\left( - \\int_0^L \\beta(x) \\, dx \\right) $ 之间的绝对误差（无量纲）。\n- 每个发射光子的平均空碰撞次数（无量纲）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $ [T_1,\\mathrm{err}_1,\\bar{n}_{\\mathrm{null},1},T_2,\\mathrm{err}_2,\\bar{n}_{\\mathrm{null},2},T_3,\\mathrm{err}_3,\\bar{n}_{\\mathrm{null},3},T_4,\\mathrm{err}_4,\\bar{n}_{\\mathrm{null},4}] $，其中 $ T_i $ 表示蒙特卡洛透射率估计值，$ \\mathrm{err}_i $ 表示相对于解析值的绝对误差，$ \\bar{n}_{\\mathrm{null},i} $ 表示测试用例 $ i $ 中每个发射光子的平均空碰撞次数。",
            "solution": "该问题要求推导并实现一个 delta-tracking（空碰撞）蒙特卡洛算法，以模拟在一维平板中光子在空间变化的吸收系数下的传输过程。目标是估计平板的透射率和平均空碰撞次数，并将透射率与解析解进行比较。\n\n### 第一部分：Delta-Tracking 算法的原理推导\n\n#### 1.1. 物理与数学基础：辐射传输方程 (RTE)\n\n控制辐射在介质中传输的基本方程是辐射传输方程（RTE）。对于一维、不发射、不散射（纯吸收）的介质，辐射强度 $I$ 沿 $+x$ 方向路径的变化由以下公式描述：\n$$\n\\frac{dI(x)}{dx} = -\\beta(x) I(x)\n$$\n其中 $\\beta(x)$ 是随空间变化的吸收系数，单位为 $\\mathrm{m}^{-1}$。项 $\\beta(x)$ 表示光子在位置 $x$ 处单位路径长度上被吸收的概率。\n\n#### 1.2. 概率解释与标准蒙特卡洛方法\n\n将 RTE 从 $x=0$ 积分到位置 $x=s$ 可得到解：\n$$\nI(s) = I(0) \\exp\\left(-\\int_0^s \\beta(x') \\, dx'\\right)\n$$\n项 $\\exp\\left(-\\int_0^s \\beta(x') \\, dx'\\right)$ 是一个从 $x=0$ 出发的光子在行进至少距离 $s$ 后仍未被吸收的概率。这是存活概率。积分 $\\tau(s) = \\int_0^s \\beta(x') \\, dx'$ 是路径的光学厚度。\n\n*第一次*相互作用位置的概率密度函数（PDF）$p(s)$，可以通过考虑存活到 $s$ 然后在无穷小区间 $[s, s+ds]$ 内发生相互作用的概率来找到。这由下式给出：\n$$\np(s) = \\beta(s) \\exp\\left(-\\int_0^s \\beta(x') \\, dx'\\right)\n$$\n要直接模拟光子传输，必须从此 PDF 中抽样自由程长度 $s$。这通常通过逆变换采样法实现。累积分布函数（CDF）是：\n$$\nF(s) = \\int_0^s p(x') \\, dx' = 1 - \\exp\\left(-\\int_0^s \\beta(x') \\, dx'\\right)\n$$\n为抽样 $s$，我们设 $F(s) = U$，其中 $U$ 是 $[0, 1)$ 中的一个均匀随机数，然后解出 $s$：\n$$\n\\int_0^s \\beta(x') \\, dx' = -\\ln(1-U)\n$$\n如果 $\\beta(x)$ 是一个复杂的函数，求解这个积分方程以得到 $s$ 在计算上可能非常昂贵或解析上难以处理，这使得直接模拟效率低下。\n\n#### 1.3. Delta-Tracking（空碰撞）方法\n\ndelta-tracking 方法重新构建了问题，以避免直接对 CDF 进行求逆。它引入了一个虚构的“空碰撞”过程。选择一个常数优函数消光系数 $\\beta^*$，使得在所有感兴趣的域内的 $x$ 都有 $\\beta(x) \\le \\beta^*$。\n\n通过向 RTE 中加上和减去一个“空”系数 $\\beta_{\\text{null}}(x) = \\beta^* - \\beta(x)$，物理系统在概念上被修改了。总相互作用系数变为 $\\beta(x) + \\beta_{\\text{null}}(x) = \\beta^*$，这是一个常数。修改后的 RTE 可以解释为：\n$$\n\\frac{dI(x)}{dx} = -\\beta^* I(x) + (\\beta^* - \\beta(x)) I(x)\n$$\n这描述了一个传输过程，其中光子与介质以一个恒定的单位长度总概率 $\\beta^*$ 相互作用。相互作用事件可以是“真实”吸收（速率为 $\\beta(x)$），也可以是“空”碰撞（速率为 $\\beta^* - \\beta(x)$），空碰撞不影响光子的状态（等效于完全前向散射）。\n\n在这个新构想下，介质是均匀的，具有恒定的消光系数 $\\beta^*$。到*下一次暂定相互作用*的自由程长度 $s$ 的 PDF 现在是一个简单的指数分布：\n$$\nf(s) = \\beta^* \\exp(-\\beta^* s)\n$$\n可以使用逆变换采样法轻松地从此分布中抽样路径长度 $s$：\n$$\ns = -\\frac{1}{\\beta^*} \\ln(U)\n$$\n其中 $U$ 是 $(0, 1)$ 中的一个均匀随机数。\n\n#### 1.4. 接受-拒绝步骤\n\n在将光子前进距离 $s$ 到达新位置 $x$ 后，我们必须确定这次暂定的相互作用是真实吸收还是空碰撞。此步骤的原理植根于泊松过程的稀疏化理论。一个速率为 $\\lambda(t)$ 的非均匀泊松过程，可以通过从一个优函数速率为 $\\lambda^* \\ge \\lambda(t)$ 的均匀泊松过程中生成事件，并以概率 $\\lambda(t)/\\lambda^*$ 接受每个事件来模拟。\n\n在我们的情境中，路径长度 $x$ 是过程变量，真实相互作用速率是 $\\beta(x)$，优函数速率是 $\\beta^*$。在相互作用点 $x$，事件是真实吸收的条件概率是真实吸收速率与总相互作用速率之比：\n$$\nP(\\text{real} | \\text{interaction at } x) = \\frac{\\beta(x)}{\\beta^*}\n$$\n这导出了以下接受-拒绝程序：\n1.  从速率为 $\\beta^*$ 的分布中抽样暂定路径长度 $s = -\\ln(U_1)/\\beta^*$。\n2.  将光子推进到提议的相互作用位置 $x' = x_{\\text{old}} + s$。\n3.  如果光子逃离介质（$x' \\ge L$），则历史终止。\n4.  如果相互作用发生在介质内部（$x'  L$），生成第二个均匀随机数 $U_2$。\n5.  如果 $U_2  \\beta(x')/\\beta^*$，则相互作用被接受为**真实吸收**。光子的历史终止。\n6.  如果 $U_2 \\ge \\beta(x')/\\beta^*$，则相互作用是**空碰撞**。光子的状态不变，其模拟从位置 $x'$ 继续，从步骤 1 开始重复。\n\n该算法正确地模拟了原始物理过程，因为在任何点 $x$ 处的真实相互作用的有效速率是暂定相互作用的速率（$\\beta^*$）乘以接受概率（$\\beta(x)/\\beta^*$），其结果等于 $\\beta(x)$，即真实的物理速率。\n\n### 第二部分：算法实现\n\n蒙特卡洛模拟是通过根据 delta-tracking 算法追踪大量（$N$ 个）独立光子历史来实现的。\n\n1.  **初始化**：对于由 $L$、$\\beta(x)$ 和 $\\beta^*$ 定义的每个测试用例，我们将透射光子和总空碰撞的计数器初始化为零。\n2.  **光子循环**：对于 $N$ 个光子中的每一个：\n    a.  初始化光子的位置 $x=0.0$ 及其状态为“存活”。\n    b.  为此特定光子初始化一个空碰撞计数器。\n    c.  **追踪循环**：当光子存活时：\n        i.   从速率为 $\\beta^*$ 的指数分布中抽样一个暂定自由程长度 $s$。\n        ii.  计算新的提议位置 $x' = x + s$。\n        iii. 如果 $x' \\ge L$，光子逃逸。增加透射光子计数器，更新总空碰撞计数，并终止该光子的历史。\n        iv. 如果 $x'  L$，将光子移动到这个新位置 $x = x'$。\n        v.  执行接受-拒绝测试：生成一个随机数 $U$ 并将其与比率 $\\beta(x)/\\beta^*$ 进行比较。\n        vi. 如果是真实碰撞（吸收），在更新总空碰撞计数后终止该光子的历史。\n        vii. 如果是空碰撞，增加该光子的空碰撞计数器，并从当前位置 $x$ 继续追踪循环。\n3.  **结果计算**：在所有 $N$ 个历史完成后：\n    a.  蒙特卡洛透射率估计值为 $T_{\\text{MC}} = (\\text{透射光子数}) / N$。\n    b.  平均空碰撞次数为 $\\bar{n}_{\\text{null}} = (\\text{总空碰撞次数}) / N$。\n    c.  解析透射率计算为 $T_{\\text{analytic}} = \\exp\\left(-\\int_0^L \\beta(x) \\, dx\\right)$。该积分（光学厚度）使用 `scipy.integrate.quad` 进行数值计算。\n    d.  绝对误差计算为 $\\mathrm{err} = |T_{\\text{MC}} - T_{\\text{analytic}}|$。\n4.  **输出**：所有测试用例的计算值 $(T_{\\text{MC}}, \\mathrm{err}, \\bar{n}_{\\text{null}})$ 被收集并按规定格式化为单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Implements a delta-tracking Monte Carlo simulation for 1D photon transport,\n    computes transmittance, error, and mean null-collisions for specified test cases.\n    \"\"\"\n    # Global simulation parameters\n    N_PHOTONS = 100000\n    SEED = 12345\n    rng = np.random.default_rng(SEED)\n\n    # Test case definitions\n    def beta_1(x):\n        return 1.0\n\n    def beta_2(x):\n        return 0.5 + 0.5 * x\n\n    def beta_3(x):\n        if 0.3 = x  0.5:\n            return 3.0\n        elif 0.5 = x = 0.8:\n            return 0.2\n        else:\n            return 0.0\n    \n    # For case 4, L=1.0 is used in the sin term as specified in the problem\n    def beta_4(x):\n        return 0.8 + 0.3 * np.sin(2.0 * np.pi * x / 1.0)\n    \n    test_cases = [\n        {'L': 0.5, 'beta_func': beta_1, 'beta_star': 1.0},\n        {'L': 1.0, 'beta_func': beta_2, 'beta_star': 1.0},\n        {'L': 0.8, 'beta_func': beta_3, 'beta_star': 3.0},\n        {'L': 1.0, 'beta_func': beta_4, 'beta_star': 1.1},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        L = case['L']\n        beta_func = case['beta_func']\n        beta_star = case['beta_star']\n\n        # Monte Carlo Simulation\n        transmitted_count = 0\n        total_null_collisions = 0\n\n        for _ in range(N_PHOTONS):\n            x = 0.0\n            photon_alive = True\n            num_null_this_photon = 0\n\n            while photon_alive:\n                # Sample distance to next tentative collision from the homogeneous medium\n                s = -np.log(rng.random()) / beta_star\n                \n                # New proposed position\n                x_new = x + s\n\n                if x_new >= L:\n                    # Photon escapes the slab (is transmitted)\n                    transmitted_count += 1\n                    photon_alive = False\n                else:\n                    # An interaction occurs within the slab\n                    x = x_new\n                    \n                    # Acceptance-rejection to determine if it is a real or null collision\n                    prob_real = beta_func(x) / beta_star\n                    if rng.random()  prob_real:\n                        # Real collision (absorption)\n                        photon_alive = False\n                    else:\n                        # Null collision\n                        num_null_this_photon += 1\n            \n            # Add this photon's null collision count to the total\n            total_null_collisions += num_null_this_photon\n\n        # Calculate Monte Carlo results statistics\n        T_mc = transmitted_count / N_PHOTONS\n        mean_null_collisions = total_null_collisions / N_PHOTONS\n\n        # Calculate analytic transmittance for error comparison\n        # The integral of beta(x) is the optical thickness\n        optical_thickness, _ = quad(beta_func, 0, L)\n        T_analytic = np.exp(-optical_thickness)\n\n        # Calculate absolute error\n        error = abs(T_mc - T_analytic)\n\n        # Store results for this case\n        all_results.extend([T_mc, error, mean_null_collisions])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个正确实现的蒙特卡洛模拟不仅要数值稳定，还必须遵循基本的物理定律。验证模拟是否遵循“细致平衡”等原理是代码验证的关键一步。本练习要求您为一个处于辐射平衡状态的系统构建一个完整的模拟。您将对光子的发射、传播和吸收过程进行建模，以验证在局部达到吸收与发射相平衡的细致平衡原理 。",
            "id": "4049551",
            "problem": "考虑一个代表处于局部热力学平衡 (LTE) 状态下均匀燃烧气体体积的一维周期性平板。该平板长度为 $L$ 米，被离散成 $N$ 个宽度为 $\\Delta x = L/N$ 的相等单元，并具有空间上分段恒定的吸收系数 $\\kappa(x)$，单位为米$^{-1}$。在 LTE 条件下，沿路径坐标 $s$ 的光谱强度 $I$ 的辐射传输方程 (RTE) 为 $ \\mathrm{d} I / \\mathrm{d} s = - \\kappa I + j $，其中发射系数 $j$ 满足 $ j = \\kappa B $，$B$ 是局部温度 $T$ (假设在整个平板上是均匀的) 下的普朗克函数。辐射平衡要求每个单元中的发射率等于吸收率，因此每个单元的净辐射源为零。\n\n将使用蒙特卡洛光子包方法来验证能量守恒、互易性和细致平衡。每个光子包携带单位能量，沿平板轴线各向同性地发射，以相等概率沿 $+x$ 或 $-x$ 方向行进，其发射位置在所选源单元内均匀分布。发射单元的索引从与 $ \\kappa_i V_i $ 成正比的离散分布中采样，其中 $ \\kappa_i $ 是单元 $i$ 的吸收系数，$ V_i $ 是单元体积（在这个一维平板中，$ V_i \\propto \\Delta x $，因此 $ \\kappa_i V_i \\propto \\kappa_i $）。光子包到达吸收点的自由飞行光深 $ \\tau $ 从指数分布 $ p(\\tau) = e^{-\\tau} $ 中采样，其中 $ \\tau = - \\ln(u) $，$ u \\sim \\mathcal{U}(0,1) $。当光子包传播时，剩余光深会因在每个单元内穿过路径 $ \\mathrm{d} x $ 而减少 $ \\kappa(x) \\, \\mathrm{d} x $，吸收事件发生在剩余光深被耗尽的那个单元内。施加周期性边界条件，因此一个在 $x=L$ 处离开的光子包会从 $x=0$ 处重新进入，一个在 $x=0$ 处离开的光子包会从 $x=L$ 处重新进入。\n\n从 LTE RTE 的基本原理 $ \\mathrm{d} I / \\mathrm{d} s = - \\kappa I + \\kappa B $ 和空间周期性、温度均匀介质中的各向同性黑体解 $ I = B $ 出发，可以得出每个单元的期望吸收等于其期望发射，即 $ \\langle A_i \\rangle = \\langle E_i \\rangle = \\kappa_i \\, 4 \\pi B \\, V_i $（相差一个被光子包单位能量归一化所吸收的常数因子）。互易性意味着，在没有各向异性散射的情况下，反转任何路径的行进方向都不会改变吸收事件的分布。能量守恒要求吸收的光子包总数等于发射的光子包总数。\n\n你的任务是实现一个完整、可复现的蒙特卡洛程序，该程序：\n- 从单元中发射光子包，其概率与 $ \\kappa_i $ 成正比。\n- 以相等的概率在 $ \\pm x $ 方向上采样各向同性方向，并在源单元内采样均匀分布的发射位置。\n- 从 $ p(\\tau) = e^{-\\tau} $ 中采样吸收光深 $ \\tau $，并在单元间传播光子包，强制执行周期性边界，直到发生吸收。\n- 统计每个单元的发射计数 $ E_i $ 和吸收计数 $ A_i $。\n- 通过检查每个单元的最大相对差异 $ \\max_i \\left| A_i - E_i \\right| / \\max \\left( E_i, 1 \\right) $ 不超过容差 $ \\epsilon $ 来局部验证细致平衡。\n- 通过检查 $ \\left| \\sum_i A_i - \\sum_i E_i \\right| = 0 $ 来验证全局能量守恒。\n\n如果引用了任何角度，都必须以弧度为单位进行解释，尽管该算法仅需要在 $ \\pm x $ 方向上进行离散方向采样，而无需明确的角度值。\n\n使用以下具有指定参数和物理单位的测试套件，并以布尔值的形式生成结果，指示每种情况下局部细致平衡和全局能量守恒是否都通过：\n- 测试用例 1 (正常路径，均匀介质): $N = 10$, $L = 1$ 米, 对所有 $i$，$ \\kappa_i = 2.0 $ 米$^{-1}$, $T = 1500$ 开尔文, 光子包数量 $N_p = 50000$, 容差 $ \\epsilon = 0.03 $, 随机种子 $123$。\n- 测试用例 2 (光学厚边界条件): $N = 10$, $L = 1$ 米, 对所有 $i$，$ \\kappa_i = 100.0 $ 米$^{-1}$, $T = 1500$ 开尔文, 光子包数量 $N_p = 50000$, 容差 $ \\epsilon = 0.03 $, 随机种子 $456$。\n- 测试用例 3 (非均匀介质互易性检查): $N = 10$, $L = 1$ 米, 对于单元 $i=0,1,2,3,4$, $ \\kappa_i = 0.5 $ 米$^{-1}$, 对于单元 $i=5,6,7,8,9$, $ \\kappa_i = 2.0 $ 米$^{-1}$, $T = 1500$ 开尔文, 光子包数量 $N_p = 50000$, 容差 $ \\epsilon = 0.03 $, 随机种子 $789$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[ \\text{result1}, \\text{result2}, \\text{result3} ]$），其中每个结果都是一个布尔值，指示相应测试用例中局部细致平衡和全局能量守恒的综合通过情况。",
            "solution": "问题陈述经评估是有效的。它在计算辐射传输领域提出了一个适定的、有科学依据的问题。所有必需的参数、物理原理和数值程序都得到了清晰和正确的定义。任务是为一维、周期性、等温的参与介质实现一个标准的光子蒙特卡洛 (PMC) 模拟，以验证全局能量守恒和局部细致平衡的原理，这些是在此类系统中辐射平衡的基本推论。\n\n解决方案的核心是一个 PMC 算法，它模拟大量能量包（光子）的生命周期。模拟域是一个长度为 $L$ 的平板，被离散成 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀单元。每个单元 $i$ 的特征是一个恒定的吸收系数 $\\kappa_i$。\n\n该模拟通过追踪 $N_p$ 个独立光子包从发射到吸收的过程来进行。对每个光子包，执行以下步骤：\n\n1.  **发射：**发射过程基于局部热力学平衡 (LTE) 的原理进行建模。\n    -   **源单元选择：**一个光子包从单元 $i$ 发射的概率与该单元的总发射量成正比。在 LTE 中，光谱发射系数为 $j = \\kappa B$，其中 $B$ 是普朗克函数。对于均匀温度 $T$，$B$ 在整个平板中是恒定的。单元 $i$ 的总发射量与 $\\kappa_i V_i$ 成正比，其中 $V_i$ 是单元体积。在这个一维问题中，$V_i$ 与单元宽度 $\\Delta x$ 成正比，而 $\\Delta x$ 是恒定的。因此，从单元 $i$ 发射的概率 $P(i)$ 由下式给出：\n        $$\n        P(i) = \\frac{\\kappa_i}{\\sum_{j=0}^{N-1} \\kappa_j}\n        $$\n        从该离散概率分布中采样一个源单元，其索引为 $i_{\\text{emit}}$。然后，该单元的发射计数器 $E_{i_{\\text{emit}}}$ 递增。\n    -   **位置和方向：**发射位置 $x_{\\text{emit}}$ 在源单元的边界 $[i_{\\text{emit}}\\Delta x, (i_{\\text{emit}}+1)\\Delta x]$ 内从均匀分布中采样。行进方向沿一维轴是各向同性的，意味着光子包有相等的概率沿 $+x$ 或 $-x$ 方向行进。相应地采样一个方向变量 $d \\in \\{-1, 1\\}$。\n\n2.  **吸收路径采样：**光子包在被吸收前行进的光程，或称光深 $\\tau$，是一个随机变量。在参与介质中，光子包穿过光深 $\\tau$ 后被吸收的概率遵循指数分布 $p(\\tau) = e^{-\\tau}$。这可以使用逆变换采样法高效地进行采样。从均匀分布 $\\mathcal{U}(0,1)$ 中抽取一个随机数 $u$，到吸收点的光深计算如下：\n    $$\n    \\tau_{\\text{abs}} = -\\ln(u)\n    $$\n    这个采样得到的 $\\tau_{\\text{abs}}$ 代表光子包在被吸收前必须行进的总光学路径长度。\n\n3.  **传播和吸收：**从发射点开始逐个单元地追踪光子包，直到其累积光程等于 $\\tau_{\\text{abs}}$。\n    -   设光子包的当前状态由其位置 $x_{\\text{pos}}$、当前单元索引 $i_{\\text{cell}}$ 和剩余待行进光深 $\\tau_{\\text{rem}}$（初始化为 $\\tau_{\\text{abs}}$）定义。\n    -   在传播的每一步中，计算沿行进方向到下一个单元边界的物理距离 $\\Delta s$。\n    -   该路径段的光学厚度为 $\\tau_{\\text{path}} = \\kappa_{i_{\\text{cell}}} \\Delta s$。\n    -   将该段的光学厚度与剩余光深进行比较：\n        -   如果 $\\tau_{\\text{rem}} \\le \\tau_{\\text{path}}$，光子包在当前单元 $i_{\\text{cell}}$ 内被吸收。该单元的吸收计数器 $A_{i_{\\text{cell}}}$ 递增，光子包的模拟结束。\n        -   如果 $\\tau_{\\text{rem}} > \\tau_{\\text{path}}$，光子包穿过该路径段并到达单元边界。剩余光深减少 $\\tau_{\\text{path}}$：$\\tau_{\\text{rem}} \\leftarrow \\tau_{\\text{rem}} - \\tau_{\\text{path}}$。光子包的状态（$x_{\\text{pos}}$, $i_{\\text{cell}}$）被更新，以反映其在下一个单元边界的新位置。施加周期性边界条件：一个在 $x=L$ 处离开的光子包会从 $x=0$ 处重新进入，一个在 $x=0$ 处离开的光子包会从 $x=L$ 处重新进入。此过程重复进行，直到光子包被吸收。\n\n4.  **验证：**在所有 $N_p$ 个光子包都被模拟之后，对统计的发射计数 $E_i$ 和吸收计数 $A_i$ 进行分析。\n    -   **全局能量守恒：**根据构造，每个发射的光子包都会被追踪直到被吸收。因此，总吸收数必须等于总发射数：$\\sum_i A_i = \\sum_i E_i = N_p$。检查 $|\\sum_i A_i - \\sum_i E_i| = 0$ 可作为对算法记账的基本合理性检查。\n    -   **局部细致平衡：**辐射平衡中的细致平衡原理意味着，平均而言，每个单元的吸收率等于其发射率。在蒙特卡洛模拟中，这意味着期望的吸收计数 $\\langle A_i \\rangle$ 应等于期望的发射计数 $\\langle E_i \\rangle$。我们通过计算每个单元的最大相对差异来验证统计涨落是否在给定的容差 $\\epsilon$ 之内：\n        $$\n        \\max_{i} \\left( \\frac{|A_i - E_i|}{\\max(E_i, 1)} \\right) \\le \\epsilon\n        $$\n        在分母中使用 $\\max(E_i, 1)$ 可以防止在某个单元没有发射这种不太可能发生的情况下出现除以零的错误。一个测试用例当且仅当全局和局部检查都满足时才算通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, L, kappa, N_p, epsilon, seed):\n    \"\"\"\n    Runs a 1D Photon Monte Carlo simulation for a periodic, isothermal slab.\n\n    Args:\n        N (int): Number of cells.\n        L (float): Length of the slab (m).\n        kappa (np.ndarray): Array of absorption coefficients for each cell (m^-1).\n        N_p (int): Number of photon packets to simulate.\n        epsilon (float): Tolerance for local detailed balance check.\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        bool: True if both global energy conservation and local detailed balance pass.\n    \"\"\"\n    np.random.seed(seed)\n\n    # 1. Setup\n    dx = L / N\n    E = np.zeros(N, dtype=np.int64)\n    A = np.zeros(N, dtype=np.int64)\n\n    # Pre-calculate emission probabilities and cell indices\n    kappa_sum = np.sum(kappa)\n    if kappa_sum == 0:\n        # If all kappa are zero, no emission can occur.\n        # This case is trivial and passes by definition.\n        return True\n    emission_probs = kappa / kappa_sum\n    cell_indices = np.arange(N)\n\n    # 2. Main Monte Carlo loop over all photon packets\n    for _ in range(N_p):\n        # 2a. Emission\n        # Select emission cell based on probabilities proportional to kappa\n        i_emit = np.random.choice(cell_indices, p=emission_probs)\n        E[i_emit] += 1\n\n        # Select random position within the cell\n        pos = (i_emit + np.random.rand()) * dx\n\n        # Select random direction (-1 for -x, +1 for +x)\n        direction = 1 if np.random.rand() > 0.5 else -1\n\n        # Sample optical depth to absorption from P(tau) = exp(-tau)\n        tau_remaining = -np.log(np.random.rand())\n\n        # 2b. Propagation until absorption\n        current_cell_idx = i_emit\n        current_pos = pos\n\n        while True:\n            kappa_current = kappa[current_cell_idx]\n\n            # Calculate distance to the next cell boundary along the direction of travel\n            if direction == 1:\n                dist_to_boundary = (current_cell_idx + 1) * dx - current_pos\n            else:  # direction == -1\n                dist_to_boundary = current_pos - current_cell_idx * dx\n            \n            # Clamp small negative distances that can arise from floating point issues\n            if dist_to_boundary  0:\n                dist_to_boundary = 0.0\n            \n            # Calculate optical thickness to the boundary\n            tau_to_boundary = kappa_current * dist_to_boundary\n\n            if tau_remaining = tau_to_boundary:\n                # Absorption occurs in the current cell\n                A[current_cell_idx] += 1\n                break  # End this packet's life\n            else:\n                # Packet traverses the cell and crosses the boundary\n                tau_remaining -= tau_to_boundary\n\n                # Update position and cell index, applying periodic boundaries\n                if direction == 1:\n                    pos_at_boundary = (current_cell_idx + 1) * dx\n                    current_cell_idx = (current_cell_idx + 1) % N\n                    # If we cross x=L, the new position is x=0\n                    current_pos = pos_at_boundary if pos_at_boundary  L else 0.0\n                else:  # direction == -1\n                    pos_at_boundary = current_cell_idx * dx\n                    current_cell_idx = (current_cell_idx - 1 + N) % N\n                    # If we cross x=0, the new position is x=L\n                    current_pos = pos_at_boundary if pos_at_boundary > 0.0 else L\n\n    # 3. Verification\n    # 3a. Global energy conservation (should always hold by construction)\n    global_pass = (np.sum(A) == np.sum(E))\n\n    # 3b. Local detailed balance\n    # Use np.maximum to avoid division by zero for cells with no emissions\n    rel_diff = np.abs(A - E) / np.maximum(E.astype(float), 1.0)\n    max_rel_diff = np.max(rel_diff)\n    local_pass = max_rel_diff = epsilon\n\n    return global_pass and local_pass\n\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test cases specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        # (N, L, kappa_def, N_p, epsilon, seed)\n        (10, 1.0, {\"type\": \"uniform\", \"val\": 2.0}, 50000, 0.03, 123),\n        (10, 1.0, {\"type\": \"uniform\", \"val\": 100.0}, 50000, 0.03, 456),\n        (10, 1.0, {\"type\": \"heterogeneous\", \"vals\": [0.5] * 5 + [2.0] * 5}, 50000, 0.03, 789),\n    ]\n\n    results = []\n    for N, L, kappa_def, N_p, epsilon, seed in test_cases:\n        if kappa_def[\"type\"] == \"uniform\":\n            kappa = np.full(N, kappa_def[\"val\"], dtype=float)\n        else: # \"heterogeneous\"\n            kappa = np.array(kappa_def[\"vals\"], dtype=float)\n        \n        # Run simulation and store the boolean result\n        result = run_simulation(N, L, kappa, N_p, epsilon, seed)\n        results.append(str(result))\n\n    # Format the final output as a single-line string\n    # Python's str(True) is \"True\", which is not what might be expected for some contexts,\n    # but for this problem it's fine. If lowercase were needed, map(str.lower, results) would be used.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}