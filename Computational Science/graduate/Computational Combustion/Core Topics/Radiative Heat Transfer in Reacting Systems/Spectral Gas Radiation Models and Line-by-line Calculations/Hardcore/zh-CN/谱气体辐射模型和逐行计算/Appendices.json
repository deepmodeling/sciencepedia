{
    "hands_on_practices": [
        {
            "introduction": "光谱线的强度并非一个常数，而是随温度发生显著变化。这种依赖性对于精确模拟具有大温度梯度的环境（如火焰）中的辐射至关重要。通过从第一性原理推导谱线强度 $S(T)$ 的表达式，您将更深入地理解统计力学和辐射传输之间的相互作用，这是逐线（line-by-line）模型的基础 。",
            "id": "4066431",
            "problem": "使用逐线光谱辐射模型分析一个均匀、等温、光学薄的水蒸气板。考虑水蒸气主要同位素体（$\\text{H}_2^{16}\\text{O}$）的一次跃迁，其线心波数为 $\\nu_0$，低能态能量为 $E''$。目标是计算随温度变化的谱线强度 $S(T)$，并将计算值与代表高分辨率透射分子吸收数据库（HITRAN）表中的参考值进行比较。\n\n从分子跃迁的基本统计力学和辐射传输原理出发，不使用简化公式，基于以下几点推导积分谱线强度 $S(T)$ 的温度依赖性：\n- 低能态布居的玻尔兹曼分布。\n- 内配分函数 $Q(T)$。\n- 受激发射校正。\n然后，用标准温度 $T_0$ 下的已知参考强度 $S(T_0)$ 来表示 $S(T)$，并消除任何未知的跃迁特定常数。\n\n使用以下物理上一致的参数和常数：\n- 标准温度 $T_0 = 296\\ \\mathrm{K}$。\n- 已知参考强度 $S(T_0) = 1.5\\times 10^{-22}\\ \\mathrm{cm}^{-1}/(\\mathrm{molecule}\\cdot \\mathrm{cm}^{-2})$。\n- 线心波数 $\\nu_0 = 3800\\ \\mathrm{cm}^{-1}$。\n- 低能态能量 $E'' = 500\\ \\mathrm{cm}^{-1}$。\n- 第二辐射常数 $c_2 = \\dfrac{h c}{k_{\\mathrm{B}}}$，其中 $c_2 = 1.438776877\\ \\mathrm{cm}\\cdot \\mathrm{K}$。\n- $\\text{H}_2^{16}\\text{O}$ 在测试温度下的配分函数值：\n  - $Q(150\\ \\mathrm{K}) = 83.49$\n  - $Q(296\\ \\mathrm{K}) = 174.12$\n  - $Q(1000\\ \\mathrm{K}) = 1197.00$\n  - $Q(2000\\ \\mathrm{K}) = 4605.00$\n\n定义与一个参考 HITRAN 风格表的比较，该表与相同的物理原理一致构建，但使用一个取整的第二辐射常数 $c_2^{\\mathrm{ref}} = 1.4387770\\ \\mathrm{cm}\\cdot \\mathrm{K}$。比较温度为：\n- $T = 296\\ \\mathrm{K}$ （一致性检查），\n- $T = 150\\ \\mathrm{K}$ （低温边缘），\n- $T = 1000\\ \\mathrm{K}$ （典型高温燃烧应用），\n- $T = 2000\\ \\mathrm{K}$ （与燃烧相关的极端高温）。\n\n您的任务：\n1. 从第一性原理出发，推导用 $S(T_0)$、$E''$、$\\nu_0$、$Q(T)$、$Q(T_0)$ 和 $c_2$ 表示的 $S(T)$ 表达式。\n2. 实现此表达式，使用提供的 $Q(T)$ 值和常数计算 $T \\in \\{150\\ \\mathrm{K}, 296\\ \\mathrm{K}, 1000\\ \\mathrm{K}, 2000\\ \\mathrm{K}\\}$ 时的 $S(T)$。\n3. 使用相同的表达式，但用 $c_2^{\\mathrm{ref}}$ 代替 $c_2$，为相同温度构建参考强度 $S_{\\mathrm{ref}}(T)$。\n4. 计算每个测试温度下的相对偏差为\n   $$\\delta(T) = \\dfrac{S(T) - S_{\\mathrm{ref}}(T)}{S_{\\mathrm{ref}}(T)}.$$\n5. 按 $[296\\ \\mathrm{K}, 150\\ \\mathrm{K}, 1000\\ \\mathrm{K}, 2000\\ \\mathrm{K}]$ 的顺序报告四个 $\\delta(T)$ 的值。\n\n物理单位和数值要求：\n- 谱线强度 $S(T)$ 必须以 $\\mathrm{cm}^{-1}/(\\mathrm{molecule}\\cdot \\mathrm{cm}^{-2})$ 为单位计算。\n- 温度以 $\\mathrm{K}$ 为单位。\n- 波数和低能态能量以 $\\mathrm{cm}^{-1}$ 为单位。\n- 相对偏差 $\\delta(T)$ 是无单位的小数值。\n\n测试套件和最终输出规范：\n- 使用上面列出的四个温度作为测试套件。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4]$），其中每个 $x_i$ 是按指定顺序为相应温度计算出的 $\\delta(T)$。",
            "solution": "用户要求推导和计算水蒸气单次转振跃迁的温度依赖谱线强度，然后进行比较，以突显对第二辐射常数 $c_2$ 的敏感性。\n\n### 步骤 1：问题验证\n\n**提取已知条件：**\n- 标准温度：$T_0 = 296\\ \\mathrm{K}$。\n- $T_0$ 下的参考强度：$S(T_0) = 1.5\\times 10^{-22}\\ \\mathrm{cm}^{-1}/(\\mathrm{molecule}\\cdot \\mathrm{cm}^{-2})$。\n- 线心波数：$\\nu_0 = 3800\\ \\mathrm{cm}^{-1}$。\n- 低能态能量：$E'' = 500\\ \\mathrm{cm}^{-1}$。\n- 第二辐射常数：$c_2 = \\dfrac{h c}{k_{\\mathrm{B}}} = 1.438776877\\ \\mathrm{cm}\\cdot \\mathrm{K}$。\n- 参考第二辐射常数：$c_2^{\\mathrm{ref}} = 1.4387770\\ \\mathrm{cm}\\cdot \\mathrm{K}$。\n- $\\text{H}_2^{16}\\text{O}$ 的配分函数值：\n  - $Q(296\\ \\mathrm{K}) = 174.12$\n  - $Q(150\\ \\mathrm{K}) = 83.49$\n  - $Q(1000\\ \\mathrm{K}) = 1197.00$\n  - $Q(2000\\ \\mathrm{K}) = 4605.00$\n- 测试温度：$T \\in \\{150\\ \\mathrm{K}, 296\\ \\mathrm{K}, 1000\\ \\mathrm{K}, 2000\\ \\mathrm{K}\\}$。\n- 相对偏差公式：$\\delta(T) = \\dfrac{S(T) - S_{\\mathrm{ref}}(T)}{S_{\\mathrm{ref}}(T)}$。\n- $\\delta(T)$ 的要求输出顺序：$[296\\ \\mathrm{K}, 150\\ \\mathrm{K}, 1000\\ \\mathrm{K}, 2000\\ \\mathrm{K}]$。\n\n**验证评估：**\n该问题具有科学依据，提法明确且客观。它基于统计力学和辐射传输的基本原理，特别是玻尔兹曼分布和受激发射，这些是逐线光谱模型的核心。所有必要的数据和常数都已提供，其数值对于水蒸气跃迁是物理上现实的。任务具体，所需的计算能得出唯一且有意义的解。该问题不包含说明中列出的任何无效缺陷。\n\n**结论：**\n该问题有效。\n\n### 步骤 2：温度依赖谱线强度 $S(T)$ 的推导\n\n谱线的积分谱线强度 $S(T)$ 是衡量特定跃迁中每个分子的总吸收量的指标。对于从用双撇号（$''$）表示的低能态到用单撇号（$'$）表示的高能态的跃迁，温度 $T$ 下的强度可以表示为：\n$$ S(T) = (\\text{常数}) \\times (\\text{低能态布居}) \\times (\\text{受激发射校正}) $$\n常数项包括基本常数和跃迁特定的性质，如爱因斯坦系数，这些都与温度无关。\n\n1.  **低能态布居**：根据玻尔兹曼分布，在热平衡温度 $T$ 下，处于简并度为 $g''$ 的低能态 $E''$ 的分子分数由下式给出：\n    $$ N_{E''} = \\frac{g'' \\exp\\left(-\\frac{E''}{k_{\\mathrm{B}} T}\\right)}{Q(T)} $$\n    其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$Q(T) = \\sum_i g_i \\exp(-E_i / k_{\\mathrm{B}} T)$ 是总内配分函数，它对所有可能的能态 $i$ 求和。\n\n2.  **受激发射校正**：净辐射吸收必须同时考虑从低能态的吸收和从高能态的受激发射。校正因子由 $\\left(1 - \\frac{N_{E'} g''}{N_{E''} g'}\\right)$ 给出，其中 $N_{E'}$ 是高能态的布居分数。使用玻尔兹曼分布来表示布居比，这变为：\n    $$ 1 - \\exp\\left(-\\frac{E' - E''}{k_{\\mathrm{B}} T}\\right) $$\n    能态之间的能量差通过 $E' - E'' = h c \\nu_0$ 与线心波数 $\\nu_0$ 相关，其中 $h$ 是普朗克常数，$c$ 是光速。因此，校正项为：\n    $$ 1 - \\exp\\left(-\\frac{h c \\nu_0}{k_{\\mathrm{B}} T}\\right) $$\n\n将这些部分组合起来，谱线强度 $S(T)$ 的形式为：\n$$ S(T) = C \\cdot \\frac{1}{Q(T)} \\cdot \\exp\\left(-\\frac{E''}{k_{\\mathrm{B}} T}\\right) \\cdot \\left[1 - \\exp\\left(-\\frac{h c \\nu_0}{k_{\\mathrm{B}} T}\\right)\\right] $$\n其中 $C$ 是一个与温度无关的、特定于该跃迁的常数。为了便于计算，我们引入第二辐射常数 $c_2 = \\frac{h c}{k_{\\mathrm{B}}}$，单位为 $\\mathrm{cm}\\cdot\\mathrm{K}$。请注意，为使量纲正确，能量项（如 $E''$）和波数（$\\nu_0$）必须以 $\\mathrm{cm}^{-1}$ 为单位表示。$S(T)$ 的表达式变为：\n$$ S(T) = C \\frac{\\exp(-c_2 E'' / T)}{Q(T)} \\left[1 - \\exp(-c_2 \\nu_0 / T)\\right] $$\n\n为了消除未知常数 $C$，我们用标准温度 $T_0$ 下的已知参考强度 $S(T_0)$ 构建一个比率：\n$$ \\frac{S(T)}{S(T_0)} = \\frac{C \\frac{\\exp(-c_2 E'' / T)}{Q(T)} \\left[1 - \\exp(-c_2 \\nu_0 / T)\\right]}{C \\frac{\\exp(-c_2 E'' / T_0)}{Q(T_0)} \\left[1 - \\exp(-c_2 \\nu_0 / T_0)\\right]} $$\n常数 $C$ 被消去。重新整理以求解 $S(T)$，得到所需的表达式：\n$$ S(T) = S(T_0) \\frac{Q(T_0)}{Q(T)} \\frac{\\exp(-c_2 E'' / T)}{\\exp(-c_2 E'' / T_0)} \\frac{1 - \\exp(-c_2 \\nu_0 / T)}{1 - \\exp(-c_2 \\nu_0 / T_0)} $$\n这可以更紧凑地写为：\n$$ S(T) = S(T_0) \\frac{Q(T_0)}{Q(T)} \\exp\\left[-c_2 E''\\left(\\frac{1}{T} - \\frac{1}{T_0}\\right)\\right] \\frac{1 - \\exp(-c_2 \\nu_0 / T)}{1 - \\exp(-c_2 \\nu_0 / T_0)} $$\n这是用于计算的最终表达式。它基于配分函数的缩放、低能态玻尔兹曼布居和受激发射校正，正确地模拟了谱线强度的温度依赖性。\n\n### 步骤 3：相对偏差 $\\delta(T)$ 的推导\n\n问题要求计算用 $c_2$ 计算的谱线强度 $S(T)$ 与用 $c_2^{\\mathrm{ref}}$ 计算的参考强度 $S_{\\mathrm{ref}}(T)$ 之间的相对偏差 $\\delta(T)$。\n$$ \\delta(T) = \\frac{S(T) - S_{\\mathrm{ref}}(T)}{S_{\\mathrm{ref}}(T)} = \\frac{S(T)}{S_{\\mathrm{ref}}(T)} - 1 $$\n$S_{\\mathrm{ref}}(T)$ 的表达式与 $S(T)$ 的表达式相同，只是用 $c_2^{\\mathrm{ref}}$ 替换了 $c_2$：\n$$ S_{\\mathrm{ref}}(T) = S(T_0) \\frac{Q(T_0)}{Q(T)} \\exp\\left[-c_2^{\\mathrm{ref}} E''\\left(\\frac{1}{T} - \\frac{1}{T_0}\\right)\\right] \\frac{1 - \\exp(-c_2^{\\mathrm{ref}} \\nu_0 / T)}{1 - \\exp(-c_2^{\\mathrm{ref}} \\nu_0 / T_0)} $$\n当我们取比值 $S(T) / S_{\\mathrm{ref}}(T)$ 时，公共项 $S(T_0)$ 和 $\\frac{Q(T_0)}{Q(T)}$ 会消去：\n$$ \\frac{S(T)}{S_{\\mathrm{ref}}(T)} = \\frac{\\exp\\left[-c_2 E''\\left(\\frac{1}{T} - \\frac{1}{T_0}\\right)\\right]}{\\exp\\left[-c_2^{\\mathrm{ref}} E''\\left(\\frac{1}{T} - \\frac{1}{T_0}\\right)\\right]} \\cdot \\frac{\\frac{1 - \\exp(-c_2 \\nu_0 / T)}{1 - \\exp(-c_2 \\nu_0 / T_0)}}{\\frac{1 - \\exp(-c_2^{\\mathrm{ref}} \\nu_0 / T)}{1 - \\exp(-c_2^{\\mathrm{ref}} \\nu_0 / T_0)}} $$\n这可以简化为：\n$$ \\frac{S(T)}{S_{\\mathrm{ref}}(T)} = \\exp\\left[(c_2^{\\mathrm{ref}} - c_2) E''\\left(\\frac{1}{T} - \\frac{1}{T_0}\\right)\\right] \\cdot \\frac{1 - \\exp(-c_2 \\nu_0 / T)}{1 - \\exp(-c_2^{\\mathrm{ref}} \\nu_0 / T)} \\cdot \\frac{1 - \\exp(-c_2^{\\mathrm{ref}} \\nu_0 / T_0)}{1 - \\exp(-c_2 \\nu_0 / T_0)} $$\n然后通过从此比率中减去 1 来计算相对偏差 $\\delta(T)$。在 $T=T_0$ 的特殊情况下，项 $\\left(\\frac{1}{T} - \\frac{1}{T_0}\\right)$ 变为零，所有比率都变为 1。因此，$\\frac{S(T_0)}{S_{\\mathrm{ref}}(T_0)} = 1$，且 $\\delta(T_0) = 0$，正如预期。\n\n### 步骤 4：实现与计算\n\n推导出的 $\\delta(T)$ 表达式将用 Python 实现。将使用提供的常数 $c_2$ 和 $c_2^{\\mathrm{ref}}$ 对每个指定温度进行计算，并按要求的顺序报告结果。使用高精度浮点运算来精确捕捉微小的差异。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the fractional deviation in line intensity due to a small\n    difference in the second radiation constant, c2.\n    \"\"\"\n\n    # Define the physical parameters and constants from the problem statement.\n    T0 = 296.0  # Standard temperature in K\n    # S_T0 is not needed for the delta calculation, but included for completeness.\n    # S_T0 = 1.5e-22  # Reference intensity in cm^-1/(molecule.cm^-2)\n    nu0 = 3800.0  # Line center wavenumber in cm^-1\n    E_pp = 500.0  # Lower-state energy (E'') in cm^-1\n\n    # Second radiation constants in cm.K\n    c2 = 1.438776877\n    c2_ref = 1.4387770\n\n    # Test temperatures in the required output order\n    test_temperatures = [296.0, 150.0, 1000.0, 2000.0]\n\n    # The partition function values Q(T) are not needed for the calculation\n    # of the fractional deviation delta(T) as they cancel out in the ratio.\n\n    # List to store the results\n    results = []\n\n    # Loop through each test temperature to compute the fractional deviation\n    for T in test_temperatures:\n        # For the case T = T0, the deviation is exactly zero by definition.\n        if T == T0:\n            delta = 0.0\n            results.append(delta)\n            continue\n\n        # Calculate the ratio S(T) / S_ref(T) using the derived formula.\n        # This formula directly computes the ratio, avoiding intermediate calculations\n        # of S(T) and S_ref(T), which improves numerical stability.\n\n        # Term 1: Contribution from the Boltzmann factor for the lower state population\n        boltzmann_ratio_exp = (c2_ref - c2) * E_pp * (1.0/T - 1.0/T0)\n        boltzmann_ratio = np.exp(boltzmann_ratio_exp)\n\n        # Term 2: Ratio of stimulated emission corrections at temperature T\n        stim_emission_num_T = 1.0 - np.exp(-c2 * nu0 / T)\n        stim_emission_den_T = 1.0 - np.exp(-c2_ref * nu0 / T)\n        stim_emission_ratio_T = stim_emission_num_T / stim_emission_den_T\n\n        # Term 3: Ratio of stimulated emission corrections at reference temperature T0\n        stim_emission_num_T0 = 1.0 - np.exp(-c2_ref * nu0 / T0)\n        stim_emission_den_T0 = 1.0 - np.exp(-c2 * nu0 / T0)\n        stim_emission_ratio_T0 = stim_emission_num_T0 / stim_emission_den_T0\n        \n        # The total ratio of line intensities S(T) / S_ref(T)\n        s_ratio = boltzmann_ratio * stim_emission_ratio_T * stim_emission_ratio_T0\n\n        # The fractional deviation is the ratio minus 1\n        delta = s_ratio - 1.0\n        results.append(delta)\n\n    # Format the final output as a comma-separated list in brackets.\n    # The str() conversion ensures standard decimal representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在真实气体中，光谱线会因热运动（多普勒效应）和分子碰撞（压力效应）而增宽，形成Voigt线型。本练习聚焦于对这一基本线型进行数值表征，这是高保真光谱模型的基石。掌握Voigt线型的宽度和峰值高度等性质的计算，是在燃烧学和大气科学中实现和解释逐线计算的一项基本技能 。",
            "id": "4066433",
            "problem": "考虑计算燃烧学中逐线光谱辐射模拟所处理的均匀等温气体元中的一条孤立谱线。该线型是由热多普勒展宽（由高斯函数建模）和碰撞压力展宽（由洛伦兹函数建模）的卷积产生的。设光谱坐标为波数 $\\tilde{\\nu}$，单位为 $\\mathrm{cm^{-1}}$。定义单位面积的高斯线型核函数 $G(\\tilde{\\nu};\\sigma)$ 和单位面积的洛伦兹线型核函数 $L(\\tilde{\\nu};\\gamma)$，其中 $\\sigma$ 是高斯标准差，$\\gamma$ 是洛伦兹半峰半宽（Half Width at Half Maximum, HWHM）。Voigt线型 $V(\\tilde{\\nu};\\sigma,\\gamma)$ 是如下卷积\n$$\nV(\\tilde{\\nu};\\sigma,\\gamma) = \\int_{-\\infty}^{+\\infty} G(\\xi;\\sigma)\\,L(\\tilde{\\nu}-\\xi;\\gamma)\\,\\mathrm{d}\\xi.\n$$\n假设给定了多普勒半峰半宽 $\\,\\alpha_D\\,$，它与高斯标准差的关系为\n$$\n\\sigma = \\frac{\\alpha_D}{\\sqrt{2\\ln 2}}.\n$$\n假设压力展宽参数 $\\,\\gamma_L\\,$ 是洛伦兹半峰半宽。\n\n从这些定义和Voigt线型的卷积结构出发（不使用问题陈述中提供的任何目标快捷公式），编写一个程序，对一组参数对 $(\\alpha_D,\\gamma_L)$ 进行数值计算：\n\n- $V(\\tilde{\\nu};\\sigma,\\gamma)$ 的半峰全宽（Full Width at Half Maximum, FWHM），记为 $\\,\\mathrm{FWHM}(\\alpha_D,\\gamma_L)\\,$，单位为 $\\mathrm{cm^{-1}}$，以及\n- 谱线中心 $\\tilde{\\nu}=0$ 处的峰值 $\\,V(0;\\sigma,\\gamma)\\,$，单位为 $\\mathrm{cm}$（请注意，振幅单位是波数单位的倒数）。\n\n你的程序必须实现一个数值稳健的方法来计算通用 $(\\alpha_D,\\gamma_L)$ 下的 $V(\\tilde{\\nu};\\sigma,\\gamma)$，然后通过求解方程\n$$\nV(\\tilde{\\nu}_{1/2};\\sigma,\\gamma) = \\frac{1}{2}V(0;\\sigma,\\gamma),\n$$\n的正根 $\\tilde{\\nu}_{1/2}>0$ 来确定 $\\,\\mathrm{FWHM}(\\alpha_D,\\gamma_L)\\,$，并使用 $\\mathrm{FWHM} = 2\\,\\tilde{\\nu}_{1/2}$。你的方法必须能正确处理其中一种展宽消失的极限情况（$\\gamma_L=0$ 时的纯高斯分布和 $\\alpha_D=0$ 时的纯洛伦兹分布），并与基本定义保持一致。\n\n将 $\\mathrm{FWHM}$ 值以 $\\mathrm{cm^{-1}}$ 表示，峰值以 $\\mathrm{cm}$ 表示，并将所有报告的数字四舍五入到 $6$ 位小数。\n\n测试套件：\n- 情况 $\\,1\\,$：$(\\alpha_D,\\gamma_L) = (0.05, 0.0)$，单位 $\\mathrm{cm^{-1}}$。\n- 情况 $\\,2\\,$：$(\\alpha_D,\\gamma_L) = (0.05, 0.01)$，单位 $\\mathrm{cm^{-1}}$。\n- 情况 $\\,3\\,$：$(\\alpha_D,\\gamma_L) = (0.05, 0.05)$，单位 $\\mathrm{cm^{-1}}$。\n- 情况 $\\,4\\,$：$(\\alpha_D,\\gamma_L) = (0.05, 0.20)$，单位 $\\mathrm{cm^{-1}}$。\n- 情况 $\\,5\\,$：$(\\alpha_D,\\gamma_L) = (0.0, 0.05)$，单位 $\\mathrm{cm^{-1}}$。\n\n覆盖性设计：情况 $\\,1\\,$ 探测纯高斯极限；情况 $\\,2\\,$ 为高斯主导；情况 $\\,3\\,$ 探索过渡区域；情况 $\\,4\\,$ 为洛伦兹主导；情况 $\\,5\\,$ 探测纯洛伦兹极限。这些情况共同展示了通过宽度和峰值的行为从类高斯形状到类洛伦兹形状的过渡。\n\n最终输出格式：你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，按顺序输出两个数字：首先是 $\\mathrm{FWHM}$（单位 $\\mathrm{cm^{-1}}$），然后是峰值 $V(0)$（单位 $\\mathrm{cm}$）。整个列表按顺序排列测试用例 $\\,1$ 到 $\\,5$。例如，输出必须具有以下形式\n$$\n[\\mathrm{FWHM}_1,\\mathrm{Peak}_1,\\mathrm{FWHM}_2,\\mathrm{Peak}_2,\\mathrm{FWHM}_3,\\mathrm{Peak}_3,\\mathrm{FWHM}_4,\\mathrm{Peak}_4,\\mathrm{FWHM}_5,\\mathrm{Peak}_5],\n$$\n每个条目四舍五入到 $6$ 位小数。",
            "solution": "用户提供的问题已经过验证，被确定为计算物理和谱线建模领域中一个定义明确、具有科学依据的问题。它要求数值计算 Voigt 剖面的关键属性，这在光谱学中是基础性的。\n\n完整的解决方案从第一性原理推导如下。\n\n**1. 问题阐述**\n\n任务是为几组多普勒和碰撞展宽参数 $(\\alpha_D, \\gamma_L)$ 计算 Voigt 线型 $V(\\tilde{\\nu};\\sigma,\\gamma)$ 的峰值 $V(0;\\sigma,\\gamma)$ 和半峰全宽（FWHM）。Voigt 剖面是代表热（多普勒）展宽的高斯剖面 $G(\\tilde{\\nu};\\sigma)$ 和代表碰撞（压力）展宽的洛伦兹剖面 $L(\\tilde{\\nu};\\gamma)$ 的卷积。\n\n**2. 本构线型核函数**\n\n问题陈述指出核函数的面积为单位1。其标准定义如下：\n\n模拟多普勒展宽的高斯核函数由下式给出：\n$$\nG(\\tilde{\\nu};\\sigma) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{\\tilde{\\nu}^2}{2\\sigma^2}\\right)\n$$\n这里，$\\tilde{\\nu}$ 是波数，单位为 $\\mathrm{cm^{-1}}$，$\\sigma$ 是高斯标准差。问题通过公式 $\\sigma = \\alpha_D / \\sqrt{2\\ln 2}$ 将 $\\sigma$ 与多普勒半峰半宽（HWHM）$\\alpha_D$ 联系起来。这种纯高斯剖面的 FWHM 是 $2\\alpha_D$。\n\n模拟压力展宽的洛伦兹核函数由下式给出：\n$$\nL(\\tilde{\\nu};\\gamma) = \\frac{1}{\\pi} \\frac{\\gamma}{\\tilde{\\nu}^2 + \\gamma^2}\n$$\n这里，$\\gamma$ 是洛伦兹 HWHM，在问题中被指定为 $\\gamma_L$。这种纯洛伦兹剖面的 FWHM 是 $2\\gamma_L$。\n\n$G(\\tilde{\\nu};\\sigma)$ 和 $L(\\tilde{\\nu};\\gamma)$ 的单位都是 $(\\mathrm{cm^{-1}})^{-1}$，即 $\\mathrm{cm}$，这确保了它们在 $\\tilde{\\nu}$ 上的积分为无量纲。\n\n**3. Voigt 剖面计算**\n\nVoigt 剖面 $V(\\tilde{\\nu};\\sigma,\\gamma)$ 是卷积：\n$$\nV(\\tilde{\\nu};\\sigma,\\gamma) = (G * L)(\\tilde{\\nu}) = \\int_{-\\infty}^{+\\infty} G(\\xi;\\sigma)\\,L(\\tilde{\\nu}-\\xi;\\gamma)\\,\\mathrm{d}\\xi\n$$\n虽然这个积分可以进行数值计算，但一种更稳健且计算上更标准的方法依赖于 Faddeeva 函数，也称为复补余误差函数 $w(z)$。Voigt 剖面可以表示为具有适当缩放的 Faddeeva 函数的实部：\n$$\nV(\\tilde{\\nu};\\sigma,\\gamma) = \\frac{\\text{Re}[w(z)]}{\\sigma\\sqrt{2\\pi}}\n$$\n其中复数参数 $z$ 定义为：\n$$\nz = \\frac{\\tilde{\\nu} + i\\gamma}{\\sigma\\sqrt{2}}\n$$\n这种表示法在数值上是稳定的，并在像 SciPy 这样的标准科学库中得到实现。由于两个单位面积函数的卷积结果是一个单位面积函数，这种 $V$ 的表示法正确地保持了单位面积。\n\n**4. 峰值和半峰全宽的计算**\n\n对于给定的参数对 $(\\alpha_D, \\gamma_L)$，我们首先计算所需的剖面参数 $\\sigma = \\alpha_D / \\sqrt{2\\ln 2}$ 和 $\\gamma = \\gamma_L$。\n\n**峰值, $V(0)$**:\nVoigt 剖面的峰值出现在谱线中心，即 $\\tilde{\\nu}=0$ 处。\n$$\nV(0;\\sigma,\\gamma) = V(\\tilde{\\nu}=0;\\sigma,\\gamma) = \\frac{\\text{Re}\\left[w\\left(\\frac{i\\gamma}{\\sigma\\sqrt{2}}\\right)\\right]}{\\sigma\\sqrt{2\\pi}}\n$$\n该值使用 Faddeeva 函数直接计算。\n\n**半峰全宽 (FWHM)**:\nFWHM 定义为 $2\\tilde{\\nu}_{1/2}$，其中 $\\tilde{\\nu}_{1/2}$ 是剖面值为其峰值一半时的正波数。我们必须对以下非线性方程求解 $\\tilde{\\nu}_{1/2}$：\n$$\nV(\\tilde{\\nu}_{1/2};\\sigma,\\gamma) = \\frac{1}{2}V(0;\\sigma,\\gamma)\n$$\n这个方程没有通用的闭式解析解，必须进行数值求解。一种可靠的方法是使用求根算法，如 Brent 方法，对函数 $f(\\tilde{\\nu}) = V(\\tilde{\\nu};\\sigma,\\gamma) - \\frac{1}{2}V(0;\\sigma,\\gamma)$ 进行求解。由于 $V(\\tilde{\\nu})$ 是一个偶函数、正函数，并且对于 $\\tilde{\\nu}>0$ 单调递减，因此保证存在唯一的正根 $\\tilde{\\nu}_{1/2}$。\n\n**5. 极限情况的处理**\n\n问题要求一个稳健的实现，能够正确处理一种展宽机制消失的极限情况。与其依赖通用数值方法处理接近零的参数，不如为这些纯粹情况实现解析解，这样更准确、更稳健。\n\n**情况 1：纯高斯剖面 ($\\gamma_L = 0, \\alpha_D > 0$)**\nVoigt 剖面退化为高斯核函数，$V(\\tilde{\\nu};\\sigma,0) = G(\\tilde{\\nu};\\sigma)$。\n- **FWHM**：从解析上已知 FWHM 为 $2\\sigma\\sqrt{2\\ln 2}$。使用给定的关系 $\\sigma = \\alpha_D / \\sqrt{2\\ln 2}$，FWHM 精确为 $2\\alpha_D$。\n- **峰值**：峰值为 $G(0) = \\frac{1}{\\sigma\\sqrt{2\\pi}}$。代入 $\\sigma$，我们得到 $V(0) = \\frac{\\sqrt{2\\ln 2}}{\\alpha_D\\sqrt{2\\pi}} = \\frac{\\sqrt{\\ln 2 / \\pi}}{\\alpha_D}$。\n\n**情况 2：纯洛伦兹剖面 ($\\alpha_D = 0, \\gamma_L > 0$)**\n在此极限下，$\\sigma \\to 0$，高斯核函数趋近于狄拉克δ函数 $\\delta(\\tilde{\\nu})$。任何函数与 $\\delta(\\tilde{\\nu})$ 的卷积都是该函数本身。因此，Voigt 剖面退化为洛伦兹核函数，$V(\\tilde{\\nu};0,\\gamma) = L(\\tilde{\\nu};\\gamma)$。\n- **FWHM**：根据其 HWHM $\\gamma_L$ 的定义，洛伦兹分布的 FWHM 精确为 $2\\gamma_L$。\n- **峰值**：峰值为 $L(0) = \\frac{1}{\\pi\\gamma_L}$。\n\n**6. 算法总结**\n\n对于每个测试用例 $(\\alpha_D, \\gamma_L)$，实现将遵循以下步骤：\n1.  检查是否 $\\gamma_L = 0$。如果是，则应用纯高斯情况的解析公式。\n2.  检查是否 $\\alpha_D = 0$。如果是，则应用纯洛伦兹情况的解析公式。\n3.  对于 $\\alpha_D > 0$ 和 $\\gamma_L > 0$ 的一般（混合）情况：\n    a.  计算 $\\sigma = \\alpha_D / \\sqrt{2\\ln 2}$。\n    b.  定义一个函数 `voigt(nu, ...)`，使用 `scipy.special.wofz` 计算 Voigt 剖面。\n    c.  通过调用 `voigt(0, ...)` 计算 `peak_value`。\n    d.  定义一个目标函数 `f(nu) = voigt(nu, ...) - 0.5 * peak_value`。\n    e.  使用数值求根器（`scipy.optimize.root_scalar`，采用 Brent 方法）在一个合适的区间内（例如 $[0, 10(\\alpha_D + \\gamma_L)]$）找到 `f(nu)=0` 的根 $\\tilde{\\nu}_{1/2}$。\n    f.  FWHM 为 $2 \\times \\tilde{\\nu}_{1/2}$。\n4.  存储计算出的 FWHM 和峰值。\n5.  处理完所有情况后，将结果格式化为具有指定精度和结构的单个字符串。\n\n这种方法忠实于线型理论的第一性原理，数值上稳健，并能正确处理所有指定的物理状态。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import wofz\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves for the FWHM and peak value of the Voigt profile for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.05, 0.0),   # Case 1: Pure Gaussian\n        (0.05, 0.01),  # Case 2: Gaussian-dominated\n        (0.05, 0.05),  # Case 3: Transitional\n        (0.05, 0.20),  # Case 4: Lorentzian-dominated\n        (0.0, 0.05)    # Case 5: Pure Lorentzian\n    ]\n\n    all_results = []\n    \n    for alpha_D, gamma_L in test_cases:\n        fwhm, peak = calculate_voigt_properties(alpha_D, gamma_L)\n        all_results.append(fwhm)\n        all_results.append(peak)\n\n    # Format the final output string with 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_voigt_properties(alpha_D, gamma_L):\n    \"\"\"\n    Calculates the FWHM and peak value for a given set of Doppler and Lorentz HWHMs.\n\n    Args:\n        alpha_D (float): Doppler Half Width at Half Maximum (HWHM).\n        gamma_L (float): Lorentzian Half Width at Half Maximum (HWHM).\n\n    Returns:\n        tuple: A tuple containing the FWHM and the peak value.\n    \"\"\"\n    # Handle the pure Gaussian limit analytically.\n    if gamma_L == 0.0 and alpha_D > 0.0:\n        fwhm = 2.0 * alpha_D\n        peak = np.sqrt(np.log(2.0) / np.pi) / alpha_D\n        return fwhm, peak\n\n    # Handle the pure Lorentzian limit analytically.\n    if alpha_D == 0.0 and gamma_L > 0.0:\n        fwhm = 2.0 * gamma_L\n        peak = 1.0 / (np.pi * gamma_L)\n        return fwhm, peak\n    \n    # Handle the pathological case of no broadening. Not in test suite.\n    if alpha_D == 0.0 and gamma_L == 0.0:\n        return 0.0, np.inf\n\n    # General Voigt profile calculation for the mixed case.\n    sigma = alpha_D / np.sqrt(2.0 * np.log(2.0))\n\n    def voigt(nu):\n        \"\"\"Computes the Voigt profile V(nu) using the Faddeeva function.\"\"\"\n        # The argument for the Faddeeva function w(z)\n        z = (nu + 1j * gamma_L) / (sigma * np.sqrt(2.0))\n        # The Voigt profile is proportional to the real part of w(z).\n        # Normalization ensures the profile has unit area.\n        return np.real(wofz(z)) / (sigma * np.sqrt(2.0 * np.pi))\n\n    # The peak value is at the line center (nu = 0).\n    peak_value = voigt(0.0)\n\n    # Define the equation whose root gives the HWHM.\n    def half_max_equation(nu):\n        return voigt(nu) - 0.5 * peak_value\n\n    # Find the HWHM (nu_half) by finding the root of the equation.\n    # The Voigt profile is monotonically decreasing, so a root is guaranteed.\n    # A generous but safe upper bound for the search bracket is chosen.\n    # A small positive lower bound is used to avoid any issues at nu=0.\n    search_bracket = [1e-9, 10.0 * (alpha_D + gamma_L)]\n    try:\n        sol = root_scalar(half_max_equation, bracket=search_bracket, method='brentq')\n        nu_half = sol.root\n    except ValueError:\n        # Fallback if the initial bracket is not wide enough, though unlikely\n        sol = root_scalar(half_max_equation, bracket=[1e-9, 100.0 * (alpha_D + gamma_L)], method='brentq')\n        nu_half = sol.root\n\n\n    # FWHM is twice the HWHM.\n    fwhm = 2.0 * nu_half\n\n    return fwhm, peak_value\n\n# Execute the main function.\nsolve()\n```"
        },
        {
            "introduction": "虽然理解单条光谱线至关重要，但实际应用需要对包含成千上万条谱线的整个光谱带进行建模。本实践将单线分析扩展到多线系统，研究数值网格分辨率如何影响关键宏观辐射特性（如普朗克平均吸收系数 $k_P$）的准确性。这个动手问题旨在解决计算辐射学中的一个关键挑战：在准确性和计算成本之间取得平衡，要求您确定可靠捕捉光谱带物理特性所需的最低数值分辨率 。",
            "id": "4066442",
            "problem": "考虑波数空间中的一个一维谱带，由变量 $\\,\\sigma\\,$ 表示，单位为 $\\mathrm{cm}^{-1}$。一种气体的吸收系数由一组 $\\,N_\\ell\\,$ 条离散谱线建模，每条谱线由一个压力展宽的 Lorentz 剖面表示。光谱吸收系数定义为\n$$\nk(\\sigma) \\;=\\; \\sum_{i=1}^{N_\\ell} S_i \\, L\\!\\left(\\sigma;\\sigma_i,\\gamma_i\\right),\n$$\n其中 $\\,S_i\\,$ 是谱线强度，$\\,\\sigma_i\\,$ 是谱线中心，$\\,\\gamma_i\\,$ 是半峰半宽（HWHM）展宽参数。Lorentz 线型由下式给出\n$$\nL\\!\\left(\\sigma;\\sigma_i,\\gamma_i\\right) \\;=\\; \\frac{1}{\\pi}\\,\\frac{\\gamma_i}{(\\sigma-\\sigma_i)^2+\\gamma_i^2},\n$$\n其被归一化，使得 $\\,\\int_{-\\infty}^{\\infty} L(\\sigma;\\sigma_i,\\gamma_i)\\,d\\sigma \\;=\\; 1\\,$.\n\n设波数形式的 Planck 函数为\n$$\nB_\\sigma(T) \\;=\\; \\frac{2 h c^2 \\sigma^3}{\\exp\\!\\left(\\frac{h c \\sigma}{k_B T}\\right) - 1},\n$$\n其中 $\\,h\\,$ 是 Planck 常数，$\\,c\\,$ 是光速，$\\,k_B\\,$ 是 Boltzmann 常数，$\\,T\\,$ 是绝对温度。在本问题中，为保持一致性，$\\,\\sigma\\,$ 的单位为 $\\mathrm{cm}^{-1}$，$\\,c\\,$ 的单位应取 $\\mathrm{cm/s}$。\n\n定义在有限波数区间 $[\\sigma_a,\\sigma_b]$ 上的谱带积分吸收为\n$$\nI \\;=\\; \\int_{\\sigma_a}^{\\sigma_b} k(\\sigma)\\,d\\sigma,\n$$\n以及谱带限制的 Planck 平均吸收系数为\n$$\nk_P(T;\\sigma_a,\\sigma_b) \\;=\\; \\frac{\\int_{\\sigma_a}^{\\sigma_b} k(\\sigma)\\,B_\\sigma(T)\\,d\\sigma}{\\int_{\\sigma_a}^{\\sigma_b} B_\\sigma(T)\\,d\\sigma}.\n$$\n\n在计算实践中，这些积分使用梯形法则在均匀网格上进行近似。然而，分辨率不足（即相对于狭窄的光谱特征，网格点过少）可能会导致显著误差。您的任务是分析分辨率不足对 $\\,I\\,$ 的影响，并确定在指定的相对误差容差下，获得稳健的 Planck 平均值 $\\,k_P\\,$ 所需的最小网格密度（谱带上的均匀点数）。\n\n从以上定义出发，仅使用公认的物理定律（例如 Planck 函数）和标准数值积分方法（例如梯形法则），实现一个程序，该程序：\n- 利用 Lorentz 剖面在有限区间上的性质，解析计算精确的谱带积分吸收 $\\,I\\,$。\n- 使用数值精确的谱带积分（而非粗糙的梯形和）计算 $\\,k_P\\,$ 的高精度参考值，并将此参考值与在逐步加密的均匀网格上的梯形法则近似值进行比较。\n- 确定最小网格点数 $\\,N_{\\min}\\,$，使得梯形法则计算的 $\\,k_P\\,$ 的相对误差小于或等于指定的容差 $\\,\\tau\\,$。\n- 通过报告在指定的粗糙网格尺寸 $\\,N_{\\text{coarse}}\\,$ 下 $\\,I\\,$ 的梯形近似的相对误差，来量化分辨率不足对 $\\,I\\,$ 的影响。\n\n所有报告的误差必须是无量纲的相对误差，形式为\n$$\n\\varepsilon_X \\;=\\; \\left|\\frac{X_{\\text{approx}} - X_{\\text{ref}}}{X_{\\text{ref}}}\\right|,\n$$\n其中 $\\,X\\,$ 酌情代表 $\\,I\\,$ 或 $\\,k_P\\,$。$\\,I\\,$ 的参考值必须是解析的有限区间 Lorentz 积分，而 $\\,k_P\\,$ 的参考值必须是使用非梯形法则的高精度方法进行的数值精确积分。\n\n您的程序必须为以下三个测试用例生成结果。在所有情况下，$\\,S_i\\,$ 的单位都与 $\\,k(\\sigma)\\,$ 的单位一致，以确保 Lorentz 剖面的归一化得到遵守；除 $\\,N_{\\min}\\,$ 是网格点的整数计数外，所有输出均为无量纲。\n\n测试用例 1（通用“理想路径”）:\n- 谱带: $[\\sigma_a,\\sigma_b] = [2200,\\,2400]$ in $\\mathrm{cm}^{-1}$。\n- 温度: $\\,T = 1800\\,$ K。\n- 谱线: \n  - $\\,(\\sigma_1,S_1,\\gamma_1) = (2280,\\,1.0,\\,0.25)$,\n  - $\\,(\\sigma_2,S_2,\\gamma_2) = (2350,\\,0.6,\\,0.15)$,\n  - $\\,(\\sigma_3,S_3,\\gamma_3) = (2390,\\,0.8,\\,0.40)$。\n- 用于 $\\,I\\,$ 误差的粗糙网格: $\\,N_{\\text{coarse}} = 400$。\n- Planck 平均值容差: $\\,\\tau = 0.01$。\n\n测试用例 2（边界和分辨率不足压力测试，使用非常窄的谱线）:\n- 谱带: $[\\sigma_a,\\sigma_b] = [2199.5,\\,2200.5]$ in $\\mathrm{cm}^{-1}$。\n- 温度: $\\,T = 1200\\,$ K。\n- 谱线:\n  - $\\,(\\sigma_1,S_1,\\gamma_1) = (2200.0,\\,1.5,\\,0.01)$,\n  - $\\,(\\sigma_2,S_2,\\gamma_2) = (2199.7,\\,0.7,\\,0.008)$。\n- 用于 $\\,I\\,$ 误差的粗糙网格: $\\,N_{\\text{coarse}} = 50$。\n- Planck 平均值容差: $\\,\\tau = 0.01$。\n\n测试用例 3（混合宽度和强度，在不同谱带上的灵敏度）:\n- 谱带: $[\\sigma_a,\\sigma_b] = [3500,\\,3600]$ in $\\mathrm{cm}^{-1}$。\n- 温度: $\\,T = 800\\,$ K。\n- 谱线:\n  - $\\,(\\sigma_1,S_1,\\gamma_1) = (3525,\\,0.2,\\,0.05)$,\n  - $\\,(\\sigma_2,S_2,\\gamma_2) = (3555,\\,1.8,\\,0.20)$,\n  - $\\,(\\sigma_3,S_3,\\gamma_3) = (3599,\\,0.5,\\,0.03)$,\n  - $\\,(\\sigma_4,S_4,\\gamma_4) = (3570,\\,0.1,\\,0.005)$。\n- 用于 $\\,I\\,$ 误差的粗糙网格: $\\,N_{\\text{coarse}} = 300$。\n- Planck 平均值容差: $\\,\\tau = 0.01$。\n\n算法要求:\n- 在均匀网格上使用梯形法则，以指定的网格密度近似计算 $\\,I\\,$ 和 $\\,k_P\\,$ 的积分。\n- 使用高精度数值积分器为每个谱带构建 $\\,k_P\\,$ 的参考值。\n- 从候选集 $\\,\\{64,\\,128,\\,256,\\,512,\\,1024,\\,2048,\\,4096,\\,8192,\\,16384\\}\\,$ 中，将满足容差要求的最小网格尺寸确定为 $\\,N_{\\min}\\,$。如果没有一个满足容差，则将 $\\,N_{\\min}\\,$ 取为最大的候选值，并报告所达到的误差。\n\n最终输出要求:\n- 您的程序应生成单行输出，按顺序包含九个结果\n  $$\n  [\\varepsilon_I^{(1)}, \\varepsilon_{k_P}^{(1)}, N_{\\min}^{(1)}, \\varepsilon_I^{(2)}, \\varepsilon_{k_P}^{(2)}, N_{\\min}^{(2)}, \\varepsilon_I^{(3)}, \\varepsilon_{k_P}^{(3)}, N_{\\min}^{(3)}],\n  $$\n  其中上标表示测试用例索引。浮点值必须打印为标准小数，网格计数必须为整数，所有值用逗号分隔并括在方括号中。不得打印任何额外文本。所有误差输出均为如上定义的无量纲数。网格计数是不带单位的纯整数。",
            "solution": "该问题要求分析在计算气体辐射特性时数值分辨率不足的影响。具体而言，我们需要量化谱带积分吸收 $I$ 的误差，并确定在指定容差内计算 Planck 平均吸收系数 $k_P$ 所需的最小网格分辨率 $N_{\\min}$。该分析将针对三个不同的测试用例进行。解决方案结合了解析积分、高精度数值积分和在均匀网格上使用梯形法则。\n\n首先，我们定义必要的物理和数学函数。光谱吸收系数 $k(\\sigma)$ 由 $N_\\ell$ 个 Lorentz 剖面之和给出：\n$$\nk(\\sigma) = \\sum_{i=1}^{N_\\ell} S_i \\, L(\\sigma;\\sigma_i,\\gamma_i)\n$$\n其中 $S_i$ 是谱线强度，$\\sigma_i$ 是谱线中心，$\\gamma_i$ 是半峰半宽（HWHM）。归一化的 Lorentz 线型函数 $L(\\sigma;\\sigma_i,\\gamma_i)$ 为：\n$$\nL(\\sigma;\\sigma_i,\\gamma_i) = \\frac{1}{\\pi}\\,\\frac{\\gamma_i}{(\\sigma-\\sigma_i)^2+\\gamma_i^2}\n$$\n热辐射由波数形式的 Planck 函数 $B_\\sigma(T)$ 描述：\n$$\nB_\\sigma(T) = \\frac{2 h c^2 \\sigma^3}{\\exp\\left(\\frac{h c \\sigma}{k_B T}\\right) - 1}\n$$\n其中 $h$、 $c$ 和 $k_B$ 分别是 Planck 常数、光速和 Boltzmann 常数。\n\n主要关注的量是在波数区间 $[\\sigma_a, \\sigma_b]$ 上定义的谱带积分吸收 $I$ 和谱带限制的 Planck 平均吸收系数 $k_P$：\n$$\nI = \\int_{\\sigma_a}^{\\sigma_b} k(\\sigma)\\,d\\sigma \\quad \\text{和} \\quad k_P(T;\\sigma_a,\\sigma_b) = \\frac{\\int_{\\sigma_a}^{\\sigma_b} k(\\sigma)\\,B_\\sigma(T)\\,d\\sigma}{\\int_{\\sigma_a}^{\\sigma_b} B_\\sigma(T)\\,d\\sigma}\n$$\n\n对于每个测试用例，解决方案分三个主要步骤进行。\n\n首先，我们为谱带积分吸收建立一个参考值 $I_{\\text{ref}}$。这通过在有限区间 $[\\sigma_a, \\sigma_b]$ 上对 Lorentz 剖面之和进行解析积分来实现。单个 Lorentz 剖面的积分是一个反正切函数：\n$$\n\\int_{\\sigma_a}^{\\sigma_b} L(\\sigma;\\sigma_i,\\gamma_i)\\,d\\sigma = \\frac{1}{\\pi} \\left[ \\arctan\\left(\\frac{\\sigma_b - \\sigma_i}{\\gamma_i}\\right) - \\arctan\\left(\\frac{\\sigma_a - \\sigma_i}{\\gamma_i}\\right) \\right]\n$$\n对所有谱线求和，得到精确值 $I_{\\text{ref}} = \\sum_i S_i \\int_{\\sigma_a}^{\\sigma_b} L(\\sigma;\\sigma_i,\\gamma_i)\\,d\\sigma$。然后，我们使用梯形法则在一个包含 $N_{\\text{coarse}}$ 个点的粗糙网格上计算数值近似值 $I_{\\text{approx}}$。相对误差 $\\varepsilon_I$ 计算为 $\\varepsilon_I = |(I_{\\text{approx}} - I_{\\text{ref}}) / I_{\\text{ref}}|$。\n\n其次，我们确定 Planck 平均吸收系数的高精度参考值 $k_{P, \\text{ref}}$。定义 $k_P$ 的分子和分母积分均使用稳健的数值积分方法计算，`scipy.integrate.quad` 是一个绝佳的选择。该函数实现了一种提供高精度的自适应求积方案。为提高其稳健性，特别是对于具有非常窄谱线（小的 $\\gamma_i$）的测试用例，谱线中心的位置 $\\sigma_i$ 作为被积函数可能困难的点被提供。这会产生分子的参考值 $N_{\\text{ref}} = \\int_{\\sigma_a}^{\\sigma_b} k(\\sigma)\\,B_\\sigma(T)\\,d\\sigma$ 和分母的参考值 $D_{\\text{ref}} = \\int_{\\sigma_a}^{\\sigma_b} B_\\sigma(T)\\,d\\sigma$，从中可以找到 $k_{P, \\text{ref}} = N_{\\text{ref}} / D_{\\text{ref}}$。\n\n第三，我们从指定的候选集 $\\{64, 128, \\dots, 16384\\}$ 中找到最小网格点数 $N_{\\min}$，该点数要求 $k_P$ 的梯形近似达到的相对误差 $\\varepsilon_{k_P}$ 小于或等于给定的容差 $\\tau = 0.01$。我们按升序遍历候选的网格尺寸。对于每个尺寸 $N$，我们构建一个从 $\\sigma_a$ 到 $\\sigma_b$ 的 $\\sigma$ 值的均匀网格，并在这些网格点上计算被积函数 $k(\\sigma)B_\\sigma(T)$ 和 $B_\\sigma(T)$。使用 `numpy.trapz` 中实现的梯形法则来近似分子 $N_{\\text{approx}}$ 和分母 $D_{\\text{approx}}$，从而得到 $k_{P, \\text{approx}} = N_{\\text{approx}} / D_{\\text{approx}}$。然后计算相对误差 $\\varepsilon_{k_P} = |(k_{P, \\text{approx}} - k_{P, \\text{ref}}) / k_{P, \\text{ref}}|$。第一个满足 $\\varepsilon_{k_P} \\le \\tau$ 的 $N$ 值被选为 $N_{\\min}$。如果没有候选网格尺寸满足容差，则将 $N_{\\min}$ 取为集合中的最大尺寸（16384），并报告在此分辨率下达到的误差。\n\n此过程被系统地应用于所提供的三个测试用例中的每一个，并且结果——$\\varepsilon_I$、与所选 $N_{\\min}$ 对应的最终 $\\varepsilon_{k_P}$ 和 $N_{\\min}$ 本身——被收集用于最终输出。该实现将使用 `numpy` 进行数值数组和操作，并使用 `scipy.integrate` 进行高精度参考计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the three test cases.\n    It encapsulates all logic as required.\n    \"\"\"\n\n    # Physical constants\n    H = 6.62607015e-34  # Planck's constant in J*s\n    C = 2.99792458e10   # Speed of light in cm/s\n    KB = 1.380649e-23     # Boltzmann's constant in J/K\n\n    def lorentz_profile(sigma, sigma_i, gamma_i):\n        \"\"\"Computes the Lorentz line shape L(sigma; sigma_i, gamma_i).\"\"\"\n        return (1.0 / np.pi) * (gamma_i / ((sigma - sigma_i)**2 + gamma_i**2))\n\n    def absorption_coefficient(sigma, lines):\n        \"\"\"Computes the spectral absorption coefficient k(sigma).\"\"\"\n        if isinstance(sigma, (int, float)):\n            k_val = 0.0\n        else:\n            k_val = np.zeros_like(sigma, dtype=float)\n        \n        for sigma_i, S_i, gamma_i in lines:\n            k_val += S_i * lorentz_profile(sigma, sigma_i, gamma_i)\n        return k_val\n\n    def planck_function(sigma, T):\n        \"\"\"Computes the Planck function B_sigma(T).\"\"\"\n        c2 = H * C / KB  # Second radiation constant in cm*K\n        exponent = c2 * sigma / T\n        # Handle potential overflow in exp, though unlikely with given inputs\n        # np.exp handles large values, returning inf.\n        with np.errstate(over='ignore'):\n            denominator = np.exp(exponent) - 1.0\n        # Prevent division by zero if denominator is zero (at sigma=0, or T=inf)\n        denominator[denominator == 0] = np.inf\n        numerator = 2.0 * H * C**2 * sigma**3\n        return numerator / denominator\n\n    def analytic_I_ref(sigma_a, sigma_b, lines):\n        \"\"\"Computes the analytical band-integrated absorption I_ref.\"\"\"\n        total_I = 0.0\n        for sigma_i, S_i, gamma_i in lines:\n            term_b = np.arctan((sigma_b - sigma_i) / gamma_i)\n            term_a = np.arctan((sigma_a - sigma_i) / gamma_i)\n            total_I += (S_i / np.pi) * (term_b - term_a)\n        return total_I\n\n    def solve_case(case_params):\n        \"\"\"Processes a single test case and returns the required results.\"\"\"\n        sigma_a, sigma_b = case_params[\"band\"]\n        T = case_params[\"T\"]\n        lines = case_params[\"lines\"]\n        N_coarse = case_params[\"N_coarse\"]\n        tau = case_params[\"tau\"]\n        N_candidates = [64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384]\n\n        # --- Part 1: Calculate relative error in I at N_coarse ---\n        I_ref = analytic_I_ref(sigma_a, sigma_b, lines)\n        \n        sigma_coarse_grid = np.linspace(sigma_a, sigma_b, N_coarse)\n        k_coarse_vals = absorption_coefficient(sigma_coarse_grid, lines)\n        I_approx_coarse = np.trapz(k_coarse_vals, x=sigma_coarse_grid)\n        \n        eps_I = np.abs((I_approx_coarse - I_ref) / I_ref) if I_ref != 0 else 0.0\n\n        # --- Part 2: Find N_min and corresponding error for k_P ---\n        # Define integrands for high-accuracy reference calculation\n        line_centers = [line[0] for line in lines]\n        \n        def k_B_integrand(s):\n            return absorption_coefficient(s, lines) * planck_function(np.array([s]), T)[0]\n\n        def B_integrand(s):\n            return planck_function(np.array([s]), T)[0]\n\n        # High-accuracy reference k_P using scipy.integrate.quad\n        k_B_integral_ref, _ = integrate.quad(k_B_integrand, sigma_a, sigma_b, points=line_centers)\n        B_integral_ref, _ = integrate.quad(B_integrand, sigma_a, sigma_b)\n        \n        k_P_ref = k_B_integral_ref / B_integral_ref if B_integral_ref != 0 else 0.0\n\n        # Find N_min by iterating through candidate grid sizes\n        N_min = -1\n        eps_kP_at_Nmin = -1.0\n\n        for N in N_candidates:\n            sigma_grid = np.linspace(sigma_a, sigma_b, N)\n            k_vals = absorption_coefficient(sigma_grid, lines)\n            B_vals = planck_function(sigma_grid, T)\n            \n            k_B_integral_approx = np.trapz(k_vals * B_vals, x=sigma_grid)\n            B_integral_approx = np.trapz(B_vals, x=sigma_grid)\n            \n            k_P_approx = k_B_integral_approx / B_integral_approx if B_integral_approx != 0 else 0.0\n            \n            current_eps_kP = np.abs((k_P_approx - k_P_ref) / k_P_ref) if k_P_ref != 0 else 0.0\n            eps_kP_at_Nmin = current_eps_kP\n            \n            if current_eps_kP = tau:\n                N_min = N\n                break\n        \n        if N_min == -1: # Tolerance not met by any candidate\n            N_min = N_candidates[-1]\n        \n        return eps_I, eps_kP_at_Nmin, N_min\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"band\": [2200.0, 2400.0], \"T\": 1800.0,\n            \"lines\": [ (2280.0, 1.0, 0.25), (2350.0, 0.6, 0.15), (2390.0, 0.8, 0.40) ],\n            \"N_coarse\": 400, \"tau\": 0.01\n        },\n        {\n            \"band\": [2199.5, 2200.5], \"T\": 1200.0,\n            \"lines\": [ (2200.0, 1.5, 0.01), (2199.7, 0.7, 0.008) ],\n            \"N_coarse\": 50, \"tau\": 0.01\n        },\n        {\n            \"band\": [3500.0, 3600.0], \"T\": 800.0,\n            \"lines\": [ (3525.0, 0.2, 0.05), (3555.0, 1.8, 0.20), (3599.0, 0.5, 0.03), (3570.0, 0.1, 0.005) ],\n            \"N_coarse\": 300, \"tau\": 0.01\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results_for_case = solve_case(case)\n        all_results.extend(results_for_case)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}