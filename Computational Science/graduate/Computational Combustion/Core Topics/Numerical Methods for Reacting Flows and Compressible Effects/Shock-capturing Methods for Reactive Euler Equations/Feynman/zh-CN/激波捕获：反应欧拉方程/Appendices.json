{
    "hands_on_practices": [
        {
            "introduction": "任何稳健的数值模拟都始于对控制物理定律的清晰理解。本练习将指导您推导反应流欧拉方程组的基本守恒形式，这是所有有限体积激波捕捉方法的出发点。通过显式地构建通量向量 $F(U)$ 和源项向量 $S(U)$，您将巩固对可压缩反应流中质量、动量、能量和化学组分如何输运和转化的掌握。",
            "id": "4061761",
            "problem": "考虑在计算燃烧学中用于可压缩反应流的有限体积激波捕捉法所使用的一维反应欧拉方程。守恒变量为 $U = (\\rho, \\rho u, \\rho E, \\rho Y)^{\\top}$，其中 $\\rho$ 是密度，$u$ 是速度，$E$ 是总比能，$Y$ 是反应物质量分数。假设混合物是理想气体，其状态方程（EOS）为 $p = \\rho R(T,Y) T$，其中 $p$ 是压力，$T$ 是温度，$R(T,Y)$ 是混合气体常数，它可能同时依赖于 $T$ 和 $Y$。总比能为 $E = e(T,Y) + \\frac{1}{2} u^{2}$，其中 $e(T,Y)$ 是单位质量的混合物内能。化学反应为具有阿伦尼乌斯速率的单步不可逆放热反应\n$$\\dot{\\omega} = - A \\rho Y \\exp\\!\\left(-\\frac{E_{a}}{R(T,Y) \\, T}\\right),$$\n其中 $A$ 是一个正的指前因子，$E_{a}$ 是活化能。令 $Q>0$ 表示每消耗单位质量反应物所释放的热量（即，每消耗单位质量反应物化学能的减少量为 $Q$）。\n\n从质量、动量、能量和组分的积分守恒律出发，根据所述假设推导反应欧拉系统的无粘通量矢量 $F(U)$ 和反应源项矢量 $S(U)$。用 $(\\rho, u, p, E, Y)$ 和给定的本构关系明确写出 $F(U)$ 和 $S(U)$ 的每个分量。然后，使用给定的反应速率，以 $Y$、$T$ 以及任何给定的常数和函数的形式，用闭合形式表示 $Q \\dot{\\omega}$。\n\n你的最终答案必须是包含所有要求分量的单个闭合形式解析表达式。不需要进行数值计算。如果引入了额外的热力学函数（例如 $e(T,Y)$ 或 $c_{v}(T,Y)$），请将它们保留为符号形式。最终答案请勿带单位。",
            "solution": "反应欧拉方程模拟了可压缩反应混合物的无粘动力学。它们是通过将积分形式的守恒律应用于一维控制体，并忽略粘性应力和热传导而推导出来的。我们从基本守恒律开始：\n\n1. 质量守恒：\n$$\\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial (\\rho u)}{\\partial x} = 0.$$\n\n2. 动量守恒：\n$$\\frac{\\partial (\\rho u)}{\\partial t} + \\frac{\\partial (\\rho u^{2} + p)}{\\partial x} = 0.$$\n\n3. 总能量守恒：\n$$\\frac{\\partial (\\rho E)}{\\partial t} + \\frac{\\partial \\left(u(\\rho E + p)\\right)}{\\partial x} = \\dot{q},$$\n其中 $\\dot{q}$ 是由化学反应引起的体积能量源。对于每消耗单位质量反应物释放热量 $Q>0$ 的放热反应，其能量效应是随着反应物的消耗，显能/内能的增加。组分源项 $\\dot{\\omega}$ 是为反应物质量分数方程（见下文）定义的，能量源项是 $-Q \\dot{\\omega}$，负号的出现是因为对于反应物消耗而言 $\\dot{\\omega}0$。因此，\n$$\\dot{q} = - Q \\dot{\\omega}。$$\n\n4. 反应物质量分数守恒：\n$$\\frac{\\partial (\\rho Y)}{\\partial t} + \\frac{\\partial (\\rho Y u)}{\\partial x} = \\dot{\\omega},$$\n其中 $\\dot{\\omega}$ 是单位体积内反应物的净生成率；对于消耗反应，$\\dot{\\omega}0$。\n\n为了将该系统表示为适用于激波捕捉方法的紧凑矢量形式，我们定义守恒状态矢量\n$$U = \\begin{pmatrix} \\rho \\\\ \\rho u \\\\ \\rho E \\\\ \\rho Y \\end{pmatrix}。$$\n无粘通量矢量 $F(U)$ 表示这些守恒量的对流输运。根据守恒律，相应的通量为：\n\n- 质量通量：$\\rho u$。\n- 动量通量：$\\rho u^{2} + p$。\n- 能量通量：$u(\\rho E + p)$，这来自于机械功项 $p u$ 和总能量 $\\rho E u$ 的平流。\n- 组分通量：$\\rho Y u$。\n\n因此，\n$$F(U) = \\begin{pmatrix} \\rho u \\\\ \\rho u^{2} + p \\\\ u(\\rho E + p) \\\\ \\rho Y u \\end{pmatrix}。$$\n\n源项矢量 $S(U)$ 包含由化学反应引起的非对流贡献。根据上述平衡律，源项为：\n\n- 质量源项：$0$，因为化学反应不改变总质量。\n- 动量源项：$0$，忽略了体积力和相间动量交换。\n- 能量源项：$-Q \\dot{\\omega}$。\n- 组分源项：$\\dot{\\omega}$。\n\n因此，\n$$S(U) = \\begin{pmatrix} 0 \\\\ 0 \\\\ -Q \\dot{\\omega} \\\\ \\dot{\\omega} \\end{pmatrix}。$$\n\n我们现在引入本构关系。状态方程（EOS）为\n$$p = \\rho R(T,Y) T,$$\n这定义了用 $\\rho$、$T$ 和 $Y$ 表示 $p$ 的热力学封闭。总比能 $E$ 是内能和动能之和，\n$$E = e(T,Y) + \\frac{1}{2} u^{2},$$\n其中 $e(T,Y)$ 可以保留为符号形式，这与一般的量热非完全混合物一致；在量热完全近似中，可以取 $e(T,Y) = c_{v}(Y) T$，但这里我们不施加该限制。\n\n反应速率由下式给出\n$$\\dot{\\omega} = - A \\rho Y \\exp\\!\\left(-\\frac{E_{a}}{R(T,Y) \\, T}\\right),$$\n其中 $A0$ 且 $E_{a}0$。相应的能量源项涉及 $Q \\dot{\\omega}$；明确地，\n$$Q \\dot{\\omega} = - Q A \\rho Y \\exp\\!\\left(-\\frac{E_{a}}{R(T,Y) \\, T}\\right)。$$\n\n注意符号约定：\n- 由于对于反应物消耗 $\\dot{\\omega}0$，因此 $-Q \\dot{\\omega}  0$，这意味着化学放热增加了显能/热能。\n- 能量的源项矢量分量是 $-Q \\dot{\\omega}$，组分的源项分量是 $\\dot{\\omega}$。\n\n汇总所要求的表达式：\n- 通量矢量 $F(U)$ 的分量是 $(\\rho u, \\rho u^{2} + p, u(\\rho E + p), \\rho Y u)$，其中 $p$ 由状态方程（EOS）给出，$E = e(T,Y) + \\frac{1}{2} u^{2}$。\n- 源项矢量 $S(U)$ 的分量是 $(0, 0, -Q \\dot{\\omega}, \\dot{\\omega})$。\n- 用 $Y$ 和 $T$ 表示的量 $Q \\dot{\\omega}$ 是 $- Q A \\rho Y \\exp\\!\\left(-\\frac{E_{a}}{R(T,Y) \\, T}\\right)$。\n\n这些表达式是激波捕捉方法在反应欧拉求解器中用于形成数值通量和残差所需的对流通量和反应源项。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\rho u  \\rho u^2 + p  u(\\rho E + p)  \\rho Y u  0  0  -Q \\dot{\\omega}  \\dot{\\omega}  -Q A \\rho Y \\exp\\!\\left(-\\frac{E_{a}}{R(T,Y) T}\\right) \\end{pmatrix}}$$"
        },
        {
            "introduction": "激波捕捉方法更新的是守恒变量向量 $U$，但计算通量和反应速率所需的热力学性质（如压力和温度）必须从中导出。本练习旨在解决一个关键任务：从已更新的总能量和组分构成中“反演状态方程”以求得温度 $T$。掌握这一步骤对于在求解器中将流体动力学与化学动力学耦合至关重要。",
            "id": "4061720",
            "problem": "考虑计算燃烧学中的一维反应欧拉方程，其适用于量热非完美理想气体混合物。总能量密度通过混合物内能函数与组分耦合，该函数取决于温度和成分，并与化学热释放耦合。设总能量密度为 $E$，质量密度为 $\\rho$，速度为 $u$，组分质量分数为 $Y_k$，其中组分索引 $k$ 遍历包含反应物 $R$ 和产物 $P$ 的二元混合物。单位质量混合物内能为 $e(T,Y)$，它取决于温度 $T$ 和质量分数 $Y = \\{Y_R, Y_P\\}$，其中 $Y_R + Y_P = 1$ 且 $Y_k \\in [0,1]$。总能量密度通过 $E = \\rho e(T,Y) + \\tfrac{1}{2}\\rho u^2$ 与 $e(T,Y)$ 和动能相关。与组分的耦合通过 $e(T,Y)$ 和热释放参数 $Q$ 实现。\n\n使用以下量热状态方程（EOS）闭合模型来表示内能：\n$$e(T,Y) = Y_R\\left(a_R T + \\tfrac{1}{2} b_R T^2\\right) + Y_P\\left(a_P T + \\tfrac{1}{2} b_P T^2\\right) - Q Y_P,$$\n其中 $a_R$、$b_R$、$a_P$、$b_P$ 为组分特定参数， $Q$ 为每单位质量产物的恒定热释放。压力的热力学状态方程（EOS）为 $p = \\rho R_{\\mathrm{mix}} T$，其中混合物气体常数 $R_{\\mathrm{mix}} = Y_R R_R + Y_P R_P$。尽管本任务不要求输出压力 $p$，但此关系是用于反应欧拉方程的激波捕捉方法中物理上一致的闭合模型的一部分。\n\n从基本守恒关系 $E = \\rho e(T,Y) + \\tfrac{1}{2}\\rho u^2$ 和上述量热EOS出发，通过求解方程使内能与 $e(T,Y) = (E - \\tfrac{1}{2}\\rho u^2)/\\rho$ 匹配，从而确定与给定状态 $(\\rho, E, Y)$ 和速度 $u$ 一致的温度 $T$（单位为 $\\mathrm{K}$）。计算必须确保 $T  0$ 以满足物理可容许性，这是激波捕捉方法中为保持热力学变量正性而提出的标准要求。\n\n使用以下恒定参数（所有数值均给出单位，必须遵守）：\n- $a_R = 700\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$,\n- $b_R = 0.05\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-2}$,\n- $a_P = 680\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$,\n- $b_P = 0.03\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-2}$,\n- $R_R = 287\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$,\n- $R_P = 289\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$,\n- $Q = 1{,}000{,}000\\ \\mathrm{J}\\,\\mathrm{kg}^{-1}$.\n\n您的任务是实现一个程序，对于一组测试用例，通过求解非线性方程来计算温度 $T$（单位为 $\\mathrm{K}$）：\n$$F(T; \\rho, E, u, Y_P) = Y_R\\left(a_R T + \\tfrac{1}{2} b_R T^2\\right) + Y_P\\left(a_P T + \\tfrac{1}{2} b_P T^2\\right) - Q Y_P - \\frac{E - \\tfrac{1}{2}\\rho u^2}{\\rho} = 0,$$\n其中 $Y_R = 1 - Y_P$。求解过程必须使用一种带有正温度区间的鲁棒求根方法，并且必须返回一个正温度解。\n\n科学真实性与单位：所有输入和输出必须使用国际单位制。计算出的温度必须以 $\\mathrm{K}$ 为单位表示，并四舍五入到 $6$ 位小数。\n\n测试套件。使用以下 $5$ 个测试用例，每个用例指定为 $(\\rho, E, u, Y_P)$:\n- 用例 $1$：$\\rho = 1.2\\ \\mathrm{kg}\\,\\mathrm{m}^{-3}$，$u = 50\\ \\mathrm{m}\\,\\mathrm{s}^{-1}$，$Y_P = 0.3$，$E = 500{,}700\\ \\mathrm{J}\\,\\mathrm{m}^{-3}$。\n- 用例 $2$：$\\rho = 1.0\\ \\mathrm{kg}\\,\\mathrm{m}^{-3}$，$u = 200\\ \\mathrm{m}\\,\\mathrm{s}^{-1}$，$Y_P = 0.0$，$E = 232{,}250\\ \\mathrm{J}\\,\\mathrm{m}^{-3}$。\n- 用例 $3$：$\\rho = 0.8\\ \\mathrm{kg}\\,\\mathrm{m}^{-3}$，$u = 20\\ \\mathrm{m}\\,\\mathrm{s}^{-1}$，$Y_P = 0.95$，$E = 679{,}660\\ \\mathrm{J}\\,\\mathrm{m}^{-3}$。\n- 用例 $4$：$\\rho = 0.3\\ \\mathrm{kg}\\,\\mathrm{m}^{-3}$，$u = 0\\ \\mathrm{m}\\,\\mathrm{s}^{-1}$，$Y_P = 0.5$，$E = 648{,}000\\ \\mathrm{J}\\,\\mathrm{m}^{-3}$。\n- 用例 $5$：$\\rho = 2.0\\ \\mathrm{kg}\\,\\mathrm{m}^{-3}$，$u = 0\\ \\mathrm{m}\\,\\mathrm{s}^{-1}$，$Y_P = 0.0$，$E = 353{,}125\\ \\mathrm{J}\\,\\mathrm{m}^{-3}$。\n\n每个用例的构建都与给定的EOS参数在物理上保持一致，并代表了在激波捕捉计算中遇到的混合物状态：一个典型的已燃混合物、一个未燃混合物、一个高度燃烧的高温混合物、一个低密度高温混合物，以及一个近环境低温混合物。您的程序必须为每个用例找到 $T$。\n\n最终输出格式。您的程序应生成一行输出，其中包含所有测试用例的温度，以逗号分隔的列表形式包含在方括号中，每个温度四舍五入到 $6$ 位小数，例如，$\\left[ T_1, T_2, T_3, T_4, T_5 \\right]$ 格式化为 $\\left[ \\texttt{float1},\\texttt{float2},\\texttt{float3},\\texttt{float4},\\texttt{float5} \\right]$。",
            "solution": "该问题是有效的。它提出了一个在计算热力学和燃烧学领域中科学基础扎实、适定且客观的任务。所有必要的数据和方程都已提供，形成了一个自洽且一致的系统。任务是根据给定的热力学状态（由质量密度 $\\rho$、总能量密度 $E$、速度 $u$ 和组分构成 $Y$ 指定）来确定混合物温度 $T$。这是在实现用于反应欧拉方程的激波捕捉数值方法中一个标准且基本的“反演”问题。\n\n温度的推导始于总能量密度 $E$ 的定义，它是欧拉方程中的一个守恒量。它是单位体积的内能和动能之和：\n$$E = \\rho e(T,Y) + \\frac{1}{2}\\rho u^2$$\n这里，$e(T,Y)$ 是比内能（单位质量内能），它取决于温度 $T$ 和组分质量分数集合 $Y = \\{Y_R, Y_P\\}$。给定一个状态 $(\\rho, E, u, Y)$，比内能通过整理上述关系确定：\n$$e(T,Y) = \\frac{E - \\frac{1}{2}\\rho u^2}{\\rho}$$\n这个值，我们可以表示为 $e_{\\text{spec}}$，代表了量热状态方程（EOS）必须匹配的目标值。\n\n该问题为反应物 $R$ 和产物 $P$ 的二元混合物提供了一个量热EOS。该EOS是温度的二次函数：\n$$e(T,Y) = Y_R\\left(a_R T + \\frac{1}{2} b_R T^2\\right) + Y_P\\left(a_P T + \\frac{1}{2} b_P T^2\\right) - Q Y_P$$\n其中 $Y_R$ 和 $Y_P$ 分别是反应物和产物的质量分数，受 $Y_R + Y_P = 1$ 的约束。常数 $a_R$、$b_R$、$a_P$ 和 $b_P$ 是组分比热容的经验参数，而 $Q$ 是化学反应热。\n\n为了找到给定状态下的温度 $T$，我们将比内能的两个表达式相等：\n$$Y_R\\left(a_R T + \\frac{1}{2} b_R T^2\\right) + Y_P\\left(a_P T + \\frac{1}{2} b_P T^2\\right) - Q Y_P = \\frac{E - \\frac{1}{2}\\rho u^2}{\\rho}$$\n代入 $Y_R = 1 - Y_P$ 并重新整理各项，以形成关于 $T$ 的标准多项式，得到一个二次方程：\n$$\\left[ \\frac{1}{2}(1 - Y_P)b_R + \\frac{1}{2}Y_P b_P \\right] T^2 + \\left[ (1 - Y_P)a_R + Y_P a_P \\right] T - \\left[ Q Y_P + \\frac{E - \\frac{1}{2}\\rho u^2}{\\rho} \\right] = 0$$\n这个方程是一般形式 $AT^2 + BT + C = 0$，其中系数定义为：\n$$A = \\frac{1}{2}\\left((1 - Y_P)b_R + Y_P b_P\\right)$$\n$$B = (1 - Y_P)a_R + Y_P a_P$$\n$$C = -\\left(Q Y_P + \\frac{E - \\frac{1}{2}\\rho u^2}{\\rho}\\right)$$\n\n对于一个物理上有意义的状态，我们要求 $T  0$。我们必须分析这些系数来确定根的性质。\n提供的常数是 $a_R = 700$、$b_R = 0.05$、$a_P = 680$、$b_P = 0.03$ 和 $Q = 1{,}000{,}000$，所有单位均为一致的国际单位制。所有的 $a_k$ 和 $b_k$ 都是正数。由于质量分数 $Y_P$ 被限制在区间 $[0,1]$ 内，系数 $A$ 和 $B$ 是正数的凸组合，因此对于任何有效组分都是严格为正的。\n具体来说，$A  0$ 意味着二次函数是一个开口向上的抛物线。\n常数项 $C$ 由热释放项 $-Q Y_P$ 和比内能项 $-e_{\\text{spec}}$ 组成。对于所有给定的测试用例，比内能 $e_{\\text{spec}} = (E - \\frac{1}{2}\\rho u^2)/\\rho$ 是正的。由于 $Q  0$ 且 $Y_P \\ge 0$，整个项 $C$ 是严格为负的。\n\n二次方程 $AT^2 + BT + C = 0$ 的根由二次公式给出：\n$$T = \\frac{-B \\pm \\sqrt{B^2 - 4AC}}{2A}$$\n判别式为 $\\Delta = B^2 - 4AC$。由于 $A0$ 和 $C0$，项 $-4AC$ 严格为正。因此，判别式 $\\Delta = B^2 - 4AC  B^2  0$，这保证了有两个不同的实数根。\n让我们分析这些根的符号。由于 $\\sqrt{\\Delta} = \\sqrt{B^2 - 4AC}  \\sqrt{B^2} = |B| = B$ （因为 $B0$），我们有：\n- 一个根 $T_1 = \\frac{-B + \\sqrt{\\Delta}}{2A}  0$。\n- 另一个根 $T_2 = \\frac{-B - \\sqrt{\\Delta}}{2A}  0$。\n\n因此，对于任何给定的有效状态，存在一个唯一、正值且物理上可容许的温度解。\n虽然解析二次公式提供了直接解，但问题要求使用鲁棒的求根方法，这对于更复杂的状态方程是一种更通用和可扩展的方法。一种基于二分法的方法，如 Brent 方法，是理想的选择。这需要找到一个括号区间 $[T_{\\text{low}}, T_{\\text{high}}]$，使得函数 $F(T) = AT^2 + BT + C$ 在端点处有相反的符号。\n在 $T=0$ 时，我们有 $F(0) = C  0$。由于 $A  0$，对于足够大的温度，$F(T)$ 将变为正值。因此，一个诸如 $[T_{\\epsilon}, T_{\\max}]$ 的区间，其中 $T_{\\epsilon}$ 是一个小的正温度（例如 $1\\ \\mathrm{K}$），而 $T_{\\max}$ 是一个足够高的温度（例如 $10000\\ \\mathrm{K}$），将可靠地包围唯一的正根。\n\n每个测试用例的计算过程如下：\n$1$. 对于给定的状态 $(\\rho, E, u, Y_P)$，计算目标比内能 $e_{\\text{spec}} = (E - \\frac{1}{2}\\rho u^2)/\\rho$。\n$2$. 定义函数 $F(T) = \\left[ \\frac{1}{2}((1 - Y_P)b_R + Y_P b_P) \\right] T^2 + \\left[ (1 - Y_P)a_R + Y_P a_P \\right] T - (Q Y_P + e_{\\text{spec}})$。\n$3$. 使用数值求根算法，如 `scipy.optimize.brentq`，并提供一个合适的正温度区间（例如 $[1, 10000]$）来求解 $F(T) = 0$ 以得到 $T$。\n$4$. 按要求将得到的温度四舍五入到 $6$ 位小数。\n此过程将应用于所有提供的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import optimize\n\ndef solve():\n    \"\"\"\n    Computes the temperature for a reactive gas mixture given its thermodynamic\n    state and a caloric Equation of State.\n    \"\"\"\n    \n    # Define constant parameters in SI units\n    a_R = 700.0   # J kg^-1 K^-1\n    b_R = 0.05    # J kg^-1 K^-2\n    a_P = 680.0   # J kg^-1 K^-1\n    b_P = 0.03    # J kg^-1 K^-2\n    Q = 1_000_000.0 # J kg^-1\n\n    # Test suite: each case is a tuple of (rho, E, u, Y_P) in SI units\n    # rho: kg m^-3, E: J m^-3, u: m s^-1, Y_P: dimensionless\n    test_cases = [\n        (1.2, 500_700.0, 50.0, 0.3),   # Case 1\n        (1.0, 232_250.0, 200.0, 0.0),   # Case 2\n        (0.8, 679_660.0, 20.0, 0.95),  # Case 3\n        (0.3, 648_000.0, 0.0, 0.5),    # Case 4\n        (2.0, 353_125.0, 0.0, 0.0),    # Case 5\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        rho, E, u, Y_P = case\n        \n        # Calculate the reactant mass fraction\n        Y_R = 1.0 - Y_P\n        \n        # Calculate the specific internal energy from the total energy density\n        e_spec = (E - 0.5 * rho * u**2) / rho\n        \n        # Define the function F(T) = 0 to be solved for temperature T.\n        # This function represents the difference between the caloric EOS\n        # and the target specific internal energy.\n        # F(T) = Y_R * e_R(T) + Y_P * e_P(T) - Q*Y_P - e_spec = 0\n        def temp_eos_function(T):\n            e_R = a_R * T + 0.5 * b_R * T**2\n            e_P = a_P * T + 0.5 * b_P * T**2\n            return Y_R * e_R + Y_P * e_P - Q * Y_P - e_spec\n            \n        # As derived, the equation for T is a quadratic AT^2 + BT + C = 0.\n        # The coefficients A and B are positive, and C is negative, guaranteeing\n        # a single positive root. We use a robust numerical root-finder\n        # as requested, which is good practice for more complex EOS.\n        \n        # A bracketing interval for the root. Since F(0) is negative and\n        # the parabola opens up, a root must exist for T > 0.\n        # A bracket of [1 K, 10000 K] is physically plausible and robust.\n        T_low = 1.0\n        T_high = 10000.0\n        \n        try:\n            # Use Brent's method to find the root T\n            temperature = optimize.brentq(temp_eos_function, T_low, T_high)\n            results.append(f\"{temperature:.6f}\")\n        except ValueError:\n            # This block would execute if a root is not bracketed,\n            # which we've proven should not happen for these cases.\n            results.append(\"Error\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "高阶精度是理想的，但不幸的是，它可能在激波或火焰锋面等急剧梯度附近导致非物理的解，例如负的质量分数。本练习介绍了一种实用方法，通过将无效状态投影到物理上可接受的解空间来强制施加质量分数的物理约束。您将实施这种修正并分析其影响，从而深入了解在维持精度与确保模拟的稳健性和物理真实性之间的重要权衡。",
            "id": "4061710",
            "problem": "考虑量热完全气体混合物的反应欧拉方程，其组分质量分数为 $Y_k$，其中 $k$ 为化学组分的索引，$Y_k$ 必须满足 $Y_k \\in [0,1]$ 且 $\\sum_k Y_k = 1$。在这些方程的激波捕捉离散化中，爆轰前沿附近的高阶重构可能会产生违反物理边界的临时组分质量分数。为确保物理可实现性且不破坏解的稳定性，请设计一种后处理方法，该方法通过在欧几里得意义上做出尽可能小的修正，来强制每个计算单元的 $Y_k$ 满足 $Y_k \\in [0,1]$ 且 $\\sum_k Y_k = 1$。应用此方法后，通过可量化的指标分析其对爆轰模拟中守恒性和精度的影响。\n\n您的任务是实现一个程序，该程序：\n- 接受一组预定义的临时组分质量分数向量 $Y = (Y_1,Y_2,\\dots,Y_N)$，其中 $N=3$ 种组分（燃料、氧化剂、产物），这些向量是由一个假设的激波捕捉更新在爆轰前沿附近产生的。\n- 应用一种单单元后处理方法，该方法强制 $Y_k \\ge 0$（对所有 $k$）且 $\\sum_k Y_k = 1$，同时最小化修正量的欧几里得范数。此方法不得需要除所提供的 $Y$ 值之外的任何外部数据。\n- 对燃料使用固定的单位质量热释放 $q$，$q = 4.0\\times 10^6$ 焦耳/千克 (J/kg)，并评估修正在多大程度上改变了潜在热释放密度 $q\\,Y_{\\text{fuel}}$。\n- 对每个测试用例，计算以下输出：\n    1. 一个布尔值，指示临时的 $Y$ 是否满足 $Y_k \\in [0,1]$（对所有 $k$）。\n    2. 一个布尔值，指示修正后的 $Y$ 是否满足 $Y_k \\in [0,1] $（对所有 $k$）。\n    3. 修正前的绝对和误差，$|\\sum_k Y_k - 1|$。\n    4. 修正后的绝对和误差，$|\\sum_k Y_k^{\\text{corr}} - 1|$。\n    5. 修正量的欧几里得范数，$\\|Y^{\\text{corr}} - Y\\|_2$。\n    6. 单位质量潜在热释放的变化量，$q\\,(Y_{\\text{fuel}}^{\\text{corr}} - Y_{\\text{fuel}})$，以 J/kg 表示。\n\n使用以下临时组分质量分数向量 $Y$ 的测试套件（组分顺序：燃料、氧化剂、产物）：\n- 测试用例 1：$Y = (1.05,\\,-0.02,\\,0.03)$。\n- 测试用例 2：$Y = (-0.10,\\,0.80,\\,0.50)$。\n- 测试用例 3：$Y = (0.999,\\,0.001,\\,0.0)$。\n- 测试用例 4：$Y = (-0.60,\\,1.80,\\,-0.20)$。\n\n覆盖性设计：\n- 测试用例 1 探索了和大于 1 的轻微上冲和下冲情况。\n- 测试用例 2 包含一个负分量且和大于 1。\n- 测试用例 3 是一个和等于 1 的近有效边界情况。\n- 测试用例 4 表现出剧烈振荡，违规幅度大但和等于 1。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的指标按顺序排列并展平为一个单一列表。例如，输出形式应为 $[r_{1,1},r_{1,2},\\dots,r_{1,6},r_{2,1},\\dots,r_{4,6}]$，其中 $r_{i,j}$ 是第 $i$ 个测试用例的第 $j$ 个指标。热释放变化的单位必须是焦耳/千克 (J/kg)，本问题不涉及角度。不使用百分比；所有量必须表示为布尔值或浮点数。不允许外部输入。",
            "solution": "该问题要求设计并实现一种后处理方法，用于修正因高阶数值格式在模拟反应流（如爆轰）时产生的非物理组分质量分数 $Y_k$。一个临时的状态向量 $Y = (Y_1, Y_2, \\dots, Y_N)$ 可能会违反物理约束 $Y_k \\in [0, 1]$ 和 $\\sum_{k=1}^N Y_k = 1$。修正过程必须强制满足这些约束，同时在欧几里得意义上最小化对临时状态的扰动。这是一个经典的约束优化问题，具体来说，是将一个点 $Y \\in \\mathbb{R}^N$ 投影到标准单纯形（或称概率单纯形）$\\Delta^{N-1}$ 上。\n\n标准单纯形的定义为集合 $\\Delta^{N-1} = \\{ y \\in \\mathbb{R}^N \\mid \\sum_{k=1}^N y_k = 1, y_k \\ge 0 \\}$。问题在于找到一个修正后的向量 $Y^{\\text{corr}}$，它是以下问题的解：\n$$ \\underset{Y^{\\text{corr}}}{\\text{minimize}} \\quad \\frac{1}{2} \\| Y^{\\text{corr}} - Y \\|_2^2 $$\n$$ \\text{subject to} \\quad \\sum_{k=1}^N Y^{\\text{corr}}_k = 1 \\quad \\text{and} \\quad Y^{\\text{corr}}_k \\ge 0 \\quad \\text{for } k=1, \\dots, N $$\n目标函数是欧几里得范数的平方，是严格凸函数，且约束集（单纯形）是闭合的凸集。因此，对于任意给定的向量 $Y$，都存在唯一的解。\n\n为解决这个二次规划问题，我们采用 Karush-Kuhn-Tucker (KKT) 条件。该问题的拉格朗日函数 $L$ 为：\n$$ L(Y^{\\text{corr}}, \\mu, \\lambda) = \\frac{1}{2} \\sum_{k=1}^N (Y^{\\text{corr}}_k - Y_k)^2 - \\sum_{k=1}^N \\mu_k Y^{\\text{corr}}_k - \\lambda \\left( \\sum_{k=1}^N Y^{\\text{corr}}_k - 1 \\right) $$\n此处，$\\mu_k \\ge 0$ 是非负约束 $Y^{\\text{corr}}_k \\ge 0$ 的拉格朗日乘子，而 $\\lambda$ 是关于和的等式约束的拉格朗日乘子。\n\nKKT 驻定性条件 $\\frac{\\partial L}{\\partial Y^{\\text{corr}}_k} = 0$ 给出：\n$$ Y^{\\text{corr}}_k - Y_k - \\mu_k - \\lambda = 0 \\implies Y^{\\text{corr}}_k = Y_k + \\mu_k + \\lambda $$\n互补松弛条件 $\\mu_k Y^{\\text{corr}}_k = 0$ 意味着对于每个组分 $k$：\n1. 如果 $Y^{\\text{corr}}_k  0$，则 $\\mu_k = 0$，这导致 $Y^{\\text{corr}}_k = Y_k + \\lambda$。\n2. 如果 $Y^{\\text{corr}}_k = 0$，则 $\\mu_k \\ge 0$。根据驻定性条件，$\\mu_k = -Y_k - \\lambda$。条件 $\\mu_k \\ge 0$ 意味着 $Y_k + \\lambda \\le 0$。\n\n综合这两种情况，我们可以用单个乘子 $\\lambda$ 简洁地表示每个分量 $Y^{\\text{corr}}_k$ 的解：\n$$ Y^{\\text{corr}}_k = \\max(0, Y_k + \\lambda) $$\n$\\lambda$ 的值可以通过将此表达式代入求和约束 $\\sum_{k=1}^N Y^{\\text{corr}}_k = 1$ 来确定：\n$$ \\sum_{k=1}^N \\max(0, Y_k + \\lambda) = 1 $$\n这是一个关于 $\\lambda$ 的连续、分段线性且单调递增的方程，可以被高效求解。一个简洁而鲁棒的算法可以按以下步骤找到唯一的 $\\lambda$：\n1. 将临时向量 $Y$ 的分量按降序排序：$u_1 \\ge u_2 \\ge \\dots \\ge u_N$。\n2. 找到满足以下条件的最大整数索引 $\\rho \\in \\{1, \\dots, N\\}$：\n$$ u_\\rho + \\frac{1}{\\rho} \\left( 1 - \\sum_{i=1}^\\rho u_i \\right)  0 $$\n此搜索可以通过从 $j=1$ 到 $N$ 迭代并保留使不等式成立的最后一个索引 $j$ 来执行。\n3. 利用该索引 $\\rho$，拉格朗日乘子 $\\lambda$ 由下式给出：\n$$ \\lambda = \\frac{1}{\\rho} \\left( 1 - \\sum_{i=1}^\\rho u_i \\right) $$\n4. 然后，使用原始（未排序）的 $Y_k$ 值计算修正后向量 $Y^{\\text{corr}}$ 的分量：\n$$ Y^{\\text{corr}}_k = \\max(0, Y_k + \\lambda) $$\n该算法保证了最终得到的向量 $Y^{\\text{corr}}$ 位于单纯形上，既满足正性约束也满足和为一的约束，并且是欧几里得意义上与原始向量 $Y$ 最近的点。$Y^{\\text{corr}}_k \\le 1$ 的约束会自动满足，因为如果 $Y^{\\text{corr}}_k  0$，那么对于所有 $j \\ne k$，$Y^{\\text{corr}}_j \\ge 0$，这意味着 $\\sum_{j \\ne k} Y^{\\text{corr}}_j \\ge 0$。根据求和约束，$Y^{\\text{corr}}_k = 1 - \\sum_{j \\ne k} Y^{\\text{corr}}_j \\le 1$。\n\n所要求的指标用于分析此修正方法带来的影响。用于判断有效性的布尔值以及修正前后的和误差，验证了物理约束的强制执行和质量守恒。修正量的欧几里得范数 $\\|Y^{\\text{corr}} - Y\\|_2$ 量化了临时状态的非物理性程度。潜在热释放的变化量 $q(Y_{\\text{fuel}}^{\\text{corr}} - Y_{\\text{fuel}})$ 则衡量了修正过程引入或移除非物理能量的大小。虽然最小化欧几里得范数是一个数学上合理的目标，但它并不显式地保证能量守恒，而这项指标突显了修正对化学源项的直接影响，这在爆轰建模中是一个至关重要的方面。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the species mass fraction correction problem for a predefined set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Species order: (fuel, oxidizer, product)\n    test_cases = [\n        (1.05, -0.02, 0.03),\n        (-0.10, 0.80, 0.50),\n        (0.999, 0.001, 0.0),\n        (-0.60, 1.80, -0.20),\n    ]\n\n    # Specific heat release for fuel in J/kg\n    q_fuel = 4.0e6\n\n    def project_to_simplex(y_prov):\n        \"\"\"\n        Projects a vector onto the probability simplex.\n\n        This function finds the vector y_corr on the simplex (sum of components is 1, all components non-negative)\n        that is closest to the provisional vector y_prov in the Euclidean L2 sense.\n\n        The algorithm is based on a fast projection method from Duchi et al. (2008).\n        \"\"\"\n        y_prov_np = np.asarray(y_prov)\n        n = len(y_prov_np)\n\n        # Sort the provisional vector in descending order\n        u = np.sort(y_prov_np)[::-1]\n\n        # Find the index rho\n        s = np.cumsum(u)\n        # The condition is u_j + (1/j) * (1 - s_j) > 0\n        # This is equivalent to j * u_j - s_j + 1 > 0\n        rho_vals = np.where(u + (1.0 / (np.arange(1, n + 1))) * (1 - s) > 0)[0]\n        \n        if len(rho_vals) == 0:\n            # This case should not be reached with typical inputs but included for robustness.\n            # It implies all components will be zeroed out and one will be set to 1.\n            # E.g., for very negative inputs.\n            # Setting lambda to make max(y_prov_k + lambda) = 1/n for non-negative results might be one approach,\n            # but a simpler recovery is to find the largest component and set it to 1.\n            y_corr = np.zeros(n)\n            y_corr[np.argmax(y_prov_np)] = 1.0\n            return y_corr\n\n        rho = rho_vals[-1] + 1\n\n        # Calculate the Lagrange multiplier lambda\n        # Our derivation used y_corr_k = max(0, y_k + lambda), so we calculate lambda directly.\n        lambda_val = (1.0 - s[rho - 1]) / rho\n\n        # Compute the corrected vector\n        y_corr = np.maximum(0, y_prov_np + lambda_val)\n\n        return y_corr\n\n    results = []\n    for case in test_cases:\n        y_provisional = np.array(case, dtype=float)\n        \n        # 1. Check if the provisional Y satisfies Y_k in [0,1]\n        provisional_valid = bool(np.all(y_provisional >= 0) and np.all(y_provisional = 1))\n        \n        # 3. Absolute sum error before correction\n        sum_err_before = abs(np.sum(y_provisional) - 1.0)\n        \n        # Apply the correction method\n        y_corrected = project_to_simplex(y_provisional)\n        \n        # 2. Check if the corrected Y satisfies Y_k in [0,1]\n        # This should always be true by construction, barring floating point issues.\n        # Adding a small tolerance for the sum check.\n        corrected_valid = bool(np.all(y_corrected >= 0) and np.all(y_corrected = 1.0 + 1e-9) and abs(np.sum(y_corrected) - 1.0)  1e-9)\n\n        # 4. Absolute sum error after correction\n        sum_err_after = abs(np.sum(y_corrected) - 1.0)\n        \n        # 5. Euclidean norm of the correction\n        correction_norm = np.linalg.norm(y_corrected - y_provisional)\n        \n        # 6. Change in potential heat release per unit mass (J/kg)\n        # Fuel is the first component (index 0)\n        heat_release_change = q_fuel * (y_corrected[0] - y_provisional[0])\n\n        results.extend([\n            provisional_valid,\n            corrected_valid,\n            sum_err_before,\n            sum_err_after,\n            correction_norm,\n            heat_release_change\n        ])\n\n    # Final print statement in the exact required format.\n    # Format booleans as lowercase 'true'/'false' and floats with sufficient precision.\n    formatted_results = []\n    for r in results:\n        if isinstance(r, bool):\n            formatted_results.append(str(r).lower())\n        else:\n            # Using a general format that avoids scientific notation for smaller numbers\n            formatted_results.append(f'{r:.15g}')\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}