{
    "hands_on_practices": [
        {
            "introduction": "在理论上探讨高分辨率格式的必要性之后，最直观的理解方式莫过于亲手实践。这个练习旨在通过一个经典的“方波”对流问题，让您直观地感受不同空间离散格式的优劣 。您将实现并对比三种代表性格式：产生非物理振荡的中央差分格式、稳定但过度耗散的一阶迎风格式，以及兼顾精度和单调性的高分辨率MUSCL格式。通过观察它们在处理间断时产生的数值振荡或模糊，您将深刻理解为何在计算燃烧学中，满足最大值原理（maximum principle）和保持界面锋利是如此重要。",
            "id": "4030750",
            "problem": "考虑恒速场中被动标量的一维线性平流，其由守恒律 $$\\frac{\\partial \\phi}{\\partial t} + a \\frac{\\partial \\phi}{\\partial x} = 0$$ 控制，定义在周期性域 $$x \\in [0, L)$$ 上，其中平流速度 $$a > 0$$ 为常数。标量场 $$\\phi(x, t)$$ 代表计算燃烧学中常用的有界混合分数或反应进程变量，该控制方程表示此标量在无源输运过程中的守恒。该方程的精确解保持极值原理：如果在 $$t = 0$$ 时，逐点满足 $$\\phi(x, 0) \\in [\\phi_{\\min}, \\phi_{\\max}]$$，那么对于所有 $$t \\ge 0$$，都有 $$\\phi(x, t) \\in [\\phi_{\\min}, \\phi_{\\max}]$$。在反应流模拟中，这一性质对于物理真实性至关重要，因为非物理的过冲或下冲会破坏反应速率和热力学一致性。\n\n以此为基础，构建一个离散化方案，使用二阶龙格-库塔方法（RK2），也称为霍恩方法，将 $$\\phi$$ 推进一个时间步。使用一个包含 $$N$$ 个点的均匀网格，网格间距为 $$\\Delta x = L / N$$，并采用周期性边界条件。设库朗-弗里德里希-路维数（CFL数）为 $$\\nu = a \\Delta t / \\Delta x$$，其中 $$\\Delta t$$ 是时间步长。\n\n对于空间导数 $$\\partial \\phi / \\partial x$$，考虑以下三种有限差分或有限体积离散格式：\n\n- 中心差分：$$D^{\\text{cen}} \\phi_i = \\frac{\\phi_{i+1} - \\phi_{i-1}}{2 \\Delta x}$$。\n- 迎风差分：对于 $$a > 0$$，$$D^{\\text{up}} \\phi_i = \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}$$。\n- 带minmod限制器的单调上游中心格式（MUSCL）（总变差减小（TVD））：用受限斜率 $$s_i = \\operatorname{minmod}(\\phi_i - \\phi_{i-1}, \\phi_{i+1} - \\phi_i)$$ 重构分段线性状态，其中 $$\\operatorname{minmod}(p,q) = \\begin{cases} \\operatorname{sign}(p) \\min(|p|, |q|),  \\text{if } p q > 0, \\\\ 0,  \\text{otherwise,} \\end{cases}$$ 然后计算在 $$a > 0$$ 时位于 $$x_{i+1/2}$$ 的迎风界面通量为 $$F_{i+1/2} = a \\left(\\phi_i + \\frac{1}{2} s_i\\right)$$，并定义空间算子 $$L(\\phi)_i = - \\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x}$$。\n\n使用对应于每种空间离散格式的半离散算子 $$L(\\phi)$$，通过一个RK2步长来推进解，即 $$\\phi^{(1)} = \\phi^n + \\Delta t \\, L(\\phi^n),$$ $$\\phi^{n+1} = \\phi^n + \\frac{\\Delta t}{2} \\left(L(\\phi^n) + L(\\phi^{(1)})\\right)。$$\n\n用一个有界方波剖面初始化 $$\\phi$$：对于 $$x \\in [x_a, x_b)$$，$$\\phi(x, 0) = 1$$，其他地方 $$\\phi(x, 0) = 0$$，并带有周期性环绕。选择 $$x_a$$ 和 $$x_b$$，使间断点远离域边界。初始界限为 $$\\phi_{\\min} = 0$$ 和 $$\\phi_{\\max} = 1$$。经过一个完整的RK2步长后，测量：\n- 过冲幅度 $$\\delta_{\\text{over}} = \\max\\left(0, \\max_i \\phi_i^{n+1} - 1\\right),$$\n- 下冲幅度 $$\\delta_{\\text{under}} = \\max\\left(0, 0 - \\min_i \\phi_i^{n+1}\\right),$$\n- 极值原理违背标志 $$\\mathsf{MPV} = (\\delta_{\\text{over}} > 0) \\lor (\\delta_{\\text{under}} > 0),$$\n- 总变差 $$\\operatorname{TV}(\\phi) = \\sum_{i=0}^{N-1} \\left| \\phi_{i+1} - \\phi_i \\right|$$（采用周期性索引），以及总变差增长因子 $$G_{\\text{TV}} = \\operatorname{TV}(\\phi^{n+1}) / \\operatorname{TV}(\\phi^{n})$$。\n\n你的程序必须实现这三种空间离散格式和RK2时间积分，并为以下测试套件（每个演化一个RK2时间步长）生成所要求的度量指标：\n- 测试 $$1$$ （中心差分，中等CFL数）：$$L = 1,$$ $$a = 1,$$ $$N = 200,$$ $$\\nu = 0.5,$$ $$x_a = 0.25,$$ $$x_b = 0.5$$。\n- 测试 $$2$$ （中心差分，小CFL数）：$$L = 1,$$ $$a = 1,$$ $$N = 200,$$ $$\\nu = 0.1,$$ $$x_a = 0.25,$$ $$x_b = 0.5$$。\n- 测试 $$3$$ （迎风差分，中等CFL数）：$$L = 1,$$ $$a = 1,$$ $$N = 200,$$ $$\\nu = 0.5,$$ $$x_a = 0.25,$$ $$x_b = 0.5$$。\n- 测试 $$4$$ （带minmod限制器的MUSCL，二阶强稳定保持龙格-库塔（SSP-RK2），中等CFL数）：$$L = 1,$$ $$a = 1,$$ $$N = 200,$$ $$\\nu = 0.5,$$ $$x_a = 0.25,$$ $$x_b = 0.5$$。\n\n科学真实性要求：所有离散格式必须强制施加周期性边界条件，所有计算必须以双精度执行，并且不允许外部输入。\n\n最终输出格式要求：你的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，按每个测试用例的以下顺序排列结果：$$[\\mathsf{MPV}_1, \\delta_{\\text{over},1}, \\delta_{\\text{under},1}, G_{\\text{TV},1}, \\mathsf{MPV}_2, \\delta_{\\text{over},2}, \\delta_{\\text{under},2}, G_{\\text{TV},2}, \\mathsf{MPV}_3, \\delta_{\\text{over},3}, \\delta_{\\text{under},3}, G_{\\text{TV},3}, \\mathsf{MPV}_4, \\delta_{\\text{over},4}, \\delta_{\\text{under},4}, G_{\\text{TV},4}]$$。每个 $$\\mathsf{MPV}_k$$ 是一个布尔值，每个 $$\\delta_{\\text{over},k}, \\delta_{\\text{under},k}, G_{\\text{TV},k}$$ 是一个浮点数。此格式必须是程序的唯一输出。",
            "solution": "所提出的问题是计算流体力学领域一个定义明确且标准的问题，具体涉及双曲守恒律的数值解。它要求实现并比较分析三种不同空间离散格式，用于求解一维线性平流方程，并与二阶龙格-库塔时间积分方法相结合。该问题具有科学依据、内部一致，并且所有参数和条件都已明确指定。因此，该问题是有效的，可以构建一个解。\n\n问题的核心是对被动标量 $$\\phi(x, t)$$ 的一维线性平流方程进行数值求解：\n$$\n\\frac{\\partial \\phi}{\\partial t} + a \\frac{\\partial \\phi}{\\partial x} = 0\n$$\n该方程定义在一个周期性域 $$x \\in [0, L)$$ 上，具有恒定的平流速度 $$a > 0$$。为了进行数值求解，该域被离散化为一个包含 $$N$$ 个点 $$x_i = i \\Delta x$$（其中 $$i = 0, 1, \\dots, N-1$$）的均匀网格，网格间距为 $$\\Delta x = L/N$$。在这些离散点上的标量场表示为 $$\\phi_i(t) \\approx \\phi(x_i, t)$$。偏微分方程被转化为一个常微分方程组（ODEs），这种技术被称为直线法：\n$$\n\\frac{d\\phi_i}{dt} = L(\\phi)_i\n$$\n其中 $$L(\\phi)_i$$ 是在网格点 $$x_i$$ 处逼近空间导数项 $$-a \\frac{\\partial \\phi}{\\partial x}$$ 的半离散算子。\n\n时间积分采用二阶龙格-库塔方法（RK2），也称为霍恩法或显式梯形法则。给定在时间 $$t_n$$ 的解 $$\\phi^n$$，在时间 $$t_{n+1} = t_n + \\Delta t$$ 的解 $$\\phi^{n+1}$$ 通过一个两步过程求得：\n$$\n\\begin{aligned}\n\\phi^{(1)} = \\phi^n + \\Delta t \\, L(\\phi^n) \\\\\n\\phi^{n+1} = \\phi^n + \\frac{\\Delta t}{2} \\left( L(\\phi^n) + L(\\phi^{(1)}) \\right)\n\\end{aligned}\n$$\n该方法在时间上是二阶精确的。它也是一种强稳定保持（SSP）格式，这意味着如果前向欧拉步 $$ \\phi \\rightarrow \\phi + \\Delta t L(\\phi) $$ 在某个时间步限制下是凸稳定的（例如，保持单调性），那么完整的RK2格式在相同的限制下也保持该稳定性。\n\n该问题要求实现三种不同的空间算子 $$L(\\phi)_i$$。\n\n1.  **中心差分：** 该格式使用标准的二阶精确中心差分模板来逼近空间导数：\n    $$\n    L^{\\text{cen}}(\\phi)_i = -a \\frac{\\phi_{i+1} - \\phi_{i-1}}{2 \\Delta x}\n    $$\n    虽然该格式是二阶精确的，但众所周知，对于纯平流问题，它是纯色散的且无条件不稳定的。它会产生伪振荡，尤其是在陡峭梯度附近，并且会违背极值原理。\n\n2.  **迎风差分：** 该格式使用一个考虑了信息传播方向的单边模板。对于 $$a > 0$$，信息从左向右流动，因此使用后向差分：\n    $$\n    L^{\\text{up}}(\\phi)_i = -a \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}\n    $$\n    该格式在空间上仅为一阶精确，但在库朗-弗里德里希-路维（CFL）数 $$\\nu = a \\Delta t / \\Delta x \\le 1$$ 的条件下是条件稳定的。其主要缺点是过度的数值耗散，这会抹平尖锐特征，但它通常在CFL条件下保持极值原理。\n\n3.  **用于守恒律的单调上游中心格式（MUSCL）：** 这是一种高分辨率有限体积方法，设计用于在光滑区域达到二阶精确，同时避免在间断点产生振荡。它通过在每个网格单元内重构分段线性剖面来扩展迎风格式。有限体积形式的半离散方程为：\n    $$\n    \\frac{d\\phi_i}{dt} = - \\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x}\n    $$\n    其中 $$F_{i+1/2}$$ 是单元 $$i$$ 和单元 $$i+1$$ 之间界面的数值通量。对于 $$a>0$$，迎风通量取界面左侧的值 $$\\phi_{i+1/2}^L$$。该值由单元平均值 $$\\phi_i$$ 和一个受限斜率重构得到：\n    $$\n    \\phi_{i+1/2}^L = \\phi_i + \\frac{1}{2} s_i\n    $$\n    项 $$s_i$$ 表示跨单元的受限差分，其选择是为了防止新极值的形成。使用minmod限制器：\n    $$\n    s_i = \\operatorname{minmod}(\\phi_i - \\phi_{i-1}, \\phi_{i+1} - \\phi_i)\n    $$\n    其中minmod函数定义为：\n    $$\n    \\operatorname{minmod}(p, q) = \\begin{cases} \\operatorname{sign}(p) \\min(|p|, |q|),  \\text{if } p q > 0, \\\\ 0,  \\text{otherwise.} \\end{cases}\n    $$\n    该限制器在两个相邻的未分离差分符号相同时选择其中较小的一个，否则返回$$0$$，从而有效地在局部极值附近使剖面平坦化。得到的通量为 $$F_{i+1/2} = a \\phi_{i+1/2}^L$$。完整的空间算子为：\n    $$\n    L^{\\text{muscl}}(\\phi)_i = - \\frac{a \\left(\\phi_i + \\frac{1}{2}s_i\\right) - a \\left(\\phi_{i-1} + \\frac{1}{2}s_{i-1}\\right)}{\\Delta x}\n    $$\n    当与合适的时间步进方法（如SSP-RK2）结合并在CFL约束下使用时，该格式是总变差减小（TVD）的，确保不引入伪振荡并遵守极值原理。\n\n对于所有格式，通过对网格索引使用模运算来强制施加周期性边界条件，使得 $$\\phi_{N+k} = \\phi_k$$。\n\n初始条件是一个方波函数，其中 $$\\phi=1$$ 在一个子区间上，其他地方 $$\\phi=0$$。初始界限为 $$\\phi_{\\min}=0$$ 和 $$\\phi_{\\max}=1$$。在一个RK2步长后需要评估的关键指标是过冲 $$\\delta_{\\text{over}}$$、下冲 $$\\delta_{\\text{under}}$$、极值原理违背标志 $$\\mathsf{MPV}$$ 和总变差增长因子 $$G_{\\text{TV}}$$。离散解的总变差（TV）为 $$ \\operatorname{TV}(\\phi) = \\sum_{i=0}^{N-1} |\\phi_{i+1} - \\phi_i| $$，其中 $$\\phi_N=\\phi_0$$。这些指标定量地评估了每种数值格式的质量。\n\n以下Python实现求解了指定的测试用例，并计算了所有必需的度量指标。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and evaluates three advection schemes for a 1D scalar transport problem.\n    \"\"\"\n\n    test_cases = [\n        {'L': 1.0, 'a': 1.0, 'N': 200, 'nu': 0.5, 'xa': 0.25, 'xb': 0.5, 'scheme': 'central'},\n        {'L': 1.0, 'a': 1.0, 'N': 200, 'nu': 0.1, 'xa': 0.25, 'xb': 0.5, 'scheme': 'central'},\n        {'L': 1.0, 'a': 1.0, 'N': 200, 'nu': 0.5, 'xa': 0.25, 'xb': 0.5, 'scheme': 'upwind'},\n        {'L': 1.0, 'a': 1.0, 'N': 200, 'nu': 0.5, 'xa': 0.25, 'xb': 0.5, 'scheme': 'muscl'},\n    ]\n\n    results = []\n\n    def get_spatial_operator(phi, scheme, dx, a, N):\n        \"\"\"Computes the semi-discrete spatial operator L(phi).\"\"\"\n        if scheme == 'central':\n            # L(phi)_i = -a * (phi_{i+1} - phi_{i-1}) / (2*dx)\n            phi_p1 = np.roll(phi, -1)\n            phi_m1 = np.roll(phi, 1)\n            return -a * (phi_p1 - phi_m1) / (2.0 * dx)\n        elif scheme == 'upwind':\n            # L(phi)_i = -a * (phi_i - phi_{i-1}) / dx for a  0\n            phi_m1 = np.roll(phi, 1)\n            return -a * (phi - phi_m1) / dx\n        elif scheme == 'muscl':\n            # Finite Volume MUSCL scheme with minmod limiter\n            # L(phi)_i = -(F_{i+1/2} - F_{i-1/2}) / dx\n\n            # 1. Compute undivided differences\n            delta_bwd = phi - np.roll(phi, 1)\n            delta_fwd = np.roll(phi, -1) - phi\n\n            # 2. Apply minmod limiter to get slopes s_i\n            # minmod(p, q) = sign(p) * min(|p|, |q|) if p*q  0, else 0\n            pq = delta_bwd * delta_fwd\n            s = np.where(pq  0, np.sign(delta_bwd) * np.minimum(np.abs(delta_bwd), np.abs(delta_fwd)), 0)\n\n            # 3. Reconstruct value at right interface of cell i (phi_{i+1/2}^L)\n            phi_L = phi + 0.5 * s\n\n            # 4. Compute upwind flux F_{i+1/2} = a * phi_{i+1/2}^L\n            flux_interface_right = a * phi_L\n\n            # 5. F_{i-1/2} is the right flux of the cell i-1\n            flux_interface_left = np.roll(flux_interface_right, 1)\n            \n            return -(flux_interface_right - flux_interface_left) / dx\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n\n    for case in test_cases:\n        L = case['L']\n        a = case['a']\n        N = case['N']\n        nu = case['nu']\n        xa = case['xa']\n        xb = case['xb']\n        scheme = case['scheme']\n\n        # Grid and time step setup\n        dx = L / N\n        dt = nu * dx / a\n        x = np.linspace(0, L, N, endpoint=False)\n\n        # Initial condition: top-hat profile\n        phi_n = np.zeros(N, dtype=np.float64)\n        # Find indices corresponding to xa and xb\n        # where condition is x_i = xa and x_i  xb\n        indices = np.where((x = xa)  (x  xb))\n        phi_n[indices] = 1.0\n        \n        # Calculate initial Total Variation\n        tv_n = np.sum(np.abs(np.roll(phi_n, -1) - phi_n))\n        \n        # RK2 time step\n        # Stage 1\n        L_n = get_spatial_operator(phi_n, scheme, dx, a, N)\n        phi_1 = phi_n + dt * L_n\n        \n        # Stage 2\n        L_1 = get_spatial_operator(phi_1, scheme, dx, a, N)\n        phi_np1 = phi_n + 0.5 * dt * (L_n + L_1)\n\n        # Calculate metrics\n        phi_max_np1 = np.max(phi_np1)\n        phi_min_np1 = np.min(phi_np1)\n\n        delta_over = np.maximum(0.0, phi_max_np1 - 1.0)\n        delta_under = np.maximum(0.0, 0.0 - phi_min_np1)\n        \n        mpv = (delta_over  1e-15) or (delta_under  1e-15) # Use tolerance for float comparison\n\n        tv_np1 = np.sum(np.abs(np.roll(phi_np1, -1) - phi_np1))\n        \n        if tv_n  1e-15:\n            g_tv = tv_np1 / tv_n\n        else:\n            g_tv = 1.0 if tv_np1  1e-15 else np.inf\n\n        results.extend([mpv, delta_over, delta_under, g_tv])\n\n    # Format the final output string\n    # Convert elements to string representation for joining\n    output_str_list = []\n    for item in results:\n        if isinstance(item, bool):\n            output_str_list.append(str(item).lower())\n        else:\n            # Use non-scientific notation for consistency\n            output_str_list.append(f'{item:.15f}')\n\n    print(f\"[{','.join(output_str_list)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "上一个练习展示了高分辨率格式的优异表现，其成功的关键在于“通量限制器”($\\text{flux limiter}$)的巧妙设计。本练习将引导您深入这一核心机制 。您将不再是调用一个黑箱函数，而是针对一个包含光滑区和间断区的具体数据集，一步步手动计算Monotonized Central (MC)限制器如何作用，以及它如何动态调整局部精度以抑制振荡。通过这个计算过程，您将获得关于总变差递减($\\text{TVD}$)格式如何在保持单调性($\\text{monotonicity}$)和追求高精度之间做出智能权衡的具象化理解。",
            "id": "4030707",
            "problem": "考虑一个与燃烧相关的被动标量（例如，混合分数）的一维标量平流方程，其形式为 $\\partial_{t} \\phi + u \\, \\partial_{x} \\phi = 0$，该方程构建在均匀的有限体积网格上，网格中心位于 $x_{i}$，网格宽度为 $\\Delta x$。使用分段线性剖面进行高分辨率通量重构，并通过限制器来防止伪振荡。具体来说，使用单调中心（MC）限制器来定义网格斜率 $\\sigma_{i}$，其表达式为 $\\sigma_{i} = \\operatorname{minmod}\\!\\left( \\frac{\\phi_{i+1} - \\phi_{i-1}}{2}, \\, 2(\\phi_{i} - \\phi_{i-1}), \\, 2(\\phi_{i+1} - \\phi_{i}) \\right)$，其中 minmod 算子定义为 $\\operatorname{minmod}(a,b,c) = \\begin{cases} \\min\\{|a|,|b|,|c|\\} \\, \\operatorname{sign}(a),  \\text{if } \\operatorname{sign}(a)=\\operatorname{sign}(b)=\\operatorname{sign}(c), \\\\ 0,  \\text{otherwise.} \\end{cases}$。受限的分段线性重构得到界面状态 $\\phi_{i+1/2}^{L} = \\phi_{i} + \\frac{1}{2}\\sigma_{i}$ 和 $\\phi_{i+1/2}^{R} = \\phi_{i+1} - \\frac{1}{2}\\sigma_{i+1}$。\n\n给定一个离散数据集，其中包含代表计算燃烧应用的光滑和不连续区域，其均匀网格间距为 $\\Delta x = 0.01$，平流速度为 $u = -1$。在索引 $i=-1,0,1,2,3,4$ 处，网格平均标量值为\n$\\phi_{-1} = 0.1800$，$\\phi_{0} = 0.2474$，$\\phi_{1} = 0.3120$，$\\phi_{2} = 0.3716$，$\\phi_{3} = 0.9000$ 和 $\\phi_{4} = 0.9000$。该数据集在 $i=0,1,2$ 上是光滑且单调递增的，并在 $i=2$ 和 $i=3$ 之间包含一个跳跃。\n\n从标量守恒定律和作为全变差递减（TVD）重构的 MC 限制器的定义出发，使用 MC 限制器计算在 $i=1$ 处的界面状态 $\\phi_{i+1/2}^{L}$ 和 $\\phi_{i+1/2}^{R}$。然后，在给定 $u0$（即通量中使用的迎风状态来自右侧）的情况下，评估该问题在界面 $x_{i+1/2}$ 处数值通量的局部精度阶 $p$。您的评估必须基于局部泰勒展开论证，该论证将限制器所做的选择与 $\\Delta x$ 中的截断误差缩放联系起来。\n\n将界面状态值四舍五入至五位有效数字。精度阶 $p$ 以整数形式报告。将最终答案表示为一个行向量，按顺序包含 $\\phi_{i+1/2}^{L}$、$\\phi_{i+1/2}^{R}$ 和 $p$。标量值为无量纲。",
            "solution": "该问题要求计算在 $i=1$ 处（即在 $x_{3/2}$ 处）界面上被动标量 $\\phi$ 的重构界面状态，并随后确定该界面上数值通量的局部精度阶。流动由一维标量平流方程 $\\partial_{t} \\phi + u \\, \\partial_{x} \\phi = 0$ 控制，具有恒定的平流速度 $u = -1$。通量重构使用带有单调中心（MC）限制器的分段线性剖面。\n\n任务分为两部分：首先，计算左、右界面状态 $\\phi_{3/2}^{L}$ 和 $\\phi_{3/2}^{R}$；其次，评估数值通量的局部精度阶 $p$。\n\n**第1部分：计算 $x_{3/2}$ 处的界面状态**\n\n界面状态由以下公式给出：\n$$ \\phi_{i+1/2}^{L} = \\phi_{i} + \\frac{1}{2}\\sigma_{i} $$\n$$ \\phi_{i+1/2}^{R} = \\phi_{i+1} - \\frac{1}{2}\\sigma_{i+1} $$\n对于 $i=1$ 处的界面，我们需要计算 $\\phi_{3/2}^{L}$ 和 $\\phi_{3/2}^{R}$。这需要计算受限斜率 $\\sigma_{1}$ 和 $\\sigma_{2}$。\n\n网格斜率 $\\sigma_i$ 由 MC 限制器确定：\n$$ \\sigma_{i} = \\operatorname{minmod}\\!\\left( \\frac{\\phi_{i+1} - \\phi_{i-1}}{2}, \\, 2(\\phi_{i} - \\phi_{i-1}), \\, 2(\\phi_{i+1} - \\phi_{i}) \\right) $$\n其中 $\\operatorname{minmod}$ 算子在所有参数符号相同时返回绝对值最小的参数，否则返回 $0$。\n\n给定的网格平均标量值为：\n$\\phi_{-1} = 0.1800$，$\\phi_{0} = 0.2474$，$\\phi_{1} = 0.3120$，$\\phi_{2} = 0.3716$，$\\phi_{3} = 0.9000$ 和 $\\phi_{4} = 0.9000$。\n\n首先，我们计算网格 $i=1$ 的斜率 $\\sigma_1$。$\\operatorname{minmod}$ 函数的参数是：\n1. 中心差分项：$a_1 = \\frac{\\phi_{2} - \\phi_{0}}{2} = \\frac{0.3716 - 0.2474}{2} = \\frac{0.1242}{2} = 0.0621$。\n2. 后向差分项（加倍）：$b_1 = 2(\\phi_{1} - \\phi_{0}) = 2(0.3120 - 0.2474) = 2(0.0646) = 0.1292$。\n3. 前向差分项（加倍）：$c_1 = 2(\\phi_{2} - \\phi_{1}) = 2(0.3716 - 0.3120) = 2(0.0596) = 0.1192$。\n\n所有三个参数 $a_1$、$b_1$ 和 $c_1$ 均为正。因此，$\\sigma_1$ 是它们绝对值的最小值：\n$$ \\sigma_1 = \\min\\{|0.0621|, |0.1292|, |0.1192|\\} = 0.0621 $$\n\n接下来，我们计算网格 $i=2$ 的斜率 $\\sigma_2$。参数是：\n1. 中心差分项：$a_2 = \\frac{\\phi_{3} - \\phi_{1}}{2} = \\frac{0.9000 - 0.3120}{2} = \\frac{0.5880}{2} = 0.2940$。\n2. 后向差分项（加倍）：$b_2 = 2(\\phi_{2} - \\phi_{1}) = 2(0.3716 - 0.3120) = 2(0.0596) = 0.1192$。\n3. 前向差分项（加倍）：$c_2 = 2(\\phi_{3} - \\phi_{2}) = 2(0.9000 - 0.3716) = 2(0.5284) = 1.0568$。\n\n所有三个参数 $a_2$、$b_2$ 和 $c_2$ 均为正。因此，$\\sigma_2$ 是它们绝对值的最小值：\n$$ \\sigma_2 = \\min\\{|0.2940|, |0.1192|, |1.0568|\\} = 0.1192 $$\n限制器选择了后向差分项 $2(\\phi_2 - \\phi_1)$，这表明在网格 2 前方存在一个陡峭的梯度，这是由跳跃至 $\\phi_3=0.9000$ 引起的。\n\n现在我们可以计算 $x_{3/2}$ 处的界面状态：\n$$ \\phi_{3/2}^{L} = \\phi_{1} + \\frac{1}{2}\\sigma_{1} = 0.3120 + \\frac{1}{2}(0.0621) = 0.3120 + 0.03105 = 0.34305 $$\n$$ \\phi_{3/2}^{R} = \\phi_{2} - \\frac{1}{2}\\sigma_{2} = 0.3716 - \\frac{1}{2}(0.1192) = 0.3716 - 0.0596 = 0.3120 $$\n四舍五入至五位有效数字，界面状态为 $\\phi_{3/2}^{L} = 0.34305$ 和 $\\phi_{3/2}^{R} = 0.31200$。\n\n**第2部分：局部精度阶评估**\n\n在界面 $x_{i+1/2}$ 处，标量平流方程的数值通量为 $F_{i+1/2} = u \\phi_{i+1/2}^{\\text{upwind}}$。由于平流速度为负（$u = -1$），“迎风”方向来自右侧。因此，$x_{3/2}$ 界面处的通量由右侧状态 $\\phi_{3/2}^{R}$ 决定：\n$$ F_{3/2} = u \\, \\phi_{3/2}^{R} $$\n通量的局部精度阶 $p$ 由重构状态中的误差阶决定，即 $(\\phi_{3/2}^{R} - \\phi(x_{3/2}))$ 如何随网格间距 $\\Delta x$ 缩放。此处，$\\phi(x_{3/2})$ 是界面处的精确解。\n\n根据我们的计算，我们发现 $\\phi_{3/2}^{R} = 0.3120$，这恰好是网格平均值 $\\phi_1$。这是因为限制器选择了 $\\sigma_2 = 2(\\phi_2 - \\phi_1)$，导致 $\\phi_{3/2}^{R} = \\phi_2 - \\frac{1}{2}(2(\\phi_2 - \\phi_1)) = \\phi_1$。\n\n因此，数值格式正在使用来自下游网格（网格 1）的网格平均值作为在界面 $x_{3/2}$ 处进行通量计算的状态。我们现在分析与此选择相关的截断误差。\n\n让我们进行泰勒级数展开。网格中心是 $x_1$，界面位于 $x_{3/2} = x_1 + \\Delta x/2$。对于光滑解，网格平均值 $\\phi_1$ 与点值 $\\phi(x_1)$ 的关系为 $\\phi_1 = \\phi(x_1) + O(\\Delta x^2)$。界面处的精确值可以围绕 $x_1$ 展开：\n$$ \\phi(x_{3/2}) = \\phi(x_1 + \\Delta x/2) = \\phi(x_1) + \\frac{\\Delta x}{2}\\phi'(x_1) + \\frac{1}{2}\\left(\\frac{\\Delta x}{2}\\right)^2 \\phi''(x_1) + \\dots = \\phi(x_1) + \\frac{\\Delta x}{2}\\phi'(x_1) + O(\\Delta x^2) $$\n重构状态的误差为：\n$$ \\text{Error} = \\phi_{3/2}^{R} - \\phi(x_{3/2}) = \\phi_1 - \\phi(x_{3/2}) $$\n代入展开式：\n$$ \\text{Error} = (\\phi(x_1) + O(\\Delta x^2)) - \\left(\\phi(x_1) + \\frac{\\Delta x}{2}\\phi'(x_1) + O(\\Delta x^2)\\right) $$\n$$ \\text{Error} = -\\frac{\\Delta x}{2}\\phi'(x_1) + O(\\Delta x^2) $$\n误差中的主导项与 $\\Delta x^1$ 成正比。这表明通量的局部截断误差是一阶的。尖锐梯度的存在迫使 TVD 限制器在局部降低格式的精度以防止伪振荡，导致在这个特定界面上产生一阶精度的通量。\n\n因此，局部精度阶为 $p=1$。\n\n需要报告的最终值为 $\\phi_{3/2}^{L}$、$\\phi_{3/2}^{R}$ 和 $p$。\n$\\phi_{3/2}^{L} = 0.34305$\n$\\phi_{3/2}^{R} = 0.31200$\n$p = 1$\n按要求将这些值排列成一个行向量。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 0.34305  0.31200  1 \\end{pmatrix} } $$"
        },
        {
            "introduction": "理解了高分辨率格式的动机和内部机理后，作为一名计算科学家，最后也是最关键的一步是：如何证明您的代码实现是正确的？这个综合性练习将向您介绍“制造解方法”($\\text{Method of Manufactured Solutions}$, MMS)，这是代码验证的黄金标准 。您将构建一个完整的MUSCL-TVD求解器，并利用MMS生成的精确解来严格检验其收敛阶($\\text{order of convergence}$)。这个过程不仅能确保您的代码没有错误，更能让您掌握衡量和报告数值方法精度的规范流程，这是进行可靠科学模拟的必备技能。",
            "id": "4030747",
            "problem": "考虑一维周期性域 $x\\in[0,1]$，其中存在空间均匀的速度 $u\\in\\mathbb{R}$。令标量场 $\\phi(x,t)$ 满足守恒律\n$$\n\\partial_t \\phi(x,t) + \\partial_x\\left(u\\,\\phi(x,t)\\right) = S(x,t),\n$$\n其中 $S(x,t)$ 是一个通过“人造解方法”（Method of Manufactured Solutions, MMS）构造的源项，从而得知一个闭式精确解。定义人造解为\n$$\n\\phi_{\\mathrm{ex}}(x,t) = \\sin\\left(2\\pi x\\right)\\cos\\left(2\\pi t\\right) + \\frac{1}{4}\\,\\cos\\left(4\\pi x - t\\right),\n$$\n选择恒定速度 $u$ 和源项 $S(x,t)$，使得当 $\\phi=\\phi_{\\mathrm{ex}}$ 时，该偏微分方程得到精确满足。具体而言，\n$$\nS(x,t) = \\partial_t \\phi_{\\mathrm{ex}}(x,t) + u\\,\\partial_x \\phi_{\\mathrm{ex}}(x,t).\n$$\n您必须实现一个适用于燃烧计算流体动力学（计算燃烧学）的高分辨率平流求解器。使用带有 van Leer 总变差递减（Total Variation Diminishing, TVD）斜率限制器的“守恒律单调上游中心格式”（Monotonic Upstream-centered Scheme for Conservation Laws, MUSCL）对通量梯度进行空间离散，并使用二阶强稳定性保持 Runge-Kutta（SSP RK2）方法进行时间积分。施加周期性边界条件。空间离散必须使用受限斜率重构界面处的左右状态，并据此计算迎风通量 $F_{i+1/2}=u\\,\\phi^{\\mathrm{upwind}}$。时间积分方案必须将解从 $t=0$推进到指定的最终时间 $T$。\n\n数值测试框架必须计算最终时间的离散 $\\ell^2$-误差，\n$$\n\\mathcal{E} = \\left(\\Delta x\\,\\sum_{i=0}^{N_x-1} \\left(\\phi_i(T) - \\phi_{\\mathrm{ex}}(x_i,T)\\right)^2\\right)^{1/2},\n$$\n其中 $N_x$ 是均匀间隔的单元格数量，$\\Delta x = 1/N_x$，且 $x_i = \\left(i+\\frac{1}{2}\\right)\\Delta x$ 是单元格中心。对于每个测试，使用您的求解器将 $\\phi(x,0) = \\phi_{\\mathrm{ex}}(x,0)$ 初始化，并推进到指定的 $T$。您可以假定变量是无量纲的，不需要物理单位。\n\n您的程序必须执行以下三组测试并汇总其结果：\n\n1. 空间收敛性研究（一般情况）：\n   - 使用恒定速度 $u = 0.7$，最终时间 $T = 0.2$，以及 Courant–Friedrichs–Lewy (CFL) 数 $\\mathrm{CFL} = 0.4$。\n   - 计算时间步长为 $\\Delta t = \\mathrm{CFL}\\,\\Delta x/|u|$ 以确保稳定性。\n   - 在 $N_x \\in \\{50,100,200,400\\}$ 的条件下运行，并为每个 $N_x$ 计算在 $t=T$ 时的离散 $\\ell^2$-误差 $\\mathcal{E}$。\n   - 报告观测到的空间阶数 $p$，其定义为通过对 $(\\Delta x,\\mathcal{E})$ 值集合进行线性回归得到的 $\\log(\\mathcal{E})$ 相对于 $\\log(\\Delta x)$ 的斜率。\n\n2. 时间收敛性研究（时间精度焦点）：\n   - 使用恒定速度 $u = 0.7$，最终时间 $T = 0.2$，以及精细的空间分辨率 $N_x = 800$。\n   - 令 $\\mathrm{CFL}_{\\max} = 0.9$，并计算最大稳定时间步长 $\\Delta t_{\\max} = \\mathrm{CFL}_{\\max}\\,\\Delta x/|u|$。\n   - 使用时间步长 $\\Delta t \\in \\{0.8\\,\\Delta t_{\\max},\\,0.4\\,\\Delta t_{\\max},\\,0.2\\,\\Delta t_{\\max},\\,0.1\\,\\Delta t_{\\max}\\}$ 运行，并为每个 $\\Delta t$ 计算在 $t=T$ 时的离散 $\\ell^2$-误差 $\\mathcal{E}$。\n   - 报告观测到的时间阶数 $q$，其定义为通过对 $(\\Delta t,\\mathcal{E})$ 值集合进行线性回归得到的 $\\log(\\mathcal{E})$ 相对于 $\\log(\\Delta t)$ 的斜率。\n\n3. 边界情况（边界条件和退化检查）：\n   - 使用 $u = 0$，最终时间 $T = 0.2$，$N_x = 50$，以及时间步长 $\\Delta t = T/200$。\n   - 由于当 $u=0$ 时平流项消失，方程简化为 $\\partial_t \\phi = S$，您的 SSP RK2 积分器应使用人造解的精确源项来求解此方程。\n   - 计算离散 $\\ell^2$-误差 $\\mathcal{E}$，并返回一个布尔值，指示 $\\mathcal{E}  5\\times 10^{-6}$ 是否成立。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，具体为 $[p,q,\\mathrm{edge}]$，其中 $p$ 和 $q$ 是实数（浮点数），$\\mathrm{edge}$ 是一个布尔值。\n\n实现所需的定义和提醒：\n- 守恒律单调上游中心格式 (MUSCL)：使用受限斜率 $s_i$ 重构界面状态，使得 $\\phi^{L}_{i+1/2} = \\phi_i + \\frac{1}{2}s_i$ 且 $\\phi^{R}_{i+1/2} = \\phi_{i+1} - \\frac{1}{2}s_{i+1}$。\n- Van Leer 总变差递减 (TVD) 斜率限制器：对于连续差分 $\\Delta_{i-1/2} = \\phi_i - \\phi_{i-1}$ 和 $\\Delta_{i+1/2} = \\phi_{i+1} - \\phi_i$，定义\n$$\ns_i = \\begin{cases}\n\\dfrac{2\\,\\Delta_{i-1/2}\\,\\Delta_{i+1/2}}{\\Delta_{i-1/2} + \\Delta_{i+1/2}},  \\text{if } \\Delta_{i-1/2}\\,\\Delta_{i+1/2}  0,\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n- 恒定 $u$ 的线性平流的迎风通量：$F_{i+1/2} = u\\,\\phi^{\\mathrm{upwind}}$，其中当 $u0$ 时 $\\phi^{\\mathrm{upwind}} = \\phi^{L}_{i+1/2}$，当 $u0$ 时 $\\phi^{\\mathrm{upwind}} = \\phi^{R}_{i+1/2}$。\n- 强稳定性保持 Runge-Kutta (SSP RK2)：通过以下方式推进\n$$\n\\phi^{(1)} = \\phi^n + \\Delta t\\,\\mathcal{R}(\\phi^n,t^n),\\quad\n\\phi^{n+1} = \\frac{1}{2}\\phi^n + \\frac{1}{2}\\left[\\phi^{(1)} + \\Delta t\\,\\mathcal{R}(\\phi^{(1)},t^n+\\Delta t)\\right],\n$$\n其中 $\\mathcal{R}(\\phi,t) = S(\\cdot,t) - \\partial_x(u\\,\\phi)$ 是半离散的右端项，其空间算子通过 MUSCL-TVD 离散化。\n\n完全按照规定实现求解器并运行这三项研究。您的最终程序输出必须是 $[p,q,\\mathrm{edge}]$ 格式的单行文本，包含两个实数和一个布尔值。",
            "solution": "用户提供的问题陈述经过严格验证，并被确定为 **有效**。它代表了计算流体动力学领域中一个适定、有科学依据且客观的问题，特别侧重于标量平流高分辨率数值格式的验证。问题任务定义清晰，控制方程和数值方法是标准的且规定正确，人造解方法（MMS）为评估求解器的精度提供了一个稳健的框架。\n\n我们继续提供一个完整、有原则的解决方案。\n\n### 1. 控制方程与人造解\n\n该问题涉及周期性域 $x\\in[0,1]$ 上的一维线性平流方程：\n$$\n\\partial_t \\phi + u\\,\\partial_x \\phi = S(x,t)\n$$\n其中 $\\phi(x,t)$ 是一个标量场，$u$ 是一个恒定速度，$S(x,t)$ 是一个源项。\n\n此问题采用了人造解方法（MMS），即预先设定一个精确的解析解 $\\phi_{\\mathrm{ex}}(x,t)$，然后推导出源项 $S(x,t)$ 以确保 $\\phi_{\\mathrm{ex}}$ 恒等地满足控制方程。人造解由下式给出：\n$$\n\\phi_{\\mathrm{ex}}(x,t) = \\sin\\left(2\\pi x\\right)\\cos\\left(2\\pi t\\right) + \\frac{1}{4}\\,\\cos\\left(4\\pi x - t\\right)\n$$\n因此，源项 $S(x,t)$ 定义为 $S(x,t) = \\partial_t \\phi_{\\mathrm{ex}} + u\\,\\partial_x \\phi_{\\mathrm{ex}}$。所需的偏导数是：\n$$\n\\partial_t \\phi_{\\mathrm{ex}}(x,t) = -2\\pi \\sin(2\\pi x)\\sin(2\\pi t) + \\frac{1}{4} \\sin(4\\pi x - t)\n$$\n$$\n\\partial_x \\phi_{\\mathrm{ex}}(x,t) = 2\\pi \\cos(2\\pi x)\\cos(2\\pi t) - \\pi \\sin(4\\pi x - t)\n$$\n代入这些表达式可得到源项的显式形式：\n$$\nS(x,t) = -2\\pi \\sin(2\\pi x)\\sin(2\\pi t) + \\frac{1}{4} \\sin(4\\pi x - t) + u \\left( 2\\pi \\cos(2\\pi x)\\cos(2\\pi t) - \\pi \\sin(4\\pi x - t) \\right)\n$$\n\n### 2. 数值离散\n\n解在包含 $N_x$ 个单元格的均匀网格上随时间推进，单元格宽度为 $\\Delta x = 1/N_x$，单元格中心为 $x_i = (i+1/2)\\Delta x$，其中 $i=0, \\dots, N_x-1$。使用有限体积法，其中单元格平均量 $\\phi_i(t) \\approx \\frac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} \\phi(x,t)\\,dx$ 根据半离散方程演化：\n$$\n\\frac{d\\phi_i}{dt} + \\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x} = S(x_i, t)\n$$\n此处，$F_{i\\pm 1/2}$ 是单元格界面处的数值通量。此常微分方程组（ODE）的右端项 $\\mathcal{R}_i(\\phi, t) = S(x_i, t) - (F_{i+1/2} - F_{i-1/2})/\\Delta x$ 将进行时间积分。\n\n#### 2.1. 空间离散：MUSCL-TVD 格式\n\n为了在避免剧烈梯度附近出现伪振荡的同时实现二阶空间精度，采用了守恒律单调上游中心格式（MUSCL）。该格式在每个单元格内重构解的分段线性表示，并由此确定单元格界面处的值（$\\phi^L_{i+1/2}$ 和 $\\phi^R_{i+1/2}$）。\n\n关键步骤如下：\n\n1.  **斜率限制**：为确保总变差递减（TVD）特性，线性重构的斜率受到限制。问题指定使用 van Leer 限制器。对每个单元格 $i$，我们根据相邻单元格的差值 $\\Delta_{i-1/2} = \\phi_i - \\phi_{i-1}$ 和 $\\Delta_{i+1/2} = \\phi_{i+1} - \\phi_i$ 计算一个受限差分，记为 $s_i$：\n    $$\n    s_i = \\begin{cases}\n    \\dfrac{2\\,\\Delta_{i-1/2}\\,\\Delta_{i+1/2}}{\\Delta_{i-1/2} + \\Delta_{i+1/2}},  \\text{if } \\Delta_{i-1/2}\\,\\Delta_{i+1/2}  0,\\\\\n    0,  \\text{otherwise}.\n    \\end{cases}\n    $$\n    此 $s_i$ 的公式对应于 $\\sigma_i \\Delta x$，其中 $\\sigma_i$ 是受限斜率。条件 $\\Delta_{i-1/2}\\,\\Delta_{i+1/2}  0$ 将高阶重构限制在解是单调的区域，在局部极值点处将斜率设为零以防止振荡。通过使用虚拟单元来处理周期性边界条件，使得 $\\phi_{-1} = \\phi_{N_x-1}$ 且 $\\phi_{N_x} = \\phi_0$。\n\n2.  **界面重构**：使用受限差分 $s_i$ 来重构每个界面 $x_{i+1/2}$ 左右两侧的标量值：\n    $$\n    \\phi^{L}_{i+1/2} = \\phi_i + \\frac{1}{2}s_i\n    $$\n    $$\n    \\phi^{R}_{i+1/2} = \\phi_{i+1} - \\frac{1}{2}s_{i+1}\n    $$\n\n3.  **迎风通量**：数值通量 $F_{i+1/2}$ 使用基于恒定速度 $u$ 符号的迎风准则计算：\n    $$\n    F_{i+1/2} = u\\,\\phi^{\\mathrm{upwind}}_{i+1/2} = \\begin{cases}\n    u\\,\\phi^{L}_{i+1/2},  \\text{if } u  0, \\\\\n    u\\,\\phi^{R}_{i+1/2},  \\text{if } u  0, \\\\\n    0,  \\text{if } u = 0.\n    \\end{cases}\n    $$\n\n#### 2.2. 时间离散：SSP RK2 格式\n\n该常微分方程组使用二阶强稳定性保持 Runge-Kutta（SSP RK2）方法进行时间积分。给定时间 $t^n$ 的解向量 $\\phi^n$，下一个时间步的解 $\\phi^{n+1}$ 通过两个阶段计算：\n$$\n\\phi^{(1)} = \\phi^n + \\Delta t\\,\\mathcal{R}(\\phi^n, t^n)\n$$\n$$\n\\phi^{n+1} = \\frac{1}{2}\\phi^n + \\frac{1}{2}\\left[\\phi^{(1)} + \\Delta t\\,\\mathcal{R}(\\phi^{(1)}, t^n + \\Delta t)\\right]\n$$\n其中 $\\mathcal{R}(\\phi, t)$ 是所有单元格的半离散残差向量，$\\Delta t$ 是为满足 Courant-Friedrichs-Lewy (CFL) 稳定性条件而选择的时间步长。\n\n### 3. 验证与误差分析\n\n通过执行问题陈述中列出的三项研究来验证所实现的求解器。其精度通过最终时间 $T$ 的离散 $\\ell^2$-误差范数来量化：\n$$\n\\mathcal{E} = \\left(\\Delta x\\,\\sum_{i=0}^{N_x-1} \\left(\\phi_i(T) - \\phi_{\\mathrm{ex}}(x_i,T)\\right)^2\\right)^{1/2}\n$$\n观测到的空间收敛阶数（$p$）和时间收敛阶数（$q$）分别通过误差对数与网格间距或时间步长的对数进行线性回归计算得出。$u=0$ 的边界情况验证了源项积分的正确实现以及平流格式在零速度极限下的稳健性。",
            "answer": "```python\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to run the three specified test cases and print the results.\n    \"\"\"\n\n    # Analytic helper functions for the Method of Manufactured Solutions\n    def phi_exact(x, t):\n        \"\"\"Computes the exact manufactured solution phi_ex(x, t).\"\"\"\n        term1 = np.sin(2 * np.pi * x) * np.cos(2 * np.pi * t)\n        term2 = 0.25 * np.cos(4 * np.pi * x - t)\n        return term1 + term2\n\n    def source_term_func(x, t, u):\n        \"\"\"Computes the source term S(x, t, u) for the manufactured solution.\"\"\"\n        dphi_dt = -2 * np.pi * np.sin(2 * np.pi * x) * np.sin(2 * np.pi * t) + \\\n                  0.25 * np.sin(4 * np.pi * x - t)\n        dphi_dx = 2 * np.pi * np.cos(2 * np.pi * x) * np.cos(2 * np.pi * t) - \\\n                  np.pi * np.sin(4 * np.pi * x - t)\n        return dphi_dt + u * dphi_dx\n\n    def calculate_rhs(phi, x_grid, t, u, dx, Nx):\n        \"\"\"\n        Calculates the right-hand-side (RHS) of the semi-discrete equation\n        using the MUSCL-TVD scheme.\n        RHS = S(x,t) - (F_{i+1/2} - F_{i-1/2}) / dx\n        \"\"\"\n        # Pad the solution array with 1 ghost cell on each side for periodic BCs\n        phi_padded = np.pad(phi, (1, 1), 'wrap')\n\n        # 1. Calculate limited slopes using the van Leer limiter\n        delta_m = phi_padded[1:-1] - phi_padded[0:-2] # phi_i - phi_{i-1}\n        delta_p = phi_padded[2:] - phi_padded[1:-1]   # phi_{i+1} - phi_i\n        \n        product = delta_m * delta_p\n        slopes = np.zeros(Nx)\n        mask = product  0\n        \n        # Denominator is delta_m + delta_p. If it's zero, product = 0, so mask is False.\n        # This naturally avoids division by zero.\n        denominator = delta_m[mask] + delta_p[mask]\n        slopes[mask] = (2.0 * product[mask]) / denominator\n\n        # 2. Reconstruct interface values and compute upwind flux\n        slopes_padded = np.pad(slopes, (1, 1), 'wrap')\n\n        # Values at left side of interface i+1/2, from cell i\n        phi_L = phi + 0.5 * slopes\n        \n        # Values at right side of interface i+1/2, from cell i+1\n        phi_R = phi_padded[2:] - 0.5 * slopes_padded[2:]\n\n        if u  0:\n            phi_upwind = phi_L\n        elif u  0:\n            phi_upwind = phi_R\n        else: # u == 0\n            phi_upwind = np.zeros(Nx)\n\n        fluxes = u * phi_upwind  # Fluxes F_{i+1/2} for i=0..Nx-1\n\n        # 3. Compute flux divergence\n        fluxes_left = np.roll(fluxes, 1) # Fluxes F_{i-1/2}\n        flux_divergence = (fluxes - fluxes_left) / dx\n\n        # 4. Compute source term\n        source = source_term_func(x_grid, t, u)\n\n        return source - flux_divergence\n\n    def run_solver(Nx, T, u, dt_specified=None, cfl=None):\n        \"\"\"\n        Core solver that integrates the PDE from t=0 to t=T.\n        \"\"\"\n        dx = 1.0 / Nx\n        x_grid = (np.arange(Nx) + 0.5) * dx\n        \n        phi = phi_exact(x_grid, 0.0)\n        \n        t = 0.0\n        \n        if dt_specified is not None:\n            dt = dt_specified\n        elif cfl is not None:\n            if u == 0:\n                # Fallback for u=0 case as CFL-based dt would be infinite\n                dt = T / 1000 \n            else:\n                dt = cfl * dx / np.abs(u)\n        else:\n            raise ValueError(\"Either dt_specified or cfl must be provided.\")\n\n        while t  T:\n            # Adjust final time step to land exactly on T\n            current_dt = min(dt, T - t)\n            \n            # SSP RK2 Time Integration\n            # Stage 1\n            rhs1 = calculate_rhs(phi, x_grid, t, u, dx, Nx)\n            phi1 = phi + current_dt * rhs1\n            \n            # Stage 2\n            rhs2 = calculate_rhs(phi1, x_grid, t + current_dt, u, dx, Nx)\n            phi = 0.5 * phi + 0.5 * (phi1 + current_dt * rhs2)\n            \n            t += current_dt\n\n        # Compute L2 error\n        phi_final_exact = phi_exact(x_grid, T)\n        error = np.sqrt(dx * np.sum((phi - phi_final_exact)**2))\n        return error\n\n    # --- Test Case 1: Spatial Convergence ---\n    def test_spatial_convergence():\n        u = 0.7\n        T = 0.2\n        cfl = 0.4\n        Nx_values = [50, 100, 200, 400]\n        \n        log_dx = []\n        log_err = []\n        \n        for Nx in Nx_values:\n            error = run_solver(Nx=Nx, T=T, u=u, cfl=cfl)\n            dx = 1.0 / Nx\n            log_dx.append(np.log(dx))\n            log_err.append(np.log(error))\n            \n        # Linear regression to find the order of convergence\n        slope, _, _, _, _ = stats.linregress(log_dx, log_err)\n        return slope\n\n    # --- Test Case 2: Temporal Convergence ---\n    def test_temporal_convergence():\n        u = 0.7\n        T = 0.2\n        Nx = 800\n        cfl_max = 0.9\n        dx = 1.0 / Nx\n        dt_max = cfl_max * dx / np.abs(u)\n        dt_factors = [0.8, 0.4, 0.2, 0.1]\n        \n        log_dt = []\n        log_err = []\n        \n        for factor in dt_factors:\n            dt = factor * dt_max\n            error = run_solver(Nx=Nx, T=T, u=u, dt_specified=dt)\n            log_dt.append(np.log(dt))\n            log_err.append(np.log(error))\n            \n        slope, _, _, _, _ = stats.linregress(log_dt, log_err)\n        return slope\n\n    # --- Test Case 3: Edge Case (u=0) ---\n    def test_edge_case():\n        u = 0.0\n        T = 0.2\n        Nx = 50\n        dt = T / 200.0  # 0.001\n        \n        error = run_solver(Nx=Nx, T=T, u=u, dt_specified=dt)\n        return error  5e-6\n\n    # Run tests and collect results\n    p = test_spatial_convergence()\n    q = test_temporal_convergence()\n    edge_result = test_edge_case()\n\n    results = [p, q, edge_result]\n    \n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}