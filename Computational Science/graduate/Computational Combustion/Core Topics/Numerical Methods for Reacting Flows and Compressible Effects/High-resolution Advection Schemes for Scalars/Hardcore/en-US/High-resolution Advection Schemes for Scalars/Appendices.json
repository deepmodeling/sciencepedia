{
    "hands_on_practices": [
        {
            "introduction": "We begin by exploring the fundamental motivation for high-resolution schemes. While simple methods like centered differencing offer higher-order accuracy on paper, they can introduce non-physical oscillations near sharp gradients, a critical flaw in combustion modeling. This coding exercise allows you to directly compare a standard centered scheme against a Total Variation Diminishing (TVD) MUSCL scheme, providing a clear, quantitative demonstration of how and why monotonicity-preserving methods are essential for simulating scalar transport.",
            "id": "4030750",
            "problem": "Consider the one-dimensional linear advection of a passive scalar in a constant-velocity field, governed by the conservation law $$\\frac{\\partial \\phi}{\\partial t} + a \\frac{\\partial \\phi}{\\partial x} = 0,$$ on a periodic domain $$x \\in [0, L),$$ with constant advective speed $$a > 0.$$ The scalar field $$\\phi(x, t)$$ represents a bounded mixture fraction or progress variable commonly used in computational combustion, and the governing equation expresses conservation of this scalar as it is transported without sources. The exact solution of this equation preserves the maximum principle: if $$\\phi(x, 0) \\in [\\phi_{\\min}, \\phi_{\\max}]$$ pointwise at $$t = 0,$$ then $$\\phi(x, t) \\in [\\phi_{\\min}, \\phi_{\\max}]$$ for all $$t \\ge 0.$$ This property is crucial for physical realism in reactive flow simulations, where unphysical overshoots or undershoots can corrupt reaction rates and thermodynamic consistency.\n\nStarting from this fundamental base, construct a discretization to advance $$\\phi$$ by one time step using the second-order Runge–Kutta method (RK2), also known as the Heun method. Use a uniform grid of $$N$$ points with grid spacing $$\\Delta x = L / N$$ and periodic boundary conditions. Let the Courant–Friedrichs–Lewy number (CFL number) be $$\\nu = a \\Delta t / \\Delta x,$$ where $$\\Delta t$$ is the time step.\n\nFor the spatial derivative $$\\partial \\phi / \\partial x,$$ consider the following three finite difference or finite volume discretizations:\n\n- Centered differencing: $$D^{\\text{cen}} \\phi_i = \\frac{\\phi_{i+1} - \\phi_{i-1}}{2 \\Delta x}.$$\n- Upwind differencing: for $$a > 0,$$ $$D^{\\text{up}} \\phi_i = \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}.$$\n- Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL) with the minmod limiter (Total Variation Diminishing (TVD)): reconstruct piecewise linear states with limited slopes $$s_i = \\operatorname{minmod}(\\phi_i - \\phi_{i-1}, \\phi_{i+1} - \\phi_i),$$ where $$\\operatorname{minmod}(p,q) = \\begin{cases} \\operatorname{sign}(p) \\min(|p|, |q|)  \\text{if } pq > 0 \\\\ 0  \\text{otherwise} \\end{cases},$$ then compute the upwind interface flux at $$x_{i+1/2}$$ for $$a > 0$$ as $$F_{i+1/2} = a \\left(\\phi_i + \\frac{1}{2} s_i\\right),$$ and define the spatial operator $$L(\\phi)_i = - \\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x}.$$\n\nAdvance the solution by one RK2 step using the semi-discrete operator $$L(\\phi)$$ that corresponds to each spatial discretization, namely $$\\phi^{(1)} = \\phi^n + \\Delta t \\, L(\\phi^n),$$ $$\\phi^{n+1} = \\phi^n + \\frac{\\Delta t}{2} \\left(L(\\phi^n) + L(\\phi^{(1)})\\right).$$\n\nInitialize $$\\phi$$ with a bounded top-hat profile: $$\\phi(x, 0) = 1$$ for $$x \\in [x_a, x_b)$$ and $$\\phi(x, 0) = 0$$ elsewhere, with periodic wraparound, choosing $$x_a$$ and $$x_b$$ so that the discontinuities are away from the domain boundaries. The initial bounds are $$\\phi_{\\min} = 0$$ and $$\\phi_{\\max} = 1.$$ After one full RK2 step, measure:\n- Overshoot magnitude $$\\delta_{\\text{over}} = \\max\\left(0, \\max_i \\phi_i^{n+1} - 1\\right),$$\n- Undershoot magnitude $$\\delta_{\\text{under}} = \\max\\left(0, 0 - \\min_i \\phi_i^{n+1}\\right),$$\n- Maximum principle violation flag $$\\mathsf{MPV} = (\\delta_{\\text{over}} > 0) \\lor (\\delta_{\\text{under}} > 0),$$\n- Total variation $$\\operatorname{TV}(\\phi) = \\sum_{i=0}^{N-1} \\left| \\phi_{i+1} - \\phi_i \\right|,$$ with periodic indexing, and the total variation growth factor $$G_{\\text{TV}} = \\operatorname{TV}(\\phi^{n+1}) / \\operatorname{TV}(\\phi^{n}).$$\n\nYour program must implement these three spatial discretizations and the RK2 time integration, and produce the requested measures for the following test suite, each evolved by a single RK2 time step:\n- Test $$1$$ (central differencing, moderate CFL): $$L = 1,$$ $$a = 1,$$ $$N = 200,$$ $$\\nu = 0.5,$$ $$x_a = 0.25,$$ $$x_b = 0.5.$$\n- Test $$2$$ (central differencing, small CFL): $$L = 1,$$ $$a = 1,$$ $$N = 200,$$ $$\\nu = 0.1,$$ $$x_a = 0.25,$$ $$x_b = 0.5.$$\n- Test $$3$$ (upwind differencing, moderate CFL): $$L = 1,$$ $$a = 1,$$ $$N = 200,$$ $$\\nu = 0.5,$$ $$x_a = 0.25,$$ $$x_b = 0.5.$$\n- Test $$4$$ (MUSCL with minmod limiter, Strong Stability Preserving Runge–Kutta of order $$2$$ (SSP-RK2), moderate CFL): $$L = 1,$$ $$a = 1,$$ $$N = 200,$$ $$\\nu = 0.5,$$ $$x_a = 0.25,$$ $$x_b = 0.5.$$\n\nScientific realism requirement: all discretizations must enforce periodic boundary conditions, all computations must be performed in double precision, and no external inputs are permitted.\n\nFinal output format requirement: your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order for each test case: $$[\\mathsf{MPV}_1, \\delta_{\\text{over},1}, \\delta_{\\text{under},1}, G_{\\text{TV},1}, \\mathsf{MPV}_2, \\delta_{\\text{over},2}, \\delta_{\\text{under},2}, G_{\\text{TV},2}, \\mathsf{MPV}_3, \\delta_{\\text{over},3}, \\delta_{\\text{under},3}, G_{\\text{TV},3}, \\mathsf{MPV}_4, \\delta_{\\text{over},4}, \\delta_{\\text{under},4}, G_{\\text{TV},4}].$$ Each $$\\mathsf{MPV}_k$$ is a boolean, and each $$\\delta_{\\text{over},k}, \\delta_{\\text{under},k}, G_{\\text{TV},k}$$ is a floating-point number. This format must be the only output of the program.",
            "solution": "The problem posed is a well-defined and standard exercise in the field of computational fluid dynamics, specifically concerning the numerical solution of hyperbolic conservation laws. It asks for the implementation and comparative analysis of three different spatial discretization schemes for the one-dimensional linear advection equation, coupled with a second-order Runge-Kutta time integration method. The problem is scientifically grounded, internally consistent, and all parameters and conditions are specified unambiguously. Therefore, the problem is valid and a solution can be constructed.\n\nThe core of the problem is the numerical solution of the one-dimensional linear advection equation for a passive scalar $$\\phi(x, t)$$:\n$$\n\\frac{\\partial \\phi}{\\partial t} + a \\frac{\\partial \\phi}{\\partial x} = 0\n$$\nThis equation is defined on a periodic domain $$x \\in [0, L)$$ with a constant advection velocity $$a > 0$$. For numerical solution, the domain is discretized into a uniform grid of $$N$$ points $$x_i = i \\Delta x$$ for $$i = 0, 1, \\dots, N-1$$, where the grid spacing is $$\\Delta x = L/N$$. The scalar field at these discrete points is denoted by $$\\phi_i(t) \\approx \\phi(x_i, t)$$. The partial differential equation is converted into a system of ordinary differential equations (ODEs), a technique known as the method of lines:\n$$\n\\frac{d\\phi_i}{dt} = L(\\phi)_i\n$$\nwhere $$L(\\phi)_i$$ is the semi-discrete operator approximating the spatial derivative term $$-a \\frac{\\partial \\phi}{\\partial x}$$ at grid point $$x_i$$.\n\nThe time integration is performed using the second-order Runge-Kutta method (RK2), also known as Heun's method or the explicit trapezoidal rule. Given the solution $$\\phi^n$$ at time $$t_n$$, the solution $$\\phi^{n+1}$$ at time $$t_{n+1} = t_n + \\Delta t$$ is found via a two-stage process:\n$$\n\\begin{aligned}\n\\phi^{(1)} = \\phi^n + \\Delta t \\, L(\\phi^n) \\\\\n\\phi^{n+1} = \\phi^n + \\frac{\\Delta t}{2} \\left( L(\\phi^n) + L(\\phi^{(1)}) \\right)\n\\end{aligned}\n$$\nThis method is second-order accurate in time. It is also a Strong Stability Preserving (SSP) scheme, meaning that if the forward Euler step $$ \\phi \\rightarrow \\phi + \\Delta t L(\\phi) $$ is convex-stable (e.g., monotonicity-preserving) under a certain time step restriction, then the full RK2 scheme preserves that stability property under the same restriction.\n\nThe problem requires the implementation of three distinct spatial operators $$L(\\phi)_i$$.\n\n1.  **Centered Differencing:** This scheme uses a standard second-order accurate central difference stencil to approximate the spatial derivative:\n    $$\n    L^{\\text{cen}}(\\phi)_i = -a \\frac{\\phi_{i+1} - \\phi_{i-1}}{2 \\Delta x}\n    $$\n    While being second-order accurate, this scheme is known to be purely dispersive and unconditionally unstable for the pure advection problem. It generates spurious oscillations, especially near sharp gradients, and will violate the maximum principle.\n\n2.  **Upwind Differencing:** This scheme uses a one-sided stencil that accounts for the direction of information propagation. For $$a > 0$$, the information flows from left to right, so a backward difference is used:\n    $$\n    L^{\\text{up}}(\\phi)_i = -a \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}\n    $$\n    This scheme is only first-order accurate in space but is conditionally stable for a Courant–Friedrichs–Lewy (CFL) number $$\\nu = a \\Delta t / \\Delta x \\le 1$$. Its primary drawback is excessive numerical diffusion, which smears sharp features, but it typically preserves the maximum principle under the CFL condition.\n\n3.  **Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL):** This is a high-resolution finite volume method designed to be second-order accurate in smooth regions while avoiding oscillations at discontinuities. It extends the upwind scheme by reconstructing a piecewise linear profile within each grid cell. The semi-discrete equation in finite volume form is:\n    $$\n    \\frac{d\\phi_i}{dt} = - \\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x}\n    $$\n    where $$F_{i+1/2}$$ is the numerical flux at the interface between cell $$i$$ and cell $$i+1$$. For $$a>0$$, the upwind flux takes the value from the left of the interface, $$\\phi_{i+1/2}^L$$. This value is reconstructed from the cell-average value $$\\phi_i$$ and a limited slope:\n    $$\n    \\phi_{i+1/2}^L = \\phi_i + \\frac{1}{2} s_i\n    $$\n    The term $$s_i$$ represents the limited difference across the cell, chosen to prevent new extrema from forming. The minmod limiter is used:\n    $$\n    s_i = \\operatorname{minmod}(\\phi_i - \\phi_{i-1}, \\phi_{i+1} - \\phi_i)\n    $$\n    where the minmod function is defined as:\n    $$\n    \\operatorname{minmod}(p, q) = \\begin{cases} \\operatorname{sign}(p) \\min(|p|, |q|)  \\text{if } pq > 0 \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n    This limiter selects the smaller of the two adjacent undivided differences if they have the same sign, and returns $$0$$ otherwise, effectively flattening the profile near local extrema. The resulting flux is $$F_{i+1/2} = a \\phi_{i+1/2}^L$$. The full spatial operator is then:\n    $$\n    L^{\\text{muscl}}(\\phi)_i = - \\frac{a \\left(\\phi_i + \\frac{1}{2}s_i\\right) - a \\left(\\phi_{i-1} + \\frac{1}{2}s_{i-1}\\right)}{\\Delta x}\n    $$\n    This scheme is Total Variation Diminishing (TVD) when coupled with a suitable time-stepping method (like SSP-RK2) under a CFL constraint, ensuring it does not introduce spurious oscillations and respects the maximum principle.\n\nFor all schemes, periodic boundary conditions are enforced by using modular arithmetic on the grid indices, such that $$\\phi_{N+k} = \\phi_k$$.\n\nThe initial condition is a top-hat function, with $$\\phi=1$$ on a sub-interval and $$\\phi=0$$ elsewhere. The initial bounds are $$\\phi_{\\min}=0$$ and $$\\phi_{\\max}=1$$. The key metrics to be evaluated after one RK2 step are the overshoot $$\\delta_{\\text{over}}$$, the undershoot $$\\delta_{\\text{under}}$$, the maximum principle violation flag $$\\mathsf{MPV}$$, and the total variation growth factor $$G_{\\text{TV}}$$. The Total Variation (TV) of the discrete solution is $$ \\operatorname{TV}(\\phi) = \\sum_{i=0}^{N-1} |\\phi_{i+1} - \\phi_i| $$, with $$\\phi_N=\\phi_0$$. These metrics quantitatively assess the quality of each numerical scheme.\n\nThe following Python implementation solves for the specified test cases, computing all required metrics.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and evaluates three advection schemes for a 1D scalar transport problem.\n    \"\"\"\n\n    test_cases = [\n        {'L': 1.0, 'a': 1.0, 'N': 200, 'nu': 0.5, 'xa': 0.25, 'xb': 0.5, 'scheme': 'central'},\n        {'L': 1.0, 'a': 1.0, 'N': 200, 'nu': 0.1, 'xa': 0.25, 'xb': 0.5, 'scheme': 'central'},\n        {'L': 1.0, 'a': 1.0, 'N': 200, 'nu': 0.5, 'xa': 0.25, 'xb': 0.5, 'scheme': 'upwind'},\n        {'L': 1.0, 'a': 1.0, 'N': 200, 'nu': 0.5, 'xa': 0.25, 'xb': 0.5, 'scheme': 'muscl'},\n    ]\n\n    results = []\n\n    def get_spatial_operator(phi, scheme, dx, a, N):\n        \"\"\"Computes the semi-discrete spatial operator L(phi).\"\"\"\n        if scheme == 'central':\n            # L(phi)_i = -a * (phi_{i+1} - phi_{i-1}) / (2*dx)\n            phi_p1 = np.roll(phi, -1)\n            phi_m1 = np.roll(phi, 1)\n            return -a * (phi_p1 - phi_m1) / (2.0 * dx)\n        elif scheme == 'upwind':\n            # L(phi)_i = -a * (phi_i - phi_{i-1}) / dx for a  0\n            phi_m1 = np.roll(phi, 1)\n            return -a * (phi - phi_m1) / dx\n        elif scheme == 'muscl':\n            # Finite Volume MUSCL scheme with minmod limiter\n            # L(phi)_i = -(F_{i+1/2} - F_{i-1/2}) / dx\n\n            # 1. Compute undivided differences\n            delta_bwd = phi - np.roll(phi, 1)\n            delta_fwd = np.roll(phi, -1) - phi\n\n            # 2. Apply minmod limiter to get slopes s_i\n            # minmod(p, q) = sign(p) * min(|p|, |q|) if p*q  0, else 0\n            pq = delta_bwd * delta_fwd\n            s = np.where(pq  0, np.sign(delta_bwd) * np.minimum(np.abs(delta_bwd), np.abs(delta_fwd)), 0)\n\n            # 3. Reconstruct value at right interface of cell i (phi_{i+1/2}^L)\n            phi_L = phi + 0.5 * s\n\n            # 4. Compute upwind flux F_{i+1/2} = a * phi_{i+1/2}^L\n            flux_interface_right = a * phi_L\n\n            # 5. F_{i-1/2} is the right flux of the cell i-1\n            flux_interface_left = np.roll(flux_interface_right, 1)\n            \n            return -(flux_interface_right - flux_interface_left) / dx\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n\n    for case in test_cases:\n        L = case['L']\n        a = case['a']\n        N = case['N']\n        nu = case['nu']\n        xa = case['xa']\n        xb = case['xb']\n        scheme = case['scheme']\n\n        # Grid and time step setup\n        dx = L / N\n        dt = nu * dx / a\n        x = np.linspace(0, L, N, endpoint=False)\n\n        # Initial condition: top-hat profile\n        phi_n = np.zeros(N, dtype=np.float64)\n        # Find indices corresponding to xa and xb\n        # where condition is x_i = xa and x_i  xb\n        indices = np.where((x = xa)  (x  xb))\n        phi_n[indices] = 1.0\n        \n        # Calculate initial Total Variation\n        tv_n = np.sum(np.abs(np.roll(phi_n, -1) - phi_n))\n        \n        # RK2 time step\n        # Stage 1\n        L_n = get_spatial_operator(phi_n, scheme, dx, a, N)\n        phi_1 = phi_n + dt * L_n\n        \n        # Stage 2\n        L_1 = get_spatial_operator(phi_1, scheme, dx, a, N)\n        phi_np1 = phi_n + 0.5 * dt * (L_n + L_1)\n\n        # Calculate metrics\n        phi_max_np1 = np.max(phi_np1)\n        phi_min_np1 = np.min(phi_np1)\n\n        delta_over = np.maximum(0.0, phi_max_np1 - 1.0)\n        delta_under = np.maximum(0.0, 0.0 - phi_min_np1)\n        \n        mpv = (delta_over  1e-15) or (delta_under  1e-15) # Use tolerance for float comparison\n\n        tv_np1 = np.sum(np.abs(np.roll(phi_np1, -1) - phi_np1))\n        \n        if tv_n  1e-15:\n            g_tv = tv_np1 / tv_n\n        else:\n            g_tv = 1.0 if tv_np1  1e-15 else np.inf\n\n        results.extend([mpv, delta_over, delta_under, g_tv])\n\n    # Format the final output string\n    # Convert elements to string representation for joining\n    output_str_list = []\n    for item in results:\n        if isinstance(item, bool):\n            output_str_list.append(str(item))\n        else:\n            # Use non-scientific notation for consistency\n            output_str_list.append(f'{item:.15f}')\n\n    print(f\"[{','.join(output_str_list)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "After appreciating the role of limiters in preventing oscillations, it is crucial to understand their mechanical operation. This exercise provides a hands-on calculation to dissect the behavior of the Monotonized Central (MC) limiter near a discontinuity. By computing the interface states manually, you will see precisely how the limiter function makes a local choice to reduce the scheme to first-order, sacrificing accuracy where necessary to maintain physical realism and stability.",
            "id": "4030707",
            "problem": "Consider the one-dimensional scalar advection equation for a combustion-relevant passive scalar (e.g., mixture fraction) given by $\\partial_{t} \\phi + u \\, \\partial_{x} \\phi = 0$, posed on a uniform finite volume mesh with cell centers at $x_{i}$ and cell width $\\Delta x$. High-resolution flux reconstruction is performed using piecewise linear profiles limited to prevent spurious oscillations. Specifically, the Monotonized Central (MC) limiter is used to define the cellwise slope $\\sigma_{i}$ as $\\sigma_{i} = \\operatorname{minmod}\\!\\left( \\frac{\\phi_{i+1} - \\phi_{i-1}}{2}, \\, 2(\\phi_{i} - \\phi_{i-1}), \\, 2(\\phi_{i+1} - \\phi_{i}) \\right)$, where the minmod operator is defined by $\\operatorname{minmod}(a,b,c) = \\begin{cases} \\min\\{|a|,|b|,|c|\\} \\, \\operatorname{sign}(a)  \\text{if } \\operatorname{sign}(a)=\\operatorname{sign}(b)=\\operatorname{sign}(c) \\\\ 0  \\text{otherwise} \\end{cases}$. The limited piecewise linear reconstruction yields interface states $\\phi_{i+1/2}^{L} = \\phi_{i} + \\frac{1}{2}\\sigma_{i}$ and $\\phi_{i+1/2}^{R} = \\phi_{i+1} - \\frac{1}{2}\\sigma_{i+1}$.\n\nYou are given a discrete dataset that contains both smooth and discontinuous regions representative of computational combustion applications, with uniform grid spacing $\\Delta x = 0.01$ and advection speed $u = -1$. At indices $i=-1,0,1,2,3,4$, the cell-averaged scalar values are\n$\\phi_{-1} = 0.1800$, $\\phi_{0} = 0.2474$, $\\phi_{1} = 0.3120$, $\\phi_{2} = 0.3716$, $\\phi_{3} = 0.9000$, and $\\phi_{4} = 0.9000$. This dataset is smooth and monotone increasing over $i=0,1,2$ and contains a jump between $i=2$ and $i=3$.\n\nStarting from the scalar conservation law and the definition of the MC limiter as a Total Variation Diminishing (TVD) reconstruction, compute the interface states $\\phi_{i+1/2}^{L}$ and $\\phi_{i+1/2}^{R}$ at $i=1$ using the MC limiter. Then, assess the local order of accuracy $p$ of the numerical flux at the interface $x_{i+1/2}$ for this problem given $u0$ (that is, the upwind state used in the flux comes from the right). Your assessment must be grounded in a local Taylor expansion argument that relates the choice made by the limiter to the truncation error scaling in $\\Delta x$.\n\nRound the interface state values to five significant figures. The order $p$ is to be reported as an integer. Express your final answer as a row vector containing $\\phi_{i+1/2}^{L}$, $\\phi_{i+1/2}^{R}$, and $p$ in that order. The scalar values are dimensionless.",
            "solution": "The problem requires the computation of the reconstructed interface states of a passive scalar $\\phi$ at the interface $x_{i+1/2}$ for $i=1$ (i.e., at $x_{3/2}$) and the subsequent determination of the local order of accuracy of the numerical flux at this interface. The flow is governed by the one-dimensional scalar advection equation, $\\partial_{t} \\phi + u \\, \\partial_{x} \\phi = 0$, with a constant advection velocity $u = -1$. The flux reconstruction uses a piecewise linear profile with the Monotonized Central (MC) limiter.\n\nThe task is divided into two parts: first, the calculation of the left and right interface states, $\\phi_{3/2}^{L}$ and $\\phi_{3/2}^{R}$; second, the assessment of the local order of accuracy, $p$, for the numerical flux.\n\n**Part 1: Computation of Interface States at $x_{3/2}$**\n\nThe interface states are given by the formulae:\n$$ \\phi_{i+1/2}^{L} = \\phi_{i} + \\frac{1}{2}\\sigma_{i} $$\n$$ \\phi_{i+1/2}^{R} = \\phi_{i+1} - \\frac{1}{2}\\sigma_{i+1} $$\nFor the interface at $i=1$, we need to compute $\\phi_{3/2}^{L}$ and $\\phi_{3/2}^{R}$. This requires the calculation of the limited slopes $\\sigma_{1}$ and $\\sigma_{2}$.\n\nThe cellwise slope $\\sigma_i$ is determined by the MC limiter:\n$$ \\sigma_{i} = \\operatorname{minmod}\\!\\left( \\frac{\\phi_{i+1} - \\phi_{i-1}}{2}, \\, 2(\\phi_{i} - \\phi_{i-1}), \\, 2(\\phi_{i+1} - \\phi_{i}) \\right) $$\nwhere the $\\operatorname{minmod}$ operator returns the argument with the smallest absolute value if all arguments have the same sign, and $0$ otherwise.\n\nThe given cell-averaged scalar values are:\n$\\phi_{-1} = 0.1800$, $\\phi_{0} = 0.2474$, $\\phi_{1} = 0.3120$, $\\phi_{2} = 0.3716$, $\\phi_{3} = 0.9000$, and $\\phi_{4} = 0.9000$.\n\nFirst, we compute the slope $\\sigma_1$ for cell $i=1$. The arguments for the $\\operatorname{minmod}$ function are:\n1. Centered difference term: $a_1 = \\frac{\\phi_{2} - \\phi_{0}}{2} = \\frac{0.3716 - 0.2474}{2} = \\frac{0.1242}{2} = 0.0621$.\n2. Backward difference term (doubled): $b_1 = 2(\\phi_{1} - \\phi_{0}) = 2(0.3120 - 0.2474) = 2(0.0646) = 0.1292$.\n3. Forward difference term (doubled): $c_1 = 2(\\phi_{2} - \\phi_{1}) = 2(0.3716 - 0.3120) = 2(0.0596) = 0.1192$.\n\nAll three arguments $a_1$, $b_1$, and $c_1$ are positive. Therefore, $\\sigma_1$ is the minimum of their absolute values:\n$$ \\sigma_1 = \\min\\{|0.0621|, |0.1292|, |0.1192|\\} = 0.0621 $$\n\nNext, we compute the slope $\\sigma_2$ for cell $i=2$. The arguments are:\n1. Centered difference term: $a_2 = \\frac{\\phi_{3} - \\phi_{1}}{2} = \\frac{0.9000 - 0.3120}{2} = \\frac{0.5880}{2} = 0.2940$.\n2. Backward difference term (doubled): $b_2 = 2(\\phi_{2} - \\phi_{1}) = 2(0.3716 - 0.3120) = 2(0.0596) = 0.1192$.\n3. Forward difference term (doubled): $c_2 = 2(\\phi_{3} - \\phi_{2}) = 2(0.9000 - 0.3716) = 2(0.5284) = 1.0568$.\n\nAll three arguments $a_2$, $b_2$, and $c_2$ are positive. Therefore, $\\sigma_2$ is the minimum of their absolute values:\n$$ \\sigma_2 = \\min\\{|0.2940|, |0.1192|, |1.0568|\\} = 0.1192 $$\nThe limiter has selected the backward difference term $2(\\phi_2 - \\phi_1)$, which is indicative of a steepening gradient ahead of cell $2$, caused by the jump to $\\phi_3=0.9000$.\n\nNow we can compute the interface states at $x_{3/2}$:\n$$ \\phi_{3/2}^{L} = \\phi_{1} + \\frac{1}{2}\\sigma_{1} = 0.3120 + \\frac{1}{2}(0.0621) = 0.3120 + 0.03105 = 0.34305 $$\n$$ \\phi_{3/2}^{R} = \\phi_{2} - \\frac{1}{2}\\sigma_{2} = 0.3716 - \\frac{1}{2}(0.1192) = 0.3716 - 0.0596 = 0.3120 $$\nRounding to five significant figures, the interface states are $\\phi_{3/2}^{L} = 0.34305$ and $\\phi_{3/2}^{R} = 0.31200$.\n\n**Part 2: Assessment of the Local Order of Accuracy**\n\nThe numerical flux for the scalar advection equation at an interface $x_{i+1/2}$ is $F_{i+1/2} = u \\phi_{i+1/2}^{\\text{upwind}}$. Since the advection velocity is negative ($u = -1$), the \"upwind\" direction is from the right. Thus, the flux at interface $x_{3/2}$ is determined by the right state, $\\phi_{3/2}^{R}$:\n$$ F_{3/2} = u \\, \\phi_{3/2}^{R} $$\nThe local order of accuracy $p$ of the flux is determined by the order of the error in the reconstructed state, i.e., how $(\\phi_{3/2}^{R} - \\phi(x_{3/2}))$ scales with the grid spacing $\\Delta x$. Here, $\\phi(x_{3/2})$ is the exact solution at the interface.\n\nFrom our calculation, we found $\\phi_{3/2}^{R} = 0.3120$, which is exactly the cell-averaged value $\\phi_1$. This occurred because the limiter chose $\\sigma_2 = 2(\\phi_2 - \\phi_1)$, leading to $\\phi_{3/2}^{R} = \\phi_2 - \\frac{1}{2}(2(\\phi_2 - \\phi_1)) = \\phi_1$.\n\nThe numerical scheme is therefore using the cell-averaged value from the downwind cell, cell $1$, as the state for the flux calculation at interface $x_{3/2}$. We now analyze the truncation error associated with this choice.\n\nLet's perform a Taylor series expansion. The cell center is $x_1$, and the interface is at $x_{3/2} = x_1 + \\Delta x/2$. The cell average $\\phi_1$ is related to the point value $\\phi(x_1)$ by $\\phi_1 = \\phi(x_1) + O(\\Delta x^2)$ for a smooth solution. The exact value at the interface can be expanded around $x_1$:\n$$ \\phi(x_{3/2}) = \\phi(x_1 + \\Delta x/2) = \\phi(x_1) + \\frac{\\Delta x}{2}\\phi'(x_1) + \\frac{1}{2}\\left(\\frac{\\Delta x}{2}\\right)^2 \\phi''(x_1) + \\dots = \\phi(x_1) + \\frac{\\Delta x}{2}\\phi'(x_1) + O(\\Delta x^2) $$\nThe error in the reconstructed state is:\n$$ \\text{Error} = \\phi_{3/2}^{R} - \\phi(x_{3/2}) = \\phi_1 - \\phi(x_{3/2}) $$\nSubstituting the expansions:\n$$ \\text{Error} = (\\phi(x_1) + O(\\Delta x^2)) - \\left(\\phi(x_1) + \\frac{\\Delta x}{2}\\phi'(x_1) + O(\\Delta x^2)\\right) $$\n$$ \\text{Error} = -\\frac{\\Delta x}{2}\\phi'(x_1) + O(\\Delta x^2) $$\nThe leading term in the error is proportional to $\\Delta x^1$. This indicates that the local truncation error of the flux is of the first order. The presence of a sharp gradient has forced the TVD limiter to reduce the scheme's accuracy locally to prevent spurious oscillations, resulting in a first-order accurate flux at this specific interface.\n\nTherefore, the local order of accuracy is $p=1$.\n\nFinal values to be reported are $\\phi_{3/2}^{L}$, $\\phi_{3/2}^{R}$, and $p$.\n$\\phi_{3/2}^{L} = 0.34305$\n$\\phi_{3/2}^{R} = 0.31200$\n$p = 1$\nThese are arranged in a row vector as requested.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 0.34305  0.31200  1 \\end{pmatrix} } $$"
        },
        {
            "introduction": "Developing a numerical solver is incomplete without rigorous verification of its correctness and accuracy. This capstone practice introduces the Method of Manufactured Solutions (MMS), a gold-standard technique for code verification. You will implement a complete high-resolution solver using the MUSCL scheme and an SSP-RK2 integrator, and then perform a formal convergence analysis to confirm that your code achieves its theoretical order of accuracy, a vital skill for any computational scientist.",
            "id": "4030747",
            "problem": "Consider the one-dimensional periodic domain $x\\in[0,1]$ with a spatially uniform velocity $u\\in\\mathbb{R}$. Let the scalar field $\\phi(x,t)$ satisfy the conservation law\n$$\n\\partial_t \\phi(x,t) + \\partial_x\\left(u\\,\\phi(x,t)\\right) = S(x,t),\n$$\nwhere $S(x,t)$ is a source term constructed by the Method of Manufactured Solutions (MMS) so that a closed-form exact solution is known. Define the manufactured solution\n$$\n\\phi_{\\mathrm{ex}}(x,t) = \\sin\\left(2\\pi x\\right)\\cos\\left(2\\pi t\\right) + \\frac{1}{4}\\,\\cos\\left(4\\pi x - t\\right),\n$$\nwith constant velocity $u$ and source $S(x,t)$ chosen to satisfy the partial differential equation exactly when $\\phi=\\phi_{\\mathrm{ex}}$. Explicitly,\n$$\nS(x,t) = \\partial_t \\phi_{\\mathrm{ex}}(x,t) + u\\,\\partial_x \\phi_{\\mathrm{ex}}(x,t).\n$$\nYou must implement a high-resolution advection solver suitable for Computational Fluid Dynamics in Combustion (computational combustion). Use the Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) with a van Leer Total Variation Diminishing (TVD) slope limiter for spatial discretization of the flux gradient, and the second-order Strong Stability-Preserving Runge-Kutta (SSP RK2) method for time integration. Impose periodic boundary conditions. The spatial discretization must reconstruct left and right states at interfaces using limited slopes and compute the upwind flux $F_{i+1/2}=u\\,\\phi^{\\mathrm{upwind}}$ accordingly. The time integration scheme must advance the solution from $t=0$ to a prescribed final time $T$.\n\nThe numerical test harness must compute the discrete $\\ell^2$-error at the final time,\n$$\n\\mathcal{E} = \\left(\\Delta x\\,\\sum_{i=0}^{N_x-1} \\left(\\phi_i(T) - \\phi_{\\mathrm{ex}}(x_i,T)\\right)^2\\right)^{1/2},\n$$\nwhere $N_x$ is the number of uniformly spaced cells, $\\Delta x = 1/N_x$, and $x_i = \\left(i+\\frac{1}{2}\\right)\\Delta x$ are cell centers. For each test, initialize $\\phi(x,0) = \\phi_{\\mathrm{ex}}(x,0)$ and advance to the specified $T$ using your solver. You may assume dimensionless variables; no physical units are required.\n\nYour program must perform the following three groups of tests and aggregate their outcomes:\n\n1. Spatial convergence study (general case):\n   - Use constant velocity $u = 0.7$, final time $T = 0.2$, and Courant–Friedrichs–Lewy (CFL) number $\\mathrm{CFL} = 0.4$.\n   - Compute the time step as $\\Delta t = \\mathrm{CFL}\\,\\Delta x/|u|$ to ensure stability.\n   - Run with $N_x \\in \\{50,100,200,400\\}$ and compute the discrete $\\ell^2$-error $\\mathcal{E}$ at $t=T$ for each $N_x$.\n   - Report the observed spatial order $p$, defined as the slope of $\\log(\\mathcal{E})$ versus $\\log(\\Delta x)$ via linear regression over the set of $(\\Delta x,\\mathcal{E})$ values.\n\n2. Temporal convergence study (time-accuracy focus):\n   - Use constant velocity $u = 0.7$, final time $T = 0.2$, and a fine spatial resolution $N_x = 800$.\n   - Let $\\mathrm{CFL}_{\\max} = 0.9$ and compute the maximum stable time step $\\Delta t_{\\max} = \\mathrm{CFL}_{\\max}\\,\\Delta x/|u|$.\n   - Run with time steps $\\Delta t \\in \\{0.8\\,\\Delta t_{\\max},\\,0.4\\,\\Delta t_{\\max},\\,0.2\\,\\Delta t_{\\max},\\,0.1\\,\\Delta t_{\\max}\\}$ and compute the discrete $\\ell^2$-error $\\mathcal{E}$ at $t=T$ for each $\\Delta t$.\n   - Report the observed temporal order $q$, defined as the slope of $\\log(\\mathcal{E})$ versus $\\log(\\Delta t)$ via linear regression over the set of $(\\Delta t,\\mathcal{E})$ values.\n\n3. Edge case (boundary condition and degeneracy check):\n   - Use $u = 0$, final time $T = 0.2$, $N_x = 50$, and time step $\\Delta t = T/200$.\n   - Since advection vanishes when $u=0$, the equation reduces to $\\partial_t \\phi = S$, which your SSP RK2 integrator should solve with the exact source for the manufactured solution.\n   - Compute the discrete $\\ell^2$-error $\\mathcal{E}$ and return a boolean indicating whether $\\mathcal{E}  5\\times 10^{-6}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, specifically $[p,q,\\mathrm{edge}]$, where $p$ and $q$ are real numbers (floats) and $\\mathrm{edge}$ is a boolean.\n\nDefinitions and reminders required for implementation:\n- Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL): reconstruct interface states using limited slopes $s_i$ so that $\\phi^{L}_{i+1/2} = \\phi_i + \\frac{1}{2}s_i$ and $\\phi^{R}_{i+1/2} = \\phi_{i+1} - \\frac{1}{2}s_{i+1}$.\n- Van Leer Total Variation Diminishing (TVD) slope limiter: for consecutive differences $\\Delta_{i-1/2} = \\phi_i - \\phi_{i-1}$ and $\\Delta_{i+1/2} = \\phi_{i+1} - \\phi_i$, define\n$$\ns_i = \\begin{cases}\n\\dfrac{2\\,\\Delta_{i-1/2}\\,\\Delta_{i+1/2}}{\\Delta_{i-1/2} + \\Delta_{i+1/2}}  \\text{if } \\Delta_{i-1/2}\\,\\Delta_{i+1/2} > 0\\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n- Upwind flux for linear advection with constant $u$: $F_{i+1/2} = u\\,\\phi^{\\mathrm{upwind}}$ with $\\phi^{\\mathrm{upwind}} = \\phi^{L}_{i+1/2}$ if $u>0$ and $\\phi^{\\mathrm{upwind}} = \\phi^{R}_{i+1/2}$ if $u0$.\n- Strong Stability-Preserving Runge-Kutta (SSP RK2): advance via\n$$\n\\phi^{(1)} = \\phi^n + \\Delta t\\,\\mathcal{R}(\\phi^n,t^n),\\quad\n\\phi^{n+1} = \\frac{1}{2}\\phi^n + \\frac{1}{2}\\left[\\phi^{(1)} + \\Delta t\\,\\mathcal{R}(\\phi^{(1)},t^n+\\Delta t)\\right]\n$$\nwhere $\\mathcal{R}(\\phi,t) = S(\\cdot,t) - \\partial_x(u\\,\\phi)$ is the semi-discrete right-hand side with the spatial operator discretized by MUSCL-TVD.\n\nImplement the solver and run the three studies exactly as specified. Your final program output must be a single line in the format $[p,q,\\mathrm{edge}]$ with the two real numbers and one boolean.",
            "solution": "The user-provided problem statement is subjected to rigorous validation and is determined to be **valid**. It represents a well-posed, scientifically grounded, and objective problem in the field of computational fluid dynamics, specifically focused on the verification of a high-resolution numerical scheme for scalar advection. The problem tasks are clearly defined, the governing equations and numerical methods are standard and correctly specified, and the Method of Manufactured Solutions (MMS) provides a robust framework for assessing the solver's accuracy.\n\nWe proceed with a complete, principled solution.\n\n### 1. Governing Equation and Manufactured Solution\n\nThe problem concerns the one-dimensional linear advection equation on a periodic domain $x\\in[0,1]$:\n$$\n\\partial_t \\phi + u\\,\\partial_x \\phi = S(x,t)\n$$\nwhere $\\phi(x,t)$ is a scalar field, $u$ is a constant velocity, and $S(x,t)$ is a source term.\n\nThe Method of Manufactured Solutions (MMS) is employed, for which an exact analytical solution $\\phi_{\\mathrm{ex}}(x,t)$ is prescribed, and the source term $S(x,t)$ is derived to ensure that $\\phi_{\\mathrm{ex}}$ satisfies the governing equation identically. The manufactured solution is given by:\n$$\n\\phi_{\\mathrm{ex}}(x,t) = \\sin\\left(2\\pi x\\right)\\cos\\left(2\\pi t\\right) + \\frac{1}{4}\\,\\cos\\left(4\\pi x - t\\right)\n$$\nThe source term $S(x,t)$ is therefore defined as $S(x,t) = \\partial_t \\phi_{\\mathrm{ex}} + u\\,\\partial_x \\phi_{\\mathrm{ex}}$. The required partial derivatives are:\n$$\n\\partial_t \\phi_{\\mathrm{ex}}(x,t) = -2\\pi \\sin(2\\pi x)\\sin(2\\pi t) + \\frac{1}{4} \\sin(4\\pi x - t)\n$$\n$$\n\\partial_x \\phi_{\\mathrm{ex}}(x,t) = 2\\pi \\cos(2\\pi x)\\cos(2\\pi t) - \\pi \\sin(4\\pi x - t)\n$$\nSubstituting these expressions yields the explicit form of the source term:\n$$\nS(x,t) = -2\\pi \\sin(2\\pi x)\\sin(2\\pi t) + \\frac{1}{4} \\sin(4\\pi x - t) + u \\left( 2\\pi \\cos(2\\pi x)\\cos(2\\pi t) - \\pi \\sin(4\\pi x - t) \\right)\n$$\n\n### 2. Numerical Discretization\n\nThe solution is advanced in time on a uniform grid of $N_x$ cells, with cell width $\\Delta x = 1/N_x$ and cell centers $x_i = (i+1/2)\\Delta x$ for $i=0, \\dots, N_x-1$. A finite volume method is used, where the cell-averaged quantity $\\phi_i(t) \\approx \\frac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} \\phi(x,t)\\,dx$ evolves according to the semi-discrete equation:\n$$\n\\frac{d\\phi_i}{dt} + \\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x} = S(x_i, t)\n$$\nHere, $F_{i\\pm 1/2}$ are the numerical fluxes at the cell interfaces. The right-hand side of this system of ordinary differential equations (ODEs), $\\mathcal{R}_i(\\phi, t) = S(x_i, t) - (F_{i+1/2} - F_{i-1/2})/\\Delta x$, is integrated in time.\n\n#### 2.1. Spatial Discretization: MUSCL-TVD Scheme\n\nTo achieve second-order spatial accuracy while avoiding spurious oscillations near sharp gradients, the Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) is employed. This scheme reconstructs a piecewise linear representation of the solution within each cell, from which values at the cell interfaces ($\\phi^L_{i+1/2}$ and $\\phi^R_{i+1/2}$) are determined.\n\nThe key steps are as follows:\n\n1.  **Slope Limiting**: To ensure the Total Variation Diminishing (TVD) property, the slopes of the linear reconstructions are limited. The problem specifies the use of the van Leer limiter. For each cell $i$, we compute a limited difference, denoted $s_i$, based on the differences in neighboring cells, $\\Delta_{i-1/2} = \\phi_i - \\phi_{i-1}$ and $\\Delta_{i+1/2} = \\phi_{i+1} - \\phi_i$:\n    $$\n    s_i = \\begin{cases}\n    \\dfrac{2\\,\\Delta_{i-1/2}\\,\\Delta_{i+1/2}}{\\Delta_{i-1/2} + \\Delta_{i+1/2}}  \\text{if } \\Delta_{i-1/2}\\,\\Delta_{i+1/2} > 0\\\\\n    0  \\text{otherwise}\n    \\end{cases}\n    $$\n    This formulation for $s_i$ corresponds to $\\sigma_i \\Delta x$, where $\\sigma_i$ is the limited slope. The condition $\\Delta_{i-1/2}\\,\\Delta_{i+1/2} > 0$ restricts the higher-order reconstruction to regions where the solution is monotonic, setting the slope to zero at local extrema to prevent oscillations. Periodic boundary conditions are handled by using ghost cells, such that $\\phi_{-1} = \\phi_{N_x-1}$ and $\\phi_{N_x} = \\phi_0$.\n\n2.  **Interface Reconstruction**: The limited differences $s_i$ are used to reconstruct the scalar values at the left and right sides of each interface $x_{i+1/2}$:\n    $$\n    \\phi^{L}_{i+1/2} = \\phi_i + \\frac{1}{2}s_i\n    $$\n    $$\n    \\phi^{R}_{i+1/2} = \\phi_{i+1} - \\frac{1}{2}s_{i+1}\n    $$\n\n3.  **Upwind Flux**: The numerical flux $F_{i+1/2}$ is calculated using an upwind criterion based on the sign of the constant velocity $u$:\n    $$\n    F_{i+1/2} = u\\,\\phi^{\\mathrm{upwind}}_{i+1/2} = \\begin{cases}\n    u\\,\\phi^{L}_{i+1/2},  \\text{if } u > 0, \\\\\n    u\\,\\phi^{R}_{i+1/2},  \\text{if } u  0, \\\\\n    0,  \\text{if } u = 0.\n    \\end{cases}\n    $$\n\n#### 2.2. Temporal Discretization: SSP RK2 Scheme\n\nThe system of ODEs is integrated in time using the second-order Strong Stability-Preserving Runge-Kutta (SSP RK2) method. Given the solution vector $\\phi^n$ at time $t^n$, the solution at the next time step, $\\phi^{n+1}$, is computed in two stages:\n$$\n\\phi^{(1)} = \\phi^n + \\Delta t\\,\\mathcal{R}(\\phi^n, t^n)\n$$\n$$\n\\phi^{n+1} = \\frac{1}{2}\\phi^n + \\frac{1}{2}\\left[\\phi^{(1)} + \\Delta t\\,\\mathcal{R}(\\phi^{(1)}, t^n + \\Delta t)\\right]\n$$\nwhere $\\mathcal{R}(\\phi, t)$ is the vector of semi-discrete residuals for all cells, and $\\Delta t$ is the time step, chosen to satisfy the Courant-Friedrichs-Lewy (CFL) stability condition.\n\n### 3. Verification and Error Analysis\n\nThe implemented solver is verified by performing the three studies laid out in the problem statement. The accuracy is quantified by the discrete $\\ell^2$-error norm at the final time $T$:\n$$\n\\mathcal{E} = \\left(\\Delta x\\,\\sum_{i=0}^{N_x-1} \\left(\\phi_i(T) - \\phi_{\\mathrm{ex}}(x_i,T)\\right)^2\\right)^{1/2}\n$$\nThe observed orders of convergence in space ($p$) and time ($q$) are computed via linear regression on the logarithm of the error versus the logarithm of the grid spacing or time step, respectively. The edge case with $u=0$ verifies the correct implementation of the source term integration and the robustness of the advection scheme in the zero-velocity limit.",
            "answer": "```python\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to run the three specified test cases and print the results.\n    \"\"\"\n\n    # Analytic helper functions for the Method of Manufactured Solutions\n    def phi_exact(x, t):\n        \"\"\"Computes the exact manufactured solution phi_ex(x, t).\"\"\"\n        term1 = np.sin(2 * np.pi * x) * np.cos(2 * np.pi * t)\n        term2 = 0.25 * np.cos(4 * np.pi * x - t)\n        return term1 + term2\n\n    def source_term_func(x, t, u):\n        \"\"\"Computes the source term S(x, t, u) for the manufactured solution.\"\"\"\n        dphi_dt = -2 * np.pi * np.sin(2 * np.pi * x) * np.sin(2 * np.pi * t) + \\\n                  0.25 * np.sin(4 * np.pi * x - t)\n        dphi_dx = 2 * np.pi * np.cos(2 * np.pi * x) * np.cos(2 * np.pi * t) - \\\n                  np.pi * np.sin(4 * np.pi * x - t)\n        return dphi_dt + u * dphi_dx\n\n    def calculate_rhs(phi, x_grid, t, u, dx, Nx):\n        \"\"\"\n        Calculates the right-hand-side (RHS) of the semi-discrete equation\n        using the MUSCL-TVD scheme.\n        RHS = S(x,t) - (F_{i+1/2} - F_{i-1/2}) / dx\n        \"\"\"\n        # Pad the solution array with 1 ghost cell on each side for periodic BCs\n        phi_padded = np.pad(phi, (1, 1), 'wrap')\n\n        # 1. Calculate limited slopes using the van Leer limiter\n        delta_m = phi_padded[1:-1] - phi_padded[0:-2] # phi_i - phi_{i-1}\n        delta_p = phi_padded[2:] - phi_padded[1:-1]   # phi_{i+1} - phi_i\n        \n        product = delta_m * delta_p\n        slopes = np.zeros(Nx)\n        mask = product  0\n        \n        # Denominator is delta_m + delta_p. If it's zero, product = 0, so mask is False.\n        # This naturally avoids division by zero.\n        denominator = delta_m[mask] + delta_p[mask]\n        slopes[mask] = (2.0 * product[mask]) / denominator\n\n        # 2. Reconstruct interface values and compute upwind flux\n        slopes_padded = np.pad(slopes, (1, 1), 'wrap')\n\n        # Values at left side of interface i+1/2, from cell i\n        phi_L = phi + 0.5 * slopes\n        \n        # Values at right side of interface i+1/2, from cell i+1\n        phi_R = phi_padded[2:] - 0.5 * slopes_padded[2:]\n\n        if u  0:\n            phi_upwind = phi_L\n        elif u  0:\n            phi_upwind = phi_R\n        else: # u == 0\n            phi_upwind = np.zeros(Nx)\n\n        fluxes = u * phi_upwind  # Fluxes F_{i+1/2} for i=0..Nx-1\n\n        # 3. Compute flux divergence\n        fluxes_left = np.roll(fluxes, 1) # Fluxes F_{i-1/2}\n        flux_divergence = (fluxes - fluxes_left) / dx\n\n        # 4. Compute source term\n        source = source_term_func(x_grid, t, u)\n\n        return source - flux_divergence\n\n    def run_solver(Nx, T, u, dt_specified=None, cfl=None):\n        \"\"\"\n        Core solver that integrates the PDE from t=0 to t=T.\n        \"\"\"\n        dx = 1.0 / Nx\n        x_grid = (np.arange(Nx) + 0.5) * dx\n        \n        phi = phi_exact(x_grid, 0.0)\n        \n        t = 0.0\n        \n        if dt_specified is not None:\n            dt = dt_specified\n        elif cfl is not None:\n            if u == 0:\n                # Fallback for u=0 case as CFL-based dt would be infinite\n                dt = T / 1000 \n            else:\n                dt = cfl * dx / np.abs(u)\n        else:\n            raise ValueError(\"Either dt_specified or cfl must be provided.\")\n\n        while t  T:\n            # Adjust final time step to land exactly on T\n            current_dt = min(dt, T - t)\n            \n            # SSP RK2 Time Integration\n            # Stage 1\n            rhs1 = calculate_rhs(phi, x_grid, t, u, dx, Nx)\n            phi1 = phi + current_dt * rhs1\n            \n            # Stage 2\n            rhs2 = calculate_rhs(phi1, x_grid, t + current_dt, u, dx, Nx)\n            phi = 0.5 * phi + 0.5 * (phi1 + current_dt * rhs2)\n            \n            t += current_dt\n\n        # Compute L2 error\n        phi_final_exact = phi_exact(x_grid, T)\n        error = np.sqrt(dx * np.sum((phi - phi_final_exact)**2))\n        return error\n\n    # --- Test Case 1: Spatial Convergence ---\n    def test_spatial_convergence():\n        u = 0.7\n        T = 0.2\n        cfl = 0.4\n        Nx_values = [50, 100, 200, 400]\n        \n        log_dx = []\n        log_err = []\n        \n        for Nx in Nx_values:\n            error = run_solver(Nx=Nx, T=T, u=u, cfl=cfl)\n            dx = 1.0 / Nx\n            log_dx.append(np.log(dx))\n            log_err.append(np.log(error))\n            \n        # Linear regression to find the order of convergence\n        slope, _, _, _, _ = stats.linregress(log_dx, log_err)\n        return slope\n\n    # --- Test Case 2: Temporal Convergence ---\n    def test_temporal_convergence():\n        u = 0.7\n        T = 0.2\n        Nx = 800\n        cfl_max = 0.9\n        dx = 1.0 / Nx\n        dt_max = cfl_max * dx / np.abs(u)\n        dt_factors = [0.8, 0.4, 0.2, 0.1]\n        \n        log_dt = []\n        log_err = []\n        \n        for factor in dt_factors:\n            dt = factor * dt_max\n            error = run_solver(Nx=Nx, T=T, u=u, dt_specified=dt)\n            log_dt.append(np.log(dt))\n            log_err.append(np.log(error))\n            \n        slope, _, _, _, _ = stats.linregress(log_dt, log_err)\n        return slope\n\n    # --- Test Case 3: Edge Case (u=0) ---\n    def test_edge_case():\n        u = 0.0\n        T = 0.2\n        Nx = 50\n        dt = T / 200.0  # 0.001\n        \n        error = run_solver(Nx=Nx, T=T, u=u, dt_specified=dt)\n        return error  5e-6\n\n    # Run tests and collect results\n    p = test_spatial_convergence()\n    q = test_temporal_convergence()\n    edge_result = test_edge_case()\n\n    results = [p, q, edge_result]\n    \n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}