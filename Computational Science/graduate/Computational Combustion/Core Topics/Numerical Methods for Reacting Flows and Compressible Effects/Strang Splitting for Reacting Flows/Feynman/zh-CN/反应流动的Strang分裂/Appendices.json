{
    "hands_on_practices": [
        {
            "introduction": "Strang 分裂法通过将一个复杂的演化方程分解为一系列更简单的子问题来简化求解过程。在反应流模拟中，化学反应步骤通常是“刚性”的，这意味着需要使用隐式时间积分方法来保证数值稳定性。本练习将引导你专注于 Strang 分裂中的一个反应半步，通过使用向后欧拉法和单步牛顿-拉夫逊校正，来求解一个与温度耦合的非线性化学反应方程，从而掌握处理刚性化学动力学求解器的核心技术细节 。",
            "id": "4068653",
            "problem": "考虑一个通过 Strang 分裂（半个反应步，一个完整的平流-扩散步，半个反应步）推进的均匀反应单元。关注一个持续时间为 $\\Delta t_{r} = \\Delta t/2$ 的反应半步，该反应是单一的不可逆燃料到产物的反应，发生在氧气大大过量的混合物中，因此反应速率对燃料质量分数呈伪一级。燃料质量分数用 $Y_{F}$ 表示，混合物温度用 $T$ 表示。单位时间的反应速率由 Arrhenius 定律建模\n$$\n\\omega(Y_{F},T) = A \\,\\exp\\!\\left(-\\frac{E_{a}}{R_{u}\\,T}\\right)\\,Y_{F},\n$$\n其中 $A$ 是指前因子，$E_{a}$ 是活化能，$R_{u}$ 是通用气体常数。在恒压、恒定密度和恒定比热容的假设下，并忽略反应子步期间的输运，燃料和温度遵循耦合的常微分方程（Ordinary Differential Equation (ODE)）\n$$\n\\frac{dY_{F}}{dt} = -\\omega(Y_{F},T), \\qquad \\frac{dT}{dt} = \\frac{q}{c_{p}}\\,\\omega(Y_{F},T),\n$$\n其中 $q$ 是单位质量燃料消耗的放热量，$c_{p}$ 是混合物在恒压下的比热容。该半步使用后向欧拉法进行隐式离散化：\n$$\nY_{F}^{*} = Y_{F}^{n} - \\Delta t_{r}\\,\\omega\\!\\left(Y_{F}^{*},T^{*}\\right), \\qquad\nT^{*} = T^{n} + \\Delta t_{r}\\,\\frac{q}{c_{p}}\\,\\omega\\!\\left(Y_{F}^{*},T^{*}\\right),\n$$\n其中上标 $n$ 表示半步开始时的状态，上标 $*$ 表示半步结束时更新的状态。您的任务是执行一次 Newton-Raphson (NR) 校正，从初始猜测 $Y_{F}^{(0)} = Y_{F}^{n}$ 开始来近似 $Y_{F}^{*}$，方法是推导 $Y_{F}^{*}$ 的标量非线性残差、其关于 $Y_{F}^{*}$ 的导数，并应用一次 Newton 校正 $Y_{F}^{(1)} = Y_{F}^{(0)} - F\\!\\left(Y_{F}^{(0)}\\right)/F'\\!\\left(Y_{F}^{(0)}\\right)$。\n\n使用以下物理上一致的参数：\n- $Y_{F}^{n} = 0.06$,\n- $T^{n} = 1200\\,\\mathrm{K}$,\n- $\\Delta t = 2.0\\times 10^{-6}\\,\\mathrm{s}$ 因此 $\\Delta t_{r} = 1.0\\times 10^{-6}\\,\\mathrm{s}$,\n- $A = 5.0\\times 10^{7}\\,\\mathrm{s}^{-1}$,\n- $E_{a} = 1.25\\times 10^{5}\\,\\mathrm{J/mol}$,\n- $R_{u} = 8.314\\,\\mathrm{J/(mol\\cdot K)}$,\n- $q = 5.0\\times 10^{7}\\,\\mathrm{J/kg}$,\n- $c_{p} = 1200\\,\\mathrm{J/(kg\\cdot K)}$.\n\n将您的最终答案表示为半步结束时经 Newton 校正的燃料质量分数 $Y_{F}^{(1)}$ 的单一值。将您的答案四舍五入到八位有效数字。将您的答案表示为无量纲的质量分数。",
            "solution": "反应子步期间的控制常微分方程（ODE）为\n$$\n\\frac{dY_{F}}{dt} = -A \\exp\\!\\left(-\\frac{E_{a}}{R_{u}\\,T}\\right) Y_{F}, \n\\qquad \n\\frac{dT}{dt} = \\frac{q}{c_{p}}\\,A \\exp\\!\\left(-\\frac{E_{a}}{R_{u}\\,T}\\right) Y_{F}.\n$$\n在半步长 $\\Delta t_{r}$ 上使用后向欧拉法得到隐式系统\n$$\nY_{F}^{*} = Y_{F}^{n} - \\Delta t_{r}\\,A \\exp\\!\\left(-\\frac{E_{a}}{R_{u}\\,T^{*}}\\right) Y_{F}^{*},\n\\qquad\nT^{*} = T^{n} + \\Delta t_{r}\\,\\frac{q}{c_{p}}\\,A \\exp\\!\\left(-\\frac{E_{a}}{R_{u}\\,T^{*}}\\right) Y_{F}^{*}.\n$$\n使用燃料方程消去 $T^{*}$。从燃料更新方程可知，\n$$\n\\Delta t_{r}\\,A \\exp\\!\\left(-\\frac{E_{a}}{R_{u}\\,T^{*}}\\right) Y_{F}^{*} = Y_{F}^{n} - Y_{F}^{*}.\n$$\n因此温度更新可以重写为\n$$\nT^{*} = T^{n} + \\frac{q}{c_{p}}\\left(Y_{F}^{n} - Y_{F}^{*}\\right).\n$$\n定义常数\n$$\n\\alpha \\equiv \\frac{q}{c_{p}}.\n$$\n则 $T^{*} = T^{n} + \\alpha\\left(Y_{F}^{n} - Y_{F}^{*}\\right)$，并且单一未知数 $Y_{F}^{*}$ 必须满足标量非线性方程\n$$\nF\\!\\left(Y\\right) \\equiv Y - Y_{F}^{n} + \\Delta t_{r}\\,A \\exp\\!\\left(-\\frac{E_{a}}{R_{u}\\,\\left[T^{n} + \\alpha\\left(Y_{F}^{n} - Y\\right)\\right]}\\right) Y = 0.\n$$\nNewton-Raphson (NR) 校正需要导数 $F'(Y)$。使用乘法法则和链式法则进行微分。定义\n$$\nT(Y) \\equiv T^{n} + \\alpha\\left(Y_{F}^{n} - Y\\right), \n\\qquad\n\\phi(Y) \\equiv \\frac{E_{a}}{R_{u}\\,T(Y)}.\n$$\n则\n$$\n\\frac{d\\phi}{dY} = \\frac{E_{a}}{R_{u}}\\frac{d}{dY}\\left(\\frac{1}{T(Y)}\\right) \n= \\frac{E_{a}}{R_{u}}\\left(-\\frac{1}{T(Y)^{2}}\\right)\\frac{dT}{dY}\n= \\frac{E_{a}}{R_{u}}\\left(-\\frac{1}{T(Y)^{2}}\\right)\\left(-\\alpha\\right)\n= \\frac{E_{a}\\,\\alpha}{R_{u}\\,T(Y)^{2}}.\n$$\n设\n$$\ng(Y) \\equiv A \\exp\\!\\left(-\\phi(Y)\\right) Y.\n$$\n则\n$$\ng'(Y) = A \\exp\\!\\left(-\\phi(Y)\\right)\\left[1 + Y\\left(-\\frac{d\\phi}{dY}\\right)\\right]\n= A \\exp\\!\\left(-\\phi(Y)\\right)\\left[1 - Y\\,\\frac{E_{a}\\,\\alpha}{R_{u}\\,T(Y)^{2}}\\right].\n$$\n因此\n$$\nF'(Y) = 1 + \\Delta t_{r}\\,g'(Y) \n= 1 + \\Delta t_{r}\\,A \\exp\\!\\left(-\\phi(Y)\\right)\\left[1 - Y\\,\\frac{E_{a}\\,\\alpha}{R_{u}\\,T(Y)^{2}}\\right].\n$$\n从 $Y^{(0)} = Y_{F}^{n}$ 开始的一次 Newton 校正是\n$$\nY^{(1)} = Y^{(0)} - \\frac{F\\!\\left(Y^{(0)}\\right)}{F'\\!\\left(Y^{(0)}\\right)}.\n$$\n在 $Y^{(0)} = Y_{F}^{n}$ 处计算 $F$ 和 $F'$。当 $Y = Y_{F}^{n}$ 时，有 $T(Y) = T^{n}$，所以\n$$\n\\phi\\!\\left(Y_{F}^{n}\\right) = \\frac{E_{a}}{R_{u}\\,T^{n}}, \n\\qquad\n\\exp\\!\\left(-\\phi\\!\\left(Y_{F}^{n}\\right)\\right) = \\exp\\!\\left(-\\frac{E_{a}}{R_{u}\\,T^{n}}\\right).\n$$\n则\n$$\nF\\!\\left(Y_{F}^{n}\\right) \n= Y_{F}^{n} - Y_{F}^{n} + \\Delta t_{r}\\,A \\exp\\!\\left(-\\frac{E_{a}}{R_{u}\\,T^{n}}\\right) Y_{F}^{n}\n= \\Delta t_{r}\\,A \\exp\\!\\left(-\\frac{E_{a}}{R_{u}\\,T^{n}}\\right) Y_{F}^{n},\n$$\n以及\n$$\nF'\\!\\left(Y_{F}^{n}\\right)\n= 1 + \\Delta t_{r}\\,A \\exp\\!\\left(-\\frac{E_{a}}{R_{u}\\,T^{n}}\\right)\\left[1 - Y_{F}^{n}\\,\\frac{E_{a}\\,\\alpha}{R_{u}\\,\\left(T^{n}\\right)^{2}}\\right].\n$$\n代入给定的参数值。首先计算温度耦合常数\n$$\n\\alpha = \\frac{q}{c_{p}} = \\frac{5.0\\times 10^{7}}{1200} \\approx 41666.6667.\n$$\n计算初始温度下的 Arrhenius 指数\n$$\n\\frac{E_{a}}{R_{u}\\,T^{n}} = \\frac{1.25\\times 10^{5}}{8.314 \\times 1200} = \\frac{1.25\\times 10^{5}}{9976.8} \\approx 12.5290674,\n$$\n所以\n$$\n\\exp\\!\\left(-\\frac{E_{a}}{R_{u}\\,T^{n}}\\right) \\approx \\exp(-12.5290674) \\approx 3.615757\\times 10^{-6}.\n$$\n因此\n$$\nA \\exp\\!\\left(-\\frac{E_{a}}{R_{u}\\,T^{n}}\\right) \\approx 5.0\\times 10^{7}\\times 3.615757\\times 10^{-6} \\approx 180.78785.\n$$\n则\n$$\nF\\!\\left(Y_{F}^{n}\\right) \\approx \\Delta t_{r}\\left[A \\exp\\!\\left(-\\frac{E_{a}}{R_{u}\\,T^{n}}\\right)\\right] Y_{F}^{n}\n= \\left(1.0\\times 10^{-6}\\right)\\left(180.78785\\right)\\left(0.06\\right)\n\\approx 1.0847271\\times 10^{-5}.\n$$\n对于导数，计算括号内的温度耦合因子\n$$\n\\frac{E_{a}\\,\\alpha}{R_{u}\\,\\left(T^{n}\\right)^{2}} \n= \\frac{\\left(1.25\\times 10^{5}\\right)\\left(41666.6667\\right)}{8.314 \\times \\left(1200\\right)^{2}}\n\\approx 435.03705,\n$$\n所以\n$$\n\\left[1 - Y_{F}^{n}\\,\\frac{E_{a}\\,\\alpha}{R_{u}\\,\\left(T^{n}\\right)^{2}}\\right] \n\\approx 1 - \\left(0.06\\right)\\left(435.03705\\right) \\approx 1 - 26.102223 \\approx -25.102223.\n$$\n因此\n$$\nF'\\!\\left(Y_{F}^{n}\\right) \n\\approx 1 + \\Delta t_{r}\\left[A \\exp\\!\\left(-\\frac{E_{a}}{R_{u}\\,T^{n}}\\right)\\right]\\left(-25.102223\\right)\n= 1 + \\left(1.0\\times 10^{-6}\\right)\\left(180.78785\\right)\\left(-25.102223\\right)\n\\approx 0.995461823.\n$$\n应用一次 Newton 校正：\n$$\nY_{F}^{(1)} = Y_{F}^{n} - \\frac{F\\!\\left(Y_{F}^{n}\\right)}{F'\\!\\left(Y_{F}^{n}\\right)}\n\\approx 0.06 - \\frac{1.0847271\\times 10^{-5}}{0.995461823}\n\\approx 0.06 - 1.0896827\\times 10^{-5}\n\\approx 0.059989103.\n$$\n四舍五入到八位有效数字，半步结束时经 Newton 校正的燃料质量分数为 $0.059989103$，表示为无量纲的质量分数。",
            "answer": "$$\\boxed{0.059989103}$$"
        },
        {
            "introduction": "在理解了如何求解各个子步骤后，一个自然而然的问题是：我们为什么通常选择结构更对称、实现略复杂的 Strang 分裂，而不是更直接的 Lie-Trotter 分裂？本练习通过一个一维平流-反应系统的数值实验来回答这一问题。你将亲手实现这两种分裂方法，并通过计算全局误差随时间步长 $\\Delta t$ 的变化，来定量地验证 Strang 分裂相较于 Lie-Trotter 分裂的二阶精度优势 。",
            "id": "4068626",
            "problem": "考虑一个一维、周期性、无量纲的反应流，其中包含两种组分的质量分数，记为 $Y(x,t)$ 和 $Z(x,t)$，在长度为 $L$、坐标为 $x \\in [0,L)$ 的域上演化。该流动由恒速平流和具有双线性质量作用动力学的局部反应所控制。其控制方程为\n$$\n\\frac{\\partial Y}{\\partial t} + c_Y \\frac{\\partial Y}{\\partial x} = -k\\, Y Z,\\qquad\n\\frac{\\partial Z}{\\partial t} + c_Z \\frac{\\partial Z}{\\partial x} = +k\\, Y Z,\n$$\n其中 $c_Y$ 和 $c_Z$ 是恒定的平流速度，$k$ 是恒定的反应速率。所有物理量均为无量纲。初始条件是光滑的正函数：\n$$\nY(x,0) = 0.7 + 0.2 \\sin(x) + 0.1 \\cos(2x), \\qquad\nZ(x,0) = 0.3 + 0.2 \\cos(x).\n$$\n在长度为 $L = 2\\pi$ 的周期区间上进行计算，使用包含 $N = 1024$ 个点的均匀网格。设最终时间为 $T = 0.2$。定义作用于对 $(Y,Z)$ 的线性平流算子 $\\mathcal{A}$，其作用是沿特征线移动每个分量；定义反应算子 $\\mathcal{R}$，其作用是求解由反应项引起的每个网格点上的局部时间演化。对两个算子都使用精确演化映射：对于平流，通过谱相位相乘实现精确的周期性位移；对于反应，利用反应过程中 $S=Y+Z$ 的不变性，使用通过分离变量法得到的局部常微分方程的精确解。\n\n构建两种算子分裂积分器来近似计算时刻 $T$ 的解：\n- Lie–Trotter 分裂：在每个时间步中，先施加一个大小为 $\\Delta t$ 的完整平流步，然后施加一个大小为 $\\Delta t$ 的完整反应步来进行演化。\n- Strang 分裂：在每个时间步中，先施加一个大小为 $\\Delta t/2$ 的半个平流步，然后是一个大小为 $\\Delta t$ 的完整反应步，最后再施加一个大小为 $\\Delta t/2$ 的半个平流步来进行演化。\n\n对于每个近似解，使用网格上的离散 $L^2$ 范数，测量其在时刻 $T$ 相对于一个参考解的全局误差。该参考解是通过 Strang 分裂方法使用一个足够小的时间步长 $\\Delta t_{\\mathrm{ref}}$（远小于测试的 $\\Delta t$ 值）构建的：\n$$\nE(\\Delta t) = \\left( \\frac{1}{N} \\sum_{j=0}^{N-1} \\left[ \\left( Y_j(T;\\Delta t) - Y_j^{\\mathrm{ref}}(T) \\right)^2 + \\left( Z_j(T;\\Delta t) - Z_j^{\\mathrm{ref}}(T) \\right)^2 \\right] \\right)^{1/2},\n$$\n其中 $Y_j(T;\\Delta t)$ 和 $Z_j(T;\\Delta t)$ 表示在时间步长为 $\\Delta t$ 时，在时刻 $T$、网格点 $j$ 处的数值解；而 $Y_j^{\\mathrm{ref}}(T)$ 和 $Z_j^{\\mathrm{ref}}(T)$ 表示参考解。\n\n通过对一组时间步长的 $\\log E(\\Delta t)$ 与 $\\log \\Delta t$ 进行最小二乘拟合，来估计每种方法的观测精度阶 $p$，即找到 $p$ 使得对于某个常数 $\\alpha$ 满足\n$$\n\\log E(\\Delta t) \\approx \\alpha + p \\, \\log \\Delta t\n$$\n报告每种方法和每个测试用例下获得的 $p$ 值。\n\n使用以下参数集测试套件，每个测试用例的最终时间均为 $T = 0.2$，测试所用的时间步长集合为 $\\Delta t \\in \\{0.02, 0.01, 0.005, 0.0025\\}$：\n- 用例 1：$c_Y = 1.0$, $c_Z = -0.5$, $k = 5.0$。\n- 用例 2：$c_Y = 1.5$, $c_Z = 0.3$, $k = 2.0$。\n- 用例 3：$c_Y = 0.7$, $c_Z = 1.2$, $k = 3.0$。\n\n所有量均为无量纲；无需物理单位。您的程序必须：\n- 精确实现谱平流位移。\n- 使用 $S=Y+Z$ 不变量的闭式解，精确实现局部反应映射。\n- 使用 Strang 分裂和 $\\Delta t_{\\mathrm{ref}} = 0.0003125$ 构建一个高保真参考解。\n- 对于每个用例，计算 Lie–Trotter 和 Strang 分裂在指定 $\\Delta t$ 值下的全局误差，估计每种方法的观测阶数 $p$，并生成最终输出。输出为单行文本，包含按以下顺序排列的六个估计阶数：Lie–Trotter 用例 1，Strang 用例 1，Lie–Trotter 用例 2，Strang 用例 2，Lie–Trotter 用例 3，Strang 用例 3。\n\n最终输出格式：单行文本，内容为方括号括起来的逗号分隔列表，例如\n$$\n[\\text{p\\_LT\\_1},\\text{p\\_Strang\\_1},\\text{p\\_LT\\_2},\\text{p\\_Strang\\_2},\\text{p\\_LT\\_3},\\text{p\\_Strang\\_3}]\n$$\n其中每一项都是一个浮点数。",
            "solution": "用户提供的问题是计算科学领域的一个适定的标准练习，具体涉及反应流的偏微分方程（PDE）数值解。该问题具有科学依据，内容无矛盾，并包含了求解所需的所有必要信息。\n\n该问题的核心是在周期域 $x \\in [0, 2\\pi)$ 上对两个组分 $Y(x,t)$ 和 $Z(x,t)$ 的一维平流-反应方程组进行数值积分。控制方程为：\n$$\n\\frac{\\partial Y}{\\partial t} + c_Y \\frac{\\partial Y}{\\partial x} = -k\\, Y Z\n$$\n$$\n\\frac{\\partial Z}{\\partial t} + c_Z \\frac{\\partial Z}{\\partial x} = +k\\, Y Z\n$$\n其中 $c_Y$ 和 $c_Z$ 是恒定的平流速度，$k$ 是恒定的反应速率。初始条件是光滑的正函数：\n$$\nY(x,0) = 0.7 + 0.2 \\sin(x) + 0.1 \\cos(2x)\n$$\n$$\nZ(x,0) = 0.3 + 0.2 \\cos(x)\n$$\n求解域在 $N=1024$ 个点的均匀网格上进行离散化。问题的核心是使用算子分裂法求解该系统，该方法将完整的偏微分方程解耦为更简单的子问题。将解 $(Y,Z)$ 推进一个时间步长 $\\Delta t$ 的完整演化算子 $\\mathcal{S}_{\\Delta t}$，可由纯平流算子 ($\\mathcal{A}$) 和纯反应算子 ($\\mathcal{R}$) 的复合来近似。\n\n演化方程可以写成抽象形式 $\\frac{d\\mathbf{u}}{dt} = (\\mathcal{A} + \\mathcal{R})\\mathbf{u}$，其中 $\\mathbf{u} = (Y,Z)^T$。算子 $\\mathcal{A}$ 和 $\\mathcal{R}$ 分别对应于偏微分方程的平流部分和反应部分。\n\n### 平流算子 $\\mathcal{A}_{\\Delta t}$\n该系统的平流部分是一对线性双曲方程：\n$$\n\\frac{\\partial Y}{\\partial t} + c_Y \\frac{\\partial Y}{\\partial x} = 0\n$$\n$$\n\\frac{\\partial Z}{\\partial t} + c_Z \\frac{\\partial Z}{\\partial x} = 0\n$$\n对于周期性域，在傅里叶空间中求解这些方程最为高效和精确。对 $Y$ 的方程（对 $Z$ 也类似）进行傅里叶变换，可以得到每个傅里叶模态 $\\hat{Y}(k_m, t)$ 的一个常微分方程（ODE）：\n$$\n\\frac{d \\hat{Y}(k_m, t)}{dt} + c_Y (i k_m) \\hat{Y}(k_m, t) = 0\n$$\n其中 $k_m$ 是离散波数。对于长度为 $L=2\\pi$、包含 $N$ 个点的域，波数为整数 $m = [-N/2, \\dots, N/2 - 1]$。在一个时间步长 $\\Delta t$ 内的精确解是傅里叶空间中的一个简单相移：\n$$\n\\hat{Y}(k_m, t_0+\\Delta t) = \\hat{Y}(k_m, t_0) e^{-i k_m c_Y \\Delta t}\n$$\n平流算子 $\\mathcal{A}_{\\Delta t}$ 的计算实现步骤如下：\n1.对组分场（例如 $Y(x)$）进行快速傅里叶正变换（FFT）。\n2.将得到的傅里叶系数乘以复相因子 $e^{-i k_m c \\Delta t}$。\n3.进行快速傅里叶逆变换，将场转换回物理空间。\n此过程分别对 $Y$ 和 $Z$ 以及它们各自的速度 $c_Y$ 和 $c_Z$ 独立应用。\n\n### 反应算子 $\\mathcal{R}_{\\Delta t}$\n反应部分是在每个网格点上独立求解的非线性耦合常微分方程组：\n$$\n\\frac{dY}{dt} = -k Y Z\n$$\n$$\n\\frac{dZ}{dt} = +k Y Z\n$$\n将两个方程相加，揭示了反应过程中的一个守恒量：\n$$\n\\frac{d(Y+Z)}{dt} = 0 \\implies S = Y+Z = \\text{constant}\n$$\n这个不变量 $S$ 使得系统可以解耦。将 $Z = S-Y$ 代入第一个常微分方程，得到一个关于 $Y$ 的 logistic 型方程：\n$$\n\\frac{dY}{dt} = -k Y (S-Y)\n$$\n该方程是可分离的，并且可以精确积分。通过分离变量并使用部分分式分解，我们得到：\n$$\n\\int \\frac{dY}{Y(S-Y)} = \\int -k dt \\implies \\frac{1}{S} \\int \\left(\\frac{1}{Y} + \\frac{1}{S-Y}\\right) dY = -k \\int dt\n$$\n从 $t=0$ 时的初始状态 $(Y_0, Z_0)$ 积分到时刻 $t$ 的状态 $(Y(t), Z(t))$，并求解 $Y(t)$，即可得到闭式解。一种数值稳定的形式是：\n$$\nY(t) = \\frac{S Y_0}{Z_0 e^{Skt} + Y_0}\n$$\n其中 $S = Y_0+Z_0$。然后可以根据不变量求得 $Z$ 的新值：$Z(t) = S - Y(t)$。反应算子 $\\mathcal{R}_{\\Delta t}$ 在每个时间步长 $\\Delta t$ 内，将此精确解映射应用于每个网格点。\n\n### 算子分裂积分器\n构建了两种分裂方法：\n1. **Lie–Trotter 分裂**：这是一种一阶精度的方法。从 $t$ 到 $t+\\Delta t$ 的一个演化步，通过先施加一个完整的平流步，再施加一个完整的反应步来近似：\n$$\n\\mathbf{u}(t+\\Delta t) \\approx \\mathcal{S}_{\\Delta t}^{\\text{LT}}(\\mathbf{u}(t)) = \\mathcal{R}_{\\Delta t} \\circ \\mathcal{A}_{\\Delta t} (\\mathbf{u}(t))\n$$\n2. **Strang 分裂**：这是一种使用对称复合的二阶精度方法。一个演化步通过施加半个平流步、一个完整反应步、再施加另一个半个平流步来近似：\n$$\n\\mathbf{u}(t+\\Delta t) \\approx \\mathcal{S}_{\\Delta t}^{\\text{S}}(\\mathbf{u}(t)) = \\mathcal{A}_{\\Delta t/2} \\circ \\mathcal{R}_{\\Delta t} \\circ \\mathcal{A}_{\\Delta t/2} (\\mathbf{u}(t))\n$$\n\n### 收敛性分析\n为了确定观测精度阶 $p$，我们对一组递减的时间步长 $\\Delta t$ 运行模拟。在最终时刻 $T$ 的全局误差是相对于一个高保真参考解来计算的。该参考解使用 Strang 分裂法和一个非常小的时间步长 $\\Delta t_{\\text{ref}} = 0.0003125$ 生成。误差通过离散 $L^2$ 范数来度量：\n$$\nE(\\Delta t) = \\left( \\frac{1}{N} \\sum_{j=0}^{N-1} \\left[ \\left( Y_j(T;\\Delta t) - Y_j^{\\mathrm{ref}}(T) \\right)^2 + \\left( Z_j(T;\\Delta t) - Z_j^{\\mathrm{ref}}(T) \\right)^2 \\right] \\right)^{1/2}\n$$\n对于一个 $p$ 阶方法，误差的缩放关系为 $E(\\Delta t) \\propto (\\Delta t)^p$。取对数后得到一个线性关系：$\\log E(\\Delta t) \\approx \\alpha + p \\log \\Delta t$。阶数 $p$ 被估计为对数据点 $(\\log \\Delta t, \\log E(\\Delta t))$ 进行线性最小二乘拟合得到的斜率。这个过程对三个测试用例中的 Lie-Trotter 分裂和 Strang 分裂都进行了操作。理论上，Lie-Trotter 分裂的预期阶数为 $p=1$，Strang 分裂的预期阶数为 $p=2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef advect(Y, Z, dt, c_Y, c_Z, kx):\n    \"\"\"\n    Evolves Y and Z by a time step dt using the spectral advection operator.\n    \"\"\"\n    Y_hat = np.fft.fft(Y)\n    Z_hat = np.fft.fft(Z)\n    \n    Y_hat_new = Y_hat * np.exp(-1j * kx * c_Y * dt)\n    Z_hat_new = Z_hat * np.exp(-1j * kx * c_Z * dt)\n    \n    # an ifft followed by .real removes numerical noise in the imaginary part\n    Y_new = np.fft.ifft(Y_hat_new).real\n    Z_new = np.fft.ifft(Z_hat_new).real\n    \n    return Y_new, Z_new\n\ndef react(Y, Z, dt, k):\n    \"\"\"\n    Evolves Y and Z by a time step dt using the exact reaction operator.\n    \"\"\"\n    S = Y + Z\n    Y_new = np.copy(Y)\n    Z_new = np.copy(Z)\n    \n    # Only compute reaction where S > 0 to avoid division by zero or log(0) issues,\n    # and handle Y=Z=0 case where no reaction occurs.\n    # A small tolerance is used for floating-point comparisons.\n    mask = S > 1e-15\n    \n    Y_masked = Y[mask]\n    Z_masked = Z[mask]\n    S_masked = S[mask]\n    \n    # Use the numerically stable form of the exact solution to avoid large exponentials\n    # Y(t) = S*Y0 / (Z0*exp(S*k*t) + Y0)\n    exp_term_pos = np.exp(S_masked * k * dt)\n    denom = Z_masked * exp_term_pos + Y_masked\n    \n    # Avoid division by zero in the unlikely case denom is zero\n    # (only if Y_masked=0 and Z_masked=0, which is outside the mask)\n    Y_new[mask] = np.divide(S_masked * Y_masked, denom, out=np.zeros_like(Y_masked), where=denom!=0)\n\n    # Z is updated from the invariant S\n    Z_new = S - Y_new\n    \n    return Y_new, Z_new\n\ndef solve_lt(Y0, Z0, T, dt, c_Y, c_Z, k, kx):\n    \"\"\"Integrator using Lie-Trotter splitting.\"\"\"\n    Y, Z = np.copy(Y0), np.copy(Z0)\n    num_steps = int(round(T / dt))\n    \n    for _ in range(num_steps):\n        Y, Z = advect(Y, Z, dt, c_Y, c_Z, kx)\n        Y, Z = react(Y, Z, dt, k)\n        \n    return Y, Z\n\ndef solve_strang(Y0, Z0, T, dt, c_Y, c_Z, k, kx):\n    \"\"\"Integrator using Strang splitting.\"\"\"\n    Y, Z = np.copy(Y0), np.copy(Z0)\n    num_steps = int(round(T / dt))\n    \n    for _ in range(num_steps):\n        Y, Z = advect(Y, Z, dt / 2.0, c_Y, c_Z, kx)\n        Y, Z = react(Y, Z, dt, k)\n        Y, Z = advect(Y, Z, dt / 2.0, c_Y, c_Z, kx)\n        \n    return Y, Z\n\ndef solve():\n    # Define problem setup\n    N = 1024\n    L = 2.0 * np.pi\n    T = 0.2\n    x = np.linspace(0, L, N, endpoint=False)\n    \n    # The integer wavenumbers for L=2*pi\n    kx = np.fft.fftfreq(N) * N\n    \n    # Initial Conditions\n    Y0 = 0.7 + 0.2 * np.sin(x) + 0.1 * np.cos(2*x)\n    Z0 = 0.3 + 0.2 * np.cos(x)\n    \n    # Test cases and time steps for convergence analysis\n    test_cases = [\n        (1.0, -0.5, 5.0), # Case 1\n        (1.5, 0.3, 2.0),  # Case 2\n        (0.7, 1.2, 3.0),  # Case 3\n    ]\n    \n    dts = np.array([0.02, 0.01, 0.005, 0.0025])\n    dt_ref = 0.0003125\n    \n    all_orders = []\n    \n    for c_Y, c_Z, k in test_cases:\n        # Compute high-fidelity reference solution\n        Y_ref, Z_ref = solve_strang(Y0, Z0, T, dt_ref, c_Y, c_Z, k, kx)\n        \n        errors_lt = []\n        errors_strang = []\n        \n        for dt in dts:\n            # Solve with Lie-Trotter and compute error\n            Y_lt, Z_lt = solve_lt(Y0, Z0, T, dt, c_Y, c_Z, k, kx)\n            error_lt = np.sqrt(np.mean((Y_lt - Y_ref)**2 + (Z_lt - Z_ref)**2))\n            errors_lt.append(error_lt)\n            \n            # Solve with Strang and compute error\n            Y_s, Z_s = solve_strang(Y0, Z0, T, dt, c_Y, c_Z, k, kx)\n            error_s = np.sqrt(np.mean((Y_s - Y_ref)**2 + (Z_s - Z_ref)**2))\n            errors_strang.append(error_s)\n\n        # Estimate order of accuracy using a log-log linear fit\n        # The model is log(E) = alpha + p * log(dt)\n        # np.polyfit(x, y, 1) returns [p, alpha] for y = p*x + alpha\n        log_dts = np.log(dts)\n        \n        # Lie-Trotter order\n        log_errors_lt = np.log(np.array(errors_lt))\n        p_lt, _ = np.polyfit(log_dts, log_errors_lt, 1)\n        all_orders.append(p_lt)\n        \n        # Strang order\n        log_errors_strang = np.log(np.array(errors_strang))\n        p_strang, _ = np.polyfit(log_dts, log_errors_strang, 1)\n        all_orders.append(p_strang)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{p:.10f}' for p in all_orders)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在许多实际的燃烧问题中，化学反应的时间尺度在空间和时间上可能存在巨大差异，使用固定的全局时间步长 $\\Delta t$ 会非常低效。本练习将介绍一种用于自适应时间步长控制的强大技术：嵌入式误差估计。你将学习如何通过在每个时间步中同时计算高阶的 Strang 分裂解和低阶的 Lie-Trotter 分裂解，并利用两者之差来廉价地估计局部截断误差，这是开发高效、稳健的自适应反应流求解器的关键一步 。",
            "id": "4068668",
            "problem": "考虑在一个周期性域 $x \\in [0, L]$ 上的一维反应扩散物质场 $Y(x,t)$，它由以下偏微分方程（PDE）控制：\n$$\n\\frac{\\partial Y}{\\partial t} = D \\frac{\\partial^2 Y}{\\partial x^2} - k(x) Y,\n$$\n其中，$D$ 是扩散系数，单位为 $\\mathrm{m}^2/\\mathrm{s}$；$k(x)$ 是空间变化的一阶反应速率，单位为 $\\mathrm{s}^{-1}$；$Y$ 是无量纲质量分数。定义作用于 $Y$ 的算子 $A$ 和 $B$ 如下：\n$$\nA(Y) = D \\frac{\\partial^2 Y}{\\partial x^2}, \\quad B(Y) = -k(x) Y.\n$$\n时长为 $\\Delta t$ 的 Strang 分裂步是以下复合算子：\n$$\nS_{\\Delta t} = \\exp\\left(\\frac{\\Delta t}{2} B\\right) \\exp\\left(\\Delta t A\\right) \\exp\\left(\\frac{\\Delta t}{2} B\\right),\n$$\n而 Lie-Trotter（一阶）分裂步为：\n$$\nL_{\\Delta t} = \\exp\\left(\\Delta t A\\right) \\exp\\left(\\Delta t B\\right).\n$$\n\n你将在一个具有 $N$ 个点、网格间距为 $h = L/N$ 的均匀网格上构建一个离散近似，并采用周期性边界条件。令 $Y_j(t)$ 近似 $x_j = j h$ 处的 $Y(x_j,t)$，其中 $j=0,1,\\dots,N-1$。带有周期性边界条件的二阶导数通过中心二阶有限差分进行离散化，得到一个离散扩散算子矩阵 $A_h \\in \\mathbb{R}^{N \\times N}$，定义为：\n$$\n\\left(A_h \\mathbf{y}\\right)_j = \\frac{D}{h^2}\\left(\\mathbf{y}_{j+1} - 2 \\mathbf{y}_j + \\mathbf{y}_{j-1}\\right),\n$$\n其中索引是周期性的，即 $\\mathbf{y}_{-1} = \\mathbf{y}_{N-1}$ 且 $\\mathbf{y}_N = \\mathbf{y}_0$。离散反应算子为 $B_h = -\\operatorname{diag}(k(x_0), \\dots, k(x_{N-1}))$，因此 $\\left(B_h \\mathbf{y}\\right)_j = -k(x_j) \\mathbf{y}_j$。\n\n在你的程序中，请使用以下规定：\n- 精确的离散扩散子步是将 $\\exp(\\Delta t A_h)$ 作用于向量 $\\mathbf{y}$。\n- 精确的离散反应子步是将对角指数矩阵 $\\exp(\\Delta t B_h)$ 作用于向量 $\\mathbf{y}$，等价于 $\\left(\\exp(\\Delta t B_h) \\mathbf{y}\\right)_j = \\exp\\left(-k(x_j) \\Delta t\\right) \\mathbf{y}_j$。\n- 完整线性系统的精确未分裂参考步是将 $\\exp\\left(\\Delta t (A_h + B_h)\\right)$ 作用于向量 $\\mathbf{y}$。\n\n定义初始条件：\n$$\nY(x,0) = 0.25 + 0.75 \\sin\\left(2\\pi \\frac{x}{L}\\right).\n$$\n所有长度单位必须是米，所有时间单位必须是秒，质量分数是无量纲的。使用由网格间距加权的离散 $\\ell^2$ 范数\n$$\n\\|\\mathbf{y}\\|_{h} = \\sqrt{h \\sum_{j=0}^{N-1} \\mathbf{y}_j^2},\n$$\n来量化误差。\n\n通过对每个测试用例和时间步长 $\\Delta t$，从相同的初始向量 $\\mathbf{y}^0$ 计算 Strang 步 $\\mathbf{y}^{\\text{S}} = S_{\\Delta t} \\mathbf{y}^0$ 和 Lie-Trotter 步 $\\mathbf{y}^{\\text{LT}} = L_{\\Delta t} \\mathbf{y}^0$ 来实现一个嵌入式低阶估计，并定义嵌入式指标：\n$$\nE_{\\text{embed}} = \\left\\| \\mathbf{y}^{\\text{LT}} - \\mathbf{y}^{\\text{S}} \\right\\|_{h}.\n$$\n同样，计算 Strang 步相对于同一 $\\Delta t$ 内精确未分裂演化的真实局部误差：\n$$\nE_{\\text{true}} = \\left\\| \\exp\\left(\\Delta t (A_h + B_h)\\right) \\mathbf{y}^0 - \\mathbf{y}^{\\text{S}} \\right\\|_{h}.\n$$\n\n你的程序必须实现上述定义，并为以下参数集测试套件生成 $E_{\\text{true}}$ 和 $E_{\\text{embed}}$ 的数值。在所有情况下，设置 $L = 1$ 米，并使用指定的 $N$。\n\n测试套件：\n1. 对易基准（反应在空间上均匀）：$D = 0.01$ $\\mathrm{m}^2/\\mathrm{s}$，$k(x) \\equiv 5$ $\\mathrm{s}^{-1}$，$\\Delta t = 0.05$ $\\mathrm{s}$，$N=16$。\n2. 中等变化的反应速率（理想情况）：$D = 0.01$ $\\mathrm{m}^2/\\mathrm{s}$，$k(x) = 5\\left(1 + 0.5 \\sin\\left(2\\pi \\frac{x}{L}\\right)\\right)$ $\\mathrm{s}^{-1}$，$\\Delta t = 0.01$ $\\mathrm{s}$，$N=32$。\n3. 强耦合与变异性：$D = 0.05$ $\\mathrm{m}^2/\\mathrm{s}$，$k(x) = 15\\left(1 + \\sin\\left(2\\pi \\frac{x}{L}\\right)\\right)$ $\\mathrm{s}^{-1}$，$\\Delta t = 0.02$ $\\mathrm{s}$，$N=32$。\n4. 大时间步长压力测试：$D = 0.05$ $\\mathrm{m}^2/\\mathrm{s}$，$k(x) = 15\\left(1 + \\sin\\left(2\\pi \\frac{x}{L}\\right)\\right)$ $\\mathrm{s}^{-1}$，$\\Delta t = 0.10$ $\\mathrm{s}$，$N=32$。\n\n对每个测试用例，计算并返回两个浮点数：首先是 $E_{\\text{true}}$，其次是 $E_{\\text{embed}}$。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$$\n\\left[E_{\\text{true}}^{(1)}, E_{\\text{embed}}^{(1)}, E_{\\text{true}}^{(2)}, E_{\\text{embed}}^{(2)}, E_{\\text{true}}^{(3)}, E_{\\text{embed}}^{(3)}, E_{\\text{true}}^{(4)}, E_{\\text{embed}}^{(4)}\\right],\n$$\n其中上标索引测试用例 1 到 4。所有报告的值都是无量纲的（质量分数的范数值），并以浮点数形式表示。",
            "solution": "该问题要求实现并比较两种算子分裂方法，即 Lie-Trotter 分裂和 Strang 分裂，用于求解一个一维反应扩散偏微分方程（PDE）。控制物质质量分数 $Y(x,t)$ 的方程由下式给出：\n$$\n\\frac{\\partial Y}{\\partial t} = D \\frac{\\partial^2 Y}{\\partial x^2} - k(x) Y\n$$\n该方程定义在一个周期性域 $x \\in [0, L]$ 上。方程右侧可以分裂为一个扩散算子 $A(Y) = D \\frac{\\partial^2 Y}{\\partial x^2}$ 和一个反应算子 $B(Y) = -k(x) Y$。因此，完整的演化方程可以写为 $\\frac{\\partial Y}{\\partial t} = (A+B)Y$。在一个时间步长 $\\Delta t$ 内的形式解是 $Y(t+\\Delta t) = \\exp(\\Delta t(A+B))Y(t)$。\n\n算子分裂方法通过单个算子指数的乘积来近似这个算子和的指数，这些单个算子的指数通常更容易计算。该问题指定了两种此类方法：\n1. 一阶 Lie-Trotter 分裂：$L_{\\Delta t} = \\exp(\\Delta t A) \\exp(\\Delta t B)$。该方法的局部误差为 $O(\\Delta t^2)$。\n2. 二阶 Strang 分裂：$S_{\\Delta t} = \\exp\\left(\\frac{\\Delta t}{2} B\\right) \\exp\\left(\\Delta t A\\right) \\exp\\left(\\frac{\\Delta t}{2} B\\right)$。该方法的局部误差为 $O(\\Delta t^3)$。\n\n该问题在一个包含 $N$ 个点 $\\{x_j = j h\\}_{j=0}^{N-1}$、网格间距为 $h=L/N$ 的均匀网格上进行离散化。物质场变成一个向量 $\\mathbf{y}(t)$，其中 $\\mathbf{y}_j(t) \\approx Y(x_j, t)$。算子 $A$ 和 $B$ 被它们的离散对应物——矩阵 $A_h$ 和 $B_h$ 所取代。\n反应算子 $B(Y)$ 在空间上是局部的，因此其离散形式 $B_h$ 是一个对角矩阵：\n$$\nB_h = -\\operatorname{diag}(k(x_0), k(x_1), \\dots, k(x_{N-1}))\n$$\n扩散算子 $A(Y)$ 使用带有周期性边界条件的二阶中心有限差分格式进行离散化。这会产生一个循环矩阵 $A_h$：\n$$\n\\left(A_h \\mathbf{y}\\right)_j = \\frac{D}{h^2}\\left(\\mathbf{y}_{j+1} - 2 \\mathbf{y}_j + \\mathbf{y}_{j-1}\\right)\n$$\n其中索引按模 $N$ 计算。\n\n数值实现需要计算这些矩阵的指数作用于向量的结果。\n对于对角反应矩阵 $B_h$，其指数 $\\exp(\\tau B_h)$ 也是对角的，其元素为 $\\exp(-\\tau k(x_j))$。它作用于向量 $\\mathbf{y}$ 是一个简单的逐元素乘法：$(\\exp(\\tau B_h)\\mathbf{y})_j = \\exp(-\\tau k(x_j)) \\mathbf{y}_j$。\n\n对于循环扩散矩阵 $A_h$，可以使用离散傅里叶变换（DFT）或其快速实现——快速傅里叶变换（FFT）来高效地应用矩阵指数。任何循环矩阵都可以被 DFT 矩阵对角化。$A_h$ 对应于傅里叶模式 $e^{i 2 \\pi m x / L}$（其中 $m=0, \\dots, N-1$）的特征值由离散算子的符号给出：\n$$\n\\lambda_m = \\frac{D}{h^2} \\left(e^{i 2\\pi m / N} - 2 + e^{-i 2\\pi m / N}\\right) = \\frac{2D}{h^2} \\left(\\cos\\left(\\frac{2\\pi m}{N}\\right) - 1\\right) = -\\frac{4D}{h^2} \\sin^2\\left(\\frac{\\pi m}{N}\\right)\n$$\n$\\exp(\\tau A_h)$ 作用于向量 $\\mathbf{y}$ 的结果计算为 $\\mathbf{z} = F^{-1} \\operatorname{diag}(\\exp(\\tau \\lambda_m)) F \\mathbf{y}$，其中 $F$ 表示 DFT。这对应于对 $\\mathbf{y}$ 进行 FFT，在傅里叶空间中与特征值的指数进行逐元素乘法，然后再进行逆 FFT。\n\n用作参考的“精确”未分裂演化由 $\\exp(\\Delta t (A_h + B_h))\\mathbf{y}^0$ 给出。矩阵 $C_h = A_h + B_h$ 通常既不是对角矩阵也不是循环矩阵，因此它的指数是使用一个标准的数值库函数 `scipy.linalg.expm` 来计算的，这对于指定的较小矩阵尺寸（$N \\in \\{16, 32\\}$）是合适的。\n\n有了这些组件，我们构建以下解：\n- 初始状态：$\\mathbf{y}^0$，其分量为 $\\mathbf{y}^0_j = 0.25 + 0.75 \\sin(2\\pi x_j/L)$。\n- 参考解：$\\mathbf{y}^{\\text{ref}} = \\exp(\\Delta t (A_h+B_h)) \\mathbf{y}^0$。\n- Lie-Trotter 解：$\\mathbf{y}^{\\text{LT}} = \\exp(\\Delta t A_h) \\exp(\\Delta t B_h) \\mathbf{y}^0$。\n- Strang 解：$\\mathbf{y}^{\\text{S}} = \\exp(\\frac{\\Delta t}{2} B_h) \\exp(\\Delta t A_h) \\exp(\\frac{\\Delta t}{2} B_h) \\mathbf{y}^0$。\n\n误差使用离散加权范数 $\\|\\mathbf{y}\\|_{h} = \\sqrt{h \\sum_{j=0}^{N-1} \\mathbf{y}_j^2}$ 进行量化：\n- Strang 分裂的真实局部误差：$E_{\\text{true}} = \\| \\mathbf{y}^{\\text{ref}} - \\mathbf{y}^{\\text{S}} \\|_{h}$。\n- 嵌入式误差指标：$E_{\\text{embed}} = \\| \\mathbf{y}^{\\text{LT}} - \\mathbf{y}^{\\text{S}} \\|_{h}$。\n\n分裂方法的理论基础依赖于 Baker-Campbell-Hausdorff 公式。误差项涉及算子 $A_h$ 和 $B_h$ 的对易子。\n一个关键的特殊情况是当 $[A_h, B_h] = A_h B_h - B_h A_h = 0$ 时。这种情况当且仅当 $B_h$ 是单位矩阵的标量倍数时发生，这意味着 $k(x)$ 必须在空间上是恒定的。在第一个测试用例中，$k(x) \\equiv 5 \\ \\mathrm{s}^{-1}$，所以 $A_h$ 和 $B_h$ 是对易的。因此，所有的分裂公式都变得精确：$\\exp(\\Delta t(A_h+B_h)) = \\exp(\\Delta t A_h)\\exp(\\Delta t B_h) = S_{\\Delta t} = L_{\\Delta t}$。因此，在这种情况下，预计 $E_{\\text{true}}$ 和 $E_{\\text{embed}}$ 都会是零（在机器精度范围内）。对于非对易情况，这些误差将不为零。嵌入式误差 $E_{\\text{embed}}$ 预计由低阶方法的主导误差项决定，该项为 $O(\\Delta t^2)$ 阶；而 Strang 分裂的真实误差 $E_{\\text{true}}$ 为 $O(\\Delta t^3)$ 阶。通过比较测试用例 3 和 4 来探究这种关系，其中 $\\Delta t$ 增加了 5 倍。我们预期 $E_{\\text{true}}$ 将增加约 $5^3=125$ 倍，$E_{\\text{embed}}$ 将增加约 $5^2=25$ 倍。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Implements and compares Lie-Trotter and Strang splitting methods for a 1D\n    reaction-diffusion equation, as specified in the problem statement.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # D (m^2/s), k_func (1/s), dt (s), N\n        (0.01, lambda x: 5.0 + 0.0 * x, 0.05, 16),\n        (0.01, lambda x: 5.0 * (1.0 + 0.5 * np.sin(2 * np.pi * x)), 0.01, 32),\n        (0.05, lambda x: 15.0 * (1.0 + np.sin(2 * np.pi * x)), 0.02, 32),\n        (0.05, lambda x: 15.0 * (1.0 + np.sin(2 * np.pi * x)), 0.10, 32),\n    ]\n\n    L = 1.0\n    results = []\n\n    for D, k_func, dt, N in test_cases:\n        # 1. Setup grid, initial condition, and reaction rate vector\n        h = L / N\n        x_grid = np.arange(N) * h\n        y0 = 0.25 + 0.75 * np.sin(2 * np.pi * x_grid / L)\n        k_vec = k_func(x_grid)\n\n        # 2. Construct discrete operator matrices\n        # Diffusion matrix A_h\n        diff_factor = D / h**2\n        A_h = np.zeros((N, N))\n        for i in range(N):\n            A_h[i, i] = -2.0 * diff_factor\n            A_h[i, (i + 1) % N] = 1.0 * diff_factor\n            A_h[i, (i - 1 + N) % N] = 1.0 * diff_factor\n        \n        # Reaction matrix B_h\n        B_h = -np.diag(k_vec)\n        \n        # Combined matrix C_h = A_h + B_h\n        C_h = A_h + B_h\n\n        # 3. Perform time stepping with different methods\n        \n        # 3.1. \"Exact\" reference solution using matrix exponential of the full operator\n        exp_C_dt = expm(dt * C_h)\n        y_ref = exp_C_dt @ y0\n\n        # Create a helper function for the diffusion sub-step using FFT\n        # Eigenvalues of the discrete diffusion operator A_h\n        m_modes = np.arange(N)\n        A_h_eigvals = -4.0 * D / h**2 * np.sin(np.pi * m_modes / N)**2\n\n        def apply_exp_A(vec, time_step):\n            vec_fourier = np.fft.fft(vec)\n            vec_fourier_evolved = np.exp(time_step * A_h_eigvals) * vec_fourier\n            return np.real(np.fft.ifft(vec_fourier_evolved))\n\n        # 3.2. Strang splitting solution: B(dt/2) A(dt) B(dt/2)\n        y_s_step1 = np.exp(-0.5 * dt * k_vec) * y0\n        y_s_step2 = apply_exp_A(y_s_step1, dt)\n        y_s = np.exp(-0.5 * dt * k_vec) * y_s_step2\n\n        # 3.3. Lie-Trotter solution: A(dt) B(dt)\n        y_lt_step1 = np.exp(-dt * k_vec) * y0\n        y_lt = apply_exp_A(y_lt_step1, dt)\n\n        # 4. Compute error norms\n        # Helper function for the h-weighted L2 norm\n        def norm_h(vec):\n            return np.sqrt(h) * np.linalg.norm(vec)\n\n        E_true = norm_h(y_ref - y_s)\n        E_embed = norm_h(y_lt - y_s)\n\n        results.extend([E_true, E_embed])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}