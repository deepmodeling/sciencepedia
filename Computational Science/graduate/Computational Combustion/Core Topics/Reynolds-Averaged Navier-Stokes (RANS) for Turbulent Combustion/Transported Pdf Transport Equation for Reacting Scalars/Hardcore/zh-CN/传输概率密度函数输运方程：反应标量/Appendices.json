{
    "hands_on_practices": [
        {
            "introduction": "在密度变化的流动（如燃烧）中，正确构建输运方程的关键在于区分体积加权（雷诺平均）和质量加权（Favre平均）。如果不加区分，可能会导致模型出现显著的系统性偏差。本练习  提供了一个量化这种偏差的实践机会，通过一个简化的预混火焰模型，让学生亲身体会到在可压缩流中标量输运计算中采用不同平均方法的差异，从而深化对Favre平均重要性的理解。",
            "id": "4073892",
            "problem": "考虑一个统计均匀的预混火焰，其被模拟为一个具有不同密度的两态混合物，分别代表反应物和产物。我们关心的标量是一个反应进程变量 $\\phi$，它在产物态下取值为 $\\phi_{1}=1$，在反应物态下取值为 $\\phi_{2}=0$。这两种状态出现的体积加权概率分别为 $p$ 和 $1-p$。产物态和反应物态的密度分别为 $\\rho_{1}$ 和 $\\rho_{2}$。假设混合物是稳态的，$\\phi$ 的输运仅由对流引起；为了评估平均输运，可以忽略扩散和反应。\n\n在可压缩流中反应标量的输运概率密度函数 (PDF) 框架中，区分雷诺PDF $P(\\phi)$（体积加权）和Favre PDF $\\tilde{P}(\\phi)$（质量加权）是至关重要的，其定义关系为 $\\tilde{P}(\\phi)=\\rho(\\phi)P(\\phi)/\\bar{\\rho}$，其中 $\\bar{\\rho}$ 是雷诺平均密度。标量的雷诺平均为 $\\overline{\\phi}=\\int \\phi\\,P(\\phi)\\,\\mathrm{d}\\phi$，Favre平均为 $\\tilde{\\phi}=\\int \\phi\\,\\tilde{P}(\\phi)\\,\\mathrm{d}\\phi$。\n\n仅使用这些基本定义，推导当使用雷诺PDF $P$ 代替Favre PDF $\\tilde{P}$ 时，在平均标量输运中产生的偏差误差的表达式，该误差被量化为两态混合物的差值 $E=\\overline{\\phi}-\\tilde{\\phi}$。然后，根据以下科学上合理的预混火焰参数计算 $E$：\n- $p=0.40$,\n- $\\rho_{1}=0.30\\,\\mathrm{kg\\,m^{-3}}$,\n- $\\rho_{2}=1.20\\,\\mathrm{kg\\,m^{-3}}$。\n\n以精确分数的形式给出你的最终答案。误差 $E$ 是无量纲的，不需要单位。",
            "solution": "恰当的基本基础是在可压缩湍流燃烧中区分雷诺平均（体积加权）和Favre平均（质量加权），以及它们相关的概率密度函数 (PDF) 表示。对于一个具有雷诺PDF $P(\\phi)$ 的标量 $\\phi$，其雷诺平均定义为\n$$\n\\overline{\\phi}=\\int_{-\\infty}^{\\infty} \\phi\\,P(\\phi)\\,\\mathrm{d}\\phi,\n$$\n而Favre平均通过Favre PDF $\\tilde{P}(\\phi)$ 定义为\n$$\n\\tilde{\\phi}=\\int_{-\\infty}^{\\infty} \\phi\\,\\tilde{P}(\\phi)\\,\\mathrm{d}\\phi.\n$$\n在可压缩流中，Favre PDF通过质量加权关系与雷诺PDF相关联\n$$\n\\tilde{P}(\\phi)=\\frac{\\rho(\\phi)}{\\bar{\\rho}}\\,P(\\phi),\n$$\n其中 $\\rho(\\phi)$ 是与状态 $\\phi$ 相关联的密度，而 $\\bar{\\rho}$ 是雷诺平均密度，\n$$\n\\bar{\\rho}=\\int_{-\\infty}^{\\infty} \\rho(\\phi)\\,P(\\phi)\\,\\mathrm{d}\\phi.\n$$\n\n我们将预混火焰模拟为一个两态混合物。该标量取两个离散值：在密度为 $\\rho_{1}$ 的产物态中 $\\phi_{1}=1$，在密度为 $\\rho_{2}$ 的反应物态中 $\\phi_{2}=0$。因此，雷诺PDF为\n$$\nP(\\phi)=p\\,\\delta(\\phi-\\phi_{1})+(1-p)\\,\\delta(\\phi-\\phi_{2}),\n$$\n其中 $p$ 是产物态的体积分数，$1-p$ 是反应物态的体积分数。使用这个离散PDF，$\\phi$ 的雷诺平均为\n$$\n\\overline{\\phi}=\\int \\phi\\,P(\\phi)\\,\\mathrm{d}\\phi=p\\,\\phi_{1}+(1-p)\\,\\phi_{2}.\n$$\n当 $\\phi_{1}=1$ 和 $\\phi_{2}=0$ 时，上式简化为\n$$\n\\overline{\\phi}=p.\n$$\n\n雷诺平均密度为\n$$\n\\bar{\\rho}=\\int \\rho(\\phi)\\,P(\\phi)\\,\\mathrm{d}\\phi=p\\,\\rho_{1}+(1-p)\\,\\rho_{2}.\n$$\n该两态混合物的Favre PDF为\n$$\n\\tilde{P}(\\phi)=\\frac{\\rho(\\phi)}{\\bar{\\rho}}\\,P(\\phi)=\\frac{p\\,\\rho_{1}}{\\bar{\\rho}}\\,\\delta(\\phi-\\phi_{1})+\\frac{(1-p)\\,\\rho_{2}}{\\bar{\\rho}}\\,\\delta(\\phi-\\phi_{2}).\n$$\n因此，Favre平均为\n$$\n\\tilde{\\phi}=\\int \\phi\\,\\tilde{P}(\\phi)\\,\\mathrm{d}\\phi=\\frac{p\\,\\rho_{1}}{\\bar{\\rho}}\\,\\phi_{1}+\\frac{(1-p)\\,\\rho_{2}}{\\bar{\\rho}}\\,\\phi_{2}.\n$$\n当 $\\phi_{1}=1$ 和 $\\phi_{2}=0$ 时，这变为\n$$\n\\tilde{\\phi}=\\frac{p\\,\\rho_{1}}{p\\,\\rho_{1}+(1-p)\\,\\rho_{2}}.\n$$\n\n当使用雷诺PDF而非Favre PDF时，在平均标量输运中产生的偏差误差 $E$ 定义为\n$$\nE=\\overline{\\phi}-\\tilde{\\phi}=p-\\frac{p\\,\\rho_{1}}{p\\,\\rho_{1}+(1-p)\\,\\rho_{2}}.\n$$\n\n我们现在根据给定的参数 $p=0.40$，$\\rho_{1}=0.30\\,\\mathrm{kg\\,m^{-3}}$ 和 $\\rho_{2}=1.20\\,\\mathrm{kg\\,m^{-3}}$ 来计算 $E$。首先计算雷诺平均密度：\n$$\n\\bar{\\rho}=p\\,\\rho_{1}+(1-p)\\,\\rho_{2}=(0.40)\\,(0.30)+(0.60)\\,(1.20)=0.12+0.72=0.84.\n$$\n计算Favre平均：\n$$\n\\tilde{\\phi}=\\frac{p\\,\\rho_{1}}{\\bar{\\rho}}=\\frac{(0.40)\\,(0.30)}{0.84}=\\frac{0.12}{0.84}=\\frac{12}{84}=\\frac{1}{7}.\n$$\n计算雷诺平均：\n$$\n\\overline{\\phi}=p=0.40=\\frac{2}{5}.\n$$\n因此误差为\n$$\nE=\\overline{\\phi}-\\tilde{\\phi}=\\frac{2}{5}-\\frac{1}{7}=\\frac{14-5}{35}=\\frac{9}{35}.\n$$\n这符合要求，是一个精确分数且无量纲。",
            "answer": "$$\\boxed{\\frac{9}{35}}$$"
        },
        {
            "introduction": "在求解输运概率密度函数（PDF）方程时，一个核心挑战是对分子混合项进行封闭。均值交换（IEM）模型是一种简单而广泛应用的封闭方法，它假设流体微团通过与局部平均成分交换来实现混合。本练习  将引导你推导在该模型下，标量方差随时间的演化规律，通过这个过程，你将清晰地看到IEM模型如何导致标量方差指数衰减，从而直观地理解其耗散特性。",
            "id": "4073894",
            "problem": "考虑一个携带单一反应标量 $\\phi(\\boldsymbol{x},t)$ 且密度 $\\rho(\\boldsymbol{x},t)$ 可变的统计均匀、各向同性的湍流。在用于反应标量的输运概率密度函数（PDF）方法中，分子混合项采用与均值交换（IEM）模型进行封闭。在拉格朗日描述中，一个概念粒子所携带的标量组分（记为 $\\Phi(t)$）在 IEM 封闭模型下，以恒定的混合速率 $\\gamma>0$ 向 Favre 均值 $\\tilde{\\phi}(t)$ 进行确定性松弛演化。Favre 均值定义为 $\\tilde{\\phi}=\\langle \\rho \\phi \\rangle / \\langle \\rho \\rangle$，其中 $\\langle \\cdot \\rangle$ 表示系综平均。假设一个均匀混合器，其中无平均梯度、无物理扩散、除 IEM 混合外无其他源项，因此在 IEM 算子作用下，$\\tilde{\\phi}(t)$ 不随时间变化。该组分的拉格朗日模型由以下常微分方程给出：\n$$\n\\frac{d\\Phi}{dt}=-\\gamma\\left(\\Phi-\\tilde{\\phi}\\right),\n$$\n其中 $\\gamma$ 不随时间变化。设 $\\Phi(0)$ 的初始分布具有有限的 Favre 方差，定义为：\n$$\n\\sigma_{\\phi}^{2}(0)=\\left\\langle \\rho \\left(\\phi(0)-\\tilde{\\phi}\\right)^{2}\\right\\rangle \\Big/ \\langle \\rho \\rangle,\n$$\n并在时间 $t$ 类似地定义 $\\sigma_{\\phi}^{2}(t)$。\n\n从上述基础出发，推导此均匀混合器中 IEM 松弛所蕴含的 $\\sigma_{\\phi}^{2}(t)$ 的时间演化。你的推导应基于给定的 $\\Phi(t)$ 演化定律、Favre 均值和 Favre 方差的定义以及所述的均匀性假设，不引入任何额外的建模捷径。提供 $\\sigma_{\\phi}^{2}(t)$ 关于 $\\sigma_{\\phi}^{2}(0)$、$\\gamma$ 和 $t$ 的最终闭式解析表达式。将最终答案表示为一个不含等号和单位的单一解析表达式。",
            "solution": "问题要求在一个由用于分子混合的与均值交换（IEM）模型控制的均匀湍流混合器中，推导标量 Favre 方差 $\\sigma_{\\phi}^{2}(t)$ 的时间演化。\n\n根据问题定义，时间 $t$ 的 Favre 方差为：\n$$\n\\sigma_{\\phi}^{2}(t) = \\frac{\\left\\langle \\rho \\left(\\phi(t)-\\tilde{\\phi}\\right)^{2}\\right\\rangle}{\\langle \\rho \\rangle}\n$$\n在拉格朗日框架中，我们追踪概念流体粒子，粒子的标量值记为 $\\Phi(t)$，其密度记为 $\\rho(t)$。系综平均 $\\langle \\cdot \\rangle$ 是对这些大量粒子的集合进行的。问题指出系统是统计均匀的，这意味着平均密度 $\\langle \\rho \\rangle$ 不随时间变化。\n\n为了求出 $\\sigma_{\\phi}^{2}(t)$ 的时间演化，我们对该定义式关于时间 $t$ 求导：\n$$\n\\frac{d\\sigma_{\\phi}^{2}(t)}{dt} = \\frac{d}{dt} \\left[ \\frac{\\left\\langle \\rho(t) \\left(\\Phi(t)-\\tilde{\\phi}\\right)^{2}\\right\\rangle}{\\langle \\rho \\rangle} \\right]\n$$\n由于 $\\langle \\rho \\rangle$ 是一个常数，我们有：\n$$\n\\frac{d\\sigma_{\\phi}^{2}(t)}{dt} = \\frac{1}{\\langle \\rho \\rangle} \\frac{d}{dt} \\left\\langle \\rho(t) \\left(\\Phi(t)-\\tilde{\\phi}\\right)^{2} \\right\\rangle\n$$\n对于一个统计定常系统（这是均匀性的一个推论），关于时间的微分运算和系综平均运算是可交换的。因此，我们可以将导数移到尖括号内：\n$$\n\\frac{d\\sigma_{\\phi}^{2}(t)}{dt} = \\frac{1}{\\langle \\rho \\rangle} \\left\\langle \\frac{d}{dt} \\left[ \\rho(t) \\left(\\Phi(t)-\\tilde{\\phi}\\right)^{2} \\right] \\right\\rangle\n$$\n我们对导数内的项应用乘法法则：\n$$\n\\frac{d}{dt} \\left[ \\rho(t) \\left(\\Phi(t)-\\tilde{\\phi}\\right)^{2} \\right] = \\frac{d\\rho}{dt} \\left(\\Phi(t)-\\tilde{\\phi}\\right)^{2} + \\rho(t) \\frac{d}{dt} \\left[ \\left(\\Phi(t)-\\tilde{\\phi}\\right)^{2} \\right]\n$$\n对第二项使用链式法则，并注意到根据问题陈述，Favre 均值 $\\tilde{\\phi}$ 不随时间变化（$\\frac{d\\tilde{\\phi}}{dt}=0$），我们得到：\n$$\n\\frac{d}{dt} \\left[ \\rho(t) \\left(\\Phi(t)-\\tilde{\\phi}\\right)^{2} \\right] = \\frac{d\\rho}{dt} \\left(\\Phi(t)-\\tilde{\\phi}\\right)^{2} + 2\\rho(t) \\left(\\Phi(t)-\\tilde{\\phi}\\right) \\frac{d\\Phi}{dt}\n$$\n问题陈述中存在一个潜在的歧义：它提到了“反应标量”，这意味着密度可能随组分变化；但它也指明“除 IEM 混合外无源项”，这意味着没有化学反应。后者是一个具体的动力学约束，必须优先考虑。IEM 模型本身只描述了标量 $\\Phi$ 因混合而发生的演化。在没有反应或其他指定的密度动力学的情况下，最合乎逻辑和标准的简化是假设每个拉格朗日粒子的密度是守恒的，即沿其轨迹为常数。这意味着对于每个粒子 $\\frac{d\\rho}{dt} = 0$。在此假设下，上式中的第一项为零。\n$$\n\\frac{d}{dt} \\left[ \\rho(t) \\left(\\Phi(t)-\\tilde{\\phi}\\right)^{2} \\right] = 2\\rho(t) \\left(\\Phi(t)-\\tilde{\\phi}\\right) \\frac{d\\Phi}{dt}\n$$\n将此结果代回方差变化率的方程中，得到：\n$$\n\\frac{d\\sigma_{\\phi}^{2}(t)}{dt} = \\frac{1}{\\langle \\rho \\rangle} \\left\\langle 2\\rho(t) \\left(\\Phi(t)-\\tilde{\\phi}\\right) \\frac{d\\Phi}{dt} \\right\\rangle\n$$\n问题给出了根据 IEM 模型的 $\\Phi(t)$ 的拉格朗日演化定律：\n$$\n\\frac{d\\Phi}{dt} = -\\gamma\\left(\\Phi - \\tilde{\\phi}\\right)\n$$\n其中 $\\gamma$ 是恒定的混合速率。将这个 $\\frac{d\\Phi}{dt}$ 的表达式代入：\n$$\n\\frac{d\\sigma_{\\phi}^{2}(t)}{dt} = \\frac{1}{\\langle \\rho \\rangle} \\left\\langle 2\\rho(t) \\left(\\Phi(t)-\\tilde{\\phi}\\right) \\left[ -\\gamma\\left(\\Phi(t)-\\tilde{\\phi}\\right) \\right] \\right\\rangle\n$$\n我们可以从系综平均中提出常数 $-2$ 和 $\\gamma$：\n$$\n\\frac{d\\sigma_{\\phi}^{2}(t)}{dt} = -2\\gamma \\frac{\\left\\langle \\rho(t) \\left(\\Phi(t)-\\tilde{\\phi}\\right)^{2} \\right\\rangle}{\\langle \\rho \\rangle}\n$$\n右边的项根据定义就是 Favre 方差 $\\sigma_{\\phi}^{2}(t)$。这就得到了一个关于 $\\sigma_{\\phi}^{2}(t)$ 的一阶线性齐次常微分方程：\n$$\n\\frac{d\\sigma_{\\phi}^{2}}{dt} = -2\\gamma \\sigma_{\\phi}^{2}(t)\n$$\n这个常微分方程可以通过分离变量法求解，初始条件为 $t=0$ 时的 Favre 方差，记为 $\\sigma_{\\phi}^{2}(0)$。解为：\n$$\n\\int_{\\sigma_{\\phi}^{2}(0)}^{\\sigma_{\\phi}^{2}(t)} \\frac{d(\\sigma_{\\phi}^{2})}{\\sigma_{\\phi}^{2}} = \\int_{0}^{t} -2\\gamma \\,d\\tau\n$$\n$$\n\\ln\\left(\\frac{\\sigma_{\\phi}^{2}(t)}{\\sigma_{\\phi}^{2}(0)}\\right) = -2\\gamma t\n$$\n对两边取指数，即可得到 Favre 方差时间演化的最终解析表达式：\n$$\n\\sigma_{\\phi}^{2}(t) = \\sigma_{\\phi}^{2}(0) \\exp(-2\\gamma t)\n$$\n此结果表明，在均匀系统中，根据 IEM 混合模型，Favre 标量方差以 $2\\gamma$ 的速率随时间指数衰减。",
            "answer": "$$\\boxed{\\sigma_{\\phi}^{2}(0) \\exp(-2\\gamma t)}$$"
        },
        {
            "introduction": "将理论模型转化为计算程序，需要确保数值求解器能严格遵守基本的物理定律。在反应流的PDF方法中，“可实现性”（realizability）是一个至关重要的概念，它要求物质的质量分数等标量始终保持在物理界限内（例如，质量分数在 $0$ 和 $1$ 之间且总和为 $1$）。这个编程练习  要求你构建一个包含混合与反应过程的简化PDF求解器，并设计测试来验证其在模拟过程中是否始终保持物理上的一致性，这是连接理论与工程实践的关键一步。",
            "id": "4073910",
            "problem": "您的任务是为代表组分质量分数的反应标量构建并分析一个简化的输运概率密度函数（PDF）求解器。设有 $N_s$ 个化学组分，每个计算粒子的质量分数为 $\\{Y_i\\}_{i=1}^{N_s}$，其中每个粒子是质量分数单纯形上联合概率分布的一个样本。质量分数单纯形的约束条件是：对于所有 $i$，$0 \\le Y_i \\le 1$ 且 $\\sum_{i=1}^{N_s} Y_i = 1$。该求解器随时间演化一个由 $N_p$ 个粒子组成的系综，其中每个粒子携带一个质量分数向量 $\\mathbf{Y} \\in \\mathbb{R}^{N_s}$，并受到微观混合和化学反应的影响。假设系统是统计均匀的（无空间输运），使得输运联合概率密度函数 $p(\\mathbf{Y}, t)$ 遵循概率守恒。微观混合应建模为一个以符合可实现性的方式将粒子组分向系综统计量收缩的演化过程，而化学反应应建模为一个在组分间进行的、保持总质量分数守恒的线性马尔可夫过程。\n\n从以下基本依据出发：\n- 单纯形上的概率守恒和质量分数守恒，这要求不变量 $0 \\le Y_i \\le 1$ 和 $\\sum_{i=1}^{N_s} Y_i = 1$ 在所有时间都成立。\n- 一个统计均匀的微观混合算子，根据其构造，它在单个时间增量内将一个粒子组分映射为与系综统计量的凸组合，从而保持单纯形。\n- 一个由生成元矩阵表示的线性反应算子，该矩阵具有非负的非对角线元素和为零的行和，它定义了组分索引上的一个连续时间马尔可夫过程，并保持非负性和总和不变。\n\n您的任务是：\n1. 基于上述基本依据，推导一个有原则的、基于粒子的时间推进格式，该格式通过一个微观混合步后跟一个线性反应步，将 $\\mathbf{Y}$ 推进一个时间步长 $\\Delta t$。该格式必须解析地保持不变量 $0 \\le Y_i \\le 1$ 和 $\\sum_i Y_i = 1$。\n2. 实现一个程序，模拟系综在指定数量的时间步长内的演化。当系综统计量本身接近边界时，所选择的微观混合必须能将标量值推向边界；而化学反应必须由一个能在组分间转移概率同时保持守恒性的生成元表示。不允许外部输入；所有参数都在代码中定义。\n3. 设计可实现性测试，以验证在所有模拟的时间步长中：\n   - 边界 $0 \\le Y_i \\le 1$ 得以维持。\n   - 总和 $\\sum_{i=1}^{N_s} Y_i = 1$ 得以维持。\n   - 当系综统计量接近边界时，微观混合总体上将粒子标量更靠近边界，这一点通过一个聚合的边界接近度度量的减小来量化。\n\n将时间 $t$ 时系综的聚合边界接近度度量定义如下。对于每个具有组分 $\\mathbf{Y}^{(k)}(t)$ 的粒子 $k$，计算 $m^{(k)}(t) = \\max_i Y^{(k)}_i(t)$，并将单个粒子到最近上界的距离定义为 $d^{(k)}(t) = 1 - m^{(k)}(t)$。系综度量是算术平均值 $\\bar{d}(t) = \\frac{1}{N_p} \\sum_{k=1}^{N_p} d^{(k)}(t)$。如果 $\\bar{d}(t_{\\text{final}}) \\le \\bar{d}(t_{\\text{initial}})$，则称微观混合将值推向了边界。\n\n程序必须在没有任何外部输入的情况下执行以下测试套件：\n\n- 测试 1（一般情况）：$N_s = 3$，$N_p = 1000$，$\\Delta t = 10^{-3}$，$N_{\\text{steps}} = 500$，混合时间尺度 $\\tau_{\\text{mix}} = 5 \\times 10^{-3}$，以及一个优先将概率质量转移到组分 1（索引 $i=1,2,3$）的反应生成元。将 $70\\%$ 的粒子初始化在 $\\mathbf{Y} = [1,0,0]$，将 $30\\%$ 初始化在 $\\mathbf{Y} = [\\frac{1}{3},\\frac{1}{3},\\frac{1}{3}]$。\n- 测试 2（边界驱动混合，无反应）：$N_s = 2$，$N_p = 200$，$\\Delta t = 5 \\times 10^{-2}$，$N_{\\text{steps}} = 50$，混合时间尺度 $\\tau_{\\text{mix}} = 5 \\times 10^{-2}$，关闭反应。将 $50\\%$ 的粒子初始化在 $\\mathbf{Y} = [1,0]$，将 $50\\%$ 初始化在 $\\mathbf{Y} = [0.2,0.8]$。\n- 测试 3（快速混合极限）：$N_s = 2$，$N_p = 50$，$\\Delta t = 1$，$N_{\\text{steps}} = 5$，混合时间尺度 $\\tau_{\\text{mix}} = 10^{-6}$，关闭反应。将粒子均匀分配在 $\\mathbf{Y} = [1,0]$ 和 $\\mathbf{Y} = [0,1]$ 之间。\n- 测试 4（单粒子边缘情况）：$N_s = 3$，$N_p = 1$，$\\Delta t = 10^{-1}$，$N_{\\text{steps}} = 20$，混合时间尺度 $\\tau_{\\text{mix}} = 10^{-1}$，关闭反应。将单个粒子初始化在 $\\mathbf{Y} = [1,0,0]$。\n\n对于每个测试，计算所有时间步长中的最大可实现性违背幅度\n$$\n\\varepsilon = \\max\\left\\{ \\max_{k,t}\\left( \\max_i\\{-Y^{(k)}_i(t), \\, Y^{(k)}_i(t)-1\\} \\right), \\; \\max_{k,t} \\left| \\sum_{i=1}^{N_s} Y^{(k)}_i(t) - 1 \\right| \\right\\},\n$$\n并通过检查 $\\bar{d}(t_{\\text{final}}) \\le \\bar{d}(t_{\\text{initial}})$ 来确定微观混合是否将值推向边界。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例产生一个布尔值，其定义为当且仅当以下两条都成立时为真：$(i)$ $\\varepsilon \\le 10^{-12}$ 且 $(ii)$ $\\bar{d}(t_{\\text{final}}) \\le \\bar{d}(t_{\\text{initial}}) + 10^{-12}$。因此，最终输出必须是 $[b_1,b_2,b_3,b_4]$ 的形式，其中每个 $b_j$ 是如上定义的真（true）或假（false）。",
            "solution": "我们从由组分质量分数 $\\{Y_i\\}_{i=1}^{N_s}$ 表示的反应标量开始，这些标量遵循 $0 \\le Y_i \\le 1$ 和 $\\sum_{i=1}^{N_s} Y_i = 1$，这定义了质量分数单纯形。在输运概率密度函数方法中，一个由 $N_p$ 个计算粒子组成的系综 $\\{\\mathbf{Y}^{(k)}(t)\\}_{k=1}^{N_p}$ 代表了联合概率密度函数 $p(\\mathbf{Y}, t)$ 的样本，它们的演化必须保持可实现性和概率守恒。\n\n微观混合的原理。在统计均匀湍流中，微观混合封闭模型必须保持可实现性，并且与向系综统计量的收缩过程一致。守恒性和凸性是其基础：如果从时间 $t$ 到 $t+\\Delta t$ 的更新是一个粒子和系综统计量 $\\mathbf{M}(t)$ 之间的凸组合，那么对于任何粒子 $k$，\n$$\n\\mathbf{Y}^{(k)}(t+\\Delta t) = \\alpha \\, \\mathbf{Y}^{(k)}(t) + (1-\\alpha)\\, \\mathbf{M}(t),\n$$\n其中 $0 \\le \\alpha \\le 1$，只要初始状态是可实现的且 $\\mathbf{M}(t)$ 位于单纯形上，就能保证 $0 \\le Y^{(k)}_i(t+\\Delta t) \\le 1$ 和 $\\sum_i Y^{(k)}_i(t+\\Delta t) = 1$。一个经过充分检验且与上述原理一致的均匀微观混合模型是均值交换相互作用（IEM）模型，它产生一个与粒子状态和系综平均值 $\\mathbf{\\bar{Y}}(t) = \\frac{1}{N_p}\\sum_k \\mathbf{Y}^{(k)}(t)$ 之差成正比的漂移项，以及一个弛豫时间尺度 $\\tau_{\\text{mix}}$。每个粒子的常微分方程为\n$$\n\\frac{d \\mathbf{Y}^{(k)}}{dt} = -\\frac{1}{\\tau_{\\text{mix}}} \\left( \\mathbf{Y}^{(k)} - \\mathbf{\\bar{Y}} \\right).\n$$\n在单个时间步 $\\Delta t$ 内，假设 $\\mathbf{\\bar{Y}}$ 在该步内为常数，求解此线性微分方程可得精确更新式\n$$\n\\mathbf{Y}^{(k)}(t+\\Delta t) = \\mathbf{\\bar{Y}}(t) + e^{-\\Delta t/\\tau_{\\text{mix}}} \\left( \\mathbf{Y}^{(k)}(t) - \\mathbf{\\bar{Y}}(t) \\right),\n$$\n这是 $\\mathbf{Y}^{(k)}(t)$ 和 $\\mathbf{\\bar{Y}}(t)$ 之间的一个凸组合，因为 $e^{-\\Delta t/\\tau_{\\text{mix}}} \\in (0,1]$。此更新解析地保持了单纯形：对于每个粒子，\n$$\n\\sum_i Y^{(k)}_i(t+\\Delta t) = \\sum_i \\bar{Y}_i(t) + e^{-\\Delta t/\\tau_{\\text{mix}}}\\left( \\sum_i Y^{(k)}_i(t) - \\sum_i \\bar{Y}_i(t) \\right) = 1 + e^{-\\Delta t/\\tau_{\\text{mix}}}(1-1) = 1,\n$$\n且 $Y^{(k)}_i(t+\\Delta t)$ 位于 $Y^{(k)}_i(t)$ 和 $\\bar{Y}_i(t)$ 之间，而这两者都位于 $[0,1]$ 区间内，因此 $0 \\le Y^{(k)}_i(t+\\Delta t) \\le 1$。\n\n化学反应的原理。在组分间转移质量的反应必须保持可实现性。一个基于组分索引的连续时间马尔可夫链实现了一个线性反应算子，其生成元矩阵为 $\\mathbf{Q} \\in \\mathbb{R}^{N_s \\times N_s}$，该矩阵的非对角线元素非负，且行和为零：\n$$\nQ_{ij} \\ge 0 \\text{ for } i \\neq j, \\qquad \\sum_{j=1}^{N_s} Q_{ij} = 0 \\text{ for all } i.\n$$\n将 $\\mathbf{Y}$ 解释为行向量，反应动力学为\n$$\n\\frac{d \\mathbf{Y}}{dt} = \\mathbf{Y}\\, \\mathbf{Q}.\n$$\n在 $\\Delta t$ 上的精确单步解为\n$$\n\\mathbf{Y}(t+\\Delta t) = \\mathbf{Y}(t)\\, \\exp(\\mathbf{Q}\\Delta t),\n$$\n其中 $\\exp$ 是矩阵指数。对于一个有效的生成元，$\\mathbf{P} = \\exp(\\mathbf{Q}\\Delta t)$ 是一个随机矩阵：其行是概率分布，元素非负且行和为1。因此，如果 $\\mathbf{Y}(t)$ 是一个概率向量（分量在 $[0,1]$ 之间且和为1），那么 $\\mathbf{Y}(t+\\Delta t) = \\mathbf{Y}(t)\\mathbf{P}$ 也是一个概率向量，从而保持了 $0 \\le Y_i \\le 1$ 和 $\\sum_i Y_i = 1$。\n\n微观混合与反应的组合。在每个时间步中，我们首先使用系综平均值应用微观混合更新来计算 $\\mathbf{Y}^{(k)}_{\\text{mix}}$，然后通过随机矩阵 $\\mathbf{P}$ 应用反应更新来获得 $\\mathbf{Y}^{(k)}_{\\text{new}} = \\mathbf{Y}^{(k)}_{\\text{mix}} \\mathbf{P}$。每个子步骤都将单纯形映射到其自身，因此组合步骤也是如此，解析地保持了可实现性。\n\n推向边界。如果系综平均值接近一个边界（例如，某个组分分量的上界1），微观混合的收缩作用将粒子拉向该平均值，从而减少系综到最近边界的平均距离。一个严谨的聚合度量是计算每个粒子的最大分量 $m^{(k)}(t) = \\max_i Y^{(k)}_i(t)$ 和平均上界距离 $\\bar{d}(t) = \\frac{1}{N_p}\\sum_k (1 - m^{(k)}(t))$。由于混合是向系综平均值的收缩，且系综平均值本身位于单纯形上，如果平均组分比初始系综平均值更接近上界，重复应用混合会减小 $\\bar{d}(t)$。\n\n算法设计。\n- 根据指定的测试用例，初始化一个包含 $N_p$ 个粒子在单纯形上的组分的数组。\n- 对于每个时间步：\n  1. 计算系综平均值 $\\mathbf{\\bar{Y}}(t) = \\frac{1}{N_p}\\sum_k \\mathbf{Y}^{(k)}(t)$。\n  2. 应用微观混合（IEM 精确更新）：对于每个粒子 $k$，\n     $$\n     \\mathbf{Y}^{(k)}_{\\text{mix}} = \\mathbf{\\bar{Y}}(t) + e^{-\\Delta t/\\tau_{\\text{mix}}} \\left( \\mathbf{Y}^{(k)}(t) - \\mathbf{\\bar{Y}}(t) \\right).\n     $$\n  3. 应用反应：预计算 $\\mathbf{P} = \\exp(\\mathbf{Q}\\Delta t)$ 并设置 $\\mathbf{Y}^{(k)}(t+\\Delta t) = \\mathbf{Y}^{(k)}_{\\text{mix}} \\mathbf{P}$。\n  4. 跟踪可实现性违背情况：在每一步，计算\n     $$\n     v_{\\text{bounds}}(t) = \\max_{k,i} \\left\\{ -Y^{(k)}_i(t),\\, Y^{(k)}_i(t)-1 \\right\\}, \\quad v_{\\text{sum}}(t) = \\max_k \\left| \\sum_i Y^{(k)}_i(t) - 1 \\right|.\n     $$\n     累积 $\\varepsilon = \\max_t \\max\\{v_{\\text{bounds}}(t), v_{\\text{sum}}(t)\\}$.\n- 计算初始和最终时间的边界接近度度量，\n  $$\n  \\bar{d}(t_{\\text{initial}}) = \\frac{1}{N_p}\\sum_{k=1}^{N_p} \\left( 1 - \\max_i Y^{(k)}_i(t_{\\text{initial}}) \\right), \\quad\n  \\bar{d}(t_{\\text{final}}) = \\frac{1}{N_p}\\sum_{k=1}^{N_p} \\left( 1 - \\max_i Y^{(k)}_i(t_{\\text{final}}) \\right).\n  $$\n- 对于每个测试，返回一个布尔值，当 $\\varepsilon \\le 10^{-12}$ 且 $\\bar{d}(t_{\\text{final}}) \\le \\bar{d}(t_{\\text{initial}}) + 10^{-12}$ 时为真。\n\n测试套件覆盖范围的理由。\n- 测试 1 代表一个典型的输运概率密度函数场景，包含三种组分、有限的微观混合以及将概率移向主导组分的反应。初始系综包括大部分处于边界的粒子和一部分广泛混合的粒子，以确保向边界收缩。\n- 测试 2 隔离了没有反应的微观混合，在一个双组分系统中，明确测试了边界附近的混合会减小到边界的聚合距离。\n- 测试 3 是一个快速混合极限情况，其中 $\\Delta t/\\tau_{\\text{mix}} \\gg 1$，导致立即收缩到系综平均值；它测试了强混合下的稳定性和可实现性。\n- 测试 4 是一个单粒子边缘情况，其中系综平均值等于粒子状态；混合是一个空操作，且关闭反应后，不变量和边界接近度度量保持不变。\n\n通过从均值交换相互作用模型推导微观混合更新，并从有效生成元的矩阵指数推导反应更新，该算法解析地保持了可实现性。程序用有限精度算术实现这些步骤，并在严格的容差下验证可实现性，同时在定义的场景中确认了指向边界的行为。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef iem_mixing_step(Y, tau_mix, dt):\n    \"\"\"\n    Apply the exact Interaction by Exchange with the Mean (IEM) mixing step.\n    Y: array of shape (N_p, N_s) with particle mass fractions.\n    tau_mix: mixing timescale (float).\n    dt: timestep (float).\n    Returns updated Y after mixing.\n    \"\"\"\n    Y_mean = Y.mean(axis=0, keepdims=True)  # shape (1, N_s)\n    alpha = np.exp(-dt / tau_mix) if tau_mix > 0.0 else 0.0  # contraction factor\n    # Exact convex update toward mean\n    Y_mix = Y_mean + alpha * (Y - Y_mean)\n    return Y_mix\n\ndef reaction_step(Y, Q, dt):\n    \"\"\"\n    Apply exact linear reaction step using matrix exponential.\n    Y: array of shape (N_p, N_s), row-vector interpretation for each particle.\n    Q: generator matrix of shape (N_s, N_s) with rows summing to zero and nonnegative off-diagonals.\n    dt: timestep (float).\n    Returns updated Y after reaction.\n    \"\"\"\n    if Q is None:\n        return Y\n    P = expm(Q * dt)  # stochastic matrix under valid generator\n    # Row-vector times matrix: (N_p, N_s) @ (N_s, N_s) -> (N_p, N_s)\n    Y_new = Y @ P\n    return Y_new\n\ndef realizability_violations(Y):\n    \"\"\"\n    Compute realizability violations for current Y.\n    Returns tuple (v_bounds, v_sum):\n    - v_bounds = max over particles and species of max(-Y_i, Y_i - 1)\n    - v_sum = max over particles of |sum_i Y_i - 1|\n    \"\"\"\n    v_bounds = max(float(np.max(-Y)), float(np.max(Y - 1.0)))\n    sums = np.sum(Y, axis=1)\n    v_sum = float(np.max(np.abs(sums - 1.0)))\n    return v_bounds, v_sum\n\ndef bound_closeness_metric(Y):\n    \"\"\"\n    Compute ensemble average closeness to upper bound:\n    mean over particles of (1 - max_i Y_i).\n    \"\"\"\n    per_particle_max = np.max(Y, axis=1)\n    d = 1.0 - per_particle_max\n    return float(np.mean(d))\n\ndef run_test(Ns, Np, dt, n_steps, tau_mix, Q, initializer):\n    \"\"\"\n    Run a single test with specified parameters.\n    Ns: number of species\n    Np: number of particles\n    dt: timestep\n    n_steps: number of steps\n    tau_mix: mixing timescale\n    Q: reaction generator matrix (Ns x Ns) or None\n    initializer: function(Np, Ns) -> initial Y array\n    Returns boolean result: True iff both realizability and bound-driven conditions hold.\n    \"\"\"\n    Y = initializer(Np, Ns)\n\n    # Initial metrics\n    eps_max = 0.0\n    v_b, v_s = realizability_violations(Y)\n    eps_max = max(eps_max, v_b, v_s)\n    d_initial = bound_closeness_metric(Y)\n\n    # Time stepping\n    for _ in range(n_steps):\n        # Mixing\n        Y = iem_mixing_step(Y, tau_mix, dt)\n        # Reaction\n        Y = reaction_step(Y, Q, dt)\n        # Track violations\n        v_b, v_s = realizability_violations(Y)\n        eps_max = max(eps_max, v_b, v_s)\n\n    d_final = bound_closeness_metric(Y)\n\n    # Conditions\n    tol = 1e-12\n    realizability_ok = eps_max <= tol\n    bounds_driven = d_final <= d_initial + tol\n\n    return realizability_ok and bounds_driven\n\ndef init_test1(Np, Ns):\n    \"\"\"\n    Test 1 initializer: 70% pure species 1, 30% equimolar.\n    Species index order: [1,2,3]; pure means [1,0,0].\n    \"\"\"\n    assert Ns == 3\n    Y = np.zeros((Np, Ns))\n    n_pure = int(0.7 * Np)\n    # Pure species 1\n    Y[:n_pure, 0] = 1.0\n    # Equimolar for the rest\n    Y[n_pure:, :] = 1.0 / Ns\n    return Y\n\ndef Q_test1(Ns):\n    \"\"\"\n    Reaction generator that preferentially moves probability to species 1.\n    Row-sum zero, nonnegative off-diagonals.\n    Example rates:\n    From species 2 -> 1 rate 2.0; 2 -> 3 rate 0.2\n    From species 3 -> 1 rate 2.0; 3 -> 2 rate 0.2\n    From species 1 -> 2,3 rates 0.05 each (small leakage)\n    \"\"\"\n    assert Ns == 3\n    Q = np.zeros((Ns, Ns))\n    # Row for species 1 (leakage to 2 and 3)\n    Q[0, 1] = 0.05\n    Q[0, 2] = 0.05\n    Q[0, 0] = -(Q[0, 1] + Q[0, 2])\n    # Row for species 2\n    Q[1, 0] = 2.0\n    Q[1, 2] = 0.2\n    Q[1, 1] = -(Q[1, 0] + Q[1, 2])\n    # Row for species 3\n    Q[2, 0] = 2.0\n    Q[2, 1] = 0.2\n    Q[2, 2] = -(Q[2, 0] + Q[2, 1])\n    return Q\n\ndef init_test2(Np, Ns):\n    \"\"\"\n    Test 2 initializer: 50% [1,0], 50% [0.2, 0.8]\n    \"\"\"\n    assert Ns == 2\n    Y = np.zeros((Np, Ns))\n    n_half = Np // 2\n    Y[:n_half, 0] = 1.0\n    Y[:n_half, 1] = 0.0\n    Y[n_half:, 0] = 0.2\n    Y[n_half:, 1] = 0.8\n    return Y\n\ndef init_test3(Np, Ns):\n    \"\"\"\n    Test 3 initializer: evenly split between [1,0] and [0,1]\n    \"\"\"\n    assert Ns == 2\n    Y = np.zeros((Np, Ns))\n    n_half = Np // 2\n    Y[:n_half, 0] = 1.0\n    Y[:n_half, 1] = 0.0\n    Y[n_half:, 0] = 0.0\n    Y[n_half:, 1] = 1.0\n    return Y\n\ndef init_test4(Np, Ns):\n    \"\"\"\n    Test 4 initializer: single particle at [1,0,0]\n    \"\"\"\n    assert Ns == 3\n    assert Np == 1\n    Y = np.zeros((Np, Ns))\n    Y[0, 0] = 1.0\n    return Y\n\ndef solve():\n    tests = []\n\n    # Test 1 parameters\n    Ns1 = 3\n    Np1 = 1000\n    dt1 = 1e-3\n    steps1 = 500\n    tau1 = 5e-3\n    Q1 = Q_test1(Ns1)\n    tests.append((Ns1, Np1, dt1, steps1, tau1, Q1, init_test1))\n\n    # Test 2 parameters (no reaction)\n    Ns2 = 2\n    Np2 = 200\n    dt2 = 5e-2\n    steps2 = 50\n    tau2 = 5e-2\n    Q2 = None\n    tests.append((Ns2, Np2, dt2, steps2, tau2, Q2, init_test2))\n\n    # Test 3 parameters (fast mixing)\n    Ns3 = 2\n    Np3 = 50\n    dt3 = 1.0\n    steps3 = 5\n    tau3 = 1e-6\n    Q3 = None\n    tests.append((Ns3, Np3, dt3, steps3, tau3, Q3, init_test3))\n\n    # Test 4 parameters (single particle, no reaction)\n    Ns4 = 3\n    Np4 = 1\n    dt4 = 1e-1\n    steps4 = 20\n    tau4 = 1e-1\n    Q4 = None\n    tests.append((Ns4, Np4, dt4, steps4, tau4, Q4, init_test4))\n\n    results = []\n    for Ns, Np, dt, steps, tau, Q, init in tests:\n        ok = run_test(Ns, Np, dt, steps, tau, Q, init)\n        results.append(ok)\n\n    # Print single-line output as specified\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}