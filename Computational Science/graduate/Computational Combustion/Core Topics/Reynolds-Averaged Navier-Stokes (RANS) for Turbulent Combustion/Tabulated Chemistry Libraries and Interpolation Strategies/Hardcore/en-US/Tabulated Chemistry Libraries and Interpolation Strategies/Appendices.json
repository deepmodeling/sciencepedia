{
    "hands_on_practices": [
        {
            "introduction": "Before diving into the complex algorithms for interpolation, it is essential to appreciate the practical constraints that motivate the use of tabulated chemistry. One of the most significant factors is the memory footprint of the chemistry library. This exercise provides a foundational understanding of how the size of a chemistry table scales with the dimensions of the state space and the number of stored variables, grounding the abstract concept in concrete computational costs .",
            "id": "4070267",
            "problem": "In a computational combustion code that employs tabulated chemistry, the thermo-chemical state is represented on a two-dimensional uniform grid in mixture fraction $Z$ and a scalar progress variable $c$. Let the library have $N_{Z}$ nodes along $Z$ and $N_{c}$ nodes along $c$. At each grid node, the library stores the mass fractions $Y_{k}(Z,c)$ for $n_{s}$ chemical species and the temperature $T(Z,c)$. Assume all stored scalars are represented in double precision according to the Institute of Electrical and Electronics Engineers (IEEE) Standard $754$ binary $64$, with $b$ bytes per scalar. No additional metadata, padding, or precomputed interpolation coefficients are stored—only the nodal values of $Y_{k}$ and $T$.\n\nStarting from the definitions of a tabulated library and a uniform tensor-product grid, derive a general expression for the total memory footprint $M$ in bytes as a function of $N_{Z}$, $N_{c}$, $n_{s}$, and $b$. Then evaluate the total number of bytes for $N_{Z}=200$, $N_{c}=200$, $n_{s}=10$, and $b=8$. Express the final numerical answer in bytes. No rounding is required.",
            "solution": "The problem requires the derivation of a general expression for the total memory footprint, $M$, of a tabulated chemistry library and its subsequent evaluation for a specific set of parameters. The validation of the problem statement confirms that it is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution.\n\nFirst, we determine the total number of nodes in the computational grid. The problem states that the thermo-chemical state is represented on a two-dimensional uniform grid in mixture fraction $Z$ and a scalar progress variable $c$. The grid is defined by $N_Z$ nodes along the $Z$ direction and $N_c$ nodes along the $c$ direction. As a tensor-product grid, the total number of discrete points (nodes) in the state space, which we denote as $N_{\\text{nodes}}$, is the product of the number of nodes in each dimension:\n$$N_{\\text{nodes}} = N_Z N_c$$\n\nNext, we determine the number of scalar quantities stored at each grid node. The problem specifies that for each node $(Z,c)$, the library stores the mass fractions $Y_k(Z,c)$ for $n_s$ chemical species and the temperature $T(Z,c)$. This means there are $n_s$ scalar values for the mass fractions and $1$ scalar value for the temperature. The total number of scalars stored per node, denoted as $N_{\\text{scalars/node}}$, is therefore:\n$$N_{\\text{scalars/node}} = n_s + 1$$\n\nThe total number of scalar values stored in the entire library, $N_{\\text{total}}$, is the product of the total number of nodes and the number of scalars per node.\n$$N_{\\text{total}} = N_{\\text{nodes}} \\times N_{\\text{scalars/node}} = (N_Z N_c)(n_s + 1)$$\n\nFinally, we calculate the total memory footprint, $M$, in bytes. Each scalar quantity is represented in double precision (IEEE $754$ binary $64$), which occupies $b$ bytes of memory. The total memory footprint is the product of the total number of scalars and the size of each scalar in bytes.\n$$M(N_Z, N_c, n_s, b) = N_{\\text{total}} \\times b$$\nSubstituting the expression for $N_{\\text{total}}$, we arrive at the general expression for the memory footprint:\n$$M(N_Z, N_c, n_s, b) = N_Z N_c (n_s + 1) b$$\nThis is the required general formula.\n\nNow, we evaluate this expression for the given numerical values: $N_Z = 200$, $N_c = 200$, $n_s = 10$, and $b=8$ bytes (since a $64$-bit double precision float is $64/8 = 8$ bytes).\nSubstituting these values into the derived formula:\n$$M = (200)(200)(10 + 1)(8)$$\nFirst, calculate the total number of nodes:\n$$N_{\\text{nodes}} = 200 \\times 200 = 40000$$\nNext, calculate the number of scalars per node:\n$$N_{\\text{scalars/node}} = 10 + 1 = 11$$\nNow, compute the total memory footprint $M$:\n$$M = 40000 \\times 11 \\times 8$$\n$$M = 440000 \\times 8$$\n$$M = 3520000$$\nThe total memory footprint for the specified library is $3,520,000$ bytes.",
            "answer": "$$\\boxed{3520000}$$"
        },
        {
            "introduction": "With an understanding of a table's structure and size, the next step is to learn the core mechanism for retrieving data: interpolation. Since thermochemical states are often parameterized by multiple variables, such as mixture fraction and a progress variable, multi-dimensional interpolation is a fundamental skill. This practice guides you through a bilinear interpolation on a 2D grid and, critically, demonstrates how a properly constructed linear interpolation scheme preserves fundamental physical laws like the conservation of mass, ensuring that the interpolated state remains consistent .",
            "id": "4070273",
            "problem": "A tabulated chemistry library for a premixed flame is parameterized by the mixture fraction $Z$ and a progress variable $c$. In such libraries, every entry stores the temperature $T(Z,c)$ and a species mass fraction vector $Y(Z,c) = \\left(Y_{1}(Z,c), Y_{2}(Z,c), \\dots, Y_{N}(Z,c)\\right)$ with the property $\\sum_{i=1}^{N} Y_{i}(Z,c) = 1$. Consider a single structured grid cell in the $(Z,c)$-plane with corner coordinates $\\left(Z_{0}, c_{0}\\right) = \\left(0.10, 0.20\\right)$, $\\left(Z_{1}, c_{0}\\right) = \\left(0.30, 0.20\\right)$, $\\left(Z_{0}, c_{1}\\right) = \\left(0.10, 0.50\\right)$, and $\\left(Z_{1}, c_{1}\\right) = \\left(0.30, 0.50\\right)$. At these corners, the tabulated values are:\n- $\\left(Z_{0}, c_{0}\\right)$: $T = 1000$ and $Y = \\left(0.30, 0.60, 0.10\\right)$,\n- $\\left(Z_{0}, c_{1}\\right)$: $T = 1500$ and $Y = \\left(0.10, 0.40, 0.50\\right)$,\n- $\\left(Z_{1}, c_{0}\\right)$: $T = 1800$ and $Y = \\left(0.55, 0.35, 0.10\\right)$,\n- $\\left(Z_{1}, c_{1}\\right)$: $T = 2100$ and $Y = \\left(0.25, 0.25, 0.50\\right)$.\n\nAssume a query point $\\left(Z, c\\right) = \\left(0.22, 0.38\\right)$ that lies inside this cell. Starting from the fundamental definition that mass fractions satisfy $\\sum_{i=1}^{N} Y_{i} = 1$ and from the definition of linear interpolation along one dimension, derive a bilinear interpolation strategy for a rectangular cell that is consistent with linear shape functions along $Z$ and $c$. Using this strategy, compute the interpolated temperature $T$ and species mass fraction vector $Y$ at $\\left(Z, c\\right) = \\left(0.22, 0.38\\right)$. Then, verify that the interpolated species still satisfy $\\sum_{i=1}^{N} Y_{i} = 1$.\n\nExpress the final temperature in kelvin and the species mass fractions as dimensionless decimals. Round all reported numerical values to $4$ significant figures. Provide your final answer as the temperature followed by the species components of $Y$ in a single row vector.",
            "solution": "The problem requires the derivation of a bilinear interpolation strategy and its application to find the temperature $T$ and species mass fraction vector $Y$ at a specific point in the $(Z,c)$ plane.\n\n**1. Derivation of the Bilinear Interpolation Formula**\n\nLet $f(Z,c)$ be a scalar function defined on the rectangular cell with corners $(Z_0, c_0)$, $(Z_1, c_0)$, $(Z_0, c_1)$, and $(Z_1, c_1)$. Bilinear interpolation can be derived by performing two sequential linear interpolations.\n\nFirst, we perform linear interpolation along the $Z$-direction at the constant $c$ coordinates $c_0$ and $c_1$. Linear interpolation along one dimension, say $x$, between points $x_0$ and $x_1$ for a value $f(x)$ at a point $x$ is given by:\n$$f(x) = f(x_0) + \\frac{x-x_0}{x_1-x_0} (f(x_1) - f(x_0)) = (1-\\xi)f(x_0) + \\xi f(x_1)$$\nwhere $\\xi = \\frac{x-x_0}{x_1-x_0}$ is the normalized coordinate.\n\nApplying this along the $Z$-axis for a query point $Z$: Let $\\xi = \\frac{Z - Z_0}{Z_1 - Z_0}$. The interpolated value at $(Z, c_0)$ is:\n$$f(Z, c_0) \\approx (1-\\xi)f(Z_0, c_0) + \\xi f(Z_1, c_0)$$\nThe interpolated value at $(Z, c_1)$ is:\n$$f(Z, c_1) \\approx (1-\\xi)f(Z_0, c_1) + \\xi f(Z_1, c_1)$$\n\nNext, we perform linear interpolation along the $c$-direction using these two intermediate values. Let $\\eta = \\frac{c - c_0}{c_1 - c_0}$.\n$$f(Z, c) \\approx (1-\\eta)f(Z, c_0) + \\eta f(Z, c_1)$$\nSubstituting the expressions for $f(Z, c_0)$ and $f(Z, c_1)$ and expanding gives the bilinear interpolation formula:\n$$f(Z, c) \\approx (1-\\xi)(1-\\eta)f(Z_0, c_0) + \\xi(1-\\eta)f(Z_1, c_0) + (1-\\xi)\\eta f(Z_0, c_1) + \\xi\\eta f(Z_1, c_1)$$\nThis formula is a weighted average of the four corner values.\n\n**2. Calculation of Interpolated Values**\n\nFirst, calculate the normalized coordinates $(\\xi, \\eta)$ for the query point $(Z, c) = (0.22, 0.38)$.\nThe cell boundaries are $Z_0=0.10$, $Z_1=0.30$, $c_0=0.20$, and $c_1=0.50$.\n$$\\xi = \\frac{Z - Z_{0}}{Z_{1} - Z_{0}} = \\frac{0.22 - 0.10}{0.30 - 0.10} = \\frac{0.12}{0.20} = 0.6$$\n$$\\eta = \\frac{c - c_{0}}{c_{1} - c_{0}} = \\frac{0.38 - 0.20}{0.50 - 0.20} = \\frac{0.18}{0.30} = 0.6$$\n\nNext, calculate the interpolation weights:\n- Weight for $(Z_0, c_0)$: $w_{00} = (1-\\xi)(1-\\eta) = (1-0.6)(1-0.6) = 0.16$\n- Weight for $(Z_1, c_0)$: $w_{10} = \\xi(1-\\eta) = 0.6 \\times (1-0.6) = 0.24$\n- Weight for $(Z_0, c_1)$: $w_{01} = (1-\\xi)\\eta = (1-0.6) \\times 0.6 = 0.24$\n- Weight for $(Z_1, c_1)$: $w_{11} = \\xi\\eta = 0.6 \\times 0.6 = 0.36$\nThe sum of weights is $0.16 + 0.24 + 0.24 + 0.36 = 1.0$.\n\nNow, apply these weights to the tabulated values.\nFor temperature $T$:\n$$T(0.22, 0.38) = w_{00}T_{00} + w_{10}T_{10} + w_{01}T_{01} + w_{11}T_{11}$$\n$$T(0.22, 0.38) = (0.16)(1000) + (0.24)(1800) + (0.24)(1500) + (0.36)(2100) = 1708$$\nRounded to $4$ significant figures, the temperature is $1708$ K.\n\nFor the species mass fraction vector $Y = (Y_1, Y_2, Y_3)$, we apply the same interpolation to each component:\n$$Y(Z, c) = w_{00}Y_{00} + w_{10}Y_{10} + w_{01}Y_{01} + w_{11}Y_{11}$$\n\n- For $Y_1$: $Y_1(0.22, 0.38) = (0.16)(0.30) + (0.24)(0.55) + (0.24)(0.10) + (0.36)(0.25) = 0.294$.\n- For $Y_2$: $Y_2(0.22, 0.38) = (0.16)(0.60) + (0.24)(0.35) + (0.24)(0.40) + (0.36)(0.25) = 0.366$.\n- For $Y_3$: $Y_3(0.22, 0.38) = (0.16)(0.10) + (0.24)(0.10) + (0.24)(0.50) + (0.36)(0.50) = 0.340$.\n\nThe interpolated species mass fraction vector, rounded to 4 significant figures, is $Y = (0.2940, 0.3660, 0.3400)$.\n\n**3. Verification of Mass Fraction Conservation**\n\nTo verify that $\\sum Y_i = 1$, we can sum the components: $0.2940 + 0.3660 + 0.3400 = 1.0000$.\nThe property holds because the interpolation is a linear operation and the sum of the interpolation weights is 1. Let $Y_{i,jk}$ be the mass fraction of species $i$ at corner $(j,k)$. The interpolated value is $Y_i = \\sum_{j,k} w_{jk} Y_{i,jk}$. Summing over $i$:\n$$ \\sum_i Y_i = \\sum_i \\sum_{j,k} w_{jk} Y_{i,jk} = \\sum_{j,k} w_{jk} \\left(\\sum_i Y_{i,jk}\\right) $$\nSince $\\sum_i Y_{i,jk} = 1$ at each corner,\n$$ \\sum_i Y_i = \\sum_{j,k} w_{jk} (1) = 1 $$\nThis confirms that the bilinear interpolation scheme inherently preserves mass fraction conservation.\n\nThe final answer is $T=1708$, $Y_1=0.2940$, $Y_2=0.3660$, $Y_3=0.3400$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1708  0.2940  0.3660  0.3400 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "While linear interpolation is robust, higher-order methods like cubic splines are often desired for their smoothness ($C^1$ or $C^2$ continuity). However, unconstrained high-order interpolation can introduce non-physical artifacts, such as overshoots and undershoots, which violate thermodynamic principles. This hands-on coding exercise  allows you to directly confront this challenge by comparing a standard cubic spline with a shape-preserving monotone cubic interpolant (PCHIP), providing a clear demonstration of why advanced interpolation strategies are critical for building reliable and physically consistent chemistry libraries.",
            "id": "4070256",
            "problem": "You are given a one-dimensional ($1$-D) tabulated temperature profile representative of a reduced chemistry manifold in computational combustion, where the independent coordinate is a dimensionless mixture fraction $x$ and the dependent variable is temperature $T$ in Kelvin. In tabulated chemistry libraries, accurate and shape-preserving interpolation is essential to avoid nonphysical overshoot in $T(x)$ that can violate thermodynamic consistency.\n\nStarting from fundamental definitions, consider the following interpolation constructs:\n- A piecewise polynomial interpolant over subintervals $[x_i,x_{i+1}]$ that matches tabulated values $T_i = T(x_i)$.\n- A piecewise cubic Hermite representation with endpoint data $(x_i, T_i)$ and slopes $m_i = \\frac{dT}{dx}(x_i)$, assembled to form a globally class $C^1$ (once continuously differentiable) interpolant.\n- A shape-preserving monotone cubic strategy that enforces constraints on $\\{m_i\\}$ so that if $\\{T_i\\}$ is monotone on $[x_i,x_{i+1}]$, the interpolant stays within the local bounds $\\left[\\min(T_i,T_{i+1}), \\max(T_i,T_{i+1})\\right]$ on that subinterval.\n\nUse widely accepted facts:\n- A natural cubic spline without explicit shape constraints may overshoot when curvature changes abruptly, even for monotone data.\n- The Piecewise Cubic Hermite Interpolating Polynomial (PCHIP) uses constrained slopes derived from local secant slopes to preserve monotonicity and avoid overshoot while maintaining class $C^1$ continuity.\n\nYour task is to implement two interpolants for each test case:\n- An unconstrained cubic spline.\n- A monotone cubic spline using PCHIP.\n\nThen, for each test case, evaluate the following quantitative diagnostics:\n- Overshoot magnitude for an interpolant $f$ on the full domain: For each subinterval $[x_i,x_{i+1}]$, sample $N$ points $\\{s_k\\}$ uniformly in $[x_i,x_{i+1}]$ and compute the interval bounds $L_i = \\min(T_i,T_{i+1})$ and $U_i = \\max(T_i,T_{i+1})$. Define the interval overshoot as\n$$\nO_i(f) = \\max_{k}\\left(\\max\\left(0, f(s_k) - U_i\\right), \\max\\left(0, L_i - f(s_k)\\right)\\right),\n$$\nand the global overshoot magnitude as\n$$\nO(f) = \\max_i O_i(f).\n$$\nReturn $O(f)$ as a real-valued number in Kelvin.\n- Monotonicity check for the PCHIP interpolant $p$: On the full domain sampled at $M$ points, verify nondecreasing behavior,\n$$\np(x_{j+1}) - p(x_j) \\ge -\\varepsilon,\n$$\nfor a tolerance $\\varepsilon  0$. Return a boolean indicating whether this holds.\n- Class $C^1$ continuity check for the PCHIP interpolant $p$: For each interior knot $x_i$ with $i \\in \\{1, \\dots, n-2\\}$, evaluate the left and right derivatives using limits $p'(x_i^-)$ and $p'(x_i^+)$ by sampling at $x_i \\pm \\delta_i$ for a small $\\delta_i$ relative to local spacing. Verify\n$$\n\\left|p'(x_i^-) - p'(x_i^+)\\right| \\le \\tau,\n$$\nfor tolerance $\\tau  0$ at all interior knots. Return a boolean indicating whether this holds.\n\nPhysical units: Temperature must be handled in Kelvin and reported in Kelvin. The mixture fraction $x$ is dimensionless.\n\nAngle units are not applicable.\n\nThe test suite is as follows, with explicit tabulated coordinates and temperatures:\n- Test case $1$ (monotone with variable curvature): $x = [0.0, 0.1, 0.2, 0.4, 0.7, 1.0]$, $T = [300.0, 310.0, 400.0, 800.0, 1400.0, 1800.0]$ Kelvin.\n- Test case $2$ (plateau followed by a steep rise): $x = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]$, $T = [300.0, 300.0, 300.0, 800.0, 1200.0, 1200.0]$ Kelvin.\n- Test case $3$ (abrupt gradient near the end): $x = [0.0, 0.3, 0.31, 1.0]$, $T = [300.0, 330.0, 1600.0, 1800.0]$ Kelvin.\n\nFor numerical parameters, use $N = 1000$ samples per interval to compute overshoot, $M = 5000$ samples over the full domain for the monotonicity check, tolerance $\\varepsilon = 10^{-10}$ for monotonicity, and $\\tau = 10^{-9}$ for class $C^1$ continuity, and define $\\delta_i = 10^{-12} \\times (x_{i+1} - x_{i-1})$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of the list corresponds to a test case, and each test case result is a list aggregating the required diagnostics in the order specified:\n- For test case $1$: $[O(\\text{spline}), O(\\text{pchip}), \\text{is\\_monotone}]$.\n- For test case $2$: $[O(\\text{spline}), O(\\text{pchip}), \\text{is\\_C1}]$.\n- For test case $3$: $[O(\\text{spline}), O(\\text{pchip})]$.\n\nFor example, the final output must have the form $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3]]$, where $a_i$ and $b_i$ are real numbers in Kelvin and $c_i$ are booleans.",
            "solution": "We begin from the tabulation concept in computational combustion: a chemistry library maps a low-dimensional control variable, such as mixture fraction $x$, to thermochemical quantities, such as temperature $T$, as a function $T(x)$ sampled at knots $\\{(x_i, T_i)\\}_{i=0}^{n-1}$ with $x_0  x_1  \\dots  x_{n-1}$. Accurate interpolation must respect physical monotonicity and avoid nonphysical overshoot.\n\nFundamental definitions. A piecewise cubic Hermite interpolant on each subinterval $[x_i,x_{i+1}]$ is constructed as\n$$\np_i(x) = a_i (x-x_i)^3 + b_i (x-x_i)^2 + c_i (x-x_i) + d_i,\n$$\nwith endpoint conditions\n$$\np_i(x_i) = T_i, \\quad p_i(x_{i+1}) = T_{i+1}, \\quad p_i'(x_i) = m_i, \\quad p_i'(x_{i+1}) = m_{i+1}.\n$$\nChoosing the slopes $\\{m_i\\}$ and assembling $\\{p_i\\}$ yields a global interpolant $p(x)$ that is class $C^1$ if $p_i'(x_{i+1}) = p_{i+1}'(x_{i+1})$ for all interior knots. A natural cubic spline determines $\\{m_i\\}$ implicitly by minimizing an energy functional involving second derivatives, but does not enforce monotonicity; abrupt curvature changes can lead to overshoot beyond local bounds, producing unphysical temperatures.\n\nShape-preserving strategy. The Piecewise Cubic Hermite Interpolating Polynomial (PCHIP) enforces monotonicity by selecting $\\{m_i\\}$ from neighboring secant slopes. Define local spacings and secant slopes\n$$\nh_i = x_{i+1} - x_i, \\quad d_i = \\frac{T_{i+1} - T_i}{h_i}.\n$$\nFor interior knots with $i \\in \\{1,\\dots,n-2\\}$, the Fritsch–Carlson constraints set\n$$\nm_i =\n\\begin{cases}\n\\displaystyle \\frac{(h_{i-1} + h_i)}{\\frac{h_{i-1}}{d_{i-1}} + \\frac{h_i}{d_i}},  \\text{if } d_{i-1} d_i  0, \\\\\n0,  \\text{if } d_{i-1} d_i \\le 0,\n\\end{cases}\n$$\nwhich is a weighted harmonic mean of adjacent secant slopes when they have the same sign, and zero otherwise. Endpoint slopes $m_0$ and $m_{n-1}$ are computed from one-sided biased formulas that limit overshoot; specifically, $m_0$ and $m_{n-1}$ are chosen to be nonnegative combinations of adjacent $d$ values and clipped so as not to create new extrema. These constraints ensure that if $\\{T_i\\}$ is monotone on $[x_i,x_{i+1}]$, then $p(x)$ stays within the interval bounds $\\left[\\min(T_i,T_{i+1}), \\max(T_i,T_{i+1})\\right]$ while preserving class $C^1$ continuity, because the construction enforces matching derivatives at knots.\n\nDiagnostic definitions. To quantify overshoot, for each subinterval $[x_i,x_{i+1}]$ we sample $N$ points $\\{s_k\\}$ and define the bounds\n$$\nL_i = \\min(T_i, T_{i+1}), \\quad U_i = \\max(T_i, T_{i+1}),\n$$\nand measure the largest violation magnitude\n$$\nO_i(f) = \\max_k \\left( \\max(0, f(s_k) - U_i), \\max(0, L_i - f(s_k)) \\right).\n$$\nWe aggregate as\n$$\nO(f) = \\max_i O_i(f),\n$$\nwhich is in Kelvin and equals zero if the interpolant stays within local bounds everywhere.\n\nMonotonicity check for PCHIP is performed by sampling $M$ points $\\{x_j\\}$ and verifying\n$$\np(x_{j+1}) - p(x_j) \\ge -\\varepsilon\n$$\nfor a small tolerance $\\varepsilon$, returning a boolean indicating nondecreasing behavior. Because the PCHIP construction enforces monotone behavior on monotone data, this check should succeed on test cases where the tabulation itself is nondecreasing.\n\nClass $C^1$ continuity is evaluated at interior knots $x_i$ by comparing one-sided derivatives. Let $\\delta_i = 10^{-12} \\times (x_{i+1} - x_{i-1})$. We compute\n$$\np'(x_i^-) \\approx p'(x_i - \\delta_i), \\quad p'(x_i^+) \\approx p'(x_i + \\delta_i),\n$$\nand verify the tolerance\n$$\n\\left|p'(x_i^-) - p'(x_i^+)\\right| \\le \\tau\n$$\nfor a small $\\tau$, returning a boolean. The PCHIP interpolant is class $C^1$, so the check should pass up to numerical limits.\n\nAlgorithmic design. For each test case we:\n- Build an unconstrained cubic spline $s(x)$ and a PCHIP interpolant $p(x)$ from $(x_i, T_i)$.\n- Compute $O(s)$ and $O(p)$ using $N = 1000$ samples per interval.\n- For the first test case, check monotonicity of $p$ using $M = 5000$ samples and $\\varepsilon = 10^{-10}$.\n- For the second test case, check class $C^1$ continuity of $p$ by comparing one-sided derivatives at interior knots with $\\tau = 10^{-9}$ and $\\delta_i$ as defined.\n\nOutput specification. The program outputs a single line with a list of three entries, one per test case:\n- Test case $1$: $[O(s), O(p), \\text{is\\_monotone}]$.\n- Test case $2$: $[O(s), O(p), \\text{is\\_C1}]$.\n- Test case $3$: $[O(s), O(p)]$.\n\nScientific realism. The tabulated temperatures are representative of a combustion process with rising temperature as $x$ increases, including a plateau and a steep gradient that are known to challenge unconstrained cubic splines. The PCHIP constraints, derived from local secant slopes, maintain shape and class $C^1$ continuity while eliminating overshoot, which is critical for robust tabulated chemistry libraries.",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import CubicSpline, PchipInterpolator\n\ndef interval_overshoot(interp, x, T, n_samples=1000):\n    \"\"\"\n    Compute the maximum overshoot magnitude across all intervals for a given interpolator.\n    Overshoot is defined relative to local interval bounds [min(T_i,T_{i+1}), max(T_i,T_{i+1})].\n    Returns a float in Kelvin.\n    \"\"\"\n    max_overshoot = 0.0\n    for i in range(len(x) - 1):\n        xi, xip1 = x[i], x[i+1]\n        Ti, Tip1 = T[i], T[i+1]\n        lower = min(Ti, Tip1)\n        upper = max(Ti, Tip1)\n        # Sample within the interval, excluding endpoints to focus on interior overshoot\n        s = np.linspace(xi, xip1, n_samples, endpoint=True)\n        vals = interp(s)\n        # Overshoot above upper bound\n        above = np.maximum(0.0, vals - upper)\n        # Overshoot below lower bound\n        below = np.maximum(0.0, lower - vals)\n        interval_max = max(above.max(initial=0.0), below.max(initial=0.0))\n        if interval_max > max_overshoot:\n            max_overshoot = interval_max\n    return float(max_overshoot)\n\ndef check_monotone(interp, x_min, x_max, n_samples=5000, eps=1e-10):\n    \"\"\"\n    Check nondecreasing monotonicity of interpolant over [x_min, x_max] sampled at n_samples.\n    Returns a boolean.\n    \"\"\"\n    xs = np.linspace(x_min, x_max, n_samples, endpoint=True)\n    vals = interp(xs)\n    diffs = np.diff(vals)\n    # Allow a small negative tolerance due to numerical noise\n    return bool(np.all(diffs >= -eps))\n\ndef check_C1_continuity(pchip, x_knots, tau=1e-9):\n    \"\"\"\n    Check C1 continuity by comparing left and right derivatives at interior knots.\n    Uses small offsets relative to local spacing.\n    Returns a boolean.\n    \"\"\"\n    # Derivative interpolator\n    dp = pchip.derivative()\n    n = len(x_knots)\n    for i in range(1, n - 1):\n        # Determine local spacing to scale delta\n        h_left = x_knots[i] - x_knots[i-1]\n        h_right = x_knots[i+1] - x_knots[i]\n        h_local = h_left + h_right\n        delta = 1e-12 * h_local\n        x_i = x_knots[i]\n        # Ensure delta does not cross into neighboring intervals due to extremely small spacing\n        d_left = float(dp(x_i - delta))\n        d_right = float(dp(x_i + delta))\n        if abs(d_left - d_right) > tau:\n            return False\n    return True\n\ndef run_test_case(x, T):\n    \"\"\"\n    Build interpolators and compute overshoot metrics.\n    Returns (O_spline, O_pchip, extras) where extras may be a boolean or None depending on test case.\n    \"\"\"\n    # Build interpolators\n    spline = CubicSpline(x, T, bc_type='not-a-knot')\n    pchip = PchipInterpolator(x, T)\n    # Compute overshoot magnitudes\n    O_spline = interval_overshoot(spline, x, T, n_samples=1000)\n    O_pchip = interval_overshoot(pchip, x, T, n_samples=1000)\n    return spline, pchip, O_spline, O_pchip\n\ndef solve():\n    # Define test cases\n    test_cases = [\n        # Test case 1: Monotone with variable curvature\n        (np.array([0.0, 0.1, 0.2, 0.4, 0.7, 1.0]), np.array([300.0, 310.0, 400.0, 800.0, 1400.0, 1800.0])),\n        # Test case 2: Plateau then steep rise\n        (np.array([0.0, 0.2, 0.4, 0.6, 0.8, 1.0]), np.array([300.0, 300.0, 300.0, 800.0, 1200.0, 1200.0])),\n        # Test case 3: Abrupt gradient near the end\n        (np.array([0.0, 0.3, 0.31, 1.0]), np.array([300.0, 330.0, 1600.0, 1800.0])),\n    ]\n\n    results = []\n\n    # Test case 1\n    x1, T1 = test_cases[0]\n    spline1, pchip1, O_spline1, O_pchip1 = run_test_case(x1, T1)\n    # Monotonicity check for PCHIP\n    is_monotone1 = check_monotone(pchip1, float(x1[0]), float(x1[-1]), n_samples=5000, eps=1e-10)\n    results.append([O_spline1, O_pchip1, is_monotone1])\n\n    # Test case 2\n    x2, T2 = test_cases[1]\n    spline2, pchip2, O_spline2, O_pchip2 = run_test_case(x2, T2)\n    # C1 continuity check for PCHIP at knots\n    is_C1_2 = check_C1_continuity(pchip2, x2, tau=1e-9)\n    results.append([O_spline2, O_pchip2, is_C1_2])\n\n    # Test case 3\n    x3, T3 = test_cases[2]\n    spline3, pchip3, O_spline3, O_pchip3 = run_test_case(x3, T3)\n    results.append([O_spline3, O_pchip3])\n\n    # Final print in exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}