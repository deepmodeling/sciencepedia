{
    "hands_on_practices": [
        {
            "introduction": "在我们对混合分数 $Z$ 进行统计建模之前，我们必须首先理解其物理定义。本练习将带您回到化学的第一性原理，要求您从元素质量守恒推导出化学计量混合分数 $Z_{st}$。 这项实践巩固了抽象变量 $Z$ 与燃烧这一具体物理过程之间的联系。",
            "id": "4009873",
            "problem": "考虑一个用于混合分数的假定Beta概率密度函数(PDF)模型的典型非预混燃烧结构，该结构涉及两股逆向流动的流股。流股$1$是燃料侧流股，流股$2$是氧化剂侧流股。设混合分数$Z$定义为局部混合物中源于流股$1$的物质的质量分数，因此在通常的相等扩散系数和直至化学计量表面的非反应性混合的假设下，混合物中每种元素$E\\in\\{C,H,O\\}$的元素质量分数满足$W_{E}(Z)=Z\\,W_{E}^{(1)}+(1-Z)\\,W_{E}^{(2)}$。假设燃料中的碳和氢完全氧化为二氧化碳和水，并忽略氮和次要组分在化学计量平衡中的参与。用$M_{C}$、$M_{H}$和$M_{O}$分别表示碳、氢和氧的原子质量。\n\n从元素守恒和在化学计量比下混合反应物中存在的氧气恰好等于将所有碳和氢转化为完全氧化产物所需氧气的要求出发，推导化学计量混合分数$Z_{st}$关于流股$i=1,2$的元素质量分数$W_{C}^{(i)}$、$W_{H}^{(i)}$、$W_{O}^{(i)}$以及原子质量$M_{C}$、$M_{H}$、$M_{O}$的闭式解析表达式。您的最终表达式必须是单一的闭式公式。答案表达时无需进行数值计算，也无需带单位。",
            "solution": "该问题要求基于元素守恒原理推导化学计量混合分数$Z_{st}$的闭式表达式。该问题具有科学依据，提法恰当，并包含了求解所需的所有信息。我们将开始推导。\n\n混合分数$Z$定义为源于燃料流股（流股$1$）的物质的质量分数。混合物中任意元素$E$的元素质量分数$W_E$由其在燃料流股$W_E^{(1)}$和氧化剂流股$W_E^{(2)}$中的质量分数的线性组合给出：\n$$W_{E}(Z) = Z W_{E}^{(1)} + (1-Z) W_{E}^{(2)}$$\n考虑的元素是碳($C$)、氢($H$)和氧($O$)。\n\n化学计量条件定义为反应物中存在的氧气量恰好等于将所有碳完全氧化为二氧化碳($\\text{CO}_2$)、将所有氢完全氧化为水($\\text{H}_2\\text{O}$)所需的氧气量。让我们用数学方式表达这一条件。\n\n首先，我们确定每单位质量的燃料元素所需的氧气质量。\n1.  对于碳($C$)：完全氧化反应为 $C + O_2 \\rightarrow \\text{CO}_2$。在原子质量的基础上，一个质量为$M_C$的碳原子与两个总质量为$2 M_O$的氧原子反应。因此，每单位质量的碳所需的氧气质量为比率$\\frac{2 M_O}{M_C}$。\n\n2.  对于氢($H$)：完全氧化反应为 $2H_2 + O_2 \\rightarrow 2\\text{H}_2\\text{O}$。在原子基础上，两个总质量为$2 M_H$的氢原子与一个质量为$M_O$的氧原子反应。因此，每单位质量的氢所需的氧气质量为比率$\\frac{M_O}{2 M_H}$。\n\n现在，考虑在化学计量条件下单位质量的混合物，此时混合分数为$Z_{st}$。在该单位质量中，碳和氢的质量分数分别为$W_C(Z_{st})$和$W_H(Z_{st})$。该单位质量混合物中的燃料元素完全燃烧所需的总氧气质量为：\n$$m_{O, \\text{required}} = W_C(Z_{st}) \\left( \\frac{2 M_O}{M_C} \\right) + W_H(Z_{st}) \\left( \\frac{M_O}{2 M_H} \\right)$$\n在同单位质量的混合物中，反应物中可用的氧气质量就是氧的元素质量分数$W_O(Z_{st})$：\n$$m_{O, \\text{available}} = W_O(Z_{st})$$\n根据定义，在化学计量比下，可用氧等于所需氧：\n$$m_{O, \\text{available}} = m_{O, \\text{required}}$$\n$$W_O(Z_{st}) = W_C(Z_{st}) \\left( \\frac{2 M_O}{M_C} \\right) + W_H(Z_{st}) \\left( \\frac{M_O}{2 M_H} \\right)$$\n这个方程可以重新整理，将化学计量表面定义为元素质量分数的特定线性组合为零的轨迹：\n$$W_C(Z_{st}) \\left( \\frac{2 M_O}{M_C} \\right) + W_H(Z_{st}) \\left( \\frac{M_O}{2 M_H} \\right) - W_O(Z_{st}) = 0$$\n\n接下来，我们将用$Z_{st}$表示的元素质量分数的定义代入这个化学计量条件：\n$$\\left[ Z_{st}W_C^{(1)} + (1-Z_{st})W_C^{(2)} \\right] \\left( \\frac{2 M_O}{M_C} \\right) + \\left[ Z_{st}W_H^{(1)} + (1-Z_{st})W_H^{(2)} \\right] \\left( \\frac{M_O}{2 M_H} \\right) - \\left[ Z_{st}W_O^{(1)} + (1-Z_{st})W_O^{(2)} \\right] = 0$$\n为了解出$Z_{st}$，我们可以将与$Z_{st}$和$(1-Z_{st})$相关的项分组：\n$$Z_{st} \\left[ W_C^{(1)} \\left( \\frac{2 M_O}{M_C} \\right) + W_H^{(1)} \\left( \\frac{M_O}{2 M_H} \\right) - W_O^{(1)} \\right] + (1-Z_{st}) \\left[ W_C^{(2)} \\left( \\frac{2 M_O}{M_C} \\right) + W_H^{(2)} \\left( \\frac{M_O}{2 M_H} \\right) - W_O^{(2)} \\right] = 0$$\n让我们为每个流股$i \\in \\{1, 2\\}$定义一个辅助变量$\\Phi_i$，它代表该流股的化学计量需氧量（如果为负则表示氧气过剩）：\n$$\\Phi_i = W_C^{(i)} \\left( \\frac{2 M_O}{M_C} \\right) + W_H^{(i)} \\left( \\frac{M_O}{2 M_H} \\right) - W_O^{(i)}$$\n有了此定义，化学计量条件简化为：\n$$Z_{st} \\Phi_1 + (1-Z_{st}) \\Phi_2 = 0$$\n这是一个关于$Z_{st}$的线性方程，我们现在可以求解它：\n$$Z_{st} \\Phi_1 + \\Phi_2 - Z_{st} \\Phi_2 = 0$$\n$$Z_{st} (\\Phi_1 - \\Phi_2) = -\\Phi_2$$\n$$Z_{st} = \\frac{-\\Phi_2}{\\Phi_1 - \\Phi_2}$$\n最后，我们将$\\Phi_1$和$\\Phi_2$的表达式代回该结果，以获得$Z_{st}$的最终闭式表达式。\n分子是：\n$$-\\Phi_2 = -\\left[ W_C^{(2)} \\left( \\frac{2 M_O}{M_C} \\right) + W_H^{(2)} \\left( \\frac{M_O}{2 M_H} \\right) - W_O^{(2)} \\right] = W_O^{(2)} - W_C^{(2)} \\left( \\frac{2 M_O}{M_C} \\right) - W_H^{(2)} \\left( \\frac{M_O}{2 M_H} \\right)$$\n分母是：\n$$\\Phi_1 - \\Phi_2 = \\left[ W_C^{(1)} \\left( \\frac{2 M_O}{M_C} \\right) + W_H^{(1)} \\left( \\frac{M_O}{2 M_H} \\right) - W_O^{(1)} \\right] - \\left[ W_C^{(2)} \\left( \\frac{2 M_O}{M_C} \\right) + W_H^{(2)} \\left( \\frac{M_O}{2 M_H} \\right) - W_O^{(2)} \\right]$$\n$$= \\left( W_C^{(1)} - W_C^{(2)} \\right) \\left( \\frac{2 M_O}{M_C} \\right) + \\left( W_H^{(1)} - W_H^{(2)} \\right) \\left( \\frac{M_O}{2 M_H} \\right) - \\left( W_O^{(1)} - W_O^{(2)} \\right)$$\n结合这些即可得到化学计量混合分数的完整表达式。",
            "answer": "$$\n\\boxed{\nZ_{st} = \\frac{W_O^{(2)} - W_C^{(2)} \\left( \\frac{2 M_O}{M_C} \\right) - W_H^{(2)} \\left( \\frac{M_O}{2 M_H} \\right)}{\\left( W_C^{(1)} - W_C^{(2)} \\right) \\left( \\frac{2 M_O}{M_C} \\right) + \\left( W_H^{(1)} - W_H^{(2)} \\right) \\left( \\frac{M_O}{2 M_H} \\right) - \\left( W_O^{(1)} - W_O^{(2)} \\right)}\n}\n$$"
        },
        {
            "introduction": "$\\beta$-PDF 由两个形状参数定义，但在计算流体力学中，我们处理的是它的均值和方差。本练习探讨了这两种表示之间至关重要的数学关系。 通过推导给定均值下有效的方差范围，您将更深入地理解模型的约束条件及其在极端但物理上相关的极限情况下的行为。",
            "id": "4009909",
            "problem": "在计算燃烧学中，守恒标量混合分数 $Z$ 通常在有界区间 $[0,1]$ 上被建模为贝塔概率密度函数 (Beta Probability Density Function, PDF)，用以表示亚格子脉动。令 $Z \\in [0,1]$ 的均值为 $\\mu \\in (0,1)$，方差为 $\\sigma^{2} \\ge 0$。贝塔概率密度函数 (Beta-PDF) 的参数形式为\n$$\nf_{Z}(z;a,b) = \\frac{z^{a-1} (1 - z)^{b-1}}{B(a,b)}, \\quad z \\in [0,1],\n$$\n其中形状参数 $a > 0$ 和 $b > 0$，$B(a,b)$ 为贝塔函数。在混合分数建模中，要求贝塔概率密度函数能够再现指定的 $\\mu$ 和 $\\sigma^{2}$，并且 $f_{Z}$ 是一个有效的概率密度函数（非负、归一化、在内部点上有限，且在 $[0,1]$ 上可积）。\n\n从贝塔概率密度函数的定义、$Z$ 的有界支撑集及其均值和方差关于形状参数的经过充分检验的表达式出发，推导在给定 $\\mu \\in (0,1)$ 以及约束条件 $a > 0$ 和 $b > 0$ 下，方差 $\\sigma^{2}$ 的容许范围。然后，研究在保持 $\\sigma^{2}$ 为有限值（且独立于 $\\mu$）的情况下 $\\mu \\to 0$ 的极限情形，并判断这样的 $\\sigma^{2}$ 是否被允许。如果不被允许，确定当 $\\mu \\to 0$ 时 $\\sigma^{2}$ 的极限容许值。此外，基于形状参数的极限值，定性描述在 $z=0$ 和 $z=1$ 附近产生的高度偏斜的贝塔概率密度函数的特征（例如，是否出现可积奇点以及质量集中在哪里）。\n\n将 $\\sigma^{2}$ 的极限容许值报告为单个无单位的数字。无需四舍五入。",
            "solution": "问题要求推导具有给定均值 $\\mu$ 的贝塔分布随机变量 $Z$ 的方差 $\\sigma^2$ 的容许范围，分析 $\\mu \\to 0$ 时的极限情况，并描述最终的概率密度函数 (PDF)。\n\n混合分数 $Z \\in [0,1]$ 的贝塔概率密度函数 (Beta-PDF) 由下式给出：\n$$\nf_{Z}(z;a,b) = \\frac{z^{a-1} (1 - z)^{b-1}}{B(a,b)}\n$$\n其中 $a > 0$ 和 $b > 0$ 是形状参数，$B(a,b)$ 是贝塔函数。\n\n$Z$ 的均值 $\\mu$ 和方差 $\\sigma^2$ 通过标准表达式与形状参数 $a$ 和 $b$ 相关联：\n$$\n\\mu = \\mathrm{E}[Z] = \\frac{a}{a+b}\n$$\n$$\n\\sigma^2 = \\mathrm{Var}[Z] = \\frac{ab}{(a+b)^2 (a+b+1)}\n$$\n问题规定 $\\mu \\in (0,1)$ 且 $\\sigma^2 \\ge 0$。一个有效的贝塔PDF的约束条件是 $a > 0$ 和 $b > 0$。\n\n**1. 方差 $\\sigma^2$ 的容许范围**\n\n第一步是用给定的均值 $\\mu$ 和方差 $\\sigma^2$ 来表示参数 $a$ 和 $b$。这使我们能将对 $a$ 和 $b$ 的约束转化为对 $\\sigma^2$ 的约束。\n\n从均值的表达式，我们可以写出 $1 - \\mu$：\n$$\n1 - \\mu = 1 - \\frac{a}{a+b} = \\frac{b}{a+b}\n$$\n方差可以用 $\\mu$ 和 $1-\\mu$ 重新表示：\n$$\n\\sigma^2 = \\left(\\frac{a}{a+b}\\right) \\left(\\frac{b}{a+b}\\right) \\frac{1}{a+b+1} = \\frac{\\mu(1-\\mu)}{a+b+1}\n$$\n对于非退化分布 ($\\sigma^2 > 0$)，我们可以解出 $a+b$ 的和：\n$$\na+b+1 = \\frac{\\mu(1-\\mu)}{\\sigma^2} \\implies a+b = \\frac{\\mu(1-\\mu)}{\\sigma^2} - 1\n$$\n现在我们可以分别解出 $a$ 和 $b$：\n$$\na = \\mu(a+b) = \\mu \\left( \\frac{\\mu(1-\\mu)}{\\sigma^2} - 1 \\right)\n$$\n$$\nb = (1-\\mu)(a+b) = (1-\\mu) \\left( \\frac{\\mu(1-\\mu)}{\\sigma^2} - 1 \\right)\n$$\n一个有效的贝塔PDF的条件是 $a > 0$ 和 $b > 0$。由于 $\\mu \\in (0,1)$，$\\mu$ 和 $1-\\mu$ 都是正数。因此，条件 $a > 0$ 和 $b > 0$ 等价于单个条件：\n$$\n\\frac{\\mu(1-\\mu)}{\\sigma^2} - 1 > 0\n$$\n$$\n\\frac{\\mu(1-\\mu)}{\\sigma^2} > 1\n$$\n由于 $\\sigma^2 \\ge 0$ (方差不能为负) 且 $\\mu(1-\\mu) > 0$，我们可以乘以 $\\sigma^2$ (假设 $\\sigma^2 \\ne 0$) 而不改变不等号方向：\n$$\n\\sigma^2  \\mu(1-\\mu)\n$$\n结合方差的非负性，对于给定的均值 $\\mu \\in (0,1)$，$\\sigma^2$ 的容许范围是：\n$$\n0 \\le \\sigma^2  \\mu(1-\\mu)\n$$\n$\\sigma^2=0$ 的情况对应于一个退化分布（在 $Z=\\mu$ 处的一个狄拉克δ函数），这是 $a,b \\to \\infty$ 时的极限。上界 $\\sigma^2 = \\mu(1-\\mu)$ 对应于一个两点伯努利分布，这在 $a,b > 0$ 的意义上不是一个贝塔PDF（它是 $a,b \\to 0$ 时的极限）。\n\n**2. 极限情况分析**\n\n问题要求研究在保持 $\\sigma^2$ 有限且独立于 $\\mu$ 的情况下 $\\mu \\to 0$ 的情形。让我们假设 $\\sigma^2=C$，其中 $C$ 是一个正常数。要使这种情况被允许，必须满足上面推导出的条件 $\\sigma^2  \\mu(1-\\mu)$。\n$$\nC  \\mu(1-\\mu)\n$$\n当我们取极限 $\\mu \\to 0^+$ 时，不等式的右侧趋近于 $0$：\n$$\n\\lim_{\\mu \\to 0^+} \\mu(1-\\mu) = 0\n$$\n这将意味着 $C \\le 0$。然而，我们假设 $C$ 是一个正常数 ($\\sigma^2 > 0$)。这是一个矛盾。因此，当均值 $\\mu$ 趋近于 $0$ 时，将方差 $\\sigma^2$ 保持为一个有限正常数是**不被允许**的。在此极限下，唯一允许的 $\\sigma^2$ 的有限常数值是 $\\sigma^2 = 0$。\n\n题目接着询问当 $\\mu \\to 0$ 时 $\\sigma^2$ 的**极限容许值**。这可以被解释为对于给定的 $\\mu$，最大可能方差的极限。最大容许方差（容许范围的上确界）是 $\\sigma^2_{max}(\\mu) = \\mu(1-\\mu)$。取 $\\mu \\to 0$ 的极限：\n$$\n\\lim_{\\mu \\to 0^+} \\sigma^2_{max}(\\mu) = \\lim_{\\mu \\to 0^+} \\mu(1-\\mu) = 0\n$$\n因此，当 $\\mu \\to 0$ 时，$\\sigma^2$ 的极限容许值是 $0$。\n\n**3. 极限PDF形状的定性描述**\n\n为了分析当 $\\mu \\to 0$ 时非退化分布的PDF形状，$\\sigma^2$ 也必须趋近于 $0$。在燃烧模型中，处理此极限的一种具有物理意义的方法是，将归一化方差 $g = \\frac{\\sigma^2}{\\mu(1-\\mu)}$ 视为一个常数，其中 $g \\in (0,1)$。这意味着对于小的 $\\mu$，$\\sigma^2$ 与 $\\mu$ 呈线性关系。\n\n将 $g$ 代入 $a$ 和 $b$ 的表达式中：\n$$\na+b = \\frac{1}{g} - 1 = \\frac{1-g}{g}\n$$\n$$\na = \\mu \\frac{1-g}{g}\n$$\n$$\nb = (1-\\mu) \\frac{1-g}{g}\n$$\n现在，我们考察当 $\\mu \\to 0^+$ 时 $a$ 和 $b$ 的极限，同时保持 $g \\in (0,1)$ 为常数：\n$$\n\\lim_{\\mu \\to 0^+} a = \\lim_{\\mu \\to 0^+} \\left( \\mu \\frac{1-g}{g} \\right) = 0\n$$\n由于 $a$ 必须为正，我们有 $a \\to 0^+$。\n$$\n\\lim_{\\mu \\to 0^+} b = \\lim_{\\mu \\to 0^+} \\left( (1-\\mu) \\frac{1-g}{g} \\right) = \\frac{1-g}{g}\n$$\n$b$ 的极限值是一个有限正常数，我们称之为 $b_0 = (1-g)/g > 0$。\n\n贝塔PDF为 $f_Z(z; a,b) \\propto z^{a-1}(1-z)^{b-1}$。\n*   **在 $z=0$ 附近的行为**：当 $a \\to 0^+$ 时，指数 $a-1$ 从上方趋近于 $-1$。项 $z^{a-1}$ 在 $z=0$ 处导致一个**可积奇点**。PDF在原点处变得无界。\n*   **在 $z=1$ 附近的行为**：当 $b \\to b_0 > 0$ 时，项 $(1-z)^{b-1}$ 表现良好。\n    *   如果 $b_0 > 1$ (即 $g  1/2$)，PDF在 $z=1$ 处趋于 $0$。\n    *   如果 $b_0 = 1$ (即 $g = 1/2$)，PDF在 $z=1$ 处趋于一个有限正常数。\n    *   如果 $0  b_0  1$ (即 $g > 1/2$)，PDF在 $z=1$ 处有另一个可积奇点。\n*   **质量集中**：由于均值 $\\mu = a/(a+b) \\to 0 / (0+b_0) = 0$，分布的概率质量完全集中在 $z=0$ 附近。在 $z=0$ 处的强奇点反映了这种极端的偏斜性。\n\n总之，当 $\\mu \\to 0$ 时（伴随 $\\sigma^2$ 作相应的缩放），贝塔PDF变成一个高度偏斜的分布，在 $z=0$ 处有一个可积奇点，这表明 $Z$ 的最可能值无限接近于 $0$。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "假定-PDF 建模的核心任务是计算化学源项的 Favre 平均值，这涉及到对 $\\beta$-PDF 进行积分。这个编程练习将指导您设计并实现一种高效的数值方法——高斯-雅可比求积法，该方法专为这项任务量身定制。 掌握这项技术是精确封闭湍流反应速率模型的关键计算技能。",
            "id": "4009851",
            "problem": "考虑一个守恒标量混合分数 $Z$，其定义域为区间 $[0,1]$。在湍流反应流中，其统计变化由 Beta 概率密度函数 (PDF) 建模，形状参数为 $\\alpha \\in \\mathbb{R}_{0}$ 和 $\\beta \\in \\mathbb{R}_{0}$。Beta-PDF 建模中的核心数值任务是反复计算以下形式的加权积分：\n$$\n\\int_{0}^{1} f(Z)\\,Z^{\\alpha-1}(1-Z)^{\\beta-1}\\,\\mathrm{d}Z,\n$$\n其中，光滑函数 $f$ 代表热化学性质映射、列表格封闭项或解析函数。您的目标是设计一种高斯型求积格式，该格式利用在适当权重下的正交性来高效、准确地计算上述表达式。\n\n从正交多项式和高斯求积在具有非负权函数的有限区间上的基本定义出发，仅使用保持权重的变量替换和多项式精度的性质，推导一个适用于区间 $[0,1]$ 上权重 $w(Z)=Z^{\\alpha-1}(1-Z)^{\\beta-1}$ 的 $n$ 点求积法。解释求积节点和权重是如何由正交性决定的，为什么这种构造对于 Beta 加权积分是高效的，以及当 $\\alpha$ 和 $\\beta$ 在大范围变化时（包括当 $\\alpha  1$ 或 $\\beta  1$ 时出现的可积端点奇点），区间映射如何确保数值稳定性。请勿在问题陈述中使用或引用任何预先推导的快捷公式；您的方法应基于第一性原理和关于正交多项式的经过验证的事实。\n\n然后，将推导出的方案实现为一个程序，该程序针对指定的测试套件，为每个案例计算积分的求积近似值，将其与参考值进行比较，并返回绝对误差。对于那些根据 Beta 函数 $\\mathrm{B}(\\cdot,\\cdot)$ 的基本性质可以知道其精确积分的测试案例，请使用该精确值作为参考。否则，请使用高精度一维数值积分方法在 $[0,1]$ 上对被积函数 $f(Z)\\,Z^{\\alpha-1}(1-Z)^{\\beta-1}$ 进行计算以获得参考值。当出现三角函数时，角度应解释为弧度。\n\n实现以下测试套件，每个案例由 $(\\alpha,\\beta,n,f)$ 指定，其中 $n$ 是求积阶数，$f$ 是被积函数：\n- 案例 1：$(\\alpha,\\beta,n,f)=(2,5,3, f(Z)=1)$；参考值为 $\\mathrm{B}(2,5)$。\n- 案例 2：$(\\alpha,\\beta,n,f)=(0.7,1.3,2, f(Z)=Z^{3})$；参考值为 $\\mathrm{B}(0.7+3,1.3)$。\n- 案例 3：$(\\alpha,\\beta,n,f)=(3.5,4.0,8, f(Z)=\\exp(-7Z))$；使用高精度数值积分。\n- 案例 4：$(\\alpha,\\beta,n,f)=(0.3,0.6,12, f(Z)=\\sqrt{Z})$；使用高精度数值积分。\n- 案例 5：$(\\alpha,\\beta,n,f)=(50.0,50.0,16, f(Z)=\\sin(\\pi Z))$；使用高精度数值积分，角度为弧度。\n- 案例 6：$(\\alpha,\\beta,n,f)=(80.0,3.0,16, f(Z)=\\frac{Z^{2}}{0.1+Z})$；使用高精度数值积分。\n\n您的程序必须产生单行输出，其中包含六个测试案例的绝对误差，格式为逗号分隔的列表并用方括号括起（例如，“[e1,e2,e3,e4,e5,e6]”）。不涉及物理单位，所有量均为无量纲。程序必须是自包含的，并且不得读取任何输入。",
            "solution": "该问题要求推导并实现一种针对 Beta 概率密度函数 (PDF) 加权积分的定制高斯求积格式。该积分的形式为：\n$$\nI = \\int_{0}^{1} f(Z)\\,Z^{\\alpha-1}(1-Z)^{\\beta-1}\\,\\mathrm{d}Z\n$$\n其中 $Z^{\\alpha-1}(1-Z)^{\\beta-1}$ 是 Beta 分布 PDF 的核心部分，$f(Z)$ 是一个光滑函数。\n\n该解决方案的基础在于高斯求积理论。对于形式为 $\\int_{a}^{b} g(x)w(x)\\,\\mathrm{d}x$ 且具有非负权函数 $w(x)$ 的积分，一个 $n$ 点高斯求积提供了一个近似：\n$$\n\\int_{a}^{b} g(x)w(x)\\,\\mathrm{d}x \\approx \\sum_{i=1}^{n} w_i g(x_i)\n$$\n构造此求积法则使其对于任何次数最高为 $2n-1$ 的多项式函数 $g(x)$ 都是精确的。当求积节点 $\\{x_i\\}_{i=1}^n$ 被选为 $n$ 次多项式 $P_n(x)$ 的根时，可以达到这种最高精度阶。该多项式 $P_n(x)$ 来自一个多项式序列 $\\{P_k(x)\\}_{k=0}^{\\infty}$，这些多项式在区间 $[a,b]$ 上关于权函数 $w(x)$ 正交。也就是说，对于 $k \\neq j$，它们满足 $\\int_{a}^{b} P_k(x)P_j(x)w(x)\\,\\mathrm{d}x = 0$。然后，权重 $\\{w_i\\}_{i=1}^n$ 由这些节点唯一确定。\n\n在我们的问题中，区间是 $[0,1]$，权函数是 $w(Z) = Z^{\\alpha-1}(1-Z)^{\\beta-1}$。与此权函数和区间相关的正交多项式是移位的雅可比多项式的一种形式。标准的雅可比多项式，记为 $P_n^{(a,b)}(x)$，在区间 $[-1,1]$ 上关于权函数 $(1-x)^a(1+x)^b$ 是正交的。为了利用已有的成熟算法来计算高斯-雅可比求积的节点和权重，我们进行变量替换，将我们的积分从 $[0,1]$ 映射到 $[-1,1]$。\n\n我们应用线性变换 $Z = \\frac{x+1}{2}$。这将区间 $x \\in [-1,1]$ 映射到 $Z \\in [0,1]$。微分元为 $\\mathrm{d}Z = \\frac{1}{2}\\mathrm{d}x$。将此代入我们的积分 $I$：\n$$\nI = \\int_{-1}^{1} f\\left(\\frac{x+1}{2}\\right) \\left(\\frac{x+1}{2}\\right)^{\\alpha-1} \\left(1-\\frac{x+1}{2}\\right)^{\\beta-1} \\frac{1}{2}\\,\\mathrm{d}x\n$$\n简化各项：\n$$\n1 - \\frac{x+1}{2} = \\frac{2 - (x+1)}{2} = \\frac{1-x}{2}\n$$\n积分变为：\n$$\nI = \\int_{-1}^{1} f\\left(\\frac{x+1}{2}\\right) \\frac{(x+1)^{\\alpha-1}}{2^{\\alpha-1}} \\frac{(1-x)^{\\beta-1}}{2^{\\beta-1}} \\frac{1}{2}\\,\\mathrm{d}x\n$$\n$$\nI = \\frac{1}{2^{\\alpha+\\beta-1}} \\int_{-1}^{1} f\\left(\\frac{x+1}{2}\\right) (1-x)^{\\beta-1}(1+x)^{\\alpha-1}\\,\\mathrm{d}x\n$$\n这个变换后的积分现在是适合在区间 $[-1,1]$ 上进行标准高斯-雅可比求积的形式。被积函数是 $g(x) = f\\left(\\frac{x+1}{2}\\right)$，权函数是 $(1-x)^{\\beta-1}(1+x)^{\\alpha-1}$。这对应于标准雅可比权重 $(1-x)^a(1+x)^b$，其参数为 $a = \\beta-1$ 和 $b = \\alpha-1$。\n\n令 $\\{x_i^{\\text{GJ}}\\}_{i=1}^n$ 为节点，$\\{w_i^{\\text{GJ}}\\}_{i=1}^n$ 为参数为 $a=\\beta-1$ 和 $b=\\alpha-1$ 的 $n$ 点高斯-雅可比求积的权重。节点 $x_i^{\\text{GJ}}$ 是雅可比多项式 $P_n^{(\\beta-1, \\alpha-1)}(x)$ 的根。在 $[-1,1]$ 上的积分的求积近似为：\n$$\n\\int_{-1}^{1} g(x)(1-x)^{\\beta-1}(1+x)^{\\alpha-1}\\,\\mathrm{d}x \\approx \\sum_{i=1}^{n} w_i^{\\text{GJ}} g(x_i^{\\text{GJ}})\n$$\n代入我们的函数 $g(x) = f\\left(\\frac{x+1}{2}\\right)$ 并与缩放因子结合，我们得到原始积分 $I$ 的近似值：\n$$\nI \\approx \\frac{1}{2^{\\alpha+\\beta-1}} \\sum_{i=1}^{n} w_i^{\\text{GJ}} f\\left(\\frac{x_i^{\\text{GJ}}+1}{2}\\right)\n$$\n这个公式提供了一个完整的算法。然而，从概念上讲，直接为目标区间 $[0,1]$ 和 Beta-PDF 权重定义一组节点 $\\{Z_i\\}_{i=1}^n$ 和权重 $\\{w_i^{\\text{B}}\\}_{i=1}^n$ 会更清晰。节点就是映射后的雅可比节点：\n$$\nZ_i = \\frac{x_i^{\\text{GJ}}+1}{2}\n$$\n在 $[0,1]$ 上的积分对应的权重是缩放后的雅可比权重：\n$$\nw_i^{\\text{B}} = \\frac{w_i^{\\text{GJ}}}{2^{\\alpha+\\beta-1}}\n$$\n这种缩放确保了正确性。例如，对于 $f(Z)=1$，积分为 $\\mathrm{B}(\\alpha,\\beta)$。标准雅可比权重之和为 $\\sum w_i^{\\text{GJ}} = \\int_{-1}^1 (1-x)^{\\beta-1}(1+x)^{\\alpha-1}\\,\\mathrm{d}x = 2^{\\alpha+\\beta-1}\\mathrm{B}(\\alpha,\\beta)$。我们的求积法则给出 $\\sum w_i^{\\text{B}} \\cdot 1 = \\frac{1}{2^{\\alpha+\\beta-1}}\\sum w_i^{\\text{GJ}} = \\mathrm{B}(\\alpha,\\beta)$，这正如所要求的那样是精确的。\n\n因此，Beta-PDF 加权积分的求积法则为：\n$$\n\\int_{0}^{1} f(Z)\\,Z^{\\alpha-1}(1-Z)^{\\beta-1}\\,\\mathrm{d}Z \\approx \\sum_{i=1}^{n} w_i^{\\text{B}} f(Z_i)\n$$\n\n这种构造是高效的，因为它利用了高斯求积的高阶多项式精度。燃烧模型中的函数 $f(Z)$ 通常是光滑的，并且能被多项式很好地近似，从而导致随着 $n$ 的增加而快速收敛。该方法特别强大，因为权函数 $w(Z)=Z^{\\alpha-1}(1-Z)^{\\beta-1}$（可能在端点包含可积奇点，如果 $\\alpha  1$ 或 $\\beta  1$ 时）被求积构造解析地处理了。求积节点和权重内在地适应了这种权重，在 Beta-PDF 具有最大质量的地方对 $f(Z)$ 进行最密集的采样，而无需用户对奇点进行离散化。\n\n该方案的数值稳定性极佳。计算正交多项式的根和权重是数值分析中的一个经典问题。现代库使用稳定的算法，例如 Golub-Welsch 算法，该算法将问题与寻找一个对称三对角矩阵（雅可比矩阵）的特征值相关联。这是一个良态计算。通过依赖这些用于典范区间 $[-1,1]$ 的稳健例程，然后应用一个简单的、非病态的线性映射来获得 $[0,1]$ 上的节点，我们继承了这种稳定性。这确保了即使对于大的 $n$ 或导致高度峰化或奇异 PDF 的参数 $\\alpha, \\beta$，计算也是可靠的。\n\n实现将按以下步骤进行：\n1. 对于一组给定的参数 $(\\alpha, \\beta, n, f)$，将雅可比参数设置为 $a = \\beta-1$ 和 $b = \\alpha-1$。\n2. 使用标准库函数（例如，`scipy.special.roots_jacobi`）计算区间 $[-1,1]$ 的 $n$ 个高斯-雅可比节点 $\\{x_i^{\\text{GJ}}\\}$ 和权重 $\\{w_i^{\\text{GJ}}\\}$。\n3. 通过 $Z_i = (x_i^{\\text{GJ}}+1)/2$ 将节点转换到目标区间 $[0,1]$。\n4. 通过 $w_i^{\\text{B}} = w_i^{\\text{GJ}} / 2^{\\alpha+\\beta-1}$ 缩放目标区间的权重。\n5. 在每个节点 $Z_i$ 处计算函数 $f$ 的值。\n6. 将积分近似值计算为加权和 $\\sum_{i=1}^{n} w_i^{\\text{B}} f(Z_i)$。\n7. 将此结果与参考值（通过 Beta 函数得到的精确值或通过高精度通用数值积分计算的值）进行比较，以求得绝对误差。\n对每个指定的测试案例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_jacobi, beta\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Derives and applies a Gauss-Jacobi quadrature scheme for Beta-PDF weighted\n    integrals, and computes the absolute error against reference values\n    for a suite of test cases.\n    \"\"\"\n\n    def gauss_beta_quadrature(alpha, beta_param, n, f):\n        \"\"\"\n        Computes the integral of f(Z) * Z^(alpha-1) * (1-Z)^(beta-1) from 0 to 1\n        using an n-point custom Gaussian quadrature.\n\n        Args:\n            alpha (float): Shape parameter of the Beta distribution.\n            beta_param (float): Shape parameter of the Beta distribution.\n            n (int): Number of quadrature points.\n            f (callable): A vectorized function f(Z).\n\n        Returns:\n            float: The approximated integral value.\n        \"\"\"\n        # The integral on [0,1] with weight w(Z) = Z^(alpha-1)*(1-Z)^(beta-1)\n        # is transformed to an integral on [-1,1] with a standard Jacobi weight.\n        # The Jacobi polynomial P_n^(a,b)(x) is orthogonal with respect to\n        # the weight (1-x)^a * (1+x)^b.\n        # The transformation Z = (x+1)/2 maps our weight to a form proportional\n        # to (1-x)^(beta-1) * (1+x)^(alpha-1).\n        # Thus, the required Jacobi parameters are a = beta-1 and b = alpha-1.\n        a_jacobi = beta_param - 1\n        b_jacobi = alpha - 1\n\n        # Get the standard Gauss-Jacobi nodes and weights for the interval [-1, 1].\n        # scipy.special.roots_jacobi provides these for the integral\n        # integral_{-1}^{1} g(x) (1-x)^a (1+x)^b dx approx sum(w_jacobi * g(x_nodes))\n        x_nodes, w_jacobi = roots_jacobi(n, a_jacobi, b_jacobi)\n\n        # Map the nodes from [-1, 1] to the target interval [0, 1].\n        z_nodes = (x_nodes + 1.0) / 2.0\n\n        # As derived, the integral I = (1/2**(alpha+beta-1)) * sum(w_jacobi_i * f(Z_i)).\n        # We can define weights for the [0,1] interval as w_beta = w_jacobi / 2**(a+b+1).\n        # This gives I = sum(w_beta_i * f(Z_i)).\n        \n        # Evaluate the function f at the transformed nodes.\n        f_vals = f(z_nodes)\n\n        # Scale the weights and compute the final sum.\n        # The scaling factor is 2**(a_jacobi + b_jacobi + 1) = 2**(alpha + beta_param - 1)\n        scaling_factor = 2.0**(alpha + beta_param - 1.0)\n        \n        integral_approx = np.sum(w_jacobi * f_vals) / scaling_factor\n\n        return integral_approx\n\n    # Define the test suite\n    # Each case: (alpha, beta, n, f, reference_type, reference_calculator)\n    test_cases = [\n        (2.0, 5.0, 3, lambda Z: 1.0, \n         'exact', lambda a,b: beta(a, b)),\n        \n        (0.7, 1.3, 2, lambda Z: Z**3, \n         'exact', lambda a,b: beta(a + 3.0, b)),\n\n        (3.5, 4.0, 8, lambda Z: np.exp(-7.0 * Z), \n         'numerical', None),\n\n        (0.3, 0.6, 12, lambda Z: np.sqrt(Z),\n         'numerical', None),\n\n        (50.0, 50.0, 16, lambda Z: np.sin(np.pi * Z),\n         'numerical', None),\n\n        (80.0, 3.0, 16, lambda Z: Z**2 / (0.1 + Z),\n         'numerical', None),\n    ]\n\n    absolute_errors = []\n\n    for case in test_cases:\n        alpha, beta_param, n, f, ref_type, ref_func = case\n\n        # Calculate the integral using the derived quadrature scheme\n        approx_val = gauss_beta_quadrature(alpha, beta_param, n, f)\n\n        # Calculate the reference value\n        if ref_type == 'exact':\n            ref_val = ref_func(alpha, beta_param)\n        else:  # 'numerical'\n            integrand = lambda Z: f(Z) * (Z**(alpha - 1.0)) * ((1.0 - Z)**(beta_param - 1.0))\n            ref_val, _ = quad(integrand, 0, 1, epsabs=1e-15, epsrel=1e-15)\n        \n        # Compute the absolute error\n        error = np.abs(approx_val - ref_val)\n        absolute_errors.append(f\"{error:.16e}\")\n\n    # Print the final result in the required format\n    print(f\"[{','.join(absolute_errors)}]\")\n\nsolve()\n```"
        }
    ]
}