{
    "hands_on_practices": [
        {
            "introduction": "在火焰面生成流形 (FGM) 方法中，火焰的复杂热化学状态被简化并映射到一个低维空间。除了守恒标量——混合物分数 $Z$ 之外，反应进度变量 $c$ 对于参数化流形至关重要。本练习  提供了一个动手实践的机会，通过实施和比较两种常见的定义——一种基于产物质量分数，另一种基于温度——来探索 $c$ 的定义是一种建模选择。通过量化它们的差异，您将更深入地理解进度变量的物理意义及其定义所带来的影响。",
            "id": "4027192",
            "problem": "给定一个由混合分数 $Z$ 参数化的一维小火焰，其中 $Z\\in[0,1]$ 是一个守恒标量。对于湍流燃烧的小火焰生成流形 (FGM) 表示法，通常使用一个反应进度变量 $c(Z)$ 来映射作为 $Z$ 函数的热化学状态。您的任务是使用两种基于小火焰组分场和温度场的定义来计算 $c(Z)$，然后通过一个范数来量化它们在 $Z\\in[0,1]$ 上的差异。\n\n任务的基本原理：\n- 混合分数 $Z$ 是一个守恒标量，它参数化了层流小火焰解，因此组分质量分数 $Y_i(Z)$ 和温度 $T(Z)$ 可以被视为区间 $Z\\in[0,1]$ 上的函数。\n- 层流小火焰中的组分守恒和能量守恒意味着主要产物组分和温度作为 $Z$ 的函数具有平滑且物理上合理的剖面。\n\n需要实现的定义（不使用任何简化方法）：\n- 基于组分的进度变量：对于每个 $Z$，由四种主要产物组分（即 $\\text{CO}_2$、$\\text{H}_2\\text{O}$、$\\text{CO}$ 和 $\\text{H}_2$）形成一个信号。将其质量分数结合起来，在每个 $Z$ 处产生一个单一的标量信号，然后用该信号在 $Z\\in[0,1]$ 上的最大值进行归一化，以使结果位于区间 $[0,1]$ 内。如果最大值为 $0$，则将基于组分的进度变量定义为对所有 $Z$ 均为 $0$。\n- 基于温度的进度变量：对于每个 $Z$，从局部温度 $T(Z)$ 中减去一个给定的未燃温度 $T_u$，然后用 $Z\\in[0,1]$ 上的最大温升对结果进行归一化，以使结果位于区间 $[0,1]$ 内。如果最大温升为 $0$，则将基于温度的进度变量定义为对所有 $Z$ 均为 $0$。\n\n用于量化差异的范数：\n- 使用两个进度变量之差在 $Z\\in[0,1]$ 上的 $L^2$ 范数。在 $[0,1]$ 上的 $N$ 个点的均匀网格上，通过梯形法则实现积分的数值近似，其中 $N$ 在测试套件中指定。范数的输出必须表示为无量纲浮点数。\n\n每个测试用例的输入构造：\n- 组分剖面和温度是解析生成的，以代表合理的小火焰行为。对于每个测试用例，您将获得定义产物组分质量分数的参数，这些质量分数是平滑的高斯函数，中心位于近化学计量的混合分数 $Z_{\\mathrm{st}}$ 附近；同时，您还将获得与总产物信号相关的温度场参数。所有组分质量分数都是无量纲的，温度单位为开尔文 (K)。对于下面出现的任何符号，请确保将其视为数学实体。\n- 对于每个组分 $i\\in\\{\\text{CO}_2,\\text{H}_2\\text{O},\\text{CO},\\text{H}_2\\}$，质量分数剖面定义为高斯函数\n$$\nY_i(Z)=A_i\\exp\\left(-\\frac{\\left(Z-\\mu_i\\right)^2}{2\\sigma_i^2}\\right),\n$$\n其中 $A_i$ 是振幅，$\\mu_i$ 是中心，$\\sigma_i$ 是宽度。中心由 $Z_{\\mathrm{st}}$ 加上依赖于组分的偏移量指定。\n- 温度场定义为\n$$\nT(Z)=T_u+T_{\\mathrm{peak}}\\left(S(Z)\\right)^\\alpha,\n$$\n其中 $S(Z)$ 是由基于组分的进度变量定义中使用的四种产物组分构建的归一化总产物信号，$T_u$ 是未燃温度，$T_{\\mathrm{peak}}$ 是最大温升参数，$\\alpha$ 是控制尖锐度的指数。如果归一化信号恒为零，则温度剖面简化为 $T(Z)=T_u$。\n\n数值细节：\n- 在 $Z\\in[0,1]$ 上使用一个包含 $N$ 个点的均匀网格。\n- 通过梯形法则近似计算 $L^2$ 范数中的积分。\n- 最终输出为无量纲浮点数。\n\n测试套件：\n- 案例 1 (一般物理上合理的小火焰):\n    - $N=1001$, $Z_{\\mathrm{st}}=0.08$, $T_u=300\\,\\mathrm{K}$, $T_{\\mathrm{peak}}=1600\\,\\mathrm{K}$, $\\alpha=1.0$.\n    - 组分参数:\n        - $\\text{CO}_2$: $A_{\\text{CO}_2}=0.12$, $\\mu_{\\text{CO}_2}=Z_{\\mathrm{st}}$, $\\sigma_{\\text{CO}_2}=0.03$.\n        - $\\text{H}_2\\text{O}$: $A_{\\text{H}_2\\text{O}}=0.10$, $\\mu_{\\text{H}_2\\text{O}}=Z_{\\mathrm{st}}$, $\\sigma_{\\text{H}_2\\text{O}}=0.035$.\n        - $\\text{CO}$: $A_{\\text{CO}}=0.02$, $\\mu_{\\text{CO}}=Z_{\\mathrm{st}}+0.01$, $\\sigma_{\\text{CO}}=0.015$.\n        - $\\text{H}_2$: $A_{\\text{H}_2}=0.005$, $\\mu_{\\text{H}_2}=Z_{\\mathrm{st}}+0.04$, $\\sigma_{\\text{H}_2}=0.06$.\n- 案例 2 (退化的无反应情况):\n    - $N=1001$, $Z_{\\mathrm{st}}=0.08$, $T_u=300\\,\\mathrm{K}$, $T_{\\mathrm{peak}}=0\\,\\mathrm{K}$, $\\alpha=1.0$.\n    - 组分参数:\n        - $\\text{CO}_2$: $A_{\\text{CO}_2}=0$, $\\mu_{\\text{CO}_2}=Z_{\\mathrm{st}}$, $\\sigma_{\\text{CO}_2}=0.03$.\n        - $\\text{H}_2\\text{O}$: $A_{\\text{H}_2\\text{O}}=0$, $\\mu_{\\text{H}_2\\text{O}}=Z_{\\mathrm{st}}$, $\\sigma_{\\text{H}_2\\text{O}}=0.035$.\n        - $\\text{CO}$: $A_{\\text{CO}}=0$, $\\mu_{\\text{CO}}=Z_{\\mathrm{st}}+0.01$, $\\sigma_{\\text{CO}}=0.015$.\n        - $\\text{H}_2$: $A_{\\text{H}_2}=0$, $\\mu_{\\text{H}_2}=Z_{\\mathrm{st}}+0.04$, $\\sigma_{\\text{H}_2}=0.06$.\n- 案例 3 (有组分生成但无温升):\n    - $N=1001$, $Z_{\\mathrm{st}}=0.06$, $T_u=300\\,\\mathrm{K}$, $T_{\\mathrm{peak}}=0\\,\\mathrm{K}$, $\\alpha=1.0$.\n    - 组分参数:\n        - $\\text{CO}_2$: $A_{\\text{CO}_2}=0.07$, $\\mu_{\\text{CO}_2}=Z_{\\mathrm{st}}$, $\\sigma_{\\text{CO}_2}=0.025$.\n        - $\\text{H}_2\\text{O}$: $A_{\\text{H}_2\\text{O}}=0.09$, $\\mu_{\\text{H}_2\\text{O}}=Z_{\\mathrm{st}}$, $\\sigma_{\\text{H}_2\\text{O}}=0.03$.\n        - $\\text{CO}$: $A_{\\text{CO}}=0.03$, $\\mu_{\\text{CO}}=Z_{\\mathrm{st}}+0.008$, $\\sigma_{\\text{CO}}=0.012$.\n        - $\\text{H}_2$: $A_{\\text{H}_2}=0.01$, $\\mu_{\\text{H}_2}=Z_{\\mathrm{st}}+0.03$, $\\sigma_{\\text{H}_2}=0.05$.\n\n您的程序必须：\n- 为每个案例在 $[0,1]$ 上构建一个包含 $N$ 个点的均匀网格 $Z$。\n- 根据提供的参数生成组分剖面和温度场。\n- 实现如上所述的基于组分和基于温度的进度变量。\n- 使用梯形法则计算它们在 $Z\\in[0,1]$ 上差值的 $L^2$ 范数。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表包含三个测试用例的有序结果，每个浮点数四舍五入到六位小数，例如 $[x_1,x_2,x_3]$。",
            "solution": "该问题要求在湍流燃烧的小火焰生成流形 (FGM) 框架内，计算并比较反应进度变量 $c$ 的两种不同定义。这种比较通过两个进度变量之差的 $L^2$ 范数来量化，该范数在混合分数 $Z \\in [0,1]$ 的域上进行评估。解决方案的开发过程是：首先根据提供的解析模型构建必要的热化学场（组分质量分数和温度），然后定义进度变量，最后使用数值积分计算范数。\n\n混合分数 $Z$ 的计算域被离散化为 $N$ 个点的均匀网格，记为 $Z_k$（$k=0, 1, \\dots, N-1$）。网格点由 $Z_k = k \\cdot \\Delta Z$ 给出，其中网格间距为 $\\Delta Z = 1/(N-1)$。\n\n首先，生成四种主要产物组分 $i \\in \\{\\text{CO}_2, \\text{H}_2\\text{O}, \\text{CO}, \\text{H}_2\\}$ 作为 $Z$ 函数的质量分数剖面。根据问题陈述，每个组分剖面 $Y_i(Z)$ 被建模为高斯函数：\n$$\nY_i(Z)=A_i\\exp\\left(-\\frac{\\left(Z-\\mu_i\\right)^2}{2\\sigma_i^2}\\right)\n$$\n这里，$A_i$ 是振幅，$\\mu_i$ 是峰值中心，$\\sigma_i$ 是标准差（宽度）。每个测试用例中都为每个组分提供了参数 $\\{A_i, \\mu_i, \\sigma_i\\}$。在离散网格 $Z_k$ 上对这些函数求值，以获得数组 $Y_i(Z_k)$。\n\n在建立组分剖面后，可以构建第一个基于组分质量分数的进度变量定义。我们将此进度变量表示为 $c_Y(Z)$。它由代表指定产物组分总质量分数的信号构建而成。该信号 $Y_{\\mathrm{prod}}(Z)$ 是各个质量分数的总和：\n$$\nY_{\\mathrm{prod}}(Z) = Y_{\\mathrm{CO}_2}(Z) + Y_{\\mathrm{H_2O}}(Z) + Y_{\\mathrm{CO}}(Z) + Y_{\\mathrm{H_2}}(Z)\n$$\n然后，该组合信号通过其在整个混合分数空间中的最大值进行归一化，以确保进度变量有界，$c_Y(Z) \\in [0, 1]$。令 $Y_{\\mathrm{prod,max}} = \\max_{Z \\in [0,1]} Y_{\\mathrm{prod}}(Z)$。基于组分的进度变量定义为：\n$$\nc_Y(Z) = \\begin{cases} \\frac{Y_{\\mathrm{prod}}(Z)}{Y_{\\mathrm{prod,max}}}  \\text{if } Y_{\\mathrm{prod,max}} > 0 \\\\ 0  \\text{if } Y_{\\mathrm{prod,max}} = 0 \\end{cases}\n$$\n第二种情况处理没有产物生成的非反应情景。\n\n接下来，构建基于温度的进度变量 $c_T(Z)$。该定义依赖于温度场 $T(Z)$，而温度场本身是根据基于组分的信号定义的。温度剖面由以下公式给出：\n$$\nT(Z)=T_u+T_{\\mathrm{peak}}\\left(S(Z)\\right)^\\alpha\n$$\n其中 $T_u$ 是未燃温度，$T_{\\mathrm{peak}}$ 是最大温升参数，$\\alpha$ 是一个指数，而 $S(Z)$ 是归一化的总产物信号。根据问题陈述，$S(Z)$ 的构建方式与基于组分的进度变量完全相同，因此我们认定 $S(Z) \\equiv c_Y(Z)$。因此，温度的表达式变为：\n$$\nT(Z)=T_u+T_{\\mathrm{peak}}\\left(c_Y(Z)\\right)^\\alpha\n$$\n基于温度的进度变量定义为局部温升 $T(Z) - T_u$ 除以该域上的最大温升 $\\Delta T_{\\mathrm{max}} = \\max_{Z \\in [0,1]} (T(Z) - T_u)$ 进行归一化。局部温升直接为 $\\Delta T(Z) = T_{\\mathrm{peak}}(c_Y(Z))^\\alpha$。最大温升为 $\\Delta T_{\\mathrm{max}} = \\max_Z [T_{\\mathrm{peak}}(c_Y(Z))^\\alpha]$。由于 $c_Y(Z) \\in [0,1]$，其最大值为 1（除非它恒为零）。因此，对于一个反应情况，其中 $Y_{\\mathrm{prod,max}} > 0$ 且 $T_{\\mathrm{peak}} > 0$，我们有 $\\Delta T_{\\mathrm{max}} = T_{\\mathrm{peak}} \\cdot (1)^\\alpha = T_{\\mathrm{peak}}$。基于温度的进度变量简化为：\n$$\nc_T(Z) = \\frac{T(Z) - T_u}{\\Delta T_{\\mathrm{max}}} = \\frac{T_{\\mathrm{peak}}\\left(c_Y(Z)\\right)^\\alpha}{T_{\\mathrm{peak}}} = \\left(c_Y(Z)\\right)^\\alpha\n$$\n对于最大温升为零的情况需要特别处理。如果 $T_{\\mathrm{peak}}=0$，则对所有 $Z$ 都有 $T(Z)=T_u$，因此 $\\Delta T_{\\mathrm{max}}=0$，根据定义，$c_T(Z) = 0$。这与问题所给的约束条件一致。\n\n最后一步是使用 $L^2$ 范数来量化 $c_Y(Z)$ 和 $c_T(Z)$ 之间的差异，其定义为：\n$$\n||c_Y - c_T||_{L^2} = \\sqrt{\\int_0^1 \\left(c_Y(Z) - c_T(Z)\\right)^2 dZ}\n$$\n该积分在离散网格上使用梯形法则进行数值计算。令 $f(Z) = (c_Y(Z) - c_T(Z))^2$。积分 $I = \\int_0^1 f(Z) dZ$ 近似为：\n$$\nI \\approx \\sum_{k=0}^{N-2} \\frac{f(Z_k) + f(Z_{k+1})}{2} \\Delta Z = \\Delta Z \\left( \\frac{f(Z_0) + f(Z_{N-1})}{2} + \\sum_{k=1}^{N-2} f(Z_k) \\right)\n$$\n$L^2$ 范数即为 $\\sqrt{I}$。\n\n该过程应用于每个测试用例：\n- **案例 1：** $\\alpha=1.0$ 且 $T_{\\mathrm{peak}} > 0$。这导致 $c_T(Z) = c_Y(Z)$。差值恒为零，因此 $L^2$ 范数为 $0$。\n- **案例 2：** 所有组分振幅 $A_i=0$，因此 $Y_{\\mathrm{prod}}(Z)=0$，从而 $c_Y(Z)=0$。同时，$T_{\\mathrm{peak}}=0$，所以 $c_T(Z)=0$。差值恒为零，范数为 $0$。\n- **案例 3：** 组分振幅 $A_i > 0$，所以 $c_Y(Z)$ 是一个非平凡函数。然而，$T_{\\mathrm{peak}}=0$，这意味着 $T(Z)=T_u$ 且 $\\Delta T_{\\mathrm{max}}=0$。根据定义，$c_T(Z)=0$。因此，需要计算的范数是 $||c_Y(Z) - 0||_{L^2} = ||c_Y(Z)||_{L^2} = \\sqrt{\\int_0^1 (c_Y(Z))^2 dZ}$，这需要进行数值评估。\n\n这种有原则的、分步的实现确保了问题陈述中的所有条件和定义都被正确地转化为计算算法。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the FGM progress variable comparison problem\n    for a given set of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"N\": 1001, \"Z_st\": 0.08, \"T_u\": 300.0, \"T_peak\": 1600.0, \"alpha\": 1.0,\n            \"species_params\": {\n                \"CO2\": {\"A\": 0.12, \"mu_shift\": 0.0, \"sigma\": 0.03},\n                \"H2O\": {\"A\": 0.10, \"mu_shift\": 0.0, \"sigma\": 0.035},\n                \"CO\": {\"A\": 0.02, \"mu_shift\": 0.01, \"sigma\": 0.015},\n                \"H2\": {\"A\": 0.005, \"mu_shift\": 0.04, \"sigma\": 0.06},\n            },\n        },\n        {\n            \"N\": 1001, \"Z_st\": 0.08, \"T_u\": 300.0, \"T_peak\": 0.0, \"alpha\": 1.0,\n            \"species_params\": {\n                \"CO2\": {\"A\": 0.0, \"mu_shift\": 0.0, \"sigma\": 0.03},\n                \"H2O\": {\"A\": 0.0, \"mu_shift\": 0.0, \"sigma\": 0.035},\n                \"CO\": {\"A\": 0.0, \"mu_shift\": 0.01, \"sigma\": 0.015},\n                \"H2\": {\"A\": 0.0, \"mu_shift\": 0.04, \"sigma\": 0.06},\n            },\n        },\n        {\n            \"N\": 1001, \"Z_st\": 0.06, \"T_u\": 300.0, \"T_peak\": 0.0, \"alpha\": 1.0,\n            \"species_params\": {\n                \"CO2\": {\"A\": 0.07, \"mu_shift\": 0.0, \"sigma\": 0.025},\n                \"H2O\": {\"A\": 0.09, \"mu_shift\": 0.0, \"sigma\": 0.03},\n                \"CO\": {\"A\": 0.03, \"mu_shift\": 0.008, \"sigma\": 0.012},\n                \"H2\": {\"A\": 0.01, \"mu_shift\": 0.03, \"sigma\": 0.05},\n            },\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        result = calculate_norm(params)\n        results.append(result)\n\n    # Format the final output as specified.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\n\ndef calculate_norm(params):\n    \"\"\"\n    Calculates the L2 norm of the difference between species-based and\n    temperature-based progress variables.\n    \n    Args:\n        params (dict): A dictionary containing all parameters for a single test case.\n        \n    Returns:\n        float: The computed L2 norm.\n    \"\"\"\n    N = params[\"N\"]\n    Z_st = params[\"Z_st\"]\n    T_peak = params[\"T_peak\"]\n    alpha = params[\"alpha\"]\n    species_params = params[\"species_params\"]\n\n    # Step 1: Create the mixture fraction grid\n    Z_grid = np.linspace(0.0, 1.0, N)\n\n    # Step 2: Calculate species profiles\n    Y_prod = np.zeros(N)\n    for sp_name, sp_p in species_params.items():\n        A = sp_p[\"A\"]\n        if A > 0: # Optimization: skip zero-amplitude species\n            mu = Z_st + sp_p[\"mu_shift\"]\n            sigma = sp_p[\"sigma\"]\n            Y_i = A * np.exp(-((Z_grid - mu)**2) / (2 * sigma**2))\n            Y_prod += Y_i\n\n    # Step 3: Calculate species-based progress variable c_Y\n    Y_prod_max = np.max(Y_prod)\n    if not np.isclose(Y_prod_max, 0.0):\n        c_Y = Y_prod / Y_prod_max\n    else:\n        c_Y = np.zeros(N)\n\n    # Step 4: Calculate temperature-based progress variable c_T\n    # Based on the analysis T_max_rise equals T_peak if T_peak > 0\n    # and c_T = (c_Y)^alpha. If T_peak is 0, c_T is 0 by definition.\n    if not np.isclose(T_peak, 0.0):\n        c_T = c_Y**alpha\n    else:\n        c_T = np.zeros(N)\n\n    # Step 5: Calculate the L2 norm of the difference\n    integrand = (c_Y - c_T)**2\n    integral = np.trapz(integrand, x=Z_grid)\n    \n    # The norm is the square root of the integral.\n    # Handle potential small negative values from numerical precision issues.\n    norm = np.sqrt(max(0, integral))\n\n    return norm\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "FGM 的核心是构成流形的火焰面解的集合。“S形曲线”是一个基本概念，它表示稳态火焰面对以标量耗散率 $\\chi_{st}$ 为特征的应变的响应。本练习  将指导您通过一个简化模型数值计算该S形曲线，重点是识别与物理点火和熄火极限相对应的关键“转折点”。掌握此练习有助于理解反应流形的边界是如何确定的。",
            "id": "4027184",
            "problem": "给定一个简化的稳态小火焰模型，用于为湍流非预混燃烧构建小火焰生成流形 (Flamelet-Generated Manifold, FGM)。目标是数值计算当化学计量标量耗散率变化时的稳态小火焰S型曲线，并识别该曲线上的转折点。\n\n出发点和假设如下。\n\n- 在单位路易斯数极限、准等压流和对冲流配置下，考虑混合分数坐标 $Z \\in [0,1]$。集总进度变量 $c(Z)$ 的稳态小火焰方程可以从混合分数空间中的稳态组分和能量守恒方程推导出来，其形式为\n$$\n0 \\;=\\; -\\rho\\,\\chi_{st}\\,\\frac{\\partial^2 c}{\\partial Z^2} \\;+\\; \\omega_c(c,T,Z),\n$$\n其中 $\\rho$ 是质量密度，$\\chi_{st}$ 是化学计量标量耗散率，$\\omega_c$ 是进度变量的化学源项。标量耗散率定义为\n$$\n\\chi \\;=\\; 2\\,D_Z\\,|\\nabla Z|^2,\n$$\n其中 $D_Z$ 是混合分数扩散率。在小火焰框架中，稳态S型曲线将火焰强度的标量度量（例如，峰值温度或进度变量）与 $\\chi_{st}$ 联系起来。\n\n- 在化学计量面 $Z=Z_{st}$ 处，采用一个有效的零维闭合，该闭合平衡了反应和扩散破坏，从而产生一个代数稳态关系\n$$\n0 \\;=\\; \\mathrm{Da}\\;R(c) \\;-\\; \\chi_{st}\\;D(c),\n$$\n其中 $\\mathrm{Da}$ 是 Damköhler 数， $R(c)$ 是一个有效反应项， $D(c)$ 是一个有效扩散破坏项。这种近似通常用于构建简化模型，并将 $Z_{st}$ 处的局部稳态解释为热释放和耗散输运之间的平衡。\n\n- 为了捕捉链分支、高 $c$ 值下的热释放饱和以及非绝热损失，使用以下唯象但科学上合理的形式：\n$$\nR(c) \\;=\\; c\\,(1-c)\\,\\exp\\!\\Big(-\\frac{\\beta}{c+\\varepsilon}\\Big) \\;-\\; s\\,c^3, \\quad D(c) \\;=\\; c \\;+\\; \\gamma,\n$$\n其中常数 $\\beta>0$（活化参数）、$\\varepsilon>0$（正则化参数）、$s>0$（集总热损失强度）和 $\\gamma>0$（模拟非零标量输运的扩散偏移量）。S型曲线由以下参数化形式获得\n$$\n\\chi_{st}(c) \\;=\\; \\frac{\\mathrm{Da}\\,R(c)}{D(c)}, \\quad c \\in (0,1),\n$$\n转折点由折叠条件定义\n$$\n\\frac{d\\chi_{st}}{dc} \\;=\\; 0 \\;\\;\\Longleftrightarrow\\;\\; R'(c)\\,D(c) \\;-\\; R(c)\\,D'(c) \\;=\\; 0,\n$$\n其中 $R'(c)$ 和 $D'(c)$ 表示对 $c$ 的导数。\n\n您的任务是实现一个完整、可运行的程序，该程序：\n\n1. 通过在 $c \\in (0,1)$ 上使用稳健的区间法找到\n$$\nN(c) \\;\\equiv\\; R'(c)\\,D(c) \\;-\\; R(c)\\,D'(c) \\;=\\; 0,\n$$\n的所有根，来计算转折点 $c^\\star \\in (0,1)$。\n\n2. 将这些转折点映射到相应的化学计量标量耗散率\n$$\n\\chi_{st}^{\\star} \\;=\\; \\frac{\\mathrm{Da}\\,R(c^\\star)}{D(c^\\star)}.\n$$\n\n3. 仅返回满足 $R(c^\\star) > 0$ 和 $\\chi_{st}^{\\star} > 0$ 的物理上可接受的转折点。\n\n4. 以 $\\mathrm{s}^{-1}$ 为单位表示每个报告的 $\\chi_{st}^{\\star}$，并四舍五入到 $6$ 位小数。\n\n本问题中出现的定义包括小火焰生成流形 (FGM)、Damköhler数 (Da) 和标量耗散率 $\\chi$。实现必须不依赖任何外部数据文件或输入，并且应是自包含的。\n\n测试套件：\n\n对于下面的每个参数集 $(\\mathrm{Da},\\beta,\\varepsilon,\\gamma,s)$，计算转折点标量耗散率 $\\chi_{st}^{\\star}$ 的列表。\n\n- 案例 $1$（一般理想情况）：$\\mathrm{Da}=15$, $\\beta=5$, $\\varepsilon=10^{-3}$, $\\gamma=0.02$, $s=0.20$。\n- 案例 $2$（低反应性，可能没有折叠）：$\\mathrm{Da}=3$, $\\beta=5$, $\\varepsilon=10^{-3}$, $\\gamma=0.02$, $s=0.20$。\n- 案例 $3$（高活化，修正的损失）：$\\mathrm{Da}=20$, $\\beta=12$, $\\varepsilon=10^{-3}$, $\\gamma=0.02$, $s=0.15$。\n\n最终输出规范：\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试案例的结果必须是一个浮点数列表（每个数四舍五入到 $6$ 位小数），表示该案例的 $\\chi_{st}^{\\star}$ 值（单位为 $\\mathrm{s}^{-1}$），并按 $c^\\star$ 递增排序。例如，如果案例 $1$ 有两个转折点，案例 $2$ 没有，案例 $3$ 有一个，那么输出格式必须是\n$$\n[\\,[\\chi_{st,1}^{\\star},\\chi_{st,2}^{\\star}],\\,[\\,],\\,[\\chi_{st,3}^{\\star}]\\,].\n$$",
            "solution": "用户提供了一个用于描述非预混小火焰稳态的唯象模型，该稳态位于化学计量混合分数 $Z_{st}$ 处。该模型被表述为化学反应与扩散输运之间的代数平衡，这是计算燃烧领域中生成小火焰生成流形 (FGM) 的一种常见简化方法。目标是找到小火焰“S型曲线”的转折点，该曲线绘制了火焰强度度量与化学计量标量耗散率 $\\chi_{st}$ 的关系。这些转折点对应于点火和熄灭等临界现象。\n\n控制代数方程如下：\n$$\n0 \\;=\\; \\mathrm{Da}\\,R(c) \\;-\\; \\chi_{st}\\;D(c)\n$$\n这里，$c \\in (0,1)$ 是一个进度变量，$\\mathrm{Da}$ 是 Damköhler 数，$R(c)$ 是有效反应速率，$D(c)$ 是有效扩散破坏速率。化学计量标量耗散率 $\\chi_{st}$ 被视为一个分岔参数。\n\n为 $R(c)$ 和 $D(c)$ 指定的形式是：\n$$\nR(c) \\;=\\; c\\,(1-c)\\,\\exp\\!\\Big(-\\frac{\\beta}{c+\\varepsilon}\\Big) \\;-\\; s\\,c^3\n$$\n$$\nD(c) \\;=\\; c \\;+\\; \\gamma\n$$\n其中 $\\beta$、$\\varepsilon$、$s$ 和 $\\gamma$ 是分别模拟活化、正则化、热损失和扩散偏移的正数常量。\n\n根据控制方程，S型曲线由 $\\chi_{st}$ 作为 $c$ 的函数进行参数化定义：\n$$\n\\chi_{st}(c) \\;=\\; \\frac{\\mathrm{Da}\\,R(c)}{D(c)}, \\quad c \\in (0,1)\n$$\n转折点是 $\\chi_{st}$ 相对于 $c$ 的曲线上的局部极值，通过将 $\\chi_{st}(c)$ 对 $c$ 的导数设为零来找到：\n$$\n\\frac{d\\chi_{st}}{dc} \\;=\\; 0\n$$\n对 $\\chi_{st}(c)$ 的表达式应用微分的商法则：\n$$\n\\frac{d\\chi_{st}}{dc} \\;=\\; \\mathrm{Da} \\cdot \\frac{R'(c)D(c) - R(c)D'(c)}{[D(c)]^2} \\;=\\; 0\n$$\n其中 $R'(c) = \\frac{dR}{dc}$ 且 $D'(c) = \\frac{dD}{dc}$。由于 $\\mathrm{Da}$ 是一个正常量，且对于 $c \\in (0,1)$ 和 $\\gamma>0$，$D(c) = c+\\gamma$ 严格为正，因此转折点的条件简化为求解分子的根：\n$$\nN(c) \\;\\equiv\\; R'(c)D(c) - R(c)D'(c) \\;=\\; 0\n$$\n为了解此方程，我们首先需要 $R(c)$ 和 $D(c)$ 的导数。\n$D(c)$ 的导数很简单：\n$$\nD'(c) \\;=\\; \\frac{d}{dc}(c + \\gamma) \\;=\\; 1\n$$\n为了求 $R'(c)$，我们逐项对 $R(c)$ 进行微分。设 $E(c) = \\exp\\left(-\\frac{\\beta}{c+\\varepsilon}\\right)$。\n$$\nR(c) \\;=\\; (c-c^2)E(c) - sc^3\n$$\n使用乘法法则和链式法则：\n$$\nR'(c) \\;=\\; \\frac{d}{dc}\\left((c-c^2)E(c)\\right) - \\frac{d}{dc}(sc^3)\n$$\n$$\n\\frac{d}{dc}\\left((c-c^2)E(c)\\right) \\;=\\; (1-2c)E(c) + (c-c^2)E'(c)\n$$\n$$\nE'(c) \\;=\\; \\exp\\left(-\\frac{\\beta}{c+\\varepsilon}\\right) \\cdot \\frac{d}{dc}\\left(-\\frac{\\beta}{c+\\varepsilon}\\right) \\;=\\; E(c) \\cdot \\frac{\\beta}{(c+\\varepsilon)^2}\n$$\n将 $E'(c)$ 代回，并对损失项进行微分：\n$$\nR'(c) \\;=\\; (1-2c)E(c) + (c-c^2)\\frac{\\beta E(c)}{(c+\\varepsilon)^2} - 3sc^2\n$$\n$$\nR'(c) \\;=\\; \\left[ (1-2c) + \\frac{\\beta c(1-c)}{(c+\\varepsilon)^2} \\right] \\exp\\left(-\\frac{\\beta}{c+\\varepsilon}\\right) - 3sc^2\n$$\n有了这些导数，转折点条件就变成了求解函数根 $c^\\star$ 的问题：\n$$\nN(c) \\;=\\; \\left( \\left[ (1-2c) + \\frac{\\beta c(1-c)}{(c+\\varepsilon)^2} \\right] E(c) - 3sc^2 \\right)(c+\\gamma) - \\left( (c-c^2)E(c) - sc^3 \\right) \\;=\\; 0\n$$\n问题现在简化为在区间 $c \\in (0,1)$ 上对函数 $N(c)$ 进行数值求根。执行此任务的稳健算法如下：\n1.  将区间 $c \\in (0,1)$ 离散化为一个细密的格点。使用一个小的留边来避免边界，例如 $c \\in [10^{-6}, 1-10^{-6}]$。\n2.  遍历格点，搜索函数 $N(c)$ 符号改变的相邻点对 $(c_i, c_{i+1})$，即 $N(c_i) \\cdot N(c_{i+1}) \\le 0$。每个这样的点对都包含一个根。\n3.  对于每个包含根的区间，使用可靠的数值求解器（如 Brent 方法）以高精度找到根 $c^\\star$。\n\n找到所有根 $c^\\star$ 后，我们必须筛选出物理上可接受的解。问题规定了两个条件：$R(c^\\star) > 0$ 和 $\\chi_{st}^\\star > 0$。标量耗散率 $\\chi_{st}^\\star$ 计算如下：\n$$\n\\chi_{st}^\\star \\;=\\; \\frac{\\mathrm{Da}\\,R(c^\\star)}{D(c^\\star)}\n$$\n鉴于 $\\mathrm{Da} > 0$ 且对于 $c^\\star \\in (0,1)$，$D(c^\\star) = c^\\star+\\gamma > 0$，条件 $\\chi_{st}^\\star > 0$ 等价于 $R(c^\\star) > 0$。因此，我们只需要检查转折点处的净反应速率是否为正。\n\n每个测试案例的最终算法如下：\n1.  为给定的参数集 $(\\beta, \\varepsilon, \\gamma, s)$ 定义函数 $N(c)$。\n2.  数值求解 $N(c)=0$ 在 $c \\in (0,1)$ 中的所有根 $c^\\star$。\n3.  对于每个根 $c^\\star$，检查是否 $R(c^\\star) > 0$。\n4.  如果根是可接受的，使用给定的 $\\mathrm{Da}$ 计算相应的转折点标量耗散率 $\\chi_{st}^\\star$。\n5.  收集所有可接受的对 $(c^\\star, \\chi_{st}^\\star)$，并按 $c^\\star$ 递增顺序对其进行排序。\n6.  测试案例的最终结果是与排序后的 $c^\\star$ 值相对应的 $\\chi_{st}^\\star$ 值列表，四舍五入到 $6$ 位小数。\n对每个提供的参数集实施此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for the turning points of the flamelet S-curve for given sets of parameters.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: (Da, beta, eps, gamma, s)\n        (15.0, 5.0, 1e-3, 0.02, 0.20),\n        # Case 2\n        (3.0, 5.0, 1e-3, 0.02, 0.20),\n        # Case 3\n        (20.0, 12.0, 1e-3, 0.02, 0.15),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        Da, beta, eps, gamma, s = params\n\n        def R(c, beta_p=beta, eps_p=eps, s_p=s):\n            \"\"\"Calculates the reaction term R(c).\"\"\"\n            if c = 0.0 or c >= 1.0:\n                return 0.0\n            exp_term = np.exp(-beta_p / (c + eps_p))\n            return c * (1.0 - c) * exp_term - s_p * c**3\n\n        def N(c, beta_p=beta, eps_p=eps, gamma_p=gamma, s_p=s):\n            \"\"\"\n            Calculates the numerator function N(c) = R'(c)D(c) - R(c)D'(c)\n            whose roots are the turning points. Since D'(c) = 1, N(c) = R'(c)D(c) - R(c).\n            \"\"\"\n            # Domain check for safety, though bracketing is within (0,1)\n            if c = 1e-9 or c >= 1.0 - 1e-9:\n                return np.nan\n\n            exp_term = np.exp(-beta_p / (c + eps_p))\n            \n            # Derivative of E(c) = exp(-beta/(c+eps))\n            # E_prime = exp_term * beta_p / (c + eps_p)**2\n            \n            # Derivative of R(c) = (c-c^2)E(c) - s*c^3\n            # R_prime = (1-2c)E(c) + (c-c^2)E_prime(c) - 3sc^2\n            Rp_term_in_brackets = (1.0 - 2.0*c) + c * (1.0 - c) * beta_p / (c + eps_p)**2\n            Rp = Rp_term_in_brackets * exp_term - 3.0 * s_p * c**2\n            \n            Rc = c * (1.0 - c) * exp_term - s_p * c**3\n            Dc = c + gamma_p\n            \n            return Rp * Dc - Rc\n\n        # Use a fine grid to bracket roots for N(c) = 0 in (0,1)\n        c_grid = np.linspace(1e-6, 1.0 - 1e-6, 10001)\n        roots = []\n        \n        y_grid = np.array([N(c) for c in c_grid])\n\n        for i in range(len(c_grid) - 1):\n            c1, c2 = c_grid[i], c_grid[i+1]\n            y1, y2 = y_grid[i], y_grid[i+1]\n            \n            if not (np.isnan(y1) or np.isnan(y2)):\n                if np.sign(y1) != np.sign(y2):\n                    try:\n                        root = brentq(N, c1, c2)\n                        # Add if not a duplicate of the last found root\n                        if not roots or not np.isclose(root, roots[-1]):\n                            roots.append(root)\n                    except (ValueError, RuntimeError):\n                        # brentq can fail if the function is strange, though unlikely here\n                        pass\n        \n        # Filter for admissible turning points and calculate chi_st\n        admissible_points = []\n        for c_star in roots:\n            Rc_star = R(c_star)\n            if Rc_star > 0.0:\n                Dc_star = c_star + gamma\n                chi_st_star = Da * Rc_star / Dc_star\n                admissible_points.append((c_star, chi_st_star))\n\n        # Sort results based on increasing c_star, as per problem specification\n        admissible_points.sort(key=lambda x: x[0])\n        \n        # Extract chi_st values and round to 6 decimal places\n        final_chi_st = [round(chi, 6) for c, chi in admissible_points]\n        all_results.append(final_chi_st)\n\n    # Format the final output string to be compact and without spaces\n    case_strings = []\n    for res_list in all_results:\n        case_strings.append(\"[\" + \",\".join(map(str, res_list)) + \"]\")\n    \n    final_output_string = \"[\" + \",\".join(case_strings) + \"]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "为了在湍流燃烧模拟（例如大涡模拟）中应用FGM，必须将预先计算的流形与解析的流场耦合起来。这需要考虑流形坐标 $Z$ 和 $c$ 的亚网格尺度波动。本练习  将引导您完成计算滤波后化学源项的关键步骤，即通过在描述 $Z$ 和 $c$ 亚网格波动的假定概率密度函数 (PDF) 上对列表化的源项进行积分。这项实践弥合了抽象的火焰面流形与其在计算流体力学 (CFD) 中实际应用之间的鸿沟。",
            "id": "4027222",
            "problem": "您的任务是在一个小火焰生成流形框架中，为湍流预混或非预混燃烧计算过滤后的进程变量源项。设混合分数为 $Z \\in [0,1]$，进程变量为 $c \\in [0,1]$。进程变量的过滤反应源项定义为以下二重积分：\n$$\n\\widetilde{\\dot{\\omega}}_c \\;=\\; \\int_0^1 \\int_0^1 \\dot{\\omega}_c(Z,c)\\, \\mathcal{P}_{Z,c}(Z,c)\\, dZ\\, dc,\n$$\n其中 $\\dot{\\omega}_c(Z,c)$ 是流形上的一个列表化反应源项，而 $\\mathcal{P}_{Z,c}(Z,c)$ 是在给定解析尺度湍流和化学条件下 $Z$ 和 $c$ 的联合概率密度函数。假设统计独立，因此 $\\mathcal{P}_{Z,c}(Z,c) = \\mathcal{P}_Z(Z)\\, \\mathcal{P}_c(c)$，并假设两个边缘分布都是支撑在 $[0,1]$ 上的Beta分布，其参数与给定的过滤后均值和方差一致。\n\n您需要从以下已知的、经过充分测试的建模基础和定义出发：\n- 过滤量定义 $\\widetilde{\\phi} = \\int \\phi\\, \\mathcal{P}\\, d\\boldsymbol{\\xi}$，其中 $\\boldsymbol{\\xi}$ 是一组合适的亚格子变量，$\\mathcal{P}$ 在其支撑集上是归一化的。\n- 一个物理上标准的假定PDF闭合：$\\mathcal{P}_Z$ 和 $\\mathcal{P}_c$ 都是在 $[0,1]$ 上的Beta分布，每个分布都由与其定义一致的均值和方差表征，且 $Z$ 和 $c$ 之间相互独立。\n- 一个在 $[0,1]\\times[0,1]$ 上光滑且有界的列表化流形 $\\dot{\\omega}_c(Z,c)$。\n\n在这个问题中，您需要：\n- 仅使用 $[0,1]$ 上Beta分布的定义关系，从给定的过滤后均值和方差推导出 $\\mathcal{P}_Z$ 和 $\\mathcal{P}_c$ 的Beta分布参数。\n- 在一个均匀中点网格上构建一个列表化流形，并使用一致的求积法对二重积分进行数值评估。\n\n流形构建：\n- 在 $Z$ 方向上定义一个包含 $N_Z$ 个点、在 $c$ 方向上定义一个包含 $N_c$ 个点的均匀中点网格，其中点为 $Z_i = \\frac{i+\\tfrac{1}{2}}{N_Z}$（$i \\in \\{0,1,\\dots,N_Z-1\\}$）和 $c_j = \\frac{j+\\tfrac{1}{2}}{N_c}$（$j \\in \\{0,1,\\dots,N_c-1\\}$）。\n- 在此网格上，通过以下公式定义列表化流形的值：\n$$\n\\dot{\\omega}_c(Z,c) \\;=\\; S_0\\, \\exp\\!\\left(-\\frac{(Z - Z_{\\mathrm{st}})^2}{2\\, \\sigma_Z^2}\\right)\\, c\\,(1-c)\\,\\left[1 + a_1\\, (2Z-1)\\,(2c-1)\\right],\n$$\n其中 $S_0 = 1$，$Z_{\\mathrm{st}} = 0.055$，$\\sigma_Z = 0.08$，且 $a_1 = 0.2$。将所有量视为无量纲；您的最终答案必须以无量纲单位表示。\n\n数值评估：\n- 对列表化网格上的二重积分使用中点矩形法则。如果 $\\mathcal{P}_Z$ 和 $\\mathcal{P}_c$ 在中点处求值，则数值近似为：\n$$\n\\widetilde{\\dot{\\omega}}_c \\;\\approx\\; \\sum_{i=0}^{N_Z-1}\\sum_{j=0}^{N_c-1} \\dot{\\omega}_c(Z_i,c_j)\\, \\mathcal{P}_Z(Z_i)\\, \\mathcal{P}_c(c_j)\\, \\Delta Z\\, \\Delta c,\n$$\n其中 $\\Delta Z = 1/N_Z$ 且 $\\Delta c = 1/N_c$。确保 $\\mathcal{P}_Z$ 和 $\\mathcal{P}_c$ 在连续意义上在 $[0,1]$ 上被正确归一化；在数值实现时，需要将离散权重重新归一化至和为1，以控制求积误差和舍入误差。\n\n输入参数和可容许性：\n- 给定 $\\tilde{Z}$、$\\widetilde{Z''^2}$、$\\tilde{c}$ 和 $\\widetilde{c''^2}$。这些分别对应于 $Z$ 和 $c$ 的均值和方差。对于一个给定的均值 $m$ 和方差 $v$，要存在一个Beta分布，必须满足 $0  m  1$ 和 $0  v  m(1-m)$。\n- 如果任何提供的均值在 $(0,1)$ 之外，通过用 $\\max(\\varepsilon, \\min(1-\\varepsilon, m))$ 替换它，将其限制在开区间内，其中 $\\varepsilon$ 是一个很小的正数。\n- 如果任何提供的方差 $v$ 不严格在 $(0, m(1-m))$ 内，通过用 $\\min\\big(m(1-m) - \\delta, \\max(v_{\\min}, v)\\big)$ 替换它，将其限制在开区间内，其中 $v_{\\min}$ 和 $\\delta$ 是为避免奇异极限而设的很小的正数。\n\nBeta分布参数推导任务：\n- 仅从 $[0,1]$ 上Beta分布的定义（以其两个正形状参数表示的均值和方差）出发，推导与给定均值和方差一致的 $\\mathcal{P}_Z$ 和 $\\mathcal{P}_c$ 的两个形状参数。\n\n计算任务：\n- 实现完整的计算过程，使用 $N_Z = 361$ 和 $N_c = 361$，以及 $\\varepsilon = 10^{-9}$，$v_{\\min} = 10^{-6}$ 和 $\\delta = 10^{-6}$，为以下测试套件中的每个参数集计算 $\\widetilde{\\dot{\\omega}}_c$：\n    - 情况 1：$(\\tilde{Z}, \\widetilde{Z''^2}, \\tilde{c}, \\widetilde{c''^2}) = (0.20, 0.010, 0.60, 0.020)$。\n    - 情况 2：$(\\tilde{Z}, \\widetilde{Z''^2}, \\tilde{c}, \\widetilde{c''^2}) = (0.80, 0.0001, 0.10, 0.0001)$。\n    - 情况 3：$(\\tilde{Z}, \\widetilde{Z''^2}, \\tilde{c}, \\widetilde{c''^2}) = (0.50, 0.200, 0.50, 0.200)$。\n    - 情况 4：$(\\tilde{Z}, \\widetilde{Z''^2}, \\tilde{c}, \\widetilde{c''^2}) = (0.02, 0.0001, 0.98, 0.0001)$。\n    - 情况 5：$(\\tilde{Z}, \\widetilde{Z''^2}, \\tilde{c}, \\widetilde{c''^2}) = (0.35, 0.150, 0.70, 0.150)$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，按情况 1 到 5 的顺序排列。每个条目必须是一个表示 $\\widetilde{\\dot{\\omega}}_c$ 的浮点数，单位为无量纲。例如，输出应如下所示：$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$。\n\n您的实现必须是完全自包含的，并且不能需要任何外部输入。它必须只使用指定的库和环境。通过遵守可容许性和限制规则，确保科学真实性和数值稳定性。在所述假设和定义下，该计算必须是通用的和普遍适用的。",
            "solution": "用户提供的问题陈述经过严格评估并被确定为有效。它在湍流燃烧模拟领域具有科学依据，在数学上是适定的，并且表述客观。所有必需的数据、模型和数值程序都已明确指定，从而可以得到一个唯一且有意义的解。因此，我们可以着手进行推导和计算实现。\n\n该问题要求在一个小火焰生成流形 (FGM) 框架内计算过滤后的进程变量源项 $\\widetilde{\\dot{\\omega}}_c$。问题的核心在于将一个列表化的化学源项 $\\dot{\\omega}_c(Z,c)$ 与混合分数 $Z$ 和进程变量 $c$ 的亚格子尺度统计量耦合起来。过滤后的源项由以下积分给出：\n$$\n\\widetilde{\\dot{\\omega}}_c = \\int_0^1 \\int_0^1 \\dot{\\omega}_c(Z,c)\\, \\mathcal{P}_{Z,c}(Z,c)\\, dZ\\, dc\n$$\n在统计独立的假设下，联合概率密度函数 (PDF) $\\mathcal{P}_{Z,c}(Z,c)$ 被分解为其边缘分布：$\\mathcal{P}_{Z,c}(Z,c) = \\mathcal{P}_Z(Z)\\, \\mathcal{P}_c(c)$。两个边缘PDF都假定为Beta分布，这对于在区间 $[0,1]$ 上有界的标量变量来说，是一个标准的、物理上合适的选择。\n\n首要任务是从Beta分布的均值 $\\mu$ 和方差 $\\sigma^2$ 推导出其形状参数 $\\alpha$ 和 $\\beta$。一个支撑在 $[0,1]$ 上的随机变量 $X \\sim \\text{Beta}(\\alpha, \\beta)$ 具有以下均值和方差：\n$$\n\\mu = \\mathbb{E}[X] = \\frac{\\alpha}{\\alpha + \\beta}\n$$\n$$\n\\sigma^2 = \\text{Var}[X] = \\frac{\\alpha \\beta}{(\\alpha + \\beta)^2 (\\alpha + \\beta + 1)}\n$$\n我们的目标是解这个包含两个未知数 $\\alpha$ 和 $\\beta$ 的二元方程组。从均值方程中，我们可以将参数之和表示为 $\\alpha + \\beta = \\alpha / \\mu$。将其代入方差方程：\n$$\n\\sigma^2 = \\frac{\\alpha \\beta}{(\\alpha/\\mu)^2 (\\alpha/\\mu + 1)} = \\frac{\\mu^2 \\beta}{\\alpha(\\alpha/\\mu + 1)}\n$$\n一个更直接的方法是首先认识到方差可以用均值来表示：\n$$\n\\sigma^2 = \\left(\\frac{\\alpha}{\\alpha + \\beta}\\right) \\left(\\frac{\\beta}{\\alpha + \\beta}\\right) \\frac{1}{\\alpha + \\beta + 1} = \\mu (1-\\mu) \\frac{1}{\\alpha + \\beta + 1}\n$$\n从这个简化关系中，我们可以解出项 $\\alpha + \\beta + 1$：\n$$\n\\alpha + \\beta + 1 = \\frac{\\mu(1-\\mu)}{\\sigma^2}\n$$\n让我们定义一个公共因子 $\\nu = \\frac{\\mu(1-\\mu)}{\\sigma^2} - 1$。那么我们有 $\\alpha + \\beta = \\nu$。为了使 $\\alpha$ 和 $\\beta$ 为正，要求 $\\nu > 0$，这意味着 $\\frac{\\mu(1-\\mu)}{\\sigma^2} > 1$，即 $\\sigma^2  \\mu(1-\\mu)$。这就是问题陈述中指定的物理可实现性条件。\n现在，我们可以解出 $\\alpha$ 和 $\\beta$。根据均值的定义，$\\alpha = \\mu(\\alpha+\\beta) = \\mu \\nu$。将此代入总和中得到 $\\beta = \\nu - \\alpha = \\nu - \\mu\\nu = \\nu(1-\\mu)$。\n因此，形状参数由以下公式给出：\n$$\n\\alpha = \\mu \\left( \\frac{\\mu(1-\\mu)}{\\sigma^2} - 1 \\right)\n$$\n$$\n\\beta = (1-\\mu) \\left( \\frac{\\mu(1-\\mu)}{\\sigma^2} - 1 \\right)\n$$\n在应用指定的限制（clamping）程序以确保输入 $(\\mu, \\sigma^2)$ 满足条件 $0  \\mu  1$ 和 $0  \\sigma^2  \\mu(1-\\mu)$ 后，这些公式将用于从 $(\\tilde{Z}, \\widetilde{Z''^2})$ 确定 $\\mathcal{P}_Z(Z)$ 的参数，以及从 $(\\tilde{c}, \\widetilde{c''^2})$ 确定 $\\mathcal{P}_c(c)$ 的参数。\n\n计算过程如下：\n1.  对于每个输入集 $(\\tilde{Z}, \\widetilde{Z''^2}, \\tilde{c}, \\widetilde{c''^2})$，应用限制（clamping）。\n    - 将均值 $\\tilde{Z}$ 和 $\\tilde{c}$ 限制在 $[\\varepsilon, 1-\\varepsilon]$ 范围内。设限制后的均值为 $m_Z$ 和 $m_c$。\n    - 限制方差 $\\widetilde{Z''^2}$ 和 $\\widetilde{c''^2}$。对于一个通用均值 $m$ 和方差 $v$，限制后的方差 $v'$ 通过 $v' = \\min\\big(m(1-m) - \\delta, \\max(v_{\\min}, v)\\big)$ 计算得出。设限制后的方差为 $v_Z$ 和 $v_c$。\n\n2.  使用限制后的 $(m_Z, v_Z)$ 计算Beta分布的形状参数 $(\\alpha_Z, \\beta_Z)$，并使用限制后的 $(m_c, v_c)$ 计算 $(\\alpha_c, \\beta_c)$，应用推导出的公式。\n\n3.  构建数值网格和源项流形。\n    - 定义均匀中点网格：$Z_i = \\frac{i+0.5}{N_Z}$（$i \\in \\{0, \\dots, N_Z-1\\}$）和 $c_j = \\frac{j+0.5}{N_c}$（$j \\in \\{0, \\dots, N_c-1\\}$）。步长为 $\\Delta Z = 1/N_Z$ 和 $\\Delta c = 1/N_c$。\n    - 使用提供的函数在 $N_Z \\times N_c$ 网格的每个点上计算源项 $\\dot{\\omega}_c(Z_i, c_j)$：\n      $$\n      \\dot{\\omega}_c(Z,c) = S_0\\, \\exp\\!\\left(-\\frac{(Z - Z_{\\mathrm{st}})^2}{2\\, \\sigma_Z^2}\\right)\\, c\\,(1-c)\\,\\left[1 + a_1\\, (2Z-1)\\,(2c-1)\\right]\n      $$\n      参数为 $S_0 = 1$，$Z_{\\mathrm{st}} = 0.055$，$\\sigma_Z = 0.08$ 和 $a_1 = 0.2$。\n\n4.  在网格上计算PDF。\n    - Beta-PDF为 $\\mathcal{P}(x; \\alpha, \\beta) = \\frac{x^{\\alpha-1}(1-x)^{\\beta-1}}{B(\\alpha, \\beta)}$，其中 $B(\\alpha, \\beta)$ 是Beta函数。\n    - 使用参数 $(\\alpha_Z, \\beta_Z)$ 计算 $\\mathcal{P}_Z(Z_i)$。\n    - 使用参数 $(\\alpha_c, \\beta_c)$ 计算 $\\mathcal{P}_c(c_j)$。\n\n5.  使用中点法则计算二重积分并应用归一化。\n    - 原始积分由以下求和近似：\n      $$\n      I_{\\text{raw}} = \\sum_{i=0}^{N_Z-1}\\sum_{j=0}^{N_c-1} \\dot{\\omega}_c(Z_i,c_j)\\, \\mathcal{P}_Z(Z_i)\\, \\mathcal{P}_c(c_j)\\, \\Delta Z\\, \\Delta c\n      $$\n    - 为校正PDF表示中的求积误差，我们通过PDF本身的数值积分进行归一化：\n      $$\n      N_Z^{\\text{norm}} = \\sum_{i=0}^{N_Z-1} \\mathcal{P}_Z(Z_i) \\Delta Z \\quad \\text{和} \\quad N_c^{\\text{norm}} = \\sum_{j=0}^{N_c-1} \\mathcal{P}_c(c_j) \\Delta c\n      $$\n    - 最终归一化后的过滤源项为：\n      $$\n      \\widetilde{\\dot{\\omega}}_c = \\frac{I_{\\text{raw}}}{N_Z^{\\text{norm}} N_c^{\\text{norm}}}\n      $$\n此过程将为提供的五个测试用例中的每一个实现。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import beta as beta_dist\n\ndef solve():\n    \"\"\"\n    Computes the filtered progress source term in a flamelet-generated manifold framework.\n    \"\"\"\n\n    # --- Problem Constants and Parameters ---\n    # Manifold constants\n    S0 = 1.0\n    Z_st = 0.055\n    sigma_Z_manifold = 0.08\n    a1 = 0.2\n\n    # Numerical parameters\n    N_Z = 361\n    N_c = 361\n    \n    # Clamping parameters\n    epsilon = 1e-9\n    v_min = 1e-6\n    delta = 1e-6\n\n    # --- Test Cases ---\n    test_cases = [\n        # (Z_mean, Z_var, c_mean, c_var)\n        (0.20, 0.010, 0.60, 0.020),\n        (0.80, 0.0001, 0.10, 0.0001),\n        (0.50, 0.200, 0.50, 0.200),\n        (0.02, 0.0001, 0.98, 0.0001),\n        (0.35, 0.150, 0.70, 0.150),\n    ]\n\n    results = []\n\n    # --- Grid Generation ---\n    # Uniform midpoint grids for Z and c\n    dZ = 1.0 / N_Z\n    dc = 1.0 / N_c\n    Z_grid = (np.arange(N_Z) + 0.5) * dZ\n    c_grid = (np.arange(N_c) + 0.5) * dc\n\n    # --- Manifold Generation ---\n    # 2D grid for evaluating the manifold\n    Z_mesh, c_mesh = np.meshgrid(Z_grid, c_grid, indexing='ij')\n\n    # Evaluate the source term manifold omega_c(Z,c)\n    term_gauss = np.exp(-((Z_mesh - Z_st)**2) / (2 * sigma_Z_manifold**2))\n    term_c = c_mesh * (1.0 - c_mesh)\n    term_coupling = 1.0 + a1 * (2*Z_mesh - 1) * (2*c_mesh - 1)\n    omega_c_manifold = S0 * term_gauss * term_c * term_coupling\n\n    for case in test_cases:\n        Z_mean_in, Z_var_in, c_mean_in, c_var_in = case\n\n        # Helper function for parameter calculation process\n        def process_scalar(mean_in, var_in):\n            # Step 1: Clamp mean and variance\n            m = np.clip(mean_in, epsilon, 1.0 - epsilon)\n            v_max = m * (1.0 - m)\n            v = np.clip(var_in, v_min, v_max - delta)\n            \n            # Step 2: Derive Beta distribution parameters\n            # nu = m(1-m)/v - 1\n            # alpha = m * nu\n            # beta = (1-m) * nu\n            common_factor = m * (1.0 - m) / v - 1.0\n            alpha = m * common_factor\n            beta = (1.0 - m) * common_factor\n            return alpha, beta\n\n        # --- PDF Parameter Calculation ---\n        alpha_Z, beta_Z = process_scalar(Z_mean_in, Z_var_in)\n        alpha_c, beta_c = process_scalar(c_mean_in, c_var_in)\n\n        # --- PDF Evaluation ---\n        # Evaluate Beta PDFs on their respective grids\n        P_Z = beta_dist.pdf(Z_grid, alpha_Z, beta_Z)\n        P_c = beta_dist.pdf(c_grid, alpha_c, beta_c)\n\n        # --- Numerical Integration ---\n        # Combine terms for the integrand: omega_c(Z,c) * P(Z) * P(c)\n        # Using broadcasting for efficiency:\n        # P_Z shape: (N_Z,), P_c shape: (N_c,)\n        # Reshape to (N_Z, 1) and (1, N_c) for broadcasting with (N_Z, N_c) manifold\n        integrand = omega_c_manifold * P_Z[:, np.newaxis] * P_c[np.newaxis, :]\n        \n        # Perform summation and multiply by cell area (dZ * dc)\n        raw_integral = np.sum(integrand) * dZ * dc\n\n        # --- Normalization ---\n        # Normalize to correct for quadrature error of the PDFs\n        norm_Z = np.sum(P_Z) * dZ\n        norm_c = np.sum(P_c) * dc\n        \n        # Handle potential for zero normalization factor, although unlikely with clamping\n        if norm_Z * norm_c > 0:\n            filtered_omega_c = raw_integral / (norm_Z * norm_c)\n        else:\n            filtered_omega_c = 0.0\n\n        results.append(filtered_omega_c)\n\n    # --- Format and Print Output ---\n    # The output string must be a comma-separated list in brackets\n    output_str = \"[\" + \",\".join(f\"{res:.8f}\" for res in results) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}