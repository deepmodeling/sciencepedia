{
    "hands_on_practices": [
        {
            "introduction": "要有效使用后向差分格式（BDF）方法，理解其构造原理至关重要。本练习 () 将指导你推导一个特定的BDF公式（BDF-3）的系数，并验证其稳定性，这是任何可靠数值方法的两大支柱。通过这个过程，你将深入理解精度阶数和零稳定性这些核心概念是如何在实践中确立的。",
            "id": "4008853",
            "problem": "在计算燃烧学中，组分质量分数向量 $\\boldsymbol{Y}(t)$ 的刚性化学动力学通常通过形式为 $d\\boldsymbol{Y}/dt = \\boldsymbol{\\omega}(\\boldsymbol{Y},T)/\\rho$ 的常微分方程（ODE）组进行建模，其中 $\\boldsymbol{\\omega}$ 是反应源项，$T$ 是温度，$\\rho$ 是密度。为了在步长为 $h$ 的均匀时间网格上可靠地推进这个刚性系统，通常使用隐式线性多步法，特别是后向差分格式（BDF）。$k$ 阶后向差分格式（BDF）的构造方式使其在 $t_{n+1}$ 处的离散时间导数对于最高为 $k$ 次的多项式是精确的；对于 $k=3$，这确保了局部截断误差为 $h^{4}$ 阶，并且要求多步法具有零稳定性，以便在不受动力学刚性影响的情况下控制扰动的传播。\n\n考虑均匀网格 $t_{n+1-j} = t_{n+1} - j h$，$j=0,1,2,3$。一个 $k=3$ 的后向差分格式可以写成具有常系数的线性多步形式 $\\sum_{j=0}^{3} \\alpha_j \\, \\boldsymbol{Y}_{n+1-j} = h \\, \\beta \\, \\boldsymbol{f}(t_{n+1}, \\boldsymbol{Y}_{n+1})$，其中 $\\boldsymbol{f}$ 表示动力学ODE的右端项。系数 $(\\alpha_0,\\alpha_1,\\alpha_2,\\alpha_3,\\beta)$ 的选择是为了强制其对最高为3次的多项式精确，从而达到3阶精度，并满足线性多步法零稳定性的根条件。\n\n哪个选项正确地指定了均匀网格上BDF-3的系数 $(\\alpha_0,\\alpha_1,\\alpha_2,\\alpha_3,\\beta)$，并对其如何保证3阶精度同时保持零稳定性提供了合理的解释？\n\nA. $(\\alpha_0,\\alpha_1,\\alpha_2,\\alpha_3,\\beta) = (\\,1,\\,-3/2,\\,1/2,\\,0,\\,1\\,)$，声称匹配最高3次的多项式可得到3阶精度，并且特征多项式在 $z=1$ 处有一个单根，其他根严格位于单位圆内，因此该方法是零稳定的。\n\nB. $(\\alpha_0,\\alpha_1,\\alpha_2,\\alpha_3,\\beta) = (\\,1,\\,-18/11,\\,9/11,\\,-2/11,\\,6/11\\,)$，解释是这些系数是通过要求 $t_{n+1}$ 处的离散导数对 $y(t)=t^m$（$m=0,1,2,3$）精确而得到的，这保证了3阶精度，并且特征多项式 $\\rho(z) = z^{3} - (18/11) z^{2} + (9/11) z - (2/11)$ 在 $z=1$ 处有一个单根，另外两个根严格位于单位圆内，证明了零稳定性。\n\nC. $(\\alpha_0,\\alpha_1,\\alpha_2,\\alpha_3,\\beta) = (\\,1,\\,-3,\\,3,\\,-1,\\,1\\,)$，断言此格式是精确的三阶后向差分，因此达到3阶精度，并且特征多项式的所有根都位于单位圆内或圆上，确保了零稳定性。\n\nD. $(\\alpha_0,\\alpha_1,\\alpha_2,\\alpha_3,\\beta) = (\\,1,\\,-18/11,\\,9/11,\\,-2/11,\\,3/11\\,)$，理由是对三次多项式的精确性和单位圆根的构型确保了3阶精度和零稳定性，并且较小的 $\\beta$ 值在不改变阶数的情况下改善了刚性问题的处理。",
            "solution": "在进行求解之前，审查问题陈述的有效性。\n\n### 步骤1：提取已知条件\n- 控制组分质量分数 $\\boldsymbol{Y}(t)$ 的常微分方程（ODE）组为 $d\\boldsymbol{Y}/dt = \\boldsymbol{\\omega}(\\boldsymbol{Y},T)/\\rho$，我们将其记为 $d\\boldsymbol{Y}/dt = \\boldsymbol{f}(t, \\boldsymbol{Y})$。\n- 该系统被描述为刚性化学动力学。\n- 使用步长为 $h$ 的均匀时间网格，其中 $t_{n+1-j} = t_{n+1} - j h$，$j=0,1,2,3$。\n- 数值方法是3阶（$k=3$）后向差分格式（BDF）。\n- 问题陈述指出，$k$ 阶BDF的构造方式使其在 $t_{n+1}$ 处的离散时间导数对最高为 $k$ 次的多项式是精确的。\n- 该方法被指定具有 $h^4$ 阶的局部截断误差（LTE），这对应于 $p=k=3$ 的全局精度阶。\n- 要求零稳定性。\n- 线性多步法写为 $\\sum_{j=0}^{3} \\alpha_j \\, \\boldsymbol{Y}_{n+1-j} = h \\, \\beta \\, \\boldsymbol{f}(t_{n+1}, \\boldsymbol{Y}_{n+1})$ 的形式。\n- 系数 $(\\alpha_0,\\alpha_1,\\alpha_2,\\alpha_3,\\beta)$ 必须根据3阶精度和零稳定性的条件来确定。\n\n### 步骤2：使用提取的已知条件进行验证\n问题陈述在科学上是合理的、适定的和客观的。\n- **科学依据：** 该问题准确地描述了BDF方法在刚性ODE中的标准应用，这是数值分析和计算科学（尤其是在计算燃烧学等领域）中的一个基本课题。BDF、精度阶、局部截断误差和零稳定性的定义都得到了正确呈现，并与既定理论一致。\n- **适定性：** 任务是基于清晰的数学标准，为一个明确定义的数值方法（BDF-3）推导出一组唯一的系数。这是一个标准的、可解的问题。\n- **客观性和完整性：** 问题以精确、无歧义的技术语言陈述。它提供了直接或通过BDF方法的定义来推导系数和评估稳定性所需的所有必要信息。\n\n### 步骤3：结论与行动\n问题是 **有效的**。将推导解答并评估各个选项。\n\n### BDF-3系数的推导\n\n$k$ 阶后向差分格式（BDF）是通过用一个唯一的、次数最多为 $k$ 的多项式 $P(t)$ 的导数来近似导数 $y'(t_{n+1})$ 而构造的，该多项式在 $k+1$ 个点上对解值进行插值。对于 $k=3$，多项式 $P(t)$ 对点 $(t_{n+1}, Y_{n+1})$、$(t_n, Y_n)$、$(t_{n-1}, Y_{n-1})$ 和 $(t_{n-2}, Y_{n-2})$ 进行插值。那么BDF-3方法由 $P'(t_{n+1}) = f(t_{n+1}, Y_{n+1})$ 给出。\n\n找到 $P'(t_{n+1})$ 的一个系统方法是使用牛顿后向差分公式来构造插值多项式。令 $s = (t - t_{n+1})/h$。多项式 $P(t)$ 可以用 $s$ 和后向差分算子 $\\nabla$ 表示为：\n$$P(t_{n+1}+sh) = Y_{n+1} + s \\nabla Y_{n+1} + \\frac{s(s+1)}{2!} \\nabla^2 Y_{n+1} + \\frac{s(s+1)(s+2)}{3!} \\nabla^3 Y_{n+1}$$\n其中 $\\nabla Y_{n+1} = Y_{n+1} - Y_n$，$\\nabla^2 Y_{n+1} = \\nabla(\\nabla Y_{n+1}) = Y_{n+1} - 2Y_n + Y_{n-1}$，以及 $\\nabla^3 Y_{n+1} = Y_{n+1} - 3Y_n + 3Y_{n-1} - Y_{n-2}$。\n\n为了找到 $P'(t_{n+1})$，我们对 $t$ 求导，并在 $t=t_{n+1}$ (对应于 $s=0$) 处求值。\n$$\\frac{dP}{dt} = \\frac{dP}{ds} \\frac{ds}{dt} = \\frac{1}{h} \\frac{dP}{ds}$$\n$$\\frac{dP}{ds} = \\nabla Y_{n+1} + \\frac{2s+1}{2} \\nabla^2 Y_{n+1} + \\frac{3s^2+6s+2}{6} \\nabla^3 Y_{n+1}$$\n在 $s=0$ 处求值：\n$$P'(t_{n+1}) = \\frac{1}{h} \\left( \\nabla Y_{n+1} + \\frac{1}{2} \\nabla^2 Y_{n+1} + \\frac{1}{3} \\nabla^3 Y_{n+1} \\right)$$\nBDF-3公式为 $P'(t_{n+1}) = f_{n+1}$，因此：\n$$h f_{n+1} = \\nabla Y_{n+1} + \\frac{1}{2} \\nabla^2 Y_{n+1} + \\frac{1}{3} \\nabla^3 Y_{n+1}$$\n代入后向差分的展开形式：\n$$h f_{n+1} = (Y_{n+1} - Y_n) + \\frac{1}{2}(Y_{n+1} - 2Y_n + Y_{n-1}) + \\frac{1}{3}(Y_{n+1} - 3Y_n + 3Y_{n-1} - Y_{n-2})$$\n对每个 $Y_{n+1-j}$ 合并同类项：\n$$h f_{n+1} = Y_{n+1}\\left(1 + \\frac{1}{2} + \\frac{1}{3}\\right) + Y_n\\left(-1 - \\frac{2}{2} - \\frac{3}{3}\\right) + Y_{n-1}\\left(\\frac{1}{2} + \\frac{3}{3}\\right) + Y_{n-2}\\left(-\\frac{1}{3}\\right)$$\n$$h f_{n+1} = Y_{n+1}\\left(\\frac{11}{6}\\right) - 3 Y_n + \\frac{3}{2} Y_{n-1} - \\frac{1}{3} Y_{n-2}$$\n为了匹配 $\\sum_{j=0}^{3} \\alpha_j \\, Y_{n+1-j} = h \\, \\beta \\, f_{n+1}$ 的形式并采用常规的归一化 $\\alpha_0 = 1$，我们将整个方程除以 $11/6$：\n$$Y_{n+1} - \\frac{3 \\cdot 6}{11} Y_n + \\frac{3/2 \\cdot 6}{11} Y_{n-1} - \\frac{1/3 \\cdot 6}{11} Y_{n-2} = h \\frac{6}{11} f_{n+1}$$\n$$Y_{n+1} - \\frac{18}{11} Y_n + \\frac{9}{11} Y_{n-1} - \\frac{2}{11} Y_{n-2} = h \\frac{6}{11} f_{n+1}$$\n由此，我们确定系数：\n$\\alpha_0 = 1$\n$\\alpha_1 = -18/11$\n$\\alpha_2 = 9/11$\n$\\alpha_3 = -2/11$\n$\\beta = 6/11$\n系数集为 $(\\alpha_0, \\alpha_1, \\alpha_2, \\alpha_3, \\beta) = (1, -18/11, 9/11, -2/11, 6/11)$。\n\n### 零稳定性的验证\n\n零稳定性由第一特征多项式 $\\rho(z)$ 的根决定。对于形式为 $\\sum_{j=0}^{k} \\alpha_j Y_{n+1-j} = \\dots$ 的方法，特征多项式通常写作 $\\rho(z) = \\sum_{j=0}^{k} \\alpha_j z^{k-j}$。然而，在标准形式 $\\sum_{i=0}^k a_i y_{n+i} = \\dots$ 中，多项式是 $\\sum_{i=0}^k a_i z^i$。通过重新标记索引，我们发现 $\\rho(z) = \\alpha_0 z^3 + \\alpha_1 z^2 + \\alpha_2 z + \\alpha_3$。\n使用我们推导出的系数：\n$$\\rho(z) = z^3 - \\frac{18}{11} z^2 + \\frac{9}{11} z - \\frac{2}{11}$$\n零稳定性的根条件要求 $\\rho(z)$ 的所有根都满足 $|z| \\leq 1$，并且任何模为1的根都必须是单根。\n对于一个相容的方法，$z=1$ 必须是一个根。我们来检验一下：\n$$\\rho(1) = 1 - \\frac{18}{11} + \\frac{9}{11} - \\frac{2}{11} = \\frac{11 - 18 + 9 - 2}{11} = \\frac{0}{11} = 0$$\n所以，$z=1$ 是一个根。为了找到其他根，我们将多项式 $11\\rho(z) = 11z^3 - 18z^2 + 9z - 2$ 除以 $(z-1)$：\n$$(11z^3 - 18z^2 + 9z - 2) \\div (z-1) = 11z^2 - 7z + 2$$\n剩下的根由二次方程 $11z^2 - 7z + 2 = 0$ 给出。使用求根公式：\n$$z = \\frac{-(-7) \\pm \\sqrt{(-7)^2 - 4(11)(2)}}{2(11)} = \\frac{7 \\pm \\sqrt{49 - 88}}{22} = \\frac{7 \\pm \\sqrt{-39}}{22} = \\frac{7 \\pm i\\sqrt{39}}{22}$$\n这些共轭复根的模的平方为：\n$$|z|^2 = \\left(\\frac{7}{22}\\right)^2 + \\left(\\frac{\\sqrt{39}}{22}\\right)^2 = \\frac{49 + 39}{22^2} = \\frac{88}{484} = \\frac{2 \\times 44}{11 \\times 44} = \\frac{2}{11}$$\n因为 $|z|^2 = 2/11  1$，所以复数根的模为 $|z| = \\sqrt{2/11}  1$。\n$\\rho(z)$ 的根是 $z_1=1$ 和 $z_{2,3} = (7 \\pm i\\sqrt{39})/22$。我们在单位圆上有一个单根，另外两个根严格位于单位圆内部。这满足了根条件，所以该方法是零稳定的。\n\n### 逐项分析选项\n\nA. $(\\alpha_0,\\alpha_1,\\alpha_2,\\alpha_3,\\beta) = (\\,1,\\,-3/2,\\,1/2,\\,0,\\,1\\,)$\n系数 $\\alpha_3=0$ 表明这是一个 $k=2$（两步）方法，而不是 $k=3$ 的方法。这是BDF-2方法的一种形式，其阶数为2，而不是3。所提供的系数 $1, -3/2, 1/2$ 甚至不是 BDF-2 的正确归一化形式（应为 $1, -4/3, 1/3$）。该选项在其前提和系数上都是根本错误的。\n**结论：不正确。**\n\nB. $(\\alpha_0,\\alpha_1,\\alpha_2,\\alpha_3,\\beta) = (\\,1,\\,-18/11,\\,9/11,\\,-2/11,\\,6/11\\,)$\n这些是在归一化 $\\alpha_0=1$ 的条件下为 BDF-3 推导出的精确系数。关于这些系数通过对最高3次多项式精确来保证3阶精度的解释，正是该方法精度的定义。特征多项式 $\\rho(z) = z^{3} - (18/11) z^{2} + (9/11) z - (2/11)$ 是正确的，并且关于它在 $z=1$ 处有一个单根、另外两个根严格位于单位圆内的分析也是正确的，正如我们的推导所示。这证实了零稳定性。该选项完全正确。\n**结论：正确。**\n\nC. $(\\alpha_0,\\alpha_1,\\alpha_2,\\alpha_3,\\beta) = (\\,1,\\,-3,\\,3,\\,-1,\\,1\\,)$\n由这些 $\\alpha_j$ 系数定义的算子是 $Y_{n+1} - 3Y_n + 3Y_{n-1} - Y_{n-2} = \\nabla^3 Y_{n+1}$，它是 $h^3 Y'''$ 的一个近似。将其设为 $h \\beta f_{n+1} = h Y'_{n+1}$ 会导致一个不相容的方法。第一特征多项式是 $\\rho(z) = z^3-3z^2+3z-1 = (z-1)^3$。这个多项式在 $z=1$ 处有一个3重根。由于零稳定性要求单位圆上的根必须是单根，所以该方法不是零稳定的。\n**结论：不正确。**\n\nD. $(\\alpha_0,\\alpha_1,\\alpha_2,\\alpha_3,\\beta) = (\\,1,\\,-18/11,\\,9/11,\\,-2/11,\\,3/11\\,)$\n$\\alpha_j$ 系数对于 BDF-3 是正确的。然而，$\\beta$ 系数是错误的。为了使一个线性多步法是相容的（阶数 $p \\ge 1$），它必须满足 $\\rho(1)=0$ 和 $\\rho'(1)=\\sigma(1)$。这里 $\\rho(z) = z^3 - (18/11)z^2 + (9/11)z - (2/11)$，我们已经求得 $\\rho'(1)=6/11$。第二特征多项式是 $\\sigma(z) = \\beta z^3$，所以 $\\sigma(1)=\\beta$。相容性要求 $\\beta=6/11$。此选项提供了 $\\beta=3/11$，所以该方法不相容，因此阶数不可能为3。其理由是有缺陷的。\n**结论：不正确。**",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "BDF方法是隐式的，需要在每个时间步求解一个非线性代数方程组。本练习 () 通过聚焦于单次牛顿-拉弗森迭代（求解这些方程的主力方法），揭示了这一过程的奥秘，并展示了系统的雅可比矩阵在其中扮演的关键角色。掌握这一机制对于理解隐式求解器如何处理刚性问题至关重要。",
            "id": "4008896",
            "problem": "考虑计算燃烧学中的一个单物种单分子衰变问题，其中质量分数 $y$ 的演化遵循常微分方程 $y' = f(y) = -k(T)\\,y$。这里，$k(T)$ 由固定温度 $T$ 下的阿伦尼乌斯速率常数给出，$y$ 是一个无量纲的质量分数。时间积分在步长为 $h0$ 的均匀时间网格上，使用二阶向后差分格式 (BDF) 方法，具体为 BDF-$2$ 公式进行。BDF-$2$ 离散化是一个经过充分检验的公式，通过对经过连续三个点的二次插值多项式求导得到，其产生的关系式为\n$$\n\\frac{3\\,y_{n} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} = f(y_{n}) \\, ,\n$$\n该式定义了在给定已知值 $y_{n-1}$ 和 $y_{n-2}$ 的情况下，$y_{n}$ 在时间索引 $n$ 处必须满足的隐式代数方程。\n\n在时间索引 $n$ 处，使用单次牛顿迭代来求解此隐式方程。令 $y_{n}^{(m)}$ 表示当前的牛顿迭代值。该隐式方程的残差为\n$$\nR\\!\\left(y_{n}^{(m)}\\right) = \\frac{3\\,y_{n}^{(m)} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} - f\\!\\left(y_{n}^{(m)}\\right) \\, ,\n$$\n动力学关于 $y$ 的雅可比矩阵为 $J = \\frac{\\partial f}{\\partial y} = -k(T)$，由于温度 $T$ 固定，在步长内该雅可比矩阵被视为常数。\n\n从这些基本原理出发，推导求解当前迭代值 $y_{n}^{(m)}$ 处 BDF-$2$ 隐式方程的线性化系统的标量牛顿更新量 $\\Delta y_{n}^{(m)}$，使用 $J=-k(T)$。将 $\\Delta y_{n}^{(m)}$ 表示为 $y_{n}^{(m)}$、$y_{n-1}$、$y_{n-2}$、$h$ 和 $k(T)$ 的函数的闭式解。将你的最终答案表示为 $\\Delta y_{n}^{(m)}$ 的单个闭式解析表达式。无需进行数值近似或舍入，并且由于 $y$ 是无量纲的，最终表达式中不应包含任何物理单位。",
            "solution": "动力学由常微分方程 $y' = f(y) = -k(T)\\,y$ 定义，其中由于温度 $T$ 固定，$k(T)$ 在时间步长内被视为常数。在步长为 $h$ 的均匀时间网格上使用二阶向后差分格式 (BDF-$2$)，定义 $y_{n}$ 与 $y_{n-1}$ 和 $y_{n-2}$ 关系的隐式关系式是一个经过充分检验的公式：\n$$\n\\frac{3\\,y_{n} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} = f(y_{n}) \\, .\n$$\n重新整理该方程以定义残差函数 $R(y_{n})$，得到：\n$$\nR(y_{n}) = \\frac{3\\,y_{n} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} - f(y_{n}) \\, .\n$$\n一次牛顿迭代在当前迭代值 $y_{n}^{(m)}$ 处对残差进行线性化，并通过求解以下方程来计算更新量 $\\Delta y_{n}^{(m)}$：\n$$\n\\left(\\frac{\\partial R}{\\partial y}\\bigg|_{y=y_{n}^{(m)}}\\right)\\,\\Delta y_{n}^{(m)} = -R\\!\\left(y_{n}^{(m)}\\right) \\, .\n$$\n我们现在计算 $R(y)$ 在 $y_{n}^{(m)}$ 处关于 $y$ 的导数。残差是 $y_{n}$ 的一个线性项与非线性动力学项 $f(y_{n})$ 之差，所以：\n$$\n\\frac{\\partial R}{\\partial y}\\bigg|_{y=y_{n}^{(m)}} = \\frac{3}{2\\,h} - \\frac{\\partial f}{\\partial y}\\bigg|_{y=y_{n}^{(m)}} \\, .\n$$\n对于给定的动力学 $f(y) = -k(T)\\,y$，关于 $y$ 的雅可比矩阵为：\n$$\nJ = \\frac{\\partial f}{\\partial y} = -k(T) \\, .\n$$\n将 $J = -k(T)$ 代入 $\\frac{\\partial R}{\\partial y}$ 的表达式中，得到：\n$$\n\\frac{\\partial R}{\\partial y}\\bigg|_{y=y_{n}^{(m)}} = \\frac{3}{2\\,h} - \\left(-k(T)\\right) = \\frac{3}{2\\,h} + k(T) \\, .\n$$\n在 $y_{n}^{(m)}$ 处计算的残差为：\n$$\nR\\!\\left(y_{n}^{(m)}\\right) = \\frac{3\\,y_{n}^{(m)} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} - \\left(-k(T)\\,y_{n}^{(m)}\\right) = \\frac{3\\,y_{n}^{(m)} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} + k(T)\\,y_{n}^{(m)} \\, .\n$$\n因此，牛顿更新量 $\\Delta y_{n}^{(m)}$ 满足：\n$$\n\\left(\\frac{3}{2\\,h} + k(T)\\right)\\,\\Delta y_{n}^{(m)} = -\\left[\\frac{3\\,y_{n}^{(m)} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} + k(T)\\,y_{n}^{(m)}\\right] \\, .\n$$\n求解 $\\Delta y_{n}^{(m)}$ 得到闭式标量更新量：\n$$\n\\Delta y_{n}^{(m)} = -\\frac{\\frac{3\\,y_{n}^{(m)} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} + k(T)\\,y_{n}^{(m)}}{\\frac{3}{2\\,h} + k(T)} \\, .\n$$\n该表达式是牛顿修正量，当其加到 $y_{n}^{(m)}$ 上时，得到下一个迭代值 $y_{n}^{(m+1)} = y_{n}^{(m)} + \\Delta y_{n}^{(m)}$。因为 $f(y)$ 是 $y$ 的线性函数，牛顿迭代在一步内收敛到精确的隐式解，但所要求的量是用 $y_{n}^{(m)}$、$y_{n-1}$、$y_{n-2}$、$h$ 和 $k(T)$ 表示的显式牛顿更新量 $\\Delta y_{n}^{(m)}$，这正是我们上面推导出的结果。",
            "answer": "$$\\boxed{-\\frac{\\frac{3\\,y_{n}^{(m)} - 4\\,y_{n-1} + y_{n-2}}{2\\,h} + k(T)\\,y_{n}^{(m)}}{\\frac{3}{2\\,h} + k(T)}}$$"
        },
        {
            "introduction": "在理解了理论和核心求解步骤之后，是时候见证BDF方法的实际应用了。本练习 () 将一个变阶数、变步长的BDF求解器应用于经典的罗伯逊问题（Robertson problem），这是一个化学动力学刚性问题的标准基准测试。通过解决这个著名的挑战，你将亲身体验这些方法在处理具有巨大时间尺度差异的系统时的强大威力。",
            "id": "2372608",
            "problem": "构建一个完整的、可运行的程序，使用变阶、变步长的后向差分公式（BDF）来近似求解一个刚性常微分方程（ODE）组的解。目标模型是 Robertson 化学动力学系统，该系统由浓度 $y_1(t)$、$y_2(t)$ 和 $y_3(t)$ 定义如下：\n$$\n\\frac{d y_1}{d t} = -0.04\\, y_1 + 10^{4}\\, y_2\\, y_3,\\quad\n\\frac{d y_2}{d t} = 0.04\\, y_1 - 10^{4}\\, y_2\\, y_3 - 3\\times 10^{7}\\, y_2^{2},\\quad\n\\frac{d y_3}{d t} = 3\\times 10^{7}\\, y_2^{2},\n$$\n初始条件为\n$$\ny_1(0)=1,\\quad y_2(0)=0,\\quad y_3(0)=0,\n$$\n时间域为 $t\\in[0, T]$。所有因变量均为无量纲，时间 $t$ 的单位为秒。程序必须实现时间自适应和阶数自适应，以使数值近似值在给定的容差范围内能保持用户指定的精度。\n\n你的程序必须在三个不同的最终时间和精度要求下对该系统进行评估。对于下方的每个测试用例，从给定的初始条件开始，使用指定的相对容差 $r_{\\mathrm{tol}}$ 和绝对容差 $a_{\\mathrm{tol}}$，从 $t=0$ 到 $t=T$ 对系统进行积分。报告标量值 $y_3(T)$，作为一个浮点数。\n\n测试套件：\n- A用例（早期刚性解析）：$T=10^{-6}$，$r_{\\mathrm{tol}}=10^{-6}$，$a_{\\mathrm{tol}}=10^{-14}$。\n- B用例（中期行为）：$T=1$，$r_{\\mathrm{tol}}=10^{-6}$，$a_{\\mathrm{tol}}=10^{-12}$。\n- C用例（长时渐近）：$T=10^{5}$，$r_{\\mathrm{tol}}=10^{-6}$，$a_{\\mathrm{tol}}=10^{-12}$。\n\n最终输出格式：\n- 你的程序应产生单行输出，内容为方括号内以逗号分隔的结果列表，顺序必须为 $[y_3(T\\text{ of Case A}), y_3(T\\text{ of Case B}), y_3(T\\text{ of Case C})]$。例如，输出必须如下所示：\n$$\n[\\text{value\\_A},\\text{value\\_B},\\text{value\\_C}],\n$$\n其中每一项都是一个浮点数。\n\n该问题需要在纯数学和计算层面进行求解和验证，与任何特定的编程语言无关，除了要求以指定格式输出单行之外。不应读取任何外部输入。所有数值答案必须表示为浮点数，不带单位或百分号。",
            "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- **常微分方程（ODE）组：**\n$$\n\\frac{d y_1}{d t} = -0.04\\, y_1 + 10^{4}\\, y_2\\, y_3\n$$\n$$\n\\frac{d y_2}{d t} = 0.04\\, y_1 - 10^{4}\\, y_2\\, y_3 - 3\\times 10^{7}\\, y_2^{2}\n$$\n$$\n\\frac{d y_3}{d t} = 3\\times 10^{7}\\, y_2^{2}\n$$\n- **初始条件：**在 $t=0$ 时，$y(0) = [y_1(0), y_2(0), y_3(0)] = [1, 0, 0]$。\n- **时间域：**$t \\in [0, T]$。\n- **实现要求：**使用变阶、变步长的后向差分公式（BDF）进行近似。\n- **测试用例：**\n  - A用例：$T=10^{-6}$，$r_{\\mathrm{tol}}=10^{-6}$，$a_{\\mathrm{tol}}=10^{-14}$。\n  - B用例：$T=1$，$r_{\\mathrm{tol}}=10^{-6}$，$a_{\\mathrm{tol}}=10^{-12}$。\n  - C用例：$T=10^{5}$，$r_{\\mathrm{tol}}=10^{-6}$，$a_{\\mathrm{tol}}=10^{-12}$。\n- **要求输出：**每个用例的 $y_3(T)$ 值，格式化为单行列表：`[value_A,value_B,value_C]`。\n\n**步骤2：验证已知条件**\n该问题具有科学依据。Robertson 系统是刚性初值问题的典型基准，源于化学动力学。刚性系统的特点是存在多个、相差悬殊的演化时间尺度。速率常数从 $k_1=0.04$ 到 $k_3=3\\times 10^{7}$ 不等，这产生了刚性。该问题是适定的；作为一个右端函数光滑（多项式）的初值问题，其存在唯一解。问题是自洽的，为数值求解提供了所有必要的参数和条件。目标陈述清晰，无歧义。\n\n**步骤3：结论与行动**\n问题有效。将构建一个合理的解决方案。\n\n**求解推导**\n任务是求解一个刚性常微分方程（ODE）组。该系统的形式为 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})$，其中 $\\mathbf{y}(t) = [y_1(t), y_2(t), y_3(t)]^T$ 是状态向量。刚性使得标准的显式数值方法（例如，Runge-Kutta）效率低下，因为这些方法需要极小的时间步长来维持数值稳定性。\n\n指定的方法是后向差分公式（BDF），这是一类非常适合求解刚性问题的隐式多步法。一个 $k$ 步 BDF 方法使用当前步的解 $\\mathbf{y}_{n+1}$ 和前 $k$ 步的解 $\\mathbf{y}_{n}, \\dots, \\mathbf{y}_{n+1-k}$ 来近似时间 $t_{n+1}$ 处的导数 $\\frac{d\\mathbf{y}}{dt}$。对于常数步长 $h$，其通用公式为：\n$$\n\\sum_{j=0}^{k} \\alpha_j \\mathbf{y}_{n+1-j} = h \\beta \\mathbf{f}(t_{n+1}, \\mathbf{y}_{n+1})\n$$\n对于 BDF 方法，$\\beta=1$，且选择系数 $\\alpha_j$ 以最大化精度阶数。例如，BDF1（隐式欧拉）和 BDF2 公式为：\n$$\n\\text{BDF1 (order 1): } \\mathbf{y}_{n+1} - \\mathbf{y}_{n} = h \\mathbf{f}(t_{n+1}, \\mathbf{y}_{n+1})\n$$\n$$\n\\text{BDF2 (order 2): } \\frac{3}{2}\\mathbf{y}_{n+1} - 2\\mathbf{y}_{n} + \\frac{1}{2}\\mathbf{y}_{n-1} = h \\mathbf{f}(t_{n+1}, \\mathbf{y}_{n+1})\n$$\n由于 $\\mathbf{y}_{n+1}$ 出现在方程的两边（它是通常为非线性的函数 $\\mathbf{f}$ 的一个参数），因此在每个时间步都必须求解一个代数方程组。这通常通过拟牛顿法（如牛顿法）来完成，该方法求解以下求根问题：\n$$\n\\mathbf{G}(\\mathbf{y}_{n+1}) = \\mathbf{y}_{n+1} - h\\gamma \\mathbf{f}(t_{n+1}, \\mathbf{y}_{n+1}) - \\mathbf{\\Psi} = \\mathbf{0}\n$$\n此处，$\\gamma$ 是一个 BDF 系数，$\\mathbf{\\Psi}$ 包含已知过去值的总和。牛顿法的迭代更新公式为：\n$$\n\\mathbf{y}_{n+1}^{(m+1)} = \\mathbf{y}_{n+1}^{(m)} - [\\mathbf{I} - h\\gamma \\mathbf{J}]^{-1} \\mathbf{G}(\\mathbf{y}_{n+1}^{(m)})\n$$\n其中 $\\mathbf{I}$ 是单位矩阵，$\\mathbf{J}$ 是 $\\mathbf{f}$ 关于 $\\mathbf{y}$ 的雅可比矩阵，在 $(t_{n+1}, \\mathbf{y}_{n+1}^{(m)})$ 处求值。雅可比矩阵定义为 $J_{ij} = \\frac{\\partial f_i}{\\partial y_j}$。提供解析的雅可比矩阵对于求解器的效率和鲁棒性至关重要。对于给定的 Robertson 系统，其雅可比矩阵为：\n$$\n\\mathbf{J}(t, \\mathbf{y}) = \\begin{pmatrix}\n-0.04  10^4 y_3  10^4 y_2 \\\\\n0.04  -10^4 y_3 - 6 \\times 10^7 y_2  -10^4 y_2 \\\\\n0  6 \\times 10^7 y_2  0\n\\end{pmatrix}\n$$\n从基本原理开始实现一个变阶、变步长的 BDF 求解器是一项艰巨的任务，其中涉及误差估计（以调整步长 $h$ 和阶数 $k$）、步长变化时的插值以及鲁棒的非线性系统求解。一种科学严谨且实用的方法是使用提供此功能的高质量、专业实现的数值库。指定的执行环境允许使用 `scipy` 库，版本为 `1.11.4`。函数 `scipy.integrate.solve_ivp` 及其参数 `method='BDF'` 正是此类求解器的一种实现。它会自适应地选择公式阶数（$k$ 从 1 到 5）和步长 $h$，以满足给定的相对（$r_{\\mathrm{tol}}$）和绝对（$a_{\\mathrm{tol}}$）容差。\n\n因此，求解策略是定义 ODE 函数 $\\mathbf{f}(t, \\mathbf{y})$ 及其雅可比矩阵 $\\mathbf{J}(t, \\mathbf{y})$。然后，对每个测试用例，使用指定的参数（`t_span`、`y0`、`method='BDF'`、`rtol`、`atol` 以及雅可比函数）调用 `scipy.integrate.solve_ivp`。从结果中提取 $y_3$ 的最终值。此过程遵循问题陈述，同时确保了数值上可靠和正确的解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the Robertson stiff ODE system using a variable-order, variable-step\n    Backward Differentiation Formula (BDF) method, as implemented in SciPy.\n    \"\"\"\n    \n    # Define the system of ODEs for the Robertson problem.\n    # y[0] corresponds to y_1, y[1] to y_2, y[2] to y_3.\n    def robertson_ode(t, y):\n        k1 = 0.04\n        k2 = 1.0e4\n        k3 = 3.0e7\n        \n        dy1dt = -k1 * y[0] + k2 * y[1] * y[2]\n        dy2dt = k1 * y[0] - k2 * y[1] * y[2] - k3 * y[1]**2\n        dy3dt = k3 * y[1]**2\n        \n        return [dy1dt, dy2dt, dy3dt]\n\n    # Define the analytical Jacobian of the ODE system.\n    # Providing the Jacobian significantly improves the performance of stiff solvers.\n    def robertson_jacobian(t, y):\n        k1 = 0.04\n        k2 = 1.0e4\n        k3 = 3.0e7\n        \n        # J_ij = df_i / dy_j\n        jac = np.zeros((3, 3))\n        \n        # Row 1: d(dy1/dt)/dy_j\n        jac[0, 0] = -k1\n        jac[0, 1] = k2 * y[2]\n        jac[0, 2] = k2 * y[1]\n        \n        # Row 2: d(dy2/dt)/dy_j\n        jac[1, 0] = k1\n        jac[1, 1] = -k2 * y[2] - 2 * k3 * y[1]\n        jac[1, 2] = -k2 * y[1]\n        \n        # Row 3: d(dy3/dt)/dy_j\n        jac[2, 0] = 0.0\n        jac[2, 1] = 2 * k3 * y[1]\n        jac[2, 2] = 0.0\n        \n        return jac\n\n    # Initial condition: y(0) = [1, 0, 0]\n    y0 = [1.0, 0.0, 0.0]\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (T, rtol, atol)\n    test_cases = [\n        (1.0e-6, 1.0e-6, 1.0e-14),  # Case A\n        (1.0, 1.0e-6, 1.0e-12),      # Case B\n        (1.0e5, 1.0e-6, 1.0e-12),    # Case C\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        T, rtol, atol = case\n        \n        # The time interval for integration\n        t_span = (0.0, T)\n        \n        # Solve the ODE system using the 'BDF' method\n        sol = solve_ivp(\n            fun=robertson_ode,\n            t_span=t_span,\n            y0=y0,\n            method='BDF',\n            jac=robertson_jacobian,\n            rtol=rtol,\n            atol=atol,\n        )\n        \n        # Check if the integration was successful\n        if not sol.success:\n            # This should not happen for a valid problem but is good practice\n            raise RuntimeError(f\"Solver failed for T={T}, rtol={rtol}, atol={atol}: {sol.message}\")\n            \n        # The solution at the final time T is sol.y[:, -1]\n        final_y = sol.y\n        # We need the value of y3(T), which is the third component\n        y3_at_T = final_y[2, -1]\n        \n        results.append(y3_at_T)\n\n    # Format the results as a string and print\n    # The output must be without any surrounding text, just the list.\n    # The `repr` function is used to ensure full floating-point precision in the output string.\n    print(f\"[{','.join(map(repr, results))}]\")\n\nsolve()\n```"
        }
    ]
}