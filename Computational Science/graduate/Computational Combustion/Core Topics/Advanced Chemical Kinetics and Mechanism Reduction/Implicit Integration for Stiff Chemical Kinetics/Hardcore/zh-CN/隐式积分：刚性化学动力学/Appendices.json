{
    "hands_on_practices": [
        {
            "introduction": "求解刚性化学动力学方程组时，一个核心问题是数值稳定性。本实践将引导你使用经典的Dahlquist测试方程 $\\dot{y} = \\lambda y$ 来分析两种常用隐式积分方法（梯形法则和BDF2）的稳定性边界。通过推导和比较它们的性质，你将深刻理解为何某些方法（如BDF）因其出色的刚性衰减特性而成为求解燃烧等刚性问题的首选。",
            "id": "4031709",
            "problem": "一个具有刚性化学的均质、恒压反应器使用隐式积分器进行时间推进。将物种源项在准稳态点附近进行线性化，对于雅可比矩阵的每个特征模态，可以得到标量Dahlquist测试方程 $\\,\\dot{y} = \\lambda y\\,$，其中 $\\,\\lambda \\in \\mathbb{C}\\,$，而刚性复合表现为具有大负实部的特征值。令 $\\,h > 0\\,$ 表示一个恒定的时间步长，并定义无量纲变量 $\\,z = h \\lambda\\,$。\n\n考虑两种标准的隐式方法：\n- 梯形法则（也称为Crank-Nicolson方法）。\n- 二阶两步后向差分格式（BDF），此后称为后向差分格式（BDF2）。\n\n从这些方法的定义和Dahlquist测试方程出发，执行以下操作：\n1. 对每种方法，推导出 $\\,y_{n+1}\\,$ 以先前值和 $\\,z\\,$ 表示的离散传播关系式，并由此确定在 $\\,z$-平面内的线性绝对稳定域。对于梯形法则，这由单个放大因子的模来表征。对于后向差分格式（BDF2），这由两步递推的特征多项式的根条件来表征。\n2. 将单步传播算子的谱半径 $\\,\\rho(z)\\,$ 定义如下：对于梯形法则，$\\,\\rho(z)\\,$ 是其单个放大因子的模；对于后向差分格式（BDF2），$\\,\\rho(z)\\,$ 是两个特征根的最大模。然后考虑特征值 $\\,\\lambda\\,$ 满足 $\\,\\Re(\\lambda) \\ll 0\\,$，并通过计算以下极限来评估刚性模态的渐近阻尼\n$$\n\\lim_{r \\to \\infty} \\rho_{\\mathrm{TR}}(-r)\n\\quad \\text{和} \\quad\n\\lim_{r \\to \\infty} \\rho_{\\mathrm{BDF2}}(-r),\n$$\n其中 $\\,r \\in \\mathbb{R}\\,$ 且 $\\,r > 0\\,$，下标表示所用方法。\n\n以包含这两个极限的有序对 $\\,\\big(\\lim_{r \\to \\infty} \\rho_{\\mathrm{TR}}(-r),\\,\\lim_{r \\to \\infty} \\rho_{\\mathrm{BDF2}}(-r)\\big)\\,$ 的形式报告最终结果。提供精确值（不要四舍五入）。最终答案必须是无量纲的。",
            "solution": "问题陈述已经过验证，被认为是常微分方程数值分析领域中一个有效的、适定的问题。它有科学依据、内容自洽且客观。\n\n目标是分析应用于Dahlquist测试方程 $\\dot{y} = \\lambda y$ 的两种隐式数值积分方法：梯形法则（TR）和两步后向差分格式（BDF2）。我们将首先推导每种方法的稳定性，然后评估它们对刚性模态的渐近阻尼行为，这些模态的特征是具有大负实部的特征值 $\\lambda$。这通过计算当 $z = h\\lambda$ 沿实轴趋于 $-\\infty$ 时谱半径的极限来建模。\n\n**第一部分：梯形法则（TR）**\n\n应用于常微分方程（ODE） $\\dot{y} = f(y)$ 的梯形法则（也称为Crank-Nicolson方法）由下式给出：\n$$y_{n+1} = y_n + \\frac{h}{2} \\left[ f(y_n) + f(y_{n+1}) \\right]$$\n对于Dahlquist测试方程，$f(y) = \\lambda y$。将其代入TR公式得到：\n$$y_{n+1} = y_n + \\frac{h}{2} (\\lambda y_n + \\lambda y_{n+1})$$\n我们现在求解 $y_{n+1}$ 以找到传播关系。\n$$y_{n+1} \\left( 1 - \\frac{h\\lambda}{2} \\right) = y_n \\left( 1 + \\frac{h\\lambda}{2} \\right)$$\n使用定义 $z = h\\lambda$，我们有：\n$$y_{n+1} \\left( 1 - \\frac{z}{2} \\right) = y_n \\left( 1 + \\frac{z}{2} \\right)$$\n$$y_{n+1} = \\left( \\frac{1 + \\frac{z}{2}}{1 - \\frac{z}{2}} \\right) y_n$$\n这是一个形式为 $y_{n+1} = G_{\\mathrm{TR}}(z) y_n$ 的单步递推关系，其中放大因子为：\n$$G_{\\mathrm{TR}}(z) = \\frac{1 + \\frac{z}{2}}{1 - \\frac{z}{2}}$$\n绝对稳定域是所有满足 $|G_{\\mathrm{TR}}(z)| \\le 1$ 的 $z \\in \\mathbb{C}$ 的集合。令 $z = x + iy$，其中 $x, y \\in \\mathbb{R}$。\n$$ \\left| \\frac{1 + \\frac{x+iy}{2}}{1 - \\frac{x+iy}{2}} \\right| \\le 1 \\implies \\left| \\frac{ (2+x) + iy }{ (2-x) - iy } \\right| \\le 1 $$\n$$| (2+x) + iy | \\le | (2-x) - iy |$$\n两边平方得到：\n$$(2+x)^2 + y^2 \\le (2-x)^2 + (-y)^2$$\n$$4 + 4x + x^2 + y^2 \\le 4 - 4x + x^2 + y^2$$\n$$8x \\le 0 \\implies x \\le 0$$\n稳定域是整个复平面的左半部分，即 $\\Re(z) \\le 0$。具有此性质的方法称为A-稳定。\n\n对于这种单步方法，谱半径就是放大因子的模：\n$$\\rho_{\\mathrm{TR}}(z) = |G_{\\mathrm{TR}}(z)| = \\left| \\frac{1 + \\frac{z}{2}}{1 - \\frac{z}{2}} \\right|$$\n我们被要求计算沿负实轴的刚性模态的极限。这对应于 $z = -r$，其中 $r \\in \\mathbb{R}$，$r > 0$ 且 $r \\to \\infty$。\n$$\\lim_{r \\to \\infty} \\rho_{\\mathrm{TR}}(-r) = \\lim_{r \\to \\infty} \\left| \\frac{1 + \\frac{-r}{2}}{1 - \\frac{-r}{2}} \\right| = \\lim_{r \\to \\infty} \\left| \\frac{1 - \\frac{r}{2}}{1 + \\frac{r}{2}} \\right| = \\lim_{r \\to \\infty} \\left| \\frac{2 - r}{2 + r} \\right|$$\n分子和分母同除以 $r$：\n$$\\lim_{r \\to \\infty} \\left| \\frac{\\frac{2}{r} - 1}{\\frac{2}{r} + 1} \\right| = \\left| \\frac{0 - 1}{0 + 1} \\right| = |-1| = 1$$\n因此，梯形法则的渐近阻尼极限为 $1$。\n\n**第二部分：两步后向差分格式（BDF2）**\n\n应用于常微分方程 $\\dot{y} = f(y)$ 的BDF2方法由下式给出：\n$$\\frac{3}{2} y_{n+1} - 2y_n + \\frac{1}{2} y_{n-1} = h f(y_{n+1})$$\n对于Dahlquist测试方程，$f(y_{n+1}) = \\lambda y_{n+1}$。代入可得：\n$$\\frac{3}{2} y_{n+1} - 2y_n + \\frac{1}{2} y_{n-1} = h \\lambda y_{n+1}$$\n合并项并代入 $z = h\\lambda$：\n$$\\left( \\frac{3}{2} - z \\right) y_{n+1} - 2y_n + \\frac{1}{2} y_{n-1} = 0$$\n这是一个线性齐次递推关系。为分析其稳定性，我们寻找形式为 $y_n = \\xi^n$ 的解。代入此假设可得到关于 $\\xi$ 的特征多项式：\n$$\\left( \\frac{3}{2} - z \\right) \\xi^2 - 2\\xi + \\frac{1}{2} = 0$$\n乘以 $2$ 以消去分数，得到一个更方便的形式：\n$$(3 - 2z) \\xi^2 - 4\\xi + 1 = 0$$\n该方法的稳定性取决于该多项式的根。如果所有根 $\\xi_k$ 都满足 $|\\xi_k| \\le 1$（根条件），则该方法是绝对稳定的。谱半径 $\\rho_{\\mathrm{BDF2}}(z)$ 是这些根的最大模，即 $\\rho_{\\mathrm{BDF2}}(z) = \\max_k |\\xi_k|$。\n\n我们通过设置 $z = -r$（其中 $r > 0$ 且 $r \\to \\infty$）来评估刚性模态的极限。特征多项式变为：\n$$(3 - 2(-r)) \\xi^2 - 4\\xi + 1 = 0 \\implies (3 + 2r) \\xi^2 - 4\\xi + 1 = 0$$\n根 $\\xi_{1,2}$ 由二次求根公式给出：\n$$\\xi = \\frac{-(-4) \\pm \\sqrt{(-4)^2 - 4(3+2r)(1)}}{2(3+2r)} = \\frac{4 \\pm \\sqrt{16 - 12 - 8r}}{2(3+2r)} = \\frac{4 \\pm \\sqrt{4 - 8r}}{6 + 4r}$$\n对于 $r > \\frac{1}{2}$，判别式为负，所以根是一对共轭复数。设根为 $\\xi$ 和 $\\bar{\\xi}$。根据韦达定理，根的乘积为：\n$$\\xi \\bar{\\xi} = \\frac{1}{3 + 2r}$$\n复数的模的平方是该数与其共轭的乘积，即 $|\\xi|^2 = \\xi \\bar{\\xi}$。由于两个根是共轭复数，它们的模相同。因此，谱半径是任一根的模：\n$$\\rho_{\\mathrm{BDF2}}(-r) = |\\xi| = \\sqrt{\\xi \\bar{\\xi}} = \\sqrt{\\frac{1}{3 + 2r}} = \\frac{1}{\\sqrt{3 + 2r}}$$\n现在我们可以计算所求的极限：\n$$\\lim_{r \\to \\infty} \\rho_{\\mathrm{BDF2}}(-r) = \\lim_{r \\to \\infty} \\frac{1}{\\sqrt{3 + 2r}}$$\n当 $r \\to \\infty$ 时，分母 $\\sqrt{3+2r} \\to \\infty$。因此，极限为 $0$。\n\n**结论**\n\n计算出的极限是：\n$$\\lim_{r \\to \\infty} \\rho_{\\mathrm{TR}}(-r) = 1$$\n$$\\lim_{r \\to \\infty} \\rho_{\\mathrm{BDF2}}(-r) = 0$$\n这些极限的有序对是 $(1, 0)$。$\\rho$ 值接近 $0$ 表示对刚性分量的强阻尼，这是理想的。值为 $1$ 表示没有阻尼。因此，在处理刚性问题方面，BDF2 优于梯形法则，这一性质被称为L-稳定性。",
            "answer": "$$\n\\boxed{(1, 0)}\n$$"
        },
        {
            "introduction": "从理论转向实践，实现一个高效的刚性求解器的关键在于精确求解隐式方法产生的非线性方程组，而这通常依赖于牛顿法及其所需的雅可比矩阵。本实践将带你为一个简化的氢气/氧气反应机理编写解析雅可比矩阵的程序，并将其与数值有限差分近似进行比较。这项练习不仅能锻炼你的编程和推导能力，还能让你体会到解析雅可比矩阵在确保求解器收敛性和准确性方面的重要性。",
            "id": "4031752",
            "problem": "考虑一个代表氢气氧化的化学反应系统，该系统为刚性化学动力学的隐式时间积分而构建。在一个常微分方程 (ODE) 系统中，物种的控制源项遵循基元反应的质量作用定律。设摩尔浓度向量为 $\\mathbf{C} \\in \\mathbb{R}^N$，其分量 $C_i$ 代表物种 $i$ 的浓度，单位为 $\\mathrm{mol}\\,\\mathrm{m}^{-3}$。对于一个具有 Arrhenius 参数 $(A_n,n_n,E_{a,n})$ 的不可逆基元反应 $n$，在温度 $T$ 下的反应进程速率由下式给出\n$$\nk_n(T) = A_n T^{n_n} \\exp\\left(-\\frac{E_{a,n}}{R T}\\right),\n$$\n其中 $R$ 是普适气体常数，单位为 $\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。对于一个反应物化学计量指数为 $\\nu_{j,n}^{\\mathrm{react}}$ 的反应，其正向反应进程速率为\n$$\nr_n(\\mathbf{C},T) = k_n(T) \\prod_{j=1}^N C_j^{\\nu_{j,n}^{\\mathrm{react}}}.\n$$\n对于第三体反应，有效第三体浓度取为总摩尔浓度 $M = \\sum_{j=1}^N C_j$，且所有第三体效率均等于 1，因此三分子反应 $a + b + M \\rightarrow \\cdots$ 的速率为\n$$\nr_n(\\mathbf{C},T) = k_n(T) \\, C_a \\, C_b \\, M.\n$$\n物种的生成速率为\n$$\n\\omega_i(\\mathbf{C},T) = \\sum_{n=1}^{N_r} s_{i,n} \\, r_n(\\mathbf{C},T),\n$$\n其中 $s_{i,n}$ 是反应 $n$ 中物种 $i$ 的净化学计量系数（产物为正，反应物为负），$N_r$ 是反应总数。源项的解析雅可比矩阵为\n$$\nJ_{i j}(\\mathbf{C},T) = \\frac{\\partial \\omega_i(\\mathbf{C},T)}{\\partial C_j}.\n$$\n您将为一个在恒定温度 $T$ 和压力 $p$ 下的简化氢/氧（$\\mathrm{H}_2/\\mathrm{O}_2$）机理实现解析雅可比矩阵，并将其准确性和稀疏模式与有限差分近似进行比较。\n\n机理定义。考虑 $N=8$ 个物种，顺序为 $\\left[\\mathrm{H}_2,\\ \\mathrm{O}_2,\\ \\mathrm{H},\\ \\mathrm{O},\\ \\mathrm{OH},\\ \\mathrm{HO}_2,\\ \\mathrm{H}_2\\mathrm{O}_2,\\ \\mathrm{H}_2\\mathrm{O}\\right]$。使用 $N_r=6$ 个不可逆基元反应：\n1. $\\mathrm{H} + \\mathrm{O}_2 \\rightarrow \\mathrm{O} + \\mathrm{OH}$，其参数 $(A_1,n_1,E_{a,1}) = \\left(2.65\\times10^{10},\\ -0.5,\\ 7.5\\times10^{4}\\right)$，单位为 $\\left(\\mathrm{m}^3\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1},\\ \\text{无量纲},\\ \\mathrm{J}\\,\\mathrm{mol}^{-1}\\right)$。\n2. $\\mathrm{O} + \\mathrm{H}_2 \\rightarrow \\mathrm{H} + \\mathrm{OH}$，其参数 $(A_2,n_2,E_{a,2}) = \\left(1.80\\times10^{10},\\ 0.0,\\ 2.6\\times10^{4}\\right)$，单位为 $\\left(\\mathrm{m}^3\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1},\\ \\text{无量纲},\\ \\mathrm{J}\\,\\mathrm{mol}^{-1}\\right)$。\n3. $\\mathrm{OH} + \\mathrm{H}_2 \\rightarrow \\mathrm{H} + \\mathrm{H}_2\\mathrm{O}$，其参数 $(A_3,n_3,E_{a,3}) = \\left(2.10\\times10^{7},\\ 1.0,\\ 1.6\\times10^{4}\\right)$，单位为 $\\left(\\mathrm{m}^3\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1},\\ \\text{无量纲},\\ \\mathrm{J}\\,\\mathrm{mol}^{-1}\\right)$。\n4. $\\mathrm{H} + \\mathrm{O}_2 + M \\rightarrow \\mathrm{HO}_2 + M$，其参数 $(A_4,n_4,E_{a,4}) = \\left(1.475\\times10^{18},\\ -1.0,\\ 0.0\\right)$，单位为 $\\left(\\mathrm{m}^6\\,\\mathrm{mol}^{-2}\\,\\mathrm{s}^{-1},\\ \\text{无量纲},\\ \\mathrm{J}\\,\\mathrm{mol}^{-1}\\right)$。\n5. $\\mathrm{HO}_2 + \\mathrm{H} \\rightarrow 2\\,\\mathrm{OH}$，其参数 $(A_5,n_5,E_{a,5}) = \\left(1.80\\times10^{10},\\ 0.0,\\ 0.0\\right)$，单位为 $\\left(\\mathrm{m}^3\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1},\\ \\text{无量纲},\\ \\mathrm{J}\\,\\mathrm{mol}^{-1}\\right)$。\n6. $2\\,\\mathrm{HO}_2 \\rightarrow \\mathrm{H}_2\\mathrm{O}_2 + \\mathrm{O}_2$，其参数 $(A_6,n_6,E_{a,6}) = \\left(1.00\\times10^{9},\\ 0.0,\\ 0.0\\right)$，单位为 $\\left(\\mathrm{m}^3\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1},\\ \\text{无量纲},\\ \\mathrm{J}\\,\\mathrm{mol}^{-1}\\right)$。\n\n对于每个反应，采用与所写方程一致的净化学计量系数 $s_{i,n}$。对于反应 4，将 $M$ 视为总浓度 $M=\\sum_{j=1}^8 C_j$，且 $M$ 本身不会对任何物种产生净化学计量变化。\n\n热力学状态。取均匀恒定的温度 $T = 1200\\ \\mathrm{K}$ 和压力 $p = 1\\ \\mathrm{atm}$，其中 $1\\ \\mathrm{atm} = 101325\\ \\mathrm{Pa}$。总摩尔浓度为 $C_{\\mathrm{tot}} = p/(R T)$，其中 $R = 8.314462618\\ \\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。设初始摩尔浓度由指定的摩尔分数 $x_i$ 通过 $C_i = x_i\\, C_{\\mathrm{tot}}$ 确定。浓度使用 $\\mathrm{mol}\\,\\mathrm{m}^{-3}$，与时间相关的速率使用秒。\n\n任务。实现一个程序，该程序：\n- 通过对物种源项 $\\boldsymbol{\\omega}(\\mathbf{C},T)$ 关于 $\\mathbf{C}$ 求导，计算解析雅可比矩阵 $J(\\mathbf{C},T)$。\n- 使用逐变量中心差分计算有限差分近似 $J^{\\mathrm{FD}}(\\mathbf{C},T)$，其中扰动 $h_j$ 自适应地选择为 $h_j = \\sqrt{\\epsilon}\\,\\max(1,|C_j|)$，$\\epsilon$ 是双精度浮点数的机器精度。如果 $C_j - h_j  0$，则使用前向差分 $J^{\\mathrm{FD}}_{:,j} \\approx \\left(\\boldsymbol{\\omega}(\\mathbf{C}+h_j \\mathbf{e}_j) - \\boldsymbol{\\omega}(\\mathbf{C})\\right)/h_j$；否则使用中心差分 $J^{\\mathrm{FD}}_{:,j} \\approx \\left(\\boldsymbol{\\omega}(\\mathbf{C}+h_j \\mathbf{e}_j) - \\boldsymbol{\\omega}(\\mathbf{C}-h_j \\mathbf{e}_j)\\right)/(2 h_j)$，其中 $\\mathbf{e}_j$ 是坐标 $j$ 上的单位向量。\n- 使用相对 Frobenius 范数误差比较解析雅可比矩阵和有限差分雅可比矩阵\n$$\nE = \\frac{\\left\\|J - J^{\\mathrm{FD}}\\right\\|_F}{\\left\\|J^{\\mathrm{FD}}\\right\\|_F},\n$$\n约定如果 $\\left\\|J^{\\mathrm{FD}}\\right\\|_F = 0$ 且 $\\left\\|J - J^{\\mathrm{FD}}\\right\\|_F = 0$，则 $E=0$；如果 $\\left\\|J^{\\mathrm{FD}}\\right\\|_F = 0$ 且 $\\left\\|J - J^{\\mathrm{FD}}\\right\\|_F > 0$，则 $E=+\\infty$。\n- 通过在微小正公差 $\\tau$ 下对两个雅可比矩阵进行阈值化，并检查所有条目是否满足 $\\mathbb{I}\\{|J_{i j}| > \\tau\\} = \\mathbb{I}\\{|J^{\\mathrm{FD}}_{i j}| > \\tau\\}$，来确定稀疏模式是否匹配。其中 $\\mathbb{I}\\{\\cdot\\}$ 表示指示函数。使用 $\\tau = 10^{-20}$。\n\n测试套件。在 $T=1200\\ \\mathrm{K}$ 和 $p=1\\ \\mathrm{atm}$ 下评估三种组分：\n- 案例 1（带自由基种子的化学计量比）：$x_{\\mathrm{H}_2} = 2/3 - 2\\times10^{-12}$，$x_{\\mathrm{O}_2} = 1/3 - 0\\times10^{-12}$，$x_{\\mathrm{H}} = 1\\times10^{-12}$，$x_{\\mathrm{OH}} = 1\\times10^{-12}$，所有其他 $x_i = 0$。通过从 $x_{\\mathrm{H}_2}$ 中减去自由基分数来保持 $\\sum_i x_i = 1$。\n- 案例 2（贫燃、富氧，带自由基种子）：$x_{\\mathrm{H}_2} = 0.2$，$x_{\\mathrm{O}_2} = 0.8 - 1\\times10^{-12}$，$x_{\\mathrm{H}} = 1\\times10^{-12}$，所有其他 $x_i = 0$。\n- 案例 3（无自由基的化学计量比）：$x_{\\mathrm{H}_2} = 2/3$，$x_{\\mathrm{O}_2} = 1/3$，所有其他 $x_i = 0$。\n\n输出规格。对每个案例，计算相对误差 $E$（作为一个浮点数）和稀疏模式匹配情况（作为一个布尔值）。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $\\left[E_1,\\ \\mathrm{match}_1,\\ E_2,\\ \\mathrm{match}_2,\\ E_3,\\ \\mathrm{match}_3\\right]$。",
            "solution": "该问题要求实现并比较一个刚性化学动力学系统源项的解析雅可比矩阵和有限差分近似。该系统代表一个简化的氢氧燃烧机理。验证问题陈述是强制性的第一步。\n\n### 步骤 1：问题验证\n\n已知条件逐字从问题陈述中提取。\n\n**数据和定义：**\n- 物种向量：$\\mathbf{C} \\in \\mathbb{R}^N$，对于 $N=8$ 个物种：$\\left[\\mathrm{H}_2,\\ \\mathrm{O}_2,\\ \\mathrm{H},\\ \\mathrm{O},\\ \\mathrm{OH},\\ \\mathrm{HO}_2,\\ \\mathrm{H}_2\\mathrm{O}_2,\\ \\mathrm{H}_2\\mathrm{O}\\right]$。\n- Arrhenius 速率常数：$k_n(T) = A_n T^{n_n} \\exp\\left(-\\frac{E_{a,n}}{R T}\\right)$。\n- 正向反应进程速率：$r_n(\\mathbf{C},T) = k_n(T) \\prod_{j=1}^N C_j^{\\nu_{j,n}^{\\mathrm{react}}}$。\n- 第三体速率：$r_n(\\mathbf{C},T) = k_n(T) \\, C_a \\, C_b \\, M$，其中 $M = \\sum_{j=1}^N C_j$。\n- 物种生成速率：$\\omega_i(\\mathbf{C},T) = \\sum_{n=1}^{N_r} s_{i,n} \\, r_n(\\mathbf{C},T)$，对于 $N_r=6$ 个反应。\n- 解析雅可比矩阵：$J_{i j}(\\mathbf{C},T) = \\frac{\\partial \\omega_i(\\mathbf{C},T)}{\\partial C_j}$。\n- 包含指定 Arrhenius 参数 $(A_n, n_n, E_{a,n})$ 的反应机理（6 个不可逆反应）。\n- 热力学状态：$T = 1200\\ \\mathrm{K}$，$p = 1\\ \\mathrm{atm} = 101325\\ \\mathrm{Pa}$。\n- 普适气体常数：$R = 8.314462618\\ \\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。\n- 总摩尔浓度：$C_{\\mathrm{tot}} = p/(R T)$。\n- 从摩尔分数计算浓度：$C_i = x_i\\, C_{\\mathrm{tot}}$。\n- 有限差分（FD）雅可比矩阵：自适应中心/前向差分格式。\n    - 扰动：$h_j = \\sqrt{\\epsilon}\\,\\max(1,|C_j|)$，其中 $\\epsilon$ 是双精度机器精度。\n    - 格式：如果 $C_j - h_j  0$ 则为前向差分，否则为中心差分。\n- 比较指标：\n    - 相对 Frobenius 范数误差：$E = \\frac{\\left\\|J - J^{\\mathrm{FD}}\\right\\|_F}{\\left\\|J^{\\mathrm{FD}}\\right\\|_F}$。\n    - 稀疏模式匹配：$\\mathbb{I}\\{|J_{i j}| > \\tau\\} = \\mathbb{I}\\{|J^{\\mathrm{FD}}_{i j}| > \\tau\\}$，对于 $\\tau = 10^{-20}$。\n- 测试案例：提供了三种特定的初始组分（摩尔分数 $x_i$）。\n\n**验证结论：**\n该问题被评估为 **有效**。\n- **科学上成立：** 该问题基于化学动力学的基本原理，即质量作用定律和 Arrhenius 速率定律。雅可比矩阵的概念是刚性 ODE 系统数值解的核心，这是计算化学与工程中的一个标准课题。所选反应构成了氢氧化机理的一个合理的（尽管是简化的）子集。\n- **良态的：** 提供了所有必要的数据，包括物种、反应、动力学参数、热力学条件以及计算的精确定义（解析和数值雅可比矩阵、比较指标）。函数定义良好且可微，确保在指定状态下存在雅可比矩阵的唯一解。\n- **客观性：** 该问题以精确、定量、无歧义的数学和化学语言陈述。它不含主观论断。\n- **无缺陷：** 该问题不违反任何无效标准。单位一致，设置没有矛盾，任务是在一个成熟的科学领域内一个非平凡但可行的计算练习。\n\n### 步骤 2：求解\n\n求解过程首先定义化学系统，然后推导解析雅可比矩阵的表达式，最后概述解析和有限差分雅可比矩阵的数值实现及其比较。\n\n**系统定义**\n该系统由 $N=8$ 个物种和 $N_r=6$ 个不可逆反应组成。物种按以下方式从 0 到 7 索引：$0:\\mathrm{H}_2$，$1:\\mathrm{O}_2$，$2:\\mathrm{H}$，$3:\\mathrm{O}$，$4:\\mathrm{OH}$，$5:\\mathrm{HO}_2$，$6:\\mathrm{H}_2\\mathrm{O}_2$，$7:\\mathrm{H}_2\\mathrm{O}$。\n\n净化学计量系数矩阵 $\\mathbf{s}$ 是一个 $N \\times N_r$ 矩阵，其中 $s_{i,n}$ 是反应 $n$ 中物种 $i$ 的系数。根据给定的反应，该矩阵为：\n$$\n\\mathbf{s} = \\begin{pmatrix}\n 0  -1  -1   0   0   0 \\\\\n-1   0   0  -1   0  +1 \\\\\n-1  +1  +1  -1  -1   0 \\\\\n+1  -1   0   0   0   0 \\\\\n+1  +1  -1   0  +2   0 \\\\\n 0   0   0  +1  -1  -2 \\\\\n 0   0   0   0   0  +1 \\\\\n 0   0  +1   0   0   0\n\\end{pmatrix}\n$$\n根据质量作用定律，$n=1,\\dots,6$ 的反应进程速率 $r_n$ 为：\n$r_1 = k_1(T) C_{\\mathrm{H}} C_{\\mathrm{O}_2}$\n$r_2 = k_2(T) C_{\\mathrm{O}} C_{\\mathrm{H}_2}$\n$r_3 = k_3(T) C_{\\mathrm{OH}} C_{\\mathrm{H}_2}$\n$r_4 = k_4(T) C_{\\mathrm{H}} C_{\\mathrm{O}_2} M$，其中 $M = \\sum_{l=0}^{7} C_l$\n$r_5 = k_5(T) C_{\\mathrm{HO}_2} C_{\\mathrm{H}}$\n$r_6 = k_6(T) C_{\\mathrm{HO}_2}^2$\n\n物种生成速率向量 $\\boldsymbol{\\omega}$ 计算为矩阵-向量乘积 $\\boldsymbol{\\omega} = \\mathbf{s} \\cdot \\mathbf{r}$，其中 $\\mathbf{r} = [r_1, r_2, r_3, r_4, r_5, r_6]^T$。\n\n**解析雅可比矩阵推导**\n解析雅可比矩阵是偏导数矩阵 $J_{ij} = \\frac{\\partial \\omega_i}{\\partial C_j}$。使用 $\\omega_i$ 的定义，我们有：\n$$\nJ_{i j} = \\frac{\\partial}{\\partial C_j} \\left( \\sum_{n=1}^{N_r} s_{i,n} r_n(\\mathbf{C}, T) \\right) = \\sum_{n=1}^{N_r} s_{i,n} \\frac{\\partial r_n}{\\partial C_j}\n$$\n该关系表明，雅可比矩阵的第 $j$ 列 $\\mathbf{J}_{:,j}$ 可以通过先求出每个反应速率对 $C_j$ 的导数向量 $(\\partial \\mathbf{r}/\\partial C_j)$，然后乘以化学计量矩阵来计算：$\\mathbf{J}_{:,j} = \\mathbf{s} \\cdot (\\partial \\mathbf{r}/\\partial C_j)$。\n\n针对每种反应类型推导导数 $\\partial r_n / \\partial C_j$。\n1.  **双分子反应 ($n \\in \\{1, 2, 3, 5\\}$):** 对于反应 $a+b \\rightarrow \\dots$，速率为 $r_n = k_n C_a C_b$。仅当 $j=a$ 或 $j=b$ 时，对 $C_j$ 的导数才不为零：\n    $$\n    \\frac{\\partial r_n}{\\partial C_j} = k_n \\frac{\\partial (C_a C_b)}{\\partial C_j} = k_n (C_b \\delta_{ja} + C_a \\delta_{jb})\n    $$\n    其中 $\\delta_{xy}$ 是 Kronecker delta。\n\n2.  **双分子自反应 ($n=6$):** 对于 $2a \\rightarrow \\dots$，速率为 $r_6 = k_6 C_a^2$。其导数为：\n    $$\n    \\frac{\\partial r_6}{\\partial C_j} = k_6 \\frac{\\partial (C_a^2)}{\\partial C_j} = 2k_6 C_a \\delta_{ja}\n    $$\n    在此问题中，$a = \\mathrm{HO}_2$。\n\n3.  **三分子反应 ($n=4$):** 对于 $a+b+M \\rightarrow \\dots$，速率为 $r_4 = k_4 C_a C_b M$。该导数需要使用乘法法则。\n    $$\n    \\frac{\\partial r_4}{\\partial C_j} = k_4 \\frac{\\partial (C_a C_b M)}{\\partial C_j} = k_4 \\left[ \\frac{\\partial(C_a C_b)}{\\partial C_j} M + C_a C_b \\frac{\\partial M}{\\partial C_j} \\right]\n    $$\n    由于 $M = \\sum_l C_l$，其导数 $\\partial M / \\partial C_j = 1$ 对任何 $j$ 都成立。项 $\\partial(C_a C_b)/\\partial C_j$ 由双分子反应法则给出。因此，\n    $$\n    \\frac{\\partial r_4}{\\partial C_j} = k_4 (C_b \\delta_{ja} + C_a \\delta_{jb}) M + k_4 C_a C_b\n    $$\n    在此问题中，$a = \\mathrm{H}$，$b = \\mathrm{O}_2$。\n\n这些表达式被实现用来计算解析雅可比矩阵 $\\mathbf{J}$ 的每一列。\n\n**有限差分雅可比矩阵**\n有限差分雅可比矩阵 $\\mathbf{J}^{\\mathrm{FD}}$ 是逐列计算的。对于每一列 $j$，扰动大小 $h_j$ 自适应地确定为：\n$$\nh_j = \\sqrt{\\epsilon} \\cdot \\max(1, |C_j|)\n$$\n其中 $\\epsilon$ 是双精度浮点数的机器精度。\n\n除非需要在负浓度下评估源项 $\\boldsymbol{\\omega}$，否则使用中心差分格式。\n- 如果 $C_j - h_j \\ge 0$，使用二阶中心差分：\n$$\n\\mathbf{J}^{\\mathrm{FD}}_{:,j} \\approx \\frac{\\boldsymbol{\\omega}(\\mathbf{C} + h_j \\mathbf{e}_j) - \\boldsymbol{\\omega}(\\mathbf{C} - h_j \\mathbf{e}_j)}{2h_j}\n$$\n- 如果 $C_j - h_j  0$，这在 $C_j=0$ 或 $C_j$ 非常小时发生，为保持正性，使用一阶前向差分：\n$$\n\\mathbf{J}^{\\mathrm{FD}}_{:,j} \\approx \\frac{\\boldsymbol{\\omega}(\\mathbf{C} + h_j \\mathbf{e}_j) - \\boldsymbol{\\omega}(\\mathbf{C})}{h_j}\n$$\n此处，$\\mathbf{e}_j$ 是第 $j$ 个物种的标准基向量。\n\n**比较与实现**\n使用相对 Frobenius 范数误差 $E$ 和稀疏模式一致性检查来比较两个雅可比矩阵。整个过程被封装在一个程序中，该程序遍历三个指定的测试案例，计算所需的量，并将输出格式化为单行。该程序首先设置常量和数据结构（化学计量矩阵、物种映射、Arrhenius 参数）。然后定义用于计算 $\\boldsymbol{\\omega}$、$\\mathbf{J}$ 和 $\\mathbf{J}^{\\mathrm{FD}}$ 的函数。一个主循环通过计算初始浓度并调用这些函数来处理每个测试案例以生成结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the chemical kinetics Jacobian problem for the specified H2/O2 mechanism.\n    \"\"\"\n    #\n    # --- 1. System Constants and Definitions ---\n    #\n    R = 8.314462618  # J/mol-K\n    T = 1200.0  # K\n    P_ATM = 101325.0  # Pa/atm\n    P = 1.0 * P_ATM  # Pa\n    C_TOT = P / (R * T)  # Total molar concentration in mol/m^3\n\n    SPECIES = ['H2', 'O2', 'H', 'O', 'OH', 'HO2', 'H2O2', 'H2O']\n    N_SPECIES = len(SPECIES)\n    species_map = {name: i for i, name in enumerate(SPECIES)}\n\n    # Net stoichiometric coefficients s[i, n] for species i in reaction n\n    # Rows: H2, O2, H, O, OH, HO2, H2O2, H2O\n    # Cols: R1, R2, R3, R4, R5, R6\n    s_matrix = np.array([\n        [ 0, -1, -1,  0,  0,  0],  # H2\n        [-1,  0,  0, -1,  0,  1],  # O2\n        [-1,  1,  1, -1, -1,  0],  # H\n        [ 1, -1,  0,  0,  0,  0],  # O\n        [ 1,  1, -1,  0,  2,  0],  # OH\n        [ 0,  0,  0,  1, -1, -2],  # HO2\n        [ 0,  0,  0,  0,  0,  1],  # H2O2\n        [ 0,  0,  1,  0,  0,  0],  # H2O\n    ], dtype=float)\n\n    # Arrhenius parameters (A, n, Ea) for each reaction\n    # Units: A in [m^3/mol/s] or [m^6/mol^2/s], n is dimensionless, Ea in [J/mol]\n    arrhenius_params = np.array([\n        # R1: H + O2 -> O + OH\n        [2.65e10, -0.5, 7.5e4],\n        # R2: O + H2 -> H + OH\n        [1.80e10, 0.0, 2.6e4],\n        # R3: OH + H2 -> H + H2O\n        [2.10e7, 1.0, 1.6e4],\n        # R4: H + O2 + M -> HO2 + M\n        [1.475e18, -1.0, 0.0],\n        # R5: HO2 + H -> 2 OH\n        [1.80e10, 0.0, 0.0],\n        # R6: 2 HO2 -> H2O2 + O2\n        [1.00e9, 0.0, 0.0],\n    ])\n\n    k_f = arrhenius_params[:, 0] * (T ** arrhenius_params[:, 1]) * np.exp(-arrhenius_params[:, 2] / (R * T))\n\n    #\n    # --- 2. Core Calculation Functions ---\n    #\n    def get_omega(C):\n        \"\"\"Computes the species source terms omega for a given concentration vector C.\"\"\"\n        r = np.zeros(6)\n        \n        # Unpack concentrations for readability\n        C_H2, C_O2, C_H, C_O, C_OH, C_HO2, C_H2O2, C_H2O = C\n        \n        # Rates of progress for the 6 reactions\n        r[0] = k_f[0] * C_H * C_O2\n        r[1] = k_f[1] * C_O * C_H2\n        r[2] = k_f[2] * C_OH * C_H2\n        M = np.sum(C) # Third-body concentration\n        r[3] = k_f[3] * C_H * C_O2 * M\n        r[4] = k_f[4] * C_HO2 * C_H\n        r[5] = k_f[5] * C_HO2**2\n        \n        return s_matrix @ r\n\n    def get_analytic_jacobian(C):\n        \"\"\"Computes the analytic Jacobian matrix.\"\"\"\n        J = np.zeros((N_SPECIES, N_SPECIES))\n        \n        # Unpack concentrations\n        C_H2, C_O2, C_H, C_O, C_OH, C_HO2, C_H2O2, C_H2O = C\n        idx_H2, idx_O2, idx_H, idx_O, idx_OH, idx_HO2, idx_H2O2, idx_H2O = range(8)\n        \n        M = np.sum(C)\n        \n        # Loop over columns j of the Jacobian (derivative w.r.t. C_j)\n        for j in range(N_SPECIES):\n            dr_dCj = np.zeros(6) # Vector of d(r_n)/d(C_j) for n=1..6\n            \n            # R1: H + O2 -> O + OH\n            if j == idx_H: dr_dCj[0] = k_f[0] * C_O2\n            elif j == idx_O2: dr_dCj[0] = k_f[0] * C_H\n            \n            # R2: O + H2 -> H + OH\n            if j == idx_O: dr_dCj[1] = k_f[1] * C_H2\n            elif j == idx_H2: dr_dCj[1] = k_f[1] * C_O\n                \n            # R3: OH + H2 -> H + H2O\n            if j == idx_OH: dr_dCj[2] = k_f[2] * C_H2\n            elif j == idx_H2: dr_dCj[2] = k_f[2] * C_OH\n            \n            # R4: H + O2 + M -> HO2 + M\n            dr_dCj[3] = k_f[3] * C_H * C_O2 # dM/dCj = 1 term\n            if j == idx_H: dr_dCj[3] += k_f[3] * C_O2 * M\n            elif j == idx_O2: dr_dCj[3] += k_f[3] * C_H * M\n\n            # R5: HO2 + H -> 2 OH\n            if j == idx_HO2: dr_dCj[4] = k_f[4] * C_H\n            elif j == idx_H: dr_dCj[4] = k_f[4] * C_HO2\n            \n            # R6: 2 HO2 -> H2O2 + O2\n            if j == idx_HO2: dr_dCj[5] = 2.0 * k_f[5] * C_HO2\n            \n            J[:, j] = s_matrix @ dr_dCj\n            \n        return J\n\n    def get_fd_jacobian(C):\n        \"\"\"Computes the Jacobian matrix using finite differences.\"\"\"\n        J_fd = np.zeros((N_SPECIES, N_SPECIES))\n        eps = np.finfo(float).eps\n        omega_0 = get_omega(C)\n\n        for j in range(N_SPECIES):\n            h = np.sqrt(eps) * max(1.0, abs(C[j]))\n            \n            if C[j] - h  0: # Use forward difference\n                C_plus = C.copy()\n                C_plus[j] += h\n                omega_plus = get_omega(C_plus)\n                J_fd[:, j] = (omega_plus - omega_0) / h\n            else: # Use central difference\n                C_plus = C.copy()\n                C_plus[j] += h\n                C_minus = C.copy()\n                C_minus[j] -= h\n                \n                omega_plus = get_omega(C_plus)\n                omega_minus = get_omega(C_minus)\n                J_fd[:, j] = (omega_plus - omega_minus) / (2.0 * h)\n        return J_fd\n\n    #\n    # --- 3. Test Cases ---\n    #\n    test_cases = [\n        # Case 1: Stoichiometric with radical seeds\n        {\n            'H2': 2./3. - 2e-12, 'O2': 1./3., 'H': 1e-12, 'OH': 1e-12\n        },\n        # Case 2: Lean with radical seed\n        {\n            'H2': 0.2, 'O2': 0.8 - 1e-12, 'H': 1e-12\n        },\n        # Case 3: Radical-free stoichiometric\n        {\n            'H2': 2./3., 'O2': 1./3.\n        },\n    ]\n\n    results = []\n    for case_mole_fracs in test_cases:\n        x = np.zeros(N_SPECIES)\n        for name, val in case_mole_fracs.items():\n            x[species_map[name]] = val\n        C = x * C_TOT\n        \n        # Compute Jacobians\n        J_analytic = get_analytic_jacobian(C)\n        J_fd = get_fd_jacobian(C)\n        \n        # Compare Jacobians\n        norm_J_fd = np.linalg.norm(J_fd, 'fro')\n        norm_diff = np.linalg.norm(J_analytic - J_fd, 'fro')\n        \n        if norm_J_fd == 0.0:\n            error = 0.0 if norm_diff == 0.0 else np.inf\n        else:\n            error = norm_diff / norm_J_fd\n            \n        # Compare sparsity patterns\n        tau = 1e-20\n        sparsity_J = np.abs(J_analytic) > tau\n        sparsity_J_fd = np.abs(J_fd) > tau\n        sparsity_match = np.all(sparsity_J == sparsity_J_fd)\n        \n        results.extend([error, sparsity_match])\n\n    #\n    # --- 4. Final Output ---\n    #\n    output_str = f\"[{','.join(map(str, results))}]\"\n    output_str = output_str.replace(\"True\", \"True\").replace(\"False\", \"False\") # Ensure capitalization\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了雅可比矩阵的计算之后，一个实际的性能问题随之而来：我们应该在牛顿迭代过程中多频繁地更新和分解雅可比矩阵？本实践通过一个具体的化学反应系统，让你实现并比较全牛顿法、修正牛顿法和弦法的性能。通过量化它们在不同条件下的迭代次数和计算开销，你将深入理解在求解器设计中，计算成本与收敛速度之间的权衡。",
            "id": "4031740",
            "problem": "考虑一个由质量作用动力学和阿伦尼乌斯温度依赖性描述的均相、恒压、空间均匀的反应混合物。令 $y_A$、$y_B$ 和 $y_C$ 表示摩尔浓度，单位为 $\\mathrm{mol}\\,\\mathrm{m}^{-3}$。反应机理是一个双分子转化 $A + B \\rightarrow C$ 和一个单分子转化 $B \\rightarrow C$。物种的常微分方程 (ODE) 为，其中理想气体常数 $R$ 的单位为 $\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$，\n$$\n\\frac{dy_A}{dt} = -k_1(T)\\,y_A\\,y_B,\\quad\n\\frac{dy_B}{dt} = -k_1(T)\\,y_A\\,y_B - k_2(T)\\,y_B,\\quad\n\\frac{dy_C}{dt} = k_1(T)\\,y_A\\,y_B + k_2(T)\\,y_B,\n$$\n其中阿伦尼乌斯速率系数为 $k_1(T) = A_1\\,\\exp\\!\\left(-\\frac{E_1}{R\\,T}\\right)$，单位为 $\\mathrm{m}^3\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$，以及 $k_2(T) = A_2\\,\\exp\\!\\left(-\\frac{E_2}{R\\,T}\\right)$，单位为 $\\mathrm{s}^{-1}$。假设在一个大小为 $h$（单位为 $\\mathrm{s}$）的单个隐式时间步长内，温度发生外部施加的阶跃变化，从 $T_n$ 变为 $T_{n+1}$。这种外部变化模拟了快速热瞬变（例如，由压缩或放热引起），同时将比较重点放在非线性代数求解上。\n\n我们考虑一个时间步长的后向欧拉离散化，\n$$\n\\boldsymbol{F}(\\boldsymbol{y}) \\equiv \\boldsymbol{y} - \\boldsymbol{y}_n - h\\,\\boldsymbol{\\omega}(\\boldsymbol{y},T_{n+1}) = \\boldsymbol{0},\n$$\n其中 $\\boldsymbol{y} = [y_A, y_B, y_C]^T$ 并且 $\\boldsymbol{\\omega}(\\boldsymbol{y},T)$ 是由上述 ODE 隐含的反应源项向量。\n\n该非线性系统将使用三种 Newton-Raphson 变体进行求解：\n- 完全牛顿法 (Full Newton)：在每个非线性迭代中，在 $T_{n+1}$ 温度下重新计算雅可比矩阵 $\\boldsymbol{J}(\\boldsymbol{y}) = \\frac{\\partial \\boldsymbol{F}}{\\partial \\boldsymbol{y}}$；每次都对其进行因式分解。\n- 修正牛顿法 (Modified Newton, 滞后雅可比)：在每个时间步中，仅在初始迭代时计算和因式分解一次 $\\boldsymbol{J}$（使用 $T_{n+1}$），并在该步的所有后续迭代中重用其因式分解。\n- 弦截法 (Chord method, 跨时间步冻结雅可比)：在当前步的所有迭代中，重用前一个时间步的雅可比矩阵因式分解（在 $\\boldsymbol{y}_n$ 和 $T_n$ 处求值）；在当前步中不重新进行因式分解。\n\n你的任务：\n1. 从质量作用 ODE 和后向欧拉离散化出发，推导牛顿更新所需的残差 $\\boldsymbol{F}(\\boldsymbol{y})$ 和雅可比矩阵结构。论证为什么该系统是刚性的，以及为什么当 $T$ 变化时 $\\boldsymbol{J}$ 会迅速变化。\n2. 为每种变体（完全牛顿法、修正牛顿法和弦截法）实现一个稳健的牛顿求解器，该求解器应包含回溯线搜索和浓度正值保持功能。使用残差的二范数作为收敛判据 $\\|\\boldsymbol{F}(\\boldsymbol{y})\\|_2 \\le \\varepsilon$，其中 $\\varepsilon = 10^{-10}$，并且每步最多迭代 $50$ 次。任何在迭代次数上限内未满足收敛容差的方法都视为失败，并为该方法报告 $-1$ 次迭代。\n3. 对于单个隐式时间步，通过报告每种方法使用的非线性迭代总次数和在该步中执行的 $\\mathrm{LU}$ 因式分解次数，来量化较少的矩阵因式分解和较慢的收敛速度之间的权衡。每当一个新的雅可比矩阵被因式分解时，因式分解次数计为一次；重用先前已因式分解的雅可比矩阵不增加计数。\n\n使用的单位：\n- 浓度单位为 $\\mathrm{mol}\\,\\mathrm{m}^{-3}$，\n- 时间单位为 $\\mathrm{s}$，\n- 温度单位为 $\\mathrm{K}$，\n- 活化能单位为 $\\mathrm{J}\\,\\mathrm{mol}^{-1}$。\n\n常数和参数：\n- 气体常数 $R = 8.314\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$，\n- 反应指前因子和活化能 $(A_1, E_1)$、$(A_2, E_2)$ 按每个测试提供。\n\n初始状态：\n- $\\boldsymbol{y}_n = [y_{A,n}, y_{B,n}, y_{C,n}]^T$ 按每个测试提供。\n\n测试套件：\n每个测试用例是一个元组 $(A_1, E_1, A_2, E_2, T_n, \\Delta T, h, y_{A,n}, y_{B,n}, y_{C,n})$，其中 $T_{n+1} = T_n + \\Delta T$。使用以下三种情况来探索温度变化和时间步长的不同区域：\n- 情况 1 (小温度变化，中等刚性)：$(1.0\\times 10^6, 8.0\\times 10^4, 1.0\\times 10^3, 1.1\\times 10^5, 1100, 10, 1.0\\times 10^{-4}, 2.0, 1.0, 0.0)$。\n- 情况 2 (中等温度变化，刚性增加)：$(1.0\\times 10^6, 8.0\\times 10^4, 1.0\\times 10^3, 1.1\\times 10^5, 1100, 150, 3.0\\times 10^{-4}, 2.0, 1.0, 0.0)$。\n- 情况 3 (快速温度变化，强刚性)：$(1.0\\times 10^6, 8.0\\times 10^4, 1.0\\times 10^3, 1.1\\times 10^5, 1100, 500, 1.0\\times 10^{-3}, 2.0, 1.0, 0.0)$。\n\n最终输出规范：\n- 对于每个测试用例，你的程序必须输出一个包含六个条目的列表：$[i_{\\mathrm{full}}, i_{\\mathrm{mod}}, i_{\\mathrm{chord}}, f_{\\mathrm{full}}, f_{\\mathrm{mod}}, f_{\\mathrm{chord}}]$，其中 $i_{\\cdot}$ 是该方法使用的非线性迭代次数，而 $f_{\\cdot}$ 是如上定义的在该步中执行的 $\\mathrm{LU}$ 因式分解次数。如果某个方法在迭代次数上限内未能收敛，则报告 $i_{\\cdot} = -1$，并根据其在尝试迭代期间的策略计算因式分解次数。\n- 你的程序应生成单行输出，其中包含所有三个测试用例的结果，格式为一个逗号分隔的列表，并用方括号括起来，其中每个元素本身就是针对一个测试用例的六元素列表，例如 $[[\\dots],[\\dots],[\\dots]]$。",
            "solution": "用户提供了一个计算化学动力学问题，重点是比较不同的 Newton-Raphson 方法变体，用于求解由刚性常微分方程 (ODE) 系统的隐式时间积分产生的非线性代数方程。\n\n### 第 1 步：提取已知条件\n\n**ODE 系统：**\n反应机理由以下关于摩尔浓度 $y_A, y_B, y_C$ 的 ODE 描述：\n$$\n\\frac{dy_A}{dt} = -k_1(T)\\,y_A\\,y_B\n$$\n$$\n\\frac{dy_B}{dt} = -k_1(T)\\,y_A\\,y_B - k_2(T)\\,y_B\n$$\n$$\n\\frac{dy_C}{dt} = k_1(T)\\,y_A\\,y_B + k_2(T)\\,y_B\n$$\n\n**速率系数：**\n阿伦尼乌斯速率系数为：\n- $k_1(T) = A_1\\,\\exp\\!\\left(-\\frac{E_1}{R\\,T}\\right)$\n- $k_2(T) = A_2\\,\\exp\\!\\left(-\\frac{E_2}{R\\,T}\\right)$\n\n**数值方法：**\n- 在时间步长 $h$ 上的后向欧拉离散化：$\\boldsymbol{y} - \\boldsymbol{y}_n - h\\,\\boldsymbol{\\omega}(\\boldsymbol{y},T_{n+1}) = \\boldsymbol{0}$，其中 $\\boldsymbol{y}$ 是时间 $t_{n+1}$ 的状态，$\\boldsymbol{y}_n$ 是时间 $t_n$ 的状态。\n- $\\boldsymbol{\\omega}(\\boldsymbol{y},T)$ 是反应源项向量。\n- 得到的非线性系统是 $\\boldsymbol{F}(\\boldsymbol{y}) = \\boldsymbol{0}$。\n\n**待实现的 Newton-Raphson 变体：**\n1.  **完全牛顿法 (Full Newton)**：在每次迭代中重新计算和因式分解雅可比矩阵 $\\boldsymbol{J}(\\boldsymbol{y}) = \\frac{\\partial \\boldsymbol{F}}{\\partial \\boldsymbol{y}}$。\n2.  **修正牛顿法 (Modified Newton)**：每个时间步在初始迭代时计算和因式分解一次 $\\boldsymbol{J}$，并重用该因式分解。\n3.  **弦截法 (Chord method)**：重用前一个时间步的雅可比矩阵因式分解，该矩阵在 $\\boldsymbol{y}_n$ 和 $T_n$ 处求值。\n\n**求解器规格：**\n- 收敛容差：$\\|\\boldsymbol{F}(\\boldsymbol{y})\\|_2 \\le \\varepsilon = 10^{-10}$。\n- 每步最大迭代次数：$50$。\n- 失败条件：如果未满足容差，则报告迭代次数为 $-1$。\n- 线搜索：必须包含回溯和正值保持。\n\n**常数：**\n- 理想气体常数 $R = 8.314\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。\n\n**测试用例：**\n每个测试用例是一个元组 $(A_1, E_1, A_2, E_2, T_n, \\Delta T, h, y_{A,n}, y_{B,n}, y_{C,n})$，其中 $T_{n+1} = T_n + \\Delta T$。\n- 情况 1：$(1.0\\times 10^6, 8.0\\times 10^4, 1.0\\times 10^3, 1.1\\times 10^5, 1100, 10, 1.0\\times 10^{-4}, 2.0, 1.0, 0.0)$\n- 情况 2：$(1.0\\times 10^6, 8.0\\times 10^4, 1.0\\times 10^3, 1.1\\times 10^5, 1100, 150, 3.0\\times 10^{-4}, 2.0, 1.0, 0.0)$\n- 情况 3：$(1.0\\times 10^6, 8.0\\times 10^4, 1.0\\times 10^3, 1.1\\times 10^5, 1100, 500, 1.0\\times 10^{-3}, 2.0, 1.0, 0.0)$\n\n**输出规范：**\n对于每个情况，一个列表 $[i_{\\mathrm{full}}, i_{\\mathrm{mod}}, i_{\\mathrm{chord}}, f_{\\mathrm{full}}, f_{\\mathrm{mod}}, f_{\\mathrm{chord}}]$，其中 $i$ 是迭代次数，$f$ 是因式分解次数。最终输出是这些列表的列表。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n- **科学依据：** 该问题基于标准的质量作用动力学和阿伦尼乌斯温度依赖性，这些是化学动力学和燃烧模拟中的基本原理。使用后向欧拉法和 Newton-Raphson 法是求解刚性 ODE 系统的标准数值技术。该设置在科学上是合理的。\n- **适定性：** 该问题提供了一整套 ODE、初始条件、参数以及一个明确定义的数值任务。所有必要信息都已给出，可以为每种指定方法在时间步结束时获得浓度的唯一解。\n- **客观性：** 该问题以精确的数学和计算术语陈述，没有任何主观或偏见的语言。任务是对数值方法进行定量比较。\n\n该问题是在计算科学中将数值方法应用于刚性系统的经典示例。它不违反任何无效性标准。\n\n### 第 3 步：结论和行动\n问题有效。将提供一个解决方案。\n\n---\n\n### 第 1 部分：推导和论证\n\n令状态向量为 $\\boldsymbol{y} = [y_A, y_B, y_C]^T$。反应源项向量 $\\boldsymbol{\\omega}(\\boldsymbol{y}, T)$ 由下式给出：\n$$\n\\boldsymbol{\\omega}(\\boldsymbol{y}, T) = \\begin{pmatrix} \\omega_A \\\\ \\omega_B \\\\ \\omega_C \\end{pmatrix} = \\begin{pmatrix} -k_1(T)\\,y_A\\,y_B \\\\ -k_1(T)\\,y_A\\,y_B - k_2(T)\\,y_B \\\\ k_1(T)\\,y_A\\,y_B + k_2(T)\\,y_B \\end{pmatrix}\n$$\n后向欧拉法在时间步长 $h = t_{n+1} - t_n$ 上将 ODE 系统 $\\frac{d\\boldsymbol{y}}{dt} = \\boldsymbol{\\omega}(\\boldsymbol{y}, T)$ 离散化为：\n$$\n\\frac{\\boldsymbol{y}_{n+1} - \\boldsymbol{y}_n}{h} = \\boldsymbol{\\omega}(\\boldsymbol{y}_{n+1}, T_{n+1})\n$$\n为了求解未知状态 $\\boldsymbol{y}_{n+1}$，我们定义一个非线性残差函数 $\\boldsymbol{F}(\\boldsymbol{y})$，其中 $\\boldsymbol{y}$ 代表 $\\boldsymbol{y}_{n+1}$：\n$$\n\\boldsymbol{F}(\\boldsymbol{y}) \\equiv \\boldsymbol{y} - \\boldsymbol{y}_n - h\\,\\boldsymbol{\\omega}(\\boldsymbol{y}, T_{n+1}) = \\boldsymbol{0}\n$$\n残差向量的分量为：\n$$\n\\boldsymbol{F}(\\boldsymbol{y}) = \\begin{pmatrix}\ny_A - y_{A,n} + h\\,k_1(T_{n+1})\\,y_A\\,y_B \\\\\ny_B - y_{B,n} + h\\,k_1(T_{n+1})\\,y_A\\,y_B + h\\,k_2(T_{n+1})\\,y_B \\\\\ny_C - y_{C,n} - h\\,k_1(T_{n+1})\\,y_A\\,y_B - h\\,k_2(T_{n+1})\\,y_B\n\\end{pmatrix}\n$$\n用于求解 $\\boldsymbol{F}(\\boldsymbol{y}) = \\boldsymbol{0}$ 的 Newton-Raphson 方法是一个迭代方案：\n$$\n\\boldsymbol{J}(\\boldsymbol{y}^{(k)}) \\delta\\boldsymbol{y}^{(k+1)} = -\\boldsymbol{F}(\\boldsymbol{y}^{(k)})\n$$\n$$\n\\boldsymbol{y}^{(k+1)} = \\boldsymbol{y}^{(k)} + \\alpha \\delta\\boldsymbol{y}^{(k+1)}\n$$\n其中 $\\delta\\boldsymbol{y}$ 是更新步长，$\\alpha$ 是线搜索参数，$\\boldsymbol{J}(\\boldsymbol{y})$ 是残差 $\\boldsymbol{F}$ 关于 $\\boldsymbol{y}$ 的雅可比矩阵。雅可比矩阵定义为 $\\boldsymbol{J}(\\boldsymbol{y}) = \\frac{\\partial \\boldsymbol{F}}{\\partial \\boldsymbol{y}} = \\boldsymbol{I} - h \\frac{\\partial \\boldsymbol{\\omega}}{\\partial \\boldsymbol{y}}$，其中 $\\boldsymbol{I}$ 是单位矩阵。\n\n在某个状态 $(\\boldsymbol{y}, T)$ 下求值的源项雅可比矩阵 $\\boldsymbol{J}_{\\omega} = \\frac{\\partial \\boldsymbol{\\omega}}{\\partial \\boldsymbol{y}}$ 为：\n$$\n\\boldsymbol{J}_{\\omega}(\\boldsymbol{y}, T) =\n\\begin{pmatrix}\n\\frac{\\partial \\omega_A}{\\partial y_A}  \\frac{\\partial \\omega_A}{\\partial y_B}  \\frac{\\partial \\omega_A}{\\partial y_C} \\\\\n\\frac{\\partial \\omega_B}{\\partial y_A}  \\frac{\\partial \\omega_B}{\\partial y_B}  \\frac{\\partial \\omega_B}{\\partial y_C} \\\\\n\\frac{\\partial \\omega_C}{\\partial y_A}  \\frac{\\partial \\omega_C}{\\partial y_B}  \\frac{\\partial \\omega_C}{\\partial y_C}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-k_1(T)\\,y_B  -k_1(T)\\,y_A  0 \\\\\n-k_1(T)\\,y_B  -k_1(T)\\,y_A - k_2(T)  0 \\\\\nk_1(T)\\,y_B  k_1(T)\\,y_A + k_2(T)  0\n\\end{pmatrix}\n$$\n因此，残差函数的雅可比矩阵 $\\boldsymbol{J}(\\boldsymbol{y})=\\boldsymbol{I} - h\\,\\boldsymbol{J}_{\\omega}(\\boldsymbol{y}, T_{n+1})$ 为：\n$$\n\\boldsymbol{J}(\\boldsymbol{y}) =\n\\begin{pmatrix}\n1 + h\\,k_1(T_{n+1})\\,y_B  h\\,k_1(T_{n+1})\\,y_A  0 \\\\\nh\\,k_1(T_{n+1})\\,y_B  1 + h\\,k_1(T_{n+1})\\,y_A + h\\,k_2(T_{n+1})  0 \\\\\n-h\\,k_1(T_{n+1})\\,y_B  -(h\\,k_1(T_{n+1})\\,y_A + h\\,k_2(T_{n+1}))  1\n\\end{pmatrix}\n$$\n\n**刚性和雅可比矩阵敏感性的论证：**\n如果一个 ODE 系统的动力学包含广泛分离的时间尺度，则该系统是刚性的。这些时间尺度与源项雅可比矩阵 $\\boldsymbol{J}_{\\omega}$ 的特征值大小的倒数有关。$\\boldsymbol{J}_{\\omega}$ 的特征值决定了对系统的扰动衰减的速度。特征值是特征方程 $\\det(\\boldsymbol{J}_{\\omega} - \\lambda\\boldsymbol{I}) = 0$ 的根。由于 $\\boldsymbol{J}_{\\omega}$ 的第三列为零，一个特征值为 $\\lambda_1 = 0$。另外两个特征值 $\\lambda_2$ 和 $\\lambda_3$ 由左上角的 $2\\times2$ 子矩阵决定。它们是实数且为负，其大小是 $k_1, k_2, y_A$ 和 $y_B$ 的函数。刚性由非零特征值的比率 $\\max|\\lambda_i|/\\min|\\lambda_i|$ 来表征，当速率常数 $k_1$ 和 $k_2$ 差异显著，或者一个反应路径比另一个快得多时，刚性会变得很明显。\n\n雅可比矩阵 $\\boldsymbol{J}$ 对温度的敏感性源于速率系数的阿伦尼乌斯形式，$k(T) = A\\exp(-E/RT)$。活化能 $E_1$ 和 $E_2$ 很大，使得指数项对温度 $T$ 的变化高度敏感。即使 $T$ 的微小变化也可能导致 $k_1$ 和 $k_2$ 发生数量级的变化。由于 $\\boldsymbol{J}$ 的元素是 $h \\cdot k_1(T_{n+1})$ 和 $h \\cdot k_2(T_{n+1})$ 的线性函数，雅可比矩阵本身也随温度迅速变化。\n\n当发生大的温度阶跃 $\\Delta T = T_{n+1} - T_n$ 时，在 $T_n$ 处计算的弦截法的雅可比矩阵成为在 $T_{n+1}$ 处进行牛顿求解所需的真实雅可比矩阵的一个非常差的近似。近似雅可比矩阵与 $\\boldsymbol{F}$ 的实际局部梯度之间的这种不匹配导致收敛速率急剧下降，常常导致方法失败。修正牛顿法在 $T_{n+1}$ 处计算雅可比矩阵但不更新它，表现更好，但如果在迭代求解过程中浓度 $\\boldsymbol{y}$ 发生显著变化，其收敛速度可能仍比完全牛顿法慢。\n\n### 第 2 和第 3 部分：实现和量化\n\n下面的 Python 代码实现了三种牛顿变体。单个函数 `newton_solver` 通过调整雅可比矩阵的计算和因式分解策略来处理所有三种情况。对于弦截法，雅可比矩阵在 $(\\boldsymbol{y}_n, T_n)$ 处求值，但为了与该方法重用*前一个*步的因式分解的定义保持一致，此因式分解的成本不计入*当前*步（即 `factorizations = 0`）。修正牛顿法在步的开始时计算和因式分解一次雅可比矩阵（`factorizations = 1`）。完全牛顿法在每次迭代时都计算和因式分解雅可比矩阵，因此因式分解的次数等于迭代次数。所有方法都采用回溯线搜索，该搜索强制保证物种的正值性和残差范数的减小。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for comparing Newton-Raphson variants.\n    \"\"\"\n    # Universal constant\n    R = 8.314  # J mol^-1 K^-1\n\n    # Test cases: (A1, E1, A2, E2, Tn, dT, h, yA_n, yB_n, yC_n)\n    test_cases = [\n        # Case 1: Small dT, mild stiffness\n        (1.0e6, 8.0e4, 1.0e3, 1.1e5, 1100.0, 10.0, 1.0e-4, 2.0, 1.0, 0.0),\n        # Case 2: Moderate dT, increased stiffness\n        (1.0e6, 8.0e4, 1.0e3, 1.1e5, 1100.0, 150.0, 3.0e-4, 2.0, 1.0, 0.0),\n        # Case 3: Rapid dT, strong stiffness\n        (1.0e6, 8.0e4, 1.0e3, 1.1e5, 1100.0, 500.0, 1.0e-3, 2.0, 1.0, 0.0),\n    ]\n\n    all_results = []\n    for i, case in enumerate(test_cases):\n        case_results = []\n        \n        # Run for Full Newton, Modified Newton, Chord\n        methods = ['full', 'modified', 'chord']\n        iter_results = []\n        fact_results = []\n\n        for method in methods:\n            iters, facts = newton_solver(method, case, R)\n            iter_results.append(iters)\n            fact_results.append(facts)\n        \n        case_results.extend(iter_results)\n        case_results.extend(fact_results)\n        all_results.append(case_results)\n\n    # Format output as specified\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_rates(T, kin_params, R):\n    \"\"\"Calculates Arrhenius rate coefficients k1 and k2.\"\"\"\n    A1, E1, A2, E2 = kin_params\n    k1 = A1 * np.exp(-E1 / (R * T))\n    k2 = A2 * np.exp(-E2 / (R * T))\n    return k1, k2\n\ndef calculate_residual(y, y_n, h, k1_np1, k2_np1):\n    \"\"\"Calculates the residual vector F(y) for the backward Euler step.\"\"\"\n    yA, yB, _ = y\n    \n    omega_A = -k1_np1 * yA * yB\n    omega_B = -k1_np1 * yA * yB - k2_np1 * yB\n    omega_C = -omega_A - k2_np1 * yB\n    \n    F = np.zeros(3)\n    F[0] = y[0] - y_n[0] - h * omega_A\n    F[1] = y[1] - y_n[1] - h * omega_B\n    F[2] = y[2] - y_n[2] - h * omega_C\n    return F\n\ndef calculate_jacobian(y, h, k1, k2):\n    \"\"\"Calculates the Jacobian matrix J = dF/dy.\"\"\"\n    yA, yB, _ = y\n    \n    J = np.zeros((3, 3))\n    \n    J[0, 0] = 1.0 + h * k1 * yB\n    J[0, 1] = h * k1 * yA\n    J[0, 2] = 0.0\n    \n    J[1, 0] = h * k1 * yB\n    J[1, 1] = 1.0 + h * k1 * yA + h * k2\n    J[1, 2] = 0.0\n    \n    J[2, 0] = -h * k1 * yB\n    J[2, 1] = -(h * k1 * yA + h * k2)\n    J[2, 2] = 1.0\n    \n    return J\n\ndef newton_solver(method, case_params, R):\n    \"\"\"\n    Solves the nonlinear system for one time step using a specified Newton variant.\n    \n    Returns:\n        (int): Number of iterations (-1 on failure).\n        (int): Number of LU factorizations performed.\n    \"\"\"\n    A1, E1, A2, E2, T_n, dT, h, yA_n, yB_n, yC_n = case_params\n    kin_params = (A1, E1, A2, E2)\n    \n    y_n = np.array([yA_n, yB_n, yC_n])\n    T_np1 = T_n + dT\n    \n    max_iter = 50\n    tol = 1.0e-10\n    min_alpha = 1.0e-8\n\n    factorizations = 0\n    \n    y_k = y_n.copy()\n    \n    # Rate constants at T_{n+1} are always needed for the residual\n    k1_np1, k2_np1 = calculate_rates(T_np1, kin_params, R)\n    \n    lu_piv = None\n    \n    # Pre-computation of Jacobian based on method\n    if method == 'chord':\n        k1_n, k2_n = calculate_rates(T_n, kin_params, R)\n        J = calculate_jacobian(y_n, h, k1_n, k2_n)\n        lu_piv = lu_factor(J)\n        # By definition, Chord reuses a factorization from a previous step.\n        # So, the cost for the current step is 0.\n        factorizations = 0  \n    elif method == 'modified':\n        J = calculate_jacobian(y_k, h, k1_np1, k2_np1)\n        lu_piv = lu_factor(J)\n        factorizations = 1\n    \n    for i in range(max_iter):\n        F_k = calculate_residual(y_k, y_n, h, k1_np1, k2_np1)\n        norm_F_k = np.linalg.norm(F_k)\n        \n        if norm_F_k = tol:\n            return i, factorizations\n        \n        if method == 'full':\n            J = calculate_jacobian(y_k, h, k1_np1, k2_np1)\n            lu_piv = lu_factor(J)\n            factorizations += 1\n        \n        try:\n            delta_y = lu_solve(lu_piv, -F_k, check_finite=False)\n        except np.linalg.LinAlgError:\n            # Singular matrix indicates failure\n            return -1, factorizations\n\n        # Backtracking line search with positivity and residual reduction\n        alpha = 1.0\n        \n        # Positivity preservation\n        while True:\n            y_trial = y_k + alpha * delta_y\n            if np.all(y_trial >= 0):\n                break\n            alpha /= 2.0\n            if alpha  min_alpha:\n                return -1, factorizations # Failed to find a positive update\n\n        # Residual reduction\n        while True:\n            y_trial = y_k + alpha * delta_y\n            F_trial = calculate_residual(y_trial, y_n, h, k1_np1, k2_np1)\n            norm_F_trial = np.linalg.norm(F_trial)\n            if norm_F_trial  norm_F_k:\n                break\n            alpha /= 2.0\n            if alpha  min_alpha:\n                # Accept small step even if norm doesn't decrease, might be near minimum\n                break\n            \n\n        y_k = y_trial\n    \n    # Final check after max_iter\n    F_final = calculate_residual(y_k, y_n, h, k1_np1, k2_np1)\n    if np.linalg.norm(F_final) = tol:\n        # Converged on the last possible iteration\n        if method == 'full':\n            factorizations = max_iter\n        return max_iter, factorizations\n    else:\n        # If max_iter reached and not converged, update factorization count\n        # for 'full' on the last iteration before returning failure.\n        if method == 'full':\n           factorizations = max_iter\n        elif method == 'modified' and max_iter > 0:\n            factorizations = 1\n        return -1, factorizations\n\nsolve()\n```"
        }
    ]
}