{
    "hands_on_practices": [
        {
            "introduction": "任何对化学反应机理的详细分析都始于准确构建每个物种浓度变化速率的能力。本练习 () 为这项基本技能提供了基础实践。通过将质量作用定律应用于一个简单的代表性反应系统，你将推导出关键自由基的生成速率（Rate of Production, ROP），并学会系统地区分形成该物种与消耗该物种的化学路径。",
            "id": "4060890",
            "problem": "考虑一个包含四种物种 $H$、$O_2$、$HO_2$ 和 $H_2O_2$ 的等温、等压、空间均匀的理想气体混合物。其基元化学机理仅限于以下两个可逆反应：\n$$\nR_1:\\quad H + O_2 \\rightleftharpoons HO_2, \\qquad R_2:\\quad HO_2 + HO_2 \\rightleftharpoons H_2O_2 + O_2.\n$$\n假设为基元质量作用动力学。分别用 $k_{1f}$、$k_{1r}$ 表示反应 $R_1$ 的正向和逆向速率系数，用 $k_{2f}$、$k_{2r}$ 表示反应 $R_2$ 的正向和逆向速率系数。令 $[X]$ 表示物种 $X$ 的摩尔浓度。使用基于化学计量和质量作用动力学的标准物种生成速率定义，推导出 $HO_2$ 的生成速率（Rate of Production, ROP），记为 $\\mathrm{ROP}_{HO_2}$，其表达式为 $k_{1f}$、$k_{1r}$、$k_{2f}$、$k_{2r}$、$[H]$、$[O_2]$、$[HO_2]$ 和 $[H_2O_2]$ 的函数。明确指出哪些项对应于 $HO_2$ 的生成，哪些对应于其消耗，并将它们组合成 $\\mathrm{ROP}_{HO_2}$ 的单个简化表达式。\n\n用摩尔浓度（例如，单位为 $\\mathrm{mol}\\,\\mathrm{cm}^{-3}$）和时间（例如，单位为 $\\mathrm{s}$）的符号形式表示最终表达式，使得 $\\mathrm{ROP}_{HO_2}$ 的量纲为浓度/时间。不要代入数值，也不要进行任何单位转换。最终答案必须是单个闭式解析表达式（不含不等式或待解方程）。无需进行四舍五入。",
            "solution": "该问题要求在一个由两个可逆基元反应定义的化学体系中，推导物种 $HO_2$ 的生成速率（ROP）。给定物种的 ROP 是其摩尔浓度因体系中所有化学反应而变化的净速率。对于一个参与 $N_r$ 个基元反应的物种 $i$，其 ROP（我们也可以表示为其净生成速率 $\\omega_i = \\frac{d[X_i]}{dt}$）由其在每个反应中的生成速率之和给出：\n$$\n\\mathrm{ROP}_{i} = \\sum_{j=1}^{N_r} \\omega_{ij}\n$$\n其中 $\\omega_{ij}$ 是物种 $i$ 在反应 $j$ 中的生成速率。该项可以表示为：\n$$\n\\omega_{ij} = \\nu_{ij} q_j\n$$\n此处，$\\nu_{ij}$ 是物种 $i$ 在反应 $j$ 中的净化学计量系数（定义为生成物侧的化学计量系数减去反应物侧的化学计量系数，即 $\\nu_{ij} = \\nu''_{ij} - \\nu'_{ij}$，其中 $\\nu''_{ij}$ 为生成物系数，$\\nu'_{ij}$ 为反应物系数），而 $q_j$ 是反应 $j$ 的净进展速率。\n\n对于一个基元可逆反应，净进展速率 $q_j$ 是正向速率与逆向速率之差。根据基元反应的质量作用定律，这些速率与反应物浓度的乘积成正比，其中每种反应物的浓度都取其化学计量系数的幂次方。\n因此，物种 $i$ 的总 ROP 为：\n$$\n\\mathrm{ROP}_{i} = \\sum_{j=1}^{N_r} \\nu_{ij} (q_{jf} - q_{jr})\n$$\n其中 $q_{jf}$ 和 $q_{jr}$ 分别是反应 $j$ 的正向和逆向进展速率。\n\n我们将此形式体系应用于给定的两个反应中的物种 $HO_2$。\n\n**反应 1：$R_1: H + O_2 \\rightleftharpoons HO_2$**\n\n首先，我们分析反应 $R_1$ 对 $HO_2$ 的 ROP 的贡献。\n正向反应是 $H + O_2 \\rightarrow HO_2$。物种 $HO_2$ 是生成物。\n逆向反应是 $HO_2 \\rightarrow H + O_2$。物种 $HO_2$ 是反应物。\n\n在 $R_1$ 中，$HO_2$ 的化学计量系数为 $\\nu'_{HO_2, 1} = 0$（反应物）和 $\\nu''_{HO_2, 1} = 1$（生成物）。\n净化学计量系数为 $\\nu_{HO_2, 1} = \\nu''_{HO_2, 1} - \\nu'_{HO_2, 1} = 1 - 0 = 1$。\n\n根据质量作用动力学，$R_1$ 的正向和逆向步骤的进展速率为：\n- 正向进展速率：$q_{1f} = k_{1f} [H] [O_2]$\n- 逆向进展速率：$q_{1r} = k_{1r} [HO_2]$\n\n$R_1$ 的净进展速率为 $q_1 = q_{1f} - q_{1r} = k_{1f} [H] [O_2] - k_{1r} [HO_2]$。\n\n$R_1$ 对 $HO_2$ 的 ROP 的贡献是：\n$$\n(\\mathrm{ROP}_{HO_2})_1 = \\nu_{HO_2, 1} \\times q_1 = (1) \\times (k_{1f} [H] [O_2] - k_{1r} [HO_2]) = k_{1f} [H] [O_2] - k_{1r} [HO_2]\n$$\n\n**反应 2：$R_2: HO_2 + HO_2 \\rightleftharpoons H_2O_2 + O_2$**\n\n接下来，我们分析反应 $R_2$ 的贡献。\n正向反应是 $HO_2 + HO_2 \\rightarrow H_2O_2 + O_2$。物种 $HO_2$ 是反应物。\n逆向反应是 $H_2O_2 + O_2 \\rightarrow HO_2 + HO_2$。物种 $HO_2$ 是生成物。\n\n在 $R_2$ 中，$HO_2$ 的化学计量系数为 $\\nu'_{HO_2, 2} = 2$（反应物）和 $\\nu''_{HO_2, 2} = 0$（生成物）。\n净化学计量系数为 $\\nu_{HO_2, 2} = \\nu''_{HO_2, 2} - \\nu'_{HO_2, 2} = 0 - 2 = -2$。\n\n$R_2$ 的正向和逆向步骤的进展速率为：\n- 正向进展速率：$q_{2f} = k_{2f} [HO_2] [HO_2] = k_{2f} [HO_2]^2$\n- 逆向进展速率：$q_{2r} = k_{2r} [H_2O_2] [O_2]$\n\n$R_2$ 的净进展速率为 $q_2 = q_{2f} - q_{2r} = k_{2f} [HO_2]^2 - k_{2r} [H_2O_2] [O_2]$。\n\n$R_2$ 对 $HO_2$ 的 ROP 的贡献是：\n$$\n(\\mathrm{ROP}_{HO_2})_2 = \\nu_{HO_2, 2} \\times q_2 = (-2) \\times (k_{2f} [HO_2]^2 - k_{2r} [H_2O_2] [O_2]) = -2 k_{2f} [HO_2]^2 + 2 k_{2r} [H_2O_2] [O_2]\n$$\n因子 $2$ 的出现是因为在反应 $R_2$ 的每个正向步骤中消耗了两个 $HO_2$ 分子，而在每个逆向步骤中生成了两个。\n\n**$HO_2$ 的总生成速率**\n\n$HO_2$ 的总 ROP 是所有反应贡献的总和：\n$$\n\\mathrm{ROP}_{HO_2} = (\\mathrm{ROP}_{HO_2})_1 + (\\mathrm{ROP}_{HO_2})_2\n$$\n$$\n\\mathrm{ROP}_{HO_2} = (k_{1f} [H] [O_2] - k_{1r} [HO_2]) + (-2 k_{2f} [HO_2]^2 + 2 k_{2r} [H_2O_2] [O_2])\n$$\n将这些项合并成一个单一表达式可得：\n$$\n\\mathrm{ROP}_{HO_2} = k_{1f} [H] [O_2] - k_{1r} [HO_2] - 2 k_{2f} [HO_2]^2 + 2 k_{2r} [H_2O_2] [O_2]\n$$\n\n按照要求，我们确定对应于 $HO_2$ 生成（正号）和消耗（负号）的项：\n- **$HO_2$ 的生成**：\n  - 来自 $R_1$ 正向反应 ($H + O_2 \\rightarrow HO_2$)：$+ k_{1f} [H] [O_2]$\n  - 来自 $R_2$ 逆向反应 ($H_2O_2 + O_2 \\rightarrow 2HO_2$)：$+ 2 k_{2r} [H_2O_2] [O_2]$\n- **$HO_2$ 的消耗**：\n  - 来自 $R_1$ 逆向反应 ($HO_2 \\rightarrow H + O_2$)：$- k_{1r} [HO_2]$\n  - 来自 $R_2$ 正向反应 ($2HO_2 \\rightarrow H_2O_2 + O_2$)：$- 2 k_{2f} [HO_2]^2$\n\n最终的简化表达式是这四项的线性组合。",
            "answer": "$$\n\\boxed{k_{1f} [H] [O_2] - k_{1r} [HO_2] - 2 k_{2f} [HO_2]^2 + 2 k_{2r} [H_2O_2] [O_2]}\n$$"
        },
        {
            "introduction": "在掌握了计算物种生成速率（ROP）之后，一个主要目标是进行反应路径分析（Reaction Path Analysis, RPA），以识别控制某一物种演化的主导反应。本练习 () 将标准的确定性分析提升到了一个新的层次，引入了动力学参数的不确定性。你不仅需要根据名义影响对反应进行排序，还需要通过蒙特卡洛模拟来评估该排序的稳健性，这对于在面对真实世界数据不确定性时开发可靠的降阶模型至关重要。",
            "id": "4060858",
            "problem": "给定一个均相、恒压反应体系的单一热化学状态，该体系遵循质量作用定律。对于由 $i$ 索引的物种，其生成速率 (Rate of Production, ROP) 通过分解为各反应的贡献来定义，如下所示：\n$$\n\\mathrm{ROP}_i \\;=\\; \\sum_{j=1}^{N_r} \\nu_{i,j}\\,\\omega_j,\n$$\n其中，$N_r$ 是反应总数，$\\nu_{i,j}$ 是物种 $i$ 在反应 $j$ 中的净化学计量系数（生成为正，消耗为负），$\\omega_j$ 是反应 $j$ 的净反应速率。每个反应对物种 $i$ 的 ROP 的贡献为\n$$\n\\mathrm{ROP}_{i,j} \\;=\\; \\nu_{i,j}\\,\\omega_j,\n$$\n反应路径分析通过对 $|\\mathrm{ROP}_{i,j}|$ 的大小进行排序，来排列对物种 $i$ 浓度变化贡献最强的反应。\n\n假设动力学速率参数存在一个局部参数不确定性模型，使得对于由 $j$ 索引的每个反应，其净反应速率 $\\omega_j$ 受到如下的乘性扰动：\n$$\n\\omega_j \\;\\mapsto\\; u_j\\,\\omega_j,\n$$\n其中 $u_j$ 被建模为对数正态分布，且在各反应之间相互独立：\n$$\n\\ln(u_j) \\sim \\mathcal{N}\\!\\left(-\\tfrac{1}{2}\\sigma_j^2,\\;\\sigma_j^2\\right).\n$$\n该选择确保了 $\\mathbb{E}[u_j] = 1$，同时允许通过对数空间中的标准差 $\\sigma_j$ 来控制其离散程度。在此不确定性下，每个反应的 ROP 贡献扰动为\n$$\n\\mathrm{ROP}_{i,j} \\;\\mapsto\\; u_j\\,\\mathrm{ROP}_{i,j}.\n$$\n\n您的任务是：\n- 实现一个算法，通过将绝对值 $|\\mathrm{ROP}_{i,j}|$ 按降序排序并选择前 $k$ 个反应，来识别对 $\\mathrm{ROP}_i$ 贡献最大的 $k$ 个主导反应。当出现平局时，优先选择基于零的索引较小的反应。\n- 通过蒙特卡洛采样，计算在受扰动的贡献 $|u_j\\,\\mathrm{ROP}_{i,j}|$ 下，每个反应出现在前 $k$ 个中的概率，从而评估这种主导地位在参数不确定性下的稳健性。将稳健主导集定义为具有最大概率的 $k$ 个反应，出现平局时优先选择基于零的索引较小的反应。\n\n请使用以下测试套件。每个案例定义了 $N_r$、化学计量系数向量 $\\nu_{i,j}$、基础反应速率向量 $\\omega_j$、对数空间标准差向量 $\\sigma_j$ 以及整数 $k$。在此问题中，所有数组都是无量纲的，索引是基于零的整数。\n\n- 案例 A (一般情况，数值大小各不相同):\n  - $N_r = 5$\n  - $\\nu_{i,j} = (\\,1.0,\\,-2.0,\\,1.0,\\,0.0,\\,1.0\\,)$\n  - $\\omega_j = (\\,2.0,\\,0.5,\\,1.5,\\,0.0,\\,-0.2\\,)$\n  - $\\sigma_j = (\\,0.1,\\,0.4,\\,0.2,\\,0.3,\\,0.5\\,)$\n  - $k = 2$\n- 案例 B (边界情况，在 $|\\mathrm{ROP}_{i,j}|$ 上存在平局):\n  - $N_r = 4$\n  - $\\nu_{i,j} = (\\,1.0,\\,1.0,\\,-1.0,\\,1.0\\,)$\n  - $\\omega_j = (\\,1.0,\\,-1.0,\\,1.0,\\,-1.0\\,)$\n  - $\\sigma_j = (\\,0.0,\\,0.0,\\,0.0,\\,0.0\\,)$\n  - $k = 3$\n- 案例 C (边缘情况，一个高度不确定的主导反应):\n  - $N_r = 6$\n  - $\\nu_{i,j} = (\\,1.0,\\,1.0,\\,1.0,\\,-1.0,\\,2.0,\\,-3.0\\,)$\n  - $\\omega_j = (\\,0.8,\\,0.7,\\,0.6,\\,0.3,\\,0.2,\\,-0.5\\,)$\n  - $\\sigma_j = (\\,0.15,\\,0.10,\\,0.10,\\,0.20,\\,0.10,\\,0.60\\,)$\n  - $k = 3$\n\n蒙特卡洛参数：\n- 每个案例独立抽取 $N = 10000$ 个样本。\n- 为保证可复现性，随机种子固定为 $42$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 对于每个测试案例，输出一个包含两项的列表：\n  - 第一项是基于在基础状态下对 $|\\mathrm{ROP}_{i,j}|$ 排序得出的 $k$ 个主导反应索引的列表。\n  - 第二项是基于根据不确定性模型通过蒙特卡洛方法计算出的前 $k$ 名出现概率排序得出的 $k$ 个稳健主导反应索引的列表。\n- 索引必须是基于零的整数。\n- 完整的输出应如下所示：\n$$\n[\\,[\\text{base\\_top\\_k},\\;\\text{robust\\_top\\_k}],\\,[\\dots],\\,[\\dots]\\,]\n$$\n其中每个占位符都是一个整数列表。\n\n您的程序必须实现上述要求，并严格按照指定格式生成单行输出。",
            "solution": "该问题是有效的。它以化学动力学和不确定性量化的原理为科学基础，定义清晰且有明确的平局处理规则，问题本身是适定的，并且是客观且计算上可行的。\n\n解决方案要求为每个测试案例实现两种不同的分析：确定性反应路径分析和通过蒙特卡洛模拟进行的概率性稳健性分析。其目标是比较两种方法所识别出的主导化学反应集合。\n\n### 第 1 部分：确定性主导反应分析\n\n此分析在单一的、标称的热化学状态下，根据各反应对物种 $i$ 生成速率 (ROP) 的贡献，识别出最具影响力的反应。\n\n反应 $j$ 对物种 $i$ 的 ROP 的贡献由下式给出\n$$\n\\mathrm{ROP}_{i,j} \\;=\\; \\nu_{i,j}\\,\\omega_j\n$$\n其中 $\\nu_{i,j}$ 是化学计量系数，$\\omega_j$ 是净反应速率。该贡献的绝对值 $|\\mathrm{ROP}_{i,j}|$ 量化了反应 $j$ 对物种 $i$ 浓度的影响，而不管它是生成途径还是消耗途径。\n\n找到 $k$ 个主导反应集的算法如下：\n1.  对于每个反应 $j \\in \\{0, 1, \\dots, N_r-1\\}$（其中 $N_r$ 是反应总数），使用提供的向量 $\\boldsymbol{\\nu}_i$ 和 $\\boldsymbol{\\omega}$ 计算基础 ROP 贡献 $\\mathrm{ROP}_{i,j} = \\nu_{i,j}\\omega_j$。\n2.  计算每个贡献的绝对值大小 $|\\mathrm{ROP}_{i,j}|$。\n3.  为便于排序，创建一个元组列表，其中每个元组包含其绝对值大小和对应的反应索引：$(|\\mathrm{ROP}_{i,j}|, j)$。\n4.  对该元组列表进行排序。主要排序标准是绝对值大小，按降序排列。次要排序标准（用于解决绝对值大小相等的情况）是反应索引 $j$，按升序排列。这遵循了指定的平局处理规则。\n5.  确定性主导集由排序后列表中前 $k$ 个元组的索引构成。\n\n### 第 2 部分：概率性稳健性分析\n\n此分析评估了在动力学参数不确定性下反应主导层级结构的稳定性。不确定性通过用一个独立的、服从对数正态分布的乘性因子 $u_j$ 扰动每个反应速率 $\\omega_j$ 来建模。$\\ln(u_j)$ 的分布为正态分布 $\\mathcal{N}(-\\frac{1}{2}\\sigma_j^2, \\sigma_j^2)$，其中 $\\sigma_j$ 是为反应 $j$ 指定的对数空间标准差。这种表示方法确保了乘数的期望值为 $\\mathbb{E}[u_j]=1$。\n\n受扰动的 ROP 贡献为 $\\mathrm{ROP}_{i,j}^{\\text{pert}} = u_j \\mathrm{ROP}_{i,j}$。该分析使用蒙特卡洛模拟进行。\n\n算法如下：\n1.  初始化一个大小为 $N_r$ 的频率计数器数组 `counts`，所有元素为零。该数组将存储在所有蒙特卡洛样本中，每个反应出现在前 $k$ 个集合中的次数。\n2.  将随机数生成器的种子固定为 42，以确保可复现性。\n3.  执行一个总共 $N=10000$ 个样本的循环。在每次迭代中：\n    a.  对于每个反应 $j=0, \\dots, N_r-1$，生成一个随机乘数 $u_j$。这通过首先从标准正态分布 $\\mathcal{N}(0, 1)$ 中抽取一个样本 $z_j$，然后计算 $u_j = \\exp(-\\frac{1}{2}\\sigma_j^2 + \\sigma_j z_j)$ 来实现。\n    b.  计算此样本中受扰动的 ROP 贡献的绝对值大小：$|\\mathrm{ROP}_{i,j}^{\\text{pert}}| = |u_j \\mathrm{ROP}_{i,j}| = u_j |\\mathrm{ROP}_{i,j}|$，因为 $u_j$ 是严格为正的。\n    c.  通过对偶对 $(|\\mathrm{ROP}_{i,j}^{\\text{pert}}|, j)$ 使用与确定性情况相同的降序绝对值、升序索引的规则进行排序，来识别此扰动样本的前 $k$ 个主导反应。\n    d.  对于上一步中识别出的 $k$ 个反应索引中的每一个，在 `counts` 数组中增加其对应的计数器。\n4.  循环完成后，通过将其总计数除以样本数 $N$ 来计算每个反应 $j$ 出现在前 $k$ 个集合中的概率 $P_j$：$P_j = \\text{counts}_j / N$。\n5.  为确定稳健主导集，根据这些概率对反应进行排序。创建一个元组列表 $(P_j, j)$，并以降序的概率 $P_j$ 为主键、升序的索引 $j$ 为次键进行排序。\n6.  稳健主导集由这个排序后的概率列表中的前 $k$ 个元组的索引构成。\n\n通过比较确定性主导集和稳健主导集，可以评估动力学不确定性对从标准反应路径分析得出的结论的影响。一个在确定性分析中占主导地位的高不确定性反应，可能其主导概率很低，从而在稳健主导集中可能被一个主导性较弱但更确定的反应所取代。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the reaction path robustness problem for the given test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (general, distinct magnitudes)\n        {\n            \"Nr\": 5,\n            \"nu_i\": (1.0, -2.0, 1.0, 0.0, 1.0),\n            \"omega\": (2.0, 0.5, 1.5, 0.0, -0.2),\n            \"sigma\": (0.1, 0.4, 0.2, 0.3, 0.5),\n            \"k\": 2,\n        },\n        # Case B (boundary, ties in |ROP_ij|)\n        {\n            \"Nr\": 4,\n            \"nu_i\": (1.0, 1.0, -1.0, 1.0),\n            \"omega\": (1.0, -1.0, 1.0, -1.0),\n            \"sigma\": (0.0, 0.0, 0.0, 0.0),\n            \"k\": 3,\n        },\n        # Case C (edge, one highly uncertain dominant reaction)\n        {\n            \"Nr\": 6,\n            \"nu_i\": (1.0, 1.0, 1.0, -1.0, 2.0, -3.0),\n            \"omega\": (0.8, 0.7, 0.6, 0.3, 0.2, -0.5),\n            \"sigma\": (0.15, 0.10, 0.10, 0.20, 0.10, 0.60),\n            \"k\": 3,\n        },\n    ]\n\n    mc_samples = 10000\n    seed = 42\n    results = []\n\n    for case in test_cases:\n        Nr = case[\"Nr\"]\n        nu_i = np.array(case[\"nu_i\"])\n        omega = np.array(case[\"omega\"])\n        sigma = np.array(case[\"sigma\"])\n        k = case[\"k\"]\n        \n        indices = np.arange(Nr)\n\n        # --- Task 1: Deterministic Dominant Reaction Analysis ---\n        rop_ij = nu_i * omega\n        abs_rop_ij = np.abs(rop_ij)\n\n        # Sort by magnitude (desc) and then index (asc) for tie-breaking\n        base_sorted_pairs = sorted(zip(abs_rop_ij, indices), key=lambda p: (-p[0], p[1]))\n        base_top_k = [pair[1] for pair in base_sorted_pairs[:k]]\n\n        # --- Task 2: Probabilistic Robustness Analysis ---\n        np.random.seed(seed)\n        top_k_counts = np.zeros(Nr, dtype=int)\n\n        for _ in range(mc_samples):\n            # Generate lognormal multipliers u_j\n            z = np.random.normal(size=Nr)\n            u = np.exp(-0.5 * sigma**2 + sigma * z)\n\n            # Calculate perturbed ROP magnitudes\n            perturbed_abs_rop = u * abs_rop_ij\n            \n            # Identify top k for this sample\n            sample_sorted_pairs = sorted(zip(perturbed_abs_rop, indices), key=lambda p: (-p[0], p[1]))\n            sample_top_k_indices = [pair[1] for pair in sample_sorted_pairs[:k]]\n            \n            # Increment counts for the top k reactions\n            top_k_counts[sample_top_k_indices] += 1\n            \n        # Calculate probabilities\n        probabilities = top_k_counts / mc_samples\n\n        # Determine robust dominant set by sorting probabilities\n        prob_sorted_pairs = sorted(zip(probabilities, indices), key=lambda p: (-p[0], p[1]))\n        robust_top_k = [pair[1] for pair in prob_sorted_pairs[:k]]\n\n        results.append([base_top_k, robust_top_k])\n\n    # Final print statement in the exact required format.\n    # The string representation of a list in Python includes spaces, matching the format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "灵敏度分析为我们提供了深刻的洞察力，以理解模型输出（如点火延迟）如何响应输入参数（如反应速率）的变化。这项高级实践 () 深入探讨了伴随方法的实现与验证，这是一种用于计算梯度灵敏度的高效技术。通过数值求解正向和伴随方程，并将计算出的梯度与有限差分估计进行严格比对，你将获得使用这一强大分析工具的实践经验，并掌握数值代码验证的关键技能。",
            "id": "4060821",
            "problem": "考虑一个均相、恒压的零维 (0-D) 反应器，其中含有一种反应物种，并由阿伦尼乌斯动力学描述一个单一全局反应。令状态向量为 $x(t) = \\begin{bmatrix} Y(t) \\\\ T(t) \\end{bmatrix}$，其中 $Y$ 是反应物的质量分数，$T$ 是温度（单位：开尔文）。控制常微分方程 (ODE) 组为\n$$\n\\frac{dY}{dt} = -k(T; A, E)\\,Y, \\quad \\frac{dT}{dt} = q\\,k(T; A, E)\\,Y,\n$$\n其中 $q$ 是与热释放和热容成正比的温升参数，$A$ 是指前因子（单位：$\\mathrm{s}^{-1}$），$E$ 是活化能（单位：$\\mathrm{J/mol}$），$k$ 是由阿伦尼乌斯定律给出的依赖于温度的速率\n$$\nk(T; A, E) = A \\exp\\!\\left(-\\frac{E}{R\\,T}\\right),\n$$\n其中 $R$ 是普适气体常数（单位：$\\mathrm{J/(mol\\cdot K)}$）。\n\n令目标泛函为最终温度\n$$\nJ(A,E) = \\phi\\!\\big(x(t_f)\\big) = T(t_f),\n$$\n且没有时间过程成本。初始条件为 $x(0)=\\begin{bmatrix} Y_0 \\\\ T_0 \\end{bmatrix}$，积分区间为 $t\\in[0,t_f]$。所有物理量均采用国际单位制 (SI)：$A$ 的单位为 $\\mathrm{s}^{-1}$，$E$ 的单位为 $\\mathrm{J/mol}$，$T$ 的单位为 $\\mathrm{K}$，时间的单位为 $\\mathrm{s}$，$q$ 的单位为 $\\mathrm{K}$ 每单位质量分数。\n\n您的任务是：\n\n1. 从上述基本定义和链式法则出发，推导出一个基于伴随的梯度 $\\nabla J = \\left[\\frac{\\partial J}{\\partial A}, \\frac{\\partial J}{\\partial E}\\right]$ 表达式，该表达式可通过从 $t=t_f$ 到 $t=0$ 的时间逆向积分一个伴随 ODE 来求值。使用满足\n$$\n-\\frac{d\\lambda}{dt} = \\left(\\frac{\\partial f}{\\partial x}\\right)^\\top \\lambda,\\quad \\lambda(t_f) = \\frac{\\partial \\phi}{\\partial x}\\Big|_{t_f},\n$$\n的伴随 $\\lambda(t) = \\begin{bmatrix}\\lambda_Y(t) \\\\ \\lambda_T(t)\\end{bmatrix}$ 的定义，其中 $f(x;A,E) = \\begin{bmatrix} -k(T;A,E)Y \\\\ q\\,k(T;A,E)Y \\end{bmatrix}$ 且 $\\phi(x(t_f))=T(t_f)$，并将 $\\frac{\\partial J}{\\partial A}$ 和 $\\frac{\\partial J}{\\partial E}$ 表示为包含 $\\lambda(t)$、$x(t)$ 以及 $f$ 对参数的偏导数的时间积分。\n\n2. 实现一个计算程序，该程序：\n   - 使用带密集输出的刚性求解器在 $[0,t_f]$ 上求解 $x(t)$ 的正向 ODE。\n   - 使用存储的正向轨迹，通过时间逆向求解伴随 ODE，以利用任务 1 中的表达式计算梯度分量。\n   - 通过一次扰动一个参数来计算梯度分量的中心有限差分 (FD) 估计：对于参数 $p\\in\\{A,E\\}$，定义 $J(p+h)$ 和 $J(p-h)$ 并使用 $\\frac{J(p+h)-J(p-h)}{2h}$，其中 $h$ 的选择与 $p$ 的量级相关。\n   - 对 $A$ 和 $E$ 两个参数，将伴随梯度与 FD 估计值进行验证。\n\n3. 提供一个同时考虑 FD 截断误差和数值求解器误差的容差准则。为此：\n   - 在固定的求解器容差下，使用两个 FD 步长 $h_1$ 和 $h_2=\\frac{1}{2}h_1$ 来形成每个梯度分量的经验截断误差估计 $\\Delta_{\\mathrm{FD}} \\approx \\left|g_{\\mathrm{FD}}(h_2) - g_{\\mathrm{FD}}(h_1)\\right|$。\n   - 通过在两个求解器容差 $\\mathrm{rtol}$ 和 $\\mathrm{rtol}/10$ 下计算 $g_{\\mathrm{FD}}(h_2)$ 来估计求解器引起的噪声，并定义 $\\Delta_{\\mathrm{sol}} \\approx \\left|g_{\\mathrm{FD}}^{\\mathrm{rtol}}(h_2)-g_{\\mathrm{FD}}^{\\mathrm{rtol}/10}(h_2)\\right|$。\n   - 使用与浮点舍入误差相关的下限：$\\Delta_{\\mathrm{fp}} = \\epsilon \\max(1,|g_{\\mathrm{adj}}|)$，其中 $\\epsilon$ 是双精度浮点数的机器精度。\n   - 如果伴随梯度分量 $g_{\\mathrm{adj}}$ 与 $g_{\\mathrm{FD}}(h_2)$ 的偏差满足\n$$\n\\left|g_{\\mathrm{adj}} - g_{\\mathrm{FD}}(h_2)\\right| \\le C\\left(\\Delta_{\\mathrm{FD}} + \\Delta_{\\mathrm{sol}} + \\Delta_{\\mathrm{fp}}\\right),\n$$\n则接受该分量，其中 $C$ 是一个固定的常数，您需要指明其值并给出理由。\n\n4. 使用以下参数集组合一个验证测试套件，这些参数集旨在探究不同的动力学区域：\n   - 情况 1 (中等反应): $A=10^7\\,\\mathrm{s}^{-1}$, $E=1.2\\times 10^5\\,\\mathrm{J/mol}$。\n   - 情况 2 (快速反应，可能存在刚性): $A=10^{10}\\,\\mathrm{s}^{-1}$, $E=1.2\\times 10^5\\,\\mathrm{J/mol}$。\n   - 情况 3 (较低活化能垒): $A=10^7\\,\\mathrm{s}^{-1}$, $E=8.0\\times 10^4\\,\\mathrm{J/mol}$。\n   - 情况 4 (高活化能垒，几乎冻结): $A=10^7\\,\\mathrm{s}^{-1}$, $E=2.0\\times 10^5\\,\\mathrm{J/mol}$。\n\n使用常数 $R=8.314\\,\\mathrm{J/(mol\\cdot K)}$，$q=1500\\,\\mathrm{K}$，$Y_0=1.0$，$T_0=1000\\,\\mathrm{K}$，$t_0=0\\,\\mathrm{s}$ 和 $t_f=0.004\\,\\mathrm{s}$。采用后向差分格式 (BDF) 方法实现求解器，并设置基本相对容差 $\\mathrm{rtol}=10^{-8}$ 和绝对容差 $\\mathrm{atol}=10^{-12}$。\n\n您的程序应为每种情况返回一个布尔值，指示两个梯度分量是否都通过了容差准则。最终输出必须是单行文本，包含四个布尔值（每种情况一个），以逗号分隔并用方括号括起来（例如，\"[True,True,False,True]\"）。不涉及角度。不使用百分比；所有数值比较都应使用绝对值或小数。\n\n用代码实现整个解决方案，生成所描述的精确单行输出。无需外部输入，所有数值和单位均如上所述。",
            "solution": "用户提供了一个问题，要求对一个简单的化学反应器模型进行伴随灵敏度分析的推导和实现，然后与有限差分进行严格的数值验证。\n\n### 步骤 1：提取已知条件\n\n-   **状态向量**：$x(t) = \\begin{bmatrix} Y(t) \\\\ T(t) \\end{bmatrix}$，其中 $Y$ 是反应物质量分数，$T$ 是温度。\n-   **控制 ODE**：\n    $$\n    \\frac{dY}{dt} = -k(T; A, E)\\,Y = f_Y(x; A, E)\n    $$\n    $$\n    \\frac{dT}{dt} = q\\,k(T; A, E)\\,Y = f_T(x; A, E)\n    $$\n-   **速率定律**：$k(T; A, E) = A \\exp\\!\\left(-\\frac{E}{R\\,T}\\right)$。\n-   **参数**：指前因子 $A$ 和活化能 $E$。\n-   **目标泛函**：$J(A,E) = \\phi(x(t_f)) = T(t_f)$。\n-   **初始条件**：$x(0) = \\begin{bmatrix} Y_0 \\\\ T_0 \\end{bmatrix}$。\n-   **时间区间**：$t \\in [0, t_f]$。\n-   **伴随方程**：\n    $$\n    -\\frac{d\\lambda}{dt} = \\left(\\frac{\\partial f}{\\partial x}\\right)^\\top \\lambda, \\quad \\lambda(t_f) = \\frac{\\partial \\phi}{\\partial x}\\Big|_{t_f}\n    $$\n    其中 $f = \\begin{bmatrix} f_Y \\\\ f_T \\end{bmatrix}$ 且 $\\lambda(t) = \\begin{bmatrix}\\lambda_Y(t) \\\\ \\lambda_T(t)\\end{bmatrix}$。\n-   **梯度表达式形式**：将 $\\frac{\\partial J}{\\partial A}$ 和 $\\frac{\\partial J}{\\partial E}$ 表示为包含 $\\lambda(t)$、$x(t)$ 和 $f$ 的偏导数的时间积分。\n-   **常数**：$R=8.314\\,\\mathrm{J/(mol\\cdot K)}$, $q=1500\\,\\mathrm{K}$, $Y_0=1.0$, $T_0=1000\\,\\mathrm{K}$, $t_0=0\\,\\mathrm{s}$, $t_f=0.004\\,\\mathrm{s}$。\n-   **数值方法**：BDF 求解器，`rtol` $= 10^{-8}$ 且 `atol` $= 10^{-12}$。\n-   **验证准则**：$\\left|g_{\\mathrm{adj}} - g_{\\mathrm{FD}}(h_2)\\right| \\le C\\left(\\Delta_{\\mathrm{FD}} + \\Delta_{\\mathrm{sol}} + \\Delta_{\\mathrm{fp}}\\right)$，并指定了计算 $\\Delta_{\\mathrm{FD}}$、$\\Delta_{\\mathrm{sol}}$ 和 $\\Delta_{\\mathrm{fp}}$ 的程序。\n-   **测试用例**：\n    -   情况 1: $A=10^7, E=1.2\\times 10^5$\n    -   情况 2: $A=10^{10}, E=1.2\\times 10^5$\n    -   情况 3: $A=10^7, E=8.0\\times 10^4$\n    -   情况 4: $A=10^7, E=2.0\\times 10^5$\n\n### 步骤 2：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题描述了一个零维均相反应器，其动力学由阿伦尼乌斯定律决定。这是化学动力学和燃烧科学中的一个经典模型。在指定的假设下，控制方程是质量和能量守恒的基本表示。该模型在科学上是合理的，没有伪科学内容。\n-   **良态性**：ODE 系统的右端项是连续且局部利普希茨的，这保证了给定初始条件下正向问题的解的存在性和唯一性。伴随系统是一个线性 ODE，给定其终端条件也能确保唯一解。任务是计算梯度，这是一个明确定义的数学运算。\n-   **目标**：问题通过精确的数学方程、常数和数值要求进行了规定。它没有歧义和主观性语言。\n-   **完整性与一致性**：所有必需的参数 ($A, E$)、常数 ($R, q$)、初始条件 ($Y_0, T_0$) 和时间区间 ($t_f$) 都已提供。没有相互矛盾的约束。\n-   **现实性**：物理常数和参数范围对于气相化学反应是合理的，并且测试用例被恰当地设计用来探究不同的反应区域（例如，慢反应、快反应、温度敏感反应）。\n-   **非平凡性**：推导伴随方程，将其与正向求解耦合进行数值求解，以及多部分验证程序，在计算科学与工程中是一个标准但概念上和算法上都非平凡的任务。\n\n### 步骤 3：结论与行动\n\n该问题是有效的。它是一个在计算化学动力学领域内良态、有科学依据且全面的问题。我将继续进行解答。\n\n### 任务 1：伴随梯度表达式的推导\n\n伴随灵敏度分析的核心是计算泛函 $J$ 对系统参数 $\\alpha$ 的梯度，而无需显式计算正向灵敏度 $\\frac{dx}{d\\alpha}$。梯度由积分表达式给出：\n$$\n\\frac{dJ}{d\\alpha_i} = \\int_{t_0}^{t_f} \\lambda(t)^\\top \\frac{\\partial f(x(t), \\alpha)}{\\partial \\alpha_i} dt\n$$\n其中伴随向量 $\\lambda(t)$ 是其自身 ODE 的解。我们必须首先为我们的特定问题定义此框架的各个组成部分。\n\n1.  **伴随终端条件**：\n    目标泛函为 $J = \\phi(x(t_f)) = T(t_f)$。伴随向量 $\\lambda(t_f)$ 的终端条件是 $\\phi$ 在最终时间 $t_f$ 对状态 $x$ 的梯度。\n    $$\n    \\lambda(t_f) = \\frac{\\partial \\phi}{\\partial x}\\bigg|_{t_f} = \\left[ \\frac{\\partial T(t_f)}{\\partial Y(t_f)}, \\frac{\\partial T(t_f)}{\\partial T(t_f)} \\right]^\\top = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\n    $$\n    因此，$\\lambda_Y(t_f)=0$ 且 $\\lambda_T(t_f)=1$。\n\n2.  **ODE 系统的雅可比矩阵**：\n    伴随 ODE 依赖于正向系统右端项 $f(x) = \\begin{bmatrix} -kY \\\\ qkY \\end{bmatrix}$ 的雅可比矩阵的转置。雅可比矩阵为 $\\frac{\\partial f}{\\partial x} = \\begin{bmatrix} \\partial f_Y / \\partial Y  \\partial f_Y / \\partial T \\\\ \\partial f_T / \\partial Y  \\partial f_T / \\partial T \\end{bmatrix}$。其分量为：\n    -   $\\frac{\\partial f_Y}{\\partial Y} = -k$\n    -   $\\frac{\\partial f_Y}{\\partial T} = -Y \\frac{\\partial k}{\\partial T} = -Y \\left( A e^{-E/(RT)} \\cdot \\frac{E}{RT^2} \\right) = -Yk\\frac{E}{RT^2}$\n    -   $\\frac{\\partial f_T}{\\partial Y} = qk$\n    -   $\\frac{\\partial f_T}{\\partial T} = qY \\frac{\\partial k}{\\partial T} = qYk\\frac{E}{RT^2}$\n    雅可比矩阵为：\n    $$\n    \\frac{\\partial f}{\\partial x} = \\begin{bmatrix} -k  -Yk\\frac{E}{RT^2} \\\\ qk  qYk\\frac{E}{RT^2} \\end{bmatrix}\n    $$\n\n3.  **伴随 ODE 系统**：\n    伴随系统为 $-\\frac{d\\lambda}{dt} = \\left(\\frac{\\partial f}{\\partial x}\\right)^\\top \\lambda$：\n    $$\n    -\\frac{d}{dt}\\begin{bmatrix} \\lambda_Y \\\\ \\lambda_T \\end{bmatrix} = \\begin{bmatrix} -k  qk \\\\ -Yk\\frac{E}{RT^2}  qYk\\frac{E}{RT^2} \\end{bmatrix} \\begin{bmatrix} \\lambda_Y \\\\ \\lambda_T \\end{bmatrix}\n    $$\n    这展开为两个关于 $\\lambda_Y(t)$ 和 $\\lambda_T(t)$ 的耦合标量 ODE，必须从时间 $t=t_f$ 逆向积分到 $t=t_0$：\n    $$\n    -\\frac{d\\lambda_Y}{dt} = -k\\lambda_Y + qk\\lambda_T = k(q\\lambda_T - \\lambda_Y)\n    $$\n    $$\n    -\\frac{d\\lambda_T}{dt} = -Yk\\frac{E}{RT^2} \\lambda_Y + qYk\\frac{E}{RT^2} \\lambda_T = Yk\\frac{E}{RT^2}(q\\lambda_T - \\lambda_Y)\n    $$\n\n4.  **右端项的参数导数**：\n    为了构建梯度被积函数，我们需要 $f$ 对参数 $A$ 和 $E$ 的偏导数。\n    首先，速率常数 $k = A e^{-E/(RT)}$ 的偏导数：\n    $$\n    \\frac{\\partial k}{\\partial A} = e^{-E/(RT)} = \\frac{k}{A}\n    $$\n    $$\n    \\frac{\\partial k}{\\partial E} = A e^{-E/(RT)} \\left(-\\frac{1}{RT}\\right) = -\\frac{k}{RT}\n    $$\n    现在，对于向量函数 $f$：\n    $$\n    \\frac{\\partial f}{\\partial A} = \\begin{bmatrix} -\\frac{\\partial k}{\\partial A}Y \\\\ q\\frac{\\partial k}{\\partial A}Y \\end{bmatrix} = \\begin{bmatrix} -\\frac{k}{A}Y \\\\ q\\frac{k}{A}Y \\end{bmatrix}\n    $$\n    $$\n    \\frac{\\partial f}{\\partial E} = \\begin{bmatrix} -\\frac{\\partial k}{\\partial E}Y \\\\ q\\frac{\\partial k}{\\partial E}Y \\end{bmatrix} = \\begin{bmatrix} \\frac{k}{RT}Y \\\\ -q\\frac{k}{RT}Y \\end{bmatrix}\n    $$\n\n5.  **梯度积分**：\n    最后，我们将这些导数代入梯度分量 $\\frac{\\partial J}{\\partial A}$ 和 $\\frac{\\partial J}{\\partial E}$ 的积分公式中。\n    $$\n    \\frac{\\partial J}{\\partial A} = \\int_{0}^{t_f} \\lambda(t)^\\top \\frac{\\partial f}{\\partial A} dt = \\int_{0}^{t_f} \\begin{bmatrix} \\lambda_Y  \\lambda_T \\end{bmatrix} \\begin{bmatrix} -\\frac{kY}{A} \\\\ q\\frac{kY}{A} \\end{bmatrix} dt = \\int_{0}^{t_f} \\frac{k(T)Y(t)}{A}(q\\lambda_T(t) - \\lambda_Y(t)) dt\n    $$\n    $$\n    \\frac{\\partial J}{\\partial E} = \\int_{0}^{t_f} \\lambda(t)^\\top \\frac{\\partial f}{\\partial E} dt = \\int_{0}^{t_f} \\begin{bmatrix} \\lambda_Y  \\lambda_T \\end{bmatrix} \\begin{bmatrix} \\frac{kY}{RT} \\\\ -q\\frac{kY}{RT} \\end{bmatrix} dt = \\int_{0}^{t_f} -\\frac{k(T)Y(t)}{RT(t)}(q\\lambda_T(t) - \\lambda_Y(t)) dt\n    $$\n    这些就是梯度分量的最终表达式。\n\n### 任务 2、3 和 4：计算流程、验证与实现\n\n计算策略包括三个主要步骤：\n1.  **正向过程**：使用刚性 ODE 求解器 (BDF) 从 $t=0$ 到 $t=t_f$ 求解主 ODE 系统 $x(t) = [Y(t), T(t)]^\\top$。必须存储或提供求解轨迹（例如，通过密集输出），因为伴随 ODE 的系数依赖于 $x(t)$。\n2.  **逆向过程**：逆向求解增广伴随系统。为了同时处理逆向积分和梯度积分，我们定义一个时间变换 $\\tau = t_f - t$，这样在 $\\tau$ 上从 $0$ 到 $t_f$ 的正向积分等价于在 $t$ 上的逆向积分。导数变换为 $\\frac{d}{d\\tau} = \\frac{dt}{d\\tau}\\frac{d}{dt} = -\\frac{d}{dt}$。对于 $\\tau \\in [0, t_f]$，需要求解的系统是：\n    $$\n    \\frac{d\\lambda_Y}{d\\tau} = k(q\\lambda_T - \\lambda_Y)\n    $$\n    $$\n    \\frac{d\\lambda_T}{d\\tau} = Yk\\frac{E}{RT^2}(q\\lambda_T - \\lambda_Y)\n    $$\n    $$\n    \\frac{d}{d\\tau} \\left(\\frac{\\partial J}{\\partial A}\\right) = \\frac{kY}{A}(q\\lambda_T - \\lambda_Y)\n    $$\n    $$\n    \\frac{d}{d\\tau} \\left(\\frac{\\partial J}{\\partial E}\\right) = -\\frac{kY}{RT}(q\\lambda_T - \\lambda_Y)\n    $$\n    其中 $Y$、$T$ 和 $k$ 在 $t = t_f - \\tau$ 处求值。在 $\\tau=0$（对应于 $t=t_f$）时的初始条件是 $\\lambda_Y(0)=0$、$\\lambda_T(0)=1$，并且梯度分量的初始值为 $0$。在 $\\tau=t_f$ 时积分得到的梯度分量的最终值即为灵敏度 $\\nabla J$。\n\n3.  **验证**：计算出的伴随梯度 $g_{\\mathrm{adj}}$ 的准确性通过与中心有限差分 (FD) 估计值 $g_{\\mathrm{FD}}$ 进行比较来验证。使用一个复杂的容差准则来考虑各种数值误差来源：\n    -   主 FD 估计 $g_{\\mathrm{FD}}(h_2)$ 使用小步长 $h_2$ 计算。\n    -   **FD 截断误差 ($\\Delta_{\\mathrm{FD}}$)**：使用两个不同的 FD 步长 $h_1 = 2h_2$ 进行估计。$\\Delta_{\\mathrm{FD}} = |g_{\\mathrm{FD}}(h_2) - g_{\\mathrm{FD}}(h_1)|$。这捕捉了有限差分公式固有的误差。\n    -   **求解器引起的噪声 ($\\Delta_{\\mathrm{sol}}$)**：通过使用两种不同的求解器容差（例如，`rtol` 和 `rtol/10`）计算相同的 FD 梯度 $g_{\\mathrm{FD}}(h_2)$ 来估计。$\\Delta_{\\mathrm{sol}} = |g_{\\mathrm{FD}}^{\\mathrm{rtol}}(h_2) - g_{\\mathrm{FD}}^{\\mathrm{rtol}/10}(h_2)|$。这捕捉了结果对 ODE 求解器精度的敏感性。\n    -   **浮点下限 ($\\Delta_{\\mathrm{fp}}$)**：由机器精度引起的误差下界，$\\Delta_{\\mathrm{fp}} = \\epsilon \\max(1, |g_{\\mathrm{adj}}|)$，其中 $\\epsilon$ 是机器精度。\n    -   **接受准则**：如果 $\\left|g_{\\mathrm{adj}} - g_{\\mathrm{FD}}(h_2)\\right| \\le C(\\Delta_{\\mathrm{FD}} + \\Delta_{\\mathrm{sol}} + \\Delta_{\\mathrm{fp}})$，则接受伴随梯度。常数 $C$ 是一个安全系数。选择 $C=10$，这是数值验证中的一种保守做法，以考虑误差估计量的近似性和潜在的误差抵消。\n\n整个过程将应用于指定的四个测试用例中的每一个。为每个用例生成一个布尔结果，指示两个梯度分量（$\\frac{\\partial J}{\\partial A}$ 和 $\\frac{\\partial J}{\\partial E}$）是否都通过了验证测试。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to run the adjoint verification for all test cases.\n    \"\"\"\n    \n    # Define constants\n    R = 8.314  # J/(mol.K)\n    Q = 1500.0  # K\n    Y0 = 1.0\n    T0 = 1000.0\n    T_INIT = np.array([Y0, T0])\n    T_SPAN = [0.0, 0.004]\n\n    # Solver settings\n    RTOL_BASE = 1e-8\n    ATOL_BASE = 1e-12\n    RTOL_TIGHT = 1e-9\n    ATOL_TIGHT = 1e-13\n\n    # FD and Verification settings\n    FD_REL_STEP_1 = 1e-6\n    FD_REL_STEP_2 = 0.5 * FD_REL_STEP_1\n    C_VERIFY = 10.0  # Verification tolerance constant\n    MACHINE_EPS = np.finfo(float).eps\n\n    # Test cases: (A, E)\n    test_cases = [\n        (1e7, 1.2e5),    # Case 1: Moderate reaction\n        (1e10, 1.2e5),   # Case 2: Fast reaction, potential stiffness\n        (1e7, 8.0e4),    # Case 3: Lower activation barrier\n        (1e7, 2.0e5),    # Case 4: High activation barrier, nearly frozen\n    ]\n\n    results = []\n    \n    for A, E in test_cases:\n        params = {'A': A, 'E': E, 'R': R, 'q': Q}\n        \n        # --- Adjoint Gradient Calculation ---\n        g_adj_A, g_adj_E = compute_adjoint_gradient(T_INIT, T_SPAN, params, RTOL_BASE, ATOL_BASE)\n        \n        # --- Finite Difference Gradient and Error Estimation ---\n        \n        # For dA\n        h1_A = FD_REL_STEP_1 * A\n        h2_A = FD_REL_STEP_2 * A\n        \n        g_fd_A_h1 = compute_fd_grad_A(T_INIT, T_SPAN, params, h1_A, RTOL_BASE, ATOL_BASE)\n        g_fd_A_h2_base = compute_fd_grad_A(T_INIT, T_SPAN, params, h2_A, RTOL_BASE, ATOL_BASE)\n        g_fd_A_h2_tight = compute_fd_grad_A(T_INIT, T_SPAN, params, h2_A, RTOL_TIGHT, ATOL_TIGHT)\n        \n        delta_fd_A = abs(g_fd_A_h2_base - g_fd_A_h1)\n        delta_sol_A = abs(g_fd_A_h2_base - g_fd_A_h2_tight)\n        delta_fp_A = MACHINE_EPS * max(1.0, abs(g_adj_A))\n        \n        tol_A = C_VERIFY * (delta_fd_A + delta_sol_A + delta_fp_A)\n        err_A = abs(g_adj_A - g_fd_A_h2_base)\n        \n        verified_A = err_A = tol_A\n\n        # For dE\n        h1_E = FD_REL_STEP_1 * E\n        h2_E = FD_REL_STEP_2 * E\n        \n        g_fd_E_h1 = compute_fd_grad_E(T_INIT, T_SPAN, params, h1_E, RTOL_BASE, ATOL_BASE)\n        g_fd_E_h2_base = compute_fd_grad_E(T_INIT, T_SPAN, params, h2_E, RTOL_BASE, ATOL_BASE)\n        g_fd_E_h2_tight = compute_fd_grad_E(T_INIT, T_SPAN, params, h2_E, RTOL_TIGHT, ATOL_TIGHT)\n        \n        delta_fd_E = abs(g_fd_E_h2_base - g_fd_E_h1)\n        delta_sol_E = abs(g_fd_E_h2_base - g_fd_E_h2_tight)\n        delta_fp_E = MACHINE_EPS * max(1.0, abs(g_adj_E))\n\n        tol_E = C_VERIFY * (delta_fd_E + delta_sol_E + delta_fp_E)\n        err_E = abs(g_adj_E - g_fd_E_h2_base)\n        \n        verified_E = err_E = tol_E\n\n        results.append(verified_A and verified_E)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef forward_ode(t, x, A, E, R, q):\n    \"\"\"ODE system for the forward problem.\"\"\"\n    Y, T = x\n    if T = 0: return np.zeros(2)\n    k = A * np.exp(-E / (R * T))\n    dY_dt = -k * Y\n    dT_dt = q * k * Y\n    return np.array([dY_dt, dT_dt])\n\ndef get_final_temp(y0, t_span, params, rtol, atol):\n    \"\"\"Solve forward ODE and return final temperature.\"\"\"\n    sol = solve_ivp(\n        fun=lambda t, y: forward_ode(t, y, **params),\n        t_span=t_span,\n        y0=y0,\n        method='BDF',\n        rtol=rtol,\n        atol=atol\n    )\n    return sol.y[1, -1]\n\ndef compute_fd_grad_A(y0, t_span, params, h, rtol, atol):\n    \"\"\"Compute FD gradient for parameter A.\"\"\"\n    params_p = params.copy(); params_p['A'] += h\n    params_m = params.copy(); params_m['A'] -= h\n    \n    Tf_p = get_final_temp(y0, t_span, params_p, rtol, atol)\n    Tf_m = get_final_temp(y0, t_span, params_m, rtol, atol)\n    \n    return (Tf_p - Tf_m) / (2 * h)\n\ndef compute_fd_grad_E(y0, t_span, params, h, rtol, atol):\n    \"\"\"Compute FD gradient for parameter E.\"\"\"\n    params_p = params.copy(); params_p['E'] += h\n    params_m = params.copy(); params_m['E'] -= h\n    \n    Tf_p = get_final_temp(y0, t_span, params_p, rtol, atol)\n    Tf_m = get_final_temp(y0, t_span, params_m, rtol, atol)\n\n    return (Tf_p - Tf_m) / (2 * h)\n\ndef compute_adjoint_gradient(y0, t_span, params, rtol, atol):\n    \"\"\"Compute adjoint gradient for parameters A and E.\"\"\"\n    t0, tf = t_span\n    A, E, R, q = params['A'], params['E'], params['R'], params['q']\n\n    # --- Forward pass ---\n    sol_fwd = solve_ivp(\n        fun=lambda t, y: forward_ode(t, y, **params),\n        t_span=t_span,\n        y0=y0,\n        method='BDF',\n        dense_output=True,\n        rtol=rtol,\n        atol=atol\n    )\n\n    # --- Backward pass ---\n    def backward_ode_augmented(tau, z, sol_fwd_interp):\n        \"\"\"Augmented adjoint ODE system in backward time tau = tf - t.\"\"\"\n        lambda_Y, lambda_T, g_A, g_E = z\n        t = tf - tau\n        \n        Y, T = sol_fwd_interp(t)\n\n        if T = 0:\n            return np.zeros(4)\n        \n        k = A * np.exp(-E / (R * T))\n        \n        # Common term in adjoint ODEs and gradient integrands\n        common_term = q * lambda_T - lambda_Y\n        \n        # Adjoint ODEs\n        d_lambda_Y_dtau = k * common_term\n        d_lambda_T_dtau = Y * k * (E / (R * T**2)) * common_term\n        \n        # Gradient integrands\n        d_gA_dtau = (k * Y / A) * common_term\n        d_gE_dtau = -(k * Y / (R * T)) * common_term\n        \n        return np.array([d_lambda_Y_dtau, d_lambda_T_dtau, d_gA_dtau, d_gE_dtau])\n\n    # Initial conditions for backward integration (@ tau=0, which is t=tf)\n    z0 = np.array([0.0, 1.0, 0.0, 0.0]) # [lambda_Y, lambda_T, grad_A, grad_E]\n    \n    sol_bwd = solve_ivp(\n        fun=lambda tau, z: backward_ode_augmented(tau, z, sol_fwd.sol),\n        t_span=[t0, tf],\n        y0=z0,\n        method='BDF',\n        rtol=rtol,\n        atol=atol\n    )\n\n    grad_A = sol_bwd.y[2, -1]\n    grad_E = sol_bwd.y[3, -1]\n    \n    return grad_A, grad_E\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}