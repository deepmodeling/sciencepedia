{
    "hands_on_practices": [
        {
            "introduction": "The first step in building any data-driven model is to process raw data into meaningful inputs. This exercise focuses on the critical process of feature engineering, transforming raw simulation data into a set of rotationally invariant scalar features suitable for a machine learning model. By implementing the mapping from velocity fields to the invariants of the strain-rate and rotation-rate tensors, you will gain hands-on experience with the data pipeline that underpins turbulence modeling .",
            "id": "4037707",
            "problem": "You are given synthetic Direct Numerical Simulation (DNS) fields representing variable-density turbulent combustion on a uniform Cartesian grid. Your task is to implement a complete mapping from raw DNS fields to a set of scalar invariant features suitable as inputs to a machine learning model for turbulence closure in computational combustion. Specifically, you must compute the mass-weighted (Favre-filtered) velocity, its gradient, and from it the symmetric strain-rate tensor and antisymmetric rotation-rate tensor, followed by a standardized set of scalar invariants. The mapping must be mathematically consistent, rotationally invariant, and must produce values in the correct physical units.\n\nStart from the following definitions and requirements:\n\n- Use a uniform grid of size $3\\times 3 \\times 3$ with Cartesian coordinates $(x,y,z)$ and equal spacings $\\Delta x=\\Delta y=\\Delta z=1\\,\\mathrm{m}$. Periodic boundary conditions must be used for all spatial operations.\n- The mass-weighted (Favre) filtered velocity is defined as $\\tilde{u}_i=\\overline{\\rho u_i}/\\overline{\\rho}$, where $\\overline{\\cdot}$ denotes a local spatial average with a compact symmetric kernel. Implement $\\overline{\\cdot}$ as a discrete top-hat average over the $3\\times 3 \\times 3$ neighborhood centered at each grid cell (periodic wrapping applies), i.e., the arithmetic mean of the $27$ neighboring values.\n- The velocity gradient tensor is defined as $\\nabla \\tilde{\\mathbf{u}}$ with components $\\partial_i \\tilde{u}_j=\\frac{\\partial \\tilde{u}_j}{\\partial x_i}$, approximated by second-order central differences with periodic boundary conditions:\n$$\n\\partial_i \\tilde{u}_j(\\mathbf{x}_{pqr})\\approx \\frac{\\tilde{u}_j(\\mathbf{x}_{pqr}+\\Delta x_i \\mathbf{e}_i)-\\tilde{u}_j(\\mathbf{x}_{pqr}-\\Delta x_i \\mathbf{e}_i)}{2\\Delta x_i},\n$$\nwhere $\\mathbf{x}_{pqr}$ is the cell at indices $(p,q,r)$, $\\mathbf{e}_i$ is the unit vector along axis $i\\in\\{x,y,z\\}$, and $\\Delta x_i=\\Delta x$ for all $i$.\n\n- Decompose the velocity gradient into its symmetric and antisymmetric parts:\n$$\nS_{ij}=\\frac{1}{2}\\left(\\partial_i \\tilde{u}_j+\\partial_j \\tilde{u}_i\\right),\\qquad\nR_{ij}=\\frac{1}{2}\\left(\\partial_i \\tilde{u}_j-\\partial_j \\tilde{u}_i\\right),\n$$\nwhere $\\mathbf{S}$ is the strain-rate tensor and $\\mathbf{R}$ is the rotation-rate tensor.\n\nFrom $\\mathbf{S}$ and $\\mathbf{R}$, compute the following scalar invariants at the central grid index $(p,q,r)=(1,1,1)$:\n\n- $I_1=\\mathrm{tr}(\\mathbf{S})$ with units $\\mathrm{s}^{-1}$,\n- $I_2=\\det(\\mathbf{S})$ with units $\\mathrm{s}^{-3}$,\n- $I_3=\\mathrm{tr}(\\mathbf{S}^2)$ with units $\\mathrm{s}^{-2}$,\n- $I_4=\\mathrm{tr}(\\mathbf{R}^2)$ with units $\\mathrm{s}^{-2}$,\n- $I_5=\\mathrm{tr}(\\mathbf{S}^3)$ with units $\\mathrm{s}^{-3}$,\n- $I_6=\\mathrm{tr}(\\mathbf{R}^2\\mathbf{S})$ with units $\\mathrm{s}^{-3}$,\n- $I_7=\\mathrm{tr}(\\mathbf{R}^2\\mathbf{S}^2)$ with units $\\mathrm{s}^{-4}$.\n\nAll invariants must be computed directly from the discrete $\\mathbf{S}$ and $\\mathbf{R}$ tensors built from the Favre-filtered velocity gradient at the specified index. Do not invoke any pre-tabulated formulas, and ensure that periodic boundary conditions are enforced consistently for both filtering and differentiation.\n\nTest Suite:\nImplement and evaluate the mapping on the following four cases. In each case, define the velocity components $(u,v,w)$ and density $\\rho$ on the $3\\times 3\\times 3$ grid using the specified parameters, with coordinates $x=i\\Delta x$, $y=j\\Delta y$, $z=k\\Delta z$ for indices $i,j,k\\in\\{0,1,2\\}$.\n\n$1.$ Homogeneous shear flow with uniform density:\n- Parameters: $a=2.0\\,\\mathrm{s}^{-1}$, $\\rho_0=1.0\\,\\mathrm{kg/m^3}$.\n- Fields: $u=a\\,y$, $v=0$, $w=0$, $\\rho=\\rho_0$.\n\n$2.$ Solid-body rotation about the $z$-axis with uniform density:\n- Parameters: $\\omega=1.5\\,\\mathrm{s}^{-1}$, $\\rho_0=1.0\\,\\mathrm{kg/m^3}$.\n- Fields: $u=-\\omega\\,y$, $v=\\omega\\,x$, $w=0$, $\\rho=\\rho_0$.\n\n$3.$ Compressible stagnation-type flow with density stratification in $x$:\n- Parameters: $a=0.5\\,\\mathrm{s}^{-1}$, $b=0.75\\,\\mathrm{s}^{-1}$, $c=-0.25\\,\\mathrm{s}^{-1}$, $\\rho_0=1.2\\,\\mathrm{kg/m^3}$, $\\epsilon=0.05\\,\\mathrm{m}^{-1}$.\n- Fields: $u=a\\,x$, $v=b\\,y$, $w=c\\,z$, $\\rho=\\rho_0\\,(1+\\epsilon\\,x)$.\n\n$4.$ Spatially constant fields:\n- Parameters: $\\rho_0=1.0\\,\\mathrm{kg/m^3}$.\n- Fields: $u=0$, $v=0$, $w=0$, $\\rho=\\rho_0$.\n\nUnits:\n- Express $I_1$ in $\\mathrm{s}^{-1}$, $I_2$ and $I_5$ and $I_6$ in $\\mathrm{s}^{-3}$, $I_3$ and $I_4$ in $\\mathrm{s}^{-2}$, and $I_7$ in $\\mathrm{s}^{-4}$. Only output the numeric values; do not append unit strings.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of the seven invariants in the order $[I_1,I_2,I_3,I_4,I_5,I_6,I_7]$. For example, the output should look like:\n$[\\,[i_{1,1},i_{1,2},\\dots,i_{1,7}],\\,[i_{2,1},\\dots,i_{2,7}],\\,[i_{3,1},\\dots,i_{3,7}],\\,[i_{4,1},\\dots,i_{4,7}]\\,]$,\nwhere $i_{m,n}$ denotes the $n$-th invariant from the $m$-th test case as a floating-point number.",
            "solution": "The problem requires the computation of a set of scalar invariants derived from the velocity gradient tensor, using data from synthetic Direct Numerical Simulation (DNS) fields. The process involves several steps: generation of raw velocity and density fields, spatial filtering, computation of the Favre-filtered velocity field, numerical differentiation to obtain the velocity gradient tensor, decomposition into symmetric and antisymmetric parts, and finally, calculation of the tensor invariants. The entire procedure's validity and outcome are critically dependent on the precise definitions of the numerical operators and the grid configuration.\n\nFirst, let us establish the computational grid and operators as defined in the problem statement. The grid is a uniform Cartesian mesh of size $3 \\times 3 \\times 3$, with grid spacing $\\Delta x = \\Delta y = \\Delta z = 1\\,\\mathrm{m}$. We may represent grid points by integer indices $(i,j,k)$ where $i,j,k \\in \\{0, 1, 2\\}$, corresponding to spatial coordinates $x=i\\Delta x$, $y=j\\Delta y$, and $z=k\\Delta z$. All spatial operations, including filtering and differentiation, must employ periodic boundary conditions.\n\nThe central operation is the spatial averaging, denoted by $\\overline{\\cdot}$. It is defined as a discrete top-hat average over a $3 \\times 3 \\times 3$ neighborhood, which comprises the mean of $27$ cell values. Let us analyze the consequence of this definition on our specific grid. A point at index $(i,j,k)$ has neighbors at indices $(i+di, j+dj, k+dk)$ where $di, dj, dk \\in \\{-1, 0, 1\\}$. With periodic boundary conditions on a grid of size $3$ in each dimension, indices are taken modulo $3$. For any point $(i,j,k)$, the set of neighboring indices $\\{ (i+di)\\%3, (j+dj)\\%3, (k+dk)\\%3 \\}$ for all $di,dj,dk \\in \\{-1,0,1\\}$ spans the entire set of possible indices $\\{0,1,2\\} \\times \\{0,1,2\\} \\times \\{0,1,2\\}$. For instance, for the central cell $(1,1,1)$, the neighbors are indexed from $(0,0,0)$ to $(2,2,2)$, covering the whole grid. For a corner cell like $(0,0,0)$, the neighbors are indexed by $\\{(-1)\\%3, 0\\%3, 1\\%3\\}$ in each dimension, which corresponds to indices $\\{2,0,1\\}$. Again, the neighborhood is the entire grid.\n\nThis analysis reveals a crucial property: for the specified $3 \\times 3 \\times 3$ grid with periodic boundaries, the $3 \\times 3 \\times 3$ top-hat filter is equivalent to a global average over all $27$ points of the domain. Consequently, for any field $f(x,y,z)$, the filtered field $\\overline{f}$ will be spatially constant, with its value equal to the mean of $f$ over the entire domain.\n\nThe Favre-filtered velocity $\\tilde{u}_i$ is defined as $\\tilde{u}_i = \\overline{\\rho u_i} / \\overline{\\rho}$. The filtering operation is applied to the density field $\\rho$ and the momentum fields $\\rho u_i$. This yields spatially constant fields $\\overline{\\rho}$ and $\\overline{\\rho u_i}$. Their ratio, $\\tilde{u}_i$, is therefore also a spatially constant scalar value for each component $i \\in \\{1,2,3\\}$. Let us denote these constant values as $\\tilde{u}_c$, $\\tilde{v}_c$, and $\\tilde{w}_c$. The Favre-filtered velocity field is thus $\\tilde{\\mathbf{u}}(\\mathbf{x}) = (\\tilde{u}_c, \\tilde{v}_c, \\tilde{w}_c)$, which is uniform across the entire domain.\n\nThe next step is to compute the velocity gradient tensor, $\\nabla \\tilde{\\mathbf{u}}$, with components $\\partial_i \\tilde{u}_j = \\frac{\\partial \\tilde{u}_j}{\\partial x_i}$. These are calculated using a second-order central difference scheme at the central grid point $(1,1,1)$. For example, the component $\\partial_x \\tilde{u}$ is:\n$$\n\\partial_x \\tilde{u}(1,1,1) \\approx \\frac{\\tilde{u}(x_2, y_1, z_1) - \\tilde{u}(x_0, y_1, z_1)}{2\\Delta x}\n$$\nSince the field $\\tilde{u}$ is constant, $\\tilde{u}(x_2, y_1, z_1) = \\tilde{u}(x_0, y_1, z_1) = \\tilde{u}_c$. The numerator is therefore zero. This applies to all components of the gradient. Thus, the velocity gradient tensor $\\nabla \\tilde{\\mathbf{u}}$ is the zero tensor:\n$$\n\\nabla \\tilde{\\mathbf{u}} = \\begin{pmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\nThis holds true provided that the mean density $\\overline{\\rho}$ is non-zero, allowing for the calculation of $\\tilde{u}_i$. For all four test cases provided, the density $\\rho$ is strictly positive everywhere, ensuring $\\overline{\\rho}  0$.\n\nFrom the zero velocity gradient, we find the strain-rate tensor $\\mathbf{S}$ and rotation-rate tensor $\\mathbf{R}$:\n$$\nS_{ij} = \\frac{1}{2}\\left(\\partial_i \\tilde{u}_j + \\partial_j \\tilde{u}_i\\right) = \\frac{1}{2}(0 + 0) = 0\n$$\n$$\nR_{ij} = \\frac{1}{2}\\left(\\partial_i \\tilde{u}_j - \\partial_j \\tilde{u}_i\\right) = \\frac{1}{2}(0 - 0) = 0\n$$\nBoth $\\mathbf{S}$ and $\\mathbf{R}$ are the $3 \\times 3$ zero tensor, $\\mathbf{0}$.\n\nFinally, we compute the seven scalar invariants from these zero tensors:\n- $I_1 = \\mathrm{tr}(\\mathbf{S}) = \\mathrm{tr}(\\mathbf{0}) = 0$\n- $I_2 = \\det(\\mathbf{S}) = \\det(\\mathbf{0}) = 0$\n- $I_3 = \\mathrm{tr}(\\mathbf{S}^2) = \\mathrm{tr}(\\mathbf{0}) = 0$\n- $I_4 = \\mathrm{tr}(\\mathbf{R}^2) = \\mathrm{tr}(\\mathbf{0}) = 0$\n- $I_5 = \\mathrm{tr}(\\mathbf{S}^3) = \\mathrm{tr}(\\mathbf{0}) = 0$\n- $I_6 = \\mathrm{tr}(\\mathbf{R}^2\\mathbf{S}) = \\mathrm{tr}(\\mathbf{0} \\cdot \\mathbf{0}) = 0$\n- $I_7 = \\mathrm{tr}(\\mathbf{R}^2\\mathbf{S}^2) = \\mathrm{tr}(\\mathbf{0} \\cdot \\mathbf{0}) = 0$\n\nThis reasoning is general and applies to any set of initial fields $\\rho$ and $u_i$ defined on the specified grid, due to the nature of the filtering operator. Therefore, for all four test cases, the calculated set of seven invariants will be $[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]$. The provided numerical implementation will execute these steps formally to confirm this result.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes scalar invariants from synthetic DNS fields for four test cases.\n    The problem setup leads to all invariants being zero due to the specific\n    choice of grid size and filter kernel which results in a constant\n    Favre-filtered velocity field.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Homogeneous shear flow\",\n            \"params\": {\"a\": 2.0, \"rho0\": 1.0},\n            \"fields\": {\n                \"u\": lambda x, y, z, p: p[\"a\"] * y,\n                \"v\": lambda x, y, z, p: 0.0,\n                \"w\": lambda x, y, z, p: 0.0,\n                \"rho\": lambda x, y, z, p: p[\"rho0\"],\n            },\n        },\n        {\n            \"name\": \"Solid-body rotation\",\n            \"params\": {\"omega\": 1.5, \"rho0\": 1.0},\n            \"fields\": {\n                \"u\": lambda x, y, z, p: -p[\"omega\"] * y,\n                \"v\": lambda x, y, z, p: p[\"omega\"] * x,\n                \"w\": lambda x, y, z, p: 0.0,\n                \"rho\": lambda x, y, z, p: p[\"rho0\"],\n            },\n        },\n        {\n            \"name\": \"Compressible stagnation flow\",\n            \"params\": {\n                \"a\": 0.5, \"b\": 0.75, \"c\": -0.25, \"rho0\": 1.2, \"epsilon\": 0.05\n            },\n            \"fields\": {\n                \"u\": lambda x, y, z, p: p[\"a\"] * x,\n                \"v\": lambda x, y, z, p: p[\"b\"] * y,\n                \"w\": lambda x, y, z, p: p[\"c\"] * z,\n                \"rho\": lambda x, y, z, p: p[\"rho0\"] * (1 + p[\"epsilon\"] * x),\n            },\n        },\n        {\n            \"name\": \"Spatially constant fields\",\n            \"params\": {\"rho0\": 1.0},\n            \"fields\": {\n                \"u\": lambda x, y, z, p: 0.0,\n                \"v\": lambda x, y, z, p: 0.0,\n                \"w\": lambda x, y, z, p: 0.0,\n                \"rho\": lambda x, y, z, p: p[\"rho0\"],\n            },\n        },\n    ]\n\n    results = []\n    \n    # Grid properties\n    grid_size = (3, 3, 3)\n    dx = dy = dz = 1.0\n    deltas = [dx, dy, dz]\n\n    for case in test_cases:\n        params = case[\"params\"]\n        field_funcs = case[\"fields\"]\n\n        # 1. Generate Raw Fields\n        # Grid coordinates (indices i, j, k are used as coordinates as delta=1)\n        k_coords, j_coords, i_coords = np.mgrid[0:grid_size[2], 0:grid_size[1], 0:grid_size[0]]\n        x_coords, y_coords, z_coords = i_coords * dx, j_coords * dy, k_coords * dz\n\n        rho = np.full(grid_size, fill_value=0.0, dtype=float)\n        u = np.full(grid_size, fill_value=0.0, dtype=float)\n        v = np.full(grid_size, fill_value=0.0, dtype=float)\n        w = np.full(grid_size, fill_value=0.0, dtype=float)\n        \n        rho = field_funcs[\"rho\"](x_coords, y_coords, z_coords, params)\n        u = field_funcs[\"u\"](x_coords, y_coords, z_coords, params)\n        v = field_funcs[\"v\"](x_coords, y_coords, z_coords, params)\n        w = field_funcs[\"w\"](x_coords, y_coords, z_coords, params)\n\n        # 2. Compute Favre-Filtered Velocity\n        # In a 3x3x3 periodic grid, a 3x3x3 top-hat filter is a global average.\n        rho_bar = np.mean(rho)\n        rhou_bar = np.mean(rho * u)\n        rhov_bar = np.mean(rho * v)\n        rhow_bar = np.mean(rho * w)\n\n        u_tilde_scalar = rhou_bar / rho_bar\n        v_tilde_scalar = rhov_bar / rho_bar\n        w_tilde_scalar = rhow_bar / rho_bar\n\n        u_tilde_field = np.full(grid_size, u_tilde_scalar)\n        v_tilde_field = np.full(grid_size, v_tilde_scalar)\n        w_tilde_field = np.full(grid_size, w_tilde_scalar)\n        \n        tilde_vels = [u_tilde_field, v_tilde_field, w_tilde_field]\n\n        # 3. Compute Velocity Gradient Tensor at center (1,1,1)\n        grad_u_tilde = np.zeros((3, 3))\n        center_idx = (1, 1, 1) # p,q,r - z,y,x indices in numpy\n\n        for j in range(3): # component of velocity (u_j)\n            for i in range(3): # direction of derivative (d/dx_i)\n                # Central difference: (f(x+h) - f(x-h)) / 2h\n                # Indices must be wrapped due to periodicity\n                \n                # neighbor index +1\n                p1_idx = list(center_idx)\n                p1_idx[2-i] = (center_idx[2-i] + 1) % 3\n                \n                # neighbor index -1\n                m1_idx = list(center_idx)\n                m1_idx[2-i] = (center_idx[2-i] - 1 + 3) % 3\n\n                val_p1 = tilde_vels[j][tuple(p1_idx)]\n                val_m1 = tilde_vels[j][tuple(m1_idx)]\n                \n                grad_u_tilde[i, j] = (val_p1 - val_m1) / (2.0 * deltas[i])\n\n        # 4. Decompose into Strain-Rate and Rotation-Rate Tensors\n        S = 0.5 * (grad_u_tilde + grad_u_tilde.T)\n        R = 0.5 * (grad_u_tilde - grad_u_tilde.T)\n\n        # 5. Compute Scalar Invariants\n        S2 = S @ S\n        S3 = S2 @ S\n        R2 = R @ R\n\n        I1 = np.trace(S)\n        I2 = np.linalg.det(S)\n        I3 = np.trace(S2)\n        I4 = np.trace(R2)\n        I5 = np.trace(S3)\n        I6 = np.trace(R2 @ S)\n        I7 = np.trace(R2 @ S2)\n        \n        invariants = [I1, I2, I3, I4, I5, I6, I7]\n        results.append(invariants)\n\n    # Final print statement in the exact required format.\n    # We construct the string representation manually to match the required format.\n    result_strings = []\n    for inv_list in results:\n        # Format each list to avoid spaces and use one decimal place for floats.\n        inv_str = f\"[{','.join(f'{x:.1f}' for x in inv_list)}]\"\n        result_strings.append(inv_str)\n\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A core challenge in simulating turbulent combustion is the closure of chemical source terms, as filtering the highly nonlinear reaction rates introduces significant error. This practice delves into the heart of this closure problem, providing a quantitative look at why simple \"naive\" closures are insufficient. You will use a second-order moment expansion to approximate the true filtered reaction rate, thereby isolating and quantifying the modeling error caused by subfilter-scale fluctuations of species and temperature .",
            "id": "4037717",
            "problem": "You are given a micro-kinetics mechanism for a reacting mixture that defines a progress-variable source rate as the sum of two elementary reaction rates. Consider the Large-Eddy Simulation (LES) filtered progress-variable source term denoted by $\\tilde{\\dot{\\omega}}_c$. The closure problem arises because the filtered source $\\tilde{\\dot{\\omega}}_c$ is, in general, not equal to the source evaluated at filtered means due to nonlinearity and subfilter covariance. Your task is to compute the modeled filtered source by evaluating the source at filtered means, and to quantify the modeling error attributable to nonlinearity and covariance via a second-order moment expansion.\n\nFundamental base to use:\n- The filtered transport equation in Large-Eddy Simulation (LES) includes a source term $\\tilde{\\dot{\\omega}}_c$ that is the filter of the microscopic source $\\dot{\\omega}_c(\\mathbf{Y},T)$, where $\\mathbf{Y}$ denotes species mass fractions and $T$ denotes temperature.\n- The expectation of a nonlinear function under small fluctuations admits a second-order Taylor expansion: for a sufficiently smooth function $f$, random vector $\\mathbf{X}$ with mean $\\boldsymbol{\\mu}$ and covariance $\\boldsymbol{\\Sigma}$, $\\mathbb{E}[f(\\mathbf{X})] \\approx f(\\boldsymbol{\\mu}) + \\frac{1}{2}\\,\\mathrm{tr}\\left(\\mathbf{H}_f(\\boldsymbol{\\mu})\\,\\boldsymbol{\\Sigma}\\right)$, where $\\mathbf{H}_f$ is the Hessian matrix of second derivatives of $f$ with respect to its inputs.\n\nMechanism definition:\n- Let the reacting system involve species with mass fractions $\\mathbf{Y} = (Y_F, Y_{O_2}, Y_R)$ for fuel, oxidizer, and an intermediate radical, respectively, and temperature $T$ in Kelvin.\n- Two elementary reactions contribute to the progress variable source:\n  1. Reaction $1$: $F + O_2 \\rightarrow P + R$ with rate\n     $$r_1(Y_F, Y_{O_2}, T) = A_1\\,Y_F^{a_1}\\,Y_{O_2}^{b_1}\\,\\exp\\!\\left(-\\frac{E_1}{R_u\\,T}\\right),$$\n  2. Reaction $2$: $R + O_2 \\rightarrow P$ with rate\n     $$r_2(Y_R, Y_{O_2}, T) = A_2\\,Y_R^{a_2}\\,Y_{O_2}^{b_2}\\,\\exp\\!\\left(-\\frac{E_2}{R_u\\,T}\\right),$$\n  where $A_1$ and $A_2$ are pre-exponential factors in $\\mathrm{s}^{-1}$, $a_1$, $a_2$, $b_1$, $b_2$ are reaction orders (dimensionless), $E_1$ and $E_2$ are activation energies in $\\mathrm{J/mol}$, and $R_u$ is the Universal Gas Constant with $R_u = 8.314\\,\\mathrm{J/(mol\\,K)}$.\n- Define the microscopic progress-variable source rate as\n  $$\\dot{\\omega}_c(\\mathbf{Y},T) = r_1(Y_F, Y_{O_2}, T) + r_2(Y_R, Y_{O_2}, T).$$\n\nClosure definitions to evaluate:\n- Modeled filtered source (naive closure using means):\n  $$\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}} = \\dot{\\omega}_c\\!\\left(\\tilde{\\mathbf{Y}}, \\tilde{T}\\right) = \\dot{\\omega}_c\\!\\left(\\boldsymbol{\\mu}_{\\mathbf{Y}}, \\mu_T\\right),$$\n  where $(\\boldsymbol{\\mu}_{\\mathbf{Y}}, \\mu_T)$ are the filtered means of $(\\mathbf{Y},T)$.\n- Second-order approximation of the true filtered source:\n  $$\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}} \\approx \\dot{\\omega}_c(\\boldsymbol{\\mu}_{\\mathbf{Y}}, \\mu_T) + \\frac{1}{2}\\,\\mathrm{tr}\\!\\left(\\mathbf{H}_{\\dot{\\omega}_c}(\\boldsymbol{\\mu}_{\\mathbf{Y}},\\mu_T)\\,\\boldsymbol{\\Sigma}\\right),$$\n  where $\\boldsymbol{\\Sigma}$ is the covariance matrix of $(Y_F, Y_{O_2}, Y_R, T)$, and $\\mathbf{H}_{\\dot{\\omega}_c}$ is the Hessian of $\\dot{\\omega}_c$ with respect to $(Y_F, Y_{O_2}, Y_R, T)$.\n\nOutputs to compute for each test case:\n- The modeled filtered source $\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}$ in $\\mathrm{s}^{-1}$.\n- The second-order approximation $\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}$ in $\\mathrm{s}^{-1}$.\n- The relative modeling bias due to nonlinearity and covariance defined as\n  $$b_{\\mathrm{rel}} = \\frac{\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}} - \\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}}{\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}},$$\n  expressed as a decimal (unitless).\n\nPhysical units:\n- Temperature $T$ must be used in Kelvin.\n- Source rates must be expressed in $\\mathrm{s}^{-1}$.\n\nAngle units:\n- No angles appear in this problem.\n\nTest suite:\nFor each test case $i \\in \\{1,2,3,4\\}$, you are provided $(A_1, E_1, a_1, b_1, A_2, E_2, a_2, b_2)$, the filtered means $(\\mu_{Y_F}, \\mu_{Y_{O_2}}, \\mu_{Y_R}, \\mu_T)$, and the covariance matrix $\\boldsymbol{\\Sigma}$ with variable ordering $(Y_F, Y_{O_2}, Y_R, T)$.\n\n- Test case $1$:\n  - Mechanism parameters: $A_1 = 5.0\\times 10^{6}\\,\\mathrm{s}^{-1}$, $E_1 = 1.2\\times 10^{5}\\,\\mathrm{J/mol}$, $a_1 = 1.0$, $b_1 = 1.0$; $A_2 = 2.5\\times 10^{7}\\,\\mathrm{s}^{-1}$, $E_2 = 1.8\\times 10^{5}\\,\\mathrm{J/mol}$, $a_2 = 1.0$, $b_2 = 0.5$.\n  - Means: $\\mu_{Y_F} = 0.02$, $\\mu_{Y_{O_2}} = 0.21$, $\\mu_{Y_R} = 0.001$, $\\mu_T = 1500$.\n  - Covariance matrix:\n    $$\\boldsymbol{\\Sigma} = \\begin{bmatrix}\n    1.0\\times 10^{-6}  -5.0\\times 10^{-7}  1.0\\times 10^{-8}  5.0\\times 10^{-2} \\\\\n    -5.0\\times 10^{-7}  2.0\\times 10^{-6}  -3.0\\times 10^{-8}  -1.0\\times 10^{-1} \\\\\n    1.0\\times 10^{-8}  -3.0\\times 10^{-8}  5.0\\times 10^{-8}  0.0 \\\\\n    5.0\\times 10^{-2}  -1.0\\times 10^{-1}  0.0  4.0\\times 10^{2}\n    \\end{bmatrix}.$$\n\n- Test case $2$:\n  - Mechanism parameters: $A_1 = 4.0\\times 10^{6}\\,\\mathrm{s}^{-1}$, $E_1 = 1.0\\times 10^{5}\\,\\mathrm{J/mol}$, $a_1 = 1.0$, $b_1 = 1.0$; $A_2 = 1.5\\times 10^{7}\\,\\mathrm{s}^{-1}$, $E_2 = 1.6\\times 10^{5}\\,\\mathrm{J/mol}$, $a_2 = 1.0$, $b_2 = 0.7$.\n  - Means: $\\mu_{Y_F} = 0.001$, $\\mu_{Y_{O_2}} = 0.23$, $\\mu_{Y_R} = 0.0005$, $\\mu_T = 1200$.\n  - Covariance matrix:\n    $$\\boldsymbol{\\Sigma} = \\begin{bmatrix}\n    1.0\\times 10^{-8}  -2.0\\times 10^{-8}  0.0  1.0\\times 10^{-2} \\\\\n    -2.0\\times 10^{-8}  1.5\\times 10^{-6}  -1.0\\times 10^{-8}  -2.0\\times 10^{-2} \\\\\n    0.0  -1.0\\times 10^{-8}  1.0\\times 10^{-8}  0.0 \\\\\n    1.0\\times 10^{-2}  -2.0\\times 10^{-2}  0.0  2.25\\times 10^{2}\n    \\end{bmatrix}.$$\n\n- Test case $3$:\n  - Mechanism parameters: $A_1 = 6.0\\times 10^{6}\\,\\mathrm{s}^{-1}$, $E_1 = 1.4\\times 10^{5}\\,\\mathrm{J/mol}$, $a_1 = 1.0$, $b_1 = 1.2$; $A_2 = 3.0\\times 10^{7}\\,\\mathrm{s}^{-1}$, $E_2 = 2.0\\times 10^{5}\\,\\mathrm{J/mol}$, $a_2 = 1.0$, $b_2 = 0.6$.\n  - Means: $\\mu_{Y_F} = 0.015$, $\\mu_{Y_{O_2}} = 0.20$, $\\mu_{Y_R} = 0.002$, $\\mu_T = 2000$.\n  - Covariance matrix:\n    $$\\boldsymbol{\\Sigma} = \\begin{bmatrix}\n    5.0\\times 10^{-7}  -3.0\\times 10^{-7}  3.0\\times 10^{-8}  1.0\\times 10^{-1} \\\\\n    -3.0\\times 10^{-7}  2.0\\times 10^{-6}  -1.0\\times 10^{-7}  -1.5\\times 10^{-1} \\\\\n    3.0\\times 10^{-8}  -1.0\\times 10^{-7}  2.0\\times 10^{-7}  2.0\\times 10^{-1} \\\\\n    1.0\\times 10^{-1}  -1.5\\times 10^{-1}  2.0\\times 10^{-1}  9.0\\times 10^{2}\n    \\end{bmatrix}.$$\n\n- Test case $4$:\n  - Mechanism parameters: $A_1 = 3.0\\times 10^{6}\\,\\mathrm{s}^{-1}$, $E_1 = 0.9\\times 10^{5}\\,\\mathrm{J/mol}$, $a_1 = 1.0$, $b_1 = 1.0$; $A_2 = 2.2\\times 10^{7}\\,\\mathrm{s}^{-1}$, $E_2 = 1.7\\times 10^{5}\\,\\mathrm{J/mol}$, $a_2 = 1.0$, $b_2 = 0.5$.\n  - Means: $\\mu_{Y_F} = 1.0\\times 10^{-5}$, $\\mu_{Y_{O_2}} = 0.25$, $\\mu_{Y_R} = 1.0\\times 10^{-6}$, $\\mu_T = 1400$.\n  - Covariance matrix:\n    $$\\boldsymbol{\\Sigma} = \\begin{bmatrix}\n    1.0\\times 10^{-7}  -1.0\\times 10^{-7}  5.0\\times 10^{-9}  2.0\\times 10^{-2} \\\\\n    -1.0\\times 10^{-7}  1.0\\times 10^{-6}  -2.0\\times 10^{-8}  -3.0\\times 10^{-2} \\\\\n    5.0\\times 10^{-9}  -2.0\\times 10^{-8}  1.0\\times 10^{-8}  0.0 \\\\\n    2.0\\times 10^{-2}  -3.0\\times 10^{-2}  0.0  4.0\\times 10^{2}\n    \\end{bmatrix}.$$\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- For the four test cases, output the twelve values in the following order:\n  $$[\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}(1),\\,\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}(1),\\,b_{\\mathrm{rel}}(1),\\,\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}(2),\\,\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}(2),\\,b_{\\mathrm{rel}}(2),\\,\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}(3),\\,\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}(3),\\,b_{\\mathrm{rel}}(3),\\,\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}(4),\\,\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}(4),\\,b_{\\mathrm{rel}}(4)],$$\n  where each $\\tilde{\\dot{\\omega}}_c$ is in $\\mathrm{s}^{-1}$ and each $b_{\\mathrm{rel}}$ is a decimal (unitless).",
            "solution": "The task is to evaluate a simple closure model for the filtered progress-variable source term in a Large-Eddy Simulation (LES) of a reacting flow and to quantify its error using a second-order moment expansion. The problem is well-defined, scientifically grounded in the principles of chemical kinetics and turbulence modeling, and all necessary parameters and data for its resolution are provided. I will proceed with a step-by-step derivation and computation.\n\nThe state of the system is described by a vector of variables $\\mathbf{x}$ and their corresponding filtered mean values $\\boldsymbol{\\mu}$. The variables are the mass fractions of fuel ($Y_F$), oxidizer ($Y_{O_2}$), a radical species ($Y_R$), and the temperature ($T$). We define the state vector as $\\mathbf{x} = (x_1, x_2, x_3, x_4)^T = (Y_F, Y_{O_2}, Y_R, T)^T$ and its mean as $\\boldsymbol{\\mu} = (\\mu_1, \\mu_2, \\mu_3, \\mu_4)^T = (\\tilde{Y}_F, \\tilde{Y}_{O_2}, \\tilde{Y}_R, \\tilde{T})^T$.\n\nThe microscopic source rate for the progress variable, $\\dot{\\omega}_c$, is given as the sum of two Arrhenius-type reaction rates, $r_1$ and $r_2$:\n$$\n\\dot{\\omega}_c(\\mathbf{x}) = r_1(x_1, x_2, x_4) + r_2(x_3, x_2, x_4)\n$$\nwhere\n$$\nr_1(x_1, x_2, x_4) = A_1\\,x_1^{a_1}\\,x_2^{b_1}\\,\\exp\\!\\left(-\\frac{E_1}{R_u\\,x_4}\\right)\n$$\n$$\nr_2(x_3, x_2, x_4) = A_2\\,x_3^{a_2}\\,x_2^{b_2}\\,\\exp\\!\\left(-\\frac{E_2}{R_u\\,x_4}\\right)\n$$\nThe universal gas constant is $R_u = 8.314\\,\\mathrm{J/(mol\\,K)}$.\n\nFirst, we compute the modeled filtered source, $\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}$, which is the source rate evaluated at the filtered mean values of the state variables:\n$$\n\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}} = \\dot{\\omega}_c(\\boldsymbol{\\mu}) = r_1(\\mu_1, \\mu_2, \\mu_4) + r_2(\\mu_3, \\mu_2, \\mu_4)\n$$\n\nNext, we seek a more accurate approximation of the true filtered source, $\\tilde{\\dot{\\omega}}_c = \\widetilde{\\dot{\\omega}_c(\\mathbf{x})}$, using a second-order Taylor expansion around the mean values. This accounts for the effects of subfilter fluctuations (covariance) and the nonlinearity of the source term function:\n$$\n\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}} = \\dot{\\omega}_c(\\boldsymbol{\\mu}) + \\frac{1}{2}\\,\\mathrm{tr}\\!\\left(\\mathbf{H}_{\\dot{\\omega}_c}(\\boldsymbol{\\mu})\\,\\boldsymbol{\\Sigma}\\right)\n$$\nHere, $\\boldsymbol{\\Sigma}$ is the $4 \\times 4$ covariance matrix of the state variables, provided for each test case. $\\mathbf{H}_{\\dot{\\omega}_c}(\\boldsymbol{\\mu})$ is the Hessian matrix of the source function $\\dot{\\omega}_c$, evaluated at the mean values $\\boldsymbol{\\mu}$. The Hessian is a symmetric matrix of second partial derivatives, $H_{ij} = \\frac{\\partial^2 \\dot{\\omega}_c}{\\partial x_i \\partial x_j}$.\n\nThe correction term due to nonlinearity and covariance is $\\Delta = \\frac{1}{2}\\,\\mathrm{tr}(\\mathbf{H}_{\\dot{\\omega}_c}\\,\\boldsymbol{\\Sigma})$. The trace operation is given by $\\mathrm{tr}(\\mathbf{A}\\mathbf{B}) = \\sum_i \\sum_j A_{ij} B_{ji}$. Since the covariance matrix $\\boldsymbol{\\Sigma}$ is symmetric ($\\Sigma_{ji} = \\Sigma_{ij}$), this simplifies to the sum of the element-wise product: $\\mathrm{tr}(\\mathbf{H}_{\\dot{\\omega}_c}\\,\\boldsymbol{\\Sigma}) = \\sum_{i,j} H_{ij} \\Sigma_{ij}$.\n\nTo compute the correction, we must first derive the components of the Hessian matrix $\\mathbf{H}_{\\dot{\\omega}_c} = \\mathbf{H}_{r_1} + \\mathbf{H}_{r_2}$. The following derivations assume positive values for all mean mass-fractions and temperature, which is physically consistent and holds for all test-cases. Let all functions and derivatives be evaluated at $\\boldsymbol{\\mu}$.\n\nThe second partial derivatives of $r_1$ are:\n$$ \\frac{\\partial^2 r_1}{\\partial x_1^2} = r_1 \\frac{a_1(a_1-1)}{x_1^2} \\quad , \\quad \\frac{\\partial^2 r_1}{\\partial x_2^2} = r_1 \\frac{b_1(b_1-1)}{x_2^2} \\quad , \\quad \\frac{\\partial^2 r_1}{\\partial x_4^2} = r_1 \\frac{E_1}{R_u x_4^3} \\left(\\frac{E_1}{R_u x_4} - 2\\right) $$\n$$ \\frac{\\partial^2 r_1}{\\partial x_1 \\partial x_2} = r_1 \\frac{a_1 b_1}{x_1 x_2} \\quad , \\quad \\frac{\\partial^2 r_1}{\\partial x_1 \\partial x_4} = r_1 \\frac{a_1 E_1}{x_1 R_u x_4^2} \\quad , \\quad \\frac{\\partial^2 r_1}{\\partial x_2 \\partial x_4} = r_1 \\frac{b_1 E_1}{x_2 R_u x_4^2} $$\nAll derivatives of $r_1$ with respect to $x_3$ (i.e., $Y_R$) are zero.\n\nThe second partial derivatives of $r_2$ are analogous:\n$$ \\frac{\\partial^2 r_2}{\\partial x_3^2} = r_2 \\frac{a_2(a_2-1)}{x_3^2} \\quad , \\quad \\frac{\\partial^2 r_2}{\\partial x_2^2} = r_2 \\frac{b_2(b_2-1)}{x_2^2} \\quad , \\quad \\frac{\\partial^2 r_2}{\\partial x_4^2} = r_2 \\frac{E_2}{R_u x_4^3} \\left(\\frac{E_2}{R_u x_4} - 2\\right) $$\n$$ \\frac{\\partial^2 r_2}{\\partial x_2 \\partial x_3} = r_2 \\frac{a_2 b_2}{x_2 x_3} \\quad , \\quad \\frac{\\partial^2 r_2}{\\partial x_3 \\partial x_4} = r_2 \\frac{a_2 E_2}{x_3 R_u x_4^2} \\quad , \\quad \\frac{\\partial^2 r_2}{\\partial x_2 \\partial x_4} = r_2 \\frac{b_2 E_2}{x_2 R_u x_4^2} $$\nAll derivatives of $r_2$ with respect to $x_1$ (i.e., $Y_F$) are zero.\n\nThe components of the total Hessian $\\mathbf{H}_{\\dot{\\omega}_c}$ are the sums of the corresponding components from $\\mathbf{H}_{r_1}$ and $\\mathbf{H}_{r_2}$. For example, $H_{22} = \\frac{\\partial^2 r_1}{\\partial x_2^2} + \\frac{\\partial^2 r_2}{\\partial x_2^2}$, while $H_{11} = \\frac{\\partial^2 r_1}{\\partial x_1^2}$ since $r_2$ does not depend on $x_1$.\n\nThe non-zero components of the Hessian matrix $H_{ij}$ are:\n- $H_{11} = r_1 \\frac{a_1(a_1-1)}{x_1^2}$\n- $H_{22} = r_1 \\frac{b_1(b_1-1)}{x_2^2} + r_2 \\frac{b_2(b_2-1)}{x_2^2}$\n- $H_{33} = r_2 \\frac{a_2(a_2-1)}{x_3^2}$\n- $H_{44} = r_1 \\frac{E_1}{R_u x_4^3}\\left(\\frac{E_1}{R_u x_4}-2\\right) + r_2 \\frac{E_2}{R_u x_4^3}\\left(\\frac{E_2}{R_u x_4}-2\\right)$\n- $H_{12} = r_1 \\frac{a_1 b_1}{x_1 x_2}$\n- $H_{13} = 0$\n- $H_{14} = r_1 \\frac{a_1 E_1}{x_1 R_u x_4^2}$\n- $H_{23} = r_2 \\frac{a_2 b_2}{x_2 x_3}$\n- $H_{24} = r_1 \\frac{b_1 E_1}{x_2 R_u x_4^2} + r_2 \\frac{b_2 E_2}{x_2 R_u x_4^2}$\n- $H_{34} = r_2 \\frac{a_2 E_2}{x_3 R_u x_4^2}$\n\nWith the Hessian matrix computed, we find the second-order approximation:\n$$\n\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}} = \\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}} + \\frac{1}{2}\\sum_{i=1}^4 \\sum_{j=1}^4 H_{ij} \\Sigma_{ij}\n$$\n\nFinally, the relative modeling bias, $b_{\\mathrm{rel}}$, quantifies the error of the naive closure model relative to the second-order approximation. It is defined as:\n$$\nb_{\\mathrm{rel}} = \\frac{\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}} - \\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}}{\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}} = \\frac{\\Delta}{\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}}\n$$\nThis procedure is applied to each test case to compute the required triplet of values: $(\\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{model}}, \\tilde{\\dot{\\omega}}_c^{\\,\\mathrm{approx}}, b_{\\mathrm{rel}})$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the final result.\n    \"\"\"\n    # Universal Gas Constant in J/(mol K)\n    Ru = 8.314\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"mech_params\": (5.0e6, 1.2e5, 1.0, 1.0, 2.5e7, 1.8e5, 1.0, 0.5), # A1, E1, a1, b1, A2, E2, a2, b2\n            \"means\": (0.02, 0.21, 0.001, 1500), # mu_YF, mu_YO2, mu_YR, mu_T\n            \"Sigma\": np.array([\n                [1.0e-6, -5.0e-7, 1.0e-8, 5.0e-2],\n                [-5.0e-7, 2.0e-6, -3.0e-8, -1.0e-1],\n                [1.0e-8, -3.0e-8, 5.0e-8, 0.0],\n                [5.0e-2, -1.0e-1, 0.0, 4.0e2]\n            ])\n        },\n        {\n            \"mech_params\": (4.0e6, 1.0e5, 1.0, 1.0, 1.5e7, 1.6e5, 1.0, 0.7),\n            \"means\": (0.001, 0.23, 0.0005, 1200),\n            \"Sigma\": np.array([\n                [1.0e-8, -2.0e-8, 0.0, 1.0e-2],\n                [-2.0e-8, 1.5e-6, -1.0e-8, -2.0e-2],\n                [0.0, -1.0e-8, 1.0e-8, 0.0],\n                [1.0e-2, -2.0e-2, 0.0, 2.25e2]\n            ])\n        },\n        {\n            \"mech_params\": (6.0e6, 1.4e5, 1.0, 1.2, 3.0e7, 2.0e5, 1.0, 0.6),\n            \"means\": (0.015, 0.20, 0.002, 2000),\n            \"Sigma\": np.array([\n                [5.0e-7, -3.0e-7, 3.0e-8, 1.0e-1],\n                [-3.0e-7, 2.0e-6, -1.0e-7, -1.5e-1],\n                [3.0e-8, -1.0e-7, 2.0e-7, 2.0e-1],\n                [1.0e-1, -1.5e-1, 2.0e-1, 9.0e2]\n            ])\n        },\n        {\n            \"mech_params\": (3.0e6, 0.9e5, 1.0, 1.0, 2.2e7, 1.7e5, 1.0, 0.5),\n            \"means\": (1.0e-5, 0.25, 1.0e-6, 1400),\n            \"Sigma\": np.array([\n                [1.0e-7, -1.0e-7, 5.0e-9, 2.0e-2],\n                [-1.0e-7, 1.0e-6, -2.0e-8, -3.0e-2],\n                [5.0e-9, -2.0e-8, 1.0e-8, 0.0],\n                [2.0e-2, -3.0e-2, 0.0, 4.0e2]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack data for the current case\n        A1, E1, a1, b1, A2, E2, a2, b2 = case[\"mech_params\"]\n        mu_YF, mu_YO2, mu_YR, mu_T = case[\"means\"]\n        Sigma = case[\"Sigma\"]\n        \n        # State vector of means: YF, YO2, YR, T\n        x = np.array([mu_YF, mu_YO2, mu_YR, mu_T])\n\n        # Step 1: Compute modeled source rate at mean values\n        exp_term1 = np.exp(-E1 / (Ru * x[3]))\n        r1_mean = A1 * (x[0]**a1) * (x[1]**b1) * exp_term1\n        \n        exp_term2 = np.exp(-E2 / (Ru * x[3]))\n        r2_mean = A2 * (x[2]**a2) * (x[1]**b2) * exp_term2\n\n        omega_model = r1_mean + r2_mean\n\n        # Step 2: Compute the Hessian matrix H\n        H = np.zeros((4, 4))\n        \n        # Diagonal components\n        H[0, 0] = r1_mean * a1 * (a1 - 1) / x[0]**2 if x[0] > 0 else 0\n        H[1, 1] = r1_mean * b1 * (b1 - 1) / x[1]**2 + r2_mean * b2 * (b2 - 1) / x[1]**2\n        H[2, 2] = r2_mean * a2 * (a2 - 1) / x[2]**2 if x[2] > 0 else 0\n        \n        term_T_r1 = r1_mean * (E1 / (Ru * x[3]**2))**2 - r1_mean * 2 * E1 / (Ru * x[3]**3)\n        term_T_r2 = r2_mean * (E2 / (Ru * x[3]**2))**2 - r2_mean * 2 * E2 / (Ru * x[3]**3)\n        H[3, 3] = term_T_r1 + term_T_r2\n\n        # Off-diagonal components\n        H[0, 1] = r1_mean * a1 * b1 / (x[0] * x[1]) if x[0] > 0 else 0\n        # H[0, 2] is 0\n        H[0, 3] = r1_mean * a1 * E1 / (x[0] * Ru * x[3]**2) if x[0] > 0 else 0\n        \n        H[1, 2] = r2_mean * a2 * b2 / (x[1] * x[2]) if x[2] > 0 else 0\n        H[1, 3] = r1_mean * b1 * E1 / (x[1] * Ru * x[3]**2) + r2_mean * b2 * E2 / (x[1] * Ru * x[3]**2)\n        \n        H[2, 3] = r2_mean * a2 * E2 / (x[2] * Ru * x[3]**2) if x[2] > 0 else 0\n\n        # Symmetrize the Hessian\n        H[1, 0] = H[0, 1]\n        H[2, 0] = H[0, 2]\n        H[3, 0] = H[0, 3]\n        H[2, 1] = H[1, 2]\n        H[3, 1] = H[1, 3]\n        H[3, 2] = H[2, 3]\n        \n        # Step 3: Compute the correction term and the approximate source rate\n        # tr(H * Sigma) simplifies to sum of element-wise product because Sigma is symmetric\n        correction = 0.5 * np.sum(H * Sigma)\n        omega_approx = omega_model + correction\n        \n        # Step 4: Compute the relative modeling bias\n        if omega_approx == 0:\n            # This case is unlikely; the bias would be undefined or infinite.\n            # For this problem, assume omega_approx is non-zero.\n            b_rel = 0.0 if correction == 0 else np.nan\n        else:\n            b_rel = correction / omega_approx\n            \n        results.extend([omega_model, omega_approx, b_rel])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.7g}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A successful machine learning model must not only be accurate but also generate physically plausible predictions. This final practice addresses the crucial concept of \"realizability\" in the context of Reynolds-stress modeling. You will compute the anisotropy tensor predicted by a hypothetical Tensor Basis Neural Network and analyze its eigenvalues to verify whether the model's output respects the fundamental constraints of turbulence physics, ensuring the predictions correspond to a valid physical state .",
            "id": "4037715",
            "problem": "Consider a reacting shear layer in a computational combustion simulation where the Reynolds-stress anisotropy tensor $b_{ij}$ is modeled using a Tensor Basis Neural Network (TBNN). The TBNN constructs $b_{ij}$ from the mean velocity gradient $A_{ij}$ through invariant scalar functions and a tensor basis built from the mean strain-rate tensor $S_{ij}$ and rotation-rate tensor $R_{ij}$. The foundational definitions are:\n- The strain-rate tensor $S_{ij}$ and the rotation-rate tensor $R_{ij}$ are defined by $S_{ij} = \\tfrac{1}{2}\\left(A_{ij} + A_{ji}\\right)$ and $R_{ij} = \\tfrac{1}{2}\\left(A_{ij} - A_{ji}\\right)$.\n- The anisotropy tensor $b_{ij}$ is symmetric and traceless by construction in the TBNN framework and is modeled as a linear combination of basis tensors $T^{(m)}_{ij}$ with scalar coefficient functions $g_{m}$ that depend on invariants of $S_{ij}$ and $R_{ij}$.\n\nFor an incompressible, planar, nonpremixed flame segment, suppose the local mean velocity gradient is\n$$\nA_{ij} = \\begin{pmatrix}\n0  2  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix}.\n$$\nThe TBNN uses the following three basis tensors constructed from $S_{ij}$ and $R_{ij}$:\n$$\nT^{(1)}_{ij} = S_{ij}, \\quad T^{(2)}_{ij} = S_{ik}R_{kj} - R_{ik}S_{kj}, \\quad T^{(3)}_{ij} = S_{ik}S_{kj} - \\tfrac{1}{3}\\,\\mathrm{tr}\\!\\left(S^{2}\\right)\\delta_{ij}.\n$$\nThe scalar invariants used by the network are $I_{1} = \\mathrm{tr}\\!\\left(S^{2}\\right)$ and $I_{2} = \\mathrm{tr}\\!\\left(R^{2}\\right)$. For this flow, the trained network prescribes the coefficient functions\n$$\ng_{1} = \\alpha_{1}\\,\\frac{I_{1}}{1 + |I_{2}|}, \\quad g_{2} = \\frac{\\alpha_{2}}{1 + I_{1}}, \\quad g_{3} = \\frac{\\alpha_{3}}{1 - I_{2}},\n$$\nwith constants $\\alpha_{1} = \\tfrac{3}{40}$, $\\alpha_{2} = \\tfrac{3}{10}$, and $\\alpha_{3} = \\tfrac{3}{4}$. The predicted anisotropy is\n$$\nb_{ij} = \\sum_{m=1}^{3} g_{m}\\,T^{(m)}_{ij}.\n$$\n\nTasks:\n1. Using the definitions above, compute $S_{ij}$, $R_{ij}$, and the invariants $I_{1}$ and $I_{2}$ for the given $A_{ij}$.\n2. Compute $g_{1}$, $g_{2}$, and $g_{3}$, then assemble $b_{ij}$ from the specified basis tensors.\n3. Compute the ordered eigenvalues $\\lambda_{1} \\ge \\lambda_{2} \\ge \\lambda_{3}$ of $b_{ij}$ and the barycentric coordinates\n$$\nC_{1\\mathrm{C}} = \\lambda_{1} - \\lambda_{2}, \\quad C_{2\\mathrm{C}} = 2\\left(\\lambda_{2} - \\lambda_{3}\\right), \\quad C_{3\\mathrm{C}} = 3\\lambda_{3} + 1.\n$$\nVerify that $C_{1\\mathrm{C}}$, $C_{2\\mathrm{C}}$, and $C_{3\\mathrm{C}}$ are all nonnegative and sum to $1$, ensuring realizability.\n\nReport as your final answer the realizability margin defined by\n$$\n\\Delta = \\min\\!\\left(C_{1\\mathrm{C}},\\,C_{2\\mathrm{C}},\\,C_{3\\mathrm{C}}\\right),\n$$\nexpressed as a single simplified closed-form analytic expression with no units. No rounding is required; provide the exact expression.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It presents a standard calculation within the field of turbulence modeling using a Tensor Basis Neural Network (TBNN). All necessary definitions and data are provided, and there are no internal contradictions.\n\nThe solution proceeds in a sequence of steps as requested by the problem statement.\n\nFirst, we compute the mean strain-rate tensor $S_{ij}$ and the mean rotation-rate tensor $R_{ij}$ from the given mean velocity gradient tensor $A_{ij}$.\nThe mean velocity gradient is given by\n$$\nA_{ij} = \\begin{pmatrix}\n0  2  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\nIts transpose is\n$$\nA_{ji} = \\begin{pmatrix}\n0  0  0 \\\\\n2  0  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\nThe strain-rate tensor $S_{ij}$ is the symmetric part of $A_{ij}$:\n$$\nS_{ij} = \\frac{1}{2}\\left(A_{ij} + A_{ji}\\right) = \\frac{1}{2}\\left( \\begin{pmatrix}\n0  2  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix} + \\begin{pmatrix}\n0  0  0 \\\\\n2  0  0 \\\\\n0  0  0\n\\end{pmatrix} \\right) = \\frac{1}{2}\\begin{pmatrix}\n0  2  0 \\\\\n2  0  0 \\\\\n0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\nThe rotation-rate tensor $R_{ij}$ is the anti-symmetric part of $A_{ij}$:\n$$\nR_{ij} = \\frac{1}{2}\\left(A_{ij} - A_{ji}\\right) = \\frac{1}{2}\\left( \\begin{pmatrix}\n0  2  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix} - \\begin{pmatrix}\n0  0  0 \\\\\n2  0  0 \\\\\n0  0  0\n\\end{pmatrix} \\right) = \\frac{1}{2}\\begin{pmatrix}\n0  2  0 \\\\\n-2  0  0 \\\\\n0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n0  1  0 \\\\\n-1  0  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\nNext, we compute the scalar invariants $I_{1} = \\mathrm{tr}(S^{2})$ and $I_{2} = \\mathrm{tr}(R^{2})$.\n$$\nS^{2} = S_{ik}S_{kj} = \\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  0\n\\end{pmatrix} \\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n$$\nI_{1} = \\mathrm{tr}(S^{2}) = 1 + 1 + 0 = 2\n$$\n$$\nR^{2} = R_{ik}R_{kj} = \\begin{pmatrix}\n0  1  0 \\\\\n-1  0  0 \\\\\n0  0  0\n\\end{pmatrix} \\begin{pmatrix}\n0  1  0 \\\\\n-1  0  0 \\\\\n0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n-1  0  0 \\\\\n0  -1  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n$$\nI_{2} = \\mathrm{tr}(R^{2}) = -1 + (-1) + 0 = -2\n$$\nNow, we compute the scalar coefficient functions $g_{1}$, $g_{2}$, and $g_{3}$ using the given constants $\\alpha_{1} = \\frac{3}{40}$, $\\alpha_{2} = \\frac{3}{10}$, and $\\alpha_{3} = \\frac{3}{4}$.\n$$\ng_{1} = \\alpha_{1}\\frac{I_{1}}{1 + |I_{2}|} = \\frac{3}{40} \\frac{2}{1 + |-2|} = \\frac{3}{40} \\frac{2}{3} = \\frac{1}{20}\n$$\n$$\ng_{2} = \\frac{\\alpha_{2}}{1 + I_{1}} = \\frac{3/10}{1 + 2} = \\frac{3/10}{3} = \\frac{1}{10}\n$$\n$$\ng_{3} = \\frac{\\alpha_{3}}{1 - I_{2}} = \\frac{3/4}{1 - (-2)} = \\frac{3/4}{3} = \\frac{1}{4}\n$$\nWe then compute the basis tensors $T^{(1)}_{ij}$, $T^{(2)}_{ij}$, and $T^{(3)}_{ij}$.\n$T^{(1)}_{ij} = S_{ij} = \\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  0\n\\end{pmatrix}$.\nFor $T^{(2)}_{ij} = S_{ik}R_{kj} - R_{ik}S_{kj}$:\n$$\nS R = \\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  0\n\\end{pmatrix} \\begin{pmatrix}\n0  1  0 \\\\\n-1  0  0 \\\\\n0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n-1  0  0 \\\\\n0  1  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n$$\nR S = \\begin{pmatrix}\n0  1  0 \\\\\n-1  0  0 \\\\\n0  0  0\n\\end{pmatrix} \\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n1  0  0 \\\\\n0  -1  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n$$\nT^{(2)}_{ij} = SR - RS = \\begin{pmatrix}\n-2  0  0 \\\\\n0  2  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\nFor $T^{(3)}_{ij} = S_{ik}S_{kj} - \\frac{1}{3}\\mathrm{tr}(S^{2})\\delta_{ij}$:\n$$\nT^{(3)}_{ij} = S^{2} - \\frac{1}{3}I_{1}\\delta_{ij} = \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  0\n\\end{pmatrix} - \\frac{2}{3}\\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix} = \\begin{pmatrix}\n1/3  0  0 \\\\\n0  1/3  0 \\\\\n0  0  -2/3\n\\end{pmatrix}\n$$\nWe assemble the anisotropy tensor $b_{ij} = \\sum_{m=1}^{3} g_{m}T^{(m)}_{ij}$:\n$$\nb_{ij} = \\frac{1}{20}\\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  0\n\\end{pmatrix} + \\frac{1}{10}\\begin{pmatrix}\n-2  0  0 \\\\\n0  2  0 \\\\\n0  0  0\n\\end{pmatrix} + \\frac{1}{4}\\begin{pmatrix}\n1/3  0  0 \\\\\n0  1/3  0 \\\\\n0  0  -2/3\n\\end{pmatrix}\n$$\n$$\nb_{ij} = \\begin{pmatrix}\n0 - \\frac{2}{10} + \\frac{1}{12}  \\frac{1}{20}  0 \\\\\n\\frac{1}{20}  0 + \\frac{2}{10} + \\frac{1}{12}  0 \\\\\n0  0  0 + 0 - \\frac{2}{12}\n\\end{pmatrix} = \\begin{pmatrix}\n-\\frac{1}{5} + \\frac{1}{12}  \\frac{1}{20}  0 \\\\\n\\frac{1}{20}  \\frac{1}{5} + \\frac{1}{12}  0 \\\\\n0  0  -\\frac{1}{6}\n\\end{pmatrix}\n$$\n$$\nb_{ij} = \\begin{pmatrix}\n\\frac{-12+5}{60}  \\frac{3}{60}  0 \\\\\n\\frac{3}{60}  \\frac{12+5}{60}  0 \\\\\n0  0  -\\frac{10}{60}\n\\end{pmatrix} = \\frac{1}{60}\\begin{pmatrix}\n-7  3  0 \\\\\n3  17  0 \\\\\n0  0  -10\n\\end{pmatrix}\n$$\nTo find the eigenvalues, we observe the matrix is block-diagonal. One eigenvalue is immediately $\\lambda = -\\frac{10}{60} = -\\frac{1}{6}$. The other two are the eigenvalues of the submatrix $M = \\frac{1}{60}\\begin{pmatrix} -7  3 \\\\ 3  17 \\end{pmatrix}$. Let the eigenvalues of $\\begin{pmatrix} -7  3 \\\\ 3  17 \\end{pmatrix}$ be $\\mu$. The characteristic equation is $(-7-\\mu)(17-\\mu) - (3)(3) = 0$, which simplifies to $\\mu^2 - 10\\mu - 119 - 9 = 0$, or $\\mu^2 - 10\\mu - 128 = 0$.\nUsing the quadratic formula:\n$$\n\\mu = \\frac{10 \\pm \\sqrt{(-10)^2 - 4(1)(-128)}}{2} = \\frac{10 \\pm \\sqrt{100 + 512}}{2} = \\frac{10 \\pm \\sqrt{612}}{2}\n$$\nSince $612 = 36 \\times 17$, $\\sqrt{612} = 6\\sqrt{17}$.\n$$\n\\mu = \\frac{10 \\pm 6\\sqrt{17}}{2} = 5 \\pm 3\\sqrt{17}\n$$\nThe eigenvalues of $b_{ij}$ are $\\lambda = \\mu/60$, so we have the set of eigenvalues $\\left\\{ \\frac{5+3\\sqrt{17}}{60}, \\frac{5-3\\sqrt{17}}{60}, -\\frac{10}{60} \\right\\}$.\nWe order them as $\\lambda_{1} \\ge \\lambda_{2} \\ge \\lambda_{3}$.\nSince $\\sqrt{17}  \\sqrt{25/9} = 5/3$, $3\\sqrt{17}  5$, so $\\frac{5-3\\sqrt{17}}{60}$ is negative.\nTo compare $\\frac{5-3\\sqrt{17}}{60}$ and $-\\frac{10}{60}$, we compare $5-3\\sqrt{17}$ and $-10$. This is equivalent to comparing $15$ and $3\\sqrt{17}$, or $5$ and $\\sqrt{17}$. Since $5^2 = 25  17$, we have $5  \\sqrt{17}$, which means $15  3\\sqrt{17}$, and thus $5-3\\sqrt{17}  -10$.\nThe ordered eigenvalues are:\n$$\n\\lambda_{1} = \\frac{5 + 3\\sqrt{17}}{60}, \\quad \\lambda_{2} = \\frac{5 - 3\\sqrt{17}}{60}, \\quad \\lambda_{3} = -\\frac{10}{60} = -\\frac{1}{6}\n$$\nNext, we compute the barycentric coordinates and verify realizability.\n$$\nC_{1\\mathrm{C}} = \\lambda_{1} - \\lambda_{2} = \\frac{5 + 3\\sqrt{17}}{60} - \\frac{5 - 3\\sqrt{17}}{60} = \\frac{6\\sqrt{17}}{60} = \\frac{\\sqrt{17}}{10}\n$$\n$$\nC_{2\\mathrm{C}} = 2\\left(\\lambda_{2} - \\lambda_{3}\\right) = 2\\left(\\frac{5 - 3\\sqrt{17}}{60} - \\frac{-10}{60}\\right) = 2\\left(\\frac{15 - 3\\sqrt{17}}{60}\\right) = \\frac{15 - 3\\sqrt{17}}{30} = \\frac{5 - \\sqrt{17}}{10}\n$$\n$$\nC_{3\\mathrm{C}} = 3\\lambda_{3} + 1 = 3\\left(-\\frac{1}{6}\\right) + 1 = -\\frac{1}{2} + 1 = \\frac{1}{2} = \\frac{5}{10}\n$$\nAll coordinates are non-negative: $C_{1\\mathrm{C}}  0$; $C_{2\\mathrm{C}}  0$ because $5  \\sqrt{17}$; $C_{3\\mathrm{C}}  0$.\nTheir sum is $C_{1\\mathrm{C}} + C_{2\\mathrm{C}} + C_{3\\mathrm{C}} = \\frac{\\sqrt{17}}{10} + \\frac{5 - \\sqrt{17}}{10} + \\frac{5}{10} = \\frac{\\sqrt{17} + 5 - \\sqrt{17} + 5}{10} = \\frac{10}{10} = 1$. The realizability conditions are satisfied.\n\nFinally, we find the realizability margin $\\Delta = \\min(C_{1\\mathrm{C}}, C_{2\\mathrm{C}}, C_{3\\mathrm{C}})$. We must compare $\\frac{\\sqrt{17}}{10}$, $\\frac{5 - \\sqrt{17}}{10}$, and $\\frac{5}{10}$.\nComparing $C_{1\\mathrm{C}}$ and $C_{2\\mathrm{C}}$: $\\sqrt{17}$ vs $5 - \\sqrt{17} \\implies 2\\sqrt{17}$ vs $5 \\implies \\sqrt{68}$ vs $\\sqrt{25}$. Thus $C_{1\\mathrm{C}}  C_{2\\mathrm{C}}$.\nComparing $C_{2\\mathrm{C}}$ and $C_{3\\mathrm{C}}$: $5 - \\sqrt{17}$ vs $5 \\implies -\\sqrt{17}$ vs $0$. Thus $C_{3\\mathrm{C}}  C_{2\\mathrm{C}}$.\nThe minimum value is $C_{2\\mathrm{C}}$.\n$$\n\\Delta = \\frac{5 - \\sqrt{17}}{10}\n$$",
            "answer": "$$\n\\boxed{\\frac{5 - \\sqrt{17}}{10}}\n$$"
        }
    ]
}