{
    "hands_on_practices": [
        {
            "introduction": "数据同化经常需要处理非线性模型。扩展卡尔曼滤波器 (Extended Kalman Filter, EKF) 是一种经典方法，它围绕当前的状态估计对模型进行线性化。本练习将指导您将 EKF 应用于燃烧学中的一个常见场景：根据非线性的化学发光信号估算温度和组分。您将推导基于阿伦尼乌斯定律 (Arrhenius law) 的观测算符的雅可比矩阵 (Jacobian)，并用它来执行 EKF 分析步骤，从而将理论与具体的计算任务联系起来。",
            "id": "4016225",
            "problem": "考虑一个用于计算燃烧学的化学反应流的离散化单室代理模型，其中化学发光信号被建模为与体积放热率成正比。假设在一种通用燃料和氧化剂之间发生单步、不可逆的放热反应。观测算子由无量纲化的阿伦尼乌斯形式和质量作用定律定义如下。设状态向量为 $x = [T, Y_F, Y_O]^T$，其中 $T$ 是无量纲温度，$Y_F$ 是无量纲燃料质量分数，$Y_O$ 是无量纲氧化剂质量分数。观测值（化学发光强度）为\n$$\nh(x) = y = \\int \\dot{q}(x)\\,\\mathrm{d}V = A \\exp\\!\\left(-\\frac{E}{R\\,T}\\right) Y_F Y_O,\n$$\n其中 $A$ 是一个无量纲指前因子（包含了恒定的密度和体积），$E$ 是无量纲活化能，$R$ 是无量纲气体常数。假设 $V = 1$，并且每次反应的恒定放热量也已无量纲化并包含在 $A$ 中。该代理模型源于经过充分验证的阿伦尼乌斯动力学，以及在自吸收可忽略不计的情况下化学发光与放热率成正比的假设。\n\n任务：\n- 从阿伦尼乌斯定律和质量作用速率表达式出发，推导观测算子 $h(x)$ 相对于状态 $(T, Y_F, Y_O)$ 的雅可比矩阵。\n- 在扩展卡尔曼滤波器（EKF）的分析（更新）步骤中，使用推导出的雅可比矩阵。该步骤针对一个标量测量值 $y^{\\mathrm{meas}}$ 和标量测量噪声方差 $R^{\\mathrm{meas}}$。EKF分析步骤使用 $h$ 在 $x^f$ 处的线性化结果，将预测均值 $x^f$ 和预测协方差 $P^f$ 更新为分析均值 $x^a$ 和分析协方差 $P^a$。\n\n假设：\n- 所有量均为无量纲。\n- 单室代理模型意味着空间积分可简化为与 $V=1$ 的乘积。\n- 气体密度被包含在 $A$ 中，且在质量作用定律中，两种反应物的化学计量指数均为1。\n\n你的程序必须：\n- 实现所推导的观测算子 $h(x)$ 及其雅可比矩阵 $H(x) = \\partial h/\\partial x$。\n- 为每个测试用例实现EKF分析步骤，以计算 $x^a$ 和 $P^a$。\n\n所需输出：\n- 对于每个测试用例，输出分析状态 $x^a = [T^a, Y_F^a, Y_O^a]$。\n- 最终的程序输出必须是单行文本，包含所有测试用例的分析状态的扁平化列表，按顺序排列，形式为用方括号括起来的逗号分隔列表，每个值都四舍五入到6位小数（例如，$[T_1^a,Y_{F,1}^a,Y_{O,1}^a,T_2^a,Y_{F,2}^a,Y_{O,2}^a,\\dots]$）。\n\n角度单位：不涉及角度。\n物理单位：所有变量均为无量纲。\n\n测试套件：\n- 用例1（正常路径）：\n  - $A = 2.0$, $E = 5.0$, $R = 1.0$。\n  - 预测均值 $x^f = [1.0, 0.2, 0.5]^T$。\n  - 预测协方差 $P^f = \\mathrm{diag}([1.0\\times 10^{-3}, 2.5\\times 10^{-4}, 2.5\\times 10^{-4}])$。\n  - 测量值 $y^{\\mathrm{meas}} = 0.0017$。\n  - 测量方差 $R^{\\mathrm{meas}} = 1.0\\times 10^{-4}$。\n- 用例2（边界：燃料接近零）：\n  - $A = 2.0$, $E = 5.0$, $R = 1.0$。\n  - 预测均值 $x^f = [1.0, 1.0\\times 10^{-6}, 0.3]^T$。\n  - 预测协方差 $P^f = \\mathrm{diag}([1.0\\times 10^{-3}, 1.0\\times 10^{-10}, 2.5\\times 10^{-4}])$。\n  - 测量值 $y^{\\mathrm{meas}} = 4.0\\times 10^{-9}$。\n  - 测量方差 $R^{\\mathrm{meas}} = 1.0\\times 10^{-8}$。\n- 用例3（边缘：高温）：\n  - $A = 2.0$, $E = 5.0$, $R = 1.0$。\n  - 预测均值 $x^f = [5.0, 0.4, 0.4]^T$。\n  - 预测协方差 $P^f = \\mathrm{diag}([1.0\\times 10^{-3}, 2.5\\times 10^{-4}, 2.5\\times 10^{-4}])$。\n  - 测量值 $y^{\\mathrm{meas}} = 0.11770000$。\n  - 测量方差 $R^{\\mathrm{meas}} = 1.0\\times 10^{-4}$。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,\\dots]$），其中每个结果是一个四舍五入到6位小数的浮点值，该列表是所有分析状态按测试用例顺序的串联。",
            "solution": "该问题被评估为有效。它在科学上基于化学动力学（阿伦尼乌斯定律，质量作用定律）和数据同化（扩展卡尔曼滤波器）的原理，问题是适定的，给出了完备的已知条件，并以客观、正式的语言表述。所提供的参数和条件是一致且充分的，足以推导出唯一、可验证的解。\n\n任务是为一个单室燃烧模型计算扩展卡尔曼滤波器（EKF）更新步骤的分析状态 $x^a$。这包含两个主要部分：首先，推导非线性观测算子的雅可比矩阵；其次，应用标准的EKF分析方程。\n\n设状态向量为 $x = [T, Y_F, Y_O]^T$，其中 $T$ 是无量纲温度，$Y_F$ 是无量纲燃料质量分数，$Y_O$ 是无量纲氧化剂质量分数。\n\n观测算子 $h(x)$ 对测量的化学发光强度进行建模，其形式如下：\n$$\nh(x) = A \\exp\\left(-\\frac{E}{RT}\\right) Y_F Y_O\n$$\n其中 $A$ 是指前因子，$E$ 是活化能，$R$ 是气体常数，均为无量纲形式。\n\n**1. 雅可比矩阵的推导**\n\n观测算子的雅可比矩阵 $H(x)$ 是一个 $1 \\times 3$ 的矩阵（一个行向量），定义为 $H(x) = \\frac{\\partial h}{\\partial x} = \\begin{bmatrix} \\frac{\\partial h}{\\partial T}  \\frac{\\partial h}{\\partial Y_F}  \\frac{\\partial h}{\\partial Y_O} \\end{bmatrix}$。我们计算每个偏导数。\n\n关于温度 $T$ 的偏导数使用链式法则求得：\n$$\n\\frac{\\partial h}{\\partial T} = \\frac{\\partial}{\\partial T} \\left( A \\exp\\left(-\\frac{E}{RT}\\right) Y_F Y_O \\right) = A Y_F Y_O \\cdot \\exp\\left(-\\frac{E}{RT}\\right) \\cdot \\frac{\\partial}{\\partial T}\\left(-\\frac{E}{RT}\\right)\n$$\n$$\n\\frac{\\partial h}{\\partial T} = \\left( A \\exp\\left(-\\frac{E}{RT}\\right) Y_F Y_O \\right) \\cdot \\left(\\frac{E}{RT^2}\\right) = h(x) \\frac{E}{RT^2}\n$$\n\n关于燃料质量分数 $Y_F$ 的偏导数是：\n$$\n\\frac{\\partial h}{\\partial Y_F} = \\frac{\\partial}{\\partial Y_F} \\left( A \\exp\\left(-\\frac{E}{RT}\\right) Y_F Y_O \\right) = A \\exp\\left(-\\frac{E}{RT}\\right) Y_O\n$$\n\n关于氧化剂质量分数 $Y_O$ 的偏导数是：\n$$\n\\frac{\\partial h}{\\partial Y_O} = \\frac{\\partial}{\\partial Y_O} \\left( A \\exp\\left(-\\frac{E}{RT}\\right) Y_F Y_O \\right) = A \\exp\\left(-\\frac{E}{RT}\\right) Y_F\n$$\n\n综合以上各项，观测算子的雅可比矩阵为：\n$$\nH(x) = \\left[ h(x) \\frac{E}{RT^2}, \\quad A \\exp\\left(-\\frac{E}{RT}\\right) Y_O, \\quad A \\exp\\left(-\\frac{E}{RT}\\right) Y_F \\right]\n$$\n\n**2. 扩展卡尔曼滤波器（EKF）分析步骤**\n\nEKF分析步骤使用一个测量值 $y^{\\mathrm{meas}}$ 及其方差 $R^{\\mathrm{meas}}$，将预测状态均值 $x^f$ 和协方差 $P^f$ 更新为分析状态均值 $x^a$ 和协方差 $P^a$。更新方程如下：\n\n设 $H$ 为在预测均值 $x^f$ 处求值的雅可比矩阵，即 $H = H(x^f)$。\n\na. **新息（或残差）：** 测量值与预测测量值之差。这是一个标量值 $\\nu$。\n$$\n\\nu = y^{\\mathrm{meas}} - h(x^f)\n$$\n\nb. **新息协方差：** 新息的方差。这也是一个标量 $S$。\n$$\nS = H P^f H^T + R^{\\mathrm{meas}}\n$$\n\nc. **卡尔曼增益：** 赋予新息的权重。它是一个 $3 \\times 1$ 的列向量 $K$。\n$$\nK = P^f H^T S^{-1} = \\frac{P^f H^T}{S}\n$$\n\nd. **分析均值：** 更新后的状态向量。\n$$\nx^a = x^f + K \\nu\n$$\n\ne. **分析协方差：** 更新后的协方差矩阵。虽然最终输出不需要它，但其公式为：\n$$\nP^a = (I - KH)P^f\n$$\n其中 $I$ 是 $3 \\times 3$ 的单位矩阵。\n\n每个测试用例的流程是将给定的 $A, E, R, x^f, P^f, y^{\\mathrm{meas}},$ 和 $R^{\\mathrm{meas}}$ 值代入这些方程，以计算分析状态 $x^a$。下面的程序实现了这个流程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the EKF analysis problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"params\": {\"A\": 2.0, \"E\": 5.0, \"R\": 1.0},\n            \"x_f\": np.array([1.0, 0.2, 0.5]),\n            \"P_f\": np.diag([1.0e-3, 2.5e-4, 2.5e-4]),\n            \"y_meas\": 0.0017,\n            \"R_meas\": 1.0e-4,\n        },\n        {\n            \"params\": {\"A\": 2.0, \"E\": 5.0, \"R\": 1.0},\n            \"x_f\": np.array([1.0, 1.0e-6, 0.3]),\n            \"P_f\": np.diag([1.0e-3, 1.0e-10, 2.5e-4]),\n            \"y_meas\": 4.0e-9,\n            \"R_meas\": 1.0e-8,\n        },\n        {\n            \"params\": {\"A\": 2.0, \"E\": 5.0, \"R\": 1.0},\n            \"x_f\": np.array([5.0, 0.4, 0.4]),\n            \"P_f\": np.diag([1.0e-3, 2.5e-4, 2.5e-4]),\n            \"y_meas\": 0.11770000,\n            \"R_meas\": 1.0e-4,\n        },\n    ]\n\n    all_results = []\n\n    def h_operator(x, A, E, R_const):\n        \"\"\"\n        Computes the observation operator h(x).\n        x = [T, Y_F, Y_O]\n        \"\"\"\n        T, Y_F, Y_O = x\n        if T == 0:  # Avoid division by zero or log of non-positive\n            return 0.0\n        return A * np.exp(-E / (R_const * T)) * Y_F * Y_O\n\n    def H_jacobian(x, A, E, R_const):\n        \"\"\"\n        Computes the Jacobian of the observation operator, H(x) = dh/dx.\n        x = [T, Y_F, Y_O]\n        \"\"\"\n        T, Y_F, Y_O = x\n        if T == 0:\n            return np.zeros(3)\n\n        exp_term = np.exp(-E / (R_const * T))\n        h_val = A * exp_term * Y_F * Y_O\n\n        # Partial derivatives\n        dh_dT = h_val * E / (R_const * T**2)\n        dh_dYF = A * exp_term * Y_O\n        dh_dYO = A * exp_term * Y_F\n\n        return np.array([dh_dT, dh_dYF, dh_dYO])\n\n    for case in test_cases:\n        # Extract parameters for the current case\n        params = case[\"params\"]\n        A, E, R_const = params[\"A\"], params[\"E\"], params[\"R\"]\n        x_f = case[\"x_f\"]\n        P_f = case[\"P_f\"]\n        y_meas = case[\"y_meas\"]\n        R_meas = case[\"R_meas\"]\n\n        # 1. Linearize observation model at the forecast mean x_f\n        # Predicted measurement h(x_f)\n        h_xf = h_operator(x_f, A, E, R_const)\n        \n        # Jacobian H at x_f. H is a 1x3 row vector (1D numpy array).\n        H = H_jacobian(x_f, A, E, R_const)\n\n        # 2. Compute Innovation\n        innovation = y_meas - h_xf\n\n        # 3. Compute Innovation Covariance (scalar)\n        # S = H @ P_f @ H^T + R_meas\n        # In numpy, for 1D H, H @ P_f @ H is equivalent to H P H^T\n        S = H @ P_f @ H + R_meas\n        \n        # 4. Compute Kalman Gain (3x1 vector)\n        # K = P_f @ H^T / S\n        K = (P_f @ H) / S\n        \n        # 5. Compute Analysis Mean (updated state)\n        # x_a = x_f + K * innovation\n        x_a = x_f + K * innovation\n\n        all_results.extend(x_a)\n\n    # Format the final output as a comma-separated list of floats rounded to 6 decimal places.\n    formatted_results = [f\"{val:.6f}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "尽管 EKF 直观易懂，但在强非线性系统中，其线性化会引入显著误差，而这正是燃烧化学的普遍特征。无迹卡尔曼滤波器 (Unscented Kalman Filter, UKF) 提供了一种更稳健、无需计算导数的替代方案。在本练习中，您将实现 UKF 的核心——无迹变换 (unscented transform)，通过一个非线性反应流模型来传播概率分布，从而为状态提供更精确的统计近似。这项实践展示了一种处理燃烧数据同化中固有的强非线性的强大方法。",
            "id": "4016267",
            "problem": "考虑一个化学反应气体的离散时间贝叶斯滤波框架，其中状态向量是二维的，$x = [T, Y_{\\mathrm{OH}}]^\\top$，$T$ 是温度（单位：开尔文），$Y_{\\mathrm{OH}}$ 是羟基自由基质量分数（无量纲）。状态演化和测量模型由下式给出：\n$$\nx_{k+1} = f(x_k) + w_k,\\quad z_{k+1} = H(x_{k+1}) + v_{k+1},\n$$\n其中 $w_k \\sim \\mathcal{N}(0, Q)$ 和 $v_{k+1} \\sim \\mathcal{N}(0, R)$ 分别是协方差矩阵为 $Q$ 和 $R$ 的零均值高斯噪声。确定性映射 $f$ 是通过一个简化的阿伦尼乌斯型源项（用于热量释放和自由基消耗）以及线性冷却来定义的：\n$$\n\\begin{aligned}\nT_{k+1} = T_k + \\Delta t\\left(\\frac{\\Delta h}{\\rho c_p} A \\exp\\!\\left(-\\frac{E_a}{R_u T_k}\\right) \\max(Y_{\\mathrm{OH},k}, 0) - k_c (T_k - T_{\\mathrm{env}}) \\right), \\\\\nY_{\\mathrm{OH},k+1} = \\max\\!\\Bigg(Y_{\\mathrm{OH},k} + \\Delta t\\left(- A_Y \\exp\\!\\left(-\\frac{E_a}{R_u T_k}\\right) \\max(Y_{\\mathrm{OH},k}, 0)\\right),\\, 0\\Bigg),\n\\end{aligned}\n$$\n其中 $\\Delta t$ 是时间步长（单位：秒），$\\Delta h/(\\rho c_p)$ 是有效温升系数（单位：开尔文），$A$ 和 $A_Y$ 是指前因子（单位：1/秒），$E_a$ 是活化能（单位：焦耳/摩尔），$R_u$ 是普适气体常数（单位：焦耳/摩尔·开尔文），$k_c$ 是线性冷却系数（单位：1/秒），$T_{\\mathrm{env}}$ 是环境温度（单位：开尔文）。$H$ 映射模拟了温度的测量以及一个与温度和羟基质量分数平方根的乘积成比例的光学信号：\n$$\nH(x) = \\begin{bmatrix}\nT \\\\\ns_0\\, T\\, \\sqrt{\\max(Y_{\\mathrm{OH}}, 0)}\n\\end{bmatrix},\n$$\n其中 $s_0$ 是一个光学比例因子（无量纲）。此设定代表一个燃烧数据同化场景，其中羟基自由基质量分数被用作火焰锋面附近反应进程的代理指标，并在基于物理的项中被约束为非负。\n\n假设当前状态估计为高斯分布 $x_k \\sim \\mathcal{N}(\\mu_x, P_x)$，其均值为 $\\mu_x \\in \\mathbb{R}^2$，协方差为 $P_x \\in \\mathbb{R}^{2\\times 2}$，且噪声 $Q \\in \\mathbb{R}^{2\\times 2}$、$R \\in \\mathbb{R}^{2\\times 2}$ 是给定的半正定矩阵。使用无迹卡尔曼滤波器（UKF）的sigma点构造方法来近似预测状态分布 $x_{k+1}$ 和预测测量分布 $z_{k+1}$。具体步骤如下：\n\n1. 对于 $n=2$，使用缩放参数 $\\alpha$、$\\beta$ 和 $\\kappa$ 构造 $2n+1$ 个sigma点：\n   - 计算 $ \\lambda = \\alpha^2 (n + \\kappa) - n $ 和 $ \\gamma = \\sqrt{n + \\lambda} $。\n   - 计算 $P_x$ 的矩阵平方根，例如通过 Cholesky 分解 $P_x = LL^\\top$，其中 $L \\in \\mathbb{R}^{2\\times 2}$ 是下三角矩阵。\n   - 定义sigma点\n     $$\n     \\chi^{(0)} = \\mu_x, \\quad \\chi^{(i)} = \\mu_x + \\gamma\\, L_{:,i}, \\quad \\chi^{(i+n)} = \\mu_x - \\gamma\\, L_{:,i} \\quad \\text{for } i=1,\\dots,n.\n     $$\n   - 定义权重\n     $$\n     W_0^{(m)} = \\frac{\\lambda}{n + \\lambda}, \\quad W_0^{(c)} = \\frac{\\lambda}{n + \\lambda} + (1 - \\alpha^2 + \\beta), \\quad W_i^{(m)} = W_i^{(c)} = \\frac{1}{2(n + \\lambda)} \\text{ for } i=1,\\dots,2n.\n     $$\n2. 将所有sigma点通过 $f$ 传播以获得变换后的点 $\\mathcal{Y}^{(i)} = f(\\chi^{(i)})$，其中 $i=0,\\dots,2n$，并计算预测状态均值和协方差\n   $$\n   \\mu_{x^+} = \\sum_{i=0}^{2n} W_i^{(m)} \\mathcal{Y}^{(i)}, \\quad P_{x^+} = \\sum_{i=0}^{2n} W_i^{(c)} \\left(\\mathcal{Y}^{(i)} - \\mu_{x^+}\\right)\\left(\\mathcal{Y}^{(i)} - \\mu_{x^+}\\right)^\\top + Q.\n   $$\n3. 将预测状态的sigma点 $\\mathcal{Y}^{(i)}$ 通过 $H$ 传播以获得 $\\mathcal{Z}^{(i)} = H(\\mathcal{Y}^{(i)})$，并计算预测测量均值和协方差\n   $$\n   \\mu_{z} = \\sum_{i=0}^{2n} W_i^{(m)} \\mathcal{Z}^{(i)}, \\quad S_{z} = \\sum_{i=0}^{2n} W_i^{(c)} \\left(\\mathcal{Z}^{(i)} - \\mu_{z}\\right)\\left(\\mathcal{Z}^{(i)} - \\mu_{z}\\right)^\\top + R.\n   $$\n通过在 $f$ 和 $H$ 中将任何具有负 $Y_{\\mathrm{OH}}$ 的sigma点视为 $0$ 来强制物理真实性。\n\n除非在每个测试用例中另有规定，否则使用以下常数：$R_u = 8.314$ (J/mol-K)，$E_a = 1.2\\times 10^5$ (J/mol)，$A = 1.0\\times 10^6$ (s$^{-1}$)，$A_Y = 1.0\\times 10^6$ (s$^{-1}$)，$\\Delta h/(\\rho c_p) = 3.0\\times 10^4$ (K)，$k_c = 50.0$ (s$^{-1}$)，$T_{\\mathrm{env}} = 300.0$ (K)，$s_0 = 200.0$ (无量纲)。不涉及角度；温度必须以开尔文表示，$Y_{\\mathrm{OH}}$ 是无量纲的。\n\n测试套件：\n- 用例1（典型火焰条件）：\n  - $\\mu_x = [1700.0,\\, 1.0\\times 10^{-4}]^\\top$ (开尔文, 无量纲)\n  - $P_x = \\begin{bmatrix} 25.0^2  0 \\\\ 0  (1.0\\times 10^{-5})^2 \\end{bmatrix}$\n  - $Q = \\begin{bmatrix} 0.05^2  0 \\\\ 0  (1.0\\times 10^{-6})^2 \\end{bmatrix}$\n  - $R = \\begin{bmatrix} 0.5^2  0 \\\\ 0  10.0^2 \\end{bmatrix}$\n  - $\\alpha=0.75$, $\\beta=2.0$, $\\kappa=0.0$, $\\Delta t = 1.0\\times 10^{-4}$ s\n- 用例2（近环境、自由基耗尽边界）：\n  - $\\mu_x = [300.0,\\, 1.0\\times 10^{-8}]^\\top$\n  - $P_x = \\begin{bmatrix} 5.0^2  0 \\\\ 0  (5.0\\times 10^{-9})^2 \\end{bmatrix}$\n  - $Q = \\begin{bmatrix} 0.02^2  0 \\\\ 0  (1.0\\times 10^{-9})^2 \\end{bmatrix}$\n  - $R = \\begin{bmatrix} 1.0^2  0 \\\\ 0  0.5^2 \\end{bmatrix}$\n  - $\\alpha=0.6$, $\\beta=2.0$, $\\kappa=-1.0$, $\\Delta t = 1.0\\times 10^{-4}$ s\n- 用例3（高温、高反应性、小$\\alpha$边缘行为）：\n  - $\\mu_x = [2200.0,\\, 5.0\\times 10^{-4}]^\\top$\n  - $P_x = \\begin{bmatrix} 10.0^2  0 \\\\ 0  (5.0\\times 10^{-5})^2 \\end{bmatrix}$\n  - $Q = \\begin{bmatrix} 0.1^2  0 \\\\ 0  (2.0\\times 10^{-6})^2 \\end{bmatrix}$\n  - $R = \\begin{bmatrix} 0.2^2  0 \\\\ 0  15.0^2 \\end{bmatrix}$\n  - $\\alpha=0.001$, $\\beta=2.0$, $\\kappa=3.0$, $\\Delta t = 5.0\\times 10^{-5}$ s\n\n您的任务是编写一个完整、可运行的程序，该程序为每个测试用例，从 $(\\mu_x, P_x)$ 构造无迹卡尔曼滤波器的sigma点，将它们通过 $f$ 和 $H$ 进行传播，并使用上述权重计算相应的预测状态均值 $\\mu_{x^+}$ 和协方差 $P_{x^+}$，以及预测测量均值 $\\mu_z$ 和协方差 $S_z$，其中 $Q$ 和 $R$作为加性协方差包括在内。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个列表的列表形式的结果，每个测试用例对应一个子列表，不含空格。每个子列表必须按此顺序包含十个浮点数：\n$$\n[\\mu_{x^+}[0],\\, \\mu_{x^+}[1],\\, P_{x^+}[0,0],\\, P_{x^+}[0,1],\\, P_{x^+}[1,1],\\, \\mu_{z}[0],\\, \\mu_{z}[1],\\, S_{z}[0,0],\\, S_{z}[0,1],\\, S_{z}[1,1]].\n$$\n例如，输出格式应如下所示\n$$\n[[\\text{c1\\_muT},\\text{c1\\_muY},\\text{c1\\_P00},\\text{c1\\_P01},\\text{c1\\_P11},\\text{c1\\_z0},\\text{c1\\_z1},\\text{c1\\_S00},\\text{c1\\_S01},\\text{c1\\_S11}],\\ [\\dots],\\ [\\dots]]\n$$\n输出中的温度必须以开尔文为单位，$Y_{\\mathrm{OH}}$ 是无量纲的。不使用角度。所有数值均以原始小数形式表示（不带百分号）。",
            "solution": "其基本原理始于隐马尔可夫模型的离散时间贝叶斯滤波框架。时间 $k$ 的状态分布由高斯分布 $\\mathcal{N}(\\mu_x, P_x)$ 概括。通过 $f$ 的非线性传播和通过 $H$ 的测量映射由基于化学动力学和传热学的物理模型决定。对于高度非线性的动力学和测量，扩展卡尔曼滤波器（EKF）通过雅可比矩阵进行局部线性化，但由于截断高阶项而存在精度问题。相比之下，无迹卡尔曼滤波器（UKF）采用称为无迹变换的确定性采样方法，该方法无需显式求导，即可捕捉高斯分布的均值和协方差，精度高达三阶泰勒展开。\n\n基本依据：离散时间 Chapman–Kolmogorov 方程通过以下方式传播先验密度\n$$\np(x_{k+1}) = \\int p(x_{k+1}\\mid x_k) p(x_k)\\, dx_k,\n$$\n预测测量分布为\n$$\np(z_{k+1}) = \\int p(z_{k+1}\\mid x_{k+1}) p(x_{k+1})\\, dx_{k+1}.\n$$\n当 $x_k \\sim \\mathcal{N}(\\mu_x, P_x)$ 且过程和测量噪声为加性高斯噪声 $w_k \\sim \\mathcal{N}(0, Q)$ 和 $v_{k+1}\\sim \\mathcal{N}(0, R)$ 时，UKF 使用一组确定性选择的sigma点来近似这些积分，这些sigma点能够捕捉高斯测度的二阶统计量，并通过非线性映射 $f$ 和 $H$ 进行传播。\n\n无迹变换构造：对于一个 $n$ 维状态，计算缩放参数\n$$\n\\lambda = \\alpha^2 (n + \\kappa) - n,\n$$\n其中 $\\alpha\\in(0,1]$ 控制sigma点在均值周围的散布范围，$\\beta$ 编码分布的先验知识（对于高斯分布，$\\beta=2$ 是最优的），$\\kappa$ 提供额外的自由度（通常 $\\kappa=0$ 或 $\\kappa=3-n$）。定义\n$$\n\\gamma = \\sqrt{n + \\lambda}.\n$$\n需要 $P_x$ 的矩阵平方根；对于正定的 $P_x$，Cholesky 分解可提供 $P_x = LL^\\top$。构造 $2n+1$ 个sigma点：\n$$\n\\chi^{(0)} = \\mu_x,\\quad \\chi^{(i)} = \\mu_x + \\gamma\\, L_{:,i},\\quad \\chi^{(i+n)} = \\mu_x - \\gamma\\, L_{:,i},\\quad i=1,\\dots,n.\n$$\n定义用于均值和协方差的权重为\n$$\nW_0^{(m)} = \\frac{\\lambda}{n + \\lambda}, \\quad W_0^{(c)} = \\frac{\\lambda}{n + \\lambda} + (1 - \\alpha^2 + \\beta), \\quad W_i^{(m)} = W_i^{(c)} = \\frac{1}{2(n + \\lambda)},\\quad i=1,\\dots,2n.\n$$\n这些权重确保sigma点具有高斯分布的正确前两阶矩。\n\n物理状态和测量映射：受燃烧启发的非线性模型 $f$ 使用阿伦尼乌斯型反应速率来模拟热量释放和自由基消耗。温度更新为\n$$\nT_{k+1} = T_k + \\Delta t\\left(\\frac{\\Delta h}{\\rho c_p} A \\exp\\!\\left(-\\frac{E_a}{R_u T_k}\\right) \\max(Y_{\\mathrm{OH},k},0) - k_c (T_k - T_{\\mathrm{env}}) \\right),\n$$\n这反映了反应进程产生的热量（按有效温升系数 $\\Delta h/(\\rho c_p)$ 缩放）和向环境温度 $T_{\\mathrm{env}}$ 的线性冷却。羟基自由基质量分数根据以下公式减少\n$$\nY_{\\mathrm{OH},k+1} = \\max\\!\\left(Y_{\\mathrm{OH},k} + \\Delta t\\left(- A_Y \\exp\\!\\left(-\\frac{E_a}{R_u T_k}\\right) \\max(Y_{\\mathrm{OH},k}, 0)\\right), 0\\right),\n$$\n其中 max 函数确保非负性，因为负质量分数是非物理的。\n\n测量模型 $H$ 反映了直接温度传感和一个与 $T \\sqrt{Y_{\\mathrm{OH}}}$ 成比例的光学信号，\n$$\nH(x) = \\begin{bmatrix}\nT \\\\\ns_0\\, T\\, \\sqrt{\\max(Y_{\\mathrm{OH}}, 0)}\n\\end{bmatrix},\n$$\n其中 $\\sqrt{\\cdot}$ 应用于 $\\max(Y_{\\mathrm{OH}},0)$，以避免当sigma点因协方差散布而产生负 $Y_{\\mathrm{OH}}$ 时出现复数值。\n\nUKF预测步骤：\n1. 从 $(\\mu_x, P_x)$ 生成sigma点 $\\{\\chi^{(i)}\\}_{i=0}^{2n}$ 及其权重 $W_i^{(m)}, W_i^{(c)}$。\n2. 将sigma点通过 $f$ 传播以获得 $\\mathcal{Y}^{(i)} = f(\\chi^{(i)})$。\n3. 计算预测状态均值和协方差：\n$$\n\\mu_{x^+} = \\sum_{i=0}^{2n} W_i^{(m)} \\mathcal{Y}^{(i)},\\quad\nP_{x^+} = \\sum_{i=0}^{2n} W_i^{(c)} \\left(\\mathcal{Y}^{(i)} - \\mu_{x^+}\\right)\\left(\\mathcal{Y}^{(i)} - \\mu_{x^+}\\right)^\\top + Q.\n$$\n4. 将预测状态的sigma点通过 $H$ 传播：$\\mathcal{Z}^{(i)} = H(\\mathcal{Y}^{(i)})$。\n5. 计算预测测量均值和协方差：\n$$\n\\mu_z = \\sum_{i=0}^{2n} W_i^{(m)} \\mathcal{Z}^{(i)},\\quad\nS_z = \\sum_{i=0}^{2n} W_i^{(c)} \\left(\\mathcal{Z}^{(i)} - \\mu_{z}\\right)\\left(\\mathcal{Z}^{(i)} - \\mu_{z}\\right)^\\top + R.\n$$\n\n算法注意事项：\n- Cholesky分解要求 $P_x$ 是对称正定矩阵；所提供的测试用例满足此条件。\n- 非线性项 $\\exp(-E_a/(R_u T))$ 具有强烈的温度依赖性；在低温 $T$ 下，它抑制反应，而在高温 $T$ 下，它加速热量释放和自由基消耗，这与化学动力学一致。\n- 在 $f$ 和 $H$ 内部将 $Y_{\\mathrm{OH}}$ 截断为非负值，保持了热量释放和信号生成的物理真实性，并防止了如对负数取平方根之类的未定义操作。\n- 加性协方差 $Q$ 和 $R$ 在无迹协方差计算之后加入，反映了过程和测量噪声。\n\n程序中的实现计划：\n- 将 $f$ 和 $H$ 定义为由物理常数和 $\\Delta t$ 参数化的函数。\n- 使用 $(\\alpha, \\beta, \\kappa)$ 实现带权重的sigma点生成。\n- 按照规定实现 $f$ 和 $H$ 的无迹变换步骤。\n- 对于每个测试用例，计算并收集输出\n$$\n[\\mu_{x^+}[0],\\, \\mu_{x^+}[1],\\, P_{x^+}[0,0],\\, P_{x^+}[0,1],\\, P_{x^+}[1,1],\\, \\mu_{z}[0],\\, \\mu_{z}[1],\\, S_{z}[0,0],\\, S_{z}[0,1],\\, S_{z}[1,1]],\n$$\n其中温度以开尔文为单位，$Y_{\\mathrm{OH}}$ 无量纲。\n- 将三个测试用例的聚合列表的列表打印为单行，无空格，并遵循指定的输出格式。\n\n这种方法通过UKF将物理燃烧模型与数据同化相结合，比线性化更准确地捕捉非线性效应，并为状态和测量提供统计上一致的均值和协方差预测。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef cholesky_lower(P):\n    # Ensure symmetry before Cholesky to avoid numerical issues\n    P_sym = 0.5 * (P + P.T)\n    return np.linalg.cholesky(P_sym)\n\ndef generate_sigma_points(mu, P, alpha, beta, kappa):\n    n = mu.shape[0]\n    lambda_ = alpha**2 * (n + kappa) - n\n    gamma = np.sqrt(n + lambda_)\n    L = cholesky_lower(P)\n    sigma_points = np.zeros((2 * n + 1, n))\n    sigma_points[0] = mu\n    for i in range(n):\n        sigma_points[1 + i] = mu + gamma * L[:, i]\n        sigma_points[1 + n + i] = mu - gamma * L[:, i]\n    Wm = np.full(2 * n + 1, 1.0 / (2.0 * (n + lambda_)))\n    Wc = np.copy(Wm)\n    Wm[0] = lambda_ / (n + lambda_)\n    Wc[0] = Wm[0] + (1.0 - alpha**2 + beta)\n    return sigma_points, Wm, Wc\n\ndef f_map(x, params):\n    # Unpack state\n    T, Y = float(x[0]), float(x[1])\n    # Unpack parameters\n    dt = params[\"dt\"]\n    Ru = params[\"Ru\"]\n    Ea = params[\"Ea\"]\n    A = params[\"A\"]\n    AY = params[\"AY\"]\n    dh_over_rho_cp = params[\"dh_over_rho_cp\"]\n    kc = params[\"kc\"]\n    Tenv = params[\"Tenv\"]\n    # Physical clipping for Y\n    Y_nonneg = max(Y, 0.0)\n    # Arrhenius term\n    # Prevent division by zero or negative T; T should be > 0 in Kelvin\n    T_eff = max(T, 1e-6)\n    arr = np.exp(-Ea / (Ru * T_eff))\n    # Temperature update\n    dTdt = dh_over_rho_cp * A * arr * Y_nonneg - kc * (T - Tenv)\n    T_next = T + dt * dTdt\n    # OH mass fraction update with nonnegativity\n    dYdt = -AY * arr * Y_nonneg\n    Y_next = Y + dt * dYdt\n    if Y_next  0.0:\n        Y_next = 0.0\n    return np.array([T_next, Y_next])\n\ndef H_map(x, params):\n    T, Y = float(x[0]), float(x[1])\n    s0 = params[\"s0\"]\n    Y_nonneg = max(Y, 0.0)\n    signal = s0 * T * np.sqrt(Y_nonneg)\n    return np.array([T, signal])\n\ndef unscented_transform(mu, P, Q, f, f_params, alpha, beta, kappa):\n    # Generate sigma points\n    sigma_points, Wm, Wc = generate_sigma_points(mu, P, alpha, beta, kappa)\n    # Propagate through f\n    n_sigma = sigma_points.shape[0]\n    y_sigma = np.zeros_like(sigma_points)\n    for i in range(n_sigma):\n        y_sigma[i] = f(sigma_points[i], f_params)\n    # Predicted mean\n    mu_pred = np.sum(Wm[:, None] * y_sigma, axis=0)\n    # Predicted covariance\n    diff = y_sigma - mu_pred\n    P_pred = np.zeros_like(P)\n    for i in range(n_sigma):\n        d = diff[i][:, None]\n        P_pred += Wc[i] * (d @ d.T)\n    P_pred += Q\n    return mu_pred, P_pred, y_sigma, Wm, Wc\n\ndef measurement_transform(y_sigma, Wm, Wc, R, H, h_params):\n    n_sigma = y_sigma.shape[0]\n    z_sigma = np.zeros((n_sigma, 2))\n    for i in range(n_sigma):\n        z_sigma[i] = H(y_sigma[i], h_params)\n    # Predicted measurement mean\n    z_mean = np.sum(Wm[:, None] * z_sigma, axis=0)\n    # Predicted measurement covariance\n    zdiff = z_sigma - z_mean\n    S = np.zeros((2, 2))\n    for i in range(n_sigma):\n        d = zdiff[i][:, None]\n        S += Wc[i] * (d @ d.T)\n    S += R\n    return z_mean, S\n\ndef solve():\n    # Define test cases parameters\n    test_cases = []\n\n    # Constants common baseline\n    base_params = {\n        \"Ru\": 8.314,              # J/mol-K\n        \"Ea\": 1.2e5,              # J/mol\n        \"A\": 1.0e6,               # 1/s\n        \"AY\": 1.0e6,              # 1/s\n        \"dh_over_rho_cp\": 3.0e4,  # K\n        \"kc\": 50.0,               # 1/s\n        \"Tenv\": 300.0,            # K\n        \"s0\": 200.0               # dimensionless\n    }\n\n    # Case 1\n    case1 = {\n        \"mu\": np.array([1700.0, 1.0e-4]),\n        \"P\": np.array([[25.0**2, 0.0],\n                       [0.0, (1.0e-5)**2]]),\n        \"Q\": np.array([[0.05**2, 0.0],\n                       [0.0, (1.0e-6)**2]]),\n        \"R\": np.array([[0.5**2, 0.0],\n                       [0.0, 10.0**2]]),\n        \"alpha\": 0.75,\n        \"beta\": 2.0,\n        \"kappa\": 0.0,\n        \"dt\": 1.0e-4\n    }\n    # Case 2\n    case2 = {\n        \"mu\": np.array([300.0, 1.0e-8]),\n        \"P\": np.array([[5.0**2, 0.0],\n                       [0.0, (5.0e-9)**2]]),\n        \"Q\": np.array([[0.02**2, 0.0],\n                       [0.0, (1.0e-9)**2]]),\n        \"R\": np.array([[1.0**2, 0.0],\n                       [0.0, 0.5**2]]),\n        \"alpha\": 0.6,\n        \"beta\": 2.0,\n        \"kappa\": -1.0,\n        \"dt\": 1.0e-4\n    }\n    # Case 3\n    case3 = {\n        \"mu\": np.array([2200.0, 5.0e-4]),\n        \"P\": np.array([[10.0**2, 0.0],\n                       [0.0, (5.0e-5)**2]]),\n        \"Q\": np.array([[0.1**2, 0.0],\n                       [0.0, (2.0e-6)**2]]),\n        \"R\": np.array([[0.2**2, 0.0],\n                       [0.0, 15.0**2]]),\n        \"alpha\": 0.001,\n        \"beta\": 2.0,\n        \"kappa\": 3.0,\n        \"dt\": 5.0e-5\n    }\n\n    test_cases.append(case1)\n    test_cases.append(case2)\n    test_cases.append(case3)\n\n    results = []\n    for case in test_cases:\n        # Merge case dt into params\n        params = dict(base_params)\n        params[\"dt\"] = case[\"dt\"]\n\n        mu = case[\"mu\"]\n        P = case[\"P\"]\n        Q = case[\"Q\"]\n        R = case[\"R\"]\n        alpha = case[\"alpha\"]\n        beta = case[\"beta\"]\n        kappa = case[\"kappa\"]\n\n        # UKF prediction\n        mu_pred, P_pred, y_sigma, Wm, Wc = unscented_transform(mu, P, Q, f_map, params, alpha, beta, kappa)\n        # Measurement prediction\n        z_mean, S = measurement_transform(y_sigma, Wm, Wc, R, H_map, params)\n\n        # Collect results: [mu_T, mu_Y, P00, P01, P11, z0, z1, S00, S01, S11]\n        res = [\n            float(mu_pred[0]), float(mu_pred[1]),\n            float(P_pred[0, 0]), float(P_pred[0, 1]), float(P_pred[1, 1]),\n            float(z_mean[0]), float(z_mean[1]),\n            float(S[0, 0]), float(S[0, 1]), float(S[1, 1])\n        ]\n        results.append(res)\n\n    # Format output as a single line list of lists with no spaces\n    def format_nested(list_of_lists):\n        def fmt_num(x):\n            # Use general format for compactness while preserving precision\n            return f\"{x:.12g}\"\n        inner = []\n        for sub in list_of_lists:\n            inner.append(\"[\" + \",\".join(fmt_num(x) for x in sub) + \"]\")\n        return \"[\" + \",\".join(inner) + \"]\"\n\n    print(format_nested(results))\n\nsolve()\n```"
        },
        {
            "introduction": "在应用如卡尔曼滤波器等标准数据同化方法时，一个关键挑战是这些方法假设状态是无约束且服从高斯分布的。然而，燃烧过程中的物理量，例如组分质量分数，必须为正值且总和为一。本练习介绍了一种强制施加这些物理约束的有效技术，即将有约束的物理变量转换到一个更适合高斯假设的无约束空间中。您将推导并应用加性对数比 (Additive Log-Ratio, ALR) 变换的逆变换，这是确保您的数据同化结果在热力学上一致且具有物理意义的关键一步。",
            "id": "4016180",
            "problem": "考虑在计算燃烧模拟中的一个可压缩反应混合物，其物种质量分数为 $Y_{k}$，其中 $k \\in \\{1,\\dots,N\\}$。根据定义，每个物种的质量分数满足 $Y_{k}  0$ 且混合物守恒约束为 $\\sum_{k=1}^{N} Y_{k} = 1$。在反应流的数据同化中，状态估计通常在无约束的欧几里得控制向量上执行，以便应用高斯更新（例如，在集合卡尔曼滤波器（EnKF）中）。为了在分析中确保热力学一致性，当将分析结果映射回物理空间时，质量分数必须保持为正且归一化。\n\n假设物种质量分数在控制向量中通过一个相对于参考物种索引 $r \\in \\{1,\\dots,N\\}$ 定义的正向变换来表示：\n$$\n\\eta_{k} = \\ln\\!\\left(\\frac{Y_{k}}{Y_{r}}\\right) \\quad \\text{对于所有 } k \\in \\{1,\\dots,N\\} \\text{ 且 } k \\neq r,\n$$\n并注意 $Y_{r}$ 由守恒约束隐式确定。假设分析步骤为所有 $k \\neq r$ 产生了更新后的控制变量 $\\hat{\\eta}_{k} \\in \\mathbb{R}$。\n\n从物理约束 $Y_{k}  0$ 和 $\\sum_{k=1}^{N} Y_{k} = 1$ 以及上述正向变换的定义出发，推导出从 $\\{\\hat{\\eta}_{k}\\}$ 返回 $\\{Y_{k}\\}$ 的逆映射，同时严格执行正定性与和为一的约束。然后，对于一个包含 $N = 3$ 且物种集合为 $\\{\\mathrm{H_{2}}, \\mathrm{O_{2}}, \\mathrm{H_{2}O}\\}$ 的氢-氧-水三物种混合物，选择参考物种 $r$ 为 $\\mathrm{H_{2}O}$。给定分析值 $\\hat{\\eta}_{\\mathrm{H_{2}}} = 0.7$ 和 $\\hat{\\eta}_{\\mathrm{O_{2}}} = -1.2$，计算物理空间质量分数 $Y_{\\mathrm{H_{2}}}$。将您的最终答案表示为无量纲分数，并四舍五入至四位有效数字。",
            "solution": "在继续之前，对问题进行验证。\n\n### 步骤1：提取已知条件\n- 物种质量分数：$Y_{k}$，其中 $k \\in \\{1, \\dots, N\\}$。\n- 物理约束：对于所有 $k$，$Y_{k}  0$，且 $\\sum_{k=1}^{N} Y_{k} = 1$。\n- 正向变换（控制变量）：$\\eta_{k} = \\ln\\left(\\frac{Y_{k}}{Y_{r}}\\right)$，对于所有 $k \\in \\{1,\\dots,N\\}$ 且 $k \\neq r$，其中 $r$ 是参考物种索引。\n- 更新后的控制变量：$\\hat{\\eta}_{k} \\in \\mathbb{R}$，对于所有 $k \\neq r$。\n- 具体案例：\n    - 物种数量：$N = 3$。\n    - 物种集合：$\\{\\mathrm{H_{2}}, \\mathrm{O_{2}}, \\mathrm{H_{2}O}\\}$。\n    - 参考物种：$r$ 对应于 $\\mathrm{H_{2}O}$。\n    - 分析值：$\\hat{\\eta}_{\\mathrm{H_{2}}} = 0.7$ 和 $\\hat{\\eta}_{\\mathrm{O_{2}}} = -1.2$。\n- 任务：\n    1. 推导从 $\\{\\hat{\\eta}_{k}\\}$ 返回 $\\{Y_{k}\\}$ 的逆映射，同时执行物理约束。\n    2. 计算给定具体案例的物理空间质量分数 $Y_{\\mathrm{H_{2}}}$。\n    3. 将最终答案四舍五入至四位有效数字。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题描述了加性对数比（Additive Log-Ratio, ALR）变换，这是成分数据分析中一种标准且严谨的方法，用于将受约束的单纯形（如质量分数）映射到无约束的欧几里得空间。其在计算燃烧领域数据同化中的应用是科学合理且相关的。\n- **适定性**：该问题是适定的。给出了正向变换，任务是找到其逆变换，这是一个数学上确定的问题。所提供的数值足以得到唯一解。\n- **客观性**：该问题使用精确、客观的数学和科学语言进行陈述。\n- **完整性与一致性**：提供了所有必要的定义、约束和数据。定义内部一致，不会导致矛盾。\n- **真实性**：背景和方法在计算科学与工程领域是符合实际的。\n\n### 步骤3：结论与行动\n该问题有效，因为它具有科学依据、适定且完整。将进行求解。\n\n### 求解推导\n\n目标是推导从更新后的控制变量 $\\{\\hat{\\eta}_{k}\\}$ 到物理质量分数 $\\{Y_{k}\\}$ 的逆映射。推导过程必须确保物理约束 $Y_{k}  0$ 和 $\\sum_{i=1}^{N} Y_{i} = 1$ 得到满足。\n\n对于 $k \\neq r$，给出的正向变换为：\n$$\n\\hat{\\eta}_{k} = \\ln\\left(\\frac{Y_{k}}{Y_{r}}\\right)\n$$\n为了找到逆映射，我们首先用 $Y_{r}$ 来表示 $Y_{k}$。对两边取指数：\n$$\n\\exp(\\hat{\\eta}_{k}) = \\frac{Y_{k}}{Y_{r}}\n$$\n$$\nY_{k} = Y_{r} \\exp(\\hat{\\eta}_{k}) \\quad \\text{对于 } k \\neq r\n$$\n该方程为 $N-1$ 个非参考物种的质量分数提供了表达式。参考物种的质量分数 $Y_{r}$ 仍然未知。为了求出它，我们使用和为一的约束：\n$$\n\\sum_{i=1}^{N} Y_{i} = 1\n$$\n我们可以将求和分为参考物种和其他物种：\n$$\nY_{r} + \\sum_{k \\neq r} Y_{k} = 1\n$$\n现在，将 $Y_{k}$ 的表达式代入求和式中：\n$$\nY_{r} + \\sum_{k \\neq r} \\left(Y_{r} \\exp(\\hat{\\eta}_{k})\\right) = 1\n$$\n从左侧提出因子 $Y_{r}$：\n$$\nY_{r} \\left(1 + \\sum_{k \\neq r} \\exp(\\hat{\\eta}_{k})\\right) = 1\n$$\n求解 $Y_{r}$ 得到参考物种的逆映射：\n$$\nY_{r} = \\frac{1}{1 + \\sum_{j \\neq r} \\exp(\\hat{\\eta}_{j})}\n$$\n为清晰起见，求和索引已更改为 $j$。这个 $Y_{r}$ 的表达式保证了正定性，因为指数函数始终为正，使得分母严格大于 $1$。\n\n现在我们可以通过将 $Y_{r}$ 的表达式代回 $Y_{k} = Y_{r} \\exp(\\hat{\\eta}_{k})$ 来找到任何非参考物种 $Y_{k}$ ($k \\neq r$) 的通用表达式：\n$$\nY_{k} = \\frac{\\exp(\\hat{\\eta}_{k})}{1 + \\sum_{j \\neq r} \\exp(\\hat{\\eta}_{j})} \\quad \\text{对于 } k \\neq r\n$$\n这些推导出的 $Y_r$ 和 $Y_k$ 的逆映射固有地满足了物理约束。正定性（$Y_k  0$）得到了保证，因为指数函数始终为正。和为一的约束通过构造得到满足：\n$$\n\\sum_{i=1}^{N} Y_{i} = Y_{r} + \\sum_{k \\neq r} Y_{k} = \\frac{1}{1 + \\sum_{j \\neq r} \\exp(\\hat{\\eta}_{j})} + \\sum_{k \\neq r} \\frac{\\exp(\\hat{\\eta}_{k})}{1 + \\sum_{j \\neq r} \\exp(\\hat{\\eta}_{j})} = \\frac{1 + \\sum_{k \\neq r} \\exp(\\hat{\\eta}_{k})}{1 + \\sum_{j \\neq r} \\exp(\\hat{\\eta}_{j})} = 1\n$$\n\n### 具体案例应用\n\n给定一个三物种混合物，$N=3$，物种为 $\\{\\mathrm{H_{2}}, \\mathrm{O_{2}}, \\mathrm{H_{2}O}\\}$。\n参考物种为 $\\mathrm{H_{2}O}$，所以 $r$ 对应于 $\\mathrm{H_{2}O}$。\n非参考物种索引为 $k \\in \\{\\mathrm{H_{2}}, \\mathrm{O_{2}}\\}$。\n给定的分析空间值为 $\\hat{\\eta}_{\\mathrm{H_{2}}} = 0.7$ 和 $\\hat{\\eta}_{\\mathrm{O_{2}}} = -1.2$。\n\n我们需要计算氢的质量分数 $Y_{\\mathrm{H_{2}}}$。由于 $\\mathrm{H_{2}}$ 不是参考物种，我们使用 $k \\neq r$ 时 $Y_k$ 的公式：\n$$\nY_{\\mathrm{H_{2}}} = \\frac{\\exp(\\hat{\\eta}_{\\mathrm{H_{2}}})}{1 + \\sum_{j \\in \\{\\mathrm{H_{2}}, \\mathrm{O_{2}}\\}} \\exp(\\hat{\\eta}_{j})}\n$$\n分母中的求和是针对所有非参考物种：\n$$\n\\sum_{j \\in \\{\\mathrm{H_{2}}, \\mathrm{O_{2}}\\}} \\exp(\\hat{\\eta}_{j}) = \\exp(\\hat{\\eta}_{\\mathrm{H_{2}}}) + \\exp(\\hat{\\eta}_{\\mathrm{O_{2}}})\n$$\n代入给定值：\n$$\nY_{\\mathrm{H_{2}}} = \\frac{\\exp(0.7)}{1 + \\exp(0.7) + \\exp(-1.2)}\n$$\n现在，我们计算数值：\n$$\n\\exp(0.7) \\approx 2.013752707\n$$\n$$\n\\exp(-1.2) \\approx 0.3011942119\n$$\n将这些值代入 $Y_{\\mathrm{H_{2}}}$ 的表达式中：\n$$\nY_{\\mathrm{H_{2}}} \\approx \\frac{2.013752707}{1 + 2.013752707 + 0.3011942119} = \\frac{2.013752707}{3.314946919}\n$$\n$$\nY_{\\mathrm{H_{2}}} \\approx 0.60747444\n$$\n问题要求将答案四舍五入至四位有效数字。\n$$\nY_{\\mathrm{H_{2}}} \\approx 0.6075\n$$\n这是 $\\mathrm{H_2}$ 质量分数的最终数值答案。",
            "answer": "$$\n\\boxed{0.6075}\n$$"
        }
    ]
}