{
    "hands_on_practices": [
        {
            "introduction": "在燃烧模拟中，许多可观测的物理量（如化学发光）与系统状态（如温度和组分浓度）之间呈非线性关系。扩展卡尔曼滤波器（EKF）是通过在当前状态估计附近对非线性模型进行线性化，来处理这种非线性问题的经典方法。本练习  将指导你亲手推导一个基于物理的观测算子的雅可比矩阵，并应用EKF的更新方程，这是将理论应用于实践的关键一步。",
            "id": "4016225",
            "problem": "考虑一个在计算燃烧学中使用的化学反应流的离散化单网格代理模型，其中化学发光信号被建模为与体积放热率成正比。假设一种通用燃料和氧化剂之间发生单步、不可逆的放热反应。观测算子由无量纲化的阿伦尼乌斯形式和质量作用定律定义如下。设状态向量为 $x = [T, Y_F, Y_O]^T$，其中 $T$ 是无量纲温度，$Y_F$ 是燃料的无量纲质量分数，$Y_O$ 是氧化剂的无量纲质量分数。观测值（化学发光强度）为\n$$\nh(x) = y = \\int \\dot{q}(x)\\,\\mathrm{d}V = A \\exp\\!\\left(-\\frac{E}{R\\,T}\\right) Y_F Y_O,\n$$\n其中 $A$ 是一个无量纲指前因子（吸收了常数密度和体积），$E$ 是一个无量纲活化能，$R$ 是一个无量纲气体常数。假设 $V = 1$，并且每次反应的恒定放热也已无量纲化并包含在 $A$ 中。该代理模型源于经过充分检验的阿伦尼乌斯动力学，以及在自吸收可忽略不计时化学发光与放热率成正比的原理。\n\n任务：\n- 从阿伦尼乌斯定律和质量作用速率表达式出发，推导观测算子 $h(x)$ 相对于状态 $(T, Y_F, Y_O)$ 的雅可比矩阵。\n- 在扩展卡尔曼滤波器 (EKF) 分析（更新）步骤中，使用推导出的雅可比矩阵，对一个标量测量值 $y^{\\mathrm{meas}}$（其标量测量噪声方差为 $R^{\\mathrm{meas}}$）进行处理。EKF 分析步骤利用 $h$ 在 $x^f$ 处的线性化，将预测均值 $x^f$ 和预测协方差 $P^f$ 更新为分析均值 $x^a$ 和分析协方差 $P^a$。\n\n假设：\n- 所有量均为无量纲。\n- 单网格代理模型意味着空间积分简化为与 $V=1$ 的乘积。\n- 气体密度被吸收到 $A$ 中，且在质量作用定律中，两种反应物的化学计量指数均为 $1$。\n\n您的程序必须：\n- 实现所推导的观测算子 $h(x)$ 及其雅可比矩阵 $H(x) = \\partial h/\\partial x$。\n- 实现 EKF 分析步骤，为每个测试用例计算 $x^a$ 和 $P^a$。\n\n所需输出：\n- 对于每个测试用例，输出分析状态 $x^a = [T^a, Y_F^a, Y_O^a]$。\n- 最终程序输出必须是单行文本，其中包含所有测试用例的分析状态按顺序组成的扁平化列表，以逗号分隔，并用方括号括起来，每个值四舍五入到 $6$ 位小数（例如，$[T_1^a,Y_{F,1}^a,Y_{O,1}^a,T_2^a,Y_{F,2}^a,Y_{O,2}^a,\\dots]$）。\n\n角度单位：不涉及角度。\n物理单位：所有变量均为无量纲。\n\n测试套件：\n- 用例 $1$ (正常情况):\n  - $A = 2.0$, $E = 5.0$, $R = 1.0$。\n  - 预测均值 $x^f = [1.0, 0.2, 0.5]^T$。\n  - 预测协方差 $P^f = \\mathrm{diag}([1.0\\times 10^{-3}, 2.5\\times 10^{-4}, 2.5\\times 10^{-4}])$。\n  - 测量值 $y^{\\mathrm{meas}} = 0.0017$。\n  - 测量方差 $R^{\\mathrm{meas}} = 1.0\\times 10^{-4}$。\n- 用例 $2$ (边界情况：燃料接近零):\n  - $A = 2.0$, $E = 5.0$, $R = 1.0$。\n  - 预测均值 $x^f = [1.0, 1.0\\times 10^{-6}, 0.3]^T$。\n  - 预测协方差 $P^f = \\mathrm{diag}([1.0\\times 10^{-3}, 1.0\\times 10^{-10}, 2.5\\times 10^{-4}])$。\n  - 测量值 $y^{\\mathrm{meas}} = 4.0\\times 10^{-9}$。\n  - 测量方差 $R^{\\mathrm{meas}} = 1.0\\times 10^{-8}$。\n- 用例 $3$ (边缘情况：高温):\n  - $A = 2.0$, $E = 5.0$, $R = 1.0$。\n  - 预测均值 $x^f = [5.0, 0.4, 0.4]^T$。\n  - 预测协方差 $P^f = \\mathrm{diag}([1.0\\times 10^{-3}, 2.5\\times 10^{-4}, 2.5\\times 10^{-4}])$。\n  - 测量值 $y^{\\mathrm{meas}} = 0.11770000$。\n  - 测量方差 $R^{\\mathrm{meas}} = 1.0\\times 10^{-4}$。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔并用方括号括起来的结果列表（例如，$[result_1,result_2,\\dots]$），每个结果是一个四舍五入到 $6$ 位小数的浮点值，并且该列表是所有分析状态按测试用例顺序的串接。",
            "solution": "该问题被评估为有效。它在科学上基于化学动力学（阿伦尼乌斯定律、质量作用定律）和数据同化（扩展卡尔曼滤波器）的原理，问题陈述清晰，给定了完整的已知条件，并且以客观、形式化的语言表述。所提供的参数和条件是一致且充分的，足以推导出唯一、可验证的解。\n\n任务是为一个单网格燃烧模型计算扩展卡尔曼滤波器 (EKF) 更新步骤的分析状态 $x^a$。这主要包括两个部分：首先，推导非线性观测算子的雅可比矩阵；其次，应用标准的 EKF 分析方程。\n\n设状态向量为 $x = [T, Y_F, Y_O]^T$，其中 $T$ 是无量纲温度，$Y_F$ 是无量纲燃料质量分数，$Y_O$ 是无量纲氧化剂质量分数。\n\n观测算子 $h(x)$ 用于模拟测量的化学发光强度，其表达式为：\n$$\nh(x) = A \\exp\\left(-\\frac{E}{RT}\\right) Y_F Y_O\n$$\n其中 $A$ 是指前因子，$E$ 是活化能，$R$ 是气体常数，均为无量纲形式。\n\n**1. 雅可比矩阵的推导**\n\n观测算子的雅可比矩阵 $H(x)$ 是一个 $1 \\times 3$ 的矩阵（一个行向量），定义为 $H(x) = \\frac{\\partial h}{\\partial x} = \\begin{bmatrix} \\frac{\\partial h}{\\partial T} & \\frac{\\partial h}{\\partial Y_F} & \\frac{\\partial h}{\\partial Y_O} \\end{bmatrix}$。我们计算每个偏导数。\n\n关于温度 $T$ 的偏导数使用链式法则求得：\n$$\n\\frac{\\partial h}{\\partial T} = \\frac{\\partial}{\\partial T} \\left( A \\exp\\left(-\\frac{E}{RT}\\right) Y_F Y_O \\right) = A Y_F Y_O \\cdot \\exp\\left(-\\frac{E}{RT}\\right) \\cdot \\frac{\\partial}{\\partial T}\\left(-\\frac{E}{RT}\\right)\n$$\n$$\n\\frac{\\partial h}{\\partial T} = \\left( A \\exp\\left(-\\frac{E}{RT}\\right) Y_F Y_O \\right) \\cdot \\left(\\frac{E}{RT^2}\\right) = h(x) \\frac{E}{RT^2}\n$$\n\n关于燃料质量分数 $Y_F$ 的偏导数为：\n$$\n\\frac{\\partial h}{\\partial Y_F} = \\frac{\\partial}{\\partial Y_F} \\left( A \\exp\\left(-\\frac{E}{RT}\\right) Y_F Y_O \\right) = A \\exp\\left(-\\frac{E}{RT}\\right) Y_O\n$$\n\n关于氧化剂质量分数 $Y_O$ 的偏导数为：\n$$\n\\frac{\\partial h}{\\partial Y_O} = \\frac{\\partial}{\\partial Y_O} \\left( A \\exp\\left(-\\frac{E}{RT}\\right) Y_F Y_O \\right) = A \\exp\\left(-\\frac{E}{RT}\\right) Y_F\n$$\n\n综合这些，观测算子的雅可比矩阵为：\n$$\nH(x) = \\left[ h(x) \\frac{E}{RT^2}, \\quad A \\exp\\left(-\\frac{E}{RT}\\right) Y_O, \\quad A \\exp\\left(-\\frac{E}{RT}\\right) Y_F \\right]\n$$\n\n**2. 扩展卡尔曼滤波器 (EKF) 分析步骤**\n\nEKF 分析步骤使用一个测量值 $y^{\\mathrm{meas}}$（其方差为 $R^{\\mathrm{meas}}$）将预测状态均值 $x^f$ 和协方差 $P^f$ 更新为分析状态均值 $x^a$ 和协方差 $P^a$。更新方程如下：\n\n令 $H$ 为在预测均值 $x^f$ 处计算的雅可比矩阵，即 $H = H(x^f)$。\n\na. **新息（或残差）：** 测量值与预测测量值之间的差。这是一个标量值 $\\nu$。\n$$\n\\nu = y^{\\mathrm{meas}} - h(x^f)\n$$\n\nb. **新息协方差：** 新息的方差。这也是一个标量 $S$。\n$$\nS = H P^f H^T + R^{\\mathrm{meas}}\n$$\n\nc. **卡尔曼增益：** 赋予新息的权重。它是一个 $3 \\times 1$ 的列向量 $K$。\n$$\nK = P^f H^T S^{-1} = \\frac{P^f H^T}{S}\n$$\n\nd. **分析均值：** 更新后的状态向量。\n$$\nx^a = x^f + K \\nu\n$$\n\ne. **分析协方差：** 更新后的协方差矩阵。虽然最终输出不需要，但其公式为：\n$$\nP^a = (I - KH)P^f\n$$\n其中 $I$ 是 $3 \\times 3$ 的单位矩阵。\n\n对于每个测试用例，流程是将给定的 $A, E, R, x^f, P^f, y^{\\mathrm{meas}}$ 和 $R^{\\mathrm{meas}}$ 值代入这些方程，以计算分析状态 $x^a$。以下程序实现了这一流程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the EKF analysis problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"params\": {\"A\": 2.0, \"E\": 5.0, \"R\": 1.0},\n            \"x_f\": np.array([1.0, 0.2, 0.5]),\n            \"P_f\": np.diag([1.0e-3, 2.5e-4, 2.5e-4]),\n            \"y_meas\": 0.0017,\n            \"R_meas\": 1.0e-4,\n        },\n        {\n            \"params\": {\"A\": 2.0, \"E\": 5.0, \"R\": 1.0},\n            \"x_f\": np.array([1.0, 1.0e-6, 0.3]),\n            \"P_f\": np.diag([1.0e-3, 1.0e-10, 2.5e-4]),\n            \"y_meas\": 4.0e-9,\n            \"R_meas\": 1.0e-8,\n        },\n        {\n            \"params\": {\"A\": 2.0, \"E\": 5.0, \"R\": 1.0},\n            \"x_f\": np.array([5.0, 0.4, 0.4]),\n            \"P_f\": np.diag([1.0e-3, 2.5e-4, 2.5e-4]),\n            \"y_meas\": 0.11770000,\n            \"R_meas\": 1.0e-4,\n        },\n    ]\n\n    all_results = []\n\n    def h_operator(x, A, E, R_const):\n        \"\"\"\n        Computes the observation operator h(x).\n        x = [T, Y_F, Y_O]\n        \"\"\"\n        T, Y_F, Y_O = x\n        if T == 0:  # Avoid division by zero or log of non-positive\n            return 0.0\n        return A * np.exp(-E / (R_const * T)) * Y_F * Y_O\n\n    def H_jacobian(x, A, E, R_const):\n        \"\"\"\n        Computes the Jacobian of the observation operator, H(x) = dh/dx.\n        x = [T, Y_F, Y_O]\n        \"\"\"\n        T, Y_F, Y_O = x\n        if T == 0:\n            return np.zeros(3)\n\n        exp_term = np.exp(-E / (R_const * T))\n        h_val = A * exp_term * Y_F * Y_O\n\n        # Partial derivatives\n        dh_dT = h_val * E / (R_const * T**2)\n        dh_dYF = A * exp_term * Y_O\n        dh_dYO = A * exp_term * Y_F\n\n        return np.array([dh_dT, dh_dYF, dh_dYO])\n\n    for case in test_cases:\n        # Extract parameters for the current case\n        params = case[\"params\"]\n        A, E, R_const = params[\"A\"], params[\"E\"], params[\"R\"]\n        x_f = case[\"x_f\"]\n        P_f = case[\"P_f\"]\n        y_meas = case[\"y_meas\"]\n        R_meas = case[\"R_meas\"]\n\n        # 1. Linearize observation model at the forecast mean x_f\n        # Predicted measurement h(x_f)\n        h_xf = h_operator(x_f, A, E, R_const)\n        \n        # Jacobian H at x_f. H is a 1x3 row vector (1D numpy array).\n        H = H_jacobian(x_f, A, E, R_const)\n\n        # 2. Compute Innovation\n        innovation = y_meas - h_xf\n\n        # 3. Compute Innovation Covariance (scalar)\n        # S = H @ P_f @ H^T + R_meas\n        # In numpy, for 1D H, H @ P_f @ H is equivalent to H P H^T\n        S = H @ P_f @ H + R_meas\n        \n        # 4. Compute Kalman Gain (3x1 vector)\n        # K = P_f @ H^T / S\n        K = (P_f @ H) / S\n        \n        # 5. Compute Analysis Mean (updated state)\n        # x_a = x_f + K * innovation\n        x_a = x_f + K * innovation\n\n        all_results.extend(x_a)\n\n    # Format the final output as a comma-separated list of floats rounded to 6 decimal places.\n    formatted_results = [f\"{val:.6f}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "并非所有燃烧过程都遵循高斯分布。例如，光子计数等离散事件通常服从泊松分布，这使得基于高斯假设的卡尔曼滤波器不再适用。本练习  将介绍粒子滤波器，这是一种功能强大的序贯蒙特卡洛方法，它不依赖于高斯假设，能够处理任意的概率分布。你将学习其核心的权重更新步骤，并分析在实践中至关重要的粒子退化问题。",
            "id": "4016190",
            "problem": "考虑将用于数据同化（DA）的序贯重要性重采样粒子方法进行单步更新，该方法应用于具有非线性化学发光观测的计算燃烧学。设隐藏的燃烧状态由一组粒子 $\\{x_n^{(j)}\\}_{j=1}^N$ 表示，其中每个 $x_n^{(j)}$ 包含温度 $T_n^{(j)}$（单位为开尔文）和一个无量纲的反应进度变量 $q_n^{(j)}$。在时间索引 $n$ 的观测是在积分时间 $\\Delta t$（单位为秒）内由光电倍增管测得的光子计数 $y_n$。假设对于给定状态，来自化学发光的期望光子计数由一个 Arrhenius 型强度模型给出：\n$$\n\\lambda(x) = \\kappa\\, q^\\alpha \\exp\\!\\left(-\\frac{E_a}{R\\,T}\\right),\n$$\n其中 $\\kappa$ 的单位是每秒，$q$ 是无量纲的，$E_a$ 是活化能（单位为焦耳每摩尔），$R$ 是通用气体常数（单位为焦耳每摩尔每开尔文），$T$ 是温度（单位为开尔文）。在积分区间内的平均光子计数为\n$$\n\\mu(x) = \\Delta t \\,\\lambda(x).\n$$\n假设一个非高斯观测模型，其中观测计数 $y_n$ 从均值为 $\\mu(x_n)$ 的泊松分布中抽样，因此似然函数为\n$$\np(y_n \\mid x_n) = \\mathrm{Poisson}\\big(\\mu(x_n)\\big).\n$$\n从贝叶斯法则和重要性采样出发，使用等于先验马尔可夫转移（自助选择）的提议分布，推导粒子权重更新，并将其在一个程序中实现。该程序给定一组先前的归一化权重 $\\{w_{n-1}^{(j)}\\}$ 和当前的粒子 $\\{x_n^{(j)}\\}$，计算更新后的归一化权重 $\\{w_n^{(j)}\\}$ 和有效样本量（ESS）。有效样本量（ESS）定义为\n$$\nN_{\\mathrm{eff}} = \\frac{1}{\\sum_{j=1}^N \\left(w_n^{(j)}\\right)^2}.\n$$\n然后，通过声明一个退化标志来分析退化现象，如果 $N_{\\mathrm{eff}}  \\beta N$，则该标志为真，其中 $\\beta$ 是一个固定分数，$N$ 是粒子数。\n\n科学和计算要求：\n- 使用物理上合理的 Arrhenius 形式，其中常数 $R = 8.314$ 焦耳每摩尔每开尔文，每个测试用例会给出 $E_a$ 和 $\\kappa$ 以及指数 $\\alpha$。\n- 光子计数 $y_n$ 是一个整数计数（无量纲）。温度 $T$ 必须以开尔文为单位，时间 $\\Delta t$ 必须以秒为单位。任何涉及 $T$ 和 $\\Delta t$ 的表达式都必须使用这些单位。\n- 使用泊松概率质量函数计算似然。为确保数值稳定性，在对数域中执行似然计算，然后对权重进行归一化。对整数 $y$，使用伽马函数恒等式 $\\log(y!) = \\log\\Gamma(y+1)$。\n\n您的程序必须为以下测试套件实现权重更新和 ESS 计算，每个测试由参数元组 $(\\{T_n^{(j)}\\}, \\{q_n^{(j)}\\}, \\{w_{n-1}^{(j)}\\}, y_n, \\Delta t, \\kappa, E_a, \\alpha, \\beta)$ 定义：\n\n- 测试 1（正常路径，中等计数）：\n    - $N = 5$\n    - $\\{T_n^{(j)}\\} = [1950, 2000, 2050, 1900, 2100]$ 开尔文\n    - $\\{q_n^{(j)}\\} = [0.85, 0.92, 0.88, 0.80, 0.95]$ (无量纲)\n    - $\\{w_{n-1}^{(j)}\\} = [0.2, 0.2, 0.2, 0.2, 0.2]$ (已归一化)\n    - $y_n = 200$ (计数)\n    - $\\Delta t = 5.0\\times 10^{-4}$ 秒\n    - $\\kappa = 3.0\\times 10^{9}$ 每秒\n    - $E_a = 1.5\\times 10^{5}$ 焦耳每摩尔\n    - $\\alpha = 1.0$\n    - $\\beta = 0.5$\n- 测试 2（倾斜的先验权重，较高计数）：\n    - $N = 8$\n    - $\\{T_n^{(j)}\\} = [1800, 1850, 1900, 1950, 2000, 2050, 2100, 2150]$ 开尔文\n    - $\\{q_n^{(j)}\\} = [0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00, 0.98]$\n    - $\\{w_{n-1}^{(j)}\\} = [0.05, 0.05, 0.10, 0.10, 0.20, 0.20, 0.15, 0.15]$ (已归一化)\n    - $y_n = 320$ (计数)\n    - $\\Delta t = 5.0\\times 10^{-4}$ 秒\n    - $\\kappa = 3.0\\times 10^{9}$ 每秒\n    - $E_a = 1.5\\times 10^{5}$ 焦耳每摩尔\n    - $\\alpha = 1.0$\n    - $\\beta = 0.5$\n- 测试 3（边界情况，零计数）：\n    - $N = 6$\n    - $\\{T_n^{(j)}\\} = [1600, 1650, 1700, 1750, 1800, 1850]$ 开尔文\n    - $\\{q_n^{(j)}\\} = [0.40, 0.45, 0.50, 0.55, 0.60, 0.65]$\n    - $\\{w_{n-1}^{(j)}\\} = [1/6, 1/6, 1/6, 1/6, 1/6, 1/6]$ (已归一化)\n    - $y_n = 0$ (计数)\n    - $\\Delta t = 5.0\\times 10^{-4}$ 秒\n    - $\\kappa = 3.0\\times 10^{9}$ 每秒\n    - $E_a = 1.5\\times 10^{5}$ 焦耳每摩尔\n    - $\\alpha = 1.0$\n    - $\\beta = 0.5$\n- 测试 4（通过更大的活化能实现更强的非线性）：\n    - $N = 7$\n    - $\\{T_n^{(j)}\\} = [1900, 1950, 2000, 2050, 2100, 2150, 2200]$ 开尔文\n    - $\\{q_n^{(j)}\\} = [0.80, 0.82, 0.85, 0.88, 0.90, 0.92, 0.95]$\n    - $\\{w_{n-1}^{(j)}\\} = [1/7, 1/7, 1/7, 1/7, 1/7, 1/7, 1/7]$ (已归一化)\n    - $y_n = 20$ (计数)\n    - $\\Delta t = 5.0\\times 10^{-4}$ 秒\n    - $\\kappa = 3.0\\times 10^{9}$ 每秒\n    - $E_a = 2.0\\times 10^{5}$ 焦耳每摩尔\n    - $\\alpha = 1.0$\n    - $\\beta = 0.5$\n\n程序输出要求：\n- 对于每个测试用例，计算更新后的归一化权重 $\\{w_n^{(j)}\\}$ 和 $N_{\\mathrm{eff}}$。\n- 如果 $N_{\\mathrm{eff}}  \\beta N$，则声明退化。\n- 将 $N_{\\mathrm{eff}}$ 四舍五入到三位小数。将每个归一化权重 $w_n^{(j)}$ 四舍五入到六位小数。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个形如 $[N_{\\mathrm{eff}}, \\text{degeneracy\\_flag}, \\text{weights}]$ 的列表，其中 $N_{\\mathrm{eff}}$ 是一个浮点数，$\\text{degeneracy\\_flag}$ 是一个布尔值，$\\text{weights}$ 是四舍五入后的浮点数列表。对于这四个测试，最终输出必须如下所示：\n$$\n\\text{[ [N\\_eff\\_1,deg\\_1,[w\\_1^{(1)},\\dots,w\\_1^{(N)}]], [N\\_eff\\_2,deg\\_2,[\\dots]], [N\\_eff\\_3,deg\\_3,[\\dots]], [N\\_eff\\_4,deg\\_4,[\\dots]] ]}\n$$\n这单行是唯一的输出。",
            "solution": "### 步骤 1：提取给定信息\n\n该问题为序贯重要性重采样粒子滤波器的单步更新提供了以下数据、定义和模型。\n\n**状态和观测模型：**\n1.  **隐藏状态：** 在时间步长 $n$ 时，每个粒子 $j$ 的隐藏状态为 $x_n^{(j)} = (T_n^{(j)}, q_n^{(j)})$，其中 $T_n^{(j)}$ 是温度（开尔文），$q_n^{(j)}$ 是无量纲的反应进度变量。\n2.  **观测：** 观测是光子计数 $y_n$（整数，无量纲）。\n3.  **化学发光强度模型：** 对于一个状态 $x=(T, q)$，期望强度 $\\lambda(x)$ 由一个 Arrhenius 型表达式给出：\n    $$ \\lambda(x) = \\kappa\\, q^\\alpha \\exp\\!\\left(-\\frac{E_a}{R\\,T}\\right) $$\n    其中 $\\kappa$ 是一个指前因子（单位：s$^{-1}$），$\\alpha$ 是一个指数，$E_a$ 是活化能（J/mol），$R$ 是通用气体常数。\n4.  **平均光子计数：** 在一个积分时间 $\\Delta t$（秒）内的平均计数 $\\mu(x)$ 是：\n    $$ \\mu(x) = \\Delta t \\,\\lambda(x) $$\n5.  **观测似然：** 观测 $y_n$ 来自一个均值为 $\\mu(x_n)$ 的泊松分布：\n    $$ p(y_n \\mid x_n) = \\mathrm{Poisson}\\big(y_n; \\mu(x_n)\\big) = \\frac{\\mu(x_n)^{y_n} e^{-\\mu(x_n)}}{y_n!} $$\n\n**粒子滤波器更新规则：**\n1.  **输入：** 先前的归一化权重 $\\{w_{n-1}^{(j)}\\}_{j=1}^N$ 和当前的粒子状态 $\\{x_n^{(j)}\\}_{j=1}^N$。\n2.  **权重更新：** 基于贝叶斯法则和重要性采样（自助粒子滤波器），未归一化的权重 $\\tilde{w}_n^{(j)}$ 更新如下：\n    $$ \\tilde{w}_n^{(j)} \\propto w_{n-1}^{(j)} p(y_n | x_n^{(j)}) $$\n    归一化的权重 $w_n^{(j)}$ 为：\n    $$ w_n^{(j)} = \\frac{\\tilde{w}_n^{(j)}}{\\sum_{k=1}^N \\tilde{w}_n^{(k)}} $$\n3.  **有效样本量 (ESS)：**\n    $$ N_{\\mathrm{eff}} = \\frac{1}{\\sum_{j=1}^N \\left(w_n^{(j)}\\right)^2} $$\n4.  **退化条件：** 如果 $N_{\\mathrm{eff}}  \\beta N$，则声明退化，其中 $N$ 是粒子数，$\\beta$ 是给定的阈值。\n\n**常量和数值要求：**\n-   通用气体常数: $R = 8.314$ J/(mol·K)。\n-   数值稳定性：似然的计算必须在对数域中进行。\n-   对数伽马恒等式：$\\log(y!) = \\log\\Gamma(y+1)$，其中 $\\Gamma$ 是伽马函数。\n\n**测试用例：**\n问题定义了四个测试用例，每个都由一个元组 $(\\{T_n^{(j)}\\}, \\{q_n^{(j)}\\}, \\{w_{n-1}^{(j)}\\}, y_n, \\Delta t, \\kappa, E_a, \\alpha, \\beta)$ 指定。具体值在问题描述中提供。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n-   **科学上合理：** 该问题牢固地植根于已建立的原则。Arrhenius 方程是化学动力学的基石。泊松分布是计数离散、独立事件（如光子到达，即散粒噪声）的正确统计模型。粒子滤波器（特别是 SIR 变体）是在非线性、非高斯系统中进行状态估计的标准和广泛使用的方法，这正是数据同化的背景。该问题在科学上是合理的。\n-   **适定的：** 对于每个测试用例，都提供了所有必需的输入。权重更新、ESS 和退化检查的数学公式是确定性的，并导致唯一的解。该问题是适定的。\n-   **客观的：** 问题是用精确的数学方程、常数和数据定义的。语言是客观的，没有歧义或主观论断。\n-   **完整性和一致性：** 每个测试都指定了所有参数（$\\kappa, E_a, \\alpha, \\Delta t, \\beta$）、常数（$R$）、状态变量（$T, q$）、先验权重（$w_{n-1}$）和观测（$y_n$）。单位被明确定义（开尔文、秒、J/mol）并且在物理上是一致的。每个测试用例中的先验权重经核实总和为 1。设置是完整且内部一致的。\n-   **无其他缺陷：** 该问题没有表现出清单中的任何其他缺陷，例如不可形式化、不切实际、不适定、微不足道或无法验证。\n\n### 步骤 3：结论与行动\n问题是有效的。我将继续推导和实现解决方案。\n\n### 基于原理的设计和解决方案推导\n\n核心任务是实现自助粒子滤波器的测量更新步骤。这涉及到根据每个粒子的预测状态对给定测量的解释程度，对一组粒子进行重新加权。\n\n**1. 权重更新规则的推导**\n\n根据序贯重要性采样的原理，给定截至时间 $n$ 的所有观测 $y_{1:n}$，状态 $x_n$ 的后验概率是递归更新的。使用贝叶斯定理：\n$$\np(x_n | y_{1:n}) \\propto p(y_n | x_n) \\, p(x_n | y_{1:n-1})\n$$\n项 $p(x_n | y_{1:n-1})$ 是在时间 $n$ 的状态的先验概率，它是从时间 $n-1$ 的状态预测的。在粒子滤波器中，这个先验由传播的粒子 $\\{x_n^{(j)}\\}$ 及其继承的权重 $\\{w_{n-1}^{(j)}\\}$ 表示。项 $p(y_n | x_n)$ 是在给定状态 $x_n$ 的情况下观测到 $y_n$ 的似然。\n\n对于自助粒子滤波器，提议分布被选为状态转移先验。粒子的重要性权重通过将先前的权重乘以新粒子状态下新观测的似然来更新：\n$$\n\\tilde{w}_n^{(j)} = w_{n-1}^{(j)} \\, p(y_n | x_n^{(j)})\n$$\n这些未归一化的权重 $\\tilde{w}_n^{(j)}$ 随后被归一化，使其总和为一：\n$$\nw_n^{(j)} = \\frac{\\tilde{w}_n^{(j)}}{\\sum_{k=1}^N \\tilde{w}_n^{(k)}}\n$$\n\n**2. 在对数域中计算似然**\n\n为了保持数值稳定性，尤其是在处理非常小的概率时，我们使用对数似然。似然由泊松概率质量函数给出：\n$$\np(y_n | x_n^{(j)}) = \\frac{(\\mu_n^{(j)})^{y_n} e^{-\\mu_n^{(j)}}}{y_n!}\n$$\n其中 $\\mu_n^{(j)} = \\mu(x_n^{(j)})$。取自然对数：\n$$\n\\log p(y_n | x_n^{(j)}) = y_n \\log(\\mu_n^{(j)}) - \\mu_n^{(j)} - \\log(y_n!)\n$$\n使用提供的恒等式 $\\log(y_n!) = \\log\\Gamma(y_n+1)$，这在数值上由对数伽马函数（SciPy 中的 `gammaln`）实现，对数似然 $\\ell_n^{(j)}$ 为：\n$$\n\\ell_n^{(j)} = y_n \\log(\\mu_n^{(j)}) - \\mu_n^{(j)} - \\mathrm{gammaln}(y_n+1)\n$$\n平均光子计数 $\\mu_n^{(j)}$ 是为每个粒子 $j$ 使用其状态 $(T_n^{(j)}, q_n^{(j)})$ 和给定的参数计算的：\n$$\n\\mu_n^{(j)} = \\Delta t \\cdot \\kappa \\cdot (q_n^{(j)})^\\alpha \\exp\\left(-\\frac{E_a}{R T_n^{(j)}}\\right)\n$$\n如果记录到观测值 $y_n=0$，则会出现一个边界情况。对数似然公式简化为 $\\ell_n^{(j)} = - \\mu_n^{(j)}$，因为 $\\log(0!) = 0$ 且项 $y_n \\log(\\mu_n^{(j)})$ 消失（只要对 $\\mu_n^{(j)} \\to 0$ 处理得当）。\n\n**3. 使用 Log-Sum-Exp 技巧进行归一化**\n\n权重的更新方程涉及指数和求和，这可能导致上溢或下溢。我们使用 log-sum-exp 技巧进行稳健的归一化。首先，我们计算未归一化的对数权重：\n$$\n\\log \\tilde{w}_n^{(j)} = \\log(w_{n-1}^{(j)}) + \\ell_n^{(j)}\n$$\n设 $L_{\\max} = \\max_k(\\log \\tilde{w}_n^{(k)})$。我们可以将归一化权重写为：\n$$\nw_n^{(j)} = \\frac{\\exp(\\log \\tilde{w}_n^{(j)})}{\\sum_{k=1}^N \\exp(\\log \\tilde{w}_n^{(k)})} = \\frac{\\exp(\\log \\tilde{w}_n^{(j)} - L_{\\max})}{\\sum_{k=1}^N \\exp(\\log \\tilde{w}_n^{(k)} - L_{\\max})}\n$$\n这种计算避免了上溢，因为最大的指数项是 $e^0=1$。它还通过放大所有项来减轻下溢。\n\n**4. ESS 计算和退化检查**\n\n在获得归一化权重 $\\{w_n^{(j)}\\}$ 后，有效样本量直接从其定义计算得出：\n$$\nN_{\\mathrm{eff}} = \\frac{1}{\\sum_{j=1}^N (w_n^{(j)})^2}\n$$\n$N_{\\mathrm{eff}}$ 提供了权重退化的度量。接近粒子总数 $N$ 的值表示权重分布均匀，而接近 1 的值表示单个粒子的权重接近于 1，而所有其他粒子的权重接近于零。\n\n最后，通过将 $N_{\\mathrm{eff}}$ 与指定的阈值进行比较来设置退化标志：\n$$\n\\text{degeneracy\\_flag} = (N_{\\mathrm{eff}}  \\beta N)\n$$\n这个系统化的过程构成了实现的基础。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import gammaln\nimport json\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It orchestrates the calculation for each test case and formats the final output.\n    \"\"\"\n    \n    # Universal Gas Constant in J/(mol·K)\n    R = 8.314\n\n    test_cases = [\n        # Test 1 (happy path, moderate counts)\n        (\n            [1950, 2000, 2050, 1900, 2100],  # T_n\n            [0.85, 0.92, 0.88, 0.80, 0.95],  # q_n\n            [0.2, 0.2, 0.2, 0.2, 0.2],  # w_n-1\n            200,  # y_n\n            5.0e-4,  # delta_t\n            3.0e9,  # kappa\n            1.5e5,  # E_a\n            1.0,  # alpha\n            0.5,  # beta\n        ),\n        # Test 2 (skewed prior weights, higher counts)\n        (\n            [1800, 1850, 1900, 1950, 2000, 2050, 2100, 2150],  # T_n\n            [0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00, 0.98],  # q_n\n            [0.05, 0.05, 0.10, 0.10, 0.20, 0.20, 0.15, 0.15], # w_n-1\n            320,  # y_n\n            5.0e-4,  # delta_t\n            3.0e9,  # kappa\n            1.5e5,  # E_a\n            1.0,  # alpha\n            0.5,  # beta\n        ),\n        # Test 3 (edge case, zero counts)\n        (\n            [1600, 1650, 1700, 1750, 1800, 1850],  # T_n\n            [0.40, 0.45, 0.50, 0.55, 0.60, 0.65],  # q_n\n            [1/6, 1/6, 1/6, 1/6, 1/6, 1/6],  # w_n-1\n            0,  # y_n\n            5.0e-4,  # delta_t\n            3.0e9,  # kappa\n            1.5e5,  # E_a\n            1.0,  # alpha\n            0.5,  # beta\n        ),\n        # Test 4 (stronger nonlinearity via larger activation energy)\n        (\n            [1900, 1950, 2000, 2050, 2100, 2150, 2200],  # T_n\n            [0.80, 0.82, 0.85, 0.88, 0.90, 0.92, 0.95],  # q_n\n            [1/7, 1/7, 1/7, 1/7, 1/7, 1/7, 1/7],  # w_n-1\n            20,  # y_n\n            5.0e-4,  # delta_t\n            3.0e9,  # kappa\n            2.0e5,  # E_a\n            1.0,  # alpha\n            0.5,  # beta\n        ),\n    ]\n\n    results = []\n    for params in test_cases:\n        T_n, q_n, w_prev, y_n, delta_t, kappa, E_a, alpha, beta = params\n        \n        # Convert inputs to numpy arrays for vectorized operations\n        T_n = np.array(T_n)\n        q_n = np.array(q_n)\n        w_prev = np.array(w_prev)\n        N = len(T_n)\n\n        # 1. Calculate the mean photon count mu for each particle\n        # lambda(x) = kappa * q^alpha * exp(-Ea / (R * T))\n        # mu(x) = delta_t * lambda(x)\n        exponent = -E_a / (R * T_n)\n        mu = delta_t * kappa * (q_n**alpha) * np.exp(exponent)\n\n        # 2. Compute the log-likelihood for each particle\n        # log L = y * log(mu) - mu - log(y!)\n        # Handle the edge case of y_n = 0 separately for robustness\n        if y_n == 0:\n            # For y=0, log L simplifies to -mu, avoiding log(0) issues.\n            log_likelihood = -mu\n        else:\n            # For y > 0, use the full formula.\n            # Handle potential mu = 0 cases to avoid log(0) = -inf.\n            # If mu is 0, log L is -inf. np.log(0) correctly returns -inf.\n            # 0 * log(0) is nan, but our problem structure ensures mu > 0 if y > 0.\n            # Even if mu=0, the log-likelihood should be -inf, resulting in zero weight.\n            # A numerically safe way to compute y*log(mu):\n            log_mu = np.full_like(mu, -np.inf) # Initialize with -inf\n            non_zero_mu_mask = mu > 0\n            log_mu[non_zero_mu_mask] = np.log(mu[non_zero_mu_mask])\n\n            log_likelihood = y_n * log_mu - mu - gammaln(y_n + 1)\n        \n        # 3. Update weights in the log domain and normalize\n        # log(w_unnorm) = log(w_prev) + log_likelihood\n        # np.log handles w_prev=0 by returning -inf, which is correct.\n        log_w_unnorm = np.log(w_prev) + log_likelihood\n\n        # Use log-sum-exp trick for normalization\n        # Find max of finite log-weights to avoid issues with -inf\n        if np.all(np.isneginf(log_w_unnorm)):\n            # All weights are zero, which implies an inconsistency or extreme case.\n            # Assign uniform weights to prevent division by zero.\n            w_n = np.full(N, 1.0/N)\n        else:\n            max_log_w = np.max(log_w_unnorm[np.isfinite(log_w_unnorm)])\n            w_shifted = np.exp(log_w_unnorm - max_log_w)\n            w_n = w_shifted / np.sum(w_shifted)\n            # Ensure no NaNs, e.g., if all weights become zero\n            w_n = np.nan_to_num(w_n, nan=1.0/N)\n            w_n /= np.sum(w_n)\n\n        # 4. Calculate Effective Sample Size (ESS)\n        # N_eff = 1 / sum(w_n^2)\n        sum_sq_weights = np.sum(w_n**2)\n        N_eff = 1.0 / sum_sq_weights\n\n        # 5. Check for degeneracy\n        # is_degenerate is True if N_eff  beta * N\n        is_degenerate = N_eff  beta * N\n\n        # 6. Format results according to specifications\n        N_eff_rounded = round(N_eff, 3)\n        weights_rounded = [round(w, 6) for w in w_n]\n        \n        results.append([N_eff_rounded, is_degenerate, weights_rounded])\n\n    # 7. Print the final output in the required single-line format\n    # The string representation of a list of lists handled by Python's `str`\n    # and subsequent replacement gives the exact required format.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        },
        {
            "introduction": "燃烧模型中的状态变量，如组分质量分数，必须满足严格的物理约束（例如，必须为正且总和为1）。然而，标准的数据同化算法通常在无约束的欧几里得空间中进行更新。本练习  旨在解决这一关键的实际问题，它将演示如何使用对数比变换，在受约束的物理空间和无约束的计算空间之间进行映射，从而确保分析结果的热力学一致性。",
            "id": "4016180",
            "problem": "考虑一个在计算燃烧模拟中的可压缩反应混合物，其组分质量分数为 $Y_{k}$，$k \\in \\{1,\\dots,N\\}$。根据定义，每个组分的质量分数满足 $Y_{k}  0$ 且混合物守恒约束为 $\\sum_{k=1}^{N} Y_{k} = 1$。在反应流的数据同化中，状态估计通常在无约束的欧几里得控制向量上执行，以应用高斯更新（例如，在集成卡尔曼滤波器（EnKF）中）。为了在分析中确保热力学一致性，当将分析结果映射回物理空间时，质量分数必须保持正值并归一化。\n\n假设组分的质量分数在控制向量中通过相对于参考组分索引 $r \\in \\{1,\\dots,N\\}$ 定义的正向变换来表示：\n$$\n\\eta_{k} = \\ln\\!\\left(\\frac{Y_{k}}{Y_{r}}\\right) \\quad \\text{对于所有 } k \\in \\{1,\\dots,N\\} \\text{ 且 } k \\neq r,\n$$\n并注意 $Y_{r}$ 由守恒约束隐式确定。假设分析步骤为所有 $k \\neq r$ 产生了更新后的控制变量 $\\hat{\\eta}_{k} \\in \\mathbb{R}$。\n\n从物理约束 $Y_{k}  0$ 和 $\\sum_{k=1}^{N} Y_{k} = 1$ 以及上述正向变换的定义出发，推导出一个逆映射，该映射从 $\\{\\hat{\\eta}_{k}\\}$ 返回 $\\{Y_{k}\\}$，同时严格强制正定性和总和为一的约束。然后，对于一个由 $N = 3$ 和组分集合 $\\{\\mathrm{H_{2}}, \\mathrm{O_{2}}, \\mathrm{H_{2}O}\\}$ 组成的氢–氧–水三组分混合物，选择参考组分 $r$ 为 $\\mathrm{H_{2}O}$。给定分析值 $\\hat{\\eta}_{\\mathrm{H_{2}}} = 0.7$ 和 $\\hat{\\eta}_{\\mathrm{O_{2}}} = -1.2$，计算物理空间中的质量分数 $Y_{\\mathrm{H_{2}}}$。将你的最终答案表示为一个无量纲分数，并四舍五入到四位有效数字。",
            "solution": "在继续之前，对问题进行验证。\n\n### 步骤1：提取给定条件\n- 组分质量分数：$Y_{k}$，其中 $k \\in \\{1, \\dots, N\\}$。\n- 物理约束：对所有 $k$，$Y_{k}  0$，且 $\\sum_{k=1}^{N} Y_{k} = 1$。\n- 正向变换（控制变量）：$\\eta_{k} = \\ln\\left(\\frac{Y_{k}}{Y_{r}}\\right)$，对所有 $k \\in \\{1,\\dots,N\\}$ 且 $k \\neq r$，其中 $r$ 是参考组分的索引。\n- 更新后的控制变量：$\\hat{\\eta}_{k} \\in \\mathbb{R}$，对所有 $k \\neq r$。\n- 具体案例：\n    - 组分数量：$N = 3$。\n    - 组分集合：$\\{\\mathrm{H_{2}}, \\mathrm{O_{2}}, \\mathrm{H_{2}O}\\}$。\n    - 参考组分：$r$ 对应于 $\\mathrm{H_{2}O}$。\n    - 分析值：$\\hat{\\eta}_{\\mathrm{H_{2}}} = 0.7$ 和 $\\hat{\\eta}_{\\mathrm{O_{2}}} = -1.2$。\n- 任务：\n    1. 推导从 $\\{\\hat{\\eta}_{k}\\}$ 返回 $\\{Y_{k}\\}$ 的逆映射，同时强制执行物理约束。\n    2. 对给定的具体案例，计算物理空间中的质量分数 $Y_{\\mathrm{H_{2}}}$。\n    3. 将最终答案四舍五入到四位有效数字。\n\n### 步骤2：使用提取的给定条件进行验证\n- **科学基础**：该问题描述了加性对数比（Additive Log-Ratio, ALR）变换，这是成分数据分析中一种标准且严谨的方法，用于将受约束的单纯形（如质量分数）映射到无约束的欧几里得空间。其在计算燃烧领域数据同化中的应用是科学合理且相关的。\n- **适定性**：问题是适定的。给出了正向变换，任务是找到其逆变换，这是一个数学上确定的问题。所提供的数值足以得到唯一解。\n- **客观性**：问题使用精确、客观的数学和科学语言陈述。\n- **完整性与一致性**：提供了所有必要的定义、约束和数据。这些定义内部一致，不会导致矛盾。\n- **现实性**：背景和方法在计算科学与工程领域是现实的。\n\n### 步骤3：结论与行动\n该问题是有效的，因为它具有科学基础、适定且完整。将进行解答。\n\n### 解答推导\n\n目标是从更新后的控制变量 $\\{\\hat{\\eta}_{k}\\}$ 推导出回到物理质量分数 $\\{Y_{k}\\}$ 的逆映射。推导过程必须确保物理约束 $Y_{k}  0$ 和 $\\sum_{i=1}^{N} Y_{i} = 1$ 得到满足。\n\n对于 $k \\neq r$，正向变换为：\n$$\n\\hat{\\eta}_{k} = \\ln\\left(\\frac{Y_{k}}{Y_{r}}\\right)\n$$\n为了求逆，我们首先用 $Y_{r}$ 来表示 $Y_{k}$。对两边取指数：\n$$\n\\exp(\\hat{\\eta}_{k}) = \\frac{Y_{k}}{Y_{r}}\n$$\n$$\nY_{k} = Y_{r} \\exp(\\hat{\\eta}_{k}) \\quad \\text{对于 } k \\neq r\n$$\n这个方程为 $N-1$ 个非参考组分的质量分数提供了表达式。参考组分的质量分数 $Y_{r}$ 仍然未知。为了找到它，我们使用总和为一的约束：\n$$\n\\sum_{i=1}^{N} Y_{i} = 1\n$$\n我们可以将求和分为参考组分和其余组分：\n$$\nY_{r} + \\sum_{k \\neq r} Y_{k} = 1\n$$\n现在，将 $Y_{k}$ 的表达式代入求和中：\n$$\nY_{r} + \\sum_{k \\neq r} \\left(Y_{r} \\exp(\\hat{\\eta}_{k})\\right) = 1\n$$\n从左侧提出 $Y_{r}$：\n$$\nY_{r} \\left(1 + \\sum_{k \\neq r} \\exp(\\hat{\\eta}_{k})\\right) = 1\n$$\n求解 $Y_{r}$，得到参考组分的逆映射：\n$$\nY_{r} = \\frac{1}{1 + \\sum_{j \\neq r} \\exp(\\hat{\\eta}_{j})}\n$$\n为清晰起见，求和索引已更改为 $j$。$Y_{r}$ 的这个表达式保证了正定性，因为指数函数总是正的，使得分母严格大于 $1$。\n\n现在我们可以通过将 $Y_r$ 的表达式代入 $Y_{k} = Y_{r} \\exp(\\hat{\\eta}_{k})$ 来找到任何非参考组分 $Y_{k}$ ($k \\neq r$) 的通用表达式：\n$$\nY_{k} = \\frac{\\exp(\\hat{\\eta}_{k})}{1 + \\sum_{j \\neq r} \\exp(\\hat{\\eta}_{j})} \\quad \\text{对于 } k \\neq r\n$$\n这些为 $Y_r$ 和 $Y_k$ 推导出的逆映射内在地满足了物理约束。正定性 ($Y_k  0$) 得到了保证，因为指数函数总是正的。总和为一的约束通过构造得到满足：\n$$\n\\sum_{i=1}^{N} Y_{i} = Y_{r} + \\sum_{k \\neq r} Y_{k} = \\frac{1}{1 + \\sum_{j \\neq r} \\exp(\\hat{\\eta}_{j})} + \\sum_{k \\neq r} \\frac{\\exp(\\hat{\\eta}_{k})}{1 + \\sum_{j \\neq r} \\exp(\\hat{\\eta}_{j})} = \\frac{1 + \\sum_{k \\neq r} \\exp(\\hat{\\eta}_{k})}{1 + \\sum_{j \\neq r} \\exp(\\hat{\\eta}_{j})} = 1\n$$\n\n### 应用于具体案例\n\n给定一个三组分混合物，$N=3$，组分为 $\\{\\mathrm{H_{2}}, \\mathrm{O_{2}}, \\mathrm{H_{2}O}\\}$。\n参考组分是 $\\mathrm{H_{2}O}$，所以 $r$ 对应于 $\\mathrm{H_{2}O}$。\n非参考组分的索引是 $k \\in \\{\\mathrm{H_{2}}, \\mathrm{O_{2}}\\}$。\n给定的分析空间值为 $\\hat{\\eta}_{\\mathrm{H_{2}}} = 0.7$ 和 $\\hat{\\eta}_{\\mathrm{O_{2}}} = -1.2$。\n\n我们需要计算氢的质量分数 $Y_{\\mathrm{H_{2}}}$。由于 $\\mathrm{H_{2}}$ 不是参考组分，我们使用 $k \\neq r$ 时 $Y_k$ 的公式：\n$$\nY_{\\mathrm{H_{2}}} = \\frac{\\exp(\\hat{\\eta}_{\\mathrm{H_{2}}})}{1 + \\sum_{j \\in \\{\\mathrm{H_{2}}, \\mathrm{O_{2}}\\}} \\exp(\\hat{\\eta}_{j})}\n$$\n分母中的求和是针对所有非参考组分：\n$$\n\\sum_{j \\in \\{\\mathrm{H_{2}}, \\mathrm{O_{2}}\\}} \\exp(\\hat{\\eta}_{j}) = \\exp(\\hat{\\eta}_{\\mathrm{H_{2}}}) + \\exp(\\hat{\\eta}_{\\mathrm{O_{2}}})\n$$\n代入给定值：\n$$\nY_{\\mathrm{H_{2}}} = \\frac{\\exp(0.7)}{1 + \\exp(0.7) + \\exp(-1.2)}\n$$\n现在，我们计算数值：\n$$\n\\exp(0.7) \\approx 2.013752707\n$$\n$$\n\\exp(-1.2) \\approx 0.3011942119\n$$\n将这些值代入 $Y_{\\mathrm{H_{2}}}$ 的表达式中：\n$$\nY_{\\mathrm{H_{2}}} \\approx \\frac{2.013752707}{1 + 2.013752707 + 0.3011942119} = \\frac{2.013752707}{3.314946919}\n$$\n$$\nY_{\\mathrm{H_{2}}} \\approx 0.60747444\n$$\n问题要求将答案四舍五入到四位有效数字。\n$$\nY_{\\mathrm{H_{2}}} \\approx 0.6075\n$$\n这是 $\\mathrm{H_2}$ 质量分数的最终数值答案。",
            "answer": "$$\n\\boxed{0.6075}\n$$"
        }
    ]
}