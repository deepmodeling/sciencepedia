{
    "hands_on_practices": [
        {
            "introduction": "When we discretize a wave equation, our numerical solution rarely propagates waves with the exact physical speed. This discrepancy, known as numerical dispersion, causes different wavelengths to travel at different speeds, leading to phase errors that can corrupt a simulation. This first exercise  delves into the heart of this issue, guiding you through a formal von Neumann analysis to derive the analytical expression for the phase speed error of a general high-order finite-difference scheme. Mastering this analysis provides a fundamental understanding of how numerical errors arise and how they depend on grid resolution and the order of the scheme.",
            "id": "4005967",
            "problem": "Consider one-dimensional linearized acoustics in a uniformly reacting gas at rest, where pressure perturbations $p'(x,t)$ satisfy the wave equation $\\frac{\\partial^{2} p'}{\\partial t^{2}} = c^{2} \\frac{\\partial^{2} p'}{\\partial x^{2}},$ with $c$ the constant sound speed. In computational combustion, spatial derivatives are often approximated by central finite-difference stencils on a uniform grid of spacing $\\Delta x$. Let $D_{x}^{(2)}$ denote a $2m$-order accurate, symmetric, central finite-difference approximation to the second spatial derivative acting on a grid function $p'_{i}(t) \\approx p'(x_{i},t)$, where $x_{i} = i \\Delta x$ and $i \\in \\mathbb{Z}$. Assume $D_{x}^{(2)}$ has the standard symmetric form\n$$\nD_{x}^{(2)} p'_{i} \\;=\\; \\frac{1}{\\Delta x^{2}} \\left( a_{0}\\, p'_{i} \\;+\\; \\sum_{j=1}^{m} a_{j}\\, p'_{i+j} \\;+\\; \\sum_{j=1}^{m} a_{j}\\, p'_{i-j} \\right),\n$$\nwith coefficients $\\{a_{j}\\}_{j=0}^{m}$ chosen so that $D_{x}^{(2)}$ is consistent with the second derivative and has truncation error $O(\\Delta x^{2m})$. Equivalently, introduce the weights $\\{b_{j}\\}_{j=1}^{m}$ for the symmetric representation of the discrete second-derivative symbol,\n$$\n\\sigma(\\theta) \\;=\\; \\frac{1}{\\Delta x^{2}} \\, 2 \\sum_{j=1}^{m} b_{j} \\left( \\cos(j\\theta) - 1 \\right), \\quad \\theta \\equiv k \\Delta x,\n$$\nwhere $k$ is the continuous wavenumber and $\\theta$ is the grid wavenumber measured in radians. The order conditions for a $2m$-order accurate second-derivative stencil are that\n$$\nS_{2} \\equiv \\sum_{j=1}^{m} b_{j} j^{2} = 1, \\quad S_{2n} \\equiv \\sum_{j=1}^{m} b_{j} j^{2n} = 0 \\;\\; \\text{for} \\;\\; n=2,3,\\dots,m,\n$$\nwhile $S_{2m+2} \\equiv \\sum_{j=1}^{m} b_{j} j^{2m+2}$ is generally nonzero and determines the leading truncation error.\n\nTreat time as continuous and perform a Fourier (normal-mode) analysis on the semi-discrete system $\\frac{\\partial^{2} p'_{i}}{\\partial t^{2}} = c^{2} D_{x}^{(2)} p'_{i}$ with the ansatz $p'_{i}(t) = \\hat{p} \\exp\\!\\left( \\mathrm{i}\\, i\\, \\theta - \\mathrm{i}\\, \\omega t \\right)$, where $\\theta = k \\Delta x$ is in radians. Starting from first principles of linear acoustics and this semi-discrete approximation, derive the dispersion relation $\\omega(k)$ in terms of the discrete symbol $\\sigma(\\theta)$ and, by a Taylor expansion consistent with the order conditions, obtain the leading-order expression for the normalized phase speed error $\\delta_{p} \\equiv \\frac{\\omega}{c k} - 1$ accurate up to and including $O\\!\\left( (k \\Delta x)^{2m} \\right)$.\n\nYour final answer must be a single closed-form analytic expression for $\\delta_{p}$ written in terms of $m$, $S_{2m+2}$, $k$, and $\\Delta x$. The angle $\\theta$ should be treated in radians. No numerical evaluation is required.",
            "solution": "The problem is subjected to validation against the specified criteria.\n\n**Step 1: Extract Givens**\n- **Governing Equation:** The one-dimensional wave equation for pressure perturbations $p'(x,t)$ is $\\frac{\\partial^{2} p'}{\\partial t^{2}} = c^{2} \\frac{\\partial^{2} p'}{\\partial x^{2}}$, where $c$ is the constant sound speed.\n- **Semi-Discrete System:** The spatially discretized equation is $\\frac{\\partial^{2} p'_{i}}{\\partial t^{2}} = c^{2} D_{x}^{(2)} p'_{i}$, where $p'_{i}(t) \\approx p'(x_{i},t)$ on a uniform grid $x_i = i \\Delta x$.\n- **Finite-Difference Operator:** $D_{x}^{(2)}$ is a $2m$-order accurate, symmetric, central finite-difference approximation to the second derivative with truncation error $O(\\Delta x^{2m})$.\n- **Discrete Symbol:** The symbol of the operator $D_{x}^{(2)}$ is given as $\\sigma(\\theta) = \\frac{1}{\\Delta x^{2}} \\, 2 \\sum_{j=1}^{m} b_{j} \\left( \\cos(j\\theta) - 1 \\right)$, where $\\theta \\equiv k \\Delta x$ is the grid wavenumber.\n- **Order Conditions:** For $2m$-order accuracy, the coefficients $\\{b_j\\}$ satisfy:\n  - $S_{2} \\equiv \\sum_{j=1}^{m} b_{j} j^{2} = 1$\n  - $S_{2n} \\equiv \\sum_{j=1}^{m} b_{j} j^{2n} = 0 \\;\\; \\text{for} \\;\\; n=2,3,\\dots,m$\n- **Leading Error Coefficient:** $S_{2m+2} \\equiv \\sum_{j=1}^{m} b_{j} j^{2m+2}$ is generally non-zero.\n- **Fourier Ansatz:** A normal-mode solution is sought in the form $p'_{i}(t) = \\hat{p} \\exp\\!\\left( \\mathrm{i}\\, i\\, \\theta - \\mathrm{i}\\, \\omega t \\right)$, where $\\omega$ is the numerical angular frequency.\n- **Objective:** Derive the leading-order expression for the normalized phase speed error $\\delta_{p} \\equiv \\frac{\\omega}{c k} - 1$, accurate up to and including the $O((k \\Delta x)^{2m})$ term. The expression should be in terms of $m$, $S_{2m+2}$, $k$, and $\\Delta x$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding:** The problem is firmly rooted in the standard Von Neumann stability analysis (or Fourier analysis) of finite-difference schemes applied to a linear hyperbolic partial differential equation. This is a canonical topic in numerical analysis and computational physics. All statements are factually and scientifically sound.\n- **Well-Posedness:** The problem provides all necessary information and definitions to derive a unique analytical expression for the leading-order phase error. The objective is clear and achievable.\n- **Objectivity:** The problem is stated in precise, formal mathematical language, free from any subjectivity or ambiguity.\n- **Conclusion:** The problem is devoid of any flaws listed in the validation checklist. It is a valid, well-posed problem in computational science.\n\n**Step 3: Verdict and Action**\n- **Verdict:** The problem is valid.\n- **Action:** Proceed with the solution.\n\n**Derivation of the Solution**\nWe begin by substituting the Fourier ansatz, $p'_{i}(t) = \\hat{p} \\exp\\!\\left( \\mathrm{i}\\, i\\, \\theta - \\mathrm{i}\\, \\omega t \\right)$, into the semi-discrete wave equation, $\\frac{\\partial^{2} p'_{i}}{\\partial t^{2}} = c^{2} D_{x}^{(2)} p'_{i}$.\n\nFirst, we evaluate the left-hand side (LHS), which involves time differentiation:\n$$\n\\frac{\\partial p'_{i}}{\\partial t} = (-\\mathrm{i} \\omega) \\hat{p} \\exp\\!\\left( \\mathrm{i}\\, i\\, \\theta - \\mathrm{i}\\, \\omega t \\right) = (-\\mathrm{i} \\omega) p'_{i}(t)\n$$\n$$\n\\frac{\\partial^{2} p'_{i}}{\\partial t^{2}} = (-\\mathrm{i} \\omega)^{2} p'_{i}(t) = -\\omega^{2} p'_{i}(t)\n$$\n\nNext, we evaluate the right-hand side (RHS), which involves the spatial finite-difference operator $D_x^{(2)}$. The action of this operator on the Fourier mode is equivalent to multiplication by its symbol, $\\sigma(\\theta)$. To show this, we note that $p'_{i\\pm j}(t) = \\exp(\\pm \\mathrm{i} j \\theta) p'_{i}(t)$. Using the definition of the discrete symbol, the action of the operator is:\n$$\nD_{x}^{(2)} p'_{i} = D_{x}^{(2)} \\left( \\hat{p} \\exp(\\mathrm{i} i \\theta) \\exp(-\\mathrm{i} \\omega t) \\right) = \\sigma(\\theta) \\left( \\hat{p} \\exp(\\mathrm{i} i \\theta) \\exp(-\\mathrm{i} \\omega t) \\right) = \\sigma(\\theta) p'_{i}\n$$\nThus, the RHS of the semi-discrete equation becomes:\n$$\nc^{2} D_{x}^{(2)} p'_{i} = c^{2} \\sigma(\\theta) p'_{i}\n$$\n\nEquating the transformed LHS and RHS, we obtain:\n$$\n-\\omega^{2} p'_{i} = c^{2} \\sigma(\\theta) p'_{i}\n$$\nSince $p'_{i}$ is a non-trivial solution, we can divide by it to obtain the numerical dispersion relation:\n$$\n\\omega^{2} = -c^{2} \\sigma(\\theta)\n$$\nThis gives the numerical frequency $\\omega$ as a function of the grid wavenumber $\\theta$. For a propagating wave, $\\omega$ must be real, which implies $\\sigma(\\theta)$ must be negative. The problem statement gives $\\sigma(\\theta) = \\frac{2}{\\Delta x^{2}} \\sum_{j=1}^{m} b_{j} (\\cos(j\\theta)-1)$. Since $\\cos(j\\theta) \\le 1$, and it can be shown that the coefficients $b_j$ for a stable scheme result in the sum being non-positive, $\\sigma(\\theta) \\le 0$ as required. Taking the positive root for the frequency of a forward-propagating wave, we get:\n$$\n\\omega = \\sqrt{-c^{2} \\sigma(\\theta)} = c \\sqrt{-\\sigma(\\theta)}\n$$\n\nTo find the phase speed error, we must analyze this expression in the low-wavenumber limit, $\\theta \\to 0$. We perform a Taylor series expansion of the symbol $\\sigma(\\theta)$ around $\\theta=0$.\nThe Taylor series for $\\cos(x)$ is $\\sum_{n=0}^{\\infty} \\frac{(-1)^{n} x^{2n}}{(2n)!}$.\n$$\n\\cos(j\\theta) - 1 = \\sum_{n=1}^{\\infty} \\frac{(-1)^{n} (j\\theta)^{2n}}{(2n)!}\n$$\nSubstituting this into the expression for $\\sigma(\\theta)$:\n$$\n\\sigma(\\theta) = \\frac{2}{\\Delta x^{2}} \\sum_{j=1}^{m} b_{j} \\left( \\sum_{n=1}^{\\infty} \\frac{(-1)^{n} j^{2n} \\theta^{2n}}{(2n)!} \\right)\n$$\nBy swapping the order of summation, we get:\n$$\n\\sigma(\\theta) = \\frac{2}{\\Delta x^{2}} \\sum_{n=1}^{\\infty} \\frac{(-1)^{n} \\theta^{2n}}{(2n)!} \\left( \\sum_{j=1}^{m} b_{j} j^{2n} \\right)\n$$\nThe inner sum is the definition of $S_{2n}$. The expression becomes:\n$$\n\\sigma(\\theta) = \\frac{2}{\\Delta x^{2}} \\sum_{n=1}^{\\infty} \\frac{(-1)^{n} S_{2n} \\theta^{2n}}{(2n)!}\n$$\nUsing the given order conditions ($S_2=1$ and $S_{2n}=0$ for $n = 2, \\dots, m$), the sum simplifies, with the first non-zero term after $n=1$ being at $n=m+1$:\n$$\n\\sigma(\\theta) = \\frac{2}{\\Delta x^{2}} \\left[ \\frac{(-1)^{1} S_{2} \\theta^{2}}{2!} + \\frac{(-1)^{m+1} S_{2m+2} \\theta^{2m+2}}{(2m+2)!} + O(\\theta^{2m+4}) \\right]\n$$\n$$\n\\sigma(\\theta) = \\frac{2}{\\Delta x^{2}} \\left[ -\\frac{\\theta^{2}}{2} + \\frac{(-1)^{m+1} S_{2m+2} \\theta^{2m+2}}{(2m+2)!} + \\dots \\right] = -\\frac{\\theta^2}{\\Delta x^2} + \\frac{2(-1)^{m+1} S_{2m+2}}{\\Delta x^2 (2m+2)!} \\theta^{2m+2} + O(\\theta^{2m+4})\n$$\nNow we compute $-\\sigma(\\theta)$:\n$$\n-\\sigma(\\theta) = \\frac{\\theta^2}{\\Delta x^2} - \\frac{2(-1)^{m+1} S_{2m+2}}{\\Delta x^2 (2m+2)!} \\theta^{2m+2} - O(\\theta^{2m+4})\n$$\n$$\n-\\sigma(\\theta) = \\frac{\\theta^2}{\\Delta x^2} \\left[ 1 - \\frac{2(-1)^{m+1} S_{2m+2}}{(2m+2)!} \\theta^{2m} - O(\\theta^{2m+2}) \\right]\n$$\nSubstitute this into the dispersion relation $\\omega = c \\sqrt{-\\sigma(\\theta)}$:\n$$\n\\omega = c \\sqrt{\\frac{\\theta^2}{\\Delta x^2} \\left[ 1 - \\frac{2(-1)^{m+1} S_{2m+2}}{(2m+2)!} \\theta^{2m} - O(\\theta^{2m+2}) \\right]}\n$$\n$$\n\\omega = \\frac{c \\theta}{\\Delta x} \\sqrt{1 - \\frac{2(-1)^{m+1} S_{2m+2}}{(2m+2)!} \\theta^{2m} - O(\\theta^{2m+2})}\n$$\nUsing the Taylor expansion $\\sqrt{1+x} = 1 + \\frac{1}{2}x + O(x^2)$ for small $x$:\n$$\n\\omega \\approx \\frac{c \\theta}{\\Delta x} \\left[ 1 - \\frac{1}{2} \\frac{2(-1)^{m+1} S_{2m+2}}{(2m+2)!} \\theta^{2m} \\right] = \\frac{c \\theta}{\\Delta x} \\left[ 1 - \\frac{(-1)^{m+1} S_{2m+2}}{(2m+2)!} \\theta^{2m} \\right]\n$$\nThe normalized phase speed is $\\frac{\\omega}{ck}$. Since $\\theta = k \\Delta x$, we have $ck = c \\frac{\\theta}{\\Delta x}$.\n$$\n\\frac{\\omega}{ck} \\approx \\frac{\\frac{c \\theta}{\\Delta x} \\left[ 1 - \\frac{(-1)^{m+1} S_{2m+2}}{(2m+2)!} \\theta^{2m} \\right]}{c \\frac{\\theta}{\\Delta x}} = 1 - \\frac{(-1)^{m+1} S_{2m+2}}{(2m+2)!} \\theta^{2m}\n$$\nThe normalized phase speed error is defined as $\\delta_p = \\frac{\\omega}{ck} - 1$.\n$$\n\\delta_p \\approx \\left[ 1 - \\frac{(-1)^{m+1} S_{2m+2}}{(2m+2)!} \\theta^{2m} \\right] - 1 = - \\frac{(-1)^{m+1} S_{2m+2}}{(2m+2)!} \\theta^{2m}\n$$\nSimplifying the negative sign using $(-1)(-1)^{m+1} = (-1)^{m+2} = (-1)^m$:\n$$\n\\delta_p \\approx \\frac{(-1)^m S_{2m+2}}{(2m+2)!} \\theta^{2m}\n$$\nFinally, expressing the result in terms of the continuous wavenumber $k$ by substituting $\\theta = k \\Delta x$:\n$$\n\\delta_p \\approx \\frac{(-1)^m S_{2m+2}}{(2m+2)!} (k \\Delta x)^{2m}\n$$\nThis is the leading-order expression for the normalized phase speed error, accurate up to and including the $O((k\\Delta x)^{2m})$ term.",
            "answer": "$$\n\\boxed{\\frac{(-1)^{m} S_{2m+2} (k\\Delta x)^{2m}}{(2m+2)!}}\n$$"
        },
        {
            "introduction": "A correct numerical algorithm is no guarantee of a correct simulation; subtle bugs in its implementation can lead to plausible but wrong results. The Method of Manufactured Solutions (MMS) is a rigorous technique for verifying that a code solves the intended equations to the designed order of accuracy. In this practice , you will implement a solver for the 1D acoustic equations with prescribed source terms, run it on a sequence of refining grids, and measure the error convergence rate. Completing this exercise demonstrates a critical skill in computational science: the ability to build confidence in your code through systematic verification.",
            "id": "4005931",
            "problem": "Consider one-dimensional small-amplitude acoustics in a homogeneous reactive mixture under the isentropic and inviscid approximation, for which the linearized equations couple the nondimensional pressure $p(x,t)$ and nondimensional velocity $u(x,t)$ on a periodic domain $x \\in [0,1]$ as\n$$\n\\frac{\\partial p}{\\partial t} + \\frac{\\partial u}{\\partial x} = S_p(x,t), \\qquad \\frac{\\partial u}{\\partial t} + \\frac{\\partial p}{\\partial x} = S_u(x,t),\n$$\nwhere the Method of Manufactured Solutions (MMS) specifies an exact solution and the source terms $S_p(x,t)$ and $S_u(x,t)$ are chosen so that the exact solution satisfies the equations identically. Assume nondimensionalization has been performed with characteristic density $\\rho_0 = 1$ and speed of sound $c = 1$, so all variables are dimensionless and angles used within trigonometric functions are in radians.\n\nStarting from the conservation of mass and momentum for a compressible fluid and linearizing around a quiescent state with constant base density, together with the isentropic relation $p = c^2 \\rho$, the coupling above follows as the fundamental base. For MMS, take the manufactured fields\n$$\np^{\\star}(x,t) = \\sin(\\kappa x)\\cos(\\omega t), \\qquad u^{\\star}(x,t) = \\sin(\\kappa x)\\sin(\\omega t),\n$$\nwith $\\kappa = 2\\pi m$ for an integer wavenumber count $m$ over the domain and $\\omega = 2\\pi$ so that the temporal period is $1$. Derive the source terms $S_p(x,t)$ and $S_u(x,t)$ to ensure $p^{\\star}$ and $u^{\\star}$ exactly satisfy the partial differential equations. Implement two spatial discretizations for the first derivatives on a uniform grid with $N$ points:\n- A second-order centered difference scheme,\n- A fourth-order centered difference scheme.\n\nUse explicit classical fourth-order Runge–Kutta time stepping, and select the time step by a Courant–Friedrichs–Lewy number $\\nu$ as $\\Delta t = \\nu \\Delta x$ with $\\Delta x = 1/N$ and $\\nu = 0.2$. Integrate from $t=0$ to a final time $t=T$, where $T = 0.3$, using periodic boundary conditions. Initialize with $p(x,0) = p^{\\star}(x,0)$ and $u(x,0) = u^{\\star}(x,0)$.\n\nFor each spatial scheme, compute grid-refined discrete relative $L_2$ errors at $t=T$ for both $p$ and $u$. Define the discrete relative $L_2$ error for a field $f$ as\n$$\n\\varepsilon_{L_2}(f) = \\frac{\\left( \\Delta x \\sum_{i=0}^{N-1} \\left[f_i^{\\text{num}}(T) - f_i^{\\star}(T)\\right]^2 \\right)^{1/2}}{\\left( \\Delta x \\sum_{i=0}^{N-1} \\left[f_i^{\\star}(T)\\right]^2 \\right)^{1/2}}.\n$$\nEstimate the observed order of convergence $p_{\\text{obs}}$ for each field and scheme by fitting a straight line to $\\log(\\varepsilon_{L_2})$ versus $\\log(\\Delta x)$ across the grid sizes, and taking the slope.\n\nYour program must implement the above and produce the observed orders of convergence for both $p$ and $u$ for each spatial scheme, using the following test suite:\n- Second-order scheme with $m=1$, $N \\in \\{32,64,128,256\\}$,\n- Fourth-order scheme with $m=1$, $N \\in \\{32,64,128,256\\}$.\n\nAll quantities are nondimensional, and angles are in radians. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[p_{\\text{obs}}^{(2)}, u_{\\text{obs}}^{(2)}, p_{\\text{obs}}^{(4)}, u_{\\text{obs}}^{(4)}]$, where superscripts indicate the spatial scheme order. Each entry must be a float rounded to three decimal places.",
            "solution": "The problem is subjected to a formal validation process before a solution is attempted.\n\n### Step 1: Extract Givens\n\nThe following information is provided in the problem statement:\n-   **Governing Equations**:\n    $$\n    \\frac{\\partial p}{\\partial t} + \\frac{\\partial u}{\\partial x} = S_p(x,t), \\qquad \\frac{\\partial u}{\\partial t} + \\frac{\\partial p}{\\partial x} = S_u(x,t)\n    $$\n-   **Domain**: Periodic, $x \\in [0,1]$.\n-   **Nondimensional Constants**: Characteristic density $\\rho_0 = 1$, speed of sound $c = 1$.\n-   **Manufactured Solution**:\n    $$\n    p^{\\star}(x,t) = \\sin(\\kappa x)\\cos(\\omega t), \\qquad u^{\\star}(x,t) = \\sin(\\kappa x)\\sin(\\omega t)\n    $$\n-   **Manufactured Solution Parameters**: $\\kappa = 2\\pi m$ for integer wavenumber $m$, and $\\omega = 2\\pi$.\n-   **Numerical Grid**: Uniform grid with $N$ points, grid spacing $\\Delta x = 1/N$.\n-   **Spatial Discretization Schemes**:\n    1.  Second-order centered difference.\n    2.  Fourth-order centered difference.\n-   **Temporal Discretization Scheme**: Classical fourth-order Runge-Kutta (RK4).\n-   **Time Step**: $\\Delta t = \\nu \\Delta x$, with Courant–Friedrichs–Lewy (CFL) number $\\nu = 0.2$.\n-   **Simulation Time**: Integrate from $t=0$ to $T=0.3$.\n-   **Initial Conditions**: $p(x,0) = p^{\\star}(x,0)$, $u(x,0) = u^{\\star}(x,0)$.\n-   **Error Metric**: Discrete relative $L_2$ error for a field $f$:\n    $$\n    \\varepsilon_{L_2}(f) = \\frac{\\left( \\Delta x \\sum_{i=0}^{N-1} \\left[f_i^{\\text{num}}(T) - f_i^{\\star}(T)\\right]^2 \\right)^{1/2}}{\\left( \\Delta x \\sum_{i=0}^{N-1} \\left[f_i^{\\star}(T)\\right]^2 \\right)^{1/2}}\n    $$\n-   **Convergence Order Estimation**: The observed order of convergence, $p_{\\text{obs}}$, is the slope of a linear fit to $\\log(\\varepsilon_{L_2})$ versus $\\log(\\Delta x)$.\n-   **Test Suite**:\n    -   Second-order scheme: $m=1$, $N \\in \\{32, 64, 128, 256\\}$.\n    -   Fourth-order scheme: $m=1$, $N \\in \\{32, 64, 128, 256\\}$.\n-   **Output Format**: A comma-separated list $[p_{\\text{obs}}^{(2)}, u_{\\text{obs}}^{(2)}, p_{\\text{obs}}^{(4)}, u_{\\text{obs}}^{(4)}]$, with values rounded to three decimal places.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is evaluated against the validation criteria:\n-   **Scientifically Grounded**: The problem is built upon the linearized acoustic equations, a fundamental model in fluid dynamics. The Method of Manufactured Solutions (MMS) is a standard and rigorous technique for verifying the correctness of numerical code implementations. All aspects are consistent with established principles of computational physics.\n-   **Well-Posed**: The problem describes a well-posed initial-boundary value problem for a system of hyperbolic partial differential equations (PDEs). The initial conditions, periodic boundary conditions, and source terms (to be derived) are clearly specified, ensuring a unique solution exists. The numerical method proposed is standard for this class of problems.\n-   **Objective**: The problem is stated in precise, unambiguous mathematical and technical language, free from subjective or opinion-based elements.\n\nThe problem does not exhibit any of the listed flaws, such as scientific unsoundness, incompleteness, contradictions, or ambiguity.\n\n### Step 3: Verdict and Action\n\nThe problem statement is deemed **valid**. A solution will be developed following the specified requirements.\n\n### Solution Derivation and Methodology\n\nThe solution requires several steps: derivation of the source terms for the Method of Manufactured Solutions (MMS), implementation of the numerical discretization schemes, and analysis of the simulation results to determine the order of convergence.\n\n**1. Derivation of Source Terms**\n\nThe source terms $S_p(x,t)$ and $S_u(x,t)$ are defined such that the manufactured solutions $p^{\\star}(x,t)$ and $u^{\\star}(x,t)$ satisfy the governing PDEs exactly. We substitute $p^{\\star}$ and $u^{\\star}$ into the PDEs.\n\nFirst, we compute the necessary partial derivatives of the manufactured solutions:\n$$\np^{\\star}(x,t) = \\sin(\\kappa x)\\cos(\\omega t) \\\\\nu^{\\star}(x,t) = \\sin(\\kappa x)\\sin(\\omega t)\n$$\nThe derivatives are:\n$$\n\\frac{\\partial p^{\\star}}{\\partial t} = -\\omega \\sin(\\kappa x)\\sin(\\omega t) \\\\\n\\frac{\\partial p^{\\star}}{\\partial x} = \\kappa \\cos(\\kappa x)\\cos(\\omega t) \\\\\n\\frac{\\partial u^{\\star}}{\\partial t} = \\omega \\sin(\\kappa x)\\cos(\\omega t) \\\\\n\\frac{\\partial u^{\\star}}{\\partial x} = \\kappa \\cos(\\kappa x)\\sin(\\omega t)\n$$\nSubstituting these into the governing equations yields the source terms:\n$$\nS_p(x,t) = \\frac{\\partial p^{\\star}}{\\partial t} + \\frac{\\partial u^{\\star}}{\\partial x} = -\\omega \\sin(\\kappa x)\\sin(\\omega t) + \\kappa \\cos(\\kappa x)\\sin(\\omega t) = \\left( \\kappa \\cos(\\kappa x) - \\omega \\sin(\\kappa x) \\right) \\sin(\\omega t)\n$$\n$$\nS_u(x,t) = \\frac{\\partial u^{\\star}}{\\partial t} + \\frac{\\partial p^{\\star}}{\\partial x} = \\omega \\sin(\\kappa x)\\cos(\\omega t) + \\kappa \\cos(\\kappa x)\\cos(\\omega t) = \\left( \\omega \\sin(\\kappa x) + \\kappa \\cos(\\kappa x) \\right) \\cos(\\omega t)\n$$\nThese expressions for $S_p$ and $S_u$ must be implemented in the numerical solver.\n\n**2. Numerical Discretization**\n\nThe problem is solved using the method of lines, where the spatial derivatives are discretized first, converting the system of PDEs into a large system of ordinary differential equations (ODEs) in time.\n\nThe spatial domain $x \\in [0,1]$ is discretized into $N$ grid points $x_i = i \\Delta x$ for $i = 0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = 1/N$. The solution fields $p(x,t)$ and $u(x,t)$ are approximated by grid functions $p_i(t) \\approx p(x_i,t)$ and $u_i(t) \\approx u(x_i,t)$.\n\nThe semi-discretized system of ODEs is:\n$$\n\\frac{d p_i}{dt} = -(\\mathcal{D}_x u)_i + S_p(x_i, t) \\\\\n\\frac{d u_i}{dt} = -(\\mathcal{D}_x p)_i + S_u(x_i, t)\n$$\nwhere $\\mathcal{D}_x$ is the finite difference operator for the spatial derivative $\\frac{\\partial}{\\partial x}$.\n\n-   **Second-Order Centered Difference ($\\mathcal{D}_x^{(2)}$)**: For a grid function $f_i$, the second-order accurate centered difference is:\n    $$\n    (\\mathcal{D}_x^{(2)} f)_i = \\frac{f_{i+1} - f_{i-1}}{2\\Delta x}\n    $$\n    Periodic boundary conditions imply that indices are taken modulo $N$, i.e., $f_{-1} = f_{N-1}$ and $f_{N} = f_0$.\n\n-   **Fourth-Order Centered Difference ($\\mathcal{D}_x^{(4)}$)**: The fourth-order accurate centered difference is:\n    $$\n    (\\mathcal{D}_x^{(4)} f)_i = \\frac{-f_{i+2} + 8 f_{i+1} - 8 f_{i-1} + f_{i-2}}{12\\Delta x}\n    $$\n    Again, periodic boundary conditions are applied to the indices.\n\nThis system of ODEs is then integrated in time using the classical fourth-order Runge-Kutta (RK4) method. For an ODE system $\\frac{d\\mathbf{V}}{dt} = \\mathbf{F}(t, \\mathbf{V})$, where $\\mathbf{V}(t) = [p_0, \\dots, p_{N-1}, u_0, \\dots, u_{N-1}]^T$, the RK4 update from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ is:\n$$\n\\mathbf{k}_1 = \\mathbf{F}(t_n, \\mathbf{V}_n) \\\\\n\\mathbf{k}_2 = \\mathbf{F}(t_n + \\frac{\\Delta t}{2}, \\mathbf{V}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = \\mathbf{F}(t_n + \\frac{\\Delta t}{2}, \\mathbf{V}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = \\mathbf{F}(t_n + \\Delta t, \\mathbf{V}_n + \\Delta t \\mathbf{k}_3) \\\\\n\\mathbf{V}_{n+1} = \\mathbf{V}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nThe time step is fixed by the CFL condition: $\\Delta t = \\nu \\Delta x = 0.2 \\Delta x$.\n\n**3. Verification Procedure**\n\nThe simulation starts from the initial conditions at $t=0$:\n$$\np(x,0) = p^{\\star}(x,0) = \\sin(\\kappa x)\\cos(0) = \\sin(\\kappa x) \\\\\nu(x,0) = u^{\\star}(x,0) = \\sin(\\kappa x)\\sin(0) = 0\n$$\nThe simulation is run for each grid resolution $N \\in \\{32, 64, 128, 256\\}$ until the final time $T=0.3$. At $t=T$, the discrete relative $L_2$ error, $\\varepsilon_{L_2}$, is computed for both $p$ and $u$ by comparing the numerical solution $f^{\\text{num}}$ against the exact solution $f^{\\star}$ at the grid points.\n\nThe order of convergence is determined from the assumption that the error behaves as $\\varepsilon_{L_2} \\approx C (\\Delta x)^{p_{\\text{obs}}}$ for some constant $C$. Taking the logarithm of this relation gives:\n$$\n\\log(\\varepsilon_{L_2}) \\approx \\log(C) + p_{\\text{obs}} \\log(\\Delta x)\n$$\nThis shows a linear relationship between $\\log(\\varepsilon_{L_2})$ and $\\log(\\Delta x)$. The slope of this line is the observed order of convergence, $p_{\\text{obs}}$. It is estimated by performing a linear least-squares regression on the set of data points $(\\log(\\Delta x_j), \\log(\\varepsilon_{j}))$ obtained from the different grid resolutions $N_j$. This process is repeated for both fields ($p$, $u$) and both spatial schemes (2nd and 4th order).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Method of Manufactured Solutions for the 1D linearized\n    acoustic equations, computes grid refinement errors, and determines\n    the observed order of convergence for 2nd and 4th-order spatial schemes.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    M_WAVENUMBER = 1\n    NU_CFL = 0.2\n    T_FINAL = 0.3\n    N_VALS = [32, 64, 128, 256]\n    SCHEMES = [2, 4]\n    \n    KAPPA = 2.0 * np.pi * M_WAVENUMBER\n    OMEGA = 2.0 * np.pi\n\n    # --- Manufactured Solution and Source Terms ---\n    def p_exact(x, t):\n        return np.sin(KAPPA * x) * np.cos(OMEGA * t)\n\n    def u_exact(x, t):\n        return np.sin(KAPPA * x) * np.sin(OMEGA * t)\n\n    def Sp_source(x, t):\n        term1 = KAPPA * np.cos(KAPPA * x)\n        term2 = -OMEGA * np.sin(KAPPA * x)\n        return (term1 + term2) * np.sin(OMEGA * t)\n\n    def Su_source(x, t):\n        term1 = OMEGA * np.sin(KAPPA * x)\n        term2 = KAPPA * np.cos(KAPPA * x)\n        return (term1 + term2) * np.cos(OMEGA * t)\n\n    # --- Spatial Derivative Operators ---\n    def deriv_2nd(f, dx):\n        \"\"\"Computes 2nd-order centered difference with periodic BCs.\"\"\"\n        f_im1 = np.roll(f, 1)\n        f_ip1 = np.roll(f, -1)\n        return (f_ip1 - f_im1) / (2.0 * dx)\n\n    def deriv_4th(f, dx):\n        \"\"\"Computes 4th-order centered difference with periodic BCs.\"\"\"\n        f_im2 = np.roll(f, 2)\n        f_im1 = np.roll(f, 1)\n        f_ip1 = np.roll(f, -1)\n        f_ip2 = np.roll(f, -2)\n        return (-f_ip2 + 8.0 * f_ip1 - 8.0 * f_im1 + f_im2) / (12.0 * dx)\n\n    # --- RHS of the ODE system dV/dt = F(t, V) ---\n    def compute_rhs(t, p_vec, u_vec, x_grid, dx, scheme_order):\n        if scheme_order == 2:\n            dp_dx = deriv_2nd(p_vec, dx)\n            du_dx = deriv_2nd(u_vec, dx)\n        elif scheme_order == 4:\n            dp_dx = deriv_4th(p_vec, dx)\n            du_dx = deriv_4th(u_vec, dx)\n        else:\n            raise ValueError(\"Unsupported scheme order\")\n            \n        rhs_p = -du_dx + Sp_source(x_grid, t)\n        rhs_u = -dp_dx + Su_source(x_grid, t)\n        \n        return rhs_p, rhs_u\n\n    # --- Main simulation runner ---\n    def run_simulation(N, scheme_order):\n        # Grid and time step setup\n        dx = 1.0 / N\n        dt = NU_CFL * dx\n        x_grid = np.linspace(0.0, 1.0, N, endpoint=False)\n\n        # Initial conditions\n        p = p_exact(x_grid, 0.0)\n        u = u_exact(x_grid, 0.0)\n        t = 0.0\n\n        # Time integration loop (RK4)\n        while t  T_FINAL:\n            # Prevent overstepping final time\n            dt_current = min(dt, T_FINAL - t)\n            \n            # k1\n            k1_p, k1_u = compute_rhs(t, p, u, x_grid, dx, scheme_order)\n            \n            # k2\n            p_temp = p + 0.5 * dt_current * k1_p\n            u_temp = u + 0.5 * dt_current * k1_u\n            k2_p, k2_u = compute_rhs(t + 0.5 * dt_current, p_temp, u_temp, x_grid, dx, scheme_order)\n\n            # k3\n            p_temp = p + 0.5 * dt_current * k2_p\n            u_temp = u + 0.5 * dt_current * k2_u\n            k3_p, k3_u = compute_rhs(t + 0.5 * dt_current, p_temp, u_temp, x_grid, dx, scheme_order)\n            \n            # k4\n            p_temp = p + dt_current * k3_p\n            u_temp = u + dt_current * k3_u\n            k4_p, k4_u = compute_rhs(t + dt_current, p_temp, u_temp, x_grid, dx, scheme_order)\n            \n            # Update solution\n            p += (dt_current / 6.0) * (k1_p + 2.0 * k2_p + 2.0 * k3_p + k4_p)\n            u += (dt_current / 6.0) * (k1_u + 2.0 * k2_u + 2.0 * k3_u + k4_u)\n            \n            t += dt_current\n\n        # --- Error Calculation ---\n        p_sol_exact = p_exact(x_grid, T_FINAL)\n        u_sol_exact = u_exact(x_grid, T_FINAL)\n        \n        # Using np.linalg.norm is equivalent to the formula since sqrt(dx) cancels.\n        error_p = np.linalg.norm(p - p_sol_exact) / np.linalg.norm(p_sol_exact)\n        error_u = np.linalg.norm(u - u_sol_exact) / np.linalg.norm(u_sol_exact)\n        \n        return error_p, error_u\n\n    # --- Convergence Analysis ---\n    all_results = []\n    dx_vals = 1.0 / np.array(N_VALS)\n    log_dx = np.log(dx_vals)\n    \n    for order in SCHEMES:\n        errors_p = []\n        errors_u = []\n        for n_val in N_VALS:\n            err_p, err_u = run_simulation(n_val, order)\n            errors_p.append(err_p)\n            errors_u.append(err_u)\n            \n        # Fit log(error) vs log(dx) to find the slope (order of convergence)\n        log_err_p = np.log(np.array(errors_p))\n        log_err_u = np.log(np.array(errors_u))\n        \n        # polyfit returns [slope, intercept] for degree 1\n        p_obs_p = np.polyfit(log_dx, log_err_p, 1)[0]\n        p_obs_u = np.polyfit(log_dx, log_err_u, 1)[0]\n        \n        all_results.append(p_obs_p)\n        all_results.append(p_obs_u)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Most practical combustion systems are not acoustically infinite or periodic; they are enclosed by walls, injectors, and nozzles whose acoustic behavior is critical. These boundaries are often characterized by a frequency-domain impedance, a concept that must be translated into a time-domain boundary condition for time-marching solvers. This final practice  tackles this essential task by having you derive and implement a Time-Domain Impedance Boundary Condition (TDIBC) for a common liner model. This exercise bridges the gap between theoretical acoustic models and their practical implementation in a computational solver.",
            "id": "4005980",
            "problem": "You are to derive and implement a Time-Domain Impedance Boundary Condition (TDIBC) that is second-order accurate in time for a single-pole acoustic impedance. Consider a planar boundary in a one-dimensional linear acoustic field in a combustion chamber, where the fluctuating wall-normal velocity is denoted by $u_n'(t)$ and the fluctuating acoustic pressure at the wall is $p'(t)$. The frequency-domain impedance is defined by the ratio of complex amplitudes $Z(\\omega)=\\hat{p}/\\hat{u}_n$ and is modeled as a single-pole, mass-resistance element,\n$$\nZ(\\omega)=R+i\\,\\omega M,\n$$\nwhere $R$ is the resistance with units $\\mathrm{Pa\\,s/m}$ and $M$ is the acoustic mass per unit area with units $\\mathrm{kg/m^2}$. For harmonic forcing $p'(t)=P_0\\cos(\\omega t)$ with amplitude $P_0$ in $\\mathrm{Pa}$ and angular frequency $\\omega$ in $\\mathrm{rad/s}$, the boundary relation in the time domain implied by this impedance is an ordinary differential equation coupling $p'(t)$ and $u_n'(t)$.\n\nTasks:\n1. Starting from the definition of acoustic impedance $Z(\\omega)=\\hat{p}/\\hat{u}_n$ and the given single-pole model $Z(\\omega)=R+i\\,\\omega M$, derive the corresponding time-domain relation between $p'(t)$ and $u_n'(t)$ that holds for general $p'(t)$ and $u_n'(t)$.\n2. From this time-domain relation, derive a second-order accurate in time discrete update that advances the wall-normal velocity from time $t^n$ to $t^{n+1}=t^n+\\Delta t$ using the trapezoidal rule (also known as the Crank–Nicolson method). Your discrete update must give $u_n'^{\\,n+1}$ in terms of $u_n'^{\\,n}$, $p'^{\\,n}$, and $p'^{\\,n+1}$, and be valid for arbitrary $R\\ge 0$ and $M\\ge 0$.\n3. Implement a program that uses your derived discrete update to march $u_n'^{\\,n}$ in time for several periods of harmonic excitation $p'(t)=P_0\\cos(\\omega t)$, with a time step $\\Delta t$ chosen to provide a specified number of points per period. Initialize $u_n'^{\\,0}$ consistently with the steady harmonic solution so that when $M=0$ the algebraic constraint is satisfied at $t=0$.\n4. For validation, compute the exact steady harmonic solution for $u_n'(t)$ implied by the impedance model, namely find its amplitude $C_{\\mathrm{exact}}$ and phase $\\phi_{\\mathrm{exact}}$ such that $u_n'(t)=C_{\\mathrm{exact}}\\cos(\\omega t-\\phi_{\\mathrm{exact}})$, and use it to compute the reference $u_n'(t)$ at discrete times.\n5. For each test case, advance $u_n'^{\\,n}$ for a prescribed number of periods, then compute the relative $\\ell^2$ error over the last full period,\n$$\n\\varepsilon=\\frac{\\left\\|u_n'^{\\,\\mathrm{num}}-u_n'^{\\,\\mathrm{exact}}\\right\\|_2}{\\left\\|u_n'^{\\,\\mathrm{exact}}\\right\\|_2},\n$$\nwhich is dimensionless.\n\nScientific and numerical assumptions:\n- Work in the small-amplitude, linear acoustics regime with a quiescent mean flow.\n- All quantities are in consistent International System of Units (SI): $R$ in $\\mathrm{Pa\\,s/m}$, $M$ in $\\mathrm{kg/m^2}$, $P_0$ in $\\mathrm{Pa}$, $\\omega$ in $\\mathrm{rad/s}$, and time $t$ in $\\mathrm{s}$.\n- Angles must be treated in radians.\n\nTest suite:\nUse the following test cases, each given as a tuple $(R,M,f,P_0,N_{\\mathrm{pp}},N_{\\mathrm{per}})$, where $f$ is frequency in $\\mathrm{Hz}$, $P_0$ is pressure amplitude in $\\mathrm{Pa}$, $N_{\\mathrm{pp}}$ is points per period, and $N_{\\mathrm{per}}$ is the number of simulated periods. The angular frequency is $\\omega=2\\pi f$, and the time step is $\\Delta t=\\frac{1}{f\\,N_{\\mathrm{pp}}}$.\n\n- Case 1 (general mass-resistance, happy path): $(150.0,\\,0.20,\\,300.0,\\,500.0,\\,200,\\,8)$\n- Case 2 (purely reactive mass, boundary case): $(0.0,\\,0.05,\\,300.0,\\,500.0,\\,200,\\,8)$\n- Case 3 (purely resistive, boundary case): $(200.0,\\,0.0,\\,300.0,\\,500.0,\\,200,\\,8)$\n- Case 4 (higher frequency, moderate mass): $(80.0,\\,0.02,\\,1500.0,\\,500.0,\\,150,\\,10)$\n- Case 5 (coarser time step, stress test): $(100.0,\\,0.05,\\,400.0,\\,500.0,\\,30,\\,10)$\n\nFinal output format:\n- Your program should produce a single line of output containing the relative $\\ell^2$ errors for the five test cases as a comma-separated list enclosed in square brackets, with each float in scientific notation rounded to six significant digits, for example,\n$$\n[1.234567\\mathrm{e}{-03},2.345678\\mathrm{e}{-04},\\dots].\n$$",
            "solution": "The user has provided a problem that requires the derivation and implementation of a second-order accurate Time-Domain Impedance Boundary Condition (TDIBC) for a single-pole acoustic impedance model. The problem is well-posed, scientifically sound, and contains all necessary information for a complete solution.\n\n### 1. Derivation of the Time-Domain Relation\nThe acoustic impedance $Z(\\omega)$ relates the complex amplitudes of acoustic pressure, $\\hat{p}(\\omega)$, and wall-normal velocity, $\\hat{u}_n(\\omega)$, in the frequency domain:\n$$\nZ(\\omega) = \\frac{\\hat{p}(\\omega)}{\\hat{u}_n(\\omega)}\n$$\nThe problem specifies a single-pole, mass-resistance impedance model:\n$$\nZ(\\omega) = R + i\\,\\omega M\n$$\nwhere $R$ is the acoustic resistance, $M$ is the acoustic mass per unit area, $\\omega$ is the angular frequency, and $i = \\sqrt{-1}$. Combining these two equations gives:\n$$\n\\hat{p}(\\omega) = (R + i\\,\\omega M) \\hat{u}_n(\\omega) = R\\,\\hat{u}_n(\\omega) + i\\,\\omega M\\,\\hat{u}_n(\\omega)\n$$\nTo transform this relationship into the time domain, we apply the inverse Fourier transform. The inverse Fourier transform of a product $i\\omega\\hat{f}(\\omega)$ corresponds to the time derivative $\\frac{d f(t)}{dt}$. Applying this rule to the equation term by term, we relate the time-domain fluctuating pressure $p'(t)$ and fluctuating velocity $u_n'(t)$:\n$$\np'(t) = R\\,u_n'(t) + M\\,\\frac{d u_n'(t)}{dt}\n$$\nThis is a first-order linear ordinary differential equation (ODE) that governs the relationship between pressure and velocity at the boundary in the time domain. This completes the first task.\n\n### 2. Discretization using the Trapezoidal Rule (Crank-Nicolson Method)\nThe second task is to derive a second-order accurate discrete update for $u_n'(t)$. We rearrange the ODE as:\n$$\nM\\,\\frac{d u_n'}{dt} + R\\,u_n' = p'(t)\n$$\nWe apply the trapezoidal rule (also known as the Crank-Nicolson method) to this ODE. This method is second-order accurate in time. It involves approximating the time derivative with a central difference across the interval $[t^n, t^{n+1}]$ and evaluating the other terms as an average of their values at $t^n$ and $t^{n+1}$:\n$$\nM \\left( \\frac{u_n'^{\\,n+1} - u_n'^{\\,n}}{\\Delta t} \\right) + R \\left( \\frac{u_n'^{\\,n+1} + u_n'^{\\,n}}{2} \\right) = \\frac{p'^{\\,n+1} + p'^{\\,n}}{2}\n$$\nwhere $\\Delta t = t^{n+1} - t^n$ is the time step, and the superscripts denote the time level. To find the update rule for $u_n'^{\\,n+1}$, we rearrange the equation to solve for this term. First, we multiply by $\\Delta t$:\n$$\nM (u_n'^{\\,n+1} - u_n'^{\\,n}) + \\frac{R\\Delta t}{2} (u_n'^{\\,n+1} + u_n'^{\\,n}) = \\frac{\\Delta t}{2} (p'^{\\,n+1} + p'^{\\,n})\n$$\nNext, we gather all terms with $u_n'^{\\,n+1}$ on the left-hand side and all other terms on the right-hand side:\n$$\nM u_n'^{\\,n+1} + \\frac{R\\Delta t}{2} u_n'^{\\,n+1} = M u_n'^{\\,n} - \\frac{R\\Delta t}{2} u_n'^{\\,n} + \\frac{\\Delta t}{2} (p'^{\\,n+1} + p'^{\\,n})\n$$\nFactoring out $u_n'^{\\,n+1}$ and $u_n'^{\\,n}$:\n$$\nu_n'^{\\,n+1} \\left( M + \\frac{R\\Delta t}{2} \\right) = u_n'^{\\,n} \\left( M - \\frac{R\\Delta t}{2} \\right) + \\frac{\\Delta t}{2} (p'^{\\,n+1} + p'^{\\,n})\n$$\nFinally, isolating $u_n'^{\\,n+1}$ yields the explicit update formula:\n$$\nu_n'^{\\,n+1} = \\frac{\\left( M - \\frac{R\\Delta t}{2} \\right) u_n'^{\\,n} + \\frac{\\Delta t}{2} (p'^{\\,n+1} + p'^{\\,n})}{M + \\frac{R\\Delta t}{2}}\n$$\nThis formula is valid for arbitrary $R \\ge 0$ and $M \\ge 0$, as long as $R$ and $M$ are not simultaneously zero. For the purely resistive case ($M=0$), the formula simplifies correctly, and for the purely reactive case ($R=0$), it also gives the correct trapezoidal update.\n\n### 3. Exact Harmonic Solution and Initial Condition\nFor validation, we require the exact steady-state solution for $u_n'(t)$ when the pressure forcing is harmonic, $p'(t) = P_0 \\cos(\\omega t)$. In the frequency domain, the complex pressure amplitude is $\\hat{p} = P_0$. The complex velocity amplitude is then:\n$$\n\\hat{u}_n = \\frac{\\hat{p}}{Z(\\omega)} = \\frac{P_0}{R + i\\omega M}\n$$\nTo find the corresponding time-domain signal, we express $\\hat{u}_n$ in polar form, $|\\hat{u}_n| e^{-i\\phi_{\\mathrm{exact}}}$. The time-domain velocity is the real part of $\\hat{u}_n e^{i\\omega t}$:\n$$\nu_n'(t) = \\mathrm{Re}\\left\\{ |\\hat{u}_n| e^{i(\\omega t - \\phi_{\\mathrm{exact}})} \\right\\} = |\\hat{u}_n| \\cos(\\omega t - \\phi_{\\mathrm{exact}})\n$$\nThis is of the form $C_{\\mathrm{exact}}\\cos(\\omega t-\\phi_{\\mathrm{exact}})$, with amplitude $C_{\\mathrm{exact}}$ and phase lag $\\phi_{\\mathrm{exact}}$ given by:\n$$\nC_{\\mathrm{exact}} = |\\hat{u}_n| = \\frac{|P_0|}{|R + i\\omega M|} = \\frac{P_0}{\\sqrt{R^2 + (\\omega M)^2}}\n$$\n$$\n\\phi_{\\mathrm{exact}} = \\operatorname{arctan2}(\\omega M, R)\n$$\nThe problem requires initializing the simulation such that $u_n'(0)$ is consistent with the steady harmonic solution. At $t=0$, the exact solution is:\n$$\nu_n'(0) = C_{\\mathrm{exact}} \\cos(-\\phi_{\\mathrm{exact}}) = C_{\\mathrm{exact}} \\cos(\\phi_{\\mathrm{exact}}) = \\frac{P_0}{\\sqrt{R^2 + (\\omega M)^2}} \\cdot \\frac{R}{\\sqrt{R^2 + (\\omega M)^2}} = \\frac{P_0 R}{R^2 + (\\omega M)^2}\n$$\nThis value will be used for the initial condition $u_n'^{\\,0}$.\n\n### 4. Error Calculation\nThe numerical solution $u_n'^{\\,\\mathrm{num}}$ is advanced in time from $t=0$ for a determined number of periods. The error is computed over the last full period of simulation to ensure any initial transient effects have decayed and the numerical solution has reached a periodic steady state. The relative $\\ell^2$ error, $\\varepsilon$, is calculated as:\n$$\n\\varepsilon=\\frac{\\left\\|u_n'^{\\,\\mathrm{num}}-u_n'^{\\,\\mathrm{exact}}\\right\\|_2}{\\left\\|u_n'^{\\,\\mathrm{exact}}\\right\\|_2}\n$$\nwhere the vectors contain the numerical and exact solutions at the discrete time points spanning the last period. The $\\ell^2$ norm of a vector $v$ with $N$ elements is $\\|v\\|_2 = \\sqrt{\\sum_{i=1}^N v_i^2}$.\n\nThe implementation will proceed by calculating these quantities for each test case and reporting the resulting error $\\varepsilon$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_tdibc_error(R, M, f, P0, N_pp, N_per):\n    \"\"\"\n    Calculates the relative l2 error for the TDIBC problem.\n\n    Args:\n        R (float): Acoustic resistance (Pa*s/m).\n        M (float): Acoustic mass per unit area (kg/m^2).\n        f (float): Frequency (Hz).\n        P0 (float): Pressure amplitude (Pa).\n        N_pp (int): Number of points per period.\n        N_per (int): Number of periods to simulate.\n\n    Returns:\n        float: The relative l2 error.\n    \"\"\"\n    # 1. Define simulation parameters\n    omega = 2.0 * np.pi * f\n    dt = 1.0 / (f * N_pp)\n    num_steps = N_pp * N_per\n    \n    # Create time vector and pressure forcing function\n    t = np.linspace(0.0, num_steps * dt, num_steps + 1)\n    p_prime = P0 * np.cos(omega * t)\n\n    # 2. Derive the exact analytical solution\n    # The absolute value of the impedance Z(omega) = R + i*omega*M\n    Z_abs = np.sqrt(R**2 + (omega * M)**2)\n    # Amplitude of the velocity u_n'(t)\n    C_exact = P0 / Z_abs if Z_abs > 1e-15 else 0.0\n    # Phase lag of u_n'(t) with respect to p'(t)\n    phi_exact = np.arctan2(omega * M, R)\n    # The exact velocity solution u_n'(t)\n    u_n_exact = C_exact * np.cos(omega * t - phi_exact)\n\n    # 3. Perform the numerical time marching\n    u_n_num = np.zeros(num_steps + 1)\n    \n    # Set the initial condition consistent with the steady harmonic solution\n    # u_n'(0) = C_exact * cos(phi_exact) = P0*R / (R^2 + (omega*M)^2)\n    denominator_ic = R**2 + (omega * M)**2\n    if denominator_ic > 1e-15:\n        u_n_num[0] = (P0 * R) / denominator_ic\n    else:\n        # This case (R=0, M=0) is not in the test suite. Z=0 means p'=0.\n        # If P0 is non-zero, the problem is ill-defined.\n        u_n_num[0] = 0.0\n\n    # Define coefficients for the Crank-Nicolson update scheme\n    # u_n'^{n+1} = coeff1 * u_n'^{n} + coeff2 * (p'^{n} + p'^{n+1})\n    den_update = M + R * dt / 2.0\n    \n    # This denominator is only zero if R=0 and M=0, not in test cases.\n    if abs(den_update)  1e-15:\n        return np.nan # Avoid division by zero\n\n    coeff1 = (M - R * dt / 2.0) / den_update\n    coeff2 = (dt / 2.0) / den_update\n    \n    # Time-marching loop\n    for n in range(num_steps):\n        u_n_num[n+1] = coeff1 * u_n_num[n] + coeff2 * (p_prime[n] + p_prime[n+1])\n\n    # 4. Compute the relative l2 error over the last period\n    start_index = num_steps - N_pp\n    \n    # Extract the solutions over the last full period (N_pp+1 points)\n    u_n_num_last_period = u_n_num[start_index:]\n    u_n_exact_last_period = u_n_exact[start_index:]\n    \n    # Calculate the L2 norms\n    norm_error = np.linalg.norm(u_n_num_last_period - u_n_exact_last_period)\n    norm_exact = np.linalg.norm(u_n_exact_last_period)\n    \n    if norm_exact  1e-15:\n        # This occurs if the exact solution is zero (e.g., P0=0).\n        # If the numerical solution is also zero, the error is 0.\n        return 0.0 if norm_error  1e-15 else np.inf\n\n    relative_error = norm_error / norm_exact\n    return relative_error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple is (R, M, f, P0, N_pp, N_per)\n    test_cases = [\n        (150.0, 0.20, 300.0, 500.0, 200, 8),   # Case 1: General\n        (0.0, 0.05, 300.0, 500.0, 200, 8),    # Case 2: Purely reactive\n        (200.0, 0.0, 300.0, 500.0, 200, 8),    # Case 3: Purely resistive\n        (80.0, 0.02, 1500.0, 500.0, 150, 10),  # Case 4: High frequency\n        (100.0, 0.05, 400.0, 500.0, 30, 10),   # Case 5: Coarse time step\n    ]\n\n    results = []\n    for case in test_cases:\n        R, M, f, P0, N_pp, N_per = case\n        error = calculate_tdibc_error(R, M, f, P0, N_pp, N_per)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    # Scientific notation with 6 significant digits (1 digit before '.', 5 after).\n    formatted_results = [f\"{res:.5e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}