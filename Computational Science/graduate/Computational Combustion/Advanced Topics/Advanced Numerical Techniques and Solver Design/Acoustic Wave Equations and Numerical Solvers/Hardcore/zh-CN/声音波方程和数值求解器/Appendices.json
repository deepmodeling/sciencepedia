{
    "hands_on_practices": [
        {
            "introduction": "在计算科学中，确保代码的正确性至关重要，而“人造解方法”（Method of Manufactured Solutions, MMS）是用于此目的的一种严谨技术。该方法的核心思想是，我们首先假定一个平滑的解析函数作为方程的“人造”精确解，然后反向推导出必须添加到原始方程中的源项以及相应的边界和初始条件。本练习将引导你完成MMS的第一步：为一个具有非均匀声速的声波方程推导源项和边界/初始条件，从而为后续的数值验证打下坚实的理论基础。",
            "id": "4005922",
            "problem": "在低马赫数反应流中，围绕具有空间变化声速的静态基态的线性化小振幅声学，其主导项可以由一个标量声压扰动场 $p(x,t)$ 来建模。该场在一维域 $x \\in [0,L]$ 上由以下非齐次双曲方程控制：\n$$\np_{tt}(x,t) - \\partial_{x}\\!\\left(c^{2}(x)\\,p_{x}(x,t)\\right) \\;=\\; s(x,t),\n$$\n其中 $c(x)$ 是局部声速，$s(x,t)$ 是一个体源项，例如代表非定常放热耦合或用于验证的人工强迫项。假设 $c(x)$ 根据以下公式平滑变化：\n$$\nc(x) \\;=\\; c_{0}\\,\\sqrt{1+\\alpha\\,\\frac{x}{L}},\n$$\n其中常数 $c_{0}0$, $L0$, 且 $\\alpha-1$，因此 $c(x)$ 在 $[0,L]$ 上为实数且严格为正。在人工解方法 (Method of Manufactured Solutions, MMS) 中，我们假设一个精确且足够光滑的解，并推导出使其成为精确解所需的强迫项以及边界/初始数据。\n\n设人工解为\n$$\np^{\\star}(x,t) \\;=\\; \\exp\\!\\left(\\lambda x\\right)\\,\\cos\\!\\left(\\omega t\\right),\n$$\n其中常数 $\\lambda \\in \\mathbb{R}$ 且 $\\omega0$。仅使用基本微分学、链式法则和给定的控制方程，完成以下任务：\n\n1. 推导源项 $s(x,t)$ 的闭式表达式，该表达式使 $p^{\\star}(x,t)$ 成为一个精确解。\n2. 分别推导在 $x=0$ 和 $x=L$ 处的一致狄利克雷边界数据 $g_{0}(t)$ 和 $g_{L}(t)$，以在边界上对所有 $t \\ge 0$ 强制实施 $p(x,t)=p^{\\star}(x,t)$。\n3. 推导一致的初始数据 $p(x,0)$ 和 $p_{t}(x,0)$，以对所有 $x \\in [0,L]$ 强制实施 $p(x,0)=p^{\\star}(x,0)$ 和 $p_{t}(x,0)=\\partial_{t}p^{\\star}(x,0)$。\n\n将你的最终答案报告为 $s(x,t)$ 的单一闭式表达式，用 $x$、$t$、$c_{0}$、$\\alpha$、$L$、$\\lambda$ 和 $\\omega$ 表示。不需要进行数值计算，也不需要四舍五入。最终答案中不要包含任何单位。",
            "solution": "用户提供了一个有效的问题陈述。该问题在声学和计算物理领域具有科学依据，具体涉及变系数线性波动方程的人工解方法 (MMS)。问题提法得当、客观，并包含推导所求量所需的全部信息。没有逻辑矛盾、事实错误或含糊不清之处。\n\n目标是推导源项 $s(x,t)$ 以及相应的边界和初始数据，使人工解 $p^{\\star}(x,t)$ 成为给定偏微分方程的精确解。\n\n控制方程为：\n$$\np_{tt}(x,t) - \\partial_{x}\\!\\left(c^{2}(x)\\,p_{x}(x,t)\\right) \\;=\\; s(x,t)\n$$\n通过重新整理，源项由下式给出：\n$$\ns(x,t) \\;=\\; p_{tt}(x,t) - \\partial_{x}\\!\\left(c^{2}(x)\\,p_{x}(x,t)\\right)\n$$\n人工解给出如下：\n$$\np^{\\star}(x,t) \\;=\\; \\exp\\!\\left(\\lambda x\\right)\\,\\cos\\!\\left(\\omega t\\right)\n$$\n空间变化的声速为：\n$$\nc(x) \\;=\\; c_{0}\\,\\sqrt{1+\\alpha\\,\\frac{x}{L}}\n$$\n由此得到声速的平方为：\n$$\nc^{2}(x) \\;=\\; c_{0}^{2}\\left(1+\\alpha\\,\\frac{x}{L}\\right)\n$$\n为了求得 $s(x,t)$，我们必须计算 $p^{\\star}(x,t)$ 的必要偏导数，并将其代入 $s(x,t)$ 的表达式中。\n\n首先，我们计算 $p^{\\star}(x,t)$ 的时间导数：\n关于时间 $t$ 的一阶偏导数为：\n$$\np_{t}(x,t) = \\frac{\\partial}{\\partial t}\\left(\\exp\\!\\left(\\lambda x\\right)\\,\\cos\\!\\left(\\omega t\\right)\\right) = -\\omega\\,\\exp\\!\\left(\\lambda x\\right)\\,\\sin\\!\\left(\\omega t\\right)\n$$\n关于时间 $t$ 的二阶偏导数为：\n$$\np_{tt}(x,t) = \\frac{\\partial}{\\partial t}\\left(-\\omega\\,\\exp\\!\\left(\\lambda x\\right)\\,\\sin\\!\\left(\\omega t\\right)\\right) = -\\omega^{2}\\,\\exp\\!\\left(\\lambda x\\right)\\,\\cos\\!\\left(\\omega t\\right)\n$$\n\n接下来，我们计算 $p^{\\star}(x,t)$ 的一阶空间导数：\n$$\np_{x}(x,t) = \\frac{\\partial}{\\partial x}\\left(\\exp\\!\\left(\\lambda x\\right)\\,\\cos\\!\\left(\\omega t\\right)\\right) = \\lambda\\,\\exp\\!\\left(\\lambda x\\right)\\,\\cos\\!\\left(\\omega t\\right)\n$$\n\n现在，我们构造项 $c^{2}(x)\\,p_{x}(x,t)$：\n$$\nc^{2}(x)\\,p_{x}(x,t) = \\left(c_{0}^{2}\\left(1+\\alpha\\,\\frac{x}{L}\\right)\\right)\\left(\\lambda\\,\\exp\\!\\left(\\lambda x\\right)\\,\\cos\\!\\left(\\omega t\\right)\\right) = c_{0}^{2}\\lambda\\left(1+\\alpha\\,\\frac{x}{L}\\right)\\exp(\\lambda x)\\cos(\\omega t)\n$$\n然后我们使用乘法法则对该表达式关于 $x$ 求导。对于函数 $f(x) = u(x)v(x)$，其导数为 $f'(x) = u'(x)v(x) + u(x)v'(x)$。令 $u(x) = 1+\\alpha\\frac{x}{L}$ 且 $v(x) = \\exp(\\lambda x)$。项 $c_{0}^{2}\\lambda\\cos(\\omega t)$ 相对于 $x$ 是一个常数。\n$$\n\\partial_{x}\\!\\left(c^{2}(x)\\,p_{x}(x,t)\\right) = c_{0}^{2}\\lambda\\cos(\\omega t)\\,\\frac{\\partial}{\\partial x}\\left[ \\left(1+\\alpha\\,\\frac{x}{L}\\right)\\exp(\\lambda x) \\right]\n$$\n应用乘法法则：\n$$\n\\frac{\\partial}{\\partial x}\\left[ \\left(1+\\alpha\\,\\frac{x}{L}\\right)\\exp(\\lambda x) \\right] = \\left(\\frac{\\alpha}{L}\\right)\\exp(\\lambda x) + \\left(1+\\alpha\\,\\frac{x}{L}\\right)(\\lambda\\exp(\\lambda x))\n$$\n提出公因子 $\\exp(\\lambda x)$：\n$$\n= \\left[ \\frac{\\alpha}{L} + \\lambda\\left(1+\\alpha\\,\\frac{x}{L}\\right) \\right] \\exp(\\lambda x)\n$$\n将其代回，我们得到：\n$$\n\\partial_{x}\\!\\left(c^{2}(x)\\,p_{x}(x,t)\\right) = c_{0}^{2}\\lambda\\cos(\\omega t)\\left[ \\frac{\\alpha}{L} + \\lambda\\left(1+\\alpha\\,\\frac{x}{L}\\right) \\right] \\exp(\\lambda x)\n$$\n$$\n= \\left[ \\frac{\\alpha\\lambda c_{0}^{2}}{L} + \\lambda^{2}c_{0}^{2}\\left(1+\\alpha\\,\\frac{x}{L}\\right) \\right] \\exp(\\lambda x)\\cos(\\omega t)\n$$\n\n最后，我们将 $p_{tt}$ 和 $\\partial_{x}(c^{2}p_{x})$ 的表达式代入 $s(x,t)$ 的方程中：\n$$\ns(x,t) = p_{tt}(x,t) - \\partial_{x}\\!\\left(c^{2}(x)\\,p_{x}(x,t)\\right)\n$$\n$$\ns(x,t) = -\\omega^{2}\\exp(\\lambda x)\\cos(\\omega t) - \\left[ \\frac{\\alpha\\lambda c_{0}^{2}}{L} + \\lambda^{2}c_{0}^{2}\\left(1+\\alpha\\,\\frac{x}{L}\\right) \\right] \\exp(\\lambda x)\\cos(\\omega t)\n$$\n提出公因子 $\\exp(\\lambda x)\\cos(\\omega t)$：\n$$\ns(x,t) = -\\left[ \\omega^{2} + \\frac{\\alpha\\lambda c_{0}^{2}}{L} + \\lambda^{2}c_{0}^{2}\\left(1+\\alpha\\,\\frac{x}{L}\\right) \\right] \\exp(\\lambda x)\\cos(\\omega t)\n$$\n这就是源项 $s(x,t)$ 的闭式表达式，满足了问题的第一个要求。\n\n为完整起见，我们推导一致的边界和初始数据。\n\n1. 狄利克雷边界数据：\n在 $x=0$ 处的边界数据 $g_{0}(t)$ 和在 $x=L$ 处的边界数据 $g_{L}(t)$ 可通过在这些位置上计算人工解 $p^{\\star}(x,t)$ 的值得到。\n在 $x=0$ 处：\n$$\ng_{0}(t) = p^{\\star}(0,t) = \\exp(\\lambda \\cdot 0)\\cos(\\omega t) = \\cos(\\omega t)\n$$\n在 $x=L$ 处：\n$$\ng_{L}(t) = p^{\\star}(L,t) = \\exp(\\lambda L)\\cos(\\omega t)\n$$\n\n2. 初始数据：\n初始数据 $p(x,0)$ 和 $p_{t}(x,0)$ 可通过在 $t=0$ 时计算 $p^{\\star}(x,t)$ 及其时间导数 $p^{\\star}_{t}(x,t)$ 的值得到。\n初始压力场：\n$$\np(x,0) = p^{\\star}(x,0) = \\exp(\\lambda x)\\cos(\\omega \\cdot 0) = \\exp(\\lambda x)\n$$\n初始压力变化率：\n$$\np_{t}(x,0) = \\left. \\frac{\\partial p^{\\star}}{\\partial t} \\right|_{t=0} = \\left. \\left( -\\omega\\,\\exp\\!\\left(\\lambda x\\right)\\,\\sin\\!\\left(\\omega t\\right) \\right) \\right|_{t=0} = -\\omega\\,\\exp\\!\\left(\\lambda x\\right)\\,\\sin(0) = 0\n$$\n\n问题要求将 $s(x,t)$ 的单一闭式表达式作为最终答案。\n$$\ns(x,t) = -\\left[ \\omega^{2} + \\lambda^{2} c_{0}^{2} \\left(1+\\alpha\\frac{x}{L}\\right) + \\frac{\\alpha \\lambda c_{0}^{2}}{L} \\right] \\exp(\\lambda x)\\cos(\\omega t)\n$$",
            "answer": "$$\\boxed{-\\left[ \\omega^{2} + \\lambda^{2} c_{0}^{2} \\left(1+\\alpha\\frac{x}{L}\\right) + \\frac{\\alpha \\lambda c_{0}^{2}}{L} \\right] \\exp(\\lambda x)\\cos(\\omega t)}$$"
        },
        {
            "introduction": "在前一个练习的基础上，本实践将“人造解方法”付诸行动。在分析推导出源项之后，关键的下一步是在数值求解器中实现它们，并验证代码是否达到了其理论收敛阶。本练习要求你编写代码，求解带有人造源项的声学方程组，并通过在不断加密的网格上计算误差来分析其收敛行为，这是计算科学家必须掌握的一项基本技能。",
            "id": "4005931",
            "problem": "考虑在等熵和无粘性近似下，均匀反应混合物中的一维小振幅声学问题。其线性化方程将周期性域 $x \\in [0,1]$ 上的无量纲压力 $p(x,t)$ 和无量纲速度 $u(x,t)$ 耦合如下：\n$$\n\\frac{\\partial p}{\\partial t} + \\frac{\\partial u}{\\partial x} = S_p(x,t), \\qquad \\frac{\\partial u}{\\partial t} + \\frac{\\partial p}{\\partial x} = S_u(x,t),\n$$\n其中，人造解方法 (Method of Manufactured Solutions, MMS) 指定了一个精确解，并且选择源项 $S_p(x,t)$ 和 $S_u(x,t)$ 以使该精确解能恒等满足方程。假设已经使用特征密度 $\\rho_0 = 1$ 和声速 $c = 1$ 进行了无量纲化，因此所有变量都是无量纲的，并且三角函数中使用的角度以弧度为单位。\n\n从可压缩流体的质量和动量守恒出发，围绕具有恒定基准密度的静止状态进行线性化，再结合等熵关系 $p = c^2 \\rho$，即可得到上述耦合关系作为基本方程。对于 MMS，取人造场为：\n$$\np^{\\star}(x,t) = \\sin(\\kappa x)\\cos(\\omega t), \\qquad u^{\\star}(x,t) = \\sin(\\kappa x)\\sin(\\omega t),\n$$\n其中 $\\kappa = 2\\pi m$（$m$ 为域上的整数波数），$\\omega = 2\\pi$ 以使时间周期为 $1$。推导源项 $S_p(x,t)$ 和 $S_u(x,t)$，以确保 $p^{\\star}$ 和 $u^{\\star}$ 精确满足偏微分方程。在具有 $N$ 个点的均匀网格上，为一阶导数实现两种空间离散化方法：\n- 二阶中心差分格式，\n- 四阶中心差分格式。\n\n使用显式经典四阶 Runge–Kutta 时间步进，并根据 Courant–Friedrichs–Lewy 数 $\\nu$ 选择时间步长 $\\Delta t = \\nu \\Delta x$，其中 $\\Delta x = 1/N$ 且 $\\nu = 0.2$。使用周期性边界条件，从 $t=0$ 积分到最终时间 $t=T$，其中 $T = 0.3$。使用 $p(x,0) = p^{\\star}(x,0)$ 和 $u(x,0) = u^{\\star}(x,0)$ 进行初始化。\n\n对于每种空间格式，计算 $t=T$ 时 $p$ 和 $u$ 经过网格加密后的离散相对 $L_2$ 误差。将场 $f$ 的离散相对 $L_2$ 误差定义为：\n$$\n\\varepsilon_{L_2}(f) = \\frac{\\left( \\Delta x \\sum_{i=0}^{N-1} \\left[f_i^{\\text{num}}(T) - f_i^{\\star}(T)\\right]^2 \\right)^{1/2}}{\\left( \\Delta x \\sum_{i=0}^{N-1} \\left[f_i^{\\star}(T)\\right]^2 \\right)^{1/2}}.\n$$\n通过对不同网格尺寸的 $\\log(\\varepsilon_{L_2})$ 与 $\\log(\\Delta x)$ 的关系进行线性拟合，并取其斜率，来估计每个场和每种格式的观测收敛阶 $p_{\\text{obs}}$。\n\n你的程序必须实现以上内容，并使用以下测试套件，为每种空间格式下的 $p$ 和 $u$ 生成观测收敛阶：\n- 二阶格式，$m=1$，$N \\in \\{32,64,128,256\\}$，\n- 四阶格式，$m=1$，$N \\in \\{32,64,128,256\\}$。\n\n所有量均为无量纲，角度以弧度为单位。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为 $[p_{\\text{obs}}^{(2)}, u_{\\text{obs}}^{(2)}, p_{\\text{obs}}^{(4)}, u_{\\text{obs}}^{(4)}]$，其中上标表示空间格式的阶数。每个条目必须是四舍五入到三位小数的浮点数。",
            "solution": "在尝试求解之前，该问题需经过正式的验证过程。\n\n### 步骤 1：提取已知信息\n\n问题陈述中提供了以下信息：\n-   **控制方程**：\n    $$\n    \\frac{\\partial p}{\\partial t} + \\frac{\\partial u}{\\partial x} = S_p(x,t), \\qquad \\frac{\\partial u}{\\partial t} + \\frac{\\partial p}{\\partial x} = S_u(x,t)\n    $$\n-   **区域**：周期性，$x \\in [0,1]$。\n-   **无量纲常数**：特征密度 $\\rho_0 = 1$，声速 $c = 1$。\n-   **人造解**：\n    $$\n    p^{\\star}(x,t) = \\sin(\\kappa x)\\cos(\\omega t), \\qquad u^{\\star}(x,t) = \\sin(\\kappa x)\\sin(\\omega t)\n    $$\n-   **人造解参数**：$\\kappa = 2\\pi m$，$m$ 为整数波数，$\\omega = 2\\pi$。\n-   **数值网格**：具有 $N$ 个点的均匀网格，网格间距 $\\Delta x = 1/N$。\n-   **空间离散格式**：\n    1.  二阶中心差分。\n    2.  四阶中心差分。\n-   **时间离散格式**：经典四阶 Runge-Kutta (RK4)。\n-   **时间步长**：$\\Delta t = \\nu \\Delta x$，Courant–Friedrichs–Lewy (CFL) 数 $\\nu = 0.2$。\n-   **模拟时间**：从 $t=0$ 积分到 $T=0.3$。\n-   **初始条件**：$p(x,0) = p^{\\star}(x,0)$，$u(x,0) = u^{\\star}(x,0)$。\n-   **误差度量**：场 $f$ 的离散相对 $L_2$ 误差：\n    $$\n    \\varepsilon_{L_2}(f) = \\frac{\\left( \\Delta x \\sum_{i=0}^{N-1} \\left[f_i^{\\text{num}}(T) - f_i^{\\star}(T)\\right]^2 \\right)^{1/2}}{\\left( \\Delta x \\sum_{i=0}^{N-1} \\left[f_i^{\\star}(T)\\right]^2 \\right)^{1/2}}\n    $$\n-   **收敛阶估计**：观测收敛阶 $p_{\\text{obs}}$ 是对 $\\log(\\varepsilon_{L_2})$ 与 $\\log(\\Delta x)$ 进行线性拟合后的斜率。\n-   **测试套件**：\n    -   二阶格式：$m=1$，$N \\in \\{32, 64, 128, 256\\}$。\n    -   四阶格式：$m=1$，$N \\in \\{32, 64, 128, 256\\}$。\n-   **输出格式**：一个逗号分隔的列表 $[p_{\\text{obs}}^{(2)}, u_{\\text{obs}}^{(2)}, p_{\\text{obs}}^{(4)}, u_{\\text{obs}}^{(4)}]$，数值四舍五入到三位小数。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n根据验证标准对问题进行评估：\n-   **有科学依据**：该问题建立在线性化声学方程之上，这是流体动力学中的一个基本模型。人造解方法 (MMS) 是一种用于验证数值代码实现正确性的标准且严谨的技术。所有方面都与计算物理学的既定原则一致。\n-   **适定的**：该问题描述了一个双曲型偏微分方程 (PDEs) 组的适定初边值问题。初始条件、周期性边界条件和源项（待推导）都已明确指定，确保了唯一解的存在。所提出的数值方法是解决此类问题的标准方法。\n-   **客观的**：问题以精确、无歧义的数学和技术语言陈述，不含主观或基于观点的元素。\n\n该问题没有表现出任何所列的缺陷，例如科学上不合理、不完整、矛盾或歧义。\n\n### 步骤 3：结论与行动\n\n问题陈述被视为**有效**。将按照指定要求制定解决方案。\n\n### 解的推导与方法\n\n解决方案需要几个步骤：为人造解方法 (MMS) 推导源项，实现数值离散格式，以及分析模拟结果以确定收敛阶。\n\n**1. 源项的推导**\n\n源项 $S_p(x,t)$ 和 $S_u(x,t)$ 的定义是为了使人造解 $p^{\\star}(x,t)$ 和 $u^{\\star}(x,t)$ 能精确满足控制偏微分方程。我们将 $p^{\\star}$ 和 $u^{\\star}$ 代入偏微分方程。\n\n首先，我们计算人造解的必要偏导数：\n$$\np^{\\star}(x,t) = \\sin(\\kappa x)\\cos(\\omega t) \\\\\nu^{\\star}(x,t) = \\sin(\\kappa x)\\sin(\\omega t)\n$$\n导数如下：\n$$\n\\frac{\\partial p^{\\star}}{\\partial t} = -\\omega \\sin(\\kappa x)\\sin(\\omega t) \\\\\n\\frac{\\partial p^{\\star}}{\\partial x} = \\kappa \\cos(\\kappa x)\\cos(\\omega t) \\\\\n\\frac{\\partial u^{\\star}}{\\partial t} = \\omega \\sin(\\kappa x)\\cos(\\omega t) \\\\\n\\frac{\\partial u^{\\star}}{\\partial x} = \\kappa \\cos(\\kappa x)\\sin(\\omega t)\n$$\n将这些导数代入控制方程，得到源项：\n$$\nS_p(x,t) = \\frac{\\partial p^{\\star}}{\\partial t} + \\frac{\\partial u^{\\star}}{\\partial x} = -\\omega \\sin(\\kappa x)\\sin(\\omega t) + \\kappa \\cos(\\kappa x)\\sin(\\omega t) = \\left( \\kappa \\cos(\\kappa x) - \\omega \\sin(\\kappa x) \\right) \\sin(\\omega t)\n$$\n$$\nS_u(x,t) = \\frac{\\partial u^{\\star}}{\\partial t} + \\frac{\\partial p^{\\star}}{\\partial x} = \\omega \\sin(\\kappa x)\\cos(\\omega t) + \\kappa \\cos(\\kappa x)\\cos(\\omega t) = \\left( \\omega \\sin(\\kappa x) + \\kappa \\cos(\\kappa x) \\right) \\cos(\\omega t)\n$$\n这些 $S_p$ 和 $S_u$ 的表达式必须在数值求解器中实现。\n\n**2. 数值离散化**\n\n该问题使用方法线法 (method of lines) 求解，即首先对空间导数进行离散化，将偏微分方程组 (PDEs) 转换为一个关于时间的大型常微分方程 (ODEs) 组。\n\n空间域 $x \\in [0,1]$ 被离散为 $N$ 个网格点 $x_i = i \\Delta x$，$i = 0, 1, \\dots, N-1$，其中网格间距为 $\\Delta x = 1/N$。解场 $p(x,t)$ 和 $u(x,t)$ 由网格函数 $p_i(t) \\approx p(x_i,t)$ 和 $u_i(t) \\approx u(x_i,t)$ 近似。\n\n半离散化的 ODE 系统为：\n$$\n\\frac{d p_i}{dt} = -(\\mathcal{D}_x u)_i + S_p(x_i, t) \\\\\n\\frac{d u_i}{dt} = -(\\mathcal{D}_x p)_i + S_u(x_i, t)\n$$\n其中 $\\mathcal{D}_x$ 是空间导数 $\\frac{\\partial}{\\partial x}$ 的有限差分算子。\n\n-   **二阶中心差分 ($\\mathcal{D}_x^{(2)}$)**：对于网格函数 $f_i$，二阶精度的中心差分为：\n    $$\n    (\\mathcal{D}_x^{(2)} f)_i = \\frac{f_{i+1} - f_{i-1}}{2\\Delta x}\n    $$\n    周期性边界条件意味着索引是对 $N$ 取模，即 $f_{-1} = f_{N-1}$ 和 $f_{N} = f_0$。\n\n-   **四阶中心差分 ($\\mathcal{D}_x^{(4)}$)**：四阶精度的中心差分为：\n    $$\n    (\\mathcal{D}_x^{(4)} f)_i = \\frac{-f_{i+2} + 8 f_{i+1} - 8 f_{i-1} + f_{i-2}}{12\\Delta x}\n    $$\n    同样，周期性边界条件应用于索引。\n\n然后，使用经典的四阶 Runge-Kutta (RK4) 方法对该 ODE 系统进行时间积分。对于一个 ODE 系统 $\\frac{d\\mathbf{V}}{dt} = \\mathbf{F}(t, \\mathbf{V})$，其中 $\\mathbf{V}(t) = [p_0, \\dots, p_{N-1}, u_0, \\dots, u_{N-1}]^T$，从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的 RK4 更新过程如下：\n$$\n\\mathbf{k}_1 = \\mathbf{F}(t_n, \\mathbf{V}_n) \\\\\n\\mathbf{k}_2 = \\mathbf{F}(t_n + \\frac{\\Delta t}{2}, \\mathbf{V}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = \\mathbf{F}(t_n + \\frac{\\Delta t}{2}, \\mathbf{V}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = \\mathbf{F}(t_n + \\Delta t, \\mathbf{V}_n + \\Delta t \\mathbf{k}_3) \\\\\n\\mathbf{V}_{n+1} = \\mathbf{V}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n时间步长由 CFL 条件固定：$\\Delta t = \\nu \\Delta x = 0.2 \\Delta x$。\n\n**3. 验证过程**\n\n模拟从 $t=0$ 时的初始条件开始：\n$$\np(x,0) = p^{\\star}(x,0) = \\sin(\\kappa x)\\cos(0) = \\sin(\\kappa x) \\\\\nu(x,0) = u^{\\star}(x,0) = \\sin(\\kappa x)\\sin(0) = 0\n$$\n对每个网格分辨率 $N \\in \\{32, 64, 128, 256\\}$ 运行模拟，直到最终时间 $T=0.3$。在 $t=T$ 时，通过在网格点上比较数值解 $f^{\\text{num}}$ 和精确解 $f^{\\star}$，计算 $p$ 和 $u$ 的离散相对 $L_2$ 误差 $\\varepsilon_{L_2}$。\n\n收敛阶由误差行为满足 $\\varepsilon_{L_2} \\approx C (\\Delta x)^{p_{\\text{obs}}}$ (对于某个常数 $C$) 的假设来确定。对此关系取对数可得：\n$$\n\\log(\\varepsilon_{L_2}) \\approx \\log(C) + p_{\\text{obs}} \\log(\\Delta x)\n$$\n这表明 $\\log(\\varepsilon_{L_2})$ 和 $\\log(\\Delta x)$ 之间存在线性关系。这条线的斜率即为观测收敛阶 $p_{\\text{obs}}$。通过对从不同网格分辨率 $N_j$ 获得的数据点集 $(\\log(\\Delta x_j), \\log(\\varepsilon_{j}))$ 进行线性最小二乘回归来估计该值。对两个场 ($p$, $u$) 和两种空间格式（二阶和四阶）重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Method of Manufactured Solutions for the 1D linearized\n    acoustic equations, computes grid refinement errors, and determines\n    the observed order of convergence for 2nd and 4th-order spatial schemes.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    M_WAVENUMBER = 1\n    NU_CFL = 0.2\n    T_FINAL = 0.3\n    N_VALS = [32, 64, 128, 256]\n    SCHEMES = [2, 4]\n    \n    KAPPA = 2.0 * np.pi * M_WAVENUMBER\n    OMEGA = 2.0 * np.pi\n\n    # --- Manufactured Solution and Source Terms ---\n    def p_exact(x, t):\n        return np.sin(KAPPA * x) * np.cos(OMEGA * t)\n\n    def u_exact(x, t):\n        return np.sin(KAPPA * x) * np.sin(OMEGA * t)\n\n    def Sp_source(x, t):\n        term1 = KAPPA * np.cos(KAPPA * x)\n        term2 = -OMEGA * np.sin(KAPPA * x)\n        return (term1 + term2) * np.sin(OMEGA * t)\n\n    def Su_source(x, t):\n        term1 = OMEGA * np.sin(KAPPA * x)\n        term2 = KAPPA * np.cos(KAPPA * x)\n        return (term1 + term2) * np.cos(OMEGA * t)\n\n    # --- Spatial Derivative Operators ---\n    def deriv_2nd(f, dx):\n        \"\"\"Computes 2nd-order centered difference with periodic BCs.\"\"\"\n        f_im1 = np.roll(f, 1)\n        f_ip1 = np.roll(f, -1)\n        return (f_ip1 - f_im1) / (2.0 * dx)\n\n    def deriv_4th(f, dx):\n        \"\"\"Computes 4th-order centered difference with periodic BCs.\"\"\"\n        f_im2 = np.roll(f, 2)\n        f_im1 = np.roll(f, 1)\n        f_ip1 = np.roll(f, -1)\n        f_ip2 = np.roll(f, -2)\n        return (-f_ip2 + 8.0 * f_ip1 - 8.0 * f_im1 + f_im2) / (12.0 * dx)\n\n    # --- RHS of the ODE system dV/dt = F(t, V) ---\n    def compute_rhs(t, p_vec, u_vec, x_grid, dx, scheme_order):\n        if scheme_order == 2:\n            dp_dx = deriv_2nd(p_vec, dx)\n            du_dx = deriv_2nd(u_vec, dx)\n        elif scheme_order == 4:\n            dp_dx = deriv_4th(p_vec, dx)\n            du_dx = deriv_4th(u_vec, dx)\n        else:\n            raise ValueError(\"Unsupported scheme order\")\n            \n        rhs_p = -du_dx + Sp_source(x_grid, t)\n        rhs_u = -dp_dx + Su_source(x_grid, t)\n        \n        return rhs_p, rhs_u\n\n    # --- Main simulation runner ---\n    def run_simulation(N, scheme_order):\n        # Grid and time step setup\n        dx = 1.0 / N\n        dt = NU_CFL * dx\n        x_grid = np.linspace(0.0, 1.0, N, endpoint=False)\n\n        # Initial conditions\n        p = p_exact(x_grid, 0.0)\n        u = u_exact(x_grid, 0.0)\n        t = 0.0\n\n        # Time integration loop (RK4)\n        while t  T_FINAL:\n            # Prevent overstepping final time\n            dt_current = min(dt, T_FINAL - t)\n            \n            # k1\n            k1_p, k1_u = compute_rhs(t, p, u, x_grid, dx, scheme_order)\n            \n            # k2\n            p_temp = p + 0.5 * dt_current * k1_p\n            u_temp = u + 0.5 * dt_current * k1_u\n            k2_p, k2_u = compute_rhs(t + 0.5 * dt_current, p_temp, u_temp, x_grid, dx, scheme_order)\n\n            # k3\n            p_temp = p + 0.5 * dt_current * k2_p\n            u_temp = u + 0.5 * dt_current * k2_u\n            k3_p, k3_u = compute_rhs(t + 0.5 * dt_current, p_temp, u_temp, x_grid, dx, scheme_order)\n            \n            # k4\n            p_temp = p + dt_current * k3_p\n            u_temp = u + dt_current * k3_u\n            k4_p, k4_u = compute_rhs(t + dt_current, p_temp, u_temp, x_grid, dx, scheme_order)\n            \n            # Update solution\n            p += (dt_current / 6.0) * (k1_p + 2.0 * k2_p + 2.0 * k3_p + k4_p)\n            u += (dt_current / 6.0) * (k1_u + 2.0 * k2_u + 2.0 * k3_u + k4_u)\n            \n            t += dt_current\n\n        # --- Error Calculation ---\n        p_sol_exact = p_exact(x_grid, T_FINAL)\n        u_sol_exact = u_exact(x_grid, T_FINAL)\n        \n        # Using np.linalg.norm is equivalent to the formula since sqrt(dx) cancels.\n        error_p = np.linalg.norm(p - p_sol_exact) / np.linalg.norm(p_sol_exact)\n        error_u = np.linalg.norm(u - u_sol_exact) / np.linalg.norm(u_sol_exact)\n        \n        return error_p, error_u\n\n    # --- Convergence Analysis ---\n    all_results = []\n    dx_vals = 1.0 / np.array(N_VALS)\n    log_dx = np.log(dx_vals)\n    \n    for order in SCHEMES:\n        errors_p = []\n        errors_u = []\n        for n_val in N_VALS:\n            err_p, err_u = run_simulation(n_val, order)\n            errors_p.append(err_p)\n            errors_u.append(err_u)\n            \n        # Fit log(error) vs log(dx) to find the slope (order of convergence)\n        log_err_p = np.log(np.array(errors_p))\n        log_err_u = np.log(np.array(errors_u))\n        \n        # polyfit returns [slope, intercept] for degree 1\n        p_obs_p = np.polyfit(log_dx, log_err_p, 1)[0]\n        p_obs_u = np.polyfit(log_dx, log_err_u, 1)[0]\n        \n        all_results.append(p_obs_p)\n        all_results.append(p_obs_u)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一旦数值代码得到验证，我们就可以用它来探索物理现象并比较不同数值方法的性能。本实践从代码验证转向实际应用，模拟一个声脉冲的传播过程。你将实现并比较两种强大的空间离散化技术——高阶有限差分法和傅里叶伪谱法——并针对一个实际问题，评估它们在精度和计算成本方面的权衡。",
            "id": "4005955",
            "problem": "考虑与计算燃烧室相关、在均匀介质中的一维小振幅声学状态，在此状态下，线性化的可压缩欧拉方程简化为关于压力扰动 $p(x,t)$ 和粒子速度 $u(x,t)$ 的一阶声学系统，\n$$\n\\frac{\\partial p}{\\partial t} + \\rho_0 c^2 \\frac{\\partial u}{\\partial x} = 0, \\qquad\n\\frac{\\partial u}{\\partial t} + \\frac{1}{\\rho_0} \\frac{\\partial p}{\\partial x} = 0,\n$$\n其中背景密度 $\\rho_0$ 和声速 $c$ 为常数。假设在长度为 $L$ 的空间域上采用周期性边界条件，并初始化一个与右行黎曼不变量一致的右行声脉冲：选择一个初始压力场 $p(x,0)$，并通过 $u(x,0) = p(x,0)/(\\rho_0 c)$ 设置初始速度场 $u(x,0)$，从而使解向右传播而不产生左行波。\n\n您的任务是，在将此声脉冲传播 100 个波长的过程中，比较两种数值空间离散化方法的计算成本和精度：\n- 一种使用快速傅里叶变换 (FFT) 计算空间导数的傅里叶伪谱法。\n- 一种使用显式模板计算一阶空间导数的高阶中心有限差分法。\n\n为确保公平比较，两种方法的时间积分都应使用相同的显式四阶龙格-库塔 (RK4) 格式。设定域为 $L = 100 \\lambda$，其中 $\\lambda$ 是脉冲定义中使用的载波的声学波长。使用代表空气的恒定声速 $c$ 和密度 $\\rho_0$，具体为 $\\rho_0 = 1\\,\\mathrm{kg/m^3}$ 和 $c = 340\\,\\mathrm{m/s}$。在 $[0,L]$ 上使用周期性边界条件。\n\n将初始脉冲定义为高斯调制的余弦波，\n$$\np(x,0) = A \\cos\\left(\\frac{2\\pi x}{\\lambda}\\right) \\exp\\left(-\\frac{(x-x_0)^2}{2\\sigma^2}\\right),\n$$\n其振幅为 $A$，中心为 $x_0$，宽度为 $\\sigma$。设置 $A=1\\,\\mathrm{Pa}$，$x_0 = L/4$ 和 $\\sigma = 3\\lambda$。定义 $u(x,0) = p(x,0)/(\\rho_0 c)$ 以产生纯粹的右行波。\n\n对于这两种方法，将解从 $t=0$ 演化到 $t=T$（其中 $T=L/c$，即一次完整的域遍历），使用的时间步长 $\\Delta t$ 满足 $\\Delta t = \\mathrm{CFL}\\,\\Delta x / c$，其中 $\\mathrm{CFL} = 0.5$，$\\Delta x = L/N$，$N$ 是空间网格点的数量。这样的选择确保了 $T/\\Delta t$ 为整数，使得结束时间恰好与一次完整的遍历对齐。有限差分法应使用中心模板计算一阶导数；根据测试用例，使用四阶精度的 $5$ 点模板或六阶精度的 $7$ 点模板。\n\n精度度量：演化到 $t=T$ 后，计算压力场的相对离散 $L^2$ 误差，\n$$\n\\varepsilon = \\frac{\\left\\|p(\\cdot,T) - p(\\cdot,0)\\right\\|_2}{\\left\\|p(\\cdot,0)\\right\\|_2},\n$$\n其中离散范数定义为 $\\|f\\|_2 = \\sqrt{\\Delta x \\sum_{i=0}^{N-1} f_i^2}$。\n\n计算成本度量：\n- 对于谱方法，报告在整个模拟过程中用于计算空间导数的一维快速傅里叶变换的总调用次数。每次正向和反向变换计为一次 FFT 调用。在所述的伪谱实现中，在龙格-库塔的每个阶段计算每个场的 $\\partial_x$ 需要一次正向 FFT 和一次反向 FFT；因此，每个龙格-库塔阶段计算 $\\partial_x p$ 和 $\\partial_x u$ 总共需要 $4$ 次 FFT 调用。每个时间步有 $4$ 个阶段，总共有 $T/\\Delta t$ 个时间步，因此总次数可以量化为一个整数。\n- 对于有限差分法，报告在整个模拟过程中用于计算空间导数的模板乘加运算总次数。使用中心 $5$ 点模板（四个非零权重）在每个网格点每次求导时需要 4 次乘法和 3 次加法，即每个网格点 7 次乘加运算。使用中心 $7$ 点模板（六个非零权重）在每个网格点每次求导时需要 6 次乘法和 5 次加法，即每个网格点 11 次乘加运算。在龙格-库塔的每个阶段，都需要计算 $\\partial_x p$ 和 $\\partial_x u$，且每个时间步有 4 个阶段。\n\n您必须实现这两种方法并生成所要求的度量。所有空间变量必须以米为单位，时间以秒为单位，压力以帕斯卡为单位，速度以米/秒为单位。将最终的精度度量报告为无量纲浮点数。将计算成本度量报告为整数。\n\n测试套件：\n- 用例 1（正常路径）：$N=1024$，有限差分阶数 $6$（七点模板）。\n- 用例 2（粗网格）：$N=256$，有限差分阶数 $4$（五点模板）。\n- 用例 3（细网格）：$N=2048$，有限差分阶数 $6$（七点模板）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表按 $[\\varepsilon_{\\mathrm{spec}}, \\mathrm{FFT}_{\\mathrm{calls}}, \\varepsilon_{\\mathrm{FD}}, \\mathrm{MADD}_{\\mathrm{ops}}]$ 的顺序排列，对应于相应的测试用例。例如，输出必须如下所示\n$$\n\\left[\\left[\\varepsilon_1,\\mathrm{FFT}_1,\\varepsilon_2,\\mathrm{MADD}_2\\right],\\left[\\varepsilon_3,\\mathrm{FFT}_3,\\varepsilon_4,\\mathrm{MADD}_4\\right],\\left[\\varepsilon_5,\\mathrm{FFT}_5,\\varepsilon_6,\\mathrm{MADD}_6\\right]\\right],\n$$\n其中所有 $\\varepsilon$ 条目均为浮点数（无量纲），所有成本条目均为整数。",
            "solution": "用户提供的问题被评估为有效。该问题具有科学依据，提法恰当，并包含进行唯一且有意义的求解所需的所有必要信息。\n\n该问题要求比较两种求解一维一阶声学系统的数值方法，该系统由线性化的可压缩欧拉方程导出。关于压力扰动 $p(x,t)$ 和粒子速度 $u(x,t)$ 的系统由以下方程组给出：\n$$\n\\frac{\\partial p}{\\partial t} + \\rho_0 c^2 \\frac{\\partial u}{\\partial x} = 0 \\\\\n\\frac{\\partial u}{\\partial t} + \\frac{1}{\\rho_0} \\frac{\\partial p}{\\partial x} = 0\n$$\n其中 $\\rho_0$ 是恒定的背景密度，$c$ 是恒定的声速。该系统可以写成向量形式 $\\frac{\\partial \\mathbf{Q}}{\\partial t} + \\mathbf{A} \\frac{\\partial \\mathbf{Q}}{\\partial x} = \\mathbf{0}$，其中 $\\mathbf{Q} = [p, u]^T$。因此，用于时间积分的右侧项为：\n$$\n\\frac{\\partial \\mathbf{Q}}{\\partial t} = \\mathbf{F}(\\mathbf{Q}) = -\\mathbf{A} \\frac{\\partial \\mathbf{Q}}{\\partial x} = \\begin{pmatrix} -\\rho_0 c^2 \\frac{\\partial u}{\\partial x} \\\\ -\\frac{1}{\\rho_0} \\frac{\\partial p}{\\partial x} \\end{pmatrix}\n$$\n\n问题定义在周期性空间域 $[0, L]$ 上。初始条件是压力的一个高斯调制余弦脉冲，速度被设置为与右行黎曼不变量匹配，即 $u(x,0) = p(x,0)/(\\rho_0 c)$。这确保了初始脉冲纯粹向右传播。在时间 $T = L/c$（对应于周期域的一次完整遍历）时的精确解与初始条件相同：$p(x,T) = p(x,0)$。这提供了一个精确解，可以用来与数值结果进行比较。\n\n对于两种空间离散化方案，时间积分均采用显式四阶龙格-库塔 (RK4) 方法。对于一个半离散系统 $\\frac{d\\mathbf{Q}}{dt} = \\mathbf{F}(\\mathbf{Q})$，从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个时间步计算如下：\n$$\n\\mathbf{k}_1 = \\mathbf{F}(\\mathbf{Q}_n) \\\\\n\\mathbf{k}_2 = \\mathbf{F}(\\mathbf{Q}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = \\mathbf{F}(\\mathbf{Q}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = \\mathbf{F}(\\mathbf{Q}_n + \\Delta t \\mathbf{k}_3) \\\\\n\\mathbf{Q}_{n+1} = \\mathbf{Q}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n函数 $\\mathbf{F}(\\mathbf{Q})$ 表示空间导数的计算，这在两种方法中是不同的。\n\n**1. 傅里叶伪谱法**\n\n该方法利用了物理空间中的微分等效于傅里叶空间中乘以虚数单位 $i$ 和波数 $k$ 的性质。在离散网格 $x_j=j\\Delta x$ 上，函数 $f(x)$ 的空间导数计算如下：\n1. 计算网格函数 $f_j$ 的离散傅里叶变换 (DFT)：$\\hat{f}_m = \\mathcal{F}[f_j]$。\n2. 乘以 $i k_m$，其中 $k_m$ 是离散波数。对于长度为 $L$、有 $N$ 个点的域，$k_m = 2\\pi m / L$，其中 $m$ 在适当的范围内。\n3. 计算离散傅里叶逆变换 (IDFT)：$(\\partial f / \\partial x)_j = \\mathcal{F}^{-1}[i k_m \\hat{f}_m]$。\n快速傅里叶变换 (FFT) 算法用于高效计算 DFT 和 IDFT。该方法具有谱精度，意味着对于光滑函数，误差随网格点数的增加呈指数级下降。\n\n**2. 有限差分法**\n\n该方法使用邻近点函数值的加权和（一个模板）来近似网格点上的空间导数。问题指定了用于一阶导数的中心模板。\n- 四阶精度的 $5$ 点模板为：\n$$ \\left(\\frac{\\partial f}{\\partial x}\\right)_i \\approx \\frac{+f_{i-2} - 8f_{i-1} + 8f_{i+1} - f_{i+2}}{12 \\Delta x} $$\n- 六阶精度的 $7$ 点模板为：\n$$ \\left(\\frac{\\partial f}{\\partial x}\\right)_i \\approx \\frac{-f_{i-3} + 9f_{i-2} - 45f_{i-1} + 45f_{i+1} - 9f_{i+2} + f_{i+3}}{60 \\Delta x} $$\n由于周期性边界条件，索引会环绕整个域，例如 $f_{-1} = f_{N-1}$。\n\n**模拟参数和度量**\n\n针对每个测试用例，使用以下参数运行模拟：$\\rho_0 = 1\\,\\mathrm{kg/m^3}$，$c = 340\\,\\mathrm{m/s}$，$A=1\\,\\mathrm{Pa}$。我们在不失一般性的前提下选择载波波长 $\\lambda=1.0\\,\\mathrm{m}$，这使得 $L=100\\,\\mathrm{m}$，$x_0=25\\,\\mathrm{m}$，以及 $\\sigma=3\\,\\mathrm{m}$。模拟运行至 $T=L/c$。时间步长为 $\\Delta t = \\mathrm{CFL}\\,\\Delta x / c$，其中 $\\mathrm{CFL}=0.5$，$\\Delta x=L/N$。总时间步数为 $N_{\\text{steps}} = T/\\Delta t = 2N$。\n\n- **精度度量**：相对离散 $L^2$ 误差，$\\varepsilon = \\frac{\\left\\|p_{\\text{num}}(\\cdot,T) - p(\\cdot,0)\\right\\|_2}{\\left\\|p(\\cdot,0)\\right\\|_2}$，其中范数为 $\\|f\\|_2 = \\sqrt{\\Delta x \\sum_{i=0}^{N-1} f_i^2}$。\n\n- **成本度量**：\n    - 谱方法：FFT 调用总次数。每个 RK4 阶段需要计算 $p$ 和 $u$ 的导数，而每个导数需要一次正向和一次反向 FFT。这导致每个阶段需要 4 次 FFT。总次数为 $4 \\text{ (FFT/阶段)} \\times 4 \\text{ (阶段/步)} \\times 2N \\text{ (步)} = 32N$。\n    - 有限差分法：乘加 (MADD) 运算总次数。$5$ 点模板每个网格点需要 4 次乘法和 3 次加法（7 次 MADD），$7$ 点模板每个网格点需要 6 次乘法和 5 次加法（11 次 MADD）。总次数为 $C_{\\text{MADD}} \\times N \\text{ (点)} \\times 2 \\text{ (场)} \\times 4 \\text{ (阶段/步)} \\times 2N \\text{ (步)} = 16 C_{\\text{MADD}} N^2$。\n\n实施过程为：遍历每个测试用例，运行两种模拟，并计算指定的度量。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations and generate the final output.\n    \"\"\"\n    \n    # --- Physical and Simulation Constants ---\n    rho0 = 1.0  # kg/m^3\n    c = 340.0   # m/s\n    A = 1.0     # Pa\n    cfl = 0.5\n\n    # --- Initial Condition Pulse Parameters (relative to wavelength lambda) ---\n    # We can choose lambda=1.0 m without loss of generality.\n    lmbda = 1.0\n    L_norm = 100.0   # Domain length in wavelengths\n    x0_norm = 25.0   # Pulse center in wavelengths\n    sigma_norm = 3.0 # Pulse width in wavelengths\n    \n    L = L_norm * lmbda\n    x0 = x0_norm * lmbda\n    sigma = sigma_norm * lmbda\n\n    test_cases = [\n        {'N': 1024, 'fd_order': 6},\n        {'N': 256, 'fd_order': 4},\n        {'N': 2048, 'fd_order': 6},\n    ]\n\n    results = []\n\n    # --- Spatial Derivative Functions ---\n    def spectral_derivative(f, L_domain):\n        \"\"\"Computes derivative using FFT.\"\"\"\n        N_pts = len(f)\n        k_wavenum = 2 * np.pi * fftfreq(N_pts, d=L_domain / N_pts)\n        f_hat = fft(f)\n        df_hat = 1j * k_wavenum * f_hat\n        return ifft(df_hat).real\n\n    def fd_derivative(f, dx, order):\n        \"\"\"Computes derivative using finite-difference stencils.\"\"\"\n        if order == 4: # 5-point stencil\n            # Stencil: (+f_{i-2} - 8f_{i-1} + 8f_{i+1} - f_{i+2}) / 12h\n            df = ( 1.0 * np.roll(f, 2)\n                  - 8.0 * np.roll(f, 1)\n                  + 8.0 * np.roll(f, -1)\n                  - 1.0 * np.roll(f, -2) ) / 12.0\n            return df / dx\n        elif order == 6: # 7-point stencil\n            # Stencil: (-f_{i-3} + 9f_{i-2} - 45f_{i-1} + 45f_{i+1} - 9f_{i+2} + f_{i+3}) / 60h\n            df = ( -1.0 * np.roll(f, 3)\n                  + 9.0 * np.roll(f, 2)\n                  - 45.0 * np.roll(f, 1)\n                  + 45.0 * np.roll(f, -1)\n                  - 9.0 * np.roll(f, -2)\n                  + 1.0 * np.roll(f, -3) ) / 60.0\n            return df / dx\n        else:\n            raise ValueError(\"FD order must be 4 or 6.\")\n\n    # --- RHS Functions for RK4 ---\n    def rhs_spectral(Q, L_domain, rho_const, c_sound):\n        p, u = Q[0, :], Q[1, :]\n        dp_dx = spectral_derivative(p, L_domain)\n        du_dx = spectral_derivative(u, L_domain)\n        dp_dt = -rho_const * c_sound**2 * du_dx\n        du_dt = -1.0 / rho_const * dp_dx\n        return np.array([dp_dt, du_dt])\n\n    def rhs_fd(Q, dx, order, rho_const, c_sound):\n        p, u = Q[0, :], Q[1, :]\n        dp_dx = fd_derivative(p, dx, order)\n        du_dx = fd_derivative(u, dx, order)\n        dp_dt = -rho_const * c_sound**2 * du_dx\n        du_dt = -1.0 / rho_const * dp_dx\n        return np.array([dp_dt, du_dt])\n\n    # --- RK4 Time Stepper ---\n    def rk4_step(Q, dt, rhs_func, **kwargs):\n        k1 = rhs_func(Q, **kwargs)\n        k2 = rhs_func(Q + 0.5 * dt * k1, **kwargs)\n        k3 = rhs_func(Q + 0.5 * dt * k2, **kwargs)\n        k4 = rhs_func(Q + dt * k3, **kwargs)\n        return Q + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    for case in test_cases:\n        N = case['N']\n        fd_order = case['fd_order']\n        \n        # --- Grid and Time Step Setup ---\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        dt = cfl * dx / c\n        T_final = L / c\n        num_steps = int(round(T_final / dt))\n\n        # --- Initial Conditions ---\n        p0 = A * np.cos(2 * np.pi * x / lmbda) * np.exp(-(x - x0)**2 / (2 * sigma**2))\n        u0 = p0 / (rho0 * c)\n        Q0 = np.array([p0, u0])\n\n        # --- Spectral Method Simulation ---\n        Q_spec = Q0.copy()\n        for _ in range(num_steps):\n            Q_spec = rk4_step(Q_spec, dt, rhs_spectral, L_domain=L, rho_const=rho0, c_sound=c)\n\n        # --- Finite-Difference Method Simulation ---\n        Q_fd = Q0.copy()\n        for _ in range(num_steps):\n            Q_fd = rk4_step(Q_fd, dt, rhs_fd, dx=dx, order=fd_order, rho_const=rho0, c_sound=c)\n\n        # --- Metrics Calculation ---\n        p_initial = Q0[0, :]\n        p_final_spec = Q_spec[0, :]\n        p_final_fd = Q_fd[0, :]\n\n        # Accuracy\n        norm_p0 = np.sqrt(dx * np.sum(p_initial**2))\n        err_spec = np.sqrt(dx * np.sum((p_final_spec - p_initial)**2)) / norm_p0\n        err_fd = np.sqrt(dx * np.sum((p_final_fd - p_initial)**2)) / norm_p0\n\n        # Cost\n        cost_spec = 32 * N\n        if fd_order == 4:\n            madd_per_point = 7\n        else: # fd_order == 6\n            madd_per_point = 11\n        cost_fd = 16 * madd_per_point * N**2\n\n        results.append([err_spec, cost_spec, err_fd, cost_fd])\n\n    # Format output as a string representation of a list of lists.\n    # This avoids any numpy-specific formatting.\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        output_str += f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}