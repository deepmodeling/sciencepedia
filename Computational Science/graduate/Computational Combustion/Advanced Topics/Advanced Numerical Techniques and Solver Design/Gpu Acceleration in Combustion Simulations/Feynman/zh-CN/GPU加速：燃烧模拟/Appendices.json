{
    "hands_on_practices": [
        {
            "introduction": "为了优化代码，我们首先需要理解其性能瓶颈。Roofline 模型是一个直观而强大的工具，可以帮助我们判断一个计算内核的性能是被计算能力（“计算密集型”）还是内存带宽（“访存密集型”）所限制。这项练习将指导您完成一次基本的 Roofline 分析 ，通过计算一个典型化学反应源项内核的算术强度，来确定其性能上限并识别主要瓶颈。",
            "id": "4028784",
            "problem": "一个有限体积反应流求解器在图形处理器（GPU）上通过一个逐单元核心函数来计算组分源项。每次单元更新执行一个浮点工作负载，包含 $F$ 次浮点运算（flops），并通过高带宽设备内存传输 $B$ 字节的数据。假设使用双精度（binary64）算术。该核心函数仅对每个单元的状态执行流式的、完全合并的全局内存访问，并写回更新后的字段，单元之间无数据重用，因此每个单元的总数据流量等于 $B$。该 GPU 的持续峰值双精度计算吞吐量为每秒 $P_{\\text{peak}}$ 次浮点运算，持续设备内存带宽为每秒 $\\beta$ 字节。请使用算术强度和屋顶线性能模型的基本定义，推导算术强度的表达式，并确定该核心函数的性能如何受到带宽和峰值计算屋顶的限制。\n\n现在，将问题具体到以下用于详细化学反应组分源项核心函数的科学实际参数：\n- 每个单元的浮点工作量：$F = 6.0 \\times 10^{4}$ flops。\n- 每个单元的数据移动量：$B = 8.0 \\times 10^{3}$ 字节。\n- GPU 持续峰值双精度吞吐量：$P_{\\text{peak}} = 9.7 \\times 10^{12}$ flops/秒。\n- GPU 持续设备内存带宽：$\\beta = 1.6 \\times 10^{12}$ 字节/秒。\n\n仅使用基本定义，计算算术强度，并将该核心函数相对于带宽和计算屋顶进行定位，以获得屋顶线模型预测的持续性能。将您的最终数值答案以每秒吉咖浮点运算（GFLOP/s）为单位表示，并四舍五入到四位有效数字。",
            "solution": "将根据指定标准对问题进行验证。\n\n### 第 1 步：提取已知条件\n- 每个单元的浮点工作负载：$F = 6.0 \\times 10^{4}$ flops\n- 每个单元的数据移动量：$B = 8.0 \\times 10^{3}$ 字节\n- 算术精度：双精度 (binary64)\n- 内存访问模式：流式的、完全合并的全局内存访问，单元之间无数据重用。\n- GPU 持续峰值双精度吞吐量：$P_{\\text{peak}} = 9.7 \\times 10^{12}$ flops/s。\n- GPU 持续设备内存带宽：$\\beta = 1.6 \\times 10^{12}$ bytes/s。\n- 最终答案要求：将预测的持续性能以每秒吉咖浮点运算（GFLOP/s）为单位表示，并四舍五入到四位有效数字。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题具有科学依据、提法恰当且客观。\n- **科学依据：**该问题使用了屋顶线性能模型，这是高性能计算中用于分析计算核心函数性能的一个基本且被广泛接受的工具。在 GPU 上运行反应流求解器的场景是计算科学中的一个标准应用。所提供的浮点运算、数据移动、峰值吞吐量和内存带宽等参数对于一个正在执行复杂化学动力学计算的现代 GPU 来说是符合实际的。\n- **提法恰当：**所有必要的数据（$F$、$B$、$P_{\\text{peak}}$、$\\beta$）和定义均已提供，足以使用屋顶线模型计算算术强度和预测性能。该问题是自洽的，并能导出一个唯一的、有意义的解。\n- **客观性：**该问题使用精确的技术术语（“有限体积”、“合并的全局内存访问”、“算术强度”）进行陈述，没有任何主观或模棱两可的语言。\n\n该问题没有表现出说明中列出的任何缺陷（例如，科学上不健全、不完整、矛盾等）。\n\n### 第 3 步：结论和行动\n问题有效。将提供完整解答。\n\n### 解题推导\n像 GPU 这样的处理器上计算核心函数的性能通常受限于其峰值计算能力或从内存中获取数据的速率。屋顶线模型将这一概念形式化。\n\n首先，我们定义核心函数的算术强度 $I$。它是执行的总浮点运算次数（$F$）与移入和移出主内存的总数据量（$B$）之比。\n$$I = \\frac{F}{B}$$\n$I$ 的单位是 flops/字节。\n\n屋顶线模型指出，可达到的性能 $P_{\\text{attainable}}$（以 flops/秒为单位）受两个因素限制：硬件的峰值计算吞吐量 $P_{\\text{peak}}$，以及在给定内存带宽 $\\beta$ 下可实现的性能。\n\n最大性能本质上受限于处理器的峰值吞吐量：\n$$P_{\\text{attainable}} \\le P_{\\text{peak}}$$\n性能也受内存子系统的限制。执行核心函数所需的时间 $t$ 必须至少与传输必要数据所需的时间 $t_{\\text{memory}} = B / \\beta$ 一样长。因此，性能（即 $F/t$）受以下限制：\n$$P_{\\text{attainable}} = \\frac{F}{t} \\le \\frac{F}{t_{\\text{memory}}} = \\frac{F}{B/\\beta} = \\left(\\frac{F}{B}\\right) \\beta = I \\cdot \\beta$$\n结合这两个限制，屋顶线模型预测的性能是这两个上限中的较小者：\n$$P_{\\text{attainable}} = \\min(P_{\\text{peak}}, I \\cdot \\beta)$$\n如果核心函数的性能受 $P_{\\text{peak}}$ 限制，则认为它是**计算受限**的（compute-bound）；如果受 $I \\cdot \\beta$ 限制，则认为是**内存受限**的（memory-bound）或带宽受限的（bandwidth-bound）。这两种状态之间的转换发生在一个特定的算术强度上，称为机器的**脊点**（ridge point）$I_{\\text{ridge}}$。该点可通过令两个性能限制相等来找到：\n$$P_{\\text{peak}} = I_{\\text{ridge}} \\cdot \\beta \\implies I_{\\text{ridge}} = \\frac{P_{\\text{peak}}}{\\beta}$$\n如果核心函数的算术强度 $I > I_{\\text{ridge}}$，它是计算受限的。如果 $I  I_{\\text{ridge}}$，它是内存受限的。\n\n现在，我们将问题具体到给定的参数。\n- 每个单元的浮点工作量：$F = 6.0 \\times 10^{4}$ flops。\n- 每个单元的数据移动量：$B = 8.0 \\times 10^{3}$ 字节。\n\n该核心函数的算术强度是：\n$$I = \\frac{6.0 \\times 10^{4} \\text{ flops}}{8.0 \\times 10^{3} \\text{ bytes}} = \\frac{60}{8} \\text{ flops/byte} = 7.5 \\text{ flops/byte}$$\nGPU 硬件参数为：\n- 峰值双精度吞吐量：$P_{\\text{peak}} = 9.7 \\times 10^{12}$ flops/s。\n- 内存带宽：$\\beta = 1.6 \\times 10^{12}$ bytes/s。\n\n接下来，我们计算 GPU 的脊点：\n$$I_{\\text{ridge}} = \\frac{P_{\\text{peak}}}{\\beta} = \\frac{9.7 \\times 10^{12} \\text{ flops/s}}{1.6 \\times 10^{12} \\text{ bytes/s}} = \\frac{9.7}{1.6} \\text{ flops/byte} = 6.0625 \\text{ flops/byte}$$\n我们将核心函数的算术强度 $I$ 与机器的脊点 $I_{\\text{ridge}}$ 进行比较：\n$$I = 7.5 \\text{ flops/byte} > I_{\\text{ridge}} = 6.0625 \\text{ flops/byte}$$\n由于核心函数的算术强度大于脊点，该核心函数的性能是计算受限的。\n\n因此，屋顶线模型预测的性能由 GPU 的峰值计算吞吐量决定：\n$$P_{\\text{attainable}} = \\min(P_{\\text{peak}}, I \\cdot \\beta) = P_{\\text{peak}}$$\n$$P_{\\text{attainable}} = 9.7 \\times 10^{12} \\text{ flops/s}$$\n问题要求以每秒吉咖浮点运算（GFLOP/s）为单位表示答案。我们知道 $1 \\text{ GFLOP/s} = 10^9 \\text{ flops/s}$。转换结果：\n$$P_{\\text{attainable}} = \\frac{9.7 \\times 10^{12} \\text{ flops/s}}{10^9 \\text{ flops/s per GFLOP/s}} = 9.7 \\times 10^3 \\text{ GFLOP/s} = 9700 \\text{ GFLOP/s}$$\n问题要求将最终答案四舍五入到四位有效数字。计算出的值恰好是 $9700$，可以表示为四位有效数字。因此，不需要进一步的四舍五入。",
            "answer": "$$\\boxed{9700}$$"
        },
        {
            "introduction": "在掌握了基本的性能分析方法后，我们可以应用它来解决实际的内核设计问题。一个常见的优化策略是“内核融合”（kernel fusion），即将多个计算步骤合并到单个内核中以减少全局内存的读写，但这是否总能带来性能提升呢？本练习  将通过一个具体案例，让您运用 Roofline 模型来量化比较内核融合与拆分两种策略的性能，从而做出有数据支持的优化决策。",
            "id": "4028809",
            "problem": "一个用于预混甲烷-空气火焰的反应流时间推进在图形处理器（GPU）上实现。每个单元格的化学更新过程会计算热力学性质、化学源项，并更新组分质量分数和温度。对于一个包含 $50$ 个组分的反应机理，对融合实现（即单个内核执行所有阶段，无需中间的全局内存写入）的详细性能分析报告了以下每个单元格的指标：总浮点运算次数 $F_{\\mathrm{fused}} = 1.2 \\times 10^{4}$ 和总全局内存流量 $M_{\\mathrm{fused}} = 6.0 \\times 10^{2}$ 字节（全局加载和存储的总和）。当内核被拆分成两个内核时（第一个内核计算性质和源项，第二个内核更新状态，中间的反应速率向量在全局内存中实例化），总浮点运算次数大致保持不变，$F_{\\mathrm{split}} \\approx 1.2 \\times 10^{4}$，但由于中间的写入和读取以及额外的寄存器溢出/重载，每个单元格的总全局内存流量增加到 $M_{\\mathrm{split}} = 1.4 \\times 10^{3}$ 字节。\n\n该GPU的峰值单精度计算吞吐量为 $P_{\\max} = 1.4 \\times 10^{13}$ 次浮点运算/秒，持续全局内存带宽为 $B_{\\max} = 9.0 \\times 10^{11}$ 字节/秒。网格包含 $N_{c} = 5.0 \\times 10^{7}$ 个单元格，每个时间步应用一次化学更新。假设在所有流式多处理器上实现理想扩展（无竞争效应或内核启动开销），并忽略延迟隐藏的不完美性。\n\n从基本原理出发，使用Roofline分析来确定每种策略可达到的性能上限，并预测融合实现和拆分实现下一次化学更新时间步的执行时间。在这些假设下，判断哪种策略是最优的。以毫秒为单位报告最优策略在一个时间步内的预测运行时间。将答案四舍五入到三位有效数字，并以毫秒表示。",
            "solution": "Roofline模型通过两个基本的机器限制和算法的算术强度来约束计算的可达到性能。这两个基本限制是处理器的峰值浮点吞吐量 $P_{\\max}$ 和内存子系统的持续全局内存带宽 $B_{\\max}$。算法的算术强度 $R$ 定义为每字节从全局内存移入和移出的数据所执行的浮点运算次数，即\n$$\nR \\equiv \\frac{F}{M},\n$$\n其中 $F$ 是工作负载的总浮点运算次数，$M$ 是相应的全局内存流量。Roofline模型所蕴含的性能界限是，可达到的吞吐量 $P_{\\mathrm{achieved}}$ 不能超过计算峰值或带宽限制的天花板，后者是带宽和算术强度的乘积：\n$$\nP_{\\mathrm{achieved}} \\leq \\min\\!\\big( P_{\\max},\\ B_{\\max} \\, R \\big).\n$$\n这一论断是从基本原理推导出来的：如果计算每移动一字节数据需要 $R$ 次浮点运算，而内存子系统每秒最多能提供 $B_{\\max}$ 字节，那么从内存方面来看，计算每秒维持的浮点运算次数不能超过 $B_{\\max} R$；同时，任何计算都不能超过处理器的峰值性能 $P_{\\max}$。\n\n给定 $N_{c}$ 个单元格，每个单元格承担相同的工作负载，因此每个时间步的总工作量为 $F_{\\mathrm{total}} = F \\, N_{c}$。那么，在Roofline模型界限下的执行时间 $T$ 为\n$$\nT = \\frac{F_{\\mathrm{total}}}{P_{\\mathrm{achieved}}} = \\frac{F \\, N_{c}}{\\min\\!\\big(P_{\\max},\\ B_{\\max} R\\big)}.\n$$\n\n我们现在计算这两种策略的算术强度。\n\n对于融合内核，\n$$\nF_{\\mathrm{fused}} = 1.2 \\times 10^{4}, \\quad M_{\\mathrm{fused}} = 6.0 \\times 10^{2},\n$$\n因此\n$$\nR_{\\mathrm{fused}} = \\frac{F_{\\mathrm{fused}}}{M_{\\mathrm{fused}}} = \\frac{1.2 \\times 10^{4}}{6.0 \\times 10^{2}} = 2.0 \\times 10^{1}.\n$$\n融合内核的带宽限制天花板是\n$$\nB_{\\max} R_{\\mathrm{fused}} = \\left(9.0 \\times 10^{11}\\right) \\times \\left(2.0 \\times 10^{1}\\right) = 1.8 \\times 10^{13}.\n$$\n与计算峰值进行比较，\n$$\nP_{\\max} = 1.4 \\times 10^{13}, \\quad B_{\\max} R_{\\mathrm{fused}} = 1.8 \\times 10^{13},\n$$\n融合内核是计算受限的，因为 $P_{\\max}  B_{\\max} R_{\\mathrm{fused}}$。因此\n$$\nP_{\\mathrm{achieved,fused}} = P_{\\max} = 1.4 \\times 10^{13}.\n$$\n每个时间步的总工作量是\n$$\nF_{\\mathrm{total}} = F_{\\mathrm{fused}} N_{c} = \\left(1.2 \\times 10^{4}\\right)\\left(5.0 \\times 10^{7}\\right) = 6.0 \\times 10^{11}.\n$$\n因此，融合实现的时间是\n$$\nT_{\\mathrm{fused}} = \\frac{6.0 \\times 10^{11}}{1.4 \\times 10^{13}} = 4.2857142857 \\times 10^{-2}\\ \\mathrm{s}.\n$$\n以毫秒表示，\n$$\nT_{\\mathrm{fused,ms}} = \\left(4.2857142857 \\times 10^{-2}\\right)\\times \\left(1.0 \\times 10^{3}\\right) = 4.2857142857 \\times 10^{1}\\ \\mathrm{ms} = 42.857142857\\ \\mathrm{ms}.\n$$\n\n对于拆分内核，\n$$\nF_{\\mathrm{split}} \\approx 1.2 \\times 10^{4}, \\quad M_{\\mathrm{split}} = 1.4 \\times 10^{3},\n$$\n因此\n$$\nR_{\\mathrm{split}} = \\frac{F_{\\mathrm{split}}}{M_{\\mathrm{split}}} = \\frac{1.2 \\times 10^{4}}{1.4 \\times 10^{3}} = 8.571428571.\n$$\n拆分实现的带宽限制天花板是\n$$\nB_{\\max} R_{\\mathrm{split}} = \\left(9.0 \\times 10^{11}\\right) \\times \\left(8.571428571\\right) = 7.714285714 \\times 10^{12}.\n$$\n与计算峰值进行比较，\n$$\nP_{\\max} = 1.4 \\times 10^{13}, \\quad B_{\\max} R_{\\mathrm{split}} = 7.714285714 \\times 10^{12},\n$$\n拆分实现是内存受限的，因为 $B_{\\max} R_{\\mathrm{split}}  P_{\\max}$。因此\n$$\nP_{\\mathrm{achieved,split}} = 7.714285714 \\times 10^{12}.\n$$\n在总工作量相同，$F_{\\mathrm{total}} = 6.0 \\times 10^{11}$ 的情况下，拆分实现的时间是\n$$\nT_{\\mathrm{split}} = \\frac{6.0 \\times 10^{11}}{7.714285714 \\times 10^{12}} = 7.777777778 \\times 10^{-2}\\ \\mathrm{s},\n$$\n以毫秒表示，\n$$\nT_{\\mathrm{split,ms}} = \\left(7.777777778 \\times 10^{-2}\\right)\\times \\left(1.0 \\times 10^{3}\\right) = 7.777777778 \\times 10^{1}\\ \\mathrm{ms} = 77.77777778\\ \\mathrm{ms}.\n$$\n\n决策：由于 $T_{\\mathrm{fused,ms}} \\approx 42.857142857\\ \\mathrm{ms}$ 且 $T_{\\mathrm{split,ms}} \\approx 77.77777778\\ \\mathrm{ms}$，在给定假设下，融合策略是最优的。将最优运行时间四舍五入到三位有效数字并以毫秒表示，可得\n$$\nT_{\\mathrm{optimal,ms}} = 42.9\\ \\mathrm{ms}.\n$$",
            "answer": "$$\\boxed{42.9}$$"
        },
        {
            "introduction": "除了宏观的性能模型，深入理解 GPU 的微架构对于极致优化至关重要。共享内存（Shared Memory）是实现高性能的关键，但如果使用不当，例如发生“Bank 冲突”（bank conflict），则会严重拖慢速度。这项练习  将带您深入 GPU 内存系统的底层机制，通过推导一种内存填充（padding）方案来避免 Bank 冲突，这是优化燃烧模拟中常见的三维模板计算的必备技巧。",
            "id": "4028757",
            "problem": "给定一个带有晕环区域的三维区块，该区块将被存放在图形处理单元（GPU）的共享内存中，用于计算燃烧学中的有限体积或有限差分模板操作。假设架构和布局如下：共享内存有 $32$ 个存储体，warp大小为 $32$ 个线程，一个位于字地址 $a$ 的 $4$ 字节字的存储体索引为 $a \\bmod 32$。使用行主序布局，其中 $x$ 维度变化最快，其次是 $y$ 维度，最后是 $z$ 维度。该区块在 $x$、$y$ 和 $z$ 面上分别包含宽度为 $h_x$、$h_y$ 和 $h_z$ 的晕环单元。包含晕环的未填充区块范围为 $s_x = n_x + 2 h_x$、$s_y = n_y + 2 h_y$ 和 $s_z = n_z + 2 h_z$。你需要在 $x$ 和 $y$ 维度上引入填充，记为 $p_x$ 和 $p_y$，使得填充后的步长为 $\\pi_x = s_x + p_x$ 和 $\\pi_y = s_y + p_y$，且 $\\pi_z = s_z$（$z$ 维度无填充）。设索引为 $(x,y,z)$ 的元素在共享内存中的地址（以 $4$ 字节字为单位）为\n$$\nA(x,y,z) = (z \\cdot \\pi_x \\pi_y) + (y \\cdot \\pi_x) + x.\n$$\n一个 warp 执行三种在模板更新中常见的访问模式：\n1. $x$ 方向线性访问：线程访问 $(x_0 + t, y_0, z_0)$，其中 $t \\in \\{0,1,\\ldots,31\\}$。\n2. $y$ 方向线性访问：线程访问 $(x_0, y_0 + t, z_0)$，其中 $t \\in \\{0,1,\\ldots,31\\}$。\n3. $z$ 方向线性访问：线程访问 $(x_0, y_0, z_0 + t)$，其中 $t \\in \\{0,1,\\ldots,31\\}$。\n\n从基本原理出发——当一个 warp 中的两个或多个线程访问映射到同一存储体的不同地址时，会发生共享内存存储体冲突；而无冲突访问要求所有 $32$ 个线程映射到不同的存储体——推导一个索引和填充方案，以确保所有三种访问模式都能实现无冲突的存储体访问。你的推导应从存储体索引公式 $b = A \\bmod 32$ 和行主序地址算术开始，并针对每种模式分析其以 $4$ 字节字为单位的步幅。你必须明确定义在何种关于 $\\pi_x$ 和 $\\pi_y$ 的条件下，warp 在进行 $y$ 方向和 $z$ 方向线性访问时不会遇到存储体冲突。然后，推导满足这些条件的最小填充值 $p_x$ 和 $p_y$，并量化填充开销，其定义为已分配共享内存元素的增加比例：\n$$\n\\text{overhead} = \\frac{(\\pi_x \\pi_y \\pi_z) - (s_x s_y s_z)}{s_x s_y s_z}.\n$$\n你必须实现一个程序，对于下面的每个测试用例，该程序计算保证所有三种模式无冲突访问的最小非负填充 $(p_x, p_y)$，通过显式计算 $t \\in \\{0,\\ldots,31\\}$ 的存储体索引来验证无冲突性，并输出填充、开销以及分别指示 $x$、$y$ 和 $z$ 方向线性访问是否无冲突的三个布尔值。始终假设元素为 $4$ 字节。不失一般性地，可将基准索引 $(x_0,y_0,z_0)$ 取为 $(0,0,0)$。\n\n测试套件（每个测试用例是一个元组 $(n_x,n_y,n_z,h_x,h_y,h_z)$）：\n- 用例 1: $(30,2,1,1,0,0)$\n- 用例 2: $(32,8,4,1,1,1)$\n- 用例 3: $(14,2,3,1,0,0)$\n- 用例 4: $(1,1,1,0,0,0)$\n- 用例 5: $(31,32,1,0,0,0)$\n\n你的程序应生成单行输出，其中包含五个测试用例的结果，形式为用方括号括起来的逗号分隔列表，每个用例的结果形式为 $[p_x,p_y,\\text{overhead},\\text{ok\\_x},\\text{ok\\_y},\\text{ok\\_z}]$。$\\text{overhead}$ 使用十进制数，$\\text{ok\\_x}$、$\\text{ok\\_y}$ 和 $\\text{ok\\_z}$ 使用布尔值。例如，你的输出应如下所示\n$$\n[[p_x,p_y,\\text{overhead},\\text{ok\\_x},\\text{ok\\_y},\\text{ok\\_z}],\\ldots]\n$$\n且打印行中不含空格。",
            "solution": "该问题要求为存储在图形处理单元（GPU）共享内存中的三维区块推导一种内存填充方案，以确保执行类模板操作的线程 warp 能够实现无冲突访问。我们首先形式化存储体冲突的条件，然后推导防止冲突所需的最小填充。\n\nGPU 架构规定了 $N_B = 32$ 个共享内存存储体和 $W = 32$ 个线程的 warp 大小。一个位于地址 $a$ 的 $4$ 字节字的存储体索引 $b$ 由公式 $b = a \\pmod{32}$ 给出。如果同一 warp 内的两个或更多线程访问映射到同一存储体索引的不同内存地址，则会发生存储体冲突。要使访问模式无冲突，warp 中的所有 $32$ 个线程必须访问映射到 $32$ 个不同存储体索引的地址。\n\n数据以行主序布局存储在一个三维数组中，并在 $x$ 和 $y$ 维度上进行填充。位于逻辑坐标 $(x,y,z)$ 的元素的地址 $A$ 由下式给出：\n$$\nA(x,y,z) = z \\cdot \\pi_x \\cdot \\pi_y + y \\cdot \\pi_x + x\n$$\n其中 $\\pi_x = s_x + p_x$ 和 $\\pi_y = s_y + p_y$ 分别是 $x$ 和 $y$ 维度上填充后的步长（strides）。未填充的维度为 $s_x = n_x + 2h_x$、$s_y = n_y + 2h_y$ 和 $s_z = n_z + 2h_z$。注意 $\\pi_z = s_z$。我们分析一个 warp 的三种指定访问模式，其中第 $k$ 个线程（$k \\in \\{0, 1, \\dots, 31\\}$）访问一个特定的地址。为简单起见，且如题所述不失一般性，我们假设基准索引为 $(x_0, y_0, z_0) = (0,0,0)$。\n\n设线程 $k$ 访问的地址为 $A_k$。相应的存储体索引为 $b_k = A_k \\pmod{32}$。一个访问模式是无冲突的，当且仅当存储体索引集合 $\\{b_0, b_1, \\dots, b_{31}\\}$ 包含 $32$ 个不同的值。这等价于 $32$ 个线程访问的地址模 $32$ 的值各不相同。如果线程 $k=0, \\dots, 31$ 访问的地址形式为 $A_0 + k \\cdot S$（其中 $S$ 是一个恒定的步幅），那么无冲突访问的条件可以简化。存储体索引为 $(A_0 + k \\cdot S) \\pmod{32}$。这组存储体索引是 $\\{0, 1, \\dots, 31\\}$ 的一个排列，当且仅当步幅 $S$ 与存储体数量 $N_B = 32$ 互质。即 $\\gcd(S, 32) = 1$。\n\n现在，我们为每种访问模式推导步幅 $S$。\n\n**1. $x$ 方向线性访问：**\n线程访问坐标 $(k, 0, 0)$，其中 $k \\in \\{0, \\dots, 31\\}$。\n线程 $k$ 的地址是 $A_k = A(k, 0, 0) = 0 \\cdot \\pi_x \\pi_y + 0 \\cdot \\pi_x + k = k$。\n相邻线程访问的地址之间的步幅为 $S_x = A_{k+1} - A_k = (k+1) - k = 1$。\n我们检查无冲突访问的条件：$\\gcd(S_x, 32) = \\gcd(1, 32) = 1$。\n这个条件总是满足的。因此，$x$ 方向线性访问是内在地无冲突的，与任何填充无关。没有对 $\\pi_x$ 或 $\\pi_y$ 施加任何条件。\n\n**2. $y$ 方向线性访问：**\n线程访问坐标 $(0, k, 0)$，其中 $k \\in \\{0, \\dots, 31\\}$。\n线程 $k$ 的地址是 $A_k = A(0, k, 0) = 0 \\cdot \\pi_x \\pi_y + k \\cdot \\pi_x + 0 = k \\cdot \\pi_x$。\n相邻线程访问的地址之间的步幅为 $S_y = A_{k+1} - A_k = (k+1)\\pi_x - k\\pi_x = \\pi_x$。\n为实现无冲突访问，必须满足 $\\gcd(S_y, 32) = \\gcd(\\pi_x, 32) = 1$。\n由于 $32 = 2^5$，任何与 $32$ 互质的数都不能有质因数 $2$，这意味着它必须是奇数。\n因此，$y$ 方向线性访问无冲突的条件是填充后的步长 $\\pi_x$ 必须是奇数。\n条件：$\\pi_x = s_x + p_x$ 必须是奇数。\n\n**3. $z$ 方向线性访问：**\n线程访问坐标 $(0, 0, k)$，其中 $k \\in \\{0, \\dots, 31\\}$。\n线程 $k$ 的地址是 $A_k = A(0, 0, k) = k \\cdot \\pi_x \\pi_y + 0 \\cdot \\pi_x + 0 = k \\cdot \\pi_x \\pi_y$。\n相邻线程访问的地址之间的步幅为 $S_z = A_{k+1} - A_k = (k+1)\\pi_x\\pi_y - k\\pi_x\\pi_y = \\pi_x\\pi_y$。\n为实现无冲突访问，必须满足 $\\gcd(S_z, 32) = \\gcd(\\pi_x \\pi_y, 32) = 1$。\n这要求乘积 $\\pi_x \\pi_y$ 是一个奇数。两个整数的乘积是奇数，当且仅当这两个整数都是奇数。\n因此，$z$ 方向线性访问无冲突的条件是 $\\pi_x$ 和 $\\pi_y$ 都必须是奇数。\n条件：$\\pi_x = s_x + p_x$ 必须是奇数，并且 $\\pi_y = s_y + p_y$ 必须是奇数。\n\n**最小填充的推导：**\n为了同时满足所有三种访问模式的条件，$\\pi_x$ 和 $\\pi_y$ 都必须是奇数。我们需要找到实现这一目标的最小非负填充值 $p_x$ 和 $p_y$。\n\n为使 $\\pi_x = s_x + p_x$ 为奇数：\n- 如果 $s_x$ 是奇数，我们可以选择 $p_x=0$（因为奇数 + 偶数 = 奇数，而 $0$ 是偶数）。这是最小的非负选择。\n- 如果 $s_x$ 是偶数，我们必须选择一个奇数 $p_x$。最小的非负奇数值是 $p_x=1$。\n这可以概括为：如果 $s_x$ 是偶数，则 $p_x = 1$；如果 $s_x$ 是奇数，则 $p_x = 0$。这等价于 $p_x = (s_x+1) \\pmod 2$。\n\n为使 $\\pi_y = s_y + p_y$ 为奇数：\n- 类似地，如果 $s_y$ 是奇数，我们选择 $p_y=0$。\n- 如果 $s_y$ 是偶数，我们选择 $p_y=1$。\n这等价于 $p_y = (s_y+1) \\pmod 2$。\n\n这些对 $p_x$ 和 $p_y$ 的最小非负选择构成了我们推导出的填充方案。\n\n**填充开销计算：**\n填充开销是已分配共享内存元素总数的增加比例。\n原始体积为 $V_{orig} = s_x s_y s_z$。\n填充后的体积为 $V_{pad} = \\pi_x \\pi_y \\pi_z = (s_x + p_x)(s_y + p_y)s_z$。\n开销定义为：\n$$\n\\text{overhead} = \\frac{V_{pad} - V_{orig}}{V_{orig}} = \\frac{(s_x+p_x)(s_y+p_y)s_z - s_x s_y s_z}{s_x s_y s_z}\n$$\n该公式用于计算填充的量化影响。\n因此，解决方案的算法如下：\n1. 对于给定的测试用例 $(n_x, n_y, n_z, h_x, h_y, h_z)$，计算未填充的维度 $s_x, s_y, s_z$。\n2. 根据 $s_x$ 和 $s_y$ 的奇偶性确定最小非负填充 $p_x, p_y$。\n3. 计算填充后的步长 $\\pi_x, \\pi_y, \\pi_z$。\n4. 计算填充开销。\n5. 使用推导出的 $\\pi_x$ 和 $\\pi_y$ 验证所有三种访问模式的无冲突性，以确认理论推导的正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are imported, as per the rules.\n\ndef solve():\n    \"\"\"\n    Calculates the minimal padding for conflict-free shared memory access\n    and the associated overhead for a series of tile configurations.\n    \"\"\"\n    # Define the test cases from the problem statement:\n    # (n_x, n_y, n_z, h_x, h_y, h_z)\n    test_cases = [\n        (30, 2, 1, 1, 0, 0),\n        (32, 8, 4, 1, 1, 1),\n        (14, 2, 3, 1, 0, 0),\n        (1, 1, 1, 0, 0, 0),\n        (31, 32, 1, 0, 0, 0),\n    ]\n\n    results = []\n    \n    # Constants from the problem\n    warp_size = 32\n    num_banks = 32\n\n    def check_conflict_free(stride, size):\n        \"\"\"\n        Checks if an access pattern with a given stride is conflict-free.\n        An access is conflict-free if gcd(stride, size) == 1.\n        This is equivalent to checking if all threads map to a unique bank.\n        \"\"\"\n        banks = set()\n        for t in range(size):\n            bank_index = (t * stride) % size\n            banks.add(bank_index)\n        return len(banks) == size\n\n    for case in test_cases:\n        nx, ny, nz, hx, hy, hz = case\n\n        # Calculate unpadded tile extents including halos\n        sx = nx + 2 * hx\n        sy = ny + 2 * hy\n        sz = nz + 2 * hz\n\n        # Derive minimal padding px and py\n        # The padded pitch (e.g., pi_x = sx + px) must be odd to be coprime with 32.\n        # If sx is even, we need to add 1 to make it odd. p_x = 1.\n        # If sx is odd, we can add 0 to keep it odd. p_x = 0.\n        px = 1 if sx % 2 == 0 else 0\n        py = 1 if sy % 2 == 0 else 0\n\n        # Calculate padded pitches\n        pi_x = sx + px\n        pi_y = sy + py\n        pi_z = sz  # No padding in z\n\n        # Calculate padding overhead\n        vol_unpadded = sx * sy * sz\n        vol_padded = pi_x * pi_y * pi_z\n        \n        # Overhead is 0 if unpadded volume is 0 to avoid division by zero,\n        # though problem constraints ensure it's positive.\n        if vol_unpadded > 0:\n            overhead = (vol_padded - vol_unpadded) / vol_unpadded\n        else:\n            overhead = 0.0\n\n        # Verify conflict-freedom for the three access patterns\n        \n        # 1. x-line access: stride is 1\n        stride_x = 1\n        ok_x = check_conflict_free(stride_x, warp_size)\n\n        # 2. y-line access: stride is pi_x\n        stride_y = pi_x\n        ok_y = check_conflict_free(stride_y, warp_size)\n\n        # 3. z-line access: stride is pi_x * pi_y\n        stride_z = pi_x * pi_y\n        ok_z = check_conflict_free(stride_z, warp_size)\n\n        # Store the results for this case\n        results.append([px, py, overhead, ok_x, ok_y, ok_z])\n\n    # Format the final output string exactly as required, with no spaces.\n    results_str_list = []\n    for res in results:\n        # Format: [px,py,overhead,ok_x,ok_y,ok_z]\n        # Python's str() for bools gives 'True'/'False', which is acceptable.\n        res_str = f\"[{res[0]},{res[1]},{res[2]},{str(res[3]).lower()},{str(res[4]).lower()},{str(res[5]).lower()}]\"\n        results_str_list.append(res_str)\n        \n    final_output = f\"[{','.join(results_str_list)}]\"\n    # Based on the expected output format which uses lowercase booleans, I've adjusted the string formatting.\n    # The example in the problem description shows `ok_x` not as a string. However, producing a boolean literal without quotes\n    # in a string context is tricky. It's more likely that the problem expects string representations `true` or `false`.\n    # Let's re-read the example output format in the problem statement.\n    # $[p_x,p_y,\\text{overhead},\\text{ok\\_x},\\text{ok\\_y},\\text{ok\\_z}]$\n    # It seems to imply boolean literals. The provided solution framework prints the python code output.\n    # Python `print` on a list containing booleans will output `True`/`False`.\n    # The example shows `ok_x` etc as variables, not strings.\n    # \"Your program should generate single line output, which contains five test case results in a comma-separated list enclosed in square brackets, with each test case result in the form of $[p_x,p_y,\\text{overhead},\\text{ok\\_x},\\text{ok\\_y},\\text{ok\\_z}]$. $\\text{overhead}$ is a decimal number, and $\\text{ok\\_x}$, $\\text{ok\\_y}$, and $\\text{ok\\_z}$ are boolean values. For example, your output should be as follows\n    # $$ [[p_x,p_y,\\text{overhead},\\text{ok\\_x},\\text{ok\\_y},\\text{ok\\_z}],\\ldots] $$\n    # and there should be no spaces in the printout.\"\n    # The example output format itself is a bit ambiguous. It uses math formatting. A Python program will output something like `[[1,1,0.546875,True,True,True],...]`.\n    # This seems like the most reasonable interpretation. I will revert the `str().lower()` part.\n    \n    final_results_str = []\n    for r in results:\n        # Format booleans as 'True' or 'False' as per standard Python list printing.\n        final_results_str.append(f\"[{r[0]},{r[1]},{r[2]},{r[3]},{r[4]},{r[5]}]\")\n    \n    print(f\"[{','.join(final_results_str)}]\")\n\nsolve()\n```"
        }
    ]
}