{
    "hands_on_practices": [
        {
            "introduction": "在着手优化 GPU 加速的代码之前，我们必须首先建立一个能够预测和解释性能的理论框架。Roofline 模型正是一个强有力的可视化工具，它将一个计算核心（kernel）的算术强度（即每次内存访问所执行的浮点运算次数）与 GPU 的峰值计算吞吐量和内存带宽联系起来。通过本练习 ，您将学习如何计算一个典型的燃烧模拟内核的算术强度，并利用 Roofline 模型来判断其性能瓶颈，从而为后续的优化指明方向。",
            "id": "4028784",
            "problem": "一个有限体积法的反应流求解器在图形处理器（GPU）上通过一个逐单元的内核来评估物种源项。每个单元的更新执行 $F$ 次浮点运算（flops）的工作量，并通过高带宽设备内存传输 $B$ 字节的数据。假设采用双精度（binary64）算术。该内核仅对每个单元的状态执行流式的、完全合并的全局内存访问，并写回更新后的字段，单元之间没有数据重用，因此每个单元的总数据流量等于 $B$。该GPU的持续峰值双精度计算吞吐量为 $P_{\\text{peak}}$ flops/秒，持续设备内存带宽为 $\\beta$ 字节/秒。使用运算强度和屋顶线性能模型的基本定义，推导运算强度的表达式，并确定内核的性能如何受限于带宽和峰值计算这两个“屋顶”。\n\n现在，将问题具体化到以下用于详细化学物种源项内核的科学现实参数：\n- 每个单元的浮点运算工作量：$F = 6.0 \\times 10^{4}$ flops。\n- 每个单元的数据移动量：$B = 8.0 \\times 10^{3}$ 字节。\n- GPU持续峰值双精度吞吐量：$P_{\\text{peak}} = 9.7 \\times 10^{12}$ flops/秒。\n- GPU持续设备内存带宽：$\\beta = 1.6 \\times 10^{12}$ 字节/秒。\n\n仅使用基本定义，计算运算强度，并将该内核相对于带宽和计算屋顶进行定位，以获得屋顶线模型预测的持续性能。将最终数值答案表示为以每秒十亿次浮点运算（GFLOP/s）为单位的预测持续性能，并将答案四舍五入到四位有效数字。",
            "solution": "将根据指定标准对问题进行验证。\n\n### 第1步：提取已知条件\n- 每个单元的浮点运算工作量：$F = 6.0 \\times 10^{4}$ flops\n- 每个单元的数据移动量：$B = 8.0 \\times 10^{3}$ 字节\n- 算术精度：双精度 (binary64)\n- 内存访问模式：流式的、完全合并的全局内存访问，单元之间无数据重用。\n- GPU持续峰值双精度吞吐量：$P_{\\text{peak}} = 9.7 \\times 10^{12}$ flops/秒。\n- GPU持续设备内存带宽：$\\beta = 1.6 \\times 10^{12}$ 字节/秒。\n- 最终答案要求：将预测的持续性能以每秒十亿次浮点运算（GFLOP/s）表示，并四舍五入到四位有效数字。\n\n### 第2步：使用提取的已知条件进行验证\n该问题具有科学依据、问题明确且客观。\n- **科学依据：** 该问题使用了屋顶线性能模型，这是高性能计算中分析计算内核性能的一个基本且被广泛接受的工具。在GPU上运行反应流求解器的场景是计算科学中的一个标准应用。所提供的浮点运算、数据移动、峰值吞吐量和内存带宽等参数对于在现代GPU上执行复杂的化学动力学计算是符合实际的。\n- **问题明确：** 所有必要的数据（$F$、$B$、$P_{\\text{peak}}$、$\\beta$）和定义都已提供，足以使用屋顶线模型计算运算强度和预测性能。该问题是自包含的，并能导出一个唯一的、有意义的解。\n- **客观性：** 该问题使用精确的技术术语（“有限体积法”、“合并的全局内存访问”、“运算强度”）进行陈述，没有主观或含糊的语言。\n\n该问题没有表现出说明中列出的任何缺陷（例如，科学上不健全、不完整、矛盾等）。\n\n### 第3步：结论与行动\n问题有效。将提供完整的解决方案。\n\n### 解题推导\n像GPU这样的处理器上计算内核的性能通常受限于其峰值计算能力或从内存获取数据的速率。屋顶线模型将这一概念形式化。\n\n首先，我们定义内核的运算强度 $I$。它是执行的总浮点运算次数（$F$）与主内存之间移动的总数据量（$B$）之比。\n$$I = \\frac{F}{B}$$\n$I$ 的单位是 flops/字节。\n\n屋顶线模型指出，可达到的性能 $P_{\\text{attainable}}$（以 flops/秒 为单位）受两个因素限制：硬件的峰值计算吞吐量 $P_{\\text{peak}}$，以及在给定内存带宽 $\\beta$ 下可实现的性能。\n\n最大性能内在地受到处理器峰值吞吐量的限制：\n$$P_{\\text{attainable}} \\le P_{\\text{peak}}$$\n性能也受到内存子系统的限制。执行内核所需的时间 $t$ 必须至少与传输必要数据所需的时间 $t_{\\text{memory}} = B / \\beta$ 一样长。因此，性能（即 $F/t$）受限于：\n$$P_{\\text{attainable}} = \\frac{F}{t} \\le \\frac{F}{t_{\\text{memory}}} = \\frac{F}{B/\\beta} = \\left(\\frac{F}{B}\\right) \\beta = I \\cdot \\beta$$\n结合这两个限制，屋顶线模型预测的性能是这两个上限中的较小者：\n$$P_{\\text{attainable}} = \\min(P_{\\text{peak}}, I \\cdot \\beta)$$\n如果内核的性能受限于 $P_{\\text{peak}}$，则认为它是**计算受限**的；如果受限于 $I \\cdot \\beta$，则认为是**内存受限**（或带宽受限）的。这两种状态之间的转换发生在一个特定的运算强度上，称为机器的脊点 $I_{\\text{ridge}}$。通过令两个性能限制相等来找到该点：\n$$P_{\\text{peak}} = I_{\\text{ridge}} \\cdot \\beta \\implies I_{\\text{ridge}} = \\frac{P_{\\text{peak}}}{\\beta}$$\n如果内核的运算强度 $I > I_{\\text{ridge}}$，它是计算受限的。如果 $I  I_{\\text{ridge}}$，它是内存受限的。\n\n现在，我们将问题具体化到给定的参数。\n- 每个单元的浮点运算工作量：$F = 6.0 \\times 10^{4}$ flops。\n- 每个单元的数据移动量：$B = 8.0 \\times 10^{3}$ 字节。\n\n内核的运算强度为：\n$$I = \\frac{6.0 \\times 10^{4} \\text{ flops}}{8.0 \\times 10^{3} \\text{ bytes}} = \\frac{60}{8} \\text{ flops/byte} = 7.5 \\text{ flops/byte}$$\nGPU硬件参数为：\n- 峰值双精度吞吐量：$P_{\\text{peak}} = 9.7 \\times 10^{12}$ flops/s。\n- 内存带宽：$\\beta = 1.6 \\times 10^{12}$ bytes/s。\n\n接下来，我们计算GPU的脊点：\n$$I_{\\text{ridge}} = \\frac{P_{\\text{peak}}}{\\beta} = \\frac{9.7 \\times 10^{12} \\text{ flops/s}}{1.6 \\times 10^{12} \\text{ bytes/s}} = \\frac{9.7}{1.6} \\text{ flops/byte} = 6.0625 \\text{ flops/byte}$$\n我们将内核的运算强度 $I$ 与机器的脊点 $I_{\\text{ridge}}$ 进行比较：\n$$I = 7.5 \\text{ flops/byte} > I_{\\text{ridge}} = 6.0625 \\text{ flops/byte}$$\n由于内核的运算强度大于脊点，因此内核的性能是计算受限的。\n\n因此，屋顶线模型预测的性能由GPU的峰值计算吞吐量决定：\n$$P_{\\text{attainable}} = \\min(P_{\\text{peak}}, I \\cdot \\beta) = P_{\\text{peak}}$$\n$$P_{\\text{attainable}} = 9.7 \\times 10^{12} \\text{ flops/s}$$\n问题要求答案以每秒十亿次浮点运算（GFLOP/s）表示。我们知道 $1 \\text{ GFLOP/s} = 10^9 \\text{ flops/s}$。转换结果：\n$$P_{\\text{attainable}} = \\frac{9.7 \\times 10^{12} \\text{ flops/s}}{10^9 \\text{ flops/s per GFLOP/s}} = 9.7 \\times 10^3 \\text{ GFLOP/s} = 9700 \\text{ GFLOP/s}$$\n问题要求最终答案四舍五入到四位有效数字。计算出的值恰好是 $9700$，可以用四位有效数字表示。因此，无需进一步四舍五入。",
            "answer": "$$\\boxed{9700}$$"
        },
        {
            "introduction": "掌握了 Roofline 模型的基本原理后，我们便可以将其应用于评估具体的优化策略。内核融合（Kernel Fusion）是一种常见的技术，它将多个连续的计算核心合并成一个，旨在通过寄存器或共享内存重用中间数据，从而减少昂贵的全局内存读写。然而，这种融合也可能导致更复杂的内核和更高的寄存器压力。本练习  提供了一个真实的决策场景，要求您运用 Roofline 分析来量化比较内核融合与分离策略的性能，从而选择最优的实现方案。",
            "id": "4028809",
            "problem": "一个用于预混甲烷-空气火焰的反应流时间推进在图形处理单元（GPU）上实现。每个单元的化学更新会评估热力学性质、化学源项，并更新组分质量分数和温度。对于一个包含 $50$ 个组分的机理，对融合实现（即执行所有阶段而无中间全局内存写入的单个内核）的详细性能分析报告了以下每个单元的度量指标：总浮点运算次数 $F_{\\mathrm{fused}} = 1.2 \\times 10^{4}$ 和总全局内存流量 $M_{\\mathrm{fused}} = 6.0 \\times 10^{2}$ 字节（全局加载和存储的总和）。当内核被分裂为两个内核时（第一个内核计算性质和源项，第二个内核更新状态，中间的反应速率向量在全局内存中物化），总浮点运算次数大致保持不变，$F_{\\mathrm{split}} \\approx 1.2 \\times 10^{4}$，但由于中间的写入和读取以及额外的溢出/重载，每个单元的总全局内存流量增加到 $M_{\\mathrm{split}} = 1.4 \\times 10^{3}$ 字节。\n\n该GPU的峰值单精度计算吞吐量为 $P_{\\max} = 1.4 \\times 10^{13}$ 次浮点运算/秒，持续全局内存带宽为 $B_{\\max} = 9.0 \\times 10^{11}$ 字节/秒。网格有 $N_{c} = 5.0 \\times 10^{7}$ 个单元，每个时间步应用一次化学更新。假设在流式多处理器（Streaming Multiprocessors）之间具有理想的可扩展性（无争用效应或内核启动开销），并忽略延迟隐藏的缺陷。\n\n从第一性原理出发，使用 roofline 分析来确定每种策略可达性能的上限，并预测融合实现和分裂实现的单个化学更新时间步的执行时间。在这些假设下，判断哪种策略是最优的。以毫秒为单位报告最优策略在一个时间步内的预测运行时间。将您的答案四舍五入到三位有效数字，并以毫秒表示。",
            "solution": "Roofline 模型通过两个基本的机器限制和算法的计算强度来约束计算的可达到性能。这两个基本限制是处理器的峰值浮点吞吐量 $P_{\\max}$ 和内存子系统的持续全局内存带宽 $B_{\\max}$。一个算法的计算强度 $R$ 定义为往返全局内存的每字节数据所执行的浮点运算次数，即\n$$\nR \\equiv \\frac{F}{M},\n$$\n其中 $F$ 是工作负载的总浮点运算次数，$M$ 是相应的全局内存流量。Roofline 模型所隐含的性能界限是，可达到的吞吐量 $P_{\\mathrm{achieved}}$ 不能超过计算峰值或带宽限制的上限，后者是带宽与计算强度的乘积：\n$$\nP_{\\mathrm{achieved}} \\leq \\min\\!\\big( P_{\\max},\\ B_{\\max} \\, R \\big).\n$$\n该陈述从第一性原理推导而来：如果计算每移动一字节数据需要 $R$ 次浮点运算，而内存子系统每秒最多可以传输 $B_{\\max}$ 字节，那么从内存方面来看，计算每秒不能维持超过 $B_{\\max} R$ 次浮点运算；同时，任何计算都不能超过处理器的峰值 $P_{\\max}$。\n\n给定 $N_{c}$ 个单元，每个单元承载相同的工作负载，因此每个时间步的总工作量为 $F_{\\mathrm{total}} = F \\, N_{c}$。在 Roofline 界限下的执行时间 $T$ 则为\n$$\nT = \\frac{F_{\\mathrm{total}}}{P_{\\mathrm{achieved}}} = \\frac{F \\, N_{c}}{\\min\\!\\big(P_{\\max},\\ B_{\\max} R\\big)}.\n$$\n\n我们现在为这两种策略计算计算强度。\n\n对于融合内核，\n$$\nF_{\\mathrm{fused}} = 1.2 \\times 10^{4}, \\quad M_{\\mathrm{fused}} = 6.0 \\times 10^{2},\n$$\n所以\n$$\nR_{\\mathrm{fused}} = \\frac{F_{\\mathrm{fused}}}{M_{\\mathrm{fused}}} = \\frac{1.2 \\times 10^{4}}{6.0 \\times 10^{2}} = 2.0 \\times 10^{1}.\n$$\n融合内核的带宽限制上限为\n$$\nB_{\\max} R_{\\mathrm{fused}} = \\left(9.0 \\times 10^{11}\\right) \\times \\left(2.0 \\times 10^{1}\\right) = 1.8 \\times 10^{13}.\n$$\n与计算峰值进行比较，\n$$\nP_{\\max} = 1.4 \\times 10^{13}, \\quad B_{\\max} R_{\\mathrm{fused}} = 1.8 \\times 10^{13},\n$$\n融合内核是计算受限的，因为 $P_{\\max}  B_{\\max} R_{\\mathrm{fused}}$。因此\n$$\nP_{\\mathrm{achieved,fused}} = P_{\\max} = 1.4 \\times 10^{13}.\n$$\n每个时间步的总工作量是\n$$\nF_{\\mathrm{total}} = F_{\\mathrm{fused}} N_{c} = \\left(1.2 \\times 10^{4}\\right)\\left(5.0 \\times 10^{7}\\right) = 6.0 \\times 10^{11}.\n$$\n因此融合时间为\n$$\nT_{\\mathrm{fused}} = \\frac{6.0 \\times 10^{11}}{1.4 \\times 10^{13}} = 4.2857142857 \\times 10^{-2}\\ \\mathrm{s}.\n$$\n以毫秒表示，\n$$\nT_{\\mathrm{fused,ms}} = \\left(4.2857142857 \\times 10^{-2}\\right)\\times \\left(1.0 \\times 10^{3}\\right) = 4.2857142857 \\times 10^{1}\\ \\mathrm{ms} = 42.857142857\\ \\mathrm{ms}.\n$$\n\n对于分裂内核，\n$$\nF_{\\mathrm{split}} \\approx 1.2 \\times 10^{4}, \\quad M_{\\mathrm{split}} = 1.4 \\times 10^{3},\n$$\n所以\n$$\nR_{\\mathrm{split}} = \\frac{F_{\\mathrm{split}}}{M_{\\mathrm{split}}} = \\frac{1.2 \\times 10^{4}}{1.4 \\times 10^{3}} = 8.571428571.\n$$\n分裂实现的带宽限制上限为\n$$\nB_{\\max} R_{\\mathrm{split}} = \\left(9.0 \\times 10^{11}\\right) \\times \\left(8.571428571\\right) = 7.714285714 \\times 10^{12}.\n$$\n与计算峰值进行比较，\n$$\nP_{\\max} = 1.4 \\times 10^{13}, \\quad B_{\\max} R_{\\mathrm{split}} = 7.714285714 \\times 10^{12},\n$$\n分裂实现是内存受限的，因为 $B_{\\max} R_{\\mathrm{split}}  P_{\\max}$。因此\n$$\nP_{\\mathrm{achieved,split}} = 7.714285714 \\times 10^{12}.\n$$\n在总工作量 $F_{\\mathrm{total}} = 6.0 \\times 10^{11}$ 相同的情况下，分裂时间为\n$$\nT_{\\mathrm{split}} = \\frac{6.0 \\times 10^{11}}{7.714285714 \\times 10^{12}} = 7.777777778 \\times 10^{-2}\\ \\mathrm{s},\n$$\n以毫秒表示，\n$$\nT_{\\mathrm{split,ms}} = \\left(7.777777778 \\times 10^{-2}\\right)\\times \\left(1.0 \\times 10^{3}\\right) = 7.777777778 \\times 10^{1}\\ \\mathrm{ms} = 77.77777778\\ \\mathrm{ms}.\n$$\n\n决策：由于 $T_{\\mathrm{fused,ms}} \\approx 42.857142857\\ \\mathrm{ms}$ 且 $T_{\\mathrm{split,ms}} \\approx 77.77777778\\ \\mathrm{ms}$，在所述假设下，融合策略是最优的。将最优运行时间四舍五入到三位有效数字并以毫秒表示，可得\n$$\nT_{\\mathrm{optimal,ms}} = 42.9\\ \\mathrm{ms}.\n$$",
            "answer": "$$\\boxed{42.9}$$"
        },
        {
            "introduction": "除了高层级的模型分析，深入理解 GPU 的内存子系统对于实现极致性能至关重要，尤其是在执行燃烧模拟中常见的模板操作（stencil operations）时。GPU 的片上共享内存（shared memory）提供了远高于全局内存的带宽和极低的延迟，但其性能的发挥严重依赖于无冲突的访问模式。本练习  将引导您深入探索共享内存的岸（bank）结构，并推导一种内存填充（padding）方案，以系统性地消除由并行访问引发的岸冲突（bank conflicts），这是解锁模板计算全部潜能的关键一步。",
            "id": "4028757",
            "problem": "给定一个带有幻象区域的三维瓦片，该瓦片需要为计算燃烧学中的有限体积或有限差分模板操作分块置于图形处理器（GPU）的共享内存中。假设架构和布局如下：共享内存有 $32$ 个存储体（bank），线程束（warp）大小为 $32$ 个线程，且位于字地址 $a$ 的一个 $4$ 字节字的存储体索引为 $a \\bmod 32$。使用行主序布局，其中 $x$ 变化最快，其次是 $y$，然后是 $z$。该瓦片在 $x$、$y$ 和 $z$ 各个面上分别包含宽度为 $h_x$、$h_y$ 和 $h_z$ 的幻象单元。包含幻象区域的未填充瓦片尺寸为 $s_x = n_x + 2 h_x$、$s_y = n_y + 2 h_y$ 和 $s_z = n_z + 2 h_z$。你需要在 $x$ 和 $y$ 维度上引入填充，记为 $p_x$ 和 $p_y$，使得填充后的步长（pitch）为 $\\pi_x = s_x + p_x$ 和 $\\pi_y = s_y + p_y$，而 $\\pi_z = s_z$（$z$ 维度没有填充）。设索引为 $(x,y,z)$ 的元素在共享内存中的地址（以 $4$ 字节字为单位）为\n$$\nA(x,y,z) = (z \\cdot \\pi_x \\pi_y) + (y \\cdot \\pi_x) + x.\n$$\n一个线程束执行模板更新中常见的三种访问模式：\n1. $x$-线访问：线程访问 $(x_0 + t, y_0, z_0)$，其中 $t \\in \\{0,1,\\ldots,31\\}$。\n2. $y$-线访问：线程访问 $(x_0, y_0 + t, z_0)$，其中 $t \\in \\{0,1,\\ldots,31\\}$。\n3. $z$-线访问：线程访问 $(x_0, y_0, z_0 + t)$，其中 $t \\in \\{0,1,\\ldots,31\\}$。\n\n从以下基本点出发：当一个线程束中的两个或更多线程访问映射到同一存储体的不同地址时，会发生共享内存存储体冲突；而无冲突访问要求所有 $32$ 个线程都映射到不同的存储体。请推导出一个索引和填充方案，以确保所有三种访问模式下都不会发生存储体冲突。你的推导应从存储体索引公式 $b = A \\bmod 32$ 和行主序地址算术开始，并对每种模式下以 $4$ 字节字为单位的步幅进行推理。你必须明确定义在何种关于 $\\pi_x$ 和 $\\pi_y$ 的条件下，线程束在进行 $y$-线和 $z$-线访问时不会遇到存储体冲突。然后，推导满足这些条件的最小填充值 $p_x$ 和 $p_y$，并量化填充开销，其定义为已分配共享内存元素数量的分数增长：\n$$\n\\text{overhead} = \\frac{(\\pi_x \\pi_y \\pi_z) - (s_x s_y s_z)}{s_x s_y s_z}.\n$$\n你必须实现一个程序，对下面的每个测试用例，计算保证所有三种模式下无冲突访问的最小非负填充 $(p_x, p_y)$，通过显式计算 $t \\in \\{0,\\ldots,31\\}$ 的存储体索引来验证无冲突性，并输出填充、开销以及分别指示 $x$-线、$y$-线和 $z$-线访问是否无冲突的三个布尔值。始终假设元素为 $4$ 字节。基准索引 $(x_0,y_0,z_0)$ 可取为 $(0,0,0)$ 而不失一般性。\n\n测试套件（每个测试用例是一个元组 $(n_x,n_y,n_z,h_x,h_y,h_z)$）：\n- 用例 1: $(30,2,1,1,0,0)$\n- 用例 2: $(32,8,4,1,1,1)$\n- 用例 3: $(14,2,3,1,0,0)$\n- 用例 4: $(1,1,1,0,0,0)$\n- 用例 5: $(31,32,1,0,0,0)$\n\n你的程序应生成单行输出，其中包含五个测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，每个用例的结果是一个形式为 $[p_x,p_y,\\text{overhead},\\text{ok\\_x},\\text{ok\\_y},\\text{ok\\_z}]$ 的列表。$\\text{overhead}$ 使用十进制数，$\\text{ok\\_x}$、$\\text{ok\\_y}$ 和 $\\text{ok\\_z}$ 使用布尔值。例如，你的输出应如下所示\n$$\n[[p_x,p_y,\\text{overhead},\\text{ok\\_x},\\text{ok\\_y},\\text{ok\\_z}],\\ldots]\n$$\n打印行中不含空格。",
            "solution": "该问题要求为存储在图形处理器（GPU）共享内存中的三维瓦片推导一种内存填充方案，以确保执行类似模板操作的线程束能够无冲突地访问。我们首先将存储体冲突的条件形式化，然后推导防止冲突所需的最小填充。\n\nGPU 架构指定了 $N_B = 32$ 个共享内存存储体和大小为 $W = 32$ 个线程的线程束。位于地址 $a$ 的一个 $4$ 字节字的存储体索引 $b$ 由公式 $b = a \\pmod{32}$ 给出。如果同一线程束内的两个或更多线程访问映射到相同存储体索引的不同内存地址，则发生存储体冲突。为了使访问模式无冲突，线程束中的所有 $32$ 个线程必须访问映射到 $32$ 个不同存储体索引的地址。\n\n数据使用行主序布局存储在三维数组中，并在 $x$ 和 $y$ 维度上进行填充。逻辑坐标为 $(x,y,z)$ 的元素的地址 $A$ 由以下公式给出：\n$$\nA(x,y,z) = z \\cdot \\pi_x \\cdot \\pi_y + y \\cdot \\pi_x + x\n$$\n其中 $\\pi_x = s_x + p_x$ 和 $\\pi_y = s_y + p_y$ 分别是 $x$ 和 $y$ 维度的填充后步长（strides）。未填充的尺寸为 $s_x = n_x + 2h_x$，$s_y = n_y + 2h_y$ 和 $s_z = n_z + 2h_z$。注意 $\\pi_z = s_z$。我们分析一个线程束的三种指定访问模式，其中第 $k$ 个线程（$k \\in \\{0, 1, \\dots, 31\\}$）访问一个特定地址。为简单起见且不失一般性，如题所述，我们假设基准索引为 $(x_0, y_0, z_0) = (0,0,0)$。\n\n设线程 $k$ 访问的地址为 $A_k$。对应的存储体索引是 $b_k = A_k \\pmod{32}$。一个访问模式是无冲突的，当且仅当存储体索引集合 $\\{b_0, b_1, \\dots, b_{31}\\}$ 包含 $32$ 个不同的值。这等价于 $32$ 个线程访问的地址模 $32$ 的结果是互不相同的。如果线程 $k=0, \\dots, 31$ 访问的地址形式为 $A_0 + k \\cdot S$，其中 $S$ 是一个恒定的步幅，则无冲突访问的条件得以简化。存储体索引为 $(A_0 + k \\cdot S) \\pmod{32}$。这组存储体索引将是 $\\{0, 1, \\dots, 31\\}$ 的一个排列，当且仅当步幅 $S$ 与存储体数量 $N_B = 32$ 互质。即 $\\gcd(S, 32) = 1$。\n\n现在，我们推导每种访问模式的步幅 $S$。\n\n**1. x-线访问：**\n线程访问坐标 $(k, 0, 0)$，其中 $k \\in \\{0, \\dots, 31\\}$。线程 $k$ 的地址是 $A_k = A(k, 0, 0) = 0 \\cdot \\pi_x \\pi_y + 0 \\cdot \\pi_x + k = k$。连续线程访问的地址之间的步幅为 $S_x = A_{k+1} - A_k = (k+1) - k = 1$。我们检查无冲突访问的条件：$\\gcd(S_x, 32) = \\gcd(1, 32) = 1$。该条件总是满足。因此，$x$-线访问本身就是无冲突的，与任何填充无关。没有对 $\\pi_x$ 或 $\\pi_y$ 施加任何条件。\n\n**2. y-线访问：**\n线程访问坐标 $(0, k, 0)$，其中 $k \\in \\{0, \\dots, 31\\}$。线程 $k$ 的地址是 $A_k = A(0, k, 0) = 0 \\cdot \\pi_x \\pi_y + k \\cdot \\pi_x + 0 = k \\cdot \\pi_x$。连续线程访问的地址之间的步幅为 $S_y = A_{k+1} - A_k = (k+1)\\pi_x - k\\pi_x = \\pi_x$。为实现无冲突访问，我们必须有 $\\gcd(S_y, 32) = \\gcd(\\pi_x, 32) = 1$。由于 $32 = 2^5$，任何与 $32$ 互质的数都不能有质因数 $2$，这意味着它必须是奇数。因此，$y$-线访问无冲突的条件是填充后的步长 $\\pi_x$ 必须是奇数。\n条件：$\\pi_x = s_x + p_x$ 必须是奇数。\n\n**3. z-线访问：**\n线程访问坐标 $(0, 0, k)$，其中 $k \\in \\{0, \\dots, 31\\}$。线程 $k$ 的地址是 $A_k = A(0, 0, k) = k \\cdot \\pi_x \\pi_y + 0 \\cdot \\pi_x + 0 = k \\cdot \\pi_x \\pi_y$。连续线程访问的地址之间的步幅为 $S_z = A_{k+1} - A_k = (k+1)\\pi_x\\pi_y - k\\pi_x\\pi_y = \\pi_x\\pi_y$。为实现无冲突访问，我们必须有 $\\gcd(S_z, 32) = \\gcd(\\pi_x \\pi_y, 32) = 1$。这要求乘积 $\\pi_x \\pi_y$ 是一个奇数。两个整数的乘积是奇数，当且仅当两个整数都是奇数。因此，$z$-线访问无冲突的条件是 $\\pi_x$ 和 $\\pi_y$ 都必须是奇数。\n条件：$\\pi_x = s_x + p_x$ 必须是奇数 且 $\\pi_y = s_y + p_y$ 必须是奇数。\n\n**最小填充的推导：**\n为了同时满足所有三种访问模式的条件，$\\pi_x$ 和 $\\pi_y$ 都必须是奇数。我们需要找到实现这一目标的最小非负填充值 $p_x$ 和 $p_y$。\n\n为了使 $\\pi_x = s_x + p_x$ 为奇数：\n- 如果 $s_x$ 是奇数，我们可以选择 $p_x=0$（因为奇数 + 偶数 = 奇数，而 $0$ 是偶数）。这是最小的非负选择。\n- 如果 $s_x$ 是偶数，我们必须选择一个奇数 $p_x$。最小的非负奇数值是 $p_x=1$。\n这可以概括为：如果 $s_x$ 是偶数，则 $p_x = 1$；如果 $s_x$ 是奇数，则 $p_x = 0$。这等价于 $p_x = (s_x+1) \\pmod 2$。\n\n为了使 $\\pi_y = s_y + p_y$ 为奇数：\n- 类似地，如果 $s_y$ 是奇数，我们选择 $p_y=0$。\n- 如果 $s_y$ 是偶数，我们选择 $p_y=1$。\n这等价于 $p_y = (s_y+1) \\pmod 2$。\n\n这些对 $p_x$ 和 $p_y$ 的最小非负选择构成了所推导的填充方案。\n\n**填充开销计算：**\n填充开销是已分配共享内存元素总数的分数增长。原始体积为 $V_{orig} = s_x s_y s_z$。填充后的体积为 $V_{pad} = \\pi_x \\pi_y \\pi_z = (s_x + p_x)(s_y + p_y)s_z$。开销定义为：\n$$\n\\text{overhead} = \\frac{V_{pad} - V_{orig}}{V_{orig}} = \\frac{(s_x+p_x)(s_y+p_y)s_z - s_x s_y s_z}{s_x s_y s_z}\n$$\n该公式用于计算填充的量化影响。因此，解决方案的算法如下：\n1. 对于给定的测试用例 $(n_x, n_y, n_z, h_x, h_y, h_z)$，计算未填充的尺寸 $s_x, s_y, s_z$。\n2. 根据 $s_x$ 和 $s_y$ 的奇偶性确定最小非负填充 $p_x, p_y$。\n3. 计算填充后的步长 $\\pi_x, \\pi_y, \\pi_z$。\n4. 计算填充开销。\n5. 使用推导出的 $\\pi_x$ 和 $\\pi_y$ 验证所有三种访问模式的无冲突性，以确认理论推导的正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are imported, as per the rules.\n\ndef solve():\n    \"\"\"\n    Calculates the minimal padding for conflict-free shared memory access\n    and the associated overhead for a series of tile configurations.\n    \"\"\"\n    # Define the test cases from the problem statement:\n    # (n_x, n_y, n_z, h_x, h_y, h_z)\n    test_cases = [\n        (30, 2, 1, 1, 0, 0),\n        (32, 8, 4, 1, 1, 1),\n        (14, 2, 3, 1, 0, 0),\n        (1, 1, 1, 0, 0, 0),\n        (31, 32, 1, 0, 0, 0),\n    ]\n\n    results = []\n    \n    # Constants from the problem\n    warp_size = 32\n    num_banks = 32\n\n    def check_conflict_free(stride, size):\n        \"\"\"\n        Checks if an access pattern with a given stride is conflict-free.\n        An access is conflict-free if gcd(stride, size) == 1.\n        This is equivalent to checking if all threads map to a unique bank.\n        \"\"\"\n        banks = set()\n        for t in range(size):\n            bank_index = (t * stride) % size\n            banks.add(bank_index)\n        return len(banks) == size\n\n    for case in test_cases:\n        nx, ny, nz, hx, hy, hz = case\n\n        # Calculate unpadded tile extents including halos\n        sx = nx + 2 * hx\n        sy = ny + 2 * hy\n        sz = nz + 2 * hz\n\n        # Derive minimal padding px and py\n        # The padded pitch (e.g., pi_x = sx + px) must be odd to be coprime with 32.\n        # If sx is even, we need to add 1 to make it odd. p_x = 1.\n        # If sx is odd, we can add 0 to keep it odd. p_x = 0.\n        px = 1 if sx % 2 == 0 else 0\n        py = 1 if sy % 2 == 0 else 0\n\n        # Calculate padded pitches\n        pi_x = sx + px\n        pi_y = sy + py\n        pi_z = sz  # No padding in z\n\n        # Calculate padding overhead\n        vol_unpadded = sx * sy * sz\n        vol_padded = pi_x * pi_y * pi_z\n        \n        # Overhead is 0 if unpadded volume is 0 to avoid division by zero,\n        # though problem constraints ensure it's positive.\n        if vol_unpadded > 0:\n            overhead = (vol_padded - vol_unpadded) / vol_unpadded\n        else:\n            overhead = 0.0\n\n        # Verify conflict-freedom for the three access patterns\n        \n        # 1. x-line access: stride is 1\n        stride_x = 1\n        ok_x = check_conflict_free(stride_x, warp_size)\n\n        # 2. y-line access: stride is pi_x\n        stride_y = pi_x\n        ok_y = check_conflict_free(stride_y, warp_size)\n\n        # 3. z-line access: stride is pi_x * pi_y\n        stride_z = pi_x * pi_y\n        ok_z = check_conflict_free(stride_z, warp_size)\n\n        # Store the results for this case\n        results.append([px, py, overhead, ok_x, ok_y, ok_z])\n\n    # Format the final output string exactly as required, with no spaces.\n    results_str_list = []\n    for res in results:\n        # Format: [px,py,overhead,ok_x,ok_y,ok_z]\n        # Python's str() for bools gives 'True'/'False', which is acceptable.\n        res_str = f\"[{res[0]},{res[1]},{res[2]},{str(res[3]).lower()},{str(res[4]).lower()},{str(res[5]).lower()}]\"\n        results_str_list.append(res_str)\n        \n    final_output = f\"[[{','.join(results_str_list)}]]\"\n    print(final_output.replace(\" \",\"\"))\n\nsolve()\n```"
        }
    ]
}