{
    "hands_on_practices": [
        {
            "introduction": "Before embarking on complex code optimizations, it is essential to first understand the performance limitations of a computational kernel. The roofline performance model provides a powerful yet intuitive framework for this analysis, relating a kernel's computational work to its memory access demands. This practice  will guide you through applying the roofline model to a typical combustion chemistry kernel, helping you diagnose whether its performance is constrained by the GPU's memory bandwidth or its peak computational throughput. Mastering this analysis is the first step toward making informed decisions about where to focus your optimization efforts.",
            "id": "4028784",
            "problem": "A finite-volume reacting-flow solver evaluates species source terms in a per-cell kernel on a Graphics Processing Unit (GPU). Each cell update carries out a floating-point workload of $F$ floating-point operations (flops) and transfers $B$ bytes through high-bandwidth device memory. Assume double precision (binary64) arithmetic. The kernel performs only streaming, perfectly coalesced global memory accesses for the per-cell state and writes back updated fields, with no reuse across cells, so that the total data traffic per cell equals $B$. The GPU has a sustained peak double-precision compute throughput of $P_{\\text{peak}}$ flops per second and a sustained device-memory bandwidth of $\\beta$ bytes per second. Use fundamental definitions of arithmetic intensity and the roofline performance model to derive an expression for the arithmetic intensity and to determine how the kernel’s performance is bounded relative to the bandwidth and peak-compute roofs.\n\nNow specialize to the following scientifically realistic parameters for a detailed-chemistry species source term kernel:\n- Per-cell floating-point work: $F = 6.0 \\times 10^{4}$ flops.\n- Per-cell data movement: $B = 8.0 \\times 10^{3}$ bytes.\n- GPU sustained peak double-precision throughput: $P_{\\text{peak}} = 9.7 \\times 10^{12}$ flops per second.\n- GPU sustained device-memory bandwidth: $\\beta = 1.6 \\times 10^{12}$ bytes per second.\n\nUsing only fundamental definitions, compute the arithmetic intensity and place the kernel relative to the bandwidth and compute roofs to obtain the roofline-predicted sustained performance. Express your final numerical answer as the predicted sustained performance in giga floating-point operations per second (GFLOP/s), and round your answer to four significant figures.",
            "solution": "The problem will be validated according to the specified criteria.\n\n### Step 1: Extract Givens\n- Per-cell floating-point workload: $F = 6.0 \\times 10^{4}$ flops\n- Per-cell data movement: $B = 8.0 \\times 10^{3}$ bytes\n- Arithmetic precision: double precision (binary64)\n- Memory access pattern: streaming, perfectly coalesced global memory accesses, no reuse across cells.\n- GPU sustained peak double-precision throughput: $P_{\\text{peak}} = 9.7 \\times 10^{12}$ flops per second.\n- GPU sustained device-memory bandwidth: $\\beta = 1.6 \\times 10^{12}$ bytes per second.\n- Final answer requirement: express the predicted sustained performance in giga floating-point operations per second (GFLOP/s), rounded to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective.\n- **Scientifically Grounded:** The problem uses the roofline performance model, a fundamental and widely accepted tool in high-performance computing for analyzing the performance of computational kernels. The scenario of a reacting-flow solver on a GPU is a standard application in computational science. The provided parameters for floating-point operations, data movement, peak throughput, and memory bandwidth are realistic for a modern GPU executing a complex chemical kinetics calculation.\n- **Well-Posed:** All necessary data ($F$, $B$, $P_{\\text{peak}}$, $\\beta$) and definitions are provided to compute the arithmetic intensity and the predicted performance using the roofline model. The problem is self-contained and leads to a unique, meaningful solution.\n- **Objective:** The problem is stated using precise, technical terminology (\"finite-volume\", \"coalesced global memory accesses\", \"arithmetic intensity\") and is free from subjective or ambiguous language.\n\nThe problem does not exhibit any of the flaws listed in the instructions (e.g., scientific unsoundness, incompleteness, contradiction, etc.).\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation\nThe performance of a computational kernel on a processor like a GPU is typically limited by either its peak computational ability or the rate at which it can be supplied with data from memory. The roofline model formalizes this concept.\n\nFirst, we define the arithmetic intensity, $I$, of the kernel. This is the ratio of the total floating-point operations ($F$) performed to the total data volume ($B$) moved to and from main memory.\n$$I = \\frac{F}{B}$$\nThe units of $I$ are flops per byte.\n\nThe roofline model states that the attainable performance, $P_{\\text{attainable}}$, measured in flops per second, is limited by two factors: the peak compute throughput of the hardware, $P_{\\text{peak}}$, and the performance achievable given the memory bandwidth, $\\beta$.\n\nThe maximum performance is inherently capped by the processor's peak throughput:\n$$P_{\\text{attainable}} \\le P_{\\text{peak}}$$\nThe performance is also limited by the memory subsystem. The time required to execute the kernel, $t$, must be at least as long as the time it takes to transfer the necessary data, $t_{\\text{memory}} = B / \\beta$. The performance, which is $F/t$, is thus bounded by:\n$$P_{\\text{attainable}} = \\frac{F}{t} \\le \\frac{F}{t_{\\text{memory}}} = \\frac{F}{B/\\beta} = \\left(\\frac{F}{B}\\right) \\beta = I \\cdot \\beta$$\nCombining these two limits, the roofline-predicted performance is the minimum of the two ceilings:\n$$P_{\\text{attainable}} = \\min(P_{\\text{peak}}, I \\cdot \\beta)$$\nThe kernel is considered **compute-bound** if its performance is limited by $P_{\\text{peak}}$, and **memory-bound** (or bandwidth-bound) if it is limited by $I \\cdot \\beta$. The transition between these two regimes occurs at a specific arithmetic intensity known as the machine's ridge point, $I_{\\text{ridge}}$. This point is found by setting the two performance limits equal:\n$$P_{\\text{peak}} = I_{\\text{ridge}} \\cdot \\beta \\implies I_{\\text{ridge}} = \\frac{P_{\\text{peak}}}{\\beta}$$\nIf the kernel's arithmetic intensity $I > I_{\\text{ridge}}$, it is compute-bound. If $I  I_{\\text{ridge}}$, it is memory-bound.\n\nNow, we specialize to the given parameters.\n- Per-cell floating-point work: $F = 6.0 \\times 10^{4}$ flops.\n- Per-cell data movement: $B = 8.0 \\times 10^{3}$ bytes.\n\nThe arithmetic intensity of the kernel is:\n$$I = \\frac{6.0 \\times 10^{4} \\text{ flops}}{8.0 \\times 10^{3} \\text{ bytes}} = \\frac{60}{8} \\text{ flops/byte} = 7.5 \\text{ flops/byte}$$\nThe GPU hardware parameters are:\n- Peak double-precision throughput: $P_{\\text{peak}} = 9.7 \\times 10^{12}$ flops/s.\n- Memory bandwidth: $\\beta = 1.6 \\times 10^{12}$ bytes/s.\n\nNext, we compute the ridge point of the GPU:\n$$I_{\\text{ridge}} = \\frac{P_{\\text{peak}}}{\\beta} = \\frac{9.7 \\times 10^{12} \\text{ flops/s}}{1.6 \\times 10^{12} \\text{ bytes/s}} = \\frac{9.7}{1.6} \\text{ flops/byte} = 6.0625 \\text{ flops/byte}$$\nWe compare the kernel's arithmetic intensity $I$ to the machine's ridge point $I_{\\text{ridge}}$:\n$$I = 7.5 \\text{ flops/byte} > I_{\\text{ridge}} = 6.0625 \\text{ flops/byte}$$\nSince the kernel's arithmetic intensity is greater than the ridge point, the kernel's performance is compute-bound.\n\nTherefore, the roofline-predicted performance is determined by the peak compute throughput of the GPU:\n$$P_{\\text{attainable}} = \\min(P_{\\text{peak}}, I \\cdot \\beta) = P_{\\text{peak}}$$\n$$P_{\\text{attainable}} = 9.7 \\times 10^{12} \\text{ flops/s}$$\nThe problem asks for the answer to be expressed in giga floating-point operations per second (GFLOP/s). We know that $1 \\text{ GFLOP/s} = 10^9 \\text{ flops/s}$. Converting the result:\n$$P_{\\text{attainable}} = \\frac{9.7 \\times 10^{12} \\text{ flops/s}}{10^9 \\text{ flops/s per GFLOP/s}} = 9.7 \\times 10^3 \\text{ GFLOP/s} = 9700 \\text{ GFLOP/s}$$\nThe problem requires the final answer to be rounded to four significant figures. The calculated value is exactly $9700$, which can be expressed with four significant figures. Thus, no further rounding is necessary.",
            "answer": "$$\\boxed{9700}$$"
        },
        {
            "introduction": "Moving from analyzing a single kernel to architecting a full simulation, we must consider how to structure complex, multi-physics problems for the GPU. Combustion solvers often involve coupled processes like advection and chemical reactions, which can be challenging to implement efficiently in a single, monolithic kernel. This exercise  demonstrates the common and effective strategy of decomposing a reacting flow problem into a sequence of specialized kernels, each handling a distinct numerical task such as flux calculation, source term evaluation, or state updates. This hands-on practice will allow you to translate a governing partial differential equation into a modular, GPU-friendly algorithm, a fundamental skill for developing robust and scalable scientific software.",
            "id": "4028766",
            "problem": "Consider a one-dimensional, spatially periodic, finite-volume discretization of a reacting advection system used in computational combustion on modern Graphics Processing Unit (GPU) hardware. Starting from the conservation law $\\partial_t U + \\nabla \\cdot F(U) = S(U)$, derive a decomposition of the numerical method into three kernels that separately compute face fluxes, source terms, and update stages. The objective is to minimize register pressure per thread on the GPU by restricting the number of live variables in each kernel. You must formalize the derivation from first principles and implement a program that emulates the kernel decomposition in a central processing unit (CPU) environment while producing numerically correct results faithful to the conservation-law discretization.\n\nAssume the unknown vector field is $U(x,t) = [Y(x,t),\\, T(x,t)]$, where $Y$ is a dimensionless progress variable bounded in $[0,1]$ and $T$ is the absolute temperature in Kelvin. Consider a one-dimensional periodic domain of length $L$ discretized into $N$ uniform cells of width $\\Delta x = L/N$ with cell centers at $x_i$ for $i \\in \\{0,1,\\dots,N-1\\}$. The advection velocity $u$ is spatially uniform. The flux is purely advective, $F(U) = u U$, and the source term models exothermic first-order kinetics via an Arrhenius law\n$$\n\\omega(Y,T) = A \\exp\\!\\left(-\\frac{E_a}{R T}\\right) Y,\n$$\nwith heat release mapped to temperature through\n$$\nS_Y(U) = \\omega(Y,T), \\qquad S_T(U) = \\frac{q}{c_p}\\,\\omega(Y,T),\n$$\nwhere $A$ is the pre-exponential factor in $\\mathrm{s}^{-1}$, $E_a$ is the activation energy in $\\mathrm{J/mol}$, $R$ is the ideal gas constant in $\\mathrm{J/(mol\\cdot K)}$, $q/c_p$ is the temperature rise per unit progress consumed in $\\mathrm{K}$, and $c_p$ is the constant-pressure specific heat. Use $R = 8.314\\,\\mathrm{J/(mol\\cdot K)}$.\n\nStarting from the integral finite-volume form,\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} U_i(t) = -\\frac{1}{\\Delta x}\\left(F_{i+\\frac{1}{2}}(t) - F_{i-\\frac{1}{2}}(t)\\right) + S\\!\\left(U_i(t)\\right),\n$$\nderive:\n- A face-flux computation using upwind Godunov flux for constant $u$: for $u \\ge 0$, $F_{i+\\frac{1}{2}} = u\\, U_i$, and for $u  0$, $F_{i+\\frac{1}{2}} = u\\, U_{i+1}$, with periodic indexing for $i+1$ and $i-1$.\n- A source-term evaluation strictly local to each cell based on the Arrhenius rate.\n- A two-stage explicit Total Variation Diminishing (TVD) second-order Runge–Kutta update (also called Heun’s method):\n  1. Stage one: $U^{(1)}_i = U^n_i - \\Delta t\\, \\nabla \\cdot F(U^n)_i + \\Delta t\\, S(U^n_i)$.\n  2. Stage two: recompute face fluxes and sources from $U^{(1)}$, then $U^{n+1}_i = \\frac{1}{2}\\left(U^n_i + U^{(1)}_i - \\Delta t\\, \\nabla \\cdot F(U^{(1)})_i + \\Delta t\\, S(U^{(1)}_i)\\right)$.\nHere $\\nabla \\cdot F(U)_i = \\frac{1}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right)$ is the discrete divergence.\n\nExplain, using the Courant–Friedrichs–Lewy (CFL) condition, how to select a stable time step $\\Delta t$ for advection and provide a conservative bound for explicit source integration. Use\n$$\n\\Delta t_{\\text{adv}} = \\frac{\\text{CFL}\\,\\Delta x}{|u|} \\quad \\text{for } |u|  0, \\quad \\Delta t_{\\text{adv}} = +\\infty \\quad \\text{for } u = 0,\n$$\nand\n$$\n\\Delta t_{\\text{src}} = \\frac{\\alpha}{\\max_i \\left(A \\exp\\!\\left(-\\frac{E_a}{R T_i}\\right)\\right)},\n$$\nwith $0  \\alpha \\le 1$ a safety factor. Use $\\alpha$ in $[0,1)$ to maintain explicit stability. The actual time step is $\\Delta t = \\min(\\Delta t_{\\text{adv}}, \\Delta t_{\\text{src}})$.\n\nYour program must implement three CPU functions that emulate the GPU kernel decomposition:\n- A face-flux function that computes and stores $F_{i+\\frac{1}{2}}$ for all faces and a divergence for each cell.\n- A source-term function that computes $S_Y$ and $S_T$ for each cell.\n- An update-stage function that performs the two-stage TVD Runge–Kutta update using only data provided by the preceding functions.\n\nInitialize $Y$ as a bounded Gaussian centered at $x_0$ with standard deviation $\\sigma$,\n$$\nY(x) = \\min\\!\\left(1, \\max\\!\\left(0, A_Y \\exp\\!\\left(-\\frac{(x - x_0)^2}{2\\sigma^2}\\right)\\right)\\right),\n$$\nwith amplitude $A_Y$ in $(0,1]$, and set $T(x) = T_0$ uniform. Use periodic boundary conditions. Clamp $Y$ to $[0,1]$ and $T$ to $[1,\\infty)$ after each stage to ensure physical realism.\n\nTest Suite. Implement four test cases that exercise different stability and physics regimes. For each case, perform exactly one second-order time step as defined above and report:\n- The spatial mean of $Y$ (dimensionless).\n- The spatial mean of $T$ expressed in Kelvin.\n\nReport the final outputs in the specified units and in the following single-line format: a comma-separated list enclosed in square brackets of length $2M$, where $M$ is the number of test cases, ordered as $[\\overline{Y}_1, \\overline{T}_1, \\overline{Y}_2, \\overline{T}_2, \\dots, \\overline{Y}_M, \\overline{T}_M]$.\n\nUse the following test cases with parameters:\n- Case $1$ (happy path, moderate reaction): $L = 1.0\\,\\mathrm{m}$, $N = 128$, $u = 1.0\\,\\mathrm{m/s}$, $\\text{CFL} = 0.5$, $\\alpha = 0.1$, $A = 10.0\\,\\mathrm{s}^{-1}$, $E_a = 6000.0\\,\\mathrm{J/mol}$, $q/c_p = 500.0\\,\\mathrm{K}$, $A_Y = 0.8$, $x_0 = 0.25 L$, $\\sigma = 0.05 L$, $T_0 = 300.0\\,\\mathrm{K}$.\n- Case $2$ (edge case, zero advection): $L = 1.0\\,\\mathrm{m}$, $N = 64$, $u = 0.0\\,\\mathrm{m/s}$, $\\text{CFL} = 0.5$, $\\alpha = 0.05$, $A = 100.0\\,\\mathrm{s}^{-1}$, $E_a = 8000.0\\,\\mathrm{J/mol}$, $q/c_p = 400.0\\,\\mathrm{K}$, $A_Y = 0.8$, $x_0 = 0.25 L$, $\\sigma = 0.05 L$, $T_0 = 300.0\\,\\mathrm{K}$.\n- Case $3$ (near-CFL boundary, mild reaction): $L = 1.0\\,\\mathrm{m}$, $N = 256$, $u = 2.0\\,\\mathrm{m/s}$, $\\text{CFL} = 0.99$, $\\alpha = 0.1$, $A = 5.0\\,\\mathrm{s}^{-1}$, $E_a = 5000.0\\,\\mathrm{J/mol}$, $q/c_p = 300.0\\,\\mathrm{K}$, $A_Y = 0.8$, $x_0 = 0.25 L$, $\\sigma = 0.05 L$, $T_0 = 300.0\\,\\mathrm{K}$.\n- Case $4$ (stiff pre-exponential, high activation energy, reaction suppressed): $L = 1.0\\,\\mathrm{m}$, $N = 128$, $u = 1.0\\,\\mathrm{m/s}$, $\\text{CFL} = 0.7$, $\\alpha = 0.1$, $A = 10000.0\\,\\mathrm{s}^{-1}$, $E_a = 80000.0\\,\\mathrm{J/mol}$, $q/c_p = 1000.0\\,\\mathrm{K}$, $A_Y = 0.8$, $x_0 = 0.25 L$, $\\sigma = 0.05 L$, $T_0 = 300.0\\,\\mathrm{K}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, output first the mean of $Y$ (dimensionless) followed by the mean of $T$ in Kelvin, resulting in a list of $8$ floats for the four cases, ordered as $[\\overline{Y}_1,\\overline{T}_1,\\overline{Y}_2,\\overline{T}_2,\\overline{Y}_3,\\overline{T}_3,\\overline{Y}_4,\\overline{T}_4]$.",
            "solution": "The problem statement has been critically validated and is deemed to be scientifically grounded, well-posed, and self-consistent. All required data, models, and numerical methods are clearly defined, forming a solvable problem in computational science. We may therefore proceed with the derivation and solution.\n\nThe problem requires the derivation and implementation of a numerical method for the one-dimensional reacting advection system described by the conservation law:\n$$\n\\partial_t U + \\nabla \\cdot F(U) = S(U)\n$$\nHere, the state vector is $U(x,t) = [Y(x,t), T(x,t)]^T$, where $Y$ is the product progress variable and $T$ is the temperature. The flux function is purely advective, $F(U) = uU$, and the source term $S(U)$ models a first-order exothermic reaction.\n\n### Finite-Volume Discretization\n\nWe begin by applying the finite-volume method, which is based on the integral form of the conservation law. We integrate the partial differential equation (PDE) over a computational cell, or control volume, $C_i = [x_{i-1/2}, x_{i+1/2}]$, where $x_{i \\pm 1/2}$ are the cell faces and the cell width is $\\Delta x = x_{i+1/2} - x_{i-1/2}$.\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial U}{\\partial t} \\,dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial F(U)}{\\partial x} \\,dx = \\int_{x_{i-1/2}}^{x_{i+1/2}} S(U) \\,dx\n$$\nWe define the cell-averaged state as $U_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} U(x,t) \\,dx$. Assuming $U_i$ is a good representation of the state within the cell, the time derivative term becomes $\\frac{d}{dt} (\\Delta x U_i) = \\Delta x \\frac{d U_i}{dt}$. The flux term is handled by the fundamental theorem of calculus: $\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial F}{\\partial x} \\,dx = F(U(x_{i+1/2}, t)) - F(U(x_{i-1/2}, t))$. We denote the numerical flux at the cell face $x_{i+1/2}$ as $F_{i+1/2}$. The source term is approximated as being constant within the cell, evaluated at the cell-average state: $\\int_{x_{i-1/2}}^{x_{i+1/2}} S(U) \\,dx \\approx S(U_i) \\Delta x$.\n\nCombining these approximations and dividing by $\\Delta x$ yields the semi-discrete system of ordinary differential equations (ODEs) for the cell averages:\n$$\n\\frac{d U_i}{dt} = -\\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2}) + S(U_i)\n$$\nThis equation describes the time evolution of the average state in cell $i$ due to fluxes at its boundaries and sources within its volume. On a GPU, the right-hand side of this equation is evaluated in a data-parallel fashion. To optimize performance and minimize register usage per thread, the computation is decomposed into three distinct kernels.\n\n### Kernel 1: Face Flux and Divergence Computation\n\nThis kernel, emulated by the $\\texttt{compute\\_fluxes\\_and\\_divergence}$ function, calculates the discrete divergence of the flux, $\\nabla \\cdot F(U)_i = \\frac{1}{\\Delta x}(F_{i+1/2} - F_{i-1/2})$. The core task is to determine the numerical flux $F_{i+1/2}$ at each cell interface. The problem specifies the Godunov upwind method. For pure advection with a constant velocity $u$, the choice of state at the interface depends on the direction of information flow.\n\n- If $u \\ge 0$, information propagates from left to right. The state at the interface $x_{i+1/2}$ is determined by the cell to its left, $C_i$. Thus, the interface state is $U_i$, and the flux is $F_{i+1/2} = F(U_i) = u U_i$.\n- If $u  0$, information propagates from right to left. The state at the interface is determined by the cell to its right, $C_{i+1}$. Thus, the interface state is $U_{i+1}$, and the flux is $F_{i+1/2} = F(U_{i+1}) = u U_{i+1}$.\n\nThis logic is applied to all faces $i+1/2$ for $i \\in \\{0, 1, \\dots, N-1\\}$, with periodic boundary conditions, meaning indices are taken modulo $N$. For example, the right neighbor of cell $N-1$ is cell $0$. Once all face fluxes $F_{i+1/2}$ are computed, the divergence for each cell $i$ is found by subtracting the incoming flux $F_{i-1/2}$ from the outgoing flux $F_{i+1/2}$ and dividing by $\\Delta x$. This kernel takes a state vector array $U$ as input and outputs the divergence array $\\nabla \\cdot F(U)$.\n\n### Kernel 2: Source Term Computation\n\nThis kernel, emulated by the $\\texttt{compute\\_source\\_terms}$ function, evaluates the source term $S(U_i)$ for each cell. This is a purely local or \"pointwise\" operation, as $S(U_i)$ depends only on the state variables $Y_i$ and $T_i$ within cell $i$. This property makes it exceptionally well-suited for parallel execution on a GPU.\n\nThe progress variable $Y$ is assumed to represent the mass fraction of products, increasing from $0$ (unburnt) to $1$ (burnt). The problem defines the reaction rate as:\n$$\n\\omega(Y,T) = A \\exp\\!\\left(-\\frac{E_a}{R T}\\right) Y\n$$\nThe source terms for $Y$ and $T$ are given as:\n$$\nS_Y(U) = \\omega(Y,T) \\quad \\text{and} \\quad S_T(U) = \\frac{q}{c_p}\\,\\omega(Y,T)\n$$\nA positive $S_Y$ indicates that the progress variable $Y$ increases over time, consistent with it being a product. The positive $S_T$ indicates that temperature increases as the reaction proceeds, representing an exothermic process. This kernel takes the state vector $U$ as input and returns the source vector array $S(U)$.\n\n### Time Integration and Stability\n\nThe semi-discrete ODE system $\\frac{d U_i}{dt} = \\mathcal{L}(U_i)$, where $\\mathcal{L}(U) = -\\nabla \\cdot F(U) + S(U)$, must be integrated in time. The problem specifies an explicit two-stage, second-order TVD Runge-Kutta scheme (Heun's method). For an explicit method to be stable, the time step $\\Delta t$ must be sufficiently small. The limit on $\\Delta t$ arises from two distinct physical processes: advection and reaction.\n\n1.  **Advection Stability (CFL Condition)**: The Courant-Friedrichs-Lewy (CFL) condition states that the numerical domain of dependence of a point must contain the physical domain of dependence. For an explicit advection scheme, this intuitively means that information (a fluid particle) should not travel more than one cell width in a single time step. This gives the stability constraint $|u| \\frac{\\Delta t}{\\Delta x} \\le 1$. Introducing a safety factor $\\text{CFL} \\in (0, 1)$, we get the advective time step limit:\n    $$\n    \\Delta t_{\\text{adv}} = \\frac{\\text{CFL}\\,\\Delta x}{|u|} \\quad (\\text{for } |u| > 0)\n    $$\n2.  **Source Term Stability**: Chemical reactions can be \"stiff,\" meaning they occur on time scales much faster than transport. For the ODE $\\frac{dY}{dt} = k Y$, an explicit forward Euler step gives $Y^{n+1} = Y^n + \\Delta t \\, k Y^n = (1+k\\Delta t)Y^n$. While this is always stable for positive $k$, accuracy and physical relevance require the change per step to be small, i.e., $k\\Delta t \\ll 1$. A common practice for explicit integration of stiff source terms is to limit the time step by the inverse of the fastest reaction rate in the system, $\\Delta t \\le 1/k_{\\max}$. In our case, the effective rate coefficient is $k(T) = A \\exp(-E_a/RT)$. To ensure stability across the entire domain, we must use the maximum rate: $k_{\\max} = \\max_i(A \\exp(-E_a/RT_i))$. The problem provides the source term time step limit with a safety factor $\\alpha \\in (0,1)$:\n    $$\n    \\Delta t_{\\text{src}} = \\frac{\\alpha}{\\max_i \\left(A \\exp\\!\\left(-\\frac{E_a}{R T_i}\\right)\\right)}\n    $$\nThe overall time step $\\Delta t$ for the coupled system must satisfy both constraints, so we take the minimum: $\\Delta t = \\min(\\Delta t_{\\text{adv}}, \\Delta t_{\\text{src}})$.\n\n### Kernel 3: State Update\nThis kernel, emulated by the $\\texttt{update\\_stage}$ function, orchestrates the time step. It uses the outputs of the flux and source kernels to advance the solution from time $t^n$ to $t^{n+1} = t^n + \\Delta t$.\n\nFirst, the stable time step $\\Delta t$ is computed based on the state $U^n$. The two-stage update then proceeds:\n\n**Stage 1:** An intermediate state $U^{(1)}$ is computed using a forward Euler step with the right-hand-side evaluated at $U^n$.\n   - Compute $\\nabla \\cdot F(U^n)$ using Kernel 1.\n   - Compute $S(U^n)$ using Kernel 2.\n   - Update: $U^{(1)}_i = U^n_i + \\Delta t \\left( -\\nabla \\cdot F(U^n)_i + S(U^n_i) \\right)$.\n   - Apply physical clamping: $Y_i^{(1)}$ is clamped to $[0, 1]$ and $T_i^{(1)}$ to $[1, \\infty)$.\n\n**Stage 2:** The final state $U^{n+1}$ is computed by averaging the initial state $U^n$ with an update based on the intermediate state $U^{(1)}$.\n   - Compute $\\nabla \\cdot F(U^{(1)})$ using Kernel 1.\n   - Compute $S(U^{(1)})$ using Kernel 2.\n   - Update: $U^{n+1}_i = \\frac{1}{2} \\left[ U^n_i + U^{(1)}_i + \\Delta t \\left( -\\nabla \\cdot F(U^{(1)})_i + S(U^{(1)}_i) \\right) \\right]$.\n   - Apply final physical clamping to $U^{n+1}$.\n\nThis decomposition ensures that each kernel is a simple, data-parallel operation, which is the key to achieving high performance on modern GPU architectures. The CPU emulation follows this exact structure.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    # Universal gas constant in J/(mol*K)\n    R_GAS = 8.314\n\n    def compute_initial_conditions(N, L, A_Y, x_0, sigma, T_0):\n        \"\"\"\n        Initializes the state vector U = [Y, T] based on problem specifications.\n        \n        Args:\n            N (int): Number of grid cells.\n            L (float): Domain length.\n            A_Y (float): Amplitude of the initial Gaussian for Y.\n            x_0 (float): Center of the initial Gaussian profile.\n            sigma (float): Standard deviation of the initial Gaussian.\n            T_0 (float): Initial uniform temperature.\n            \n        Returns:\n            np.ndarray: Initial state vector U of shape (2, N).\n            float: Grid cell width dx.\n        \"\"\"\n        dx = L / N\n        # Cell centers\n        x = np.arange(N) * dx + dx / 2.0\n        \n        # Initialize progress variable Y with a clamped Gaussian\n        Y = A_Y * np.exp(-((x - x_0)**2) / (2 * sigma**2))\n        Y = np.clip(Y, 0.0, 1.0)\n        \n        # Initialize temperature T as uniform\n        T = np.full(N, T_0, dtype=float)\n        \n        U = np.array([Y, T])\n        return U, dx\n\n    def compute_fluxes_and_divergence(U, u, dx):\n        \"\"\"\n        Emulates the GPU kernel for computing face fluxes and their divergence.\n        Uses first-order Godunov upwinding with periodic boundary conditions.\n        \n        Args:\n            U (np.ndarray): State vector of shape (2, N).\n            u (float): Uniform advection velocity.\n            dx (float): Grid cell width.\n            \n        Returns:\n            np.ndarray: The discrete flux divergence, shape (2, N).\n        \"\"\"\n        if u >= 0:\n            # Information flows from left to right (i -> i+1/2), use state from cell i.\n            upwind_state = U\n        else:\n            # Information flows from right to left (i+1 -> i+1/2), use state from cell i+1.\n            # np.roll with shift=-1 gets element i+1 at index i (periodic).\n            upwind_state = np.roll(U, -1, axis=1)\n            \n        # Fluxes at faces i+1/2, where F_faces[:, i] corresponds to F_{i+1/2}\n        F_faces = u * upwind_state\n        \n        # Fluxes at faces i-1/2 are the fluxes from the previous face\n        # np.roll with shift=1 gets element i-1 at index i (periodic).\n        F_minus_half = np.roll(F_faces, 1, axis=1)\n        \n        # Divergence is (outgoing_flux - incoming_flux) / cell_width\n        div_F = (F_faces - F_minus_half) / dx\n        \n        return div_F\n\n    def compute_source_terms(U, A, Ea, q_over_cp):\n        \"\"\"\n        Emulates the GPU kernel for computing reaction source terms.\n        This is a pointwise operation.\n        \n        Args:\n            U (np.ndarray): State vector of shape (2, N).\n            A (float): Pre-exponential factor.\n            Ea (float): Activation energy.\n            q_over_cp (float): Temperature rise per unit progress.\n\n        Returns:\n            np.ndarray: The source term vector S, shape (2, N).\n        \"\"\"\n        Y, T = U[0, :], U[1, :]\n        \n        # Ensure temperature is positive for the exponential calculation\n        T_safe = np.maximum(T, 1.0)\n        \n        # Arrhenius reaction rate\n        omega = A * np.exp(-Ea / (R_GAS * T_safe)) * Y\n        \n        S = np.zeros_like(U)\n        # As per problem, Y is a product, so its rate is positive\n        S[0, :] = omega\n        # Heat release increases temperature\n        S[1, :] = q_over_cp * omega\n        \n        return S\n\n    def update_stage(U_n, dx, params):\n        \"\"\"\n        Emulates the GPU kernel that performs the two-stage TVD-RK2 update.\n        It orchestrates calls to the flux and source kernels.\n        \n        Args:\n            U_n (np.ndarray): State vector at time n, shape (2, N).\n            dx (float): Grid cell width.\n            params (dict): Dictionary of all simulation parameters.\n\n        Returns:\n            np.ndarray: The updated state vector at time n+1.\n        \"\"\"\n        # --- 1. Compute stable time step ---\n        # Advection time step limit (CFL condition)\n        if params['u'] == 0.0:\n            dt_adv = np.inf\n        else:\n            dt_adv = params['CFL'] * dx / np.abs(params['u'])\n            \n        # Source term time step limit (stiffness)\n        T_n_safe = np.maximum(U_n[1, :], 1.0)\n        rate_coeff = params['A'] * np.exp(-params['Ea'] / (R_GAS * T_n_safe))\n        max_rate_coeff = np.max(rate_coeff)\n        \n        if max_rate_coeff > 1e-12: # Avoid division by zero\n            dt_src = params['alpha'] / max_rate_coeff\n        else:\n            dt_src = np.inf\n            \n        dt = min(dt_adv, dt_src)\n\n        # --- 2. Stage 1 of TVD-RK2 ---\n        div_F_n = compute_fluxes_and_divergence(U_n, params['u'], dx)\n        S_n = compute_source_terms(U_n, params['A'], params['Ea'], params['q_over_cp'])\n        RHS_n = -div_F_n + S_n\n        \n        U_1 = U_n + dt * RHS_n\n        \n        # Physical clamping\n        U_1[0, :] = np.clip(U_1[0, :], 0.0, 1.0)\n        U_1[1, :] = np.clip(U_1[1, :], 1.0, None)\n        \n        # --- 3. Stage 2 of TVD-RK2 ---\n        div_F_1 = compute_fluxes_and_divergence(U_1, params['u'], dx)\n        S_1 = compute_source_terms(U_1, params['A'], params['Ea'], params['q_over_cp'])\n        RHS_1 = -div_F_1 + S_1\n        \n        U_np1 = 0.5 * (U_n + U_1 + dt * RHS_1)\n        \n        # Final physical clamping\n        U_np1[0, :] = np.clip(U_np1[0, :], 0.0, 1.0)\n        U_np1[1, :] = np.clip(U_np1[1, :], 1.0, None)\n        \n        return U_np1\n\n    # --- Test Suite Execution ---\n    test_cases = [\n        # Case 1 (happy path, moderate reaction)\n        {'L': 1.0, 'N': 128, 'u': 1.0, 'CFL': 0.5, 'alpha': 0.1, 'A': 10.0, 'Ea': 6000.0, 'q_over_cp': 500.0, 'A_Y': 0.8, 'x_0_frac': 0.25, 'sigma_frac': 0.05, 'T_0': 300.0},\n        # Case 2 (edge case, zero advection)\n        {'L': 1.0, 'N': 64, 'u': 0.0, 'CFL': 0.5, 'alpha': 0.05, 'A': 100.0, 'Ea': 8000.0, 'q_over_cp': 400.0, 'A_Y': 0.8, 'x_0_frac': 0.25, 'sigma_frac': 0.05, 'T_0': 300.0},\n        # Case 3 (near-CFL boundary, mild reaction)\n        {'L': 1.0, 'N': 256, 'u': 2.0, 'CFL': 0.99, 'alpha': 0.1, 'A': 5.0, 'Ea': 5000.0, 'q_over_cp': 300.0, 'A_Y': 0.8, 'x_0_frac': 0.25, 'sigma_frac': 0.05, 'T_0': 300.0},\n        # Case 4 (stiff pre-exponential, reaction suppressed by high Ea)\n        {'L': 1.0, 'N': 128, 'u': 1.0, 'CFL': 0.7, 'alpha': 0.1, 'A': 10000.0, 'Ea': 80000.0, 'q_over_cp': 1000.0, 'A_Y': 0.8, 'x_0_frac': 0.25, 'sigma_frac': 0.05, 'T_0': 300.0},\n    ]\n\n    results = []\n    for params in test_cases:\n        # Resolve fractional parameters\n        x_0 = params['L'] * params['x_0_frac']\n        sigma = params['L'] * params['sigma_frac']\n        \n        # 1. Set initial conditions\n        U_n, dx = compute_initial_conditions(\n            params['N'], params['L'], params['A_Y'], x_0, sigma, params['T_0']\n        )\n        \n        # 2. Perform exactly one time step\n        U_np1 = update_stage(U_n, dx, params)\n        \n        # 3. Calculate spatial means and store results\n        mean_Y, mean_T = U_np1.mean(axis=1)\n        results.extend([mean_Y, mean_T])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once the high-level structure of a solver is in place, performance gains often come from low-level, hardware-aware optimizations. For the finite-volume or finite-difference methods common in combustion simulation, stencil operations are computationally dominant and rely on fast access to neighboring data. This practice  focuses on optimizing these stencils by leveraging the GPU's programmable, on-chip shared memory. You will learn how the structured layout of this memory can lead to \"bank conflicts\" that serialize memory requests and harm performance, and you will derive a data padding scheme to mitigate this issue, ensuring your stencil kernels can achieve maximum memory throughput.",
            "id": "4028757",
            "problem": "You are given a three-dimensional tile with halo regions to be staged in Graphics Processing Unit (GPU) shared memory for finite-volume or finite-difference stencil operations in computational combustion. Assume the following architecture and layout: shared memory has $32$ banks, the warp size is $32$ threads, and the bank index for a $4$-byte word at word address $a$ is $a \\bmod 32$. Use row-major layout where $x$ varies fastest, followed by $y$, followed by $z$. The tile includes halo cells of width $h_x$, $h_y$, and $h_z$ on the $x$, $y$, and $z$ faces, respectively. The unpadded tile extents including halos are $s_x = n_x + 2 h_x$, $s_y = n_y + 2 h_y$, and $s_z = n_z + 2 h_z$. You will introduce padding in the $x$ and $y$ dimensions, denoted $p_x$ and $p_y$, so that the padded pitches are $\\pi_x = s_x + p_x$ and $\\pi_y = s_y + p_y$, and $\\pi_z = s_z$ (no padding in $z$). Let the shared-memory address in $4$-byte words for an element at indices $(x,y,z)$ be\n$$\nA(x,y,z) = (z \\cdot \\pi_x \\pi_y) + (y \\cdot \\pi_x) + x.\n$$\nA warp performs three access patterns commonly encountered in stencil updates:\n1. $x$-line access: threads access $(x_0 + t, y_0, z_0)$ for $t \\in \\{0,1,\\ldots,31\\}$.\n2. $y$-line access: threads access $(x_0, y_0 + t, z_0)$ for $t \\in \\{0,1,\\ldots,31\\}$.\n3. $z$-line access: threads access $(x_0, y_0, z_0 + t)$ for $t \\in \\{0,1,\\ldots,31\\}$.\n\nStarting from the fundamental base that a shared-memory bank conflict occurs when two or more threads in a warp access different addresses mapping to the same bank and that conflict-free access requires that all $32$ threads map to distinct banks, derive an indexing and padding scheme that ensures conflict-free bank access for all three patterns. Your derivation should begin from the bank-index formula $b = A \\bmod 32$ and the row-major address arithmetic, and reason about the stride in $4$-byte words for each pattern. You must explicitly define the conditions on $\\pi_x$ and $\\pi_y$ under which a warp experiences no bank conflicts for $y$-line and $z$-line access. Then, derive the minimal padding values $p_x$ and $p_y$ that satisfy these conditions and quantify the padding overhead, defined as the fractional increase in allocated shared-memory elements:\n$$\n\\text{overhead} = \\frac{(\\pi_x \\pi_y \\pi_z) - (s_x s_y s_z)}{s_x s_y s_z}.\n$$\nYou must implement a program that, for each test case below, computes the minimal nonnegative padding $(p_x, p_y)$ that guarantees conflict-free access for all three patterns, verifies conflict-freedom by explicitly computing bank indices for $t \\in \\{0,\\ldots,31\\}$, and outputs the padding and overhead along with three booleans indicating conflict-freedom for $x$-, $y$-, and $z$-line accesses, respectively. Assume $4$-byte elements throughout. The base indices $(x_0,y_0,z_0)$ may be taken as $(0,0,0)$ without loss of generality.\n\nTest suite (each test case is a tuple $(n_x,n_y,n_z,h_x,h_y,h_z)$):\n- Case 1: $(30,2,1,1,0,0)$\n- Case 2: $(32,8,4,1,1,1)$\n- Case 3: $(14,2,3,1,0,0)$\n- Case 4: $(1,1,1,0,0,0)$\n- Case 5: $(31,32,1,0,0,0)$\n\nYour program should produce a single line of output containing the results for the five cases as a comma-separated list enclosed in square brackets, where each case’s result is a list in the form $[p_x,p_y,\\text{overhead},\\text{ok\\_x},\\text{ok\\_y},\\text{ok\\_z}]$. Use a decimal number for $\\text{overhead}$ and booleans for $\\text{ok\\_x}$, $\\text{ok\\_y}$, and $\\text{ok\\_z}$. For example, your output should look like\n$$\n[[p_x,p_y,\\text{overhead},\\text{ok\\_x},\\text{ok\\_y},\\text{ok\\_z}],\\ldots]\n$$\nwith no spaces in the printed line.",
            "solution": "The problem requires the derivation of a memory padding scheme for a three-dimensional tile stored in a Graphics Processing Unit's (GPU) shared memory to ensure conflict-free access for a warp of threads performing stencil-like operations. We begin by formalizing the conditions for bank conflicts and then derive the minimal padding required to prevent them.\n\nThe GPU architecture specifies $N_B = 32$ shared memory banks and a warp size of $W = 32$ threads. The bank index $b$ for a $4$-byte word at address $a$ is given by the formula $b = a \\pmod{32}$. A bank conflict occurs if two or more threads within the same warp access distinct memory addresses that map to the same bank index. For an access pattern to be conflict-free, all $32$ threads in the warp must access addresses that map to $32$ distinct bank indices.\n\nThe data is stored in a 3D array using a row-major layout with padding in the $x$ and $y$ dimensions. The address $A$ of an element at logical coordinates $(x,y,z)$ is given by:\n$$\nA(x,y,z) = z \\cdot \\pi_x \\cdot \\pi_y + y \\cdot \\pi_x + x\n$$\nwhere $\\pi_x = s_x + p_x$ and $\\pi_y = s_y + p_y$ are the padded pitches (strides) in the $x$ and $y$ dimensions, respectively. The unpadded dimensions are $s_x = n_x + 2h_x$, $s_y = n_y + 2h_y$, and $s_z = n_z + 2h_z$. Note that $\\pi_z = s_z$. We analyze the three specified access patterns for a warp, where the $k$-th thread (for $k \\in \\{0, 1, \\dots, 31\\}$) accesses a specific address. For simplicity and without loss of generality as stated, we assume the base indices are $(x_0, y_0, z_0) = (0,0,0)$.\n\nLet the address accessed by thread $k$ be $A_k$. The corresponding bank index is $b_k = A_k \\pmod{32}$. An access pattern is conflict-free if and only if the set of bank indices $\\{b_0, b_1, \\dots, b_{31}\\}$ contains $32$ distinct values. This is equivalent to the addresses of the $32$ threads having distinct values modulo $32$. If the addresses accessed by threads $k=0, \\dots, 31$ are of the form $A_0 + k \\cdot S$, where $S$ is a constant stride, the condition for conflict-free access simplifies. The bank indices are $(A_0 + k \\cdot S) \\pmod{32}$. This set of bank indices will be a permutation of $\\{0, 1, \\dots, 31\\}$ if and only if the stride $S$ is coprime to the number of banks, $N_B = 32$. That is, $\\gcd(S, 32) = 1$.\n\nNow, we derive the stride $S$ for each access pattern.\n\n**1. x-line access:**\nThreads access coordinates $(k, 0, 0)$ for $k \\in \\{0, \\dots, 31\\}$.\nThe address for thread $k$ is $A_k = A(k, 0, 0) = 0 \\cdot \\pi_x \\pi_y + 0 \\cdot \\pi_x + k = k$.\nThe stride between addresses accessed by consecutive threads is $S_x = A_{k+1} - A_k = (k+1) - k = 1$.\nWe check the condition for conflict-free access: $\\gcd(S_x, 32) = \\gcd(1, 32) = 1$.\nThis condition is always met. Therefore, x-line access is inherently conflict-free, irrespective of any padding. No conditions are imposed on $\\pi_x$ or $\\pi_y$.\n\n**2. y-line access:**\nThreads access coordinates $(0, k, 0)$ for $k \\in \\{0, \\dots, 31\\}$.\nThe address for thread $k$ is $A_k = A(0, k, 0) = 0 \\cdot \\pi_x \\pi_y + k \\cdot \\pi_x + 0 = k \\cdot \\pi_x$.\nThe stride between addresses accessed by consecutive threads is $S_y = A_{k+1} - A_k = (k+1)\\pi_x - k\\pi_x = \\pi_x$.\nFor conflict-free access, we must have $\\gcd(S_y, 32) = \\gcd(\\pi_x, 32) = 1$.\nSince $32 = 2^5$, any number coprime to $32$ must not have $2$ as a prime factor, meaning it must be an odd number.\nThus, the condition for conflict-free y-line access is that the padded pitch $\\pi_x$ must be an odd number.\nCondition: $\\pi_x = s_x + p_x$ must be odd.\n\n**3. z-line access:**\nThreads access coordinates $(0, 0, k)$ for $k \\in \\{0, \\dots, 31\\}$.\nThe address for thread $k$ is $A_k = A(0, 0, k) = k \\cdot \\pi_x \\pi_y + 0 \\cdot \\pi_x + 0 = k \\cdot \\pi_x \\pi_y$.\nThe stride between addresses accessed by consecutive threads is $S_z = A_{k+1} - A_k = (k+1)\\pi_x\\pi_y - k\\pi_x\\pi_y = \\pi_x\\pi_y$.\nFor conflict-free access, we must have $\\gcd(S_z, 32) = \\gcd(\\pi_x \\pi_y, 32) = 1$.\nThis requires the product $\\pi_x \\pi_y$ to be an odd number. A product of two integers is odd if and only if both integers are odd.\nThus, the conditions for conflict-free z-line access are that both $\\pi_x$ and $\\pi_y$ must be odd numbers.\nCondition: $\\pi_x = s_x + p_x$ must be odd AND $\\pi_y = s_y + p_y$ must be odd.\n\n**Derivation of Minimal Padding:**\nTo satisfy the conditions for all three access patterns simultaneously, both $\\pi_x$ and $\\pi_y$ must be odd. We need to find the minimal non-negative padding values, $p_x$ and $p_y$, to achieve this.\n\nFor $\\pi_x = s_x + p_x$ to be odd:\n- If $s_x$ is odd, we can choose $p_x=0$ (since odd + even = odd, and $0$ is even). This is the minimal non-negative choice.\n- If $s_x$ is even, we must choose an odd $p_x$. The minimal non-negative odd value is $p_x=1$.\nThis can be summarized as: $p_x = 1$ if $s_x$ is even, and $p_x = 0$ if $s_x$ is odd. This is equivalent to $p_x = (s_x+1) \\pmod 2$.\n\nFor $\\pi_y = s_y + p_y$ to be odd:\n- Similarly, if $s_y$ is odd, we choose $p_y=0$.\n- If $s_y$ is even, we choose $p_y=1$.\nThis is equivalent to $p_y = (s_y+1) \\pmod 2$.\n\nThese minimal, non-negative choices for $p_x$ and $p_y$ constitute the derived padding scheme.\n\n**Padding Overhead Calculation:**\nThe padding overhead is the fractional increase in the total number of allocated shared memory elements.\nThe original volume is $V_{orig} = s_x s_y s_z$.\nThe padded volume is $V_{pad} = \\pi_x \\pi_y \\pi_z = (s_x + p_x)(s_y + p_y)s_z$.\nThe overhead is defined as:\n$$\n\\text{overhead} = \\frac{V_{pad} - V_{orig}}{V_{orig}} = \\frac{(s_x+p_x)(s_y+p_y)s_z - s_x s_y s_z}{s_x s_y s_z}\n$$\nThis formula is used to compute the quantitative impact of the padding.\nThe algorithm for the solution is thus:\n1. For a given test case $(n_x, n_y, n_z, h_x, h_y, h_z)$, compute the unpadded dimensions $s_x, s_y, s_z$.\n2. Determine the minimal non-negative padding $p_x, p_y$ based on the parity of $s_x$ and $s_y$.\n3. Compute the padded pitches $\\pi_x, \\pi_y, \\pi_z$.\n4. Calculate the padding overhead.\n5. Verify conflict-freedom for all three access patterns using the derived $\\pi_x$ and $\\pi_y$ to confirm the theoretical derivation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are imported, as per the rules.\n\ndef solve():\n    \"\"\"\n    Calculates the minimal padding for conflict-free shared memory access\n    and the associated overhead for a series of tile configurations.\n    \"\"\"\n    # Define the test cases from the problem statement:\n    # (n_x, n_y, n_z, h_x, h_y, h_z)\n    test_cases = [\n        (30, 2, 1, 1, 0, 0),\n        (32, 8, 4, 1, 1, 1),\n        (14, 2, 3, 1, 0, 0),\n        (1, 1, 1, 0, 0, 0),\n        (31, 32, 1, 0, 0, 0),\n    ]\n\n    results = []\n    \n    # Constants from the problem\n    warp_size = 32\n    num_banks = 32\n\n    def check_conflict_free(stride, size):\n        \"\"\"\n        Checks if an access pattern with a given stride is conflict-free.\n        An access is conflict-free if gcd(stride, size) == 1.\n        This is equivalent to checking if all threads map to a unique bank.\n        \"\"\"\n        banks = set()\n        for t in range(size):\n            bank_index = (t * stride) % size\n            banks.add(bank_index)\n        return len(banks) == size\n\n    for case in test_cases:\n        nx, ny, nz, hx, hy, hz = case\n\n        # Calculate unpadded tile extents including halos\n        sx = nx + 2 * hx\n        sy = ny + 2 * hy\n        sz = nz + 2 * hz\n\n        # Derive minimal padding px and py\n        # The padded pitch (e.g., pi_x = sx + px) must be odd to be coprime with 32.\n        # If sx is even, we need to add 1 to make it odd. p_x = 1.\n        # If sx is odd, we can add 0 to keep it odd. p_x = 0.\n        px = 1 if sx % 2 == 0 else 0\n        py = 1 if sy % 2 == 0 else 0\n\n        # Calculate padded pitches\n        pi_x = sx + px\n        pi_y = sy + py\n        pi_z = sz  # No padding in z\n\n        # Calculate padding overhead\n        vol_unpadded = sx * sy * sz\n        vol_padded = pi_x * pi_y * pi_z\n        \n        # Overhead is 0 if unpadded volume is 0 to avoid division by zero,\n        # though problem constraints ensure it's positive.\n        if vol_unpadded > 0:\n            overhead = (vol_padded - vol_unpadded) / vol_unpadded\n        else:\n            overhead = 0.0\n\n        # Verify conflict-freedom for the three access patterns\n        \n        # 1. x-line access: stride is 1\n        stride_x = 1\n        ok_x = check_conflict_free(stride_x, warp_size)\n\n        # 2. y-line access: stride is pi_x\n        stride_y = pi_x\n        ok_y = check_conflict_free(stride_y, warp_size)\n\n        # 3. z-line access: stride is pi_x * pi_y\n        stride_z = pi_x * pi_y\n        ok_z = check_conflict_free(stride_z, warp_size)\n\n        # Store the results for this case\n        results.append([px, py, overhead, ok_x, ok_y, ok_z])\n\n    # Format the final output string exactly as required, with no spaces.\n    results_str_list = []\n    for res in results:\n        # Format: [px,py,overhead,ok_x,ok_y,ok_z]\n        # Python's str() for bools gives 'True'/'False', which needs to be lowercase.\n        res_str = f\"[{res[0]},{res[1]},{res[2]},{str(res[3]).lower()},{str(res[4]).lower()},{str(res[5]).lower()}]\"\n        results_str_list.append(res_str)\n        \n    final_output = f\"[{','.join(results_str_list)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}