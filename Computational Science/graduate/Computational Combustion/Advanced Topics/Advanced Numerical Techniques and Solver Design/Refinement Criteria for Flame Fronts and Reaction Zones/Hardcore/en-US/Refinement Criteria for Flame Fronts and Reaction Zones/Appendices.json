{
    "hands_on_practices": [
        {
            "introduction": "The first step in any adaptive simulation of combustion is to accurately locate the phenomena of interest. This practice provides a foundational exercise in identifying a premixed flame front and quantifying its characteristic thickness using standard, physically-based definitions. By translating the concepts of a temperature-based progress variable and the full-width at half-maximum of the heat release rate into a computational algorithm, you will develop the essential skill of extracting key flame metrics from raw simulation data .",
            "id": "4057465",
            "problem": "You are given smooth one-dimensional fields representing a premixed laminar flame: temperature $T(x)$ in kelvin and a single-step mass reaction rate per unit volume $\\dot{\\omega}(x)$ in $\\mathrm{kg\\,m^{-3}\\,s^{-1}}$, both defined on a bounded spatial interval with uniform grid. Using accepted definitions from computational combustion, implement a program that, for each provided test case, computes two refinement metrics associated with a flame front and reaction zone: (i) the flame front location $x_f$ defined by a temperature-based progress variable at $c=0.5$, and (ii) the reaction zone thickness $\\Delta_R$ defined as the full-width at half-maximum (FWHM) of the magnitude of the volumetric heat release rate $\\lvert \\dot{q}(x) \\rvert$. All outputs must be expressed in meters as decimal floats.\n\nFundamental bases and definitions to use:\n\n- The temperature-based progress variable is normalized as $c(x) = \\dfrac{T(x) - T_u}{T_b - T_u}$, where $T_u$ and $T_b$ are the unburned and burned temperatures, respectively. For the purpose of this problem, define $T_u = \\min_{x} T(x)$ and $T_b = \\max_{x} T(x)$ over the given domain.\n\n- The flame front location $x_f$ is the unique $x$ such that $c(x_f) = 0.5$. In discrete data, determine $x_f$ by linear interpolation between the two grid points that straddle $c=0.5$.\n\n- The volumetric heat release rate for a single-step global reaction is modeled as $\\dot{q}(x) = Q\\,\\dot{\\omega}(x)$, where $Q$ is the heat of reaction per unit mass. Use $Q = 5.0 \\times 10^{7}\\,\\mathrm{J\\,kg^{-1}}$. Compute the magnitude $\\lvert \\dot{q}(x) \\rvert$ and identify the dominant peak nearest to $x_f$. Define the reaction zone thickness $\\Delta_R$ as the FWHM around that peak: i.e., the distance between the two positions on either side of the peak where $\\lvert \\dot{q}(x) \\rvert$ equals half of the peak value, computed via linear interpolation on the discrete grid.\n\nAlgorithmic requirements:\n\n- Interpolate linearly for both $x_f$ and the half-maximum crossing points that define $\\Delta_R$.\n\n- If multiple local maxima of $\\lvert \\dot{q}(x) \\rvert$ exist, choose the one with minimal absolute distance to $x_f$.\n\n- Ensure scientific realism by working on smooth profiles; the provided test cases satisfy monotonic $T(x)$ trends and localized reaction zones.\n\nUnits and output format:\n\n- Express $x_f$ and $\\Delta_R$ in meters as decimal floats.\n\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list of lists enclosed in square brackets, with each inner list containing $[x_f,\\Delta_R]$ for one test case. For example: $[\\,[x_{f,1},\\Delta_{R,1}],\\,[x_{f,2},\\Delta_{R,2}]\\,]$. Format all floats with six digits after the decimal point.\n\nTest suite:\n\nFor each test case, construct a uniform grid $x$ and define $T(x)$ and $\\dot{\\omega}(x)$ as follows. All parameters are in standard units with $x$ in meters.\n\n- Test case $1$ (happy path, single Gaussian reaction zone):\n  - Domain: $x \\in [-5\\times 10^{-3},\\,5\\times 10^{-3}]$ with $N=2001$ points.\n  - Temperature: $T_u = 300$, $T_b = 2200$, $L_T = 5.0\\times 10^{-4}$, $T(x) = T_u + (T_b - T_u)\\,\\dfrac{1}{2}\\left(1 + \\tanh\\left(\\dfrac{x}{L_T}\\right)\\right)$.\n  - Reaction rate: amplitude $A = 1.2$, center $x_0 = 0$, width $\\sigma = 2.5\\times 10^{-4}$, $\\dot{\\omega}(x) = A \\exp\\!\\left(-\\dfrac{(x - x_0)^2}{2\\sigma^2}\\right)$.\n\n- Test case $2$ (two peaks, select peak nearest to front):\n  - Domain: $x \\in [-6\\times 10^{-3},\\,6\\times 10^{-3}]$ with $N=2401$ points.\n  - Temperature: $T_u = 300$, $T_b = 2200$, $L_T = 6.0\\times 10^{-4}$, offset $x_f^{(0)} = -1.0\\times 10^{-3}$,\n    $T(x) = T_u + (T_b - T_u)\\,\\dfrac{1}{2}\\left(1 + \\tanh\\left(\\dfrac{x - x_f^{(0)}}{L_T}\\right)\\right)$.\n  - Reaction rate: two Gaussians with $A_1 = 0.8$, $x_1 = -1.0\\times 10^{-3}$, $\\sigma_1 = 2.0\\times 10^{-4}$, and $A_2 = 0.5$, $x_2 = 1.5\\times 10^{-3}$, $\\sigma_2 = 3.5\\times 10^{-4}$,\n    $\\dot{\\omega}(x) = A_1 \\exp\\!\\left(-\\dfrac{(x - x_1)^2}{2\\sigma_1^2}\\right) + A_2 \\exp\\!\\left(-\\dfrac{(x - x_2)^2}{2\\sigma_2^2}\\right)$.\n\n- Test case $3$ (non-Gaussian, compact parabolic reaction zone):\n  - Domain: $x \\in [-3\\times 10^{-3},\\,3\\times 10^{-3}]$ with $N=1201$ points.\n  - Temperature: $T_u = 300$, $T_b = 2200$, $L_T = 3.0\\times 10^{-4}$, $T(x) = T_u + (T_b - T_u)\\,\\dfrac{1}{2}\\left(1 + \\tanh\\left(\\dfrac{x}{L_T}\\right)\\right)$.\n  - Reaction rate: amplitude $A = 0.6$, center $x_0 = 5.0\\times 10^{-4}$, half-width parameter $\\sigma = 6.0\\times 10^{-4}$,\n    $\\dot{\\omega}(x) = \\max\\!\\left\\{0,\\;A\\left(1 - \\left(\\dfrac{x - x_0}{\\sigma}\\right)^2\\right)\\right\\}$.\n\nYour program must compute, for each test case, the pair $[x_f,\\Delta_R]$ and produce a single line of output containing the list of these pairs, in meters, each float formatted with six digits after the decimal point, as in $[[x_{f,1},\\Delta_{R,1}],[x_{f,2},\\Delta_{R,2}],[x_{f,3},\\Delta_{R,3}]]$.",
            "solution": "The user-provided problem statement has been analyzed and is deemed valid. It is scientifically grounded in the principles of computational combustion, well-posed with clear definitions and constraints, and objective in its formulation. All necessary data for a unique and verifiable solution are provided.\n\nThe task is to compute two metrics for a one-dimensional laminar flame profile: the flame front location $x_f$ and the reaction zone thickness $\\Delta_R$. The solution for each test case proceeds in two main stages.\n\n### Stage 1: Determination of the Flame Front Location ($x_f$)\n\nThe flame front location is defined based on the progress of the reaction, which is quantified by a normalized temperature field.\n\n**1.1. Progress Variable Definition**\nThe temperature-based progress variable, $c(x)$, is defined as:\n$$c(x) = \\frac{T(x) - T_u}{T_b - T_u}$$\nwhere $T(x)$ is the temperature field. The unburned temperature, $T_u$, and the burned temperature, $T_b$, are defined as the global minimum and maximum of the temperature profile over the spatial domain, respectively:\n$$T_u = \\min_{x} T(x)$$\n$$T_b = \\max_{x} T(x)$$\nBy this definition, the progress variable is bounded, $c(x) \\in [0, 1]$.\n\n**1.2. Flame Front Location ($x_f$)**\nThe flame front, $x_f$, is defined as the unique spatial coordinate where the progress variable is equal to $0.5$:\n$$c(x_f) = 0.5$$\nGiven that the data are provided on a discrete, uniform grid $x_i$, the location $x_f$ is determined via linear interpolation. First, we identify two adjacent grid points, $x_i$ and $x_{i+1}$, that straddle the value $c = 0.5$. That is, we find an index $i$ such that $c(x_i) \\le 0.5 < c(x_{i+1})$ or $c(x_i) \\ge 0.5 > c(x_{i+1})$. For the monotonically increasing temperature profiles provided, the former case applies.\n\nThe linear interpolation formula to find $x_f$ is:\n$$x_f = x_i + (x_{i+1} - x_i) \\frac{0.5 - c(x_i)}{c(x_{i+1}) - c(x_i)}$$\n\n### Stage 2: Determination of the Reaction Zone Thickness ($\\Delta_R$)\n\nThe reaction zone thickness is defined as the full-width at half-maximum (FWHM) of the magnitude of the volumetric heat release rate, centered around the dominant peak.\n\n**2.1. Volumetric Heat Release Rate**\nThe volumetric heat release rate, $\\dot{q}(x)$, is given by:\n$$\\dot{q}(x) = Q \\cdot \\dot{\\omega}(x)$$\nwhere $\\dot{\\omega}(x)$ is the mass reaction rate per unit volume and $Q$ is the heat of reaction per unit mass, provided as $Q = 5.0 \\times 10^7 \\, \\mathrm{J\\,kg^{-1}}$. The analysis is performed on the magnitude of this quantity, $|\\dot{q}(x)|$. Since the provided reaction rate profiles $\\dot{\\omega}(x)$ are non-negative, $|\\dot{q}(x)| = \\dot{q}(x)$.\n\n**2.2. Peak Identification and Selection**\nThe profile $|\\dot{q}(x)|$ may have one or more local maxima. We must identify all such peaks in the discrete data. A point $x_j$ is a local maximum if $|\\dot{q}(x_j)| > |\\dot{q}(x_{j-1})|$ and $|\\dot{q}(x_j)| > |\\dot{q}(x_{j+1})|$.\n\nIf multiple peaks exist, the problem specifies selecting the one whose location, $x_{\\text{peak}}$, is closest to the previously determined flame front location, $x_f$. We select the peak that minimizes the distance $|x_{\\text{peak}} - x_f|$.\n\n**2.3. Full-Width at Half-Maximum (FWHM) Calculation**\nLet the value of the selected peak be $|\\dot{q}|_{\\text{max}}$. The half-maximum value is $0.5 \\cdot |\\dot{q}|_{\\text{max}}$. The reaction zone thickness, $\\Delta_R$, is the distance between the two points, $x_L$ and $x_R$, on the left and right sides of the peak, respectively, where the heat release rate equals this half-maximum value.\n$$\\Delta_R = x_R - x_L$$\nwhere $|\\dot{q}(x_L)| = |\\dot{q}(x_R)| = 0.5 \\cdot |\\dot{q}|_{\\text{max}}$.\n\nThese points, $x_L$ and $x_R$, are found by linear interpolation on the discrete grid.\n- To find $x_L$, we search for two adjacent grid points $x_j$ and $x_{j+1}$ to the left of the peak ($x_j, x_{j+1} < x_{\\text{peak}}$) that straddle the half-maximum value. The interpolation is:\n$$x_L = x_j + (x_{j+1} - x_j) \\frac{0.5 |\\dot{q}|_{\\text{max}} - |\\dot{q}(x_j)|}{|\\dot{q}(x_{j+1})| - |\\dot{q}(x_j)|}$$\n- To find $x_R$, we search for two adjacent grid points $x_k$ and $x_{k+1}$ to the right of the peak ($x_k, x_{k+1} > x_{\\text{peak}}$) that satisfy the same condition. The interpolation is:\n$$x_R = x_k + (x_{k+1} - x_k) \\frac{0.5 |\\dot{q}|_{\\text{max}} - |\\dot{q}(x_k)|}{|\\dot{q}(x_{k+1})| - |\\dot{q}(x_k)|}$$\n\nThis systematic procedure is applied to each test case to derive the required metrics.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the calculation for all test cases and print the final result.\n    \"\"\"\n    \n    # Heat of reaction per unit mass in J/kg\n    Q = 5.0e7\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"domain\": (-5e-3, 5e-3), \"N\": 2001,\n            \"T_params\": {\"Tu\": 300.0, \"Tb\": 2200.0, \"L_T\": 5.0e-4},\n            \"T_func\": lambda x, p: p[\"Tu\"] + (p[\"Tb\"] - p[\"Tu\"]) * 0.5 * (1 + np.tanh(x / p[\"L_T\"])),\n            \"omega_params\": {\"A\": 1.2, \"x0\": 0.0, \"sigma\": 2.5e-4},\n            \"omega_func\": lambda x, p: p[\"A\"] * np.exp(-(x - p[\"x0\"])**2 / (2 * p[\"sigma\"]**2))\n        },\n        {\n            \"domain\": (-6e-3, 6e-3), \"N\": 2401,\n            \"T_params\": {\"Tu\": 300.0, \"Tb\": 2200.0, \"L_T\": 6.0e-4, \"x_f0\": -1.0e-3},\n            \"T_func\": lambda x, p: p[\"Tu\"] + (p[\"Tb\"] - p[\"Tu\"]) * 0.5 * (1 + np.tanh((x - p[\"x_f0\"]) / p[\"L_T\"])),\n            \"omega_params\": {\"A1\": 0.8, \"x1\": -1.0e-3, \"sigma1\": 2.0e-4, \"A2\": 0.5, \"x2\": 1.5e-3, \"sigma2\": 3.5e-4},\n            \"omega_func\": lambda x, p: (p[\"A1\"] * np.exp(-(x - p[\"x1\"])**2 / (2 * p[\"sigma1\"]**2)) +\n                                       p[\"A2\"] * np.exp(-(x - p[\"x2\"])**2 / (2 * p[\"sigma2\"]**2)))\n        },\n        {\n            \"domain\": (-3e-3, 3e-3), \"N\": 1201,\n            \"T_params\": {\"Tu\": 300.0, \"Tb\": 2200.0, \"L_T\": 3.0e-4},\n            \"T_func\": lambda x, p: p[\"Tu\"] + (p[\"Tb\"] - p[\"Tu\"]) * 0.5 * (1 + np.tanh(x / p[\"L_T\"])),\n            \"omega_params\": {\"A\": 0.6, \"x0\": 5.0e-4, \"sigma\": 6.0e-4},\n            \"omega_func\": lambda x, p: np.maximum(0, p[\"A\"] * (1 - ((x - p[\"x0\"]) / p[\"sigma\"])**2))\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _calculate_metrics(case, Q)\n        results.append(result)\n\n    # Format the final output string.\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _linear_interpolate(x_target, y_data, x_data):\n    \"\"\"General linear interpolation function.\"\"\"\n    # Find the index where y_target would be inserted in a sorted y_data\n    # This identifies the interval for interpolation.\n    i = np.searchsorted(y_data, x_target)\n    \n    # Handle edge cases where target is outside data range, though not expected here\n    if i == 0 or i == len(y_data):\n        # Fallback to direct search if searchsorted fails due to non-monotonicity\n        # around the target (not expected for c(x)).\n        for k in range(len(y_data) - 1):\n             if (y_data[k] <= x_target < y_data[k+1]) or (y_data[k] >= x_target > y_data[k+1]):\n                 i = k + 1\n                 break\n        else: # This else belongs to the for-loop\n             return np.nan # Target not found in any interval\n\n    y1, y2 = y_data[i - 1], y_data[i]\n    x1, x2 = x_data[i - 1], x_data[i]\n\n    return x1 + (x2 - x1) * (x_target - y1) / (y2 - y1)\n    \ndef _calculate_metrics(case, Q):\n    \"\"\"\n    Computes [x_f, Delta_R] for a single test case.\n    \"\"\"\n    # 1. Generate grid and profiles\n    x = np.linspace(case[\"domain\"][0], case[\"domain\"][1], case[\"N\"])\n    T = case[\"T_func\"](x, case[\"T_params\"])\n    omega_dot = case[\"omega_func\"](x, case[\"omega_params\"])\n\n    # 2. Calculate flame front location x_f\n    Tu = np.min(T)\n    Tb = np.max(T)\n    c = (T - Tu) / (Tb - Tu)\n    \n    # Find indices straddling c=0.5\n    # np.searchsorted is efficient for monotonic arrays\n    idx = np.searchsorted(c, 0.5)\n    \n    # Perform linear interpolation for x_f\n    c1, c2 = c[idx - 1], c[idx]\n    x1, x2 = x[idx - 1], x[idx]\n    xf = x1 + (x2 - x1) * (0.5 - c1) / (c2 - c1)\n\n    # 3. Calculate heat release rate and find dominant peak\n    q_dot_mag = np.abs(Q * omega_dot)\n    \n    # Find all peaks in the heat release rate profile\n    peak_indices, _ = find_peaks(q_dot_mag)\n    \n    if len(peak_indices) == 0: # Should not happen with given test cases\n        return [xf, np.nan]\n    elif len(peak_indices) == 1:\n        chosen_peak_idx = peak_indices[0]\n    else:\n        # Choose the peak closest to xf\n        peak_locations = x[peak_indices]\n        distances = np.abs(peak_locations - xf)\n        chosen_peak_idx = peak_indices[np.argmin(distances)]\n\n    # 4. Calculate reaction zone thickness Delta_R (FWHM)\n    q_dot_max = q_dot_mag[chosen_peak_idx]\n    half_max = 0.5 * q_dot_max\n\n    # Find left crossing point x_L\n    x_L = 0.0\n    for i in range(chosen_peak_idx, 0, -1):\n        if q_dot_mag[i-1] < half_max <= q_dot_mag[i]:\n            y1, y2 = q_dot_mag[i-1], q_dot_mag[i]\n            x_L = x[i-1] + (x[i] - x[i-1]) * (half_max - y1) / (y2 - y1)\n            break\n            \n    # Find right crossing point x_R\n    x_R = 0.0\n    for i in range(chosen_peak_idx, len(q_dot_mag) - 1):\n        if q_dot_mag[i] >= half_max > q_dot_mag[i+1]:\n            y1, y2 = q_dot_mag[i], q_dot_mag[i+1]\n            x_R = x[i] + (x[i+1] - x[i]) * (half_max - y1) / (y2 - y1)\n            break\n    \n    delta_R = x_R - x_L\n\n    return [xf, delta_R]\n\nsolve()\n```"
        },
        {
            "introduction": "While temperature provides a convenient marker for the flame front, it is not the only one; species concentrations and reaction rates offer alternative, and sometimes more direct, pointers to the reaction zone. This exercise explores the practical reality that different flame markers are not always co-located and can have varying sensitivity to numerical noise or poor resolution . You will compare several common indicators and then construct a robust, combined refinement criterion designed to be more reliable than any single marker alone, a crucial step towards developing stable and efficient Adaptive Mesh Refinement (AMR) strategies.",
            "id": "4057428",
            "problem": "Consider the problem of localizing a flame front and reaction zone in a one-dimensional premixed flame using multiple markers and designing a robust refinement indicator for Adaptive Mesh Refinement (AMR). The domain is along a spatial coordinate $x$ in meters. The provided synthetic datasets approximate a statistically steady, one-dimensional premixed flame. Physical fields include temperature $T$ in Kelvin, hydroxyl mass fraction $Y_{\\mathrm{OH}}$ (dimensionless), and the magnitude of volumetric heat release rate $|\\dot{q}|$ in watts per cubic meter. You must compute localization metrics based on first principles and propose a robust combined refinement criterion. All distances must be expressed in meters.\n\nFundamental base and definitions to use:\n- Begin from the conservation of energy and species in reacting flows. In a steady, one-dimensional premixed flame, heat conduction and chemical reaction balance to create a thin region of large temperature gradient, often used to define the flame front. Let $T(x)$ denote temperature, $Y_{\\mathrm{OH}}(x)$ denote hydroxyl mass fraction indicating strong reaction activity, and $|\\dot{q}(x)|$ denote heat release rate magnitude. For species and energy, the local production rates induce peaks in $Y_{\\mathrm{OH}}$ and $|\\dot{q}|$ near the reaction zone. The heat release rate is defined by $|\\dot{q}| = \\left| -\\sum_k h_k \\dot{\\omega}_k \\right|$, where $h_k$ is species enthalpy and $\\dot{\\omega}_k$ is net species production rate; however, for this synthetic dataset $|\\dot{q}|(x)$ is directly prescribed.\n- Define the flame front position by the location of the largest magnitude temperature gradient, i.e., the $x$ at which $|\\partial T/\\partial x|$ attains its maximum. Define a reaction zone location by the maximum of $|\\dot{q}(x)|$. The hydroxyl mass fraction can be used either as a front indicator via its gradient $|\\partial Y_{\\mathrm{OH}}/\\partial x|$ or as a reaction indicator via its peak $Y_{\\mathrm{OH}}$.\n- Define a thermal thickness $\\delta_{\\mathrm{th}}$ as the distance between the positions $x_{0.1}$ and $x_{0.9}$ where $T(x)$ reaches $T_u + 0.1\\,(T_b - T_u)$ and $T_u + 0.9\\,(T_b - T_u)$, respectively, with $T_u$ the unburned temperature and $T_b$ the burned temperature. This thickness is used to normalize localization sensitivity.\n\nSynthetic datasets (all parameters are exact and must be used as given):\n- Dataset $1$ (\"happy path\"): Domain length $L = 0.02$ and grid points $N = 400$, hence uniform spacing $\\Delta x = L/(N-1)$. Unburned temperature $T_u = 300$, burned temperature $T_b = 2100$, nominal front center $x_0 = 0.010$, thermal transition parameter $\\delta_T = 0.0005$. Temperature profile: $T(x) = T_u + (T_b - T_u)\\,\\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_0}{\\delta_T}\\right)\\right)$. Hydroxyl profile: $Y_{\\mathrm{OH}}(x) = Y_{\\text{peak}}\\exp\\left(-\\frac{(x - x_0 - s_{\\mathrm{OH}})^2}{2\\sigma_{\\mathrm{OH}}^2}\\right)$ with $Y_{\\text{peak}} = 0.01$, $s_{\\mathrm{OH}} = 0.0001$, $\\sigma_{\\mathrm{OH}} = 0.0003$. Heat release profile: $|\\dot{q}|(x) = q_{\\text{peak}}\\exp\\left(-\\frac{(x - x_0 - s_q)^2}{2\\sigma_q^2}\\right)$ with $q_{\\text{peak}} = 5\\times 10^9$, $s_q = 0.00015$, $\\sigma_q = 0.00025$.\n- Dataset $2$ (\"thin-front boundary\"): Domain length $L = 0.01$, grid points $N = 60$, $T_u = 300$, $T_b = 2100$, $x_0 = 0.005$, $\\delta_T = 0.0002$. Hydroxyl: $Y_{\\text{peak}} = 0.01$, $s_{\\mathrm{OH}} = 0.00006$, $\\sigma_{\\mathrm{OH}} = 0.00015$. Heat release: $q_{\\text{peak}} = 3\\times 10^9$, $s_q = 0.00008$, $\\sigma_q = 0.00012$. Temperature $T(x)$ and $Y_{\\mathrm{OH}}(x)$ and $|\\dot{q}|(x)$ defined as in dataset $1$ with these parameters.\n- Dataset $3$ (\"noisy signals edge case\"): Same as dataset $1$ but add zero-mean Gaussian noise. For $Y_{\\mathrm{OH}}$, add $\\eta_Y$ with standard deviation $0.05\\,Y_{\\text{peak}}$. For $|\\dot{q}|$, add $\\eta_q$ with standard deviation $0.05\\,q_{\\text{peak}}$. For $T$, add negligible noise $\\eta_T$ with standard deviation $0.005\\,(T_b - T_u)$. All noise should be independent and reproducible with a fixed random seed, specifically use seed $12345$.\n\nTasks:\n- For each dataset, compute spatial derivatives using second-order centered differences for interior points and first-order one-sided differences at boundaries. Determine the flame front location $x_{T'}$ where $|\\partial T/\\partial x|$ is maximal, the hydroxyl-gradient front location $x_{Y'}$ where $|\\partial Y_{\\mathrm{OH}}/\\partial x|$ is maximal, the hydroxyl peak location $x_{Y}$ where $Y_{\\mathrm{OH}}$ is maximal, and the heat release peak location $x_{q}$ where $|\\dot{q}|$ is maximal.\n- Compute the thermal thickness $\\delta_{\\mathrm{th}}$ by interpolating $x_{0.1}$ and $x_{0.9}$ from the discrete $T(x)$ profile as specified.\n- Evaluate localization sensitivity as normalized distances in meters divided by $\\delta_{\\mathrm{th}}$: $s_{Tq} = |x_{T'} - x_q|/\\delta_{\\mathrm{th}}$, $s_{Yq} = |x_{Y} - x_q|/\\delta_{\\mathrm{th}}$, and $s_{TY} = |x_{T'} - x_{Y'}|/\\delta_{\\mathrm{th}}$.\n- Propose a robust combined refinement indicator $C(x)$ built from normalized markers. Define the normalized indicators $S_T(x) = |\\partial T/\\partial x|/\\max_{x}|\\partial T/\\partial x|$, $S_Y(x) = |\\partial Y_{\\mathrm{OH}}/\\partial x|/\\max_{x}|\\partial Y_{\\mathrm{OH}}/\\partial x|$, and $S_q(x) = |\\dot{q}(x)|/\\max_{x}|\\dot{q}(x)|$. Define the combined indicator as the harmonic mean $C(x) = \\frac{3}{\\frac{1}{S_T(x)} + \\frac{1}{S_Y(x)} + \\frac{1}{S_q(x)}}$, with the convention that where any denominator is zero, treat the corresponding term as $+\\infty$ so that $C(x)$ becomes zero. Use a threshold $\\tau = 0.5$ and mark a point for refinement if $C(x) \\ge \\tau$. Let $N_{\\text{ref}}$ be the count of marked points.\n- Compute the combined indicator peak location $x_C$ where $C(x)$ is maximal, and also compute $s_{Cq} = |x_C - x_q|/\\delta_{\\mathrm{th}}$ in meters normalized by $\\delta_{\\mathrm{th}}$.\n\nRequired outputs and units:\n- For each dataset, output a list containing the following in order: $s_{Tq}$, $s_{Yq}$, $s_{TY}$, $s_{Cq}$, $x_{T'}$, $x_q$, and $N_{\\text{ref}}$. All $x$ values must be in meters, and all $s$ values are dimensionless. $N_{\\text{ref}}$ is an integer.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the list contains the three per-dataset lists in the same order as datasets $1$, $2$, and $3$, for example, $[[\\dots],[\\dots],[\\dots]]$.\n\nTest suite coverage:\n- Dataset $1$ tests a well-resolved smooth flame.\n- Dataset $2$ probes a near-grid-resolution front to test boundary sensitivity.\n- Dataset $3$ includes noise to test robustness of the combined indicator against spurious extrema.",
            "solution": "The problem requires the analysis of synthetic one-dimensional premixed flame data to identify the locations of key features and to design a robust refinement indicator for Adaptive Mesh Refinement (AMR). The solution involves several computational steps, which are applied to three distinct datasets representing a well-resolved flame, an under-resolved flame, and a flame with noisy signals.\n\nFirst, we establish the computational domain and generate the physical field data. For each dataset, a one-dimensional spatial grid $x$ of $N$ points is created over a domain of length $L$, resulting in a uniform grid spacing of $\\Delta x = L/(N-1)$. The temperature profile $T(x)$, hydroxyl mass fraction $Y_{\\mathrm{OH}}(x)$, and magnitude of the heat release rate $|\\dot{q}(x)|$ are calculated at each grid point using the provided analytical functions:\n$$T(x) = T_u + (T_b - T_u)\\,\\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_0}{\\delta_T}\\right)\\right)$$\n$$Y_{\\mathrm{OH}}(x) = Y_{\\text{peak}}\\exp\\left(-\\frac{(x - x_0 - s_{\\mathrm{OH}})^2}{2\\sigma_{\\mathrm{OH}}^2}\\right)$$\n$$|\\dot{q}|(x) = q_{\\text{peak}}\\exp\\left(-\\frac{(x - x_0 - s_q)^2}{2\\sigma_q^2}\\right)$$\nFor Dataset $3$, zero-mean Gaussian noise is added to each field. Specifically, let $T_{clean}(x)$, $Y_{\\mathrm{OH,clean}}(x)$, and $|\\dot{q}|_{clean}(x)$ be the profiles generated from the formulas. The noisy profiles are then $T(x) = T_{clean}(x) + \\eta_T(x)$, $Y_{\\mathrm{OH}}(x) = Y_{\\mathrm{OH,clean}}(x) + \\eta_Y(x)$, and $|\\dot{q}|(x) = |\\dot{q}|_{clean}(x) + \\eta_q(x)$, where $\\eta_T$, $\\eta_Y$, and $\\eta_q$ are random variables drawn from normal distributions with standard deviations of $0.005\\,(T_b - T_u)$, $0.05\\,Y_{\\text{peak}}$, and $0.05\\,q_{\\text{peak}}$, respectively.\n\nSecond, spatial derivatives are computed numerically to identify gradient-based features. The derivatives $\\partial T/\\partial x$ and $\\partial Y_{\\mathrm{OH}}/\\partial x$ are calculated using a second-order centered difference scheme for interior grid points $i \\in [1, N-2]$:\n$$ \\left(\\frac{\\partial f}{\\partial x}\\right)_i \\approx \\frac{f_{i+1} - f_{i-1}}{2\\Delta x} $$\nand a first-order one-sided difference scheme for the boundaries at $i=0$ and $i=N-1$:\n$$ \\left(\\frac{\\partial f}{\\partial x}\\right)_0 \\approx \\frac{f_1 - f_0}{\\Delta x}, \\quad \\left(\\frac{\\partial f}{\\partial x}\\right)_{N-1} \\approx \\frac{f_{N-1} - f_{N-2}}{\\Delta x} $$\n\nThird, the locations of the principal flame features are determined from the discrete data. The flame front position $x_{T'}$ is the grid point $x$ where the magnitude of the temperature gradient, $|\\partial T/\\partial x|$, is maximal. Similarly, the hydroxyl-gradient front location $x_{Y'}$ is where $|\\partial Y_{\\mathrm{OH}}/\\partial x|$ is maximal. The hydroxyl peak location $x_{Y}$ and the heat release peak location $x_{q}$ are found where $Y_{\\mathrm{OH}}(x)$ and $|\\dot{q}(x)|$ are maximal, respectively. These are all found by finding the index of the maximum value in the corresponding array.\n\nFourth, the thermal thickness $\\delta_{\\mathrm{th}}$ is computed. This metric characterizes the width of the main temperature transition. It is defined as $\\delta_{\\mathrm{th}} = |x_{0.9} - x_{0.1}|$, where $x_{0.1}$ and $x_{0.9}$ are the spatial coordinates where the temperature equals $T_{0.1} = T_u + 0.1(T_b - T_u)$ and $T_{0.9} = T_u + 0.9(T_b - T_u)$, respectively. These positions are determined by linear interpolation on the discrete $T(x)$ profile. For the noisy temperature profile in Dataset $3$, which may not be monotonic, the temperature and corresponding coordinate arrays are sorted together prior to interpolation to ensure its correctness.\n\nFifth, localization sensitivities are evaluated. These dimensionless quantities measure the spatial separation between different feature-detection markers, normalized by the flame's thermal thickness $\\delta_{\\mathrm{th}}$. The metrics are calculated as:\n$$s_{Tq} = \\frac{|x_{T'} - x_q|}{\\delta_{\\mathrm{th}}}, \\quad s_{Yq} = \\frac{|x_{Y} - x_q|}{\\delta_{\\mathrm{th}}}, \\quad s_{TY} = \\frac{|x_{T'} - x_{Y'}|}{\\delta_{\\mathrm{th}}}$$\n\nSixth, a robust combined refinement indicator $C(x)$ is designed and evaluated. This step aims to create a single, reliable marker for AMR that is less sensitive to noise or under-resolution than any individual marker. First, the individual indicators are normalized to the range $[0, 1]$:\n$$S_T(x) = \\frac{|\\partial T/\\partial x|}{\\max_{x}|\\partial T/\\partial x|}, \\quad S_Y(x) = \\frac{|\\partial Y_{\\mathrm{OH}}/\\partial x|}{\\max_{x}|\\partial Y_{\\mathrm{OH}}/\\partial x|}, \\quad S_q(x) = \\frac{|\\dot{q}(x)|}{\\max_{x}|\\dot{q}(x)|}$$\nThe combined indicator $C(x)$ is defined as the harmonic mean of these normalized indicators:\n$$C(x) = \\frac{3}{\\frac{1}{S_T(x)} + \\frac{1}{S_Y(x)} + \\frac{1}{S_q(x)}}$$\nBy convention, if any of the individual indicators $S(x)$ is zero, the term $1/S(x)$ is treated as infinite, which results in $C(x) = 0$. This property ensures that the combined indicator is large only in regions where all three underlying markers are significant, lending it robustness. Grid points are marked for refinement if $C(x) \\ge \\tau$, where the threshold is given as $\\tau = 0.5$. The total count of such points is denoted $N_{\\text{ref}}$. The location of the peak of this combined indicator, $x_C$, is also determined, and its separation from the heat release peak is quantified by $s_{Cq} = |x_C - x_q|/\\delta_{\\mathrm{th}}$.\n\nFinally, this entire procedure is executed for each of the three datasets, and the computed values ($s_{Tq}$, $s_{Yq}$, $s_{TY}$, $s_{Cq}$, $x_{T'}$, $x_q$, and $N_{\\text{ref}}$) are collected for the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that defines datasets, processes them,\n    and prints the results in the required format.\n    \"\"\"\n\n    def compute_derivative(f, dx):\n        \"\"\"\n        Computes the spatial derivative of a 1D array f with spacing dx.\n        Uses second-order centered differences for the interior and\n        first-order one-sided differences for the boundaries.\n        \"\"\"\n        N = len(f)\n        if N < 2:\n            return np.zeros_like(f)\n        \n        df_dx = np.zeros(N, dtype=float)\n        \n        # Interior points (second-order centered)\n        if N > 2:\n            df_dx[1:-1] = (f[2:] - f[:-2]) / (2 * dx)\n        \n        # Boundary points (first-order one-sided)\n        df_dx[0] = (f[1] - f[0]) / dx\n        df_dx[-1] = (f[-1] - f[-2]) / dx\n        \n        return df_dx\n\n    def process_dataset(params):\n        \"\"\"\n        Processes a single dataset to compute all required metrics.\n        \"\"\"\n        # 1. Unpack parameters and generate grid\n        L, N = params['L'], params['N']\n        Tu, Tb = params['T_u'], params['T_b']\n        x0, dT = params['x_0'], params['delta_T']\n        Yp, sOH, sigOH = params['Y_peak'], params['s_OH'], params['sigma_OH']\n        qp, sq, sigq = params['q_peak'], params['s_q'], params['sigma_q']\n\n        x = np.linspace(0, L, N)\n        dx = x[1] - x[0]\n\n        # 2. Generate clean profiles\n        T = Tu + (Tb - Tu) * 0.5 * (1 + np.tanh((x - x0) / dT))\n        Y_OH = Yp * np.exp(-((x - x0 - sOH)**2) / (2 * sigOH**2))\n        q_dot = qp * np.exp(-((x - x0 - sq)**2) / (2 * sigq**2))\n\n        # 3. Add noise if specified (Dataset 3)\n        if params.get('noise', False):\n            rng = np.random.default_rng(params['seed'])\n            \n            noise_T = rng.normal(0, 0.005 * (Tb - Tu), N)\n            T += noise_T\n            \n            noise_Y = rng.normal(0, 0.05 * Yp, N)\n            Y_OH += noise_Y\n\n            noise_q = rng.normal(0, 0.05 * qp, N)\n            q_dot += noise_q\n\n        # 4. Compute derivatives\n        dT_dx = compute_derivative(T, dx)\n        dYOH_dx = compute_derivative(Y_OH, dx)\n        abs_dT_dx = np.abs(dT_dx)\n        abs_dYOH_dx = np.abs(dYOH_dx)\n\n        # 5. Determine feature locations\n        x_T_prime = x[np.argmax(abs_dT_dx)]\n        x_Y_prime = x[np.argmax(abs_dYOH_dx)]\n        x_Y = x[np.argmax(Y_OH)]\n        x_q = x[np.argmax(q_dot)]\n\n        # 6. Compute thermal thickness\n        T_01 = Tu + 0.1 * (Tb - Tu)\n        T_09 = Tu + 0.9 * (Tb - Tu)\n        \n        # For noisy data, ensure T is monotonic for interpolation\n        if params.get('noise', False):\n            sort_indices = np.argsort(T)\n            T_sorted = T[sort_indices]\n            x_sorted = x[sort_indices]\n            x_01 = np.interp(T_01, T_sorted, x_sorted)\n            x_09 = np.interp(T_09, T_sorted, x_sorted)\n        else: # For clean data, T is monotonic\n            x_01 = np.interp(T_01, T, x)\n            x_09 = np.interp(T_09, T, x)\n\n        delta_th = np.abs(x_09 - x_01)\n        if delta_th == 0: delta_th = 1e-12 # Avoid division by zero\n\n        # 7. Evaluate localization sensitivities\n        s_Tq = np.abs(x_T_prime - x_q) / delta_th\n        s_Yq = np.abs(x_Y - x_q) / delta_th\n        s_TY = np.abs(x_T_prime - x_Y_prime) / delta_th\n\n        # 8. Compute combined refinement indicator\n        max_abs_dT_dx = np.max(abs_dT_dx)\n        if max_abs_dT_dx == 0: max_abs_dT_dx = 1e-12\n        S_T = abs_dT_dx / max_abs_dT_dx\n\n        max_abs_dYOH_dx = np.max(abs_dYOH_dx)\n        if max_abs_dYOH_dx == 0: max_abs_dYOH_dx = 1e-12\n        S_Y = abs_dYOH_dx / max_abs_dYOH_dx\n        \n        max_q_dot = np.max(q_dot)\n        if max_q_dot <= 0: max_q_dot = 1e-12 # Handle potential negative noisy values\n        S_q = q_dot / max_q_dot\n        S_q[S_q < 0] = 0 # Magnitudes cannot be negative\n\n        C = np.zeros_like(x)\n        inv_S_T = np.divide(1.0, S_T, out=np.full_like(S_T, np.inf), where=S_T!=0)\n        inv_S_Y = np.divide(1.0, S_Y, out=np.full_like(S_Y, np.inf), where=S_Y!=0)\n        inv_S_q = np.divide(1.0, S_q, out=np.full_like(S_q, np.inf), where=S_q!=0)\n        \n        denominator_sum = inv_S_T + inv_S_Y + inv_S_q\n        mask = np.isfinite(denominator_sum)\n        C[mask] = 3.0 / denominator_sum[mask]\n\n        tau = 0.5\n        N_ref = np.sum(C >= tau)\n\n        # 9. Compute C peak location and sensitivity\n        x_C = x[np.argmax(C)]\n        s_Cq = np.abs(x_C - x_q) / delta_th\n\n        return [s_Tq, s_Yq, s_TY, s_Cq, x_T_prime, x_q, N_ref]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 0.02, \"N\": 400, \"T_u\": 300, \"T_b\": 2100, \"x_0\": 0.010,\n            \"delta_T\": 0.0005, \"Y_peak\": 0.01, \"s_OH\": 0.0001, \"sigma_OH\": 0.0003,\n            \"q_peak\": 5e9, \"s_q\": 0.00015, \"sigma_q\": 0.00025\n        },\n        {\n            \"L\": 0.01, \"N\": 60, \"T_u\": 300, \"T_b\": 2100, \"x_0\": 0.005,\n            \"delta_T\": 0.0002, \"Y_peak\": 0.01, \"s_OH\": 0.00006, \"sigma_OH\": 0.00015,\n            \"q_peak\": 3e9, \"s_q\": 0.00008, \"sigma_q\": 0.00012\n        },\n        {\n            \"L\": 0.02, \"N\": 400, \"T_u\": 300, \"T_b\": 2100, \"x_0\": 0.010,\n            \"delta_T\": 0.0005, \"Y_peak\": 0.01, \"s_OH\": 0.0001, \"sigma_OH\": 0.0003,\n            \"q_peak\": 5e9, \"s_q\": 0.00015, \"sigma_q\": 0.00025,\n            \"noise\": True, \"seed\": 12345\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_dataset(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_sublists = []\n    for res_list in results:\n        # The last element N_ref must be an integer\n        str_list = [f\"{val}\" for val in res_list[:-1]] + [f\"{int(res_list[-1])}\"]\n        formatted_sublists.append(f\"[{','.join(str_list)}]\")\n    \n    print(f\"[{','.join(formatted_sublists)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from one to two dimensions reveals a critical challenge in computational efficiency: flame fronts are thin sheets with vastly different length scales along their normal and tangential directions. Isotropic refinement, which uses the same grid spacing in all directions, is therefore highly wasteful. This practice introduces the powerful concept of anisotropic mesh adaptation, where the grid is tailored to the flame's geometry . You will use the gradient and Hessian of the temperature field to compute the flame's local thickness and curvature, and from these, design a metric that specifies different resolution requirements normal and tangential to the front, enabling far more efficient simulations.",
            "id": "4057404",
            "problem": "You are given a two-dimensional temperature field $T(\\mathbf{x})$ defined on a rectangular domain with Cartesian coordinates $\\mathbf{x} = (x,y)$. The field contains a premixed flame front modeled as an isotherm. Your tasks are: compute the Hessian $H(T)$ of the temperature field, estimate the curvature of the flame front from $H(T)$, and design an anisotropic adaptation metric that guarantees $N$ points along the local normal direction and $M$ points along the local tangential direction of the flame front. The adaptation should be specified as direction-dependent spacings $h_n$ and $h_t$ at points on the flame front, and these spacings must be reported in meters.\n\nFundamental base and definitions to use:\n- The temperature field $T(x,y)$ is a smooth scalar function. The gradient is $\\nabla T = (T_x, T_y)$, where $T_x = \\partial T / \\partial x$ and $T_y = \\partial T / \\partial y$. The Hessian $H(T)$ is the $2 \\times 2$ matrix of second derivatives,\n$$\nH(T) = \\begin{bmatrix}\nT_{xx} & T_{xy} \\\\\nT_{yx} & T_{yy}\n\\end{bmatrix},\n$$\nwith $T_{xx} = \\partial^2 T / \\partial x^2$, $T_{yy} = \\partial^2 T / \\partial y^2$, and $T_{xy} = T_{yx} = \\partial^2 T / (\\partial x \\partial y)$.\n- The flame front is defined as the isotherm $T(x,y) = T_f$, where $T_f$ is given. At points on the flame front, define the unit normal $\\mathbf{n} = \\nabla T / \\|\\nabla T\\|$ and a unit tangential vector $\\mathbf{t}$ orthogonal to $\\mathbf{n}$ by $\\mathbf{t} = (-n_y, n_x)$.\n- The curvature $\\kappa$ of a level set $T(x,y) = \\text{constant}$ can be computed from first and second derivatives by\n$$\n\\kappa = \\frac{T_x^2 T_{yy} - 2 T_x T_y T_{xy} + T_y^2 T_{xx}}{\\|\\nabla T\\|^3}.\n$$\n- The local thermal thickness along the normal direction is approximated by\n$$\nL_n = \\frac{\\Delta T}{\\|\\nabla T\\|},\n$$\nwhere $\\Delta T = T_b - T_u$ is the temperature rise from unburnt ($T_u$) to burnt ($T_b$) mixture across the reaction zone.\n- The local tangential length scale is taken to be the local radius of curvature $R = 1/|\\kappa|$, clipped by a maximum tangential scale $L_{\\max}$ to avoid unbounded values when $|\\kappa|$ is near zero. Specifically,\n$$\nL_t = \\min\\left(\\frac{1}{\\max(|\\kappa|,\\kappa_{\\min})}, L_{\\max}\\right),\n$$\nwhere $\\kappa_{\\min} > 0$ is a small threshold.\n- To guarantee $N$ points resolved along the normal and $M$ points along the tangential direction, choose spacings\n$$\nh_n = \\frac{L_n}{N}, \\qquad h_t = \\frac{L_t}{M}.\n$$\n- The anisotropic metric tensor $G$ at the flame front can be specified to align with $\\mathbf{n}$ and $\\mathbf{t}$, with eigenvalues $1/h_n^2$ and $1/h_t^2$ along $\\mathbf{n}$ and $\\mathbf{t}$, respectively.\n\nNumerical construction of $T(x,y)$ for each test case:\n- The domain is a rectangle of dimensions $L_x \\times L_y$ in meters, discretized on a uniform grid of $N_x \\times N_y$ points.\n- The temperature field is constructed using a smooth transition across the flame front based on a hyperbolic tangent profile,\n$$\nT(x,y) = T_u + \\Delta T \\cdot \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_0(y)}{\\delta}\\right)\\right),\n$$\nwhere $x_0(y)$ is the flame front location modulated in the $y$-direction, and $\\delta$ is the thermal thickness parameter controlling the steepness.\n\nEstimation and output requirements:\n- Compute $T_x, T_y, T_{xx}, T_{yy}, T_{xy}$ using second-order central differences on the uniform grid.\n- Define the flame front isotherm $T_f = (T_u + T_b)/2$. Identify grid points in a narrow band around the front using $|T - T_f| \\le \\epsilon$ with $\\epsilon = 0.01 \\Delta T$.\n- At these band points, compute $\\|\\nabla T\\|$, $H(T)$, $\\kappa$, $L_n$, $L_t$, $h_n$, and $h_t$ using the formulas above.\n- Report the average $h_n$ and average $h_t$ across the band points for each test case. These averages must be expressed in meters as decimal numbers. Do not include unit symbols in the output; only numeric values are allowed in the final printed list.\n\nTest suite:\nProvide results for the following four parameter sets. All quantities are in meters or Kelvins as applicable.\n1. Case $1$: A planar front.\n   - $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$.\n   - $T_u = 300$, $T_b = 2000$, $\\delta = 0.0005$.\n   - $x_0(y) = L_x/2$, i.e., no modulation ($a = 0$, $\\lambda$ unused).\n   - $N = 10$, $M = 20$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$.\n\n2. Case $2$: A weakly curved front.\n   - $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$.\n   - $T_u = 300$, $T_b = 2000$, $\\delta = 0.0003$.\n   - $x_0(y) = L_x/2 + a \\sin(2\\pi y/\\lambda)$ with $a = 0.001$ and $\\lambda = L_y$.\n   - $N = 12$, $M = 24$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$.\n\n3. Case $3$: A more strongly curved front.\n   - $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$.\n   - $T_u = 300$, $T_b = 2000$, $\\delta = 0.0002$.\n   - $x_0(y) = L_x/2 + a \\sin(2\\pi y/\\lambda)$ with $a = 0.003$ and $\\lambda = L_y$.\n   - $N = 16$, $M = 32$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$.\n\n4. Case $4$: A thicker reaction zone, planar front (edge case for small gradients).\n   - $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$.\n   - $T_u = 300$, $T_b = 2000$, $\\delta = 0.002$.\n   - $x_0(y) = L_x/2$.\n   - $N = 6$, $M = 12$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$.\n\nAnswer specification:\n- For each test case, your program must compute and return the list $[h_n^{\\text{avg}}, h_t^{\\text{avg}}]$ in meters, where $h_n^{\\text{avg}}$ and $h_t^{\\text{avg}}$ are the averages of $h_n$ and $h_t$ over the front band points.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one sublist per test case in order, for example, $[[h_{n,1},h_{t,1}],[h_{n,2},h_{t,2}],\\ldots]$.",
            "solution": "The problem as stated is valid. It is scientifically grounded in the principles of computational combustion and fluid dynamics, specifically concerning adaptive mesh refinement for resolving flame fronts. The problem is well-posed, with all necessary parameters and definitions provided for a unique numerical solution. The language is objective and the setup is consistent. We may therefore proceed with the solution.\n\nThe objective is to design an anisotropic mesh adaptation metric for resolving a premixed flame front in a two-dimensional domain. This is accomplished by calculating the desired mesh spacings, denoted as $h_n$ and $h_t$, in the directions normal and tangential to the flame front, respectively. These spacings are determined based on local physical length scales of the flame. The procedure involves the following principal steps:\n\n1.  **Temperature Field Construction**: A continuous and differentiable temperature field $T(x,y)$ is first constructed on a uniform Cartesian grid. This field represents a premixed flame, with a smooth transition from unburnt temperature $T_u$ to burnt temperature $T_b$.\n2.  **Numerical Differentiation**: The first and second partial derivatives of the temperature field ($T_x, T_y, T_{xx}, T_{yy}, T_{xy}$) are computed numerically. These derivatives are essential for characterizing the local geometry of the flame front.\n3.  **Flame Front Localization**: The flame front is identified as an isotherm $T(x,y) = T_f$. In practice, we operate on a narrow band of grid points around this isotherm to ensure robust numerical evaluation.\n4.  **Calculation of Geometric and Physical Properties**: At each point within the flame front band, we compute key quantities:\n    *   The magnitude of the temperature gradient, $\\|\\nabla T\\|$, which is inversely proportional to the flame's local thickness.\n    *   The curvature, $\\kappa$, of the temperature iso-contours, which quantifies the local bending of the flame front.\n5.  **Determination of Characteristic Length Scales**: From the computed properties, we define two characteristic length scales:\n    *   The normal length scale, $L_n$, represents the thermal thickness of the flame.\n    *   The tangential length scale, $L_t$, is based on the local radius of curvature.\n6.  **Computation of Mesh Spacings**: Finally, the desired mesh spacings $h_n$ and $h_t$ are calculated by requiring a specific number of grid points, $N$ and $M$, to resolve the normal and tangential length scales, respectively.\n\nWe will now detail the implementation of each step.\n\n**1. Grid and Temperature Field Generation**\n\nThe computational domain is a rectangle of size $L_x \\times L_y$, discretized by a uniform grid of $N_x \\times N_y$ points. The grid spacings are $\\Delta x = L_x / (N_x-1)$ and $\\Delta y = L_y / (N_y-1)$. The temperature field $T(x,y)$ is given by the analytical expression:\n$$\nT(x,y) = T_u + \\Delta T \\cdot \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_0(y)}{\\delta}\\right)\\right)\n$$\nwhere $\\Delta T = T_b - T_u$ is the total temperature rise, $\\delta$ is a parameter controlling the flame thickness, and $x_0(y)$ defines the position of the flame front center. For a planar front, $x_0(y)$ is a constant. For a curved front, it is a sinusoidal function $x_0(y) = L_x/2 + a \\sin(2\\pi y/\\lambda)$.\n\n**2. Numerical Differentiation**\n\nTo evaluate the geometric properties of the flame, we need the partial derivatives of $T(x,y)$. We employ second-order central difference schemes, which are suitable for a uniform grid. For a function $f(x,y)$ discretized on the grid as $f_{i,j} = f(i\\Delta x, j\\Delta y)$, the derivatives are approximated as:\n$$\n\\frac{\\partial f}{\\partial x}\\bigg|_{i,j} \\approx \\frac{f_{i+1,j} - f_{i-1,j}}{2 \\Delta x}\n$$\n$$\n\\frac{\\partial^2 f}{\\partial x^2}\\bigg|_{i,j} \\approx \\frac{f_{i+1,j} - 2f_{i,j} + f_{i-1,j}}{(\\Delta x)^2}\n$$\n$$\n\\frac{\\partial^2 f}{\\partial x \\partial y}\\bigg|_{i,j} \\approx \\frac{f_{i+1,j+1} - f_{i+1,j-1} - f_{i-1,j+1} + f_{i-1,j-1}}{4 \\Delta x \\Delta y}\n$$\nAnalogous formulas apply for $T_y$ and $T_{yy}$. These computations are performed across the entire grid.\n\n**3. Flame Front Localization**\n\nThe flame front is defined by the isotherm $T_f = (T_u + T_b) / 2$. We select all grid points $(x_i, y_j)$ where the temperature $T(x_i, y_j)$ is within a small tolerance $\\epsilon$ of $T_f$. The condition is:\n$$\n|T(x,y) - T_f| \\le \\epsilon\n$$\nwhere $\\epsilon$ is set to $0.01 \\Delta T$. This identifies a thin band of points that effectively sample the flame structure.\n\n**4. Calculation of Physical Quantities**\n\nAt each grid point identified in the previous step, we proceed to compute the following quantities.\n\nThe magnitude of the temperature gradient is fundamental, given by:\n$$\n\\|\\nabla T\\| = \\sqrt{T_x^2 + T_y^2}\n$$\nThe curvature $\\kappa$ of the level sets of $T(x,y)$ is calculated using the established formula involving first and second derivatives:\n$$\n\\kappa = \\frac{T_x^2 T_{yy} - 2 T_x T_y T_{xy} + T_y^2 T_{xx}}{\\|\\nabla T\\|^3}\n$$\n\n**5. Determination of Characteristic Length Scales**\n\nThe local normal length scale, $L_n$, is the thermal thickness, which is inversely proportional to the maximum temperature gradient. It is defined as:\n$$\nL_n = \\frac{\\Delta T}{\\|\\nabla T\\|}\n$$\nThe local tangential length scale, $L_t$, is related to the flame's geometry. It is taken as the radius of curvature, $R = 1/|\\kappa|$. To handle regions of low curvature (where $R \\to \\infty$) and to maintain a reasonable aspect ratio, $L_t$ is clipped by a minimum curvature $\\kappa_{\\min}$ and a maximum length scale $L_{\\max}$:\n$$\nL_t = \\min\\left(\\frac{1}{\\max(|\\kappa|,\\kappa_{\\min})}, L_{\\max}\\right)\n$$\nThis formulation ensures that the tangential length scale remains bounded and physically meaningful.\n\n**6. Computation of Anisotropic Mesh Spacings**\n\nThe final goal is to determine the mesh spacings $h_n$ and $h_t$ that ensure the flame is adequately resolved. The requirement is to place $N$ grid points across the normal length scale $L_n$ and $M$ points across the tangential length scale $L_t$. This directly leads to the definitions:\n$$\nh_n = \\frac{L_n}{N}, \\qquad h_t = \\frac{L_t}{M}\n$$\nThese values are computed for every point in the flame front band.\n\n**7. Averaging and Final Output**\n\nFor each test case, the problem requires reporting a single representative value for $h_n$ and $h_t$. We achieve this by computing the arithmetic mean of all $h_n$ and $h_t$ values calculated over the points in the flame front band. This provides the average required normal spacing, $h_n^{\\text{avg}}$, and average tangential spacing, $h_t^{\\text{avg}}$, for resolving the flame front according to the specified criteria. The process is then repeated for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes anisotropic mesh spacings for resolving a premixed flame front\n    for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: Planar front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.0005, 'a': 0.0, 'lambda_y': 0.02, 'N': 10, 'M': 20,\n         'Lmax': 0.01, 'kappa_min': 1e-6},\n        # Case 2: Weakly curved front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.0003, 'a': 0.001, 'lambda_y': 0.02, 'N': 12, 'M': 24,\n         'Lmax': 0.01, 'kappa_min': 1e-6},\n        # Case 3: More strongly curved front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.0002, 'a': 0.003, 'lambda_y': 0.02, 'N': 16, 'M': 32,\n         'Lmax': 0.01, 'kappa_min': 1e-6},\n        # Case 4: Thicker reaction zone, planar front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.002, 'a': 0.0, 'lambda_y': 0.02, 'N': 6, 'M': 12,\n         'Lmax': 0.01, 'kappa_min': 1e-6}\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Unpack parameters from the dictionary\n        Lx, Ly, Nx, Ny = case['Lx'], case['Ly'], case['Nx'], case['Ny']\n        Tu, Tb, delta = case['Tu'], case['Tb'], case['delta']\n        a, lambda_y = case['a'], case['lambda_y']\n        N, M, Lmax, kappa_min = case['N'], case['M'], case['Lmax'], case['kappa_min']\n\n        # 1. Create grid and compute grid spacings\n        x_vec = np.linspace(0, Lx, Nx)\n        y_vec = np.linspace(0, Ly, Ny)\n        dx = x_vec[1] - x_vec[0]\n        dy = y_vec[1] - y_vec[0]\n        # meshgrid with 'xy' indexing creates arrays of shape (Ny, Nx)\n        x, y = np.meshgrid(x_vec, y_vec, indexing='xy')\n\n        # 2. Generate the temperature field\n        delta_T = Tb - Tu\n        if a == 0.0:\n            x0_y = Lx / 2.0\n        else:\n            x0_y = Lx / 2.0 + a * np.sin(2.0 * np.pi * y / lambda_y)\n        \n        arg_tanh = (x - x0_y) / delta\n        T = Tu + delta_T * 0.5 * (1.0 + np.tanh(arg_tanh))\n\n        # 3. Compute first and second derivatives using second-order central differences\n        # np.gradient assumes first axis is y and second is x for (Ny, Nx) arrays\n        Ty, Tx = np.gradient(T, dy, dx)\n        \n        # Second derivatives are computed from gradients of first derivatives\n        _, Txx = np.gradient(Tx, dy, dx)  # d(Tx)/dx\n        Tyy, Txy = np.gradient(Ty, dy, dx)  # d(Ty)/dy and d(Ty)/dx\n\n        # 4. Identify flame front band\n        Tf = (Tu + Tb) / 2.0\n        epsilon = 0.01 * delta_T\n        band_indices = np.where(np.abs(T - Tf) <= epsilon)\n\n        if band_indices[0].size == 0:\n            # Handle the case where no points are found in the band\n            all_results.append([float('nan'), float('nan')])\n            continue\n\n        # Extract derivatives at the band points\n        Tx_band = Tx[band_indices]\n        Ty_band = Ty[band_indices]\n        Txx_band = Txx[band_indices]\n        Tyy_band = Tyy[band_indices]\n        Txy_band = Txy[band_indices]\n\n        # 5. Compute physical quantities at band points\n        # Gradient magnitude\n        grad_T_norm_sq = Tx_band**2 + Ty_band**2\n        grad_T_norm = np.sqrt(grad_T_norm_sq)\n\n        # Curvature\n        kappa_numerator = (Tx_band**2 * Tyy_band -\n                           2 * Tx_band * Ty_band * Txy_band +\n                           Ty_band**2 * Txx_band)\n        kappa_denominator = grad_T_norm**3\n        \n        # Use np.divide to safely handle potential division by zero\n        kappa = np.divide(kappa_numerator, kappa_denominator, \n                          out=np.zeros_like(kappa_numerator, dtype=float), \n                          where=kappa_denominator != 0)\n\n        # 6. Determine characteristic length scales\n        # Normal length scale (thermal thickness)\n        Ln = delta_T / grad_T_norm\n        \n        # Tangential length scale (based on radius of curvature)\n        abs_kappa = np.abs(kappa)\n        inv_kappa_clipped = 1.0 / np.maximum(abs_kappa, kappa_min)\n        Lt = np.minimum(inv_kappa_clipped, Lmax)\n        \n        # 7. Compute required spacings\n        hn = Ln / N\n        ht = Lt / M\n\n        # 8. Average results\n        hn_avg = np.mean(hn)\n        ht_avg = np.mean(ht)\n\n        all_results.append([hn_avg, ht_avg])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}