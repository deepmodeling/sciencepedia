{
    "hands_on_practices": [
        {
            "introduction": "在任何自适应网格加密（AMR）策略中，首要任务是准确定位需要加密的关键区域。本实践旨在通过编程方式，从一维预混火焰的原始数据中识别火焰锋面位置并量化反应区厚度。通过使用基于温度的反应进程变量和热释放率，您将掌握从模拟结果中提取关键物理尺度的基本技能。",
            "id": "4057465",
            "problem": "给定代表预混层流火焰的光滑一维场：温度 $T(x)$（单位：开尔文）和单位体积的单步质量反应速率 $\\dot{\\omega}(x)$（单位：$\\mathrm{kg\\,m^{-3}\\,s^{-1}}$）。这两个场均定义在一个具有均匀网格的有界空间区间上。请使用计算燃烧学中的公认定义，实现一个程序，为每个提供的测试用例计算与火焰锋面和反应区相关的两个细化指标：(i) 由基于温度的反应进度变量在 $c=0.5$ 时定义的火焰锋面位置 $x_f$，以及 (ii) 定义为体积放热率大小 $\\lvert \\dot{q}(x) \\rvert$ 的半峰全宽（FWHM）的反应区厚度 $\\Delta_R$。所有输出必须以米为单位，表示为十进制浮点数。\n\n使用的基本原理和定义：\n\n- 基于温度的反应进度变量归一化为 $c(x) = \\dfrac{T(x) - T_u}{T_b - T_u}$，其中 $T_u$ 和 $T_b$ 分别是未燃温度和已燃温度。为解决此问题，定义 $T_u = \\min_{x} T(x)$ 和 $T_b = \\max_{x} T(x)$ 为给定域上的全局最小值和最大值。\n\n- 火焰锋面位置 $x_f$ 是满足 $c(x_f) = 0.5$ 的唯一 $x$。在离散数据中，通过在跨越 $c=0.5$ 的两个网格点之间进行线性插值来确定 $x_f$。\n\n- 单步全局反应的体积放热率模型为 $\\dot{q}(x) = Q\\,\\dot{\\omega}(x)$，其中 $Q$ 是单位质量的反应热。使用 $Q = 5.0 \\times 10^{7}\\,\\mathrm{J\\,kg^{-1}}$。计算其大小 $\\lvert \\dot{q}(x) \\rvert$ 并识别最接近 $x_f$ 的主峰。将反应区厚度 $\\Delta_R$ 定义为该峰值周围的半峰全宽（FWHM）：即，峰值两侧 $\\lvert \\dot{q}(x) \\rvert$ 等于峰值一半的两个位置之间的距离，该距离通过在离散网格上进行线性插值计算。\n\n算法要求：\n\n- 对 $x_f$ 和定义 $\\Delta_R$ 的半峰值交叉点均进行线性插值。\n\n- 如果 $\\lvert \\dot{q}(x) \\rvert$ 存在多个局部最大值，选择与 $x_f$ 绝对距离最小的那个。\n\n- 通过处理光滑剖面来确保科学真实性；所提供的测试用例满足单调的 $T(x)$ 趋势和局部化的反应区。\n\n单位和输出格式：\n\n- 将 $x_f$ 和 $\\Delta_R$ 以米为单位表示为十进制浮点数。\n\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表，每个内部列表包含一个测试用例的 $[x_f,\\Delta_R]$。例如：$[\\,[x_{f,1},\\Delta_{R,1}],\\,[x_{f,2},\\Delta_{R,2}]\\,]$。所有浮点数格式化为小数点后六位。\n\n测试套件：\n\n对于每个测试用例，构建一个均匀网格 $x$ 并如下定义 $T(x)$ 和 $\\dot{\\omega}(x)$。所有参数均采用标准单位，其中 $x$ 的单位是米。\n\n- 测试用例 1（理想情况，单个高斯反应区）：\n  - 域：$x \\in [-5\\times 10^{-3},\\,5\\times 10^{-3}]$，含 $N=2001$ 个点。\n  - 温度：$T_u = 300$，$T_b = 2200$，$L_T = 5.0\\times 10^{-4}$，$T(x) = T_u + (T_b - T_u)\\,\\dfrac{1}{2}\\left(1 + \\tanh\\left(\\dfrac{x}{L_T}\\right)\\right)$。\n  - 反应速率：振幅 $A = 1.2$，中心 $x_0 = 0$，宽度 $\\sigma = 2.5\\times 10^{-4}$，$\\dot{\\omega}(x) = A \\exp\\!\\left(-\\dfrac{(x - x_0)^2}{2\\sigma^2}\\right)$。\n\n- 测试用例 2（两个峰值，选择最接近锋面的峰）：\n  - 域：$x \\in [-6\\times 10^{-3},\\,6\\times 10^{-3}]$，含 $N=2401$ 个点。\n  - 温度：$T_u = 300$，$T_b = 2200$，$L_T = 6.0\\times 10^{-4}$，偏移 $x_f^{(0)} = -1.0\\times 10^{-3}$，\n    $T(x) = T_u + (T_b - T_u)\\,\\dfrac{1}{2}\\left(1 + \\tanh\\left(\\dfrac{x - x_f^{(0)}}{L_T}\\right)\\right)$。\n  - 反应速率：两个高斯函数，参数为 $A_1 = 0.8$，$x_1 = -1.0\\times 10^{-3}$，$\\sigma_1 = 2.0\\times 10^{-4}$，以及 $A_2 = 0.5$，$x_2 = 1.5\\times 10^{-3}$，$\\sigma_2 = 3.5\\times 10^{-4}$，\n    $\\dot{\\omega}(x) = A_1 \\exp\\!\\left(-\\dfrac{(x - x_1)^2}{2\\sigma_1^2}\\right) + A_2 \\exp\\!\\left(-\\dfrac{(x - x_2)^2}{2\\sigma_2^2}\\right)$。\n\n- 测试用例 3（非高斯，紧凑抛物线反应区）：\n  - 域：$x \\in [-3\\times 10^{-3},\\,3\\times 10^{-3}]$，含 $N=1201$ 个点。\n  - 温度：$T_u = 300$，$T_b = 2200$，$L_T = 3.0\\times 10^{-4}$，$T(x) = T_u + (T_b - T_u)\\,\\dfrac{1}{2}\\left(1 + \\tanh\\left(\\dfrac{x}{L_T}\\right)\\right)$。\n  - 反应速率：振幅 $A = 0.6$，中心 $x_0 = 5.0\\times 10^{-4}$，半宽参数 $\\sigma = 6.0\\times 10^{-4}$，\n    $\\dot{\\omega}(x) = \\max\\!\\left\\{0,\\;A\\left(1 - \\left(\\dfrac{x - x_0}{\\sigma}\\right)^2\\right)\\right\\}$。\n\n您的程序必须为每个测试用例计算配对 $[x_f,\\Delta_R]$，并生成单行输出，其中包含这些配对的列表，单位为米，每个浮点数格式化为小数点后六位，如 $[[x_{f,1},\\Delta_{R,1}],[x_{f,2},\\Delta_{R,2}],[x_{f,3},\\Delta_{R,3}]]$。",
            "solution": "用户提供的问题陈述已经过分析，并被认为是有效的。它在科学上基于计算燃烧学的原理，定义和约束清晰，问题阐述明确，并且表述客观。所有用于获得唯一可验证解的必要数据均已提供。\n\n任务是为一个一维层流火焰剖面计算两个指标：火焰锋面位置 $x_f$ 和反应区厚度 $\\Delta_R$。每个测试用例的求解过程分为两个主要阶段。\n\n### 阶段 1：确定火焰锋面位置 ($x_f$)\n\n火焰锋面位置是基于反应进度来定义的，而反应进度由归一化的温度场量化。\n\n**1.1. 反应进度变量的定义**\n基于温度的反应进度变量 $c(x)$ 定义为：\n$$c(x) = \\frac{T(x) - T_u}{T_b - T_u}$$\n其中 $T(x)$ 是温度场。未燃温度 $T_u$ 和已燃温度 $T_b$ 分别定义为空间域上温度剖面的全局最小值和最大值：\n$$T_u = \\min_{x} T(x)$$\n$$T_b = \\max_{x} T(x)$$\n根据此定义，反应进度变量有界，即 $c(x) \\in [0, 1]$。\n\n**1.2. 火焰锋面位置 ($x_f$)**\n火焰锋面 $x_f$ 定义为反应进度变量等于 $0.5$ 的唯一空间坐标：\n$$c(x_f) = 0.5$$\n鉴于数据是在离散的均匀网格 $x_i$ 上提供的，位置 $x_f$ 通过线性插值确定。首先，我们识别出跨越 $c = 0.5$ 值的两个相邻网格点 $x_i$ 和 $x_{i+1}$。也就是说，我们找到一个索引 $i$ 使得 $c(x_i) \\le 0.5  c(x_{i+1})$ 或 $c(x_i) \\ge 0.5 > c(x_{i+1})$。对于所提供的单调递增的温度剖面，适用前一种情况。\n\n用于找到 $x_f$ 的线性插值公式是：\n$$x_f = x_i + (x_{i+1} - x_i) \\frac{0.5 - c(x_i)}{c(x_{i+1}) - c(x_i)}$$\n\n### 阶段 2：确定反应区厚度 ($\\Delta_R$)\n\n反应区厚度定义为以主峰为中心的体积放热率大小的半峰全宽（FWHM）。\n\n**2.1. 体积放热率**\n体积放热率 $\\dot{q}(x)$ 由下式给出：\n$$\\dot{q}(x) = Q \\cdot \\dot{\\omega}(x)$$\n其中 $\\dot{\\omega}(x)$ 是单位体积的质量反应速率，而 $Q$ 是单位质量的反应热，给定值为 $Q = 5.0 \\times 10^7 \\, \\mathrm{J\\,kg^{-1}}$。分析是基于此量的绝对值 $|\\dot{q}(x)|$ 进行的。由于所提供的反应速率剖面 $\\dot{\\omega}(x)$ 是非负的，因此 $|\\dot{q}(x)| = \\dot{q}(x)$。\n\n**2.2. 峰值识别与选择**\n剖面 $|\\dot{q}(x)|$ 可能有一个或多个局部最大值。我们必须在离散数据中识别所有这些峰值。如果 $|\\dot{q}(x_j)| > |\\dot{q}(x_{j-1})|$ 且 $|\\dot{q}(x_j)| > |\\dot{q}(x_{j+1})|$，则点 $x_j$ 是一个局部最大值。\n\n如果存在多个峰值，问题指定选择其位置 $x_{\\text{peak}}$ 与先前确定的火焰锋面位置 $x_f$ 最接近的一个。我们选择使距离 $|x_{\\text{peak}} - x_f|$ 最小化的峰值。\n\n**2.3. 半峰全宽（FWHM）计算**\n设所选峰值的值为 $|\\dot{q}|_{\\text{max}}$。半峰值为 $0.5 \\cdot |\\dot{q}|_{\\text{max}}$。反应区厚度 $\\Delta_R$ 是峰值左右两侧放热率等于此半峰值的两个点 $x_L$ 和 $x_R$ 之间的距离。\n$$\\Delta_R = x_R - x_L$$\n其中 $|\\dot{q}(x_L)| = |\\dot{q}(x_R)| = 0.5 \\cdot |\\dot{q}|_{\\text{max}}$。\n\n这些点 $x_L$ 和 $x_R$ 是通过在离散网格上进行线性插值找到的。\n- 为了找到 $x_L$，我们在峰值左侧（$x_j, x_{j+1}  x_{\\text{peak}}$）搜索跨越半峰值的两个相邻网格点 $x_j$ 和 $x_{j+1}$。插值公式为：\n$$x_L = x_j + (x_{j+1} - x_j) \\frac{0.5 |\\dot{q}|_{\\text{max}} - |\\dot{q}(x_j)|}{|\\dot{q}(x_{j+1})| - |\\dot{q}(x_j)|}$$\n- 为了找到 $x_R$，我们在峰值右侧（$x_k, x_{k+1} > x_{\\text{peak}}$）搜索满足相同条件的两个相邻网格点 $x_k$ 和 $x_{k+1}$。插值公式为：\n$$x_R = x_k + (x_{k+1} - x_k) \\frac{0.5 |\\dot{q}|_{\\text{max}} - |\\dot{q}(x_k)|}{|\\dot{q}(x_{k+1})| - |\\dot{q}(x_k)|}$$\n\n此系统性步骤应用于每个测试用例，以推导出所需的指标。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the calculation for all test cases and print the final result.\n    \"\"\"\n    \n    # Heat of reaction per unit mass in J/kg\n    Q = 5.0e7\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"domain\": (-5e-3, 5e-3), \"N\": 2001,\n            \"T_params\": {\"Tu\": 300.0, \"Tb\": 2200.0, \"L_T\": 5.0e-4},\n            \"T_func\": lambda x, p: p[\"Tu\"] + (p[\"Tb\"] - p[\"Tu\"]) * 0.5 * (1 + np.tanh(x / p[\"L_T\"])),\n            \"omega_params\": {\"A\": 1.2, \"x0\": 0.0, \"sigma\": 2.5e-4},\n            \"omega_func\": lambda x, p: p[\"A\"] * np.exp(-(x - p[\"x0\"])**2 / (2 * p[\"sigma\"]**2))\n        },\n        {\n            \"domain\": (-6e-3, 6e-3), \"N\": 2401,\n            \"T_params\": {\"Tu\": 300.0, \"Tb\": 2200.0, \"L_T\": 6.0e-4, \"x_f0\": -1.0e-3},\n            \"T_func\": lambda x, p: p[\"Tu\"] + (p[\"Tb\"] - p[\"Tu\"]) * 0.5 * (1 + np.tanh((x - p[\"x_f0\"]) / p[\"L_T\"])),\n            \"omega_params\": {\"A1\": 0.8, \"x1\": -1.0e-3, \"sigma1\": 2.0e-4, \"A2\": 0.5, \"x2\": 1.5e-3, \"sigma2\": 3.5e-4},\n            \"omega_func\": lambda x, p: (p[\"A1\"] * np.exp(-(x - p[\"x1\"])**2 / (2 * p[\"sigma1\"]**2)) +\n                                       p[\"A2\"] * np.exp(-(x - p[\"x2\"])**2 / (2 * p[\"sigma2\"]**2)))\n        },\n        {\n            \"domain\": (-3e-3, 3e-3), \"N\": 1201,\n            \"T_params\": {\"Tu\": 300.0, \"Tb\": 2200.0, \"L_T\": 3.0e-4},\n            \"T_func\": lambda x, p: p[\"Tu\"] + (p[\"Tb\"] - p[\"Tu\"]) * 0.5 * (1 + np.tanh(x / p[\"L_T\"])),\n            \"omega_params\": {\"A\": 0.6, \"x0\": 5.0e-4, \"sigma\": 6.0e-4},\n            \"omega_func\": lambda x, p: np.maximum(0, p[\"A\"] * (1 - ((x - p[\"x0\"]) / p[\"sigma\"])**2))\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _calculate_metrics(case, Q)\n        results.append(result)\n\n    # Format the final output string.\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _linear_interpolate(y_target, y_data, x_data):\n    \"\"\"General linear interpolation function.\"\"\"\n    # Find the index where y_target would be inserted in a sorted y_data\n    # This identifies the interval for interpolation.\n    i = np.searchsorted(y_data, y_target)\n    \n    # Handle edge cases where target is outside data range, though not expected here\n    if i == 0 or i == len(y_data):\n        # Fallback to direct search if searchsorted fails due to non-monotonicity\n        # around the target (not expected for c(x)).\n        for k in range(len(y_data) - 1):\n             if (y_data[k] = y_target and y_target = y_data[k+1]) or (y_data[k] >= y_target > y_data[k+1]):\n                 i = k + 1\n                 break\n        else: # This else belongs to the for-loop\n             return np.nan # Target not found in any interval\n\n    y1, y2 = y_data[i - 1], y_data[i]\n    x1, x2 = x_data[i - 1], x_data[i]\n    \n    # Avoid division by zero if the y-values are identical\n    if y2 - y1 == 0:\n        return x1\n    \n    return x1 + (x2 - x1) * (y_target - y1) / (y2 - y1)\n    \ndef _calculate_metrics(case, Q):\n    \"\"\"\n    Computes [x_f, Delta_R] for a single test case.\n    \"\"\"\n    # 1. Generate grid and profiles\n    x = np.linspace(case[\"domain\"][0], case[\"domain\"][1], case[\"N\"])\n    T = case[\"T_func\"](x, case[\"T_params\"])\n    omega_dot = case[\"omega_func\"](x, case[\"omega_params\"])\n\n    # 2. Calculate flame front location x_f\n    Tu = np.min(T)\n    Tb = np.max(T)\n    c = (T - Tu) / (Tb - Tu)\n    \n    # Find indices straddling c=0.5\n    # np.searchsorted is efficient for monotonic arrays\n    idx = np.searchsorted(c, 0.5)\n    \n    # Perform linear interpolation for x_f\n    c1, c2 = c[idx - 1], c[idx]\n    x1, x2 = x[idx - 1], x[idx]\n    xf = x1 + (x2 - x1) * (0.5 - c1) / (c2 - c1)\n\n    # 3. Calculate heat release rate and find dominant peak\n    q_dot_mag = np.abs(Q * omega_dot)\n    \n    # Find all peaks in the heat release rate profile\n    peak_indices, _ = find_peaks(q_dot_mag)\n    \n    if len(peak_indices) == 0: # Should not happen with given test cases\n        return [xf, np.nan]\n    elif len(peak_indices) == 1:\n        chosen_peak_idx = peak_indices[0]\n    else:\n        # Choose the peak closest to xf\n        peak_locations = x[peak_indices]\n        distances = np.abs(peak_locations - xf)\n        chosen_peak_idx = peak_indices[np.argmin(distances)]\n\n    # 4. Calculate reaction zone thickness Delta_R (FWHM)\n    q_dot_max = q_dot_mag[chosen_peak_idx]\n    half_max = 0.5 * q_dot_max\n\n    # Find left crossing point x_L\n    x_L = 0.0\n    for i in range(chosen_peak_idx, 0, -1):\n        if q_dot_mag[i-1]  half_max = q_dot_mag[i]:\n            y1, y2 = q_dot_mag[i-1], q_dot_mag[i]\n            x_L = x[i-1] + (x[i] - x[i-1]) * (half_max - y1) / (y2 - y1)\n            break\n            \n    # Find right crossing point x_R\n    x_R = 0.0\n    for i in range(chosen_peak_idx, len(q_dot_mag) - 1):\n        if q_dot_mag[i] >= half_max > q_dot_mag[i+1]:\n            y1, y2 = q_dot_mag[i], q_dot_mag[i+1]\n            x_R = x[i] + (x[i+1] - x[i]) * (half_max - y1) / (y2 - y1)\n            break\n    \n    delta_R = x_R - x_L\n\n    return [xf, delta_R]\n\nsolve()\n```"
        },
        {
            "introduction": "在真实的燃烧模拟中，火焰结构可以通过多种物理和化学标记物（如温度、关键组分浓度和热释放率）来表征，但它们的位置可能存在细微差异。本练习将引导您探索如何比较不同标记物的性能，并设计一个组合的、更稳健的加密指标。这对于开发能够抵抗数值噪声和分辨率不足影响的可靠自适应算法至关重要。",
            "id": "4057428",
            "problem": "考虑在一维预混火焰中使用多种标记来定位火焰锋面和反应区，并为自适应网格加密 (AMR) 设计一个鲁棒的加密指示器的问题。计算域沿空间坐标 $x$ 展开，单位为米。所提供的合成数据集近似一个统计稳态的一维预混火焰。物理场包括温度 $T$（单位：开尔文），羟基质量分数 $Y_{\\mathrm{OH}}$（无量纲），以及体积放热率的大小 $|\\dot{q}|$（单位：瓦特/立方米）。您必须基于第一性原理计算定位度量，并提出一个鲁棒的组合加密判据。所有距离必须以米为单位表示。\n\n使用的基本原理和定义：\n- 从反应流中的能量和组分守恒出发。在稳态一维预混火焰中，热传导与化学反应相平衡，形成一个具有大温度梯度的薄区域，该区域常被用来定义火焰锋面。令 $T(x)$ 表示温度，$Y_{\\mathrm{OH}}(x)$ 表示羟基质量分数（指示强反应活性），$|\\dot{q}(x)|$ 表示放热率大小。对于组分和能量，局部生成速率会在反应区附近引起 $Y_{\\mathrm{OH}}$ 和 $|\\dot{q}|$ 的峰值。放热率定义为 $|\\dot{q}| = \\left| -\\sum_k h_k \\dot{\\omega}_k \\right|$，其中 $h_k$ 是组分焓，$\\dot{\\omega}_k$ 是组分净生成速率；然而，对于此合成数据集，$|\\dot{q}|(x)$ 是直接给定的。\n- 将火焰锋面位置定义为温度梯度大小最大的位置，即 $|\\partial T/\\partial x|$ 达到其最大值处的 $x$。将反应区位置定义为 $|\\dot{q}(x)|$ 的最大值所在位置。羟基质量分数既可以通过其梯度 $|\\partial Y_{\\mathrm{OH}}/\\partial x|$ 作为锋面指示器，也可以通过其峰值 $Y_{\\mathrm{OH}}$ 作为反应指示器。\n- 定义热厚度 $\\delta_{\\mathrm{th}}$ 为 $T(x)$ 分别达到 $T_u + 0.1\\,(T_b - T_u)$ 和 $T_u + 0.9\\,(T_b - T_u)$ 的位置 $x_{0.1}$ 和 $x_{0.9}$ 之间的距离，其中 $T_u$ 是未燃温度，$T_b$ 是已燃温度。该厚度用于归一化定位敏感度。\n\n合成数据集（所有参数均为精确值，必须按给定值使用）：\n- 数据集 $1$（“理想情况”）：域长度 $L = 0.02$，网格点数 $N = 400$，因此均匀间距为 $\\Delta x = L/(N-1)$。未燃温度 $T_u = 300$，已燃温度 $T_b = 2100$，名义锋面中心 $x_0 = 0.010$，热过渡参数 $\\delta_T = 0.0005$。温度分布：$T(x) = T_u + (T_b - T_u)\\,\\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_0}{\\delta_T}\\right)\\right)$。羟基分布：$Y_{\\mathrm{OH}}(x) = Y_{\\text{peak}}\\exp\\left(-\\frac{(x - x_0 - s_{\\mathrm{OH}})^2}{2\\sigma_{\\mathrm{OH}}^2}\\right)$，其中 $Y_{\\text{peak}} = 0.01$, $s_{\\mathrm{OH}} = 0.0001$, $\\sigma_{\\mathrm{OH}} = 0.0003$。放热分布：$|\\dot{q}|(x) = q_{\\text{peak}}\\exp\\left(-\\frac{(x - x_0 - s_q)^2}{2\\sigma_q^2}\\right)$，其中 $q_{\\text{peak}} = 5\\times 10^9$, $s_q = 0.00015$, $\\sigma_q = 0.00025$。\n- 数据集 $2$（“薄锋面边界”）：域长度 $L = 0.01$，网格点数 $N = 60$，$T_u = 300$，$T_b = 2100$，$x_0 = 0.005$，$\\delta_T = 0.0002$。羟基：$Y_{\\text{peak}} = 0.01$，$s_{\\mathrm{OH}} = 0.00006$，$\\sigma_{\\mathrm{OH}} = 0.00015$。放热：$q_{\\text{peak}} = 3\\times 10^9$，$s_q = 0.00008$，$\\sigma_q = 0.00012$。温度 $T(x)$、羟基 $Y_{\\mathrm{OH}}(x)$ 和放热 $|\\dot{q}|(x)$ 的定义与数据集 $1$ 相同，但使用这些参数。\n- 数据集 $3$（“噪声信号边缘情况”）：与数据集 $1$ 相同，但添加零均值高斯噪声。对于 $Y_{\\mathrm{OH}}$，添加标准差为 $0.05\\,Y_{\\text{peak}}$ 的噪声 $\\eta_Y$。对于 $|\\dot{q}|$，添加标准差为 $0.05\\,q_{\\text{peak}}$ 的噪声 $\\eta_q$。对于 $T$，添加标准差为 $0.005\\,(T_b - T_u)$ 的可忽略噪声 $\\eta_T$。所有噪声应独立且可复现，使用固定的随机种子，具体使用种子 $12345$。\n\n任务：\n- 对于每个数据集，使用二阶中心差分计算内部点的空间导数，使用一阶单边差分计算边界点的空间导数。确定 $|\\partial T/\\partial x|$ 最大的火焰锋面位置 $x_{T'}$，$|\\partial Y_{\\mathrm{OH}}/\\partial x|$ 最大的羟基梯度锋面位置 $x_{Y'}$，$Y_{\\mathrm{OH}}$ 最大的羟基峰值位置 $x_{Y}$，以及 $|\\dot{q}|$ 最大的放热峰值位置 $x_{q}$。\n- 通过对离散的 $T(x)$ 分布进行插值，计算得到 $x_{0.1}$ 和 $x_{0.9}$，从而计算热厚度 $\\delta_{\\mathrm{th}}$。\n- 评估定位敏感度，其形式为以米为单位的归一化距离除以 $\\delta_{\\mathrm{th}}$：$s_{Tq} = |x_{T'} - x_q|/\\delta_{\\mathrm{th}}$，$s_{Yq} = |x_{Y} - x_q|/\\delta_{\\mathrm{th}}$，以及 $s_{TY} = |x_{T'} - x_{Y'}|/\\delta_{\\mathrm{th}}$。\n- 提出一个由归一化标记构建的鲁棒组合加密指示器 $C(x)$。定义归一化指示器 $S_T(x) = |\\partial T/\\partial x|/\\max_{x}|\\partial T/\\partial x|$, $S_Y(x) = |\\partial Y_{\\mathrm{OH}}/\\partial x|/\\max_{x}|\\partial Y_{\\mathrm{OH}}/\\partial x|$ 和 $S_q(x) = |\\dot{q}(x)|/\\max_{x}|\\dot{q}(x)|$。将组合指示器定义为调和平均数 $C(x) = \\frac{3}{\\frac{1}{S_T(x)} + \\frac{1}{S_Y(x)} + \\frac{1}{S_q(x)}}$，并约定当任何分母为零时，相应项视为 $+\\infty$，从而使 $C(x)$ 变为零。使用阈值 $\\tau = 0.5$，如果 $C(x) \\ge \\tau$，则标记该点进行加密。令 $N_{\\text{ref}}$ 为被标记点的数量。\n- 计算组合指示器峰值位置 $x_C$（$C(x)$ 取得最大值处），并计算 $s_{Cq} = |x_C - x_q|/\\delta_{\\mathrm{th}}$，即以米为单位的距离并由 $\\delta_{\\mathrm{th}}$ 归一化。\n\n要求的输出和单位：\n- 对于每个数据集，按顺序输出一个包含以下内容的列表：$s_{Tq}$，$s_{Yq}$，$s_{TY}$，$s_{Cq}$，$x_{T'}$，$x_q$ 和 $N_{\\text{ref}}$。所有 $x$ 值必须以米为单位，所有 $s$ 值为无量纲。$N_{\\text{ref}}$ 是一个整数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表包含三个按数据集 $1$、$2$ 和 $3$ 顺序排列的子列表，例如 $[[\\dots],[\\dots],[\\dots]]$。\n\n测试套件覆盖范围：\n- 数据集 $1$ 测试一个解析良好的光滑火焰。\n- 数据集 $2$ 探测一个接近网格分辨率的锋面，以测试边界敏感性。\n- 数据集 $3$ 包含噪声，以测试组合指示器对伪极值的鲁棒性。",
            "solution": "该问题要求分析合成的一维预混火焰数据，以识别关键特征的位置，并为自适应网格加密（AMR）设计一个鲁棒的加密指示器。解决方案涉及几个计算步骤，这些步骤将应用于三个不同数据集，分别代表解析良好的火焰、解析不足的火焰和带有噪声信号的火焰。\n\n首先，我们建立计算域并生成物理场数据。对于每个数据集，在长度为 $L$ 的域上创建一个包含 $N$ 个点的一维空间网格 $x$，从而得到均匀的网格间距 $\\Delta x = L/(N-1)$。使用所提供的解析函数在每个网格点上计算温度分布 $T(x)$、羟基质量分数 $Y_{\\mathrm{OH}}(x)$ 以及放热率大小 $|\\dot{q}(x)|$：\n$$T(x) = T_u + (T_b - T_u)\\,\\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_0}{\\delta_T}\\right)\\right)$$\n$$Y_{\\mathrm{OH}}(x) = Y_{\\text{peak}}\\exp\\left(-\\frac{(x - x_0 - s_{\\mathrm{OH}})^2}{2\\sigma_{\\mathrm{OH}}^2}\\right)$$\n$$|\\dot{q}|(x) = q_{\\text{peak}}\\exp\\left(-\\frac{(x - x_0 - s_q)^2}{2\\sigma_q^2}\\right)$$\n对于数据集 $3$，向每个场中添加零均值高斯噪声。具体来说，令 $T_{clean}(x)$、$Y_{\\mathrm{OH,clean}}(x)$ 和 $|\\dot{q}|_{clean}(x)$ 为由公式生成的分布。则带噪声的分布为 $T(x) = T_{clean}(x) + \\eta_T(x)$，$Y_{\\mathrm{OH}}(x) = Y_{\\mathrm{OH,clean}}(x) + \\eta_Y(x)$ 和 $|\\dot{q}|(x) = |\\dot{q}|_{clean}(x) + \\eta_q(x)$，其中 $\\eta_T$、$\\eta_Y$ 和 $\\eta_q$ 是分别从标准差为 $0.005\\,(T_b - T_u)$、$0.05\\,Y_{\\text{peak}}$ 和 $0.05\\,q_{\\text{peak}}$ 的正态分布中抽取的随机变量。\n\n其次，通过数值计算空间导数来识别基于梯度的特征。使用二阶中心差分格式计算内部网格点 $i \\in [1, N-2]$ 的导数 $\\partial T/\\partial x$ 和 $\\partial Y_{\\mathrm{OH}}/\\partial x$：\n$$ \\left(\\frac{\\partial f}{\\partial x}\\right)_i \\approx \\frac{f_{i+1} - f_{i-1}}{2\\Delta x} $$\n并使用一阶单边差分格式计算边界点 $i=0$ 和 $i=N-1$ 的导数：\n$$ \\left(\\frac{\\partial f}{\\partial x}\\right)_0 \\approx \\frac{f_1 - f_0}{\\Delta x}, \\quad \\left(\\frac{\\partial f}{\\partial x}\\right)_{N-1} \\approx \\frac{f_{N-1} - f_{N-2}}{\\Delta x} $$\n\n第三，从离散数据中确定主要火焰特征的位置。火焰锋面位置 $x_{T'}$ 是温度梯度大小 $|\\partial T/\\partial x|$ 最大的网格点 $x$。类似地，羟基梯度锋面位置 $x_{Y'}$ 是 $|\\partial Y_{\\mathrm{OH}}/\\partial x|$ 最大的位置。羟基峰值位置 $x_{Y}$ 和放热峰值位置 $x_{q}$ 分别是 $Y_{\\mathrm{OH}}(x)$ 和 $|\\dot{q}(x)|$ 最大的位置。这些位置都是通过查找相应数组中最大值的索引来确定的。\n\n第四，计算热厚度 $\\delta_{\\mathrm{th}}$。该度量表征了主要温度过渡区的宽度。其定义为 $\\delta_{\\mathrm{th}} = |x_{0.9} - x_{0.1}|$，其中 $x_{0.1}$ 和 $x_{0.9}$ 分别是温度等于 $T_{0.1} = T_u + 0.1(T_b - T_u)$ 和 $T_{0.9} = T_u + 0.9(T_b - T_u)$ 的空间坐标。这些位置通过对离散的 $T(x)$ 分布进行线性插值来确定。对于数据集 $3$ 中可能非单调的带噪声温度分布，在插值前将温度及其对应的坐标数组一起排序，以确保插值的正确性。\n\n第五，评估定位敏感度。这些无量纲量用于衡量不同特征检测标记之间的空间间隔，并用火焰热厚度 $\\delta_{\\mathrm{th}}$ 进行归一化。该度量计算如下：\n$$s_{Tq} = \\frac{|x_{T'} - x_q|}{\\delta_{\\mathrm{th}}}, \\quad s_{Yq} = \\frac{|x_{Y} - x_q|}{\\delta_{\\mathrm{th}}}, \\quad s_{TY} = \\frac{|x_{T'} - x_{Y'}|}{\\delta_{\\mathrm{th}}}$$\n\n第六，设计并评估一个鲁棒的组合加密指示器 $C(x)$。此步骤旨在为 AMR 创建一个单一、可靠的标记，该标记比任何单个标记对噪声或解析不足都更不敏感。首先，将各个指示器归一化到 $[0, 1]$ 区间：\n$$S_T(x) = \\frac{|\\partial T/\\partial x|}{\\max_{x}|\\partial T/\\partial x|}, \\quad S_Y(x) = \\frac{|\\partial Y_{\\mathrm{OH}}/\\partial x|}{\\max_{x}|\\partial Y_{\\mathrm{OH}}/\\partial x|}, \\quad S_q(x) = \\frac{|\\dot{q}(x)|}{\\max_{x}|\\dot{q}(x)|}$$\n组合指示器 $C(x)$ 定义为这些归一化指示器的调和平均数：\n$$C(x) = \\frac{3}{\\frac{1}{S_T(x)} + \\frac{1}{S_Y(x)} + \\frac{1}{S_q(x)}}$$\n按照约定，如果任何单个指示器 $S(x)$ 为零，则项 $1/S(x)$ 被视为无穷大，导致 $C(x) = 0$。此属性确保组合指示器仅在所有三个底层标记都显著的区域才较大，从而赋予其鲁棒性。如果 $C(x) \\ge \\tau$（其中阈值给定为 $\\tau = 0.5$），则将网格点标记为待加密。此类点的总数记为 $N_{\\text{ref}}$。同时确定此组合指示器的峰值位置 $x_C$，其与放热峰值的间隔由 $s_{Cq} = |x_C - x_q|/\\delta_{\\mathrm{th}}$ 量化。\n\n最后，对三个数据集中的每一个执行整个过程，并收集计算出的值（$s_{Tq}$，$s_{Yq}$，$s_{TY}$，$s_{Cq}$，$x_{T'}$，$x_q$ 和 $N_{\\text{ref}}$）作为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that defines datasets, processes them,\n    and prints the results in the required format.\n    \"\"\"\n\n    def compute_derivative(f, dx):\n        \"\"\"\n        Computes the spatial derivative of a 1D array f with spacing dx.\n        Uses second-order centered differences for the interior and\n        first-order one-sided differences for the boundaries.\n        \"\"\"\n        N = len(f)\n        if N  2:\n            return np.zeros_like(f)\n        \n        df_dx = np.zeros(N, dtype=float)\n        \n        # Interior points (second-order centered)\n        if N > 2:\n            df_dx[1:-1] = (f[2:] - f[:-2]) / (2 * dx)\n        \n        # Boundary points (first-order one-sided)\n        df_dx[0] = (f[1] - f[0]) / dx\n        df_dx[-1] = (f[-1] - f[-2]) / dx\n        \n        return df_dx\n\n    def process_dataset(params):\n        \"\"\"\n        Processes a single dataset to compute all required metrics.\n        \"\"\"\n        # 1. Unpack parameters and generate grid\n        L, N = params['L'], params['N']\n        Tu, Tb = params['T_u'], params['T_b']\n        x0, dT = params['x_0'], params['delta_T']\n        Yp, sOH, sigOH = params['Y_peak'], params['s_OH'], params['sigma_OH']\n        qp, sq, sigq = params['q_peak'], params['s_q'], params['sigma_q']\n\n        x = np.linspace(0, L, N)\n        dx = x[1] - x[0]\n\n        # 2. Generate clean profiles\n        T = Tu + (Tb - Tu) * 0.5 * (1 + np.tanh((x - x0) / dT))\n        Y_OH = Yp * np.exp(-((x - x0 - sOH)**2) / (2 * sigOH**2))\n        q_dot = qp * np.exp(-((x - x0 - sq)**2) / (2 * sigq**2))\n\n        # 3. Add noise if specified (Dataset 3)\n        if params.get('noise', False):\n            rng = np.random.default_rng(params['seed'])\n            \n            noise_T = rng.normal(0, 0.005 * (Tb - Tu), N)\n            T += noise_T\n            \n            noise_Y = rng.normal(0, 0.05 * Yp, N)\n            Y_OH += noise_Y\n\n            noise_q = rng.normal(0, 0.05 * qp, N)\n            q_dot += noise_q\n\n        # 4. Compute derivatives\n        dT_dx = compute_derivative(T, dx)\n        dYOH_dx = compute_derivative(Y_OH, dx)\n        abs_dT_dx = np.abs(dT_dx)\n        abs_dYOH_dx = np.abs(dYOH_dx)\n\n        # 5. Determine feature locations\n        x_T_prime = x[np.argmax(abs_dT_dx)]\n        x_Y_prime = x[np.argmax(abs_dYOH_dx)]\n        x_Y = x[np.argmax(Y_OH)]\n        x_q = x[np.argmax(q_dot)]\n\n        # 6. Compute thermal thickness\n        T_01 = Tu + 0.1 * (Tb - Tu)\n        T_09 = Tu + 0.9 * (Tb - Tu)\n        \n        # For noisy data, ensure T is monotonic for interpolation\n        if params.get('noise', False):\n            sort_indices = np.argsort(T)\n            T_sorted = T[sort_indices]\n            x_sorted = x[sort_indices]\n            x_01 = np.interp(T_01, T_sorted, x_sorted)\n            x_09 = np.interp(T_09, T_sorted, x_sorted)\n        else: # For clean data, T is monotonic\n            x_01 = np.interp(T_01, T, x)\n            x_09 = np.interp(T_09, T, x)\n\n        delta_th = np.abs(x_09 - x_01)\n        if delta_th == 0: delta_th = 1e-12 # Avoid division by zero\n\n        # 7. Evaluate localization sensitivities\n        s_Tq = np.abs(x_T_prime - x_q) / delta_th\n        s_Yq = np.abs(x_Y - x_q) / delta_th\n        s_TY = np.abs(x_T_prime - x_Y_prime) / delta_th\n\n        # 8. Compute combined refinement indicator\n        max_abs_dT_dx = np.max(abs_dT_dx)\n        if max_abs_dT_dx == 0: max_abs_dT_dx = 1e-12\n        S_T = abs_dT_dx / max_abs_dT_dx\n\n        max_abs_dYOH_dx = np.max(abs_dYOH_dx)\n        if max_abs_dYOH_dx == 0: max_abs_dYOH_dx = 1e-12\n        S_Y = abs_dYOH_dx / max_abs_dYOH_dx\n        \n        max_q_dot = np.max(q_dot)\n        if max_q_dot = 0: max_q_dot = 1e-12 # Handle potential negative noisy values\n        S_q = q_dot / max_q_dot\n        S_q[S_q  0] = 0 # Magnitudes cannot be negative\n\n        C = np.zeros_like(x)\n        inv_S_T = np.divide(1.0, S_T, out=np.full_like(S_T, np.inf), where=S_T!=0)\n        inv_S_Y = np.divide(1.0, S_Y, out=np.full_like(S_Y, np.inf), where=S_Y!=0)\n        inv_S_q = np.divide(1.0, S_q, out=np.full_like(S_q, np.inf), where=S_q!=0)\n        \n        denominator_sum = inv_S_T + inv_S_Y + inv_S_q\n        mask = np.isfinite(denominator_sum)  (denominator_sum > 0)\n        C[mask] = 3.0 / denominator_sum[mask]\n\n        tau = 0.5\n        N_ref = np.sum(C >= tau)\n\n        # 9. Compute C peak location and sensitivity\n        x_C = x[np.argmax(C)]\n        s_Cq = np.abs(x_C - x_q) / delta_th\n\n        return [s_Tq, s_Yq, s_TY, s_Cq, x_T_prime, x_q, N_ref]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 0.02, \"N\": 400, \"T_u\": 300, \"T_b\": 2100, \"x_0\": 0.010,\n            \"delta_T\": 0.0005, \"Y_peak\": 0.01, \"s_OH\": 0.0001, \"sigma_OH\": 0.0003,\n            \"q_peak\": 5e9, \"s_q\": 0.00015, \"sigma_q\": 0.00025\n        },\n        {\n            \"L\": 0.01, \"N\": 60, \"T_u\": 300, \"T_b\": 2100, \"x_0\": 0.005,\n            \"delta_T\": 0.0002, \"Y_peak\": 0.01, \"s_OH\": 0.00006, \"sigma_OH\": 0.00015,\n            \"q_peak\": 3e9, \"s_q\": 0.00008, \"sigma_q\": 0.00012\n        },\n        {\n            \"L\": 0.02, \"N\": 400, \"T_u\": 300, \"T_b\": 2100, \"x_0\": 0.010,\n            \"delta_T\": 0.0005, \"Y_peak\": 0.01, \"s_OH\": 0.0001, \"sigma_OH\": 0.0003,\n            \"q_peak\": 5e9, \"s_q\": 0.00015, \"sigma_q\": 0.00025,\n            \"noise\": True, \"seed\": 12345\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_dataset(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_sublists = []\n    for res_list in results:\n        # The last element N_ref must be an integer\n        str_list = [f\"{val:.6f}\" for val in res_list[:-1]] + [f\"{int(res_list[-1])}\"]\n        formatted_sublists.append(f\"[{','.join(str_list)}]\")\n    \n    print(f\"[{','.join(formatted_sublists)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了在多维模拟中实现最高的计算效率，仅进行各向同性的网格加密（即简单地将单元格变小）是不够的。本项高级实践将指导您如何设计一种各向异性自适应度量，使网格单元能够根据火焰锋面的局部几何形状进行拉伸和对齐。通过计算温度场的Hessian矩阵并从中推导曲率，您将学习如何创建与火焰结构高度匹配的高效网格。",
            "id": "4057404",
            "problem": "给定一个在笛卡尔坐标系 $\\mathbf{x} = (x,y)$ 的矩形域上定义的二维温度场 $T(\\mathbf{x})$。该场包含一个被建模为等温线的预混火焰锋面。您的任务是：计算温度场的 Hessian 矩阵 $H(T)$，根据 $H(T)$ 估计火焰锋面的曲率，并设计一个各向异性自适应度量，以保证沿火焰锋面的局部法线方向有 $N$ 个点，沿局部切线方向有 $M$ 个点。该自适应应指定为火焰锋面上各点的方向相关间距 $h_n$ 和 $h_t$，并且这些间距必须以米为单位报告。\n\n使用的基本原理和定义：\n- 温度场 $T(x,y)$ 是一个光滑的标量函数。其梯度为 $\\nabla T = (T_x, T_y)$，其中 $T_x = \\partial T / \\partial x$，$T_y = \\partial T / \\partial y$。Hessian 矩阵 $H(T)$ 是一个 $2 \\times 2$ 的二阶导数矩阵，\n$$\nH(T) = \\begin{bmatrix}\nT_{xx}  T_{xy} \\\\\nT_{yx}  T_{yy}\n\\end{bmatrix},\n$$\n其中 $T_{xx} = \\partial^2 T / \\partial x^2$，$T_{yy} = \\partial^2 T / \\partial y^2$，$T_{xy} = T_{yx} = \\partial^2 T / (\\partial x \\partial y)$。\n- 火焰锋面被定义为等温线 $T(x,y) = T_f$，其中 $T_f$ 是给定的。在火焰锋面上的点，定义单位法向量 $\\mathbf{n} = \\nabla T / \\|\\nabla T\\|$ 和一个与 $\\mathbf{n}$ 正交的单位切向量 $\\mathbf{t}$，其定义为 $\\mathbf{t} = (-n_y, n_x)$。\n- 水平集 $T(x,y) = \\text{constant}$ 的曲率 $\\kappa$ 可以通过一阶和二阶导数计算得出：\n$$\n\\kappa = \\frac{T_x^2 T_{yy} - 2 T_x T_y T_{xy} + T_y^2 T_{xx}}{\\|\\nabla T\\|^3}.\n$$\n- 沿法线方向的局部热厚度近似为：\n$$\nL_n = \\frac{\\Delta T}{\\|\\nabla T\\|},\n$$\n其中 $\\Delta T = T_b - T_u$ 是混合物穿过反应区时从未燃($T_u$)到已燃($T_b$)的温升。\n- 局部切向长度尺度取为局部曲率半径 $R = 1/|\\kappa|$，并由一个最大切向尺度 $L_{\\max}$ 进行限制，以避免当 $|\\kappa|$ 接近零时出现无界值。具体来说，\n$$\nL_t = \\min\\left(\\frac{1}{\\max(|\\kappa|,\\kappa_{\\min})}, L_{\\max}\\right),\n$$\n其中 $\\kappa_{\\min}  0$ 是一个小的阈值。\n- 为保证沿法线方向有 $N$ 个解析点，沿切线方向有 $M$ 个解析点，选择间距为：\n$$\nh_n = \\frac{L_n}{N}, \\qquad h_t = \\frac{L_t}{M}.\n$$\n- 火焰锋面处的各向异性度量张量 $G$ 可以指定为与 $\\mathbf{n}$ 和 $\\mathbf{t}$ 对齐，其沿 $\\mathbf{n}$ 和 $\\mathbf{t}$ 方向的特征值分别为 $1/h_n^2$ 和 $1/h_t^2$。\n\n每个测试用例的 $T(x,y)$ 的数值构造：\n- 域是一个尺寸为 $L_x \\times L_y$ 米的矩形，在 $N_x \\times N_y$ 个点的均匀网格上离散化。\n- 温度场是基于双曲正切剖面在火焰锋面上的平滑过渡构建的，\n$$\nT(x,y) = T_u + \\Delta T \\cdot \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_0(y)}{\\delta}\\right)\\right),\n$$\n其中 $x_0(y)$ 是在 $y$ 方向上调制的火焰锋面位置，$\\delta$ 是控制陡峭度的热厚度参数。\n\n估计和输出要求：\n- 在均匀网格上使用二阶中心差分计算 $T_x, T_y, T_{xx}, T_{yy}, T_{xy}$。\n- 定义火焰锋面等温线为 $T_f = (T_u + T_b)/2$。使用 $|T - T_f| \\le \\epsilon$ 识别锋面周围窄带中的网格点，其中 $\\epsilon = 0.01 \\Delta T$。\n- 在这些窄带点上，使用上述公式计算 $\\|\\nabla T\\|$, $H(T)$, $\\kappa$, $L_n$, $L_t$, $h_n$ 和 $h_t$。\n- 报告每个测试用例在窄带点上 $h_n$ 和 $h_t$ 的平均值。这些平均值必须以米为单位表示为十进制数。输出中不要包含单位符号；最终打印的列表中只允许出现数值。\n\n测试套件：\n为以下四组参数提供结果。所有量纲单位分别为米或开尔文。\n1.  案例1：平面锋面。\n    -   $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$。\n    -   $T_u = 300$, $T_b = 2000$, $\\delta = 0.0005$。\n    -   $x_0(y) = L_x/2$，即无调制（$a = 0$，$\\lambda$ 未使用）。\n    -   $N = 10$, $M = 20$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$。\n\n2.  案例2：弱弯曲锋面。\n    -   $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$。\n    -   $T_u = 300$, $T_b = 2000$, $\\delta = 0.0003$。\n    -   $x_0(y) = L_x/2 + a \\sin(2\\pi y/\\lambda)$，其中 $a = 0.001$，$\\lambda = L_y$。\n    -   $N = 12$, $M = 24$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$。\n\n3.  案例3：更强弯曲的锋面。\n    -   $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$。\n    -   $T_u = 300$, $T_b = 2000$, $\\delta = 0.0002$。\n    -   $x_0(y) = L_x/2 + a \\sin(2\\pi y/\\lambda)$，其中 $a = 0.003$，$\\lambda = L_y$。\n    -   $N = 16$, $M = 32$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$。\n\n4.  案例4：较厚的反应区，平面锋面（小梯度边缘情况）。\n    -   $L_x = 0.02$, $L_y = 0.02$, $N_x = 301$, $N_y = 301$。\n    -   $T_u = 300$, $T_b = 2000$, $\\delta = 0.002$。\n    -   $x_0(y) = L_x/2$。\n    -   $N = 6$, $M = 12$, $L_{\\max} = 0.01$, $\\kappa_{\\min} = 10^{-6}$。\n\n答案规范：\n- 对于每个测试用例，您的程序必须计算并返回列表 $[h_n^{\\text{avg}}, h_t^{\\text{avg}}]$（单位为米），其中 $h_n^{\\text{avg}}$ 和 $h_t^{\\text{avg}}$ 是锋面窄带点上 $h_n$ 和 $h_t$ 的平均值。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个子列表，并按顺序排列，例如 $[[h_{n,1},h_{t,1}],[h_{n,2},h_{t,2}],\\ldots]$。",
            "solution": "所述问题是有效的。它在科学上基于计算燃烧学和流体动力学的原理，特别是关于解析火焰锋面的自适应网格加密。该问题是适定的，为获得唯一的数值解提供了所有必要的参数和定义。语言客观，设置一致。因此，我们可以开始求解。\n\n目标是设计一种各向异性网格自适应度量，用于解析二维域中的预混火焰锋面。这是通过计算所需的网格间距 $h_n$ 和 $h_t$ 来实现的，这两个间距分别对应于火焰锋面的法线方向和切线方向。这些间距是根据火焰的局部物理长度尺度确定的。该过程包括以下主要步骤：\n\n1.  **温度场构建**：首先，在一个均匀的笛卡尔网格上构建一个连续可微的温度场 $T(x,y)$。该场代表一个预混火焰，具有从未燃温度 $T_u$到已燃温度 $T_b$的平滑过渡。\n2.  **数值微分**：对温度场的一阶和二阶偏导数（$T_x, T_y, T_{xx}, T_{yy}, T_{xy}$）进行数值计算。这些导数对于表征火焰锋面的局部几何形状至关重要。\n3.  **火焰锋面定位**：火焰锋面被确定为等温线 $T(x,y) = T_f$。在实践中，我们对该等温线周围的一个窄带网格点进行操作，以确保稳健的数值评估。\n4.  **几何和物理属性计算**：在火焰锋面窄带内的每个点上，我们计算以下关键量：\n    *   温度梯度的模 $\\|\\nabla T\\|$，它与火焰的局部厚度成反比。\n    *   温度等值线的曲率 $\\kappa$，它量化了火焰锋面的局部弯曲程度。\n5.  **特征长度尺度的确定**：根据计算出的属性，我们定义两个特征长度尺度：\n    *   法向长度尺度 $L_n$，代表火焰的热厚度。\n    *   切向长度尺度 $L_t$，基于局部曲率半径。\n6.  **网格间距的计算**：最后，通过要求特定数量的网格点 $N$ 和 $M$ 分别解析法向和切向长度尺度，来计算所需的网格间距 $h_n$ 和 $h_t$。\n\n我们现在将详细说明每个步骤的实现。\n\n**1. 网格和温度场生成**\n\n计算域是一个尺寸为 $L_x \\times L_y$ 的矩形，由一个 $N_x \\times N_y$ 点的均匀网格离散化。网格间距为 $\\Delta x = L_x / (N_x-1)$ 和 $\\Delta y = L_y / (N_y-1)$。温度场 $T(x,y)$ 由以下解析表达式给出：\n$$\nT(x,y) = T_u + \\Delta T \\cdot \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_0(y)}{\\delta}\\right)\\right)\n$$\n其中 $\\Delta T = T_b - T_u$ 是总温升，$\\delta$ 是控制火焰厚度的参数，$x_0(y)$ 定义了火焰锋面中心的位置。对于平面锋面，$x_0(y)$ 是一个常数。对于弯曲锋面，它是一个正弦函数 $x_0(y) = L_x/2 + a \\sin(2\\pi y/\\lambda)$。\n\n**2. 数值微分**\n\n为了评估火焰的几何特性，我们需要 $T(x,y)$ 的偏导数。我们采用二阶中心差分格式，这适用于均匀网格。对于在网格上离散为 $f_{i,j} = f(i\\Delta x, j\\Delta y)$ 的函数 $f(x,y)$，其导数近似为：\n$$\n\\frac{\\partial f}{\\partial x}\\bigg|_{i,j} \\approx \\frac{f_{i+1,j} - f_{i-1,j}}{2 \\Delta x}\n$$\n$$\n\\frac{\\partial^2 f}{\\partial x^2}\\bigg|_{i,j} \\approx \\frac{f_{i+1,j} - 2f_{i,j} + f_{i-1,j}}{(\\Delta x)^2}\n$$\n$$\n\\frac{\\partial^2 f}{\\partial x \\partial y}\\bigg|_{i,j} \\approx \\frac{f_{i+1,j+1} - f_{i+1,j-1} - f_{i-1,j+1} + f_{i-1,j-1}}{4 \\Delta x \\Delta y}\n$$\n类似的公式适用于 $T_y$ 和 $T_{yy}$。这些计算在整个网格上执行。\n\n**3. 火焰锋面定位**\n\n火焰锋面由等温线 $T_f = (T_u + T_b) / 2$ 定义。我们选择所有网格点 $(x_i, y_j)$，其温度 $T(x_i, y_j)$ 在 $T_f$ 的一个小的容差 $\\epsilon$ 范围内。条件是：\n$$\n|T(x,y) - T_f| \\le \\epsilon\n$$\n其中 $\\epsilon$ 被设置为 $0.01 \\Delta T$。这样可以识别出一个有效采样火焰结构的薄带点。\n\n**4. 物理量计算**\n\n在上一步中识别的每个网格点上，我们继续计算以下量。\n\n温度梯度的模是基础，由下式给出：\n$$\n\\|\\nabla T\\| = \\sqrt{T_x^2 + T_y^2}\n$$\n$T(x,y)$ 水平集的曲率 $\\kappa$ 使用已建立的涉及一阶和二阶导数的公式计算：\n$$\n\\kappa = \\frac{T_x^2 T_{yy} - 2 T_x T_y T_{xy} + T_y^2 T_{xx}}{\\|\\nabla T\\|^3}\n$$\n\n**5. 特征长度尺度的确定**\n\n局部法向长度尺度 $L_n$ 是热厚度，与最大温度梯度成反比。它定义为：\n$$\nL_n = \\frac{\\Delta T}{\\|\\nabla T\\|}\n$$\n局部切向长度尺度 $L_t$ 与火焰的几何形状有关。它被取为曲率半径 $R = 1/|\\kappa|$。为了处理低曲率区域（其中 $R \\to \\infty$）并保持合理的纵横比，$L_t$ 被最小曲率 $\\kappa_{\\min}$ 和最大长度尺度 $L_{\\max}$ 限制：\n$$\nL_t = \\min\\left(\\frac{1}{\\max(|\\kappa|,\\kappa_{\\min})}, L_{\\max}\\right)\n$$\n这种公式确保了切向长度尺度保持有界且具有物理意义。\n\n**6. 各向异性网格间距的计算**\n\n最终目标是确定能确保火焰被充分解析的网格间距 $h_n$ 和 $h_t$。要求是在法向长度尺度 $L_n$ 上放置 $N$ 个网格点，在切向长度尺度 $L_t$ 上放置 $M$ 个网格点。这直接引出以下定义：\n$$\nh_n = \\frac{L_n}{N}, \\qquad h_t = \\frac{L_t}{M}\n$$\n这些值是为火焰锋面窄带中的每个点计算的。\n\n**7. 平均和最终输出**\n\n对于每个测试用例，问题要求报告 $h_n$ 和 $h_t$ 的单个代表值。我们通过计算在火焰锋面窄带内的点上计算出的所有 $h_n$ 和 $h_t$ 值的算术平均值来实现这一点。这提供了根据指定标准解析火焰锋面所需的平均法向间距 $h_n^{\\text{avg}}$ 和平均切向间距 $h_t^{\\text{avg}}$。然后对每个提供的测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes anisotropic mesh spacings for resolving a premixed flame front\n    for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: Planar front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.0005, 'a': 0.0, 'lambda_y': 0.02, 'N': 10, 'M': 20,\n         'Lmax': 0.01, 'kappa_min': 1e-6},\n        # Case 2: Weakly curved front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.0003, 'a': 0.001, 'lambda_y': 0.02, 'N': 12, 'M': 24,\n         'Lmax': 0.01, 'kappa_min': 1e-6},\n        # Case 3: More strongly curved front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.0002, 'a': 0.003, 'lambda_y': 0.02, 'N': 16, 'M': 32,\n         'Lmax': 0.01, 'kappa_min': 1e-6},\n        # Case 4: Thicker reaction zone, planar front\n        {'Lx': 0.02, 'Ly': 0.02, 'Nx': 301, 'Ny': 301, 'Tu': 300.0, 'Tb': 2000.0,\n         'delta': 0.002, 'a': 0.0, 'lambda_y': 0.02, 'N': 6, 'M': 12,\n         'Lmax': 0.01, 'kappa_min': 1e-6}\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Unpack parameters from the dictionary\n        Lx, Ly, Nx, Ny = case['Lx'], case['Ly'], case['Nx'], case['Ny']\n        Tu, Tb, delta = case['Tu'], case['Tb'], case['delta']\n        a, lambda_y = case['a'], case['lambda_y']\n        N, M, Lmax, kappa_min = case['N'], case['M'], case['Lmax'], case['kappa_min']\n\n        # 1. Create grid and compute grid spacings\n        x_vec = np.linspace(0, Lx, Nx)\n        y_vec = np.linspace(0, Ly, Ny)\n        dx = x_vec[1] - x_vec[0]\n        dy = y_vec[1] - y_vec[0]\n        # meshgrid with 'xy' indexing creates arrays of shape (Ny, Nx)\n        x, y = np.meshgrid(x_vec, y_vec, indexing='xy')\n\n        # 2. Generate the temperature field\n        delta_T = Tb - Tu\n        if a == 0.0:\n            x0_y = Lx / 2.0\n        else:\n            x0_y = Lx / 2.0 + a * np.sin(2.0 * np.pi * y / lambda_y)\n        \n        arg_tanh = (x - x0_y) / delta\n        T = Tu + delta_T * 0.5 * (1.0 + np.tanh(arg_tanh))\n\n        # 3. Compute first and second derivatives using second-order central differences\n        # np.gradient assumes first axis is y and second is x for (Ny, Nx) arrays\n        Ty, Tx = np.gradient(T, dy, dx)\n        \n        # Second derivatives are computed from gradients of first derivatives\n        _, Txx = np.gradient(Tx, dy, dx)  # d(Tx)/dx\n        Tyy, Txy = np.gradient(Ty, dy, dx)  # d(Ty)/dy and d(Ty)/dx\n\n        # 4. Identify flame front band\n        Tf = (Tu + Tb) / 2.0\n        epsilon = 0.01 * delta_T\n        band_indices = np.where(np.abs(T - Tf) = epsilon)\n\n        if band_indices[0].size == 0:\n            # Handle the case where no points are found in the band\n            all_results.append([float('nan'), float('nan')])\n            continue\n\n        # Extract derivatives at the band points\n        Tx_band = Tx[band_indices]\n        Ty_band = Ty[band_indices]\n        Txx_band = Txx[band_indices]\n        Tyy_band = Tyy[band_indices]\n        Txy_band = Txy[band_indices]\n\n        # 5. Compute physical quantities at band points\n        # Gradient magnitude\n        grad_T_norm_sq = Tx_band**2 + Ty_band**2\n        grad_T_norm = np.sqrt(grad_T_norm_sq)\n\n        # Curvature\n        kappa_numerator = (Tx_band**2 * Tyy_band -\n                           2 * Tx_band * Ty_band * Txy_band +\n                           Ty_band**2 * Txx_band)\n        kappa_denominator = grad_T_norm**3\n        \n        # Use np.divide to safely handle potential division by zero\n        kappa = np.divide(kappa_numerator, kappa_denominator, \n                          out=np.zeros_like(kappa_numerator, dtype=float), \n                          where=kappa_denominator != 0)\n\n        # 6. Determine characteristic length scales\n        # Normal length scale (thermal thickness)\n        Ln = np.divide(delta_T, grad_T_norm, out=np.zeros_like(grad_T_norm), where=grad_T_norm!=0)\n        \n        # Tangential length scale (based on radius of curvature)\n        abs_kappa = np.abs(kappa)\n        inv_kappa_clipped = 1.0 / np.maximum(abs_kappa, kappa_min)\n        Lt = np.minimum(inv_kappa_clipped, Lmax)\n        \n        # 7. Compute required spacings\n        hn = Ln / N\n        ht = Lt / M\n\n        # 8. Average results\n        hn_avg = np.mean(hn)\n        ht_avg = np.mean(ht)\n\n        all_results.append([hn_avg, ht_avg])\n\n    # Final print statement in the exact required format.\n    formatted_sublists = [f\"[{res[0]},{res[1]}]\" for res in all_results]\n    print(f\"[{','.join(formatted_sublists)}]\")\n\nsolve()\n```"
        }
    ]
}