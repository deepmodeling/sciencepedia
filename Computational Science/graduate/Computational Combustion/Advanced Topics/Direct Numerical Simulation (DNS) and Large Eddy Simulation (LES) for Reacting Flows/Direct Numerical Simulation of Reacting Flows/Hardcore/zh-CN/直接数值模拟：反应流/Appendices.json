{
    "hands_on_practices": [
        {
            "introduction": "在任何反应流模拟中，准确计算组分的热力学性质是至关重要的一步。本练习将指导你实现一个核心任务：使用标准的NASA七系数多项式来计算物种的比定压热容 $c_{p,k}$、焓 $h_k$ 和熵 $s_k$。通过这个实践 ，你不仅能掌握从基本热力学关系到计算程序实现的完整过程，还将学会如何验证这些性质在不同温度区间连接点处的连续性，这对保证直接数值模拟（DNS）的数值稳定性至关重要。",
            "id": "4019148",
            "problem": "考虑在燃烧的直接数值模拟 (DNS) 中通常建模的反应理想气体混合物，其中必须精确且平滑地评估各组分随温度变化的热力学性质，以避免源项中的数值伪影。对于每个组分，在不相交的温度区间上使用美国国家航空航天局 (NASA) 的七系数多项式表示法。令 $T$ 表示以开尔文为单位的绝对温度，令 $R$ 表示以 $\\mathrm{J}\\, \\mathrm{mol}^{-1}\\, \\mathrm{K}^{-1}$ 为单位的通用气体常数。对于给定的温度区间，NASA 表示法提供了一组系数 $\\{a_1,a_2,a_3,a_4,a_5,a_6,a_7\\}$，这些系数必须用于计算组分的定压热容 $c_{p,k}(T)$、焓 $h_k(T)$ 和熵 $s_k(T)$。\n\n从基本热力学定义和理想气体假设出发，推导基于每个区间上的 NASA 七系数多项式表示法来计算 $c_{p,k}(T)$（单位为 $\\mathrm{J}\\, \\mathrm{mol}^{-1}\\, \\mathrm{K}^{-1}$）、$h_k(T)$（单位为 $\\mathrm{J}\\, \\mathrm{mol}^{-1}$）和 $s_k(T)$（单位为 $\\mathrm{J}\\, \\mathrm{mol}^{-1}\\, \\mathrm{K}^{-1}$）的表达式。然后，在一个指定的温度范围内实现一个计算，该计算在 $\\left[T_{\\min}^{\\text{low}},T_{\\max}^{\\text{low}}\\right]$ 上使用低温多项式，在 $\\left[T_{\\min}^{\\text{high}},T_{\\max}^{\\text{high}}\\right]$ 上使用高温多项式，并有一个满足 $T_{\\min}^{\\text{low}} \\le T_{\\mathrm{mid}} \\le T_{\\max}^{\\text{low}}$ 和 $T_{\\min}^{\\text{high}} \\le T_{\\mathrm{mid}} \\le T_{\\max}^{\\text{high}}$ 的断点（也称为中点）$T_{\\mathrm{mid}}$。通过检查在 $T=T_{\\mathrm{mid}}$ 时，由低温多项式和高温多项式计算出的值在指定容差内是否匹配，来验证 $c_{p,k}(T)$、$h_k(T)$ 和 $s_k(T)$ 在断点处的连续性。报告每个性质在 $T_{\\mathrm{mid}}$ 处的绝对不匹配值，并返回布尔值，指示每个性质是否在容差范围内连续。\n\n使用 $R=8.314462618\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。对于所有涉及物理量的输出，将 $c_{p,k}$ 以 $\\mathrm{J}\\,\\mathrm{mol}^{-1}\\, \\mathrm{K}^{-1}$ 表示，$h_k$ 以 $\\mathrm{J}\\, \\mathrm{mol}^{-1}$ 表示，$s_k$ 以 $\\mathrm{J}\\, \\mathrm{mol}^{-1}\\, \\mathrm{K}^{-1}$ 表示。\n\n组分和系数的测试套件：\n- 组分 $k=$ 氢气 ($\\mathrm{H}_2$)。温度区间：低温 $\\left[200,1000\\right]$ K，高温 $\\left[1000,6000\\right]$ K，断点 $T_{\\mathrm{mid}}=1000$ K。低温系数 $(a_1,\\dots,a_7)$:\n  $\\left(2.34433112,\\, 7.98052075\\times 10^{-3},\\, -1.94781510\\times 10^{-5},\\, 2.01572094\\times 10^{-8},\\, -7.37611761\\times 10^{-12},\\, -9.17935173\\times 10^{2},\\, 6.83010238\\times 10^{-1}\\right)$。\n  高温系数 $(a_1,\\dots,a_7)$:\n  $\\left(3.33727920,\\, -4.94024731\\times 10^{-5},\\, 4.99456778\\times 10^{-7},\\, -1.79566394\\times 10^{-10},\\, 2.00255376\\times 10^{-14},\\, -9.50158922\\times 10^{2},\\, -3.20502331\\right)$。\n  连续性容差：$\\epsilon = 10^{-6}$。\n- 组分 $k=$ 氧气 ($\\mathrm{O}_2$)。温度区间：低温 $\\left[200,1000\\right]$ K，高温 $\\left[1000,6000\\right]$ K，断点 $T_{\\mathrm{mid}}=1000$ K。低温系数：\n  $\\left(3.78245636,\\, -2.99673416\\times 10^{-3},\\, 9.84730201\\times 10^{-6},\\, -9.68129509\\times 10^{-9},\\, 3.24372837\\times 10^{-12},\\, -1.06394356\\times 10^{3},\\, 3.65767573\\right)$。\n  高温系数：\n  $\\left(3.28253784,\\, 1.48308754\\times 10^{-3},\\, -7.57966669\\times 10^{-7},\\, 2.09470555\\times 10^{-10},\\, -2.16717794\\times 10^{-14},\\, -1.08845772\\times 10^{3},\\, 5.45323129\\right)$。\n  连续性容差：$\\epsilon = 10^{-6}$。\n- 组分 $k=$ 水 ($\\mathrm{H}_2\\mathrm{O}$)。温度区间：低温 $\\left[200,1000\\right]$ K，高温 $\\left[1000,6000\\right]$ K，断点 $T_{\\mathrm{mid}}=1000$ K。低温系数：\n  $\\left(4.19864056,\\, -2.03643410\\times 10^{-3},\\, 6.52040211\\times 10^{-6},\\, -5.48797062\\times 10^{-9},\\, 1.77197817\\times 10^{-12},\\, -3.02937267\\times 10^{4},\\, -8.49032208\\times 10^{-1}\\right)$。\n  高温系数：\n  $\\left(3.03399249,\\, 2.17691804\\times 10^{-3},\\, -1.64072518\\times 10^{-7},\\, -9.70419870\\times 10^{-11},\\, 1.68200992\\times 10^{-14},\\, -3.00042971\\times 10^{4},\\, 4.96677010\\right)$。\n  连续性容差：$\\epsilon = 10^{-6}$。\n- 组分 $k=$ 二氧化碳 ($\\mathrm{CO}_2$)。温度区间：低温 $\\left[200,1000\\right]$ K，高温 $\\left[1000,6000\\right]$ K，断点 $T_{\\mathrm{mid}}=1000$ K。低温系数：\n  $\\left(2.35677352,\\, 8.98459677\\times 10^{-3},\\, -7.12356269\\times 10^{-6},\\, 2.45919022\\times 10^{-9},\\, -1.43699548\\times 10^{-13},\\, -4.83719697\\times 10^{4},\\, 9.90105222\\right)$。\n  高温系数：\n  $\\left(3.85796028,\\, 4.41437026\\times 10^{-3},\\, -2.21481404\\times 10^{-6},\\, 5.23490188\\times 10^{-10},\\, -4.72084164\\times 10^{-14},\\, -4.87591660\\times 10^{4},\\, 2.27163806\\right)$。\n  连续性容差：$\\epsilon = 10^{-6}$。\n- 组分 $k=$ 氧气-不匹配 ($\\mathrm{O}_2$-bad)。温度区间：低温 $\\left[200,1000\\right]$ K，高温 $\\left[1000,6000\\right]$ K，断点 $T_{\\mathrm{mid}}=1000$ K。低温系数与 $\\mathrm{O}_2$ 低温系数相同：\n  $\\left(3.78245636,\\, -2.99673416\\times 10^{-3},\\, 9.84730201\\times 10^{-6},\\, -9.68129509\\times 10^{-9},\\, 3.24372837\\times 10^{-12},\\, -1.06394356\\times 10^{3},\\, 3.65767573\\right)$。\n  为破坏连续性而故意扰动的高温系数：\n  $\\left(3.28353784,\\, 1.48308754\\times 10^{-3},\\, -7.57966669\\times 10^{-7},\\, 2.09470555\\times 10^{-10},\\, -2.16717794\\times 10^{-14},\\, -1.08845772\\times 10^{3},\\, 5.45323129\\right)$。\n  连续性容差：$\\epsilon = 10^{-6}$。\n\n实现要求：\n- 从第一性原理推导 $c_{p,k}(T)$、$h_k(T)$ 和 $s_k(T)$ 的表达式，并实现它们在每个区间上的求值。在低温区间使用低温多项式，在高温区间使用高温多项式。\n- 对于每个组分，在 $T=T_{\\mathrm{mid}}$ 处评估两个多项式的值，并计算绝对不匹配值 $\\Delta c_p$、$\\Delta h$、$\\Delta s$，单位如上所述。\n- 对于每个组分，返回三个布尔值，分别指示 $\\Delta c_p \\le \\epsilon$、$\\Delta h \\le \\epsilon$ 和 $\\Delta s \\le \\epsilon$ 是否成立，并附上三个不匹配值的大小。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个结果项应为一个六元列表，顺序为 $\\left[\\text{cp\\_continuous},\\text{h\\_continuous},\\text{s\\_continuous},\\Delta c_p,\\Delta h,\\Delta s\\right]$，其中前三项为布尔值，后三项为浮点数。因此，输出的形式为 $\\left[\\left[b_1,b_2,b_3,x_1,x_2,x_3\\right],\\dots\\right]$。\n\n用于计算 $c_{p,k}(T)$、$h_k(T)$ 和 $s_k(T)$ 的温度网格可以是每个区间的任何合理离散化（例如，均匀间距），但连续性检查必须在断点 $T_{\\mathrm{mid}}$ 处精确执行。角度单位不适用。所有物理量必须以上述指定单位报告。",
            "solution": "该问题已经过验证，被确定为具有科学依据、提法明确且客观。它基于化学热力学的标准原理，并利用一个广泛接受的经验模型（NASA 七系数多项式）来表示计算流体动力学和燃烧模拟中的组分性质。所有必要的数据和约束条件均已提供。因此，我们可以进行推导和求解。\n\n问题的核心是从 NASA 七系数多项式表示法中，为理想气体组分 $k$ 推导摩尔定压热容 ($c_{p,k}$)、摩尔焓 ($h_k$) 和摩尔熵 ($s_k$) 的表达式。这些多项式定义了无量纲热容 $\\frac{c_{p,k}(T)}{R}$ 作为温度 $T$ 的函数。\n\n令通用气体常数为 $R = 8.314462618\\,\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。对于给定的温度区间，NASA 多项式系数为 $\\{a_1, a_2, a_3, a_4, a_5, a_6, a_7\\}$。\n\n**1. 定压热容 $c_{p,k}(T)$ 的推导**\n\n定压无量纲比热的 NASA 标准多项式形式是关于温度 $T$ 的四阶多项式：\n$$\n\\frac{c_{p,k}(T)}{R} = a_1 + a_2 T + a_3 T^2 + a_4 T^3 + a_5 T^4\n$$\n为了获得以 $\\mathrm{J}\\,\\mathrm{mol}^{-1}\\, \\mathrm{K}^{-1}$ 为单位的摩尔定压热容 $c_{p,k}(T)$，我们只需乘以通用气体常数 $R$：\n$$\nc_{p,k}(T) = R \\left( a_1 + a_2 T + a_3 T^2 + a_4 T^3 + a_5 T^4 \\right)\n$$\n\n**2. 摩尔焓 $h_k(T)$ 的推导**\n\n在恒压过程中，物质的定压热容与焓之间的关系由基本热力学定义给出：\n$$\nc_{p,k} = \\left( \\frac{\\partial h_k}{\\partial T} \\right)_P\n$$\n对于理想气体，焓仅是温度的函数，因此偏导数变为常导数，$c_{p,k}(T) = \\frac{dh_k}{dT}$。我们可以通过对 $c_{p,k}(T)$ 进行温度积分来求得焓 $h_k(T)$：\n$$\nh_k(T) = \\int c_{p,k}(T) \\,dT\n$$\n通常使用无量纲形式进行此积分：\n$$\n\\frac{h_k(T)}{R} = \\int \\frac{c_{p,k}(T)}{R} \\,dT + C_1 = \\int \\left( a_1 + a_2 T + a_3 T^2 + a_4 T^3 + a_5 T^4 \\right) \\,dT\n$$\n进行积分得到：\n$$\n\\frac{h_k(T)}{R} = a_1 T + \\frac{a_2}{2} T^2 + \\frac{a_3}{3} T^3 + \\frac{a_4}{4} T^4 + \\frac{a_5}{5} T^5 + a_6\n$$\n在这里，第六个系数 $a_6$ 被定义为积分常数 $C_1$。这是 NASA 多项式的标准约定。为了获得以 $\\mathrm{J}\\,\\mathrm{mol}^{-1}$ 为单位的摩尔焓 $h_k(T)$，我们乘以 $R$ 并重新整理表达式以匹配标准计算形式：\n$$\nh_k(T) = R T \\left( a_1 + \\frac{a_2}{2} T + \\frac{a_3}{3} T^2 + \\frac{a_4}{4} T^3 + \\frac{a_5}{5} T^4 + \\frac{a_6}{T} \\right)\n$$\n\n**3. 摩尔熵 $s_k(T)$ 的推导**\n\n在参考压力下的熵变（标准态熵, $s_k^0$）与热容的关系为：\n$$\nds_k^0 = \\frac{c_{p,k}(T)}{T} \\,dT\n$$\n我们通过对该表达式积分来求得熵 $s_k^0(T)$：\n$$\ns_k^0(T) = \\int \\frac{c_{p,k}(T)}{T} \\,dT\n$$\n使用无量纲形式：\n$$\n\\frac{s_k^0(T)}{R} = \\int \\frac{c_{p,k}(T)}{RT} \\,dT + C_2 = \\int \\left( \\frac{a_1}{T} + a_2 + a_3 T + a_4 T^2 + a_5 T^3 \\right) \\,dT\n$$\n进行积分得到：\n$$\n\\frac{s_k^0(T)}{R} = a_1 \\ln(T) + a_2 T + \\frac{a_3}{2} T^2 + \\frac{a_4}{3} T^3 + \\frac{a_5}{4} T^4 + a_7\n$$\n在这里，第七个系数 $a_7$ 被定义为积分常数 $C_2$。这同样是标准约定。问题要求的是 $s_k(T)$，在此上下文中指的是标准摩尔熵。为了获得以 $\\mathrm{J}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$ 为单位的 $s_k(T)$，我们乘以 $R$：\n$$\ns_k(T) = R \\left( a_1 \\ln(T) + a_2 T + \\frac{a_3}{2} T^2 + \\frac{a_4}{3} T^3 + \\frac{a_5}{4} T^4 + a_7 \\right)\n$$\n系数 $a_6$ 和 $a_7$ 是为每个温度范围专门选择的，以使函数 $h_k(T)$ 和 $s_k(T)$ 在断点温度 $T_{\\mathrm{mid}}$ 处是连续的。热容 $c_{p,k}(T)$ 也应是连续的。\n\n**4. 连续性验证**\n\n为了验证这些性质在断点 $T_{\\mathrm{mid}}$ 处的连续性，我们在 $T = T_{\\mathrm{mid}}$ 处同时使用低温系数 ($a_{i, \\text{low}}$) 和高温系数 ($a_{i, \\text{high}}$) 来计算这些值。\n\n令 $c_{p,\\text{low}}(T_\\text{mid})$、$h_{\\text{low}}(T_\\text{mid})$、$s_{\\text{low}}(T_\\text{mid})$ 为使用低温多项式系数计算的值，而 $c_{p,\\text{high}}(T_\\text{mid})$、$h_{\\text{high}}(T_\\text{mid})$、$s_{\\text{high}}(T_\\text{mid})$ 为使用高温系数计算的值。\n\n绝对不匹配值计算如下：\n$$\n\\Delta c_p = |c_{p,\\text{high}}(T_\\text{mid}) - c_{p,\\text{low}}(T_\\text{mid})|\n$$\n$$\n\\Delta h = |h_{\\text{high}}(T_\\text{mid}) - h_{\\text{low}}(T_\\text{mid})|\n$$\n$$\n\\Delta s = |s_{\\text{high}}(T_\\text{mid}) - s_{\\text{low}}(T_\\text{mid})|\n$$\n如果每个性质各自的不匹配值小于或等于指定的容差 $\\epsilon = 10^{-6}$，则该性质满足连续性。\n- 如果 $\\Delta c_p \\le \\epsilon$，$c_p$ 是连续的。\n- 如果 $\\Delta h \\le \\epsilon$，$h$ 是连续的。\n- 如果 $\\Delta s \\le \\epsilon$，$s$ 是连续的。\n\n实施过程将通过将这些推导出的公式编码到一个函数中，将其应用于每个组分所提供的测试用例，并报告连续性布尔值和不匹配值的大小来继续。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes thermodynamic properties using NASA 7-coefficient polynomials\n    and checks for continuity at the breakpoint temperature.\n    \"\"\"\n    R = 8.314462618  # J / (mol * K)\n\n    test_cases = [\n        {\n            \"name\": \"H2\",\n            \"T_mid\": 1000.0,\n            \"epsilon\": 1.0e-6,\n            \"low_coeffs\": [\n                2.34433112e+00, 7.98052075e-03, -1.94781510e-05,\n                2.01572094e-08, -7.37611761e-12, -9.17935173e+02,\n                6.83010238e-01\n            ],\n            \"high_coeffs\": [\n                3.33727920e+00, -4.94024731e-05, 4.99456778e-07,\n                -1.79566394e-10, 2.00255376e-14, -9.50158922e+02,\n                -3.20502331e+00\n            ],\n        },\n        {\n            \"name\": \"O2\",\n            \"T_mid\": 1000.0,\n            \"epsilon\": 1.0e-6,\n            \"low_coeffs\": [\n                3.78245636e+00, -2.99673416e-03, 9.84730201e-06,\n                -9.68129509e-09, 3.24372837e-12, -1.06394356e+03,\n                3.65767573e+00\n            ],\n            \"high_coeffs\": [\n                3.28253784e+00, 1.48308754e-03, -7.57966669e-07,\n                2.09470555e-10, -2.16717794e-14, -1.08845772e+03,\n                5.45323129e+00\n            ],\n        },\n        {\n            \"name\": \"H2O\",\n            \"T_mid\": 1000.0,\n            \"epsilon\": 1.0e-6,\n            \"low_coeffs\": [\n                4.19864056e+00, -2.03643410e-03, 6.52040211e-06,\n                -5.48797062e-09, 1.77197817e-12, -3.02937267e+04,\n                -8.49032208e-01\n            ],\n            \"high_coeffs\": [\n                3.03399249e+00, 2.17691804e-03, -1.64072518e-07,\n                -9.70419870e-11, 1.68200992e-14, -3.00042971e+04,\n                4.96677010e+00\n            ],\n        },\n        {\n            \"name\": \"CO2\",\n            \"T_mid\": 1000.0,\n            \"epsilon\": 1.0e-6,\n            \"low_coeffs\": [\n                2.35677352e+00, 8.98459677e-03, -7.12356269e-06,\n                2.45919022e-09, -1.43699548e-13, -4.83719697e+04,\n                9.90105222e+00\n            ],\n            \"high_coeffs\": [\n                3.85796028e+00, 4.41437026e-03, -2.21481404e-06,\n                5.23490188e-10, -4.72084164e-14, -4.87591660e+04,\n                2.27163806e+00\n            ],\n        },\n        {\n            \"name\": \"O2-mismatched\",\n            \"T_mid\": 1000.0,\n            \"epsilon\": 1.0e-6,\n            \"low_coeffs\": [\n                3.78245636e+00, -2.99673416e-03, 9.84730201e-06,\n                -9.68129509e-09, 3.24372837e-12, -1.06394356e+03,\n                3.65767573e+00\n            ],\n            # High-temp coeffs intentionally perturbed from O2\n            \"high_coeffs\": [\n                3.28353784e+00, 1.48308754e-03, -7.57966669e-07,\n                2.09470555e-10, -2.16717794e-14, -1.08845772e+03,\n                5.45323129e+00\n            ],\n        }\n    ]\n\n    def calculate_properties(T, coeffs, R_gas):\n        \"\"\"\n        Calculates cp, h, and s from NASA 7-coefficient polynomial.\n        Args:\n            T (float): Temperature in Kelvin.\n            coeffs (list or np.ndarray): Array of 7 coefficients {a1..a7}.\n            R_gas (float): Universal gas constant.\n        Returns:\n            tuple: (cp, h, s)\n        \"\"\"\n        a1, a2, a3, a4, a5, a6, a7 = coeffs\n        \n        T_powers = np.array([1.0, T, T**2, T**3, T**4])\n        \n        # Dimensionless heat capacity: cp/R = sum(a_i * T^(i-1)) for i=1 to 5\n        cp_over_R = np.dot(coeffs[:5], T_powers)\n        \n        # Dimensionless enthalpy: h/RT = ...\n        h_over_RT = (\n            a1 + a2 * T / 2.0 + a3 * T**2 / 3.0 +\n            a4 * T**3 / 4.0 + a5 * T**4 / 5.0 + a6 / T\n        )\n        \n        # Dimensionless entropy: s/R = ...\n        s_over_R = (\n            a1 * np.log(T) + a2 * T + a3 * T**2 / 2.0 +\n            a4 * T**3 / 3.0 + a5 * T**4 / 4.0 + a7\n        )\n\n        cp = R_gas * cp_over_R\n        h = R_gas * T * h_over_RT\n        s = R_gas * s_over_R\n        \n        return cp, h, s\n\n    results = []\n    for case in test_cases:\n        T_mid = case[\"T_mid\"]\n        epsilon = case[\"epsilon\"]\n        \n        # Calculate properties at T_mid using both sets of coefficients\n        cp_low, h_low, s_low = calculate_properties(T_mid, case[\"low_coeffs\"], R)\n        cp_high, h_high, s_high = calculate_properties(T_mid, case[\"high_coeffs\"], R)\n\n        # Calculate absolute mismatches\n        delta_cp = abs(cp_high - cp_low)\n        delta_h = abs(h_high - h_low)\n        delta_s = abs(s_high - s_low)\n\n        # Check for continuity within tolerance\n        cp_continuous = delta_cp = epsilon\n        h_continuous = delta_h = epsilon\n        s_continuous = delta_s = epsilon\n        \n        results.append([\n            cp_continuous, h_continuous, s_continuous,\n            delta_cp, delta_h, delta_s\n        ])\n    \n    # Format the final output string as a list of lists.\n    # The `map(str, ...)` will use Python's default string conversion for lists,\n    # which is a valid and standard representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在建立了物性计算的基础后，我们转向模拟的核心引擎：时间积分方法。本练习将探讨两种在DNS中广泛应用的时间推进策略：算子分裂法（如Strang分裂）和非分裂的隐式-显式（IMEX）方法 。通过在一个典型的反应-扩散问题中实现并比较这两种方案，你将能够亲手量化由算子分裂引入的“分裂误差”，从而深刻理解不同数值方法在求解复杂多尺度问题时的精度与效率权衡。",
            "id": "4019193",
            "problem": "考虑一个一维反应-扩散标量场，描述了在周期性域 $x \\in [0,L)$ 中单一物质的质量分数 $u(x,t)$，该场由无对流的物质守恒方程（源自 Fick 定律和体积反应源）控制：\n$$\n\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2} + \\omega(u),\n$$\n其中 $D$ 是恒定的扩散系数，$\\omega(u)$ 是反应源项。为了在与反应流直接数值模拟 (DNS) 相关的场景中分离算子分裂效应，使用非线性逻辑斯谛反应模型\n$$\n\\omega(u) = k\\,u\\,(1-u),\n$$\n其中 $k$ 是一个恒定的反应速率。在具有 $N$ 个点的均匀网格上，使用带有周期性边界条件的二阶中心有限差分对空间进行离散化，以使离散拉普拉斯算子与连续算子保持一致。初始条件为\n$$\nu(x,0) = u_0(x) = 0.2 + 0.1\\sin(2\\pi x/L).\n$$\n\n为该半离散系统实现两种时间积分策略：\n- 一种“非分裂”的隐式-显式 (IMEX) 格式，其中扩散项采用隐式处理，反应项采用显式处理，并使用二阶精度的 Crank–Nicolson 方法（用于扩散）和 Adams–Bashforth 方法（用于反应）的组合。使用与整体 IMEX 策略一致的第一步来初始化多步部分。确保在每个时间步长内，隐式算子的求解都精确且稳定。\n- 一种 Strang 分裂法（二阶算子分裂），通过组合一个纯扩散的半步、一个纯反应的整步以及最后一个纯扩散的半步来推进一个完整的时间步。对于扩散子步，采用与空间离散化一致的二阶精度隐式格式。对于反应子步，采用二阶精度显式方法来积分 $\\dot{u}=\\omega(u)$。\n\n对于每种方法，从相同的初始条件 $u_0(x)$ 和相同的空间离散化开始，计算从 $t=0$ 到最终时间 $T$ 的解。对于每个时间步长 $\\Delta t$，通过计算非分裂 IMEX 解 $u_{\\mathrm{IMEX}}(x,T)$ 与 Strang 分裂解 $u_{\\mathrm{Strang}}(x,T)$ 之间差分的离散 $L_2$ 范数来量化在 $t=T$ 时的分裂误差：\n$$\n\\|u_{\\mathrm{IMEX}}(\\cdot,T)-u_{\\mathrm{Strang}}(\\cdot,T)\\|_2 \\equiv \\left( \\int_0^L \\left[u_{\\mathrm{IMEX}}(x,T)-u_{\\mathrm{Strang}}(x,T)\\right]^2\\,dx \\right)^{1/2},\n$$\n并通过基于网格的 Riemann 和来近似该积分\n$$\n\\|u_{\\mathrm{IMEX}}(\\cdot,T)-u_{\\mathrm{Strang}}(\\cdot,T)\\|_{2,\\Delta x} \\equiv \\left( \\Delta x \\sum_{j=0}^{N-1} \\left[u_{\\mathrm{IMEX}}(x_j,T)-u_{\\mathrm{Strang}}(x_j,T)\\right]^2 \\right)^{1/2},\n$$\n其中 $x_j=j\\,\\Delta x$ 且 $\\Delta x=L/N$。\n\n使用以下科学上一致的参数，以确保计算的稳健性和代表性：\n- 域长度 $L=1$ (无量纲)。\n- 扩散系数 $D=0.01$ (无量纲)。\n- 反应速率 $k=1$ (无量纲)。\n- 网格大小 $N=256$ (均匀间距，周期性)。\n- 最终时间 $T=0.1$ (无量纲)。\n- 初始条件 $u_0(x)=0.2+0.1\\sin(2\\pi x/L)$。\n\n实现这两种方法，并针对以下每个时间步长 $\\Delta t$（所有步长都选择为可以整除 $T$），计算在 $t=T$ 时差分的离散 $L_2$ 范数：\n- $\\Delta t = 0.0025$,\n- $\\Delta t = 0.005$,\n- $\\Delta t = 0.01$,\n- $\\Delta t = 0.02$.\n\n所有量均为无量纲；将最终答案表示为无量纲浮点数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$\\texttt{[result1,result2,result3,result4]}$），其顺序与所列的 $\\Delta t$ 值相对应。计算必须是自包含的，并在没有外部输入的情况下执行所需的算子求解和更新。由这些 $\\Delta t$ 值定义的测试套件涵盖了典型情况、中到大时间步长的行为以及相对小时间步长的边缘情况。其目标是通过在相同的空间离散化和物理参数下比较非分裂解和 Strang 分裂解，揭示分裂误差对 $\\Delta t$ 的依赖性。",
            "solution": "该问题要求对一个一维反应-扩散方程进行数值求解，并比较两种不同的时间积分格式。控制物质质量分数 $u(x,t)$ 的偏微分方程 (PDE) 如下：\n$$\n\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2} + \\omega(u)\n$$\n在周期性域 $x \\in [0,L)$ 上。扩散系数 $D$ 和反应速率 $k$ 是常数。非线性反应源项由逻辑斯谛模型给出，即 $\\omega(u) = k\\,u\\,(1-u)$。初始条件指定为 $u(x,0) = u_0(x) = 0.2 + 0.1\\sin(2\\pi x/L)$。\n\n为了对该方程进行数值求解，我们首先进行空间离散化，将偏微分方程转换为一个常微分方程组 (ODEs)，这种方法被称为直线法。\n\n**1. 空间离散化与半离散系统**\n\n我们使用一个包含 $N$ 个点的均匀网格对空间域 $[0,L)$ 进行离散化，其中 $x_j = j \\Delta x$，$j=0, 1, \\dots, N-1$，网格间距为 $\\Delta x = L/N$。标量场 $u(x,t)$ 由一个向量 $\\mathbf{u}(t)$ 表示，其第 $j$ 个分量 $u_j(t)$ 近似于 $u(x_j, t)$。\n\n空间二阶导数，即拉普拉斯算子 $\\frac{\\partial^2}{\\partial x^2}$，使用二阶精度的中心有限差分格式进行近似。对于周期函数，作用于 $u_j$ 的离散拉普拉斯算子为：\n$$\n\\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_j \\approx \\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2}\n$$\n其中指数对 $N$ 取模以施加周期性。这种离散化可以表示为一个矩阵-向量乘积 $\\mathbf{L}\\mathbf{u}$，其中 $\\mathbf{L}$ 是离散拉普拉斯矩阵。\n\n于是，半离散的常微分方程组可以写为：\n$$\n\\frac{d\\mathbf{u}}{dt} = D \\mathbf{L} \\mathbf{u} + \\mathbf{\\Omega}(\\mathbf{u})\n$$\n其中 $(\\mathbf{\\Omega}(\\mathbf{u}))_j = \\omega(u_j) = k u_j (1-u_j)$。矩阵 $\\mathbf{L}$ 是一个循环矩阵。循环矩阵的一个关键性质是它们可以被离散傅里叶变换 (DFT) 对角化。这使得在傅里叶空间中可以高效地求解涉及 $\\mathbf{L}$ 的线性系统，在傅里叶空间中，矩阵乘法变为逐元素乘法。$\\mathbf{L}$ 的特征值由 $\\lambda_m = \\frac{2}{(\\Delta x)^2} (\\cos(2\\pi m/N) - 1)$ 给出，其中整数波数为 $m = 0, 1, \\dots, N-1$。\n\n**2. 非分裂 IMEX 格式 (Crank-Nicolson / Adams-Bashforth)**\n\n第一种方法是二阶精度的隐式-显式 (IMEX) 格式。刚性的扩散项 ($D \\mathbf{L} \\mathbf{u}$) 为保证稳定性而采用隐式处理，而非刚性的反应项 ($\\mathbf{\\Omega}(\\mathbf{u})$) 为提高效率而采用显式处理。我们对扩散项使用二阶 Crank-Nicolson (CN) 方法，对反应项使用二阶 Adams-Bashforth (AB2) 方法。从时间步 $n$ 到 $n+1$ 的更新公式为：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = D \\mathbf{L} \\left( \\frac{\\mathbf{u}^{n+1} + \\mathbf{u}^n}{2} \\right) + \\left( \\frac{3}{2} \\mathbf{\\Omega}(\\mathbf{u}^n) - \\frac{1}{2} \\mathbf{\\Omega}(\\mathbf{u}^{n-1}) \\right)\n$$\n为了求解 $\\mathbf{u}^{n+1}$，我们重排方程，将隐式项分离到左侧：\n$$\n\\left(\\mathbf{I} - \\frac{D \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^{n+1} = \\left(\\mathbf{I} + \\frac{D \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^n + \\Delta t \\left( \\frac{3}{2} \\mathbf{\\Omega}(\\mathbf{u}^n) - \\frac{1}{2} \\mathbf{\\Omega}(\\mathbf{u}^{n-1}) \\right)\n$$\n这是一个形如 $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$ 的线性系统，其中 $\\mathbf{x} = \\mathbf{u}^{n+1}$。使用 DFT（表示为 $\\mathcal{F}$），我们将此系统转换到傅里叶空间：\n$$\n\\mathcal{F}\\left\\{ \\left(\\mathbf{I} - \\frac{D \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^{n+1} \\right\\} = \\mathcal{F}\\left\\{ \\text{RHS} \\right\\}\n$$\n$$\n\\left(\\mathbf{I} - \\frac{D \\Delta t}{2} \\mathbf{\\Lambda}_L\\right) \\hat{\\mathbf{u}}^{n+1} = \\hat{\\mathbf{b}}\n$$\n其中 $\\hat{\\mathbf{u}} = \\mathcal{F}\\{\\mathbf{u}\\}$，$\\mathbf{\\Lambda}_L$ 是 $\\mathbf{L}$ 的特征值构成的对角矩阵，$\\hat{\\mathbf{b}}$ 是右端向量的 DFT。通过逐元素除法 $\\hat{u}_m^{n+1} = \\hat{b}_m / (1 - \\frac{D \\Delta t}{2}\\lambda_m)$ 求得解，然后通过逆 DFT 恢复 $\\mathbf{u}^{n+1} = \\mathcal{F}^{-1}\\{\\hat{\\mathbf{u}}^{n+1}\\}$。\n\n两步的 AB2 方法需要为第一个时间步设置一个特殊的启动程序。我们对反应项使用一阶向前欧拉法，尽管该单步仅为一阶精度，但这足以在时间 $T$ 维持全局解的整体二阶精度。第一步为：\n$$\n\\left(\\mathbf{I} - \\frac{D \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^{1} = \\left(\\mathbf{I} + \\frac{D \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^0 + \\Delta t \\mathbf{\\Omega}(\\mathbf{u}^0)\n$$\n\n**3. Strang 分裂格式**\n\n第二种方法是 Strang 分裂，一种二阶算子分裂技术。在一个时间步长 $\\Delta t$ 内的演化被分解为三个连续的子步：一个半步的扩散，一个整步的反应，以及最后一个半步的扩散。\n$$\n\\mathbf{u}^{n+1} = \\mathcal{D}(\\Delta t/2) \\circ \\mathcal{R}(\\Delta t) \\circ \\mathcal{D}(\\Delta t/2) (\\mathbf{u}^n)\n$$\n其中 $\\mathcal{D}(\\delta t)$ 是在时间间隔 $\\delta t$ 内求解纯扩散方程 $\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2}$ 的算子，而 $\\mathcal{R}(\\delta t)$ 是在 $\\delta t$ 内求解纯反应方程 $\\frac{du}{dt} = \\omega(u)$ 的算子。\n\n- **扩散子步 $\\mathcal{D}(\\delta t)$**：我们使用二阶隐式 Crank-Nicolson 方法。对于大小为 $\\delta t$ 的一个步长，更新公式为：\n  $$\n  \\left(\\mathbf{I} - \\frac{D \\delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^{\\text{new}} = \\left(\\mathbf{I} + \\frac{D \\delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^{\\text{old}}\n  $$\n  这个线性系统在傅里叶空间中被高效求解，与 IMEX 格式的隐式部分完全相同，只是将 $\\Delta t$ 替换为子步时长 $\\delta t = \\Delta t/2$。\n\n- **反应子步 $\\mathcal{R}(\\Delta t)$**：我们对每个网格点 $j$ 在一个时间步长 $\\Delta t$ 内求解常微分方程组 $\\frac{du_j}{dt} = k u_j(1-u_j)$。这是一个逻辑斯谛方程，它有精确的解析解：\n  $$\n  u_j(t) = \\frac{u_j(0)}{u_j(0) + (1-u_j(0))e^{-kt}}\n  $$\n  对反应子步使用此精确解提供的更新比任何标准的二阶显式数值方法都更精确，并避免了与反应项相关的任何潜在稳定性约束。\n\n完整的 Strang 分裂步包括：应用扩散算子进行 $\\Delta t/2$ 的演化，然后应用反应算子进行 $\\Delta t$ 的演化，最后再次应用扩散算子进行 $\\Delta t/2$ 的演化。\n\n**4. 误差计算与实现**\n\n对于每个指定的时间步长 $\\Delta t$，两种格式都从 $t=0$ 积分到最终时间 $T=0.1$。然后通过计算两种方法得到的最终解 $u_{\\mathrm{IMEX}}(x,T)$ 和 $u_{\\mathrm{Strang}}(x,T)$ 之间差分的离散 $L_2$ 范数来量化分裂误差：\n$$\n\\|u_{\\mathrm{IMEX}}(\\cdot,T)-u_{\\mathrm{Strang}}(\\cdot,T)\\|_{2,\\Delta x} \\equiv \\left( \\Delta x \\sum_{j=0}^{N-1} \\left[u_{\\mathrm{IMEX}}(x_j,T)-u_{\\mathrm{Strang}}(x_j,T)\\right]^2 \\right)^{1/2}\n$$\n对 $\\Delta t \\in \\{0.0025, 0.005, 0.01, 0.02\\}$ 进行计算。由于两种格式都是二阶精度的，它们的差值主要由 Strang 方法的分裂误差决定，预计将与 $(\\Delta t)^2$ 成比例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Computes and compares solutions of a 1D reaction-diffusion equation\n    using an unsplit IMEX scheme and a Strang splitting scheme.\n    \"\"\"\n    \n    # Define physical and numerical parameters from the problem statement.\n    L = 1.0       # Domain length\n    D = 0.01      # Diffusivity\n    k = 1.0       # Reaction rate\n    N = 256       # Grid size\n    T = 0.1       # Final time\n\n    # List of time step sizes to test\n    test_cases = [0.0025, 0.005, 0.01, 0.02]\n\n    # --- Setup common to all simulations ---\n    dx = L / N\n    x = np.arange(N) * dx\n    \n    # Initial condition u(x,0)\n    u0 = 0.2 + 0.1 * np.sin(2 * np.pi * x / L)\n\n    # Pre-compute eigenvalues of the discrete Laplacian operator for FFT-based solver.\n    # Wavenumber modes for the DFT.\n    modes = fft.fftfreq(N, d=1.0) * N\n    # Eigenvalues of the second-order central difference Laplacian matrix.\n    lap_eig = (2 / dx**2) * (np.cos(2 * np.pi * modes / N) - 1)\n\n    def reaction_term_func(u_vec):\n        \"\"\"Computes the logistic reaction term omega(u) = k*u*(1-u).\"\"\"\n        return k * u_vec * (1 - u_vec)\n\n    def run_imex(dt):\n        \"\"\"\n        Solves the system using the second-order IMEX scheme:\n        Crank-Nicolson for diffusion (implicit) and Adams-Bashforth for reaction (explicit).\n        \"\"\"\n        u = u0.copy()\n        num_steps = int(round(T / dt))\n        omega_prev = None\n\n        # Pre-compute operators in Fourier space for the implicit solve.\n        # This corresponds to the inverse of the matrix (I - D*dt/2 * L) in Fourier space.\n        imex_implicit_inv_op_hat = 1.0 / (1.0 - D * dt / 2.0 * lap_eig)\n        # This corresponds to the matrix (I + D*dt/2 * L) in Fourier space.\n        imex_explicit_op_hat = 1.0 + D * dt / 2.0 * lap_eig\n\n        for n in range(num_steps):\n            omega_curr = reaction_term_func(u)\n            \n            if n == 0:\n                # First step: Use first-order Forward Euler for the reaction term.\n                # This is a standard startup for a multi-step method.\n                explicit_reaction_part = dt * omega_curr\n            else:\n                # Subsequent steps: Use second-order Adams-Bashforth for the reaction.\n                explicit_reaction_part = dt * (1.5 * omega_curr - 0.5 * omega_prev)\n            \n            omega_prev = omega_curr\n\n            # Construct the full right-hand side (RHS) of the linear system.\n            # The diffusion part is calculated in Fourier space for precision.\n            diffusion_rhs = np.real(fft.ifft(imex_explicit_op_hat * fft.fft(u)))\n            rhs = diffusion_rhs + explicit_reaction_part\n            \n            # Solve for the next time step u^{n+1} in Fourier space.\n            rhs_hat = fft.fft(rhs)\n            u_next_hat = rhs_hat * imex_implicit_inv_op_hat\n            u = np.real(fft.ifft(u_next_hat))\n\n        return u\n\n    def run_strang(dt):\n        \"\"\"\n        Solves the system using second-order Strang splitting:\n        D(dt/2) - R(dt) - D(dt/2).\n        \"\"\"\n        u = u0.copy()\n        num_steps = int(round(T / dt))\n        \n        # --- Define sub-step operators ---\n\n        # Diffusion sub-step operator for a duration of dt/2.\n        # This is one Crank-Nicolson step.\n        dt_half = dt / 2.0\n        # The implicit operator corresponds to (I - D*(dt/2)/2 * L)^-1.\n        strang_implicit_inv_op_hat = 1.0 / (1.0 - D * dt_half / 2.0 * lap_eig)\n        # The explicit operator corresponds to (I + D*(dt/2)/2 * L).\n        strang_explicit_op_hat = 1.0 + D * dt_half / 2.0 * lap_eig\n        \n        def diffusion_substep(u_in):\n            \"\"\"Applies Crank-Nicolson for a half time step.\"\"\"\n            u_in_hat = fft.fft(u_in)\n            # Combine explicit and implicit parts in one multiplication\n            u_out_hat = u_in_hat * strang_explicit_op_hat * strang_implicit_inv_op_hat\n            return np.real(fft.ifft(u_out_hat))\n\n        def reaction_substep(u_in):\n            \"\"\"Applies the exact solution of the logistic ODE for a full time step.\"\"\"\n            # Use a small floor to prevent division by zero if u_in is exactly 0.\n            u_in_safe = np.where(u_in == 0, 1e-16, u_in)\n            return u_in_safe / (u_in_safe + (1 - u_in_safe) * np.exp(-k * dt))\n\n        # --- Main time-stepping loop ---\n        for _ in range(num_steps):\n            # Apply the three stages of Strang splitting\n            u = diffusion_substep(u)   # 1. Half-step diffusion\n            u = reaction_substep(u)    # 2. Full-step reaction\n            u = diffusion_substep(u)   # 3. Half-step diffusion\n            \n        return u\n\n    results = []\n    for dt in test_cases:\n        # Run both simulations for the current time step dt\n        u_final_imex = run_imex(dt)\n        u_final_strang = run_strang(dt)\n        \n        # Compute the discrete L2 norm of the difference between the two solutions.\n        diff_sq = (u_final_imex - u_final_strang)**2\n        l2_norm_of_difference = np.sqrt(dx * np.sum(diff_sq))\n        results.append(l2_norm_of_difference)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "数值模拟的实践中充满了挑战，其中之一便是确保计算结果的物理真实性。由于离散误差，计算出的组分质量分数 $Y_k$ 可能出现小于零或总和不为1的非物实现象，这会严重影响模拟的稳定性和准确性。本练习  聚焦于一个关键的数值鲁棒性技术：将非物理的组分向量投影到“概率单纯形”上，从而强制保证质量分数的守恒性和非负性，这是开发稳定可靠的DNS求解器的必备技能。",
            "id": "4019173",
            "problem": "考虑一个为多组分混合物的直接数值模拟 (DNS) 而离散化的反应流，其中每个计算网格都包含组分质量分数 $Y_k$，$k \\in \\{1,\\dots,N_s\\}$，$N_s$ 表示化学物质的种类数量。根据质量守恒和组分质量分数的定义，物理上可实现的状态必须满足对所有 $k$ 都有 $Y_k \\ge 0$ 以及 $\\sum_{k=1}^{N_s} Y_k = 1$。容许集是概率单纯形 $\\mathcal{S} = \\{ \\mathbf{y} \\in \\mathbb{R}^{N_s} \\mid y_k \\ge 0, \\sum_{k=1}^{N_s} y_k = 1 \\}$。由平流、扩散和反应源项的离散化引起的数值扩散和色散，可能会导致可实现性的违例，例如出现 $Y_k  0$、在其他组分为负值时某些组分 $Y_k  1$，或者 $\\sum_{k=1}^{N_s} Y_k \\neq 1$。\n\n您的任务是量化一个给定的 $\\mathbf{Y}$ 与单纯形的偏差，并应用一种局部重正化方法来恢复其可实现性。使用一个基于到单纯形的欧几里得距离的偏差度量，对于任意 $\\mathbf{y} \\in \\mathbb{R}^{N_s}$，该度量定义为 $d(\\mathbf{y}) = \\left\\| \\mathbf{y} - \\mathbf{y}^\\star \\right\\|_2$，其中 $\\mathbf{y}^\\star$ 是 $\\mathbf{y}$ 在 $\\mathcal{S}$ 上的欧几里得投影。局部重正化算子 $\\mathcal{R}$ 必须将 $\\mathbf{y}$ 映射到 $\\mathbf{y}^\\star \\in \\mathcal{S}$，使得对所有 $k$ 都有 $0 \\le y^\\star_k \\le 1$ 且 $\\sum_{k=1}^{N_s} y_k^\\star = 1$。该实现必须对小的负值违例和大的过冲保持数值稳定。\n\n从适用于计算燃烧学和反应流DNS的基本定律和核心定义出发：质量守恒、组分质量分数的定义以及单纯形的性质。除了从第一性原理和标准凸优化最优性条件推导出的公式外，不要使用任何快捷公式。\n\n实现一个程序，该程序：\n- 为每个测试用例中的每个网格计算 $d(\\mathbf{y})$。\n- 通过投影到 $\\mathcal{S}$上来应用局部重正化 $\\mathcal{R}$。\n- 计算每个测试用例的总偏差减少量，其定义为该测试用例中所有网格的 $d(\\mathbf{y})$ 之和减去所有网格的 $d(\\mathcal{R}(\\mathbf{y}))$ 之和（在精确计算中应为零）。\n\n测试套件包含四个测试用例，每个用例包含多个网格。每个网格是一个组分质量分数的向量：\n- 测试用例 1 (有效和边界可实现状态，$N_s = 4$，三个网格)：\n  - $\\mathbf{y}^{(1)} = [0.1, 0.2, 0.3, 0.4]$\n  - $\\mathbf{y}^{(2)} = [0.0, 0.0, 1.0, 0.0]$\n  - $\\mathbf{y}^{(3)} = [10^{-15}, 0.5, 0.5 - 10^{-15}, 0.0]$\n- 测试用例 2 (轻微违例和求和误差，$N_s = 4$，三个网格)：\n  - $\\mathbf{y}^{(1)} = [0.2, -10^{-8}, 0.5, 0.3 + 10^{-8}]$\n  - $\\mathbf{y}^{(2)} = [0.25, 0.25, 0.25, 0.26]$\n  - $\\mathbf{y}^{(3)} = [-10^{-12}, 0.6, 0.4, 10^{-12}]$\n- 测试用例 3 (严重过冲和负值，$N_s = 5$，两个网格)：\n  - $\\mathbf{y}^{(1)} = [1.2, -0.1, -0.05, -0.05, 0.0]$\n  - $\\mathbf{y}^{(2)} = [0.8, 0.3, -0.1, 0.0, 0.0]$\n- 测试用例 4 (非负组分的强求和偏差，$N_s = 3$，两个网格)：\n  - $\\mathbf{y}^{(1)} = [0.4, 0.4, 0.4]$\n  - $\\mathbf{y}^{(2)} = [0.3, 0.3, 0.3]$\n\n所有量均为无量纲。不使用角度。您的程序应生成单行输出，其中包含每个测试用例的总偏差减少量，表示为保留六位小数的浮点数列表，格式严格为：\"[r1,r2,r3,r4]\"。\n\n您的实现必须是自包含的，且不要求任何用户输入。该算法对于给定的测试套件应具有鲁棒性和高效率，并应反映出从质量守恒、$Y_k$的定义和概率单纯形出发的推导逻辑。",
            "solution": "该问题要求开发一个程序，对组分质量分数向量 $\\mathbf{Y}$ 强制施加物理可实现性。在反应流的直接数值模拟 (DNS) 过程中，这些向量可能会因数值误差而损坏。该任务的核心是将一个任意向量 $\\mathbf{y} \\in \\mathbb{R}^{N_s}$ 投影到标准单纯形（或称概率单纯形）$\\mathcal{S}$ 上。\n\n根据质量守恒的基本原理和质量分数的定义，一个物理可实现的状态 $\\mathbf{Y}$ 必须位于单纯形 $\\mathcal{S}$ 内，其定义为：\n$$\n\\mathcal{S} = \\left\\{ \\mathbf{x} \\in \\mathbb{R}^{N_s} \\mid \\sum_{k=1}^{N_s} x_k = 1, \\text{ and } x_k \\ge 0 \\text{ for all } k=1, \\dots, N_s \\right\\}\n$$\n问题指定使用欧几里得投影将给定向量 $\\mathbf{y}$ 映射到其在单纯形 $\\mathcal{S}$ 上的最近点 $\\mathbf{y}^\\star$。偏差随后通过欧几里得距离 $d(\\mathbf{y}) = \\| \\mathbf{y} - \\mathbf{y}^\\star \\|_2$ 来量化。因此，重正化算子为 $\\mathcal{R}(\\mathbf{y}) = \\mathbf{y}^\\star$。\n\n这个投影可以被表述为一个约束二次优化问题。我们寻求找到一个向量 $\\mathbf{x}$，它能够最小化与 $\\mathbf{y}$ 的欧几里得距离的平方，同时受限于定义单纯形的约束条件：\n$$\n\\begin{aligned}\n\\text{minimize} \\quad  f(\\mathbf{x}) = \\frac{1}{2} \\| \\mathbf{x} - \\mathbf{y} \\|_2^2 = \\frac{1}{2} \\sum_{k=1}^{N_s} (x_k - y_k)^2 \\\\\n\\text{subject to} \\quad  \\sum_{k=1}^{N_s} x_k = 1 \\\\\n\\text{and} \\quad  x_k \\ge 0, \\quad k=1, \\dots, N_s\n\\end{aligned}\n$$\n这是一个凸优化问题，因为目标函数是严格凸的，且可行集 $\\mathcal{S}$ 是凸集。因此，Karush-Kuhn-Tucker (KKT) 条件对于确定唯一的优化解 $\\mathbf{x}^\\star = \\mathbf{y}^\\star$ 既是必要条件也是充分条件。\n\n为应用 KKT 条件，我们首先构建该问题的拉格朗日函数：\n$$\nL(\\mathbf{x}, \\lambda, \\boldsymbol{\\mu}) = \\frac{1}{2} \\sum_{k=1}^{N_s} (x_k - y_k)^2 - \\lambda \\left( \\sum_{k=1}^{N_s} x_k - 1 \\right) - \\sum_{k=1}^{N_s} \\mu_k x_k\n$$\n在此，$\\lambda$ 是等式约束的拉格朗日乘子，而 $\\boldsymbol{\\mu} = (\\mu_1, \\dots, \\mu_{N_s})$ 是非负性不等式约束的拉格朗日乘子。\n\n最优解 $\\mathbf{x}^\\star$ 的 KKT 条件如下：\n$1$. **平稳性**：拉格朗日函数关于 $\\mathbf{x}$ 的梯度在 $\\mathbf{x}^\\star$ 处必须为零：\n$$\n\\frac{\\partial L}{\\partial x_k} = (x_k^\\star - y_k) - \\lambda - \\mu_k = 0 \\quad \\implies \\quad x_k^\\star = y_k + \\lambda + \\mu_k\n$$\n$2$. **原始可行性**：解 $\\mathbf{x}^\\star$ 必须满足原始约束：\n$$\n\\sum_{k=1}^{N_s} x_k^\\star = 1 \\quad \\text{and} \\quad x_k^\\star \\ge 0\n$$\n$3$. **对偶可行性**：不等式乘子必须为非负：\n$$\n\\mu_k \\ge 0\n$$\n$4$. **互补松弛性**：每个不等式乘子与其对应约束表达式的乘积必须为零：\n$$\n\\mu_k x_k^\\star = 0\n$$\n根据互补松弛性条件，对于每个分量 $k$，要么 $x_k^\\star = 0$，要么 $\\mu_k = 0$。\n- 如果 $x_k^\\star  0$，那么必须有 $\\mu_k = 0$。根据平稳性条件，这意味着 $x_k^\\star = y_k + \\lambda$。\n- 如果 $x_k^\\star = 0$，那么 $\\mu_k \\ge 0$ 是可能的。根据平稳性，有 $0 = y_k + \\lambda + \\mu_k$，这意味着 $\\mu_k = - (y_k + \\lambda)$。对偶可行性条件 $\\mu_k \\ge 0$ 则要求 $y_k + \\lambda \\le 0$。\n\n让我们定义一个标量 $\\theta = -\\lambda$。这样我们就可以将这两种情况合并成一个简洁的表达式。条件 $x_k^\\star = y_k + \\lambda$ 变为 $x_k^\\star = y_k - \\theta$，而条件 $y_k + \\lambda \\le 0$ 变为 $y_k - \\theta \\le 0$。\n这使我们能够将最优解按分量表示为：\n$$\nx_k^\\star = \\max(0, y_k - \\theta)\n$$\n这个表达式巧妙地同时强制了非负性以及从平稳性和互补松弛性条件中导出的关系。剩下的任务是确定未知的标量 $\\theta$。这可以通过施加最后一个未满足的约束，即原始可行性条件 $\\sum_{k=1}^{N_s} x_k^\\star = 1$ 来完成：\n$$\n\\sum_{k=1}^{N_s} \\max(0, y_k - \\theta) = 1\n$$\n让我们定义一个函数 $g(\\theta) = \\sum_{k=1}^{N_s} \\max(0, y_k - \\theta)$。这个函数是连续的、分段线性的且单调非增的。保证存在一个唯一的 $\\theta$ 值能够解 $g(\\theta) = 1$。\n\n对 $\\theta$ 的直接搜索可以变得非常高效。让我们将输入向量 $\\mathbf{y}$ 的分量按降序排序：$y_{(1)} \\ge y_{(2)} \\ge \\dots \\ge y_{(N_s)}$。函数 $g(\\theta)$ 仅在 $\\theta = y_{(i)}$ 的值处改变其线性形式。假设我们找到了一个索引 $\\rho \\in \\{1, \\dots, N_s\\}$，使得对于最优的 $\\theta$，当 $k \\le \\rho$ 时有 $y_{(k)} - \\theta  0$，当 $k  \\rho$ 时有 $y_{(k)} - \\theta \\le 0$。那么求和式变为：\n$$\n\\sum_{k=1}^{\\rho} (y_{(k)} - \\theta) = 1\n$$\n解出 $\\theta$ 得：\n$$\n\\theta = \\frac{1}{\\rho} \\left( \\sum_{k=1}^{\\rho} y_{(k)} - 1 \\right)\n$$\n正确的索引 $\\rho$ 是满足条件 $y_{(j)} - \\theta_j  0$ 的最大整数 $j$，其中 $\\theta_j$ 是使用前 $j$ 个分量计算出的 $\\theta$ 值。这引出了一个高效的算法：\n\n$1$. 对输入向量 $\\mathbf{y}$ 进行排序得到 $\\mathbf{u}$，使得 $u_1 \\ge u_2 \\ge \\dots \\ge u_{N_s}$。\n$2$. 计算 $\\mathbf{u}$ 的累积和，记为 $\\text{csum}_j = \\sum_{i=1}^j u_i$。\n$3$. 找到最大的索引 $\\rho \\in \\{1, \\dots, N_s\\}$，使其满足 $u_\\rho - \\frac{1}{\\rho}(\\text{csum}_\\rho - 1)  0$。\n$4$. 利用这个 $\\rho$，计算最优阈值 $\\theta = \\frac{1}{\\rho}(\\text{csum}_\\rho - 1)$。\n$5$. 然后使用原始（未排序）的向量 $\\mathbf{y}$ 计算投影向量 $\\mathbf{y}^\\star$：$y_k^\\star = \\max(0, y_k - \\theta)$，其中 $k=1, \\dots, N_s$。\n\n一旦计算出 $\\mathbf{y}^\\star$，单个网格的偏差为 $d(\\mathbf{y}) = \\| \\mathbf{y} - \\mathbf{y}^\\star \\|_2$。一个测试用例的总偏差减少量是该用例中所有网格的这些偏差之和，因为根据定义，投影点与单纯形的偏差为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases, compute projections, and report results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: valid and boundary realizable states\n        [\n            [0.1, 0.2, 0.3, 0.4],\n            [0.0, 0.0, 1.0, 0.0],\n            [1e-15, 0.5, 0.5 - 1e-15, 0.0]\n        ],\n        # Test Case 2: mild violations and sum errors\n        [\n            [0.2, -1e-8, 0.5, 0.3 + 1e-8],\n            [0.25, 0.25, 0.25, 0.26],\n            [-1e-12, 0.6, 0.4, 1e-12]\n        ],\n        # Test Case 3: severe overshoots and negativity\n        [\n            [1.2, -0.1, -0.05, -0.05, 0.0],\n            [0.8, 0.3, -0.1, 0.0, 0.0]\n        ],\n        # Test Case 4: strong sum deviations with nonnegative components\n        [\n            [0.4, 0.4, 0.4],\n            [0.3, 0.3, 0.3]\n        ]\n    ]\n\n    def project_to_simplex(y_in: np.ndarray) - np.ndarray:\n        \"\"\"\n        Projects a vector y_in onto the probability simplex.\n\n        The algorithm is derived from the KKT conditions for the Euclidean\n        projection onto the simplex, which results in finding a threshold\n        theta such that the projection is given by max(0, y - theta).\n\n        Args:\n            y_in: A 1D numpy array of species mass fractions.\n\n        Returns:\n            A 1D numpy array representing the projected vector on the simplex.\n        \"\"\"\n        n_s = len(y_in)\n        \n        # Vectors already on the simplex are common and can be checked quickly.\n        # This also handles the trivial case Ns=1 where y must be [1.0].\n        if np.all(y_in = 0) and np.isclose(np.sum(y_in), 1.0):\n            return y_in.copy()\n            \n        # Sort y in descending order.\n        u = np.sort(y_in)[::-1]\n        \n        # Compute cumulative sums.\n        cssv = np.cumsum(u)\n        \n        # Find the largest index rho for which the condition holds.\n        # The condition u_j - (1/j)(cssv_j - 1)  0 simplifies to\n        # j * u_j  cssv_j - 1 to avoid division inside the loop.\n        # We search from j=1 to Ns. In 0-based indexing, this is i=0 to Ns-1.\n        # 'indices' will contain all 0-based indices i that satisfy the condition.\n        indices = np.nonzero(u * np.arange(1, n_s + 1)  cssv - 1)[0]\n        \n        # The largest index rho corresponds to the last element in 'indices'.\n        rho_idx = indices[-1]\n        rho = rho_idx + 1\n        \n        # Compute the threshold theta.\n        theta = (cssv[rho_idx] - 1) / rho\n        \n        # Apply the threshold to the original vector.\n        y_star = np.maximum(0, y_in - theta)\n        \n        return y_star\n\n    total_reductions = []\n    for case in test_cases:\n        total_deviation_for_case = 0.0\n        for y_list in case:\n            y_vec = np.array(y_list, dtype=np.float64)\n            \n            # Project the vector onto the simplex.\n            y_star = project_to_simplex(y_vec)\n            \n            # Calculate the deviation d(y) = ||y - y*||_2. The deviation\n            # reduction is d(y) - d(y*), and since y* is on the simplex,\n            # its own projection is itself, so d(y*) = ||y* - y*||_2 = 0.\n            # Thus, the reduction is simply d(y).\n            deviation = np.linalg.norm(y_vec - y_star)\n            \n            total_deviation_for_case += deviation\n            \n        total_reductions.append(total_deviation_for_case)\n\n    # Format the final output string exactly as required.\n    formatted_results = [f\"{r:.6f}\" for r in total_reductions]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}