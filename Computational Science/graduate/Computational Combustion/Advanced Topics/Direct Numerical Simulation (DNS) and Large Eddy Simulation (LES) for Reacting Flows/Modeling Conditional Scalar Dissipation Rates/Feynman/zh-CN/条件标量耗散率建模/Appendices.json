{
    "hands_on_practices": [
        {
            "introduction": "这个练习将标量耗散率的抽象概念置于一个具体的计算任务中。我们将从一个给定的标量场出发，通过数值方法计算其耗散率，并验证一个基本的守恒定律。这项实践旨在建立对标量耗散率物理意义的直观理解，并培养在离散网格上计算梯度和执行空间平均等基本计算技能。",
            "id": "4041978",
            "problem": "给定一个三维周期性域，其中一个被动标量场 $ \\phi(\\mathbf{x}, t) $ 根据一个具有恒定分子扩散系数 $ D_\\phi $ 的纯扩散模型演化。该标量输运方程是没有平流和源项的扩散方程。标量耗散率基于脉动场 $ \\phi'(\\mathbf{x}, t) $ 进行建模，该脉动场定义为与瞬时空间平均值的偏差。您的任务是计算空间平均标量耗散率，从时间序列数据中估计标量方差的衰减率，并通过对标量场值进行分箱来检验条件公式。\n\n使用的基本原理：\n- 具有恒定扩散系数的被动标量的扩散方程：在周期性边界条件且无源项的情况下，标量的时间变化率取决于标量的拉普拉斯算子。\n- 脉动场为 $ \\phi'(\\mathbf{x}, t) = \\phi(\\mathbf{x}, t) - \\langle \\phi(\\cdot, t) \\rangle $，其中 $ \\langle \\cdot \\rangle $ 表示在固定时间对整个域的空间平均。\n- 与脉动相关的标量耗散率定义为 $ \\chi_\\phi(\\mathbf{x}, t) = 2 D_\\phi \\left\\|\\nabla \\phi'(\\mathbf{x}, t)\\right\\|^2 $。\n- 给定标量值的条件标量耗散率是条件期望 $ \\langle \\chi_\\phi \\mid \\phi' \\in \\mathcal{B}_i \\rangle $，其中 $ \\mathcal{B}_i $ 是 $ \\phi' $ 值域中的一个分箱，无条件平均通过对条件期望关于 $ \\phi' $ 的概率密度（离散化为分箱上的概率质量）进行积分来恢复。\n\n计算要求：\n- 在所有三个方向上使用带有周期性边界条件的均匀笛卡尔网格。\n- 使用带有周期性环绕的中心有限差分来近似空间梯度。\n- 对时间序列上的方差使用时间中心差分，以估计中間时刻的瞬时衰减率。\n- 对于条件建模，在中间时刻将 $ \\phi'(\\mathbf{x}, t) $ 的范围划分为 $ 8 $ 个等宽分箱，计算 $ \\chi_\\phi $ 的条件平均值，然后计算这些条件平均值的分箱概率加权积分（离散和）。\n\n单位与报告：\n- 扩散系数 $ D_\\phi $ 的单位是 $ \\mathrm{m}^2/\\mathrm{s} $，距离单位是 $ \\mathrm{m} $，时间单位是 $ \\mathrm{s} $。标量耗散率 $ \\chi_\\phi $ 及其空间平均的单位是 $ \\mathrm{s}^{-1} $。\n- 您的输出必须以 $ \\mathrm{s}^{-1} $ 为单位报告。\n- 程序必须生成单行输出，格式为逗号分隔的类Python列表，每个测试用例包含一个子列表。每个子列表必须按以下顺序包含五个浮点数：中间时刻的空间平均耗散率、从时间序列中估计的中间时刻方差衰减率、这两个量之间的绝对差、条件积分估计值（条件耗散的概率加权积分），以及条件积分估计值与无条件平均值之间的绝对差。最终输出必须是形式为 $ [ [r_{1,1}, r_{1,2}, r_{1,3}, r_{1,4}, r_{1,5}], [r_{2,1}, \\dots], \\dots ] $ 的单行字符串，不含空格。\n\n测试套件和域/模型规范：\n对于每个案例，定义一个长度为 $ (L_x, L_y, L_z) $ 的周期性域，由 $ (N_x, N_y, N_z) $ 个网格点离散化，一个恒定的扩散系数 $ D_\\phi $，一个时间步长 $ \\Delta t $，以及一个由余弦模态之和加上一个偏移量构成的标量场。每个余弦模态的形式为 $ A \\cos(\\mathbf{k} \\cdot \\mathbf{x}) $，其中 $ \\mathbf{k} = \\left( \\frac{2\\pi n_x}{L_x}, \\frac{2\\pi n_y}{L_y}, \\frac{2\\pi n_z}{L_z} \\right) $，并在扩散作用下演化，使得在时间 $ t $ 时每个模态的振幅乘以 $ \\exp\\left( - D_\\phi \\|\\mathbf{k}\\|^2 t \\right) $。偏移量是加到场上的一个常数，不会因扩散而衰减。对于每个案例，使用此演化定律在时间 $ t = 0 $、$ t = \\Delta t $ 和 $ t = 2 \\Delta t $ 构建标量场 $ \\phi(\\mathbf{x}, t) $。计算在 $ t = \\Delta t $ 时的空间平均耗散，并使用应用于三个时间层级的中心时间差分来估计在 $ t = \\Delta t $ 时标量方差的衰减率。\n\n提供以下四个测试用例：\n- 案例1（单波数分量）：\n  - 域长度：$ (L_x, L_y, L_z) = (1.0, 1.0, 1.0) $ $ \\mathrm{m} $。\n  - 网格点数：$ (N_x, N_y, N_z) = (32, 32, 32) $。\n  - 扩散系数：$ D_\\phi = 1.0 \\times 10^{-4} $ $ \\mathrm{m}^2/\\mathrm{s} $。\n  - 时间步长：$ \\Delta t = 0.05 $ $ \\mathrm{s} $。\n  - 偏移量：$ 0.0 $。\n  - 模态：$ A = 1.0 $，$ (n_x, n_y, n_z) \\in \\{ (1, 0, 0), (0, 1, 0), (0, 0, 1) \\} $。\n- 案例2（具有非零均值的多波数分量）：\n  - 域长度：$ (L_x, L_y, L_z) = (2.0, 2.0, 2.0) $ $ \\mathrm{m} $。\n  - 网格点数：$ (N_x, N_y, N_z) = (40, 40, 40) $。\n  - 扩散系数：$ D_\\phi = 5.0 \\times 10^{-4} $ $ \\mathrm{m}^2/\\mathrm{s} $。\n  - 时间步长：$ \\Delta t = 0.02 $ $ \\mathrm{s} $。\n  - 偏移量：$ 0.5 $。\n  - 模态：$ (A, n_x, n_y, n_z) \\in \\{ (0.7, 1, 2, 0), (0.3, 0, 1, 3) \\} $。\n- 案例3（均匀场）：\n  - 域长度：$ (L_x, L_y, L_z) = (1.0, 1.0, 1.0) $ $ \\mathrm{m} $。\n  - 网格点数：$ (N_x, N_y, N_z) = (16, 16, 16) $。\n  - 扩散系数：$ D_\\phi = 1.0 \\times 10^{-3} $ $ \\mathrm{m}^2/\\mathrm{s} $。\n  - 时间步长：$ \\Delta t = 0.1 $ $ \\mathrm{s} $。\n  - 偏移量：$ 2.0 $。\n  - 模态：无。\n- 案例4（各向异性域和混合模态）：\n  - 域长度：$ (L_x, L_y, L_z) = (1.0, 1.5, 0.5) $ $ \\mathrm{m} $。\n  - 网格点数：$ (N_x, N_y, N_z) = (24, 36, 12) $。\n  - 扩散系数：$ D_\\phi = 2.0 \\times 10^{-4} $ $ \\mathrm{m}^2/\\mathrm{s} $。\n  - 时间步长：$ \\Delta t = 0.03 $ $ \\mathrm{s} $。\n  - 偏移量：$ 0.1 $。\n  - 模态：$ (A, n_x, n_y, n_z) \\in \\{ (0.8, 2, 1, 0), (0.5, 0, 3, 2) \\} $。\n\n为每个案例实施的算法步骤：\n- 使用上述模态演化方法，在指定网格上构建时间 $ t = 0 $、$ t = \\Delta t $ 和 $ t = 2 \\Delta t $ 时的标量场 $ \\phi(\\mathbf{x}, t) $。\n- 通过减去 $ t = \\Delta t $ 时的空间平均值，计算脉动场 $ \\phi'(\\mathbf{x}, \\Delta t) $。\n- 使用中心有限差分（带周期性环绕）和网格间距 $ \\Delta x = L_x/N_x $, $ \\Delta y = L_y/N_y $, $ \\Delta z = L_z/N_z $ 来近似 $ \\nabla \\phi'(\\mathbf{x}, \\Delta t) $。\n- 逐点计算 $ \\chi_\\phi(\\mathbf{x}, \\Delta t) = 2 D_\\phi \\left( \\left( \\partial \\phi'/\\partial x \\right)^2 + \\left( \\partial \\phi'/\\partial y \\right)^2 + \\left( \\partial \\phi'/\\partial z \\right)^2 \\right) $，然后通过在网格上平均来计算空间平均值 $ \\langle \\chi_\\phi \\rangle $。\n- 计算 $ t = 0 $、$ t = \\Delta t $ 和 $ t = 2 \\Delta t $ 时的标量方差 $ \\langle \\phi'^2 \\rangle(t) $，然后使用中心差分 $ - \\left( \\langle \\phi'^2 \\rangle(2\\Delta t) - \\langle \\phi'^2 \\rangle(0) \\right) / (2 \\Delta t) $ 估计 $ t = \\Delta t $ 时的瞬时衰减率。\n- 构建 $ 8 $ 个覆盖 $ [ \\min \\phi'(\\mathbf{x}, \\Delta t), \\max \\phi'(\\mathbf{x}, \\Delta t) ] $ 范围的等宽分箱。对于每个分箱 $ \\mathcal{B}_i $，计算条件平均值 $ \\langle \\chi_\\phi \\mid \\phi' \\in \\mathcal{B}_i \\rangle $ 和分箱概率 $ p_i $。形成概率加权积分（离散和）$ \\sum_i p_i \\langle \\chi_\\phi \\mid \\phi' \\in \\mathcal{B}_i \\rangle $，并报告该值及其与无条件平均值的绝对差。\n- 将所有报告的率以浮点数形式表示，单位为 $ \\mathrm{s}^{-1} $。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含上述指定顺序的五个浮点数的子列表。例如，输出应类似于 $ [[r_{1,1},r_{1,2},r_{1,3},r_{1,4},r_{1,5}],[r_{2,1},r_{2,2},r_{2,3},r_{2,4},r_{2,5}],\\dots] $，不含空格。",
            "solution": "用户希望解决一个计算物理问题，该问题涉及三维周期性域中被动标量的扩散。此问题要求实现输运现象和数据分析中的若干数值和解析概念。\n\n### I. 问题验证\n\n问题陈述已根据指定标准进行评估，并确定为**有效**。\n\n1.  **科学依据**：该问题基于基本的-热/扩散方程 $ \\partial_t \\phi = D_\\phi \\nabla^2 \\phi $，这是输运现象的基石。诸如标量脉动场 $ \\phi' $、标量耗散率 $ \\chi_\\phi $，以及标量方差衰减与平均耗散率之间的关系 $ d\\langle \\phi'^2 \\rangle/dt = -\\langle \\chi_\\phi \\rangle $ 等关键概念，在此框架内是标准且正确的。对于周期性域上的问题，使用傅里葉级数表示初始标量场及其解析时间演化是一种可靠且标准的方法。\n\n2.  **适定性与完整性**：该问题是适定的。初始条件由解析函数（余弦之和）给出，且带有周期性边界条件的控制偏微分方程具有唯一、稳定的解。四个测试用例的所有必要参数——域几何形状、网格分辨率、物理常数（$D_\\phi$）、时间步长（$ \\Delta t $）和场分量（模态和偏移量）——都已明确提供。用于空间和时间导数以及条件平均的数值方法也已明确定义。该问题是自洽的，没有矛盾之处。\n\n3.  **客观性与可行性**：该问题以精确、客观的数学语言陈述。任务是算法性的，不允许主觀解释。最大的网格为 $40 \\times 40 \\times 40$，其计算负载完全在标准科学计算环境的能力范围之内，不存在任何可行性问题。\n\n总之，该问题是一个有效且结构良好的计算物理练习，要求实现数值导数、从谱数据生成场以及统计分析，所有这些都基于既定的科学原理。\n\n### II. 求解方法\n\n將遵循问题陈述中为每个测试用例概述的算法步骤来实施解决方案。\n\n1.  **网格与场生成**：对于每个测试用例，将构建一个具有坐标 $(x, y, z)$ 的均匀三维笛卡尔网格。标量场 $\\phi(\\mathbf{x}, t)$ 将在三个时间实例 $t=0$、$t=\\Delta t$ 和 $t=2\\Delta t$ 生成，方法是将在指定余弦模态的贡献求和。根据扩散方程的解析解，每个模态的振幅 $A_m$ 会随时间衰减，缩放因子为 $\\exp(-D_\\phi \\|\\mathbf{k}_m\\|^2 t)$，其中 $\\mathbf{k}_m$ 是该模态的波矢量。\n    $$ \\phi(\\mathbf{x}, t) = \\text{offset} + \\sum_{m} A_m \\exp\\left(-D_\\phi \\left\\| \\mathbf{k}_m \\right\\|^2 t\\right) \\cos(\\mathbf{k}_m \\cdot \\mathbf{x}) $$\n    其中 $\\mathbf{k}_m = \\left( \\frac{2\\pi n_{m,x}}{L_x}, \\frac{2\\pi n_{m,y}}{L_y}, \\frac{2\\pi n_{m,z}}{L_z} \\right)$。\n\n2.  **脉动与方差计算**：在三个时间步中的每一个，计算空间平均值 $\\langle\\phi\\rangle(t)$ 并从场中减去，以获得脉动场 $\\phi'(\\mathbf{x}, t) = \\phi(\\mathbf{x}, t) - \\langle\\phi\\rangle(t)$。然后，标量方差计算为脉动场平方的空间平均值，即 $\\langle\\phi'^2\\rangle(t) = \\langle (\\phi'(\\mathbf{x}, t))^2 \\rangle$。\n\n3.  **方差衰减率估计**：在中间时间步 $t=\\Delta t$ 时，标量方差的瞬时衰减率通过对方差的时间序列应用二阶中心差分公式来估计：\n    $$ R_{\\text{decay}} = - \\frac{d\\langle\\phi'^2\\rangle}{dt}\\bigg|_{t=\\Delta t} \\approx - \\frac{\\langle\\phi'^2\\rangle(2\\Delta t) - \\langle\\phi'^2\\rangle(0)}{2\\Delta t} $$\n\n4.  **空间平均标量耗散率**：此值在 $t = \\Delta t$ 时计算。首先，使用带有周期性边界条件的二阶中心差分格式数值计算脉动场的梯度 $\\nabla\\phi'(\\mathbf{x}, \\Delta t)$。例如，在 $x$ 方向上，网格点 $i$ 处的分量为：\n    $$ \\frac{\\partial \\phi'}{\\partial x}\\bigg|_i \\approx \\frac{\\phi'_{i+1} - \\phi'_{i-1}}{2\\Delta x} $$\n    然后计算逐点标量耗散率：\n    $$ \\chi_\\phi(\\mathbf{x}, \\Delta t) = 2 D_\\phi \\left\\| \\nabla\\phi'(\\mathbf{x}, \\Delta t) \\right\\|^2 = 2 D_\\phi \\left[ \\left(\\frac{\\partial \\phi'}{\\partial x}\\right)^2 + \\left(\\frac{\\partial \\phi'}{\\partial y}\\right)^2 + \\left(\\frac{\\partial \\phi'}{\\partial z}\\right)^2 \\right] $$\n    最后，计算其空间平均值 $\\langle\\chi_\\phi\\rangle(\\Delta t)$。通过计算该结果与 $R_{\\text{decay}}$ 的绝对差值来进行比较。\n\n5.  **条件标量耗散率**：在 $t = \\Delta t$ 时，将脉动场的范围 $[\\min(\\phi'), \\max(\\phi')]$ 划分为 8 个等宽分箱，记为 $\\mathcal{B}_i$（$i=1, \\dots, 8$）。对于每个网格点，我们确定其 $\\phi'$ 值属于哪个分箱。然后，对于每个分箱 $\\mathcal{B}_i$，我们计算两个量：\n    - 一个点落入分箱的概率，$p_i = N_i / N_{\\text{total}}$，其中 $N_i$ 是分箱 $i$ 中的点数。\n    - 耗散率的条件平均值，$\\langle\\chi_\\phi | \\phi' \\in \\mathcal{B}_i\\rangle$，通过对分箱 $i$ 中所有点的 $\\chi_\\phi$进行平均得到。\n\n    接着，通过对由各自概率加权的条件平均值求和，构建平均耗散率的另一种估计，这是全期望定律的离散表示：\n    $$ \\langle\\chi_\\phi\\rangle_{\\text{cond-int}} = \\sum_{i=1}^8 p_i \\langle\\chi_\\phi | \\phi' \\in \\mathcal{B}_i\\rangle $$\n    该值预期在数值上非常接近直接的空间平均值 $\\langle\\chi_\\phi\\rangle(\\Delta t)$。计算这两个估计值之间的绝对差。\n\n这五个浮点值——$\\langle\\chi_\\phi\\rangle(\\Delta t)$、$R_{\\text{decay}}$、它们的绝对差、$\\langle\\chi_\\phi\\rangle_{\\text{cond-int}}$ 以及它与 $\\langle\\chi_\\phi\\rangle(\\Delta t)$ 的绝对差——都将为每个测试用例计算并按要求格式化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for scalar dissipation rate calculations.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case 1 (single-wavenumber)\",\n            \"domain_lengths\": (1.0, 1.0, 1.0),\n            \"grid_points\": (32, 32, 32),\n            \"diffusivity\": 1.0e-4,\n            \"time_step\": 0.05,\n            \"offset\": 0.0,\n            \"modes\": [\n                (1.0, (1, 0, 0)),\n                (1.0, (0, 1, 0)),\n                (1.0, (0, 0, 1))\n            ]\n        },\n        {\n            \"name\": \"Case 2 (multi-wavenumber)\",\n            \"domain_lengths\": (2.0, 2.0, 2.0),\n            \"grid_points\": (40, 40, 40),\n            \"diffusivity\": 5.0e-4,\n            \"time_step\": 0.02,\n            \"offset\": 0.5,\n            \"modes\": [\n                (0.7, (1, 2, 0)),\n                (0.3, (0, 1, 3))\n            ]\n        },\n        {\n            \"name\": \"Case 3 (uniform field)\",\n            \"domain_lengths\": (1.0, 1.0, 1.0),\n            \"grid_points\": (16, 16, 16),\n            \"diffusivity\": 1.0e-3,\n            \"time_step\": 0.1,\n            \"offset\": 2.0,\n            \"modes\": []\n        },\n        {\n            \"name\": \"Case 4 (anisotropic)\",\n            \"domain_lengths\": (1.0, 1.5, 0.5),\n            \"grid_points\": (24, 36, 12),\n            \"diffusivity\": 2.0e-4,\n            \"time_step\": 0.03,\n            \"offset\": 0.1,\n            \"modes\": [\n                (0.8, (2, 1, 0)),\n                (0.5, (0, 3, 2))\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        Ls = np.array(case[\"domain_lengths\"])\n        Ns = np.array(case[\"grid_points\"])\n        D_phi = case[\"diffusivity\"]\n        dt = case[\"time_step\"]\n        offset = case[\"offset\"]\n        modes = case[\"modes\"]\n        \n        deltas = Ls / Ns\n        \n        coords = [np.arange(N) * d for N, d in zip(Ns, deltas)]\n        X, Y, Z = np.meshgrid(coords[0], coords[1], coords[2], indexing='ij')\n\n        def generate_phi(t):\n            field = np.full(Ns, offset, dtype=float)\n            if not modes:\n                return field\n            \n            for A, n in modes:\n                n = np.array(n)\n                k = 2. * np.pi * n / Ls\n                k_norm_sq = np.sum(k**2)\n                decay = np.exp(-D_phi * k_norm_sq * t)\n                kx_x = k[0] * X\n                ky_y = k[1] * Y\n                kz_z = k[2] * Z\n                field += A * decay * np.cos(kx_x + ky_y + kz_z)\n            return field\n\n        phi_0 = generate_phi(0)\n        phi_1 = generate_phi(dt)\n        phi_2 = generate_phi(2 * dt)\n        \n        # Fluctuation fields and variances\n        phi_prime_0 = phi_0 - phi_0.mean()\n        phi_prime_1 = phi_1 - phi_1.mean()\n        phi_prime_2 = phi_2 - phi_2.mean()\n        \n        var_0 = np.mean(phi_prime_0**2)\n        var_1 = np.mean(phi_prime_1**2)\n        var_2 = np.mean(phi_prime_2**2)\n        \n        # Result 2: Estimated decay rate of variance\n        rate_decay_var = -(var_2 - var_0) / (2 * dt)\n\n        # Gradients of phi_prime at t=dt for dissipation calculation\n        grad_x = (np.roll(phi_prime_1, -1, axis=0) - np.roll(phi_prime_1, 1, axis=0)) / (2 * deltas[0])\n        grad_y = (np.roll(phi_prime_1, -1, axis=1) - np.roll(phi_prime_1, 1, axis=1)) / (2 * deltas[1])\n        grad_z = (np.roll(phi_prime_1, -1, axis=2) - np.roll(phi_prime_1, 1, axis=2)) / (2 * deltas[2])\n        \n        grad_phi_prime_norm_sq = grad_x**2 + grad_y**2 + grad_z**2\n        \n        chi_phi_1 = 2 * D_phi * grad_phi_prime_norm_sq\n        \n        # Result 1: Spatially averaged dissipation rate\n        avg_chi_phi = np.mean(chi_phi_1)\n        \n        # Result 3: Absolute difference between dissipation and variance decay rate\n        abs_diff_rates = np.abs(avg_chi_phi - rate_decay_var)\n\n        # Conditional analysis\n        phi_prime_1_flat = phi_prime_1.flatten()\n        chi_phi_1_flat = chi_phi_1.flatten()\n        \n        min_phi_p = phi_prime_1_flat.min()\n        max_phi_p = phi_prime_1_flat.max()\n        \n        num_bins = 8\n        cond_integral_est = 0.0\n        \n        if np.isclose(min_phi_p, max_phi_p):\n            # Uniform field, dissipation is zero everywhere\n            cond_integral_est = 0.0\n        else:\n            bin_edges = np.linspace(min_phi_p, max_phi_p, num_bins + 1)\n            # Ensure the max value is included in the last bin\n            bin_edges[-1] += 1e-9 * (max_phi_p - min_phi_p) if (max_phi_p - min_phi_p) > 0 else 1e-9\n            \n            digitized = np.digitize(phi_prime_1_flat, bin_edges)\n            \n            for i in range(1, num_bins + 1):\n                indices = np.where(digitized == i)[0]\n                count = len(indices)\n                if count > 0:\n                    p_i = count / phi_prime_1_flat.size\n                    cond_avg_chi = np.mean(chi_phi_1_flat[indices])\n                    cond_integral_est += p_i * cond_avg_chi\n        \n        # Result 4: Conditional-integral estimate\n        # This is already captured in cond_integral_est\n        \n        # Result 5: Absolute difference between conditional and unconditional averages\n        abs_diff_cond_uncond = np.abs(cond_integral_est - avg_chi_phi)\n        \n        results.append([\n            avg_chi_phi,\n            rate_decay_var,\n            abs_diff_rates,\n            cond_integral_est,\n            abs_diff_cond_uncond\n        ])\n        \n    # Format the final output string exactly as specified\n    output_str = repr(results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在实际建模中，条件量通常是根据实验或直接数值模拟（DNS）产生的离散数据来估计的。本练习模拟了这一过程，要求您使用分箱方法为条件期望和条件Favre平均构建估计量，并评估其内在偏差。掌握从原始数据中提取可靠的条件统计量，是开发和验证燃烧模型的关键实践技能。",
            "id": "4041886",
            "problem": "给定您混合分数、一个标量和一个密度的独立同分布样本，表示为三元组 $\\{(Z_i, A_i, \\rho_i)\\}_{i=1}^N$，其中 $Z_i \\in [0,1]$ 是混合分数，$A_i$ 是一个无量纲标量耗散率，$\\rho_i$ 是一个无量纲密度。目标是使用分箱策略在一个离散化的 $z$-网格上计算条件期望 $\\langle A \\mid Z = z \\rangle$ 和条件 Favre 平均 $\\tilde{A}(z)$ 的估计值，并评估估计偏差。条件 Favre 平均定义为 $\\tilde{A}(z) = \\dfrac{\\langle \\rho A \\mid Z = z \\rangle}{\\langle \\rho \\mid Z = z \\rangle}$，其中 $\\langle \\cdot \\mid Z = z \\rangle$ 表示给定 $Z = z$ 的条件期望。评估必须量化由箱宽和有限采样引起的偏差。\n\n本问题的基本基础包括：\n- 条件期望 $\\langle A \\mid Z = z \\rangle$ 的定义，即在混合分数 $Z$ 等于 $z$ 的实现上 $A$ 的期望。\n- 条件 Favre 平均 $\\tilde{A}(z)$ 的定义，即密度加权条件平均，$\\tilde{A}(z) = \\dfrac{\\langle \\rho A \\mid Z = z \\rangle}{\\langle \\rho \\mid Z = z \\rangle}$。\n- 使用直方图分箱（一种矩形核）在有限的 $z$-网格上近似条件期望，并认识到分箱会引入一个依赖于箱宽的确定性偏差，以及一个由有限采样引起的随机误差。\n\n您必须设计并实现一个满足以下所有要求的算法：\n- 通过将区间 $[0,1]$ 划分为 $K$ 个宽度为 $h = 1/K$ 的等宽箱，来构建一个离散化的 $z$-网格，并在箱中心定义估计量位置。\n- 对于每个估计量位置（每个箱），计算：\n  1. 使用落入该箱的数据估算 $\\langle A \\mid Z = z \\rangle$。\n  2. 使用落入该箱的数据估算 $\\tilde{A}(z)$。\n- 提供一种稳健的方法来处理样本数为零的箱，通过定义一个确定性的插值或外推程序，为所有箱产生有限的估计量。\n- 通过将估计量与下面定义的基准真值条件函数进行比较，量化每个网格位置的估计偏差。从这些偏差中，计算：\n  - 条件期望估计量在所有箱上的最大绝对偏差。\n  - 条件 Favre 平均估计量在所有箱上的最大绝对偏差。\n- 使用矩形核的主阶确定性分箱偏差，对箱体引起的偏差进行评估。对于一个平滑的目标函数 $f(z)$ 和对称的箱，主阶分箱偏差与 $h^2$ 成比例，且与二阶导数 $f''(z)$ 成正比，因此网格点处的箱体引起的偏差大小约为 $\\left|\\dfrac{h^2}{24} f''(z)\\right|$。对于条件 Favre 平均，将其同样的领先阶评估应用于其真实条件函数，下文记为 $g(z)$。\n- 对于每个测试用例，按顺序报告四个浮点数：$\\text{max\\_abs\\_bias\\_unweighted}$、$\\text{max\\_abs\\_bias\\_favre}$、$\\text{predicted\\_bin\\_bias\\_max\\_unweighted}$、$\\text{predicted\\_bin\\_bias\\_max\\_favre}$。\n\n使用以下生成模型和测试套件进行评估：\n- 基准真值函数为\n  $$ f(z) = 0.4 + 0.5 z + 0.15 \\sin(2\\pi z), \\quad r(z) = 1.0 + 0.4 \\cos(2\\pi z), $$\n  对于所有 $z \\in [0,1]$，$r(z) > 0$。\n- 采样模型为\n  $$ Z_i \\sim \\operatorname{Beta}(\\alpha, \\beta), $$\n  $$ \\begin{pmatrix} \\eta_i \\\\ \\xi_i \\end{pmatrix} \\sim \\mathcal{N}\\left( \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} \\sigma_A^2  c\\,\\sigma_A \\sigma_\\rho \\\\ c\\,\\sigma_A \\sigma_\\rho  \\sigma_\\rho^2 \\end{pmatrix} \\right), $$\n  $$ A_i = f(Z_i) + \\eta_i, \\quad \\rho_i = r(Z_i) + \\xi_i, $$\n  其中 $\\eta_i$ 和 $\\xi_i$ 是联合高斯分布，相关系数为 $c \\in [-1,1]$，$\\sigma_A > 0$ 和 $\\sigma_\\rho > 0$ 是标准差。真实的条件期望是 $\\langle A \\mid Z = z \\rangle = f(z)$。真实的条件 Favre 函数是\n  $$ g(z) = \\frac{\\langle \\rho A \\mid Z = z \\rangle}{\\langle \\rho \\mid Z = z \\rangle} = f(z) + \\frac{\\operatorname{Cov}(\\eta,\\xi)}{r(z)} = f(z) + \\frac{c\\,\\sigma_A \\sigma_\\rho}{r(z)}. $$\n\n实现以下参数值的测试套件。对于每个案例，设置随机数生成器种子以确保可复现性，然后采样 $\\{(Z_i,A_i,\\rho_i)\\}_{i=1}^N$ 并按照规定执行估计和偏差评估：\n- 案例1（一般情况）：$N = 12000$，$K = 60$，$(\\alpha,\\beta) = (2,5)$，$\\sigma_A = 0.08$，$\\sigma_\\rho = 0.06$，$c = 0.5$，种子 $= 12345$。\n- 案例2（Z在边界处密集且噪声不相关）：$N = 1000$，$K = 40$，$(\\alpha,\\beta) = (0.5,0.5)$，$\\sigma_A = 0.15$，$\\sigma_\\rho = 0.10$，$c = 0.0$，种子 $= 23456$。\n- 案例3（窄箱、中等N、相关噪声）：$N = 6000$，$K = 200$，$(\\alpha,\\beta) = (3,3)$，$\\sigma_A = 0.04$，$\\sigma_\\rho = 0.04$，$c = 0.7$，种子 $= 34567$。\n- 案例4（小N、Z分布强倾斜）：$N = 300$，$K = 30$，$(\\alpha,\\beta) = (5,1)$，$\\sigma_A = 0.12$，$\\sigma_\\rho = 0.08$，$c = 0.3$，种子 $= 45678$。\n\n算法要求和输出：\n- 在 $[0,1]$ 上构建 $K$ 个等宽的箱，在箱中心计算估计值，并使用邻近非空箱的插值确定性地处理空箱。\n- 通过从相应估计量中减去基准真值条件函数 $f(z)$ 和 $g(z)$，计算每箱的偏差。\n- 按上述指定顺序计算每个案例的四个浮点数。\n- 您的程序应生成单行输出，包含结果，格式为逗号分隔的案例结果列表，每个案例结果是逗号分隔的四个浮点数列表，全部用方括号括起来，不含空格。例如：“[[c1_1,c1_2,c1_3,c1_4],[c2_1,c2_2,c2_3,c2_4],[c3_1,c3_2,c3_3,c3_4],[c4_1,c4_2,c4_3,c4_4]]”。\n本问题中所有量均为无量纲，因此不需要物理单位。三角函数内部出现的角度，根据构造，单位为弧度。",
            "solution": "该问题要求实现和评估一种基于分箱的估计策略，用于从一组散点数据样本中估计条件期望和条件 Favre 平均。验证证实了该问题是适定的，在统计估计理论和计算燃烧模拟方面有科学依据，并为可复现的数值实验提供了完整的规范。因此，我们可以着手解决。\n\n问题的核心是从一个包含 $N$ 个数据三元组 $\\{(Z_i, A_i, \\rho_i)\\}_{i=1}^N$ 的有限集合中，估计标量 $A$ 的条件期望，记为 $\\langle A \\mid Z=z \\rangle$，以及其密度加权对应项，即条件 Favre 平均 $\\tilde{A}(z)$。在这里，$Z$ 是条件变量（混合分数），$A$ 是一个标量，$\\rho$ 是密度。\n\n### 基准真值模型\n数据由一个已知的底层模型生成，这为我们的评估提供了基准真值。真实的条件均值由以下公式给出：\n- $\\langle A \\mid Z=z \\rangle = f(z) = 0.4 + 0.5z + 0.15\\sin(2\\pi z)$\n- $\\langle \\rho \\mid Z=z \\rangle = r(z) = 1.0 + 0.4\\cos(2\\pi z)$\n\n样本本身是通过向这些函数添加相关的零均值高斯噪声生成的：\n$A_i = f(Z_i) + \\eta_i$\n$\\rho_i = r(Z_i) + \\xi_i$\n其中 $(\\eta_i, \\xi_i)$ 从协方差为 $c\\sigma_A\\sigma_\\rho$ 的二元正态分布中抽取。混合分数样本 $Z_i$ 从 Beta 分布中抽取，$Z_i \\sim \\operatorname{Beta}(\\alpha, \\beta)$。\n\n根据这些定义，真实的条件 Favre 平均 $\\tilde{A}(z)$ 可以推导为：\n$$\n\\tilde{A}(z) = \\frac{\\langle \\rho A \\mid Z=z \\rangle}{\\langle \\rho \\mid Z=z \\rangle} = \\frac{\\langle (r(z) + \\xi)(f(z) + \\eta) \\mid Z=z \\rangle}{r(z)}\n$$\n展开分子，并利用噪声项 $(\\eta, \\xi)$ 与 $Z$ 的统计独立性及其零均值属性（$\\langle\\eta\\rangle = \\langle\\xi\\rangle = 0$），我们得到：\n$$\n\\langle \\rho A \\mid Z=z \\rangle = r(z)f(z) + \\langle \\eta\\xi \\rangle = r(z)f(z) + \\mathrm{Cov}(\\eta, \\xi)\n$$\n协方差给出为 $\\mathrm{Cov}(\\eta, \\xi) = c\\sigma_A\\sigma_\\rho$。因此，我们记为 $g(z)$ 的真实条件 Favre 平均是：\n$$\ng(z) = \\tilde{A}(z) = f(z) + \\frac{c\\sigma_A\\sigma_\\rho}{r(z)}\n$$\n由于 $r(z) = 1.0 + 0.4\\cos(2\\pi z) \\ge 1.0 - 0.4 = 0.6 > 0$，函数 $g(z)$ 对所有 $z \\in [0,1]$ 都是良定义的。\n\n### 估计算法\n估计过程在均匀网格上使用基于直方图（分箱）的方法。\n\n1.  **网格构建**：将条件变量的域 $[0,1]$ 划分为 $K$ 个箱 $\\{B_k\\}_{k=1}^K$，其等宽为 $h = 1/K$。第 $k$ 个箱定义为 $B_k = [ (k-1)h, kh )$ 对于 $k=1, \\dots, K-1$，以及 $B_K = [(K-1)h, Kh]$。估计量在每个箱的中心 $z_k = (k-0.5)h$ 处进行评估。\n\n2.  **分箱估计量**：对于每个箱 $B_k$，我们找到数据样本的子集 $S_k = \\{i \\mid Z_i \\in B_k\\}$ 及其大小 $N_k = |S_k|$。\n    - 条件期望 $\\langle A \\mid Z=z_k \\rangle$ 的估计量是箱内 $A_i$ 的样本均值：\n      $$ \\hat{A}_k = \\frac{1}{N_k} \\sum_{i \\in S_k} A_i $$\n    - 条件 Favre 平均 $\\tilde{A}(z_k)$ 的估计量是 $\\rho A$ 的样本均值与 $\\rho$ 的样本均值之比：\n      $$ \\hat{\\tilde{A}}_k = \\frac{\\frac{1}{N_k} \\sum_{i \\in S_k} \\rho_i A_i}{\\frac{1}{N_k} \\sum_{i \\in S_k} \\rho_i} = \\frac{\\sum_{i \\in S_k} \\rho_i A_i}{\\sum_{i \\in S_k} \\rho_i} $$\n    如果一个箱 $B_k$ 是空的（$N_k=0$），这些估计量是未定义的。\n\n3.  **处理空箱**：当 $N_k=0$ 时，直接估计会导致不确定形式。需要一个确定性程序。我们首先为所有非空箱计算估计值。然后，对于任何空箱，其值使用最近的非空邻近箱的值进行线性插值来估计。对于域边界处的空箱（即在第一个非空箱之前或最后一个之后），使用最近的非空箱的值进行外推。\n\n### 偏差评估\n每个网格点 $z_k$ 处估计量的总误差是确定性偏差（由于箱宽 $h$）和随机误差（由于有限样本量 $N$）的和。总偏差通过将最终估计值（插值后）与在箱中心评估的真实函数进行比较来计算：\n- 无加权平均的偏差：$\\mathcal{B}_A(z_k) = \\hat{A}_k - f(z_k)$\n- Favre 平均的偏差：$\\mathcal{B}_{\\tilde{A}}(z_k) = \\hat{\\tilde{A}}_k - g(z_k)$\n\n问题要求报告这些偏差在所有箱 $k=1, \\dots, K$ 上的最大绝对值。\n\n此外，还需要一个关于主阶确定性分箱偏差的理论预测。对于足够平滑的函数和对称的分箱核，在点 $z$ 处的此偏差约为 $\\frac{h^2}{24} \\ddot{F}(z)$，其中 $\\ddot{F}$ 是真实条件函数的二阶导数。\n- 对于无加权平均，预测的偏差大小为 $\\left|\\frac{h^2}{24} f''(z)\\right|$。\n- 对于 Favre 平均，预测的偏差大小为 $\\left|\\frac{h^2}{24} g''(z)\\right|$。\n\n所需的二阶导数为：\n- $f''(z) = \\frac{d^2}{dz^2} (0.4 + 0.5z + 0.15\\sin(2\\pi z)) = -0.15(2\\pi)^2\\sin(2\\pi z) = -0.6\\pi^2\\sin(2\\pi z)$\n- 为了找到 $g''(z)$，我们对 $g(z) = f(z) + C r(z)^{-1}$ 进行微分，其中 $C=c\\sigma_A\\sigma_\\rho$。\n  $$ g''(z) = f''(z) + C \\frac{d^2}{dz^2}(r(z)^{-1}) = f''(z) + C \\left[ 2 \\frac{(r'(z))^2}{r(z)^3} - \\frac{r''(z)}{r(z)^2} \\right] $$\n  其中 $r(z) = 1.0 + 0.4\\cos(2\\pi z)$，$r'(z) = -0.8\\pi\\sin(2\\pi z)$，以及 $r''(z) = -1.6\\pi^2\\cos(2\\pi z)$。\n\n该算法计算这些预测偏差大小在网格点 $z_k$ 上的最大值。这为可归因于网格粗糙度的误差部分提供了一个理论基线，与统计采样误差分开。\n\n### 实现摘要\n解决方案使用 `numpy` 和 `scipy` 库在 Python 中实现。对于每个测试用例：\n1.  为可复现性设置随机数生成器种子。\n2.  根据指定模型生成 $N$ 个 $(Z_i, A_i, \\rho_i)$ 样本。\n3.  使用 `scipy.stats.binned_statistic` 函数高效地计算每个 $K$ 箱中 $A_i$、$\\rho_i$ 和 $\\rho_i A_i$ 的总和，以及样本计数 $N_k$。\n4.  计算估计值 $\\hat{A}_k$ 和 $\\hat{\\tilde{A}}_k$。这会为空箱生成 `NaN` 值。\n5.  使用 `numpy.interp` 通过线性插值和常数外推来填充 `NaN` 值。\n6.  在箱中心评估真实函数 $f(z)$ 和 $g(z)$，以计算实际的估计偏差。\n7.  使用解析的二阶导数 $f''(z)$ 和 $g''(z)$ 计算理论分箱偏差。\n8.  确定并存储实际偏差和预测偏差的最大绝对值。\n最后，将所有测试用例的结果格式化为指定的单个字符串。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import binned_statistic\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: general case\n        {'N': 12000, 'K': 60, 'alpha': 2, 'beta': 5, 'sigma_A': 0.08, 'sigma_rho': 0.06, 'c': 0.5, 'seed': 12345},\n        # Case 2: boundary-heavy Z and uncorrelated noise\n        {'N': 1000, 'K': 40, 'alpha': 0.5, 'beta': 0.5, 'sigma_A': 0.15, 'sigma_rho': 0.10, 'c': 0.0, 'seed': 23456},\n        # Case 3: narrow bins, moderate N, correlated noise\n        {'N': 6000, 'K': 200, 'alpha': 3, 'beta': 3, 'sigma_A': 0.04, 'sigma_rho': 0.04, 'c': 0.7, 'seed': 34567},\n        # Case 4: small N, strongly skewed Z\n        {'N': 300, 'K': 30, 'alpha': 5, 'beta': 1, 'sigma_A': 0.12, 'sigma_rho': 0.08, 'c': 0.3, 'seed': 45678},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_case(**params)\n        all_results.append(result)\n\n    # Format the final output string as a list of lists, with no spaces.\n    results_str = str(all_results).replace(\" \", \"\")\n    print(results_str)\n\ndef run_case(N, K, alpha, beta, sigma_A, sigma_rho, c, seed):\n    \"\"\"\n    Performs the full simulation and analysis for a single test case.\n    \"\"\"\n    # 1. Setup and Ground Truth Functions\n    rng = np.random.default_rng(seed)\n    h = 1.0 / K\n    z_centers = np.linspace(h / 2, 1 - h / 2, K)\n\n    # Ground-truth functions\n    f = lambda z: 0.4 + 0.5 * z + 0.15 * np.sin(2 * np.pi * z)\n    r = lambda z: 1.0 + 0.4 * np.cos(2 * np.pi * z)\n    cov_eta_xi = c * sigma_A * sigma_rho\n    g = lambda z: f(z) + cov_eta_xi / r(z)\n\n    # 2. Generate Sample Data\n    Z_i = rng.beta(alpha, beta, size=N)\n    cov_matrix = [[sigma_A**2, cov_eta_xi], [cov_eta_xi, sigma_rho**2]]\n    noise = rng.multivariate_normal([0, 0], cov_matrix, size=N)\n    eta_i, xi_i = noise[:, 0], noise[:, 1]\n    A_i = f(Z_i) + eta_i\n    rho_i = r(Z_i) + xi_i\n\n    # 3. Binning and Estimation\n    bins = np.linspace(0, 1, K + 1)\n    sum_A, _, _ = binned_statistic(Z_i, A_i, statistic='sum', bins=bins)\n    sum_rho, _, _ = binned_statistic(Z_i, rho_i, statistic='sum', bins=bins)\n    sum_rhoA, _, _ = binned_statistic(Z_i, rho_i * A_i, statistic='sum', bins=bins)\n    counts, _, _ = binned_statistic(Z_i, Z_i, statistic='count', bins=bins)\n\n    # 4. Calculate Estimates, handle division by zero\n    with np.errstate(divide='ignore', invalid='ignore'):\n        A_hat = sum_A / counts\n        A_tilde_hat = sum_rhoA / sum_rho\n\n    # 5. Handle Empty Bins with Interpolation\n    is_empty = (counts == 0)\n    non_empty_indices = np.where(~is_empty)[0]\n\n    if len(non_empty_indices) == 0:\n        A_hat_filled = np.zeros(K)\n        A_tilde_hat_filled = np.zeros(K)\n    elif len(non_empty_indices) == 1:\n        A_hat_filled = np.full(K, A_hat[non_empty_indices[0]])\n        A_tilde_hat_filled = np.full(K, A_tilde_hat[non_empty_indices[0]])\n    else:\n        A_hat_filled = np.interp(z_centers, z_centers[~is_empty], A_hat[~is_empty])\n        A_tilde_hat_filled = np.interp(z_centers, z_centers[~is_empty], A_tilde_hat[~is_empty])\n    \n    # 6. Calculate Actual Bias\n    true_f_at_centers = f(z_centers)\n    true_g_at_centers = g(z_centers)\n    bias_unweighted = A_hat_filled - true_f_at_centers\n    bias_favre = A_tilde_hat_filled - true_g_at_centers\n    max_abs_bias_unweighted = np.max(np.abs(bias_unweighted))\n    max_abs_bias_favre = np.max(np.abs(bias_favre))\n\n    # 7. Calculate Predicted Binning Bias\n    f_pp = lambda z: -0.15 * (2 * np.pi)**2 * np.sin(2 * np.pi * z)\n    r_p = lambda z: -0.8 * np.pi * np.sin(2 * np.pi * z)\n    r_pp = lambda z: -1.6 * np.pi**2 * np.cos(2 * np.pi * z)\n    \n    def g_pp(z):\n        r_val = r(z)\n        r_p_val = r_p(z)\n        r_pp_val = r_pp(z)\n        term1 = f_pp(z)\n        term2 = cov_eta_xi * (2 * (r_p_val**2) / (r_val**3) - r_pp_val / (r_val**2))\n        return term1 + term2\n        \n    pred_bias_unweighted = (h**2 / 24) * np.abs(f_pp(z_centers))\n    pred_bias_favre = (h**2 / 24) * np.abs(g_pp(z_centers))\n\n    predicted_bin_bias_max_unweighted = np.max(pred_bias_unweighted) if len(pred_bias_unweighted) > 0 else 0.0\n    predicted_bin_bias_max_favre = np.max(pred_bias_favre) if len(pred_bias_favre) > 0 else 0.0\n\n    return [max_abs_bias_unweighted, max_abs_bias_favre, predicted_bin_bias_max_unweighted, predicted_bin_bias_max_favre]\n```"
        },
        {
            "introduction": "我们对条件标量耗散率 $\\langle \\chi_Z | z \\rangle$ 进行建模的最终目标，是将其用作更大输运模型（如条件矩封闭，CMC）中的一个关键封闭项。本练习探讨了最终CMC解对 $\\langle \\chi_Z | z \\rangle$ 剖面具体形状的敏感性。通过运用微扰分析，我们可以量化耗散率模型中的微小变化如何传播到最终预测的标量场中，这凸显了发展精确封闭模型的极端重要性。",
            "id": "4041919",
            "problem": "考虑一个统计稳态的非预混流，其中混合分数 $z \\in [0,1]$ 是一个守恒标量。设 $\\tilde{\\phi}(z)$ 表示在条件矩封闭（CMC）框架下，给定混合分数 $z$ 时被动标量的条件平均值。此处，CMC 被定义为在 $z$ 的等值面上对标量输运方程进行条件平均。\n\n在 Lewis 数为 1、密度恒定以及被动标量的条件源项可忽略的假设下，混合分数空间中的输运过程由与条件标量耗散率 $\\langle \\chi_Z \\mid z \\rangle$ 相关的扩散微观混合通量的守恒定律所支配。\n\n要求您通过围绕一个基准剖面进行一阶微扰分析，来分析 CMC 解 $\\tilde{\\phi}(z)$ 对 $\\langle \\chi_Z \\mid z \\rangle$ 形状变化的敏感性。假设以下科学上一致的设定：\n\n- 基准条件标量耗散率是均匀的：$\\langle \\chi_Z \\mid z \\rangle = \\chi_0$，其中 $\\chi_0 > 0$ 是一个常数。\n- 被动标量的边界条件为 Dirichlet 条件：$\\tilde{\\phi}(0) = 0$ 和 $\\tilde{\\phi}(1) = 1$。\n- 一个微小的形状微扰将耗散率修改为 $\\langle \\chi_Z \\mid z \\rangle = \\chi_0 \\left(1 + \\epsilon h(z)\\right)$，其中 $0  \\epsilon \\ll 1$ 是一个无量纲振幅，$h(z)$ 是一个给定的无量纲形状函数。\n- 取 $h(z) = \\sin(\\pi z)$。\n\n从混合分数空间中扩散通量的基本守恒定律出发，并使用第一性原理（不要使用预先推导的简化公式），对 $\\epsilon$ 进行一阶微扰分析，以获得由 $\\langle \\chi_Z \\mid z \\rangle$ 的微扰引起的 CMC 解中的主阶变化 $\\Delta \\tilde{\\phi}(z)$。然后，计算当 $z = \\frac{1}{4}$ 时这个主阶变化的值。\n\n将您的最终答案表示为关于 $\\Delta \\tilde{\\phi}\\!\\left(\\frac{1}{4}\\right)$ 的单一、精确到 $\\epsilon$ 一阶的解析表达式。不要四舍五入；由于 $\\tilde{\\phi}$ 的构造是无量纲的，因此不需要单位。",
            "solution": "用户请求对一个计算燃烧学问题进行分析。第一步是对问题陈述进行强制性验证。\n\n### 步骤 1：提取已知条件\n- **框架**：用于统计稳态非预混流的条件矩封闭（CMC）。\n- **变量**：\n    - 混合分数 $z \\in [0,1]$。\n    - 被动标量的条件平均值：$\\tilde{\\phi}(z)$。\n    - 混合分数的条件标量耗散率：$\\langle \\chi_Z \\mid z \\rangle$。\n- **假设**：\n    - Lewis 数为 1。\n    - 密度恒定。\n    - 被动标量的条件源项可忽略。\n- **控制原理**：混合分数空间中扩散微观混合通量的守恒。\n- **基准剖面**：$\\langle \\chi_Z \\mid z \\rangle = \\chi_0$，其中 $\\chi_0 > 0$ 是一个常数。\n- **微扰剖面**：$\\langle \\chi_Z \\mid z \\rangle = \\chi_0 \\left(1 + \\epsilon h(z)\\right)$，其中 $0  \\epsilon \\ll 1$。\n- **微扰形状函数**：$h(z) = \\sin(\\pi z)$。\n- **边界条件**：$\\tilde{\\phi}(0) = 0$ 和 $\\tilde{\\phi}(1) = 1$。\n- **目标**：找出由微扰引起的解的主阶变化 $\\Delta \\tilde{\\phi}(z)$，并在 $z = \\frac{1}{4}$ 处对其求值。主阶变化定义为 $\\Delta \\tilde{\\phi}(z) = \\tilde{\\phi}(z) - \\tilde{\\phi}_0(z)$，精确到 $\\epsilon$ 的一阶。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题设定在条件矩封闭这一公认的框架内，这是湍流燃烧模拟中的一种标准技术。混合分数、条件平均和标量耗散率等概念是该领域的基础。在这些假设下，被动标量的控制方程是一个标准结果。\n- **适定性**：该问题可归结为求解一个带有两个 Dirichlet 边界条件的二阶常微分方程。这构成了一个适定的 Sturm-Liouville 边值问题，保证了唯一解的存在。\n- **目标**：问题陈述使用了精确、标准且无偏的科学术语。所有量都得到了清晰的定义。\n- **完整性与一致性**：问题提供了所有必要信息：物理控制原理、系数函数 $\\langle \\chi_Z \\mid z \\rangle$ 的基准形式和微扰形式，以及因变量 $\\tilde{\\phi}(z)$ 的边界条件。其中没有矛盾之处。\n- **可行性**：使用简单的正弦微扰函数 $h(z)$ 和均匀的基准剖面，使得通过标准的一阶微扰分析获得解析解成为可能，这是一项可行的数学任务。\n\n### 步骤 3：结论与行动\n该问题在科学上是有效的、适定的，并包含了获得唯一解所需的所有信息。可以开始求解过程。\n\n### 求解推导\n\n在给定的假设（稳态、Lewis 数为 1、密度 $\\rho$ 恒定、源项可忽略）下，混合分数空间中被动标量 $\\phi$ 的输运由针对条件平均值 $\\tilde{\\phi}(z)$ 的条件矩封闭（CMC）方程所控制：\n$$\n\\frac{d}{dz} \\left( \\frac{\\rho}{2} \\langle \\chi_Z \\mid z \\rangle \\frac{d\\tilde{\\phi}}{dz} \\right) = 0\n$$\n由于 $\\rho$ 是常数，可以消去。该方程表示 $z$ 空间中扩散通量的守恒。积分一次，我们得到：\n$$\n\\langle \\chi_Z \\mid z \\rangle \\frac{d\\tilde{\\phi}}{dz} = C\n$$\n其中 $C$ 是一个积分常数。\n\n首先，我们求解基准情况。设基准解为 $\\tilde{\\phi}_0(z)$。基准条件标量耗散为 $\\langle \\chi_Z \\mid z \\rangle = \\chi_0$。方程变为：\n$$\n\\chi_0 \\frac{d\\tilde{\\phi}_0}{dz} = C_0\n$$\n对 $z$ 积分：\n$$\n\\tilde{\\phi}_0(z) = \\frac{C_0}{\\chi_0} z + D_0\n$$\n我们应用边界条件 $\\tilde{\\phi}_0(0) = 0$ 和 $\\tilde{\\phi}_0(1) = 1$：\n- $\\tilde{\\phi}_0(0) = 0 \\implies D_0 = 0$。\n- $\\tilde{\\phi}_0(1) = 1 \\implies \\frac{C_0}{\\chi_0} (1) = 1 \\implies C_0 = \\chi_0$。\n因此，基准解为 $\\tilde{\\phi}_0(z) = z$。\n\n接下来，我们进行一阶微扰分析。将完整解 $\\tilde{\\phi}(z)$ 按 $\\epsilon$ 的幂次展开：\n$$\n\\tilde{\\phi}(z) = \\tilde{\\phi}_0(z) + \\epsilon \\tilde{\\phi}_1(z) + \\mathcal{O}(\\epsilon^2)\n$$\n微扰后的条件标量耗散率为 $\\langle \\chi_Z \\mid z \\rangle = \\chi_0 (1 + \\epsilon h(z))$。将这些代入控制方程 $\\langle \\chi_Z \\mid z \\rangle \\frac{d\\tilde{\\phi}}{dz} = C$：\n$$\n\\chi_0 (1 + \\epsilon h(z)) \\frac{d}{dz} \\left( \\tilde{\\phi}_0(z) + \\epsilon \\tilde{\\phi}_1(z) \\right) = C\n$$\n常数 $C$ 也依赖于微扰，因此我们将其展开为 $C = C_0 + \\epsilon C_1 + \\mathcal{O}(\\epsilon^2)$。\n$$\n\\chi_0 (1 + \\epsilon h(z)) \\left( \\frac{d\\tilde{\\phi}_0}{dz} + \\epsilon \\frac{d\\tilde{\\phi}_1}{dz} \\right) = C_0 + \\epsilon C_1\n$$\n我们代入 $\\frac{d\\tilde{\\phi}_0}{dz} = 1$ 和 $C_0 = \\chi_0$：\n$$\n\\chi_0 (1 + \\epsilon h(z)) \\left( 1 + \\epsilon \\frac{d\\tilde{\\phi}_1}{dz} \\right) = \\chi_0 + \\epsilon C_1\n$$\n展开左侧并保留到 $\\epsilon$ 的一阶项：\n$$\n\\chi_0 \\left( 1 + \\epsilon \\frac{d\\tilde{\\phi}_1}{dz} + \\epsilon h(z) + \\mathcal{O}(\\epsilon^2) \\right) = \\chi_0 + \\epsilon C_1\n$$\n我们令 $\\epsilon$ 的同阶项相等。\n零阶（$\\mathcal{O}(\\epsilon^0)$）方程为 $\\chi_0 = \\chi_0$，这是一致的。\n一阶（$\\mathcal{O}(\\epsilon^1)$）方程为：\n$$\n\\chi_0 \\left( \\frac{d\\tilde{\\phi}_1}{dz} + h(z) \\right) = C_1\n$$\n$$\n\\frac{d\\tilde{\\phi}_1}{dz} = \\frac{C_1}{\\chi_0} - h(z)\n$$\n设 $C'_1 = C_1/\\chi_0$。对 $z$ 积分：\n$$\n\\tilde{\\phi}_1(z) = \\int \\left( C'_1 - h(z) \\right) dz = C'_1 z - \\int h(z) dz + D_1\n$$\n我们将边界条件应用于完整解 $\\tilde{\\phi}(z)$。由于 $\\tilde{\\phi}_0(z)$ 已经满足了非齐次边界条件，微扰部分 $\\epsilon \\tilde{\\phi}_1(z)$ 必须满足齐次边界条件。\n- $\\tilde{\\phi}(0) = \\tilde{\\phi}_0(0) + \\epsilon \\tilde{\\phi}_1(0) = 0 \\implies \\epsilon \\tilde{\\phi}_1(0) = 0 \\implies \\tilde{\\phi}_1(0) = 0$。\n- $\\tilde{\\phi}(1) = \\tilde{\\phi}_0(1) + \\epsilon \\tilde{\\phi}_1(1) = 1 \\implies \\epsilon \\tilde{\\phi}_1(1) = 0 \\implies \\tilde{\\phi}_1(1) = 0$。\n\n现在，我们代入 $h(z) = \\sin(\\pi z)$：\n$$\n\\int h(z) dz = \\int \\sin(\\pi z) dz = -\\frac{1}{\\pi} \\cos(\\pi z)\n$$\n所以 $\\tilde{\\phi}_1(z)$ 的解为：\n$$\n\\tilde{\\phi}_1(z) = C'_1 z + \\frac{1}{\\pi} \\cos(\\pi z) + D_1\n$$\n对 $\\tilde{\\phi}_1(z)$ 应用齐次边界条件：\n- 在 $z=0$ 处：$\\tilde{\\phi}_1(0) = 0 \\implies C'_1(0) + \\frac{1}{\\pi}\\cos(0) + D_1 = 0 \\implies \\frac{1}{\\pi} + D_1 = 0 \\implies D_1 = -\\frac{1}{\\pi}$。\n- 在 $z=1$ 处：$\\tilde{\\phi}_1(1) = 0 \\implies C'_1(1) + \\frac{1}{\\pi}\\cos(\\pi) + D_1 = 0 \\implies C'_1 - \\frac{1}{\\pi} + D_1 = 0$。\n代入 $D_1 = -1/\\pi$：\n$$\nC'_1 - \\frac{1}{\\pi} - \\frac{1}{\\pi} = 0 \\implies C'_1 = \\frac{2}{\\pi}\n$$\n所以，一阶修正项为：\n$$\n\\tilde{\\phi}_1(z) = \\frac{2}{\\pi}z + \\frac{1}{\\pi}\\cos(\\pi z) - \\frac{1}{\\pi} = \\frac{1}{\\pi} \\left( 2z + \\cos(\\pi z) - 1 \\right)\n$$\n解的主阶变化为 $\\Delta \\tilde{\\phi}(z) = \\tilde{\\phi}(z) - \\tilde{\\phi}_0(z) \\approx \\epsilon \\tilde{\\phi}_1(z)$。\n$$\n\\Delta \\tilde{\\phi}(z) = \\frac{\\epsilon}{\\pi} \\left( 2z + \\cos(\\pi z) - 1 \\right)\n$$\n我们需要在 $z = \\frac{1}{4}$ 处计算该式的值：\n$$\n\\Delta \\tilde{\\phi}\\left(\\frac{1}{4}\\right) = \\frac{\\epsilon}{\\pi} \\left( 2\\left(\\frac{1}{4}\\right) + \\cos\\left(\\frac{\\pi}{4}\\right) - 1 \\right)\n$$\n$$\n\\Delta \\tilde{\\phi}\\left(\\frac{1}{4}\\right) = \\frac{\\epsilon}{\\pi} \\left( \\frac{1}{2} + \\frac{\\sqrt{2}}{2} - 1 \\right)\n$$\n$$\n\\Delta \\tilde{\\phi}\\left(\\frac{1}{4}\\right) = \\frac{\\epsilon}{\\pi} \\left( \\frac{\\sqrt{2} - 1}{2} \\right)\n$$\n$$\n\\Delta \\tilde{\\phi}\\left(\\frac{1}{4}\\right) = \\frac{\\epsilon(\\sqrt{2}-1)}{2\\pi}\n$$\n这就是在指定点处主阶变化的最终解析表达式。",
            "answer": "$$\n\\boxed{\\frac{\\epsilon(\\sqrt{2}-1)}{2\\pi}}\n$$"
        }
    ]
}