{
    "hands_on_practices": [
        {
            "introduction": "The first step toward mastering the concept of scalar dissipation is to compute it directly. This exercise provides a foundational, hands-on opportunity to implement the definition of the scalar dissipation rate, $\\chi_\\phi$, from a given scalar field and to verify its physical role as the destruction mechanism for scalar variance. By comparing the spatially-averaged dissipation rate with the temporal decay of scalar variance, you will confirm a fundamental balance equation in turbulent mixing .",
            "id": "4041978",
            "problem": "You are given a three-dimensional periodic domain in which a passive scalar field $ \\phi(\\mathbf{x}, t) $ evolves according to a diffusion-only model with constant molecular diffusivity $ D_\\phi $. The scalar transport equation is the diffusion equation with no advection and no sources. The scalar dissipation rate is modeled based on the fluctuation field $ \\phi'(\\mathbf{x}, t) $, defined as the deviation from the instantaneous spatial mean. Your tasks are to compute the spatially averaged scalar dissipation rate, estimate the rate of decay of the scalar variance from time series data, and examine a conditional formulation by binning the scalar field values.\n\nFundamental base to use:\n- The diffusion equation for a passive scalar with constant diffusivity: the time rate of change of the scalar depends on the Laplacian of the scalar, under periodic boundary conditions and no sources.\n- The fluctuation field is $ \\phi'(\\mathbf{x}, t) = \\phi(\\mathbf{x}, t) - \\langle \\phi(\\cdot, t) \\rangle $, where $ \\langle \\cdot \\rangle $ denotes a spatial average over the domain at fixed time.\n- The scalar dissipation rate associated with the fluctuations is defined as $ \\chi_\\phi(\\mathbf{x}, t) = 2 D_\\phi \\left\\|\\nabla \\phi'(\\mathbf{x}, t)\\right\\|^2 $.\n- The conditional scalar dissipation rate given the scalar value is the conditional expectation $ \\langle \\chi_\\phi \\mid \\phi' \\in \\mathcal{B}_i \\rangle $, where $ \\mathcal{B}_i $ is a bin in the range of $ \\phi' $, and the unconditional average is recovered by integrating the conditional expectation with respect to the probability density of $ \\phi' $ (discretized as a probability mass over bins).\n\nComputational requirements:\n- Use a uniform Cartesian grid with periodic boundary conditions in all three directions.\n- Use centered finite differences with periodic wrap-around to approximate spatial gradients.\n- Use a central difference in time on the variance time series to estimate the instantaneous rate of decay at the middle time.\n- For conditional modeling, partition the range of $ \\phi'(\\mathbf{x}, t) $ at the middle time into $ 8 $ equal-width bins and compute the conditional averages of $ \\chi_\\phi $, then the bin-probability-weighted integral (discrete sum) of these conditional averages.\n\nUnits and reporting:\n- The diffusivity $ D_\\phi $ is in $ \\mathrm{m}^2/\\mathrm{s} $, distances are in $ \\mathrm{m} $, and time is in $ \\mathrm{s} $. The scalar dissipation rate $ \\chi_\\phi $ and its spatial average have units of $ \\mathrm{s}^{-1} $.\n- Your outputs must be reported in $ \\mathrm{s}^{-1} $.\n- The program must produce a single line of output in the format of a comma-separated Python-like list containing one sublist per test case. Each sublist must contain five floats in the following order: the spatially averaged dissipation rate at the middle time, the estimated decay rate of the variance at the middle time from the time series, the absolute difference between these two quantities, the conditional-integral estimate (probability-weighted integral of conditional dissipation), and the absolute difference between the conditional-integral estimate and the unconditional average. The final output must be a single line string of the form $ [ [r_{1,1}, r_{1,2}, r_{1,3}, r_{1,4}, r_{1,5}], [r_{2,1}, \\dots], \\dots ] $ with no spaces.\n\nTest suite and domain/model specification:\nFor each case, define a periodic domain of lengths $ (L_x, L_y, L_z) $, discretized by $ (N_x, N_y, N_z) $ grid points, a constant diffusivity $ D_\\phi $, a time step $ \\Delta t $, and a scalar field constructed as a sum of cosine modes plus an offset. Each cosine mode is of the form $ A \\cos(\\mathbf{k} \\cdot \\mathbf{x}) $ where $ \\mathbf{k} = \\left( \\frac{2\\pi n_x}{L_x}, \\frac{2\\pi n_y}{L_y}, \\frac{2\\pi n_z}{L_z} \\right) $, and evolves under diffusion such that the amplitude of each mode at time $ t $ is multiplied by $ \\exp\\left( - D_\\phi \\|\\mathbf{k}\\|^2 t \\right) $. The offset is a constant added to the field and does not decay under diffusion. For each case, construct the scalar field $ \\phi(\\mathbf{x}, t) $ at times $ t = 0 $, $ t = \\Delta t $, and $ t = 2 \\Delta t $ using this evolution law. Compute the spatially averaged dissipation at $ t = \\Delta t $, and estimate the decay rate of the scalar variance at $ t = \\Delta t $ using a central time difference applied to the three time levels.\n\nProvide the following four test cases:\n- Case $ 1 $ (single-wavenumber components):\n  - Domain lengths: $ (L_x, L_y, L_z) = (1.0, 1.0, 1.0) $ $ \\mathrm{m} $.\n  - Grid points: $ (N_x, N_y, N_z) = (32, 32, 32) $.\n  - Diffusivity: $ D_\\phi = 1.0 \\times 10^{-4} $ $ \\mathrm{m}^2/\\mathrm{s} $.\n  - Time step: $ \\Delta t = 0.05 $ $ \\mathrm{s} $.\n  - Offset: $ 0.0 $.\n  - Modes: $ A = 1.0 $, $ (n_x, n_y, n_z) \\in \\{ (1, 0, 0), (0, 1, 0), (0, 0, 1) \\} $.\n- Case $ 2 $ (multi-wavenumber components with nonzero mean):\n  - Domain lengths: $ (L_x, L_y, L_z) = (2.0, 2.0, 2.0) $ $ \\mathrm{m} $.\n  - Grid points: $ (N_x, N_y, N_z) = (40, 40, 40) $.\n  - Diffusivity: $ D_\\phi = 5.0 \\times 10^{-4} $ $ \\mathrm{m}^2/\\mathrm{s} $.\n  - Time step: $ \\Delta t = 0.02 $ $ \\mathrm{s} $.\n  - Offset: $ 0.5 $.\n  - Modes: $ (A, n_x, n_y, n_z) \\in \\{ (0.7, 1, 2, 0), (0.3, 0, 1, 3) \\} $.\n- Case $ 3 $ (uniform field):\n  - Domain lengths: $ (L_x, L_y, L_z) = (1.0, 1.0, 1.0) $ $ \\mathrm{m} $.\n  - Grid points: $ (N_x, N_y, N_z) = (16, 16, 16) $.\n  - Diffusivity: $ D_\\phi = 1.0 \\times 10^{-3} $ $ \\mathrm{m}^2/\\mathrm{s} $.\n  - Time step: $ \\Delta t = 0.1 $ $ \\mathrm{s} $.\n  - Offset: $ 2.0 $.\n  - Modes: none.\n- Case $ 4 $ (anisotropic domain and mixed modes):\n  - Domain lengths: $ (L_x, L_y, L_z) = (1.0, 1.5, 0.5) $ $ \\mathrm{m} $.\n  - Grid points: $ (N_x, N_y, N_z) = (24, 36, 12) $.\n  - Diffusivity: $ D_\\phi = 2.0 \\times 10^{-4} $ $ \\mathrm{m}^2/\\mathrm{s} $.\n  - Time step: $ \\Delta t = 0.03 $ $ \\mathrm{s} $.\n  - Offset: $ 0.1 $.\n  - Modes: $ (A, n_x, n_y, n_z) \\in \\{ (0.8, 2, 1, 0), (0.5, 0, 3, 2) \\} $.\n\nAlgorithmic steps to implement for each case:\n- Construct the scalar field $ \\phi(\\mathbf{x}, t) $ at times $ t = 0 $, $ t = \\Delta t $, $ t = 2 \\Delta t $ on the specified grid using the mode evolution described above.\n- Compute the fluctuation field $ \\phi'(\\mathbf{x}, \\Delta t) $ by subtracting the spatial mean at $ t = \\Delta t $.\n- Approximate $ \\nabla \\phi'(\\mathbf{x}, \\Delta t) $ using centered finite differences with periodic wrap-around and grid spacings $ \\Delta x = L_x/N_x $, $ \\Delta y = L_y/N_y $, $ \\Delta z = L_z/N_z $.\n- Compute the pointwise $ \\chi_\\phi(\\mathbf{x}, \\Delta t) = 2 D_\\phi \\left( \\left( \\partial \\phi'/\\partial x \\right)^2 + \\left( \\partial \\phi'/\\partial y \\right)^2 + \\left( \\partial \\phi'/\\partial z \\right)^2 \\right) $, then compute the spatial average $ \\langle \\chi_\\phi \\rangle $ by averaging over the grid.\n- Compute the scalar variance $ \\langle \\phi'^2 \\rangle(t) $ at $ t = 0 $, $ t = \\Delta t $, and $ t = 2 \\Delta t $, then estimate the instantaneous decay rate at $ t = \\Delta t $ using a central difference $ - \\left( \\langle \\phi'^2 \\rangle(2\\Delta t) - \\langle \\phi'^2 \\rangle(0) \\right) / (2 \\Delta t) $.\n- Construct $ 8 $ equal-width bins spanning $ [ \\min \\phi'(\\mathbf{x}, \\Delta t), \\max \\phi'(\\mathbf{x}, \\Delta t) ] $. For each bin $ \\mathcal{B}_i $, compute the conditional average $ \\langle \\chi_\\phi \\mid \\phi' \\in \\mathcal{B}_i \\rangle $ and the bin probability $ p_i $. Form the probability-weighted integral (discrete sum) $ \\sum_i p_i \\langle \\chi_\\phi \\mid \\phi' \\in \\mathcal{B}_i \\rangle $, and report it together with its absolute difference from the unconditional average.\n- Express all reported rates in $ \\mathrm{s}^{-1} $ as floats.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case contributing one sublist of five floats in the order specified above. For example, the output should look like $ [[r_{1,1},r_{1,2},r_{1,3},r_{1,4},r_{1,5}],[r_{2,1},r_{2,2},r_{2,3},r_{2,4},r_{2,5}],\\dots] $ with no spaces.",
            "solution": "The user wants to solve a computational physics problem involving the diffusion of a passive scalar in a three-dimensional periodic domain. The problem requires the implementation of several numerical and analytical concepts from transport phenomena and data analysis.\n\n### I. Problem Validation\n\nThe problem statement has been evaluated against the specified criteria and is determined to be **valid**.\n\n1.  **Scientific Grounding**: The problem is based on the fundamental heat/diffusion equation, $ \\partial_t \\phi = D_\\phi \\nabla^2 \\phi $, a cornerstone of transport phenomena. Key concepts such as the scalar fluctuation field $ \\phi' $, the scalar dissipation rate $ \\chi_\\phi $, and the relationship between the decay of scalar variance and the mean dissipation rate, $ d\\langle \\phi'^2 \\rangle/dt = -\\langle \\chi_\\phi \\rangle $, are standard and correct within this framework. The use of a Fourier series representation for the initial scalar field and its analytical time evolution is a sound and standard method for problems on periodic domains.\n\n2.  **Well-Posedness and Completeness**: The problem is well-posed. The initial conditions are given by analytic functions (sum of cosines), and the governing partial differential equation with periodic boundary conditions has a unique, stable solution. All necessary parameters for each of the four test cases—domain geometry, grid resolution, physical constants ($D_\\phi$), time step ($ \\Delta t $), and field composition (modes and offset)—are explicitly provided. The numerical methods for spatial and temporal derivatives, as well as for conditional averaging, are clearly defined. The problem is self-contained and free of contradictions.\n\n3.  **Objectivity and Feasibility**: The problem is stated in precise, objective, mathematical language. The tasks are algorithmic and do not permit subjective interpretation. The computational load, with the largest grid being $40 \\times 40 \\times 40$, is well within the capabilities of standard scientific computing environments and does not present any feasibility issues.\n\nIn summary, the problem is a valid and well-structured exercise in computational physics, requiring the implementation of numerical derivatives, field generation from spectral data, and statistical analysis, all grounded in established scientific principles.\n\n### II. Solution Methodology\n\nThe solution will be implemented by following the algorithmic steps outlined in the problem statement for each test case.\n\n1.  **Grid and Field Generation**: For each test case, a uniform 3D Cartesian grid will be constructed with coordinates $(x, y, z)$. The scalar field $\\phi(\\mathbf{x}, t)$ will be generated at three time instances, $t=0$, $t=\\Delta t$, and $t=2\\Delta t$, by summing the contributions from the specified cosine modes. Each mode's amplitude $A_m$ decays in time according to the analytical solution of the diffusion equation, scaling by $\\exp(-D_\\phi \\|\\mathbf{k}_m\\|^2 t)$, where $\\mathbf{k}_m$ is the wavevector of the mode.\n    $$ \\phi(\\mathbf{x}, t) = \\text{offset} + \\sum_{m} A_m \\exp\\left(-D_\\phi \\left\\| \\mathbf{k}_m \\right\\|^2 t\\right) \\cos(\\mathbf{k}_m \\cdot \\mathbf{x}) $$\n    where $\\mathbf{k}_m = \\left( \\frac{2\\pi n_{m,x}}{L_x}, \\frac{2\\pi n_{m,y}}{L_y}, \\frac{2\\pi n_{m,z}}{L_z} \\right)$.\n\n2.  **Fluctuation and Variance Calculation**: At each of the three time steps, the spatial mean $\\langle\\phi\\rangle(t)$ is computed and subtracted from the field to obtain the fluctuation field $\\phi'(\\mathbf{x}, t) = \\phi(\\mathbf{x}, t) - \\langle\\phi\\rangle(t)$. The scalar variance is then computed as the spatial average of the squared fluctuation field, $\\langle\\phi'^2\\rangle(t) = \\langle (\\phi'(\\mathbf{x}, t))^2 \\rangle$.\n\n3.  **Variance Decay Rate Estimation**: The instantaneous rate of decay of the scalar variance at the middle time step, $t=\\Delta t$, is estimated using a second-order central difference formula applied to the time series of the variance:\n    $$ R_{\\text{decay}} = - \\frac{d\\langle\\phi'^2\\rangle}{dt}\\bigg|_{t=\\Delta t} \\approx - \\frac{\\langle\\phi'^2\\rangle(2\\Delta t) - \\langle\\phi'^2\\rangle(0)}{2\\Delta t} $$\n\n4.  **Spatially Averaged Scalar Dissipation Rate**: This is calculated at $t = \\Delta t$. First, the gradient of the fluctuation field, $\\nabla\\phi'(\\mathbf{x}, \\Delta t)$, is computed numerically using a second-order central difference scheme with periodic boundary conditions. For a component, e.g., in the $x$-direction, at grid point $i$:\n    $$ \\frac{\\partial \\phi'}{\\partial x}\\bigg|_i \\approx \\frac{\\phi'_{i+1} - \\phi'_{i-1}}{2\\Delta x} $$\n    The pointwise scalar dissipation rate is then calculated:\n    $$ \\chi_\\phi(\\mathbf{x}, \\Delta t) = 2 D_\\phi \\left\\| \\nabla\\phi'(\\mathbf{x}, \\Delta t) \\right\\|^2 = 2 D_\\phi \\left[ \\left(\\frac{\\partial \\phi'}{\\partial x}\\right)^2 + \\left(\\frac{\\partial \\phi'}{\\partial y}\\right)^2 + \\left(\\frac{\\partial \\phi'}{\\partial z}\\right)^2 \\right] $$\n    Finally, its spatial average, $\\langle\\chi_\\phi\\rangle(\\Delta t)$, is computed. This result is compared with $R_{\\text{decay}}$ by calculating their absolute difference.\n\n5.  **Conditional Scalar Dissipation Rate**: At $t = \\Delta t$, the range of the fluctuation field, $[\\min(\\phi'), \\max(\\phi')]$, is divided into $8$ equal-width bins, $\\mathcal{B}_i$ for $i=1, \\dots, 8$. For each grid point, we determine which bin its $\\phi'$ value falls into. Then, for each bin $\\mathcal{B}_i$, we compute two quantities:\n    - The probability of a point falling into the bin, $p_i = N_i / N_{\\text{total}}$, where $N_i$ is the number of points in bin $i$.\n    - The conditional average of the dissipation rate, $\\langle\\chi_\\phi | \\phi' \\in \\mathcal{B}_i\\rangle$, by averaging $\\chi_\\phi$ over all points in bin $i$.\n\n    An alternative estimate of the mean dissipation rate is then constructed by summing the conditional averages weighted by their respective probabilities, which is a discrete representation of the law of total expectation:\n    $$ \\langle\\chi_\\phi\\rangle_{\\text{cond-int}} = \\sum_{i=1}^8 p_i \\langle\\chi_\\phi | \\phi' \\in \\mathcal{B}_i\\rangle $$\n    This value is expected to be numerically very close to the direct spatial average $\\langle\\chi_\\phi\\rangle(\\Delta t)$. The absolute difference between these two estimates is calculated.\n\nThese five floating-point values—$\\langle\\chi_\\phi\\rangle(\\Delta t)$, $R_{\\text{decay}}$, their absolute difference, $\\langle\\chi_\\phi\\rangle_{\\text{cond-int}}$, and its absolute difference from $\\langle\\chi_\\phi\\rangle(\\Delta t)$—are computed for each test case and formatted as required.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for scalar dissipation rate calculations.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case 1 (single-wavenumber)\",\n            \"domain_lengths\": (1.0, 1.0, 1.0),\n            \"grid_points\": (32, 32, 32),\n            \"diffusivity\": 1.0e-4,\n            \"time_step\": 0.05,\n            \"offset\": 0.0,\n            \"modes\": [\n                (1.0, (1, 0, 0)),\n                (1.0, (0, 1, 0)),\n                (1.0, (0, 0, 1))\n            ]\n        },\n        {\n            \"name\": \"Case 2 (multi-wavenumber)\",\n            \"domain_lengths\": (2.0, 2.0, 2.0),\n            \"grid_points\": (40, 40, 40),\n            \"diffusivity\": 5.0e-4,\n            \"time_step\": 0.02,\n            \"offset\": 0.5,\n            \"modes\": [\n                (0.7, (1, 2, 0)),\n                (0.3, (0, 1, 3))\n            ]\n        },\n        {\n            \"name\": \"Case 3 (uniform field)\",\n            \"domain_lengths\": (1.0, 1.0, 1.0),\n            \"grid_points\": (16, 16, 16),\n            \"diffusivity\": 1.0e-3,\n            \"time_step\": 0.1,\n            \"offset\": 2.0,\n            \"modes\": []\n        },\n        {\n            \"name\": \"Case 4 (anisotropic)\",\n            \"domain_lengths\": (1.0, 1.5, 0.5),\n            \"grid_points\": (24, 36, 12),\n            \"diffusivity\": 2.0e-4,\n            \"time_step\": 0.03,\n            \"offset\": 0.1,\n            \"modes\": [\n                (0.8, (2, 1, 0)),\n                (0.5, (0, 3, 2))\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        Ls = np.array(case[\"domain_lengths\"])\n        Ns = np.array(case[\"grid_points\"])\n        D_phi = case[\"diffusivity\"]\n        dt = case[\"time_step\"]\n        offset = case[\"offset\"]\n        modes = case[\"modes\"]\n        \n        deltas = Ls / Ns\n        \n        coords = [np.arange(N) * d for N, d in zip(Ns, deltas)]\n        X, Y, Z = np.meshgrid(coords[0], coords[1], coords[2], indexing='ij')\n\n        def generate_phi(t):\n            field = np.full(Ns, offset, dtype=float)\n            if not modes:\n                return field\n            \n            for A, n in modes:\n                n = np.array(n)\n                k = 2. * np.pi * n / Ls\n                k_norm_sq = np.sum(k**2)\n                decay = np.exp(-D_phi * k_norm_sq * t)\n                kx_x = k[0] * X\n                ky_y = k[1] * Y\n                kz_z = k[2] * Z\n                field += A * decay * np.cos(kx_x + ky_y + kz_z)\n            return field\n\n        phi_0 = generate_phi(0)\n        phi_1 = generate_phi(dt)\n        phi_2 = generate_phi(2 * dt)\n        \n        # Fluctuation fields and variances\n        phi_prime_0 = phi_0 - phi_0.mean()\n        phi_prime_1 = phi_1 - phi_1.mean()\n        phi_prime_2 = phi_2 - phi_2.mean()\n        \n        var_0 = np.mean(phi_prime_0**2)\n        var_1 = np.mean(phi_prime_1**2)\n        var_2 = np.mean(phi_prime_2**2)\n        \n        # Result 2: Estimated decay rate of variance\n        rate_decay_var = -(var_2 - var_0) / (2 * dt)\n\n        # Gradients of phi_prime at t=dt for dissipation calculation\n        grad_x = (np.roll(phi_prime_1, -1, axis=0) - np.roll(phi_prime_1, 1, axis=0)) / (2 * deltas[0])\n        grad_y = (np.roll(phi_prime_1, -1, axis=1) - np.roll(phi_prime_1, 1, axis=1)) / (2 * deltas[1])\n        grad_z = (np.roll(phi_prime_1, -1, axis=2) - np.roll(phi_prime_1, 1, axis=2)) / (2 * deltas[2])\n        \n        grad_phi_prime_norm_sq = grad_x**2 + grad_y**2 + grad_z**2\n        \n        chi_phi_1 = 2 * D_phi * grad_phi_prime_norm_sq\n        \n        # Result 1: Spatially averaged dissipation rate\n        avg_chi_phi = np.mean(chi_phi_1)\n        \n        # Result 3: Absolute difference between dissipation and variance decay rate\n        abs_diff_rates = np.abs(avg_chi_phi - rate_decay_var)\n\n        # Conditional analysis\n        phi_prime_1_flat = phi_prime_1.flatten()\n        chi_phi_1_flat = chi_phi_1.flatten()\n        \n        min_phi_p = phi_prime_1_flat.min()\n        max_phi_p = phi_prime_1_flat.max()\n        \n        num_bins = 8\n        cond_integral_est = 0.0\n        \n        if np.isclose(min_phi_p, max_phi_p):\n            # Uniform field, dissipation is zero everywhere\n            cond_integral_est = 0.0\n        else:\n            bin_edges = np.linspace(min_phi_p, max_phi_p, num_bins + 1)\n            # Ensure the max value is included in the last bin\n            bin_edges[-1] += 1e-9 * (max_phi_p - min_phi_p) if (max_phi_p - min_phi_p) > 0 else 1e-9\n            \n            digitized = np.digitize(phi_prime_1_flat, bin_edges)\n            \n            for i in range(1, num_bins + 1):\n                indices = np.where(digitized == i)[0]\n                count = len(indices)\n                if count > 0:\n                    p_i = count / phi_prime_1_flat.size\n                    cond_avg_chi = np.mean(chi_phi_1_flat[indices])\n                    cond_integral_est += p_i * cond_avg_chi\n        \n        # Result 4: Conditional-integral estimate\n        # This is already captured in cond_integral_est\n        \n        # Result 5: Absolute difference between conditional and unconditional averages\n        abs_diff_cond_uncond = np.abs(cond_integral_est - avg_chi_phi)\n        \n        results.append([\n            avg_chi_phi,\n            rate_decay_var,\n            abs_diff_rates,\n            cond_integral_est,\n            abs_diff_cond_uncond\n        ])\n        \n    # Format the final output string exactly as specified\n    output_str = repr(results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "In practice, data from direct numerical simulations or experiments are obtained as scattered points in a multi-dimensional space. This exercise tackles the essential task of processing such data to construct the one-dimensional conditional profiles, like $\\langle \\chi_Z|z \\rangle$, that form the basis of many turbulent combustion models. You will implement a binning strategy to estimate conditional and Favre averages, confronting practical issues like empty bins and quantifying the inherent bias in the estimation process .",
            "id": "4041886",
            "problem": "You are given independent and identically distributed samples of a mixture fraction, a scalar quantity, and a density, represented as triples $\\{(Z_i, A_i, \\rho_i)\\}_{i=1}^N$, where $Z_i \\in [0,1]$ is the mixture fraction, $A_i$ is a non-dimensional scalar dissipation rate, and $\\rho_i$ is a non-dimensional density. The goal is to compute estimates of the conditional expectation $\\langle A \\mid Z = z \\rangle$ and the conditional Favre average $\\tilde{A}(z)$ on a discretized $z$-grid using a binning strategy, and to assess the estimation bias. The conditional Favre average is defined as $\\tilde{A}(z) = \\dfrac{\\langle \\rho A \\mid Z = z \\rangle}{\\langle \\rho \\mid Z = z \\rangle}$, where $\\langle \\cdot \\mid Z = z \\rangle$ denotes the conditional expectation given $Z = z$. The assessment must quantify the bias attributable to bin width and finite sampling.\n\nThe fundamental base for this problem consists of:\n- The definition of conditional expectation $\\langle A \\mid Z = z \\rangle$ as the expectation of $A$ over realizations with mixture fraction $Z$ equal to $z$.\n- The definition of the conditional Favre average $\\tilde{A}(z)$ as the density-weighted conditional average, $\\tilde{A}(z) = \\dfrac{\\langle \\rho A \\mid Z = z \\rangle}{\\langle \\rho \\mid Z = z \\rangle}$.\n- The use of histogram binning (a rectangular kernel) to approximate conditional expectations on a finite $z$-grid, recognizing that binning induces a deterministic bias that depends on the bin width, as well as a stochastic error due to finite sampling.\n\nYou must design and implement an algorithm satisfying all of the following requirements:\n- Construct a discretized $z$-grid covering the interval $[0,1]$ by partitioning it into $K$ equal-width bins with width $h = 1/K$, and define the estimator locations at the bin centers.\n- For each estimator location (each bin), compute:\n  1. An estimate of $\\langle A \\mid Z = z \\rangle$ using data falling in that bin.\n  2. An estimate of $\\tilde{A}(z)$ using data falling in that bin.\n- Provide a robust method for handling bins with zero samples, by defining a deterministic interpolation or extrapolation procedure that yields finite estimators for all bins.\n- Quantify the estimation bias at each grid location by comparing the estimators to ground-truth conditional functions defined below. From these biases, compute:\n  - The maximum absolute bias over all bins for the conditional expectation estimator.\n  - The maximum absolute bias over all bins for the conditional Favre average estimator.\n- Provide an assessment of bin-induced bias using the leading-order deterministic binning bias for a rectangular kernel. For a smooth target function $f(z)$ and symmetric bins, the leading binning bias scales with $h^2$ and is proportional to the second derivative $f''(z)$, so the bin-induced bias magnitude at grid points is approximately $\\left|\\dfrac{h^2}{24} f''(z)\\right|$. For the conditional Favre average, apply the same leading-order assessment to its true conditional function, denoted below by $g(z)$.\n- Report, for each test case, four floats in the order: $\\text{max\\_abs\\_bias\\_unweighted}$, $\\text{max\\_abs\\_bias\\_favre}$, $\\text{predicted\\_bin\\_bias\\_max\\_unweighted}$, $\\text{predicted\\_bin\\_bias\\_max\\_favre}$.\n\nUse the following generative model and test suite for evaluation:\n- The ground-truth functions are\n  $$ f(z) = 0.4 + 0.5 z + 0.15 \\sin(2\\pi z), \\quad r(z) = 1.0 + 0.4 \\cos(2\\pi z), $$\n  with $r(z) > 0$ for all $z \\in [0,1]$.\n- The sampling model is\n  $$ Z_i \\sim \\operatorname{Beta}(\\alpha, \\beta), $$\n  $$ \\begin{pmatrix} \\eta_i \\\\ \\xi_i \\end{pmatrix} \\sim \\mathcal{N}\\left( \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}, \\begin{pmatrix} \\sigma_A^2 & c\\,\\sigma_A \\sigma_\\rho \\\\ c\\,\\sigma_A \\sigma_\\rho & \\sigma_\\rho^2 \\end{pmatrix} \\right), $$\n  $$ A_i = f(Z_i) + \\eta_i, \\quad \\rho_i = r(Z_i) + \\xi_i, $$\n  where $\\eta_i$ and $\\xi_i$ are jointly Gaussian with correlation coefficient $c \\in [-1,1]$, and $\\sigma_A > 0$, $\\sigma_\\rho > 0$ are standard deviations. The true conditional expectation is $\\langle A \\mid Z = z \\rangle = f(z)$. The true conditional Favre function is\n  $$ g(z) = \\frac{\\langle \\rho A \\mid Z = z \\rangle}{\\langle \\rho \\mid Z = z \\rangle} = f(z) + \\frac{\\operatorname{Cov}(\\eta,\\xi)}{r(z)} = f(z) + \\frac{c\\,\\sigma_A \\sigma_\\rho}{r(z)}. $$\n\nImplement the following test suite of parameter values. For each case, set the random number generator seed to ensure reproducibility, then sample $\\{(Z_i,A_i,\\rho_i)\\}_{i=1}^N$ and perform the estimation and bias assessment as specified:\n- Case 1 (general case): $N = 12000$, $K = 60$, $(\\alpha,\\beta) = (2,5)$, $\\sigma_A = 0.08$, $\\sigma_\\rho = 0.06$, $c = 0.5$, seed $= 12345$.\n- Case 2 (boundary-heavy $Z$ and uncorrelated noise): $N = 1000$, $K = 40$, $(\\alpha,\\beta) = (0.5,0.5)$, $\\sigma_A = 0.15$, $\\sigma_\\rho = 0.10$, $c = 0.0$, seed $= 23456$.\n- Case 3 (narrow bins, moderate $N$, correlated noise): $N = 6000$, $K = 200$, $(\\alpha,\\beta) = (3,3)$, $\\sigma_A = 0.04$, $\\sigma_\\rho = 0.04$, $c = 0.7$, seed $= 34567$.\n- Case 4 (small $N$, strongly skewed $Z$): $N = 300$, $K = 30$, $(\\alpha,\\beta) = (5,1)$, $\\sigma_A = 0.12$, $\\sigma_\\rho = 0.08$, $c = 0.3$, seed $= 45678$.\n\nAlgorithmic requirements and output:\n- Construct $K$ equal-width bins on $[0,1]$, compute estimates at bin centers, and handle empty bins deterministically using interpolation from neighboring non-empty bins.\n- Compute the per-bin biases by subtracting the ground-truth conditional functions $f(z)$ and $g(z)$ from the corresponding estimators.\n- Compute the four floats for each case in the order specified above.\n- Your program should produce a single line of output containing the results as a comma-separated list of case results, each case result being a comma-separated list of four floats, all enclosed in square brackets, with no spaces. For example: \"[[c1_1,c1_2,c1_3,c1_4],[c2_1,c2_2,c2_3,c2_4],[c3_1,c3_2,c3_3,c3_4],[c4_1,c4_2,c4_3,c4_4]]\".\nAll quantities in this problem are non-dimensional, so no physical units are needed. Angles, where present inside trigonometric functions, are in radians by construction.",
            "solution": "The problem requires the implementation and assessment of a binning-based estimation strategy for conditional expectations and conditional Favre averages from a set of scattered data samples. The validation confirms that the problem is well-posed, scientifically grounded in statistical estimation theory and computational combustion modeling, and provides a complete specification for a reproducible numerical experiment. We may therefore proceed with a solution.\n\nThe core of the problem is to estimate the conditional expectation of a scalar $A$, denoted $\\langle A \\mid Z=z \\rangle$, and its density-weighted counterpart, the conditional Favre average $\\tilde{A}(z)$, from a finite set of $N$ data triples $\\{(Z_i, A_i, \\rho_i)\\}_{i=1}^N$. Here, $Z$ is the conditioning variable (mixture fraction), $A$ is a scalar quantity, and $\\rho$ is the density.\n\n### Ground-Truth Model\nThe data is generated from a known underlying model, which provides the ground truth for our assessment. The true conditional means are given by:\n- $\\langle A \\mid Z=z \\rangle = f(z) = 0.4 + 0.5z + 0.15\\sin(2\\pi z)$\n- $\\langle \\rho \\mid Z=z \\rangle = r(z) = 1.0 + 0.4\\cos(2\\pi z)$\n\nThe samples themselves are generated by adding correlated zero-mean Gaussian noise to these functions:\n$A_i = f(Z_i) + \\eta_i$\n$\\rho_i = r(Z_i) + \\xi_i$\nwhere $(\\eta_i, \\xi_i)$ are drawn from a bivariate normal distribution with covariance $c\\sigma_A\\sigma_\\rho$. The mixture fraction samples $Z_i$ are drawn from a Beta distribution, $Z_i \\sim \\operatorname{Beta}(\\alpha, \\beta)$.\n\nFrom these definitions, the true conditional Favre average $\\tilde{A}(z)$ can be derived as:\n$$\n\\tilde{A}(z) = \\frac{\\langle \\rho A \\mid Z=z \\rangle}{\\langle \\rho \\mid Z=z \\rangle} = \\frac{\\langle (r(z) + \\xi)(f(z) + \\eta) \\mid Z=z \\rangle}{r(z)}\n$$\nExpanding the numerator and using the statistical independence of the noise terms $(\\eta, \\xi)$ from $Z$, and their zero-mean property ($\\langle\\eta\\rangle = \\langle\\xi\\rangle = 0$), we get:\n$$\n\\langle \\rho A \\mid Z=z \\rangle = r(z)f(z) + \\langle \\eta\\xi \\rangle = r(z)f(z) + \\mathrm{Cov}(\\eta, \\xi)\n$$\nThe covariance is given as $\\mathrm{Cov}(\\eta, \\xi) = c\\sigma_A\\sigma_\\rho$. Therefore, the true conditional Favre average, which we denote $g(z)$, is:\n$$\ng(z) = \\tilde{A}(z) = f(z) + \\frac{c\\sigma_A\\sigma_\\rho}{r(z)}\n$$\nSince $r(z) = 1.0 + 0.4\\cos(2\\pi z) \\ge 1.0 - 0.4 = 0.6 > 0$, the function $g(z)$ is well-defined for all $z \\in [0,1]$.\n\n### Estimation Algorithm\nThe estimation procedure uses a histogram-based (binning) method on a uniform grid.\n\n1.  **Grid Construction**: The conditioning variable's domain, $[0,1]$, is partitioned into $K$ bins, $\\{B_k\\}_{k=1}^K$, of equal width $h = 1/K$. The $k$-th bin is defined as $B_k = [ (k-1)h, kh )$ for $k=1, \\dots, K-1$, and $B_K = [(K-1)h, Kh]$. The estimator is evaluated at the center of each bin, $z_k = (k-0.5)h$.\n\n2.  **Binned Estimators**: For each bin $B_k$, we find the subset of data samples $S_k = \\{i \\mid Z_i \\in B_k\\}$ and its size $N_k = |S_k|$.\n    - The estimator for the conditional expectation $\\langle A \\mid Z=z_k \\rangle$ is the sample mean of $A_i$ for points in the bin:\n      $$ \\hat{A}_k = \\frac{1}{N_k} \\sum_{i \\in S_k} A_i $$\n    - The estimator for the conditional Favre average $\\tilde{A}(z_k)$ is the ratio of the sample mean of $\\rho A$ to the sample mean of $\\rho$:\n      $$ \\hat{\\tilde{A}}_k = \\frac{\\frac{1}{N_k} \\sum_{i \\in S_k} \\rho_i A_i}{\\frac{1}{N_k} \\sum_{i \\in S_k} \\rho_i} = \\frac{\\sum_{i \\in S_k} \\rho_i A_i}{\\sum_{i \\in S_k} \\rho_i} $$\n    If a bin $B_k$ is empty ($N_k=0$), these estimators are undefined.\n\n3.  **Handling Empty Bins**: When $N_k=0$, the direct estimators result in indeterminate forms. A deterministic procedure is required. We first compute the estimates for all non-empty bins. Then, for any empty bin, its value is estimated using linear interpolation between the values of the nearest non-empty neighboring bins. For empty bins at the boundaries of the domain (i.e., before the first non-empty bin or after the last one), the value of the nearest non-empty bin is used for extrapolation.\n\n### Bias Assessment\nThe total error in the estimators at each grid point $z_k$ is the sum of a deterministic bias (due to the bin width $h$) and a stochastic error (due to finite sample size $N$). The total bias is computed by comparing the final estimates (after interpolation) with the true functions evaluated at the bin centers:\n- Bias for unweighted average: $\\mathcal{B}_A(z_k) = \\hat{A}_k - f(z_k)$\n- Bias for Favre average: $\\mathcal{B}_{\\tilde{A}}(z_k) = \\hat{\\tilde{A}}_k - g(z_k)$\n\nThe problem requires reporting the maximum absolute value of these biases over all bins, $k=1, \\dots, K$.\n\nFurthermore, a theoretical prediction for the leading-order deterministic binning bias is required. For a sufficiently smooth function and a symmetric binning kernel, this bias at a point $z$ is approximately $\\frac{h^2}{24} \\ddot{F}(z)$, where $\\ddot{F}$ is the second derivative of the true conditional function.\n- For the unweighted average, the predicted bias magnitude is $\\left|\\frac{h^2}{24} f''(z)\\right|$.\n- For the Favre average, the predicted bias magnitude is $\\left|\\frac{h^2}{24} g''(z)\\right|$.\n\nThe required second derivatives are:\n- $f''(z) = \\frac{d^2}{dz^2} (0.4 + 0.5z + 0.15\\sin(2\\pi z)) = -0.15(2\\pi)^2\\sin(2\\pi z) = -0.6\\pi^2\\sin(2\\pi z)$\n- To find $g''(z)$, we differentiate $g(z) = f(z) + C r(z)^{-1}$, where $C=c\\sigma_A\\sigma_\\rho$.\n  $$ g''(z) = f''(z) + C \\frac{d^2}{dz^2}(r(z)^{-1}) = f''(z) + C \\left[ 2 \\frac{(r'(z))^2}{r(z)^3} - \\frac{r''(z)}{r(z)^2} \\right] $$\n  with $r(z) = 1.0 + 0.4\\cos(2\\pi z)$, $r'(z) = -0.8\\pi\\sin(2\\pi z)$, and $r''(z) = -1.6\\pi^2\\cos(2\\pi z)$.\n\nThe algorithm computes the maximum of these predicted bias magnitudes over the grid points $z_k$. This provides a theoretical baseline for the part of the error attributable to the coarseness of the grid, separately from the statistical sampling error.\n\n### Implementation Summary\nThe solution is implemented in Python using the `numpy` and `scipy` libraries. For each test case:\n1.  A random number generator is seeded for reproducibility.\n2.  $N$ samples of $(Z_i, A_i, \\rho_i)$ are generated according to the specified model.\n3.  The `scipy.stats.binned_statistic` function is used to efficiently compute the sums of $A_i$, $\\rho_i$, and $\\rho_i A_i$, as well as the sample count $N_k$, in each of the $K$ bins.\n4.  The estimates $\\hat{A}_k$ and $\\hat{\\tilde{A}}_k$ are calculated. This produces `NaN` values for empty bins.\n5.  `numpy.interp` is used to fill the `NaN` values using linear interpolation and constant extrapolation.\n6.  The true functions $f(z)$ and $g(z)$ are evaluated at the bin centers to compute the actual estimation bias.\n7.  The theoretical binning bias is calculated using the analytical second derivatives $f''(z)$ and $g''(z)$.\n8.  The maximum absolute values for both the actual and predicted biases are determined and stored.\nFinally, the results for all test cases are formatted into a single string as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import binned_statistic\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: general case\n        {'N': 12000, 'K': 60, 'alpha': 2, 'beta': 5, 'sigma_A': 0.08, 'sigma_rho': 0.06, 'c': 0.5, 'seed': 12345},\n        # Case 2: boundary-heavy Z and uncorrelated noise\n        {'N': 1000, 'K': 40, 'alpha': 0.5, 'beta': 0.5, 'sigma_A': 0.15, 'sigma_rho': 0.10, 'c': 0.0, 'seed': 23456},\n        # Case 3: narrow bins, moderate N, correlated noise\n        {'N': 6000, 'K': 200, 'alpha': 3, 'beta': 3, 'sigma_A': 0.04, 'sigma_rho': 0.04, 'c': 0.7, 'seed': 34567},\n        # Case 4: small N, strongly skewed Z\n        {'N': 300, 'K': 30, 'alpha': 5, 'beta': 1, 'sigma_A': 0.12, 'sigma_rho': 0.08, 'c': 0.3, 'seed': 45678},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_case(**params)\n        all_results.append(result)\n\n    # Format the final output string as a list of lists, with no spaces.\n    results_str = str(all_results).replace(\" \", \"\")\n    print(results_str)\n\ndef run_case(N, K, alpha, beta, sigma_A, sigma_rho, c, seed):\n    \"\"\"\n    Performs the full simulation and analysis for a single test case.\n    \"\"\"\n    # 1. Setup and Ground Truth Functions\n    rng = np.random.default_rng(seed)\n    h = 1.0 / K\n    \n    # Ground-truth function for <A|Z=z>\n    def f(z):\n        return 0.4 + 0.5 * z + 0.15 * np.sin(2 * np.pi * z)\n\n    # Ground-truth function for <rho|Z=z>\n    def r(z):\n        return 1.0 + 0.4 * np.cos(2 * np.pi * z)\n\n    # Ground-truth function for Favre average g(z)\n    def g(z):\n        cov_eta_xi = c * sigma_A * sigma_rho\n        return f(z) + cov_eta_xi / r(z)\n\n    # 2. Data Generation\n    # Generate mixture fraction samples\n    Z_samples = rng.beta(alpha, beta, size=N)\n\n    # Generate correlated Gaussian noise\n    mean_noise = [0, 0]\n    cov_matrix = [\n        [sigma_A**2, c * sigma_A * sigma_rho],\n        [c * sigma_A * sigma_rho, sigma_rho**2]\n    ]\n    eta_samples, xi_samples = rng.multivariate_normal(mean_noise, cov_matrix, size=N).T\n\n    # Generate A and rho samples\n    A_samples = f(Z_samples) + eta_samples\n    rho_samples = r(Z_samples) + xi_samples\n\n    # 3. Binning and Estimation\n    bin_edges = np.linspace(0.0, 1.0, K + 1)\n    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2.0\n\n    # Use binned_statistic to compute sums and counts\n    counts, _, _ = binned_statistic(Z_samples, A_samples, statistic='count', bins=bin_edges)\n    sum_A, _, _ = binned_statistic(Z_samples, A_samples, statistic='sum', bins=bin_edges)\n    sum_rho, _, _ = binned_statistic(Z_samples, rho_samples, statistic='sum', bins=bin_edges)\n    sum_rhoA, _, _ = binned_statistic(Z_samples, rho_samples * A_samples, statistic='sum', bins=bin_edges)\n\n    # Calculate estimators, handling empty bins by producing NaN\n    with np.errstate(divide='ignore', invalid='ignore'):\n        A_est = np.divide(sum_A, counts)\n        A_favre_est = np.divide(sum_rhoA, sum_rho)\n\n    # 4. Handle Empty Bins with Interpolation\n    def interpolate_nans(y, x):\n        nan_mask = np.isnan(y)\n        if np.all(nan_mask): # All bins are empty\n            return np.zeros_like(y)\n        y[nan_mask] = np.interp(x[nan_mask], x[~nan_mask], y[~nan_mask])\n        return y\n\n    A_est = interpolate_nans(A_est, bin_centers)\n    A_favre_est = interpolate_nans(A_favre_est, bin_centers)\n\n    # 5. Bias Calculation\n    # Evaluate true functions at bin centers\n    f_true = f(bin_centers)\n    g_true = g(bin_centers)\n\n    # Calculate maximum absolute bias\n    max_abs_bias_unweighted = np.max(np.abs(A_est - f_true))\n    max_abs_bias_favre = np.max(np.abs(A_favre_est - g_true))\n\n    # 6. Predicted Bin Bias Calculation\n    # Second derivative functions\n    def f_pp(z):\n        return -0.15 * (2 * np.pi)**2 * np.sin(2 * np.pi * z)\n\n    def g_pp(z):\n        const_C = c * sigma_A * sigma_rho\n        if const_C == 0:\n            return f_pp(z)\n        \n        rz = r(z)\n        rp_z = -0.8 * np.pi * np.sin(2 * np.pi * z)\n        rpp_z = -1.6 * np.pi**2 * np.cos(2 * np.pi * z)\n        \n        term1 = 2 * (rp_z**2) / (rz**3)\n        term2 = rpp_z / (rz**2)\n        \n        return f_pp(z) + const_C * (term1 - term2)\n\n    # Predicted bias magnitudes\n    pred_bias_unweighted = np.abs((h**2 / 24.0) * f_pp(bin_centers))\n    pred_bias_favre = np.abs((h**2 / 24.0) * g_pp(bin_centers))\n\n    # Maximum predicted biases\n    predicted_bin_bias_max_unweighted = np.max(pred_bias_unweighted)\n    predicted_bin_bias_max_favre = np.max(pred_bias_favre)\n\n    return [\n        max_abs_bias_unweighted,\n        max_abs_bias_favre,\n        predicted_bin_bias_max_unweighted,\n        predicted_bin_bias_max_favre\n    ]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Closure models, like those for the conditional scalar dissipation rate $\\langle \\chi_Z | z \\rangle$, are the heart of many advanced combustion theories, but how sensitive are the final predictions to the specific form of the model? This practice employs perturbation analysis, a powerful mathematical tool, to directly investigate the impact of the dissipation profile's shape on the solution of the Conditional Moment Closure (CMC) equations. This analysis reveals the functional link between the closure model and the predicted scalar profiles, underscoring the importance of accurate dissipation rate modeling .",
            "id": "4041919",
            "problem": "Consider a statistically steady, non-premixed flow in which the mixture fraction $z \\in [0,1]$ is a conserved scalar, and let $\\tilde{\\phi}(z)$ denote the conditional mean of a passive scalar given mixture fraction $z$ within the framework of Conditional Moment Closure (CMC), defined here as the conditional averaging of the scalar transport equation over level sets of $z$. Under unity Lewis number, constant density, and negligible conditional source terms for the passive scalar, the transport in mixture-fraction space is governed by conservation of a diffusive micro-mixing flux associated with the conditional scalar dissipation rate $\\langle \\chi_Z \\mid z \\rangle$.\n\nYou are asked to analyze the sensitivity of the CMC solution $\\tilde{\\phi}(z)$ to changes in the shape of $\\langle \\chi_Z \\mid z \\rangle$ via a first-order perturbation analysis about a baseline profile. Assume the following scientifically consistent setup:\n\n- Baseline conditional scalar dissipation rate is uniform: $\\langle \\chi_Z \\mid z \\rangle = \\chi_0$, with $\\chi_0 > 0$ constant.\n- Boundary conditions on the passive scalar are Dirichlet: $\\tilde{\\phi}(0) = 0$ and $\\tilde{\\phi}(1) = 1$.\n- A small shape perturbation modifies the dissipation rate to $\\langle \\chi_Z \\mid z \\rangle = \\chi_0 \\left(1 + \\epsilon h(z)\\right)$, where $0 < \\epsilon \\ll 1$ is a dimensionless amplitude and $h(z)$ is a prescribed dimensionless shape function.\n- Take $h(z) = \\sin(\\pi z)$.\n\nStarting from fundamental conservation of diffusive flux in mixture-fraction space and using first principles (do not invoke pre-derived shortcut formulas), perform a first-order perturbation analysis in $\\epsilon$ to obtain the leading-order change $\\Delta \\tilde{\\phi}(z)$ in the CMC solution due to the perturbation in $\\langle \\chi_Z \\mid z \\rangle$. Then, evaluate this leading-order change at $z = \\frac{1}{4}$.\n\nExpress your final answer as a single exact analytical expression for $\\Delta \\tilde{\\phi}\\!\\left(\\frac{1}{4}\\right)$ to first order in $\\epsilon$. Do not round; no units are required because $\\tilde{\\phi}$ is non-dimensional by construction.",
            "solution": "The user has requested an analysis of a problem in computational combustion. The first step is a mandatory validation of the problem statement.\n\n### Step 1: Extract Givens\n- **Framework**: Conditional Moment Closure (CMC) for a statistically steady, non-premixed flow.\n- **Variables**:\n    - Mixture fraction $z \\in [0,1]$.\n    - Conditional mean of a passive scalar: $\\tilde{\\phi}(z)$.\n    - Conditional scalar dissipation rate of mixture fraction: $\\langle \\chi_Z \\mid z \\rangle$.\n- **Assumptions**:\n    - Unity Lewis number.\n    - Constant density.\n    - Negligible conditional source terms for the passive scalar.\n- **Governing Principle**: Conservation of diffusive micro-mixing flux in mixture-fraction space.\n- **Baseline Profile**: $\\langle \\chi_Z \\mid z \\rangle = \\chi_0$, where $\\chi_0 > 0$ is a constant.\n- **Perturbed Profile**: $\\langle \\chi_Z \\mid z \\rangle = \\chi_0 \\left(1 + \\epsilon h(z)\\right)$, where $0 < \\epsilon \\ll 1$.\n- **Perturbation Shape Function**: $h(z) = \\sin(\\pi z)$.\n- **Boundary Conditions**: $\\tilde{\\phi}(0) = 0$ and $\\tilde{\\phi}(1) = 1$.\n- **Objective**: Find the leading-order change $\\Delta \\tilde{\\phi}(z)$ in the solution due to the perturbation and evaluate it at $z = \\frac{1}{4}$. The leading-order change is defined as $\\Delta \\tilde{\\phi}(z) = \\tilde{\\phi}(z) - \\tilde{\\phi}_0(z)$ to first order in $\\epsilon$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is set within the well-established framework of Conditional Moment Closure, a standard technique in turbulent combustion modeling. The concepts of mixture fraction, conditional averaging, and scalar dissipation rate are fundamental to this field. The governing equation for a passive scalar under these assumptions is a standard result.\n- **Well-Posed**: The problem reduces to solving a second-order ordinary differential equation with two Dirichlet boundary conditions. This constitutes a well-posed Sturm-Liouville boundary value problem, which guarantees a unique solution.\n- **Objective**: The problem is stated using precise, standard, and unbiased scientific terminology. All quantities are clearly defined.\n- **Completeness and Consistency**: The problem provides all necessary information: the governing physical principle, the baseline and perturbed forms of the coefficient function $\\langle \\chi_Z \\mid z \\rangle$, and the boundary conditions for the dependent variable $\\tilde{\\phi}(z)$. There are no contradictions.\n- **Feasibility**: The use of a simple sinusoidal perturbation function $h(z)$ and a uniform baseline allows for an analytical solution via a standard first-order perturbation analysis, which is a feasible mathematical task.\n\n### Step 3: Verdict and Action\nThe problem is scientifically valid, well-posed, and contains all necessary information for a unique solution. The solution process may proceed.\n\n### Solution Derivation\n\nThe transport of a passive scalar $\\phi$ in mixture fraction space, under the given assumptions (steady state, unity Lewis number, constant density $\\rho$, and negligible source term), is governed by the Conditional Moment Closure (CMC) equation for the conditional mean $\\tilde{\\phi}(z)$:\n$$\n\\frac{d}{dz} \\left( \\frac{\\rho}{2} \\langle \\chi_Z \\mid z \\rangle \\frac{d\\tilde{\\phi}}{dz} \\right) = 0\n$$\nSince $\\rho$ is a constant, it can be divided out. This equation expresses the conservation of the diffusive flux in $z$-space. Integrating once, we get:\n$$\n\\langle \\chi_Z \\mid z \\rangle \\frac{d\\tilde{\\phi}}{dz} = C\n$$\nwhere $C$ is a constant of integration.\n\nFirst, we solve for the baseline case. Let the baseline solution be $\\tilde{\\phi}_0(z)$. The baseline conditional scalar dissipation is $\\langle \\chi_Z \\mid z \\rangle = \\chi_0$. The equation becomes:\n$$\n\\chi_0 \\frac{d\\tilde{\\phi}_0}{dz} = C_0\n$$\nIntegrating with respect to $z$:\n$$\n\\tilde{\\phi}_0(z) = \\frac{C_0}{\\chi_0} z + D_0\n$$\nWe apply the boundary conditions, $\\tilde{\\phi}_0(0) = 0$ and $\\tilde{\\phi}_0(1) = 1$:\n- $\\tilde{\\phi}_0(0) = 0 \\implies D_0 = 0$.\n- $\\tilde{\\phi}_0(1) = 1 \\implies \\frac{C_0}{\\chi_0} (1) = 1 \\implies C_0 = \\chi_0$.\nThus, the baseline solution is $\\tilde{\\phi}_0(z) = z$.\n\nNext, we perform a first-order perturbation analysis. The full solution $\\tilde{\\phi}(z)$ is expanded in powers of $\\epsilon$:\n$$\n\\tilde{\\phi}(z) = \\tilde{\\phi}_0(z) + \\epsilon \\tilde{\\phi}_1(z) + \\mathcal{O}(\\epsilon^2)\n$$\nThe perturbed conditional scalar dissipation rate is $\\langle \\chi_Z \\mid z \\rangle = \\chi_0 (1 + \\epsilon h(z))$. Substituting these into the governing equation $\\langle \\chi_Z \\mid z \\rangle \\frac{d\\tilde{\\phi}}{dz} = C$:\n$$\n\\chi_0 (1 + \\epsilon h(z)) \\frac{d}{dz} \\left( \\tilde{\\phi}_0(z) + \\epsilon \\tilde{\\phi}_1(z) \\right) = C\n$$\nThe constant $C$ also depends on the perturbation, so we expand it as $C = C_0 + \\epsilon C_1 + \\mathcal{O}(\\epsilon^2)$.\n$$\n\\chi_0 (1 + \\epsilon h(z)) \\left( \\frac{d\\tilde{\\phi}_0}{dz} + \\epsilon \\frac{d\\tilde{\\phi}_1}{dz} \\right) = C_0 + \\epsilon C_1\n$$\nWe substitute $\\frac{d\\tilde{\\phi}_0}{dz} = 1$ and $C_0 = \\chi_0$:\n$$\n\\chi_0 (1 + \\epsilon h(z)) \\left( 1 + \\epsilon \\frac{d\\tilde{\\phi}_1}{dz} \\right) = \\chi_0 + \\epsilon C_1\n$$\nExpanding the left side and keeping terms up to first order in $\\epsilon$:\n$$\n\\chi_0 \\left( 1 + \\epsilon \\frac{d\\tilde{\\phi}_1}{dz} + \\epsilon h(z) + \\mathcal{O}(\\epsilon^2) \\right) = \\chi_0 + \\epsilon C_1\n$$\nWe equate terms of the same order in $\\epsilon$.\nThe zeroth-order ($\\mathcal{O}(\\epsilon^0)$) equation is $\\chi_0 = \\chi_0$, which is consistent.\nThe first-order ($\\mathcal{O}(\\epsilon^1)$) equation is:\n$$\n\\chi_0 \\left( \\frac{d\\tilde{\\phi}_1}{dz} + h(z) \\right) = C_1\n$$\n$$\n\\frac{d\\tilde{\\phi}_1}{dz} = \\frac{C_1}{\\chi_0} - h(z)\n$$\nLet $C'_1 = C_1/\\chi_0$. Integrating with respect to $z$:\n$$\n\\tilde{\\phi}_1(z) = \\int \\left( C'_1 - h(z) \\right) dz = C'_1 z - \\int h(z) dz + D_1\n$$\nWe apply the boundary conditions to the full solution $\\tilde{\\phi}(z)$. Since $\\tilde{\\phi}_0(z)$ already satisfies the inhomogeneous boundary conditions, the perturbation part $\\epsilon \\tilde{\\phi}_1(z)$ must satisfy homogeneous boundary conditions.\n- $\\tilde{\\phi}(0) = \\tilde{\\phi}_0(0) + \\epsilon \\tilde{\\phi}_1(0) = 0 \\implies \\epsilon \\tilde{\\phi}_1(0) = 0 \\implies \\tilde{\\phi}_1(0) = 0$.\n- $\\tilde{\\phi}(1) = \\tilde{\\phi}_0(1) + \\epsilon \\tilde{\\phi}_1(1) = 1 \\implies \\epsilon \\tilde{\\phi}_1(1) = 0 \\implies \\tilde{\\phi}_1(1) = 0$.\n\nNow, we substitute $h(z) = \\sin(\\pi z)$:\n$$\n\\int h(z) dz = \\int \\sin(\\pi z) dz = -\\frac{1}{\\pi} \\cos(\\pi z)\n$$\nSo the solution for $\\tilde{\\phi}_1(z)$ is:\n$$\n\\tilde{\\phi}_1(z) = C'_1 z + \\frac{1}{\\pi} \\cos(\\pi z) + D_1\n$$\nApplying the homogeneous boundary conditions for $\\tilde{\\phi}_1(z)$:\n- At $z=0$: $\\tilde{\\phi}_1(0) = 0 \\implies C'_1(0) + \\frac{1}{\\pi}\\cos(0) + D_1 = 0 \\implies \\frac{1}{\\pi} + D_1 = 0 \\implies D_1 = -\\frac{1}{\\pi}$.\n- At $z=1$: $\\tilde{\\phi}_1(1) = 0 \\implies C'_1(1) + \\frac{1}{\\pi}\\cos(\\pi) + D_1 = 0 \\implies C'_1 - \\frac{1}{\\pi} + D_1 = 0$.\nSubstituting $D_1 = -1/\\pi$:\n$$\nC'_1 - \\frac{1}{\\pi} - \\frac{1}{\\pi} = 0 \\implies C'_1 = \\frac{2}{\\pi}\n$$\nSo, the first-order correction term is:\n$$\n\\tilde{\\phi}_1(z) = \\frac{2}{\\pi}z + \\frac{1}{\\pi}\\cos(\\pi z) - \\frac{1}{\\pi} = \\frac{1}{\\pi} \\left( 2z + \\cos(\\pi z) - 1 \\right)\n$$\nThe leading-order change in the solution is $\\Delta \\tilde{\\phi}(z) = \\tilde{\\phi}(z) - \\tilde{\\phi}_0(z) \\approx \\epsilon \\tilde{\\phi}_1(z)$.\n$$\n\\Delta \\tilde{\\phi}(z) = \\frac{\\epsilon}{\\pi} \\left( 2z + \\cos(\\pi z) - 1 \\right)\n$$\nWe need to evaluate this at $z = \\frac{1}{4}$:\n$$\n\\Delta \\tilde{\\phi}\\left(\\frac{1}{4}\\right) = \\frac{\\epsilon}{\\pi} \\left( 2\\left(\\frac{1}{4}\\right) + \\cos\\left(\\frac{\\pi}{4}\\right) - 1 \\right)\n$$\n$$\n\\Delta \\tilde{\\phi}\\left(\\frac{1}{4}\\right) = \\frac{\\epsilon}{\\pi} \\left( \\frac{1}{2} + \\frac{\\sqrt{2}}{2} - 1 \\right)\n$$\n$$\n\\Delta \\tilde{\\phi}\\left(\\frac{1}{4}\\right) = \\frac{\\epsilon}{\\pi} \\left( \\frac{\\sqrt{2} - 1}{2} \\right)\n$$\n$$\n\\Delta \\tilde{\\phi}\\left(\\frac{1}{4}\\right) = \\frac{\\epsilon(\\sqrt{2}-1)}{2\\pi}\n$$\nThis is the final analytical expression for the leading-order change at the specified point.",
            "answer": "$$\n\\boxed{\\frac{\\epsilon(\\sqrt{2}-1)}{2\\pi}}\n$$"
        }
    ]
}