{
    "hands_on_practices": [
        {
            "introduction": "在滤波密度函数（FDF）方法中，我们使用一组拉格朗日粒子来表示亚格子尺度上的标量统计信息。这种基于蒙特卡洛的方法的一个核心实践问题是：需要多少粒子才能达到可接受的统计精度？本练习将指导您应用中心极限定理，建立统计误差、置信水平和样本量$N$之间的联系，这是设计和评估FDF模拟的一项基本技能。",
            "id": "4024881",
            "problem": "在湍流反应流的大涡模拟（LES）中，采用一种基于颗粒的滤波密度函数（FDF）方法来估计Favre滤波标量场。Favre滤波标量的定义为 $\\tilde{\\phi} = \\overline{\\rho \\phi}/\\overline{\\rho}$，其中 $\\rho$ 是密度，$\\phi$ 是一个标量（例如，混合分数），上划线表示空间滤波。在给定时间的单个LES控制体内，从滤波密度函数中抽取 $N$ 个独立的颗粒实现 $\\{\\phi_{i}\\}_{i=1}^{N}$，每个颗粒代表相等的质量，因此在估计量中具有相等的颗粒权重。对于相等质量的情况，$\\tilde{\\phi}$ 的蒙特卡罗估计量简化为简单样本均值 $\\hat{\\tilde{\\phi}} = \\frac{1}{N}\\sum_{i=1}^{N}\\phi_{i}$。\n\n假设以下科学上合理的条件：\n- 颗粒样本是独立同分布的，具有有限方差，因此中心极限定理适用于 $\\hat{\\tilde{\\phi}}$。\n- 在此控制体中，从上一步估计得到的亚格子标量方差为 $\\operatorname{Var}(\\phi) = 2.5 \\times 10^{-3}$（无量纲）。\n- 您需要为 $\\tilde{\\phi}$ 构建一个置信水平为 $0.95$ 的对称双侧置信区间，其半宽不超过 $\\Delta = 1.0 \\times 10^{-3}$（无量纲）。\n\n从Favre滤波定义和中心极限定理出发，推导 $\\hat{\\tilde{\\phi}}$ 的统计误差如何随 $N$ 变化，并构建相应的正态近似置信区间。然后，确定最小整数 $N$，使得在置信水平为 $0.95$ 时，该区间的半宽至多为 $\\Delta$。将您的最终答案表示为单个整数 $N$。",
            "solution": "该问题要求确定蒙特卡罗估计Favre滤波标量 $\\tilde{\\phi}$ 所需的最小颗粒数 $N$，以达到指定的统计精度。我们首先验证问题陈述的合理性。\n\n### 步骤1：提取已知条件\n-   Favre滤波标量定义：$\\tilde{\\phi} = \\overline{\\rho \\phi}/\\overline{\\rho}$。\n-   $\\tilde{\\phi}$ 的蒙特卡罗估计量：$\\hat{\\tilde{\\phi}} = \\frac{1}{N}\\sum_{i=1}^{N}\\phi_{i}$，其中 $\\{\\phi_{i}\\}_{i=1}^{N}$ 是独立同分布（i.i.d.）样本。\n-   中心极限定理（CLT）适用于 $\\hat{\\tilde{\\phi}}$。\n-   亚格子标量方差：$\\operatorname{Var}(\\phi) = 2.5 \\times 10^{-3}$。\n-   对称双侧区间的置信水平：$0.95$。\n-   置信区间的最大允许半宽：$\\Delta = 1.0 \\times 10^{-3}$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题在科学上基于大涡模拟（LES）和滤波密度函数（FDF）方法的理论，这是计算燃烧学中的一种标准方法。蒙特卡罗估计量的使用和中心极限定理的应用是正确应用于此背景下的基本统计原理。该问题是适定的，提供了唯一确定样本量 $N$ 所需的所有必要信息——基础分布的方差、期望的置信水平和要求的精度。语言客观且无歧义。因此，该问题被认为是有效的。\n\n### 步骤3：推导与求解\nFavre滤波标量 $\\tilde{\\phi}$ 的蒙特卡罗估计量由 $N$ 个独立同分布颗粒实现 $\\{\\phi_i\\}$ 的样本均值给出：\n$$ \\hat{\\tilde{\\phi}} = \\frac{1}{N}\\sum_{i=1}^{N}\\phi_{i} $$\n样本 $\\phi_i$ 从一个分布中抽取，该分布的均值是真实的Favre滤波标量 $E[\\phi_i] = \\tilde{\\phi}$，其方差是亚格子标量方差 $\\sigma^2 = \\operatorname{Var}(\\phi)$。\n\n该估计量的期望值为：\n$$ E[\\hat{\\tilde{\\phi}}] = E\\left[\\frac{1}{N}\\sum_{i=1}^{N}\\phi_{i}\\right] = \\frac{1}{N}\\sum_{i=1}^{N}E[\\phi_{i}] = \\frac{1}{N}(N\\tilde{\\phi}) = \\tilde{\\phi} $$\n这证实了该估计量是无偏的。\n\n由于样本的独立性，该估计量的方差为：\n$$ \\operatorname{Var}(\\hat{\\tilde{\\phi}}) = \\operatorname{Var}\\left(\\frac{1}{N}\\sum_{i=1}^{N}\\phi_{i}\\right) = \\frac{1}{N^2}\\sum_{i=1}^{N}\\operatorname{Var}(\\phi_{i}) = \\frac{1}{N^2}(N\\sigma^2) = \\frac{\\sigma^2}{N} $$\n该估计量的标准差，即标准误差，为 $\\sigma_{\\hat{\\tilde{\\phi}}} = \\frac{\\sigma}{\\sqrt{N}}$。这表明估计量的统计误差与 $N^{-1/2}$ 成比例。\n\n根据中心极限定理，对于足够大的 $N$，样本均值 $\\hat{\\tilde{\\phi}}$ 的分布近似为均值为 $\\tilde{\\phi}$、方差为 $\\frac{\\sigma^2}{N}$ 的正态分布：\n$$ \\hat{\\tilde{\\phi}} \\sim \\mathcal{N}\\left(\\tilde{\\phi}, \\frac{\\sigma^2}{N}\\right) $$\n为构建置信区间，我们将估计量标准化以获得一个标准正态变量 $Z$：\n$$ Z = \\frac{\\hat{\\tilde{\\phi}} - \\tilde{\\phi}}{\\sigma/\\sqrt{N}} \\sim \\mathcal{N}(0, 1) $$\n我们寻求一个置信水平为 $1-\\alpha = 0.95$ 的 $\\tilde{\\phi}$ 的对称双侧置信区间。这意味着显著性水平 $\\alpha = 0.05$。该区间定义为：\n$$ P(-z_{\\alpha/2} \\le Z \\le z_{\\alpha/2}) = 1 - \\alpha $$\n其中 $z_{\\alpha/2}$ 是来自标准正态分布的临界值，其尾部概率为 $\\alpha/2$。对于本例，$\\alpha/2 = 0.025$。相应的临界值是 $z_{0.025}$，对应于累积概率 $1 - 0.025 = 0.975$。该值为 $z_{0.025} \\approx 1.96$。\n\n代入 $Z$ 的表达式并整理不等式以分离出 $\\tilde{\\phi}$：\n$$ P\\left(\\hat{\\tilde{\\phi}} - z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{N}} \\le \\tilde{\\phi} \\le \\hat{\\tilde{\\phi}} + z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{N}}\\right) = 1 - \\alpha $$\n该置信区间的半宽是在估计值 $\\hat{\\tilde{\\phi}}$ 上加减的量：\n$$ \\text{半宽} = z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{N}} $$\n问题要求该半宽至多为 $\\Delta = 1.0 \\times 10^{-3}$：\n$$ z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{N}} \\le \\Delta $$\n我们现在可以解这个不等式，求出最小整数 $N$。已知条件如下：\n-   $\\operatorname{Var}(\\phi) = \\sigma^2 = 2.5 \\times 10^{-3}$\n-   $\\Delta = 1.0 \\times 10^{-3}$\n-   $z_{0.025} \\approx 1.96$\n\n首先，我们求标准差 $\\sigma$：\n$$ \\sigma = \\sqrt{\\sigma^2} = \\sqrt{2.5 \\times 10^{-3}} = \\sqrt{25 \\times 10^{-4}} = 5 \\times 10^{-2} = 0.05 $$\n将已知值代入不等式：\n$$ 1.96 \\times \\frac{0.05}{\\sqrt{N}} \\le 1.0 \\times 10^{-3} $$\n整理以求解 $\\sqrt{N}$：\n$$ \\sqrt{N} \\ge \\frac{1.96 \\times 0.05}{1.0 \\times 10^{-3}} $$\n$$ \\sqrt{N} \\ge \\frac{0.098}{10^{-3}} $$\n$$ \\sqrt{N} \\ge 98 $$\n两边平方以求得关于 $N$ 的条件：\n$$ N \\ge 98^2 $$\n$$ N \\ge 9604 $$\n由于 $N$ 必须是整数，所需的最小颗粒数为 $9604$。",
            "answer": "$$\\boxed{9604}$$"
        },
        {
            "introduction": "FDF粒子不仅代表了标量值，它们的演化还需遵循描述亚格子尺度过程（如分子混合）的模型。本练习将解决一个关键的实现挑战：如何确保混合分数等有界标量在其物理边界内（即可实现性）。您将分析一个经典的微观混合模型（IEM），了解一个简单的数值方案为何会产生非物理结果，并实现一种标准的“削峰”修正方法来强制保证物理一致性。",
            "id": "4024972",
            "problem": "您的任务是构建并分析一个数学上严谨的测试，以证明用于大涡模拟 (LES) 的滤波密度函数 (FDF) 方法中的均值交换相互作用 (IEM) 微混合模型可能违反有界标量的可实现性，然后展示一个带有截断的修正 IEM 更新如何强制实现有界性。所关注的标量用 $\\,\\xi\\,$ 表示，其物理上有界于区间 $\\,\\xi\\in[0,1]\\,$（例如，混合分数或归一化进程变量）。分析和计算必须纯粹以数学术语进行，并且必须易于理解和在软件中实现。在适用情况下，所有物理参数都必须以秒为单位给出。\n\n从以下基础开始：\n\n- 大涡模拟 (LES) 滤波密度函数 (FDF) 框架通过一组拉格朗日粒子来表示标量的亚格子统计特性，这些粒子的状态在组分空间中对滤波密度函数进行采样。\n- 对于被动有界标量 $\\,\\xi\\,$，均值交换相互作用 (IEM) 微混合模型规定了每个拉格朗日样本随时间连续演化的方式为\n$$\n\\frac{d\\xi}{dt}=-\\frac{\\xi-\\tilde{\\xi}}{\\tau_{\\text{mix}}},\n$$\n其中 $\\,\\tilde{\\xi}\\,$ 是 $\\,\\xi\\,$ 的滤波（条件）平均值，$\\,\\tau_{\\text{mix}}\\,$ 是以秒表示的微混合时间尺度。\n\n您的任务：\n\n1) 对于在时间增量 $\\,\\Delta t\\,$（单位为秒）上的单个前向 Euler 步，推导 IEM 模型的显式一阶时间离散更新。使用 $\\,\\alpha=\\Delta t/\\tau_{\\text{mix}}\\,$ 来表示该更新，并确定在该条件下，此离散更新保持为当前样本值和滤波平均值的凸组合，从而对于所有初始位于 $\\, [0,1]\\,$ 的样本和 $\\,\\tilde{\\xi}\\in[0,1]\\,$，都满足可实现性 $\\,\\xi\\in[0,1]\\,$。\n\n2) 仅使用逻辑和代数，并假设初始粒子集合的 $\\,\\xi\\,$ 在 $\\, [0,1]\\,$ 上均匀分布，且滤波平均值 $\\,\\tilde{\\xi}=m\\in[0,1]\\,$ 在该时间步内为常数，推导当 $\\,\\alpha>1\\,$ 时，经过一次显式 Euler IEM 更新后，位于 $\\, [0,1]\\,$ 区间外的样本比例的闭式表达式。您的表达式必须分别说明低于 $\\,0\\,$ 和高于 $\\,1\\,$ 的样本测度，然后将它们组合以得出总比例。此推导中不得使用数值积分或随机抽样。\n\n3) 定义一个修正的 IEM 更新，其中 Euler 更新后的任何样本值都被截断到容许区间 $\\, [0,1]\\,$ 内，即替换为 $\\,\\max(0,\\min(1,\\xi^{\\text{new}}))\\,$. 解释为什么在此修正下，即使未修正的显式 Euler 更新在 $\\,\\alpha>1\\,$ 时可能违反可实现性，对于任何 $\\,\\alpha>0\\,$ 和 $\\,m\\in[0,1]\\,$，可实现性也都能被强制满足。\n\n4) 实现一个程序，对于下面指定的每个测试用例，计算并输出两个量：\n   - 经过一次未修正的显式 Euler IEM 步后，违反 $\\, [0,1]\\,$ 的样本的解析推导比例（以小数形式）。\n   - 经过一次带截断的修正 IEM 步后，违反 $\\, [0,1]\\,$ 的样本的比例（以小数形式）。\n\n在所有情况下，使用单位为秒的 $\\,\\tau_{\\text{mix}}\\,$ 和 $\\,\\Delta t\\,$，并将最终比例表示为小数。\n\n测试套件（每个用例提供 $\\,(\\tau_{\\text{mix}},\\Delta t,m)\\,$）：\n- 用例 1 (正常路径): $\\,\\tau_{\\text{mix}}=0.1\\,$ s, $\\,\\Delta t=0.01\\,$ s, $\\,m=0.5\\,$.\n- 用例 2 (边界条件): $\\,\\tau_{\\text{mix}}=0.02\\,$ s, $\\,\\Delta t=0.02\\,$ s, $\\,m=0.2\\,$.\n- 用例 3 (下界违规): $\\,\\tau_{\\text{mix}}=0.1\\,$ s, $\\,\\Delta t=0.2\\,$ s, $\\,m=0.3\\,$.\n- 用例 4 (上界违规): $\\,\\tau_{\\text{mix}}=0.05\\,$ s, $\\,\\Delta t=0.1\\,$ s, $\\,m=0.8\\,$.\n- 用例 5 (双边违规): $\\,\\tau_{\\text{mix}}=0.1\\,$ s, $\\,\\Delta t=0.3\\,$ s, $\\,m=0.5\\,$.\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含每个用例的两个比例 $\\,[\\text{未修正},\\text{修正}]\\,$，并将五个用例的结果平铺展开为\n$$\n[\\text{C1 未修正},\\text{C1 修正},\\text{C2 未修正},\\text{C2 修正},\\text{C3 未修正},\\text{C3 修正},\\text{C4 未修正},\\text{C4 修正},\\text{C5 未修正},\\text{C5 修正}].\n$$\n所有数值输出必须是小数。不应打印任何其他文本。",
            "solution": "本分析探讨了当均值交换相互作用 (IEM) 微混合模型与显式一阶 Euler 格式结合使用时的可实现性问题。标量 $\\xi$ 有界于区间 [0, 1] 内。一个拉格朗日样本 $\\xi$ 的连续演化由以下常微分方程给出：\n$$\n\\frac{d\\xi}{dt}=-\\frac{\\xi-\\tilde{\\xi}}{\\tau_{\\text{mix}}}\n$$\n其中 $\\tilde{\\xi}$ 是滤波平均值，$\\tau_{\\text{mix}}$ 是微混合时间尺度。\n\n### 1. 离散化与可实现性条件\n\n为离散化 IEM 方程，我们在时间步长 $\\Delta t$ 上应用前向 Euler 格式。设 $\\xi^n$ 为时刻 $t_n$ 的标量值，$\\xi^{n+1}$ 为时刻 $t_{n+1} = t_n + \\Delta t$ 的值。时间导数近似为 $\\frac{d\\xi}{dt} \\approx \\frac{\\xi^{n+1} - \\xi^n}{\\Delta t}$。将此代入 IEM 方程得到：\n$$\n\\frac{\\xi^{n+1} - \\xi^n}{\\Delta t} = -\\frac{\\xi^n - \\tilde{\\xi}}{\\tau_{\\text{mix}}}\n$$\n求解 $\\xi^{n+1}$，我们得到显式一阶更新法则：\n$$\n\\xi^{n+1} = \\xi^n - \\frac{\\Delta t}{\\tau_{\\text{mix}}}(\\xi^n - \\tilde{\\xi})\n$$\n我们定义无量纲时间步参数 $\\alpha = \\frac{\\Delta t}{\\tau_{\\text{mix}}}$。更新法则可写作：\n$$\n\\xi^{n+1} = \\xi^n - \\alpha(\\xi^n - \\tilde{\\xi})\n$$\n整理各项，将 $\\xi^{n+1}$ 表示为 $\\xi^n$ 和 $\\tilde{\\xi}$ 的线性组合：\n$$\n\\xi^{n+1} = (1-\\alpha)\\xi^n + \\alpha\\tilde{\\xi}\n$$\n如果系数 $(1-\\alpha)$ 和 $\\alpha$ 非负且和为 1，则此更新代表一个凸组合。它们的和为 $(1-\\alpha) + \\alpha = 1$。非负性条件为 $\\alpha \\ge 0$ 和 $1-\\alpha \\ge 0$。由于 $\\Delta t$ 和 $\\tau_{\\text{mix}}$ 均为正的物理量，$\\alpha \\ge 0$ 总是满足的。凸组合的剩余条件是：\n$$\n1-\\alpha \\ge 0 \\implies \\alpha \\le 1\n$$\n如果此条件成立，即 $\\Delta t \\le \\tau_{\\text{mix}}$，并且当前样本值 $\\xi^n$ 和滤波平均值 $\\tilde{\\xi}$ 都在可实现区间 [0, 1] 内，那么新的样本值 $\\xi^{n+1}$ 也保证在 [0, 1] 内。这是凸组合的一个基本性质：它们将一个凸集（如区间 [0, 1]）映射到其自身。因此，条件 $\\alpha \\le 1$ 足以确保离散更新满足可实现性。\n\n### 2. 不可实现样本的解析比例\n\n现在我们推导当 $\\alpha > 1$ 时违反边界 [0, 1] 的样本比例。我们假设初始粒子集合的标量值 $\\xi_0$ 在 [0, 1] 上均匀分布。其概率密度函数为 $p(\\xi_0) = 1$ (对于 $\\xi_0 \\in [0, 1]$) 且 $p(\\xi_0) = 0$ (其他情况)。滤波平均值为常数 $\\tilde{\\xi} = m \\in [0, 1]$。更新后的值为 $\\xi_1 = (1-\\alpha)\\xi_0 + \\alpha m$。由于 $\\alpha > 1$，系数 $(1-\\alpha)$ 为负。\n\n如果 $\\xi_1  0$ 或 $\\xi_1 > 1$，则样本变得不可实现。违反边界的样本比例是使得 $\\xi_1 \\notin [0,1]$ 的 $\\xi_0 \\in [0,1]$ 集合的测度。\n\n**低于 $0$ 的违规**：\n条件是 $\\xi_1  0$，这等价于：\n$$\n(1-\\alpha)\\xi_0 + \\alpha m  0 \\implies (1-\\alpha)\\xi_0  -\\alpha m\n$$\n由于 $(1-\\alpha)$ 是负数，除以它会反转不等号：\n$$\n\\xi_0 > \\frac{-\\alpha m}{1-\\alpha} = \\frac{\\alpha m}{\\alpha-1}\n$$\n在初始 [0, 1] 区间内导致此违规的 $\\xi_0$ 值位于区间 $(\\frac{\\alpha m}{\\alpha-1}, 1]$。这类样本的比例，即该区间的长度（因为 $p(\\xi_0)=1$），仅当 $\\frac{\\alpha m}{\\alpha-1}  1$ 时才非零。这个比例 $F_{0}$ 为：\n$$\nF_{0} = \\max\\left(0, 1 - \\frac{\\alpha m}{\\alpha-1}\\right)\n$$\n\n**高于 $1$ 的违规**：\n条件是 $\\xi_1 > 1$，这等价于：\n$$\n(1-\\alpha)\\xi_0 + \\alpha m > 1 \\implies (1-\\alpha)\\xi_0 > 1 - \\alpha m\n$$\n再次，除以负数 $(1-\\alpha)$ 会反转不等号：\n$$\n\\xi_0  \\frac{1-\\alpha m}{1-\\alpha} = \\frac{\\alpha m-1}{\\alpha-1}\n$$\n在 [0, 1] 区间内导致此违规的 $\\xi_0$ 值位于区间 $[0, \\frac{\\alpha m-1}{\\alpha-1})$。这类样本的比例 $F_{>1}$，仅当 $\\frac{\\alpha m-1}{\\alpha-1} > 0$ 时才非零。这个比例是：\n$$\nF_{>1} = \\max\\left(0, \\frac{\\alpha m-1}{\\alpha-1}\\right)\n$$\n\n关于 $\\xi_0$ 的这两个条件是互斥的，因为 $\\frac{\\alpha m}{\\alpha-1} > \\frac{\\alpha m-1}{\\alpha-1}$。因此，不可实现样本的总比例 $F_{\\text{total}}$ 是这两种情况的比例之和：\n$$\nF_{\\text{total}}(\\alpha, m) = \\begin{cases} 0  \\text{if } \\alpha \\le 1 \\\\ \\max\\left(0, 1 - \\frac{\\alpha m}{\\alpha-1}\\right) + \\max\\left(0, \\frac{\\alpha m - 1}{\\alpha-1}\\right)  \\text{if } \\alpha > 1 \\end{cases}\n$$\n\n### 3. 带截断的修正 IEM 更新\n\n为了不论 $\\alpha$ 的值如何都强制实现可实现性，可以通过应用截断操作来修正 IEM 更新。在使用显式 Euler 步计算出新值 $\\xi^{\\text{new}} = (1-\\alpha)\\xi^n + \\alpha \\tilde{\\xi}$ 后，将其强制约束回容许区间 [0, 1] 内。修正后的更新为：\n$$\n\\xi^{\\text{new}}_{\\text{clipped}} = \\max(0, \\min(1, \\xi^{\\text{new}}))\n$$\n该操作分两步进行：\n1. 内部函数 $\\min(1, \\xi^{\\text{new}})$ 确保任何大于 $1$ 的值都被替换为 $1$。此步骤的结果总是小于或等于 $1$。\n2. 外部函数 $\\max(0, \\dots)$ 确保任何小于 $0$ 的值都被替换为 $0$。此步骤的结果总是大于或等于 $0$。\n\n总的来说，截断函数将任何实数 $\\xi^{\\text{new}}$ 映射到区间 [0, 1]。因此，对于任何正数 $\\alpha$ 以及任何初始值 $\\xi^n \\in [0,1]$ 和 $\\tilde{\\xi}=m \\in [0,1]$，得到的标量值 $\\xi^{\\text{new}}_{\\text{clipped}}$ 都保证是可实现的。经过此修正步骤后，违反可实现性的样本比例根据定义恒为 $0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_violation_fractions(tau_mix: float, delta_t: float, m: float) -> tuple[float, float]:\n    \"\"\"\n    Calculates the fraction of samples violating realizability for IEM model.\n\n    Args:\n        tau_mix: The micromixing time scale in seconds.\n        delta_t: The time step size in seconds.\n        m: The constant filtered mean, m = tilde{xi}.\n\n    Returns:\n        A tuple containing:\n        - The analytically derived fraction for the unmodified explicit Euler update.\n        - The fraction for the modified update with clipping.\n    \"\"\"\n    if tau_mix == 0:\n        # Avoid division by zero, though problem constraints imply tau_mix > 0.\n        return 0.0, 0.0\n\n    alpha = delta_t / tau_mix\n    unmodified_fraction = 0.0\n\n    # The unmodified Euler step violates realizability only if alpha > 1.\n    if alpha > 1.0:\n        # Denominator for the violation expressions\n        denom = alpha - 1.0\n\n        # Fraction of samples that fall below 0\n        # This corresponds to initial xi_0 > (alpha * m) / (alpha - 1)\n        # The fraction is max(0, 1 - (alpha * m) / (alpha - 1))\n        frac_below_zero = np.maximum(0.0, 1.0 - (alpha * m) / denom)\n\n        # Fraction of samples that fall above 1\n        # This corresponds to initial xi_0  (alpha * m - 1) / (alpha - 1)\n        # The fraction is max(0, (alpha * m - 1.0) / (alpha - 1))\n        frac_above_one = np.maximum(0.0, (alpha * m - 1.0) / denom)\n\n        # The two violation regions for initial xi_0 are disjoint,\n        # so the total fraction is their sum.\n        unmodified_fraction = frac_below_zero + frac_above_one\n\n    # The modified IEM update with clipping enforces realizability by construction.\n    # Therefore, the fraction of samples violating the bounds is always 0.\n    modified_fraction = 0.0\n\n    return unmodified_fraction, modified_fraction\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite and prints the results.\n    \"\"\"\n    # Test suite from the problem statement: (tau_mix, delta_t, m)\n    test_cases = [\n        (0.1, 0.01, 0.5),  # Case 1 (happy path, alpha  1)\n        (0.02, 0.02, 0.2),  # Case 2 (boundary condition, alpha = 1)\n        (0.1, 0.2, 0.3),   # Case 3 (lower-bound violation, alpha > 1)\n        (0.05, 0.1, 0.8),   # Case 4 (upper-bound violation, alpha > 1)\n        (0.1, 0.3, 0.5),   # Case 5 (both-side violation, alpha > 1)\n    ]\n\n    results = []\n    for case in test_cases:\n        tau_mix, delta_t, m = case\n        unmod_frac, mod_frac = calculate_violation_fractions(tau_mix, delta_t, m)\n        results.append(unmod_frac)\n        results.append(mod_frac)\n\n    # Format the output as a single comma-separated list in brackets.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "FDF方法的主要优势之一在于其能精确处理复杂的化学反应项，而无需对其形式进行建模。然而，在燃烧模拟中，化学反应通常是“稀有事件”，仅在状态空间的特定小区域（如高温区）内发生，这使得标准的蒙特卡洛采样效率低下。本节高级练习将介绍重要性采样，这是一种强大的方差缩减技术，它能够显著提高稀有反应事件的采样效率，从而实现对滤波反应速率的精确、高效计算。",
            "id": "4024869",
            "problem": "考虑用于湍流反应流的大涡模拟 (LES) 方法，以及用于模拟未解析标量脉动的滤波密度函数 (FDF) 方法。在 FDF 框架中，局部亚格子状态的滤波反应速率定义为反应源泛函在标量滤波联合概率密度函数上的期望。设标量矢量为 $(Z, \\Theta)$，其中 $Z \\in [0,1]$ 是无量纲混合分数，$\\Theta \\in (0,\\infty)$ 是无量纲温度。假设 $(Z,\\Theta)$ 在滤波尺度上是统计独立的。滤波反应速率为\n$$\n\\tilde{R} \\;=\\; \\iint S(Z,\\Theta)\\,\\tilde{p}_{Z}(Z)\\,\\tilde{p}_{\\Theta}(\\Theta)\\, \\mathrm{d}Z\\, \\mathrm{d}\\Theta,\n$$\n其中 $S(Z,\\Theta)$ 是一个取决于局部反应状态的非负反应源泛函，而 $\\tilde{p}_{Z}$ 和 $\\tilde{p}_{\\Theta}$ 分别是 $Z$ 和 $\\Theta$ 的滤波边际密度。\n\n从第一性原理（概率论中期望和重要性采样的定义）出发，使用一个在 $\\tilde{p}_{Z}(Z)\\tilde{p}_{\\Theta}(\\Theta)$ 的支撑集上具有完全支撑集的建议密度 $q(Z,\\Theta)$，推导 $\\tilde{R}$ 的一个无偏重要性采样估计器。明确展示无偏性所需的条件，包括权重定义和在建议测度下的期望。\n\n对于数值评估，考虑以下科学上合理的设置：\n- 反应泛函为\n$$\nS(Z,\\Theta) \\;=\\; Z\\,(1-Z)\\,\\exp\\!\\left(-\\frac{\\beta}{\\Theta}\\right),\n$$\n其中无量纲活化参数 $\\beta0$。\n- 滤波密度是独立的，由下式给出\n$$\n\\tilde{p}_{Z}(Z) \\;=\\; \\frac{Z^{a-1}(1-Z)^{b-1}}{B(a,b)},\\quad Z\\in[0,1],\\qquad B(a,b) \\;=\\; \\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)},\n$$\n以及\n$$\n\\tilde{p}_{\\Theta}(\\Theta) \\;=\\; \\frac{\\Theta^{k-1}\\exp\\!\\left(-\\Theta/s\\right)}{\\Gamma(k)\\,s^{k}},\\quad \\Theta\\in(0,\\infty),\n$$\n其中 $a0$, $b0$ 是 Beta 分布的参数，而 $k1$, $s0$ 是 Gamma 分布的形状和尺度参数。这些选择确保了物理上合理的正值标量和有限积分。\n- 建议密度可分解为 $q(Z,\\Theta)=q_{Z}(Z)\\,q_{\\Theta}(\\Theta)$，其中\n$$\nq_{Z}(Z) \\;=\\; \\frac{Z^{c-1}(1-Z)^{d-1}}{B(c,d)},\\quad Z\\in[0,1],\n$$\n以及\n$$\nq_{\\Theta}(\\Theta) \\;=\\; \\frac{\\Theta^{k_q-1}\\exp\\!\\left(-\\Theta/s_q\\right)}{\\Gamma(k_q)\\,s_q^{k_q}},\\quad \\Theta\\in(0,\\infty),\n$$\n参数 $c0$, $d0$, $k_q1$, $s_q0$ 的选择是为了增加稀有反应状态（例如，中等的 $Z$ 和大的 $\\Theta$）的出现频率。\n\n任务：\n- 推导。仅使用期望的定义和概率密度函数的性质，推导从 $q(Z,\\Theta)$ 中抽取的重加权粒子的 $\\tilde{R}$ 的无偏重要性采样估计器。不要假设任何快捷公式；从定义 $\\tilde{R}=\\mathbb{E}_{\\tilde{p}}[S(Z,\\Theta)]$ 开始，并逐步构建估计器。精确陈述权重定义和无偏性条件。\n- 算法设计。实现一个程序，该程序：\n  1. 从 $q(Z,\\Theta)$ 生成 $N$ 个独立样本 $(Z_i,\\Theta_i)$，并使用权重 $w(Z_i,\\Theta_i)=\\frac{\\tilde{p}_{Z}(Z_i)\\tilde{p}_{\\Theta}(\\Theta_i)}{q_{Z}(Z_i)q_{\\Theta}(\\Theta_i)}$ 计算重要性采样估计器。\n  2. 从 $\\tilde{p}_{Z}(Z)\\tilde{p}_{\\Theta}(\\Theta)$ 生成 $N$ 个独立样本，并计算朴素蒙特卡洛估计器（即简单平均值）以进行比较。\n  3. 使用数值积分计算 $\\tilde{R}$ 的高精度数值参考值。利用独立性将积分分解为 $E_Z\\cdot E_\\Theta$，其中\n     $$\n     E_Z \\;=\\; \\int_{0}^{1} Z(1-Z)\\,\\tilde{p}_{Z}(Z)\\,\\mathrm{d}Z \\;=\\; \\mathbb{E}[Z]-\\mathbb{E}[Z^{2}] \\;=\\; \\frac{a}{a+b} \\;-\\; \\frac{a(a+1)}{(a+b)(a+b+1)},\n     $$\n     以及\n     $$\n     E_\\Theta \\;=\\; \\int_{0}^{\\infty} \\exp\\!\\left(-\\frac{\\beta}{\\Theta}\\right)\\,\\tilde{p}_{\\Theta}(\\Theta)\\,\\mathrm{d}\\Theta,\n     $$\n     该项应以足够的精度进行数值评估，并认识到对于任意的 $(k,s,\\beta)$，通常不存在闭合形式的解。\n- 测试套件。使用以下参数集，每个参数集具有相同的样本数量 $N$：\n  - 情况 A（中等稀有反应状态）：\n    - $a=2$, $b=10$, $k=2$, $s=0.5$, $\\beta=3$,\n    - $c=3$, $d=3$, $k_q=2$, $s_q=1.2$,\n    - $N=50000$。\n  - 情况 B（极端稀有反应状态）：\n    - $a=2$, $b=20$, $k=2$, $s=0.2$, $\\beta=10$,\n    - $c=3$, $d=3$, $k_q=2$, $s_q=1.5$,\n    - $N=50000$。\n  - 情况 C（建议密度等于目标密度；边界一致性检查）：\n    - $a=2$, $b=10$, $k=2$, $s=0.5$, $\\beta=3$,\n    - $c=2$, $d=10$, $k_q=2$, $s_q=0.5$,\n    - $N=50000$。\n- 输出规格。对于每种情况，计算朴素估计器的绝对误差和重要性采样估计器相对于数值积分参考值的绝对误差。程序必须输出一行，包含一个由方括号括起来的逗号分隔列表，其中包含三种情况下误差的比率（朴素绝对误差除以重要性采样绝对误差），每个比率四舍五入到小数点后六位。最终输出格式必须严格为 $[\\text{r}_A,\\text{r}_B,\\text{r}_C]$ 的形式，其中 $\\text{r}_\\cdot$ 是四舍五入到小数点后六位的浮点数。所有量均为无量纲。",
            "solution": "该问题被评估为有效，因为它具有科学依据、是适定的、客观且内部一致的。它提出了一个计算燃烧学中标准的、尽管是高级的问题，可以使用概率论和数值方法的既定原理来解决。所有必要的数据和定义均已提供。\n\n推导和算法设计将按如下方式进行。\n\n滤波反应速率 $\\tilde{R}$ 定义为源泛函 $S(Z,\\Theta)$ 关于联合滤波密度函数 $\\tilde{p}(Z,\\Theta)$ 的期望。鉴于标量 $Z$ 和 $\\Theta$ 的统计独立性，联合密度是边际密度的乘积：$\\tilde{p}(Z,\\Theta) = \\tilde{p}_{Z}(Z)\\tilde{p}_{\\Theta}(\\Theta)$。待估计的积分为：\n$$\n\\tilde{R} = \\mathbb{E}_{\\tilde{p}}[S(Z,\\Theta)] = \\int_{0}^{\\infty}\\int_{0}^{1} S(Z,\\Theta)\\,\\tilde{p}_{Z}(Z)\\,\\tilde{p}_{\\Theta}(\\Theta)\\, \\mathrm{d}Z\\, \\mathrm{d}\\Theta\n$$\n\n$\\tilde{R}$ 的一个朴素蒙特卡洛估计器是通过从目标分布 $\\tilde{p}(Z,\\Theta)$ 中抽取 $N$ 个独立同分布 (i.i.d.) 的样本 $(Z_i, \\Theta_i)$，并计算泛函 $S(Z,\\Theta)$ 的样本均值来构建的：\n$$\n\\hat{R}_{\\text{naive}} = \\frac{1}{N} \\sum_{i=1}^{N} S(Z_i, \\Theta_i), \\quad \\text{where } (Z_i, \\Theta_i) \\sim \\tilde{p}(Z, \\Theta)\n$$\n该估计器是无偏的，即 $\\mathbb{E}_{\\tilde{p}}[\\hat{R}_{\\text{naive}}] = \\tilde{R}$，但如果被积函数的重要区域（即 $S(Z,\\Theta)$ 值大的区域）被 $\\tilde{p}(Z,\\Theta)$ 采样的频率很低，则其方差可能会很高。\n\n重要性采样提供了一种通过从一个不同的分布，即建议密度 $q(Z,\\Theta)$，进行采样来降低这种方差的方法，该建议密度被选择用来更频繁地对重要区域进行采样。推导过程首先通过在被积函数上乘以和除以建议密度 $q(Z,\\Theta)$ 来重写 $\\tilde{R}$ 的积分。只要 $q(Z,\\Theta)$ 的支撑集覆盖 $\\tilde{p}(Z,\\Theta)S(Z,\\Theta)$ 的支撑集，即当 $\\tilde{p}(Z,\\Theta)S(Z,\\Theta) \\neq 0$ 时有 $q(Z,\\Theta) > 0$，这样做就是允许的。问题陈述中说明 $q(Z,\\Theta)$ 在 $\\tilde{p}(Z,\\Theta)$ 的支撑集上具有完全支撑集，这满足了该条件。\n\n$$\n\\tilde{R} = \\iint S(Z,\\Theta)\\,\\tilde{p}(Z,\\Theta) \\left(\\frac{q(Z,\\Theta)}{q(Z,\\Theta)}\\right) \\, \\mathrm{d}Z\\, \\mathrm{d}\\Theta = \\iint \\left( S(Z,\\Theta) \\frac{\\tilde{p}(Z,\\Theta)}{q(Z,\\Theta)} \\right) q(Z,\\Theta) \\, \\mathrm{d}Z\\, \\mathrm{d}\\Theta\n$$\n\n该表达式可以被解释为新的随机变量 $S(Z,\\Theta) \\frac{\\tilde{p}(Z,\\Theta)}{q(Z,\\Theta)}$ 关于建议密度 $q(Z,\\Theta)$ 的期望。我们定义重要性权重为：\n$$\nw(Z,\\Theta) = \\frac{\\tilde{p}(Z,\\Theta)}{q(Z,\\Theta)} = \\frac{\\tilde{p}_{Z}(Z)\\tilde{p}_{\\Theta}(\\Theta)}{q_{Z}(Z)q_{\\Theta}(\\Theta)}\n$$\n根据这个定义，$\\tilde{R}$ 的表达式变为：\n$$\n\\tilde{R} = \\mathbb{E}_{q}[S(Z,\\Theta) w(Z,\\Theta)]\n$$\n\n重要性采样蒙特卡洛估计器 $\\hat{R}_{\\text{IS}}$ 是通过从建议分布 $q(Z,\\Theta)$ 中抽取 $N$ 个独立同分布样本 $(Z_i, \\Theta_i)$，并计算重加权函数的样本均值来形成的：\n$$\n\\hat{R}_{\\text{IS}} = \\frac{1}{N} \\sum_{i=1}^{N} S(Z_i, \\Theta_i) w(Z_i, \\Theta_i), \\quad \\text{where } (Z_i, \\Theta_i) \\sim q(Z, \\Theta)\n$$\n\n为证明该估计器是无偏的，我们取其关于建议分布 $q(Z,\\Theta)$ 的期望：\n$$\n\\mathbb{E}_{q}[\\hat{R}_{\\text{IS}}] = \\mathbb{E}_{q}\\left[ \\frac{1}{N} \\sum_{i=1}^{N} S(Z_i, \\Theta_i) w(Z_i, \\Theta_i) \\right]\n$$\n根据期望的线性性质，我们可以将期望算子移到求和符号内部：\n$$\n\\mathbb{E}_{q}[\\hat{R}_{\\text{IS}}] = \\frac{1}{N} \\sum_{i=1}^{N} \\mathbb{E}_{q}[S(Z_i, \\Theta_i) w(Z_i, \\Theta_i)]\n$$\n由于所有样本 $(Z_i, \\Theta_i)$ 都是从 $q(Z,\\Theta)$ 中抽取的独立同分布样本，所以期望项对所有 $i$ 都是相同的。令 $(Z, \\Theta)$ 代表一个服从分布 $q(Z,\\Theta)$ 的一般随机变量对。\n$$\n\\mathbb{E}_{q}[\\hat{R}_{\\text{IS}}] = \\frac{1}{N} \\cdot N \\cdot \\mathbb{E}_{q}[S(Z, \\Theta) w(Z, \\Theta)] = \\mathbb{E}_{q}[S(Z, \\Theta) w(Z, \\Theta)]\n$$\n根据期望的定义，这等价于我们之前推导的积分：\n$$\n\\mathbb{E}_{q}[S(Z, \\Theta) w(Z, \\Theta)] = \\iint S(Z,\\Theta) w(Z,\\Theta) q(Z,\\Theta) \\, \\mathrm{d}Z\\, \\mathrm{d}\\Theta\n$$\n代入权重 $w(Z,\\Theta) = \\frac{\\tilde{p}(Z,\\Theta)}{q(Z,\\Theta)}$ 的定义：\n$$\n\\mathbb{E}_{q}[\\hat{R}_{\\text{IS}}] = \\iint S(Z,\\Theta) \\left(\\frac{\\tilde{p}(Z,\\Theta)}{q(Z,\\Theta)}\\right) q(Z,\\Theta) \\, \\mathrm{d}Z\\, \\mathrm{d}\\Theta = \\iint S(Z,\\Theta) \\tilde{p}(Z,\\Theta) \\, \\mathrm{d}Z\\, \\mathrm{d}\\Theta\n$$\n这最后的积分就是 $\\tilde{R}$ 的定义。因此，我们证明了 $\\mathbb{E}_{q}[\\hat{R}_{\\text{IS}}] = \\tilde{R}$，从而证实了重要性采样估计器是无偏的。\n\n数值评估的算法设计遵循这些原理。\n1. 计算一个高精度的参考值 $\\tilde{R}_{\\text{ref}}$。由于统计独立性，$\\tilde{R} = E_Z \\cdot E_\\Theta$。$E_Z$ 项可解析计算为\n$$\nE_Z = \\frac{a}{a+b} - \\frac{a(a+1)}{(a+b)(a+b+1)}\n$$\n$E_\\Theta$ 项使用高精度数值积分（例如 `scipy.integrate.quad`）计算：\n$$\nE_\\Theta = \\int_{0}^{\\infty} \\exp\\!\\left(-\\frac{\\beta}{\\Theta}\\right)\\,\\tilde{p}_{\\Theta}(\\Theta)\\,\\mathrm{d}\\Theta\n$$\n2. 朴素估计器 $\\hat{R}_{\\text{naive}}$ 是通过从目标分布 $\\tilde{p}_{Z}(Z) \\sim \\text{Beta}(a,b)$ 和 $\\tilde{p}_{\\Theta}(\\Theta) \\sim \\text{Gamma}(k,s)$ 中抽取 $N$ 个样本，并对 $S(Z_i, \\Theta_i)$ 进行平均来计算的。\n3. 重要性采样估计器 $\\hat{R}_{\\text{IS}}$ 是通过从建议分布 $q_{Z}(Z) \\sim \\text{Beta}(c,d)$ 和 $q_{\\Theta}(\\Theta) \\sim \\text{Gamma}(k_q,s_q)$ 中抽取 $N$ 个样本，为每个样本计算权重 $w_i = \\frac{\\tilde{p}(Z_i, \\Theta_i)}{q(Z_i, \\Theta_i)}$，并对乘积 $S(Z_i, \\Theta_i)w_i$ 进行平均来计算的。\n4. 对于每种情况，计算绝对误差 $|\\hat{R}_{\\text{naive}} - \\tilde{R}_{\\text{ref}}|$ 和 $|\\hat{R}_{\\text{IS}} - \\tilde{R}_{\\text{ref}}|$，并报告它们的比率。为确保数值稳定性，权重使用对数概率计算：$\\log w_i = \\log \\tilde{p}(Z_i,\\Theta_i) - \\log q(Z_i,\\Theta_i)$，然后 $w_i = \\exp(\\log w_i)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import beta, gamma\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes and compares naive and importance sampling Monte Carlo estimators\n    for a filtered reaction rate in an FDF context for LES of turbulent combustion.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (moderately rare reactive states)\n        {\n            'name': 'A', 'N': 50000,\n            'target_params': {'a': 2.0, 'b': 10.0, 'k': 2.0, 's': 0.5, 'beta': 3.0},\n            'proposal_params': {'c': 3.0, 'd': 3.0, 'k_q': 2.0, 's_q': 1.2}\n        },\n        # Case B (severely rare reactive states)\n        {\n            'name': 'B', 'N': 50000,\n            'target_params': {'a': 2.0, 'b': 20.0, 'k': 2.0, 's': 0.2, 'beta': 10.0},\n            'proposal_params': {'c': 3.0, 'd': 3.0, 'k_q': 2.0, 's_q': 1.5}\n        },\n        # Case C (proposal equals target; boundary consistency check)\n        {\n            'name': 'C', 'N': 50000,\n            'target_params': {'a': 2.0, 'b': 10.0, 'k': 2.0, 's': 0.5, 'beta': 3.0},\n            'proposal_params': {'c': 2.0, 'd': 10.0, 'k_q': 2.0, 's_q': 0.5}\n        }\n    ]\n\n    results = []\n    \n    # Setting a fixed seed for reproducibility of the random numbers.\n    # While not strictly requested, it ensures the output is deterministic.\n    np.random.seed(42)\n\n    for case in test_cases:\n        # Extract parameters for the current case\n        N = case['N']\n        a, b, k, s, beta_val = case['target_params'].values()\n        c, d, k_q, s_q = case['proposal_params'].values()\n\n        # 1. Compute high-accuracy numerical reference value using quadrature\n        # E_Z term\n        E_Z = (a / (a + b)) - (a * (a + 1)) / ((a + b) * (a + b + 1))\n        \n        # E_Theta term integrand\n        def E_theta_integrand(theta):\n            return np.exp(-beta_val / theta) * gamma.pdf(theta, k, scale=s)\n        \n        # Numerical integration for E_Theta\n        E_Theta, _ = quad(E_theta_integrand, 0, np.inf)\n        \n        ref_R = E_Z * E_Theta\n\n        # 2. Compute the naive Monte Carlo estimator\n        # Generate samples from the target distribution p(Z, Theta)\n        Z_target_samples = np.random.beta(a, b, N)\n        Theta_target_samples = np.random.gamma(k, s, N)\n        \n        # Reaction source term S(Z, Theta)\n        S_target = Z_target_samples * (1 - Z_target_samples) * np.exp(-beta_val / Theta_target_samples)\n        \n        # Naive estimator\n        naive_R = np.mean(S_target)\n\n        # 3. Compute the importance sampling estimator\n        # Generate samples from the proposal distribution q(Z, Theta)\n        Z_proposal_samples = np.random.beta(c, d, N)\n        Theta_proposal_samples = np.random.gamma(k_q, s_q, N)\n\n        # Compute log-probabilities for numerical stability\n        # Log-pdf of target distribution at proposal samples\n        log_p = beta.logpdf(Z_proposal_samples, a, b) + gamma.logpdf(Theta_proposal_samples, k, scale=s)\n        \n        # Log-pdf of proposal distribution at proposal samples\n        log_q = beta.logpdf(Z_proposal_samples, c, d) + gamma.logpdf(Theta_proposal_samples, k_q, scale=s_q)\n        \n        # Importance weights\n        weights = np.exp(log_p - log_q)\n        \n        # Reaction source term evaluated at proposal samples\n        S_proposal = Z_proposal_samples * (1 - Z_proposal_samples) * np.exp(-beta_val / Theta_proposal_samples)\n        \n        # Importance sampling estimator\n        is_R = np.mean(S_proposal * weights)\n\n        # 4. Compute errors and their ratio\n        abs_err_naive = np.abs(naive_R - ref_R)\n        abs_err_is = np.abs(is_R - ref_R)\n        \n        # Handle case where importance sampling error is zero to avoid division by zero\n        if abs_err_is == 0:\n            # If IS is perfect and naive is not, ratio is infinite.\n            # If both are perfect, ratio is undefined, 1.0 is a reasonable assignment.\n            ratio = np.inf if abs_err_naive > 0 else 1.0\n        else:\n            ratio = abs_err_naive / abs_err_is\n        \n        results.append(ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}