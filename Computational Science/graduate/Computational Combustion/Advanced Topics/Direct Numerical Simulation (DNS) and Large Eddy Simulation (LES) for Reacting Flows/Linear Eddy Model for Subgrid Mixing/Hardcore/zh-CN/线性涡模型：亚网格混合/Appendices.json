{
    "hands_on_practices": [
        {
            "introduction": "在线性涡模型（LEM）中，三线映射是模拟亚格子尺度湍流搅动的核心机制。为了深入理解其作用，本练习将该映射从复杂的流场中分离出来，通过一个理想化的思想实验，精确计算单次三线映射对线性标量场梯度范数的影响。这个计算将清晰地揭示三线映射是如何通过拉伸和折叠流体微团来锐化标量梯度，这是湍流混合的一个关键特征。",
            "id": "4036475",
            "problem": "考虑线性涡模型 (LEM)，其中亚格子尺度的搅拌由作用在长度为 $l$ 的区间上的三重映射表示。设标量场定义在区间 $[0,l]$ 上，初始为线性场 $\\phi_{0}(x) = a x + b$，其中 $a \\neq 0$，并假设没有分子扩散。三重映射 $s:[0,l]\\to[0,l]$ 是一个标准的分段线性重排，由下式给出\n$$\ns(x) = \n\\begin{cases}\n3x,  0 \\le x  \\frac{l}{3}, \\\\\n2l - 3x,  \\frac{l}{3} \\le x  \\frac{2l}{3}, \\\\\n3x - 2l,  \\frac{2l}{3} \\le x \\le l,\n\\end{cases}\n$$\n该映射将区间压缩为原来的三分之一，形成三层，并反转中间层。在没有扩散的不可压缩重排下，映射后的标量场为 $\\phi_{1}(x) = \\phi_{0}(s(x))$。\n\n从 $L^2$ 范数和链式法则的定义出发，计算单次三重映射对区间 $[0,l]$ 上标量梯度的 $L^2$ 范数的影响，即计算以下比率：\n$$\nR \\equiv \\frac{\\|\\partial_{x}\\phi_{1}\\|_{L^{2}(0,l)}}{\\|\\partial_{x}\\phi_{0}\\|_{L^{2}(0,l)}}.\n$$\n请给出最终答案，该答案应为一个精确的无量纲数。不要进行四舍五入。",
            "solution": "用户希望计算在应用单次三重映射前后，标量梯度的 $L^2$ 范数之比。\n\n首先对问题进行验证，以确保其科学上合理、适定且客观。\n\n### 步骤 1：提取已知条件\n-   **定义域**：长度为 $l > 0$ 的区间 $[0,l]$。\n-   **初始标量场**：$\\phi_{0}(x) = a x + b$，其中 $a \\neq 0$ 且 $b$ 为常数。\n-   **三重映射**：$s:[0,l]\\to[0,l]$ 定义为\n    $$\n    s(x) =\n    \\begin{cases}\n    3x,  0 \\le x  \\frac{l}{3} \\\\\n    2l - 3x,  \\frac{l}{3} \\le x  \\frac{2l}{3} \\\\\n    3x - 2l,  \\frac{2l}{3} \\le x \\le l\n    \\end{cases}\n    $$\n-   **映射后标量场**：$\\phi_{1}(x) = \\phi_{0}(s(x))$。\n-   **假设**：无分子扩散。\n-   **目标**：计算比率 $R \\equiv \\frac{\\|\\partial_{x}\\phi_{1}\\|_{L^{2}(0,l)}}{\\|\\partial_{x}\\phi_{0}\\|_{L^{2}(0,l)}}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题使用了线性涡模型 (LEM) 中的标准三重映射，这是计算燃烧学和湍流理论中公认的模型。所使用的数学工具（$L^2$ 范数、链式法则）是标准的。该问题是将数学分析应用于基于物理的模型的一个有效实例。\n-   **适定性**：所有必要的组成部分均已定义。初始条件 $\\phi_0(x)$ 已指定，变换 $s(x)$ 已明确给出，目标量 $R$ 是一个定义明确的范数之比。条件 $a \\neq 0$ 确保了分母不为零。存在唯一且有意义的解。\n-   **客观性**：该问题使用精确的数学语言陈述，没有歧义或主观陈述。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n### 解答\n\n目标是计算比率 $R \\equiv \\frac{\\|\\partial_{x}\\phi_{1}\\|_{L^{2}(0,l)}}{\\|\\partial_{x}\\phi_{0}\\|_{L^{2}(0,l)}}$。这需要计算初始标量场 $\\phi_0(x)$ 和映射后标量场 $\\phi_1(x)$ 在区间 $[0,l]$ 上的梯度 $L^2$ 范数。函数 $f(x)$ 在该区间上的 $L^2$ 范数定义为 $\\|f\\|_{L^2(0,l)} = \\sqrt{\\int_0^l (f(x))^2 dx}$。\n\n**1. 分母计算：$\\|\\partial_{x}\\phi_{0}\\|_{L^{2}(0,l)}$**\n\n首先，我们求初始标量场 $\\phi_{0}(x) = ax + b$ 的梯度。\n$$\n\\partial_x \\phi_0(x) = \\frac{d}{dx}(ax+b) = a\n$$\n接下来，我们计算其 $L^2$ 范数的平方：\n$$\n\\|\\partial_{x}\\phi_{0}\\|_{L^{2}(0,l)}^{2} = \\int_{0}^{l} (\\partial_x \\phi_0(x))^2 dx = \\int_{0}^{l} a^2 dx\n$$\n由于 $a$ 是常数，积分为：\n$$\n\\|\\partial_{x}\\phi_{0}\\|_{L^{2}(0,l)}^{2} = a^2 \\int_{0}^{l} dx = a^2 [x]_{0}^{l} = a^2 l\n$$\n开平方根得到范数：\n$$\n\\|\\partial_{x}\\phi_{0}\\|_{L^{2}(0,l)} = \\sqrt{a^2 l} = |a|\\sqrt{l}\n$$\n题目指定 $a \\neq 0$，所以该范数不为零。\n\n**2. 分子计算：$\\|\\partial_{x}\\phi_{1}\\|_{L^{2}(0,l)}$**\n\n映射后的标量场为 $\\phi_{1}(x) = \\phi_{0}(s(x))$。我们使用链式法则计算其梯度 $\\partial_x \\phi_1(x)$：\n$$\n\\partial_x \\phi_1(x) = \\frac{d}{dx} \\phi_0(s(x)) = (\\phi_0' \\circ s)(x) \\cdot s'(x) = \\phi_0'(s(x)) \\cdot s'(x)\n$$\n由于 $\\phi_0(y) = ay+b$，其导数为 $\\phi_0'(y) = a$。因此，对于任意 $x$，$\\phi_0'(s(x)) = a$。梯度简化为：\n$$\n\\partial_x \\phi_1(x) = a \\cdot s'(x)\n$$\n接下来，我们求分段线性三重映射的导数 $s'(x)$：\n$$\ns'(x) = \\frac{d}{dx} s(x) =\n\\begin{cases}\n3,  0  x  \\frac{l}{3} \\\\\n-3,  \\frac{l}{3}  x  \\frac{2l}{3} \\\\\n3,  \\frac{2l}{3}  x  l\n\\end{cases}\n$$\n导数在 $x=l/3$ 和 $x=2l/3$ 处未定义，但这些点的测度为零，不影响 $L^2$ 范数积分的值。\n\n现在我们可以写出 $\\partial_x \\phi_1(x)$ 的表达式：\n$$\n\\partial_x \\phi_1(x) =\n\\begin{cases}\n3a,  0  x  \\frac{l}{3} \\\\\n-3a,  \\frac{l}{3}  x  \\frac{2l}{3} \\\\\n3a,  \\frac{2l}{3}  x  l\n\\end{cases}\n$$\n为了计算 $\\|\\partial_{x}\\phi_{1}\\|_{L^{2}(0,l)}$，我们首先计算其平方：\n$$\n\\|\\partial_{x}\\phi_{1}\\|_{L^{2}(0,l)}^{2} = \\int_{0}^{l} (\\partial_x \\phi_1(x))^2 dx\n$$\n我们将积分分为三个子区间：\n$$\n\\|\\partial_{x}\\phi_{1}\\|_{L^{2}(0,l)}^{2} = \\int_{0}^{l/3} (3a)^2 dx + \\int_{l/3}^{2l/3} (-3a)^2 dx + \\int_{2l/3}^{l} (3a)^2 dx\n$$\n在所有三种情况下，被积函数均为 $(3a)^2 = (-3a)^2 = 9a^2$：\n$$\n\\|\\partial_{x}\\phi_{1}\\|_{L^{2}(0,l)}^{2} = \\int_{0}^{l/3} 9a^2 dx + \\int_{l/3}^{2l/3} 9a^2 dx + \\int_{2l/3}^{l} 9a^2 dx\n$$\n另一种看待这个问题的方式是，$(\\partial_x\\phi_1(x))^2 = (a \\cdot s'(x))^2 = a^2 (s'(x))^2$，并且在 $[0,l]$ 上几乎处处有 $(s'(x))^2 = 9$。因此：\n$$\n\\|\\partial_{x}\\phi_{1}\\|_{L^{2}(0,l)}^{2} = \\int_{0}^{l} a^2 (s'(x))^2 dx = \\int_{0}^{l} 9a^2 dx\n$$\n计算该积分：\n$$\n\\|\\partial_{x}\\phi_{1}\\|_{L^{2}(0,l)}^{2} = 9a^2 \\int_{0}^{l} dx = 9a^2 [x]_{0}^{l} = 9a^2l\n$$\n开平方根得到范数：\n$$\n\\|\\partial_{x}\\phi_{1}\\|_{L^{2}(0,l)} = \\sqrt{9a^2l} = 3|a|\\sqrt{l}\n$$\n\n**3. 最终比率计算**\n\n最后，我们计算比率 $R$：\n$$\nR = \\frac{\\|\\partial_{x}\\phi_{1}\\|_{L^{2}(0,l)}}{\\|\\partial_{x}\\phi_{0}\\|_{L^{2}(0,l)}} = \\frac{3|a|\\sqrt{l}}{|a|\\sqrt{l}}\n$$\n由于 $a \\neq 0$ 且 $l > 0$，项 $|a|$ 和 $\\sqrt{l}$ 非零，可以消去。\n$$\nR = 3\n$$\n结果是一个无量纲数，正如预期。对线性标量场应用单次三重映射会将其梯度的 $L^2$ 范数放大 3 倍。",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "真实的混合过程是湍流搅动与分子扩散之间竞争与协作的结果。本练习将三线映射与分子扩散结合在一个数值模拟中，观察初始分离的标量场是如何随时间混合均匀的。通过追踪标量方差（衡量混合不均匀度的指标）的衰减，我们可以量化混合效率，并探索施密特数（$Sc$）——即动量扩散与质量扩散速率之比——对混合过程的重要影响。",
            "id": "4036493",
            "problem": "要求您实现一个适用于计算燃烧学的一维线性涡模型 (LEM)，用于亚格子混合。在该模型中，一个被动标量经历分子扩散和通过三重映射实现的保测搅动交替进行的过程。目标是计算标量方差的演化，并量化其如何依赖于施密特数（运动粘度与分子扩散率之比）。\n\n起点和建模假设：\n- 考虑一个长度为 $L$ 的一维周期性域，其空间坐标为 $x \\in [0,L)$，以及一个由 $N$ 个均匀间隔点组成的计算网格。\n- 被动标量场 $Y(x,t)$ 根据平流-扩散方程演化\n$$\n\\frac{\\partial Y}{\\partial t} + u(x,t)\\frac{\\partial Y}{\\partial x} = D \\frac{\\partial^2 Y}{\\partial x^2},\n$$\n其中 $D$ 是分子扩散率，$u(x,t)$ 是湍流速度场。在线性涡模型中，$u(x,t)$ 的作用被建模为施加在某个区间上的瞬时保测重排（称为三重映射），在两次重排之间，标量仅通过纯扩散演化。\n\n- 运动粘度设定为 $\\nu$ (单位 $\\mathrm{m^2/s}$)，分子扩散率由施密特数 $Sc = \\nu/D$ 确定。因此 $D = \\nu/Sc$。\n\n初始条件和演化协议：\n- 设初始标量为阶跃函数：\n$$\nY(x,0) = \\begin{cases}\n1,  0 \\le x  L/2,\\\\\n0,  L/2 \\le x  L,\n\\end{cases}\n$$\n即在 $x = L/2$ 处存在一个不连续点。\n- 通过交替进行 $M$ 个周期来演化标量：\n  1. 一个持续时间为 $\\Delta t$ 的纯扩散过程，采用周期性边界条件。通过根据以下公式更新每个傅里叶模 $\\hat{Y}_k$，在谱空间中精确实现此扩散步骤：\n  $$\n  \\hat{Y}_k(t+\\Delta t) = \\hat{Y}_k(t)\\,\\exp\\!\\left(-D\\,k^2\\,\\Delta t\\right),\n  $$\n  其中 $k = 2\\pi n/L$，整数 $n$ 是傅里叶模的索引。\n  2. 一个确定性地应用于长度为 $f L$ 的中心区间 $[a,b]$ 上的三重映射，其中 $f \\in (0,1]$ 是涡尺度分数。三重映射将 $[a,b]$ 内的内容替换为三个等长的自身压缩副本，其中中间的副本反转，并保持 $[a,b]$ 之外的标量不变。该映射必须在计算网格上使用线性插值，实现为 $[a,b]$ 上的分段线性、保测重排。该区间应中心放置，使得 $a = (L - fL)/2$ 且 $b = a + fL$。\n\n关注量：\n- 域平均值为\n$$\n\\overline{Y}(t) = \\frac{1}{L}\\int_0^L Y(x,t)\\,\\mathrm{d}x,\n$$\n标量方差为\n$$\n\\sigma^2(t) = \\frac{1}{L}\\int_0^L \\left(Y(x,t) - \\overline{Y}(t)\\right)^2 \\mathrm{d}x.\n$$\n在均匀网格上，计算最终时刻 $t = M\\Delta t$ 时 $\\sigma^2(t)$ 的离散近似值。\n\n物理单位和数值规格：\n- 使用 $L = 1\\,\\mathrm{m}$，$N = 2048$，$\\nu = 1.5\\times 10^{-5}\\,\\mathrm{m^2/s}$，$M = 40$ 以及 $\\Delta t = 0.02\\,\\mathrm{s}$。标量 $Y$ 是无量纲的。以无量纲量的形式报告最终标量方差。\n\n测试套件：\n对于每个测试用例，设置施密特数 $Sc$ 和涡尺度分数 $f$，计算 $D=\\nu/Sc$，执行上述演化协议，并以十进制浮点数形式返回最终标量方差 $\\sigma^2(M\\Delta t)$。使用以下五个测试用例：\n- 用例 1：$Sc = 0.7$，$f = 0.6$。\n- 用例 2：$Sc = 1.0$，$f = 0.3$。\n- 用例 3：$Sc = 10.0$，$f = 0.6$。\n- 用例 4：$Sc = 100.0$，$f = 0.6$。\n- 用例 5：$Sc = 1.0$，$f = 1.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例的最终标量方差，按顺序以逗号分隔的列表形式包含在方括号中，每个值格式化为小数点后恰好 $8$ 位，例如 $[v_1,v_2,v_3,v_4,v_5]$。",
            "solution": "该问题陈述在科学上和数学上均被评估为是合理的。它为一个根植于计算流体动力学和湍流模拟既定原则的数值任务提供了完整且自洽的描述。具体而言，它详细说明了用于被动标量混合的一维线性涡模型 (LEM) 的实现，这是燃烧科学中公认的一种亚格子尺度模型。参数、初始/边界条件以及演化协议都得到了明确规定，确保了问题是适定的。该模型将谱空间中扩散方程的解析解与保测三重映射的应用相结合，这两者都是标准且可形式化的技术。不存在矛盾、缺失数据或违反物理原理的情况。因此，该问题被认为是有效的，可以构建出合理的解决方案。\n\n该解决方案需要对一个长度为 $L$、由 $N$ 个网格点离散化的一维周期性域上的标量场 $Y(x,t)$ 的演化进行数值模拟。模拟总共进行 $M$ 个周期，每个周期包括一个分子扩散步骤，随后是一个由三重映射建模的湍流搅动步骤。\n\n**1. 系统初始化**\n\n- 空间域是区间 $x \\in [0, L)$，其长度指定为 $L = 1\\,\\mathrm{m}$。\n- 定义一个包含 $N=2048$ 个点的均匀计算网格，$x_j = j \\frac{L}{N}$，其中 $j = 0, 1, \\dots, N-1$。\n- 初始标量场 $Y(x,0)$ 是由下式描述的阶跃函数：\n$$\nY(x_j, 0) = \\begin{cases} 1  \\text{for } x_j  L/2 \\\\ 0  \\text{for } x_j \\ge L/2 \\end{cases}\n$$\n- 谱扩散步骤需要与离散网格对应的角波数 $k$。对于一个长度为 $L$ 且有 $N$ 个点的域，空间频率为 $\\nu_n = n/L$。相应的角波数为 $k_n = 2\\pi\\nu_n$。这些可以通过使用 `numpy.fft.fftfreq` 函数高效计算，该函数返回的频率 $\\nu_n$ 的顺序与快速傅里叶变换 (FFT) 算法兼容。\n- 对于每个由施密特数 $Sc$ 和涡尺度分数 $f$ 定义的测试用例，分子扩散率 $D$ 是根据给定的运动粘度 $\\nu = 1.5\\times 10^{-5}\\,\\mathrm{m^2/s}$ 和定义 $Sc=\\nu/D$ 计算得出的，即 $D = \\nu/Sc$。\n\n**2. 时间演化协议**\n\n系统演化 $M=40$ 个周期，每个周期代表一个时间间隔 $\\Delta t=0.02\\,\\mathrm{s}$。在每个周期中，从时间 $t$ 到 $t+\\Delta t$，按顺序执行以下两个步骤。\n\n**2.1. 扩散步骤**\n此步骤模拟分子扩散效应。通过在周期 $\\Delta t$ 内求解纯扩散方程 $\\frac{\\partial Y}{\\partial t} = D \\frac{\\partial^2 Y}{\\partial x^2}$（采用周期性边界条件），来推进标量场 $Y(x,t)$。\n- 使用 FFT 将场 $Y(x,t)$ 变换到傅里叶空间，以获得其谱表示 $\\hat{Y}(k,t)$。\n- 在傅里叶空间中，对于每个模式 $k$，扩散方程变为一个常微分方程，其精确解为：\n$$\n\\hat{Y}(k, t+\\Delta t) = \\hat{Y}(k, t) \\exp(-D k^2 \\Delta t)\n$$\n- 因子 $\\exp(-Dk^2\\Delta t)$ 是一个谱传递函数，它更强地衰减高波数模式，代表了标量梯度的粘性耗散。\n- 更新后的谱场 $\\hat{Y}(k, t+\\Delta t)$ 使用逆傅里叶变换 (IFFT) 转换回物理空间。其结果，我们可以表示为 $Y^*(x, t+\\Delta t)$，即为扩散后的标量场。取 IFFT 输出的实部，因为初始场是实数，任何虚部都是由数值浮点误差引起的。\n\n**2.2. 三重映射（搅动）步骤**\n此步骤模拟湍流涡的混合效应。它被实现为在指定区间内对标量场进行的瞬时、保测重排。\n- 将三重映射应用于扩散后的场 $Y^*(x, t+\\Delta t)$，以生成该周期的最终场 $Y(x, t+\\Delta t)$。\n- 该映射应用于长度为 $L_{eddy} = fL$ 的中心区间 $[a,b]$，其中 $a = (L - L_{eddy})/2$ 且 $b = a + L_{eddy}$。此区间外的标量值不受影响。\n- 对于位于 $[a,b]$ 内的网格点 $x_j$，新的标量值 $Y(x_j, t+\\Delta t)$ 是通过在一组源坐标 $x_{source, j}$ 处对映射前场 $Y^*(x, t+\\Delta t)$ 进行插值来确定的。函数 $T: x_j \\mapsto x_{source, j}$ 定义了该映射。对于三重映射，其表达式为：\n$$\nT(x) = \\begin{cases}\na + 3(x - a)  \\text{if } a \\le x \\le a + L_{eddy}/3, \\\\\nb - 3(x - [a + L_{eddy}/3])  \\text{if } a + L_{eddy}/3  x \\le a + 2L_{eddy}/3, \\\\\na + 3(x - [a + 2L_{eddy}/3])  \\text{if } a + 2L_{eddy}/3  x \\le b.\n\\end{cases}\n$$\n此映射获取区间 $[a,b]$ 上的标量场，将其压缩三倍，并将三个副本放回 $[a,b]$ 中，其中中间的副本被反转。\n- 由于源坐标 $x_{source, j} = T(x_j)$ 通常不会落在网格点上，因此需要按规定进行线性插值。使用带有 `period=L` 选项的 `numpy.interp` 函数计算值 $Y^*(x_{source, j}, t+\\Delta t)$，以正确处理域的周期性。\n\n**3. 最终方差计算**\n\n- 完成所有 $M$ 个周期后，模拟在最终时间 $t_{final} = M\\Delta t$ 结束。\n- 最终标量方差 $\\sigma^2(t_{final})$ 是从最终标量场 $Y(x, t_{final})$ 计算得出的。在离散网格上，这是对所有网格点的平均值。\n- 首先，计算域平均标量值：\n$$\n\\overline{Y} = \\frac{1}{N} \\sum_{j=0}^{N-1} Y(x_j, t_{final})\n$$\n- 然后，方差是与均值偏差的平方的平均值：\n$$\n\\sigma^2 = \\frac{1}{N} \\sum_{j=0}^{N-1} (Y(x_j, t_{final}) - \\overline{Y})^2\n$$\n- 对所提供的五个 $(Sc, f)$ 测试用例中的每一个都重复此整个过程。得到的五个方差值被格式化并作为最终答案呈现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Linear Eddy Model simulation for all test cases\n    and print the results in the specified format.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.7, 0.6),   # Case 1: Sc = 0.7, f = 0.6\n        (1.0, 0.3),   # Case 2: Sc = 1.0, f = 0.3\n        (10.0, 0.6),  # Case 3: Sc = 10.0, f = 0.6\n        (100.0, 0.6), # Case 4: Sc = 100.0, f = 0.6\n        (1.0, 1.0)    # Case 5: Sc = 1.0, f = 1.0\n    ]\n\n    results = []\n    for sc, f in test_cases:\n        # Run the simulation for one case.\n        variance = run_lem_simulation(sc, f)\n        results.append(variance)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\n\ndef run_lem_simulation(sc: float, f: float) -> float:\n    \"\"\"\n    Performs a one-dimensional Linear Eddy Model simulation for a passive scalar.\n\n    Args:\n        sc: The Schmidt number (Sc = nu/D).\n        f: The eddy-length fraction for the triplet map.\n\n    Returns:\n        The final scalar variance after M cycles.\n    \"\"\"\n    # Physical and numerical specifications from the problem statement\n    L = 1.0            # Domain length [m]\n    N = 2048           # Number of grid points\n    nu = 1.5e-5        # Kinematic viscosity [m^2/s]\n    M = 40             # Number of evolution cycles\n    dt = 0.02          # Time step duration [s]\n\n    # Derived parameters\n    D = nu / sc        # Molecular diffusivity [m^2/s]\n\n    # Set up computational grids\n    # Spatial grid\n    x = np.linspace(0, L, N, endpoint=False)\n    # Wavenumber grid for FFT\n    dx = L / N\n    k = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # Initial condition: step function\n    Y = np.zeros(N, dtype=np.float64)\n    Y[x  L/2] = 1.0\n\n    # Pre-calculate the spectral diffusion operator for efficiency\n    diffusion_operator = np.exp(-D * k**2 * dt)\n\n    # Main evolution loop\n    for _ in range(M):\n        # --- Step 1: Diffusion in spectral space ---\n        Y_hat = np.fft.fft(Y)\n        Y_hat *= diffusion_operator\n        Y = np.real(np.fft.ifft(Y_hat))\n\n        # --- Step 2: Triplet map stirring in physical space ---\n        Y_old = Y.copy()\n        \n        L_eddy = f * L\n        a = (L - L_eddy) / 2\n        b = a + L_eddy\n\n        # Identify grid points within the mapping interval [a, b)\n        map_indices = np.where((x >= a)  (x  b))[0]\n        \n        if map_indices.size > 0:\n            x_target = x[map_indices]\n            x_source = np.zeros_like(x_target)\n            \n            # Define boundaries of the three sub-regions for the map\n            b1 = a + L_eddy / 3\n            b2 = a + 2 * L_eddy / 3\n            \n            # Create boolean masks for each sub-region\n            mask1 = x_target = b1\n            mask2 = (x_target > b1)  (x_target = b2)\n            mask3 = x_target > b2\n            \n            # Apply the piecewise-linear triplet map to get source coordinates\n            x_source[mask1] = a + 3 * (x_target[mask1] - a)\n            x_source[mask2] = b - 3 * (x_target[mask2] - b1)\n            x_source[mask3] = a + 3 * (x_target[mask3] - b2)\n\n            # Interpolate values from the old field at source coordinates\n            # Use period=L for correct handling of periodic boundary conditions\n            Y[map_indices] = np.interp(x_source, x, Y_old, period=L)\n\n    # Calculate final scalar variance\n    mean_Y = np.mean(Y)\n    variance = np.mean((Y - mean_Y)**2)\n    \n    return variance\n\nsolve()\n```"
        },
        {
            "introduction": "在模拟湍流燃烧时，除了混合，还必须考虑化学反应。本练习聚焦于LEM框架中的反应子步骤，将一维计算域上的每个点视为一个独立的绝热恒压反应器。此练习的核心挑战在于处理化学反应动力学的“刚性”（stiffness）问题，这要求使用专门为刚性系统设计的稳健数值积分方法。掌握这一技能对于任何想要实现反应流求解器的研究者来说都至关重要。",
            "id": "4036531",
            "problem": "您需要实现计算燃烧学中用于亚格子混合的线性涡模型 (LEM) 的纯反应子步，该模型沿着一维空间点线进行。在 LEM 框架中，反应子步在每个点上局部地推进热化学状态，在此过程中没有空间耦合；空间搅拌和扩散在其他子步中处理。对于单步不可逆反应，假设单位混合物质量的反应速率由阿伦尼乌斯表达式 $\\dot{\\omega} = A \\exp\\!\\left(-\\dfrac{E_a}{R\\,T}\\right)\\,Y_F\\,Y_O$ 给出，其中 $A$ 是指前因子，$E_a$ 是活化能，$R$ 是通用气体常数，$T$ 是温度，$Y_F$ 和 $Y_O$ 分别是燃料和氧化剂的局部质量分数。\n\n从第一性原理出发，在反应子步期间，将线上的每个点建模为空间均匀、恒压、绝热的反应器。在这些假设下，组分守恒和热力学第一定律意味着以下用于描述局部状态的常微分方程 (ODEs)：\n- 燃料质量分数演化：$\\dfrac{dY_F}{dt} = -\\,\\dot{\\omega}$。\n- 氧化剂质量分数演化：$\\dfrac{dY_O}{dt} = -\\,\\dot{\\omega}$。\n- 温度演化：$\\dfrac{dT}{dt} = \\dfrac{Q}{c_p}\\,\\dot{\\omega}$。\n\n这里，$Q$ 是单位混合物质量每单位消耗的燃料质量分数所释放的比热量（常数），$c_p$ 是混合物在恒压下的比热容（常数）。此封闭关系强制要求温升速率与放热速率成正比，并遵循绝热、恒压的约束。\n\n您的任务是编写一个完整的、可运行的程序，该程序能够：\n1. 将一维线离散化为 $N$ 个空间点，总长度为 $L$。\n2. 沿线设置初始分布 $Y_F(x)$ 和 $Y_O(x)$，以及空间均匀的初始温度 $T_0$。\n3. 使用适用于刚性化学问题的数值稳健策略，通过在给定的反应子步时长 $\\Delta t$ 内积分上述 ODE 系统，独立地推进每个空间点的状态。\n4. 对每个测试用例，计算反应子步结束后的最终沿线平均燃料质量分数 $\\overline{Y_F}^{\\,\\text{final}}$。\n5. 生成单行输出，其中包含三个结果，格式为方括号内以逗号分隔的浮点数列表，每个浮点数四舍五入到 $6$ 位小数，例如 $[r_1,r_2,r_3]$。\n\n角度不属于此任务的一部分。必须遵守物理单位：温度单位为开尔文，时间单位为秒，活化能单位为焦耳每摩尔，通用气体常数单位为焦耳每摩尔开尔文，放热量单位为焦耳每千克，比热容单位为焦耳每千克开尔文。质量分数是无量纲的。\n\n您必须设计能够稳健处理刚性问题的积分方案；策略可包括隐式求解器、提供雅可比矩阵、自适应步长控制、为保持正定性而处理耗尽事件以及反应限制。\n\n使用以下测试套件。对于所有情况，通用气体常数 $R = 8.314462618$（单位为焦耳每摩尔开尔文）。\n\n- 测试用例 $1$（一般情况，非极端刚性）：\n  - 离散化：$N = 50$，$L = 0.01$ 米。\n  - 初始条件：$T_0 = 1200$ 开尔文，$Y_F(x) = Y_{F,0} + a_F \\sin\\!\\left(2\\pi x/L\\right)$，其中 $Y_{F,0} = 0.05$，$a_F = 0.02$，$Y_O(x) = Y_{O,0} + a_O \\cos\\!\\left(2\\pi x/L\\right)$，其中 $Y_{O,0} = 0.08$，$a_O = 0.02$。\n  - 化学参数：$A = 1.0\\times 10^{6}$ s$^{-1}$，$E_a = 8.0\\times 10^{4}$ 焦耳每摩尔，$Q = 5.0\\times 10^{6}$ 焦耳每千克，$c_p = 1000$ 焦耳每千克开尔文。\n  - 反应子步时长：$\\Delta t = 1.0\\times 10^{-3}$ 秒。\n\n- 测试用例 $2$（刚性动力学：大的指前因子和活化能）：\n  - 离散化：$N = 50$，$L = 0.01$ 米。\n  - 初始条件：$T_0 = 900$ 开尔文，$Y_F(x) = Y_{F,0} + a_F \\sin\\!\\left(2\\pi x/L\\right)$，其中 $Y_{F,0} = 0.05$，$a_F = 0.02$，$Y_O(x) = Y_{O,0} + a_O \\cos\\!\\left(2\\pi x/L\\right)$，其中 $Y_{O,0} = 0.10$，$a_O = 0.02$。\n  - 化学参数：$A = 1.0\\times 10^{12}$ s$^{-1}$，$E_a = 1.8\\times 10^{5}$ 焦耳每摩尔，$Q = 5.0\\times 10^{6}$ 焦耳每千克，$c_p = 1000$ 焦耳每千克开尔文。\n  - 反应子步时长：$\\Delta t = 5.0\\times 10^{-4}$ 秒。\n\n- 测试用例 $3$（边界情况：半条线氧化剂耗尽）：\n  - 离散化：$N = 50$，$L = 0.01$ 米。\n  - 初始条件：$T_0 = 1100$ 开尔文，$Y_F(x) = Y_{F,0} + a_F \\sin\\!\\left(2\\pi x/L\\right)$，其中 $Y_{F,0} = 0.05$，$a_F = 0.01$。分段定义 $Y_O(x)$：当 $x \\le L/2$ 时 $Y_O(x) = 0$，当 $x > L/2$ 时 $Y_O(x) = 0.10$。\n  - 化学参数：$A = 1.0\\times 10^{7}$ s$^{-1}$，$E_a = 1.2\\times 10^{5}$ 焦耳每摩尔，$Q = 5.0\\times 10^{6}$ 焦耳每千克，$c_p = 1000$ 焦耳每千克开尔文。\n  - 反应子步时长：$\\Delta t = 1.0\\times 10^{-3}$ 秒。\n\n您的程序应生成单行输出，其中包含结果，格式为方括号内以逗号分隔的列表，每个浮点数四舍五入到 $6$ 位小数，严格遵循 $[r_1,r_2,r_3]$ 的格式。",
            "solution": "该问题要求在一维网格上实现线性涡模型 (LEM) 的纯反应子步。在每个空间点，热化学状态根据描述均匀、恒压、绝热反应器的一组常微分方程 (ODE) 独立演化。任务是针对整个网格上的一组初始条件对该 ODE 系统进行积分，并计算最终的沿线平均燃料质量分数。\n\n在任何给定空间点和时间 $t$，系统的状态可以由状态向量 $\\mathbf{y}(t) = [Y_F(t), Y_O(t), T(t)]^T$ 描述，其中 $Y_F$ 是燃料质量分数，$Y_O$ 是氧化剂质量分数，$T$ 是温度。控制性常微分方程为：\n$$\n\\frac{dY_F}{dt} = -\\,\\dot{\\omega}\n$$\n$$\n\\frac{dY_O}{dt} = -\\,\\dot{\\omega}\n$$\n$$\n\\frac{dT}{dt} = \\frac{Q}{c_p}\\,\\dot{\\omega}\n$$\n其中 $Q$ 是比放热量，$c_p$ 是定压比热容，$\\dot{\\omega}$ 是由阿伦尼乌斯表达式给出的反应速率：\n$$\n\\dot{\\omega} = A \\exp\\!\\left(-\\frac{E_a}{R\\,T}\\right)\\,Y_F\\,Y_O\n$$\n这里，$A$ 是指前因子，$E_a$ 是活化能，$R$ 是通用气体常数。\n\n该系统可以写成向量形式 $\\frac{d\\mathbf{y}}{dt} = f(\\mathbf{y})$，其中：\n$$\nf(\\mathbf{y}) = \\dot{\\omega}(\\mathbf{y}) \\begin{bmatrix} -1 \\\\ -1 \\\\ Q/c_p \\end{bmatrix}\n$$\n\n模拟燃烧化学的一个关键方面是控制性常微分方程的数值刚性。刚性源于反应动力学中存在的大范围时间尺度，其中某些组分或温度的变化可能比其他组分或温度快得多。反应速率对温度的指数依赖性是这种刚性的主要来源。对刚性系统使用标准的显式数值积分方法（例如，前向欧拉法或龙格-库塔法）将需要极小的时间步长来维持数值稳定性。\n\n因此，一个稳健的数值策略必须采用隐式 ODE 求解器。我们将使用 SciPy 库中的 `solve_ivp` 函数，并将其配置为使用 'BDF'（后向差分公式）方法。BDF 是一族隐式多步法，非常适合刚性初值问题。\n\n为了进一步提高隐式求解器的效率和可靠性，我们将提供 ODE 系统的解析雅可比矩阵 $J$。雅可比矩阵定义为 $J_{ij} = \\frac{\\partial f_i}{\\partial y_j}$，其中 $f_i$ 是函数 $f(\\mathbf{y})$ 的第 $i$ 个分量，$y_j$ 是状态向量 $\\mathbf{y} = [Y_F, Y_O, T]^T$ 的第 $j$ 个分量。雅可比矩阵可以表示为外积 $J = \\mathbf{v} (\\nabla \\dot{\\omega})^T$，其中 $\\mathbf{v} = [-1, -1, Q/c_p]^T$，$\\nabla \\dot{\\omega}$ 是反应速率相对于状态变量的梯度。梯度的分量为：\n$$\n\\frac{\\partial \\dot{\\omega}}{\\partial Y_F} = A \\exp\\!\\left(-\\frac{E_a}{R\\,T}\\right) Y_O\n$$\n$$\n\\frac{\\partial \\dot{\\omega}}{\\partial Y_O} = A \\exp\\!\\left(-\\frac{E_a}{R\\,T}\\right) Y_F\n$$\n$$\n\\frac{\\partial \\dot{\\omega}}{\\partial T} = A \\exp\\!\\left(-\\frac{E_a}{R\\,T}\\right) Y_F Y_O \\left(\\frac{E_a}{R T^2}\\right) = \\dot{\\omega} \\frac{E_a}{R T^2}\n$$\n这些表达式用于为求解器构建 $3 \\times 3$ 的雅可比矩阵。\n\n实现过程如下：\n1.  将长度为 $L$ 的一维域离散化为 $N$ 个点，创建一个空间网格 $x$。\n2.  对于每个测试用例，定义参数并计算每个网格点上的初始条件 $Y_F(x)$、$Y_O(x)$ 和 $T(x)=T_0$。\n3.  遍历每个空间点。对于每个点 $i$，这定义了一个独立的初值问题，其初始状态为 $\\mathbf{y}_0 = [Y_F(x_i), Y_O(x_i), T_0]^T$。\n4.  使用 `scipy.integrate.solve_ivp` 函数，配合 'BDF' 方法和解析推导的雅可比矩阵，在时间区间 $[0, \\Delta t]$ 上求解每个初值问题。\n5.  一个物理约束是质量分数不能为负。这在 ODE 和雅可比函数定义中通过确保任何对 $Y_F$ 或 $Y_O$ 的引用都使用 $\\max(0, Y)$ 来强制执行。这可以防止出现非物理状态，并确保在反应物完全耗尽时反应能正确停止。\n6.  在所有 $N$ 个点的积分完成后，计算最终的沿线平均燃料质量分数 $\\overline{Y_F}^{\\,\\text{final}}$，即每个点上得到的最终燃料质量分数的算术平均值。\n\n这种有原则的方法确保了为 LEM 模拟中推进反应子步的问题提供一个科学正确、数值稳定且高效的解决方案。最终的程序结构将包含一个主 `solve` 函数，该函数遍历所提供的测试用例，并调用一个辅助函数来实现针对单个用例的上述数值积分方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for the LEM reaction substep problem.\n    \"\"\"\n    R = 8.314462618  # Universal gas constant in J/(mol·K)\n\n    test_cases = [\n        # Test Case 1: General, non-extreme stiffness\n        {\n            \"N\": 50, \"L\": 0.01, \"T0\": 1200,\n            \"YF_ic_func\": lambda x, L: 0.05 + 0.02 * np.sin(2 * np.pi * x / L),\n            \"YO_ic_func\": lambda x, L: 0.08 + 0.02 * np.cos(2 * np.pi * x / L),\n            \"A\": 1.0e6, \"Ea\": 8.0e4, \"Q\": 5.0e6, \"cp\": 1000, \"dt\": 1.0e-3\n        },\n        # Test Case 2: Stiff kinetics\n        {\n            \"N\": 50, \"L\": 0.01, \"T0\": 900,\n            \"YF_ic_func\": lambda x, L: 0.05 + 0.02 * np.sin(2 * np.pi * x / L),\n            \"YO_ic_func\": lambda x, L: 0.10 + 0.02 * np.cos(2 * np.pi * x / L),\n            \"A\": 1.0e12, \"Ea\": 1.8e5, \"Q\": 5.0e6, \"cp\": 1000, \"dt\": 5.0e-4\n        },\n        # Test Case 3: Oxidizer-depleted half-line\n        {\n            \"N\": 50, \"L\": 0.01, \"T0\": 1100,\n            \"YF_ic_func\": lambda x, L: 0.05 + 0.01 * np.sin(2 * np.pi * x / L),\n            \"YO_ic_func\": lambda x, L: np.where(x = L / 2, 0.0, 0.10),\n            \"A\": 1.0e7, \"Ea\": 1.2e5, \"Q\": 5.0e6, \"cp\": 1000, \"dt\": 1.0e-3\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        avg_YF = solve_reaction_substep(\n            R=R, **case_params\n        )\n        # Format the result as required\n        results.append(f\"{avg_YF:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_reaction_substep(N, L, T0, YF_ic_func, YO_ic_func, A, Ea, Q, cp, dt, R):\n    \"\"\"\n    Solves the reaction ODE system for a single test case.\n\n    Args:\n        N: Number of spatial points.\n        L: Length of the 1D line.\n        T0: Initial uniform temperature.\n        YF_ic_func: Function to generate initial fuel mass fraction distribution.\n        YO_ic_func: Function to generate initial oxidizer mass fraction distribution.\n        A: Pre-exponential factor.\n        Ea: Activation energy.\n        Q: Specific heat release.\n        cp: Specific heat at constant pressure.\n        dt: Reaction substep duration.\n        R: Universal gas constant.\n\n    Returns:\n        The line-averaged final fuel mass fraction.\n    \"\"\"\n    x = np.linspace(0, L, N)\n    \n    YF_initial = YF_ic_func(x, L)\n    YO_initial = YO_ic_func(x, L)\n    T_initial = np.full(N, T0)\n\n    # These functions are defined as closures to capture the case parameters.\n    def ode_system(t, y):\n        Y_F, Y_O, T = y\n        \n        # Enforce positivity and handle non-reactive states\n        Y_F_clipped = max(0.0, Y_F)\n        Y_O_clipped = max(0.0, Y_O)\n        \n        if Y_F_clipped == 0 or Y_O_clipped == 0 or T = 0:\n            return [0.0, 0.0, 0.0]\n        \n        try:\n            k = A * np.exp(-Ea / (R * T))\n            omega_dot = k * Y_F_clipped * Y_O_clipped\n        except (OverflowError, ZeroDivisionError):\n            return [0.0, 0.0, 0.0]\n\n        dYF_dt = -omega_dot\n        dYO_dt = -omega_dot\n        dT_dt = (Q / cp) * omega_dot\n        \n        return [dYF_dt, dYO_dt, dT_dt]\n\n    def jacobian(t, y):\n        Y_F, Y_O, T = y\n        \n        Y_F_clipped = max(0.0, Y_F)\n        Y_O_clipped = max(0.0, Y_O)\n\n        if Y_F_clipped == 0 or Y_O_clipped == 0 or T = 0:\n            return np.zeros((3, 3))\n\n        try:\n            k = A * np.exp(-Ea / (R * T))\n            exp_arg_deriv_T = Ea / (R * T**2)\n        except (OverflowError, ZeroDivisionError):\n            return np.zeros((3, 3))\n        \n        # Partial derivatives of omega_dot\n        d_omega_d_YF = k * Y_O_clipped\n        d_omega_d_YO = k * Y_F_clipped\n        d_omega_d_T = k * Y_F_clipped * Y_O_clipped * exp_arg_deriv_T\n        \n        jac = np.array([\n            [-d_omega_d_YF, -d_omega_d_YO, -d_omega_d_T],\n            [-d_omega_d_YF, -d_omega_d_YO, -d_omega_d_T],\n            [(Q/cp)*d_omega_d_YF, (Q/cp)*d_omega_d_YO, (Q/cp)*d_omega_d_T]\n        ])\n        \n        return jac\n\n    final_YF_values = np.zeros(N)\n    for i in range(N):\n        y0 = [YF_initial[i], YO_initial[i], T_initial[i]]\n        \n        # Optimization: if initially no reactant, state doesn't change.\n        if y0[0] = 0 or y0[1] = 0:\n            final_YF_values[i] = max(0.0, y0[0])\n            continue\n            \n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=(0, dt),\n            y0=y0,\n            method='BDF',\n            jac=jacobian,\n            rtol=1e-6,\n            atol=1e-10\n        )\n        \n        if sol.status != 0:\n            # If solver fails, a robust approach is to assume no reaction occurred\n            # or handle the failure appropriately. For this problem, we'll\n            # use the initial value as a fallback, though failure is not expected.\n            final_state = y0\n        else:\n            final_state = sol.y[:, -1]\n        \n        final_YF_values[i] = max(0.0, final_state[0])\n\n    return np.mean(final_YF_values)\n\nsolve()\n```"
        }
    ]
}