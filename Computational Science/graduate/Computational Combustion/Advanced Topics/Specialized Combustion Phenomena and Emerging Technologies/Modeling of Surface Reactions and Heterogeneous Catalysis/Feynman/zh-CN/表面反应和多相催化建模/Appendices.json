{
    "hands_on_practices": [
        {
            "introduction": "表面反应建模的基石在于理解并量化单个基本步骤的动力学。本练习将引导您分析一个经典的表面科学实验——程序升温脱附（Temperature Programmed Desorption, TPD）。通过将测得的脱附峰值温度与基本的动力学理论联系起来，您将推导出并计算一个关键的动力学参数：脱附活化能$E_{\\text{des}}$。这项实践旨在通过连接实验数据与理论模型，巩固您对一级反应动力学的理解，这是催化研究中至关重要的技能 。",
            "id": "4042357",
            "problem": "在铂表面上进行了一项与计算燃烧相关的催化一氧化碳解吸实验，该实验使用程序升温解吸（TPD）技术，其中温度随时间线性升高。假设为一级解吸动力学，无再吸附，且横向相互作用可忽略不计。解吸速率遵循 Polanyi–Wigner 形式，且解吸活化能垒与覆盖度无关。\n\n给定以下 TPD 可观测量和动力学指前因子：峰值温度 $T_{\\text{p}} = 540\\,\\mathrm{K}$，恒定升温速率 $\\beta = 2.0\\,\\mathrm{K\\,s^{-1}}$，以及与温度无关的指前因子（尝试频率）$\\nu = 1.0\\times 10^{13}\\,\\mathrm{s^{-1}}$，请从第一性原理推导出一个以 $T_{\\text{p}}$、$\\beta$ 和 $\\nu$ 表示解吸活化能 $E_{\\text{des}}$ 的封闭形式解析表达式，然后进行数值计算。使用普适气体常数 $R = 8.314462618\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$。最终能量以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位表示，并将答案四舍五入至四位有效数字。",
            "solution": "### 解题过程\n\n解吸过程由 Polanyi–Wigner 方程描述，该方程给出了表面覆盖度 $\\theta$ 随时间 $t$ 的变化率：\n$$ r_{\\text{des}} = -\\frac{d\\theta}{dt} = \\nu \\theta^n \\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right) $$\n这里，$n$ 是解吸反应的级数，$\\nu$ 是指前因子，$E_{\\text{des}}$ 是解吸活化能，$R$ 是普适气体常数，$T$ 是绝对温度。\n\n问题陈述表明解吸是一级过程，因此我们设 $n=1$：\n$$ -\\frac{d\\theta}{dt} = \\nu \\theta \\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right) $$\n在 TPD 实验中，温度随时间线性增加，$T(t) = T_0 + \\beta t$，其中 $\\beta$ 是恒定的升温速率。这意味着 $\\frac{dT}{dt} = \\beta$，或 $dt = \\frac{dT}{\\beta}$。\n\n解吸速率是在 TPD 谱图中测量的量，在峰值温度 $T_{\\text{p}}$ 时达到最大值。为了找到这个最大值，我们必须将速率对时间（或温度）的导数设为零。让我们对速率方程求关于时间 $t$ 的导数：\n$$ \\frac{d}{dt}\\left(-\\frac{d\\theta}{dt}\\right) = \\frac{d}{dt}\\left[\\nu \\theta \\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right)\\right] = 0 \\quad \\text{在} \\quad T = T_{\\text{p}} \\text{时} $$\n对右侧应用乘法法则得到：\n$$ \\nu \\left[ \\frac{d\\theta}{dt} \\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right) + \\theta \\frac{d}{dt}\\left(\\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right)\\right) \\right]_{T=T_{\\text{p}}} = 0 $$\n我们在峰值温度 $T_{\\text{p}}$ 处计算这些项。\n方括号内的第一项包含 $\\frac{d\\theta}{dt}$，我们用速率方程本身代入：\n$$ \\frac{d\\theta}{dt} = -\\nu \\theta \\exp\\left(-\\frac{E_{\\text{des}}}{RT_{\\text{p}}}\\right) $$\n第二项包含指数因子的时间导数，我们使用链式法则计算：\n$$ \\frac{d}{dt}\\left(\\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right)\\right) = \\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right) \\cdot \\left(\\frac{E_{\\text{des}}}{RT^2}\\right) \\cdot \\frac{dT}{dt} = \\exp\\left(-\\frac{E_{\\text{des}}}{RT}\\right) \\cdot \\frac{E_{\\text{des}}\\beta}{RT^2} $$\n将这些表达式代入最大速率条件，在 $T=T_{\\text{p}}$ 处进行计算，并除以非零量 $\\nu$：\n$$ \\left[ \\left(-\\nu \\theta \\exp\\left(-\\frac{E_{\\text{des}}}{RT_{\\text{p}}}\\right)\\right) \\exp\\left(-\\frac{E_{\\text{des}}}{RT_{\\text{p}}}\\right) + \\theta \\left(\\exp\\left(-\\frac{E_{\\text{des}}}{RT_{\\text{p}}}\\right) \\frac{E_{\\text{des}}\\beta}{RT_{\\text{p}}^2}\\right) \\right] = 0 $$\n我们可以提出公因子 $\\theta(T_{\\text{p}}) \\exp\\left(-\\frac{E_{\\text{des}}}{RT_{\\text{p}}}\\right)$，它在峰值处非零：\n$$ -\\nu \\exp\\left(-\\frac{E_{\\text{des}}}{RT_{\\text{p}}}\\right) + \\frac{E_{\\text{des}}\\beta}{RT_{\\text{p}}^2} = 0 $$\n整理这个方程得到著名的 Redhead 方程，它隐含地将 $E_{\\text{des}}$ 与实验可观测量联系起来：\n$$ \\frac{E_{\\text{des}}}{RT_{\\text{p}}^2} = \\frac{\\nu}{\\beta} \\exp\\left(-\\frac{E_{\\text{des}}}{RT_{\\text{p}}}\\right) $$\n为了找到 $E_{\\text{des}}$ 的封闭形式解析表达式，我们重新整理这个超越方程。令 $x = \\frac{E_{\\text{des}}}{RT_{\\text{p}}}$。方程变为：\n$$ \\frac{x RT_{\\text{p}}}{RT_{\\text{p}}^2} = \\frac{\\nu}{\\beta} \\exp(-x) $$\n$$ \\frac{x}{T_{\\text{p}}} = \\frac{\\nu}{\\beta} \\exp(-x) $$\n两边乘以 $T_{\\text{p}} \\exp(x)$，我们得到：\n$$ x \\exp(x) = \\frac{\\nu T_{\\text{p}}}{\\beta} $$\n这个方程是 $z \\exp(z) = y$ 的标准形式，其中 $z$ 的解由 Lambert W 函数给出，$z = W(y)$。在我们的例子中，$z=x$ 且 $y = \\frac{\\nu T_{\\text{p}}}{\\beta}$。\n因此，$x$ 的解是：\n$$ x = W\\left(\\frac{\\nu T_{\\text{p}}}{\\beta}\\right) $$\n代回 $x = \\frac{E_{\\text{des}}}{RT_{\\text{p}}}$，我们得到解吸活化能的封闭形式解析表达式：\n$$ E_{\\text{des}} = RT_{\\text{p}} W\\left(\\frac{\\nu T_{\\text{p}}}{\\beta}\\right) $$\n现在，我们使用给定的值对这个表达式进行数值计算：\n$T_{\\text{p}} = 540\\,\\mathrm{K}$\n$\\beta = 2.0\\,\\mathrm{K\\,s^{-1}}$\n$\\nu = 1.0\\times 10^{13}\\,\\mathrm{s^{-1}}$\n$R = 8.314462618\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$\n\n首先，我们计算 Lambert W 函数的自变量：\n$$ \\frac{\\nu T_{\\text{p}}}{\\beta} = \\frac{(1.0 \\times 10^{13}\\,\\mathrm{s^{-1}}) \\times (540\\,\\mathrm{K})}{2.0\\,\\mathrm{K\\,s^{-1}}} = 2.7 \\times 10^{15} $$\n接下来，我们计算该自变量的 Lambert W 函数值。对于大的自变量 $y$，$W(y) \\approx \\ln(y) - \\ln(\\ln(y))$。\n$$ W(2.7 \\times 10^{15}) \\approx 32.064299 $$\n现在，我们将此值代回 $E_{\\text{des}}$ 的表达式：\n$$ E_{\\text{des}} = (8.314462618\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}) \\times (540\\,\\mathrm{K}) \\times (32.064299) $$\n$$ E_{\\text{des}} \\approx 143969.8\\,\\mathrm{J\\,mol^{-1}} $$\n问题要求答案以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位，并四舍五入至四位有效数字。\n$$ E_{\\text{des}} = 143.9698\\,\\mathrm{kJ\\,mol^{-1}} $$\n四舍五入至四位有效数字得到：\n$$ E_{\\text{des}} = 144.0\\,\\mathrm{kJ\\,mol^{-1}} $$",
            "answer": "$$\n\\boxed{144.0}\n$$"
        },
        {
            "introduction": "在构建包含多个反应步骤的综合微观动力学模型时，我们常常需要估算许多活化能，而其中一些很难通过实验或计算直接获得。本练习介绍了一种现代计算催化中的强大工具：Brønsted–Evans–Polanyi (BEP) 关系，它揭示了活化能与反应能之间的线性关联。您将学习如何使用加权最小二乘法，根据一组已知的密度泛函理论 (DFT) 计算数据来拟合 BEP 关系，并利用它来预测未知反应的活化能，同时进行严谨的不确定性量化 。",
            "id": "4042389",
            "problem": "考虑一系列与计算燃烧相关的基本催化表面反应。对于每个反应步骤，密度泛函理论 (DFT) 提供了以电子伏特 (eV) 为单位的反应能 $\\Delta E$，并对一部分步骤提供了以 eV 为单位的活化能 $E_a$。Brønsted–Evans–Polanyi (BEP) 相关性通常将相似反应类别中的活化能与反应能联系起来。从过渡态理论 (TST) 出发（其中速率常数由 $k = \\nu \\exp(-E_a/(k_B T))$ 给出，$k_B$ 为玻尔兹曼常数，$T$ 为绝对温度），并借鉴 Hammond 假设（该假设表明过渡态根据反应的放热性接近反应物或产物），开发一种基于统计学原理的线性估计器。该估计器使用已知 $E_a$ 的训练对将 $\\Delta E$ 映射到 $E_a$，然后应用它来预测缺少 $E_a$ 的步骤的 $E_a$ 值。假设测量的活化能误差服从高斯分布，且标准差已知，并通过一阶不确定性传播来考虑预测输入 $\\Delta E$ 的不确定性。\n\n任务：\n1. 从测量活化能的高斯噪声模型出发，推导用于将反应能线性映射到活化能的两个未知参数的估计器。使用由反应能构建的设计矩阵、一个对角权重矩阵以及活化能向量来表示您的估计器。推导参数估计的协方差矩阵，以及一个基于约化卡方（reduced chi-squared）的膨胀规则，以考虑潜在的模型差异。\n2. 对于一个新的具有相关标准差的反应能，通过使用一阶 delta 方法传播参数不确定性和输入不确定性（变量误差），推导预测的平均活化能及其一倍标准差的不确定性。\n3. 在一个程序中实现该估计器和预测不确定性，该程序针对以下每个测试用例，在提供的训练集上拟合线性映射，并输出拟合的参数和预测结果。\n\n定义：\n- Brønsted–Evans–Polanyi (BEP) 关系：在给定表面上的一系列同系反应中，活化能与反应能之间的经验性线性相关关系。\n- 过渡态理论 (TST)：一种通过 $k = \\nu \\exp(-E_a/(k_B T))$ 将反应速率与活化自由能联系起来的理论。\n\n所有能量必须以 eV 为单位进行处理和报告。最终的程序输出必须是单行文本，包含所有测试用例的结果列表，每个结果由拟合的斜率和截距组成，后跟预测的活化能列表及其一倍标准差不确定性的列表，所有数值均以 eV 为单位。确切的最终输出格式必须是：\n- 打印为单个 Python 列表的单行文本，其中每个测试用例的结果是一个形式为 $[\\alpha, \\beta, [\\mu_1, \\mu_2, \\ldots], [\\sigma_1, \\sigma_2, \\ldots]]$ 的列表，其中 $\\alpha$ 和 $\\beta$ 是拟合参数，$\\mu_j$ 是第 $j$ 个缺失步骤的预测活化能，$\\sigma_j$ 是其不确定性。\n- 不出现角度。\n- 不应打印百分比；一倍标准差的不确定性是以 eV 为单位的浮点数。\n\n测试套件：\n- 案例 A (一般情况): 训练数据 $(\\Delta E_i, E_{a,i}, \\sigma_{y,i})$ 为\n  $\\Delta E$ 值 $[-0.45, 0.10, 0.35, 0.80, 1.20, -0.10, 0.55, 0.95]$ eV，\n  $E_a$ 值 $[0.62, 0.55, 0.60, 0.78, 0.92, 0.50, 0.72, 0.86]$ eV，\n  $\\sigma_y$ 值 $[0.05, 0.04, 0.04, 0.05, 0.06, 0.04, 0.05, 0.05]$ eV。\n  预测 $\\Delta E^* = [0.00, 0.40, 1.00]$ eV，每个值的 $\\sigma_x = 0.02$ eV。\n- 案例 B (近热中性边界情况): 训练数据\n  $\\Delta E = [-0.80, -0.30, 0.00, 0.20, 0.50]$ eV，\n  $E_a = [0.70, 0.58, 0.56, 0.60, 0.68]$ eV，\n  $\\sigma_y = [0.07, 0.05, 0.04, 0.05, 0.06]$ eV。\n  预测 $\\Delta E^* = [0.00, -0.05, 0.05]$ eV，每个值的 $\\sigma_x = 0.01$ eV。\n- 案例 C (最小训练数据边缘情况): 训练数据\n  $\\Delta E = [0.20, 0.90]$ eV，\n  $E_a = [0.60, 0.85]$ eV，\n  $\\sigma_y = [0.08, 0.08]$ eV。\n  预测 $\\Delta E^* = [-0.10, 0.50, 1.20]$ eV，每个值的 $\\sigma_x = 0.03$ eV。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[[\\alpha,\\beta,[\\mu_1,\\ldots],[\\sigma_1,\\ldots]], \\ldots]$，所有数值条目均以 eV 为单位给出。浮点数必须使用标准十进制表示法打印。",
            "solution": "该问题要求开发并实现一种基于统计学原理的方法，用于估计线性 Brønsted–Evans–Polanyi (BEP) 关系的参数，并以量化的不确定性预测新的活化能。我们将首先基于加权最小二乘法和一阶不确定性传播推导必要的统计框架，然后实现该框架以解决所提供的测试用例。\n\n### 1. 线性模型的参数估计\n\nBEP 关系假定活化能 $E_a$ 和反应能 $\\Delta E$ 之间存在线性关系。对于一组包含 $N$ 个反应的训练集，该关系可以建模为：\n$$\nE_{a,i} = \\alpha \\Delta E_i + \\beta + \\epsilon_i \\quad \\text{for } i = 1, \\ldots, N\n$$\n其中 $(\\alpha, \\beta)$ 是未知的线性参数（斜率和截距），$\\epsilon_i$ 代表第 $i$ 个观测的误差项。问题陈述，测量的活化能（我们表示为 $y_i \\equiv E_{a,i}$）服从高斯分布误差，其标准差 $\\sigma_{y,i}$ 已知。我们假设训练集的反应能（表示为 $x_i \\equiv \\Delta E_i$）是精确已知的。因此，误差项 $\\epsilon_i$ 是独立的随机变量，满足 $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma_{y,i}^2)$。\n\n该框架导向一个加权最小二乘 (WLS) 问题。最优参数 $(\\hat{\\alpha}, \\hat{\\beta})$ 是那些最小化加权残差的平方和，也称为卡方 ($\\chi^2$) 统计量：\n$$\n\\chi^2(\\alpha, \\beta) = \\sum_{i=1}^{N} \\left(\\frac{y_i - (\\alpha x_i + \\beta)}{\\sigma_{y,i}}\\right)^2\n$$\n最小化 $\\chi^2$ 等价于在高斯误差模型下最大化数据的似然。为使解形式化，我们使用矩阵表示法。设参数向量为 $\\mathbf{\\theta} = [\\alpha, \\beta]^T$。模型写作 $\\mathbf{y} \\approx \\mathbf{X}\\mathbf{\\theta}$，其中：\n- $\\mathbf{y} = [y_1, y_2, \\ldots, y_N]^T$ 是观测到的活化能向量。\n- $\\mathbf{X}$ 是 $N \\times 2$ 的设计矩阵：\n$$\n\\mathbf{X} = \\begin{pmatrix}\nx_1  1 \\\\\nx_2  1 \\\\\n\\vdots  \\vdots \\\\\nx_N  1\n\\end{pmatrix}\n$$\n于是 $\\chi^2$ 统计量为：\n$$\n\\chi^2(\\mathbf{\\theta}) = (\\mathbf{y} - \\mathbf{X}\\mathbf{\\theta})^T \\mathbf{W} (\\mathbf{y} - \\mathbf{X}\\mathbf{\\theta})\n$$\n其中 $\\mathbf{W}$ 是对角权重矩阵，其元素为 $W_{ii} = 1/\\sigma_{y,i}^2$。\n\n为了找到最小化 $\\chi^2$ 的估计器 $\\hat{\\mathbf{\\theta}}$，我们将梯度对 $\\mathbf{\\theta}$ 的导数设为零：\n$$\n\\frac{\\partial \\chi^2}{\\partial \\mathbf{\\theta}} = -2\\mathbf{X}^T \\mathbf{W} (\\mathbf{y} - \\mathbf{X}\\hat{\\mathbf{\\theta}}) = \\mathbf{0}\n$$\n这得到了 WLS 的正规方程组：\n$$\n(\\mathbf{X}^T \\mathbf{W} \\mathbf{X}) \\hat{\\mathbf{\\theta}} = \\mathbf{X}^T \\mathbf{W} \\mathbf{y}\n$$\n如果矩阵 $(\\mathbf{X}^T \\mathbf{W} \\mathbf{X})$ 是可逆的（这要求至少有两个不同的 $x_i$ 值），则参数的估计器为：\n$$\n\\hat{\\mathbf{\\theta}} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} (\\mathbf{X}^T \\mathbf{W} \\mathbf{y})\n$$\n\n### 2. 参数估计的协方差与模型差异\n\n估计参数 $\\hat{\\mathbf{\\theta}}$ 的不确定性源于输入测量值 $\\mathbf{y}$ 的不确定性。$\\mathbf{y}$ 的协方差矩阵是 $\\mathbf{C}_y = \\mathbf{W}^{-1} = \\text{diag}(\\sigma_{y,1}^2, \\ldots, \\sigma_{y,N}^2)$。通过线性估计器方程传播此不确定性，得到参数的协方差矩阵 $\\mathbf{C}_{\\theta}$：\n$$\n\\mathbf{C}_{\\theta} = \\text{Cov}(\\hat{\\mathbf{\\theta}}) = ((\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{W}) \\mathbf{C}_y ((\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{W})^T\n$$\n代入 $\\mathbf{C}_y = \\mathbf{W}^{-1}$ 并注意到 $\\mathbf{W}$ 是对称的，上式简化为：\n$$\n\\mathbf{C}_{\\theta} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1}\n$$\n$\\mathbf{C}_{\\theta}$ 的对角元素是参数的方差，$\\sigma_\\alpha^2$ 和 $\\sigma_\\beta^2$，非对角元素是它们的协方差 $\\text{Cov}(\\alpha, \\beta)$。\n\n在 $\\hat{\\mathbf{\\theta}}$ 处 $\\chi^2$ 的最小值，记为 $\\chi^2_{\\text{min}}$，可作为拟合优度度量。约化卡方 $\\chi^2_{\\text{red}} = \\chi^2_{\\text{min}} / \\nu$，其中 $\\nu = N - p$ 是自由度（$N$ 个数据点，$p=2$ 个参数），如果模型正确且误差估计 $\\sigma_{y,i}$ 准确，则其期望值约为 1。$\\chi^2_{\\text{red}}  1$ 的值表明模型对数据的表征不佳，或者测量误差被低估。一种常见的做法是将参数协方差矩阵乘以该因子，以解释观测到的额外离散：\n$$\n\\mathbf{C}_{\\theta}^{\\text{inflated}} = S^2 \\cdot \\mathbf{C}_{\\theta} \\quad \\text{其中} \\quad S^2 = \\max(1, \\chi^2_{\\text{red}})\n$$\n该膨胀规则确保参数的不确定性反映了数据围绕拟合模型的实际离散程度，而不仅仅是报告的测量误差。在 $N=p$ 的特殊情况下（例如，用两个点拟合一条直线），$\\nu=0$ 且拟合是完美的，因此 $\\chi^2_{\\text{min}}=0$。分数 $\\chi^2_{\\text{red}}$ 变为 $0/0$。在这种情况下，我们没有信息来评估模型差异，因此按照惯例取 $S^2=1$。\n\n### 3. 新数据的预测和不确定性\n\n给定一个新的反应能 $\\Delta E^* \\equiv x^*$ 及其相关的不确定性 $\\sigma_x$，我们希望预测相应的活化能 $E_a^*$ 及其不确定性。\n\n预测的平均活化能 $\\mu$ 通过在 $x^*$ 处简单地评估拟合的线性模型获得：\n$$\n\\mu = \\hat{\\alpha} x^* + \\hat{\\beta} = [x^*, 1] \\hat{\\mathbf{\\theta}} = \\mathbf{x}^{*T} \\hat{\\mathbf{\\theta}}\n$$\n其中 $\\mathbf{x}^* = [x^*, 1]^T$。\n\n该预测的不确定性来自两个独立的来源：（1）拟合参数 $\\hat{\\mathbf{\\theta}}$ 的不确定性，以及（2）输入值 $x^*$ 的不确定性。我们使用一阶泰勒展开（delta 方法）来传播这些不确定性。预测的方差 $\\sigma_\\mu^2$ 由下式给出：\n$$\n\\sigma_\\mu^2 \\approx \\nabla f^T \\mathbf{C} \\nabla f\n$$\n其中 $f$ 是预测函数 $f(x^*, \\alpha, \\beta) = \\alpha x^* + \\beta$，$\\nabla f$ 是 $f$ 相对于其随机变量的梯度，$\\mathbf{C}$ 是它们的协方差矩阵。\n\n总方差 $\\sigma_{\\mu}^2$ 是来自参数不确定性和输入不确定性的方差之和：\n$$\n\\sigma_{\\mu}^2 = \\sigma_{\\text{param}}^2 + \\sigma_{\\text{input}}^2\n$$\n\n1.  **参数不确定性贡献**：由 $\\hat{\\mathbf{\\theta}}$ 的不确定性引起的方差为：\n    $$\n    \\sigma_{\\text{param}}^2 = \\mathbf{x}^{*T} \\mathbf{C}_{\\theta}^{\\text{inflated}} \\mathbf{x}^*\n    $$\n\n2.  **输入不确定性贡献（变量误差）**：由 $x^*$ 的不确定性引起的方差为：\n    $$\n    \\sigma_{\\text{input}}^2 = \\left(\\frac{\\partial f}{\\partial x^*}\\right)^2 \\sigma_x^2 = \\hat{\\alpha}^2 \\sigma_x^2\n    $$\n\n结合这些，预测的总方差为：\n$$\n\\sigma_{\\mu}^2 = \\mathbf{x}^{*T} \\mathbf{C}_{\\theta}^{\\text{inflated}} \\mathbf{x}^* + \\hat{\\alpha}^2 \\sigma_x^2\n$$\n预测的最终一倍标准差不确定性为 $\\sigma_{\\mu} = \\sqrt{\\sigma_{\\mu}^2}$。\n\n这样就完成了所需估计器及其相关预测不确定性的推导。现在将实现该算法来解决给定的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(train_DE, train_Ea, train_sigma_y, pred_DE, pred_sigma_x):\n    \"\"\"\n    Fits a linear BEP model using weighted least squares and predicts Ea values.\n\n    Args:\n        train_DE (list): Training reaction energies (x-values).\n        train_Ea (list): Training activation barriers (y-values).\n        train_sigma_y (list): Standard deviations of training activation barriers.\n        pred_DE (list): Reaction energies for which to predict Ea.\n        pred_sigma_x (float or list): Standard deviation(s) of prediction reaction energies.\n\n    Returns:\n        tuple: (alpha, beta, mu_list, sigma_list)\n               - alpha (float): Fitted slope.\n               - beta (float): Fitted intercept.\n               - mu_list (list): Predicted mean activation barriers.\n               - sigma_list (list): Predicted one-sigma uncertainties.\n    \"\"\"\n    # Convert inputs to numpy arrays for vectorized operations\n    x = np.array(train_DE)\n    y = np.array(train_Ea)\n    sigma_y = np.array(train_sigma_y)\n    \n    # --- 1. Parameter Estimation via Weighted Least Squares ---\n    \n    # Number of training points\n    N = len(x)\n    \n    # Design matrix X\n    X = np.vstack((x, np.ones(N))).T\n    \n    # Weight matrix W (diagonal with 1/sigma_y^2)\n    W = np.diag(1.0 / sigma_y**2)\n    \n    # Calculate (X^T * W * X)\n    X_T_W = X.T @ W\n    X_T_W_X = X_T_W @ X\n    \n    # Inverse of (X^T * W * X)\n    try:\n        X_T_W_X_inv = np.linalg.inv(X_T_W_X)\n    except np.linalg.LinAlgError:\n        # This would happen if X is not full rank (e.g., all x are the same)\n        # Not expected for the given test cases\n        return float('nan'), float('nan'), [], []\n\n    # Calculate (X^T * W * y)\n    X_T_W_y = X_T_W @ y\n    \n    # Estimate parameters theta_hat = [alpha, beta]\n    theta_hat = X_T_W_X_inv @ X_T_W_y\n    alpha, beta = theta_hat[0], theta_hat[1]\n    \n    # --- 2. Covariance and Model Discrepancy ---\n\n    # Basic parameter covariance matrix\n    C_theta = X_T_W_X_inv\n    \n    # Calculate reduced chi-squared and inflation factor S^2\n    p = 2  # number of parameters (alpha, beta)\n    dof = N - p\n    \n    if dof > 0:\n        residuals = y - (alpha * x + beta)\n        chi_squared_min = np.sum((residuals / sigma_y)**2)\n        chi_squared_red = chi_squared_min / dof\n        inflation_factor_sq = max(1.0, chi_squared_red)\n    else:\n        # For N=p, dof=0. No information to assess goodness of fit.\n        # By convention, assume no model discrepancy, so inflation factor is 1.\n        inflation_factor_sq = 1.0\n\n    # Inflated covariance matrix\n    C_theta_inflated = inflation_factor_sq * C_theta\n    \n    # --- 3. Prediction and Uncertainty Propagation ---\n    \n    pred_x = np.array(pred_DE)\n    if isinstance(pred_sigma_x, (int, float)):\n        pred_sx = np.full_like(pred_x, pred_sigma_x)\n    else:\n        pred_sx = np.array(pred_sigma_x)\n\n    mu_list = []\n    sigma_list = []\n    \n    for x_star, sigma_x in zip(pred_x, pred_sx):\n        # Mean prediction\n        mu = alpha * x_star + beta\n        mu_list.append(mu)\n        \n        # Prediction vector\n        x_star_vec = np.array([x_star, 1.0])\n        \n        # Variance from parameter uncertainty\n        var_param = x_star_vec.T @ C_theta_inflated @ x_star_vec\n        \n        # Variance from input uncertainty\n        var_input = (alpha**2) * (sigma_x**2)\n        \n        # Total variance and standard deviation\n        total_var = var_param + var_input\n        sigma = np.sqrt(total_var)\n        sigma_list.append(sigma)\n        \n    return alpha, beta, mu_list, sigma_list\n    \ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the final result.\n    \"\"\"\n    test_cases = [\n        {\n            \"train_DE\": [-0.45, 0.10, 0.35, 0.80, 1.20, -0.10, 0.55, 0.95],\n            \"train_Ea\": [0.62, 0.55, 0.60, 0.78, 0.92, 0.50, 0.72, 0.86],\n            \"train_sigma_y\": [0.05, 0.04, 0.04, 0.05, 0.06, 0.04, 0.05, 0.05],\n            \"pred_DE\": [0.00, 0.40, 1.00],\n            \"pred_sigma_x\": 0.02,\n        },\n        {\n            \"train_DE\": [-0.80, -0.30, 0.00, 0.20, 0.50],\n            \"train_Ea\": [0.70, 0.58, 0.56, 0.60, 0.68],\n            \"train_sigma_y\": [0.07, 0.05, 0.04, 0.05, 0.06],\n            \"pred_DE\": [0.00, -0.05, 0.05],\n            \"pred_sigma_x\": 0.01,\n        },\n        {\n            \"train_DE\": [0.20, 0.90],\n            \"train_Ea\": [0.60, 0.85],\n            \"train_sigma_y\": [0.08, 0.08],\n            \"pred_DE\": [-0.10, 0.50, 1.20],\n            \"pred_sigma_x\": 0.03,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, beta, mu_list, sigma_list = process_case(\n            case[\"train_DE\"],\n            case[\"train_Ea\"],\n            case[\"train_sigma_y\"],\n            case[\"pred_DE\"],\n            case[\"pred_sigma_x\"]\n        )\n        \n        # Format the result for the current case as required\n        case_result = [alpha, beta, mu_list, sigma_list]\n        results.append(case_result)\n\n    # Convert the list of results to the required string format\n    # The default str() on a list provides the correct '[...]' formatting.\n    # Joining these with ',' and enclosing in '[]' gives the final output.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了动力学模型后，下一步便是分析整个催化反应器系统的宏观行为。由于反应与输运过程的非线性耦合，催化系统常常表现出复杂的动态特性，如多重稳态和振荡。本练习将指导您实施一种先进的数值方法——伪弧长连续法 (Pseudo-Arclength Continuation)，以追踪反应器稳态解随关键参数（如 Damköhler 数 $D_a$）变化的完整轨迹。通过分析系统雅可比矩阵的特征值，您将学会如何识别导致系统失稳的临界点，特别是预测反应振荡起始的霍普夫 (Hopf) 分岔点 。",
            "id": "4042372",
            "problem": "您的任务是为与计算燃烧、表面反应和非均相催化相关的一个简化催化壁反应器模型，构建并实现一种数值延拓和稳定性检测方法。从基本守恒定律和经过充分检验的原理出发：一个近壁控制体，其中有一种反应物发生单一的一阶放热表面反应。气相反应物浓度和壁面温度由两个耦合的常微分方程（ODE）建模，这些方程源自质量和能量平衡，考虑了与主体和热浴的线性交换，以及一个阿伦尼乌斯型表面反应。状态向量为 $x = [c, T]$，其中 $c$ 是由其入口值归一化的无量纲近壁反应物浓度，$T$ 是由热浴温度归一化的无量纲壁面温度。控制参数是丹柯勒数（Da），记为 $D_a$，表示特征反应时间尺度与输运时间尺度之比。活化参数为 $\\beta  0$，放热参数为 $\\gamma  0$。质量和热量交换的时间尺度分别为 $\\tau_m  0$ 和 $\\tau_h  0$。无量纲动力系统为：\n$$\n\\frac{dc}{dt} = \\frac{1 - c}{\\tau_m} - D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c,\n$$\n$$\n\\frac{dT}{dt} = \\frac{1 - T}{\\tau_h} + \\gamma D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c.\n$$\n稳态 $(c^\\ast, T^\\ast)$ 满足 $F(x, D_a) = 0$，其中\n$$\nF(x, D_a) =\n\\begin{bmatrix}\n\\frac{1 - c}{\\tau_m} - D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c \\\\\n\\frac{1 - T}{\\tau_h} + \\gamma D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c\n\\end{bmatrix}.\n$$\n线性稳定性由雅可比矩阵 $J(x^\\ast, D_a) = \\left.\\frac{\\partial F}{\\partial x}\\right|_{(x^\\ast, D_a)}$ 决定，其 $2 \\times 2$ 个元素为：\n$$\n\\frac{\\partial f_1}{\\partial c} = -\\frac{1}{\\tau_m} - D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right), \\quad\n\\frac{\\partial f_1}{\\partial T} = - D_a c \\exp\\!\\left(-\\frac{\\beta}{T}\\right) \\frac{\\beta}{T^2},\n$$\n$$\n\\frac{\\partial f_2}{\\partial c} = \\gamma D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right), \\quad\n\\frac{\\partial f_2}{\\partial T} = -\\frac{1}{\\tau_h} + \\gamma D_a c \\exp\\!\\left(-\\frac{\\beta}{T}\\right) \\frac{\\beta}{T^2}.\n$$\n当 $J$ 的特征值以共轭复数对的形式穿过虚轴时，检测到霍普夫分岔。对于一个 $2 \\times 2$ 的雅可比矩阵，这可以通过以下条件检测：在穿越点两侧，行列式 $\\det(J)  0$，判别式 $\\Delta = \\operatorname{tr}(J)^2 - 4 \\det(J)  0$，并且迹 $\\operatorname{tr}(J)$ 在连续的延拓点之间符号发生改变。使用这些准则来检测延拓路径上的第一个霍普夫分岔。\n\n实现一个伪弧长延拓（PAC）方案，以追踪当 $D_a$ 变化时稳态解分支 $x^\\ast(D_a)$。您的算法必须：\n- 从 $D_a = 0$ 和稳态 $x^\\ast = [1, 1]$ 开始初始化。\n- 通过求解 $J(x^\\ast, 0) \\frac{dx^\\ast}{d D_a} = - \\frac{\\partial F}{\\partial D_a}(x^\\ast, 0)$ 来计算初始切向量，其中\n$$\n\\frac{\\partial F}{\\partial D_a}(x, D_a) =\n\\begin{bmatrix}\n- \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c \\\\\n\\gamma \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c\n\\end{bmatrix}.\n$$\n- 沿切线方向使用弧长增量 $\\Delta s$ 进行预测步，形成预测点 $(x_{\\text{pred}}, D_{a,\\text{pred}})$。\n- 应用牛顿校正法求解增广系统\n$$\nG(x, D_a) =\n\\begin{bmatrix}\nF(x, D_a) \\\\\nt_x^\\top (x - x_{\\text{prev}}) + t_{D_a} (D_a - D_{a,\\text{prev}}) - \\Delta s\n\\end{bmatrix} = 0,\n$$\n其中 $t = [t_x, t_{D_a}]$ 是前一个切向量，$(x_{\\text{prev}}, D_{a,\\text{prev}})$ 是前一个校正解。使用增广雅可比矩阵\n$$\n\\frac{\\partial G}{\\partial (x, D_a)} =\n\\begin{bmatrix}\nJ(x, D_a)  \\frac{\\partial F}{\\partial D_a}(x, D_a) \\\\\nt_x^\\top  t_{D_a}\n\\end{bmatrix}.\n$$\n- 在每个校正解之后，通过求解 $J \\frac{dx^\\ast}{d D_a} = - \\frac{\\partial F}{\\partial D_a}$ 来重新计算 $\\frac{dx^\\ast}{d D_a}$，并对 $[t_x, t_{D_a}] = \\left[\\frac{dx^\\ast}{d D_a}, 1\\right]$ 进行归一化，以更新切向量。\n- 使用上述条件检测霍普夫分岔；通过在符号改变发生且两侧判别式均为负的连续点之间对 $\\operatorname{tr}(J)$ 进行线性插值，来近似计算穿越点的 $D_a$。\n\n所有变量和参数都是无量纲的。使用鲁棒的数值保护措施以避免除以零，例如将任何 $\\exp(-\\beta/T)$ 的计算替换为 $\\exp(-\\beta/\\max(T, \\epsilon))$，其中 $\\epsilon$ 是一个小的正数。为校正器使用牛顿迭代容差 $\\varepsilon$ 和最大迭代次数。如果在任何步骤中校正器未能收敛，则终止该测试用例的延拓。\n\n测试套件：\n为以下3个参数集运行您的程序，每个参数集以 $(\\tau_m, \\tau_h, \\beta, \\gamma, D_{a,\\max}, \\Delta s, N_{\\text{steps}}, \\varepsilon)$ 的形式给出，其中 $N_{\\text{steps}}$ 是最大延拓步数。对于每种情况，从 $D_a = 0$ 开始，继续延拓直到 $D_a \\ge D_{a,\\max}$ 或达到 $N_{\\text{steps}}$，并报告第一个检测到的霍普夫分岔点 $D_a$ 作为浮点值。如果没有检测到霍普夫分岔，则对该测试用例输出 $-1.0$。\n- 情况1：$(0.5, 5.0, 12.0, 8.0, 6.0, 0.02, 400, 10^{-10})$。\n- 情况2（边界情况，可能没有霍普夫分岔）：$(2.0, 2.0, 8.0, 2.0, 10.0, 0.02, 500, 10^{-10})$。\n- 情况3（边界情况，具有更高的活化能和放热性）：$(0.1, 10.0, 15.0, 10.0, 3.0, 0.01, 500, 10^{-10})$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含3个浮点数结果（每个测试用例一个），格式为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3]$。不涉及物理单位；所有输出均为无量纲。",
            "solution": "该问题要求实现一种数值延拓和稳定性分析方法，以追踪催化壁反应器模型的稳态解，并检测霍普夫分岔。指定的方法是伪弧长延拓（PAC）方案，结合基于系统雅可比矩阵的线性稳定性分析。该问题经确认为科学上合理、适定，并包含获得唯一数值解所需的所有信息。\n\n该物理系统由一对耦合的常微分方程描述，分别代表无量纲近壁反应物浓度 $c$ 和无量纲壁面温度 $T$。状态向量为 $x = [c, T]^\\top$。系统的演化由以下方程控制：\n$$\n\\frac{d c}{dt} = f_1(c, T, D_a) = \\frac{1 - c}{\\tau_m} - D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c\n$$\n$$\n\\frac{d T}{dt} = f_2(c, T, D_a) = \\frac{1 - T}{\\tau_h} + \\gamma D_a \\exp\\!\\left(-\\frac{\\beta}{T}\\right) c\n$$\n其中 $\\tau_m$ 和 $\\tau_h$ 是质量和热量输运的时间尺度，$\\beta$ 是活化参数，$\\gamma$ 是放热参数，$D_a$ 是丹柯勒数，用作延拓参数。\n\n稳态 $(c^\\ast, T^\\ast)$ 是代数方程组 $F(x, D_a) = [f_1, f_2]^\\top = 0$ 的解。任务的核心是在状态-参数空间 $(x, D_a)$ 中追踪解曲线 $x^\\ast(D_a)$。\n\n实现过程如下：\n\n**1. 伪弧长延拓 (PAC)**\n采用 PAC 方法来追踪解分支，包括穿越转折点（折叠点），在这些点上，以参数 $D_a$ 为自变量的标准延拓方法会失效。\n\n**1.1. 初始化**\n延拓从一个已知解开始。在 $D_a = 0$ 时，系统简化为 $\\frac{1-c}{\\tau_m} = 0$ 和 $\\frac{1-T}{\\tau_h} = 0$，得到平凡稳态 $x^\\ast = [c^\\ast, T^\\ast] = [1, 1]$。这是我们解分支上的第一个点。\n\n**1.2. 切向量计算**\n解曲线的切向量为预测步提供了方向。它是通过对稳态方程 $F(x(D_a), D_a) = 0$ 关于弧长参数 $s$ 求导得到的。一个更直接的方法，如问题所述，是计算关于 $D_a$ 的导数。设切向量为 $t = [\\frac{dx^\\ast}{ds}, \\frac{dD_a}{ds}]$。根据链式法则，$\\frac{\\partial F}{\\partial x} \\frac{dx^\\ast}{dD_a} + \\frac{\\partial F}{\\partial D_a} = 0$。这给出了切向量状态空间分量的线性方程组：\n$$\nJ(x^\\ast, D_a) \\frac{dx^\\ast}{dD_a} = - \\frac{\\partial F}{\\partial D_a}(x^\\ast, D_a)\n$$\n其中 $J$ 是雅可比矩阵，$\\frac{\\partial F}{\\partial D_a}$ 是系统函数对参数的偏导数。问题指定将未归一化的切向量构造为 $[\\frac{dx^\\ast}{dD_a}, 1]$，然后将其归一化为单位长度，$t = [t_x, t_{D_a}]$。此过程在远离折叠分岔点时有效。\n所需的偏导数为：\n$$\nJ = \\begin{bmatrix} -\\frac{1}{\\tau_m} - R  -R \\frac{\\beta c}{T^2} \\\\ \\gamma R  -\\frac{1}{\\tau_h} + \\gamma R \\frac{\\beta c}{T^2} \\end{bmatrix}, \\quad \\frac{\\partial F}{\\partial D_a} = \\begin{bmatrix} -R/D_a \\\\ \\gamma R/D_a \\end{bmatrix}\n$$\n其中反应速率项为 $R = D_a \\exp(-\\beta/T) c$。初始切向量在 $(x, D_a) = ([1,1], 0)$ 处使用此系统计算。在指数项中使用数值保护措施 $T_{\\text{safe}} = \\max(T, \\epsilon)$（其中 $\\epsilon0$ 为一个小数），以防止当 $T$ 趋近于零时出现除以零或浮点溢出。\n\n**1.3. 预测-校正步骤**\n延拓是迭代进行的。从一个已知的解点 $(x_{\\text{prev}}, D_{a,\\text{prev}})$ 和切向量 $t$ 出发，预测一个新点，然后进行校正。\n\n*   **预测器**：沿切线方向以固定的弧长步长 $\\Delta s$ 进行一次 Euler 步：\n    $$\n    (x_{\\text{pred}}, D_{a,\\text{pred}}) = (x_{\\text{prev}}, D_{a,\\text{prev}}) + \\Delta s \\cdot t\n    $$\n*   **校正器**：通过使用牛顿法求解一个增广系统来精化预测点。该系统由原始稳态方程和一个约束条件组成，该约束条件迫使校正步垂直于切平面，从而将解固定在所需弧长处解曲线上的一个特定点。为求解校正点 $(x, D_a)$ 而建立的系统是 $G(x, D_a) = 0$：\n    $$\n    G(x, D_a) =\n    \\begin{bmatrix}\n    F(x, D_a) \\\\\n    t_x^\\top (x - x_{\\text{prev}}) + t_{D_a} (D_a - D_{a,\\text{prev}}) - \\Delta s\n    \\end{bmatrix} = 0\n    $$\n    牛顿法迭代求解线性系统 $\\frac{\\partial G}{\\partial (x, D_a)} \\Delta z = -G(z)$ 以获得更新量 $\\Delta z = [\\Delta x, \\Delta D_a]^\\top$，其中增广雅可比矩阵为：\n    $$\n    \\frac{\\partial G}{\\partial (x, D_a)} =\n    \\begin{bmatrix}\n    J(x, D_a)  \\frac{\\partial F}{\\partial D_a}(x, D_a) \\\\\n    t_x^\\top  t_{D_a}\n    \\end{bmatrix}\n    $$\n\n**2. 稳定性分析与霍普夫分岔检测**\n在每个成功的校正步骤之后，评估新稳态解 $(x^\\ast, D_{a}^\\ast)$ 的稳定性。线性稳定性由雅可比矩阵 $J(x^\\ast, D_{a}^\\ast)$ 的特征值 $\\lambda_{1,2}$ 决定。\n\n对于 $2 \\times 2$ 系统，特征值由 $\\lambda_{1,2} = \\frac{\\operatorname{tr}(J) \\pm \\sqrt{\\operatorname{tr}(J)^2 - 4\\det(J)}}{2}$ 给出。当一对共轭复数特征值穿过虚轴时，发生霍普夫分岔。这对应于以下条件：\n1.  特征值的实部变号：$\\operatorname{Re}(\\lambda) = \\frac{\\operatorname{tr}(J)}{2}$ 穿过零。这意味着我们必须检测到迹 $\\operatorname{tr}(J)$ 的符号变化。\n2.  在穿越点特征值为复数：判别式必须为负，$\\Delta = \\operatorname{tr}(J)^2 - 4\\det(J)  0$。由于在分岔点 $\\operatorname{tr}(J) = 0$，这简化为要求 $\\det(J)  0$。\n\n在数值上，如果在两个连续的延拓点（索引为 $i$ 和 $i+1$）之间检测到霍普夫分岔，则需满足：\n*   $\\operatorname{tr}(J_i) \\cdot \\operatorname{tr}(J_{i+1})  0$（符号变化）。\n*   $\\det(J_i)  0$ 且 $\\det(J_{i+1})  0$。\n*   $\\operatorname{tr}(J_i)^2 - 4\\det(J_i)  0$ 且 $\\operatorname{tr}(J_{i+1})^2 - 4\\det(J_{i+1})  0$。\n\n一旦找到包含分岔点的一对点，分岔点处的 $D_a$ 值 $D_{a,Hopf}$ 可通过线性插值估算，即找到连接 $(\\operatorname{tr}(J_i), D_{a,i})$ 和 $(\\operatorname{tr}(J_{i+1}), D_{a,i+1})$ 的线段的根：\n$$\nD_{a,Hopf} = D_{a,i} - \\operatorname{tr}(J_i) \\frac{D_{a,i+1} - D_{a,i}}{\\operatorname{tr}(J_{i+1}) - \\operatorname{tr}(J_i)}\n$$\n报告第一个这样检测到的点。如果延拓完成而未满足这些条件，则表示未找到霍普夫分岔。对于给定的参数集，该过程在检测到第一个霍普夫点、达到最大步数 $N_{\\text{steps}}$、超过最大参数值 $D_{a,\\max}$ 或牛顿校正器未能收敛时终止。",
            "answer": "```python\nimport numpy as np\n\n# Global constants for numerical stability and convergence\nSAFEGUARD_EPSILON = 1e-12\nNEWTON_MAX_ITER = 20\n\ndef eval_F(x, Da, params):\n    \"\"\"Evaluates the steady-state system function F(x, Da).\"\"\"\n    c, T = x\n    tau_m, tau_h, beta, gamma, _, _, _, _ = params\n    \n    T_safe = np.maximum(T, SAFEGUARD_EPSILON)\n    \n    try:\n        exp_term = np.exp(-beta / T_safe)\n    except FloatingPointError:\n        exp_term = 0.0 # Effectively handles large beta/T\n\n    reaction_term = Da * exp_term * c\n    \n    f1 = (1.0 - c) / tau_m - reaction_term\n    f2 = (1.0 - T) / tau_h + gamma * reaction_term\n    \n    return np.array([f1, f2])\n\ndef eval_Jacobian(x, Da, params):\n    \"\"\"Evaluates the Jacobian matrix J = dF/dx.\"\"\"\n    c, T = x\n    tau_m, tau_h, beta, gamma, _, _, _, _ = params\n    \n    T_safe = np.maximum(T, SAFEGUARD_EPSILON)\n    \n    try:\n        exp_term = np.exp(-beta / T_safe)\n    except FloatingPointError:\n        exp_term = 0.0\n\n    R = Da * exp_term\n    R_prime_T = R * beta / (T_safe**2)\n\n    j11 = -1.0 / tau_m - R\n    j12 = -c * R_prime_T\n    j21 = gamma * R\n    j22 = -1.0 / tau_h + gamma * c * R_prime_T\n    \n    return np.array([[j11, j12], [j21, j22]])\n\ndef eval_F_Da(x, Da, params):\n    \"\"\"Evaluates the partial derivative dF/dDa.\"\"\"\n    c, T = x\n    _, _, beta, gamma, _, _, _, _ = params\n\n    T_safe = np.maximum(T, SAFEGUARD_EPSILON)\n\n    try:\n        exp_term = np.exp(-beta / T_safe)\n    except FloatingPointError:\n        exp_term = 0.0\n\n    f1_Da = -exp_term * c\n    f2_Da = gamma * exp_term * c\n    \n    return np.array([f1_Da, f2_Da])\n\ndef run_continuation(params):\n    \"\"\"\n    Performs pseudo-arclength continuation and Hopf bifurcation detection.\n    \"\"\"\n    _, _, _, _, Da_max, ds, N_steps, newton_tol = params\n    \n    # Initialization\n    x_curr = np.array([1.0, 1.0])\n    Da_curr = 0.0\n    \n    history_x = [x_curr]\n    history_Da = [Da_curr]\n    history_stability = []\n\n    # Initial tangent calculation\n    try:\n        J0 = eval_Jacobian(x_curr, Da_curr, params)\n        F_Da0 = eval_F_Da(x_curr, Da_curr, params)\n        dx_dDa = np.linalg.solve(J0, -F_Da0)\n    except np.linalg.LinAlgError:\n        return -1.0 # Should not happen at Da=0\n\n    # Form and normalize tangent\n    t_unnorm = np.append(dx_dDa, 1.0)\n    t_curr = t_unnorm / np.linalg.norm(t_unnorm)\n\n    # Initial stability\n    tr = np.trace(J0)\n    det = np.linalg.det(J0)\n    history_stability.append({'trace': tr, 'det': det})\n\n    for _ in range(N_steps):\n        # Store previous state for corrector and interpolation\n        x_prev, Da_prev = x_curr, Da_curr\n        t_prev = t_curr\n        \n        # Predictor step\n        x_pred = x_prev + ds * t_prev[:2]\n        Da_pred = Da_prev + ds * t_prev[2]\n\n        # Corrector (Newton's method)\n        x_new, Da_new = x_pred, Da_pred\n        \n        converged = False\n        for _ in range(NEWTON_MAX_ITER):\n            try:\n                # Build augmented system\n                F_val = eval_F(x_new, Da_new, params)\n                N_val = np.dot(t_prev[:2], x_new - x_prev) + t_prev[2] * (Da_new - Da_prev) - ds\n                G = np.append(F_val, N_val)\n\n                if np.linalg.norm(G)  newton_tol:\n                    converged = True\n                    break\n\n                J_new = eval_Jacobian(x_new, Da_new, params)\n                F_Da_new = eval_F_Da(x_new, Da_new, params)\n                \n                aug_J = np.zeros((3, 3))\n                aug_J[:2, :2] = J_new\n                aug_J[:2, 2] = F_Da_new\n                aug_J[2, :2] = t_prev[:2]\n                aug_J[2, 2] = t_prev[2]\n                \n                delta = np.linalg.solve(aug_J, -G)\n                x_new += delta[:2]\n                Da_new += delta[2]\n            except (np.linalg.LinAlgError, FloatingPointError):\n                return -1.0 # Corrector failed\n\n        if not converged:\n            return -1.0 # Corrector failed to converge\n\n        x_curr, Da_curr = x_new, Da_new\n        \n        # Check termination conditions\n        if Da_curr >= Da_max or Da_curr  0: # Stop if Da goes too high or negative\n            break\n\n        # Stability analysis and Hopf detection\n        J_curr = eval_Jacobian(x_curr, Da_curr, params)\n        tr_curr = np.trace(J_curr)\n        det_curr = np.linalg.det(J_curr)\n        \n        prev_stability = history_stability[-1]\n        tr_prev = prev_stability['trace']\n        det_prev = prev_stability['det']\n        \n        # Hopf conditions: tr sign change, det > 0, discriminant  0\n        if tr_curr * tr_prev  0:\n            if det_curr > 0 and det_prev > 0:\n                disc_curr = tr_curr**2 - 4 * det_curr\n                disc_prev = tr_prev**2 - 4 * det_prev\n                if disc_curr  0 and disc_prev  0:\n                    # Linearly interpolate to find Da where trace is zero\n                    Da_hopf = Da_prev - tr_prev * (Da_curr - Da_prev) / (tr_curr - tr_prev)\n                    return Da_hopf\n\n        # Store current state for next iteration\n        history_x.append(x_curr)\n        history_Da.append(Da_curr)\n        history_stability.append({'trace': tr_curr, 'det': det_curr})\n\n        # Update tangent\n        try:\n            dx_dDa = np.linalg.solve(J_curr, -eval_F_Da(x_curr, Da_curr, params))\n            t_unnorm = np.append(dx_dDa, 1.0)\n            \n            # The problem does not specify orientation check, but it's good practice.\n            # However, to be strict, we'll follow the exact wording.\n            t_new = t_unnorm / np.linalg.norm(t_unnorm)\n\n            # Ensure consistent direction of travel along the arc\n            # Check dot product with previous tangent. If it's negative, flip.\n            if np.dot(t_new, t_prev)  0:\n                t_new = -t_new\n\n            t_curr = t_new\n\n        except np.linalg.LinAlgError:\n            # This can happen at a fold point where J is singular.\n            # The PAC framework is designed to handle this, but the tangent calculation as written will fail.\n            # A more robust tangent calculation (e.g., using null space of augmented Jacobian) would be needed.\n            # For this problem, we assume folds are not encountered in a way that breaks this simpler tangent update.\n            # If a fold is hit exactly, we can try to continue with the previous tangent or stop.\n            # Let's stop to be safe as the problem doesn't specify recovery.\n            return -1.0\n\n    return -1.0 # No Hopf bifurcation found\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (tau_m, tau_h, beta, gamma, Da_max, ds, N_steps, newton_tol)\n        (0.5, 5.0, 12.0, 8.0, 6.0, 0.02, 400, 1e-10),\n        (2.0, 2.0, 8.0, 2.0, 10.0, 0.02, 500, 1e-10),\n        (0.1, 10.0, 15.0, 10.0, 3.0, 0.01, 500, 1e-10),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_continuation(params)\n        results.append(f\"{result:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}