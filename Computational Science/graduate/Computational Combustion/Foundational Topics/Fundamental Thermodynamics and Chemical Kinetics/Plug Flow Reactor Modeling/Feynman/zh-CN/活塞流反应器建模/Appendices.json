{
    "hands_on_practices": [
        {
            "introduction": "对平推流反应器（PFR）的理解始于其基本的设计方程。第一个实践旨在引导你从一个微分摩尔衡算式中推导出这个核心方程，这是任何化学工程师都必须掌握的关键技能。接着，你将对这个方程在简单的一级和二级动力学条件下进行积分 ，从而具体地理解反应动力学如何直接影响所需的反应器尺寸。",
            "id": "3872934",
            "problem": "一种液相、等温、不可逆的物种 $A$ 到 $B$ 的异构化反应在平推流反应器（PFR）中进行。进料只包含物种 $A$，其摩尔流率为 $F_{A0}$，浓度为 $C_{A0}$。密度恒定，体积流量恒定，无副反应，且轴向扩散可忽略不计。根据候选的微观动力学机理，$A$ 的消失速率可能是关于 $A$ 的一级或二级反应：\n- 一级反应假设：$-r_{A} = k_{1} C_{A}$，其中 $k_{1}$ 为常数。\n- 二级反应假设：$-r_{A} = k_{2} C_{A}^{2}$，其中 $k_{2}$ 为常数。\n\n从反应器微分切片的稳态摩尔衡算和转化率的定义出发，推导PFR设计方程 $\\mathrm{d}X/\\mathrm{d}V = -r_{A}/F_{A0}$。然后，利用液相、恒密关系式 $C_{A} = C_{A0}(1-X)$，积分得到在每种动力学假设下，反应器体积 $V$ 作为转化率 $X$ 的函数。对于目标转化率 $X = 0.85$（在恒定温度 $T$下），进料摩尔流率 $F_{A0} = 10\\ \\mathrm{kmol}/\\mathrm{h}$，进料浓度 $C_{A0} = 1.0\\ \\mathrm{kmol}/\\mathrm{m}^{3}$，一级反应速率常数 $k_{1} = 0.75\\ \\mathrm{h}^{-1}$，以及二级反应速率常数 $k_{2} = 1.6\\ \\mathrm{m}^{3}/(\\mathrm{kmol}\\cdot\\mathrm{h})$，计算在两种动力学假设下，为达到 $X = 0.85$ 所需的反应器体积的无量纲比值 $V_{\\text{second}}/V_{\\text{first}}$。将最终比值四舍五入到四位有效数字，并以无单位的纯数字形式报告。",
            "solution": "该问题陈述经评估具有科学依据、提法恰当、客观、完整且一致。它代表了化学反应器设计中的一个标准问题。因此，有必要给出完整解答。\n\n解答按要求分三个阶段进行：首先，推导以转化率表示的平推流反应器（PFR）设计方程；其次，对该方程在一级和二级动力学条件下进行积分，求出所需反应器体积 $V$ 作为转化率 $X$ 的函数；第三，在指定条件下计算两种动力学模型的体积数值比。\n\n**1. PFR设计方程的推导**\n\n我们首先对稳态运行的PFR中的一个微元体积 $\\mathrm{d}V$ 内的物种 $A$ 进行摩尔衡算。通用摩尔衡算方程为：\n$$\n\\text{流入} - \\text{流出} + \\text{生成} = \\text{累积}\n$$\n对于从体积 $V$ 到 $V + \\mathrm{d}V$ 的一个微分切片，以及对物种 $A$ 而言，这可以转化为：\n$$\nF_{A}|_{V} - F_{A}|_{V+\\mathrm{d}V} + r_{A} \\mathrm{d}V = 0\n$$\n其中 $F_A$ 是 $A$ 的摩尔流率，$r_A$ 是单位体积内 $A$ 的生成速率。由于是稳态假设，累积项为零。\n$F_{A}|_{V+\\mathrm{d}V}$ 项可以表示为在 $V$ 附近的 Taylor 级数展开：$F_{A}|_{V+\\mathrm{d}V} = F_{A}|_{V} + \\frac{\\mathrm{d}F_A}{\\mathrm{d}V}\\mathrm{d}V + \\dots$。忽略高阶项，衡算式变为：\n$$\nF_{A}|_{V} - \\left( F_{A}|_{V} + \\frac{\\mathrm{d}F_A}{\\mathrm{d}V}\\mathrm{d}V \\right) + r_{A} \\mathrm{d}V = 0\n$$\n$$\n-\\frac{\\mathrm{d}F_A}{\\mathrm{d}V}\\mathrm{d}V + r_{A} \\mathrm{d}V = 0\n$$\n两边同除以 $\\mathrm{d}V$ 得到以摩尔流率表示的PFR设计方程：\n$$\n\\frac{\\mathrm{d}F_A}{\\mathrm{d}V} = r_A\n$$\n反应物 $A$ 的分数转化率 $X$ 定义为已反应的 $A$ 的摩尔数占初始摩尔数的分数：\n$$\nX = \\frac{F_{A0} - F_A}{F_{A0}}\n$$\n其中 $F_{A0}$ 是反应器入口处（$V=0$）$A$ 的摩尔进料速率。整理可得 $F_A$：\n$$\nF_A = F_{A0}(1-X)\n$$\n由于 $F_{A0}$ 是常数，将 $F_A$ 对反应器体积 $V$ 求导可得：\n$$\n\\frac{\\mathrm{d}F_A}{\\mathrm{d}V} = \\frac{\\mathrm{d}}{\\mathrm{d}V}[F_{A0}(1-X)] = -F_{A0}\\frac{\\mathrm{d}X}{\\mathrm{d}V}\n$$\n将此结果代入摩尔衡算式 $\\frac{\\mathrm{d}F_A}{\\mathrm{d}V} = r_A$ 中，得到：\n$$\n-F_{A0}\\frac{\\mathrm{d}X}{\\mathrm{d}V} = r_A\n$$\n最后，我们整理得到题目要求的以转化率 $X$ 和 $A$ 的消失速率 $-r_A = -r_{A, \\text{formation}} = r_{A, \\text{disappearance}}$ 表示的PFR设计方程：\n$$\n\\frac{\\mathrm{d}X}{\\mathrm{d}V} = \\frac{-r_A}{F_{A0}}\n$$\n至此，第一部分的推导完成。\n\n**2. 反应器体积作为转化率的函数**\n\n对于密度恒定的液相反应，体积流量 $v$ 是恒定的。物种 $A$ 的浓度 $C_A$ 与其摩尔流率 $F_A$ 的关系为 $C_A = F_A/v$。在入口处，$C_{A0} = F_{A0}/v_{0}$。由于 $v=v_0$，我们可以写出：\n$$\nC_A = \\frac{F_A}{v_0} = \\frac{F_{A0}(1-X)}{v_0} = C_{A0}(1-X)\n$$\n这证实了问题陈述中给出的关系。现在我们对每种动力学假设积分设计方程。\n\n设计方程可以分离变量并积分，以求得达到转化率 $X$ 所需的体积 $V$：\n$$\nV = F_{A0} \\int_{0}^{X} \\frac{1}{-r_A} \\mathrm{d}X'\n$$\n\n**一级反应假设：**\n速率定律为 $-r_A = k_1 C_A$。代入浓度表达式，我们得到：\n$$\n-r_A = k_1 C_{A0}(1-X)\n$$\n将此代入设计方程的积分形式：\n$$\nV_{\\text{first}} = F_{A0} \\int_{0}^{X} \\frac{1}{k_1 C_{A0}(1-X')} \\mathrm{d}X'\n$$\n由于 $F_{A0}$、$k_1$ 和 $C_{A0}$ 是常数，我们可以将它们从积分中提出：\n$$\nV_{\\text{first}} = \\frac{F_{A0}}{k_1 C_{A0}} \\int_{0}^{X} \\frac{1}{1-X'} \\mathrm{d}X' = \\frac{F_{A0}}{k_1 C_{A0}} [-\\ln(1-X')]_{0}^{X}\n$$\n$$\nV_{\\text{first}} = \\frac{F_{A0}}{k_1 C_{A0}} [-\\ln(1-X) - (-\\ln(1-0))] = -\\frac{F_{A0}}{k_1 C_{A0}} \\ln(1-X) = \\frac{F_{A0}}{k_1 C_{A0}} \\ln\\left(\\frac{1}{1-X}\\right)\n$$\n\n**二级反应假设：**\n速率定律为 $-r_A = k_2 C_A^2$。代入浓度表达式：\n$$\n-r_A = k_2 (C_{A0}(1-X))^2 = k_2 C_{A0}^2 (1-X)^2\n$$\n将此代入积分设计方程：\n$$\nV_{\\text{second}} = F_{A0} \\int_{0}^{X} \\frac{1}{k_2 C_{A0}^2 (1-X')^2} \\mathrm{d}X'\n$$\n将常数从积分中提出：\n$$\nV_{\\text{second}} = \\frac{F_{A0}}{k_2 C_{A0}^2} \\int_{0}^{X} (1-X')^{-2} \\mathrm{d}X' = \\frac{F_{A0}}{k_2 C_{A0}^2} \\left[\\frac{1}{1-X'}\\right]_{0}^{X}\n$$\n$$\nV_{\\text{second}} = \\frac{F_{A0}}{k_2 C_{A0}^2} \\left(\\frac{1}{1-X} - \\frac{1}{1-0}\\right) = \\frac{F_{A0}}{k_2 C_{A0}^2} \\left(\\frac{1 - (1-X)}{1-X}\\right)\n$$\n$$\nV_{\\text{second}} = \\frac{F_{A0}}{k_2 C_{A0}^2} \\left(\\frac{X}{1-X}\\right)\n$$\n\n**3. 反应器体积比的计算**\n\n我们现在使用推导出的表达式计算比值 $V_{\\text{second}}/V_{\\text{first}}$：\n$$\n\\frac{V_{\\text{second}}}{V_{\\text{first}}} = \\frac{\\frac{F_{A0}}{k_2 C_{A0}^2} \\left(\\frac{X}{1-X}\\right)}{\\frac{F_{A0}}{k_1 C_{A0}} \\ln\\left(\\frac{1}{1-X}\\right)}\n$$\n通过消去项（$F_{A0}$ 和一个 $C_{A0}$ 因子）来简化表达式：\n$$\n\\frac{V_{\\text{second}}}{V_{\\text{first}}} = \\frac{k_1}{k_2 C_{A0}} \\frac{\\left(\\frac{X}{1-X}\\right)}{\\ln\\left(\\frac{1}{1-X}\\right)}\n$$\n这是比值的最终符号表达式。现在，我们代入给定的数值：\n- 目标转化率 $X = 0.85$。\n- 一级反应速率常数 $k_1 = 0.75\\ \\mathrm{h}^{-1}$。\n- 二级反应速率常数 $k_2 = 1.6\\ \\mathrm{m}^{3}/(\\mathrm{kmol}\\cdot\\mathrm{h})$。\n- 进料浓度 $C_{A0} = 1.0\\ \\mathrm{kmol}/\\mathrm{m}^{3}$。\n\n首先，计算中间项：\n$$\n1 - X = 1 - 0.85 = 0.15\n$$\n$$\n\\frac{X}{1-X} = \\frac{0.85}{0.15} = \\frac{17}{3}\n$$\n$$\n\\frac{1}{1-X} = \\frac{1}{0.15} = \\frac{20}{3}\n$$\n$$\n\\ln\\left(\\frac{1}{1-X}\\right) = \\ln\\left(\\frac{20}{3}\\right)\n$$\n现在，将这些连同常数一起代入比值表达式中：\n$$\n\\frac{V_{\\text{second}}}{V_{\\text{first}}} = \\frac{0.75\\ \\mathrm{h}^{-1}}{(1.6\\ \\mathrm{m}^{3}/(\\mathrm{kmol}\\cdot\\mathrm{h})) (1.0\\ \\mathrm{kmol}/\\mathrm{m}^{3})} \\frac{\\frac{17}{3}}{\\ln\\left(\\frac{20}{3}\\right)}\n$$\n第一项中的单位相互抵消，正如无量纲比值所预期的那样：\n$$\n\\frac{V_{\\text{second}}}{V_{\\text{first}}} = \\frac{0.75}{1.6} \\frac{\\frac{17}{3}}{\\ln\\left(\\frac{20}{3}\\right)} = 0.46875 \\times \\frac{5.666...}{1.8971199...}\n$$\n$$\n\\frac{V_{\\text{second}}}{V_{\\text{first}}} = 0.46875 \\times 2.986980... \\approx 1.399678...\n$$\n将最终结果四舍五入到四位有效数字，得到 $1.400$。",
            "answer": "$$\n\\boxed{1.400}\n$$"
        },
        {
            "introduction": "现实世界中的反应器很少是等温的。这个实践将我们带入更为复杂且贴近现实的非等温系统领域，在这里，质量平衡与能量平衡相互耦合。你将为一个包含可逆反应的绝热PFR建立并求解模型，探索温度、反应速率和化学平衡限制之间的关键相互作用 ，并学习如何用数值方法判断反应何时达到“停滞”状态。",
            "id": "3894917",
            "problem": "考虑一个稳态、绝热的平推流反应器 (PFR)，其中两种气相物质之间发生单一、基元、可逆的吸热反应 $A \\rightleftharpoons B$。该反应器横截面积恒定，并在恒定压力下运行。进料中可能含有一种惰性物质 $I$。总摩尔流量 $F_{\\text{tot}}$ 是物质 $A$、$B$ 和 $I$ 的摩尔流量之和。必须使用以下基本原理来推导模型：\n- 对于 PFR 中的物质 $i$，其一维稳态摩尔衡算为 $dF_i/dz = \\nu_i r V'$，其中 $z$ 是轴向坐标（单位：米），$\\nu_i$ 是物质 $i$ 的化学计量系数，$r$ 是反应进程速率（单位：$\\text{mol}/(\\text{m}^3\\cdot\\text{s})$），$V' = A_c$ 是反应器横截面积（单位：$\\text{m}^2$）。\n- 对于绝热 PFR，其一维稳态能量衡算为 $dT/dz = -\\Delta H_{\\text{rxn}}\\, r\\, A_c / \\left(\\sum_j F_j C_{p,j}\\right)$，其中 $T$ 是温度（单位：$\\text{K}$），$\\Delta H_{\\text{rxn}} > 0$ 是吸热反应焓（单位：$\\text{J}/\\text{mol}$），$C_{p,j}$ 是物质 $j$ 的恒压摩尔热容（单位：$\\text{J}/(\\text{mol}\\cdot\\text{K})$），求和项涵盖所有存在的物质。\n- 理想气体定律意味着总摩尔浓度 $C_{\\text{tot}} = P/(R T)$（单位：$\\text{mol}/\\text{m}^3$），其中 $P$ 的单位是 $\\text{Pa}$，普适气体常数 $R$ 的单位是 $\\text{J}/(\\text{mol}\\cdot\\text{K})$。分浓度为 $C_i = y_i C_{\\text{tot}}$，其中 $y_i = F_i/F_{\\text{tot}}$。\n- 基元可逆反应的速率定律为 $r = k_f(T) C_A - k_r(T) C_B$，其动力学遵循阿伦尼乌斯（Arrhenius）关系式 $k_f(T) = k_{0,f} \\exp\\!\\left(-E_f/(R T)\\right)$，其中 $k_{0,f}$ 是指前因子（单位：$\\text{s}^{-1}$），$E_f$ 是正向活化能（单位：$\\text{J}/\\text{mol}$）。热力学一致性要求 $k_r(T) = k_f(T)/K_{\\text{eq}}(T)$。\n- 平衡常数 $K_{\\text{eq}}(T)$ 的范特霍夫（van't Hoff）关系式为 $d\\ln K_{\\text{eq}}/dT = \\Delta H_{\\text{rxn}}/(R T^2)$，当在参考温度 $T_{\\text{ref}}$ 下的 $K_{\\text{eq}}(T_{\\text{ref}}) = K_{\\text{ref}}$ 已知时，积分可得 $\\ln K_{\\text{eq}}(T) = \\ln K_{\\text{ref}} + \\Delta H_{\\text{rxn}}/R \\left(1/T_{\\text{ref}} - 1/T\\right)$。\n- 在理想气体近似下，反应商为 $Q = y_B/y_A$。\n\n定义一个“近平衡停滞”位置 $z^\\star$，其为满足无量纲接近度量 $\\left|\\ln\\!\\left(Q/K_{\\text{eq}}(T)\\right)\\right| \\le \\tau$ 的最小轴向位置，其中 $\\tau > 0$ 是一个预设的容差。如果在反应器长度范围内没有出现这样的位置，则报告 $z^\\star = -1.0$。\n\n您的任务是：\n1. 基于这些原理推导出关于 $F_A(z)$、$F_B(z)$ 和 $T(z)$ 的耦合微分方程，并阐明与温度相关的平衡如何通过 $k_r(T) = k_f(T)/K_{\\text{eq}}(T)$ 影响逆反应速率。\n2. 实现一个鲁棒的数值求解器，该求解器沿 $z$ 方向从入口到指定的最大长度对耦合系统进行积分，并检测第一个满足 $\\left|\\ln\\!\\left(Q/K_{\\text{eq}}(T)\\right)\\right| \\le \\tau$ 的轴向位置 $z^\\star$。使用一种在 $y_A$ 或 $y_B$ 非常小的情况下数值适定的事件检测策略。\n3. 对于下面的每个测试用例，计算 $z^\\star$（单位：米），四舍五入到六位小数。如果在反应器长度内未检测到停滞，则返回 $-1.000000$。\n\n使用普适气体常数 $R = 8.31446261815324\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$。\n\n测试套件：\n- 案例1（吸热反应，含惰性物质，温度下降显著）：\n  - $A_c = 0.01\\,\\text{m}^2$\n  - $P = 2.0\\times 10^5\\,\\text{Pa}$\n  - $T_{\\text{in}} = 800.0\\,\\text{K}$\n  - $F_{A,0} = 1.0\\,\\text{mol}/\\text{s}$，$F_{B,0} = 0.0\\,\\text{mol}/\\text{s}$，$F_{I,0} = 2.0\\,\\text{mol}/\\text{s}$\n  - $C_{p,A} = 35.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$，$C_{p,B} = 35.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$，$C_{p,I} = 30.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$\n  - $\\Delta H_{\\text{rxn}} = 5.0\\times 10^4\\,\\text{J}/\\text{mol}$\n  - $k_{0,f} = 2.0\\times 10^5\\,\\text{s}^{-1}$，$E_f = 8.0\\times 10^4\\,\\text{J}/\\text{mol}$\n  - $K_{\\text{ref}} = 3.0$ 于 $T_{\\text{ref}} = 800.0\\,\\text{K}$\n  - $\\tau = 0.02$\n  - $z_{\\max} = 5.0\\,\\text{m}$\n- 案例2（吸热反应，但温度依赖性较弱，无惰性物质）：\n  - $A_c = 0.02\\,\\text{m}^2$\n  - $P = 1.5\\times 10^5\\,\\text{Pa}$\n  - $T_{\\text{in}} = 700.0\\,\\text{K}$\n  - $F_{A,0} = 2.0\\,\\text{mol}/\\text{s}$，$F_{B,0} = 0.5\\,\\text{mol}/\\text{s}$，$F_{I,0} = 0.0\\,\\text{mol}/\\text{s}$\n  - $C_{p,A} = 33.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$，$C_{p,B} = 33.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$，$C_{p,I} = 0.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$\n  - $\\Delta H_{\\text{rxn}} = 8.0\\times 10^3\\,\\text{J}/\\text{mol}$\n  - $k_{0,f} = 1.0\\times 10^5\\,\\text{s}^{-1}$，$E_f = 7.0\\times 10^4\\,\\text{J}/\\text{mol}$\n  - $K_{\\text{ref}} = 2.0$ 于 $T_{\\text{ref}} = 700.0\\,\\text{K}$\n  - $\\tau = 0.02$\n  - $z_{\\max} = 10.0\\,\\text{m}$\n- 案例3（与案例1相同，但停滞容差更严格）：\n  - $A_c = 0.01\\,\\text{m}^2$\n  - $P = 2.0\\times 10^5\\,\\text{Pa}$\n  - $T_{\\text{in}} = 800.0\\,\\text{K}$\n  - $F_{A,0} = 1.0\\,\\text{mol}/\\text{s}$，$F_{B,0} = 0.0\\,\\text{mol}/\\text{s}$，$F_{I,0} = 2.0\\,\\text{mol}/\\text{s}$\n  - $C_{p,A} = 35.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$，$C_{p,B} = 35.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$，$C_{p,I} = 30.0\\,\\text{J}/(\\text{mol}\\cdot\\text{K})$\n  - $\\Delta H_{\\text{rxn}} = 5.0\\times 10^4\\,\\text{J}/\\text{mol}$\n  - $k_{0,f} = 2.0\\times 10^5\\,\\text{s}^{-1}$，$E_f = 8.0\\times 10^4\\,\\text{J}/\\text{mol}$\n  - $K_{\\text{ref}} = 3.0$ 于 $T_{\\text{ref}} = 800.0\\,\\text{K}$\n  - $\\tau = 1.0\\times 10^{-4}$\n  - $z_{\\max} = 5.0\\,\\text{m}$\n\n您的程序应生成单行输出，其中包含三个计算出的停滞位置（单位：米），以逗号分隔并用方括号括起来（例如，\"[z1,z2,z3]\"），每个数字四舍五入到六位小数，并以米为单位表示。输出格式必须与此完全一致。",
            "solution": "用户要求推导并实现一个用于稳态、绝热平推流反应器 (PFR) 的数值模型，以确定“近平衡停滞”位置 $z^\\star$。\n\n### 步骤1：问题验证\n\n已根据指定标准对问题陈述进行了严格评估。\n\n-   **已知条件提取**：所有数据、变量和控制方程均已从问题描述中逐字提取。这些包括摩尔衡算、能量衡算、理想气体定律、速率定律、阿伦尼乌斯动力学、范特霍夫关系以及停滞条件的定义。三个不同测试用例的所有参数均已提供。\n-   **验证**：\n    1.  **科学依据**：该问题基于化学反应工程的基本且普遍接受的原理。PFR模型方程、动力学表达式（阿伦尼乌斯）和热力学关系（范特霍夫）都是标准的且陈述正确。该问题在科学上是合理的。\n    2.  **适定性**：该问题描述了一个具有明确初始条件的耦合一阶常微分方程（ODE）系统。这构成了一个标准的初值问题（IVP）。定义ODE的函数是连续的，确保了唯一解的存在。“停滞”条件被定义为ODE求解器的一个精确事件，使得整个问题是适定的。\n    3.  **客观性**：该问题使用精确、无歧义的数学和科学语言进行表述。它不含主观陈述。\n    4.  **完整性与一致性**：该问题是自洽的。为每个测试用例提供了所有必要的参数、常数和初始条件。所提供的信息中没有矛盾之处。\n    5.  **数值考量**：问题正确预见了当某个物种浓度为零时（例如在入口处），事件函数 $\\left|\\ln(Q/K_{\\text{eq}})\\right|$ 可能出现的数值问题。它特别要求一个“数值适定的”策略。这是反应器建模中的一个标准挑战，处理好它是鲁棒解决方案的一部分。\n\n-   **结论**：该问题是**有效的**。它是一个构思良好、非平凡的计算化学工程问题，需要应用既定原理和数值方法。\n\n### 步骤2：控制方程的推导\n\n系统沿轴向坐标 $z$ 的状态可以由摩尔流量 $F_i(z)$ 和温度 $T(z)$ 描述。对于反应 $A \\rightleftharpoons B$，化学计量系数为 $\\nu_A = -1$ 和 $\\nu_B = +1$。惰性物质 $I$ 的 $\\nu_I = 0$。\n\n1.  **摩尔衡算与化学计量**：\n    物质 $i$ 的摩尔衡算为 $dF_i/dz = \\nu_i r A_c$。\n    -   对于物质A：$dF_A/dz = (-1) r A_c$\n    -   对于物质B：$dF_B/dz = (+1) r A_c$\n    -   对于物质I：$dF_I/dz = (0) r A_c = 0$，这意味着 $F_I(z) = F_{I,0}$（常数）。\n\n    将A和B的衡算式相加得到 $d(F_A + F_B)/dz = 0$。积分可得 $F_A(z) + F_B(z) = F_{A,0} + F_{B,0}$，为一个常数。这允许我们用 $F_A$ 来代数表示 $F_B$：\n    $$F_B(z) = F_{A,0} + F_{B,0} - F_A(z)$$\n    总摩尔流量也是恒定的：$F_{\\text{tot}} = F_A(z) + F_B(z) + F_I(z) = F_{A,0} + F_{B,0} + F_{I,0}$。\n\n    因此，我们只需要求解一个关于摩尔流量的ODE，例如对 $F_A$：\n    $$ \\frac{dF_A}{dz} = -r A_c $$\n\n2.  **反应速率 ($r$) 表达式**：\n    速率定律为 $r = k_f(T) C_A - k_r(T) C_B$。根据热力学一致性，$k_r(T) = k_f(T)/K_{\\text{eq}}(T)$，速率变为：\n    $$ r = k_f(T) \\left( C_A - \\frac{C_B}{K_{\\text{eq}}(T)} \\right) $$\n    根据理想气体定律，物质 $j$ 的浓度为 $C_j = y_j C_{\\text{tot}} = \\frac{F_j}{F_{\\text{tot}}} \\frac{P}{RT}$。将其代入速率表达式：\n    $$ r = k_f(T) \\frac{P}{RT F_{\\text{tot}}} \\left( F_A - \\frac{F_B}{K_{\\text{eq}}(T)} \\right) $$\n    其中：\n    -   正向速率常数 $k_f(T)$ 由阿伦尼乌斯方程给出：$k_f(T) = k_{0,f} \\exp\\left(-\\frac{E_f}{RT}\\right)$。\n    -   平衡常数 $K_{\\text{eq}}(T)$ 由积分形式的范特霍夫方程给出：$K_{\\text{eq}}(T) = \\exp\\left( \\ln K_{\\text{ref}} + \\frac{\\Delta H_{\\text{rxn}}}{R} \\left(\\frac{1}{T_{\\text{ref}}} - \\frac{1}{T}\\right) \\right)$。\n\n3.  **能量衡算**：\n    绝热PFR的能量衡算式为：\n    $$ \\frac{dT}{dz} = -\\frac{\\Delta H_{\\text{rxn}}\\, r\\, A_c}{\\sum_j F_j C_{p,j}} $$\n    分母是总热容流率：$\\sum_j F_j C_{p,j} = F_A C_{p,A} + F_B C_{p,B} + F_I C_{p,I}$。该项依赖于状态变量 $F_A$（因为 $F_B$ 依赖于 $F_A$）。\n\n4.  **最终ODE系统**：\n    我们得到了一个关于状态向量 $\\mathbf{y}(z) = [F_A(z), T(z)]^T$ 的耦合一阶ODE系统：\n    $$ \\frac{dF_A}{dz} = -r A_c $$\n    $$ \\frac{dT}{dz} = -\\frac{\\Delta H_{\\text{rxn}}\\, r\\, A_c}{F_A C_{p,A} + (F_{A,0} + F_{B,0} - F_A) C_{p,B} + F_{I,0} C_{p,I}} $$\n    其中 $r$ 是如上文所定义的 $F_A$ 和 $T$ 的函数。初始条件为 $F_A(0) = F_{A,0}$ 和 $T(0) = T_{\\text{in}}$。\n\n### 步骤3：数值实现策略\n\n1.  **ODE求解器**：将使用 `scipy.integrate.solve_ivp` 对ODE系统进行数值积分来解决该问题。此函数非常适合此任务，因为它很鲁棒并提供了事件检测机制。\n\n2.  **状态向量**：求解器使用的状态向量将是 `y = [F_A, T]`。\n\n3.  **停滞条件的事件检测**：停滞位置 $z^\\star$ 由条件 $|\\ln(Q/K_{\\text{eq}})| \\le \\tau$ 定义，其中 $Q = y_B/y_A = F_B/F_A$。这等同于找到事件函数的一个最小正根 $z > 0$：\n    $$ g(z, \\mathbf{y}) = \\left|\\ln\\left(\\frac{F_B(z)}{F_A(z)} / K_{\\text{eq}}(T(z))\\right)\\right| - \\tau = 0 $$\n    -   **数值稳定性**：在反应器入口（$z=0$），如果 $F_{B,0}=0$，则 $Q=0$ 且 $\\ln(Q)$ 未定义。事件函数的实现必须能妥善处理这种情况。一个简单的保护措施是检查 $F_B$ 是否有效为零，如果是，则返回一个大的正值，以防止函数在开始时被触发。\n    -   **事件方向**：随着反应从远离平衡的初始状态进行，项 $|\\ln(Q/K_{\\text{eq}})|$ 的值从一个大值减小。当该值从上方穿过 $\\tau$ 时，事件发生。因此，求解器应寻找一个负方向（`direction = -1`）的零点穿越。\n    -   **终止事件**：一旦满足停滞条件，积分应停止。这通过将事件函数的 `terminal` 属性设置为 `True` 来实现。\n\n4.  **算法**：\n    -   对每个测试用例，收集所有参数。\n    -   定义一个ODE函数 `dydz(z, y, params)` 来计算导数 $[dF_A/dz, dT/dz]$。\n    -   定义一个事件函数 `event_stall(z, y, params)` 来计算 $g(z, \\mathbf{y})$。\n    -   使用初始条件 `y0 = [F_A0, T_in]`、积分区间 `[0, z_max]`、ODE和事件函数以及适当的数值容差来调用 `solve_ivp`。\n    -   如果求解器成功找到一个事件，则将第一个事件时间 `sol.t_events[0][0]` 作为 $z^\\star$。\n    -   如果在 $[0, z_{\\max}]$ 内未找到事件，则将 $z^\\star$ 赋值为 $-1.0$。\n    -   结果四舍五入到六位小数并存储。\n\n最终的Python实现将封装此逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the near-equilibrium stall position in a PFR for given test cases.\n    \"\"\"\n    R_GAS = 8.31446261815324\n\n    test_cases = [\n        # Case 1 (endothermic with inert, strong temperature drop):\n        {\n            \"Ac\": 0.01, \"P\": 2.0e5, \"T_in\": 800.0,\n            \"F_A0\": 1.0, \"F_B0\": 0.0, \"F_I0\": 2.0,\n            \"CpA\": 35.0, \"CpB\": 35.0, \"CpI\": 30.0,\n            \"dH_rxn\": 5.0e4, \"k0f\": 2.0e5, \"Ef\": 8.0e4,\n            \"K_ref\": 3.0, \"T_ref\": 800.0,\n            \"tau\": 0.02, \"z_max\": 5.0\n        },\n        # Case 2 (endothermic but mild temperature dependence, no inert):\n        {\n            \"Ac\": 0.02, \"P\": 1.5e5, \"T_in\": 700.0,\n            \"F_A0\": 2.0, \"F_B0\": 0.5, \"F_I0\": 0.0,\n            \"CpA\": 33.0, \"CpB\": 33.0, \"CpI\": 0.0,\n            \"dH_rxn\": 8.0e3, \"k0f\": 1.0e5, \"Ef\": 7.0e4,\n            \"K_ref\": 2.0, \"T_ref\": 700.0,\n            \"tau\": 0.02, \"z_max\": 10.0\n        },\n        # Case 3 (same as Case 1 but stringent stall tolerance):\n        {\n            \"Ac\": 0.01, \"P\": 2.0e5, \"T_in\": 800.0,\n            \"F_A0\": 1.0, \"F_B0\": 0.0, \"F_I0\": 2.0,\n            \"CpA\": 35.0, \"CpB\": 35.0, \"CpI\": 30.0,\n            \"dH_rxn\": 5.0e4, \"k0f\": 2.0e5, \"Ef\": 8.0e4,\n            \"K_ref\": 3.0, \"T_ref\": 800.0,\n            \"tau\": 1.0e-4, \"z_max\": 5.0\n        }\n    ]\n\n    def dydz(z, y, p):\n        \"\"\"\n        Defines the system of ordinary differential equations for the PFR model.\n        y = [F_A, T]\n        \"\"\"\n        F_A, T = y\n\n        # State variable protection\n        if T = 0: return [0.0, 0.0]\n        F_A = max(0.0, F_A)\n        \n        # Algebraic relations\n        F_B = p[\"F_A0\"] + p[\"F_B0\"] - F_A\n        F_B = max(0.0, F_B)\n        F_tot = p[\"F_A0\"] + p[\"F_B0\"] + p[\"F_I0\"]\n\n        # Temperature-dependent parameters\n        k_f = p[\"k0f\"] * np.exp(-p[\"Ef\"] / (R_GAS * T))\n        \n        log_K_ref = np.log(p[\"K_ref\"])\n        ln_K_eq = log_K_ref + (p[\"dH_rxn\"] / R_GAS) * (1.0 / p[\"T_ref\"] - 1.0 / T)\n        K_eq = np.exp(ln_K_eq)\n\n        # Rate of reaction\n        r = k_f * (p[\"P\"] / (R_GAS * T * F_tot)) * (F_A - F_B / K_eq)\n\n        # Derivatives\n        dFA_dz = -r * p[\"Ac\"]\n        \n        sum_FCp = F_A * p[\"CpA\"] + F_B * p[\"CpB\"] + p[\"F_I0\"] * p[\"CpI\"]\n        if abs(sum_FCp)  1e-12:\n            dT_dz = 0.0\n        else:\n            dT_dz = -p[\"dH_rxn\"] * r * p[\"Ac\"] / sum_FCp\n        \n        return [dFA_dz, dT_dz]\n\n    def event_stall(z, y, p):\n        \"\"\"\n        Event function to detect near-equilibrium stall.\n        Triggers when |ln(Q/K_eq)| - tau = 0.\n        \"\"\"\n        F_A, T = y\n        \n        # Guard against undefined logs at z=0 or due to numerical error\n        if F_A = 1e-20 or T = 0: return 1.0\n        \n        F_B = p[\"F_A0\"] + p[\"F_B0\"] - F_A\n        if F_B = 1e-20: return 1.0\n        \n        # Reaction quotient\n        Q = F_B / F_A\n        \n        # Equilibrium constant\n        log_K_ref = np.log(p[\"K_ref\"])\n        ln_K_eq = log_K_ref + (p[\"dH_rxn\"] / R_GAS) * (1.0 / p[\"T_ref\"] - 1.0 / T)\n        K_eq = np.exp(ln_K_eq)\n\n        # Event function value\n        value = np.abs(np.log(Q / K_eq)) - p[\"tau\"]\n        return value\n\n    event_stall.terminal = True\n    event_stall.direction = -1\n\n    results = []\n    for params in test_cases:\n        y0 = [params[\"F_A0\"], params[\"T_in\"]]\n        z_span = [0, params[\"z_max\"]]\n        \n        # Use tighter tolerances for higher accuracy, especially for Case 3\n        rtol = 1e-9\n        atol = 1e-12\n\n        sol = solve_ivp(\n            dydz, \n            z_span, \n            y0, \n            args=(params,),\n            method='RK45', \n            events=event_stall, \n            dense_output=True,\n            rtol=rtol,\n            atol=atol\n        )\n\n        if sol.status == 1 and len(sol.t_events[0]) > 0:\n            z_star = sol.t_events[0][0]\n        else:\n            z_star = -1.0\n            \n        results.append(f\"{z_star:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "复杂燃烧过程模拟的效率取决于对刚性常微分方程组的数值求解。这个高级实践聚焦于这些求解器计算核心：雅可比矩阵。你将为一个通用的化学反应机理推导其解析雅可比矩阵，通过利用其固有的稀疏性来实现高效的构建算法，并理解为何这对于隐式积分方法至关重要 。",
            "id": "4051573",
            "problem": "考虑一个一维稳态平推流反应器 (PFR)，其轴向坐标为 $z$，主体速度为 $u$（单位：米/秒）。$N$ 个物种的摩尔浓度向量为 $C \\in \\mathbb{R}^N$，其组分 $C_i$ 的单位为摩尔/立方米。单位体积物种生成速率为 $\\dot{\\omega}_i(C,T)$，单位为摩尔/(立方米·秒)，由一个包含 $M$ 个基元反应的机理在质量作用定律下确定。假设温度 $T$（单位：开尔文）下为等温条件。PFR 的物种守恒方程为\n$$\nu \\frac{d C_i}{d z} = \\dot{\\omega}_i(C,T), \\quad i = 1,\\dots,N.\n$$\n对于每个基元反应 $r$，物种 $i$ 的反应物化学计量系数为 $\\nu^{\\mathrm{reac}}_{i,r} \\in \\{0,1,2,\\dots\\}$，生成物化学计量系数为 $\\nu^{\\mathrm{prod}}_{i,r} \\in \\{0,1,2,\\dots\\}$，定义净化学计量系数为 $\\nu^{\\mathrm{net}}_{i,r} = \\nu^{\\mathrm{prod}}_{i,r} - \\nu^{\\mathrm{reac}}_{i,r}$。正向和逆向阿伦尼乌斯速率系数为\n$$\nk^{\\mathrm{f}}_r(T) = A^{\\mathrm{f}}_r T^{n^{\\mathrm{f}}_r} \\exp\\left(-\\frac{E^{\\mathrm{f}}_r}{R_{\\mathrm{u}} T}\\right), \\quad\nk^{\\mathrm{b}}_r(T) = A^{\\mathrm{b}}_r T^{n^{\\mathrm{b}}_r} \\exp\\left(-\\frac{E^{\\mathrm{b}}_r}{R_{\\mathrm{u}} T}\\right),\n$$\n其中 $A^{\\mathrm{f}}_r, A^{\\mathrm{b}}_r$ 是指前因子，$n^{\\mathrm{f}}_r, n^{\\mathrm{b}}_r$ 是温度指数，$E^{\\mathrm{f}}_r, E^{\\mathrm{b}}_r$ 是活化能（单位：焦耳/摩尔），$R_{\\mathrm{u}}$ 是普适气体常数（单位：焦耳/(摩尔·开尔文)）。基元反应的正向和逆向反应速率为\n$$\nR^{\\mathrm{f}}_r(C,T) = k^{\\mathrm{f}}_r(T) \\prod_{i=1}^N C_i^{\\nu^{\\mathrm{reac}}_{i,r}}, \\quad\nR^{\\mathrm{b}}_r(C,T) = k^{\\mathrm{b}}_r(T) \\prod_{i=1}^N C_i^{\\nu^{\\mathrm{prod}}_{i,r}},\n$$\n净速率为 $R_r(C,T) = R^{\\mathrm{f}}_r(C,T) - R^{\\mathrm{b}}_r(C,T)$（对于不可逆反应，设置 $A^{\\mathrm{b}}_r = 0, n^{\\mathrm{b}}_r = 0, E^{\\mathrm{b}}_r = 0$）。物种生成速率满足\n$$\n\\dot{\\omega}_i(C,T) = \\sum_{r=1}^M \\nu^{\\mathrm{net}}_{i,r} \\, R_r(C,T).\n$$\n\n任务：\n1. 从这些定义出发，推导雅可比矩阵的元素\n$$\nJ_{i j}(C,T) = \\frac{\\partial \\dot{\\omega}_i}{\\partial C_j}(C,T),\n$$\n并用 $\\nu^{\\mathrm{reac}}_{i,r}$、$\\nu^{\\mathrm{prod}}_{i,r}$、$\\nu^{\\mathrm{net}}_{i,r}$、$k^{\\mathrm{f}}_r(T)$、$k^{\\mathrm{b}}_r(T)$ 和 $C$ 表示。推导过程必须仅使用上面给出的质量作用形式和阿伦尼乌斯速率系数以及微积分基本法则。解释 $J$ 的哪些元素精确为零及其原因，并讨论稀疏模式与反应图的关系。\n\n2. 设计一个算法，通过仅组装由反应机理定义所隐含的非零元素来利用稀疏性构建 $J(C,T)$，并概述如何在基于牛顿法的隐式时间步进法（用于刚性常微分方程（ODEs））或 PFR 中的空间推进法中利用这种稀疏性（例如，使用稀疏直接法或迭代法求解形如 $(I - \\Delta t \\, J) \\delta = r$ 的线性系统）。\n\n3. 将该算法实现为一个完整、可运行的程序（参见最终答案要求），该程序：\n   - 为每个测试用例以压缩稀疏行 (CSR) 格式构建解析稀疏雅可比矩阵 $J$。\n   - 通过与使用有限差分法数值近似的稠密雅可比矩阵进行比较来验证它，报告元素间的最大绝对差值。\n   - 报告稀疏度分数，定义为非零元素的数量除以 $N^2$。\n   - 使用普适气体常数 $R_{\\mathrm{u}} = 8.314462618$ 焦耳/(摩尔·开尔文)。\n   - 使用国际单位制 (SI 单位)：浓度 $C_i$ 单位为摩尔/立方米，速率系数单位一致（例如，/秒，立方米/(摩尔·秒)，米的六次方/(摩尔的平方·秒)），温度 $T$ 单位为开尔文，生成速率 $\\dot{\\omega}_i$ 单位为摩尔/(立方米·秒)。\n\n测试套件：\n在您的程序中提供以下四个机理测试用例作为输入。对于每个案例，机理由 $N$、反应定义、$T$ 和初始浓度向量 $C$ 指定。\n\n- 案例 1 (理想情况：不可逆双分子反应):\n  - $N = 3$ 个物种，索引为 $0,1,2$，分别代表 $A,B,C$。\n  - 反应 $M = 1$：$A + B \\to C$，其中 $\\nu^{\\mathrm{reac}}_{\\cdot,1} = [1,1,0]$, $\\nu^{\\mathrm{prod}}_{\\cdot,1} = [0,0,1]$。\n  - 正向阿伦尼乌斯参数：$A^{\\mathrm{f}}_1 = 1.0$, $n^{\\mathrm{f}}_1 = 0$, $E^{\\mathrm{f}}_1 = 0$；逆向参数如前述设为零。\n  - 温度 $T = 1000$。\n  - 浓度 $C = [2.0, 1.0, 0.0]$。\n\n- 案例 2 (可逆单分子平衡动力学):\n  - $N = 2$ 个物种 $C,D$，索引为 $0,1$。\n  - 反应 $M = 1$：$C \\rightleftharpoons D$，其中 $\\nu^{\\mathrm{reac}}_{\\cdot,1} = [1,0]$, $\\nu^{\\mathrm{prod}}_{\\cdot,1} = [0,1]$。\n  - 正向阿伦尼乌斯参数：$A^{\\mathrm{f}}_1 = 0.5$, $n^{\\mathrm{f}}_1 = 0$, $E^{\\mathrm{f}}_1 = 0$；逆向阿伦尼乌斯参数：$A^{\\mathrm{b}}_1 = 0.1$, $n^{\\mathrm{b}}_1 = 0$, $E^{\\mathrm{b}}_1 = 0$。\n  - 温度 $T = 1000$。\n  - 浓度 $C = [1.5, 0.5]$。\n\n- 案例 3 (边缘情况：惰性物种和更高化学计量):\n  - $N = 4$ 个物种 $A,B,C,D$，索引为 $0,1,2,3$。\n  - 反应 $M = 1$：$2A + B \\to C$，其中 $\\nu^{\\mathrm{reac}}_{\\cdot,1} = [2,1,0,0]$, $\\nu^{\\mathrm{prod}}_{\\cdot,1} = [0,0,1,0]$。\n  - 正向阿伦尼乌斯参数：$A^{\\mathrm{f}}_1 = 0.2$, $n^{\\mathrm{f}}_1 = 0$, $E^{\\mathrm{f}}_1 = 0$；逆向参数设为零。\n  - 温度 $T = 900$。\n  - 浓度 $C = [1.0, 0.5, 0.0, 10.0]$。\n\n- 案例 4 (含有自由基物种和多个反应的稀疏链式反应):\n  - $N = 5$ 个物种 $A,R,B,C,D$，索引为 $0,1,2,3,4$。\n  - 反应 $M = 3$：\n    - $r1$: $A + R \\to 2R$，其中 $\\nu^{\\mathrm{reac}}_{\\cdot,1} = [1,1,0,0,0]$, $\\nu^{\\mathrm{prod}}_{\\cdot,1} = [0,2,0,0,0]$，正向阿伦尼乌斯参数 $A^{\\mathrm{f}}_1 = 1.0 \\times 10^{-3}$, $n^{\\mathrm{f}}_1 = 0$, $E^{\\mathrm{f}}_1 = 20000$，逆向参数设为零。\n    - $r2$: $R + B \\to C$，其中 $\\nu^{\\mathrm{reac}}_{\\cdot,2} = [0,1,1,0,0]$, $\\nu^{\\mathrm{prod}}_{\\cdot,2} = [0,0,0,1,0]$，正向阿伦尼乌斯参数 $A^{\\mathrm{f}}_2 = 1.0 \\times 10^{-2}$, $n^{\\mathrm{f}}_2 = 0$, $E^{\\mathrm{f}}_2 = 0$，逆向参数设为零。\n    - $r3$: $C \\to D$，其中 $\\nu^{\\mathrm{reac}}_{\\cdot,3} = [0,0,0,1,0]$, $\\nu^{\\mathrm{prod}}_{\\cdot,3} = [0,0,0,0,1]$，正向阿伦尼乌斯参数 $A^{\\mathrm{f}}_3 = 100.0$, $n^{\\mathrm{f}}_3 = 0$, $E^{\\mathrm{f}}_3 = 0$，逆向参数设为零。\n  - 温度 $T = 1200$。\n  - 浓度 $C = [2.0, 1.0 \\times 10^{-6}, 1.0, 0.0, 0.0]$。\n\n答案规格：\n- 对每个测试用例，计算：\n  - 解析雅可比矩阵元素与有限差分雅可比矩阵近似值之间的最大绝对差，以浮点数表示 (无量纲)。\n  - 稀疏度分数 $\\,\\mathrm{nnz}/N^2\\,$，以浮点数表示 (无量纲)，其中 $\\,\\mathrm{nnz}\\,$ 是 CSR 矩阵中存储的非零元素数量。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果为一个子列表，按顺序排列，每个子列表包含按所述顺序排列的两个浮点数。例如：\"[[v_1,w_1],[v_2,w_2],[v_3,w_3],[v_4,w_4]]\"。",
            "solution": "该问题要求推导、设计算法并实现计算化学反应流（由平推流反应器（PFR）建模）中物种生成速率的雅可比矩阵。对问题陈述的验证确认了其在科学上是合理的、适定的和完整的。因此，我们可以着手解决该问题。\n\n### 第一部分：雅可比矩阵的推导\n\n物种生成速率向量 $\\dot{\\omega}(C,T)$ 关于物种浓度向量 $C$ 的雅可比矩阵由其元素定义：\n$$\nJ_{i j}(C,T) = \\frac{\\partial \\dot{\\omega}_i}{\\partial C_j}(C,T)\n$$\n其中 $i$ 是被求导的物种生成速率的索引（行索引），$j$ 是浓度变量的索引（列索引）。\n\n物种 $i$ 的生成速率由对所有 $M$ 个反应的求和给出：\n$$\n\\dot{\\omega}_i(C,T) = \\sum_{r=1}^M \\nu^{\\mathrm{net}}_{i,r} \\, R_r(C,T)\n$$\n其中 $\\nu^{\\mathrm{net}}_{i,r}$ 是物种 $i$ 在反应 $r$ 中的净化学计量系数，$R_r$ 是反应 $r$ 的净反应进程速率。\n\n根据微分算子的线性性质，我们可以将雅可比矩阵元素写为：\n$$\nJ_{i j} = \\frac{\\partial}{\\partial C_j} \\left( \\sum_{r=1}^M \\nu^{\\mathrm{net}}_{i,r} R_r \\right) = \\sum_{r=1}^M \\nu^{\\mathrm{net}}_{i,r} \\frac{\\partial R_r}{\\partial C_j}\n$$\n净反应进程速率 $R_r$ 是正向速率和逆向速率之差，$R_r = R^{\\mathrm{f}}_r - R^{\\mathrm{b}}_r$。因此，我们有：\n$$\nJ_{i j} = \\sum_{r=1}^M \\nu^{\\mathrm{net}}_{i,r} \\left( \\frac{\\partial R^{\\mathrm{f}}_r}{\\partial C_j} - \\frac{\\partial R^{\\mathrm{b}}_r}{\\partial C_j} \\right)\n$$\n现在我们必须求出正向和逆向反应速率的偏导数，这些速率由质量作用定律定义。基元反应 $r$ 的正向速率为：\n$$\nR^{\\mathrm{f}}_r(C,T) = k^{\\mathrm{f}}_r(T) \\prod_{k=1}^N C_k^{\\nu^{\\mathrm{reac}}_{k,r}}\n$$\n为了计算关于 $C_j$ 的偏导数，我们应用乘法法则。仅当乘积中对应于 $k=j$ 的项，其导数才非零：\n$$\n\\frac{\\partial R^{\\mathrm{f}}_r}{\\partial C_j} = k^{\\mathrm{f}}_r(T) \\left( \\prod_{k \\neq j} C_k^{\\nu^{\\mathrm{reac}}_{k,r}} \\right) \\frac{\\partial}{\\partial C_j} \\left( C_j^{\\nu^{\\mathrm{reac}}_{j,r}} \\right)\n$$\n应用幂函数求导法则 $\\frac{d}{dx} x^n = nx^{n-1}$，我们得到：\n$$\n\\frac{\\partial}{\\partial C_j} \\left( C_j^{\\nu^{\\mathrm{reac}}_{j,r}} \\right) = \\nu^{\\mathrm{reac}}_{j,r} \\, C_j^{\\nu^{\\mathrm{reac}}_{j,r}-1}\n$$\n如果 $\\nu^{\\mathrm{reac}}_{j,r}=0$，该导数为零。如果 $\\nu^{\\mathrm{reac}}_{j,r} \\geq 1$，我们可以将速率的导数表示为：\n$$\n\\frac{\\partial R^{\\mathrm{f}}_r}{\\partial C_j} = k^{\\mathrm{f}}_r(T) \\, \\nu^{\\mathrm{reac}}_{j,r} \\, C_j^{\\nu^{\\mathrm{reac}}_{j,r}-1} \\prod_{k \\neq j} C_k^{\\nu^{\\mathrm{reac}}_{k,r}}\n$$\n如果 $C_j=0$，此形式会遇到计算问题。一个更方便的形式，在 $C_j  0$ 时有效，是通过注意到 $R^{\\mathrm{f}}_r = \\left( k^{\\mathrm{f}}_r \\prod_{k \\neq j} C_k^{\\nu^{\\mathrm{reac}}_{k,r}} \\right) C_j^{\\nu^{\\mathrm{reac}}_{j,r}}$ 得到的。这给出了：\n$$\n\\frac{\\partial R^{\\mathrm{f}}_r}{\\partial C_j} = \\nu^{\\mathrm{reac}}_{j,r} \\frac{R^{\\mathrm{f}}_r}{C_j} \\quad (\\text{对于 } C_j  0 \\text{ 且 } \\nu^{\\mathrm{reac}}_{j,r} \\ge 1)\n$$\n如果 $C_j=0$，导数必须仔细评估。如果 $\\nu^{\\mathrm{reac}}_{j,r}  1$，导数为 $0$。如果 $\\nu^{\\mathrm{reac}}_{j,r} = 1$，导数为 $k^{\\mathrm{f}}_r \\prod_{k \\neq j} C_k^{\\nu^{\\mathrm{reac}}_{k,r}}$。如果 $\\nu^{\\mathrm{reac}}_{j,r} = 0$，导数为 $0$。\n\n对于逆向反应速率 $R^{\\mathrm{b}}_r(C,T) = k^{\\mathrm{b}}_r(T) \\prod_{k=1}^N C_k^{\\nu^{\\mathrm{prod}}_{k,r}}$，可以进行类似的推导：\n$$\n\\frac{\\partial R^{\\mathrm{b}}_r}{\\partial C_j} = \\nu^{\\mathrm{prod}}_{j,r} \\frac{R^{\\mathrm{b}}_r}{C_j} \\quad (\\text{对于 } C_j  0 \\text{ 且 } \\nu^{\\mathrm{prod}}_{j,r} \\ge 1)\n$$\n对于 $C_j=0$ 的情况也需要特别注意。\n\n结合这些结果，雅可比矩阵元素的最终表达式为：\n$$\nJ_{i j} = \\sum_{r=1}^M \\nu^{\\mathrm{net}}_{i,r} \\left( \\nu^{\\mathrm{reac}}_{j,r} \\frac{R^{\\mathrm{f}}_r}{C_j} - \\nu^{\\mathrm{prod}}_{j,r} \\frac{R^{\\mathrm{b}}_r}{C_j} \\right)\n$$\n对于 $C_j  0$，这个公式在计算上是高效的，因为反应进程速率 $R^{\\mathrm{f}}_r$ 和 $R^{\\mathrm{b}}_r$ 通常在计算中都会被求出。对于 $C_j = 0$ 的情况，必须如上所述通过直接计算导数来处理。\n\n**雅可比矩阵的稀疏性**\n\n仅当物种 $j$ 浓度的变化影响物种 $i$ 的生成速率时，元素 $J_{ij} = \\partial \\dot{\\omega}_i / \\partial C_j$ 才为非零。从推导的公式中可以看出，要使反应 $r$ 对 $J_{ij}$ 的贡献非零，必须同时满足两个条件：\n1.  物种 $i$ 必须参与反应 $r$ (即其净生成量非零，$\\nu^{\\mathrm{net}}_{i,r} \\neq 0$)。\n2.  反应 $r$ 的速率必须依赖于物种 $j$ 的浓度。对于遵循质量作用定律的基元反应，这意味着物种 $j$ 必须是反应 $r$ 的反应物或生成物 (即 $\\nu^{\\mathrm{reac}}_{j,r}  0$ 或 $\\nu^{\\mathrm{prod}}_{j,r}  0$)。\n\n因此，如果对于机理中的每个反应 $r$，物种 $i$ 不参与该反应，或者物种 $j$ 不是该反应的反应物或生成物，则 $J_{ij}$ 将精确为零。\n\n雅可比矩阵的稀疏模式因此由反应网络的连通性决定。在以物种为节点的反应图中，如果物种 $j$ 和物种 $i$ 都参与一个共同的反应，则可以从 $j$ 到 $i$ 画一个相互作用链接。该相互作用图的邻接矩阵对应于 $J$ 的稀疏模式。对于大型化学机理，其中每个反应通常只涉及数百或数千个物种中的少数几个，所得到的雅可比矩阵非常稀疏，即其大多数元素为零。\n\n### 第二部分：算法设计与应用\n\n**构建稀疏雅可比矩阵的算法**\n\n可以利用雅可比矩阵的结构来高效地构建它。一个以反应为中心的算法是理想的：\n\n1.  **预计算：**给定温度 $T$ 和浓度 $C$，计算所有正向和逆向速率系数 ($k^{\\mathrm{f}}_r, k^{\\mathrm{b}}_r$) 以及所有正向和逆向反应进程速率 ($R^{\\mathrm{f}}_r, R^{\\mathrm{b}}_r$)。\n2.  **稀疏性与数值组装：**初始化一个数据结构，用于以坐标 (COO) 格式存储稀疏矩阵元素，即数值、行索引和列索引的列表。\n3.  **遍历反应：**对每个反应 $r = 1, \\dots, M$：\n    a. 识别受此反应影响的物种集合 $\\{i\\}$ (其中 $\\nu^{\\mathrm{net}}_{i,r} \\neq 0$)。\n    b. 识别其浓度影响此反应速率的物种集合 $\\{j\\}$ (其中 $\\nu^{\\mathrm{reac}}_{j,r}  0$ 或 $\\nu^{\\mathrm{prod}}_{j,r}  0$)。\n    c. 对这些集合中的每一对 $(i, j)$：\n        i. 计算反应 $r$ 的反应进程速率关于 $C_j$ 的偏导数：$\\frac{\\partial R_r}{\\partial C_j} = \\frac{\\partial R^{\\mathrm{f}}_r}{\\partial C_j} - \\frac{\\partial R^{\\mathrm{b}}_r}{\\partial C_j}$。使用检查 $C_j=0$ 的稳健方法。\n        ii. 计算对雅可比矩阵的贡献：$\\Delta J_{ij} = \\nu^{\\mathrm{net}}_{i,r} \\frac{\\partial R_r}{\\partial C_j}$。\n        iii. 将此值及其索引 $(i, j)$ 添加到 COO 列表中。\n4.  **完成矩阵构建：**遍历所有反应后，从收集的列表中构建一个稀疏矩阵 (例如 `scipy.sparse.coo_matrix`)。COO 格式可以直接处理对同一 $(i,j)$ 元素的多个贡献，这些贡献可以相加得到最终值。将矩阵转换为压缩稀疏行 (CSR) 格式，以便进行高效的后续代数运算。\n\n**在数值求解器中利用稀疏性**\n\nPFR 的控制方程 $u \\frac{dC}{dz} = \\dot{\\omega}(C,T)$ 构成了一个常微分方程 (ODEs) 系统。化学动力学系统是出了名的刚性，意味着它们包含差异巨大的时间尺度。这使得必须使用隐式数值积分方法来保证稳定性。\n\n从 $z_n$ 推进到 $z_{n+1} = z_n + \\Delta z$ 的一个隐式后向欧拉步为：\n$$\nC_{n+1} = C_n + \\frac{\\Delta z}{u} \\dot{\\omega}(C_{n+1}, T)\n$$\n这是一个关于 $C_{n+1}$ 的非线性代数系统。它可以用 Newton 法求解。令 $G(C) = C - C_n - \\frac{\\Delta z}{u} \\dot{\\omega}(C,T) = 0$。Newton 迭代为：\n$$\n[G'(C^k)] (C^{k+1} - C^k) = -G(C^k)\n$$\n其中 $G'(C)$ 是函数 $G$ 的雅可比矩阵。该雅可比矩阵为：\n$$\nG'(C) = I - \\frac{\\Delta z}{u} \\frac{\\partial \\dot{\\omega}}{\\partial C} = I - \\frac{\\Delta z}{u} J\n$$\n在每个 Newton 步中，我们必须求解一个形如 $(I - \\gamma J) \\delta = r$ 的线性系统，其中 $\\gamma = \\Delta z/u$ 与步长有关。由于 $J$ 非常稀疏，矩阵 $(I - \\gamma J)$ 也是稀疏的，并且具有相同的模式（外加对角线上的单位矩阵）。\n\n使用稠密线性代数存储和分解该矩阵将产生 $O(N^2)$ 的内存成本和 $O(N^3)$ 的计算成本，这对于大的 $N$ 来说是无法承受的。通过使用稀疏矩阵格式（如 CSR）和专门的求解器，这些成本被大大降低：\n- **稀疏直接求解器：**像 UMFPACK 或 SuperLU 这样的库对稀疏矩阵执行 LU 分解。成本取决于非零元素的数量 ($\\mathrm{nnz}$) 和分解过程中的“填充”，但通常远优于 $O(N^3)$。\n- **迭代求解器：**像 GMRES 或 BiCGSTAB 这样的方法通过重复应用矩阵-向量乘积来求解系统。对于稀疏矩阵，矩阵-向量乘积的成本为 $O(\\mathrm{nnz})$，远低于稠密矩阵的 $O(N^2)$ 成本。当与一个好的预条件子（例如，不完全 LU 分解）结合使用时，这些方法非常有效，这也利用了稀疏性。\n\n总而言之，构建解析稀疏雅可比矩阵的能力对于计算燃烧学中使用的现代刚性 ODE 求解器的效率至关重要。\n\n### 第三部分：实现\n\n提供的 Python 代码实现了针对四个给定测试用例的稀疏雅可比矩阵计算和验证。\n- `compute_omega`：计算物种生成速率向量 $\\dot{\\omega}$。\n- `compute_analytical_jacobian`：实现以反应为中心的算法，以 CSR 格式构建稀疏雅可比矩阵。它仔细处理了浓度为零的情况。\n- `compute_numerical_jacobian`：使用中心有限差分格式（对于接近零的浓度，则回退到前向差分）计算稠密雅可比矩阵以进行验证。\n- 主函数 `solve` 遍历测试用例，调用这些函数，比较结果以计算最大绝对误差，计算稀疏度分数，并按规定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing and validating sparse Jacobians for four test cases.\n    \"\"\"\n    R_u = 8.314462618  # Universal gas constant in J/(mol·K)\n\n    # Define test cases as specified in the problem statement\n    test_cases = [\n        {\n            \"name\": \"Case 1: Irreversible bimolecular\",\n            \"N\": 3,\n            \"T\": 1000.0,\n            \"C\": np.array([2.0, 1.0, 0.0]),\n            \"reactions\": [\n                {\n                    \"nu_reac\": np.array([1, 1, 0]),\n                    \"nu_prod\": np.array([0, 0, 1]),\n                    \"A_f\": 1.0, \"n_f\": 0.0, \"E_f\": 0.0,\n                    \"A_b\": 0.0, \"n_b\": 0.0, \"E_b\": 0.0,\n                }\n            ],\n        },\n        {\n            \"name\": \"Case 2: Reversible unimolecular equilibrium\",\n            \"N\": 2,\n            \"T\": 1000.0,\n            \"C\": np.array([1.5, 0.5]),\n            \"reactions\": [\n                {\n                    \"nu_reac\": np.array([1, 0]),\n                    \"nu_prod\": np.array([0, 1]),\n                    \"A_f\": 0.5, \"n_f\": 0.0, \"E_f\": 0.0,\n                    \"A_b\": 0.1, \"n_b\": 0.0, \"E_b\": 0.0,\n                }\n            ],\n        },\n        {\n            \"name\": \"Case 3: Inert species and higher stoichiometry\",\n            \"N\": 4,\n            \"T\": 900.0,\n            \"C\": np.array([1.0, 0.5, 0.0, 10.0]),\n            \"reactions\": [\n                {\n                    \"nu_reac\": np.array([2, 1, 0, 0]),\n                    \"nu_prod\": np.array([0, 0, 1, 0]),\n                    \"A_f\": 0.2, \"n_f\": 0.0, \"E_f\": 0.0,\n                    \"A_b\": 0.0, \"n_b\": 0.0, \"E_b\": 0.0,\n                }\n            ],\n        },\n        {\n            \"name\": \"Case 4: Sparse chain reaction\",\n            \"N\": 5,\n            \"T\": 1200.0,\n            \"C\": np.array([2.0, 1.0e-6, 1.0, 0.0, 0.0]),\n            \"reactions\": [\n                {\n                    \"nu_reac\": np.array([1, 1, 0, 0, 0]),\n                    \"nu_prod\": np.array([0, 2, 0, 0, 0]),\n                    \"A_f\": 1.0e-3, \"n_f\": 0.0, \"E_f\": 20000.0,\n                    \"A_b\": 0.0, \"n_b\": 0.0, \"E_b\": 0.0,\n                },\n                {\n                    \"nu_reac\": np.array([0, 1, 1, 0, 0]),\n                    \"nu_prod\": np.array([0, 0, 0, 1, 0]),\n                    \"A_f\": 1.0e-2, \"n_f\": 0.0, \"E_f\": 0.0,\n                    \"A_b\": 0.0, \"n_b\": 0.0, \"E_b\": 0.0,\n                },\n                {\n                    \"nu_reac\": np.array([0, 0, 0, 1, 0]),\n                    \"nu_prod\": np.array([0, 0, 0, 0, 1]),\n                    \"A_f\": 100.0, \"n_f\": 0.0, \"E_f\": 0.0,\n                    \"A_b\": 0.0, \"n_b\": 0.0, \"E_b\": 0.0,\n                },\n            ],\n        },\n    ]\n\n    def compute_omega(T, C, reactions, N, R_u):\n        omega_dot = np.zeros(N)\n        for r_def in reactions:\n            k_f = r_def[\"A_f\"] * T**r_def[\"n_f\"] * np.exp(-r_def[\"E_f\"] / (R_u * T))\n            k_b = r_def[\"A_b\"] * T**r_def[\"n_b\"] * np.exp(-r_def[\"E_b\"] / (R_u * T))\n            \n            R_f, R_b = k_f, k_b\n            for i in range(N):\n                if r_def[\"nu_reac\"][i] > 0:\n                    R_f *= C[i]**r_def[\"nu_reac\"][i]\n                if r_def[\"nu_prod\"][i] > 0:\n                    R_b *= C[i]**r_def[\"nu_prod\"][i]\n            \n            nu_net = r_def[\"nu_prod\"] - r_def[\"nu_reac\"]\n            R_net = R_f - R_b\n            omega_dot += nu_net * R_net\n        return omega_dot\n\n    def compute_analytical_jacobian(T, C, reactions, N, R_u):\n        data, row, col = [], [], []\n        \n        for r_def in reactions:\n            k_f = r_def[\"A_f\"] * T**r_def[\"n_f\"] * np.exp(-r_def[\"E_f\"] / (R_u * T))\n            k_b = r_def[\"A_b\"] * T**r_def[\"n_b\"] * np.exp(-r_def[\"E_b\"] / (R_u * T))\n            \n            R_f, R_b = k_f, k_b\n            for i in range(N):\n                if r_def[\"nu_reac\"][i] > 0: R_f *= C[i]**r_def[\"nu_reac\"][i]\n                if r_def[\"nu_prod\"][i] > 0: R_b *= C[i]**r_def[\"nu_prod\"][i]\n\n            nu_net = r_def[\"nu_prod\"] - r_def[\"nu_reac\"]\n            \n            affected_species = np.where(nu_net != 0)[0]\n            participant_species = np.where(r_def[\"nu_reac\"] + r_def[\"nu_prod\"] > 0)[0]\n\n            for i in affected_species:\n                for j in participant_species:\n                    # Forward rate derivative\n                    dRf_dCj = 0.0\n                    nu_reac_j = r_def[\"nu_reac\"][j]\n                    if nu_reac_j > 0:\n                        if C[j] > 1e-40: # Numerically stable path for C > 0\n                            dRf_dCj = nu_reac_j * R_f / C[j]\n                        else: # C == 0 case\n                            if nu_reac_j == 1:\n                                term = k_f\n                                for k in range(N):\n                                    if k != j and r_def[\"nu_reac\"][k] > 0:\n                                        term *= C[k] ** r_def[\"nu_reac\"][k]\n                                dRf_dCj = term\n                            # else (nu_reac_j > 1), derivative is 0\n                    \n                    # Backward rate derivative\n                    dRb_dCj = 0.0\n                    nu_prod_j = r_def[\"nu_prod\"][j]\n                    if nu_prod_j > 0:\n                        if C[j] > 1e-40: # Numerically stable path for C > 0\n                            dRb_dCj = nu_prod_j * R_b / C[j]\n                        else: # C == 0 case\n                            if nu_prod_j == 1:\n                                term = k_b\n                                for k in range(N):\n                                    if k != j and r_def[\"nu_prod\"][k] > 0:\n                                        term *= C[k] ** r_def[\"nu_prod\"][k]\n                                dRb_dCj = term\n                            # else (nu_prod_j > 1), derivative is 0\n\n                    J_ij_contrib = nu_net[i] * (dRf_dCj - dRb_dCj)\n                    if J_ij_contrib != 0.0:\n                        data.append(J_ij_contrib)\n                        row.append(i)\n                        col.append(j)\n\n        if not data:\n            return coo_matrix((N, N)).tocsr()\n            \n        coo = coo_matrix((data, (row, col)), shape=(N, N))\n        coo.sum_duplicates()\n        return coo.tocsr()\n\n    def compute_numerical_jacobian(T, C, reactions, N, R_u):\n        h = 1e-8\n        J_num = np.zeros((N, N))\n        \n        for j in range(N):\n            C_plus = C.copy()\n            C_minus = C.copy()\n            \n            C_plus[j] += h\n            C_minus[j] -= h\n            \n            omega_plus = compute_omega(T, C_plus, reactions, N, R_u)\n            \n            # Use forward difference if central difference would use negative conc\n            if C[j]  h:\n                omega_base = compute_omega(T, C, reactions, N, R_u)\n                J_num[:, j] = (omega_plus - omega_base) / h\n            else:\n                omega_minus = compute_omega(T, C_minus, reactions, N, R_u)\n                J_num[:, j] = (omega_plus - omega_minus) / (2.0 * h)\n                \n        return J_num\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        T = case[\"T\"]\n        C = case[\"C\"]\n        reactions = case[\"reactions\"]\n        \n        J_analytic = compute_analytical_jacobian(T, C, reactions, N, R_u)\n        J_numerical = compute_numerical_jacobian(T, C, reactions, N, R_u)\n        \n        diff = np.max(np.abs(J_analytic.toarray() - J_numerical))\n        \n        sparsity_frac = J_analytic.nnz / (N * N)\n        \n        results.append([diff, sparsity_frac])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{res[0]},{res[1]}]\" for res in results]) + \"]\"\n    print(output_str)\n\nsolve()\n\n```"
        }
    ]
}