{
    "hands_on_practices": [
        {
            "introduction": "在投入编写复杂的求解器代码之前，我们可以借助动力系统理论来预测求解的可行性。这个练习  引导我们运用一个简洁的“维数计算”论证，来确定求解火焰结构需要多少个自由参数（例如火焰速度）。这个看似抽象的理论分析，为我们后续将要学习的连续化方法提供了根本性的数学依据，揭示了为何火焰速度通常是问题的一个“本征值”而非预设参数。",
            "id": "4062376",
            "problem": "考虑一个一维、稳态、平面的自由传播预混火焰，该火焰处于一个相对于实验室坐标系以未知速度 $s$ 移动的坐标系中。控制方程为在移动坐标系中写出的稳态组分和能量守恒定律，包含分子扩散和单步反应。经过无量纲化并引入梯度的一阶变量后，该稳态边值问题可简化为以下形式的自治一阶常微分方程（ODE）组\n$$\n\\frac{d\\mathbf{u}}{dx}=\\mathbf{f}(\\mathbf{u};s), \\quad \\mathbf{u}\\in\\mathbb{R}^{n},\n$$\n其中 $n=4$ 源于两个二阶标量平衡方程（组分和能量）。远场边界条件是当 $x\\to -\\infty$ 时的未燃态 $\\mathbf{u}^{-}$ 和当 $x\\to +\\infty$ 时的已燃态 $\\mathbf{u}^{+}$。假设对于固定的 $s$，$\\mathbf{u}^{-}$ 和 $\\mathbf{u}^{+}$ 是该 ODE 的双曲平衡点，并且围绕这些平衡点的线性化具有以下谱\n$$\n\\sigma\\big(D_{\\mathbf{u}}\\mathbf{f}(\\mathbf{u}^{-};s)\\big)=\\{\\,0.38,\\;1.27,\\;-0.19,\\;-2.41\\,\\},\n$$\n$$\n\\sigma\\big(D_{\\mathbf{u}}\\mathbf{f}(\\mathbf{u}^{+};s)\\big)=\\{\\,-0.81,\\;-0.22,\\;0.36,\\;0.59\\,\\}.\n$$\n在动力系统的意义上，将 $x$ 视为自变量。你的目标是采用打靶法计算火焰，该方法从非燃平衡点的不稳定流形出发，射向已燃平衡点的稳定流形。在延拓框架中，你可以改变一组 $p$ 个标量延拓参数（包括但不限于波速 $s$）。由于问题在 $x$ 方向上具有平移不变性，因此你施加一个标量相位条件来在打靶过程中固定空间位移。\n\n从守恒律结构和动力系统中稳定与不稳定流形的定义出发，推导确定标量延拓参数最小数量 $p$ 的维数计数条件，使得在利用一个标量相位条件消除平移不变性的同时，能够通过打靶法找到从 $\\mathbf{u}^{-}$ 到 $\\mathbf{u}^{+}$ 的横截异宿连接。然后，利用所提供的谱，计算此 $n=4$ 火焰模型的最小 $p$ 值。请给出你的最终答案，为一个不带单位的整数。",
            "solution": "该问题要求推导一个维数计数条件，以确定使用打靶法计算一维稳态火焰结构所需的最小延拓参数数量 $p$。该结构对应于 $n$ 维状态空间中连接未燃平衡态 $\\mathbf{u}^{-}$ 和已燃平衡态 $\\mathbf{u}^{+}$ 的异宿轨道。\n\n设控制该系统的自治常微分方程（ODE）组为\n$$\n\\frac{d\\mathbf{u}}{dx} = \\mathbf{f}(\\mathbf{u}; \\mathbf{q}),\n$$\n其中 $\\mathbf{u} \\in \\mathbb{R}^n$ 是状态向量，$\\mathbf{q} \\in \\mathbb{R}^p$ 是一个包含 $p$ 个标量延拓参数的向量。代表火焰剖面的解是一条连接两个平衡点的轨迹：$\\lim_{x\\to-\\infty} \\mathbf{u}(x) = \\mathbf{u}^{-}$ 和 $\\lim_{x\\to+\\infty} \\mathbf{u}(x) = \\mathbf{u}^{+}$。在动力系统的语言中，这条轨迹是一个异宿轨道。\n\n这样的轨道必须位于起始平衡点的不稳定流形 $W^u(\\mathbf{u}^{-})$ 和终点平衡点的稳定流形 $W^s(\\mathbf{u}^{+})$ 的交集中。这些不变流形的维数由系统在平衡点处线性化的谱决定。设 $J^{-} = D_{\\mathbf{u}}\\mathbf{f}(\\mathbf{u}^{-}; \\mathbf{q})$ 和 $J^{+} = D_{\\mathbf{u}}\\mathbf{f}(\\mathbf{u}^{+}; \\mathbf{q})$ 分别是未燃态和已燃态的雅可比矩阵。一个平衡点的不稳定流形的维数是其雅可比矩阵特征值中实部为正的个数。稳定流形的维数是特征值中实部为负的个数。问题中指出平衡点是双曲的，这意味着没有特征值的实部为零。\n\n设 $d_u^{-} = \\dim(W^u(\\mathbf{u}^{-}))$ 为 $J^{-}$ 的特征值中满足 $\\Re(\\lambda) > 0$ 的个数。\n设 $d_s^{+} = \\dim(W^s(\\mathbf{u}^{+}))$ 为 $J^{+}$ 的特征值中满足 $\\Re(\\lambda)  0$ 的个数。\n\n异宿轨道作为自治 ODE 的解，不是一个单点，而是一条一维曲线，这是由于系统在自变量 $x$ 上的平移不变性。如果 $\\mathbf{u}(x)$ 是一个解，那么对于任意常数位移 $c$，$\\mathbf{u}(x+c)$ 也是一个解。因此，一个能被稳健找到的异宿连接应对应于 $W^u(\\mathbf{u}^{-})$ 和 $W^s(\\mathbf{u}^{+})$ 的一维交集。\n\n根据横截性理论，在环境空间 $A$ 中，两个流形 $M_1$ 和 $M_2$ 的交集的维数由 $\\dim(M_1 \\cap M_2) = \\dim(M_1) + \\dim(M_2) - \\dim(A)$ 给出，前提是交集是横截的。对于我们的问题，流形是 $W^u(\\mathbf{u}^{-})$ 和 $W^s(\\mathbf{u}^{+})$，环境空间是状态空间 $\\mathbb{R}^n$。对于一组固定的参数 $\\mathbf{q}$，存在一维横截交集的条件是：\n$$\n1 = d_u^{-} + d_s^{+} - n.\n$$\n整理后得到，在不需要可调参数的情况下，存在结构稳定的异宿轨道的条件为：\n$$\nd_u^{-} + d_s^{+} = n+1.\n$$\n如果此等式不成立，通常流形不会以所需的一维方式相交。此期望交集的余维，代表了未被满足的约束数量，由 $C = (n+1) - (d_u^{-} + d_s^{+})$ 给出。为了满足这些约束并强制流形以适当的方式相交，我们必须引入与该余维数量相等的自由参数。因此，所需的最小延拓参数数量 $p$ 为：\n$$\np = n+1 - (d_u^{-} + d_s^{+}).\n$$\n这里假设 $p \\ge 0$。如果维数之和已经足够大，则不需要参数，所以更正式地 $p = \\max(0, n+1 - (d_u^{-} + d_s^{+}))$.\n\n同样的结果也可以从数值打靶法的角度推导出来。在打靶法中，我们的目标是求解一个代数方程组，其中变量的数量等于方程的数量。\n变量包括：\n1.  用于在 $d_u^{-}$ 维不稳定流形 $W^u(\\mathbf{u}^{-})$ 上指定初始条件的参数。这提供了 $d_u^{-}$ 个变量。\n2.  $p$ 个延拓参数 $\\mathbf{q}$。\n总变量数 = $d_u^{-} + p$。\n\n方程包括：\n1.  使计算出的轨迹落到 $d_s^{+}$ 维稳定流形 $W^s(\\mathbf{u}^{+})$ 上所需的条件。在 $\\mathbb{R}^n$ 中，这个流形可以用 $n - d_s^{+}$ 个方程来定义。\n2.  一个标量相位条件，用于消除平移自由度，并从一参数族的位移解中选择一个唯一的解。这提供了 $1$ 个方程。\n总方程数 = $(n - d_s^{+}) + 1$。\n\n为了得到一个适定的求根问题，令变量数量与方程数量相等：\n$$\nd_u^{-} + p = n - d_s^{+} + 1.\n$$\n解出 $p$，我们得到相同的维数计数条件：\n$$\np = n+1 - d_u^{-} - d_s^{+}.\n$$\n现在，我们将此条件应用于具体问题。给定的参数是：\n状态空间的维数是 $n=4$。\n\n在未燃态 $\\mathbf{u}^{-}$ 处的雅可比矩阵谱为 $\\sigma\\big(D_{\\mathbf{u}}\\mathbf{f}(\\mathbf{u}^{-};s)\\big)=\\{\\,0.38,\\;1.27,\\;-0.19,\\;-2.41\\,\\}$。\n实部为正的特征值是 $0.38$ 和 $1.27$。因此，在 $\\mathbf{u}^{-}$ 处的不稳定流形的维数是 $d_u^{-} = 2$。\n\n在已燃态 $\\mathbf{u}^{+}$ 处的雅可比矩阵谱为 $\\sigma\\big(D_{\\mathbf{u}}\\mathbf{f}(\\mathbf{u}^{+};s)\\big)=\\{\\,-0.81,\\;-0.22,\\;0.36,\\;0.59\\,\\}$。\n实部为负的特征值是 $-0.81$ 和 $-0.22$。因此，在 $\\mathbf{u}^{+}$ 处的稳定流形的维数是 $d_s^{+} = 2$。\n\n我们拥有所有必要的值：\n$n = 4$\n$d_u^{-} = 2$\n$d_s^{+} = 2$\n\n将这些值代入推导出的最小延拓参数数量 $p$ 的公式中：\n$$\np = n+1 - (d_u^{-} + d_s^{+})\n$$\n$$\np = 4+1 - (2 + 2)\n$$\n$$\np = 5 - 4\n$$\n$$\np = 1\n$$\n所需的最小延拓参数数量为 $1$。这与自由传播火焰的物理性质相符，其中火焰速度 $s$ 通常是问题的一个未知特征值，必须与解的剖面一同确定，因此充当了唯一需要的延拓参数。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "当我们知道需要通过改变某个参数来寻找解时，下一个自然的问题就是：在这个参数变化的过程中，系统会在何处发生质变？本练习  提供了一个基于简化模型的编码实践，旨在精确地“探测”这些导致系统行为发生根本性改变的“分岔点”。你将通过实现一个打靶法程序，亲身体验如何利用雅可比行列式的消失来预示新火焰解的诞生，这是参数连续化追踪策略中的关键一步。",
            "id": "4062369",
            "problem": "考虑一个典型的一维稳态反应-扩散模型，用于热扩散机制下的预混火焰，该模型建立在无量纲空间区间 $x \\in [0,1]$ 上。在近起始状态下，经过适当的无量纲化后，能量和物质守恒方程的振幅简化，得到一个标量场 $u(x)$ 的范式边值问题，该问题捕捉了点火-熄火平衡：\n$$\n\\frac{d^2 u}{dx^2} + \\mu\\,u - u^3 = 0,\\quad x \\in (0,1),\n$$\n附带狄利克雷（Dirichlet）边界条件\n$$\nu(0) = 0,\\quad u(1) = 0.\n$$\n此处，$u(x)$ 是一个无量纲温度或反应进程变量振幅，$\\mu$ 是一个无量纲控制参数，概括了反应和扩散输运之间的竞争。这个简化方程是临界点附近燃烧理论中一个经过充分检验的模型，并且在数学上与小振幅展开下的一维稳态反应-扩散系统一致。\n\n标准的打靶策略将边值问题重新表述为一个具有未知初始斜率的初值问题。引入 $v(x) = du/dx$，该系统可以写成\n$$\n\\frac{du}{dx} = v,\\qquad \\frac{dv}{dx} = -\\mu\\,u + u^3,\n$$\n初始条件为 $u(0) = 0$ 和 $v(0) = s$，其中 $s$ 是一个未知的标量，选择它以满足终端边界条件 $u(1) = 0$。定义打靶残差\n$$\nR(s;\\mu) = u(1; s, \\mu),\n$$\n即使用初始斜率 $s$ 和参数 $\\mu$ 从 $x=0$ 到 $x=1$ 积分初值问题得到的在 $x = 1$ 处的 $u$ 值。\n\n平凡分支 $u(x)\\equiv 0$ 对所有 $\\mu$ 都满足边界条件，并对应于 $s=0$。产生非平凡分支的分岔可以通过打靶映射在 $s=0$ 处的可逆性丧失来检测，这等价于打靶雅可比矩阵为零\n$$\n\\frac{\\partial R}{\\partial s}(0;\\mu) = \\lim_{s\\to 0} \\frac{R(s;\\mu)}{s}.\n$$\n通过在 $u=0$ 处将系统线性化（这会抑制三次项），导数 $\\partial R/\\partial s$ 可简化为线性常微分方程 $\\tfrac{d^2 u}{dx^2} + \\mu u = 0$ 在初始条件 $u(0)=0, u'(0)=1$ 下解的边界求值。这得出了显式公式\n$$\n\\frac{\\partial R}{\\partial s}(0;\\mu) = \\frac{\\sin(\\sqrt{\\mu})}{\\sqrt{\\mu}}.\n$$\n分支点出现在参数值使得 $\\frac{\\partial R}{\\partial s}(0;\\mu) = 0$ 的地方，即\n$$\n\\mu_n = n^2 \\pi^2,\\quad n \\in \\mathbb{N}.\n$$\n\n您的任务是实现一个程序，使用基于打靶的分岔检测和区间套分岔参数延拓，执行以下计算：\n\n1. 对于给定的单个参数值 $\\,\\mu\\,$，计算并返回打靶雅可比矩阵的模的绝对值\n$$\nD(\\mu) = \\left|\\frac{\\partial R}{\\partial s}(0;\\mu)\\right| = \\left|\\frac{\\sin(\\sqrt{\\mu})}{\\sqrt{\\mu}}\\right|.\n$$\n\n2. 对于给定的参数区间 $[\\mu_a,\\mu_b]$ 且 $\\mu_a  \\mu_b$，使用区间套定界延拓策略在 $[\\mu_a,\\mu_b]$ 中定位一个分支点 $\\mu^\\star$，方法是找到标量函数 $\\tfrac{\\partial R}{\\partial s}(0;\\mu)$ 的一个根，即\n$$\n\\frac{\\partial R}{\\partial s}(0;\\mu^\\star) = 0,\n$$\n并将值 $\\mu^\\star$ 作为浮点数返回。\n\n您必须使用一个稳健的区间套求解器应用于函数 $\\tfrac{\\partial R}{\\partial s}(0;\\mu)$ 来实现根查找步骤，分岔的检测等同于检测该函数在区间内的符号变化，然后通过求精找到一个根。这体现了一种简单而有效的参数延拓策略。\n\n使用以下参数值测试套件：\n\n- 测试用例 1 (单个值): $\\mu = 8.0$。\n- 测试用例 2 (区间): $[\\mu_a,\\mu_b] = [9.0, 10.5]$。\n- 测试用例 3 (单个值): $\\mu = 12.0$。\n- 测试用例 4 (区间): $[\\mu_a,\\mu_b] = [38.0, 40.0]$。\n\n所有量都是无量纲的，因此没有物理单位。不使用角度，因此不需要角度单位。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例的顺序排列结果，其中输出为浮点数：\n$$\n[\\;D(8.0),\\ \\text{来自 } [9.0,10.5] \\text{ 的 } \\mu^\\star,\\ D(12.0),\\ \\text{来自 } [38.0,40.0] \\text{ 的 } \\mu^{\\star}\\;].\n$$\n不强制要求四舍五入规则；输出您的计算产生的原生浮点表示。",
            "solution": "问题陈述已经过验证，并被确定为是合理的。它在科学上基于应用于典型燃烧模型的分岔和动力系统理论，是适定的，提供了所有必要信息，并且没有矛盾或含糊之处。各项任务都以数学精度进行了规定。\n\n该问题要求实现与一维反应-扩散方程分岔分析相关的两个不同计算任务。该分析基于平凡解分支上的打靶雅可比，由以下函数给出：\n$$\n\\frac{\\partial R}{\\partial s}(0;\\mu) = \\frac{\\sin(\\sqrt{\\mu})}{\\sqrt{\\mu}}\n$$\n其中 $\\mu$ 是控制参数。\n\n第一个任务是为特定的 $\\mu$ 值计算该雅可比矩阵的绝对值，记为 $D(\\mu)$。公式为：\n$$\nD(\\mu) = \\left|\\frac{\\sin(\\sqrt{\\mu})}{\\sqrt{\\mu}}\\right|\n$$\n这是一个直接的函数求值。此计算将针对提供单个参数值的测试用例执行。\n- 对于测试用例 1，我们在 $\\mu = 8.0$ 处评估 $D(\\mu)$：\n$$\nD(8.0) = \\left|\\frac{\\sin(\\sqrt{8.0})}{\\sqrt{8.0}}\\right|\n$$\n- 对于测试用例 3，我们在 $\\mu = 12.0$ 处评估 $D(\\mu)$：\n$$\nD(12.0) = \\left|\\frac{\\sin(\\sqrt{12.0})}{\\sqrt{12.0}}\\right|\n$$\n\n第二个任务是使用区间套定界延拓策略在给定的参数区间 $[\\mu_a, \\mu_b]$ 内定位一个分支点 $\\mu^\\star$。当雅可比矩阵消失时，从平凡解发生分支，这允许存在从平凡解分岔出来的非平凡解。这对应于寻找雅可比函数的根：\n$$\n\\frac{\\partial R}{\\partial s}(0;\\mu^\\star) = \\frac{\\sin(\\sqrt{\\mu^\\star})}{\\sqrt{\\mu^\\star}} = 0\n$$\n对于 $\\mu > 0$，此函数的根由分子 $\\sin(\\sqrt{\\mu^\\star}) = 0$ 的零点确定。当 $\\sqrt{\\mu^\\star} = n\\pi$ 对于任何非零整数 $n \\in \\mathbb{N}$ 时，此条件得到满足，从而得到众所周知的在 $\\mu^\\star_n = n^2\\pi^2$ 处的分支点。\n\n问题指定使用稳健的区间套求解器。这意味着对函数 $f(\\mu) = \\frac{\\sin(\\sqrt{\\mu})}{\\sqrt{\\mu}}$ 在给定区间 $[\\mu_a, \\mu_b]$ 上应用数值求根算法，如 Brent 方法。此方法是合适的，因为如果区间端点的函数值 $f(\\mu_a)$ 和 $f(\\mu_b)$ 符号相反，它保证收敛到一个根。\n- 对于测试用例 2，区间为 $[\\mu_a, \\mu_b] = [9.0, 10.5]$。我们寻找第一个分支点 $\\mu^\\star_1 = (1\\cdot\\pi)^2 = \\pi^2 \\approx 9.8696$。我们验证该区间包含此根：\n  - 在 $\\mu_a = 9.0$ 处，函数参数为 $\\sqrt{9.0} = 3.0$。值为 $f(9.0) = \\sin(3.0)/3.0 > 0$。\n  - 在 $\\mu_b = 10.5$ 处，参数为 $\\sqrt{10.5} \\approx 3.24$。由于 $\\pi \\approx 3.14159$，该参数在区间 $(\\pi, 2\\pi)$ 内，其中正弦函数为负。因此，$f(10.5) = \\sin(\\sqrt{10.5})/\\sqrt{10.5}  0$。\n  由于 $f(\\mu_a) \\cdot f(\\mu_b)  0$，区间内存在一个根。数值求解器将找到 $\\mu^\\star \\approx 9.8696044$。\n\n- 对于测试用例 4，区间为 $[\\mu_a, \\mu_b] = [38.0, 40.0]$。我们寻找第二个分支点 $\\mu^\\star_2 = (2\\cdot\\pi)^2 = 4\\pi^2 \\approx 39.4784$。我们验证区间：\n  - 在 $\\mu_a = 38.0$ 处，参数为 $\\sqrt{38.0} \\approx 6.164$。由于 $2\\pi \\approx 6.283$，该参数在区间 $(\\pi, 2\\pi)$ 内，其中正弦函数为负。因此，$f(38.0)  0$。\n  - 在 $\\mu_b = 40.0$ 处，参数为 $\\sqrt{40.0} \\approx 6.325$，略大于 $2\\pi$。该参数在 $(2\\pi, 3\\pi)$ 内，其中正弦函数为正。因此，$f(40.0) > 0$。\n  由于 $f(\\mu_a) \\cdot f(\\mu_b)  0$，存在一个根，并将通过数值方法定位在 $\\mu^\\star \\approx 39.4784176$。\n\n实现将包括一个 Python 脚本，利用 `numpy` 库进行所需的数学函数计算，并使用 `scipy.optimize.brentq` 作为稳健的区间套求解器来完成求根任务。该脚本将按顺序处理每个测试用例，并按要求将结果格式化为单个逗号分隔的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating Jacobian magnitudes and finding bifurcation points\n    for the given test cases.\n    \"\"\"\n\n    # Define the shooting Jacobian function dR/ds(0, mu).\n    # This function is the one whose roots are the bifurcation points.\n    def shooting_jacobian(mu: float) - float:\n        \"\"\"\n        Calculates the shooting Jacobian at the trivial branch for a given parameter mu.\n        The formula is sin(sqrt(mu)) / sqrt(mu).\n        \"\"\"\n        # The problem scope implies mu  0. The test cases all satisfy this.\n        # For mu=0, the limit is 1. We handle mu = 0 as per the problem.\n        if mu = 0:\n            # This case is not hit by the provided test suite.\n            # Returning NaN or raising an error are valid options for mu  0.\n            # The limit as mu -> 0+ is 1.0.\n            return 1.0 if mu == 0.0 else np.nan\n        \n        sqrt_mu = np.sqrt(mu)\n        return np.sin(sqrt_mu) / sqrt_mu\n\n    # Define the tasks based on the problem description.\n    # Task 1: Compute D(mu) = |shooting_jacobian(mu)|\n    def calculate_D(mu: float) - float:\n        \"\"\"\n        Calculates the absolute magnitude of the shooting Jacobian.\n        \"\"\"\n        return np.abs(shooting_jacobian(mu))\n\n    # Task 2: Find the root mu* in a given interval [mu_a, mu_b].\n    # This is done by finding the root of the shooting_jacobian function.\n    # scipy.optimize.brentq is a robust bracketed root-finding algorithm.\n    def find_bifurcation_point(mu_a: float, mu_b: float) - float:\n        \"\"\"\n        Finds a root of the shooting_jacobian function within the interval [mu_a, mu_b].\n        \"\"\"\n        root = brentq(shooting_jacobian, mu_a, mu_b)\n        return root\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'type': 'single', 'value': 8.0},\n        {'type': 'interval', 'bounds': [9.0, 10.5]},\n        {'type': 'single', 'value': 12.0},\n        {'type': 'interval', 'bounds': [38.0, 40.0]},\n    ]\n    \n    results = []\n    \n    # Process each test case.\n    for case in test_cases:\n        if case['type'] == 'single':\n            # This is Task 1: compute D(mu).\n            mu = case['value']\n            result = calculate_D(mu)\n            results.append(result)\n        elif case['type'] == 'interval':\n            # This is Task 2: find mu*.\n            mu_a, mu_b = case['bounds']\n            result = find_bifurcation_point(mu_a, mu_b)\n            results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format is a comma-separated list of native float representations in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了理论基础和分岔点探测技术后，我们便可以迎接最终的挑战：完整地计算刚性火焰结构。这个综合性练习  将指导你实现并比较两种核心的非线性求解器——收敛快但鲁棒性差的牛顿法，以及更为稳健的伪瞬态连续化（PTC）方法。通过解决这个实际的火焰问题，你将深刻理解求解刚性燃烧问题时面临的实际困难，以及选择合适数值工具的至关重要性。",
            "id": "3966595",
            "problem": "考虑一个一维、稳态、无量纲的层流预混自由火焰反应-扩散模型，该模型具有单位 Lewis 数，定义在空间区间 $z \\in [0,1]$ 上。未知量是无量纲温度 $\\theta(z)$ 和无量纲燃料质量分数 $y(z)$。对于 $z \\in (0,1)$，控制方程为：\n$$\n0 = \\frac{d^2 \\theta}{dz^2} + \\mathrm{Da}\\, y\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta}\\right),\n$$\n$$\n0 = \\mathrm{Le}\\, \\frac{d^2 y}{dz^2} - \\mathrm{Da}\\, y\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta}\\right),\n$$\n边界条件为 Dirichlet 边界条件：\n$$\n\\theta(0)=0,\\quad \\theta(1)=\\Theta_{\\mathrm{ad}},\\quad y(0)=1,\\quad y(1)=0.\n$$\n这里，$\\mathrm{Da}$ 是 Damköhler 数（反应时间尺度与扩散时间尺度之比），$\\beta$ 是无量纲活化能参数，$\\gamma$ 是热释放耦合系数，$\\mathrm{Le}$ 是 Lewis 数（热扩散率与质量扩散率之比），$\\Theta_{\\mathrm{ad}}$ 是无量纲绝热温升。这些参数控制刚度：大的 $\\beta$ 和大的 $\\mathrm{Da}$ 会产生指数级尖锐的反应区。\n\n您的任务是使用二阶中心差分法在 $N$ 个等距网格点上离散化这些方程，其中 $N=50$。设网格由 $z_i = i\\,\\Delta z$ 定义，对于 $i=0,1,\\dots,N-1$，其中 $\\Delta z = 1/(N-1)$。将离散未知量表示为 $\\theta_i \\approx \\theta(z_i)$ 和 $y_i \\approx y(z_i)$。为包含 $2N$ 个未知量的向量 $\\mathbf{U} = [\\theta_0,\\theta_1,\\dots,\\theta_{N-1},y_0,y_1,\\dots,y_{N-1}]^\\top$ 构建非线性残差向量 $\\mathbf{F}(\\mathbf{U})=\\mathbf{0}$，具体如下：\n\n- 对于内部节点 $i=1,2,\\dots,N-2$，\n$$\nF_{\\theta,i} = \\frac{\\theta_{i-1} - 2\\theta_i + \\theta_{i+1}}{\\Delta z^2} + \\mathrm{Da}\\, y_i\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta_i}\\right),\n$$\n$$\nF_{y,i} = \\mathrm{Le}\\, \\frac{y_{i-1} - 2 y_i + y_{i+1}}{\\Delta z^2} - \\mathrm{Da}\\, y_i\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta_i}\\right).\n$$\n\n- 对于边界节点，\n$$\nF_{\\theta,0} = \\theta_0 - 0,\\quad F_{\\theta,N-1} = \\theta_{N-1} - \\Theta_{\\mathrm{ad}},\n$$\n$$\nF_{y,0} = y_0 - 1,\\quad F_{y,N-1} = y_{N-1} - 0.\n$$\n\n将残差范数定义为完整 $2N$ 维向量 $\\mathbf{F}(\\mathbf{U})$ 的欧几里得范数，即\n$$\n\\|\\mathbf{F}(\\mathbf{U})\\|_2 = \\left( \\sum_{j=1}^{2N} F_j^2 \\right)^{1/2}.\n$$\n\n您必须实现并比较两种非线性求解器：\n\n1. 直接 Newton 法（也称为 Newton–Raphson 法）：从一个初始猜测值开始，在每次迭代 $k$ 中，构建雅可比矩阵 $\\mathbf{J}(\\mathbf{U}^{(k)}) = \\partial \\mathbf{F}/\\partial \\mathbf{U}$ 并求解线性系统\n$$\n\\mathbf{J}(\\mathbf{U}^{(k)})\\, \\delta^{(k)} = -\\mathbf{F}(\\mathbf{U}^{(k)}),\n$$\n然后更新\n$$\n\\mathbf{U}^{(k+1)} = \\mathbf{U}^{(k)} + \\delta^{(k)}.\n$$\n当 $\\|\\mathbf{F}(\\mathbf{U}^{(k+1)})\\|_2 \\le 10^{-8}$ 或迭代次数达到最大值 50 时终止。\n\n2. 伪瞬态延拓法 (PTC)：引入伪时间，并使用带有自适应伪时间步长的后向欧拉线性化方法向稳态推进。在迭代 $k$ 中，对于当前伪时间步长 $\\Delta t^{(k)}$，求解\n$$\n\\left( \\frac{1}{\\Delta t^{(k)}} \\mathbf{I} + \\mathbf{J}(\\mathbf{U}^{(k)}) \\right)\\, \\delta^{(k)} = -\\mathbf{F}(\\mathbf{U}^{(k)}),\n$$\n并更新\n$$\n\\mathbf{U}^{(k+1)} = \\mathbf{U}^{(k)} + \\delta^{(k)}.\n$$\n使用以下伪时间步长控制：\n- 初始化 $\\Delta t^{(0)} = 10^{-4}$，下界和上界分别为 $10^{-6}$ 和 $10^{2}$。\n- 计算出 $\\mathbf{U}^{(k+1)}$ 后，令 $r^{(k)} = \\|\\mathbf{F}(\\mathbf{U}^{(k+1)})\\|_2 / \\|\\mathbf{F}(\\mathbf{U}^{(k)})\\|_2$。如果 $r^{(k)}  0.7$，通过 $\\Delta t^{(k+1)} = \\min( 2\\, \\Delta t^{(k)}, 10^{2} )$ 增加步长；否则，通过 $\\Delta t^{(k+1)} = \\max( 0.5\\, \\Delta t^{(k)}, 10^{-6} )$ 减小步长。\n当 $\\|\\mathbf{F}(\\mathbf{U}^{(k+1)})\\|_2 \\le 10^{-8}$ 或迭代次数达到最大值 200 时终止。\n\n在两种方法中，使用相同的初始猜测值：\n$$\n\\theta_i^{(0)} = \\Theta_{\\mathrm{ad}}\\, z_i,\\qquad y_i^{(0)} = 1 - z_i.\n$$\n\n为了提高效率，推导并实现解析雅可比矩阵的元素。对于每个内部节点 $i$，反应项 $R_i = \\mathrm{Da}\\, y_i\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta_i}\\right)$ 的偏导数为\n$$\n\\frac{\\partial R_i}{\\partial \\theta_i} = \\mathrm{Da}\\, y_i\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta_i}\\right)\\, \\frac{\\beta \\gamma}{(1+\\gamma \\theta_i)^2},\\qquad \\frac{\\partial R_i}{\\partial y_i} = \\mathrm{Da}\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta_i}\\right).\n$$\n\n测试套件：在以下参数集上运行您的程序，所有参数集均设置 $\\Theta_{\\mathrm{ad}}=1$ 和 $\\mathrm{Le}=1$：\n- 情况 A（中等刚度）：$\\mathrm{Da}=10$, $\\beta=5$, $\\gamma=4$。\n- 情况 B（刚性）：$\\mathrm{Da}=50$, $\\beta=12$, $\\gamma=4$。\n- 情况 C（非常刚性）：$\\mathrm{Da}=100$, $\\beta=20$, $\\gamma=4$。\n\n对于每种情况，分别报告直接 Newton 法和伪瞬态延拓法的四个量：最终残差范数和终止时的迭代次数。如果某种方法因线性求解错误而失败，或在最大迭代次数内未达到容差，则报告终止时达到的残差范数和所用的迭代次数。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按如下顺序排列\n$$\n[\\; r^{\\mathrm{N}}_{\\mathrm{A}},\\; i^{\\mathrm{N}}_{\\mathrm{A}},\\; r^{\\mathrm{P}}_{\\mathrm{A}},\\; i^{\\mathrm{P}}_{\\mathrm{A}},\\; r^{\\mathrm{N}}_{\\mathrm{B}},\\; i^{\\mathrm{N}}_{\\mathrm{B}},\\; r^{\\mathrm{P}}_{\\mathrm{B}},\\; i^{\\mathrm{P}}_{\\mathrm{B}},\\; r^{\\mathrm{N}}_{\\mathrm{C}},\\; i^{\\mathrm{N}}_{\\mathrm{C}},\\; r^{\\mathrm{P}}_{\\mathrm{C}},\\; i^{\\mathrm{P}}_{\\mathrm{C}} \\;],\n$$\n其中 $r$ 表示最终残差范数（浮点数），$i$ 表示迭代次数（整数）。由于公式是无量纲的，因此不涉及物理单位。不存在角度。不使用百分比。",
            "solution": "该问题要求对一个耦合的非线性边值问题系统进行数值求解，该系统模拟了一维层流预混火焰。连续的控制方程在均匀网格上使用二阶中心有限差分格式进行离散化，得到一个形式为 $\\mathbf{F}(\\mathbf{U}) = \\mathbf{0}$ 的大型非线性代数方程组。\n\n未知量向量 $\\mathbf{U}$ 是通过将所有网格点 $i=0, 1, \\dots, N-1$ 的离散温度值 $\\theta_i$ 和离散燃料质量分数值 $y_i$ 串联起来构建的。具体来说，$\\mathbf{U} = [\\theta_0, \\dots, \\theta_{N-1}, y_0, \\dots, y_{N-1}]^\\top$，得到一个大小为 $2N$ 的向量。残差向量 $\\mathbf{F}(\\mathbf{U})$ 的结构类似，其前 $N$ 个分量对应温度的离散方程，后 $N$ 个分量对应燃料质量分数的离散方程。对于内部网格点 $i=1, \\dots, N-2$，残差方程由离散化的控制方程给出。对于边界点 $i=0$ 和 $i=N-1$，残差表示对 Dirichlet 边界条件的强制执行。\n\n需要实现两种迭代数值方法来找到满足 $\\mathbf{F}(\\mathbf{U}) = \\mathbf{0}$ 的根 $\\mathbf{U}$。\n\n首先，直接 Newton 法 (Newton-Raphson) 是一种求根算法，它从一个初始猜测值 $\\mathbf{U}^{(0)}$ 开始，并迭代地精炼它。在每次迭代 $k$ 中，非线性函数 $\\mathbf{F}(\\mathbf{U})$ 通过其在当前迭代点 $\\mathbf{U}^{(k)}$ 附近的一阶泰勒展开来近似：\n$$ \\mathbf{F}(\\mathbf{U}) \\approx \\mathbf{F}(\\mathbf{U}^{(k)}) + \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{U}}\\bigg|_{\\mathbf{U}^{(k)}} (\\mathbf{U} - \\mathbf{U}^{(k)}) $$\n通过设置 $\\mathbf{F}(\\mathbf{U}) = \\mathbf{0}$ 来找到下一个迭代点 $\\mathbf{U}^{(k+1)}$，并将雅可比矩阵定义为 $\\mathbf{J}(\\mathbf{U}^{(k)}) = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{U}}\\big|_{\\mathbf{U}^{(k)}}$，我们得到一个用于更新步 $\\delta^{(k)} = \\mathbf{U}^{(k+1)} - \\mathbf{U}^{(k)}$ 的线性系统：\n$$ \\mathbf{J}(\\mathbf{U}^{(k)})\\, \\delta^{(k)} = -\\mathbf{F}(\\mathbf{U}^{(k)}) $$\n求解出 $\\delta^{(k)}$ 后，通过 $\\mathbf{U}^{(k+1)} = \\mathbf{U}^{(k)} + \\delta^{(k)}$ 更新解。当猜测值足够接近根时，该方法表现出二次收敛性，但如果初始猜测值不佳，则可能发散，特别是对于吸引盆较小的刚性系统。\n\n其次，伪瞬态延拓法 (PTC) 是一种全局化技术，旨在提高 Newton 法的鲁棒性。它将稳态问题 $\\mathbf{F}(\\mathbf{U})=\\mathbf{0}$ 重构为一个伪瞬态问题 $\\frac{d\\mathbf{U}}{dt} = -\\mathbf{F}(\\mathbf{U})$ 的长时间解。在伪时间上应用步长为 $\\Delta t$ 的隐式（后向）欧拉离散化，得到：\n$$ \\frac{\\mathbf{U}^{(k+1)} - \\mathbf{U}^{(k)}}{\\Delta t^{(k)}} = -\\mathbf{F}(\\mathbf{U}^{(k+1)}) $$\n将项 $\\mathbf{F}(\\mathbf{U}^{(k+1)})$ 在当前迭代点 $\\mathbf{U}^{(k)}$ 附近线性化为 $\\mathbf{F}(\\mathbf{U}^{(k+1)}) \\approx \\mathbf{F}(\\mathbf{U}^{(k)}) + \\mathbf{J}(\\mathbf{U}^{(k)})(\\mathbf{U}^{(k+1)} - \\mathbf{U}^{(k)})$，并重新整理，得到用于更新 $\\delta^{(k)}$ 的线性系统：\n$$ \\left( \\frac{1}{\\Delta t^{(k)}} \\mathbf{I} + \\mathbf{J}(\\mathbf{U}^{(k)}) \\right)\\, \\delta^{(k)} = -\\mathbf{F}(\\mathbf{U}^{(k)}) $$\n其中 $\\mathbf{I}$ 是单位矩阵。项 $\\frac{1}{\\Delta t^{(k)}}\\mathbf{I}$ 加到雅可比矩阵的对角线上，增强了对角占优性，从而改善了线性系统的条件数，特别是对于小的 $\\Delta t^{(k)}$。这使得该方法对不良的初始猜测值更加鲁棒。自适应时间步长策略允许该方法在收敛缓慢时采取小的、谨慎的步长（通过减小 $\\Delta t^{(k)}$），而在收敛快速时采取更大的、更激进的类 Newton 步长（通过增加 $\\Delta t^{(k)}$）。\n\n对于这两种方法，都必须构建解析的雅可比矩阵 $\\mathbf{J}$。雅可比矩阵具有一个 $2 \\times 2$ 的块结构，对应于 $\\theta$ 和 $y$ 的残差相对于 $\\theta$ 和 $y$ 变量的导数。其元素通过对残差方程 $F_{\\theta,i}$ 和 $F_{y,i}$ 关于变量 $\\theta_j$ 和 $y_j$ 求导得出。对于内部节点，这会产生一个来自有限差分模板的带状结构，以及来自非线性反应耦合的非对角项。反应项 $R_i = \\mathrm{Da}\\, y_i\\, \\exp(-\\frac{\\beta}{1+\\gamma \\theta_i})$ 的导数由下式给出：\n$$ \\frac{\\partial R_i}{\\partial \\theta_i} = R_i \\frac{\\beta \\gamma}{(1+\\gamma \\theta_i)^2}, \\qquad \\frac{\\partial R_i}{\\partial y_i} = \\frac{R_i}{y_i} = \\mathrm{Da}\\, \\exp\\!\\left(-\\frac{\\beta}{1+\\gamma \\theta_i}\\right) $$\n对于边界节点，残差方程是线性的，导致雅可比矩阵对角线上的元素为常数 1。\n\n整体实现流程如下：首先定义用于计算任何给定状态 $\\mathbf{U}$ 的残差向量 $\\mathbf{F}(\\mathbf{U})$ 和雅可比矩阵 $\\mathbf{J}(\\mathbf{U})$ 的函数。然后，两个独立的求解器函数分别实现 Newton 法和 PTC 法的迭代循环，包括它们特定的终止准则和逻辑。初始猜测值由给定的线性剖面构建。程序遍历三个指定的测试用例，对每个用例运行两种求解器，并收集最终的残差范数和迭代次数以供报告。这种比较突出了 Newton 法的快速收敛性与 PTC 法的优越鲁棒性之间的权衡，特别是当问题刚度随着参数 $\\mathrm{Da}$ 和 $\\beta$ 的增加而增加时。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a 1D premixed flame problem using Newton and PTC methods.\n    \"\"\"\n    # --- Problem Constants ---\n    N = 50\n    DZ = 1.0 / (N - 1)\n    DZ2 = DZ * DZ\n    Z = np.linspace(0, 1, N)\n    TOL = 1e-8\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case A (moderate stiffness)\n        {'Da': 10, 'beta': 5, 'gamma': 4, 'Le': 1, 'The_ad': 1},\n        # Case B (stiff)\n        {'Da': 50, 'beta': 12, 'gamma': 4, 'Le': 1, 'The_ad': 1},\n        # Case C (very stiff)\n        {'Da': 100, 'beta': 20, 'gamma': 4, 'Le': 1, 'The_ad': 1},\n    ]\n\n    # --- Helper Functions for Residual and Jacobian ---\n    \n    def compute_residual(U, params):\n        Da, beta, gamma, Le, The_ad = params['Da'], params['beta'], params['gamma'], params['Le'], params['The_ad']\n        theta = U[:N]\n        y = U[N:]\n        F = np.zeros(2 * N)\n\n        # Interior nodes\n        for i in range(1, N - 1):\n            # The reaction term argument can become large positive if (1+gamma*theta) is small or negative,\n            # leading to overflow in np.exp. Clamp the argument to a reasonable max value.\n            arg = -beta / (1.0 + gamma * theta[i]) if (1.0 + gamma * theta[i]) != 0 else np.inf\n            exp_term = np.exp(min(arg, 700)) if y[i] > 0 else 0\n            R = Da * y[i] * exp_term\n            \n            F[i] = (theta[i-1] - 2*theta[i] + theta[i+1]) / DZ2 + R\n            F[N + i] = Le * (y[i-1] - 2*y[i] + y[i+1]) / DZ2 - R\n            \n        # Boundary conditions\n        F[0] = theta[0] - 0.0\n        F[N-1] = theta[N-1] - The_ad\n        F[N] = y[0] - 1.0\n        F[2*N-1] = y[N-1] - 0.0\n        \n        return F\n\n    def compute_jacobian(U, params):\n        Da, beta, gamma, Le = params['Da'], params['beta'], params['gamma'], params['Le']\n        theta = U[:N]\n        y = U[N:]\n        J = np.zeros((2 * N, 2 * N))\n\n        # Interior nodes\n        for i in range(1, N - 1):\n            denom = 1.0 + gamma * theta[i]\n            if denom == 0 or y[i]  0:\n                dRd_theta, dRd_y = 0.0, 0.0\n            else:\n                arg = -beta / denom\n                exp_term = np.exp(min(arg, 700))\n                dRd_theta = Da * y[i] * exp_term * (beta * gamma) / (denom * denom)\n                dRd_y = Da * exp_term\n\n            # Block dF_theta / d_theta\n            J[i, i-1] = 1.0 / DZ2\n            J[i, i] = -2.0 / DZ2 + dRd_theta\n            J[i, i+1] = 1.0 / DZ2\n            \n            # Block dF_theta / d_y\n            J[i, N + i] = dRd_y\n            \n            # Block dF_y / d_theta\n            J[N + i, i] = -dRd_theta\n            \n            # Block dF_y / d_y\n            J[N + i, N + i - 1] = Le / DZ2\n            J[N + i, N + i]     = -2.0 * Le / DZ2 - dRd_y\n            J[N + i, N + i + 1] = Le / DZ2\n\n        # Boundary conditions\n        J[0, 0] = 1.0\n        J[N-1, N-1] = 1.0\n        J[N, N] = 1.0\n        J[2*N-1, 2*N-1] = 1.0\n        \n        return J\n\n    # --- Solver Implementations ---\n    \n    def solve_newton(U_init, params):\n        max_iter = 50\n        U = U_init.copy()\n        \n        for k in range(max_iter):\n            F = compute_residual(U, params)\n            norm_F = np.linalg.norm(F)\n            \n            if norm_F = TOL:\n                return norm_F, k\n            \n            J = compute_jacobian(U, params)\n            \n            try:\n                delta = np.linalg.solve(J, -F)\n            except np.linalg.LinAlgError:\n                return norm_F, k\n            \n            U += delta\n            \n        final_norm = np.linalg.norm(compute_residual(U, params))\n        return final_norm, max_iter\n\n    def solve_ptc(U_init, params):\n        max_iter = 200\n        U = U_init.copy()\n        \n        dt = 1e-4\n        dt_min, dt_max = 1e-6, 1e2\n        \n        F_current = compute_residual(U, params)\n        norm_F_current = np.linalg.norm(F_current)\n\n        for k in range(max_iter):\n            if norm_F_current = TOL:\n                return norm_F_current, k\n            \n            J = compute_jacobian(U, params)\n            A = np.identity(2 * N) * (1.0 / dt) + J\n            \n            try:\n                delta = np.linalg.solve(A, -F_current)\n            except np.linalg.LinAlgError:\n                return norm_F_current, k\n            \n            U += delta\n            \n            F_next = compute_residual(U, params)\n            norm_F_next = np.linalg.norm(F_next)\n            \n            ratio = norm_F_next / norm_F_current if norm_F_current > 1e-12 else 0.0\n            \n            if ratio  0.7:\n                dt = min(2.0 * dt, dt_max)\n            else:\n                dt = max(0.5 * dt, dt_min)\n            \n            F_current = F_next\n            norm_F_current = norm_F_next\n\n        return norm_F_current, max_iter\n\n    # --- Main Execution Logic ---\n    results = []\n    for case in test_cases:\n        theta0 = case['The_ad'] * Z\n        y0 = 1.0 - Z\n        U0 = np.concatenate([theta0, y0])\n        \n        res_N, iter_N = solve_newton(U0, case)\n        results.extend([res_N, iter_N])\n        \n        res_P, iter_P = solve_ptc(U0, case)\n        results.extend([res_P, iter_P])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}