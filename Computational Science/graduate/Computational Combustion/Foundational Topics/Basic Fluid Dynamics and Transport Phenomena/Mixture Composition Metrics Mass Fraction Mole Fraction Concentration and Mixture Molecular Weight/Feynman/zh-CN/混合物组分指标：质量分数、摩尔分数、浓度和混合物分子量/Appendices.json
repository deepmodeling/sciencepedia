{
    "hands_on_practices": [
        {
            "introduction": "在科学计算中，同一个物理量通常可以通过不同的路径，使用不同的变量集合来计算。本练习将从理论和数值两方面来验证这一思想。我们将证明，在理想气体假设下，基于质量相关属性（如质量分数 $Y_i$ 和密度 $\\rho$）计算得到的组分摩尔浓度 $c_i$，与基于摩尔相关属性（如摩尔分数 $X_i$ 和压力 $p$）计算得到的结果是完全等效的。通过这项实践，你将加深对质量分数、摩尔分数以及热力学状态变量之间基本关系的理解。",
            "id": "4040326",
            "problem": "您需要设计并实现一个完整的算法工作流程，该流程根据计算燃烧学的相关基本定义和定律来计算气体混合物中各组分的摩尔浓度。目标是从不同的成分度量标准推导出组分浓度的表达式，在指定条件下证明其等效性，然后在一套测试用例上进行数值验证。\n\n出发点和定义：\n- 令 $i$ 为化学组分的索引。令 $n_i$ 表示组分 $i$ 的摩尔数，$m_i$为其质量，$W_i$ 为其分子量（单位：$\\mathrm{kg/mol}$）。令 $n = \\sum_i n_i$ 和 $m = \\sum_i m_i$ 分别表示混合物的总摩尔数和总质量。令 $V$ 表示混合物的总体积（单位：$\\mathrm{m^3}$），$\\rho$为其质量密度（单位：$\\mathrm{kg/m^3}$），$p$为其压力（单位：$\\mathrm{Pa}$），$T$为其温度（单位：$\\mathrm{K}$）。普适气体常数为 $R_u$（单位：$\\mathrm{J/(mol \\cdot K)}$）。\n- 质量分数定义为 $Y_i = m_i/m$。\n- 摩尔分数定义为 $X_i = n_i/n$。\n- 组分摩尔浓度定义为 $c_i = n_i/V$（单位：$\\mathrm{mol/m^3}$）。\n- 混合物分子量定义为 $W = m/n$。\n- 在理想气体条件下，理想气体定律成立：$pV = n R_u T$。\n\n任务：\n1. 从上述关于 $Y_i$、$X_i$、$c_i$、$\\rho$、$W$、$m_i=n_i W_i$ 的定义以及理想气体定律出发，推导一个用 $Y_i$、$\\rho$ 和 $W_i$ 表示 $c_i$ 的表达式。另外，在理想气体条件下，推导一个用 $X_i$、$p$ 和 $T$ 表示 $c_i$ 的表达式。当混合物遵循理想气体定律，且 $Y_i$、$X_i$ 和 $W$ 的定义被一致应用时，严格证明这两个表达式是等效的。\n2. 设计并实现一个具有清晰步骤的算法，该算法能够：\n   - 使用定义在质量分数 $Y_i$ 和摩尔分数 $X_i$ 之间进行转换。\n   - 根据 $X_i$ 和 $W_i$ 计算混合物分子量 $W$。\n   - 在理想气体条件下，根据 $p$、$T$ 和 $W$ 计算 $\\rho$。\n   - 仅使用基本定义，根据 $\\rho$ 和 $Y_i$ 计算 $c_i$。\n   - 使用理想气体定律，根据 $X_i$、$p$ 和 $T$ 计算 $c_i$。\n   - 通过报告每个测试用例中各组分计算结果之间的最大绝对差异，来验证两种 $c_i$ 计算方法的数值等效性。\n\n物理单位与报告：\n- 分子量 $W_i$ 和混合物分子量 $W$ 必须以 $\\mathrm{kg/mol}$ 为单位处理。\n- 压力 $p$ 必须以 $\\mathrm{Pa}$ 为单位，温度 $T$ 以 $\\mathrm{K}$ 为单位，密度 $\\rho$ 以 $\\mathrm{kg/m^3}$ 为单位，浓度 $c_i$ 以 $\\mathrm{mol/m^3}$ 为单位。\n- 对于每个测试用例，您的程序必须计算并报告一个实数，该实数等于最大绝对差 $\\max_i |c_i^{(\\text{mass})} - c_i^{(\\text{mole})}|$，单位为 $\\mathrm{mol/m^3}$。\n\n测试套件：\n使用以下科学上一致的测试用例。对于每个用例，混合物均为理想气体，您必须根据所提供的参数在内部构建所有必需的量。\n\n- 用例 A（多组分甲烷-类空气混合物）：\n  - 组分：$\\mathrm{CH_4}$、$\\mathrm{O_2}$、$\\mathrm{N_2}$\n  - $W_i$：$[0.016043, 0.031998, 0.0280134]$ $\\mathrm{kg/mol}$\n  - 摩尔分数 $X_i$：$[0.05, 0.21, 0.74]$\n  - $p = 101325$ $\\mathrm{Pa}$，$T = 1000$ $\\mathrm{K}$\n- 用例 B（单组分氧气）：\n  - 组分：$\\mathrm{O_2}$\n  - $W_i$：$[0.031998]$ $\\mathrm{kg/mol}$\n  - 摩尔分数 $X_i$：$[1.0]$\n  - $p = 5 \\times 101325$ $\\mathrm{Pa}$，$T = 300$ $\\mathrm{K}$\n- 用例 C（低压高温空气中的痕量氢气）：\n  - 组分：$\\mathrm{H_2}$、$\\mathrm{O_2}$、$\\mathrm{N_2}$\n  - $W_i$：$[0.00201588, 0.031998, 0.0280134]$ $\\mathrm{kg/mol}$\n  - 摩尔分数 $X_i$：$[10^{-6}, 0.21, 0.789999]$\n  - $p = 50000$ $\\mathrm{Pa}$，$T = 1500$ $\\mathrm{K}$\n- 用例 D（燃烧产物混合物）：\n  - 组分：$\\mathrm{CO_2}$、$\\mathrm{H_2O}$\n  - $W_i$：$[0.0440095, 0.01801528]$ $\\mathrm{kg/mol}$\n  - 摩尔分数 $X_i$：$[0.3, 0.7]$\n  - $p = 2 \\times 101325$ $\\mathrm{Pa}$，$T = 2300$ $\\mathrm{K}$\n\n答案规格：\n- 对于每个用例，计算两组组分浓度，然后输出一个浮点数，该数等于各组分浓度之间的最大绝对差，单位为 $\\mathrm{mol/m^3}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，并保持用例的列出顺序：例如 $[r_A,r_B,r_C,r_D]$，其中每个 $r_\\cdot$ 是一个实数。\n\n不允许用户输入；所有数据必须如上所述进行硬编码。您的代码必须是一个完整、可运行的程序，实现所有步骤，并且只打印指定的最后一行。",
            "solution": "问题陈述已经过仔细审查，并被确定为有效。它具有科学依据，问题提出得当，客观，并提供了一套完整且一致的定义和数据。因此，我们可以着手提供完整的解决方案。\n\n这个问题的核心包括两个部分：首先是对两种计算组分摩尔浓度的方法进行理论推导和等效性证明，然后是设计并实现一个算法来数值验证这种等效性。\n\n### 任务1：理论推导与等效性证明\n\n我们的任务是为组分 $i$ 的摩尔浓度（记为 $c_i$）推导两个不同的表达式，然后在理想气体条件下证明它们的等效性。\n\n**推导1：从质量分数、密度和分子量计算浓度**\n\n这个推导过程将用于计算 $c_i^{(\\text{mass})}$，它从所提供的基本定义出发。\n\n1.  组分摩尔浓度的定义为 $c_i = n_i / V$，其中 $n_i$ 是组分 $i$ 的摩尔数，$V$ 是混合物的总体积。\n2.  组分 $i$ 的质量 $m_i$ 与其摩尔量 $n_i$ 和分子量 $W_i$ 之间的关系为 $m_i = n_i W_i$。可以将其重新整理为 $n_i = m_i / W_i$。\n3.  将这个 $n_i$ 的表达式代入 $c_i$ 的定义中，得到：\n    $$c_i = \\frac{(m_i / W_i)}{V} = \\frac{m_i}{V W_i}$$\n4.  组分 $i$ 的质量分数 $Y_i$ 定义为 $Y_i = m_i / m$，其中 $m$ 是混合物的总质量。可以将其重新整理为 $m_i = Y_i m$。\n5.  将这个 $m_i$ 的表达式代入我们的 $c_i$ 表达式中：\n    $$c_i = \\frac{Y_i m}{V W_i} = \\frac{Y_i}{W_i} \\left(\\frac{m}{V}\\right)$$\n6.  项 $(m/V)$ 是混合物质质量密度 $\\rho$ 的定义。\n7.  因此，我们得到了第一个组分摩尔浓度的表达式：\n    $$c_i^{(\\text{mass})} = \\frac{\\rho Y_i}{W_i}$$\n\n**推导2：从摩尔分数、压力和温度计算浓度（理想气体）**\n\n这第二个推导过程将用于计算 $c_i^{(\\text{mole})}$，它引入了理想气体定律。\n\n1.  我们再次从摩尔浓度的定义开始，$c_i = n_i / V$。\n2.  组分 $i$ 的摩尔分数 $X_i$ 定义为 $X_i = n_i / n$，其中 $n$ 是混合物中的总摩尔数。可以将其重新整理为 $n_i = X_i n$。\n3.  将这个 $n_i$ 的表达式代入 $c_i$ 的定义中：\n    $$c_i = \\frac{X_i n}{V} = X_i \\left(\\frac{n}{V}\\right)$$\n4.  对于表现为理想气体的混合物，理想气体定律为 $pV = n R_u T$，其中 $p$ 是压力，$T$ 是温度，$R_u$ 是普适气体常数。\n5.  我们可以重新整理理想气体定律，以求解项 $(n/V)$，该项代表混合物的总摩尔浓度：\n    $$\\frac{n}{V} = \\frac{p}{R_u T}$$\n6.  将此结果代入我们的 $c_i$ 表达式中，得到第二个所需公式：\n    $$c_i^{(\\text{mole})} = X_i \\frac{p}{R_u T}$$\n\n**等效性证明**\n\n为了在理想气体条件下证明 $c_i^{(\\text{mass})} = c_i^{(\\text{mole})}$，我们必须通过一致地应用给定定义来证明 $\\rho Y_i / W_i = X_i p / (R_u T)$。我们将从 $c_i^{(\\text{mass})}$ 的表达式开始，并证明它可以转换为 $c_i^{(\\text{mole})}$ 的表达式。\n\n1.  从 $c_i^{(\\text{mass})}$ 的表达式开始：\n    $$c_i^{(\\text{mass})} = \\frac{\\rho Y_i}{W_i}$$\n2.  我们需要用基于摩尔的量和状态变量（$p$，$T$）来表示基于质量的量 $\\rho$ 和 $Y_i$。\n3.  首先，我们建立质量分数 $Y_i$ 和摩尔分数 $X_i$ 之间的关系。\n    -   根据定义，$Y_i = m_i / m$。\n    -   代入 $m_i = n_i W_i$ 和 $m = \\sum_j m_j = \\sum_j (n_j W_j)$：\n        $$Y_i = \\frac{n_i W_i}{\\sum_j n_j W_j}$$\n    -   将分子和分母同时除以总摩尔数 $n = \\sum_j n_j$：\n        $$Y_i = \\frac{(n_i/n) W_i}{\\sum_j (n_j/n) W_j} = \\frac{X_i W_i}{\\sum_j X_j W_j}$$\n    -   分母 $\\sum_j X_j W_j$ 是混合物平均分子量 $W$ 的定义。这可以从 $W = m/n$ 的主定义中得出：$W = (\\sum_j m_j)/n = (\\sum_j n_j W_j)/n = \\sum_j (n_j/n) W_j = \\sum_j X_j W_j$。\n    -   因此，转换公式为 $Y_i = (X_i W_i)/W$。\n4.  接下来，我们来表示理想气体的混合物密度 $\\rho$。\n    -   根据定义，$\\rho = m/V$。\n    -   使用理想气体定律 $V = n R_u T / p$：\n        $$\\rho = \\frac{m}{n R_u T / p} = \\frac{m}{n} \\frac{p}{R_u T}$$\n    -   认识到 $W = m/n$，我们得到密度的状态方程：$\\rho = W p / (R_u T)$。\n5.  现在，将推导出的 $Y_i$ 和 $\\rho$ 的表达式代回 $c_i^{(\\text{mass})}$ 的公式中：\n    $$c_i^{(\\text{mass})} = \\left( \\frac{W p}{R_u T} \\right) \\left( \\frac{X_i W_i}{W} \\right) \\left( \\frac{1}{W_i} \\right)$$\n6.  分子和分母中的混合物分子量 $W$ 相互抵消。组分分子量 $W_i$ 也相互抵消。\n    $$c_i^{(\\text{mass})} = \\frac{p}{R_u T} X_i$$\n7.  这个最终表达式与 $c_i^{(\\text{mole})}$ 的表达式相同。这便完成了证明：\n    $$c_i^{(\\text{mass})} = c_i^{(\\text{mole})}$$\n这个严格的证明证实了，对于任何遵循理想气体定律的气体混合物，这两种表述在理论上是等效的。\n\n### 任务2：用于数值验证的算法工作流程\n\n现在我们将对理论等效性进行数值验证。对于提供的每个测试用例，算法按以下步骤进行。每个用例的输入是组分分子量集合 $\\{W_i\\}$、组分摩尔分数集合 $\\{X_i\\}$、混合物压力 $p$ 和混合物温度 $T$。普适气体常数 $R_u = 8.314462618 \\, \\mathrm{J/(mol \\cdot K)}$ 是一个必需的物理常数。\n\n**步骤1：通过摩尔分数路径计算浓度**\n这是最直接的计算方法。\n- 计算混合物的总摩尔浓度，$c = p / (R_u T)$。\n- 使用先前推导的公式计算每个组分 $i$ 的浓度：$c_i^{(\\text{mole})} = X_i \\cdot c = X_i (p / (R_u T))$。\n\n**步骤2：通过质量分数路径计算浓度**\n该路径涉及几个中间计算。\n- **2(a) 计算混合物分子量 ($W$)：** 将混合物的平均分子量计算为组分分子量的摩尔分数加权平均值：\n  $$W = \\sum_i X_i W_i$$\n- **2(b) 将摩尔分数转换为质量分数 ($\\{X_i\\} \\to \\{Y_i\\}$)：** 对于每个组分，使用转换公式计算其质量分数：\n  $$Y_i = \\frac{X_i W_i}{W}$$\n- **2(c) 计算混合物密度 ($\\rho$)：** 使用理想气体状态方程，根据压力、温度和混合物分子量计算混合物质质量密度：\n  $$\\rho = \\frac{p W}{R_u T}$$\n- **2(d) 计算组分浓度 ($c_i^{(\\text{mass})}$)：** 使用基于质量的公式计算每个组分的浓度：\n  $$c_i^{(\\text{mass})} = \\frac{\\rho Y_i}{W_i}$$\n\n**步骤3：比较结果并报告差异**\n- 对于每个测试用例，都已计算出一组浓度 $\\{c_i^{(\\text{mole})}\\}$ 和 $\\{c_i^{(\\text{mass})}\\}$。\n- 计算这两组数据之间的逐元素绝对差：$\\Delta c_i = |c_i^{(\\text{mass})} - c_i^{(\\text{mole})}|$.\n- 该测试用例的最终结果是绝对差集合中的最大值：\n  $$\\text{Discrepancy} = \\max_i(\\Delta c_i)$$\n这个差异应接近于零，其大小仅受浮点运算的有限精度限制。该算法的实现在最终答案中提供。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and validates species molar concentrations in gas mixtures.\n\n    This function implements the algorithmic workflow to:\n    1. Calculate species molar concentrations from mole fractions, pressure, and temperature.\n    2. Calculate the same concentrations via an alternative path involving mass fractions\n       and density.\n    3. Numerically validate the equivalence of the two methods by computing the maximum\n       absolute difference in the results for several test cases.\n    \"\"\"\n    # Universal gas constant in J/(mol·K)\n    R_u = 8.31446261815324\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary containing species names, molecular weights (W_i),\n    # mole fractions (X_i), pressure (p), and temperature (T).\n    test_cases = [\n        {\n            \"name\": \"Case A (methane–air-like mixture)\",\n            \"species\": [\"CH4\", \"O2\", \"N2\"],\n            \"W_i\": np.array([0.016043, 0.031998, 0.0280134]),  # kg/mol\n            \"X_i\": np.array([0.05, 0.21, 0.74]),\n            \"p\": 101325.0,  # Pa\n            \"T\": 1000.0,  # K\n        },\n        {\n            \"name\": \"Case B (single-species oxygen)\",\n            \"species\": [\"O2\"],\n            \"W_i\": np.array([0.031998]),  # kg/mol\n            \"X_i\": np.array([1.0]),\n            \"p\": 5.0 * 101325.0,  # Pa\n            \"T\": 300.0,  # K\n        },\n        {\n            \"name\": \"Case C (trace hydrogen in air)\",\n            \"species\": [\"H2\", \"O2\", \"N2\"],\n            \"W_i\": np.array([0.00201588, 0.031998, 0.0280134]),  # kg/mol\n            \"X_i\": np.array([1e-6, 0.21, 0.789999]),\n            \"p\": 50000.0,  # Pa\n            \"T\": 1500.0,  # K\n        },\n        {\n            \"name\": \"Case D (combustion products)\",\n            \"species\": [\"CO2\", \"H2O\"],\n            \"W_i\": np.array([0.0440095, 0.01801528]),  # kg/mol\n            \"X_i\": np.array([0.3, 0.7]),\n            \"p\": 2.0 * 101325.0,  # Pa\n            \"T\": 2300.0,  # K\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        W_i = case[\"W_i\"]\n        X_i = case[\"X_i\"]\n        p = case[\"p\"]\n        T = case[\"T\"]\n\n        # --- Calculation Path 1: Mole Fraction Based ---\n        # c_i = X_i * (p / (R_u * T))\n        total_molar_concentration = p / (R_u * T)\n        c_i_mole = X_i * total_molar_concentration\n\n        # --- Calculation Path 2: Mass Fraction Based ---\n        # 1. Compute mixture molecular weight (W)\n        # W = sum(X_i * W_i)\n        W_mixture = np.dot(X_i, W_i)\n\n        # 2. Convert mole fractions (X_i) to mass fractions (Y_i)\n        # Y_i = X_i * W_i / W_mixture\n        # Adding a small epsilon to W_mixture to avoid division by zero in edge cases,\n        # although not strictly necessary with the given test data.\n        Y_i = (X_i * W_i) / (W_mixture + 1e-30)\n\n        # 3. Compute mixture density (rho) using the ideal gas law\n        # rho = p * W_mixture / (R_u * T)\n        rho_mixture = p * W_mixture / (R_u * T)\n\n        # 4. Compute species concentrations (c_i) from mass-based quantities\n        # c_i = rho * Y_i / W_i\n        c_i_mass = (rho_mixture * Y_i) / (W_i + 1e-30)\n\n        # --- Validation ---\n        # Compute the maximum absolute difference between the two computed concentration vectors.\n        # This value should be near machine precision (~0.0).\n        max_abs_diff = np.max(np.abs(c_i_mass - c_i_mole))\n        results.append(max_abs_diff)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在真实的计算机模拟中，数值计算（如浮点运算）带来的微小误差可能会累积，导致计算出的质量分数向量 $\\tilde{Y}$ 违反其基本的物理约束，即各组分质量分数之和应为 $1$ ($\\sum_i Y_i = 1$) 且所有组分质量分数均不能为负 ($Y_i \\ge 0$)。本练习将介绍一种严谨的数学方法来修正这些不符合物理规律的质量分数，即在欧几里得空间中寻找一个与原始向量 $\\tilde{Y}$ “最近”且满足所有物理约束的向量 $Y^\\star$。这项被称为“单纯形投影”的技术，是确保燃烧模拟代码鲁棒性和物理保真度的关键工具。",
            "id": "4040311",
            "problem": "给定一个反应混合物中由 $i \\in \\{1,\\dots,n\\}$ 索引的有限化学物质集合。物质 $i$ 的质量分数用 $Y_i$ 表示，摩尔分数用 $X_i$ 表示，分子量（每摩尔的质量）用 $W_i$ 表示。由于数值燃烧模拟中的浮点舍入和算法截断，人们经常得到一个受扰动的质量分数向量 $\\tilde{Y} \\in \\mathbb{R}^n$，它可能不满足质量分数的两个核心约束，即 $\\sum_{i=1}^n Y_i = 1$ 和对所有 $i$ 都有 $Y_i \\ge 0$。混合物的分子量 $W_{\\mathrm{mix}}$ 由质量分数和分子量定义为 $$W_{\\mathrm{mix}} = \\left(\\sum_{i=1}^n \\frac{Y_i}{W_i}\\right)^{-1},$$ 当对所有 $i$ 都有 $Y_i \\ge 0$、$\\sum_i Y_i = 1$ 和 $W_i > 0$ 时，该定义是良定义的。你的任务是，从第一性原理出发，推导出一个归一化策略，该策略接收任何由浮点计算产生的 $\\tilde{Y}$，并返回一个满足质量分数约束的校正向量 $Y^\\star$，同时在适当的度量下使扰动最小。你必须从质量分数的质量守恒基本约束（非负性和总和为一）以及最小化与 $\\tilde{Y}$ 之间物理上有意义的偏差这一基本优化原理出发，并推理出一个具体的算法。然后，你必须证明该策略在单纯形 $$\\Delta^{n-1} = \\left\\{Y \\in \\mathbb{R}^n \\;\\middle|\\; \\sum_{i=1}^n Y_i = 1,\\; Y_i \\ge 0 \\;\\forall i\\right\\}$$ 上是可行的。在你的证明中，你应该确立解的存在性、唯一性，并证明构造出的 $Y^\\star$ 位于 $\\Delta^{n-1}$ 内，同时论证在所选度量下扰动是最小的。\n\n程序要求：在一个程序中实现你的归一化策略，并将其应用于下面的测试套件。对于每个测试用例，计算校正后的质量分数 $Y^\\star$ 和使用校正后的 $Y^\\star$ 计算出的相应混合物分子量 $W_{\\mathrm{mix}}$。质量分数是无量纲的，而分子量必须以 $\\mathrm{kg}/\\mathrm{kmol}$ 为单位处理，你的程序必须以 $\\mathrm{kg}/\\mathrm{kmol}$ 报告 $W_{\\mathrm{mix}}$。你必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身应该是一个双元素列表，其第一个元素是校正后的质量分数列表 $Y^\\star$（与给定的物质顺序相同），第二个元素是标量 $W_{\\mathrm{mix}}$（单位为 $\\mathrm{kg}/\\mathrm{kmol}$）。最终输出必须具有以下形式 $$\\left[\\left[Y^\\star_{(1)}, W_{\\mathrm{mix},(1)}\\right], \\left[Y^\\star_{(2)}, W_{\\mathrm{mix},(2)}\\right], \\dots \\right],$$ 其中 $Y^\\star_{(k)}$ 是一个包含 $n$ 个浮点数的列表，$W_{\\mathrm{mix},(k)}$ 是一个浮点数。\n\n推导允许的基本依据：\n- 质量分数约束 $\\sum_{i=1}^n Y_i = 1$ 和对所有 $i$ 都有 $Y_i \\ge 0$。\n- 根据 $\\mathbb{R}^n$ 中范数诱导的距离最小化偏差的原则（在此背景下，从第一性原理选择并论证一个合适的范数）。\n- 混合物分子量 $W_{\\mathrm{mix}}$ 由质量分数和分子量定义的公式。\n\n测试套件：\n- 物质与分子量：考虑 $n = 5$ 种物质，其分子量（单位为 $\\mathrm{kg}/\\mathrm{kmol}$）按以下固定顺序排列：氮气 ($\\mathrm{N}_2$) $W_1 = 28.0134$、氧气 ($\\mathrm{O}_2$) $W_2 = 31.9988$、二氧化碳 ($\\mathrm{CO}_2$) $W_3 = 44.0095$、水 ($\\mathrm{H}_2\\mathrm{O}$) $W_4 = 18.01528$、甲烷 ($\\mathrm{CH}_4$) $W_5 = 16.04246$。\n- 测试用例按相同的物质顺序指定 $\\tilde{Y}$ 如下：\n    1. 正常路径扰动：$\\tilde{Y}^{(1)} = [0.755, 0.205, 0.001, 0.039, 0.0009]$。\n    2. 因舍入导致的微小负值，总和接近1：$\\tilde{Y}^{(2)} = [0.7000000001, 0.2099999999, -10^{-12}, 0.09, 0]$。\n    3. 极端舍入崩溃（边界压力测试）：$\\tilde{Y}^{(3)} = [0, 0, 0, 0, 0]$。\n    4. 已接近可行，总和有微小误差：$\\tilde{Y}^{(4)} = [0.7800000000001, 0.2099999999999, 0, 0.01, 0]$。\n    5. 高度倾斜且有微小负值：$\\tilde{Y}^{(5)} = [1 + 10^{-9}, -10^{-9}, 0, 0, 0]$。\n\n答案规范：\n- 对于每个测试用例，按上文所述返回校正后的 $Y^\\star$ 和得到的 $W_{\\mathrm{mix}}$。所有数字在输出行中必须报告为纯十进制浮点数，不带单位，但你的推导和程序必须以 $\\mathrm{kg}/\\mathrm{kmol}$ 处理 $W_i$ 并以 $\\mathrm{kg}/\\mathrm{kmol}$ 解释 $W_{\\mathrm{mix}}$。\n- 你的程序必须精确地产生一行，其中包含列表 $$\\left[\\left[Y^\\star_{(1)}, W_{\\mathrm{mix},(1)}\\right],\\left[Y^\\star_{(2)}, W_{\\mathrm{mix},(2)}\\right],\\left[Y^\\star_{(3)}, W_{\\mathrm{mix},(3)}\\right],\\left[Y^\\star_{(4)}, W_{\\mathrm{mix},(4)}\\right],\\left[Y^\\star_{(5)}, W_{\\mathrm{mix},(5)}\\right]\\right].$$\n\n可行性与覆盖范围：\n- 你的测试套件包括一个一般情况、几个带有微小负值的情况、一个完全崩溃的边界情况以及一个高度倾斜的情况。你必须确保你的归一化策略在所有情况下都能返回有效的质量分数 $Y^\\star$，满足 $\\sum_i Y^\\star_i = 1$ 和 $Y^\\star_i \\ge 0$。\n- 每个测试用例的输出必须是一个由浮点数列表和浮点数组成的列表，如规范所述，以确保每个测试用例的答案都是可量化和可自动验证的。",
            "solution": "校正一个受扰动的质量分数向量 $\\tilde{Y} \\in \\mathbb{R}^n$ 以满足物理约束的问题是计算建模中的一个经典问题，尤其在燃烧等质量守恒至关重要的领域。目标是找到一个校正向量 $Y^\\star$，它遵循定义标准单纯形 $\\Delta^{n-1}$ 的约束，同时与原始的扰动向量 $\\tilde{Y}$ “尽可能接近”。\n\n质量分数向量 $Y = [Y_1, \\dots, Y_n]^T$ 的约束是：\n1. 总和为一约束：$\\sum_{i=1}^n Y_i = 1$。\n2. 非负性约束：对于所有 $i \\in \\{1, \\dots, n\\}$，有 $Y_i \\ge 0$。\n\n任务是找到一个向量 $Y^\\star$，在满足这些约束的条件下，最小化与 $\\tilde{Y}$ 的偏差。这可以正式地表述为一个优化问题。\n\n首先，我们必须选择一个度量来量化偏差 $\\|Y^\\star - \\tilde{Y}\\|$。最自然且数学上最方便的选择是标准欧几里得距离（或 $L_2$ 范数）。最小化距离 $\\|Y^\\star - \\tilde{Y}\\|_2$ 等价于最小化其平方 $\\|Y^\\star - \\tilde{Y}\\|_2^2$。这一选择是合理的，因为它产生了一个严格凸的二次目标函数，从而保证了解的唯一性。它平等地对待所有物质分数的扰动，而没有引入任何任意的权重。\n\n因此，优化问题是找到 $\\tilde{Y}$ 在单纯形 $\\Delta^{n-1}$ 上的欧几里得投影：\n$$\n\\begin{align*}\n\\underset{Y^\\star \\in \\mathbb{R}^n}{\\text{minimize}}  \\quad f(Y^\\star) = \\frac{1}{2} \\|Y^\\star - \\tilde{Y}\\|_2^2 = \\frac{1}{2} \\sum_{i=1}^n (Y^\\star_i - \\tilde{Y}_i)^2 \\\\\n\\text{subject to}  \\quad \\sum_{i=1}^n Y^\\star_i = 1 \\\\\n \\quad Y^\\star_i \\ge 0 \\quad \\text{for } i = 1, \\dots, n\n\\end{align*}\n$$\n因子 $\\frac{1}{2}$ 是为了在求导时便于代数计算。这是一个凸优化问题（一个二次规划问题），因为目标函数是严格凸的，且约束集是凸的。\n\n我们使用 Karush-Kuhn-Tucker (KKT) 条件来解决这个问题。该问题的拉格朗日函数 $\\mathcal{L}$ 是：\n$$ \\mathcal{L}(Y^\\star, \\mu, \\lambda) = \\frac{1}{2} \\sum_{i=1}^n (Y^\\star_i - \\tilde{Y}_i)^2 - \\mu \\left( \\sum_{i=1}^n Y^\\star_i - 1 \\right) - \\sum_{i=1}^n \\lambda_i Y^\\star_i $$\n其中 $\\mu$ 是等式约束的拉格朗日乘子，$\\lambda_i$ 是非负性不等式约束的乘子。\n\n最优性的 KKT 条件是：\n1. **平稳性 (Stationarity):** 对所有 $i \\in \\{1,\\dots,n\\}$，$\\frac{\\partial \\mathcal{L}}{\\partial Y^\\star_i} = Y^\\star_i - \\tilde{Y}_i - \\mu - \\lambda_i = 0$。这意味着 $Y^\\star_i = \\tilde{Y}_i + \\mu + \\lambda_i$。\n2. **原始可行性 (Primal Feasibility):** $\\sum_{i=1}^n Y^\\star_i = 1$ 且对所有 $i$ 都有 $Y^\\star_i \\ge 0$。\n3. **对偶可行性 (Dual Feasibility):** 对所有 $i$ 都有 $\\lambda_i \\ge 0$。\n4. **互补松弛性 (Complementary Slackness):** 对所有 $i$ 都有 $\\lambda_i Y^\\star_i = 0$。\n\n从互补松弛性条件可知，对于每个物质 $i$，要么 $\\lambda_i=0$，要么 $Y^\\star_i=0$。\n- 如果 $Y^\\star_i > 0$，那么必须有 $\\lambda_i = 0$。平稳性条件简化为 $Y^\\star_i = \\tilde{Y}_i + \\mu$。条件 $Y^\\star_i > 0$ 意味着 $\\tilde{Y}_i + \\mu > 0$。\n- 如果 $Y^\\star_i = 0$，那么 $\\lambda_i \\ge 0$。平稳性条件给出 $0 = \\tilde{Y}_i+\\mu+\\lambda_i$。由于 $\\lambda_i \\ge 0$，这要求 $\\tilde{Y}_i + \\mu \\le 0$。\n\n将这两种情况结合起来，可以得到解 $Y^\\star_i$ 的一个紧凑表达式：\n$$ Y^\\star_i = \\max(0, \\tilde{Y}_i + \\mu) $$\n这个简洁的结果表明，解是通过对原始向量 $\\tilde{Y}$ 进行一个值为 $\\mu$ 的均匀平移，然后在零处进行截断得到的。唯一的未知数是拉格朗日乘子 $\\mu$。\n\n为了找到 $\\mu$，我们应用原始可行性约束 $\\sum_{i=1}^n Y^\\star_i = 1$：\n$$ \\sum_{i=1}^n \\max(0, \\tilde{Y}_i + \\mu) = 1 $$\n我们定义一个函数 $g(\\mu) = \\sum_{i=1}^n \\max(0, \\tilde{Y}_i + \\mu)$。我们需要找到 $g(\\mu) = 1$ 的根。函数 $g(\\mu)$ 是连续、分段线性和单调不减的。这保证了 $\\mu$ 的唯一解存在。\n\n为了高效地求解 $\\mu$，我们将 $\\tilde{Y}$ 的分量按降序排序：$u_1 \\ge u_2 \\ge \\dots \\ge u_n$。条件 $\\tilde{Y}_i + \\mu > 0$ 将对那些 $\\tilde{Y}_i$ 值最大的分量成立。设 $\\rho$ 是满足此条件的元素数量。这 $\\rho$ 个元素构成了“激活集”，它们在最终解中的值将是正的。对于这 $\\rho$ 个元素，$Y^\\star_i = u_i + \\mu$，而对于剩下的 $n-\\rho$ 个元素，$Y^\\star_i = 0$。\n\n总和约束变为：\n$$ \\sum_{j=1}^\\rho (u_j + \\mu) = 1 \\implies \\left(\\sum_{j=1}^\\rho u_j\\right) + \\rho \\mu = 1 $$\n解出 $\\mu$：\n$$ \\mu = \\frac{1 - \\sum_{j=1}^\\rho u_j}{\\rho} $$\n正确的 $\\rho$ 值是使激活集一致的那个，即对 $j \\le \\rho$ 有 $u_j + \\mu > 0$ 且对 $j > \\rho$ 有 $u_j + \\mu \\le 0$。临界条件发生在激活集的边界，即 $j=\\rho$。我们需要找到最大的 $\\rho \\in \\{1, \\dots, n\\}$ 使得：\n$$ u_\\rho + \\frac{1 - \\sum_{j=1}^\\rho u_j}{\\rho} > 0 $$\n这个不等式可以重写为 $\\rho u_\\rho + 1 - \\sum_{j=1}^\\rho u_j > 0$，或 $\\rho u_\\rho > \\left(\\sum_{j=1}^\\rho u_j\\right) - 1$。\n\n这引出了以下算法：\n1. 给定输入向量 $\\tilde{Y} \\in \\mathbb{R}^n$。\n2. 将 $\\tilde{Y}$ 按降序排序，得到一个新向量 $u = [u_1, u_2, \\dots, u_n]$。\n3. 计算 $u$ 的累积和，$S_j = \\sum_{i=1}^j u_i$。\n4. 找到满足条件 $j u_j > S_j - 1$ (对于 $j=1, \\dots, \\rho$) 的最大整数 $\\rho \\in \\{1,\\dots,n\\}$。\n5. 用这个 $\\rho$ 计算平移参数 $\\mu = (1 - S_\\rho) / \\rho$。\n6. 最终的校正向量 $Y^\\star$ 逐元素计算为 $Y^\\star_i = \\max(0, \\tilde{Y}_i + \\mu)$。\n\n该算法正确性的证明必须确立解 $Y^\\star$ 的存在性、唯一性和可行性。\n- **存在性与唯一性：** 目标函数 $f(Y^\\star)$ 是严格凸且连续的。约束集，即单纯形 $\\Delta^{n-1}$，是 $\\mathbb{R}^n$ 的一个非空、闭合且凸（因此是紧）的子集。威尔斯特拉斯极值定理保证了最小值的存在。$f$ 的严格凸性保证了这个最小值是唯一的。\n- **可行性：** 根据构造，$Y^\\star_i = \\max(0, \\tilde{Y}_i + \\mu)$ 确保了 $Y^\\star_i \\ge 0$。总和为 $\\sum_{i=1}^n Y^\\star_i = \\sum_{i=1}^n \\max(0, \\tilde{Y}_i + \\mu) = \\sum_{j=1}^\\rho (u_j + \\mu)$，其中第二个和是对应于激活集的排序向量 $u$ 的元素。这可以计算为 $(\\sum_{j=1}^\\rho u_j) + \\rho \\mu = S_\\rho + \\rho \\frac{1 - S_\\rho}{\\rho} = S_\\rho + 1 - S_\\rho = 1$。因此，解 $Y^\\star$ 位于单纯形 $\\Delta^{n-1}$ 上。\n- **最优性：** 由于优化问题是凸的，KKT 条件是全局最优解的充分必要条件。我们的推导找到了满足这些条件的唯一解，因此它是唯一的最优解。\n\n最后，利用校正后的质量分数 $Y^\\star$，根据其定义计算混合物分子量 $W_\\mathrm{mix}$：\n$$ W_{\\mathrm{mix}} = \\left(\\sum_{i=1}^n \\frac{Y^\\star_i}{W_i}\\right)^{-1} $$\n其中 $W_i > 0$ 是物质的分子量。由于 $Y^\\star_i \\ge 0$ 且 $\\sum_i Y^\\star_i=1$，并且并非所有的 $Y^\\star_i$ 都可以为 $0$，所以分母是良定义的正数，确保了 $W_\\mathrm{mix}$ 也是良定义的正数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the mass fraction normalization problem for a suite of test cases.\n    \"\"\"\n\n    # Define the species molecular weights (kg/kmol) in a fixed order.\n    # N2, O2, CO2, H2O, CH4\n    molecular_weights = np.array([\n        28.0134,    # W_1 (N2)\n        31.9988,    # W_2 (O2)\n        44.0095,    # W_3 (CO2)\n        18.01528,   # W_4 (H2O)\n        16.04246    # W_5 (CH4)\n    ])\n\n    # Define the test cases for the perturbed mass fraction vector tilde_Y.\n    test_cases = [\n        # 1. Happy-path perturbation\n        np.array([0.755, 0.205, 0.001, 0.039, 0.0009]),\n        # 2. Tiny negative entry due to roundoff\n        np.array([0.7000000001, 0.2099999999, -1e-12, 0.09, 0.0]),\n        # 3. Extreme rounding collapse (boundary stress test)\n        np.array([0.0, 0.0, 0.0, 0.0, 0.0]),\n        # 4. Already near-feasible with tiny sum error\n        np.array([0.7800000000001, 0.2099999999999, 0.0, 0.01, 0.0]),\n        # 5. Highly skewed with a tiny negative entry\n        np.array([1.0 + 1e-9, -1e-9, 0.0, 0.0, 0.0])\n    ]\n\n    results = []\n    for y_tilde in test_cases:\n        # Normalize the mass fraction vector\n        y_star = _project_to_simplex(y_tilde)\n        \n        # Calculate the mixture molecular weight using the corrected mass fractions\n        # W_mix = (sum(Y_i / W_i))^-1\n        # To avoid division by zero if a W_i is zero (not the case here),\n        # we can filter. Since W_i are all > 0, this is robust.\n        # Likewise, if a Y_i is zero, its term is zero.\n        w_mix = 1.0 / np.sum(y_star / molecular_weights)\n        \n        # Store the results for this case. y_star is converted to a list for formatting.\n        results.append([y_star.tolist(), w_mix])\n\n    # Format the final output string exactly as specified in the problem statement.\n    # The format is [[Y*_1, W_mix_1], [Y*_2, W_mix_2], ...]\n    # where each Y* is a list of floats.\n    output_str = f\"[{','.join(f'[{str(y)},{w}]' for y, w in results)}]\"\n    print(output_str)\n\ndef _project_to_simplex(y_tilde: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Projects a vector onto the standard simplex using a fast projection algorithm.\n\n    This algorithm finds the Euclidean projection of a vector y_tilde onto the\n    simplex {x | sum(x) = 1, x_i >= 0}, which is equivalent to solving the\n    optimization problem:\n    \n    minimize   0.5 * ||x - y_tilde||^2\n    subject to sum(x) = 1, x_i >= 0\n    \n    Args:\n        y_tilde: A numpy array representing the vector to be projected.\n\n    Returns:\n        A numpy array representing the projected vector on the simplex.\n    \"\"\"\n    n = y_tilde.shape[0]\n    \n    # Sort the input vector in descending order.\n    u = np.sort(y_tilde)[::-1]\n    \n    # Calculate the cumulative sum of the sorted vector.\n    s = np.cumsum(u)\n    \n    # Find the largest index rho such that u_rho + (1 - s_rho) / rho > 0.\n    # This is implemented by finding all j that satisfy the condition and taking the max.\n    # The condition is vectorized as: u_j > (s_j - 1) / j for j=1...n\n    # Using 1-based indexing for j in the formula corresponds to 0-based index `j-1` in arrays.\n    j_indices = np.arange(1, n + 1)\n    condition = u > (s - 1) / j_indices\n    \n    # The set of indices j for which the condition holds is never empty because for j=1,\n    # u_1 > (u_1 - 1)/1 is 0 > -1, which is always true.\n    # So we can safely access the last element.\n    rho = np.where(condition)[0][-1] + 1\n    \n    # Calculate the Lagrange multiplier (the shift value mu).\n    # mu = (1 - s[rho-1]) / rho, where s[rho-1] is the sum of the top rho elements.\n    mu = (1 - s[rho - 1]) / rho\n    \n    # Apply the shift and clip at zero to get the projected vector.\n    y_star = np.maximum(0, y_tilde + mu)\n    \n    return y_star\n\nsolve()\n```"
        },
        {
            "introduction": "最后一个练习将前述概念应用于计算流体动力学 (CFD) 的一个高级主题中。在有限体积法等数值方法中，为了获得高精度的解，需要在计算网格的交界面上重构物理量的分布。本练习将演示如何为一个有限体积求解器设计并实现一种界面重构方案，该方案能够在重构组分分布的同时，确保在界面处同样严格满足质量分数的正定性和归一性约束。掌握这项技术对于开发稳定、准确的反应流数值模拟程序至关重要。",
            "id": "4040288",
            "problem": "给定一个含多个化学组分的一维反应性气体混合物的有限体积框架。设 $S$ 为组分数，索引为 $i \\in \\{1,\\dots,S\\}$。每个控制体的守恒变量是组分质量密度 $\\rho Y_i$，其中 $\\rho$ 是混合物质量密度，$Y_i$ 是组分质量分数。出发的基本依据包括：定义式 $Y_i = \\rho_i/\\rho$（其中 $\\rho_i$ 为组分质量密度），各组分的有限体积守恒更新的积分形式，以及混合物理想气体定律 $p = \\rho R T$，其中 $p$ 为压力，$T$ 为温度，$R$ 为混合气体常数，定义为 $R = R_{\\mathrm{u}}/W_{\\mathrm{mix}}$，$R_{\\mathrm{u}}$ 是普适气体常数，$W_{\\mathrm{mix}}$ 是混合物分子量。您必须基于这些基本原理进行推导，设计一种质量分数场的重构方法，并计算混合物组分的度量指标。\n\n您的任务是，为下述每个测试用例，实现一种在控制体交界面上对组分质量分数进行分段线性重构的方法，该方法需同时满足两个约束：正性约束（对所有 $i$，$Y_i \\ge 0$）和归一化约束（$\\sum_i Y_i = 1$）。每个测试用例处理一个目标单元，给定其单元平均组分向量 $\\mathbf{Y}$ 及其左右相邻单元的平均向量，记为 $\\mathbf{Y}^{L}$ 和 $\\mathbf{Y}^{R}$。使用基于给定相邻状态的标量、分量形式的斜率限制器来估计初始斜率向量，然后在构造左右交界面值之前，通过确保限制后的斜率分量之和为零来强制交界面状态的精确归一化。最后，通过一个由容许性约束计算出的、在 $[0,1]$ 区间内的因子来统一缩放斜率，以强制交界面值的正性。\n\n从基本定义出发，根据第一性原理推导如何：\n- 在通量和源项一致离散化的条件下，确保 $\\rho Y_i$ 的有限体积离散化能保证 $\\sum_i Y_i$ 在时间上守恒，并解释为什么强制跨组分斜率之和为零的重构方法能够在交界面上保持 $\\sum_i Y_i$。\n- 仅使用局部数据 $(\\mathbf{Y}^{L}, \\mathbf{Y}, \\mathbf{Y}^{R})$ 构建一个对 $\\mathbf{Y}$ 的斜率限制、保持和、保持正性的交界面重构。\n- 根据重构后的质量分数和给定的组分分子量 $\\{W_i\\}_{i=1}^S$ 计算混合物分子量 $W_{\\mathrm{mix}}$。\n- 根据重构后的质量分数、压力 $p$（单位为 $\\mathrm{Pa}$）、温度 $T$（单位为 $\\mathrm{K}$）和分子量，计算摩尔分数 $\\{X_i\\}_{i=1}^S$ 和摩尔浓度 $\\{c_i\\}_{i=1}^S$（单位为 $\\mathrm{mol/m}^3$）。所需关系式仅从定义和理想气体定律推导；不要引入问题陈述中未给出的任何简化表达式。\n\n重构的实现细节和约束：\n- 每个单元使用一个斜率向量的分段线性形式。组分 $i$ 的原始斜率应根据 $\\mathbf{Y}^{L}$、$\\mathbf{Y}$ 和 $\\mathbf{Y}^{R}$，通过一种符号一致且幅值有界的选择来计算（例如，一个双参数运算，如果符号不同则返回零，否则返回具有共同符号的较小幅值）。然后，在用它来形成交界面状态之前，通过代数方式强制斜率分量之和精确为零。设最终限制后的斜率为 $\\boldsymbol{s}$，则左右交界面值为 $\\mathbf{Y}^{-} = \\mathbf{Y} - \\tfrac{1}{2}\\boldsymbol{s}$ 和 $\\mathbf{Y}^{+} = \\mathbf{Y} + \\tfrac{1}{2}\\boldsymbol{s}$。\n- 为同时强制 $\\mathbf{Y}^{-}$ 和 $\\mathbf{Y}^{+}$ 的正性，将零和斜率乘以一个因子 $\\alpha \\in [0,1]$ 进行统一缩放。该因子根据任一交界面状态的任一分量均不能为负的约束计算得出。得到的 $\\boldsymbol{s} = \\alpha \\,\\boldsymbol{s}_0$ 必须在分量上满足 $\\mathbf{Y}^{-} \\ge \\mathbf{0}$ 和 $\\mathbf{Y}^{+} \\ge \\mathbf{0}$，同时保持 $\\sum_i s_i = 0$。\n\n对于每个测试用例，您的程序必须：\n1. 执行上述重构以获得 $\\mathbf{Y}^{-}$ 和 $\\mathbf{Y}^{+}$。\n2. 仅使用您推导出的定义和关系，分别从 $\\mathbf{Y}^{-}$ 和 $\\mathbf{Y}^{+}$ 计算 $W_{\\mathrm{mix}}^{-}$ 和 $W_{\\mathrm{mix}}^{+}$。\n3. 计算摩尔浓度向量 $\\mathbf{c}^{-}$ 和 $\\mathbf{c}^{+}$，并报告其和 $\\sum_i c_i^{-}$ 和 $\\sum_i c_i^{+}$。\n4. 生成四个布尔值，指示归一化和正性约束在两个交界面上是否成立：\n   - $b_1$：$\\sum_i Y_i^{-}$ 是否在 $10^{-12}$ 的容差内等于 $1$，\n   - $b_2$：$\\sum_i Y_i^{+}$ 是否在 $10^{-12}$ 的容差内等于 $1$，\n   - $b_3$：$\\mathbf{Y}^{-}$ 的所有分量是否在 $10^{-12}$ 的容差内为非负，\n   - $b_4$：$\\mathbf{Y}^{+}$ 的所有分量是否在 $10^{-12}$ 的容差内为非负。\n\n物理常数和单位：\n- 对所有测试用例，使用普适气体常数 $R_{\\mathrm{u}} = 8.314462618\\,\\mathrm{J/(mol \\cdot K)}$（在程序中写作 $R_{\\mathrm{u}} = 8.314462618$，单位由上下文隐含）。\n- 压力 $p$ 的单位为 $\\mathrm{Pa}$，温度 $T$ 的单位为 $\\mathrm{K}$，分子量 $W_i$ 的单位为 $\\mathrm{kg/mol}$，摩尔浓度 $c_i$ 必须以 $\\mathrm{mol/m}^3$ 为单位计算和报告。\n\n测试套件：\n- 用例 1（$S=4$ 个组分）：$W = [\\,0.0440095,\\,0.01801528,\\,0.0280134,\\,0.0319988\\,]$，$\\mathbf{Y}^{L} = [\\,0.12,\\,0.18,\\,0.62,\\,0.08\\,]$，$\\mathbf{Y} = [\\,0.10,\\,0.20,\\,0.60,\\,0.10\\,]$，$\\mathbf{Y}^{R} = [\\,0.08,\\,0.22,\\,0.57,\\,0.13\\,]$，$p = 101325$，$T = 1200$。\n- 用例 2（$S=4$ 个组分）：$W = [\\,0.0440095,\\,0.01801528,\\,0.0280134,\\,0.0319988\\,]$，$\\mathbf{Y}^{L} = [\\,0.68,\\,0.30,\\,0.02,\\,0.00\\,]$，$\\mathbf{Y} = [\\,0.70,\\,0.29,\\,0.01,\\,0.00\\,]$，$\\mathbf{Y}^{R} = [\\,0.75,\\,0.24,\\,0.01,\\,0.00\\,]$，$p = 500000$，$T = 2500$。\n- 用例 3（$S=2$ 个组分）：$W = [\\,0.00201588,\\,0.0280134\\,]$，$\\mathbf{Y}^{L} = [\\,0.98,\\,0.02\\,]$，$\\mathbf{Y} = [\\,1.00,\\,0.00\\,]$，$\\mathbf{Y}^{R} = [\\,0.99,\\,0.01\\,]$，$p = 200000$，$T = 300$。\n- 用例 4（$S=4$ 个组分）：$W = [\\,0.0440095,\\,0.01801528,\\,0.0280134,\\,0.0319988\\,]$，$\\mathbf{Y}^{L} = [\\,0.20,\\,0.20,\\,0.40,\\,0.20\\,]$，$\\mathbf{Y} = [\\,0.25,\\,0.25,\\,0.25,\\,0.25\\,]$，$\\mathbf{Y}^{R} = [\\,0.30,\\,0.10,\\,0.20,\\,0.40\\,]$，$p = 300000$，$T = 1800$。\n\n答案规格：\n- 对于每个测试用例，输出列表 $[\\,b_1,\\,b_2,\\,b_3,\\,b_4,\\,W_{\\mathrm{mix}}^{-},\\,W_{\\mathrm{mix}}^{+},\\,\\sum_i c_i^{-},\\,\\sum_i c_i^{+}\\,]$，其中前四项是布尔值，后四项是浮点数。\n- 您的程序应生成单行输出，其中包含四个测试用例的结果，格式为由逗号分隔的各个用例列表，并用方括号括起来，例如：$[[\\dots],[\\dots],[\\dots],[\\dots]]$。",
            "solution": "该问题要求设计并实现一种用于有限体积单元交界面上组分质量分数的数值重构方法。该方法必须遵循物理约束，特别是质量分数的正性（$Y_i \\ge 0$）及其和的归一化（$\\sum_i Y_i = 1$）。解决方案将按规定从第一性原理出发进行阐述，涵盖其理论基础、算法构建以及相关热化学性质的推导。\n\n**理论基础与推导**\n\n首先，我们为重构的约束条件建立理论基础。\n\n**1. 质量分数归一化的守恒性**\n该问题基于 $\\rho Y_i$ 的组分守恒方程的有限体积离散化。对于给定的控制体 $V_j$，组分 $i$ 的守恒律为：\n$$\n\\frac{d}{dt} \\int_{V_j} \\rho Y_i \\, dV = - \\oint_{\\partial V_j} \\mathbf{F}_i \\cdot d\\mathbf{A} + \\int_{V_j} \\dot{\\omega}_i \\, dV\n$$\n其中 $\\rho$ 是混合物密度，$Y_i$ 是组分 $i$ 的质量分数，$\\mathbf{F}_i$ 是组分 $i$ 的通量（包括对流和扩散），$\\dot{\\omega}_i$ 是其由化学反应产生的质量生成率。\n\n对所有组分 $i=1, \\ldots, S$ 求和：\n$$\n\\sum_{i=1}^S \\frac{d}{dt} \\int_{V_j} \\rho Y_i \\, dV = - \\sum_{i=1}^S \\oint_{\\partial V_j} \\mathbf{F}_i \\cdot d\\mathbf{A} + \\sum_{i=1}^S \\int_{V_j} \\dot{\\omega}_i \\, dV\n$$\n根据定义，质量分数之和为1，即 $\\sum_i Y_i = 1$，因此 $\\sum_i \\rho Y_i = \\rho$。由于化学反应中的质量守恒，化学生成率之和为零，即 $\\sum_i \\dot{\\omega}_i = 0$。组分通量之和构成总质量通量，即 $\\sum_i \\mathbf{F}_i = \\mathbf{F}_{\\text{total}}$。因此，该方程简化为混合物的连续性方程：\n$$\n\\frac{d}{dt} \\int_{V_j} \\rho \\, dV = - \\oint_{\\partial V_j} \\mathbf{F}_{\\text{total}} \\cdot d\\mathbf{A}\n$$\n离散这些方程的数值格式必须保持 $\\sum_i Y_i = 1$ 的性质。设时间步 $n$ 的单元平均值为 $(\\rho Y_i)_j^n$。其离散更新形式为：\n$$\nV_j (\\rho Y_i)_j^{n+1} = V_j (\\rho Y_i)_j^n - \\Delta t \\sum_{\\text{faces } f} (\\tilde{\\mathbf{F}}_i \\cdot \\mathbf{A})_f + V_j \\Delta t \\dot{\\omega}_{i,j}^n\n$$\n其中 $\\tilde{\\mathbf{F}}_i$ 是数值通量。对 $i$ 求和得到：\n$$\nV_j \\sum_i (\\rho Y_i)_j^{n+1} = V_j \\sum_i (\\rho Y_i)_j^n - \\Delta t \\sum_{f} \\left(\\sum_i \\tilde{\\mathbf{F}}_i \\cdot \\mathbf{A}\\right)_f\n$$\n如果数值通量是一致的，即 $\\sum_i \\tilde{\\mathbf{F}}_i = \\tilde{\\mathbf{F}}_{\\text{total}}$，并且总密度的格式使用 $\\tilde{\\mathbf{F}}_{\\text{total}}$，那么如果 $\\sum_i Y_{i,j}^n = 1$，则可推出 $\\sum_i Y_{i,j}^{n+1} = 1$。数值通量的一致性依赖于重构的交界面值。为了计算交界面处的通量，我们需要重构的状态，例如 $\\mathbf{Y}^{-}$ 和 $\\mathbf{Y}^{+}$。为保证一致性，这些重构状态也必须满足归一化约束。\n\n单元内的分段线性重构形式为 $\\mathbf{Y}(x) = \\mathbf{Y} + \\boldsymbol{s} \\frac{x}{\\Delta x}$，其中 $\\mathbf{Y}$ 是单元平均值，$\\boldsymbol{s}$ 是斜率向量。在 $x=\\pm\\frac{\\Delta x}{2}$ 处的交界面值为 $\\mathbf{Y}^{\\pm} = \\mathbf{Y} \\pm \\frac{1}{2}\\boldsymbol{s}$。对各分量求和：\n$$\n\\sum_i Y_i^{\\pm} = \\sum_i \\left(Y_i \\pm \\frac{1}{2} s_i\\right) = \\sum_i Y_i \\pm \\frac{1}{2} \\sum_i s_i\n$$\n鉴于单元平均值是归一化的，即 $\\sum_i Y_i = 1$，显然，$\\sum_i Y_i^{\\pm} = 1$ 的充要条件是斜率分量之和为零：$\\sum_i s_i = 0$。这是重构算法的一个关键设计约束。\n\n**2. 从第一性原理推导混合物组分度量**\n问题要求从质量分数 ($Y_i$)、分子量 ($W_i$)、压力 ($p$) 和温度 ($T$) 计算混合物分子量 ($W_{\\mathrm{mix}}$)、摩尔分数 ($X_i$) 和摩尔浓度 ($c_i$)。\n\n- **混合物分子量 ($W_{\\mathrm{mix}}$)**：根据定义，$W_{\\mathrm{mix}} = m/N$，其中 $m$ 是总质量，$N$ 是总摩尔数。总摩尔数 $N = \\sum_i N_i$，对于每个组分，摩尔数通过质量 $m_i$ 和分子量 $W_i$ 相关联：$N_i = m_i / W_i$。因此，$N = \\sum_i (m_i / W_i)$。将此代入 $W_{\\mathrm{mix}}$ 的定义中：\n$$\nW_{\\mathrm{mix}} = \\frac{m}{\\sum_i (m_i / W_i)}\n$$\n将分子和分母同除以总质量 $m$，并使用质量分数定义 $Y_i = m_i/m$，可得出所需公式：\n$$\nW_{\\mathrm{mix}} = \\left( \\sum_{i=1}^S \\frac{Y_i}{W_i} \\right)^{-1}\n$$\n\n- **摩尔分数 ($X_i$)**：根据定义，$X_i = N_i/N$。使用上述关系式：\n$$\nX_i = \\frac{m_i/W_i}{\\sum_j (m_j/W_j)}\n$$\n将分子和分母同除以总质量 $m$：\n$$\nX_i = \\frac{(m_i/m)/W_i}{\\sum_j (m_j/m)/W_j} = \\frac{Y_i/W_i}{\\sum_j (Y_j/W_j)} = \\frac{Y_i}{W_i} W_{\\mathrm{mix}}\n$$\n\n- **摩尔浓度 ($c_i$)**：根据定义，$c_i = N_i/V$，其中 $V$ 是体积。我们可以写成 $c_i = (m_i/V)/W_i = \\rho_i/W_i$。使用质量分数定义 $\\rho_i = \\rho Y_i$，我们得到 $c_i = \\rho Y_i / W_i$。混合物密度 $\\rho$ 可从混合物理想气体定律 $p = \\rho R T$ 获得，其中 $R = R_{\\mathrm{u}}/W_{\\mathrm{mix}}$。这给出 $\\rho = p W_{\\mathrm{mix}} / (R_{\\mathrm{u}} T)$。将 $\\rho$ 代入 $c_i$ 的表达式中：\n$$\nc_i = \\left( \\frac{p W_{\\mathrm{mix}}}{R_{\\mathrm{u}} T} \\right) \\frac{Y_i}{W_i}\n$$\n问题要求计算摩尔浓度之和 $\\sum_i c_i$。这是总摩尔浓度 $c = N/V$。从理想气体定律的摩尔形式 $pV = NR_{\\mathrm{u}}T$ 可以直接得出：\n$$\n\\sum_{i=1}^S c_i = c = \\frac{N}{V} = \\frac{p}{R_{\\mathrm{u}} T}\n$$\n此结果表明，对于理想气体混合物，在给定的压力和温度下，总摩尔浓度与组分无关。这个推导出的公式将被用于交界面上的计算，因为它既高效又稳健。\n\n**算法设计**\n\n对于每个单元，重构算法使用其平均状态 $\\mathbf{Y}$ 及其邻居 $\\mathbf{Y}^L$ 和 $\\mathbf{Y}^R$，分四个主要步骤进行。\n\n**步骤1：初始斜率估计**\n分量形式地估计原始斜率向量 $\\boldsymbol{s}_{\\text{raw}}$。我们定义向前差分 $\\boldsymbol{\\Delta}^+ = \\mathbf{Y}^R - \\mathbf{Y}$ 和向后差分 $\\boldsymbol{\\Delta}^- = \\mathbf{Y} - \\mathbf{Y}^L$。问题描述了一个斜率限制器，如果其参数符号不同则为零，否则取较小参数的幅值。这对应于 `minmod` 函数。初始斜率计算为 $s_{\\text{raw},i} = \\text{minmod}(\\Delta_i^-, \\Delta_i^+)$。这种选择可以防止引入新的极值。\n\n**步骤2：强制归一化约束**\n原始斜率向量 $\\boldsymbol{s}_{\\text{raw}}$ 通常不满足 $\\sum_i s_{\\text{raw},i} = 0$。为了强制满足此条件，我们将 $\\boldsymbol{s}_{\\text{raw}}$ 投影到零和向量的超平面上。这通过减去其分量的平均值来实现：\n$$\n\\boldsymbol{s}_0 = \\boldsymbol{s}_{\\text{raw}} - \\bar{s}_{\\text{raw}}, \\quad \\text{where} \\quad \\bar{s}_{\\text{raw}} = \\frac{1}{S} \\sum_{i=1}^S s_{\\text{raw},i}\n$$\n根据构造，得到的斜率向量 $\\boldsymbol{s}_0$ 满足 $\\sum_i s_{0,i} = 0$。\n\n**步骤3：强制正性约束**\n交界面值临时由 $\\mathbf{Y}^{\\pm} = \\mathbf{Y} \\pm \\frac{1}{2} \\boldsymbol{s}_0$ 给出。某些分量 $Y_i^{\\pm}$ 可能为负。为确保正性，我们将斜率向量 $\\boldsymbol{s}_0$ 统一乘以一个因子 $\\alpha \\in [0, 1]$，得到最终斜率 $\\boldsymbol{s} = \\alpha \\boldsymbol{s}_0$。因子 $\\alpha$ 必须是保证对所有 $i$ 都有 $Y_i^{\\pm} \\ge 0$ 的最大值。约束条件为：\n$$\nY_i - \\frac{1}{2} \\alpha s_{0,i} \\ge 0 \\quad \\text{and} \\quad Y_i + \\frac{1}{2} \\alpha s_{0,i} \\ge 0\n$$\n这些不等式可以重写为对 $\\alpha$ 的约束：\n- 如果 $s_{0,i} > 0$：$\\alpha \\le 2 Y_i / s_{0,i}$。\n- 如果 $s_{0,i}  0$：$\\alpha \\le -2 Y_i / s_{0,i} = 2 Y_i / |s_{0,i}|$。\n- 如果 $s_{0,i} = 0$：对 $\\alpha$ 没有约束。\n为同时满足所有这些条件，$\\alpha$ 必须小于或等于所有这些界的最小值。因此，最大的 $\\alpha$ 是：\n$$\n\\alpha = \\min \\left( 1, \\min_{i | s_{0,i} \\neq 0} \\left\\{ \\frac{2 Y_i}{|s_{0,i}|} \\right\\} \\right)\n$$\n如果所有 $s_{0,i}=0$，我们可以取 $\\alpha=1$。\n\n**步骤4：最终计算**\n使用最终斜率 $\\boldsymbol{s} = \\alpha \\boldsymbol{s}_0$，计算交界面质量分数：\n$$\n\\mathbf{Y}^{-} = \\mathbf{Y} - \\frac{1}{2}\\boldsymbol{s} \\quad \\text{and} \\quad \\mathbf{Y}^{+} = \\mathbf{Y} + \\frac{1}{2}\\boldsymbol{s}\n$$\n然后计算所需的输出量：\n1.  对两个交界面的归一化（$\\sum_i Y_i^{\\pm} \\approx 1$）和正性（$Y_i^{\\pm} \\ge 0$）进行布尔检查，使用 $10^{-12}$ 的容差。\n2.  使用推导出的公式 $W_{\\mathrm{mix}} = (\\sum_i Y_i/W_i)^{-1}$ 计算混合物分子量 $W_{\\mathrm{mix}}^{-}$ 和 $W_{\\mathrm{mix}}^{+}$。\n3.  总摩尔浓度 $\\sum_i c_i^{-}$ 和 $\\sum_i c_i^{+}$。如前所推导，假设在重构目的下 $p$ 和 $T$ 在整个单元中是常数，则二者均等于 $p/(R_{\\mathrm{u}}T)$。\n\n这个完整的、有原则的流程将为每个测试用例实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational combustion problem for all test cases.\n    It performs a constrained, piecewise-linear reconstruction of species mass fractions\n    and computes derived mixture properties at cell interfaces.\n    \"\"\"\n    R_u = 8.314462618  # Universal gas constant in J/(mol.K)\n    TOL = 1e-12\n\n    test_cases = [\n        # Case 1\n        {'W': np.array([0.0440095, 0.01801528, 0.0280134, 0.0319988]),\n         'Y_L': np.array([0.12, 0.18, 0.62, 0.08]),\n         'Y': np.array([0.10, 0.20, 0.60, 0.10]),\n         'Y_R': np.array([0.08, 0.22, 0.57, 0.13]),\n         'p': 101325.0, 'T': 1200.0},\n        # Case 2\n        {'W': np.array([0.0440095, 0.01801528, 0.0280134, 0.0319988]),\n         'Y_L': np.array([0.68, 0.30, 0.02, 0.00]),\n         'Y': np.array([0.70, 0.29, 0.01, 0.00]),\n         'Y_R': np.array([0.75, 0.24, 0.01, 0.00]),\n         'p': 500000.0, 'T': 2500.0},\n        # Case 3\n        {'W': np.array([0.00201588, 0.0280134]),\n         'Y_L': np.array([0.98, 0.02]),\n         'Y': np.array([1.00, 0.00]),\n         'Y_R': np.array([0.99, 0.01]),\n         'p': 200000.0, 'T': 300.0},\n        # Case 4\n        {'W': np.array([0.0440095, 0.01801528, 0.0280134, 0.0319988]),\n         'Y_L': np.array([0.20, 0.20, 0.40, 0.20]),\n         'Y': np.array([0.25, 0.25, 0.25, 0.25]),\n         'Y_R': np.array([0.30, 0.10, 0.20, 0.40]),\n         'p': 300000.0, 'T': 1800.0},\n    ]\n\n    all_results = []\n\n    def minmod(a, b):\n        \"\"\"\n        Component-wise minmod function. Returns zero if signs differ,\n        otherwise returns the argument with the smaller magnitude.\n        \"\"\"\n        # A numerically stable and concise way to implement minmod for vectors.\n        # np.sign(0) is 0, which handles cases with zero correctly.\n        return 0.5 * (np.sign(a) + np.sign(b)) * np.minimum(np.abs(a), np.abs(b))\n\n    for case in test_cases:\n        W = case['W']\n        Y_L, Y, Y_R = case['Y_L'], case['Y'], case['Y_R']\n        p, T = case['p'], case['T']\n\n        # Step 1: Initial slope estimation\n        delta_minus = Y - Y_L\n        delta_plus = Y_R - Y\n        s_raw = minmod(delta_minus, delta_plus)\n\n        # Step 2: Enforce zero-sum constraint\n        s_mean = np.mean(s_raw)\n        s0 = s_raw - s_mean\n\n        # Step 3: Enforce positivity constraint\n        alpha = 1.0\n        s0_abs = np.abs(s0)\n        \n        # Calculate ratios only where s0 is non-zero to avoid division by zero\n        # The tolerance in the mask is to robustly handle floating point numbers near zero.\n        non_zero_mask = s0_abs > TOL\n        \n        if np.any(non_zero_mask):\n            ratios = 2.0 * Y[non_zero_mask] / s0_abs[non_zero_mask]\n            # There could be cases where Y_i is near zero, resulting in a very small alpha.\n            # Handle Y_i = 0 leading to alpha_i = 0 correctly.\n            alpha_max = np.min(ratios)\n            alpha = min(1.0, alpha_max)\n        \n        # Final slope after positivity enforcement\n        s = alpha * s0\n\n        # Step 4: Compute final quantities\n        Y_minus = Y - 0.5 * s\n        Y_plus = Y + 0.5 * s\n\n        # Constraint checks\n        b1 = np.isclose(np.sum(Y_minus), 1.0, atol=TOL, rtol=0)\n        b2 = np.isclose(np.sum(Y_plus), 1.0, atol=TOL, rtol=0)\n        b3 = np.all(Y_minus >= -TOL)\n        b4 = np.all(Y_plus >= -TOL)\n\n        # Mixture molecular weights\n        # Handle potential division by zero if a W_i is not provided or zero, though not in test data\n        W_mix_minus = 1.0 / np.sum(Y_minus / W)\n        W_mix_plus = 1.0 / np.sum(Y_plus / W)\n\n        # Total molar concentrations\n        # From derivation, sum(c_i) = p / (R_u * T) for an ideal gas mixture.\n        # This is independent of composition.\n        sum_c_minus = p / (R_u * T)\n        sum_c_plus = p / (R_u * T)\n\n        # Store results for this case\n        case_results = [\n            b1, b2, b3, b4, \n            W_mix_minus, W_mix_plus, \n            sum_c_minus, sum_c_plus\n        ]\n        all_results.append(case_results)\n\n    # Format the final output as a string representing a list of lists.\n    def repr_list(lst):\n        return repr(lst).replace(\" \", \"\")\n\n    print(f\"[{','.join(map(repr_list, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}