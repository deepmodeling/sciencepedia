{
    "hands_on_practices": [
        {
            "introduction": "在反应流模拟中，一个核心挑战是如何在巨大的计算域中准确捕捉微小的物理结构，例如火焰锋面。自适应网格加密（AMR）技术通过仅在需要高分辨率的区域加密网格，为这一挑战提供了高效的解决方案。本练习将通过一个基本计算，展示如何确定捕捉特定物理特征所需的加密层级，从而将物理尺度要求与网格设计直接联系起来 。",
            "id": "4038671",
            "problem": "一种用于计算燃烧学的自适应网格加密算法被应用于二维预混反应流，以解析火焰锋面周围的薄反应区。该算法使用各向同性 $2{:}1$ 加密，并维持一个 $2{:}1$ 的网格拓扑结构（相邻网格单元的尺寸差异最多为两倍），以确保在守恒有限体积离散化中，粗细网格界面上的通量交换是稳定的。在基础网格上，均匀的网格单元宽度为 $\\Delta x_{0} = 1\\ \\mathrm{mm}$。加密准则要求火焰附近的局部网格单元宽度 $\\Delta x$ 必须减小至最多 $\\Delta x_{\\mathrm{t}} = 62.5\\ \\mu\\mathrm{m}$，以充分解析反应层的厚度。\n\n从 $2{:}1$ 加密的基本定义出发，即每个加密等级将局部网格单元宽度减半，推导所需的最小整数加密等级数 $L$，以使加密后的局部网格单元宽度满足 $\\Delta x \\leq \\Delta x_{\\mathrm{t}}$。计算 $L$ 并报告所需的等级数。最终答案以无单位的纯数字表示。",
            "solution": "该问题经验证是合理且适定的。所提出的概念——自适应网格加密 (AMR)、$2{:}1$ 网格拓扑以及用于解析反应区的加密准则——在计算燃烧学领域都是标准的且有科学依据的。给定的数值是物理上现实的，并且问题陈述是自包含的、客观的且无歧义的，从而导向一个唯一的解。\n\n设 $\\Delta x_0$ 为基础网格上的均匀网格单元宽度，给定为 $\\Delta x_0 = 1\\ \\mathrm{mm}$。\n设 $L$ 为所应用的整数加密等级数。问题陈述该算法使用各向同性 $2{:}1$ 加密，并关键地将其定义为“每个加密等级将局部网格单元宽度减半”。\n\n我们可以将在给定加密等级 $L$ 时的网格单元宽度（记为 $\\Delta x_L$）表示为基础网格单元宽度 $\\Delta x_0$ 的函数。\n对于 $L=0$（基础网格），网格单元宽度为 $\\Delta x_0$。\n对于 $L=1$，网格单元宽度为 $\\Delta x_1 = \\frac{\\Delta x_0}{2}$。\n对于 $L=2$，网格单元宽度为 $\\Delta x_2 = \\frac{\\Delta x_1}{2} = \\frac{(\\Delta x_0/2)}{2} = \\frac{\\Delta x_0}{2^2}$。\n\n通过归纳法，经过 $L$ 级加密后的网格单元宽度遵循以下几何级数：\n$$ \\Delta x_L = \\frac{\\Delta x_0}{2^L} $$\n\n加密准则要求最终的局部网格单元宽度（我们记为 $\\Delta x_L$）必须小于或等于目标宽度 $\\Delta x_{\\mathrm{t}}$。问题中给出 $\\Delta x_{\\mathrm{t}} = 62.5\\ \\mu\\mathrm{m}$。\n这个要求可以表示为以下不等式：\n$$ \\Delta x_L \\leq \\Delta x_{\\mathrm{t}} $$\n\n将 $\\Delta x_L$ 的表达式代入此不等式，得到：\n$$ \\frac{\\Delta x_0}{2^L} \\leq \\Delta x_{\\mathrm{t}} $$\n\n我们需要求解满足此条件的最小整数 $L$。为此，我们首先重排不等式以分离出含 $L$ 的项：\n$$ 2^L \\geq \\frac{\\Delta x_0}{\\Delta x_{\\mathrm{t}}} $$\n\n在计算比值之前，我们必须将两个量表示为一致的单位。我们将两者都转换为微米 ($\\mu\\mathrm{m}$)。\n给定：\n$\\Delta x_0 = 1\\ \\mathrm{mm} = 1000\\ \\mu\\mathrm{m}$\n$\\Delta x_{\\mathrm{t}} = 62.5\\ \\mu\\mathrm{m}$\n\n现在，我们计算比值：\n$$ \\frac{\\Delta x_0}{\\Delta x_{\\mathrm{t}}} = \\frac{1000\\ \\mu\\mathrm{m}}{62.5\\ \\mu\\mathrm{m}} = \\frac{1000}{62.5} $$\n为简化分数，我们可以将分子和分母同乘以 $10$：\n$$ \\frac{10000}{625} $$\n注意到 $625 = 25^2 = 5^4$ 且 $10000 = 100^2 = (10^2)^2 = 10^4 = (2 \\times 5)^4 = 2^4 \\times 5^4$，我们有：\n$$ \\frac{10000}{625} = \\frac{2^4 \\times 5^4}{5^4} = 2^4 = 16 $$\n\n将此值代回关于 $L$ 的不等式中：\n$$ 2^L \\geq 16 $$\n\n为了求 $L$，我们可以对不等式两边取以 $2$ 为底的对数。由于当 $x > 0$ 时 $\\log_2(x)$ 是一个单调递增函数，不等式的方向保持不变。\n$$ \\log_2(2^L) \\geq \\log_2(16) $$\n$$ L \\geq \\log_2(16) $$\n因为 $2^4 = 16$，所以我们有 $\\log_2(16) = 4$。\n因此，不等式变为：\n$$ L \\geq 4 $$\n\n问题要求的是最小整数加密等级数 $L$。由于 $L$ 必须是整数且 $L$ 必须大于或等于 $4$，所以 $L$ 的最小整数值为 $4$。\n这意味着需要至少 $4$ 个加密等级才能将网格单元宽度从 $1\\ \\mathrm{mm}$ 减小到 $62.5\\ \\mu\\mathrm{m}$ 或以下。\n每个等级的网格单元尺寸如下：\n等级 $0$：$1000\\ \\mu\\mathrm{m}$\n等级 $1$：$500\\ \\mu\\mathrm{m}$\n等级 $2$：$250\\ \\mu\\mathrm{m}$\n等级 $3$：$125\\ \\mu\\mathrm{m}$\n等级 $4$：$62.5\\ \\mu\\mathrm{m}$\n在 $L=4$ 时，加密后的网格单元宽度为 $\\Delta x_4 = 62.5\\ \\mu\\mathrm{m}$，满足条件 $\\Delta x_4 \\leq 62.5\\ \\mu\\mathrm{m}$。",
            "answer": "$$ \\boxed{4} $$"
        },
        {
            "introduction": "除了火焰锋面，在靠近壁面的区域，由于粘性和热效应，同样存在着剧烈的物理量梯度。本练习将引导你设计一个附面层网格，这是计算流体力学中一项常见的关键任务 。你将学习如何使用等比数列来构建一个拉伸的非均匀网格，这种方法能够在壁面附近实现高分辨率，并平滑地过渡到远场的粗网格，从而有效地平衡精度与计算成本。",
            "id": "4038646",
            "problem": "在反应流燃烧室中，一个平面的、与坐标轴对齐的壁面需要在壁面法线方向上使用贴体边界层网格，以解析近壁处温度和物质组分的陡峭梯度。考虑一个邻近壁面的一维层堆叠，该堆叠将沿切向拉伸，以形成整个流场的近壁网格。该堆叠采用层厚的等比数列，其增长因子为常数 $g>1$，使得第 $k$ 层的厚度为 $\\,\\Delta y_k\\,$，并满足关系式 $\\,\\Delta y_k = \\Delta y_1\\, g^{\\,k-1}\\,$，其中 $\\,k=1,2,\\dots,N\\,$。边界层网格的总厚度被指定为 $\\,\\delta\\,$，它必须等于这 $N$ 个层厚度之和。这种构造方法在计算流体力学 (CFD) 的反应流模拟中被广泛使用，旨在实现从粘性子层向外的受控扩张，同时保持光滑的网格拓扑。\n\n给定层数 $\\,N=20\\,$，增长因子 $\\,g=1.2\\,$，以及目标总厚度 $\\,\\delta = 2\\ \\mathrm{mm}\\,$，请基于等比数列和层厚度之和等于 $\\,\\delta\\,$ 的约束条件，从第一性原理推导 $\\,\\Delta y_1\\,$ 和 $\\,\\Delta y_N\\,$ 的表达式。然后，使用指定参数对这些表达式进行数值计算。\n\n以 $\\mathrm{mm}$ 为单位表示 $\\,\\Delta y_1\\,$ 和 $\\,\\Delta y_N\\,$，并将两个值都四舍五入到四位有效数字。最终答案必须只包含这两个数字，形式为一个不带单位的单行矩阵。",
            "solution": "该问题陈述具有科学依据、适定且客观。它描述了一种在计算流体力学中生成边界层网格的标准方法，即使用等比数列来确定层厚度。所有必需的参数都已提供，没有矛盾或含糊之处。因此，该问题是有效的，可以求解。\n\n问题的核心在于边界层网格的总厚度 $\\delta$ 与各个层厚度 $\\Delta y_k$ 之间的关系。总厚度是 $N$ 个单层厚度之和：\n$$\n\\delta = \\sum_{k=1}^{N} \\Delta y_k\n$$\n\n问题陈述指出，层厚度遵循一个具有恒定增长因子 $g$ 的等比数列。第 $k$ 层的厚度 $\\Delta y_k$ 由以下关系式给出：\n$$\n\\Delta y_k = \\Delta y_1 g^{k-1}\n$$\n其中 $\\Delta y_1$ 是邻近壁面的第一层的厚度。\n\n为了找到 $\\Delta y_1$ 的表达式，我们将等比数列公式代入 $\\delta$ 的求和式中：\n$$\n\\delta = \\sum_{k=1}^{N} \\left( \\Delta y_1 g^{k-1} \\right)\n$$\n\n由于 $\\Delta y_1$ 相对于求和指数 $k$ 是一个常数，我们可以将其提取出来：\n$$\n\\delta = \\Delta y_1 \\sum_{k=1}^{N} g^{k-1}\n$$\n\n这个求和项是一个有限等比级数。设指数为 $j = k-1$。当 $k$ 从 $1$ 变为 $N$ 时，$j$ 从 $0$ 变为 $N-1$。该和可以重写为：\n$$\n\\sum_{j=0}^{N-1} g^j = g^0 + g^1 + g^2 + \\dots + g^{N-1}\n$$\n\n首项为 $a$、公比为 $r$、项数为 $n$ 的有限等比级数的求和公式是 $S_n = a \\frac{r^n - 1}{r-1}$。在我们的例子中，首项是 $g^0 = 1$，公比是 $g$，共有 $N$ 项。因此，和为：\n$$\n\\sum_{j=0}^{N-1} g^j = \\frac{g^N - 1}{g - 1}\n$$\n此公式成立，因为问题规定 $g > 1$，所以分母 $g-1$ 非零。\n\n将此结果代回 $\\delta$ 的方程中：\n$$\n\\delta = \\Delta y_1 \\left( \\frac{g^N - 1}{g - 1} \\right)\n$$\n\n我们现在可以解出第一层的厚度 $\\Delta y_1$：\n$$\n\\Delta y_1 = \\delta \\left( \\frac{g - 1}{g^N - 1} \\right)\n$$\n这就是 $\\Delta y_1$ 的通用表达式。\n\n接下来，我们推导第 $N$ 层（最外层）厚度 $\\Delta y_N$ 的表达式。根据等比数列的定义：\n$$\n\\Delta y_N = \\Delta y_1 g^{N-1}\n$$\n\n代入我们刚刚为 $\\Delta y_1$ 推导出的表达式：\n$$\n\\Delta y_N = \\left[ \\delta \\left( \\frac{g - 1}{g^N - 1} \\right) \\right] g^{N-1}\n$$\n这就是 $\\Delta y_N$ 的通用表达式。\n\n现在我们使用给定的参数 $N=20$、$g=1.2$ 和 $\\delta = 2\\ \\mathrm{mm}$ 对这些表达式进行数值计算。\n\n首先，我们计算 $g^N - 1$ 这一项：\n$$\ng^N - 1 = (1.2)^{20} - 1\n$$\n$$\n(1.2)^{20} \\approx 38.3375999\n$$\n$$\ng^N - 1 \\approx 38.3375999 - 1 = 37.3375999\n$$\n\n现在计算 $\\Delta y_1$：\n$$\n\\Delta y_1 = 2 \\left( \\frac{1.2 - 1}{(1.2)^{20} - 1} \\right) = 2 \\left( \\frac{0.2}{37.3375999} \\right) = \\frac{0.4}{37.3375999}\n$$\n$$\n\\Delta y_1 \\approx 0.01071300\\ \\mathrm{mm}\n$$\n四舍五入到四位有效数字，我们得到 $\\Delta y_1 = 0.01071\\ \\mathrm{mm}$。\n\n最后，计算 $\\Delta y_N$：\n$$\n\\Delta y_N = \\Delta y_1 g^{N-1} = \\Delta y_1 (1.2)^{19}\n$$\n我们计算 $(1.2)^{19} = (1.2)^{20} / 1.2 \\approx 38.3375999 / 1.2 \\approx 31.9479999$。\n$$\n\\Delta y_N \\approx (0.01071300) \\times (31.9479999) \\approx 0.3422619\\ \\mathrm{mm}\n$$\n四舍五入到四位有效数字，我们得到 $\\Delta y_N = 0.3423\\ \\mathrm{mm}$。\n\n第一层和最后一层厚度的结果是 $\\Delta y_1 \\approx 0.01071\\ \\mathrm{mm}$ 和 $\\Delta y_N \\approx 0.3423\\ \\mathrm{mm}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.01071  0.3423\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "当我们构建了复杂的曲线坐标网格后，必须确保数值求解器能正确地“理解”这些几何信息。本项高级练习将探讨一个精妙而深刻的数值原则——几何守恒律（Geometric Conservation Law, GCL）。你将通过比较两种不同的离散格式，亲身体验不恰当的网格度量项计算如何在均匀流场中引入虚假的“源项”，从而破坏解的物理真实性。这个练习揭示了在复杂几何上保证数值模拟精度的核心要求。",
            "id": "4038601",
            "problem": "设计并分析一个用于表示喷管状通道的二维映射结构化网格的曲线度量项的二阶精度离散近似，并展示其在保持均匀流而不引入伪数值源方面的效果。在一个从计算坐标 $(\\xi,\\eta)\\in[0,1]\\times[0,1]$ 到形式为 $x = x(\\xi,\\eta)$ 和 $y = y(\\xi,\\eta)$ 的物理坐标 $(x,y)$ 的通用曲线坐标映射下进行工作。考虑一个均匀物理速度场 $\\mathbf{u} = (u,v)$ 作用于一个通过平流输运的均匀标量 $q$ 的散度。使用以下基本依据。\n\n- 从守恒的坐标变换散度恒等式出发：如果 $J$ 表示雅可比行列式 $J = x_{\\xi} y_{\\eta} - x_{\\eta} y_{\\xi}$，且 $\\mathbf{a}^{\\xi} = (y_{\\eta},-x_{\\eta})$, $\\mathbf{a}^{\\eta} = (-y_{\\xi}, x_{\\xi})$ 是满足 $J \\nabla = \\mathbf{a}^{\\xi} \\partial_{\\xi} + \\mathbf{a}^{\\eta} \\partial_{\\eta}$ 的度量向量，那么连续度量恒等式为 $\\partial_{\\xi} \\mathbf{a}^{\\xi} + \\partial_{\\eta} \\mathbf{a}^{\\eta} = \\mathbf{0}$，它保证了均匀状态 $q=\\text{const}$ 和 $\\mathbf{u}=\\text{const}$ 在变换坐标系下会产生零散度。\n- 假设一个间距为 $\\Delta \\xi$ 和 $\\Delta \\eta$ 的均匀计算网格。\n\n您的任务是为均匀状态建立两种关于逆变通量散度的全离散近似：\n\n- 一致的中心差分格式：使用相同的二阶中心差分算子来近似所有导数 $x_{\\xi}$、$x_{\\eta}$、$y_{\\xi}$、$y_{\\eta}$ 以及散度 $\\partial_{\\xi}(\\cdot)$、$\\partial_{\\eta}(\\cdot)$。\n- 一个故意不一致的混合模板格式：用 $\\xi$ 方向的前向差分近似 $x_{\\xi}$ 和 $y_{\\xi}$，用 $\\eta$ 方向的后向差分近似 $x_{\\eta}$ 和 $y_{\\eta}$，并用中心差分近似外层散度。\n\n对于每种格式，计算离散残差\n$$\nR = D_{\\xi}\\big(u\\, y_{\\eta} - v\\, x_{\\eta}\\big) + D_{\\eta}\\big(-u\\, y_{\\xi} + v\\, x_{\\xi}\\big),\n$$\n其中 $D_{\\xi}$ 和 $D_{\\eta}$ 是所选的离散差分算子，而 $(x_{\\xi},x_{\\eta},y_{\\xi},y_{\\eta})$ 是对应的离散度量近似。在模板被完全定义的内部网格点上计算 $R$。将伪源的大小度量为内部点上的无穷范数，\n$$\n\\|R\\|_{\\infty} = \\max_{i,j} |R_{i,j}|,\n$$\n当用 $q$ 的常数尺度进行归一化并将 $u$ 和 $v$ 作为固定常数时，该范数是无量纲的。\n\n使用一个在 $\\xi$ 方向上有 $N_{\\xi}$ 个点、在 $\\eta$ 方向上有 $N_{\\eta}$ 个点的结构化计算网格来定义喷管状映射。使用一个光滑的沿中心线对齐的通道映射\n- 喷管：$x(\\xi,\\eta) = L\\,\\xi$, $y(\\xi,\\eta) = \\eta\\, h(x(\\xi,\\eta))$，其半高为\n$$\nh(x) = y_{\\text{in}} - \\big(y_{\\text{in}} - y_{\\text{th}}\\big)\\,\\exp\\big(-\\beta\\,(x-x_t)^2\\big) + s\\,(x-x_t),\n$$\n其中 $L$, $y_{\\text{in}}$, $y_{\\text{th}}$, $\\beta$, $x_t$ 和 $s$ 是选定的正常数，以确保对于 $x\\in[0,L]$ 有 $h(x)>0$。\n- 矩形：$x(\\xi,\\eta) = L\\,\\xi$, $y(\\xi,\\eta) = \\eta\\, H$，其中 $H$ 是一个正常数。\n- 扭曲喷管：$x(\\xi,\\eta) = L\\,\\xi$, $y(\\xi,\\eta) = \\eta\\, h(x(\\xi,\\eta)) + \\alpha \\sin(2\\pi \\xi)\\sin(2\\pi \\eta)$，其中 $\\alpha$ 是一个小的正常数。\n\n对于所有情况，使用具有恒定 $(u,v)$ 和恒定 $q$ 的均匀流，以便任何非零离散残差仅由度量离散化误差引起，而非物理原因。角度以弧度为单位。所有结果都应通过返回所定义的 $\\|R\\|_{\\infty}$ 作为不带物理单位的纯数字来报告。\n\n实现这两种格式，为以下每个测试用例在内部网格上计算每种格式的 $\\|R\\|_{\\infty}$，并在一行中将所有结果按下方确切顺序输出为方括号括起来的逗号分隔列表，其中每个测试贡献两个数值：第一个用于不一致的混合模板格式，第二个用于一致的中心差分格式。\n\n- 测试 A (光滑喷管，细网格): $L = 1$, $y_{\\text{in}} = 0.5$, $y_{\\text{th}} = 0.2$, $\\beta = 25$, $x_t = 0.5$, $s = 0.15$, $N_{\\xi} = 101$, $N_{\\eta} = 61$, $u = 0.7$, $v = 0.05$。\n- 测试 B (光滑喷管，粗网格): $L = 1$, $y_{\\text{in}} = 0.5$, $y_{\\text{th}} = 0.2$, $\\beta = 25$, $x_t = 0.5$, $s = 0.15$, $N_{\\xi} = 21$, $N_{\\eta} = 11$, $u = 0.7$, $v = 0.05$。\n- 测试 C (矩形，细网格): $L = 1$, $H = 0.4$, $N_{\\xi} = 101$, $N_{\\eta} = 61$, $u = 0.7$, $v = 0.05$。\n- 测试 D (扭曲喷管，细网格): $L = 1$, $y_{\\text{in}} = 0.5$, $y_{\\text{th}} = 0.2$, $\\beta = 25$, $x_t = 0.5$, $s = 0.15$, $\\alpha = 0.02$, $N_{\\xi} = 101$, $N_{\\eta} = 61$, $u = 0.7$, $v = 0.05$。\n\n科学真实性约束。\n\n- 使用上述光滑映射，以确保对于所有给定的参数，度量导数都存在且有界。\n- 将残差计算限制在内部点，以便所有算子都有良好定义，无需边界封闭处理。\n\n您的程序应生成单行输出，其中包含按确切顺序排列的结果，格式为方括号括起来的逗号分隔列表（例如，$[r_1,r_2,\\dots]$）\n$$\n[\\|R\\|_{\\infty}^{\\text{mixed},A},\\ \\|R\\|_{\\infty}^{\\text{central},A},\\ \\|R\\|_{\\infty}^{\\text{mixed},B},\\ \\|R\\|_{\\infty}^{\\text{central},B},\\ \\|R\\|_{\\infty}^{\\text{mixed},C},\\ \\|R\\|_{\\infty}^{\\text{central},C},\\ \\|R\\|_{\\infty}^{\\text{mixed},D},\\ \\|R\\|_{\\infty}^{\\text{central},D} ].\n$$\n\n推导和算法设计必须从上述基本定律和定义出发，不得假定超出这些范围的任何简化公式。分析必须清楚地说明正在计算什么，为什么均匀状态应在解析上得到保持，以及离散中心度量公式如何以二阶精度强制执行度量恒等式的离散模拟，而不一致的混合模板公式则违反了该模拟，并在弯曲网格上产生非零的 $\\|R\\|_{\\infty}$。",
            "solution": "问题要求设计和分析两种在曲线坐标系中对度量项的离散近似方法，旨在验证均匀流场的保持性。这是计算流体动力学中的一个基本概念，称为满足几何守恒律（Geometric Conservation Law, GCL）。不满足GCL会引入伪数值源项，这可能会破坏解的准确性，尤其是在非均匀或移动网格上。\n\n我们从散度算子从物理坐标 $(x,y)$ 到计算坐标 $(\\xi,\\eta)$ 的变换开始。映射由 $x=x(\\xi,\\eta)$ 和 $y=y(\\xi,\\eta)$ 给出。向量场 $\\mathbf{F}$ 的散度在变换坐标系中以守恒形式给出：\n$$\n\\nabla \\cdot \\mathbf{F} = \\frac{1}{J} \\left( \\frac{\\partial (J F^\\xi)}{\\partial \\xi} + \\frac{\\partial (J F^\\eta)}{\\partial \\eta} \\right)\n$$\n其中 $J = x_{\\xi} y_{\\eta} - x_{\\eta} y_{\\xi}$ 是变换的雅可比行列式，$F^\\xi$ 和 $F^\\eta$ 是 $\\mathbf{F}$ 的逆变分量。对于一个平流通量 $\\mathbf{F} = q\\mathbf{u}$，其中标量 $q$ 和速度向量 $\\mathbf{u}=(u,v)$ 均为常数，其逆变通量由以下公式给出：\n$$\nJ F^\\xi = q(u y_{\\eta} - v x_{\\eta})\n$$\n$$\nJ F^\\eta = q(u (-y_{\\xi}) + v x_{\\xi})\n$$\n问题考虑了通量向量的散度，对于常数 $q$（不失一般性，可设为1）和常数 $(u,v)$，该散度正比于：\n$$\nR_{\\text{cont}} = \\frac{\\partial}{\\partial \\xi}\\big(u y_{\\eta} - v x_{\\eta}\\big) + \\frac{\\partial}{\\partial \\eta}\\big(-u y_{\\xi} + v x_{\\xi}\\big)\n$$\n由于 $u$ 和 $v$ 是常数，它们可以从导数中提出：\n$$\nR_{\\text{cont}} = u \\left( \\frac{\\partial y_{\\eta}}{\\partial \\xi} - \\frac{\\partial y_{\\xi}}{\\partial \\eta} \\right) - v \\left( \\frac{\\partial x_{\\eta}}{\\partial \\xi} - \\frac{\\partial x_{\\xi}}{\\partial \\eta} \\right)\n$$\n如果映射函数 $x(\\xi,\\eta)$ 和 $y(\\xi,\\eta)$ 是二阶连续可微的，则关于混合偏导数相等的克莱罗定理（Clairaut's theorem）适用：\n$$\n\\frac{\\partial^2 y}{\\partial \\xi \\partial \\eta} = \\frac{\\partial^2 y}{\\partial \\eta \\partial \\xi} \\quad \\text{and} \\quad \\frac{\\partial^2 x}{\\partial \\xi \\partial \\eta} = \\frac{\\partial^2 x}{\\partial \\eta \\partial \\xi}\n$$\n这意味着 $R_{\\text{cont}}$ 表达式中括号内的两项都为零。因此，对于任何足够光滑的网格映射，均匀流场的散度恒为零。这就是连续度量恒等式。一个数值格式必须保持此恒等式的离散模拟，才能被认为是“自由流保持”（freestream-preserving）的。\n\n我们的任务是为两种不同的格式计算离散残差 $R = D_{\\xi}(F^{\\xi}) + D_{\\eta}(F^{\\eta})$，其中 $D_{\\xi}$ 和 $D_{\\eta}$ 是离散差分算子。网格在计算空间中是均匀的，间距为 $\\Delta\\xi = 1/(N_\\xi - 1)$ 和 $\\Delta\\eta = 1/(N_\\eta - 1)$。我们在网格节点 $(i,j)$ 上定义离散算子：\n- 二阶中心差分：$D_{\\xi,c}(f)_{i,j} = \\frac{f_{i+1,j} - f_{i-1,j}}{2\\Delta\\xi}$ 和 $D_{\\eta,c}(f)_{i,j} = \\frac{f_{i,j+1} - f_{i,j-1}}{2\\Delta\\eta}$。\n- 前向差分：$D_{\\xi,f}(f)_{i,j} = \\frac{f_{i+1,j} - f_{i,j}}{\\Delta\\xi}$。\n- 后向差分：$D_{\\eta,b}(f)_{i,j} = \\frac{f_{i,j} - f_{i,j-1}}{\\Delta\\eta}$。\n\n**格式1：一致的中心差分格式**\n该格式对所有导数（包括内部度量项 $x_\\xi, x_\\eta, \\dots$ 和外部散度算子 $D_\\xi, D_\\eta$）使用相同的二阶中心差分算子。离散残差为：\n$$\nR^{\\text{central}}_{i,j} = u \\left( D_{\\xi,c}((y_{\\eta})_c)_{i,j} - D_{\\eta,c}((y_{\\xi})_c)_{i,j} \\right) - v \\left( D_{\\xi,c}((x_{\\eta})_c)_{i,j} - D_{\\eta,c}((x_{\\xi})_c)_{i,j} \\right)\n$$\n让我们分析其中一项。算子 $D_{\\xi,c}((f_{\\eta})_c)$ 应用于网格函数 $f_{i,j}$ 的结果是：\n$$\nD_{\\xi,c}(D_{\\eta,c}(f))_{i,j} = \\frac{1}{2\\Delta\\xi} \\left( \\frac{f_{i+1,j+1}-f_{i+1,j-1}}{2\\Delta\\eta} - \\frac{f_{i-1,j+1}-f_{i-1,j-1}}{2\\Delta\\eta} \\right) = \\frac{f_{i+1,j+1}-f_{i+1,j-1}-f_{i-1,j+1}+f_{i-1,j-1}}{4\\Delta\\xi\\Delta\\eta}\n$$\n类似地，算子 $D_{\\eta,c}((f_{\\xi})_c)$ 的结果是：\n$$\nD_{\\eta,c}(D_{\\xi,c}(f))_{i,j} = \\frac{1}{2\\Delta\\eta} \\left( \\frac{f_{i+1,j+1}-f_{i-1,j+1}}{2\\Delta\\xi} - \\frac{f_{i+1,j-1}-f_{i-1,j-1}}{2\\Delta\\xi} \\right) = \\frac{f_{i+1,j+1}-f_{i-1,j+1}-f_{i+1,j-1}+f_{i-1,j-1}}{4\\Delta\\xi\\Delta\\eta}\n$$\n这两个表达式是相同的。因此，离散中心差分算子是可交换的：$D_{\\xi,c}D_{\\eta,c} = D_{\\eta,c}D_{\\xi,c}$。这是克莱罗定理的离散模拟。因此，对于任何网格，$R^{\\text{central}}_{i,j}$ 将在机器浮点精度范围内为零，从而离散地满足GCL。残差在内部区域 `[2:-2, 2:-2]` 上进行评估，以确保每个维度上的5点模板都在网格内部。\n\n**格式2：不一致的混合模板格式**\n该格式对度量项使用前向/后向差分，对外层散度使用中心差分：\n$$\nR^{\\text{mixed}}_{i,j} = u \\left( D_{\\xi,c}((y_{\\eta})_b)_{i,j} - D_{\\eta,c}((y_{\\xi})_f)_{i,j} \\right) - v \\left( D_{\\xi,c}((x_{\\eta})_b)_{i,j} - D_{\\eta,c}((x_{\\xi})_f)_{i,j} \\right)\n$$\n让我们分析离散混合导数算子。\n$$\nD_{\\eta,c}((f_{\\xi})_f)_{i,j} = \\frac{1}{2\\Delta\\eta}\\left( \\frac{f_{i+1,j+1}-f_{i,j+1}}{\\Delta\\xi} - \\frac{f_{i+1,j-1}-f_{i,j-1}}{\\Delta\\xi} \\right) = \\frac{f_{i+1,j+1}-f_{i,j+1}-f_{i+1,j-1}+f_{i,j-1}}{2\\Delta\\xi\\Delta\\eta}\n$$\n$$\nD_{\\xi,c}((f_{\\eta})_b)_{i,j} = \\frac{1}{2\\Delta\\xi}\\left( \\frac{f_{i+1,j}-f_{i+1,j-1}}{\\Delta\\eta} - \\frac{f_{i-1,j}-f_{i-1,j-1}}{\\Delta\\eta} \\right) = \\frac{f_{i+1,j}-f_{i+1,j-1}-f_{i-1,j}+f_{i-1,j-1}}{2\\Delta\\xi\\Delta\\eta}\n$$\n这两个表达式不相同。它们的模板不同，因此离散算子不可交换。这种不一致性意味着，在映射的二阶导数不为零的弯曲网格上，它们的差通常不为零。这导致非零的残差 $R^{\\text{mixed}}_{i,j}$，其作用如同一个伪源项。一个例外是简单的笛卡尔网格或剪切网格，其中 $x$ 和 $y$ 是 $\\xi, \\eta$ 的线性函数，在这种情况下，所有二阶导数都为零，残差将消失。该格式的残差在内部区域 `[1:-1, 1:-1]` 上进行评估。\n\n计算过程包括：\n1. 对于每个测试用例，定义网格参数并生成物理网格坐标 $(x_{i,j}, y_{i,j})$。\n2. 对于每种格式：\n   a. 计算整个网格上的离散度量项场（例如，$(x_\\xi)_{f}$，$(y_\\eta)_{b}$ 等）。\n   b. 使用这些度量场计算逆变通量场 $F^\\xi$ 和 $F^\\eta$。\n   c. 将适当的离散散度算子 $D_\\xi$ 和 $D_\\eta$ 应用于通量场，以获得残差场 $R_{i,j}$。\n3. 对于每种格式，在其各自有效的内部域上找到残差的最大绝对值，$\\|R\\|_{\\infty} = \\max_{i,j} |R_{i,j}|$。\n\n该分析预测，一致的中心差分格式将对所有测试用例产生接近机器精度的残差，而不一致的混合模板格式将对弯曲网格（测试 A、B、D）产生非零残差，并对矩形网格（测试 C）产生接近零的残差。不一致格式的误差大小预计会随着网格加密而减小（比较测试 B 和测试 A）。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to compute residuals for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test A (smooth nozzle, fine grid)\n        {'type': 'nozzle', 'L': 1.0, 'y_in': 0.5, 'y_th': 0.2, 'beta': 25.0,\n         'x_t': 0.5, 's': 0.15, 'alpha': 0.0, 'H': 0.0, 'N_xi': 101, 'N_eta': 61,\n         'u': 0.7, 'v': 0.05},\n        # Test B (smooth nozzle, coarse grid)\n        {'type': 'nozzle', 'L': 1.0, 'y_in': 0.5, 'y_th': 0.2, 'beta': 25.0,\n         'x_t': 0.5, 's': 0.15, 'alpha': 0.0, 'H': 0.0, 'N_xi': 21, 'N_eta': 11,\n         'u': 0.7, 'v': 0.05},\n        # Test C (rectangular, fine grid)\n        {'type': 'rectangular', 'L': 1.0, 'y_in': 0.0, 'y_th': 0.0, 'beta': 0.0,\n         'x_t': 0.0, 's': 0.0, 'alpha': 0.0, 'H': 0.4, 'N_xi': 101, 'N_eta': 61,\n         'u': 0.7, 'v': 0.05},\n        # Test D (skewed nozzle, fine grid)\n        {'type': 'skewed', 'L': 1.0, 'y_in': 0.5, 'y_th': 0.2, 'beta': 25.0,\n         'x_t': 0.5, 's': 0.15, 'alpha': 0.02, 'H': 0.0, 'N_xi': 101, 'N_eta': 61,\n         'u': 0.7, 'v': 0.05},\n    ]\n\n    results = []\n\n    for params in test_cases:\n        # Unpack parameters\n        N_xi, N_eta = params['N_xi'], params['N_eta']\n        L, H, u, v = params['L'], params['H'], params['u'], params['v']\n        y_in, y_th, beta = params['y_in'], params['y_th'], params['beta']\n        x_t, s, alpha = params['x_t'], params['s'], params['alpha']\n        \n        dxi = 1.0 / (N_xi - 1)\n        deta = 1.0 / (N_eta - 1)\n\n        # Generate computational grid (i-th index -> xi, j-th index -> eta)\n        xi_1d = np.linspace(0, 1, N_xi)\n        eta_1d = np.linspace(0, 1, N_eta)\n        XI, ETA = np.meshgrid(xi_1d, eta_1d, indexing='ij')\n\n        # Generate physical grid\n        x = L * XI\n        if params['type'] == 'rectangular':\n            y = H * ETA\n        else: # nozzle or skewed nozzle\n            h_x = y_in - (y_in - y_th) * np.exp(-beta * (x - x_t)**2) + s * (x - x_t)\n            y = ETA * h_x\n            if params['type'] == 'skewed':\n                y += alpha * np.sin(2 * np.pi * XI) * np.sin(2 * np.pi * ETA)\n\n        # Inconsistent Mixed-Stencil Scheme\n        x_xi_f = (np.roll(x, -1, axis=0) - x) / dxi\n        y_xi_f = (np.roll(y, -1, axis=0) - y) / dxi\n        x_eta_b = (x - np.roll(x, 1, axis=1)) / deta\n        y_eta_b = (y - np.roll(y, 1, axis=1)) / deta\n\n        F_xi_mixed = u * y_eta_b - v * x_eta_b\n        F_eta_mixed = -u * y_xi_f + v * x_xi_f\n\n        DivF_xi_mixed = (np.roll(F_xi_mixed, -1, axis=0) - np.roll(F_xi_mixed, 1, axis=0)) / (2 * dxi)\n        DivF_eta_mixed = (np.roll(F_eta_mixed, -1, axis=1) - np.roll(F_eta_mixed, 1, axis=1)) / (2 * deta)\n        \n        R_mixed = DivF_xi_mixed + DivF_eta_mixed\n        res_mixed = np.max(np.abs(R_mixed[1:-1, 1:-1]))\n        results.append(res_mixed)\n        \n        # Consistent Central Scheme\n        x_xi_c = (np.roll(x, -1, axis=0) - np.roll(x, 1, axis=0)) / (2 * dxi)\n        y_xi_c = (np.roll(y, -1, axis=0) - np.roll(y, 1, axis=0)) / (2 * dxi)\n        x_eta_c = (np.roll(x, -1, axis=1) - np.roll(x, 1, axis=1)) / (2 * deta)\n        y_eta_c = (np.roll(y, -1, axis=1) - np.roll(y, 1, axis=1)) / (2 * deta)\n\n        F_xi_central = u * y_eta_c - v * x_eta_c\n        F_eta_central = -u * y_xi_c + v * x_xi_c\n\n        DivF_xi_central = (np.roll(F_xi_central, -1, axis=0) - np.roll(F_xi_central, 1, axis=0)) / (2 * dxi)\n        DivF_eta_central = (np.roll(F_eta_central, -1, axis=1) - np.roll(F_eta_central, 1, axis=1)) / (2 * deta)\n\n        R_central = DivF_xi_central + DivF_eta_central\n        res_central = np.max(np.abs(R_central[2:-2, 2:-2]))\n        results.append(res_central)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}