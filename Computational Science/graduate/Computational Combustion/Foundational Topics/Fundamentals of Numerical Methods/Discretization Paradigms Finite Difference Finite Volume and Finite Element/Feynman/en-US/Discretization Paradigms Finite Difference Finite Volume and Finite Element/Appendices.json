{
    "hands_on_practices": [
        {
            "introduction": "In computational science, ensuring your code is correct is the first and most critical step. This exercise introduces the Method of Manufactured Solutions (MMS), a powerful technique for code verification. By designing a problem with a known analytic solution, you can rigorously test your implementation of a finite difference scheme for an advection-diffusion-reaction equation and quantitatively measure its convergence rate, confirming it matches theoretical expectations .",
            "id": "4020935",
            "problem": "Consider the steady one-dimensional advection-diffusion-reaction model for a passive scalar in computational combustion, posed on the domain $[0,1]$ with nondimensional quantities. The governing equation is\n$$\n-\\nu \\,\\frac{d^2 u}{dx^2} + a \\,\\frac{du}{dx} + r\\,u = s(x),\n$$\nwhere $u(x)$ is the scalar field, $\\nu > 0$ is the diffusion coefficient, $a$ is the constant advection speed, $r \\ge 0$ is the reaction rate, and $s(x)$ is a source term. Dirichlet boundary conditions are imposed as\n$$\nu(0) = u_{\\text{exact}}(0), \\quad u(1) = u_{\\text{exact}}(1).\n$$\nUse the method of manufactured solutions: select a smooth, analytic function $u_{\\text{exact}}(x)$ and set\n$$\ns(x) = -\\nu\\,u_{\\text{exact}}''(x) + a\\,u_{\\text{exact}}'(x) + r\\,u_{\\text{exact}}(x)\n$$\nso that $u_{\\text{exact}}(x)$ is the exact solution of the continuous problem. Discretize the interior of $[0,1]$ with $M$ uniformly spaced grid points (including boundaries) with spacing $h = \\frac{1}{M-1}$. Approximate $\\frac{d^2 u}{dx^2}$ and $\\frac{du}{dx}$ at interior nodes using second-order centered finite differences, assemble the resulting linear system, and enforce the Dirichlet boundary conditions strongly. Solve the linear system to obtain the discrete approximation $u_h$ at the grid points.\n\nCompute the discrete $L^2$-norm of the error\n$$\n\\|e\\|_{L^2_h} = \\left(h \\sum_{i=0}^{M-1} \\big(u_h(x_i) - u_{\\text{exact}}(x_i)\\big)^2 \\right)^{1/2}\n$$\nwith $x_i = i\\,h$. Perform a grid refinement study with successive halving of $h$ to estimate the observed order of accuracy\n$$\np = \\frac{\\log\\left(\\|e\\|_{L^2_{h_1}} / \\|e\\|_{L^2_{h_2}}\\right)}{\\log\\left(h_1 / h_2\\right)}\n$$\nbetween each consecutive pair of grids.\n\nImplement the above for the following test suite. For each test case, use the specified coefficients $(\\nu,a,r)$, the manufactured solution $u_{\\text{exact}}(x)$, and the list of grid sizes $M$:\n\nTest case $1$ (general smooth solution, moderate advection and reaction):\n- $(\\nu,a,r) = (0.1,\\,0.5,\\,1.0)$,\n- $u_{\\text{exact}}(x) = \\sin(2\\pi x) + x(1-x)$,\n- $M \\in \\{21,\\,41,\\,81,\\,161\\}$.\n\nTest case $2$ (reaction-dominated regime with exponential solution):\n- $(\\nu,a,r) = (0.01,\\,0.1,\\,10.0)$,\n- $u_{\\text{exact}}(x) = e^{x}$,\n- $M \\in \\{21,\\,41,\\,81,\\,161\\}$.\n\nTest case $3$ (advection-dominated regime stabilized by reaction):\n- $(\\nu,a,r) = (0.001,\\,1.0,\\,20.0)$,\n- $u_{\\text{exact}}(x) = \\sin(\\pi x)$,\n- $M \\in \\{51,\\,101,\\,201,\\,401\\}$.\n\nAll quantities are nondimensional, so no physical units are required. Your program must:\n- For each test case, compute the discrete $L^2$ error $\\|e\\|_{L^2_h}$ on each grid, then compute the observed orders $p$ between each consecutive grid.\n- Aggregate the observed orders for each test case into a list of floats corresponding to the consecutive pairs of $M$ values, in the same order as given.\n- Produce a single line of output containing the lists of observed orders for all test cases as a comma-separated list enclosed in square brackets, for example\n$$\n[ [p_{1,1},p_{1,2},p_{1,3}], [p_{2,1},p_{2,2},p_{2,3}], [p_{3,1},p_{3,2},p_{3,3}] ].\n$$\nEach $p$ must be printed as a decimal (floating-point number). No additional text may be printed.",
            "solution": "The derivation starts from the steady one-dimensional conservation of a passive scalar with advection, diffusion, and reaction, which in nondimensional form can be written as\n$$\n-\\nu \\,\\frac{d^2 u}{dx^2} + a \\,\\frac{du}{dx} + r\\,u = s(x),\n$$\nwith constants $\\nu > 0$, $a$, and $r \\ge 0$. The method of manufactured solutions prescribes an analytic function $u_{\\text{exact}}(x)$ and defines the source term by substitution into the differential operator, namely\n$$\ns(x) = -\\nu\\,u_{\\text{exact}}''(x) + a\\,u_{\\text{exact}}'(x) + r\\,u_{\\text{exact}}(x).\n$$\nBy this construction, $u_{\\text{exact}}(x)$ solves the continuous problem with the given boundary conditions $u(0)=u_{\\text{exact}}(0)$ and $u(1)=u_{\\text{exact}}(1)$.\n\nTo discretize the domain, choose $M$ grid points including the endpoints, so the grid spacing is $h = \\frac{1}{M-1}$ and $x_i = i\\,h$ for $i=0,1,\\dots,M-1$. At an interior node indexed by $i$ with $1 \\le i \\le M-2$, approximate derivatives using second-order centered finite differences derived from Taylor expansions. The second derivative is\n$$\n\\frac{d^2 u}{dx^2}\\bigg|_{x_i} \\approx \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} + O(h^2),\n$$\nand the first derivative is\n$$\n\\frac{du}{dx}\\bigg|_{x_i} \\approx \\frac{u_{i+1} - u_{i-1}}{2h} + O(h^2).\n$$\nSubstituting these into the strong form yields the discrete equation at each interior node:\n$$\n-\\nu \\left(\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\\right) + a \\left(\\frac{u_{i+1} - u_{i-1}}{2h}\\right) + r\\,u_i = s(x_i).\n$$\nCollecting coefficients forms a tridiagonal linear system $A \\mathbf{u} = \\mathbf{b}$ for the interior unknowns $\\mathbf{u} = [u_1,\\dots,u_{M-2}]^\\top$:\n$$\nA_{i,i} = \\frac{2\\nu}{h^2} + r, \\quad A_{i,i-1} = -\\frac{\\nu}{h^2} - \\frac{a}{2h}, \\quad A_{i,i+1} = -\\frac{\\nu}{h^2} + \\frac{a}{2h}.\n$$\nDirichlet boundary values enter the right-hand side via the off-diagonal couplings at $i=1$ and $i=M-2$, specifically\n$$\nb_i = s(x_i) - A_{i,i-1}\\,u_0 \\ \\text{if } i=1, \\quad b_i = s(x_i) - A_{i,i+1}\\,u_{M-1} \\ \\text{if } i=M-2,\n$$\nand $b_i = s(x_i)$ otherwise, with $u_0 = u_{\\text{exact}}(0)$ and $u_{M-1} = u_{\\text{exact}}(1)$. Solving the linear system provides interior approximations, and the full grid solution $u_h(x_i)$ is constructed by inserting the Dirichlet values at the boundaries.\n\nTo assess accuracy, use the discrete $L^2$ norm as a quadrature-based approximation of the continuous $L^2$ norm,\n$$\n\\|e\\|_{L^2_h} = \\left(h \\sum_{i=0}^{M-1} \\left(u_h(x_i) - u_{\\text{exact}}(x_i)\\right)^2 \\right)^{1/2}.\n$$\nSince Dirichlet boundary conditions are enforced exactly, the boundary contributions are zero, and including them does not change the error norm. For a sequence of grids with $h$ halved each time, the observed order of accuracy between consecutive grids is computed as\n$$\np = \\frac{\\log\\left(\\|e\\|_{L^2_{h_1}} / \\|e\\|_{L^2_{h_2}}\\right)}{\\log\\left(h_1 / h_2\\right)}.\n$$\nSecond-order centered finite differences yield truncation errors of order $O(h^2)$ for both the first and second derivatives, so under smooth coefficients and the manufactured exact solutions, the discrete scheme is expected to exhibit an observed order close to $p \\approx 2$ in the $L^2$ norm, provided the linear system is well-conditioned. The advection-diffusion-reaction balance affects the conditioning; the reaction term $r$ contributes to diagonal dominance, and moderate $a$ relative to $\\nu$ and $h$ helps avoid spurious oscillations for central differencing. In the test suite, the chosen parameters ensure solvable systems across the refinements. The algorithm proceeds as follows: for each test case, define $u_{\\text{exact}}(x)$ and its derivatives $u_{\\text{exact}}'(x)$ and $u_{\\text{exact}}''(x)$; compute $s(x)$ on the grid; assemble $A$ and $\\mathbf{b}$; solve for $\\mathbf{u}$; compute $\\|e\\|_{L^2_h}$ on each grid; compute $p$ for each consecutive pair; and output the lists of observed orders for all test cases in the specified single-line format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_tridiagonal_matrix_and_rhs(M, nu, a, r, u_exact, du_exact, d2u_exact):\n    \"\"\"\n    Build the tridiagonal matrix A and right-hand side b for the interior unknowns\n    using second-order centered finite differences for:\n        -nu * u'' + a * u' + r * u = s(x),\n    with Dirichlet boundary conditions u(0)=u_exact(0), u(1)=u_exact(1).\n    \"\"\"\n    h = 1.0 / (M - 1)\n    x = np.linspace(0.0, 1.0, M)\n\n    # Precompute source term s at interior nodes using manufactured solution\n    s = -nu * d2u_exact(x) + a * du_exact(x) + r * u_exact(x)\n\n    n_interior = M - 2\n    A = np.zeros((n_interior, n_interior))\n    b = np.zeros(n_interior)\n\n    # Coefficients for tridiagonal stencil\n    diag = 2.0 * nu / (h**2) + r\n    off_left = -nu / (h**2) - a / (2.0 * h)\n    off_right = -nu / (h**2) + a / (2.0 * h)\n\n    u0 = u_exact(0.0)\n    uN = u_exact(1.0)\n\n    for i in range(n_interior):\n        # Global index of the interior node\n        gi = i + 1\n        # Fill diagonal\n        A[i, i] = diag\n        # Left off-diagonal\n        if i - 1 >= 0:\n            A[i, i - 1] = off_left\n        else:\n            # Contribution from boundary u0\n            b[i] -= off_left * u0\n        # Right off-diagonal\n        if i + 1 <= n_interior - 1:\n            A[i, i + 1] = off_right\n        else:\n            # Contribution from boundary uN\n            b[i] -= off_right * uN\n        # Source term at this node\n        b[i] += s[gi]\n\n    return A, b, x\n\ndef solve_fd(M, nu, a, r, u_exact, du_exact, d2u_exact):\n    \"\"\"\n    Solve the finite difference discretization and return the grid, numerical solution,\n    and L2 error against the manufactured exact solution.\n    \"\"\"\n    A, b, x = build_tridiagonal_matrix_and_rhs(M, nu, a, r, u_exact, du_exact, d2u_exact)\n\n    # Solve for interior unknowns\n    u_interior = np.linalg.solve(A, b)\n\n    # Assemble full solution with Dirichlet boundaries\n    u_h = np.zeros(M)\n    u_h[0] = u_exact(0.0)\n    u_h[-1] = u_exact(1.0)\n    u_h[1:-1] = u_interior\n\n    # Compute discrete L2 error\n    h = 1.0 / (M - 1)\n    u_ex = u_exact(x)\n    err = u_h - u_ex\n    l2_err = np.sqrt(h * np.sum(err**2))\n    return x, u_h, l2_err\n\ndef observed_orders(M_list, nu, a, r, u_exact, du_exact, d2u_exact):\n    \"\"\"\n    Compute observed orders between consecutive grids in M_list.\n    \"\"\"\n    errors = []\n    hs = []\n    for M in M_list:\n        _, _, l2_err = solve_fd(M, nu, a, r, u_exact, du_exact, d2u_exact)\n        h = 1.0 / (M - 1)\n        errors.append(l2_err)\n        hs.append(h)\n\n    orders = []\n    for i in range(len(M_list) - 1):\n        e1 = errors[i]\n        e2 = errors[i + 1]\n        h1 = hs[i]\n        h2 = hs[i + 1]\n        # Guard against any potential divide-by-zero or zero error\n        if e1 > 0 and e2 > 0 and h1 > 0 and h2 > 0:\n            p = np.log(e1 / e2) / np.log(h1 / h2)\n        else:\n            p = float('nan')\n        orders.append(p)\n    return orders\n\n# Manufactured solutions and derivatives\ndef ms1_u(x):\n    return np.sin(2.0 * np.pi * x) + x * (1.0 - x)\n\ndef ms1_du(x):\n    return 2.0 * np.pi * np.cos(2.0 * np.pi * x) + (1.0 - 2.0 * x)\n\ndef ms1_d2u(x):\n    return -(2.0 * np.pi)**2 * np.sin(2.0 * np.pi * x) - 2.0\n\ndef ms2_u(x):\n    return np.exp(x)\n\ndef ms2_du(x):\n    return np.exp(x)\n\ndef ms2_d2u(x):\n    return np.exp(x)\n\ndef ms3_u(x):\n    return np.sin(np.pi * x)\n\ndef ms3_du(x):\n    return np.pi * np.cos(np.pi * x)\n\ndef ms3_d2u(x):\n    return -(np.pi**2) * np.sin(np.pi * x)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"nu\": 0.1,\n            \"a\": 0.5,\n            \"r\": 1.0,\n            \"u\": ms1_u,\n            \"du\": ms1_du,\n            \"d2u\": ms1_d2u,\n            \"M_list\": [21, 41, 81, 161],\n        },\n        # Test case 2\n        {\n            \"nu\": 0.01,\n            \"a\": 0.1,\n            \"r\": 10.0,\n            \"u\": ms2_u,\n            \"du\": ms2_du,\n            \"d2u\": ms2_d2u,\n            \"M_list\": [21, 41, 81, 161],\n        },\n        # Test case 3\n        {\n            \"nu\": 0.001,\n            \"a\": 1.0,\n            \"r\": 20.0,\n            \"u\": ms3_u,\n            \"du\": ms3_du,\n            \"d2u\": ms3_d2u,\n            \"M_list\": [51, 101, 201, 401],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        nu = case[\"nu\"]\n        a = case[\"a\"]\n        r = case[\"r\"]\n        u = case[\"u\"]\n        du = case[\"du\"]\n        d2u = case[\"d2u\"]\n        M_list = case[\"M_list\"]\n\n        orders = observed_orders(M_list, nu, a, r, u, du, d2u)\n        # Round for neat output (not required mathematically, purely formatting)\n        orders_rounded = [float(f\"{p:.6f}\") for p in orders]\n        results.append(orders_rounded)\n\n    # Final print statement in the exact required format.\n    # Construct the single-line output with lists.\n    def list_to_str(lst):\n        return \"[\" + \",\".join(map(str, lst)) + \"]\"\n\n    print(\"[\" + \",\".join(list_to_str(r) for r in results) + \"]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A numerically accurate solution is not always a physically meaningful one. This practice explores the Discrete Maximum Principle (DMP), a property that ensures a numerical scheme does not produce non-physical oscillations, such as temperatures outside the range of initial or boundary conditions. By comparing Finite Difference, Finite Volume, and Finite Element discretizations for a reaction-diffusion problem, you will discover fundamental differences in their inherent structures and their ability to preserve physical bounds, a crucial consideration in combustion modeling where species concentrations must remain positive .",
            "id": "4020797",
            "problem": "Consider the one-dimensional steady reaction–diffusion balance for a single, dimensionless reactive scalar on the interval $[0,1]$ with homogeneous medium and prescribed Dirichlet boundary data. The governing equation, derived from species conservation and Fickian diffusion, is\n$$\n- \\frac{d}{dx}\\left(D(x)\\,\\frac{du}{dx}\\right) + k\\,u(x) = 0,\\quad x\\in(0,1),\n$$\nwith boundary conditions\n$$\nu(0) = 1,\\quad u(1) = 0,\n$$\nwhere $D(x) > 0$ is the diffusion coefficient and $k \\ge 0$ is the reaction (absorption) coefficient. All quantities are dimensionless.\n\nYour task is to write a complete, runnable program that:\n- Constructs three discrete approximations on a uniform mesh of $N$ elements (with $N+1$ nodes), implementing:\n  1. Finite Difference (FD) using a conservative flux-based central approximation for variable $D(x)$.\n  2. Finite Volume (FV) using a two-point flux approximation, i.e., balancing fluxes across control-volume faces.\n  3. Finite Element (FE) with linear elements, assembling the diffusion stiffness and using the consistent mass matrix for the reaction term.\n- Solves the resulting linear systems for the discrete interior solutions in each paradigm, enforcing the Dirichlet boundary conditions $u(0)=1$ and $u(1)=0$ strongly.\n- Checks satisfaction of the Discrete Maximum Principle (DMP) for each method, defined here as: every interior discrete value lies within the closed interval $[0,1]$ up to a numerical tolerance. Formally, if $u_i$ denotes an interior degree of freedom, the test is\n$$\n\\min_i u_i \\ge 0 - \\varepsilon\\quad\\text{and}\\quad \\max_i u_i \\le 1 + \\varepsilon,\n$$\nwith tolerance $\\varepsilon = 10^{-12}$.\n- Reports, for each test case, three boolean values indicating whether the FD, FV, and FE discrete solutions satisfy the DMP.\n\nIn all discretizations, use a uniform partition with $N$ elements, $x_j = j\\,\\Delta x$ for $j=0,1,\\dots,N$, $\\Delta x = 1/N$. For variable diffusion, define $D(x)$ pointwise as indicated by each test case. In FD and FV, evaluate face-centered diffusion $D_{j+\\frac{1}{2}} = D\\!\\left(x_{j+\\frac{1}{2}}\\right)$ with $x_{j+\\frac{1}{2}} = \\left(j+\\frac{1}{2}\\right)\\Delta x$. In FE, assemble element-wise with $D_e = D\\!\\left(x_{e+\\frac{1}{2}}\\right)$ taken constant per element, and use the consistent reaction mass matrix.\n\nTest Suite:\n- Case $1$ (happy path, diffusion only): $N=50$, $k=0$, $D(x)\\equiv 1$.\n- Case $2$ (reaction-dominated, coarse mesh): $N=10$, $k=5000$, $D(x)\\equiv 1$.\n- Case $3$ (diffusion-dominated): $N=50$, $k=1$, $D(x)\\equiv 10$.\n- Case $4$ (strong diffusion jump with reaction): $N=20$, $k=100$, \n  $D(x) = \\begin{cases}\n  1,& x < 0.3,\\\\\n  0.01,& x \\ge 0.3.\n  \\end{cases}$\n- Case $5$ (boundary-dominated coarse grid): $N=3$, $k=0$, $D(x)\\equiv 1$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists with no spaces, in the order of test cases above. Each inner list has three entries corresponding to $(\\text{FD},\\text{FV},\\text{FE})$ DMP indicators. For example, the printed line should look like\n$$\n[[\\text{True},\\text{True},\\text{False}],[\\text{True},\\text{True},\\text{True}],\\dots]\n$$\nbut with the boolean values computed from your implementation. The output must be a single line and must match this structure exactly.",
            "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded, well-posed, objective, and contains sufficient information for a unique solution. The problem asks for the implementation and comparison of three numerical methods for a one-dimensional steady reaction-diffusion equation, a canonical problem in transport phenomena and computational science.\n\nThe governing equation for a reactive scalar $u(x)$ on the domain $x \\in [0,1]$ is given by:\n$$\n- \\frac{d}{dx}\\left(D(x)\\,\\frac{du}{dx}\\right) + k\\,u(x) = 0\n$$\nwith Dirichlet boundary conditions $u(0) = 1$ and $u(1) = 0$. Here, $D(x) > 0$ is the diffusion coefficient and $k \\ge 0$ is the reaction rate coefficient.\n\nWe will discretize this equation on a uniform mesh with $N$ elements and $N+1$ nodes, where $x_j = j\\,\\Delta x$ for $j=0, 1, \\dots, N$, and the mesh spacing is $\\Delta x = 1/N$. The discrete solution at node $x_j$ is denoted $u_j$. The $N-1$ interior node values, $u_1, u_2, \\dots, u_{N-1}$, are the unknowns to be solved for.\n\n### 1. Finite Difference (FD) Method\nThe FD method approximates the derivatives at discrete node points. For a variable diffusion coefficient, a conservative formulation is employed. The divergence of the diffusive flux, $-\\frac{d}{dx}(D \\frac{du}{dx})$, at an interior node $x_j$ is approximated using central differences over a control volume of length $\\Delta x$ centered at $x_j$:\n$$\n-\\left.\\frac{d}{dx}\\left(D(x)\\,\\frac{du}{dx}\\right)\\right|_{x_j} \\approx -\\frac{1}{\\Delta x} \\left[ \\left(D\\frac{du}{dx}\\right)_{j+\\frac{1}{2}} - \\left(D\\frac{du}{dx}\\right)_{j-\\frac{1}{2}} \\right]\n$$\nThe fluxes at the cell faces, located at $x_{j\\pm\\frac{1}{2}} = (j\\pm\\frac{1}{2})\\Delta x$, are also approximated by central differences:\n$$\n\\left(D\\frac{du}{dx}\\right)_{j+\\frac{1}{2}} \\approx D(x_{j+\\frac{1}{2}}) \\frac{u_{j+1} - u_j}{\\Delta x} = D_{j+\\frac{1}{2}} \\frac{u_{j+1} - u_j}{\\Delta x}\n$$\nSubstituting these into the governing equation and approximating the reaction term as $k\\,u_j$ yields the discrete equation for an interior node $j \\in \\{1, \\dots, N-1\\}$:\n$$\n-\\frac{1}{\\Delta x} \\left( D_{j+\\frac{1}{2}} \\frac{u_{j+1} - u_j}{\\Delta x} - D_{j-\\frac{1}{2}} \\frac{u_j - u_{j-1}}{\\Delta x} \\right) + k\\,u_j = 0\n$$\nMultiplying by $\\Delta x^2$ and grouping terms by unknown $u_j$, we obtain the algebraic stencil:\n$$\n-D_{j-\\frac{1}{2}} u_{j-1} + \\left(D_{j-\\frac{1}{2}} + D_{j+\\frac{1}{2}} + k\\,\\Delta x^2\\right)u_j - D_{j+\\frac{1}{2}} u_{j+1} = 0\n$$\n\n### 2. Finite Volume (FV) Method\nThe FV method begins by integrating the governing equation over a control volume (CV). For a node-centered scheme, the CV for node $j$ is $[x_{j-\\frac{1}{2}}, x_{j+\\frac{1}{2}}]$ of volume $\\Delta x$.\n$$\n\\int_{x_{j-\\frac{1}{2}}}^{x_{j+\\frac{1}{2}}} \\left( - \\frac{d}{dx}\\left(D\\,\\frac{du}{dx}\\right) + k\\,u \\right) dx = 0\n$$\nApplying the fundamental theorem of calculus to the divergence term gives a balance of fluxes at the CV faces:\n$$\n- \\left[ D\\,\\frac{du}{dx} \\right]_{x_{j-\\frac{1}{2}}}^{x_{j+\\frac{1}{2}}} + \\int_{x_{j-\\frac{1}{2}}}^{x_{j+\\frac{1}{2}}} k\\,u(x) dx = 0\n$$\n$$\n\\left(D\\,\\frac{du}{dx}\\right)_{j-\\frac{1}{2}} - \\left(D\\,\\frac{du}{dx}\\right)_{j+\\frac{1}{2}} + \\int_{x_{j-\\frac{1}{2}}}^{x_{j+\\frac{1}{2}}} k\\,u(x) dx = 0\n$$\nUsing the specified two-point flux approximation, which is identical to the one used in the FD scheme, and approximating the source term integral as $k\\,u_j\\,\\Delta x$, we get:\n$$\nD_{j-\\frac{1}{2}} \\frac{u_j - u_{j-1}}{\\Delta x} - D_{j+\\frac{1}{2}} \\frac{u_{j+1} - u_j}{\\Delta x} + k\\,u_j\\,\\Delta x = 0\n$$\nMultiplying by $\\Delta x$ reveals that this equation is algebraically identical to the FD equation. Thus, for the specified approximations, the FD and FV methods produce identical linear systems.\n\n### 3. Finite Element (FE) Method\nThe FE method is based on a weak formulation of the problem. We seek an approximate solution $u_h(x) = \\sum_{j=0}^{N} u_j \\phi_j(x)$, where $\\phi_j(x)$ are a basis of piecewise linear \"hat\" functions. The Galerkin method requires the residual to be orthogonal to each basis function $\\phi_i(x)$ for interior nodes $i=1, \\dots, N-1$.\n$$\n\\int_0^1 \\left( - \\frac{d}{dx}\\left(D\\frac{du_h}{dx}\\right) + k\\,u_h \\right) \\phi_i(x) dx = 0\n$$\nIntegrating the diffusion term by parts yields:\n$$\n\\int_0^1 D(x)\\,\\frac{du_h}{dx}\\frac{d\\phi_i}{dx} dx + \\int_0^1 k\\,u_h(x)\\,\\phi_i(x) dx = \\left[-D\\frac{du_h}{dx}\\phi_i\\right]_0^1\n$$\nSince $\\phi_i(0)=\\phi_i(1)=0$ for interior nodes, the boundary term vanishes. Substituting $u_h$ leads to a linear system $(S+M)\\mathbf{u} = \\mathbf{f}$, where $S$ is the stiffness matrix and $M$ is the mass matrix.\nThe entries are assembled element-wise. For an element $e$ spanning $[x_e, x_{e+1}]$ with constant diffusion $D_e = D(x_{e+\\frac{1}{2}})$, the element stiffness matrix $S^e$ and consistent mass matrix $M^e$ are:\n$$\nS^e = \\frac{D_e}{\\Delta x} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}, \\quad M^e = k \\frac{\\Delta x}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}\n$$\nThe equation for an interior node $i$ is assembled from contributions of element $i-1$ and element $i$. This yields the algebraic stencil:\n$$\n\\left(-\\frac{D_{i-\\frac{1}{2}}}{\\Delta x} + k\\frac{\\Delta x}{6}\\right)u_{i-1} + \\left(\\frac{D_{i-\\frac{1}{2}} + D_{i+\\frac{1}{2}}}{\\Delta x} + k\\frac{2\\Delta x}{3}\\right)u_i + \\left(-\\frac{D_{i+\\frac{1}{2}}}{\\Delta x} + k\\frac{\\Delta x}{6}\\right)u_{i+1} = 0\n$$\n\n### Linear System and Boundary Conditions\nFor each method, a tridiagonal linear system $A\\mathbf{u}_{\\text{int}} = \\mathbf{b}$ is constructed for the vector of interior unknowns $\\mathbf{u}_{\\text{int}} = [u_1, \\dots, u_{N-1}]^T$. The Dirichlet conditions are enforced strongly by modifying the first and last equations.\nFor $j=1$ (first interior node), the term involving the known $u_0=1$ is moved to the right-hand side.\n- For FD/FV: the RHS of the first equation becomes $b_1 = D_{1/2} u_0 = D_{1/2}$.\n- For FE: the RHS becomes $b_1 = -(-\\frac{D_{1/2}}{\\Delta x} + k\\frac{\\Delta x}{6})u_0 = \\frac{D_{1/2}}{\\Delta x} - k\\frac{\\Delta x}{6}$.\nFor $j=N-1$ (last interior node), the term involving $u_N=0$ is simply zero and does not contribute to the system.\n\n### Discrete Maximum Principle (DMP)\nThe continuous problem satisfies a maximum principle: for $k \\ge 0$, the solution $u(x)$ must lie between the boundary-value extrema, i.e., $u(x) \\in [0,1]$. A numerical scheme satisfies a DMP if its discrete solution also respects these bounds. This is guaranteed if the system matrix $A$ is an M-matrix, which requires (among other properties) non-positive off-diagonal elements ($A_{ij} \\le 0$ for $i \\ne j$) and positive diagonal elements ($A_{ii} > 0$).\n- The FD/FV matrix has off-diagonal entries like $-D_{j\\pm\\frac{1}{2}}$ (before scaling), which are always non-positive since $D>0$. Thus, FD/FV will satisfy the DMP.\n- The FE matrix, however, has off-diagonal entries like $-\\frac{D}{\\Delta x} + k\\frac{\\Delta x}{6}$. If the reaction term is large, this term can become positive. Specifically, if $k\\frac{\\Delta x^2}{6D} > 1$, the M-matrix property is lost, and non-physical oscillations (overshoots or undershoots) may appear, violating the DMP. This is a known issue with the consistent mass matrix formulation in reaction-dominated regimes.\n\nThe implementation will construct and solve these systems for each test case and verify the DMP for each resulting solution vector.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and generate the final output.\n    \"\"\"\n\n    def check_dmp(u_interior):\n        \"\"\"\n        Checks if the discrete solution satisfies the Discrete Maximum Principle.\n        For an empty set of interior nodes, it is trivially satisfied.\n        \"\"\"\n        epsilon = 1e-12\n        if u_interior.size == 0:\n            return True\n        min_u = np.min(u_interior)\n        max_u = np.max(u_interior)\n        return min_u >= -epsilon and max_u <= 1.0 + epsilon\n\n    def solve_fd_fv(N, k, D_func):\n        \"\"\"\n        Solves the reaction-diffusion equation using the Finite Difference /\n        Finite Volume method. The two are algebraically identical for this problem.\n        \"\"\"\n        if N <= 1:\n            return np.array([])\n            \n        num_interior = N - 1\n        dx = 1.0 / N\n        u0, uN = 1.0, 0.0\n\n        A = np.zeros((num_interior, num_interior))\n        b = np.zeros(num_interior)\n\n        for i in range(num_interior):\n            j = i + 1  # Node index\n            \n            # Diffusion coefficients at cell faces\n            D_minus = D_func((j - 0.5) * dx)\n            D_plus = D_func((j + 0.5) * dx)\n\n            # Diagonal entry\n            A[i, i] = D_minus + D_plus + k * dx**2\n            \n            # Off-diagonal entries\n            if i > 0:\n                A[i, i - 1] = -D_minus\n            if i < num_interior - 1:\n                A[i, i + 1] = -D_plus\n\n            # Boundary conditions\n            if j == 1:\n                b[i] += D_minus * u0\n            # if j == N - 1, uN term is zero\n\n        u_interior = np.linalg.solve(A, b)\n        return u_interior\n\n    def solve_fe(N, k, D_func):\n        \"\"\"\n        Solves the reaction-diffusion equation using the Finite Element method\n        with linear basis functions and a consistent mass matrix.\n        \"\"\"\n        if N <= 1:\n            return np.array([])\n            \n        num_interior = N - 1\n        dx = 1.0 / N\n        u0, uN = 1.0, 0.0\n\n        A = np.zeros((num_interior, num_interior))\n        b = np.zeros(num_interior)\n\n        for i in range(num_interior):\n            j = i + 1  # Node index\n            \n            # Diffusion coefficients (constant per element)\n            D_left_elem = D_func((j - 0.5) * dx) # For element j-1\n            D_right_elem = D_func((j + 0.5) * dx) # For element j\n            \n            # Stiffness part\n            stiff_diag = (D_left_elem + D_right_elem) / dx\n            stiff_off_diag_left = -D_left_elem / dx\n            stiff_off_diag_right = -D_right_elem / dx\n\n            # Mass part (consistent)\n            mass_diag = k * 2.0 * dx / 3.0\n            mass_off_diag = k * dx / 6.0\n\n            # Assemble matrix A\n            A[i, i] = stiff_diag + mass_diag\n            if i > 0:\n                A[i, i - 1] = stiff_off_diag_left + mass_off_diag\n            if i < num_interior - 1:\n                A[i, i + 1] = stiff_off_diag_right + mass_off_diag\n\n            # Assemble RHS vector b with boundary conditions\n            if j == 1:\n                # Contribution from u0=1 term\n                b[i] += -(stiff_off_diag_left + mass_off_diag) * u0\n            # if j == N - 1, uN term is zero\n\n        u_interior = np.linalg.solve(A, b)\n        return u_interior\n\n    test_cases = [\n        # Case 1 (happy path, diffusion only)\n        (50, 0.0, lambda x: 1.0),\n        # Case 2 (reaction-dominated, coarse mesh)\n        (10, 5000.0, lambda x: 1.0),\n        # Case 3 (diffusion-dominated)\n        (50, 1.0, lambda x: 10.0),\n        # Case 4 (strong diffusion jump with reaction)\n        (20, 100.0, lambda x: 1.0 if x < 0.3 else 0.01),\n        # Case 5 (boundary-dominated coarse grid)\n        (3, 0.0, lambda x: 1.0),\n    ]\n\n    all_results = []\n    for N, k, D_func in test_cases:\n        # Solve using each method\n        u_fd = solve_fd_fv(N, k, D_func)\n        u_fv = u_fd  # As derived, FD and FV are identical for this problem setup\n        u_fe = solve_fe(N, k, D_func)\n\n        # Check Discrete Maximum Principle for each solution\n        dmp_results = [\n            check_dmp(u_fd),\n            check_dmp(u_fv),\n            check_dmp(u_fe)\n        ]\n        all_results.append(dmp_results)\n\n    # Format the output as specified\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The accuracy of a simulation often hinges on the correct implementation of boundary conditions, which represent the interaction between the computational domain and its surroundings. This exercise focuses on implementing a Robin (or mixed) boundary condition for heat transfer within the Finite Volume framework, a common scenario in combustion applications involving wall heat loss. You will derive and apply a consistent flux expression that couples conduction within the domain to convection at the boundary, a fundamental skill for modeling realistic thermal systems .",
            "id": "4020756",
            "problem": "Consider a one-dimensional boundary-adjacent control volume in computational combustion where conductive heat transfer within the solid or stagnant gas near the wall is modeled. You are to implement the Robin (mixed) boundary condition for heat loss at a boundary face, expressed as $-\\lambda \\, \\partial_n T = h \\, (T - T_\\infty)$, where $\\lambda$ is the thermal conductivity, $h$ is the heat transfer coefficient, $T$ is the temperature evaluated at the boundary, and $T_\\infty$ is the ambient temperature. The outward unit normal $\\mathbf{n}$ points from the cell interior to the environment. The objective is to compute the face-based contribution to the energy balance using the Finite Volume Method (FVM), consistent with the conservation of energy and Fourier's law of heat conduction.\n\nBase your derivation and implementation strictly on the following fundamental laws and definitions:\n- Conservation of energy for a control volume: the net outward heat flux through the control surface equals the rate of energy loss from the control volume due to conduction at the boundary.\n- Fourier's law of heat conduction: the normal conductive heat flux is $q_n = -\\lambda \\, \\partial_n T$.\n- Newton's law of cooling (Robin boundary condition form): at the boundary face, $q_n = h \\, (T_b - T_\\infty)$, where $T_b$ is the boundary temperature at the face.\n\nAssume a planar boundary face with area $A$ and uniform properties over the face. Approximate the temperature gradient normal to the boundary using a linear one-sided finite volume reconstruction based on the cell-center temperature $T_p$ and the boundary temperature $T_b$ across a distance $d$ between the cell center and the boundary plane. Your task is to derive a consistent face-based heat flow expression to be included in the cell’s energy balance and implement it in code.\n\nYour program must compute, for each test case, the scalar quantity $Q_{\\text{face,out}}$ in watts ($\\mathrm{W}$), defined as the outward heat flow through the boundary face: $Q_{\\text{face,out}} = q_n \\, A$, with the sign convention that a positive value corresponds to energy leaving the cell through the boundary.\n\nUse the following test suite of parameter sets ($\\lambda, h, d, A, T_p, T_\\infty$), all in SI units: thermal conductivity $\\lambda$ in $\\mathrm{W}/(\\mathrm{m}\\cdot \\mathrm{K})$, heat transfer coefficient $h$ in $\\mathrm{W}/(\\mathrm{m}^2\\cdot \\mathrm{K})$, distance $d$ in $\\mathrm{m}$, area $A$ in $\\mathrm{m}^2$, temperatures $T_p$ and $T_\\infty$ in $\\mathrm{K}$.\n\n- Case $1$: $(\\lambda, h, d, A, T_p, T_\\infty) = (0.08, 25.0, 0.005, 0.01, 1200.0, 300.0)$.\n- Case $2$: $(\\lambda, h, d, A, T_p, T_\\infty) = (0.08, 0.0, 0.005, 0.01, 800.0, 300.0)$.\n- Case $3$: $(\\lambda, h, d, A, T_p, T_\\infty) = (0.08, 100000.0, 0.005, 0.01, 800.0, 300.0)$.\n- Case $4$: $(\\lambda, h, d, A, T_p, T_\\infty) = (10.0, 100.0, 0.0001, 0.02, 400.0, 350.0)$.\n- Case $5$: $(\\lambda, h, d, A, T_p, T_\\infty) = (0.2, 50.0, 0.5, 0.05, 450.0, 300.0)$.\n- Case $6$: $(\\lambda, h, d, A, T_p, T_\\infty) = (0.000001, 100.0, 0.01, 0.01, 600.0, 300.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,\\dots,r_6]$, where each $r_i$ is a floating-point number representing $Q_{\\text{face,out}}$ in $\\mathrm{W}$ for case $i$, using the sign convention defined above. No other text should be printed.",
            "solution": "The problem is valid. It is scientifically grounded in the principles of heat transfer, mathematically well-posed, and all necessary parameters for a unique solution are provided. The derivation and implementation proceed as follows.\n\nThe objective is to determine the outward heat flow, $Q_{\\text{face,out}}$, through a boundary face of a control volume. This quantity is a source term in the discrete energy conservation equation for the cell. We are provided with the cell-center temperature $T_p$, the ambient temperature $T_\\infty$, the thermal conductivity of the material $\\lambda$, the convective heat transfer coefficient $h$, the area of the face $A$, and the normal distance $d$ from the cell center to the face.\n\nThe derivation is based on three physical and numerical principles:\n1.  **Fourier's Law of Conduction**: The heat flux, $q_n$, conducted from the interior of the control volume to the boundary face is given by:\n    $$ q_n = -\\lambda \\, \\partial_n T $$\n    where $\\partial_n T$ is the gradient of temperature normal to the face, evaluated at the face. The problem specifies a one-sided linear approximation for this gradient using the cell-center temperature $T_p$ and the unknown boundary face temperature $T_b$, separated by a distance $d$.\n    $$ \\partial_n T \\approx \\frac{T_b - T_p}{d} $$\n    Substituting this approximation into Fourier's Law gives the conductive flux from the cell's interior to the boundary:\n    $$ q_{\\text{n,cond}} = -\\lambda \\left( \\frac{T_b - T_p}{d} \\right) = \\frac{\\lambda}{d} (T_p - T_b) $$\n\n2.  **Newton's Law of Cooling**: The heat flux from the boundary face at temperature $T_b$ to the ambient environment at temperature $T_\\infty$ is given by the Robin boundary condition:\n    $$ q_{\\text{n,conv}} = h (T_b - T_\\infty) $$\n\n3.  **Energy Conservation at the Boundary Face**: At steady state, the heat conducted to the face from the interior must equal the heat convected away from the face to the environment. This ensures a continuous heat flux across the boundary. Therefore, we can equate the two expressions for the flux:\n    $$ q_n = q_{\\text{n,cond}} = q_{\\text{n,conv}} $$\n    $$ \\frac{\\lambda}{d} (T_p - T_b) = h (T_b - T_\\infty) $$\n\nThe equation above contains the unknown boundary temperature $T_b$. To derive a usable expression for the flux source term, we must first solve for $T_b$ in terms of the known quantities.\nRearranging the equation to isolate $T_b$:\n$$ \\frac{\\lambda}{d} T_p - \\frac{\\lambda}{d} T_b = h T_b - h T_\\infty $$\n$$ \\frac{\\lambda}{d} T_p + h T_\\infty = T_b \\left( h + \\frac{\\lambda}{d} \\right) $$\n$$ T_b = \\frac{\\frac{\\lambda}{d} T_p + h T_\\infty}{h + \\frac{\\lambda}{d}} $$\nThis expression reveals that the boundary temperature $T_b$ is a weighted average of the internal temperature $T_p$ and the external ambient temperature $T_\\infty$. The weights are determined by the ratio of conductive to convective thermal resistances.\n\nNow, we substitute this expression for $T_b$ back into one of the flux equations. Using the convective flux equation $q_n = h (T_b - T_\\infty)$ is algebraically more direct:\n$$ q_n = h \\left( \\left[ \\frac{\\frac{\\lambda}{d} T_p + h T_\\infty}{h + \\frac{\\lambda}{d}} \\right] - T_\\infty \\right) $$\nTo simplify, we find a common denominator for the terms inside the parenthesis:\n$$ q_n = h \\left( \\frac{\\frac{\\lambda}{d} T_p + h T_\\infty - T_\\infty \\left(h + \\frac{\\lambda}{d}\\right)}{h + \\frac{\\lambda}{d}} \\right) $$\n$$ q_n = h \\left( \\frac{\\frac{\\lambda}{d} T_p + h T_\\infty - h T_\\infty - \\frac{\\lambda}{d} T_\\infty}{h + \\frac{\\lambda}{d}} \\right) $$\n$$ q_n = h \\left( \\frac{\\frac{\\lambda}{d} (T_p - T_\\infty)}{h + \\frac{\\lambda}{d}} \\right) $$\nMultiplying the numerator and denominator of the combined coefficient by $d$ yields a more elegant form:\n$$ q_n = \\frac{h \\lambda}{h d + \\lambda} (T_p - T_\\infty) $$\nThis expression for the normal heat flux $q_n$ depends only on known parameters.\n\nFinally, the total outward heat flow through the face, $Q_{\\text{face,out}}$, is the flux multiplied by the face area $A$:\n$$ Q_{\\text{face,out}} = q_n A = \\left( \\frac{h \\lambda}{h d + \\lambda} \\right) A (T_p - T_\\infty) $$\nThis is the final equation to be implemented. The sign convention is consistent with the problem statement: if $T_p > T_\\infty$, heat flows out of the domain, and $Q_{\\text{face,out}}$ is positive.\n\nWe can examine two limiting cases to verify the correctness of the formula:\n-   **Adiabatic boundary ($h \\to 0$)**: The formula becomes $Q_{\\text{face,out}} = \\left( \\frac{0 \\cdot \\lambda}{0 \\cdot d + \\lambda} \\right) A (T_p - T_\\infty) = 0$, which correctly represents an insulated surface with zero heat flux.\n-   **Dirichlet boundary ($h \\to \\infty$)**: The formula can be rewritten as $Q_{\\text{face,out}} = \\left( \\frac{\\lambda}{d + \\lambda/h} \\right) A (T_p - T_\\infty)$. As $h \\to \\infty$, the term $\\lambda/h \\to 0$, and the expression approaches $Q_{\\text{face,out}} \\to \\frac{\\lambda}{d} A (T_p - T_\\infty)$. This corresponds to the standard finite volume approximation for conductive heat flux with a fixed boundary temperature $T_b=T_\\infty$.\n\nThe derived formula is physically consistent and robust for all non-negative inputs of $\\lambda$ and $h$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the outward heat flow through a boundary face for several test cases,\n    based on a Finite Volume Method implementation of a Robin boundary condition.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (lambda, h, d, A, T_p, T_infinity) in SI units.\n    # lambda: thermal conductivity [W/(m.K)]\n    # h: heat transfer coefficient [W/(m^2.K)]\n    # d: distance from cell center to boundary [m]\n    # A: area of the boundary face [m^2]\n    # T_p: cell-center temperature [K]\n    # T_infinity: ambient temperature [K]\n    test_cases = [\n        (0.08, 25.0, 0.005, 0.01, 1200.0, 300.0),\n        (0.08, 0.0, 0.005, 0.01, 800.0, 300.0),\n        (0.08, 100000.0, 0.005, 0.01, 800.0, 300.0),\n        (10.0, 100.0, 0.0001, 0.02, 400.0, 350.0),\n        (0.2, 50.0, 0.5, 0.05, 450.0, 300.0),\n        (0.000001, 100.0, 0.01, 0.01, 600.0, 300.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_val, h, d, A, T_p, T_infinity = case\n\n        # The derived formula for the outward heat flow Q_face_out is:\n        # Q_face_out = (h * lambda / (h * d + lambda)) * A * (T_p - T_infinity)\n        \n        # This formula handles the h=0 (adiabatic) and lambda=0 (perfectly insulating)\n        # cases correctly, resulting in a flux of 0.\n        # If both h and lambda are zero, the physical result is 0 flux. The formula\n        # would lead to 0/0, so we handle that case explicitly for robustness,\n        # though it is not present in the test suite.\n        if h == 0.0 and lambda_val == 0.0:\n            q_face_out = 0.0\n        else:\n            # Numerator of the coefficient\n            num_coeff = h * lambda_val\n            # Denominator of the coefficient\n            den_coeff = h * d + lambda_val\n            \n            # Temperature difference driving the heat transfer\n            delta_T = T_p - T_infinity\n            \n            # Handle case where denominator is zero (only if h=0 and lambda=0, already checked)\n            if den_coeff == 0.0:\n                 q_face_out = 0.0\n            else:\n                q_face_out = (num_coeff / den_coeff) * A * delta_T\n\n        results.append(q_face_out)\n\n    # Format the final output string exactly as required.\n    # The map(str, results) converts each float in the list to its string representation.\n    # The ','.join(...) concatenates these strings with a comma.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}