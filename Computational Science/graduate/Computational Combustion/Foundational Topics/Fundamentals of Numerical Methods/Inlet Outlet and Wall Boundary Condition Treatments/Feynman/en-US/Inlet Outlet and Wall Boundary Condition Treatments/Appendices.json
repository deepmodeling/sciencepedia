{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of any finite-volume fluid dynamics solver is the accurate implementation of wall boundary conditions. This practice guides you through the fundamental technique of using \"ghost cells\" to translate physical constraints—such as impermeability, slip/no-slip, and adiabatic/isothermal conditions—into precise numerical values. By deriving ghost-cell properties from first principles, you will gain a practical understanding of how continuum-level physics is robustly imposed at the discrete level, a critical skill for developing or using computational combustion codes .",
            "id": "4032103",
            "problem": "You are asked to implement physically consistent wall boundary condition treatments in the Finite Volume Method (FVM) for Computational Fluid Dynamics (CFD) applied to combustion flows. The focus is on a planar wall boundary with unit normal and the consistent construction of ghost-cell values that enforce physically correct behavior for velocity and temperature fields. The task must be solved from first principles: impermeability and slip versus no-slip behavior for velocity, and adiabatic versus isothermal behavior for temperature. You must formalize and compute ghost-cell values that ensure the correct wall constraints for the solution of compressible flows. You must not rely on any shortcut or pre-stated formulas; instead, your solution must derive what is needed from fundamental laws. Your final program must compute ghost-cell values of tangential velocity and ghost-cell temperatures for a set of specified cases.\n\nThe physical setting is a two-dimensional Cartesian uniform grid with a planar wall aligned arbitrarily. Let the wall be represented locally by a unit normal vector $\\,\\mathbf{n}\\,$ in the plane. Let the fluid velocity at the first interior cell center adjacent to the wall be denoted by $\\,\\mathbf{u}_0\\,$ with components in $\\mathrm{m/s}$, and the temperature at that center be $\\,T_0\\,$ in $\\mathrm{K}$. Let the wall temperature for isothermal cases be $\\,T_w\\,$ in $\\mathrm{K}$. For numerical enforcement in a cell-centered finite-volume discretization, assume the wall lies at the midpoint between the first interior cell center and the ghost cell center along the wall-normal direction. You must compute the ghost-cell values consistent with the following physically defined boundary types:\n\n1. Impermeable wall: the normal velocity at the wall satisfies $\\,\\mathbf{u}\\cdot\\mathbf{n} = 0\\,$.\n2. Slip wall (inviscid): the shear stress vanishes at the wall, which implies zero normal gradient of tangential velocity along the wall-normal direction.\n3. No-slip wall (viscous): both the normal velocity and tangential velocity at the wall must be zero.\n4. Adiabatic wall: the normal heat flux satisfies $\\,\\mathbf{q}\\cdot\\mathbf{n} = 0\\,$, where $\\,\\mathbf{q} = -k\\,\\nabla T\\,$ is the conductive heat flux, implying zero normal temperature gradient at the wall.\n5. Isothermal wall: the temperature at the wall is prescribed and equals $\\,T_w\\,$.\n\nYou must project the interior velocity $\\,\\mathbf{u}_0\\,$ onto the wall-normal and wall-tangential directions, enforce the appropriate wall constraints to determine the ghost-cell values, and then report the scalar tangential component of the ghost-cell velocity and the ghost-cell temperature. You must interpret velocities in $\\mathrm{m/s}$ and temperatures in $\\mathrm{K}$.\n\nYour program must implement the above for the following test suite, where each case specifies the wall normal $\\,\\mathbf{n}\\,$, the interior velocity $\\,\\mathbf{u}_0\\,$, the interior temperature $\\,T_0\\,$, the type of velocity boundary (slip or no-slip), and the type of thermal boundary (adiabatic or isothermal, with a specified $\\,T_w\\,$ where appropriate). The unit normal must be treated generally, and the tangential direction must be chosen orthonormal to the normal.\n\nTest Suite:\n- Case $\\,1\\,$: $\\,\\mathbf{n} = (1,0)\\,$, $\\,\\mathbf{u}_0 = (1.5,-2.0)\\,$ $\\mathrm{m/s}$, $\\,T_0 = 800\\,$ $\\mathrm{K}$, slip and adiabatic.\n- Case $\\,2\\,$: $\\,\\mathbf{n} = (1,0)\\,$, $\\,\\mathbf{u}_0 = (3.0,4.0)\\,$ $\\mathrm{m/s}$, $\\,T_0 = 1100\\,$ $\\mathrm{K}$, slip and isothermal with $\\,T_w = 1000\\,$ $\\mathrm{K}$.\n- Case $\\,3\\,$: $\\,\\mathbf{n} = (1,0)\\,$, $\\,\\mathbf{u}_0 = (0.5,1.0)\\,$ $\\mathrm{m/s}$, $\\,T_0 = 1200\\,$ $\\mathrm{K}$, no-slip and adiabatic.\n- Case $\\,4\\,$: $\\,\\mathbf{n} = (1,0)\\,$, $\\,\\mathbf{u}_0 = (-0.2,-0.8)\\,$ $\\mathrm{m/s}$, $\\,T_0 = 400\\,$ $\\mathrm{K}$, no-slip and isothermal with $\\,T_w = 350\\,$ $\\mathrm{K}$.\n- Case $\\,5\\,$: $\\,\\mathbf{n} = (1,0)\\,$, $\\,\\mathbf{u}_0 = (2.0,0.0)\\,$ $\\mathrm{m/s}$, $\\,T_0 = 900\\,$ $\\mathrm{K}$, slip and adiabatic.\n- Case $\\,6\\,$: $\\,\\mathbf{n} = \\left(\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}\\right)\\,$, $\\,\\mathbf{u}_0 = (1.0,2.0)\\,$ $\\mathrm{m/s}$, $\\,T_0 = 850\\,$ $\\mathrm{K}$, slip and isothermal with $\\,T_w = 800\\,$ $\\mathrm{K}$.\n\nFor each case, compute and return:\n- The scalar tangential component of the ghost-cell velocity (in $\\mathrm{m/s}$), defined with respect to a unit tangential direction orthonormal to $\\,\\mathbf{n}\\,$.\n- The ghost-cell temperature (in $\\mathrm{K}$).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a two-element list $\\,\\big[\\text{ghost tangential velocity}, \\text{ghost temperature}\\big]\\,$. For example, a valid overall format is $\\,\\big[ [a_1,b_1], [a_2,b_2], \\dots \\big]\\,$. Report all numeric values as plain floats without units in the output. Internally, all velocities must be treated in $\\mathrm{m/s}$ and all temperatures in $\\mathrm{K}$.",
            "solution": "We begin from general principles in fluid mechanics and heat transfer. Consider a planar wall in a two-dimensional domain. Let the unit normal be $\\,\\mathbf{n}\\,$ and define a unit tangential direction $\\,\\mathbf{t}\\,$ such that $\\,\\mathbf{t}\\cdot\\mathbf{n} = 0\\,$ and $\\,\\|\\mathbf{t}\\| = 1\\,$. A convenient construction in two dimensions is $\\,\\mathbf{t} = (-n_y, n_x)\\,$ when $\\,\\mathbf{n} = (n_x,n_y)\\,$, followed by normalization in case of numerical round-off.\n\nThe interior velocity at the cell center adjacent to the wall is $\\,\\mathbf{u}_0\\,$. Decompose $\\,\\mathbf{u}_0\\,$ into normal and tangential scalar components via orthogonal projection:\n$$\nu_{n,0} = \\mathbf{u}_0 \\cdot \\mathbf{n}, \\quad u_{t,0} = \\mathbf{u}_0 \\cdot \\mathbf{t}.\n$$\nThe vector form is $\\,\\mathbf{u}_0 = u_{n,0}\\,\\mathbf{n} + u_{t,0}\\,\\mathbf{t}\\,$.\n\nWe now impose the wall physics in the framework of a cell-centered Finite Volume Method (FVM). The ghost cell center is placed symmetrically across the wall at the same distance normal to the wall as the interior cell center, so the wall face lies midway between these two centers. This symmetric placement implies second-order accuracy for linear reconstructions when boundary values are enforced by odd or even reflection consistent with the wall constraints.\n\nVelocity boundary types:\n1. Impermeable wall. The condition $\\,\\mathbf{u}\\cdot\\mathbf{n} = 0\\,$ at the wall must be enforced. In a second-order symmetric ghost-cell placement, the odd reflection about the wall face enforces the wall-face value of the normal velocity to be zero. Denote the ghost-cell normal component as $\\,u_{n,g}\\,$ and the interior as $\\,u_{n,0}\\,$. By odd reflection, the ghost must satisfy\n$$\nu_{n,g} = -\\,u_{n,0}.\n$$\nThis ensures the face value is zero when interpolating linearly between the interior and ghost centers, making the impermeability constraint hold at the wall.\n\n2. Slip wall (inviscid). The wall shear stress vanishes, which means the normal derivative of tangential velocity is zero:\n$$\n\\frac{\\partial u_t}{\\partial n} = 0 \\quad \\text{on the wall}.\n$$\nUnder symmetric placement of interior and ghost centers about the wall, this is enforced by even reflection of the tangential component: the ghost tangential scalar equals the interior tangential scalar,\n$$\nu_{t,g} = u_{t,0}.\n$$\nTogether with $\\,u_{n,g} = -u_{n,0}\\,$, the ghost velocity vector is then\n$$\n\\mathbf{u}_g = u_{n,g}\\,\\mathbf{n} + u_{t,g}\\,\\mathbf{t} = (-u_{n,0})\\,\\mathbf{n} + (u_{t,0})\\,\\mathbf{t}.\n$$\n\n3. No-slip wall (viscous). The velocity at the wall is zero, meaning both normal and tangential components vanish at the wall face. Symmetric ghost-cell placement implies odd reflection for both components:\n$$\nu_{n,g} = -\\,u_{n,0}, \\quad u_{t,g} = -\\,u_{t,0}.\n$$\nThis enforces zero velocity at the wall when interpolated to the face.\n\nThermal boundary types:\n1. Adiabatic wall. The normal heat flux vanishes, $\\,\\mathbf{q}\\cdot\\mathbf{n} = 0\\,$, where $\\,\\mathbf{q} = -k\\nabla T\\,$ and $\\,k\\,$ is the thermal conductivity. Consequently,\n$$\n\\frac{\\partial T}{\\partial n} = 0 \\quad \\text{on the wall}.\n$$\nUnder symmetric placement, this is enforced by even reflection of temperature:\n$$\nT_g = T_0,\n$$\nwhere $\\,T_g\\,$ is the ghost-cell temperature and $\\,T_0\\,$ is the adjacent interior temperature.\n\n2. Isothermal wall. The temperature at the wall face is prescribed as $\\,T_w\\,$. With symmetric placement and linear interpolation to the wall face located midway between interior and ghost centers, the face temperature equals the average of interior and ghost values. Enforcing the wall face to be $\\,T_w\\,$ gives\n$$\n\\frac{T_0 + T_g}{2} = T_w \\quad \\Rightarrow \\quad T_g = 2\\,T_w - T_0.\n$$\n\nAlgorithmic steps for each case:\n1. Normalize the given wall normal $\\,\\mathbf{n}\\,$ to ensure unit length:\n$$\n\\mathbf{n} \\leftarrow \\frac{\\mathbf{n}}{\\|\\mathbf{n}\\|}.\n$$\n2. Construct and normalize the tangential direction $\\,\\mathbf{t}\\,$ as $\\,\\mathbf{t} = (-n_y, n_x)\\,$, then normalize $\\,\\mathbf{t}\\,$ to unit length.\n3. Compute the scalar projections $\\,u_{n,0} = \\mathbf{u}_0 \\cdot \\mathbf{n}\\,$ and $\\,u_{t,0} = \\mathbf{u}_0 \\cdot \\mathbf{t}\\,$.\n4. Apply the velocity boundary condition:\n   - For slip: $\\,u_{n,g} = -u_{n,0}\\,$, $\\,u_{t,g} = u_{t,0}\\,$.\n   - For no-slip: $\\,u_{n,g} = -u_{n,0}\\,$, $\\,u_{t,g} = -u_{t,0}\\,$.\n   The required output for velocity is the scalar $\\,u_{t,g}\\,$.\n5. Apply the thermal boundary condition:\n   - For adiabatic: $\\,T_g = T_0\\,$.\n   - For isothermal: $\\,T_g = 2\\,T_w - T_0\\,$.\n6. Report the pair $\\,\\big[u_{t,g},\\,T_g\\big]\\,$ for each case, interpreting the first as $\\mathrm{m/s}$ and the second as $\\mathrm{K}$, and output all results in a single list-of-lists on one line.\n\nApplying these steps to the specified test suite:\n- Case $\\,1\\,$ (slip, adiabatic) with $\\,\\mathbf{n}=(1,0)\\,$ and $\\,\\mathbf{t}=(0,1)\\,$ yields $\\,u_{t,0} = -2.0\\,$ and hence $\\,u_{t,g} = -2.0\\,$; temperature $\\,T_g = 800\\,$.\n- Case $\\,2\\,$ (slip, isothermal) yields $\\,u_{t,g} = 4.0\\,$; temperature $\\,T_g = 2\\cdot 1000 - 1100 = 900\\,$.\n- Case $\\,3\\,$ (no-slip, adiabatic) yields $\\,u_{t,g} = -1.0\\,$; temperature $\\,T_g = 1200\\,$.\n- Case $\\,4\\,$ (no-slip, isothermal) yields $\\,u_{t,g} = 0.8\\,$; temperature $\\,T_g = 2\\cdot 350 - 400 = 300\\,$.\n- Case $\\,5\\,$ (slip, adiabatic) yields $\\,u_{t,g} = 0.0\\,$; temperature $\\,T_g = 900\\,$.\n- Case $\\,6\\,$ (slip, isothermal) with $\\,\\mathbf{n}=\\left(\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}\\right)\\,$ and $\\,\\mathbf{t}=\\left(-\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}\\right)\\,$ yields $\\,u_{t,0} = \\mathbf{u}_0\\cdot\\mathbf{t} = \\frac{-1+2}{\\sqrt{2}} = \\frac{1}{\\sqrt{2}}\\,$, hence $\\,u_{t,g} = \\frac{1}{\\sqrt{2}}\\,$; temperature $\\,T_g = 2\\cdot 800 - 850 = 750\\,$.\n\nThe final program must compute these results generically from the inputs and print a single line containing a list of two-element lists $\\,\\big[u_{t,g},\\,T_g\\big]\\,$ for all cases, with numeric values as plain floats.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef normalize(vec):\n    \"\"\"Return the normalized vector; if norm is zero, return zero vector.\"\"\"\n    v = np.array(vec, dtype=float)\n    nrm = np.linalg.norm(v)\n    if nrm == 0.0:\n        return v\n    return v / nrm\n\ndef tangential_from_normal(n):\n    \"\"\"Construct a unit tangential vector orthonormal to the unit normal n in 2D.\"\"\"\n    # For n = (nx, ny), a perpendicular vector is t = (-ny, nx)\n    t = np.array([-n[1], n[0]], dtype=float)\n    return normalize(t)\n\ndef ghost_tangential_and_temperature(n, u0, T0, slip, adiabatic, Tw=None):\n    \"\"\"\n    Compute ghost-cell tangential velocity component and temperature.\n    n: wall normal vector (2D), will be normalized.\n    u0: interior velocity vector (2D) in m/s.\n    T0: interior temperature in K.\n    slip: boolean, True for slip wall, False for no-slip wall.\n    adiabatic: boolean, True for adiabatic wall, False for isothermal wall.\n    Tw: wall temperature in K if isothermal; ignored for adiabatic.\n    Returns (u_t_ghost, T_ghost).\n    \"\"\"\n    n_hat = normalize(n)\n    t_hat = tangential_from_normal(n_hat)\n    u0_vec = np.array(u0, dtype=float)\n\n    # Decompose interior velocity\n    u_n0 = float(np.dot(u0_vec, n_hat))\n    u_t0 = float(np.dot(u0_vec, t_hat))\n\n    # Apply velocity boundary condition\n    u_ng = -u_n0  # impermeability always enforced\n    if slip:\n        u_tg = u_t0  # zero gradient of tangential velocity at slip wall\n    else:\n        u_tg = -u_t0  # no-slip: zero wall tangential velocity\n\n    # Apply thermal boundary condition\n    if adiabatic:\n        T_g = float(T0)\n    else:\n        # isothermal: require Tw provided\n        if Tw is None:\n            raise ValueError(\"Isothermal wall requires Tw.\")\n        T_g = float(2.0 * Tw - T0)\n\n    return (u_tg, T_g)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: dict with keys 'n', 'u0', 'T0', 'slip', 'adiabatic', 'Tw' (optional)\n    test_cases = [\n        # Case 1: n=(1,0), u0=(1.5,-2.0), T0=800, slip  adiabatic\n        {\"n\": (1.0, 0.0), \"u0\": (1.5, -2.0), \"T0\": 800.0, \"slip\": True,  \"adiabatic\": True,  \"Tw\": None},\n        # Case 2: n=(1,0), u0=(3.0,4.0), T0=1100, slip  isothermal Tw=1000\n        {\"n\": (1.0, 0.0), \"u0\": (3.0, 4.0),  \"T0\": 1100.0, \"slip\": True,  \"adiabatic\": False, \"Tw\": 1000.0},\n        # Case 3: n=(1,0), u0=(0.5,1.0), T0=1200, no-slip  adiabatic\n        {\"n\": (1.0, 0.0), \"u0\": (0.5, 1.0),  \"T0\": 1200.0, \"slip\": False, \"adiabatic\": True,  \"Tw\": None},\n        # Case 4: n=(1,0), u0=(-0.2,-0.8), T0=400, no-slip  isothermal Tw=350\n        {\"n\": (1.0, 0.0), \"u0\": (-0.2, -0.8), \"T0\": 400.0, \"slip\": False, \"adiabatic\": False, \"Tw\": 350.0},\n        # Case 5: n=(1,0), u0=(2.0,0.0), T0=900, slip  adiabatic\n        {\"n\": (1.0, 0.0), \"u0\": (2.0, 0.0),  \"T0\": 900.0, \"slip\": True,  \"adiabatic\": True,  \"Tw\": None},\n        # Case 6: n=(1/sqrt(2),1/sqrt(2)), u0=(1.0,2.0), T0=850, slip  isothermal Tw=800\n        {\"n\": (1.0/np.sqrt(2.0), 1.0/np.sqrt(2.0)), \"u0\": (1.0, 2.0), \"T0\": 850.0, \"slip\": True, \"adiabatic\": False, \"Tw\": 800.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        u_tg, T_g = ghost_tangential_and_temperature(\n            n=case[\"n\"],\n            u0=case[\"u0\"],\n            T0=case[\"T0\"],\n            slip=case[\"slip\"],\n            adiabatic=case[\"adiabatic\"],\n            Tw=case[\"Tw\"]\n        )\n        # Optional rounding for neat output\n        u_tg_round = round(u_tg, 6)\n        T_g_round = round(T_g, 6)\n        results.append([u_tg_round, T_g_round])\n\n    # Final print statement in the exact required format: single line, list of lists.\n    # Ensure no extra text is printed.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In the simulation of reacting flows, the composition of the mixture entering the domain is a primary driver of the subsequent chemistry and thermodynamics. This exercise addresses the common practical issue of inconsistent inlet species data, where specified mass fractions $Y_k$ may not be physically valid. You will implement a robust correction scheme that enforces both non-negativity and mass conservation ($\\sum_k Y_k = 1$), while simultaneously adjusting the inlet temperature to preserve the mixture's sensible enthalpy—a vital step for ensuring the energy balance of the simulation is not artificially corrupted at the boundary .",
            "id": "4032089",
            "problem": "You are modeling an inlet boundary condition for a reacting perfect-gas mixture in a computational combustion simulation. The inflow species mass fractions may be inconsistent with mass conservation at the inlet, which requires that the species mass fractions sum to unity. You must design and implement a boundary correction and enthalpy-preserving normalization scheme.\n\nAssume the following foundational facts, which you should use as the base of your derivation and design:\n- For a mixture, mass fractions satisfy the identity $\\sum_{k=1}^{N_{\\mathrm{sp}}} Y_k = 1$, where $Y_k$ are species mass fractions and $N_{\\mathrm{sp}}$ is the number of species.\n- The sensible enthalpy of species $k$ is defined relative to a reference temperature $T_{\\mathrm{ref}}$ as $h_k^{\\mathrm{sens}}(T) = \\int_{T_{\\mathrm{ref}}}^{T} c_{p,k}(T')\\, \\mathrm{d}T'$. In this problem, model $c_{p,k}$ as constant for each species, so $h_k^{\\mathrm{sens}}(T) = c_{p,k}\\,(T - T_{\\mathrm{ref}})$.\n- The mixture sensible enthalpy is $h^{\\mathrm{sens}}(T, \\boldsymbol{Y}) = \\sum_{k=1}^{N_{\\mathrm{sp}}} Y_k\\, h_k^{\\mathrm{sens}}(T)$.\n\nYour task is to:\n1. Compute the mass conservation discrepancy at the inlet, defined as $\\varepsilon = 1 - \\sum_{k=1}^{N_{\\mathrm{sp}}} Y_k^{\\mathrm{in}}$, where $Y_k^{\\mathrm{in}}$ are the provided inflow mass fractions.\n2. Correct the species mass fractions by:\n   - Enforcing non-negativity: any $Y_k^{\\mathrm{in}}  0$ must be clipped to $0$ prior to normalization.\n   - Renormalizing the clipped inflow mass fractions to obtain corrected mass fractions $\\tilde{Y}_k$ that satisfy $\\sum_{k} \\tilde{Y}_k = 1$.\n3. Preserve the inflow mixture sensible enthalpy across this correction by adjusting the static temperature from $T_{\\mathrm{in}}$ to a corrected value $\\tilde{T}$ such that $h^{\\mathrm{sens}}(T_{\\mathrm{in}}, \\boldsymbol{Y}^{\\mathrm{clip}}) = h^{\\mathrm{sens}}(\\tilde{T}, \\tilde{\\boldsymbol{Y}})$, where $\\boldsymbol{Y}^{\\mathrm{clip}}$ are the clipped (non-negative) inflow mass fractions used to define the target enthalpy. Use the constant-specific-heat model to derive and compute $\\tilde{T}$ exactly.\n\nAll temperatures must be expressed in Kelvin ($\\mathrm{K}$). The reference temperature is $T_{\\mathrm{ref}} = 298.15$ $\\mathrm{K}$. Specific heats at constant pressure $c_{p,k}$ are constant and given in $\\mathrm{J}\\, \\mathrm{kg}^{-1}\\, \\mathrm{K}^{-1}$ for the five-species set $\\{ \\mathrm{N_2}, \\mathrm{O_2}, \\mathrm{CH_4}, \\mathrm{CO_2}, \\mathrm{H_2O} \\}$ as:\n- $\\mathrm{N_2}$: $c_{p,\\mathrm{N_2}} = 1040.0$\n- $\\mathrm{O_2}$: $c_{p,\\mathrm{O_2}} = 918.0$\n- $\\mathrm{CH_4}$: $c_{p,\\mathrm{CH_4}} = 2220.0$\n- $\\mathrm{CO_2}$: $c_{p,\\mathrm{CO_2}} = 846.0$\n- $\\mathrm{H_2O}$: $c_{p,\\mathrm{H_2O}} = 1850.0$\n\nImplement the above using the following test suite of inlet states. Each test case provides $T_{\\mathrm{in}}$ and the inflow mass fractions in the species order $\\{ \\mathrm{N_2}, \\mathrm{O_2}, \\mathrm{CH_4}, \\mathrm{CO_2}, \\mathrm{H_2O} \\}$:\n\n- Test case A (general case with sum greater than unity): $T_{\\mathrm{in}} = 900.0$ $\\mathrm{K}$, $\\boldsymbol{Y}^{\\mathrm{in}} = [0.75, 0.21, 0.03, 0.02, 0.0]$.\n- Test case B (general case with sum less than unity): $T_{\\mathrm{in}} = 1200.0$ $\\mathrm{K}$, $\\boldsymbol{Y}^{\\mathrm{in}} = [0.70, 0.19, 0.06, 0.03, 0.01]$.\n- Test case C (negative entry due to numerical noise): $T_{\\mathrm{in}} = 800.0$ $\\mathrm{K}$, $\\boldsymbol{Y}^{\\mathrm{in}} = [0.77, 0.23, -0.01, 0.01, 0.0]$.\n- Test case D (mild overspecification): $T_{\\mathrm{in}} = 1000.0$ $\\mathrm{K}$, $\\boldsymbol{Y}^{\\mathrm{in}} = [0.78, 0.22, 0.01, 0.0, 0.0]$.\n\nYour program must:\n- For each test case, compute and return the triple consisting of the discrepancy $\\varepsilon$, the corrected temperature $\\tilde{T}$ that preserves sensible enthalpy, and the corrected mass fraction vector $\\tilde{\\boldsymbol{Y}}$ after clipping and normalization, all rounded to six decimal places.\n- Produce a single line of output containing a list of these triples for the four test cases, as a comma-separated list enclosed in square brackets. Within each triple, the corrected mass fractions must appear as a sub-list in the species order $\\{ \\mathrm{N_2}, \\mathrm{O_2}, \\mathrm{CH_4}, \\mathrm{CO_2}, \\mathrm{H_2O} \\}$.\n\nFor example, the final output format must be:\n$[ [\\varepsilon_A, \\tilde{T}_A, [\\tilde{Y}_{A,\\mathrm{N_2}}, \\tilde{Y}_{A,\\mathrm{O_2}}, \\tilde{Y}_{A,\\mathrm{CH_4}}, \\tilde{Y}_{A,\\mathrm{CO_2}}, \\tilde{Y}_{A,\\mathrm{H_2O}}]], [\\varepsilon_B, \\tilde{T}_B, [\\dots]], [\\varepsilon_C, \\tilde{T}_C, [\\dots]], [\\varepsilon_D, \\tilde{T}_D, [\\dots]] ]$\nwhere all numeric entries are decimal numbers in Kelvin for temperatures and dimensionless for mass fractions and discrepancy, each rounded to six decimal places.",
            "solution": "The problem statement is evaluated to be valid. It is scientifically grounded in the principles of thermodynamics and mass conservation, is well-posed with a clear and complete set of givens, and is expressed in objective, formal language. A unique and meaningful solution can be derived and computed.\n\nThe task is to design and implement a numerical scheme for correcting inlet boundary conditions for a reacting gas mixture. The scheme must ensure mass conservation and preserve the mixture's sensible enthalpy by adjusting the inlet temperature. The process involves three sequential steps: computing the mass conservation error, correcting the species mass fractions, and adjusting the temperature.\n\n### 1. Mass Conservation Discrepancy\n\nThe fundamental principle of mass conservation for a multi-species mixture requires that the sum of all species mass fractions, $Y_k$, equals unity.\n$$\n\\sum_{k=1}^{N_{\\mathrm{sp}}} Y_k = 1\n$$\nwhere $N_{\\mathrm{sp}}$ is the total number of species. The provided inflow mass fractions, denoted $Y_k^{\\mathrm{in}}$, may violate this condition. The discrepancy, $\\varepsilon$, is defined as the deviation from unity of this sum:\n$$\n\\varepsilon = 1 - \\sum_{k=1}^{N_{\\mathrm{sp}}} Y_k^{\\mathrm{in}}\n$$\n\n### 2. Mass Fraction Correction Scheme\n\nA physically valid set of mass fractions must satisfy two conditions: non-negativity ($Y_k \\ge 0$ for all $k$) and the sum-to-one constraint. The correction is performed in two sub-steps.\n\n#### 2.1. Non-negativity Enforcement (Clipping)\n\nNumerical errors or user input can lead to small negative mass fractions. These are unphysical and must be eliminated. Each inflow mass fraction $Y_k^{\\mathrm{in}}$ is clipped to zero if it is negative. The resulting clipped mass fractions, $Y_k^{\\mathrm{clip}}$, are defined as:\n$$\nY_k^{\\mathrm{clip}} = \\max(0, Y_k^{\\mathrm{in}})\n$$\n\n#### 2.2. Normalization\n\nAfter clipping, the sum of the mass fractions, $S^{\\mathrm{clip}} = \\sum_{k=1}^{N_{\\mathrm{sp}}} Y_k^{\\mathrm{clip}}$, may not be equal to $1$. To enforce the sum-to-one constraint, the clipped mass fractions are normalized. The final, corrected mass fractions, $\\tilde{Y}_k$, are obtained by dividing each $Y_k^{\\mathrm{clip}}$ by their sum $S^{\\mathrm{clip}}$:\n$$\n\\tilde{Y}_k = \\frac{Y_k^{\\mathrm{clip}}}{S^{\\mathrm{clip}}} = \\frac{Y_k^{\\mathrm{clip}}}{\\sum_{j=1}^{N_{\\mathrm{sp}}} Y_j^{\\mathrm{clip}}}\n$$\nThis operation guarantees that $\\sum_{k=1}^{N_{\\mathrm{sp}}} \\tilde{Y}_k = 1$, provided that $S^{\\mathrm{clip}} > 0$. For the given test cases, this condition is met.\n\n### 3. Enthalpy-Preserving Temperature Correction\n\nThe correction of mass fractions alters the composition of the inflow mixture. To maintain the original energy content of the flow, the inlet temperature must be adjusted. This is achieved by preserving the mixture sensible enthalpy.\n\nThe sensible enthalpy of species $k$, $h_k^{\\mathrm{sens}}$, under the constant specific heat assumption, is given by:\n$$\nh_k^{\\mathrm{sens}}(T) = c_{p,k}(T - T_{\\mathrm{ref}})\n$$\nwhere $c_{p,k}$ is the constant-pressure specific heat of species $k$, $T$ is the static temperature, and $T_{\\mathrm{ref}}$ is the reference temperature for enthalpy, given as $298.15 \\, \\mathrm{K}$.\n\nThe mixture sensible enthalpy, $h^{\\mathrm{sens}}$, is the mass-fraction-weighted sum of the species enthalpies:\n$$\nh^{\\mathrm{sens}}(T, \\boldsymbol{Y}) = \\sum_{k=1}^{N_{\\mathrm{sp}}} Y_k h_k^{\\mathrm{sens}}(T) = \\sum_{k=1}^{N_{\\mathrm{sp}}} Y_k c_{p,k} (T - T_{\\mathrm{ref}}) = (T - T_{\\mathrm{ref}}) \\sum_{k=1}^{N_{\\mathrm{sp}}} Y_k c_{p,k}\n$$\n\nThe problem requires that the sensible enthalpy of the mixture defined by the clipped mass fractions $\\boldsymbol{Y}^{\\mathrm{clip}}$ at the original inlet temperature $T_{\\mathrm{in}}$ is equal to the sensible enthalpy of the mixture with corrected mass fractions $\\tilde{\\boldsymbol{Y}}$ at a new, corrected temperature $\\tilde{T}$. This conservation principle is expressed as:\n$$\nh^{\\mathrm{sens}}(T_{\\mathrm{in}}, \\boldsymbol{Y}^{\\mathrm{clip}}) = h^{\\mathrm{sens}}(\\tilde{T}, \\tilde{\\boldsymbol{Y}})\n$$\n\nSubstituting the definition of mixture sensible enthalpy gives:\n$$\n(T_{\\mathrm{in}} - T_{\\mathrm{ref}}) \\sum_{k=1}^{N_{\\mathrm{sp}}} Y_k^{\\mathrm{clip}} c_{p,k} = (\\tilde{T} - T_{\\mathrm{ref}}) \\sum_{k=1}^{N_{\\mathrm{sp}}} \\tilde{Y}_k c_{p,k}\n$$\n\nWe introduce the mixture specific heat $c_{p, \\mathrm{mix}}(\\boldsymbol{Y}) = \\sum_k Y_k c_{p,k}$. The equation becomes:\n$$\n(T_{\\mathrm{in}} - T_{\\mathrm{ref}}) \\, c_{p, \\mathrm{mix}}(\\boldsymbol{Y}^{\\mathrm{clip}}) = (\\tilde{T} - T_{\\mathrm{ref}}) \\, c_{p, \\mathrm{mix}}(\\tilde{\\boldsymbol{Y}})\n$$\n\nFrom the normalization step, we have $\\tilde{Y}_k = Y_k^{\\mathrm{clip}} / S^{\\mathrm{clip}}$. Therefore, the corrected mixture specific heat can be related to the clipped mixture specific heat:\n$$\nc_{p, \\mathrm{mix}}(\\tilde{\\boldsymbol{Y}}) = \\sum_{k=1}^{N_{\\mathrm{sp}}} \\tilde{Y}_k c_{p,k} = \\sum_{k=1}^{N_{\\mathrm{sp}}} \\frac{Y_k^{\\mathrm{clip}}}{S^{\\mathrm{clip}}} c_{p,k} = \\frac{1}{S^{\\mathrm{clip}}} \\sum_{k=1}^{N_{\\mathrm{sp}}} Y_k^{\\mathrm{clip}} c_{p,k} = \\frac{c_{p, \\mathrm{mix}}(\\boldsymbol{Y}^{\\mathrm{clip}})}{S^{\\mathrm{clip}}}\n$$\n\nSubstituting this relationship back into the enthalpy conservation equation:\n$$\n(T_{\\mathrm{in}} - T_{\\mathrm{ref}}) \\, c_{p, \\mathrm{mix}}(\\boldsymbol{Y}^{\\mathrm{clip}}) = (\\tilde{T} - T_{\\mathrm{ref}}) \\, \\frac{c_{p, \\mathrm{mix}}(\\boldsymbol{Y}^{\\mathrm{clip}})}{S^{\\mathrm{clip}}}\n$$\n\nAssuming $c_{p, \\mathrm{mix}}(\\boldsymbol{Y}^{\\mathrm{clip}}) > 0$, which is true as all $c_{p,k} > 0$ and at least one $Y_k^{\\mathrm{clip}} > 0$, we can cancel this term from both sides:\n$$\nT_{\\mathrm{in}} - T_{\\mathrm{ref}} = \\frac{\\tilde{T} - T_{\\mathrm{ref}}}{S^{\\mathrm{clip}}}\n$$\n\nSolving for the corrected temperature $\\tilde{T}$ yields the final, exact expression:\n$$\n\\tilde{T} = T_{\\mathrm{ref}} + S^{\\mathrm{clip}} (T_{\\mathrm{in}} - T_{\\mathrm{ref}})\n$$\nThis elegant result shows that the temperature correction factor is simply the sum of the clipped mass fractions, $S^{\\mathrm{clip}}$. The entire procedure can now be implemented algorithmically.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes boundary condition corrections for reacting flow inlets.\n\n    For each test case, the function calculates:\n    1. The mass conservation discrepancy (epsilon).\n    2. The corrected mass fractions (Y_tilde) by clipping negative values and normalizing.\n    3. The corrected temperature (T_tilde) that preserves the mixture sensible enthalpy.\n    \"\"\"\n    \n    # Foundational constants and definitions\n    T_ref = 298.15  # K\n    species = ['N2', 'O2', 'CH4', 'CO2', 'H2O']\n    # Specific heats at constant pressure [J kg^-1 K^-1] for the species set\n    cp_k = np.array([1040.0, 918.0, 2220.0, 846.0, 1850.0])\n\n    # Test suite of inlet states\n    # Each case: (T_in [K], Y_in list)\n    test_cases = [\n        # Test case A\n        (900.0, [0.75, 0.21, 0.03, 0.02, 0.0]),\n        # Test case B\n        (1200.0, [0.70, 0.19, 0.06, 0.03, 0.01]),\n        # Test case C\n        (800.0, [0.77, 0.23, -0.01, 0.01, 0.0]),\n        # Test case D\n        (1000.0, [0.78, 0.22, 0.01, 0.0, 0.0]),\n    ]\n\n    # List to store the string representation of each case's result\n    formatted_results = []\n\n    for T_in, Y_in_list in test_cases:\n        Y_in = np.array(Y_in_list)\n\n        # 1. Compute the mass conservation discrepancy\n        epsilon = 1.0 - np.sum(Y_in)\n\n        # 2. Correct the species mass fractions\n        # 2.1. Enforce non-negativity (clipping)\n        Y_clip = np.maximum(0.0, Y_in)\n\n        # 2.2. Renormalize to obtain corrected mass fractions\n        S_clip = np.sum(Y_clip)\n        \n        if S_clip > 0:\n            Y_tilde = Y_clip / S_clip\n        else:\n            # Handle edge case where all mass fractions are zero or negative.\n            # In this case, mass fractions remain zero and no normalization is possible.\n            # Temperature is not adjusted as enthalpy is zero.\n            Y_tilde = np.zeros_like(Y_in)\n            \n        # 3. Preserve enthalpy by correcting the temperature\n        if S_clip > 0:\n             # The derivation simplifies to T_tilde = T_ref + S_clip * (T_in - T_ref)\n            T_tilde = T_ref + S_clip * (T_in - T_ref)\n        else:\n            T_tilde = T_in\n\n        # Format results to six decimal places as required by the problem statement.\n        eps_str = f\"{epsilon:.6f}\"\n        T_tilde_str = f\"{T_tilde:.6f}\"\n        \n        # Format the mass fraction vector as a string list\n        y_tilde_str_list = [f\"{y:.6f}\" for y in Y_tilde]\n        y_tilde_list_str = f\"[{','.join(y_tilde_str_list)}]\"\n        \n        # Combine into the final string format for the current test case\n        case_result_str = f\"[{eps_str},{T_tilde_str},{y_tilde_list_str}]\"\n        formatted_results.append(case_result_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After implementing numerical methods, how can we be certain they are correct? This advanced practice introduces the Method of Manufactured Solutions (MMS), a rigorous and indispensable technique for code verification. You will design a problem with a known analytical solution to formally test the accuracy of your finite difference scheme, including the often-tricky implementation of various boundary condition types. By measuring the convergence rate of the error, you will learn to quantitatively verify that your code achieves its theoretical order of accuracy, a hallmark of high-quality scientific software development .",
            "id": "4032140",
            "problem": "You are asked to design and verify a boundary condition implementation by the Method of Manufactured Solutions in a steady, two-dimensional advection–diffusion problem representative of scalar transport in computational combustion. Consider the rectangular domain $\\Omega = [0,1] \\times [0,1]$ with Cartesian coordinates $(x,y)$ and constant advection velocities $(u,v)$ and constant diffusivity $\\Gamma  0$. The governing equation is\n$$ u \\,\\frac{\\partial \\phi}{\\partial x} + v \\,\\frac{\\partial \\phi}{\\partial y} - \\nabla \\cdot \\left( \\Gamma \\nabla \\phi \\right) = S(x,y), \\quad (x,y) \\in \\Omega,$$\nwhere $\\phi(x,y)$ is a dimensionless scalar that may represent a mixture fraction, species mass fraction, or temperature surrogate.\n\nUse the Method of Manufactured Solutions to impose analytic inlet, outlet, and wall boundary conditions. Let the exact manufactured solution be\n$$ \\phi_{\\text{exact}}(x,y) = \\sin(\\pi x)\\,\\cos(2\\pi y) + x^2 - \\tfrac{1}{2} y. $$\nDerive the analytic source term $S(x,y)$ so that $\\phi_{\\text{exact}}$ is the exact solution of the partial differential equation for the given $(u,v,\\Gamma)$. Impose boundary conditions that are exactly satisfied by $\\phi_{\\text{exact}}$:\n- Inlet at $x=0$ (Dirichlet): $\\phi(0,y) = \\phi_{\\text{exact}}(0,y)$.\n- Outlet at $x=1$ (Neumann): $\\dfrac{\\partial \\phi}{\\partial x}(1,y) = \\dfrac{\\partial \\phi_{\\text{exact}}}{\\partial x}(1,y)$.\n- Walls at $y=0$ and $y=1$ (Robin): for $y=0$ with outward normal $\\mathbf{n}=(0,-1)$ and coefficient $a_b \\ge 0$, enforce\n$$ \\mathbf{n}\\cdot \\nabla \\phi + a_b\\,\\phi = \\mathbf{n}\\cdot \\nabla \\phi_{\\text{exact}} + a_b\\,\\phi_{\\text{exact}}, $$\nand for $y=1$ with outward normal $\\mathbf{n}=(0,+1)$ and coefficient $a_t \\ge 0$, enforce\n$$ \\mathbf{n}\\cdot \\nabla \\phi + a_t\\,\\phi = \\mathbf{n}\\cdot \\nabla \\phi_{\\text{exact}} + a_t\\,\\phi_{\\text{exact}}. $$\nAt the two corner points $(0,0)$, $(0,1)$, $(1,0)$, and $(1,1)$, give precedence to the $x=0$ and $x=1$ boundary conditions as specified above.\n\nDiscretize the equation with a second-order finite difference method on a uniform grid with $N_x \\times N_y$ nodal unknowns including the boundary nodes, using central differences for interior advection and diffusion and one-sided second-order stencils to impose the Neumann and Robin boundary conditions. Specifically:\n- For interior nodes $(i,j)$ with $1 \\le i \\le N_x-2$ and $1 \\le j \\le N_y-2$, approximate the derivatives with second-order central differences.\n- For the outlet Neumann condition at $x=1$ (index $i=N_x-1$), enforce the boundary condition equation using a second-order one-sided backward difference for $\\dfrac{\\partial \\phi}{\\partial x}$.\n- For the wall Robin conditions at $y=0$ and $y=1$ (indices $j=0$ and $j=N_y-1$), enforce the boundary condition equation using second-order one-sided differences for the normal derivative.\n\nAll quantities are dimensionless, so no unit conversion is required.\n\nImplement a program that:\n- Constructs the analytic source $S(x,y)$ and boundary data from $\\phi_{\\text{exact}}$ and its derivatives.\n- Assembles and solves the resulting linear system for three successively refined grids with $(N_x,N_y) \\in \\{(16,16),(32,32),(64,64)\\}$.\n- Computes the following error norms between the numerical solution $\\phi_h$ and the exact solution $\\phi_{\\text{exact}}$ evaluated on the same grid:\n  - The discrete $L^2$ norm defined by\n    $$ \\| e \\|_{2,h} = \\left( \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} \\left( \\phi_h(x_i,y_j) - \\phi_{\\text{exact}}(x_i,y_j) \\right)^2 \\,\\Delta x \\,\\Delta y \\right)^{1/2}, $$\n    where $\\Delta x = 1/(N_x-1)$ and $\\Delta y = 1/(N_y-1)$.\n  - The discrete $L^\\infty$ norm defined by\n    $$ \\| e \\|_{\\infty,h} = \\max_{0 \\le i \\le N_x-1,\\,0 \\le j \\le N_y-1} \\left| \\phi_h(x_i,y_j) - \\phi_{\\text{exact}}(x_i,y_j) \\right|. $$\n- Computes the observed order of accuracy between the two finest grids for each norm as\n  $$ p = \\frac{\\log\\left( E_{h} / E_{h/2} \\right)}{\\log(2)}, $$\n  where $E_h$ is the error norm on grid spacing $h$ (use $\\Delta x$ as the representative spacing; both $\\Delta x$ and $\\Delta y$ are halved between refinements).\n\nTest Suite:\nUse the following three parameter sets $(u,v,\\Gamma,a_b,a_t)$:\n- Case A (balanced advection–diffusion and mixed walls): $(u,v,\\Gamma,a_b,a_t) = (1.0, 0.5, 0.1, 0.8, 0.3)$.\n- Case B (diffusion dominated with pure Neumann walls): $(u,v,\\Gamma,a_b,a_t) = (0.2, 0.1, 1.0, 0.0, 0.0)$.\n- Case C (advection dominated with strong wall sink): $(u,v,\\Gamma,a_b,a_t) = (1.5, 0.7, 0.05, 5.0, 2.0)$.\n\nRequired Final Output Format:\nYour program should produce a single line of output containing the results for the three cases as a list of lists, where each inner list contains two floating-point numbers $[p_{L^2}, p_{L^\\infty}]$ computed between the $(32,32)$ and $(64,64)$ grids. For example, the output format must be exactly\n$$ [ [p_{A,L^2},p_{A,L^\\infty}], [p_{B,L^2},p_{B,L^\\infty}], [p_{C,L^2},p_{C,L^\\infty}] ]. $$\n\nNo user input should be required; all data must be generated internally by the program.",
            "solution": "The user-provided problem has been analyzed and validated.\n\n### Step 1: Extract Givens\n- **Governing Equation**: Steady $2$D advection-diffusion equation $u \\,\\frac{\\partial \\phi}{\\partial x} + v \\,\\frac{\\partial \\phi}{\\partial y} - \\nabla \\cdot \\left( \\Gamma \\nabla \\phi \\right) = S(x,y)$ for a scalar $\\phi(x,y)$ on the domain $\\Omega = [0,1] \\times [0,1]$.\n- **Parameters**: Advection velocities $(u,v)$ and diffusivity $\\Gamma > 0$ are constant.\n- **Manufactured Solution**: $\\phi_{\\text{exact}}(x,y) = \\sin(\\pi x)\\,\\cos(2\\pi y) + x^2 - \\tfrac{1}{2} y$.\n- **Boundary Conditions**:\n    - **Inlet ($x=0$)**: Dirichlet, $\\phi(0,y) = \\phi_{\\text{exact}}(0,y)$.\n    - **Outlet ($x=1$)**: Neumann, $\\dfrac{\\partial \\phi}{\\partial x}(1,y) = \\dfrac{\\partial \\phi_{\\text{exact}}}{\\partial x}(1,y)$.\n    - **Bottom Wall ($y=0$)**: Robin, $-\\dfrac{\\partial \\phi}{\\partial y} + a_b\\,\\phi = -\\dfrac{\\partial \\phi_{\\text{exact}}}{\\partial y} + a_b\\,\\phi_{\\text{exact}}$, for coefficient $a_b \\ge 0$.\n    - **Top Wall ($y=1$)**: Robin, $\\dfrac{\\partial \\phi}{\\partial y} + a_t\\,\\phi = \\dfrac{\\partial \\phi_{\\text{exact}}}{\\partial y} + a_t\\,\\phi_{\\text{exact}}$, for coefficient $a_t \\ge 0$.\n- **Corner Treatment**: Conditions at $x=0$ and $x=1$ take precedence at corner points.\n- **Discretization**: Second-order finite differences on a uniform $N_x \\times N_y$ grid.\n    - Interior: Central differences.\n    - Outlet ($x=1$): Second-order one-sided backward difference for $\\frac{\\partial \\phi}{\\partial x}$.\n    - Walls ($y=0, y=1$): Second-order one-sided differences for $\\frac{\\partial \\phi}{\\partial y}$.\n- **Grid Refinement**: Solve for $(N_x,N_y) \\in \\{(16,16),(32,32),(64,64)\\}$.\n- **Error Analysis**: Compute discrete $L^2$ and $L^\\infty$ error norms and the order of accuracy $p = \\frac{\\log\\left( E_{h} / E_{h/2} \\right)}{\\log(2)}$ between the two finest grids.\n- **Test Cases**:\n    - Case A: $(u,v,\\Gamma,a_b,a_t) = (1.0, 0.5, 0.1, 0.8, 0.3)$.\n    - Case B: $(u,v,\\Gamma,a_b,a_t) = (0.2, 0.1, 1.0, 0.0, 0.0)$.\n    - Case C: $(u,v,\\Gamma,a_b,a_t) = (1.5, 0.7, 0.05, 5.0, 2.0)$.\n- **Output Format**: A list of lists: $[ [p_{A,L^2},p_{A,L^\\infty}], [p_{B,L^2},p_{B,L^\\infty}], [p_{C,L^2},p_{C,L^\\infty}] ]$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective. It specifies a standard partial differential equation from transport phenomena and employs the Method of Manufactured Solutions, a standard verification technique in computational science. All required data, boundary conditions, numerical methods, and analysis procedures are provided, making the problem self-contained and unambiguous. The physical and mathematical setup is consistent and sound.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A reasoned solution will be provided.\n\n---\n\nThe solution proceeds by first deriving the analytical source term and boundary condition data from the manufactured solution. Then, the governing equation and boundary conditions are discretized using a second-order finite difference method, leading to a large sparse linear system of equations. This system is solved for three grid resolutions, and the numerical error is analyzed to determine the observed order of accuracy.\n\n**Step 1: Derivation of the Source Term**\nThe governing equation is $u \\,\\frac{\\partial \\phi}{\\partial x} + v \\,\\frac{\\partial \\phi}{\\partial y} - \\Gamma \\left( \\frac{\\partial^2 \\phi}{\\partial x^2} + \\frac{\\partial^2 \\phi}{\\partial y^2} \\right) = S(x,y)$. To ensure $\\phi_{\\text{exact}}$ is the true solution, we substitute it into the left-hand side to find the required source term $S(x,y)$.\nThe manufactured solution is $\\phi_{\\text{exact}}(x,y) = \\sin(\\pi x)\\,\\cos(2\\pi y) + x^2 - \\frac{1}{2} y$. We compute its partial derivatives:\n$$ \\frac{\\partial \\phi_{\\text{exact}}}{\\partial x} = \\pi \\cos(\\pi x)\\cos(2\\pi y) + 2x $$\n$$ \\frac{\\partial \\phi_{\\text{exact}}}{\\partial y} = -2\\pi \\sin(\\pi x)\\sin(2\\pi y) - \\frac{1}{2} $$\n$$ \\frac{\\partial^2 \\phi_{\\text{exact}}}{\\partial x^2} = -\\pi^2 \\sin(\\pi x)\\cos(2\\pi y) + 2 $$\n$$ \\frac{\\partial^2 \\phi_{\\text{exact}}}{\\partial y^2} = -4\\pi^2 \\sin(\\pi x)\\cos(2\\pi y) $$\nThe Laplacian is $\\nabla^2 \\phi_{\\text{exact}} = \\frac{\\partial^2 \\phi_{\\text{exact}}}{\\partial x^2} + \\frac{\\partial^2 \\phi_{\\text{exact}}}{\\partial y^2} = 2 - 5\\pi^2 \\sin(\\pi x)\\cos(2\\pi y)$.\nSubstituting these into the PDE gives the source term:\n$$ S(x,y) = u \\left( \\pi \\cos(\\pi x)\\cos(2\\pi y) + 2x \\right) + v \\left( -2\\pi \\sin(\\pi x)\\sin(2\\pi y) - \\frac{1}{2} \\right) - \\Gamma \\left( 2 - 5\\pi^2 \\sin(\\pi x)\\cos(2\\pi y) \\right) $$\n\n**Step 2: Specification of Boundary Conditions**\nThe boundary conditions are defined by evaluating $\\phi_{\\text{exact}}$ and its normal derivatives on the boundaries of the domain $\\Omega = [0,1] \\times [0,1]$.\n- **Inlet ($x=0$):** $\\phi(0,y) = \\phi_{\\text{exact}}(0,y) = \\sin(0)\\cos(2\\pi y) + 0^2 - \\frac{1}{2}y = -\\frac{1}{2}y$. This is a Dirichlet condition.\n- **Outlet ($x=1$):** $\\frac{\\partial \\phi}{\\partial x}(1,y) = \\frac{\\partial \\phi_{\\text{exact}}}{\\partial x}(1,y) = \\pi\\cos(\\pi)\\cos(2\\pi y) + 2(1) = 2 - \\pi\\cos(2\\pi y)$. This is a Neumann condition.\n- **Bottom Wall ($y=0$):** The Robin condition is $-\\frac{\\partial \\phi}{\\partial y} + a_b\\,\\phi = G_b(x)$, where $G_b(x) = -\\frac{\\partial \\phi_{\\text{exact}}}{\\partial y}(x,0) + a_b \\phi_{\\text{exact}}(x,0)$.\n$$ \\frac{\\partial \\phi_{\\text{exact}}}{\\partial y}(x,0) = -2\\pi\\sin(\\pi x)\\sin(0) - \\frac{1}{2} = -\\frac{1}{2} $$\n$$ \\phi_{\\text{exact}}(x,0) = \\sin(\\pi x)\\cos(0) + x^2 - 0 = \\sin(\\pi x) + x^2 $$\nThus, $G_b(x) = -(-\\frac{1}{2}) + a_b(\\sin(\\pi x) + x^2) = \\frac{1}{2} + a_b(\\sin(\\pi x) + x^2)$.\n- **Top Wall ($y=1$):** The Robin condition is $\\frac{\\partial \\phi}{\\partial y} + a_t\\,\\phi = G_t(x)$, where $G_t(x) = \\frac{\\partial \\phi_{\\text{exact}}}{\\partial y}(x,1) + a_t \\phi_{\\text{exact}}(x,1)$.\n$$ \\frac{\\partial \\phi_{\\text{exact}}}{\\partial y}(x,1) = -2\\pi\\sin(\\pi x)\\sin(2\\pi) - \\frac{1}{2} = -\\frac{1}{2} $$\n$$ \\phi_{\\text{exact}}(x,1) = \\sin(\\pi x)\\cos(2\\pi) + x^2 - \\frac{1}{2} = \\sin(\\pi x) + x^2 - \\frac{1}{2} $$\nThus, $G_t(x) = -\\frac{1}{2} + a_t(\\sin(\\pi x) + x^2 - \\frac{1}{2})$.\n\n**Step 3: Finite Difference Discretization**\nWe discretize the domain with a uniform grid of $N_x \\times N_y$ nodes, where $x_i = i\\Delta x$ and $y_j = j\\Delta y$ for $i \\in [0, N_x-1]$, $j \\in [0, N_y-1]$. The grid spacings are $\\Delta x = 1/(N_x-1)$ and $\\Delta y = 1/(N_y-1)$. The unknowns $\\phi_{i,j} = \\phi(x_i, y_j)$ are flattened into a single vector $\\mathbf{\\Phi}$ of size $N_x N_y$ using a row-major mapping $k = j \\cdot N_x + i$. We construct a linear system $A\\mathbf{\\Phi}=\\mathbf{b}$ by writing one equation for each node $(i,j)$.\n\n- **Interior Nodes ($1 \\le i \\le N_x-2, 1 \\le j \\le N_y-2$):** We use second-order central differences for all derivatives. The discretized PDE at node $(i,j)$ is:\n$$ u \\left( \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2\\Delta x} \\right) + v \\left( \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2\\Delta y} \\right) - \\Gamma \\left( \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{\\Delta x^2} + \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{\\Delta y^2} \\right) = S(x_i, y_j) $$\nThis equation is rearranged to populate the row $k = j \\cdot N_x + i$ of matrix $A$ and vector $\\mathbf{b}$.\n\n- **Boundary Nodes:**\n    - **Inlet ($i=0$):** The Dirichlet condition gives a simple equation: $\\phi_{0,j} = -\\frac{1}{2} y_j$.\n    - **Outlet ($i=N_x-1$):** A second-order backward difference for the Neumann condition yields: $\\frac{3\\phi_{N_x-1,j} - 4\\phi_{N_x-2,j} + \\phi_{N_x-3,j}}{2\\Delta x} = G_o(y_j)$, where $G_o(y) = 2 - \\pi\\cos(2\\pi y)$.\n    - **Bottom Wall ($j=0, 1 \\le i \\le N_x-2$):** A second-order forward difference for the Robin condition gives: $-\\left(\\frac{-3\\phi_{i,0} + 4\\phi_{i,1} - \\phi_{i,2}}{2\\Delta y}\\right) + a_b\\phi_{i,0} = G_b(x_i)$.\n    - **Top Wall ($j=N_y-1, 1 \\le i \\le N_x-2$):** A second-order backward difference for the Robin condition gives: $\\left(\\frac{3\\phi_{i,N_y-1} - 4\\phi_{i,N_y-2} + \\phi_{i,N_y-3}}{2\\Delta y}\\right) + a_t\\phi_{i,N_y-1} = G_t(x_i)$.\n    - **Corners:** As specified, the inlet ($x=0$) and outlet ($x=1$) conditions take precedence. The equations for $i=0$ and $i=N_x-1$ are applied for all $j \\in [0, N_y-1]$, which automatically handles all four corners.\n\nThis set of $N_x N_y$ linear equations is assembled into a sparse matrix $A$ and a vector $\\mathbf{b}$. The system is then solved for $\\mathbf{\\Phi}$.\n\n**Step 4: Error Analysis**\nAfter obtaining the numerical solution $\\phi_h$ on a grid with spacing $h$ (represented by $\\Delta x$), we compute the error $e = \\phi_h - \\phi_{\\text{exact}}$ at each grid node. The quality of the solution is assessed using two discrete error norms:\n- **$L^2$ norm:** $\\| e \\|_{2,h} = \\left( \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} e_{i,j}^2 \\,\\Delta x \\,\\Delta y \\right)^{1/2}$\n- **$L^\\infty$ norm:** $\\| e \\|_{\\infty,h} = \\max_{i,j} |e_{i,j}|$\nThe observed order of accuracy, $p$, is calculated by comparing the error $E_h$ on a coarse grid (e.g., $32 \\times 32$) with the error $E_{h/2}$ on a fine grid ($64 \\times 64$):\n$$ p = \\frac{\\log(E_h / E_{h/2})}{\\log(2)} $$\nFor a second-order accurate numerical method, we expect $p \\approx 2$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main driver function to run all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        # Case A (balanced advection–diffusion and mixed walls)\n        (1.0, 0.5, 0.1, 0.8, 0.3),\n        # Case B (diffusion dominated with pure Neumann walls)\n        (0.2, 0.1, 1.0, 0.0, 0.0),\n        # Case C (advection dominated with strong wall sink)\n        (1.5, 0.7, 0.05, 5.0, 2.0),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        u, v, Gamma, ab, at = params\n        errors = []\n        grid_sizes = [16, 32, 64]\n        \n        for N in grid_sizes:\n            l2_err, linf_err = solve_on_grid(N, N, u, v, Gamma, ab, at)\n            errors.append((l2_err, linf_err))\n        \n        # Calculate order of accuracy using the two finest grids (N=32 and N=64)\n        e32_l2, e32_linf = errors[1]\n        e64_l2, e64_linf = errors[2]\n\n        p_l2 = np.log(e32_l2 / e64_l2) / np.log(2) if e64_l2 > 0 else 0.0\n        p_linf = np.log(e32_linf / e64_linf) / np.log(2) if e64_linf > 0 else 0.0\n        \n        all_results.append([p_l2, p_linf])\n\n    print(all_results)\n\ndef solve_on_grid(Nx, Ny, u, v, Gamma, ab, at):\n    \"\"\"\n    Solves the 2D advection-diffusion problem on a single grid configuration.\n    \"\"\"\n    pi = np.pi\n    \n    # 1. Define analytical functions for MMS\n    phi_exact_func = lambda x, y: np.sin(pi * x) * np.cos(2 * pi * y) + x**2 - 0.5 * y\n    dphi_dx_func = lambda x, y: pi * np.cos(pi * x) * np.cos(2 * pi * y) + 2 * x\n    dphi_dy_func = lambda x, y: -2 * pi * np.sin(pi * x) * np.sin(2 * pi * y) - 0.5\n    d2phi_dx2_func = lambda x, y: -pi**2 * np.sin(pi * x) * np.cos(2 * pi * y) + 2\n    d2phi_dy2_func = lambda x, y: -4 * pi**2 * np.sin(pi * x) * np.cos(2 * pi * y)\n\n    source_func = lambda x, y: u * dphi_dx_func(x, y) + v * dphi_dy_func(x, y) - \\\n                               Gamma * (d2phi_dx2_func(x, y) + d2phi_dy2_func(x, y))\n\n    # 2. Setup Grid\n    x = np.linspace(0, 1, Nx)\n    y = np.linspace(0, 1, Ny)\n    dx = x[1] - x[0]\n    dy = y[1] - y[0]\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 3. Assemble Linear System A*phi = b\n    num_unknowns = Nx * Ny\n    A = lil_matrix((num_unknowns, num_unknowns), dtype=float)\n    b = np.zeros(num_unknowns, dtype=float)\n\n    for i in range(Nx):\n        for j in range(Ny):\n            k = j * Nx + i\n            \n            # Inlet boundary (x=0) - Dirichlet\n            if i == 0:\n                A[k, k] = 1.0\n                b[k] = phi_exact_func(x[i], y[j])\n            \n            # Outlet boundary (x=1) - Neumann\n            elif i == Nx - 1:\n                # 2nd order one-sided backward difference\n                # (3*phi_i,j - 4*phi_{i-1},j + phi_{i-2},j) / (2*dx) = g_outlet\n                A[k, k] = 3.0\n                A[k, k - 1] = -4.0\n                A[k, k - 2] = 1.0\n                g_outlet = dphi_dx_func(x[i], y[j])\n                b[k] = 2.0 * dx * g_outlet\n\n            # Bottom wall (y=0) - Robin\n            elif j == 0: # and 1 = i = Nx-2\n                # -(-3*phi_i,0 + 4*phi_i,1 - phi_i,2)/(2*dy) + ab*phi_i,0 = h_bottom\n                # (3+2*dy*ab)*phi_i,0 - 4*phi_i,1 + phi_i,2 = 2*dy*h_bottom\n                A[k, k] = 3.0 + 2.0 * dy * ab\n                A[k, k + Nx] = -4.0\n                A[k, k + 2*Nx] = 1.0\n                h_bottom = -dphi_dy_func(x[i], y[j]) + ab * phi_exact_func(x[i], y[j])\n                b[k] = 2.0 * dy * h_bottom\n\n            # Top wall (y=1) - Robin\n            elif j == Ny - 1: # and 1 = i = Nx-2\n                # (3*phi_i,j - 4*phi_i,j-1 + phi_i,j-2)/(2*dy) + at*phi_i,j = h_top\n                # (3+2*dy*at)*phi_i,j - 4*phi_i,j-1 + phi_i,j-2 = 2*dy*h_top\n                A[k, k] = 3.0 + 2.0 * dy * at\n                A[k, k - Nx] = -4.0\n                A[k, k - 2 * Nx] = 1.0\n                h_top = dphi_dy_func(x[i], y[j]) + at * phi_exact_func(x[i], y[j])\n                b[k] = 2.0 * dy * h_top\n                \n            # Interior nodes\n            else:\n                # Central differences for advection and diffusion\n                # u*d/dx + v*d/dy - G*(d2/dx2 + d2/dy2) = S\n                u_term_c = 0.0\n                u_term_e = u / (2.0 * dx)\n                u_term_w = -u / (2.0 * dx)\n                \n                v_term_c = 0.0\n                v_term_n = v / (2.0 * dy)\n                v_term_s = -v / (2.0 * dy)\n                \n                G_term_c = -Gamma * (-2.0 / dx**2 - 2.0 / dy**2)\n                G_term_e = -Gamma * (1.0 / dx**2)\n                G_term_w = -Gamma * (1.0 / dx**2)\n                G_term_n = -Gamma * (1.0 / dy**2)\n                G_term_s = -Gamma * (1.0 / dy**2)\n                \n                A[k, k] = u_term_c + v_term_c + G_term_c\n                A[k, k + 1] = u_term_e + G_term_e # east\n                A[k, k - 1] = u_term_w + G_term_w # west\n                A[k, k + Nx] = v_term_n + G_term_n # north\n                A[k, k - Nx] = v_term_s + G_term_s # south\n                \n                b[k] = source_func(x[i], y[j])\n\n    # 4. Solve the linear system\n    A_csr = A.tocsr()\n    phi_numerical_flat = spsolve(A_csr, b)\n    phi_numerical = phi_numerical_flat.reshape((Ny, Nx)).T # Transpose to match X,Y meshgrid `ij` indexing\n\n    # 5. Compute Error\n    phi_exact_grid = phi_exact_func(X, Y)\n    error = phi_numerical - phi_exact_grid\n    \n    l2_error = np.sqrt(np.sum(error**2 * dx * dy))\n    linf_error = np.max(np.abs(error))\n    \n    return l2_error, linf_error\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}