{
    "hands_on_practices": [
        {
            "introduction": "此实践将侧重于一项核心技能：在周期性域上离散化微分算子。我们将推导并在非均匀网格上实现一个拉普拉斯算子的有限差分模板，并特别关注周期性边界所需的“环绕”逻辑。这项练习对于在燃烧模拟中精确建模扩散过程至关重要()。",
            "id": "4070015",
            "problem": "考虑一维拉普拉斯算子，在此设定下简化为二阶导数，作用于定义在周期为 $L$ 的周期性域 $[0,L]$ 上的光滑标量场 $u(x)$。在计算燃烧学中，扩散算子使用有限差分进行离散化，并需要仔细处理对称性和周期性边界条件。在一个具有 $N$ 个节点的非均匀但周期性的网格上，必须强制执行回卷（周期性）边界条件，以便端点处的离散模板使用跨越周期性边界的邻点，从而保持周期性域的离散平移对称性。\n\n从第一性原理出发，使用 $u(x)$ 在 $x_i$ 点的泰勒级数，在一个具有局部间距 $h_{i-1}=x_i-x_{i-1}$ 和 $h_i=x_{i+1}-x_i$ 的非均匀网格上，构建二阶导数 $u''(x_i)$ 的三点中心有限差分近似。其中，指数按模 $N$ 计算以强制周期性。该构建必须通过匹配泰勒级数系数来推导（即，通过求解模板权重，使近似对二次及以下阶多项式精确）。使用此结果在一个光滑变化的非均匀周期性网格上获得一个二阶精确的离散拉普拉斯算子。所有角度必须以弧度为单位。在此问题中，域长度 $L$ 是无量纲的。\n\n你必须编写一个完整的程序，该程序：\n- 通过一个光滑单调映射 $x(\\xi) = \\xi + \\varepsilon \\,\\frac{L}{2\\pi}\\,\\sin\\!\\left(\\frac{2\\pi \\xi}{L}\\right)$，将均匀计算网格 $\\xi_j = j\\,L/N$（其中 $j\\in\\{0,1,\\dots,N-1\\}$）映射到物理空间，从而构建一个光滑变化的非均匀周期性网格。其中畸变参数 $\\varepsilon \\in (0,1)$，且 $x(0)=0$ 和 $x(L)=L$。\n- 通过使用模数索引和跨周期性边界的距离来定义 $h_{i-1}$ 和 $h_i$，从而为离散模板强制执行周期性回卷：对于 $i=0$，使用 $h_{-1} = x_0 - x_{N-1} + L$；对于 $i=N-1$，使用 $h_{N-1} = x_0 - x_{N-1} + L$。\n- 将得到的离散拉普拉斯算子应用于光滑周期性测试函数\n  $$\n  u(x) = \\sin\\!\\left(\\frac{2\\pi m x}{L}\\right) + 0.1\\,\\cos\\!\\left(\\frac{4\\pi m x}{L}\\right),\n  $$\n  其中 $m$ 是一个正整数，并将其逐点与精确的二阶导数\n  $$\n  u''(x) = -\\left(\\frac{2\\pi m}{L}\\right)^2 \\sin\\!\\left(\\frac{2\\pi m x}{L}\\right) - 0.1\\left(\\frac{4\\pi m}{L}\\right)^2 \\cos\\!\\left(\\frac{4\\pi m x}{L}\\right)\n  $$\n  进行比较。\n- 计算定义为\n  $$\n  E_\\infty(N) = \\max_{0\\le i \\le N-1} \\left| (\\Delta_h u)_i - u''(x_i) \\right|\n  $$\n  的最大范数误差（离散 $\\ell_\\infty$ 范数），其中 $(\\Delta_h u)_i$ 表示你在节点 $i$ 处的离散拉普拉斯算子。\n- 通过计算观测收敛阶\n  $$\n  p_{N\\to 2N} = \\frac{\\log\\!\\left( E_\\infty(N) / E_\\infty(2N) \\right)}{\\log(2)}\n  $$\n  来验证二阶精度。\n\n设计你的程序以运行以下测试套件：\n- 测试用例 A：$L=1.0$, $m=3$, $\\varepsilon=0.3$, $N=32$。\n- 测试用例 B：$L=1.0$, $m=3$, $\\varepsilon=0.3$, $N=64$。\n- 测试用例 C：$L=1.0$, $m=3$, $\\varepsilon=0.3$, $N=128$。\n- 对称性测试 D（周期性回卷下的离散平移不变性）：使用 $L=1.0$, $\\varepsilon=0.3$, $m=3$, $N=37$，如上构建网格和数据，计算 $(x,u(x))$ 上的离散拉普拉斯算子，然后将指数循环移位 $s=7$ 得到 $(\\tilde{x}, u(\\tilde{x}))$，在移位后的对上重新计算离散拉普拉斯算子，并验证移位后的结果与原始结果在最大范数下是否在紧公差范围内匹配。如果最大绝对差小于 $10^{-10}$，则报告布尔值 true，否则报告 false。\n\n你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，顺序如下：\n- 根据测试用例 A 和 B 计算出的观测阶 $p_{32\\to 64}$，保留三位小数。\n- 根据测试用例 B 和 C 计算出的观测阶 $p_{64\\to 128}$，保留三位小数。\n- 对称性测试 D 的布尔结果。\n\n例如，要求的格式形式为\n\"[p32_64,p64_128,flagD]\"\n其中 $p32\\_64$ 和 $p64\\_128$ 是保留三位小数的浮点数，而 $flagD$ 是 True 或 False。\n\n角度必须以弧度为单位；此问题中没有需要报告的物理单位，所有带量纲的常数均被视为无量纲。\n\n最终的程序必须是完整的、可运行的，无需用户输入，也无需外部文件。唯一允许的库是 Python 标准库和指定的数值库。输出必须是指定格式的单行文本。",
            "solution": "用户希望我解决一个计算问题。\n\n### 第1步：提取已知条件\n- **算子**：一维拉普拉斯算子，$\\frac{d^2}{dx^2}$，作用于标量场 $u(x)$。\n- **域**：周期性，$[0,L]$，周期为 $L$。\n- **网格**：$N$ 个节点，非均匀但周期性。\n- **指数**：按模 $N$ 计算以强制周期性。\n- **局部间距**：$h_{i-1}=x_i-x_{i-1}$ 和 $h_i=x_{i+1}-x_i$。\n- **近似**：$u''(x_i)$ 的三点中心有限差分。\n- **推导方法**：匹配泰勒级数系数，使其对二次及以下阶多项式精确。\n- **网格生成**：\n    - 均匀网格：$\\xi_j = j\\,L/N$，其中 $j\\in\\{0,1,\\dots,N-1\\}$。\n    - 映射：$x(\\xi) = \\xi + \\varepsilon \\,\\frac{L}{2\\pi}\\,\\sin\\!\\left(\\frac{2\\pi \\xi}{L}\\right)$。\n    - 畸变参数：$\\varepsilon \\in (0,1)$。\n- **间距的周期性边界条件**：\n    - 对于 $i=0$：$h_{-1} = x_0 - x_{N-1} + L$。\n    - 对于 $i=N-1$：$h_{N-1} = x_0 - x_{N-1} + L$。\n- **测试函数**：$u(x) = \\sin\\!\\left(\\frac{2\\pi m x}{L}\\right) + 0.1\\,\\cos\\!\\left(\\frac{4\\pi m x}{L}\\right)$，其中 $m$ 为正整数。\n- **精确二阶导数**：$u''(x) = -\\left(\\frac{2\\pi m}{L}\\right)^2 \\sin\\!\\left(\\frac{2\\pi m x}{L}\\right) - 0.1\\left(\\frac{4\\pi m}{L}\\right)^2 \\cos\\!\\left(\\frac{4\\pi m x}{L}\\right)$。\n- **误差度量**：最大范数误差，$E_\\infty(N) = \\max_{0\\le i \\le N-1} \\left| (\\Delta_h u)_i - u''(x_i) \\right|$。\n- **收敛阶公式**：$p_{N\\to 2N} = \\frac{\\log\\!\\left( E_\\infty(N) / E_\\infty(2N) \\right)}{\\log(2)}$。\n- **测试用例 A**：$L=1.0$, $m=3$, $\\varepsilon=0.3$, $N=32$。\n- **测试用例 B**：$L=1.0$, $m=3$, $\\varepsilon=0.3$, $N=64$。\n- **测试用例 C**：$L=1.0$, $m=3$, $\\varepsilon=0.3$, $N=128$。\n- **对称性测试 D**：\n    - 参数：$L=1.0$, $\\varepsilon=0.3$, $m=3$, $N=37$。\n    - 步骤：在 $(x, u(x))$ 上计算拉普拉斯算子，将指数循环移位 $s=7$ 得到 $(\\tilde{x}, u(\\tilde{x}))$，在移位后的对上重新计算拉普拉斯算子，验证移位后的结果与原始结果是否匹配。\n    - 输出：布尔值，如果最大绝对差小于 $10^{-10}$ 则为 `True`。\n\n### 第2步：使用提取的已知条件进行验证\n根据指定标准对问题进行验证。\n- **科学上成立**：该问题植根于数值分析的基本原理，特别是使用泰勒级数分析进行有限差分方法的推导和应用。这是计算科学与工程（包括计算燃烧学）中的一个标准且成熟的课题。所有数学公式均正确。该问题在科学上是健全的。\n- **适定的**：问题定义清晰，包含所有必要的已知条件。它要求推导一个特定的数值格式，实现它，并通过一组指定的测试用例对其进行评估。目标——计算收敛阶和测试离散对称性——是明确的。可以确定一个唯一且有意义的解。\n- **客观的**：问题以精确、正式的语言陈述，没有歧义、主观性或个人观点。所有参数和测试程序都明确定义。\n- **其他缺陷**：\n    1.  **科学上不健全**：无。数学是标准的且正确的。\n    2.  **不可形式化或不相关**：问题是高度可形式化的，并与在计算领域中处理具有对称性和周期性边界条件的扩散算子的特定主题直接相关。\n    3.  **设置不完整或矛盾**：设置是完整的。所有函数、参数、边界条件规则和测试用例都已提供，没有矛盾。为 $i=N-1$ 处的模板定义的 $h_{N-1}$ 与从 $x_{N-1}$ 到 $x_0$ 的周期性镜像的距离相同，这是一致的。\n    4.  **不切实际或不可行**：该问题描述了一个标准的数值实验。条件在计算上是可行的，并且作为模型问题在物理上是合理的。\n    5.  **病态或结构不良**：问题结构良好，对任务的每个部分都能得出唯一、稳定的解。\n    6.  **伪深刻、琐碎或同义反复**：该问题是一个标准但非琐碎的数值方法练习，需要仔细的推导和实现。它测试了对非均匀周期性网格上有限差分的真正理解。\n    7.  **超出科学可验证性范围**：结果完全可以通过独立的计算和代码执行来验证。\n\n### 第3步：结论与行动\n该问题有效。将提供完整的解决方案。\n\n**有限差分格式的推导**\n\n目标是找到一个形式为\n$$(\\Delta_h u)_i = c_{i-1}u(x_{i-1}) + c_i u(x_i) + c_{i+1}u(x_{i+1})$$\n的二阶导数 $u''(x_i)$ 的三点近似，该近似在非均匀网格上成立。设网格间距为 $h_{i-1} = x_i - x_{i-1}$ 和 $h_i = x_{i+1} - x_i$。我们在 $x_i$ 附近对 $u(x_{i-1})$ 和 $u(x_{i+1})$ 进行泰勒级数展开：\n$$u(x_{i-1}) = u(x_i - h_{i-1}) = u(x_i) - h_{i-1}u'(x_i) + \\frac{h_{i-1}^2}{2}u''(x_i) - \\frac{h_{i-1}^3}{6}u'''(x_i) + \\mathcal{O}(h_{i-1}^4)$$\n$$u(x_{i+1}) = u(x_i + h_i) = u(x_i) + h_i u'(x_i) + \\frac{h_i^2}{2}u''(x_i) + \\frac{h_i^3}{6}u'''(x_i) + \\mathcal{O}(h_i^4)$$\n将这些代入模板表达式中得到：\n$$(\\Delta_h u)_i = c_{i-1}\\left(u_i - h_{i-1}u'_i + \\frac{h_{i-1}^2}{2}u''_i + \\dots\\right) + c_i u_i + c_{i+1}\\left(u_i + h_i u'_i + \\frac{h_i^2}{2}u''_i + \\dots\\right)$$\n此处我们使用简写 $u_j^{(k)}$ 代表 $u^{(k)}(x_j)$。按 $x_i$ 处导数的阶数分组：\n$$(\\Delta_h u)_i = (c_{i-1} + c_i + c_{i+1})u_i + (-c_{i-1}h_{i-1} + c_{i+1}h_i)u'_i + \\left(c_{i-1}\\frac{h_{i-1}^2}{2} + c_{i+1}\\frac{h_i^2}{2}\\right)u''_i + \\dots$$\n为了使 $(\\Delta_h u)_i = u''_i + \\text{误差}$，我们必须匹配低阶导数的系数。这要求模板对于多项式 $p(x) = 1$、$p(x) = x-x_i$ 和 $p(x) = (x-x_i)^2$ 是精确的，从而得到关于权重 $c_{i-1}$、$c_i$、$c_{i+1}$ 的以下线性方程组：\n1.  $u_i$ 的系数：$c_{i-1} + c_i + c_{i+1} = 0$\n2.  $u'_i$ 的系数：$-c_{i-1}h_{i-1} + c_{i+1}h_i = 0$\n3.  $u''_i$ 的系数：$c_{i-1}\\frac{h_{i-1}^2}{2} + c_{i+1}\\frac{h_i^2}{2} = 1$\n\n从方程（2），我们发现 $c_{i+1} = c_{i-1} \\frac{h_{i-1}}{h_i}$。将其代入方程（3）：\n$$c_{i-1}\\frac{h_{i-1}^2}{2} + \\left(c_{i-1} \\frac{h_{i-1}}{h_i}\\right)\\frac{h_i^2}{2} = 1 \\implies c_{i-1}\\left(\\frac{h_{i-1}^2 + h_{i-1}h_i}{2}\\right) = 1$$\n解出 $c_{i-1}$：\n$$c_{i-1} = \\frac{2}{h_{i-1}(h_{i-1}+h_i)}$$\n其他权重则为：\n$$c_{i+1} = \\frac{h_{i-1}}{h_i} c_{i-1} = \\frac{h_{i-1}}{h_i} \\frac{2}{h_{i-1}(h_{i-1}+h_i)} = \\frac{2}{h_i(h_{i-1}+h_i)}$$\n$$c_i = -c_{i-1} - c_{i+1} = -\\frac{2}{h_{i-1}(h_{i-1}+h_i)} - \\frac{2}{h_i(h_{i-1}+h_i)} = -\\frac{2(h_i+h_{i-1})}{h_{i-1}h_i(h_{i-1}+h_i)} = -\\frac{2}{h_{i-1}h_i}$$\n得到的有限差分近似为：\n$$(\\Delta_h u)_i = \\frac{2}{h_{i-1}(h_{i-1}+h_i)}u_{i-1} - \\frac{2}{h_{i-1}h_i}u_i + \\frac{2}{h_i(h_{i-1}+h_i)}u_{i+1}$$\n截断误差的主导项通过检查 $u'''_i$ 的系数得到，即 $\\frac{1}{3}(h_i - h_{i-1})u'''_i$。对于一个光滑变化的网格，其中网格点位置 $x_j$ 是指数 $j$ 的光滑函数，相邻间距的差 $h_i - h_{i-1}$ 与平均间距的平方成正比，即 $\\mathcal{O}(h^2)$。因此，主导误差项的行为是 $\\mathcal{O}(h)$，使得该格式在形式上是一阶的。然而，误差展开中的下一项是 $\\mathcal{O}(h^2)$ 阶，对于光滑函数和光滑网格，实际上是这一项占主导地位，从而产生二阶精度，这正是需要通过数值验证的。\n\n**算法设计**\n\n通过实现一组函数来执行指定的测试来解决该问题。\n\n1.  **网格与函数生成**：一个函数首先定义一个均匀计算网格 $\\xi_j = jL/N$（其中 $j \\in \\{0, \\dots, N-1\\}$），然后应用光滑映射 $x(\\xi) = \\xi + \\varepsilon \\frac{L}{2\\pi}\\sin(2\\pi \\xi/L)$ 来创建非均匀物理网格 $x$。测试函数 $u(x)$ 及其精确的二阶导数 $u''(x)$ 在此网格上进行评估。\n\n2.  **离散拉普拉斯算子计算**：一个核心函数计算离散拉普拉斯算子。\n    - 它首先计算所有节点 $i$ 的前向网格间距 $h_i = x_{i+1} - x_i$。为强制周期性，指数按模 $N$ 处理。对于节点 $i=N-1$，下一个节点 $i=N$ 等效于下一个周期性块中的 $i=0$，位于 $x_0+L$。因此，间距为 $h_{N-1} = (x_0+L) - x_{N-1}$。这通过先计算循环移位后的坐标之间的差，然后对回卷元素加上 $L$ 来处理。\n    - 创建两个数组，分别表示每个节点的前向间距 ($h_i$) 和后向间距 ($h_{i-1}$)。\n    - 使用推导出的公式和局部间距计算每个节点 $i$ 的权重 $c_{i-1}$、$c_i$、$c_{i+1}$。\n    - 然后通过矢量化操作计算离散拉普拉斯算子：$(\\Delta_h u)_i = c_{i-1,i}u_{i-1} + c_{i,i}u_i + c_{i+1,i}u_{i+1}$，其中使用周期性移位来访问 $u_{i-1}$ 和 $u_{i+1}$。\n\n3.  **收敛性研究**：\n    - 通过找到离散拉普拉斯算子 $(\\Delta_h u)_i$ 和精确 $u''(x_i)$ 之间的最大绝对差，计算 $N=32, 64, 128$ 时的误差 $E_\\infty(N)$。\n    - 使用提供的对数公式计算观测收敛阶 $p_{32\\to 64}$ 和 $p_{64\\to 128}$。期望值约为 $2$，这证实了二阶精度。\n\n4.  **对称性测试**：\n    - 对于 $N=37$，计算网格 $x$、函数值 $u$ 和离散拉普拉斯算子 $(\\Delta_h u)_{\\text{orig}}$。\n    - 将网格和函数数组循环移位 $s=7$：$\\tilde{x}_i = x_{i-s}$ 和 $\\tilde{u}_i = u_{i-s}$。\n    - 使用移位后的网格 $\\tilde{x}$ 和移位后的函数值 $\\tilde{u}$ 从头开始重新计算离散拉普拉斯算子，得到 $(\\Delta_h \\tilde{u})_{\\text{recomp}}$。\n    - 原始的离散拉普拉斯算子结果也进行移位：$((\\Delta_h u)_{\\text{orig}})_{\\text{shifted}, i} = ((\\Delta_h u)_{\\text{orig}})_{i-s}$。\n    - 通过检查 $(\\Delta_h \\tilde{u})_{\\text{recomp}}$ 和 $((\\Delta_h u)_{\\text{orig}})_{\\text{shifted}}$ 之间的最大绝对差是否低于 $10^{-10}$ 的紧公差，来验证离散平移不变性。这证实了算子的实现尊重了离散域的周期性对称性。\n\n最终程序将这些测试的结果整理成指定的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_discrete_laplacian(x: np.ndarray, u: np.ndarray, L: float) -> np.ndarray:\n    \"\"\"\n    Computes the 3-point finite difference approximation to the second derivative\n    on a nonuniform periodic grid.\n\n    Args:\n        x: The array of grid point coordinates.\n        u: The array of function values at each grid point.\n        L: The period of the domain.\n\n    Returns:\n        The discrete Laplacian of u at each grid point.\n    \"\"\"\n    N = len(x)\n    \n    # Calculate forward spacings h_i = x_{i+1} - x_i with periodic wrap-around\n    h_fwd = np.roll(x, -1) - x\n    # Correct the wrap-around distance for the last element\n    h_fwd[-1] = (x[0] + L) - x[-1]\n\n    # Calculate backward spacings h_{i-1} = x_i - x_{i-1}\n    # This is equivalent to a cyclically shifted version of the forward spacings\n    h_bwd = np.roll(h_fwd, 1)\n\n    # Get function values at neighboring points using periodic roll\n    u_m1 = np.roll(u, 1)   # u_{i-1}\n    u_p1 = np.roll(u, -1)  # u_{i+1}\n\n    # Stencil weights for the approximation at each point i\n    # c_m1 corresponds to u_{i-1}, c_0 to u_i, c_p1 to u_{i+1}\n    c_m1 = 2.0 / (h_bwd * (h_bwd + h_fwd))\n    c_0  = -2.0 / (h_bwd * h_fwd)\n    c_p1 = 2.0 / (h_fwd * (h_bwd + h_fwd))\n\n    # Apply the stencil across all points in a vectorized manner\n    lap_u = c_m1 * u_m1 + c_0 * u + c_p1 * u_p1\n    \n    return lap_u\n\ndef run_convergence_case(L: float, N: int, epsilon: float, m: int):\n    \"\"\"\n    Runs a single case for the convergence study. Generates the grid,\n    computes the discrete and exact Laplacians, and returns the max-norm error\n    and the computed discrete Laplacian array.\n\n    Args:\n        L: The period of the domain.\n        N: The number of grid points.\n        epsilon: The grid distortion parameter.\n        m: The wavenumber parameter for the test function.\n\n    Returns:\n        A tuple containing:\n        - The max-norm error.\n        - The computed discrete Laplacian array.\n        - The grid coordinate array.\n        - The test function value array.\n    \"\"\"\n    # 1. Grid Generation\n    xi = np.arange(N) * L / N\n    x = xi + epsilon * (L / (2.0 * np.pi)) * np.sin(2.0 * np.pi * xi / L)\n\n    # 2. Test Function and its Exact Second Derivative\n    u_x = np.sin(2.0 * np.pi * m * x / L) + 0.1 * np.cos(4.0 * np.pi * m * x / L)\n    \n    term1_sin = -((2.0 * np.pi * m / L)**2) * np.sin(2.0 * np.pi * m * x / L)\n    term2_cos = -0.1 * ((4.0 * np.pi * m / L)**2) * np.cos(4.0 * np.pi * m * x / L)\n    u_xx_exact = term1_sin + term2_cos\n\n    # 3. Compute Discrete Laplacian\n    lap_u_discrete = compute_discrete_laplacian(x, u_x, L)\n\n    # 4. Compute Maximum-Norm Error\n    error_inf = np.max(np.abs(lap_u_discrete - u_xx_exact))\n    \n    return error_inf, lap_u_discrete, x, u_x\n\ndef run_symmetry_test(L: float, N: int, epsilon: float, m: int, s: int) -> bool:\n    \"\"\"\n    Performs the discrete translational invariance test.\n\n    Args:\n        L: The period of the domain.\n        N: The number of grid points (must be prime for a good test).\n        epsilon: The grid distortion parameter.\n        m: The wavenumber parameter for the test function.\n        s: The number of indices to shift by.\n\n    Returns:\n        True if the operator is invariant to within a tolerance, False otherwise.\n    \"\"\"\n    # Compute the Laplacian on the original grid and data\n    _, lap_u_orig, x_orig, u_orig = run_convergence_case(L, N, epsilon, m)\n\n    # Cyclically shift the grid and function data\n    x_shifted = np.roll(x_orig, s)\n    u_shifted = np.roll(u_orig, s)\n    \n    # Recompute the Laplacian on the shifted grid/data\n    lap_u_recomputed = compute_discrete_laplacian(x_shifted, u_shifted, L)\n    \n    # Shift the original result for comparison\n    lap_u_orig_shifted = np.roll(lap_u_orig, s)\n\n    # Check for discrete translational invariance\n    diff = np.max(np.abs(lap_u_recomputed - lap_u_orig_shifted))\n    \n    return diff  1e-10\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Test cases defined in the problem\n    test_cases = [\n        # (L, m, epsilon, N)\n        (1.0, 3, 0.3, 32),   # Test case A\n        (1.0, 3, 0.3, 64),   # Test case B\n        (1.0, 3, 0.3, 128),  # Test case C\n    ]\n    \n    # Run convergence study\n    E_32, _, _, _ = run_convergence_case(L=test_cases[0][0], N=test_cases[0][3], epsilon=test_cases[0][2], m=test_cases[0][1])\n    E_64, _, _, _ = run_convergence_case(L=test_cases[1][0], N=test_cases[1][3], epsilon=test_cases[1][2], m=test_cases[1][1])\n    E_128, _, _, _ = run_convergence_case(L=test_cases[2][0], N=test_cases[2][3], epsilon=test_cases[2][2], m=test_cases[2][1])\n\n    # Compute observed orders of convergence\n    p32_64 = np.log(E_32 / E_64) / np.log(2.0)\n    p64_128 = np.log(E_64 / E_128) / np.log(2.0)\n\n    # Run symmetry test D\n    symmetry_test_params = {'L': 1.0, 'epsilon': 0.3, 'm': 3, 'N': 37, 's': 7}\n    sym_flag = run_symmetry_test(**symmetry_test_params)\n    \n    # Format and print the final output\n    print(f\"[{p32_64:.3f},{p64_128:.3f},{sym_flag}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在正确实现的基础上，此实践致力于解决验证这一关键任务。我们将基于基本守恒定律设计一个诊断测试，用以检测周期性边界映射中那些虽然微小但可能导致严重后果的错误()。这项技能对于确保任何计算代码的物理保真度和鲁棒性都是必不可少的。",
            "id": "4069994",
            "problem": "您的任务是构建、实现并验证一个诊断程序，通过随时间追踪质量和化学组分的守恒误差，来检测成对周期性面之间不匹配的周期性映射。背景是计算燃烧学中的周期性边界条件处理。所有量均为无量纲。\n\n基本原理：从总质量和各化学组分的积分守恒定律出发。对于一个空间域 $\\Omega$ 及其边界 $\\partial \\Omega$，给定密度场 $\\rho$、速度场 $\\boldsymbol{u}$ 以及组分索引为 $s$ 的组分质量分数 $Y_{s}$，积分守恒定律（体积源项为零）为\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\Omega} \\rho \\,\\mathrm{d}V \\;=\\; - \\int_{\\partial \\Omega} \\rho \\,\\boldsymbol{u}\\cdot \\boldsymbol{n} \\,\\mathrm{d}S,\n\\qquad\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\Omega} \\rho Y_{s} \\,\\mathrm{d}V \\;=\\; - \\int_{\\partial \\Omega} \\rho Y_{s} \\,\\boldsymbol{u}\\cdot \\boldsymbol{n} \\,\\mathrm{d}S.\n$$\n对于一对周期性面 $\\Gamma_{L}$ 和 $\\Gamma_{R}$，其单位外法线分别为 $\\boldsymbol{n}_{L}$ 和 $\\boldsymbol{n}_{R}$，一个正确的周期性映射 $M$ 会将 $\\Gamma_{L}$ 上的每个点与 $\\Gamma_{R}$ 上的一个点配对，其性质是点对点的法向通量相抵消：\n$$\n\\left.\\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{n}_{L}\\right|_{\\boldsymbol{x}\\in\\Gamma_{L}} \\;+\\; \\left.\\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{n}_{R}\\right|_{M(\\boldsymbol{x})\\in\\Gamma_{R}} \\;=\\; 0,\n$$\n$\\rho Y_{s}$ 的情况也类似。即使 $\\Gamma_{L}\\cup\\Gamma_{R}$ 上的全局净通量积分为零，一个不匹配的映射也会违反这种点对点的抵消关系。因此，一个稳健的检测测试必须评估点对点的抵消情况，而不仅仅是全局净通量。\n\n待实现的离散化与诊断程序：考虑一个在 $x$ 方向上呈周期性的二维域。沿周期性方向将其离散为一组均匀的 $N_{y}$ 个长度为 $\\Delta y$ 的线段，索引为 $j\\in\\{0,\\dots,N_{y}-1\\}$，线段中心位于 $y_{j}=\\left(j+\\tfrac{1}{2}\\right)\\Delta y$，其中 $\\Delta y = 1/N_{y}$。左、右周期性面分别为位于 $x=0$ 的 $\\Gamma_{L}$ 和位于 $x=1$ 的 $\\Gamma_{R}$。假设速度场为常数 $\\boldsymbol{u}=(U,0)$ 且 $U\\ge 0$，场量仅依赖于 $y$：密度 $\\rho(y)$ 和两个满足 $Y_{1}(y)+Y_{2}(y)=1$ 的组分质量分数 $Y_{1}(y)$ 和 $Y_{2}(y)$。外法线满足 $\\boldsymbol{n}_{L}=(-1,0)$ 和 $\\boldsymbol{n}_{R}=(+1,0)$。定义每个线段的离散单位外法向质量通量密度为\n$$\nf^{\\text{mass}}_{L}(j) \\;=\\; \\rho(y_{j})\\,\\boldsymbol{u}\\cdot \\boldsymbol{n}_{L} \\;=\\; -U\\,\\rho(y_{j}),\\qquad\nf^{\\text{mass}}_{R}(k) \\;=\\; \\rho(y_{k})\\,\\boldsymbol{u}\\cdot \\boldsymbol{n}_{R} \\;=\\; +U\\,\\rho(y_{k}),\n$$\n对于组分 $s\\in\\{1,2\\}$，\n$$\nf^{(s)}_{L}(j) \\;=\\; -U\\,\\rho(y_{j})\\,Y_{s}(y_{j}),\\qquad f^{(s)}_{R}(k) \\;=\\; +U\\,\\rho(y_{k})\\,Y_{s}(y_{k}).\n$$\n映射被离散地表示为一个索引映射 $M:\\{0,\\dots,N_{y}-1\\}\\to\\{0,\\dots,N_{y}-1\\}$。对于一个正确的周期性映射，点对点的抵消关系满足 $f_{L}(j)+f_{R}(M(j))=0$，这对每个 $j$ 以及质量和每个组分都成立。为检测不匹配，定义在时间区间 $[0,T]$ 内的累积点对点守恒误差，该区间具有均匀的时间步长 $\\Delta t$ 和 $N_{t}=T/\\Delta t$ 个步长：\n$$\nE_{\\text{mass}} \\;=\\; \\sum_{n=0}^{N_{t}-1} \\Delta t \\sum_{j=0}^{N_{y}-1} \\left| f^{\\text{mass}}_{L}(j) + f^{\\text{mass}}_{R}(M(j)) \\right|\\,\\Delta y,\n$$\n$$\nE_{s} \\;=\\; \\sum_{n=0}^{N_{t}-1} \\Delta t \\sum_{j=0}^{N_{y}-1} \\left| f^{(s)}_{L}(j) + f^{(s)}_{R}(M(j)) \\right|\\,\\Delta y,\\quad s\\in\\{1,2\\}.\n$$\n当场量不随时间变化时，误差与 $T$ 呈线性关系；对于正确的映射，在精确算术中所有误差均为零。\n\n您的任务：编写一个完整、可运行的程序来实现此诊断。使用以下固定的场定义和测试套件，并通过将 $E_{\\text{mass}}、E_{1}、E_{2}$ 中的每一个与指定的容差 $\\varepsilon$ 进行比较来决定每个案例的通过/失败。\n\n使用的场定义：\n- $N_{y}$ 个线段，其中 $y_{j}=\\left(j+\\tfrac{1}{2}\\right)/N_{y}$。\n- $\\rho(y) \\;=\\; 1 \\;+\\; 0.2\\,\\sin(2\\pi y) \\;+\\; 0.1\\,\\cos(4\\pi y)$。\n- $Y_{1}(y) \\;=\\; 0.5 \\;+\\; 0.3\\,\\sin(2\\pi y)$，以及 $Y_{2}(y) \\;=\\; 1 - Y_{1}(y)$。\n\n每个测试案例的映射定义：\n- 映射偏移量 $s$ 指定了 $M(j) \\equiv (j+s)\\bmod N_{y}$。\n\n时间积分参数：\n- 总时间 $T=1$，时间步数 $N_{t}=100$，因此 $\\Delta t = T/N_{t}$。\n\n判定规则：\n- 当且仅当 $E_{\\text{mass}}\\le \\varepsilon$ 且 $E_{1}\\le \\varepsilon$ 且 $E_{2}\\le \\varepsilon$ 时，案例通过。\n\n测试套件：\n- 案例 1：$N_{y}=64$, $U=0.5$, $s=0$, $\\varepsilon=10^{-11}$。\n- 案例 2：$N_{y}=64$, $U=0$, $s=13$, $\\varepsilon=10^{-12}$。\n- 案例 3：$N_{y}=64$, $U=0.5$, $s=1$, $\\varepsilon=10^{-6}$。\n- 案例 4：$N_{y}=64$, $U=10^{-8}$, $s=1$, $\\varepsilon=10^{-6}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按测试套件顺序排列的结果，格式为方括号内由逗号分隔的 Python 布尔文字列表，例如，“[True,False,True,True]”。",
            "solution": "问题陈述已经过验证，并被确定为是合理的。它在科学上基于连续介质力学的原理，特别是积分守恒定律，并提出了一个与计算燃烧学相关的适定数值问题。所有必要的数据、方程和条件都已提供，从而可以构建一个唯一且可验证的解。\n\n任务是实现一个诊断工具，以检测数值模拟中边界条件的周期性映射错误。该诊断基于量化跨越两个周期性面的质量和组分质量分数的局部、点对点守恒误差。\n\n基本原理是域 $\\Omega$ 内某个量 $\\phi$ 的积分守恒定律，该定律指出，体积内 $\\phi$ 总量的时间变化率等于穿过边界 $\\partial\\Omega$ 的 $\\phi$ 的净通量。对于密度 $\\rho$ 和组分质量分数 $Y_s$，给定速度场 $\\boldsymbol{u}$，并忽略扩散输运和源项，这些定律是：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\Omega} \\rho \\,\\mathrm{d}V \\;=\\; - \\int_{\\partial \\Omega} \\rho \\,\\boldsymbol{u}\\cdot \\boldsymbol{n} \\,\\mathrm{d}S\n$$\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\Omega} \\rho Y_{s} \\,\\mathrm{d}V \\;=\\; - \\int_{\\partial \\Omega} \\rho Y_{s} \\,\\boldsymbol{u}\\cdot \\boldsymbol{n} \\,\\mathrm{d}S\n$$\n对于具有周期性边界的域，例如一对面 $\\Gamma_{L}$ 和 $\\Gamma_{R}$，全局守恒要求流入 $\\Gamma_{L}$ 的总通量等于流出 $\\Gamma_{R}$ 的总通量。然而，正确的数值实现需要一个更强的、点对点的条件。如果 $M$ 是将点 $\\boldsymbol{x} \\in \\Gamma_{L}$ 与点 $M(\\boldsymbol{x}) \\in \\Gamma_{R}$ 配对的映射，那么局部通量必须相互抵消。给定外法线 $\\boldsymbol{n}_{L}$ 和 $\\boldsymbol{n}_{R}$，这意味着对流通量密度必须满足：\n$$\n\\left(\\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{n}_{L}\\right)\\big|_{\\boldsymbol{x}} \\;+\\; \\left(\\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{n}_{R}\\right)\\big|_{M(\\boldsymbol{x})} \\;=\\; 0\n$$\n一个不匹配的映射 $M$ 将违反这种局部抵消，从而导致数值误差。提议的诊断程序量化了这种违反情况。\n\n问题将此简化为一个二维域，在 $x=0$ ($\\Gamma_{L}$) 和 $x=1$ ($\\Gamma_{R}$) 之间呈 $x$ 方向周期性。这些面被离散化为 $N_y$ 个长度为 $\\Delta y = 1/N_y$ 的线段。线段中心为 $y_j = (j+1/2)\\Delta y$，其中 $j \\in \\{0, \\dots, N_y-1\\}$。速度是恒定的，$\\boldsymbol{u}=(U,0)$，而场量 $\\rho(y)$ 和 $Y_s(y)$ 仅依赖于 $y$。外法线为 $\\boldsymbol{n}_{L}=(-1,0)$ 和 $\\boldsymbol{n}_{R}=(+1,0)$。\n\n左面上线段 $j$ 和右面上线段 $k$ 的离散外法向质量通量密度为：\n$$\nf^{\\text{mass}}_{L}(j) = -U\\,\\rho(y_{j}), \\qquad f^{\\text{mass}}_{R}(k) = +U\\,\\rho(y_{k})\n$$\n对应组分 $s \\in \\{1, 2\\}$ 的组分通量为：\n$$\nf^{(s)}_{L}(j) = -U\\,\\rho(y_{j})\\,Y_{s}(y_{j}), \\qquad f^{(s)}_{R}(k) = +U\\,\\rho(y_{k})\\,Y_{s}(y_{k})\n$$\n对于将 $\\Gamma_L$ 上的线段 $j$ 映射到 $\\Gamma_R$ 上的线段 $M(j)$ 的离散映射 $M(j)$，质量的局部抵消误差为 $|f^{\\text{mass}}_{L}(j) + f^{\\text{mass}}_{R}(M(j))|$。诊断误差度量 $E$ 是这些局部误差在整个边界和整个时间上的累积总和。鉴于场是稳态的，对大小为 $\\Delta t$ 的 $N_t$ 个时间步的求和简化为乘以总时间 $T = N_t \\Delta t$。总质量的误差为：\n$$\nE_{\\text{mass}} \\;=\\; \\sum_{n=0}^{N_{t}-1} \\Delta t \\sum_{j=0}^{N_{y}-1} \\left| f^{\\text{mass}}_{L}(j) + f^{\\text{mass}}_{R}(M(j)) \\right|\\,\\Delta y \\;=\\; T \\cdot \\Delta y \\sum_{j=0}^{N_{y}-1} \\left| -U\\,\\rho(y_{j}) + U\\,\\rho(y_{M(j)}) \\right|\n$$\n由于 $U \\ge 0$，这简化为：\n$$\nE_{\\text{mass}} \\;=\\; T \\cdot U \\cdot \\Delta y \\sum_{j=0}^{N_{y}-1} \\left| \\rho(y_{M(j)}) - \\rho(y_j) \\right|\n$$\n类似地，对于组分 $s$：\n$$\nE_{s} \\;=\\; T \\cdot U \\cdot \\Delta y \\sum_{j=0}^{N_{y}-1} \\left| \\rho(y_{M(j)})Y_s(y_{M(j)}) - \\rho(y_j)Y_s(y_j) \\right|\n$$\n实现将按如下方式进行。对于由 ($N_y, U, s, \\varepsilon$) 定义的每个测试案例：\n1. 构建由 $N_y$ 个点 $\\{y_j\\}$ 组成的网格。\n2. 计算 $\\rho(y_j)$, $Y_1(y_j)$ 和 $Y_2(y_j)$ 的场值并存储在数组中。同时计算类似质量通量的量 $\\phi_s(y_j)=\\rho(y_j)Y_s(y_j)$。\n3. 应用离散映射 $M(j) = (j+s)\\bmod N_y$。在计算上，这等效于场数组的周期性移位。一个值为 $q(y_j)$ 的数组 `q` 被映射到一个数组 `q_mapped`，其中 `q_mapped`$[j] = q(y_{M(j)})$。这可以通过对数组执行循环移位操作来高效实现。对于偏移量 $s$，这对应于向左循环移位 $s$ 个位置。\n4. 使用简化公式计算误差 $E_{\\text{mass}}$、$E_1$ 和 $E_2$。为提高效率，使用矢量化操作。\n5. 如果所有三个误差 $E_{\\text{mass}}$、$E_1$ 和 $E_2$ 都小于或等于指定的容差 $\\varepsilon$，则该测试案例标记为“通过”(`True`)，否则标记为“失败”(`False`)。\n\n场定义为：\n- $\\rho(y) \\;=\\; 1 \\;+\\; 0.2\\,\\sin(2\\pi y) \\;+\\; 0.1\\,\\cos(4\\pi y)$\n- $Y_{1}(y) \\;=\\; 0.5 \\;+\\; 0.3\\,\\sin(2\\pi y)$\n- $Y_{2}(y) \\;=\\; 1 - Y_{1}(y)$\n\n固定参数为 $T = 1$ 和 $\\Delta t = T/100 = 0.01$。在简化公式中，不需要明确使用 $N_t=100$ 和 $\\Delta t$ 的值，只需要它们的乘积 $T$。\n实现将使用 Python 语言，并利用 `numpy` 库进行数值计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates a diagnostic for mismatched periodic boundary\n    conditions in a computational combustion context.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Ny, U, s, epsilon)\n        (64, 0.5, 0, 1e-11),   # Case 1: Perfect mapping, should pass.\n        (64, 0.0, 13, 1e-12),  # Case 2: Zero velocity, no flux, should pass.\n        (64, 0.5, 1, 1e-6),    # Case 3: Mismatched mapping, should fail.\n        (64, 1e-8, 1, 1e-6),   # Case 4: Mismatched, but tiny velocity, should pass.\n    ]\n\n    T = 1.0  # Total simulation time.\n\n    results = []\n    for Ny, U, s, epsilon in test_cases:\n        # Step 1: Discretize the domain in the y-direction.\n        dy = 1.0 / Ny\n        y = (np.arange(Ny) + 0.5) * dy\n\n        # Step 2: Define and evaluate the spatially varying fields.\n        rho = 1.0 + 0.2 * np.sin(2 * np.pi * y) + 0.1 * np.cos(4 * np.pi * y)\n        Y1 = 0.5 + 0.3 * np.sin(2 * np.pi * y)\n        \n        # The species mass fractions must sum to 1.\n        # This implies rho*Y1 + rho*Y2 = rho.\n        phi1 = rho * Y1\n        phi2 = rho - phi1\n\n        # Step 3: Apply the periodic mapping M(j) = (j+s) mod Ny.\n        # This corresponds to a circular left shift by 's' positions.\n        # np.roll(arr, -s) shifts elements to the left.\n        rho_mapped = np.roll(rho, -s)\n        phi1_mapped = np.roll(phi1, -s)\n        phi2_mapped = np.roll(phi2, -s)\n\n        # A more numerically robust way to calculate phi2_mapped to enforce\n        # the conservation property rho = phi1 + phi2 exactly.\n        # phi2_mapped_alt = rho_mapped - phi1_mapped\n        # The results are identical in this case.\n\n        # Step 4: Calculate the cumulative pairwise conservation errors.\n        # The formulas are simplified for steady fields: E = T * U * dy * sum(|diff|).\n        \n        # Mass conservation error\n        diff_rho = rho_mapped - rho\n        E_mass = T * U * dy * np.sum(np.abs(diff_rho))\n\n        # Species 1 conservation error\n        diff_phi1 = phi1_mapped - phi1\n        E1 = T * U * dy * np.sum(np.abs(diff_phi1))\n\n        # Species 2 conservation error\n        # Can be derived from mass and species 1 differences\n        # diff_phi2 = phi2_mapped - phi2\n        #           = (rho_mapped - phi1_mapped) - (rho - phi1)\n        #           = (rho_mapped - rho) - (phi1_mapped - phi1)\n        #           = diff_rho - diff_phi1\n        diff_phi2 = diff_rho - diff_phi1\n        E2 = T * U * dy * np.sum(np.abs(diff_phi2))\n\n        # Step 5: Apply the decision rule.\n        # A case passes if and only if all three errors are within the tolerance.\n        passed = (E_mass = epsilon) and (E1 = epsilon) and (E2 = epsilon)\n        results.append(passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这项实践将数值方法与物理结果联系起来，探讨周期性边界的离散化选择如何影响热声稳定性分析。我们将研究数值色散的概念，并通过收敛性研究来量化其对预测增长率的影响()。这项练习凸显了确保模拟结果具有物理意义且独立于计算网格的重要性。",
            "id": "4069956",
            "problem": "考虑一个长度为 $L$ 的一维预混周期性燃烧室，其基态声速 $c$ 和基态密度 $\\rho_0$ 均为常数。假设流场是静止的，没有平均流。小振幅热声扰动通过带有时间延迟的热释放闭合模型的线性声学进行建模。将声压扰动记为 $p'(x,t)$，声速扰动记为 $u'(x,t)$。基本方程组包括：(i) 线性化连续性方程 $\\partial \\rho'/\\partial t + \\rho_0 \\, \\partial u'/\\partial x = 0$，(ii) 线性化动量方程 $\\rho_0 \\, \\partial u'/\\partial t + \\partial p'/\\partial x = 0$，(iii) 理想气体声学闭合关系 $p' = c^2 \\rho'$，以及 (iv) 一个具有时间延迟 $\\tau$ 的紧凑（空间局域）热释放扰动模型，定义为 $q'(t) = \\kappa \\, u'(x_f, t - \\tau)$，其中 $x_f$ 是火焰位置，$\\kappa$ 是一个比例常数。在均匀周期性域中，您可以将 $x_f$ 视为任意值。Rayleigh 判据指出，模态增长率与 $p'$ 和 $q'$ 的周期平均乘积成正比，其中阻尼 $D$ 用于计入黏性、热和辐射损失。在小振幅极限下，模态动力学可以通过角频率 $\\omega$ 和波数 $k$ 之间的色散关系，以及用时间延迟和 $q'$ 与 $p'$ 之间的相位表示的模态增长率 $\\sigma$ 的显式表达式来近似。\n\n周期性边界条件意味着空间本征模是区间 $[0,L)$ 上的谐波，并且空间导数的离散近似必须强制执行周期性环绕。考虑一个包含 $N$ 个点、间距为 $\\Delta x = L/N$ 的均匀网格，并使用由周期性边界条件闭合的标准二阶中心差分格式来近似 $\\partial^2/\\partial x^2$。令 $m \\in \\{1,2,\\dots\\}$ 为模态数的索引。有限差分近似会引入一个偏离连续关系的离散色散关系。周期性域的对称性产生的离散本征向量是网格谐波，而本征值则依赖于 $N$ 和 $m$。这种数值色散会影响时间延迟闭合模型中的相位，从而影响热声增长率。\n\n任务1（推导）：从上述基本方程组出发，假设单个傅里叶模态拟设为 $p'(x,t) = \\Re\\{ P_m \\exp(i k x - i \\omega t) \\}$，其中振幅为 $P_m$，模态指数为 $m$，推导连续色散关系，然后推导在含 $N$ 个点的均匀网格上、采用周期性边界条件的二阶中心差分拉普拉斯算子的离散色散关系。利用离散本征向量在网格索引 $j \\in \\{0,1,\\dots,N-1\\}$ 处为 $\\exp(i 2 \\pi m j / N)$ 这一事实，求出离散角频率 $\\omega_m(N)$ 作为 $L$、$c$、$m$ 和 $N$ 的函数。然后，使用时间延迟闭合模型，将模态增长率 $\\sigma_m(N)$ 表示为耦合增益 $G$ 和阻尼 $D$ 的函数。使用给定的基本定律论证每一步。确保所有角度量的变量和算子都以弧度表示，并且所有推导出的增长率都以 $\\mathrm{s}^{-1}$ 为单位。\n\n任务2（算法与灵敏度）：设计一个数值实验，通过改变 $N$ 并将 $\\sigma_m(N)$ 与一个高分辨率参考值 $\\sigma_m(N_{\\mathrm{ref}})$ 进行比较，来量化 $\\sigma_m(N)$ 对周期性边界条件离散化的灵敏度。将每个模态 $m$ 和网格尺寸 $N$ 的相对误差定义为 $\\varepsilon_{m}(N) = \\left| \\sigma_m(N) - \\sigma_m(N_{\\mathrm{ref}}) \\right| / \\max\\left(\\left| \\sigma_m(N_{\\mathrm{ref}}) \\right|, \\epsilon_0 \\right)$，其中 $\\epsilon_0$ 是一个小的正常数，用于避免除以零。通过在所选的模态和网格尺寸上取最大值来聚合灵敏度：$\\varepsilon_{\\max} = \\max_{m,N} \\varepsilon_m(N)$。提出一个容差 $\\varepsilon_{\\mathrm{tol}}$，并将网格无关性定义为条件 $\\varepsilon_{\\max} \\le \\varepsilon_{\\mathrm{tol}}$。您的程序必须为每个测试用例计算 $\\varepsilon_{\\max}$，并将其作为无量纲浮点数输出。\n\n任务3（实现与测试套件）：实现一个完整的、可运行的程序，该程序执行基于推导的公式计算和灵敏度研究。使用以下具有物理上合理参数的测试套件。所有角度必须以弧度为单位，所有时间以秒为单位，$L$ 以米为单位，$c$ 以米/秒为单位，$G$ 和 $D$ 以 $\\mathrm{s}^{-1}$ 为单位。在最终输出中仅报告无量纲相对误差。对于每个测试用例，计算模态 $m = 1,2,\\dots,M$。\n\n- 测试用例 A（一般情况）：$ L = 1.0\\,\\mathrm{m} $，$ c = 600.0\\,\\mathrm{m/s} $，$ G = 100.0\\,\\mathrm{s}^{-1} $，$ D = 20.0\\,\\mathrm{s}^{-1} $，$ \\tau = 0.0020\\,\\mathrm{s} $，$ M = 4 $，$ N \\in \\{32,64,128,256,512\\} $，$ N_{\\mathrm{ref}} = 4096 $，$ \\varepsilon_{\\mathrm{tol}} = 10^{-4} $，$ \\epsilon_0 = 10^{-12} $。\n\n- 测试用例 B（零延迟边界情况）：$ L = 1.0\\,\\mathrm{m} $，$ c = 340.0\\,\\mathrm{m/s} $，$ G = 50.0\\,\\mathrm{s}^{-1} $，$ D = 5.0\\,\\mathrm{s}^{-1} $，$ \\tau = 0.0\\,\\mathrm{s} $，$ M = 3 $，$ N \\in \\{8,16,32,64\\} $，$ N_{\\mathrm{ref}} = 4096 $，$ \\varepsilon_{\\mathrm{tol}} = 10^{-10} $，$ \\epsilon_0 = 10^{-12} $。在这种情况下，时间延迟相位为零，因此如果周期性边界条件被正确强制执行，增长率应与 $N$ 无关。\n\n- 测试用例 C（相位敏感情况）：$ L = 1.5\\,\\mathrm{m} $，$ c = 650.0\\,\\mathrm{m/s} $，$ G = 80.0\\,\\mathrm{s}^{-1} $，$ D = 10.0\\,\\mathrm{s}^{-1} $，$ \\tau = 0.0006\\,\\mathrm{s} $，$ M = 6 $，$ N \\in \\{16,24,32,48,64,96,128,256,512,1024\\} $，$ N_{\\mathrm{ref}} = 4096 $，$ \\varepsilon_{\\mathrm{tol}} = 10^{-4} $，$ \\epsilon_0 = 10^{-12} $。\n\n最终输出格式规范：您的程序应生成单行输出，其中包含三个测试用例的最大相对误差，格式为方括号括起来的逗号分隔列表，例如 $[\\varepsilon_{\\max}^{(A)},\\varepsilon_{\\max}^{(B)},\\varepsilon_{\\max}^{(C)}]$，其中每个条目都是一个无量纲浮点数。不得打印任何其他文本。程序必须是自包含的，并且无需用户输入即可执行。",
            "solution": "该问题是有效的，因为它在科学上基于线性声学和计算物理学的原理，是适定的，具有明确的目标和充足的数据，并且没有矛盾或含糊之处。因此，我们可以继续进行推导和求解。\n\n按照要求，分析分为三个部分：控制性的解析关系和数值关系的推导，灵敏度分析算法的构建，以及完整程序的实现。\n\n首先，我们从所提供的基本原理推导出控制性波动方程。线性化的连续性方程和动量方程是：\n$$\n\\frac{\\partial \\rho'}{\\partial t} + \\rho_0 \\frac{\\partial u'}{\\partial x} = 0 \\quad \\text{(i)}\n$$\n$$\n\\rho_0 \\frac{\\partial u'}{\\partial t} + \\frac{\\partial p'}{\\partial x} = 0 \\quad \\text{(ii)}\n$$\n我们将方程 (i) 对时间 $t$ 求导，将方程 (ii) 对空间 $x$ 求导：\n$$\n\\frac{\\partial^2 \\rho'}{\\partial t^2} + \\rho_0 \\frac{\\partial^2 u'}{\\partial t \\partial x} = 0\n$$\n$$\n\\rho_0 \\frac{\\partial^2 u'}{\\partial x \\partial t} + \\frac{\\partial^2 p'}{\\partial x^2} = 0\n$$\n假设场具有足够好的连续性，混合偏导数相等。因此，我们可以令涉及声速 $u'$ 的项相等：\n$$\n\\rho_0 \\frac{\\partial^2 u'}{\\partial t \\partial x} = -\\frac{\\partial^2 \\rho'}{\\partial t^2} = \\rho_0 \\frac{\\partial^2 u'}{\\partial x \\partial t} = -\\frac{\\partial^2 p'}{\\partial x^2}\n$$\n这就得到了压力 $p'$ 和密度 $\\rho'$ 扰动之间的关系：\n$$\n\\frac{\\partial^2 \\rho'}{\\partial t^2} = \\frac{\\partial^2 p'}{\\partial x^2}\n$$\n使用理想气体声学闭合关系 $p' = c^2 \\rho'$（这意味着 $\\rho' = p'/c^2$），并将其代入上式，我们得到声压的一维齐次波动方程：\n$$\n\\frac{1}{c^2} \\frac{\\partial^2 p'}{\\partial t^2} - \\frac{\\partial^2 p'}{\\partial x^2} = 0\n$$\n该方程描述了在没有源项和耗散的情况下的声波传播，这些条件决定了系统的固有模态和频率。\n\n接下来，我们推导连续色散关系。我们考虑形式为 $p'(x,t) = \\Re\\{ P_m \\exp(i k x - i \\omega t) \\}$ 的单个傅里叶模态拟设，其中 $P_m$ 是复振幅，$k$ 是波数，$\\omega$ 是角频率。将其代入波动方程得到：\n$$\n\\frac{1}{c^2} (-i \\omega)^2 P_m e^{i(kx-\\omega t)} - (ik)^2 P_m e^{i(kx-\\omega t)} = 0\n$$\n$$\n-\\frac{\\omega^2}{c^2} + k^2 = 0 \\implies \\omega^2 = c^2 k^2\n$$\n这就得到了连续色散关系 $\\omega = \\pm c k$。对于长度为 $L$ 的周期性域，波数 $k$ 是量子化的以确保周期性，即 $p'(x+L,t) = p'(x,t)$。这要求 $kL = 2\\pi m$，其中 $m \\in \\{1, 2, ...\\}$ 为整数模态数。$m=0$ 模态对应于空间均匀的压力扰动，不是声波。因此，连续固有角频率为：\n$$\n\\omega_{m, \\text{cont}} = c |k_m| = \\frac{2 \\pi c m}{L}\n$$\n\n现在我们推导由空间离散化产生的离散色散关系。长度为 $L$ 的域被离散化为 $N$ 个均匀网格区间，网格间距为 $\\Delta x = L/N$。通过将空间导数 $\\partial^2/\\partial x^2$ 替换为其二阶中心差分近似，可以得到网格点 $j$ 处的半离散波动方程：\n$$\n\\frac{d^2 p'_j(t)}{dt^2} = c^2 \\frac{p'_{j+1}(t) - 2p'_j(t) + p'_{j-1}(t)}{(\\Delta x)^2}\n$$\n其中周期性边界条件意味着 $p'_{N} = p'_{0}$ 和 $p'_{-1} = p'_{N-1}$。问题陈述离散本征向量是形式为 $\\exp(i 2 \\pi m j / N)$ 的网格谐波。让我们将离散拉普拉斯算子应用于此本征向量：\n$$\n\\frac{e^{i 2 \\pi m (j+1)/N} - 2e^{i 2 \\pi m j/N} + e^{i 2 \\pi m (j-1)/N}}{(\\Delta x)^2} = \\frac{e^{i 2 \\pi m j/N}}{(\\Delta x)^2} \\left( e^{i 2 \\pi m / N} - 2 + e^{-i 2 \\pi m / N} \\right)\n$$\n使用恒等式 $2\\cos\\theta = e^{i\\theta} + e^{-i\\theta}$，上式简化为：\n$$\n\\frac{e^{i 2 \\pi m j/N}}{(\\Delta x)^2} \\left( 2\\cos\\left(\\frac{2\\pi m}{N}\\right) - 2 \\right) = \\frac{e^{i 2 \\pi m j/N}}{(\\Delta x)^2} \\left( -4\\sin^2\\left(\\frac{\\pi m}{N}\\right) \\right)\n$$\n因此，模态 $m$ 的离散拉普拉斯算子的本征值为 $\\lambda_m = -\\frac{4}{(\\Delta x)^2} \\sin^2(\\frac{\\pi m}{N})$。将拟设 $p'_j(t) = P_m \\exp(-i \\omega_m(N) t)$ 代入半离散波动方程，其中 $\\omega_m(N)$ 是离散角频率，我们得到：\n$$\n(-i \\omega_m(N))^2 = c^2 \\lambda_m \\implies -\\omega_m(N)^2 = -c^2 \\frac{4}{(\\Delta x)^2} \\sin^2\\left(\\frac{\\pi m}{N}\\right)\n$$\n求解 $\\omega_m(N)$ 并代入 $\\Delta x = L/N$ 得到离散色散关系：\n$$\n\\omega_m(N) = \\frac{2c}{\\Delta x} \\left| \\sin\\left(\\frac{\\pi m}{N}\\right) \\right| = \\frac{2cN}{L} \\sin\\left(\\frac{\\pi m}{N}\\right)\n$$\n其中我们取频率的正根，并假设 $m \\le N/2$ 以使正弦项为正。这个数值频率 $\\omega_m(N)$ 偏离了连续频率 $\\omega_{m, \\text{cont}}$，这种效应被称为数值色散。\n\n最后，我们推导模态增长率 $\\sigma_m(N)$ 的表达式。Rayleigh 判据指出，增长率与压力 $p'$ 和热释放率 $q'$ 的周期平均乘积成正比。对于时间延迟模型 $q'(t) = \\kappa \\, u'(x_f, t-\\tau)$，增长率由压力和热释放之间的相位差决定。根据线性化动量方程 (ii)，假设单个行波分量为 $\\tilde{p}=P_m e^{i(kx-\\omega t)}$，则复速度为 $\\tilde{u} = \\frac{k}{\\rho_0 \\omega}\\tilde{p}$。由于 $k$ 和 $\\omega$ 是实数，$\\tilde{u}$ 和 $\\tilde{p}$ 是同相的。复热释放率为 $\\tilde{q}(t) = \\kappa \\tilde{u}(x_f, t-\\tau) \\propto e^{-i\\omega(t-\\tau)} = e^{-i\\omega t} e^{i\\omega\\tau}$。因此，$\\tilde{q}(t)$ 和 $\\tilde{p}(x_f, t)$ 之间的相位差为 $\\phi = \\omega\\tau$。考虑火焰-声学耦合增益 $G$ 和系统级阻尼 $D$ 后，增长率的简化形式为 $\\sigma = G \\cos(\\phi) - D$。使用离散频率 $\\omega_m(N)$，在尺寸为 $N$ 的网格上模态 $m$ 的增长率为：\n$$\n\\sigma_m(N) = G \\cos(\\omega_m(N) \\tau) - D\n$$\n综合我们的结果，最终的表达式是：\n$$\n\\sigma_m(N) = G \\cos\\left( \\left[ \\frac{2cN}{L} \\sin\\left(\\frac{\\pi m}{N}\\right) \\right] \\tau \\right) - D\n$$\n该表达式表明，$\\omega_m(N)$ 中的数值色散通过改变反馈回路的相位，直接影响计算出的热声增长率。\n\n数值灵敏度研究旨在量化这种影响。所指定的算法如下。对于每个测试用例：\n1. 对于每个模态 $m \\in \\{1, 2, \\dots, M\\}$，使用推导的公式和高分辨率网格 $N_{\\mathrm{ref}}$ 计算参考增长率 $\\sigma_m(N_{\\mathrm{ref}})$。\n2. 遍历每个指定的网格尺寸 $N$。对于每个 $N$，遍历每个模态 $m \\in \\{1, \\dots, M\\}$。\n3. 计算当前网格尺寸下的增长率 $\\sigma_m(N)$。\n4. 计算相对误差 $\\varepsilon_m(N) = \\left| \\sigma_m(N) - \\sigma_m(N_{\\mathrm{ref}}) \\right| / \\max\\left(\\left| \\sigma_m(N_{\\mathrm{ref}}) \\right|, \\epsilon_0 \\right)$。\n5. 测试用例的聚合灵敏度 $\\varepsilon_{\\max}$ 是在所有指定的 $m$ 和 $N$ 上计算出的所有相对误差 $\\varepsilon_m(N)$ 的最大值。\n此过程系统地评估了数值解向高分辨率参考值的收敛性，为离散化误差提供了一个定量的度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef calculate_max_error(params: dict) - float:\n    \"\"\"\n    Calculates the maximum relative error for a given test case.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the test case.\n\n    Returns:\n        float: The maximum relative error over all specified modes and grid sizes.\n    \"\"\"\n    L = params[\"L\"]\n    c = params[\"c\"]\n    G = params[\"G\"]\n    D = params[\"D\"]\n    tau = params[\"tau\"]\n    M = params[\"M\"]\n    N_list = params[\"N\"]\n    N_ref = params[\"N_ref\"]\n    epsilon_0 = params[\"epsilon_0\"]\n\n    modes = np.arange(1, M + 1)\n    all_errors = []\n\n    # Define the functions for angular frequency and growth rate based on the derivation.\n    # omega_m(N) = (2*c*N/L) * sin(pi*m/N)\n    def calculate_omega(m_vals, N_val, c_val, L_val):\n        return (2 * c_val * N_val / L_val) * np.sin(np.pi * m_vals / N_val)\n\n    # sigma_m(N) = G * cos(omega_m(N) * tau) - D\n    def calculate_sigma(omega_vals, G_val, D_val, tau_val):\n        return G_val * np.cos(omega_vals * tau_val) - D_val\n\n    # 1. Calculate the reference growth rates sigma_m(N_ref) for all modes.\n    omega_ref = calculate_omega(modes, N_ref, c, L)\n    sigma_ref = calculate_sigma(omega_ref, G, D, tau)\n\n    # Denominator for the relative error calculation\n    # max(|sigma_m(N_ref)|, epsilon_0)\n    denominators = np.maximum(np.abs(sigma_ref), epsilon_0)\n\n    # 2. Iterate through grid sizes and modes to calculate errors.\n    for N in N_list:\n        # Calculate omega and sigma for the current grid size N for all modes\n        omega_N = calculate_omega(modes, N, c, L)\n        sigma_N = calculate_sigma(omega_N, G, D, tau)\n        \n        # Calculate relative error for all modes for the current N\n        # ε_m(N) = |sigma_m(N) - sigma_m(N_ref)| / max(|sigma_m(N_ref)|, ε_0)\n        errors = np.abs(sigma_N - sigma_ref) / denominators\n        \n        all_errors.extend(errors)\n\n    # 3. Find the maximum error over all computations for this case.\n    if not all_errors:\n        return 0.0\n    \n    return np.max(all_errors)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"name\": \"A\",\n            \"L\": 1.0, \"c\": 600.0, \"G\": 100.0, \"D\": 20.0, \"tau\": 0.0020,\n            \"M\": 4, \"N\": [32, 64, 128, 256, 512], \"N_ref\": 4096,\n            \"epsilon_0\": 1e-12\n        },\n        # Test Case B\n        {\n            \"name\": \"B\",\n            \"L\": 1.0, \"c\": 340.0, \"G\": 50.0, \"D\": 5.0, \"tau\": 0.0,\n            \"M\": 3, \"N\": [8, 16, 32, 64], \"N_ref\": 4096,\n            \"epsilon_0\": 1e-12\n        },\n        # Test Case C\n        {\n            \"name\": \"C\",\n            \"L\": 1.5, \"c\": 650.0, \"G\": 80.0, \"D\": 10.0, \"tau\": 0.0006,\n            \"M\": 6, \"N\": [16, 24, 32, 48, 64, 96, 128, 256, 512, 1024],\n            \"N_ref\": 4096, \"epsilon_0\": 1e-12\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        max_error = calculate_max_error(case)\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}