{
    "hands_on_practices": [
        {
            "introduction": "在掌握了基本实现后，我们转向验证。一个正确的数值方案不仅要准确，还必须在离散层面上遵守质量、能量等基本量的守恒定律。本练习将开发一个诊断工具，用于检验周期性边界上局部通量的守恒性，这是确保数值实现不会引入非物理源或汇的关键一步。",
            "id": "4069994",
            "problem": "您的任务是构建、实现并验证一个诊断程序，该程序通过跟踪质量和化学组分随时间的守恒误差，来检测成对周期性面之间不匹配的周期性映射。背景是具有周期性边界条件处理的计算燃烧学。所有量均为无量纲。\n\n基本原理：从总质量和每种化学组分的积分守恒定律开始。对于一个空间域 $\\Omega$ 及其边界 $\\partial \\Omega$，密度场 $\\rho$，速度场 $\\boldsymbol{u}$，以及组分索引为 $s$ 的组分质量分数 $Y_{s}$，（在没有体积源的情况下）积分守恒定律为\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\Omega} \\rho \\,\\mathrm{d}V \\;=\\; - \\int_{\\partial \\Omega} \\rho \\,\\boldsymbol{u}\\cdot \\boldsymbol{n} \\,\\mathrm{d}S,\n\\qquad\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\Omega} \\rho Y_{s} \\,\\mathrm{d}V \\;=\\; - \\int_{\\partial \\Omega} \\rho Y_{s} \\,\\boldsymbol{u}\\cdot \\boldsymbol{n} \\,\\mathrm{d}S.\n$$\n对于一对具有向外单位法线 $\\boldsymbol{n}_{L}$ 和 $\\boldsymbol{n}_{R}$ 的周期性面 $\\Gamma_{L}$ 和 $\\Gamma_{R}$，一个正确的周期性映射 $M$ 将 $\\Gamma_{L}$ 上的每个点与 $\\Gamma_{R}$ 上的一个点配对，其性质是逐点的法向通量相互抵消：\n$$\n\\left.\\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{n}_{L}\\right|_{\\boldsymbol{x}\\in\\Gamma_{L}} \\;+\\; \\left.\\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{n}_{R}\\right|_{M(\\boldsymbol{x})\\in\\Gamma_{R}} \\;=\\; 0,\n$$\n$\\rho Y_{s}$ 的情况也类似。即使在 $\\Gamma_{L}\\cup\\Gamma_{R}$ 上的全局净通量积分为零，不匹配的映射也会违反这种成对抵消。因此，一个稳健的检测测试必须评估成对抵消，而不仅仅是全局净通量。\n\n待实现的离散化与诊断：考虑一个在 $x$ 方向上周期性的二维域。沿 $y$ 方向将周期性方向离散化为 $N_{y}$ 个长度为 $\\Delta y$ 的均匀段，由 $j\\in\\{0,\\dots,N_{y}-1\\}$ 索引，段中心位于 $y_{j}=\\left(j+\\tfrac{1}{2}\\right)\\Delta y$，其中 $\\Delta y = 1/N_{y}$。左、右周期性面分别为位于 $x=0$ 处的 $\\Gamma_{L}$ 和位于 $x=1$ 处的 $\\Gamma_{R}$。假设一个恒定的速度场 $\\boldsymbol{u}=(U,0)$ 且 $U\\ge 0$，并且各场仅依赖于 $y$：密度 $\\rho(y)$ 和两个组分质量分数 $Y_{1}(y)$ 和 $Y_{2}(y)$，满足 $Y_{1}(y)+Y_{2}(y)=1$。向外法线满足 $\\boldsymbol{n}_{L}=(-1,0)$ 和 $\\boldsymbol{n}_{R}=(+1,0)$。定义每个段的离散向外法向质量通量密度为\n$$\nf^{\\text{mass}}_{L}(j) \\;=\\; \\rho(y_{j})\\,\\boldsymbol{u}\\cdot \\boldsymbol{n}_{L} \\;=\\; -U\\,\\rho(y_{j}),\\qquad\nf^{\\text{mass}}_{R}(k) \\;=\\; \\rho(y_{k})\\,\\boldsymbol{u}\\cdot \\boldsymbol{n}_{R} \\;=\\; +U\\,\\rho(y_{k}),\n$$\n对于组分 $s\\in\\{1,2\\}$，\n$$\nf^{(s)}_{L}(j) \\;=\\; -U\\,\\rho(y_{j})\\,Y_{s}(y_{j}),\\qquad f^{(s)}_{R}(k) \\;=\\; +U\\,\\rho(y_{k})\\,Y_{s}(y_{k}).\n$$\n一个映射通过索引映射 $M:\\{0,\\dots,N_{y}-1\\}\\to\\{0,\\dots,N_{y}-1\\}$ 进行离散表示。对于一个正确的周期性映射，成对抵消满足对每个 $j$ 以及对质量和每个组分都有 $f_{L}(j)+f_{R}(M(j))=0$。为了检测不匹配，定义在时间间隔 $[0,T]$ 内（使用均匀时间步长 $\\Delta t$ 和 $N_{t}=T/\\Delta t$ 个步长）的累积成对守恒误差为\n$$\nE_{\\text{mass}} \\;=\\; \\sum_{n=0}^{N_{t}-1} \\Delta t \\sum_{j=0}^{N_{y}-1} \\left| f^{\\text{mass}}_{L}(j) + f^{\\text{mass}}_{R}(M(j)) \\right|\\,\\Delta y,\n$$\n$$\nE_{s} \\;=\\; \\sum_{n=0}^{N_{t}-1} \\Delta t \\sum_{j=0}^{N_{y}-1} \\left| f^{(s)}_{L}(j) + f^{(s)}_{R}(M(j)) \\right|\\,\\Delta y,\\quad s\\in\\{1,2\\}.\n$$\n当场不随时间变化时，误差与 $T$ 呈线性关系；对于正确的映射，在精确算术中所有误差都精确为零。\n\n您的任务：编写一个完整、可运行的程序来实现此诊断。使用以下固定的场定义和测试套件，并通过将 $E_{\\text{mass}},E_{1},E_{2}$ 各自与指定的容差 $\\varepsilon$ 进行比较来决定每个案例的通过/失败。\n\n使用的场定义：\n- $N_{y}$ 个段，其中 $y_{j}=\\left(j+\\tfrac{1}{2}\\right)/N_{y}$。\n- $\\rho(y) \\;=\\; 1 \\;+\\; 0.2\\,\\sin(2\\pi y) \\;+\\; 0.1\\,\\cos(4\\pi y)$。\n- $Y_{1}(y) \\;=\\; 0.5 \\;+\\; 0.3\\,\\sin(2\\pi y)$，且 $Y_{2}(y) \\;=\\; 1 - Y_{1}(y)$。\n\n每个测试案例的映射定义：\n- 映射偏移量 $s$ 指定 $M(j) \\equiv (j+s)\\bmod N_{y}$。\n\n时间积分参数：\n- 总时间 $T=1$ 且时间步数 $N_{t}=100$，因此 $\\Delta t = T/N_{t}$。\n\n判定规则：\n- 一个案例当且仅当 $E_{\\text{mass}}\\le \\varepsilon$ 且 $E_{1}\\le \\varepsilon$ 且 $E_{2}\\le \\varepsilon$ 时通过。\n\n测试套件：\n- 案例 $1$：$N_{y}=64$, $U=0.5$, $s=0$, $\\varepsilon=10^{-11}$。\n- 案例 $2$：$N_{y}=64$, $U=0$, $s=13$, $\\varepsilon=10^{-12}$。\n- 案例 $3$：$N_{y}=64$, $U=0.5$, $s=1$, $\\varepsilon=10^{-6}$。\n- 案例 $4$：$N_{y}=64$, $U=10^{-8}$, $s=1$, $\\varepsilon=10^{-6}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按测试套件顺序排列的结果，格式为方括号内以逗号分隔的 Python 布尔文字列表，例如，“[True,False,True,True]”。",
            "solution": "问题陈述已经过验证，并被确定是合理的。它在科学上基于连续介质力学的原理，特别是积分守恒定律，并提出了一个与计算燃烧学相关的适定数值问题。所有必要的数据、方程和条件都已提供，从而可以构建一个唯一且可验证的解决方案。\n\n任务是实现一个诊断工具，用于检测数值模拟中边界条件周期性映射的错误。该诊断基于量化跨越两个周期性面的质量和组分质量分数的局部、成对守恒误差。\n\n基本原理是域 $\\Omega$ 内某个量 $\\phi$ 的积分守恒定律，该定律指出，体积内 $\\phi$ 总量的时间变化率等于 $\\phi$ 穿过边界 $\\partial\\Omega$ 的净通量。对于密度 $\\rho$ 和组分质量分数 $Y_s$，速度场为 $\\boldsymbol{u}$，并忽略扩散输运和源项，这些定律是：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\Omega} \\rho \\,\\mathrm{d}V \\;=\\; - \\int_{\\partial \\Omega} \\rho \\,\\boldsymbol{u}\\cdot \\boldsymbol{n} \\,\\mathrm{d}S\n$$\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\Omega} \\rho Y_{s} \\,\\mathrm{d}V \\;=\\; - \\int_{\\partial \\Omega} \\rho Y_{s} \\,\\boldsymbol{u}\\cdot \\boldsymbol{n} \\,\\mathrm{d}S\n$$\n对于具有周期性边界的域，例如一对面 $\\Gamma_{L}$ 和 $\\Gamma_{R}$，全局守恒要求进入 $\\Gamma_{L}$ 的总通量等于流出 $\\Gamma_{R}$ 的总通量。然而，正确的数值实现需要一个更强的、逐点的条件。如果 $M$ 是将点 $\\boldsymbol{x} \\in \\Gamma_{L}$ 与点 $M(\\boldsymbol{x}) \\in \\Gamma_{R}$ 配对的映射，那么局部通量必须相互抵消。对于向外法线 $\\boldsymbol{n}_{L}$ 和 $\\boldsymbol{n}_{R}$，这意味着对流通量密度必须满足：\n$$\n\\left(\\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{n}_{L}\\right)\\big|_{\\boldsymbol{x}} \\;+\\; \\left(\\rho\\,\\boldsymbol{u}\\cdot\\boldsymbol{n}_{R}\\right)\\big|_{M(\\boldsymbol{x})} \\;=\\; 0\n$$\n不匹配的映射 $M$ 会违反这种局部抵消，导致数值误差。提议的诊断方法量化了这种违反。\n\n该问题将其简化为一个在 $x$ 方向上于 $x=0$（$\\Gamma_{L}$）和 $x=1$（$\\Gamma_{R}$）之间周期性的二维域。这些面被离散化为 $N_y$ 个长度为 $\\Delta y = 1/N_y$ 的段。段中心为 $y_j = (j+1/2)\\Delta y$，其中 $j \\in \\{0, \\dots, N_y-1\\}$。速度是恒定的，$\\boldsymbol{u}=(U,0)$，并且场 $\\rho(y)$ 和 $Y_s(y)$ 仅依赖于 $y$。向外法线为 $\\boldsymbol{n}_{L}=(-1,0)$ 和 $\\boldsymbol{n}_{R}=(+1,0)$。\n\n左面上段 $j$ 和右面上段 $k$ 的离散向外法向质量通量密度为：\n$$\nf^{\\text{mass}}_{L}(j) = -U\\,\\rho(y_{j}), \\qquad f^{\\text{mass}}_{R}(k) = +U\\,\\rho(y_{k})\n$$\n对应于组分 $s \\in \\{1, 2\\}$ 的组分通量为：\n$$\nf^{(s)}_{L}(j) = -U\\,\\rho(y_{j})\\,Y_{s}(y_{j}), \\qquad f^{(s)}_{R}(k) = +U\\,\\rho(y_{k})\\,Y_{s}(y_{k})\n$$\n对于将 $\\Gamma_L$ 上的段 $j$ 映射到 $\\Gamma_R$ 上段 $M(j)$ 的离散映射 $M(j)$，质量的局部抵消误差为 $|f^{\\text{mass}}_{L}(j) + f^{\\text{mass}}_{R}(M(j))|$。诊断误差度量 $E$ 是这些局部误差在整个边界和整个时间上的累积和。鉴于场是稳态的，对 $N_t$ 个大小为 $\\Delta t$ 的时间步的求和简化为乘以总时间 $T = N_t \\Delta t$。总质量的误差是：\n$$\nE_{\\text{mass}} \\;=\\; \\sum_{n=0}^{N_{t}-1} \\Delta t \\sum_{j=0}^{N_{y}-1} \\left| f^{\\text{mass}}_{L}(j) + f^{\\text{mass}}_{R}(M(j)) \\right|\\,\\Delta y \\;=\\; T \\cdot \\Delta y \\sum_{j=0}^{N_{y}-1} \\left| -U\\,\\rho(y_{j}) + U\\,\\rho(y_{M(j)}) \\right|\n$$\n由于 $U \\ge 0$，这简化为：\n$$\nE_{\\text{mass}} \\;=\\; T \\cdot U \\cdot \\Delta y \\sum_{j=0}^{N_{y}-1} \\left| \\rho(y_{M(j)}) - \\rho(y_j) \\right|\n$$\n类似地，对于组分 $s$：\n$$\nE_{s} \\;=\\; T \\cdot U \\cdot \\Delta y \\sum_{j=0}^{N_{y}-1} \\left| \\rho(y_{M(j)})Y_s(y_{M(j)}) - \\rho(y_j)Y_s(y_j) \\right|\n$$\n实现将按如下方式进行。对于每个由 ($N_y, U, s, \\varepsilon$) 定义的测试案例：\n$1$. 构建 $N_y$ 个点 $\\{y_j\\}$ 的网格。\n$2$. 计算 $\\rho(y_j)$、$Y_1(y_j)$ 和 $Y_2(y_j)$ 的场值并存储在数组中。还计算了类似质量通量的量 $\\phi_s(y_j)=\\rho(y_j)Y_s(y_j)$。\n$3$. 应用离散映射 $M(j) = (j+s)\\bmod N_y$。在计算上，这等效于场数组的周期性移位。一个值为 $q(y_j)$ 的数组 `q` 被映射到一个数组 `q_mapped`，其中 `q_mapped`$[j] = q(y_{M(j)})$。这可以通过对数组使用循环移位操作来高效实现。对于偏移量 $s$，这对应于向左循环移位 $s$ 个位置。\n$4$. 使用简化公式计算误差 $E_{\\text{mass}}$、$E_1$ 和 $E_2$。为提高效率，使用向量化操作。\n$5$. 如果所有三个误差 $E_{\\text{mass}}$、$E_1$ 和 $E_2$ 都小于或等于指定的容差 $\\varepsilon$，则该测试案例标记为“通过”(`True`)，否则标记为“失败”(`False`)。\n\n场定义为：\n- $\\rho(y) \\;=\\; 1 \\;+\\; 0.2\\,\\sin(2\\pi y) \\;+\\; 0.1\\,\\cos(4\\pi y)$\n- $Y_{1}(y) \\;=\\; 0.5 \\;+\\; 0.3\\,\\sin(2\\pi y)$\n- $Y_{2}(y) \\;=\\; 1 - Y_{1}(y)$\n\n固定参数为 $T = 1$ 和 $\\Delta t = T/100 = 0.01$。在简化的公式中，并不明确需要 $N_t=100$ 和 $\\Delta t$ 的值，只需要它们的乘积 $T$。\n该实现将使用 Python 进行，并使用 `numpy` 库进行数值计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates a diagnostic for mismatched periodic boundary\n    conditions in a computational combustion context.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Ny, U, s, epsilon)\n        (64, 0.5, 0, 1e-11),   # Case 1: Perfect mapping, should pass.\n        (64, 0.0, 13, 1e-12),  # Case 2: Zero velocity, no flux, should pass.\n        (64, 0.5, 1, 1e-6),    # Case 3: Mismatched mapping, should fail.\n        (64, 1e-8, 1, 1e-6),   # Case 4: Mismatched, but tiny velocity, should pass.\n    ]\n\n    T = 1.0  # Total simulation time.\n\n    results = []\n    for Ny, U, s, epsilon in test_cases:\n        # Step 1: Discretize the domain in the y-direction.\n        dy = 1.0 / Ny\n        y = (np.arange(Ny) + 0.5) * dy\n\n        # Step 2: Define and evaluate the spatially varying fields.\n        rho = 1.0 + 0.2 * np.sin(2 * np.pi * y) + 0.1 * np.cos(4 * np.pi * y)\n        Y1 = 0.5 + 0.3 * np.sin(2 * np.pi * y)\n        \n        # The species mass fractions must sum to 1.\n        # This implies rho*Y1 + rho*Y2 = rho.\n        phi1 = rho * Y1\n        phi2 = rho - phi1\n\n        # Step 3: Apply the periodic mapping M(j) = (j+s) mod Ny.\n        # This corresponds to a circular left shift by 's' positions.\n        # np.roll(arr, -s) shifts elements to the left.\n        rho_mapped = np.roll(rho, -s)\n        phi1_mapped = np.roll(phi1, -s)\n        phi2_mapped = np.roll(phi2, -s)\n\n        # A more numerically robust way to calculate phi2_mapped to enforce\n        # the conservation property rho = phi1 + phi2 exactly.\n        # phi2_mapped_alt = rho_mapped - phi1_mapped\n        # The results are identical in this case.\n\n        # Step 4: Calculate the cumulative pairwise conservation errors.\n        # The formulas are simplified for steady fields: E = T * U * dy * sum(|diff|).\n        \n        # Mass conservation error\n        diff_rho = rho_mapped - rho\n        E_mass = T * U * dy * np.sum(np.abs(diff_rho))\n\n        # Species 1 conservation error\n        diff_phi1 = phi1_mapped - phi1\n        E1 = T * U * dy * np.sum(np.abs(diff_phi1))\n\n        # Species 2 conservation error\n        # Can be derived from mass and species 1 differences\n        # diff_phi2 = phi2_mapped - phi2\n        #           = (rho_mapped - phi1_mapped) - (rho - phi1)\n        #           = (rho_mapped - rho) - (phi1_mapped - phi1)\n        #           = diff_rho - diff_phi1\n        diff_phi2 = diff_rho - diff_phi1\n        E2 = T * U * dy * np.sum(np.abs(diff_phi2))\n\n        # Step 5: Apply the decision rule.\n        # A case passes if and only if all three errors are within the tolerance.\n        passed = (E_mass = epsilon) and (E1 = epsilon) and (E2 = epsilon)\n        results.append(passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本节旨在连接数值方法与物理诠释。离散化选择看似微小，却可能引入数值伪影，如数值色散，即不同波长的波以不同速度传播。这项高级实践将演示周期性域中的数值色散如何改变对热声系统稳定性的预测，从而突显了收敛性研究对于确保结果具有物理意义且独立于网格分辨率的至关重要性。",
            "id": "4069956",
            "problem": "考虑一个长度为 $L$ 的一维预混周期性燃烧室，其基态声速为常数 $c$，基态密度为 $\\rho_0$。假设流动是静止的，没有平均流。小振幅热声扰动通过线性声学和一个带有时延的热释放闭合模型来建模。将声压扰动记为 $p'(x,t)$，声速扰动记为 $u'(x,t)$。基本方程组包括：(i) 线性化连续性方程 $ \\partial \\rho'/\\partial t + \\rho_0 \\, \\partial u'/\\partial x = 0 $，(ii) 线性化动量方程 $ \\rho_0 \\, \\partial u'/\\partial t + \\partial p'/\\partial x = 0 $，(iii) 理想气体声学闭合关系 $ p' = c^2 \\rho' $，以及 (iv) 一个带有时延 $ \\tau$ 的紧凑（空间局域）热释放扰动模型，定义为 $ q'(t) = \\kappa \\, u'(x_f, t - \\tau) $，其中 $x_f$ 是火焰位置，$\\kappa$ 是一个比例常数。在均匀周期性域中，您可以将 $x_f$ 视为任意值。Rayleigh判据指出，模态增长率与 $p'$ 和 $q'$ 的周期平均乘积成正比，其中阻尼 $D$ 用于解释粘性、热和辐射损失。在小振幅极限下，模态动力学可以通过角频率 $\\omega$ 和波数 $k$ 之间的色散关系，以及用时延和 $q'$ 与 $p'$ 之间的相位表示的模态增长率 $ \\sigma $ 的显式表达式来近似。\n\n周期性边界条件意味着空间本征模是区间 $[0,L)$ 上的谐波，并且空间导数的离散近似必须强制执行周期性环绕。考虑一个包含 $N$ 个点的均匀网格，网格间距为 $\\Delta x = L/N$，并使用施加了周期性边界条件的标准二阶中心差分来近似 $\\partial^2/\\partial x^2$。令 $m \\in \\{1,2,\\dots\\}$ 为模态数索引。有限差分近似会引入一个偏离连续关系的离散色散关系。周期性域的对称性产生的离散本征向量是网格谐波，其本征值依赖于 $N$ 和 $m$。这种数值色散会影响时延闭合模型中的相位，从而影响热声增长率。\n\n任务 1 (推导): 从上述基本方程组出发，并假设单个傅里叶模态拟设 $ p'(x,t) = \\Re\\{ P_m \\exp(i k x - i \\omega t) \\} $（其中 $P_m$ 为振幅，$m$ 为模态指数），推导连续色散关系，然后推导在含 $N$ 个点的均匀网格上，使用周期性边界条件的二阶中心差分拉普拉斯算子的离散色散关系。利用离散本征向量在网格索引 $ j \\in \\{0,1,\\dots,N-1\\} $ 处为 $ \\exp(i 2 \\pi m j / N) $ 这一事实，得到离散角频率 $ \\omega_m(N) $ 作为 $L$、$c$、$m$ 和 $N$ 的函数。然后，使用时延闭合模型，将模态增长率 $ \\sigma_m(N) $ 表示为耦合增益 $G$ 和阻尼 $D$ 的函数。使用所述基本定律证明每一步。确保所有角量均以弧度表示，并且所有推导出的增长率均以 $ \\mathrm{s}^{-1} $ 表示。\n\n任务 2 (算法与敏感性): 设计一个数值实验，通过改变 $N$ 并将 $ \\sigma_m(N) $ 与高分辨率参考值 $ \\sigma_m(N_{\\mathrm{ref}}) $ 进行比较，来量化 $ \\sigma_m(N) $ 对周期性边界条件离散化的敏感性。将每个模态 $m$ 和网格尺寸 $N$ 的相对误差定义为 $ \\varepsilon_{m}(N) = \\left| \\sigma_m(N) - \\sigma_m(N_{\\mathrm{ref}}) \\right| / \\max\\left(\\left| \\sigma_m(N_{\\mathrm{ref}}) \\right|, \\epsilon_0 \\right) $，其中 $ \\epsilon_0 $ 是一个小的正常数，用于避免除以零。通过取选定模态和网格尺寸上的最大值 $ \\varepsilon_{\\max} = \\max_{m,N} \\varepsilon_m(N) $ 来汇总敏感性。提出一个容差 $ \\varepsilon_{\\mathrm{tol}} $，并将网格无关性定义为条件 $ \\varepsilon_{\\max} \\le \\varepsilon_{\\mathrm{tol}} $。您的程序必须计算每个测试用例的 $ \\varepsilon_{\\max} $，并以无量纲浮点数的形式输出。\n\n任务 3 (实现与测试套件): 实现一个完整的、可运行的程序，执行基于推导的公式和敏感性研究。使用以下具有物理上合理的参数的测试套件。所有角度必须以弧度为单位，所有时间以秒为单位，$L$ 以米为单位，$c$ 以米/秒为单位，$G$ 和 $D$ 以 $ \\mathrm{s}^{-1} $ 为单位。在最终输出中仅报告无量纲相对误差。对于每个测试用例，计算模态 $m = 1,2,\\dots,M$。\n\n- 测试用例 A (一般情况): $ L = 1.0\\,\\mathrm{m} $, $ c = 600.0\\,\\mathrm{m/s} $, $ G = 100.0\\,\\mathrm{s}^{-1} $, $ D = 20.0\\,\\mathrm{s}^{-1} $, $ \\tau = 0.0020\\,\\mathrm{s} $, $ M = 4 $, $ N \\in \\{32,64,128,256,512\\} $, $ N_{\\mathrm{ref}} = 4096 $, $ \\varepsilon_{\\mathrm{tol}} = 10^{-4} $, $ \\epsilon_0 = 10^{-12} $。\n\n- 测试用例 B (零时延边界情况): $ L = 1.0\\,\\mathrm{m} $, $ c = 340.0\\,\\mathrm{m/s} $, $ G = 50.0\\,\\mathrm{s}^{-1} $, $ D = 5.0\\,\\mathrm{s}^{-1} $, $ \\tau = 0.0\\,\\mathrm{s} $, $ M = 3 $, $ N \\in \\{8,16,32,64\\} $, $ N_{\\mathrm{ref}} = 4096 $, $ \\varepsilon_{\\mathrm{tol}} = 10^{-10} $, $ \\epsilon_0 = 10^{-12} $。在此情况下，时延相位为零，因此如果周期性边界条件被正确执行，增长率应与 $N$ 无关。\n\n- 测试用例 C (相位敏感情况): $ L = 1.5\\,\\mathrm{m} $, $ c = 650.0\\,\\mathrm{m/s} $, $ G = 80.0\\,\\mathrm{s}^{-1} $, $ D = 10.0\\,\\mathrm{s}^{-1} $, $ \\tau = 0.0006\\,\\mathrm{s} $, $ M = 6 $, $ N \\in \\{16,24,32,48,64,96,128,256,512,1024\\} $, $ N_{\\mathrm{ref}} = 4096 $, $ \\varepsilon_{\\mathrm{tol}} = 10^{-4} $, $ \\epsilon_0 = 10^{-12} $。\n\n最终输出格式规范：您的程序应生成一行输出，其中包含三个测试用例的最大相对误差，形式为逗号分隔的列表，并用方括号括起来，例如 $ [\\varepsilon_{\\max}^{(A)},\\varepsilon_{\\max}^{(B)},\\varepsilon_{\\max}^{(C)}] $，其中每个条目都是一个无量纲浮点数。不得打印任何其他文本。程序必须是自包含的，并且无需用户输入即可执行。",
            "solution": "该问题是有效的，因为它在科学上基于线性声学和计算物理学的原理，是适定的，具有明确的目标和充足的数据，并且没有矛盾或歧义。因此，我们可以进行推导和求解。\n\n根据要求，分析分为三个部分：推导解析和数值关系，构建敏感性分析算法，以及实现完整的程序。\n\n首先，我们从所提供的基本原理推导波动方程。线性化连续性方程和动量方程为：\n$$\n\\frac{\\partial \\rho'}{\\partial t} + \\rho_0 \\frac{\\partial u'}{\\partial x} = 0 \\quad \\text{(i)}\n$$\n$$\n\\rho_0 \\frac{\\partial u'}{\\partial t} + \\frac{\\partial p'}{\\partial x} = 0 \\quad \\text{(ii)}\n$$\n我们对方程 (i) 关于时间 $t$ 求导，对方程 (ii) 关于空间 $x$ 求导：\n$$\n\\frac{\\partial^2 \\rho'}{\\partial t^2} + \\rho_0 \\frac{\\partial^2 u'}{\\partial t \\partial x} = 0\n$$\n$$\n\\rho_0 \\frac{\\partial^2 u'}{\\partial x \\partial t} + \\frac{\\partial^2 p'}{\\partial x^2} = 0\n$$\n假设场具有足够的连续性，混合偏导数是相等的。因此，我们可以将涉及声速 $u'$ 的项相等：\n$$\n\\rho_0 \\frac{\\partial^2 u'}{\\partial t \\partial x} = -\\frac{\\partial^2 \\rho'}{\\partial t^2} = \\rho_0 \\frac{\\partial^2 u'}{\\partial x \\partial t} = -\\frac{\\partial^2 p'}{\\partial x^2}\n$$\n这就得出了压力 $p'$ 和密度 $\\rho'$ 扰动之间的关系：\n$$\n\\frac{\\partial^2 \\rho'}{\\partial t^2} = \\frac{\\partial^2 p'}{\\partial x^2}\n$$\n使用理想气体声学闭合关系 $p' = c^2 \\rho'$（这意味着 $\\rho' = p'/c^2$），并将其代入上式，我们得到声压的一维齐次波动方程：\n$$\n\\frac{1}{c^2} \\frac{\\partial^2 p'}{\\partial t^2} - \\frac{\\partial^2 p'}{\\partial x^2} = 0\n$$\n这个方程控制着在没有源项和耗散情况下的声波传播，这些决定了系统的固有模态和频率。\n\n接下来，我们推导连续色散关系。我们考虑形式为 $p'(x,t) = \\Re\\{ P_m \\exp(i k x - i \\omega t) \\}$ 的单个傅里叶模态拟设，其中 $P_m$ 是复振幅，$k$ 是波数，$\\omega$ 是角频率。将其代入波动方程得到：\n$$\n\\frac{1}{c^2} (-i \\omega)^2 P_m e^{i(kx-\\omega t)} - (ik)^2 P_m e^{i(kx-\\omega t)} = 0\n$$\n$$\n-\\frac{\\omega^2}{c^2} + k^2 = 0 \\implies \\omega^2 = c^2 k^2\n$$\n这就得到了连续色散关系 $\\omega = \\pm c k$。对于长度为 $L$ 的周期性域，波数 $k$ 是量子化的以确保周期性，即 $p'(x+L,t) = p'(x,t)$。这要求 $kL = 2\\pi m$，其中整数模态数 $m \\in \\{1, 2, ...\\}$。模态 $m=0$ 对应于空间均匀的压力扰动，不是声波。因此，连续固有角频率为：\n$$\n\\omega_{m, \\text{cont}} = c |k_m| = \\frac{2 \\pi c m}{L}\n$$\n\n现在我们推导由空间离散化产生的离散色散关系。长度为 $L$ 的域被离散为 $N$ 个均匀的网格区间，网格间距为 $\\Delta x = L/N$。在网格点 $j$ 处的半离散波动方程是通过将空间导数 $\\partial^2/\\partial x^2$ 替换为其二阶中心差分近似得到的：\n$$\n\\frac{d^2 p'_j(t)}{dt^2} = c^2 \\frac{p'_{j+1}(t) - 2p'_j(t) + p'_{j-1}(t)}{(\\Delta x)^2}\n$$\n其中周期性边界条件意味着 $p'_{N} = p'_{0}$ 和 $p'_{-1} = p'_{N-1}$。问题陈述中指出，离散本征向量是形式为 $\\exp(i 2 \\pi m j / N)$ 的网格谐波。让我们将离散拉普拉斯算子应用于此本征向量：\n$$\n\\frac{e^{i 2 \\pi m (j+1)/N} - 2e^{i 2 \\pi m j/N} + e^{i 2 \\pi m (j-1)/N}}{(\\Delta x)^2} = \\frac{e^{i 2 \\pi m j/N}}{(\\Delta x)^2} \\left( e^{i 2 \\pi m / N} - 2 + e^{-i 2 \\pi m / N} \\right)\n$$\n使用恒等式 $2\\cos\\theta = e^{i\\theta} + e^{-i\\theta}$，上式简化为：\n$$\n\\frac{e^{i 2 \\pi m j/N}}{(\\Delta x)^2} \\left( 2\\cos\\left(\\frac{2\\pi m}{N}\\right) - 2 \\right) = \\frac{e^{i 2 \\pi m j/N}}{(\\Delta x)^2} \\left( -4\\sin^2\\left(\\frac{\\pi m}{N}\\right) \\right)\n$$\n因此，模态 $m$ 的离散拉普拉斯算子的本征值为 $\\lambda_m = -\\frac{4}{(\\Delta x)^2} \\sin^2(\\frac{\\pi m}{N})$。将拟设 $p'_j(t) = P_m \\exp(-i \\omega_m(N) t)$ 代入半离散波动方程，其中 $\\omega_m(N)$ 是离散角频率，我们得到：\n$$\n(-i \\omega_m(N))^2 = c^2 \\lambda_m \\implies -\\omega_m(N)^2 = -c^2 \\frac{4}{(\\Delta x)^2} \\sin^2\\left(\\frac{\\pi m}{N}\\right)\n$$\n求解 $\\omega_m(N)$ 并代入 $\\Delta x = L/N$ 得到离散色散关系：\n$$\n\\omega_m(N) = \\frac{2c}{\\Delta x} \\left| \\sin\\left(\\frac{\\pi m}{N}\\right) \\right| = \\frac{2cN}{L} \\sin\\left(\\frac{\\pi m}{N}\\right)\n$$\n其中我们取频率的正根，并假设 $m \\le N/2$ 以使正弦项为正。这个数值频率 $\\omega_m(N)$ 偏离了连续频率 $\\omega_{m, \\text{cont}}$，这种效应被称为数值色散。\n\n最后，我们推导模态增长率 $\\sigma_m(N)$ 的表达式。Rayleigh判据指出，增长率与压力 $p'$ 和热释放率 $q'$ 的周期平均乘积成正比。对于时延模型 $q'(t) = \\kappa \\, u'(x_f, t-\\tau)$，增长率由压力和热释放之间的相位差决定。从线性化动量方程 (ii) 出发，假设单个行波分量为 $\\tilde{p}=P_m e^{i(kx-\\omega t)}$，则复速度为 $\\tilde{u} = \\frac{k}{\\rho_0 \\omega}\\tilde{p}$。由于 $k$ 和 $\\omega$ 是实数，$\\tilde{u}$ 和 $\\tilde{p}$ 是同相的。复热释放率为 $\\tilde{q}(t) = \\kappa \\tilde{u}(x_f, t-\\tau) \\propto e^{-i\\omega(t-\\tau)} = e^{-i\\omega t} e^{i\\omega\\tau}$。因此，$\\tilde{q}(t)$ 和 $\\tilde{p}(x_f, t)$ 之间的相位差为 $\\phi = \\omega\\tau$。增长率的简化形式，包含了火焰-声学耦合增益 $G$ 和系统级阻尼 $D$，则为 $\\sigma = G \\cos(\\phi) - D$。使用离散频率 $\\omega_m(N)$，在大小为 $N$ 的网格上，模态 $m$ 的增长率为：\n$$\n\\sigma_m(N) = G \\cos(\\omega_m(N) \\tau) - D\n$$\n结合我们的结果，最终的表达式是：\n$$\n\\sigma_m(N) = G \\cos\\left( \\left[ \\frac{2cN}{L} \\sin\\left(\\frac{\\pi m}{N}\\right) \\right] \\tau \\right) - D\n$$\n该表达式表明，$\\omega_m(N)$ 中的数值色散通过改变反馈回路的相位，直接影响计算出的热声增长率。\n\n数值敏感性研究旨在量化这种影响。指定的算法如下。对于每个测试用例：\n1. 对于每个模态 $m \\in \\{1, 2, \\dots, M\\}$，使用推导的公式和高分辨率网格 $N_{\\mathrm{ref}}$ 计算参考增长率 $\\sigma_m(N_{\\mathrm{ref}})$。\n2. 遍历每个指定的网格尺寸 $N$。对于每个 $N$，遍历每个模态 $m \\in \\{1, \\dots, M\\}$。\n3. 计算当前网格尺寸下的增长率 $\\sigma_m(N)$。\n4. 计算相对误差 $\\varepsilon_m(N) = \\left| \\sigma_m(N) - \\sigma_m(N_{\\mathrm{ref}}) \\right| / \\max\\left(\\left| \\sigma_m(N_{\\mathrm{ref}}) \\right|, \\epsilon_0 \\right)$。\n5. 测试用例的汇总敏感性 $\\varepsilon_{\\max}$ 是在所有指定的 $m$ 和 $N$ 上计算出的所有相对误差 $\\varepsilon_m(N)$ 的最大值。\n这个过程系统地评估了数值解向高分辨率参考值的收敛性，为离散化误差提供了一个定量的度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef calculate_max_error(params: dict) - float:\n    \"\"\"\n    Calculates the maximum relative error for a given test case.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the test case.\n\n    Returns:\n        float: The maximum relative error over all specified modes and grid sizes.\n    \"\"\"\n    L = params[\"L\"]\n    c = params[\"c\"]\n    G = params[\"G\"]\n    D = params[\"D\"]\n    tau = params[\"tau\"]\n    M = params[\"M\"]\n    N_list = params[\"N\"]\n    N_ref = params[\"N_ref\"]\n    epsilon_0 = params[\"epsilon_0\"]\n\n    modes = np.arange(1, M + 1)\n    all_errors = []\n\n    # Define the functions for angular frequency and growth rate based on the derivation.\n    # omega_m(N) = (2*c*N/L) * sin(pi*m/N)\n    def calculate_omega(m_vals, N_val, c_val, L_val):\n        return (2 * c_val * N_val / L_val) * np.sin(np.pi * m_vals / N_val)\n\n    # sigma_m(N) = G * cos(omega_m(N) * tau) - D\n    def calculate_sigma(omega_vals, G_val, D_val, tau_val):\n        return G_val * np.cos(omega_vals * tau_val) - D_val\n\n    # 1. Calculate the reference growth rates sigma_m(N_ref) for all modes.\n    omega_ref = calculate_omega(modes, N_ref, c, L)\n    sigma_ref = calculate_sigma(omega_ref, G, D, tau)\n\n    # Denominator for the relative error calculation\n    # max(|sigma_m(N_ref)|, epsilon_0)\n    denominators = np.maximum(np.abs(sigma_ref), epsilon_0)\n\n    # 2. Iterate through grid sizes and modes to calculate errors.\n    for N in N_list:\n        # Calculate omega and sigma for the current grid size N for all modes\n        omega_N = calculate_omega(modes, N, c, L)\n        sigma_N = calculate_sigma(omega_N, G, D, tau)\n        \n        # Calculate relative error for all modes for the current N\n        # ε_m(N) = |sigma_m(N) - sigma_m(N_ref)| / max(|sigma_m(N_ref)|, ε_0)\n        errors = np.abs(sigma_N - sigma_ref) / denominators\n        \n        all_errors.extend(errors)\n\n    # 3. Find the maximum error over all computations for this case.\n    if not all_errors:\n        return 0.0\n    \n    return np.max(all_errors)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"name\": \"A\",\n            \"L\": 1.0, \"c\": 600.0, \"G\": 100.0, \"D\": 20.0, \"tau\": 0.0020,\n            \"M\": 4, \"N\": [32, 64, 128, 256, 512], \"N_ref\": 4096,\n            \"epsilon_0\": 1e-12\n        },\n        # Test Case B\n        {\n            \"name\": \"B\",\n            \"L\": 1.0, \"c\": 340.0, \"G\": 50.0, \"D\": 5.0, \"tau\": 0.0,\n            \"M\": 3, \"N\": [8, 16, 32, 64], \"N_ref\": 4096,\n            \"epsilon_0\": 1e-12\n        },\n        # Test Case C\n        {\n            \"name\": \"C\",\n            \"L\": 1.5, \"c\": 650.0, \"G\": 80.0, \"D\": 10.0, \"tau\": 0.0006,\n            \"M\": 6, \"N\": [16, 24, 32, 48, 64, 96, 128, 256, 512, 1024],\n            \"N_ref\": 4096, \"epsilon_0\": 1e-12\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        max_error = calculate_max_error(case)\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}