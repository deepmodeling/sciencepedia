{
    "hands_on_practices": [
        {
            "introduction": "理解数值误差通常始于分析简单的模型问题。本练习使用傅里叶分析这一强大工具，来分离和量化空间和时间离散格式在线性平流方程中引入的相速度误差。这有助于建立关于数值方法的不同部分如何影响总误差的直观认识。",
            "id": "4074159",
            "problem": "考虑一维线性平流方程，该方程是计算燃烧学中的一个典型基本模块，用于描述反应流中代表混合物分数的平滑被动标量，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\n其中平流速度 $a0$ 为常数，网格为间距 $\\Delta x$ 的均匀网格。设其精确解为单一傅里叶模式\n$$\nu(x,t) = \\sin(k x - a t),\n$$\n其波数 $k0$，因此其无量纲网格波数为 $\\theta = k \\Delta x$。考虑一个全离散方法，该方法对空间导数使用二阶中心差分，对时间积分使用三阶强稳定性保持龙格-库塔 (SSP-RK3) 方法，时间步长为 $\\Delta t$，库朗-弗里德里希-列维 (CFL) 数 $\\nu = a \\Delta t / \\Delta x = 0.5$。使用傅里叶 (冯·诺依曼) 分析和小 $\\theta$ 渐近分析，将分数相速度误差 $\\delta$ 定义为 $c_{\\text{num}} = a (1 + \\delta)$，其中 $c_{\\text{num}}$ 是数值相速度。\n\n推导在 $\\theta$ 的最低非零阶（直至并包含 $\\mathcal{O}(\\theta^{4})$）下，$\\delta$ 的独立贡献项，这些贡献分别来自：\n- 单独的空间离散化（假设时间积分为精确的），以及\n- 单独的时间离散化（假设空间导数为精确的）。\n\n将你的最终答案表示为一个行矩阵，其中包含根据指定的 CFL 数用 $\\theta$ 表示的两个分数误差，第一个元素对应空间贡献，第二个元素对应时间贡献。无需四舍五入，所有量均为无量纲。最终表达式中不要包含单位。",
            "solution": "题目要求分析求解一维线性平流方程 $\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0$ 的数值格式的分数相速度误差 $\\delta$。分析需使用傅里叶模式和渐近展开进行。空间离散和时间离散的贡献需要分开确定。\n\n首先，我们只考虑空间离散的贡献，假设时间积分是精确的。这对应于分析半离散问题。空间导数 $\\frac{\\partial u}{\\partial x}$ 由二阶中心差分算子 $\\delta_x^{(2)}$ 近似：\n$$\n\\frac{d u_j}{d t} = -a \\delta_x^{(2)} u_j = -a \\frac{u_{j+1} - u_{j-1}}{2 \\Delta x}\n$$\n我们将一个傅里叶模式 $u_j(t) = \\hat{u}(t) e^{i k x_j}$ 代入半离散方程，得到一个关于傅里叶振幅 $\\hat{u}(t)$ 的常微分方程 (ODE)：\n$$\n\\frac{d\\hat{u}}{dt} = -a \\hat{u} \\frac{e^{i k \\Delta x} - e^{-i k \\Delta x}}{2 \\Delta x} = -i \\frac{a \\sin(k \\Delta x)}{\\Delta x} \\hat{u}\n$$\n该 ODE 的形式为 $\\frac{d\\hat{u}}{dt} = -i \\omega_{\\text{num,space}} \\hat{u}$，其中数值频率 $\\omega_{\\text{num,space}} = \\frac{a}{\\Delta x} \\sin(k \\Delta x)$。数值相速度定义为 $c_{\\text{num}} = \\omega_{\\text{num}}/k$。因此，空间离散的数值相速度为：\n$$\nc_{\\text{num,space}} = \\frac{\\omega_{\\text{num,space}}}{k} = \\frac{a \\sin(k \\Delta x)}{k \\Delta x}\n$$\n使用无量纲网格波数 $\\theta = k \\Delta x$，上式变为 $c_{\\text{num,space}} = a \\frac{\\sin(\\theta)}{\\theta}$。分数相速度误差 $\\delta_{\\text{space}}$ 由 $c_{\\text{num,space}} = a(1 + \\delta_{\\text{space}})$ 定义。因此：\n$$\n\\delta_{\\text{space}} = \\frac{c_{\\text{num,space}}}{a} - 1 = \\frac{\\sin(\\theta)}{\\theta} - 1\n$$\n为了找出小 $\\theta$ 时该误差的主阶项，我们使用 $\\sin(\\theta)$ 的泰勒级数展开：\n$$\n\\frac{\\sin(\\theta)}{\\theta} = \\frac{\\theta - \\frac{\\theta^3}{6} + \\frac{\\theta^5}{120} - \\mathcal{O}(\\theta^7)}{\\theta} = 1 - \\frac{\\theta^2}{6} + \\frac{\\theta^4}{120} - \\mathcal{O}(\\theta^6)\n$$\n由空间离散引起的分数误差，到并包括 $\\mathcal{O}(\\theta^4)$ 阶项为：\n$$\n\\delta_{\\text{space}} = \\left(1 - \\frac{\\theta^2}{6} + \\frac{\\theta^4}{120}\\right) - 1 = -\\frac{1}{6}\\theta^2 + \\frac{1}{120}\\theta^4\n$$\n\n接下来，我们只考虑时间离散的贡献，假设空间导数是精确计算的。平流方程变成一个关于傅里叶振幅随时间演化的 ODE：$\\frac{d u}{d t} = -iak u$。这是一个形如 $\\frac{d\\phi}{dt} = \\lambda \\phi$ 的 ODE，其中 $\\lambda = -iak$。我们使用三阶强稳定性保持龙格-库塔 (SSP-RK3) 方法来求解它。该方法的放大因子 $G_{\\text{num,time}}(z)$ 为：\n$$\nG_{\\text{num,time}}(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3\n$$\n其中 $z = \\lambda \\Delta t = -iak \\Delta t = -i(a \\frac{\\Delta t}{\\Delta x})(k \\Delta x) = -i\\nu\\theta$。精确放大因子是 $G_{\\text{exact}} = e^z$。分数相速度误差 $\\delta_{\\text{time}}$ 与数值放大因子的相位误差有关。我们可以通过分析 $\\ln(G_{\\text{num,time}})$ 来找到相位。\n$$\n\\ln(G_{\\text{num,time}}) = \\ln(G_{\\text{exact}} + (G_{\\text{num,time}} - G_{\\text{exact}})) = \\ln(e^z(1 + e^{-z}(G_{\\text{num,time}} - G_{\\text{exact}})))\n$$\n展开 $e^z$ 的泰勒级数，我们知道 $G_{\\text{num,time}}(z) - G_{\\text{exact}}(z) = - \\frac{z^4}{24} - \\frac{z^5}{120} - \\mathcal{O}(z^6)$。\n$$\n\\ln(G_{\\text{num,time}}) = z + \\ln\\left(1 - e^{-z}\\left(\\frac{z^4}{24} + \\frac{z^5}{120} + \\dots\\right)\\right)\n$$\n使用 $\\ln(1-x) \\approx -x$ 和 $e^{-z} \\approx 1 - z + z^2/2 - \\dots$：\n$$\n\\ln(G_{\\text{num,time}}) \\approx z - e^{-z}\\left(\\frac{z^4}{24} + \\frac{z^5}{120} + \\dots\\right) \\approx z - (1 - z + \\dots)\\left(\\frac{z^4}{24} + \\frac{z^5}{120} + \\dots\\right)\n$$\n$$\n\\ln(G_{\\text{num,time}}) \\approx z - \\left(\\frac{z^4}{24} + \\frac{z^5}{120} - \\frac{z^5}{24} + \\dots\\right) = z - \\left(\\frac{z^4}{24} - \\frac{4z^5}{120}\\right) = z - \\frac{z^4}{24} + \\frac{z^5}{30}\n$$\n在一个时间步长内的数值相位是 $\\phi_{\\text{num}} = -\\text{Im}(\\ln(G_{\\text{num,time}}))$。代入 $z = -i\\nu\\theta$：\n$$\nz^4 = (-i\\nu\\theta)^4 = (\\nu\\theta)^4\n$$\n$$\nz^5 = (-i\\nu\\theta)^5 = -i(\\nu\\theta)^5\n$$\n$$\n\\phi_{\\text{num}} = -\\text{Im}\\left(-i\\nu\\theta - \\frac{(\\nu\\theta)^4}{24} - i\\frac{(\\nu\\theta)^5}{30}\\right) = \\nu\\theta + \\frac{(\\nu\\theta)^5}{30}\n$$\n精确相位是 $\\phi_{\\text{exact}} = \\nu\\theta$。相位误差是 $\\Delta\\phi = \\phi_{\\text{num}} - \\phi_{\\text{exact}} = \\frac{(\\nu\\theta)^5}{30}$。分数相速度误差 $\\delta_{\\text{time}}$ 定义为：\n$$\n\\delta_{\\text{time}} = \\frac{c_{\\text{num,time}} - a}{a} = \\frac{\\phi_{\\text{num}}/(k\\Delta t) - \\phi_{\\text{exact}}/(k\\Delta t)}{a} = \\frac{\\Delta\\phi}{ak\\Delta t} = \\frac{\\Delta\\phi}{\\nu\\theta}\n$$\n因此，\n$$\n\\delta_{\\text{time}} = \\frac{(\\nu\\theta)^5/30}{\\nu\\theta} = \\frac{\\nu^4\\theta^4}{30}\n$$\n给定 CFL 数 $\\nu = 0.5 = 1/2$，我们得到：\n$$\n\\delta_{\\text{time}} = \\frac{(1/2)^4 \\theta^4}{30} = \\frac{(1/16) \\theta^4}{30} = \\frac{1}{480}\\theta^4\n$$\n由空间离散引起的第一个贡献是 $\\delta_{\\text{space}} = -\\frac{1}{6}\\theta^2 + \\frac{1}{120}\\theta^4$。由时间离散引起的第二个贡献是 $\\delta_{\\text{time}} = \\frac{1}{480}\\theta^4$。\n最终答案是一个包含这两个表达式的行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-\\frac{1}{6}\\theta^{2} + \\frac{1}{120}\\theta^{4}  \\frac{1}{480}\\theta^{4}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "从理论走向实践，本练习将要求您编写代码来求解一个模型问题并验证其格式的精度。通过在系列加密网格上实施“人造解方法”（Method of Manufactured Solutions）并使用理查森外推法（Richardson extrapolation），您将学习一个计算测量精度阶和主误差常数的标准流程，这是代码验证的一项关键技能。",
            "id": "4074120",
            "problem": "考虑一个代表计算燃烧中标量输运的一维稳态平流-扩散-反应模型。在空间域 $x \\in [0,1]$ 上，未知标量场 $u(x)$ 满足以下边值问题\n$$\n- \\frac{d}{dx} \\left( D \\frac{d u}{dx} \\right) + v \\frac{d u}{dx} + k u = s(x),\n$$\n边界条件为狄利克雷（Dirichlet）边界条件 $u(0) = u_0$ 和 $u(1) = u_1$。此处，$D$ 是扩散系数，$v$ 是平流速度（假设 $v \\ge 0$），$k$ 是线性反应速率，$s(x)$ 是一个人为设定的源项，其定义使得所选的光滑函数 $u_{\\mathrm{exact}}(x)$ 是该连续方程的精确解：\n$$\ns(x) = - D \\frac{d^2 u_{\\mathrm{exact}}}{dx^2}(x) + v \\frac{d u_{\\mathrm{exact}}}{dx}(x) + k\\, u_{\\mathrm{exact}}(x).\n$$\n使用具有 $N$ 个单元和网格间距 $h = 1/N$ 的均匀网格上的有限体积法（Finite Volume Method, FVM），在与节点 $x_i = i h$ (其中 $i = 0,1,\\dots,N$) 对齐的单元中心处对控制方程进行离散化。假设 $D$、$v$ 和 $k$ 为常数，并对扩散项使用二阶中心差分近似，对平流项使用一阶迎风近似（对 $v  0$ 有效），在节点处使用点态反应项，则内部节点 $i = 1,2,\\dots,N-1$ 的离散方程形式如下\n$$\n- D \\frac{u_{i+1} - 2 u_i + u_{i-1}}{h^2} + v \\frac{u_i - u_{i-1}}{h} + k u_i = s(x_i),\n$$\n并在边界上指定 $u_0 = u_{\\mathrm{exact}}(0)$ 和 $u_N = u_{\\mathrm{exact}}(1)$。\n\n设网格以整数比率 $r \\ge 2$ 进行加密，生成三个嵌套网格，分别包含 $N_1$、$N_2 = r N_1$ 和 $N_3 = r N_2$ 个单元，对应的网格尺寸为 $h_1$、$h_2 = h_1/r$ 和 $h_3 = h_2/r$。在每个网格上，求解离散系统后，定义一个标量“关注量”（Quantity of Interest, QoI）$Q(h)$，即在中点 $x = 0.5$ 处的离散解值（当 $N$ 为偶数时，该点是一个网格节点）。假设离散 QoI 存在一个渐近误差展开式\n$$\nQ(h) = Q^\\star + C h^p + \\mathcal{O}(h^{p+1}),\n$$\n其中 $Q^\\star$ 是与网格无关的极限值，$p  0$ 是精度阶数，$C$ 是渐近误差常数。目标是利用这三个嵌套网格构建一个理查森外推（Richardson extrapolation）框架，以估计 $p$ 和 $C$。\n\n你的任务是：\n- 对每个测试用例，在三个嵌套网格上实现上述 FVM 离散化方法，以求解 $u(x)$。\n- 仅使用三个离散 QoI $Q(h_1)$、$Q(h_2)$、$Q(h_3)$ 和加密比率 $r$，基于渐近误差模型并通过代数消去未知量 $Q^\\star$，推导并实现一个估计 $p$ 和 $C$ 的过程。\n- 通过在你的估计中使用所有三个网格的信息，确保算法对中等程度的前渐近效应具有鲁棒性。\n\n推导过程中的所有变量都必须进行数学处理，需要时明确使用渐近误差定义和对数的标准性质，不得使用问题陈述中提供的任何快捷公式。\n\n程序必须执行以下测试套件，为每个用例解决上述问题，并输出每个用例的估计阶数 $p$ 和常数 $C$：\n\n- 测试用例 1（扩散-反应，预期为二阶）：\n    - $D = 0.1$, $v = 0$, $k = 1$, $u_{\\mathrm{exact}}(x) = \\sin(\\pi x)$, $N_1 = 16$, $r = 2$。\n- 测试用例 2（平流主导，预期为一阶迎风）：\n    - $D = 0.005$, $v = 3$, $k = 0.5$, $u_{\\mathrm{exact}}(x) = \\sin(2\\pi x)$, $N_1 = 32$, $r = 2$。\n- 测试用例 3（扩散-反应，使用非二倍率加密）：\n    - $D = 0.01$, $v = 0$, $k = 2$, $u_{\\mathrm{exact}}(x) = e^{x}$, $N_1 = 12$, $r = 3$。\n- 测试用例 4（混合机制，具有显著反应，迎风平流）：\n    - $D = 0.02$, $v = 1$, $k = 10$, $u_{\\mathrm{exact}}(x) = \\cosh(2(x - 0.5))$, $N_1 = 18$, $r = 2$。\n\n对于每个测试用例，$u_0$ 和 $u_1$ 必须分别设置为 $u_{\\mathrm{exact}}(0)$ 和 $u_{\\mathrm{exact}}(1)$。三角函数中使用的角度必须是弧度。由于问题是以无量纲形式提出的，因此不需要物理单位。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素本身是一个包含相应测试用例的浮点值 $[p, C]$ 的二元列表。例如，一个有效的输出格式是：\n$$\n[[p_1,C_1],[p_2,C_2],[p_3,C_3],[p_4,C_4]].\n$$",
            "solution": "问题陈述经评估具有科学依据、良态、客观且自洽。它提出了一个使用有限体积法（FVM）求解边值问题的标准练习，并通过人造解法和理查森外推法验证数值格式的精度。所有参数、方程和目标都已明确定义。不存在不一致、歧义或事实错误。因此，该问题是有效的，并提供了一个解决方案。\n\n解决方案分三个阶段展开。首先，我们将 FVM 离散化形式化为一个线性代数系统。其次，我们推导精度阶数 $p$ 和主误差常数 $C$ 的估计量。第三，我们概述了解决给定测试用例的计算算法。\n\n### 1. 有限体积离散化与线性系统构建\n\n控制方程为一维平流-扩散-反应方程：\n$$\n- \\frac{d}{dx} \\left( D \\frac{d u}{dx} \\right) + v \\frac{d u}{dx} + k u = s(x)\n$$\n假设扩散系数 $D$ 为常数，方程简化为：\n$$\n-D \\frac{d^2 u}{dx^2} + v \\frac{d u}{dx} + k u = s(x)\n$$\n问题指定了在包含 $N$ 个单元的均匀网格上进行类似有限差分的离散化，该网格有 $N+1$ 个节点 $x_i = i h$，其中 $i=0, 1, \\dots, N$，$h=1/N$。内部节点 $i=1, 2, \\dots, N-1$ 的离散方程如下：\n$$\n- D \\frac{u_{i+1} - 2 u_i + u_{i-1}}{h^2} + v \\frac{u_i - u_{i-1}}{h} + k u_i = s(x_i)\n$$\n此处，$u_i \\approx u(x_i)$。该方程对扩散项使用二阶中心差分，对平流项使用一阶迎风差分（假设 $v \\ge 0$）。\n\n为了求解未知值 $u_1, u_2, \\dots, u_{N-1}$，我们重新排列方程，按空间索引对各项进行分组：\n$$\n\\left(-\\frac{D}{h^2}\\right) u_{i-1} + \\left(\\frac{2D}{h^2} + \\frac{v}{h} + k\\right) u_i - \\left(\\frac{D}{h^2} + \\frac{v}{h}\\right) u_{i+1} = s(x_i)\n$$\n这个结构为 $N-1$ 个未知的内部节点值定义了一个包含 $N-1$ 个线性方程的方程组。我们可以将此系统写成矩阵形式 $A \\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_1, u_2, \\dots, u_{N-1}]^T$。矩阵 $A$ 是一个大小为 $(N-1) \\times (N-1)$ 的三对角矩阵。对于一般行 $i$（对应于 $u_i$ 的方程），非零项为：\n-   下对角线，$A_{i, i-1} = -\\frac{D}{h^2} - \\frac{v}{h}$\n-   主对角线，$A_{i, i} = \\frac{2D}{h^2} + \\frac{v}{h} + k$\n-   上对角线，$A_{i, i+1} = -\\frac{D}{h^2}$\n\n狄利克雷边界条件为 $u(0) = u_0$ 和 $u(1) = u_N$，其中 $u_0$ 和 $u_N$ 是已知值。这些边界值会影响系统的第一个和最后一个方程。\n\n对于第一个内部节点，$i=1$：\n$$\n\\left(\\frac{2D}{h^2} + \\frac{v}{h} + k\\right) u_1 - \\frac{D}{h^2} u_2 = s(x_1) - \\left(-\\frac{D}{h^2} - \\frac{v}{h}\\right) u_0\n$$\n对于最后一个内部节点，$i=N-1$：\n$$\n\\left(-\\frac{D}{h^2} - \\frac{v}{h}\\right) u_{N-2} + \\left(\\frac{2D}{h^2} + \\frac{v}{h} + k\\right) u_{N-1} = s(x_{N-1}) - \\left(-\\frac{D}{h^2}\\right) u_N\n$$\n因此，右侧向量 $\\mathbf{b}$ 为：\n$$\nb_i = \n\\begin{cases} \ns(x_1) + \\left(\\frac{D}{h^2} + \\frac{v}{h}\\right) u_0  \\text{如果 } i=1 \\\\\ns(x_i)  \\text{如果 } 1  i  N-1 \\\\\ns(x_{N-1}) + \\frac{D}{h^2} u_N  \\text{如果 } i=N-1\n\\end{cases}\n$$\n其中 $\\mathbf{b}$ 的索引从 $1$ 到 $N-1$。这个三对角线性系统可以被高效地求解，以得到未知数向量 $\\mathbf{u}$。\n\n### 2. 精度阶数 $(p)$ 和误差常数 $(C)$ 的估计量推导\n\n问题假设离散的关注量 (QoI) $Q(h)$，即在 $x=0.5$ 处的解，存在一个渐近误差展开式：\n$$\nQ(h) = Q^\\star + C h^p + \\mathcal{O}(h^{p+1})\n$$\n其中 $Q^\\star$ 是精确的 QoI，$p$ 是精度阶数，$C$ 是主误差常数。我们在嵌套网格上得到了三个解，其网格尺寸分别为 $h_1$，$h_2 = h_1/r$ 和 $h_3 = h_2/r = h_1/r^2$。设相应的 QoI 值为 $Q_1$、$Q_2$ 和 $Q_3$。忽略高阶项，我们有：\n$$\n\\begin{align}\nQ_1  \\approx Q^\\star + C h_1^p \\quad (1) \\\\\nQ_2  \\approx Q^\\star + C h_2^p = Q^\\star + C (h_1/r)^p = Q^\\star + C \\frac{h_1^p}{r^p} \\quad (2) \\\\\nQ_3  \\approx Q^\\star + C h_3^p = Q^\\star + C (h_1/r^2)^p = Q^\\star + C \\frac{h_1^p}{r^{2p}} \\quad (3)\n\\end{align}\n$$\n我们有三个方程和三个未知数（$Q^\\star$, $C$, $p$）。我们可以通过代数消去 $Q^\\star$ 来求得 $p$ 和 $C$。\n\n方程 $(1)$ 减去方程 $(2)$：\n$$\nQ_1 - Q_2 \\approx \\left(Q^\\star + C h_1^p\\right) - \\left(Q^\\star + C \\frac{h_1^p}{r^p}\\right) = C h_1^p \\left(1 - \\frac{1}{r^p}\\right) \\quad (4)\n$$\n方程 $(2)$ 减去方程 $(3)$：\n$$\nQ_2 - Q_3 \\approx \\left(Q^\\star + C \\frac{h_1^p}{r^p}\\right) - \\left(Q^\\star + C \\frac{h_1^p}{r^{2p}}\\right) = C \\frac{h_1^p}{r^p} \\left(1 - \\frac{1}{r^p}\\right) \\quad (5)\n$$\n现在，我们可以通过计算方程 $(4)$ 与方程 $(5)$ 的比值来消去 $C$ 和 $h_1$：\n$$\n\\frac{Q_1 - Q_2}{Q_2 - Q_3} \\approx \\frac{C h_1^p \\left(1 - \\frac{1}{r^p}\\right)}{C \\frac{h_1^p}{r^p} \\left(1 - \\frac{1}{r^p}\\right)} = r^p\n$$\n为了求解 $p$，我们对两边取自然对数：\n$$\n\\ln\\left(\\frac{Q_1 - Q_2}{Q_2 - Q_3}\\right) \\approx \\ln(r^p) = p \\ln(r)\n$$\n这就给出了精度阶数的估计量：\n$$\np \\approx \\frac{\\ln\\left(\\frac{Q_1 - Q_2}{Q_2 - Q_3}\\right)}{\\ln(r)}\n$$\n这个公式稳健地使用了来自所有三个网格的信息。\n\n为了估计 $C$，我们可以重新整理方程 $(4)$：\n$$\nQ_1 - Q_2 \\approx C (h_1^p - h_2^p)\n$$\n求解 $C$ 并使用 $p$ 的估计值：\n$$\nC \\approx \\frac{Q_1 - Q_2}{h_1^p - h_2^p}\n$$\n其中分母中的 $p$ 是上一步中估计出的值。\n\n### 3. 测试用例执行算法\n\n对每个测试用例，执行以下步骤：\n1.  定义物理参数 $D, v, k$，加密比率 $r$，以及初始网格单元数 $N_1$。\n2.  定义人造解 $u_{\\mathrm{exact}}(x)$ 及其一阶和二阶导数 $u'_{\\mathrm{exact}}(x)$ 和 $u''_{\\mathrm{exact}}(x)$。\n3.  定义源项函数 $s(x) = -D u''_{\\mathrm{exact}}(x) + v u'_{\\mathrm{exact}}(x) + k u_{\\mathrm{exact}}(x)$。\n4.  计算三个嵌套网格的网格大小：$N_1$、$N_2 = r N_1$ 和 $N_3 = r N_2$。\n5.  对于每个网格大小 $N_j$ (其中 $j=1,2,3$)：\n    a.  计算网格间距 $h_j = 1/N_j$。\n    b.  如上文推导，构建 $(N_j-1) \\times (N_j-1)$ 的三对角矩阵 $A$ 和长度为 $N_j-1$ 的右侧向量 $\\mathbf{b}$。边界值 $u_0 = u_{\\mathrm{exact}}(0)$ 和 $u_{N_j} = u_{\\mathrm{exact}}(1)$ 用于构建 $\\mathbf{b}$。\n    c.  求解线性系统 $A\\mathbf{u}=\\mathbf{b}$ 以找到内部解 $\\mathbf{u}$。\n    d.  提取 QoI，即在 $x=0.5$ 处的解。该节点的索引为 $i = 0.5 / h_j = N_j/2$。由于向量 $\\mathbf{u}$ 存储的是 $u_1, \\dots, u_{N_j-1}$，所需的值位于计算出的解向量的索引 $(N_j/2) - 1$ 处。该值存储为 $Q_j$。\n6.  使用收集到的 QoI ($Q_1, Q_2, Q_3$)、网格尺寸 ($h_1, h_2$) 和加密比率 $r$，利用推导出的公式计算估计的阶数 $p$ 和常数 $C$。\n7.  将数对 $[p, C]$ 存储为当前测试用例的结果。\n8.  遍历所有测试用例后，将最终结果格式化为指定的字符串格式。",
            "answer": "```python\nimport numpy as np\n\ndef solve_fvm(params, N):\n    \"\"\"\n    Solves the 1D advection-diffusion-reaction BVP using the specified FVM.\n\n    Args:\n        params (dict): A dictionary containing D, v, k, and functions for\n                       u_exact, u_exact_deriv1, u_exact_deriv2.\n        N (int): The number of cells in the grid.\n\n    Returns:\n        float: The discrete solution value at x = 0.5 (the QoI).\n    \"\"\"\n    D = params['D']\n    v = params['v']\n    k = params['k']\n    u_exact_func = params['u_exact_func']\n    u_exact_deriv1 = params['u_exact_deriv1']\n    u_exact_deriv2 = params['u_exact_deriv2']\n\n    h = 1.0 / N\n    x_nodes = np.linspace(0.0, 1.0, N + 1)\n    \n    # Manufactured source term\n    s_func = lambda x: -D * u_exact_deriv2(x) + v * u_exact_deriv1(x) + k * u_exact_func(x)\n    \n    dim = N - 1\n    if dim == 0:\n        return np.nan\n\n    # Setup the linear system Au = b for interior nodes u_1, ..., u_{N-1}\n    A = np.zeros((dim, dim))\n    b = np.zeros(dim)\n    \n    # Coefficients from the discrete equation\n    coeff_im1 = -D / h**2 - v / h\n    coeff_i   = 2 * D / h**2 + v / h + k\n    coeff_ip1 = -D / h**2\n    \n    # Fill the tridiagonal matrix A\n    np.fill_diagonal(A, coeff_i)\n    if dim > 1:\n        np.fill_diagonal(A[1:], coeff_im1)\n        np.fill_diagonal(A[:, 1:], coeff_ip1)\n\n    # Fill the RHS vector b, including source term and BCs\n    for i in range(1, N):\n        idx = i - 1\n        b[idx] = s_func(x_nodes[i])\n        \n    u0 = u_exact_func(0.0)\n    uN = u_exact_func(1.0)\n    \n    b[0] -= coeff_im1 * u0\n    if dim > 1:\n        b[dim - 1] -= coeff_ip1 * uN\n\n    # Solve the system\n    u_internal = np.linalg.solve(A, b)\n    \n    # Extract the Quantity of Interest (QoI), u(x=0.5)\n    # The index for x=0.5 is i = 0.5 / h = N/2.\n    # The unknowns u_internal are u_1, ..., u_{N-1}.\n    # The index in u_internal for u_i is i-1.\n    qoi_node_idx = N // 2\n    qoi_vec_idx = qoi_node_idx - 1\n    \n    qoi = u_internal[qoi_vec_idx]\n    \n    return qoi\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            'D': 0.1, 'v': 0.0, 'k': 1.0, 'r': 2, 'N1': 16,\n            'u_exact_func': lambda x: np.sin(np.pi * x),\n            'u_exact_deriv1': lambda x: np.pi * np.cos(np.pi * x),\n            'u_exact_deriv2': lambda x: -np.pi**2 * np.sin(np.pi * x),\n        },\n        # Test Case 2\n        {\n            'D': 0.005, 'v': 3.0, 'k': 0.5, 'r': 2, 'N1': 32,\n            'u_exact_func': lambda x: np.sin(2 * np.pi * x),\n            'u_exact_deriv1': lambda x: 2 * np.pi * np.cos(2 * np.pi * x),\n            'u_exact_deriv2': lambda x: -4 * np.pi**2 * np.sin(2 * np.pi * x),\n        },\n        # Test Case 3\n        {\n            'D': 0.01, 'v': 0.0, 'k': 2.0, 'r': 3, 'N1': 12,\n            'u_exact_func': lambda x: np.exp(x),\n            'u_exact_deriv1': lambda x: np.exp(x),\n            'u_exact_deriv2': lambda x: np.exp(x),\n        },\n        # Test Case 4\n        {\n            'D': 0.02, 'v': 1.0, 'k': 10.0, 'r': 2, 'N1': 18,\n            'u_exact_func': lambda x: np.cosh(2 * (x - 0.5)),\n            'u_exact_deriv1': lambda x: 2 * np.sinh(2 * (x - 0.5)),\n            'u_exact_deriv2': lambda x: 4 * np.cosh(2 * (x - 0.5)),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N1 = case['N1']\n        r = case['r']\n        N2 = r * N1\n        N3 = r * N2\n\n        # Solve on the three nested grids\n        Q1 = solve_fvm(case, N1)\n        Q2 = solve_fvm(case, N2)\n        Q3 = solve_fvm(case, N3)\n\n        # Estimate order of accuracy p\n        # p = ln((Q1-Q2)/(Q2-Q3)) / ln(r)\n        ratio_of_diffs = (Q1 - Q2) / (Q2 - Q3)\n        # Handle cases where differences might be zero or negative, returning NaN\n        if ratio_of_diffs = 0:\n            p_est = np.nan\n        else:\n            p_est = np.log(ratio_of_diffs) / np.log(r)\n        \n        # Estimate leading error constant C\n        # C = (Q1 - Q2) / (h1^p - h2^p)\n        h1 = 1.0 / N1\n        h2 = 1.0 / N2\n        \n        if np.isnan(p_est) or (Q1 - Q2) == 0:\n            C_est = np.nan\n        else:\n            C_est = (Q1 - Q2) / (h1**p_est - h2**p_est)\n\n        results.append([p_est, C_est])\n\n    # Format the final output string\n    output_str = f\"[{','.join(f'[{p},{c}]' for p, c in results)}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}