{"hands_on_practices": [{"introduction": "精确的衍射峰位是任何成功的Rietveld精修的基石。然而，实验数据常常受到系统误差的影响，例如仪器零点偏移和样品高度位移。本练习 [@problem_id:2517921] 将指导你如何利用标准样品从第一性原理出发，校准这些常见的仪器误差，这是在进行任何复杂的结构或物相分析之前至关重要的数据预处理步骤。", "problem": "一台布拉格-布伦塔诺（Bragg–Brentano）准聚焦X射线衍射（XRD）仪存在两种主要的系统误差，会导致峰位移动：一种是加性零点漂移，另一种是样品沿衍射仪轴的位移。考虑使用具有已知预期峰位的晶体标样进行校准，然后在进行Rietveld精修之前，将估计出的仪器校正参数应用于一个独立的样品图谱。您的任务是：仅利用已知的仪器半径和校准物峰位，从第一性原理出发，推导出一个测量位置与预期位置之间的可线性化关系，该关系能同时估计零点漂移和样品位移；然后，通过求解相应的隐式方程得到校正后的角度，使用这些估计值来校正样品的实测图谱。所有角度都必须以“度”为单位进行处理和报告，样品位移必须以“毫米”为单位进行处理和报告。\n\n您可以假定以下出发点：\n- 衍射的布拉格定律关联了晶面间距、波长和布拉格角。在布拉格-布伦塔诺几何构型中，衍射峰出现在一个等于两倍布拉格角的散射角处。\n- 在这种准聚焦几何构型中，一个微小的样品高度误差会通过一个确定性的光程差效应来改变衍射条件，该效应取决于布拉格角和衍射仪半径。\n- 零点漂移是施加于测量角度 $2\\theta$ 的一个加性角度偏移，且与角度无关。\n\n请勿使用任何未从这些原理推导出的“捷径”公式；相反，您应基于这些基础来构建适当的关系和估计程序。\n\n对于下方的每个测试用例，您将获得：\n- 衍射仪半径 $R$ (单位：毫米)。\n- 预期校准物峰位 (真实值)，单位为 $2\\theta$ (度)。\n- 实测校准物峰位，单位为 $2\\theta$ (度)。\n- 一组必须使用您估计的仪器参数进行校正的样品峰位 (观测值)，单位为 $2\\theta$ (度)。\n\n您的程序必须为每个测试用例执行以下操作：\n1) 根据校准峰和 $R$，使用一个基于布拉格-布伦塔诺几何构型和小位移近似推导出的、有物理依据的可线性化模型，估计零点漂移 $z$ (度) 和样品位移 $\\Delta h$ (毫米)。不要假定任一参数是先验已知的。\n2) 应用估计出的 $z$ 和 $\\Delta h$ 来校正每个提供的样品 $2\\theta$。为此，需要使用数值稳定的不动点迭代或求根迭代方法，求解相应的隐式校正方程以获得校正后的 $2\\theta$。在校正后的 $2\\theta$ 上使用 $\\varepsilon = 10^{-10}$ 度的收敛容差，并且每个峰最多迭代 $100$ 次。如果迭代在限制次数内未收敛，则返回最后一次迭代的结果。\n3) 将所有输出报告为四舍五入到六位小数的实数。\n\n测试套件（三个用例）：\n- 用例 $1$：\n  - $R = 200.0$ 毫米\n  - 预期校准物 $2\\theta$ (度)：$[28.44200, 47.30500, 56.11900]$\n  - 实测校准物 $2\\theta$ (度)：$[28.40870, 47.27610, 56.09320]$\n  - 样品观测 $2\\theta$ (度)：$[30.00000, 45.00000, 60.00000, 75.00000]$\n- 用例 $2$：\n  - $R = 217.5$ 毫米\n  - 预期校准物 $2\\theta$ (度)：$[28.44200, 47.30500, 56.11900]$\n  - 实测校准物 $2\\theta$ (度)：$[28.32200, 47.18500, 55.99900]$\n  - 样品观测 $2\\theta$ (度)：$[25.00000, 40.00000, 55.00000, 70.00000]$\n- 用例 $3$：\n  - $R = 160.0$ 毫米\n  - 预期校准物 $2\\theta$ (度)：$[28.44200, 47.30500, 56.11900]$\n  - 实测校准物 $2\\theta$ (度)：$[28.58100, 47.43630, 56.24560]$\n  - 样品观测 $2\\theta$ (度)：$[35.00000, 50.00000, 65.00000, 80.00000]$\n\n角度单位：度。长度单位：毫米。不得使用其他单位。将 $z$ 表示为以度为单位的实数，将 $\\Delta h$ 表示为以毫米为单位的实数。每个校正后的样品峰位必须表示为以度为单位的实数。\n\n最终输出格式：\n- 生成一个包含在方括号内的单行逗号分隔列表。\n- 该列表必须为每个测试用例按顺序连接以下内容：估计的零点漂移 $z$ (度)，估计的样品位移 $\\Delta h$ (毫米)，然后是按照给定顺序排列的校正后样品 $2\\theta$ 值 (度)。\n- 所有数字必须四舍五入到六位小数。\n- 具体来说，对于三个用例，每个用例有四个样品峰，输出必须包含 $3 \\times (2 + 4) = 18$ 个数字，例如 $[z_1, \\Delta h_1, c_{1,1}, c_{1,2}, c_{1,3}, c_{1,4}, z_2, \\Delta h_2, c_{2,1}, c_{2,2}, c_{2,3}, c_{2,4}, z_3, \\Delta h_3, c_{3,1}, c_{3,2}, c_{3,3}, c_{3,4}]$，其中每个 $c_{i,j}$ 是一个校正后的样品 $2\\theta$ 值 (度)。", "solution": "该问题被验证为具有科学依据、适定的，并且是应用物理学和数据分析领域的一项客观任务。它要求推导并应用一个模型来处理布拉格-布伦塔诺X射线衍射中的系统误差。解决方案分两个阶段进行：首先，根据校准数据推导模型并估计仪器参数；其次，应用这些参数来校正样品的测量数据。\n\n实测散射角 $2\\theta_m$ 与真实晶体学散射角 $2\\theta_c$ 之间的关系受到多种系统误差的影响。本问题指定了两种主要误差：仪器零点漂移 $z$ 和样品位移误差 $\\Delta h$。测量角度是真实角度与这些误差贡献之和。\n\n零点漂移 $z$ 是一个加到所有测量值上的恒定角度偏移，与角度本身无关。因此，它对测量角度的贡献就是 $+z$。\n\n当样品表面与测角仪的聚焦圆轴不完全重合时，就会产生样品位移误差。样品沿其表面法线（垂直于样品平面）方向的位移 $\\Delta h$ 会在测量的峰位中引入一个与角度相关的漂移。对布拉格-布伦塔诺准聚焦几何构型的几何分析表明，对于相对于测角仪半径 $R$ 的一个微小位移 $\\Delta h$，其在 $2\\theta$ 上引起的角度漂移（记为 $\\Delta(2\\theta)_{disp}$），以弧度表示为：\n$$\n\\Delta(2\\theta)_{disp} \\approx -2\\frac{\\Delta h}{R}\\cos(\\theta_c)\n$$\n其中 $\\theta_c = (2\\theta_c) / 2$ 是真实布拉格角。负号表示正位移（样品过高，朝向X射线源/探测器）会使衍射峰向更低的 $2\\theta$ 值移动。为了按要求使用度为单位，我们将此表达式进行转换：\n$$\n\\Delta(2\\theta)_{disp, deg} = \\left(-2\\frac{\\Delta h}{R}\\cos(\\theta_c)\\right) \\times \\frac{180}{\\pi} = -\\frac{360}{\\pi}\\frac{\\Delta h}{R}\\cos(\\theta_c)\n$$\n结合这两个误差项，测量角度和真实角度之间的关系为：\n$$\n2\\theta_m \\approx 2\\theta_c + z + \\Delta(2\\theta)_{disp, deg} = 2\\theta_c + z - \\frac{360}{\\pi}\\frac{\\Delta h}{R}\\cos(\\theta_c)\n$$\n为了估计未知参数 $z$ 和 $\\Delta h$，我们将此方程重排为适合回归的线性形式。利用所提供的校准物数据，对于一组峰 $i=1, \\dots, N$，其 $2\\theta_m$ 和 $2\\theta_c$ 均为已知：\n$$\n2\\theta_{m,i} - 2\\theta_{c,i} = z - \\left(\\frac{360}{\\pi R}\\Delta h\\right) \\cos(\\theta_{c,i})\n$$\n该方程具有 $Y_i = C + M X_i$ 的形式，定义了一条直线。我们可以识别出其中的变量和系数：\n- 因变量是 $Y_i = 2\\theta_{m,i} - 2\\theta_{c,i}$。\n- 自变量是 $X_i = \\cos(\\theta_{c,i}) = \\cos(2\\theta_{c,i}/2)$。\n- 截距是 $C = z$。\n- 斜率是 $M = -\\frac{360}{\\pi R}\\Delta h$。\n\n给定一组校准峰，可以通过对 $Y$ 与 $X$ 进行线性最小二乘拟合来确定 $z$ 和 $M$ 的值。仪器零点漂移 $z$ 直接由拟合的截距给出。样品位移 $\\Delta h$ 可以从斜率 $M$ 计算得出：\n$$\n\\Delta h = -M \\frac{\\pi R}{360}\n$$\n一旦参数 $z$ 和 $\\Delta h$（通过 $M$）被估计出来，它们就可以用来校正一个新样品的实测峰位 $2\\theta_{obs}$。对于这样的样品，其真实的、校正后的位置 $2\\theta_{corr}$ 是未知的。它通过求解以下隐式方程得到：\n$$\n2\\theta_{obs} = 2\\theta_{corr} + z - \\frac{360}{\\pi}\\frac{\\Delta h}{R}\\cos(\\theta_{corr})\n$$\n代入 $M = -\\frac{360}{\\pi R}\\Delta h$，我们得到：\n$$\n2\\theta_{obs} = 2\\theta_{corr} + z + M \\cos(\\theta_{corr})\n$$\n重排以求解 $2\\theta_{corr}$ 可得：\n$$\n2\\theta_{corr} = 2\\theta_{obs} - z - M \\cos(\\frac{2\\theta_{corr}}{2})\n$$\n该方程的形式为 $x = g(x)$，其中 $x = 2\\theta_{corr}$ 且 $g(x) = (2\\theta_{obs} - z) - M \\cos(x/2)$。它可以使用不动点迭代进行数值求解。我们定义一个迭代序列：\n$$\nx_{k+1} = (2\\theta_{obs} - z) - M \\cos\\left(\\frac{\\pi}{180} \\frac{x_k}{2}\\right)\n$$\n一个合适的初始猜测值是 $x_0 = 2\\theta_{obs} - z$，这忽略了微小的位移校正。重复进行迭代，直到连续值之间的变化 $|x_{k+1} - x_k|$ 小于指定的容差 $\\varepsilon = 10^{-10}$。收敛速度很快，因为导数 $|g'(x)| = |(M \\pi / 360) \\sin(x/2)| = |(\\Delta h/R)\\sin(x/2)|$ 通常远小于1。如果在100次迭代内未达到收敛，则使用最后计算出的值。所有角度都必须以度为单位处理，但在计算三角函数时需转换为弧度。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for instrument correction parameters and applies them to sample data\n    for a series of test cases in X-ray diffraction analysis.\n    \"\"\"\n    # Test cases as provided in the problem description.\n    test_cases = [\n        {\n            \"R\": 200.0,\n            \"cal_true\": np.array([28.44200, 47.30500, 56.11900]),\n            \"cal_meas\": np.array([28.40870, 47.27610, 56.09320]),\n            \"sam_obs\": np.array([30.00000, 45.00000, 60.00000, 75.00000]),\n        },\n        {\n            \"R\": 217.5,\n            \"cal_true\": np.array([28.44200, 47.30500, 56.11900]),\n            \"cal_meas\": np.array([28.32200, 47.18500, 55.99900]),\n            \"sam_obs\": np.array([25.00000, 40.00000, 55.00000, 70.00000]),\n        },\n        {\n            \"R\": 160.0,\n            \"cal_true\": np.array([28.44200, 47.30500, 56.11900]),\n            \"cal_meas\": np.array([28.58100, 47.43630, 56.24560]),\n            \"sam_obs\": np.array([35.00000, 50.00000, 65.00000, 80.00000]),\n        }\n    ]\n\n    all_results = []\n    \n    # Define constants for the iterative correction\n    TOLERANCE = 1e-10\n    MAX_ITERATIONS = 100\n\n    for case in test_cases:\n        R = case[\"R\"]\n        cal_true_2theta = case[\"cal_true\"]\n        cal_meas_2theta = case[\"cal_meas\"]\n        sam_obs_2theta = case[\"sam_obs\"]\n\n        # Step 1: Estimate z and delta_h using linear regression.\n        # The model is: 2theta_meas = 2theta_true + z - (360/pi * delta_h/R) * cos(theta_true)\n        # We linearize this as: y = C + M*x\n        # where y = 2theta_meas - 2theta_true, x = cos(theta_true), C = z, M = -(360/pi * delta_h/R)\n        \n        y_cal = cal_meas_2theta - cal_true_2theta\n        theta_true_deg = cal_true_2theta / 2.0\n        x_cal = np.cos(np.deg2rad(theta_true_deg))\n\n        # Perform linear least-squares regression to find slope (M) and intercept (C).\n        # np.polyfit(x, y, 1) returns [slope, intercept].\n        slope, intercept = np.polyfit(x_cal, y_cal, 1)\n\n        # Estimate parameters z and delta_h from regression results.\n        z_est = intercept  # in degrees\n        # From M = -(360/pi * delta_h/R), we get delta_h = -M * (pi*R/360)\n        delta_h_est = -slope * (np.pi * R / 360.0)  # in mm\n\n        all_results.append(z_est)\n        all_results.append(delta_h_est)\n\n        # Step 2: Correct sample peak positions by solving the implicit equation.\n        # 2theta_corr = 2theta_obs - z + (360/pi * delta_h/R) * cos(theta_corr)\n        # Using the slope M: 2theta_corr = 2theta_obs - z - M * cos(theta_corr)\n        \n        corrected_peaks = []\n        for obs_peak in sam_obs_2theta:\n            # Fixed-point iteration: x_{k+1} = g(x_k)\n            # where x = 2theta_corr\n\n            # Initial guess for the corrected angle\n            x_corr = obs_peak - z_est\n            \n            constant_term = obs_peak - z_est\n            cosine_coeff = -slope\n            \n            for _ in range(MAX_ITERATIONS):\n                x_prev = x_corr\n                # The argument to cosine must be in radians. x_prev is 2*theta in degrees.\n                theta_corr_rad = np.deg2rad(x_prev / 2.0)\n                x_corr = constant_term + cosine_coeff * np.cos(theta_corr_rad)\n                \n                if np.abs(x_corr - x_prev)  TOLERANCE:\n                    break\n            \n            corrected_peaks.append(x_corr)\n        \n        all_results.extend(corrected_peaks)\n\n    # Format all numbers to six decimal places for the final output string.\n    formatted_results = [f\"{num:.6f}\" for num in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2517921"}, {"introduction": "衍射峰的形状，特别是其宽度，蕴含着关于材料微观结构的宝贵信息。本练习 [@problem_id:2517814] 将带你实践经典的Williamson-Hall分析方法，这是一种从衍射峰增宽中分离出微晶尺寸和微观应变贡献的强大技术。通过这个实践，你将学会如何从峰形中提取定量的微观结构参数，这是Rietveld分析在材料科学中的一个核心应用。", "problem": "给定一份立方纳米晶材料的粉末X射线衍射峰的线形展宽数据，该数据是使用实验室衍射仪通过铜K-alpha辐射测量的。目标是通过类似Rietveld的方法，将峰宽分解为有限微晶尺寸和微观应变的贡献，从而提取体加权微晶尺寸 $D$ 和均方根微观应变 $\\epsilon$，并从一个统计上稳健的最小二乘模型中量化参数相关性。\n\n您必须使用的基本出发点：\n- 布拉格定律（Bragg’s Law）：$2 d \\sin \\theta = \\lambda$，其中 $\\theta$ 是布拉格角，$\\lambda$ 是波长。\n- 对于运动学近似下的多晶粉末，衍射峰的积分宽度（面积除以高度），在经过仪器反卷积后，可以建模为沿衍射矢量的尺寸和应变展宽贡献之和。\n- 对于体加权微晶尺寸，谢乐（Scherrer）型关系式的积分宽度与 $1/\\cos \\theta$ 成正比。\n- 对于均方根微观应变（假定为各向同性），应变展宽的积分宽度与 $\\tan \\theta$ 成正比。\n\n使用以下数据和常数：\n- 使用铜K-alpha波长 $\\lambda$，单位为纳米：$\\lambda = 0.15406$。\n- 使用适用于体加权尺寸的形状因子 $K = 0.9$。\n- 下面提供的峰宽是经过仪器校正的积分宽度，记为 $\\beta^\\star$，以 $2\\theta$ 的弧度表示。角度以 $2\\theta$ 的度数给出。在计算三角函数时，您必须使用以弧度为单位的 $\\theta$，其中 $\\theta = (2\\theta)/2$，由度数转换而来。\n- 您必须以纳米报告 $D$，以无量纲小数报告 $\\epsilon$（而不是百分比）。\n\n测试套件：\n对于每种情况，都提供了一组 $2\\theta$ 值（以度为单位）和相应的经过仪器校正的积分宽度 $\\beta^\\star$（以 $2\\theta$ 的弧度为单位）。\n\n- 情况A（宽角度覆盖范围，中等尺寸和应变）：\n  - $2\\theta$: $[40, 50, 70, 90, 110, 120]$\n  - $\\beta^\\star$: $[0.005028, 0.005638, 0.007124, 0.009159, 0.012226, 0.014476]$\n\n- 情况B（有限角度覆盖范围，预计参数相关性更强）：\n  - $2\\theta$: $[40, 50, 60]$\n  - $\\beta^\\star$: $[0.003919, 0.004416, 0.004979]$\n\n- 情况C（主要为尺寸展宽）：\n  - $2\\theta$: $[40, 50, 70, 90, 110, 120]$\n  - $\\beta^\\star$: $[0.005904, 0.006122, 0.006773, 0.007845, 0.009662, 0.011092]$\n\n- 情况D（主要为应变展宽）：\n  - $2\\theta$: $[40, 50, 70, 90, 110, 120]$\n  - $\\beta^\\star$: $[0.003788, 0.004814, 0.007172, 0.010197, 0.014526, 0.017598]$\n\n要求：\n1. 从基本关系式出发，构建一个可线性化的模型，该模型将积分宽度分解为尺寸和应变分量作为 $\\theta$ 的函数，适用于对映射到 $D$ 和 $\\epsilon$ 的两个参数进行最小二乘估计。\n2. 对线性化模型使用普通最小二乘法，从每种情况的数据中估计两个回归参数。由此计算出 $D$（以纳米为单位）和 $\\epsilon$（无量纲）。\n3. 根据最小二乘设计矩阵和残差平方和估计参数协方差矩阵。传播此协方差以获得 $D$ 和 $\\epsilon$ 之间的协方差，并报告 $D$ 和 $\\epsilon$ 之间的相关系数 $r$，定义为 $r = \\mathrm{cov}(D,\\epsilon)/\\sqrt{\\mathrm{var}(D)\\mathrm{var}(\\epsilon)}$。如果分母在数值上为零，则将 $r$ 设为 $0$。\n4. 在进行任何三角函数求值时，角度必须转换为弧度。最终的 $D$ 必须以纳米表示，$\\epsilon$ 以小数表示。不要使用百分号。\n5. 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个案例的结果是一个三元列表 $[D,\\epsilon,r]$，每个值格式化为六位小数。例如：$[[D_A,\\epsilon_A,r_A],[D_B,\\epsilon_B,r_B],[D_C,\\epsilon_C,r_C],[D_D,\\epsilon_D,r_D]]$。\n\n您的任务：\n- 实现一个程序，将上述建模和估计方法应用于提供的测试套件，并按规定格式打印单行聚合结果。", "solution": "所提出的问题是X射线线形分析的一个有效且适定的应用。它要求使用标准的Williamson-Hall方法从粉末衍射数据中确定微晶尺寸和微观应变。所有提供的数据、常数和基本原理在科学上都是合理的且内部一致的。\n\n目标是通过对衍射峰的仪器校正积分宽度 $\\beta^\\star$ 进行建模，来确定体加权微晶尺寸 $D$ 和均方根微观应变 $\\epsilon$。总宽度假定为尺寸展宽贡献 $\\beta_D$ 和应变展宽贡献 $\\beta_\\epsilon$ 的线性加和：\n$$ \\beta^\\star = \\beta_D + \\beta_\\epsilon $$\n\n尺寸贡献由谢乐（Scherrer）方程描述，其中积分宽度与微晶尺寸和布拉格角 $\\theta$ 的余弦成反比：\n$$ \\beta_D = \\frac{K \\lambda}{D \\cos\\theta} $$\n此处，$K$ 是无量纲的谢乐形状因子（给定为 $K=0.9$），$\\lambda$ 是X射线波长（给定为 $\\lambda=0.15406$ nm），$D$ 是以纳米为单位的体加权微晶尺寸。宽度 $\\beta_D$ 以 $2\\theta$ 的弧度表示。\n\n应变贡献基于Wilson的各向同性应变理论进行建模，其中宽度与布拉格角的正切成正比：\n$$ \\beta_\\epsilon = 4 \\epsilon \\tan\\theta $$\n此处，$\\epsilon$ 是无量纲的均方根微观应变，$\\beta_\\epsilon$ 也以 $2\\theta$ 的弧度表示。\n\n将这两个贡献结合起来，得到总宽度模型：\n$$ \\beta^\\star = \\frac{K \\lambda}{D \\cos\\theta} + 4 \\epsilon \\tan\\theta $$\n\n为了使用线性最小二乘法估计参数 $D$ 和 $\\epsilon$，通过乘以 $\\cos\\theta$ 将此方程重排为Williamson-Hall形式：\n$$ \\beta^\\star \\cos\\theta = \\frac{K \\lambda}{D} + 4 \\epsilon \\sin\\theta $$\n\n该方程对于每个衍射峰 $i$ 都具有线性形式 $y_i = c + m x_i$，其中：\n- 因变量为 $y_i = \\beta^\\star_i \\cos\\theta_i$。\n- 自变量为 $x_i = \\sin\\theta_i$。\n- 截距为 $c = \\frac{K \\lambda}{D}$。\n- 斜率为 $m = 4 \\epsilon$。\n\n分析过程首先将给定的衍射角 $2\\theta$ 从度数转换为弧度，并计算 $\\theta_i = (2\\theta_i)/2$。然后，对于每个数据点 $(\\beta^\\star_i, \\theta_i)$，计算相应的配对 $(x_i, y_i)$。通过执行普通最小二乘（OLS）回归来找到斜率 $\\hat{m}$ 和截距 $\\hat{c}$ 的最优值。在矩阵表示法中，对于系统 $\\mathbf{y} = \\mathbf{Xp}$，其中 $\\mathbf{p} = [c, m]^T$ 是参数矢量，$\\mathbf{X}$ 是设计矩阵，OLS估计由 $\\hat{\\mathbf{p}} = (\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{y}$ 给出。\n\n从估计的参数 $\\hat{c}$ 和 $\\hat{m}$ 中，导出物理量：\n$$ D = \\frac{K \\lambda}{\\hat{c}} \\quad \\text{和} \\quad \\epsilon = \\frac{\\hat{m}}{4} $$\n\n为了量化所确定的参数 $D$ 和 $\\epsilon$ 之间的统计相关性，我们首先计算回归参数的协方差矩阵 $\\mathrm{cov}(\\hat{\\mathbf{p}})$。这由以下公式给出：\n$$ \\mathrm{cov}(\\hat{\\mathbf{p}}) = \\hat{\\sigma}^2 (\\mathbf{X}^T\\mathbf{X})^{-1} $$\n其中 $\\hat{\\sigma}^2$ 是回归方差的无偏估计，由残差平方和（RSS）计算得出：\n$$ \\hat{\\sigma}^2 = \\frac{1}{N-k} \\mathrm{RSS} = \\frac{1}{N-2} \\sum_{i=1}^{N} (y_i - (\\hat{c} + \\hat{m}x_i))^2 $$\n此处，$N$ 是数据点的数量，$k=2$ 是线性模型中参数的数量。\n\n$D$ 和 $\\epsilon$ 之间的协方差是通过将 $\\hat{\\mathbf{p}} = [\\hat{c}, \\hat{m}]^T$ 的协方差经由变换函数传播得到的。从 $(c, m)$ 到 $(D, \\epsilon)$ 变换的雅可比矩阵 $\\mathbf{J}$ 是：\n$$ \\mathbf{J} = \\begin{pmatrix} \\frac{\\partial D}{\\partial c}  \\frac{\\partial D}{\\partial m} \\\\ \\frac{\\partial \\epsilon}{\\partial c}  \\frac{\\partial \\epsilon}{\\partial m} \\end{pmatrix} = \\begin{pmatrix} -\\frac{K\\lambda}{c^2}  0 \\\\ 0  \\frac{1}{4} \\end{pmatrix} $$\n$(D, \\epsilon)$ 的协方差矩阵则近似为 $\\mathrm{cov}(D, \\epsilon) \\approx \\mathbf{J} \\, \\mathrm{cov}(\\hat{\\mathbf{p}}) \\, \\mathbf{J}^T$。\n\n最后，计算相关系数 $r(D, \\epsilon)$：\n$$ r(D, \\epsilon) = \\frac{\\mathrm{cov}(D, \\epsilon)}{\\sqrt{\\mathrm{var}(D)\\mathrm{var}(\\epsilon)}} $$\n此计算揭示了导出的物理参数之间的相关性与回归参数之间的相关性呈负相关，即 $r(D, \\epsilon) = -r(\\hat{c}, \\hat{m})$。对于在正值 $x_i$ 范围内的此类线性拟合，拟合的斜率和截距之间的强负相关性，通常会导致 $D$ 和 $\\epsilon$ 之间存在强正相关性。\n\n以下程序为提供的测试用例实现了这整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for crystallite size (D), microstrain (epsilon), and their\n    correlation (r) from XRD peak broadening data using Williamson-Hall analysis.\n    \"\"\"\n\n    # Define constants from the problem statement.\n    K = 0.9  # Scherrer shape factor\n    LAMBDA = 0.15406  # Wavelength in nanometers\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Broad angular coverage\n        (np.array([40.0, 50.0, 70.0, 90.0, 110.0, 120.0]),\n         np.array([0.005028, 0.005638, 0.007124, 0.009159, 0.012226, 0.014476])),\n        # Case B: Limited angular coverage\n        (np.array([40.0, 50.0, 60.0]),\n         np.array([0.003919, 0.004416, 0.004979])),\n        # Case C: Dominantly size broadening\n        (np.array([40.0, 50.0, 70.0, 90.0, 110.0, 120.0]),\n         np.array([0.005904, 0.006122, 0.006773, 0.007845, 0.009662, 0.011092])),\n        # Case D: Dominantly strain broadening\n        (np.array([40.0, 50.0, 70.0, 90.0, 110.0, 120.0]),\n         np.array([0.003788, 0.004814, 0.007172, 0.010197, 0.014526, 0.017598])),\n    ]\n\n    results = []\n    for case in test_cases:\n        two_theta_deg, beta_star = case\n        N = len(two_theta_deg)\n\n        # Convert 2*theta in degrees to theta in radians\n        theta_rad = np.deg2rad(two_theta_deg / 2)\n\n        # Construct variables for the Williamson-Hall plot: y = c + m*x\n        # x = sin(theta)\n        # y = beta_star * cos(theta)\n        x_wh = np.sin(theta_rad)\n        y_wh = beta_star * np.cos(theta_rad)\n\n        # Perform Ordinary Least Squares (OLS) regression\n        # Design matrix X for model y = p[0] + p[1]*x\n        X = np.vstack([np.ones(N), x_wh]).T\n        \n        # Calculate parameters p_hat = [c_hat, m_hat] using (X.T * X)^-1 * X.T * y\n        # Use np.linalg.solve for better numerical stability than direct inversion\n        try:\n            XTX = X.T @ X\n            XTy = X.T @ y_wh\n            p_hat = np.linalg.solve(XTX, XTy)\n        except np.linalg.LinAlgError:\n            # Handle singular matrix case, though unlikely with this data\n            results.append([0.0, 0.0, 0.0])\n            continue\n            \n        c_hat, m_hat = p_hat\n\n        # Calculate crystallite size (D) and microstrain (epsilon)\n        # c_hat = K * lambda / D  => D = K * lambda / c_hat\n        # m_hat = 4 * epsilon    => epsilon = m_hat / 4\n        D = 0.0\n        if c_hat > 0:\n            D = (K * LAMBDA) / c_hat\n        \n        epsilon = m_hat / 4.0\n\n        # Calculate the correlation coefficient between D and epsilon\n        r_De = 0.0\n        # Number of parameters in the model k=2\n        if N > 2:\n            # Calculate residual sum of squares (RSS)\n            residuals = y_wh - (c_hat + m_hat * x_wh)\n            RSS = np.sum(residuals**2)\n            \n            # Estimate of the regression variance sigma^2\n            sigma2_hat = RSS / (N - 2)\n\n            # Covariance matrix of the parameters [c, m]\n            try:\n                XTX_inv = np.linalg.inv(XTX)\n                cov_p = sigma2_hat * XTX_inv\n                \n                var_c = cov_p[0, 0]\n                var_m = cov_p[1, 1]\n                cov_cm = cov_p[0, 1]\n\n                # Denominator for correlation coefficient of (c, m)\n                denom_r_cm = np.sqrt(var_c * var_m)\n                \n                if denom_r_cm > 1e-15: # Avoid division by zero\n                    r_cm = cov_cm / denom_r_cm\n                    # Correlation of (D, epsilon) is -1 * correlation of (c, m)\n                    r_De = -r_cm\n                else:\n                    # Occurs if fit is perfect (RSS=0), so no statistical variance\n                    r_De = 0.0\n\n            except np.linalg.LinAlgError:\n                r_De = 0.0\n        else:\n            # Cannot estimate variance with N = k, correlation is undefined\n            r_De = 0.0\n\n        results.append([D, epsilon, r_De])\n\n    # Format output string\n    output_str = \"[\"\n    output_str += \",\".join(\n        f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\" for res in results\n    )\n    output_str += \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "2517814"}, {"introduction": "Rietveld精修的真正威力在于它能够根据衍射数据来检验和优化复杂的晶体结构模型。本练习 [@problem_id:2517932] 模拟了材料科学中的一个常见挑战：确定混合阳离子占位点的原子占有率。你将学习如何应用电荷中性和占位点全占据等基本物理约束，来解决一个在其他情况下可能无法唯一确定解的结构问题，从而揭示材料的精确化学计量和原子排布。", "problem": "给定一个氧化物中混合阳离子位的约束占有率精修的简化但有科学依据的模型，该模型适用于构建约束最小二乘问题，正如在用于定量相分析的 Rietveld 精修中所使用的那样。考虑一个通过中子粉末衍射 (NPD) 测量的、名义成分为 $\\mathrm{AFeO}_{3-\\delta}$ 的理想化类钙钛矿氧化物。$\\mathrm{A}$ 位表现出锶和镧之间的阳离子混合，而氧位可能是亚化学计量的以保持电荷中性。铁位被完全占据并固定为 $\\mathrm{Fe}^{3+}$。为简化本问题，假设位移参数是各向同性的且晶格固定；仅关注占有率和约束条件。\n\n基本依据和假设：\n- 对于一组选定的反射，来自某个晶体学位置的总散射振幅贡献被线性地建模为其平均相干散射长度与一个已知的、依赖于反射的标度因子的乘积。对于平均相干散射长度为 $b_{\\mathrm{avg}}$ 的位点，给定反射的振幅代理为 $S \\, b_{\\mathrm{avg}}$，其中 $S$ 是该反射的已知标度常数。当所选反射满足来自其他位点的相位干涉可以忽略不计时，这是一种在占有率精修中使用的标准线性化方法。\n- 相干中子散射长度为常数：$b_{\\mathrm{Sr}} = 7.02 \\,\\mathrm{fm}$，$b_{\\mathrm{La}} = 8.24 \\,\\mathrm{fm}$ 和 $b_{\\mathrm{O}} = 5.803 \\,\\mathrm{fm}$。\n- 未知占有率收集在向量 $\\mathbf{x} = \\big[x_{\\mathrm{Sr}},\\, x_{\\mathrm{La}},\\, x_{\\mathrm{O}}\\big]^{\\mathsf{T}}$ 中，其中 $x_{\\mathrm{Sr}}$ 和 $x_{\\mathrm{La}}$ 是锶和镧在 $\\mathrm{A}$ 位（单一位置）上的分数占有率，$x_{\\mathrm{O}}$ 是氧的位点占有率因子，假设三个等效氧位具有相同的占有率因子，因此每个化学式单位的总氧量为 $3\\,x_{\\mathrm{O}}$。\n- 通过约束条件 $x_{\\mathrm{Sr}} + x_{\\mathrm{La}} = 1$ 强制 $\\mathrm{A}$ 位完全占据。\n- 使用固定的 $\\mathrm{Fe}^{3+}$ 和可变的氧占有率，在整个化学式单位上强制电荷中性。中性条件为 $2\\,x_{\\mathrm{Sr}} + 3\\,x_{\\mathrm{La}} + 3 - 2 \\cdot 3 \\, x_{\\mathrm{O}} = 0$，可写为 $2\\,x_{\\mathrm{Sr}} + 3\\,x_{\\mathrm{La}} - 6\\,x_{\\mathrm{O}} = -3$。\n- 设 $\\mathcal{A}$ 表示混合的 $\\mathrm{A}$ 位，$\\mathcal{O}$ 表示氧位。对于一组选定的、由 $\\mathcal{A}$ 位主导的反射，振幅代理为 $y_{\\mathcal{A},k} = S_{\\mathcal{A},k}\\,\\big(b_{\\mathrm{Sr}}\\,x_{\\mathrm{Sr}} + b_{\\mathrm{La}}\\,x_{\\mathrm{La}}\\big)$，其中 $k$ 属于一个指定集合。对于一组由 $\\mathcal{O}$ 位主导的反射，振幅代理为 $y_{\\mathcal{O},\\ell} = S_{\\mathcal{O},\\ell}\\,\\big(b_{\\mathrm{O}}\\,x_{\\mathrm{O}}\\big)$，其中 $\\ell$ 属于一个指定集合。\n\n您的任务是：\n- 构建约束线性最小二乘问题，在满足完全占据和电荷中性的线性约束条件下，最小化观测振幅代理与计算值之间的残差平方和。\n- 实现一个算法，通过求解等式约束最小二乘的 Karush-Kuhn-Tucker (KKT) 线性系统来解决该约束最小二乘问题。\n- 将您的求解器应用于提供的测试套件，并返回精修后的占有率。\n\n数学公式：\n- 将 $\\mathcal{A}$ 位振幅代理和 $\\mathcal{O}$ 位振幅代理的方程叠加成一个单一的线性系统 $\\mathbf{M}\\,\\mathbf{x} \\approx \\mathbf{y}$，其中对于 $\\mathcal{A}$ 位主导的反射，$\\mathbf{M}$ 的行形式为 $S_{\\mathcal{A},k}\\,[\\,b_{\\mathrm{Sr}},\\, b_{\\mathrm{La}},\\, 0\\,]$，对于 $\\mathcal{O}$ 位主导的反射，$\\mathbf{M}$ 的行形式为 $S_{\\mathcal{O},\\ell}\\,[\\,0,\\, 0,\\, b_{\\mathrm{O}}\\,]$。约束矩阵为 $\\mathbf{A}_{\\mathrm{eq}}\\,\\mathbf{x} = \\mathbf{b}_{\\mathrm{eq}}$，其中\n$$\n\\mathbf{A}_{\\mathrm{eq}} =\n\\begin{bmatrix}\n1  1  0 \\\\\n2  3  -6\n\\end{bmatrix},\n\\quad\n\\mathbf{b}_{\\mathrm{eq}} =\n\\begin{bmatrix}\n1 \\\\\n-3\n\\end{bmatrix}.\n$$\n- 通过构建 KKT 系统来求解等式约束最小二乘问题\n$$\n\\begin{bmatrix}\n\\mathbf{H}  \\mathbf{A}_{\\mathrm{eq}}^{\\mathsf{T}} \\\\\n\\mathbf{A}_{\\mathrm{eq}}  \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{x} \\\\\n\\boldsymbol{\\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{g} \\\\\n\\mathbf{b}_{\\mathrm{eq}}\n\\end{bmatrix},\n\\quad\n\\text{with }\n\\mathbf{H} = \\mathbf{M}^{\\mathsf{T}} \\mathbf{M},\n\\;\n\\mathbf{g} = \\mathbf{M}^{\\mathsf{T}} \\mathbf{y},\n$$\n其中 $\\boldsymbol{\\lambda}$ 是拉格朗日乘子。提取 $\\mathbf{x}$。\n\n测试套件和数值数据：\n- 分别对 $\\mathcal{A}$ 和 $\\mathcal{O}$ 集合使用标度因子 $S_{\\mathcal{A}} = \\big[\\,1.0,\\, 0.8,\\, 1.2\\,\\big]$ 和 $S_{\\mathcal{O}} = \\big[\\,1.0,\\, 0.9\\,\\big]$。\n- 使用相干散射长度 $b_{\\mathrm{Sr}} = 7.02$ (单位 $\\mathrm{fm}$)，$b_{\\mathrm{La}} = 8.24$ (单位 $\\mathrm{fm}$) 和 $b_{\\mathrm{O}} = 5.803$ (单位 $\\mathrm{fm}$)。\n- 每种情况的观测振幅代理 $\\mathbf{y}$ 如下：\n\n情况 $\\mathbf{1}$ (中度混合，氧缺位与电中性一致)：\n- 真实混合物（您的求解器不直接使用，仅供参考）：$x_{\\mathrm{Sr}} = 0.4$, $x_{\\mathrm{La}} = 0.6$, $x_{\\mathrm{O}} = 14/15$。\n- 观测到的 $\\mathcal{A}$ 位振幅：$y_{\\mathcal{A}} = \\big[\\,7.752,\\, 6.2016,\\, 9.3024\\,\\big]$。\n- 观测到的 $\\mathcal{O}$ 位振幅：$y_{\\mathcal{O}} = \\big[\\,5.416133333333333,\\, 4.87452\\,\\big]$。\n\n情况 $\\mathbf{2}$ (富 $\\mathrm{Sr}$ 边界)：\n- 真实混合物：$x_{\\mathrm{Sr}} = 1.0$, $x_{\\mathrm{La}} = 0.0$, $x_{\\mathrm{O}} = 5/6$。\n- 观测到的 $\\mathcal{A}$ 位振幅：$y_{\\mathcal{A}} = \\big[\\,7.02,\\, 5.616,\\, 8.424\\,\\big]$。\n- 观测到的 $\\mathcal{O}$ 位振幅：$y_{\\mathcal{O}} = \\big[\\,4.835833333333333,\\, 4.35225\\,\\big]$。\n\n情况 $\\mathbf{3}$ (富 $\\mathrm{La}$ 边界)：\n- 真实混合物：$x_{\\mathrm{Sr}} = 0.0$, $x_{\\mathrm{La}} = 1.0$, $x_{\\mathrm{O}} = 1.0$。\n- 观测到的 $\\mathcal{A}$ 位振幅：$y_{\\mathcal{A}} = \\big[\\,8.24,\\, 6.592,\\, 9.888\\,\\big]$。\n- 观测到的 $\\mathcal{O}$ 位振幅：$y_{\\mathcal{O}} = \\big[\\,5.803,\\, 5.2227\\,\\big]$。\n\n编程任务：\n- 实现一个程序，该程序利用提供的 $S_{\\mathcal{A}}$, $S_{\\mathcal{O}}$, $b_{\\mathrm{Sr}}$, $b_{\\mathrm{La}}$ 和 $b_{\\mathrm{O}}$ 以及上面列出的观测振幅代理，为每种情况构建 $\\mathbf{M}$ 和 $\\mathbf{y}$。然后求解 KKT 系统以获得每种情况下的精修占有率 $\\big[x_{\\mathrm{Sr}},\\, x_{\\mathrm{La}},\\, x_{\\mathrm{O}}\\big]$。\n- 数值输出必须表示为四舍五入到六位小数的小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个测试用例结果都是一个包含三个精修占有率 $\\big[x_{\\mathrm{Sr}},\\, x_{\\mathrm{La}},\\, x_{\\mathrm{O}}\\big]$ 的子列表，并四舍五入到六位小数。例如，输出应类似于 $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]$，不含任何额外文本或空格。", "solution": "我们从衍射中基本的结构因子概念开始，其中反射的强度与结构因子模的平方成正比，而结构因子是原子散射贡献的总和。当所选反射满足单个位点主导振幅且来自其他位点的相位干涉可忽略不计时，可以将振幅代理建模为该位点平均散射长度与已知几何标度因子的线性关系。对于具有部分占有率的位点，平均相干散射长度是组分物种的相干中子散射长度的占有率加权和。\n\n设 $\\mathbf{x} = \\big[x_{\\mathrm{Sr}},\\, x_{\\mathrm{La}},\\, x_{\\mathrm{O}}\\big]^{\\mathsf{T}}$ 为未知占有率向量。对于 $\\mathrm{A}$ 位，平均相干散射长度为\n$$\nb_{\\mathrm{avg},\\mathcal{A}} = b_{\\mathrm{Sr}}\\,x_{\\mathrm{Sr}} + b_{\\mathrm{La}}\\,x_{\\mathrm{La}},\n$$\n对于第 $k$ 个选定反射的振幅代理为\n$$\ny_{\\mathcal{A},k} \\approx S_{\\mathcal{A},k} \\, b_{\\mathrm{avg},\\mathcal{A}} = S_{\\mathcal{A},k}\\,\\big(b_{\\mathrm{Sr}}\\,x_{\\mathrm{Sr}} + b_{\\mathrm{La}}\\,x_{\\mathrm{La}}\\big).\n$$\n对于每个化学式单位中三个等效位点共用占有率 $x_{\\mathrm{O}}$ 的氧位，第 $\\ell$ 个选定反射的振幅代理为\n$$\ny_{\\mathcal{O},\\ell} \\approx S_{\\mathcal{O},\\ell} \\, b_{\\mathrm{O}} \\, x_{\\mathrm{O}}.\n$$\n\n我们强制执行两个线性约束：\n- $\\mathrm{A}$ 位完全占据：\n$$\nx_{\\mathrm{Sr}} + x_{\\mathrm{La}} = 1.\n$$\n- 使用固定的 $\\mathrm{Fe}^{3+}$、$\\mathrm{A}$ 位上混合的 $\\mathrm{Sr}^{2+}$ 和 $\\mathrm{La}^{3+}$，以及三个各带 -2 电荷、占有率为 $x_{\\mathrm{O}}$ 的氧位来实现电荷中性：\n$$\n2\\,x_{\\mathrm{Sr}} + 3\\,x_{\\mathrm{La}} + 3 - 2 \\cdot 3 \\, x_{\\mathrm{O}} = 0 \\;\\;\\Longleftrightarrow\\;\\; 2\\,x_{\\mathrm{Sr}} + 3\\,x_{\\mathrm{La}} - 6\\,x_{\\mathrm{O}} = -3.\n$$\n叠加这些约束条件可得\n$$\n\\mathbf{A}_{\\mathrm{eq}} =\n\\begin{bmatrix}\n1  1  0 \\\\\n2  3  -6\n\\end{bmatrix},\n\\quad\n\\mathbf{b}_{\\mathrm{eq}} =\n\\begin{bmatrix}\n1 \\\\\n-3\n\\end{bmatrix}.\n$$\n\n我们现在组装一个线性系统 $\\mathbf{M}\\,\\mathbf{x} \\approx \\mathbf{y}$，该系统叠加了所有振幅代理方程：\n- 对于每个标度为 $S_{\\mathcal{A},k}$ 的 $\\mathcal{A}$ 位反射，包含一行 $S_{\\mathcal{A},k}\\,[\\,b_{\\mathrm{Sr}},\\, b_{\\mathrm{La}},\\, 0\\,]$。\n- 对于每个标度为 $S_{\\mathcal{O},\\ell}$ 的 $\\mathcal{O}$ 位反射，包含一行 $S_{\\mathcal{O},\\ell}\\,[\\,0,\\, 0,\\, b_{\\mathrm{O}}\\,]$。\n\n给定观测到的振幅代理 $\\mathbf{y}$，约束最小二乘问题为\n$$\n\\min_{\\mathbf{x}} \\;\\; \\|\\mathbf{M}\\,\\mathbf{x} - \\mathbf{y}\\|_2^2 \\quad \\text{subject to} \\quad \\mathbf{A}_{\\mathrm{eq}}\\,\\mathbf{x} = \\mathbf{b}_{\\mathrm{eq}}.\n$$\n等式约束的一阶最优性条件（Karush-Kuhn-Tucker 条件）导出线性 KKT 系统\n$$\n\\begin{bmatrix}\n\\mathbf{H}  \\mathbf{A}_{\\mathrm{eq}}^{\\mathsf{T}} \\\\\n\\mathbf{A}_{\\mathrm{eq}}  \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{x} \\\\\n\\boldsymbol{\\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{g} \\\\\n\\mathbf{b}_{\\mathrm{eq}}\n\\end{bmatrix},\n\\quad\n\\text{with} \\quad\n\\mathbf{H} = \\mathbf{M}^{\\mathsf{T}} \\mathbf{M}, \\;\\; \\mathbf{g} = \\mathbf{M}^{\\mathsf{T}} \\mathbf{y}.\n$$\n求解此线性系统可得到在约束条件下最小化残差的精修占有率 $\\mathbf{x}$。此方法是稳健的，因为 $\\mathbf{H}$ 是半正定的，并且约束条件耦合了原本为块对角形式的正规方程，从而在给定数据下得到一个非奇异的 KKT 矩阵。\n\n我们现在将此方法应用于提供的测试套件。\n\n常数：\n- $b_{\\mathrm{Sr}} = 7.02$,\n- $b_{\\mathrm{La}} = 8.24$,\n- $b_{\\mathrm{O}} = 5.803$,\n- $S_{\\mathcal{A}} = \\big[\\,1.0,\\, 0.8,\\, 1.2\\,\\big]$,\n- $S_{\\mathcal{O}} = \\big[\\,1.0,\\, 0.9\\,\\big]$.\n\n对于每种情况，我们构建一个有五行的矩阵 $\\mathbf{M}$：\n$$\n\\mathbf{M} =\n\\begin{bmatrix}\n1.0\\,b_{\\mathrm{Sr}}  1.0\\,b_{\\mathrm{La}}  0 \\\\\n0.8\\,b_{\\mathrm{Sr}}  0.8\\,b_{\\mathrm{La}}  0 \\\\\n1.2\\,b_{\\mathrm{Sr}}  1.2\\,b_{\\mathrm{La}}  0 \\\\\n0  0  1.0\\,b_{\\mathrm{O}} \\\\\n0  0  0.9\\,b_{\\mathrm{O}}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n7.02  8.24  0 \\\\\n5.616  6.592  0 \\\\\n8.424  9.888  0 \\\\\n0  0  5.803 \\\\\n0  0  5.2227\n\\end{bmatrix}.\n$$\n然后，我们针对与观测振幅相对应的每个 $\\mathbf{y}$ 求解 KKT 系统。\n\n由于观测值是精确地从物理模型和约束条件生成的，约束最小二乘解能够在数值精度范围内恢复真实的占有率。精修后的结果（四舍五入到六位小数）如下：\n- 情况 1：$\\big[x_{\\mathrm{Sr}},\\, x_{\\mathrm{La}},\\, x_{\\mathrm{O}}\\big] = \\big[0.400000,\\, 0.600000,\\, 0.933333\\big]$。\n- 情况 2：$\\big[x_{\\mathrm{Sr}},\\, x_{\\mathrm{La}},\\, x_{\\mathrm{O}}\\big] = \\big[1.000000,\\, 0.000000,\\, 0.833333\\big]$。\n- 情况 3：$\\big[x_{\\mathrm{Sr}},\\, x_{\\mathrm{La}},\\, x_{\\mathrm{O}}\\big] = \\big[0.000000,\\, 1.000000,\\, 1.000000\\big]$。\n\n程序算法步骤：\n1. 定义常数 $b_{\\mathrm{Sr}}$, $b_{\\mathrm{La}}$, $b_{\\mathrm{O}}$, $S_{\\mathcal{A}}$ 和 $S_{\\mathcal{O}}$。\n2. 对于每个测试用例，使用标度因子和散射长度组装 $\\mathbf{M}$，并根据提供的观测振幅设置 $\\mathbf{y}$。\n3. 构建 $\\mathbf{H} = \\mathbf{M}^{\\mathsf{T}}\\mathbf{M}$ 和 $\\mathbf{g} = \\mathbf{M}^{\\mathsf{T}}\\mathbf{y}$。\n4. 组装 KKT 矩阵和右侧向量，并求解 $\\mathbf{x}$。\n5. 将 $\\mathbf{x}$ 四舍五入到六位小数，并收集所有情况的结果。\n6. 按照指定的确切格式打印汇总列表。\n\n程序将输出：\n$$\n[[0.400000,0.600000,0.933333],[1.000000,0.000000,0.833333],[0.000000,1.000000,1.000000]]\n$$\n每个条目都四舍五入到六位小数，并按要求格式化，不含空格。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(yA, yO, b_Sr, b_La, b_O, SA, SO):\n    \"\"\"\n    Solve the constrained least squares:\n        minimize || M x - y ||^2\n    subject to A_eq x = b_eq,\n    using the KKT system formulation.\n    \"\"\"\n    # Build M matrix\n    # Rows for A-site dominated reflections\n    MA = np.array([[SA[0] * b_Sr, SA[0] * b_La, 0.0],\n                   [SA[1] * b_Sr, SA[1] * b_La, 0.0],\n                   [SA[2] * b_Sr, SA[2] * b_La, 0.0]], dtype=float)\n    # Rows for O-site dominated reflections\n    MO = np.array([[0.0, 0.0, SO[0] * b_O],\n                   [0.0, 0.0, SO[1] * b_O]], dtype=float)\n    M = np.vstack([MA, MO])\n\n    # Observed y vector\n    y = np.concatenate([np.array(yA, dtype=float), np.array(yO, dtype=float)])\n\n    # Constraint matrices\n    Aeq = np.array([[1.0, 1.0, 0.0],\n                    [2.0, 3.0, -6.0]], dtype=float)\n    beq = np.array([1.0, -3.0], dtype=float)\n\n    # Form KKT system\n    H = M.T @ M\n    g = M.T @ y\n\n    # KKT matrix and rhs\n    KKT_size = H.shape[0] + Aeq.shape[0]\n    KKT = np.zeros((KKT_size, KKT_size))\n    KKT[:H.shape[0], :H.shape[1]] = H\n    KKT[:H.shape[0], H.shape[1]:] = Aeq.T\n    KKT[H.shape[0]:, :H.shape[1]] = Aeq\n    \n    rhs = np.concatenate([g, beq])\n\n    # Solve KKT system\n    sol = np.linalg.solve(KKT, rhs)\n    x = sol[:3]\n    return x\n\ndef main():\n    # Constants (neutron coherent scattering lengths in fm)\n    b_Sr = 7.02\n    b_La = 8.24\n    b_O = 5.803\n\n    # Scale factors\n    SA = [1.0, 0.8, 1.2]\n    SO = [1.0, 0.9]\n\n    # Test cases: observed amplitude proxies\n    # Case 1\n    yA1 = [7.752, 6.2016, 9.3024]\n    yO1 = [5.416133333333333, 4.87452]\n    # Case 2\n    yA2 = [7.02, 5.616, 8.424]\n    yO2 = [4.835833333333333, 4.35225]\n    # Case 3\n    yA3 = [8.24, 6.592, 9.888]\n    yO3 = [5.803, 5.2227]\n\n    test_cases = [\n        (yA1, yO1),\n        (yA2, yO2),\n        (yA3, yO3),\n    ]\n\n    results = []\n    for yA, yO in test_cases:\n        x = solve_case(yA, yO, b_Sr, b_La, b_O, SA, SO)\n        # Round to six decimals\n        x_rounded = [round(val, 6) for val in x]\n        results.append(x_rounded)\n\n    # Final print statement in the exact required format\n    # The output string must be a single line with no extra spaces.\n    output_str = \"[\" + \",\".join(\n        \"[\" + \",\".join(f\"{val:.6f}\" for val in case_res) + \"]\"\n        for case_res in results\n    ) + \"]\"\n    print(output_str)\n\nif __name__ == \"__main__\":\n    main()\n```", "id": "2517932"}]}