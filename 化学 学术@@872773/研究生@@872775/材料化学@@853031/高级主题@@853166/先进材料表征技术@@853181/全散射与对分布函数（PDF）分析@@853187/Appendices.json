{"hands_on_practices": [{"introduction": "我们的实践始于最基础的构建，我们将探讨一个最基本的情形：一个孤立的、固定的原子间距。这个练习将演示真实空间中的一个离散距离如何转换成倒易空间中的特定信号 $S(Q)$，然后再转换回对分布函数 $G(r)$ 中的一个理想化的峰 [@problem_id:161163]。掌握这一推导过程，将为理解任何PDF图谱中峰的来源奠定坚实的理论基础。", "problem": "原子对分布函数 (PDF)，记为 $G(r)$，提供了关于材料中原子对之间距离分布的关键信息。它通过与实验上可测量的总散射结构因子 $S(Q)$ 的关系来定义，该关系为傅里叶正弦变换：\n$$\nG(r) = \\frac{2}{\\pi} \\int_0^\\infty Q[S(Q)-1] \\sin(Qr) \\,dQ\n$$\n其中 $Q$ 是散射矢量的模。\n\n对于一个包含 $N$ 个原子、位置为 $\\{\\vec{r}_i\\}$ 的系统，其结构因子 $S(Q)$ 定义为干涉函数的取向平均：\n$$\nS(Q) = \\frac{1}{N} \\sum_{j=1}^N \\sum_{k=1}^N \\langle e^{-i\\vec{Q}\\cdot(\\vec{r}_j-\\vec{r}_k)} \\rangle\n$$\n对于一对被固定距离 $r_{jk} = |\\vec{r}_j - \\vec{r}_k|$ 分隔的原子 $j$ 和 $k$，其取向平均（由 $\\langle \\dots \\rangle$ 表示）由德拜公式给出：\n$$\n\\langle e^{-i\\vec{Q}\\cdot\\vec{r}_{jk}} \\rangle = \\frac{\\sin(Qr_{jk})}{Qr_{jk}}\n$$\n\n考虑一个单一、孤立的同核双原子分子。由于该分子在真空中是孤立的，其平均原子数密度 $\\rho_0$ 可视为零。假设原子是点状的，且分子是刚性的，具有固定的原子间距 $r_0$（即理想的、未展宽的情况），推导其对分布函数 $G(r)$ 的表达式。你可能需要狄拉克-德尔塔函数的积分表示：$\\int_0^\\infty \\cos(kx) \\,dk = \\pi \\delta(x)$。", "solution": "该问题要求推导一个具有固定键长 $r_0$ 的理想同核双原子分子的对分布函数 $G(r)$。我们将首先推导该系统的结构因子 $S(Q)$，然后进行傅里叶正弦变换。\n\n**步骤1：推导结构因子 $S(Q)$**\n\n对于一个双原子分子，原子数 $N=2$。设两个原子标记为1和2。结构因子的一般公式是：\n$$\nS(Q) = \\frac{1}{N} \\sum_{j=1}^2 \\sum_{k=1}^2 \\langle e^{-i\\vec{Q}\\cdot(\\vec{r}_j-\\vec{r}_k)} \\rangle\n$$\n我们可以将双重求和展开为四项：\n$$\nS(Q) = \\frac{1}{2} \\left[ \\langle e^{-i\\vec{Q}\\cdot(\\vec{r}_1-\\vec{r}_1)} \\rangle + \\langle e^{-i\\vec{Q}\\cdot(\\vec{r}_2-\\vec{r}_2)} \\rangle + \\langle e^{-i\\vec{Q}\\cdot(\\vec{r}_1-\\vec{r}_2)} \\rangle + \\langle e^{-i\\vec{Q}\\cdot(\\vec{r}_2-\\vec{r}_1)} \\rangle \\right]\n$$\n前两项（$j=k$ 时）是自散射项。矢量差为零，因此 $\\vec{r}_j - \\vec{r}_j = \\vec{0}$，且 $e^{-i\\vec{Q}\\cdot\\vec{0}} = e^0 = 1$。\n后两项（$j \\neq k$ 时）是相干散射项。原子之间的距离固定为 $|\\vec{r}_1 - \\vec{r}_2| = |\\vec{r}_2 - \\vec{r}_1| = r_0$。我们对这些项应用德拜公式。\n$$\nS(Q) = \\frac{1}{2} \\left[ 1 + 1 + \\frac{\\sin(Q|\\vec{r}_1-\\vec{r}_2|)}{Q|\\vec{r}_1-\\vec{r}_2|} + \\frac{\\sin(Q|\\vec{r}_2-\\vec{r}_1|)}{Q|\\vec{r}_2-\\vec{r}_1|} \\right]\n$$\n$$\nS(Q) = \\frac{1}{2} \\left[ 2 + \\frac{\\sin(Qr_0)}{Qr_0} + \\frac{\\sin(Qr_0)}{Qr_0} \\right] = \\frac{1}{2} \\left[ 2 + 2\\frac{\\sin(Qr_0)}{Qr_0} \\right]\n$$\n这可以简化为该双原子分子的结构因子：\n$$\nS(Q) = 1 + \\frac{\\sin(Qr_0)}{Qr_0}\n$$\n\n**步骤2：计算约化散射函数 $Q[S(Q)-1]$**\n\n根据推导出的 $S(Q)$，我们可以找到 $G(r)$ 积分所需的项：\n$$\nS(Q) - 1 = \\frac{\\sin(Qr_0)}{Qr_0}\n$$\n$$\nQ[S(Q)-1] = Q \\left( \\frac{\\sin(Qr_0)}{Qr_0} \\right) = \\frac{\\sin(Qr_0)}{r_0}\n$$\n\n**步骤3：计算傅里叶正弦变换以求得 $G(r)$**\n\n现在我们将此表达式代入 $G(r)$ 的定义中：\n$$\nG(r) = \\frac{2}{\\pi} \\int_0^\\infty Q[S(Q)-1] \\sin(Qr) \\,dQ = \\frac{2}{\\pi} \\int_0^\\infty \\frac{\\sin(Qr_0)}{r_0} \\sin(Qr) \\,dQ\n$$\n我们可以将常数 $1/r_0$ 从积分中提出：\n$$\nG(r) = \\frac{2}{\\pi r_0} \\int_0^\\infty \\sin(Qr_0) \\sin(Qr) \\,dQ\n$$\n为了计算该积分，我们使用三角函数的积化和差恒等式：$\\sin A \\sin B = \\frac{1}{2}[\\cos(A-B) - \\cos(A+B)]$。令 $A = Qr_0$ 和 $B = Qr$。\n$$\nG(r) = \\frac{2}{\\pi r_0} \\int_0^\\infty \\frac{1}{2}[\\cos(Q(r_0-r)) - \\cos(Q(r_0+r))] \\,dQ\n$$\n$$\nG(r) = \\frac{1}{\\pi r_0} \\left[ \\int_0^\\infty \\cos(Q(r-r_0)) \\,dQ - \\int_0^\\infty \\cos(Q(r+r_0)) \\,dQ \\right]\n$$\n注意 $\\cos$ 是偶函数，所以 $\\cos(x) = \\cos(-x)$，这使我们可以写出 $\\cos(Q(r_0-r)) = \\cos(Q(r-r_0))$。\n\n**步骤4：使用狄拉克-德尔塔函数表示**\n\n题目给出了恒等式 $\\int_0^\\infty \\cos(kx) \\,dk = \\pi \\delta(x)$。将其应用于我们的两个积分：\n\\begin{enumerate}\n    \\item  $\\int_0^\\infty \\cos(Q(r-r_0)) \\,dQ = \\pi \\delta(r-r_0)$\n    \\item  $\\int_0^\\infty \\cos(Q(r+r_0)) \\,dQ = \\pi \\delta(r+r_0)$\n\\end{enumerate}\n将这些结果代回 $G(r)$ 的表达式：\n$$\nG(r) = \\frac{1}{\\pi r_0} [\\pi \\delta(r-r_0) - \\pi \\delta(r+r_0)] = \\frac{1}{r_0} [\\delta(r-r_0) - \\delta(r+r_0)]\n$$\n由于 $r$ 代表物理距离，它必须是非负的（$r \\ge 0$）。键长 $r_0$ 是严格为正的（$r_0 > 0$）。因此，项 $r+r_0$ 总是正的，永远不为零。这意味着对于所有物理上的 $r$ 值，$\\delta(r+r_0) = 0$。\n表达式简化为：\n$$\nG(r) = \\frac{\\delta(r-r_0)}{r_0}\n$$\n这就是同核双原子分子的理想、未展宽的对分布函数。它正确地表示了在 $r=r_0$ 处存在一个单一的原子间距。", "answer": "$$\n\\boxed{\\frac{\\delta(r-r_0)}{r_0}}\n$$", "id": "161163"}, {"introduction": "从理想化的单一距离转向更真实的材料，我们现在考虑一个由连续对分布函数 $g(r)$ 描述的体系。本练习涉及“正向问题”：即从给定的真实空间原子排布计算预期的总散射结构因子 $S(Q)$ [@problem_id:2533214]。你将为各向同性体系推导关键的积分变换，并以数值方式实现它，从而巩固对真实空间和倒易空间之间傅里叶关系的理解，并培养模拟散射数据的实用计算技能。", "problem": "给定一种单原子各向同性材料，其特征在于数密度 $\\rho_{0}$ 和对分布函数 (PDF) $g(r)$，其中 $r$ 是对间距。总散射结构因子 $S(Q)$（其中散射矢量模长 $Q$ 的单位为 $\\mathrm{\\AA}^{-1}$）从第一性原理出发，定义为总关联函数 $h(r)=g(r)-1$ 的三维傅里叶变换，通过以下公式表示：\n$$\nS(Q) \\;=\\; 1 \\;+\\; \\rho_{0} \\int_{\\mathbb{R}^{3}} \\mathrm{d}^{3}\\mathbf{r}\\; h(r)\\, e^{\\,i\\mathbf{Q}\\cdot\\mathbf{r}}\\,,\n$$\n其中 $\\mathbf{Q}$ 是模长为 $Q$ 的矢量，$r=\\lvert \\mathbf{r}\\rvert$。对于各向同性系统，该表达式可简化为关于 $r$ 的一维积分，此积分必须从上述定义出发进行推导，不得假定任何快捷公式。\n\n你的任务是：\n- 从给定的三维定义和各向同性假设出发，推导出一个对于 $Q \\ge 0$ 在数值上易于处理的 $S(Q)$ 的一维积分表达式，包括其在 $Q \\to 0$ 时的良定义极限。\n- 实现一个数值算法，用于计算所得的一维积分，并使 $S(Q)$ 的计算结果达到指定的绝对公差。\n- 将你的实现应用于以下测试套件，并按要求格式输出结果。\n\n使用以下解析指定的 $g(r)$ 和参数：\n- 数密度：$\\rho_{0} = 0.084\\;\\mathrm{\\AA}^{-3}$。\n- 对分布函数：\n$$\ng(r) \\;=\\; 1 \\;+\\; A \\exp\\!\\Big(-\\frac{(r-r_{0})^{2}}{2\\sigma^{2}}\\Big) \\;-\\; C \\exp\\!\\Big(-\\frac{r^{2}}{2\\sigma_{c}^{2}}\\Big),\n$$\n参数为 $A=1.4$，$r_{0}=2.75\\;\\mathrm{\\AA}$，$\\sigma=0.12\\;\\mathrm{\\AA}$，$C=0.2$ 以及 $\\sigma_{c}=0.45\\;\\mathrm{\\AA}$。该 $g(r)$ 是光滑的，当 $r\\to \\infty$ 时趋向于 $1$，并且对于单原子系统是物理上合理的。\n\n数值要求和指南：\n- 所有距离 $r$ 的单位均为 $\\mathrm{\\AA}$，所有 $Q$ 值的单位均为 $\\mathrm{\\AA}^{-1}$。结构因子 $S(Q)$ 是无量纲的。\n- 对于每个测试用例，你必须确保 $S(Q)$ 的绝对误差至多为 $\\varepsilon_{S} = 10^{-8}$。\n- 你的数值计算必须是一维的，并且必须控制上限 $r_{\\max}$ 的截断，以确保在与积分前因子结合时，被忽略的尾部贡献小于所要求的公差。你可以假设对于高斯因子 $\\exp(-x^{2}/2)$，其尾部积分满足 $\\int_{k}^{\\infty} \\exp(-t^{2}/2)\\,\\mathrm{d}t \\le \\exp(-k^{2}/2)/k$ (对于 $k>0$)，你可以选择一个足够大的倍数 $k$，使得尾部与 $\\varepsilon_{S}$ 相比可以忽略不计。请确保在你选择的实现中明确记录所选的 $r_{\\max}$。\n- 角度单位：在你的推导中引入的任何角度依赖性都必须以弧度处理。\n- 对分布函数 (PDF) 必须理解为上面定义的实空间函数 $g(r)$。\n\n测试套件：\n- 对所有测试使用上面指定的单一 $g(r)$ 和 $\\rho_{0}$。为以下四个 $Q$ 值（单位为 $\\mathrm{\\AA}^{-1}$）计算 $S(Q)$：$Q \\in \\{0.0,\\;0.5,\\;4.0,\\;15.0\\}$。\n- 对于 $Q=0$，你必须使用由你的推导所蕴含的正确极限形式，以避免数值奇异点。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含 $S(Q)$ 的四个结果，其顺序与上述测试套件的 $Q$ 值相同，四舍五入到恰好 $8$ 位小数，并以逗号分隔列表的形式用方括号括起来。例如，包含四个结果的输出应类似于 $\\big[$$s_{1}$$,$$s_{2}$$,$$s_{3}$$,$$s_{4}$$\\big]\\,$，其中每个 $s_{i}$ 在小数点后恰好有 $8$ 位数字。", "solution": "问题陈述已经过验证。我们发现其具有科学依据、内容自洽、逻辑一致且定义明确。它代表了凝聚态物理学中的一个标准问题。我们接下来进行推导和数值求解。\n\n任务是为一个单原子各向同性系统计算总散射结构因子 $S(Q)$。出发点是所给出的定义，即总关联函数 $h(r) = g(r) - 1$ 的三维傅里叶变换。\n$$S(Q) = 1 + \\rho_{0} \\int_{\\mathbb{R}^{3}} \\mathrm{d}^{3}\\mathbf{r}\\; h(r)\\, e^{i\\,\\mathbf{Q}\\cdot\\mathbf{r}}$$\n此处，$\\rho_{0}$ 是数密度，$\\mathbf{Q}$ 是模长为 $Q$ 的散射矢量，$\\mathbf{r}$ 是模长为 $r$ 的位置矢量。系统的各向同性意味着 $h(r)$ 仅依赖于标量距离 $r = |\\mathbf{r}|$。\n\n为计算该积分，我们将积分变量 $\\mathbf{r}$ 用球极坐标 $(r, \\theta, \\phi)$ 表示。体积元为 $\\mathrm{d}^{3}\\mathbf{r} = r^2 \\sin\\theta \\,\\mathrm{d}r\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi$。为简化起见，我们对齐坐标系，使矢量 $\\mathbf{Q}$ 沿 $z$ 轴。因此，$\\mathbf{Q} = (0, 0, Q)$。指数项中的点积变为 $\\mathbf{Q}\\cdot\\mathbf{r} = Q r \\cos\\theta$，其中 $\\theta$ 是极角。\n\n积分变为：\n$$ \\int_{\\mathbb{R}^{3}} \\mathrm{d}^{3}\\mathbf{r}\\; h(r)\\, e^{i\\,\\mathbf{Q}\\cdot\\mathbf{r}} = \\int_0^\\infty \\mathrm{d}r \\int_0^\\pi \\mathrm{d}\\theta \\int_0^{2\\pi} \\mathrm{d}\\phi\\; h(r)\\, e^{iQr\\cos\\theta}\\, r^2 \\sin\\theta $$\n被积函数与方位角 $\\phi$ 无关，因此对 $\\phi$ 的积分产生一个因子 $2\\pi$：\n$$ = 2\\pi \\int_0^\\infty \\mathrm{d}r\\; r^2 h(r) \\left( \\int_0^\\pi \\mathrm{d}\\theta\\; e^{iQr\\cos\\theta} \\sin\\theta \\right) $$\n我们通过换元法计算关于 $\\theta$ 的内层积分。令 $u = \\cos\\theta$，这意味着 $\\mathrm{d}u = -\\sin\\theta\\,\\mathrm{d}\\theta$。$u$ 的积分限从 $\\cos(0)=1$ 到 $\\cos(\\pi)=-1$。\n$$ \\int_0^\\pi e^{iQr\\cos\\theta} \\sin\\theta\\,\\mathrm{d}\\theta = \\int_1^{-1} e^{iQru} (-\\mathrm{d}u) = \\int_{-1}^1 e^{iQru}\\,\\mathrm{d}u $$\n这个基本积分的计算结果为：\n$$ \\left[ \\frac{e^{iQru}}{iQr} \\right]_{-1}^1 = \\frac{e^{iQr} - e^{-iQr}}{iQr} $$\n使用欧拉恒等式 $\\sin(x) = (e^{ix} - e^{-ix})/(2i)$，上式简化为：\n$$ \\frac{2i\\sin(Qr)}{iQr} = 2 \\frac{\\sin(Qr)}{Qr} $$\n该表达式在 $Q>0$ 和 $r>0$ 时有效。\n\n将此结果代回到 $S(Q)$ 的表达式中，我们得到其一维积分表示：\n$$ S(Q) = 1 + \\rho_{0} \\cdot 2\\pi \\int_0^\\infty r^2 h(r) \\left( 2 \\frac{\\sin(Qr)}{Qr} \\right) \\mathrm{d}r $$\n$$ S(Q) = 1 + 4\\pi\\rho_0 \\int_0^\\infty r^2 (g(r)-1) \\frac{\\sin(Qr)}{Qr} \\mathrm{d}r $$\n该方程是各向同性系统的一个普适结果，通常以略有不同的形式被称为德拜散射方程。对于数值计算，此形式更为优越，因为它能正确处理 $Q \\to 0$ 的极限情况。\n\n对于 $Q=0$ 的特定情况，我们考察被积函数的极限。当 $Q \\to 0$ 时，函数 $\\frac{\\sin(Qr)}{Qr}$ 趋近于 $1$。$S(0)$ 的表达式变为：\n$$ S(0) = \\lim_{Q\\to 0} S(Q) = 1 + 4\\pi\\rho_0 \\int_0^\\infty r^2 (g(r)-1) \\mathrm{d}r $$\n这是一个熟知的结果，它将零散射角处的结构因子与总关联函数的积分联系起来，而后者又与材料的等温压缩率相关。通过使用一个合适的 `sinc` 函数（其中 $\\text{sinc}(x) = \\sin(x)/x$ 且 $\\text{sinc}(0)=1$）来实现这个统一的公式，我们可以在积分例程中无需特殊情况逻辑，就能正确地计算所有 $Q \\ge 0$（包括 $Q=0$）情况下的 $S(Q)$。\n\n对于数值实现，我们必须计算一个从 $r=0$ 到 $r=\\infty$ 的定积分。我们将使用一个有限的积分上限 $r_{\\max}$，并确保截断误差可以忽略不计。总关联函数由下式给出：\n$$ h(r) = g(r) - 1 = A \\exp\\left(-\\frac{(r-r_{0})^{2}}{2\\sigma^{2}}\\right) - C \\exp\\left(-\\frac{r^{2}}{2\\sigma_{c}^{2}}\\right) $$\n其中 $A=1.4$，$r_{0}=2.75\\,\\mathrm{\\AA}$，$\\sigma=0.12\\,\\mathrm{\\AA}$，$C=0.2$，以及 $\\sigma_{c}=0.45\\,\\mathrm{\\AA}$。$h(r)$ 中的两项都是高斯函数，并且对于大的 $r$ 值会极快地衰减。第一项以 $r_0=2.75\\,\\mathrm{\\AA}$ 为中心，标准差很小，为 $\\sigma=0.12\\,\\mathrm{\\AA}$。当 $r$ 值偏离 $r_0$ 几个 $\\sigma$ 的距离时，函数 $h(r)$ 及其与 $r$ 的幂的乘积将小到可以忽略。\n我们选择 $r_{\\max}$ 为 $5.0\\,\\mathrm{\\AA}$。在此距离上，第一个指数的参数约为 $-((5.0-2.75)/0.12)^2/2 \\approx -(18.75)^2/2 \\approx -176$，这使得 $\\exp(-176)$ 在计算上为零。第二项相对于其宽度衰减得更快。因此，选择 $r_{\\max}=5.0\\,\\mathrm{\\AA}$ 足以确保截断误差比所要求的绝对误差容限 $\\varepsilon_S = 10^{-8}$ 小很多个数量级。\n\n该积分将使用 `scipy.integrate.quad` 函数进行计算，这是一个稳健的自适应求积例程。为了满足 $S(Q)$ 的目标精度，我们将积分本身的绝对误差容限设置为一个更严格的值 `epsabs`$=10^{-10}$。\n\n最终需要实现的表达式是：\n$$ S(Q) = 1 + \\int_0^{r_{\\max}} 4\\pi\\rho_0 r^2 h(r) \\frac{\\sin(Qr)}{Qr} \\mathrm{d}r $$\n函数 $\\frac{\\sin(Qr)}{Qr}$ 将使用 `numpy.sinc` 来实现，以稳健地处理 $Qr=0$ 的情况。`numpy.sinc(x)` 函数计算的是 $\\sin(\\pi x)/(\\pi x)$。因此，我们通过 `numpy.sinc(Qr/numpy.pi)` 来计算 $\\frac{\\sin(Qr)}{Qr}$。\n\n步骤如下：\n1.  定义常量 $\\rho_0, A, r_0, \\sigma, C, \\sigma_c$。\n2.  定义函数 $h(r)$。\n3.  定义被积函数 $I(r, Q) = 4\\pi\\rho_0 r^2 h(r) \\frac{\\sin(Qr)}{Qr}$。\n4.  对于每个给定的 $Q$ 值，使用 `scipy.integrate.quad` 计算 $S(Q) = 1 + \\int_0^{5.0} I(r, Q) \\mathrm{d}r$。\n5.  按规定格式化并打印结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Derives and calculates the total scattering structure factor S(Q)\n    for a monatomic isotropic material.\n    \"\"\"\n    \n    # Define physical constants and parameters for g(r)\n    # in units of Angstroms (Å) and inverse Angstroms (Å⁻¹).\n    RHO0 = 0.084    # Number density in Å⁻³\n    A = 1.4         # Amplitude of the first Gaussian peak\n    R0 = 2.75       # Position of the first peak in Å\n    SIGMA = 0.12    # Width of the first peak in Å\n    C = 0.2         # Amplitude of the compensatory Gaussian\n    SIGMAC = 0.45   # Width of the compensatory Gaussian in Å\n\n    # Numerical integration parameters.\n    # The upper integration limit r_max is chosen to be 5.0 Å.\n    # The function h(r) decays extremely rapidly due to its Gaussian nature.\n    # The dominant term is centered at r0=2.75 Å with sigma=0.12 Å.\n    # At r=5.0 Å, r is (5.0-2.75)/0.12 ≈ 18.75 standard deviations from the peak.\n    # The value of the Gaussian term is proportional to exp(-18.75²/2), which is\n    # computationally zero, ensuring the truncation error is negligible.\n    R_MAX = 5.0\n    \n    # Absolute tolerance for the numerical quadrature to ensure the final\n    # error on S(Q) is less than 10⁻⁸.\n    INTEGRATION_TOL = 1e-10\n\n    def h(r: float) -> float:\n        \"\"\"\n        Calculates the total correlation function, h(r) = g(r) - 1.\n        \n        Args:\n            r: The pair separation distance in Å.\n        \n        Returns:\n            The value of h(r).\n        \"\"\"\n        term1 = A * np.exp(-(r - R0)**2 / (2 * SIGMA**2))\n        term2 = C * np.exp(-r**2 / (2 * SIGMAC**2))\n        return term1 - term2\n\n    def integrand(r: float, Q: float) -> float:\n        \"\"\"\n        The integrand for calculating the integral part of S(Q).\n        This formulation is valid for all Q >= 0.\n        \n        Args:\n            r: The pair separation distance in Å.\n            Q: The magnitude of the scattering vector in Å⁻¹.\n        \n        Returns:\n            The value of the integrand at r for a given Q.\n        \"\"\"\n        # The form is 4*pi*rho0 * r^2 * h(r) * sin(Qr)/(Qr).\n        # We use np.sinc for robust evaluation at Qr -> 0.\n        # np.sinc(x) is defined as sin(pi*x)/(pi*x).\n        # So, to compute sin(Qr)/(Qr), we use np.sinc(Q*r/np.pi).\n        # The r^2 term naturally handles the r=0 case, making the integrand 0.\n        sinc_term = np.sinc(Q * r / np.pi)\n        \n        return 4 * np.pi * RHO0 * r**2 * h(r) * sinc_term\n\n    def calculate_s_q(Q: float) -> float:\n        \"\"\"\n        Calculates the structure factor S(Q) for a given Q value.\n        \n        Args:\n            Q: The magnitude of the scattering vector in Å⁻¹.\n            \n        Returns:\n            The calculated value of S(Q).\n        \"\"\"\n        integral_val, _ = integrate.quad(\n            integrand, a=0, b=R_MAX, args=(Q,), epsabs=INTEGRATION_TOL\n        )\n        return 1.0 + integral_val\n\n    # Test cases for Q in Å⁻¹ as specified in the problem statement.\n    test_cases = [0.0, 0.5, 4.0, 15.0]\n\n    results = []\n    for q_val in test_cases:\n        s_q_result = calculate_s_q(q_val)\n        results.append(s_q_result)\n    \n    # Format the final results to exactly 8 decimal places and print.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2533214"}, {"introduction": "在真实的实验中，我们测量散射数据直至一个有限的动量转移值 $Q_{\\max}$，然后通过傅里叶逆变换得到 $G(r)$。这个动手编程练习将探讨这种不可避免的数据截断如何在计算出的PDF中引入被称为“截断涟漪”的人为信号 [@problem_id:2533221]。你将实现并比较几种旨在减轻这些影响的“窗函数”，通过量化峰分辨率和伪影抑制之间的权衡，你将对PDF数据处理中最关键的实际步骤之一获得深刻的见解。", "problem": "给定一个对应于单个原子间距 $R$ 的合成简约总散射函数 $F(Q)$。简约对分布函数 $G(r)$ 由正弦变换定义\n$$\nG(r) = \\frac{2}{\\pi} \\int_{0}^{Q_{\\max}} w(Q)\\,F(Q)\\,\\sin(Q r)\\,dQ,\n$$\n其中 $w(Q)$ 是一个窗函数（或称锥化函数），用于减轻由有限截止值 $Q_{\\max}$ 引起的截断效应（termination ripples）。在此问题中，您需要对每个测试用例，在相同的 $Q_{\\max}$ 下使用三种不同的窗函数计算和比较 $G(r)$：\n- 矩形窗: $w_{\\mathrm{rect}}(Q) = 1$ for $0 \\le Q \\le Q_{\\max}$。\n- Lorch 窗: $w_{\\mathrm{Lorch}}(Q) = \\dfrac{\\sin\\!\\left(\\pi Q/Q_{\\max}\\right)}{\\pi Q/Q_{\\max}}$ for $0 \\le Q \\le Q_{\\max}$。\n- Hann 窗 (升余弦): $w_{\\mathrm{Hann}}(Q) = \\dfrac{1}{2}\\left[1+\\cos\\!\\left(\\pi Q/Q_{\\max}\\right)\\right]$ for $0 \\le Q \\le Q_{\\max}$。\n\n基本和建模假设：\n- 对于稀疏、相同散射体系统中的单个原子间距 $R$，静态结构因子满足 $S(Q)-1 \\propto \\dfrac{\\sin(QR)}{Q R}$。简约总散射函数为 $F(Q) = Q\\,[S(Q)-1]$，在不考虑整体缩放因子的情况下，即为 $F(Q) = \\dfrac{\\sin(QR)}{R}$。请使用此模型计算 $F(Q)$。\n- 在 $Q$ 的均匀网格上，使用梯形法则进行数值积分。\n\n数值规格：\n- 在 $[0, Q_{\\max}]$ 上使用均匀的 $Q$ 网格，步长为 $\\Delta Q = 0.01\\,\\text{\\AA}^{-1}$（包括两个端点）。\n- 在 $[0, 6.0]$ 上使用均匀的 $r$ 网格计算 $G(r)$，步长为 $\\Delta r = 0.002\\,\\text{\\AA}$（包括两个端点）。\n- 在每个测试用例中，三种窗函数使用相同的 $Q_{\\max}$。\n- 物理单位：$Q$ 的单位是 $\\text{\\AA}^{-1}$，$r$ 的单位是 $\\text{\\AA}$。所有与 $r$ 相关的输出值和所有宽度值均以 $\\text{\\AA}$ 为单位报告。振幅和比率为无量纲。\n\n对于每个测试用例和每种窗函数，从数值计算出的 $G(r)$ 中计算以下四个定量指标：\n1. $R$ 附近的峰位：在区间 $[R-1.0\\,\\text{\\AA},\\,R+1.0\\,\\text{\\AA}]$ 内，$G(r)$ 达到其最大值时 $r$ 的值。\n2. 主峰的半峰全宽（FWHM）：通过线性插值确定所识别峰周围的左右半高交叉点，并报告它们的差值（以 $\\text{\\AA}$ 为单位）。\n3. 峰值振幅：在 $[R-1.0\\,\\text{\\AA},\\,R+1.0\\,\\text{\\AA}]$ 内 $G(r)$ 的最大值。\n4. 最大旁瓣比：在 FWHM 区间之外（即对于 $r \\in [0,6.0]$，排除左右半高交叉点之间的区域），$G(r)$ 的最大绝对值与峰值振幅之比。\n\n将所有报告的浮点数值四舍五入到六位小数。\n\n测试套件：\n为以下参数集计算结果（$R$ 以 $\\text{\\AA}$ 为单位，$Q_{\\max}$ 以 $\\text{\\AA}^{-1}$ 为单位）：\n- 测试 1 (一般情况): $R = 2.0$, $Q_{\\max} = 25.0$。\n- 测试 2 (低 $Q_{\\max}$ 边界): $R = 2.0$, $Q_{\\max} = 8.0$。\n- 测试 3 (短距离): $R = 1.0$, $Q_{\\max} = 25.0$。\n- 测试 4 (高 $Q_{\\max}$): $R = 2.0$, $Q_{\\max} = 40.0$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表。每个内部列表对应于按上述顺序列出的一个测试用例，并且必须按以下顺序包含十二个浮点数：\n$[$peak$_{\\mathrm{rect}}$, FWHM$_{\\mathrm{rect}}$, amp$_{\\mathrm{rect}}$, sidelobe$_{\\mathrm{rect}}$, peak$_{\\mathrm{Lorch}}$, FWHM$_{\\mathrm{Lorch}}$, amp$_{\\mathrm{Lorch}}$, sidelobe$_{\\mathrm{Lorch}}$, peak$_{\\mathrm{Hann}}$, FWHM$_{\\mathrm{Hann}}$, amp$_{\\mathrm{Hann}}$, sidelobe$_{\\mathrm{Hann}}]$,\n所有浮点数均四舍五入至六位小数。例如，打印的行应如下所示：\n[[v11,v12,...,v1,12],[v21,v22,...,v2,12],[v31,...,v3,12],[v41,...,v4,12]]\n\n所有关于 $r$ 和 FWHM 的输出必须以 $\\text{\\AA}$ 为单位，而振幅和比率是无量纲的。不应打印任何额外的文本。", "solution": "所提出的问题是材料表征领域中一个定义明确的计算练习，具体涉及总散射和对分布函数（PDF）分析。它具有科学依据，是完整的，并且其参数在物理上是现实的。因此，该问题是有效的，并将提供一个解决方案。\n\n目标是从一个简约总散射函数模型 $F(Q)$ 计算出简约对分布函数 $G(r)$，并量化三种不同窗函数对所得 $G(r)$ 峰形的影响。\n\n$G(r)$ 和 $F(Q)$ 之间的关系由正弦傅里叶变换给出：\n$$\nG(r) = \\frac{2}{\\pi} \\int_{0}^{Q_{\\max}} w(Q)\\,F(Q)\\,\\sin(Q r)\\,dQ\n$$\n此处，$Q$ 是散射矢量的模，$r$ 是原子间距，$Q_{\\max}$ 是实验或计算数据范围的有限上限。函数 $w(Q)$ 是一个窗函数或锥化函数，用于减轻截断效应，这是由于在 $Q_{\\max}$ 处突然截断积分而导致的 $G(r)$ 中的伪振荡。\n\n该问题模拟了仅包含单一、唯一原子间距 $R$ 的系统的散射。对于这样一个简化系统，简约总散射函数 $F(Q) = Q[S(Q)-1]$（其中 $S(Q)$ 是静态结构因子）可以近似为：\n$$\nF(Q) = \\frac{\\sin(QR)}{R}\n$$\n该模型是单对原子 Debye 散射方程的缩放版本，可作为本次研究的有效且解析上简单的函数。\n\n我们将比较三种标准的窗函数：\n1.  **矩形窗**：$w_{\\mathrm{rect}}(Q) = 1$。这相当于不应用任何窗函数，通常会在 $G(r)$ 中产生最尖锐的中心峰，但也会带来最严重的截断效应。\n2.  **Lorch 窗**：$w_{\\mathrm{Lorch}}(Q) = \\dfrac{\\sin(\\pi Q/Q_{\\max})}{\\pi Q/Q_{\\max}}$。这是一个 sinc 函数，是矩形函数的傅里叶变换。应用它的目的是为了锐化实空间中的特征。\n3.  **Hann 窗**：$w_{\\mathrm{Hann}}(Q) = \\dfrac{1}{2}\\left[1+\\cos(\\pi Q/Q_{\\max})\\right]$。这种升余弦窗提供了出色的旁瓣抑制，但代价是主峰会略有展宽。\n\n$G(r)$ 的解析积分不进行计算。相反，要求使用基于梯形法则的数值方法。连续函数在均匀网格上进行离散化。$Q$ 空间网格范围为 $[0, Q_{\\max}]$，步长为 $\\Delta Q = 0.01\\,\\text{\\AA}^{-1}$；$r$ 空间网格范围为 $[0, 6.0\\,\\text{\\AA}]$，步长为 $\\Delta r = 0.002\\,\\text{\\AA}$。\n\n对于 $r$ 网格上的每个点 $r_j$，$G(r_j)$ 的数值计算如下：\n$$\nG(r_j) \\approx \\frac{2}{\\pi} \\sum_{i=0}^{N-1} \\frac{y_i(r_j) + y_{i+1}(r_j)}{2} \\Delta Q\n$$\n其中 $y_i(r_j) = w(Q_i) F(Q_i) \\sin(Q_i r_j)$，$Q_i$ 是 $Q$ 网格上的点。为了提高效率，此过程被向量化。项 $\\sin(Q_i r_j)$ 作为 $Q$ 和 $r$ 向量的外积来计算。然后，所有 $r_j$ 值的被积函数表示为一个矩阵，并沿该矩阵的 $Q$ 轴应用梯形法则，从而在单次操作中计算出整个 $G(r)$ 曲线。\n\n对于每个计算出的 $G(r)$ 曲线，提取四个指标：\n1.  **峰位 ($r_{\\mathrm{peak}}$) 和振幅 ($A_{\\mathrm{peak}}$)**：在搜索区间 $[R-1.0\\,\\text{\\AA}, R+1.0\\,\\text{\\AA}]$ 内找到 $G(r)$ 最大值对应的 $r$ 值和 $G(r)$ 值。\n2.  **半峰全宽 (FWHM)**：峰值振幅 $50\\%$ 处的峰宽。半高值为 $A_{\\text{half}} = A_{\\text{peak}} / 2$。算法从峰位向外搜索，找到在峰的左侧（$r  r_{\\text{peak}}$）和右侧（$r > r_{\\text{peak}}$）与半高值相交的两个点。通过在相邻网格点之间进行线性插值来精确定位这些交叉点，FWHM即为两点之间的距离。\n3.  **峰值振幅**：在 $[R-1.0\\,\\text{\\AA},\\,R+1.0\\,\\text{\\AA}]$ 内 $G(r)$ 的最大值。\n4.  **最大旁瓣比**：在 FWHM 区间之外（即对于 $r \\in [0,6.0]$，排除左右半高交叉点之间的区域），$G(r)$ 的最大绝对值与峰值振幅之比。", "answer": "```python\nimport numpy as np\n\ndef calculate_all_metrics(G_r, r_grid, R):\n    \"\"\"\n    Calculates peak position, FWHM, peak amplitude, and sidelobe ratio for a G(r) curve.\n    \n    Args:\n        G_r (np.ndarray): The computed G(r) values.\n        r_grid (np.ndarray): The r-grid.\n        R (float): The ideal interatomic distance.\n\n    Returns:\n        list: A list containing [peak_pos, fwhm, peak_amp, sidelobe_ratio].\n    \"\"\"\n    # 1. Peak Position and Amplitude\n    search_mask = (r_grid = R - 1.0)  (r_grid = R + 1.0)\n    \n    # Ensure search range is not empty\n    if not np.any(search_mask):\n        return [np.nan] * 4\n        \n    G_r_search = G_r[search_mask]\n    r_grid_search = r_grid[search_mask]\n    \n    if len(G_r_search) == 0:\n        return [np.nan] * 4\n\n    peak_idx_local = np.argmax(G_r_search)\n    peak_amp = G_r_search[peak_idx_local]\n    \n    # Convert local index back to global index\n    search_indices = np.where(search_mask)[0]\n    peak_idx_global = search_indices[peak_idx_local]\n    peak_pos = r_grid[peak_idx_global]\n\n    if peak_amp == 0:\n        return [peak_pos, 0.0, 0.0, 0.0]\n\n    # 2. FWHM\n    half_max = peak_amp / 2.0\n    \n    # Find left crossing\n    # Search backwards from peak\n    i = peak_idx_global\n    while i  0 and G_r[i] = half_max:\n        i -= 1\n    \n    # Linear interpolation for left crossing\n    if i == 0 and G_r[0] = half_max:\n        r_left = r_grid[0]\n    else:\n        y1, y2 = G_r[i], G_r[i+1]\n        x1, x2 = r_grid[i], r_grid[i+1]\n        r_left = x1 + (x2 - x1) * (half_max - y1) / (y2 - y1) if (y2 - y1) != 0 else (x1 + x2) / 2\n        \n    # Find right crossing\n    # Search forwards from peak\n    j = peak_idx_global\n    while j  len(r_grid) - 1 and G_r[j] = half_max:\n        j += 1\n\n    # Linear interpolation for right crossing\n    if j == len(r_grid) - 1 and G_r[j] = half_max:\n        r_right = r_grid[-1]\n    else:\n        y1, y2 = G_r[j-1], G_r[j]\n        x1, x2 = r_grid[j-1], r_grid[j]\n        r_right = x1 + (x2 - x1) * (half_max - y1) / (y2 - y1) if (y2 - y1) != 0 else (x1 + x2) / 2\n        \n    fwhm = r_right - r_left\n\n    # 4. Maximum Sidelobe Ratio\n    sidelobe_mask = (r_grid  r_left) | (r_grid  r_right)\n    sidelobe_values = G_r[sidelobe_mask]\n    \n    if len(sidelobe_values) == 0:\n        max_sidelobe_abs = 0.0\n    else:\n        max_sidelobe_abs = np.max(np.abs(sidelobe_values))\n        \n    sidelobe_ratio = max_sidelobe_abs / peak_amp\n\n    return [peak_pos, fwhm, peak_amp, sidelobe_ratio]\n\ndef process_case(R, Q_max):\n    \"\"\"\n    Processes a single test case (R, Q_max) for all three window functions.\n    \n    Args:\n        R (float): Interatomic distance in Angstroms.\n        Q_max (float): Maximum scattering vector in Angstrom^-1.\n\n    Returns:\n        list: A flattened list of 12 metric values for the three windows.\n    \"\"\"\n    dQ = 0.01\n    dr = 0.002\n    \n    Q = np.arange(0, Q_max + dQ, dQ)\n    r = np.arange(0, 6.0 + dr, dr)\n    \n    F_Q = np.sin(Q * R) / R\n    \n    # Define window functions\n    w_rect = np.ones_like(Q)\n    w_lorch = np.sinc(Q / Q_max) # np.sinc(x) is sin(pi*x)/(pi*x)\n    w_hann = 0.5 * (1 + np.cos(np.pi * Q / Q_max))\n    \n    windows = {'rect': w_rect, 'lorch': w_lorch, 'hann': w_hann}\n    results = []\n    \n    # Vectorized calculation of G(r)\n    Qr_matrix = np.outer(Q, r)\n    sin_Qr = np.sin(Qr_matrix)\n\n    for w_name in ['rect', 'lorch', 'hann']:\n        w_Q = windows[w_name]\n        \n        # Integrand: w(Q) * F(Q) * sin(Qr)\n        integrand_matrix = (w_Q * F_Q)[:, np.newaxis] * sin_Qr\n        \n        # Trapezoidal rule integration along the Q-axis (axis=0)\n        integral_values = np.trapz(integrand_matrix, x=Q, axis=0)\n        \n        G_r = (2 / np.pi) * integral_values\n        \n        # Calculate metrics\n        metrics = calculate_all_metrics(G_r, r, R)\n        results.extend(metrics)\n        \n    return results\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        (2.0, 25.0), # Test 1\n        (2.0, 8.0),  # Test 2\n        (1.0, 25.0), # Test 3\n        (2.0, 40.0)  # Test 4\n    ]\n\n    all_results = []\n    for R, Q_max in test_cases:\n        case_results = process_case(R, Q_max)\n        all_results.append(case_results)\n\n    # Format output string\n    row_strings = [f\"[{','.join(f'{v:.6f}' for v in row)}]\" for row in all_results]\n    final_output = f\"[{','.join(row_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2533221"}]}