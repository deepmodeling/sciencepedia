{"hands_on_practices": [{"introduction": "在设计和理解玻璃材料时，一个核心任务是根据其化学成分预测网络结构。本练习将指导您完成对一个复杂铝硅酸盐玻璃的化学计量分析。通过此实践，您将学会如何区分网络改性剂的不同作用——电荷补偿铝酸盐单元和产生非桥氧（non-bridging oxygens, NBOs），并最终计算出关键的结构参数 $\\mathrm{NBO/T}$，这是连接成分与玻璃性能（如黏度）的桥梁 [@problem_id:2522549]。", "problem": "一种多组分铝硅酸盐玻璃的摩尔百分比组成如下：$\\mathrm{SiO_2}$ $=$ $64$，$\\mathrm{Al_2O_3}$ $=$ $12$，$\\mathrm{Na_2O}$ $=$ $10$，$\\mathrm{CaO}$ $=$ $8$，以及 $\\mathrm{MgO}$ $=$ $6$。假设一个理想的无规网络，其中当有足够的改性体电荷时，所有的铝都以四面体配位的 $\\mathrm{AlO_4^-}$ 单元形式进入网络，所有的改性阳离子（$\\mathrm{Na^+}$、$\\mathrm{Ca^{2+}}$、$\\mathrm{Mg^{2+}}$）首先对 $\\mathrm{AlO_4^-}$ 单元进行电荷平衡，任何剩余的改性体正电荷则用于产生非桥氧。在这些条件下，忽略其他网络形成体或铝的更高配位态的可能性。\n\n仅从原子平衡和电荷中性出发，并使用“每个四面体配位网络形成体的非桥氧数”（NBO/T）的定义，即非桥氧阴离子数与四面体配位网络形成体阳离子总数之比，完成以下任务：\n\n- 确定（以正电荷当量为基础）用于电荷平衡 $\\mathrm{AlO_4^-}$ 的改性阳离子电荷分数与用于产生非桥氧的分数。\n- 因此，计算该组成的 $\\mathrm{NBO/T}$ 值，其中四面体配位的网络形成体是 $\\mathrm{Si}$ 和 $\\mathrm{Al}$。\n\n只报告 $\\mathrm{NBO/T}$ 的最终值作为你的答案。如果它能精确地表示为一个有理数，请给出精确值；否则四舍五入到四位有效数字。$\\mathrm{NBO/T}$ 是一个无量纲的量；不要包含单位。", "solution": "所提出的问题是硅酸盐玻璃结构化学中的一个标准练习，并且是有效的。它在科学上基于已建立的玻璃结构模型，问题设定良好，数据充分且一致，表述客观。下面将进行解答。\n\n分析基于玻璃网络内的原子和电荷平衡。我们以摩尔百分比给出的氧化物组分为基础，考虑 $100$ 摩尔的总量。\n\n首先，我们根据给定的组成确定各组成阳离子的摩尔量：\n- $\\mathrm{SiO_2}$ 的摩尔数 $= 64$。这提供了 $64$ 摩尔的 $\\mathrm{Si}^{4+}$ 阳离子。\n- $\\mathrm{Al_2O_3}$ 的摩尔数 $= 12$。这提供了 $2 \\times 12 = 24$ 摩尔的 $\\mathrm{Al}^{3+}$ 阳离子。\n- $\\mathrm{Na_2O}$ 的摩尔数 $= 10$。这提供了 $2 \\times 10 = 20$ 摩尔的 $\\mathrm{Na}^{+}$ 阳离子。\n- $\\mathrm{CaO}$ 的摩尔数 $= 8$。这提供了 $8$ 摩尔的 $\\mathrm{Ca}^{2+}$ 阳离子。\n- $\\mathrm{MgO}$ 的摩尔数 $= 6$。这提供了 $6$ 摩尔的 $\\mathrm{Mg}^{2+}$ 阳离子。\n\n问题将四面体配位的网络形成体阳离子 T 定义为硅和铝。这些阳离子的总摩尔量，记为 $[T]$，是硅和铝的摩尔数之和。\n$$\n[T] = [\\mathrm{Si}] + [\\mathrm{Al}] = 64 + 24 = 88 \\text{ 摩尔}\n$$\n\n接下来，我们评估电荷平衡要求。根据问题陈述，$\\mathrm{Al}^{3+}$ 在四面体网络中取代 $\\mathrm{Si}^{4+}$。这种取代为每个并入 $(\\mathrm{AlO_4})$ 四面体的铝原子产生一个 $-1$ 的局部电荷亏损。因此，网络中每摩尔的 $\\mathrm{Al}^{3+}$ 需要一摩尔的正电荷来进行补偿。\n- 需要电荷补偿的 $\\mathrm{Al}^{3+}$ 的摩尔数 $= 24$。\n- 铝补偿所需的正电荷 $= 24$ 摩尔电荷。\n\n这种电荷补偿由网络改性阳离子提供：$\\mathrm{Na}^{+}$、$\\mathrm{Ca}^{2+}$ 和 $\\mathrm{Mg}^{2+}$。我们计算来自这些改性体的总可用正电荷。电荷贡献是离子的摩尔量乘以其价态。\n- 来自 $\\mathrm{Na}^{+}$ 的电荷：$1 \\times [\\mathrm{Na}^{+}] = 1 \\times 20 = 20$ 摩尔电荷。\n- 来自 $\\mathrm{Ca}^{2+}$ 的电荷：$2 \\times [\\mathrm{Ca}^{2+}] = 2 \\times 8 = 16$ 摩尔电荷。\n- 来自 $\\mathrm{Mg}^{2+}$ 的电荷：$2 \\times [\\mathrm{Mg}^{2+}] = 2 \\times 6 = 12$ 摩尔电荷。\n\n可用的总改性体正电荷为：\n$$\n[\\text{改性体电荷}]_{\\text{总}} = 20 + 16 + 12 = 48 \\text{ 摩尔电荷}\n$$\n\n问题规定了电荷分布的层次结构：改性阳离子首先平衡 $(\\mathrm{AlO_4})^{-}$ 单元。\n- 可用的改性体电荷（$48$ 摩尔）大于铝补偿所需的电荷（$24$ 摩尔）。这证实了所有铝都以 $(\\mathrm{AlO_4})^{-}$ 形式进入网络的假设是成立的。\n\n因此，用于平衡铝的改性体电荷的分数为 $\\frac{24}{48} = \\frac{1}{2}$。剩余的改性体电荷用于产生非桥氧（NBOs）。\n- 剩余改性体电荷 $= [\\text{改性体电荷}]_{\\text{总}} - (\\text{铝补偿电荷})$\n$$\n\\text{剩余改性体电荷} = 48 - 24 = 24 \\text{ 摩尔电荷}\n$$\n这回答了问题内部的第一个查询；电荷在铝补偿和非桥氧生成之间平均分配。\n\n非桥氧的生成涉及一个桥连 $\\mathrm{T-O-T}$ 键的断裂，产生一个形式电荷为 $-1$ 的端氧（$\\mathrm{T-O^-}$），它由一个单位的改性阳离子正电荷来平衡。例如，$\\mathrm{O}^{2-} + \\equiv\\mathrm{T-O-T}\\equiv \\rightarrow 2(\\equiv\\mathrm{T-O^-})$。形成的两个非桥氧上的两个负电荷由来自改性体的两个正电荷（例如，$2\\mathrm{Na}^+$ 或 $1\\mathrm{Ca}^{2+}$）来平衡。因此，NBOs 的摩尔数在数值上等于未用于铝补偿的改性体正电荷的摩尔数。\n$$\n[\\mathrm{NBO}] = \\text{剩余改性体电荷} = 24 \\text{ 摩尔}\n$$\n\n最后，我们计算 $\\mathrm{NBO/T}$，即非桥氧数与四面体配位网络形成体阳离子总数之比。\n$$\n\\mathrm{NBO/T} = \\frac{[\\mathrm{NBO}]}{[T]} = \\frac{24}{88}\n$$\n这个分数简化如下：\n$$\n\\frac{24}{88} = \\frac{12}{44} = \\frac{6}{22} = \\frac{3}{11}\n$$\n结果是一个精确的有理数，符合要求。", "answer": "$$\\boxed{\\frac{3}{11}}$$", "id": "2522549"}, {"introduction": "除了基于化学计量的结构单元分析，我们还可以从物理拓扑学的角度来审视玻璃网络。拓扑约束理论（Topological Constraint Theory）提供了一个强大的框架，通过量化原子间的机械约束来预测网络的刚性。在此练习 [@problem_id:2522564] 中，您将应用该理论，从第一性原理出发计算二氧化硅（$\\mathrm{SiO_2}$）网络中的平均约束数 $\\langle n_c \\rangle$，并判断该网络是柔性的、等静态的还是应力刚性的。", "problem": "一个完全聚合的二氧化硅（$\\mathrm{SiO_2}$）玻璃网络完全由以硅为中心的四面体构成，其中所有的氧都是桥氧（每个氧原子与两个硅原子键合）。在拓扑约束理论（TCT）的框架内考虑该网络，其中网络的刚性是通过平衡每个原子的力学约束数量与每个原子的自由度数量来评估的。\n\n使用以下基于键合和玻璃化转变温度（$T_g$）附近热激活的、有物理依据的假设：\n- 在三维（$3$D）网络中，每个原子贡献 $3$ 个平移自由度。\n- 每个共价键贡献一个键伸缩约束，该约束由其连接的两个原子平均共享。\n- 对于配位数为 $r$ 的中心原子，当其周围的键弯曲（角）约束完整时，用于固定 $r$ 个键方向的这组约束有 $2r-3$ 个独立成员。\n- 在 $T_g$ 下的 $\\mathrm{SiO_2}$ 中，以硅为中心的氧-硅-氧（$\\mathrm{O\\!-\\!Si\\!-\\!O}$）角约束是完整的，而以氧为中心的硅-氧-硅（$\\mathrm{Si\\!-\\!O\\!-\\!Si}$）角约束则被热削弱，可被视为已断裂。\n\n按以下步骤进行：\n1. 根据约束计数的第一性原理，在上述假设下，确定在一个完全聚合的 $\\mathrm{SiO_2}$ 网络中，与一个硅原子和一个桥氧原子相关的键伸缩和键弯曲约束的数量。\n2. 通过在化学计量的 $\\mathrm{SiO_2}$ 中按原子分数对各物种特定的约束进行加权，计算每个原子的平均约束数 $\\langle n_c \\rangle$。\n3. 使用 Maxwell 刚性判据，根据你所获得的 $\\langle n_c \\rangle$ 值，说明该网络是等静的、应力刚性的还是柔性的。\n\n将 $\\langle n_c \\rangle$ 的数值作为最终答案报告，不带单位。如果得到的是精确值，请勿四舍五入。分类应在你的计算过程中得到明确的论证，但无需包含在最终的数值答案中。", "solution": "在尝试解答之前，对所提出的问题进行验证。\n\n首先，从问题陈述中逐字提取已知条件：\n- 该系统是一个完全聚合的二氧化硅（$\\mathrm{SiO_2}$）玻璃网络。\n- 该结构由以硅为中心的四面体构成，其中所有的氧都是桥氧。\n- 理论框架是拓扑约束理论（TCT）。\n- 维度是三维（$3$D），每个原子有 $3$ 个平移自由度。\n- 一个共价键贡献一个键伸缩约束，由两个原子平均共享。\n- 配位数为 $r$ 的中心原子周围的独立键弯曲约束数量为 $2r-3$。\n- 以硅为中心的 O-Si-O 角约束是完整的。\n- 以氧为中心的 Si-O-Si 角约束是断裂的。\n\n该问题具有科学依据，因为它采用了广为接受的 Phillips-Thorpe 拓扑约束理论来分析一种典型的网络形成玻璃 $\\mathrm{SiO_2}$ 的刚性。关于配位数和玻璃化转变温度下角约束状态的假设在该模型中是标准的。该问题是适定的，提供了计算每个原子的平均约束数和对网络进行分类所需的所有必要定义和数据。其语言客观且精确。因此，该问题是有效的，将提供解答。\n\n目标是计算 $\\mathrm{SiO_2}$ 网络的每个原子平均约束数 $\\langle n_c \\rangle$，并根据 Maxwell 判据对其刚性进行分类。这将按要求分三步执行。\n\n步骤 $1$：确定每种原子的约束。\n\n首先，考虑硅（$\\mathrm{Si}$）原子。在一个完全聚合的 $\\mathrm{SiO_2}$ 网络中，每个硅原子位于一个四面体的中心，与四个氧原子键合。因此，硅的配位数是 $r_{\\mathrm{Si}} = 4$。\n硅原子上的约束有两种类型：键伸缩和键弯曲。\n- 键伸缩约束（$\\alpha$ 约束）：$4$ 个 Si-O 共价键中的每一个都施加一个约束。由于每个约束由其连接的两个原子平均共享，因此归于单个 Si 原子的伸缩约束数量是其配位数的一半。\n$$n_{\\alpha}(\\mathrm{Si}) = \\frac{r_{\\mathrm{Si}}}{2} = \\frac{4}{2} = 2$$\n- 键弯曲约束（$\\beta$ 约束）：这些是以 Si 原子为中心的角约束，对应于 O-Si-O 键角。问题陈述说明这些约束是完整的。对于配位数为 $r$ 的中心原子，有 $2r-3$ 个独立的角约束。对于硅，其 $r_{\\mathrm{Si}}=4$：\n$$n_{\\beta}(\\mathrm{Si}) = 2r_{\\mathrm{Si}} - 3 = 2(4) - 3 = 8 - 3 = 5$$\n每个硅原子的总约束数 $n_c(\\mathrm{Si})$ 是其伸缩约束和弯曲约束之和。\n$$n_c(\\mathrm{Si}) = n_{\\alpha}(\\mathrm{Si}) + n_{\\beta}(\\mathrm{Si}) = 2 + 5 = 7$$\n\n接下来，考虑氧（$\\mathrm{O}$）原子。问题指明所有氧原子都是桥氧，意味着每个氧原子连接两个硅原子。因此，氧的配位数是 $r_{\\mathrm{O}} = 2$。\n- 键伸缩约束：一个氧原子参与两个 Si-O 键。归于单个 O 原子的伸缩约束数量是其配位数的一半。\n$$n_{\\alpha}(\\mathrm{O}) = \\frac{r_{\\mathrm{O}}}{2} = \\frac{2}{2} = 1$$\n- 键弯曲约束：以氧原子为中心的角约束是 Si-O-Si 键角。问题明确指出，在玻璃化转变温度下，该约束被热削弱，应被视为断裂。因此，它对刚性分析的计数贡献为零。\n$$n_{\\beta}(\\mathrm{O}) = 0$$\n每个氧原子的总约束数 $n_c(\\mathrm{O})$ 是其伸缩约束和弯曲约束之和。\n$$n_c(\\mathrm{O}) = n_{\\alpha}(\\mathrm{O}) + n_{\\beta}(\\mathrm{O}) = 1 + 0 = 1$$\n\n步骤 $2$：计算每个原子的平均约束数 $\\langle n_c \\rangle$。\n\n每个原子的平均约束数是每种原子的约束的加权平均值，其中权重是原子分数。对于化学计量的 $\\mathrm{SiO_2}$，一个化学式单位包含一个硅原子和两个氧原子，总共 $1+2=3$ 个原子。\n硅的原子分数是 $x_{\\mathrm{Si}} = \\frac{1}{1+2} = \\frac{1}{3}$。\n氧的原子分数是 $x_{\\mathrm{O}} = \\frac{2}{1+2} = \\frac{2}{3}$。\n每个原子的平均约束数 $\\langle n_c \\rangle$ 计算如下：\n$$\\langle n_c \\rangle = x_{\\mathrm{Si}} n_c(\\mathrm{Si}) + x_{\\mathrm{O}} n_c(\\mathrm{O})$$\n代入步骤 $1$ 中导出的值：\n$$\\langle n_c \\rangle = \\left(\\frac{1}{3}\\right) \\times 7 + \\left(\\frac{2}{3}\\right) \\times 1 = \\frac{7}{3} + \\frac{2}{3} = \\frac{9}{3} = 3$$\n\n步骤 $3$：基于 Maxwell 判据的刚性分类。\n\nMaxwell 刚性判据将每个原子的平均力学约束数 $\\langle n_c \\rangle$ 与每个原子的自由度数 $N_{dof}$ 进行比较。问题陈述该系统是三维（$3$D）的，并且只考虑平移自由度，所以 $N_{dof} = 3$。\n网络的刚性分类如下：\n- 如果 $\\langle n_c \\rangle  N_{dof}$，网络是柔性的（欠约束）。\n- 如果 $\\langle n_c \\rangle = N_{dof}$，网络是等静的（临界约束）。\n- 如果 $\\langle n_c \\rangle  N_{dof}$，网络是应力刚性的（过约束）。\n\n在本例中，我们计算出 $\\langle n_c \\rangle = 3$ 并且有 $N_{dof} = 3$。由于 $\\langle n_c \\rangle = N_{dof}$，在指定假设下的 $\\mathrm{SiO_2}$ 玻璃网络被分类为等静的。这标志着一个网络是刚性的，但没有冗余约束，这种状态通常与最佳的玻璃形成能力相关。\n\n所要求的最终答案是 $\\langle n_c \\rangle$ 的数值。", "answer": "$$\\boxed{3}$$", "id": "2522564"}, {"introduction": "理论模型和化学计量预测的有效性最终需要通过实验或计算机模拟数据来检验。本实践提供了一个直接处理原子尺度模拟数据的机会，要求您编写代码来分析给定的钠硅酸盐玻璃构型。您将计算并分析径向分布函数（radial distribution functions, RDFs）、键角分布和 $Q^n$ 物种分布等关键结构描述符，这些都是表征无定形材料结构的基本工具 [@problem_id:2522514]。", "problem": "考虑一个在周期性边界条件下进行原子尺度建模的硅酸钠玻璃网络。给定两个人工合成但科学上真实的分子构型（作为两个独立的测试用例），每个构型都包含一个单独的帧，其中有硅、氧和钠原子在边长为 $L_{\\mathrm{box}}$ 埃（Å）的立方模拟晶胞内的原子位置。你的任务是，对于每个测试用例，从基本定义出发计算：(i) 偏径向分布函数，(ii) 角分布，以及 (iii) $Q^n$ 形态分布，然后将这些计算结果与基于实验观测和化学计量约束的基准值进行比较。\n\n基本定义与要求：\n\n1. 必须使用最小镜像约定施加周期性边界条件。对于任意两个原子沿一个边长为 $L_{\\mathrm{box}}$ 的笛卡尔坐标轴的位移矢量 $\\Delta \\mathbf{r}$，其最小镜像分量为 $\\Delta r^\\prime = \\Delta r - L_{\\mathrm{box}} \\,\\mathrm{round}(\\Delta r / L_{\\mathrm{box}})$。欧几里得距离则为 $r = \\lVert \\Delta \\mathbf{r}^\\prime \\rVert$。\n\n2. 物种 $\\beta$ 周围的物种 $\\alpha$ 的偏径向分布函数 $g_{\\alpha\\beta}(r)$ 定义为\n$$\ng_{\\alpha\\beta}(r) = \\frac{1}{N_\\alpha\\,\\rho_\\beta}\\,\\frac{1}{4\\pi r^2 \\Delta r}\\,\\sum_{i \\in \\alpha} \\sum_{j \\in \\beta,\\, j \\neq i} \\mathbf{1}\\{r_{ij} \\in [r, r+\\Delta r)\\},\n$$\n其中 $N_\\alpha$ 是 $\\alpha$ 类型原子的数量，$\\rho_\\beta = N_\\beta/V$ 是物种 $\\beta$ 的数密度，$V = L_{\\mathrm{box}}^3$ 是体积，$\\Delta r$ 是径向区间宽度，$\\mathbf{1}\\{\\cdot\\}$ 是指示函数。此定义对 $\\alpha \\neq \\beta$ 和 $\\alpha = \\beta$ 均成立（当 $\\alpha=\\beta$ 时，不包括自身对）。\n\n3. 需要计算四面体内的氧-硅-氧角和四面体间的硅-氧-硅角的角分布：\n   - 对于氧-硅-氧角 $P_{\\mathrm{O\\!-\\!Si\\!-\\!O}}(\\theta)$，每个位于硅原子上的角 $\\theta$ 是通过从该硅原子指向两个与其成键的不同氧邻居（在截断半径 $r_{\\mathrm{c}}^{\\mathrm{SiO}}$ 内）的矢量计算得出的。\n   - 对于硅-氧-硅角 $P_{\\mathrm{Si\\!-\\!O\\!-\\!Si}}(\\theta)$，每个位于氧原子上的角 $\\theta$ 是通过从该氧原子指向两个不同硅邻居（在 $r_{\\mathrm{c}}^{\\mathrm{SiO}}$ 内）的矢量计算得出的。\n   角由下式给出\n   $$\n   \\theta = \\arccos\\!\\left(\\frac{\\mathbf{u}\\cdot\\mathbf{v}}{\\lVert \\mathbf{u}\\rVert\\,\\lVert \\mathbf{v}\\rVert}\\right),\n   $$\n   并转换为度。使用 $r_{\\mathrm{c}}^{\\mathrm{SiO}} = 2.10\\,\\mathrm{\\AA}$。\n\n4. 桥氧（BO）和非桥氧（NBO）由硅的配位情况定义：一个与恰好两个硅原子成键（在 $r_{\\mathrm{c}}^{\\mathrm{SiO}}$ 内）的氧原子是BO；与恰好一个硅原子成键的是NBO。对于每个硅原子，$Q^n$ 定义为与该硅原子相连的BO的数量 $n$（即 $n \\in \\{0,1,2,3,4\\}$）。$Q^n$ 分布是所有硅原子的 $n$ 值的直方图，平均 $Q$ 指数为 $\\bar{n} = \\frac{1}{N_{\\mathrm{Si}}}\\sum_{\\mathrm{Si}} n$。\n\n5. 碱金属硅酸盐中平均 $Q$ 指数的化学计量基准：假设每个钠阳离子对一个NBO进行电荷平衡，则每个硅原子的平均桥氧数满足\n$$\n\\bar{n}_{\\mathrm{bench}} = 4 - \\frac{N_{\\mathrm{Na}}}{N_{\\mathrm{Si}}}.\n$$\n\n6. 用于比较计算所得结构指标的基准值：\n   - $g_{\\mathrm{SiO}}(r)$ 的第一峰位置在 $1.62\\,\\mathrm{\\AA}$ 附近。\n   - $g_{\\mathrm{OO}}(r)$ 的第一峰位置在 $2.62\\,\\mathrm{\\AA}$ 附近。\n   - $g_{\\mathrm{NaO}}(r)$ 的第一峰位置在 $2.35\\,\\mathrm{\\AA}$ 附近。\n   - $P_{\\mathrm{O\\!-\\!Si\\!-\\!O}}(\\theta)$ 的峰值在 $109.5\\,\\mathrm{deg}$ 附近。\n   - $P_{\\mathrm{Si\\!-\\!O\\!-\\!Si}}(\\theta)$ 的峰值在 $140\\,\\mathrm{deg}$ 附近。\n   - 平均 $Q$ 指数 $\\bar{n}$ 在上述 $\\bar{n}_{\\mathrm{bench}}$ 附近。\n\n7. 需使用的数值参数：\n   - 距离单位必须为埃，角度单位必须为度。\n   - 使用径向区间宽度 $\\Delta r = 0.005\\,\\mathrm{\\AA}$ 和最大距离 $r_{\\max} = 6.0\\,\\mathrm{\\AA}$。\n   - 在 $\\theta \\in [0,180]\\,\\mathrm{deg}$ 范围内使用角度区间宽度 $\\Delta \\theta = 0.5\\,\\mathrm{deg}$。\n\n8. 每个测试用例的判定逻辑：定义布尔标志，如果计算出的指标与基准值在指定容差范围内一致，则该标志为真：\n   - $\\lvert r_{\\mathrm{peak}}^{\\mathrm{SiO}} - 1.62\\rvert  0.05\\,\\mathrm{\\AA}$，\n   - $\\lvert r_{\\mathrm{peak}}^{\\mathrm{OO}} - 2.62\\rvert  0.12\\,\\mathrm{\\AA}$，\n   - $\\lvert r_{\\mathrm{peak}}^{\\mathrm{NaO}} - 2.35\\rvert  0.12\\,\\mathrm{\\AA}$，\n   - $\\lvert \\theta_{\\mathrm{peak}}^{\\mathrm{O\\!-\\!Si\\!-\\!O}} - 109.5\\rvert  3.0\\,\\mathrm{deg}$，\n   - $\\lvert \\theta_{\\mathrm{peak}}^{\\mathrm{Si\\!-\\!O\\!-\\!Si}} - 140.0\\rvert  10.0\\,\\mathrm{deg}$，\n   - $\\lvert \\bar{n} - \\bar{n}_{\\mathrm{bench}}\\rvert  0.01$。\n   仅当所有六个条件都为真时，测试用例的结果才为真。\n\n测试套件规范（两种构型；所有坐标单位为埃；角度单位为度；立方晶胞边长 $L_{\\mathrm{box}} = 30.0$）：\n\n每种构型都通过算法构建，以编码具有物理意义的局部结构：\n\n- 两种情况共用的常数：\n  - 理想硅-氧键长 $L_{\\mathrm{SiO}} = 1.62$。\n  - 桥氧处的硅-氧-硅目标角度 $\\theta_{\\mathrm{Si\\!-\\!O\\!-\\!Si}} = 140.0$。\n  - 标准四面体方向 $\\{\\mathbf{d}_k\\}_{k=1}^4 = \\{\\frac{(1,1,1)}{\\sqrt{3}}, \\frac{(1,-1,-1)}{\\sqrt{3}}, \\frac{(-1,1,-1)}{\\sqrt{3}}, \\frac{(-1,-1,1)}{\\sqrt{3}}\\}$。\n  - 对于一个位于 $\\mathbf{S}$ 处的硅原子与位于 $\\mathbf{O}$ 处的氧原子键合，令 $\\hat{\\mathbf{t}} = \\frac{\\mathbf{O}-\\mathbf{S}}{\\lVert \\mathbf{O}-\\mathbf{S}\\rVert}$ 表示单位键方向。其他三个氧邻居（非桥氧）被放置在 $\\mathbf{S} + L_{\\mathrm{SiO}}\\,\\mathbf{R}\\mathbf{d}_k$ 处，其中 $\\mathbf{d}_k$ 是未被选为桥接方向的三个方向，而 $\\mathbf{R}$ 是通过罗德里格斯公式将参考方向 $\\mathbf{d}_{\\mathrm{ref}}=\\frac{(1,1,1)}{\\sqrt{3}}$ 映射到 $-\\hat{\\mathbf{t}}$ 的旋转。这种构造确保了非桥氧邻居的局部氧-硅-氧角接近 $109.47\\,\\mathrm{deg}$。\n  - 对于每个与硅原子 $\\mathbf{S}$ 成键的非桥氧原子 $\\mathbf{O}$，在其 $\\mathbf{O} - L_{\\mathrm{NaO}}\\,\\frac{\\mathbf{S}-\\mathbf{O}}{\\lVert \\mathbf{S}-\\mathbf{O}\\rVert}$ 位置放置一个钠原子，其中 $L_{\\mathrm{NaO}} = 2.35$。\n\n- 测试用例 1（由一个桥氧连接的两个共角四面体）：\n  - 将单个桥氧放置在原点 $\\mathbf{O}_{\\mathrm{b}} = (0,0,0)$。\n  - 将两个硅原子放置在距离原点 $L_{\\mathrm{SiO}}$ 处，使得位于氧原子上、指向两个硅原子的矢量之间的角度为 $\\theta_{\\mathrm{Si\\!-\\!O\\!-\\!Si}} = 140.0\\,\\mathrm{deg}$。在 $xy$ 平面上，放置 $\\mathbf{S}_1 = L_{\\mathrm{SiO}}(\\cos 70^\\circ, \\sin 70^\\circ, 0)$ 和 $\\mathbf{S}_2 = L_{\\mathrm{SiO}}(\\cos(-70^\\circ), \\sin(-70^\\circ, 0)$。\n  - 在每个硅原子周围，使用上述四面体旋转规则构建三个非桥氧，其中参考方向映射到朝向桥氧的键方向。\n  - 按规定为每个非桥氧放置一个钠原子。\n  - 这将产生 $N_{\\mathrm{Si}}=2$，$N_{\\mathrm{O}}=7$，$N_{\\mathrm{Na}}=6$。\n\n- 测试用例 2（由两个桥氧连接的三个四面体链）：\n  - 第一个桥：放置 $\\mathbf{O}_{12} = (0,0,0)$。放置 $\\mathbf{S}_2 = L_{\\mathrm{SiO}}(\\cos 70^\\circ, \\sin 70^\\circ, 0)$ 和 $\\mathbf{S}_1 = L_{\\mathrm{SiO}}(\\cos(-70^\\circ), \\sin(-70^\\circ), 0)$。\n  - 在 $\\mathbf{S}_2$ 周围，计算将参考方向映射到朝向 $\\mathbf{O}_{12}$ 的键的四面体旋转。选择剩下三个旋转过的四面体方向之一 $\\hat{\\mathbf{t}}_{23}$，并将第二个桥放置在 $\\mathbf{O}_{23} = \\mathbf{S}_2 + L_{\\mathrm{SiO}}\\,\\hat{\\mathbf{t}}_{23}$。\n  - 第二个桥的几何结构：在 $\\mathbf{O}_{23}$ 处，定义 $\\hat{\\mathbf{u}} = \\frac{\\mathbf{S}_2 - \\mathbf{O}_{23}}{\\lVert \\mathbf{S}_2 - \\mathbf{O}_{23}\\rVert}$。选择任意一个与 $\\hat{\\mathbf{u}}$ 正交的单位矢量 $\\hat{\\mathbf{p}}$，并设置 $\\hat{\\mathbf{w}} = \\cos(140^\\circ)\\,\\hat{\\mathbf{u}} + \\sin(140^\\circ)\\,\\hat{\\mathbf{p}}$。放置 $\\mathbf{S}_3 = \\mathbf{O}_{23} + L_{\\mathrm{SiO}}\\,\\hat{\\mathbf{w}}$ 以在 $\\mathbf{O}_{23}$ 处强制形成一个 $140.0\\,\\mathrm{deg}$ 的硅-氧-硅角。\n  - 在每个硅原子周围，使用四面体旋转规则放置剩余的非桥氧，其中参考方向映射到该硅原子所使用的桥方向上。按规定为每个非桥氧放置一个钠原子。\n  - 这将产生 $N_{\\mathrm{Si}}=3$，$N_{\\mathrm{O}}=10$，$N_{\\mathrm{Na}}=8$。\n\n每个测试用例的计算任务：\n\n- 使用上述定义和参数 $\\Delta r = 0.005\\,\\mathrm{\\AA}$ 和 $r_{\\max} = 6.0\\,\\mathrm{\\AA}$ 计算 $g_{\\mathrm{SiO}}(r)$、$g_{\\mathrm{OO}}(r)$ 和 $g_{\\mathrm{NaO}}(r)$。在窗口 $[1.4,1.9]\\,\\mathrm{\\AA}$（硅-氧）、$[2.2,3.0]\\,\\mathrm{\\AA}$（氧-氧）、$[2.1,2.6]\\,\\mathrm{\\AA}$（钠-氧）内识别第一峰的位置。\n- 使用 $\\Delta \\theta = 0.5\\,\\mathrm{deg}$ 在 $[0,180]\\,\\mathrm{deg}$ 范围内计算 $P_{\\mathrm{O\\!-\\!Si\\!-\\!O}}(\\theta)$ 和 $P_{\\mathrm{Si\\!-\\!O\\!-\\!Si}}(\\theta)$。在窗口 $[90,120]\\,\\mathrm{deg}$（氧-硅-氧）和 $[120,160]\\,\\mathrm{deg}$（硅-氧-硅）内识别峰值位置。\n- 确定每个硅的 $Q^n$ 值，计算在 $n \\in \\{0,1,2,3,4\\}$ 上的分布，并计算 $\\bar{n}$。计算基准值 $\\bar{n}_{\\mathrm{bench}} = 4 - \\frac{N_{\\mathrm{Na}}}{N_{\\mathrm{Si}}}$。\n- 对每个测试用例，评估上面列出的六个带容差的比较，并生成一个布尔结果，仅当所有比较都满足时才为真。\n\n最终输出格式：\n\n你的程序应生成单行输出，其中包含两个布尔结果，以逗号分隔并用方括号括起来（例如，\"[True,False]\"）。", "solution": "问题陈述已经过严格验证，并被认为是有效的。它构成了材料化学领域一个良构的计算问题，专注于硅酸盐网络的结构分析。该问题要求实现算法，为两种人工生成的原子构型计算标准的结构描述符——偏径向分布函数 ($g_{\\alpha\\beta}(r)$)、角分布函数 ($P(\\theta)$) 和 $Q^n$ 形态分布。构型和基准值是以自洽的方式构建的，因此主要挑战在于正确和精确地实现所需的几何和统计计算，而不是模拟物理现象。\n\n该问题具有科学依据，使用了非晶材料研究中的既定概念和定义。虽然每个测试用例中的原子数量太少，使得计算出的性质不足以在统计上代表块状玻璃，但问题明确将其定义为“人工合成的……分子构型”，这表明它们是作为分析代码的确定性测试平台。因此，该问题是对算法正确性的测试，而非对物理模拟保真度的测试。\n\n问题描述中的某些次要模糊之处需要澄清，以确保得到唯一的、确定性的解。\n1.  **旋转矩阵构建**：问题需要一个旋转 $\\mathbf{R}$ 将矢量 $\\mathbf{a}$ 映射到矢量 $\\mathbf{b}$。假定为最小旋转。这可以通过矢量代数（罗德里格斯旋转公式）或更方便地使用 `scipy.spatial.transform.Rotation` 类来稳健地实现，后者在指定的环境中是允许的。这种方法能正确处理所有几何情况，包括平行和反平行矢量。\n2.  **正交矢量的选择**：第二个测试用例的构建需要选择一个与给定矢量 $\\hat{\\mathbf{u}}$ 正交的单位矢量 $\\hat{\\mathbf{p}}$。为确保确定性过程，必须做出一个规范的选择。选择一个任意的非共线矢量（例如，$(1,0,0)$，如果它与给定矢量共线，则选择$(0,1,0)$），然后计算其与 $\\hat{\\mathbf{u}}$ 的叉积并进行归一化。这样可以得到一个唯一的正交矢量 $\\hat{\\mathbf{p}}$。\n3.  **四舍五入约定**：周期性边界条件的最小镜像约定使用一个 `round()` 函数。Python 的标准数值库通常在处理半整数时会四舍五入到最近的偶数。我们将采用 `numpy.round()` 实现的这一约定。\n\n澄清了这些点后，问题就得到了完全的指定。解决方案首先通过实现函数，根据提供的确定性规则为两个测试用例生成原子坐标。随后，开发一组分析函数来计算结构指标。最后，将这些指标与给定的基准进行评估，以产生所需的布尔输出。\n\n解决方案的结构如下：\n\n1.  **坐标生成**：\n    - 创建一个函数，使用 `scipy.spatial.transform.Rotation.align_vectors` 计算对齐两个矢量的旋转矩阵。\n    - 实现函数 `generate_case1_coords` 和 `generate_case2_coords`。这些函数精确地遵循问题中陈述的几何构造规则，以生成所有硅(Si)、氧(O)和钠(Na)原子的位置。所有角度在使用三角函数前必须从度转换为弧度。\n\n2.  **结构分析**：\n    - 实现一个函数 `minimum_image_distance` 来计算在边长为 $L_{\\mathrm{box}}$ 的周期性边界条件下两个原子之间的距离。位移矢量 $\\Delta\\mathbf{r}$ 通过 $\\Delta\\mathbf{r}' = \\Delta\\mathbf{r} - L_{\\mathrm{box}} \\cdot \\mathrm{round}(\\Delta\\mathbf{r} / L_{\\mathrm{box}})$ 进行校正。\n    - 一个函数 `calculate_rdf` 计算偏径向分布函数 $g_{\\alpha\\beta}(r)$。它系统地遍历所有相关的原子对 $(\\alpha, \\beta)$，计算它们的最小镜像距离，并构建一个直方图。然后根据提供的公式对直方图计数进行归一化：\n      $$g_{\\alpha\\beta}(r) = \\frac{V}{N_\\alpha N_\\beta} \\frac{\\text{count}(r)}{4\\pi r^2 \\Delta r}$$\n      其中 $\\text{count}(r)$ 是在半径为 $r$、厚度为 $\\Delta r$ 的球壳中找到的原子对的数量，$V = L_{\\mathrm{box}}^3$ 是体积，$N_\\alpha$ 和 $N_\\beta$ 分别是物种 $\\alpha$ 和 $\\beta$ 的原子总数。\n    - 一个函数 `calculate_angle_dist` 计算原子三联体（例如 O-Si-O）的角分布。它首先基于截断距离 $r_{\\mathrm{c}}^{\\mathrm{SiO}} = 2.10\\,\\mathrm{\\AA}$ 的邻域搜索来识别所有有效的三联体。对于每个以原子B为中心的三联体（A-B-C），角度是通过矢量 $\\mathbf{r}_{\\mathrm{BA}}$ 和 $\\mathbf{r}_{\\mathrm{BC}}$ 使用点积公式 $\\theta = \\arccos(\\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\| \\|\\mathbf{v}\\|})$ 计算得出的，并生成这些角度的直方图。\n    - 一个函数 `calculate_Qn_spec` 确定 $Q^n$ 形态分布。首先，它通过查找每个氧原子相对于硅的配位数来识别桥氧(BO)和非桥氧(NBO)。配位数为2的氧是BO；配位数为1的氧是NBO。然后，对于每个硅原子，它计算其邻近的氧原子中有多少是桥氧。这个计数就是该硅原子的 $Q^n$ 状态的 $n$ 值。平均 $Q$ 指数 $\\bar{n}$ 是所有硅原子的这些 $n$ 值的平均值。\n\n3.  **评估和输出**：\n    - 一个主处理函数遍历每个测试用例。\n    - 它调用坐标生成和结构分析函数。\n    - 它通过找到相应直方图的最大值，在指定的窗口内找到计算出的RDF和角分布的峰值位置。\n    - 它计算平均 $Q$ 指数 $\\bar{n}$ 及其基准值 $\\bar{n}_{\\mathrm{bench}} = 4 - N_{\\mathrm{Na}}/N_{\\mathrm{Si}}$。\n    - 根据计算出的指标及其各自的基准和容差，评估六个指定的布尔条件。\n    - 当且仅当所有六个条件都满足时，该测试用例的最终结果为 `True`。\n    - 收集两个测试用例的布尔结果，并按要求的格式打印。\n\n这个系统性的步骤确保了问题的所有方面都以科学和数学的严谨性得到处理，从而得出一个可验证且正确的最终答案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\n\ndef solve():\n    # Define shared parameters from the problem statement\n    L_BOX = 30.0\n    R_CUT_SIO = 2.10\n    L_SIO = 1.62\n    L_NAO = 2.35\n    THETA_SIOSI_DEG = 140.0\n    \n    TETRA_DIRS = np.array([\n        [1, 1, 1],\n        [1, -1, -1],\n        [-1, 1, -1],\n        [-1, -1, 1]\n    ]) / np.sqrt(3)\n    D_REF = TETRA_DIRS[0]\n\n    def get_rotation_from_vectors(vec_a, vec_b):\n        \"\"\"Computes rotation matrix to align vec_a with vec_b.\"\"\"\n        # scipy's align_vectors expects arrays of vectors\n        vec_a_norm = vec_a / np.linalg.norm(vec_a)\n        vec_b_norm = vec_b / np.linalg.norm(vec_b)\n        rot, _ = Rotation.align_vectors(vec_b_norm.reshape(1, 3), vec_a_norm.reshape(1, 3))\n        return rot.as_matrix()\n\n    def get_orthogonal_vector(v):\n        \"\"\"Generates a deterministic orthogonal vector to v.\"\"\"\n        v_norm = v / np.linalg.norm(v)\n        # Choose a vector that is not aligned with v\n        if abs(np.dot(v_norm, [1, 0, 0])) > 0.9:\n            axis = [0, 1, 0]\n        else:\n            axis = [1, 0, 0]\n        p = np.cross(v_norm, axis)\n        return p / np.linalg.norm(p)\n\n    def generate_case1_coords():\n        \"\"\"Generates atomic coordinates for Test Case 1.\"\"\"\n        si_coords, o_coords, na_coords = [], [], []\n\n        # Bridging Oxygen\n        o_b = np.array([0.0, 0.0, 0.0])\n        o_coords.append(o_b)\n\n        # Silicon atoms\n        angle_rad = np.deg2rad(THETA_SIOSI_DEG / 2)\n        s1 = L_SIO * np.array([np.cos(angle_rad), np.sin(angle_rad), 0])\n        s2 = L_SIO * np.array([np.cos(-angle_rad), np.sin(-angle_rad), 0])\n        si_coords.extend([s1, s2])\n\n        # NBOs and Na atoms\n        for si in si_coords:\n            t_hat = (o_b - si) / np.linalg.norm(o_b - si)\n            rot_matrix = get_rotation_from_vectors(D_REF, -t_hat)\n            \n            nbo_count = 0\n            for d in TETRA_DIRS:\n                if not np.allclose(d, D_REF):\n                    rotated_d = rot_matrix @ d\n                    o_nbo = si + L_SIO * rotated_d\n                    o_coords.append(o_nbo)\n                    \n                    na_vec = (si - o_nbo) / np.linalg.norm(si - o_nbo)\n                    na = o_nbo - L_NAO * na_vec\n                    na_coords.append(na)\n                    nbo_count += 1\n            assert nbo_count == 3\n\n        return np.array(si_coords), np.array(o_coords), np.array(na_coords)\n\n    def generate_case2_coords():\n        \"\"\"Generates atomic coordinates for Test Case 2.\"\"\"\n        si_coords, o_coords, na_coords = [], [], []\n\n        # First bridge\n        o12 = np.array([0.0, 0.0, 0.0])\n        \n        angle_rad = np.deg2rad(THETA_SIOSI_DEG / 2)\n        s1 = L_SIO * np.array([np.cos(-angle_rad), np.sin(-angle_rad), 0])\n        s2 = L_SIO * np.array([np.cos(angle_rad), np.sin(angle_rad), 0])\n\n        # Second bridge and S3\n        t12_hat_from_s2 = (o12 - s2) / np.linalg.norm(o12 - s2)\n        rot_s2 = get_rotation_from_vectors(D_REF, -t12_hat_from_s2)\n        \n        # Deterministically select the second tetrahedral direction for the next bridge\n        # We need to distinguish TETRA_DIRS[1] from D_REF after rotation\n        t23_hat = rot_s2 @ TETRA_DIRS[1]\n        o23 = s2 + L_SIO * t23_hat\n        \n        u_hat = (s2 - o23) / np.linalg.norm(s2 - o23)\n        p_hat = get_orthogonal_vector(u_hat)\n        w_hat = np.cos(np.deg2rad(THETA_SIOSI_DEG)) * u_hat + np.sin(np.deg2rad(THETA_SIOSI_DEG)) * p_hat\n        s3 = o23 + L_SIO * w_hat\n\n        si_coords.extend([s1, s2, s3])\n        o_coords.extend([o12, o23])\n        \n        # NBOs and Na placement\n        connected_bos = {0: [o12], 1: [o12, o23], 2: [o23]}\n        si_bo_dirs = {\n            0: [(o12 - s1) / np.linalg.norm(o12 - s1)],\n            1: [(o12 - s2) / np.linalg.norm(o12 - s2), (o23 - s2) / np.linalg.norm(o23 - s2)],\n            2: [(o23 - s3) / np.linalg.norm(o23 - s3)]\n        }\n        \n        for i, si in enumerate(si_coords):\n            bo_dirs = si_bo_dirs[i]\n            \n            # Map NBOs away from BOs\n            # For Q2, map d_ref--bo1, d_ref2--bo2\n            if len(bo_dirs) == 1:\n                rot_si = get_rotation_from_vectors(D_REF, -bo_dirs[0])\n                dirs_to_use = [d for d in TETRA_DIRS if not np.allclose(d, D_REF)]\n                for d in dirs_to_use:\n                    rotated_d = rot_si @ d\n                    o_nbo = si + L_SIO * rotated_d\n                    o_coords.append(o_nbo)\n                    na_vec = (si - o_nbo) / np.linalg.norm(si - o_nbo)\n                    na = o_nbo - L_NAO * na_vec\n                    na_coords.append(na)\n\n            elif len(bo_dirs) == 2:\n                rot_si_1 = get_rotation_from_vectors(D_REF, -bo_dirs[0])\n                temp_d2 = rot_si_1 @ TETRA_DIRS[1]\n                rot_si_2 = get_rotation_from_vectors(temp_d2, -bo_dirs[1])\n                rot_si_final = rot_si_2 @ rot_si_1\n                dirs_to_use = [TETRA_DIRS[2], TETRA_DIRS[3]]\n                for d in dirs_to_use:\n                    rotated_d = rot_si_final @ d\n                    o_nbo = si + L_SIO * rotated_d\n                    o_coords.append(o_nbo)\n                    na_vec = (si - o_nbo) / np.linalg.norm(si - o_nbo)\n                    na = o_nbo - L_NAO * na_vec\n                    na_coords.append(na)\n\n        return np.array(si_coords), np.array(o_coords), np.array(na_coords)\n\n    def get_min_image_dist_vec(p1, p2, box_size):\n        delta = p2 - p1\n        delta -= box_size * np.round(delta / box_size)\n        return delta\n\n    def calculate_rdf(coords1, coords2, box_size, r_max, dr):\n        is_same_species = np.array_equal(coords1, coords2)\n        n1, n2 = len(coords1), len(coords2)\n        if n1 == 0 or n2 == 0:\n            return np.zeros(int(r_max / dr)), np.arange(dr / 2, r_max, dr)\n\n        bins = np.arange(0, r_max + dr, dr)\n        hist = np.zeros(len(bins) - 1)\n        \n        for i, p1 in enumerate(coords1):\n            for j, p2 in enumerate(coords2):\n                if is_same_species and i == j:\n                    continue\n                \n                dist_vec = get_min_image_dist_vec(p1, p2, box_size)\n                dist = np.linalg.norm(dist_vec)\n                \n                if dist  r_max:\n                    bin_idx = int(dist / dr)\n                    hist[bin_idx] += 1\n        \n        r = bins[:-1] + dr / 2\n        vol_shell = 4.0 * np.pi * r**2 * dr\n        \n        # Avoid division by zero for r=0\n        vol_shell[vol_shell == 0] = 1.0\n\n        if is_same_species:\n            norm_factor = n1 * (n1 - 1) / box_size**3\n        else:\n            norm_factor = n1 * n2 / box_size**3\n        \n        g_r = hist / (vol_shell * norm_factor)\n        return g_r, r\n\n    def get_peak_position(dist, r_vals, r_min, r_max):\n        mask = (r_vals >= r_min)  (r_vals = r_max)\n        if not np.any(mask): return -1\n        \n        masked_dist = dist[mask]\n        masked_r = r_vals[mask]\n        if len(masked_dist) == 0: return -1\n        \n        peak_idx = np.argmax(masked_dist)\n        return masked_r[peak_idx]\n\n    def calculate_angle_dist(coords_a, coords_b, coords_c, is_abc_triplet, cutoff, d_theta):\n        # Angle a-b-c. Coords for species a, b, c.\n        if len(coords_b) == 0:\n            return np.zeros(int(180 / d_theta)), np.arange(d_theta/2, 180, d_theta)\n\n        bins = np.arange(0, 180 + d_theta, d_theta)\n        hist = np.zeros(len(bins) - 1)\n        \n        for i_b, p_b in enumerate(coords_b):\n            neighbors_a = []\n            for i_a, p_a in enumerate(coords_a):\n                if is_abc_triplet and i_a == i_b: continue\n                if np.linalg.norm(get_min_image_dist_vec(p_b, p_a, L_BOX))  cutoff:\n                    neighbors_a.append(i_a)\n\n            neighbors_c = []\n            for i_c, p_c in enumerate(coords_c):\n                if is_abc_triplet and i_c == i_b: continue\n                if np.linalg.norm(get_min_image_dist_vec(p_b, p_c, L_BOX))  cutoff:\n                    neighbors_c.append(i_c)\n\n            from itertools import combinations\n            a_indices = neighbors_a\n            c_indices = neighbors_c if not is_abc_triplet else neighbors_a\n\n            if is_abc_triplet:\n                indices_pairs = combinations(a_indices, 2)\n            else:\n                indices_pairs = [(na, nc) for na in a_indices for nc in c_indices]\n\n            for idx_a, idx_c in indices_pairs:\n                if idx_a == idx_c: continue\n                \n                vec_ba = get_min_image_dist_vec(p_b, coords_a[idx_a], L_BOX)\n                vec_bc = get_min_image_dist_vec(p_b, coords_c[idx_c], L_BOX)\n                \n                cos_theta = np.dot(vec_ba, vec_bc) / (np.linalg.norm(vec_ba) * np.linalg.norm(vec_bc))\n                cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                theta_deg = np.rad2deg(np.arccos(cos_theta))\n                \n                if theta_deg  180:\n                    bin_idx = int(theta_deg / d_theta)\n                    hist[bin_idx] += 1\n        \n        return hist, bins[:-1] + d_theta/2\n\n    def calculate_qn_spec(si_coords, o_coords, cutoff):\n        if len(si_coords) == 0 or len(o_coords) == 0:\n            return 0.0, {}\n\n        o_si_neighbors = {i: [] for i in range(len(o_coords))}\n        si_o_neighbors = {i: [] for i in range(len(si_coords))}\n\n        for i_si, p_si in enumerate(si_coords):\n            for i_o, p_o in enumerate(o_coords):\n                if np.linalg.norm(get_min_image_dist_vec(p_si, p_o, L_BOX))  cutoff:\n                    o_si_neighbors[i_o].append(i_si)\n                    si_o_neighbors[i_si].append(i_o)\n        \n        bo_indices = set()\n        for i_o, neighbors in o_si_neighbors.items():\n            if len(neighbors) == 2:\n                bo_indices.add(i_o)\n        \n        q_values = []\n        for i_si in range(len(si_coords)):\n            n = 0\n            for i_o in si_o_neighbors[i_si]:\n                if i_o in bo_indices:\n                    n += 1\n            q_values.append(n)\n        \n        avg_n = np.mean(q_values) if q_values else 0.0\n        return avg_n, q_values\n\n    def run_case(coords_generator):\n        si_coords, o_coords, na_coords = coords_generator()\n        n_si, n_o, n_na = len(si_coords), len(o_coords), len(na_coords)\n        dr, d_theta = 0.005, 0.5\n        \n        # 1. RDFs\n        g_sio, r_sio = calculate_rdf(si_coords, o_coords, L_BOX, 6.0, dr)\n        g_oo, r_oo = calculate_rdf(o_coords, o_coords, L_BOX, 6.0, dr)\n        g_nao, r_nao = calculate_rdf(na_coords, o_coords, L_BOX, 6.0, dr)\n\n        r_peak_sio = get_peak_position(g_sio, r_sio, 1.4, 1.9)\n        r_peak_oo = get_peak_position(g_oo, r_oo, 2.2, 3.0)\n        r_peak_nao = get_peak_position(g_nao, r_nao, 2.1, 2.6)\n\n        # 2. Angle distributions\n        p_osio, theta_osio = calculate_angle_dist(o_coords, si_coords, o_coords, True, R_CUT_SIO, d_theta)\n        p_siosi, theta_siosi = calculate_angle_dist(si_coords, o_coords, si_coords, False, R_CUT_SIO, d_theta)\n        \n        theta_peak_osio = get_peak_position(p_osio, theta_osio, 90, 120)\n        theta_peak_siosi = get_peak_position(p_siosi, theta_siosi, 120, 160)\n\n        # 3. Qn speciation\n        n_bar, _ = calculate_qn_spec(si_coords, o_coords, R_CUT_SIO)\n        n_bar_bench = 4.0 - n_na / n_si if n_si > 0 else 0.0\n        \n        # 4. Evaluate conditions\n        cond1 = abs(r_peak_sio - 1.62)  0.05\n        cond2 = abs(r_peak_oo - 2.62)  0.12\n        cond3 = abs(r_peak_nao - 2.35)  0.12\n        cond4 = abs(theta_peak_osio - 109.5)  3.0\n        cond5 = abs(theta_peak_siosi - 140.0)  10.0\n        cond6 = abs(n_bar - n_bar_bench)  0.01\n\n        return all([cond1, cond2, cond3, cond4, cond5, cond6])\n\n    results = []\n    test_cases = [generate_case1_coords, generate_case2_coords]\n    for case_func in test_cases:\n        results.append(run_case(case_func))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2522514"}]}