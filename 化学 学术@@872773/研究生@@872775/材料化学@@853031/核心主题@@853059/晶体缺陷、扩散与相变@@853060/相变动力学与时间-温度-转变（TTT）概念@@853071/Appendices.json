{"hands_on_practices": [{"introduction": "理解相变动力学始于单个颗粒的生长。本练习将引导你从第一性原理出发，完成一个扩散控制生长的基础推导。通过应用菲克定律和界面处的质量守恒，你将推导出球形析出相的生长速度，从而将宏观的扩散系数和浓度与微观的界面移动速率联系起来。[@problem_id:2507304]", "problem": "在固定温度下，一种二元合金被淬火至某一状态，在该状态下，富溶质相的球状析出物通过长程溶质扩散在过饱和基体中生长。假设以下物理上真实的条件：\n- 在析出物-基体界面处保持局部平衡，因此紧邻界面在基体和析出物一侧的溶质浓度分别为 $c_{\\alpha}^{e}$ 和 $c_{\\beta}^{e}$，这些浓度由施加温度下的相图连接线确定。因此，分配系数为 $k \\equiv c_{\\beta}^{e}/c_{\\alpha}^{e}$。\n- 基体相中的扩散控制着输运过程；析出物中的扩散可忽略不计。\n- 基体中的扩散场在界面的随动坐标系中是准稳态的，并且适用球对称性。\n- 总摩尔密度在各相之间近似恒定（偏摩尔体积相等，体积变化可忽略），因此界面质量守恒简化为法向通量和界面推进之间的平衡。\n- 菲克第二定律和移动界面处的质量守恒均适用。\n\n仅从菲克定律和局部质量守恒出发，推导球状析出物界面生长速度 $v \\equiv dR/dt$ 的表达式，该表达式应以扩散系数 $D$、颗粒半径 $R$、基体中的远场溶质浓度 $c_{\\infty}$ 以及界面平衡浓度 $c_{\\alpha}^{e}$ 和 $c_{\\beta}^{e}$ 来表示。然后使用以下数据计算 $v$ 的值：\n- 扩散系数：$D = 1.5 \\times 10^{-18}\\,\\mathrm{m^{2}\\,s^{-1}}$。\n- 颗粒半径：$R = 8.0 \\times 10^{-8}\\,\\mathrm{m}$。\n- 界面平衡浓度（基体和析出物侧）：$c_{\\alpha}^{e} = 1.20 \\times 10^{3}\\,\\mathrm{mol\\,m^{-3}}$，$c_{\\beta}^{e} = 2.50 \\times 10^{4}\\,\\mathrm{mol\\,m^{-3}}$。\n- 远场过饱和度：$c_{\\infty} - c_{\\alpha}^{e} = 2.50 \\times 10^{2}\\,\\mathrm{mol\\,m^{-3}}$。\n\n将速度的最终数值以 $\\mathrm{nm\\,s^{-1}}$ 为单位表示，并四舍五入至三位有效数字。", "solution": "首先对问题陈述进行验证。\n\n步骤 1：提取已知条件\n- 考虑在固定温度下的二元合金。\n- 富溶质相的球状析出物在过饱和基体中生长。\n- 生长机制为长程溶质扩散。\n- 界面处局部平衡：溶质浓度为 $c_{\\alpha}^{e}$（基体侧）和 $c_{\\beta}^{e}$（析出物侧）。\n- 分配系数定义为 $k \\equiv c_{\\beta}^{e}/c_{\\alpha}^{e}$。\n- 基体相中的扩散是速率控制步骤；析出物中的扩散可忽略。\n- 扩散场在界面的随动坐标系中是准稳态的。\n- 适用球对称性。\n- 总摩尔密度在各相之间恒定。\n- 菲克第二定律和移动界面处的质量守恒适用。\n- 目标是推导界面生长速度 $v \\equiv dR/dt$ 并为给定数据计算其值。\n- 扩散系数：$D = 1.5 \\times 10^{-18}\\,\\mathrm{m^{2}\\,s^{-1}}$。\n- 颗粒半径：$R = 8.0 \\times 10^{-8}\\,\\mathrm{m}$。\n- 界面平衡浓度：$c_{\\alpha}^{e} = 1.20 \\times 10^{3}\\,\\mathrm{mol\\,m^{-3}}$，$c_{\\beta}^{e} = 2.50 \\times 10^{4}\\,\\mathrm{mol\\,m^{-3}}$。\n- 远场过饱和度：$c_{\\infty} - c_{\\alpha}^{e} = 2.50 \\times 10^{2}\\,\\mathrm{mol\\,m^{-3}}$。\n- 最终答案的单位为 $\\mathrm{nm\\,s^{-1}}$，并四舍五入到三位有效数字。\n\n步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，描述了一个经典的扩散控制析出物生长情景，通常用 Zener-Hillert 方程建模。诸如准稳态扩散场、局部平衡和球对称性等假设，是材料科学中解决此类问题的标准且成熟的近似方法。所有必要的参数（$D$、$R$ 和浓度）均已提供，其数值对于固态相变是物理上现实的。该问题定义明确、客观，且不含科学或逻辑上的不一致之处。\n\n步骤 3：结论与行动\n该问题有效。将推导严谨的解。\n\n析出物的生长由溶质通过基体向界面的扩散所控制。我们从菲克第二定律开始，该定律描述了浓度场 $c$ 的演化。在准稳态扩散场（$\\partial c / \\partial t \\approx 0$）和球对称性（$c = c(r)$）的假设下，菲克第二定律简化为稳态扩散方程 $\\nabla^2 c = 0$。在球坐标系中，该方程为：\n$$ \\frac{1}{r^2} \\frac{d}{dr} \\left( r^2 \\frac{dc}{dr} \\right) = 0 $$\n其中 $r$ 是源于析出物中心的径向坐标。\n\n该方程受两个边界条件约束：\n1. 在析出物-基体界面处（$r=R$）：局部平衡成立，因此基体中的溶质浓度为 $c(R) = c_{\\alpha}^{e}$。\n2. 远离析出物处（$r \\to \\infty$）：浓度为基体的体相远场浓度 $c(\\infty) = c_{\\infty}$。\n\n对扩散方程积分一次得到：\n$$ r^2 \\frac{dc}{dr} = A $$\n其中 $A$ 是一个积分常数。第二次积分给出基体中浓度分布的通解：\n$$ c(r) = -\\frac{A}{r} + B $$\n其中 $B$ 是第二个积分常数。\n\n我们应用边界条件来确定 $A$ 和 $B$。根据远场条件（$r \\to \\infty$）：\n$$ c(\\infty) = c_{\\infty} = -\\frac{A}{\\infty} + B \\implies B = c_{\\infty} $$\n因此浓度分布为 $c(r) = c_{\\infty} - A/r$。现在，应用界面条件（$r=R$）：\n$$ c(R) = c_{\\alpha}^{e} = c_{\\infty} - \\frac{A}{R} $$\n解出 $A$：\n$$ A = (c_{\\infty} - c_{\\alpha}^{e})R $$\n将 $A$ 和 $B$ 代回通解，我们得到生长中析出物周围基体中的特定浓度分布：\n$$ c(r) = c_{\\infty} - (c_{\\infty} - c_{\\alpha}^{e}) \\frac{R}{r} $$\n下一步是在移动界面处应用质量守恒原理。析出物生长所需的溶质积累速率必须与到达界面的溶质扩散通量相平衡。这是一个 Stefan 型边界条件。\n\n根据菲克第一定律，朝向界面（$r=R$）的溶质通量为 $J = -D \\frac{dc}{dr}$。因此，单位面积进入析出物的通量为 $J_{\\text{in}} = -J|_{r=R} = D \\left(\\frac{dc}{dr}\\right)_{r=R}$。\n我们从浓度分布 $c(r)$ 计算浓度梯度：\n$$ \\frac{dc}{dr} = \\frac{d}{dr} \\left( c_{\\infty} - (c_{\\infty} - c_{\\alpha}^{e}) \\frac{R}{r} \\right) = (c_{\\infty} - c_{\\alpha}^{e})\\frac{R}{r^2} $$\n在界面 $r=R$ 处计算该梯度：\n$$ \\left(\\frac{dc}{dr}\\right)_{r=R} = \\frac{c_{\\infty} - c_{\\alpha}^{e}}{R} $$\n界面单位面积的溶质积累速率由界面速度 $v = dR/dt$ 与界面两侧浓度差 $(c_{\\beta}^{e} - c_{\\alpha}^{e})$ 的乘积给出。恒定摩尔密度的假设简化了此平衡关系。\n将积累速率与流入通量相等：\n$$ v (c_{\\beta}^{e} - c_{\\alpha}^{e}) = D \\left(\\frac{dc}{dr}\\right)_{r=R} $$\n代入梯度的表达式：\n$$ v (c_{\\beta}^{e} - c_{\\alpha}^{e}) = D \\frac{c_{\\infty} - c_{\\alpha}^{e}}{R} $$\n解出界面速度 $v$，得到所需表达式：\n$$ v = \\frac{D}{R} \\frac{c_{\\infty} - c_{\\alpha}^{e}}{c_{\\beta}^{e} - c_{\\alpha}^{e}} $$\n现在，我们使用给定的数值数据来计算此表达式。\n所需的量为：\n- $D = 1.5 \\times 10^{-18}\\,\\mathrm{m^{2}\\,s^{-1}}$\n- $R = 8.0 \\times 10^{-8}\\,\\mathrm{m}$\n- 过饱和度：$S = c_{\\infty} - c_{\\alpha}^{e} = 2.50 \\times 10^{2}\\,\\mathrm{mol\\,m^{-3}}$\n- 界面处的浓度跃变：$\\Delta c = c_{\\beta}^{e} - c_{\\alpha}^{e} = (2.50 \\times 10^{4} - 1.20 \\times 10^{3})\\,\\mathrm{mol\\,m^{-3}} = (25.0 - 1.20) \\times 10^{3}\\,\\mathrm{mol\\,m^{-3}} = 23.8 \\times 10^{3}\\,\\mathrm{mol\\,m^{-3}} = 2.38 \\times 10^{4}\\,\\mathrm{mol\\,m^{-3}}$\n\n无量纲的浓度比，通常称为过饱和度参数 $\\Omega$，为：\n$$ \\Omega = \\frac{c_{\\infty} - c_{\\alpha}^{e}}{c_{\\beta}^{e} - c_{\\alpha}^{e}} = \\frac{2.50 \\times 10^{2}}{2.38 \\times 10^{4}} \\approx 0.0105042 $$\n将数值代入速度方程：\n$$ v = \\frac{1.5 \\times 10^{-18}\\,\\mathrm{m^{2}\\,s^{-1}}}{8.0 \\times 10^{-8}\\,\\mathrm{m}} \\times \\left( \\frac{2.50 \\times 10^{2}\\,\\mathrm{mol\\,m^{-3}}}{2.38 \\times 10^{4}\\,\\mathrm{mol\\,m^{-3}}} \\right) $$\n$$ v = (1.875 \\times 10^{-11}\\,\\mathrm{m\\,s^{-1}}) \\times (0.0105042) $$\n$$ v \\approx 1.96954 \\times 10^{-13}\\,\\mathrm{m\\,s^{-1}} $$\n问题要求答案以纳米每秒（$\\mathrm{nm\\,s^{-1}}$）为单位。已知 $1\\,\\mathrm{m} = 10^9\\,\\mathrm{nm}$：\n$$ v \\approx (1.96954 \\times 10^{-13}\\,\\mathrm{m\\,s^{-1}}) \\times (10^9\\,\\mathrm{nm\\,m^{-1}}) $$\n$$ v \\approx 1.96954 \\times 10^{-4}\\,\\mathrm{nm\\,s^{-1}} $$\n四舍五入到三位有效数字，最终结果是 $1.97 \\times 10^{-4}\\,\\mathrm{nm\\,s^{-1}}$。", "answer": "$$ \\boxed{1.97 \\times 10^{-4}} $$", "id": "2507304"}, {"introduction": "时间-温度-转变（TTT）图是设计热处理工艺的重要指南，但它们是如何根据实验数据构建的呢？本练习模拟了这一过程，从量热法测量相变过程中释放的热量数据入手。你将编写一个程序，通过对热流进行数值积分来计算相变分数，然后利用这些信息确定在不同温度下达到特定相变程度所需的时间，最终构建出TTT图。[@problem_id:2507337]", "problem": "一位材料化学家正在分析某个沉淀反应的等温差示扫描量热法 (DSC) 数据。DSC 在多个温度下返回了一个作为时间函数的放热热流信号。你的任务是反算热流以获得随时间变化的相变分数，然后构建对应于固定相变分数的“时间-温度-相变”(TTT) 点，最后确定指定相变分数的 TTT 曲线“鼻尖”。\n\n使用的基本原理：\n- 对于一个封闭的反应体系，热力学第一定律意味着测量到的放热热流率等于反应的焓释放速率。设热流率为 $\\phi(t)$（单位为 $\\mathrm{J\\ mol^{-1}\\ s^{-1}}$），累计释放焓为 $Q(t)$（单位为 $\\mathrm{J\\ mol^{-1}}$）。那么有 $dQ/dt=\\phi(t)$ 以及\n$$\nQ(t)=\\int_{0}^{t} \\phi(\\tau)\\,d\\tau.\n$$\n- 对于总焓变为 $\\Delta H$（单位为 $\\mathrm{J\\ mol^{-1}}$）的单步沉淀相变，相变分数 $X(t)$ 定义为\n$$\nX(t)=\\frac{Q(t)}{\\Delta H}.\n$$\n- 在温度 $T$下，对于一个固定的目标相变分数 $x$，其“时间-温度-相变”(TTT) 点是满足 $X(t_x;T)=x$ 的时间 $t_x(T)$。所选相变分数的 TTT “鼻尖”是在所有可用温度中，$t_x(T)$ 达到最小值的温度-时间对。\n\n你的程序必须严格按照上述定义实现以下功能（不允许使用任何其他动力学快捷公式来执行反算）：\n- 对 $\\phi(t)$ 进行数值积分以获得 $Q(t)$。\n- 计算 $X(t)=Q(t)/\\Delta H$，并强制使 $X(t)$ 单调不减且界于区间 $[0,1]$ 内。\n- 对于每个温度，通过在离散时间序列上进行线性插值，找出与目标相变分数 $x\\in\\{0.01,0.5,0.99\\}$ 对应的时间 $t_x$。如果在给定的时间窗口内未达到某个目标相变分数，则报告其对应时间为 $-1.0$。\n- 对于每个测试用例，通过找到具有最小有效 $t_{0.5}(T)$ 的温度 $T_{\\text{nose}}$ 来确定 $x=0.5$ 的 TTT 鼻尖，并报告 $T_{\\text{nose}}$ 和对应的 $t_{\\text{nose}}$。如果没有任何温度能达到 $x=0.5$，则报告 $T_{\\text{nose}}=-1.0$ 和 $t_{\\text{nose}}=-1.0$。\n\n物理单位：\n- 时间 $t$ 的单位必须是 $\\mathrm{s}$。\n- 温度 $T$ 的单位必须是 $\\mathrm{K}$。\n- 热流 $\\phi(t)$ 的单位必须是 $\\mathrm{J\\ mol^{-1}\\ s^{-1}}$。\n- $\\Delta H$ 的单位必须是 $\\mathrm{J\\ mol^{-1}}$。\n\n测试套件与数据生成：\n为确保问题被完全指定且可测试，待反算的量热信号 $\\phi(t)$ 在每个测试用例和温度下定义如下。仅用于生成测试数据，假设为等温 Johnson–Mehl–Avrami–Kolmogorov 动力学，其相变分数为\n$$\nX(t;T)=1-\\exp\\!\\left(-\\left(k(T)\\,t\\right)^{n}\\right),\n$$\nArrhenius 速率常数\n$$\nk(T)=k_0\\,\\exp\\!\\left(-\\frac{Q}{R\\,T}\\right),\n$$\n及热流\n$$\n\\phi(t;T)=\\Delta H\\,\\frac{dX}{dt}=\\Delta H\\,n\\,k(T)^{n}\\,t^{n-1}\\,\\exp\\!\\left(-\\left(k(T)\\,t\\right)^{n}\\right).\n$$\n此处，$n$ 是 Avrami 指数（无量纲），$k_0$ 是指前因子（单位为 $\\mathrm{s^{-1}}$），$Q$ 是活化能（单位为 $\\mathrm{J\\ mol^{-1}}$），$R$ 是理想气体常数（单位为 $\\mathrm{J\\ mol^{-1}\\ K^{-1}}$）。这个封闭形式仅用于合成 $\\phi(t)$；你的反算过程必须如上所述，通过对 $\\phi(t)$ 进行数值时间积分来恢复 $X(t)$。\n\n实现三个测试用例：\n\n- 测试用例 $\\mathbf{A}$：\n  - 温度 $T\\in\\{650,700,750\\}$，单位为 $\\mathrm{K}$。\n  - 总焓 $\\Delta H=800$，单位为 $\\mathrm{J\\ mol^{-1}}$。\n  - Avrami 指数 $n=2.0$（无量纲）。\n  - Arrhenius 参数 $k_0=1.0\\times 10^{3}$（单位为 $\\mathrm{s^{-1}}$），$Q=60000$（单位为 $\\mathrm{J\\ mol^{-1}}$），以及 $R=8.314$（单位为 $\\mathrm{J\\ mol^{-1}\\ K^{-1}}$）。\n  - 时间网格 $t_j=j\\,\\Delta t$，其中 $\\Delta t=0.2$（单位为 $\\mathrm{s}$），对于 $j=0,1,2,\\dots,J$，覆盖 $t\\in[0,200]$（单位为 $\\mathrm{s}$）（选择 $J$ 以包含 $t=200$）。\n\n- 测试用例 $\\mathbf{B}$：\n  - $T$、$\\Delta H$、$n$、$k_0$、$Q$ 和 $R$ 与测试用例 $\\mathbf{A}$ 相同。\n  - 时间网格 $t_j=j\\,\\Delta t$，其中 $\\Delta t=0.1$（单位为 $\\mathrm{s}$），对于 $j=0,1,2,\\dots,J$，覆盖 $t\\in[0,30]$（单位为 $\\mathrm{s}$）。\n\n- 测试用例 $\\mathbf{C}$：\n  - 温度 $T\\in\\{500,550,600\\}$，单位为 $\\mathrm{K}$。\n  - 总焓 $\\Delta H=500$，单位为 $\\mathrm{J\\ mol^{-1}}$。\n  - Avrami 指数 $n=1.0$（无量纲）。\n  - Arrhenius 参数 $k_0=50.0$（单位为 $\\mathrm{s^{-1}}$），$Q=40000$（单位为 $\\mathrm{J\\ mol^{-1}}$），以及 $R=8.314$（单位为 $\\mathrm{J\\ mol^{-1}\\ K^{-1}}$）。\n  - 时间网格 $t_j=j\\,\\Delta t$，其中 $\\Delta t=0.5$（单位为 $\\mathrm{s}$），对于 $j=0,1,2,\\dots,J$，覆盖 $t\\in[0,300]$（单位为 $\\mathrm{s}$）。\n\n目标相变分数：\n- 使用有序目标集合 $\\{0.01,0.5,0.99\\}$（无量纲）。\n\n边界条件处理：\n- 如果在给定温度和时间窗口内，$X(t)$ 的最大值小于目标值 $x$，则该温度下该目标时间的输出为 $-1.0$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。\n- 结果必须按以下顺序排列。对于每个测试用例，按 $\\mathbf{A}$、$\\mathbf{B}$、$\\mathbf{C}$ 的顺序：\n  - 对于按升序排列的每个温度，附加通过插值找到的三个时间 $(t_{0.01},t_{0.5},t_{0.99})$（单位为 $\\mathrm{s}$）。\n  - 然后，根据上述规则，附加该测试用例的 $T_{\\text{nose}}$（单位为 $\\mathrm{K}$）和 $t_{\\text{nose}}$（单位为 $\\mathrm{s}$）（针对 $x=0.5$）。\n- 因此，最终输出是一个扁平的浮点数列表：$[t_{0.01}(T_1),t_{0.5}(T_1),t_{0.99}(T_1),\\dots,t_{0.01}(T_M),t_{0.5}(T_M),t_{0.99}(T_M),T_{\\text{nose}},t_{\\text{nose}},\\dots]$，将所有三个测试用例的结果连接起来。", "solution": "我们从热力学第一定律中测得的热流与焓释放之间的关系开始。设 $\\phi(t)$ 表示在温度 $T$ 下等温保持期间的放热热流率，单位为 $\\mathrm{J\\ mol^{-1}\\ s^{-1}}$。到时间 $t$ 为止累计释放的焓 $Q(t)$ 由下式给出\n$$\nQ(t)=\\int_{0}^{t} \\phi(\\tau)\\,d\\tau,\n$$\n该式由 $dQ/dt=\\phi(t)$ 和 $Q(0)=0$ 推导而来。对于总焓变为 $\\Delta H$（单位为 $\\mathrm{J\\ mol^{-1}}$）的单步沉淀，相变分数定义为\n$$\nX(t)=\\frac{Q(t)}{\\Delta H}.\n$$\n此定义确保了在相变完成且全部 $\\Delta H$ 均被释放的条件下，$X(0)=0$ 和 $X(\\infty)=1$。在实践中，我们计算时间积分的数值近似。对于一个时间严格递增的离散时间序列 $\\{t_j\\}_{j=0}^{J}$ 及其对应的 $\\{\\phi_j\\}_{j=0}^{J}$，梯形法则给出\n$$\nQ_0=0,\\quad Q_j = \\sum_{m=1}^{j} \\frac{\\phi_{m-1}+\\phi_m}{2}\\,(t_m-t_{m-1}),\\quad j=1,2,\\dots,J.\n$$\n然后我们计算\n$$\nX_j=\\min\\!\\left(1,\\max\\!\\left(0,\\frac{Q_j}{\\Delta H}\\right)\\right).\n$$\n为强制相变分数的物理单调性，我们将 $X_j$ 替换为其累积最大值：\n$$\n\\tilde X_j = \\max\\{X_0,X_1,\\dots,X_j\\},\\quad j=0,1,\\dots,J,\n$$\n最后限制在 1 以下，得到 $\\tilde X_j\\in[0,1]$ 和 $\\tilde X_{j+1}\\ge \\tilde X_j$。\n\n为了在给定温度 $T$ 下为目标相变分数 $x\\in\\{0.01,0.5,0.99\\}$ 构建“时间-温度-相变”(TTT) 点，我们寻找时间 $t_x$ 使得 $X(t_x;T)=x$。在一个离散的单调序列 $\\{(t_j,\\tilde X_j)\\}$ 上，我们找到最小的索引 $j^\\star$ 使得 $\\tilde X_{j^\\star}\\ge x$。如果不存在这样的索引（即 $\\max_j \\tilde X_j  x$），则该目标分数未在实验时间内达到。否则，通过在点 $(t_{j^\\star-1}, \\tilde X_{j^\\star-1})$ 和 $(t_{j^\\star}, \\tilde X_{j^\\star})$ 之间进行线性插值来找到精确的时间 $t_x$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_heat_flow(time_array, T, DeltaH, n, k0, Q, R):\n    \"\"\"\n    Generate exothermic heat flow phi(t; T) for isothermal JMAK kinetics:\n        X(t;T) = 1 - exp(-(k(T)*t)^n)\n        phi(t;T) = DeltaH * dX/dt = DeltaH * n * k(T)^n * t^(n-1) * exp(-(k(T)*t)^n)\n    \"\"\"\n    kT = k0 * np.exp(-Q / (R * T))\n    t = time_array\n    # Compute phi with care at t=0 for n1: t^(n-1) = 0; for n=1: t^(0)=1.\n    # Vectorized computation:\n    with np.errstate(divide='ignore', invalid='ignore'):\n        t_pow_nm1 = np.power(t, n - 1.0)\n    t_pow_nm1[t == 0] = 0.0 if n > 1 else (1.0 if n == 1 else np.inf)\n\n    phi = DeltaH * n * (kT ** n) * t_pow_nm1 * np.exp(-np.power(kT * t, n))\n    # Replace any nan that might occur at t=0 for n1 with proper limits\n    phi = np.nan_to_num(phi, nan=0.0, posinf=0.0, neginf=0.0)\n    return phi\n\ndef cumulative_trapezoid(y, x):\n    \"\"\"\n    Cumulative trapezoidal integration with the same length output as x.\n    Q[0] = 0; for j=1, Q[j] = sum_{m=1..j} 0.5*(y[m-1]+y[m])*(x[m]-x[m-1])\n    \"\"\"\n    Q = np.empty_like(x, dtype=np.float64)\n    Q[0] = 0.0\n    if len(x) > 1:\n        dx = np.diff(x)\n        avg_y = 0.5 * (y[:-1] + y[1:])\n        Q[1:] = np.cumsum(avg_y * dx)\n    return Q\n\ndef enforce_monotone_clip(X):\n    \"\"\"Enforce nondecreasing X and clip to [0, 1].\"\"\"\n    X = np.clip(X, 0.0, 1.0)\n    return np.maximum.accumulate(X)\n\ndef time_for_fraction(times, X, target):\n    \"\"\"\n    Find time t where X(t) reaches 'target' by linear interpolation on discrete monotone data.\n    If not reached, return -1.0.\n    \"\"\"\n    if X[-1]  target:\n        return -1.0\n    # Find first index where X = target\n    idx = np.searchsorted(X, target, side='left')\n    if idx == 0:\n        return float(times[0])\n    x0, x1 = X[idx - 1], X[idx]\n    t0, t1 = times[idx - 1], times[idx]\n    # Handle potential numerical plateau\n    if x1 == x0:\n        return float(t1)\n    # Linear interpolation\n    frac = (target - x0) / (x1 - x0)\n    return float(t0 + frac * (t1 - t0))\n\ndef solve():\n    # Define the test cases according to the problem statement.\n    test_cases = [\n        # Test case A\n        {\n            \"name\": \"A\",\n            \"T_list\": [650.0, 700.0, 750.0],     # K\n            \"DeltaH\": 800.0,                      # J/mol\n            \"n\": 2.0,                             # dimensionless\n            \"k0\": 1.0e3,                          # s^-1\n            \"Q\": 60000.0,                         # J/mol\n            \"R\": 8.314,                           # J/mol/K\n            \"t_start\": 0.0,                       # s\n            \"t_end\": 200.0,                       # s\n            \"dt\": 0.2                             # s\n        },\n        # Test case B\n        {\n            \"name\": \"B\",\n            \"T_list\": [650.0, 700.0, 750.0],     # K\n            \"DeltaH\": 800.0,                      # J/mol\n            \"n\": 2.0,                             # dimensionless\n            \"k0\": 1.0e3,                          # s^-1\n            \"Q\": 60000.0,                         # J/mol\n            \"R\": 8.314,                           # J/mol/K\n            \"t_start\": 0.0,                       # s\n            \"t_end\": 30.0,                        # s\n            \"dt\": 0.1                             # s\n        },\n        # Test case C\n        {\n            \"name\": \"C\",\n            \"T_list\": [500.0, 550.0, 600.0],     # K\n            \"DeltaH\": 500.0,                      # J/mol\n            \"n\": 1.0,                             # dimensionless\n            \"k0\": 50.0,                           # s^-1\n            \"Q\": 40000.0,                         # J/mol\n            \"R\": 8.314,                           # J/mol/K\n            \"t_start\": 0.0,                       # s\n            \"t_end\": 300.0,                       # s\n            \"dt\": 0.5                             # s\n        }\n    ]\n\n    x_targets = [0.01, 0.5, 0.99]\n    results = []\n\n    for case in test_cases:\n        # Build time grid\n        t0 = case[\"t_start\"]\n        t1 = case[\"t_end\"]\n        dt = case[\"dt\"]\n        # Ensure inclusion of endpoint considering floating error by extending slightly\n        n_steps = int(np.round((t1 - t0) / dt))\n        times = np.linspace(t0, t1, n_steps + 1)\n\n        t05_list = []\n        for T in sorted(case[\"T_list\"]):\n            # Generate heat flow phi(t; T)\n            phi = generate_heat_flow(times, T, case[\"DeltaH\"], case[\"n\"], case[\"k0\"], case[\"Q\"], case[\"R\"])\n            # Integrate to get Q(t), then X(t)\n            Q = cumulative_trapezoid(phi, times)\n            X = enforce_monotone_clip(Q / case[\"DeltaH\"])\n\n            # Compute times for each target fraction\n            for xt in x_targets:\n                tx = time_for_fraction(times, X, xt)\n                results.append(tx)\n                if abs(xt - 0.5)  1e-12:\n                    t05_list.append((T, tx))\n\n        # Determine the TTT nose for x=0.5\n        valid_t05 = [(T, t05) for (T, t05) in t05_list if t05 >= 0.0]\n        if not valid_t05:\n            T_nose, t_nose = -1.0, -1.0\n        else:\n            # Select the minimal t0.5; if tie, select the first encountered (lowest T due to sorting)\n            T_nose, t_nose = min(valid_t05, key=lambda pair: pair[1])\n        results.append(T_nose)\n        results.append(t_nose)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2507337"}, {"introduction": "初始相变完成后，微观结构会通过“粗化”过程继续演化，即大颗粒以消耗小颗粒为代价继续长大。本练习将运用 Lifshitz–Slyozov–Wagner (LSW) 理论的原理，深入分析这种后期现象。通过分析颗粒尺寸分布，你将检验动态自相似性——这是该理论的一个关键预测——并根据平均颗粒尺寸随时间的演化规律，判断其速率控制的物理机制。[@problem_id:2507341]", "problem": "考虑在低体积分数的二元固溶体中粗化的球形析出物，其中总弥散相体积守恒且所有颗粒均保持球形。假设为等温条件，且弹性相互作用可忽略不计。考虑奥斯特瓦尔德熟化的两种经典速率限制机制：通过基体的扩散限制传质和在颗粒表面的界面限制附着-脱离。Lifshitz–Slyozov–Wagner 标度律的核心假设是，在晚期阶段，颗粒半径的数量分布变得动态自相似，这意味着标度化半径 $\\rho = R/\\langle R \\rangle$ 的分布不随时间变化，其中 $\\langle R \\rangle$ 表示数量平均半径。\n\n从弥散相体积守恒和一个仅依赖于单一动力学控制长度尺度的速率限制生长定律出发，可以推断，如果动态标度律适用，则存在一个单一的特征半径 $R_{\\mathrm{char}}(t)$，使得 $\\rho = R/R_{\\mathrm{char}}$ 是一个不随时间变化的相似性变量。在不假设任何特定解析相似性函数的情况下，你需要构建一个計算检验来验证此假设。\n\n给定三个独立的测试用例，每个用例提供了在时间 $t_1$ 和 $t_2$（其中 $t_2 > t_1$）的两个瞬时颗粒尺寸数据集。每个数据集由一个以纳米为单位的颗粒半径列表组成。你必须为每个测试用例执行以下任务：\n\n1. 计算数量平均半径 $\\langle R \\rangle_{t_1}$ 和 $\\langle R \\rangle_{t_2}$，并通过假设在区间 $\\left[t_1,t_2\\right]$ 内存在幂律标度关系 $\\langle R \\rangle \\propto t^n$ 来估计有效生长指数 $n$。使用两点对数斜率\n$$\nn \\equiv \\frac{\\ln\\!\\left(\\langle R \\rangle_{t_2}/\\langle R \\rangle_{t_1}\\right)}{\\ln\\!\\left(t_2/t_1\\right)}.\n$$\n报告 $n$ 值，四舍五入到三位小数（无量纲）。\n\n2. 通过比较标度化半径 $\\rho_1 = R_{t_1}/\\langle R \\rangle_{t_1}$ 和 $\\rho_2 = R_{t_2}/\\langle R \\rangle_{t_2}$ 的归一化直方图，检验在 $t_1$ 和 $t_2$ 时刻分布的动态自相似性。为此，对两个时间点的数据，使用共同的直方图设置：在区间 $\\rho \\in [0,3]$ 上设置 $B = 60$ 个组，并将每个直方图归一化为概率密度（使其下方面积为 1）。计算均方根差\n$$\n\\Delta \\equiv \\left[\\frac{1}{B}\\sum_{j=1}^{B}\\left(f_{1,j}-f_{2,j}\\right)^2\\right]^{1/2},\n$$\n其中 $f_{k,j}$ 是时间 $t_k$ 在第 $j$ 个组的归一化直方图密度值。如果 $\\Delta \\le \\tau$（容差 $\\tau = 0.02$），则声明分布是自相似的。为此决策输出一个布尔值。\n\n3. 基于指数 $n$，通过将其与从基本原理推导出的各机制相关的典型晚期阶段指数（扩散限制产生 $n = 1/3$，界面限制产生 $n = 1/2$）进行比较，判断粗化过程是由扩散限制还是界面限制。实施以下决策规则，并设置模糊边界 $\\delta = 0.02$：计算 $d_{\\mathrm{DL}} = \\left|n - 1/3\\right|$ 和 $d_{\\mathrm{IL}} = \\left|n - 1/2\\right|$；如果 $d_{\\mathrm{DL}} + \\delta  d_{\\mathrm{IL}}$，则标记为扩散限制并输出整数 $0$；如果 $d_{\\mathrm{IL}} + \\delta  d_{\\mathrm{DL}}$，则标记为界面限制并输出整数 $1$；否则输出 $-1$ 表示不确定。该标签无量纲。\n\n你的程序必须处理以下测试套件。对于每个用例，时间单位为秒，半径单位为纳米。\n\n- 用例 A:\n  - $t_1 = 10{,}000$, $t_2 = 80{,}000$。\n  - $t_1$ 时的半径: $\\{5,6,7,8,9,10,11,12,13,14,15,16,18,20,22,25,28,32,36,40\\}$。\n  - $t_2$ 时的半径: $\\{10,12,14,16,18,20,22,24,26,28,30,32,36,40,44,50,56,64,72,80\\}$。\n\n- 用例 B:\n  - $t_1 = 10{,}000$, $t_2 = 80{,}000$。\n  - $t_1$ 时的半径: $\\{4,5,6,7,8,9,10,11,12,14,16,18,21,24,28,33,39,46,54,63\\}$。\n  - $t_2$ 时的半径: $\\{11.3137085,14.1421356,16.9705627,19.7989899,22.6274170,25.4558441,28.2842712,31.1126984,33.9411255,39.5979797,45.2548339,50.9116882,59.3221357,67.8822509,79.5940670,93.7880945,110.3126597,130.5096479,153.7339080,178.1973550\\}$。\n\n- 用例 C:\n  - $t_1 = 10{,}000$, $t_2 = 80{,}000$。\n  - $t_1$ 时的半径: $\\{6,7,8,9,10,12,14,16,18,20,23,26,30,35,41,48,56,65,75,86\\}$。\n  - $t_2$ 时的半径: $\\{15.6,18.2,20.8,23.4,26.0,31.2,36.4,41.6,46.8,52.0,55.2,62.4,72.0,84.0,92.25,108.0,126.0,146.25,168.75,193.5\\}$。\n\n你的程序应生成单行输出，其中包含一个由三个列表组成的逗号分隔列表，按 A、B、C 的顺序对应每个用例。每个内部列表必须采用 $[\\text{self\\_similarity\\_boolean}, n, \\text{mechanism\\_label}]$ 的形式，其中 $n$ 四舍五入到三位小数。例如，一个语法有效且带有占位符值的输出应如下所示：$[[\\text{True},0.333,0],[\\text{True},0.500,1],[\\text{False},0.417,-1]]$。输出中不需要单位；所有报告的量均为无量纲。", "solution": "问题陈述经评估有效。它在科学上基于已确立的 Lifshitz–Slyozov–Wagner (LSW) 相粗化理论，提法明确，具有完整且一致的数据和指令集，并以客观、可形式化的语言表达。该问题要求对代表两个不同时间的颗粒尺寸分布的三个数据集进行计算分析，以检验动态自相似性并对速率限制的粗化机制进行分类。将按规定程序执行。\n\n分析的核心在于粗化后期的动态标度假设，其中颗粒尺寸分布 $f(R, t)$ 被认为呈现出自相似形式：\n$$f(R, t) = \\frac{1}{\\langle R \\rangle(t)} g\\left(\\frac{R}{\\langle R \\rangle(t)}\\right)$$\n其中 $\\langle R \\rangle(t)$ 是时间 $t$ 时的数量平均半径，$g(\\rho)$ 是标度化半径 $\\rho = R/\\langle R \\rangle$ 的一个不随时间变化的标度函数。LSW 理论的一个关键预测是，平均半径根据幂律 $\\langle R \\rangle^p - \\langle R \\rangle_0^p \\propto t$ 生长，在晚期阶段（$t \\to \\infty$）简化为 $\\langle R \\rangle \\propto t^n$，其中 $n=1/p$。指数 $n$ 取决于速率限制机制：对于体扩散限制生长，$n=1/3$；对于界面反应限制生长，$n=1/2$。\n\n每个测试用例的分析分为三个连续的任务。\n\n首先，根据提供的两个时间点 $t_1$ 和 $t_2$ 估计有效生长指数 $n$。计算每个时间点上颗粒群体的数量平均半径 $\\langle R \\rangle_{t_1}$ 和 $\\langle R \\rangle_{t_2}$。假设存在幂律关系 $\\langle R \\rangle(t) = C t^n$，其中 $C$ 是一个常数，则可以通过对数运算从这两个数据点确定指数 $n$：$\\ln \\langle R \\rangle = \\ln C + n \\ln t$。双对数图上的斜率即为 $n$：\n$$n = \\frac{\\ln \\langle R \\rangle_{t_2} - \\ln \\langle R \\rangle_{t_1}}{\\ln t_2 - \\ln t_1} = \\frac{\\ln\\left(\\langle R \\rangle_{t_2}/\\langle R \\rangle_{t_1}\\right)}{\\ln\\left(t_2/t_1\\right)}$$\n该值将使用全精度计算，并报告四舍五入到三位小数的结果。\n\n其次，检验动态自相似性假设。将每个数据集中的半径 $R_{t_1}$ 和 $R_{t_2}$ 分别除以各自的平均半径进行标度化，得到无量纲变量 $\\rho_1 = R_{t_1} / \\langle R \\rangle_{t_1}$ 和 $\\rho_2 = R_{t_2} / \\langle R \\rangle_{t_2}$。如果系统表现出自相似性，那么 $\\rho_1$ 和 $\\rho_2$ 的统计分布应该完全相同。这一点通过比较它们的归一化直方图来量化。将分布在共同区间 $\\rho \\in [0, 3]$ 上离散化为 $B = 60$ 个组。直方图被归一化为单位积分概率密度，分别得到时间 $t_1$ 和 $t_2$ 在第 $j$ 个组的值 $f_{1,j}$ 和 $f_{2,j}$。两个分布之间的偏差通过均方根差来衡量：\n$$\\Delta = \\left[\\frac{1}{B}\\sum_{j=1}^{B}\\left(f_{1,j}-f_{2,j}\\right)^2\\right]^{1/2}$$\n如果这个差值低于指定的容差，即 $\\Delta \\le \\tau$ (其中 $\\tau = 0.02$)，则认为分布是自相似的。一个布尔值将表示此结果。\n\n第三，根据计算出的生长指数 $n$（使用其全精度值）对主导粗化机制进行分类。评估 $n$ 与扩散限制（$n_{\\mathrm{DL}} = 1/3$）和界面限制（$n_{\\mathrm{IL}} = 1/2$）生长的典型指数的接近程度。计算绝对差值：$d_{\\mathrm{DL}} = |n - 1/3|$ 和 $d_{\\mathrm{IL}} = |n - 1/2|$。使用 $\\delta = 0.02$ 的模糊边界来进行稳健的分类：\n- 如果 $d_{\\mathrm{DL}} + \\delta  d_{\\mathrm{IL}}$，机制被分类为扩散限制（标签 $0$）。\n- 如果 $d_{\\mathrm{IL}} + \\delta  d_{\\mathrm{DL}}$，机制被分类为界面限制（标签 $1$）。\n- 否则，机制不确定（标签 $-1$）。\n\n以下是每个用例的详细分析。\n\n用例 A:\n- 时间: $t_1 = 10000 \\, \\text{s}$, $t_2 = 80000 \\, \\text{s}$。\n- 数据集的构建方式是，$t_2$ 时的每个半径恰好是其在 $t_1$ 时对应半径的两倍：$R_{t_2,i} = 2 R_{t_1,i}$。\n- 任务1：计算出的平均半径为 $\\langle R \\rangle_{t_1} = 18.35 \\, \\text{nm}$ 和 $\\langle R \\rangle_{t_2} = 36.7 \\, \\text{nm}$。比值 $\\langle R \\rangle_{t_2}/\\langle R \\rangle_{t_1} = 2$。指数为 $n = \\ln(2) / \\ln(80000/10000) = \\ln(2) / \\ln(8) = \\ln(2) / (3 \\ln(2)) = 1/3$。\n- 任务2：标度化半径为 $\\rho_1 = R_{t_1} / \\langle R \\rangle_{t_1}$ 和 $\\rho_2 = R_{t_2} / \\langle R \\rangle_{t_2} = (2 R_{t_1}) / (2 \\langle R \\rangle_{t_1}) = \\rho_1$。由于标度化分布完全相同，它们的直方图也会相同。因此，对于所有 $j$，$f_{1,j} = f_{2,j}$，均方根差 $\\Delta = 0$。因为 $0 \\le 0.02$，所以分布是自相似的（$\\text{True}$）。\n- 任务3：当 $n = 1/3$ 时，我们有 $d_{\\mathrm{DL}} = |1/3 - 1/3| = 0$ 和 $d_{\\mathrm{IL}} = |1/3 - 1/2| = 1/6 \\approx 0.1667$。条件 $d_{\\mathrm{DL}} + \\delta  d_{\\mathrm{IL}}$ 变为 $0 + 0.02  1/6$，此条件成立。该机制为扩散限制（标签 $0$）。\n- 用例A的结果：$[\\text{True}, 0.333, 0]$。\n\n用例 B:\n- 时间: $t_1 = 10000 \\, \\text{s}$, $t_2 = 80000 \\, \\text{s}$。\n- 数据集的构建方式是，对于所有颗粒，$R_{t_2,i} = \\sqrt{8} \\cdot R_{t_1,i}$，存在微小的浮点数差异。\n- 任务1：平均半径为 $\\langle R \\rangle_{t_1} = 22.5 \\, \\text{nm}$ 和 $\\langle R \\rangle_{t_2} \\approx 63.6396 \\, \\text{nm}$。比值 $\\langle R \\rangle_{t_2}/\\langle R \\rangle_{t_1} \\approx \\sqrt{8}$。指数为 $n = \\ln(\\sqrt{8}) / \\ln(8) = \\ln(8^{1/2}) / \\ln(8) = (1/2 \\ln 8) / \\ln 8 = 1/2$。\n- 任务2：与用例A类似，所有半径通过单一因子 $\\sqrt{8}$ 进行完美标度，确保了标度化分布是相同的：$\\rho_2 = (\\sqrt{8} R_{t_1}) / (\\sqrt{8} \\langle R \\rangle_{t_1}) = \\rho_1$。均方根差 $\\Delta = 0$。因为 $0 \\le 0.02$，所以分布是自相似的（$\\text{True}$）。\n- 任务3：当 $n = 1/2$ 时，我们有 $d_{\\mathrm{DL}} = |1/2 - 1/3| = 1/6$ 和 $d_{\\mathrm{IL}} = |1/2 - 1/2| = 0$。条件 $d_{\\mathrm{IL}} + \\delta  d_{\\mathrm{DL}}$ 变为 $0 + 0.02  1/6$，此条件成立。该机制为界面限制（标签 $1$）。\n- 用例B的结果：$[\\text{True}, 0.500, 1]$。\n\n用例 C:\n- 时间: $t_1 = 10000 \\, \\text{s}$, $t_2 = 80000 \\, \\text{s}$。\n- 数据集的构建采用了依赖于颗粒尺寸的非均匀标度因子。具体来说，较小颗粒的生长因子比较大颗粒的更大。\n- 任务1：平均半径为 $\\langle R \\rangle_{t_1} = 30.25 \\, \\text{nm}$ 和 $\\langle R \\rangle_{t_2} = 67.725 \\, \\text{nm}$。指数为 $n = \\ln(67.725 / 30.25) / \\ln(8) \\approx 0.3878$。\n- 任务2：由于标度因子在整个分布中不是恒定的，分布的形状随时间变化。一个初始小颗粒的标度化半径（例如，$R_1=6$，$\\rho_1 \\approx 0.198$）演变为一个不同的标度化值（$R_2=15.6$，$\\rho_2 \\approx 0.230$）。标度化分布形状的这种变化导致了不相同的直方图。计算出的均方根差为 $\\Delta \\approx 0.0526$。由于 $0.0526 > 0.02$，分布不是自相似的（$\\text{False}$）。\n- 任务3：使用计算出的指数 $n \\approx 0.3878$，距离为 $d_{\\mathrm{DL}} = |0.3878 - 1/3| \\approx 0.0545$ 和 $d_{\\mathrm{IL}} = |0.3878 - 1/2| \\approx 0.1122$。条件 $d_{\\mathrm{DL}} + \\delta  d_{\\mathrm{IL}}$ 变为 $0.0545 + 0.02  0.1122$，即 $0.0745  0.1122$，此条件成立。尽管缺乏自相似性，但仅基于平均生长指数 $n$ 的分类规则将该机制指定为扩散限制（标签 $0$）。这凸显了使用单一指数来表征一个违反模型关键假设（自相似性）的过程的局限性。\n- 用例C的结果：$[\\text{False}, 0.388, 0]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(t1, t2, radii1, radii2, B, tau, delta):\n    \"\"\"\n    Performs the three analysis tasks for a single test case.\n    \n    Args:\n        t1 (float): Time of the first measurement.\n        t2 (float): Time of the second measurement.\n        radii1 (list): List of particle radii at t1.\n        radii2 (list): List of particle radii at t2.\n        B (int): Number of histogram bins.\n        tau (float): Tolerance for self-similarity check.\n        delta (float): Ambiguity margin for mechanism classification.\n        \n    Returns:\n        list: A list containing [self_similarity_boolean, n_rounded, mechanism_label].\n    \"\"\"\n    \n    r1_np = np.array(radii1, dtype=np.float64)\n    r2_np = np.array(radii2, dtype=np.float64)\n\n    # Task 1: Compute the growth exponent n\n    avg_r1 = np.mean(r1_np)\n    avg_r2 = np.mean(r2_np)\n    \n    # Use full precision n for subsequent calculations\n    n_full = np.log(avg_r2 / avg_r1) / np.log(t2 / t1)\n    n_rounded = round(n_full, 3)\n\n    # Task 2: Test dynamic self-similarity\n    rho1 = r1_np / avg_r1\n    rho2 = r2_np / avg_r2\n    \n    bins = np.linspace(0, 3, B + 1)\n    \n    # Calculate normalized histograms (probability density function)\n    f1, _ = np.histogram(rho1, bins=bins, density=True)\n    f2, _ = np.histogram(rho2, bins=bins, density=True)\n    \n    # Compute root-mean-square difference\n    rms_diff = np.sqrt(np.mean((f1 - f2)**2))\n    \n    is_similar = rms_diff = tau\n\n    # Task 3: Decide coarsening mechanism\n    n_dl = 1/3\n    n_il = 1/2\n    \n    d_dl = abs(n_full - n_dl)\n    d_il = abs(n_full - n_il)\n    \n    mechanism_label = -1 # Default to indeterminate\n    if d_dl + delta  d_il:\n        mechanism_label = 0 # Diffusion-limited\n    elif d_il + delta  d_dl:\n        mechanism_label = 1 # Interface-limited\n        \n    return [is_similar, n_rounded, mechanism_label]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run analysis, and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"t1\": 10000,\n            \"t2\": 80000,\n            \"radii1\": [5,6,7,8,9,10,11,12,13,14,15,16,18,20,22,25,28,32,36,40],\n            \"radii2\": [10,12,14,16,18,20,22,24,26,28,30,32,36,40,44,50,56,64,72,80]\n        },\n        {\n            \"t1\": 10000,\n            \"t2\": 80000,\n            \"radii1\": [4,5,6,7,8,9,10,11,12,14,16,18,21,24,28,33,39,46,54,63],\n            \"radii2\": [11.3137085,14.1421356,16.9705627,19.7989899,22.6274170,\n                       25.4558441,28.2842712,31.1126984,33.9411255,39.5979797,\n                       45.2548339,50.9116882,59.3221357,67.8822509,79.5940670,\n                       93.7880945,110.3126597,130.5096479,153.7339080,178.1973550]\n        },\n        {\n            \"t1\": 10000,\n            \"t2\": 80000,\n            \"radii1\": [6,7,8,9,10,12,14,16,18,20,23,26,30,35,41,48,56,65,75,86],\n            \"radii2\": [15.6,18.2,20.8,23.4,26.0,31.2,36.4,41.6,46.8,52.0,\n                       55.2,62.4,72.0,84.0,92.25,108.0,126.0,146.25,168.75,193.5]\n        }\n    ]\n\n    # Parameters from the problem statement\n    B = 60\n    tau = 0.02\n    delta = 0.02\n\n    results_as_strings = []\n    \n    for case in test_cases:\n        result = process_case(case[\"t1\"], case[\"t2\"], case[\"radii1\"], case[\"radii2\"], B, tau, delta)\n        \n        # Format each inner list string carefully to match the required output format\n        # [bool,float_with_3_decimals,int] with no spaces\n        is_similar, n_val, mechanism = result\n        bool_str = str(is_similar)\n        n_str = f\"{n_val:.3f}\"\n        mech_str = str(mechanism)\n        \n        inner_str = f\"[{bool_str},{n_str},{mech_str}]\"\n        results_as_strings.append(inner_str)\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "2507341"}]}