{"hands_on_practices": [{"introduction": "理论是实践的基石。在深入研究复杂的真实材料之前，通过一个简化的模型来掌握能带结构的核心概念至关重要。本练习 [@problem_id:2484916] 将引导你使用紧束缚近似，为一个一维双原子链推导能带色散关系，从而亲手揭示能带和带隙是如何从原子轨道的相互作用中产生的。", "problem": "考虑一个一维双原子链，其晶胞基元包含两个原子，分别为 A 和 B，其在位能分别为 $\\epsilon_{A}$ 和 $\\epsilon_{B}$。设晶格常数为 $a$（等效 A 位点之间的距离），在每个晶胞内，将 A 原子置于位置 $x=0$，B 原子置于位置 $x=a/2$。假设采用最近邻紧束缚模型，仅在不同类近邻原子（A 到 B）之间存在跃迁积分 $t$，并忽略任何重叠积分以及任何相同子晶格上的跃迁。使用布洛赫定理和紧束缚近似作为基本框架，在 $\\{A,B\\}$ 基下构建 $2\\times 2$ 的布洛赫哈密顿量，推导双能带色散关系 $E_{\\pm}(k)$，并根据 $\\epsilon_{A}-\\epsilon_{B}$ 和 $t$ 的函数关系，判断基带隙是直接带隙还是间接带隙。明确指出价带顶和导带底出现的晶体动量值。\n\n将您的最终答案以一个有序对的形式报告，该有序对包含基带隙 $E_{g}$ 的解析表达式以及此带隙出现时的一个晶体动量 $k_{g}$（用 $a$ 表示），写为 $(E_{g},\\,k_{g})$。不需要进行数值计算或四舍五入。", "solution": "所述问题是有效的。这是一个来自固态物理学的、提法恰当、有科学依据的问题，没有矛盾或歧义。下面是解的推导过程。\n\n该体系是一个晶格常数为 $a$ 的一维双原子链。每个晶胞（由整数 $n$ 索引）包含两个原子 A 和 B。格点的位置由 $R_n = na$ 给出。A 原子位于位置 $na$，B 原子位于位置 $na + a/2$。在位能为 $\\epsilon_A$ 和 $\\epsilon_B$，不同类原子间的最近邻跃迁积分为 $t$。我们忽略相同子晶格上的跃迁和重叠积分。\n\n我们使用紧束缚近似来构建解。晶体波函数 $\\Psi_k(x)$ 是由 A 和 B 原子的原子轨道构成的布洛赫和的线性组合。设 $|\\phi_{A,n}\\rangle$ 和 $|\\phi_{B,n}\\rangle$ 分别为第 $n$ 个晶胞中 A 原子和 B 原子的原子轨道。相应的布洛赫基矢为：\n$$ |\\psi_{A,k}\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{n} \\exp(ikna) |\\phi_{A,n}\\rangle $$\n$$ |\\psi_{B,k}\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{n} \\exp(ikna) |\\phi_{B,n}\\rangle $$\n其中 $N$ 是晶胞数，$k$ 是晶体动量。对于给定的 $k$，波函数可以写为 $\\Psi_k = c_A |\\psi_{A,k}\\rangle + c_B |\\psi_{B,k}\\rangle$。问题简化为此基下 $2 \\times 2$ 布洛赫哈密顿量 $H(k)$ 的本征值方程求解：\n$$ H(k) \\begin{pmatrix} c_A \\\\ c_B \\end{pmatrix} = E(k) \\begin{pmatrix} c_A \\\\ c_B \\end{pmatrix} $$\n$H(k)$ 的矩阵元为 $H_{ij}(k) = \\langle \\psi_{i,k} | H | \\psi_{j,k} \\rangle$，其中 $i, j \\in \\{A, B\\}$。\n\n对角元代表在位能，受任何同子晶格跃迁的修正。由于忽略了同子晶格跃迁，这些对角元就是简单的在位能。\n$H_{AA}(k) = \\langle \\psi_{A,k} | H | \\psi_{A,k} \\rangle = \\frac{1}{N} \\sum_{n,m} \\exp(ik(m-n)a) \\langle \\phi_{A,n} | H | \\phi_{A,m} \\rangle$。\n哈密顿算符 $H$ 仅将一个轨道与其自身（在位能）或其最近邻（跃迁）连接。因此，$\\langle \\phi_{A,n} | H | \\phi_{A,m} \\rangle = \\epsilon_A \\delta_{nm}$。\n$$ H_{AA}(k) = \\frac{1}{N} \\sum_{n} \\exp(0) \\epsilon_A = \\epsilon_A $$\n类似地，\n$$ H_{BB}(k) = \\epsilon_B $$\n\n非对角元代表子晶格之间的跃迁。\n$H_{AB}(k) = \\langle \\psi_{A,k} | H | \\psi_{B,k} \\rangle = \\frac{1}{N} \\sum_{n,m} \\exp(ik(m-n)a) \\langle \\phi_{A,n} | H | \\phi_{B,m} \\rangle$。\n在晶胞 $n$ 中（位置 $na$）的 A 原子有两个 B 类最近邻：一个在同一晶胞 $n$ 中（位置 $na+a/2$）的 B 原子，以及一个在前一个晶胞 $n-1$ 中（位置 $(n-1)a+a/2 = na-a/2$）的 B 原子。因此，对于给定在位点 $n$ 的 A 原子，跃迁项 $\\langle \\phi_{A,n} | H | \\phi_{B,m} \\rangle$ 仅在 $m=n$ 和 $m=n-1$ 时非零。在这两种情况下，其值均为跃迁积分 $t$。\n对 $m$ 的求和简化为两项：\n$$ H_{AB}(k) = \\frac{1}{N} \\sum_{n} \\left( \\exp(ik(n-n)a) \\langle \\phi_{A,n} | H | \\phi_{B,n} \\rangle + \\exp(ik((n-1)-n)a) \\langle \\phi_{A,n} | H | \\phi_{B,n-1} \\rangle \\right) $$\n$$ H_{AB}(k) = \\frac{1}{N} \\sum_{n} \\left( t + t\\exp(-ika) \\right) = t(1 + \\exp(-ika)) $$\n由于哈密顿量是厄米共轭的，$H_{BA}(k) = (H_{AB}(k))^*$。\n$$ H_{BA}(k) = t^*(1 + \\exp(ika)) $$\n假设跃迁积分 $t$ 是一个实数参数，$t^*=t$。\n$$ H_{BA}(k) = t(1 + \\exp(ika)) $$\n\n布洛赫哈密顿矩阵为：\n$$ H(k) = \\begin{pmatrix} \\epsilon_A & t(1+\\exp(-ika)) \\\\ t(1+\\exp(ika)) & \\epsilon_B \\end{pmatrix} $$\n为求能量本征值 $E(k)$，我们求解久期方程 $\\det(H(k) - E I) = 0$：\n$$ (\\epsilon_A - E)(\\epsilon_B - E) - |t(1+\\exp(-ika))|^2 = 0 $$\n非对角项的平方为：\n$|t(1+\\exp(-ika))|^2 = t^2 (1+\\exp(-ika))(1+\\exp(ika)) = t^2(1 + \\exp(ika) + \\exp(-ika) + 1) = t^2(2 + 2\\cos(ka)) = 4t^2\\cos^2(ka/2)$。\n久期方程变为：\n$$ E^2 - (\\epsilon_A + \\epsilon_B)E + \\epsilon_A \\epsilon_B - 4t^2\\cos^2(ka/2) = 0 $$\n求解这个关于 $E$ 的二次方程，得到两个能带，$E_+(k)$（导带）和 $E_-(k)$（价带）：\n$$ E_{\\pm}(k) = \\frac{\\epsilon_A + \\epsilon_B \\pm \\sqrt{(\\epsilon_A + \\epsilon_B)^2 - 4(\\epsilon_A\\epsilon_B - 4t^2\\cos^2(ka/2))}}{2} $$\n$$ E_{\\pm}(k) = \\frac{\\epsilon_A + \\epsilon_B}{2} \\pm \\frac{1}{2}\\sqrt{(\\epsilon_A - \\epsilon_B)^2 + 16t^2\\cos^2(ka/2)} $$\n\n为了确定基带隙，我们必须找到价带的最大值 $E_{VBM}$ 和导带的最小值 $E_{CBM}$。这些极值出现在 $dE/dk=0$ 的点，即第一布里渊区的高对称点（$k=0$ 和 $k=\\pm \\pi/a$）。\n色散关系的 $k$ 依赖性完全包含在 $\\cos^2(ka/2)$ 项中。\n价带为 $E_-(k) = \\frac{\\epsilon_A + \\epsilon_B}{2} - \\frac{1}{2}\\sqrt{(\\epsilon_A - \\epsilon_B)^2 + 16t^2\\cos^2(ka/2)}$。为了使 $E_-(k)$ 最大化，我们必须最小化从常数平均能量中减去的正项。这意味着我们必须最小化平方根项，这又意味着最小化 $\\cos^2(ka/2)$。$\\cos^2(ka/2)$ 的最小值为 $0$，出现在第一布里渊区的边界，即 $k = \\pm \\pi/a$。\n因此，价带顶 (VBM) 位于 $k_{VBM} = \\pm \\pi/a$。\n$$ E_{VBM} = E_-(\\pm\\pi/a) = \\frac{\\epsilon_A + \\epsilon_B}{2} - \\frac{1}{2}\\sqrt{(\\epsilon_A - \\epsilon_B)^2} = \\frac{\\epsilon_A + \\epsilon_B}{2} - \\frac{1}{2}|\\epsilon_A - \\epsilon_B| = \\min(\\epsilon_A, \\epsilon_B) $$\n\n导带为 $E_+(k) = \\frac{\\epsilon_A + \\epsilon_B}{2} + \\frac{1}{2}\\sqrt{(\\epsilon_A - \\epsilon_B)^2 + 16t^2\\cos^2(ka/2)}$。为了使 $E_+(k)$ 最小化，我们必须最小化加到常数平均能量上的正项。同样，这需要最小化 $\\cos^2(ka/2)$，这发生在 $k = \\pm \\pi/a$。\n因此，导带底 (CBM) 位于 $k_{CBM} = \\pm \\pi/a$。\n$$ E_{CBM} = E_+(\\pm\\pi/a) = \\frac{\\epsilon_A + \\epsilon_B}{2} + \\frac{1}{2}\\sqrt{(\\epsilon_A - \\epsilon_B)^2} = \\frac{\\epsilon_A + \\epsilon_B}{2} + \\frac{1}{2}|\\epsilon_A - \\epsilon_B| = \\max(\\epsilon_A, \\epsilon_B) $$\n\n由于价带顶和导带底都出现在相同的晶体动量（$k = \\pm \\pi/a$）处，因此基带隙是直接带隙。对于任何非零的 $t$ 值和任何 $\\epsilon_A, \\epsilon_B$ 值，此结论均成立。\n\n基带隙 $E_g$ 是导带底和价带顶之差：\n$$ E_g = E_{CBM} - E_{VBM} = \\max(\\epsilon_A, \\epsilon_B) - \\min(\\epsilon_A, \\epsilon_B) = |\\epsilon_A - \\epsilon_B| $$\n这个直接带隙出现在晶体动量 $k_g = \\pm \\pi/a$ 处。问题要求给出一个这样的动量值。我们选择 $k_g = \\pi/a$。\n\n最终答案是有序对 $(E_g, k_g)$。", "answer": "$$ \\boxed{ \\begin{pmatrix} |\\epsilon_A - \\epsilon_B| & \\frac{\\pi}{a} \\end{pmatrix} } $$", "id": "2484916"}, {"introduction": "能带的形状，特别是带边（导带底和价带顶）的曲率，决定了载流子的行为。这个曲率通过有效质量张量来量化，这是一个描述电子或空穴在晶体中运动难易程度的关键参数。本计算练习 [@problem_id:2484981] 将让你从给定的数值能带色散数据出发，通过二次拟合来计算主有效质量，这模拟了分析第一性原理计算结果以提取材料关键参数的常见工作流程。", "problem": "给定一个导带底附近的数值电子色散关系族，对于足够小的波矢量大小，该色散关系可以用一个各向异性抛物线能带和一个可选的弱非抛物线修正来建模。假定三维色散关系遵循以下基本关系：\n\n- 有效质量张量 $\\mathbf{M}$ 由能带边能量 $E(\\mathbf{k})$ 的曲率定义，通过\n$$\n\\left(\\mathbf{M}^{-1}\\right)_{ij} = \\frac{1}{\\hbar^2}\\,\\frac{\\partial^2 E}{\\partial k_i \\partial k_j}\\bigg|_{\\mathbf{k}=\\mathbf{0}},\n$$\n其中 $\\hbar$ 是约化普朗克常数，$i,j \\in \\{x,y,z\\}$，$\\mathbf{k}$ 是以逆长度为单位测量的晶体动量。\n\n- 在最小值附近，色散关系可以展开为\n$$\nE(\\mathbf{k}) \\approx E_0 + \\frac{\\hbar^2}{2}\\,\\mathbf{k}^{\\mathsf{T}}\\,\\mathbf{M}^{-1}\\,\\mathbf{k} + \\beta \\|\\mathbf{k}\\|^4,\n$$\n其中 $E_0$ 是一个恒定的能量偏移，二次项编码了有效质量张量，而 $\\beta \\ge 0$ 是一个小的非抛物线性系数。除非另有说明，所有能量必须以电子伏特处理，波矢量以米分之一处理，质量以千克处理。\n\n沿给定对称方向集的主有效质量将通过对一维切片 $E(t\\,\\hat{\\mathbf{u}})$进行二次拟合来获得，其中 $t$ 是沿单位方向 $\\hat{\\mathbf{u}}$ 的标量波数。如果在给定的方向集上，质量在指定的相对容差内相等，则认为旋转不变性有效。\n\n你的任务是编写一个完整的程序，为下面指定的每个测试用例执行以下操作：\n\n1. 对于每个为提取质量而提供的单位方向 $\\hat{\\mathbf{u}}$，在围绕 $t=0$ 对称分布的几个小的 $t$ 值处对 $E(t\\,\\hat{\\mathbf{u}})$ 进行采样。使用关于标量变量 $t$ 的最小二乘二次拟合（包括一个常数项）来估计该方向上的曲率。根据该曲率和上述基本定义，推导出相应的方向有效质量。沿 $\\hat{\\mathbf{u}}$ 的方向质量是通过将一维展开 $E(t\\,\\hat{\\mathbf{u}}) \\approx E_0 + \\frac{\\hbar^2}{2\\,m_{\\hat{\\mathbf{u}}}} t^2$ 与从张量定义和曲率拟合中获得的主导二次项相等来定义的。将每个得到的质量表示为电子静止质量 $m_{\\mathrm{e}}$ 的单位（无量纲比率），并四舍五入到六位小数。\n\n2. 对于每个测试用例，在适当时还需验证旋转不变性：计算沿附加验证方向的方向质量，并报告一个布尔值，指示所有这些质量是否在该测试用例指定的相对容差 $\\tau$ 内相等。使用以下标准\n$$\n\\frac{\\max_i m_i - \\min_i m_i}{\\frac{1}{N}\\sum_{i=1}^N m_i} \\le \\tau,\n$$\n其中 $m_i$ 是沿验证方向的方向质量，$N$ 是验证方向的数量。\n\n3. 使用以下物理常数：\n- $\\hbar = 1.054\\,571\\,817\\times 10^{-34}\\,\\mathrm{J\\cdot s}$,\n- $m_{\\mathrm{e}} = 9.109\\,383\\,7015\\times 10^{-31}\\,\\mathrm{kg}$,\n- $1\\,\\mathrm{eV} = 1.602\\,176\\,634\\times 10^{-19}\\,\\mathrm{J}$,\n- $1\\,\\text{\\AA}^{-1} = 10^{10}\\,\\mathrm{m}^{-1}$。\n\n4. 单位和转换：\n- 所有内部计算的波矢量必须以 $\\mathrm{m}^{-1}$ 为单位。\n- 色散模型返回的能量必须以 $\\mathrm{eV}$ 为单位。\n- 输出的质量必须报告为比率 $m_{\\hat{\\mathbf{u}}}/m_{\\mathrm{e}}$，四舍五入到六位小数。\n- 下面任何旋转矩阵中出现的所有角度均以度为单位指定；如果提供了数值矩阵，请直接使用这些数字。\n\n5. 用于估计曲率的拟合协议：\n- 对于每个方向 $\\hat{\\mathbf{u}}$ 和测试用例，使用提供的 $k$ 值（单位为 $\\text{\\AA}^{-1}$）及其负值，连同 $0$，形成 $\\mathrm{m}^{-1}$ 单位的样本集 $\\{t\\}$。也就是说，对于给定的列表 $[k_1,k_2,\\dots,k_M]$，使用 $\\{-k_M,\\dots,-k_1,0,k_1,\\dots,k_M\\}$（单位为 $\\mathrm{m}^{-1}$）并计算每个点上的 $E(t\\,\\hat{\\mathbf{u}})$。\n- 对 $E$ 和 $t^2$ 进行带截距的线性最小二乘回归，以提取在最小化 $E$ 的平方误差意义下的最佳拟合二次系数。根据此系数和上述定义，计算方向有效质量。\n\n6. 输出格式：\n你的程序应生成单行输出，其中包含所有测试用例结果的 Python 风格列表，顺序与下面给出的测试用例相同。每个测试用例的结果本身必须是一个包含四个元素的列表\n$[m_1, m_2, m_3, R]$，其中 $m_1,m_2,m_3$ 分别是对应于该测试中用于质量提取的三个指定对称方向的三个方向有效质量（单位为 $m_{\\mathrm{e}}$），每个都四舍五入到六位小数，而 $R$ 是一个布尔值，指示是否在所述容差和验证方向下验证了旋转不变性。因此，最终的程序输出应为代表四个此类列表的列表的单行。\n\n测试套件：\n\n对于每个测试，色散关系根据质量张量和可选的非抛物线性生成\n$$\nE(\\mathbf{k}) = E_0 + \\frac{\\hbar^2}{2}\\,\\mathbf{k}^{\\mathsf{T}}\\,\\mathbf{M}^{-1}\\,\\mathbf{k} + \\beta\\,\\|\\mathbf{k}\\|^4,\n$$\n其中 $E(\\mathbf{k})$ 单位为 $\\mathrm{eV}$，$\\mathbf{k}$ 单位为 $\\mathrm{m}^{-1}$，$\\mathbf{M}$ 单位为 $\\mathrm{kg}$，$\\beta$ 单位为 $\\mathrm{eV\\cdot m^4}$。实验室坐标系中的质量张量构造为 $\\mathbf{M} = \\mathbf{R}\\,\\mathrm{diag}(m_x, m_y, m_z)\\,\\mathbf{R}^{\\mathsf{T}}$，其中 $m_x,m_y,m_z$ 以 $m_{\\mathrm{e}}$ 为单位指定，$\\mathbf{R}$ 是一个标准正交旋转矩阵。\n\n- 测试 1 (各向同性，严格抛物线型):\n  - $E_0 = 0\\,\\mathrm{eV}$。\n  - $(m_x, m_y, m_z) = (0.2, 0.2, 0.2)\\,m_{\\mathrm{e}}$。\n  - $\\mathbf{R} = \\mathbf{I}_3$。\n  - $\\beta = 0\\,\\mathrm{eV\\cdot m^4}$。\n  - 用于质量提取的对称方向: $\\hat{\\mathbf{u}}_1=(1,0,0)$, $\\hat{\\mathbf{u}}_2=(0,1,0)$, $\\hat{\\mathbf{u}}_3=(0,0,1)$。\n  - 用于旋转不变性验证的方向: $(1,0,0)$, $\\frac{1}{\\sqrt{2}}(1,1,0)$, $\\frac{1}{\\sqrt{3}}(1,1,1)$, $(0.866025403784, 0.5, 0)$。\n  - 旋转不变性相对容差 $\\tau = 10^{-6}$。\n  - $k$ 的模（与正负号及零一起使用）: $[0.0025, 0.005, 0.0075, 0.01]\\,\\text{\\AA}^{-1}$。\n\n- 测试 2 (各向异性，轴对齐):\n  - $E_0 = 0\\,\\mathrm{eV}$。\n  - $(m_x, m_y, m_z) = (0.2, 0.3, 1.0)\\,m_{\\mathrm{e}}$。\n  - $\\mathbf{R} = \\mathbf{I}_3$。\n  - $\\beta = 0\\,\\mathrm{eV\\cdot m^4}$。\n  - 用于质量提取的对称方向: $\\hat{\\mathbf{u}}_1=(1,0,0)$, $\\hat{\\mathbf{u}}_2=(0,1,0)$, $\\hat{\\mathbf{u}}_3=(0,0,1)$。\n  - 用于旋转不变性验证的方向: $(1,0,0)$, $\\frac{1}{\\sqrt{2}}(1,1,0)$, $\\frac{1}{\\sqrt{3}}(1,1,1)$。\n  - 旋转不变性相对容差 $\\tau = 10^{-6}$。\n  - $k$ 的模: $[0.0025, 0.005, 0.0075, 0.01]\\,\\text{\\AA}^{-1}$。\n\n- 测试 3 (各向同性，带弱非抛物线性):\n  - $E_0 = 0\\,\\mathrm{eV}$。\n  - $(m_x, m_y, m_z) = (0.5, 0.5, 0.5)\\,m_{\\mathrm{e}}$。\n  - $\\mathbf{R} = \\mathbf{I}_3$。\n  - $\\beta = 5.0\\times 10^{-39}\\,\\mathrm{eV\\cdot m^4}$。\n  - 用于质量提取的对称方向: $\\hat{\\mathbf{u}}_1=(1,0,0)$, $\\hat{\\mathbf{u}}_2=(0,1,0)$, $\\hat{\\mathbf{u}}_3=(0,0,1)$。\n  - 验证方向: $(1,0,0)$, $(0,1,0)$, $\\frac{1}{\\sqrt{2}}(1,1,0)$, $(0,0,1)$。\n  - 旋转不变性相对容差 $\\tau = 10^{-3}$。\n  - $k$ 的模: $[0.0025, 0.005, 0.0075, 0.01]\\,\\text{\\AA}^{-1}$。\n\n- 测试 4 (各向异性，主轴旋转):\n  - $E_0 = 0\\,\\mathrm{eV}$。\n  - $(m_x, m_y, m_z) = (0.15, 0.30, 0.80)\\,m_{\\mathrm{e}}$。\n  - $\\mathbf{R} = \\mathbf{R}_z(30^\\circ)\\,\\mathbf{R}_y(20^\\circ)$，其数值为\n    $$\n    \\mathbf{R} =\n    \\begin{pmatrix}\n    0.813797681349  -0.500000000000  0.296198132726 \\\\\n    0.469846310393  0.866025403784  0.171010071663 \\\\\n    -0.342020143326  0.000000000000  0.939692620786\n    \\end{pmatrix}.\n    $$\n  - $\\beta = 0\\,\\mathrm{eV\\cdot m^4}$。\n  - 用于质量提取的对称方向 (选择为 $\\mathbf{R}$ 的列，每个都归一化): $\\hat{\\mathbf{u}}_1=(0.813797681349, 0.469846310393, -0.342020143326)$, $\\hat{\\mathbf{u}}_2=(-0.5, 0.866025403784, 0)$, $\\hat{\\mathbf{u}}_3=(0.296198132726, 0.171010071663, 0.939692620786)$。\n  - 验证方向: $(1,0,0)$, $(0,1,0)$, $(0,0,1)$, $(0.813797681349, 0.469846310393, -0.342020143326)$。\n  - 旋转不变性相对容差 $\\tau = 10^{-6}$。\n  - $k$ 的模: $[0.0025, 0.005, 0.0075, 0.01]\\,\\text{\\AA}^{-1}$。\n\n实现要求：\n\n- 完全按照上述规定实现色散模型。\n- 对于每个测试用例，计算并输出列表 $[m_1, m_2, m_3, R]$，其中 $m_1,m_2,m_3$ 分别对应于该测试用例的三个给定对称方向的质量，单位为 $m_{\\mathrm{e}}$，并四舍五入到六位小数，而 $R$ 是在该声明的容差和验证方向下进行旋转不变性检查的布尔结果。\n- 你的程序应生成单行输出，包含一个 Python 风格的列表的列表形式的结果，例如，类似\n$[[m_{1,1},m_{1,2},m_{1,3},R_1],[m_{2,1},m_{2,2},m_{2,3},R_2],\\dots]$。", "solution": "所提出的问题是固态物理学中一个定义明确的计算练习，具体涉及使用有效质量近似来表征能带极值点附近的电子能带结构。该问题在科学上是合理的，内部一致，并为其解决提供了所有必要的信息。因此，我将着手提供一个完整的解决方案。\n\n每个测试用例的解决方法包括三个主要步骤：首先，根据提供的参数构建能量色散模型；其次，通过模拟能量数据并执行二次最小二乘拟合来计算方向有效质量；第三，基于一组计算出的方向质量来评估旋转不变性。\n\n能量色散 $E$ 作为晶体动量波矢量 $\\mathbf{k}$ 的函数的基础物理模型由能带最小值 $\\mathbf{k}=\\mathbf{0}$ 附近的展开式给出：\n$$\nE(\\mathbf{k}) \\approx E_0 + \\frac{\\hbar^2}{2}\\,\\mathbf{k}^{\\mathsf{T}}\\,\\mathbf{M}^{-1}\\,\\mathbf{k} + \\beta \\|\\mathbf{k}\\|^4\n$$\n在这里，$E_0$ 是能带最小值的能量，$\\mathbf{M}$ 是有效质量张量，$\\hbar$ 是约化普朗克常数，$\\beta$ 是一个考虑非抛物线性的系数。问题规定能量单位为电子伏特（eV），波矢量 $\\mathbf{k}$ 单位为逆米（m$^{-1}$），质量单位为千克（kg），$\\beta$ 单位为 eV·m$^4$。二次项 $\\frac{\\hbar^2}{2}\\,\\mathbf{k}^{\\mathsf{T}}\\,\\mathbf{M}^{-1}\\,\\mathbf{k}$ 的单位是焦耳（J）。为保持一致性，该项必须通过除以基本电荷 $e$ 转换为电子伏特，其以库仑为单位的数值在数值上等于从 eV 到 J 的转换因子。因此，用于计算的正确表述的色散关系是：\n$$\nE(\\mathbf{k}) [\\mathrm{eV}] = E_0 + \\frac{\\hbar^2}{2e}\\,\\mathbf{k}^{\\mathsf{T}}\\,\\mathbf{M}^{-1}\\,\\mathbf{k} + \\beta \\|\\mathbf{k}\\|^4\n$$\n有效质量张量 $\\mathbf{M}$ 由其主质量 $(m_x, m_y, m_z)$（以电子静止质量 $m_{\\mathrm{e}}$ 为单位给出）和一个旋转矩阵 $\\mathbf{R}$ 构建而成，即 $\\mathbf{M} = \\mathbf{R}\\,\\mathrm{diag}(m_x m_{\\mathrm{e}}, m_y m_{\\mathrm{e}}, m_z m_{\\mathrm{e}})\\,\\mathbf{R}^{\\mathsf{T}}$。然后通过数值方法计算逆张量 $\\mathbf{M}^{-1}$。\n\n为了找到沿单位方向 $\\hat{\\mathbf{u}}$ 的方向有效质量 $m_{\\hat{\\mathbf{u}}}$，我们考虑一维色散 $E(t\\,\\hat{\\mathbf{u}})$，其中 $t$ 是沿 $\\hat{\\mathbf{u}}$ 的标量波数。这由近似式 $E(t\\,\\hat{\\mathbf{u}}) \\approx E_0 + \\frac{\\hbar^2}{2e\\,m_{\\hat{\\mathbf{u}}}} t^2$ 定义。我们通过将二次模型 $E_{fit}(t) = a_0 + a_2 t^2$ 拟合到一组采样数据点来估计 $t^2$ 项的系数。样本是通过对给定的模值列表 $[k_1, k_2, \\dots, k_M]$ 在 $t \\in \\{-k_M, \\dots, -k_1, 0, k_1, \\dots, k_M\\}$ 处（将模值从 $\\text{\\AA}^{-1}$ 转换为 $m^{-1}$ 后）计算 $E(t\\,\\hat{\\mathbf{u}})$ 来生成的。拟合过程是在模型 $E = a_0 + a_2(t^2)$ 上使用线性最小二乘回归，其中 $t^2$ 是自变量。得到的最佳拟合系数 $a_2$ 是 $\\frac{\\hbar^2}{2e\\,m_{\\hat{\\mathbf{u}}}}$ 的一个估计值。然后，方向有效质量（单位为千克）可以提取为：\n$$\nm_{\\hat{\\mathbf{u}}} = \\frac{\\hbar^2}{2e\\,a_2}\n$$\n随后，通过除以电子静止质量，将该值表示为无量纲比率 $m_{\\hat{\\mathbf{u}}}/m_{\\mathrm{e}}$。\n\n对于每个测试用例，此过程首先应用于一组指定的三个“对称方向”，以获得所需的质量 $m_1$、$m_2$ 和 $m_3$。\n\n最后，对另一组“验证方向”评估旋转不变性。对一组 $N$ 个验证方向计算方向质量 $\\{m_i\\}$。如果满足以下条件，则认为材料在给定的容差 $\\tau$ 内是旋转不变的：\n$$\n\\frac{\\max_i m_i - \\min_i m_i}{\\frac{1}{N}\\sum_{i=1}^N m_i} \\le \\tau\n$$\n此检查产生一个布尔值 $R$。\n\n计算实现将封装这些步骤。一个用于能量色散模型的函数将接受 $\\mathbf{k}$ 和测试用例参数以返回 $E(\\mathbf{k})$。第二个函数将协调采样、拟合和提取给定方向 $\\hat{\\mathbf{u}}$ 的方向质量。一个主例程将遍历提供的测试套件，为指定的质量提取和验证方向调用这些函数，并为每个案例编译最终结果 $[m_1, m_2, m_3, R]$。程序将使用提供的高精度物理常数并按规定处理所有单位转换。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the electronic dispersion problem for all test cases.\n    \"\"\"\n    \n    # Physical constants\n    HBAR = 1.054571817e-34    # J.s\n    M_E = 9.1093837015e-31     # kg\n    EV_TO_J = 1.602176634e-19  # J/eV\n    AA_INV_TO_M_INV = 1e10     # m^-1 / A^-1\n\n    # Test suite definition\n    test_cases = [\n        {\n            \"E0\": 0.0,\n            \"principal_masses_me\": (0.2, 0.2, 0.2),\n            \"R\": np.identity(3),\n            \"beta\": 0.0,\n            \"mass_directions\": [(1, 0, 0), (0, 1, 0), (0, 0, 1)],\n            \"validation_directions\": [(1, 0, 0), (1/np.sqrt(2), 1/np.sqrt(2), 0), (1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)), (0.866025403784, 0.5, 0)],\n            \"tau\": 1e-6,\n            \"k_magnitudes_aa\": [0.0025, 0.005, 0.0075, 0.01]\n        },\n        {\n            \"E0\": 0.0,\n            \"principal_masses_me\": (0.2, 0.3, 1.0),\n            \"R\": np.identity(3),\n            \"beta\": 0.0,\n            \"mass_directions\": [(1, 0, 0), (0, 1, 0), (0, 0, 1)],\n            \"validation_directions\": [(1, 0, 0), (1/np.sqrt(2), 1/np.sqrt(2), 0), (1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3))],\n            \"tau\": 1e-6,\n            \"k_magnitudes_aa\": [0.0025, 0.005, 0.0075, 0.01]\n        },\n        {\n            \"E0\": 0.0,\n            \"principal_masses_me\": (0.5, 0.5, 0.5),\n            \"R\": np.identity(3),\n            \"beta\": 5.0e-39,\n            \"mass_directions\": [(1, 0, 0), (0, 1, 0), (0, 0, 1)],\n            \"validation_directions\": [(1, 0, 0), (0, 1, 0), (1/np.sqrt(2), 1/np.sqrt(2), 0), (0, 0, 1)],\n            \"tau\": 1e-3,\n            \"k_magnitudes_aa\": [0.0025, 0.005, 0.0075, 0.01]\n        },\n        {\n            \"E0\": 0.0,\n            \"principal_masses_me\": (0.15, 0.30, 0.80),\n            \"R\": np.array([\n                [0.813797681349, -0.500000000000, 0.296198132726],\n                [0.469846310393, 0.866025403784, 0.171010071663],\n                [-0.342020143326, 0.000000000000, 0.939692620786]\n            ]),\n            \"beta\": 0.0,\n            \"mass_directions\": [(0.813797681349, 0.469846310393, -0.342020143326), (-0.5, 0.866025403784, 0), (0.296198132726, 0.171010071663, 0.939692620786)],\n            \"validation_directions\": [(1, 0, 0), (0, 1, 0), (0, 0, 1), (0.813797681349, 0.469846310393, -0.342020143326)],\n            \"tau\": 1e-6,\n            \"k_magnitudes_aa\": [0.0025, 0.005, 0.0075, 0.01]\n        }\n    ]\n\n    def dispersion_model(k_vec, E0, Minv, beta):\n        \"\"\"Calculates energy E(k) in eV.\"\"\"\n        # k_vec is a 3-element numpy array in m^-1\n        k_norm_sq = np.dot(k_vec, k_vec)\n        \n        # Quadratic term. k.T @ M_inv @ k\n        quad_term_J = 0.5 * (HBAR**2) * (k_vec @ Minv @ k_vec)\n        quad_term_eV = quad_term_J / EV_TO_J\n        \n        # Non-parabolic term\n        non_para_term_eV = beta * (k_norm_sq**2)\n        \n        return E0 + quad_term_eV + non_para_term_eV\n\n    def calculate_directional_mass(u_vec, E0, Minv, beta, k_magnitudes_aa):\n        \"\"\"Calculates directional mass along u_vec in units of m_e.\"\"\"\n        u_vec = np.array(u_vec)\n        u_vec = u_vec / np.linalg.norm(u_vec)\n\n        # Prepare sampling points t in m^-1\n        k_mags_m_inv = np.array(k_magnitudes_aa) * AA_INV_TO_M_INV\n        t_samples = np.concatenate([-k_mags_m_inv[::-1], [0], k_mags_m_inv])\n\n        # Sample energy values\n        E_samples = np.array([dispersion_model(t * u_vec, E0, Minv, beta) for t in t_samples])\n        \n        # Perform least-squares fit for E = a0 + a2*t^2\n        t_samples_sq = t_samples**2\n        A = np.vstack([np.ones(len(t_samples_sq)), t_samples_sq]).T\n        \n        # Solve for coefficients [a0, a2]\n        coeffs, _, _, _ = np.linalg.lstsq(A, E_samples, rcond=None)\n        a2 = coeffs[1]\n        \n        # Calculate mass from the quadratic coefficient a2\n        # a2 = (hbar^2) / (2 * e_charge * m_directional)\n        # m_directional is in kg\n        if a2 == 0:\n            return np.inf\n        mass_kg = (HBAR**2) / (2 * EV_TO_J * a2)\n        mass_me = mass_kg / M_E\n        \n        return mass_me\n\n    def check_rotational_invariance(masses, tolerance):\n        \"\"\"Checks if masses are equal within a relative tolerance.\"\"\"\n        if not masses or len(masses)  2:\n            return True\n        mass_arr = np.array(masses)\n        max_m = np.max(mass_arr)\n        min_m = np.min(mass_arr)\n        avg_m = np.mean(mass_arr)\n        if avg_m == 0:\n            return max_m == min_m\n        \n        spread = (max_m - min_m) / avg_m\n        return spread = tolerance\n\n    all_results = []\n    for case in test_cases:\n        # Construct inverse mass tensor M_inv\n        m_diag_kg = np.diag(case[\"principal_masses_me\"]) * M_E\n        R = case[\"R\"]\n        M = R @ m_diag_kg @ R.T\n        Minv = np.linalg.inv(M)\n        \n        # Calculate masses for the three main directions\n        mass_results_me = []\n        for u in case[\"mass_directions\"]:\n            mass = calculate_directional_mass(u, case[\"E0\"], Minv, case[\"beta\"], case[\"k_magnitudes_aa\"])\n            mass_results_me.append(mass)\n\n        # Perform rotational invariance validation\n        validation_masses = []\n        for v in case[\"validation_directions\"]:\n            mass = calculate_directional_mass(v, case[\"E0\"], Minv, case[\"beta\"], case[\"k_magnitudes_aa\"])\n            validation_masses.append(mass)\n            \n        is_invariant = check_rotational_invariance(validation_masses, case[\"tau\"])\n\n        # Format and append results\n        formatted_masses = [round(m, 6) for m in mass_results_me]\n        all_results.append(formatted_masses + [is_invariant])\n    \n    # Custom string formatting to match Python list literal style\n    # and ensure six decimal places for floats.\n    result_strs = []\n    for result in all_results:\n        m1_str = f\"{result[0]:.6f}\"\n        m2_str = f\"{result[1]:.6f}\"\n        m3_str = f\"{result[2]:.6f}\"\n        R_str = str(result[3])\n        result_strs.append(f\"[{m1_str}, {m2_str}, {m3_str}, {R_str}]\")\n\n    final_output_str = f\"[{','.join(result_strs)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2484981"}, {"introduction": "能带结构最终的价值在于它能够预测和解释材料的宏观性质，如光学特性。然而，从密度泛函理论（DFT）等计算方法得到的能带通常需要修正，以匹配实验结果。本练习 [@problem_id:2484915] 将带你实践一种常见的修正技术——剪刀算符（scissor operator），并进一步计算修正后能带结构的光学吸收谱，从而将抽象的能带图与可测量的物理量直接联系起来。", "problem": "给定一个直接带隙半导体通过密度泛函理论 (DFT) 计算得到的离散单粒子能带结构，该结构位于布里渊区 (BZ) 的一维采样上，同时还提供了 $k$ 点权重和光学跃迁矩阵元的平方。您的任务是实现对导带的剪刀算符校正，并评估其对独立粒子光学吸收谱的影响。所有能量必须以电子伏特 ($\\mathrm{eV}$) 为单位处理，吸收值必须以任意单位 (无量纲) 报告，并四舍五入到六位小数。\n\n基本原理：\n- 零温独立粒子近似 (IPA)：光学带间吸收是由占据的价态到空的导态的垂直跃迁驱动的，并可通过费米黄金定则建模。吸收部分与跃迁概率乘以一个强制能量守恒的狄拉克δ函数的 $k$ 点加权和成正比。\n- 费米黄金定则 (独立粒子，直接跃迁)：\n$$\n\\alpha(E_\\gamma) \\propto \\sum_{k} w_k \\, \\lvert M(k) \\rvert^2 \\, \\delta\\!\\left(E_c(k) - E_v(k) - E_\\gamma \\right),\n$$\n其中，$E_\\gamma$ 是光子能量，$w_k$ 是 $k$ 点权重，$E_v(k)$ 和 $E_c(k)$ 分别是价带和导带能量，而 $\\lvert M(k) \\rvert^2$ 是动量 (或速度) 矩阵元的模平方。\n- 剪刀算符：将导带通过一个常数 $\\Delta$ 进行刚性上移，$E_c^{\\mathrm{sc}}(k) = E_c(k) + \\Delta$。\n- 数值展宽：用宽度为 $\\sigma$ 的归一化高斯函数替代狄拉克δ函数：\n$$\n\\delta_\\sigma(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right).\n$$\n- 离散 $k$ 空间近似：布里渊区上的积分被给定 $k$ 点 $\\{k_i\\}$ 及其权重 $\\{w_i\\}$ 的加权和所取代。\n\n从这些原理 (而非快捷公式) 出发，通过应用剪刀算符并在离散 $k$ 点表示中使用高斯展宽的费米黄金定则，推导并实现对指定光子能量下吸收谱值的计算。假设温度为零，因此价带完全被占据，导带为空。\n\n使用的数据 (所有能量单位为 $\\mathrm{eV}$，权重无量纲)：\n- $k$点权重 $[w_0,w_1,w_2,w_3,w_4] = [\\,0.1,\\,0.2,\\,0.4,\\,0.2,\\,0.1\\,]$。\n- 价带能量 $[E_v(k_i)] = [\\,-0.10,\\,-0.02,\\,0.00,\\,-0.02,\\,-0.10\\,]$。\n- 导带能量 $[E_c(k_i)] = [\\,2.10,\\,1.95,\\,1.80,\\,1.95,\\,2.10\\,]$。\n- 光学矩阵元平方 $[\\lvert M(k_i) \\rvert^2] = [\\,0.5,\\,1.0,\\,2.0,\\,1.0,\\,0.5\\,]$。\n\n对于光子能量 $E_\\gamma$、剪刀位移 $\\Delta$ 和高斯宽度 $\\sigma$，将计算出的吸收定义为：\n$$\n\\alpha(E_\\gamma; \\Delta, \\sigma) \\propto \\sum_{i=0}^{4} w_i \\, \\lvert M(k_i) \\rvert^2 \\, \\delta_\\sigma\\!\\left( \\left[E_c(k_i) + \\Delta\\right] - E_v(k_i) - E_\\gamma \\right).\n$$\n因为只比较不同 $(\\Delta,\\sigma)$ 值下的相对趋势，您可以直接使用这个比例量 (即，省略所有情况下共有的任何预因子)。您的程序必须计算这个比例量 $\\alpha$，作为一个实数 (无量纲)，以任意单位表示。\n\n需要实现和评估的测试套件：\n- 案例1 (基线，无剪刀算符)：$\\Delta = 0.0$ $\\mathrm{eV}$，$\\sigma = 0.05$ $\\mathrm{eV}$，光子能量 $[\\,1.8,\\,2.0,\\,2.2\\,]$ $\\mathrm{eV}$。\n- 案例2 (大剪刀位移，谱线尖锐)：$\\Delta = 0.5$ $\\mathrm{eV}$，$\\sigma = 0.01$ $\\mathrm{eV}$，光子能量 $[\\,1.8,\\,2.0,\\,2.2\\,]$ $\\mathrm{eV}$。\n- 案例3 (中等剪刀位移，展宽与案例1相同)：$\\Delta = 0.2$ $\\mathrm{eV}$，$\\sigma = 0.05$ $\\mathrm{eV}$，光子能量 $[\\,2.0,\\,2.2,\\,2.4\\,]$ $\\mathrm{eV}$。\n\n要求：\n- 在评估跃迁之前，将剪刀算符实现为刚性位移 $E_c(k) \\mapsto E_c(k) + \\Delta$。\n- 按规定使用宽度为 $\\sigma$ 的归一化高斯展宽 $\\delta_\\sigma(x)$。\n- 对于每种情况，计算所列出的每个光子能量下的吸收值，并将每个结果四舍五入到六位小数。\n- 所有案例的输出必须汇总到单行中，格式必须完全如下：一个Python风格的列表的列表，其中每个内部列表按相同顺序包含该案例中光子能量的计算结果。例如，输出必须看起来像 $[\\,[a_1,a_2,a_3],\\,[b_1,b_2,b_3],\\,[c_1,c_2,c_3]\\,]$，其中每个条目都是四舍五入到六位小数的浮点数。\n\n角度单位不适用。所有物理能量必须以 $\\mathrm{eV}$ 为单位处理和报告，吸收输出是无量纲的 (任意单位)。您的程序必须是自包含的，不需要任何输入，并且只打印所需的单个输出行。不允许访问外部文件或网络。", "solution": "所提出的问题是固体物理学中一个定义明确的计算练习，具体涉及从电子能带结构计算光学性质。它具有科学依据，逻辑上一致，并且提供了所有必要的参数和定义。因此，该问题被认为是有效的，并将提供完整的解决方案。\n\n控制固体中光学吸收的基本原理是费米黄金定则。对于零温下的直接带间跃迁，此时价带完全被占据，导带为空，吸收系数 $\\alpha$ 作为光子能量 $E_\\gamma$ 的函数，与联合态密度成正比，并由跃迁概率加权。在独立粒子近似中，这表示为在第一布里渊区 (BZ) 上的积分：\n$$\n\\alpha(E_\\gamma) \\propto \\int_{\\text{BZ}} d^3k \\, \\lvert M(\\mathbf{k}) \\rvert^2 \\, \\delta(E_c(\\mathbf{k}) - E_v(\\mathbf{k}) - E_\\gamma)\n$$\n在这里，$E_c(\\mathbf{k})$ 和 $E_v(\\mathbf{k})$ 分别是导带和价带的能量色散关系。$\\lvert M(\\mathbf{k}) \\rvert^2$ 是光学跃迁矩阵元的平方，它量化了在给定晶体动量 $\\mathbf{k}$ 下发生跃迁的概率。狄拉克δ函数 $\\delta(E)$ 强制执行能量守恒原理，确保只有当光子能量 $E_\\gamma$ 精确匹配最终和初始电子态之间的能量差时，光子才会被吸收。\n\n对于基于密度泛函理论 (DFT) 计算结果的数值计算，由于DFT在离散的 $k$ 点网格上提供能量，该积分通过加权和来近似：\n$$\n\\alpha(E_\\gamma) \\propto \\sum_{i} w_i \\, \\lvert M(k_i) \\rvert^2 \\, \\delta(E_c(k_i) - E_v(k_i) - E_\\gamma)\n$$\n其中，求和是对BZ样本中的离散k点 $k_i$ 进行的，$w_i$ 是相应的权重，且 $\\sum_i w_i = 1$。\n\n狄拉克δ函数在离散数值计算中存在数学上的问题。因此，标准做法是使用一个展宽函数来替代它，以模拟有限寿命效应并获得连续谱。问题为此指定了一个归一化的高斯函数：\n$$\n\\delta(x) \\rightarrow \\delta_\\sigma(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\n$$\n其中 $\\sigma$ 是展宽参数，对应于高斯函数的标准差。\n\n此外，众所周知，标准的DFT计算，特别是使用局域或半局域交换相关泛函的计算，会系统性地低估电子带隙。一个常见且简单的校正方法是应用“剪刀算符”，即对所有导带态施加一个刚性的、均匀的能量位移 $\\Delta$：\n$$\nE_c(k_i) \\rightarrow E_c^{\\text{sc}}(k_i) = E_c(k_i) + \\Delta\n$$\n此过程在保持导带形状的同时校正了基本带隙。\n\n结合这些组成部分，我们得到了问题陈述中指定的计算吸收谱的最终表达式。对于给定的光子能量 $E_\\gamma$、剪刀校正 $\\Delta$ 和展宽宽度 $\\sigma$，吸收计算如下：\n$$\n\\alpha(E_\\gamma; \\Delta, \\sigma) = \\sum_{i=0}^{4} w_i \\, \\lvert M(k_i) \\rvert^2 \\, \\delta_\\sigma( (E_c(k_i) + \\Delta) - E_v(k_i) - E_\\gamma )\n$$\n代入高斯函数 $\\delta_\\sigma$ 的定义，用于实现的精确公式是：\n$$\n\\alpha(E_\\gamma; \\Delta, \\sigma) = \\sum_{i=0}^{4} w_i \\, \\lvert M(k_i) \\rvert^2 \\, \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{( (E_c(k_i) + \\Delta) - E_v(k_i) - E_\\gamma )^2}{2\\sigma^2}\\right)\n$$\n提供的代码将实现此公式，以评估三个指定测试用例的吸收情况。每个光子能量的计算涉及：\n1.  将剪刀位移 $\\Delta$ 应用于导带能量 $E_c(k_i)$。\n2.  对于每个 $k$ 点 $k_i$，计算高斯函数的跃迁能量差参数：$x_i = (E_c(k_i) + \\Delta) - E_v(k_i) - E_\\gamma$。\n3.  计算高斯函数 $\\delta_\\sigma(x_i)$。\n4.  用相应的k点权重 $w_i$ 和矩阵元平方 $\\lvert M(k_i) \\rvert^2$ 对每个高斯值进行加权。\n5.  对所有 $k$ 点的贡献求和，以获得总吸收值。\n\n此过程将对每个测试案例中指定的每个光子能量重复进行，并将结果按要求收集和格式化。该实现将使用 `numpy` 库进行高效的基于数组的计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optical absorption spectrum for a direct-gap semiconductor\n    using Fermi's golden rule with a scissor operator and Gaussian broadening.\n    \"\"\"\n\n    # Data from the problem statement\n    # k-point weights [w_0, w_1, w_2, w_3, w_4]\n    k_weights = np.array([0.1, 0.2, 0.4, 0.2, 0.1])\n    # Valence band energies [E_v(k_i)] in eV\n    Ev = np.array([-0.10, -0.02, 0.00, -0.02, -0.10])\n    # Conduction band energies [E_c(k_i)] in eV\n    Ec = np.array([2.10, 1.95, 1.80, 1.95, 2.10])\n    # Squared optical matrix elements [|M(k_i)|^2] in arbitrary units\n    M_sq = np.array([0.5, 1.0, 2.0, 1.0, 0.5])\n\n    # Test suite: (Delta, sigma, photon_energies)\n    test_cases = [\n        (0.0, 0.05, [1.8, 2.0, 2.2]),  # Case 1\n        (0.5, 0.01, [1.8, 2.0, 2.2]),  # Case 2\n        (0.2, 0.05, [2.0, 2.2, 2.4]),  # Case 3\n    ]\n\n    all_results = []\n\n    def calculate_absorption(delta, sigma, photon_energies):\n        \"\"\"\n        Calculates absorption for a set of parameters.\n\n        Args:\n            delta (float): Scissor operator shift in eV.\n            sigma (float): Gaussian broadening width in eV.\n            photon_energies (list of float): Photon energies to evaluate in eV.\n\n        Returns:\n            list of float: Calculated absorption values, rounded.\n        \"\"\"\n        results_for_case = []\n        if sigma = 0:\n            # Avoid division by zero if sigma is not positive\n            return [0.0] * len(photon_energies)\n\n        # Apply scissor operator to the conduction band\n        Ec_scissored = Ec + delta\n\n        # Pre-calculate transition energies\n        transition_energies = Ec_scissored - Ev\n\n        # Pre-calculate the constant part of the Gaussian normalization\n        gaussian_norm = 1.0 / (sigma * np.sqrt(2 * np.pi))\n\n        for E_gamma in photon_energies:\n            # Calculate the argument of the exponential for all k-points\n            x = transition_energies - E_gamma\n            # Calculate the Gaussian broadening for all k-points\n            gaussian_values = gaussian_norm * np.exp(-(x**2) / (2 * sigma**2))\n\n            # Calculate the contribution of each k-point to the absorption\n            contributions = k_weights * M_sq * gaussian_values\n\n            # Sum contributions to get total absorption\n            total_absorption = np.sum(contributions)\n            results_for_case.append(round(total_absorption, 6))\n\n        return results_for_case\n\n    for delta, sigma, photon_energies in test_cases:\n        case_results = calculate_absorption(delta, sigma, photon_energies)\n        all_results.append(case_results)\n\n    # Format the final output as a string representing a list of lists.\n    # The list comprehension and str.join create the inner lists '[r1,r2,r3]'.\n    # A second str.join combines them into the final output.\n    inner_lists = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output_string = f\"[{','.join(inner_lists)}]\"\n\n    print(final_output_string)\n\nsolve()\n```", "id": "2484915"}]}