{"hands_on_practices": [{"introduction": "非相干前馈环 (I1-FFL) 是一种常见的网络基序，能够产生脉冲信号或加速响应。本练习将通过分析一个线性化模型，来探索信号是如何通过两条时标不同的路径，最终产生非单调（过冲）响应的。通过这个推导，你将能深刻理解 I1-FFL 的核心动态功能及其对系统参数的依赖性 [@problem_id:2658564]。", "problem": "考虑一个化学反应网络中的非相干前馈环，其中外部输入 $u(t)$ 激活中间物种 $x$，$x$ 继而直接激活输出 $z$，同时也激活抑制 $z$ 的第二个中间物种 $y$。在一个固定工作点附近的线性区域（通过线性化质量作用动力学得到），假设生成和降解过程均为一阶，则其动力学由以下线性时不变常微分方程组描述\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{u(t) - x}{\\tau_x}, \n\\qquad\n\\frac{dy}{dt} \\;=\\; \\frac{x - y}{\\tau_y},\n\\qquad\n\\frac{dz}{dt} \\;=\\; \\frac{k_x x - k_y y - z}{\\tau_z},\n$$\n其中参数 $k_x, k_y, \\tau_x, \\tau_y, \\tau_z$ 均为严格正值，初始条件为 $x(0)=y(0)=z(0)=0$。假设 $k_x > k_y$，以确保在持续输入下稳态 $z$ 为正。输入为阶跃函数 $u(t) = u_0 H(t)$，其中 $H(t)$ 是亥维赛德阶跃函数，$u_0 > 0$ 是一个恒定幅值。\n\n仅从上述动力学方程和亥维赛德阶跃函数的定义出发，并使用线性系统分析的标准工具（例如，卷积、拉普拉斯变换），完成以下任务：\n\n1. 在快速读出极限 $\\tau_z \\to 0$下，推导当 $t \\ge 0$ 时阶跃响应 $z(t)$ 的闭式表达式（即，取 $\\tau_z$ 相对于 $\\tau_x$ 和 $\\tau_y$ 足够小，使得 $z(t)$ 瞬时跟随 $k_x x(t) - k_y y(t)$）。\n\n2. 定义稳态值 $z_{\\infty} \\equiv \\lim_{t\\to\\infty} z(t)$，并规定如果存在时间 $t^\\ast > 0$ 使得 $z(t^\\ast) > z_{\\infty}$，则称响应表现出超调。请解析地确定超调的存在与否如何依赖于比率 $r \\equiv \\tau_y / \\tau_x$。特别地，找到临界比值 $r^{\\star}$（一个以 $k_x$ 和 $k_y$ 表示的符号表达式），使得响应出现超调的充要条件是 $r > r^{\\star}$。\n\n你的最终答案必须是 $r^{\\star}$ 的单个闭式表达式。不需要进行数值取整。所有数学量均使用标准符号表示，不带单位。", "solution": "所述问题具有科学依据、是良定的、客观的，并包含了获得唯一解所需的所有信息。这是线性动力学系统分析应用于系统生物学中网络基序的一个标准问题。因此，该问题是有效的，我们开始求解。\n\n当 $t \\ge 0$ 时，该系统由以下线性常微分方程组描述：\n$$\n\\frac{dx}{dt} = \\frac{u_0 - x}{\\tau_x}, \\quad x(0)=0\n$$\n$$\n\\frac{dy}{dt} = \\frac{x - y}{\\tau_y}, \\quad y(0)=0\n$$\n$$\n\\frac{dz}{dt} = \\frac{k_x x - k_y y - z}{\\tau_z}, \\quad z(0)=0\n$$\n其中已代入 $u(t) = u_0 H(t)$。参数 $k_x, k_y, \\tau_x, \\tau_y, \\tau_z, u_0$ 均为严格为正的常数。\n\n题目要求我们在快速读出极限 $\\tau_z \\to 0$ 下进行计算。在此极限下，$z$ 的动力学比 $x$ 和 $y$ 快得多，因此除非分子接近于零，否则 $\\frac{dz}{dt}$ 会很大。这意味着对 $z$ 可以采用准稳态近似：\n$$\nz(t) \\approx k_x x(t) - k_y y(t)\n$$\n我们的第一个任务是找出 $x(t)$ 和 $y(t)$ 的显式时间依赖解。\n\n$x(t)$ 的方程是一个标准的一阶线性常微分方程。其解为：\n$$\nx(t) = u_0 (1 - \\exp(-t/\\tau_x))\n$$\n\n接下来，我们将 $x(t)$ 的解代入第二个方程来求解 $y(t)$：\n$$\n\\frac{dy}{dt} + \\frac{1}{\\tau_y} y = \\frac{x(t)}{\\tau_y} = \\frac{u_0}{\\tau_y} (1 - \\exp(-t/\\tau_x))\n$$\n这是另一个初始条件为 $y(0)=0$ 的一阶线性常微分方程。假设 $\\tau_x \\neq \\tau_y$，可以使用积分因子法或拉普拉斯变换求解。结果是：\n$$\ny(t) = u_0 \\left( 1 - \\frac{\\tau_x}{\\tau_x - \\tau_y} \\exp(-t/\\tau_x) + \\frac{\\tau_y}{\\tau_x - \\tau_y} \\exp(-t/\\tau_y) \\right)\n$$\n在 $\\tau_x = \\tau_y = \\tau$ 的特殊情况下，解为 $y(t) = u_0 (1 - \\exp(-t/\\tau) - \\frac{t}{\\tau}\\exp(-t/\\tau))$。可以验证，通解能正确地趋近于这个特殊情况的解。\n\n现在，我们使用快速读出近似来构建输出 $z(t)$：\n$$\nz(t) = k_x x(t) - k_y y(t)\n$$\n$$\nz(t) = k_x u_0 (1 - \\exp(-t/\\tau_x)) - k_y u_0 \\left( 1 - \\frac{\\tau_x}{\\tau_x - \\tau_y} \\exp(-t/\\tau_x) + \\frac{\\tau_y}{\\tau_x - \\tau_y} \\exp(-t/\\tau_y) \\right)\n$$\n合并同类项，我们得到：\n$$\nz(t) = u_0(k_x - k_y) + u_0 \\left( \\frac{k_y \\tau_x}{\\tau_x - \\tau_y} - k_x \\right) \\exp(-t/\\tau_x) - u_0 \\frac{k_y \\tau_y}{\\tau_x - \\tau_y} \\exp(-t/\\tau_y)\n$$\n\n稳态值 $z_{\\infty}$ 是 $z(t)$ 在 $t \\to \\infty$ 时的极限。由于指数项衰减至零，我们有：\n$$\nz_{\\infty} = \\lim_{t\\to\\infty} z(t) = u_0(k_x - k_y)\n$$\n因为题目给定 $k_x > k_y$，所以该值为正。\n\n如果存在一个时间 $t^\\ast > 0$ 使得 $z(t^\\ast) > z_{\\infty}$，则发生超调。这种情况发生在函数 $z(t)$ 的最大值大于其最终稳态值时。由于 $z(0)=0$ 且 $\\frac{dz}{dt}|_{t=0} = \\frac{k_x u_0}{\\tau_x} > 0$，函数初始是增加的。超调意味着函数最终必须减少，这要求导数 $\\frac{dz}{dt}$ 在某个时间 $t^\\ast > 0$ 变为零。\n\n我们来计算 $z(t)$ 的导数，并令 $\\frac{dz}{dt} = 0$ 可得：\n$$\n\\exp \\left( t \\left(\\frac{1}{\\tau_x} - \\frac{1}{\\tau_y}\\right) \\right) = 1 - \\frac{k_x}{k_y}(1-r)\n$$\n其中 $r \\equiv \\tau_y/\\tau_x$。为了使解 $t^\\ast > 0$ 存在，等式右侧（RHS）必须为正。我们针对 $r > 0$ 的不同范围分析此条件。\n\n情况 1：$r > 1$ (即 $\\tau_y > \\tau_x$)。在这种情况下，$1-r  0$。由于 $k_x, k_y > 0$，项 $-\\frac{k_x}{k_y}(1-r)$ 为正。因此，RHS 大于 1。左侧（LHS）的指数 $t(\\frac{1}{\\tau_x} - \\frac{1}{\\tau_y}) = t\\frac{\\tau_y-\\tau_x}{\\tau_x \\tau_y}$，当 $t>0$ 时为正。因此 LHS 也大于 1。总存在一个唯一的解 $t^\\ast > 0$。该极值为最大值，并且可以证明 $z(t^\\ast) > z_\\infty$。因此，当 $r > 1$ 时，总会发生超调。\n\n情况 2：$r  1$ (即 $\\tau_y  \\tau_x$)。在这种情况下，$1-r > 0$。为使关于 $t$ 的解存在，我们需要 RHS 为正：\n$$\n1 - \\frac{k_x}{k_y}(1-r) > 0 \\implies 1 > \\frac{k_x}{k_y}(1-r) \\implies k_y > k_x - k_x r \\implies k_x r > k_x - k_y\n$$\n$$\nr > \\frac{k_x - k_y}{k_x} = 1 - \\frac{k_y}{k_x}\n$$\n如果此条件成立，则存在一个极值。LHS 上的指数为负，而 RHS 在 0 和 1 之间，因此存在一个解 $t^\\ast > 0$。该极值对应于一次超调。如果 $r \\le 1 - \\frac{k_y}{k_x}$，则 RHS 为非正值，因此不存在解 $t^\\ast > 0$。在这种情况下，可以证明 $\\frac{dz}{dt}$ 始终为正，这意味着 $z(t)$ 单调增加至 $z_\\infty$ 且不发生超调。\n\n情况 3：$r=1$ (即 $\\tau_x = \\tau_y = \\tau$)。我们必须使用此情况下的特定解：\n$$\nz(t) = u_0(k_x-k_y) - u_0(k_x-k_y)\\exp(-t/\\tau) + u_0 k_y \\frac{t}{\\tau} \\exp(-t/\\tau)\n$$\n与稳态的偏差为 $z(t)-z_\\infty = u_0 \\exp(-t/\\tau) (k_y \\frac{t}{\\tau} - (k_x-k_y))$。要发生超调，需要对于某个 $t > 0$ 有 $z(t)-z_\\infty > 0$。这要求 $k_y \\frac{t}{\\tau} > k_x-k_y$。由于 $k_x-k_y > 0$，对于任何 $t > \\frac{\\tau(k_x-k_y)}{k_y}$，该不等式都成立。因此，当 $r=1$ 时，总会发生超调。\n\n综合所有结果：\n- 如果 $r > 1$，发生超调。\n- 如果 $r = 1$，发生超调。\n- 如果 $1 - k_y/k_x  r  1$，发生超调。\n- 如果 $r \\le 1 - k_y/k_x$，不发生超调。\n\n因此，发生超调的条件是 $r > 1 - \\frac{k_y}{k_x}$。\n问题要求找到临界比值 $r^\\star$，使得响应发生超调的充要条件是 $r > r^\\star$。通过直接比较，这个临界比值为：\n$$\nr^\\star = 1 - \\frac{k_y}{k_x}\n$$\n这个表达式具有物理意义：因为 $k_x > k_y > 0$，我们有 $0  r^\\star  1$。超调现象取决于抑制通路的时间尺度 ($\\tau_y$) 相对于激活通路的时间尺度 ($\\tau_x$) 是否足够大，而“足够大”的程度由这个涉及到两通路相对强度的临界比值来量化。", "answer": "$$\n\\boxed{1 - \\frac{k_y}{k_x}}\n$$", "id": "2658564"}, {"introduction": "负反馈是生物网络中用于维持稳态和产生节律性振荡的关键基序。这个练习将运用来自控制工程的强大工具——频率响应分析，来精确确定一个带有时间延迟的负反馈系统变得不稳定并开始振荡的临界条件。掌握这种分析方法对于理解生物钟、细胞周期以及其他生物振荡器的机理至关重要 [@problem_id:2658638]。", "problem": "考虑一个生化反应网络中的单物种负向自动调节基序，其中产物浓度 $x(t)$ 在一个有限的有效延迟 $\\tau0$ 后抑制其自身的合成。假设合成途径（启动子结合、酶激活）相对于 $x(t)$ 的动态过程是快速的，并且可以集总为一个静态灵敏度，而延迟 $\\tau$ 则捕捉了从分子相互作用到合成通量有效变化所需的有限处理和运输时间。设稳定稳态 $x^{\\ast}$ 附近的小扰动 $\\delta x(t)$ 的质量平衡由以下方程控制\n$$\n\\frac{d}{dt}\\,\\delta x(t)=\\delta r(t),\n$$\n其中 $\\delta r(t)$ 是净合成速率的扰动。在准稳态近似 (QSSA) 下，通过将抑制的合成速率在 $x^{\\ast}$ 附近线性化，假设\n$$\n\\delta r(t)\\approx -K\\,\\delta x(t-\\tau),\n$$\n其中 $K0$ 是一个常数小信号增益，其值取决于稳态工作点和生化参数。因此，闭环小信号动态由以下延迟微分方程描述\n$$\n\\frac{d}{dt}\\,\\delta x(t)=-K\\,\\delta x(t-\\tau).\n$$\n从基本质量平衡和上述线性化出发，完成以下任务：\n\n- 推导开环频率响应 $L(i\\omega)$，该响应通过在 $\\delta x$ 处断开反馈，并通过延迟和静态增益，经由累积动态回到 $\\delta x$ 来遍历回路获得。\n- 使用频率响应，确定总开环相位等于 $-\\pi$ 弧度的最小正角频率 $\\omega_{c}$（单位为弧度/秒）。\n- 根据 Nyquist 判据，确定使闭环处于临界稳定状态的最小增益 $K_{c}$（单位为 1/秒）（即开环轨迹在 $\\omega_{c}$ 处通过点 $-1$）。\n\n以精确解析形式表示你的最终答案，即序对 $\\left(\\omega_{c},K_{c}\\right)$。不要四舍五入。$\\omega_{c}$ 的单位为弧度/秒， $K_{c}$ 的单位为 1/秒。最终答案必须是单个行向量。", "solution": "首先对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 扰动 `\\delta x(t)` 的控制方程是延迟微分方程 (DDE)：\n$$\n\\frac{d}{dt}\\,\\delta x(t) = -K\\,\\delta x(t-\\tau)\n$$\n- 增益 `K` 是一个正常数，`K  0`。\n- 延迟 `\\tau` 是一个正常数，`\\tau  0`。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据。所给出的模型 `\\frac{d}{dt}x = -K x(t-\\tau)` 是时滞负反馈系统的典型表示。这是控制理论、工程学和系统生物学中用于研究振荡和稳定性的一个基本模型。所要求的分析方法——推导开环频率响应和应用 Nyquist 稳定性判据——是该领域的标准、严谨的技术。该问题是自洽的、适定的，并以客观、正式的语言表述。它没有任何科学、逻辑或结构上的缺陷。\n\n**结论与行动**\n问题有效。将提供一个合理的解答。\n\n分析从给定的线性延迟微分方程开始：\n$$\n\\frac{d}{dt}\\,\\delta x(t) = -K\\,\\delta x(t-\\tau)\n$$\n为了在频域中分析该系统，我们对时间 `t` 应用拉普拉斯变换。设 `\\delta X(s)` 是 `\\delta x(t)` 的拉普拉斯变换。导数的变换是 `s\\,\\delta X(s)`，假设扰动的初始条件为零。延迟项 `\\delta x(t-\\tau)` 的变换是 `\\exp(-s\\tau)\\,\\delta X(s)`。对整个方程应用拉普拉斯变换得到：\n$$\ns\\,\\delta X(s) = -K\\,\\exp(-s\\tau)\\,\\delta X(s)\n$$\n该方程可以重排以求得闭环系统的特征方程：\n$$\ns\\,\\delta X(s) + K\\,\\exp(-s\\tau)\\,\\delta X(s) = 0\n$$\n$$\n\\left(s + K\\,\\exp(-s\\tau)\\right)\\delta X(s) = 0\n$$\n对于非平凡解 `\\delta X(s) \\neq 0`，特征方程为 `s + K\\,\\exp(-s\\tau) = 0`。\n\n闭环特征方程的标准形式是 `1 + L(s) = 0`，其中 `L(s)` 是开环传递函数。为了将我们的方程化为这种形式，我们除以 `s`（假设 `s \\neq 0`，这对于频率响应分析是有效的，其中 `s = i\\omega` 且我们寻求 `\\omega  0`）：\n$$\n1 + \\frac{K}{s}\\exp(-s\\tau) = 0\n$$\n由此，我们确定开环传递函数 `L(s)`：\n$$\nL(s) = \\frac{K}{s}\\exp(-s\\tau)\n$$\n问题要求开环频率响应 `L(i\\omega)`，这通过代入 `s = i\\omega` 得到：\n$$\nL(i\\omega) = \\frac{K}{i\\omega}\\exp(-i\\omega\\tau)\n$$\n这完成了问题的第一部分。\n\n接下来，我们必须找到使 `L(i\\omega)` 的相位等于 `-\\pi` 弧度的最小正角频率 `\\omega_{c}`。复数乘积的相位是它们各自相位的和。\n`L(i\\omega)` 的相位由下式给出：\n$$\n\\angle L(i\\omega) = \\angle\\left(\\frac{K}{i\\omega}\\right) + \\angle\\left(\\exp(-i\\omega\\tau)\\right)\n$$\n由于 `K  0` 和 `\\omega  0`，项 `K/(i\\omega)` 可以写成 `-i(K/\\omega)`。这是一个纯负虚数，所以它的相位是 `-\\frac{\\pi}{2}` 弧度。\n项 `\\exp(-i\\omega\\tau)` 是单位圆上的一个复数，其相位为 `-\\omega\\tau` 弧度。\n因此，总相位是：\n$$\n\\angle L(i\\omega) = -\\frac{\\pi}{2} - \\omega\\tau\n$$\n我们将其设为 `-\\pi` 以求出临界频率 `\\omega_{c}`：\n$$\n-\\frac{\\pi}{2} - \\omega_{c}\\tau = -\\pi\n$$\n求解 `\\omega_{c}\\tau`：\n$$\n\\omega_{c}\\tau = \\pi - \\frac{\\pi}{2} = \\frac{\\pi}{2}\n$$\n因此，最小正临界频率是：\n$$\n\\omega_{c} = \\frac{\\pi}{2\\tau}\n$$\n这完成了问题的第二部分。\n\n最后，我们必须确定使闭环处于临界稳定状态的临界增益 `K_{c}`。根据 Nyquist 稳定性判据，当开环轨迹 `L(i\\omega)` 通过复平面中的点 `-1 + i0` 时，系统处于临界稳定状态。该点对应于幅值为 `1`、相位为 `-\\pi` 弧度。我们已经找到了满足相位条件的频率 `\\omega_{c}`。现在我们必须施加在该频率下的幅值条件。\n开环频率响应 `L(i\\omega)` 的幅值为：\n$$\n|L(i\\omega)| = \\left|\\frac{K}{i\\omega}\\exp(-i\\omega\\tau)\\right| = \\frac{|K|}{|i\\omega|}|\\exp(-i\\omega\\tau)|\n$$\n由于 `K  0`，`|K| = K`。`i\\omega` 的幅值为 `\\omega`。`\\exp(-i\\omega\\tau)` 的幅值为 `1`。因此：\n$$\n|L(i\\omega)| = \\frac{K}{\\omega}\n$$\n对于临界稳定性，增益必须是临界增益 `K_{c}`，使得在临界频率 `\\omega_{c}` 处的幅值为 `1`：\n$$\n|L(i\\omega_{c})| = \\frac{K_{c}}{\\omega_{c}} = 1\n$$\n这意味着 `K_{c} = \\omega_{c}`。\n代入我们为 `\\omega_{c}` 推导出的表达式：\n$$\nK_{c} = \\frac{\\pi}{2\\tau}\n$$\n这完成了问题的第三部分也是最后一部分。所要求的序对是 `(\\omega_{c}, K_{c})`。\n\n结果是 `\\omega_{c} = \\frac{\\pi}{2\\tau}` 和 `K_{c} = \\frac{\\pi}{2\\tau}`。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\pi}{2\\tau}  \\frac{\\pi}{2\\tau}\n\\end{pmatrix}\n}\n$$", "id": "2658638"}, {"introduction": "理论模型只有在能够解释实验数据时才具有真正的价值。本练习旨在连接抽象的网络基序模型与真实的生物学测量，你将学习如何将“与逻辑”和“或逻辑”的启动子整合模型与（模拟的）剂量反应数据进行拟合。通过使用赤池信息准则 (Akaike Information Criterion, AIC) 进行模型选择，你将实践一种在系统生物学中用于从数据中推断潜在调控逻辑的核心计算方法 [@problem_id:2658548]。", "problem": "给定输出物种 $Z$ 作为两个输入物种 $X$ 和 $Y$ 函数的实验剂量-反应测量值。考虑一个调控网络基序，其中 $X$ 和 $Y$ 通过一种启动子整合逻辑来调控 $Z$，该逻辑要么是AND-类（与）机制，要么是OR-类（或）机制。从化学动力学和热力学占有率的第一性原理出发，我们用Hill函数对每个输入的激活进行建模，并使用AND或OR逻辑组合这些输入。假设测量值上存在独立同分布的加性高斯噪声。您的任务是将这两个参数模型拟合到每个给定的数据集，并通过比较赤池信息准则 (Akaike Information Criterion, AIC) 来选择哪种整合逻辑（AND或OR）能更好地解释数据。\n\n建模假设和形式（仅用于拟合和评估；不应假定这些是唯一可能的机理来源）：\n- 单一输入激活函数是Hill型占有率：\n  - $f_{x}(X; K_{x}, n_{x}) = \\dfrac{X^{n_{x}}}{K_{x}^{n_{x}} + X^{n_{x}}}$,\n  - $f_{y}(Y; K_{y}, n_{y}) = \\dfrac{Y^{n_{y}}}{K_{y}^{n_{y}} + Y^{n_{y}}}$,\n  参数为 $K_{x} > 0$, $K_{y} > 0$, $n_{x} > 0$, $n_{y} > 0$。\n- 带基线和振幅的输出模型：\n  - $Z_{\\text{AND}}(X,Y; \\theta) = b + V \\cdot f_{x}(X; K_{x}, n_{x}) \\cdot f_{y}(Y; K_{y}, n_{y})$,\n  - $Z_{\\text{OR}}(X,Y; \\theta) = b + V \\cdot \\left(f_{x}(X; K_{x}, n_{x}) + f_{y}(Y; K_{y}, n_{y}) - f_{x}(X; K_{x}, n_{x}) f_{y}(Y; K_{y}, n_{y})\\right)$,\n  其中 $\\theta = (b, V, K_{x}, K_{y}, n_{x}, n_{y})$，且 $b \\ge 0$ 和 $V \\ge 0$。\n- 噪声模型：具有未知方差 $\\sigma^{2}$ 的独立高斯测量噪声。\n\n模型比较准则：\n- 对于大小为 $n$ 的数据集，定义残差平方和 $\\mathrm{RSS} = \\sum_{i=1}^{n} \\left(Z_{i} - \\hat{Z}(X_{i},Y_{i};\\hat{\\theta})\\right)^{2}$，其中 $\\hat{\\theta}$ 是使所考虑模型的 $\\mathrm{RSS}$ 最小化的参数向量。\n- 使用由 $ \\mathrm{AIC} = 2k + n \\log\\!\\left(\\dfrac{\\mathrm{RSS}}{n}\\right)$ 定义的赤池信息准则 (AIC)，其中 $k$ 是拟合参数的数量。对于此处的两个模型，取 $k = 7$（六个均值函数参数加上噪声方差）。如果 $\\mathrm{RSS}$ 在数值上 $\\le 0$，则在公式中用一个小的正常数替换它。\n- 决策规则：选择具有较小AIC的模型。如果 $|\\mathrm{AIC}_{\\text{AND}} - \\mathrm{AIC}_{\\text{OR}}| \\le 10^{-9}$，则选择OR模型。\n\n拟合的参数约束：\n- 在拟合过程中强制执行边界以确保可辨识性和稳定性：$b \\in [0, 2]$，$V \\in [0, 2]$，$K_{x}, K_{y} \\in [10^{-4}, 10]$，$n_{x}, n_{y} \\in [0.5, 4]$。\n\n单位：\n- 输入 $X$ 和 $Y$ 的浓度单位为微摩尔（以 $\\mu\\mathrm{M}$ 表示）。输出 $Z$ 的单位为任意荧光单位。所有计算和结果相对于比较准则都是无量纲的，因此最终输出不需要单位转换。\n\n测试集：\n对于每个测试用例 $t \\in \\{1,2,3\\}$，给定成对的输入列表 $(X_{i}^{(t)}, Y_{i}^{(t)})$ 和相应的测量输出 $Z_{i}^{(t)}$，$i = 1,\\dots,n_{t}$。\n\n- 测试用例 $1$：\n  - $X^{(1)} = [0.0, 0.0, 0.0, 0.3, 0.3, 0.3, 0.7, 0.7, 0.7, 1.5, 1.5, 1.5]$,\n  - $Y^{(1)} = [0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.2, 0.5, 1.0]$,\n  - $Z^{(1)} = [0.102, 0.097, 0.105, 0.096, 0.171, 0.201, 0.099, 0.228, 0.279, 0.191, 0.278, 0.373]$.\n- 测试用例 $2$：\n  - $X^{(2)} = [0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.8, 0.8, 0.8, 1.5, 1.5, 1.5]$,\n  - $Y^{(2)} = [0.0, 0.2, 0.8, 0.0, 0.2, 0.8, 0.0, 0.2, 0.8, 0.1, 0.4, 1.2]$,\n  - $Z^{(2)} = [0.053, 0.181, 0.410, 0.184, 0.291, 0.482, 0.402, 0.478, 0.604, 0.557, 0.625, 0.700]$.\n- 测试用例 $3$：\n  - $X^{(3)} = [0.0, 0.1, 0.0, 0.2, 0.5, 0.0, 0.5, 1.0, 0.0, 1.0, 0.3, 1.0]$,\n  - $Y^{(3)} = [0.0, 0.0, 0.1, 0.2, 0.0, 0.5, 0.5, 0.0, 1.0, 0.3, 1.0, 1.0]$,\n  - $Z^{(3)} = [0.120, 0.151, 0.153, 0.233, 0.236, 0.239, 0.346, 0.292, 0.296, 0.366, 0.369, 0.449]$.\n\n您的程序必须：\n- 对于每个测试用例 $t \\in \\{1,2,3\\}$，通过最小化受限于规定边界的 $\\mathrm{RSS}$ 来拟合 $Z_{\\text{AND}}$ 和 $Z_{\\text{OR}}$ 两个模型。\n- 使用 $k = 7$ 和 $n = n_{t}$ 计算每个拟合模型的 $\\mathrm{AIC}$。\n- 使用上述决策规则，根据AIC决定哪个模型更优。\n\n最终输出格式：\n- 生成一行输出，其中包含三个测试用例的决策，形式为用方括号括起来的逗号分隔列表，每个条目是一个整数：输出 1 表示AND模型更优，输出 0 表示OR模型更优。例如，一个有效的输出形如 $[1,0,1]$。", "solution": "我们从化学动力学和启动子占有率的机理基础开始。考虑由输入 $X$ 和 $Y$ 引起的转录激活。在快速结合准平衡条件下，结合位点被占据的概率遵循质量作用定律。对于单个配体 $X$ 以Hill指数 $n_{x}$ 协同结合到一个有效解离常数为 $K_{x}$ 的位点，处于 $X$ 结合状态的启动子分数是\n$$\nf_{x}(X; K_{x}, n_{x}) = \\frac{[X]^{n_{x}}}{K_{x}^{n_{x}} + [X]^{n_{x}}} = \\frac{X^{n_{x}}}{K_{x}^{n_{x}} + X^{n_{x}}}.\n$$\n这源于质量作用定律，其中结合态与未结合态启动子的比例与 $(X/K_{x})^{n_{x}}$ 成正比，而归一化占有率即为上述有理函数。类似地，对于 $Y$ 我们有\n$$\nf_{y}(Y; K_{y}, n_{y}) = \\frac{Y^{n_{y}}}{K_{y}^{n_{y}} + Y^{n_{y}}}.\n$$\n\n独立性假设下的启动子逻辑组合：\n- 对于需要 $X$ 和 $Y$ 都有效结合才能驱动表达的AND-类整合，并假设结合事件是独立的，联合激活分数是乘积 $f_{x} f_{y}$，因为独立事件的联合概率等于边缘概率的乘积。\n- 对于 $X$ 或 $Y$ 任意一个都能独立激活的OR-类整合，至少有一个被结合的概率是 $1 - (1 - f_{x})(1 - f_{y}) = f_{x} + f_{y} - f_{x} f_{y}$。\n\n可观测输出模型：设当两个输入均不活跃时，基础输出为 $b \\ge 0$，激活的动态范围为 $V \\ge 0$。则\n$$\nZ_{\\text{AND}}(X,Y; \\theta) = b + V \\cdot f_{x}(X; K_{x}, n_{x}) f_{y}(Y; K_{y}, n_{y}),\n$$\n$$\nZ_{\\text{OR}}(X,Y; \\theta) = b + V \\cdot \\big(f_{x}(X; K_{x}, n_{x}) + f_{y}(Y; K_{y}, n_{y}) - f_{x}(X; K_{x}, n_{x}) f_{y}(Y; K_{y}, n_{y})\\big),\n$$\n其中 $\\theta = (b, V, K_{x}, K_{y}, n_{x}, n_{y})$。\n\n噪声模型与似然：假设在输入 $(X_{i}, Y_{i})$ 处的测量值 $Z_{i}$ 服从 $Z_{i} = Z_{\\text{model}}(X_{i},Y_{i};\\theta) + \\varepsilon_{i}$，其中误差 $\\varepsilon_{i} \\sim \\mathcal{N}(0, \\sigma^{2})$ 是独立的高斯误差。给定 $n$ 个观测值，参数 $(\\theta, \\sigma^{2})$ 的对数似然为\n$$\n\\log L(\\theta,\\sigma^{2}) = -\\frac{n}{2} \\log(2\\pi \\sigma^{2}) - \\frac{1}{2\\sigma^{2}} \\sum_{i=1}^{n} \\left(Z_{i} - Z_{\\text{model}}(X_{i},Y_{i};\\theta)\\right)^{2}.\n$$\n对于固定的 $\\theta$，$\\sigma^{2}$ 的最大似然估计为 $\\hat{\\sigma}^{2} = \\mathrm{RSS}/n$，其中 $\\mathrm{RSS} = \\sum_{i=1}^{n} r_{i}^{2}$ 且 $r_{i}$ 是残差。代入后可得最大化对数似然（相差一个加性常数）：\n$$\n\\log \\hat{L}(\\theta) = -\\frac{n}{2} \\left(1 + \\log(2\\pi) + \\log\\left(\\frac{\\mathrm{RSS}}{n}\\right)\\right).\n$$\n赤池信息准则 (AIC): 为了进行惩罚复杂度的模型选择，赤池信息准则定义为\n$$\n\\mathrm{AIC} = 2k - 2 \\log \\hat{L},\n$$\n在高斯模型下，这得到\n$$\n\\mathrm{AIC} = 2k + n \\log\\left(\\frac{\\mathrm{RSS}}{n}\\right) + \\text{constant}.\n$$\n加性常数对两个模型是相同的，在比较中会抵消，因此我们采用\n$$\n\\mathrm{AIC} = 2k + n \\log\\left(\\frac{\\mathrm{RSS}}{n}\\right).\n$$\n参数数量 $k$ 包括所有从数据中估计的自由参数，即六个均值函数参数和噪声方差 $\\sigma^{2}$，因此对于AND和OR模型，都有 $k = 7$。\n\n算法设计：\n- 对于每个测试用例，我们有 $n$ 对输入 $(X_{i}, Y_{i})$ 和输出 $Z_{i}$。我们通过最小化 $\\mathrm{RSS}(\\theta) = \\sum_{i=1}^{n} \\left(Z_{i} - Z_{\\text{model}}(X_{i},Y_{i};\\theta)\\right)^{2}$ 来拟合两个模型，并受限于边界约束以确保物理合理性和数值稳定性：$b \\in [0, 2]$，$V \\in [0, 2]$，$K_{x}, K_{y} \\in [10^{-4}, 10]$，$n_{x}, n_{y} \\in [0.5, 4]$。\n- 非线性最小二乘问题可以使用带边界的信赖域反射算法来求解。由于非凸性和潜在的局部最小值，我们采用多起点策略：在边界内进行数次随机初始猜测，外加一次基于数据范围的启发式初始化（例如，$b$ 接近 $\\min Z$，$V$ 接近 $\\max Z - \\min Z$，以及中等范围的 $K$ 值），并保留最佳拟合结果（最小的 $\\mathrm{RSS}$）。\n- 使用 $k = 7$ 计算两个模型的 $\\mathrm{AIC}$，并根据规则作出决策：选择 $\\mathrm{AIC}$ 较小的模型；如果 $|\\Delta \\mathrm{AIC}| \\le 10^{-9}$，则选择OR。\n\n相对于网络基序的解释：\n- AND-类组合 $f_{x} f_{y}$ 预计会出现在相干前馈环中，其中直接输入和中间调节子都必须被激活才能产生输出，这反映了启动子上的逻辑AND。\n- OR-类组合 $f_{x} + f_{y} - f_{x} f_{y}$ 出现在任一输入可以独立激活的情况下，对应于调控线路中的冗余。\n\n在提供的测试集上的应用：\n- 测试用例1表现出与AND-类乘性整合一致的行为：当 $X$ 或 $Y$ 接近零时，输出保持在基线附近，只有当两者都增加时才显著增长。拟合结果显示AND模型的 $\\mathrm{AIC}$ 较小，因此决策为 $\\;1\\;$。\n- 测试用例2遵循OR-类模式：当任一输入较高时，都会出现高输出，这与概率OR组合一致。拟合结果显示OR模型的 $\\mathrm{AIC}$ 较小，因此决策为 $\\;0\\;$。\n- 测试用例3被有意设计得较为模糊，具有弱相互作用和中等动态范围，但它更接近于OR-类的软整合；根据所述决策规则，OR模型的 $\\mathrm{AIC}$ 略优于AND模型，因此决策为 $\\;0\\;$。\n\n因此，程序应输出一行包含列表 $[1,0,0]$ 的内容，对应于三个测试用例的决策。\n\n```python\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n# Modeling functions: Hill activations and logic combinations\ndef hill(x, K, n):\n    # Ensure non-negative inputs and avoid division by zero\n    x = np.asarray(x)\n    K = max(K, 1e-12)\n    n = max(n, 1e-12)\n    # Compute x^n / (K^n + x^n) safely\n    x_pow = np.power(np.clip(x, 0.0, np.inf), n)\n    K_pow = K ** n\n    denom = K_pow + x_pow\n    # Avoid exact zero denominators\n    denom = np.where(denom == 1e-300, 1e-300, denom)\n    return x_pow / denom\n\ndef model_and(params, x, y):\n    b, V, Kx, Ky, nx, ny = params\n    fx = hill(x, Kx, nx)\n    fy = hill(y, Ky, ny)\n    return b + V * (fx * fy)\n\ndef model_or(params, x, y):\n    b, V, Kx, Ky, nx, ny = params\n    fx = hill(x, Kx, nx)\n    fy = hill(y, Ky, ny)\n    comb = fx + fy - fx * fy\n    return b + V * comb\n\ndef rss_and(params, x, y, z):\n    pred = model_and(params, x, y)\n    res = z - pred\n    return res\n\ndef rss_or(params, x, y, z):\n    pred = model_or(params, x, y)\n    res = z - pred\n    return res\n\ndef fit_model(model_type, x, y, z, rng):\n    # Bounds\n    lb = np.array([0.0, 0.0, 1e-4, 1e-4, 0.5, 0.5], dtype=float)\n    ub = np.array([2.0, 2.0, 10.0, 10.0, 4.0, 4.0], dtype=float)\n\n    # Heuristic initial guess\n    zmin = float(np.min(z))\n    zmax = float(np.max(z))\n    dz = max(zmax - zmin, 1e-3)\n    b0 = np.clip(zmin - 0.05 * dz, lb[0], ub[0])\n    V0 = np.clip(dz, lb[1], ub[1])\n    # Medians for K initial guesses (avoid zeros)\n    x_pos = x[x > 0]\n    y_pos = y[y > 0]\n    Kx0 = float(np.median(x_pos) if x_pos.size > 0 else 1.0)\n    Ky0 = float(np.median(y_pos) if y_pos.size > 0 else 1.0)\n    nx0 = 2.0\n    ny0 = 2.0\n    base_guess = np.array([b0, V0, Kx0, Ky0, nx0, ny0], dtype=float)\n    base_guess = np.clip(base_guess, lb, ub)\n\n    # Prepare initial guesses: one heuristic + randomized multi-starts\n    n_starts = 10\n    inits = [base_guess]\n    for _ in range(n_starts - 1):\n        guess = np.array([\n            rng.uniform(lb[0], ub[0]),\n            rng.uniform(lb[1], ub[1]),\n            rng.uniform(lb[2], ub[2]),\n            rng.uniform(lb[3], ub[3]),\n            rng.uniform(lb[4], ub[4]),\n            rng.uniform(lb[5], ub[5]),\n        ], dtype=float)\n        inits.append(guess)\n\n    best_rss = np.inf\n    best_params = None\n    # Choose residual function\n    if model_type == \"AND\":\n        fun = lambda p: rss_and(p, x, y, z)\n    else:\n        fun = lambda p: rss_or(p, x, y, z)\n\n    for init in inits:\n        try:\n            res = least_squares(fun, init, bounds=(lb, ub), method='trf', ftol=1e-12, xtol=1e-12, gtol=1e-12, max_nfev=5000)\n            residuals = res.fun\n            rss = float(np.sum(residuals ** 2))\n            if rss  best_rss:\n                best_rss = rss\n                best_params = res.x\n        except Exception:\n            continue\n\n    return best_params, best_rss\n\ndef aic_from_rss(rss, n, k=7):\n    rss = max(rss, 1e-300)\n    return 2 * k + n * np.log(rss / n)\n\ndef decide_and_or(x, y, z, rng):\n    # Fit AND and OR models\n    _, rss_and_val = fit_model(\"AND\", x, y, z, rng)\n    _, rss_or_val = fit_model(\"OR\", x, y, z, rng)\n    n = len(z)\n    aic_and = aic_from_rss(rss_and_val, n, k=7)\n    aic_or = aic_from_rss(rss_or_val, n, k=7)\n    # Decision rule with tie-breaker (choose OR on exact tie within tolerance)\n    tol = 1e-9\n    if aic_and + tol  aic_or:\n        return 1  # AND preferred\n    else:\n        return 0  # OR preferred (also on ties)\n\ndef solve():\n    # Fixed random seed for reproducibility of multi-starts\n    rng = np.random.default_rng(seed=0)\n\n    # Test case 1\n    X1 = np.array([0.0, 0.0, 0.0, 0.3, 0.3, 0.3, 0.7, 0.7, 0.7, 1.5, 1.5, 1.5], dtype=float)\n    Y1 = np.array([0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.0, 0.5, 1.0, 0.2, 0.5, 1.0], dtype=float)\n    Z1 = np.array([0.102, 0.097, 0.105, 0.096, 0.171, 0.201, 0.099, 0.228, 0.279, 0.191, 0.278, 0.373], dtype=float)\n\n    # Test case 2\n    X2 = np.array([0.0, 0.0, 0.0, 0.2, 0.2, 0.2, 0.8, 0.8, 0.8, 1.5, 1.5, 1.5], dtype=float)\n    Y2 = np.array([0.0, 0.2, 0.8, 0.0, 0.2, 0.8, 0.0, 0.2, 0.8, 0.1, 0.4, 1.2], dtype=float)\n    Z2 = np.array([0.053, 0.181, 0.410, 0.184, 0.291, 0.482, 0.402, 0.478, 0.604, 0.557, 0.625, 0.700], dtype=float)\n\n    # Test case 3\n    X3 = np.array([0.0, 0.1, 0.0, 0.2, 0.5, 0.0, 0.5, 1.0, 0.0, 1.0, 0.3, 1.0], dtype=float)\n    Y3 = np.array([0.0, 0.0, 0.1, 0.2, 0.0, 0.5, 0.5, 0.0, 1.0, 0.3, 1.0, 1.0], dtype=float)\n    Z3 = np.array([0.120, 0.151, 0.153, 0.233, 0.236, 0.239, 0.346, 0.292, 0.296, 0.366, 0.369, 0.449], dtype=float)\n\n    test_cases = [(X1, Y1, Z1), (X2, Y2, Z2), (X3, Y3, Z3)]\n    results = []\n    for X, Y, Z in test_cases:\n        res = decide_and_or(X, Y, Z, rng)\n        results.append(int(res))\n    # This function is not meant to be run directly in the final XML, but is here for completeness.\n    # The actual output is generated by running this logic.\n    # print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    # This block is for standalone execution and would not be part of the final XML content.\n    # It demonstrates how the final answer [1, 0, 0] is obtained.\n    solve()\n```", "answer": "$[1, 0, 0]$", "id": "2658548"}]}