{"hands_on_practices": [{"introduction": "本练习旨在通过计算 Newman-Girvan 模块度分数 $Q$ 来量化网络模块化，是一项基础性训练。通过对一个假设网络的不同划分手动计算 $Q$ 值，您将对这一广泛使用的指标的运作方式有具体的理解。本练习旨在揭示模块度最大化的一个关键局限性——分辨率极限，表明即使是直观的模块结构，如果其规模相对于网络的其他部分过小，也可能无法被检测到。[@problem_id:2656674]", "problem": "考虑一个可逆化学反应网络，该网络表示为一个无向、无权图，其中顶点是化学物种，两个物种之间的无向边表示它们共同参与至少一个可逆反应步骤。该网络被组织成 $3$ 个假设的模块，记为 $\\mathcal{A}$、$\\mathcal{B}$ 和 $\\mathcal{C}$。模块 $\\mathcal{A}$ 和 $\\mathcal{B}$ 都是稠密且小的；具体来说，每个都是一个包含 $5$ 个顶点的完全子图，因此每个都有 $10$ 条内部边。模块 $\\mathcal{C}$ 是一个较大的稠密子图，其内部边的数量未知，记为 $L_{\\mathcal{C}} \\in \\mathbb{N}$。在模块之间，$\\mathcal{A}$ 和 $\\mathcal{B}$ 之间恰好有 $1$ 条边，$\\mathcal{A}$ 和 $\\mathcal{C}$ 之间恰好有 $1$ 条边，$\\mathcal{B}$ 和 $\\mathcal{C}$ 之间也恰好有 $1$ 条边；不存在其他边。你可以假设使用标准的 Newman–Girvan 模块度定义来处理无向、无权网络，并且可以将给定的 $3$ 模块分配视为一个候选划分。\n\n计算包含 $3$ 个独立模块 $\\{\\mathcal{A}\\}, \\{\\mathcal{B}\\}, \\{\\mathcal{C}\\}$ 的划分的模块度 $Q$，以及两个小模块合并后的划分 $\\{\\mathcal{A}\\cup\\mathcal{B}\\}, \\{\\mathcal{C}\\}$ 的模块度 $Q$。通过比较这两个值，确定最小整数 $L_{\\mathcal{C}}^{\\star}$，使得合并后的划分的模块度严格高于 $3$ 模块划分的模块度。你的最终答案必须是单个整数 $L_{\\mathcal{C}}^{\\star}$，无需单位，也无需四舍五入。", "solution": "该问题要求确定网络模块 $\\mathcal{C}$ 中内部边数 $L_{\\mathcal{C}}$ 的一个条件，使得合并另外两个模块 $\\mathcal{A}$ 和 $\\mathcal{B}$ 会导致网络模块度的严格增加。\n\n首先，我们必须定义模块度。对于一个被划分为一组社区（模块）的无向、无权网络，其 Newman-Girvan 模块度 $Q$ 由以下公式给出：\n$$Q = \\sum_{s} \\left( e_s - a_s^2 \\right)$$\n其中，求和遍及划分中的所有模块 $s$。项 $e_s = \\frac{L_s}{m}$ 是网络中属于模块 $s$ 内部的边的比例，其中 $L_s$ 是两端都在模块 $s$ 内的边的数量，$m$ 是网络中边的总数。项 $a_s = \\frac{d_s}{2m}$ 是连接到模块 $s$ 中顶点的所有边“末梢”的比例，其中 $d_s$ 是模块 $s$ 中所有顶点的度之和。这可以重写为：\n$$Q = \\sum_{s} \\left[ \\frac{L_s}{m} - \\left(\\frac{d_s}{2m}\\right)^2 \\right]$$\n\n为了继续，我们必须计算两个给定划分的必要参数。\n该网络由三个模块组成：$\\mathcal{A}$、$\\mathcal{B}$ 和 $\\mathcal{C}$。\n模块 $\\mathcal{A}$ 是一个包含 $n_{\\mathcal{A}} = 5$ 个顶点的完全图，因此其内部边数为 $L_{\\mathcal{A}} = \\binom{5}{2} = 10$。\n模块 $\\mathcal{B}$ 是一个包含 $n_{\\mathcal{B}} = 5$ 个顶点的完全图，因此其内部边数为 $L_{\\mathcal{B}} = \\binom{5}{2} = 10$。\n模块 $\\mathcal{C}$ 有未知数量的内部边 $L_{\\mathcal{C}}$。\n模块间的连接是给定的：$\\mathcal{A}$ 和 $\\mathcal{B}$ 之间有一条边，$\\mathcal{A}$ 和 $\\mathcal{C}$ 之间有一条边，$\\mathcal{B}$ 和 $\\mathcal{C}$ 之间也有一条边。没有其他边。\n\n网络中的总边数 $m$ 是所有内部边和模块间边的总和：\n$$m = L_{\\mathcal{A}} + L_{\\mathcal{B}} + L_{\\mathcal{C}} + E_{\\mathcal{A}\\mathcal{B}} + E_{\\mathcal{A}\\mathcal{C}} + E_{\\mathcal{B}\\mathcal{C}} = 10 + 10 + L_{\\mathcal{C}} + 1 + 1 + 1 = 23 + L_{\\mathcal{C}}$$\n\n模块 $s$ 的总度 $d_s$ 是其节点的度之和。这可以计算为 $d_s = 2L_s + (\\text{连接到 } s \\text{ 的外部边数})$。\n对于模块 $\\mathcal{A}$：$d_{\\mathcal{A}} = 2L_{\\mathcal{A}} + E_{\\mathcal{A}\\mathcal{B}} + E_{\\mathcal{A}\\mathcal{C}} = 2(10) + 1 + 1 = 22$。\n对于模块 $\\mathcal{B}$：$d_{\\mathcal{B}} = 2L_{\\mathcal{B}} + E_{\\mathcal{A}\\mathcal{B}} + E_{\\mathcal{B}\\mathcal{C}} = 2(10) + 1 + 1 = 22$。\n对于模块 $\\mathcal{C}$：$d_{\\mathcal{C}} = 2L_{\\mathcal{C}} + E_{\\mathcal{A}\\mathcal{C}} + E_{\\mathcal{B}\\mathcal{C}} = 2L_{\\mathcal{C}} + 1 + 1 = 2L_{\\mathcal{C}} + 2$。\n\n现在，我们计算第一个划分 $P_1 = \\{\\mathcal{A}, \\mathcal{B}, \\mathcal{C}\\}$ 的模块度 $Q_1$。\n$$Q_1 = \\left[\\frac{L_{\\mathcal{A}}}{m} - \\left(\\frac{d_{\\mathcal{A}}}{2m}\\right)^2\\right] + \\left[\\frac{L_{\\mathcal{B}}}{m} - \\left(\\frac{d_{\\mathcal{B}}}{2m}\\right)^2\\right] + \\left[\\frac{L_{\\mathcal{C}}}{m} - \\left(\\frac{d_{\\mathcal{C}}}{2m}\\right)^2\\right]$$\n代入我们的值：\n$$Q_1 = \\left[\\frac{10}{m} - \\left(\\frac{22}{2m}\\right)^2\\right] + \\left[\\frac{10}{m} - \\left(\\frac{22}{2m}\\right)^2\\right] + \\left[\\frac{L_{\\mathcal{C}}}{m} - \\left(\\frac{2L_{\\mathcal{C}}+2}{2m}\\right)^2\\right]$$\n$$Q_1 = \\frac{20+L_{\\mathcal{C}}}{m} - \\frac{1}{m^2} \\left[ \\left(\\frac{22}{2}\\right)^2 + \\left(\\frac{22}{2}\\right)^2 + \\left(\\frac{2L_{\\mathcal{C}}+2}{2}\\right)^2 \\right]$$\n$$Q_1 = \\frac{20+L_{\\mathcal{C}}}{m} - \\frac{1}{m^2} \\left( 11^2 + 11^2 + (L_{\\mathcal{C}}+1)^2 \\right)$$\n$$Q_1 = \\frac{20+L_{\\mathcal{C}}}{m} - \\frac{121 + 121 + L_{\\mathcal{C}}^2 + 2L_{\\mathcal{C}} + 1}{m^2} = \\frac{20+L_{\\mathcal{C}}}{m} - \\frac{L_{\\mathcal{C}}^2 + 2L_{\\mathcal{C}} + 243}{m^2}$$\n为了合并这些项，我们使用 $m = 23 + L_{\\mathcal{C}}$：\n$$Q_1 = \\frac{(20+L_{\\mathcal{C}})(23+L_{\\mathcal{C}}) - (L_{\\mathcal{C}}^2 + 2L_{\\mathcal{C}} + 243)}{(23+L_{\\mathcal{C}})^2}$$\n$$Q_1 = \\frac{(460 + 43L_{\\mathcal{C}} + L_{\\mathcal{C}}^2) - (L_{\\mathcal{C}}^2 + 2L_{\\mathcal{C}} + 243)}{(23+L_{\\mathcal{C}})^2} = \\frac{41L_{\\mathcal{C}} + 217}{(23+L_{\\mathcal{C}})^2}$$\n\n接下来，我们计算第二个划分 $P_2 = \\{\\mathcal{M}, \\mathcal{C}\\}$ 的模块度 $Q_2$，其中 $\\mathcal{M} = \\mathcal{A} \\cup \\mathcal{B}$。\n对于合并后的模块 $\\mathcal{M}$，其内部边数是 $\\mathcal{A}$ 内部、$\\mathcal{B}$ 内部以及 $\\mathcal{A}$ 和 $\\mathcal{B}$ 之间的边的总和：\n$$L_{\\mathcal{M}} = L_{\\mathcal{A}} + L_{\\mathcal{B}} + E_{\\mathcal{A}\\mathcal{B}} = 10 + 10 + 1 = 21$$\n模块 $\\mathcal{M}$ 的总度是其组成模块的度之和：\n$$d_{\\mathcal{M}} = d_{\\mathcal{A}} + d_{\\mathcal{B}} = 22 + 22 = 44$$\n模块 $\\mathcal{C}$ 的参数（$L_{\\mathcal{C}}$，$d_{\\mathcal{C}}$）和总边数 $m$ 保持不变。\n模块度 $Q_2$ 为：\n$$Q_2 = \\left[\\frac{L_{\\mathcal{M}}}{m} - \\left(\\frac{d_{\\mathcal{M}}}{2m}\\right)^2\\right] + \\left[\\frac{L_{\\mathcal{C}}}{m} - \\left(\\frac{d_{\\mathcal{C}}}{2m}\\right)^2\\right]$$\n代入合并划分的值：\n$$Q_2 = \\left[\\frac{21}{m} - \\left(\\frac{44}{2m}\\right)^2\\right] + \\left[\\frac{L_{\\mathcal{C}}}{m} - \\left(\\frac{2L_{\\mathcal{C}}+2}{2m}\\right)^2\\right]$$\n$$Q_2 = \\frac{21+L_{\\mathcal{C}}}{m} - \\frac{1}{m^2} \\left[ \\left(\\frac{44}{2}\\right)^2 + \\left(\\frac{2L_{\\mathcal{C}}+2}{2}\\right)^2 \\right]$$\n$$Q_2 = \\frac{21+L_{\\mathcal{C}}}{m} - \\frac{1}{m^2} \\left( 22^2 + (L_{\\mathcal{C}}+1)^2 \\right)$$\n$$Q_2 = \\frac{21+L_{\\mathcal{C}}}{m} - \\frac{484 + L_{\\mathcal{C}}^2 + 2L_{\\mathcal{C}} + 1}{m^2} = \\frac{21+L_{\\mathcal{C}}}{m} - \\frac{L_{\\mathcal{C}}^2 + 2L_{\\mathcal{C}} + 485}{m^2}$$\n合并项：\n$$Q_2 = \\frac{(21+L_{\\mathcal{C}})(23+L_{\\mathcal{C}}) - (L_{\\mathcal{C}}^2 + 2L_{\\mathcal{C}} + 485)}{(23+L_{\\mathcal{C}})^2}$$\n$$Q_2 = \\frac{(483 + 44L_{\\mathcal{C}} + L_{\\mathcal{C}}^2) - (L_{\\mathcal{C}}^2 + 2L_{\\mathcal{C}} + 485)}{(23+L_{\\mathcal{C}})^2} = \\frac{42L_{\\mathcal{C}} - 2}{(23+L_{\\mathcal{C}})^2}$$\n\n我们的任务是找到最小的整数 $L_{\\mathcal{C}}^{\\star}$，使得合并后的划分严格增加了模块度。这对应于条件 $Q_2 > Q_1$。\n$$\\frac{42L_{\\mathcal{C}} - 2}{(23+L_{\\mathcal{C}})^2} > \\frac{41L_{\\mathcal{C}} + 217}{(23+L_{\\mathcal{C}})^2}$$\n由于 $L_{\\mathcal{C}}$ 表示边的数量，$L_{\\mathcal{C}} \\in \\mathbb{N}$，因此 $L_{\\mathcal{C}} \\ge 0$。分母 $(23+L_{\\mathcal{C}})^2$ 严格为正。因此，我们可以将不等式两边同乘以该项，而不会改变不等式的方向。\n$$42L_{\\mathcal{C}} - 2 > 41L_{\\mathcal{C}} + 217$$\n两边同时减去 $41L_{\\mathcal{C}}$，得到：\n$$L_{\\mathcal{C}} - 2 > 217$$\n两边同时加上 $2$，得到：\n$$L_{\\mathcal{C}} > 219$$\n问题要求满足此条件的 $L_{\\mathcal{C}}$ 的最小整数值，记为 $L_{\\mathcal{C}}^{\\star}$。严格大于 $219$ 的最小整数是 $220$。\n因此，$L_{\\mathcal{C}}^{\\star} = 220$。", "answer": "$$\\boxed{220}$$", "id": "2656674"}, {"introduction": "除了纯粹的结构定义，化学网络中的模块性还可以从系统动力学和守恒定律的角度来理解。本练习将引导您探索“守恒部分 (conserved moieties)”的概念，即在整个反应动力学过程中其总量保持守恒的物种群组。通过从化学计量矩阵中识别这些守恒部分，您将学习如何基于基本的物理约束来定义模块，这为拓扑聚类方法提供了一种强有力的替代视角。[@problem_id:2656659]", "problem": "一个封闭、充分混合的反应网络包含 $6$ 个化学物种 $\\{X_1,\\dots,X_6\\}$ 和 $6$ 个遵循质量作用动力学的基元反应 $\\{R_1,\\dots,R_6\\}$。该网络的结构特性由化学计量变化向量（列向量）$v_r \\in \\mathbb{Z}^{6}$ 规定，这些向量构成一个化学计量矩阵 $S \\in \\mathbb{Z}^{6 \\times 6}$，其中第 $j$ 列是 $v_j$。这些反应是：\n- $R_1: X_1 + X_4 \\rightarrow X_2 + X_5$，其 $v_1 = (-1,\\,+1,\\,0,\\,-1,\\,+1,\\,0)^{\\top}$，\n- $R_2: X_2 + X_5 \\rightarrow X_3 + X_4$，其 $v_2 = (0,\\,-1,\\,+1,\\,+1,\\,-1,\\,0)^{\\top}$，\n- $R_3: X_3 + X_4 \\rightarrow X_1 + X_5$，其 $v_3 = (+1,\\,0,\\,-1,\\,-1,\\,+1,\\,0)^{\\top}$，\n- $R_4: X_4 \\rightarrow X_5$，其 $v_4 = (0,\\,0,\\,0,\\,-1,\\,+1,\\,0)^{\\top}$，\n- $R_5: X_5 \\rightarrow X_4$，其 $v_5 = (0,\\,0,\\,0,\\,+1,\\,-1,\\,0)^{\\top}$，\n- $R_6: X_6 + X_5 \\rightarrow X_6 + X_4$，其 $v_6 = (0,\\,0,\\,0,\\,+1,\\,-1,\\,0)^{\\top}$。\n\n因此，\n$$\nS \\;=\\;\n\\begin{pmatrix}\n-1  & 0 & +1 & 0 & 0 & 0\\\\\n+1  & -1 & 0 & 0 & 0 & 0\\\\\n0  & +1 & -1 & 0 & 0 & 0\\\\\n-1  & +1 & -1 & -1 & +1 & +1\\\\\n+1  & -1 & +1 & +1 & -1 & -1\\\\\n0  & 0 & 0 & 0 & 0 & 0\n\\end{pmatrix}.\n$$\n\n一个守恒部分是任何满足 $l^{\\top} S = 0^{\\top}$ 的非零向量 $l \\in \\mathbb{R}^{6}$。一个守恒部分向量 $l$ 的支撑集是满足 $l_i \\neq 0$ 的索引 $i$ 的集合。考虑将物种划分为恰好两个非空模块 $\\mathcal{M}_1$ 和 $\\mathcal{M}_2$ 的模块划分。如果对于一个非负守恒部分基的每个基向量 $l$，其支撑集完全包含在 $\\mathcal{M}_1$ 或 $\\mathcal{M}_2$ 中，则该划分满足守恒部分完整性。\n\n定义一个划分的模块间相互作用权重如下：每个反应 $R_r$ 被赋予一个正常数无量纲权重 $w_r$，具体为\n$$\nw_1 = 2,\\;\\; w_2 = 1.5,\\;\\; w_3 = 1,\\;\\; w_4 = 0.2,\\;\\; w_5 = 0.2,\\;\\; w_6 = 0.8.\n$$\n对于一个给定的划分，当且仅当参与反应 $R_r$ 的物种集合（其反应物和产物的并集）不完全包含在单个模块内时，该反应对模块间相互作用权重贡献 $w_r$。\n\n任务：\n1. 仅从化学计量矩阵的定义、守恒部分作为满足 $l^{\\top} S = 0^{\\top}$ 的向量 $l$ 的定义，以及在 $\\mathbb{R}$ 上的线性代数出发，计算该网络守恒部分的一个非负基，并识别每个基向量支撑集中的物种。\n2. 在上述定义的守恒部分完整性约束下，在将 $6$ 个物种划分为恰好两个非空模块的所有划分中，确定一个使总模块间相互作用权重最小化的划分。将可达到的最小总模块间相互作用权重作为一个不带单位的实数报告。\n\n你的最终答案必须仅为最小总模块间相互作用权重。不要在最终答案中包含任何其他量。", "solution": "该问题提出了一个化学反应网络，并要求完成两个不同的任务。首先，确定系统的基本守恒定律；其次，利用这些定律找到物种的最优模块划分，以最小化模块间的化学相互作用。我将依次并以必要的严谨性来解决这些任务。\n\n首先，我们必须验证问题陈述的有效性。问题提供了一组 $6$ 个物种、$6$ 个反应、一个化学计量矩阵 $S \\in \\mathbb{Z}^{6 \\times 6}$、守恒部分的定义、一个划分约束以及一个待最小化的成本函数。所有定义和数据都已明确给出，并且与化学反应网络理论的标准形式体系一致。该问题具有科学依据、是良定的，且不包含任何歧义或矛盾。因此，这是一个有效的问题，我将继续进行解答。\n\n第1部分：计算守恒部分的非负基\n\n守恒部分被定义为满足 $l^{\\top} S = 0^{\\top}$ 的非零向量 $l \\in \\mathbb{R}^{6}$。这是化学计量矩阵 $S$ 的左零向量的标准定义。所有这些向量构成的集合形成一个向量空间，即 $S$ 的左零空间，记为 $\\text{ker}(S^{\\top})$。我们的任务是找到这个空间的一个基，并附加约束条件：基向量必须是非负的，即其所有分量都必须大于或等于零。\n\n待求解的线性方程组是 $S^{\\top} l = 0$，其中 $l = (l_1, l_2, l_3, l_4, l_5, l_6)^{\\top}$。给定化学计量矩阵 $S$ 的转置是：\n$$\nS^{\\top} = \n\\begin{pmatrix}\n-1 & 1 & 0 & -1 & 1 & 0 \\\\\n0 & -1 & 1 & 1 & -1 & 0 \\\\\n1 & 0 & -1 & -1 & 1 & 0 \\\\\n0 & 0 & 0 & -1 & 1 & 0 \\\\\n0 & 0 & 0 & 1 & -1 & 0 \\\\\n0 & 0 & 0 & 1 & -1 & 0\n\\end{pmatrix}\n$$\n我们执行高斯消元法来求 $S^{\\top}$ 的零空间。\n将第一行加到第三行（$R_3 \\leftarrow R_3 + R_1$）得到：\n$$\n\\begin{pmatrix}\n-1 & 1 & 0 & -1 & 1 & 0 \\\\\n0 & -1 & 1 & 1 & -1 & 0 \\\\\n0 & 1 & -1 & -2 & 2 & 0 \\\\\n0 & 0 & 0 & -1 & 1 & 0 \\\\\n0 & 0 & 0 & 1 & -1 & 0 \\\\\n0 & 0 & 0 & 1 & -1 & 0\n\\end{pmatrix}\n$$\n将第二行加到第三行（$R_3 \\leftarrow R_3 + R_2$）得到：\n$$\n\\begin{pmatrix}\n-1 & 1 & 0 & -1 & 1 & 0 \\\\\n0 & -1 & 1 & 1 & -1 & 0 \\\\\n0 & 0 & 0 & -1 & 1 & 0 \\\\\n0 & 0 & 0 & -1 & 1 & 0 \\\\\n0 & 0 & 0 & 1 & -1 & 0 \\\\\n0 & 0 & 0 & 1 & -1 & 0\n\\end{pmatrix}\n$$\n最后四行是线性相关的。我们可以将它们化简为一个唯一的非零行和若干零行，从而得到行阶梯形矩阵：\n$$\n\\begin{pmatrix}\n-1 & 1 & 0 & -1 & 1 & 0 \\\\\n0 & -1 & 1 & 1 & -1 & 0 \\\\\n0 & 0 & 0 & -1 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0\n\\end{pmatrix}\n$$\n与此矩阵对应的方程组是：\n1. $-l_1 + l_2 - l_4 + l_5 = 0$\n2. $-l_2 + l_3 + l_4 - l_5 = 0$\n3. $-l_4 + l_5 = 0$\n\n该矩阵的秩为 $3$，所以零空间的维数为 $6 - 3 = 3$。我们可以选择 $l_3$、$l_5$ 和 $l_6$ 作为自由变量。\n根据方程（3），我们有 $l_4 = l_5$。\n将 $l_4 = l_5$ 代入方程（2）得到 $-l_2 + l_3 = 0$，这意味着 $l_2 = l_3$。\n将 $l_2 = l_3$ 和 $l_4 = l_5$ 代入方程（1）得到 $-l_1 + l_3 - l_5 + l_5 = 0$，这意味着 $l_1 = l_3$。\n因此，通解向量 $l$ 是：\n$$\nl = \\begin{pmatrix} l_3 \\\\ l_3 \\\\ l_3 \\\\ l_5 \\\\ l_5 \\\\ l_6 \\end{pmatrix} = l_3 \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix} + l_5 \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 1 \\\\ 0 \\end{pmatrix} + l_6 \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix}\n$$\n通过将一个自由变量设为 $1$、其余设为 $0$ 得到的三個向量构成了守恒部分空间的一个基。它们是：\n$l^{(1)} = (1, 1, 1, 0, 0, 0)^{\\top}$\n$l^{(2)} = (0, 0, 0, 1, 1, 0)^{\\top}$\n$l^{(3)} = (0, 0, 0, 0, 0, 1)^{\\top}$\n这些向量完全由非负分量组成，因此它们构成一个有效的非负基。\n这些基向量的支撑集是：\n- $\\text{supp}(l^{(1)}) = \\{1, 2, 3\\}$，对应于物种 $\\{X_1, X_2, X_3\\}$。\n- $\\text{supp}(l^{(2)}) = \\{4, 5\\}$，对应于物种 $\\{X_4, X_5\\}$。\n- $\\text{supp}(l^{(3)}) = \\{6\\}$，对应于物种 $\\{X_6\\}$。\n\n第2部分：满足守恒部分完整性下的最优划分\n\n“守恒部分完整性”约束要求，对于任何将物种划分为两个模块 $\\mathcal{M}_1$ 和 $\\mathcal{M}_2$ 的有效划分，每个守恒部分基向量的支撑集必须完全位于一个模块内。这从根本上意味着每个支撑集内的物种不能被分开。物种集合 $\\{X_1, X_2, X_3\\}$、$\\{X_4, X_5\\}$ 和 $\\{X_6\\}$ 必须各自被视为一个不可分割的单元。我们用 $G_1 = \\{X_1, X_2, X_3\\}$，$G_2 = \\{X_4, X_5\\}$ 和 $G_3 = \\{X_6\\}$ 来表示这些单元。\n\n问题现在简化为将这三个单元的集合 $\\{G_1, G_2, G_3\\}$ 划分为两个非空模块。恰好存在三种这样的划分：\n1.  $\\mathcal{M}_1 = G_1$，$\\mathcal{M}_2 = G_2 \\cup G_3$。用物种表示为：$\\mathcal{M}_1 = \\{X_1, X_2, X_3\\}$，$\\mathcal{M}_2 = \\{X_4, X_5, X_6\\}$。\n2.  $\\mathcal{M}_1 = G_2$，$\\mathcal{M}_2 = G_1 \\cup G_3$。用物种表示为：$\\mathcal{M}_1 = \\{X_4, X_5\\}$，$\\mathcal{M}_2 = \\{X_1, X_2, X_3, X_6\\}$。\n3.  $\\mathcal{M}_1 = G_3$，$\\mathcal{M}_2 = G_1 \\cup G_2$。用物种表示为：$\\mathcal{M}_1 = \\{X_6\\}$，$\\mathcal{M}_2 = \\{X_1, X_2, X_3, X_4, X_5\\}$。\n\n现在我们必须计算每种划分的总模块间相互作用权重。一个权重为 $w_r$ 的反应 $R_r$，如果其参与物种（反应物和产物）不都包含在单个模块中，则它对该总权重有贡献。我们列出每个反应的参与物种集 $P_r$：\n- $R_1$: $P_1 = \\{X_1, X_4, X_2, X_5\\} \\subset G_1 \\cup G_2$。权重 $w_1 = 2$。\n- $R_2$: $P_2 = \\{X_2, X_5, X_3, X_4\\} \\subset G_1 \\cup G_2$。权重 $w_2 = 1.5$。\n- $R_3$: $P_3 = \\{X_3, X_4, X_1, X_5\\} \\subset G_1 \\cup G_2$。权重 $w_3 = 1$。\n- $R_4$: $P_4 = \\{X_4, X_5\\} \\subset G_2$。权重 $w_4 = 0.2$。\n- $R_5$: $P_5 = \\{X_5, X_4\\} \\subset G_2$。权重 $w_5 = 0.2$。\n- $R_6$: $P_6 = \\{X_6, X_5, X_4\\} \\subset G_2 \\cup G_3$。权重 $w_6 = 0.8$。\n\n现在我们评估每种划分的相互作用权重：\n\n情况1：$\\mathcal{M}_1 = G_1$，$\\mathcal{M}_2 = G_2 \\cup G_3$。\n- $R_1, R_2, R_3$ 涉及来自 $G_1$ 和 $G_2$ 的物种。由于 $G_1 \\subset \\mathcal{M}_1$ 且 $G_2 \\subset \\mathcal{M}_2$，这些反应跨越了模块。\n- $R_4, R_5$ 仅涉及来自 $G_2$ 的物种，而 $G_2$ 完全在 $\\mathcal{M}_2$ 中。这些是模块内反应。\n- $R_6$ 涉及来自 $G_2$ 和 $G_3$ 的物种，这两者都在 $\\mathcal{M}_2$ 中。这是模块内反应。\n总权重 $W_1 = w_1 + w_2 + w_3 = 2 + 1.5 + 1 = 4.5$。\n\n情况2：$\\mathcal{M}_1 = G_2$，$\\mathcal{M}_2 = G_1 \\cup G_3$。\n- $R_1, R_2, R_3$ 涉及来自 $G_1$ 和 $G_2$ 的物种。由于 $G_2 \\subset \\mathcal{M}_1$ 且 $G_1 \\subset \\mathcal{M}_2$，这些反应跨越了模块。\n- $R_4, R_5$ 仅涉及来自 $G_2$ 的物种，而 $G_2$ 完全在 $\\mathcal{M}_1$ 中。这些是模块内反应。\n- $R_6$ 涉及来自 $G_2$ 和 $G_3$ 的物种。由于 $G_2 \\subset \\mathcal{M}_1$ 且 $G_3 \\subset \\mathcal{M}_2$，该反应跨越了模块。\n总权重 $W_2 = w_1 + w_2 + w_3 + w_6 = 2 + 1.5 + 1 + 0.8 = 5.3$。\n\n情况3：$\\mathcal{M}_1 = G_3$，$\\mathcal{M}_2 = G_1 \\cup G_2$。\n- $R_1, R_2, R_3$ 涉及来自 $G_1$ 和 $G_2$ 的物种，这两者都在 $\\mathcal{M}_2$ 中。这些是模块内反应。\n- $R_4, R_5$ 仅涉及来自 $G_2$ 的物种，而 $G_2$ 完全在 $\\mathcal{M}_2$ 中。这些是模块内反应。\n- $R_6$ 涉及来自 $G_2$ 和 $G_3$ 的物种。由于 $G_3 \\subset \\mathcal{M}_1$ 且 $G_2 \\subset \\mathcal{M}_2$，该反应跨越了模块。\n总权重 $W_3 = w_6 = 0.8$。\n\n比较总相互作用权重：$W_1 = 4.5$，$W_2 = 5.3$ 和 $W_3 = 0.8$。最小值为 $0.8$。这个最小权重对应于将催化剂物种 $X_6$ 放在一个模块中，而所有其他物种放在另一个模块中的划分。这个结果在化学上是直观的，因为催化剂起到了连接原本分离的动力学的作用。\n\n可达到的最小总模块间相互作用权重是 $0.8$。", "answer": "$$\n\\boxed{0.8}\n$$", "id": "2656659"}, {"introduction": "这项计算练习旨在弥合模块性理论概念与其实际应用之间的鸿沟。您将从动力学方程出发，实现一个完整的光谱聚类流程，以识别化学反应网络中的模块。本练习将指导您完成从系统的雅可比矩阵推导物种相互作用图，应用谱方法将网络嵌入低维空间，并使用 k-均值聚类算法恢复模块的全过程，从而使您掌握网络科学中的一项核心技术。[@problem_id:2656656]", "problem": "考虑一个小型的质量作用化学反应网络族，每个网络都被解释为从在参考浓度下线性化的物种动力学的雅可比矩阵派生出的加权无向物种相互作用图。从质量作用动力学和常微分方程（ODE）的基本原理出发，您需要计算物种相互作用图的谱嵌入，然后使用 k-means 算法将物种聚类成假定模块。最后，您将通过比较总内部强度与跨簇的切割大小来验证所得分区。\n\n基本原理如下。对于一个收集在向量 $\\mathbf{x} \\in \\mathbb{R}_{\\ge 0}^{n}$ 中的一组物种浓度，以及一组由 $j \\in \\{1,\\dots,m\\}$ 索引的、具有质量作用速率 $v_j(\\mathbf{x})$ 的反应，物种动力学为\n$$\n\\frac{d \\mathbf{x}}{dt} \\;=\\; \\mathbf{S}\\, \\mathbf{v}(\\mathbf{x}),\n$$\n其中 $\\mathbf{S} \\in \\mathbb{R}^{n \\times m}$ 是化学计量矩阵。对于每个反应 $j$，$v_j(\\mathbf{x})$ 是物种浓度的乘积，各浓度以化学计量级数为幂，再乘以一个正常数速率常数 $k_j$。在参考浓度 $\\mathbf{x}^{\\star}$ 下求值的雅可比矩阵（右侧对 $\\mathbf{x}$ 的偏导数矩阵）为\n$$\n\\mathbf{J} \\;\\equiv\\; \\left. \\frac{\\partial}{\\partial \\mathbf{x}} \\left(\\mathbf{S}\\, \\mathbf{v}(\\mathbf{x})\\right)\\right|_{\\mathbf{x} = \\mathbf{x}^{\\star}} \\;=\\; \\mathbf{S}\\, \\left. \\frac{\\partial \\mathbf{v}}{\\partial \\mathbf{x}} \\right|_{\\mathbf{x} = \\mathbf{x}^{\\star}}.\n$$\n定义物种上的对称非负权重矩阵 $\\mathbf{W}$ 为\n$$\n\\mathbf{W} \\;=\\; \\frac{1}{2}\\left( |\\mathbf{J}| + |\\mathbf{J}|^{\\mathsf{T}} \\right),\n$$\n其对角线条目设为零，其中绝对值是逐元素计算的。设 $\\mathbf{D}$ 为对角度矩阵，其条目为 $D_{ii} = \\sum_{j} W_{ij}$，并考虑对称归一化图拉普拉斯矩阵\n$$\n\\mathbf{L}_{\\mathrm{sym}} \\;=\\; \\mathbf{I} - \\mathbf{D}^{-1/2}\\, \\mathbf{W}\\, \\mathbf{D}^{-1/2}.\n$$\n通过将与 $k$ 个最小特征值（计算多重性）相关的 $\\mathbf{L}_{\\mathrm{sym}}$ 的 $k$ 个特征向量堆叠为列以形成 $\\mathbf{U} \\in \\mathbb{R}^{n \\times k}$，然后对 $\\mathbf{U}$ 进行行归一化，使每行具有单位欧几里得范数（零范数的行可以保持为零），从而获得一个 $k$ 维谱嵌入。然后对该嵌入矩阵的行执行 k-means 聚类。\n\n对分区 $\\mathcal{C} = \\{C_1,\\dots,C_k\\}$ 的验证通过计算以下指标来完成：\n- **内部强度**（簇内边的总权重）：\n$$ S_{\\mathrm{intra}} \\;=\\; \\sum_{l=1}^k \\sum_{i,j \\in C_l, i  j} W_{ij} $$\n- **切割大小**（簇间边的总权重）：\n$$ S_{\\mathrm{cut}} \\;=\\; \\sum_{1 \\le l  m \\le k} \\sum_{i \\in C_l, j \\in C_m} W_{ij} $$\n- **质量比**:\n$$ R \\;=\\; \\frac{S_{\\mathrm{intra}}}{S_{\\mathrm{cut}} + \\varepsilon} $$\n其中 $\\varepsilon = 10^{-12}$。\n\n**任务:**\n对以下四个测试用例执行上述完整的谱聚类流程，并计算每个用例的质量比 $R$。使用 $k$-means 算法时，应运行 10 次随机初始化（`n_init=10`），最大迭代次数为 100（`max_iter=100`），并使用固定的随机种子 `42` 以确保结果的可复现性。\n\n- **测试用例 A**: $n=6$, $k=2$, 反应: `[(1, 2, 1.0), (2, 1, 1.0), (2, 3, 1.0), (3, 2, 1.0), (4, 5, 1.0), (5, 4, 1.0), (5, 6, 1.0), (6, 5, 1.0), (3, 4, 0.02), (6, 1, 0.02)]`\n- **测试用例 B**: $n=6$, $k=2$, 反应: `[(1, 4, 0.9), (4, 1, 0.9), (2, 5, 0.9), (5, 2, 0.9), (3, 6, 0.9), (6, 3, 0.9), (1, 2, 0.8), (2, 3, 0.8), (3, 1, 0.8), (4, 5, 0.8), (5, 6, 0.8), (6, 4, 0.8)]`\n- **测试用例 C**: $n=6$, $k=3$, 反应: `[(1, 2, 1.0), (2, 1, 1.0), (3, 4, 1.0), (4, 3, 1.0), (5, 6, 1.0), (6, 5, 1.0), (2, 3, 0.03), (4, 5, 0.03)]`\n- **测试用例 D**: $n=6$, $k=2$, 反应: `[(1, 2, 1.0), (2, 1, 1.0), (2, 3, 1.0), (3, 2, 1.0), (4, 5, 1.0), (5, 4, 1.0), (5, 6, 1.0), (6, 5, 1.0)]`\n\n您的最终答案应该是一个包含四个浮点数的 Python 列表，格式为 `[R_A, R_B, R_C, R_D]`。", "solution": "问题陈述是有效的。它在科学上是合理的、适定的和客观的。它为使用标准谱聚类流程分析化学反应网络的模块性提供了一套完整且一致的指令。该方法论基于化学动力学、线性代数、图论和机器学习的既定原理。不存在事实错误、矛盾或含糊之处。我将继续提供详细的解决方案。\n\n问题的核心是识别化学反应网络中的模块化结构。模块是一组相互之间强相互作用但与组外物种弱相互作用的物种。所提供的方法论系统地将化学网络转换为数学图，然后使用谱方法对其进行划分。\n\n**1. 从反应动力学到相互作用图**\n\n物种浓度 $\\mathbf{x} = (x_1, \\dots, x_n)^{\\mathsf{T}}$ 的动力学由一个常微分方程（ODE）系统描述，$\\frac{d\\mathbf{x}}{dt} = \\mathbf{S} \\mathbf{v}(\\mathbf{x})$，其中 $\\mathbf{S}$ 是化学计量矩阵，$\\mathbf{v}(\\mathbf{x})$ 是反应速率向量。为了分析物种间的相互作用，我们围绕参考浓度 $\\mathbf{x}^{\\star}$ 线性化此系统。此线性化的矩阵是雅可比矩阵 $\\mathbf{J}$。每个元素 $J_{ij} = \\frac{\\partial}{\\partial x_j} (\\frac{dx_i}{dt})$ 代表物种 $j$ 浓度的微小变化对物种 $i$ 变化率的影响。\n\n问题指定了形式为 $i \\to j$ 的单分子反应，其质量作用速率为 $v(\\mathbf{x}) = k x_i$。该反应消耗物种 $i$ 并产生物种 $j$。速率仅依赖于 $x_i$，因此该速率的唯一非零偏导数是 $\\frac{\\partial v}{\\partial x_i} = k$。该反应的化学计量向量对物种 $i$ 为 -1，对物种 $j$ 为 +1。对雅可比矩阵 $\\mathbf{J}$ 的贡献是第 $i$ 列的变化：对角元素 $J_{ii}$ 减少 $k$（由于消耗），而非对角元素 $J_{ji}$ 增加 $k$（由于生产）。我们通过对所有反应的这些贡献求和来构建完整的雅可比矩阵。\n\n雅可比矩阵 $\\mathbf{J}$ 通常不是对称的。为了定义物种相互作用的加权无向图，我们需要一个对称的权重矩阵 $\\mathbf{W}$。问题通过对雅可比矩阵的逐元素绝对值进行对称化来定义它：$\\mathbf{W} = \\frac{1}{2}(|\\mathbf{J}| + |\\mathbf{J}|^{\\mathsf{T}})$。取绝对值确保所有权重都是非负的，代表相互作用的强度，无论其是激活性的还是抑制性的。对角线条目设为零，因为我们关心的是不同物种之间的相互作用。\n\n**2. 用于模块检测的谱聚类**\n\n有了权重矩阵 $\\mathbf{W}$，我们就得到了一个无向图，其中物种是节点，$W_{ij}$ 是物种 $i$ 和 $j$ 之间边的权重。为了在该图中找到簇，我们采用谱聚类，这是一种基于图拉普拉斯矩阵属性的强大技术。问题使用了对称归一化拉普拉斯矩阵，定义为 $\\mathbf{L}_{\\mathrm{sym}} = \\mathbf{I} - \\mathbf{D}^{-1/2}\\mathbf{W}\\mathbf{D}^{-1/2}$，其中 $\\mathbf{D}$ 是对角度矩阵，其元素为 $D_{ii} = \\sum_j W_{ij}$。\n\n谱聚类的关键见解是，与拉普拉斯矩阵最小特征值相对应的特征向量捕获了图的大规模结构。对于一个有 $c$ 个连通分量的图，拉普拉斯矩阵有 $c$ 个等于 0 的特征值。相应的特征向量是这些分量的指示向量。对于一个近可分解图（即具有强模块的图），与最小非零特征值（通常称为 Fiedler 向量）相关的特征向量在模块内将几乎是恒定的，并在它们之间的弱连接处改变值。\n\n我们计算与 $k$ 个最小特征值相对应的 $\\mathbf{L}_{\\mathrm{sym}}$ 的 $k$ 个特征向量。这些特征向量构成了矩阵 $\\mathbf{U} \\in \\mathbb{R}^{n \\times k}$ 的列。$\\mathbf{U}$ 的行可以看作是 $n$ 个物种在 $k$ 维欧几里得空间中的新坐标。这就是“谱嵌入”。在这个空间中，属于同一模块的物种预期会彼此靠近。为了使这些点更适合基于距离的聚类，我们对矩阵 $\\mathbf{U}$ 进行行归一化，将嵌入投影到单位球面上。\n\n**3. K-Means 聚类和分区评估**\n\n一旦物种被嵌入到新的 $k$ 维空间中，我们使用 k-means 算法将它们分成 $k$ 个簇。K-means 旨在找到一个最小化簇内平方和（WCSS）的分区。由于 k-means 对初始化敏感，问题指定多次（10 次）运行该算法，每次都使用随机初始化，并选择产生最小 WCSS 的分区。\n\n最后，所得分区 $\\mathcal{C} = \\{C_1, \\dots, C_k\\}$ 的质量通过比较簇内边的总权重（$S_{\\mathrm{intra}}$）与簇间边的总权重（$S_{\\mathrm{cut}}$）来量化。质量比 $R = S_{\\mathrm{intra}} / (S_{\\mathrm{cut}} + \\varepsilon)$ 作为最终度量。高 $R$ 值表示成功地将网络划分为不同的、内部密集的模块。小常数 $\\varepsilon = 10^{-12}$ 被加到分母中，以确保在完全不连通模块（$S_{\\mathrm{cut}} = 0$）情况下的数值稳定性。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\nimport random\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    def custom_kmeans(X, k, n_init, max_iter, seed):\n        \"\"\"\n        Performs k-means clustering.\n\n        Args:\n            X (np.ndarray): The data to cluster, shape (n_samples, n_features).\n            k (int): The number of clusters.\n            n_init (int): The number of times to run k-means with different random seeds.\n            max_iter (int): The maximum number of iterations for a single run.\n            seed (int): A seed for the random number generator for reproducibility.\n\n        Returns:\n            np.ndarray: The final cluster labels for each sample.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        best_labels = None\n        best_wcss = float('inf')\n        n_samples = X.shape[0]\n\n        for _ in range(n_init):\n            # Initialize centroids by picking k unique random points from X\n            initial_indices = rng.choice(n_samples, size=k, replace=False)\n            centroids = X[initial_indices, :]\n            \n            for i in range(max_iter):\n                # Assignment step: assign each point to the nearest centroid\n                dists_sq = np.sum((X[:, np.newaxis, :] - centroids[np.newaxis, :, :])**2, axis=2)\n                labels = np.argmin(dists_sq, axis=1)\n\n                # Update step: recalculate centroids\n                new_centroids = np.copy(centroids)\n                for j in range(k):\n                    cluster_points = X[labels == j]\n                    if cluster_points.shape[0] > 0:\n                        new_centroids[j] = cluster_points.mean(axis=0)\n                \n                # Check for convergence\n                if np.allclose(new_centroids, centroids):\n                    break\n                centroids = new_centroids\n\n            # Calculate Within-Cluster Sum of Squares (WCSS) for this run\n            current_wcss = 0\n            for j in range(k):\n                cluster_points = X[labels == j]\n                if cluster_points.shape[0] > 0:\n                    current_wcss += np.sum((cluster_points - centroids[j])**2)\n            \n            # Keep track of the best result\n            if current_wcss  best_wcss:\n                best_wcss = current_wcss\n                best_labels = labels\n        \n        return best_labels\n\n    test_cases = [\n        {\n            \"name\": \"A\", \"n\": 6, \"k\": 2, \"reactions\": [\n                (1, 2, 1.0), (2, 1, 1.0), (2, 3, 1.0), (3, 2, 1.0),\n                (4, 5, 1.0), (5, 4, 1.0), (5, 6, 1.0), (6, 5, 1.0),\n                (3, 4, 0.02), (6, 1, 0.02)\n            ]\n        },\n        {\n            \"name\": \"B\", \"n\": 6, \"k\": 2, \"reactions\": [\n                (1, 4, 0.9), (4, 1, 0.9), (2, 5, 0.9), (5, 2, 0.9), (3, 6, 0.9), (6, 3, 0.9),\n                (1, 2, 0.8), (2, 3, 0.8), (3, 1, 0.8), (4, 5, 0.8), (5, 6, 0.8), (6, 4, 0.8)\n            ]\n        },\n        {\n            \"name\": \"C\", \"n\": 6, \"k\": 3, \"reactions\": [\n                (1, 2, 1.0), (2, 1, 1.0),\n                (3, 4, 1.0), (4, 3, 1.0),\n                (5, 6, 1.0), (6, 5, 1.0),\n                (2, 3, 0.03), (4, 5, 0.03)\n            ]\n        },\n        {\n            \"name\": \"D\", \"n\": 6, \"k\": 2, \"reactions\": [\n                (1, 2, 1.0), (2, 1, 1.0), (2, 3, 1.0), (3, 2, 1.0),\n                (4, 5, 1.0), (5, 4, 1.0), (5, 6, 1.0), (6, 5, 1.0)\n            ]\n        }\n    ]\n\n    results = []\n    epsilon = 1e-12\n\n    for case in test_cases:\n        n, k, reactions = case['n'], case['k'], case['reactions']\n\n        # 1. Construct the Jacobian matrix J\n        J = np.zeros((n, n))\n        for i, j, rate_const in reactions:\n            # Using 0-based indexing\n            J[i - 1, i - 1] -= rate_const\n            J[j - 1, i - 1] += rate_const\n\n        # 2. Construct the symmetric weight matrix W\n        abs_J = np.abs(J)\n        W = 0.5 * (abs_J + abs_J.T)\n        np.fill_diagonal(W, 0)\n\n        # 3. Construct the symmetric normalized Laplacian L_sym\n        D_diag = np.sum(W, axis=1)\n        D_inv_sqrt_diag = np.zeros_like(D_diag, dtype=float)\n        non_zero_mask = D_diag > 0\n        D_inv_sqrt_diag[non_zero_mask] = 1.0 / np.sqrt(D_diag[non_zero_mask])\n        D_inv_sqrt = np.diag(D_inv_sqrt_diag)\n        L_sym = np.identity(n) - D_inv_sqrt @ W @ D_inv_sqrt\n\n        # 4. Compute the spectral embedding\n        eigenvalues, eigenvectors = eigh(L_sym)\n        U = eigenvectors[:, :k]\n\n        # Row-normalize the embedding U\n        U_norm = np.copy(U)\n        row_norms = np.linalg.norm(U_norm, axis=1, keepdims=True)\n        # Avoid division by zero for rows with zero norm\n        non_zero_rows_mask = (row_norms > 1e-15).flatten()\n        U_norm[non_zero_rows_mask] /= row_norms[non_zero_rows_mask]\n\n        # 5. Perform k-means clustering on the embedded data\n        # Use a fixed seed for reproducibility as required for a deterministic check\n        labels = custom_kmeans(U_norm, k, n_init=10, max_iter=100, seed=42)\n\n        # 6. Compute the quality ratio R\n        S_intra = 0.0\n        S_cut = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if W[i, j] > 0:\n                    if labels[i] == labels[j]:\n                        S_intra += W[i, j]\n                    else:\n                        S_cut += W[i, j]\n        \n        R = S_intra / (S_cut + epsilon)\n        results.append(R)\n    \n    # Format the results into the required string format\n    print(f\"[{','.join([f'{r:.10f}' for r in results])}]\")\n\nsolve()\n```", "id": "2656656"}]}