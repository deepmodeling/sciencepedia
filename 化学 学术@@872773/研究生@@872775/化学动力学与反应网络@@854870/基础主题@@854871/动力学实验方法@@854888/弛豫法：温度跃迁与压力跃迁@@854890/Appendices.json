{"hands_on_practices": [{"introduction": "在分析弛豫动力学之前，我们必须首先理解如何物理地产生快速的温度跃变。这项练习聚焦于电阻式T-jump装置中焦耳热的核心原理 [@problem_id:2669948]。通过应用能量守恒定律，你将能确定实现目标温升所需的电流脉冲参数，从而对控制扰动强度的实验硬件有一个切实的理解。", "problem": "电阻式温跃（T-jump）装置用于扰动水相微体积中快速可逆反应的平衡，以便监测其弛豫回平衡的过程。该装置通过样品中的浸入式电阻路径施加一个矩形电流脉冲。假设在脉冲期间存在以下理想化情况：(i) 电流 $I$ 和电阻 $R$ 是恒定的；(ii) 所有作为热量耗散的电能都均匀地沉积在样品中；(iii) 对环境的热损失可以忽略不计；(iv) 溶液的比热容 $c_p$ 和密度 $\\rho$ 在小的温升范围内保持不变；(v) 在脉冲期间没有相变或反应焓的贡献。\n\n样品为体积 $V = 20.0 \\ \\mathrm{\\mu L}$ 的水溶液，在初始温度下，其密度 $\\rho = 1.00 \\ \\mathrm{g \\cdot mL^{-1}}$，比热容 $c_p = 4.18 \\ \\mathrm{J \\cdot g^{-1} \\cdot K^{-1}}$。通过样品的电流路径的有效电阻为 $R = 5.00 \\ \\mathrm{\\Omega}$。施加一个持续时间为 $\\Delta t = 5.00 \\ \\mathrm{\\mu s}$ 的矩形电流脉冲。目标温跃为 $\\Delta T_{\\mathrm{target}} = 10.0 \\ \\mathrm{K}$。\n\n仅从能量守恒、焦耳热和宏观热容的定义出发，推导连接温升 $\\Delta T$ 与 $I$、$R$、$\\Delta t$、$m$ 和 $c_p$ 之间的关系式，然后确定在给定条件下实现目标温跃 $\\Delta T_{\\mathrm{target}}$ 所需的电流幅值 $I$。将最终数值结果四舍五入到三位有效数字。以安培（A）为单位表示电流。", "solution": "所述问题经确定是有效的。它在科学上是合理的，基于能量守恒、焦耳热和量热学的基本原理。该问题提法恰当，提供了推导唯一且有意义解所需的所有必要数据和约束条件。它客观且无歧义。因此，我们将着手解决此问题。\n\n控制此过程的主要原理是能量守恒。问题指明，所有作为热量耗散的电能都均匀地沉积在样品中，并且对环境的热损失可以忽略不计。因此，电流脉冲提供的电能 $E_{\\mathrm{elec}}$ 必须等于样品吸收的导致其温度升高的热量 $Q$。\n$$E_{\\mathrm{elec}} = Q$$\n电能是电功率 $P$ 与脉冲持续时间 $\\Delta t$ 的乘积。根据焦耳热定律，对于流过恒定电阻 $R$ 的恒定电流 $I$，耗散的功率为：\n$$P = I^{2}R$$\n因此，在时间间隔 $\\Delta t$ 内耗散的总电能为：\n$$E_{\\mathrm{elec}} = P \\Delta t = I^{2}R \\Delta t$$\n样品吸收的热量由量热学原理描述。对于质量为 $m$、比热容 $c_p$ 在温度区间内恒定的样品，产生温度变化 $\\Delta T$ 所需的热量由下式给出：\n$$Q = m c_p \\Delta T$$\n通过将耗散的电能与吸收的热量相等，我们得到问题所要求的关系式：\n$$I^{2}R \\Delta t = m c_p \\Delta T$$\n该方程将温升 $\\Delta T$ 与电流 $I$、电阻 $R$、脉冲持续时间 $\\Delta t$、样品质量 $m$ 和比热容 $c_p$ 联系起来。\n\n为了求解实现目标温跃 $\\Delta T_{\\mathrm{target}}$ 所需的电流幅值 $I$，我们必须重新整理这个表达式：\n$$I^{2} = \\frac{m c_p \\Delta T}{R \\Delta t}$$\n$$I = \\sqrt{\\frac{m c_p \\Delta T}{R \\Delta t}}$$\n溶液的质量 $m$ 没有直接给出。它必须由给定的体积 $V$ 和密度 $\\rho$ 计算得出：\n$$m = \\rho V$$\n将此代入电流 $I$ 的方程中，得到用于计算的完整表达式：\n$$I = \\sqrt{\\frac{\\rho V c_p \\Delta T}{R \\Delta t}}$$\n我们已知以下数值：\n-   样品体积 $V = 20.0 \\ \\mathrm{\\mu L}$\n-   密度 $\\rho = 1.00 \\ \\mathrm{g \\cdot mL^{-1}}$\n-   比热容 $c_p = 4.18 \\ \\mathrm{J \\cdot g^{-1} \\cdot K^{-1}}$\n-   电阻 $R = 5.00 \\ \\mathrm{\\Omega}$\n-   脉冲持续时间 $\\Delta t = 5.00 \\ \\mathrm{\\mu s}$\n-   目标温跃 $\\Delta T = \\Delta T_{\\mathrm{target}} = 10.0 \\ \\mathrm{K}$\n\n必须使用一套一致的单位。我们将使用克（$\\mathrm{g}$）作为质量单位，秒（$\\mathrm{s}$）作为时间单位，焦耳（$\\mathrm{J}$）作为能量单位，开尔文（$\\mathrm{K}$）作为温度单位，欧姆（$\\Omega$）作为电阻单位进行计算。这些单位是兼容的，因为 $1 \\ \\mathrm{J} = 1 \\ \\mathrm{A}^{2} \\cdot \\Omega \\cdot \\mathrm{s}$。\n\n首先，我们计算水溶液的质量 $m$。我们必须将体积从微升（$\\mu\\mathrm{L}$）转换为毫升（$\\mathrm{mL}$），以便与密度的单位保持一致。\n$$V = 20.0 \\ \\mathrm{\\mu L} = 20.0 \\times 10^{-3} \\ \\mathrm{mL} = 0.0200 \\ \\mathrm{mL}$$\n$$m = \\rho V = (1.00 \\ \\mathrm{g \\cdot mL^{-1}}) \\times (0.0200 \\ \\mathrm{mL}) = 0.0200 \\ \\mathrm{g}$$\n脉冲持续时间必须从微秒（$\\mu\\mathrm{s}$）转换为秒（$\\mathrm{s}$）：\n$$\\Delta t = 5.00 \\ \\mathrm{\\mu s} = 5.00 \\times 10^{-6} \\ \\mathrm{s}$$\n现在我们将所有数值代入 $I$ 的表达式中：\n$$I = \\sqrt{\\frac{(0.0200 \\ \\mathrm{g}) \\times (4.18 \\ \\mathrm{J \\cdot g^{-1} \\cdot K^{-1}}) \\times (10.0 \\ \\mathrm{K})}{(5.00 \\ \\mathrm{\\Omega}) \\times (5.00 \\times 10^{-6} \\ \\mathrm{s})}}$$\n让我们分别计算分子（所需热量）和分母。\n所需热量为：\n$$Q = m c_p \\Delta T = (0.0200) \\times (4.18) \\times (10.0) \\ \\mathrm{J} = 0.836 \\ \\mathrm{J}$$\n分母中的项为：\n$$R \\Delta t = (5.00 \\ \\mathrm{\\Omega}) \\times (5.00 \\times 10^{-6} \\ \\mathrm{s}) = 25.0 \\times 10^{-6} \\ \\mathrm{\\Omega \\cdot s} = 2.50 \\times 10^{-5} \\ \\mathrm{\\Omega \\cdot s}$$\n电流的平方是这两个量的比值：\n$$I^{2} = \\frac{0.836 \\ \\mathrm{J}}{2.50 \\times 10^{-5} \\ \\mathrm{\\Omega \\cdot s}} = 33440 \\ \\mathrm{A}^{2}$$\n取平方根得到电流的幅值：\n$$I = \\sqrt{33440} \\ \\mathrm{A} \\approx 182.86606 \\ \\mathrm{A}$$\n问题要求将最终数值结果四舍五入到三位有效数字。\n$$I \\approx 183 \\ \\mathrm{A}$$\n这是一个相当大的电流，这对于在导电介质中产生快速温跃是预料之中的。", "answer": "$$\\boxed{183}$$", "id": "2669948"}, {"introduction": "当温度跃变发生后，系统的化学平衡位置会根据范特霍夫方程发生移动。这项练习将引导你推导并计算由此产生的可观测信号变化的大小，即弛豫幅度 [@problem_id:2669895]。此实践将反应的热力学性质（如反应焓变 $\\Delta H^\\circ$）与光谱信号（由比尔-朗伯定律描述）联系起来，从而在宏观测量与微观过程之间架起一座桥梁。", "problem": "考虑一个在初始温度为 $T_0$ 的理想溶液中进行的可逆基元异构化反应 $A \\rightleftharpoons B$，其平衡常数为 $K(T) \\equiv \\frac{c_B^{\\mathrm{eq}}}{c_A^{\\mathrm{eq}}}$。总分析浓度为 $c_T = c_A + c_B$，在固定探测波长下的光吸收度遵循比尔-朗伯定律 $A = \\ell\\left(\\varepsilon_A c_A + \\varepsilon_B c_B\\right)$，其中 $\\ell$ 是光程，$\\varepsilon_A, \\varepsilon_B$ 分别是 A 和 B 的摩尔吸光系数。在 $t=0$ 时施加一个幅度为 $\\Delta T$ 的瞬时温度跃迁（温跃），该过程相对于反应弛豫而言非常快，因此在 $t=0^+$ 时浓度保持不变，但速率常数（以及 $K$）变为其在 $T_0+\\Delta T$ 时的值。假设活度等于浓度，标准反应焓 $\\Delta H^\\circ$ 在温度跃迁范围内不随温度变化，且摩尔吸光系数在该范围内也不随温度变化。\n\n1) 仅从质量守恒、平衡常数的定义、比尔-朗伯定律以及范特霍夫关系式 $\\frac{d\\ln K}{dT}=\\frac{\\Delta H^\\circ}{R\\,T^2}$（其中 $R$ 为普适气体常数）出发，推导吸收度弛豫的有符号振幅的表达式。该振幅定义为温度跃迁后新旧平衡吸收度之差，并应表示为关于 A 的摩尔分数的灵敏度因子乘以 $t=0^+$ 时的瞬时平衡组成位移的形式。请用 $K(T_0)$ 和 $K(T_0+\\Delta T)$ 表示组成位移，并用 $K(T_0)$、$\\Delta H^\\circ$、$T_0$ 和 $\\Delta T$ 表示 $K(T_0+\\Delta T)$，且不对 $\\ln K$ 进行线性化处理。\n\n2) 对下列参数进行振幅的数值计算：$T_0 = 298.0\\ \\mathrm{K}$，$\\Delta T = 5.00\\ \\mathrm{K}$，$K(T_0)=3.00$，$\\Delta H^\\circ = 45.0 \\times 10^3\\ \\mathrm{J \\cdot mol^{-1}}$，$R=8.314462618\\ \\mathrm{J \\cdot mol^{-1} \\cdot K^{-1}}$，$c_T=1.50 \\times 10^{-3}\\ \\mathrm{M}$，$\\ell=1.000\\ \\mathrm{cm}$，$\\varepsilon_A = 8.000 \\times 10^3\\ \\mathrm{M^{-1} \\cdot cm^{-1}}$，以及 $\\varepsilon_B = 1.200 \\times 10^4\\ \\mathrm{M^{-1} \\cdot cm^{-1}}$。以吸收度单位（无量纲）报告吸收度振幅的最终数值。将答案四舍五入至四位有效数字。", "solution": "首先验证问题的科学合理性、一致性和完整性。问题描述了一个标准的温度跃迁弛豫动力学实验。它基于化学动力学、热力学（范特霍夫方程）和光谱学（比尔-朗伯定律）的基本原理。所有必要的参数都已提供，并且所作的假设（理想溶液、在小温度范围内 $\\Delta H^\\circ$ 和摩尔吸光系数恒定）在物理上是合理的，并且在此背景下是标准的。该问题提法恰当、客观且有科学依据。因此，该问题被认为是有效的，并将构建解答。\n\n第1部分：吸收度振幅表达式的推导\n\n溶液的总吸收度 $A$ 由比尔-朗伯定律给出：\n$$A = \\ell \\left( \\varepsilon_A c_A + \\varepsilon_B c_B \\right)$$\n其中 $\\ell$ 是光程，$\\varepsilon_i$ 是摩尔吸光系数， $c_i$ 是物种 $i \\in \\{A, B\\}$ 的浓度。\n质量守恒规定总浓度 $c_T = c_A + c_B$ 是恒定的。我们可以用物种 A 的摩尔分数 $x_A = \\frac{c_A}{c_T}$ 和总浓度 $c_T$ 来表示各组分的浓度。\n$$c_A = x_A c_T$$\n$$c_B = (1-x_A) c_T$$\n将这些代入比尔-朗伯定律，得到吸收度作为 $x_A$ 函数的表达式：\n$$A(x_A) = \\ell c_T \\left( \\varepsilon_A (x_A c_T) + \\varepsilon_B ((1-x_A) c_T) \\right)$$\n$$A(x_A) = \\ell c_T \\left( \\varepsilon_A x_A + \\varepsilon_B - \\varepsilon_B x_A \\right)$$\n$$A(x_A) = \\ell c_T \\left( (\\varepsilon_A - \\varepsilon_B) x_A + \\varepsilon_B \\right)$$\n吸收度弛豫的有符号振幅 $\\Delta A_{\\text{amp}}$ 定义为最终平衡吸收度（在温度 $T_f = T_0 + \\Delta T$ 时）与初始平衡吸收度（在温度 $T_0$ 时）之差。设 $x_{A,0}^{\\text{eq}}$ 和 $x_{A,f}^{\\text{eq}}$ 分别为在 $T_0$ 和 $T_f$ 时 A 的平衡摩尔分数。\n$$A_{\\text{old}}^{\\text{eq}} = A(x_{A,0}^{\\text{eq}}) = \\ell c_T \\left( (\\varepsilon_A - \\varepsilon_B) x_{A,0}^{\\text{eq}} + \\varepsilon_B \\right)$$\n$$A_{\\text{new}}^{\\text{eq}} = A(x_{A,f}^{\\text{eq}}) = \\ell c_T \\left( (\\varepsilon_A - \\varepsilon_B) x_{A,f}^{\\text{eq}} + \\varepsilon_B \\right)$$\n振幅是它们的差值：\n$$\\Delta A_{\\text{amp}} = A_{\\text{new}}^{\\text{eq}} - A_{\\text{old}}^{\\text{eq}} = \\ell c_T (\\varepsilon_A - \\varepsilon_B) \\left( x_{A,f}^{\\text{eq}} - x_{A,0}^{\\text{eq}} \\right)$$\n此表达式符合所要求的形式。“关于 A 的摩尔分数的灵敏度因子”是吸收度对 $x_A$ 的导数，即 $\\frac{\\partial A}{\\partial x_A} = \\ell c_T (\\varepsilon_A - \\varepsilon_B)$。“组成位移”是平衡摩尔分数的变化量，即 $\\Delta x_A^{\\text{eq}} = x_{A,f}^{\\text{eq}} - x_{A,0}^{\\text{eq}}$。\n\n接下来，我们用平衡常数来表示组成位移。平衡常数为 $K = \\frac{c_B^{\\text{eq}}}{c_A^{\\text{eq}}} = \\frac{x_B^{\\text{eq}}}{x_A^{\\text{eq}}} = \\frac{1-x_A^{\\text{eq}}}{x_A^{\\text{eq}}}$。\n求解 $x_A^{\\text{eq}}$ 可得 $K x_A^{\\text{eq}} = 1 - x_A^{\\text{eq}}$，整理后为 $(K+1)x_A^{\\text{eq}} = 1$，所以 $x_A^{\\text{eq}} = \\frac{1}{K+1}$。\n设 $K_0 = K(T_0)$ 和 $K_f = K(T_f) = K(T_0 + \\Delta T)$。摩尔分数为：\n$$x_{A,0}^{\\text{eq}} = \\frac{1}{K_0+1} \\quad \\text{和} \\quad x_{A,f}^{\\text{eq}} = \\frac{1}{K_f+1}$$\n因此，组成位移为：\n$$\\Delta x_A^{\\text{eq}} = \\frac{1}{K_f+1} - \\frac{1}{K_0+1}$$\n\n最后，我们必须使用范特霍夫关系式 $\\frac{d\\ln K}{dT}=\\frac{\\Delta H^\\circ}{R\\,T^2}$ 将 $K_f$ 与 $K_0$ 联系起来。假设 $\\Delta H^\\circ$ 在此区间内为常数，将此方程从 $T_0$ 积分到 $T_f$：\n$$\\int_{K_0}^{K_f} d\\ln K = \\int_{T_0}^{T_f} \\frac{\\Delta H^\\circ}{R\\,T^2} dT$$\n$$\\ln K_f - \\ln K_0 = \\frac{\\Delta H^\\circ}{R} \\left[ -\\frac{1}{T} \\right]_{T_0}^{T_f}$$\n$$\\ln\\left(\\frac{K_f}{K_0}\\right) = \\frac{\\Delta H^\\circ}{R} \\left( -\\frac{1}{T_f} + \\frac{1}{T_0} \\right) = \\frac{\\Delta H^\\circ}{R} \\left( \\frac{T_f - T_0}{T_0 T_f} \\right)$$\n代入 $T_f = T_0 + \\Delta T$ 得：\n$$\\ln\\left(\\frac{K_f}{K_0}\\right) = \\frac{\\Delta H^\\circ}{R} \\left( \\frac{\\Delta T}{T_0 (T_0 + \\Delta T)} \\right)$$\n对两边取指数，得到 $K_f$ 的表达式：\n$$K_f = K_0 \\exp\\left( \\frac{\\Delta H^\\circ}{R} \\frac{\\Delta T}{T_0 (T_0 + \\Delta T)} \\right)$$\n结合这些结果，吸收度振幅的最终表达式为：\n$$\\Delta A_{\\text{amp}} = \\ell c_T (\\varepsilon_A - \\varepsilon_B) \\left( \\frac{1}{K_f+1} - \\frac{1}{K_0+1} \\right)$$\n其中 $K_f$ 的定义如上。推导完成。\n\n第2部分：数值计算\n\n给定以下参数：\n$T_0 = 298.0\\ \\mathrm{K}$\n$\\Delta T = 5.00\\ \\mathrm{K}$\n$K_0 = K(T_0) = 3.00$\n$\\Delta H^\\circ = 45.0 \\times 10^3\\ \\mathrm{J \\cdot mol^{-1}}$\n$R = 8.314462618\\ \\mathrm{J \\cdot mol^{-1} \\cdot K^{-1}}$\n$c_T = 1.50 \\times 10^{-3}\\ \\mathrm{M}$\n$\\ell = 1.000\\ \\mathrm{cm}$\n$\\varepsilon_A = 8.000 \\times 10^3\\ \\mathrm{M^{-1} \\cdot cm^{-1}}$\n$\\varepsilon_B = 1.200 \\times 10^4\\ \\mathrm{M^{-1} \\cdot cm^{-1}}$\n\n首先，计算新温度 $T_f$：\n$$T_f = T_0 + \\Delta T = 298.0\\ \\mathrm{K} + 5.00\\ \\mathrm{K} = 303.0\\ \\mathrm{K}$$\n接下来，计算 $K_f$ 的指数项参数：\n$$ \\frac{\\Delta H^\\circ}{R} \\frac{\\Delta T}{T_0 T_f} = \\frac{45.0 \\times 10^3\\ \\mathrm{J \\cdot mol^{-1}}}{8.314462618\\ \\mathrm{J \\cdot mol^{-1} \\cdot K^{-1}}} \\frac{5.00\\ \\mathrm{K}}{(298.0\\ \\mathrm{K})(303.0\\ \\mathrm{K})} \\approx 0.2996906 $$\n现在，计算新的平衡常数 $K_f$：\n$$K_f = (3.00) \\exp(0.2996906) \\approx (3.00)(1.34944) \\approx 4.04832$$\n接下来，计算 A 的初始和最终平衡摩尔分数：\n$$x_{A,0}^{\\text{eq}} = \\frac{1}{K_0+1} = \\frac{1}{3.00+1} = \\frac{1}{4} = 0.25$$\n$$x_{A,f}^{\\text{eq}} = \\frac{1}{K_f+1} = \\frac{1}{4.04832+1} = \\frac{1}{5.04832} \\approx 0.198085$$\n组成位移为：\n$$\\Delta x_A^{\\text{eq}} = x_{A,f}^{\\text{eq}} - x_{A,0}^{\\text{eq}} \\approx 0.198085 - 0.25 = -0.051915$$\n现在，计算灵敏度因子：\n$$\\ell c_T (\\varepsilon_A - \\varepsilon_B) = (1.000\\ \\mathrm{cm})(1.50 \\times 10^{-3}\\ \\mathrm{M})(8.000 \\times 10^3 - 1.200 \\times 10^4)\\ \\mathrm{M^{-1} \\cdot cm^{-1}}$$\n$$ = (1.50 \\times 10^{-3})(-4.000 \\times 10^3) = -6.00$$\n最后，计算吸收度振幅：\n$$\\Delta A_{\\text{amp}} = (-6.00) \\times (-0.051915) \\approx 0.31149$$\n将结果四舍五入至四位有效数字，得到 $0.3115$。正号表示吸收度增加，这与吸热反应（$\\Delta H^\\circ > 0$）在温度升高时向 B 物种（其摩尔吸光系数更高，$\\varepsilon_B > \\varepsilon_A$）移动的趋势一致。", "answer": "$$\n\\boxed{0.3115}\n$$", "id": "2669895"}, {"introduction": "弛豫实验的最后一步是分析时间分辨数据以提取动力学信息，这通常涉及将信号拟合为多个指数衰减项的和。这项计算实践 tackles 这一过程中的一个关键挑战：模型选择 [@problem_id:2669947]。通过应用赤池信息准则 (AIC)、贝叶斯信息准则 (BIC) 和交叉验证等现代统计工具，你将学习如何从含噪信号中科学地确定潜在的动力学过程数量。", "problem": "您将执行一个建模和模型选择任务，该任务基于温度跃迁 (T-jump) 扰动后的化学弛豫动力学。在平衡态受到微小扰动的情况下，反应网络在其稳态附近的线性化意味着可观测量会以解耦的指数模式之和的形式弛豫。在时间 $t$ 发生的此类弛豫的数据集可以建模为\n$$\ny(t) = C + \\sum_{i=1}^{m} A_i \\exp\\!\\left(-\\frac{t}{\\tau_i}\\right) + \\varepsilon(t),\n$$\n其中 $m$ 是模型阶数（指数模式的数量），$A_i$ 是实数振幅，$\\tau_i \\gt 0$ 是弛豫时间常数（单位为秒），$C$ 是常数基线，$\\varepsilon(t)$ 是均值为零、方差为 $\\sigma^2$ 的独立同分布高斯噪声。\n\n您的任务是使用高斯噪声下的最大似然法、赤池信息准则 (AIC)、贝叶斯信息准则 (BIC) 和 $K$ 折交叉验证 (CV)，在单指数、双指数和三指数模型之间实现基于原则的模型选择。您必须通过对每个候选阶数 $m \\in \\{1,2,3\\}$ 显式拟合非线性最小二乘问题，并从第一性原理计算选择准则来完成此任务。\n\n在整个过程中，请作如下假设：\n- 噪声 $\\varepsilon(t)$ 是均值为零、方差为常数 $\\sigma^2$（未知）的高斯噪声。\n- 高斯噪声下的最大似然估计等同于最小化残差平方和\n$$\n\\mathrm{RSS}_m = \\sum_{j=1}^{n} \\left[y_j - \\left(C + \\sum_{i=1}^{m} A_i \\exp\\!\\left(-\\frac{t_j}{\\tau_i}\\right)\\right)\\right]^2,\n$$\n其中 $(t_j, y_j)$ 是 $n$ 个测量点。\n- 模型阶数 $m$ 的拟合参数数量为 $p_m = 2m + 1$（$m$ 个振幅、$m$ 个时间常数和偏移量 $C$）。为了使用信息准则进行模型比较，采用标准的最小二乘替代负对数似然：\n$$\n-2 \\log \\hat{L}_m = n \\log\\!\\left(\\frac{\\mathrm{RSS}_m}{n}\\right) + \\text{constant},\n$$\n这样，准则之间的差异不受加法常数的影响。\n- 将模型 $m$ 的赤池信息准则 (AIC) 和贝叶斯信息准则 (BIC) 定义为\n$$\n\\mathrm{AIC}_m = n \\log\\!\\left(\\frac{\\mathrm{RSS}_m}{n}\\right) + 2 p_m, \\qquad\n\\mathrm{BIC}_m = n \\log\\!\\left(\\frac{\\mathrm{RSS}_m}{n}\\right) + p_m \\log n.\n$$\n- 对于 $K$ 折交叉验证，使用 $K = 5$ 折，使用固定种子 42 将 $n$ 个索引伪随机地划分为 $K$ 个折，并将交叉验证的均方预测误差定义为在每个留出折上计算的均方误差在所有折上的平均值。在每一折中，仅在训练子集上拟合模型，并在验证子集上评估均方预测误差。\n- 选择规则：对于每个准则（AIC、BIC、CV），选择使该准则最小化的模型阶数 $m$。如果两个或多个模型的准则值与该准则的最小值之差在容差 $\\epsilon = 10^{-9}$ 以内，则选择较小的 $m$。\n\n请为以下包含三个具有已知真实值 (ground truth) 的合成 T-jump 数据集的测试套件实现上述过程（时间单位为秒，信号单位为任意一致单位）。对于每个数据集，从 $t = 0$ 到 $t = T_{\\max}$（含端点）生成 $n$ 个均匀间隔的时间点，使用给定的真实值参数模拟无噪声信号，并添加具有指定标准差 $\\sigma$ 的独立高斯噪声：\n- 数据集 1（真实情况为单指数）：$n = 200$，$T_{\\max} = 3.0$，$m^\\star = 1$，振幅 $[1.2]$，时间常数 $[0.5]$，偏移量 $C = 0.0$，噪声标准差 $\\sigma = 0.02$。\n- 数据集 2（真实情况为双指数）：$n = 300$，$T_{\\max} = 2.0$，$m^\\star = 2$，振幅 $[0.6, 0.4]$，时间常数 $[0.1, 1.0]$，偏移量 $C = 0.05$，噪声标准差 $\\sigma = 0.02$。\n- 数据集 3（真实情况为三指数）：$n = 400$，$T_{\\max} = 3.0$，$m^\\star = 3$，振幅 $[0.5, 0.3, 0.2]$，时间常数 $[0.02, 0.2, 2.0]$，偏移量 $C = -0.1$，噪声标准差 $\\sigma = 0.01$。\n\n所有表示时间的模拟量必须以秒为单位。所有对数均为自然对数。任何角度（如果出现）必须以弧度为单位。输出中的任何量都不应以百分比形式书写；如果出现任何比例，必须表示为小数或分数。\n\n最终输出规范：\n- 对于每个数据集（按 1,2,3 的顺序），根据上述定义的 AIC、BIC 和 5 折交叉验证计算选定的模型阶数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按以下顺序包含 9 个整数\n$$\n[\\text{AIC}_1,\\ \\text{BIC}_1,\\ \\text{CV}_1,\\ \\text{AIC}_2,\\ \\text{BIC}_2,\\ \\text{CV}_2,\\ \\text{AIC}_3,\\ \\text{BIC}_3,\\ \\text{CV}_3],\n$$\n例如，其中 $\\text{AIC}_2$ 是根据 AIC 为数据集 2 选择的模型阶数。每个条目必须是整数 1、2 或 3。", "solution": "该问题要求实现一个模型选择程序，以确定化学弛豫动力学模型中指数项的最佳数量。我们有三个候选模型，分别对应 $m=1$、$m=2$ 和 $m=3$ 个指数衰减项之和，外加一个常数偏移量。在时间 $t$ 观测到的信号 $y(t)$ 的模型为\n$$\ny(t) = C + \\sum_{i=1}^{m} A_i \\exp\\left(-\\frac{t}{\\tau_i}\\right) + \\varepsilon(t),\n$$\n其中 $C$ 是基线偏移量，$A_i$ 是振幅，$\\tau_i$ 是正的弛豫时间常数，而 $\\varepsilon(t)$ 代表均值为零的独立同分布高斯噪声。一个 $m$ 阶模型的可估计参数数量为 $p_m = 2m + 1$。\n\n主要任务是为每个模型阶数 $m \\in \\{1, 2, 3\\}$ 找到最优的参数集 $\\{C, \\{A_i\\}_{i=1}^m, \\{\\tau_i\\}_{i=1}^m\\}$。高斯噪声下的最大似然原理指出，这些参数是通过最小化残差平方和 (RSS) 来找到的：\n$$\n\\mathrm{RSS}_m = \\sum_{j=1}^{n} \\left[y_j - \\hat{y}_m(t_j)\\right]^2,\n$$\n其中 $\\{y_j\\}$ 是在时间 $\\{t_j\\}$ 观测到的 $n$ 个数据点，$\\hat{y}_m(t)$ 是 $m$ 阶的模型函数。这构成了一个非线性最小二乘优化问题。我们将通过 `scipy.optimize.curve_fit` 使用 Levenberg-Marquardt 算法来解决它。非线性拟合的成功在很大程度上取决于提供良好的初始参数猜测和有物理动机的约束。我们将使用边界来强制执行 $\\tau_i > 0$ 的约束。初始猜测将从数据的宏观特征中推导得出：基线 $C$ 根据长时间的信号估计，总振幅根据初始信号变化估计，而时间常数 $\\tau_i$ 在测量时间窗口内对数分布。\n\n在为每个模型最小化 $\\mathrm{RSS}_m$ 后，我们使用三个不同的准则进行模型选择。\n\n首先是赤池信息准则 (AIC) 和贝叶斯信息准则 (BIC)。这些是信息论准则，用于在拟合优度和模型复杂性之间进行权衡。提供的公式是：\n$$\n\\mathrm{AIC}_m = n \\log\\left(\\frac{\\mathrm{RSS}_m}{n}\\right) + 2 p_m\n$$\n$$\n\\mathrm{BIC}_m = n \\log\\left(\\frac{\\mathrm{RSS}_m}{n}\\right) + p_m \\log n\n$$\nBIC 对额外参数的惩罚比 AIC 更强，因为它的惩罚项与数据点数量的对数 $\\log n$ 成正比。对于这两个准则，使准则值最小化的模型阶数 $m$ 被认为是最佳的。\n\n其次是 $K=5$ 的 $K$ 折交叉验证 (CV)。此方法提供模型在未用于训练的数据上的预测性能的估计。数据集被划分为 $K=5$ 个不相交的折。对于每一折，模型在其他 $K-1$ 个折上进行训练，并在留出的那一折上计算其均方误差 (MSE)。一个模型的 CV 分数是这 $K$ 个折的 MSE 的平均值：\n$$\n\\mathrm{CV-MSE}_m = \\frac{1}{K} \\sum_{k=1}^{K} \\left( \\frac{1}{|S_k|} \\sum_{j \\in S_k} \\left[y_j - \\hat{y}_{m, -k}(t_j)\\right]^2 \\right)\n$$\n其中 $S_k$ 表示第 $k$ 折，$\\hat{y}_{m, -k}(t_j)$ 是在除第 $k$ 折之外的所有数据上训练的模型所做的预测。选择使该平均预测误差最小化的模型阶数 $m$。为了确保可复现性，使用固定的随机种子 42 进行分区。\n\n对于提供的三个数据集中的每一个，总体流程如下：\n1.  生成合成数据集：创建时间向量，使用给定参数计算真实信号，并添加具有指定标准差 $\\sigma$ 的高斯噪声。\n2.  对于每个模型阶数 $m \\in \\{1, 2, 3\\}$：\n    a. 将模型拟合到完整数据集以找到最佳拟合参数，然后计算 $\\mathrm{RSS}_m$。\n    b. 使用 $\\mathrm{RSS}_m$ 计算 $\\mathrm{AIC}_m$ 和 $\\mathrm{BIC}_m$。\n    c. 执行 5 折交叉验证以计算 $\\mathrm{CV-MSE}_m$。\n3.  对于三个准则中的每一个，选择使相应分数最小化的模型阶数 $m$。如果多个模型的分数在最小值加容差 $\\epsilon = 10^{-9}$ 的范围内，则选择 $m$ 最小的那个。\n4.  最终输出是九个选定模型阶数（3 个准则 $\\times$ 3 个数据集）的集合。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Implements model selection for exponential decay models using AIC, BIC,\n    and K-fold cross-validation.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 200, \"T_max\": 3.0, \"m_true\": 1,\n            \"A_true\": [1.2], \"tau_true\": [0.5], \"C_true\": 0.0,\n            \"sigma\": 0.02, \"gen_seed\": 0\n        },\n        {\n            \"n\": 300, \"T_max\": 2.0, \"m_true\": 2,\n            \"A_true\": [0.6, 0.4], \"tau_true\": [0.1, 1.0], \"C_true\": 0.05,\n            \"sigma\": 0.02, \"gen_seed\": 1\n        },\n        {\n            \"n\": 400, \"T_max\": 3.0, \"m_true\": 3,\n            \"A_true\": [0.5, 0.3, 0.2], \"tau_true\": [0.02, 0.2, 2.0], \"C_true\": -0.1,\n            \"sigma\": 0.01, \"gen_seed\": 2\n        }\n    ]\n\n    def model_factory(m):\n        \"\"\"Creates a model function for a sum of m exponentials.\"\"\"\n        def model(t, *params):\n            C = params[0]\n            Amps = params[1:m+1]\n            Taus = params[m+1:2*m+1]\n            y = np.full_like(t, C, dtype=float)\n            for i in range(m):\n                y += Amps[i] * np.exp(-t / Taus[i])\n            return y\n        return model\n\n    def get_initial_params(m, t, y):\n        \"\"\"Generates initial parameter guesses for the optimizer.\"\"\"\n        C_guess = y[-1]\n        A_total_guess = y[0] - C_guess\n        A_guesses = [A_total_guess / m] * m\n        \n        t_max = t[-1]\n        t_step = t[1] - t[0] if len(t) > 1 else 0.01\n        if t_step == 0: t_step = 1e-4\n\n        if m == 1:\n            tau_guesses = [t_max / 3.0]\n        else:\n            # Distribute time constants logarithmically\n            tau_guesses = np.logspace(np.log10(t_step), np.log10(t_max), m).tolist()\n\n        return [C_guess] + A_guesses + tau_guesses\n\n    def get_bounds(m, t):\n        \"\"\"Generates parameter bounds for the optimizer.\"\"\"\n        t_max = t[-1]\n        lower_bounds = [-np.inf] + [-np.inf] * m + [1e-9] * m\n        upper_bounds = [np.inf] + [np.inf] * m + [t_max * 10] * m\n        return (lower_bounds, upper_bounds)\n\n    def select_best_model(scores, tolerance=1e-9):\n        \"\"\"Selects the best model order based on scores and a tie-breaking rule.\"\"\"\n        if not scores or all(s is None or np.isinf(s) for s in scores):\n            return -1  # Indicates failure for all models\n\n        valid_scores = [s for s in scores if s is not None and not np.isinf(s)]\n        if not valid_scores: return -1\n\n        min_score = min(valid_scores)\n        \n        candidate_ms = []\n        for i, score in enumerate(scores):\n            if score is not None and not np.isinf(score):\n                if score = min_score + tolerance:\n                    candidate_ms.append(i + 1)\n        \n        return min(candidate_ms) if candidate_ms else -1\n\n    all_results = []\n    \n    for case in test_cases:\n        n, T_max, m_true = case['n'], case['T_max'], case['m_true']\n        A_true, tau_true, C_true = case['A_true'], case['tau_true'], case['C_true']\n        sigma, gen_seed = case['sigma'], case['gen_seed']\n        \n        # --- Generate Data ---\n        t = np.linspace(0, T_max, n)\n        true_model_func = model_factory(m_true)\n        y_true = true_model_func(t, *([C_true] + A_true + tau_true))\n        rng_data = np.random.default_rng(gen_seed)\n        noise = rng_data.normal(loc=0.0, scale=sigma, size=n)\n        y_obs = y_true + noise\n\n        aic_scores, bic_scores, cv_scores = [], [], []\n\n        for m in [1, 2, 3]:\n            model_m = model_factory(m)\n            p0 = get_initial_params(m, t, y_obs)\n            bounds = get_bounds(m, t)\n            p_m = 2 * m + 1\n\n            # --- Full data fit for AIC/BIC ---\n            try:\n                popt, _ = curve_fit(model_m, t, y_obs, p0=p0, bounds=bounds, maxfev=10000)\n                y_pred = model_m(t, *popt)\n                rss_m = np.sum((y_obs - y_pred)**2)\n                \n                if rss_m = 1e-12: # Avoid log(0) or instability\n                    aic_m = bic_m = np.inf\n                else:\n                    log_likelihood_term = n * np.log(rss_m / n)\n                    aic_m = log_likelihood_term + 2 * p_m\n                    bic_m = log_likelihood_term + p_m * np.log(n)\n            except (RuntimeError, ValueError):\n                aic_m = bic_m = np.inf\n            aic_scores.append(aic_m)\n            bic_scores.append(bic_m)\n\n            # --- 5-fold Cross-Validation ---\n            K = 5\n            rs_cv = np.random.RandomState(42)\n            indices = np.arange(n)\n            rs_cv.shuffle(indices)\n            folds = np.array_split(indices, K)\n            \n            fold_mses = []\n            fit_failed_in_cv = False\n            for val_idx in folds:\n                train_idx = np.setdiff1d(indices, val_idx, assume_unique=True)\n                \n                t_train, y_train = t[train_idx], y_obs[train_idx]\n                t_val, y_val = t[val_idx], y_obs[val_idx]\n\n                p0_cv = get_initial_params(m, t_train, y_train)\n                bounds_cv = get_bounds(m, t_train)\n\n                try:\n                    popt_cv, _ = curve_fit(model_m, t_train, y_train, p0=p0_cv, bounds=bounds_cv, maxfev=10000)\n                    y_pred_val = model_m(t_val, *popt_cv)\n                    mse_k = np.mean((y_val - y_pred_val)**2)\n                    fold_mses.append(mse_k)\n                except (RuntimeError, ValueError):\n                    fit_failed_in_cv = True\n                    break\n            \n            cv_m = np.mean(fold_mses) if not fit_failed_in_cv else np.inf\n            cv_scores.append(cv_m)\n\n        # --- Select best model for this dataset ---\n        aic_choice = select_best_model(aic_scores)\n        bic_choice = select_best_model(bic_scores)\n        cv_choice = select_best_model(cv_scores)\n\n        all_results.extend([aic_choice, bic_choice, cv_choice])\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2669947"}]}