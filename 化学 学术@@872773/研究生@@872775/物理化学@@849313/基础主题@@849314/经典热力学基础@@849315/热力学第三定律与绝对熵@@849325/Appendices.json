{"hands_on_practices": [{"introduction": "理论的基石在于能够从第一性原理推导出可观测的宏观属性。本练习将指导您完成一个核心的统计力学推导：计算同位素混合物在绝对零度附近的残留熵。通过从玻尔兹曼熵公式 $S = k_{B} \\ln W$ 出发，并应用斯特林近似，您将亲自推导出混合熵的著名表达式，从而深刻理解宏观热力学量与其微观组态根源之间的直接联系。[@problem_id:2680901]", "problem": "一种单原子晶体由两种同位素（记为A和B）组成，它们以固定的摩尔分数 $x$ 和 $1-x$ 随机取代 $N$ 个等效晶格点。假设在 $T \\to 0$ 的极限下，所有晶格点对于A和B在能量上是等效的，振动自由度处于其基态，因此激发没有贡献，并且在 $T \\to 0$ 时唯一的简并度来源是同位素在晶格点上的取代排列。该固体是一种宏观上大的、遍历性不可及的淬火随机排列，与其低温平衡组成一致。\n\n从玻尔兹曼熵定义 $S = k_{B} \\ln W$ 和晶格上同位素可区分构型数 $W$ 的组合计数出发，推导在热力学极限下，每摩尔晶格点的摩尔剩余熵 $S_{\\mathrm{res},m}$ 作为 $x$ 的函数。然后，计算等摩尔情况（$x = \\tfrac{1}{2}$）下的剩余摩尔熵。将您的最终数值结果以 $\\text{J mol}^{-1} \\text{K}^{-1}$ 为单位表示，并将答案四舍五入到四位有效数字。", "solution": "所述问题是有效的。这是一个有科学依据、适定且客观的物理化学问题，可以使用统计力学的基本原理解答。\n\n该问题要求推导晶格上二元同位素混合物的摩尔剩余熵 $S_{\\mathrm{res},m}$。此推导的基础是玻尔兹曼熵定义，它将熵 $S$ 与系统可及的微观态数 $W$ 联系起来：\n$$S = k_{B} \\ln W$$\n其中 $k_{B}$ 是玻尔兹曼常数。\n\n问题指明，在温度 $T \\to 0$ 时，熵的唯一来源是由两种同位素A和B在 $N$ 个晶格点上的随机排列引起的构型简并度。给定有 $N_A = xN$ 个同位素A原子和 $N_B = (1-x)N$ 个同位素B原子，其中 $x$ 是同位素A的摩尔分数， $N$ 是晶格点的总数。\n\n可区分的构型数 $W$ 是在 $N = N_A + N_B$ 个不同位置上排列 $N_A$ 个A类相同物品和 $N_B$ 个B类相同物品的方法数。这由二项式系数给出：\n$$W = \\binom{N}{N_A} = \\frac{N!}{N_A! N_B!}$$\n将此代入玻尔兹曼熵公式，得到：\n$$S = k_{B} \\ln \\left( \\frac{N!}{N_A! N_B!} \\right) = k_{B} (\\ln(N!) - \\ln(N_A!) - \\ln(N_B!))$$\n由于固体是宏观的，原子数 $N$、$N_A$ 和 $N_B$ 都非常大。因此，我们可以对大数 $n$ 的阶乘的自然对数应用斯特林近似 $\\ln(n!) \\approx n \\ln n - n$。将此应用于每个阶乘项：\n$$ \\ln(N!) \\approx N \\ln N - N $$\n$$ \\ln(N_A!) \\approx N_A \\ln N_A - N_A $$\n$$ \\ln(N_B!) \\approx N_B \\ln N_B - N_B $$\n将这些近似值代入熵 $S$ 的表达式中：\n$$ S \\approx k_{B} \\left[ (N \\ln N - N) - (N_A \\ln N_A - N_A) - (N_B \\ln N_B - N_B) \\right] $$\n$$ S \\approx k_{B} \\left[ N \\ln N - N_A \\ln N_A - N_B \\ln N_B - (N - N_A - N_B) \\right] $$\n由于 $N = N_A + N_B$，项 $(N - N_A - N_B)$ 等于0。表达式简化为：\n$$ S \\approx k_{B} \\left[ N \\ln N - N_A \\ln N_A - N_B \\ln N_B \\right] $$\n现在，我们用位点总数 $N$ 和摩尔分数 $x$ 来表示 $N_A$ 和 $N_B$：$N_A = xN$ 和 $N_B = (1-x)N$。\n$$ S \\approx k_{B} \\left[ N \\ln N - (xN) \\ln(xN) - ((1-x)N) \\ln((1-x)N) \\right] $$\n使用对数性质 $\\ln(ab) = \\ln a + \\ln b$：\n$$ S \\approx k_{B} \\left[ N \\ln N - xN(\\ln x + \\ln N) - (1-x)N(\\ln(1-x) + \\ln N) \\right] $$\n$$ S \\approx k_{B} \\left[ N \\ln N - xN \\ln x - xN \\ln N - (1-x)N \\ln(1-x) - (1-x)N \\ln N \\right] $$\n我们可以将含有 $\\ln N$ 的项组合在一起：\n$$ S \\approx k_{B} \\left[ (N - xN - (1-x)N) \\ln N - xN \\ln x - (1-x)N \\ln(1-x) \\right] $$\n乘以 $\\ln N$ 的项是 $N - xN - N + xN = 0$。这样剩下：\n$$ S = -N k_{B} \\left[ x \\ln x + (1-x) \\ln(1-x) \\right] $$\n这是 $N$ 个位点系统的总剩余熵。问题要求的是摩尔剩余熵 $S_{\\mathrm{res},m}$，即每摩尔晶格点的熵。晶格点的摩尔数是 $n = N/N_{A}$，其中 $N_{A}$ 是阿伏伽德罗常数。\n$$ S_{\\mathrm{res},m} = \\frac{S}{n} = \\frac{-N k_{B} \\left[ x \\ln x + (1-x) \\ln(1-x) \\right]}{N/N_{A}} $$\n$$ S_{\\mathrm{res},m} = -N_{A} k_{B} \\left[ x \\ln x + (1-x) \\ln(1-x) \\right] $$\n阿伏伽德罗常数和玻尔兹曼常数的乘积是普适气体常数 $R = N_{A} k_{B}$。因此，摩尔剩余熵作为组分 $x$ 的函数是：\n$$ S_{\\mathrm{res},m}(x) = -R \\left[ x \\ln x + (1-x) \\ln(1-x) \\right] $$\n这就完成了问题的第一部分。\n\n第二部分要求计算等摩尔情况（$x = \\frac{1}{2}$ 或 $x = 0.5$）下该表达式的值。\n将 $x = 0.5$ 代入推导出的公式：\n$$ S_{\\mathrm{res},m}(0.5) = -R \\left[ 0.5 \\ln(0.5) + (1-0.5) \\ln(0.5) \\right] $$\n$$ S_{\\mathrm{res},m}(0.5) = -R \\left[ 0.5 \\ln(0.5) + 0.5 \\ln(0.5) \\right] = -R \\ln(0.5) $$\n使用对数性质 $\\ln(0.5) = \\ln(\\frac{1}{2}) = -\\ln(2)$：\n$$ S_{\\mathrm{res},m}(0.5) = -R (-\\ln(2)) = R \\ln(2) $$\n为了求出数值，我们使用普适气体常数的值 $R \\approx 8.31446 \\, \\text{J mol}^{-1} \\text{K}^{-1}$ 和 $\\ln(2) \\approx 0.693147$ 的值。\n$$ S_{\\mathrm{res},m}(0.5) \\approx (8.31446 \\, \\text{J mol}^{-1} \\text{K}^{-1}) \\times (0.693147) $$\n$$ S_{\\mathrm{res},m}(0.5) \\approx 5.7628 \\, \\text{J mol}^{-1} \\text{K}^{-1} $$\n问题要求答案四舍五入到四位有效数字。第五位有效数字是8，所以我们将第四位数字向上取整。\n$$ S_{\\mathrm{res},m}(0.5) \\approx 5.763 \\, \\text{J mol}^{-1} \\text{K}^{-1} $$", "answer": "$$\\boxed{5.763}$$", "id": "2680901"}, {"introduction": "热力学第三定律不仅为熵设定了绝对零点，也引发了关于过冷液体和玻璃态物质本质的深刻思考。这个思想实验探讨了所谓的“熵危机”——如果一个无序的非晶相的熵随着温度降低而持续减少，是否可能在某个正温度下变得比其对应的完美晶体还要低？通过构建和分析晶体与非晶态在低温下的熵函数，您将推导出考兹曼温度 $T_K$ 的表达式，这是一个理解玻璃化转变奥秘的关键概念。[@problem_id:2022102]", "problem": "一种新的二维（2D）聚合物已被合成，它在低温下可以以两种不同的固相形态存在：一种是完全有序的晶体单层，另一种是无序的非晶体单层。根据热力学第三定律，晶体形态的摩尔熵在绝对零度时为零，即 $S_{m}^{(c)}(0) = 0$。而非晶体形态由于其固有的无序性，在绝对零度时具有一个非零的剩余摩尔熵，记为 $S_0$。\n\n在低温下，理论模型预测这两种相的恒压摩尔热容 $C_{p,m}$ 可以很好地用以下关于温度 $T$ 的函数来近似：\n- 对于晶体单层：$C_{p,m}^{(c)}(T) = \\alpha T^{2}$\n- 对于非晶体单层：$C_{p,m}^{(a)}(T) = \\beta T$\n\n此处，$\\alpha$ 和 $\\beta$ 是该材料特有的正常数。如果无序的非晶相的熵降至低于有序的晶相的熵，就会出现一个热力学佯谬，有时被称为“熵危机”。假设给定的低温热容模型对于外推是有效的，请确定一个假设的温度 $T_K > 0$，在该温度下，非晶体单层的摩尔熵将变得等于晶体单层的摩尔熵。\n\n请用 $\\alpha$、$\\beta$ 和 $S_0$ 将您的答案表示为一个符号表达式。", "solution": "对于恒压下的可逆路径，摩尔熵的变化遵循\n$$\n\\mathrm{d}S_{m}=\\frac{C_{p,m}(T)}{T}\\,\\mathrm{d}T.\n$$\n从绝对零度积分到温度 $T$ 得到\n$$\nS_{m}(T)=S_{m}(0)+\\int_{0}^{T}\\frac{C_{p,m}(T')}{T'}\\,\\mathrm{d}T'.\n$$\n\n晶体单层：给定 $S_{m}^{(c)}(0)=0$ 和 $C_{p,m}^{(c)}(T)=\\alpha T^{2}$，\n$$\nS_{m}^{(c)}(T)=0+\\int_{0}^{T}\\frac{\\alpha {T'}^{2}}{T'}\\,\\mathrm{d}T'=\\alpha\\int_{0}^{T}T'\\,\\mathrm{d}T'=\\frac{\\alpha}{2}T^{2}.\n$$\n\n非晶体单层：给定 $S_{m}^{(a)}(0)=S_{0}$ 和 $C_{p,m}^{(a)}(T)=\\beta T$，\n$$\nS_{m}^{(a)}(T)=S_{0}+\\int_{0}^{T}\\frac{\\beta T'}{T'}\\,\\mathrm{d}T'=S_{0}+\\beta\\int_{0}^{T}\\mathrm{d}T'=S_{0}+\\beta T.\n$$\n\n假设的考兹曼 (Kauzmann) 温度 $T_{K}$ 被定义为满足 $S_{m}^{(a)}(T_{K})=S_{m}^{(c)}(T_{K})$。因此，\n$$\nS_{0}+\\beta T_{K}=\\frac{\\alpha}{2}T_{K}^{2},\n$$\n这可以重排为二次方程\n$$\n\\frac{\\alpha}{2}T_{K}^{2}-\\beta T_{K}-S_{0}=0.\n$$\n乘以 2，\n$$\n\\alpha T_{K}^{2}-2\\beta T_{K}-2S_{0}=0.\n$$\n解出 $T_{K}$，\n$$\nT_{K}=\\frac{2\\beta\\pm\\sqrt{(2\\beta)^{2}+8\\alpha S_{0}}}{2\\alpha}=\\frac{\\beta\\pm\\sqrt{\\beta^{2}+2\\alpha S_{0}}}{\\alpha}.\n$$\n由于 $\\alpha>0$、$\\beta>0$ 和 $S_{0}>0$，具有物理意义的（正）根由正号得到：\n$$\nT_{K}=\\frac{\\beta+\\sqrt{\\beta^{2}+2\\alpha S_{0}}}{\\alpha}.\n$$", "answer": "$$\\boxed{\\frac{\\beta+\\sqrt{\\beta^{2}+2\\alpha S_{0}}}{\\alpha}}$$", "id": "2022102"}, {"introduction": "从理论模型到实验现实的跨越是科学研究的关键一步。在实践中，绝对熵通常不是通过微观态计数，而是通过对实验测量的热容数据进行积分来确定的。本练习模拟了这一过程，要求您编写一个程序，根据分段多项式拟合的热容数据和相变潜热，计算一种假设物质在不同温度下的绝对熵。这个计算实践不仅巩固了熵的积分定义，还让您掌握了处理真实实验数据（包括一级相变点）以获得基本热力学状态函数的实用技能。[@problem_id:2680899]", "problem": "给定一种假设的晶体物质，其测得的摩尔定压热容 (Cp) 在连续温度区间上由分段多项式表示，并存在两次一级相变。目标是仅使用平衡热力学的基本定律和定义，计算绝对摩尔熵作为温度的函数，并在一个程序中实现此计算，该程序能在各个区间和相变温度点上生成数值稳定的值。假设在零温下为完美晶体，因此热力学第三定律适用，无残余熵。\n\n物质数据：\n- 分段 Cp 拟合（每个多项式是关于温度 $T$ 的幂函数，系数按 $\\{a_0,a_1,a_2,\\dots\\}$ 顺序排列，使得 $C_p(T)=\\sum_{k=0}^{n} a_k T^k$）：\n  1. 区间 $\\left[0.0,50.0\\right)$ 开尔文，系数为 $\\{0.0,0.0,0.0,1.5\\times 10^{-4}\\}$。\n  2. 区间 $\\left[50.0,150.0\\right)$ 开尔文，系数为 $\\{12.0,0.02,1.0\\times 10^{-4}\\}$。\n  3. 区间 $\\left[150.0,400.0\\right)$ 开尔文，系数为 $\\{20.0,0.015,2.0\\times 10^{-5}\\}$。\n  4. 区间 $\\left[400.0,800.0\\right]$ 开尔文，系数为 $\\{30.0,0.005\\}$。\n\n- 以温度和摩尔潜热为特征的一级相变：\n  1. 在 $T=150.0$ 开尔文发生固-固相变，潜热 $L=500.0$ 焦耳/摩尔。\n  2. 在 $T=400.0$ 开尔文发生熔化，潜热 $L=10000.0$ 焦耳/摩尔。\n\n假设和要求：\n- 将每个多项式区间视为仅在其指定温度范围内有效的独立拟合。\n- 必须包含在 $T=150.0$ 开尔文和 $T=400.0$ 开尔文的相变，以使绝对熵在从 $T=0.0$ 开尔文向上的平衡路径上随温度连续。将“等于或高于”相变温度解释为包含潜热的贡献。\n- 从适用于恒压可逆加热和热力学第三定律的第一性原理定义出发；不要使用任何其他唯象的简化方法。\n- 所有积分和求和的计算方式必须在 $T=0.0$ 开尔文和分段边界处是良定义的。数据所蕴含的被积函数结构使得这成为可能，而无需引入任何非物理行为。\n\n单位：\n- 温度单位必须是开尔文。\n- 热容单位是焦耳/摩尔/开尔文。\n- 潜热单位是焦耳/摩尔。\n- 报告绝对摩尔熵，单位为焦耳/摩尔/开尔文，四舍五入到六位小数。\n\n测试集：\n计算以下温度（开尔文）下的绝对摩尔熵：$\\{0.0, 25.0, 50.0, 150.0, 200.0, 333.33, 400.0, 600.0\\}$。\n\n程序输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$，其中每个 $\\text{result}_i$ 是一个四舍五入到六位小数的浮点数，顺序与测试集温度相同。", "solution": "问题陈述有效。这是一个物理化学中良定义的（well-posed）问题，它基于热力学的基本原理，并为获得唯一解提供了所有必要的数据。所提供的分段热容函数在区间边界处存在不连续性，这是经验模型的常见特征，但这并不影响熵的热力学计算，因为熵是状态函数。我们将继续进行求解。\n\n物质在温度 $T$ 下的绝对摩尔熵 $S(T)$ 由热力学第三定律和熵变的定义确定。第三定律指出，完美晶体在绝对零度时的熵为零。\n$$S(T=0 \\text{ K}) = 0$$\n对于恒定压力 $P$ 下的可逆过程，无穷小的熵变 $dS$ 与恒压热容 $C_p$ 的关系如下：\n$$dS = \\frac{dq_{\\text{rev}}}{T} = \\frac{C_p(T) dT}{T}$$\n假设在此范围内没有相变发生，从 $0$ K 积分到温度 $T$ 即可得到绝对熵：\n$$S(T) = S(0) + \\int_{0}^{T} \\frac{C_p(T')}{T'} dT' = \\int_{0}^{T} \\frac{C_p(T')}{T'} dT'$$\n如果物质在温度 $T_{\\text{tr}}$ 经历一级相变，其摩尔相变潜热为 $L_{\\text{tr}}$，则会产生额外的熵变：\n$$\\Delta S_{\\text{tr}} = \\frac{L_{\\text{tr}}}{T_{\\text{tr}}}$$\n因此，温度 $T$ 下的绝对熵是由于加热以及在低于或等于 $T$ 的温度下发生的相变所引起的所有熵增之和。\n$$S(T) = \\int_{0}^{T} \\frac{C_p(T')}{T'} dT' + \\sum_{T_{\\text{tr},i} \\le T} \\frac{L_{\\text{tr},i}}{T_{\\text{tr},i}}$$\n热容 $C_p(T)$ 以分段多项式函数 $C_p(T) = \\sum_{k=0}^{n} a_k T^k$ 的形式给出。必须对每个分段计算 $\\frac{C_p(T)}{T}$ 的积分。对于一个通用的多项式分段，其积分为：\n$$\\int \\frac{\\sum_{k=0}^{n} a_k (T')^k}{T'} dT' = \\int \\left( \\frac{a_0}{T'} + a_1 + a_2 T' + \\dots + a_n (T')^{n-1} \\right) dT' = a_0 \\ln(T') + a_1 T' + \\frac{a_2}{2}(T')^2 + \\dots + \\frac{a_n}{n}(T')^n$$\n我们必须在给定的温度区间和相变点上累积应用此过程。让我们定义变化点：$T_1 = 50.0$ K（函数变化），$T_2 = 150.0$ K（函数变化和相变），以及 $T_3 = 400.0$ K（函数变化和相变）。\n\n**1. 区间 1：$T \\in [0.0, 50.0)$ K**\n$C_{p,1}(T) = 1.5 \\times 10^{-4} T^3$。这种形式与低温下的 Debye $T^3$ 定律一致。\n$$S(T) = \\int_{0}^{T} \\frac{1.5 \\times 10^{-4} (T')^3}{T'} dT' = \\int_{0}^{T} 1.5 \\times 10^{-4} (T')^2 dT' = \\left[ \\frac{1.5 \\times 10^{-4}}{3} (T')^3 \\right]_0^T = \\frac{1.5 \\times 10^{-4}}{3} T^3$$\n在边界 $T_1 = 50.0$ K 处，熵为：\n$$S(50.0) = \\frac{1.5 \\times 10^{-4} \\times (50.0)^3}{3} = 6.25 \\, \\text{J mol}^{-1} \\text{K}^{-1}$$\n\n**2. 区间 2：$T \\in [50.0, 150.0)$ K**\n$C_{p,2}(T) = 12.0 + 0.02T + 1.0 \\times 10^{-4} T^2$。对于此区间内的 $T$，熵为：\n$$S(T) = S(50.0) + \\int_{50.0}^{T} \\frac{C_{p,2}(T')}{T'} dT'$$\n在第一次相变（$T_2 = 150.0$ K）发生前的熵为：\n$$S(150.0^{-}) = S(50.0) + \\int_{50.0}^{150.0} \\left( \\frac{12.0}{T'} + 0.02 + 1.0 \\times 10^{-4} T' \\right) dT'$$\n$$S(150.0^{-}) = 6.25 + \\left[ 12.0 \\ln(T') + 0.02 T' + \\frac{1.0 \\times 10^{-4}}{2}(T')^2 \\right]_{50.0}^{150.0} \\approx 6.25 + 16.183347 = 22.433347 \\, \\text{J mol}^{-1} \\text{K}^{-1}$$\n在 $T_2 = 150.0$ K，发生固-固相变，潜热 $L_1 = 500.0$ 焦耳/摩尔。相变熵为 $\\Delta S_{\\text{tr},1} = \\frac{500.0}{150.0} = \\frac{10}{3} \\, \\text{J mol}^{-1} \\text{K}^{-1}$。\n在 $150.0$ K 时，包含相变在内的熵为：\n$$S(150.0) = S(150.0^{-}) + \\Delta S_{\\text{tr},1} \\approx 22.433347 + 3.333333 = 25.766681 \\, \\text{J mol}^{-1} \\text{K}^{-1}$$\n\n**3. 区间 3：$T \\in [150.0, 400.0)$ K**\n$C_{p,3}(T) = 20.0 + 0.015T + 2.0 \\times 10^{-5} T^2$。对于此区间内的 $T$：\n$$S(T) = S(150.0) + \\int_{150.0}^{T} \\frac{C_{p,3}(T')}{T'} dT'$$\n在熔化（$T_3 = 400.0$ K）前的熵为：\n$$S(400.0^{-}) = S(150.0) + \\int_{150.0}^{400.0} \\left( \\frac{20.0}{T'} + 0.015 + 2.0 \\times 10^{-5} T' \\right) dT'$$\n$$S(400.0^{-}) \\approx 25.766681 + \\left[ 20.0 \\ln(T') + 0.015 T' + \\frac{2.0 \\times 10^{-5}}{2}(T')^2 \\right]_{150.0}^{400.0} \\approx 25.766681 + 24.741585 = 50.508266 \\, \\text{J mol}^{-1} \\text{K}^{-1}$$\n在 $T_3 = 400.0$ K，发生熔化，潜热 $L_2 = 10000.0$ 焦耳/摩尔。熔化熵为 $\\Delta S_{\\text{tr},2} = \\frac{10000.0}{400.0} = 25.0 \\, \\text{J mol}^{-1} \\text{K}^{-1}$。\n在 $400.0$ K 时的熵为：\n$$S(400.0) = S(400.0^{-}) + \\Delta S_{\\text{tr},2} \\approx 50.508266 + 25.0 = 75.508266 \\, \\text{J mol}^{-1} \\text{K}^{-1}$$\n\n**4. 区间 4：$T \\in [400.0, 800.0]$ K**\n$C_{p,4}(T) = 30.0 + 0.005T$。对于此区间内的 $T$：\n$$S(T) = S(400.0) + \\int_{400.0}^{T} \\frac{C_{p,4}(T')}{T'} dT' = S(400.0) + \\int_{400.0}^{T} \\left( \\frac{30.0}{T'} + 0.005 \\right) dT'$$\n例如，在 $T = 600.0$ K 时：\n$$S(600.0) = S(400.0) + \\left[ 30.0 \\ln(T') + 0.005 T' \\right]_{400.0}^{600.0} \\approx 75.508266 + 13.163953 = 88.672219 \\, \\text{J mol}^{-1} \\text{K}^{-1}$$\n\n实现将包含一个函数，该函数针对给定的温度 $T$ 确定其所在的温度区间，并通过将所有先前区间和相变的贡献与当前区间内的贡献相加来计算熵。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the absolute molar entropy for a hypothetical substance at various temperatures.\n    The calculation is based on piecewise polynomial fits for heat capacity (Cp) and\n    includes entropy changes from two first-order phase transitions, adhering to the\n    Third Law of Thermodynamics.\n    \"\"\"\n\n    # Test temperatures in Kelvin\n    test_temperatures = [0.0, 25.0, 50.0, 150.0, 200.0, 333.33, 400.0, 600.0]\n\n    # Model parameters\n    # Cp(T) = sum(a_k * T^k)\n    # Coefficients {a0, a1, a2, ...} for each segment\n    cp_coeffs = {\n        1: [0.0, 0.0, 0.0, 1.5e-4],       # T in [0, 50)\n        2: [12.0, 0.02, 1.0e-4],         # T in [50, 150)\n        3: [20.0, 0.015, 2.0e-5],        # T in [150, 400)\n        4: [30.0, 0.005]                 # T in [400, 800]\n    }\n    \n    # Phase transitions\n    transitions = {\n        150.0: 500.0,   # T_tr in K, Latent heat L in J/mol\n        400.0: 10000.0\n    }\n    \n    # Temperature boundaries for Cp segments\n    T_boundaries = [0.0, 50.0, 150.0, 400.0, 800.0]\n\n    def integral_cp_over_t(coeffs, T_low, T_high):\n        \"\"\"\n        Calculates the definite integral of Cp(T)/T from T_low to T_high for a given polynomial.\n        int( (a0/T + a1 + a2*T + ...) dT ) = a0*ln(T) + a1*T + (a2/2)*T^2 + ...\n        \"\"\"\n        if T_high == T_low:\n            return 0.0\n\n        def antiderivative(T):\n            if T == 0: return 0.0\n            val = 0.0\n            # a0*ln(T) term\n            if len(coeffs) > 0 and coeffs[0] != 0.0:\n                val += coeffs[0] * np.log(T)\n            # Higher order terms: (a_k / k) * T^k for k>=1\n            for k in range(1, len(coeffs)):\n                val += (coeffs[k] / k) * T**k\n            return val\n            \n        return antiderivative(T_high) - antiderivative(T_low)\n\n    # Pre-calculate entropy at boundary points for efficiency\n    s_boundaries = {}\n    s_boundaries[T_boundaries[0]] = 0.0\n    \n    # S at 50K\n    s_50 = integral_cp_over_t(cp_coeffs[1], T_boundaries[0], T_boundaries[1])\n    s_boundaries[T_boundaries[1]] = s_50\n    \n    # S at 150K\n    s_150_pre = s_50 + integral_cp_over_t(cp_coeffs[2], T_boundaries[1], T_boundaries[2])\n    s_150_post = s_150_pre + transitions[T_boundaries[2]] / T_boundaries[2]\n    s_boundaries[T_boundaries[2]] = s_150_post\n\n    # S at 400K\n    s_400_pre = s_150_post + integral_cp_over_t(cp_coeffs[3], T_boundaries[2], T_boundaries[3])\n    s_400_post = s_400_pre + transitions[T_boundaries[3]] / T_boundaries[3]\n    s_boundaries[T_boundaries[3]] = s_400_post\n\n    def calculate_entropy(T):\n        \"\"\"\n        Calculates absolute molar entropy at a specific temperature T.\n        \"\"\"\n        if T  0.0:\n            raise ValueError(\"Temperature must be non-negative.\")\n        \n        if T  T_boundaries[1]: # T in [0, 50)\n            return s_boundaries[T_boundaries[0]] + integral_cp_over_t(cp_coeffs[1], T_boundaries[0], T)\n        \n        elif T  T_boundaries[2]: # T in [50, 150)\n            return s_boundaries[T_boundaries[1]] + integral_cp_over_t(cp_coeffs[2], T_boundaries[1], T)\n        \n        elif T == T_boundaries[2]: # T = 150\n            return s_boundaries[T_boundaries[2]] # Includes transition\n        \n        elif T  T_boundaries[3]: # T in (150, 400)\n            return s_boundaries[T_boundaries[2]] + integral_cp_over_t(cp_coeffs[3], T_boundaries[2], T)\n        \n        elif T == T_boundaries[3]: # T = 400\n            return s_boundaries[T_boundaries[3]] # Includes transition\n        \n        elif T = T_boundaries[4]: # T in (400, 800]\n            return s_boundaries[T_boundaries[3]] + integral_cp_over_t(cp_coeffs[4], T_boundaries[3], T)\n        \n        else: # T > 800\n            # Problem data does not cover this range, but can extrapolate if needed.\n            # As per problem, assume T = 800.\n            raise ValueError(f\"Temperature {T}K is outside the valid range [0, 800].\")\n\n    results = [calculate_entropy(T) for T in test_temperatures]\n    \n    # Format output as a list of strings with 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2680899"}]}