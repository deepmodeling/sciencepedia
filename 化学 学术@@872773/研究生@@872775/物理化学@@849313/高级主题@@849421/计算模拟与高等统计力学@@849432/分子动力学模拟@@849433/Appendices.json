{"hands_on_practices": [{"introduction": "分子动力学模拟旨在通过模拟有限数量的粒子来揭示宏观系统的性质。为了克服小尺寸带来的显著表面效应，我们采用周期性边界条件（PBC），将模拟盒子在空间中无限重复。这项实践将指导你实现周期性边界条件的核心算法——最小镜像约定（MIC），这是正确计算粒子间相互作用和确保模拟物理真实性的第一步，也是编写任何分子动力学代码的基础 [@problem_id:2458300]。", "problem": "您需要编写一个完整、可运行的程序，以演示在分子动力学 (MD) 模拟中周期性边界条件下的最小镜像约定的效果。该程序必须以两种方式计算正交周期性模拟盒子中两个粒子间的欧几里得距离：(1) 忽略周期性的朴素欧几里得距离，以及 (2) 应用最小镜像约定后的欧几里得距离。距离必须以纳米 (nm) 为单位表示，并四舍五入到恰好六位小数。\n\n背景与基本原理：在采用周期性边界条件 (PBC) 的分子动力学 (MD) 模拟中，通过对有限的模拟盒子进行无限平铺来模仿宏观体系的行为。两个粒子间的物理距离被解释为一个粒子与另一个粒子的任意周期性镜像之间的最小距离。其底层的几何规则源自欧几里得距离的定义和晶格的平移对称性。对于边长为 $L_x$、$L_y$ 和 $L_z$ 的正交盒子，最小距离是通过沿每个轴选择盒子长度的整数倍平移来获得的，这种选择使得位移矢量的欧几里得范数最小。您的程序必须实现此规则。\n\n您的任务：\n- 定义一个函数，给定两个以纳米为单位的三维位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 以及以纳米为单位的盒子边长 $(L_x,L_y,L_z)$，该函数返回两个值：\n  1) 以纳米为单位的朴素欧几里得距离 $d_{\\text{naive}} = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert$，\n  2) 以纳米为单位的最小镜像约定距离 $d_{\\text{mic}}$，该距离通过将位移分量平移 $(L_x,L_y,L_z)$ 的整数倍以使其范数最小化来获得。\n- 将盒子视为正交且轴对齐的。\n- 粒子位置可能位于主盒子区间之外。您的实现仍必须利用周期性正确计算 $d_{\\text{mic}}$。\n- 为了使您的实现清晰，请在程序中包含一个多行伪代码字符串（不打印），概述您所实现的最小镜像约定逻辑。\n\n数值和单位要求：\n- 所有距离必须以纳米 (nm) 为单位。\n- 报告的距离需四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n您的程序必须按照给定顺序为以下 $5$ 个测试用例计算 $[d_{\\text{naive}}, d_{\\text{mic}}]$。\n\n1) 正常情况，盒子内的小间距：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.5\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.5\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.7\\,\\text{nm},\\,1.2\\,\\text{nm},\\,1.6\\,\\text{nm}\\,)$\n\n2) 沿一个轴穿越周期性边界：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.1\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.9\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n\n3) 各向异性盒子及沿多轴的回绕：\n- 盒子：$(L_x,L_y,L_z) = (\\,2.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,5.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,1.9\\,\\text{nm},\\,0.2\\,\\text{nm},\\,4.8\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.1\\,\\text{nm},\\,3.9\\,\\text{nm},\\,0.3\\,\\text{nm}\\,)$\n\n4) 沿一个轴恰好为半个盒子长度的间距（临界情况）：\n- 盒子：$(L_x,L_y,L_z) = (\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n\n5) 位置在主盒子区间之外：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm}\\,)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的配对列表。每个配对对应于指定顺序的一个测试用例，并且必须采用 $[d_{\\text{naive}},d_{\\text{mic}}]$ 的形式，两个值都以纳米为单位四舍五入到恰好 $6$ 位小数。输出中不得包含空格。\n- 例如，要求的整体格式为 $[[a_1,b_1],[a_2,b_2],\\dots]$，其中每个 $a_k$ 和 $b_k$ 都是以纳米为单位且恰好有 $6$ 位小数的浮点数。", "solution": "所提出的问题是计算统计力学中的一个基础练习，具体涉及在分子动力学 (MD) 模拟中实现周期性边界条件 (PBC)。使用 PBC 是一种标准且必要的技术，通过模拟少量有限的粒子来近似宏观系统的性质。它减轻了在小系统中本会占主导地位的严重表面效应。这个问题的核心是正确计算粒子间距离，这由最小镜像约定 (MIC) 所决定。\n\n问题是良定的，有科学依据，并为唯一且可验证的解提供了所有必要的数据。我们将进行严谨的推导和实现。\n\n设正交模拟盒子由一组对应于边长的三个正交矢量定义，$\\mathbf{L} = (L_x, L_y, L_z)$。两个粒子 $i$ 和 $j$ 的位置由矢量 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 给出。\n\n首先，我们定义朴素欧几里得距离 $d_{\\text{naive}}$。这是非周期性三维欧几里得空间中的标准距离。它由位移矢量 $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$ 的范数计算得出。\n$$\nd_{\\text{naive}} = \\lVert \\Delta\\mathbf{r} \\rVert = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}\n$$\n其中 $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y, \\Delta z)$。此计算忽略了模拟盒子的周期性，并将系统视为孤立在真空中。\n\n其次，我们讨论最小镜像约定距离 $d_{\\text{mic}}$。在周期性系统中，模拟盒子在所有方向上无限复制。位于位置 $\\mathbf{r}$ 的粒子在位置 $\\mathbf{r} + n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}$ 处有一个无限的周期性镜像晶格，其中 $n_x, n_y, n_z$ 是任意整数。粒子 $i$ 和粒子 $j$ 之间的物理距离是粒子 $i$ 与粒子 $j$ 的*任何*一个周期性镜像之间的最短距离。\n\n从数学上讲，这表示为：\n$$\nd_{\\text{mic}} = \\min_{n_x, n_y, n_z \\in \\mathbb{Z}} \\left\\lVert (\\mathbf{r}_j - \\mathbf{r}_i) - (n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}) \\right\\rVert\n$$\n对于正交盒子，范数的最小化可以对每个笛卡尔分量独立进行。让我们考虑位移矢量的 $x$ 分量，$\\Delta x = x_j - x_i$。我们必须找到一个整数 $n_x$ 来最小化 $|\\Delta x - n_x L_x|$。当 $n_x$ 是最接近比率 $\\Delta x / L_x$ 的整数时，即可实现这一点。这就是“最近整数函数”，通常表示为 $\\text{nint}(s)$ 或通过 `round(s)` 实现。\n\n因此，经过MIC调整的位移分量 $\\Delta x'$ 为：\n$$\n\\Delta x' = \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right)\n$$\n这个公式正确地将位移矢量分量“回绕”到区间 $[-L_x/2, L_x/2]$ 内。同样的逻辑也适用于 $y$ 和 $z$ 分量。完整的经过MIC调整的位移矢量 $\\Delta\\mathbf{r}'$ 则是：\n$$\n\\Delta\\mathbf{r}' = \\left( \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right), \\Delta y - L_y \\cdot \\text{round}\\left(\\frac{\\Delta y}{L_y}\\right), \\Delta z - L_z \\cdot \\text{round}\\left(\\frac{\\Delta z}{L_z}\\right) \\right)\n$$\n这种矢量运算是鲁棒的，并且能正确处理粒子坐标可能位于主模拟盒子之外的情况，因为只有它们的相对位移是重要的。\n\n最小镜像距离 $d_{\\text{mic}}$ 是这个调整后位移矢量的欧几里得范数：\n$$\nd_{\\text{mic}} = \\lVert \\Delta\\mathbf{r}' \\rVert = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2}\n$$\n\n提供的测试用例将使用这种已确立的方法来解决。实现将利用 `numpy` 库进行高效的矢量算术。对于每个测试用例，我们将计算 $d_{\\text{naive}}$ 和 $d_{\\text{mic}}$，并按要求将结果四舍五入到恰好 $6$ 位小数进行报告。对于位移恰好为半个盒子长度的特殊情况，例如 $\\Delta x = L_x/2$，由 `round` 函数处理。该函数通常会四舍五入到最近的偶数整数（例如，在 `numpy` 中），但无论调整后位移的符号选择如何，最终的距离都是唯一的 $L_x/2$。对于 $\\Delta x = L_x/2$，$\\Delta x' = L_x/2 - L_x \\cdot \\text{round}(0.5) = L_x/2 - L_x \\cdot 0 = L_x/2$。其大小是明确无误的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating naive and minimum image convention (MIC)\n    distances for a set of test cases in a molecular dynamics context.\n    \"\"\"\n\n    # Per the problem specification, this multi-line string contains the\n    # pseudocode explaining the implemented MIC logic. It is not printed.\n    # noinspection PyUnusedLocal\n    MIC_PSEUDOCODE = \"\"\"\n    function calculate_minimum_image_distance(r_i, r_j, box_dims):\n        // r_i, r_j: 3D position vectors [x, y, z] of two particles in nm.\n        // box_dims: 3D vector of orthorhombic box lengths [L_x, L_y, L_z] in nm.\n\n        // 1. Calculate the raw displacement vector.\n        //    This is a simple vector subtraction.\n        delta_r = r_j - r_i\n\n        // 2. Apply the minimum image convention to each component of the displacement vector.\n        //    For an orthorhombic box, this can be done independently for each axis.\n        //    The principle is to find the closest periodic image by shifting the displacement\n        //    by an integer number of box lengths. This is mathematically equivalent to\n        //    finding the nearest integer multiple of the box length to subtract.\n        \n        //    Let dr_c be a component of delta_r (e.g., delta_x) and L_c be the\n        //    corresponding box length (e.g., L_x).\n        //    The scaled displacement is s = dr_c / L_c.\n        //    The nearest integer number of box lengths to shift by is n = round(s).\n        //    The MIC-adjusted displacement component is dr'_c = dr_c - n * L_c.\n\n        //    In vector notation, this is:\n        mic_delta_r = delta_r - box_dims * np.round(delta_r / box_dims)\n        \n        // 3. Calculate the Euclidean norm (length) of the MIC-adjusted displacement vector.\n        //    This is the final minimum image distance.\n        distance_mic = sqrt(mic_delta_r[0]^2 + mic_delta_r[1]^2 + mic_delta_r[2]^2)\n        \n        return distance_mic\n    \"\"\"\n\n    def compute_distances(r_i_tuple, r_j_tuple, box_dims_tuple):\n        \"\"\"\n        Calculates naive and MIC distances for a single pair of particles.\n        \n        Args:\n            r_i_tuple (tuple): Position of particle i.\n            r_j_tuple (tuple): Position of particle j.\n            box_dims_tuple (tuple): Orthorhombic box dimensions (Lx, Ly, Lz).\n        \n        Returns:\n            A list containing two floats: [d_naive, d_mic].\n        \"\"\"\n        r_i = np.array(r_i_tuple, dtype=float)\n        r_j = np.array(r_j_tuple, dtype=float)\n        box_dims = np.array(box_dims_tuple, dtype=float)\n\n        # 1. Naive Euclidean distance\n        delta_r_naive = r_j - r_i\n        d_naive = np.linalg.norm(delta_r_naive)\n\n        # 2. Minimum Image Convention (MIC) distance\n        # The logic delta_r - L * round(delta_r / L) correctly finds the\n        # shortest vector in a periodic lattice.\n        delta_r_mic = delta_r_naive - box_dims * np.round(delta_r_naive / box_dims)\n        d_mic = np.linalg.norm(delta_r_mic)\n        \n        return [d_naive, d_mic]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1) Happy path, small separation\n        {'r_i': (0.5, 1.0, 1.5), 'r_j': (0.7, 1.2, 1.6), 'box': (3.0, 3.0, 3.0)},\n        # 2) Crossing a periodic boundary\n        {'r_i': (0.1, 1.0, 1.0), 'r_j': (2.9, 1.0, 1.0), 'box': (3.0, 3.0, 3.0)},\n        # 3) Anisotropic box and multi-axis wrapping\n        {'r_i': (1.9, 0.2, 4.8), 'r_j': (0.1, 3.9, 0.3), 'box': (2.0, 4.0, 5.0)},\n        # 4) Exactly half-box separation\n        {'r_i': (0.0, 0.0, 0.0), 'r_j': (2.0, 0.0, 0.0), 'box': (4.0, 4.0, 4.0)},\n        # 5) Positions outside the primary box\n        {'r_i': (-0.1, -0.1, -0.1), 'r_j': (3.1, 3.1, 3.1), 'box': (3.0, 3.0, 3.0)},\n    ]\n\n    result_strings = []\n    for case in test_cases:\n        d_naive, d_mic = compute_distances(case['r_i'], case['r_j'], case['box'])\n        \n        # Format the numbers to exactly 6 decimal places and create the pair string.\n        # This ensures trailing zeros are included and meets the formatting requirement.\n        result_strings.append(f\"[{d_naive:.6f},{d_mic:.6f}]\")\n\n    # Final print statement in the exact required format: [[a1,b1],[a2,b2],...]\n    # without spaces between elements.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2458300"}, {"introduction": "在定义了模拟的几何空间后，我们需要一个算法来根据牛顿运动定律随时间演化系统。本练习将深入探讨速度 Verlet 算法的特性，它是分子动力学模拟中最常用的积分器之一。通过一个简化的谐振子模型，你将凭经验验证辛积分器能量守恒的标度律，并理解计算成本（时间步长 $Δt$）与模拟精度（能量守恒性）之间的关键权衡 [@problem_id:2651929]。", "problem": "考虑一个一维谐振子，其质量为 $m$，弹簧常数为 $k$，其演化遵循牛顿第二定律 $m\\,d^2x/dt^2 = -\\,dV/dx$，势能为 $V(x) = \\tfrac{1}{2}k x^2$。分子动力学（MD）中常用的一种二阶辛、时间可逆积分器是速度Verlet方案。从哈密顿力学的角度来看，辛积分器保持相空间体积不变，并精确守恒一个修正哈密顿量。该修正哈密顿量与真实哈密顿量之差为时间步长 $\\Delta t$ 的高阶项。从这些基本原理（牛顿定律、哈密頓结构以及辛和时间可逆积分的定义）出发，推导速度Verlet积分器的全局能量误差作为 $\\Delta t$ 函数的主阶标度关系。\n\n具体来说，将在时长为 $T$ 的模拟中，绝对能量偏差 $A(\\Delta t)$ 定义为\n$$\nA(\\Delta t) = \\max_{0 \\le t \\le T}\\,\\big|E(t) - E(0)\\big| \\quad \\text{with} \\quad E(t) = \\tfrac{1}{2}m v(t)^2 + \\tfrac{1}{2}k x(t)^2,\n$$\n并量化对于二阶辛速度Verlet方法，当 $\\Delta t \\to 0$ 时，$A(\\Delta t)$ 如何随 $\\Delta t$ 变化。\n\n然后，设计一个经验性方案，用于在微正则系综（粒子数 $N$、体积 $V$ 和能量 $E$ 恒定；常称为 $NVE$）的生产级分子动力学（MD）模拟中测量能量漂移，并将此方案转化为针对谐振子的计算实验。具体要求如下：\n- 针对参数为 $m$、$k$、初始位置为 $x(0)$、初始速度为 $v(0)$ 的谐振子，实现速度Verlet积分器。\n- 对于一组时间步长 $\\{\\Delta t_i\\}$，运行积分器直至总时间 $T$，并记录每个离散时间 $t_n = n \\Delta t_i$ 的总能量 $E(t_n)$。对于每个 $\\Delta t_i$：\n  1. 计算绝对能量偏差 $A(\\Delta t_i) = \\max_n |E(t_n) - E(0)|$，单位为焦耳。\n  2. 估算单位时间的经验线性能量漂移 $D(\\Delta t_i)$（单位为焦耳/秒），其值为模拟过程中 $E(t)$ 相对于 $t$ 的最小二乘斜率，即在普通最小二乘意义下，对点集 $(t_n, E(t_n))$ 的最佳拟合直线的斜率。\n  3. 通过监测积分在 $[0,T]$ 区间内是否保持数值稳定，来确定一个布尔稳定性标志。如果在任何采样点，总能量变为非有限值或增长超过 $E(0)$ 的预设倍数，则声明轨迹不稳定；否则声明其稳定。\n- 仅使用稳定轨迹，通过对 $\\log A$ 与 $\\log \\Delta t$ 进行线性回归来拟合幂律 $A(\\Delta t) \\propto \\Delta t^{p}$，以估算标度指数 $p$。\n\n您的程序必须使用以下物理参数和测试组，并以指定单位报告所要求的量：\n- 物理参数：\n  - 质量 $m = 1.66053906660 \\times 10^{-27}\\ \\text{kg}$。\n  - 弹簧常数 $k = 1.0\\ \\text{N}\\,\\text{m}^{-1}$。\n  - 初始条件 $x(0) = 1.0 \\times 10^{-9}\\ \\text{m}$ 和 $v(0) = 0.0\\ \\text{m}\\,\\text{s}^{-1}$。\n- 总模拟时间：$T = 2.0 \\times 10^{-11}\\ \\text{s}$。\n- 时间步长测试组：\n  - $\\Delta t_1 = 1.0 \\times 10^{-15}\\ \\text{s}$ (正常路径)。\n  - $\\Delta t_2 = 2.0 \\times 10^{-15}\\ \\text{s}$ (正常路径)。\n  - $\\Delta t_3 = 4.0 \\times 10^{-15}\\ \\text{s}$ (较大但预期稳定)。\n  - $\\Delta t_4 = 3.0 \\times 10^{-14}\\ \\text{s}$ (超出谐振子的线性稳定性极限，即预期不稳定的边界情况)。\n- 稳定性检测规则：如果在任何时刻，总能量为非有限值或满足 $|E(t) - E(0)|/E(0) > 10^{6}$，则声明轨迹不稳定并停止该 $\\Delta t$ 的运行。\n\n单位与数值报告要求：\n- 以焦耳为单位报告 $A(\\Delta t_i)$。\n- 以焦耳/秒为单位报告 $D(\\Delta t_i)$。\n- 指数 $p$ 是无量纲的。\n- 本问题不使用角度。\n- 所有浮点数应以编程语言默认转换产生的标准十进制或科学记数法输出，输出中不应嵌入单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表。此列表必须为测试组中的每个时间步长包含一个条目，最后以指数 $p$作为最后一个条目。每个时间步长条目必须是 $[\\text{stable}, A(\\Delta t_i), D(\\Delta t_i)]$ 的形式，其中 $\\text{stable}$ 是一个布尔值。因此，输出应类似于\n$[[\\text{stable}_1, A_1, D_1],[\\text{stable}_2, A_2, D_2],[\\text{stable}_3, A_3, D_3],[\\text{stable}_4, A_4, D_4],p]$\n逗号后无空格，并用单对方括号括起来。\n\n覆盖性设计：\n- 所选的 $\\Delta t_1$ 和 $\\Delta t_2$ 代表了用于评估标度关系的典型稳定情况。\n- 所选的 $\\Delta t_3$ 探测了更大但仍稳定的步长。\n- 所选的 $\\Delta t_4$ 超出了线性稳定性极限 $\\Delta t  2/\\omega$（其中 $\\omega = \\sqrt{k/m}$），旨在触发不稳定性检测器。\n\n最终的数值输出应理解为使用上述指定单位，但不包含在打印行中。您的推导必须从所述的基本原理出发，且不得预先假设目标标度关系。", "solution": "所述问题定义明确，植根于经典力学和数值分析的基本原理。它在科学上是合理的，并为获得唯一解提供了所有必要信息。我们着手解决此问题，过程包括理论推导和计算程序。\n\n**能量误差标度关系的理论推导**\n\n所考虑的系统是一个一维谐振子，由哈密顿量 $H(x, p) = \\frac{p^2}{2m} + \\frac{1}{2}kx^2$ 控制，其中 $p=mv$ 是动量。运动方程为 $m\\ddot{x} = -kx$。动力学将使用速度Verlet算法进行积分，这是一种二階对称辛积分器。\n\n从时间 $t$ 到 $t+\\Delta t$ 的一个时间步长 $\\Delta t$ 的更新方案由下式给出：\n$$x(t + \\Delta t) = x(t) + v(t)\\Delta t + \\frac{1}{2}a(t)(\\Delta t)^2$$\n$$v(t + \\Delta t) = v(t) + \\frac{1}{2}\\left[ a(t) + a(t+\\Delta t) \\right]\\Delta t$$\n其中 $a(t) = F(x(t))/m = -kx(t)/m$。\n\n辛积分器的一个基本性质是它不守恒系统的真实哈密顿量 $H$。相反，该算法生成的点序列 $(x_n, v_n)$ 位于一个修正（或称“影子”）哈密顿量 $\\tilde{H}$ 的不变流形上。对于一个 $2r$ 阶的对称积分器（对于速度Verlet，阶数为 $2$，因此 $r=1$），这个影子哈密顿量可以表示为时间步长 $\\Delta t$ 的偶次幂的渐近级数：\n$$\\tilde{H}(x, v; \\Delta t) = H(x, v) + (\\Delta t)^2 H_2(x, v) + (\\Delta t)^4 H_4(x, v) + \\mathcal{O}((\\Delta t)^6)$$\n函数 $H_j(x, v)$ 由原始哈密顿量和积分器的具体形式确定。\n\n在时间 $t_n = n\\Delta t$ 上的数值轨迹 $(x_n, v_n)$ 精确守恒这个影子哈密顿量（在机器精度范围内）：\n$$\\tilde{H}(x_n, v_n; \\Delta t) = \\text{constant} = \\tilde{E}_0$$\n这个守恒量 $\\tilde{E}_0$ 的值由初始条件 $(x_0, v_0)$ 固定：\n$$\\tilde{E}_0 = \\tilde{H}(x_0, v_0; \\Delta t) = H(x_0, v_0) + (\\Delta t)^2 H_2(x_0, v_0) + \\mathcal{O}((\\Delta t)^4)$$\n令 $E_0 = H(x_0, v_0)$ 为真实初始能量。则 $\\tilde{E}_0 \\approx E_0 + (\\Delta t)^2 H_2(x_0, v_0)$。\n\n模拟期间测量的能量是*真实*哈密顿量 $E_n = H(x_n, v_n)$ 在数值轨迹上每个点的值。通过重新排列 $\\tilde{H}$ 的级数，我们可以将 $E_n$ 表示为：\n$$E_n = H(x_n, v_n) = \\tilde{H}(x_n, v_n; \\Delta t) - (\\Delta t)^2 H_2(x_n, v_n) - \\mathcal{O}((\\Delta t)^4)$$\n由于对所有 $n$ 都有 $\\tilde{H}(x_n, v_n; \\Delta t) = \\tilde{E}_0$，我们得到：\n$$E_n \\approx \\tilde{E}_0 - (\\Delta t)^2 H_2(x_n, v_n)$$\n我们关心的是相对于初始能量的能量偏差 $E_n - E_0$。代入 $\\tilde{E}_0$ 的表达式：\n$$E_n - E_0 \\approx \\left( E_0 + (\\Delta t)^2 H_2(x_0, v_0) \\right) - (\\Delta t)^2 H_2(x_n, v_n) - E_0$$\n$$E_n - E_0 \\approx (\\Delta t)^2 \\left( H_2(x_0, v_0) - H_2(x_n, v_n) \\right)$$\n对于像谐振子这样的束缚系统，轨迹 $(x_n, v_n)$ 在相空间中是周期性或准周期性的。随着系统的演化，函数 $H_2(x_n, v_n)$ 的值会发生变化。这导致计算出的能量 $E_n$ 在一个平均值附近振荡，而不是保持恒定或系统性漂移。这些能量振荡的振幅与主阶项 $(\\Delta t)^2$ 成正比。\n\n我们关注的量是最大绝对能量偏差 $A(\\Delta t) = \\max_n |E_n - E_0|$。基于以上分析，此偏差的大小由 $(\\Delta t)^2$ 项在整个轨迹上的最大变化决定。因此，我们推导出标度律：\n$$A(\\Delta t) \\propto (\\Delta t)^2$$\n这预测了关系式 $A(\\Delta t) \\propto (\\Delta t)^p$ 中的标度指数 $p$ 等于 $2$。线性能量漂移 $D(\\Delta t)$ 预期可以忽略不计，它源于有限精度算术而非算法本身，因为对于有界运动，辛积分器不会表现出系统性能量漂移。\n\n**计算方案**\n\n理论结果将通过指定的直接数值模拟进行经验性检验。程序如下：\n1.  **积分器实现**：为力 $F(x) = -kx$ 的一维谐振子实现速度Verlet算法。\n2.  **模拟循环**：对于所提供测试组中的每个时间步长 $\\Delta t_i$，执行从 $t=0$ 到 $t=T$ 的模拟。状态 $(x(t), v(t))$ 初始化为 $(x(0), v(0))$。\n3.  **数据收集与稳定性检查**：在每一步 $n$，计算并存储总能量 $E(t_n) = \\frac{1}{2}m v(t_n)^2 + \\frac{1}{2}k x(t_n)^2$。执行稳定性检查：如果 $|E(t_n) - E(0)|/E(0) > 10^6$ 或 $E(t_n)$ 变为非有限值，则将该轨迹标记为不稳定，并终止该 $\\Delta t_i$ 的模拟。\n4.  **度量计算**：在完成（或终止）给定 $\\Delta t_i$ 的一次运行时：\n    *   在生成的轨迹上计算绝对能量偏差 $A(\\Delta t_i) = \\max_n |E(t_n) - E(0)|$。\n    *   通过对能量数据 $\\{E(t_n)\\}$ 与时间数据 $\\{t_n\\}$ 进行普通最小二乘线性回归，来估算单位时间的线性能量漂移 $D(\\Delta t_i)$。$D(\\Delta t_i)$ 是最佳拟合线的斜率。\n5.  **标度指数估算**：使用所有*稳定*轨迹的数据，确定标度指数 $p$。这是通过拟合幂律 $A(\\Delta t) = C(\\Delta t)^p$ 实现的。对等式两边取对数得到 $\\log A = p \\log \\Delta t + \\log C$。对 $\\log A$ 与 $\\log \\Delta t$ 进行线性回归，所得斜率即为 $p$ 的经验估计值。\n\n该计算实验旨在验证 $p=2$ 的理论预测，量化能量涨落，并测试该系统积分器的稳定性极限。最终输出将是一个执行此方案并按指定格式报告结果的程序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Solves the problem of analyzing the velocity Verlet integrator for a 1D harmonic oscillator.\n    \n    This function performs the following steps:\n    1. Sets up the physical parameters and simulation settings for a harmonic oscillator.\n    2. Iterates through a test suite of time steps (dt).\n    3. For each dt, runs a molecular dynamics simulation using the velocity Verlet algorithm.\n    4. Monitors the simulation for numerical stability based on energy conservation.\n    5. Calculates the maximum absolute energy deviation (A) and the linear energy drift (D).\n    6. For stable runs, performs a power-law fit to find the scaling exponent (p) of A versus dt.\n    7. Formats and prints the results as specified in the problem statement.\n    \"\"\"\n    \n    # Physical parameters and initial conditions\n    m = 1.66053906660e-27  # Mass in kg\n    k = 1.0                # Spring constant in N/m\n    x0 = 1.0e-9            # Initial position in m\n    v0 = 0.0               # Initial velocity in m/s\n    \n    # Simulation parameters\n    T_total = 2.0e-11      # Total simulation time in s\n    dts = [1.0e-15, 2.0e-15, 4.0e-15, 3.0e-14] # Time step test suite in s\n    \n    # Stability detection rule\n    STABILITY_REL_ENERGY_THRESHOLD = 1e6\n\n    # Initial energy, E(0)\n    E0 = 0.5 * k * x0**2 + 0.5 * m * v0**2\n\n    final_results = []\n    stable_run_data = []\n\n    for dt in dts:\n        # --- Simulation for a single time step dt ---\n        # Initialization\n        x, v = x0, v0\n        t = 0.0\n        \n        times = [t]\n        energies = [E0]\n        \n        stable = True\n        \n        # Initial acceleration a(t=0)\n        a = -k * x / m\n        \n        # Run the integrator up to total time T\n        num_steps = int(np.ceil(T_total / dt))\n        for _ in range(num_steps):\n            # Velocity Verlet Algorithm\n            # 1. Update position x(t + dt)\n            x_new = x + v * dt + 0.5 * a * dt**2\n            \n            # 2. Calculate new acceleration a(t + dt)\n            a_new = -k * x_new / m\n            \n            # 3. Update velocity v(t + dt)\n            v_new = v + 0.5 * (a + a_new) * dt\n            \n            # Update state for the next iteration\n            x, v, a = x_new, v_new, a_new\n            t += dt\n            \n            # Calculate and store current energy E(t)\n            current_E = 0.5 * k * x**2 + 0.5 * m * v**2\n            \n            # Append results for this step\n            times.append(t)\n            energies.append(current_E)\n\n            # Check for numerical instability and terminate run if needed\n            is_finite = np.isfinite(current_E)\n            rel_error_exceeded = (E0 > 0 and abs(current_E - E0) / E0 > STABILITY_REL_ENERGY_THRESHOLD)\n            \n            if not is_finite or rel_error_exceeded:\n                stable = False\n                break\n    \n        # --- Post-processing for this dt ---\n        times_arr = np.array(times)\n        energies_arr = np.array(energies)\n        \n        # Filter out non-finite values that could result from instability\n        finite_indices = np.isfinite(energies_arr)\n        valid_times = times_arr[finite_indices]\n        valid_energies = energies_arr[finite_indices]\n\n        # 1. Compute absolute energy deviation A(dt)\n        if valid_energies.size > 0:\n            A_dt = np.max(np.abs(valid_energies - E0))\n        else:\n            A_dt = np.inf\n\n        # 2. Estimate linear energy drift D(dt) via least-squares\n        if valid_times.size > 1:\n            # linregress returns: slope, intercept, r-value, p-value, stderr\n            D_dt, _, _, _, _ = linregress(valid_times, valid_energies)\n        else:\n            D_dt = 0.0\n        \n        # Store results for this dt\n        final_results.append([stable, A_dt, D_dt])\n        \n        if stable:\n            stable_run_data.append({'dt': dt, 'A': A_dt})\n\n    # --- Final analysis across stable runs ---\n    # Fit power law A(dt) ~ dt^p by linear regression of log(A) on log(dt)\n    if len(stable_run_data) > 1:\n        log_dts = np.log([d['dt'] for d in stable_run_data])\n        log_As = np.log([d['A'] for d in stable_run_data])\n        # The slope of the log-log plot is the scaling exponent p\n        p, _, _, _, _ = linregress(log_dts, log_As)\n    else:\n        # This case should not be reached with the given problem parameters\n        p = np.nan\n\n    # --- Format final output string ---\n    output_parts = []\n    for result_item in final_results:\n        stable_str = str(result_item[0]).lower()\n        A_val = result_item[1]\n        D_val = result_item[2]\n        output_parts.append(f'[{stable_str},{A_val},{D_val}]')\n    \n    output_parts.append(str(p))\n    \n    # Print the single-line output in the exact required format\n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```", "id": "2651929"}, {"introduction": "成功运行模拟只是第一步，验证其是否产生了正确的物理系综是保证结果可靠性的关键。这项高级实践将介绍一种严谨的统计方法，用于检验恒温模拟是否确实对正则系综进行了正确采样。你将通过分析动能的分布，并应用基于参数自助法校准的拟合优度检验，学习如何批判性地评估模拟输出的统计力学有效性 [@problem_id:2652001]。", "problem": "你的任务是设计并实现一个严格的、程序化的统计检验，以验证一个分子动力学（MD）恒温器是否为一个具有已知二次自由度数量的系统生成了正则动能分布。在温度对应于逆热能 $\\beta$ 的正则系综中，一个具有 $f$ 个独立二次自由度的系统的瞬时标量动能 $K \\ge 0$ 预计遵循以下分布：\n$$\nP(K) \\propto K^{\\frac{f}{2} - 1} e^{-\\beta K}.\n$$\n这是 Gamma 分布族，其形状参数为 $k = \\frac{f}{2}$，尺度参数为 $\\theta = \\frac{1}{\\beta}$。\n\n从以下基本事实出发：\n- 玻尔兹曼分布意味着，在正则系综中，对于哈密顿量 $H$，概率密度与 $\\exp(-\\beta H)$ 成正比。\n- 对于一个具有 $f$ 个独立二次速度模式的系统，动能是 $f$ 个二次项的总和，这导致 $K$ 的分布为 Gamma 分布，形状参数为 $k = \\frac{f}{2}$。\n- 概率积分变换指出，如果 $X$ 具有连续的累积分布函数 $F$，那么 $U = F(X)$ 在 $[0,1]$ 上是均匀分布的。\n\n你的任务是提出、论证并实现一个假设检验，该检验具有以下原假设和操作约束：\n- 原假设 $H_0$：动能样本 $\\{K_i\\}_{i=1}^n$ 是独立同分布的，遵循具有已知 $f$（因此形状参数 $k = \\frac{f}{2}$ 也已知）和未知 $\\beta  0$（将从样本中估计）的正则预测。\n- 检验设计约束：\n  1. 你必须在 $H_0$ 下，仅使用基于固定 $k$ 的最大似然法证明合理的量，从数据中估计 $\\beta$。\n  2. 你必须使用拟合模型的累积分布函数来转换样本，以获得在 $H_0$ 下应为在 $[0,1]$ 上独立同分布的均匀分布值。\n  3. 你必须计算一个在整个支撑集上都敏感的无分布拟合优度统计量，并即使在 $\\beta$ 是估计的情况下，也要在 $H_0$ 下校准其抽样分布。解析校准不能假设参数已知；你必须使用从第一性原理出发并与 $H_0$ 一致的有原则的重抽样方法。\n\n实现要求：\n- 编写一个完整且可运行的程序，构建以下合成测试数据集（无量纲能量；不需要物理单位），对每个数据集应用你的检验，并输出一行，其中包含一个布尔值决策列表，指示在显著性水平 $\\alpha = 0.05$ 下，是否接受每个测试用例的 $H_0$。使用以下确定性数据集构建规则：\n  - 对于任何“纯 Gamma”数据集，使用逆累积分布函数，通过在等间距分位数 $u_i = \\frac{i - \\frac{1}{2}}{n}$（对于 $i = 1,\\dots,n$）上取值 $K_i = F^{-1}_{\\Gamma}(u_i; k, \\theta)$（其中 $k = \\frac{f}{2}$ 和 $\\theta = \\frac{1}{\\beta_{\\text{true}}}$），来构建一个大小为 $n$ 的确定性分布样本。\n  - 对于任何“混合”数据集，一半样本来自具有 $(k, \\theta_1)$ 的 Gamma 分布的逆累积分布函数分位数，另一半来自 $(k, \\theta_2)$，每一半都使用等间距分位数。\n- 你的检验必须实现：\n  - 对于固定的 $k = \\frac{f}{2}$，从样本均值 $\\overline{K}$ 获得的 $\\beta$ 的最大似然估计量。\n  - 一个概率积分变换 $u_i = F_{\\Gamma}(K_i; k, \\hat{\\theta})$，其中 $\\hat{\\theta} = \\frac{1}{\\hat{\\beta}}$。\n  - 一个从 $\\{u_i\\}$ 计算的单样本柯尔莫哥洛夫–斯米尔诺夫统计量，通过参数化自举进行校准，其中有 $B$ 个在拟合参数 $\\hat{\\beta}$ 下根据 $H_0$ 生成的合成数据集，每个自举数据集都重新估计 $\\hat{\\beta}^{(b)}$ 并重新计算统计量。使用无偏有限样本 p 值约定 $p = \\frac{1 + \\#\\{D^{(b)} \\ge D_{\\text{obs}}\\}}{B + 1}$。自举是校准所必需的，以解释从数据中估计的参数。\n- 显著性水平：$\\alpha = 0.05$（无量纲）。\n- 不涉及角度单位。\n- 最终输出格式：你的程序应生成单行输出，其中包含测试套件的决策，格式为逗号分隔的 Python 布尔值列表，例如，“[True,False,True]”。\n\n在你的程序中实现的测试套件：\n- 案例 1（正常路径，中等 $f$）：$f = 12$，$\\beta_{\\text{true}} = 0.8$，$n = 2500$，纯 Gamma 分布，使用假设的 $f = 12$ 进行测试。\n- 案例 2（正常路径，指数分布特例）：$f = 2$，$\\beta_{\\text{true}} = 1.5$，$n = 1000$，纯 Gamma 分布，使用假设的 $f = 2$ 进行测试。\n- 案例 3（结构化模型违规；温度不均匀）：$f = 12$，$n = 2500$，权重相等的 $\\beta_1 = 0.8$ 和 $\\beta_2 = 1.2$ 的混合分布，使用假设的 $f = 12$ 进行测试。\n- 案例 4（结构化模型违规；有效自由度不正确）：真实生成器 $f_{\\text{true}} = 16$ 且 $\\beta_{\\text{true}} = 1.0$，$n = 3000$，但使用假设的 $f = 12$ 进行测试。\n- 案例 5（边界条件；小样本，纯 Gamma）：$f = 12$，$\\beta_{\\text{true}} = 0.8$，$n = 80$，纯 Gamma 分布，使用假设的 $f = 12$ 进行测试。\n\n所有能量都是无量纲的。你的程序必须完全按照规定在内部构建这些数据集，使用 $B = 500$ 次重复的参数化自举执行检验，并使用固定的随机种子以确保确定性输出，然后打印一行包含案例 1 到 5 顺序的布尔值决策列表。", "solution": "该任务是设计并实现一个统计检验，以验证来自某个分子动力学模拟的动能样本是否遵循理论上预测的正则分布。这个问题设定良好且科学上合理，它基于统计力学和统计推断的基本原理。我们将提供一个完整、合理的解决方案。\n\n问题的核心是针对 Gamma 分布的拟合优度检验，其中形状参数已知，但尺度参数未知，必须从数据中估计。\n\n**1. 原假设与动能分布**\n\n原假设 $H_0$ 指出，动能样本 $\\{K_i\\}_{i=1}^n$ 是独立同分布（i.i.d.）的，遵循为正则系综中的系统所预测的分布。对于一个具有 $f$ 个独立二次自由度的系统，动能 $K$ 遵循 Gamma 分布。Gamma 分布的概率密度函数（PDF）由下式给出：\n$$\nP(K; k, \\theta) = \\frac{1}{\\Gamma(k)\\theta^k} K^{k-1} e^{-K/\\theta}\n$$\n其中 $k$ 是形状参数，$\\theta$ 是尺度参数。在我们的物理情境中，形状参数由自由度决定，$k = f/2$，尺度参数通过 $\\theta = 1/\\beta$ 与逆温度 $\\beta = (k_B T)^{-1}$ 相关。由于问题陈述使用 $\\beta$ 作为感兴趣的参数，我们可以将 PDF 写成：\n$$\nP(K; k, \\beta) = \\frac{\\beta^k}{\\Gamma(k)} K^{k-1} e^{-\\beta K}\n$$\n在 $H_0$ 下，形状参数 $k$ 是已知的（因为 $f$ 已给定），但 $\\beta$ 是未知的。\n\n**2. 尺度参数 $\\beta$ 的最大似然估计**\n\n为了执行检验，我们必须首先从观测数据 $\\{K_i\\}_{i=1}^n$ 中估计未知参数 $\\beta$。题目指定了使用最大似然估计（MLE）方法。似然函数是观测到数据的联合概率，对于一个 i.i.d. 样本，它是单个概率的乘积：\n$$\n\\mathcal{L}(\\beta | \\{K_i\\}, k) = \\prod_{i=1}^n P(K_i; k, \\beta) = \\prod_{i=1}^n \\frac{\\beta^k}{\\Gamma(k)} K_i^{k-1} e^{-\\beta K_i} \n$$\n处理对数似然函数 $\\ln \\mathcal{L}$ 更为方便：\n$$\n\\ln \\mathcal{L}(\\beta) = \\sum_{i=1}^n \\left( k \\ln \\beta - \\ln \\Gamma(k) + (k-1) \\ln K_i - \\beta K_i \\right)\n$$\n$$\n\\ln \\mathcal{L}(\\beta) = n k \\ln \\beta - n \\ln \\Gamma(k) + (k-1) \\sum_{i=1}^n \\ln K_i - \\beta \\sum_{i=1}^n K_i\n$$\n为了找到使该函数最大化的 $\\beta$ 值，我们对其关于 $\\beta$ 求导并令其为零：\n$$\n\\frac{d \\ln \\mathcal{L}}{d \\beta} = \\frac{n k}{\\beta} - \\sum_{i=1}^n K_i = 0\n$$\n解出 $\\beta$ 得到 MLE，记为 $\\hat{\\beta}$：\n$$\n\\frac{n k}{\\hat{\\beta}} = \\sum_{i=1}^n K_i \\implies \\hat{\\beta} = \\frac{n k}{\\sum_{i=1}^n K_i} = \\frac{k}{\\overline{K}}\n$$\n其中 $\\overline{K} = \\frac{1}{n} \\sum_{i=1}^n K_i$ 是样本平均动能。对应的尺度参数 $\\theta$ 的 MLE 是 $\\hat{\\theta} = 1/\\hat{\\beta} = \\overline{K}/k$。这确认了所需的估计步骤。\n\n**3. 拟合优度检验**\n\n有了估计参数 $\\hat{\\beta}$，我们现在可以进行拟合优度检验。\n\n**步骤 3a: 概率积分变换 (PIT)**\nPIT 指出，对于一个具有累积分布函数（CDF）$F_X(x)$ 的连续随机变量 $X$，随机变量 $U = F_X(X)$ 在 $[0, 1]$ 上均匀分布。我们将此原理应用于我们的数据。假设 $H_0$ 为真且我们的估计参数 $\\hat{\\beta}$ 接近真实值，那么变换后的值\n$$\nu_i = F_{\\Gamma}(K_i; k, \\hat{\\beta}) = \\int_0^{K_i} P(x; k, \\hat{\\beta}) dx\n$$\n应构成一个近似于从 Uniform($0,1$) 分布中抽取的 i.i.d. 样本。与均匀性的显著偏离构成了反对 $H_0$ 的证据。\n\n**步骤 3b: 柯尔莫哥洛夫–斯米尔诺夫 (KS) 统计量**\n为了量化与均匀性的偏离，我们使用单样本柯尔莫哥洛夫–斯米尔诺夫（KS）统计量。我们首先计算变换后样本 $\\{u_i\\}_{i=1}^n$ 的经验分布函数（EDF）。设 $u_{(i)}$ 为排序后的值。EDF 为：\n$$\nE_n(u) = \\frac{1}{n} \\sum_{i=1}^n \\mathbb{I}(u_i \\le u)\n$$\nKS 统计量 $D_n$ 是 EDF 与目标分布的 CDF 之间的最大绝对差值，在此情况下，目标分布是标准均匀分布，其 CDF 为 $F_U(u) = u$（对于 $u \\in [0,1]$）：\n$$\nD_{obs} = \\sup_{u \\in [0,1]} |E_n(u) - u|\n$$\n计算上，这由下式给出：\n$$\nD_{obs} = \\max_{i=1, \\dots, n} \\left\\{ \\max\\left( \\frac{i}{n} - u_{(i)}, u_{(i)} - \\frac{i-1}{n} \\right) \\right\\}\n$$\n\n**4. 使用参数化自举进行校准**\n\n一个关键点是，KS 统计量的标准临界值在这里不适用。标准的 KS 检验假设所假设分布的参数是预先指定且*不是*从数据中估计的。通过使用从数据中估计的 $\\hat{\\beta}$，我们将原假设的分布与特定样本联系起来，这通常导致 $D_{obs}$ 比使用真实 $\\beta$ 时预期的要小。这使得标准检验变得保守（更不容易拒绝原假设）。\n\n为了获得正确的 p 值，我们必须确定在 $H_0$ 下，*给定参数是从数据中估计的*情况下，$D_n$ 的抽样分布。这可以通过参数化自举来实现，它模拟了在原假设下数据生成和检验的整个过程。\n\n该过程如下：\n1.  从原始数据 $\\{K_i\\}$ 计算 $\\overline{K}$ 和 MLE $\\hat{\\beta} = k/\\overline{K}$。\n2.  如上所述计算观测到的检验统计量 $D_{obs}$。\n3.  生成 $B$ 个自举样本。对于每个重复 $b=1, \\dots, B$：\n    a.  通过从拟合的 Gamma 分布 $\\text{Gamma}(k, 1/\\hat{\\beta})$ 中抽取 $n$ 个随机变量，生成一个合成数据集 $\\{K_i^{*(b)}\\}_{i=1}^n$。\n    b.  对于这个合成数据集，计算其自身的参数 MLE：$\\hat{\\beta}^{*(b)} = k/\\overline{K}^{*(b)}$。\n    c.  使用其自身估计的参数，对合成数据应用 PIT：$u_i^{*(b)} = F_{\\Gamma}(K_i^{*(b)}; k, 1/\\hat{\\beta}^{*(b)})$。\n    d.  计算此重复的 KS 统计量 $D^{(b)}$。\n4.  集合 $\\{D^{(b)}\\}_{b=1}^B$ 作为我们检验统计量零分布的经验近似。\n\n**5. 决策规则**\n\np 值是在假设 $H_0$ 为真的情况下，观测到与 $D_{obs}$ 一样极端或更极端的检验统计量的概率。使用自举分布，我们按如下方式计算 p 值：\n$$\np = \\frac{1 + N_{\\text{extreme}}}{B+1}\n$$\n其中 $N_{\\text{extreme}} = \\#\\{D^{(b)} \\ge D_{obs}\\}$ 是达到或超过观测值的自举统计量的数量。在分子和分母上加 1 是一个标准约定，以避免 p 值为 0，并确保 p 值在原假设下得到正确校准。\n\n最后，我们将 p 值与预先指定的显著性水平 $\\alpha = 0.05$ 进行比较。\n- 如果 $p  \\alpha$，我们拒绝原假设 $H_0$。这表明数据并非来自指定的 Gamma 分布族。对应的输出是 `False`。\n- 如果 $p \\ge \\alpha$，我们未能拒绝 $H_0$。这意味着数据与原假设一致。对应的输出是 `True`。\n\n这个完整的程序为检验模拟中动能分布的有效性提供了一个严格、有原则的检验，并正确地考虑了参数估计。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import gamma, kstest\n\ndef solve():\n    \"\"\"\n    Implements and applies a statistical test to verify the canonical kinetic energy distribution\n    from a Molecular Dynamics simulation, as specified in the problem statement.\n    \"\"\"\n    # Set a fixed random seed for reproducibility of the bootstrap procedure\n    np.random.seed(42)\n\n    # Parameters for the test\n    B = 500  # Number of bootstrap replicates\n    alpha = 0.05  # Significance level\n\n    # Define the test suite\n    test_cases = [\n        # Case 1: happy path, moderate f\n        {'type': 'pure', 'f_true': 12, 'beta_true': 0.8, 'n': 2500, 'f_test': 12},\n        # Case 2: happy path, exponential special case\n        {'type': 'pure', 'f_true': 2, 'beta_true': 1.5, 'n': 1000, 'f_test': 2},\n        # Case 3: structured model violation; temperature inhomogeneity\n        {'type': 'mixture', 'f_true': 12, 'beta1': 0.8, 'beta2': 1.2, 'n': 2500, 'f_test': 12},\n        # Case 4: structured model violation; incorrect effective degrees of freedom\n        {'type': 'pure', 'f_true': 16, 'beta_true': 1.0, 'n': 3000, 'f_test': 12},\n        # Case 5: boundary condition; small sample, pure Gamma\n        {'type': 'pure', 'f_true': 12, 'beta_true': 0.8, 'n': 80, 'f_test': 12},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # --- 1. Generate Synthetic Dataset as per problem specification ---\n        n = case['n']\n        f_test = case['f_test']\n        k_test = f_test / 2.0\n\n        if case['type'] == 'pure':\n            f_true = case['f_true']\n            k_true = f_true / 2.0\n            beta_true = case['beta_true']\n            theta_true = 1.0 / beta_true\n            quantiles = (np.arange(1, n + 1) - 0.5) / n\n            K_data = gamma.ppf(quantiles, a=k_true, scale=theta_true)\n        elif case['type'] == 'mixture':\n            f_true = case['f_true']\n            k_true = f_true / 2.0\n            beta1, beta2 = case['beta1'], case['beta2']\n            theta1, theta2 = 1.0 / beta1, 1.0 / beta2\n            \n            n1 = n // 2\n            n2 = n - n1\n            \n            quantiles1 = (np.arange(1, n1 + 1) - 0.5) / n1\n            K1 = gamma.ppf(quantiles1, a=k_true, scale=theta1)\n            \n            quantiles2 = (np.arange(1, n2 + 1) - 0.5) / n2\n            K2 = gamma.ppf(quantiles2, a=k_true, scale=theta2)\n            \n            K_data = np.concatenate([K1, K2])\n\n        # --- 2. Perform Hypothesis Test ---\n        # Estimate parameters from data (MLE for Gamma with known shape)\n        K_bar_obs = np.mean(K_data)\n        # Handle case of zero mean, though unlikely with this data generation\n        if K_bar_obs == 0:\n            # Cannot proceed, but this case won't occur in practice here.\n            # We can treat this as a failure to reject.\n            results.append(True) \n            continue\n            \n        beta_hat_obs = k_test / K_bar_obs\n        theta_hat_obs = 1.0 / beta_hat_obs\n\n        # Apply Probability Integral Transform (PIT)\n        u_obs = gamma.cdf(K_data, a=k_test, scale=theta_hat_obs)\n        \n        # Compute the observed Kolmogorov-Smirnov statistic\n        D_obs = kstest(u_obs, 'uniform').statistic\n\n        # --- 3. Parametric Bootstrap Calibration ---\n        D_bootstrap = np.zeros(B)\n        for i in range(B):\n            # a. Generate bootstrap sample from the fitted null model\n            K_star = gamma.rvs(a=k_test, scale=theta_hat_obs, size=n)\n            \n            # b. Re-estimate beta for the bootstrap sample\n            K_bar_star = np.mean(K_star)\n            if K_bar_star == 0: # Extremely unlikely\n                beta_hat_star = np.inf\n                theta_hat_star = 0\n            else:\n                beta_hat_star = k_test / K_bar_star\n                theta_hat_star = 1.0 / beta_hat_star\n            \n            # c. Apply PIT to the bootstrap sample with its own re-estimated parameter\n            u_star = gamma.cdf(K_star, a=k_test, scale=theta_hat_star)\n            \n            # d. Compute and store the KS statistic for the bootstrap replicate\n            D_bootstrap[i] = kstest(u_star, 'uniform').statistic\n            \n        # --- 4. Calculate p-value and make a decision ---\n        num_extreme = np.sum(D_bootstrap >= D_obs)\n        p_value = (1.0 + num_extreme) / (B + 1.0)\n        \n        decision = (p_value >= alpha)\n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2652001"}]}