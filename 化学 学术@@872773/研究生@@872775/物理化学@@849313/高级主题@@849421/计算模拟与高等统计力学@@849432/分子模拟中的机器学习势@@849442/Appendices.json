{"hands_on_practices": [{"introduction": "训练机器学习势的一个核心方法是“力匹配”，即模型学习再现来自高精度模拟的力。这个练习提供了该过程的动手经验，展示了如何通过对从含噪声数据中学习到的力场进行积分，来构建一个保守的势能面。这是许多现代势函数开发工作流程的基石 [@problem_id:2648595]。", "problem": "您的任务是以科学原理为基础，从带噪声的力标签构建一维机器学习势能模型，并在固定的评估网格上量化能量预测误差。其基本原理是，在一维空间中，一个力场是保守的，等价于存在一个标量能量函数，其负梯度等于该力。具体而言，对于位置 $x$、力 $F(x)$ 和能量 $E(x)$，定义关系为 $F(x) = - \\frac{dE(x)}{dx}$，能量差满足 $E(x) - E(x_{0}) = - \\int_{x_{0}}^{x} F(u)\\,du$。所有量均为无量纲。您的程序必须是完全确定性的，并且不应读取任何输入。\n\n您的程序必须为每个指定的测试用例实现以下内容：\n- 基准能量和力。精确能量为双阱形式 $E_{\\mathrm{true}}(x) = a\\,\\big(x^{2} - b^{2}\\big)^{2} + c\\,x$，精确力为 $F_{\\mathrm{true}}(x) = -\\frac{d}{dx}E_{\\mathrm{true}}(x) = -4\\,a\\,x\\,(x^{2}-b^{2}) - c$，其中 $a$、$b$ 和 $c$ 是给定参数。\n- 训练点的采样。必须通过以下两种方案之一，在区间 $\\left[-L, L\\right]$ 中选择一组 $N$ 个训练位置 $\\{x_{i}\\}_{i=1}^{N}$：\n  - 均匀采样 (Uniform): $x_{i}$ 在 $\\left[-L,L\\right]$ 中等距分布。\n  - 非均匀采样 (立方扭曲, cubic warping): 定义 $u_{i}$ 在 $\\left[-1,1\\right]$ 中等距分布，并设置 $x_{i} = L\\,\\mathrm{sign}(u_{i})\\,|u_{i}|^{3}$。\n- 带噪声的力标签。对于每个 $x_{i}$，计算 $F_{\\mathrm{true}}(x_{i})$ 并添加标准差为 $\\sigma$ 的独立高斯噪声以获得 $F_{\\mathrm{noisy}}(x_{i})$。使用固定的伪随机生成器种子 $2025$，以使噪声在不同运行和用例中可复现。\n- 保守三次样条拟合。通过最小化标准平滑样条目标函数，将三次平滑样条 $\\mathcal{S}_{F}(x)$ 拟合到数据 $\\{(x_{i}, F_{\\mathrm{noisy}}(x_{i}))\\}_{i=1}^{N}$，平滑因子 $s$ 设置为 $s = \\sigma^{2}\\,N$。然后，使用拟合的 $\\mathcal{S}_{F}(x)$ 通过保守积分定义能量预测器：\n  - 固定参考位置 $x_{\\mathrm{ref}} = 0$。\n  - 将预测能量定义为 $\\widehat{E}(x) = E_{\\mathrm{true}}(x_{\\mathrm{ref}}) - \\int_{x_{\\mathrm{ref}}}^{x} \\mathcal{S}_{F}(u)\\,du$。此选择确保模型是一个保守场，并通过在 $x_{\\mathrm{ref}}$ 处锚定来消除任意的能量常数。\n- 误差评估。在一个包含 $M=501$ 个点的均匀评估网格（位于 $\\left[-L,L\\right]$ 内）上，计算能量的均方根误差 (RMSE)，\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{M}\\sum_{j=1}^{M}\\Big(\\widehat{E}(x^{\\mathrm{eval}}_{j}) - E_{\\mathrm{true}}(x^{\\mathrm{eval}}_{j})\\Big)^{2}}.\n$$\n所有能量和力都是无量纲的。\n\n为以下测试套件实现上述过程（每个用例指定 $(a,b,c,L,N,\\sigma,\\text{sampling})$）：\n- 用例 1: $(a=\\!1.0,\\,b=\\!1.0,\\,c=\\!0.1,\\,L=\\!2.0,\\,N=\\!51,\\,\\sigma=\\!0.1,\\,\\text{uniform})$。\n- 用例 2: $(a=\\!0.5,\\,b=\\!1.2,\\,c=\\!0.0,\\,L=\\!2.0,\\,N=\\!41,\\,\\sigma=\\!0.01,\\,\\text{uniform})$。\n- 用例 3: $(a=\\!1.0,\\,b=\\!0.8,\\,c=\\!0.0,\\,L=\\!1.6,\\,N=\\!31,\\,\\sigma=\\!0.3,\\,\\text{uniform})$。\n- 用例 4: $(a=\\!1.0,\\,b=\\!1.0,\\,c=\\!0.2,\\,L=\\!2.0,\\,N=\\!7,\\,\\sigma=\\!0.05,\\,\\text{uniform})$。\n- 用例 5: $(a=\\!0.8,\\,b=\\!1.0,\\,c=\\!0.0,\\,L=\\!2.0,\\,N=\\!51,\\,\\sigma=\\!0.1,\\,\\text{nonuniform})$。\n\n您的程序应按上述顺序计算每个用例的能量 $\\mathrm{RMSE}$，并输出一行包含结果的内容，结果为用方括号括起来的逗号分隔列表。输出列表中的每个数字必须是精确到小数点后六位的小数表示。例如，包含三个用例的输出必须类似于 $[\\text{0.123456},\\text{0.234567},\\text{0.345678}]$。由于问题仅使用无量纲量，因此不需要进行物理单位转换。不使用角度。不使用百分比；所有数字均以小数形式报告。", "solution": "所提出的问题是计算物理学中一个明确定义的练习，具体涉及从模拟的力数据构建机器学习势能模型。该问题具有科学依据，内部一致，并要求应用标准的、可验证的数值方法。因此，该问题被认为是有效的。解决方案如下。\n\n核心原理是，对于一维保守系统，位置 $x$ 处的力 $F(x)$ 是势能 $E(x)$ 的负导数，表示为 $F(x) = -\\frac{dE(x)}{dx}$。因此，两点 $x_0$ 和 $x$ 之间的能量差可以通过对力进行积分得到：\n$$\nE(x) - E(x_0) = -\\int_{x_0}^{x} F(u) \\, du\n$$\n任务是从一组有限的带噪声的力测量值中重建函数 $E(x)$。\n\n首先，我们定义基准模型。真实势能由一个带有线性倾斜的双阱函数给出：\n$$\nE_{\\mathrm{true}}(x) = a(x^2 - b^2)^2 + cx\n$$\n相应的真实力是其负导数：\n$$\nF_{\\mathrm{true}}(x) = -4ax(x^2 - b^2) - c\n$$\n其中 $a$、$b$ 和 $c$ 是指定参数。\n\n其次，我们生成训练数据。在区间 $[-L, L]$ 内采样一组 $N$ 个训练位置 $\\{x_i\\}_{i=1}^N$。指定了两种不同的采样方案：\n1.  **均匀采样**：点 $x_i$ 在 $[-L, L]$ 上等距分布。\n2.  **非均匀采样**：点通过立方扭曲函数生成，$x_i = L \\cdot \\mathrm{sign}(u_i) \\cdot |u_i|^3$，其中 $u_i$ 在 $[-1, 1]$ 上均匀分布。此方案将点集中在域的中心附近。\n\n对于每个训练位置 $x_i$，通过向真实力添加独立同分布的高斯噪声来创建带噪声的力标签：\n$$\nF_{\\mathrm{noisy}}(x_i) = F_{\\mathrm{true}}(x_i) + \\epsilon_i, \\quad \\text{其中} \\quad \\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2)\n$$\n为确保可复现性，伪随机数生成器使用固定值 $2025$ 作为种子。\n\n第三，我们构建机器学习模型。使用三次平滑样条（表示为 $\\mathcal{S}_F(x)$）拟合带噪声的力数据 $\\{(x_i, F_{\\mathrm{noisy}}(x_i))\\}_{i=1}^N$。这是一种非参数回归方法，旨在找到一个近似数据的平滑函数。平滑度由参数 $s$ 控制，根据问题规范，该参数设置为 $s = \\sigma^2 N$。这是一个常见的启发式方法，将平滑水平与噪声方差和数据点数量联系起来。\n\n第四，我们从拟合的力样条 $\\mathcal{S}_F(x)$ 推导出预测的势能 $\\widehat{E}(x)$。为确保模型代表一个保守场，我们通过直接积分获得 $\\widehat{E}(x)$。通过将预测能量锚定在参考点 $x_{\\mathrm{ref}}=0$ 处的真实能量，来固定任意积分常数。这给出了预测能量的表达式：\n$$\n\\widehat{E}(x) = E_{\\mathrm{true}}(x_{\\mathrm{ref}}) - \\int_{x_{\\mathrm{ref}}}^{x} \\mathcal{S}_F(u) \\, du = E_{\\mathrm{true}}(0) - \\int_{0}^{x} \\mathcal{S}_F(u) \\, du\n$$\n此处，$E_{\\mathrm{true}}(0) = a(0^2 - b^2)^2 + c \\cdot 0 = ab^4$。此过程通过构造保证了学习到的势与学习到的力场是一致的。\n\n最后，我们评估学习到的势 $\\widehat{E}(x)$ 的准确性。误差通过相对于真实势 $E_{\\mathrm{true}}(x)$ 的均方根误差 (RMSE) 来量化。这是在一个包含 $M=501$ 个点 $\\{x_j^{\\mathrm{eval}}\\}_{j=1}^M$ 的密集、均匀评估网格（在区间 $[-L, L]$ 内）上计算的：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{M} \\sum_{j=1}^{M} \\left( \\widehat{E}(x_j^{\\mathrm{eval}}) - E_{\\mathrm{true}}(x_j^{\\mathrm{eval}}) \\right)^2}\n$$\n对问题陈述中指定的五个测试用例中的每一个都实施并执行此完整过程。所得的 RMSE 值为模型在不同势形状、数据密度、噪声水平和采样策略条件下的性能提供了定量度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import UnivariateSpline\nfrom typing import List, Tuple, Union\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It orchestrates the calculation of RMSE for each case and prints the final result.\n    \"\"\"\n\n    # Test cases as specified in the problem statement.\n    # Each case is a tuple: (a, b, c, L, N, sigma, sampling_scheme)\n    test_cases = [\n        # Case 1: (a=1.0, b=1.0, c=0.1, L=2.0, N=51, sigma=0.1, 'uniform')\n        (1.0, 1.0, 0.1, 2.0, 51, 0.1, 'uniform'),\n        # Case 2: (a=0.5, b=1.2, c=0.0, L=2.0, N=41, sigma=0.01, 'uniform')\n        (0.5, 1.2, 0.0, 2.0, 41, 0.01, 'uniform'),\n        # Case 3: (a=1.0, b=0.8, c=0.0, L=1.6, N=31, sigma=0.3, 'uniform')\n        (1.0, 0.8, 0.0, 1.6, 31, 0.3, 'uniform'),\n        # Case 4: (a=1.0, b=1.0, c=0.2, L=2.0, N=7, sigma=0.05, 'uniform')\n        (1.0, 1.0, 0.2, 2.0, 7, 0.05, 'uniform'),\n        # Case 5: (a=0.8, b=1.0, c=0.0, L=2.0, N=51, sigma=0.1, 'nonuniform')\n        (0.8, 1.0, 0.0, 2.0, 51, 0.1, 'nonuniform'),\n    ]\n\n    # Initialize a single pseudo-random number generator for reproducibility across all cases.\n    rng = np.random.default_rng(2025)\n\n    results = []\n    for case in test_cases:\n        rmse = compute_rmse_for_case(case, rng)\n        results.append(rmse)\n\n    # Format the output as a comma-separated list of numbers with 6 decimal places,\n    # enclosed in square brackets.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\n\ndef compute_rmse_for_case(case_params: Tuple, rng: np.random.Generator) -> float:\n    \"\"\"\n    Computes the energy RMSE for a single test case.\n\n    Args:\n        case_params: A tuple containing the parameters for the case (a, b, c, L, N, sigma, sampling).\n        rng: The numpy random number generator instance.\n\n    Returns:\n        The calculated root-mean-squared error for the energy.\n    \"\"\"\n    a, b, c, L, N, sigma, sampling = case_params\n\n    # 1. Define ground-truth energy and force functions.\n    def e_true(x: Union[float, np.ndarray]) -> Union[float, np.ndarray]:\n        return a * (x**2 - b**2)**2 + c * x\n\n    def f_true(x: Union[float, np.ndarray]) -> Union[float, np.ndarray]:\n        return -4 * a * x * (x**2 - b**2) - c\n\n    # 2. Generate training points.\n    if sampling == 'uniform':\n        x_train = np.linspace(-L, L, N)\n    elif sampling == 'nonuniform':\n        u = np.linspace(-1.0, 1.0, N)\n        x_train = L * np.sign(u) * np.abs(u)**3\n    else:\n        raise ValueError(\"Invalid sampling scheme specified.\")\n\n    # 3. Generate noisy force labels.\n    f_train_true = f_true(x_train)\n    noise = rng.normal(loc=0.0, scale=sigma, size=N)\n    f_train_noisy = f_train_true + noise\n\n    # Ensure data is sorted by x for spline fitting, which is a requirement for UnivariateSpline.\n    # While linspace and the specified nonuniform transform produce sorted output, this is robust.\n    sort_indices = np.argsort(x_train)\n    x_train_sorted = x_train[sort_indices]\n    f_train_noisy_sorted = f_train_noisy[sort_indices]\n\n    # 4. Fit a conservative model: cubic spline for force.\n    # The smoothing factor 's' is specified as N * sigma^2.\n    smoothing_factor = N * sigma**2\n    force_spline = UnivariateSpline(x_train_sorted, f_train_noisy_sorted, s=smoothing_factor)\n\n    # 5. Construct the predicted energy by integrating the force spline.\n    # The integration constant is set by matching the true energy at x_ref=0.\n    x_ref = 0.0\n    e_ref = e_true(x_ref)\n\n    # The integral of the spline needs to be computed for each evaluation point.\n    # We create a vectorized function for this purpose.\n    @np.vectorize\n    def predict_energy(x: float) -> float:\n        integral_part = force_spline.integral(x_ref, x)\n        return e_ref - integral_part\n\n    # 6. Evaluate the error on a fixed evaluation grid.\n    M = 501\n    x_eval = np.linspace(-L, L, M)\n    \n    e_eval_true = e_true(x_eval)\n    e_eval_predicted = predict_energy(x_eval)\n\n    # 7. Compute the Root-Mean-Squared Error (RMSE).\n    rmse = np.sqrt(np.mean((e_eval_predicted - e_eval_true)**2))\n    \n    return rmse\n\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2648595"}, {"introduction": "物理定律与观察者的坐标系无关。对于原子间势，这意味着能量必须满足旋转不变性，而力必须满足旋转协变性。本练习对这一原理进行了具体的分析性演示，展示了在旋转下力必须如何变换，以确保势能面在物理上是自洽的 [@problem_id:2648608]。", "problem": "考虑一个三原子系统，其原子位置在固定实验室坐标系中为 $\\mathbf{r}_1$、$\\mathbf{r}_2$ 和 $\\mathbf{r}_3$。三维空间中的旋转由特殊正交群 $\\mathrm{SO}(3)$ 的一个元素表示，刚性旋转通过 $\\mathbf{r}_i \\mapsto \\mathbf{R}\\,\\mathbf{r}_i$ 作用于位置，其中 $\\mathbf{R}^{\\top}\\mathbf{R} = \\mathbf{I}$ 且 $\\det \\mathbf{R} = 1$。在遵循特殊欧几里得群 $\\mathrm{SE}(3)$ 对称性的机器学习原子间势中，标量特征是旋转不变的，而矢量和高阶张量特征在 $\\mathbf{R}$ 作用下是等变变换的。力由标量能量对原子位置的负梯度得到，因此，如果能量是旋转不变的，力在旋转下必须像矢量一样变换。\n\n设原子位置（单位一致但任意）为\n$\\mathbf{r}_1 = (0,\\,0,\\,0)$，$\\mathbf{r}_2 = (1,\\,0,\\,0)$ 和 $\\mathbf{r}_3 = (0,\\,1,\\,0)$。考虑旋转矩阵\n$$\n\\mathbf{R} \\;=\\;\n\\begin{pmatrix}\n0  &-1  &0 \\\\\n1  &\\,0  &0 \\\\\n0  &\\,0  &1\n\\end{pmatrix},\n$$\n该矩阵将矢量绕 z 轴旋转 $90$ 度。为每个无序对 $(i,j)$ 定义以下对特征：\n- 一个标量不变特征 $g^{(0)}_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$。\n- 一个矢量等变特征 $\\mathbf{g}^{(1)}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$。\n\n假设一个能量模型仅依赖于由这些特征构建的标量不变量，即相同的谐波对项之和，\n$$\nE(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3) \\;=\\; \\frac{k}{2}\\,\\sum_{1 \\le i  j \\le 3} \\Big(\\|\\mathbf{r}_i - \\mathbf{r}_j\\| - d_0\\Big)^2,\n$$\n其中刚度 $k  0$ 且静止长度 $d_0 = 1$。原子 $i$ 上的力定义为 $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} E$。\n\n任务：\n1. 仅使用上述定义和旋转的性质，确定 $\\mathbf{g}^{(1)}_{ij}$ 在 $\\mathbf{r}_i \\mapsto \\mathbf{R}\\mathbf{r}_i$ 下如何变换，并为给定的构型和 $\\mathbf{R}$ 计算显式的变换后矢量特征 $\\mathbf{R}\\,\\mathbf{g}^{(1)}_{23}$。\n2. 从 $E$ 的定义和链式法则出发，推导单个对的 $\\mathbf{F}_i$，然后计算给定构型的总力 $\\mathbf{F}_1$、$\\mathbf{F}_2$ 和 $\\mathbf{F}_3$。\n3. 将旋转 $\\mathbf{R}$ 应用于计算出的力，以获得旋转后的力 $\\mathbf{F}'_i = \\mathbf{R}\\,\\mathbf{F}_i$。\n4. 通过从旋转后的位置 $\\mathbf{r}'_i = \\mathbf{R}\\,\\mathbf{r}_i$ 重新计算力，独立验证它们与步骤3中获得的 $\\mathbf{F}'_i$ 一致。\n最终答案请提供一个包含旋转后力的 9 分量行矢量，顺序为 $\\big(F'_{1x}, F'_{1y}, F'_{1z}, F'_{2x}, F'_{2y}, F'_{2z}, F'_{3x}, F'_{3y}, F'_{3z}\\big)$。最终的方框答案中不要包含单位。如果选择简化根式，请保留精确形式；无需四舍五入。", "solution": "问题陈述已经过验证，被认为是科学上合理的、适定的、客观的和完整的。这是将矢量微积分和线性代数应用于分子建模物理原理的标准练习。我们将系统地执行所要求的步骤。\n\n能量函数 $E$ 仅依赖于原子间的距离 $\\|\\mathbf{r}_i - \\mathbf{r}_j\\|$。由于距离在旋转下是不变的（$\\|\\mathbf{R}\\mathbf{x}\\| = \\|\\mathbf{x}\\|$），所以能量 $E$ 是旋转不变的。力是能量的负梯度，$\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} E$。根据链式法则，如果能量是不变的，力必须是等变的，即在坐标旋转 $\\mathbf{r}_i \\to \\mathbf{r}'_i = \\mathbf{R}\\mathbf{r}_i$ 后，新的力 $\\mathbf{F}'_i$ 必须满足 $\\mathbf{F}'_i = \\mathbf{R}\\mathbf{F}_i$。我们将逐步验证这一点。\n\n**1. 特征的变换**\n\n矢量特征 $\\mathbf{g}^{(1)}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$ 在旋转下变换为：\n$\\mathbf{g'}^{(1)}_{ij} = \\mathbf{r}'_i - \\mathbf{r}'_j = \\mathbf{R}\\mathbf{r}_i - \\mathbf{R}\\mathbf{r}_j = \\mathbf{R}(\\mathbf{r}_i - \\mathbf{r}_j) = \\mathbf{R}\\mathbf{g}^{(1)}_{ij}$。\n这证明了其等变性。对于 $\\mathbf{r}_2 = (1, 0, 0)^{\\top}$ 和 $\\mathbf{r}_3 = (0, 1, 0)^{\\top}$，我们有 $\\mathbf{g}^{(1)}_{23} = \\mathbf{r}_2 - \\mathbf{r}_3 = (1, -1, 0)^{\\top}$。\n变换后的特征为：\n$$\n\\mathbf{R}\\mathbf{g}^{(1)}_{23} = \\begin{pmatrix} 0  -1  0 \\\\ 1  0  0 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}\n$$\n\n**2. 原始构型的力计算**\n\n作用于原子 $i$ 的力 $\\mathbf{F}_i$ 是来自所有对 $(i,j)$ 的贡献之和。对 $(i,j)$ 这一对的贡献为：\n$$\n\\mathbf{F}_{i \\leftarrow j} = -\\nabla_{\\mathbf{r}_i} \\left[ \\frac{k}{2}(\\|\\mathbf{r}_i - \\mathbf{r}_j\\| - d_0)^2 \\right] = -k (\\|\\mathbf{r}_{ij}\\| - d_0) \\frac{\\mathbf{r}_{ij}}{\\|\\mathbf{r}_{ij}\\|}\n$$\n其中 $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$。\n给定构型：$\\mathbf{r}_1=(0,0,0)$, $\\mathbf{r}_2=(1,0,0)$, $\\mathbf{r}_3=(0,1,0)$ 和 $d_0=1$。\n原子间距离为：$\\|\\mathbf{r}_{12}\\| = 1$, $\\|\\mathbf{r}_{13}\\| = 1$, $\\|\\mathbf{r}_{23}\\| = \\sqrt{2}$。\n- $\\mathbf{F}_1 = \\mathbf{F}_{1 \\leftarrow 2} + \\mathbf{F}_{1 \\leftarrow 3} = -k (1-1)\\frac{\\mathbf{r}_{12}}{1} - k (1-1)\\frac{\\mathbf{r}_{13}}{1} = \\mathbf{0}$。\n- $\\mathbf{F}_2 = \\mathbf{F}_{2 \\leftarrow 1} + \\mathbf{F}_{2 \\leftarrow 3} = -k (1-1)\\frac{\\mathbf{r}_{21}}{1} - k (\\sqrt{2}-1)\\frac{\\mathbf{r}_{23}}{\\sqrt{2}} = -k (\\sqrt{2}-1) \\frac{(1,-1,0)}{\\sqrt{2}} = k\\left(\\frac{\\sqrt{2}}{2}-1, 1-\\frac{\\sqrt{2}}{2}, 0\\right)$。\n- $\\mathbf{F}_3 = \\mathbf{F}_{3 \\leftarrow 1} + \\mathbf{F}_{3 \\leftarrow 2} = -k (1-1)\\frac{\\mathbf{r}_{31}}{1} - k (\\sqrt{2}-1)\\frac{\\mathbf{r}_{32}}{\\sqrt{2}} = -k (\\sqrt{2}-1) \\frac{(-1,1,0)}{\\sqrt{2}} = k\\left(1-\\frac{\\sqrt{2}}{2}, \\frac{\\sqrt{2}}{2}-1, 0\\right)$。\n总力 $\\mathbf{F}_1+\\mathbf{F}_2+\\mathbf{F}_3 = \\mathbf{0}$，符合平移不变性。\n\n**3. 旋转力**\n\n我们将旋转矩阵 $\\mathbf{R}$ 应用于上面计算出的力：\n- $\\mathbf{F}'_1 = \\mathbf{R}\\mathbf{F}_1 = \\mathbf{0}$。\n- $\\mathbf{F}'_2 = \\mathbf{R}\\mathbf{F}_2 = k \\begin{pmatrix} 0  -1  0 \\\\ 1  0  0 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} \\frac{\\sqrt{2}}{2}-1 \\\\ 1-\\frac{\\sqrt{2}}{2} \\\\ 0 \\end{pmatrix} = k \\begin{pmatrix} -(1-\\frac{\\sqrt{2}}{2}) \\\\ \\frac{\\sqrt{2}}{2}-1 \\\\ 0 \\end{pmatrix} = k\\left(\\frac{\\sqrt{2}}{2}-1, \\frac{\\sqrt{2}}{2}-1, 0\\right)$。\n- $\\mathbf{F}'_3 = \\mathbf{R}\\mathbf{F}_3 = k \\begin{pmatrix} 0  -1  0 \\\\ 1  0  0 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} 1-\\frac{\\sqrt{2}}{2} \\\\ \\frac{\\sqrt{2}}{2}-1 \\\\ 0 \\end{pmatrix} = k \\begin{pmatrix} -(\\frac{\\sqrt{2}}{2}-1) \\\\ 1-\\frac{\\sqrt{2}}{2} \\\\ 0 \\end{pmatrix} = k\\left(1-\\frac{\\sqrt{2}}{2}, 1-\\frac{\\sqrt{2}}{2}, 0\\right)$。\n\n**4. 从旋转后的坐标独立计算力**\n\n旋转后的坐标为：\n- $\\mathbf{r}'_1 = \\mathbf{R}\\mathbf{r}_1 = (0,0,0)^{\\top}$\n- $\\mathbf{r}'_2 = \\mathbf{R}\\mathbf{r}_2 = (0,1,0)^{\\top}$\n- $\\mathbf{r}'_3 = \\mathbf{R}\\mathbf{r}_3 = (-1,0,0)^{\\top}$\n原子间距离不变：$\\|\\mathbf{r}'_{12}\\|=1$, $\\|\\mathbf{r}'_{13}\\|=1$, $\\|\\mathbf{r}'_{23}\\|=\\sqrt{2}$。\n- $\\mathbf{F}'_1(\\mathbf{r}') = \\mathbf{0}$。\n- $\\mathbf{F}'_2(\\mathbf{r}') = \\mathbf{F}'_{2 \\leftarrow 1} + \\mathbf{F}'_{2 \\leftarrow 3} = -k(1-1)\\frac{\\mathbf{r}'_{21}}{1} - k(\\sqrt{2}-1)\\frac{\\mathbf{r}'_{23}}{\\sqrt{2}} = -k(\\sqrt{2}-1)\\frac{(1,1,0)}{\\sqrt{2}} = k\\left(\\frac{\\sqrt{2}}{2}-1, \\frac{\\sqrt{2}}{2}-1, 0\\right)$。\n- $\\mathbf{F}'_3(\\mathbf{r}') = \\mathbf{F}'_{3 \\leftarrow 1} + \\mathbf{F}'_{3 \\leftarrow 2} = -k(1-1)\\frac{\\mathbf{r}'_{31}}{1} - k(\\sqrt{2}-1)\\frac{\\mathbf{r}'_{32}}{\\sqrt{2}} = -k(\\sqrt{2}-1)\\frac{(-1,-1,0)}{\\sqrt{2}} = k\\left(1-\\frac{\\sqrt{2}}{2}, 1-\\frac{\\sqrt{2}}{2}, 0\\right)$。\n这些力与第3步中通过旋转原始力得到的 $\\mathbf{F}'_i$ 完全一致，从而验证了力的旋转等变性。\n\n**最终答案**\n\n将旋转后的力分量 $\\mathbf{F}'_1, \\mathbf{F}'_2, \\mathbf{F}'_3$ 连接成一个行向量：\n$$\n\\big( F'_{1x}, F'_{1y}, F'_{1z}, F'_{2x}, F'_{2y}, F'_{2z}, F'_{3x}, F'_{3y}, F'_{3z} \\big) = \\left( 0, 0, 0, k\\left(\\frac{\\sqrt{2}}{2}-1\\right), k\\left(\\frac{\\sqrt{2}}{2}-1\\right), 0, k\\left(1-\\frac{\\sqrt{2}}{2}\\right), k\\left(1-\\frac{\\sqrt{2}}{2}\\right), 0 \\right)\n$$\n这与提供的答案格式相匹配。", "answer": "$$\n\\boxed{\\begin{pmatrix} 0  0  0  k\\left(\\frac{\\sqrt{2}}{2}-1\\right)  k\\left(\\frac{\\sqrt{2}}{2}-1\\right)  0  k\\left(1-\\frac{\\sqrt{2}}{2}\\right)  k\\left(1-\\frac{\\sqrt{2}}{2}\\right)  0 \\end{pmatrix}}\n$$", "id": "2648608"}, {"introduction": "任何新的原子间势的一个关键测试是其在分子动力学模拟中的表现。本练习模拟了这一至关重要的验证步骤，你将使用该势函数进行微正则系综 (NVE) 模拟，并通过监测能量守恒来评估其稳定性。这个过程对于确定一个合适的积分时间步长以进行可靠的生产模拟至关重要 [@problem_id:2648626]。", "problem": "给定一个用于在粒子数、体积和能量（NVE）恒定的微正则系综中进行经典分子动力学模拟的配对机器学习（ML）势能模型。您的任务是实现一个程序，通过运行简短的NVE轨迹并测量总能量的最大分数漂移来确定一个数值稳定的积分时间步长。该系统以约化（无量纲）单位定义，因此质量、长度和能量是无量纲的，且等于单位尺度；因此，漂移度量是无量纲的，不需要物理单位。\n\n基本原理：\n- 牛顿第二定律：对于每个粒子索引 $i$，其质量为 $m_i$，位置向量为 $\\mathbf{r}_i(t)$，速度为 $\\mathbf{v}_i(t)$，力为 $\\mathbf{F}_i(\\mathbf{r})$，其方程为 $m_i \\, \\frac{d^2 \\mathbf{r}_i}{dt^2} = \\mathbf{F}_i(\\mathbf{r})$ 和 $\\mathbf{F}_i(\\mathbf{r}) = - \\nabla_{\\mathbf{r}_i} U(\\mathbf{r})$，其中 $U(\\mathbf{r})$ 是势能函数。\n- 理想微正则系综轨迹中的能量守恒：精确的总能量 $E_{\\mathrm{tot}}(t) = K(t) + U(t)$ 保持不变，其中动能为 $K(t) = \\sum_i \\frac{1}{2} m_i \\lVert \\mathbf{v}_i(t) \\rVert^2$。在数值积分中任何非零的漂移都是离散化误差。\n\nML势能模型：\n- 三个粒子，索引为 $i \\in \\{1,2,3\\}$，在三维空间中具有位置。总势能是所有唯一对的总和，\n$$\nU(\\mathbf{r}) \\;=\\; \\sum_{1 \\le i  j \\le 3} \\; \\sum_{k=1}^{3} \\; w_k \\, \\phi_k(r_{ij}) \\, s(r_{ij}),\n$$\n其中 $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$，配对特征是带有平滑余弦截断的高斯径向基函数，\n$$\n\\phi_k(r) \\;=\\; \\exp\\!\\left(-\\beta_k \\, (r - \\mu_k)^2\\right), \\quad s(r) \\;=\\; \\begin{cases}\n\\dfrac{1}{2}\\left[\\cos\\!\\left(\\dfrac{\\pi r}{r_c}\\right) + 1\\right],  r  r_c,\\\\\n0,  r \\ge r_c.\n\\end{cases}\n$$\n参数如下：\n- 权重 $w_1 = 0.8$，$w_2 = -0.3$，$w_3 = 0.2$。\n- 中心 $\\mu_1 = 1.0$，$\\mu_2 = 2.0$，$\\mu_3 = 3.0$。\n- 宽度参数 $\\beta_1 = 4.0$，$\\beta_2 = 1.0$，$\\beta_3 = 0.5$。\n- 截断半径 $r_c = 3.5$。\n\n力：\n- 对于 $r  r_c$，使用 $s'(r) = -\\dfrac{\\pi}{2 r_c} \\sin\\!\\left(\\dfrac{\\pi r}{r_c}\\right)$，对于 $r \\ge r_c$，则 $s'(r) = 0$。\n- 对于每个配对和基函数索引 $k$，计算 $\\dfrac{d \\phi_k}{dr} = -2 \\beta_k (r - \\mu_k)\\, \\phi_k(r)$。能量贡献的配对径向导数为\n$$\n\\frac{dU_{ij}}{dr} \\;=\\; \\sum_{k=1}^{3} w_k \\left( \\frac{d\\phi_k}{dr}(r_{ij}) \\, s(r_{ij}) \\;+\\; \\phi_k(r_{ij}) \\, s'(r_{ij}) \\right).\n$$\n来自配对 $(i,j)$ 作用于粒子 $i$ 的力是\n$$\n\\mathbf{F}_{i \\leftarrow j} \\;=\\; - \\frac{dU_{ij}}{dr} \\, \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{r_{ij}},\n$$\n并且粒子 $j$ 受到大小相等、方向相反的力以保持动量守恒。作用于粒子 $i$ 的总力是所有 $j \\ne i$ 的力之和。\n\n积分方案：\n- 使用从牛顿第二定律推导出的速度Verlet积分器：\n  - 给定当前位置 $\\mathbf{r}(t)$、速度 $\\mathbf{v}(t)$ 和加速度 $\\mathbf{a}(t) = \\mathbf{F}(t)/m$，使用时间步长 $\\Delta t$ 的更新过程如下\n  $$\n  \\mathbf{v}\\!\\left(t + \\frac{\\Delta t}{2}\\right) = \\mathbf{v}(t) + \\frac{\\Delta t}{2} \\, \\mathbf{a}(t),\n  $$\n  $$\n  \\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\Delta t \\, \\mathbf{v}\\!\\left(t + \\frac{\\Delta t}{2}\\right),\n  $$\n  $$\n  \\mathbf{a}(t + \\Delta t) = \\frac{\\mathbf{F}(\\mathbf{r}(t + \\Delta t))}{m},\n  $$\n  $$\n  \\mathbf{v}(t + \\Delta t) = \\mathbf{v}\\!\\left(t + \\frac{\\Delta t}{2}\\right) + \\frac{\\Delta t}{2} \\, \\mathbf{a}(t + \\Delta t).\n  $$\n- 所有粒子的质量均为 $m_i = 1$。\n\n初始条件：\n- 三维空间中的粒子数 $N = 3$。\n- 初始位置：\n  - 粒子 1：$(0.0, 0.0, 0.0)$，\n  - 粒子 2：$(1.2, 0.0, 0.0)$，\n  - 粒子 3：$(0.6, 1.0, 0.0)$。\n- 初始速度（净动量为零）：\n  - 粒子 1：$(0.0, 0.0, 0.0)$，\n  - 粒子 2：$(0.0, 0.05, 0.0)$，\n  - 粒子 3：$(0.0, -0.05, 0.0)$。\n\n能量漂移度量和稳定性判据：\n- 对于给定的时间步长 $\\Delta t$，运行一个包含 $T$ 个步骤的轨迹，并记录在步骤索引 $n \\in \\{0,1,\\dots,T\\}$ 时的总能量 $E_{\\mathrm{tot}}(n)$。\n- 定义 $E_0 = E_{\\mathrm{tot}}(0)$ 和轨迹上的无量纲最大分数漂移\n$$\nD(\\Delta t) \\;=\\; \\max_{0 \\le n \\le T} \\frac{\\left| E_{\\mathrm{tot}}(n) - E_0 \\right|}{\\max\\left( \\left| E_0 \\right|, \\epsilon \\right)},\n$$\n其中有一个小的正数 $\\epsilon = 10^{-12}$ 以避免在 $E_0 = 0$ 时出现除以零的情况。\n- 如果 $D(\\Delta t) \\le \\tau$，其中 $\\tau = 10^{-3}$，则一个时间步长被分类为稳定。\n\n说明：\n- 严格按照上述定义实现ML势能及其力。\n- 在约化单位中实现用于NVE轨迹的速度Verlet积分器。\n- 对于下面测试集中的每个时间步长，计算 $D(\\Delta t)$ 并根据给定的容差确定其是否稳定。\n- 如果在轨迹中位置、速度、力或能量出现任何非有限值（不是实数），则终止该轨迹，并将 $D(\\Delta t)$ 设置为一个大的哨兵值 $10^{6}$，并将其分类为不稳定。\n- 确定测试集中稳定的最大时间步长。如果没有一个稳定，则该元素返回 $-1$。\n\n测试集：\n- 使用 $T = 1000$ 个步骤。\n- 候选时间步长 $\\Delta t \\in \\{0.001, 0.005, 0.010, 0.020, 0.050, 0.100\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。\n- 该列表必须按照与测试集相同的顺序列出 $6$ 个最大分数漂移 $D(\\Delta t)$，然后是其中最大的稳定时间步长值（如果没有稳定值，则为 $-1$）。例如，打印的字符串应具有 $[d_1,d_2,d_3,d_4,d_5,d_6,d_{\\mathrm{stable}}]$ 的形式，其中每个 $d_i$ 是一个浮点数，$d_{\\mathrm{stable}}$ 是所选时间步长的浮点数或 $-1$。", "solution": "问题陈述已经过评估，被认为是有效的。这是一个在计算物理化学领域内定义良好、科学基础坚实的问题，没有矛盾、歧义和事实错误。任务是实现一个分子动力学模拟，以评估针对自定义机器学习势能的不同积分时间步长的数值稳定性。我们将采用严谨的、基于原理的解决方案。\n\n该解决方案需要实现几个关键部分：给定机器学习模型的势能和力的计算，用于在时间中传播系统的速度Verlet积分算法，以及对总能量守恒的分析以确定积分稳定性。\n\n**1. 系统和势能模型**\n\n该系统由三维空间中的 $N=3$ 个粒子组成，在约化单位系统中，所有粒子的质量都设为单位一（$m_i = 1$）。总势能 $U(\\mathbf{r})$ 定义为所有唯一粒子对 $(i, j)$ 之间相互作用的总和：\n$$\nU(\\mathbf{r}) \\;=\\; \\sum_{1 \\le i  j \\le 3} U_{ij}(r_{ij})\n$$\n其中 $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$ 是粒子 $i$ 和 $j$ 之间的距离。单个配对的相互作用势 $U_{ij}$ 由加权高斯函数的总和乘以一个平滑截断函数来描述：\n$$\nU_{ij}(r_{ij}) \\;=\\; \\sum_{k=1}^{3} \\; w_k \\, \\phi_k(r_{ij}) \\, s(r_{ij})\n$$\n其组成部分是高斯径向基函数，\n$$\n\\phi_k(r) \\;=\\; \\exp\\!\\left(-\\beta_k \\, (r - \\mu_k)^2\\right)\n$$\n和余弦截断函数，\n$$\ns(r) \\;=\\; \\begin{cases}\n\\dfrac{1}{2}\\left[\\cos\\!\\left(\\dfrac{\\pi r}{r_c}\\right) + 1\\right],  r  r_c, \\\\\n0,  r \\ge r_c.\n\\end{cases}\n$$\n提供的参数是权重 $\\{w_k\\}$、中心 $\\{\\mu_k\\}$、宽度参数 $\\{\\beta_k\\}$ 和截断半径 $r_c$。这些参数完全定义了势能面。\n\n**2. 力的计算**\n\n作用于粒子 $i$ 的力 $\\mathbf{F}_i$ 是总势能相对于其位置向量 $\\mathbf{r}_i$ 的负梯度：\n$$\n\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U(\\mathbf{r}) = -\\nabla_{\\mathbf{r}_i} \\sum_{1 \\le k  l \\le 3} U_{kl}(r_{kl})\n$$\n梯度算子 $\\nabla_{\\mathbf{r}_i}$ 只影响求和中依赖于 $\\mathbf{r}_i$ 的项。这些是所有 $j \\ne i$ 的项 $U_{ij}$。通过应用链式法则，作用于粒子 $i$ 的力可以表示为配对力的总和：\n$$\n\\mathbf{F}_i = \\sum_{j \\ne i} \\mathbf{F}_{i \\leftarrow j}\n$$\n其中 $\\mathbf{F}_{i \\leftarrow j}$ 是由于与粒子 $j$ 的相互作用而作用于粒子 $i$ 的力。该力的计算公式为：\n$$\n\\mathbf{F}_{i \\leftarrow j} = -\\nabla_{\\mathbf{r}_i} U_{ij}(r_{ij}) = -\\frac{dU_{ij}}{dr_{ij}} \\nabla_{\\mathbf{r}_i} r_{ij}\n$$\n标量距离 $r_{ij}$ 的梯度是指向从 $j$ 到 $i$ 的单位向量：\n$$\n\\nabla_{\\mathbf{r}_i} r_{ij} = \\nabla_{\\mathbf{r}_i} \\sqrt{(\\mathbf{r}_i - \\mathbf{r}_j)\\cdot(\\mathbf{r}_i - \\mathbf{r}_j)} = \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{r_{ij}}\n$$\n这导致了问题陈述中提供的配对力表达式：\n$$\n\\mathbf{F}_{i \\leftarrow j} = - \\frac{dU_{ij}}{dr_{ij}} \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{r_{ij}}\n$$\n根据牛顿第三定律，粒子 $i$ 对粒子 $j$ 的作用力为 $\\mathbf{F}_{j \\leftarrow i} = -\\mathbf{F}_{i \\leftarrow j}$。此性质对于保持总动量至关重要，在实现中通过计算每个配对力一次，并将其以相反的符号应用于两个相互作用的粒子来加以利用。\n\n配对势的径向导数 $\\frac{dU_{ij}}{dr}$ 是通过对 $U_{ij}(r)$ 的定义应用乘法法则得到的：\n$$\n\\frac{dU_{ij}}{dr} = \\frac{d}{dr} \\left( s(r) \\sum_{k=1}^3 w_k \\phi_k(r) \\right) = s'(r) \\left( \\sum_{k=1}^3 w_k \\phi_k(r) \\right) + s(r) \\left( \\sum_{k=1}^3 w_k \\frac{d\\phi_k}{dr}(r) \\right)\n$$\n这可以重新排列成问题陈述中给出的形式：\n$$\n\\frac{dU_{ij}}{dr} = \\sum_{k=1}^{3} w_k \\left( \\frac{d\\phi_k}{dr}(r_{ij}) \\, s(r_{ij}) + \\phi_k(r_{ij}) \\, s'(r_{ij}) \\right)\n$$\n所需的导数为：\n$$\n\\frac{d \\phi_k}{dr}(r) = -2 \\beta_k (r - \\mu_k)\\, \\phi_k(r) \\quad \\text{和} \\quad s'(r) = -\\frac{\\pi}{2 r_c} \\sin\\!\\left(\\frac{\\pi r}{r_c}\\right) \\quad \\text{对于 } r  r_c.\n$$\n对于 $r \\ge r_c$，这两个导数都为零。\n\n**3. 数值积分方案**\n\n粒子的运动方程 $m_i \\ddot{\\mathbf{r}}_i = \\mathbf{F}_i$ 使用速度Verlet算法进行数值积分。这是一个时间可逆和辛积分器，对于固定的时间步长 $\\Delta t$，它具有出色的长期能量守恒特性。给定系统在时间 $t$ 的状态——位置 $\\mathbf{r}(t)$、速度 $\\mathbf{v}(t)$ 和加速度 $\\mathbf{a}(t) = \\mathbf{F}(\\mathbf{r}(t))/m$——在时间 $t+\\Delta t$ 的状态通过以下步骤计算：\n1.  计算半步速度：$\\mathbf{v}(t + \\frac{\\Delta t}{2}) = \\mathbf{v}(t) + \\frac{\\Delta t}{2} \\mathbf{a}(t)$。\n2.  将位置更新到完整步：$\\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\Delta t \\, \\mathbf{v}(t + \\frac{\\Delta t}{2})$。\n3.  使用新位置计算力 $\\mathbf{F}(\\mathbf{r}(t + \\Delta t))$。\n4.  计算新步的加速度：$\\mathbf{a}(t + \\Delta t) = \\mathbf{F}(\\mathbf{r}(t + \\Delta t))/m$。\n5.  将速度更新到完整步：$\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t + \\frac{\\Delta t}{2}) + \\frac{\\Delta t}{2} \\mathbf{a}(t + \\Delta t)$。\n\n对于每个候选时间步长 $\\Delta t$，此过程重复 $T=1000$ 步。\n\n**4. 能量守恒与稳定性分析**\n\n在完美的微正则（NVE）系综模拟中，总能量 $E_{\\mathrm{tot}} = K + U$ 必须守恒。动能 $K$ 由 $K(t) = \\sum_i \\frac{1}{2} m_i \\lVert \\mathbf{v}_i(t) \\rVert^2$ 给出，势能 $U$ 根据上述模型计算。数值积分会引入离散化误差，导致计算出的总能量随时间漂移。这种漂移的幅度是积分准确性和稳定性的直接度量。\n\n我们使用在 $T$ 步轨迹上的最大分数能量漂移 $D(\\Delta t)$ 来量化稳定性：\n$$\nD(\\Delta t) = \\max_{0 \\le n \\le T} \\frac{\\left| E_{\\mathrm{tot}}(n) - E_0 \\right|}{\\max\\left( \\left| E_0 \\right|, \\epsilon \\right)}\n$$\n其中 $E_{\\mathrm{tot}}(n)$ 是第 $n$ 步的总能量，$E_0$ 是初始总能量，$\\epsilon = 10^{-12}$ 是一个小的常数，以防止除以零。如果一个时间步长 $\\Delta t$ 的漂移 $D(\\Delta t)$ 不超过预定义的容差 $\\tau = 10^{-3}$，则认为该时间步长是稳定的。\n\n最终任务是为测试集 $\\{0.001, 0.005, 0.010, 0.020, 0.050, 0.100\\}$ 中的每个 $\\Delta t$ 计算 $D(\\Delta t)$，并确定满足稳定性标准的最大 $\\Delta t$ 值。如果模拟变得数值不稳定，表现为位置、速度或能量中出现非有限数（例如 `NaN` 或 `inf`），则终止轨迹，并将其漂移赋一个大的哨兵值 $10^6$。如果没有测试的时间步长是稳定的，则最大稳定步长的结果为 $-1$。\n\n实现将包括一个主循环，遍历候选时间步长。对于每个时间步长，从指定的初始条件开始运行模拟，在每个积分步骤跟踪总能量。然后计算并记录最大分数漂移。最后，报告收集到的漂移值和最大的稳定时间步长。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics stability problem.\n    \"\"\"\n    \n    # --- System Parameters ---\n    # ML potential parameters\n    W = np.array([0.8, -0.3, 0.2])\n    MU = np.array([1.0, 2.0, 3.0])\n    BETA = np.array([4.0, 1.0, 0.5])\n    R_CUT = 3.5\n    R_CUT_SQ = R_CUT ** 2\n\n    # Particle properties\n    N_PARTICLES = 3\n    MASSES = np.ones(N_PARTICLES)\n\n    # Initial conditions\n    R0 = np.array([\n        [0.0, 0.0, 0.0],\n        [1.2, 0.0, 0.0],\n        [0.6, 1.0, 0.0]\n    ])\n    V0 = np.array([\n        [0.0, 0.0, 0.0],\n        [0.0, 0.05, 0.0],\n        [0.0, -0.05, 0.0]\n    ])\n\n    # Simulation parameters\n    T_STEPS = 1000\n    DT_CANDIDATES = [0.001, 0.005, 0.010, 0.020, 0.050, 0.100]\n    \n    # Stability criterion\n    DRIFT_TOLERANCE_TAU = 1e-3\n    EPSILON = 1e-12\n    SENTINEL_DRIFT = 1e6\n\n    def calculate_potential_and_forces(positions):\n        \"\"\"\n        Calculates the total potential energy and forces for all particles.\n        \"\"\"\n        potential_energy = 0.0\n        forces = np.zeros_like(positions)\n\n        for i in range(N_PARTICLES):\n            for j in range(i + 1, N_PARTICLES):\n                r_vec = positions[i] - positions[j]\n                r_sq = np.dot(r_vec, r_vec)\n\n                if r_sq >= R_CUT_SQ:\n                    continue\n\n                r = np.sqrt(r_sq)\n                \n                # Calculate phi_k and their derivatives\n                r_minus_mu = r - MU\n                phi_k = np.exp(-BETA * r_minus_mu**2)\n                d_phi_k_dr = -2.0 * BETA * r_minus_mu * phi_k\n\n                # Calculate s(r) and its derivative\n                arg_cos = np.pi * r / R_CUT\n                s_r = 0.5 * (np.cos(arg_cos) + 1.0)\n                s_prime_r = -0.5 * (np.pi / R_CUT) * np.sin(arg_cos)\n\n                # Calculate pair potential U_ij and its derivative dU_ij/dr\n                sum_w_phi = np.dot(W, phi_k)\n                sum_w_dphi = np.dot(W, d_phi_k_dr)\n\n                U_ij = sum_w_phi * s_r\n                dU_ij_dr = sum_w_dphi * s_r + sum_w_phi * s_prime_r\n                \n                potential_energy += U_ij\n\n                # Calculate pairwise force F_i_from_j = - (dU/dr) * (r_vec / r)\n                force_magnitude = -dU_ij_dr / r\n                force_vec = force_magnitude * r_vec\n\n                forces[i] += force_vec\n                forces[j] -= force_vec\n        \n        return potential_energy, forces\n\n    def run_simulation(dt):\n        \"\"\"\n        Runs an NVE simulation for a given time step dt and computes the energy drift.\n        \"\"\"\n        r = R0.copy()\n        v = V0.copy()\n\n        # Initial energy and forces\n        U0, F0 = calculate_potential_and_forces(r)\n        if not np.all(np.isfinite(U0)) or not np.all(np.isfinite(F0)):\n            return SENTINEL_DRIFT\n\n        K0 = 0.5 * np.sum(MASSES[:, np.newaxis] * v**2)\n        E0 = K0 + U0\n\n        a = F0 / MASSES[:, np.newaxis]\n        \n        max_abs_drift = 0.0\n\n        for _ in range(T_STEPS):\n            # Velocity Verlet steps\n            v_half = v + 0.5 * dt * a\n            r += dt * v_half\n            \n            U, F = calculate_potential_and_forces(r)\n            \n            if not np.all(np.isfinite(U)) or not np.all(np.isfinite(F)):\n                return SENTINEL_DRIFT\n\n            a = F / MASSES[:, np.newaxis]\n            v = v_half + 0.5 * dt * a\n        \n            # Energy calculation for drift\n            K = 0.5 * np.sum(MASSES[:, np.newaxis] * v**2)\n            E_n = K + U\n            \n            current_drift = abs(E_n - E0)\n            if current_drift > max_abs_drift:\n                max_abs_drift = current_drift\n        \n        denominator = max(abs(E0), EPSILON)\n        max_fractional_drift = max_abs_drift / denominator\n\n        return max_fractional_drift\n\n    # Main logic\n    drifts = []\n    for dt in DT_CANDIDATES:\n        drift = run_simulation(dt)\n        drifts.append(drift)\n\n    largest_stable_dt = -1.0\n    for i in range(len(DT_CANDIDATES) - 1, -1, -1):\n        if drifts[i] = DRIFT_TOLERANCE_TAU:\n            largest_stable_dt = DT_CANDIDATES[i]\n            break\n\n    results = drifts + [largest_stable_dt]\n    \n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2648626"}]}