{"hands_on_practices": [{"introduction": "对于金属体系的计算，精确地在布里渊区内进行积分是获得可靠结果的关键。本练习通过从零开始构建一个简单的自由电子气模型，提供了一个基础性的动手实践机会。通过这个练习，学生可以亲手探究 $k$ 点网格密度和电子展宽这两个基本参数之间的重要权衡关系，这对于确保任何平面波计算的收敛性都至关重要 [@problem_id:2915098]。", "problem": "您将编写一个完整的、可运行的程序，在平面波形式论和周期性边界条件下，对三维自由电子金属进行建模。该模型使用“空”赝势（零势），因此只有动能有贡献。目标是研究对于不同的电子展宽宽度，每个电子的总能量如何随着 $k$点采样密度的增加而收敛，然后找出展宽和 $k$点采样之间的最佳平衡点，以最低的成本达到指定的目标精度。\n\n从第一性原理出发，使用以下物理上和数值上明确定义的基础：\n- 在原子单位（哈特里原子单位：$\\hbar = 1$，$m_e = 1$，$e = 1$）下，自由电子（空赝势）的 Kohn–Sham (KS) 单粒子哈密顿量给出的单粒子能量为 $\\varepsilon(\\mathbf{k}) = \\lvert \\mathbf{k} \\rvert^2 / 2$。\n- 周期性原胞是一个边长为 $a$、体积为 $V = a^3$ 的立方体，其倒易晶格为简单立方结构，第一布里渊区 (BZ) 由 $\\mathbf{k} \\in [-\\pi/a, \\pi/a)^3$ 给出。\n- 布里渊区积分通过一个均匀的、以 $\\Gamma$ 点为中心的 Monkhorst–Pack (MP) 网格进行近似，每个倒易晶格轴向有 $g$ 个点，总共有 $N_k = g^3$ 个点，权重相等，为 $w_{\\mathbf{k}} = 1/N_k$。使用半平移的均匀网格，以避免将点精确地放置在区域边界上：对于每个笛卡尔分量，使用点 $k_i = -\\pi/a + (i + 1/2)\\Delta k$，其中 $\\Delta k = 2\\pi/(ag)$ 且 $i = 0, 1, \\dots, g-1$。\n- 自旋简并度为 $g_s = 2$，因此占据数为 $f(\\varepsilon, \\mu, \\sigma) = 1 / \\left( 1 + \\exp\\left( (\\varepsilon - \\mu)/\\sigma \\right) \\right)$，这是电子展宽宽度为 $\\sigma$（以哈特里为单位，其作用类似于 $k_B T$）时的费米–狄拉克分布。化学势 $\\mu$ 通过归一化约束条件 $g_s \\sum_{\\mathbf{k}} w_{\\mathbf{k}} f(\\varepsilon_{\\mathbf{k}}, \\mu, \\sigma) = N_e$ 来强制每个原胞的总电子数 $N_e$ 从而确定。\n- 在此模型中，每个电子的内能等于每个电子的动能，由 $E_{\\mathrm{num}} = \\dfrac{g_s \\sum_{\\mathbf{k}} w_{\\mathbf{k}} f(\\varepsilon_{\\mathbf{k}}, \\mu, \\sigma)\\, \\varepsilon_{\\mathbf{k}}}{N_e}$ 给出。\n- 对于下面指定的测试参数，请确保费米球位于第一布里渊区内，这样只有最低的自由电子分支 $\\varepsilon(\\mathbf{k}) = \\lvert \\mathbf{k} \\rvert^2 / 2$ 有贡献。这一点由所选的 $N_e$ 和 $a$ 保证。\n- 对于三维均匀自由电子气，每个电子的精确零温参考能量为 $E_{\\mathrm{exact}} = \\dfrac{3}{5} E_F$，其中 $E_F = k_F^2/2$ 且 $k_F = (3 \\pi^2 n)^{1/3}$，电子数密度为 $n = N_e / V$。\n\n您的程序必须：\n1) 将 $k$ 点求和实现为 MP 网格上的黎曼和，并使用稳健的求根程序，通过求解给定 $g$ 和 $\\sigma$ 下的电子数约束来确定 $\\mu$。\n2) 对每个测试用例，计算每个电子的内能 $E_{\\mathrm{num}}$ 和绝对误差 $\\lvert E_{\\mathrm{num}} - E_{\\mathrm{exact}} \\rvert$（以哈特里为单位）。\n3) 在预设的离散 $(g, \\sigma)$ 对集合中进行搜索，找到以最少的 $k$ 点数 $N_k = g^3$ 达到指定容差以下绝对误差的组合。如果没有组合满足容差要求，则选择所达到的绝对误差最小的组合并报告。\n\n在所有计算中，使用以下固定的物理参数（以哈特里原子单位）：\n- 立方原胞边长 $a = 20$ 玻尔（因此 $V = a^3$）。\n- 每个原胞的总电子数 $N_e = 1$。\n- 自旋简并度 $g_s = 2$。\n\n使用上述公式，由 $n = N_e/V$ 和 $k_F = (3 \\pi^2 n)^{1/3}$ 计算精确参考能量。\n\n数值细节和要求：\n- 对于每个测试的 $g$，使用上述的半平移均匀 MP 网格。\n- 使用费米–狄拉克展宽，宽度为 $\\sigma$（以哈特里为单位）。不要使用零展宽宽度。\n- 对于每个 $(g,\\sigma)$，通过区间法（如二分法）求解电子数方程 $g_s \\sum_{\\mathbf{k}} w_{\\mathbf{k}} f(\\varepsilon_{\\mathbf{k}}, \\mu, \\sigma) = N_e$ 来确定化学势 $\\mu$，以保证对所有 $\\sigma > 0$ 都收敛。\n- 对每个测试用例，计算 $E_{\\mathrm{num}}$ 和绝对误差 $\\lvert E_{\\mathrm{num}} - E_{\\mathrm{exact}} \\rvert$。\n- 所有能量必须以哈特里为单位报告。不涉及角度。不使用百分比。\n\n测试套件：\n- 为了说明收敛性，请评估以下 8 个测试用例 $(g, \\sigma)$（其中 $\\sigma$ 以哈特里为单位）的绝对误差：$(4, 0.002)$、$(6, 0.002)$、$(8, 0.002)$、$(12, 0.002)$、$(4, 0.01)$、$(6, 0.01)$、$(8, 0.01)$、$(12, 0.01)$。\n- 对于最佳平衡搜索，使用候选集 $g \\in \\{4, 6, 8, 10, 12, 16\\}$ 和 $\\sigma \\in \\{0.002, 0.01, 0.05\\}$，容差为 $\\tau = 10^{-3}$ 哈特里。最佳组合是在按 $N_k = g^3$ 递增顺序扫描时，第一个满足条件 $\\lvert E_{\\mathrm{num}} - E_{\\mathrm{exact}} \\rvert \\le \\tau$ 的组合；如果没有组合满足容差要求，则选择误差最小的组合。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，不含空格。\n- 前 8 个条目必须是上述 8 个测试用例的绝对误差（以哈特里为单位），以浮点数形式报告。\n- 最后 4 个条目必须按此顺序报告：最佳 $g$（整数）、最佳 $\\sigma$（浮点数，以哈特里为单位）、相应的 $N_k = g^3$（整数）以及达到的绝对误差（浮点数，以哈特里为单位）。因此，输出列表的总长度为 12 个条目。\n- 所需输出格式示例（非实际数字）：$[e_1,e_2,\\dots,e_8,g_{\\mathrm{opt}},\\sigma_{\\mathrm{opt}},N_{k,\\mathrm{opt}},e_{\\mathrm{opt}}]$。\n\n科学合理性和推导期望：\n- 证明在给定的 $a$ 和 $N_e$ 下，费米球严格位于第一布里渊区内，因此 $\\varepsilon(\\mathbf{k}) = \\lvert \\mathbf{k} \\rvert^2/2$ 已足够，无需考虑更高阶的倒易晶格平移。解释为什么在这个空赝势极限下，每个电子的内能等于每个电子的动能。\n- 使用费米–狄拉克分布和 Mermin 的有限温形式论（在定义层面），论证为什么有限的 $\\sigma$ 会在 $E_{\\mathrm{num}}$ 中引入一个可控的偏差，但会减少 $k$ 点求和中的求积误差，从而导致一个必须由最佳平衡搜索来解决的权衡问题。\n\n本问题陈述中的所有数学符号、变量、函数、算符和数字都应使用 LaTeX 书写，并使用内联数学分隔符，所有能量必须按上述要求以哈特里表示。您的实现必须遵守稍后定义的执行环境和库约束，并且不得读取外部输入。", "solution": "我们在原子单位下，在平面波框架内对三维自由电子金属进行建模，采用空赝势，使得 Kohn–Sham (KS) 哈密顿量简化为动能算符。布洛赫波的单粒子色散关系为 $\\varepsilon(\\mathbf{k}) = \\lvert \\mathbf{k} \\rvert^2/2$。立方原胞的边长为 $a$，体积为 $V = a^3$。对于简单立方晶格，第一布里渊区 (BZ) 是一个立方体 $\\mathbf{k} \\in [-\\pi/a,\\pi/a)^3$。\n\n基础推导：\n1) 平面波基组与空赝势。在哈特里原子单位下，自由电子的 KS 哈密顿量为 $\\hat{H} = -\\nabla^2/2$。其本征函数是平面波 $\\exp(i \\mathbf{k} \\cdot \\mathbf{r})$，本征值为 $\\varepsilon(\\mathbf{k}) = \\lvert \\mathbf{k} \\rvert^2/2$。对于周期性超胞，$\\mathbf{k}$ 被限制在第一布里渊区内，对布里渊区的积分给出每个原胞的观测量。\n\n2) 有限展宽下的占据数。在电子展宽宽度为 $\\sigma$（费米–狄拉克分布，扮演 $k_B T$ 的角色）时，占据数为 $f(\\varepsilon,\\mu,\\sigma) = \\big(1 + \\exp((\\varepsilon - \\mu)/\\sigma)\\big)^{-1}$，其中 $\\mu$ 由电子数约束条件确定。对于自旋简并度 $g_s = 2$ 的电子，每个原胞的电子数为\n$$\nN_e = g_s \\int_{\\mathrm{BZ}} \\frac{d^3 k}{\\Omega_{\\mathrm{BZ}}}\\, f\\big(\\varepsilon(\\mathbf{k}),\\mu,\\sigma\\big),\n$$\n其中 $\\Omega_{\\mathrm{BZ}}$ 是布里渊区的体积。在数值上，我们将积分替换为一个均匀的、以 $\\Gamma$ 点为中心的 Monkhorst–Pack (MP) 网格，每个轴向有 $g$ 个点，总点数为 $N_k = g^3$，权重相等，为 $w_{\\mathbf{k}} = 1/N_k$。我们采用半平移，使点不落在区域边界上：\n$$\nk_i = -\\frac{\\pi}{a} + \\left(i + \\frac{1}{2}\\right)\\Delta k,\\quad \\Delta k = \\frac{2\\pi}{a g},\\quad i = 0,1,\\dots,g-1.\n$$\n离散化的电子数约束变为\n$$\nN_e = g_s \\sum_{\\mathbf{k}} w_{\\mathbf{k}} f\\big(\\varepsilon(\\mathbf{k}),\\mu,\\sigma\\big) = g_s \\frac{1}{N_k} \\sum_{\\mathbf{k}} f\\big(\\varepsilon(\\mathbf{k}),\\mu,\\sigma\\big).\n$$\n这个关于 $\\mu$ 的单调方程可通过二分法稳健地求解，因为当 $\\mu \\to -\\infty$ 时，$f\\to 0$ 且和为零，而当 $\\mu \\to +\\infty$ 时，$f\\to 1$ 且和趋近于 $g_s$；因此对于任何 $N_e \\in (0,g_s)$ 都存在解。\n\n3) 每个电子的内能。在空赝势极限下，总内能等于动能。其离散估计量为\n$$\nE_{\\mathrm{num}} = \\frac{g_s \\sum_{\\mathbf{k}} w_{\\mathbf{k}} f\\big(\\varepsilon(\\mathbf{k}),\\mu,\\sigma\\big)\\, \\varepsilon(\\mathbf{k})}{N_e}.\n$$\n我们以哈特里为单位报告此能量。\n\n4) 精确参考能量与费米球条件。数密度为 $n = N_e/V$。零温下的费米波矢为 $k_F = (3\\pi^2 n)^{1/3}$，费米能为 $E_F = k_F^2/2$，每个电子的精确零温内能为\n$$\nE_{\\mathrm{exact}} = \\frac{3}{5} E_F = \\frac{3}{5}\\frac{k_F^2}{2}.\n$$\n我们还必须确保费米球位于第一布里渊区内，这样只需要考虑最低的自由电子抛物面，而无需进行能带折叠。布里渊区边界的大小为 $\\pi/a$。给定参数 $a = 20$ 玻尔和 $N_e = 1$，原胞体积为 $V = a^3 = 20^3 = 8000$，密度为 $n = N_e/V = 1/8000 = 0.000125$，由此得出\n$$\nk_F = \\big(3\\pi^2 n\\big)^{1/3} = \\big(3\\pi^2 \\times 0.000125\\big)^{1/3},\n$$\n且\n$$\n\\frac{\\pi}{a} = \\frac{\\pi}{20}.\n$$\n从数值上看，$k_F \\approx 0.154$ 且 $\\pi/a \\approx 0.157$，因此 $k_F  \\pi/a$，这确保了费米球严格位于第一布里渊区内部。因此，在此设置中，布里渊区内的 $\\varepsilon(\\mathbf{k}) = \\lvert \\mathbf{k} \\rvert^2/2$ 足以描述所有被占据的态。\n\n5) 展宽与 $k$ 点的权衡。有限的展宽平滑了费米面处的不连续性，并减少了离散 $k$ 点求和中的求积误差（尤其是在使用粗糙 $k$ 点网格时），但它相对于零温值在 $E_{\\mathrm{num}}$ 中引入了偏差。对于费米–狄拉克统计，Sommerfeld 展开表明，对于小的 $\\sigma$，内能中的主要偏差与 $\\mathcal{O}(\\sigma^2)$ 成正比，而来自有限 $k$ 点采样的求积误差通常随着网格的加密而减小。因此，在精度约束下，存在一个 $\\sigma$ 和网格密度之间的最佳平衡点，可以最小化计算成本（此处以 $N_k = g^3$ 衡量）。\n\n算法设计：\n- 对于每个测试用例 $(g,\\sigma)$，构建均匀的半平移 MP 网格并计算 $\\varepsilon(\\mathbf{k})$。\n- 通过在方程 $g_s \\frac{1}{N_k}\\sum_{\\mathbf{k}} f(\\varepsilon(\\mathbf{k}),\\mu,\\sigma) - N_e = 0$ 上使用二分法求解 $\\mu$。在极值能量周围使用一个宽泛、安全的区间，该区间根据 $\\sigma$ 的倍数进行调整，以确保左侧表达式在该区间内变号。映射 $\\mu \\mapsto \\sum f$ 是严格递增的，保证了二分法的收敛性。\n- 计算 $E_{\\mathrm{num}} = \\dfrac{g_s}{N_e} \\frac{1}{N_k}\\sum_{\\mathbf{k}} f(\\varepsilon(\\mathbf{k}),\\mu,\\sigma)\\, \\varepsilon(\\mathbf{k})$ 和绝对误差 $\\lvert E_{\\mathrm{num}} - E_{\\mathrm{exact}} \\rvert$（以哈特里为单位）。\n- 对于最佳平衡搜索，枚举候选集 $g \\in \\{4,6,8,10,12,16\\}$ 和 $\\sigma \\in \\{0.002,0.01,0.05\\}$，计算每对的误差，并选择按 $N_k = g^3$ 递增顺序排列时第一个满足容差 $\\tau = 10^{-3}$ 哈特里的组合。如果没有组合满足容差，则选择误差最小的组合。\n\n测试套件与输出：\n- 计算 8 个测试用例 $(g,\\sigma)$ 的绝对误差，顺序为：$(4, 0.002)$、$(6, 0.002)$、$(8, 0.002)$、$(12, 0.002)$、$(4, 0.01)$、$(6, 0.01)$、$(8, 0.01)$、$(12, 0.01)$。\n- 在指定的候选集和容差范围内执行最佳平衡选择。\n- 以精确格式 $[e_1,e_2,\\dots,e_8,g_{\\mathrm{opt}},\\sigma_{\\mathrm{opt}},N_{k,\\mathrm{opt}},e_{\\mathrm{opt}}]$ 输出单行结果，不含空格，其中 $e_i$ 和 $e_{\\mathrm{opt}}$ 是以哈特里为单位的绝对误差，$g_{\\mathrm{opt}}$ 和 $N_{k,\\mathrm{opt}}$ 是整数，$\\sigma_{\\mathrm{opt}}$ 以哈特里为单位。\n\n该方法清晰地将平面波和赝势框架（空赝势）、Mermin 形式论中的有限温（展宽）占据数，以及通过均匀 $k$ 点采样的布里渊区求积联系起来，从而能够在严格、可验证的精度标准下，对收敛性进行定量研究，并提供一个明确的算法来确定展宽和 $k$ 点密度之间的最佳平衡。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Execution environment: Python 3.12, numpy 1.23.5, scipy 1.11.4 (not used)\n# Self-contained: no input, no external files.\n\ndef build_k_grid_and_energies(a_bohr: float, g: int):\n    \"\"\"\n    Construct half-shifted, uniform Monkhorst–Pack-like k-grid for a simple cubic BZ:\n      k_i = -pi/a + (i + 0.5) * (2pi/(a*g)), for i = 0..g-1\n    Returns flattened energies eps = |k|^2 / 2 in Hartree (atomic units).\n    \"\"\"\n    dk = 2.0 * np.pi / (a_bohr * g)\n    kmin = -np.pi / a_bohr\n    # Half-shifted grid avoids boundary points\n    k1d = kmin + (np.arange(g) + 0.5) * dk\n    # Build 3D grid and compute energies\n    kx, ky, kz = np.meshgrid(k1d, k1d, k1d, indexing='ij')\n    k2 = kx*kx + ky*ky + kz*kz\n    eps = 0.5 * k2  # Hartree (since atomic units)\n    return eps.reshape(-1)\n\ndef fermi_dirac_occ(eps: np.ndarray, mu: float, sigma: float):\n    \"\"\"\n    Stable Fermi-Dirac occupation f = 1 / (1 + exp((eps-mu)/sigma)).\n    sigma  0 (Hartree). Returns vector of same shape as eps.\n    \"\"\"\n    x = (eps - mu) / sigma\n    # Use stable logistic evaluation\n    # For x = 0: f = exp(-x) / (1 + exp(-x))\n    # For x  0:  f = 1 / (1 + exp(x))\n    occ = np.empty_like(x)\n    mask = x = 0\n    # Avoid overflow by clipping exponentials\n    xm = x[mask]\n    xp = x[~mask]\n    occ[mask] = np.exp(-np.clip(xm, -700, 700))\n    occ[mask] = occ[mask] / (1.0 + occ[mask])\n    exp_xp = np.exp(np.clip(xp, -700, 700))\n    occ[~mask] = 1.0 / (1.0 + exp_xp)\n    return occ\n\ndef solve_mu_for_number(eps: np.ndarray, sigma: float, Ne: float, gs: float):\n    \"\"\"\n    Solve for chemical potential mu such that:\n      gs * mean(f(eps, mu, sigma)) = Ne\n    using bisection on a safe bracket.\n    \"\"\"\n    # Safe bracket around min/max energies extended by multiples of sigma and a buffer\n    e_min = float(np.min(eps))\n    e_max = float(np.max(eps))\n    # Ensure sigma contributes to bracket extent; add additive buffer in case sigma is tiny\n    buffer = max(1.0, 10.0 * sigma)\n    mu_lo = e_min - 10.0 * buffer\n    mu_hi = e_max + 10.0 * buffer\n\n    def electrons(mu):\n        f = fermi_dirac_occ(eps, mu, sigma)\n        return gs * float(np.mean(f))\n\n    # Expand bracket if necessary to ensure monotonic bracket captures root\n    N_lo = electrons(mu_lo)\n    N_hi = electrons(mu_hi)\n    # If for numerical reasons the bracket is not wide enough, expand geometrically\n    expand_count = 0\n    while N_lo = Ne and expand_count  50:\n        mu_lo -= 2.0 * buffer\n        N_lo = electrons(mu_lo)\n        expand_count += 1\n    expand_count = 0\n    while N_hi = Ne and expand_count  50:\n        mu_hi += 2.0 * buffer\n        N_hi = electrons(mu_hi)\n        expand_count += 1\n\n    # Bisection\n    for _ in range(100):\n        mu_mid = 0.5 * (mu_lo + mu_hi)\n        N_mid = electrons(mu_mid)\n        if N_mid  Ne:\n            mu_hi = mu_mid\n        else:\n            mu_lo = mu_mid\n        if abs(mu_hi - mu_lo)  1e-12:\n            break\n    return 0.5 * (mu_lo + mu_hi)\n\ndef compute_internal_energy_per_electron(a: float, g: int, sigma: float,\n                                         Ne: float, gs: float, E_exact: float,\n                                         cache):\n    \"\"\"\n    Compute E_num (Hartree per electron) and absolute error vs E_exact for given (g, sigma).\n    Uses a cache to avoid recomputation.\n    \"\"\"\n    key = (g, float(sigma))\n    if key in cache:\n        return cache[key]\n    eps = build_k_grid_and_energies(a, g)\n    mu = solve_mu_for_number(eps, sigma, Ne, gs)\n    f = fermi_dirac_occ(eps, mu, sigma)\n    # Internal energy per electron\n    E_num = (gs * float(np.mean(f * eps))) / Ne\n    err = abs(E_num - E_exact)\n    cache[key] = (E_num, err)\n    return cache[key]\n\ndef solve():\n    # Physical parameters (atomic units)\n    a = 20.0  # bohr\n    V = a**3  # bohr^3\n    Ne = 1.0\n    gs = 2.0\n\n    # Exact zero-temperature energy per electron for 3D free electron gas\n    n = Ne / V\n    kF = (3.0 * (np.pi**2) * n)**(1.0/3.0)\n    EF = 0.5 * (kF**2)\n    E_exact = (3.0/5.0) * EF  # Hartree per electron\n\n    # Test suite: 8 cases\n    test_cases = [\n        (4, 0.002),\n        (6, 0.002),\n        (8, 0.002),\n        (12, 0.002),\n        (4, 0.01),\n        (6, 0.01),\n        (8, 0.01),\n        (12, 0.01),\n    ]\n\n    # Compute errors for test cases\n    cache = {}\n    errors = []\n    for g, sigma in test_cases:\n        _, err = compute_internal_energy_per_electron(a, g, sigma, Ne, gs, E_exact, cache)\n        errors.append(round(err, 8))  # round for stable printing\n\n    # Optimal balance search\n    tau = 1e-3  # Hartree\n    g_candidates = [4, 6, 8, 10, 12, 16]\n    sigma_candidates = [0.002, 0.01, 0.05]\n\n    # Enumerate pairs ordered by increasing Nk = g^3\n    pairs = []\n    for g in g_candidates:\n        Nk = g**3\n        for sigma in sigma_candidates:\n            pairs.append((Nk, g, sigma))\n    pairs.sort(key=lambda x: x[0])  # sort by Nk\n\n    g_opt = None\n    sigma_opt = None\n    Nk_opt = None\n    err_opt = None\n\n    # Scan for first pair meeting tolerance\n    best_err = None\n    best_tuple = None\n    for Nk, g, sigma in pairs:\n        _, err = compute_internal_energy_per_electron(a, g, sigma, Ne, gs, E_exact, cache)\n        if (best_err is None) or (err  best_err):\n            best_err = err\n            best_tuple = (g, sigma, Nk, err)\n        if err = tau and g_opt is None:\n            g_opt, sigma_opt, Nk_opt, err_opt = g, sigma, Nk, err\n            break\n\n    # If none met tolerance, pick best-attained error\n    if g_opt is None:\n        g_opt, sigma_opt, Nk_opt, err_opt = best_tuple\n\n    # Prepare flat results list: 8 errors + g_opt + sigma_opt + Nk_opt + err_opt\n    results = []\n    for e in errors:\n        # ensure consistent numeric format\n        results.append(e if isinstance(e, float) else float(e))\n    results.append(int(g_opt))\n    results.append(float(sigma_opt))\n    results.append(int(Nk_opt))\n    results.append(round(float(err_opt), 8))\n\n    # Print as a single line, comma-separated, no spaces, enclosed in square brackets\n    def format_number(x):\n        # Ensure minimal yet readable representation, no spaces\n        if isinstance(x, int):\n            return str(x)\n        # For floats, ensure standard Python str formatting, but avoid scientific notation for small numbers if possible\n        return str(x)\n\n    print(\"[\" + \",\".join(format_number(x) for x in results) + \"]\")\n\nsolve()\n```", "id": "2915098"}, {"introduction": "在理解了单个收敛参数的基础上，本实践将挑战转向确保计算整体准确性的更宏观层面。它指导学生像研究者一样思考，设计一个系统的灵敏度分析流程。本练习的目标是学习如何有条不紊地分离和识别来自基组（由 $E_{\\text{cut}}$ 控制）、$k$ 点采样和赝势本身的误差，这是产出可靠科学结果的一项关键技能 [@problem_id:2915024]。", "problem": "您正在将使用平面波基组和赝势计算出的砷化镓的平衡晶格常数与一个可靠的全电子参考值进行比较。您的计算结果比参考值大了约 $1.5\\%$。您怀疑误差来自三个来源：平面波基组不完备性（由动能截断能 $E_{\\text{cut}}$ 控制）、布里渊区采样误差（由 $k$ 点网格控制）和赝势的可移植性（在模守恒赝势、超软赝势和投影缀加波方法之间的选择，以及对镓 $3d$ 态的具体处理方式）。您必须设计一个灵敏度分析，将差异归因于这些来源，并且仅使用公认的原理：平面波基组的完备性随平面波动能截断能 $E_{\\text{cut}}$ 单调增加；布里渊区积分由离散的 $k$ 点网格近似，并随着采样密度的增加而收敛；赝势近似了价电子与离子实核之间的相互作用，其可移植性必须通过不同类型赝势和价电子划分的交叉检验来验证。该设计应通过一次只改变一个控制变量来避免混淆变量，并应包括对多种赝势类型的交叉检验。\n\n以下哪种分析方案最可靠地分离了基组、 $k$ 点和赝势误差的贡献，并包含了必要的交叉检验来归因所观察到的 $1.5\\%$ 的差异？\n\nA. 同时缩放 $E_{\\text{cut}}$ 和 $k$ 点网格的线密度（例如，每一步都将两者加倍），并在每个组合设置下完全弛豫结构，直到力低于 $10^{-3}$ eV/Å。在整个过程中使用单一的投影缀加波赝势集。如果在两三次这样的缩放后差异仍然存在，则将其归因于交换相关泛函，因为基组和 $k$ 点是同步增加的。\n\nB. 在固定的实验体积和晶胞形状下，通过增加 $E_{\\text{cut}}$ 进行平面波截断能收敛测试，直到总能量变化低于 $1$ meV/atom 且连续的 $E_{\\text{cut}}$ 值之间的所有应力张量分量变化小于 $0.1$ GPa，同时使用足够密集的 $k$ 点网格和适用于半导体的固定展宽。将总能量与 $E_{\\text{cut}}$ 的关系拟合到一个平滑的渐近形式，以估计 $E_{\\text{cut}} \\to \\infty$ 的极限。接下来，将 $E_{\\text{cut}}$ 固定在收敛值，使用一致的积分方案（例如，四面体方法或固定宽度展宽）对 $k$ 点网格密度进行收敛测试（例如，以 $\\Gamma$ 为中心的 Monkhorst–Pack 网格），并在需要时外推到无限网格极限。只有在两个控制参数都收敛之后，才使用多种赝势重复计算：将镓 $3d$ 态分别作为芯态和价态处理的模守恒和超软赝势，以及投影缀加波数据集。对于每种赝势，在相同的数值容差下重新进行 $E_{\\text{cut}}$ 和 $k$ 点收敛测试，然后重新弛豫结构并比较得到的晶格常数；如果可能，可选择性地包含与全电子参考值的单点交叉检验。将基组和 $k$ 点收敛后，不同赝势之间的任何剩余差异归因于赝势的可移植性。\n\nC. 对所有赝势使用一个统一的 $E_{\\text{cut}}$，该值取自赝势生成器推荐的最小值，并使用仅含 $\\Gamma$ 点的 $k$ 点。如果差异仍然存在，则将电子展宽宽度增加一倍以稳定自洽场循环。将任何剩余的差异归因于赝势误差，因为基组和 $k$ 点设置都保持固定。\n\nD. 首先使用一个低的 $E_{\\text{cut}}$ 来保持计算成本低廉，并在此条件下对 $k$ 点网格进行收敛测试，然后假设在收敛的 $k$ 点网格下，能量收敛所需的 $E_{\\text{cut}}$ 是相似的。仅比较将镓 $3d$ 作为芯态的模守恒赝势。如果它们在 $5$ meV/atom 内一致，则断定赝势不是误差来源，并将 $1.5\\%$ 的差异归因于基组误差。\n\nE. 在三个相隔 $10$ Ry 的 $E_{\\text{cut}}$ 值下进行完整的体积优化，每次都拟合状态方程；选择能产生与下一个更大的 $E_{\\text{cut}}$ 值相比晶格常数差异在 $0.2\\%$ 以内的最小 $E_{\\text{cut}}$。然后测试 $k$ 点网格，直到总能量变化小于 $10$ meV/atom。如果 $1.5\\%$ 的差异仍然存在，则切换到另一个模守恒赝势库；如果晶格常数变化小于 $0.1\\%$，则宣布该赝势可接受，并将剩余误差归因于 $k$ 点。", "solution": "问题陈述是计算材料科学领域中一个有效且定义明确的问题。它描述了在使用平面波基组和赝势进行密度泛函理论（$DFT$）计算时遇到的一个标准情景。已识别的误差来源——平面波基组不完备性（$E_{\\text{cut}}$）、布里渊区采样（$k$ 点）和赝势选择——是为获得准确结果而必须收敛的主要数值参数。目标是设计一个方案，正确地分离每个误差源对计算出的砷化镓（$GaAs$）晶格常数 $1.5\\%$ 差异的贡献。\n\n一个科学严谨的灵敏度分析必须遵循一次只改变一个参数的基本原则。通过同时改变多个参数引入的混淆变量，使得将观察到的变化归因于特定来源变得不可能。解决此问题的正确方案必须在评估物理近似（赝势）之前，依次收敛数值参数。\n\n正确的步骤如下：\n1.  选择一种赝势。\n2.  选择一个非常密集的 $k$ 点网格，以在基组收敛过程中最小化其误差贡献。在固定几何结构下（例如，实验晶格常数），计算一系列递增的平面波动能截断能 $E_{\\text{cut}}$ 下的总能量或应力张量。当所选的可观测量（例如，每个原子的总能量）在最后两个截断能值之间的变化小于一个严格的容差时，认为截断能已收敛。\n3.  使用收敛的 $E_{\\text{cut}}$ 值，对 $k$ 点网格进行收敛测试。计算一系列日益密集的 $k$ 点网格（例如，$4 \\times 4 \\times 4$，$6 \\times 6 \\times 6$ 等）下的总能量。当总能量的变化小于一个严格的容差时，认为网格已收敛。\n4.  在 $E_{\\text{cut}}$ 和 $k$ 点网格都收敛后，进行完整的结构弛豫（几何优化）以找到平衡晶格常数。该计算结果代表了所选赝势在基组和 $k$ 点方面收敛后的预测值。\n5.  为了评估赝势误差，使用不同的赝势重复整个过程（步骤 $1-4$）。这必须包括不同的类型（模守恒、超软、投影缀加波），以及对镓来说至关重要的不同价电子组态（即将 Ga $3d$ 态作为芯电子或价电子处理）。最终收敛的晶格常数的分布范围是衡量赝势可移植性误差的一个指标。与可靠的全电子计算的偏差量化了每种赝势的绝对误差。\n\n基于这种正确的方法论，我们评估每个提议的选项。\n\n**选项 A：**该方案建议同时缩放 $E_{\\text{cut}}$ 和 $k$ 点网格密度。这在根本上是有缺陷的，因为它引入了混淆变量。观察到的晶格常数变化无法唯一地归因于基组改进或更好的布里渊区采样，因为两者都在变化。将持续存在的误差归因于交换相关泛函的结论是不合逻辑的，因为来自主要数值参数的贡献尚未被恰当分离。\n**结论：不正确。**\n\n**选项 B：**该方案描述了一个系统而严谨的程序，与公认的最佳实践完全一致。它正确地将数值参数的收敛与最终计算分离开来。首先，它在一个固定的、密集的 $k$ 点网格上对 $E_{\\text{cut}}$ 进行收敛测试。其次，它在确定的 $E_{\\text{cut}}$ 下对 $k$ 点网格进行收敛测试。这个顺序过程正确地隔离了变量。关键的是，它规定了必须对多种赝势重复进行整个收敛研究，包括不同的类型和价电子处理方式（Ga $3d$ 态），并且应该比较最终的收敛结果。这是可靠地将最终误差归因于赝势选择的唯一方法。该方案条理清晰、合理，并且旨在得出站得住脚的结论。\n**结论：正确。**\n\n**选项 C：**该方案严重不足。对于像晶格常数这样的结构性质的高精度计算，使用“推荐的最小值” $E_{\\text{cut}}$ 几乎永远不够。对于像 $GaAs$ 这样的半导体，使用仅含 $\\Gamma$ 点的 $k$ 点会导致布里渊区积分中出现一个非常大的、不受控制的误差。增加电子展宽对于半导体来说是一个不恰当的工具，并且不能解决基组或 $k$ 点不足的问题。在这些不受控制的条件下将误差归因于赝势是毫无根据的。\n**结论：不正确。**\n\n**选项 D：**该方案颠倒了正确的收敛程序。不应该使用一个低的、未收敛的 $E_{\\text{cut}}$ 来对 $k$ 点网格进行收敛测试。所需的 $k$ 点采样水平可能取决于基组，用一个不充分的基组进行此测试可能会产生误导性结果。标准的、稳健的程序是使用一个“安全”的（过度收敛的）$k$ 点网格来确定所需的 $E_{\\text{cut}}$，然后使用该 $E_{\\text{cut}}$ 来确定最小的足够 $k$ 点网格。此外，仅测试单一价电子组态（Ga $3d$ 在芯态）的模守恒赝势是对赝势误差的不完整评估。最大的误差通常来自价电子划分的选择或不同赝势类型（例如，模守恒与投影缀加波）之间的差异。\n**结论：不正确。**\n\n**选项 E：**该方案使用了一种宽松且不可靠的收敛方法。仅在三个 $E_{\\text{cut}}$ 值下检查晶格常数的收敛是稀疏的。对最终性质（晶格常数到 $0.2\\%$）设置收敛容差，不如将总能量或力收敛到一个严格的容差（例如，亚 meV 级别）来得直接和可靠。评估赝势的逻辑也是有缺陷的。发现两种不同的赝势给出相似的结果（变化小于 $0.1\\%$）并不能证明它们是正确的；它们可能都受到相同的系统误差的影响。宣布赝势可接受并将剩余的 $1.5\\%$ 的大误差归咎于 $k$ 点是一个未经证实的猜测。\n**结论：不正确。**", "answer": "$$\\boxed{B}$$", "id": "2915024"}, {"introduction": "在掌握了收敛性测试和通用方法学之后，这最后一个实践将深入探讨赝势本身的复杂性。通过一个动手编程问题，它旨在解决一种被称为“鬼态”的著名赝势病态。通过构建和诊断一个简单的一维模型，学生可以深入了解这些非物理束缚态是如何产生的，以及如何通过修改赝势的构造来消除它们，从而揭开赝势质量这一关键方面的神秘面纱 [@problem_id:2915027]。", "problem": "您将实现一个一维平面波模拟，该模拟旨在模拟 Kleinman–Bylander 可分离非局域赝势的基本特征，并演示如何通过选择局域通道或投影算符构造来消除鬼态，同时保持可移植性。请在哈特里原子单位下工作，其中电子质量为1，能量单位为哈特里 (Ha)，长度单位为玻尔 (bohr)，普朗克常数除以 $2\\pi$ 等于 $1$。该系统是一个长度为 $L$ 的一维大超胞，具有周期性边界条件，并采用由动能截断所截断的平面波基组。\n\n基本基组与模型规范：\n- 考虑一个长度为 $L$ 的一维周期性超胞和平面波基组 $\\{\\lvert G \\rangle\\}$，其波矢 $G = 2\\pi n/L$，其中 $n$ 为整数。平面波是正交归一的，即 $\\langle x \\lvert G \\rangle = L^{-1/2}\\exp(i G x)$。\n- 动能算符为 $T = -\\frac{1}{2} \\frac{d^2}{dx^2}$，在平面波基组中，其对角元为 $T_{G,G'} = \\frac{G^2}{2} \\delta_{G,G'}$。\n- 局域势是一个高斯势阱 $V_{\\mathrm{loc}}(x) = V_0 \\exp\\!\\left[-(x/a)^2\\right]$，其中 $V_0  0$ 且 $a0$。其矩阵元为 $V^{\\mathrm{loc}}_{G,G'} = \\frac{1}{L}\\int_{-L/2}^{L/2} V_{\\mathrm{loc}}(x) e^{-i(G-G')x}\\,dx$。对于 $L \\gg a$ 的情况，该积分可以很好地由全线傅里叶变换近似：$V^{\\mathrm{loc}}_{G,G'} \\approx \\frac{1}{L} \\int_{-\\infty}^{\\infty} V_{\\mathrm{loc}}(x) e^{-i(G-G')x}\\,dx$。\n- 非局域赝势以 Kleinman–Bylander 可分离形式 $V_{\\mathrm{nl}} = \\sum_{i=1}^{N_p} D_i \\lvert \\beta_i \\rangle \\langle \\beta_i \\rvert$ 给出，其中 $D_i$ 是实数耦合系数，$\\beta_i(x)$ 是局域化投影函数。在平面波基组中，非局域矩阵为 $\\left(V_{\\mathrm{nl}}\\right)_{G,G'} = \\sum_i D_i\\, \\langle G \\vert \\beta_i \\rangle \\langle \\beta_i \\vert G' \\rangle$，其中 $\\langle G \\vert \\beta_i \\rangle = L^{-1/2}\\int \\beta_i(x) e^{-i G x}\\,dx$。\n- 使用两种类型的投影算符，通过一维中的宇称来模拟不同的角动量通道：“偶宇称”（类s）和“奇宇称”（类p）。使用以下模型投影算符：\n  - 偶宇称投影算符：$\\beta^{(\\mathrm{even})}_b(x) = \\exp\\!\\left[-(x/b)^2\\right]$，宽度参数为 $b0$。\n  - 奇宇称投影算符：$\\beta^{(\\mathrm{odd})}_b(x) = x \\exp\\!\\left[-(x/b)^2\\right]$，宽度参数为 $b0$。\n  它们的平面波分量需通过定义积分 $\\langle G \\vert \\beta \\rangle = L^{-1/2} \\int_{-\\infty}^{\\infty} \\beta(x) e^{-i G x}\\,dx$ 获得。对于高斯函数，傅里叶变换是标准的，并能得出您应精确实现的封闭形式。\n\n待构造和对角化的哈密顿量：\n- 截断的平面波基组由一个能量截断值 $E_{\\mathrm{cut}}$ 定义：包含所有满足 $\\frac{G^2}{2} \\le E_{\\mathrm{cut}}$ 的 $G$。在此基组中，构建三个厄米矩阵：\n  1. $H_{\\mathrm{loc}} = T + V_{\\mathrm{loc}}$（无非局域投影算符）。\n  2. $H_{A} = T + V_{\\mathrm{loc}} + V_{\\mathrm{nl}}^{(A)}$，用于“构造A”，该构造使用一个已知容易产生鬼态的吸引性偶宇称投影算符集。\n  3. $H_{B} = T + V_{\\mathrm{loc}} + V_{\\mathrm{nl}}^{(B)}$，用于“构造B”，该构造模拟了局域通道和投影算符构造的改变：保持偶宇称通道为局域，并将非局域权重置于奇宇称（排斥性）投影算符中，从而最小化与偶宇称基态的耦合，以此消除鬼态，同时保持偶宇称（价电子）通道的可移植性。\n\n鬼态检测与可移植性度量：\n- 将有限超胞/基组中的束缚态数量定义为哈密顿量严格小于 $0$ 的本征值的数量。令 $N_{-}(H)$ 表示此数量。\n- 当 $N_{-}(H_{A})  N_{-}(H_{\\mathrm{loc}})$ 时，即当可分离非局域构造产生了至少一个局域参考中不存在的额外负能态时，操作上检测到一个“鬼态”。\n- 如果 $N_{-}(H_{B}) = N_{-}(H_{\\mathrm{loc}})$，则实现了消除。\n- 为了量化“保持可移植性”，比较 $H_{B}$ 和 $H_{\\mathrm{loc}}$ 的最低束缚态能量（最负的本征值）。令 $E_0(H)$ 为 $H$ 的最小本征值。如果 $\\lvert E_0(H_{B}) - E_0(H_{\\mathrm{loc}}) \\rvert \\le \\varepsilon$，则认为可移植性得以保持，其中容差 $\\varepsilon = 10^{-4}$ 哈特里。如果 $N_{-}(H_{\\mathrm{loc}}) = 0$，则跳过此可移植性检查，并为下面的逻辑测试目的默认其为满足。\n\n每个测试用例需计算的最终结果：\n- 对于每个测试用例，返回一个布尔值，定义为\n  $$\\mathrm{Result} = \\big(N_{-}(H_{A})  N_{-}(H_{\\mathrm{loc}})\\big)\\ \\wedge\\ \\big(N_{-}(H_{B}) = N_{-}(H_{\\mathrm{loc}})\\big)\\ \\wedge\\ \\Big(N_{-}(H_{\\mathrm{loc}})=0 \\ \\vee\\ \\lvert E_0(H_{B}) - E_0(H_{\\mathrm{loc}}) \\rvert \\le \\varepsilon\\Big).$$\n\n测试套件（所有能量单位为哈特里，长度单位为玻尔）：\n- 案例1（理想路径；A中存在明显鬼态；B中鬼态被消除；可移植性得以保持）：\n  - $L = 40.0$, $E_{\\mathrm{cut}} = 0.8$, $V_0 = -0.20$, $a = 1.0$,\n  - 构造A（偶宇称投影算符）：$N_p=2$，宽度 $b = [0.6, 0.3]$，耦合 $D = [-100.0, -50.0]$，\n  - 构造B（奇宇称投影算符）：$N_p=2$，宽度 $b = [0.6, 0.3]$，耦合 $D = [20.0, 10.0]$。\n- 案例2（基组受限的边界情况；A中仍显示鬼态，B中被消除）：\n  - $L = 40.0$, $E_{\\mathrm{cut}} = 0.3$, $V_0 = -0.20$, $a = 1.0$,\n  - 构造A（偶宇称）：$b = [0.6, 0.3]$，$D = [-80.0, -40.0]$，\n  - 构造B（奇宇称）：$b = [0.6, 0.3]$，$D = [15.0, 7.0]$。\n- 案例3（无问题的非局域吸引；无鬼态需要消除）：\n  - $L = 40.0$, $E_{\\mathrm{cut}} = 0.8$, $V_0 = -0.05$, $a = 1.0$,\n  - 构造A（偶宇称）：$b = [0.6, 0.3]$，$D = [0.0, 0.0]$，\n  - 构造B（奇宇称）：$b = [0.6, 0.3]$，$D = [2.0, 1.0]$。\n\n实现要求：\n- 直接根据上述定义计算矩阵元。对于高斯局域势和高斯（乘以-$x$）投影算符，使用精确的全线傅里叶积分：\n  - $\\int_{-\\infty}^{\\infty} e^{-(x/a)^2} e^{-i q x}\\, dx = \\sqrt{\\pi}\\, a \\, e^{-(q a/2)^2}$,\n  - $\\int_{-\\infty}^{\\infty} e^{-(x/b)^2} e^{-i G x}\\, dx = \\sqrt{\\pi}\\, b \\, e^{-(G b/2)^2}$,\n  - $\\int_{-\\infty}^{\\infty} x\\, e^{-(x/b)^2} e^{-i G x}\\, dx = i \\sqrt{\\pi}\\, b \\left(- \\frac{G b^2}{2}\\right) e^{-(G b/2)^2}$。\n  一致地对每个 $\\langle G \\vert \\beta \\rangle$ 应用平面波归一化因子 $L^{-1/2}$，对 $V^{\\mathrm{loc}}_{G,G'}$ 应用 $L^{-1}$。\n- 对每个测试用例，对角化三个厄米矩阵 $H_{\\mathrm{loc}}$, $H_A$ 和 $H_B$。\n- 计算每个哈密顿量的负本征值数量，并按定义评估布尔结果。\n- 所有计算必须在哈特里和玻尔单位下进行。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3]$，其中每个 $\\mathrm{result}_i$ 是 True 或 False（作为布尔字面量）。\n\n您的程序必须是完整的，并能按规定在没有任何外部输入的情况下运行。", "solution": "该问题要求实现一个一维平面波模拟，以研究赝势中的鬼态现象及其消除方法。这是一个基于计算量子力学原理的有效且定义明确的问题。解决方案通过在平面波基组中构建周期性系统的哈密顿量，对其进行对角化以找到其能谱，并根据指定标准分析结果。\n\n整个过程分为四个主要阶段：\n$1$. 构建平面波基组。\n$2$. 构建动能、局域势和非局域势算符的矩阵元。\n$3$. 组装并对角化三个指定的哈密顿量：$H_{\\mathrm{loc}}$、$H_{A}$ 和 $H_{B}$。\n$4$. 基于束缚态数量和能量可移植性评估结果。\n\n**$1$. 基组构建**\n\n量子系统被限制在一个长度为 $L$ 的一维超胞中，并具有周期性边界条件。单粒子波函数在平面波基组中展开，这些平面波是动量算符的本征函数。一个平面波 $\\lvert G \\rangle$ 的实空间表示为 $\\langle x \\lvert G \\rangle = L^{-1/2} \\exp(i G x)$，其中波矢 $G$ 必须与超胞的周期性相容，即 $G = 2\\pi n / L$，其中 $n$ 为整数。\n\n无限的平面波集合通过一个动能截断值 $E_{\\mathrm{cut}}$ 进行截断。只有动能 $\\frac{G^2}{2}$ 小于或等于此截断值的平面波才被保留在基组中。这个条件表示为：\n$$\n\\frac{1}{2} \\left( \\frac{2\\pi n}{L} \\right)^2 \\le E_{\\mathrm{cut}} \\implies |n| \\le \\frac{L \\sqrt{2 E_{\\mathrm{cut}}}}{2\\pi}\n$$\n因此，定义基组的整数集合为 $n \\in \\{-n_{\\mathrm{max}}, \\dots, n_{\\mathrm{max}}\\}$，其中 $n_{\\mathrm{max}} = \\lfloor L\\sqrt{2E_{\\mathrm{cut}}} / (2\\pi) \\rfloor$。基函数的总数为 $N_G = 2n_{\\mathrm{max}} + 1$。\n\n**$2$. 哈密顿量矩阵元**\n\n总哈密顿量为 $H = T + V_{\\mathrm{loc}} + V_{\\mathrm{nl}}$。其矩阵表示在截断的平面波基组 $\\{\\lvert G_k \\rangle\\}_{k=1}^{N_G}$ 中构建。\n\n**动能算符 ($T$):**\n动能算符 $T = -\\frac{1}{2}\\frac{d^2}{dx^2}$ 在平面波基组中是对角的，因为平面波是它的本征函数：$T \\lvert G \\rangle = \\frac{G^2}{2} \\lvert G \\rangle$。因此，矩阵元为：\n$$\nT_{G,G'} = \\langle G \\vert T \\vert G' \\rangle = \\frac{{G'}^2}{2} \\langle G \\vert G' \\rangle = \\frac{G^2}{2} \\delta_{G,G'}\n$$\n\n**局域势算符 ($V_{\\mathrm{loc}}$):**\n局域势是一个高斯函数，$V_{\\mathrm{loc}}(x) = V_0 \\exp[-(x/a)^2]$。其矩阵元由势的傅里叶分量给出。对于大超胞 ($L \\gg a$)，这可以很好地通过在无限域上的连续傅里叶变换来近似：\n$$\nV^{\\mathrm{loc}}_{G,G'} = \\frac{1}{L} \\int_{-L/2}^{L/2} V_{\\mathrm{loc}}(x) e^{-i(G-G')x} dx \\approx \\frac{1}{L} \\int_{-\\infty}^{\\infty} V_{\\mathrm{loc}}(x) e^{-iqx} dx\n$$\n其中 $q = G-G'$。使用为高斯函数提供的积分公式 $\\int_{-\\infty}^{\\infty} e^{-(x/a)^2} e^{-iqx} dx = \\sqrt{\\pi}\\, a \\, e^{-(qa/2)^2}$，我们得到：\n$$\nV^{\\mathrm{loc}}_{G,G'} = \\frac{V_0 \\sqrt{\\pi} a}{L} \\exp\\left[-\\left(\\frac{(G-G')a}{2}\\right)^2\\right]\n$$\n该矩阵是一个实对称的托普利兹矩阵。\n\n**非局域赝势算符 ($V_{\\mathrm{nl}}$):**\n非局域部分以可分离的 Kleinman-Bylander 形式给出，$V_{\\mathrm{nl}} = \\sum_{i=1}^{N_p} D_i \\lvert \\beta_i \\rangle \\langle \\beta_i \\rvert$。其矩阵元为：\n$$\n\\left(V_{\\mathrm{nl}}\\right)_{G,G'} = \\langle G \\vert V_{\\mathrm{nl}} \\vert G' \\rangle = \\sum_{i=1}^{N_p} D_i \\langle G \\vert \\beta_i \\rangle \\langle \\beta_i \\vert G' \\rangle\n$$\n项 $\\langle G \\vert \\beta_i \\rangle$ 是投影函数 $\\beta_i(x)$ 的平面波分量，计算方式为 $\\langle G \\vert \\beta_i \\rangle = L^{-1/2} \\int_{-\\infty}^{\\infty} \\beta_i(x) e^{-iGx} dx$。\n\n对于**偶宇称投影算符**，$\\beta^{(\\mathrm{even})}_b(x) = \\exp[-(x/b)^2]$，其分量是实数：\n$$\n\\langle G \\vert \\beta^{(\\mathrm{even})}_b \\rangle = \\frac{1}{\\sqrt{L}} \\int_{-\\infty}^{\\infty} e^{-(x/b)^2} e^{-iGx} dx = \\frac{\\sqrt{\\pi} b}{\\sqrt{L}} \\exp\\left[-\\left(\\frac{Gb}{2}\\right)^2\\right]\n$$\n对于**奇宇称投影算符**，$\\beta^{(\\mathrm{odd})}_b(x) = x \\exp[-(x/b)^2]$，其分量是纯虚数：\n$$\n\\langle G \\vert \\beta^{(\\mathrm{odd})}_b \\rangle = \\frac{1}{\\sqrt{L}} \\int_{-\\infty}^{\\infty} x e^{-(x/b)^2} e^{-iGx} dx = \\frac{i}{\\sqrt{L}} \\left( \\sqrt{\\pi} b \\left( -\\frac{Gb^2}{2} \\right) \\exp\\left[-\\left(\\frac{Gb}{2}\\right)^2\\right] \\right)\n$$\n我们记 $\\langle G \\vert \\beta_i \\rangle = \\tilde{\\beta}_i(G)$。对于奇宇称投影算符，非局域矩阵为 $(V_{\\mathrm{nl}})_{G,G'} = D_i \\tilde{\\beta}_i(G) \\tilde{\\beta}_i(G')^*$。由于 $\\tilde{\\beta}_i$ 是虚数，$\\tilde{\\beta}_i^* = - \\tilde{\\beta}_i$，因此乘积 $\\tilde{\\beta}_i(G) \\tilde{\\beta}_i(G')^*$ 变为实数。在所有情况下，得到的哈密顿矩阵都是实对称的。\n\n**$3$. 哈密顿量组装与对角化**\n\n构建并对角化三个不同的哈密顿量：\n$1$. $H_{\\mathrm{loc}} = T + V_{\\mathrm{loc}}$：仅包含局域势的参考哈密顿量。\n$2$. $H_{A} = H_{\\mathrm{loc}} + V_{\\mathrm{nl}}^{(A)}$：构造A，使用吸引性 ($D_i  0$) 的偶宇称投影算符。已知此构型容易产生非物理的、深度束缚的“鬼”态。\n$3$. $H_{B} = H_{\\mathrm{loc}} + V_{\\mathrm{nl}}^{(B)}$：构造B，使用排斥性 ($D_i  0$) 的奇宇称投影算符。这种设计避免了与偶宇称基态的强耦合，从而防止了鬼态的产生，同时旨在保持价电子态的物理性质（可移植性）。\n\n这些 $N_G \\times N_G$ 的厄米矩阵使用标准的数值本征求解器进行对角化，以获得它们的本征值，这些本征值对应于系统的能级。\n\n**$4$. 分析与最终评估**\n\n分析过程遵循问题陈述中指定的规则。\n首先，我们计算每个哈密顿量的负本征值数量 $N_{-}(H)$。这些代表了系统的束缚态。\n- 如果构造A引入了比局域参考更多的新束缚态，即 $N_{-}(H_A)  N_{-}(H_{\\mathrm{loc}})$，则检测到一个**鬼态**。\n- 如果构造B产生的束缚态数量与参考相同，即 $N_{-}(H_B) = N_{-}(H_{\\mathrm{loc}})$，则鬼态被**消除**。\n- **可移植性**是衡量基本物理性质（例如基态能量）保持得有多好的一种度量。如果基态能量在容差 $\\varepsilon = 10^{-4}$ Ha 范围内保持不变，即 $|E_0(H_B) - E_0(H_{\\mathrm{loc}})| \\le \\varepsilon$，则认为可移植性得以保持。这里，$E_0(H)$ 是哈密顿量 $H$ 的最低本征值。如果参考哈密顿量 $H_{\\mathrm{loc}}$ 没有束缚态（即 $N_{-}(H_{\\mathrm{loc}})=0$），则跳过此检查。\n\n对于每个测试用例，最终的布尔结果通过这三个条件的逻辑与运算得出：\n$$\n\\mathrm{Result} = \\big(N_{-}(H_{A})  N_{-}(H_{\\mathrm{loc}})\\big)\\ \\wedge\\ \\big(N_{-}(H_{B}) = N_{-}(H_{\\mathrm{loc}})\\big)\\ \\wedge\\ \\Big(N_{-}(H_{\\mathrm{loc}})=0 \\ \\vee\\ \\lvert E_0(H_{B}) - E_0(H_{\\mathrm{loc}}) \\rvert \\le \\varepsilon\\Big)\n$$\n该协议系统地验证了构造 A 是否表现出鬼态病理，以及构造 B 是否在保持物理精度的同时成功地修正了它。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 40.0, \"E_cut\": 0.8, \"V0\": -0.20, \"a\": 1.0,\n            \"A\": {\"type\": \"even\", \"b\": [0.6, 0.3], \"D\": [-100.0, -50.0]},\n            \"B\": {\"type\": \"odd\", \"b\": [0.6, 0.3], \"D\": [20.0, 10.0]},\n        },\n        {\n            \"L\": 40.0, \"E_cut\": 0.3, \"V0\": -0.20, \"a\": 1.0,\n            \"A\": {\"type\": \"even\", \"b\": [0.6, 0.3], \"D\": [-80.0, -40.0]},\n            \"B\": {\"type\": \"odd\", \"b\": [0.6, 0.3], \"D\": [15.0, 7.0]},\n        },\n        {\n            \"L\": 40.0, \"E_cut\": 0.8, \"V0\": -0.05, \"a\": 1.0,\n            \"A\": {\"type\": \"even\", \"b\": [0.6, 0.3], \"D\": [0.0, 0.0]},\n            \"B\": {\"type\": \"odd\", \"b\": [0.6, 0.3], \"D\": [2.0, 1.0]},\n        },\n    ]\n\n    epsilon = 1e-4\n    results = []\n\n    for case in test_cases:\n        result = evaluate_case(\n            case[\"L\"], case[\"E_cut\"], case[\"V0\"], case[\"a\"],\n            case[\"A\"], case[\"B\"], epsilon\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef evaluate_case(L, E_cut, V0, a, proj_A_params, proj_B_params, epsilon):\n    \"\"\"\n    Performs the plane-wave simulation for a single test case.\n    \"\"\"\n    # 1. Basis Set Construction\n    # Determine the maximum integer n for the G-vectors based on E_cut\n    n_max = int(np.floor(L * np.sqrt(2 * E_cut) / (2 * np.pi)))\n    G_vec = (2 * np.pi / L) * np.arange(-n_max, n_max + 1)\n    N_G = len(G_vec)\n\n    # 2. Kinetic Energy Matrix (T)\n    T_mat = 0.5 * np.diag(G_vec**2)\n\n    # 3. Local Potential Matrix (V_loc)\n    # G-G' matrix\n    q_mat = G_vec[:, None] - G_vec[None, :]\n    V_loc_mat = (V0 / L) * np.sqrt(np.pi) * a * np.exp(-((q_mat * a / 2.0)**2))\n\n    # 4. Nonlocal Potential Matrices (V_nl)\n    # Construction A\n    V_nl_A = np.zeros((N_G, N_G), dtype=float)\n    b_vals_A, D_vals_A = proj_A_params[\"b\"], proj_A_params[\"D\"]\n    for b, D in zip(b_vals_A, D_vals_A):\n        # Even projector: beta_G = L^{-1/2} * sqrt(pi)*b * exp(-(Gb/2)^2)\n        beta_G_vec_even = (np.sqrt(np.pi) * b / np.sqrt(L)) * \\\n                          np.exp(-((G_vec * b / 2.0)**2))\n        V_nl_A += D * np.outer(beta_G_vec_even, beta_G_vec_even)\n    \n    # Construction B\n    V_nl_B = np.zeros((N_G, N_G), dtype=float)\n    b_vals_B, D_vals_B = proj_B_params[\"b\"], proj_B_params[\"D\"]\n    for b, D in zip(b_vals_B, D_vals_B):\n        # Odd projector: beta_G = i * f(G), where f(G) is real.\n        # The matrix becomes D * f(G_i) * f(G_j)\n        f_G_vec_odd = (np.sqrt(np.pi) * b / np.sqrt(L)) * \\\n                      (-G_vec * b**2 / 2.0) * \\\n                      np.exp(-((G_vec * b / 2.0)**2))\n        V_nl_B += D * np.outer(f_G_vec_odd, f_G_vec_odd)\n\n    # 5. Assemble Hamiltonians\n    H_loc = T_mat + V_loc_mat\n    H_A = H_loc + V_nl_A\n    H_B = H_loc + V_nl_B\n\n    # 6. Diagonalize Matrices to find eigenvalues\n    eigvals_loc = eigh(H_loc, eigvals_only=True)\n    eigvals_A = eigh(H_A, eigvals_only=True)\n    eigvals_B = eigh(H_B, eigvals_only=True)\n\n    # 7. Analyze eigenvalues and compute final boolean result\n    # Count negative eigenvalues (bound states)\n    N_neg_loc = np.sum(eigvals_loc  0)\n    N_neg_A = np.sum(eigvals_A  0)\n    N_neg_B = np.sum(eigvals_B  0)\n\n    # Condition 1: Ghost state detected in Construction A\n    cond1_ghost_detected = N_neg_A  N_neg_loc\n\n    # Condition 2: Ghost state eliminated in Construction B\n    cond2_ghost_eliminated = N_neg_B == N_neg_loc\n\n    # Condition 3: Transferability is retained\n    cond3_transferability = False\n    if N_neg_loc == 0:\n        cond3_transferability = True\n    else:\n        # Check energy difference only if there are bound states in reference\n        E0_loc = np.min(eigvals_loc)\n        E0_B = np.min(eigvals_B)\n        if abs(E0_B - E0_loc) = epsilon:\n            cond3_transferability = True\n            \n    final_result = cond1_ghost_detected and cond2_ghost_eliminated and cond3_transferability\n    return final_result\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2915027"}]}