{"hands_on_practices": [{"introduction": "在深入研究复杂的隧穿路径之前，我们首先分析最简单的瞬子类型：在势垒顶部的周期轨道。这个练习将揭示势垒曲率（由频率 $\\omega_b$ 表征）与虚时周期轨道（或称“瞬子”）周期之间的基本关系。通过求解在抛物线势垒顶部的欧几里得运动方程，我们可以为更高级的瞬子理论建立一个坚实的概念基础 [@problem_id:2898615]。", "problem": "考虑一个质量为 $m$ 的一维反应坐标在势垒中运动，该势垒在其最大值 $x^{\\ddagger}$ 附近被二次型 $V(x)\\approx V^{\\ddagger}-\\tfrac{1}{2}m\\omega_{b}^{2}\\left(x-x^{\\ddagger}\\right)^{2}$ 局域近似，其中 $\\omega_{b}0$ 是垒顶曲率频率。在适用于热激活隧穿的半经典瞬子理论的虚时（欧几里得）表述中，欧几里得作用量为 $S_{E}[x]=\\int \\mathrm{d}\\tau\\,\\left(\\tfrac{m}{2}\\dot{x}^{2}+V(x)\\right)$，相应的欧拉-拉格朗日方程为 $m\\,\\ddot{x}=\\partial V/\\partial x$，其中上方的点表示对虚时 $\\tau$ 的导数。假设运动为限制在垒顶谐振区域内的小振幅运动，并施加代表有限温度路径的周期性边界条件 $x(\\tau+\\beta\\hbar)=x(\\tau)$，其中 $\\beta=\\left(k_{B}T\\right)^{-1}$。\n\n仅从这些基本定义出发，推导位移坐标 $y(\\tau)=x(\\tau)-x^{\\ddagger}$下的欧几里得运动方程，求解该方程以获得瞬子轨迹 $x(\\tau)$ 的闭合形式解（该解可包含任意振幅和相位），并确定其基元周期 $T_{b}$（解的最小正周期）。明确陈述将非平凡解与虚时间隔 $\\beta\\hbar$ 联系起来的周期性条件，并用 $\\omega_{b}$ 表示基元周期。\n\n只报告基元周期 $T_{b}$ 作为最终答案。将其表示为 $\\omega_{b}$ 的符号函数。在最终的方框答案中不要包含单位。", "solution": "问题陈述是有效的。这是一个关于虚时中周期轨道的半经典速率理论中的标准适定问题。我们将按要求进行推导。\n\n出发点是给定的在势垒最大值 $x^{\\ddagger}$ 附近的势能面：\n$$\nV(x) \\approx V^{\\ddagger} - \\frac{1}{2}m\\omega_{b}^{2}(x - x^{\\ddagger})^{2}\n$$\n问题陈述指出，欧几里得运动方程为 $m\\ddot{x} = \\partial V/\\partial x$，其中上方的点表示对虚时 $\\tau$ 的导数。\n\n首先，我们计算力项 $\\partial V/\\partial x$。势能对坐标 $x$ 的导数为：\n$$\n\\frac{\\partial V}{\\partial x} = \\frac{\\partial}{\\partial x} \\left[ V^{\\ddagger} - \\frac{1}{2}m\\omega_{b}^{2}(x - x^{\\ddagger})^{2} \\right]\n$$\n常数项 $V^{\\ddagger}$ 在求导后消失。对二次项应用链式法则得到：\n$$\n\\frac{\\partial V}{\\partial x} = - \\frac{1}{2}m\\omega_{b}^{2} \\cdot 2(x - x^{\\ddagger}) \\cdot \\frac{\\partial}{\\partial x}(x - x^{\\ddagger}) = -m\\omega_{b}^{2}(x - x^{\\ddagger})\n$$\n将此结果代入运动方程得到：\n$$\nm\\ddot{x} = -m\\omega_{b}^{2}(x - x^{\\ddagger})\n$$\n根据题目要求，我们使用位移坐标 $y(\\tau) = x(\\tau) - x^{\\ddagger}$。由于 $x^{\\ddagger}$ 是一个常数，$y(\\tau)$ 对 $\\tau$ 的导数是 $\\dot{y} = \\dot{x}$ 和 $\\ddot{y} = \\ddot{x}$。通过代换，运动方程可以重写为以 $y(\\tau)$ 表示的形式：\n$$\nm\\ddot{y} = -m\\omega_{b}^{2}y\n$$\n两边除以质量 $m$（非零），将方程简化为：\n$$\n\\ddot{y}(\\tau) + \\omega_{b}^{2}y(\\tau) = 0\n$$\n这是简谐振子的标准二阶线性常微分方程。其物理解释是，在虚时中穿越势垒的运动等效于在反转势阱 $-V(x)$ 中的振荡运动。\n\n该方程的通解是一个正弦函数。写成振幅-相位形式为：\n$$\ny(\\tau) = A \\cos(\\omega_{b}\\tau + \\phi)\n$$\n其中 $A$ 是振幅，$\\phi$ 是相位常数。这是两个任意的积分常数。\n\n因此，在原始坐标系中的轨迹 $x(\\tau)$（它代表了垒顶的周期轨道或“瞬子”）为：\n$$\nx(\\tau) = x^{\\ddagger} + y(\\tau) = x^{\\ddagger} + A \\cos(\\omega_{b}\\tau + \\phi)\n$$\n问题要求确定此解的*基元周期* $T_{b}$。基元周期是使 $x(\\tau + T) = x(\\tau)$ 对所有 $\\tau$ 成立的最小正值 $T$。这个条件等价于 $y(\\tau + T) = y(\\tau)$。对于函数 $y(\\tau) = A \\cos(\\omega_{b}\\tau + \\phi)$，在一个周期内，余弦函数的自变量必须改变 $2\\pi$ 的整数倍。对于最小周期 $T_{b}$，这个变化必须恰好是 $2\\pi$：\n$$\n\\omega_{b}(\\tau + T_{b}) + \\phi = (\\omega_{b}\\tau + \\phi) + 2\\pi k\n$$\n其中 $k$ 是整数。对于最小正周期， $k=1$。\n$$\n\\omega_{b}T_{b} = 2\\pi\n$$\n解出基元周期 $T_{b}$ 得到：\n$$\nT_{b} = \\frac{2\\pi}{\\omega_{b}}\n$$\n这个周期是势垒的内禀属性，仅由其曲率频率 $\\omega_{b}$ 决定。\n\n问题还提到了边界条件 $x(\\tau + \\beta\\hbar) = x(\\tau)$，该条件出现在热速率的量子统计力学表述中。要使一个满足此周期性的非平凡解（$A \\neq 0$）在虚时间隔 $\\tau=0$ 到 $\\tau=\\beta\\hbar$ 上存在，这个区间的长度必须是基元周期 $T_{b}$ 的整数倍。因此，周期性条件是：\n$$\n\\beta\\hbar = n T_{b} = n \\frac{2\\pi}{\\omega_{b}}\n$$\n其中 $n$ 是一个正整数，$n \\in \\{1, 2, 3, \\dots\\}$。在给定温度 $T$（由 $\\beta = (k_B T)^{-1}$ 指定）下，只有当这个条件能被满足时，这样的周期解才存在。然而，问题只要求基元周期 $T_{b}$ 本身，它与温度无关。\n\n最终结果按要求仅依赖于 $\\omega_{b}$。", "answer": "$$\\boxed{\\frac{2\\pi}{\\omega_{b}}}$$", "id": "2898615"}, {"introduction": "真实的化学反应势能面远比简单的抛物线模型复杂，因此解析解通常是不可行的。为了处理任意势能面，我们必须采用数值方法。本练习将指导您实现环状聚合物瞬子（Ring-Polymer Instanton, RPI）方法，通过将欧几里得作用量离散化，并使用牛顿-拉夫逊（Newton-Raphson）算法来寻找瞬子路径，即最小作用量路径。这是计算化学中计算量子速率理论的一项核心计算技能 [@problem_id:2898586]。", "problem": "要求您实现一个完整的程序，该程序为在虚时间中离散为 $P$ 个珠子的一维路径构建欧几里得作用量的有限差分格点化，在周期性边界条件下建立珠子坐标的非线性定态条件，并使用牛顿-拉夫逊方法求解它们。该程序必须能够处理固定珠子约束，以强制穿越势垒，从而稳定一个非平凡的类瞬子路径。所有量都应以原子单位表示，其中约化普朗克常数 $\\hbar$ 等于 $1$，质量以电子质量为单位，能量以哈特里（Hartree）为单位。\n\n从一维坐标 $x(\\tau)$ 在区间 $\\tau \\in [0, \\beta \\hbar]$ 上满足周期性边界条件 $x(0) = x(\\beta \\hbar)$ 的虚时间定态作用量原理出发，其中 $\\beta$ 是逆温度。使用包含 $P$ 个珠子的均匀网格，时间步长为 $\\Delta \\tau = \\beta \\hbar / P$，并将离散欧几里得作用量定义为给定势 $V(x)$ 的虚时间作用量泛函的一致有限差分近似。以此为基础，推导表示周期性边界条件下珠子坐标的离散定态条件的非线性系统。然后，建立一个牛顿-拉夫逊迭代来求解该系统，该系统带有可选的固定珠子约束，将指定的珠子索引固定在指定的值上，从而将未知数减少到自由珠子。\n\n您的程序必须实现：\n- 一个通用例程，用于在给定一组珠子坐标 $\\{x_k\\}_{k=1}^P$、质量 $m$、逆温度 $\\beta$ 和势 $V(x)$ 的情况下，计算环上的离散欧几里得作用量 $S_{\\mathrm{E}}[\\{x_k\\}]$。\n- 一个通用例程，用于组装在周期性边界条件下，自由珠子的离散欧几里得作用量定态条件的非线性残差向量 $\\mathbf{F}(\\mathbf{x})$ 和雅可比矩阵 $\\mathbf{J}(\\mathbf{x})$，同时将固定珠子视为参数。\n- 一个带有回溯线搜索的牛顿-拉夫逊求解器，用于减小残差的范数，并在残差范数的停止容差内收敛到解。\n- 三个测试用例，每个都在下面完全指定，生成一个单行输出，汇总所有用例所请求的量。对于所有用例，使用原子单位并设置 $\\hbar = 1$。\n\n要使用的势：\n- 谐振子势：$V(x) = \\frac{1}{2} k x^2$，其梯度 $V'(x)$ 和海森矩阵 $V''(x)$ 与此定义一致。\n- 对称双势阱：$V(x) = a (x^2 - b^2)^2$，其梯度 $V'(x)$ 和海森矩阵 $V''(x)$ 与此定义一致。\n\n数值要求：\n- 在由 $P$ 个珠子组成的环上使用周期性边界条件。\n- 允许将一组珠子索引 $\\mathcal{I}_{\\mathrm{fixed}} \\subset \\{0,1,\\dots,P-1\\}$ 固定在指定值上，所有其他珠子都作为自由变量处理。残差方程仅对自由珠子强制执行。在构建最近邻耦合时，酌情使用固定值。\n- 使用带有回溯线搜索的牛顿-拉夫逊迭代来稳健地减小残差范数。当残差的欧几里得范数低于 $10^{-10}$ 或达到最大迭代次数 $100$ 次时停止。如果未达到收敛，则返回找到的最佳迭代结果。\n\n测试套件：\n- 用例 1（谐振子，平凡定态路径）：$P = 32$，$\\beta = 6$，$m = 1$，谐振子刚度 $k = 1$。将珠子索引 $0$ 固定在 $x=0$。将所有珠子初始化在 $x=0$。报告收敛路径上 $\\exp(-S_{\\mathrm{E}})$ 的值，以浮点数形式表示（由于 $\\hbar=1$，该值无量纲）。\n- 用例 2（中等逆温度下的双势阱，强制穿越）：$P = 64$，$\\beta = 6$，$m = 1$，双势阱参数 $a = 1$，$b = 1$。将珠子索引 $0$ 固定在 $x=+1$，珠子索引 $P/2$ 固定在 $x=-1$。通过在两个固定珠子之间的两个环段上进行线性插值来初始化其余珠子，以创建一条平滑的周期性路径。报告收敛路径上 $\\exp(-S_{\\mathrm{E}})$ 的值，以浮点数形式表示（无量纲）。\n- 用例 3（较低温度下的双势阱，强制穿越）：$P = 128$，$\\beta = 10$，$m = 1$，双势阱参数 $a = 1$，$b = 1$。将珠子索引 $0$ 固定在 $x=+1$，珠子索引 $P/2$ 固定在 $x=-1$。按用例 2 中的方式进行初始化。报告收敛路径上 $\\exp(-S_{\\mathrm{E}})$ 的值，以浮点数形式表示（无量纲）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个结果，按用例 1、2 和 3 的顺序列在方括号内，以逗号分隔。例如：`[r1,r2,r3]`。\n- 每个元素必须是浮点数。\n\n角度单位不适用。不应打印任何物理单位，因为所请求的输出是在原子单位下作用量的无量纲指数。", "solution": "所提出的问题陈述是有效的。这是一个来自计算量子化学领域的、定义明确且有科学依据的问题，具体涉及使用虚时间路径积分形式主义对瞬子路径进行数值计算。所有必要的参数、物理模型和数值要求都已明确提供。我将继续进行推导和求解。\n\n该问题的基础在于量子统计力学的路径积分表述。对于一个哈密顿量为 $\\hat{H}$、逆温度为 $\\beta = 1/(k_B T)$ 的系统，其配分函数 $Z$ 由 $Z = \\mathrm{Tr}[e^{-\\beta \\hat{H}}]$ 给出。这可以表示为在虚时间 $\\tau \\in [0, \\beta\\hbar]$ 内对所有可能的闭合路径 $x(\\tau)$ 的费曼路径积分，其中 $x(0) = x(\\beta\\hbar)$。我们在原子单位下操作，其中约化普朗克常数 $\\hbar = 1$。配分函数则为：\n$$\nZ = \\int \\mathcal{D}x(\\tau) \\, e^{-S_{\\mathrm{E}}[x(\\tau)]}\n$$\n其中 $S_{\\mathrm{E}}[x(\\tau)]$ 是质量为 $m$ 的粒子在势 $V(x)$ 中的欧几里得作用量泛函：\n$$\nS_{\\mathrm{E}}[x(\\tau)] = \\int_0^{\\beta} \\left[ \\frac{1}{2}m \\left(\\frac{dx}{d\\tau}\\right)^2 + V(x(\\tau)) \\right] d\\tau\n$$\n为了进行数值计算，我们将虚时间区间 $[0, \\beta]$ 离散为 $P$ 个时间片，或称“珠子”，每个时间片的持续时间为 $\\Delta\\tau = \\beta/P$。路径 $x(\\tau)$ 由一组坐标 $\\{x_k\\}_{k=0}^{P-1}$ 表示，其中 $x_k = x(k\\Delta\\tau)$。导数通过有限差分近似为 $\\frac{dx}{d\\tau} \\approx \\frac{x_{k+1}-x_k}{\\Delta\\tau}$，积分变为求和。在周期性边界条件 $x_P = x_0$ 下，离散欧几里得作用量为：\n$$\nS_{\\mathrm{E}}[\\{x_k\\}] = \\sum_{k=0}^{P-1} \\left[ \\frac{1}{2}m \\left(\\frac{x_{k+1} - x_k}{\\Delta\\tau}\\right)^2 \\Delta\\tau + V(x_k) \\Delta\\tau \\right] = \\sum_{k=0}^{P-1} \\left[ \\frac{mP}{2\\beta}(x_{k+1}-x_k)^2 + \\frac{\\beta}{P}V(x_k) \\right]\n$$\n定态路径，例如瞬子，对应于作用量的极值点。我们通过求解作用量对每个珠子坐标的偏导数为零的方程组来找到这样的路径：$\\frac{\\partial S_{\\mathrm{E}}}{\\partial x_j} = 0$。这对每个珠子 $j$ 定义了残差向量分量 $F_j$：\n$$\nF_j(\\mathbf{x}) \\equiv \\frac{\\partial S_{\\mathrm{E}}}{\\partial x_j} = \\frac{\\partial}{\\partial x_j} \\left( \\sum_{k=0}^{P-1} \\left[ \\frac{mP}{2\\beta}(x_{k+1}-x_k)^2 + \\frac{\\beta}{P}V(x_k) \\right] \\right)\n$$\n坐标 $x_j$ 出现在索引为 $k=j$ 和 $k=j-1$ 的动能项中，以及索引为 $k=j$ 的势能项中。进行微分可得：\n$$\nF_j(\\mathbf{x}) = \\frac{mP}{\\beta}(2x_j - x_{j-1} - x_{j+1}) + \\frac{\\beta}{P} V'(x_j) = 0\n$$\n其中索引按模 $P$ 计算以强制周期性（例如，对于 $j=0$，$x_{j-1} = x_{P-1}$）。这是一个关于坐标 $\\mathbf{x} = \\{x_0, \\dots, x_{P-1}\\}$ 的包含 $P$ 个耦合非线性方程的系统。\n\n为求解系统 $\\mathbf{F}(\\mathbf{x}) = 0$，我们采用牛顿-拉夫逊方法。这种迭代方法通过求解线性系统以获得修正量 $\\Delta\\mathbf{x}$ 来改进估计值 $\\mathbf{x}^{(n)}$：\n$$\n\\mathbf{J}(\\mathbf{x}^{(n)}) \\Delta\\mathbf{x} = -\\mathbf{F}(\\mathbf{x}^{(n)})\n$$\n下一个估计值为 $\\mathbf{x}^{(n+1)} = \\mathbf{x}^{(n)} + \\alpha \\Delta\\mathbf{x}$，其中 $\\alpha \\in (0, 1]$ 是通过线搜索确定的步长。矩阵 $\\mathbf{J}$ 是 $\\mathbf{F}$ 的雅可比矩阵，其元素为 $J_{ij} = \\frac{\\partial F_i}{\\partial x_j}$，该矩阵也是作用量 $S_{\\mathrm{E}}$ 的海森矩阵。其元素为：\n- 对角元素 ($j=i$):\n  $$\n  J_{ii} = \\frac{\\partial F_i}{\\partial x_i} = \\frac{2mP}{\\beta} + \\frac{\\beta}{P}V''(x_i)\n  $$\n- 非对角最近邻元素 ($j=i\\pm1$，模 $P$):\n  $$\n  J_{i, i\\pm1} = \\frac{\\partial F_i}{\\partial x_{i\\pm1}} = -\\frac{mP}{\\beta}\n  $$\n- 所有其他元素均为零。雅可比矩阵是一个对称、稀疏且（在周期性边界下）类循环三对角矩阵。\n\n该问题要求处理固定的珠子。如果珠子的一个子集 $\\mathcal{I}_{\\mathrm{fixed}}$ 的位置被固定，它们就不再是变量。方程组仅对自由珠子 $\\mathcal{I}_{\\mathrm{free}}$ 求解。牛顿-拉夫逊系统的维度减少到 $N_{\\mathrm{free}} = |\\mathcal{I}_{\\mathrm{free}}|$。残差向量 $\\mathbf{F}_{\\mathrm{free}}$ 和雅可比矩阵 $\\mathbf{J}_{\\mathrm{free}}$ 仅根据 $\\mathcal{I}_{\\mathrm{free}}$ 中的索引构建。当计算自由珠子 $i$ 的残差 $F_i$ 时，如果其邻居 $i\\pm1$ 是固定的，则使用其固定的坐标值作为常数。类似地，在构建雅可比矩阵 $\\mathbf{J}_{\\mathrm{free}}$ 时，耦合项 $J_{i,j}$ 仅当 $i$ 和 $j$ 都是自由珠子且是最近邻时才非零。\n\n算法流程如下：\n1. 根据测试用例的规定，初始化所有 $P$ 个珠子坐标 $\\{x_k\\}$。\n2. 定义自由和固定珠子索引的集合。\n3. 开始牛顿-拉夫逊迭代：\n    a. 为当前自由珠子坐标构建残差向量 $\\mathbf{F}_{\\mathrm{free}}$ 和雅可比矩阵 $\\mathbf{J}_{\\mathrm{free}}$。\n    b. 检查残差的欧几里得范数 $\\|\\mathbf{F}_{\\mathrm{free}}\\|$。如果低于容差 $10^{-10}$，则解已收敛。\n    c. 求解线性系统 $\\mathbf{J}_{\\mathrm{free}} \\Delta\\mathbf{x}_{\\mathrm{free}} = -\\mathbf{F}_{\\mathrm{free}}$ 以找到更新步长。\n    d. 执行回溯线搜索以找到一个步长 $\\alpha \\in (0, 1]$，该步长能减小残差范数。从 $\\alpha=1$ 开始，测试更新 $\\mathbf{x}_{\\mathrm{free}}' = \\mathbf{x}_{\\mathrm{free}} + \\alpha \\Delta\\mathbf{x}_{\\mathrm{free}}$。如果 $\\|\\mathbf{F}_{\\mathrm{free}}(\\mathbf{x}_{\\mathrm{free}}')\\|  \\|\\mathbf{F}_{\\mathrm{free}}(\\mathbf{x}_{\\mathrm{free}})\\|$，则接受该步长。否则，将 $\\alpha$ 减小一个因子（例如，$2$）并重复。\n    e. 将接受的更新应用于自由珠子坐标。\n4. 收敛或达到最大迭代次数后，使用所有 $P$ 个珠子（包括自由和固定的）的最终坐标计算总欧几里得作用量 $S_{\\mathrm{E}}$。\n5. 最终报告的值为 $\\exp(-S_{\\mathrm{E}})$。\n\n指定的势及其导数为：\n- 谐振子势：$V(x) = \\frac{1}{2} k x^2$，$V'(x) = kx$，$V''(x) = k$。\n- 双势阱势：$V(x) = a (x^2 - b^2)^2$，$V'(x) = 4a(x^3 - b^2 x)$，$V''(x) = 4a(3x^2 - b^2)$。\n\n将实施这种结构化方法来解决这些测试用例。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for finding stationary paths of the Euclidean action.\n    \"\"\"\n\n    def get_potentials(name, params):\n        \"\"\"Returns functions for V, V', V'' for a given potential.\"\"\"\n        if name == 'harmonic':\n            k = params['k']\n            V = lambda x: 0.5 * k * x**2\n            V_prime = lambda x: k * x\n            V_double_prime = lambda x: k * np.ones_like(x)\n        elif name == 'double_well':\n            a, b = params['a'], params['b']\n            V = lambda x: a * (x**2 - b**2)**2\n            V_prime = lambda x: 4 * a * x * (x**2 - b**2)\n            V_double_prime = lambda x: 4 * a * (3 * x**2 - b**2)\n        else:\n            raise ValueError(f\"Unknown potential: {name}\")\n        return V, V_prime, V_double_prime\n\n    def calculate_action(x, m, beta, V):\n        \"\"\"Calculates the discrete Euclidean action.\"\"\"\n        P = len(x)\n        # Periodic boundary condition: x_P = x_0 handled by np.roll\n        kinetic_term = 0.5 * m * (P / beta)**2 * np.sum((x - np.roll(x, -1))**2)\n        potential_term = np.sum(V(x))\n        # Each term in the integral is weighted by d_tau = beta/P\n        return (beta / P) * (kinetic_term + potential_term)\n\n    def run_newton_raphson(x_init, m, beta, V, V_prime, V_double_prime, fixed_beads):\n        \"\"\"\n        Solves for the stationary path using Newton-Raphson with fixed bead constraints.\n        \n        Args:\n            x_init (np.ndarray): Initial coordinates of the P beads.\n            m (float): Mass.\n            beta (float): Inverse temperature.\n            V, V_prime, V_double_prime (callable): Potential and its derivatives.\n            fixed_beads (dict): A dictionary {index: value} for fixed beads.\n\n        Returns:\n            np.ndarray: Converged coordinates of the P beads.\n        \"\"\"\n        P = len(x_init)\n        x = np.copy(x_init)\n        \n        # Apply fixed bead values\n        for idx, val in fixed_beads.items():\n            x[idx] = val\n\n        is_free = np.ones(P, dtype=bool)\n        is_free[list(fixed_beads.keys())] = False\n        free_indices = np.where(is_free)[0]\n        n_free = len(free_indices)\n        \n        if n_free == 0:\n            return x\n\n        # Map global bead index to local index in the free-bead system\n        free_map = {global_idx: local_idx for local_idx, global_idx in enumerate(free_indices)}\n\n        max_iter = 100\n        tol = 1e-10\n        \n        kinetic_prefactor1 = m * P / beta\n        potential_prefactor = beta / P\n\n        for i in range(max_iter):\n            # 1. Assemble Residual F for free beads\n            F_free = np.zeros(n_free)\n            x_prev = np.roll(x, 1)\n            x_next = np.roll(x, -1)\n            \n            # Vectorized calculation for the residual\n            all_F = kinetic_prefactor1 * (2*x - x_prev - x_next) + potential_prefactor * V_prime(x)\n            F_free = all_F[free_indices]\n            \n            residual_norm = np.linalg.norm(F_free)\n            if residual_norm  tol:\n                break\n            \n            # 2. Assemble Jacobian J for free beads\n            J_free = np.zeros((n_free, n_free))\n            \n            # Diagonal elements\n            diag_vals = 2 * kinetic_prefactor1 + potential_prefactor * V_double_prime(x[free_indices])\n            np.fill_diagonal(J_free, diag_vals)\n            \n            # Off-diagonal elements\n            off_diag_val = -kinetic_prefactor1\n            for k, bead_idx in enumerate(free_indices):\n                # Neighbor k-1\n                neighbor_prev = (bead_idx - 1 + P) % P\n                if is_free[neighbor_prev]:\n                    local_prev_idx = free_map[neighbor_prev]\n                    J_free[k, local_prev_idx] += off_diag_val\n\n                # Neighbor k+1 (already handled by symmetry, but doing explicitly for clarity)\n                # We can exploit J being symmetric, but this is more direct.\n                neighbor_next = (bead_idx + 1) % P\n                if is_free[neighbor_next]:\n                    local_next_idx = free_map[neighbor_next]\n                    J_free[k, local_next_idx] += off_diag_val\n\n            # 3. Solve for the step\n            try:\n                delta_x_free = np.linalg.solve(J_free, -F_free)\n            except np.linalg.LinAlgError:\n                # If Jacobian is singular, we cannot proceed.\n                # This may happen for bad initial guesses.\n                # Here we just stop and return the current state.\n                break\n\n            # 4. Backtracking line search\n            alpha = 1.0\n            x_new = np.copy(x)\n            for _ in range(10): # Max 10 backtracking steps\n                x_new[free_indices] = x[free_indices] + alpha * delta_x_free\n                \n                # Recalculate residual for the new coordinates\n                x_new_prev = np.roll(x_new, 1)\n                x_new_next = np.roll(x_new, -1)\n                all_F_new = kinetic_prefactor1 * (2*x_new - x_new_prev - x_new_next) + potential_prefactor * V_prime(x_new)\n                F_free_new = all_F_new[free_indices]\n\n                if np.linalg.norm(F_free_new)  residual_norm:\n                    break\n                alpha /= 2.0\n            \n            x = x_new\n\n        return x\n\n    # --- Test Suite ---\n    test_cases = [\n        {\n            'case': 1, 'P': 32, 'beta': 6, 'm': 1,\n            'potential_name': 'harmonic', 'potential_params': {'k': 1},\n            'fixed_beads': {0: 0.0},\n            'init_func': lambda P, fixed: np.zeros(P)\n        },\n        {\n            'case': 2, 'P': 64, 'beta': 6, 'm': 1,\n            'potential_name': 'double_well', 'potential_params': {'a': 1, 'b': 1},\n            'fixed_beads': {0: 1.0, 32: -1.0},\n            'init_func': lambda P, fixed: np.interp(\n                np.arange(P), [0, P/2, P], [fixed[0], fixed[P/2], fixed[0]]\n            )\n        },\n        {\n            'case': 3, 'P': 128, 'beta': 10, 'm': 1,\n            'potential_name': 'double_well', 'potential_params': {'a': 1, 'b': 1},\n            'fixed_beads': {0: 1.0, 64: -1.0},\n            'init_func': lambda P, fixed: np.interp(\n                np.arange(P), [0, P/2, P], [fixed[0], fixed[P/2], fixed[0]]\n            )\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        P = case['P']\n        fixed_beads = case['fixed_beads']\n        \n        V, Vp, Vpp = get_potentials(case['potential_name'], case['potential_params'])\n        \n        x_init = case['init_func'](P, fixed_beads)\n        \n        x_converged = run_newton_raphson(\n            x_init, case['m'], case['beta'], V, Vp, Vpp, fixed_beads\n        )\n        \n        action = calculate_action(x_converged, case['m'], case['beta'], V)\n        \n        result = np.exp(-action)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2898586"}, {"introduction": "完成瞬子路径的计算后，下一步是评估其对速率常数的贡献，这需要计算涨落行列式。本练习将教您如何从离散化的作用量中构建黑塞矩阵（Hessian matrix），并计算其伪行列式（pseudo-determinant）。您将学习如何通过投影方法处理因虚时平移不变性而产生的零模，从而完成半经典速率计算中的关键一步 [@problem_id:2898619]。", "problem": "实现一个程序，该程序针对瞬子理论中使用的一维环状聚合物离散化的欧几里得作用量，计算与给定离散路径周围的二次涨落相关的涨落行列式，并移除由虚时平移产生的离散零模。您的实现必须基于以下第一性原理。\n\n从一个质量为 $m$ 的粒子在标量势 $V(x)$ 中的离散化欧几里得作用量开始，该体系处于逆温度 $\\beta$（无量纲单位，约化普朗克常数设为1），使用一个包含 $P$ 个珠子的环状聚合物，时间步长均匀，为 $\\Delta \\tau = \\beta/P$：\n$$\nS_P[\\mathbf{x}] \\equiv \\sum_{k=0}^{P-1} \\left[ \\frac{m}{2\\,\\Delta \\tau}\\,\\left(x_{k+1}-x_k\\right)^2 + \\Delta \\tau\\, V(x_k) \\right],\n$$\n其中强制采用周期性边界条件，$x_P \\equiv x_0$。涨落算符是 $S_P$ 关于珠子坐标的 Hessian 矩阵，即一个 $P \\times P$ 矩阵，其元素为 $H_{ij} = \\partial^2 S_P / \\partial x_i \\partial x_j$。证明它可以写成环上的离散拉普拉斯算子和逐点势能曲率的形式：\n$$\n\\mathbf{H} = \\frac{m}{\\Delta \\tau}\\,\\mathbf{L} \\;+\\; \\Delta \\tau \\,\\mathrm{diag}\\left(V''(x_0),\\dots,V''(x_{P-1})\\right),\n$$\n其中 $\\mathbf{L}$ 是循环离散拉普拉斯算子，由 $(\\mathbf{L}\\,\\mathbf{y})_k = 2 y_k - y_{k+1} - y_{k-1}$ 给出，具有周期性环绕。\n\n在连续理论中，对于欧几里得作用量的一个稳态周期轨道，存在一个与瞬子路径对虚时间的导数成正比的零模，这反映了时间平移不变性。在离散的环状聚合物表示中，一个相应的离散零模由有限差分切向矢量表示：\n$$\n\\mathbf{t} \\propto \\left( x_{1}-x_{0},\\; x_{2}-x_{1},\\; \\dots,\\; x_{0}-x_{P-1} \\right).\n$$\n为了计算半经典瞬子速率理论中出现的涨落行列式，必须移除此离散零模并计算非零本征值的乘积，即伪行列式：\n$$\n\\det{}' \\mathbf{H} \\equiv \\prod_{\\lambda_j \\neq 0} \\lambda_j.\n$$\n\n您的程序必须仅根据上述定义，为每个测试用例实现以下步骤：\n1. 使用解析周期性拟设构建离散路径 $\\mathbf{x} \\in \\mathbb{R}^P$\n$$\nx_k = s\\,a\\,\\tanh\\!\\big(\\kappa \\,\\sin(2\\pi k/P)\\big), \\quad k=0,\\dots,P-1,\n$$\n其中 $a$ 和 $\\kappa$ 是形状参数，$s \\in [0,1]$ 是振幅标度。\n2. 对于双阱势\n$$\nV(x) = \\lambda\\,(x^2 - a^2)^2,\n$$\n计算每个珠子位置的逐点曲率 $V''(x) = 12\\,\\lambda\\,x^2 - 4\\,\\lambda\\,a^2$。\n3. 使用上述公式组装 Hessian 矩阵 $\\mathbf{H}$。\n4. 构建具有周期性环绕的离散切向矢量 $\\mathbf{t}$，将其归一化为单位范数，并用它来移除离散零模，具体操作如下：计算 $\\mathbf{H}$ 的完全本征分解，识别与 $\\mathbf{t}$ 具有最大绝对重叠的本征矢量，并从乘积中排除相应的本征值。如果 $\\|\\mathbf{t}\\|$ 在数值上可忽略不计，则回退到使用均匀矢量 $(1,1,\\dots,1)$ 作为零模方向。\n5. 返回投影涨落行列式绝对值的自然对数，\n$$\n\\log\\left|\\det{}' \\mathbf{H}\\right| = \\sum_{j \\neq j_0} \\log\\left|\\lambda_j\\right|,\n$$\n其中 $j_0$ 是被移除模式的索引。使用数值稳定的实现，通过在对数内部取绝对值，并根据需要将幅值裁剪至远离零，从而永远不会计算非正数的对数。所有量都是无量纲的；将最终数值结果表示为四舍五入到八位小数的浮点数。\n\n测试套件。将您的程序应用于以下四个测试用例，每个用例由元组 $(m,\\lambda,a,\\beta,P,\\kappa,s)$ 指定：\n- 情况1（正常路径，中等刚度双阱，良好分辨的路径）：$(1.0,\\,1.0,\\,1.0,\\,40.0,\\,64,\\,2.5,\\,1.0)$。\n- 情况2（更宽的势阱，更多珠子）：$(1.0,\\,0.5,\\,1.2,\\,60.0,\\,96,\\,3.0,\\,1.0)$。\n- 情况3（边缘情况：近乎均匀的路径；零模回退到均匀方向）：$(1.0,\\,1.0,\\,1.0,\\,16.0,\\,16,\\,1.5,\\,0.0)$。\n- 情况4（更大质量，更刚硬的势阱，中等数量的珠子，减小的振幅）：$(2.0,\\,1.5,\\,0.8,\\,24.0,\\,32,\\,2.0,\\,0.5)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含四个结果，形式为方括号内逗号分隔的列表（例如，“[r1,r2,r3,r4]”），其中每个 $r_i$ 是对应情况下 $\\log\\left|\\det{}' \\mathbf{H}\\right|$ 的值，四舍五入到八位小数。没有物理单位；所有输出都是无量纲的实数。", "solution": "问题陈述已经过严格评估，并被确定为有效。它提出了一个适定且有科学依据的计算任务，植根于半经典瞬子理论的原理，特别是环状聚合物瞬子（RPI）方法。所有必需的定义、参数和函数形式均已提供，从而可以得到唯一且可验证的解。所述的计算涨落行列式的方法是该领域的标准实践。\n\n我们现在将着手对所需计算进行系统性的、基于第一性原理的推导和实现。\n\n目标是为一组给定的物理和数值参数计算量 $\\log\\left|\\det{}' \\mathbf{H}\\right|$。这里，$\\mathbf{H}$ 代表一维势中粒子的离散化欧几里得作用量的 Hessian 矩阵，而 $\\det{}'$ 表示伪行列式，其中与时间平移不变性相关的零本征值的贡献被排除。\n\n该过程分为以下强制性步骤。\n\n**1. 生成离散化路径**\n\n系统由一个包含 $P$ 个珠子的环状聚合物描述，代表在虚时间 $\\tau \\in [0, \\beta]$ 中的一条循环路径，其中 $\\beta$ 是逆温度且 $\\hbar=1$。虚时间隔被离散化为 $P$ 个大小为 $\\Delta\\tau = \\beta/P$ 的步长。第 $k$ 个珠子的位置（其中 $k \\in \\{0, 1, \\dots, P-1\\}$）由解析拟设给出：\n$$\nx_k = s\\,a\\,\\tanh\\!\\big(\\kappa \\,\\sin(2\\pi k/P)\\big)\n$$\n该公式基于提供的形状参数 $a$ 和 $\\kappa$ 以及振幅标度 $s$ 定义了离散路径矢量 $\\mathbf{x} = (x_0, x_1, \\dots, x_{P-1}) \\in \\mathbb{R}^P$。\n\n**2. 评估势能曲率**\n\n粒子在双阱势中运动，其势能由下式给出：\n$$\nV(x) = \\lambda\\,(x^2 - a^2)^2\n$$\n路径的稳定性由二阶涨落决定，这取决于势的局部曲率。$V(x)$ 的二阶导数是：\n$$\nV''(x) = \\frac{d^2}{dx^2} \\left[ \\lambda\\,(x^4 - 2a^2x^2 + a^4) \\right] = \\lambda\\,(12x^2 - 4a^2)\n$$\n在每个珠子的位置 $x_k$ 处评估该曲率，以生成一个包含 $P$ 个曲率值的矢量，该矢量将构成 Hessian 矩阵中与势能相关的部分的对角线。\n\n**3. 组装 Hessian 矩阵**\n\n离散化作用量 $S_P$ 的 Hessian 矩阵 $\\mathbf{H}$ 由其元素 $H_{ij} = \\frac{\\partial^2 S_P}{\\partial x_i \\partial x_j}$ 定义。如问题所述，这导致了以下表达式：\n$$\n\\mathbf{H} = \\frac{m}{\\Delta \\tau}\\,\\mathbf{L} \\;+\\; \\Delta \\tau \\,\\mathbf{D}_{V''}\n$$\n其中 $m$ 是粒子质量，$\\mathbf{D}_{V''}$ 是对角矩阵，其元素为 $\\left(\\mathbf{D}_{V''}\\right)_{kk} = V''(x_k)$，而 $\\mathbf{L}$ 是周期链的 $P \\times P$ 离散拉普拉斯矩阵（一个循环矩阵）。$\\mathbf{L}$ 的元素由下式给出：\n$$\nL_{ij} = 2\\delta_{ij} - \\delta_{i, j+1} - \\delta_{i, j-1}\n$$\n其中索引被理解为模 $P$。该矩阵在离散路径积分形式中代表动能算符。完整的 Hessian 矩阵 $\\mathbf{H}$ 是这个动能项和对角势能项的和。作为两个实对称矩阵的和，$\\mathbf{H}$ 本身也是实对称的。\n\n**4. 识别和移除零模**\n\n周期轨道的欧几里得作用量在虚时间平移下是不变的。这种对称性导致连续涨落算符出现一个零本征值模式，该模式与瞬子路径的时间导数 $\\dot{x}(\\tau)$ 成正比。在离散表示中，该模式对应于离散切向矢量 $\\mathbf{t}$，其分量由有限差分近似给出：\n$$\nt_k = x_{k+1} - x_k, \\quad \\text{其中 } x_P \\equiv x_0\n$$\n为了正确计算涨落行列式，必须将此模式投影出去。过程如下：\n首先，构建矢量 $\\mathbf{t}$。如果路径是均匀的（例如当 $s=0$ 时），会导致所有 $x_k$ 都相同，这时会出现一种特殊情况。在这种情况下，$\\|\\mathbf{t}\\|$ 在数值上为零。按照指示，我们回退到使用均匀矢量 $\\mathbf{u} = (1, 1, \\dots, 1)$ 作为零模方向。该矢量 $\\mathbf{u}$ 是离散拉普拉斯算子 $\\mathbf{L}$ 的精确零本征矢量。\n将所选矢量（$\\mathbf{t}$ 或 $\\mathbf{u}$）归一化为单位长度，我们称之为 $\\hat{\\mathbf{z}}$。\n接下来，计算实对称矩阵 $\\mathbf{H}$ 的完整本征系统。这将得到 $P$ 个实本征值 $\\{\\lambda_j\\}$ 和一组相应的标准正交本征矢量 $\\{\\mathbf{v}_j\\}$。\n通过找到与我们的参考矢量 $\\hat{\\mathbf{z}}$ 具有最大绝对重叠的本征矢量，来识别与离散零模对应的本征矢量，我们称之为 $\\mathbf{v}_{j_0}$：\n$$\nj_0 = \\underset{j}{\\operatorname{arg\\,max}} \\left| \\hat{\\mathbf{z}} \\cdot \\mathbf{v}_j \\right|\n$$\n然后，将相应的本征值 $\\lambda_{j_0}$ 从随后的乘积中排除。\n\n**5. 计算对数伪行列式**\n\n最终感兴趣的量是 $\\mathbf{H}$ 的伪行列式绝对值的自然对数，它是除零模本征值 $\\lambda_{j_0}$ 外所有本征值的乘积。\n$$\n\\log\\left|\\det{}' \\mathbf{H}\\right| = \\log\\left| \\prod_{j \\neq j_0} \\lambda_j \\right| = \\sum_{j \\neq j_0} \\log\\left|\\lambda_j\\right|\n$$\n这种表述确保了数值稳定性。通过在取对数前对每个本征值 $\\lambda_j$ 取绝对值，我们处理了负本征值的情况。如果任何未被投影的本征值在数值上为零，其对数将正确地为 $-\\infty$，求和结果将反映这一点。这构成了每个测试用例的最终结果。", "answer": "```python\nimport numpy as np\n\ndef calculate_log_det_prime(params: tuple) -> float:\n    \"\"\"\n    Calculates the log of the pseudo-determinant for a ring-polymer system.\n\n    Args:\n        params: A tuple containing (m, lambda, a, beta, P, kappa, s).\n\n    Returns:\n        The value of log|det' H|.\n    \"\"\"\n    m, lam, a, beta, P, kappa, s = params\n    P = int(P) # Ensure P is an integer for matrix dimensions\n\n    # Step 0: Define fundamental constants from parameters\n    delta_tau = beta / P\n    k_vec = np.arange(P)\n\n    # Step 1: Construct the discrete path x\n    # x_k = s * a * tanh(kappa * sin(2*pi*k/P))\n    path_arg = kappa * np.sin(2.0 * np.pi * k_vec / P)\n    x = s * a * np.tanh(path_arg)\n\n    # Step 2: Compute the pointwise potential curvature V''(x_k)\n    # V''(x) = 12 * lambda * x^2 - 4 * lambda * a^2\n    v_pp = 12.0 * lam * x**2 - 4.0 * lam * a**2\n    V_pp_diag = np.diag(v_pp)\n\n    # Step 3: Assemble the Hessian matrix H\n    # H = (m / delta_tau) * L + delta_tau * diag(V'')\n    # Construct the discrete Laplacian matrix L\n    L_matrix = 2.0 * np.eye(P) - np.diag(np.ones(P - 1), k=1) - np.diag(np.ones(P - 1), k=-1)\n    L_matrix[0, P - 1] = -1.0\n    L_matrix[P - 1, 0] = -1.0\n    \n    H = (m / delta_tau) * L_matrix + delta_tau * V_pp_diag\n    \n    # Step 4: Identify and prepare the discrete zero mode vector\n    # Build the discrete tangent vector t\n    t = np.roll(x, -1) - x\n    t_norm = np.linalg.norm(t)\n    \n    # Check for a numerically negligible norm (e.g., s=0 case).\n    # If so, use the uniform vector as the zero-mode representative.\n    if t_norm  1e-10:\n        zero_mode_unnormalized = np.ones(P)\n    else:\n        zero_mode_unnormalized = t\n    \n    # Normalize the zero-mode vector for projection\n    norm = np.linalg.norm(zero_mode_unnormalized)\n    zero_mode_normalized = zero_mode_unnormalized / norm\n    \n    # Compute the full eigen-decomposition of the symmetric matrix H\n    eigenvalues, eigenvectors = np.linalg.eigh(H)\n    \n    # Identify the eigenvector with the largest absolute overlap\n    # with the normalized zero-mode vector.\n    # Eigenvectors are columns, so we transpose for dot products.\n    overlaps = np.abs(eigenvectors.T @ zero_mode_normalized)\n    zero_mode_index = np.argmax(overlaps)\n    \n    # Step 5: Compute the sum of logarithms of absolute eigenvalues,\n    # excluding the identified zero mode.\n    # log|det' H| = sum_{j != j0} log|lambda_j|\n    log_det_prime = 0.0\n    for i in range(P):\n        if i == zero_mode_index:\n            continue\n        \n        # Add log of absolute value of the eigenvalue.\n        # This is numerically safe and handles negative eigenvalues.\n        # np.log(0) correctly yields -inf.\n        log_det_prime += np.log(np.abs(eigenvalues[i]))\n            \n    return log_det_prime\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite as specified in the problem statement.\n    # Each case is a tuple: (m, lambda, a, beta, P, kappa, s)\n    test_cases = [\n        (1.0, 1.0, 1.0, 40.0, 64, 2.5, 1.0),\n        (1.0, 0.5, 1.2, 60.0, 96, 3.0, 1.0),\n        (1.0, 1.0, 1.0, 16.0, 16, 1.5, 0.0),\n        (2.0, 1.5, 0.8, 24.0, 32, 2.0, 0.5),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = calculate_log_det_prime(params)\n        # Format the result to eight decimal places.\n        results.append(f\"{result:.8f}\")\n\n    # Print the final output in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2898619"}]}