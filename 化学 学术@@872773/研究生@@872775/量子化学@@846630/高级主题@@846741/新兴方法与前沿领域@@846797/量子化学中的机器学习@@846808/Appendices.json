{"hands_on_practices": [{"introduction": "现代机器学习势函数，特别是图神经网络，其核心在于将原子间距编码为富有表达能力的特征向量。该过程的基石是径向基函数（Radial Basis Functions, RBFs）。[@problem_id:2903777]将引导你从第一性原理出发，设计一个可学习的径向基函数层，包括构建一个平滑的截断函数并初始化一组高斯函数以有效覆盖整个空间域。通过这个实践，你将掌握构建先进原子模拟模型的基础模块，并理解其背后关键的设计决策。", "problem": "您正在为分子图中的成对原子间距设计一个可学习的径向基函数（Radial Basis Function, RBF）层。设标量原子间距用 $r \\in [0,\\infty)$ 表示，单位为埃（ångström），并设有一个有限的截断半径 $r_\\mathrm{c} \\in (0,\\infty)$（单位也为埃），当距离超过该半径时，贡献将被抑制。该层由 $K \\in \\mathbb{N}$ 个高斯包络组成，这些包络的中心位于 $0 = \\mu_0  \\mu_1  \\cdots  \\mu_{K-1} = r_\\mathrm{c}$，并乘以一个平滑的截断函数 $f_\\mathrm{c}(r)$，使得每个基函数的形式为 $\\phi_k(r) = f_\\mathrm{c}(r)\\,\\exp\\!\\big(-\\beta_k\\,(r-\\mu_k)^2\\big)$，其中 $k \\in \\{0,1,\\dots,K-1\\}$。任何三角函数内部的角度都必须以弧度为单位。\n\n从第一性原理出发，施加以下基本设计要求：\n\n1. 平滑截断设计。截断函数 $f_\\mathrm{c}(r)$ 必须满足以下所有条件：\n   - 对于 $r > r_\\mathrm{c}$，$f_\\mathrm{c}(r) = 0$，\n   - $f_\\mathrm{c}(0) = 1$ 且 $f_\\mathrm{c}(r_\\mathrm{c}) = 0$，\n   - $f_\\mathrm{c}'(0) = 0$ 且 $f_\\mathrm{c}'(r_\\mathrm{c}) = 0$，\n   - $f_\\mathrm{c}(r)$ 在 $[0,\\infty)$ 上连续，并在 $[0,r_\\mathrm{c}]$ 上连续可微。\n\n2. 中心的均匀覆盖。中心 $\\mu_k$ 应均匀覆盖整个区间 $[0,r_\\mathrm{c}]$，包括端点，使用恒定的间距 $s = r_\\mathrm{c}/(K-1)$。\n\n3. 由中点等值重叠确定宽度。对于目标重叠水平 $\\tau \\in (0,1)$，要求对于任意两个相邻的中心 $\\mu_k$ 和 $\\mu_{k+1}$，高斯包络（不含截断函数）在中点 $r = (\\mu_k + \\mu_{k+1})/2$ 处的值为 $\\tau$。也就是说，如果包络是 $\\exp\\!\\big(-\\beta\\,(r-\\mu)^2\\big)$，其中所有 $k$ 共享一个逆宽度参数 $\\beta > 0$，则在中点处的值等于 $\\tau$。\n\n任务：\n\na) 仅从上述边界和平滑性条件出发，推导出一个满足所有要求的函数 $f_\\mathrm{c}(r)$ 的显式闭合形式表达式。您的推导不能预设任何特定的函数形式；相反，应从这些条件出发，推导出一个与约束条件一致的最小频率三角函数构造。明确写出最终的 $f_\\mathrm{c}(r)$，包括其在 $[0,r_\\mathrm{c}]$ 和 $(r_\\mathrm{c},\\infty)$ 上的分段定义，以及其在 $[0,r_\\mathrm{c}]$ 上的一阶导数。\n\nb) 使用中点等值重叠要求和均匀间距 $s = r_\\mathrm{c}/(K-1)$，推导共享逆宽度 $\\beta$ 关于 $s$ 和 $\\tau$ 的显式公式。如果您倾向于将高斯包络参数化为 $\\exp\\!\\big(-\\frac{(r-\\mu)^2}{2\\sigma^2}\\big)$，其中共享标准差 $\\sigma>0$，也请推导 $\\sigma$ 关于 $s$ 和 $\\tau$ 的表达式，并证明两种参数化方式的等价性。\n\nc) 实现一个程序，使用您推导的表达式构建RBF，并为一组参数选择的测试套件评估以下量化检查。对于每个测试用例，计算：\n   - 包络中点重叠误差 $E_\\mathrm{overlap} = \\left|\\exp\\!\\big(-\\beta\\,(s/2)^2\\big) - \\tau\\right|$，\n   - 截断边界误差 $E_\\mathrm{boundary} = \\max\\big(\\,|f_\\mathrm{c}(0) - 1|,\\; |f_\\mathrm{c}(r_\\mathrm{c}) - 0|,\\; |f_\\mathrm{c}'(0)|,\\; |f_\\mathrm{c}'(r_\\mathrm{c})|\\,\\big)$，\n   - 超出截断误差 $E_\\mathrm{beyond} = |f_\\mathrm{c}(r_\\mathrm{c} + \\varepsilon)|$，其中 $\\varepsilon = r_\\mathrm{c}\\cdot 10^{-6}$。\n\n对于每个测试用例，以浮点数形式报告一个标量值 $E_\\mathrm{total} = \\max\\big(E_\\mathrm{overlap}, E_\\mathrm{boundary}, E_\\mathrm{beyond}\\big)$。所有输出均为无单位实数。余弦或正弦函数内部的角度必须以弧度为单位。\n\n测试套件：\n- 案例 1: $r_\\mathrm{c} = 5.0$ 埃, $K = 8$, $\\tau = 0.5$。\n- 案例 2: $r_\\mathrm{c} = 5.0$ 埃, $K = 2$, $\\tau = 0.5$。\n- 案例 3: $r_\\mathrm{c} = 1.0$ 埃, $K = 5$, $\\tau = 0.1$。\n- 案例 4: $r_\\mathrm{c} = 3.5$ 埃, $K = 10$, $\\tau = 0.9$。\n\n您的程序应生成单行输出，其中包含按案例 1 到 4 的确切顺序排列的结果，格式为逗号分隔的列表并用方括号括起（例如，“[result1,result2,result3,result4]”）。不应打印任何额外文本。所有内部计算对任何三角函数参数都必须使用弧度。如果您需要计算任何三角函数量，请确保其参数形式为 $\\text{(无量纲因子)} \\times r$，以使输入为弧度。距离 $r$ 和 $r_\\mathrm{c}$ 的单位是埃，但报告的误差是无量纲的，应作为无单位浮点数打印。", "solution": "问题陈述经过验证，被认为是科学上可靠、定义明确的，并且是计算量子化学领域内的一个客观问题。它没有矛盾或含糊之处。因此，我们可以进行形式化的推导和求解。\n\n该任务分为三个部分。我们将按顺序解决它们。\n\na) 平滑截断函数 $f_\\mathrm{c}(r)$ 的推导\n\n我们需要为区间 $[0, r_\\mathrm{c}]$ 推导一个函数 $f_\\mathrm{c}(r)$，该函数满足以下四个条件：\n1.  $f_\\mathrm{c}(0) = 1$\n2.  $f_\\mathrm{c}(r_\\mathrm{c}) = 0$\n3.  $f_\\mathrm{c}'(0) = 0$\n4.  $f_\\mathrm{c}'(r_\\mathrm{c}) = 0$\n\n此外，该函数必须在 $[0, \\infty)$ 上连续，并在 $[0, r_\\mathrm{c}]$ 上连续可微。问题指定了一个分段定义，其中当 $r > r_\\mathrm{c}$ 时 $f_\\mathrm{c}(r) = 0$。在 $r=r_\\mathrm{c}$ 处的条件确保了向零的平滑过渡。使用“最小频率三角函数构造”的指令表明其形式涉及单个余弦项。\n\n让我们为区间 $[0, r_\\mathrm{c}]$ 上的 $f_\\mathrm{c}(r)$ 提出一个通用形式：\n$$f_\\mathrm{c}(r) = A \\cos(B r) + C$$\n其中 $A$、$B$ 和 $C$ 是待定常数。其导数为：\n$$f_\\mathrm{c}'(r) = -A B \\sin(B r)$$\n\n我们系统地应用给定条件：\n-   条件 3，$f_\\mathrm{c}'(0) = 0$：$f_\\mathrm{c}'(0) = -A B \\sin(0) = 0$。对于任意选择的 $A$ 和 $B$，此条件均成立。\n-   条件 4，$f_\\mathrm{c}'(r_\\mathrm{c}) = 0$：$f_\\mathrm{c}'(r_\\mathrm{c}) = -A B \\sin(B r_\\mathrm{c}) = 0$。对于非平凡解（$A \\ne 0, B \\ne 0$），必须有 $\\sin(B r_\\mathrm{c}) = 0$。这意味着 $B r_\\mathrm{c} = n \\pi$，其中 $n$ 为整数。为满足“最小频率”要求，我们选择最小的非零正整数 $n=1$。这得出 $B = \\frac{\\pi}{r_\\mathrm{c}}$。\n-   条件 1，$f_\\mathrm{c}(0) = 1$：$f_\\mathrm{c}(0) = A \\cos(0) + C = A + C = 1$。\n-   条件 2，$f_\\mathrm{c}(r_\\mathrm{c}) = 0$：当 $B = \\pi/r_\\mathrm{c}$ 时，我们有 $f_\\mathrm{c}(r_\\mathrm{c}) = A \\cos\\left(\\frac{\\pi r_\\mathrm{c}}{r_\\mathrm{c}}\\right) + C = A \\cos(\\pi) + C = -A + C = 0$。\n\n我们现在得到一个关于 $A$ 和 $C$ 的二元线性方程组：\n$$\n\\begin{cases}\nA + C = 1 \\\\\n-A + C = 0\n\\end{cases}\n$$\n从第二个方程，我们得到 $C = A$。将其代入第一个方程得到 $2A = 1$，因此 $A = 1/2$。从而，$C = 1/2$。\n\n因此，在区间 $[0, r_\\mathrm{c}]$ 上的函数是：\n$$f_\\mathrm{c}(r) = \\frac{1}{2} \\cos\\left(\\frac{\\pi r}{r_\\mathrm{c}}\\right) + \\frac{1}{2} = \\frac{1}{2}\\left(1 + \\cos\\left(\\frac{\\pi r}{r_\\mathrm{c}}\\right)\\right)$$\n\n截断函数的完整分段定义是：\n$$f_\\mathrm{c}(r) = \\begin{cases} \\frac{1}{2}\\left(1 + \\cos\\left(\\frac{\\pi r}{r_\\mathrm{c}}\\right)\\right)  \\text{if } 0 \\le r \\le r_\\mathrm{c} \\\\ 0  \\text{if } r > r_\\mathrm{c} \\end{cases}$$\n在区间 $[0, r_\\mathrm{c}]$ 上的一阶导数是：\n$$f_\\mathrm{c}'(r) = -\\frac{\\pi}{2 r_\\mathrm{c}} \\sin\\left(\\frac{\\pi r}{r_\\mathrm{c}}\\right)$$\n此构造满足所有提出的要求。\n\nb) 宽度参数 $\\beta$ 和 $\\sigma$ 的推导\n\n高斯包络由 $\\exp\\!\\big(-\\beta\\,(r-\\mu)^2\\big)$ 给出，具有一个共享的逆宽度参数 $\\beta$。中心 $\\mu_k$ 在 $[0, r_\\mathrm{c}]$ 上均匀分布。对于 $K \\ge 2$ 个基函数，间距为 $s = r_\\mathrm{c} / (K-1)$。中心位于 $\\mu_k = k \\cdot s$，其中 $k \\in \\{0, 1, \\dots, K-1\\}$。\n\n重叠条件是为任意两个相邻中心 $\\mu_k$ 和 $\\mu_{k+1}$ 指定的。它们之间的中点是 $r_\\mathrm{mid} = \\frac{\\mu_k + \\mu_{k+1}}{2}$。该中点到任一中心的距离是 $|r_\\mathrm{mid} - \\mu_k| = \\frac{\\mu_{k+1} - \\mu_k}{2} = \\frac{s}{2}$。\n\n该条件要求以 $\\mu_k$ 为中心的高斯包络在 $r_\\mathrm{mid}$ 处计算时其值等于 $\\tau$：\n$$\\exp\\!\\big(-\\beta\\,(r_\\mathrm{mid}-\\mu_k)^2\\big) = \\tau$$\n代入距离 $(r_\\mathrm{mid}-\\mu_k) = s/2$：\n$$\\exp\\!\\big(-\\beta\\,(s/2)^2\\big) = \\tau$$\n为了求解 $\\beta$，我们对两边取自然对数：\n$$-\\beta \\frac{s^2}{4} = \\ln(\\tau)$$\n由于 $\\tau \\in (0,1)$，$\\ln(\\tau)$ 是负数，因此 $\\beta$ 是正数，符合要求。\n$$\\beta = -\\frac{4 \\ln(\\tau)}{s^2}$$\n代入 $s = r_\\mathrm{c}/(K-1)$，我们得到 $\\beta = -\\frac{4 (K-1)^2 \\ln(\\tau)}{r_\\mathrm{c}^2}$。\n\n对于替代参数化 $\\exp\\!\\big(-\\frac{(r-\\mu)^2}{2\\sigma^2}\\big)$，我们令两种包络形式相等：\n$$\\exp\\!\\big(-\\beta\\,(r-\\mu)^2\\big) = \\exp\\!\\big(-\\frac{(r-\\mu)^2}{2\\sigma^2}\\big)$$\n这意味着指数必须相等：\n$$\\beta = \\frac{1}{2\\sigma^2}$$\n求解标准差 $\\sigma$：\n$$\\sigma^2 = \\frac{1}{2\\beta} \\implies \\sigma = \\sqrt{\\frac{1}{2\\beta}}$$\n代入我们关于 $\\beta$ 的表达式：\n$$\\sigma = \\sqrt{\\frac{1}{2 \\left(-\\frac{4 \\ln(\\tau)}{s^2}\\right)}} = \\sqrt{-\\frac{s^2}{8 \\ln(\\tau)}} = \\frac{s}{\\sqrt{-8 \\ln(\\tau)}}$$\n\nc) 用于验证的算法设计\n\n最后的任务是实现推导出的公式，并为几个测试用例计算误差度量。总误差 $E_\\mathrm{total}$ 是三个分量的最大值：\n-   $E_\\mathrm{overlap} = \\left|\\exp\\!\\big(-\\beta\\,(s/2)^2\\big) - \\tau\\right|$。通过代入我们推导的 $\\beta$ 表达式，该式计算为 $\\left|\\exp\\!\\big( -(-\\frac{4 \\ln(\\tau)}{s^2})\\frac{s^2}{4} \\big) - \\tau\\right| = \\left|e^{\\ln(\\tau)} - \\tau\\right| = |\\tau - \\tau| = 0$。此误差测试了 $\\beta$ 公式实现的数值精度。\n-   $E_\\mathrm{boundary} = \\max\\big(\\,|f_\\mathrm{c}(0) - 1|,\\; |f_\\mathrm{c}(r_\\mathrm{c}) - 0|,\\; |f_\\mathrm{c}'(0)|,\\; |f_\\mathrm{c}'(r_\\mathrm{c})|\\,\\big)$。根据我们在(a)部分的构造，$\\max$ 函数内的所有四项在解析上都为零。此误差测试了截断函数及其导数的实现。\n-   $E_\\mathrm{beyond} = |f_\\mathrm{c}(r_\\mathrm{c} + \\varepsilon)|$，其中 $\\varepsilon = r_\\mathrm{c} \\cdot 10^{-6}$。由于 $r_\\mathrm{c} + \\varepsilon > r_\\mathrm{c}$，我们对 $f_\\mathrm{c}(r)$ 的分段定义规定其值为 $0$。此误差在解析上也必须为零，并测试了 $f_\\mathrm{c}(r)$ 分段性质的正确实现。\n\n因此，计算机程序将计算这三个误差度量，预计它们仅由于浮点运算的固有局限性才不为零。每个测试用例最终报告的值 $E_\\mathrm{total}$ 将是这些微小数值误差的最大值，从而有效地量化了计算的精度。实现将以弧度处理所有角度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of deriving and verifying radial basis function parameters.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (r_c, K, tau)\n        (5.0, 8, 0.5),  # Case 1\n        (5.0, 2, 0.5),  # Case 2\n        (1.0, 5, 0.1),  # Case 3\n        (3.5, 10, 0.9), # Case 4\n    ]\n\n    results = []\n\n    for r_c, K, tau in test_cases:\n        # Task a: Define the cutoff function f_c(r) and its derivative.\n        # The argument of the trigonometric functions, pi * r / r_c, is dimensionless,\n        # ensuring the input to np.cos and np.sin is in radians.\n\n        def f_c(r):\n            \"\"\"Calculates the value of the cosine cutoff function.\"\"\"\n            if r  0.0 or r > r_c:\n                return 0.0\n            return 0.5 * (1.0 + np.cos(np.pi * r / r_c))\n\n        def f_c_prime(r):\n            \"\"\"Calculates the derivative of the cosine cutoff function.\"\"\"\n            # The derivative is 0 at the boundaries r=0 and r=r_c, and outside [0, r_c].\n            if r = 0.0 or r >= r_c:\n                return 0.0\n            return -(np.pi / (2.0 * r_c)) * np.sin(np.pi * r / r_c)\n\n        # Task c: Calculate error metrics.\n\n        # 1. E_boundary: Check if f_c(r) satisfies the boundary conditions.\n        err_f0 = np.abs(f_c(0.0) - 1.0)\n        err_frc = np.abs(f_c(r_c) - 0.0)\n        err_fp0 = np.abs(f_c_prime(0.0) - 0.0)\n        err_fprc = np.abs(f_c_prime(r_c) - 0.0)\n        E_boundary = np.max([err_f0, err_frc, err_fp0, err_fprc])\n\n        # 2. E_beyond: Check if f_c(r) is zero beyond the cutoff radius.\n        epsilon = r_c * 1e-6\n        E_beyond = np.abs(f_c(r_c + epsilon) - 0.0)\n        \n        # Task b: Derive and use the inverse-width parameter beta.\n        # The problem statement implies K >= 2 for the spacing 's' to be meaningful.\n        # All test cases satisfy K >= 2.\n        if K  2:\n            # This case corresponds to an invalid setup for defining 's'.\n            # Based on the problem constraints (mu_0=0, mu_{K-1}=r_c > 0), K=1 is impossible.\n            # We add a inf result to signal this, though it won't be reached by test cases.\n            results.append(float('inf'))\n            continue\n        \n        s = r_c / (K - 1.0)\n        # Derived formula for beta: beta = -4 * ln(tau) / s^2\n        beta = -4.0 * np.log(tau) / (s**2)\n\n        # 3. E_overlap: Check the midpoint overlap value.\n        # The envelope value at a distance of s/2 from the center should be tau.\n        envelope_midpoint_value = np.exp(-beta * (s / 2.0)**2)\n        E_overlap = np.abs(envelope_midpoint_value - tau)\n        \n        # Final total error for the current test case.\n        # By derivation, all errors should be zero. The result is the maximum\n        # of the numerical errors due to floating-point representation.\n        E_total = np.max([E_overlap, E_boundary, E_beyond])\n        results.append(E_total)\n\n    # Final print statement in the exact required format.\n    # The map call formats each floating point number into a string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2903777"}, {"introduction": "在确定了模型的结构（例如，通过一组基函数）之后，下一步是使用量子化学计算数据来训练模型参数。[@problem_id:2903774]旨在通过构建学习曲线，量化比较两种主流的训练策略：能量匹配与力匹配。你将通过一个具体的数值实验，亲身体会到在损失函数中引入导数信息（即原子间作用力）为何能够显著提升模型的学习效率，这对于数据生成成本高昂的量子化学领域至关重要。", "problem": "要求您设计并实现一个程序，通过分析学习曲线，比较在一维势能面（PES）模型中，固定模型容量下力匹配和能量匹配的数据效率。该场景构建于量子化学背景下，并使用原子单位：能量单位为哈特里（Hartree），距离单位为玻尔（bohr）。所有学习和评估都必须在原子单位下进行。最终程序必须按照本问题末尾指定的格式输出所需结果。\n\n您必须使用的基本原理如下。势能面（PES）是原子核坐标 $x$ 的函数 $E_{\\mathrm{true}}(x)$，其负梯度定义了力 $F_{\\mathrm{true}}(x)$，即 $F_{\\mathrm{true}}(x) = -\\frac{d}{dx}E_{\\mathrm{true}}(x)$。一个参数化能量模型定义为 $E_{w}(x) = \\sum_{k=1}^{M} w_k \\,\\phi_k(x)$，其中 $M$ 是模型容量（基函数的数量），$w \\in \\mathbb{R}^{M}$ 是参数，$\\{\\phi_k\\}_{k=1}^M$ 是固定的、可微的基函数。能量匹配通过最小化能量标签的正则化平方误差和来训练 $w$，而力匹配则通过最小化由模型力 $F_w(x) = -\\frac{d}{dx}E_w(x)$ 计算出的力标签的正则化平方误差和来训练 $w$。具体来说，对于训练输入 $\\{x_i\\}_{i=1}^{N}$、能量 $y^{(E)}_i = E_{\\mathrm{true}}(x_i)$ 和力 $y^{(F)}_i = F_{\\mathrm{true}}(x_i)$，这两个优化问题是\n$$\n\\min_{w \\in \\mathbb{R}^{M}} \\left[ \\sum_{i=1}^{N} \\left( E_w(x_i) - y^{(E)}_i \\right)^2 + \\lambda \\lVert w \\rVert_2^2 \\right],\n\\qquad\n\\min_{w \\in \\mathbb{R}^{M}} \\left[ \\sum_{i=1}^{N} \\left( F_w(x_i) - y^{(F)}_i \\right)^2 + \\lambda \\lVert w \\rVert_2^2 \\right],\n$$\n其中岭参数 $\\lambda  0$。这些问题产生闭式解的正规方程。对于能量匹配，如果 $\\Phi \\in \\mathbb{R}^{N \\times M}$ 的行是 $\\Phi_{i,:} = \\big(\\phi_1(x_i),\\ldots,\\phi_M(x_i)\\big)$ 且 $y^{(E)} \\in \\mathbb{R}^N$，那么\n$$\nw_{\\mathrm{E}} = \\arg\\min_w \\lVert \\Phi w - y^{(E)} \\rVert_2^2 + \\lambda \\lVert w \\rVert_2^2\n= \\left( \\Phi^\\top \\Phi + \\lambda I \\right)^{-1} \\Phi^\\top y^{(E)}.\n$$\n对于力匹配，如果 $G \\in \\mathbb{R}^{N \\times M}$ 的行是 $G_{i,:} = \\big(-\\tfrac{d}{dx}\\phi_1(x_i),\\ldots,-\\tfrac{d}{dx}\\phi_M(x_i)\\big)$ 且 $y^{(F)} \\in \\mathbb{R}^N$，那么\n$$\nw_{\\mathrm{F}} = \\arg\\min_w \\lVert G w - y^{(F)} \\rVert_2^2 + \\lambda \\lVert w \\rVert_2^2\n= \\left( G^\\top G + \\lambda I \\right)^{-1} G^\\top y^{(F)}.\n$$\n\n在每次测试中，对于所有训练集大小，您都必须使用一个固定容量的模型，其基函数如下。设 $M$ 为基函数的总数，由一个常数基 $\\phi_1(x) = 1$ 和 $M-1$ 个高斯函数 $\\phi_k(x) = \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\frac{x-c_{k}}{\\sigma}\\right)^2\\right)$（对于 $k \\in \\{2,\\ldots,M\\}$）组成，其中 $\\{c_k\\}$ 是在定义域上均匀间隔的中心点，$\\sigma$ 是由定义域和 $M$ 决定的固定宽度。对于每次测试，设中心点在指定的定义域上均匀间隔，宽度为 $\\sigma = 1.5\\,\\Delta$，其中 $\\Delta$ 是相邻中心点之间的间距。每个测试用例的总容量 $M$ 固定为 $M=20$；因此必须使用一个常数基加上 $M-1=19$ 个高斯函数。\n\n对于给定的测试，训练输入必须是指定定义域上的 $N$ 个均匀间隔的点，测试网格必须是同一域上的 $T$ 个均匀间隔的点，其中 $T=1000$。对于每个模型（$w_{\\mathrm{E}}$ 和 $w_{\\mathrm{F}}$），性能必须以测试网格上能量的平均绝对误差（MAE）来衡量：\n$$\n\\mathrm{MAE}(w) = \\frac{1}{T}\\sum_{j=1}^{T} \\left| E_w(x^{\\mathrm{test}}_j) - E_{\\mathrm{true}}(x^{\\mathrm{test}}_j) \\right| \\quad \\text{单位为哈特里（Hartree）}。\n$$\n对于任一训练策略，学习曲线是将训练集大小 $N$ 映射到 $\\mathrm{MAE}(w(N))$ 的函数，其中所有其他要素都保持不变。数据效率被量化为达到目标 MAE 阈值 $\\varepsilon$ 所需的最小训练集大小 $N_{\\min}$：\n$$\nN_{\\min}(\\varepsilon) = \\min \\left\\{ N \\in \\mathcal{N} \\,:\\, \\mathrm{MAE}(w(N)) \\le \\varepsilon \\right\\},\n$$\n其中 $\\mathcal{N}$ 是一组预定义的候选训练集大小。如果对于任何 $N \\in \\mathcal{N}$ 都未达到该阈值，则 $N_{\\min}(\\varepsilon)$ 返回 $-1$。\n\n您必须使用以下适用于所有测试的固定要素来实现上述内容：\n- 原子单位：能量单位为哈特里（Hartree），距离单位为玻尔（bohr）。所有中间和最终计算都必须使用这些单位。任何最终的样本复杂度输出都是无单位的整数。\n- 如上所述的基函数规格，$M=20$。\n- 岭参数 $\\lambda = 10^{-8}$。\n- 候选训练集大小 $\\mathcal{N} = [\\,8,\\,12,\\,16,\\,24,\\,32,\\,48,\\,64,\\,96,\\,128\\,]$。\n- 测试网格大小 $T=1000$ 个点，分布在测试的定义域上。\n\n定义三个科学上真实的测试用例。在每个用例中，距离单位为玻尔（bohr），能量单位为哈特里（Hartree）：\n\n- 测试用例 1（带倾斜的双势阱）：\n  - 定义域 $[x_{\\min},x_{\\max}] = [-1.5,\\,1.5]$。\n  - 真实 PES $E_{\\mathrm{true}}(x) = a\\,(x^2 - b^2)^2 + d\\,x$，其中 $a=0.02$，$b=1.0$，$d=0.005$。\n  - 目标阈值 $\\varepsilon = 4 \\times 10^{-3}$。\n\n- 测试用例 2（类莫尔斯势键）：\n  - 定义域 $[x_{\\min},x_{\\max}] = [0.5,\\,3.0]$。\n  - 真实 PES $E_{\\mathrm{true}}(x) = D\\,\\big(1 - e^{-a(x-x_0)}\\big)^2 - D$，其中 $D=0.02$，$a=1.5$，$x_0=1.5$。\n  - 目标阈值 $\\varepsilon = 3 \\times 10^{-3}$。\n\n- 测试用例 3（单势阱非谐性）：\n  - 定义域 $[x_{\\min},x_{\\max}] = [-1.2,\\,1.2]$。\n  - 真实 PES $E_{\\mathrm{true}}(x) = k_4 x^4 + k_2 x^2 + k_1 x$，其中 $k_4=0.01$，$k_2=0.02$，$k_1=0.005$。\n  - 目标阈值 $\\varepsilon = 5 \\times 10^{-3}$。\n\n对于每个测试用例，您必须：\n- 如上所述，构建包含 $M=20$ 个基函数的集合，其中包括一个常数基以及中心点在定义域上均匀间隔、宽度 $\\sigma$ 为中心点间距 1.5 倍的高斯基。\n- 对于每个 $N \\in \\mathcal{N}$，通过求解相应的正则化正规方程，使用在 $N$ 个训练点上精确计算的能量和力，来计算 $w_{\\mathrm{E}}(N)$ 和 $w_{\\mathrm{F}}(N)$。\n- 通过在测试网格上计算 $\\mathrm{MAE}(w_{\\mathrm{E}}(N))$ 和 $\\mathrm{MAE}(w_{\\mathrm{F}}(N))$ 来评估学习曲线。\n- 确定 $N^{(\\mathrm{E})}_{\\min}$ 和 $N^{(\\mathrm{F})}_{\\min}$，分别为能量匹配和力匹配达到该测试用例阈值 $\\varepsilon$ 所需的最小 $N \\in \\mathcal{N}$。\n- 如果 $N^{(\\mathrm{E})}_{\\min}$ 和 $N^{(\\mathrm{F})}_{\\min}$ 均为正数，则计算数据效率比 $r = \\frac{N^{(\\mathrm{E})}_{\\min}}{N^{(\\mathrm{F})}_{\\min}}$（浮点数）；否则，将 $r$ 设置为 $-1.0$。\n\n角度单位不适用。不使用百分比。\n\n您的程序必须生成单行输出，其中包含三个测试用例的结果，格式为方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个包含 $[N^{(\\mathrm{E})}_{\\min}, N^{(\\mathrm{F})}_{\\min}, r]$ 的长度为三的列表。例如，输出格式必须与“[ [NE1,NF1,r1],[NE2,NF2,r2],[NE3,NF3,r3] ]”完全一样，除了示例中显示的空格外，不需要其他空格。程序不得读取任何输入。\n\n请根据这些规格提供一个完整且可运行的解决方案。", "solution": "我们通过构建和分析学习曲线，比较在固定模型容量下，使用能量匹配和力匹配拟合势能面（PES）时的数据效率。基本原理始于物理定义：对于一维势能面，力是能量的负导数，即 $F_{\\mathrm{true}}(x) = -\\frac{d}{dx}E_{\\mathrm{true}}(x)$。我们使用一个参数化能量模型 $E_w(x) = \\sum_{k=1}^{M} w_k \\phi_k(x)$，其中 $M$ 在所有训练集大小中都保持固定，以确保容量恒定。\n\n训练策略由正则化最小二乘问题定义。对于能量匹配，给定训练输入 $\\{x_i\\}_{i=1}^{N}$ 和能量标签 $y^{(E)}_i = E_{\\mathrm{true}}(x_i)$，我们最小化经验风险加上岭惩罚项\n$$\nJ_{\\mathrm{E}}(w) = \\sum_{i=1}^{N} \\left( E_w(x_i) - y^{(E)}_i \\right)^2 + \\lambda \\lVert w \\rVert_2^2.\n$$\n设 $\\Phi \\in \\mathbb{R}^{N \\times M}$ 是设计矩阵，其元素为 $\\Phi_{ik} = \\phi_k(x_i)$，$y^{(E)} \\in \\mathbb{R}^N$ 是目标向量。最小化器满足正规方程\n$$\n\\frac{\\partial J_{\\mathrm{E}}}{\\partial w} = 2\\Phi^\\top(\\Phi w - y^{(E)}) + 2\\lambda w = 0 \\quad \\Longrightarrow \\quad (\\Phi^\\top \\Phi + \\lambda I) w = \\Phi^\\top y^{(E)},\n$$\n因此\n$$\nw_{\\mathrm{E}} = (\\Phi^\\top \\Phi + \\lambda I)^{-1} \\Phi^\\top y^{(E)}.\n$$\n\n对于力匹配，我们使用力标签 $y^{(F)}_i = F_{\\mathrm{true}}(x_i)$ 并最小化\n$$\nJ_{\\mathrm{F}}(w) = \\sum_{i=1}^{N} \\left( F_w(x_i) - y^{(F)}_i \\right)^2 + \\lambda \\lVert w \\rVert_2^2,\n$$\n其中 $F_w(x) = -\\frac{d}{dx}E_w(x) = -\\sum_{k=1}^{M} w_k \\frac{d}{dx}\\phi_k(x)$。定义 $G \\in \\mathbb{R}^{N \\times M}$，其元素为 $G_{ik} = -\\frac{d}{dx}\\phi_k(x_i)$，且 $y^{(F)} \\in \\mathbb{R}^N$，则正规方程为\n$$\n\\frac{\\partial J_{\\mathrm{F}}}{\\partial w} = 2G^\\top(G w - y^{(F)}) + 2\\lambda w = 0 \\quad \\Longrightarrow \\quad (G^\\top G + \\lambda I) w = G^\\top y^{(F)},\n$$\n所以\n$$\nw_{\\mathrm{F}} = (G^\\top G + \\lambda I)^{-1} G^\\top y^{(F)}.\n$$\n\n我们采用带有常数项的高斯基，以确保模型能够拟合任意的能量偏移，这在物理上是有意义的，因为不同体系的绝对能量零点可能不同。基函数指定为\n- $\\phi_1(x) = 1$，\n- 对于 $k \\in \\{2,\\ldots,M\\}$，$\\phi_k(x) = \\exp\\!\\left( -\\frac{1}{2} \\left( \\frac{x - c_k}{\\sigma} \\right)^2 \\right)$，\n其中中心点 $\\{c_k\\}$ 在定义域上均匀间隔，宽度 $\\sigma$ 与中心点间距成比例。力匹配中使用的导数为\n$$\n\\frac{d}{dx}\\phi_k(x) = -\\frac{x - c_k}{\\sigma^2} \\, \\phi_k(x), \\quad \\text{所以} \\quad G_{ik} = -\\frac{d}{dx}\\phi_k(x_i) = \\frac{x_i - c_k}{\\sigma^2} \\phi_k(x_i),\n$$\n对于常数基，$\\frac{d}{dx}\\phi_1(x) = 0$，因此 $G$ 中对应的列为零。因为包含了岭项 $\\lambda \\lVert w \\rVert_2^2$ 且 $\\lambda = 10^{-8}$，所以 $(\\Phi^\\top \\Phi + \\lambda I)$ 和 $(G^\\top G + \\lambda I)$ 是正定的，因此是可逆的，从而确保了解的适定性。\n\n我们为一组候选训练集大小 $\\mathcal{N} = [\\,8,\\,12,\\,16,\\,24,\\,32,\\,48,\\,64,\\,96,\\,128\\,]$ 构建学习曲线。对于每个 $N \\in \\mathcal{N}$，我们在定义域上放置 $N$ 个均匀间隔的训练点，并从给定的真实 PES 计算精确的标签 $(y^{(E)}, y^{(F)})$。我们求解 $w_{\\mathrm{E}}(N)$ 和 $w_{\\mathrm{F}}(N)$，然后在 $T=1000$ 个均匀间隔点的测试网格上评估能量的平均绝对误差（MAE）：\n$$\n\\mathrm{MAE}(w) = \\frac{1}{T} \\sum_{j=1}^{T} \\left| E_w(x^{\\mathrm{test}}_j) - E_{\\mathrm{true}}(x^{\\mathrm{test}}_j) \\right|, \\quad \\text{以哈特里（Hartree）为单位}。\n$$\n\n在目标精度 $\\varepsilon$ 下的数据效率被量化为 $N_{\\min}(\\varepsilon)$，即满足 MAE 不超过 $\\varepsilon$ 的最小 $N \\in \\mathcal{N}$。如果不存在这样的 $N$，我们设置 $N_{\\min}(\\varepsilon) = -1$。我们报告 $N^{(\\mathrm{E})}_{\\min}$ 和 $N^{(\\mathrm{F})}_{\\min}$ 以及它们之间的比率\n$$\nr = \\begin{cases}\n\\frac{N^{(\\mathrm{E})}_{\\min}}{N^{(\\mathrm{F})}_{\\min}},  \\text{如果 } N^{(\\mathrm{E})}_{\\min} > 0 \\text{ 且 } N^{(\\mathrm{F})}_{\\min} > 0,\\\\\n-1.0,  \\text{否则}。\n\\end{cases}\n$$\n\n我们对三个测试用例执行上述步骤，每个用例都具有科学上合理的 PES 和以原子单位表示的定义域：\n- 测试 1：带倾斜的双势阱，$E_{\\mathrm{true}}(x) = a(x^2 - b^2)^2 + d x$，其中 $a=0.02$，$b=1.0$，$d=0.005$，定义域 $[-1.5, 1.5]$，目标 $\\varepsilon = 4\\times 10^{-3}$。\n  力为 $F_{\\mathrm{true}}(x) = -\\frac{d}{dx}E_{\\mathrm{true}}(x) = -4 a x (x^2 - b^2) - d$。\n- 测试 2：类莫尔斯势键，$E_{\\mathrm{true}}(x) = D (1 - e^{-a(x-x_0)})^2 - D$，其中 $D=0.02$，$a=1.5$，$x_0=1.5$，定义域 $[0.5, 3.0]$，目标 $\\varepsilon = 3\\times 10^{-3}$。\n  设 $u(x) = e^{-a(x-x_0)}$。则 $\\frac{d}{dx}E_{\\mathrm{true}}(x) = 2 D (1 - u) (a u)$，因此 $F_{\\mathrm{true}}(x) = - 2 D a u (1 - u)$。\n- 测试 3：单势阱非谐性，$E_{\\mathrm{true}}(x) = k_4 x^4 + k_2 x^2 + k_1 x$，其中 $k_4=0.01$，$k_2=0.02$，$k_1=0.005$，定义域 $[-1.2, 1.2]$，目标 $\\varepsilon = 5\\times 10^{-3}$。\n  力为 $F_{\\mathrm{true}}(x) = -\\frac{d}{dx}E_{\\mathrm{true}}(x) = -(4k_4 x^3 + 2k_2 x + k_1)$。\n\n算法步骤：\n1. 对于给定的测试，构建 $M=20$ 的基函数，中心点在定义域上均匀间隔，宽度 $\\sigma$ 为中心点间距的 1.5 倍。包括常数基 $\\phi_1(x)=1$。\n2. 对于每个 $N \\in \\mathcal{N}$，在定义域上创建 $N$ 个均匀间隔的训练点 $x_i$，计算标签 $y^{(E)}_i = E_{\\mathrm{true}}(x_i)$ 和 $y^{(F)}_i = F_{\\mathrm{true}}(x_i)$。\n3. 使用基函数及其导数构建能量设计矩阵 $\\Phi$ 和力设计矩阵 $G$，其中常数基的导数列设为零。\n4. 通过求解线性方程组 $(\\Phi^\\top \\Phi + \\lambda I) w = \\Phi^\\top y^{(E)}$ 和 $(G^\\top G + \\lambda I) w = G^\\top y^{(F)}$ 来得到 $w_{\\mathrm{E}}(N)$ 和 $w_{\\mathrm{F}}(N)$，而不是显式地计算矩阵的逆。\n5. 在 $T=1000$ 个点的测试网格上评估 $\\mathrm{MAE}(w_{\\mathrm{E}}(N))$ 和 $\\mathrm{MAE}(w_{\\mathrm{F}}(N))$，并确定每种方法满足测试阈值 $\\varepsilon$ 的最小 $N$。如果没有满足的，则该方法的输出为 $-1$。\n6. 按定义计算比率 $r$，并报告 $[N^{(\\mathrm{E})}_{\\min}, N^{(\\mathrm{F})}_{\\min}, r]$。\n\n该方法直接源于保守系统中能量与力之间的基本关系，以及经过充分检验的正则化最小二乘法（岭回归）公式。它还确保了在不同训练集大小下模型容量的固定，从而分离出样本大小对泛化能力的影响。最终输出将三个测试用例的结果聚合成一行，并遵循指定的格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gaussian_basis_and_derivative(x, centers, sigma):\n    \"\"\"\n    Compute Gaussian RBF basis values and their spatial derivatives for a 1D input array x.\n    Includes constant basis as the first column, whose derivative is zero.\n    Parameters:\n        x: shape (n,)\n        centers: shape (m,) for Gaussian centers (does not include constant basis)\n        sigma: scalar width\n    Returns:\n        Phi: shape (n, M) with M = 1 + m (constant + Gaussians)\n        dPhi_dx: shape (n, M) derivatives; first column is zeros\n    \"\"\"\n    x = np.asarray(x).reshape(-1, 1)         # (n,1)\n    centers = np.asarray(centers).reshape(1, -1)  # (1,m)\n    # Gaussian values for each x against each center\n    # G[i,k] = exp(-0.5 * ((x_i - c_k)/sigma)^2)\n    diff = (x - centers) / sigma\n    G = np.exp(-0.5 * diff**2)               # (n,m)\n    # Derivative of Gaussian wrt x: d/dx exp(-0.5 t^2) = exp(-0.5 t^2) * (-t) * (1/sigma)\n    # But since t = (x - c)/sigma, d/dx t = 1/sigma, so d/dx = -(x-c)/sigma^2 * G\n    dGdx = -(x - centers) / (sigma**2) * G   # (n,m)\n    # Assemble with constant basis\n    n = x.shape[0]\n    const = np.ones((n, 1))\n    dconst = np.zeros((n, 1))\n    Phi = np.concatenate([const, G], axis=1)        # (n, 1+m)\n    dPhi_dx = np.concatenate([dconst, dGdx], axis=1)\n    return Phi, dPhi_dx\n\ndef solve_ridge(A, b, lam):\n    # Solve (A^T A + lam I) w = A^T b robustly without explicit inversion.\n    ATA = A.T @ A\n    ATb = A.T @ b\n    M = ATA.shape[0]\n    reg = lam * np.eye(M)\n    w = np.linalg.solve(ATA + reg, ATb)\n    return w\n\ndef make_basis(domain, M_total):\n    \"\"\"\n    Construct centers and sigma for Gaussian basis with constant term included.\n    Returns:\n        centers: (M_total-1,) for Gaussians (excludes constant basis)\n        sigma: scalar width\n    \"\"\"\n    x_min, x_max = domain\n    m = M_total - 1\n    centers = np.linspace(x_min, x_max, m)\n    if m > 1:\n        delta = centers[1] - centers[0]\n    else:\n        delta = (x_max - x_min)\n    sigma = 1.5 * delta\n    return centers, sigma\n\ndef build_design_matrices(x_train, centers, sigma):\n    Phi, dPhi_dx = gaussian_basis_and_derivative(x_train, centers, sigma)\n    # For force matching, model force is F_w(x) = -d/dx E_w(x) = -(dPhi_dx @ w),\n    # so the design matrix that maps w to F is G = -dPhi_dx.\n    G = -dPhi_dx\n    return Phi, G\n\ndef eval_energy_model(x, w, centers, sigma):\n    Phi, _ = gaussian_basis_and_derivative(x, centers, sigma)\n    return Phi @ w\n\n# True PES and forces for test cases\ndef pes_double_well(x, a=0.02, b=1.0, d=0.005):\n    # E(x) = a (x^2 - b^2)^2 + d x\n    x = np.asarray(x)\n    E = a * (x**2 - b**2)**2 + d * x\n    F = - (4.0 * a * x * (x**2 - b**2) + d)\n    return E, F\n\ndef pes_morse(x, D=0.02, a=1.5, x0=1.5):\n    # E(x) = D (1 - exp(-a (x - x0)))^2 - D\n    x = np.asarray(x)\n    u = np.exp(-a * (x - x0))\n    E = D * (1.0 - u)**2 - D\n    dE_dx = 2.0 * D * (1.0 - u) * (a * u)  # derivative of E wrt x\n    F = -dE_dx\n    return E, F\n\ndef pes_anharmonic(x, k4=0.01, k2=0.02, k1=0.005):\n    # E(x) = k4 x^4 + k2 x^2 + k1 x\n    x = np.asarray(x)\n    E = k4 * x**4 + k2 * x**2 + k1 * x\n    dE_dx = 4.0 * k4 * x**3 + 2.0 * k2 * x + k1\n    F = -dE_dx\n    return E, F\n\ndef learning_curve_min_N(domain, E_F_func, epsilon, N_candidates, M_total=20, lam=1e-8, T=1000):\n    # Construct basis\n    centers, sigma = make_basis(domain, M_total)\n    # Test grid\n    x_test = np.linspace(domain[0], domain[1], T)\n    E_true_test, _ = E_F_func(x_test)\n    # Iterate over candidate N\n    N_min_E = -1\n    N_min_F = -1\n    for N in N_candidates:\n        x_train = np.linspace(domain[0], domain[1], N)\n        E_train, F_train = E_F_func(x_train)\n        Phi, G = build_design_matrices(x_train, centers, sigma)\n        # Solve ridge for energies\n        w_E = solve_ridge(Phi, E_train, lam)\n        # Solve ridge for forces\n        w_F = solve_ridge(G, F_train, lam)\n        # Evaluate MAE on test\n        E_pred_E = eval_energy_model(x_test, w_E, centers, sigma)\n        E_pred_F = eval_energy_model(x_test, w_F, centers, sigma)\n        mae_E = np.mean(np.abs(E_pred_E - E_true_test))\n        mae_F = np.mean(np.abs(E_pred_F - E_true_test))\n        if N_min_E == -1 and mae_E = epsilon:\n            N_min_E = N\n        if N_min_F == -1 and mae_F = epsilon:\n            N_min_F = N\n        # Early stop if both found\n        if (N_min_E != -1) and (N_min_F != -1):\n            break\n    # Ratio\n    if N_min_E > 0 and N_min_F > 0:\n        r = float(N_min_E) / float(N_min_F)\n    else:\n        r = -1.0\n    return N_min_E, N_min_F, r\n\ndef solve():\n    # Define test cases as specified\n    N_candidates = [8, 12, 16, 24, 32, 48, 64, 96, 128]\n    tests = [\n        # Test 1: Double well with tilt\n        {\n            \"domain\": (-1.5, 1.5),\n            \"E_F_func\": pes_double_well,\n            \"epsilon\": 4e-3\n        },\n        # Test 2: Morse-like bond\n        {\n            \"domain\": (0.5, 3.0),\n            \"E_F_func\": pes_morse,\n            \"epsilon\": 3e-3\n        },\n        # Test 3: Single-well anharmonic\n        {\n            \"domain\": (-1.2, 1.2),\n            \"E_F_func\": pes_anharmonic,\n            \"epsilon\": 5e-3\n        }\n    ]\n    results = []\n    for t in tests:\n        NE, NF, r = learning_curve_min_N(\n            domain=t[\"domain\"],\n            E_F_func=t[\"E_F_func\"],\n            epsilon=t[\"epsilon\"],\n            N_candidates=N_candidates,\n            M_total=20,\n            lam=1e-8,\n            T=1000\n        )\n        # Round ratio for cleaner output while keeping as float\n        if r >= 0:\n            r_out = round(r, 6)\n        else:\n            r_out = -1.0\n        results.append([NE, NF, r_out])\n    # Final print statement in the exact required format.\n    # Format as a single-line list of lists.\n    # Example format: [[NE1,NF1,r1],[NE2,NF2,r2],[NE3,NF3,r3]]\n    # Avoid spaces to match strict parsing; but problem allows spaces as in example.\n    # We'll include minimal spaces as shown.\n    inner = \",\".join(\"[\" + \",\".join(str(x) for x in triplet) + \"]\" for triplet in results)\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2903774"}, {"introduction": "训练得到一个机器学习力场后，仅仅在测试集上检验其预测精度是远远不够的；我们还必须验证它是否遵循了基本的物理定律。在玻恩-奥本海默近似下，力是势能标量场的负梯度，这意味着力场必须是保守的。本练习[@problem_id:2903810]将指导你实现一个重要的物理验证测试：通过数值计算力在闭合路径上的环流来检验其保守性。这个实践将使你能够诊断和量化模型中可能存在的非物理旋转分量，从而确保所学力场在分子动力学等应用中的可靠性。", "problem": "考虑一个在 Born-Oppenheimer 势能面（PES）上训练的机器学习（ML）模型所预测的二维构型空间中的原子间力场。在 Born-Oppenheimer 近似中，核间作用力是标量势能的负梯度，因此精确的力场是保守的：对于任何闭合回路，力的线积分为零。您需要设计一个保守性的数值测试，通过计算预测力沿闭合回路的线积分，并通过环流-面积关系量化旋度误差。\n\n您的程序必须为每个测试用例执行以下操作：\n- 使用 $N$ 个均匀间隔的样本，对一个以原点为中心、半径为 $R$ 的圆形回路按角度 $\\theta$（弧度，范围为 $[0,2\\pi]$）进行参数化。参数化形式为 $r(\\theta) = \\big(R\\cos\\theta, R\\sin\\theta\\big)$，其微分为 $dr = r'(\\theta)\\,d\\theta = \\big(-R\\sin\\theta, R\\cos\\theta\\big)\\,d\\theta$。\n- 通过复合梯形法则对被积函数 $g(\\theta) = \\mathbf{F}\\big(r(\\theta)\\big)\\cdot r'(\\theta)$ 在 $\\theta$ 上进行数值近似，计算线积分（功）$W = \\oint_{\\mathcal{C}} \\mathbf{F}(\\mathbf{r})\\cdot d\\mathbf{l}$。\n- 计算面积平均标量旋度（z分量）为 $\\bar{\\omega}_z = \\dfrac{1}{A}\\oint_{\\mathcal{C}} \\mathbf{F}\\cdot d\\mathbf{l}$，其中 $A = \\pi R^2$ 是回路面积。将 $W$ 解释为以 Hartree 为单位的能量，将 $\\bar{\\omega}_z$ 解释为以 Hartree 每 Bohr 平方为单位的量，两者均使用原子单位制，并报告这两个量。角度必须以弧度为单位。\n\n使用以下机器学习预测的力场。设保守参考势为\n$$\nE(x,y) = \\tfrac{1}{2}k(x^2+y^2) + a\\,x\\,y,\n$$\n其中 $k = 1.0$ 且 $a = 0.3$（在原子单位制中为无量纲）。定义保守力 $\\mathbf{F}_{\\mathrm{cons}}(x,y) = -\\nabla E(x,y)$，因此\n$$\nF_{x,\\mathrm{cons}}(x,y) = -k\\,x - a\\,y,\\quad F_{y,\\mathrm{cons}}(x,y) = -k\\,y - a\\,x.\n$$\n定义两个非保守微扰，旨在模拟机器学习模型的误差：\n- 均匀旋转分量 $\\mathbf{R}_1(x,y) = \\big(-y,\\; x\\big)$，强度为 $\\varepsilon = 10^{-3}$。\n- 空间变化的旋转分量 $\\mathbf{R}_2(x,y) = \\big(-y\\,(1+\\beta x^2),\\; x\\,(1+\\beta y^2)\\big)$，强度为 $\\varepsilon = 5\\times 10^{-4}$，且 $\\beta = 0.4$。\n\n构建以下预测力场：\n- $\\mathcal{F}_1(x,y) = \\mathbf{F}_{\\mathrm{cons}}(x,y)$\n- $\\mathcal{F}_2(x,y) = \\mathbf{F}_{\\mathrm{cons}}(x,y) + \\varepsilon\\,\\mathbf{R}_1(x,y)$\n- $\\mathcal{F}_4(x,y) = \\mathbf{F}_{\\mathrm{cons}}(x,y) + \\varepsilon\\,\\mathbf{R}_2(x,y)$\n\n您的程序必须为以下这套包含回路半径和样本数的测试套件评估这些量：\n- 测试用例 $1$：力场 $\\mathcal{F}_1$，半径 $R = 0.5$ Bohr，样本数 $N = 4096$。\n- 测试用例 $2$：力场 $\\mathcal{F}_2$，半径 $R = 1.0$ Bohr，样本数 $N = 8192$。\n- 测试用例 $3$：力场 $\\mathcal{F}_2$，半径 $R = 2.0$ Bohr，样本数 $N = 8192$。\n- 测试用例 $4$：力场 $\\mathcal{F}_4$，半径 $R = 1.5$ Bohr，样本数 $N = 16384$。\n\n对于每个测试用例，计算：\n- 线积分 $W$（单位：Hartree）。\n- 面积平均旋度 $\\bar{\\omega}_z$（单位：Hartree 每 Bohr 平方）。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，条目顺序为 $[W_1,\\bar{\\omega}_{z,1},W_2,\\bar{\\omega}_{z,2},W_3,\\bar{\\omega}_{z,3},W_4,\\bar{\\omega}_{z,4}]$。所有角度必须以弧度为单位，能量必须以 Hartree 表示。不应打印任何额外文本。", "solution": "问题陈述经过验证。\n\n**步骤 1：提取的已知信息**\n- **任务**：数值测试机器学习预测力场的保守性。\n- **方法**：计算闭合圆形回路上的线积分 $W = \\oint_{\\mathcal{C}} \\mathbf{F}(\\mathbf{r})\\cdot d\\mathbf{l}$ 和面积平均标量旋度 $\\bar{\\omega}_z = W/A$。\n- **回路**：圆形，半径为 $R$，以原点为中心。由 $\\mathbf{r}(\\theta) = (R\\cos\\theta, R\\sin\\theta)$ 参数化，其中 $\\theta \\in [0, 2\\pi]$。\n- **数值积分**：使用 $N$ 个均匀间隔样本的复合梯形法则。被积函数为 $g(\\theta) = \\mathbf{F}(\\mathbf{r}(\\theta))\\cdot \\mathbf{r}'(\\theta)$，其中 $\\mathbf{r}'(\\theta) = (-R\\sin\\theta, R\\cos\\theta)$。\n- **保守势和力**：$E(x,y) = \\frac{1}{2}k(x^2+y^2) + a\\,x\\,y$，其中 $k=1.0, a=0.3$。保守力为 $\\mathbf{F}_{\\mathrm{cons}}(x,y) = -\\nabla E = (-k\\,x - a\\,y, -k\\,y - a\\,x)$。\n- **非保守微扰**：\n    - $\\mathbf{R}_1(x,y) = (-y, x)$，强度为 $\\varepsilon = 10^{-3}$。\n    - $\\mathbf{R}_2(x,y) = (-y(1+\\beta x^2), x(1+\\beta y^2))$，强度为 $\\varepsilon = 5 \\times 10^{-4}$，且 $\\beta = 0.4$。\n- **待测试的力场**：\n    - $\\mathcal{F}_1 = \\mathbf{F}_{\\mathrm{cons}}$\n    - $\\mathcal{F}_2 = \\mathbf{F}_{\\mathrm{cons}} + \\varepsilon \\mathbf{R}_1$ （其中 $\\varepsilon=10^{-3}$）\n    - $\\mathcal{F}_4 = \\mathbf{F}_{\\mathrm{cons}} + \\varepsilon \\mathbf{R}_2$ （其中 $\\varepsilon=5 \\times 10^{-4}, \\beta=0.4$）\n- **测试用例**：\n    1. 力场 $\\mathcal{F}_1$，$R=0.5$ Bohr，$N=4096$。\n    2. 力场 $\\mathcal{F}_2$，$R=1.0$ Bohr，$N=8192$。\n    3. 力场 $\\mathcal{F}_2$，$R=2.0$ Bohr，$N=8192$。\n    4. 力场 $\\mathcal{F}_4$，$R=1.5$ Bohr，$N=16384$。\n- **输出**：对于每个用例，计算功 $W$（Hartree）和面积平均旋度 $\\bar{\\omega}_z$（Hartree/Bohr$^2$）。生成一个单一列表：$[W_1, \\bar{\\omega}_{z,1}, W_2, \\bar{\\omega}_{z,2}, \\dots]$。\n\n**步骤 2：使用提取的已知信息进行验证**\n根据验证标准对问题进行评估。\n- **科学依据**：该问题基于矢量微积分（斯托克斯定理）和经典力学（保守力）的基本原理。将其应用于在 Born-Oppenheimer 近似背景下验证 ML 派生的原子间势，是计算量子化学中一个有效且相关的主题。\n- **良态问题**：所有必要的数学函数、物理常数和数值参数（$R, N$）都已精确定义。计算过程已明确说明（复合梯形法则）。可以计算出唯一、稳定且有意义的解。\n- **客观性**：问题以精确、正式的语言陈述，没有任何主观性或歧义。\n\n**步骤 3：结论与行动**\n该问题是**有效的**。它是一个定义明确、具有清晰科学依据的计算练习。可以构建一个分步的解决方案。\n\n**解题思路**\n\n目标是量化几个模型力场的非保守特性。一个力场 $\\mathbf{F}$ 是保守的，当且仅当它是一个标量势的梯度，即 $\\mathbf{F} = -\\nabla E$。一个直接的推论是它的旋度为零，$\\nabla \\times \\mathbf{F} = \\mathbf{0}$。对于一个二维场 $\\mathbf{F}(x,y) = (F_x(x,y), F_y(x,y))$，旋度是一个只有 $z$ 分量的矢量，$(\\nabla \\times \\mathbf{F})_z = \\frac{\\partial F_y}{\\partial x} - \\frac{\\partial F_x}{\\partial y}$。\n\n斯托克斯定理将矢量场沿简单闭合曲线 $\\mathcal{C}$ 的线积分（环流）与该场旋度在由该曲线包围的面积 $A$ 上的面积分联系起来：\n$$\nW = \\oint_{\\mathcal{C}} \\mathbf{F} \\cdot d\\mathbf{l} = \\iint_{A} (\\nabla \\times \\mathbf{F}) \\cdot d\\mathbf{A} = \\iint_{A} (\\nabla \\times \\mathbf{F})_z \\,dx\\,dy\n$$\n对于一个保守场，$W=0$。非零的 $W$ 值表示一个非保守场。待计算的量，即面积平均标量旋度 $\\bar{\\omega}_z$，就是根据这个定理定义的：\n$$\n\\bar{\\omega}_z = \\frac{1}{A} \\oint_{\\mathcal{C}} \\mathbf{F} \\cdot d\\mathbf{l}\n$$\n这提供了一个直接度量力场在所包围区域上的平均非保守旋转特性的方法。\n\n该问题要求对线积分进行数值计算。路径 $\\mathcal{C}$ 是一个以原点为中心、半径为 $R$ 的圆，由角度 $\\theta \\in [0, 2\\pi]$ 参数化：\n$$\n\\mathbf{r}(\\theta) = (x(\\theta), y(\\theta)) = (R\\cos\\theta, R\\sin\\theta)\n$$\n微分线元为：\n$$\nd\\mathbf{l} = \\mathbf{r}'(\\theta) d\\theta = (-R\\sin\\theta, R\\cos\\theta) d\\theta\n$$\n因此，线积分被转换为关于 $\\theta$ 的定积分：\n$$\nW = \\int_{0}^{2\\pi} \\mathbf{F}(\\mathbf{r}(\\theta)) \\cdot \\mathbf{r}'(\\theta) \\, d\\theta\n$$\n设被积函数为 $g(\\theta) = \\mathbf{F}(\\mathbf{r}(\\theta)) \\cdot \\mathbf{r}'(\\theta)$。我们需要用具有 $N$ 个样本的复合梯形法则来近似 $W = \\int_{0}^{2\\pi} g(\\theta) d\\theta$。对于一个在其周期上积分的周期函数，该法则简化为对均匀间隔点 $\\theta_i = i \\cdot \\Delta\\theta$（其中 $\\Delta\\theta = 2\\pi/N$，对于 $i=0, 1, \\dots, N-1$）的求和。\n$$\nW \\approx \\Delta\\theta \\sum_{i=0}^{N-1} g(\\theta_i) = \\frac{2\\pi}{N} \\sum_{i=0}^{N-1} g(\\theta_i)\n$$\n我们现在为每个特定的力场定义被积函数 $g(\\theta)$。常数为 $k=1.0$ 和 $a=0.3$。\n\n**力场 $\\mathcal{F}_1$**：此力场根据其构造是保守的。\n$\\mathcal{F}_1(x,y) = \\mathbf{F}_{\\mathrm{cons}}(x,y) = (-kx - ay, -ky - ax)$。\n代入参数化 $x=R\\cos\\theta, y=R\\sin\\theta$ 并与 $\\mathbf{r}'(\\theta) = (-R\\sin\\theta, R\\cos\\theta)$ 求点积：\n\\begin{align*}\ng_1(\\theta) = (-kR\\cos\\theta - aR\\sin\\theta)(-R\\sin\\theta) + (-kR\\sin\\theta - aR\\cos\\theta)(R\\cos\\theta) \\\\\n= R^2(k\\cos\\theta\\sin\\theta + a\\sin^2\\theta) - R^2(k\\sin\\theta\\cos\\theta + a\\cos^2\\theta) \\\\\n= aR^2(\\sin^2\\theta - \\cos^2\\theta) = -aR^2\\cos(2\\theta)\n\\end{align*}\n其解析积分为 $\\int_0^{2\\pi} -aR^2\\cos(2\\theta) \\,d\\theta = 0$。数值计算结果应接近机器精度。\n\n**力场 $\\mathcal{F}_2$**：此力场包含一个均匀的旋转微扰。$\\mathcal{F}_2 = \\mathbf{F}_{\\mathrm{cons}} + \\varepsilon_1 \\mathbf{R}_1$，其中 $\\varepsilon_1 = 10^{-3}$。\n线积分是线性的，所以 $W_2 = \\oint \\mathbf{F}_{\\mathrm{cons}} \\cdot d\\mathbf{l} + \\varepsilon_1 \\oint \\mathbf{R}_1 \\cdot d\\mathbf{l}$。第一项为零。\n微扰项的被积函数为 $\\varepsilon_1 \\mathbf{R}_1(\\mathbf{r}(\\theta)) \\cdot \\mathbf{r}'(\\theta)$。\n对于 $\\mathbf{R}_1(x,y) = (-y, x)$，在路径上我们有 $\\mathbf{R}_1(\\mathbf{r}(\\theta)) = (-R\\sin\\theta, R\\cos\\theta) = \\mathbf{r}'(\\theta)$。\n因此，被积函数为 $\\varepsilon_1 \\mathbf{r}'(\\theta) \\cdot \\mathbf{r}'(\\theta) = \\varepsilon_1 |\\mathbf{r}'(\\theta)|^2 = \\varepsilon_1 R^2$。\n总被积函数为 $g_2(\\theta) = -aR^2\\cos(2\\theta) + \\varepsilon_1 R^2$。其解析积分为 $W_2 = 2\\pi\\varepsilon_1 R^2$。\n面积平均旋度为 $\\bar{\\omega}_{z,2} = W_2 / (\\pi R^2) = 2\\varepsilon_1$。\n\n**力场 $\\mathcal{F}_4$**：此力场包含一个空间变化的旋转微扰。$\\mathcal{F}_4 = \\mathbf{F}_{\\mathrm{cons}} + \\varepsilon_2 \\mathbf{R}_2$，其中 $\\varepsilon_2 = 5 \\times 10^{-4}, \\beta=0.4$。\n同样，我们关注微扰项的积分。被积函数为 $\\varepsilon_2 \\mathbf{R}_2(\\mathbf{r}(\\theta)) \\cdot \\mathbf{r}'(\\theta)$。\n$\\mathbf{R}_2(x,y) = (-y(1+\\beta x^2), x(1+\\beta y^2))$。\n\\begin{align*}\n\\mathbf{R}_2 \\cdot \\mathbf{r}' = \\varepsilon_2 [ (-y(1+\\beta x^2))(-R\\sin\\theta) + (x(1+\\beta y^2))(R\\cos\\theta) ] \\\\\n= \\varepsilon_2 [ (R\\sin\\theta(1+\\beta R^2\\cos^2\\theta))(R\\sin\\theta) + (R\\cos\\theta(1+\\beta R^2\\sin^2\\theta))(R\\cos\\theta) ] \\\\\n= \\varepsilon_2 R^2 [ \\sin^2\\theta(1+\\beta R^2\\cos^2\\theta) + \\cos^2\\theta(1+\\beta R^2\\sin^2\\theta) ] \\\\\n= \\varepsilon_2 R^2 [ \\sin^2\\theta+\\cos^2\\theta + \\beta R^2(\\sin^2\\theta\\cos^2\\theta + \\cos^2\\theta\\sin^2\\theta) ] \\\\\n= \\varepsilon_2 R^2 [ 1 + 2\\beta R^2 \\sin^2\\theta\\cos^2\\theta ] = \\varepsilon_2 R^2 [ 1 + \\frac{1}{2}\\beta R^2 \\sin^2(2\\theta) ]\n\\end{align*}\n总被积函数为 $g_4(\\theta) = -aR^2\\cos(2\\theta) + \\varepsilon_2 R^2 [ 1 + \\frac{1}{2}\\beta R^2 \\sin^2(2\\theta) ]$。\n解析上，利用 $\\int_0^{2\\pi} \\sin^2(2\\theta)d\\theta = \\pi$，积分为 $W_4 = \\varepsilon_2 R^2 [ 2\\pi + \\frac{1}{2}\\beta R^2 \\pi ] = 2\\pi\\varepsilon_2 R^2 (1 + \\frac{1}{4}\\beta R^2)$。\n面积平均旋度为 $\\bar{\\omega}_{z,4} = W_4 / (\\pi R^2) = 2\\varepsilon_2(1 + \\frac{1}{4}\\beta R^2)$。\n\n数值代码将为每个指定的测试用例实现这些被积函数的梯形法则求和，然后计算面积平均旋度。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the line integral of model force fields around a circular loop\n    to test for non-conservative character.\n    \"\"\"\n\n    # --- Define Constants and Force Fields ---\n\n    # Physical constants in atomic units\n    K_CONST = 1.0\n    A_CONST = 0.3\n    \n    # Perturbation parameters\n    EPS1 = 1e-3\n    EPS2 = 5e-4\n    BETA = 0.4\n\n    def f1_field(x, y):\n        \"\"\"Conservative reference force field F_cons.\"\"\"\n        fx = -K_CONST * x - A_CONST * y\n        fy = -K_CONST * y - A_CONST * x\n        return fx, fy\n\n    def f2_field(x, y):\n        \"\"\"F_cons + uniform rotational perturbation.\"\"\"\n        fx_cons = -K_CONST * x - A_CONST * y\n        fy_cons = -K_CONST * y - A_CONST * x\n        \n        # Perturbation R1 = (-y, x)\n        fx_pert = -y\n        fy_pert = x\n        \n        return fx_cons + EPS1 * fx_pert, fy_cons + EPS1 * fy_pert\n\n    def f4_field(x, y):\n        \"\"\"F_cons + spatially varying rotational perturbation.\"\"\"\n        fx_cons = -K_CONST * x - A_CONST * y\n        fy_cons = -K_CONST * y - A_CONST * x\n        \n        # Perturbation R2 = (-y(1+beta*x^2), x(1+beta*y^2))\n        fx_pert = -y * (1 + BETA * x**2)\n        fy_pert = x * (1 + BETA * y**2)\n        \n        return fx_cons + EPS2 * fx_pert, fy_cons + EPS2 * fy_pert\n    \n    # --- Define Test Cases ---\n\n    test_cases = [\n        {'field_func': f1_field, 'R': 0.5, 'N': 4096, 'label': 'F1'},\n        {'field_func': f2_field, 'R': 1.0, 'N': 8192, 'label': 'F2_R1'},\n        {'field_func': f2_field, 'R': 2.0, 'N': 8192, 'label': 'F2_R2'},\n        {'field_func': f4_field, 'R': 1.5, 'N': 16384, 'label': 'F4'},\n    ]\n\n    all_results = []\n    \n    # --- Execute Calculations for Each Case ---\n\n    for case in test_cases:\n        field_func = case['field_func']\n        R = case['R']\n        N = case['N']\n\n        # 1. Parameterize the circular loop with N samples\n        # The composite trapezoidal rule for a periodic function is a simple sum\n        # over N points.\n        d_theta = 2.0 * np.pi / N\n        thetas = np.arange(0.0, 2.0 * np.pi, d_theta)\n\n        # Path coordinates r(theta) = (x(theta), y(theta))\n        x_coords = R * np.cos(thetas)\n        y_coords = R * np.sin(thetas)\n\n        # Path derivative r'(theta) = (dx/dtheta, dy/dtheta)\n        dr_x = -R * np.sin(thetas)\n        dr_y = R * np.cos(thetas)\n\n        # 2. Evaluate the force field F(r(theta)) on the path\n        fx_vals, fy_vals = field_func(x_coords, y_coords)\n\n        # 3. Compute the integrand g(theta) = F(r(theta)) . r'(theta)\n        integrand = fx_vals * dr_x + fy_vals * dr_y\n\n        # 4. Numerically approximate the line integral W using the trapezoidal rule\n        # W = integral from 0 to 2pi of g(theta) dtheta\n        W = np.sum(integrand) * d_theta\n        \n        # 5. Compute the area-averaged scalar curl\n        A = np.pi * R**2\n        omega_z = W / A\n\n        all_results.extend([W, omega_z])\n\n    # --- Format and Print Final Output ---\n    \n    # Format the results into a single string as specified.\n    # [W_1, omega_z_1, W_2, omega_z_2, ...]\n    formatted_results = f\"[{','.join(f'{r:.10f}' for r in all_results)}]\"\n    print(formatted_results)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2903810"}]}