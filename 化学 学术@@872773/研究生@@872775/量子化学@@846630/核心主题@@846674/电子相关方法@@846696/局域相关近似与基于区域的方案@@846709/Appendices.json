{"hands_on_practices": [{"introduction": "局部相关方法的出发点是将离域的正则分子轨道转化为在空间上更紧凑的定域分子轨道（LMOs）。这个实践将引导你实现 Foster–Boys 定域化算法，这是实现这种转化的基石技术。通过一个迭代的 Jacobi 旋转过程，你将学习如何最小化轨道展宽，并定量地理解轨道定域化的概念。[@problem_id:2903150]", "problem": "给定一些小型模型系统的正交归一原子轨道 (AO) 基组和正则占据轨道集。您将通过在占据空间内进行幺正旋转来构建 Boys 局域化占据轨道，并使用 Foster–Boys 扩展泛函来量化局域化程度。所有算符和坐标均以原子单位表示；距离以玻尔（Bohr）为单位，扩展值以平方玻尔为单位。角度必须以弧度为单位。\n\n使用的基本依据和定义：\n- 占据分子轨道 (MO) 由 AO 系数矩阵 $\\;C \\in \\mathbb{R}^{N_\\mathrm{AO} \\times N_\\mathrm{occ}}\\;$ 表示，其列是正交归一的，其中 $N_\\mathrm{AO}$ 是 AO 的数量，$N_\\mathrm{occ}$ 是占据轨道的数量。正交归一性是相对于 AO 重叠矩阵 $\\;S\\;$ 而言的，此处取为单位矩阵 $\\;S = I\\;$。\n- 占据空间内的一个幺正变换由 $\\;U \\in \\mathbb{R}^{N_\\mathrm{occ} \\times N_\\mathrm{occ}}\\;$ 表示，满足 $\\;U^\\top U = I\\;$，得到变换后的轨道 $\\;C' = C U\\;$。\n- Boys 局域化的目标是最小化 Foster–Boys 扩展值\n$$\n\\Omega(C') \\;=\\; \\sum_{i=1}^{N_\\mathrm{occ}} \\left( \\langle \\phi_i | \\hat{\\mathbf{r}}^2 | \\phi_i \\rangle \\;-\\; \\lVert \\langle \\phi_i | \\hat{\\mathbf{r}} | \\phi_i \\rangle \\rVert^2 \\right),\n$$\n其中 $\\;\\phi_i\\;$ 是第 $i$ 个占据轨道，$\\;\\hat{\\mathbf{r}} = (\\hat{x},\\hat{y},\\hat{z})\\;$ 是位置算符，而 $\\;\\hat{\\mathbf{r}}^2 = \\hat{x}^2 + \\hat{y}^2 + \\hat{z}^2\\;$。\n- 在一个由高度局域化且正交归一的函数组成的 AO 基组中，函数中心位于 $\\;\\mathbf{r}_\\mu = (x_\\mu,y_\\mu,z_\\mu)\\;$，使用对角积分近似\n$$\nR_x = \\mathrm{diag}(x_1,\\dots,x_{N_\\mathrm{AO}}),\\quad\nR_y = \\mathrm{diag}(y_1,\\dots,y_{N_\\mathrm{AO}}),\\quad\nR_z = \\mathrm{diag}(z_1,\\dots,z_{N_\\mathrm{AO}}),\\quad\nR_2 = \\mathrm{diag}(x_1^2+y_1^2+z_1^2,\\dots,x_{N_\\mathrm{AO}}^2+y_{N_\\mathrm{AO}}^2+z_{N_\\mathrm{AO}}^2).\n$$\n- 对于表示 AO 基中某个 MO 的任意列向量 $\\;v\\;$，其质心分量和半径平方计算如下\n$$\nm_\\alpha(v) \\;=\\; v^\\top R_\\alpha\\, v \\quad (\\alpha \\in \\{x,y,z\\}), \\qquad\nr^2(v) \\;=\\; v^\\top R_2\\, v,\n$$\n轨道对扩展值的贡献为 $\\;r^2(v) - \\big(m_x(v)^2 + m_y(v)^2 + m_z(v)^2\\big)\\;$。\n\n您的任务是编写一个程序，对下面的每个测试用例，在占据空间内执行迭代的 Jacobi 配对幺正旋转，以最小化 $\\;\\Omega(C')\\;$，并遵循以下要求：\n- 从给定的正则占据轨道 $\\;C\\;$ 开始。\n- 在每次扫描中，考虑所有满足 $\\;p  q\\;$ 的不同占据轨道对 $\\;(p,q)\\;$，并选择一个旋转角 $\\;\\theta\\;$（以弧度为单位），该角度能局部优化这对轨道的 Boys 目标函数。将此 $2\\times 2$ 正交旋转应用于 $\\;C\\;$ 的第 $\\;p\\;$ 列和第 $\\;q\\;$ 列。\n- 迭代扫描，直至满足收敛标准，即单次扫描中应用的最大绝对旋转角小于 $\\;\\varepsilon = 10^{-10}\\;$，或者达到最大扫描次数 $\\;K = 1000\\;$，以先发生者为准。\n- 收敛后，计算最终的扩展值 $\\;\\Omega(C')\\;$（以平方玻尔为单位）。\n\n测试套件：\n为以下三种情况实现上述过程。在每种情况下，AO 坐标以列表 $\\;[(x_\\mu,y_\\mu,z_\\mu)]\\;$ 的形式给出（$\\;\\mu = 1,\\dots,N_\\mathrm{AO}\\;$），正则占据轨道 $\\;C\\;$ 以一个 $\\;N_\\mathrm{AO} \\times N_\\mathrm{occ}\\;$ 实数矩阵的形式给出，其列是正交归一的。\n\n- 情况 A（理想情况，离域于线性三原子分子）：\n  - $N_\\mathrm{AO} = 3$, $N_\\mathrm{occ} = 2$。\n  - AO 坐标：\n    $[( -1, 0, 0 ),\\ ( 0, 0, 0 ),\\ ( 1, 0, 0 )]$。\n  - 正则占据轨道 $C$：\n    第 1 列：$\\left[ \\frac{1}{\\sqrt{2}},\\ 0,\\ \\frac{1}{\\sqrt{2}} \\right]^\\top$，\n    第 2 列：$\\left[ \\frac{1}{2},\\ \\frac{1}{\\sqrt{2}},\\ -\\frac{1}{2} \\right]^\\top$。\n\n- 情况 B（边界情况，单个占据轨道）：\n  - $N_\\mathrm{AO} = 2$, $N_\\mathrm{occ} = 1$。\n  - AO 坐标：\n    $[( -\\frac{1}{2}, 0, 0 ),\\ ( \\frac{1}{2}, 0, 0 )]$。\n  - 正则占据轨道 $C$：\n    第 1 列：$\\left[ \\frac{1}{\\sqrt{2}},\\ \\frac{1}{\\sqrt{2}} \\right]^\\top$。\n\n- 情况 C（边缘情况，十字形结构中的对称性和近简并）：\n  - $N_\\mathrm{AO} = 4$, $N_\\mathrm{occ} = 2$。\n  - AO 坐标：\n    $[( -1, 0, 0 ),\\ ( 1, 0, 0 ),\\ ( 0, -1, 0 ),\\ ( 0, 1, 0 )]$。\n  - 正则占据轨道 $C$：\n    第 1 列：$\\left[ \\frac{1}{\\sqrt{2}},\\ 0,\\ 0,\\ \\frac{1}{\\sqrt{2}} \\right]^\\top$，\n    第 2 列：$\\left[ 0,\\ \\frac{1}{\\sqrt{2}},\\ \\frac{1}{\\sqrt{2}},\\ 0 \\right]^\\top$。\n\n程序要求：\n- 根据上述 AO 坐标构建 $\\;R_x\\;$、$\\;R_y\\;$、$\\;R_z\\;$ 和 $\\;R_2\\;$。\n- 在占据空间上实现 Jacobi 旋转过程，以最小化 $\\;\\Omega\\;$，收敛参数为 $\\;\\varepsilon = 10^{-10}\\;$ 和 $\\;K = 1000\\;$。\n- 对于每种情况，以浮点数形式报告最终的 $\\;\\Omega\\;$ 值（以平方玻尔为单位）。将输出表示为精确到小数点后六位的十进制数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按情况 A、情况 B、情况 C 顺序排列的结果，形式为方括号括起来的逗号分隔列表。例如，输出格式必须为\n$[r_A,r_B,r_C]$,\n其中 $\\;r_A,r_B,r_C\\;$ 分别是四舍五入到六位小数的最终 $\\;\\Omega\\;$ 值，该行中任何地方都不能有空格。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**步骤 1：提取给定条件**\n- **模型：** 正交归一原子轨道 (AO) 基组 ($\\;S = I\\;$)，正则占据分子轨道 (MO) 的 Boys 局域化。\n- **MO 系数矩阵：** $\\;C \\in \\mathbb{R}^{N_\\mathrm{AO} \\times N_\\mathrm{occ}}\\;$，其列是正交归一的。\n- **幺正变换：** $\\;C' = C U\\;$，其中 $\\;U \\in \\mathbb{R}^{N_\\mathrm{occ} \\times N_\\mathrm{occ}}\\;$ 是一个正交矩阵 ($\\;U^\\top U = I\\;$)。\n- **Foster–Boys 扩展泛函：** $\\;\\Omega(C') = \\sum_{i=1}^{N_\\mathrm{occ}} \\left( \\langle \\phi_i | \\hat{\\mathbf{r}}^2 | \\phi_i \\rangle - \\lVert \\langle \\phi_i | \\hat{\\mathbf{r}} | \\phi_i \\rangle \\rVert^2 \\right)\\;$。\n- **对角积分近似：** 位置算符 $\\;\\hat{x},\\hat{y},\\hat{z}\\;$ 和平方位置算符 $\\;\\hat{\\mathbf{r}}^2\\;$ 在 AO 基组中的矩阵表示是从 AO 中心坐标 $\\;\\mathbf{r}_\\mu = (x_\\mu,y_\\mu,z_\\mu)\\;$ 导出的对角矩阵：\n$$\nR_x = \\mathrm{diag}(x_1,\\dots,x_{N_\\mathrm{AO}}),\\quad\nR_y = \\mathrm{diag}(y_1,\\dots,y_{N_\\mathrm{AO}}),\\quad\nR_z = \\mathrm{diag}(z_1,\\dots,z_{N_\\mathrm{AO}})\n$$\n$$\nR_2 = \\mathrm{diag}(x_1^2+y_1^2+z_1^2,\\dots,x_{N_\\mathrm{AO}}^2+y_{N_\\mathrm{AO}}^2+z_{N_\\mathrm{AO}}^2)\n$$\n- **轨道性质：** 对于 MO 列向量 $\\;v\\;$，质心分量为 $\\;m_\\alpha(v) = v^\\top R_\\alpha v\\;$，半径平方为 $\\;r^2(v) = v^\\top R_2 v\\;$。\n- **优化过程：** 对 $\\;C\\;$ 的列进行迭代的 Jacobi 配对旋转。\n- **收敛标准：** 单次扫描中的最大绝对旋转角 $\\;|\\theta|_{\\max}  \\varepsilon = 10^{-10}\\;$，或最大扫描次数 $\\;K = 1000\\;$。\n- **测试用例：**\n  - **情况 A：** $N_\\mathrm{AO} = 3$, $N_\\mathrm{occ} = 2$。AO 坐标：$\\;[(-1, 0, 0), (0, 0, 0), (1, 0, 0)]\\;$。$C$ 的列：$\\;c_1 = [\\frac{1}{\\sqrt{2}}, 0, \\frac{1}{\\sqrt{2}}]^\\top\\;$, $\\;c_2 = [\\frac{1}{2}, \\frac{1}{\\sqrt{2}}, -\\frac{1}{2}]^\\top\\;$。\n  - **情况 B：** $N_\\mathrm{AO} = 2$, $N_\\mathrm{occ} = 1$。AO 坐标：$\\;[(-\\frac{1}{2}, 0, 0), (\\frac{1}{2}, 0, 0)]\\;$。$C$ 的列：$\\;c_1 = [\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}]^\\top\\;$。\n  - **情况 C：** $N_\\mathrm{AO} = 4$, $N_\\mathrm{occ} = 2$。AO 坐标：$\\;[(-1, 0, 0), (1, 0, 0), (0, -1, 0), (0, 1, 0)]\\;$。$C$ 的列：$\\;c_1 = [\\frac{1}{\\sqrt{2}}, 0, 0, \\frac{1}{\\sqrt{2}}]^\\top\\;$, $\\;c_2 = [0, \\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}, 0]^\\top\\;$。\n\n**步骤 2：使用提取的给定条件进行验证**\n该问题具有科学依据，描述了在特定对角积分近似下的标准 Boys-Foster 局域化方法。该方法在量子化学中是基础性的，用于将离域的正则轨道转换为化学上直观的局域化轨道，这是许多局域电子相关方法的前导步骤。问题陈述清晰，提供了所有必要的矩阵、参数和一个明确定义的收敛算法（Jacobi 扫描）。初始 MO 系数矩阵经核实确如所述是正交归一的。该问题是客观、定量、无歧义或矛盾的。它完全属于指定领域。\n\n**步骤 3：结论与行动**\n问题被判定为有效。将构建一个解决方案。\n\n**解题推导**\n目标是最小化 Foster-Boys 扩展值 $\\;\\Omega(C')$。该扩展值由两项组成：半径平方和与质心范数平方和。\n半径平方和 $\\;\\sum_i \\langle \\phi_i | \\hat{\\mathbf{r}}^2 | \\phi_i \\rangle = \\mathrm{Tr}(C'^\\top R_2 C')\\;$ 在正交变换 $\\;C' = CU\\;$ 下是不变的：\n$$\n\\mathrm{Tr}((CU)^\\top R_2 (CU)) = \\mathrm{Tr}(U^\\top C^\\top R_2 C U) = \\mathrm{Tr}(C^\\top R_2 C U U^\\top) = \\mathrm{Tr}(C^\\top R_2 C)\n$$\n因此，最小化扩展值 $\\;\\Omega\\;$ 等价于最大化轨道质心范数的平方和：\n$$\nL(C') = \\sum_{i=1}^{N_\\mathrm{occ}} \\lVert \\langle \\phi'_i | \\hat{\\mathbf{r}} | \\phi'_i \\rangle \\rVert^2 = \\sum_{i=1}^{N_\\mathrm{occ}} \\sum_{\\alpha \\in \\{x,y,z\\}} \\left( (c'_i)^\\top R_\\alpha c'_i \\right)^2\n$$\nJacobi 方法通过顺序优化轨道对来解决这个最大化问题。对于一对轨道 $\\;(\\phi_p, \\phi_q)\\;$，我们应用一个旋转：\n$$\n\\begin{pmatrix} \\phi'_p \\\\ \\phi'_q \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix} \\begin{pmatrix} \\phi_p \\\\ \\phi_q \\end{pmatrix}\n$$\n这个旋转只影响涉及轨道 $\\;p\\;$ 和 $\\;q\\;$ 的项。我们必须找到使 $\\;\\|\\langle \\phi'_p | \\hat{\\mathbf{r}} | \\phi'_p \\rangle\\|^2 + \\|\\langle \\phi'_q | \\hat{\\mathbf{r}} | \\phi'_q \\rangle\\|^2\\;$ 最大化的角度 $\\;\\theta\\;$。\n\n令 $\\;\\mathbf{A}_{ij}\\;$ 为轨道 $\\;i\\;$ 和 $\\;j\\;$ 之间的偶极矩矩阵元向量：\n$$\n\\mathbf{A}_{ij} = (\\langle \\phi_i | \\hat{x} | \\phi_j \\rangle, \\langle \\phi_i | \\hat{y} | \\phi_j \\rangle, \\langle \\phi_i | \\hat{z} | \\phi_j \\rangle) = (c_i^\\top R_x c_j, c_i^\\top R_y c_j, c_i^\\top R_z c_j)\n$$\n注意，由于算符是实数且对称的，因此 $\\;\\mathbf{A}_{ij} = \\mathbf{A}_{ji}\\;$。对于轨道对 $\\;(p,q)\\;$ 的最大化问题简化为找到使 $\\;\\|\\mathbf{A}'_{pp}\\|^2 + \\|\\mathbf{A}'_{qq}\\|^2\\;$ 最大化的 $\\;\\theta\\;$。\n变换后的质心 $\\;\\mathbf{A}'_{pp}\\;$ 和 $\\;\\mathbf{A}'_{qq}\\;$ 用原始矩阵元和旋转角 $\\;\\theta\\;$ 表示：\n$$\n\\mathbf{A}'_{pp} = \\mathbf{A}_{pp}\\cos^2\\theta + \\mathbf{A}_{qq}\\sin^2\\theta + 2\\mathbf{A}_{pq}\\sin\\theta\\cos\\theta\n$$\n$$\n\\mathbf{A}'_{qq} = \\mathbf{A}_{pp}\\sin^2\\theta + \\mathbf{A}_{qq}\\cos^2\\theta - 2\\mathbf{A}_{pq}\\sin\\theta\\cos\\theta\n$$\n令 $\\;\\mathbf{D} = \\mathbf{A}_{pp} - \\mathbf{A}_{qq}\\;$ 且 $\\;\\gamma = 2\\theta\\;$。需要最大化的和可以写成：\n$$\nL(\\theta) = \\text{const} + \\frac{1}{2} \\left[ \\left(\\|\\mathbf{D}\\|^2 - 4\\|\\mathbf{A}_{pq}\\|^2\\right) \\cos^2\\gamma + 4(\\mathbf{D}\\cdot\\mathbf{A}_{pq})\\sin\\gamma\\cos\\gamma \\right]\n$$\n将关于 $\\;\\gamma\\;$ 的导数设为零，得到最优角的条件：\n$$\n\\tan(2\\gamma) = \\tan(4\\theta) = \\frac{4(\\mathbf{D}\\cdot\\mathbf{A}_{pq})}{\\|\\mathbf{D}\\|^2 - 4\\|\\mathbf{A}_{pq}\\|^2}\n$$\n令分子为 $\\;X = 4(\\mathbf{A}_{pp} - \\mathbf{A}_{qq})\\cdot\\mathbf{A}_{pq}\\;$，分母为 $\\;Y = \\|\\mathbf{A}_{pp} - \\mathbf{A}_{qq}\\|^2 - 4\\|\\mathbf{A}_{pq}\\|^2\\;$。使目标函数最大化的最优角通过以下方式找到：\n$$\n\\theta = \\frac{1}{4} \\mathrm{atan2}(X, Y)\n$$\n这里使用 $\\;\\mathrm{atan2}(Y,X)\\;$ 函数来正确确定 $\\;4\\theta\\;$ 的象限（在我的约定中是 $\\mathrm{atan2}(y,x)$），以确保朝向最大值移动。在代码中，使用的 `numpy.arctan2(X, Y)` 对应于此公式。\n\n**算法**\n对每个测试用例：\n1.  根据给定的 AO 坐标构建对角矩阵 $\\;R_x, R_y, R_z\\;$ 和 $\\;R_2\\;$。\n2.  初始化 MO 系数矩阵 $\\;C\\;$，并设置扫描计数器和收敛标志。\n3.  开始迭代扫描。在每次扫描中：\n    a. 将当前扫描的最大角度 $\\;|\\theta|_{\\max}^{\\text{sweep}}\\;$ 初始化为零。\n    b. 对于每个不同的占据轨道对 $\\;(p, q)\\;$（$p  q$）：\n        i.   使用当前的 $\\;c_p\\;$ 和 $\\;c_q\\;$ 计算偶极矩矩阵元向量 $\\;\\mathbf{A}_{pp}\\;$、$\\;\\mathbf{A}_{qq}\\;$ 和 $\\;\\mathbf{A}_{pq}\\;$。\n        ii.  计算 $\\;\\tan(4\\theta)\\;$ 表达式的分子 $\\;X\\;$ 和分母 $\\;Y\\;$。\n        iii. 确定旋转角 $\\;\\theta = \\frac{1}{4} \\mathrm{atan2}(X, Y)\\;$。\n        iv.  更新本次扫描的最大角度记录：$\\;|\\theta|_{\\max}^{\\text{sweep}} = \\max(|\\theta|_{\\max}^{\\text{sweep}}, |\\theta|)\\;$。\n        v.   应用旋转来更新矩阵 $\\;C\\;$ 的列 $\\;c_p\\;$ 和 $\\;c_q\\;$：\n             $$\n             \\begin{pmatrix} c'_p  c'_q \\end{pmatrix} = \\begin{pmatrix} c_p  c_q \\end{pmatrix} \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix}\n             $$\n    c. 遍历所有轨道对后，检查收敛性。如果 $\\;|\\theta|_{\\max}^{\\text{sweep}}  \\varepsilon\\;$，或者达到最大扫描次数 $\\;K\\;$，则终止迭代。\n4.  收敛后，使用最终的局域化轨道矩阵 $\\;C'\\;$ 计算最终的总扩展值 $\\;\\Omega\\;$：\n    $$\n    \\Omega = \\sum_{i=0}^{N_\\mathrm{occ}-1} \\left[ (c'_i)^\\top R_2 c'_i - \\sum_{\\alpha \\in \\{x,y,z\\}} \\left( (c'_i)^\\top R_\\alpha c'_i \\right)^2 \\right]\n    $$\n5. 报告最终的 $\\;\\Omega\\;$ 值。对于 $\\;N_\\mathrm{occ} \\le 1\\;$ 的情况，无法进行旋转；初始扩展值即为最终扩展值。\n\n此过程针对指定的三个测试用例中的每一个实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    \n    # Define convergence parameters from the problem statement.\n    EPSILON = 1e-10\n    MAX_SWEEPS = 1000\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"ao_coords\": np.array([\n                [-1.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0]\n            ]),\n            \"C_initial\": np.array([\n                [1.0/np.sqrt(2.0), 1.0/2.0],\n                [0.0, 1.0/np.sqrt(2.0)],\n                [1.0/np.sqrt(2.0), -1.0/2.0]\n            ])\n        },\n        {\n            \"name\": \"Case B\",\n            \"ao_coords\": np.array([\n                [-0.5, 0.0, 0.0],\n                [0.5, 0.0, 0.0]\n            ]),\n            \"C_initial\": np.array([\n                [1.0/np.sqrt(2.0)],\n                [1.0/np.sqrt(2.0)]\n            ]).reshape(2, 1)\n        },\n        {\n            \"name\": \"Case C\",\n            \"ao_coords\": np.array([\n                [-1.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [0.0, -1.0, 0.0],\n                [0.0, 1.0, 0.0]\n            ]),\n            \"C_initial\": np.array([\n                [1.0/np.sqrt(2.0), 0.0],\n                [0.0, 1.0/np.sqrt(2.0)],\n                [0.0, 1.0/np.sqrt(2.0)],\n                [1.0/np.sqrt(2.0), 0.0]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_localization(\n            case[\"ao_coords\"],\n            case[\"C_initial\"],\n            MAX_SWEEPS,\n            EPSILON\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\ndef run_localization(ao_coords, C_initial, max_sweeps, epsilon):\n    \"\"\"\n    Performs Boys localization for a single case and returns the final spread.\n    \n    Args:\n        ao_coords (np.ndarray): AO coordinates, shape (N_AO, 3).\n        C_initial (np.ndarray): Initial MO coefficient matrix, shape (N_AO, N_occ).\n        max_sweeps (int): Maximum number of sweeps.\n        epsilon (float): Convergence threshold for the maximum rotation angle.\n        \n    Returns:\n        float: The final minimized Foster-Boys spread.\n    \"\"\"\n    n_ao, n_occ = C_initial.shape\n    C = C_initial.copy()\n\n    # If N_occ = 1, no localization is possible or needed.\n    if n_occ = 1:\n        return calculate_spread(ao_coords, C)\n\n    # Construct the diagonal operator matrices R_x, R_y, R_z\n    r_a = ao_coords[:, 0]\n    r_b = ao_coords[:, 1]\n    r_c = ao_coords[:, 2]\n    \n    Rx = np.diag(r_a)\n    Ry = np.diag(r_b)\n    Rz = np.diag(r_c)\n    \n    for sweep in range(max_sweeps):\n        max_angle_in_sweep = 0.0\n        \n        # Iterate over all distinct pairs of occupied orbitals (p, q)\n        for p in range(n_occ):\n            for q in range(p + 1, n_occ):\n                cp = C[:, p]\n                cq = C[:, q]\n\n                # Compute dipole matrix element vectors A_pp, A_qq, A_pq\n                A_pp = np.array([cp.T @ Rx @ cp, cp.T @ Ry @ cp, cp.T @ Rz @ cp])\n                A_qq = np.array([cq.T @ Rx @ cq, cq.T @ Ry @ cq, cq.T @ Rz @ cq])\n                A_pq = np.array([cp.T @ Rx @ cq, cp.T @ Ry @ cq, cp.T @ Rz @ cq])\n\n                # Calculate numerator and denominator for tan(4*theta)\n                D_vec = A_pp - A_qq\n                X_num = 4.0 * np.dot(D_vec, A_pq)\n                Y_den = np.dot(D_vec, D_vec) - 4.0 * np.dot(A_pq, A_pq)\n                \n                # Avoid division by zero when orbitals are already localized\n                if np.isclose(X_num, 0.0) and np.isclose(Y_den, 0.0):\n                    theta = 0.0\n                else:\n                    theta = 0.25 * np.arctan2(X_num, Y_den)\n\n                max_angle_in_sweep = max(max_angle_in_sweep, abs(theta))\n                \n                # Apply the rotation if the angle is significant\n                if abs(theta) > 1e-15: # A small threshold to avoid no-op\n                    c_theta = np.cos(theta)\n                    s_theta = np.sin(theta)\n                    \n                    # Original columns p and q\n                    cp_orig = C[:, p].copy()\n                    cq_orig = C[:, q].copy()\n                    \n                    # Update columns C_p and C_q\n                    C[:, p] = cp_orig * c_theta + cq_orig * s_theta\n                    C[:, q] = -cp_orig * s_theta + cq_orig * c_theta\n\n        # Check for convergence\n        if max_angle_in_sweep  epsilon:\n            break\n            \n    return calculate_spread(ao_coords, C)\n\n\ndef calculate_spread(ao_coords, C):\n    \"\"\"\n    Calculates the total Foster-Boys spread for a given set of orbitals.\n    \n    Args:\n        ao_coords (np.ndarray): AO coordinates, shape (N_AO, 3).\n        C (np.ndarray): MO coefficient matrix, shape (N_AO, N_occ).\n        \n    Returns:\n        float: The total spread.\n    \"\"\"\n    n_ao, n_occ = C.shape\n\n    # Construct operator matrices\n    r_a = ao_coords[:, 0]\n    r_b = ao_coords[:, 1]\n    r_c = ao_coords[:, 2]\n    \n    Rx = np.diag(r_a)\n    Ry = np.diag(r_b)\n    Rz = np.diag(r_c)\n    R2 = np.diag(r_a**2 + r_b**2 + r_c**2)\n\n    total_spread = 0.0\n    for i in range(n_occ):\n        ci = C[:, i]\n        \n        # Squared radius:\n        r2_i = ci.T @ R2 @ ci\n        # Centroid components:\n        mx_i = ci.T @ Rx @ ci\n        my_i = ci.T @ Ry @ ci\n        mz_i = ci.T @ Rz @ ci\n        # Centroid norm squared:\n        m2_i = mx_i**2 + my_i**2 + mz_i**2\n        \n        total_spread += (r2_i - m2_i)\n    return total_spread\n\nsolve()\n```", "id": "2903150"}, {"introduction": "一旦我们获得了定域轨道，下一步就是为每对轨道定义一个局部的虚拟轨道空间，即“域”。这个练习模拟了如何根据一个简单直观的距离标准来构建这些“对域”。通过这个实践，你将看到域的大小如何随着截断半径的变化而变化，这直接关系到局部相关方法的计算效率。[@problem_id:2903203]", "problem": "在量子化学中基于域的局域相关近似中，局域分子轨道（Localized Molecular Orbitals, LMOs）被假定在空间上是紧凑的，并且一个 LMO 或一个 LMO 对的相关空间被近似为位于该 LMO 显著区域附近的虚拟轨道子集。一种简单且广泛使用的域构建方法是基于距离的规则：对于每个 LMO，将其域定义为包含所有投影原子轨道（PAO）虚拟轨道的原子集合，这些原子的原子核位置位于以该 LMO 空间中心为球心、半径等于一个截断值的球体内。两个 LMO 的对域则定义为它们各自域的并集。基于此原理和欧几里得几何，实现一个程序来构建此类域，并计算每个 LMO 对中产生的虚拟轨道数随截断半径变化的函数。\n\n此问题的基本原理：\n- 三维空间中的欧几里得距离：对于位置向量为 $\\mathbf{r}$ 的点和位置向量为 $\\mathbf{R}$ 的点，距离为 $d = \\lVert \\mathbf{r} - \\mathbf{R} \\rVert_2 = \\sqrt{(x_r - x_R)^2 + (y_r - y_R)^2 + (z_r - z_R)^2}$。\n- 集合的并集：对于集合 $\\mathcal{A}$ 和 $\\mathcal{B}$，其并集为 $\\mathcal{A} \\cup \\mathcal{B} = \\{ x \\mid x \\in \\mathcal{A} \\text{ or } x \\in \\mathcal{B} \\}$。\n- 求和计数：如果每个原子 $a$ 贡献 $n_a$ 个虚拟轨道，且一个域包含原子集合 $\\mathcal{D}$，则该域中的虚拟轨道总数为 $N = \\sum_{a \\in \\mathcal{D}} n_a$。\n\n设置：\n- 给定 $5$ 个原子，其原子核坐标固定，单位为埃（Å）：\n  - 原子 $0$：$(0.0, 0.0, 0.0)$ Å\n  - 原子 $1$：$(1.5, 0.0, 0.0)$ Å\n  - 原子 $2$：$(3.0, 0.0, 0.0)$ Å\n  - 原子 $3$：$(4.5, 0.0, 0.0)$ Å\n  - 原子 $4$：$(3.0, 1.2, 0.0)$ Å\n- 与每个原子相关联的虚拟轨道数（例如，PAO 的数量）为：\n  - 原子 $0$：$3$\n  - 原子 $1$：$2$\n  - 原子 $2$：$4$\n  - 原子 $3$：$1$\n  - 原子 $4$：$3$\n- 给定 $3$ 个 LMO，其中心由原子坐标定义：\n  - LMO $0$：中心位于原子 $0$。\n  - LMO $1$：中心位于原子 $1$ 和原子 $2$ 的中点。\n  - LMO $2$：中心位于原子 $2$ 和原子 $4$ 的中点。\n- 基于距离的域规则（闭球）：对于一个截断半径 $R_c$（单位为 Å），LMO $i$ 的域是所有原子 $a$ 的集合，其中从 LMO 中心到原子位置的距离 $d_{ia}$ 满足 $d_{ia} \\le R_c$。LMO $i$ 和 $j$ 的对域是它们各自域的集合论并集。该对的虚拟轨道数是该并集集合中每个原子的虚拟轨道数之和（每个原子的虚拟轨道最多只计数一次）。\n\n任务：\n- 对于下面测试套件中的每个截断半径 $R_c$，按 $(0,1)$、$(0,2)$ 和 $(1,2)$ 这个确切顺序，计算无序 LMO 对的对域中的虚拟轨道数。\n- 所有距离单位均为埃（Å）。输出是无量纲的整数计数；不要在输出数字上附加任何单位。\n\n测试套件（截断半径 $R_c$ 单位为 Å）：\n- $0.6$\n- $1.2$\n- $2.25$\n- $3.5$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个无空格的逗号分隔列表的列表。对于给定顺序中的每个截断半径，输出一个包含三个整数的列表，分别对应于 LMO 对 $(0,1)$、$(0,2)$ 和 $(1,2)$。将这些按截断半径生成的列表聚合到一个外部列表中。例如，格式必须严格如 `[[a,b,c],[d,e,f],[g,h,i],[j,k,l]]`，且不含任何空格。", "solution": "我们从电子相关的局域性原理出发：在基于域的局域相关方案中，与一个局域占据实体相关的虚拟轨道空间被限制在一个空间邻域内。为了对此建模，我们使用 LMO (Localized Molecular Orbital) 中心周围的距离阈值，并将对域定义为各个 LMO 域的并集。计数过程可简化为欧几里得距离计算和集合求并集。\n\n数据：\n- 原子 $0$ 到 $4$ 的坐标（单位为埃，Å）：\n  - $\\mathbf{R}_0 = (0.0, 0.0, 0.0)$，\n  - $\\mathbf{R}_1 = (1.5, 0.0, 0.0)$，\n  - $\\mathbf{R}_2 = (3.0, 0.0, 0.0)$，\n  - $\\mathbf{R}_3 = (4.5, 0.0, 0.0)$，\n  - $\\mathbf{R}_4 = (3.0, 1.2, 0.0)$。\n- 每个原子的虚拟轨道数：$n_0 = 3$，$n_1 = 2$，$n_2 = 4$，$n_3 = 1$，$n_4 = 3$。\n- LMO 中心：\n  - $\\mathbf{r}_0 = \\mathbf{R}_0$。\n  - $\\mathbf{r}_1 = \\dfrac{\\mathbf{R}_1 + \\mathbf{R}_2}{2} = (2.25, 0.0, 0.0)$。\n  - $\\mathbf{r}_2 = \\dfrac{\\mathbf{R}_2 + \\mathbf{R}_4}{2} = (3.0, 0.6, 0.0)$。\n\n对于任意 LMO $i$ 和原子 $a$，欧几里得距离为\n$$\nd_{ia} = \\lVert \\mathbf{r}_i - \\mathbf{R}_a \\rVert_2 = \\sqrt{(x_i - x_a)^2 + (y_i - y_a)^2 + (z_i - z_a)^2}.\n$$\n对于给定的截断半径 $R_c$，单个 LMO 的域是原子索引集合\n$$\n\\mathcal{D}_i(R_c) = \\{ a \\in \\{0,1,2,3,4\\} \\mid d_{ia} \\le R_c \\}.\n$$\nLMO $i$ 和 $j$ 的对域是其并集\n$$\n\\mathcal{D}_{ij}(R_c) = \\mathcal{D}_i(R_c) \\cup \\mathcal{D}_j(R_c).\n$$\n对域中的虚拟轨道数为\n$$\nN_{ij}(R_c) = \\sum_{a \\in \\mathcal{D}_{ij}(R_c)} n_a.\n$$\n\n我们计算相关距离：\n\n对于 $\\mathbf{r}_0 = (0.0, 0.0, 0.0)$:\n- $d_{0,0} = 0.0$,\n- $d_{0,1} = 1.5$,\n- $d_{0,2} = 3.0$,\n- $d_{0,3} = 4.5$,\n- $d_{0,4} = \\sqrt{3.0^2 + 1.2^2} = \\sqrt{9 + 1.44} = \\sqrt{10.44} \\approx 3.231$.\n\n对于 $\\mathbf{r}_1 = (2.25, 0.0, 0.0)$:\n- $d_{1,0} = 2.25$,\n- $d_{1,1} = 0.75$,\n- $d_{1,2} = 0.75$,\n- $d_{1,3} = 2.25$,\n- $d_{1,4} = \\sqrt{0.75^2 + 1.2^2} = \\sqrt{0.5625 + 1.44} = \\sqrt{2.0025} \\approx 1.415$.\n\n对于 $\\mathbf{r}_2 = (3.0, 0.6, 0.0)$:\n- $d_{2,0} = \\sqrt{3.0^2 + 0.6^2} = \\sqrt{9 + 0.36} = \\sqrt{9.36} \\approx 3.059$,\n- $d_{2,1} = \\sqrt{1.5^2 + 0.6^2} = \\sqrt{2.25 + 0.36} = \\sqrt{2.61} \\approx 1.616$,\n- $d_{2,2} = 0.6$,\n- $d_{2,3} = \\sqrt{1.5^2 + 0.6^2} \\approx 1.616$,\n- $d_{2,4} = 0.6$.\n\n我们采用闭球规则 $d_{ia} \\le R_c$。现在为每个截断半径计算域和计数。\n\n截断半径 $R_c = 0.6$:\n- $\\mathcal{D}_0(0.6) = \\{0\\}$,\n- $\\mathcal{D}_1(0.6) = \\varnothing$,\n- $\\mathcal{D}_2(0.6) = \\{2,4\\}$。\n对域并集：\n- $\\mathcal{D}_{0,1}(0.6) = \\{0\\}$ 得到 $N_{0,1}(0.6) = n_0 = 3$。\n- $\\mathcal{D}_{0,2}(0.6) = \\{0,2,4\\}$ 得到 $N_{0,2}(0.6) = n_0 + n_2 + n_4 = 3 + 4 + 3 = 10$。\n- $\\mathcal{D}_{1,2}(0.6) = \\{2,4\\}$ 得到 $N_{1,2}(0.6) = n_2 + n_4 = 4 + 3 = 7$。\n此截断半径下的结果列表：$[3, 10, 7]$。\n\n截断半径 $R_c = 1.2$:\n- $\\mathcal{D}_0(1.2) = \\{0\\}$,\n- $\\mathcal{D}_1(1.2) = \\{1,2\\}$,\n- $\\mathcal{D}_2(1.2) = \\{2,4\\}$。\n对域并集：\n- $\\mathcal{D}_{0,1}(1.2) = \\{0,1,2\\}$ 得到 $N_{0,1}(1.2) = 3 + 2 + 4 = 9$。\n- $\\mathcal{D}_{0,2}(1.2) = \\{0,2,4\\}$ 得到 $N_{0,2}(1.2) = 3 + 4 + 3 = 10$。\n- $\\mathcal{D}_{1,2}(1.2) = \\{1,2,4\\}$ 得到 $N_{1,2}(1.2) = 2 + 4 + 3 = 9$。\n结果列表：$[9, 10, 9]$。\n\n截断半径 $R_c = 2.25$:\n- $\\mathcal{D}_0(2.25) = \\{0,1\\}$,\n- $\\mathcal{D}_1(2.25) = \\{0,1,2,3,4\\}$ (由于等于 $2.25$ 和更小的距离，包含所有原子),\n- $\\mathcal{D}_2(2.25) = \\{1,2,3,4\\}$。\n对域并集：\n- $\\mathcal{D}_{0,1}(2.25) = \\{0,1,2,3,4\\}$ 得到 $N_{0,1}(2.25) = 3 + 2 + 4 + 1 + 3 = 13$。\n- $\\mathcal{D}_{0,2}(2.25) = \\{0,1,2,3,4\\}$ 得到 $N_{0,2}(2.25) = 13$。\n- $\\mathcal{D}_{1,2}(2.25) = \\{0,1,2,3,4\\}$ 得到 $N_{1,2}(2.25) = 13$。\n结果列表：$[13, 13, 13]$。\n\n截断半径 $R_c = 3.5$:\n- $\\mathcal{D}_0(3.5) = \\{0,1,2,4\\}$ (原子 $3$ 在 $4.5$ 处被排除),\n- $\\mathcal{D}_1(3.5) = \\{0,1,2,3,4\\}$,\n- $\\mathcal{D}_2(3.5) = \\{0,1,2,3,4\\}$ (原子 $0$ 在 $\\approx 3.059$ 处被包含)。\n对域并集：\n- $\\mathcal{D}_{0,1}(3.5) = \\{0,1,2,3,4\\}$ 得到 $N_{0,1}(3.5) = 13$。\n- $\\mathcal{D}_{0,2}(3.5) = \\{0,1,2,3,4\\}$ 得到 $N_{0,2}(3.5) = 13$。\n- $\\mathcal{D}_{1,2}(3.5) = \\{0,1,2,3,4\\}$ 得到 $N_{1,2}(3.5) = 13$。\n结果列表：$[13, 13, 13]$。\n\n按截断半径 $[0.6, 1.2, 2.25, 3.5]$ 和轨道对 $(0,1)$, $(0,2)$, $(1,2)$ 的顺序汇总这三对的结果，预期的单行输出（无空格）为：\n$$\n[[3,10,7],[9,10,9],[13,13,13],[13,13,13]].\n$$\n\n程序应通过以下方式实现此逻辑：\n- 根据给定的原子坐标计算 LMO 中心，\n- 计算所有距离 $d_{ia}$，\n- 通过 $d_{ia} \\le R_c$ 进行阈值判断来形成域，\n- 对给定的 LMO 对取集合并集，\n- 对并集集合中的每个原子的虚拟轨道数求和，\n- 并以指定的精确格式打印嵌套列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_pair_virtual_counts(atom_positions, virtuals_per_atom, lmo_centers, cutoff):\n    \"\"\"\n    Compute number of virtuals per LMO pair at a given cutoff.\n    Unordered pairs considered: (0,1), (0,2), (1,2) for three LMOs.\n    \"\"\"\n    atom_positions = np.asarray(atom_positions, dtype=float)  # shape (A, 3)\n    lmo_centers = np.asarray(lmo_centers, dtype=float)        # shape (L, 3)\n    virtuals_per_atom = np.asarray(virtuals_per_atom, dtype=int)\n\n    # Distances: shape (L, A)\n    diff = lmo_centers[:, None, :] - atom_positions[None, :, :]\n    dists = np.linalg.norm(diff, axis=2)\n\n    # Domains: atoms within cutoff (inclusive)\n    domains = [set(np.nonzero(dists[i] = cutoff)[0].tolist()) for i in range(lmo_centers.shape[0])]\n\n    # Unordered pairs in lex order\n    pairs = [(0,1), (0,2), (1,2)]\n    counts = []\n    for i, j in pairs:\n        union_atoms = domains[i] | domains[j]\n        count = int(np.sum(virtuals_per_atom[list(union_atoms)])) if union_atoms else 0\n        counts.append(count)\n    return counts\n\ndef solve():\n    # Atomic coordinates (Å)\n    atoms = np.array([\n        [0.0, 0.0, 0.0],  # Atom 0\n        [1.5, 0.0, 0.0],  # Atom 1\n        [3.0, 0.0, 0.0],  # Atom 2\n        [4.5, 0.0, 0.0],  # Atom 3\n        [3.0, 1.2, 0.0],  # Atom 4\n    ], dtype=float)\n\n    # Virtual orbitals per atom (e.g., number of PAOs per atom)\n    v_per_atom = np.array([3, 2, 4, 1, 3], dtype=int)\n\n    # LMO centers:\n    # LMO 0 at atom 0\n    r0 = atoms[0]\n    # LMO 1 at midpoint of atoms 1 and 2\n    r1 = 0.5 * (atoms[1] + atoms[2])\n    # LMO 2 at midpoint of atoms 2 and 4\n    r2 = 0.5 * (atoms[2] + atoms[4])\n    lmo_centers = np.vstack([r0, r1, r2])\n\n    # Test suite of cutoffs (Å)\n    test_cases = [0.6, 1.2, 2.25, 3.5]\n\n    results = []\n    for cutoff in test_cases:\n        counts = compute_pair_virtual_counts(atoms, v_per_atom, lmo_centers, cutoff)\n        results.append(counts)\n\n    # Format nested list without spaces: [[a,b,c],[d,e,f],...]\n    outer = []\n    for inner in results:\n        inner_str = \"[\" + \",\".join(str(int(x)) for x in inner) + \"]\"\n        outer.append(inner_str)\n    print(\"[\" + \",\".join(outer) + \"]\")\n\nsolve()\n```", "id": "2903203"}, {"introduction": "即使在预定义的域内，虚拟空间仍然可以被进一步压缩，这是对自然轨道（PNO）方法的核心。本练习聚焦于为特定电子对量身定制的对自然轨道（PNOs）的概念。通过计算和分析一个模型振幅矩阵产生的 PNO 占据数，你将亲身体验到极少数的 PNOs 是如何能够捕捉到绝大部分的对相关能的，从而理解 PNO 截断的威力。[@problem_id:2903183]", "problem": "在采用对自然轨道 (PNO) 的局域相关理论中，例如基于域的局域对自然轨道耦合簇 (DLPNO-CCSD)，对于一个占据-占据轨道对 $\\{i,j\\}$ 的 PNO 定义为由对双激发振幅构建的虚-虚轨道对密度矩阵的本征矢量。考虑一个闭壳层体系和单个占据轨道对 $\\{i,j\\}$，其实数自旋匹配双激发振幅 $t_{ij}^{ab}$ 在一个正交规范虚轨道基中由一个 $4 \\times 4$ 矩阵 $\\mathbf{T}$ 给出，其行由虚轨道 $a \\in \\{1,2,3,4\\}$ 索引，列由虚轨道 $b \\in \\{1,2,3,4\\}$ 索引：\n$$\n\\mathbf{T} \\equiv \\big(t_{ij}^{ab}\\big) \\;=\\;\n\\begin{pmatrix}\n0  1  0  0\\\\\n10^{-3/2}  0  0  0\\\\\n0  0  0  10^{-3}\\\\\n0  0  10^{-3}  0\n\\end{pmatrix}.\n$$\n采用标准模型，其中虚空间中的对密度定义为\n$$\n\\mathbf{D} \\equiv \\big(D_{ac}\\big) \\;=\\; \\sum_{b} t_{ij}^{ab}\\, t_{ij}^{cb} \\;=\\; \\mathbf{T}\\,\\mathbf{T}^{\\top},\n$$\n并且 PNO 占据数是 $\\mathbf{D}$ 的本征值 $\\{\\lambda_p\\}$。进一步假设一个常用近似，即可恢复的对相关能与 $\\mathrm{tr}(\\mathbf{D})$ 成正比，并且保留 $k$ 个最大的 PNO 所恢复的能量分数等于\n$$\nf_k \\;=\\; \\frac{\\sum_{p=1}^{k} \\lambda_p}{\\sum_{p=1}^{4} \\lambda_p}.\n$$\n任务：\n1. 计算 $\\mathbf{D}$ 的 PNO 本征值 $\\{\\lambda_p\\}$ 并按降序排序。\n2. 确定所需的 PNO 的最小数量 $k_{\\min}$，使得 $f_{k_{\\min}} \\ge 0.999$。\n\n只报告最小数量 $k_{\\min}$ 作为你的最终答案。不需要单位。", "solution": "首先对问题陈述进行验证。\n\n**第一步：提取已知条件**\n- **体系：** 一个闭壳层体系。\n- **轨道对：** 单个占据轨道对 $\\{i,j\\}$。\n- **振幅：** 给定一个 $4 \\times 4$ 的实数自旋匹配双激发振幅矩阵 $\\mathbf{T} \\equiv (t_{ij}^{ab})$：\n$$\n\\mathbf{T} \\;=\\;\n\\begin{pmatrix}\n0  1  0  0\\\\\n10^{-3/2}  0  0  0\\\\\n0  0  0  10^{-3}\\\\\n0  0  10^{-3}  0\n\\end{pmatrix}\n$$\n- **对密度矩阵定义：** 虚-虚轨道对密度矩阵 $\\mathbf{D}$ 定义为 $\\mathbf{D} \\equiv (D_{ac}) = \\sum_{b} t_{ij}^{ab}\\, t_{ij}^{cb}$，用矩阵表示法即为 $\\mathbf{D} = \\mathbf{T}\\,\\mathbf{T}^{\\top}$。\n- **PNO 占据数：** $\\mathbf{D}$ 的本征值 $\\{\\lambda_p\\}$。\n- **能量恢复分数：** 前 $k$ 个 PNO 恢复的对相关能分数为 $f_k = \\frac{\\sum_{p=1}^{k} \\lambda_p}{\\sum_{p=1}^{4} \\lambda_p}$。\n- **目标：** 求最小整数 $k_{\\min}$，使得 $f_{k_{\\min}} \\ge 0.999$。\n\n**第二步：使用提取的已知条件进行验证**\n该问题具有科学依据，因为它采用了量子化学中局域相关方法理论的标准定义和近似，特别是基于 PNO 的方法。对密度矩阵、PNO 占据数和能量恢复分数的定义在此理论框架内都是常规的。该问题是适定的，提供了所有必要信息，其数学结构保证了唯一且有意义的解的存在。没有矛盾、歧义或事实错误。这是一个计算化学理论中的有效、正式的练习题。\n\n**第三步：结论与行动**\n问题有效。将推导解答。\n\n**解答推导**\n主要任务是求出对密度矩阵 $\\mathbf{D} = \\mathbf{T}\\,\\mathbf{T}^{\\top}$ 的本征值，然后确定满足给定阈值所需的这些本征值的最小数量。\n\n首先，我们计算矩阵 $\\mathbf{D}$。给定的振幅矩阵 $\\mathbf{T}$ 为：\n$$\n\\mathbf{T} =\n\\begin{pmatrix}\n0  1  0  0\\\\\n10^{-3/2}  0  0  0\\\\\n0  0  0  10^{-3}\\\\\n0  0  10^{-3}  0\n\\end{pmatrix}\n$$\n该矩阵具有块对角结构：\n$$\n\\mathbf{T} = \\begin{pmatrix} \\mathbf{A}  \\mathbf{0}_{2\\times2} \\\\ \\mathbf{0}_{2\\times2}  \\mathbf{B} \\end{pmatrix}, \\quad \\text{其中 } \\mathbf{A} = \\begin{pmatrix} 0  1 \\\\ 10^{-3/2}  0 \\end{pmatrix} \\text{ 且 } \\mathbf{B} = \\begin{pmatrix} 0  10^{-3} \\\\ 10^{-3}  0 \\end{pmatrix}\n$$\n$\\mathbf{T}$ 的转置是 $\\mathbf{T}^{\\top} = \\begin{pmatrix} \\mathbf{A}^{\\top}  \\mathbf{0}_{2\\times2} \\\\ \\mathbf{0}_{2\\times2}  \\mathbf{B}^{\\top} \\end{pmatrix}$。\n密度矩阵 $\\mathbf{D}$ 也因此是块对角的：\n$$\n\\mathbf{D} = \\mathbf{T}\\,\\mathbf{T}^{\\top} = \\begin{pmatrix} \\mathbf{A}\\mathbf{A}^{\\top}  \\mathbf{0}_{2\\times2} \\\\ \\mathbf{0}_{2\\times2}  \\mathbf{B}\\mathbf{B}^{\\top} \\end{pmatrix}\n$$\n我们分别计算块 $\\mathbf{A}\\mathbf{A}^{\\top}$ 和 $\\mathbf{B}\\mathbf{B}^{\\top}$。\n对于第一个块：\n$$\n\\mathbf{A}\\mathbf{A}^{\\top} = \\begin{pmatrix} 0  1 \\\\ 10^{-3/2}  0 \\end{pmatrix} \\begin{pmatrix} 0  10^{-3/2} \\\\ 1  0 \\end{pmatrix} = \\begin{pmatrix} (0)(0) + (1)(1)  (0)(10^{-3/2}) + (1)(0) \\\\ (10^{-3/2})(0) + (0)(1)  (10^{-3/2})(10^{-3/2}) + (0)(0) \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ 0  10^{-3} \\end{pmatrix}\n$$\n对于第二个块，注意到 $\\mathbf{B}$ 是一个对称矩阵，所以 $\\mathbf{B}^{\\top} = \\mathbf{B}$。\n$$\n\\mathbf{B}\\mathbf{B}^{\\top} = \\mathbf{B}^2 = \\begin{pmatrix} 0  10^{-3} \\\\ 10^{-3}  0 \\end{pmatrix} \\begin{pmatrix} 0  10^{-3} \\\\ 10^{-3}  0 \\end{pmatrix} = \\begin{pmatrix} (10^{-3})^2  0 \\\\ 0  (10^{-3})^2 \\end{pmatrix} = \\begin{pmatrix} 10^{-6}  0 \\\\ 0  10^{-6} \\end{pmatrix}\n$$\n组合这些块，完整的密度矩阵 $\\mathbf{D}$ 是：\n$$\n\\mathbf{D} = \\begin{pmatrix}\n1  0  0  0\\\\\n0  10^{-3}  0  0\\\\\n0  0  10^{-6}  0\\\\\n0  0  0  10^{-6}\n\\end{pmatrix}\n$$\nPNO 占据数 $\\{\\lambda_p\\}$ 是 $\\mathbf{D}$ 的本征值。由于 $\\mathbf{D}$ 是一个对角矩阵，其本征值就是其对角元素。\n本征值为 $\\{1, 10^{-3}, 10^{-6}, 10^{-6}\\}$。\n按降序排序得到：\n$\\lambda_1 = 1$\n$\\lambda_2 = 10^{-3}$\n$\\lambda_3 = 10^{-6}$\n$\\lambda_4 = 10^{-6}$\n\n接下来，我们必须找到最小整数 $k_{\\min}$，使得恢复分数 $f_{k_{\\min}} \\ge 0.999$。\n本征值的总和，也就是 $\\mathbf{D}$ 的迹，为：\n$$\n\\sum_{p=1}^{4} \\lambda_p = 1 + 10^{-3} + 10^{-6} + 10^{-6} = 1 + 0.001 + 2 \\times 10^{-6} = 1.001002\n$$\n我们对递增的 $k$ 值检查分数 $f_k$。\n对于 $k=1$：\n$$\nf_1 = \\frac{\\lambda_1}{\\sum_{p=1}^{4} \\lambda_p} = \\frac{1}{1.001002}\n$$\n我们检验条件 $f_1 \\ge 0.999$：\n$$\n\\frac{1}{1.001002} \\ge 0.999 \\iff 1 \\ge 0.999 \\times 1.001002\n$$\n$0.999 \\times 1.001002 = (1 - 10^{-3})(1 + 10^{-3} + 2 \\times 10^{-6}) = 1 + 10^{-3} + 2 \\times 10^{-6} - 10^{-3} - 10^{-6} - 2 \\times 10^{-9} = 1 + 10^{-6} - 2 \\times 10^{-9} = 1.000000998$。\n测试结果为 $1 \\ge 1.000000998$，这是错误的。另一种计算得出 $f_1 \\approx 0.998999$，小于 $0.999$。\n\n对于 $k=2$：\n$$\nf_2 = \\frac{\\lambda_1 + \\lambda_2}{\\sum_{p=1}^{4} \\lambda_p} = \\frac{1 + 10^{-3}}{1.001002} = \\frac{1.001}{1.001002}\n$$\n我们检验条件 $f_2 \\ge 0.999$：\n$$\n\\frac{1.001}{1.001002} \\ge 0.999 \\iff 1.001 \\ge 0.999 \\times 1.001002\n$$\n使用之前的结果，$0.999 \\times 1.001002 = 0.999990998$。\n测试结果为 $1.001 \\ge 0.999990998$。这个不等式是成立的。\n由于当 $k=2$ 时条件满足，而当 $k=1$ 时不满足，所以所需的 PNO 的最小数量是 $2$。\n因此，$k_{\\min} = 2$。", "answer": "$$\n\\boxed{2}\n$$", "id": "2903183"}]}