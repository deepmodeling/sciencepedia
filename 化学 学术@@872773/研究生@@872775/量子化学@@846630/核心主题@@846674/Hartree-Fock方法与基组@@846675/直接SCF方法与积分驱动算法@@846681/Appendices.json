{"hands_on_practices": [{"introduction": "在直接SCF方法中，有效的积分筛选策略是避免$O(M^4)$计算瓶颈的关键。这些策略依赖于对电子排斥积分（ERI）的廉价且可靠的估计。本练习将指导您使用如柯西-施瓦茨不等式等基本数学工具，为交换矩阵$K$的元素推导出一个严格的上限。通过这个实践，您将掌握积分筛选算法背后的核心理论依据，即我们为何以及如何能够安全地忽略那些对总能量贡献微乎其微的积分。[@problem_id:2886238]", "problem": "在积分驱动的直接自洽场 (SCF) 交换矩阵构建中，交换矩阵元由收缩 $K_{\\mu\\nu}=\\sum_{\\lambda\\sigma}(\\mu\\lambda|\\nu\\sigma)P_{\\lambda\\sigma}$ 定义，其中 $(\\mu\\lambda|\\nu\\sigma)$ 是在正交归一的原子中心高斯基组上的电子排斥积分 (ERI)，而 $P_{\\lambda\\sigma}$ 是单粒子密度矩阵的矩阵元。假设通过积分预筛选和密度的局域性，先验地已知以下信息：\n- 对于每对指标 $\\mu$ 和 $\\lambda$，定义 Schwarz 量 $Q_{\\mu\\lambda}=(\\mu\\lambda|\\mu\\lambda)$，对于每对指标 $\\nu$ 和 $\\sigma$，定义 $Q_{\\nu\\sigma}=(\\nu\\sigma|\\nu\\sigma)$。令聚合的 Schwarz 和为 $A_{\\mu}=\\sum_{\\lambda}Q_{\\mu\\lambda}$ 和 $A_{\\nu}=\\sum_{\\sigma}Q_{\\nu\\sigma}$。\n- 密度矩阵是局域化的，即最多有 $M$ 个元素 $P_{\\lambda\\sigma}$ 非零，并且对于某个已知的常数 $P_{0}>0$，每个元素都满足 $|P_{\\lambda\\sigma}|\\le P_{0}$。\n\n仅从 $K_{\\mu\\nu}$ 的定义、柯西-施瓦茨不等式和上述局域性信息出发，确定您能保证的 $|K_{\\mu\\nu}|$ 的最紧标量上界 $B_{\\mu\\nu}$，该上界仅依赖于 $A_{\\mu}$、$A_{\\nu}$、$M$ 和 $P_{0}$，且不引入任何额外的系统特定量。以 $A_{\\mu}$、$A_{\\nu}$、$M$ 和 $P_{0}$ 的单个闭式解析表达式形式提供您的最终结果。不需要进行数值计算，最终表达式也不需要单位。", "solution": "该问题陈述经评估被确定为有效。它在科学上基于量子化学原理，特别是 Hartree-Fock 理论，并且是一个信息充分、能够得出唯一解的适定数学问题。\n\n目标是利用所提供的定义和约束，找到交换矩阵元大小 $|K_{\\mu\\nu}|$ 的最紧标量上界。交换矩阵元定义为：\n$$\nK_{\\mu\\nu} = \\sum_{\\lambda,\\sigma} (\\mu\\lambda|\\nu\\sigma) P_{\\lambda\\sigma}\n$$\n在此，$(\\mu\\lambda|\\nu\\sigma)$ 是电子排斥积分 (ERI)，$P_{\\lambda\\sigma}$ 是单粒子密度矩阵的矩阵元。指标 $\\mu, \\nu, \\lambda, \\sigma$ 指的是正交归一基组中的基函数。\n\n为了找到 $|K_{\\mu\\nu}|$ 的上界，我们首先对定义表达式取绝对值：\n$$\n|K_{\\mu\\nu}| = \\left| \\sum_{\\lambda,\\sigma} (\\mu\\lambda|\\nu\\sigma) P_{\\lambda\\sigma} \\right|\n$$\n对指标对 $(\\lambda, \\sigma)$ 的求和可以解释为两个高维向量的点积。设一个向量 $V$ 由 ERI 元素 $V_{\\lambda\\sigma} = (\\mu\\lambda|\\nu\\sigma)$ 组成，第二个向量 $P$ 由密度矩阵元 $P_{\\lambda\\sigma}$ 组成。那么该求和等价于一个点积。我们应用柯西-施瓦茨不等式，该不等式指出对于两个向量 $V$ 和 $P$，有 $|\\langle V, P \\rangle|^2 \\le \\|V\\|^2 \\|P\\|^2$。在我们的表示法中，这变为：\n$$\n|K_{\\mu\\nu}|^2 = \\left| \\sum_{\\lambda,\\sigma} (\\mu\\lambda|\\nu\\sigma) P_{\\lambda\\sigma} \\right|^2 \\le \\left( \\sum_{\\lambda,\\sigma} |(\\mu\\lambda|\\nu\\sigma)|^2 \\right) \\left( \\sum_{\\lambda,\\sigma} |P_{\\lambda\\sigma}|^2 \\right)\n$$\n现在我们利用问题陈述中提供的信息，分别对右侧的两项寻找上界。\n\n首先，我们来限定包含 ERI 的项：$\\sum_{\\lambda,\\sigma} |(\\mu\\lambda|\\nu\\sigma)|^2$。\n该问题要求使用柯西-施瓦茨不等式。一个标准的 ERI 不等式是，它本身是将柯西-施瓦茨不等式应用于库仑算符下的电荷分布 $\\rho_{\\mu\\lambda}(\\mathbf{r}_1) = \\phi_{\\mu}^*(\\mathbf{r}_1)\\phi_{\\lambda}(\\mathbf{r}_1)$ 和 $\\rho_{\\nu\\sigma}(\\mathbf{r}_2) = \\phi_{\\nu}^*(\\mathbf{r}_2)\\phi_{\\sigma}(\\mathbf{r}_2)$ 的结果：\n$$\n|(\\mu\\lambda|\\nu\\sigma)|^2 \\le (\\mu\\lambda|\\mu\\lambda)(\\nu\\sigma|\\nu\\sigma)\n$$\n问题中给出了 Schwarz 量的定义：$Q_{\\mu\\lambda} = (\\mu\\lambda|\\mu\\lambda)$ 和 $Q_{\\nu\\sigma} = (\\nu\\sigma|\\nu\\sigma)$。将这些代入不等式，得到：\n$$\n|(\\mu\\lambda|\\nu\\sigma)|^2 \\le Q_{\\mu\\lambda} Q_{\\nu\\sigma}\n$$\n由于这对求和中的每一项都成立，我们可以写出：\n$$\n\\sum_{\\lambda,\\sigma} |(\\mu\\lambda|\\nu\\sigma)|^2 \\le \\sum_{\\lambda,\\sigma} Q_{\\mu\\lambda} Q_{\\nu\\sigma}\n$$\n右侧的被加数是一个关于 $\\lambda$ 的函数和一个关于 $\\sigma$ 的函数的乘积。因此，这个双重求和可以分解为两个单一求和的乘积：\n$$\n\\sum_{\\lambda,\\sigma} Q_{\\mu\\lambda} Q_{\\nu\\sigma} = \\left( \\sum_{\\lambda} Q_{\\mu\\lambda} \\right) \\left( \\sum_{\\sigma} Q_{\\nu\\sigma} \\right)\n$$\n使用聚合的 Schwarz 和的定义，$A_{\\mu}=\\sum_{\\lambda}Q_{\\mu\\lambda}$ 和 $A_{\\nu}=\\sum_{\\sigma}Q_{\\nu\\sigma}$，我们得到第一项的上界：\n$$\n\\sum_{\\lambda,\\sigma} |(\\mu\\lambda|\\nu\\sigma)|^2 \\le A_{\\mu} A_{\\nu}\n$$\n\n接下来，我们来限定包含密度矩阵的项：$\\sum_{\\lambda,\\sigma} |P_{\\lambda\\sigma}|^2$。\n我们已知最多有 $M$ 个元素 $P_{\\lambda\\sigma}$ 非零。设 $S$ 为满足 $P_{\\lambda\\sigma} \\neq 0$ 的指标对 $(\\lambda, \\sigma)$ 的集合。该集合的大小为 $|S| \\le M$。因此，求和可以简化为对集合 $S$ 的求和：\n$$\n\\sum_{\\lambda,\\sigma} |P_{\\lambda\\sigma}|^2 = \\sum_{(\\lambda, \\sigma) \\in S} |P_{\\lambda\\sigma}|^2\n$$\n我们还已知对于任意元素，有 $|P_{\\lambda\\sigma}| \\le P_0$。对这个不等式两边平方，得到 $|P_{\\lambda\\sigma}|^2 \\le P_0^2$。将此应用于求和中的每一项：\n$$\n\\sum_{(\\lambda, \\sigma) \\in S} |P_{\\lambda\\sigma}|^2 \\le \\sum_{(\\lambda, \\sigma) \\in S} P_0^2 = |S| P_0^2\n$$\n利用 $|S| \\le M$ 这一事实，我们得到第二项的上界：\n$$\n\\sum_{\\lambda,\\sigma} |P_{\\lambda\\sigma}|^2 \\le M P_0^2\n$$\n\n最后，我们将这两项的上界合并回关于 $|K_{\\mu\\nu}|^2$ 的原始不等式中：\n$$\n|K_{\\mu\\nu}|^2 \\le (A_{\\mu} A_{\\nu}) (M P_0^2) = M P_0^2 A_{\\mu} A_{\\nu}\n$$\n对两边取平方根，得到 $|K_{\\mu\\nu}|$ 的期望上界 $B_{\\mu\\nu}$。由于 $P_0 > 0$，我们有：\n$$\n|K_{\\mu\\nu}| \\le \\sqrt{M P_0^2 A_{\\mu} A_{\\nu}} = P_0 \\sqrt{M A_{\\mu} A_{\\nu}}\n$$\n这个表达式是仅根据给定信息所能保证的最紧上界，因为它是通过直接应用不等式得出的。这些不等式的等号成立条件通常不满足，但若无更多的系统特定知识，此界也无法改进。最终结果仅依赖于 $A_{\\mu}$、$A_{\\nu}$、$M$ 和 $P_0$，符合要求。", "answer": "$$\n\\boxed{P_{0} \\sqrt{M A_{\\mu} A_{\\nu}}}\n$$", "id": "2886238"}, {"introduction": "在理论上确立了可以为积分设置界限之后，下一个实际问题是如何选择一个合适的筛选阈值 $\\tau$ 来平衡计算成本与最终精度。本练习要求您设计并实现一个算法，该算法能根据用户指定的能量容差 $\\varepsilon$ 自适应地确定最大允许的 $\\tau$ 值。这项编码实践将理论与稳健的计算实现联系起来，展示了如何在保证能量精度的前提下最大限度地提高计算效率。[@problem_id:2886212]", "problem": "设计并实现一个算法测试，该测试在采用积分驱动筛选的直接自洽场（SCF）程序中的闭壳层限制性Hartree-Fock（RHF）迭代中，能够自适应地选择积分筛选阈值 $ \\tau $，以确保每次迭代中由此产生的总电子能量变化不超过一个以哈特里（Hartree）为单位的指定容差。该算法必须基于第一性原理，且不得依赖任何预先计算的 $ \\tau $ 快捷公式。\n\n假设以下基本事实和定义：\n- 在原子轨道基中，RHF Fock矩阵 $ F $ 的元素为\n$$ F_{\\mu \\nu} = H_{\\mu \\nu} + \\sum_{\\lambda \\sigma} P_{\\lambda \\sigma} \\left[ (\\mu \\nu|\\lambda \\sigma) - \\tfrac{1}{2} (\\mu \\lambda|\\nu \\sigma) \\right], $$\n其中 $ H_{\\mu \\nu} $ 是单电子（核）哈密顿量，$ P_{\\lambda \\sigma} $ 是密度矩阵，$ (\\mu \\nu|\\lambda \\sigma) $ 是化学家标记法下的双电子排斥积分。\n- RHF总电子能量为\n$$ E = \\tfrac{1}{2} \\sum_{\\mu \\nu} P_{\\mu \\nu} \\left( H_{\\mu \\nu} + F_{\\mu \\nu} \\right). $$\n- 在采用积分驱动算法的直接SCF中，使用柯西-施瓦茨不等式对积分进行筛选。定义一个非负对界限矩阵 $ Q \\in \\mathbb{R}^{N \\times N} $，其元素为\n$$ Q_{\\mu \\nu} = \\sqrt{ (\\mu \\nu|\\mu \\nu) }, $$\n因此柯西-施瓦茨界限给出\n$$ \\left| (\\mu \\nu|\\lambda \\sigma) \\right| \\le Q_{\\mu \\nu} \\, Q_{\\lambda \\sigma}. $$\n- 一个阈值 $ \\tau > 0 $ 用于忽略任何其界限严格小于 $ \\tau $ 的双电子贡献。具体而言，如果 $ Q_{\\mu \\nu} Q_{\\lambda \\sigma}  \\tau $，则忽略库仑贡献 $ (\\mu \\nu|\\lambda \\sigma) $；如果 $ Q_{\\mu \\lambda} Q_{\\nu \\sigma}  \\tau $，则忽略交换贡献 $ (\\mu \\lambda|\\nu \\sigma) $。\n\n您的任务是：\n- 根据上述定义和三角不等式，推导出一个可计算且单调非递减的上界 $ \\Delta E_{\\mathrm{bound}}(\\tau) $。该上界对应于在固定密度 $ P $ 的情况下，单次SCF迭代中仅由积分筛选引起的能量变化大小 $ |\\Delta E| $，并应是 $ \\tau $ 的函数。您必须仅使用 $ P $、$ Q $ 和 $ \\tau $ 来表示此界限，不得包含任何未知积分。\n- 利用此界限，设计一个 $ \\tau $ 的自适应选择规则，该规则选择满足 $ \\Delta E_{\\mathrm{bound}}(\\tau) \\le \\varepsilon $ 的最大 $ \\tau $，其中 $ \\varepsilon $ 是用户指定的、以哈特里为单位的容差，表示每次迭代中由筛选允许的最大总能量变化。\n- 将此选择规则实现为一个程序，该程序为每个测试用例计算并返回所选的 $ \\tau $。\n\n实现要求：\n- 将 $ P $ 和 $ Q $ 表示为大小为 $ N \\times N $ 的密集数组。为每个测试用例明确定义 $ N $。\n- 除能量容差 $ \\varepsilon $（必须理解为哈特里单位）外，将所有量视为无量纲。\n- 对于给定的 $ \\tau $，定义指示函数\n$$ \\chi^{J}_{\\mu \\nu, \\lambda \\sigma}(\\tau) = \\begin{cases} 1  \\text{if } Q_{\\mu \\nu} Q_{\\lambda \\sigma}  \\tau, \\\\ 0  \\text{otherwise}, \\end{cases}\n\\quad\n\\chi^{K}_{\\mu \\nu, \\lambda \\sigma}(\\tau) = \\begin{cases} 1  \\text{if } Q_{\\mu \\lambda} Q_{\\nu \\sigma}  \\tau, \\\\ 0  \\text{otherwise}, \\end{cases} $$\n并在您的界限中使用绝对密度 $ |P_{\\mu \\nu}| $，以通过三角不等式确保上界。\n- 对于固定的 $ \\tau $，您的界限 $ \\Delta E_{\\mathrm{bound}}(\\tau) $ 必须能在 $ O(N^4) $ 或更优的时间复杂度内计算，并且必须是关于 $ \\tau $ 的单调非递减函数。\n- 选择 $ \\tau $ 的搜索区间为 $ [0, \\tau_{\\max}] $，其中\n$$ \\tau_{\\max} = \\left( \\max_{\\mu \\nu} Q_{\\mu \\nu} \\right)^2, $$\n并选择满足 $ \\Delta E_{\\mathrm{bound}}(\\tau) \\le \\varepsilon $ 的最大 $ \\tau \\in [0, \\tau_{\\max}] $。如果 $ \\Delta E_{\\mathrm{bound}}(\\tau_{\\max}) \\le \\varepsilon $，则返回 $ \\tau_{\\max} $。\n- 使用一种稳健的单调求根策略（如二分法）来定位最大的可接受 $ \\tau $。\n\n测试套件：\n提供一个程序，为以下四个测试用例评估自适应的 $ \\tau $。每个测试用例包含一个矩阵大小 $ N $、一个密度矩阵 $ P \\in \\mathbb{R}^{N \\times N} $（使用对称的 $ P $）、一个具有非负项的对界限矩阵 $ Q \\in \\mathbb{R}^{N \\times N} $，以及一个以哈特里为单位的能量容差 $ \\varepsilon $。除 $ \\varepsilon $ 外，以下所有数字均为无量纲。\n\n- A例（一般情况，中等容差）：$ N = 3 $,\n  $$\n  P = \\begin{pmatrix}\n  1.90  0.20  0.10 \\\\\n  0.20  1.80  0.05 \\\\\n  0.10  0.05  1.70\n  \\end{pmatrix}, \\quad\n  Q = \\begin{pmatrix}\n  0.50  0.20  0.10 \\\\\n  0.20  0.60  0.15 \\\\\n  0.10  0.15  0.40\n  \\end{pmatrix}, \\quad\n  \\varepsilon = 1.0 \\times 10^{-4}.\n  $$\n- B例（零密度边缘情况）：$ N = 2 $,\n  $$\n  P = \\begin{pmatrix}\n  0.0  0.0 \\\\\n  0.0  0.0\n  \\end{pmatrix}, \\quad\n  Q = \\begin{pmatrix}\n  0.30  0.10 \\\\\n  0.10  0.25\n  \\end{pmatrix}, \\quad\n  \\varepsilon = 1.0 \\times 10^{-6}.\n  $$\n- C例（与A相同，但容差更严）：$ N = 3 $,\n  $$\n  P = \\begin{pmatrix}\n  1.90  0.20  0.10 \\\\\n  0.20  1.80  0.05 \\\\\n  0.10  0.05  1.70\n  \\end{pmatrix}, \\quad\n  Q = \\begin{pmatrix}\n  0.50  0.20  0.10 \\\\\n  0.20  0.60  0.15 \\\\\n  0.10  0.15  0.40\n  \\end{pmatrix}, \\quad\n  \\varepsilon = 1.0 \\times 10^{-8}.\n  $$\n- D例（与A相同，但容差较宽）：$ N = 3 $,\n  $$\n  P = \\begin{pmatrix}\n  1.90  0.20  0.10 \\\\\n  0.20  1.80  0.05 \\\\\n  0.10  0.05  1.70\n  \\end{pmatrix}, \\quad\n  Q = \\begin{pmatrix}\n  0.50  0.20  0.10 \\\\\n  0.20  0.60  0.15 \\\\\n  0.10  0.15  0.40\n  \\end{pmatrix}, \\quad\n  \\varepsilon = 1.0 \\times 10^{-2}.\n  $$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与测试用例A、B、C、D的顺序相同。每个 $ \\tau $ 必须精确到小数点后 $ 8 $ 位。例如，输出应类似于 $ [\\tau_A,\\tau_B,\\tau_C,\\tau_D] $，每个 $ \\tau $ 打印到 $ 8 $ 位小数，不含任何额外文本。不应需要用户输入。", "solution": "所提出的问题是计算量子化学领域一个明确定义的练习，具体涉及直接自洽场（SCF）方法。它在科学上基于Hartree-Fock理论的原理以及使用标准数学不等式进行积分筛选。该问题是自洽的，提供了所有必要的定义和数据，并且没有歧义或矛盾。因此，它值得一个完整、合理的解答。\n\n目标是推导单次限制性Hartree-Fock（RHF）迭代中由积分筛选引入的总电子能量误差的上界，并利用该上界自适应地选择筛选阈值 $\\tau$。\n\n步骤1：能量误差上界 $\\Delta E_{\\mathrm{bound}}(\\tau)$ 的推导\n\nRHF总电子能量由下式给出：\n$$ E = \\tfrac{1}{2} \\sum_{\\mu \\nu} P_{\\mu \\nu} (H_{\\mu \\nu} + F_{\\mu \\nu}) $$\n其中 $P$ 是密度矩阵，$H$ 是核哈密顿矩阵，$F$ 是Fock矩阵。将Fock矩阵的表达式，\n$$ F_{\\mu \\nu} = H_{\\mu \\nu} + \\sum_{\\lambda \\sigma} P_{\\lambda \\sigma} \\left[ (\\mu \\nu|\\lambda \\sigma) - \\tfrac{1}{2} (\\mu \\lambda|\\nu \\sigma) \\right] $$\n代入能量表达式得到：\n$$ E = \\tfrac{1}{2} \\sum_{\\mu \\nu} P_{\\mu \\nu} \\left( 2H_{\\mu \\nu} + \\sum_{\\lambda \\sigma} P_{\\lambda \\sigma} \\left[ (\\mu \\nu|\\lambda \\sigma) - \\tfrac{1}{2} (\\mu \\lambda|\\nu \\sigma) \\right] \\right) $$\n$$ E = \\sum_{\\mu \\nu} P_{\\mu \\nu} H_{\\mu \\nu} + \\tfrac{1}{2} \\sum_{\\mu \\nu \\lambda \\sigma} P_{\\mu \\nu} P_{\\lambda \\sigma} (\\mu \\nu|\\lambda \\sigma) - \\tfrac{1}{4} \\sum_{\\mu \\nu \\lambda \\sigma} P_{\\mu \\nu} P_{\\lambda \\sigma} (\\mu \\lambda|\\nu \\sigma) $$\n在阈值 $\\tau$ 下的积分筛选通过忽略某些双电子排斥积分而引入误差。能量的单电子部分 $\\sum_{\\mu \\nu} P_{\\mu \\nu} H_{\\mu \\nu}$ 不受影响。能量变化 $\\Delta E$ 是所有被忽略的双电子能量贡献之和。根据问题描述，如果库仑项 $(\\mu \\nu|\\lambda \\sigma)$ 的柯西-施瓦茨界限 $Q_{\\mu \\nu} Q_{\\lambda \\sigma}  \\tau$，则该项被忽略；如果交换项 $(\\mu \\lambda|\\nu \\sigma)$ 的界限 $Q_{\\mu \\lambda} Q_{\\nu \\sigma}  \\tau$，则该项被忽略。使用问题中定义的指示函数 $\\chi^J$ 和 $\\chi^K$，总能量变化为：\n$$ \\Delta E(\\tau) = \\tfrac{1}{2} \\sum_{\\mu \\nu \\lambda \\sigma} P_{\\mu \\nu} P_{\\lambda \\sigma} (\\mu \\nu|\\lambda \\sigma) \\chi^{J}_{\\mu \\nu, \\lambda \\sigma}(\\tau) - \\tfrac{1}{4} \\sum_{\\mu \\nu \\lambda \\sigma} P_{\\mu \\nu} P_{\\lambda \\sigma} (\\mu \\lambda|\\nu \\sigma) \\chi^{K}_{\\mu \\nu, \\lambda \\sigma}(\\tau) $$\n我们寻求此变化量大小 $|\\Delta E(\\tau)|$ 的一个上界。使用三角不等式：\n$$ |\\Delta E(\\tau)| \\le \\left| \\tfrac{1}{2} \\sum_{\\mu \\nu \\lambda \\sigma} P_{\\mu \\nu} P_{\\lambda \\sigma} (\\mu \\nu|\\lambda \\sigma) \\chi^{J}_{\\mu \\nu, \\lambda \\sigma}(\\tau) \\right| + \\left| \\tfrac{1}{4} \\sum_{\\mu \\nu \\lambda \\sigma} P_{\\mu \\nu} P_{\\lambda \\sigma} (\\mu \\lambda|\\nu \\sigma) \\chi^{K}_{\\mu \\nu, \\lambda \\sigma}(\\tau) \\right| $$\n再次应用三角不等式将绝对值移到求和内部，并利用性质 $|ab| = |a||b|$：\n$$ |\\Delta E(\\tau)| \\le \\tfrac{1}{2} \\sum_{\\mu \\nu \\lambda \\sigma} |P_{\\mu \\nu}| |P_{\\lambda \\sigma}| |(\\mu \\nu|\\lambda \\sigma)| \\chi^{J}_{\\mu \\nu, \\lambda \\sigma}(\\tau) + \\tfrac{1}{4} \\sum_{\\mu \\nu \\lambda \\sigma} |P_{\\mu \\nu}| |P_{\\lambda \\sigma}| |(\\mu \\lambda|\\nu \\sigma)| \\chi^{K}_{\\mu \\nu, \\lambda \\sigma}(\\tau) $$\n现在，我们应用为积分提供的柯西-施瓦茨界限：$|(\\mu \\nu|\\lambda \\sigma)| \\le Q_{\\mu \\nu} Q_{\\lambda \\sigma}$ 和 $|(\\mu \\lambda|\\nu \\sigma)| \\le Q_{\\mu \\lambda} Q_{\\nu \\sigma}$。这产生了一个可计算的上界 $\\Delta E_{\\mathrm{bound}}(\\tau)$：\n$$ \\Delta E_{\\mathrm{bound}}(\\tau) = \\tfrac{1}{2} \\sum_{\\mu \\nu \\lambda \\sigma} |P_{\\mu \\nu}| |P_{\\lambda \\sigma}| Q_{\\mu \\nu} Q_{\\lambda \\sigma} \\chi^{J}_{\\mu \\nu, \\lambda \\sigma}(\\tau) + \\tfrac{1}{4} \\sum_{\\mu \\nu \\lambda \\sigma} |P_{\\mu \\nu}| |P_{\\lambda \\sigma}| Q_{\\mu \\lambda} Q_{\\nu \\sigma} \\chi^{K}_{\\mu \\nu, \\lambda \\sigma}(\\tau) $$\n此表达式定义了所需的界限。它仅依赖于已知的矩阵 $P$ 和 $Q$ 以及阈值 $\\tau$。求和是在满足相应筛选条件（$Q_{\\mu \\nu} Q_{\\lambda \\sigma}  \\tau$ 和 $Q_{\\mu \\lambda} Q_{\\nu \\sigma}  \\tau$）的所有指标上进行的。由于求和中的所有项都是非负的，并且随着 $\\tau$ 的增加，求和的范围扩大或保持不变，因此 $\\Delta E_{\\mathrm{bound}}(\\tau)$ 是 $\\tau$ 的一个单调非递减函数。\n\n步骤2：自适应阈值选择的算法设计\n\n目标是找到区间 $[0, \\tau_{\\max}]$ 内满足 $\\Delta E_{\\mathrm{bound}}(\\tau) \\le \\varepsilon$ 的最大阈值 $\\tau$，其中 $\\varepsilon$ 是给定的容差。最大阈值由积分界限的最大可能值确定：\n$$ \\tau_{\\max} = \\left( \\max_{\\mu, \\nu} Q_{\\mu \\nu} \\right)^2 $$\n函数 $f(\\tau) = \\Delta E_{\\mathrm{bound}}(\\tau) - \\varepsilon$ 是单调非递减的。我们正在寻找使 $f(\\tau) \\le 0$ 成立的最大 $\\tau$。这是一个求根问题。\n\n该算法按以下步骤进行：\n1. 对于给定的测试用例（$N$, $P$, $Q$, $\\varepsilon$），计算 $\\tau_{\\max}$。\n2. 评估 $\\Delta E_{\\mathrm{bound}}(\\tau_{\\max})$。如果 $\\Delta E_{\\mathrm{bound}}(\\tau_{\\max}) \\le \\varepsilon$，则任何 $\\tau \\in [0, \\tau_{\\max}]$ 都是可接受的。其中最大的值是 $\\tau_{\\max}$，即为解。\n3. 如果 $\\Delta E_{\\mathrm{bound}}(\\tau_{\\max}) > \\varepsilon$，由于 $\\Delta E_{\\mathrm{bound}}(0) = 0 \\le \\varepsilon$，必定存在一个解 $\\tau^*  \\tau_{\\max}$。因为 $\\Delta E_{\\mathrm{bound}}(\\tau)$ 是单调的，所以存在一个唯一的根 $\\tau^*$ 使得 $\\Delta E_{\\mathrm{bound}}(\\tau^*) = \\varepsilon$。这个根是 $\\tau$ 的最大允许值。我们可以使用在区间 $[0, \\tau_{\\max}]$ 上的二分搜索来找到它。\n\n二分法算法如下：\na. 初始化 `low` = $0$，`high` = $\\tau_{\\max}$。\nb. 重复足够次数的迭代（例如，对于双精度准确度，重复 $100$ 次）：\n    i. 计算 `mid` = (`low` + `high`) / $2$。\n    ii. 计算 $E_{\\text{mid}} = \\Delta E_{\\mathrm{bound}}(\\text{mid})$。\n    iii. 如果 $E_{\\text{mid}} \\le \\varepsilon$，这意味着 `mid` 是一个有效的阈值，可能存在更大的阈值。因此，我们将搜索空间更新到上半部分：`low` = `mid`。\n    iv. 如果 $E_{\\text{mid}} > \\varepsilon$，则 `mid` 太大。我们必须在下半部分搜索更小的阈值：`high` = `mid`。\nc. `low`（或 `high`）的最终值就是所期望的最优阈值 $\\tau$。\n\n计算 $\\Delta E_{\\mathrm{bound}}(\\tau)$ 的函数将对两个项（库仑项和交换项）分别使用四个嵌套循环来实现，每次评估的总体复杂度为 $O(N^4)$，考虑到问题约束和较小的 $N$ 值，这是可以接受的。\n\n此过程为确定积分筛选阈值提供了一种稳健且有原则的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_delta_e_bound(tau, P, Q):\n    \"\"\"\n    Computes the upper bound on the energy change due to integral screening.\n\n    Args:\n        tau (float): The integral screening threshold.\n        P (np.ndarray): The density matrix (N x N).\n        Q (np.ndarray): The pair bound matrix (N x N).\n\n    Returns:\n        float: The energy error bound Delta_E_bound(tau).\n    \"\"\"\n    N = P.shape[0]\n    P_abs = np.abs(P)\n    \n    # Coulomb term contribution\n    J_bound = 0.0\n    for mu in range(N):\n        for nu in range(N):\n            for lam in range(N):\n                for sig in range(N):\n                    q_prod = Q[mu, nu] * Q[lam, sig]\n                    if q_prod  tau:\n                        J_bound += 0.5 * P_abs[mu, nu] * P_abs[lam, sig] * q_prod\n\n    # Exchange term contribution\n    K_bound = 0.0\n    for mu in range(N):\n        for nu in range(N):\n            for lam in range(N):\n                for sig in range(N):\n                    q_prod = Q[mu, lam] * Q[nu, sig]\n                    if q_prod  tau:\n                        K_bound += 0.25 * P_abs[mu, nu] * P_abs[lam, sig] * q_prod\n\n    return J_bound + K_bound\n\ndef find_optimal_tau(P, Q, epsilon):\n    \"\"\"\n    Finds the largest screening threshold tau such that the energy error\n    bound does not exceed epsilon.\n\n    Args:\n        P (np.ndarray): The density matrix.\n        Q (np.ndarray): The pair bound matrix.\n        epsilon (float): The energy tolerance.\n\n    Returns:\n        float: The optimal screening threshold tau.\n    \"\"\"\n    if np.max(Q) == 0.0:\n        # If all Q entries are zero, any tau > 0 will screen all integrals,\n        # but the bound will always be 0. tau_max is also 0.\n        return 0.0\n        \n    tau_max = np.max(Q)**2\n    \n    # Handle the zero density edge case where bound is always 0.\n    if np.all(P == 0):\n        return tau_max\n\n    # Check if the maximum possible threshold already satisfies the condition.\n    bound_at_max = compute_delta_e_bound(tau_max, P, Q)\n    if bound_at_max = epsilon:\n        return tau_max\n\n    # Perform a bisection search for the optimal tau.\n    low = 0.0\n    high = tau_max\n    \n    # 100 iterations are sufficient for double precision convergence.\n    for _ in range(100):\n        mid = (low + high) / 2.0\n        if mid == low or mid == high: # Convergence reached\n            break\n            \n        bound_at_mid = compute_delta_e_bound(mid, P, Q)\n        \n        if bound_at_mid = epsilon:\n            # mid is a valid threshold, try for a larger one\n            low = mid\n        else:\n            # mid is too high, reduce the threshold\n            high = mid\n            \n    return low\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the solver for each case.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 3,\n            \"P\": np.array([\n                [1.90, 0.20, 0.10],\n                [0.20, 1.80, 0.05],\n                [0.10, 0.05, 1.70]\n            ]),\n            \"Q\": np.array([\n                [0.50, 0.20, 0.10],\n                [0.20, 0.60, 0.15],\n                [0.10, 0.15, 0.40]\n            ]),\n            \"epsilon\": 1.0e-4\n        },\n        {\n            \"N\": 2,\n            \"P\": np.array([\n                [0.0, 0.0],\n                [0.0, 0.0]\n            ]),\n            \"Q\": np.array([\n                [0.30, 0.10],\n                [0.10, 0.25]\n            ]),\n            \"epsilon\": 1.0e-6\n        },\n        {\n            \"N\": 3,\n            \"P\": np.array([\n                [1.90, 0.20, 0.10],\n                [0.20, 1.80, 0.05],\n                [0.10, 0.05, 1.70]\n            ]),\n            \"Q\": np.array([\n                [0.50, 0.20, 0.10],\n                [0.20, 0.60, 0.15],\n                [0.10, 0.15, 0.40]\n            ]),\n            \"epsilon\": 1.0e-8\n        },\n        {\n            \"N\": 3,\n            \"P\": np.array([\n                [1.90, 0.20, 0.10],\n                [0.20, 1.80, 0.05],\n                [0.10, 0.05, 1.70]\n            ]),\n            \"Q\": np.array([\n                [0.50, 0.20, 0.10],\n                [0.20, 0.60, 0.15],\n                [0.10, 0.15, 0.40]\n            ]),\n            \"epsilon\": 1.0e-2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        P = case[\"P\"]\n        Q = case[\"Q\"]\n        epsilon = case[\"epsilon\"]\n        \n        # Ensure matrices are symmetric as per problem statement hint\n        P = 0.5 * (P + P.T)\n        \n        tau = find_optimal_tau(P, Q, epsilon)\n        results.append(f\"{tau:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2886212"}, {"introduction": "积分筛选算法旨在减少浮点运算（flops）的总数，但它们对内存访问模式有何影响？本练习引入了“计算强度”（arithmetic intensity）这一关键性能指标，即每移动一字节数据所执行的浮点运算次数。您将通过一个具体的模型定量分析积分筛选如何影响这一指标，从而揭示算法在现代计算机体系结构上的性能特征。理解这种计算与内存访问之间的权衡对于优化代码性能至关重要，因为在现代处理器中，内存带宽往往是主要的性能瓶颈。[@problem_id:2886242]", "problem": "考虑一个在大小为 $N=20$ 的原子轨道 (AO) 基组上，使用积分驱动算法直接构建自洽场 (SCF) Fock 矩阵的过程。在此设置中，电子排斥积分 (ERIs) 是动态计算并立即收缩到 Fock 矩阵中的。假设使用以下具有科学依据的成本模型，该模型旨在捕捉此类构建过程中的主要计算和内存行为：\n\n- 全程使用双精度，因此每个浮点数占用 $8$ 字节。\n- 置换唯一的 AO ERI 的数量近似为 $N^{4}/8$。\n- 计算一个收缩的 AO ERI 需要 $2000$ 次浮点运算 (flops)。\n- 对于每个实际计算的（即未被筛除的）ERI，会精确执行 $6$ 次 Fock 更新；每次更新是对一个 Fock 元素进行一次乘加运算，并伴随一次密度读取：\n  - 将每次乘加计为 $2$ 次浮点运算。\n  - 将每次密度读取计为 $8$ 字节。\n  - 将每次 Fock 更新计为对一个双精度数的读-改-写操作，每次更新 Fock 元素产生 $16$ 字节的内存流量。\n- 在没有筛选的情况下，所有 $N^{4}/8$ 个积分都会被计算，并且不执行任何筛选检查。\n- 使用 Schwarz 型筛选时，对每个候选积分（在相同的 $N^{4}/8$ 个候选积分中）进行一次界限检查，这需要读取两个预先计算好的壳层对界限（每个 AO 对一个），每个候选积分的成本为总计 $16$ 字节和 $2$ 次浮点运算。只有一小部分 $s=0.10$ 的候选积分通过了界限检查，并继续进行如上所述的完整 ERI 求值和 Fock 更新。如果一个候选积分未通过检查，则不会对该候选积分进行 ERI 求值和 Fock 更新。\n\n使用计算强度（总浮点运算次数除以与主内存之间传输的总字节数）的定义，计算完整 Fock 构建过程的计算强度：\n- 无筛选情况下的 $I_{\\text{no-screen}}$，\n- 有筛选情况下的 $I_{\\text{screen}}$。\n\n两个答案均以 flops/byte 为单位表示。将您的答案四舍五入到三位有效数字。在最终的方框答案中不要包含单位；按 $\\bigl(I_{\\text{no-screen}},\\,I_{\\text{screen}}\\bigr)$ 的顺序列出这两个值。", "solution": "该问题要求计算在两种条件下直接构建自洽场 (SCF) Fock 矩阵的计算强度：无积分筛选和有积分筛选。计算强度 $I$ 定义为总浮点运算 (flops) 次数与主内存之间数据传输总字节数的比值。\n\n$I = \\frac{\\text{总浮点运算次数}}{\\text{总字节数}}$\n\n首先，我们确定题目中给出的参数。\n原子轨道 (AO) 基组的大小为 $N=20$。\n置换唯一的双电子排斥积分 (ERIs) 的数量近似为 $N_{ERI} = \\frac{N^{4}}{8}$。\n对于 $N=20$，这个数量是：\n$$N_{ERI} = \\frac{20^{4}}{8} = \\frac{160000}{8} = 20000$$\n\n成本模型参数如下：\n- 计算一个 ERI 的浮点运算次数：$F_{eval} = 2000$ flops。\n- 每个计算的 ERI 对应的 Fock 更新次数：$U_{ERI} = 6$。\n- 每次 Fock 更新的成本：\n    - 浮点运算：$F_{update} = 2$ flops (一次乘加)。\n    - 内存流量：$B_{update} = 8 \\text{ 字节 (密度读取)} + 16 \\text{ 字节 (Fock 读-改-写)} = 24 \\text{ 字节}$。\n- 每次筛选检查的成本：\n    - 浮点运算：$F_{screen\\_check} = 2$ flops。\n    - 内存流量：$B_{screen\\_check} = 16$ 字节 (两个壳层对界限)。\n- 通过筛选的积分比例：$s = 0.10$。\n\n我们现在分别分析每种情况。\n\n情况 1：无筛选 ($I_{\\text{no-screen}}$)\n在这种情况下，所有 $N_{ERI}$ 个积分都被计算并贡献给 Fock 矩阵。不执行筛选检查。\n\n首先，我们计算总浮点运算次数 $F_{\\text{no-screen}}$。这是 ERI 求值和随后的 Fock 更新所产生的浮点运算次数之和。\n对所有 $N_{ERI}$ 个积分进行 ERI 求值产生的浮点运算次数为 $N_{ERI} \\times F_{eval}$。\n对所有 $N_{ERI}$ 个积分进行 Fock 更新产生的浮点运算次数为 $N_{ERI} \\times U_{ERI} \\times F_{update}$。\n$$F_{\\text{no-screen}} = N_{ERI} \\times (F_{eval} + U_{ERI} \\times F_{update})$$\n$$F_{\\text{no-screen}} = 20000 \\times (2000 + 6 \\times 2) = 20000 \\times (2000 + 12) = 20000 \\times 2012 = 40240000 \\text{ flops}$$\n\n接着，我们计算总内存流量 $B_{\\text{no-screen}}$。在这个直接算法中，唯一指定的内存流量来自于更新步骤中的密度矩阵读取和 Fock 矩阵的读-改-写操作。\n$$B_{\\text{no-screen}} = N_{ERI} \\times U_{ERI} \\times B_{update}$$\n$$B_{\\text{no-screen}} = 20000 \\times 6 \\times 24 = 2880000 \\text{ bytes}$$\n\n计算强度是这两个量的比值。\n$$I_{\\text{no-screen}} = \\frac{F_{\\text{no-screen}}}{B_{\\text{no-screen}}} = \\frac{40240000}{2880000} = \\frac{4024}{288} \\approx 13.9722$$\n四舍五入到三位有效数字，我们得到 $I_{\\text{no-screen}} = 14.0$ flops/byte。\n\n情况 2：使用 Schwarz 型筛选 ($I_{\\text{screen}}$)\n在这种情况下，会对 $N_{ERI}$ 个候选积分中的每一个进行筛选检查。只有一部分比例为 $s$ 的积分通过检查，并继续进行完整的 ERI 求值和 Fock 更新步骤。\n\n实际计算的积分数量为 $N_{comp} = s \\times N_{ERI} = 0.10 \\times 20000 = 2000$。\n\n总浮点运算次数 $F_{\\text{screen}}$ 是所有筛选检查的浮点运算次数，加上对通过检查的积分进行求值和处理的浮点运算次数之和。\n对所有 $N_{ERI}$ 个候选积分进行筛选检查产生的浮点运算次数：$N_{ERI} \\times F_{screen\\_check}$。\n对 $N_{comp}$ 个计算出的积分进行 ERI 求值和 Fock 更新产生的浮点运算次数：$N_{comp} \\times (F_{eval} + U_{ERI} \\times F_{update})$。\n$$F_{\\text{screen}} = (N_{ERI} \\times F_{screen\\_check}) + (s \\times N_{ERI}) \\times (F_{eval} + U_{ERI} \\times F_{update})$$\n$$F_{\\text{screen}} = (20000 \\times 2) + (0.10 \\times 20000) \\times (2000 + 6 \\times 2)$$\n$$F_{\\text{screen}} = 40000 + 2000 \\times 2012 = 40000 + 4024000 = 4064000 \\text{ flops}$$\n\n总内存流量 $B_{\\text{screen}}$ 是所有筛选检查的内存流量，加上对通过检查的积分进行 Fock 更新的流量之和。\n对所有 $N_{ERI}$ 个候选积分进行筛选检查产生的内存流量：$N_{ERI} \\times B_{screen\\_check}$。\n对 $N_{comp}$ 个计算出的积分进行 Fock 更新产生的内存流量：$N_{comp} \\times U_{ERI} \\times B_{update}$。\n$$B_{\\text{screen}} = (N_{ERI} \\times B_{screen\\_check}) + (s \\times N_{ERI}) \\times U_{ERI} \\times B_{update}$$\n$$B_{\\text{screen}} = (20000 \\times 16) + (0.10 \\times 20000) \\times 6 \\times 24$$\n$$B_{\\text{screen}} = 320000 + 2000 \\times 144 = 320000 + 288000 = 608000 \\text{ bytes}$$\n\n计算强度是这两个量的比值。\n$$I_{\\text{screen}} = \\frac{F_{\\text{screen}}}{B_{\\text{screen}}} = \\frac{4064000}{608000} = \\frac{4064}{608} \\approx 6.6842$$\n四舍五入到三位有效数字，我们得到 $I_{\\text{screen}} = 6.68$ flops/byte。\n\n结果为 $I_{\\text{no-screen}} \\approx 14.0$ 和 $I_{\\text{screen}} \\approx 6.68$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n14.0  6.68\n\\end{pmatrix}\n}\n$$", "id": "2886242"}]}