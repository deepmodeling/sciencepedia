{"hands_on_practices": [{"introduction": "第一个练习将积分筛选的概念建立在其数学基础——柯西-施瓦茨不等式之上。通过一个具体的数值示例，您将看到如何利用一个严格的上限来做出一个具有重要计算意义的决定：是计算一个昂贵的积分四重奏，还是完全跳过它。这个实践旨在巩固所有基于施瓦茨不等式的预筛选技术背后的核心逻辑 [@problem_id:2898934]。", "problem": "在基于实高斯原子轨道基组的限制性Hartree–Fock (RHF) 方法中，构建Fock矩阵的库仑贡献时，考虑双电子排斥积分的定义如下\n$$(\\mu\\nu|\\lambda\\sigma) \\equiv \\iint \\varphi_{\\mu}(\\mathbf{r}_{1})\\,\\varphi_{\\nu}(\\mathbf{r}_{1})\\,\\frac{1}{r_{12}}\\,\\varphi_{\\lambda}(\\mathbf{r}_{2})\\,\\varphi_{\\sigma}(\\mathbf{r}_{2})\\,d\\mathbf{r}_{1}\\,d\\mathbf{r}_{2},$$\n其中 $r_{12} = |\\mathbf{r}_{1}-\\mathbf{r}_{2}|$ 且 $\\{\\varphi_{\\kappa}\\}$ 是归一化基函数。在积分筛选中，一个常见的预筛选步骤是基于将Cauchy–Schwarz不等式应用于 $(\\mathbf{r}_{1},\\mathbf{r}_{2})$ 上合适的 $L^{2}$ 内积。\n\n从上述定义和平方可积函数的Cauchy–Schwarz不等式出发，推导 $|(\\mu\\nu|\\lambda\\sigma)|$ 的一个严格上界，用 $(\\mu\\nu|\\mu\\nu)$ 和 $(\\lambda\\sigma|\\lambda\\sigma)$ 表示。然后，使用用户指定的筛选阈值 $\\tau > 0$，陈述一个准则，在该准则下，壳层四重积分 $(\\mu\\nu|\\lambda\\sigma)$ 在Fock元素 $F_{\\mu\\nu}$ 的库仑项构建中可以被忽略。如果该四重积分未被忽略，请使用你推导出的上界来确定由单个密度矩阵元 $D_{\\lambda\\sigma}$ 产生的对 $F_{\\mu\\nu}$ 的库仑贡献的最大可能值。\n\n使用以下数据：\n$$(\\mu\\nu|\\mu\\nu) = 0.80\\ \\text{Hartree},\\quad (\\lambda\\sigma|\\lambda\\sigma) = 0.45\\ \\text{Hartree},\\quad \\tau = 0.55\\ \\text{Hartree},\\quad D_{\\lambda\\sigma} = 0.18.$$\n\n报告由给定 $(\\mu\\nu|\\lambda\\sigma)$ 四重积分对 $F_{\\mu\\nu}$ 的库仑贡献的最大可能值的单个数值，单位为Hartree。按照惯例，如果该四重积分被忽略，则报告值为 $0$。将您的答案四舍五入到四位有效数字，并以Hartree为单位表示最终能量。", "solution": "问题陈述在科学和数学上均属有效，提供了所有必要数据，且无歧义。下面进行严格求解。\n\n问题要求三个连续的结果：首先，推导双电子排斥积分(ERI)的上界；其次，给出筛选此积分的标准；第三，基于此筛选计算对库仑矩阵的最大贡献。\n\n让我们从双电子排斥积分的定义开始：\n$$(\\mu\\nu|\\lambda\\sigma) \\equiv \\iint \\varphi_{\\mu}(\\mathbf{r}_{1})\\,\\varphi_{\\nu}(\\mathbf{r}_{1})\\,\\frac{1}{r_{12}}\\,\\varphi_{\\lambda}(\\mathbf{r}_{2})\\,\\varphi_{\\sigma}(\\mathbf{r}_{2})\\,d\\mathbf{r}_{1}\\,d\\mathbf{r}_{2}$$\n其中 $r_{12} = |\\mathbf{r}_{1}-\\mathbf{r}_{2}|$。我们将电荷分布（或基函数乘积）定义为 $\\rho_{\\mu\\nu}(\\mathbf{r}) = \\varphi_{\\mu}(\\mathbf{r})\\varphi_{\\nu}(\\mathbf{r})$ 和 $\\rho_{\\lambda\\sigma}(\\mathbf{r}) = \\varphi_{\\lambda}(\\mathbf{r})\\varphi_{\\sigma}(\\mathbf{r})$。这样，该积分可以更紧凑地表示为：\n$$(\\mu\\nu|\\lambda\\sigma) = \\iint \\rho_{\\mu\\nu}(\\mathbf{r}_{1})\\,\\frac{1}{r_{12}}\\,\\rho_{\\lambda\\sigma}(\\mathbf{r}_{2})\\,d\\mathbf{r}_{1}\\,d\\mathbf{r}_{2}$$\n这个表达式定义了实的、平方可积函数空间上的一个内积。对于任意两个此类函数 $f(\\mathbf{r})$ 和 $g(\\mathbf{r})$，它们的内积由下式给出：\n$$\\langle f|g \\rangle = \\iint f(\\mathbf{r}_{1})\\,\\frac{1}{r_{12}}\\,g(\\mathbf{r}_{2})\\,d\\mathbf{r}_{1}\\,d\\mathbf{r}_{2}$$\n与核 $\\frac{1}{r_{12}}$ 对应的算符是正定的，这确保了这是一个有效的内积。此内积的Cauchy–Schwarz不等式表明 $|\\langle f|g \\rangle|^2 \\le \\langle f|f \\rangle \\langle g|g \\rangle$。\n\n通过设 $f = \\rho_{\\mu\\nu}$ 和 $g = \\rho_{\\lambda\\sigma}$，我们可以将Cauchy-Schwarz不等式直接应用于ERI：\n$$|(\\mu\\nu|\\lambda\\sigma)|^2 = |\\langle \\rho_{\\mu\\nu}|\\rho_{\\lambda\\sigma} \\rangle|^2 \\le \\langle \\rho_{\\mu\\nu}|\\rho_{\\mu\\nu} \\rangle \\langle \\rho_{\\lambda\\sigma}|\\rho_{\\lambda\\sigma} \\rangle$$\n转换回标准的ERI表示法，我们得到：\n$$|(\\mu\\nu|\\lambda\\sigma)|^2 \\le (\\mu\\nu|\\mu\\nu)(\\lambda\\sigma|\\lambda\\sigma)$$\n对两边取平方根，得到该积分大小的严格上界：\n$$|(\\mu\\nu|\\lambda\\sigma)| \\le \\sqrt{(\\mu\\nu|\\mu\\nu)(\\lambda\\sigma|\\lambda\\sigma)}$$\n这便是广泛用于电子排斥积分的Schwarz不等式。\n\n接下来，我们建立筛选准则。在预筛选步骤中，目标是避免计算可忽略的积分。一个常见的标准是将推导出的上界与指定的阈值进行比较。设 $I_{max} = \\sqrt{(\\mu\\nu|\\mu\\nu)(\\lambda\\sigma|\\lambda\\sigma)}$。问题提供了一个筛选阈值 $\\tau$。如果四重积分 $(\\mu\\nu|\\lambda\\sigma)$ 的最大可能值 $I_{max}$ 小于此阈值，则认为它是可忽略的，因此被跳过。该准则为：\n$$\\text{若 } \\sqrt{(\\mu\\nu|\\mu\\nu)(\\lambda\\sigma|\\lambda\\sigma)}  \\tau \\text{，则忽略该四重积分}$$\n\n我们现在使用给定的数据应用此准则：$(\\mu\\nu|\\mu\\nu) = 0.80$ Hartree, $(\\lambda\\sigma|\\lambda\\sigma) = 0.45$ Hartree, 以及 $\\tau = 0.55$ Hartree。\n首先，我们计算上界 $I_{max}$：\n$$I_{max} = \\sqrt{(0.80)(0.45)} = \\sqrt{0.36} = 0.60\\ \\text{Hartree}$$\n现在，我们将此上界与阈值 $\\tau$ 进行比较，检查是否满足忽略条件：\n$$0.60  0.55$$\n这个不等式不成立。因此，根据指定的准则和数据，积分四重积分 $(\\mu\\nu|\\lambda\\sigma)$ **不**被忽略。\n\n最后的任务是确定来自这个特定四重积分对Fock矩阵元 $F_{\\mu\\nu}$ 的库仑贡献的最大可能值。来自密度矩阵元 $D_{\\lambda\\sigma}$ 的库仑贡献由项 $C = D_{\\lambda\\sigma} (\\mu\\nu|\\lambda\\sigma)$ 给出。此贡献的大小为 $|C| = |D_{\\lambda\\sigma}| |(\\mu\\nu|\\lambda\\sigma)|$。最大可能值 $|C|_{max}$ 出现在 $|(\\mu\\nu|\\lambda\\sigma)|$ 达到其上界 $I_{max}$ 时：\n$$|C|_{max} = |D_{\\lambda\\sigma}| \\times I_{max}$$\n使用给定的值 $D_{\\lambda\\sigma} = 0.18$ 和我们计算出的值 $I_{max} = 0.60$ Hartree：\n$$|C|_{max} = |0.18| \\times 0.60 = 0.18 \\times 0.60 = 0.108\\ \\text{Hartree}$$\n问题要求答案报告为四位有效数字。因此，我们将 $0.108$ 表示为 $0.1080$。\n如果该四重积分被忽略，则答案为 $0$。由于它未被忽略，计算出的最大贡献即为所求答案。", "answer": "$$\\boxed{0.1080}$$", "id": "2898934"}, {"introduction": "在基本原理的基础上，本练习探讨了在实际计算中使用收缩基函数时出现的一个关键的微妙问题。它演示了由于相长干涉，朴素的筛选方法为何会失效，并强调了采用更稳健的多阶段方法的必要性 [@problem_id:2899009]。这个练习对于培养设计可靠且高效的量子化学算法所需的直觉至关重要。", "problem": "考虑高斯基组中的电子排斥积分 (ERI)，其对收缩高斯型轨道 (CGTO) 的定义如下。每个收缩基函数是归一化原函数的线性组合，$\\chi_{\\mu}(\\mathbf{r}) = \\sum_{p} c_{\\mu p} g_{\\mu p}(\\mathbf{r})$，一个普遍的 ERI 为 $(\\mu\\nu|\\lambda\\sigma) = \\iint \\chi_{\\mu}(\\mathbf{r}_1)\\chi_{\\nu}(\\mathbf{r}_1)\\frac{1}{r_{12}}\\chi_{\\lambda}(\\mathbf{r}_2)\\chi_{\\sigma}(\\mathbf{r}_2)\\,d\\mathbf{r}_1 d\\mathbf{r}_2$。根据柯西-施瓦茨不等式 (CSI)，可以得到一个界限 $|(\\mu\\nu|\\lambda\\sigma)| \\le \\| \\mu\\nu \\| \\cdot \\| \\lambda\\sigma \\|$，其中 $\\| \\mu\\nu \\| \\equiv \\sqrt{(\\mu\\nu|\\mu\\nu)}$。在实践中，积分筛选通常在决定是否计算 $(\\mu\\nu|\\lambda\\sigma)$ 之前，先廉价地估计 $\\|\\mu\\nu\\|$。\n\n你获得了一个具体的壳层对例子，旨在探究忽略收缩效应的朴素施瓦茨筛选的失效模式。设有壳层对 $AB$ 和 $CD$，每个壳层由两个原函数构成，使得在库仑度规下的收缩壳层对“向量”可以表示为两个近乎平行的原函数乘积贡献的线性组合，\n$\\mathbf{v}_{AB} = w_1 \\mathbf{v}_1 + w_2 \\mathbf{v}_2$ 和 $\\mathbf{v}_{CD} = u_1 \\mathbf{u}_1 + u_2 \\mathbf{u}_2$。假设以下明确数据成立：\n- 对于 $AB$：$\\|\\mathbf{v}_1\\| = \\|\\mathbf{v}_2\\| = 10^{-2}$，$\\langle \\mathbf{v}_1,\\mathbf{v}_2 \\rangle = 0.99 \\times 10^{-4}$，以及由收缩系数和归一化产生的权重 $w_1 = w_2 = 5$。\n- 对于 $CD$：$\\|\\mathbf{u}_1\\| = \\|\\mathbf{u}_2\\| = 10^{-2}$，$\\langle \\mathbf{u}_1,\\mathbf{u}_2 \\rangle = 0.99 \\times 10^{-4}$，以及权重 $u_1 = u_2 = 5$。\n\n进一步假设收缩壳层对向量的相对方向满足 $\\langle \\mathbf{v}_{AB}, \\mathbf{v}_{CD} \\rangle = \\cos\\theta \\, \\|\\mathbf{v}_{AB}\\| \\, \\|\\mathbf{v}_{CD}\\|$，其中 $\\cos\\theta = 0.5$。使用一个筛选阈值 $\\tau$ 如下：如果有一个估计量 $\\widehat{\\|\\mu\\nu\\|}$，当 $\\widehat{\\|\\mu\\nu\\|}\\,\\widehat{\\|\\lambda\\sigma\\|}  \\tau$ 时，代码将跳过 $(\\mu\\nu|\\lambda\\sigma)$。取 $\\tau = 10^{-3}$。\n\n一位开发者提出了一种忽略收缩结构的朴素单阶段估计，取 $\\widehat{\\|AB\\|} = \\max_{i\\in\\{1,2\\}} \\|\\mathbf{v}_i\\|$，对 $CD$ 也类似。你需要分析这种朴素筛选是否会在上述具体例子中漏掉大的 ERI，并选择一个不会漏掉它们、同时仅使用基本不等式（柯西-施瓦茨不等式和三角不等式）和定义的鲁棒多阶段筛选方法。\n\n以下哪个选项给出了对失效的正确诊断，并提供了一个鲁棒、安全的多阶段筛选协议，该协议能避免在此例中漏掉大的 ERI，同时保持计算效率？\n\nA. 仅使用朴素的单阶段界限 $\\widehat{\\|AB\\|} = \\max_{i} \\|\\mathbf{v}_i\\|$ 和 $\\widehat{\\|CD\\|} = \\max_{j} \\|\\mathbf{u}_j\\|$。因为每个原函数的范数是任何收缩的上界，所以这是保证安全的；乘积 $10^{-2} \\cdot 10^{-2} = 10^{-4}$ 低于 $\\tau$，因此 $(AB|CD)$ 可以被跳过。\n\nB. 使用一个考虑收缩效应的两阶段施瓦茨筛选。阶段1：应用三角不等式得到安全但廉价的界限 $\\widehat{\\|AB\\|}_{1} = \\sum_{i} |w_i| \\|\\mathbf{v}_i\\|$ 和 $\\widehat{\\|CD\\|}_{1} = \\sum_{j} |u_j| \\|\\mathbf{u}_j\\|$; 如果 $\\widehat{\\|AB\\|}_{1}\\,\\widehat{\\|CD\\|}_{1}  \\tau$，则安全跳过。否则，阶段2：通过原函数库仑度规计算精确的收缩壳层对范数，$\\|AB\\|^2 = \\mathbf{w}^\\top \\mathbf{M}^{(AB)} \\mathbf{w}$ 和 $\\|CD\\|^2 = \\mathbf{u}^\\top \\mathbf{M}^{(CD)} \\mathbf{u}$，其中 $\\mathbf{M}^{(AB)}_{ij} = \\langle \\mathbf{v}_i,\\mathbf{v}_j\\rangle$，对 $CD$ 也类似，然后应用收缩施瓦茨界限来决定。为了构建福克矩阵，可以添加密度加权筛选 $|P_{\\mu\\nu}| \\| \\mu\\nu \\|$ 来进一步减少工作量。\n\nC. 用重叠度规筛选替换库仑度规施瓦茨界限，通过 $\\|S_{\\mu\\nu}\\| \\equiv \\sqrt{\\langle \\chi_\\mu \\chi_\\nu, \\chi_\\mu \\chi_\\nu \\rangle_S}$ 来估计 $\\|\\mu\\nu\\|$，其中 $\\langle \\cdot,\\cdot \\rangle_S$ 是重叠内积，因为重叠的计算更廉价。由于重叠随距离的衰减比库仑相互作用更快，这将比施瓦茨筛选更安全。\n\nD. 完全依赖于中心间距离筛选。使用点电荷估计 $\\widehat{|(\\mu\\nu|\\lambda\\sigma)|} = 1/R_{\\text{min}}$，其中 $R_{\\text{min}}$ 是 $\\{A,B\\}$ 和 $\\{C,D\\}$ 之间的最小中心间距离，忽略收缩系数和指数。这是一个通用的上界，所以任何满足 $\\widehat{|(\\mu\\nu|\\lambda\\sigma)|}  \\tau$ 的积分都可以被安全地跳过。", "solution": "该问题科学上合理、表述清晰、内部一致，通过一个具体示例阐述了量子化学积分计算中的一个重要难题，并提供了所有必需数据。因此，该问题有效。\n\n任务是分析朴素筛选协议的失效原因，并确定一种鲁棒的替代方案。我们进行严格的分析。\n\n首先，我们分析朴素筛选协议。收缩壳层对 $AB$ 的范数的估计量是 $\\widehat{\\|AB\\|} = \\max_{i} \\|\\mathbf{v}_i\\|$。给定 $\\|\\mathbf{v}_1\\| = \\|\\mathbf{v}_2\\| = 10^{-2}$，得到 $\\widehat{\\|AB\\|} = 10^{-2}$。壳层对 $CD$ 的数据完全相同，因此 $\\widehat{\\|CD\\|} = \\max_{j} \\|\\mathbf{u}_j\\| = 10^{-2}$。筛选条件基于这些估计量的乘积：\n$$ \\widehat{\\|AB\\|} \\cdot \\widehat{\\|CD\\|} = (10^{-2}) \\cdot (10^{-2}) = 10^{-4} $$\n给定的阈值是 $\\tau = 10^{-3}$。由于 $10^{-4}  10^{-3}$，这种朴素协议将不经计算就丢弃积分 $(AB|CD)$。\n\n接下来，我们必须通过计算积分的精确值来确定这个决定是否正确。该积分定义为内积 $(AB|CD) = \\langle \\mathbf{v}_{AB}, \\mathbf{v}_{CD} \\rangle$。我们已知 $\\langle \\mathbf{v}_{AB}, \\mathbf{v}_{CD} \\rangle = 0.5 \\cdot \\|\\mathbf{v}_{AB}\\| \\cdot \\|\\mathbf{v}_{CD}\\|$。我们必须计算收缩壳层对向量的精确范数。\n对于 $\\mathbf{v}_{AB}$：\n$$ \\|\\mathbf{v}_{AB}\\|^2 = \\langle w_1 \\mathbf{v}_1 + w_2 \\mathbf{v}_2, w_1 \\mathbf{v}_1 + w_2 \\mathbf{v}_2 \\rangle $$\n$$ \\|\\mathbf{v}_{AB}\\|^2 = w_1^2 \\|\\mathbf{v}_1\\|^2 + w_2^2 \\|\\mathbf{v}_2\\|^2 + 2 w_1 w_2 \\langle \\mathbf{v}_1, \\mathbf{v}_2 \\rangle $$\n代入所给数据：\n$$ \\|\\mathbf{v}_{AB}\\|^2 = (5^2)(10^{-2})^2 + (5^2)(10^{-2})^2 + 2(5)(5)(0.99 \\times 10^{-4}) $$\n$$ \\|\\mathbf{v}_{AB}\\|^2 = 25 \\times 10^{-4} + 25 \\times 10^{-4} + 50 \\times 0.99 \\times 10^{-4} $$\n$$ \\|\\mathbf{v}_{AB}\\|^2 = 50 \\times 10^{-4} + 49.5 \\times 10^{-4} = 99.5 \\times 10^{-4} $$\n$\\mathbf{v}_{CD}$ 的数据完全相同，所以 $\\|\\mathbf{v}_{CD}\\|^2 = 99.5 \\times 10^{-4}$。\n现在我们计算积分 $(AB|CD)$ 的值：\n$$ (AB|CD) = 0.5 \\cdot \\|\\mathbf{v}_{AB}\\| \\cdot \\|\\mathbf{v}_{CD}\\| = 0.5 \\cdot \\sqrt{99.5 \\times 10^{-4}} \\cdot \\sqrt{99.5 \\times 10^{-4}} $$\n$$ (AB|CD) = 0.5 \\cdot (99.5 \\times 10^{-4}) = 49.75 \\times 10^{-4} = 4.975 \\times 10^{-3} $$\n积分的绝对值是 $|(AB|CD)| = 4.975 \\times 10^{-3}$。该值大于筛选阈值 $\\tau = 10^{-3}$。朴素筛选协议估计其贡献量级为 $10^{-4}$，因此灾难性地失效了，并且会错误地丢弃一个数值上很重要的积分。失效的根源在于原函数乘积分布之间的相长干涉（$\\mathbf{v}_1$ 和 $\\mathbf{v}_2$ 近乎平行，因为 $\\langle \\mathbf{v}_1, \\mathbf{v}_2 \\rangle / (\\|\\mathbf{v}_1\\|\\|\\mathbf{v}_2\\|) = 0.99$），并被大的收缩系数所放大。\n\n我们现在评估给定的选项。\n\nA. 此选项主张采用朴素筛选，声称它是“保证安全的”，因为“每个原函数的范数是任何收缩的上界”。这个前提显然是错误的。我们计算出收缩范数 $\\|\\mathbf{v}_{AB}\\| = \\sqrt{99.5 \\times 10^{-4}} \\approx 9.975 \\times 10^{-2}$，这比原函数范数 $\\|\\mathbf{v}_i\\| = 10^{-2}$ 大了将近一个数量级。如上所示，跳过该积分的结论是错误的。\n结论：**不正确**。\n\nB. 此选项提出了一个两阶段筛选协议。\n阶段1：使用三角不等式建立一个安全的上界：$\\|\\mathbf{v}_{AB}\\| = \\|w_1 \\mathbf{v}_1 + w_2 \\mathbf{v}_2\\| \\le |w_1|\\|\\mathbf{v}_1\\| + |w_2|\\|\\mathbf{v}_2\\|$。这是一个数学上严格的上界。我们来计算这个估计量 $\\widehat{\\|AB\\|}_{1}$：\n$$ \\widehat{\\|AB\\|}_{1} = |5| \\cdot 10^{-2} + |5| \\cdot 10^{-2} = 10 \\times 10^{-2} = 10^{-1} $$\n类似地，$\\widehat{\\|CD\\|}_{1} = 10^{-1}$。筛选乘积为 $\\widehat{\\|AB\\|}_{1} \\cdot \\widehat{\\|CD\\|}_{1} = 10^{-1} \\cdot 10^{-1} = 10^{-2}$。\n由于 $10^{-2} > \\tau = 10^{-3}$，这第一阶段正确地防止了积分被跳过，并要求进入下一阶段。\n阶段2：此阶段涉及计算精确的收缩范数的平方，$\\|AB\\|^2 = \\mathbf{w}^\\top \\mathbf{M}^{(AB)} \\mathbf{w}$，其中 $\\mathbf{M}^{(AB)}_{ij} = \\langle \\mathbf{v}_i, \\mathbf{v}_j \\rangle$。这正是我们为求得 $\\|\\mathbf{v}_{AB}\\|^2 = 99.5 \\times 10^{-4}$ 所做的计算。由此产生的施瓦茨界限为 $\\|\\mathbf{v}_{AB}\\| \\cdot \\|\\mathbf{v}_{CD}\\| = 99.5 \\times 10^{-4} \\approx 10^{-2}$。由于该值大于 $\\tau=10^{-3}$，该积分被正确地标记为需要完整计算。这个两阶段协议既鲁棒（它在每个阶段都提供了数学上保证的上界）又高效（只有当廉价的阶段1表明有必要时，才执行昂贵的阶段2）。关于密度加权筛选的最后评论是对实际代码中进一步优化的准确描述。\n结论：**正确**。\n\nC. 此选项建议用重叠度规筛选替换库仑度规施瓦茨界限。其声称这是“更安全的”，因为据说重叠比库仑相互作用衰减得更快。这在根本上是有缺陷的。筛选的安全性要求有严格的上界。没有普适的不等式能保证重叠范数 $\\sqrt{\\int (\\chi_\\mu\\chi_\\nu)^2 d\\mathbf{r}}$ 为库仑范数 $\\sqrt{(\\mu\\nu|\\mu\\nu)}$ 提供上界。对于弥散函数，其电荷分布很广，重叠可能很小，而长程库仑相互作用仍然显著。该协议不能保证安全，并且依赖于物理直觉而非数学严谨性。\n结论：**不正确**。\n\nD. 此选项建议使用点电荷近似 $\\widehat{|(\\mu\\nu|\\lambda\\sigma)|} = 1/R_{\\text{min}}$，并声称这是一个“通用的上界”。这显然是错误的。ERI 的值关键取决于四个基函数的空间范围和重叠，这由它们的指数和收缩系数决定，而不仅仅是它们中心之间的距离。可以轻易构造出反例。例如，对于两个高度弥散、重叠的电荷分布，即使 $R_{\\text{min}}$ 很大，积分也可能非常大。反之，对于四个非常紧凑的函数，即使 $R_{\\text{min}}$ 很小，积分也可能可以忽略不计。这个估计量是一个粗略的近似，而不是一个严格的界限，因此用于筛选是不安全的。\n结论：**不正确**。\n\n综上所述，只有选项 B 正确地诊断了朴素方法的失效，并提出了一个数学上可靠、鲁棒且分阶段的筛选协议，该协议正确地处理了给定案例中收缩基函数内的相长干涉。", "answer": "$$\\boxed{B}$$", "id": "2899009"}, {"introduction": "这最后一个练习将前面练习中的概念综合成一个完整的计算任务。您将从第一性原理出发，实现一个筛选算法，从原始积分的解析公式开始，最终完成一个基于壳层对界限的功能性筛选测试 [@problem_id:2898970]。这种亲自动手的编程经验巩固了理论知识，并提供了一个具体的例子，说明这些技术是如何在量子化学软件中实现的。", "problem": "构建一个完整、可运行的程序。给定一组固定的收缩、归一化的笛卡尔 $s$ 型高斯壳层以及一组带阈值的壳层四重态，该程序为每个壳层对 $\\left(I,J\\right)$ 计算一个壳层对界 $B_{IJ}$，并且当且仅当 $B_{IJ}\\,B_{KL}\\tau$ 时，筛选一个壳层四重态 $\\left(I,J\\mid K,L\\right)$。您的程序必须从以下公认的基础出发，从第一性原理实现计算。\n\n使用的基本定义和事实：\n- 一个中心位于 $\\mathbf{A}\\in\\mathbb{R}^{3}$、指数为 $\\alpha>0$ 的原始、归一化的 $s$ 型高斯函数是 $\\phi\\left(\\mathbf{r};\\alpha,\\mathbf{A}\\right)=N\\left(\\alpha\\right)\\,\\exp\\left(-\\alpha\\left\\lVert\\mathbf{r}-\\mathbf{A}\\right\\rVert^{2}\\right)$，其中 $N\\left(\\alpha\\right)=\\left(\\dfrac{2\\alpha}{\\pi}\\right)^{3/4}$。\n- 一个收缩的 $s$ 型壳层 $I$ 是一个线性组合 $\\Phi_{I}\\left(\\mathbf{r}\\right)=\\sum_{a=1}^{n_{I}} d_{a}^{\\left(I\\right)}\\,\\phi\\left(\\mathbf{r};\\alpha_{a}^{\\left(I\\right)},\\mathbf{A}_{I}\\right)$，具有实数收缩系数 $d_{a}^{\\left(I\\right)}$ 和原函数指数 $\\alpha_{a}^{\\left(I\\right)}>0$，所有这些都共享相同的中心 $\\mathbf{A}_{I}$。\n- 在两个收缩壳层乘积上的电子排斥积分定义为 $\\left(IJ\\mid KL\\right)=\\displaystyle\\iint \\dfrac{\\Phi_{I}\\left(\\mathbf{r}_{1}\\right)\\Phi_{J}\\left(\\mathbf{r}_{1}\\right)\\,\\Phi_{K}\\left(\\mathbf{r}_{2}\\right)\\Phi_{L}\\left(\\mathbf{r}_{2}\\right)}{\\left\\lVert\\mathbf{r}_{1}-\\mathbf{r}_{2}\\right\\rVert}\\,\\mathrm{d}\\mathbf{r}_{1}\\,\\mathrm{d}\\mathbf{r}_{2}$。\n- 柯西-施瓦茨不等式意味着筛选界 $\\left\\lvert\\left(IJ\\mid KL\\right)\\right\\rvert\\le \\sqrt{\\left(IJ\\mid IJ\\right)}\\,\\sqrt{\\left(KL\\mid KL\\right)}$。定义壳层对界 $B_{IJ}=\\sqrt{\\left(IJ\\mid IJ\\right)}$。\n- 高斯乘积定理和经过充分检验的一维积分约化，为原始 $s$ 型电子排斥积分提供了以 $0$ 阶 Boys 函数表示的闭式形式，$F_{0}\\!\\left(T\\right)=\\dfrac{1}{2}\\sqrt{\\dfrac{\\pi}{T}}\\,\\mathrm{erf}\\!\\left(\\sqrt{T}\\right)$（对于 $T>0$），其连续极限为 $F_{0}\\!\\left(0\\right)=1$。您的程序必须以数值稳定的方式对所有 $T\\ge 0$ 计算 $F_{0}\\!\\left(T\\right)$。\n\n算法任务：\n- 仅使用上述基本项，推导并实现一个算法，通过展开为原函数积分和 Boys 函数的数值计算，精确地评估收缩 $s$ 型壳层的 $\\left(IJ\\mid IJ\\right)$，并由此计算 $B_{IJ}$。然后，对于每个具有阈值 $\\tau$ 的四重态 $\\left(I,J\\mid K,L\\right)$，通过测试 $B_{IJ}\\,B_{KL}\\tau$ 来判断它是否被筛选掉。\n\n任务中嵌入的输入（固定测试套件）：\n- 有 $4$ 个壳层，索引为 $0,1,2,3$，每个都是一个 $s$ 型收缩高斯壳层，参数如下：\n  - 壳层 $0$：中心 $\\mathbf{A}_{0}=\\left(0.0,0.0,0.0\\right)$，指数 $\\left[\\alpha\\right]=\\left[0.5,0.15\\right]$，系数 $\\left[d\\right]=\\left[0.6,0.4\\right]$。\n  - 壳层 $1$：中心 $\\mathbf{A}_{1}=\\left(1.2,0.0,0.0\\right)$，指数 $\\left[\\alpha\\right]=\\left[0.9\\right]$，系数 $\\left[d\\right]=\\left[1.0\\right]$。\n  - 壳层 $2$：中心 $\\mathbf{A}_{2}=\\left(0.0,2.0,0.0\\right)$，指数 $\\left[\\alpha\\right]=\\left[0.3,1.0\\right]$，系数 $\\left[d\\right]=\\left[0.7,0.3\\right]$。\n  - 壳层 $3$：中心 $\\mathbf{A}_{3}=\\left(6.0,0.0,0.0\\right)$，指数 $\\left[\\alpha\\right]=\\left[0.2\\right]$，系数 $\\left[d\\right]=\\left[1.0\\right]$。\n- 评估以下 $5$ 个具有给定阈值 $\\tau$ 的测试四重态 $\\left(I,J\\mid K,L\\right)$：\n  - 情况 $1$：$\\left(0,1\\mid 0,1\\right)$，$\\tau=10^{-3}$。\n  - 情况 $2$：$\\left(0,3\\mid 1,3\\right)$，$\\tau=10^{-6}$。\n  - 情况 $3$：$\\left(1,1\\mid 1,1\\right)$，$\\tau=10^{-1}$。\n  - 情况 $4$：$\\left(0,2\\mid 0,2\\right)$，$\\tau=10^{-3}$。\n  - 情况 $5$：$\\left(2,3\\mid 2,3\\right)$，$\\tau=10^{-5}$。\n\n输出要求：\n- 对于每种情况，输出一个布尔值，指示该四重态是否被筛选掉，即 $B_{IJ}\\,B_{KL}\\tau$ 的计算结果是否为真。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，不含空格，按上述 $5$ 种情况的顺序排列；例如，$\\left[\\mathrm{True},\\mathrm{False},\\ldots\\right]$ 但打印时无空格，如 `[True,False,...]`。\n- 不涉及物理单位；所有量均为无量纲。\n\n约束：\n- 除了从基本项推导出的内容外，您不得硬编码任何收缩积分的闭式表达式。通过对原函数贡献进行显式求和来计算收缩量，并以数值方式小心处理 $T\\to 0$ 的情况来计算 $F_{0}\\!\\left(T\\right)$。\n- 假设所有壳层均为 $s$ 型；角动量大于零的情况超出了本任务的范围。", "solution": "问题陈述有效。该问题在科学上基于量子化学的积分计算原理，定义明确，提供了求解唯一解所需的所有数据和定义。任务是计算化学中的一个标准程序。\n\n问题的核心是根据柯西-施瓦茨不等式，判断一个表示为 $\\left(IJ\\mid KL\\right)$ 的电子排斥积分壳层四重态是否可以忽略。筛选条件为 $B_{IJ}\\,B_{KL}\\tau$，其中 $\\tau$ 是一个数值阈值，$B_{PQ}$ 是定义为 $B_{PQ} = \\sqrt{\\left(PQ\\mid PQ\\right)}$ 的壳层对界。为了实现这个筛选过程，我们必须首先开发一种方法，用以计算任何一对收缩 $s$ 型高斯壳层 $I$ 和 $J$ 的积分 $\\left(IJ\\mid IJ\\right)$。\n\n一个收缩的 $s$ 型壳层 $\\Phi_{I}$ 是原始 $s$ 型高斯函数 $\\phi_a^I$ 的线性组合：\n$$ \\Phi_{I}\\left(\\mathbf{r}\\right)=\\sum_{a=1}^{n_{I}} d_{a}^{\\left(I\\right)}\\,\\phi\\left(\\mathbf{r};\\alpha_{a}^{\\left(I\\right)},\\mathbf{A}_{I}\\right) $$\n其中 $d_{a}^{\\left(I\\right)}$ 是收缩系数，$\\alpha_{a}^{\\left(I\\right)}$ 是指数，$\\mathbf{A}_{I}$ 是壳层的中心。原始高斯函数 $\\phi$ 是归一化的，其归一化常数为 $N\\left(\\alpha\\right)=\\left(\\frac{2\\alpha}{\\pi}\\right)^{3/4}$。\n\n双电子排斥积分 $\\left(IJ\\mid IJ\\right)$ 是在这些收缩壳层上定义的：\n$$ \\left(IJ\\mid IJ\\right)=\\iint \\dfrac{\\Phi_{I}\\left(\\mathbf{r}_{1}\\right)\\Phi_{J}\\left(\\mathbf{r}_{1}\\right)\\,\\Phi_{I}\\left(\\mathbf{r}_{2}\\right)\\Phi_{J}\\left(\\mathbf{r}_{2}\\right)}{\\left\\lVert\\mathbf{r}_{1}-\\mathbf{r}_{2}\\right\\rVert}\\,\\mathrm{d}\\mathbf{r}_{1}\\,\\mathrm{d}\\mathbf{r}_{2} $$\n通过代入 $\\Phi_I$ 和 $\\Phi_J$ 的线性展开式，该积分变成对原始高斯函数积分的求和：\n$$ \\left(IJ\\mid IJ\\right) = \\sum_{a \\in I} \\sum_{b \\in J} \\sum_{c \\in I} \\sum_{d \\in J} d_{a}^{\\left(I\\right)} d_{b}^{\\left(J\\right)} d_{c}^{\\left(I\\right)} d_{d}^{\\left(J\\right)} \\left(\\phi_a^I \\phi_b^J \\mid \\phi_c^I \\phi_d^J\\right) $$\n其中 $\\left(\\phi_a^I \\phi_b^J \\mid \\phi_c^I \\phi_d^J\\right)$ 是涉及四个高斯函数的原函数积分：$\\phi_a^I$ 中心在 $\\mathbf{A}_I$，$\\phi_b^J$ 在 $\\mathbf{A}_J$，$\\phi_c^I$ 在 $\\mathbf{A}_I$，$\\phi_d^J$ 在 $\\mathbf{A}_J$。\n\n一个具有指数 $\\alpha_a, \\alpha_b, \\alpha_c, \\alpha_d$ 和中心 $\\mathbf{A}, \\mathbf{B}, \\mathbf{C}, \\mathbf{D}$ 的原始 $s$ 型电子排斥积分 $\\left(\\phi_a \\phi_b \\mid \\phi_c \\phi_d\\right)$ 的值可以使用高斯乘积定理推导出来。两个高斯函数的乘积是另一个高斯函数。这使得六维积分可以约化为已知形式。归一化原函数的最终解析表达式为：\n$$ \\left(\\phi_a \\phi_b \\mid \\phi_c \\phi_d\\right) = N_a N_b N_c N_d \\frac{2\\pi^{5/2}}{p_{ab}p_{cd}\\sqrt{p_{ab}+p_{cd}}} \\exp\\left(-\\frac{\\alpha_a\\alpha_b}{p_{ab}}\\left\\lVert\\mathbf{A}-\\mathbf{B}\\right\\rVert^2 - \\frac{\\alpha_c\\alpha_d}{p_{cd}}\\left\\lVert\\mathbf{C}-\\mathbf{D}\\right\\rVert^2\\right) F_0\\left(T\\right) $$\n这里使用了以下定义：\n- $p_{ab} = \\alpha_a + \\alpha_b$ 和 $p_{cd} = \\alpha_c + \\alpha_d$。\n- 乘积高斯函数的新中心是 $\\mathbf{P}_{ab} = \\frac{\\alpha_a\\mathbf{A} + \\alpha_b\\mathbf{B}}{p_{ab}}$ 和 $\\mathbf{P}_{cd} = \\frac{\\alpha_c\\mathbf{C} + \\alpha_d\\mathbf{D}}{p_{cd}}$。\n- Boys 函数的自变量是 $T = \\frac{p_{ab}p_{cd}}{p_{ab}+p_{cd}}\\left\\lVert\\mathbf{P}_{ab}-\\mathbf{P}_{cd}\\right\\rVert^2$。\n- $N_k = \\left(\\frac{2\\alpha_k}{\\pi}\\right)^{3/4}$ 是原函数 $\\phi_k$ 的归一化常数。\n\n$0$ 阶 Boys 函数 $F_0\\left(T\\right)$ 在 $T > 0$ 时的表达式为：\n$$ F_0\\left(T\\right) = \\frac{1}{2}\\sqrt{\\frac{\\pi}{T}}\\,\\mathrm{erf}\\left(\\sqrt{T}\\right) $$\n对于 $T=0$，其极限为 $F_0\\left(0\\right)=1$。在数值计算上，对于小的 $T$，直接使用该公式是不稳定的。我们使用 $F_0(T)$ 在 $T=0$ 附近的泰勒级数展开：\n$$ F_0\\left(T\\right) = \\sum_{n=0}^{\\infty} \\frac{\\left(-T\\right)^n}{2n+1} = 1 - \\frac{T}{3} + \\frac{T^2}{5} - O\\left(T^3\\right) $$\n使用一个小的 $T$ 阈值（例如，$10^{-8}$）来在级数展开和涉及误差函数 $\\mathrm{erf}$ 的精确公式之间切换。\n\n算法流程如下：\n1. 对于测试套件中的每个壳层四重态 $\\left(I,J\\mid K,L\\right)$ 和阈值 $\\tau$，识别出必要的壳层对：$\\left(I,J\\right)$ 和 $\\left(K,L\\right)$。\n2. 对于每个唯一的壳层对 $\\left(P,Q\\right)$，使用上述公式，通过对其所有组成的原函数积分求和来计算积分 $\\left(PQ\\mid PQ\\right)$。使用缓存来存储和重用已计算的界值 $B_{PQ}$，以避免冗余计算。\n3. 计算壳层对界 $B_{PQ} = \\sqrt{\\left(PQ\\mid PQ\\right)}$。\n4. 在计算出界 $B_{IJ}$ 和 $B_{KL}$ 后，评估筛选条件 $B_{IJ}B_{KL}  \\tau$。\n5. 此比较的布尔结果决定了四重态是否被筛选掉。收集所有测试用例的结果，并格式化为所需的输出字符串。\n该过程按照规定，从第一性原理正确地实现了积分筛选。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Solves the integral screening problem for a fixed set of Gaussian shells and quartets.\n    \"\"\"\n\n    # Define shell data structure\n    # Shells are dictionaries with center (np.array), alphas (np.array), and coeffs (np.array)\n    shells = [\n        # Shell 0\n        {'center': np.array([0.0, 0.0, 0.0]), 'alphas': np.array([0.5, 0.15]), 'coeffs': np.array([0.6, 0.4])},\n        # Shell 1\n        {'center': np.array([1.2, 0.0, 0.0]), 'alphas': np.array([0.9]), 'coeffs': np.array([1.0])},\n        # Shell 2\n        {'center': np.array([0.0, 2.0, 0.0]), 'alphas': np.array([0.3, 1.0]), 'coeffs': np.array([0.7, 0.3])},\n        # Shell 3\n        {'center': np.array([6.0, 0.0, 0.0]), 'alphas': np.array([0.2]), 'coeffs': np.array([1.0])},\n    ]\n\n    # Test cases: (I, J, K, L, tau)\n    test_cases = [\n        (0, 1, 0, 1, 1e-3),\n        (0, 3, 1, 3, 1e-6),\n        (1, 1, 1, 1, 1e-1),\n        (0, 2, 0, 2, 1e-3),\n        (2, 3, 2, 3, 1e-5),\n    ]\n\n    def boys_F0(T):\n        \"\"\"\n        Computes the Boys function F_0(T) in a numerically stable manner.\n        \"\"\"\n        if T  1e-8:\n            return 1.0 - T/3.0 + T**2/5.0 - T**3/7.0 + T**4/9.0\n        else:\n            return 0.5 * np.sqrt(np.pi / T) * erf(np.sqrt(T))\n\n    # Vectorize the Boys function to apply it to NumPy arrays\n    vec_boys_F0 = np.vectorize(boys_F0)\n\n    def compute_B_IJ(shell_I, shell_J):\n        \"\"\"\n        Computes the shell-pair bound B_IJ = sqrt((IJ|IJ)).\n        This function is vectorized for efficiency and clarity.\n        \"\"\"\n        coeffs_I = shell_I['coeffs']\n        alphas_I = shell_I['alphas']\n        center_I = shell_I['center']\n\n        coeffs_J = shell_J['coeffs']\n        alphas_J = shell_J['alphas']\n        center_J = shell_J['center']\n\n        dist_sq_IJ = np.sum((center_I - center_J)**2)\n\n        # Expand primitive parameters into 4D arrays for vectorized computation\n        # Dimensions correspond to prims a, b, c, d\n        da = coeffs_I[:, None, None, None]\n        db = coeffs_J[None, :, None, None]\n        dc = coeffs_I[None, None, :, None]\n        dd = coeffs_J[None, None, None, :]\n        coeffs_prod = da * db * dc * dd\n        \n        aa = alphas_I[:, None, None, None]\n        ab = alphas_J[None, :, None, None]\n        ac = alphas_I[None, None, :, None]\n        ad = alphas_J[None, None, None, :]\n\n        # Compute arguments for the ERI formula\n        pab = aa + ab\n        pcd = ac + ad\n        \n        # Argument for Boys function\n        # T = [p_ab*p_cd / (p_ab+p_cd)] * ||P_ab - P_cd||^2\n        # ||P_ab - P_cd||^2 = [ (alpha_a*alpha_d - alpha_b*alpha_c) / (p_ab*p_cd) ]^2 * ||A_I - A_J||^2\n        T_factor = ((aa*ad - ab*ac)**2 / (pab * pcd * (pab + pcd)))\n        T = T_factor * dist_sq_IJ\n\n        # Handle T=0 case by avoiding division by zero\n        # This occurs when aa*ad - ab*ac = 0 or dist_sq_IJ = 0.\n        # np.nan_to_num will convert NaN from 0/0 to 0, which is correct for T.\n        T = np.nan_to_num(T)\n        f0_values = vec_boys_F0(T)\n\n        # Exponential prefactor\n        exp_term = np.exp(-(aa*ab/pab + ac*ad/pcd) * dist_sq_IJ)\n\n        # Normalization constants\n        N_a = (2 * aa / np.pi)**0.75\n        N_b = (2 * ab / np.pi)**0.75\n        N_c = (2 * ac / np.pi)**0.75\n        N_d = (2 * ad / np.pi)**0.75\n\n        # Constant part of the primitive integral formula\n        const_factor = (2 * np.pi**2.5) / (pab * pcd * np.sqrt(pab + pcd))\n        \n        # Combine all parts to get the primitive integrals\n        prim_integrals = N_a * N_b * N_c * N_d * const_factor * exp_term * f0_values\n        \n        # Sum over all primitive contributions\n        total_integral = np.sum(coeffs_prod * prim_integrals)\n\n        return np.sqrt(total_integral)\n\n    # Main logic\n    results = []\n    B_cache = {}\n\n    for I, J, K, L, tau in test_cases:\n        # Use sorted tuples as keys for commutativity, e.g., B_IJ = B_JI\n        pair1 = tuple(sorted((I, J)))\n        pair2 = tuple(sorted((K, L)))\n        \n        if pair1 not in B_cache:\n            B_cache[pair1] = compute_B_IJ(shells[pair1[0]], shells[pair1[1]])\n        \n        if pair2 not in B_cache:\n            B_cache[pair2] = compute_B_IJ(shells[pair2[0]], shells[pair2[1]])\n            \n        B_IJ = B_cache[pair1]\n        B_KL = B_cache[pair2]\n        \n        is_screened = B_IJ * B_KL  tau\n        results.append(is_screened)\n\n    # Format output as required: [True,False,...] with no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2898970"}]}