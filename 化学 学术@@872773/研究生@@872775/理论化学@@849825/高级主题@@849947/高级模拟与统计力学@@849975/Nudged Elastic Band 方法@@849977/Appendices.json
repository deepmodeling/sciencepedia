{"hands_on_practices": [{"introduction": "在任何微动弹性带（NEB）计算中，第一步都是生成反应路径的初始猜测。一种常见的方法是对原子坐标进行线性插值。然而，这种简单的方法可能会引入不合理的几何畸变，例如拉伸的化学键。本练习将引导你量化这种畸变，并建立一个实用标准，以判断何时需要使用更复杂的内坐标插值方法[@problem_id:2818647]。这项实践对于建立物理上合理的初始路径至关重要，它可以显著提高后续NEB优化的效率和稳定性。", "problem": "在用于识别化学反应中最小能量路径的微扰弹性带 (NEB) 方法中，反应物和产物构型之间的初始路径通常通过笛卡尔坐标中的线性插值生成。考虑一个标有 $A$–$B$–$C$ 的三原子分子，其中中心原子 $B$ 固定在原点，原子 $A$ 固定在 $\\left(-r,\\,0,\\,0\\right)$，而原子 $C$ 在初始和最终构型之间，以固定的键长 $|BC|=r$ 在 $x$–$y$ 平面内移动。不失一般性，设 $C$ 的初始位置为 $\\mathbf{R}_{C}^{(0)}=\\left(r,\\,0,\\,0\\right)$，最终位置为 $\\mathbf{R}_{C}^{(1)}=\\left(r\\cos\\Delta\\theta,\\,r\\sin\\Delta\\theta,\\,0\\right)$，其中 $\\Delta\\theta$ 是 $B$ 处弯曲角的变化量。\n\n$C$ 的笛卡尔线性插值对 $t\\in[0,\\,1]$ 定义为\n$$\n\\mathbf{R}_{C}(t)\\;=\\;(1-t)\\,\\mathbf{R}_{C}^{(0)}\\;+\\;t\\,\\mathbf{R}_{C}^{(1)}.\n$$\n这种插值描绘了以 $B$ 为中心、半径为 $r$ 的圆上两个端点之间的直线弦，并且通常会扭曲瞬时键距 $|BC(t)|=|\\mathbf{R}_{C}(t)|$。相比之下，仅在固定 $|BC|=r$ 的情况下改变弯曲角的内坐标插值将使 $BC$ 键长沿路径（沿着圆弧）保持恒定。\n\n仅从向量范数和基本三角恒等式出发，推导沿笛卡尔线性插值的 $BC$ 键长的最大相对偏差作为 $\\Delta\\theta$ 的函数，并由此得出一个标准，用于判断在插值过程中对允许的最大键长相对偏差施加硬性容差 $\\varepsilon$ 的情况下，何时内坐标插值是更可取的。\n\n最后，对于容差 $\\varepsilon=0.02$（以小数形式表示），计算临界角变化 $\\Delta\\theta_{c}$，使得当 $\\Delta\\theta\\Delta\\theta_{c}$ 时，根据此标准，内坐标插值是更可取的。将 $\\Delta\\theta_{c}$ 以弧度表示，并将您的答案四舍五入到四位有效数字。", "solution": "所述问题在科学上是合理的，提法恰当，并包含了唯一解所需的所有信息。我们将着手进行推导。\n\n原子 $C$ 的初始和最终位置分别为 $\\mathbf{R}_{C}^{(0)} = (r, 0, 0)$ 和 $\\mathbf{R}_{C}^{(1)} = (r\\cos\\Delta\\theta, r\\sin\\Delta\\theta, 0)$。原子 $B$ 位于原点。因此，键向量 $\\mathbf{R}_{BC}$ 与原子 $C$ 的位置向量 $\\mathbf{R}_{C}$ 相同。端点处的键长为 $|\\mathbf{R}_{C}^{(0)}| = r$ 和 $|\\mathbf{R}_{C}^{(1)}| = r$。\n\n沿线性插值路径的原子 $C$ 的位置向量由 $\\mathbf{R}_{C}(t)$ 给出，其中 $t \\in [0, 1]$：\n$$\n\\mathbf{R}_{C}(t) = (1-t)\\mathbf{R}_{C}^{(0)} + t\\mathbf{R}_{C}^{(1)}\n$$\n代入坐标向量：\n$$\n\\mathbf{R}_{C}(t) = (1-t)(r, 0, 0) + t(r\\cos\\Delta\\theta, r\\sin\\Delta\\theta, 0)\n$$\n$$\n\\mathbf{R}_{C}(t) = ((1-t)r + tr\\cos\\Delta\\theta, tr\\sin\\Delta\\theta, 0)\n$$\n$$\n\\mathbf{R}_{C}(t) = (r(1-t+t\\cos\\Delta\\theta), tr\\sin\\Delta\\theta, 0)\n$$\n$BC$ 的瞬时键长是该向量的模，我们将其表示为 $|BC(t)|_L$，其中下标 $L$ 表示线性插值。我们计算其平方：\n$$\n|BC(t)|_L^2 = |\\mathbf{R}_{C}(t)|^2 = [r(1-t+t\\cos\\Delta\\theta)]^2 + [tr\\sin\\Delta\\theta]^2\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( (1-t+t\\cos\\Delta\\theta)^2 + t^2\\sin^2\\Delta\\theta \\right)\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( (1-t)^2 + 2t(1-t)\\cos\\Delta\\theta + t^2\\cos^2\\Delta\\theta + t^2\\sin^2\\Delta\\theta \\right)\n$$\n使用基本三角恒等式 $\\cos^2\\Delta\\theta + \\sin^2\\Delta\\theta = 1$：\n$$\n|BC(t)|_L^2 = r^2 \\left( (1-t)^2 + 2t(1-t)\\cos\\Delta\\theta + t^2 \\right)\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( 1 - 2t + t^2 + 2t\\cos\\Delta\\theta - 2t^2\\cos\\Delta\\theta + t^2 \\right)\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( 1 - 2t + 2t^2 + (2t - 2t^2)\\cos\\Delta\\theta \\right)\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( 1 - 2t(1-t) + 2t(1-t)\\cos\\Delta\\theta \\right)\n$$\n$$\n|BC(t)|_L^2 = r^2 \\left( 1 - 2t(1-t)(1-\\cos\\Delta\\theta) \\right)\n$$\n我们应用半角公式 $1-\\cos\\Delta\\theta = 2\\sin^2(\\frac{\\Delta\\theta}{2})$：\n$$\n|BC(t)|_L^2 = r^2 \\left( 1 - 4t(1-t)\\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right) \\right)\n$$\n因此，瞬时键长为：\n$$\n|BC(t)|_L = r \\sqrt{1 - 4t(1-t)\\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right)}\n$$\n键长与其标称值 $r$ 的相对偏差为：\n$$\nD(t) = \\frac{r - |BC(t)|_L}{r} = 1 - \\frac{|BC(t)|_L}{r} = 1 - \\sqrt{1 - 4t(1-t)\\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right)}\n$$\n为求最大相对偏差 $D_{max}$，我们必须求出 $D(t)$ 在 $t \\in [0, 1]$ 上的最大值。这等价于求 $|BC(t)|_L$ 的最小值，而这又等价于最大化平方根下被减去的正项 $4t(1-t)\\sin^2(\\frac{\\Delta\\theta}{2})$。由于对于给定路径 $\\Delta\\theta$ 是常数，我们只需最大化函数 $f(t) = t(1-t) = t - t^2$ 在区间 $t \\in [0, 1]$ 上的值。\n$f(t)$ 的最大值可以通过将其导数设为零来找到：\n$$\n\\frac{df}{dt} = 1 - 2t = 0 \\implies t = \\frac{1}{2}\n$$\n该点代表一个最大值，因为二阶导数 $\\frac{d^2f}{dt^2} = -2  0$。最大值为 $f(\\frac{1}{2}) = \\frac{1}{2}(1-\\frac{1}{2}) = \\frac{1}{4}$。这发生在弦的中点。\n\n最小键长 $|BC|_{min}$ 出现在 $t=\\frac{1}{2}$ 处：\n$$\n|BC|_{min}^2 = r^2 \\left( 1 - 4\\left(\\frac{1}{4}\\right)\\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right) \\right) = r^2 \\left( 1 - \\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right) \\right) = r^2 \\cos^2\\left(\\frac{\\Delta\\theta}{2}\\right)\n$$\n假设 $\\Delta\\theta \\in [0, \\pi]$，则 $\\cos(\\frac{\\Delta\\theta}{2}) \\ge 0$，所以 $|BC|_{min} = r\\cos(\\frac{\\Delta\\theta}{2})$。\n\n那么，最大相对偏差 $D_{max}$ 为：\n$$\nD_{max} = 1 - \\frac{|BC|_{min}}{r} = 1 - \\frac{r\\cos(\\frac{\\Delta\\theta}{2})}{r} = 1 - \\cos\\left(\\frac{\\Delta\\theta}{2}\\right)\n$$\n这就是所求的最大相对偏差作为 $\\Delta\\theta$ 函数的表达式。\n\n偏好内坐标插值的标准是该最大偏差超过给定的容差 $\\varepsilon$。内坐标插值能完美地保持键长，因此其偏差为 $0$。因此，当以下条件成立时，笛卡尔插值是不可接受的：\n$$\nD_{max}  \\varepsilon\n$$\n$$\n1 - \\cos\\left(\\frac{\\Delta\\theta}{2}\\right)  \\varepsilon\n$$\n这就是该标准。\n\n最后，我们计算临界角变化 $\\Delta\\theta_c$，此时最大偏差等于容差 $\\varepsilon=0.02$。\n$$\n1 - \\cos\\left(\\frac{\\Delta\\theta_c}{2}\\right) = \\varepsilon\n$$\n$$\n\\cos\\left(\\frac{\\Delta\\theta_c}{2}\\right) = 1 - \\varepsilon\n$$\n$$\n\\frac{\\Delta\\theta_c}{2} = \\arccos(1 - \\varepsilon)\n$$\n$$\n\\Delta\\theta_c = 2 \\arccos(1 - \\varepsilon)\n$$\n代入指定的容差 $\\varepsilon = 0.02$：\n$$\n\\Delta\\theta_c = 2 \\arccos(1 - 0.02) = 2 \\arccos(0.98)\n$$\n在弧度模式下使用计算器：\n$$\n\\arccos(0.98) \\approx 0.20033400 \\, \\text{rad}\n$$\n$$\n\\Delta\\theta_c \\approx 2 \\times 0.20033400 = 0.40066800 \\, \\text{rad}\n$$\n四舍五入到四位有效数字，临界角为 $0.4007$ 弧度。对于任何角度变化 $\\Delta\\theta  \\Delta\\theta_c$，简单线性路径的键长扭曲将超过 $2\\%$ 的容差，这使得基于内坐标的路径更为可取。", "answer": "$$\\boxed{0.4007}$$", "id": "2818647"}, {"introduction": "许多NEB的应用，特别是在材料科学和表面化学领域，都是在具有周期性边界条件（PBC）的体系中进行的。当路径穿过晶胞边界时，对距离和切线的朴素计算将会失败。本练习侧重于正确处理PBC的基本技术：计算最小镜像位移和“展开”路径以创建连续的表示[@problem_id:2818619]。掌握这项技能是在周期性体系中正确实施或解释NEB计算的先决条件。", "problem": "在微动弹性带（NEB）方法中，一条路径被离散化为一系列处于具有周期性边界条件的构型空间中的映象点。考虑一个正交周期性模拟晶胞，其在空间维度 $\\alpha \\in \\{1,\\dots,d\\}$ 上的边长为 $L_\\alpha$。坐标为 $x_i$ 和 $x_j$ 的两个映象点，在经过晶胞长度的整数倍平移后是等效的，这反映了周期性边界条件的平移不变性。沿着每个笛卡尔分量，物理上有意义的映象点到位移是使距离最小化的平移。这可以通过为每个分量 $\\alpha$ 选择一个位于区间 $\\left[-\\frac{L_\\alpha}{2}, \\frac{L_\\alpha}{2}\\right)$ 内的位移来表示。当朴素分量差恰好等于 $\\frac{L_\\alpha}{2}$ 时，选择值 $-\\frac{L_\\alpha}{2}$ 以确保一个右连续的代表和一个一致的展开。通过从第一个映象点作为参考点开始，累加求和这些最小映象位移，可以获得一条连续的展开路径。在内部映象点索引 $i$ 处的路径切线被定义为展开路径上其两个最近邻之间的弦方向上的单位向量，即与 $x^{\\mathrm{unwrapped}}_{i+1} - x^{\\mathrm{unwrapped}}_{i-1}$ 成比例的归一化向量。如果该弦的范数为零，则将切线定义为适当维度的零向量。\n\n从周期性边界条件和最小映象位移概念的这些基本定义出发，实现一个程序，该程序：\n1) 计算路径上每对连续映象点之间的最小映象位移向量。\n2) 通过从第一个映象点开始累加这些位移，生成展开坐标。\n3) 计算展开路径上每个内部映象点的中心差分弦切线，当弦范数非零时将其归一化为单位长度，否则为零向量。\n\n所有距离均以埃（ångström）表示，所有报告的浮点结果必须四舍五入到 $6$ 位小数。不涉及角度；无需报告三角函数角度。\n\n使用以下测试套件。每个测试指定维度 $d$、晶胞边长 $L_\\alpha$ 以及映象点坐标的有序列表：\n- 测试 A（在一个维度上存在周期性穿越的理想路径）：$d = 1$， $L = [\\,10.0\\,]$，位置 $[\\,8.0,\\, 9.0,\\, 0.5,\\, 1.5\\,]$。\n- 测试 B（具有周期性穿越的二维路径）：$d = 2$， $L = [\\,10.0,\\, 10.0\\,]$，位置 $[\\, (9.0,\\, 1.0),\\, (0.5,\\, 1.5),\\, (1.5,\\, 2.0),\\, (2.2,\\, 2.3) \\,]$。\n- 测试 C（处理精确半盒差和多次穿越的三维路径）：$d = 3$， $L = [\\,10.0,\\, 8.0,\\, 6.0\\,]$，位置 $[\\, (1.0,\\, 7.0,\\, 5.5),\\, (6.0,\\, 0.5,\\, 2.5),\\, (1.2,\\, 7.5,\\, 5.5),\\, (6.2,\\, 0.5,\\, 2.5) \\,]$。\n\n对于每个测试，您的程序必须输出一对列表：\n- 第一个列表是连续映象点之间的最小映象位移序列，按分量展开（如果有 $N$ 个映象点，长度为 $(N-1)\\times d$）。\n- 第二个列表是展开路径上内部映象点的切向量序列，按分量展开（长度为 $(N-2)\\times d$）。\n\n您的程序应生成单行输出，其中包含所有测试的结果，格式为由方括号括起来的、按测试分的配对的逗号分隔列表。例如，整体形状必须为 $[\\,[\\,[\\dots],\\,[\\dots]\\,],\\,[\\,[\\dots],\\,[\\dots]\\,],\\,[\\,[\\dots],\\,[\\dots]\\,]\\,]$，其中每个数值条目均四舍五入到 $6$ 位小数，并解释为以埃为单位的距离。", "solution": "该问题要求实现用于处理在周期性边界条件下离散化反应路径的基本算法，这在微动弹性带（NEB）方法中很常见。任务是计算最小映象位移，生成展开的连续路径，并计算路径切线。该问题的有效性已得到确认，因为其前提在科学上是合理的、适定的，并且可直接应用于计算化学。我们从第一性原理出发进行求解。\n\n设构型空间为一个 $d$ 维正交晶胞，具有周期性边界条件，由边长向量 $L = (L_1, L_2, \\dots, L_d)$ 定义。一条路径由 $N$ 个映象点的有序序列给出，其坐标为 $\\{x_i\\}_{i=0}^{N-1}$，其中每个 $x_i \\in \\mathbb{R}^d$。\n\n**1. 最小映象位移**\n\n在周期性系统中，由于平移不变性，两点 $x_i$ 和 $x_j$ 之间的位移不是唯一的。物理上有意义的位移是对应于最短可能路径的位移，这一原则被称为最小映象约定（MIC）。对于一个朴素位移向量 $\\Delta x = x_j - x_i$，最小映象位移向量 $d_{\\text{min}}(x_j, x_i)$ 的求法是：考虑 $x_j$ 的所有周期性映象（位于 $x_j + n \\circ L$，其中 $n \\in \\mathbb{Z}^d$ 是任意整数向量，$\\circ$ 表示逐元素乘积），并找到离 $x_i$ 最近的那个。\n\n对于每个空间分量 $\\alpha \\in \\{1, \\dots, d\\}$，最小位移的分量 $d_\\alpha$ 必须满足 $d_\\alpha \\equiv \\Delta x_\\alpha \\pmod{L_\\alpha}$ 并且必须位于以零为中心的基准区间内。问题指定该区间为 $\\left[-\\frac{L_\\alpha}{2}, \\frac{L_\\alpha}{2}\\right)$。选择这样一个右连续的区间解决了边界上的模糊性。具体来说，一个恰好为 $\\frac{L_\\alpha}{2}$ 的朴素差值会被映射到 $-\\frac{L_\\alpha}{2}$。实现此约定的一个稳健数学公式是：\n$$\nd_\\alpha(\\Delta x_\\alpha, L_\\alpha) = \\Delta x_\\alpha - L_\\alpha \\cdot \\left\\lfloor \\frac{\\Delta x_\\alpha}{L_\\alpha} + \\frac{1}{2} \\right\\rfloor\n$$\n其中 $\\lfloor \\cdot \\rfloor$ 是向下取整函数。此操作被逐分量地应用于朴素位移向量 $\\Delta x$，以获得完整的最小映象位移向量。对于给定的问题，我们必须为每对连续的映象点 $(x_{i}, x_{i+1})$ 计算这个值，从而得到一个包含 $N-1$ 个位移向量的序列 $\\{v_i\\}_{i=0}^{N-2}$，其中 $v_i = d_{\\text{min}}(x_{i+1}, x_i)$。\n\n**2. 路径展开**\n\n由坐标 $\\{x_i\\}$ 表示的、限制在主模拟晶胞（例如，每个分量在 $[0, L_\\alpha)$ 内）内的离散化路径，在粒子穿过周期性边界时是不连续的。为了对路径进行微积分运算（例如计算切线），有必要构建一条连续的“展开”路径。这可以通过将第一个映象点 $x_0$ 作为参考，并累加求和最小映象位移来实现。展开路径 $\\{x^{\\mathrm{unw}}_i\\}_{i=0}^{N-1}$ 定义如下：\n$$\nx^{\\mathrm{unw}}_0 = x_0\n$$\n$$\nx^{\\mathrm{unw}}_{i+1} = x^{\\mathrm{unw}}_i + v_i = x^{\\mathrm{unw}}_i + d_{\\text{min}}(x_{i+1}, x_i) \\quad \\text{for } i = 0, \\dots, N-2\n$$\n这等价于以下求和：\n$$\nx^{\\mathrm{unw}}_i = x_0 + \\sum_{k=0}^{i-1} v_k\n$$\n得到的坐标 $\\{x^{\\mathrm{unw}}_i\\}$ 代表了在一个无限、非周期性空间中的一个连续的点链。\n\n**3. 路径切线计算**\n\n在内部映象点 $i$（其中 $0  i  N-1$）处的切向量提供了路径局部方向的估计。一个常用且稳定的估计量是展开路径上相邻映象点之间的中心差分弦。弦向量 $\\tau_i$ 由下式给出：\n$$\n\\tau_i = x^{\\mathrm{unw}}_{i+1} - x^{\\mathrm{unw}}_{i-1}\n$$\n切向量 $\\hat{\\tau}_i$ 被定义为归一化的弦向量，前提是弦的范数非零。范数是标准的欧几里得范数，即 $||\\tau_i|| = \\sqrt{\\tau_i \\cdot \\tau_i}$。\n$$\n\\hat{\\tau}_i =\n\\begin{cases}\n\\frac{\\tau_i}{||\\tau_i||}   \\text{如果 } ||\\tau_i|| \\neq 0 \\\\\n\\mathbf{0}   \\text{如果 } ||\\tau_i|| = 0\n\\end{cases}\n$$\n其中 $\\mathbf{0}$ 是 $\\mathbb{R}^d$ 中的零向量。此定义适用于从 $i=1$ 到 $N-2$ 的所有内部映象点。\n\n所提供的算法按顺序实现这三个步骤。首先，它计算最小映象位移的 $(N-1) \\times d$ 个分量。其次，它生成展开路径的坐标。最后，它计算所有内部映象点处归一化切向量的 $(N-2) \\times d$ 个分量。所有数值结果均按要求四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the NEB path analysis problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test A: 1D path with periodic crossing\n        {\n            \"d\": 1,\n            \"L\": [10.0],\n            \"positions\": np.array([8.0, 9.0, 0.5, 1.5]).reshape(-1, 1)\n        },\n        # Test B: 2D path with periodic crossing\n        {\n            \"d\": 2,\n            \"L\": [10.0, 10.0],\n            \"positions\": np.array([\n                (9.0, 1.0), (0.5, 1.5), (1.5, 2.0), (2.2, 2.3)\n            ])\n        },\n        # Test C: 3D path with half-box differences and multiple crossings\n        {\n            \"d\": 3,\n            \"L\": [10.0, 8.0, 6.0],\n            \"positions\": np.array([\n                (1.0, 7.0, 5.5), (6.0, 0.5, 2.5), (1.2, 7.5, 5.5), (6.2, 0.5, 2.5)\n            ])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        res = process_case(case[\"d\"], np.array(case[\"L\"]), case[\"positions\"])\n        all_results.append(res)\n    \n    # Format the final output string\n    formatted_pairs = []\n    for pair in all_results:\n        disp_str = \"[\" + \",\".join([f\"{x:.6f}\" for x in pair[0]]) + \"]\"\n        tang_str = \"[\" + \",\".join([f\"{x:.6f}\" for x in pair[1]]) + \"]\"\n        formatted_pairs.append(f\"[{disp_str},{tang_str}]\")\n    \n    final_output = \"[\" + \",\".join(formatted_pairs) + \"]\"\n    print(final_output)\n\ndef process_case(d, L, positions):\n    \"\"\"\n    Computes displacements and tangents for a single test case.\n\n    Args:\n        d (int): Number of dimensions.\n        L (np.ndarray): Array of box lengths for each dimension.\n        positions (np.ndarray): Array of image coordinates, shape (N, d).\n\n    Returns:\n        tuple[list[float], list[float]]: A pair of flattened lists containing\n        minimum-image displacements and tangent vectors.\n    \"\"\"\n    num_images = positions.shape[0]\n\n    # 1. Compute minimum-image displacements\n    naive_displacements = positions[1:] - positions[:-1]\n    \n    # Apply minimum image convention: d = dx - L * floor(dx/L + 0.5)\n    # This correctly handles the half-box case as specified.\n    min_displacements = naive_displacements - L * np.floor(naive_displacements / L + 0.5)\n    \n    # 2. Compute unwrapped coordinates\n    unwrapped_coords = np.zeros_like(positions)\n    unwrapped_coords[0] = positions[0]\n    unwrapped_coords[1:] = positions[0] + np.cumsum(min_displacements, axis=0)\n    \n    # 3. Compute tangent vectors at internal images\n    if num_images > 2:\n        # Central difference chords: x_{i+1} - x_{i-1}\n        chords = unwrapped_coords[2:] - unwrapped_coords[:-2]\n        \n        # Norms of the chord vectors\n        norms = np.linalg.norm(chords, axis=1)\n        \n        # Handle zero-norm case to avoid division by zero\n        tangents = np.zeros_like(chords)\n        non_zero_mask = norms > 1e-9 # Use a small tolerance for floating point safety\n        \n        # Normalize non-zero chords\n        tangents[non_zero_mask] = chords[non_zero_mask] / norms[non_zero_mask, np.newaxis]\n    else:\n        tangents = np.array([])\n        \n    # Flatten results for output\n    flat_displacements = min_displacements.flatten().tolist()\n    flat_tangents = tangents.flatten().tolist()\n    \n    return flat_displacements, flat_tangents\n\nsolve()\n```", "id": "2818619"}, {"introduction": "在建立了一条有效的初始路径之后，NEB方法的核心是迭代优化各个映像点（image）的位置。这种优化是由一个独特的力组合驱动的，这些力源自势能面和映像点之间的人工弹簧力。本练习让你深入NEB算法的核心，要求你推导并实现力的各个分量，并执行单个优化步骤[@problem_id:2818674]。通过这样做，你将具体理解“微动”（nudged）和“弹性带”（elastic band）这两个部分是如何协同工作，引导路径向最小能量路径演化的。", "problem": "在一个标量势能面上，连接两个局域极小值的离散路径由 $\\mathbb{R}^d$ 空间中 $M+1$ 个构型矢量的有限序列 $\\{\\mathbf{R}_i\\}_{i=0}^{M}$ 表示，其中 $\\mathbf{R}_0$ 和 $\\mathbf{R}_M$ 是固定端点。考虑使用弹性微扰带（Nudged Elastic Band, NEB）方法来近似计算最小能量路径。NEB 框架将相邻的像（image）视为由谐振子弹簧连接，并通过一个组合力来推动内部的像：该组合力由约束在局域切线方向上的弹簧力和移除了切向分量的势能力构成。本问题中所有量均为无量纲。所有角度（若适用）均以弧度为单位。\n\n从以下基本陈述出发：\n- 势能是一个标量场 $V(\\mathbf{R})$，由该势产生的物理力为 $-\\nabla V(\\mathbf{R})$。\n- 相邻像之间的弹簧相互作用是谐性的，具有恒定的弹簧系数 $k0$。\n- 某个内部像的局域路径切线是其位置的离散中心差分的方向。\n- NEB 方案仅组合了平行于局域切线的弹簧力分量和垂直于该切线的势能力分量。\n\n基于这些基本陈述，推导出以下各项的显式表达式：\n- 每个内部像 $i\\in\\{1,\\dots,M-1\\}$ 处的单位切向量 $\\hat{\\boldsymbol{\\tau}}_i$，仅使用 $\\mathbf{R}_{i-1},\\mathbf{R}_{i},\\mathbf{R}_{i+1}$ 表示。\n- 作用于每个内部像 $i$ 且限制在切线方向上的弹簧力。\n- 作用于每个内部像 $i$ 且限制在垂直于切线的子空间内的势能力。\n\n然后，设计一个算法，在给定初始路径的情况下，对内部像执行一步显式最速下降：\n$$\n\\mathbf{R}_i \\leftarrow \\mathbf{R}_i + \\alpha\\, \\mathbf{F}_i,\n$$\n其中 $\\alpha0$ 是步长，$\\mathbf{F}_i$ 是根据上述原理构成的 NEB 力。端点 $i=0$ 和 $i=M$ 不进行更新。令像间距离为 $d_i=\\left\\|\\mathbf{R}_{i+1}-\\mathbf{R}_i\\right\\|$（对于 $i\\in\\{0,\\dots,M-1\\}$）。对于每一步，通过变异系数 $c_v = \\sigma_d/\\mu_d$ 来量化间距的均匀性，其中 $\\sigma_d$ 和 $\\mu_d$ 分别是 $\\{d_i\\}_{i=0}^{M-1}$ 的标准差和均值。令 $r$ 为比率 $r=c_v^{\\text{after}}/c_v^{\\text{before}}$。此外，计算 $\\bar{s}$，即所有内部像上切向弹簧力的平均大小。\n\n实现一个程序，对于下面指定的每个测试用例，计算一步 NEB 更新，并以浮点数形式返回数对 $[r,\\bar{s}]$，四舍五入到六位小数。\n\n使用以下测试套件（所有量均为无量纲）：\n\n- 测试用例 A（理想路径；对称双势阱上不均匀的初始间距）：\n  - 势 $V_1(x,y) = (x^2-1)^2 + 0.1\\,y^2$。\n  - 梯度 $\\nabla V_1(x,y)$ 必须由您自己推导。\n  - 维度 $d=2$。\n  - 像的数量为 $M+1=7$，端点固定在 $\\mathbf{R}_0 = (-1,0)$ 和 $\\mathbf{R}_6=(1,0)$。\n  - 初始内部像：$\\mathbf{R}_1 = (-0.9,0)$, $\\mathbf{R}_2 = (-0.7,0)$, $\\mathbf{R}_3 = (-0.2,0)$, $\\mathbf{R}_4 = (0.3,0)$, $\\mathbf{R}_5 = (0.8,0)$。\n  - 弹簧系数 $k=1.0$。\n  - 步长 $\\alpha=0.05$。\n\n- 测试用例 B（边界条件；在相同的势上已是等間距）：\n  - 势 $V_1(x,y)$ 同上。\n  - 维度 $d=2$。\n  - 像的数量为 $M+1=7$，端点固定在 $\\mathbf{R}_0 = (-1,0)$ 和 $\\mathbf{R}_6=(1,0)$。\n  - 初始内部像沿直线段等距分布：$\\mathbf{R}_i = (-1 + i\\cdot \\Delta,0)$，对于 $i\\in\\{1,\\dots,5\\}$，其中 $\\Delta = \\frac{2}{6}$。\n  - 弹簧系数 $k=1.0$。\n  - 步长 $\\alpha=0.05$。\n\n- 测试用例 C（弯曲的谷底；不均匀的间距和非平凡的垂直力）：\n  - 势 $V_2(x,y) = \\big(y-\\sin(\\pi x)\\big)^2 + 0.01\\,x^2$。请使用弧度制角度。\n  - 梯度 $\\nabla V_2(x,y)$ 必须由您自己推导。\n  - 维度 $d=2$。\n  - 像的数量为 $M+1=7$，端点固定在 $\\mathbf{R}_0 = (-1,0)$ 和 $\\mathbf{R}_6=(1,0)$。\n  - 初始内部像：$\\mathbf{R}_1 = (-0.9,0)$, $\\mathbf{R}_2 = (-0.6,0)$, $\\mathbf{R}_3 = (-0.1,0)$, $\\mathbf{R}_4 = (0.4,0)$, $\\mathbf{R}_5 = (0.9,0)$。\n  - 弹簧系数 $k=1.0$。\n  - 步长 $\\alpha=0.05$。\n\n您的程序应为每个测试用例计算如上定义的数对 $[r,\\bar{s}]$。如果 $c_v^{\\text{before}}=0$，则按约定定义 $r=1$。您的程序应产生单行输出，其中包含这些数对的结果，以逗号分隔的列表形式呈现，并用方括号括起来，例如：$[\\,[r_A,\\bar{s}_A],[r_B,\\bar{s}_B],[r_C,\\bar{s}_C]\\,]$，每个浮点数四舍五入到六位小数。不应产生任何其他输出。", "solution": "问题陈述是有效的。它提出了一个在计算化学领域中关于弹性微扰带（NEB）方法的、适定且有科学依据的问题。给定的定义和约束对于推导必要的公式和实现算法是充分且一致的。\n\n该任务要求基于问题中提供的第一性原理推导 NEB 方法中使用的力，然后设计并实现一个算法来执行单个优化步骤。该问题是理解和应用 NEB 方法的一个标准练习。\n\n推导过程如下。系统由一条通过 $M+1$ 个像离散化的路径组成，这些像由 $d$ 维空间 $\\mathbb{R}^d$ 中的位置矢量 $\\{\\mathbf{R}_i\\}_{i=0}^{M}$ 表示。端点 $\\mathbf{R}_0$ 和 $\\mathbf{R}_M$ 是固定的。内部的像 $i \\in \\{1, \\dots, M-1\\}$ 将被更新。\n\n首先，我们推导内部像 $i$ 处的单位切向量的表达式。问题陈述其为“位置的离散中心差分的方向”。这是连接相邻像 $\\mathbf{R}_{i-1}$ 和 $\\mathbf{R}_{i+1}$ 的矢量。\n因此，切向量 $\\boldsymbol{\\tau}_i$ 为：\n$$\n\\boldsymbol{\\tau}_i = \\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}\n$$\n相应的单位切向量 $\\hat{\\boldsymbol{\\tau}}_i$ 通过将此矢量归一化得到：\n$$\n\\hat{\\boldsymbol{\\tau}}_i = \\frac{\\boldsymbol{\\tau}_i}{\\|\\boldsymbol{\\tau}_i\\|} = \\frac{\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}}{\\|\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}\\|}\n$$\n这个定义在 $\\mathbf{R}_{i+1} \\neq \\mathbf{R}_{i-1}$ 的条件下是有效的，否则范数将为零。对于给定的测试用例，此条件成立。\n\n其次，我们推导弹簧力。问题陈述“相邻的像被具有恒定弹簧系数 $k0$ 的谐振子弹簧连接”。弹性带的总弹性势能 $S$ 是每个分段的谐性势能之和：\n$$\nS(\\{\\mathbf{R}_i\\}) = \\sum_{j=0}^{M-1} \\frac{1}{2} k \\left\\| \\mathbf{R}_{j+1} - \\mathbf{R}_j \\right\\|^2\n$$\n作用在特定像 $i$ 上的力是该总势能相对于其位置 $\\mathbf{R}_i$ 的负梯度。总和中只有两项依赖于 $\\mathbf{R}_i$：即 $j=i-1$ 和 $j=i$ 的项。\n$$\n\\mathbf{F}_{i, \\text{spring}}^{\\text{total}} = - \\nabla_{\\mathbf{R}_i} S = - \\frac{\\partial}{\\partial \\mathbf{R}_i} \\left[ \\frac{1}{2} k \\left\\| \\mathbf{R}_i - \\mathbf{R}_{i-1} \\right\\|^2 + \\frac{1}{2} k \\left\\| \\mathbf{R}_{i+1} - \\mathbf{R}_i \\right\\|^2 \\right]\n$$\n$$\n\\mathbf{F}_{i, \\text{spring}}^{\\text{total}} = - \\left[ k (\\mathbf{R}_i - \\mathbf{R}_{i-1}) + k (\\mathbf{R}_i - \\mathbf{R}_{i+1}) \\right] = k(\\mathbf{R}_{i-1} - \\mathbf{R}_i) + k(\\mathbf{R}_{i+1} - \\mathbf{R}_i) = k \\left( \\mathbf{R}_{i-1} + \\mathbf{R}_{i+1} - 2\\mathbf{R}_i \\right)\n$$\n问题指明对于 NEB 力，我们必须使用“仅平行于局域切线的弹簧力分量”。这是 $\\mathbf{F}_{i, \\text{spring}}^{\\text{total}}$ 在单位切向量 $\\hat{\\boldsymbol{\\tau}}_i$ 上的投影。\n$$\n\\mathbf{F}_{i, s}^{\\parallel} = \\left( \\mathbf{F}_{i, \\text{spring}}^{\\text{total}} \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i = \\left[ k \\left( \\mathbf{R}_{i-1} + \\mathbf{R}_{i+1} - 2\\mathbf{R}_i \\right) \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right] \\hat{\\boldsymbol{\\tau}}_i\n$$\n这就是所要求的切向弹簧力的表达式。\n\n第三，我们推导垂直于切线的势能力分量。来自势能面 $V(\\mathbf{R})$ 作用于像 $i$ 的力是 $\\mathbf{F}_{i, \\text{pot}} = -\\nabla V(\\mathbf{R}_i)$。问题陈述我们使用“仅垂直于该切线的势能力分量”。$\\mathbf{F}_{i, \\text{pot}}$ 垂直于 $\\hat{\\boldsymbol{\\tau}}_i$ 的分量可以通过减去其平行分量得到：\n$$\n\\mathbf{F}_{i, \\text{pot}}^{\\perp} = \\mathbf{F}_{i, \\text{pot}} - \\left( \\mathbf{F}_{i, \\text{pot}} \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i\n$$\n代入 $\\mathbf{F}_{i, \\text{pot}} = -\\nabla V(\\mathbf{R}_i)$：\n$$\n\\mathbf{F}_{i, \\text{pot}}^{\\perp} = -\\nabla V(\\mathbf{R}_i) - \\left( (-\\nabla V(\\mathbf{R}_i)) \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i = -\\nabla V(\\mathbf{R}_i) + \\left( \\nabla V(\\mathbf{R}_i) \\cdot \\hat{\\boldsymbol{\\tau}}_i \\right) \\hat{\\boldsymbol{\\tau}}_i\n$$\n这个力分量将路径推向最小能量路径，而不会导致像沿着路径滑动。\n\n作用于内部像 $i$ 的总 NEB 力 $\\mathbf{F}_i$ 是这两个分量的和：\n$$\n\\mathbf{F}_i = \\mathbf{F}_{i, s}^{\\parallel} + \\mathbf{F}_{i, \\text{pot}}^{\\perp}\n$$\n\n必须计算指定势 $V_1(x,y) = (x^2-1)^2 + 0.1 y^2$ 和 $V_2(x,y) = (y-\\sin(\\pi x))^2 + 0.01 x^2$ 的梯度。对于 $\\mathbf{R}=(x,y)$:\n- 对于 $V_1$: $\\nabla V_1(x,y) = \\left( \\frac{\\partial V_1}{\\partial x}, \\frac{\\partial V_1}{\\partial y} \\right) = (4x(x^2-1), 0.2y)$。\n- 对于 $V_2$: $\\nabla V_2(x,y) = \\left( \\frac{\\partial V_2}{\\partial x}, \\frac{\\partial V_2}{\\partial y} \\right) = (0.02x - 2\\pi(y-\\sin(\\pi x))\\cos(\\pi x), 2(y-\\sin(\\pi x)))$。\n\n单个更新步骤的算法如下：\n1.  给定初始路径 $\\{\\mathbf{R}_i\\}_{i=0}^{M}$、参数 $k$ 和步长 $\\alpha$。\n2.  计算初始像间距离集合 $\\{d_i\\}_{i=0}^{M-1}$，其中 $d_i = \\|\\mathbf{R}_{i+1} - \\mathbf{R}_i\\|$。计算它们的均值 $\\mu_d^{\\text{before}}$ 和标准差 $\\sigma_d^{\\text{before}}$。计算 $c_v^{\\text{before}} = \\sigma_d^{\\text{before}} / \\mu_d^{\\text{before}}$，通过设置 $c_v^{\\text{before}}=0$ 来处理 $\\mu_d^{\\text{before}}=0$ 的情况。\n3.  初始化一个新的路径数组 $\\{\\mathbf{R}'_i\\}$ 并复制固定端点：$\\mathbf{R}'_0 = \\mathbf{R}_0$ 和 $\\mathbf{R}'_M = \\mathbf{R}_M$。初始化一个列表以存储弹簧力的大小。\n4.  对从 $1$ 到 $M-1$ 的每个内部像 $i$：\n    a. 使用原始路径位置 $\\mathbf{R}_{i-1}$ 和 $\\mathbf{R}_{i+1}$ 计算单位切向量 $\\hat{\\boldsymbol{\\tau}}_i$。\n    b. 计算切向弹簧力 $\\mathbf{F}_{i, s}^{\\parallel}$ 并存储其大小 $\\|\\mathbf{F}_{i, s}^{\\parallel}\\| = |\\mathbf{F}_{i, \\text{spring}}^{\\text{total}} \\cdot \\hat{\\boldsymbol{\\tau}}_i|$。\n    c. 计算势梯度 $\\nabla V(\\mathbf{R}_i)$ 和垂直势能力 $\\mathbf{F}_{i, \\text{pot}}^{\\perp}$。\n    d. 将力相加得到总 NEB 力 $\\mathbf{F}_i = \\mathbf{F}_{i, s}^{\\parallel} + \\mathbf{F}_{i, \\text{pot}}^{\\perp}$。\n    e. 计算更新后的位置：$\\mathbf{R}'_i = \\mathbf{R}_i + \\alpha \\mathbf{F}_i$。\n5.  更新所有内部像后，从新路径 $\\{\\mathbf{R}'_i\\}$ 计算新的距离集合 $\\{d'_i\\}_{i=0}^{M-1}$。计算它们的均值 $\\mu_d^{\\text{after}}$ 和标准差 $\\sigma_d^{\\text{after}}$，并求出 $c_v^{\\text{after}} = \\sigma_d^{\\text{after}} / \\mu_d^{\\text{after}}$。\n6.  计算比率 $r = c_v^{\\text{after}} / c_v^{\\text{before}}$。如果 $c_v^{\\text{before}}=0$，则根据问题规范设置 $r=1$。\n7.  通过平均步骤 4b 中存储的值，计算切向弹簧力的平均大小 $\\bar{s}$。\n8.  返回数对 $[r, \\bar{s}]$。\n\n对每个提供的测试用例实施此程序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases for the NEB problem.\n    \"\"\"\n\n    def grad_V1(R):\n        \"\"\"Gradient of V1(x,y) = (x^2-1)^2 + 0.1*y^2\"\"\"\n        x, y = R\n        dx = 4 * x * (x**2 - 1)\n        dy = 0.2 * y\n        return np.array([dx, dy])\n\n    def grad_V2(R):\n        \"\"\"Gradient of V2(x,y) = (y-sin(pi*x))^2 + 0.01*x^2\"\"\"\n        x, y = R\n        sin_pix = np.sin(np.pi * x)\n        cos_pix = np.cos(np.pi * x)\n        term1 = y - sin_pix\n        dx = 0.02 * x - 2 * np.pi * term1 * cos_pix\n        dy = 2 * term1\n        return np.array([dx, dy])\n\n    def get_cv(path):\n        \"\"\"Calculate the coefficient of variation of inter-image distances.\"\"\"\n        distances = [np.linalg.norm(path[i+1] - path[i]) for i in range(len(path) - 1)]\n        mean_dist = np.mean(distances)\n        if mean_dist == 0:\n            return 0.0\n        std_dist = np.std(distances)\n        return std_dist / mean_dist\n\n    def process_case(initial_path_internal, R0, RM, grad_V, k, alpha):\n        \"\"\"\n        Processes one test case of the NEB calculation.\n        Performs one update step and computes the required metrics [r, s_bar].\n        \"\"\"\n        # Construct full initial path\n        path = [R0] + initial_path_internal + [RM]\n        path = [np.array(p) for p in path]\n        M = len(path) - 1\n        num_internal_images = M - 1\n\n        # --- Before the update step ---\n        cv_before = get_cv(path)\n\n        # --- Perform one NEB update step ---\n        new_path = [p.copy() for p in path]\n        tangential_spring_force_mags = []\n\n        for i in range(1, M):\n            # Current, previous, and next image positions\n            R_i = path[i]\n            R_prev = path[i-1]\n            R_next = path[i+1]\n\n            # 1. Calculate tangent\n            tau_vec = R_next - R_prev\n            norm_tau = np.linalg.norm(tau_vec)\n            if norm_tau == 0:\n                tau_hat = np.zeros_like(tau_vec)\n            else:\n                tau_hat = tau_vec / norm_tau\n\n            # 2. Calculate tangential spring force F_s_parallel\n            F_spring_total = k * (R_prev + R_next - 2 * R_i)\n            F_s_parallel_scalar = np.dot(F_spring_total, tau_hat)\n            F_s_parallel = F_s_parallel_scalar * tau_hat\n            tangential_spring_force_mags.append(np.abs(F_s_parallel_scalar))\n\n            # 3. Calculate perpendicular potential force F_pot_perp\n            grad_Vi = grad_V(R_i)\n            F_pot_total = -grad_Vi\n            F_pot_perp = F_pot_total - np.dot(F_pot_total, tau_hat) * tau_hat\n\n            # 4. Total NEB force and update position\n            F_i = F_s_parallel + F_pot_perp\n            new_path[i] = R_i + alpha * F_i\n        \n        # --- After the update step ---\n        cv_after = get_cv(new_path)\n\n        # --- Calculate final metrics ---\n        if cv_before == 0.0:\n            r = 1.0\n        else:\n            r = cv_after / cv_before\n\n        s_bar = np.mean(tangential_spring_force_mags) if tangential_spring_force_mags else 0.0\n\n        return [round(r, 6), round(s_bar, 6)]\n\n    # Test Case A\n    R0_A = [-1.0, 0.0]\n    RM_A = [1.0, 0.0]\n    path_internal_A = [\n        [-0.9, 0.0], [-0.7, 0.0], [-0.2, 0.0], [0.3, 0.0], [0.8, 0.0]\n    ]\n    k_A = 1.0\n    alpha_A = 0.05\n    \n    # Test Case B\n    R0_B = [-1.0, 0.0]\n    RM_B = [1.0, 0.0]\n    delta_B = 2.0 / 6.0\n    path_internal_B = [\n        [-1 + i * delta_B, 0.0] for i in range(1, 6)\n    ]\n    k_B = 1.0\n    alpha_B = 0.05\n    \n    # Test Case C\n    R0_C = [-1.0, 0.0]\n    RM_C = [1.0, 0.0]\n    path_internal_C = [\n        [-0.9, 0.0], [-0.6, 0.0], [-0.1, 0.0], [0.4, 0.0], [0.9, 0.0]\n    ]\n    k_C = 1.0\n    alpha_C = 0.05\n\n    test_cases = [\n        (path_internal_A, R0_A, RM_A, grad_V1, k_A, alpha_A),\n        (path_internal_B, R0_B, RM_B, grad_V1, k_B, alpha_B),\n        (path_internal_C, R0_C, RM_C, grad_V2, k_C, alpha_C)\n    ]\n\n    results = []\n    for params in test_cases:\n        result = process_case(*params)\n        results.append(result)\n\n    # Format the final output string\n    result_str = \",\".join([f\"[{r},{s}]\" for r, s in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "2818674"}]}