{"hands_on_practices": [{"introduction": "在通过时间演化爱因斯坦方程之前，必须首先在三维表面上指定时空的初始状态。本练习将指导您完成现代数值相对论中一项至关重要的实践任务：将初始数据从经典的阿诺维特-德泽-米斯纳（Arnowitt-Deser-Misner, ADM）变量转换为数值上更稳健的BSSN（Baumgarte-Shapiro-Shibata-Nakamura）变量。掌握这种变换是构建稳定、准确的模拟代码的基础步骤。", "problem": "您需要在一个使用周期性边界条件的均匀三维笛卡尔网格上，实现、验证和测试一个从 Arnowitt–Deser–Misner (ADM) 初始数据到 Baumgarte–Shapiro–Shibata–Nakamura (BSSN) 变量的变换。ADM 初始数据包括空间度规 $\\gamma_{ij}$ 和外曲率 $K_{ij}$。需要生成的 BSSN 变量是共形因子 $\\phi$、共形度规 $\\tilde{\\gamma}_{ij}$、共形无迹外曲率 $A_{ij}$、平均曲率 $K$ 以及收缩的共形联络函数 $\\tilde{\\Gamma}^{i}$。\n\n出发点（源自 $3+1$ 分解和 BSSN 形式体系的基本定义与恒等式）：\n- 度规的共形分解为 $\\gamma_{ij} = e^{4 \\phi} \\tilde{\\gamma}_{ij}$，其中 $\\det(\\tilde{\\gamma}_{ij}) = 1$。由此可得 $\\det(\\gamma_{ij}) = e^{12 \\phi}$，因此 $\\phi = \\frac{1}{12} \\ln \\det(\\gamma_{ij})$。\n- 平均曲率是外曲率相对于 $\\gamma_{ij}$ 的迹：$K = \\gamma^{ij} K_{ij}$，其中 $\\gamma^{ij}$ 是 $\\gamma_{ij}$ 的逆矩阵。\n- $K_{ij}$ 的无迹部分是 $S_{ij} = K_{ij} - \\frac{1}{3} \\gamma_{ij} K$。共形无迹外曲率是 $A_{ij} = e^{-4 \\phi} S_{ij}$。\n- 在笛卡尔坐标系中，当 $\\det(\\tilde{\\gamma}_{ij}) = 1$ 时，收缩的共形联络函数满足 $\\tilde{\\Gamma}^{i} = - \\partial_{j} \\tilde{\\gamma}^{ij}$，其中 $\\tilde{\\gamma}^{ij}$ 是 $\\tilde{\\gamma}_{ij}$ 的逆矩阵。空间导数需要进行数值近似。\n\n数值要求：\n- 使用一个包含 $N \\times N \\times N$ 个点的均匀笛卡尔网格，覆盖周期性区域 $[0, L] \\times [0, L] \\times [0, L]$。网格间距为 $\\Delta x = \\Delta y = \\Delta z = L/N$。对于整数 $n, m, p \\in \\{0, 1, \\dots, N-1\\}$，网格点位于 $x_{n} = n \\Delta x$，$y_{m} = m \\Delta y$，$z_{p} = p \\Delta z$。\n- 在所有三个方向上使用周期性边界条件。\n- 使用二阶中心有限差分计算空间导数。对于任意标量或张量分量 $u$，沿坐标 $x$ 的离散导数近似为 $\\partial_{x} u \\approx \\left(u(x+\\Delta x) - u(x-\\Delta x)\\right) / (2 \\Delta x)$，对 $y$ 和 $z$ 也类似，并进行周期性环绕处理。\n\n实现任务：\n- 编写一个模块，在给定网格上的场 $\\gamma_{ij}$ 和 $K_{ij}$后，根据上述定义在每个网格点上计算 $\\phi$、$\\tilde{\\gamma}_{ij}$、$A_{ij}$、$K$ 和 $\\tilde{\\Gamma}^{i}$。\n- 在以下三个测试用例上验证实现。在每个用例中，ADM 数据均由解析式指定，您必须在网格上构造 $\\gamma_{ij}$ 和 $K_{ij}$，应用您的变换，并在 BSSN 量非平凡的情况下将其与解析已知的 BSSN 量进行比较。\n\n测试套件（所有用例使用相同的网格参数 $N$ 和 $L$）：\n- 通用网格参数：$N = 32$, $L = 2\\pi$。\n\n- 用例 1（纯共形因子、平直共形度规、外曲率消失）：\n  - 定义 $f(x) = a \\sin(k x)$，其中 $a = 0.1$，$k = 1$，仅依赖于 $x$。\n  - 设置 $\\gamma_{ij} = e^{4 f(x)} \\delta_{ij}$ 和 $K_{ij} = 0$。\n  - 解析 BSSN 参考值：$\\phi = f(x)$，$\\tilde{\\gamma}_{ij} = \\delta_{ij}$，$A_{ij} = 0$，$K = 0$，$\\tilde{\\Gamma}^{i} = 0$。\n\n- 用例 2（非平凡单位行列式共形度规、共形因子为零、外曲率消失）：\n  - 定义 $h(x) = b \\cos(k x)$，其中 $b = 0.2$，$k = 2$，仅依赖于 $x$。\n  - 设置 $\\tilde{\\gamma}_{ij} = \\mathrm{diag}\\left(e^{h(x)}, e^{-h(x)}, 1\\right)$ 和 $\\gamma_{ij} = \\tilde{\\gamma}_{ij}$，且 $K_{ij} = 0$。\n  - 解析 BSSN 参考值：$\\phi = 0$，$A_{ij} = 0$，$K = 0$。逆共形度规为 $\\tilde{\\gamma}^{ij} = \\mathrm{diag}\\left(e^{-h(x)}, e^{h(x)}, 1\\right)$。因此 $\\tilde{\\Gamma}^{x} = -\\partial_{x}\\tilde{\\gamma}^{xx} = e^{-h(x)} h'(x)$，其中 $h'(x) = - b k \\sin(k x)$，且 $\\tilde{\\Gamma}^{y} = 0$，$\\tilde{\\Gamma}^{z} = 0$。\n\n- 用例 3（非平凡共形因子、平直共形度规、具有给定迹和无迹部分的外曲率）：\n  - 定义 $f(x) = a \\cos(k x)$，其中 $a = 0.05$，$k = 3$，仅依赖于 $x$。设 $K_{0} = 0.4$ 和 $s = 0.3$ 为常数。\n  - 设置 $\\gamma_{ij} = e^{4 f(x)} \\delta_{ij}$ 并定义一个常数无迹张量 $S_{ij} = \\mathrm{diag}(s, -s/2, -s/2)$（相对于 $\\delta_{ij}$ 是无迹的）。定义 $K_{ij} = \\frac{1}{3} \\gamma_{ij} K_{0} + e^{4 f(x)} S_{ij}$。\n  - 解析 BSSN 参考值：$\\phi = f(x)$，$\\tilde{\\gamma}_{ij} = \\delta_{ij}$，$K = K_{0}$，$A_{ij} = S_{ij}$，$\\tilde{\\Gamma}^{i} = 0$。\n\n误差评估和要求输出：\n- 对于每个用例，计算：\n  - $\\phi$ 在所有网格点上的最大绝对误差：$\\max |\\phi_{\\mathrm{num}} - \\phi_{\\mathrm{ref}}|$。\n  - $K$ 在所有网格点上的最大绝对误差：$\\max |K_{\\mathrm{num}} - K_{\\mathrm{ref}}|$。\n  - $A_{ij}$ 在所有网格点和分量上的最大绝对误差：$\\max |A^{\\mathrm{num}}_{ij} - A^{\\mathrm{ref}}_{ij}|$。\n  - $\\tilde{\\Gamma}^{i}$ 误差的逐点欧几里得范数的最大值：$\\max \\sqrt{(\\Delta \\tilde{\\Gamma}^{x})^{2} + (\\Delta \\tilde{\\Gamma}^{y})^{2} + (\\Delta \\tilde{\\Gamma}^{z})^{2}}$。\n- 您的程序应生成单行输出，其中按顺序包含所有三个用例的结果，形式为一个用方括号括起来的逗号分隔列表：$[\\mathrm{case1\\_phi},\\mathrm{case1\\_K},\\mathrm{case1\\_A},\\mathrm{case1\\_\\tilde{\\Gamma}};\\mathrm{case2\\_phi},\\mathrm{case2\\_K},\\mathrm{case2\\_A},\\mathrm{case2\\_\\tilde{\\Gamma}};\\mathrm{case3\\_phi},\\mathrm{case3\\_K},\\mathrm{case3\\_A},\\mathrm{case3\\_\\tilde{\\Gamma}}]$。在实际输出字符串中，将分号替换为逗号，从而得到一个包含 12 个浮点数的扁平列表。不应打印任何其他文本。", "solution": "问题陈述已提交以供验证。提取并分析了其中的给定条件、定义和测试用例，以评估其内部一致性和科学有效性。该问题涉及将爱因斯坦场方程的初始数据从 Arnowitt–Deser–Misner (ADM) 形式体系变换到 Baumgarte–Shapiro–Shibata–Nakamura (BSSN) 形式体系。所有定义——度规的共形分解 $\\gamma_{ij} = e^{4 \\phi} \\tilde{\\gamma}_{ij}$、平均曲率的定义 $K = \\gamma^{ij} K_{ij}$、共形无迹外曲率 $A_{ij}$ 以及收缩的共形联络函数 $\\tilde{\\Gamma}^{i} = - \\partial_{j} \\tilde{\\gamma}^{ij}$——在数值相对论领域都是标准的。所提供的测试用例经核实与这些定义一致。此问题是一个定义明确的计算物理任务，具有清晰、客观的规范和可验证的结果。因此，该问题被视为有效。\n\n解决方案要求实现一个数值程序，在均匀笛卡尔网格上从 ADM 变量（$\\gamma_{ij}, K_{ij}$）计算 BSSN 变量（$\\phi, \\tilde{\\gamma}_{ij}, K, A_{ij}, \\tilde{\\Gamma}^{i}$）。其步骤如下。\n\n首先，建立一个均匀、周期性的三维笛卡尔网格。该网格有 $N \\times N \\times N$ 个点，其中 $N=32$，覆盖了区域 $[0, L] \\times [0, L] \\times [0, L]$，其中 $L=2\\pi$。网格间距为 $\\Delta x = \\Delta y = \\Delta z = L/N$。每个网格点 $(i,j,k)$ 的坐标为 $(x_i, y_j, z_k)$。对于三个测试用例中的每一个，初始的 ADM 张量场 $\\gamma_{ij}$ 和 $K_{ij}$ 会根据其解析定义在该网格上被构造为数组。\n\n该变换在每个网格点上按以下计算顺序进行：\n\n1.  **共形因子 $\\phi$**：计算空间度规的行列式 $\\det(\\gamma_{ij})$。然后，共形因子由 $\\phi = \\frac{1}{12} \\ln(\\det(\\gamma_{ij}))$ 给出。此步骤分离出了空间几何的体积部分。\n\n2.  **共形度规 $\\tilde{\\gamma}_{ij}$**：使用计算出的共形因子 $\\phi$，对物理度规 $\\gamma_{ij}$ 进行共形重缩放以获得共形度规 $\\tilde{\\gamma}_{ij} = e^{-4\\phi} \\gamma_{ij}$。根据构造，该度规的行列式为单位一，即 $\\det(\\tilde{\\gamma}_{ij}) = 1$。\n\n3.  **平均曲率 $K$**：在每个网格点上通过对 $3 \\times 3$ 矩阵 $\\gamma_{ij}$ 求逆来计算物理空间度规的逆 $\\gamma^{ij}$。然后通过将逆度规与外曲率进行缩并来求得平均曲率：$K = \\gamma^{ij} K_{ij}$。这是一个对两个指标求和的过程，代表了 $K_{ij}$ 的迹。\n\n4.  **共形无迹外曲率 $A_{ij}$**：首先，计算外曲率相对于物理度规的无迹部分 $S_{ij} = K_{ij} - \\frac{1}{3} \\gamma_{ij} K$。然后对此张量进行共形重缩放，得到 BSSN 变量 $A_{ij} = e^{-4\\phi} S_{ij}$。\n\n5.  **收缩的共形联络函数 $\\tilde{\\Gamma}^{i}$**：这是唯一需要数值微分的步骤。\n    a.  从 $\\tilde{\\gamma}_{ij}$ 计算共形度规的逆 $\\tilde{\\gamma}^{ij}$。\n    b.  使用带有周期性边界条件的二阶中心有限差分格式计算 $\\tilde{\\gamma}^{ij}$ 各分量的空间导数 $\\partial_j$。对于一个场 $u(x,y,z)$ 和网格间距 $\\Delta x$，在网格点 $i$ 处关于 $x$ 的导数可近似为 $\\partial_x u_i \\approx \\frac{u_{i+1} - u_{i-1}}{2 \\Delta x}$。区域的周期性意味着边界处的索引 $i+1$ 会环绕到开头，而 $i-1$ 会环绕到末尾。\n    c.  然后通过对这些导数进行缩并来计算联络函数：$\\tilde{\\Gamma}^{i} = - \\sum_{j} \\partial_j \\tilde{\\gamma}^{ij}$。具体来说，对于每个分量 $i \\in \\{x, y, z\\}$：\n    $$ \\tilde{\\Gamma}^x = -(\\partial_x \\tilde{\\gamma}^{xx} + \\partial_y \\tilde{\\gamma}^{xy} + \\partial_z \\tilde{\\gamma}^{xz}) $$\n    $$ \\tilde{\\Gamma}^y = -(\\partial_x \\tilde{\\gamma}^{yx} + \\partial_y \\tilde{\\gamma}^{yy} + \\partial_z \\tilde{\\gamma}^{yz}) $$\n    $$ \\tilde{\\Gamma}^z = -(\\partial_x \\tilde{\\gamma}^{zx} + \\partial_y \\tilde{\\gamma}^{zy} + \\partial_z \\tilde{\\gamma}^{zz}) $$\n    请注意，由于逆度规是对称的（$\\tilde{\\gamma}^{ij} = \\tilde{\\gamma}^{ji}$），该表达式等价于逆共形度规张量各行（或各列）的散度。\n\n最后，对于每个测试用例，将数值计算出的 BSSN 场与其提供的解析参考解进行比较。误差度量按规定计算：标量场和张量场 $\\phi$、$K$ 和 $A_{ij}$ 的最大绝对误差，以及 $\\tilde{\\Gamma}^{i}$ 的误差向量的逐点欧几里得范数的最大值。这些误差预计会很小，与二阶有限差分格式的截断误差 $O(\\Delta x^2)$ 处于同一量级。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted from the specified environment.\n\ndef solve():\n    \"\"\"\n    Implements and tests the ADM to BSSN transformation for numerical relativity.\n    \"\"\"\n    N = 32\n    L = 2.0 * np.pi\n    dx = L / N\n    # We use np.mgrid to create coordinate arrays where the first axis corresponds to x,\n    # the second to y, and the third to z. This is unconventional but allows for\n    # straightforward indexing e.g., axis=0 for x-derivatives.\n    coords = np.mgrid[0:N, 0:N, 0:N].astype(float) * dx\n    x, y, z = coords[0], coords[1], coords[2]\n\n    def central_diff(field, axis, step):\n        \"\"\"Computes 2nd-order periodic central difference.\"\"\"\n        return (np.roll(field, -1, axis=axis) - np.roll(field, 1, axis=axis)) / (2.0 * step)\n\n    def adm_to_bssn(gamma, K_ij, dx, dy, dz):\n        \"\"\"\n        Performs the transformation from ADM to BSSN variables on the grid.\n        \n        Args:\n            gamma (np.ndarray): Physical metric, shape (3, 3, N, N, N).\n            K_ij (np.ndarray): Extrinsic curvature, shape (3, 3, N, N, N).\n            dx, dy, dz (float): Grid spacings.\n\n        Returns:\n            A tuple of BSSN variables: (phi, tilde_gamma, A_ij, K_trace, Gamma_i).\n        \"\"\"\n        # Transpose for np.linalg functions which operate on the last two axes\n        gamma_T = gamma.transpose(2, 3, 4, 0, 1)\n        \n        # 1. Conformal factor phi\n        gamma_det = np.linalg.det(gamma_T)\n        phi = (1.0 / 12.0) * np.log(gamma_det)\n\n        # 2. Conformal metric tilde_gamma_ij\n        # Use broadcasting: (N,N,N) * (3,3,N,N,N)\n        tilde_gamma = np.exp(-4.0 * phi) * gamma\n        \n        # 3. Mean curvature K\n        gamma_inv_T = np.linalg.inv(gamma_T)\n        gamma_inv = gamma_inv_T.transpose(3, 4, 0, 1, 2)\n        K_trace = np.einsum('ij...,ij...->...', gamma_inv, K_ij)\n\n        # 4. Conformal trace-free extrinsic curvature A_ij\n        S_ij = K_ij - (1.0 / 3.0) * K_trace * gamma  # Broadcasting K_trace * gamma\n        A_ij = np.exp(-4.0 * phi) * S_ij\n        \n        # 5. Contracted conformal connection functions Gamma^i\n        tilde_gamma_T = tilde_gamma.transpose(2, 3, 4, 0, 1)\n        tilde_gamma_inv_T = np.linalg.inv(tilde_gamma_T)\n        tilde_gamma_inv = tilde_gamma_inv_T.transpose(3, 4, 0, 1, 2)\n        \n        Gamma_i = np.zeros((3, N, N, N))\n        \n        # Sum over j: partial_j tilde_gamma^ij\n        # For i = 0 (x-component):\n        Gamma_i[0] = -(central_diff(tilde_gamma_inv[0, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[0, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[0, 2], 2, dz))\n        # For i = 1 (y-component):\n        Gamma_i[1] = -(central_diff(tilde_gamma_inv[1, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[1, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[1, 2], 2, dz))\n        # For i = 2 (z-component):\n        Gamma_i[2] = -(central_diff(tilde_gamma_inv[2, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[2, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[2, 2], 2, dz))\n        \n        return phi, tilde_gamma, A_ij, K_trace, Gamma_i\n\n    all_errors = []\n\n    # Test Case 1\n    a, k = 0.1, 1.0\n    f_x = a * np.sin(k * x)\n    \n    gamma_1 = np.zeros((3, 3, N, N, N))\n    conf_factor = np.exp(4.0 * f_x)\n    gamma_1[0, 0] = conf_factor\n    gamma_1[1, 1] = conf_factor\n    gamma_1[2, 2] = conf_factor\n    \n    K_ij_1 = np.zeros((3, 3, N, N, N))\n    \n    phi_num_1, tilde_gamma_num_1, A_ij_num_1, K_num_1, Gamma_i_num_1 = adm_to_bssn(gamma_1, K_ij_1, dx, dx, dx)\n    \n    phi_ref_1 = f_x\n    K_ref_1 = np.zeros_like(phi_ref_1)\n    A_ij_ref_1 = np.zeros_like(A_ij_num_1)\n    Gamma_i_ref_1 = np.zeros_like(Gamma_i_num_1)\n    \n    err_phi_1 = np.max(np.abs(phi_num_1 - phi_ref_1))\n    err_K_1 = np.max(np.abs(K_num_1 - K_ref_1))\n    err_A_1 = np.max(np.abs(A_ij_num_1 - A_ij_ref_1))\n    err_Gamma_1 = np.max(np.sqrt(np.sum((Gamma_i_num_1 - Gamma_i_ref_1)**2, axis=0)))\n    all_errors.extend([err_phi_1, err_K_1, err_A_1, err_Gamma_1])\n\n    # Test Case 2\n    b, k = 0.2, 2.0\n    h_x = b * np.cos(k * x)\n    \n    gamma_2 = np.zeros((3, 3, N, N, N))\n    gamma_2[0, 0] = np.exp(h_x)\n    gamma_2[1, 1] = np.exp(-h_x)\n    gamma_2[2, 2] = 1.0\n    \n    K_ij_2 = np.zeros((3, 3, N, N, N))\n\n    phi_num_2, _, A_ij_num_2, K_num_2, Gamma_i_num_2 = adm_to_bssn(gamma_2, K_ij_2, dx, dx, dx)\n\n    phi_ref_2 = np.zeros_like(phi_num_2)\n    K_ref_2 = np.zeros_like(K_num_2)\n    A_ij_ref_2 = np.zeros_like(A_ij_num_2)\n    \n    Gamma_i_ref_2 = np.zeros((3, N, N, N))\n    hp_x = -b * k * np.sin(k * x)\n    Gamma_i_ref_2[0] = np.exp(-h_x) * hp_x\n    \n    err_phi_2 = np.max(np.abs(phi_num_2 - phi_ref_2))\n    err_K_2 = np.max(np.abs(K_num_2 - K_ref_2))\n    err_A_2 = np.max(np.abs(A_ij_num_2 - A_ij_ref_2))\n    err_Gamma_2 = np.max(np.sqrt(np.sum((Gamma_i_num_2 - Gamma_i_ref_2)**2, axis=0)))\n    all_errors.extend([err_phi_2, err_K_2, err_A_2, err_Gamma_2])\n\n    # Test Case 3\n    a, k = 0.05, 3.0\n    K0, s = 0.4, 0.3\n    f_x = a * np.cos(k * x)\n    \n    gamma_3 = np.zeros((3, 3, N, N, N))\n    conf_factor = np.exp(4.0 * f_x)\n    gamma_3[0, 0] = conf_factor\n    gamma_3[1, 1] = conf_factor\n    gamma_3[2, 2] = conf_factor\n    \n    S_ij_const = np.zeros((3, 3))\n    S_ij_const[0, 0] = s\n    S_ij_const[1, 1] = -s / 2.0\n    S_ij_const[2, 2] = -s / 2.0\n    \n    K_ij_3 = (1.0 / 3.0) * K0 * gamma_3 + conf_factor * S_ij_const[:, :, np.newaxis, np.newaxis, np.newaxis]\n    \n    phi_num_3, _, A_ij_num_3, K_num_3, Gamma_i_num_3 = adm_to_bssn(gamma_3, K_ij_3, dx, dx, dx)\n\n    phi_ref_3 = f_x\n    K_ref_3 = np.full_like(K_num_3, K0)\n    A_ij_ref_3 = S_ij_const[:, :, np.newaxis, np.newaxis, np.newaxis]\n    Gamma_i_ref_3 = np.zeros_like(Gamma_i_num_3)\n    \n    err_phi_3 = np.max(np.abs(phi_num_3 - phi_ref_3))\n    err_K_3 = np.max(np.abs(K_num_3 - K_ref_3))\n    err_A_3 = np.max(np.abs(A_ij_num_3 - A_ij_ref_3))\n    err_Gamma_3 = np.max(np.sqrt(np.sum((Gamma_i_num_3 - Gamma_i_ref_3)**2, axis=0)))\n    all_errors.extend([err_phi_3, err_K_3, err_A_3, err_Gamma_3])\n\n    print(f\"[{','.join(map(str, all_errors))}]\")\n\nsolve()\n```", "id": "2420591"}, {"introduction": "正确配置初始数据后，下一个挑战是随时间向前演化时空，这个过程由您选择的“规范”（或坐标系）决定。这个选择不仅仅是为了方便，它对模拟的长期稳定性至关重要，尤其是在存在黑洞的情况下。本问题要求您分析一个看似简单的规范选择——测地线切片（geodesic slicing）——的后果，并理解为何它常常导致模拟过早失败，这一现象被称为“撞向奇点”（singularity crashing）。", "problem": "在广义相对论的3+1形式中，时空被分解为一系列由全局时间坐标 $t$ 索引的三维类空超曲面，或称为“切片”。这种切片的几何由两个关键量描述：lapse 函数 $\\alpha$ 和 shift 向量 $\\beta^i$。lapse 函数 $\\alpha(t, \\vec{x})$ 决定了对于一个保持在固定空间坐标 $\\vec{x}$ 处并垂直于每个切片运动的假设“欧拉” (Eulerian) 观测者而言，固有时 $\\tau$ 相对于坐标时 $t$ 的流逝速率。该关系式为 $d\\tau = \\alpha dt$。\n\n一个数值相对论程序被用来模拟 Schwarzschild 黑洞时空的演化，包括其内部。对于此类模拟的稳定性和持久性而言，一个关键的选择是“切片条件”，这是一种随着模拟的进行确定 lapse 函数 $\\alpha$ 的规则。\n\n考虑最简单的切片条件，称为“测地线切片”(Geodesic Slicing)，其中 lapse 函数在所有时间和空间点都设为1，即 $\\alpha(t, \\vec{x}) = 1$。尽管这种选择在计算上很简单，但对于包含奇点的时空的长期模拟来说，它是有问题的。\n\n以下哪个陈述正确地指出了测地线切片导致黑洞模拟终止的主要原因？\n\nA. 事件视界的面积随时间伪性减小，违反了 Hawking 面积定理，导致了非物理的解。\n\nB. 恒定的 lapse 函数导致计算网格在事件视界附近无限快地膨胀，这种现象被称为“网格拉伸”，使得模拟在计算上难以处理。\n\nC. 由切片定义的坐标与自由下落的观测者共动，导致切片直接前进到中心奇点，在那里像曲率这样的物理量会发散，并导致计算溢出。\n\nD. 条件 $\\alpha=1$ 与广义相对论的哈密顿约束和动量约束不相容，导致这些约束被指数级违反，并迅速破坏模拟的物理有效性。\n\nE. 时间演化全局停止，因为所有观测者的固有时变得与坐标时相等，从而有效地“冻结”了整个时空的几何。", "solution": "问题要求确定在黑洞时空的数值模拟中，“测地线切片”（$\\alpha=1$）的主要失效模式。让我们分析这种切片条件的物理意义及其在黑洞内部的后果。\n\n首先，我们必须理解 lapse 函数 $\\alpha$ 的作用。它通过方程 $d\\tau = \\alpha dt$ 将垂直于空间切片运动的观测者的固有时 $\\tau$ 的流逝与坐标时 $t$ 的推进联系起来。测地线切片设置 $\\alpha=1$。这意味着对于处于固定空间坐标位置的观测者，他们的固有时流逝速率与全局坐标时完全相同，$d\\tau = dt$。这样的观测者处于自由下落状态；他们的世界线是测地线。因此，空间切片对于一个自由下落观测者族来说是固有时不变的曲面。\n\n接下来，考虑 Schwarzschild 黑洞的结构。一旦观测者或粒子穿过事件视界，它就进入了一个径向坐标 $r$ 和时间坐标的角色互换的区域。径向坐标 $r$ 变为类时的，所有指向未来的世界线都必须不可避免地朝向更小的 $r$ 值移动，最终终止于 $r=0$ 处的物理奇点。没有任何物理力量可以阻止这种向内的运动。\n\n现在，让我们结合这两点。使用测地线切片的数值模拟用超曲面来叶状化时空，这些超曲面实际上被一群自由下落的观测者“携带”前进。在黑洞之外，这不一定是个问题。然而，对于计算域内任何位于事件视界内部的部分，这些自由下落的观测者（以及与他们相关的计算网格点）都会不可阻挡地被吸引向 $r=0$ 处的中心奇点。\n\n代表模拟中“现在”的空间切片，将因此随着时间推移而稳步向 $r=0$ 进军。在奇点处，时空曲率是无限的。数值模拟必须计算的物理量，例如 Riemann 曲率张量的分量或像 Kretschmann 标量（对于 Schwarzschild，$K = R_{abcd}R^{abcd} \\propto 1/r^6$）这样的标量不变量，在 $r \\to 0$ 时会发散。随着模拟的切片接近奇点，这些量的计算值将无界增长。任何真实的计算机对其可以表示的数字大小都有一个有限的限制。这种无界增长会迅速导致“浮点溢出”错误，致使模拟崩溃。这种现象通常被称为“撞向奇点”(singularity crashing)。\n\n有了这些理解，我们来评估给出的选项：\n\n**A. 事件视界的面积随时间伪性减小...** 这是不正确的。Hawking 面积定理是一项基本物理定律。一个正确求解爱因斯坦场方程的数值程序，无论使用何种坐标系（切片），都会遵守该定理。违反可能由于数值误差而发生，但这是分辨率不足的症状，而非由 $\\alpha=1$ 条件本身引起的主要失效模式。\n\n**B. 恒定的 lapse 函数导致计算网格在事件视界附近无限快地膨胀...** 这是不正确的。实际上，相反的问题在“奇点回避”切片（如谐和切片或 1+log 切片）中更常见。这些切片会使 lapse $\\alpha$ 在奇点附近坍缩为零以“冻结”那里的时间，这可能导致其他地方出现极端的网格拉伸。$\\alpha=1$ 的问题在于它*未能*减慢时间，而不是它导致了网格拉伸。\n\n**C. 由切片定义的坐标与自由下落的观测者共动，导致切片直接前进到中心奇点，在那里像曲率这样的物理量会发散，并导致计算溢出。** 这是对失效模式的正确描述。切片被拖入奇点，在有限的计算机上计算无限大的物理量的尝试导致模拟停止。\n\n**D. 条件 $\\alpha=1$ 与广义相对论的哈密顿约束和动量约束不相容...** 这是不正确的。lapse 和 shift 的选择（即规范选择），原则上与约束方程是否满足无关。约束必须在初始切片上得到满足，而演化方程的正确实现将确保它们在后续的切片上（在数值误差范围内）保持满足，无论规范如何选择。模拟的失效是坐标到达一个物理病态区域（奇点）的后果，而不是与基本方程存在内在不相容性。\n\n**E. 时间演化全局停止，因为所有观测者的固有时变得与坐标时相等...** 这描述的情况与实际发生的恰好相反。设置 $\\alpha=1$ *强制*时间在各处以恒定速率演化。问题在于这种演化将切片引入了一个物理规律失效的区域。时间演化不会停止；它直接走向一场灾难。一个“冻结”的几何将对应于一个静态时空，这并不是在动态模拟中发生的情况。\n\n因此，测地线切片失效的主要原因是它不能避开奇点，从而在切片到达奇点时导致计算崩溃。", "answer": "$$\\boxed{C}$$", "id": "1814395"}, {"introduction": "数值模拟的价值取决于其可靠性，而验证代码能否产生有物理意义的结果是计算科学的基石。最基本的验证技术之一是收敛性测试，它用以确认数值误差是否随着网格分辨率的提高而以预期的速率减小。本实践将让您分析模拟的输出数据来计算代码的收敛阶，这是验证任何数值相对论求解器的关键技能。", "problem": "一位物理学家正在对一个新的数值相对论代码进行收敛性测试。该代码通过求解爱因斯坦场方程来演化时空的初始构型。空间离散化格式的精度由其收敛阶 $p$ 来表征。对于一个 $p$ 阶的数值方法，离散误差 $E$ 期望与网格间距 $h$ 满足标度关系 $E \\propto h^p$。\n\n为了测量 $p$，这位物理学家使用三种系统性加密的网格分辨率运行了三次模拟。这些分辨率分别为：间距为 $h_c$ 的粗网格、间距为 $h_m = h_c/r$ 的中等网格，以及间距为 $h_f = h_m/r$ 的细网格。常数 $r$ 被称为加密因子。在本次测试中，使用的加密因子为 $r=2.0$。\n\n在经过设定的演化时间后，物理学家在一个固定的时空点上测量了由时空度规导出的一个特定标量 $\\Phi$ 的值。三次模拟得到如下数值：\n- 粗分辨率 ($\\Phi_c$)：$2.4000$\n- 中等分辨率 ($\\Phi_m$)：$2.3568$\n- 细分辨率 ($\\Phi_f$)：$2.3456$\n\n假设误差由离散化的主导阶项主导，请计算该数值代码的实测收敛阶 $p$。将最终答案四舍五入至三位有效数字。", "solution": "我们假设在网格间距为 $h$ 时测得的量 $\\Phi(h)$ 具有形式 $\\Phi(h)=\\Phi^{*}+C h^{p}+o(h^{p})$，其中 $\\Phi^{*}$ 是精确值，$C$ 是一个常数，$p$ 是收敛阶。对于三个网格间距 $h_{c}$、$h_{m}=h_{c}/r$ 和 $h_{f}=h_{m}/r=h_{c}/r^{2}$，其主导阶的差值满足\n$$\n\\Phi_{c}-\\Phi_{m}=C\\left(h_{c}^{p}-h_{m}^{p}\\right)=C h_{c}^{p}\\left(1-r^{-p}\\right),\n$$\n$$\n\\Phi_{m}-\\Phi_{f}=C\\left(h_{m}^{p}-h_{f}^{p}\\right)=C h_{m}^{p}\\left(1-r^{-p}\\right)=C h_{c}^{p} r^{-p}\\left(1-r^{-p}\\right).\n$$\n因此，比值\n$$\nR=\\frac{\\Phi_{c}-\\Phi_{m}}{\\Phi_{m}-\\Phi_{f}}=r^{p},\n$$\n所以\n$$\np=\\frac{\\ln R}{\\ln r}=\\frac{\\ln\\left(\\left|\\frac{\\Phi_{c}-\\Phi_{m}}{\\Phi_{m}-\\Phi_{f}}\\right|\\right)}{\\ln r}.\n$$\n代入给定值，\n$$\n\\Phi_{c}-\\Phi_{m}=2.4000-2.3568=0.0432,\\quad \\Phi_{m}-\\Phi_{f}=2.3568-2.3456=0.0112,\n$$\n那么\n$$\nR=\\frac{0.0432}{0.0112}=\\frac{432}{112}=\\frac{27}{7}.\n$$\n当 $r=2$ 时，我们得到\n$$\np=\\frac{\\ln\\left(\\frac{27}{7}\\right)}{\\ln 2}\\approx 1.94753,\n$$\n四舍五入到三位有效数字后得到 $1.95$。", "answer": "$$\\boxed{1.95}$$", "id": "1814389"}]}