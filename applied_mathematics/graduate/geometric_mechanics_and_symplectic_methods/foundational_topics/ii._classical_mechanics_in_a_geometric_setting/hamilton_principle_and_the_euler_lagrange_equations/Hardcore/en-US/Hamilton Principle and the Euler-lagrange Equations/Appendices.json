{
    "hands_on_practices": [
        {
            "introduction": "The Legendre transform is the bridge connecting Lagrangian mechanics on the tangent bundle $TQ$ to Hamiltonian mechanics on the cotangent bundle $T^*Q$. For this transition to be a smooth, invertible map (a diffeomorphism), the Lagrangian must be \"hyperregular\". This exercise challenges you to explore this crucial property from first principles by computing the Jacobian of the fiber derivative for a general mechanical Lagrangian, thereby making the condition for hyperregularity explicit . Understanding this condition is fundamental to determining when a system admits a straightforward Hamiltonian description.",
            "id": "3744702",
            "problem": "Consider a smooth configuration manifold $Q$ of dimension $n$ with local coordinates $q = (q^{1},\\dots,q^{n})$. Let $TQ$ denote its tangent bundle with induced local fiber coordinates $v = \\dot{q} = (\\dot{q}^{1},\\dots,\\dot{q}^{n})$. Let the Lagrangian be of the mechanical type\n$$\nL(q,v) \\;=\\; \\frac{1}{2}\\, v^{\\top} M(q)\\, v \\;+\\; b(q)\\cdot v \\;-\\; V(q),\n$$\nwhere $M(q)$ is a smooth $n\\times n$ matrix-valued function, $b(q)$ is a smooth $\\mathbb{R}^{n}$-valued function, and $V(q)$ is a smooth real-valued function. Hamilton’s principle states that physical trajectories make the action $S[q] = \\int L(q,\\dot{q})\\, dt$ stationary among variations with fixed endpoints, and the Euler–Lagrange equations follow. The Hamiltonian description is obtained via the fiber derivative (also called the Legendre transform) $\\mathcal{F}L : TQ \\to T^{\\ast}Q$, which in local coordinates is defined by $(q,v) \\mapsto (q,p)$ with $p = \\partial L/\\partial v$.\n\nStarting from these foundations and the definition of the fiber derivative, compute in local coordinates the Jacobian (total derivative) of $\\mathcal{F}L$ as a map from $TQ$ to $T^{\\ast}Q$, expressed as a $2n\\times 2n$ block matrix with respect to the variables $(q,v)$ and the image coordinates $(q,p)$. Your derivation must proceed from first principles: compute the momentum map $p(q,v)$ from the given $L$, then differentiate it with respect to $q$ and $v$ to obtain the Jacobian blocks. Present the final Jacobian explicitly in terms of $M(q)$, $b(q)$, and their partial derivatives with respect to the components of $q$.\n\nIn addition, state precise necessary and sufficient conditions on $M(q)$ under which the Lagrangian $L$ is hyperregular (i.e., the fiber derivative $\\mathcal{F}L$ is a diffeomorphism $TQ \\to T^{\\ast}Q$). Justify your conditions directly from the structure you derive.\n\nReport as your final answer only the $2n\\times 2n$ Jacobian block matrix of $\\mathcal{F}L$. No units are required. Do not include any inequalities or verbal conditions in your final reported answer.",
            "solution": "The problem requires the computation of the Jacobian of the fiber derivative (Legendre transform) for a given Lagrangian, and the determination of the conditions under which this transformation is a diffeomorphism (i.e., the Lagrangian is hyperregular).\n\nThe given Lagrangian is of the mechanical type:\n$$\nL(q,v) = \\frac{1}{2}\\, v^{\\top} M(q)\\, v + b(q)\\cdot v - V(q)\n$$\nwhere $q = (q^1, \\dots, q^n)$ are local coordinates on the configuration manifold $Q$, and $v = \\dot{q} = (v^1, \\dots, v^n)$ are the corresponding fiber coordinates on the tangent bundle $TQ$. $M(q)$ is an $n \\times n$ matrix-valued function, $b(q)$ is an $\\mathbb{R}^n$-valued function (a vector field), and $V(q)$ is a scalar potential.\n\nTo perform calculations, we write the Lagrangian in index notation:\n$$\nL(q,v) = \\frac{1}{2} \\sum_{i,j=1}^n M_{ij}(q) v^i v^j + \\sum_{i=1}^n b_i(q) v^i - V(q)\n$$\nThe fiber derivative $\\mathcal{F}L: TQ \\to T^*Q$ maps coordinates $(q,v)$ to $(q,p)$, where the conjugate momentum $p = (p_1, \\dots, p_n)$ is defined by $p_k = \\frac{\\partial L}{\\partial v^k}$. Let's compute the components of $p$:\n$$\np_k = \\frac{\\partial}{\\partial v^k} \\left( \\frac{1}{2} \\sum_{i,j} M_{ij}(q) v^i v^j + \\sum_i b_i(q) v^i - V(q) \\right)\n$$\nThe derivative of the quadratic term is:\n$$\n\\frac{\\partial}{\\partial v^k} \\left( \\frac{1}{2} \\sum_{i,j} M_{ij} v^i v^j \\right) = \\frac{1}{2} \\sum_{i,j} M_{ij} \\left( \\frac{\\partial v^i}{\\partial v^k} v^j + v^i \\frac{\\partial v^j}{\\partial v^k} \\right) = \\frac{1}{2} \\sum_{i,j} M_{ij} (\\delta^i_k v^j + v^i \\delta^j_k)\n$$\n$$\n= \\frac{1}{2} \\left( \\sum_j M_{kj} v^j + \\sum_i M_{ik} v^i \\right)\n$$\nThis expression depends on both $M$ and its transpose $M^\\top$. Let's rewrite it:\n$$\n= \\frac{1}{2} \\sum_j (M_{kj} + M_{jk}) v^j\n$$\nThe derivative of the linear term is $\\frac{\\partial}{\\partial v^k} (\\sum_i b_i v^i) = b_k$. The potential term $V(q)$ is independent of $v$, so its derivative is zero.\nCombining the terms, the momentum is:\n$$\np_k(q,v) = \\frac{1}{2} \\sum_{j=1}^n (M_{kj}(q) + M_{jk}(q)) v^j + b_k(q)\n$$\nIt is standard to introduce the symmetric part of the matrix $M(q)$, denoted $\\tilde{M}(q)$, with entries $\\tilde{M}_{kj}(q) = \\frac{1}{2}(M_{kj}(q) + M_{jk}(q))$. In matrix notation, $\\tilde{M}(q) = \\frac{1}{2}(M(q) + M(q)^\\top)$. The momentum map is then concisely written in vector form as:\n$$\np(q,v) = \\tilde{M}(q)v + b(q)\n$$\nThe fiber derivative $\\mathcal{F}L$ is the map from $TQ$ to $T^*Q$ given in local coordinates by $\\mathcal{F}L(q,v) = (q, p(q,v))$. We are asked to find its Jacobian, which is a $2n \\times 2n$ matrix representing the total derivative of this map with respect to the coordinate vector $(q, v)$. The Jacobian matrix has a block structure:\n$$\nD(\\mathcal{F}L)(q,v) = \\begin{pmatrix} \\frac{\\partial q}{\\partial q}  \\frac{\\partial q}{\\partial v} \\\\ \\frac{\\partial p}{\\partial q}  \\frac{\\partial p}{\\partial v} \\end{pmatrix}\n$$\nWe compute each of the four $n \\times n$ blocks:\n1.  **Top-left block**: $\\frac{\\partial q}{\\partial q}$. The entries are $(\\frac{\\partial q}{\\partial q})_{ij} = \\frac{\\partial q^i}{\\partial q^j} = \\delta_{ij}$. This block is the $n \\times n$ identity matrix, $I_n$.\n2.  **Top-right block**: $\\frac{\\partial q}{\\partial v}$. The entries are $(\\frac{\\partial q}{\\partial v})_{ij} = \\frac{\\partial q^i}{\\partial v^j} = 0$, since $q$ does not depend on $v$. This block is the $n \\times n$ zero matrix, $0_n$.\n3.  **Bottom-right block**: $\\frac{\\partial p}{\\partial v}$. The entries are $(\\frac{\\partial p}{\\partial v})_{ij} = \\frac{\\partial p_i}{\\partial v^j}$. Using the expression for $p_i$:\n    $$\n    \\frac{\\partial p_i}{\\partial v^j} = \\frac{\\partial}{\\partial v^j} \\left( \\sum_{k=1}^n \\tilde{M}_{ik}(q) v^k + b_i(q) \\right) = \\sum_{k=1}^n \\tilde{M}_{ik}(q) \\frac{\\partial v^k}{\\partial v^j} = \\sum_{k=1}^n \\tilde{M}_{ik}(q) \\delta_{kj} = \\tilde{M}_{ij}(q)\n    $$\n    So, this block is the matrix $\\tilde{M}(q) = \\frac{1}{2}(M(q) + M(q)^\\top)$.\n4.  **Bottom-left block**: $\\frac{\\partial p}{\\partial q}$. The entries are $(\\frac{\\partial p}{\\partial q})_{ij} = \\frac{\\partial p_i}{\\partial q^j}$. This requires differentiating the expression for $p_i$ with respect to the components of $q$:\n    $$\n    \\frac{\\partial p_i}{\\partial q^j} = \\frac{\\partial}{\\partial q^j} \\left( \\sum_{k=1}^n \\tilde{M}_{ik}(q) v^k + b_i(q) \\right) = \\sum_{k=1}^n \\frac{\\partial \\tilde{M}_{ik}(q)}{\\partial q^j} v^k + \\frac{\\partial b_i(q)}{\\partial q^j}\n    $$\n    Substituting back $\\tilde{M}_{ik} = \\frac{1}{2}(M_{ik} + M_{ki})$, we obtain the final expression for the entry:\n    $$\n    \\left(\\frac{\\partial p}{\\partial q}\\right)_{ij} = \\sum_{k=1}^n \\frac{1}{2} \\left( \\frac{\\partial M_{ik}(q)}{\\partial q^j} + \\frac{\\partial M_{ki}(q)}{\\partial q^j} \\right) v^k + \\frac{\\partial b_i(q)}{\\partial q^j}\n    $$\nAssembling these blocks, the Jacobian of the fiber derivative is:\n$$\nD(\\mathcal{F}L)(q,v) = \\begin{pmatrix} I_n  0_n \\\\ \\left[\\frac{\\partial p_i}{\\partial q^j}\\right]  \\tilde{M}(q) \\end{pmatrix}\n$$\nwhere the $(i,j)$-th entry of the bottom-left block is the expression derived above.\n\nNext, we determine the condition for the Lagrangian $L$ to be hyperregular. By definition, $L$ is hyperregular if the fiber derivative $\\mathcal{F}L: TQ \\to T^*Q$ is a diffeomorphism. A diffeomorphism is a smooth map that has a smooth inverse.\n\nAccording to the Inverse Function Theorem, a smooth map is a local diffeomorphism at a point if and only if its Jacobian matrix is invertible at that point. The Jacobian of $\\mathcal{F}L$ is block lower triangular, so its determinant is the product of the determinants of its diagonal blocks:\n$$\n\\det(D(\\mathcal{F}L)(q,v)) = \\det(I_n) \\det(\\tilde{M}(q)) = \\det(\\tilde{M}(q))\n$$\nFor $\\mathcal{F}L$ to be a local diffeomorphism everywhere, its Jacobian must be invertible for all $(q,v) \\in TQ$. This requires $\\det(\\tilde{M}(q)) \\neq 0$ for all $q \\in Q$. This means the symmetric part of the kinetic energy matrix, $\\tilde{M}(q)$, must be non-singular (invertible) on the entire manifold $Q$.\n\nLet's check if this condition is also sufficient for $\\mathcal{F}L$ to be a global diffeomorphism. We must show that the map is bijective and that its inverse is smooth. The map is $\\mathcal{F}L(q,v) = (q', p')$ with $q'=q$ and $p' = \\tilde{M}(q)v + b(q)$. To find the inverse map, we solve for $(q,v)$ in terms of $(q',p')$. Clearly, $q=q'$. We then solve for $v$:\n$$\np' = \\tilde{M}(q')v + b(q') \\implies \\tilde{M}(q')v = p' - b(q')\n$$\nIf $\\tilde{M}(q')$ is invertible, we can find a unique solution for $v$:\n$$\nv = (\\tilde{M}(q'))^{-1} (p' - b(q'))\n$$\nThis defines the inverse map $\\mathcal{F}L^{-1}: T^*Q \\to TQ$ as $\\mathcal{F}L^{-1}(q',p') = (q', (\\tilde{M}(q'))^{-1}(p' - b(q')))$. The map is well-defined and bijective if and only if $\\tilde{M}(q)$ is invertible for all $q \\in Q$.\nFurthermore, if this condition holds, the inverse map is smooth. Since $M(q)$ and $b(q)$ are smooth, $\\tilde{M}(q)$ is also smooth. The entries of the inverse matrix $(\\tilde{M}(q))^{-1}$ are rational functions of the entries of $\\tilde{M}(q)$ (via the adjugate matrix formula), and since the determinant is non-zero, the inverse is also a smooth function of $q$. Therefore, the map $\\mathcal{F}L^{-1}$ is smooth.\n\nThus, the necessary and sufficient condition for the Lagrangian $L$ to be hyperregular is that the matrix $\\tilde{M}(q) = \\frac{1}{2}(M(q) + M(q)^\\top)$ is non-singular for all $q \\in Q$.\n\nThe problem asks for the Jacobian matrix as the final answer. We present it in block form, with the entries of each block specified.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nI_n  0_n \\\\\n\\left[ \\sum_{k=1}^n \\frac{1}{2} \\left( \\frac{\\partial M_{ik}}{\\partial q^j} + \\frac{\\partial M_{ki}}{\\partial q^j} \\right) v^k + \\frac{\\partial b_i}{\\partial q^j} \\right]  \\frac{1}{2}\\left(M(q) + M(q)^\\top\\right)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Hamilton's principle is more powerful than just yielding the Euler-Lagrange equations for paths with fixed endpoints. The boundary terms that arise during its derivation contain profound physical information about the system's behavior when endpoints are free or constrained. This practice guides you through an exploration of these boundary terms, deriving first the natural boundary conditions for a free endpoint and then the more general transversality condition for a path terminating on a specific submanifold . This reveals how the variational principle elegantly encodes both the dynamics and the geometric boundary interactions.",
            "id": "3744671",
            "problem": "Consider a mechanical system with configuration space $Q=\\mathbb{R}^{n}$ and a smooth Lagrangian $L: TQ \\times \\mathbb{R} \\to \\mathbb{R}$, written in local coordinates as $L(q,\\dot{q},t)$, where $q \\in \\mathbb{R}^{n}$ and $\\dot{q} \\in \\mathbb{R}^{n}$. Let the action functional be $S[q]=\\int_{t_{0}}^{t_{1}} L(q(t),\\dot{q}(t),t)\\,dt$. Assume the initial endpoint $q(t_{0})$ is fixed, but the terminal endpoint $q(t_{1})$ is not fixed. \n\nPart A: Starting from Hamilton's principle (the statement that the first variation $\\delta S$ vanishes for all admissible variations $\\delta q$), derive the interior equations and show explicitly how allowing $\\delta q(t_{1})\\neq 0$ yields a natural boundary condition at $t_{1}$ when the endpoint is completely free.\n\nPart B: Now suppose the terminal endpoint $q(t_{1})$ is constrained to lie on a smooth embedded submanifold $\\mathcal{S}\\subset \\mathbb{R}^{n}$ defined locally as\n$$\n\\mathcal{S}=\\{\\,q\\in\\mathbb{R}^{n}\\mid g_{i}(q)=0,\\;i=1,\\dots,k\\,\\},\n$$\nwhere each $g_{i}:\\mathbb{R}^{n}\\to\\mathbb{R}$ is smooth and the $k\\times n$ Jacobian matrix has rank $k$ at $q(t_{1})$ so that $\\mathcal{S}$ has codimension $k$. For admissible variations, require $\\delta q(t_{0})=0$ and $\\delta q(t_{1})\\in T_{q(t_{1})}\\mathcal{S}$, the tangent space to $\\mathcal{S}$ at the endpoint.\n\nUsing Hamilton's principle and only fundamental definitions and operations (integration by parts and the definition of the tangent and normal spaces via gradients of the constraints), compute the transversality condition at $t_{1}$ for the constrained endpoint. Express your final transversality condition as a single analytical expression that relates $\\frac{\\partial L}{\\partial \\dot{q}}(t_{1})$ to the gradients $\\nabla g_{i}(q(t_{1}))$.\n\nYour final answer must be a single closed-form analytic expression. No numerical evaluation is required.",
            "solution": "The problem requires the derivation of the transversality condition for a mechanical system whose trajectory endpoint is constrained to a submanifold. We will proceed from the foundational statement of Hamilton's principle.\n\nLet the configuration of the system at time $t$ be described by the generalized coordinates $q(t) = (q_1(t), \\dots, q_n(t)) \\in \\mathbb{R}^n$. The action functional is defined as the time integral of the Lagrangian $L(q, \\dot{q}, t)$:\n$$\nS[q] = \\int_{t_{0}}^{t_{1}} L(q(t), \\dot{q}(t), t) \\, dt\n$$\nHamilton's principle posits that the actual path taken by the system between a fixed initial state $q(t_0)$ and a final state renders the action stationary. This means the first variation of the action, $\\delta S$, must vanish for any admissible variation $\\delta q(t)$ of the path $q(t)$. An admissible variation is an infinitesimal perturbation of the path, $\\delta q(t)$, that respects the given constraints.\n\nWe begin by computing the first variation of the action, $\\delta S$. The variation of the Lagrangian is given by the chain rule:\n$$\n\\delta L = \\sum_{j=1}^{n} \\frac{\\partial L}{\\partial q_j} \\delta q_j + \\sum_{j=1}^{n} \\frac{\\partial L}{\\partial \\dot{q}_j} \\delta \\dot{q}_j\n$$\nUsing the commutativity of the variation and time differentiation, $\\delta \\dot{q}_j = \\delta \\left(\\frac{dq_j}{dt}\\right) = \\frac{d}{dt}(\\delta q_j)$, the variation of the action becomes:\n$$\n\\delta S = \\int_{t_{0}}^{t_{1}} \\delta L(q, \\dot{q}, t) \\, dt = \\int_{t_{0}}^{t_{1}} \\left( \\sum_{j=1}^{n} \\frac{\\partial L}{\\partial q_j} \\delta q_j + \\sum_{j=1}^{n} \\frac{\\partial L}{\\partial \\dot{q}_j} \\frac{d}{dt}(\\delta q_j) \\right) dt\n$$\nWe apply integration by parts to the second term for each component $j$:\n$$\n\\int_{t_{0}}^{t_{1}} \\frac{\\partial L}{\\partial \\dot{q}_j} \\frac{d}{dt}(\\delta q_j) \\, dt = \\left[ \\frac{\\partial L}{\\partial \\dot{q}_j} \\delta q_j \\right]_{t_{0}}^{t_{1}} - \\int_{t_{0}}^{t_{1}} \\left( \\frac{d}{dt} \\frac{\\partial L}{\\partial \\dot{q}_j} \\right) \\delta q_j \\, dt\n$$\nSubstituting this back into the expression for $\\delta S$ and rearranging terms gives:\n$$\n\\delta S = \\int_{t_{0}}^{t_{1}} \\sum_{j=1}^{n} \\left( \\frac{\\partial L}{\\partial q_j} - \\frac{d}{dt} \\frac{\\partial L}{\\partial \\dot{q}_j} \\right) \\delta q_j \\, dt + \\left[ \\sum_{j=1}^{n} \\frac{\\partial L}{\\partial \\dot{q}_j} \\delta q_j \\right]_{t_{0}}^{t_{1}}\n$$\nThis expression is fundamental. In more compact vector notation, where $\\frac{\\partial L}{\\partial q}$ and $\\frac{\\partial L}{\\partial \\dot{q}}$ represent vectors of partial derivatives, and the dot product denotes the standard inner product on $\\mathbb{R}^n$, we have:\n$$\n\\delta S = \\int_{t_{0}}^{t_{1}} \\left( \\frac{\\partial L}{\\partial q} - \\frac{d}{dt} \\frac{\\partial L}{\\partial \\dot{q}} \\right) \\cdot \\delta q \\, dt + \\left[ \\frac{\\partial L}{\\partial \\dot{q}} \\cdot \\delta q \\right]_{t_{0}}^{t_{1}}\n$$\nFor Hamilton's principle, $\\delta S = 0$, to hold for arbitrary variations $\\delta q(t)$ in the open interval $(t_0, t_1)$, the integrand multiplying $\\delta q$ must vanish identically. This conclusion, from the fundamental lemma of calculus of variations, yields the Euler-Lagrange equations of motion:\n$$\n\\frac{\\partial L}{\\partial q_j} - \\frac{d}{dt} \\frac{\\partial L}{\\partial \\dot{q}_j} = 0, \\quad j=1, \\dots, n\n$$\nWith the Euler-Lagrange equations satisfied, the condition $\\delta S = 0$ reduces to the vanishing of the boundary term:\n$$\n\\left[ \\frac{\\partial L}{\\partial \\dot{q}} \\cdot \\delta q \\right]_{t_{0}}^{t_{1}} = \\frac{\\partial L}{\\partial \\dot{q}}(t_1) \\cdot \\delta q(t_1) - \\frac{\\partial L}{\\partial \\dot{q}}(t_0) \\cdot \\delta q(t_0) = 0\n$$\nThe specific form of the boundary conditions depends on the constraints imposed on the variations $\\delta q(t_0)$ and $\\delta q(t_1)$.\n\nPart A: The problem specifies a fixed initial endpoint, $q(t_0)$, which implies that any admissible variation must vanish at the initial time, i.e., $\\delta q(t_0)=0$. If the terminal endpoint $q(t_1)$ is completely free, then the variation $\\delta q(t_1)$ is an arbitrary vector in $\\mathbb{R}^n$. The boundary condition equation then simplifies to:\n$$\n\\frac{\\partial L}{\\partial \\dot{q}}(t_1) \\cdot \\delta q(t_1) = 0\n$$\nSince this must hold for any arbitrary vector $\\delta q(t_1) \\in \\mathbb{R}^n$, the only way for the dot product to be zero is if the other vector is the zero vector. This gives the natural boundary condition for a free endpoint:\n$$\n\\frac{\\partial L}{\\partial \\dot{q}}(t_1) = 0\n$$\nThis vector, $p(t_1) = \\frac{\\partial L}{\\partial \\dot{q}}(t_1)$, is the generalized momentum at time $t_1$. Thus, for a free endpoint, the momentum must vanish.\n\nPart B: We now address the primary question. The initial endpoint remains fixed, so $\\delta q(t_0) = 0$. The terminal endpoint $q(t_1)$ is constrained to lie on a smooth submanifold $\\mathcal{S} \\subset \\mathbb{R}^n$, defined as the zero locus of $k$ smooth functions:\n$$\n\\mathcal{S} = \\{\\, q \\in \\mathbb{R}^n \\mid g_i(q)=0, \\; i=1, \\dots, k \\,\\}\n$$\nThe path $q(t)$ must end on this surface, so $q(t_1) \\in \\mathcal{S}$. An admissible variation $\\delta q$ must map a path ending on $\\mathcal{S}$ to another path ending on $\\mathcal{S}$. To first order, this requires the variation vector at the endpoint, $\\delta q(t_1)$, to lie in the tangent space of $\\mathcal{S}$ at the point $q(t_1)$. That is, $\\delta q(t_1) \\in T_{q(t_1)}\\mathcal{S}$.\n\nThe tangent space $T_{q(t_1)}\\mathcal{S}$ is the set of all vectors in $\\mathbb{R}^n$ that are orthogonal to the gradients of all the constraint functions evaluated at $q(t_1)$. Let $v = \\delta q(t_1)$. Then $v \\in T_{q(t_1)}\\mathcal{S}$ if and only if:\n$$\n\\nabla g_i(q(t_1)) \\cdot v = 0 \\quad \\text{for all } i=1, \\dots, k\n$$\nThe condition on the boundary variations remains $\\frac{\\partial L}{\\partial \\dot{q}}(t_1) \\cdot \\delta q(t_1) = 0$. However, now this must hold not for arbitrary $\\delta q(t_1)$, but for all $\\delta q(t_1)$ belonging to the subspace $T_{q(t_1)}\\mathcal{S}$.\n\nLet $p(t_1) = \\frac{\\partial L}{\\partial \\dot{q}}(t_1)$. The condition is $p(t_1) \\cdot v = 0$ for all $v \\in T_{q(t_1)}\\mathcal{S}$. This means that the vector $p(t_1)$ is orthogonal to the entire tangent space $T_{q(t_1)}\\mathcal{S}$. In a Euclidean space, a vector orthogonal to a subspace must lie in its orthogonal complement. The orthogonal complement of the tangent space, $(T_{q(t_1)}\\mathcal{S})^\\perp$, is the normal space to the submanifold $\\mathcal{S}$ at $q(t_1)$.\n\nThe normal space is spanned by the gradient vectors of the constraint functions, $\\{\\nabla g_i(q(t_1))\\}_{i=1,\\dots,k}$. The problem states that the Jacobian matrix of the $g_i$ has full rank $k$, which ensures that these $k$ gradient vectors are linearly independent and thus form a basis for the $k$-dimensional normal space.\n\nTherefore, since the momentum vector $p(t_1) = \\frac{\\partial L}{\\partial \\dot{q}}(t_1)$ belongs to the normal space, it must be expressible as a linear combination of these basis vectors. This leads to the existence of $k$ real-valued scalars, $\\lambda_1, \\dots, \\lambda_k$, which are Lagrange multipliers, such that:\n$$\n\\frac{\\partial L}{\\partial \\dot{q}}(t_1) = \\sum_{i=1}^{k} \\lambda_i \\nabla g_i(q(t_1))\n$$\nThis is the transversality condition for the constrained endpoint. It states that the generalized momentum vector of the system at the terminal time must be normal to the constraint surface $\\mathcal{S}$. This single analytical expression relates the momentum, which depends on the dynamics via $L$, to the geometry of the constraint surface via the gradients of the functions $g_i$.",
            "answer": "$$\n\\boxed{\\frac{\\partial L}{\\partial \\dot{q}}(t_{1}) = \\sum_{i=1}^{k} \\lambda_i \\nabla g_i(q(t_{1}))}\n$$"
        },
        {
            "introduction": "One of the most powerful modern applications of Hamilton's principle is in the construction of numerical methods that inherit the geometric structures of the physical system, such as symplecticity and momentum conservation. By discretizing the action integral *before* taking the variation, we can derive \"variational integrators\" that exhibit superior long-term stability and fidelity compared to conventional methods. This hands-on coding exercise asks you to derive and implement the well-known implicit midpoint method from a discrete action principle, and then numerically verify its excellent structural properties .",
            "id": "3744697",
            "problem": "Consider a finite-dimensional mechanical system with configuration vector $q \\in \\mathbb{R}^n$, constant symmetric positive-definite mass matrix $M \\in \\mathbb{R}^{n \\times n}$, and potential energy $V:\\mathbb{R}^n \\to \\mathbb{R}$. The Lagrangian is $L(q,\\dot{q}) = \\tfrac{1}{2}\\dot{q}^T M \\dot{q} - V(q)$. Starting from Hamilton's principle (the stationary action principle) and the definition of a discrete action constructed by applying the midpoint quadrature over each time subinterval, you are asked to derive, implement, and analyze a variational integrator.\n\nYour tasks are:\n- Construct the discrete action by choosing a midpoint quadrature over each time step and derive the discrete Euler-Lagrange update map for $(q_k,p_k) \\mapsto (q_{k+1},p_{k+1})$, where $p$ is the canonical momentum defined by $p = \\partial L/\\partial \\dot{q}$.\n- Deduce an implementable implicit one-step method that, given $(q_k,p_k)$ and a step size $h0$, returns $(q_{k+1},p_{k+1})$ for general smooth $V(q)$ and constant $M$.\n- Analyze the order of accuracy of the resulting method and its symplecticity from first principles of the discrete variational construction.\n- Implement the method and provide numerical evidence of its order and symplecticity on a small test suite.\n\nYou must restrict your derivations to the following foundational bases:\n- Hamilton's principle: the physical trajectory makes stationary the action integral $S[q] = \\int_{t_0}^{t_1} L(q,\\dot{q})\\,dt$.\n- The definition of canonical momentum $p = \\partial L/\\partial \\dot{q}$.\n- Discrete action and discrete Euler-Lagrange equations obtained by stationarity of the discrete action with respect to variations of the discrete path.\n- Basic Taylor expansion and linearization arguments for error and Jacobian computations.\nNo shortcut formulas for the target discrete update are permitted in the problem statement; derive them from these bases.\n\nImplementation requirements:\n- Your program must implement the implicit one-step method derived from the midpoint discrete action using a robust solver for the implicit equations.\n- Your program must output numerical results for the following test suite. All quantities are dimensionless, so no physical unit conversion is required.\n- Test Suite:\n  1. Scalar harmonic oscillator accuracy rate: Let $n=1$, $M = [2]$, $V(q) = \\tfrac{1}{2}\\,3\\,q^2$, initial conditions $q(0)=1$, $p(0)=0$, final time $T=1$. Compute the observed convergence rate of the global error by integrating with two step sizes $h_1=0.1$ and $h_2=0.05$. Use the exact solution of the harmonic oscillator to evaluate the global error at $T$ for each $h$, then report the rate $r = \\log(e_{h_2}/e_{h_1})/\\log(h_2/h_1)$ as a float, where $e_h$ is the Euclidean norm of the error in $(q(T),p(T))$.\n  2. Two-dimensional coupled oscillator symplecticity residual: Let $n=2$, $M = \\begin{bmatrix}2  0.5 \\\\ 0.5  1.5\\end{bmatrix}$, $V(q) = \\tfrac{1}{2} q^T K q$ with $K = \\begin{bmatrix}4  1 \\\\ 1  3\\end{bmatrix}$, choose a reproducible state $(q,p)$ with $q=(0.3,-0.2)$ and $p=(0.4,0.5)$, and $h=0.1$. Compute the numerical Jacobian $D\\Phi$ of the one-step map $\\Phi$ at $(q,p)$ using a central finite-difference approximation, then report the Frobenius norm of the symplecticity defect $\\|D\\Phi^T\\,J\\,D\\Phi - J\\|_F$ as a float, where $J = \\begin{bmatrix}0  I \\\\ -I  0\\end{bmatrix}$ is the canonical symplectic matrix.\n  3. Free particle exactness check: Let $n=3$, $M = \\mathrm{diag}(1,2,3)$, $V(q)=0$, initial conditions $q(0)=(0.1,-0.2,0.3)$, $p(0)=(0.5,-0.4,0.3)$, step size $h=0.2$, final time $T=1$ (five steps). Compute the Euclidean norm of the global error in $(q(T),p(T))$ relative to the exact solution at time $T$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where result1 is the float from Test 1, result2 is the float from Test 2, and result3 is the float from Test 3.",
            "solution": "### Derivation of the Implicit Midpoint Variational Integrator\n\nThe objective is to derive a numerical one-step method $(q_k, p_k) \\mapsto (q_{k+1}, p_{k+1})$ for a mechanical system described by the Lagrangian $L(q, \\dot{q}) = \\frac{1}{2}\\dot{q}^T M \\dot{q} - V(q)$. The derivation begins with Hamilton's principle, which states that the physical trajectory of the system renders the action integral $S[q] = \\int_{t_0}^{t_1} L(q(t), \\dot{q}(t)) dt$ stationary.\n\n**1. Discrete Action**\nWe partition the time interval $[t_0, t_1]$ into $N$ subintervals of length $h$, such that $t_k = t_0 + kh$. The total action is the sum of actions over each subinterval, $S = \\sum_{k=0}^{N-1} \\int_{t_k}^{t_{k+1}} L(q, \\dot{q}) dt$. We construct a discrete action, $S_d$, by approximating the integral over each subinterval $[t_k, t_{k+1}]$ using the midpoint quadrature rule. This involves approximating the integrand $L(q(t), \\dot{q}(t))$ at the midpoint time $t_{k+1/2} = t_k + h/2$. We use central difference approximations for the configuration and velocity at this midpoint:\n$$\nq_{k+1/2} \\approx \\frac{q_k + q_{k+1}}{2}\n$$\n$$\n\\dot{q}_{k+1/2} \\approx \\frac{q_{k+1} - q_k}{h}\n$$\nwhere $q_k = q(t_k)$ and $q_{k+1} = q(t_{k+1})$. The action over the subinterval is then approximated by the discrete Lagrangian, $L_d$:\n$$\n\\int_{t_k}^{t_{k+1}} L(q, \\dot{q}) dt \\approx L_d(q_k, q_{k+1}) = h L\\left(\\frac{q_k + q_{k+1}}{2}, \\frac{q_{k+1} - q_k}{h}\\right)\n$$\nThe total discrete action over the entire path $\\{q_k\\}_{k=0}^N$ is the sum:\n$$\nS_d(\\{q_k\\}) = \\sum_{k=0}^{N-1} L_d(q_k, q_{k+1})\n$$\n\n**2. Discrete Euler-Lagrange Equations**\nThe discrete version of Hamilton's principle requires that the discrete action be stationary with respect to variations in the interior path points. That is, $\\delta S_d = 0$ for all variations $\\delta q_k$ such that the endpoints are fixed ($\\delta q_0 = \\delta q_N = 0$).\n\n$$\n\\delta S_d = \\delta \\sum_{k=0}^{N-1} L_d(q_k, q_{k+1}) = \\sum_{k=0}^{N-1} \\left( \\frac{\\partial L_d(q_k, q_{k+1})}{\\partial q_k} \\delta q_k + \\frac{\\partial L_d(q_k, q_{k+1})}{\\partial q_{k+1}} \\delta q_{k+1} \\right) = 0\n$$\nUsing the notation $D_1 L_d$ and $D_2 L_d$ for the partial derivatives with respect to the first and second arguments, we have:\n$$\n\\sum_{k=0}^{N-1} \\left( D_1 L_d(q_k, q_{k+1}) \\cdot \\delta q_k + D_2 L_d(q_k, q_{k+1}) \\cdot \\delta q_{k+1} \\right) = 0\n$$\nBy re-indexing the sum over $\\delta q_{k+1}$ and collecting terms for each $\\delta q_k$, we get:\n$$\n\\sum_{k=1}^{N-1} \\left( D_2 L_d(q_{k-1}, q_k) + D_1 L_d(q_k, q_{k+1}) \\right) \\cdot \\delta q_k = 0\n$$\nSince the variations $\\delta q_k$ are arbitrary for $k=1, \\dots, N-1$, the term in the parenthesis must be zero. This yields the **Discrete Euler-Lagrange (DEL) equations**:\n$$\nD_1 L_d(q_k, q_{k+1}) + D_2 L_d(q_{k-1}, q_k) = 0\n$$\nThis equation provides a relationship between three consecutive configurations $q_{k-1}, q_k, q_{k+1}$.\n\n**3. Discrete Momenta and the One-Step Method**\nTo formulate a one-step method, we define discrete momenta in a way that is consistent with the DEL equations. We define:\n$$\np_k := -D_1 L_d(q_k, q_{k+1})\n$$\n$$\np_{k+1} := D_2 L_d(q_k, q_{k+1})\n$$\nSubstituting these definitions into the DEL equation gives $D_1 L_d(q_k, q_{k+1}) + D_2 L_d(q_{k-1}, q_k) = -p_k + p_k = 0$, which is satisfied identically. The pair of equations for $p_k$ and $p_{k+1}$ defines the integrator. Let's compute the derivatives for our specific Lagrangian $L(q,\\dot{q}) = \\frac{1}{2}\\dot{q}^T M \\dot{q} - V(q)$:\n$$\nL_d(q_k, q_{k+1}) = h \\left[ \\frac{1}{2} \\left(\\frac{q_{k+1}-q_k}{h}\\right)^T M \\left(\\frac{q_{k+1}-q_k}{h}\\right) - V\\left(\\frac{q_k+q_{k+1}}{2}\\right) \\right]\n$$\nThe partial derivatives are (using vector calculus identities and symmetry of $M$):\n$$\nD_1 L_d(q_k, q_{k+1}) = h \\left[ -\\frac{1}{h^2} M(q_{k+1}-q_k) - \\frac{1}{2}\\nabla V\\left(\\frac{q_k+q_{k+1}}{2}\\right) \\right]\n$$\n$$\nD_2 L_d(q_k, q_{k+1}) = h \\left[ \\frac{1}{h^2} M(q_{k+1}-q_k) - \\frac{1}{2}\\nabla V\\left(\\frac{q_k+q_{k+1}}{2}\\right) \\right]\n$$\nSubstituting these into the momentum definitions:\n$$\np_k = -D_1 L_d = \\frac{1}{h}M(q_{k+1}-q_k) + \\frac{h}{2}\\nabla V\\left(\\frac{q_k+q_{k+1}}{2}\\right)\n$$\n$$\np_{k+1} = D_2 L_d = \\frac{1}{h}M(q_{k+1}-q_k) - \\frac{h}{2}\\nabla V\\left(\\frac{q_k+q_{k+1}}{2}\\right)\n$$\nThese two equations implicitly define the mapping $(q_k, p_k) \\mapsto (q_{k+1}, p_{k+1})$. To make them more suitable for implementation, we can manipulate them. Subtracting the second from the first gives $p_k - p_{k+1} = h \\nabla V(\\frac{q_k+q_{k+1}}{2})$, which rearranges to:\n$$\np_{k+1} = p_k - h \\nabla V\\left(\\frac{q_k+q_{k+1}}{2}\\right)\n$$\nAdding the two equations gives $p_k + p_{k+1} = \\frac{2}{h}M(q_{k+1}-q_k)$. Rearranging for $q_{k+1}$ gives:\n$$\nq_{k+1} = q_k + \\frac{h}{2} M^{-1} (p_k+p_{k+1})\n$$\nThese two coupled equations define the integrator, known as the implicit midpoint rule or Störmer-Verlet method. To implement it, we must solve for $(q_{k+1}, p_{k+1})$ given $(q_k, p_k)$. Substituting the expression for $p_{k+1}$ into the one for $q_{k+1}$ yields a single implicit equation for $q_{k+1}$:\n$$\nq_{k+1} = q_k + h M^{-1} p_k - \\frac{h^2}{2} M^{-1} \\nabla V\\left(\\frac{q_k+q_{k+1}}{2}\\right)\n$$\nThis nonlinear equation for $q_{k+1}$ can be written as $F(q_{k+1})=0$ and solved using a numerical root-finding algorithm, such as Newton's method. Once $q_{k+1}$ is found, $p_{k+1}$ is computed explicitly.\n\n### Analysis of the Method\n\n**Order of Accuracy**: The midpoint rule used to approximate the action integral is second-order accurate, meaning the error in $L_d$ is $O(h^3)$. The resulting discrete Euler-Lagrange equations approximate the continuous Euler-Lagrange equations to second-order accuracy. Consequently, the local truncation error of the numerical method is $O(h^3)$, which leads to a global error of $O(h^2)$. The method is second-order accurate, and the numerical convergence rate $r$ should be approximately $2$.\n\n**Symplecticity**: A key property of variational integrators is that they are symplectic. A map $\\Phi: (q, p) \\mapsto (q', p')$ is symplectic if it preserves the canonical symplectic 2-form, i.e., $dq' \\wedge dp' = dq \\wedge dp$. From the definitions of the discrete momenta, we have:\n$$\np_k \\cdot dq_k - p_{k+1} \\cdot dq_{k+1} = -D_1 L_d(q_k, q_{k+1}) \\cdot dq_k - D_2 L_d(q_k, q_{k+1}) \\cdot dq_{k+1} = -d L_d(q_k, q_{k+1})\n$$\nTaking the exterior derivative of this expression yields:\n$$\nd(p_k \\cdot dq_k - p_{k+1} \\cdot dq_{k+1}) = -d(d L_d(q_k, q_{k+1}))\n$$\nSince the exterior derivative of an exact form is zero ($d(d f) = 0$ for any function $f$), we have:\n$$\nd(p_k \\cdot dq_k) - d(p_{k+1} \\cdot dq_{k+1}) = 0\n$$\nNoting that $d(p \\cdot dq) = dp \\wedge dq$, this simplifies to $dp_k \\wedge dq_k = dp_{k+1} \\wedge dq_{k+1}$, which proves that the map is symplectic. This property ensures excellent long-term energy and momentum conservation behavior for Hamiltonian systems. The numerical test for symplecticity should show a defect matrix $D\\Phi^T J D\\Phi - J$ with a norm close to machine precision (plus any error from the finite-difference Jacobian approximation).\n\n### Implementation Plan\nThe numerical tests will be performed as follows:\n1.  **Accuracy Rate**: The scalar harmonic oscillator will be integrated with two different step sizes. The exact solution $q(t) = \\cos(\\sqrt{1.5}t)$, $p(t) = -2\\sqrt{1.5}\\sin(\\sqrt{1.5}t)$ will be used to compute the global error at $T=1$. The convergence rate will be calculated from these errors.\n2.  **Symplecticity Residual**: For the coupled oscillator, the one-step map $\\Phi(q,p)$ will be defined. Its Jacobian $D\\Phi$ will be approximated numerically using central differences. The symplecticity defect matrix $D\\Phi^T J D\\Phi - J$ will be computed, and its Frobenius norm reported. This norm is expected to be very small.\n3.  **Free Particle Exactness**: For this case, $\\nabla V(q) = 0$. The integrator simplifies to $p_{k+1}=p_k$ and $q_{k+1}=q_k+hM^{-1}p_k$. The analytic solution is $p(t)=p_0$ and $q(t)=q_0+tM^{-1}p_0$. The numerical method exactly reproduces the trajectory at the discrete time steps. The error at $T=1$ is expected to be zero, up to floating-point roundoff error.",
            "answer": "```python\nimport numpy as np\nfrom numpy.linalg import inv, norm\nfrom scipy.optimize import root\n\ndef implicit_midpoint_step(q_k, p_k, h, M, grad_V, M_inv=None):\n    \"\"\"\n    Performs one step of the implicit midpoint variational integrator.\n    \n    Args:\n        q_k (np.ndarray): Current position vector.\n        p_k (np.ndarray): Current momentum vector.\n        h (float): Time step size.\n        M (np.ndarray): Mass matrix.\n        grad_V (callable): Gradient of the potential energy V(q).\n        M_inv (np.ndarray, optional): Pre-computed inverse of the mass matrix.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: The next position and momentum (q_{k+1}, p_{k+1}).\n    \"\"\"\n    if M_inv is None:\n        M_inv = inv(M)\n    \n    # Define the implicit equation F(q_{k+1}) = 0 to be solved.\n    def F(q_next):\n        q_mid = (q_k + q_next) / 2\n        return q_next - q_k - h * (M_inv @ p_k) + (h**2 / 2) * (M_inv @ grad_V(q_mid))\n\n    # Provide an initial guess for the root finder (explicit Euler step).\n    q_next_guess = q_k + h * (M_inv @ p_k)\n\n    # Solve for q_{k+1} using scipy's root finder.\n    sol = root(F, q_next_guess, method='hybr', tol=1e-12)\n    if not sol.success:\n        raise RuntimeError(f\"Root-finding failed to converge: {sol.message}\")\n    q_next = sol.x\n\n    # Explicitly calculate p_{k+1} using the found q_{k+1}.\n    q_mid = (q_k + q_next) / 2\n    p_next = p_k - h * grad_V(q_mid)\n\n    return q_next, p_next\n\ndef solve_case1():\n    \"\"\"Scalar harmonic oscillator accuracy rate.\"\"\"\n    M = np.array([[2.0]])\n    V = lambda q: 0.5 * 3.0 * q**2\n    grad_V = lambda q: 3.0 * q\n    q0 = np.array([1.0])\n    p0 = np.array([0.0])\n    T = 1.0\n\n    omega = np.sqrt(3.0 / 2.0)\n    q_exact_T = np.array([np.cos(omega * T)])\n    p_exact_T = np.array([-2.0 * omega * np.sin(omega * T)])\n    z_exact_T = np.concatenate([q_exact_T, p_exact_T])\n\n    errors = []\n    step_sizes = [0.1, 0.05]\n    \n    for h in step_sizes:\n        q, p = q0.copy(), p0.copy()\n        num_steps = int(round(T / h))\n        for _ in range(num_steps):\n            q, p = implicit_midpoint_step(q, p, h, M, grad_V)\n        \n        z_num = np.concatenate([q, p])\n        error = norm(z_num - z_exact_T)\n        errors.append(error)\n        \n    e_h1, e_h2 = errors[0], errors[1]\n    h1, h2 = step_sizes[0], step_sizes[1]\n    \n    rate = np.log(e_h2 / e_h1) / np.log(h2 / h1)\n    return rate\n\ndef solve_case2():\n    \"\"\"Two-dimensional coupled oscillator symplecticity residual.\"\"\"\n    n = 2\n    M = np.array([[2.0, 0.5], [0.5, 1.5]])\n    K = np.array([[4.0, 1.0], [1.0, 3.0]])\n    grad_V = lambda q: K @ q\n    \n    q_k = np.array([0.3, -0.2])\n    p_k = np.array([0.4, 0.5])\n    h = 0.1\n    \n    z_k = np.concatenate([q_k, p_k])\n    dim = 2 * n\n    M_inv = inv(M)\n    \n    def one_step_map(z):\n        q = z[:n]\n        p = z[n:]\n        q_next, p_next = implicit_midpoint_step(q, p, h, M, grad_V, M_inv)\n        return np.concatenate([q_next, p_next])\n\n    # Compute numerical Jacobian DPhi using central differences\n    DPhi = np.zeros((dim, dim))\n    eps = 1e-7\n    for j in range(dim):\n        ej = np.zeros(dim)\n        ej[j] = 1.0\n        z_plus = z_k + eps * ej\n        z_minus = z_k - eps * ej\n        \n        phi_plus = one_step_map(z_plus)\n        phi_minus = one_step_map(z_minus)\n        \n        DPhi[:, j] = (phi_plus - phi_minus) / (2 * eps)\n\n    # Construct the canonical symplectic matrix J\n    I = np.eye(n)\n    O = np.zeros((n, n))\n    J = np.block([[O, I], [-I, O]])\n    \n    # Compute the symplecticity defect and its Frobenius norm\n    defect = DPhi.T @ J @ DPhi - J\n    return norm(defect, 'fro')\n\ndef solve_case3():\n    \"\"\"Free particle exactness check.\"\"\"\n    M = np.diag([1.0, 2.0, 3.0])\n    grad_V = lambda q: np.zeros_like(q)\n    q0 = np.array([0.1, -0.2, 0.3])\n    p0 = np.array([0.5, -0.4, 0.3])\n    h = 0.2\n    T = 1.0\n\n    M_inv = inv(M)\n    \n    # Exact solution at T\n    q_exact_T = q0 + T * (M_inv @ p0)\n    p_exact_T = p0\n    z_exact_T = np.concatenate([q_exact_T, p_exact_T])\n    \n    # Numerical integration\n    q, p = q0.copy(), p0.copy()\n    num_steps = int(round(T / h))\n    for _ in range(num_steps):\n        q, p = implicit_midpoint_step(q, p, h, M, grad_V, M_inv)\n    \n    z_num = np.concatenate([q, p])\n    \n    # Global error norm\n    return norm(z_num - z_exact_T)\n\ndef solve():\n    \"\"\"\n    Solves all test cases and prints the results in the required format.\n    \"\"\"\n    result1 = solve_case1()\n    result2 = solve_case2()\n    result3 = solve_case3()\n    \n    results = [result1, result2, result3]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}