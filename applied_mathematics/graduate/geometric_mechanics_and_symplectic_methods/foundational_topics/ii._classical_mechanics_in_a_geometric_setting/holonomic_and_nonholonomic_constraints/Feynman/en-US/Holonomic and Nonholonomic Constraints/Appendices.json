{
    "hands_on_practices": [
        {
            "introduction": "The Gotay–Nester–Hinds (GNH) algorithm provides a rigorous and systematic procedure for handling constrained Hamiltonian systems. By iteratively generating new constraint submanifolds to ensure consistency, it reveals the true phase space where the dynamics unfolds. This exercise  offers a concrete application of the algorithm to a simple holonomic system, transforming an abstract sequence of steps into a clear, tangible calculation and showing how secondary constraints arise naturally.",
            "id": "3746589",
            "problem": "Consider the cotangent bundle $T^{\\ast}\\mathbb{R}^{2}$ with canonical coordinates $(q,p)$, where $q=(q_{1},q_{2})\\in \\mathbb{R}^{2}$ and $p=(p_{1},p_{2})\\in \\mathbb{R}^{2}$. Let the canonical symplectic form be $\\omega=\\sum_{i=1}^{2}dq_{i}\\wedge dp_{i}$. Consider the Hamiltonian $H:T^{\\ast}\\mathbb{R}^{2}\\to \\mathbb{R}$ given by\n$$\nH(q,p)=\\frac{1}{2m}\\,p\\cdot p+\\frac{k}{2}\\,q\\cdot q,\n$$\nwith $m>0$ and $k\\ge 0$ constants, where $p\\cdot p=p_{1}^{2}+p_{2}^{2}$ and $q\\cdot q=q_{1}^{2}+q_{2}^{2}$. Impose the holonomic constraint\n$$\n\\phi(q)=q\\cdot q-R^{2}=0,\n$$\nwith $R>0$ constant, interpreted as restricting the configuration to the circle of radius $R$.\n\nUsing the Gotay–Nester–Hinds (GNH) algorithm, treat the constrained Hamiltonian system on the primary constraint manifold $M_{0}=\\{(q,p)\\in T^{\\ast}\\mathbb{R}^{2}\\mid \\phi(q)=0\\}$ as a presymplectic system with the pulled-back two-form and restricted Hamiltonian. Determine successively the constraint manifolds $M_{k}$ until the algorithm stabilizes, and derive the final constrained dynamics as a vector field $X$ tangent to the final constraint manifold, obtained from the intrinsic equation $\\iota_{X}\\omega_{k}=dH_{k}$ at the stabilized stage.\n\nConcretely, work out all intermediate consistency conditions implied by the GNH algorithm, identify the stage at which the presymplectic form becomes nondegenerate, and compute the resulting constrained equations of motion in the form\n$$\n\\dot{q}=\\frac{1}{m}\\,p,\\qquad \\dot{p}=-k\\,q+\\lambda(q,p)\\,q,\n$$\non the final constraint manifold, for a unique scalar function $\\lambda(q,p)$ determined by the algorithm. Express $\\lambda(q,p)$ explicitly in terms of $q$, $p$, $m$, $k$, and $R$.\n\nAnswer specification: provide only the final analytic expression for $\\lambda(q,p)$, simplified. No numerical evaluation is required.",
            "solution": "We start from the canonical symplectic manifold $(T^{\\ast}\\mathbb{R}^{2},\\omega)$ with $\\omega=\\sum_{i=1}^{2}dq_{i}\\wedge dp_{i}$ and Hamiltonian $H(q,p)=\\frac{1}{2m}\\,p\\cdot p+\\frac{k}{2}\\,q\\cdot q$. Impose the holonomic constraint $\\phi(q)=q\\cdot q-R^{2}=0$, and consider the primary constraint manifold\n$$\nM_{0}=\\{(q,p)\\in T^{\\ast}\\mathbb{R}^{2}\\mid \\phi(q)=0\\}.\n$$\nThe Gotay–Nester–Hinds (GNH) algorithm treats the restricted system $(M_{0},\\omega_{0},H_{0})$, where $\\omega_{0}=i_{0}^{\\ast}\\omega$ and $H_{0}=H|_{M_{0}}$, with $i_{0}:M_{0}\\hookrightarrow T^{\\ast}\\mathbb{R}^{2}$ the inclusion. A vector field $X$ tangent to $M_{0}$ is a solution if it satisfies the presymplectic equation\n$$\n\\iota_{X}\\omega_{0}=dH_{0}.\n$$\nBecause $\\omega_{0}$ can be degenerate, existence of solutions requires that $dH_{0}$ annihilates the kernel of $\\omega_{0}$.\n\nStep 1: Compute the kernel of $\\omega_{0}$. A tangent vector $(\\delta q,\\delta p)$ at $(q,p)\\in M_{0}$ satisfies the tangency condition $d\\phi(q)\\cdot \\delta q=2\\,q\\cdot \\delta q=0$, i.e., $\\delta q$ is orthogonal to $q$. The restriction of $\\omega$ is given by $\\omega((\\delta q,\\delta p),(\\eta_{q},\\eta_{p}))=\\delta q\\cdot \\eta_{p}-\\eta_{q}\\cdot \\delta p$. For $(\\delta q,\\delta p)$ to lie in the kernel of $\\omega_{0}$, we require\n$$\n\\omega((\\delta q,\\delta p),(\\eta_{q},\\eta_{p}))=0\\quad \\text{for all }(\\eta_{q},\\eta_{p})\\text{ tangent to }M_{0}.\n$$\nTaking $\\eta_{p}$ arbitrary forces $\\delta q=0$. With $\\delta q=0$, the condition reduces to $-\\eta_{q}\\cdot \\delta p=0$ for all $\\eta_{q}$ orthogonal to $q$. This implies that $\\delta p$ must be parallel to $q$. Therefore,\n$$\n\\ker(\\omega_{0})=\\{(0,\\alpha\\,q)\\mid \\alpha\\in \\mathbb{R}\\}.\n$$\n\nStep 2: Consistency condition and the secondary constraint. Existence of a solution requires that $dH_{0}$ annihilates $\\ker(\\omega_{0})$. For $Z=(0,\\alpha q)\\in \\ker(\\omega_{0})$,\n$$\ndH_{0}(Z)=\\frac{\\partial H}{\\partial p}(q,p)\\cdot \\alpha q=\\left(\\frac{1}{m}\\,p\\right)\\cdot \\alpha q=\\frac{\\alpha}{m}\\,p\\cdot q.\n$$\nTo have $dH_{0}(Z)=0$ for all $\\alpha$, we must impose the secondary constraint\n$$\n\\psi(q,p)=q\\cdot p=0.\n$$\nDefine\n$$\nM_{1}=\\{(q,p)\\in M_{0}\\mid \\psi(q,p)=0\\}=\\{(q,p)\\in T^{\\ast}\\mathbb{R}^{2}\\mid q\\cdot q=R^{2},\\ q\\cdot p=0\\}.\n$$\n\nStep 3: Kernel of $\\omega$ restricted to $M_{1}$ and termination. We compute $\\ker(\\omega_{1})$ where $\\omega_{1}=i_{1}^{\\ast}\\omega_{0}$ and $i_{1}:M_{1}\\hookrightarrow M_{0}$. Tangent vectors $(\\delta q,\\delta p)$ to $M_{1}$ satisfy both $q\\cdot \\delta q=0$ and $\\delta(q\\cdot p)=\\delta q\\cdot p+q\\cdot \\delta p=0$. For a vector $(0,\\alpha q)$ to be tangent to $M_{1}$, the second condition requires $q\\cdot (\\alpha q)=\\alpha\\,q\\cdot q=\\alpha R^{2}=0$, hence $\\alpha=0$. Therefore, the only vector in $\\ker(\\omega_{1})$ is the zero vector, and $\\omega_{1}$ is nondegenerate on $M_{1}$. The GNH algorithm thus stabilizes at $M_{1}$ with no further constraints, since the presymplectic form has become symplectic.\n\nStep 4: Solve for the constrained dynamics on $M_{1}$. On the ambient space $T^{\\ast}\\mathbb{R}^{2}$, the Hamiltonian vector field satisfies\n$$\n\\dot{q}=\\frac{\\partial H}{\\partial p}=\\frac{1}{m}\\,p,\\qquad \\dot{p}=-\\frac{\\partial H}{\\partial q}=-k\\,q.\n$$\nOn $M_{0}$, solutions to $\\iota_{X}\\omega_{0}=dH_{0}$ are not unique due to $\\ker(\\omega_{0})$; we can add an arbitrary multiple of $(0,q)$ without changing $\\iota_{X}\\omega_{0}$. On $M_{1}$, however, uniqueness holds because $\\omega_{1}$ is nondegenerate. Hence, the constrained vector field on $M_{1}$ must be of the form\n$$\n\\dot{q}=\\frac{1}{m}\\,p,\\qquad \\dot{p}=-k\\,q+\\lambda(q,p)\\,q,\n$$\nfor a scalar function $\\lambda(q,p)$ chosen so that the flow is tangent to $M_{1}$.\n\nStep 5: Determine $\\lambda(q,p)$ from tangency. Tangency to $M_{1}$ requires preservation in time of both constraints. For $\\phi(q)=q\\cdot q-R^{2}=0$,\n$$\n\\frac{d}{dt}\\phi(q)=2\\,q\\cdot \\dot{q}=2\\,q\\cdot \\left(\\frac{1}{m}\\,p\\right)=\\frac{2}{m}\\,q\\cdot p=0,\n$$\nwhich holds identically on $M_{1}$ given $\\psi=0$. For $\\psi(q,p)=q\\cdot p=0$,\n$$\n\\frac{d}{dt}\\psi(q,p)=\\dot{q}\\cdot p+q\\cdot \\dot{p}=\\left(\\frac{1}{m}\\,p\\right)\\cdot p+q\\cdot \\left(-k\\,q+\\lambda(q,p)\\,q\\right)=\\frac{1}{m}\\,p\\cdot p+(-k+\\lambda(q,p))\\,q\\cdot q.\n$$\nOn $M_{1}$, $q\\cdot q=R^{2}$. Therefore the tangency condition $\\frac{d}{dt}\\psi=0$ yields\n$$\n0=\\frac{1}{m}\\,p\\cdot p+(-k+\\lambda(q,p))\\,R^{2},\n$$\nwhich solves uniquely for\n$$\n\\lambda(q,p)=k-\\frac{p\\cdot p}{m\\,R^{2}}.\n$$\n\nConclusion: The GNH algorithm produces $M_{0}=\\{q\\cdot q=R^{2}\\}$, then $M_{1}=\\{q\\cdot q=R^{2},\\ q\\cdot p=0\\}$, at which $\\omega$ becomes nondegenerate. The constrained dynamics on $M_{1}$ is\n$$\n\\dot{q}=\\frac{1}{m}\\,p,\\qquad \\dot{p}=-k\\,q+\\left(k-\\frac{p\\cdot p}{m\\,R^{2}}\\right)q,\n$$\nand the sought scalar function is $\\lambda(q,p)=k-\\frac{p\\cdot p}{m\\,R^{2}}$.",
            "answer": "$$\\boxed{k-\\frac{p\\cdot p}{m R^{2}}}$$"
        },
        {
            "introduction": "Shifting from the Hamiltonian to the geometric Lagrangian perspective, we can understand nonholonomic constraints through the lens of Riemannian geometry. This practice  involves deriving the reaction forces required to maintain a nonholonomic constraint not through multipliers, but by using tools like the Levi-Civita connection and orthogonal projections. This approach provides a powerful, coordinate-invariant insight into how the geometry of the configuration space dictates the dynamics.",
            "id": "3746625",
            "problem": "Consider a mechanical system with configuration manifold $Q=\\mathbb{R}^{3}$, global Cartesian coordinates $(x,y,z)$, and kinetic energy $T=\\frac{1}{2}m\\left(\\dot{x}^{2}+\\dot{y}^{2}+\\dot{z}^{2}\\right)$, where $m>0$ is a constant mass. The kinetic energy induces a Riemannian metric $g$ with components $g_{ij}=m\\,\\delta_{ij}$ and inverse $g^{ij}=\\frac{1}{m}\\,\\delta^{ij}$. Impose the nonholonomic velocity constraint given by the one-form $\\alpha=\\mathrm{d}z-x\\,\\mathrm{d}y$, so that the admissible distribution is $D=\\ker\\alpha=\\{v\\in TQ\\mid \\alpha(v)=0\\}$. Assume free motion (no external body forces), and require that the constraint $\\alpha(\\dot{q})=0$ holds for all times, where $\\dot{q}=(\\dot{x},\\dot{y},\\dot{z})$.\n\nStarting from first principles of Riemannian geometry and mechanics (Levi–Civita connection of $g$, covariant differentiation of tensor fields, and projection by $g$-orthogonality), perform the following:\n\n- Construct the $g$-orthogonal projector $P_{D}:TQ\\to D$ at a generic point $(x,y,z)$ in terms of $\\alpha$ and $g$, and use it to define the constrained connection $\\nabla^{\\mathrm{nh}}$ on $D$ by $\\nabla^{\\mathrm{nh}}_{Y}Z=P_{D}\\left(\\nabla_{Y}Z\\right)$ for $D$-valued vector fields $Y,Z$, where $\\nabla$ is the Levi–Civita connection of $g$.\n- Write the covariant form of the nonholonomic equations of motion enforcing $\\alpha(\\dot{q})=0$ and $\\nabla^{\\mathrm{nh}}_{\\dot{q}}\\dot{q}$ being $g$-orthogonal to $D^{\\perp}$, allowing for reaction terms that lie in $D^{\\perp}$.\n- Using the above, compute the explicit reaction acceleration vector $R(q,\\dot{q})$ that must appear in the equation $\\nabla_{\\dot{q}}\\dot{q}=R(q,\\dot{q})$ to preserve the constraint, where $\\nabla$ is the Levi–Civita connection of $g$.\n\nYour final answer must be a single closed-form analytic expression for the reaction acceleration $R(q,\\dot{q})$ written as a row vector in terms of $x$, $\\dot{x}$, $\\dot{y}$, and $\\dot{z}$. Express the final answer exactly (no rounding).",
            "solution": "The mechanical system is defined on the configuration manifold $Q=\\mathbb{R}^{3}$ with global Cartesian coordinates $q=(x,y,z)$. The kinetic energy $T=\\frac{1}{2}m(\\dot{x}^{2}+\\dot{y}^{2}+\\dot{z}^{2})$ induces a Riemannian metric $g$ whose components in this coordinate system are constant, $g_{ij}=m\\,\\delta_{ij}$. The inverse metric has components $g^{ij}=\\frac{1}{m}\\,\\delta^{ij}$.\n\nFirst, we analyze the geometric objects involved.\nThe nonholonomic constraint is given by the one-form $\\alpha=\\mathrm{d}z-x\\,\\mathrm{d}y$. In the coordinate basis $(\\mathrm{d}x, \\mathrm{d}y, \\mathrm{d}z)$, its components are $\\alpha_x=0$, $\\alpha_y=-x$, and $\\alpha_z=1$. The constraint on the velocity vector $\\dot{q}=(\\dot{x},\\dot{y},\\dot{z})$ is $\\alpha(\\dot{q})=0$, which explicitly reads $\\dot{z}-x\\dot{y}=0$.\n\nThe set of admissible velocities at each point $q \\in Q$ forms a $2$-dimensional linear subspace $D_q \\subset T_qQ$, called the constraint distribution. $D = \\ker\\alpha$.\nThe metric $g$ defines an orthogonal complement $D^{\\perp}$ to $D$. This subspace is spanned by the vector field $\\alpha^{\\sharp}$ which is $g$-dual to $\\alpha$. The components $(\\alpha^{\\sharp})^i$ are found by raising the index of $\\alpha_j$ with the inverse metric: $(\\alpha^{\\sharp})^i = g^{ij}\\alpha_j$.\n$$(\\alpha^{\\sharp})^x = g^{xx}\\alpha_x + g^{xy}\\alpha_y + g^{xz}\\alpha_z = \\frac{1}{m}(0) = 0$$\n$$(\\alpha^{\\sharp})^y = g^{yx}\\alpha_x + g^{yy}\\alpha_y + g^{yz}\\alpha_z = \\frac{1}{m}(-x) = -\\frac{x}{m}$$\n$$(\\alpha^{\\sharp})^z = g^{zx}\\alpha_x + g^{zy}\\alpha_y + g^{zz}\\alpha_z = \\frac{1}{m}(1) = \\frac{1}{m}$$\nIn the coordinate basis $(\\partial_x, \\partial_y, \\partial_z)$, the vector field spanning $D^{\\perp}$ is $\\alpha^{\\sharp} = -\\frac{x}{m}\\partial_y + \\frac{1}{m}\\partial_z$.\n\nThe problem asks to construct the $g$-orthogonal projector $P_D: TQ \\to D$. It is simpler to first construct the projector $P_{D^{\\perp}}: TQ \\to D^{\\perp}$ and then define $P_D = \\mathrm{Id} - P_{D^{\\perp}}$. For any vector field $V$, its projection onto the subspace spanned by $\\alpha^{\\sharp}$ is given by:\n$$P_{D^{\\perp}}(V) = \\frac{g(V, \\alpha^{\\sharp})}{g(\\alpha^{\\sharp}, \\alpha^{\\sharp})} \\alpha^{\\sharp}$$\nThe terms in this expression can be written in terms of $\\alpha$ and $g^{-1}$: $g(V, \\alpha^{\\sharp}) = g(V, g^{-1}(\\alpha, \\cdot)) = \\alpha(V)$ and $g(\\alpha^{\\sharp}, \\alpha^{\\sharp}) = g(g^{-1}(\\alpha, \\cdot), g^{-1}(\\alpha, \\cdot)) = g^{-1}(\\alpha, \\alpha)$. Let's calculate the denominator:\n$$g^{-1}(\\alpha, \\alpha) = g^{ij}\\alpha_i\\alpha_j = \\frac{1}{m}(0^2 + (-x)^2 + 1^2) = \\frac{x^2+1}{m}$$\nThus, the projector onto $D^{\\perp}$ is $P_{D^{\\perp}}(V) = \\frac{\\alpha(V)}{(x^2+1)/m} \\alpha^{\\sharp}$.\nThe projector onto $D$ is $P_D(V) = V - P_{D^{\\perp}}(V) = V - \\frac{m\\,\\alpha(V)}{x^2+1}\\alpha^{\\sharp}$.\n\nThe constrained connection is defined as $\\nabla^{\\mathrm{nh}}_{Y}Z=P_{D}(\\nabla_{Y}Z)$ for vector fields $Y,Z$ with values in $D$. The nonholonomic equations of motion for a free particle are the nonholonomic geodesic equations, which state that the component of the acceleration tangent to the constraint distribution must be zero. This is expressed as $\\nabla^{\\mathrm{nh}}_{\\dot{q}}\\dot{q}=0$, which is equivalent to $P_D(\\nabla_{\\dot{q}}\\dot{q})=0$. This implies that the acceleration vector $\\nabla_{\\dot{q}}\\dot{q}$ must be orthogonal to the distribution $D$, i.e., $\\nabla_{\\dot{q}}\\dot{q} \\in D^{\\perp}$.\nThe reaction acceleration $R(q,\\dot{q})$ is precisely this required acceleration vector: $R(q,\\dot{q}) = \\nabla_{\\dot{q}}\\dot{q}$. Therefore, we must have $R(q,\\dot{q}) \\in D^{\\perp}$.\n\nThe Levi-Civita connection $\\nabla$ for the metric $g_{ij}=m\\,\\delta_{ij}$ is simple. The Christoffel symbols $\\Gamma^k_{ij} = \\frac{1}{2}g^{kl}(\\partial_i g_{jl} + \\partial_j g_{il} - \\partial_l g_{ij})$ are all zero because the metric components are constant.\nThe covariant derivative of the velocity vector $\\dot{q}$ along the curve $q(t)$ is given by $(\\nabla_{\\dot{q}}\\dot{q})^k = \\frac{d\\dot{q}^k}{dt} + \\Gamma^k_{ij}\\dot{q}^i\\dot{q}^j$. Since $\\Gamma^k_{ij}=0$, this simplifies to $(\\nabla_{\\dot{q}}\\dot{q})^k = \\ddot{q}^k$.\nSo, the reaction acceleration is the standard acceleration vector $R = \\ddot{q} = (\\ddot{x},\\ddot{y},\\ddot{z})$.\n\nSince $R \\in D^{\\perp}$, it must be proportional to $\\alpha^{\\sharp}$:\n$$R = \\lambda \\alpha^{\\sharp}$$\nfor some scalar function $\\lambda = \\lambda(q, \\dot{q})$. In components, this is:\n$$(\\ddot{x}, \\ddot{y}, \\ddot{z}) = \\lambda \\left(0, -\\frac{x}{m}, \\frac{1}{m}\\right)$$\nThis component-wise equality gives us three equations:\n1) $\\ddot{x} = 0$\n2) $\\ddot{y} = -\\frac{\\lambda x}{m}$\n3) $\\ddot{z} = \\frac{\\lambda}{m}$\n\nTo find $\\lambda$, we must enforce that the velocity vector $\\dot{q}$ remains in the distribution $D$ for all time. This means the constraint equation $\\alpha(\\dot{q})=0$ must hold for all $t$, which implies its total time derivative must be zero:\n$$\\frac{d}{dt}(\\alpha(\\dot{q})) = 0 \\implies \\frac{d}{dt}(\\dot{z} - x\\dot{y}) = 0$$\nUsing the product rule, we get:\n$$\\ddot{z} - \\dot{x}\\dot{y} - x\\ddot{y} = 0$$\nNow we substitute the expressions for $\\ddot{y}$ and $\\ddot{z}$ from equations $2)$ and $3)$ into this condition:\n$$\\left(\\frac{\\lambda}{m}\\right) - \\dot{x}\\dot{y} - x\\left(-\\frac{\\lambda x}{m}\\right) = 0$$\n$$\\frac{\\lambda}{m} - \\dot{x}\\dot{y} + \\frac{\\lambda x^2}{m} = 0$$\nFactoring out $\\lambda/m$:\n$$\\frac{\\lambda}{m}(1+x^2) = \\dot{x}\\dot{y}$$\nSolving for $\\lambda$:\n$$\\lambda = \\frac{m\\dot{x}\\dot{y}}{x^2+1}$$\nThis determines the magnitude of the reaction acceleration. Now we can find the components of $R$ by substituting this expression for $\\lambda$ back into equations $1)$, $2)$, and $3)$:\n$$R_x = \\ddot{x} = 0$$\n$$R_y = \\ddot{y} = -\\frac{\\lambda x}{m} = -\\left(\\frac{m\\dot{x}\\dot{y}}{x^2+1}\\right)\\frac{x}{m} = -\\frac{x\\dot{x}\\dot{y}}{x^2+1}$$\n$$R_z = \\ddot{z} = \\frac{\\lambda}{m} = \\left(\\frac{m\\dot{x}\\dot{y}}{x^2+1}\\right)\\frac{1}{m} = \\frac{\\dot{x}\\dot{y}}{x^2+1}$$\nThe reaction acceleration vector is thus $R(q,\\dot{q}) = \\left(0, -\\frac{x\\dot{x}\\dot{y}}{x^2+1}, \\frac{\\dot{x}\\dot{y}}{x^2+1}\\right)$. Note that this expression depends on $x$, $\\dot{x}$, and $\\dot{y}$. While the constraint $\\dot{z} = x\\dot{y}$ holds, the expression does not explicitly contain $\\dot{z}$, which is consistent with the instructions.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & -\\frac{x\\dot{x}\\dot{y}}{x^2+1} & \\frac{\\dot{x}\\dot{y}}{x^2+1}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Bridging theory with computational practice is essential for modern mechanics. This problem  delves into the numerical simulation of nonholonomic systems by comparing a direct, constrained variational integrator with an approximate penalty method. By implementing and analyzing these two approaches, you will gain hands-on experience with the practical challenges of enforcing constraints numerically and observe the convergence properties of common approximation schemes.",
            "id": "3746644",
            "problem": "Consider a mechanical system on the plane with configuration variables $q = (x,y,\\theta)$, where $(x,y)$ denotes the Cartesian position of the rigid body’s center of mass and $\\theta$ its orientation angle measured in radians. The Lagrangian is purely kinetic, defined by $L(q,\\dot{q}) = T(q,\\dot{q})$ with $T = \\frac{1}{2} m (\\dot{x}^{2} + \\dot{y}^{2}) + \\frac{1}{2} J \\dot{\\theta}^{2}$, where $m > 0$ is the mass and $J > 0$ is the scalar moment of inertia. The system is subject to a nonholonomic (non-integrable, velocity-dependent) linear constraint of Chaplygin sleigh type: the lateral velocity at the contact point is zero. In body coordinates, this is encoded by the Pfaffian one-form\n$$\nA(q)\\,\\dot{q} = -\\sin(\\theta)\\,\\dot{x} + \\cos(\\theta)\\,\\dot{y} + a\\,\\dot{\\theta} = 0,\n$$\nwhere $a > 0$ is the signed distance from the center of mass to the knife edge contact point along the longitudinal body axis.\n\nYou are to implement a discrete variational integrator and a penalty-based approximation for the nonholonomic constraint, both derived from the discrete action principle. Use the midpoint discrete Lagrangian\n$$\nL_{d}(q_{k},q_{k+1};h) = h\\,L\\!\\left(\\frac{q_{k}+q_{k+1}}{2},\\frac{q_{k+1}-q_{k}}{h}\\right),\n$$\nwhere $h > 0$ is the fixed time step. Define the discrete constraint function\n$$\n\\phi(q_{k},q_{k+1};h) = -\\sin\\!\\left(\\frac{\\theta_{k}+\\theta_{k+1}}{2}\\right)\\frac{x_{k+1}-x_{k}}{h} + \\cos\\!\\left(\\frac{\\theta_{k}+\\theta_{k+1}}{2}\\right)\\frac{y_{k+1}-y_{k}}{h} + a\\,\\frac{\\theta_{k+1}-\\theta_{k}}{h}.\n$$\nFor the penalty method, use the augmented discrete Lagrangian\n$$\n\\widetilde{L}_{d}(q_{k},q_{k+1};h,\\rho) = L_{d}(q_{k},q_{k+1};h) + \\frac{\\rho\\,h}{2}\\,\\phi(q_{k},q_{k+1};h)^{2},\n$$\nwhere $\\rho \\ge 0$ is the penalty parameter. The discrete trajectory is obtained by enforcing the discrete Euler–Lagrange stationarity condition for the total discrete action $\\sum_{k} \\widetilde{L}_{d}(q_{k},q_{k+1};h,\\rho)$:\n$$\nD_{2}\\widetilde{L}_{d}(q_{k-1},q_{k};h,\\rho) + D_{1}\\widetilde{L}_{d}(q_{k},q_{k+1};h,\\rho) = 0 \\quad \\text{for all } k,\n$$\nwhere $D_{i}$ denotes the partial derivative with respect to the $i$-th argument of $\\widetilde{L}_{d}$.\n\nFor the constrained discrete Lagrange–d’Alembert integrator (Discrete LdA), enforce the nonholonomic constraint via a discrete Lagrange multiplier $\\lambda_{k}$ and solve at each step the nonlinear system\n$$\nD_{2}L_{d}(q_{k-1},q_{k};h) + D_{1}L_{d}(q_{k},q_{k+1};h) + A(q_{k})^{\\top}\\lambda_{k} = 0,\n$$\n$$\n\\phi(q_{k},q_{k+1};h) = 0,\n$$\nwhere $A(q_{k}) = \\big[-\\sin(\\theta_{k}),\\,\\cos(\\theta_{k}),\\,a\\big]$ is the constraint covector evaluated at $q_{k}$ and $A(q_{k})^{\\top}\\lambda_{k}$ is the corresponding generalized discrete constraint force.\n\nUsing these principles only, implement a program that:\n- Constructs a constrained reference trajectory via the discrete Lagrange–d’Alembert method over $N$ steps with fixed step size $h$, given initial conditions $q_{0}$ and a first step $q_{1}$ obtained from a velocity consistent with the constraint.\n- Constructs penalized trajectories for the same initial conditions and $(h,N)$ using the penalty-augmented discrete Euler–Lagrange equations for various $\\rho$ values.\n- Computes, for each $\\rho$, a single float equal to the mean Euclidean distance between the penalized trajectory and the constrained trajectory across all time indices $k = 0,1,\\dots,N$, i.e.,\n$$\n\\mathrm{err}(\\rho) = \\frac{1}{N+1}\\sum_{k=0}^{N} \\left\\| q^{(\\rho)}_{k} - q^{\\mathrm{constr}}_{k} \\right\\|_{2}.\n$$\n\nAngle quantities must be in radians. There are no physical unit conversions required beyond the given definitions. Use parameters $(m,J,a) = (1.0,0.25,0.5)$ and the initial conditions $q_{0} = (0,0,0.3)$, and $q_{1} = q_{0} + h\\,(\\dot{x}_{0},\\dot{y}_{0},\\dot{\\theta}_{0})$ with $(\\dot{x}_{0},\\dot{y}_{0},\\dot{\\theta}_{0}) = (u\\cos(\\theta_{0}),u\\sin(\\theta_{0}),0)$ and $u = 1.0$. Use the five test cases:\n- Case 1 (baseline, no penalty): $(\\rho,h,N) = (0.0, 0.05, 50)$.\n- Case 2 (small penalty): $(\\rho,h,N) = (5.0, 0.05, 50)$.\n- Case 3 (moderate penalty): $(\\rho,h,N) = (20.0, 0.05, 50)$.\n- Case 4 (large penalty): $(\\rho,h,N) = (100.0, 0.05, 50)$.\n- Case 5 (large penalty with smaller step): $(\\rho,h,N) = (100.0, 0.02, 50)$.\n\nYour program should produce a single line of output containing the five errors as a comma-separated list enclosed in square brackets (e.g., \"[e1,e2,e3,e4,e5]\"). The values must be Python floats.\n\nThe goal is to demonstrate numerically that the penalized trajectories converge to the nonholonomic constrained trajectory as the penalty parameter increases, in the sense that $\\mathrm{err}(\\rho)$ decreases with larger $\\rho$ (and, typically, with smaller $h$).",
            "solution": "The problem requires the implementation and comparison of two numerical methods for a nonholonomic mechanical system. The first method is a constrained variational integrator based on the Lagrange-d'Alembert principle, which serves as the reference. The second is an unconstrained integrator for a penalty-augmented Lagrangian. Both methods are derived from a discrete action principle using a specified discrete Lagrangian.\n\nFirst, we define the midpoint discrete Lagrangian $L_d(q_k, q_{k+1}; h)$ by substituting the midpoint approximations for position and velocity into the continuous Lagrangian $L = \\frac{1}{2} m (\\dot{x}^2 + \\dot{y}^2) + \\frac{1}{2} J \\dot{\\theta}^2$.\nLet $q_k = (x_k, y_k, \\theta_k)$. The discrete velocities are $\\frac{q_{k+1}-q_k}{h}$.\n$$\nL_d(q_k, q_{k+1}; h) = h \\left[ \\frac{1}{2}m\\left( \\left(\\frac{x_{k+1}-x_k}{h}\\right)^2 + \\left(\\frac{y_{k+1}-y_k}{h}\\right)^2 \\right) + \\frac{1}{2}J\\left(\\frac{\\theta_{k+1}-\\theta_k}{h}\\right)^2 \\right]\n$$\n$$\nL_d(q_k, q_{k+1}; h) = \\frac{m}{2h}\\left((x_{k+1}-x_k)^2 + (y_{k+1}-y_k)^2\\right) + \\frac{J}{2h}(\\theta_{k+1}-\\theta_k)^2\n$$\nThe equations of motion for both methods are derived from the discrete Euler-Lagrange equations, which represent the stationarity of the discrete action sum. The general form is $\\frac{\\partial}{\\partial q_k} \\sum_j \\mathcal{L}_d(q_j, q_{j+1}) = 0$, which for a single step expands to $D_2\\mathcal{L}_d(q_{k-1}, q_k) + D_1\\mathcal{L}_d(q_k, q_{k+1}) = 0$, where $\\mathcal{L}_d$ is the relevant discrete Lagrangian for the method.\n\n**Method 1: Discrete Lagrange-d'Alembert (LdA) Integrator (Reference Trajectory)**\nThis method enforces the nonholonomic constraint exactly at each step using a Lagrange multiplier. The evolution is governed by a system of differential-algebraic equations, which in discrete form becomes a system of nonlinear algebraic equations to be solved for $(q_{k+1}, \\lambda_k)$ at each time step $k$. Given $q_{k-1}$ and $q_k$, we solve:\n$$\n\\begin{cases}\nD_2 L_d(q_{k-1}, q_k; h) + D_1 L_d(q_k, q_{k+1}; h) + A(q_k)^\\top \\lambda_k = 0 \\\\\n\\phi(q_k, q_{k+1}; h) = 0\n\\end{cases}\n$$\nThe derivatives of $L_d$ are:\n$D_1 L_d(q_k, q_{k+1}) = \\left[ \\frac{-m(x_{k+1}-x_k)}{h}, \\frac{-m(y_{k+1}-y_k)}{h}, \\frac{-J(\\theta_{k+1}-\\theta_k)}{h} \\right]^\\top$\n$D_2 L_d(q_{k-1}, q_k) = \\left[ \\frac{m(x_k-x_{k-1})}{h}, \\frac{m(y_k-y_{k-1})}{h}, \\frac{J(\\theta_k-\\theta_{k-1})}{h} \\right]^\\top$\nUsing the provided $A(q_k) = [-\\sin(\\theta_k), \\cos(\\theta_k), a]$, the system of equations for the unknowns $(x_{k+1}, y_{k+1}, \\theta_{k+1}, \\lambda_k)$ becomes (after multiplying the first three equations by $h$):\n1. $m(2x_k - x_{k-1} - x_{k+1}) - h\\lambda_k\\sin(\\theta_k) = 0$\n2. $m(2y_k - y_{k-1} - y_{k+1}) + h\\lambda_k\\cos(\\theta_k) = 0$\n3. $J(2\\theta_k - \\theta_{k-1} - \\theta_{k+1}) + h\\lambda_k a = 0$\n4. $-\\sin(\\frac{\\theta_k+\\theta_{k+1}}{2})\\frac{x_{k+1}-x_k}{h} + \\cos(\\frac{\\theta_k+\\theta_{k+1}}{2})\\frac{y_{k+1}-y_k}{h} + a\\frac{\\theta_{k+1}-\\theta_k}{h} = 0$\nThis is a system of $4$ nonlinear algebraic equations in $4$ variables which we solve at each step $k=1, \\dots, N-1$ using a numerical root-finding algorithm.\n\n**Method 2: Penalty Method Integrator**\nThis method approximates the constraint by adding a penalty term to the discrete Lagrangian. The augmented discrete Lagrangian is $\\widetilde{L}_d = L_d + \\frac{\\rho h}{2}\\phi^2$. The equations of motion are the standard discrete Euler-Lagrange equations for $\\widetilde{L}_d$:\n$D_2\\widetilde{L}_d(q_{k-1}, q_k; h, \\rho) + D_1\\widetilde{L}_d(q_k, q_{k+1}; h, \\rho) = 0$.\nThe derivatives are $D_i\\widetilde{L}_d = D_i L_d + \\rho h \\phi D_i \\phi$. The resulting system is a set of $3$ nonlinear equations for the $3$ components of $q_{k+1}$:\n$$\nF(q_{k+1}) = D_2 L_d(q_{k-1}, q_k) + \\rho h \\phi_{k-1,k} D_2\\phi(q_{k-1},q_k) + D_1 L_d(q_k, q_{k+1}) + \\rho h \\phi_{k,k+1} D_1\\phi(q_k,q_{k+1}) = 0\n$$\nwhere $\\phi_{i,j} = \\phi(q_i, q_j; h)$. This system for $q_{k+1}=(x_{k+1}, y_{k+1}, \\theta_{k+1})$ is solved at each step using a numerical root-finder. As $\\rho \\to \\infty$, the solution is expected to converge to the solution of the LdA method.\n\n**Numerical Implementation**\nFor both methods, we start with $q_0$ and $q_1$. For each subsequent step $k=1, \\dots, N-1$, we solve the corresponding nonlinear system for $q_{k+1}$ using `scipy.optimize.root`. A good initial guess for the iterative solver at step $k$ is the extrapolated value $q_{k+1}^{\\text{guess}} = q_k + (q_k - q_{k-1})$. For the LdA method, the initial guess for $\\lambda_k$ is set to $0$.\n\nAfter generating the constrained reference trajectory $q^{\\text{constr}}$ and the penalized trajectory $q^{(\\rho)}$ for each test case, we compute the error using the specified mean Euclidean distance formula.\nThe implementation computes the reference trajectory for a given $(h, N)$ pair only once and reuses it for different values of $\\rho$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    params = {'m': 1.0, 'J': 0.25, 'a': 0.5}\n    q0 = np.array([0.0, 0.0, 0.3])\n    u = 1.0\n    v0 = np.array([u * np.cos(q0[2]), u * np.sin(q0[2]), 0.0])\n\n    test_cases = [\n        # (rho, h, N)\n        (0.0, 0.05, 50),\n        (5.0, 0.05, 50),\n        (20.0, 0.05, 50),\n        (100.0, 0.05, 50),\n        (100.0, 0.02, 50),\n    ]\n\n    results = []\n    ref_trajectory_cache = {}\n\n    for rho, h, N in test_cases:\n        \n        # Calculate initial conditions based on h\n        q1 = q0 + h * v0\n\n        # Generate or retrieve reference trajectory\n        if (h, N) in ref_trajectory_cache:\n            q_constr = ref_trajectory_cache[(h, N)]\n        else:\n            q_constr = _generate_constrained_trajectory(h, N, q0, q1, params)\n            ref_trajectory_cache[(h, N)] = q_constr\n\n        # Generate penalized trajectory\n        q_penalized = _generate_penalized_trajectory(rho, h, N, q0, q1, params)\n\n        # Compute error\n        error = np.mean(np.linalg.norm(q_penalized - q_constr, axis=1))\n        results.append(error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _phi(q_k, q_kp1, h, a):\n    \"\"\"Discrete constraint function phi.\"\"\"\n    x_k, y_k, th_k = q_k\n    x_kp1, y_kp1, th_kp1 = q_kp1\n    th_mid = (th_k + th_kp1) / 2.0\n    val = -np.sin(th_mid) * (x_kp1 - x_k) / h\n    val += np.cos(th_mid) * (y_kp1 - y_k) / h\n    val += a * (th_kp1 - th_k) / h\n    return val\n\ndef _generate_constrained_trajectory(h, N, q0, q1, params):\n    \"\"\"Generates a trajectory using the Discrete Lagrange-d'Alembert method.\"\"\"\n    m, J, a = params['m'], params['J'], params['a']\n    \n    q_traj = np.zeros((N + 1, 3))\n    q_traj[0], q_traj[1] = q0, q1\n    \n    lambda_k_guess = 0.0\n\n    def lda_residual(z, q_k, q_km1):\n        x_kp1, y_kp1, th_kp1, lambda_k = z\n        x_k, y_k, th_k = q_k\n        x_km1, y_km1, th_km1 = q_km1\n\n        res = np.zeros(4)\n        res[0] = m * (2 * x_k - x_km1 - x_kp1) - h * lambda_k * np.sin(th_k)\n        res[1] = m * (2 * y_k - y_km1 - y_kp1) + h * lambda_k * np.cos(th_k)\n        res[2] = J * (2 * th_k - th_km1 - th_kp1) + h * lambda_k * a\n        res[3] = _phi(q_k, np.array([x_kp1, y_kp1, th_kp1]), h, a)\n        return res\n\n    for k in range(1, N):\n        q_k = q_traj[k]\n        q_km1 = q_traj[k - 1]\n        \n        # Initial guess for the root finder\n        q_kp1_guess = q_k + (q_k - q_km1)\n        z_guess = np.append(q_kp1_guess, lambda_k_guess)\n\n        sol = root(lda_residual, z_guess, args=(q_k, q_km1), method='hybr', tol=1e-9)\n        if not sol.success:\n            raise RuntimeError(f'LdA solver failed at step {k}')\n        \n        q_traj[k + 1] = sol.x[:3]\n        lambda_k_guess = sol.x[3] # Use as guess for next step\n        \n    return q_traj\n\ndef _generate_penalized_trajectory(rho, h, N, q0, q1, params):\n    \"\"\"Generates a trajectory using the penalty method.\"\"\"\n    m, J, a = params['m'], params['J'], params['a']\n\n    q_traj = np.zeros((N + 1, 3))\n    q_traj[0], q_traj[1] = q0, q1\n\n    if rho == 0.0: # Unconstrained case has an analytical update\n        for k in range(1, N):\n            q_traj[k + 1] = 2 * q_traj[k] - q_traj[k - 1]\n        return q_traj\n\n    def penalty_residual(q_kp1, q_k, q_km1):\n        x_k, y_k, th_k = q_k\n        x_km1, y_km1, th_km1 = q_km1\n        x_kp1, y_kp1, th_kp1 = q_kp1\n\n        # Terms related to L_d(q_{k-1}, q_k) and phi(q_{k-1}, q_k)\n        th_mid0 = (th_km1 + th_k) / 2.0\n        phi0 = _phi(q_km1, q_k, h, a)\n        d_phi0_d_thk = ( -0.5*np.cos(th_mid0)*((x_k-x_km1)/h) \n                        - 0.5*np.sin(th_mid0)*((y_k-y_km1)/h) + a/h )\n\n        # Terms related to L_d(q_k, q_{k+1}) and phi(q_k, q_{k+1})\n        th_mid1 = (th_k + th_kp1) / 2.0\n        phi1 = _phi(q_k, q_kp1, h, a)\n        d_phi1_d_thk = ( -0.5*np.cos(th_mid1)*((x_kp1-x_k)/h) \n                        - 0.5*np.sin(th_mid1)*((y_kp1-y_k)/h) - a/h )\n\n        # Discrete EL equations\n        res = np.zeros(3)\n        # x-equation\n        res[0] = m/h * (x_k - x_km1) + rho*h*phi0*(-np.sin(th_mid0)/h) + \\\n                 m/h * (x_k - x_kp1) + rho*h*phi1*(np.sin(th_mid1)/h)\n        # y-equation\n        res[1] = m/h * (y_k - y_km1) + rho*h*phi0*(np.cos(th_mid0)/h) + \\\n                 m/h * (y_k - y_kp1) + rho*h*phi1*(-np.cos(th_mid1)/h)\n        # theta-equation\n        res[2] = J/h * (th_k - th_km1) + rho*h*phi0*d_phi0_d_thk + \\\n                 J/h * (th_k - th_kp1) + rho*h*phi1*d_phi1_d_thk\n        return res\n        \n    for k in range(1, N):\n        q_k = q_traj[k]\n        q_km1 = q_traj[k-1]\n        \n        q_kp1_guess = q_k + (q_k - q_km1)\n\n        sol = root(penalty_residual, q_kp1_guess, args=(q_k, q_km1), method='hybr', tol=1e-9)\n        if not sol.success:\n            raise RuntimeError(f'Penalty solver failed at step {k} for rho={rho}')\n        \n        q_traj[k + 1] = sol.x\n\n    return q_traj\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}