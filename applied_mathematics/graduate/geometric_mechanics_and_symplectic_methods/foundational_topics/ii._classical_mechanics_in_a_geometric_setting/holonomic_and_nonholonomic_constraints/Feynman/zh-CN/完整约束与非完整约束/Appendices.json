{
    "hands_on_practices": [
        {
            "introduction": "非完整系统的运动可以被看作是在允许的速度构成的分布上的一种“测地线”运动。这个练习将帮助你巩固这一几何图像，即约束力被理解为将加速度矢量保持在允许方向内所必需的力。通过为经典的非完整接触问题（如刀刃约束）推导反应加速度，你将亲身体验黎曼几何的概念（如联络和投影）如何为动力学提供深刻的见解。",
            "id": "3746625",
            "problem": "考虑一个力学系统，其位形流形为 $Q=\\mathbb{R}^{3}$，全局笛卡尔坐标为 $(x,y,z)$，动能为 $T=\\frac{1}{2}m\\left(\\dot{x}^{2}+\\dot{y}^{2}+\\dot{z}^{2}\\right)$，其中 $m>0$ 是一个常数质量。该动能导出一个黎曼度量 $g$，其分量为 $g_{ij}=m\\,\\delta_{ij}$，逆度量分量为 $g^{ij}=\\frac{1}{m}\\,\\delta^{ij}$。施加由1-形式 $\\alpha=\\mathrm{d}z-x\\,\\mathrm{d}y$ 给出的非完整速度约束，因此容许分布为 $D=\\ker\\alpha=\\{v\\in TQ\\mid \\alpha(v)=0\\}$。假设系统作自由运动（无外部体力），并要求约束 $\\alpha(\\dot{q})=0$ 对所有时间都成立，其中 $\\dot{q}=(\\dot{x},\\dot{y},\\dot{z})$。\n\n从黎曼几何与力学的第一性原理出发（$g$ 的 Levi–Civita 联络、张量场的协变微分以及通过 $g$-正交性的投影），完成以下任务：\n\n- 在一般点 $(x,y,z)$ 处，用 $\\alpha$ 和 $g$ 构建 $g$-正交投影算子 $P_{D}:TQ\\to D$，并用它为取值于 $D$ 的向量场 $Y,Z$ 定义约束联络 $\\nabla^{\\mathrm{nh}}$，其定义为 $\\nabla^{\\mathrm{nh}}_{Y}Z=P_{D}\\left(\\nabla_{Y}Z\\right)$，其中 $\\nabla$ 是 $g$ 的 Levi–Civita 联络。\n- 写出非完整运动方程的协变形式，该形式强制要求 $\\alpha(\\dot{q})=0$ 且 $\\nabla^{\\mathrm{nh}}_{\\dot{q}}\\dot{q}$ 与 $D^{\\perp}$ $g$-正交，并允许反作用项存在于 $D^{\\perp}$ 中。\n- 使用以上结果，计算为保持约束而必须出现在方程 $\\nabla_{\\dot{q}}\\dot{q}=R(q,\\dot{q})$ 中的显式反作用加速度向量 $R(q,\\dot{q})$，其中 $\\nabla$ 是 $g$ 的 Levi–Civita 联络。\n\n你的最终答案必须是反作用加速度 $R(q,\\dot{q})$ 的一个单一闭式解析表达式，以行向量形式表示，并用 $x$、$\\dot{x}$、$\\dot{y}$ 和 $\\dot{z}$ 来表达。最终答案需为精确表达式（无四舍五入）。",
            "solution": "该问题是有效的，因为它是关于非完整系统的几何力学中一个定义明确的标准问题。它具有科学依据、自洽且客观。\n\n该力学系统定义在位形流形 $Q=\\mathbb{R}^{3}$ 上，全局笛卡尔坐标为 $q=(x,y,z)$。动能 $T=\\frac{1}{2}m(\\dot{x}^{2}+\\dot{y}^{2}+\\dot{z}^{2})$ 导出一个黎曼度量 $g$，其在此坐标系下的分量为常数，$g_{ij}=m\\,\\delta_{ij}$。逆度量的分量为 $g^{ij}=\\frac{1}{m}\\,\\delta^{ij}$。\n\n首先，我们分析所涉及的几何对象。\n非完整约束由1-形式 $\\alpha=\\mathrm{d}z-x\\,\\mathrm{d}y$ 给出。在坐标基 $(\\mathrm{d}x, \\mathrm{d}y, \\mathrm{d}z)$ 中，其分量为 $\\alpha_x=0$, $\\alpha_y=-x$ 和 $\\alpha_z=1$。对速度向量 $\\dot{q}=(\\dot{x},\\dot{y},\\dot{z})$ 的约束为 $\\alpha(\\dot{q})=0$，明确写为 $\\dot{z}-x\\dot{y}=0$。\n\n在每一点 $q \\in Q$ 处，容许速度的集合构成一个二维线性子空间 $D_q \\subset T_qQ$，称为约束分布。$D = \\ker\\alpha$。\n度量 $g$ 定义了 $D$ 的一个正交补 $D^{\\perp}$。该子空间由向量场 $\\alpha^{\\sharp}$ 张成，$\\alpha^{\\sharp}$ 是 $\\alpha$ 的 $g$-对偶。其分量 $(\\alpha^{\\sharp})^i$ 通过用逆度量提升 $\\alpha_j$ 的指标得到：$(\\alpha^{\\sharp})^i = g^{ij}\\alpha_j$。\n$$(\\alpha^{\\sharp})^x = g^{xx}\\alpha_x + g^{xy}\\alpha_y + g^{xz}\\alpha_z = \\frac{1}{m}(0) = 0$$\n$$(\\alpha^{\\sharp})^y = g^{yx}\\alpha_x + g^{yy}\\alpha_y + g^{yz}\\alpha_z = \\frac{1}{m}(-x) = -\\frac{x}{m}$$\n$$(\\alpha^{\\sharp})^z = g^{zx}\\alpha_x + g^{zy}\\alpha_y + g^{zz}\\alpha_z = \\frac{1}{m}(1) = \\frac{1}{m}$$\n在坐标基 $(\\partial_x, \\partial_y, \\partial_z)$ 中，张成 $D^{\\perp}$ 的向量场为 $\\alpha^{\\sharp} = -\\frac{x}{m}\\partial_y + \\frac{1}{m}\\partial_z$。\n\n问题要求构造 $g$-正交投影算子 $P_D: TQ \\to D$。更简单的方法是先构造到 $D^{\\perp}$ 上的投影算子 $P_{D^{\\perp}}: TQ \\to D^{\\perp}$，然后定义 $P_D = \\mathrm{Id} - P_{D^{\\perp}}$。对于任意向量场 $V$，其在由 $\\alpha^{\\sharp}$ 张成的子空间上的投影由下式给出：\n$$P_{D^{\\perp}}(V) = \\frac{g(V, \\alpha^{\\sharp})}{g(\\alpha^{\\sharp}, \\alpha^{\\sharp})} \\alpha^{\\sharp}$$\n此表达式中的各项可以用 $\\alpha$ 和 $g^{-1}$ 来表示：$g(V, \\alpha^{\\sharp}) = g(V, g^{-1}(\\alpha, \\cdot)) = \\alpha(V)$ 且 $g(\\alpha^{\\sharp}, \\alpha^{\\sharp}) = g(g^{-1}(\\alpha, \\cdot), g^{-1}(\\alpha, \\cdot)) = g^{-1}(\\alpha, \\alpha)$。我们来计算分母：\n$$g^{-1}(\\alpha, \\alpha) = g^{ij}\\alpha_i\\alpha_j = \\frac{1}{m}(0^2 + (-x)^2 + 1^2) = \\frac{x^2+1}{m}$$\n因此，到 $D^{\\perp}$ 上的投影算子为 $P_{D^{\\perp}}(V) = \\frac{\\alpha(V)}{(x^2+1)/m} \\alpha^{\\sharp}$。\n到 $D$ 上的投影算子为 $P_D(V) = V - P_{D^{\\perp}}(V) = V - \\frac{m\\,\\alpha(V)}{x^2+1}\\alpha^{\\sharp}$。\n\n约束联络定义为 $\\nabla^{\\mathrm{nh}}_{Y}Z=P_{D}(\\nabla_{Y}Z)$，其中 $Y,Z$ 是取值于 $D$ 的向量场。自由粒子的非完整运动方程即非完整测地线方程，它表明加速度在约束分布上的切向分量必须为零。这表示为 $\\nabla^{\\mathrm{nh}}_{\\dot{q}}\\dot{q}=0$，等价于 $P_D(\\nabla_{\\dot{q}}\\dot{q})=0$。这意味着加速度向量 $\\nabla_{\\dot{q}}\\dot{q}$ 必须与分布 $D$ 正交，即 $\\nabla_{\\dot{q}}\\dot{q} \\in D^{\\perp}$。\n反作用加速度 $R(q,\\dot{q})$ 正是这个所要求的加速度向量：$R(q,\\dot{q}) = \\nabla_{\\dot{q}}\\dot{q}$。因此，我们必须有 $R(q,\\dot{q}) \\in D^{\\perp}$。\n\n对于度量 $g_{ij}=m\\,\\delta_{ij}$，其 Levi-Civita 联络 $\\nabla$ 很简单。由于度量分量是常数，Christoffel 符号 $\\Gamma^k_{ij} = \\frac{1}{2}g^{kl}(\\partial_i g_{jl} + \\partial_j g_{il} - \\partial_l g_{ij})$ 全都为零。\n速度向量 $\\dot{q}$ 沿曲线 $q(t)$ 的协变导数由 $(\\nabla_{\\dot{q}}\\dot{q})^k = \\frac{d\\dot{q}^k}{dt} + \\Gamma^k_{ij}\\dot{q}^i\\dot{q}^j$ 给出。由于 $\\Gamma^k_{ij}=0$，这简化为 $(\\nabla_{\\dot{q}}\\dot{q})^k = \\ddot{q}^k$。\n所以，反作用加速度就是标准的加速度向量 $R = \\ddot{q} = (\\ddot{x},\\ddot{y},\\ddot{z})$。\n\n由于 $R \\in D^{\\perp}$，它必须与 $\\alpha^{\\sharp}$ 成比例：\n$$R = \\lambda \\alpha^{\\sharp}$$\n其中 $\\lambda = \\lambda(q, \\dot{q})$ 是某个标量函数。用分量表示，即为：\n$$(\\ddot{x}, \\ddot{y}, \\ddot{z}) = \\lambda \\left(0, -\\frac{x}{m}, \\frac{1}{m}\\right)$$\n这种分量上的相等关系给了我们三个方程：\n1) $\\ddot{x} = 0$\n2) $\\ddot{y} = -\\frac{\\lambda x}{m}$\n3) $\\ddot{z} = \\frac{\\lambda}{m}$\n\n为了求出 $\\lambda$，我们必须强制要求速度向量 $\\dot{q}$ 始终保持在分布 $D$ 中。这意味着约束方程 $\\alpha(\\dot{q})=0$ 必须对所有 $t$ 成立，这又意味着其全时间导数必须为零：\n$$\\frac{d}{dt}(\\alpha(\\dot{q})) = 0 \\implies \\frac{d}{dt}(\\dot{z} - x\\dot{y}) = 0$$\n使用乘法法则，我们得到：\n$$\\ddot{z} - \\dot{x}\\dot{y} - x\\ddot{y} = 0$$\n现在我们将方程 $2)$ 和 $3)$ 中 $\\ddot{y}$ 和 $\\ddot{z}$ 的表达式代入此条件中：\n$$\\left(\\frac{\\lambda}{m}\\right) - \\dot{x}\\dot{y} - x\\left(-\\frac{\\lambda x}{m}\\right) = 0$$\n$$\\frac{\\lambda}{m} - \\dot{x}\\dot{y} + \\frac{\\lambda x^2}{m} = 0$$\n提出因子 $\\lambda/m$：\n$$\\frac{\\lambda}{m}(1+x^2) = \\dot{x}\\dot{y}$$\n解出 $\\lambda$：\n$$\\lambda = \\frac{m\\dot{x}\\dot{y}}{x^2+1}$$\n这就确定了反作用加速度的大小。现在我们可以将 $\\lambda$ 的这个表达式代回方程 $1)$、$2)$ 和 $3)$，从而求出 $R$ 的分量：\n$$R_x = \\ddot{x} = 0$$\n$$R_y = \\ddot{y} = -\\frac{\\lambda x}{m} = -\\left(\\frac{m\\dot{x}\\dot{y}}{x^2+1}\\right)\\frac{x}{m} = -\\frac{x\\dot{x}\\dot{y}}{x^2+1}$$\n$$R_z = \\ddot{z} = \\frac{\\lambda}{m} = \\left(\\frac{m\\dot{x}\\dot{y}}{x^2+1}\\right)\\frac{1}{m} = \\frac{\\dot{x}\\dot{y}}{x^2+1}$$\n因此，反作用加速度向量为 $R(q,\\dot{q}) = \\left(0, -\\frac{x\\dot{x}\\dot{y}}{x^2+1}, \\frac{\\dot{x}\\dot{y}}{x^2+1}\\right)$。注意，此表达式依赖于 $x$、$\\dot{x}$ 和 $\\dot{y}$。尽管约束 $\\dot{z} = x\\dot{y}$ 成立，但该表达式并未显式包含 $\\dot{z}$，这与题目要求一致。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & -\\frac{x\\dot{x}\\dot{y}}{x^2+1} & \\frac{\\dot{x}\\dot{y}}{x^2+1}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "转换到哈密顿框架后，处理约束可能会变得微妙，如果处理不当，甚至会导致不一致性。这个练习将向你介绍一个强大的、系统性的程序——Gotay–Nester–Hinds (GNH) 算法——来解决这些问题。通过为一个完整的约束系统生成一系列的一致性条件，你将确定最终的、物理上一致的动力学所在的相空间子流形，从而掌握处理约束哈密顿系统的核心技术。",
            "id": "3746589",
            "problem": "考虑余切丛 $T^{\\ast}\\mathbb{R}^{2}$，其正则坐标为 $(q,p)$，其中 $q=(q_{1},q_{2})\\in \\mathbb{R}^{2}$ 且 $p=(p_{1},p_{2})\\in \\mathbb{R}^{2}$。设正则辛形式为 $\\omega=\\sum_{i=1}^{2}\\mathrm{d}q_{i}\\wedge \\mathrm{d}p_{i}$。考虑哈密顿量 $H:T^{\\ast}\\mathbb{R}^{2}\\to \\mathbb{R}$，由下式给出\n$$\nH(q,p)=\\frac{1}{2m}\\,p\\cdot p+\\frac{k}{2}\\,q\\cdot q,\n$$\n其中 $m>0$ 和 $k\\ge 0$ 为常数，且 $p\\cdot p=p_{1}^{2}+p_{2}^{2}$，$q\\cdot q=q_{1}^{2}+q_{2}^{2}$。施加完整约束\n$$\n\\phi(q)=q\\cdot q-R^{2}=0,\n$$\n其中 $R>0$ 为常数，这被解释为将位形限制在半径为 $R$ 的圆周上。\n\n使用 Gotay–Nester–Hinds (GNH) 算法，将主约束流形 $M_{0}=\\{(q,p)\\in T^{\\ast}\\mathbb{R}^{2}\\mid \\phi(q)=0\\}$ 上的约束哈密顿系统视为一个带有拉回2-形式和限制后的哈密顿量的前辛系统。逐次确定约束流形 $M_{k}$ 直至算法稳定，并从稳定阶段的内蕴方程 $\\iota_{X}\\omega_{k}=\\mathrm{d}H_{k}$ 中导出最终的约束动力学，其表现为与最终约束流形相切的矢量场 $X$。\n\n具体而言，导出 GNH 算法所蕴含的所有中间一致性条件，确定前辛形式变为非退化的阶段，并计算所得的约束运动方程，其形式为\n$$\n\\dot{q}=\\frac{1}{m}\\,p,\\qquad \\dot{p}=-k\\,q+\\lambda(q,p)\\,q,\n$$\n该方程在最终约束流形上成立，其中 $\\lambda(q,p)$ 是由该算法确定的唯一标量函数。请用 $q$、$p$、$m$、$k$ 和 $R$ 显式地表示 $\\lambda(q,p)$。\n\n回答要求：仅提供 $\\lambda(q,p)$ 的最终化简解析表达式。无需进行数值计算。",
            "solution": "我们从正则辛流形 $(T^{\\ast}\\mathbb{R}^{2},\\omega)$ 开始，其中 $\\omega=\\sum_{i=1}^{2}\\mathrm{d}q_{i}\\wedge \\mathrm{d}p_{i}$，哈密顿量为 $H(q,p)=\\frac{1}{2m}\\,p\\cdot p+\\frac{k}{2}\\,q\\cdot q$。施加完整约束 $\\phi(q)=q\\cdot q-R^{2}=0$，并考虑主约束流形\n$$\nM_{0}=\\{(q,p)\\in T^{\\ast}\\mathbb{R}^{2}\\mid \\phi(q)=0\\}。\n$$\nGotay–Nester–Hinds (GNH) 算法处理受限系统 $(M_{0},\\omega_{0},H_{0})$，其中 $\\omega_{0}=i_{0}^{\\ast}\\omega$ 且 $H_{0}=H|_{M_{0}}$，$i_{0}:M_{0}\\hookrightarrow T^{\\ast}\\mathbb{R}^{2}$ 是包含映射。若一个与 $M_{0}$ 相切的矢量场 $X$ 满足前辛方程\n$$\n\\iota_{X}\\omega_{0}=\\mathrm{d}H_{0},\n$$\n则它是一个解。\n由于 $\\omega_{0}$ 可能是退化的，解的存在性要求 $\\mathrm{d}H_{0}$ 零化 $\\omega_{0}$ 的核。\n\n步骤1：计算 $\\omega_{0}$ 的核。在 $(q,p)\\in M_{0}$ 处的一个切矢量 $(\\delta q,\\delta p)$ 满足相切条件 $\\mathrm{d}\\phi(q)\\cdot \\delta q=2\\,q\\cdot \\delta q=0$，即 $\\delta q$ 与 $q$ 正交。$\\omega$ 的限制由 $\\omega((\\delta q,\\delta p),(\\eta_{q},\\eta_{p}))=\\delta q\\cdot \\eta_{p}-\\eta_{q}\\cdot \\delta p$ 给出。为了使 $(\\delta q,\\delta p)$ 位于 $\\omega_{0}$ 的核中，我们要求\n$$\n\\omega((\\delta q,\\delta p),(\\eta_{q},\\eta_{p}))=0\\quad \\text{对所有与 }M_{0}\\text{ 相切的 }(\\eta_{q},\\eta_{p})\\text{ 成立}。\n$$\n取任意的 $\\eta_{p}$ 会迫使 $\\delta q=0$。当 $\\delta q=0$ 时，条件简化为 $-\\eta_{q}\\cdot \\delta p=0$ 对所有与 $q$ 正交的 $\\eta_{q}$ 成立。这意味着 $\\delta p$ 必须与 $q$ 平行。因此，\n$$\n\\ker(\\omega_{0})=\\{(0,\\alpha\\,q)\\mid \\alpha\\in \\mathbb{R}\\}。\n$$\n\n步骤2：一致性条件和次级约束。解的存在性要求 $\\mathrm{d}H_{0}$ 零化 $\\ker(\\omega_{0})$。对于 $Z=(0,\\alpha q)\\in \\ker(\\omega_{0})$，\n$$\n\\mathrm{d}H_{0}(Z)=\\frac{\\partial H}{\\partial p}(q,p)\\cdot \\alpha q=\\left(\\frac{1}{m}\\,p\\right)\\cdot \\alpha q=\\frac{\\alpha}{m}\\,p\\cdot q。\n$$\n为了使 $\\mathrm{d}H_{0}(Z)=0$ 对所有 $\\alpha$ 成立，我们必须施加次级约束\n$$\n\\psi(q,p)=q\\cdot p=0。\n$$\n定义\n$$\nM_{1}=\\{(q,p)\\in M_{0}\\mid \\psi(q,p)=0\\}=\\{(q,p)\\in T^{\\ast}\\mathbb{R}^{2}\\mid q\\cdot q=R^{2},\\ q\\cdot p=0\\}。\n$$\n\n步骤3：$\\omega$ 限制在 $M_{1}$ 上的核与算法终止。我们计算 $\\ker(\\omega_{1})$，其中 $\\omega_{1}=i_{1}^{\\ast}\\omega_{0}$ 且 $i_{1}:M_{1}\\hookrightarrow M_{0}$。与 $M_{1}$ 相切的切矢量 $(\\delta q,\\delta p)$ 同时满足 $q\\cdot \\delta q=0$ 和 $\\delta(q\\cdot p)=\\delta q\\cdot p+q\\cdot \\delta p=0$。为了使矢量 $(0,\\alpha q)$ 与 $M_{1}$ 相切，第二个条件要求 $q\\cdot (\\alpha q)=\\alpha\\,q\\cdot q=\\alpha R^{2}=0$，因此 $\\alpha=0$。所以，$\\ker(\\omega_{1})$ 中唯一的矢量是零矢量，且 $\\omega_{1}$ 在 $M_{1}$ 上是非退化的。因此，GNH 算法在 $M_{1}$ 处稳定，没有进一步的约束，因为前辛形式已经变成了辛形式。\n\n步骤4：求解 $M_{1}$ 上的约束动力学。在环境空间 $T^{\\ast}\\mathbb{R}^{2}$ 中，哈密顿矢量场满足\n$$\n\\dot{q}=\\frac{\\partial H}{\\partial p}=\\frac{1}{m}\\,p,\\qquad \\dot{p}=-\\frac{\\partial H}{\\partial q}=-k\\,q。\n$$\n在 $M_{0}$ 上，由于 $\\ker(\\omega_{0})$ 的存在，$\\iota_{X}\\omega_{0}=\\mathrm{d}H_{0}$ 的解不唯一；我们可以加上 $(0,q)$ 的任意倍数而不改变 $\\iota_{X}\\omega_{0}$。然而，在 $M_{1}$ 上，由于 $\\omega_{1}$ 是非退化的，解的唯一性成立。因此，$M_{1}$ 上的约束矢量场必须具有以下形式\n$$\n\\dot{q}=\\frac{1}{m}\\,p,\\qquad \\dot{p}=-k\\,q+\\lambda(q,p)\\,q,\n$$\n其中标量函数 $\\lambda(q,p)$ 的选取要保证流与 $M_{1}$ 相切。\n\n步骤5：从相切性确定 $\\lambda(q,p)$。与 $M_{1}$ 的相切性要求两个约束都随时间保持不变。对于 $\\phi(q)=q\\cdot q-R^{2}=0$，\n$$\n\\frac{d}{dt}\\phi(q)=2\\,q\\cdot \\dot{q}=2\\,q\\cdot \\left(\\frac{1}{m}\\,p\\right)=\\frac{2}{m}\\,q\\cdot p=0,\n$$\n在 $M_{1}$ 上，当给定 $\\psi=0$ 时，此式恒成立。对于 $\\psi(q,p)=q\\cdot p=0$，\n$$\n\\frac{d}{dt}\\psi(q,p)=\\dot{q}\\cdot p+q\\cdot \\dot{p}=\\left(\\frac{1}{m}\\,p\\right)\\cdot p+q\\cdot \\left(-k\\,q+\\lambda(q,p)\\,q\\right)=\\frac{1}{m}\\,p\\cdot p+(-k+\\lambda(q,p))\\,q\\cdot q。\n$$\n在 $M_{1}$ 上，$q\\cdot q=R^{2}$。因此，相切条件 $\\frac{d}{dt}\\psi=0$ 得到\n$$\n0=\\frac{1}{m}\\,p\\cdot p+(-k+\\lambda(q,p))\\,R^{2},\n$$\n由此可唯一地解出\n$$\n\\lambda(q,p)=k-\\frac{p\\cdot p}{m\\,R^{2}}。\n$$\n\n结论：GNH 算法生成 $M_{0}=\\{q\\cdot q=R^{2}\\}$，然后生成 $M_{1}=\\{q\\cdot q=R^{2},\\ q\\cdot p=0\\}$，在此流形上 $\\omega$ 变为非退化。$M_{1}$ 上的约束动力学为\n$$\n\\dot{q}=\\frac{1}{m}\\,p,\\qquad \\dot{p}=-k\\,q+\\left(k-\\frac{p\\cdot p}{m\\,R^{2}}\\right)q,\n$$\n所求的标量函数为 $\\lambda(q,p)=k-\\frac{p\\cdot p}{m\\,R^{2}}$。",
            "answer": "$$\\boxed{k-\\frac{p\\cdot p}{m R^{2}}}$$"
        },
        {
            "introduction": "理论框架虽然优雅，但在实践中我们常常需要计算机来求解复杂的运动方程。这个练习将指导你实现并比较两种主流的约束系统仿真方法：一种是精确的离散Lagrange–d’Alembert方法，另一种是近似的罚函数法。通过这个编码实践，你将把抽象的变分原理转化为可执行的算法，并数值验证罚函数法在罚参数$ \\rho $趋于无穷大时的收敛性，从而获得几何数值积分领域的宝贵实践经验。",
            "id": "3746644",
            "problem": "考虑一个平面上的力学系统，其位形变量为 $q = (x,y,\\theta)$，其中 $(x,y)$ 表示刚体质心的笛卡尔坐标位置，$\\theta$ 是其以弧度计量的方位角。其拉格朗日量是纯动能的，定义为 $L(q,\\dot{q}) = T(q,\\dot{q})$，其中 $T = \\frac{1}{2} m (\\dot{x}^{2} + \\dot{y}^{2}) + \\frac{1}{2} J \\dot{\\theta}^{2}$，$m > 0$ 是质量，$J > 0$ 是标量转动惯量。该系统受到一个 Chaplygin 雪橇类型的非完整（不可积，速度相关）线性约束：接触点的横向速度为零。在物体坐标系中，这被编码为普法夫一次型\n$$\nA(q)\\,\\dot{q} = -\\sin(\\theta)\\,\\dot{x} + \\cos(\\theta)\\,\\dot{y} + a\\,\\dot{\\theta} = 0,\n$$\n其中 $a > 0$ 是从质心沿纵向物体轴到刀刃接触点的有向距离。\n\n您需要实现一个离散变分积分器和一个用于非完整约束的基于罚函数的近似方法，两者都源于离散作用量原理。使用中点离散拉格朗日量\n$$\nL_{d}(q_{k},q_{k+1};h) = h\\,L\\!\\left(\\frac{q_{k}+q_{k+1}}{2},\\frac{q_{k+1}-q_{k}}{h}\\right),\n$$\n其中 $h > 0$ 是固定时间步长。定义离散约束函数\n$$\n\\phi(q_{k},q_{k+1};h) = -\\sin\\!\\left(\\frac{\\theta_{k}+\\theta_{k+1}}{2}\\right)\\frac{x_{k+1}-x_{k}}{h} + \\cos\\!\\left(\\frac{\\theta_{k}+\\theta_{k+1}}{2}\\right)\\frac{y_{k+1}-y_{k}}{h} + a\\,\\frac{\\theta_{k+1}-\\theta_{k}}{h}.\n$$\n对于罚函数法，使用增广离散拉格朗日量\n$$\n\\widetilde{L}_{d}(q_{k},q_{k+1};h,\\rho) = L_{d}(q_{k},q_{k+1};h) + \\frac{\\rho\\,h}{2}\\,\\phi(q_{k},q_{k+1};h)^{2},\n$$\n其中 $\\rho \\ge 0$ 是罚参数。通过对总离散作用量 $\\sum_{k} \\widetilde{L}_{d}(q_{k},q_{k+1};h,\\rho)$ 强制执行离散欧拉-拉格朗日平稳性条件来获得离散轨迹：\n$$\nD_{2}\\widetilde{L}_{d}(q_{k-1},q_{k};h,\\rho) + D_{1}\\widetilde{L}_{d}(q_{k},q_{k+1};h,\\rho) = 0 \\quad \\text{对所有 } k,\n$$\n其中 $D_{i}$ 表示对 $\\widetilde{L}_{d}$ 的第 $i$ 个参数的偏导数。\n\n对于受约束的离散拉格朗日-达朗贝尔积分器（离散LdA），通过离散拉格朗日乘子 $\\lambda_{k}$ 强制施加非完整约束，并在每一步求解非线性系统\n$$\nD_{2}L_{d}(q_{k-1},q_{k};h) + D_{1}L_{d}(q_{k},q_{k+1};h) + A(q_{k})^{\\top}\\lambda_{k} = 0,\n$$\n$$\n\\phi(q_{k},q_{k+1};h) = 0,\n$$\n其中 $A(q_{k}) = \\big[-\\sin(\\theta_{k}),\\,\\cos(\\theta_{k}),\\,a\\big]$ 是在 $q_{k}$ 处求值的约束协矢量，$A(q_{k})^{\\top}\\lambda_{k}$ 是对应的广义离散约束力。\n\n仅使用这些原理，实现一个程序，该程序：\n- 使用离散拉格朗日-达朗贝尔方法，在给定初始条件 $q_0$ 和一个由与约束一致的速度得到的第一步 $q_1$ 的情况下，以固定步长 $h$ 构建一个包含 $N$ 步的受约束参考轨迹。\n- 对相同的初始条件和 $(h,N)$，使用罚函数增广的离散欧拉-拉格朗日方程为不同的 $\\rho$ 值构建罚函数轨迹。\n- 对每个 $\\rho$，计算一个浮点数，该浮点数等于在所有时间索引 $k = 0,1,\\dots,N$ 上，罚函数轨迹与受约束轨迹之间的平均欧几里得距离，即\n$$\n\\mathrm{err}(\\rho) = \\frac{1}{N+1}\\sum_{k=0}^{N} \\left\\| q^{(\\rho)}_{k} - q^{\\mathrm{constr}}_{k} \\right\\|_{2}.\n$$\n\n角度量必须以弧度为单位。除了给定的定义外，不需要进行物理单位转换。使用参数 $(m,J,a) = (1.0,0.25,0.5)$ 和初始条件 $q_{0} = (0,0,0.3)$，以及 $q_{1} = q_{0} + h\\,(\\dot{x}_{0},\\dot{y}_{0},\\dot{\\theta}_{0})$，其中 $(\\dot{x}_{0},\\dot{y}_{0},\\dot{\\theta}_{0}) = (u\\cos(\\theta_{0}),u\\sin(\\theta_{0}),0)$ 且 $u = 1.0$。使用以下五个测试用例：\n- 用例1（基线，无罚函数）：$(\\rho,h,N) = (0.0, 0.05, 50)$。\n- 用例2（小罚函数）：$(\\rho,h,N) = (5.0, 0.05, 50)$。\n- 用例3（中等罚函数）：$(\\rho,h,N) = (20.0, 0.05, 50)$。\n- 用例4（大罚函数）：$(\\rho,h,N) = (100.0, 0.05, 50)$。\n- 用例5（大罚函数，更小步长）：$(\\rho,h,N) = (100.0, 0.02, 50)$。\n\n您的程序应生成单行输出，其中包含五个误差值，以逗号分隔并用方括号括起（例如，“[e1,e2,e3,e4,e5]”）。这些值必须是 Python 浮点数。\n\n目标是数值上证明，随着罚参数的增加，罚函数轨迹收敛于非完整约束轨迹，即 $\\mathrm{err}(\\rho)$ 随着 $\\rho$ 的增大（通常也随着 $h$ 的减小）而减小。",
            "solution": "该问题要求为一个非完整力学系统实现并比较两种数值方法。第一种方法是基于拉格朗日-达朗贝尔原理的受约束变分积分器，它作为参考基准。第二种方法是用于罚函数增广拉格朗日量的无约束积分器。两种方法都源于离散作用量原理，并使用一个指定的离散拉格朗日量。\n\n首先，我们通过将位置和速度的中点近似代入连续拉格朗日量 $L = \\frac{1}{2} m (\\dot{x}^2 + \\dot{y}^2) + \\frac{1}{2} J \\dot{\\theta}^2$ 来定义中点离散拉格朗日量 $L_d(q_k, q_{k+1}; h)$。\n设 $q_k = (x_k, y_k, \\theta_k)$。离散速度为 $\\frac{q_{k+1}-q_k}{h}$。\n$$\nL_d(q_k, q_{k+1}; h) = h \\left[ \\frac{1}{2}m\\left( \\left(\\frac{x_{k+1}-x_k}{h}\\right)^2 + \\left(\\frac{y_{k+1}-y_k}{h}\\right)^2 \\right) + \\frac{1}{2}J\\left(\\frac{\\theta_{k+1}-\\theta_k}{h}\\right)^2 \\right]\n$$\n$$\nL_d(q_k, q_{k+1}; h) = \\frac{m}{2h}\\left((x_{k+1}-x_k)^2 + (y_{k+1}-y_k)^2\\right) + \\frac{J}{2h}(\\theta_{k+1}-\\theta_k)^2\n$$\n两种方法的运动方程都源于离散欧拉-拉格朗日方程，该方程表示离散作用量总和的平稳性。其一般形式为 $\\frac{\\partial}{\\partial q_k} \\sum_j \\mathcal{L}_d(q_j, q_{j+1}) = 0$，对于单个步骤，它展开为 $D_2\\mathcal{L}_d(q_{k-1}, q_k) + D_1\\mathcal{L}_d(q_k, q_{k+1}) = 0$，其中 $\\mathcal{L}_d$ 是该方法所用的离散拉格朗日量。\n\n**方法1：离散拉格朗日-达朗贝尔（LdA）积分器（参考轨迹）**\n此方法在每一步都使用一个拉格朗日乘子来精确地施加非完整约束。系统的演化由一个微分代数方程组控制，其离散形式在每个时间步 $k$ 成为一个需要求解 $(q_{k+1}, \\lambda_k)$ 的非线性代数方程组。给定 $q_{k-1}$ 和 $q_k$，我们求解：\n$$\n\\begin{cases}\nD_2 L_d(q_{k-1}, q_k; h) + D_1 L_d(q_k, q_{k+1}; h) + A(q_k)^\\top \\lambda_k = 0 \\\\\n\\phi(q_k, q_{k+1}; h) = 0\n\\end{cases}\n$$\n$L_d$ 的导数为：\n$D_1 L_d(q_k, q_{k+1}) = \\left[ \\frac{-m(x_{k+1}-x_k)}{h}, \\frac{-m(y_{k+1}-y_k)}{h}, \\frac{-J(\\theta_{k+1}-\\theta_k)}{h} \\right]^\\top$\n$D_2 L_d(q_{k-1}, q_k) = \\left[ \\frac{m(x_k-x_{k-1})}{h}, \\frac{m(y_k-y_{k-1})}{h}, \\frac{J(\\theta_k-\\theta_{k-1})}{h} \\right]^\\top$\n使用给定的 $A(q_k) = [-\\sin(\\theta_k), \\cos(\\theta_k), a]$，关于未知数 $(x_{k+1}, y_{k+1}, \\theta_{k+1}, \\lambda_k)$ 的方程组变为（前三个方程乘以 $h$ 后）：\n1. $m(x_k - x_{k-1}) - m(x_{k+1} - x_k) - h\\lambda_k\\sin(\\theta_k) = 0 \\implies m(2x_k - x_{k-1} - x_{k+1}) - h\\lambda_k\\sin(\\theta_k) = 0$\n2. $m(y_k - y_{k-1}) - m(y_{k+1} - y_k) + h\\lambda_k\\cos(\\theta_k) = 0 \\implies m(2y_k - y_{k-1} - y_{k+1}) + h\\lambda_k\\cos(\\theta_k) = 0$\n3. $J(\\theta_k - \\theta_{k-1}) - J(\\theta_{k+1} - \\theta_k) + h\\lambda_k a = 0 \\implies J(2\\theta_k - \\theta_{k-1} - \\theta_{k+1}) + h\\lambda_k a = 0$\n4. $-\\sin(\\frac{\\theta_k+\\theta_{k+1}}{2})\\frac{x_{k+1}-x_k}{h} + \\cos(\\frac{\\theta_k+\\theta_{k+1}}{2})\\frac{y_{k+1}-y_k}{h} + a\\frac{\\theta_{k+1}-\\theta_k}{h} = 0$\n这是一个包含 4 个变量的 4 个非线性代数方程组，我们在每一步 $k=1, \\dots, N-1$ 都使用数值求根算法来求解。\n\n**方法2：罚函数法积分器**\n此方法通过在离散拉格朗日量中添加一个罚项来近似约束。增广离散拉格朗日量为 $\\widetilde{L}_d = L_d + \\frac{\\rho h}{2}\\phi^2$。运动方程是针对 $\\widetilde{L}_d$ 的标准离散欧拉-拉格朗日方程：\n$D_2\\widetilde{L}_d(q_{k-1}, q_k; h, \\rho) + D_1\\widetilde{L}_d(q_k, q_{k+1}; h, \\rho) = 0$。\n其导数为 $D_i\\widetilde{L}_d = D_i L_d + \\rho h \\phi D_i \\phi$。得到的系统是关于 $q_{k+1}$ 的 3 个分量的 3 个非线性方程组：\n$$\nF(q_{k+1}) = D_2 L_d(q_{k-1}, q_k) + \\rho h \\phi_{k-1,k} D_2\\phi(q_{k-1},q_k) + D_1 L_d(q_k, q_{k+1}) + \\rho h \\phi_{k,k+1} D_1\\phi(q_k,q_{k+1}) = 0\n$$\n其中 $\\phi_{i,j} = \\phi(q_i, q_j; h)$。这个关于 $q_{k+1}=(x_{k+1}, y_{k+1}, \\theta_{k+1})$ 的系统在每一步都使用数值求根器求解。当 $\\rho \\to \\infty$ 时，其解预期会收敛到 LdA 方法的解。\n\n**数值实现**\n对于这两种方法，我们都从 $q_0$ 和 $q_1$ 开始。对于随后的每一步 $k=1, \\dots, N-1$，我们使用 `scipy.optimize.root` 求解相应的关于 $q_{k+1}$ 的非线性系统。在第 $k$ 步，迭代求解器的一个良好初始猜测是外推值 $q_{k+1}^{\\text{guess}} = q_k + (q_k - q_{k-1})$。对于 LdA 方法，$\\lambda_k$ 的初始猜测设为 $0$。\n\n在为每个测试用例生成了受约束的参考轨迹 $q^{\\text{constr}}$ 和罚函数轨迹 $q^{(\\rho)}$ 之后，我们使用指定的平均欧几里得距离公式计算误差。\n该实现对于给定的 $(h, N)$ 对只计算一次参考轨迹，并为不同的 $\\rho$ 值重用该轨迹。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    params = {'m': 1.0, 'J': 0.25, 'a': 0.5}\n    q0 = np.array([0.0, 0.0, 0.3])\n    u = 1.0\n    v0 = np.array([u * np.cos(q0[2]), u * np.sin(q0[2]), 0.0])\n\n    test_cases = [\n        # (rho, h, N)\n        (0.0, 0.05, 50),\n        (5.0, 0.05, 50),\n        (20.0, 0.05, 50),\n        (100.0, 0.05, 50),\n        (100.0, 0.02, 50),\n    ]\n\n    results = []\n    ref_trajectory_cache = {}\n\n    for rho, h, N in test_cases:\n        \n        # Calculate initial conditions based on h\n        q1 = q0 + h * v0\n\n        # Generate or retrieve reference trajectory\n        if (h, N) in ref_trajectory_cache:\n            q_constr = ref_trajectory_cache[(h, N)]\n        else:\n            q_constr = _generate_constrained_trajectory(h, N, q0, q1, params)\n            ref_trajectory_cache[(h, N)] = q_constr\n\n        # Generate penalized trajectory\n        q_penalized = _generate_penalized_trajectory(rho, h, N, q0, q1, params)\n\n        # Compute error\n        error = np.mean(np.linalg.norm(q_penalized - q_constr, axis=1))\n        results.append(error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _phi(q_k, q_kp1, h, a):\n    \"\"\"Discrete constraint function phi.\"\"\"\n    x_k, y_k, th_k = q_k\n    x_kp1, y_kp1, th_kp1 = q_kp1\n    th_mid = (th_k + th_kp1) / 2.0\n    val = -np.sin(th_mid) * (x_kp1 - x_k) / h\n    val += np.cos(th_mid) * (y_kp1 - y_k) / h\n    val += a * (th_kp1 - th_k) / h\n    return val\n\ndef _generate_constrained_trajectory(h, N, q0, q1, params):\n    \"\"\"Generates a trajectory using the Discrete Lagrange-d'Alembert method.\"\"\"\n    m, J, a = params['m'], params['J'], params['a']\n    \n    q_traj = np.zeros((N + 1, 3))\n    q_traj[0], q_traj[1] = q0, q1\n    \n    lambda_k_guess = 0.0\n\n    def lda_residual(z, q_k, q_km1):\n        x_kp1, y_kp1, th_kp1, lambda_k = z\n        x_k, y_k, th_k = q_k\n        x_km1, y_km1, th_km1 = q_km1\n\n        res = np.zeros(4)\n        res[0] = m * (2 * x_k - x_km1 - x_kp1) - h * lambda_k * np.sin(th_k)\n        res[1] = m * (2 * y_k - y_km1 - y_kp1) + h * lambda_k * np.cos(th_k)\n        res[2] = J * (2 * th_k - th_km1 - th_kp1) + h * lambda_k * a\n        res[3] = _phi(q_k, np.array([x_kp1, y_kp1, th_kp1]), h, a)\n        return res\n\n    for k in range(1, N):\n        q_k = q_traj[k]\n        q_km1 = q_traj[k - 1]\n        \n        # Initial guess for the root finder\n        q_kp1_guess = q_k + (q_k - q_km1)\n        z_guess = np.append(q_kp1_guess, lambda_k_guess)\n\n        sol = root(lda_residual, z_guess, args=(q_k, q_km1), method='hybr', tol=1e-9)\n        if not sol.success:\n            raise RuntimeError(f'LdA solver failed at step {k}')\n        \n        q_traj[k + 1] = sol.x[:3]\n        lambda_k_guess = sol.x[3] # Use as guess for next step\n        \n    return q_traj\n\ndef _generate_penalized_trajectory(rho, h, N, q0, q1, params):\n    \"\"\"Generates a trajectory using the penalty method.\"\"\"\n    m, J, a = params['m'], params['J'], params['a']\n\n    q_traj = np.zeros((N + 1, 3))\n    q_traj[0], q_traj[1] = q0, q1\n\n    if rho == 0.0: # Unconstrained case has an analytical update\n        for k in range(1, N):\n            q_traj[k + 1] = 2 * q_traj[k] - q_traj[k - 1]\n        return q_traj\n\n    def penalty_residual(q_kp1, q_k, q_km1):\n        x_k, y_k, th_k = q_k\n        x_km1, y_km1, th_km1 = q_km1\n        x_kp1, y_kp1, th_kp1 = q_kp1\n\n        # Terms related to L_d(q_{k-1}, q_k) and phi(q_{k-1}, q_k)\n        th_mid0 = (th_km1 + th_k) / 2.0\n        phi0 = _phi(q_km1, q_k, h, a)\n        d_phi0_d_thk = ( -0.5*np.cos(th_mid0)*((x_k-x_km1)/h) \n                        - 0.5*np.sin(th_mid0)*((y_k-y_km1)/h) + a/h )\n\n        # Terms related to L_d(q_k, q_{k+1}) and phi(q_k, q_{k+1})\n        th_mid1 = (th_k + th_kp1) / 2.0\n        phi1 = _phi(q_k, q_kp1, h, a)\n        d_phi1_d_thk = ( -0.5*np.cos(th_mid1)*((x_kp1-x_k)/h) \n                        - 0.5*np.sin(th_mid1)*((y_kp1-y_k)/h) - a/h )\n\n        # Discrete EL equations\n        res = np.zeros(3)\n        # x-equation\n        res[0] = m/h * (x_k - x_{k-1}) + rho*h*phi0*(-np.sin(th_mid0)/h) + \\\n                 m/h * (x_k - x_{k+1}) + rho*h*phi1*(np.sin(th_mid1)/h)\n        # y-equation\n        res[1] = m/h * (y_k - y_{k-1}) + rho*h*phi0*(np.cos(th_mid0)/h) + \\\n                 m/h * (y_k - y_{k+1}) + rho*h*phi1*(-np.cos(th_mid1)/h)\n        # theta-equation\n        res[2] = J/h * (th_k - th_km1) + rho*h*phi0*d_phi0_d_thk + \\\n                 J/h * (th_k - th_kp1) + rho*h*phi1*d_phi1_d_thk\n        return res\n        \n    for k in range(1, N):\n        q_k = q_traj[k]\n        q_km1 = q_traj[k-1]\n        \n        q_kp1_guess = q_k + (q_k - q_km1)\n\n        sol = root(penalty_residual, q_kp1_guess, args=(q_k, q_km1), method='hybr', tol=1e-9)\n        if not sol.success:\n            raise RuntimeError(f'Penalty solver failed at step {k} for rho={rho}')\n        \n        q_traj[k + 1] = sol.x\n\n    return q_traj\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}