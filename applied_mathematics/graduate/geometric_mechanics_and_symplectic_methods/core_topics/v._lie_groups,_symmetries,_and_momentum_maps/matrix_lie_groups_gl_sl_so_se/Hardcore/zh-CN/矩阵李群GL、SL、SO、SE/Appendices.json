{
    "hands_on_practices": [
        {
            "introduction": "这个基础练习是理解李代数（无穷小生成元）如何生成李群（有限变换）的基石。通过为 $SO(2)$ 进行这个具体计算，我们将在抽象的指数映射与我们熟悉的二维旋转矩阵公式之间建立起坚实的联系。这个实践将揭示李代数中的一个简单斜对称矩阵是如何通过指数运算“演化”为群中的一个旋转操作的，从而为几何力学中的运动学描述提供了基本工具 。",
            "id": "3755442",
            "problem": "令 $SO(2)$ 表示特殊正交群 (SO)，定义为 $SO(2)=\\{R\\in GL(2,\\mathbb{R}) \\mid R^{\\top}R=I,\\ \\det(R)=1\\}$，并令 $\\mathfrak{so}(2)$ 表示其李代数，定义为 $\\mathfrak{so}(2)=\\{X\\in \\mathbb{R}^{2\\times 2} \\mid X^{\\top}=-X\\}$。对于 $X\\in \\mathfrak{so}(2)$，矩阵指数定义为 $\\exp(X)=\\sum_{k=0}^{\\infty}\\frac{1}{k!}X^{k}$。在平面几何力学中，一个恒定的角速度由一个斜对称生成元 $X\\in\\mathfrak{so}(2)$ 表示，其在单位时间后的有限旋转由 $\\exp(X)$ 给出。\n\n仅使用上述定义和标准的线性代数知识，完成以下任务：\n- 证明指数映射 $\\exp:\\mathfrak{so}(2)\\to SO(2)$ 是满射，即对于每一个 $R\\in SO(2)$，都存在一个 $X\\in\\mathfrak{so}(2)$ 使得 $R=\\exp(X)$。\n- 令 $J\\in\\mathfrak{so}(2)$ 是由 $J=\\begin{pmatrix}0  -1\\\\ 1  0\\end{pmatrix}$ 定义的斜对称生成元，并令 $\\theta\\in\\mathbb{R}$。计算矩阵指数 $\\exp(\\theta J)$ 的显式闭合形式表达式。\n\n你的最终答案必须是 $\\exp(\\theta J)$ 的单一闭合形式表达式，并尽可能化简。不需要数值近似。",
            "solution": "首先验证问题陈述的正确性和可解性。\n\n### 步骤1：提取已知条件\n- 特殊正交群 $SO(2)$ 的定义：$SO(2)=\\{R\\in GL(2,\\mathbb{R}) \\mid R^{\\top}R=I,\\ \\det(R)=1\\}$。\n- 其李代数 $\\mathfrak{so}(2)$ 的定义：$\\mathfrak{so}(2)=\\{X\\in \\mathbb{R}^{2\\times 2} \\mid X^{\\top}=-X\\}$。\n- 矩阵指数的定义：对于 $X\\in \\mathfrak{so}(2)$，$\\exp(X)=\\sum_{k=0}^{\\infty}\\frac{1}{k!}X^{k}$。\n- 斜对称生成元 $J$ 的定义：$J=\\begin{pmatrix}0  -1\\\\ 1  0\\end{pmatrix}$。\n- 参数 $\\theta \\in \\mathbb{R}$。\n- 任务1：证明指数映射 $\\exp:\\mathfrak{so}(2)\\to SO(2)$ 是满射。\n- 任务2：计算 $\\exp(\\theta J)$ 的显式闭合形式表达式。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，因为 $SO(2)$、$\\mathfrak{so}(2)$ 和矩阵指数的定义在李群理论及其在几何力学中的应用中都是标准的。问题提法清晰，定义和目标明确，可以导出一个唯一的计算解和一个标准的满射性证明。术语精确客观。没有矛盾、信息缺失或不切实际的前提。该问题是其领域内的一个基础练习，并且在数学上是可验证的。\n\n### 步骤3：结论与行动\n问题有效。将提供一个完整的、有理有据的解答。\n\n### 解答\n解答将按问题陈述的要求分两大部分进行。首先，我们将计算 $\\exp(\\theta J)$ 的显式表达式，因为这个结果对于第二部分（即满射性的证明）至关重要。\n\n**第1部分：计算 $\\exp(\\theta J)$**\n\n我们需要求解矩阵指数 $\\exp(\\theta J)$ 的闭合形式表达式，其中 $J = \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix}$ 且 $\\theta \\in \\mathbb{R}$。矩阵 $X = \\theta J = \\begin{pmatrix} 0  -\\theta \\\\ \\theta  0 \\end{pmatrix}$ 是 $\\mathfrak{so}(2)$ 的一个元素，因为 $(\\theta J)^{\\top} = \\theta J^{\\top} = \\theta \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix} = -\\theta J$。\n\n矩阵指数由幂级数定义：\n$$\n\\exp(\\theta J) = \\sum_{k=0}^{\\infty} \\frac{1}{k!}(\\theta J)^k = \\sum_{k=0}^{\\infty} \\frac{\\theta^k}{k!} J^k\n$$\n为计算此级数，我们首先研究矩阵 $J$ 的幂：\n$J^0 = I = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}$\n$J^1 = J = \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix}$\n$J^2 = J J = \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix} \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix} = \\begin{pmatrix} -1  0 \\\\ 0  -1 \\end{pmatrix} = -I$\n$J^3 = J^2 J = (-I)J = -J$\n$J^4 = J^2 J^2 = (-I)(-I) = I$\n\n$J$ 的幂是周期性的，周期为 $4$：$\\{I, J, -I, -J, \\dots\\}$。现在我们可以展开 $\\exp(\\theta J)$ 的级数：\n$$\n\\exp(\\theta J) = \\frac{\\theta^0}{0!}J^0 + \\frac{\\theta^1}{1!}J^1 + \\frac{\\theta^2}{2!}J^2 + \\frac{\\theta^3}{3!}J^3 + \\frac{\\theta^4}{4!}J^4 + \\dots\n$$\n代入 $J$ 的幂：\n$$\n\\exp(\\theta J) = I + \\theta J - \\frac{\\theta^2}{2!}I - \\frac{\\theta^3}{3!}J + \\frac{\\theta^4}{4!}I + \\dots\n$$\n我们可以将与单位矩阵 $I$ 相关的项和与矩阵 $J$ 相关的项分组：\n$$\n\\exp(\\theta J) = \\left(1 - \\frac{\\theta^2}{2!} + \\frac{\\theta^4}{4!} - \\dots\\right)I + \\left(\\theta - \\frac{\\theta^3}{3!} + \\frac{\\theta^5}{5!} - \\dots\\right)J\n$$\n括号中的两个级数分别是余弦函数和正弦函数的麦克劳林级数：\n$\\cos(\\theta) = \\sum_{k=0}^{\\infty} \\frac{(-1)^k \\theta^{2k}}{(2k)!} = 1 - \\frac{\\theta^2}{2!} + \\frac{\\theta^4}{4!} - \\dots$\n$\\sin(\\theta) = \\sum_{k=0}^{\\infty} \\frac{(-1)^k \\theta^{2k+1}}{(2k+1)!} = \\theta - \\frac{\\theta^3}{3!} + \\frac{\\theta^5}{5!} - \\dots$\n\n因此，我们可以将 $\\exp(\\theta J)$ 的表达式写成紧凑形式：\n$$\n\\exp(\\theta J) = \\cos(\\theta)I + \\sin(\\theta)J\n$$\n代入 $I$ 和 $J$ 的矩阵表示：\n$$\n\\exp(\\theta J) = \\cos(\\theta)\\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} + \\sin(\\theta)\\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix} = \\begin{pmatrix} \\cos(\\theta)  0 \\\\ 0  \\cos(\\theta) \\end{pmatrix} + \\begin{pmatrix} 0  -\\sin(\\theta) \\\\ \\sin(\\theta)  0 \\end{pmatrix}\n$$\n这可以简化为最终的闭合形式表达式：\n$$\n\\exp(\\theta J) = \\begin{pmatrix} \\cos(\\theta)  -\\sin(\\theta) \\\\ \\sin(\\theta)  \\cos(\\theta) \\end{pmatrix}\n$$\n这就完成了问题的第二个任务。\n\n**第2部分：满射性证明**\n\n我们必须证明指数映射 $\\exp: \\mathfrak{so}(2) \\to SO(2)$ 是满射。这意味着对于任何矩阵 $R \\in SO(2)$，都存在一个矩阵 $X \\in \\mathfrak{so}(2)$ 使得 $\\exp(X) = R$。\n\n首先，我们来描述 $SO(2)$ 中一个一般元素 $R$ 的特征。设 $R = \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}$。其定义属性是 $R^{\\top}R=I$ 和 $\\det(R)=1$。第一个属性意味着：\n$$\nR^{\\top}R = \\begin{pmatrix} a  c \\\\ b  d \\end{pmatrix}\\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix} = \\begin{pmatrix} a^2+c^2  ab+cd \\\\ ab+cd  b^2+d^2 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}\n$$\n这给出了条件：$a^2+c^2=1$，$b^2+d^2=1$，以及 $ab+cd=0$。\n条件 $a^2+c^2=1$ 允许我们用一个角度 $\\phi \\in \\mathbb{R}$ 来参数化 $a$ 和 $c$，使得 $a = \\cos(\\phi)$ 且 $c = \\sin(\\phi)$。\n条件 $\\det(R)=ad-bc=1$ 变为 $d\\cos(\\phi) - b\\sin(\\phi)=1$。\n条件 $ab+cd=0$ 变为 $b\\cos(\\phi) + d\\sin(\\phi)=0$。\n我们得到了一个关于 $b$ 和 $d$ 的二元线性方程组：\n1) $d\\cos(\\phi) - b\\sin(\\phi)=1$\n2) $d\\sin(\\phi) + b\\cos(\\phi)=0$\n将(1)式乘以 $\\cos(\\phi)$，(2)式乘以 $\\sin(\\phi)$，然后相加得到：\n$d(\\cos^2(\\phi)+\\sin^2(\\phi)) = \\cos(\\phi) \\implies d=\\cos(\\phi)$。\n将(1)式乘以 $-\\sin(\\phi)$，(2)式乘以 $\\cos(\\phi)$，然后相加得到：\n$b(\\sin^2(\\phi)+\\cos^2(\\phi)) = -\\sin(\\phi) \\implies b=-\\sin(\\phi)$。\n因此，任何 $R \\in SO(2)$ 中的矩阵都可以写成标准旋转矩阵的形式：\n$$\nR = \\begin{pmatrix} \\cos(\\phi)  -\\sin(\\phi) \\\\ \\sin(\\phi)  \\cos(\\phi) \\end{pmatrix}\n$$\n对于某个角度 $\\phi \\in \\mathbb{R}$。\n\n现在，我们需要找到一个 $X \\in \\mathfrak{so}(2)$ 使得 $\\exp(X)=R$。一个 $\\mathfrak{so}(2)$ 中的一般元素具有 $X = \\theta J$ 的形式，其中 $\\theta \\in \\mathbb{R}$。\n从第1部分我们得到 $\\exp(\\theta J)$ 的表达式：\n$$\n\\exp(\\theta J) = \\begin{pmatrix} \\cos(\\theta)  -\\sin(\\theta) \\\\ \\sin(\\theta)  \\cos(\\theta) \\end{pmatrix}\n$$\n为了实现 $\\exp(X) = R$，我们必须令这两个矩阵相等：\n$$\n\\begin{pmatrix} \\cos(\\theta)  -\\sin(\\theta) \\\\ \\sin(\\theta)  \\cos(\\theta) \\end{pmatrix} = \\begin{pmatrix} \\cos(\\phi)  -\\sin(\\phi) \\\\ \\sin(\\phi)  \\cos(\\phi) \\end{pmatrix}\n$$\n通过观察，我们可以通过选择 $\\theta = \\phi$ 来满足这个等式。\n因此，对于任何给定的 $R \\in SO(2)$（它对应于一个角度为 $\\phi$ 的旋转），我们可以选择矩阵 $X = \\phi J \\in \\mathfrak{so}(2)$。这个 $X$ 的指数是\n$$\n\\exp(X) = \\exp(\\phi J) = \\begin{pmatrix} \\cos(\\phi)  -\\sin(\\phi) \\\\ \\sin(\\phi)  \\cos(\\phi) \\end{pmatrix} = R\n$$\n因为对于上域 $SO(2)$ 中的每一个元素 $R$，我们都在定义域 $\\mathfrak{so}(2)$ 中找到了一个原像 $X$，所以映射 $\\exp: \\mathfrak{so}(2) \\to SO(2)$ 是满射。证明到此结束。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\cos(\\theta)  -\\sin(\\theta) \\\\ \\sin(\\theta)  \\cos(\\theta) \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "这个练习旨在将我们对李群的几何直觉形式化。将特殊正交群 $SO(n)$ 视为所有可逆矩阵构成的更大空间 $GL(n)$ 中的一个光滑曲面（即一个流形）是几何力学中的一个核心概念。本练习将运用微分几何的工具，通过分析定义群的约束条件，来精确计算这个曲面的“大小”或维度，从而强化李群作为几何对象的观念 。",
            "id": "3755409",
            "problem": "令 $GL(n)$ 表示由 $n \\times n$ 实可逆矩阵构成的一般线性群 (GL($n$))，令 $SO(n)$ 表示特殊正交群 (SO($n$))，定义为满足 $Q^{\\top}Q = I$ 和 $\\det(Q) = 1$ 的 $Q \\in GL(n)$ 的集合。考虑光滑映射 $F: GL(n) \\to \\operatorname{Sym}(n)$，其中 $\\operatorname{Sym}(n)$ 表示 $n \\times n$ 实对称矩阵构成的向量空间，该映射由 $F(Q) = Q^{\\top}Q - I$ 给出。使用适用于几何力学和矩阵李群的基本原理（包括通过矩阵曲线定义切空间以及光滑矩阵值映射的导数），分析由 $Q^{\\top}Q = I$ 施加的约束，以确定 $SO(n)$ 在 $GL(n)$ 中的余维数。通过计算在点 $Q \\in SO(n)$ 处的导数 $DF_{Q}$ 并证明其值域与 $\\operatorname{Sym}(n)$ 一致，来证明这些约束是独立的。根据此余维数，验证 $SO(n)$ 的维数公式，即 $n(n-1)/2$。以 $n$ 的单个闭式表达式给出余维数。不需要数值近似。",
            "solution": "本题要求我们通过分析定义特殊正交群 $SO(n)$ 的约束，来确定它在一般线性群 $GL(n)$ 中的余维数。群 $GL(n)$ 是所有 $n \\times n$ 实可逆矩阵的集合。它是所有 $n \\times n$ 实矩阵的向量空间 $M_n(\\mathbb{R})$ 的一个开子集，因此是一个维数为 $\\dim(GL(n)) = n^2$ 的流形。\n\n特殊正交群 $SO(n)$ 定义为满足以下两个条件的矩阵 $Q \\in GL(n)$ 的集合：\n1. $Q^{\\top}Q = I$（正交性）\n2. $\\det(Q) = 1$（特殊条件）\n\n题目引导我们分析约束 $Q^{\\top}Q = I$。我们定义一个映射 $F: GL(n) \\to \\operatorname{Sym}(n)$，其中 $\\operatorname{Sym}(n)$ 是 $n \\times n$ 实对称矩阵的向量空间，该映射由\n$$F(Q) = Q^{\\top}Q - I$$\n给出。满足正交性条件的矩阵集合是正交群 $O(n)$，它是 $F$ 对应于 $\\operatorname{Sym}(n)$ 中零矩阵 $0$ 的水平集。即 $O(n) = F^{-1}(0)$。\n\n群 $SO(n)$ 是 $O(n)$ 的一个子集，满足附加条件 $\\det(Q) = 1$。正交矩阵的行列式总是 $\\pm 1$。集合 $O(n)$ 由两个连通分支组成，一个行列式为 $1$（即 $SO(n)$），另一个行列式为 $-1$。由于 $SO(n)$ 是 $O(n)$ 的一个开子流形，它们具有相同的维数：$\\dim(SO(n)) = \\dim(O(n))$。因此，$SO(n)$ 在 $GL(n)$ 中的余维数与 $O(n)$ 在 $GL(n)$ 中的余维数相同。\n\n我们可以使用正则值定理来确定这个余维数。如果 $0 \\in \\operatorname{Sym}(n)$ 是映射 $F$ 的一个正则值，那么它的原像 $F^{-1}(0) = O(n)$ 是 $GL(n)$ 的一个子流形，其余维数等于目标空间 $\\operatorname{Sym}(n)$ 的维数。如果映射的导数在原像中的每一点都是满射的，则该值为正则值。\n\n让我们计算 $F$ 在点 $Q \\in O(n)$ 处的导数。导数（或微分）$DF_Q$ 是一个从定义域在 $Q$ 点的切空间到余定义域在 $F(Q)$ 点的切空间的线性映射。\n定义域是 $M_n(\\mathbb{R})$ 中的开集 $GL(n)$，所以它在任意点 $Q$ 的切空间 $T_Q GL(n)$ 可以等同于 $M_n(\\mathbb{R})$。\n余定义域是向量空间 $\\operatorname{Sym}(n)$，所以它在任意点（包括点 $F(Q) = 0$）的切空间可以等同于 $\\operatorname{Sym}(n)$ 本身。因此，$DF_Q: M_n(\\mathbb{R}) \\to \\operatorname{Sym}(n)$。\n\n为求 $DF_Q$ 的作用，我们考虑 $GL(n)$ 中一条光滑曲线 $\\gamma(t)$，满足 $\\gamma(0) = Q$ 且速度为 $\\gamma'(0) = V$，其中 $V \\in M_n(\\mathbb{R})$ 是一个切向量。$F$ 在 $Q$ 点对 $V$ 的导数为：\n$$DF_Q(V) = \\frac{d}{dt}\\bigg|_{t=0} F(\\gamma(t)) = \\frac{d}{dt}\\bigg|_{t=0} (\\gamma(t)^{\\top}\\gamma(t) - I)$$\n使用矩阵微分的乘法法则：\n$$DF_Q(V) = \\gamma'(0)^{\\top}\\gamma(0) + \\gamma(0)^{\\top}\\gamma'(0) = V^{\\top}Q + Q^{\\top}V$$\n我们需要证明对于任何 $Q \\in O(n)$，这个映射 $DF_Q: V \\mapsto V^{\\top}Q + Q^{\\top}V$ 都是满射。这意味着对于任何对称矩阵 $S \\in \\operatorname{Sym}(n)$，我们必须找到一个矩阵 $V \\in M_n(\\mathbb{R})$ 使得 $V^{\\top}Q + Q^{\\top}V = S$。\n\n由于 $Q \\in O(n)$，它是可逆的。任何切向量 $V \\in M_n(\\mathbb{R})$ 都可以表示为 $V = QX$，其中 $X \\in M_n(\\mathbb{R})$ 是唯一的。将此代入导数的表达式中：\n$$DF_Q(QX) = (QX)^{\\top}Q + Q^{\\top}(QX) = X^{\\top}Q^{\\top}Q + Q^{\\top}QX$$\n由于 $Q \\in O(n)$，我们有 $Q^{\\top}Q = I$。表达式简化为：\n$$DF_Q(QX) = X^{\\top}I + IX = X^{\\top} + X$$\n问题现在简化为证明对于任何对称矩阵 $S \\in \\operatorname{Sym}(n)$，存在一个矩阵 $X \\in M_n(\\mathbb{R})$ 使得 $X^{\\top} + X = S$。\n我们选择 $X = \\frac{1}{2}S$。由于 $S$ 是对称的，所以 $S^{\\top} = S$。那么，\n$$X^{\\top} + X = \\left(\\frac{1}{2}S\\right)^{\\top} + \\frac{1}{2}S = \\frac{1}{2}S^{\\top} + \\frac{1}{2}S = \\frac{1}{2}S + \\frac{1}{2}S = S$$\n这证明了对于任何 $S \\in \\operatorname{Sym}(n)$，我们都可以找到一个矩阵 $X = \\frac{1}{2}S$，它对应于切向量 $V = Q(\\frac{1}{2}S)$，使得 $DF_Q(V) = S$。因此，对于所有 $Q \\in O(n)$，导数 $DF_Q$ 都是满射。\n导数的满射性意味着由方程组 $Q^{\\top}Q - I = 0$ 定义的约束是独立的。\n\n根据正则值定理，$O(n)$（也即 $SO(n)$）在 $GL(n)$ 中的余维数等于目标空间 $\\operatorname{Sym}(n)$ 的维数。一个 $n \\times n$ 对称矩阵由其主对角线及主对角线上方的元素决定。主对角线上有 $n$ 个元素，严格位于主对角线上方的元素有 $\\binom{n}{2} = \\frac{n(n-1)}{2}$ 个。\n因此，$\\operatorname{Sym}(n)$ 的维数是：\n$$\\dim(\\operatorname{Sym}(n)) = n + \\frac{n(n-1)}{2} = \\frac{2n + n^2 - n}{2} = \\frac{n^2 + n}{2} = \\frac{n(n+1)}{2}$$\n这就是 $SO(n)$ 在 $GL(n)$ 中的余维数。\n\n最后，我们验证 $SO(n)$ 的维数公式。子流形的维数等于环境流形的维数减去其余维数。\n$$\\dim(SO(n)) = \\dim(GL(n)) - \\text{codim}(SO(n))$$\n$$\\dim(SO(n)) = n^2 - \\frac{n(n+1)}{2} = \\frac{2n^2 - (n^2+n)}{2} = \\frac{n^2 - n}{2} = \\frac{n(n-1)}{2}$$\n这证实了题目陈述中给出的维数公式。$SO(n)$ 在 $GL(n)$ 中的余维数是 $\\frac{n(n+1)}{2}$。",
            "answer": "$$\\boxed{\\frac{n(n+1)}{2}}$$"
        },
        {
            "introduction": "这是一个综合性实践，它展示了李群形式体系在几何力学实际应用中的强大威力。模拟刚体（如卫星）的姿态运动需要一种能够精确保持旋转群 $SO(3)$ 几何结构的数值积分器，以避免误差累积和不稳定性。本练习要求利用李理论的基石之一——Baker-Campbell-Hausdorff (BCH) 公式，来构建这样一个积分器，从而将李群的抽象理论应用于解决具体的动力学问题 。",
            "id": "3755449",
            "problem": "考虑特殊正交群 (SO(3))，其定义为所有满足 $R^{\\top} R = I_3$ 和 $\\det(R) = 1$ 的实 $3 \\times 3$ 矩阵 $R$ 的集合。其李代数 $\\mathfrak{so}(3)$ 由所有 $3 \\times 3$ 实斜对称矩阵构成。在几何力学中，刚体姿态的动力学可以建模为 $SO(3)$ 上的一个右不变常微分方程：\n$$\n\\dot{R}(t) = R(t) \\widehat{\\omega}(t), \\quad R(0) = I_3,\n$$\n其中 $\\omega(t) \\in \\mathbb{R}^3$ 是随时间变化的体角速度，而 $\\widehat{\\cdot} : \\mathbb{R}^3 \\to \\mathfrak{so}(3)$ 是“帽”同构，对于 $v = (v_1, v_2, v_3)^{\\top}$ 定义为\n$$\n\\widehat{v} = \\begin{bmatrix}\n0  -v_3  v_2 \\\\\nv_3  0  -v_1 \\\\\n-v_2  v_1  0\n\\end{bmatrix}.\n$$\n你需要使用 Baker–Campbell–Hausdorff (BCH) 公式为此方程设计一个二阶精度的李群积分器。Baker–Campbell–Hausdorff (BCH) 公式给出了李代数中指数乘积的对数。对于与小参数 $h$ 呈线性关系的 $X, Y \\in \\mathfrak{so}(3)$，在步长上截断至二阶后，其形式为\n$$\n\\mathrm{BCH}_2(X,Y) = X + Y + \\frac{1}{2}[X,Y],\n$$\n其中 $[X,Y] = XY - YX$ 是矩阵对易子。利用此公式，构建一个单步法，在时间步长 $h$ 内，通过单个指数将 $R_k \\approx R(t_k)$ 推进到 $R_{k+1} \\approx R(t_{k+1})$：\n$$\nR_{k+1} = R_k \\exp\\left(\\Omega_k\\right),\n$$\n其中\n$$\n\\Omega_k = \\mathrm{BCH}_2\\!\\left(\\frac{h}{2}\\,\\widehat{\\omega}(t_k),\\,\\frac{h}{2}\\,\\widehat{\\omega}(t_{k+1})\\right).\n$$\n对于足够光滑的 $\\omega(t)$，该方法在步长 $h$ 上应具有全局二阶精度。应用于 $\\mathfrak{so}(3)$ 元素的矩阵指数 $\\exp(\\cdot)$ 应使用 Rodrigues 公式实现。令 $\\mathrm{vee}:\\mathfrak{so}(3)\\to\\mathbb{R}^3$ 表示帽映射的逆映射，对任意 $v \\in \\mathbb{R}^3$，定义 $\\mathfrak{so}(3)$ 上的指数映射为\n$$\n\\exp(\\widehat{v}) = I_3 + \\frac{\\sin \\theta}{\\theta}\\,\\widehat{v} + \\frac{1 - \\cos \\theta}{\\theta^2}\\,\\widehat{v}^2, \\quad \\theta = \\|v\\|.\n$$\n你的程序必须：\n- 在 $SO(3)$ 上实现上述基于 BCH 的二阶积分器。\n- 使用以弧度/秒表示的角速度 $\\omega(t)$。时间 $t$ 的单位为秒。所有角度必须以弧度处理。\n- 对于下方的每个测试用例，使用你的积分器计算最终的旋转矩阵 $R(T)$，并将其与参考值 $R_{\\mathrm{ref}}(T)$ 进行比较。报告两者之差的 Frobenius 范数：\n$$\n\\varepsilon = \\|R(T) - R_{\\mathrm{ref}}(T)\\|_F.\n$$\n- 参考值 $R_{\\mathrm{ref}}(T)$ 若有精确解则使用精确解，否则使用相同 BCH 积分器在非常小的步长下得到的高分辨率数值解。\n\n使用以下测试套件，每个套件由角速度函数 $\\omega(t)$、最终时间 $T$ 和步数 $N$ 指定：\n1. 边界条件（零运动）：$\\omega(t) = (0, 0, 0)$，$T = 1.0$，$N = 10$。参考值为 $R_{\\mathrm{ref}}(T) = I_3$。\n2. 恒定对易情况：$\\omega(t) = (0, 0, 1.0)$，$T = 1.0$，$N = 40$。参考值为精确解 $R_{\\mathrm{ref}}(T) = \\exp\\left(\\widehat{(0,0,1.0)}\\,T\\right)$。\n3. 单轴时变对易情况：$\\omega(t) = (2.0\\,t, 0, 0)$，$T = 1.0$，$N = 100$。由于 $\\widehat{\\omega}(t)$ 始终沿同一轴，精确解为 $R_{\\mathrm{ref}}(T) = \\exp\\left(\\widehat{\\left(\\frac{2.0}{2}T^2, 0, 0\\right)}\\right)$。\n4. 非对易振荡情况：$\\omega(t) = (\\sin t, \\cos t, 0)$，$T = 2\\pi$，$N = 400$。参考值为使用相同 BCH 方法在 $N_{\\mathrm{ref}} = 20000$ 的条件下计算出的高分辨率数值解 $R_{\\mathrm{ref}}(T)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4]”）。每个结果必须是对应测试用例的 $\\varepsilon$ 的浮点值，以无量纲单位（矩阵范数）表示，并采用完整的 Python 默认浮点格式。不应打印任何其他文本。",
            "solution": "该问题要求在特殊正交群 $SO(3)$ 上为刚体动力学实现一个二阶李群积分器。分析与实现将按以下步骤进行：首先，我们将利用李代数 $\\mathfrak{so}(3)$ 的性质来简化积分器更新步骤的表达式。其次，我们将详细说明如何使用所提供的 Rodrigues 公式来实现矩阵指数映射，并特别注意数值稳定性。最后，我们将概述待实现的完整算法。\n\n控制常微分方程是一个在 $SO(3)$ 上的右不变系统：\n$$\n\\dot{R}(t) = R(t) \\widehat{\\omega}(t), \\quad R(0) = I_3\n$$\n其中 $R(t) \\in SO(3)$ 是姿态矩阵，$\\omega(t) \\in \\mathbb{R}^3$ 是体角速度，而 $\\widehat{\\cdot}: \\mathbb{R}^3 \\to \\mathfrak{so}(3)$ 是帽同构。对于向量 $v = (v_1, v_2, v_3)^{\\top} \\in \\mathbb{R}^3$，该映射定义为：\n$$\n\\widehat{v} = \\begin{bmatrix}\n0  -v_3  v_2 \\\\\nv_3  0  -v_1 \\\\\n-v_2  v_1  0\n\\end{bmatrix}\n$$\n李代数 $\\mathfrak{so}(3)$ 是 $3 \\times 3$ 实斜对称矩阵的空间。$\\mathfrak{so}(3)$ 上的矩阵对易子通过恒等式 $[\\widehat{u}, \\widehat{v}] = \\widehat{u \\times v}$（对于任意 $u, v \\in \\mathbb{R}^3$）与 $\\mathbb{R}^3$ 中的叉积相对应。\n\n所提出的单步数值积分器使用以下公式将解从时间 $t_k$ 推进到 $t_{k+1} = t_k + h$：\n$$\nR_{k+1} = R_k \\exp(\\Omega_k)\n$$\n增量生成元 $\\Omega_k \\in \\mathfrak{so}(3)$ 使用二阶截断的 Baker–Campbell–Hausdorff (BCH) 公式计算：\n$$\n\\Omega_k = \\mathrm{BCH}_2\\!\\left(\\frac{h}{2}\\,\\widehat{\\omega}(t_k),\\,\\frac{h}{2}\\,\\widehat{\\omega}(t_{k+1})\\right) = X + Y + \\frac{1}{2}[X,Y]\n$$\n其中 $X = \\frac{h}{2}\\,\\widehat{\\omega}(t_k)$ 且 $Y = \\frac{h}{2}\\,\\widehat{\\omega}(t_{k+1})$。\n\n我们可以推导出 $\\Omega_k$ 的一个计算上更高效的形式。令 $\\omega_k = \\omega(t_k)$ 和 $\\omega_{k+1} = \\omega(t_{k+1})$。利用帽映射的线性性质（$\\widehat{\\alpha u + \\beta v} = \\alpha\\widehat{u} + \\beta\\widehat{v}$）和对易子恒等式，我们可以将 $\\Omega_k$ 重写如下：\n$$\n\\Omega_k = \\frac{h}{2}\\widehat{\\omega}_k + \\frac{h}{2}\\widehat{\\omega}_{k+1} + \\frac{1}{2}\\left[\\frac{h}{2}\\widehat{\\omega}_k, \\frac{h}{2}\\widehat{\\omega}_{k+1}\\right]\n$$\n$$\n\\Omega_k = \\frac{h}{2}(\\widehat{\\omega}_k + \\widehat{\\omega}_{k+1}) + \\frac{h^2}{8}[\\widehat{\\omega}_k, \\widehat{\\omega}_{k+1}]\n$$\n$$\n\\Omega_k = \\widehat{\\frac{h}{2}(\\omega_k + \\omega_{k+1})} + \\frac{h^2}{8}\\widehat{(\\omega_k \\times \\omega_{k+1})}\n$$\n$$\n\\Omega_k = \\widehat{\\left( \\frac{h}{2}(\\omega_k + \\omega_{k+1}) + \\frac{h^2}{8}(\\omega_k \\times \\omega_{k+1}) \\right)}\n$$\n此结果表明，矩阵 $\\Omega_k$ 是单个向量的帽映射，我们将其记为 $\\delta v_k$：\n$$\n\\delta v_k = \\frac{h}{2}(\\omega_k + \\omega_{k+1}) + \\frac{h^2}{8}(\\omega_k \\times \\omega_{k+1})\n$$\n因此，$\\Omega_k$ 的计算简化为计算向量 $\\delta v_k$ 然后应用帽映射，即 $\\Omega_k = \\widehat{\\delta v_k}$。这避免了为计算对易子而进行的显式矩阵乘法。\n\n下一步是计算矩阵指数 $\\exp(\\Omega_k) = \\exp(\\widehat{\\delta v_k})$。这通过对一个通用的 $\\widehat{v} \\in \\mathfrak{so}(3)$ 使用 Rodrigues 公式来完成：\n$$\n\\exp(\\widehat{v}) = I_3 + \\frac{\\sin \\theta}{\\theta}\\,\\widehat{v} + \\frac{1 - \\cos \\theta}{\\theta^2}\\,\\widehat{v}^2, \\quad \\theta = \\|v\\|_2\n$$\n直接实现此公式可能因除以零或灾难性抵消而导致在 $\\theta$ 值较小时出现数值不稳定性。为确保鲁棒性，我们通过使用系数的泰勒级数展开来处理 $\\theta$ 接近零的情况：\n- 对于 $\\theta \\approx 0$，$\\frac{\\sin \\theta}{\\theta} \\approx 1 - \\frac{\\theta^2}{6} + \\frac{\\theta^4}{120}$\n- 对于 $\\theta \\approx 0$，$\\frac{1 - \\cos \\theta}{\\theta^2} \\approx \\frac{1}{2} - \\frac{\\theta^2}{24} + \\frac{\\theta^4}{720}$\n可以使用一个阈值，例如 $\\theta  10^{-8}$，在直接公式和泰勒级数近似之间切换。如果 $\\theta = 0$，则 $v=0$，$\\widehat{v}=0$，且 $\\exp(\\widehat{v}) = I_3$。\n\n完整的积分算法如下：\n1. 初始化 $R_0 = I_3$ 和 $t_0 = 0$。步长为 $h = T/N$。\n2. 对于 $k$ 从 $0$ 到 $N-1$：\n    a. 确定时间点 $t_k = k h$ 和 $t_{k+1} = (k+1)h$。\n    b. 计算角速度 $\\omega_k = \\omega(t_k)$ 和 $\\omega_{k+1} = \\omega(t_{k+1})$。\n    c. 计算增量向量 $\\delta v_k = \\frac{h}{2}(\\omega_k + \\omega_{k+1}) + \\frac{h^2}{8}(\\omega_k \\times \\omega_{k+1})$。\n    d. 使用稳定的 Rodrigues 公式计算增量旋转矩阵 $\\Delta R_k = \\exp(\\widehat{\\delta v_k})$。\n    e. 更新姿态：$R_{k+1} = R_k \\Delta R_k$。\n3. 在时间 $T$ 的最终姿态是 $R_N$。\n\n对于每个测试用例，将计算出的 $R(T) = R_N$ 与参考解 $R_{\\mathrm{ref}}(T)$ 进行比较。误差由两者之差的 Frobenius 范数量化：\n$$\n\\varepsilon = \\|R(T) - R_{\\mathrm{ref}}(T)\\|_F = \\sqrt{\\sum_{i=1}^3 \\sum_{j=1}^3 (R_{ij}(T) - (R_{\\mathrm{ref}})_{ij}(T))^2}\n$$\n实现将遵循这些原则来解决所提供的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a second-order Lie group integrator for SO(3) and evaluates it on a test suite.\n    \"\"\"\n\n    def hat(v):\n        \"\"\"\n        Maps a 3D vector to its corresponding 3x3 skew-symmetric matrix.\n        v: A 3-element array-like object.\n        Returns: A 3x3 numpy array.\n        \"\"\"\n        v = np.asarray(v)\n        return np.array([\n            [0, -v[2], v[1]],\n            [v[2], 0, -v[0]],\n            [-v[1], v[0], 0]\n        ])\n\n    def exp_so3(v):\n        \"\"\"\n        Computes the matrix exponential for so(3) using Rodrigues' formula.\n        Handles the small-angle case for numerical stability.\n        v: A 3-element array-like object representing the rotation vector.\n        Returns: A 3x3 rotation matrix.\n        \"\"\"\n        v = np.asarray(v)\n        v_hat = hat(v)\n        theta = np.linalg.norm(v)\n\n        # Handle the case theta - 0 to avoid division by zero and loss of precision.\n        # A threshold is used to switch to a Taylor series approximation.\n        if theta  1e-9:\n            # For small theta, use Taylor series for the coefficients.\n            # A = sin(theta)/theta ≈ 1 - theta^2/6 + theta^4/120\n            # B = (1-cos(theta))/theta^2 ≈ 1/2 - theta^2/24 + theta^4/720\n            theta2 = theta**2\n            theta4 = theta**4\n            A = 1.0 - theta2 / 6.0 + theta4 / 120.0\n            B = 0.5 - theta2 / 24.0 + theta4 / 720.0\n        else:\n            A = np.sin(theta) / theta\n            B = (1.0 - np.cos(theta)) / (theta**2)\n\n        return np.identity(3) + A * v_hat + B * np.dot(v_hat, v_hat)\n\n    def run_integration(omega_func, T, N):\n        \"\"\"\n        Performs the numerical integration of the dynamics equation.\n        omega_func: A function that takes time t and returns the angular velocity vector.\n        T: Final time.\n        N: Number of steps.\n        Returns: The final rotation matrix R(T).\n        \"\"\"\n        h = T / N\n        R = np.identity(3)\n        \n        for k in range(N):\n            t_k = k * h\n            t_k_plus_1 = (k + 1) * h\n            \n            omega_k = np.asarray(omega_func(t_k))\n            omega_k_plus_1 = np.asarray(omega_func(t_k_plus_1))\n            \n            # Compute the increment vector delta_v_k based on the BCH formula simplification\n            delta_v_k = (h / 2.0) * (omega_k + omega_k_plus_1) + \\\n                        (h**2 / 8.0) * np.cross(omega_k, omega_k_plus_1)\n            \n            # Compute the incremental rotation and update the orientation\n            delta_R_k = exp_so3(delta_v_k)\n            R = np.dot(R, delta_R_k)\n            \n        return R\n\n    def frobenius_norm_diff(A, B):\n        \"\"\"\n        Computes the Frobenius norm of the difference between two matrices.\n        \"\"\"\n        return np.linalg.norm(A - B, 'fro')\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"omega_func\": lambda t: np.array([0.0, 0.0, 0.0]),\n            \"T\": 1.0, \"N\": 10,\n            \"ref_func\": lambda T, N: np.identity(3)\n        },\n        {\n            \"omega_func\": lambda t: np.array([0.0, 0.0, 1.0]),\n            \"T\": 1.0, \"N\": 40,\n            \"ref_func\": lambda T, N: exp_so3(np.array([0.0, 0.0, 1.0]) * T)\n        },\n        {\n            \"omega_func\": lambda t: np.array([2.0 * t, 0.0, 0.0]),\n            \"T\": 1.0, \"N\": 100,\n            \"ref_func\": lambda T, N: exp_so3(np.array([0.5 * 2.0 * T**2, 0.0, 0.0]))\n        },\n        {\n            \"omega_func\": lambda t: np.array([np.sin(t), np.cos(t), 0.0]),\n            \"T\": 2.0 * np.pi, \"N\": 400,\n            \"ref_func\": lambda T, N: run_integration(lambda t: np.array([np.sin(t), np.cos(t), 0.0]), T, 20000)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Run the integrator for the current test case\n        R_T = run_integration(case[\"omega_func\"], case[\"T\"], case[\"N\"])\n        \n        # Compute the reference solution\n        R_ref = case[\"ref_func\"](case[\"T\"], case[\"N\"])\n        \n        # Calculate the Frobenius norm of the error\n        error = frobenius_norm_diff(R_T, R_ref)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}