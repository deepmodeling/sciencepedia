{
    "hands_on_practices": [
        {
            "introduction": "这第一个练习是基础性的。它要求你从第一性原理出发，为一个可分离的哈密顿系统实现速度-Verlet算法。通过将你实现的方法应用于几个标准的物理模型，你将执行必要的验证检查，包括长期能量守恒和时间可逆性，这些都是这种几何积分法的标志性特征。",
            "id": "3782600",
            "problem": "考虑一个可分哈密顿系统，其位形向量为 $q \\in \\mathbb{R}^d$，动量向量为 $p \\in \\mathbb{R}^d$，对角质量矩阵为 $M = \\mathrm{diag}(m_1,\\dots,m_d)$ 且对角元 $m_i$ 严格为正，哈密顿量为\n$$\nH(q,p) = T(p) + V(q), \\quad T(p) = \\frac{1}{2} \\sum_{i=1}^d \\frac{p_i^2}{m_i}, \\quad V(q) \\in C^2(\\mathbb{R}^d,\\mathbb{R}).\n$$\n哈密顿方程为\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p}(q,p), \\qquad \\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q}(q,p).\n$$\n对于可分的 $H$，这可以简化为\n$$\n\\frac{dq}{dt} = M^{-1} p, \\qquad \\frac{dp}{dt} = -\\nabla V(q).\n$$\n速度Verlet（也称为Störmer-Verlet）方法是一种二阶、保辛、时间可逆的积分器，通过对动能部分和势能部分的精确流进行对称组合得到。您的任务是从第一性原理出发，基于哈密顿方程和可分性假设，实现速度Verlet方法，并为 $(q,p)$ 和半步动量设计高效的存储模式。您必须：\n- 从 $T$ 和 $V$ 的精确流推导该方法，并编写清晰的伪代码，标明力计算 $F(q) = -\\nabla V(q)$ 发生的精确位置。\n- 指定并实现一种高效的存储和更新策略，用于处理整数步上的 $(q,p)$ 和半步动量 $p_{n+\\frac{1}{2}}$。\n- 在您的实现中加入计数功能，以统计力的计算次数，并验证在使用缓存时每一步的预期计数值。\n\n本问题中的所有量都是无量纲的；不需要物理单位。\n\n算法设计约束：\n- 假设 $M$ 是对角的且先验已知；通过逐分量除法隐式地使用 $M^{-1}$。\n- 使用定义 $F(q) = -\\nabla V(q)$。\n- 实现力缓存以避免在单步内对 $q_n$ 进行重复计算，即重用上一次计算的 $F(q_n)$ 来计算 $p_{n+\\frac{1}{2}}$。\n\n测试套件：\n实现您的程序，对以下四个测试用例运行速度Verlet方法。对于每个用例，计算并报告以下指标：\n1. 轨迹上的最大绝对能量偏差，\n$$\n\\Delta H_{\\max} = \\max_{0 \\le k \\le N} \\left| H(q_k,p_k) - H(q_0,p_0) \\right|.\n$$\n2. 最终绝对能量偏差，\n$$\n\\Delta H_{\\mathrm{final}} = \\left| H(q_N,p_N) - H(q_0,p_0) \\right|.\n$$\n3. 时间反演误差，通过先以步长 $h$ 向前积分 $N$ 步，再以步长 $-h$ 向后积分 $N$ 步来测量，并报告\n$$\n\\varepsilon_{\\mathrm{rev}} = \\left\\| q_{\\mathrm{back}} - q_0 \\right\\|_2 + \\left\\| p_{\\mathrm{back}} - p_0 \\right\\|_2,\n$$\n其中 $(q_{\\mathrm{back}},p_{\\mathrm{back}})$ 是向后积分后的状态。\n4. 一个布尔值，指示当在循环内部使用 $F(q_n)$ 缓存时，统计的力计算次数是否等于 $N+1$。\n\n提供以下测试用例：\n- 用例A（一维谐振子）：$d=1$, $m_1 = 1$, $V(q) = \\frac{1}{2} k q^2$ 其中 $k=1$, $q_0 = 1$, $p_0 = 0$, 步长 $h = 0.1$, 步数 $N = 1000$。\n- 用例B（一维四次振子）：$d=1$, $m_1 = 1$, $V(q) = \\frac{1}{4} q^4$, $q_0 = 1$, $p_0 = 0$, $h = 0.05$, $N = 1000$。\n- 用例C（一维自由粒子）：$d=1$, $m_1 = 2$, $V(q) \\equiv 0$, $q_0 = 3$, $p_0 = 4$, $h = 0.2$, $N = 100$。\n- 用例D（二维各向异性谐振子）：$d=2$, $m_1 = 1$, $m_2 = 2$, $V(q) = \\frac{1}{2} (k_1 q_1^2 + k_2 q_2^2)$ 其中 $k_1 = 1$, $k_2 = 0.5$, $q_0 = (1,2)$, $p_0 = (0,0.5)$, $h = 0.07$, $N = 800$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含从用例A到用例D的上述四个指标，并展开成一个单一列表：\n$$\n\\left[ \\Delta H_{\\max}^{(A)}, \\Delta H_{\\mathrm{final}}^{(A)}, \\varepsilon_{\\mathrm{rev}}^{(A)}, \\text{force\\_count\\_ok}^{(A)}, \\Delta H_{\\max}^{(B)}, \\Delta H_{\\mathrm{final}}^{(B)}, \\varepsilon_{\\mathrm{rev}}^{(B)}, \\text{force\\_count\\_ok}^{(B)}, \\Delta H_{\\max}^{(C)}, \\Delta H_{\\mathrm{final}}^{(C)}, \\varepsilon_{\\mathrm{rev}}^{(C)}, \\text{force\\_count\\_ok}^{(C)}, \\Delta H_{\\max}^{(D)}, \\Delta H_{\\mathrm{final}}^{(D)}, \\varepsilon_{\\mathrm{rev}}^{(D)}, \\text{force\\_count\\_ok}^{(D)} \\right].\n$$\n每个 $\\Delta H_{\\max}$、$\\Delta H_{\\mathrm{final}}$ 和 $\\varepsilon_{\\mathrm{rev}}$ 都应打印为浮点数，每个 $\\text{force\\_count\\_ok}$ 都应打印为布尔值。\n\n您的程序必须是自包含的，并且不需要任何输入。它必须实现带有力缓存的速度Verlet方法，并按指定格式生成最终输出。",
            "solution": "该问题要求推导并实现用于可分哈密顿系统的速度Verlet（Störmer-Verlet）方法。实现必须通过四个测试用例进行基准测试，评估其能量守恒性、时间可逆性以及计算成本（力的计算次数）。\n\n首先，我们验证问题陈述的有效性。该问题设定在哈密顿力学和几何数值积分的成熟框架内。所有定义、方程、初始条件和参数均已提供，并且在数学和物理上是一致的。测试用例对应于标准的、无争议的物理模型（谐振子、自由粒子）。任务是具体的、客观的、可形式化的。因此，该问题被认为是有效的。\n\n我们继续解决问题，从积分器的推导开始。\n\n**速度Verlet方法的推导**\n\n系统由一个可分哈密顿量 $H(q,p) = T(p) + V(q)$ 描述，其中 $T(p) = \\frac{1}{2} p^T M^{-1} p$ 是动能，$V(q)$ 是势能。哈密顿方程为：\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p} = M^{-1}p\n$$\n$$\n\\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q} = -\\nabla V(q) = F(q)\n$$\n在一个时间步长 $h$ 上的形式解由流算子 $\\Phi_H^h$ 给出，使得 $(q(t+h), p(t+h)) = \\Phi_H^h(q(t), p(t))$。由于哈密顿量是可分的，我们可以将流分解为两部分：\n1.  对应于动能部分 $T(p)$ 的流 $\\Phi_T^t$，它求解 $\\dot{q} = M^{-1}p$ 和 $\\dot{p} = 0$。其精确解为：\n    $$\n    \\Phi_T^t(q_0, p_0) = (q_0 + t M^{-1} p_0, p_0)\n    $$\n2.  对应于势能部分 $V(q)$ 的流 $\\Phi_V^t$，它求解 $\\dot{q} = 0$ 和 $\\dot{p} = F(q)$。其精确解为：\n    $$\n    \\Phi_V^t(q_0, p_0) = (q_0, p_0 + t F(q_0))\n    $$\n\n速度Verlet方法是一种二阶积分器，源于对哈密顿算子的对称Strang分裂。一个步长 $h$ 的流通过组合各组成部分的精确流来近似：\n$$\n\\Phi_H^h \\approx \\Phi_V^{h/2} \\circ \\Phi_T^h \\circ \\Phi_V^{h/2}\n$$\n设 $(q_n, p_n)$ 是在时间 $t_n$ 的状态。为了计算在时间 $t_{n+1} = t_n+h$ 的状态 $(q_{n+1}, p_{n+1})$，我们应用以下组合序列：\n\n1.  **动量的第一个半步：** 将流 $\\Phi_V^{h/2}$ 应用于 $(q_n, p_n)$。\n    $$\n    (q', p') = \\Phi_V^{h/2}(q_n, p_n) = (q_n, p_n + \\frac{h}{2} F(q_n))\n    $$\n    我们将中间动量表示为 $p_{n+\\frac{1}{2}} = p_n + \\frac{h}{2} F(q_n)$。此时状态为 $(q_n, p_{n+\\frac{1}{2}})$。此步骤需要在 $q_n$ 处进行一次力计算。\n\n2.  **位置的完整一步：** 将流 $\\Phi_T^h$ 应用于中间状态 $(q_n, p_{n+\\frac{1}{2}})$。\n    $$\n    (q'', p'') = \\Phi_T^h(q_n, p_{n+\\frac{1}{2}}) = (q_n + h M^{-1} p_{n+\\frac{1}{2}}, p_{n+\\frac{1}{2}})\n    $$\n    这定义了新位置 $q_{n+1} = q_n + h M^{-1} p_{n+\\frac{1}{2}}$。此时状态为 $(q_{n+1}, p_{n+\\frac{1}{2}})$。\n\n3.  **动量的第二个半步：** 将流 $\\Phi_V^{h/2}$ 应用于状态 $(q_{n+1}, p_{n+\\frac{1}{2}})$。\n    $$\n    (q_{n+1}, p_{n+1}) = \\Phi_V^{h/2}(q_{n+1}, p_{n+\\frac{1}{2}}) = (q_{n+1}, p_{n+\\frac{1}{2}} + \\frac{h}{2} F(q_{n+1}))\n    $$\n    这定义了最终动量 $p_{n+1}$。此步骤需要在新位置 $q_{n+1}$ 进行第二次力计算。\n\n**算法实现与力缓存**\n\n结合以上步骤即可得到速度Verlet算法。我们以一种突出计算流程和存储的方式来编写它。变量 $p_{n+\\frac{1}{2}}$ 是一个中间量，不需要在时间步之间存储。\n\n从 $(q_n, p_n)$ 到 $(q_{n+1}, p_{n+1})$ 的单步过程如下：\n1.  计算 $p_{n+\\frac{1}{2}} = p_n + \\frac{h}{2} F(q_n)$。\n2.  计算 $q_{n+1} = q_n + h M^{-1} p_{n+\\frac{1}{2}}$。\n3.  在新位置计算力 $F(q_{n+1})$。\n4.  计算 $p_{n+1} = p_{n+\\frac{1}{2}} + \\frac{h}{2} F(q_{n+1})$。\n\n为了通过力缓存高效地实现这一点，我们观察到步骤1中所需的力 $F(q_n)$ 与上一个时间步结束时（在步骤3中）计算的力 $F(q_{n-1+1})$ 相同。这使得我们在主积分循环中每步只进行一次力计算。在循环开始前需要进行一次初始的力计算。\n\n积分 $N$ 步的伪代码如下：\n\n**算法：带有力缓存的速度Verlet**\n1.  **初始化：**\n    *   设置初始状态：$q \\leftarrow q_0, p \\leftarrow p_0$。\n    *   初始化力缓存：`force_cache` $\\leftarrow F(q_0)$。\n    *   初始化计数器：`force_eval_count` $\\leftarrow 1$。\n\n2.  **积分循环：** 对于 $n$ 从 $0$ 到 $N-1$：\n    *   （a）使用缓存的力更新动量半步：\n        $p \\leftarrow p + \\frac{h}{2} \\cdot \\text{force\\_cache}$。\n        （*此时，$p$ 保持 $p_{n+\\frac{1}{2}}$ 的值*）。\n    *   （b）更新位置一整步：\n        $q \\leftarrow q + h \\cdot M^{-1}p$。\n        （*此时，$q$ 保持 $q_{n+1}$ 的值*）。\n    *   （c）计算新的力并更新缓存：\n        `force_cache` $\\leftarrow F(q)$。\n        `force_eval_count` $\\leftarrow$ `force_eval_count` $+ 1$。\n    *   （d）用第二个半步完成动量更新：\n        $p \\leftarrow p + \\frac{h}{2} \\cdot \\text{force\\_cache}$。\n        （*此时，$(q,p)$ 保持 $(q_{n+1}, p_{n+1})$ 的值*）。\n\n3.  **终止：** 最终状态为 $(q, p)$，总力计算次数为 `force_eval_count`。对于 $N$ 步，此计数值将为 $N+1$。\n\n**指标计算**\n-   **能量偏差**：在整个前向积分过程中，在每一步 $k=0, \\dots, N$ 都会计算哈密顿量 $H(q_k, p_k)$。$\\Delta H_{\\max}$ 是与初始能量 $H(q_0, p_0)$ 的最大绝对差值，而 $\\Delta H_{\\mathrm{final}}$ 是在最终步骤 $N$ 的绝对差值。\n-   **时间可逆性**：该方法的时间可逆性是其对称组合的结果。为了进行数值测试，我们从 $(q_0, p_0)$ 开始，用步长 $h$ 向前积分 $N$ 步得到 $(q_N, p_N)$。然后，我们从 $(q_N, p_N)$ 开始，用步长 $-h$ 向后积分 $N$ 步。得到的状态 $(q_{\\mathrm{back}}, p_{\\mathrm{back}})$ 应接近 $(q_0, p_0)$。误差 $\\varepsilon_{\\mathrm{rev}} = \\left\\| q_{\\mathrm{back}} - q_0 \\right\\|_2 + \\left\\| p_{\\mathrm{back}} - p_0 \\right\\|_2$ 衡量了这种偏差，对于时间可逆方法，该误差预期在机器精度量级。\n\n接下来的实现将为四个测试用例中的每一个定义具体的哈密顿量、势能和力函数，然后应用上述算法来计算所需的指标。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that defines test cases, runs the simulations,\n    and prints the results in the required format.\n    \"\"\"\n\n    def integrator(V_func, F_func, m, q_start, p_start, h, N):\n        \"\"\"\n        Generic velocity-Verlet integrator.\n\n        Args:\n            V_func: Potential energy function V(q).\n            F_func: Force function F(q) = -grad(V).\n            m: Mass vector (diagonal of mass matrix).\n            q_start: Initial position vector.\n            p_start: Initial momentum vector.\n            h: Time step size.\n            N: Number of steps.\n\n        Returns:\n            A tuple containing:\n            - q_final (np.array): Final position.\n            - p_final (np.array): Final momentum.\n            - H_history (list): History of Hamiltonian values at each step.\n            - force_eval_count (int): Total number of force evaluations.\n        \"\"\"\n        q = q_start.copy()\n        p = p_start.copy()\n\n        def hamiltonian(pos, mom):\n            kinetic = 0.5 * np.sum(mom**2 / m)\n            potential = V_func(pos)\n            return kinetic + potential\n\n        H_history = [hamiltonian(q, p)]\n        \n        # Initial force evaluation before the loop\n        force = F_func(q)\n        force_eval_count = 1\n\n        for _ in range(N):\n            # 1. Half-step momentum update\n            p += 0.5 * h * force\n            \n            # 2. Full-step position update\n            q += h * (p / m)\n            \n            # 3. Compute new force (and count it)\n            force = F_func(q)\n            force_eval_count += 1\n            \n            # 4. Second half-step momentum update\n            p += 0.5 * h * force\n            \n            H_history.append(hamiltonian(q,p))\n\n        return q, p, H_history, force_eval_count\n\n    def run_case(case_params):\n        \"\"\"\n        Runs a single test case and computes all required metrics.\n        \"\"\"\n        d = case_params['d']\n        m = case_params['m']\n        V_func = case_params['V']\n        F_func = case_params['F']\n        q0 = case_params['q0']\n        p0 = case_params['p0']\n        h = case_params['h']\n        N = case_params['N']\n        \n        # Ensure inputs are numpy arrays for consistent vector operations\n        m = np.array(m, dtype=float)\n        q0 = np.array(q0, dtype=float)\n        p0 = np.array(p0, dtype=float)\n\n        # 1. Forward integration\n        q_final, p_final, H_history, force_evals = integrator(V_func, F_func, m, q0, p0, h, N)\n        \n        H0 = H_history[0]\n        H_final = H_history[-1]\n        \n        # Metric 1: Max absolute energy deviation\n        delta_H_max = np.max(np.abs(np.array(H_history) - H0))\n        \n        # Metric 2: Final absolute energy deviation\n        delta_H_final = np.abs(H_final - H0)\n        \n        # Metric 4: Force evaluation count check\n        force_count_ok = (force_evals == N + 1)\n        \n        # 2. Backward integration for time reversal error\n        q_back, p_back, _, _ = integrator(V_func, F_func, m, q_final, p_final, -h, N)\n        \n        # Metric 3: Time-reversal error\n        eps_rev = np.linalg.norm(q_back - q0) + np.linalg.norm(p_back - p0)\n        \n        return delta_H_max, delta_H_final, eps_rev, force_count_ok\n\n    # Define the four test cases\n    test_cases = [\n        # Case A: 1D Harmonic Oscillator\n        {\n            'd': 1, 'm': [1.0], 'k': 1.0,\n            'V': lambda q, k=1.0: 0.5 * k * q[0]**2,\n            'F': lambda q, k=1.0: np.array([-k * q[0]]),\n            'q0': [1.0], 'p0': [0.0], 'h': 0.1, 'N': 1000\n        },\n        # Case B: 1D Quartic Oscillator\n        {\n            'd': 1, 'm': [1.0],\n            'V': lambda q: 0.25 * q[0]**4,\n            'F': lambda q: np.array([-q[0]**3]),\n            'q0': [1.0], 'p0': [0.0], 'h': 0.05, 'N': 1000\n        },\n        # Case C: 1D Free Particle\n        {\n            'd': 1, 'm': [2.0],\n            'V': lambda q: 0.0,\n            'F': lambda q: np.array([0.0]),\n            'q0': [3.0], 'p0': [4.0], 'h': 0.2, 'N': 100\n        },\n        # Case D: 2D Anisotropic Harmonic Oscillator\n        {\n            'd': 2, 'm': [1.0, 2.0], 'k': [1.0, 0.5],\n            'V': lambda q, k1=1.0, k2=0.5: 0.5 * (k1 * q[0]**2 + k2 * q[1]**2),\n            'F': lambda q, k1=1.0, k2=0.5: np.array([-k1 * q[0], -k2 * q[1]]),\n            'q0': [1.0, 2.0], 'p0': [0.0, 0.5], 'h': 0.07, 'N': 800\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = run_case(case)\n        all_results.extend(results)\n\n    # Format and print the final output string\n    result_str = ','.join(map(str, all_results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然Störmer-Verlet方法以其出色的长期能量稳定性而闻名，但它终究是一种近似。本练习将指导你设计一个数值实验，以经验性地衡量该方法的精度。通过分析能量误差如何随步长 $h$ 缩放，你将验证该方法的二阶收敛性，这是其性能的一个关键方面。",
            "id": "3782626",
            "problem": "考虑一个可分哈密顿系统，其广义位置为 $q \\in \\mathbb{R}^d$，共轭动量为 $p \\in \\mathbb{R}^d$，哈密顿量由 $H(q,p) = T(p) + V(q)$ 给出，其中 $T(p)$ 是动能，$V(q)$ 是势能。其正则运动方程为 $\\dot{q} = \\partial H / \\partial p$ 和 $\\dot{p} = -\\partial H / \\partial q$。Störmer-Verlet 方法是用于此类可分哈密顿量的一种辛的、时间可逆的数值积分器。设计并实现一个数值实验，通过改变时间步长 $h$ 来凭经验证明，对于固定的时间区间，Störmer-Verlet 方法的最大绝对能量误差的标度为 $O(h^2)$。\n\n您的程序必须实现 Störmer-Verlet 方法来对以下四个测试系统进行积分，每个系统都指定了无量纲参数和初始数据。所有能量和时间都以无量纲单位处理，角度必须以弧度为单位。\n\n1. 一维谐振子：$H(q,p) = \\frac{p^2}{2m} + \\frac{k}{2} q^2$，其中 $m = 1$, $k = 1$, $q(0) = 1$, $p(0) = 0$。\n2. 非线性摆：$H(q,p) = \\frac{p^2}{2m} + mgL \\left(1 - \\cos(q)\\right)$，其中 $m = 1$, $g = 1$, $L = 1$, $q(0) = 1$ (弧度), $p(0) = 0$。\n3. 一维双阱势：$H(q,p) = \\frac{p^2}{2m} + \\frac{1}{4}\\left(q^2 - 1\\right)^2$，其中 $m = 1$, $q(0) = 0$, $p(0) = 1$。\n4. 二维各向异性谐振子：$H(q,p) = \\frac{p_1^2}{2m_1} + \\frac{p_2^2}{2m_2} + \\frac{k_1}{2} q_1^2 + \\frac{k_2}{2} q_2^2$，其中 $m_1 = 1$, $m_2 = 2$, $k_1 = 1$, $k_2 = 4$, $q(0) = (1, 0.5)$, $p(0) = (0, 0)$。\n\n对于每个系统，在固定的时间区间 $[0, T]$（其中 $T = 50$）上进行积分。对于集合 $\\{0.4, 0.2, 0.1, 0.05, 0.025\\}$ 中的每个时间步长 $h$，定义 $N = \\operatorname{round}(T / h)$ 并使用由此产生的均匀步长 $\\tilde{h} = T / N$。对于每个 $\\tilde{h}$，使用 Störmer-Verlet 方法计算离散轨迹 $\\{(q_n, p_n)\\}_{n=0}^N$，并评估最大绝对能量偏差\n$$\n\\Delta H_{\\max}(\\tilde{h}) = \\max_{0 \\le n \\le N} \\left| H(q_n, p_n) - H(q_0, p_0) \\right|.\n$$\n通过对数据点对 $\\left(\\log(\\tilde{h}), \\log\\left(\\Delta H_{\\max}(\\tilde{h})\\right)\\right)$ 进行最小二乘线性拟合来估计标度指数 $p$，即拟合 $\\log\\left(\\Delta H_{\\max}(\\tilde{h})\\right) \\approx a + p \\log(\\tilde{h})$ 并报告斜率 $p$。\n\n测试套件和答案规范：\n- 使用上面列出的四个系统，固定的结束时间 $T = 50$，以及步长 $h \\in \\{0.4, 0.2, 0.1, 0.05, 0.025\\}$。\n- 对每个系统，按所述方法计算斜率 $p$。\n- 您的程序应生成单行输出，其中包含按上述四个系统顺序列出的斜率，四舍五入到三位小数，并以逗号分隔的列表形式包含在方括号中，例如 $[p_1, p_2, p_3, p_4]$。",
            "solution": "该问题要求设计一个数值实验，以凭经验验证 Störmer-Verlet 方法在能量守恒方面对几个可分哈密顿系统的精度阶。任务的核心是实现积分器，用一组递减的时间步长模拟动力学过程，测量最大能量偏差，然后使用对数-对数回归来估计标度指数，理论上该指数应为 $2$。\n\n首先，我们将物理和数值框架形式化。一个可分哈密顿系统由一个哈密顿函数 $H(q, p)$ 描述，该函数可以分解为一个只依赖于动量 $p \\in \\mathbb{R}^d$ 的动能项 $T(p)$ 和一个只依赖于位置 $q \\in \\mathbb{R}^d$ 的势能项 $V(q)$，使得 $H(q, p) = T(p) + V(q)$。系统的时间演化由哈密顿方程决定：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = \\nabla_p T(p)\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q} = -\\nabla_q V(q) \\equiv F(q)\n$$\n其中 $F(q)$ 是力。对于所讨论的系统，动能具有标准二次型 $T(p) = \\frac{1}{2} p^T M^{-1} p$，其中 $M$ 是（通常为对角）质量矩阵。这得到 $\\nabla_p T(p) = M^{-1}p$。\n\nStörmer-Verlet 方法是一种几何积分器，具体来说是一种二阶辛方法，因其在应用于此类系统时具有出色的长期能量稳定性而闻名。该算法的位置 Verlet 变体使用以下三个步骤将时间 $t_n$ 的状态 $(q_n, p_n)$推进到时间 $t_{n+1} = t_n + \\tilde{h}$ 的状态 $(q_{n+1}, p_{n+1})$：\n1. 动量的半步更新：$p_{n+1/2} = p_n + \\frac{\\tilde{h}}{2} F(q_n)$\n2. 位置的全步更新：$q_{n+1} = q_n + \\tilde{h} M^{-1} p_{n+1/2}$\n3. 动量的最终半步更新：$p_{n+1} = p_{n+1/2} + \\frac{\\tilde{h}}{2} F(q_{n+1})$\n\n该数值实验旨在证明哈密顿量的最大误差 $\\Delta H_{\\max}(\\tilde{h}) = \\max_{0 \\le n \\le N} |H(q_n, p_n) - H(q_0, p_0)|$ 与步长成二次方关系，即 $\\Delta H_{\\max}(\\tilde{h}) = O(\\tilde{h}^2)$。这种关系意味着 $\\log(\\Delta H_{\\max})$ 相对于 $\\log(\\tilde{h})$ 的图应近似为一条斜率为 $2$ 的直线。我们通过对一组步长 $\\tilde{h}$ 的模拟所生成的数据点 $(\\log(\\tilde{h}), \\log(\\Delta H_{\\max}(\\tilde{h})))$ 进行线性最小二乘拟合来估计这个斜率，记为 $p$。问题指定了一组初始步长 $h \\in \\{0.4, 0.2, 0.1, 0.05, 0.025\\}$ 和总积分时间 $T = 50$。对于每个 $h$，步数为 $N = \\operatorname{round}(T/h)$，实际使用的步长为 $\\tilde{h} = T/N$。\n\n该实验针对四个不同的物理系统进行：\n\n1.  **一维谐振子**：$H(q,p) = \\frac{p^2}{2m} + \\frac{k}{2} q^2$。当 $m=1$ 且 $k=1$ 时，力为 $F(q) = -q$。质量矩阵是标量 $M=1$。初始条件为 $q(0)=1, p(0)=0$。\n\n2.  **非线性摆**：$H(q,p) = \\frac{p^2}{2m} + mgL(1 - \\cos(q))$。当 $m=1, g=1, L=1$ 时，力为 $F(q) = -\\sin(q)$，且 $M=1$。初始条件为 $q(0)=1, p(0)=0$。\n\n3.  **一维双阱势**：$H(q,p) = \\frac{p^2}{2m} + \\frac{1}{4}(q^2 - 1)^2$。当 $m=1$ 时，力为 $F(q) = - (q^3 - q) = q-q^3$，且 $M=1$。初始条件为 $q(0)=0, p(0)=1$。\n\n4.  **二维各向异性谐振子**：$H(q,p) = \\frac{p_1^2}{2m_1} + \\frac{p_2^2}{2m_2} + \\frac{k_1}{2} q_1^2 + \\frac{k_2}{2} q_2^2$。参数为 $m_1=1, m_2=2, k_1=1, k_2=4$ 时，力矢量为 $F(q) = (-k_1 q_1, -k_2 q_2) = (-q_1, -4q_2)$。质量矩阵为 $M = \\operatorname{diag}(m_1, m_2) = \\operatorname{diag}(1, 2)$。初始条件为 $q(0)=(1, 0.5), p(0)=(0, 0)$。\n\n对于每个系统，我们遍历指定的步长，执行 Störmer-Verlet 积分，计算最大能量误差，并收集对数-对数数据。对这些数据进行线性回归，得到所需的标度指数 $p$。最终输出包含为这四个系统计算出的指数，四舍五入到三位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Performs a numerical experiment to determine the energy error scaling\n    of the Störmer-Verlet method for four different Hamiltonian systems.\n    \"\"\"\n    T_final = 50.0\n    h_values = [0.4, 0.2, 0.1, 0.05, 0.025]\n\n    # Definitions for the four test systems\n    systems = [\n        # System 1: One-dimensional harmonic oscillator\n        {\n            \"name\": \"Harmonic Oscillator (1D)\",\n            \"q0\": np.array([1.0]),\n            \"p0\": np.array([0.0]),\n            \"masses\": np.array([1.0]),\n            \"force\": lambda q: -q,\n            \"potential\": lambda q: 0.5 * q[0]**2,\n        },\n        # System 2: Nonlinear pendulum\n        {\n            \"name\": \"Nonlinear Pendulum (1D)\",\n            \"q0\": np.array([1.0]),\n            \"p0\": np.array([0.0]),\n            \"masses\": np.array([1.0]),\n            \"force\": lambda q: -np.sin(q),\n            \"potential\": lambda q: 1.0 - np.cos(q[0]),\n        },\n        # System 3: One-dimensional double-well potential\n        {\n            \"name\": \"Double-Well Potential (1D)\",\n            \"q0\": np.array([0.0]),\n            \"p0\": np.array([1.0]),\n            \"masses\": np.array([1.0]),\n            \"force\": lambda q: q - q**3,\n            \"potential\": lambda q: 0.25 * (q[0]**2 - 1.0)**2,\n        },\n        # System 4: Two-dimensional anisotropic harmonic oscillator\n        {\n            \"name\": \"Anisotropic Oscillator (2D)\",\n            \"q0\": np.array([1.0, 0.5]),\n            \"p0\": np.array([0.0, 0.0]),\n            \"masses\": np.array([1.0, 2.0]),\n            \"force\": lambda q: np.array([-q[0], -4.0 * q[1]]),\n            \"potential\": lambda q: 0.5 * q[0]**2 + 2.0 * q[1]**2,\n        }\n    ]\n\n    slopes = []\n\n    for system_params in systems:\n        q0 = system_params[\"q0\"]\n        p0 = system_params[\"p0\"]\n        masses = system_params[\"masses\"]\n        force_func = system_params[\"force\"]\n        potential_func = system_params[\"potential\"]\n\n        def kinetic_func(p):\n            return np.sum(p**2 / (2.0 * masses))\n\n        def hamiltonian_func(q, p):\n            return kinetic_func(p) + potential_func(q)\n\n        log_h_tilde_list = []\n        log_delta_H_max_list = []\n\n        H0 = hamiltonian_func(q0, p0)\n\n        for h in h_values:\n            N = int(round(T_final / h))\n            h_tilde = T_final / N\n\n            q = np.copy(q0)\n            p = np.copy(p0)\n            \n            max_energy_error = 0.0\n\n            for _ in range(N):\n                # Störmer-Verlet (position-Verlet) integration step\n                p_half_step = p + 0.5 * h_tilde * force_func(q)\n                q = q + h_tilde * p_half_step / masses\n                p = p_half_step + 0.5 * h_tilde * force_func(q)\n\n                # Calculate energy error at the end of the step\n                H_current = hamiltonian_func(q, p)\n                energy_error = abs(H_current - H0)\n                if energy_error > max_energy_error:\n                    max_energy_error = energy_error\n            \n            log_h_tilde_list.append(np.log(h_tilde))\n            log_delta_H_max_list.append(np.log(max_energy_error))\n\n        # Perform linear regression on the log-log data to find the slope\n        lin_reg_result = linregress(log_h_tilde_list, log_delta_H_max_list)\n        slope = lin_reg_result.slope\n        slopes.append(slope)\n        \n    # Format the final results as specified\n    formatted_slopes = [f\"{s:.3f}\" for s in slopes]\n    print(f\"[{','.join(formatted_slopes)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Störmer-Verlet方法的卓越特性源于其辛性——即它能保持相空间的几何结构。这最后一个高级练习将挑战你为这一特性创建一个直接的数值诊断工具。你将近似计算单步映射的雅可比矩阵，并验证它是否满足辛条件，从而将抽象的数学定义与具体的计算测试联系起来。",
            "id": "3782583",
            "problem": "考虑一个可分的哈密顿系统，其位形变量为 $q \\in \\mathbb{R}^d$，动量为 $p \\in \\mathbb{R}^d$，因此状态为 $z = (q,p) \\in \\mathbb{R}^{2d}$。其动力学由可分哈密顿量 $H(q,p) = T(p) + V(q)$ 的哈密顿方程决定，其中 $T$ 是动能，$V$ 是势能，即 $\\dot{q} = \\nabla_p T(p)$ 和 $\\dot{p} = -\\nabla_q V(q)$。$\\mathbb{R}^{2d}$ 上的典范辛形式由常数矩阵 $J \\in \\mathbb{R}^{2d \\times 2d}$ 表示，其分块结构为 $J = \\begin{bmatrix} 0  I \\\\ -I  0 \\end{bmatrix}$，其中 $I$ 表示 $d \\times d$ 单位矩阵。一个光滑映射 $\\Phi_h : \\mathbb{R}^{2d} \\to \\mathbb{R}^{2d}$ 是辛的，当且仅当其雅可比矩阵 $D\\Phi_h(z)$ 满足其拉回保持典范辛形式的条件。\n\n仅使用这些基础事实，设计一个数值诊断工具，以评估应用于可分哈密顿量的 Störmer-Verlet 方法（也称为速度 Verlet 方法）所定义的单步映射的辛性。您的诊断工具必须在给定状态 $z$ 处，使用中心有限差分和小的扰动大小 $\\varepsilon$ 来近似雅可比矩阵 $D\\Phi_h(z)$，然后使用拉回的典范形式与典范形式之间差异的矩阵范数来量化与辛性的偏差。具体来说，您必须：\n- 为可分哈密顿量 $H(q,p) = T(p) + V(q)$ 实现一个正确的 Störmer-Verlet 单步映射，使用力 $f(q) = -\\nabla_q V(q)$ 和速度场 $v(p) = \\nabla_p T(p)$。\n- 在给定 $z$ 处，沿着 $\\mathbb{R}^{2d}$ 的标准基，使用固定的 $\\varepsilon = 10^{-7}$，通过中心有限差分近似雅可比矩阵 $D\\Phi_h(z)$。\n- 为适当的维度 $d$ 构造典范辛矩阵 $J$。\n- 在 $z$ 处构建辛性缺陷矩阵，并计算其弗罗贝尼乌斯范数（Frobenius norm）作为标量诊断值。您必须使用中心有限差分和弗罗贝尼乌斯范数，并且在任何出现角度的地方都必须使用以弧度为单位测量的角度。\n\n您必须将您的诊断工具应用于以下测试套件，并为每种情况返回一个实数，该实数等于 Störmer-Verlet 映射的辛性缺陷矩阵的弗罗贝尼乌斯范数：\n- 情况 $1$（单自由度谐振子）：设 $d=1$。设 $T(p) = \\tfrac{1}{2} p^2$ 和 $V(q) = \\tfrac{1}{2} \\omega^2 q^2$，其中 $\\omega = 1.7$。使用初始状态 $q = 0.3$, $p = -0.4$ 和步长 $h = 0.1$。\n- 情况 $2$（接近线性稳定性阈值的单自由度谐振子）：设 $d=1$。使用与情况 $1$ 相同的 $T$ 和 $V$，其中 $\\omega = 1.7$。使用相同的初始状态 $q = 0.3$, $p = -0.4$。使用步长 $h = 1.99/\\omega$。\n- 情况 $3$（处于平衡态的单自由度非线性摆）：设 $d=1$。设 $T(p) = \\tfrac{1}{2} p^2$ 和 $V(q) = 1 - \\cos(q)$。角度必须以弧度为单位。使用初始状态 $q = 0.0$, $p = 0.0$ 和步长 $h = 0.3$。\n- 情况 $4$（偏离平衡态的单自由度非线性摆）：设 $d=1$。使用与情况 $3$ 相同的 $T$ 和 $V$。使用初始状态 $q = 1.0$, $p = 0.2$（角度以弧度为单位）和步长 $h = 0.3$。\n- 情况 $5$（双自由度解耦谐振子）：设 $d=2$。设 $T(p) = \\tfrac{1}{2}(p_1^2 + p_2^2)$ 和 $V(q) = \\tfrac{1}{2}(\\omega_1^2 q_1^2 + \\omega_2^2 q_2^2)$，其中 $\\omega_1 = 1.0$ 和 $\\omega_2 = 1.5$。使用初始状态 $(q_1,q_2,p_1,p_2) = (0.2,-0.1,-0.3,0.4)$ 和步长 $h = 0.2$。\n\n所有量都是无量纲的，除了角度必须以弧度为单位。不需要其他物理单位。您的程序必须生成单行输出，其中包含按上述情况顺序排列的五个诊断结果，格式为逗号分隔的列表并用方括号括起来，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是按规定计算的情况 $i$ 的辛性缺陷矩阵的弗罗贝尼乌斯范数。结果必须是按要求顺序和格式打印的浮点数。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于哈密顿力学和几何数值积分的原理，问题设定适定，提供了所有必要的数据和条件，并且表述客观。该问题是计算物理学中一个标准且具有启发性的练习。\n\n任务是数值上验证 Störmer-Verlet 积分方法的辛性。一个动力学系统由一个可分的哈密顿量 $H(q,p) = T(p) + V(q)$ 描述，其中 $q \\in \\mathbb{R}^d$ 是广义坐标，$p \\in \\mathbb{R}^d$ 是共轭动量。系统的状态是 $2d$ 维相空间 $\\mathbb{R}^{2d}$ 中的一个点 $z = (q,p)$。系统的演化由哈密顿方程决定：\n$$\n\\dot{q} = \\nabla_p T(p)\n$$\n$$\n\\dot{p} = -\\nabla_q V(q)\n$$\n这组方程可以紧凑地写成 $\\dot{z} = X_H(z)$，其中 $X_H$ 是与 $H$ 相关联的哈密顿向量场。系统的精确流 $\\phi_t$ 是一个将初始状态 $z_0$ 映为时间 $t$ 后的状态 $z(t) = \\phi_t(z_0)$ 的映射。哈密顿流的一个关键性质是它们是辛的。一个映射 $\\Psi: \\mathbb{R}^{2d} \\to \\mathbb{R}^{2d}$ 是辛的，如果它保持典范辛二形式。以矩阵形式表示，这等价于其雅可比矩阵 $D\\Psi(z)$ 满足以下条件：\n$$\n(D\\Psi(z))^T J D\\Psi(z) = J\n$$\n对于所有 $z$，其中 $J$ 是 $2d \\times 2d$ 的典范辛矩阵，由下式给出：\n$$\nJ = \\begin{bmatrix} 0  I \\\\ -I  0 \\end{bmatrix}\n$$\n这里，$I$ 是 $d \\times d$ 单位矩阵，$0$ 是 $d \\times d$ 零矩阵。\n\n理想情况下，哈密顿系统的数值积分器也应产生辛映射，以保持相空间的几何结构，这能带来出色的长期稳定性和定性准确性。Störmer-Verlet 方法是这种几何积分器的一个著名例子。它的单步映射 $\\Phi_h: z_n \\to z_{n+1}$ 是精确辛的。此性质源于其通过哈密顿算子的对称分裂（称为 Trotter-Suzuki 分裂或李分裂 (Lie splitting)）的构造。具体来说，该方法是哈密顿量组成部分 $T(p)$ 和 $V(q)$ 的精确流的复合。对于从状态 $(q_n, p_n)$ 到 $(q_{n+1}, p_{n+1})$ 的步长为 $h$ 的 Störmer-Verlet 算法的速度 Verlet 形式如下：\n1.  在势能 $V$ 下更新动量半步：$p_{n+1/2} = p_n - \\frac{h}{2} \\nabla_q V(q_n)$\n2.  在动能 $T$ 下更新位置一整步：$q_{n+1} = q_n + h \\nabla_p T(p_{n+1/2})$\n3.  在势能 $V$ 下更新动量第二个半步：$p_{n+1} = p_{n+1/2} - \\frac{h}{2} \\nabla_q V(q_{n+1})$\n\n对于问题中给定的哈密顿量，动能具有标准形式 $T(p) = \\frac{1}{2} p^T p$，这得到 $\\nabla_p T(p) = p$。定义力为 $f(q) = -\\nabla_q V(q)$，单步映射 $\\Phi_h$ 实现如下：\n1.  $p_{n+1/2} = p_n + \\frac{h}{2} f(q_n)$\n2.  $q_{n+1} = q_n + h \\cdot p_{n+1/2}$\n3.  $p_{n+1} = p_{n+1/2} + \\frac{h}{2} f(q_{n+1})$\n\n用于评估辛性的诊断工具涉及在给定点 $z=(q,p)$ 处数值计算此映射的雅可比矩阵 $D\\Phi_h(z)$，然后量化其与辛条件的偏差。雅可比矩阵是一个 $2d \\times 2d$ 矩阵，其第 $j$ 列是映射输出对其输入第 $j$ 个分量的偏导数，即 $\\frac{\\partial \\Phi_h}{\\partial z_j}$。我们使用二阶精度的中心有限差分公式，以小扰动 $\\varepsilon = 10^{-7}$ 来近似这些列：\n$$\n\\frac{\\partial \\Phi_h}{\\partial z_j}(z) \\approx \\frac{\\Phi_h(z + \\varepsilon e_j) - \\Phi_h(z - \\varepsilon e_j)}{2\\varepsilon}\n$$\n其中 $e_j$ 是 $\\mathbb{R}^{2d}$ 中的第 $j$ 个标准基向量。\n\n设数值近似的雅可比矩阵为 $A$。然后我们构建辛性缺陷矩阵 $S$：\n$$\nS(z) = A^T J A - J\n$$\n理论上，对于一个精确辛映射和一个精确计算的雅可比矩阵，该矩阵将恒等于零。在实践中，使用有限差分近似和浮点运算将导致一个虽小但非零的矩阵。此缺陷的大小由其弗罗贝尼乌斯范数（Frobenius norm）$\\|S(z)\\|_F$ 来量化：\n$$\n\\|S(z)\\|_F = \\sqrt{\\sum_{i=1}^{2d} \\sum_{j=1}^{2d} |S_{ij}|^2}\n$$\n这个标量值作为我们的诊断工具。一个非常小的值（接近机器精度）证实了所实现映射的辛性。\n\n该程序应用于五个测试案例。对每个案例，使用适当的维度 $d$、初始状态 $z_0$、步长 $h$ 和力函数 $f(q)$ 来计算诊断值。\n-   案例 $1$ 和 $2$：一维谐振子，$d=1$，$V(q) = \\frac{1}{2}\\omega^2 q^2$，其中 $\\omega=1.7$。力为 $f(q) = -\\omega^2 q$。\n-   案例 $3$ 和 $4$：一维非线性摆，$d=1$，$V(q) = 1 - \\cos(q)$。力为 $f(q) = -\\sin(q)$。角度以弧度为单位。\n-   案例 $5$：二维解耦谐振子，$d=2$，$V(q) = \\frac{1}{2}(\\omega_1^2 q_1^2 + \\omega_2^2 q_2^2)$，其中 $\\omega_1=1.0$ 和 $\\omega_2=1.5$。力向量为 $f(q) = (-\\omega_1^2 q_1, -\\omega_2^2 q_2)^T$。\n状态向量的分量排序为 $(q_1, \\dots, q_d, p_1, \\dots, p_d)$。",
            "answer": "```python\nimport numpy as np\n\ndef stormer_verlet_step(z, h, d, force_func, v_func):\n    \"\"\"\n    Performs a single step of the Störmer-Verlet (velocity Verlet) method.\n    \n    Args:\n        z (np.ndarray): The current state vector [q, p] of size 2d.\n        h (float): The time step size.\n        d (int): The dimension of the configuration space.\n        force_func (callable): The force function f(q) = -grad_q V(q).\n        v_func (callable): The velocity function v(p) = grad_p T(p).\n        \n    Returns:\n        np.ndarray: The state vector at the next time step.\n    \"\"\"\n    q = z[:d]\n    p = z[d:]\n    \n    p_half = p + (h / 2.0) * force_func(q)\n    q_next = q + h * v_func(p_half)\n    p_next = p_half + (h / 2.0) * force_func(q_next)\n    \n    return np.concatenate((q_next, p_next))\n\ndef compute_symplecticity_defect_norm(d, z0, h, force_func):\n    \"\"\"\n    Computes the Frobenius norm of the symplecticity defect matrix.\n    \n    Args:\n        d (int): The dimension of the configuration space.\n        z0 (np.ndarray): The state vector at which to compute the Jacobian.\n        h (float): The time step size for the integrator.\n        force_func (callable): The force function f(q).\n        \n    Returns:\n        float: The Frobenius norm of the defect matrix.\n    \"\"\"\n    eps = 1e-7\n    dim = 2 * d\n\n    # For all given problems, T(p) = 1/2 p^T p, so grad_p T(p) = p.\n    v_func = lambda p: p\n\n    # Define the one-step map for the given parameters\n    def one_step_map(z):\n        return stormer_verlet_step(z, h, d, force_func, v_func)\n\n    # Compute Jacobian using central differences\n    jacobian = np.zeros((dim, dim))\n    for j in range(dim):\n        e_j = np.zeros(dim)\n        e_j[j] = 1.0\n        z_plus = z0 + eps * e_j\n        z_minus = z0 - eps * e_j\n        \n        map_plus = one_step_map(z_plus)\n        map_minus = one_step_map(z_minus)\n        \n        jacobian[:, j] = (map_plus - map_minus) / (2.0 * eps)\n        \n    # Construct canonical symplectic matrix J\n    I_d = np.identity(d)\n    J = np.block([\n        [np.zeros((d, d)), I_d],\n        [-I_d, np.zeros((d, d))]\n    ])\n\n    # Compute defect matrix and its Frobenius norm\n    A = jacobian\n    defect_matrix = A.T @ J @ A - J\n    norm = np.linalg.norm(defect_matrix, 'fro')\n    \n    return norm\n\ndef solve():\n    \"\"\"\n    Runs the diagnostic for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: 1D Harmonic Oscillator\n        {\n            'd': 1,\n            'z0': np.array([0.3, -0.4]),\n            'h': 0.1,\n            'force': lambda q: -1.7**2 * q\n        },\n        # Case 2: 1D Harmonic Oscillator (near stability threshold)\n        {\n            'd': 1,\n            'z0': np.array([0.3, -0.4]),\n            'h': 1.99 / 1.7,\n            'force': lambda q: -1.7**2 * q\n        },\n        # Case 3: 1D Nonlinear Pendulum (equilibrium)\n        {\n            'd': 1,\n            'z0': np.array([0.0, 0.0]),\n            'h': 0.3,\n            'force': lambda q: -np.sin(q)\n        },\n        # Case 4: 1D Nonlinear Pendulum (non-equilibrium)\n        {\n            'd': 1,\n            'z0': np.array([1.0, 0.2]),\n            'h': 0.3,\n            'force': lambda q: -np.sin(q)\n        },\n        # Case 5: 2D Decoupled Harmonic Oscillator\n        {\n            'd': 2,\n            'z0': np.array([0.2, -0.1, -0.3, 0.4]),\n            'h': 0.2,\n            'force': lambda q: np.array([-1.0**2 * q[0], -1.5**2 * q[1]])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_symplecticity_defect_norm(\n            case['d'], case['z0'], case['h'], case['force']\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}