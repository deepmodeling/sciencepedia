{
    "hands_on_practices": [
        {
            "introduction": "Understanding a numerical method's stability is paramount before its application. This analytical exercise uses the harmonic oscillator, a fundamental model in physics, to explore the linear stability of the Störmer-Verlet method. By deriving the recurrence relation and analyzing its amplification factor, you will determine the precise condition on the time step $h$ that guarantees bounded, oscillatory solutions and uncover how the method produces a slightly modified numerical frequency.",
            "id": "3782611",
            "problem": "Consider the scalar harmonic oscillator governed by the ordinary differential equation (ODE) $$q''(t)+\\omega^{2} q(t)=0,$$ with Hamiltonian $$H(p,q)=\\frac{1}{2} p^{2}+\\frac{1}{2} \\omega^{2} q^{2},$$ where $q$ is the position, $p$ is the momentum, and $\\omega>0$ is the angular frequency. The Störmer-Verlet method is a time-reversible, second-order, symplectic integrator constructed by a symmetric composition of exact flows of split Hamiltonians. Apply the Störmer-Verlet method with time step $h>0$ to this system to derive the two-step recurrence in $q_{n}$, and analyze its linear stability by the standard amplification ansatz $q_{n}=\\zeta^{n}$.\n\nStarting from first principles of geometric mechanics and symplectic methods (Hamilton’s equations, symmetric composition, and linear amplification analysis), do the following:\n\n1. Derive the two-step position-only recurrence that the Störmer-Verlet method produces for the harmonic oscillator, and obtain the corresponding quadratic amplification polynomial in the complex number $\\zeta$.\n2. Determine the condition on $h\\omega$ under which all solutions produced by the method remain bounded for all discrete times $n$. Identify and describe the qualitative behavior of the method at the stability boundary.\n3. In the linearly stable regime, the method produces bounded oscillations with a discrete modified angular frequency $\\tilde{\\omega}$, defined by $q_{n}=A \\cos(n \\tilde{\\omega} h)+B \\sin(n \\tilde{\\omega} h)$ for some constants $A$ and $B$. Compute $\\tilde{\\omega}$ explicitly in terms of $h$ and $\\omega$.\n\nProvide your final answer as a single closed-form analytical expression for $\\tilde{\\omega}$ in radians per unit time. No rounding is required.",
            "solution": "The problem requires an analysis of the Störmer-Verlet method applied to the scalar harmonic oscillator. The analysis will proceed in three stages: first, the derivation of the numerical update rule and its amplification polynomial; second, the linear stability analysis of this rule; and third, the derivation of the modified frequency of the numerical solution.\n\nThe system is described by the Hamiltonian $H(p,q) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 q^2$. Hamilton's equations of motion are\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p} = p,\n$$\n$$\n\\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q} = -\\omega^2 q.\n$$\nDifferentiating the first equation with respect to time $t$ and substituting the second gives $q''(t) = p'(t) = -\\omega^2 q(t)$, which is the stated ordinary differential equation (ODE) $q''(t) + \\omega^2 q(t) = 0$.\n\nThe Störmer-Verlet method arises from a symmetric splitting of the Hamiltonian into its kinetic and potential parts, $H(p,q) = T(p) + V(q)$, where $T(p) = \\frac{1}{2}p^2$ and $V(q) = \\frac{1}{2}\\omega^2 q^2$. We will use the 'velocity Verlet' steps to derive the two-step recurrence relation in position.\n\nLet $q_n$ and $p_n$ be the numerical approximations to $q(nh)$ and $p(nh)$ respectively. The velocity Verlet method is given by the three steps:\n1. Update momentum by a half-step: $p_{n+1/2} = p_n + \\frac{h}{2} F(q_n)$, where $F(q) = -\\frac{dV}{dq} = -\\omega^2 q$.\n$$p_{n+1/2} = p_n - \\frac{h}{2} \\omega^2 q_n$$\n2. Update position by a full-step using the half-step momentum:\n$$q_{n+1} = q_n + h p_{n+1/2}$$\n3. Update momentum by a final half-step:\n$$p_{n+1} = p_{n+1/2} - \\frac{h}{2} \\omega^2 q_{n+1}$$\n\nTo derive the requested two-step recurrence in $q_n$, we must eliminate the momentum variables. From step $2$, we can express the midpoint momentum as $p_{n+1/2} = \\frac{q_{n+1} - q_n}{h}$. Similarly, for the previous time step, $p_{n-1/2} = \\frac{q_n - q_{n-1}}{h}$.\nThe update from $p_{n-1/2}$ to $p_{n+1/2}$ is found by combining the third step of the previous iteration and the first step of the current iteration:\n$p_n = p_{n-1/2} - \\frac{h}{2}\\omega^2 q_n$ and $p_{n+1/2} = p_n - \\frac{h}{2}\\omega^2 q_n$.\nSubstituting the first into the second gives $p_{n+1/2} = p_{n-1/2} - h \\omega^2 q_n$.\nNow, we substitute the expressions for the midpoint momenta in terms of positions:\n$$\n\\frac{q_{n+1} - q_n}{h} = \\frac{q_n - q_{n-1}}{h} - h \\omega^2 q_n.\n$$\nMultiplying by $h$ and rearranging terms, we obtain the two-step recurrence relation for the position $q_n$:\n$$\nq_{n+1} - 2q_n + q_{n-1} = -(h\\omega)^2 q_n\n$$\n$$\nq_{n+1} - (2 - (h\\omega)^2) q_n + q_{n-1} = 0.\n$$\n\nTo perform the linear stability analysis (part 1 and 2), we use the amplification ansatz $q_n = \\zeta^n$ for some complex number $\\zeta$. Substituting this into the recurrence relation gives:\n$$\n\\zeta^{n+1} - (2 - (h\\omega)^2) \\zeta^n + \\zeta^{n-1} = 0.\n$$\nAssuming $\\zeta \\neq 0$, we can divide by $\\zeta^{n-1}$ to get the characteristic quadratic amplification polynomial:\n$$\n\\zeta^2 - (2 - (h\\omega)^2) \\zeta + 1 = 0.\n$$\nFor the numerical solution $\\{q_n\\}$ to remain bounded for all $n$, the roots $\\zeta$ of this polynomial must lie on the unit circle in the complex plane, i.e., $|\\zeta| = 1$, and they must be distinct. If a root has a magnitude greater than $1$, the solution will grow exponentially. If there is a repeated root on the unit circle, the solution will grow linearly.\nThe characteristic polynomial is of the form $\\zeta^2 - 2A\\zeta + B = 0$, with $A = 1 - \\frac{(h\\omega)^2}{2}$ and $B=1$. The roots are $\\zeta = A \\pm \\sqrt{A^2-B}$. Since $B=1$, the roots are $\\zeta = A \\pm \\sqrt{A^2-1}$.\nFor the roots to be on the unit circle, they must be complex conjugates, which requires the discriminant to be negative: $A^2 - 1 < 0$. This implies $A^2 < 1$, or $-1 < A < 1$.\nSubstituting the expression for $A$:\n$$\n-1 < 1 - \\frac{(h\\omega)^2}{2} < 1.\n$$\nThis gives two inequalities:\n1. $1 - \\frac{(h\\omega)^2}{2} < 1 \\implies -\\frac{(h\\omega)^2}{2} < 0 \\implies (h\\omega)^2 > 0$. This is true since $h>0$ and $\\omega>0$.\n2. $-1 < 1 - \\frac{(h\\omega)^2}{2} \\implies \\frac{(h\\omega)^2}{2} < 2 \\implies (h\\omega)^2 < 4$.\nSince $h\\omega > 0$, we take the positive square root to find the stability condition:\n$$\nh\\omega < 2.\n$$\nAt the stability boundary, $h\\omega = 2$, we have $A = 1 - \\frac{2^2}{2} = -1$. The amplification polynomial becomes $\\zeta^2 + 2\\zeta + 1 = (\\zeta+1)^2 = 0$. This gives a repeated root $\\zeta = -1$. In this case, the general solution to the recurrence is of the form $q_n = (C_1 + C_2 n)(-1)^n$. The term $C_2 n$ indicates that the amplitude of the oscillations grows linearly with the number of steps, $n$. This is a numerical resonance, and the solution is unbounded.\n\nFor the third part of the problem, we analyze the behavior in the linearly stable regime, $0 < h\\omega < 2$. Here, the roots of the amplification polynomial are a complex conjugate pair on the unit circle, which can be written as $\\zeta = e^{\\pm i\\theta}$. The general solution is a linear combination of $\\zeta_1^n$ and $\\zeta_2^n$, which can be written in real form as $q_n = \\tilde{A} \\cos(n\\theta) + \\tilde{B} \\sin(n\\theta)$.\nThe problem statement gives the form of the solution as $q_n = A \\cos(n \\tilde{\\omega} h) + B \\sin(n \\tilde{\\omega} h)$. By comparing these two forms, we can identify $\\theta = \\tilde{\\omega}h$.\nThe roots of $\\zeta^2 - 2A\\zeta + 1 = 0$ are $\\zeta = A \\pm i\\sqrt{1-A^2}$. On the unit circle, we can set $A = \\cos(\\theta)$. Thus, the roots are $\\cos(\\theta) \\pm i\\sin(\\theta) = e^{\\pm i\\theta}$, which is consistent.\nWe equate our expression for $A$ with $\\cos(\\theta)$:\n$$\n\\cos(\\theta) = A = 1 - \\frac{(h\\omega)^2}{2}.\n$$\nSubstituting $\\theta = \\tilde{\\omega}h$, we get:\n$$\n\\cos(\\tilde{\\omega}h) = 1 - \\frac{(h\\omega)^2}{2}.\n$$\nTo find the modified angular frequency $\\tilde{\\omega}$, we solve for it by taking the inverse cosine of both sides. Since $0 < h\\omega < 2$, the argument of the inverse cosine is in the range $(-1, 1)$, so $\\tilde{\\omega}$ is well-defined and real.\n$$\n\\tilde{\\omega}h = \\arccos\\left(1 - \\frac{(h\\omega)^2}{2}\\right).\n$$\nFinally, we obtain the expression for $\\tilde{\\omega}$:\n$$\n\\tilde{\\omega} = \\frac{1}{h} \\arccos\\left(1 - \\frac{(h\\omega)^2}{2}\\right).\n$$\nThis expression shows that the numerical frequency $\\tilde{\\omega}$ is different from the true frequency $\\omega$ and depends on the time step $h$. The difference $\\tilde{\\omega} - \\omega$ is the phase error of the method, which can be shown to be of order $O(h^2)$, consistent with the Störmer-Verlet method being a second-order accurate integrator.\nAn equivalent form can be derived using the half-angle identity $1-\\cos(x) = 2\\sin^2(x/2)$, which gives $\\tilde{\\omega} = \\frac{2}{h} \\arcsin\\left(\\frac{h\\omega}{2}\\right)$. Both expressions are correct. We provide the one derived directly from the cosine.",
            "answer": "$$\n\\boxed{\\frac{1}{h} \\arccos\\left(1 - \\frac{(h\\omega)^2}{2}\\right)}\n$$"
        },
        {
            "introduction": "A major advantage of the Störmer-Verlet method is its excellent long-term energy behavior. While the discrete energy is not exactly conserved, the error remains bounded over very long integration times, unlike with many non-symplectic methods. This numerical experiment is designed to empirically verify that the maximum energy error scales as $O(h^2)$, confirming the method's second-order accuracy across several distinct physical systems. This practice provides tangible evidence for one of the integrator's most celebrated practical features.",
            "id": "3782626",
            "problem": "Consider a separable Hamiltonian system with generalized position $q \\in \\mathbb{R}^d$ and conjugate momentum $p \\in \\mathbb{R}^d$, whose Hamiltonian is given by $H(q,p) = T(p) + V(q)$ where $T(p)$ is the kinetic energy and $V(q)$ is the potential energy. The canonical equations of motion are $\\dot{q} = \\partial H / \\partial p$ and $\\dot{p} = -\\partial H / \\partial q$. The Störmer-Verlet method is a symplectic, time-reversible numerical integrator for such separable Hamiltonians. Design and implement a numerical experiment that varies the time step $h$ to demonstrate empirically that, over a fixed time interval, the maximum absolute energy error scales like $O(h^2)$ for the Störmer-Verlet method.\n\nYour program must implement the Störmer-Verlet method to integrate the following four test systems, each specified with dimensionless parameters and initial data. All energies and times are to be treated in dimensionless units, and angles must be in radians.\n\n1. One-dimensional harmonic oscillator: $H(q,p) = \\frac{p^2}{2m} + \\frac{k}{2} q^2$ with $m = 1$, $k = 1$, $q(0) = 1$, $p(0) = 0$.\n2. Nonlinear pendulum: $H(q,p) = \\frac{p^2}{2m} + mgL \\left(1 - \\cos(q)\\right)$ with $m = 1$, $g = 1$, $L = 1$, $q(0) = 1$ (radians), $p(0) = 0$.\n3. One-dimensional double-well potential: $H(q,p) = \\frac{p^2}{2m} + \\frac{1}{4}\\left(q^2 - 1\\right)^2$ with $m = 1$, $q(0) = 0$, $p(0) = 1$.\n4. Two-dimensional anisotropic harmonic oscillator: $H(q,p) = \\frac{p_1^2}{2m_1} + \\frac{p_2^2}{2m_2} + \\frac{k_1}{2} q_1^2 + \\frac{k_2}{2} q_2^2$ with $m_1 = 1$, $m_2 = 2$, $k_1 = 1$, $k_2 = 4$, $q(0) = (1, 0.5)$, $p(0) = (0, 0)$.\n\nFor each system, integrate over the fixed time interval $[0, T]$ with $T = 50$. For each time step size $h$ in the set $\\{0.4, 0.2, 0.1, 0.05, 0.025\\}$, define $N = \\operatorname{round}(T / h)$ and use the resulting uniform step size $\\tilde{h} = T / N$. For each $\\tilde{h}$, compute the discrete trajectory $\\{(q_n, p_n)\\}_{n=0}^N$ using the Störmer-Verlet method, and evaluate the maximum absolute energy deviation\n$$\n\\Delta H_{\\max}(\\tilde{h}) = \\max_{0 \\le n \\le N} \\left| H(q_n, p_n) - H(q_0, p_0) \\right|.\n$$\nEstimate the scaling exponent $p$ by a least-squares linear fit to the data pairs $\\left(\\log(\\tilde{h}), \\log\\left(\\Delta H_{\\max}(\\tilde{h})\\right)\\right)$, i.e., fit $\\log\\left(\\Delta H_{\\max}(\\tilde{h})\\right) \\approx a + p \\log(\\tilde{h})$ and report the slope $p$.\n\nTest Suite and Answer Specification:\n- Use the four systems listed above, the fixed end time $T = 50$, and the step sizes $h \\in \\{0.4, 0.2, 0.1, 0.05, 0.025\\}$.\n- For each system, compute the slope $p$ as described.\n- Your program should produce a single line of output containing the slopes, in the order of the four systems listed above, rounded to three decimals, as a comma-separated list enclosed in square brackets, for example, $[p_1, p_2, p_3, p_4]$.",
            "solution": "The problem requires designing a numerical experiment to empirically verify the order of accuracy of the Störmer-Verlet method concerning energy conservation for several separable Hamiltonian systems. The core of the task is to implement the integrator, simulate the dynamics for a set of decreasing time steps, measure the maximum energy deviation, and then use a log-log regression to estimate the scaling exponent, which is theoretically expected to be $2$.\n\nFirst, we formalize the physical and numerical framework. A separable Hamiltonian system is described by a Hamiltonian function $H(q, p)$ that can be split into a kinetic energy term $T(p)$ depending only on the momentum $p \\in \\mathbb{R}^d$ and a potential energy term $V(q)$ depending only on the position $q \\in \\mathbb{R}^d$, such that $H(q, p) = T(p) + V(q)$. The time evolution of the system is governed by Hamilton's equations:\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = \\nabla_p T(p)\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q} = -\\nabla_q V(q) \\equiv F(q)\n$$\nwhere $F(q)$ is the force. For the systems in question, the kinetic energy has the standard quadratic form $T(p) = \\frac{1}{2} p^T M^{-1} p$, where $M$ is the (typically diagonal) mass matrix. This gives $\\nabla_p T(p) = M^{-1}p$.\n\nThe Störmer-Verlet method is a geometric integrator, specifically a second-order symplectic method, renowned for its excellent long-term energy stability when applied to such systems. The velocity Verlet variant of the algorithm advances the state $(q_n, p_n)$ at time $t_n$ to $(q_{n+1}, p_{n+1})$ at time $t_{n+1} = t_n + \\tilde{h}$ using the following three steps:\n1. A half-step update for the momentum: $p_{n+1/2} = p_n + \\frac{\\tilde{h}}{2} F(q_n)$\n2. A full-step update for the position: $q_{n+1} = q_n + \\tilde{h} M^{-1} p_{n+1/2}$\n3. A final half-step update for the momentum: $p_{n+1} = p_{n+1/2} + \\frac{\\tilde{h}}{2} F(q_{n+1})$\n\nThe numerical experiment is designed to demonstrate that the maximum error in the Hamiltonian, $\\Delta H_{\\max}(\\tilde{h}) = \\max_{0 \\le n \\le N} |H(q_n, p_n) - H(q_0, p_0)|$, scales quadratically with the step size, i.e., $\\Delta H_{\\max}(\\tilde{h}) = O(\\tilde{h}^2)$. This relationship implies that a plot of $\\log(\\Delta H_{\\max})$ versus $\\log(\\tilde{h})$ should be approximately linear with a slope of $2$. We estimate this slope, denoted by $p$, by performing a linear least-squares fit on the data points $(\\log(\\tilde{h}), \\log(\\Delta H_{\\max}(\\tilde{h})))$ generated by running simulations for a set of step sizes $\\tilde{h}$. The problem specifies an initial set of step sizes $h \\in \\{0.4, 0.2, 0.1, 0.05, 0.025\\}$ and a total integration time of $T = 50$. For each $h$, the number of steps is $N = \\operatorname{round}(T/h)$, and the actual step size used is $\\tilde{h} = T/N$.\n\nThe experiment is conducted for four distinct physical systems:\n\n1.  **One-dimensional harmonic oscillator**: $H(q,p) = \\frac{p^2}{2m} + \\frac{k}{2} q^2$. With $m=1$ and $k=1$, the force is $F(q) = -q$. The mass matrix is the scalar $M=1$. Initial conditions are $q(0)=1, p(0)=0$.\n\n2.  **Nonlinear pendulum**: $H(q,p) = \\frac{p^2}{2m} + mgL(1 - \\cos(q))$. With $m=1, g=1, L=1$, the force is $F(q) = -\\sin(q)$, and $M=1$. Initial conditions are $q(0)=1, p(0)=0$.\n\n3.  **One-dimensional double-well potential**: $H(q,p) = \\frac{p^2}{2m} + \\frac{1}{4}(q^2 - 1)^2$. With $m=1$, the force is $F(q) = - (q^3 - q) = q-q^3$, and $M=1$. Initial conditions are $q(0)=0, p(0)=1$.\n\n4.  **Two-dimensional anisotropic harmonic oscillator**: $H(q,p) = \\frac{p_1^2}{2m_1} + \\frac{p_2^2}{2m_2} + \\frac{k_1}{2} q_1^2 + \\frac{k_2}{2} q_2^2$. With parameters $m_1=1, m_2=2, k_1=1, k_2=4$, the force vector is $F(q) = (-k_1 q_1, -k_2 q_2) = (-q_1, -4q_2)$. The mass matrix is $M = \\operatorname{diag}(m_1, m_2) = \\operatorname{diag}(1, 2)$. Initial conditions are $q(0)=(1, 0.5), p(0)=(0, 0)$.\n\nFor each system, we iterate through the specified step sizes, perform the Störmer-Verlet integration, compute the maximum energy error, and collect the log-log data. A linear regression on this data yields the desired scaling exponent $p$. The final output consists of the calculated exponents for the four systems, rounded to three decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Performs a numerical experiment to determine the energy error scaling\n    of the Störmer-Verlet method for four different Hamiltonian systems.\n    \"\"\"\n    T_final = 50.0\n    h_values = [0.4, 0.2, 0.1, 0.05, 0.025]\n\n    # Definitions for the four test systems\n    systems = [\n        # System 1: One-dimensional harmonic oscillator\n        {\n            \"name\": \"Harmonic Oscillator (1D)\",\n            \"q0\": np.array([1.0]),\n            \"p0\": np.array([0.0]),\n            \"masses\": np.array([1.0]),\n            \"force\": lambda q: -q,\n            \"potential\": lambda q: 0.5 * q[0]**2,\n        },\n        # System 2: Nonlinear pendulum\n        {\n            \"name\": \"Nonlinear Pendulum (1D)\",\n            \"q0\": np.array([1.0]),\n            \"p0\": np.array([0.0]),\n            \"masses\": np.array([1.0]),\n            \"force\": lambda q: -np.sin(q),\n            \"potential\": lambda q: 1.0 - np.cos(q[0]),\n        },\n        # System 3: One-dimensional double-well potential\n        {\n            \"name\": \"Double-Well Potential (1D)\",\n            \"q0\": np.array([0.0]),\n            \"p0\": np.array([1.0]),\n            \"masses\": np.array([1.0]),\n            \"force\": lambda q: q - q**3,\n            \"potential\": lambda q: 0.25 * (q[0]**2 - 1.0)**2,\n        },\n        # System 4: Two-dimensional anisotropic harmonic oscillator\n        {\n            \"name\": \"Anisotropic Oscillator (2D)\",\n            \"q0\": np.array([1.0, 0.5]),\n            \"p0\": np.array([0.0, 0.0]),\n            \"masses\": np.array([1.0, 2.0]),\n            \"force\": lambda q: np.array([-q[0], -4.0 * q[1]]),\n            \"potential\": lambda q: 0.5 * q[0]**2 + 2.0 * q[1]**2,\n        }\n    ]\n\n    slopes = []\n\n    for system_params in systems:\n        q0 = system_params[\"q0\"]\n        p0 = system_params[\"p0\"]\n        masses = system_params[\"masses\"]\n        force_func = system_params[\"force\"]\n        potential_func = system_params[\"potential\"]\n\n        def kinetic_func(p):\n            return np.sum(p**2 / (2.0 * masses))\n\n        def hamiltonian_func(q, p):\n            return kinetic_func(p) + potential_func(q)\n\n        log_h_tilde_list = []\n        log_delta_H_max_list = []\n\n        H0 = hamiltonian_func(q0, p0)\n\n        for h in h_values:\n            N = int(round(T_final / h))\n            h_tilde = T_final / N\n\n            q = np.copy(q0)\n            p = np.copy(p0)\n            \n            max_energy_error = 0.0\n\n            for _ in range(N):\n                # Störmer-Verlet (velocity Verlet) integration step\n                p_half_step = p + 0.5 * h_tilde * force_func(q)\n                q = q + h_tilde * p_half_step / masses\n                p = p_half_step + 0.5 * h_tilde * force_func(q)\n\n                # Calculate energy error at the end of the step\n                H_current = hamiltonian_func(q, p)\n                energy_error = abs(H_current - H0)\n                if energy_error > max_energy_error:\n                    max_energy_error = energy_error\n            \n            log_h_tilde_list.append(np.log(h_tilde))\n            log_delta_H_max_list.append(np.log(max_energy_error))\n\n        # Perform linear regression on the log-log data to find the slope\n        lin_reg_result = linregress(log_h_tilde_list, log_delta_H_max_list)\n        slope = lin_reg_result.slope\n        slopes.append(slope)\n        \n    # Format the final results as specified\n    formatted_slopes = [f\"{s:.3f}\" for s in slopes]\n    print(f\"[{','.join(formatted_slopes)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The remarkable long-term stability of the Störmer-Verlet integrator is not an accident; it is a direct consequence of its symplecticity—the preservation of the canonical symplectic form in phase space. This advanced practice guides you through designing a numerical diagnostic to directly probe this fundamental geometric property. By approximating the Jacobian of the one-step map and verifying that it satisfies the symplectic condition, you will gain a deeper, hands-on insight into the geometric foundations of the method's power.",
            "id": "3782583",
            "problem": "Consider a separable Hamiltonian system with configuration variables $q \\in \\mathbb{R}^d$ and momenta $p \\in \\mathbb{R}^d$ so that the state is $z = (q,p) \\in \\mathbb{R}^{2d}$. The dynamics are governed by Hamilton's equations for a separable Hamiltonian $H(q,p) = T(p) + V(q)$, where $T$ is the kinetic energy and $V$ is the potential energy, namely $\\dot{q} = \\nabla_p T(p)$ and $\\dot{p} = -\\nabla_q V(q)$. The canonical symplectic form on $\\mathbb{R}^{2d}$ is represented by the constant matrix $J \\in \\mathbb{R}^{2d \\times 2d}$ with block structure $J = \\begin{bmatrix} 0 & I \\\\ -I & 0 \\end{bmatrix}$, where $I$ denotes the $d \\times d$ identity. A smooth map $\\Phi_h : \\mathbb{R}^{2d} \\to \\mathbb{R}^{2d}$ is symplectic if and only if its Jacobian $D\\Phi_h(z)$ satisfies the condition that its pullback preserves the canonical symplectic form.\n\nUsing only these foundational facts, design a numerical diagnostic to assess the symplecticity of the one-step map defined by the Störmer-Verlet method (also known as the velocity Verlet method) applied to a separable Hamiltonian. Your diagnostic must approximate the Jacobian $D\\Phi_h(z)$ at a given state $z$ using central finite differences with a small perturbation magnitude $\\varepsilon$ and then quantify the deviation from symplecticity using a matrix norm of the discrepancy between the pulled-back canonical form and the canonical form. Concretely, you must:\n- Implement a correct Störmer-Verlet one-step map for separable Hamiltonians $H(q,p) = T(p) + V(q)$, using the force $f(q) = -\\nabla_q V(q)$ and the velocity field $v(p) = \\nabla_p T(p)$.\n- Approximate the Jacobian $D\\Phi_h(z)$ at a given $z$ by central finite differences along the standard basis of $\\mathbb{R}^{2d}$ with a fixed $\\varepsilon = 10^{-7}$.\n- Construct the canonical symplectic matrix $J$ for the appropriate dimension $d$.\n- Form the symplecticity defect matrix at $z$ and compute its Frobenius norm as a scalar diagnostic. You must use central finite differences and the Frobenius norm, and you must use angles measured in radians wherever angles appear.\n\nYou must apply your diagnostic to the following test suite and return, for each case, a single real number equal to the Frobenius norm of the symplecticity defect matrix for the Störmer-Verlet map:\n- Case $1$ (one-degree-of-freedom harmonic oscillator): Let $d=1$. Let $T(p) = \\tfrac{1}{2} p^2$ and $V(q) = \\tfrac{1}{2} \\omega^2 q^2$ with $\\omega = 1.7$. Use initial state $q = 0.3$, $p = -0.4$ and step size $h = 0.1$.\n- Case $2$ (one-degree-of-freedom harmonic oscillator near the linear stability threshold): Let $d=1$. Use the same $T$ and $V$, with $\\omega = 1.7$. Use the same initial state $q = 0.3$, $p = -0.4$. Use step size $h = 1.99/\\omega$.\n- Case $3$ (one-degree-of-freedom nonlinear pendulum at equilibrium): Let $d=1$. Let $T(p) = \\tfrac{1}{2} p^2$ and $V(q) = 1 - \\cos(q)$. Angles must be in radians. Use initial state $q = 0.0$, $p = 0.0$ and step size $h = 0.3$.\n- Case $4$ (one-degree-of-freedom nonlinear pendulum away from equilibrium): Let $d=1$. Use the same $T$ and $V$ as in Case $3$. Use initial state $q = 1.0$, $p = 0.2$ (angles in radians) and step size $h = 0.3$.\n- Case $5$ (two-degree-of-freedom decoupled harmonic oscillator): Let $d=2$. Let $T(p) = \\tfrac{1}{2}(p_1^2 + p_2^2)$ and $V(q) = \\tfrac{1}{2}(\\omega_1^2 q_1^2 + \\omega_2^2 q_2^2)$ with $\\omega_1 = 1.0$ and $\\omega_2 = 1.5$. Use initial state $(q_1,q_2,p_1,p_2) = (0.2,-0.1,-0.3,0.4)$ and step size $h = 0.2$.\n\nAll quantities are dimensionless except for angles, which must be in radians. No other physical units are needed. Your program must produce a single line of output containing the five diagnostic results in the order of the cases above, as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5]$, where each $r_i$ is the Frobenius norm of the symplecticity defect matrix for Case $i$ computed as specified. The results must be floating-point numbers printed in the required order and format.",
            "solution": "The task is to numerically verify the symplecticity of the Störmer-Verlet integration method. A dynamical system is described by a separable Hamiltonian $H(q,p) = T(p) + V(q)$, where $q \\in \\mathbb{R}^d$ are the generalized coordinates and $p \\in \\mathbb{R}^d$ are the conjugate momenta. The state of the system is a point $z = (q,p)$ in the $2d$-dimensional phase space $\\mathbb{R}^{2d}$. The evolution of the system is governed by Hamilton's equations:\n$$\n\\dot{q} = \\nabla_p T(p)\n$$\n$$\n\\dot{p} = -\\nabla_q V(q)\n$$\nThis system of equations can be written compactly as $\\dot{z} = X_H(z)$, where $X_H$ is the Hamiltonian vector field associated with $H$. The exact flow of the system, $\\phi_t$, is a map that takes an initial state $z_0$ to the state $z(t) = \\phi_t(z_0)$ after time $t$. A key property of Hamiltonian flows is that they are symplectic. A map $\\Psi: \\mathbb{R}^{2d} \\to \\mathbb{R}^{2d}$ is symplectic if it preserves the canonical symplectic two-form. In matrix form, this is equivalent to its Jacobian, $D\\Psi(z)$, satisfying the condition:\n$$\n(D\\Psi(z))^T J D\\Psi(z) = J\n$$\nfor all $z$, where $J$ is the $2d \\times 2d$ canonical symplectic matrix given by:\n$$\nJ = \\begin{bmatrix} 0 & I \\\\ -I & 0 \\end{bmatrix}\n$$\nHere, $I$ is the $d \\times d$ identity matrix and $0$ is the $d \\times d$ zero matrix.\n\nNumerical integrators for Hamiltonian systems ideally should also produce symplectic maps to preserve the geometric structure of the phase space, which leads to excellent long-term stability and qualitative accuracy. The Störmer-Verlet method is a celebrated example of such a geometric integrator. Its one-step map, $\\Phi_h: z_n \\to z_{n+1}$, is exactly symplectic. This property arises from its construction via a symmetric splitting of the Hamiltonian operator, known as Trotter-Suzuki or Lie splitting. Specifically, the method is a composition of exact flows of the constituent parts of the Hamiltonian, $T(p)$ and $V(q)$. The velocity Verlet formulation of the Störmer-Verlet algorithm for a step size $h$ from state $(q_n, p_n)$ to $(q_{n+1}, p_{n+1})$ is:\n1.  Update momentum by a half-step under potential $V$: $p_{n+1/2} = p_n - \\frac{h}{2} \\nabla_q V(q_n)$\n2.  Update position by a full-step under kinetic energy $T$: $q_{n+1} = q_n + h \\nabla_p T(p_{n+1/2})$\n3.  Update momentum by the second half-step under potential $V$: $p_{n+1} = p_{n+1/2} - \\frac{h}{2} \\nabla_q V(q_{n+1})$\n\nFor the Hamiltonians given in the problem, the kinetic energy is of the standard form $T(p) = \\frac{1}{2} p^T p$, which yields $\\nabla_p T(p) = p$. Defining the force as $f(q) = -\\nabla_q V(q)$, the one-step map $\\Phi_h$ is implemented as:\n1.  $p_{n+1/2} = p_n + \\frac{h}{2} f(q_n)$\n2.  $q_{n+1} = q_n + h \\cdot p_{n+1/2}$\n3.  $p_{n+1} = p_{n+1/2} + \\frac{h}{2} f(q_{n+1})$\n\nThe diagnostic to assess symplecticity involves numerically calculating the Jacobian of this map, $D\\Phi_h(z)$, at a given point $z=(q,p)$ and then quantifying its deviation from the symplectic condition. The Jacobian matrix is a $2d \\times 2d$ matrix whose $j$-th column is the partial derivative of the map's output with respect to the $j$-th component of its input, $\\frac{\\partial \\Phi_h}{\\partial z_j}$. We approximate these columns using the second-order accurate central finite difference formula with a small perturbation $\\varepsilon = 10^{-7}$:\n$$\n\\frac{\\partial \\Phi_h}{\\partial z_j}(z) \\approx \\frac{\\Phi_h(z + \\varepsilon e_j) - \\Phi_h(z - \\varepsilon e_j)}{2\\varepsilon}\n$$\nwhere $e_j$ is the $j$-th standard basis vector in $\\mathbb{R}^{2d}$.\n\nLet the numerically approximated Jacobian be $A$. We then form the symplecticity defect matrix, $S$:\n$$\nS(z) = A^T J A - J\n$$\nTheoretically, for an exactly symplectic map with an exactly computed Jacobian, this matrix would be identically zero. In practice, the use of finite difference approximation and floating-point arithmetic will result in a small but non-zero matrix. The magnitude of this defect is quantified by its Frobenius norm, $\\|S(z)\\|_F$:\n$$\n\\|S(z)\\|_F = \\sqrt{\\sum_{i=1}^{2d} \\sum_{j=1}^{2d} |S_{ij}|^2}\n$$\nThis scalar value serves as our diagnostic. A very small value (close to machine precision) confirms the symplecticity of the implemented map.\n\nThe procedure is applied to five test cases. For each case, the appropriate dimension $d$, initial state $z_0$, step size $h$, and force function $f(q)$ are used to compute the diagnostic value.\n-   Cases $1$ and $2$: One-dimensional harmonic oscillator, $d=1$, $V(q) = \\frac{1}{2}\\omega^2 q^2$ with $\\omega=1.7$. The force is $f(q) = -\\omega^2 q$.\n-   Cases $3$ and $4$: One-dimensional nonlinear pendulum, $d=1$, $V(q) = 1 - \\cos(q)$. The force is $f(q) = -\\sin(q)$. Angles are in radians.\n-   Case $5$: Two-dimensional decoupled harmonic oscillator, $d=2$, $V(q) = \\frac{1}{2}(\\omega_1^2 q_1^2 + \\omega_2^2 q_2^2)$ with $\\omega_1=1.0$ and $\\omega_2=1.5$. The force vector is $f(q) = (-\\omega_1^2 q_1, -\\omega_2^2 q_2)^T$.\nThe state vector components are ordered as $(q_1, \\dots, q_d, p_1, \\dots, p_d)$.",
            "answer": "```python\nimport numpy as np\n\ndef stormer_verlet_step(z, h, d, force_func, v_func):\n    \"\"\"\n    Performs a single step of the Störmer-Verlet (velocity Verlet) method.\n    \n    Args:\n        z (np.ndarray): The current state vector [q, p] of size 2d.\n        h (float): The time step size.\n        d (int): The dimension of the configuration space.\n        force_func (callable): The force function f(q) = -grad_q V(q).\n        v_func (callable): The velocity function v(p) = grad_p T(p).\n        \n    Returns:\n        np.ndarray: The state vector at the next time step.\n    \"\"\"\n    q = z[:d]\n    p = z[d:]\n    \n    p_half = p + (h / 2.0) * force_func(q)\n    q_next = q + h * v_func(p_half)\n    p_next = p_half + (h / 2.0) * force_func(q_next)\n    \n    return np.concatenate((q_next, p_next))\n\ndef compute_symplecticity_defect_norm(d, z0, h, force_func):\n    \"\"\"\n    Computes the Frobenius norm of the symplecticity defect matrix.\n    \n    Args:\n        d (int): The dimension of the configuration space.\n        z0 (np.ndarray): The state vector at which to compute the Jacobian.\n        h (float): The time step size for the integrator.\n        force_func (callable): The force function f(q).\n        \n    Returns:\n        float: The Frobenius norm of the defect matrix.\n    \"\"\"\n    eps = 1e-7\n    dim = 2 * d\n\n    # For all given problems, T(p) = 1/2 p^T p, so grad_p T(p) = p.\n    v_func = lambda p: p\n\n    # Define the one-step map for the given parameters\n    def one_step_map(z):\n        return stormer_verlet_step(z, h, d, force_func, v_func)\n\n    # Compute Jacobian using central differences\n    jacobian = np.zeros((dim, dim))\n    for j in range(dim):\n        e_j = np.zeros(dim)\n        e_j[j] = 1.0\n        z_plus = z0 + eps * e_j\n        z_minus = z0 - eps * e_j\n        \n        map_plus = one_step_map(z_plus)\n        map_minus = one_step_map(z_minus)\n        \n        jacobian[:, j] = (map_plus - map_minus) / (2.0 * eps)\n        \n    # Construct canonical symplectic matrix J\n    I_d = np.identity(d)\n    J = np.block([\n        [np.zeros((d, d)), I_d],\n        [-I_d, np.zeros((d, d))]\n    ])\n\n    # Compute defect matrix and its Frobenius norm\n    A = jacobian\n    defect_matrix = A.T @ J @ A - J\n    norm = np.linalg.norm(defect_matrix, 'fro')\n    \n    return norm\n\ndef solve():\n    \"\"\"\n    Runs the diagnostic for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: 1D Harmonic Oscillator\n        {\n            'd': 1,\n            'z0': np.array([0.3, -0.4]),\n            'h': 0.1,\n            'force': lambda q: -1.7**2 * q\n        },\n        # Case 2: 1D Harmonic Oscillator (near stability threshold)\n        {\n            'd': 1,\n            'z0': np.array([0.3, -0.4]),\n            'h': 1.99 / 1.7,\n            'force': lambda q: -1.7**2 * q\n        },\n        # Case 3: 1D Nonlinear Pendulum (equilibrium)\n        {\n            'd': 1,\n            'z0': np.array([0.0, 0.0]),\n            'h': 0.3,\n            'force': lambda q: -np.sin(q)\n        },\n        # Case 4: 1D Nonlinear Pendulum (non-equilibrium)\n        {\n            'd': 1,\n            'z0': np.array([1.0, 0.2]),\n            'h': 0.3,\n            'force': lambda q: -np.sin(q)\n        },\n        # Case 5: 2D Decoupled Harmonic Oscillator\n        {\n            'd': 2,\n            'z0': np.array([0.2, -0.1, -0.3, 0.4]),\n            'h': 0.2,\n            'force': lambda q: np.array([-1.0**2 * q[0], -1.5**2 * q[1]])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_symplecticity_defect_norm(\n            case['d'], case['z0'], case['h'], case['force']\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}