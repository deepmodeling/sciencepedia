{
    "hands_on_practices": [
        {
            "introduction": "第一个练习将指导你完成速度Verlet方法的基础实现。通过根据哈密顿量分裂原理编写算法，并将其应用于几个典型的物理系统，你将直接观察到其出色的长期能量守恒性和时间可逆性。这个动手实践是掌握几何积分器至关重要的第一步。",
            "id": "3782600",
            "problem": "考虑一个可分的哈密顿系统，其位形向量为 $q \\in \\mathbb{R}^d$，动量向量为 $p \\in \\mathbb{R}^d$，对角质量矩阵为 $M = \\mathrm{diag}(m_1,\\dots,m_d)$（其中各项 $m_i$ 均为严格正值），以及哈密顿量为\n$$\nH(q,p) = T(p) + V(q), \\quad T(p) = \\frac{1}{2} \\sum_{i=1}^d \\frac{p_i^2}{m_i}, \\quad V(q) \\in C^2(\\mathbb{R}^d,\\mathbb{R}).\n$$\n哈密顿方程为\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p}(q,p), \\qquad \\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q}(q,p).\n$$\n对于可分的 $H$，这可简化为\n$$\n\\frac{dq}{dt} = M^{-1} p, \\qquad \\frac{dp}{dt} = -\\nabla V(q).\n$$\nvelocity-Verlet（也称为 Störmer-Verlet）方法是一种二阶、保辛、时间可逆的积分器，通过对动能和势能部分的精确流进行对称组合得到。您的任务是从第一性原理出发，基于哈密顿方程和可分性假设，实现 velocity-Verlet 方法，并为 $(q,p)$ 和半步长动量设计高效的存储模式。您必须：\n- 从 $T$ 和 $V$ 的精确流推导该方法，并编写清晰的伪代码，明确指出力评估 $F(q) = -\\nabla V(q)$ 发生的精确点。\n- 为整数步长的 $(q,p)$ 和半步长动量 $p_{n+\\frac{1}{2}}$ 指定并实现一种高效的存储和更新策略。\n- 在您的实现中加入计数功能，以统计力的评估次数，并在使用缓存时验证每步的预期计数值。\n\n此问题中的所有量均为无量纲；不需要物理单位。\n\n算法设计约束：\n- 假设 $M$ 是对角矩阵且先验已知；通过分量除法隐式使用 $M^{-1}$。\n- 使用定义 $F(q) = -\\nabla V(q)$。\n- 实现力缓存，以避免在一个步长内对 $q_n$ 进行重复评估，重用上一次计算的 $F(q_n)$ 来计算 $p_{n+\\frac{1}{2}}$。\n\n测试套件：\n实现您的程序，对以下四个测试用例运行 velocity-Verlet 方法。对于每个用例，计算并报告以下指标：\n1. 整个轨迹上的最大绝对能量偏差，\n$$\n\\Delta H_{\\max} = \\max_{0 \\le k \\le N} \\left| H(q_k,p_k) - H(q_0,p_0) \\right|.\n$$\n2. 最终绝对能量偏差，\n$$\n\\Delta H_{\\mathrm{final}} = \\left| H(q_N,p_N) - H(q_0,p_0) \\right|.\n$$\n3. 时间反演误差，通过以步长 $h$ 向前积分 $N$ 步，然后以步长 $-h$向后积分 $N$ 步来测量，并报告\n$$\n\\varepsilon_{\\mathrm{rev}} = \\left\\| q_{\\mathrm{back}} - q_0 \\right\\|_2 + \\left\\| p_{\\mathrm{back}} - p_0 \\right\\|_2,\n$$\n其中 $(q_{\\mathrm{back}},p_{\\mathrm{back}})$ 是向后积分后的状态。\n4. 一个布尔值，指示在循环内使用 $F(q_n)$ 缓存时，统计的力评估次数是否等于 $N+1$。\n\n提供以下测试用例：\n- 用例 A（一维谐振子）：$d=1$, $m_1 = 1$, $V(q) = \\frac{1}{2} k q^2$（其中 $k=1$），$q_0 = 1$, $p_0 = 0$，步长 $h = 0.1$，步数 $N = 1000$。\n- 用例 B（一维四次振子）：$d=1$, $m_1 = 1$, $V(q) = \\frac{1}{4} q^4$, $q_0 = 1$, $p_0 = 0$, $h = 0.05$, $N = 1000$。\n- 用例 C（一维自由粒子）：$d=1$, $m_1 = 2$, $V(q) \\equiv 0$, $q_0 = 3$, $p_0 = 4$, $h = 0.2$, $N = 100$。\n- 用例 D（二维各向异性谐振子）：$d=2$, $m_1 = 1$, $m_2 = 2$, $V(q) = \\frac{1}{2} (k_1 q_1^2 + k_2 q_2^2)$（其中 $k_1 = 1$, $k_2 = 0.5$），$q_0 = (1,2)$, $p_0 = (0,0.5)$, $h = 0.07$, $N = 800$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含从用例 A 到用例 D 的上述四个指标，并平铺成一个列表：\n$$\n\\left[ \\Delta H_{\\max}^{(A)}, \\Delta H_{\\mathrm{final}}^{(A)}, \\varepsilon_{\\mathrm{rev}}^{(A)}, \\text{force\\_count\\_ok}^{(A)}, \\Delta H_{\\max}^{(B)}, \\Delta H_{\\mathrm{final}}^{(B)}, \\varepsilon_{\\mathrm{rev}}^{(B)}, \\text{force\\_count\\_ok}^{(B)}, \\Delta H_{\\max}^{(C)}, \\Delta H_{\\mathrm{final}}^{(C)}, \\varepsilon_{\\mathrm{rev}}^{(C)}, \\text{force\\_count\\_ok}^{(C)}, \\Delta H_{\\max}^{(D)}, \\Delta H_{\\mathrm{final}}^{(D)}, \\varepsilon_{\\mathrm{rev}}^{(D)}, \\text{force\\_count\\_ok}^{(D)} \\right].\n$$\n每个 $\\Delta H_{\\max}$、$\\Delta H_{\\mathrm{final}}$ 和 $\\varepsilon_{\\mathrm{rev}}$ 应打印为浮点数，每个 $\\text{force\\_count\\_ok}$ 应打印为布尔值。\n\n您的程序必须是自包含的，并且不需要任何输入。它必须实现带有力缓存的 velocity-Verlet 方法，并按指定格式生成最终输出。",
            "solution": "该问题要求对一个可分的哈密顿系统推导并实现 velocity-Verlet (Störmer-Verlet) 方法。该实现必须针对四个测试用例进行基准测试，评估其能量守恒性、时间可逆性以及计算成本（力评估次数）。\n\n首先，我们验证问题的陈述。该问题设定在哈密顿力学和几何数值积分的成熟框架内。所有定义、方程、初始条件和参数都已提供，并且在数学和物理上是一致的。测试用例对应于标准的、无争议的物理模型（谐振子、自由粒子）。任务是具体的、客观的且可形式化的。因此，该问题被认为是有效的。\n\n我们继续解决问题，从积分器的推导开始。\n\n**Velocity-Verlet 方法的推导**\n\n该系统由一个可分的哈密顿量 $H(q,p) = T(p) + V(q)$ 描述，其中 $T(p) = \\frac{1}{2} p^T M^{-1} p$ 是动能，$V(q)$ 是势能。哈密顿方程为：\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p} = M^{-1}p\n$$\n$$\n\\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q} = -\\nabla V(q) = F(q)\n$$\n在一个时间步长 $h$ 上的形式解由流算子 $\\Phi_H^h$ 给出，使得 $(q(t+h), p(t+h)) = \\Phi_H^h(q(t), p(t))$。由于哈密顿量是可分的，我们可以将流分解为两个部分：\n1.  对应于动能部分 $T(p)$ 的流 $\\Phi_T^t$，它求解 $\\dot{q} = M^{-1}p$ 和 $\\dot{p} = 0$。其精确解为：\n    $$\n    \\Phi_T^t(q_0, p_0) = (q_0 + t M^{-1} p_0, p_0)\n    $$\n2.  对应于势能部分 $V(q)$ 的流 $\\Phi_V^t$，它求解 $\\dot{q} = 0$ 和 $\\dot{p} = F(q)$。其精确解为：\n    $$\n    \\Phi_V^t(q_0, p_0) = (q_0, p_0 + t F(q_0))\n    $$\n\nvelocity-Verlet 方法是一种二阶积分器，源于对哈密顿算子的对称 Strang 分裂。一个步长 $h$ 的流通过组合各组成部分的精确流来近似：\n$$\n\\Phi_H^h \\approx \\Phi_V^{h/2} \\circ \\Phi_T^h \\circ \\Phi_V^{h/2}\n$$\n设 $(q_n, p_n)$ 为时间 $t_n$ 时的状态。为了计算时间 $t_{n+1} = t_n+h$ 时的状态 $(q_{n+1}, p_{n+1})$，我们应用以下组合序列：\n\n1.  **动量的第一个半步：** 对 $(q_n, p_n)$ 应用流 $\\Phi_V^{h/2}$。\n    $$\n    (q', p') = \\Phi_V^{h/2}(q_n, p_n) = (q_n, p_n + \\frac{h}{2} F(q_n))\n    $$\n    我们将中间动量表示为 $p_{n+\\frac{1}{2}} = p_n + \\frac{h}{2} F(q_n)$。此时状态为 $(q_n, p_{n+\\frac{1}{2}})$。此步骤需要在 $q_n$ 处进行一次力评估。\n\n2.  **位置的完整步长：** 对中间状态 $(q_n, p_{n+\\frac{1}{2}})$ 应用流 $\\Phi_T^h$。\n    $$\n    (q'', p'') = \\Phi_T^h(q_n, p_{n+\\frac{1}{2}}) = (q_n + h M^{-1} p_{n+\\frac{1}{2}}, p_{n+\\frac{1}{2}})\n    $$\n    这定义了新位置 $q_{n+1} = q_n + h M^{-1} p_{n+\\frac{1}{2}}$。此时状态为 $(q_{n+1}, p_{n+\\frac{1}{2}})$。\n\n3.  **动量的第二个半步：** 对状态 $(q_{n+1}, p_{n+\\frac{1}{2}})$ 应用流 $\\Phi_V^{h/2}$。\n    $$\n    (q_{n+1}, p_{n+1}) = \\Phi_V^{h/2}(q_{n+1}, p_{n+\\frac{1}{2}}) = (q_{n+1}, p_{n+\\frac{1}{2}} + \\frac{h}{2} F(q_{n+1}))\n    $$\n    这定义了最终动量 $p_{n+1}$。此步骤需要在新位置 $q_{n+1}$ 处进行第二次力评估。\n\n**算法实现和力缓存**\n\n结合以上步骤即可得到 velocity-Verlet 算法。让我们以一种突出计算流程和存储的方式来编写它。变量 $p_{n+\\frac{1}{2}}$ 是一个中间量，不需要在时间步之间存储。\n\n从 $(q_n, p_n)$ 到 $(q_{n+1}, p_{n+1})$ 的单步计算如下：\n1.  计算 $p_{n+\\frac{1}{2}} = p_n + \\frac{h}{2} F(q_n)$。\n2.  计算 $q_{n+1} = q_n + h M^{-1} p_{n+\\frac{1}{2}}$。\n3.  在新位置评估力 $F(q_{n+1})$。\n4.  计算 $p_{n+1} = p_{n+\\frac{1}{2}} + \\frac{h}{2} F(q_{n+1})$。\n\n为了通过力缓存高效地实现这一点，我们观察到步骤 1 中所需的力 $F(q_n)$ 与上一个时间步结束时（在步骤 3 中）计算的力 $F(q_{n-1+1})$ 相同。这使得我们在主积分循环中每步只使用一次力评估。在循环开始前需要进行一次初始的力评估。\n\n一个 $N$ 步积分的伪代码如下：\n\n**算法：带有力缓存的 Velocity-Verlet**\n1.  **初始化：**\n    *   设置初始状态：$q \\leftarrow q_0, p \\leftarrow p_0$。\n    *   初始化力缓存：`force_cache` $\\leftarrow F(q_0)$。\n    *   初始化计数器：`force_eval_count` $\\leftarrow 1$。\n\n2.  **积分循环：** 对于 $n$ 从 $0$ 到 $N-1$：\n    *   (a) 使用缓存的力更新动量半步：\n        $p \\leftarrow p + \\frac{h}{2} \\cdot \\text{force\\_cache}$。\n        （*此时，$p$ 保持 $p_{n+\\frac{1}{2}}$ 的值*）。\n    *   (b) 更新位置一个完整步长：\n        $q \\leftarrow q + h \\cdot M^{-1}p$。\n        （*此时，$q$ 保持 $q_{n+1}$ 的值*）。\n    *   (c) 计算新的力并更新缓存：\n        `force_cache` $\\leftarrow F(q)$。\n        `force_eval_count` $\\leftarrow$ `force_eval_count` $+ 1$。\n    *   (d) 用第二个半步完成动量更新：\n        $p \\leftarrow p + \\frac{h}{2} \\cdot \\text{force\\_cache}$。\n        （*此时，$(q,p)$ 保持 $(q_{n+1}, p_{n+1})$ 的值*）。\n\n3.  **终止：** 最终状态为 $(q, p)$，总的力评估次数为 `force_eval_count`。对于 $N$ 步，该计数将为 $N+1$。\n\n**指标计算**\n-   **能量偏差**：在整个前向积分过程中，在每一步 $k=0, \\dots, N$ 计算哈密顿量 $H(q_k, p_k)$。$\\Delta H_{\\max}$ 是与初始能量 $H(q_0, p_0)$ 的最大绝对差值，$\\Delta H_{\\mathrm{final}}$ 是在最终步 $N$ 的绝对差值。\n-   **时间可逆性**：该方法的时间可逆性是其对称组合的结果。为了进行数值测试，我们从 $(q_0, p_0)$ 开始，以步长 $h$ 向前积分 $N$ 步得到 $(q_N, p_N)$。然后我们从 $(q_N, p_N)$ 开始，使用步长 $-h$ 向后积分 $N$ 步。得到的状态 $(q_{\\mathrm{back}}, p_{\\mathrm{back}})$ 应接近 $(q_0, p_0)$。误差 $\\varepsilon_{\\mathrm{rev}} = \\left\\| q_{\\mathrm{back}} - q_0 \\right\\|_2 + \\left\\| p_{\\mathrm{back}} - p_0 \\right\\|_2$ 衡量了偏差，对于时间可逆方法，该偏差预计在机器精度量级。\n\n接下来的实现将为四个测试用例中的每一个定义具体的哈密顿量、势能和力函数，然后应用上述算法来计算所需的指标。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that defines test cases, runs the simulations,\n    and prints the results in the required format.\n    \"\"\"\n\n    def integrator(V_func, F_func, m, q_start, p_start, h, N):\n        \"\"\"\n        Generic velocity-Verlet integrator.\n\n        Args:\n            V_func: Potential energy function V(q).\n            F_func: Force function F(q) = -grad(V).\n            m: Mass vector (diagonal of mass matrix).\n            q_start: Initial position vector.\n            p_start: Initial momentum vector.\n            h: Time step size.\n            N: Number of steps.\n\n        Returns:\n            A tuple containing:\n            - q_final (np.array): Final position.\n            - p_final (np.array): Final momentum.\n            - H_history (list): History of Hamiltonian values at each step.\n            - force_eval_count (int): Total number of force evaluations.\n        \"\"\"\n        q = q_start.copy()\n        p = p_start.copy()\n\n        def hamiltonian(pos, mom):\n            kinetic = 0.5 * np.sum(mom**2 / m)\n            potential = V_func(pos)\n            return kinetic + potential\n\n        H_history = [hamiltonian(q, p)]\n        \n        # Initial force evaluation before the loop\n        force = F_func(q)\n        force_eval_count = 1\n\n        for _ in range(N):\n            # 1. Half-step momentum update\n            p += 0.5 * h * force\n            \n            # 2. Full-step position update\n            q += h * (p / m)\n            \n            # 3. Compute new force (and count it)\n            force = F_func(q)\n            force_eval_count += 1\n            \n            # 4. Second half-step momentum update\n            p += 0.5 * h * force\n            \n            H_history.append(hamiltonian(q,p))\n\n        return q, p, H_history, force_eval_count\n\n    def run_case(case_params):\n        \"\"\"\n        Runs a single test case and computes all required metrics.\n        \"\"\"\n        d = case_params['d']\n        m = case_params['m']\n        V_func = case_params['V']\n        F_func = case_params['F']\n        q0 = case_params['q0']\n        p0 = case_params['p0']\n        h = case_params['h']\n        N = case_params['N']\n        \n        # Ensure inputs are numpy arrays for consistent vector operations\n        m = np.array(m, dtype=float)\n        q0 = np.array(q0, dtype=float)\n        p0 = np.array(p0, dtype=float)\n\n        # 1. Forward integration\n        q_final, p_final, H_history, force_evals = integrator(V_func, F_func, m, q0, p0, h, N)\n        \n        H0 = H_history[0]\n        H_final = H_history[-1]\n        \n        # Metric 1: Max absolute energy deviation\n        delta_H_max = np.max(np.abs(np.array(H_history) - H0))\n        \n        # Metric 2: Final absolute energy deviation\n        delta_H_final = np.abs(H_final - H0)\n        \n        # Metric 4: Force evaluation count check\n        force_count_ok = (force_evals == N + 1)\n        \n        # 2. Backward integration for time reversal error\n        q_back, p_back, _, _ = integrator(V_func, F_func, m, q_final, p_final, -h, N)\n        \n        # Metric 3: Time-reversal error\n        eps_rev = np.linalg.norm(q_back - q0) + np.linalg.norm(p_back - p0)\n        \n        return delta_H_max, delta_H_final, eps_rev, force_count_ok\n\n    # Define the four test cases\n    test_cases = [\n        # Case A: 1D Harmonic Oscillator\n        {\n            'd': 1, 'm': [1.0], 'k': 1.0,\n            'V': lambda q, k=1.0: 0.5 * k * q[0]**2,\n            'F': lambda q, k=1.0: np.array([-k * q[0]]),\n            'q0': [1.0], 'p0': [0.0], 'h': 0.1, 'N': 1000\n        },\n        # Case B: 1D Quartic Oscillator\n        {\n            'd': 1, 'm': [1.0],\n            'V': lambda q: 0.25 * q[0]**4,\n            'F': lambda q: np.array([-q[0]**3]),\n            'q0': [1.0], 'p0': [0.0], 'h': 0.05, 'N': 1000\n        },\n        # Case C: 1D Free Particle\n        {\n            'd': 1, 'm': [2.0],\n            'V': lambda q: 0.0,\n            'F': lambda q: np.array([0.0]),\n            'q0': [3.0], 'p0': [4.0], 'h': 0.2, 'N': 100\n        },\n        # Case D: 2D Anisotropic Harmonic Oscillator\n        {\n            'd': 2, 'm': [1.0, 2.0], 'k': [1.0, 0.5],\n            'V': lambda q, k1=1.0, k2=0.5: 0.5 * (k1 * q[0]**2 + k2 * q[1]**2),\n            'F': lambda q, k1=1.0, k2=0.5: np.array([-k1 * q[0], -k2 * q[1]]),\n            'q0': [1.0, 2.0], 'p0': [0.0, 0.5], 'h': 0.07, 'N': 800\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = run_case(case)\n        all_results.extend(results)\n\n    # Format and print the final output string\n    result_str = ','.join(map(str, all_results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "任何数值方法的一个关键特征是其精度阶，它描述了误差如何随着步长的减小而变化。本练习将引导你设计一个数值实验，以经验性地验证Störmer-Verlet方法的二阶精度。通过分析最大能量误差随步长 $h$ 的标度关系，你将确认它遵循 $O(h^2)$ 的趋势，这是该方法对称分裂构造的直接结果。",
            "id": "3782626",
            "problem": "考虑一个可分离哈密顿系统，其广义位置为 $q \\in \\mathbb{R}^d$，共轭动量为 $p \\in \\mathbb{R}^d$，哈密顿量由 $H(q,p) = T(p) + V(q)$ 给出，其中 $T(p)$ 是动能，$V(q)$ 是势能。其正则运动方程为 $\\dot{q} = \\partial H / \\partial p$ 和 $\\dot{p} = -\\partial H / \\partial q$。Störmer-Verlet 方法是一种用于此类可分离哈密顿量的辛、时间可逆的数值积分器。设计并实现一个数值实验，通过改变时间步长 $h$ 来经验性地证明，在固定的时间区间内，Störmer-Verlet 方法的最大绝对能量误差按 $O(h^2)$ 的规律缩放。\n\n你的程序必须实现 Störmer-Verlet 方法来对以下四个测试系统进行积分，每个系统都用无量纲参数和初始数据指定。所有的能量和时间都应以无量纲单位处理，角度必须以弧度为单位。\n\n1. 一维谐振子：$H(q,p) = \\frac{p^2}{2m} + \\frac{k}{2} q^2$，参数为 $m = 1$, $k = 1$, $q(0) = 1$, $p(0) = 0$。\n2. 非线性摆：$H(q,p) = \\frac{p^2}{2m} + mgL \\left(1 - \\cos(q)\\right)$，参数为 $m = 1$, $g = 1$, $L = 1$, $q(0) = 1$ (弧度), $p(0) = 0$。\n3. 一维双势阱：$H(q,p) = \\frac{p^2}{2m} + \\frac{1}{4}\\left(q^2 - 1\\right)^2$，参数为 $m = 1$, $q(0) = 0$, $p(0) = 1$。\n4. 二维各向异性谐振子：$H(q,p) = \\frac{p_1^2}{2m_1} + \\frac{p_2^2}{2m_2} + \\frac{k_1}{2} q_1^2 + \\frac{k_2}{2} q_2^2$，参数为 $m_1 = 1$, $m_2 = 2$, $k_1 = 1$, $k_2 = 4$, $q(0) = (1, 0.5)$, $p(0) = (0, 0)$。\n\n对每个系统，在固定时间区间 $[0, T]$ 上进行积分，其中 $T = 50$。对于集合 $\\{0.4, 0.2, 0.1, 0.05, 0.025\\}$ 中的每个时间步长 $h$，定义 $N = \\operatorname{round}(T / h)$，并使用由此产生的均匀步长 $\\tilde{h} = T / N$。对于每个 $\\tilde{h}$，使用 Störmer-Verlet 方法计算离散轨迹 $\\{(q_n, p_n)\\}_{n=0}^N$，并评估最大绝对能量偏差\n$$\n\\Delta H_{\\max}(\\tilde{h}) = \\max_{0 \\le n \\le N} \\left| H(q_n, p_n) - H(q_0, p_0) \\right|.\n$$\n通过对数据对 $\\left(\\log(\\tilde{h}), \\log\\left(\\Delta H_{\\max}(\\tilde{h})\\right)\\right)$ 进行最小二乘线性拟合来估计标度指数 $p$，即拟合 $\\log\\left(\\Delta H_{\\max}(\\tilde{h})\\right) \\approx a + p \\log(\\tilde{h})$ 并报告斜率 $p$。\n\n测试套件和答案规范：\n- 使用上面列出的四个系统，固定的结束时间 $T = 50$，以及步长 $h \\in \\{0.4, 0.2, 0.1, 0.05, 0.025\\}$。\n- 对每个系统，按所述方法计算斜率 $p$。\n- 你的程序应生成单行输出，其中包含按上述四个系统顺序排列的斜率，四舍五入到三位小数，并以逗号分隔的列表形式用方括号括起来，例如 $[p_1, p_2, p_3, p_4]$。",
            "solution": "该问题要求设计一个数值实验，以经验性地验证 Störmer-Verlet 方法在能量守恒方面对几个可分离哈密顿系统的精度阶数。任务的核心是实现积分器，用一组递减的时间步长模拟动力学过程，测量最大能量偏差，然后使用对数-对数回归来估计标度指数，理论上该指数预期为 $2$。\n\n首先，我们形式化物理和数值框架。一个可分离哈密顿系统由一个哈密顿函数 $H(q, p)$ 描述，该函数可以分解为一个仅依赖于动量 $p \\in \\mathbb{R}^d$ 的动能项 $T(p)$ 和一个仅依赖于位置 $q \\in \\mathbb{R}^d$ 的势能项 $V(q)$，使得 $H(q, p) = T(p) + V(q)$。系统的时间演化由哈密顿方程控制：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = \\nabla_p T(p)\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q} = -\\nabla_q V(q) \\equiv F(q)\n$$\n其中 $F(q)$ 是力。对于所讨论的系统，动能具有标准二次型 $T(p) = \\frac{1}{2} p^T M^{-1} p$，其中 $M$ 是（通常为对角）质量矩阵。这得到 $\\nabla_p T(p) = M^{-1}p$。\n\nStörmer-Verlet 方法是一种几何积分器，具体来说是一种二阶辛方法，因其应用于此类系统时具有出色的长期能量稳定性而闻名。该算法的位置 Verlet 变体使用以下三个步骤将时间 $t_n$ 的状态 $(q_n, p_n)$ 推进到时间 $t_{n+1} = t_n + \\tilde{h}$ 的状态 $(q_{n+1}, p_{n+1})$：\n1. 动量的半步更新：$p_{n+1/2} = p_n + \\frac{\\tilde{h}}{2} F(q_n)$\n2. 位置的整步更新：$q_{n+1} = q_n + \\tilde{h} M^{-1} p_{n+1/2}$\n3. 动量的最后半步更新：$p_{n+1} = p_{n+1/2} + \\frac{\\tilde{h}}{2} F(q_{n+1})$\n\n该数值实验旨在证明哈密顿量的最大误差 $\\Delta H_{\\max}(\\tilde{h}) = \\max_{0 \\le n \\le N} |H(q_n, p_n) - H(q_0, p_0)|$ 随步长呈二次方缩放，即 $\\Delta H_{\\max}(\\tilde{h}) = O(\\tilde{h}^2)$。这种关系意味着 $\\log(\\Delta H_{\\max})$ 对 $\\log(\\tilde{h})$ 的图应近似为一条斜率为 $2$ 的直线。我们通过对一组步长 $\\tilde{h}$ 进行模拟所生成的数据点 $(\\log(\\tilde{h}), \\log(\\Delta H_{\\max}(\\tilde{h})))$ 进行线性最小二乘拟合，来估计这个斜率（记为 $p$）。问题指定了一组初始步长 $h \\in \\{0.4, 0.2, 0.1, 0.05, 0.025\\}$ 和总积分时间 $T=50$。对于每个 $h$，步数为 $N = \\operatorname{round}(T/h)$，实际使用的步长为 $\\tilde{h} = T/N$。\n\n该实验针对四个不同的物理系统进行：\n\n1.  **一维谐振子**：$H(q,p) = \\frac{p^2}{2m} + \\frac{k}{2} q^2$。当 $m=1$ 且 $k=1$ 时，力为 $F(q) = -q$。质量矩阵是标量 $M=1$。初始条件为 $q(0)=1, p(0)=0$。\n\n2.  **非线性摆**：$H(q,p) = \\frac{p^2}{2m} + mgL(1 - \\cos(q))$。当 $m=1, g=1, L=1$ 时，力为 $F(q) = -\\sin(q)$，且 $M=1$。初始条件为 $q(0)=1, p(0)=0$。\n\n3.  **一维双势阱**：$H(q,p) = \\frac{p^2}{2m} + \\frac{1}{4}(q^2 - 1)^2$。当 $m=1$ 时，力为 $F(q) = - (q^3 - q) = q-q^3$，且 $M=1$。初始条件为 $q(0)=0, p(0)=1$。\n\n4.  **二维各向异性谐振子**：$H(q,p) = \\frac{p_1^2}{2m_1} + \\frac{p_2^2}{2m_2} + \\frac{k_1}{2} q_1^2 + \\frac{k_2}{2} q_2^2$。参数为 $m_1=1, m_2=2, k_1=1, k_2=4$ 时，力矢量为 $F(q) = (-k_1 q_1, -k_2 q_2) = (-q_1, -4q_2)$。质量矩阵为 $M = \\operatorname{diag}(m_1, m_2) = \\operatorname{diag}(1, 2)$。初始条件为 $q(0)=(1, 0.5), p(0)=(0, 0)$。\n\n对每个系统，我们遍历指定的步长，执行 Störmer-Verlet 积分，计算最大能量误差，并收集对数-对数数据。对这些数据进行线性回归，得到所需的标度指数 $p$。最终输出包含四个系统计算出的指数，四舍五入到三位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Performs a numerical experiment to determine the energy error scaling\n    of the Störmer-Verlet method for four different Hamiltonian systems.\n    \"\"\"\n    T_final = 50.0\n    h_values = [0.4, 0.2, 0.1, 0.05, 0.025]\n\n    # Definitions for the four test systems\n    systems = [\n        # System 1: One-dimensional harmonic oscillator\n        {\n            \"name\": \"Harmonic Oscillator (1D)\",\n            \"q0\": np.array([1.0]),\n            \"p0\": np.array([0.0]),\n            \"masses\": np.array([1.0]),\n            \"force\": lambda q: -q,\n            \"potential\": lambda q: 0.5 * q[0]**2,\n        },\n        # System 2: Nonlinear pendulum\n        {\n            \"name\": \"Nonlinear Pendulum (1D)\",\n            \"q0\": np.array([1.0]),\n            \"p0\": np.array([0.0]),\n            \"masses\": np.array([1.0]),\n            \"force\": lambda q: -np.sin(q),\n            \"potential\": lambda q: 1.0 - np.cos(q[0]),\n        },\n        # System 3: One-dimensional double-well potential\n        {\n            \"name\": \"Double-Well Potential (1D)\",\n            \"q0\": np.array([0.0]),\n            \"p0\": np.array([1.0]),\n            \"masses\": np.array([1.0]),\n            \"force\": lambda q: q - q**3,\n            \"potential\": lambda q: 0.25 * (q[0]**2 - 1.0)**2,\n        },\n        # System 4: Two-dimensional anisotropic harmonic oscillator\n        {\n            \"name\": \"Anisotropic Oscillator (2D)\",\n            \"q0\": np.array([1.0, 0.5]),\n            \"p0\": np.array([0.0, 0.0]),\n            \"masses\": np.array([1.0, 2.0]),\n            \"force\": lambda q: np.array([-q[0], -4.0 * q[1]]),\n            \"potential\": lambda q: 0.5 * q[0]**2 + 2.0 * q[1]**2,\n        }\n    ]\n\n    slopes = []\n\n    for system_params in systems:\n        q0 = system_params[\"q0\"]\n        p0 = system_params[\"p0\"]\n        masses = system_params[\"masses\"]\n        force_func = system_params[\"force\"]\n        potential_func = system_params[\"potential\"]\n\n        def kinetic_func(p):\n            return np.sum(p**2 / (2.0 * masses))\n\n        def hamiltonian_func(q, p):\n            return kinetic_func(p) + potential_func(q)\n\n        log_h_tilde_list = []\n        log_delta_H_max_list = []\n\n        H0 = hamiltonian_func(q0, p0)\n\n        for h in h_values:\n            N = int(round(T_final / h))\n            h_tilde = T_final / N\n\n            q = np.copy(q0)\n            p = np.copy(p0)\n            \n            max_energy_error = 0.0\n\n            for _ in range(N):\n                # Störmer-Verlet (position-Verlet) integration step\n                p_half_step = p + 0.5 * h_tilde * force_func(q)\n                q = q + h_tilde * p_half_step / masses\n                p = p_half_step + 0.5 * h_tilde * force_func(q)\n\n                # Calculate energy error at the end of the step\n                H_current = hamiltonian_func(q, p)\n                energy_error = abs(H_current - H0)\n                if energy_error > max_energy_error:\n                    max_energy_error = energy_error\n            \n            log_h_tilde_list.append(np.log(h_tilde))\n            log_delta_H_max_list.append(np.log(max_energy_error))\n\n        # Perform linear regression on the log-log data to find the slope\n        lin_reg_result = linregress(log_h_tilde_list, log_delta_H_max_list)\n        slope = lin_reg_result.slope\n        slopes.append(slope)\n        \n    # Format the final results as specified\n    formatted_slopes = [f\"{s:.3f}\" for s in slopes]\n    print(f\"[{','.join(formatted_slopes)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Störmer-Verlet方法具有卓越稳定性的最深层原因是其辛性质，即它能保持相空间的几何结构。本练习将指导你设计一个数值诊断工具，通过近似计算积分器单步映射的雅可比矩阵，来检验它是否满足辛映射的定义条件。这项高级实践将你的代码实现与几何力学的核心理论直接联系起来，让你“看”到辛性质在计算中的体现。",
            "id": "3782583",
            "problem": "考虑一个可分哈密顿系统，其构型变量为 $q \\in \\mathbb{R}^d$，动量为 $p \\in \\mathbb{R}^d$，因此状态为 $z = (q,p) \\in \\mathbb{R}^{2d}$。该动力学由一个可分哈密顿量 $H(q,p) = T(p) + V(q)$ 的哈密顿方程所支配，其中 $T$ 是动能，$V$ 是势能，即 $\\dot{q} = \\nabla_p T(p)$ 和 $\\dot{p} = -\\nabla_q V(q)$。$\\mathbb{R}^{2d}$ 上的典范辛形式由常数矩阵 $J \\in \\mathbb{R}^{2d \\times 2d}$ 表示，其块结构为 $J = \\begin{bmatrix} 0  I \\\\ -I  0 \\end{bmatrix}$，其中 $I$ 表示 $d \\times d$ 的单位矩阵。一个光滑映射 $\\Phi_h : \\mathbb{R}^{2d} \\to \\mathbb{R}^{2d}$ 是辛的，当且仅当其雅可比矩阵 $D\\Phi_h(z)$ 满足其拉回保持典范辛形式的条件。\n\n仅使用这些基本事实，设计一个数值诊断方法，以评估应用于可分哈密顿量的 Störmer-Verlet 方法（也称为速度 Verlet 方法）所定义的单步映射的辛性。您的诊断方法必须使用中心有限差分，在给定状态 $z$ 处，以一个小的扰动量 $\\varepsilon$ 来近似雅可比矩阵 $D\\Phi_h(z)$，然后使用拉回的典范形式与典范形式之差的矩阵范数来量化与辛性的偏差。具体来说，您必须：\n- 为可分哈密顿量 $H(q,p) = T(p) + V(q)$ 实现一个正确的 Störmer-Verlet 单步映射，使用力 $f(q) = -\\nabla_q V(q)$ 和速度场 $v(p) = \\nabla_p T(p)$。\n- 在给定状态 $z$ 处，通过沿 $\\mathbb{R}^{2d}$ 的标准基使用中心有限差分，以固定的 $\\varepsilon = 10^{-7}$ 来近似雅可比矩阵 $D\\Phi_h(z)$。\n- 为适当的维度 $d$ 构建典范辛矩阵 $J$。\n- 在 $z$ 处构造辛性缺陷矩阵，并计算其 Frobenius 范数作为标量诊断值。您必须使用中心有限差分和 Frobenius 范数，并且在任何出现角度的地方都必须使用以弧度为单位的角度。\n\n您必须将您的诊断方法应用于以下测试套件，并为每种情况返回一个实数，该实数等于 Störmer-Verlet 映射的辛性缺陷矩阵的 Frobenius 范数：\n- 情况 1（单自由度谐振子）：设 $d=1$。设 $T(p) = \\tfrac{1}{2} p^2$ 和 $V(q) = \\tfrac{1}{2} \\omega^2 q^2$，其中 $\\omega = 1.7$。使用初始状态 $q = 0.3$，$p = -0.4$ 和步长 $h = 0.1$。\n- 情况 2（接近线性稳定性阈值的单自由度谐振子）：设 $d=1$。使用与情况 1 相同的 $T$ 和 $V$，其中 $\\omega = 1.7$。使用相同的初始状态 $q = 0.3$，$p = -0.4$。使用步长 $h = 1.99/\\omega$。\n- 情况 3（处于平衡状态的单自由度非线性摆）：设 $d=1$。设 $T(p) = \\tfrac{1}{2} p^2$ 和 $V(q) = 1 - \\cos(q)$。角度必须以弧度为单位。使用初始状态 $q = 0.0$，$p = 0.0$ 和步长 $h = 0.3$。\n- 情况 4（偏离平衡状态的单自由度非线性摆）：设 $d=1$。使用与情况 3 相同的 $T$ 和 $V$。使用初始状态 $q = 1.0$，$p = 0.2$（角度以弧度为单位）和步长 $h = 0.3$。\n- 情况 5（双自由度解耦谐振子）：设 $d=2$。设 $T(p) = \\tfrac{1}{2}(p_1^2 + p_2^2)$ 和 $V(q) = \\tfrac{1}{2}(\\omega_1^2 q_1^2 + \\omega_2^2 q_2^2)$，其中 $\\omega_1 = 1.0$ 和 $\\omega_2 = 1.5$。使用初始状态 $(q_1,q_2,p_1,p_2) = (0.2,-0.1,-0.3,0.4)$ 和步长 $h = 0.2$。\n\n除角度必须以弧度为单位外，所有量均为无量纲。不需要其他物理单位。您的程序必须生成单行输出，其中包含按上述情况顺序排列的五个诊断结果，格式为方括号内以逗号分隔的列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是按规定计算的第 $i$ 种情况下辛性缺陷矩阵的 Frobenius 范数。结果必须是按要求顺序和格式打印的浮点数。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于哈密顿力学和几何数值积分的原理，问题设定良好，提供了所有必要的数据和条件，并且表述客观。该问题是计算物理学中一个标准且具有指导意义的练习。\n\n任务是数值验证 Störmer-Verlet 积分方法的辛性。一个动力学系统由一个可分哈密顿量 $H(q,p) = T(p) + V(q)$ 描述，其中 $q \\in \\mathbb{R}^d$ 是广义坐标，$p \\in \\mathbb{R}^d$ 是共轭动量。系统的状态是 $2d$ 维相空间 $\\mathbb{R}^{2d}$ 中的一个点 $z = (q,p)$。系统的演化由哈密顿方程支配：\n$$\n\\dot{q} = \\nabla_p T(p)\n$$\n$$\n\\dot{p} = -\\nabla_q V(q)\n$$\n这个方程组可以紧凑地写成 $\\dot{z} = X_H(z)$，其中 $X_H$ 是与 $H$ 相关联的哈密顿向量场。系统的精确流 $\\phi_t$ 是一个映射，它将初始状态 $z_0$ 经过时间 $t$ 后映射到状态 $z(t) = \\phi_t(z_0)$。哈密顿流的一个关键性质是它们是辛的。一个映射 $\\Psi: \\mathbb{R}^{2d} \\to \\mathbb{R}^{2d}$ 如果保持典范辛二形式，则它是辛的。用矩阵形式表示，这等价于其雅可比矩阵 $D\\Psi(z)$ 对所有 $z$ 满足条件：\n$$\n(D\\Psi(z))^T J D\\Psi(z) = J\n$$\n其中 $J$ 是由下式给出的 $2d \\times 2d$ 典范辛矩阵：\n$$\nJ = \\begin{bmatrix} 0  I \\\\ -I  0 \\end{bmatrix}\n$$\n这里，$I$ 是 $d \\times d$ 的单位矩阵，$0$ 是 $d \\times d$ 的零矩阵。\n\n理想情况下，哈密顿系统的数值积分器也应生成辛映射，以保持相空间的几何结构，这能带来出色的长期稳定性和定性准确性。Störmer-Verlet 方法是这类几何积分器的一个著名例子。其单步映射 $\\Phi_h: z_n \\to z_{n+1}$ 是精确辛的。这一性质源于其构造方式，即通过对哈密顿算子进行对称分裂，这被称为 Trotter-Suzuki 分裂或李分裂（Lie splitting）。具体来说，该方法是哈密顿量组成部分 $T(p)$ 和 $V(q)$ 的精确流的复合。Störmer-Verlet 算法的速度 Verlet 形式，对于从状态 $(q_n, p_n)$ 到 $(q_{n+1}, p_{n+1})$ 的步长 $h$ 如下：\n1.  在势 $V$ 下更新半步动量：$p_{n+1/2} = p_n - \\frac{h}{2} \\nabla_q V(q_n)$\n2.  在动能 $T$ 下更新整步位置：$q_{n+1} = q_n + h \\nabla_p T(p_{n+1/2})$\n3.  在势 $V$ 下更新第二个半步动量：$p_{n+1} = p_{n+1/2} - \\frac{h}{2} \\nabla_q V(q_{n+1})$\n\n对于问题中给出的哈密顿量，动能具有标准形式 $T(p) = \\frac{1}{2} p^T p$，这得到 $\\nabla_p T(p) = p$。将力定义为 $f(q) = -\\nabla_q V(q)$，单步映射 $\\Phi_h$ 实现如下：\n1.  $p_{n+1/2} = p_n + \\frac{h}{2} f(q_n)$\n2.  $q_{n+1} = q_n + h \\cdot p_{n+1/2}$\n3.  $p_{n+1} = p_{n+1/2} + \\frac{h}{2} f(q_{n+1})$\n\n评估辛性的诊断方法包括：在给定点 $z=(q,p)$ 处数值计算此映射的雅可比矩阵 $D\\Phi_h(z)$，然后量化其与辛条件的偏差。雅可比矩阵是一个 $2d \\times 2d$ 的矩阵，其第 $j$ 列是映射输出相对于其输入第 $j$ 个分量的偏导数，即 $\\frac{\\partial \\Phi_h}{\\partial z_j}$。我们使用二阶精确的中心有限差分公式，以一个小的扰动 $\\varepsilon = 10^{-7}$ 来近似这些列：\n$$\n\\frac{\\partial \\Phi_h}{\\partial z_j}(z) \\approx \\frac{\\Phi_h(z + \\varepsilon e_j) - \\Phi_h(z - \\varepsilon e_j)}{2\\varepsilon}\n$$\n其中 $e_j$ 是 $\\mathbb{R}^{2d}$ 中的第 $j$ 个标准基向量。\n\n设数值近似的雅可比矩阵为 $A$。然后我们构造辛性缺陷矩阵 $S$：\n$$\nS(z) = A^T J A - J\n$$\n理论上，对于一个精确辛的映射和一个精确计算的雅可比矩阵，该矩阵将恒等于零。在实践中，使用有限差分近似和浮点运算将导致一个虽小但非零的矩阵。这个缺陷的大小由其 Frobenius 范数 $\\|S(z)\\|_F$ 来量化：\n$$\n\\|S(z)\\|_F = \\sqrt{\\sum_{i=1}^{2d} \\sum_{j=1}^{2d} |S_{ij}|^2}\n$$\n这个标量值作为我们的诊断指标。一个非常小的值（接近机器精度）证实了所实现映射的辛性。\n\n该过程应用于五个测试案例。对于每个案例，使用适当的维度 $d$、初始状态 $z_0$、步长 $h$ 和力函数 $f(q)$ 来计算诊断值。\n-   情况 1 和 2：一维谐振子，$d=1$，$V(q) = \\frac{1}{2}\\omega^2 q^2$，其中 $\\omega=1.7$。力为 $f(q) = -\\omega^2 q$。\n-   情况 3 和 4：一维非线性摆，$d=1$，$V(q) = 1 - \\cos(q)$。力为 $f(q) = -\\sin(q)$。角度以弧度为单位。\n-   情况 5：二维解耦谐振子，$d=2$，$V(q) = \\frac{1}{2}(\\omega_1^2 q_1^2 + \\omega_2^2 q_2^2)$，其中 $\\omega_1=1.0$ 且 $\\omega_2=1.5$。力向量为 $f(q) = (-\\omega_1^2 q_1, -\\omega_2^2 q_2)^T$。\n状态向量分量的顺序为 $(q_1, \\dots, q_d, p_1, \\dots, p_d)$。",
            "answer": "```python\nimport numpy as np\n\ndef stormer_verlet_step(z, h, d, force_func, v_func):\n    \"\"\"\n    Performs a single step of the Störmer-Verlet (velocity Verlet) method.\n    \n    Args:\n        z (np.ndarray): The current state vector [q, p] of size 2d.\n        h (float): The time step size.\n        d (int): The dimension of the configuration space.\n        force_func (callable): The force function f(q) = -grad_q V(q).\n        v_func (callable): The velocity function v(p) = grad_p T(p).\n        \n    Returns:\n        np.ndarray: The state vector at the next time step.\n    \"\"\"\n    q = z[:d]\n    p = z[d:]\n    \n    p_half = p + (h / 2.0) * force_func(q)\n    q_next = q + h * v_func(p_half)\n    p_next = p_half + (h / 2.0) * force_func(q_next)\n    \n    return np.concatenate((q_next, p_next))\n\ndef compute_symplecticity_defect_norm(d, z0, h, force_func):\n    \"\"\"\n    Computes the Frobenius norm of the symplecticity defect matrix.\n    \n    Args:\n        d (int): The dimension of the configuration space.\n        z0 (np.ndarray): The state vector at which to compute the Jacobian.\n        h (float): The time step size for the integrator.\n        force_func (callable): The force function f(q).\n        \n    Returns:\n        float: The Frobenius norm of the defect matrix.\n    \"\"\"\n    eps = 1e-7\n    dim = 2 * d\n\n    # For all given problems, T(p) is quadratic, so we can define a general v_func\n    # based on masses. Defaulting to unit masses as per problem descriptions\n    # where not specified otherwise (T(p) = 1/2 p^2 means mass=1).\n    if d == 2 and 'q_1' in force_func.__code__.co_varnames: # Heuristic for case 5\n        masses = np.array([1.0, 1.0])\n    else: # All other cases are d=1 with T=p^2/2 so mass=1\n        masses = np.array([1.0]*d)\n        \n    v_func = lambda p: p / masses\n\n\n    # The problem implies T(p) = 1/2 p^T p for all cases, which means v(p) = p.\n    # The solution text correctly simplifies this.\n    v_func = lambda p: p\n\n\n    # Define the one-step map for the given parameters\n    def one_step_map(z):\n        return stormer_verlet_step(z, h, d, force_func, v_func)\n\n    # Compute Jacobian using central differences\n    jacobian = np.zeros((dim, dim))\n    for j in range(dim):\n        e_j = np.zeros(dim)\n        e_j[j] = 1.0\n        z_plus = z0 + eps * e_j\n        z_minus = z0 - eps * e_j\n        \n        map_plus = one_step_map(z_plus)\n        map_minus = one_step_map(z_minus)\n        \n        jacobian[:, j] = (map_plus - map_minus) / (2.0 * eps)\n        \n    # Construct canonical symplectic matrix J\n    I_d = np.identity(d)\n    J = np.block([\n        [np.zeros((d, d)), I_d],\n        [-I_d, np.zeros((d, d))]\n    ])\n\n    # Compute defect matrix and its Frobenius norm\n    A = jacobian\n    defect_matrix = A.T @ J @ A - J\n    norm = np.linalg.norm(defect_matrix, 'fro')\n    \n    return norm\n\ndef solve():\n    \"\"\"\n    Runs the diagnostic for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: 1D Harmonic Oscillator\n        {\n            'd': 1,\n            'z0': np.array([0.3, -0.4]),\n            'h': 0.1,\n            'force': lambda q: -1.7**2 * q\n        },\n        # Case 2: 1D Harmonic Oscillator (near stability threshold)\n        {\n            'd': 1,\n            'z0': np.array([0.3, -0.4]),\n            'h': 1.99 / 1.7,\n            'force': lambda q: -1.7**2 * q\n        },\n        # Case 3: 1D Nonlinear Pendulum (equilibrium)\n        {\n            'd': 1,\n            'z0': np.array([0.0, 0.0]),\n            'h': 0.3,\n            'force': lambda q: -np.sin(q)\n        },\n        # Case 4: 1D Nonlinear Pendulum (non-equilibrium)\n        {\n            'd': 1,\n            'z0': np.array([1.0, 0.2]),\n            'h': 0.3,\n            'force': lambda q: -np.sin(q)\n        },\n        # Case 5: 2D Decoupled Harmonic Oscillator\n        {\n            'd': 2,\n            'z0': np.array([0.2, -0.1, -0.3, 0.4]),\n            'h': 0.2,\n            'force': lambda q: np.array([-1.0**2 * q[0], -1.5**2 * q[1]])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_symplecticity_defect_norm(\n            case['d'], case['z0'], case['h'], case['force']\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}